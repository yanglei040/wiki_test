{"hands_on_practices": [{"introduction": "计算物理学中的许多误差源于浮点数算术的有限精度。这个练习通过一个狭义相对论中的经典例子，让你亲身体验“灾难性相消”——两个几乎相等的数相减导致相对精度的大幅损失。通过对洛伦兹因子$\\gamma$的表达式进行代数重构，你将学会如何识别并避免这类数值陷阱，这是编写稳健科学计算代码的一项关键技能。[@problem_id:2439862]", "problem": "一个狭义相对论动力学模拟将动能计算为 $K = mc^{2}(\\gamma - 1)$，其中洛伦兹因子定义为 $\\gamma = 1/\\sqrt{1 - v^{2}/c^{2}}$。对于速度 $v \\ll c$ 的粒子，直接计算 $\\gamma$ 然后得到 $\\gamma - 1$ 会由于相消误差而引入较大的相对数值误差。\n\n考虑一个以速度 $v = 3.0 \\ \\mathrm{m\\,s^{-1}}$ 运动的粒子。光速为 $c = 299{,}792{,}458 \\ \\mathrm{m\\,s^{-1}}$（根据定义是精确值）。\n\n在不使用任何预先制表的近似值的情况下，推导一个用 $v$ 和 $c$ 表示 $\\gamma - 1$ 的代数表达式，该表达式可以避免在 $v \\ll c$ 时的相消误差。然后使用该表达式计算当 $v = 3.0$ 且 $c = 299{,}792{,}458$ 时 $\\gamma - 1$ 的数值。将你的答案四舍五入到六位有效数字。将最终结果表示为一个无量纲数。", "solution": "狭义相对论中的洛伦兹因子定义为\n$$\n\\gamma = \\frac{1}{\\sqrt{1 - \\beta^{2}}}, \\quad \\text{其中} \\quad \\beta \\equiv \\frac{v}{c}.\n$$\n对于动能，我们关心的量是 $\\gamma - 1$。直接计算 $\\gamma - 1 = \\frac{1}{\\sqrt{1 - \\beta^{2}}} - 1$ 在 $\\beta \\ll 1$ 时会遇到相消误差问题，因为它减去了两个都非常接近于 $1$ 的数。\n\n一个可以避免减去几乎相等的数的代数变换可以通过有理化得到：\n$$\n\\gamma - 1 \\;=\\; \\frac{1}{\\sqrt{1 - \\beta^{2}}} - 1 \\;=\\; \\frac{1 - \\sqrt{1 - \\beta^{2}}}{\\sqrt{1 - \\beta^{2}}}\n\\;=\\; \\frac{(1 - \\sqrt{1 - \\beta^{2}})(1 + \\sqrt{1 - \\beta^{2}})}{\\sqrt{1 - \\beta^{2}}(1 + \\sqrt{1 - \\beta^{2}})}\n$$\n$$\n=\\; \\frac{1 - (1 - \\beta^{2})}{\\sqrt{1 - \\beta^{2}}\\bigl(1 + \\sqrt{1 - \\beta^{2}}\\bigr)}\n\\;=\\; \\frac{\\beta^{2}}{\\sqrt{1 - \\beta^{2}}\\bigl(1 + \\sqrt{1 - \\beta^{2}}\\bigr)}.\n$$\n这个表达式避免了在分子中减去几乎相等的量；当 $\\beta \\ll 1$ 时，它是数值稳定的。\n\n对于 $\\beta \\ll 1$ ，从二项式定理得到的级数展开给出了一个同样数值稳定的进一步解析近似：\n$$\n\\gamma \\;=\\; (1 - \\beta^{2})^{-1/2} \\;=\\; 1 + \\frac{1}{2}\\beta^{2} + \\frac{3}{8}\\beta^{4} + \\cdots,\n$$\n所以\n$$\n\\gamma - 1 \\;=\\; \\frac{1}{2}\\beta^{2} + \\frac{3}{8}\\beta^{4} + \\cdots.\n$$\n因为在这种情况下 $\\beta \\equiv v/c$ 极小，所以在所要求的精度下，$\\beta^{4}$ 及更高阶的项可以忽略不计。具体来说，当 $\\beta \\sim 10^{-8}$ 时，有 $\\beta^{4} \\sim 10^{-32}$，所以项 $\\frac{3}{8}\\beta^{4}$ 是 $\\mathcal{O}(10^{-32})$ 量级，与首项 $\\frac{1}{2}\\beta^{2} \\sim 10^{-17}$ 相比，这比六位有效数字的精度要求低了许多个数量级。\n\n因此，对于所要求的数值计算，我们可以使用稳定的主导阶表达式\n$$\n\\gamma - 1 \\approx \\frac{1}{2}\\beta^{2} = \\frac{1}{2}\\left(\\frac{v}{c}\\right)^{2}。\n$$\n\n现在代入给定的值（由于要求一个数值答案，此代入是合理的）：\n$$\nv = 3.0 \\ \\mathrm{m\\,s^{-1}}, \\qquad c = 299{,}792{,}458 \\ \\mathrm{m\\,s^{-1}}.\n$$\n计算\n$$\n\\beta^{2} = \\left(\\frac{v}{c}\\right)^{2} = \\frac{v^{2}}{c^{2}} = \\frac{9}{(299{,}792{,}458)^{2}}.\n$$\n因为 $c$ 是精确值，$c^{2}$ 是精确整数\n$$\nc^{2} = 89{,}875{,}517{,}873{,}681{,}764,\n$$\n所以\n$$\n\\gamma - 1 \\approx \\frac{1}{2}\\beta^{2} = \\frac{9}{2\\,c^{2}} = \\frac{9}{179{,}751{,}035{,}747{,}363{,}528}.\n$$\n将此精确有理数转换为科学记数法，\n$$\n\\gamma - 1 \\approx 5.006925252241283 \\times 10^{-17}.\n$$\n四舍五入到六位有效数字得到\n$$\n\\gamma - 1 \\approx 5.00693 \\times 10^{-17}.\n$$\n该值为无量纲数，符合要求。被忽略的下一项 $\\frac{3}{8}\\beta^{4}$ 的量级为 $10^{-32}$，不影响所报告的六位有效数字。", "answer": "$$\\boxed{5.00693 \\times 10^{-17}}$$", "id": "2439862"}, {"introduction": "除了固有的浮点误差，我们选择的数值算法本身也是误差的来源，尤其是在求解微分方程时。本练习将引导你分析一种常见积分方法（显式欧拉法）的数值稳定性，这是模拟物理系统随时间演化的核心问题。通过推导求解阻尼谐振子时保持数值解有界的临界时间步长$\\Delta t_{\\text{crit}}$，你将深入理解算法选择如何决定模拟的成败。[@problem_id:2439889]", "problem": "考虑一个阻尼谐振子，其运动由常微分方程 (ODE) $m \\ddot{x} + \\gamma \\dot{x} + k x = 0$ 描述，其中 $m > 0$、$\\gamma > 0$ 且 $k > 0$。假设该振子是严格欠阻尼的，因此 $\\gamma^{2} < 4 m k$。引入状态变量 $x$ 和 $v = \\dot{x}$，并应用时间步长为 $\\Delta t > 0$ 的显式欧拉法，使用以下公式将状态从时间 $t_{n}$ 推进到 $t_{n+1} = t_{n} + \\Delta t$：\n$$\n\\begin{pmatrix}\nx_{n+1} \\\\\nv_{n+1}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nx_{n} \\\\\nv_{n}\n\\end{pmatrix}\n+\n\\Delta t\n\\begin{pmatrix}\nv_{n} \\\\\n-(\\gamma/m) v_{n} - (k/m) x_{n}\n\\end{pmatrix}.\n$$\n确定最大时间步长 $\\Delta t_{\\text{crit}}$，使得对于任意初始状态 $\\begin{pmatrix} x_{0} \\\\ v_{0} \\end{pmatrix}$，所得到的离散时间序列 $\\begin{pmatrix} x_{n} \\\\ v_{n} \\end{pmatrix}$ 对所有 $n \\in \\mathbb{N}$ 都保持有界。请以 $m$、$\\gamma$ 和 $k$ 的单个闭式表达式给出您的答案。请勿对答案进行四舍五入。", "solution": "该问题要求解将显式欧拉法应用于阻尼谐振子方程时的稳定性极限。问题陈述具有科学依据、是适定且客观的。这是一个关于数值稳定性的计算物理标准问题。因此，我们开始求解。\n\n该系统的常微分方程由下式给出：\n$$\nm \\ddot{x} + \\gamma \\dot{x} + k x = 0\n$$\n其中 $m > 0$、$\\gamma > 0$、$k > 0$，且系统是欠阻尼的，满足 $\\gamma^2 < 4mk$。我们引入状态向量 $\\mathbf{y} = \\begin{pmatrix} x \\\\ v \\end{pmatrix}$，其中 $v = \\dot{x}$。该一阶常微分方程组为：\n$$\n\\dot{\\mathbf{y}} = \\frac{d}{dt} \\begin{pmatrix} x \\\\ v \\end{pmatrix} = \\begin{pmatrix} v \\\\ -\\frac{k}{m}x - \\frac{\\gamma}{m}v \\end{pmatrix} = \\begin{pmatrix} 0 & 1 \\\\ -\\frac{k}{m} & -\\frac{\\gamma}{m} \\end{pmatrix} \\begin{pmatrix} x \\\\ v \\end{pmatrix}\n$$\n其形式为 $\\dot{\\mathbf{y}} = \\mathbf{M} \\mathbf{y}$，其中 $\\mathbf{M} = \\begin{pmatrix} 0 & 1 \\\\ -k/m & -\\gamma/m \\end{pmatrix}$ 是系统矩阵。\n\n显式欧拉法使用更新规则 $\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\Delta t \\, \\dot{\\mathbf{y}}_n$ 将解从时间 $t_n$ 推进到 $t_{n+1} = t_n + \\Delta t$。代入 $\\dot{\\mathbf{y}}_n = \\mathbf{M} \\mathbf{y}_n$，我们得到：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\Delta t \\, \\mathbf{M} \\mathbf{y}_n = (\\mathbf{I} + \\Delta t \\, \\mathbf{M}) \\mathbf{y}_n\n$$\n其中 $\\mathbf{I}$ 是 $2 \\times 2$ 的单位矩阵。矩阵 $\\mathbf{A} = \\mathbf{I} + \\Delta t \\, \\mathbf{M}$ 被称为放大矩阵。离散时间序列 $\\mathbf{y}_n$ 对任意初始条件保持有界，当且仅当放大矩阵的谱半径 $\\rho(\\mathbf{A})$ 小于或等于 $1$。谱半径是矩阵 $\\mathbf{A}$ 的特征值的最大模。\n\n$\\mathbf{A}$ 的特征值（记为 $\\lambda_A$）与 $\\mathbf{M}$ 的特征值（记为 $\\lambda_M$）通过关系式 $\\lambda_A = 1 + \\Delta t \\, \\lambda_M$ 相关联。因此，稳定性条件为对于矩阵 $\\mathbf{M}$ 的所有特征值 $\\lambda_M$，都有 $|1 + \\Delta t \\, \\lambda_M| \\leq 1$。\n\n首先，我们通过求解特征方程 $\\det(\\mathbf{M} - \\lambda_M \\mathbf{I}) = 0$ 来找到 $\\mathbf{M}$ 的特征值。\n$$\n\\det \\begin{pmatrix} -\\lambda_M & 1 \\\\ -k/m & -\\gamma/m - \\lambda_M \\end{pmatrix} = (-\\lambda_M)(-\\gamma/m - \\lambda_M) - (-k/m) = 0\n$$\n$$\n\\lambda_M^2 + \\frac{\\gamma}{m}\\lambda_M + \\frac{k}{m} = 0\n$$\n这个二次方程的根是：\n$$\n\\lambda_M = \\frac{-\\frac{\\gamma}{m} \\pm \\sqrt{(\\frac{\\gamma}{m})^2 - 4\\frac{k}{m}}}{2} = \\frac{-\\gamma \\pm \\sqrt{\\gamma^2 - 4mk}}{2m}\n$$\n鉴于欠阻尼条件 $\\gamma^2 < 4mk$，平方根内的项为负。因此特征值为一对共轭复数。设 $\\lambda_M = a \\pm i b$，其中 $a$ 是实部，$b$ 是虚部。\n$$\na = -\\frac{\\gamma}{2m} \\quad \\text{and} \\quad b = \\frac{\\sqrt{4mk - \\gamma^2}}{2m}\n$$\n由于两个特征值是共轭复数，稳定性条件 $|1 + \\Delta t \\, \\lambda_M| \\leq 1$ 对两者产生相同的约束。我们计算这个条件：\n$$\n|1 + \\Delta t (a + ib)|^2 \\leq 1^2\n$$\n$$\n|(1 + a\\Delta t) + i(b\\Delta t)|^2 \\leq 1\n$$\n$$\n(1 + a\\Delta t)^2 + (b\\Delta t)^2 \\leq 1\n$$\n$$\n1 + 2a\\Delta t + a^2(\\Delta t)^2 + b^2(\\Delta t)^2 \\leq 1\n$$\n$$\n2a\\Delta t + (a^2 + b^2)(\\Delta t)^2 \\leq 0\n$$\n由于 $\\Delta t > 0$，我们可以用它来除不等式两边而不改变不等号方向：\n$$\n2a + (a^2+b^2)\\Delta t \\leq 0\n$$\n由于 $a = -\\frac{\\gamma}{2m}$ 是负的，而 $(a^2+b^2)$ 是正的，我们可以解出 $\\Delta t$：\n$$\n\\Delta t \\leq \\frac{-2a}{a^2+b^2}\n$$\n项 $a^2+b^2$ 是特征值 $\\lambda_M$ 的模的平方，即 $a^2+b^2 = |\\lambda_M|^2$。对于一个一般多项式 $\\lambda^2+c_1\\lambda+c_0=0$，其根的乘积为 $c_0$。对于我们的特征方程，其特征值的乘积为 $\\lambda_{M,1}\\lambda_{M,2} = k/m$。由于特征值是一对共轭复数，这个乘积也等于 $|\\lambda_M|^2$。因此，$a^2+b^2 = k/m$。\n\n项 $-2a$ 是：\n$$\n-2a = -2 \\left(-\\frac{\\gamma}{2m}\\right) = \\frac{\\gamma}{m}\n$$\n将这些表达式代回到关于 $\\Delta t$ 的不等式中：\n$$\n\\Delta t \\leq \\frac{\\gamma/m}{k/m} = \\frac{\\gamma}{k}\n$$\n将显式欧拉法应用于欠阻尼谐振子的稳定性条件是 $\\Delta t \\leq \\frac{\\gamma}{k}$。使数值解保持有界的最大时间步长 $\\Delta t_{\\text{crit}}$ 是等号成立时的极限情况。\n$$\n\\Delta t_{\\text{crit}} = \\frac{\\gamma}{k}\n$$\n只要 $\\gamma > 0$ 且 $k > 0$，这个结果就与质量 $m$ 和具体的欠阻尼程度无关。", "answer": "$$\n\\boxed{\\frac{\\gamma}{k}}\n$$", "id": "2439889"}, {"introduction": "在某些物理系统中，即使是微不足道的计算误差也会被指数级放大，从而完全改变系统的长期行为，混沌系统就是典型的例子。本练习将让你探究计算精度对混沌动力学模拟的深远影响。通过使用单精度和双精度浮点数分别计算逻辑斯蒂映射的李雅普诺夫指数（Lyapunov exponent），你将直观地看到数值误差如何从根本上限制我们对混沌系统可预测性的把握。[@problem_id:2439861]", "problem": "您的任务是定量分析有限精度算术如何影响一个典型混沌系统的最大李雅普诺夫指数的数值估计。考虑由以下迭代定义的逻辑斯谛映射\n$$\nx_{n+1} = f_r(x_n) = r\\,x_n\\,(1 - x_n),\n$$\n其中控制参数 $r \\in (0,4]$，状态 $x_n \\in [0,1]$。对于一维迭代映射，最大李雅普诺夫指数根据第一性原理定义为\n$$\n\\lambda(r,x_0) = \\lim_{N \\to \\infty}\\frac{1}{N}\\sum_{n=0}^{N-1}\\ln\\left| f_r'(x_n) \\right|,\n$$\n其中 $x_{n+1} = f_r(x_n)$，而 $f_r'(x)$ 是 $f_r(x)$ 关于 $x$ 的导数。对于逻辑斯谛映射，$f_r'(x) = r(1 - 2x)$。在实践中，$\\lambda(r,x_0)$ 的任何数值估计都取决于用于演化 $x_n$ 和累加求和的算术，这会引入改变结果的舍入误差和表示误差。\n\n实现一个完整的程序，对于下述测试套件中的每一组参数，使用两种不同的算术精度计算 $\\lambda(r,x_0)$ 的有限 $N$ 估计值：\n- binary32 浮点数（通常称为单精度或“float”，占 $32$ 位），\n- binary64 浮点数（通常称为双精度或“double”，占 $64$ 位）。\n\n对于每次估计，所有迭代值 $x_n$ 以及用于确定 $x_{n+1}$ 和被加数 $\\ln\\left| f_r'(x_n) \\right|$ 的所有中间算术都必须以指定的精度执行。对于每一组参数，在对随后的 $N$ 次迭代进行累加求和之前，先舍弃初始的 $T$ 次瞬态迭代。数值估计是无量纲的，并且必须报告为四舍五入到小数点后六位的小数。\n\n测试套件（每个元组指定 $(r,x_0,T,N)$）：\n- 情况1（周期性状态）：$(3.5,\\;0.123456789,\\;1000,\\;100000)$。\n- 情况2（混沌临界点附近）：$(3.56995,\\;0.123456789,\\;1000,\\;150000)$。\n- 情况3（混沌窗口）：$(3.6,\\;0.123456789,\\;1000,\\;150000)$。\n- 情况4（完全发展的混沌）：$(4.0,\\;0.123456789,\\;1000,\\;200000)$。\n\n对于每种情况，输出一个包含三个浮点数的列表：\n$$\n\\left[\\widehat{\\lambda}_{32},\\;\\widehat{\\lambda}_{64},\\;|\\widehat{\\lambda}_{64} - \\widehat{\\lambda}_{32}|\\right],\n$$\n其中 $\\widehat{\\lambda}_{32}$ 是完全在 binary32 算术下计算的估计值，$\\widehat{\\lambda}_{64}$ 是完全在 binary64 算术下计算的估计值，该情况下两者均使用相同的 $(r,x_0,T,N)$。\n\n最终输出格式：您的程序应生成单行输出，其中包含所有四种情况的结果，格式为不含空格的、逗号分隔的列表之列表，例如\n$$\n\\texttt{[[a\\_1,b\\_1,c\\_1],[a\\_2,b\\_2,c\\_2],[a\\_3,b\\_3,c\\_3],[a\\_4,b\\_4,c\\_4]]},\n$$\n其中每个 $a_i$、$b_i$ 和 $c_i$ 都是四舍五入到小数点后六位的小数。不涉及物理单位；这些值都是纯数。", "solution": "所述问题是有效的。这是一个在数值分析领域，特别是在计算物理学范畴内，良构的、计算上可行的、且有科学依据的练习。它探讨了有限精度算术如何影响混沌动力学系统模拟的基本概念。问题陈述中没有矛盾、歧义或事实不准确之处。因此，我们将着手提供一个完整的解决方案。\n\n该问题要求对逻辑斯谛映射的最大李雅普诺夫指数 $\\lambda$ 进行数值估计，该映射由以下迭代方程定义：\n$$\nx_{n+1} = f_r(x_n) = r x_n (1 - x_n)\n$$\n这里，$x_n \\in [0, 1]$ 是系统在第 n 次迭代时的状态，$r \\in (0, 4]$ 是控制参数。对于这样一个从初始条件 $x_0$ 开始的一维映射，李雅普诺夫指数的理论定义由以下极限给出：\n$$\n\\lambda(r, x_0) = \\lim_{N \\to \\infty} \\frac{1}{N} \\sum_{n=0}^{N-1} \\ln\\left| f_r'(x_n) \\right|\n$$\n其中 $f_r'(x)$ 是 $f_r(x)$ 关于 $x$ 的导数。对于逻辑斯谛映射，该导数为：\n$$\nf_r'(x) = \\frac{d}{dx} \\left( r x - r x^2 \\right) = r(1 - 2x)\n$$\n在任何实际计算中，我们都无法取 $N \\to \\infty$ 的极限。因此，我们计算一个有限和近似值 $\\widehat{\\lambda}$。此外，对于混沌系统，其长期行为由系统的吸引子所表征。为确保我们的计算反映的是吸引子的性质，而非初始瞬态动力学，我们首先将系统演化 $T$ 次迭代并舍弃这些状态。然后，我们在随后的 $N$ 次迭代中开始求和。因此，数值估计按如下方式计算：\n\n1. 初始化状态：$x \\leftarrow x_0$。\n2. 演化通过瞬态阶段：迭代 $x \\leftarrow f_r(x)$ 共 $T$ 步。\n3. 计算总和：初始化一个累加器 $S = 0$。在接下来的 $N$ 步中，执行以下操作：\n   a. 更新总和：$S \\leftarrow S + \\ln|f_r'(x)|$。\n   b. 更新状态：$x \\leftarrow f_r(x)$。\n4. 计算估计值：$\\widehat{\\lambda} = S / N$。\n\n核心任务是探究该计算如何受到所用浮点算术精度的影响。我们将对每个测试用例执行两次此完整过程：一次使用 `binary32`（单精度）浮点数，一次使用 `binary64`（双精度）浮点数。\n\n为确保比较的完整性，至关重要的是，每次计算中的*所有*数值量和算术运算都必须严格限制在指定的精度内。这包括初始参数 $r$ 和 $x_0$、状态变量 $x_n$、所有数值常数（例如 $1$、$2$）以及累加器 $S$。在我们使用 Python `numpy` 库的实现中，这是通过将所有相关值分别显式转换为 `numpy.float32` 和 `numpy.float64` 类型来实现的。\n\n因此，对于给定的精度类型，算法如下：\n令 `p` 为精度类型（例如 `numpy.float32`）。\n- 初始化：`r_p = p(r)`、`x_p = p(x_0)`、`one_p = p(1)`、`two_p = p(2)`。\n- 瞬态迭代（$i$ 从 $1$ 到 $T$）：\n  - `x_p = r_p * x_p * (one_p - x_p)`\n- 求和设置：`S_p = p(0)`、`N_p = p(N)`。\n- 求和迭代（$i$ 从 $1$ 到 $N$）：\n  - `f_prime = r_p * (one_p - two_p * x_p)`\n  - 处理 $|f_prime| = 0$ 的情况，此时 $\\ln(0)$ 无定义。`numpy.log` 函数会正确返回 $-\\infty$，该值将在求和过程中传播。这是一个可接受的结果，因为它正确地识别出一条落在临界点上的轨道。\n  - `S_p = S_p + p(numpy.log(numpy.abs(f_prime)))`\n  - `x_p = r_p * x_p * (one_p - x_p)`\n- 最终结果：$\\widehat{\\lambda} = S_p / N_p$。\n\n对测试套件中的每组参数 $(r, x_0, T, N)$ 都执行此过程，以获得 $\\widehat{\\lambda}_{32}$ 和 $\\widehat{\\lambda}_{64}$。然后计算绝对差 $|\\widehat{\\lambda}_{64} - \\widehat{\\lambda}_{32}|$，以量化由算术精度差异引起的偏差。最终结果按规定报告，四舍五入到六位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes Lyapunov exponent estimates for the logistic map using\n    binary32 and binary64 precision and formats the output as required.\n    \"\"\"\n\n    # Test suite: each tuple is (r, x0, T, N)\n    # r: control parameter\n    # x0: initial condition\n    # T: number of transient iterations to discard\n    # N: number of iterations for summation\n    test_cases = [\n        (3.5, 0.123456789, 1000, 100000),       # Periodic regime\n        (3.56995, 0.123456789, 1000, 150000),    # Near onset of chaos\n        (3.6, 0.123456789, 1000, 150000),       # Chaotic window\n        (4.0, 0.123456789, 1000, 200000)        # Fully developed chaos\n    ]\n\n    def calculate_lambda_estimate(r_val, x0_val, T, N, precision):\n        \"\"\"\n        Calculates a finite-N estimate of the Lyapunov exponent for the\n        logistic map, strictly enforcing the specified numerical precision.\n\n        Args:\n            r_val (float): The control parameter r.\n            x0_val (float): The initial condition x0.\n            T (int): The number of transient iterations.\n            N (int): The number of iterations for the sum.\n            precision (numpy.dtype): The numpy data type for precision\n                                     (e.g., np.float32 or np.float64).\n\n        Returns:\n            float: The estimated Lyapunov exponent.\n        \"\"\"\n        # Cast all numerical quantities to the specified precision. This is critical.\n        r = precision(r_val)\n        x = precision(x0_val)\n        p_one = precision(1.0)\n        p_two = precision(2.0)\n        \n        # Discard T transient iterations to let the trajectory settle onto the attractor.\n        for _ in range(T):\n            x = r * x * (p_one - x)\n            \n        log_sum = precision(0.0)\n        \n        # Accumulate the sum of logarithms of the derivative's absolute value.\n        for _ in range(N):\n            # Calculate the derivative at the current point x.\n            f_prime = r * (p_one - p_two * x)\n            # Add the log of the absolute value to the sum.\n            # The result of np.log is cast back to the working precision.\n            log_sum += precision(np.log(np.abs(f_prime)))\n            \n            # Iterate to the next state.\n            x = r * x * (p_one - x)\n            \n        # The estimate is the average of the accumulated sum.\n        # The division must also use the specified precision.\n        lambda_hat = log_sum / precision(N)\n        \n        return lambda_hat\n\n    results = []\n    for r, x0, T, N in test_cases:\n        # Calculate estimate using binary32 (single precision)\n        lambda_32 = calculate_lambda_estimate(r, x0, T, N, np.float32)\n        \n        # Calculate estimate using binary64 (double precision)\n        lambda_64 = calculate_lambda_estimate(r, x0, T, N, np.float64)\n        \n        # Calculate the absolute difference between the two estimates\n        # Promote to float64 for the difference calculation to preserve precision\n        diff = np.abs(np.float64(lambda_64) - np.float64(lambda_32))\n        \n        results.append([lambda_32, lambda_64, diff])\n\n    # Format the results into the required string format.\n    # Each number is formatted to 6 decimal places, which includes rounding.\n    formatted_cases = []\n    for res_case in results:\n        # res_case[0] is float32, res_case[1] is float64, res_case[2] is float64.\n        # Python's f-string handles the type conversion automatically for printing.\n        formatted_case = f\"[{res_case[0]:.6f},{res_case[1]:.6f},{res_case[2]:.6f}]\"\n        formatted_cases.append(formatted_case)\n    \n    # Final print statement must produce a single line with the exact format.\n    print(f\"[[{','.join(formatted_cases)}]]\")\n\nsolve()\n```", "id": "2439861"}]}