{"hands_on_practices": [{"introduction": "在计算物理中，一个看似无害的表达式在特定点附近求值时，可能会因数值不稳定性而产生巨大误差。本练习将通过评估函数 $f(x) = (\\tan(x) - \\sin(x))/x^3$ 在 $x \\to 0$ 时的行为，来揭示灾难性相消的陷阱。通过对比直接计算与经过三角恒等式变换后的稳定形式，您将亲身体会到分析性重构对于编写可靠数值代码的重要性。[@problem_id:2389878]", "problem": "你的任务是评估在计算函数 $f(x) = \\dfrac{\\tan(x) - \\sin(x)}{x^3}$ 时，当x值（以弧度为单位）接近0时的数值稳定性和误差传播。你的程序必须对每个测试值 $x$ 实现两种不同的 $f(x)$ 数值计算方法，并相对于一个由截断级数展开式构建的高精度参考值来量化每种计算方法的误差。\n\n定义和要求：\n\n- 使用弧度制。\n- 对于任何给定的非零 $x$，定义以下三种计算方法：\n  1. 直接计算 $f_{\\mathrm{dir}}(x) = \\dfrac{\\tan(x) - \\sin(x)}{x^3}$。\n  2. 通过三角变换得到的数值稳定计算方法\n     $$f_{\\mathrm{stab}}(x) = \\dfrac{2 \\sin(x) \\sin^2\\!\\left(\\dfrac{x}{2}\\right)}{x^3 \\cos(x)},$$\n     该方法通过使用 $1 - \\cos(x) = 2\\sin^2\\!\\left(\\dfrac{x}{2}\\right)$ 避免了相消误差。\n  3. 一个由 $f(x)$ 的麦克劳林级数在 $x^6$ 阶截断所构建的参考值：\n     $$f_{\\mathrm{ref}}(x) = \\dfrac{1}{2} + \\dfrac{x^2}{8} + \\dfrac{91}{1680} x^4 + \\dfrac{529}{24192} x^6.$$\n     该参考值在 $|x| \\leq 10^{-1}$ 范围内有效，其余项为 $\\mathcal{O}(x^8)$。\n\n- 对于每个 $x$，计算绝对相对误差\n  $$E_{\\mathrm{dir}}(x) = \\dfrac{\\left| f_{\\mathrm{dir}}(x) - f_{\\mathrm{ref}}(x) \\right|}{\\left| f_{\\mathrm{ref}}(x) \\right|}, \\quad E_{\\mathrm{stab}}(x) = \\dfrac{\\left| f_{\\mathrm{stab}}(x) - f_{\\mathrm{ref}}(x) \\right|}{\\left| f_{\\mathrm{ref}}(x) \\right|}.$$\n\n测试集：\n\n计算并报告以下输入（均为弧度）的误差：$x \\in \\{10^{-1}, 10^{-4}, 10^{-8}, -10^{-8}, 10^{-12}, 10^{-16}\\}$。\n\n最终输出格式：\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于每个测试值 $x$，该列表必须按顺序包含 $E_{\\mathrm{dir}}(x)$，然后是 $E_{\\mathrm{stab}}(x)$。对于以上述顺序给出的测试值，输出因此必须是\n$$[E_{\\mathrm{dir}}(10^{-1}), E_{\\mathrm{stab}}(10^{-1}), E_{\\mathrm{dir}}(10^{-4}), E_{\\mathrm{stab}}(10^{-4}), E_{\\mathrm{dir}}(10^{-8}), E_{\\mathrm{stab}}(10^{-8}), E_{\\mathrm{dir}}(-10^{-8}), E_{\\mathrm{stab}}(-10^{-8}), E_{\\mathrm{dir}}(10^{-12}), E_{\\mathrm{stab}}(10^{-12}), E_{\\mathrm{dir}}(10^{-16}), E_{\\mathrm{stab}}(10^{-16})].$$\n所有角度必须解释为弧度。所有报告的量必须是十进制浮点数。", "solution": "所述问题是有效的。这是一个计算物理学中的适定问题，它有科学依据、内部一致且没有歧义。它讨论了灾难性相消这一基本数值概念及其缓解方法。\n\n核心任务是计算当 $x$ 值接近 0 时函数 $f(x) = \\dfrac{\\tan(x) - \\sin(x)}{x^3}$ 的值。此计算通过三种不同的方法进行，以展示和量化数值误差。\n\n第一种方法是直接计算，$f_{\\mathrm{dir}}(x) = \\dfrac{\\tan(x) - \\sin(x)}{x^3}$。该公式容易发生灾难性相消。对于 $x \\approx 0$，我们有 $\\tan(x) \\approx x$ 和 $\\sin(x) \\approx x$。在有限精度浮点运算中，计算 $\\tan(x) - \\sin(x)$ 涉及两个非常接近的数的相减。此操作导致开头的有效数字被抵消，留下的结果主要由表示误差主导。这种精度损失随后被除以一个非常小的数 $x^3$ 而放大。\n\n为理解 $f(x)$ 在小 $x$ 时的行为，我们考察其分子各分量的麦克劳林级数展开：\n$$ \\tan(x) = x + \\frac{x^3}{3} + \\frac{2x^5}{15} + \\mathcal{O}(x^7) $$\n$$ \\sin(x) = x - \\frac{x^3}{6} + \\frac{x^5}{120} + \\mathcal{O}(x^7) $$\n将这两个级数相减，揭示了分子的真实行为：\n$$ \\tan(x) - \\sin(x) = \\left( \\frac{1}{3} - (-\\frac{1}{6}) \\right) x^3 + \\left( \\frac{2}{15} - \\frac{1}{120} \\right) x^5 + \\mathcal{O}(x^7) = \\frac{1}{2}x^3 + \\frac{1}{8}x^5 + \\mathcal{O}(x^7) $$\n因此，当 $x \\to 0$ 时，函数 $f(x)$ 趋近于一个有限极限：\n$$ \\lim_{x \\to 0} f(x) = \\lim_{x \\to 0} \\frac{\\frac{1}{2}x^3 + \\frac{1}{8}x^5 + \\mathcal{O}(x^7)}{x^3} = \\frac{1}{2} $$\n直接计算公式试图通过减去两个 $\\mathcal{O}(x)$ 阶的大得多的项来计算一个 $\\mathcal{O}(x^3)$ 阶的小的首项，这正是造成数值灾难的根源。\n\n第二种方法，$f_{\\mathrm{stab}}(x)$，使用一个三角恒等式来重构表达式以避免这种相消。推导如下：\n$$ f(x) = \\frac{\\frac{\\sin(x)}{\\cos(x)} - \\sin(x)}{x^3} = \\frac{\\sin(x) \\left( \\frac{1}{\\cos(x)} - 1 \\right)}{x^3} = \\frac{\\sin(x) (1 - \\cos(x))}{x^3 \\cos(x)} $$\n对于小的 $x$，$1 - \\cos(x)$ 这一项仍然是一个有问题的减法。然而，它可以用半角公式 $1 - \\cos(x) = 2 \\sin^2\\left(\\frac{x}{2}\\right)$ 来替换。这会得到数值稳定的形式：\n$$ f_{\\mathrm{stab}}(x) = \\frac{2 \\sin(x) \\sin^2\\left(\\frac{x}{2}\\right)}{x^3 \\cos(x)} $$\n该表达式不包含近似相等量的减法，因此预期在数值上是稳定的。\n\n第三种方法使用 $f(x)$ 本身的截断麦克劳林级数来提供一个高精度参考值 $f_{\\mathrm{ref}}(x)$。从 $\\tan(x) - \\sin(x)$ 的展开式，我们推导出 $f(x)$ 的级数：\n$$ f(x) = \\frac{\\frac{1}{2}x^3 + \\frac{1}{8}x^5 + \\frac{13}{240}x^7 + \\dots}{x^3} = \\frac{1}{2} + \\frac{1}{8}x^2 + \\frac{13}{240}x^4 + \\dots $$\n问题提供了一个更精确的截断：\n$$ f_{\\mathrm{ref}}(x) = \\frac{1}{2} + \\frac{x^2}{8} + \\frac{91}{1680} x^4 + \\frac{529}{24192} x^6 $$\n这种多项式求值方法对于小 $x$ 来说是内在地稳定的，因为它只涉及正数项的加法（因为 $x$ 是平方的）和乘法。这使其成为一个理想的基准。\n\n数值实现将包含三个分别对应于 $f_{\\mathrm{dir}}$、$f_{\\mathrm{stab}}$ 和 $f_{\\mathrm{ref}}$ 的函数。然后，我们将遍历 $x$ 值的测试集：$\\{10^{-1}, 10^{-4}, 10^{-8}, -10^{-8}, 10^{-12}, 10^{-16}\\}$。对于每个 $x$，我们计算直接法和稳定法相对于参考值的绝对相对误差：\n$$ E_{\\mathrm{dir}}(x) = \\frac{\\left| f_{\\mathrm{dir}}(x) - f_{\\mathrm{ref}}(x) \\right|}{\\left| f_{\\mathrm{ref}}(x) \\right|}, \\quad E_{\\mathrm{stab}}(x) = \\frac{\\left| f_{\\mathrm{stab}}(x) - f_{\\mathrm{ref}}(x) \\right|}{\\left| f_{\\mathrm{ref}}(x) \\right|} $$\n由于 $f_{\\mathrm{ref}}(x)$ 是一个正常数（$1/2$）和一些非负项的和，其值总是大于或等于 $1/2$，因此在误差计算中没有除以零的风险。函数 $f(x)$ 是一个偶函数，意味着 $f(x) = f(-x)$，所以对于 $x=10^{-8}$ 和 $x=-10^{-8}$ 的结果预期将是相同的。\n\n实现将使用霍纳方法 (Horner's method) 来进行 $f_{\\mathrm{ref}}(x)$ 的多项式求值，以优化性能并保持数值精度。最终输出将是针对每个测试用例按指定顺序计算出的误差列表，$E_{\\mathrm{dir}}(x)$ 和 $E_{\\mathrm{stab}}(x)$。我们预计，当 $|x| \\to 0$ 时，$E_{\\mathrm{dir}}(x)$ 将急剧增加，而 $E_{\\mathrm{stab}}(x)$ 将保持很小，这证实了重构后表达式的优越稳定性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef f_dir(x: float) -> float:\n    \"\"\"\n    Direct evaluation of f(x) = (tan(x) - sin(x)) / x**3.\n    This form is prone to catastrophic cancellation for x near 0.\n    \"\"\"\n    if x == 0.0:\n        return 0.5  # The limit as x -> 0\n    return (np.tan(x) - np.sin(x)) / (x**3)\n\ndef f_stab(x: float) -> float:\n    \"\"\"\n    Numerically stable evaluation of f(x) using trigonometric rearrangement.\n    f_stab(x) = (2 * sin(x) * sin(x/2)**2) / (x**3 * cos(x)).\n    \"\"\"\n    if x == 0.0:\n        return 0.5  # The limit as x -> 0\n    \n    # Pre-calculate common terms\n    sin_x = np.sin(x)\n    x_half = x / 2.0\n    sin_x_half = np.sin(x_half)\n    cos_x = np.cos(x)\n    x_cubed = x**3\n    \n    # Avoid division by zero if cos(x) is zero, though not for test cases\n    if cos_x == 0.0:\n        return np.inf * np.sign(sin_x)\n        \n    numerator = 2.0 * sin_x * sin_x_half**2\n    denominator = x_cubed * cos_x\n    \n    return numerator / denominator\n\ndef f_ref(x: float) -> float:\n    \"\"\"\n    Reference evaluation of f(x) using its Maclaurin series expansion\n    truncated at the O(x^6) term.\n    f_ref(x) = 1/2 + x^2/8 + (91/1680)x^4 + (529/24192)x^6.\n    \"\"\"\n    if x == 0.0:\n        return 0.5\n        \n    # Use Horner's method for efficient and stable polynomial evaluation\n    y = x**2\n    c0 = 1.0 / 2.0\n    c1 = 1.0 / 8.0\n    c2 = 91.0 / 1680.0\n    c3 = 529.0 / 24192.0\n\n    return c0 + y * (c1 + y * (c2 + y * c3))\n\ndef solve():\n    \"\"\"\n    Main function to execute the problem's requirements.\n    It calculates and reports the relative errors for two numerical methods\n    against a reference value for a given set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        1e-1,\n        1e-4,\n        1e-8,\n        -1e-8,\n        1e-12,\n        1e-16\n    ]\n\n    results = []\n    for x in test_cases:\n        # Calculate the function value using all three methods\n        val_dir = f_dir(x)\n        val_stab = f_stab(x)\n        val_ref = f_ref(x)\n\n        # Calculate the absolute relative errors\n        # Note: abs(val_ref) is guaranteed to be >= 0.5, so no division by zero\n        error_dir = np.abs(val_dir - val_ref) / np.abs(val_ref)\n        error_stab = np.abs(val_stab - val_ref) / np.abs(val_ref)\n        \n        results.append(error_dir)\n        results.append(error_stab)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2389878"}, {"introduction": "灾难性相消的原理不仅限于简单的标量函数，它同样会影响到物理学中核心的矢量运算。本实践将探讨当两个向量几乎平行时，其叉积计算的数值稳定性问题，这在力学和电磁学中是常见情景。通过将双精度浮点数的计算结果与高精度“基准真相”进行比较，您将量化精度损失，并理解其在实际物理问题中的潜在影响。[@problem_id:2389869]", "problem": "要求您通过直接的数值实验，评估计算两个几乎平行的三维向量的叉积的数值稳定性。分析必须严格基于叉积的数学定义和相对误差的定义。\n\n对于下面测试套件中的每个有序向量对 $\\mathbf{a}=(a_1,a_2,a_3)$ 和 $\\mathbf{b}=(b_1,b_2,b_3)$，执行以下操作：\n\n1. 使用标准的双精度浮点运算，计算由以下公式定义的模 $\\lVert \\mathbf{a}\\times\\mathbf{b}\\rVert$：\n$$\n\\mathbf{a}\\times\\mathbf{b}=\\big(a_2 b_3 - a_3 b_2,\\; a_3 b_1 - a_1 b_3,\\; a_1 b_2 - a_2 b_1\\big)\n$$\n和\n$$\n\\lVert \\mathbf{a}\\times\\mathbf{b}\\rVert=\\sqrt{(a_2 b_3 - a_3 b_2)^2+(a_3 b_1 - a_1 b_3)^2+(a_1 b_2 - a_2 b_1)^2}.\n$$\n\n2. 独立地，使用至少有 $80$ 位正确小数位的算术方法，计算同一模的高精度参考值。\n\n3. 对于每对向量，计算相对误差\n$$\n\\varepsilon=\\frac{\\left|\\lVert \\mathbf{a}\\times\\mathbf{b}\\rVert_{\\text{double}}-\\lVert \\mathbf{a}\\times\\mathbf{b}\\rVert_{\\text{high-precision}}\\right|}{\\lVert \\mathbf{a}\\times\\mathbf{b}\\rVert_{\\text{high-precision}}}.\n$$\n\n本问题中的所有量都是无量纲的，因此不适用任何物理单位。通过叉积的几何解释而隐含存在的角度，不应被直接使用。\n\n测试套件（每个分量都以精确的十进制字符串形式给出）：\n\n- 情况 $1$（中等大小，几乎平行）：\n  - $\\mathbf{a}_1=(\\,$\"$1\"$, \"$1\"$, \"$1\"$)$, $\\mathbf{b}_1=(\\,$\"$1.000000000001\"$, \"$0.999999999999\"$, \"$1\"$)$.\n- 情况 $2$（大数值，几乎平行）：\n  - $\\mathbf{a}_2=(\\,$\"$10000000000000000\"$, \"$10000000000000000\"$, \"$10000000000000000\"$)$,\n    $\\mathbf{b}_2=(\\,$\"$10000000000010000\"$, \"$9999999999990000\"$, \"$10000000000000000\"$)$.\n- 情况 $3$（小数值，几乎平行）：\n  - $\\mathbf{a}_3=(\\,$\"$1e-16\"$, \"$1e-16\"$, \"$1e-16\"$)$, $\\mathbf{b}_3=(\\,$\"$1.000000000001e-16\"$, \"$0.999999999999e-16\"$, \"$1e-16\"$)$.\n- 情况 $4$（非常小的数值，几乎平行；在双精度下易发生下溢）：\n  - $\\mathbf{a}_4=(\\,$\"$1e-200\"$, \"$1e-200\"$, \"$1e-200\"$)$, $\\mathbf{b}_4=(\\,$\"$1.000000000001e-200\"$, \"$0.999999999999e-200\"$, \"$1e-200\"$)$.\n- 情况 $5$（正交对照组）：\n  - $\\mathbf{a}_5=(\\,$\"$1\"$, \"$0\"$, \"$0\"$)$, $\\mathbf{b}_5=(\\,$\"$0\"$, \"$1\"$, \"$0\"$)$.\n\n您的程序必须对每个情况 $k\\in\\{1,2,3,4,5\\}$，计算如上定义的相对误差 $\\varepsilon_k$，其中近似值使用双精度浮点运算，参考值使用至少 $80$ 位十进制数。最终输出必须是一行，包含五个按顺序排列的相对误差列表，四舍五入到 $12$ 位有效数字，格式为方括号括起来的逗号分隔列表，例如，“$[x_1,x_2,x_3,x_4,x_5]$”。", "solution": "该问题要求评估使用标准双精度浮点运算计算两个几乎平行向量的叉积的模的数值稳定性。该分析将通过把结果与高精度参考计算进行比较来执行。\n\n所研究的基本原理是**灾难性相消**（catastrophic cancellation），这是数值计算中的一个主要误差来源。当两个几乎相等的数相减时，就会发生这种现象。在浮点运算中，数字以有限数量的有效数字存储。当两个非常接近的数相减时，前面的、最有效的数字会相互抵消，留下的结果主要由后面的、不太有效的数字主导，而这些数字通常被表示或舍入误差所污染。这实际上放大了输入的相对误差，导致结果的相对误差较大，且正确有效数字很少甚至没有。\n\n叉积 $\\mathbf{c} = \\mathbf{a} \\times \\mathbf{b}$ 的标准笛卡尔坐标公式涉及三次这样的减法：\n$$c_1 = a_2 b_3 - a_3 b_2$$\n$$c_2 = a_3 b_1 - a_1 b_3$$\n$$c_3 = a_1 b_2 - a_2 b_1$$\n如果向量 $\\mathbf{a}$ 和 $\\mathbf{b}$ 几乎平行，那么对于某个标量 $k$，有 $\\mathbf{b} \\approx k\\mathbf{a}$。因此，每次减法中的两项变得几乎相等：$a_i b_j \\approx a_i (k a_j) = k a_i a_j$ 且 $a_j b_i \\approx a_j (k a_i) = k a_i a_j$。因此，在使用有限精度算法时，这种情况极易发生灾难性相消。\n\n解决方案是对每个测试用例实施两种计算路径：一种是双精度计算（`numpy.float64`），另一种是高精度参考计算（使用 Python 的 `decimal` 模块）。\n\n1.  **高精度参考计算**：为了建立一个“基准真相”（ground truth）值，我们使用 Python 的 `decimal` 模块，精度设置为 $100$ 位，这轻松超过了所要求的 $80$ 位。以字符串形式给出的输入向量分量被转换为 `Decimal` 对象，以防止在初始化时出现任何精度损失。叉积的分量及后续的模使用 `Decimal` 算术计算，得出 $\\|\\mathbf{a} \\times \\mathbf{b}\\|_{\\text{high-precision}}$。\n\n2.  **双精度计算**：相同的输入字符串被转换为标准的 Python `float` 对象，这些对象对应于 IEEE $754$ 双精度数（`numpy.float64`）。叉积及其模 $\\|\\mathbf{a} \\times \\mathbf{b}\\|_{\\text{double}}$ 使用这些浮点数计算，以模拟标准的数值环境。\n\n3.  **相对误差**：然后按规定计算相对误差 $\\varepsilon$：\n    $$ \\varepsilon = \\frac{\\left| \\|\\mathbf{a} \\times \\mathbf{b}\\|_{\\text{double}} - \\|\\mathbf{a} \\times \\mathbf{b}\\|_{\\text{high-precision}} \\right|}{\\|\\mathbf{a} \\times \\mathbf{b}\\|_{\\text{high-precision}}} $$\n    为了精确地执行此计算，双精度结果在相减前被转换为 `Decimal` 对象，以确保误差计算本身不会引入进一步的显著误差。\n\n我们分析每种情况：\n\n-   **情况 1（中等大小，几乎平行）**：向量为 $\\mathbf{a}_1=(1, 1, 1)$ 和 $\\mathbf{b}_1=(1+10^{-12}, 1-10^{-12}, 1)$。分量减法，例如 $a_{1,1}b_{1,2} - a_{1,2}b_{1,1} = 1 \\cdot (1-10^{-12}) - 1 \\cdot (1+10^{-12}) = -2 \\times 10^{-12}$，涉及到相减的两个数相差约 $2 \\times 10^{-12}$。在双精度运算中，$1 \\pm 10^{-12}$ 的表示会引入一个小的初始误差。减法操作放大了这个误差对最终结果的贡献。一个分量的相对误差大约是 $\\epsilon_{\\text{mach}} / (10^{-12}) \\approx 10^{-16} / 10^{-12} = 10^{-4}$，导致大约 $4$ 个十进制位的精度损失。计算出的模的相对误差也在这个数量级。\n\n-   **情况 2（大数值，几乎平行）**：分量在 $10^{16}$ 的数量级。叉积计算中的中间乘积在 $10^{32}$ 的数量级。这些乘积之间的差值本应在 $10^{20}$ 的数量级，但由于灾难性相消而完全丢失。例如，计算 $a_{2,2}b_{2,3} - a_{2,3}b_{2,2}$ 涉及 $(10^{16})^2 - 10^{16}(10^{16}-10^4) = 10^{32} - (10^{32} - 10^{20})$。双精度浮点数大约有 $16$ 位十进制数的精度。因此，$10^{32} - 10^{20}$ 的计算结果是 $10^{32}$，因为第二项太小而无法表示。减法结果为 $0$。叉积的所有分量都变为零，导致模为 $0$，相对误差为 $1$。\n\n-   **情况 3（小数值，几乎平行）**：分量在 $10^{-16}$ 的数量级。初始的浮点表示是误差的来源。一个像 $1.000000000001 \\times 10^{-16} = 10^{-16} + 10^{-28}$ 这样的数被存储。由于双精度的机器 epsilon 大约是 $2.2 \\times 10^{-16}$，项 $10^{-28}$ 比 $10^{-16}$ 小了 $12$ 个数量级以上，在初始转换为 `float64` 时就丢失了。处理器实际上认为 `1e-16 + 1e-28 == 1e-16`。因此，在双精度下，向量 $\\mathbf{b}_3$ 变得与 $\\mathbf{a}_3$ 完全相同。两个相同向量的叉积是零向量，所以计算出的模为 $0$，相对误差为 $1$。\n\n-   **情况 4（非常小的数值，几乎平行）**：分量在 $10^{-200}$ 的数量级。叉积公式中的中间乘积在 $(10^{-200})^2 = 10^{-400}$ 的数量级。这个值小于最小的可表示的非规格化双精度数（大约为 $4.9 \\times 10^{-324}$）。计算发生下溢，结果为 $0$。叉积向量的所有分量都被计算为 $0$，得出模为 $0$ 和相对误差为 $1$。\n\n-   **情况 5（正交对照组）**：向量为 $\\mathbf{a}_5=(1, 0, 0)$ 和 $\\mathbf{b}_5=(0, 1, 0)$。所有分量都是小整数，可以在浮点数中精确表示。叉积计算只涉及 $0$ 和 $1$ 的乘法和减法，这些运算都可以精确执行。结果 $\\|\\mathbf{a}_5 \\times \\mathbf{b}_5\\|_{\\text{double}} = 1$ 与高精度结果完全相同，因此相对误差为 $0$。这个案例证实了当算法不受数值不稳定性影响时，它是正确的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom decimal import Decimal, getcontext\n\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Computes the relative error in the magnitude of the cross product\n    for several pairs of 3D vectors.\n    \"\"\"\n\n    # Set the precision for high-precision calculations.\n    # Required is at least 80 digits; 100 provides a safe margin.\n    getcontext().prec = 100\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        (('1', '1', '1'), ('1.000000000001', '0.999999999999', '1')),\n        # Case 2\n        (('10000000000000000', '10000000000000000', '10000000000000000'),\n         ('10000000000010000', '9999999999990000', '10000000000000000')),\n        # Case 3\n        (('1e-16', '1e-16', '1e-16'),\n         ('1.000000000001e-16', '0.999999999999e-16', '1e-16')),\n        # Case 4\n        (('1e-200', '1e-200', '1e-200'),\n         ('1.000000000001e-200', '0.999999999999e-200', '1e-200')),\n        # Case 5\n        (('1', '0', '0'), ('0', '1', '0')),\n    ]\n\n    def compute_magnitude_hp(a_str, b_str):\n        a = [Decimal(s) for s in a_str]\n        b = [Decimal(s) for s in b_str]\n        \n        c1 = a[1] * b[2] - a[2] * b[1]\n        c2 = a[2] * b[0] - a[0] * b[2]\n        c3 = a[0] * b[1] - a[1] * b[0]\n        \n        mag_sq = c1**2 + c2**2 + c3**2\n        \n        return mag_sq.sqrt()\n\n    def compute_magnitude_dp(a_str, b_str):\n        a = np.array([float(s) for s in a_str], dtype=np.float64)\n        b = np.array([float(s) for s in b_str], dtype=np.float64)\n        \n        c1 = a[1] * b[2] - a[2] * b[1]\n        c2 = a[2] * b[0] - a[0] * b[2]\n        c3 = a[0] * b[1] - a[1] * b[0]\n        \n        mag_sq = c1**2 + c2**2 + c3**2\n        \n        return np.sqrt(mag_sq)\n\n    results = []\n    for a_vec_str, b_vec_str in test_cases:\n        mag_hp = compute_magnitude_hp(a_vec_str, b_vec_str)\n        mag_dp = compute_magnitude_dp(a_vec_str, b_vec_str)\n        \n        if mag_hp == 0:\n            # If the true value is zero, relative error is 0 if dp is also 0,\n            # otherwise it is infinite. In the given cases, this path is not taken.\n            relative_error = Decimal(0) if mag_dp == 0 else Decimal('inf')\n        else:\n            # Convert dp result to Decimal for high-precision error calculation\n            mag_dp_dec = Decimal(str(mag_dp))\n            absolute_error = abs(mag_dp_dec - mag_hp)\n            relative_error = absolute_error / mag_hp\n        \n        results.append(relative_error)\n\n    def format_to_12_sig_digits(d):\n        \"\"\"Formats a Decimal number to a string with 12 significant digits in scientific notation.\"\"\"\n        if d == 0:\n            return \"0.00000000000e+00\"\n        return f\"{d:.11e}\"\n\n    formatted_results = [format_to_12_sig_digits(res) for res in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2389869"}, {"introduction": "数值不稳定性不仅仅是关于减法导致的精度损失。本练习将介绍另一种常见的陷阱：中间溢出。您将通过比较两种计算二项式系数 $\\binom{n}{k}$ 的方法，发现即使最终结果完全在可表示范围内，一个理论上正确的公式也可能因为中间步骤（如计算 $n!$）超出计算机的数值范围而彻底失败。这个实践强调了选择数值稳健算法的至关重要性。[@problem_id:2389940]", "problem": "要求您评估在双精度浮点算术中计算二项式系数 $\\binom{n}{k}$ 时的数值稳定性与误差传播。请考虑两种算法：(i) 阶乘商方法，该方法使用恒等式 $\\binom{n}{k} = \\dfrac{n!}{k!(n-k)!}$ 且完全在浮点数算术中进行计算；(ii) 累乘积方法，该方法通过迭代地乘以比值来构建乘积，以避免出现大的中间值。目标是在一个设计的测试套件上量化并比较两种方法的前向相对误差，并解释任何可能出现的灾难性相消或有效位丢失现象。\n\n推理和实现的基本依据：\n- 使用以 2 为基、舍入到最近的浮点算术标准模型，其中每个基本算术运算都满足 $\\mathrm{fl}(a \\,\\mathrm{op}\\, b) = (a \\,\\mathrm{op}\\, b)(1+\\delta)$，且 $|\\delta| \\leq \\varepsilon_{\\text{machine}}$。双精度的机器 epsilon 值为 $\\varepsilon_{\\text{machine}} \\approx 2^{-53} \\approx 1.11\\times 10^{-16}$。\n- 二项式系数为整数 $n \\geq 0$ 和 $0 \\leq k \\leq n$ 定义为 $\\binom{n}{k} = \\dfrac{n!}{k!(n-k)!}$，在精确算术中其结果恰好是整数。您可以假定您的编程语言中提供了精确整数算术，用于计算参考值。\n\n您必须实现的算法定义：\n- 阶乘商方法（浮点数）：在浮点数算术中计算 $n!$、$k!$ 和 $(n-k)!$（不使用对数），然后相除得到 $\\widehat{C}_{\\text{fact}} = \\dfrac{\\mathrm{fl}(n!)}{\\mathrm{fl}(k!)\\,\\mathrm{fl}((n-k)!)}$。如果任何中间阶乘计算上溢到 $+\\infty$ 或产生“非数值”（Not-a-Number），则得到的近似值被认为是不可用的。\n- 累乘积方法（浮点数）：通过设置 $k \\leftarrow \\min(k, n-k)$ 并对 $i = 1,2,\\dots,k$ 进行迭代来计算 $\\widehat{C}_{\\text{mult}}$，\n$$\n\\widehat{C}_{\\text{mult}} \\leftarrow \\widehat{C}_{\\text{mult}} \\times \\frac{n - k + i}{i},\n$$\n整个计算过程完全在浮点数算术中进行。\n\n需要报告的误差度量：\n- 对于每个测试用例，使用精确整数算术计算精确参考值 $C_{\\text{exact}} = \\binom{n}{k}$。然后计算每种方法的前向相对误差：\n$$\ne_{\\text{fact}} = \\frac{\\left|\\widehat{C}_{\\text{fact}} - C_{\\text{exact}}\\right|}{C_{\\text{exact}}}, \\qquad\ne_{\\text{mult}} = \\frac{\\left|\\widehat{C}_{\\text{mult}} - C_{\\text{exact}}\\right|}{C_{\\text{exact}}}.\n$$\n如果 $\\widehat{C}_{\\text{fact}}$ 为 $+\\infty$ 或“非数值”，则设置 $e_{\\text{fact}} = +\\infty$。如果 $\\widehat{C}_{\\text{mult}}$ 发生上溢或为“非数值”，也进行类似处理。\n- 对于每个测试用例，还需报告一个布尔值 $b$，其定义为：如果 $e_{\\text{mult}} \\leq e_{\\text{fact}}$，则 $b = \\text{True}$，否则 $b = \\text{False}$。\n\n角度单位：不适用。物理单位：不适用。\n\n您必须使用的测试套件：\n- 用例 1：$(n,k) = (10,5)$。\n- 用例 2：$(n,k) = (60,30)$。\n- 用例 3：$(n,k) = (100,1)$。\n- 用例 4：$(n,k) = (170,85)$。\n- 用例 5：$(n,k) = (200,2)$。\n- 用例 6：$(n,k) = (300,150)$。\n\n覆盖性设计：\n- 这些用例覆盖了小规模对称 $(k \\approx n/2)$、中等规模对称、极端不对称 $(k \\ll n)$、接近双精度阶乘上溢的边界 $(n=170)$，以及阶乘会发生上溢 $(n=200$ 和 $n=300)$ 但累乘积方法应保持有限值的各种情况。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个长度为 6 的列表，每个元素是按 $[e_{\\text{fact}}, e_{\\text{mult}}, b]$ 顺序排列的包含三个条目的列表，分别对应上述的用例 1 到 6。\n- 每个有限浮点误差必须以科学记数法打印，并精确到六位有效数字（例如，$1.234560\\mathrm{e}{-07}$）。如果值为无穷大或非数值，则打印为 $inf$。\n- 布尔值必须打印为 $\\text{True}$ 或 $\\text{False}$。\n- 例如，整体打印的行应如下所示\n$[\\,[e_{1,\\text{fact}},e_{1,\\text{mult}},b_1],\\,[e_{2,\\text{fact}},e_{2,\\text{mult}},b_2],\\,\\dots,\\,[e_{6,\\text{fact}},e_{6,\\text{mult}},b_6]\\,]$。", "solution": "所述问题是有效的。它在科学上基于数值分析的原理，特别是浮点算术，并且是适定的，提供了一个清晰且可计算的任务。我们需要比较两种计算二项式系数 $\\binom{n}{k}$ 的算法。\n\n分析的核心在于理解浮点算术的局限性，即其受限于有限的表示范围和精度。根据标准模型，任何基本算术运算 `op` 都会产生舍入误差：$\\mathrm{fl}(a \\,\\mathrm{op}\\, b) = (a \\,\\mathrm{op}\\, b)(1+\\delta)$，其中 $|\\delta| \\leq \\varepsilon_{\\text{machine}}$。对于 IEEE 754 双精度标准，机器 epsilon $\\varepsilon_{\\text{machine}} \\approx 2^{-53} \\approx 1.11 \\times 10^{-16}$。\n\n第一种算法是阶乘商方法，它基于恒等式 $\\binom{n}{k} = \\dfrac{n!}{k!(n-k)!}$ 来计算 $\\widehat{C}_{\\text{fact}}$。该实现方式在进行除法之前，在浮点算术中计算分子 $\\mathrm{fl}(n!)$ 和分母 $\\mathrm{fl}(k!) \\times \\mathrm{fl}((n-k)!)$。此方法的主要弱点是**上溢**。阶乘函数 $n!$ 呈超指数级增长。在双精度算术中，可表示的最大有限数约为 $1.8 \\times 10^{308}$。$170!$ 的值约为 $7.26 \\times 10^{306}$，是可表示的，但 $171!$ 约为 $1.24 \\times 10^{309}$，会上溢为无穷大 ($+\\infty$)。因此，对任何 $n > 170$，$\\mathrm{fl}(n!)$ 将为 $+\\infty$。这使得该方法不可用，因为计算结果将是 $+\\infty$（如果分母是有限的）或“非数值” (`NaN`)（如果分母也上溢，例如出现不定式 $\\infty/\\infty$）。这是由浮点数的有限表示范围导致的灾难性失败，而非舍入造成的精度损失问题。\n\n第二种算法是累乘积方法。该方法基于将二项式系数重写为乘积形式：\n$$ \\binom{n}{k} = \\frac{n \\times (n-1) \\times \\dots \\times (n-k+1)}{k \\times (k-1) \\times \\dots \\times 1} = \\prod_{i=1}^{k} \\frac{n-i+1}{i} $$\n通过使用恒等式 $\\binom{n}{k} = \\binom{n}{n-k}$，我们可以通过选择 $k$ 和 $n-k$ 中较小的一个来确保乘积中的项数最少。该算法随后通过迭代 $\\widehat{C}_{\\text{mult}} \\leftarrow \\widehat{C}_{\\text{mult}} \\times \\frac{n - k' + i}{i}$ 来定义，其中 $i = 1, \\dots, k'$ 且 $k' = \\min(k, n-k)$。这种形式的关键优势在于它避免了计算大的中间阶乘。项 $\\frac{n-k'+i}{i}$ 的量级适中，并且部分积 $\\prod_{j=1}^{i} \\frac{n-k'+j}{j} = \\binom{n-k'+i}{i}$ 会平滑地增长到最终值。只要最终结果 $\\binom{n}{k}$ 本身不上溢，此方法就会产生一个有限的结果。这种方法在根本上更稳定，因为它将中间值维持在可控的规模，从而避免了上溢，并减少了舍入误差的累积——当处理处于浮点数范围极值的数时，这种累积会更加显著。\n\n为量化性能，我们相对于通过任意精度整数算术获得的确切值 $C_{\\text{exact}}$，计算每种方法的前向相对误差 $e_{\\text{fact}}$ 和 $e_{\\text{mult}}$。由上溢或 `NaN` 导致的不可用结果被正确处理为产生无穷大误差。所设计的测试套件旨在展示这些原理：它包括两种方法预期都能很好工作的用例（小 $n$）、一个处于阶乘方法上溢边界的用例 ($n=170$)，以及阶乘方法保证会失败 ($n > 170$) 而累乘积方法能够成功的用例。因此，比较布尔值 $b = (e_{\\text{mult}} \\leq e_{\\text{fact}})$ 将系统地评估累乘积方法的优越稳定性。", "answer": "```python\nimport math\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares the numerical error of two algorithms for the binomial coefficient.\n    \"\"\"\n\n    def float_factorial(m: int) -> float:\n        \"\"\"Computes factorial of m as a float, handling overflow to inf.\"\"\"\n        if m < 0:\n            return float('nan')\n        if m == 0:\n            return 1.0\n        res = 1.0\n        for i in range(1, m + 1):\n            res *= float(i)\n        return res\n\n    def compute_fact_method(n: int, k: int) -> float:\n        \"\"\"\n        Computes binomial(n, k) using the factorial-quotient method in floating-point.\n        C = n! / (k! * (n-k)!)\n        \"\"\"\n        if k < 0 or k > n:\n            return float('nan')\n\n        n_fact = float_factorial(n)\n        k_fact = float_factorial(k)\n        nk_fact = float_factorial(n - k)\n\n        # The problem statement implies we perform the floating-point operations\n        # on the (potentially infinite) results of the factorials.\n        denominator = k_fact * nk_fact\n        if denominator == 0.0:\n            return float('inf') # Division by zero\n        \n        return n_fact / denominator\n\n    def compute_mult_method(n: int, k: int) -> float:\n        \"\"\"\n        Computes binomial(n, k) using the stable multiplicative method.\n        C = product_{i=1 to k} (n-k+i)/i\n        \"\"\"\n        if k < 0 or k > n:\n            return float('nan')\n\n        # Use symmetry property binom(n, k) = binom(n, n-k)\n        k_comp = n - k\n        if k_comp < k:\n            k = k_comp\n        \n        if k == 0:\n            return 1.0\n\n        res = 1.0\n        for i in range(1, k + 1):\n            # Formula is derived from C(n,k) = (n/k) * C(n-1, k-1)\n            # which can be iteratively computed as prod_{i=1 to k} (n-i+1)/i\n            # The problem gives an equivalent form: C_mult <- C_mult * (n-k+i)/i\n            term = float(n - k + i) / float(i)\n            res *= term\n        \n        return res\n\n    def format_val(v: float) -> str:\n        \"\"\"Formats a float value according to the problem specification.\"\"\"\n        if np.isinf(v) or np.isnan(v):\n            return 'inf'\n        # The problem example \"1.234560e-07\" corresponds to the format specifier \"{:.6e}\",\n        # which provides 1 digit before the decimal and 6 after, for a total of 7 significant digits.\n        # This is followed despite the text \"six significant digits\" due to the example's specificity.\n        return f\"{v:.6e}\"\n\n    test_cases = [\n        (10, 5),\n        (60, 30),\n        (100, 1),\n        (170, 85),\n        (200, 2),\n        (300, 150),\n    ]\n\n    results_list = []\n    for n, k in test_cases:\n        # Compute exact value using arbitrary-precision integers\n        c_exact = math.comb(n, k)\n        c_exact_float = float(c_exact)\n\n        # Method 1: Factorial-quotient\n        c_fact = compute_fact_method(n, k)\n        if np.isinf(c_fact) or np.isnan(c_fact):\n            e_fact = float('inf')\n        else:\n            e_fact = abs(c_fact - c_exact_float) / c_exact_float if c_exact_float != 0 else 0.0\n\n        # Method 2: Multiplicative\n        c_mult = compute_mult_method(n, k)\n        if np.isinf(c_mult) or np.isnan(c_mult):\n            e_mult = float('inf')\n        else:\n            e_mult = abs(c_mult - c_exact_float) / c_exact_float if c_exact_float != 0 else 0.0\n\n        # Comparison\n        b = e_mult <= e_fact\n        \n        results_list.append(f\"[{format_val(e_fact)},{format_val(e_mult)},{str(b)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_list)}]\")\n\nsolve()\n```", "id": "2389940"}]}