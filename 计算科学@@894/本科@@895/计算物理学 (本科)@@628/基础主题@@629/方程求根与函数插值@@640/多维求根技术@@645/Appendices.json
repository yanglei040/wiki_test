{"hands_on_practices": [{"introduction": "将抽象的几何问题转化为代数方程组是科学计算中的一项基本技能。这个练习将带你解决经典的阿波罗尼乌斯问题的一个特例：寻找一个与三个已知圆都相切的圆。通过将几何约束（相切条件）表达为非线性方程，你将有机会从零开始实现牛顿法，包括推导雅可比矩阵，来求解这个多维求根问题 [@problem_id:2415340]。", "problem": "您需要计算平面中一个圆的参数，该圆同时与给定的三个圆外切。所求圆的圆心为 $\\,(x,y)\\,$，半径为 $\\,r \\ge 0\\,$，并且对于每一个给定的圆心为 $\\,(x_i,y_i)\\,$、半径为 $\\,r_i \\ge 0\\,$ 的圆，必须满足以下几何约束：两圆心之间的欧几里得距离等于两半径之和。正式地，使用欧几里得范数和基础几何学，两圆外切的定义条件是它们的圆心距等于半径之和。这导出了以下方程组\n$$\n\\sqrt{(x-x_i)^2+(y-y_i)^2} - \\big(r + r_i\\big) = 0,\\quad i\\in\\{1,2,3\\}.\n$$\n这是经典的 Apollonius 问题的一个特例，即全外切情况。通常情况下，全外切问题最多可以有 $\\,2\\,$ 个不同的解，在退化配置下解的数量会更少。您的任务是找到所有满足该方程组且 $\\,r \\ge 0\\,$ 的解，并使其在严格的数值公差范围内。\n\n您的方法应该基于以下基本原理推导得出：\n- 两点 $\\,(x,y)\\,$ 和 $\\,(x_i,y_i)\\,$ 之间的欧几里得距离是 $\\,\\sqrt{(x-x_i)^2+(y-y_i)^2}\\,$。\n- 圆外切的定义指出，圆心距等于半径之和。\n- 多维求根旨在找到 $\\,\\mathbf{u}^\\star \\in \\mathbb{R}^n\\,$ 使得 $\\,\\mathbf{F}(\\mathbf{u}^\\star)=\\mathbf{0}\\,$，通常通过使用雅可比矩阵进行迭代线性化并采用牛顿类型的步骤进行更新。\n\n您的程序必须：\n- 利用上述几何约束，构建一个包含未知数 $\\,x\\,$, $\\,y\\,$ 和 $\\,r\\,$ 的三元非线性方程组。\n- 使用基于三维牛顿法的多维求根方法求解 $\\,x\\,$, $\\,y\\,$ 和 $\\,r\\,$。您必须从欧几里得距离微分的第一性原理出发，推导出解析的雅可比矩阵。\n- 通过使用多个初始猜测值，找到所有 $\\,r \\ge 0\\,$ 的不同解，并对在小公差范围内数值上相同的解进行去重。\n- 在整个搜索过程中，通过约束 $\\,r \\ge 0\\,$ 来强制实现外切条件。\n- 如果三个方程的最大绝对残差不超过 $\\,10^{-8}\\,$，则接受该解。\n\n数值单位：本问题不涉及物理单位。也不涉及角度。\n\n测试套件：\n- 案例 $\\,1\\,$（一般配置，预期有两个解）：三个圆的参数为 $\\,(x_1,y_1,r_1)=(0.0,0.0,1.0)\\,$，$\\,(x_2,y_2,r_2)=(4.0,0.0,1.0)\\,$，以及 $\\,(x_3,y_3,r_3)=(0.0,3.0,0.5)\\,$。\n- 案例 $\\,2\\,$（具有退化半径的边界配置，预期有一个解）：三个圆的参数为 $\\,(x_1,y_1,r_1)=(0.0,0.0,0.0)\\,$，$\\,(x_2,y_2,r_2)=(4.0,0.0,0.0)\\,$，以及 $\\,(x_3,y_3,r_3)=(0.0,3.0,0.0)\\,$。\n- 案例 $\\,3\\,$（非对称配置，预期有两个解）：三个圆的参数为 $\\,(x_1,y_1,r_1)=(0.0,0.0,1.0)\\,$，$\\,(x_2,y_2,r_2)=(6.0,0.0,2.0)\\,$，以及 $\\,(x_3,y_3,r_3)=(2.0,5.0,0.5)\\,$。\n\n答案规格：\n- 对于每个测试案例，找到所有满足方程组且在公差范围内的不同解 $\\,(x,y,r)\\,$（其中 $\\,r \\ge 0\\,$）。\n- 对每个案例的解按 $\\,r\\,$ 升序排序；如果两个解的半径在 $\\,10^{-6}\\,$ 范围内相等，则按 $\\,x\\,$ 然后按 $\\,y\\,$ 的字典序进行排序。\n- 在最终输出中，将 $\\,x\\,$, $\\,y\\,$ 和 $\\,r\\,$ 各自四舍五入到 $\\,6\\,$ 位小数。\n- 您的程序应生成一行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。每个元素对应一个测试案例，其本身是一个解三元组的列表。例如：\n\"[ [ [x11,y11,r11], [x12,y12,r12] ], [ [x21,y21,r21] ], [ [x31,y31,r31], [x32,y32,r32] ] ]\"\n其中每个数值条目均按指示进行四舍五入。", "solution": "用户提供的问题经过严格验证，被认为是适定的、有科学依据且客观的。这是一个计算几何中的标准问题，是 Apollonius 问题的一个特例，可以使用数值方法求解。所有必要的数据均已提供，问题没有矛盾或歧义之处。\n\n任务是找到一个圆心为 $(x, y)$、半径为 $r$ 的圆，该圆与三个给定的圆外切，每个给定圆由其圆心 $(x_i, y_i)$ 和半径 $r_i$ 定义（$i \\in \\{1, 2, 3\\}$）。\n\n**1. 数学公式**\n\n解圆 $(x, y, r)$与给定圆 $(x_i, y_i, r_i)$ 之间外切的几何条件是，它们的圆心之间的欧几里得距离等于它们的半径之和。这给了我们一个包含三个非线性方程的方程组：\n$$\nd_i = r + r_i, \\quad i \\in \\{1, 2, 3\\}\n$$\n其中 $d_i = \\sqrt{(x-x_i)^2 + (y-y_i)^2}$ 是圆心之间的距离。为了使用求根算法求解，我们将该系统表示为 $\\mathbf{F}(\\mathbf{u}) = \\mathbf{0}$，其中 $\\mathbf{u} = [x, y, r]^T$ 是未知数向量。函数 $f_i$ 定义为残差：\n$$\nf_i(x,y,r) = \\sqrt{(x-x_i)^2 + (y-y_i)^2} - r - r_i = 0\n$$\n这给出了方程组：\n$$\n\\mathbf{F}(\\mathbf{u}) =\n\\begin{pmatrix}\nf_1(x,y,r) \\\\\nf_2(x,y,r) \\\\\nf_3(x,y,r)\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\sqrt{(x-x_1)^2+(y-y_1)^2} - r - r_1 \\\\\n\\sqrt{(x-x_2)^2+(y-y_2)^2} - r - r_2 \\\\\n\\sqrt{(x-x_3)^2+(y-y_3)^2} - r - r_3\n\\end{pmatrix}\n=\n\\mathbf{0}\n$$\n我们寻求满足该方程组并受物理约束 $r \\ge 0$ 的解 $\\mathbf{u}^\\star$。\n\n**2. 方法论：牛顿-拉弗森法**\n\n这个非线性方程组使用牛顿-拉弗森法求解。它是一种迭代算法，从一个初始猜测值 $\\mathbf{u}_0$ 开始，生成一个收敛于根 $\\mathbf{u}^\\star$ 的近似序列 $\\mathbf{u}_k$。该方法的核心是在每一步使用雅可比矩阵 $J$ 对系统进行线性化。更新规则如下：\n$$\n\\mathbf{u}_{k+1} = \\mathbf{u}_k + \\Delta \\mathbf{u}_k\n$$\n其中更新步长 $\\Delta \\mathbf{u}_k$ 是以下线性方程组的解：\n$$\nJ(\\mathbf{u}_k) \\Delta \\mathbf{u}_k = -\\mathbf{F}(\\mathbf{u}_k)\n$$\n\n**3. 雅可比矩阵推导**\n\n雅可比矩阵 $J(\\mathbf{u})$ 是一个 $3 \\times 3$ 的矩阵，其元素是函数 $f_i$ 对变量 $x, y, r$ 的偏导数。\n$$\nJ(\\mathbf{u}) = \\begin{pmatrix}\n\\frac{\\partial f_1}{\\partial x} & \\frac{\\partial f_1}{\\partial y} & \\frac{\\partial f_1}{\\partial r} \\\\\n\\frac{\\partial f_2}{\\partial x} & \\frac{\\partial f_2}{\\partial y} & \\frac{\\partial f_2}{\\partial r} \\\\\n\\frac{\\partial f_3}{\\partial x} & \\frac{\\partial f_3}{\\partial y} & \\frac{\\partial f_3}{\\partial r}\n\\end{pmatrix}\n$$\n我们计算一个通用函数 $f_i$ 的偏导数。令 $d_i = \\sqrt{(x-x_i)^2 + (y-y_i)^2}$。\n关于 $x$ 的导数是：\n$$\n\\frac{\\partial f_i}{\\partial x} = \\frac{\\partial}{\\partial x} \\left( d_i - r - r_i \\right) = \\frac{\\partial d_i}{\\partial x} = \\frac{1}{2 d_i} \\cdot 2(x - x_i) = \\frac{x-x_i}{d_i}\n$$\n关于 $y$ 的导数是：\n$$\n\\frac{\\partial f_i}{\\partial y} = \\frac{\\partial}{\\partial y} \\left( d_i - r - r_i \\right) = \\frac{\\partial d_i}{\\partial y} = \\frac{1}{2 d_i} \\cdot 2(y - y_i) = \\frac{y-y_i}{d_i}\n$$\n关于 $r$ 的导数是：\n$$\n\\frac{\\partial f_i}{\\partial r} = \\frac{\\partial}{\\partial r} \\left( d_i - r - r_i \\right) = -1\n$$\n只要 $d_i \\neq 0$，即解圆的圆心不与任何给定圆的圆心重合，这些导数就是良定义的。将它们组合起来得到完整的雅可比矩阵：\n$$\nJ(x, y, r) = \\begin{pmatrix}\n\\frac{x-x_1}{d_1} & \\frac{y-y_1}{d_1} & -1 \\\\\n\\frac{x-x_2}{d_2} & \\frac{y-y_2}{d_2} & -1 \\\\\n\\frac{x-x_3}{d_3} & \\frac{y-y_3}{d_3} & -1\n\\end{pmatrix}\n$$\n\n**4. 算法策略**\n\n牛顿-拉弗森法是一种局部搜索算法，这意味着它将收敛到“接近”初始猜测值的单个根。由于该问题可能有多个解（对于此配置，通常为零个、一个或两个），因此需要采用使用多个不同初始猜测值的策略来找到所有不同的解。\n\n我们的策略对 $(x, y, r)$ 采用以下初始猜测值：\n1. **基于质心的猜测：** 将圆心 $(x, y)$ 初始化为三个给定圆圆心的质心。半径 $r$ 初始化为 $0$。此猜测旨在找到位于三个给定圆之间间隙中的小解圆。\n2. **基于外心的猜测：** 将圆心 $(x, y)$ 初始化为由三个给定圆圆心形成的三角形的外心。初始半径根据此外心到其中一个圆心的距离进行估算。此猜测旨在找到一个包围三个给定圆的大圆。这仅在三个圆心不共线时适用。\n3. **基于中点的猜测：** 将圆心 $(x,y)$ 初始化为每对给定圆圆心的中点，初始半径为 $0$。这些猜测作为额外的起始点，以提高找到所有解的机会。\n\n对于每个初始猜测，牛顿-拉弗森迭代持续进行，直到更新步长 $\\Delta\\mathbf{u}_k$ 的范数低于公差，或达到最大迭代次数。一个潜在的解如果满足以下两个标准，则被接受：\n1. 最终残差向量的最大绝对值 $||\\mathbf{F}(\\mathbf{u}^\\star)||_\\infty$ 小于或等于 $10^{-8}$。\n2. 半径 $r$ 是非负的，即 $r \\ge 0$。\n\n最后，对收集到的有效解集进行后处理以移除重复项。在无穷范数下，任何两个距离小于 $10^{-6}$ 公差的解都被认为是相同的。然后，每个测试案例的唯一解按半径 $r$ 升序排序，若半径相同则按 $x$ 再按 $y$ 的字典序进行排序。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the parameters of circles externally tangent to three given circles.\n    \"\"\"\n    test_cases = [\n        # Case 1: (x1,y1,r1), (x2,y2,r2), (x3,y3,r3)\n        [(0.0, 0.0, 1.0), (4.0, 0.0, 1.0), (0.0, 3.0, 0.5)],\n        # Case 2\n        [(0.0, 0.0, 0.0), (4.0, 0.0, 0.0), (0.0, 3.0, 0.0)],\n        # Case 3\n        [(0.0, 0.0, 1.0), (6.0, 0.0, 2.0), (2.0, 5.0, 0.5)],\n    ]\n\n    all_results = []\n\n    for circles in test_cases:\n        c1, c2, c3 = [np.array(c) for c in circles]\n        \n        # --- Generate initial guesses ---\n        initial_guesses = []\n        \n        # 1. Centroid of centers, r=0\n        centroid = (c1[:2] + c2[:2] + c3[:2]) / 3.0\n        initial_guesses.append(np.array([centroid[0], centroid[1], 0.0]))\n        \n        # 2. Circumcenter of centers\n        x1, y1, r1 = c1\n        x2, y2, r2 = c2\n        x3, y3, r3 = c3\n        \n        D_mat = 2 * np.array([[x2 - x1, y2 - y1], [x3 - x2, y3 - y2]])\n        b_vec = np.array([x2**2 + y2**2 - x1**2 - y1**2, \n                          x3**2 + y3**2 - x2**2 - y2**2])\n        \n        if np.linalg.det(D_mat) > 1e-9:\n            try:\n                circ_center = np.linalg.solve(D_mat, b_vec)\n                r_est = np.linalg.norm(circ_center - c1[:2]) - r1\n                initial_guesses.append(np.array([circ_center[0], circ_center[1], max(0, r_est)]))\n            except np.linalg.LinAlgError:\n                pass\n\n        # 3. Midpoints of centers, r=0\n        mid12 = (c1[:2] + c2[:2]) / 2.0\n        initial_guesses.append(np.array([mid12[0], mid12[1], 0.0]))\n        mid13 = (c1[:2] + c3[:2]) / 2.0\n        initial_guesses.append(np.array([mid13[0], mid13[1], 0.0]))\n        mid23 = (c2[:2] + c3[:2]) / 2.0\n        initial_guesses.append(np.array([mid23[0], mid23[1], 0.0]))\n\n        solutions = []\n        for u0 in initial_guesses:\n            sol = newton_solver(u0, circles)\n            if sol is not None:\n                solutions.append(sol)\n        \n        # --- Deduplicate solutions ---\n        unique_solutions = []\n        if solutions:\n            # Sort to make deduplication deterministic\n            solutions.sort(key=lambda s: (s[2], s[0], s[1]))\n            unique_solutions.append(solutions[0])\n            for sol in solutions[1:]:\n                is_duplicate = False\n                for unique_sol in unique_solutions:\n                    if np.linalg.norm(sol - unique_sol, ord=np.inf) < 1e-6:\n                        is_duplicate = True\n                        break\n                if not is_duplicate:\n                    unique_solutions.append(sol)\n        \n        # --- Sort solutions ---\n        # Tie-breaking with 1e-6 tolerance on radii as per problem statement\n        unique_solutions.sort(key=lambda s: (round(s[2] / 1e-6) * 1e-6, s[0], s[1]))\n        \n        # --- Format for output ---\n        formatted_solutions = [[round(val, 6) for val in sol] for sol in unique_solutions]\n        all_results.append(formatted_solutions)\n\n    print(str(all_results).replace(\"'\", '\"'))\n\ndef newton_solver(u0, circles, max_iter=100, step_tol=1e-9, residual_tol=1e-8):\n    \"\"\"\n    Solves the system F(u)=0 using Newton's method.\n    u = [x, y, r]\n    \"\"\"\n    u = np.copy(u0)\n    \n    for _ in range(max_iter):\n        x, y, r = u\n        \n        # Calculate F(u)\n        F = np.zeros(3)\n        distances = np.zeros(3)\n        for i, c in enumerate(circles):\n            xi, yi, ri = c\n            d = np.sqrt((x - xi)**2 + (y - yi)**2)\n            if d < 1e-9: # Avoid division by zero\n                return None\n            distances[i] = d\n            F[i] = d - r - ri\n        \n        # Calculate Jacobian J(u)\n        J = np.zeros((3, 3))\n        for i, c in enumerate(circles):\n            xi, yi, _ = c\n            J[i, 0] = (x - xi) / distances[i]\n            J[i, 1] = (y - yi) / distances[i]\n            J[i, 2] = -1.0\n            \n        # Solve J * du = -F\n        try:\n            du = np.linalg.solve(J, -F)\n        except np.linalg.LinAlgError:\n            return None # Singular matrix\n        \n        # Update u\n        u += du\n        \n        # Check for step convergence\n        if np.linalg.norm(du, ord=np.inf) < step_tol:\n            break\n            \n    # Final validation\n    x, y, r = u\n    F_final = np.zeros(3)\n    for i, c in enumerate(circles):\n        xi, yi, ri = c\n        d = np.sqrt((x - xi)**2 + (y - yi)**2)\n        F_final[i] = d - r - ri\n        \n    if np.linalg.norm(F_final, ord=np.inf) <= residual_tol and u[2] >= -1e-9: # Allow for small numerical error around zero radius\n        u[2] = max(0.0, u[2]) # ensure r is not negative\n        return u\n        \n    return None\n\nsolve()\n```", "id": "2415340"}, {"introduction": "物理和工程中的许多问题最终都归结为寻找系统的平衡态，即所有力达到平衡的状态。在这个练习中，你将为一个由杆和索构成的张拉整体结构（tensegrity）建立模型，并通过求解一个由力平衡方程和几何约束方程组成的非线性系统来确定其稳定构型 [@problem_id:2415350]。此问题不仅展示了多维求根技术在静力学分析中的直接应用，还引入了拉格朗日乘子法来处理约束，这是计算物理中一种强大而通用的技术。", "problem": "给定一个最小张拉整体结构的二维模型，该结构由两个自由节点、连接这两个节点的一根不可伸长杆以及几条连接到固定锚点的弹性索组成。目标是确定其平衡构型，该构型定义为每个自由节点上的合力为零且每根杆的长度约束都精确满足的构型。所有距离的单位必须是米。\n\n建模假设：\n- 每条索都建模为遵循 Hooke定律的线性弹簧。如果一个位于位置 $\\mathbf{r}_i \\in \\mathbb{R}^2$ 的自由节点通过一根刚度为 $k$、静止长度为 $L_0$ 的索连接到一个位于位置 $\\mathbf{a} \\in \\mathbb{R}^2$ 的固定锚点，则该索对节点施加的力为\n$$\n\\mathbf{F}_{\\text{cable}} = k \\,\\frac{\\|\\mathbf{a}-\\mathbf{r}_i\\| - L_0}{\\|\\mathbf{a}-\\mathbf{r}_i\\|} \\, (\\mathbf{a}-\\mathbf{r}_i),\n$$\n约定所有力的单位为牛顿，所有长度的单位为米。\n- 每根杆都是完全不可伸长且无质量的，具有给定的长度 $L_s$。对于连接两个位于位置 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 的自由节点的杆，引入一个标量拉格朗日乘子 $\\lambda$ 来施加约束\n$$\ng(\\mathbf{r}_i,\\mathbf{r}_j) = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|^2 - L_s^2 = 0.\n$$\n这会在节点 $i$ 和节点 $j$ 上产生大小相等、方向相反的内力，分别为 $\\mathbf{F}_{\\text{strut},i} = \\lambda \\, (\\mathbf{r}_i - \\mathbf{r}_j)$ 和 $\\mathbf{F}_{\\text{strut},j} = -\\lambda \\, (\\mathbf{r}_i - \\mathbf{r}_j)$。\n- 在平衡状态下，对于每个自由节点 $i$，所有连接于此的索力和杆力的矢量和必须精确为 $\\mathbf{0}$，并且每个杆的约束都必须满足 $g=0$。\n\n未知数和方程：\n- 设两个自由节点为 $C$ 和 $D$，其未知坐标为 $\\mathbf{r}_C = (x_C, y_C)$ 和 $\\mathbf{r}_D = (x_D, y_D)$。\n- 在 $C$ 和 $D$ 之间有一根杆，其拉格朗日乘子 $\\lambda$ 未知，给定长度为 $L_s$。\n- 对每个自由节点，写出合力的 $x$ 和 $y$ 分量为零的两个标量平衡方程。附加标量杆约束方程。总方程数量为 $5$ 个，与未知数 $x_C$、$y_C$、$x_D$、$y_D$ 和 $\\lambda$ 的数量相匹配。\n\n测试套件：\n对于每个测试用例，会给定固定锚点的位置、索的参数、杆的长度，以及 $(x_C, y_C, x_D, y_D)$ 的一个初始猜测值。所有坐标和长度的单位都是米，所有刚度的单位都是牛顿/米。\n\n- 测试用例 1（对称基底，中等预张力）：\n  - 锚点：$A=(0.0, 0.0)$，$B=(1.0, 0.0)$。\n  - 索：$C$–$A$，$C$–$B$，$D$–$A$，$D$–$B$，每条的刚度为 $k = 100.0$，静止长度为 $L_0 = 0.7$。\n  - $C$ 和 $D$ 之间的杆，给定长度为 $L_s = 1.0$。\n  - 自由节点的初始猜测值：$(x_C, y_C, x_D, y_D)=(0.0, 0.5, 1.0, 0.5)$。\n\n- 测试用例 2（更长的杆，更软的索）：\n  - 锚点：$A=(0.0, 0.0)$，$B=(1.0, 0.0)$。\n  - 索：$C$–$A$，$C$–$B$，$D$–$A$，$D$–$B$，每条的刚度为 $k = 80.0$，静止长度为 $L_0 = 0.8$。\n  - $C$ 和 $D$ 之间的杆，给定长度为 $L_s = 1.2$。\n  - 自由节点的初始猜测值：$(x_C, y_C, x_D, y_D)=(0.0, 0.6, 1.2, 0.6)$。\n\n- 测试用例 3（非对称基底，更强的索）：\n  - 锚点：$A=(0.0, 0.0)$，$B=(1.2, 0.0)$。\n  - 索：$C$–$A$，$C$–$B$，$D$–$A$，$D$–$B$，每条的刚度为 $k = 120.0$，静止长度为 $L_0 = 0.75$。\n  - $C$ 和 $D$ 之间的杆，给定长度为 $L_s = 1.1$。\n  - 自由节点的初始猜测值：$(x_C, y_C, x_D, y_D)=(0.0, 0.55, 1.1, 0.55)$。\n\n任务：\n- 对于每个测试用例，求解 $(x_C, y_C, x_D, y_D)$ 和 $\\lambda$，使得节点 $C$ 的二维矢量平衡、节点 $D$ 的二维矢量平衡以及标量杆约束都得到精确满足。每个测试用例只报告坐标 $(x_C, y_C, x_D, y_D)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由列表组成的列表，以逗号分隔。每个内部列表包含一个测试用例的四个坐标，顺序为 $[x_C, y_C, x_D, y_D]$。\n- 每个坐标都以米为单位表示，并四舍五入到六位小数。\n- 确切的所需格式如下：\n  - 一个左方括号，后跟三个由方括号括起来的、用逗号分隔的列表，每个列表包含四个十进制数（四舍五入到六位小数），列表之间用逗号分隔，最后是一个右方括号，中间没有空格。\n  - 例如：$[[x_{C1},y_{C1},x_{D1},y_{D1}],[x_{C2},y_{C2},x_{D2},y_{D2}],[x_{C3},y_{C3},x_{D3},y_{D3}]]$ 其中所有条目都是以米为单位的十进制数，四舍五入到六位小数。", "solution": "该问题要求找到一个二维张拉整体结构的静态平衡构型。这是计算力学中的一个经典问题，可以归结为求解一个非线性代数方程组的根。该方程组由力平衡原理和几何约束定义。\n\n系统的未知数构成一个 5 维状态向量 $\\mathbf{x} = (x_C, y_C, x_D, y_D, \\lambda)^T$，其中 $\\mathbf{r}_C = (x_C, y_C)$ 和 $\\mathbf{r}_D = (x_D, y_D)$ 是两个自由节点的坐标，$\\lambda$ 是与杆长约束相关的拉格朗日乘子。问题在于求解向量方程 $\\mathbf{H}(\\mathbf{x}) = \\mathbf{0}$，其中 $\\mathbf{H}$ 是一个关于 $\\mathbf{x}$ 的向量值函数，代表了控制该系统的物理定律。\n\n函数 $\\mathbf{H}: \\mathbb{R}^5 \\to \\mathbb{R}^5$ 由五个标量方程组成。前四个方程强制静态平衡，即每个自由节点上的合力为零。第五个方程是几何约束，即杆保持其给定长度。\n\n设锚点位置为 $\\mathbf{a}_A$ 和 $\\mathbf{a}_B$。作用于节点 $C$ 上的合力，记为 $\\mathbf{F}_C$，是连接到锚点 $A$ 和 $B$ 的两条索的力，以及连接到节点 $D$ 的杆的内力的矢量和。\n$$\n\\mathbf{F}_C(\\mathbf{r}_C, \\mathbf{r}_D, \\lambda) = \\mathbf{F}_{CA}(\\mathbf{r}_C) + \\mathbf{F}_{CB}(\\mathbf{r}_C) + \\mathbf{F}_{\\text{strut},C}(\\mathbf{r}_C, \\mathbf{r}_D) = \\mathbf{0}\n$$\n根据提供的模型，由连接到锚点 $\\mathbf{a}$ 的索对节点 $C$ 施加的力为：\n$$\n\\mathbf{F}_{\\text{cable}}(\\mathbf{r}_C, \\mathbf{a}) = k \\frac{\\|\\mathbf{a}-\\mathbf{r}_C\\| - L_0}{\\|\\mathbf{a}-\\mathbf{r}_C\\|} (\\mathbf{a}-\\mathbf{r}_C)\n$$\n由连接到节点 $D$ 的杆对节点 $C$ 施加的力为：\n$$\n\\mathbf{F}_{\\text{strut},C}(\\mathbf{r}_C, \\mathbf{r}_D) = \\lambda (\\mathbf{r}_C - \\mathbf{r}_D)\n$$\n类似地，作用于节点 $D$ 上的合力，记为 $\\mathbf{F}_D$，是：\n$$\n\\mathbf{F}_D(\\mathbf{r}_C, \\mathbf{r}_D, \\lambda) = \\mathbf{F}_{DA}(\\mathbf{r}_D) + \\mathbf{F}_{DB}(\\mathbf{r}_D) + \\mathbf{F}_{\\text{strut},D}(\\mathbf{r}_C, \\mathbf{r}_D) = \\mathbf{0}\n$$\n索力 $\\mathbf{F}_{DA}$ 和 $\\mathbf{F}_{DB}$ 的定义与此类似。杆对节点 $D$ 施加一个大小相等、方向相反的力：\n$$\n\\mathbf{F}_{\\text{strut},D}(\\mathbf{r}_C, \\mathbf{r}_D) = -\\lambda (\\mathbf{r}_C - \\mathbf{r}_D) = \\lambda (\\mathbf{r}_D - \\mathbf{r}_C)\n$$\n第五个方程是长度为 $L_s$ 的杆的完整约束：\n$$\ng(\\mathbf{r}_C, \\mathbf{r}_D) = \\|\\mathbf{r}_C - \\mathbf{r}_D\\|^2 - L_s^2 = (x_C - x_D)^2 + (y_C - y_D)^2 - L_s^2 = 0\n$$\n这些平衡和约束条件构成了包含五个非线性标量方程的方程组，$H_i(\\mathbf{x})=0$，其中 $i=1, \\dots, 5$：\n$H_1: k\\frac{\\|\\mathbf{a}_A-\\mathbf{r}_C\\| - L_0}{\\|\\mathbf{a}_A-\\mathbf{r}_C\\|}(a_{Ax}-x_C) + k\\frac{\\|\\mathbf{a}_B-\\mathbf{r}_C\\| - L_0}{\\|\\mathbf{a}_B-\\mathbf{r}_C\\|}(a_{Bx}-x_C) + \\lambda(x_C-x_D) = 0$\n$H_2: k\\frac{\\|\\mathbf{a}_A-\\mathbf{r}_C\\| - L_0}{\\|\\mathbf{a}_A-\\mathbf{r}_C\\|}(a_{Ay}-y_C) + k\\frac{\\|\\mathbf{a}_B-\\mathbf{r}_C\\| - L_0}{\\|\\mathbf{a}_B-\\mathbf{r}_C\\|}(a_{By}-y_C) + \\lambda(y_C-y_D) = 0$\n$H_3: k\\frac{\\|\\mathbf{a}_A-\\mathbf{r}_D\\| - L_0}{\\|\\mathbf{a}_A-\\mathbf{r}_D\\|}(a_{Ax}-x_D) + k\\frac{\\|\\mathbf{a}_B-\\mathbf{r}_D\\| - L_0}{\\|\\mathbf{a}_B-\\mathbf{r}_D\\|}(a_{Bx}-x_D) + \\lambda(x_D-x_C) = 0$\n$H_4: k\\frac{\\|\\mathbf{a}_A-\\mathbf{r}_D\\| - L_0}{\\|\\mathbf{a}_A-\\mathbf{r}_D\\|}(a_{Ay}-y_D) + k\\frac{\\|\\mathbf{a}_B-\\mathbf{r}_D\\| - L_0}{\\|\\mathbf{a}_B-\\mathbf{r}_D\\|}(a_{By}-y_D) + \\lambda(y_D-y_C) = 0$\n$H_5: (x_C - x_D)^2 + (y_C - y_D)^2 - L_s^2 = 0$\n\n该方程组不适合解析求解，必须进行数值求解。解决此类问题的标准技术是 Newton-Raphson 方法。这种迭代方法从一个初始猜测值 $\\mathbf{x}_0$开始，并根据更新规则 $\\mathbf{x}_{n+1} = \\mathbf{x}_n - J^{-1}(\\mathbf{x}_n) \\mathbf{H}(\\mathbf{x}_n)$ 对其进行精化，其中 $J$ 是 $\\mathbf{H}$ 的雅可比矩阵。在实际实现中，会使用鲁棒的数值求解器，例如 `scipy.optimize` 库中提供的求解器。\n\n解决方案的实现首先是定义一个 Python 函数，该函数针对给定的状态向量 $\\mathbf{x}$ 和一组物理参数（锚点位置、$k$、$L_0$、$L_s$）计算向量 $\\mathbf{H}(\\mathbf{x})$。状态向量的初始猜测值 $\\mathbf{x}_0$ 是根据每个测试用例中提供的坐标构建的，并补充了拉格朗日乘子的初始猜测值，该值可以合理地设置为 $\\lambda_0 = 0$。然后调用 `scipy.optimize.root` 函数来找到满足 $\\mathbf{H}(\\mathbf{x}^*) \\approx \\mathbf{0}$ 的解 $\\mathbf{x}^*$。对于问题陈述中指定的三个测试用例，重复此过程。最终报告的结果包含解向量 $\\mathbf{x}^*$ 的坐标分量 $(x_C, y_C, x_D, y_D)$。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import root\n\ndef solve():\n    \"\"\"\n    Solves for the equilibrium configuration of a tensegrity structure for given test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {\n            \"anchors\": {\"A\": np.array([0.0, 0.0]), \"B\": np.array([1.0, 0.0])},\n            \"k\": 100.0,\n            \"L0\": 0.7,\n            \"Ls\": 1.0,\n            \"initial_guess\": np.array([0.0, 0.5, 1.0, 0.5])\n        },\n        # Test case 2\n        {\n            \"anchors\": {\"A\": np.array([0.0, 0.0]), \"B\": np.array([1.0, 0.0])},\n            \"k\": 80.0,\n            \"L0\": 0.8,\n            \"Ls\": 1.2,\n            \"initial_guess\": np.array([0.0, 0.6, 1.2, 0.6])\n        },\n        # Test case 3\n        {\n            \"anchors\": {\"A\": np.array([0.0, 0.0]), \"B\": np.array([1.2, 0.0])},\n            \"k\": 120.0,\n            \"L0\": 0.75,\n            \"Ls\": 1.1,\n            \"initial_guess\": np.array([0.0, 0.55, 1.1, 0.55])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        aA = case[\"anchors\"][\"A\"]\n        aB = case[\"anchors\"][\"B\"]\n        k = case[\"k\"]\n        L0 = case[\"L0\"]\n        Ls = case[\"Ls\"]\n        initial_coords = case[\"initial_guess\"]\n\n        def equations(x):\n            \"\"\"\n            Defines the system of 5 non-linear equations for equilibrium.\n            x: state vector [xc, yc, xd, yd, lambda]\n            \"\"\"\n            xc, yc, xd, yd, lam = x\n            rC = np.array([xc, yc])\n            rD = np.array([xd, yd])\n            \n            # Helper for cable forces to avoid code repetition.\n            # Handles the force model F = k * (1 - L0/d) * (a - r)\n            def cable_force(node_pos, anchor_pos):\n                vec = anchor_pos - node_pos\n                dist = np.linalg.norm(vec)\n                # Add a small epsilon to prevent division by zero if a node is at an anchor\n                if dist < 1e-9:\n                    return np.array([0.0, 0.0])\n                force_magnitude_factor = k * (1.0 - L0 / dist)\n                return force_magnitude_factor * vec\n\n            # Forces on node C\n            F_CA = cable_force(rC, aA)\n            F_CB = cable_force(rC, aB)\n            F_strut_C = lam * (rC - rD)\n            F_net_C = F_CA + F_CB + F_strut_C\n\n            # Forces on node D\n            F_DA = cable_force(rD, aA)\n            F_DB = cable_force(rD, aB)\n            F_strut_D = lam * (rD - rC)\n            F_net_D = F_DA + F_DB + F_strut_D\n\n            # Strut length constraint\n            g = np.linalg.norm(rC - rD)**2 - Ls**2\n\n            return np.array([F_net_C[0], F_net_C[1], F_net_D[0], F_net_D[1], g])\n\n        # Initial guess for the full state vector (coords + lambda)\n        x0 = np.append(initial_coords, 0.0)\n\n        # Solve the system of equations\n        sol = root(equations, x0, method='hybr')\n        \n        if sol.success:\n            # Extract the coordinates from the solution vector\n            result_coords = sol.x[:4]\n            results.append(result_coords)\n        else:\n            # Append a failure indicator if solver does not converge.\n            # This should not happen for the given test cases.\n            results.append([np.nan, np.nan, np.nan, np.nan])\n    \n    # Format the output string exactly as required\n    formatted_lists = []\n    for r in results:\n        formatted_lists.append(f\"[{','.join([f'{val:.6f}' for val in r])}]\")\n    \n    final_output = f\"[{','.join(formatted_lists)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2415350"}, {"introduction": "许多物理系统的行为会随着某个参数（如温度、压力或外力）的变化而改变。参数延拓法是一种强大的计算技术，它使我们能够追踪系统解随参数变化的路径，而不仅仅是求解单个孤立点。在这个高级练习中，你将实现一个“预测-校正”方案，使用牛顿法作为校正步骤，来追踪一个非线性方程组的解曲线 [@problem_id:2415400]。掌握这项技术将为你分析系统的分岔、稳定性和临界行为等高级主题奠定坚实的基础。", "problem": "一个参数化向量方程由非线性映射 $F:\\mathbb{R}^2 \\times \\mathbb{R} \\to \\mathbb{R}^2$ 给出，其定义为\n$$\nF(\\mathbf{x},\\alpha) = \\begin{bmatrix}\n\\sin(x_1) + x_2 - \\alpha \\\\\nx_1 + \\cos(x_2) - 1\n\\end{bmatrix},\n$$\n其中 $\\mathbf{x} = (x_1,x_2)^{\\top}$，$\\alpha$ 是一个标量参数。所有角度都必须以弧度为单位。根是指任何满足 $F(\\mathbf{x}_{\\star},\\alpha)=\\mathbf{0}$ 的 $\\mathbf{x}_{\\star}$。\n\n你的任务是计算一个解路径 $\\{\\mathbf{x}_k\\}_{k=0}^{N}$，该路径对于参数值序列 $\\{\\alpha_k\\}_{k=0}^{N}$ 近似满足 $F(\\mathbf{x}_k,\\alpha_k)=\\mathbf{0}$。其中每个 $\\alpha_k$ 是通过在指定的起始值 $\\alpha_0$ 和结束值 $\\alpha_N$ 之间进行均匀划分生成的。使用先前找到的解 $\\mathbf{x}_{k-1}$ 作为在下一个参数值 $\\alpha_k$ 处寻找 $\\mathbf{x}_k$ 的初始猜测。\n\n从向量函数根的核心定义和 $F$ 关于 $\\mathbf{x}$ 的一阶泰勒展开出发，设计并实现一个校正步，该校正步基于在每次迭代中求解一个线性化系统以减小残差 $F(\\mathbf{x},\\alpha_k)$。通过采用一种回溯策略来确保全局收敛，该策略在非线性残差未能充分减小时减小步长。避免使用任何黑箱求根器；而是通过在每一步构建并求解相应的线性化系统，从第一性原理出发实现迭代。对残差和步长使用欧几里得范数。当残差范数不大于容差 $\\varepsilon_F$ 且未超过最大迭代次数时，终止在参数值 $\\alpha_k$ 处的校正器。每个参数值使用 $\\varepsilon_F=10^{-10}$ 和最多50次校正器迭代。如果校正步中的线性系统是病态或奇异的，则计算一个最小二乘步。\n\n为以下测试套件实现此参数延拓过程。在所有情况下，对于起始参数值，使用初始猜测 $\\mathbf{x}_0=[0.0,0.0]^{\\top}$。\n\n- 测试用例1（理想路径）：$\\alpha$ 从 $\\alpha_0=0.0$ 到 $\\alpha_N=1.0$，使用 $N=20$ 个均匀步长。\n- 测试用例2（粗略步长边界）：$\\alpha$ 从 $\\alpha_0=0.0$ 到 $\\alpha_N=1.0$，使用 $N=2$ 个均匀步长。\n- 测试用例3（反向边缘情况）：$\\alpha$ 从 $\\alpha_0=0.0$ 到 $\\alpha_N=-1.0$，使用 $N=10$ 个均匀步长。\n\n对于每个测试用例，仅报告最后一个参数值 $\\alpha_N$ 处的最终解 $\\mathbf{x}_N$。要求的最终输出格式为单行，包含一个逗号分隔的列表的列表形式的结果，其中每个浮点数条目四舍五入到六位小数，例如 $[\\,[x_{1,\\mathrm{T1}},x_{2,\\mathrm{T1}}],[x_{1,\\mathrm{T2}},x_{2,\\mathrm{T2}}],[x_{1,\\mathrm{T3}},x_{2,\\mathrm{T3}}]\\,]$，其中 $(x_{1,\\mathrm{Tj}},x_{2,\\mathrm{Tj}})$ 是测试用例 $j$ 的最终解。不涉及物理单位。角度以弧度为单位。程序必须精确地产生这一单行输出。", "solution": "所提出的问题是计算科学中一个定义明确的练习，要求实现一种参数延拓法来追踪一个非线性方程组的解流形。该问题具有科学依据，数学上一致，并为其解决提供了所有必要的信息。因此，该问题被认为是有效的。\n\n问题的核心是为参数化向量方程 $F(\\mathbf{x}, \\alpha) = \\mathbf{0}$ 找到一个解序列 $\\{\\mathbf{x}_k\\}_{k=0}^{N}$，其中参数 $\\alpha$ 是增量式变化的。函数 $F: \\mathbb{R}^2 \\times \\mathbb{R} \\to \\mathbb{R}^2$ 由下式给出：\n$$\nF(\\mathbf{x}, \\alpha) = \\begin{bmatrix}\nf_1(\\mathbf{x}, \\alpha) \\\\\nf_2(\\mathbf{x}, \\alpha)\n\\end{bmatrix} = \\begin{bmatrix}\n\\sin(x_1) + x_2 - \\alpha \\\\\nx_1 + \\cos(x_2) - 1\n\\end{bmatrix}\n$$\n其中 $\\mathbf{x} = (x_1, x_2)^\\top$。此任务将使用预测-校正方案来完成，具体来说是自然参数延拓与Newton-Raphson校正器相结合。\n\n首先，将从起始值 $\\alpha_0$ 到结束值 $\\alpha_N$ 的参数范围离散化为 $N$ 个均匀步，定义一个参数值序列 $\\{\\alpha_k\\}_{k=0}^{N}$，其中 $\\alpha_k = \\alpha_0 + k \\cdot (\\alpha_N - \\alpha_0)/N$。\n\n延拓过程从 $k=0$ 处的参数值 $\\alpha_0$ 开始。解 $\\mathbf{x}_0$ 的初始猜测由 $[0.0, 0.0]^\\top$ 给出。对于每个后续的参数值 $\\alpha_k$（对于 $k > 0$），预测步包括使用先前计算出的解 $\\mathbf{x}_{k-1}$ 作为新解 $\\mathbf{x}_k$ 的初始猜测。这是一个零阶或“自然”预测器。\n\n对于每个固定的参数值 $\\alpha_k$，采用一种校正方法来迭代地精化当前猜测（我们记为 $\\mathbf{x}^{(j)}$），以找到 $F(\\mathbf{x}, \\alpha_k) = \\mathbf{0}$ 的一个根。指定的校正器基于 $F$ 在 $\\mathbf{x}^{(j)}$ 周围的一阶泰勒展开：\n$$\nF(\\mathbf{x}^{(j)} + \\Delta\\mathbf{x}, \\alpha_k) \\approx F(\\mathbf{x}^{(j)}, \\alpha_k) + J_F(\\mathbf{x}^{(j)}) \\Delta\\mathbf{x}\n$$\n此处，$\\Delta\\mathbf{x}$ 是校正步，$J_F(\\mathbf{x})$ 是 $F$ 关于 $\\mathbf{x}$ 的雅可比矩阵。我们寻求 $\\Delta\\mathbf{x}$ 使得线性近似变为零向量，这导出了Newton-Raphson线性系统：\n$$\nJ_F(\\mathbf{x}^{(j)}) \\Delta\\mathbf{x} = -F(\\mathbf{x}^{(j)}, \\alpha_k)\n$$\n给定函数 $F$ 的雅可比矩阵是：\n$$\nJ_F(\\mathbf{x}) = \\begin{bmatrix} \\frac{\\partial f_1}{\\partial x_1} & \\frac{\\partial f_1}{\\partial x_2} \\\\ \\frac{\\partial f_2}{\\partial x_1} & \\frac{\\partial f_2}{\\partial x_2} \\end{bmatrix} = \\begin{bmatrix} \\cos(x_1) & 1 \\\\ 1 & -\\sin(x_2) \\end{bmatrix}\n$$\n此矩阵与参数 $\\alpha$ 无关。通过求解这个 $2 \\times 2$ 线性系统来找到校正步 $\\Delta\\mathbf{x}$。问题要求，如果雅可比矩阵 $J_F$ 是奇异或病态的——这可能在解路径的转折点处发生——则必须以最小二乘意义求解该系统。即使线性系统不存在唯一解，这也能提供一个鲁棒的更新方向。\n\n为确保校正器迭代的收敛性，特别是当来自预测步的初始猜测距离真根不够近时，会实现一个回溯线搜索。完整的Newton步 $\\Delta\\mathbf{x}$ 会被一个因子 $\\lambda \\in (0, 1]$ 缩放，下一个迭代点计算如下：\n$$\n\\mathbf{x}^{(j+1)} = \\mathbf{x}^{(j)} + \\lambda \\Delta\\mathbf{x}\n$$\n选择步长 $\\lambda$ 以确保残差的欧几里得范数 $\\|F(\\mathbf{x}, \\alpha_k)\\|_2$ 有充分的下降。一个简单而有效的策略是从 $\\lambda=1$ 开始，并连续减小它（例如，通过减半），直到满足条件 $\\|F(\\mathbf{x}^{(j+1)}, \\alpha_k)\\|_2 < \\|F(\\mathbf{x}^{(j)}, \\alpha_k)\\|_2$。\n\n对于给定的 $\\alpha_k$，当残差的欧几里得范数降至指定容差以下，即 $\\|F(\\mathbf{x}^{(j)}, \\alpha_k)\\|_2 \\le \\varepsilon_F = 10^{-10}$，或达到最大50次迭代后，校正过程终止。\n\n总体算法按如下步骤进行：\n1. 使用为初始参数值提供的猜测来初始化解：$\\mathbf{x}_{\\text{current}} = [0.0, 0.0]^\\top$。\n2. 生成参数值序列 $\\alpha_0, \\alpha_1, \\ldots, \\alpha_N$。\n3. 对于序列中的每个 $\\alpha_k$：\n    a. 设置校正器的初始猜测：$\\mathbf{x}^{(0)} = \\mathbf{x}_{\\text{current}}$。\n    b. 开始校正器循环（对于 $j = 0, 1, \\ldots, 49$）：\n        i. 计算残差向量 res $= F(\\mathbf{x}^{(j)}, \\alpha_k)$。\n        ii. 如果 $\\|\\text{res}\\|_2 \\le 10^{-10}$，则校正器已收敛。存储 $\\mathbf{x}_{\\text{current}} = \\mathbf{x}^{(j)}$ 并跳出内循环，以继续处理下一个 $\\alpha_{k+1}$。\n        iii. 计算雅可比矩阵 $J = J_F(\\mathbf{x}^{(j)})$。\n        iv. 为保证鲁棒性，使用最小二乘法求解线性系统 $J \\Delta\\mathbf{x} = -\\text{res}$ 以获得 $\\Delta\\mathbf{x}$。\n        v. 执行回溯线搜索，从 $\\lambda=1$ 开始，以找到合适的步长 $\\lambda$。\n        vi. 更新解的猜测：$\\mathbf{x}^{(j+1)} = \\mathbf{x}^{(j)} + \\lambda \\Delta\\mathbf{x}$。\n    c. 内循环之后（无论是通过收敛还是达到最大迭代次数），得到的 $\\mathbf{x}^{(j)}$ 成为新的 $\\mathbf{x}_{\\text{current}}$。\n4. 在遍历所有参数值直到 $\\alpha_N$ 之后，最终的 $\\mathbf{x}_{\\text{current}}$ 即为该测试用例所需的解。对所有指定的测试用例重复此过程。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a parameter continuation method to solve a nonlinear system F(x, alpha) = 0.\n    The method uses a natural parameter predictor and a Newton-Raphson corrector\n    with a backtracking line search and least-squares steps for robustness.\n    \"\"\"\n\n    # Define the nonlinear vector function F(x, alpha)\n    def F(x, alpha):\n        x1, x2 = x\n        f1 = np.sin(x1) + x2 - alpha\n        f2 = x1 + np.cos(x2) - 1.0\n        return np.array([f1, f2])\n\n    # Define the Jacobian matrix J(x)\n    def J(x):\n        x1, x2 = x\n        j11 = np.cos(x1)\n        j12 = 1.0\n        j21 = 1.0\n        j22 = -np.sin(x2)\n        return np.array([[j11, j12], [j21, j22]])\n\n    # Define parameters for the numerical method\n    F_TOLERANCE = 1e-10\n    MAX_CORRECTOR_ITER = 50\n    MIN_LAMBDA = 1e-8\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        # (alpha_start, alpha_end, num_steps)\n        (0.0, 1.0, 20),  # Test case 1\n        (0.0, 1.0, 2),   # Test case 2\n        (0.0, -1.0, 10), # Test case 3\n    ]\n\n    final_results = []\n\n    for alpha_start, alpha_end, N in test_cases:\n        # Generate the sequence of parameter values\n        alphas = np.linspace(alpha_start, alpha_end, N + 1)\n        \n        # Initial guess for the solution at the starting parameter value\n        x_sol = np.array([0.0, 0.0])\n\n        # Loop over the parameter steps (continuation loop)\n        for alpha_k in alphas:\n            x_guess = np.copy(x_sol)\n            \n            # Corrector loop (Newton-Raphson with line search)\n            for _ in range(MAX_CORRECTOR_ITER):\n                residual = F(x_guess, alpha_k)\n                res_norm = np.linalg.norm(residual)\n\n                # Check for convergence\n                if res_norm <= F_TOLERANCE:\n                    break\n                \n                # Compute Jacobian and solve the linear system for the Newton step\n                jacobian = J(x_guess)\n                # Use lstsq for robustness against singularity\n                delta_x, _, _, _ = np.linalg.lstsq(jacobian, -residual, rcond=None)\n\n                # Backtracking line search for globalization\n                lambda_val = 1.0\n                while lambda_val > MIN_LAMBDA:\n                    x_new = x_guess + lambda_val * delta_x\n                    new_res_norm = np.linalg.norm(F(x_new, alpha_k))\n                    \n                    if new_res_norm < res_norm:\n                        x_guess = x_new\n                        break\n                    \n                    lambda_val /= 2.0\n                else:\n                    # If lambda becomes too small, step might be non-productive.\n                    # Stop this corrector iteration and hope for the best.\n                    break\n            \n            # Update the solution for the current parameter value\n            x_sol = x_guess\n\n        # Append the final solution (at alpha_N) for the current test case\n        final_results.append(x_sol)\n\n    # Format and print the final output as specified\n    formatted_strings = [f'[{res[0]:.6f},{res[1]:.6f}]' for res in final_results]\n    print(f\"[{','.join(formatted_strings)}]\")\n\nsolve()\n```", "id": "2415400"}]}