{"hands_on_practices": [{"introduction": "在编写复杂的代码之前，通过一个简单的、可手动求解的例子来理解切比雪夫插值的机理至关重要。本练习将引导你用一个二次多项式来近似函数 $f(x) = x^3$。这不仅能让你实践如何找到切比雪夫节点并求解插值多项式，还能让你对背后的数学原理有一个具体而直观的认识。[@problem_id:2187288]", "problem": "在数值分析中，使用切比雪夫节点进行插值是优于使用等距点的一种方法，尤其是在避免龙格现象（Runge's phenomenon）方面。该方法选择的插值点是切比雪夫多项式的根，这些点聚集在区间的端点附近。\n\n考虑区间 $[-1, 1]$ 上的函数 $f(x) = x^3$。你的任务是求一个次数至多为2的唯一多项式，记作 $P_2(x)$，它在区间上的三个切比雪夫节点处对 $f(x)$ 进行插值。这些节点被定义为第一类3次切比雪夫多项式 $T_3(x)$ 的根。\n\n请将 $P_2(x)$ 的答案表示为关于 $x$ 的简化多项式形式。", "solution": "给定 $[-1,1]$ 上的函数 $f(x)=x^{3}$，我们必须找到一个次数至多为 $2$ 的唯一多项式 $P_{2}(x)$，它在 $[-1,1]$ 上的三个切比雪夫节点处对 $f$ 进行插值。这些节点被定义为第一类3次切比雪夫多项式 $T_{3}(x)$ 的根。\n\n使用恒等式 $T_{3}(x)=\\cos\\!\\big(3\\arccos x\\big)=4x^{3}-3x$。$T_{3}$ 的根即为三个切比雪夫节点：\n$$\nT_{3}(x)=4x^{3}-3x=x\\big(4x^{2}-3\\big)=0\n\\quad\\Longrightarrow\\quad\nx\\in\\left\\{0,\\;\\pm\\frac{\\sqrt{3}}{2}\\right\\}.\n$$\n设 $P_{2}(x)=A x^{2}+B x+C$。插值条件为在每个节点 $\\xi\\in\\left\\{0,\\pm\\frac{\\sqrt{3}}{2}\\right\\}$ 处，$P_{2}(\\xi)=\\xi^{3}$。\n\n1) 在 $x=0$ 处：\n$$\nP_{2}(0)=C=0 \\quad\\Longrightarrow\\quad C=0.\n$$\n\n2) 设 $a=\\frac{\\sqrt{3}}{2}$。在 $x=a$ 和 $x=-a$ 处：\n$$\nP_{2}(a)=A a^{2}+B a=a^{3},\\qquad P_{2}(-a)=A a^{2}-B a=-a^{3}.\n$$\n将这两个方程相加可以消去 $B$：\n$$\n\\big(A a^{2}+B a\\big)+\\big(A a^{2}-B a\\big)=a^{3}+(-a^{3})\n\\;\\Longrightarrow\\;\n2A a^{2}=0\n\\;\\Longrightarrow\\;\nA=0\n\\quad(\\text{因为 }a\\neq 0).\n$$\n将 $A=0$ 代入 $A a^{2}+B a=a^{3}$ 以求解 $B$：\n$$\nB a=a^{3}\\;\\Longrightarrow\\;B=a^{2}.\n$$\n由于 $a=\\frac{\\sqrt{3}}{2}$，我们有\n$$\na^{2}=\\left(\\frac{\\sqrt{3}}{2}\\right)^{2}=\\frac{3}{4}.\n$$\n因此，\n$$\nP_{2}(x)=B x=\\frac{3}{4}\\,x.\n$$\n快速验证：$P_{2}(0)=0=f(0)$，且 $P_{2}(\\pm a)=\\frac{3}{4}(\\pm a)=\\pm a\\cdot\\frac{3}{4}=\\pm a^{3}=f(\\pm a)$，因此在所有三个切比雪夫节点上都满足插值条件。\n\n因此，次数至多为 $2$ 的唯一插值多项式是 $P_{2}(x)=\\frac{3}{4}x$。", "answer": "$$\\boxed{\\frac{3}{4}x}$$", "id": "2187288"}, {"introduction": "多项式插值的一个基本特性是，它能够精确地复现任何次数不高于插值多项式次数的函数。本计算练习旨在通过实验验证这一核心原则。通过在切比雪夫节点上对不同多项式进行插值，你将观察到插值误差在数值精度范围内几乎为零，从而加深对该方法理论精确性的理解。[@problem_id:2378845]", "problem": "考虑一个定义在闭区间 $[a,b]$ 上的实值函数 $f(x)$。对于一个整数 $N \\ge 0$，在 $[a,b]$ 上的 $N+1$ 个第一类 Chebyshev 节点定义为\n$$\nx_k = \\frac{a+b}{2} + \\frac{b-a}{2} \\cos\\!\\left(\\frac{(2k+1)\\pi}{2(N+1)}\\right), \\quad k=0,1,\\dots,N,\n$$\n其中所有角度均以弧度为单位。Chebyshev 插值多项式 $p_N(x)$ 是满足 $p_N(x_k)=f(x_k)$（对于所有 $k=0,1,\\dots,N$）的次数至多为 $N$ 的唯一多项式。\n\n您的任务是确定，在一般情况下，当 $f(x)$ 本身是一个次数为 $M$ 且 $M<N$ 的多项式时，$p_N(x)$ 是什么，并通过为几个指定的测试用例计算密集网格上的最大范数插值误差来对此进行实验验证。\n\n对于下方的每个测试用例，请按指定顺序执行以下操作：\n- 如上所定义，在 $[a,b]$ 上构造 $N+1$ 个 Chebyshev 节点 $\\{x_k\\}_{k=0}^N$。\n- 构造满足 $p_N(x_k)=f(x_k)$ 的、次数至多为 $N$ 的唯一插值多项式 $p_N(x)$。\n- 在 $[a,b]$ 上包含端点的 $2001$ 个点的均匀网格上，计算最大绝对误差\n$$\nE = \\max_{x \\in \\text{grid}} \\left|p_N(x) - f(x)\\right|.\n$$\n\n使用以下测试套件，其中每个函数 $f(x)$ 是一个由系数 $\\{c_m\\}_{m=0}^{M}$ 给出的多项式，通过 $f(x)=\\sum_{m=0}^{M} c_m x^m$ 定义：\n- 测试 1 (理想情况): $[a,b]=[-1,1]$, $N=8$，系数 $[c_0,\\dots,c_3]=[3,-2,0,5]$ 使得 $f(x)=3-2x+5x^3$ 且 $M=3$，$M<N$。\n- 测试 2 (边界情况 $M=N$): $[a,b]=[2,5]$, $N=5$，系数 $[c_0,\\dots,c_5]=[7,0,-4,0,0,1]$ 使得 $f(x)=7-4x^2+x^5$ 且 $M=5$，$M=N$。\n- 测试 3 (平移/缩放的区间, $M<N$): $[a,b]=[-3,4]$, $N=12$，系数 $[c_0,\\dots,c_7]=[1,-1,1,0,-1,0,0,1]$ 使得 $f(x)=1-x+x^2-x^4+x^7$ 且 $M=7$，$M<N$。\n- 测试 4 (退化的最小次数): $[a,b]=[-2,3]$, $N=0$，系数 $[c_0]=[2.5]$ 使得 $f(x)=2.5$ 且 $M=0$，$M=N$。\n- 测试 5 (对比行为的边界情况 $M>N$): $[a,b]=[0,1]$, $N=6$，系数 $[c_0,\\dots,c_{10}]=[0.5,-1.2,0,0.3,0,-0.7,0,0.4,0,0,1]$ 使得 $f(x)=0.5-1.2x+0.3x^3-0.7x^5+0.4x^7+x^{10}$ 且 $M=10$，$M>N$。\n\n您的程序必须输出一行，包含一个含有 $5$ 个浮点数的列表 $[E_1,E_2,E_3,E_4,E_5]$，其中 $E_i$ 是测试用例 $i$ 的 $E$ 值，顺序与上面列出的完全一致。输出必须格式化为方括号内以逗号分隔的列表，每个数字使用科学记数法书写，小数点后有 $16$ 位有效数字（例如，$[1.2345678901234567e-12,2.3456789012345678e-10,\\dots]$）。不应打印任何额外文本。", "solution": "所提出的问题既需要关于多项式插值的理论推导，也需要通过数值计算进行实验验证。对问题陈述的验证发现，其在科学上是合理的、适定的，并包含了唯一解所需的所有必要信息。这是数值分析领域的一个标准问题。我们将首先处理关于插值多项式同一性的理论方面，然后介绍用于实验验证的计算过程。\n\n逼近论中的一个基本定理指出，对于任何 $N+1$ 个不同的点集 $\\{x_k\\}_{k=0}^N$ 和对应的值 $\\{y_k\\}_{k=0}^N$，存在一个次数至多为 $N$ 的唯一多项式 $p_N(x)$，使得对于所有 $k \\in \\{0, 1, \\dots, N\\}$ 都有 $p_N(x_k)=y_k$。问题在于，当被插值的函数 $f(x)$ 本身是一个多项式时，这个插值多项式 $p_N(x)$ 会是什么。设 $f(x)$ 的次数为 $M$。我们分析两种情况。\n\n情况 1: $M \\le N$。\n设待插值的函数 $f(x)$ 是一个次数为 $M$ 的多项式，其中 $M \\le N$。次数至多为 $M$ 的多项式空间，记作 $P_M$，是次数至多为 $N$ 的多项式空间 $P_N$ 的一个子空间。因此，$f(x) \\in P_N$。\n\nChebyshev 插值多项式 $p_N(x)$ 被定义为 $P_N$ 中满足插值条件 $p_N(x_k) = f(x_k)$ 的唯一多项式，其中 $\\{x_k\\}_{k=0}^N$ 是 $N+1$ 个不同的 Chebyshev 节点。\n\n考虑差值多项式 $q(x) = p_N(x) - f(x)$。由于 $p_N(x)$ 和 $f(x)$ 都是次数至多为 $N$ 的多项式，它们的差 $q(x)$ 也必须是一个次数至多为 $N$ 的多项式。\n根据插值的定义，在每个节点 $x_k$ 处，我们有：\n$$q(x_k) = p_N(x_k) - f(x_k) = f(x_k) - f(x_k) = 0$$\n这表明 $q(x)$ 有 $N+1$ 个不同的根。一个次数至多为 $N$ 的非零多项式最多只能有 $N$ 个不同的根。因此，要使 $q(x)$ 有 $N+1$ 个根，它必须是零多项式，即 $q(x) \\equiv 0$。\n\n由 $q(x) = 0$ 可得，对于所有 $x$，$p_N(x) \\equiv f(x)$。插值多项式与原函数本身是完全相同的。因此，插值误差 $E = \\max |p_N(x) - f(x)|$ 必须恒为零。在实践中，由于计算环境中的浮点数运算，这个误差将是一个非常小的数，量级与机器精度相当。这个理论结果适用于测试用例 1、2、3 和 4，其中 $M \\le N$。\n\n情况 2: $M > N$。\n如果 $f(x)$ 是一个次数为 $M > N$ 的多项式，它通常不能被一个次数至多为 $N$ 的多项式 $p_N(x)$ 精确表示。插值误差 $f(x) - p_N(x)$ 由以下公式给出：\n$$f(x) - p_N(x) = \\frac{f^{(N+1)}(\\xi)}{(N+1)!} \\prod_{k=0}^{N} (x-x_k)$$\n对于区间 $[a,b]$ 中的某个 $\\xi$。由于 $f(x)$ 是一个次数为 $M > N$ 的多项式，其 $(N+1)$ 阶导数 $f^{(N+1)}(x)$ 是一个次数为 $M-(N+1) \\ge 0$ 的非零多项式。因此，误差项不恒为零。乘积 $\\prod_{k=0}^{N} (x-x_k)$ 是一个次数为 $N+1$ 的特定多项式，其根位于 Chebyshev 节点。选择 Chebyshev 节点可以最小化此乘积项在区间上的最大值，从而提供一个近乎最优的多项式逼近。对于这种情况，我们预期会有一个不可忽略的误差 $E > 0$，该误差显著大于机器精度。这适用于测试用例 5。\n\n为每个测试用例验证这些发现的计算过程如下：\n1. 对于由区间 $[a,b]$、插值多项式次数 $N$ 和函数 $f(x) = \\sum_{m=0}^{M} c_m x^m$ 的系数 $\\{c_m\\}_{m=0}^{M}$ 定义的每个测试用例，我们首先为计算评估定义函数 $f(x)$。\n2. 使用给定公式在区间 $[a,b]$ 上计算 $N+1$ 个 Chebyshev 节点 $\\{x_k\\}_{k=0}^N$：\n   $$x_k = \\frac{a+b}{2} + \\frac{b-a}{2} \\cos\\!\\left(\\frac{(2k+1)\\pi}{2(N+1)}\\right)$$\n3. 在这些节点上评估函数 $f(x)$ 的值，以获得点集 $\\{ (x_k, f(x_k)) \\}_{k=0}^N$。\n4. 构造插值多项式 $p_N(x)$。虽然可以通过求解线性方程组来获得其系数，但一种数值上更稳定且更高效的评估方法是使用重心插值公式。我们将使用一个实现此方法的库函数。\n5. 在区间 $[a,b]$ 上创建一个密集的、包含端点的 $2001$ 个点的均匀网格。\n6. 在密集网格的每个点上，评估原函数 $f(x)$ 和插值多项式 $p_N(x)$ 的值。\n7. 计算整个网格上评估的函数值与插值多项式值之间的最大绝对差，以求得误差 $E$：\n   $$E = \\max_{x \\in \\text{grid}} \\left|p_N(x) - f(x)\\right|$$\n对所有 5 个测试用例重复此过程。所得到的误差要么接近于零（对于 $M \\le N$），要么显著较大（对于 $M > N$），从而证实了理论分析。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import barycentric_interpolate\n\ndef solve():\n    \"\"\"\n    Solves the Chebyshev interpolation problem for a suite of test cases.\n    For each case, it computes the maximum interpolation error on a dense grid.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple contains: (a, b, N, coefficients_c)\n    # where c are coefficients for powers from 0 to M.\n    test_cases = [\n        # Test 1: M < N\n        (-1.0, 1.0, 8, [3.0, -2.0, 0.0, 5.0]),\n        # Test 2: M = N\n        (2.0, 5.0, 5, [7.0, 0.0, -4.0, 0.0, 0.0, 1.0]),\n        # Test 3: M < N, shifted/scaled interval\n        (-3.0, 4.0, 12, [1.0, -1.0, 1.0, 0.0, -1.0, 0.0, 0.0, 1.0]),\n        # Test 4: M = N, minimal degree\n        (-2.0, 3.0, 0, [2.5]),\n        # Test 5: M > N, contrast case\n        (0.0, 1.0, 6, [0.5, -1.2, 0.0, 0.3, 0.0, -0.7, 0.0, 0.4, 0.0, 0.0, 1.0])\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        a, b, N, coeffs = case\n\n        # 1. Define the function f(x) using its polynomial coefficients.\n        # numpy.polyval expects coefficients from the highest power to the lowest.\n        # The problem provides coefficients from the lowest power (c_0) to the highest.\n        # Therefore, we must reverse the coefficient list.\n        f = lambda x: np.polyval(np.array(coeffs)[::-1], x)\n\n        # 2. Construct the N+1 Chebyshev nodes on [a,b].\n        k = np.arange(N + 1)\n        angles = (2 * k + 1) * np.pi / (2 * (N + 1))\n        # Standard Chebyshev nodes are on [-1,1], so we scale and shift them to [a,b].\n        x_nodes = (a + b) / 2.0 + (b - a) / 2.0 * np.cos(angles)\n\n        # 3. Form the data points (x_k, f(x_k)) for interpolation.\n        y_nodes = f(x_nodes)\n\n        # 4. On a uniform grid of 2001 points, compute the maximum absolute error.\n        grid_points = np.linspace(a, b, 2001)\n\n        # Evaluate the interpolant p_N(x) on the grid using barycentric interpolation.\n        y_interpolated = barycentric_interpolate(x_nodes, y_nodes, grid_points)\n\n        # Evaluate the true function f(x) on the grid.\n        y_true = f(grid_points)\n\n        # Compute the maximum absolute error E.\n        max_error = np.max(np.abs(y_interpolated - y_true))\n        results.append(max_error)\n\n    # Final print statement in the exact required format.\n    # Each number is in scientific notation with 16 digits after the decimal point.\n    print(f\"[{','.join(f'{e:.16e}' for e in results)}]\")\n\nsolve()\n```", "id": "2378845"}, {"introduction": "一种插值方法的真正考验在于其处理非多项式函数的性能，尤其是像著名的龙格函数这样的“困难”函数。本实践将比较使用两种“优良”节点集——切比雪夫节点和勒让德节点——来克服龙格现象的效果。通过这个编码挑战，你将获得关于特定节点布局为何对实现稳定和准确的近似至关重要的实践性见解。[@problem_id:2378832]", "problem": "您的任务是：对于一个给定函数，使用两组不同的节点，在区间 $[-1,1]$ 上构造并比较多项式插值。设目标函数为 $f(x)=\\dfrac{1}{1+25x^2}$，定义域为 $x\\in[-1,1]$。对于每个次数参数 $n\\in\\{1,5,10,25\\}$，请执行以下步骤：\n\n1. 在 $[-1,1]$ 上定义两组共 $n$ 个插值节点：\n   (a) Legendre 多项式 $P_n(x)$ 的 $n$ 个不同实根，任意排序。\n   (b) 第一类 Chebyshev 节点 $x_k=\\cos\\!\\left(\\dfrac{(2k-1)\\pi}{2n}\\right)$，其中 $k=1,2,\\dots,n$，余弦函数的参数以弧度为单位。\n\n2. 对每组节点，构造唯一的、次数至多为 $n-1$ 的多项式插值 $p_{n-1}(x)$，使其在各节点处与 $f(x)$ 相匹配。\n\n3. 在一个覆盖 $[-1,1]$ 区间（即包含 $x=-1$ 和 $x=1$ 且等距分布）、由 $M=2001$ 个点组成的均匀网格 $G$ 上，计算最大绝对插值误差\n$$\nE=\\max_{x\\in G}\\left|f(x)-p_{n-1}(x)\\right|.\n$$\n\n4. 对于每个 $n\\in\\{1,5,10,25\\}$，计算两个值：使用 Legendre 根的 $E_{\\text{Leg}}$ 和使用 Chebyshev 节点的 $E_{\\text{Cheb}}$，两者的定义均如步骤3所示。将这两个误差值均四舍五入至8位小数。\n\n您的程序必须生成单行输出，该行包含一个由四个结果组成的逗号分隔列表（每个 $n$ 对应一个结果），每个结果本身是一个有序对 $[E_{\\text{Leg}},E_{\\text{Cheb}}]$。具体来说，确切的输出格式必须是\n$$\n\\big[\\,[E_{\\text{Leg}}(1),E_{\\text{Cheb}}(1)],\\,[E_{\\text{Leg}}(5),E_{\\text{Cheb}}(5)],\\,[E_{\\text{Leg}}(10),E_{\\text{Cheb}}(10)],\\,[E_{\\text{Leg}}(25),E_{\\text{Cheb}}(25)]\\,\\big],\n$$\n其中每个浮点数在小数点后精确显示8位数字，并且行内任何地方都没有空格。\n\n所有三角函数求值都必须使用弧度单位。不涉及任何物理单位。\n\n测试套件：\n- $n=1$ （只有一个节点的边界情况）。\n- $n=5$ （中等次数）。\n- $n=10$ （较高次数）。\n- $n=25$ （插值数值稳定性的压力测试）。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，`[[a_1,b_1],[a_2,b_2],[a_3,b_3],[a_4,b_4]]`），其中每个 $a_i$ 和 $b_i$ 都是四舍五入到8位小数的浮点数。", "solution": "在尝试任何解决方案之前，需对问题陈述进行验证。\n\n步骤1：提取已知条件\n- 待插值函数：$f(x) = \\dfrac{1}{1+25x^2}$。\n- 插值定义域：$x \\in [-1, 1]$。\n- 多项式次数集合：$n \\in \\{1, 5, 10, 25\\}$。\n- 插值节点：对于每个 $n$，有两组共 $n$ 个节点。\n    - (a) Legendre 节点：Legendre 多项式 $P_n(x)$ 的 $n$ 个不同实根。\n    - (b) 第一类 Chebyshev 节点：$x_k = \\cos\\left(\\dfrac{(2k-1)\\pi}{2n}\\right)$，其中 $k=1, 2, \\dots, n$。\n- 插值多项式：对每组节点，存在一个次数至多为 $n-1$ 的唯一多项式 $p_{n-1}(x)$。\n- 误差评估网格：在 $[-1, 1]$ 上的一个均匀网格 $G$，包含 $M=2001$ 个点，含端点。\n- 误差度量：$E = \\max_{x \\in G} |f(x) - p_{n-1}(x)|$。\n- 要求输出：对于每个 $n$，误差 $E_{\\text{Leg}}$ 和 $E_{\\text{Cheb}}$ 四舍五入到8位小数。\n- 最终输出格式：单行字符串 `[[...],[...],[...],[...]]`。\n\n步骤2：使用提取的已知条件进行验证\n根据既定标准对问题进行分析。\n- **科学性**：该问题是数值分析中的一个标准练习，具体涉及多项式逼近理论。它关系到插值中不同节点选择的比较，这是计算科学中的一个基本课题。函数 $f(x) = \\dfrac{1}{1+25x^2}$ 是典型的 Runge 函数，用于展示高次多项式插值可能出现的发散现象。使用 Legendre 节点和 Chebyshev 节点是减轻这种被称为 Runge 现象的发散的成熟技术。该问题在科学上是正确且相关的。\n- **适定性**：该问题是适定的。对于任意 $n$ 个不同节点的集合，都存在一个次数至多为 $n-1$ 的唯一插值多项式。已知 Legendre 多项式 $P_n(x)$ 的根和指定的 Chebyshev 节点是区间 $(-1, 1)$ 内的 $n$ 个不同实数。计算误差的指令是明确无误的。\n- **客观性**：问题以精确、客观和数学化的语言陈述。所有量和过程都得到了形式化定义。\n\n问题陈述不存在任何缺陷。它不是科学上不成立、不可形式化、不完整、矛盾、不切实际或不适定的。\n\n步骤3：结论与行动\n问题被判定为**有效**。将提供一个解决方案。\n\n本任务旨在比较两组插值节点——Legendre 多项式的根和第一类 Chebyshev 节点——在区间 $[-1, 1]$ 上对 Runge 函数 $f(x) = \\dfrac{1}{1+25x^2}$ 进行插值的有效性。比较基于函数与其多项式插值在不同多项式次数 $n$ 下的最大绝对误差。\n\n问题的核心在于多项式插值理论。给定 $j=0, \\dots, n-1$ 的 $n$ 个不同点 $(x_j, y_j)$，存在一个次数至多为 $n-1$ 的唯一多项式 $p_{n-1}(x)$，使得对所有 $j$ 都有 $p_{n-1}(x_j) = y_j$。虽然这个多项式是唯一的，但它作为底层函数 $f(x)$（其中 $y_j = f(x_j)$）在整个区间上的近似质量在很大程度上取决于节点 $x_j$ 的选择。\n\n对于高次插值，尤其对于像给定函数 $f(x)$ 这样的函数，天真地选择等距节点可能会导致灾难性的结果。当 $n \\to \\infty$ 时，误差在区间端点附近可以无界增长，这种病态现象被称为 Runge 现象。\n\n为克服此问题，必须使用在区间端点附近分布更密集的节点。正交多项式的根是一个极好的选择。本问题研究了两种这样的节点集：\n1.  **Legendre 节点**：Legendre 多项式 $P_n(x)$ 的根，这些多项式是在 $[-1, 1]$ 上关于权函数 $w(x)=1$ 的正交多项式。这些节点也是 Gauss-Legendre 求积的节点，其设计目的是为多项式积分实现尽可能高的精度。\n2.  **Chebyshev 节点**：第一类 Chebyshev 多项式 $T_n(x)$ 的根。这些节点是半圆上等距点在 $x$ 轴上的投影。业已证明，在这些节点上进行插值可以最小化 Lebesgue 常数（该常数限定了插值误差），并且在极小化极大意义上（即最小化最大误差）是近乎最优的。\n\n对于插值多项式的数值构造和求值，我们避免使用以病态著称的 Vandermonde 矩阵。相反，我们采用重心插值公式，该公式计算高效且数值稳定。该插值多项式表示为：\n$$\np_{n-1}(x) = \\frac{\\sum_{j=0}^{n-1} \\frac{w_j}{x-x_j} y_j}{\\sum_{j=0}^{n-1} \\frac{w_j}{x-x_j}}\n$$\n其中 $y_j = f(x_j)$，重心权重 $w_j$ 由 $w_j = \\frac{1}{\\prod_{k \\neq j} (x_j - x_k)}$ 给出。这些权重仅取决于节点，而不取决于函数值，并且可以预先计算。`scipy.interpolate.BarycentricInterpolator` 类提供了此方法的稳健实现。\n\n算法如下：\n1.  定义目标函数 $f(x) = (1+25x^2)^{-1}$ 和在 $[-1, 1]$ 上由 $M=2001$ 个点组成的高分辨率评估网格 $G$。\n2.  对于每个次数参数 $n \\in \\{1, 5, 10, 25\\}$：\n    a.  **Legendre 插值**：\n        i.  使用标准数值库函数（如 `scipy.special.roots_legendre`）计算 $P_n(x)$ 的 $n$ 个根。\n        ii. 在这些节点上计算 $f(x)$ 以获得值 $y_j$。\n        iii. 使用节点和函数值构造一个重心插值器。\n        iv. 在网格 $G$ 上计算所得多项式 $p_{n-1, \\text{Leg}}(x)$ 的值。\n        v.  计算最大绝对误差 $E_{\\text{Leg}} = \\max_{x \\in G} |f(x) - p_{n-1, \\text{Leg}}(x)|$。\n\n    b.  **Chebyshev 插值**：\n        i.  使用公式 $x_k = \\cos\\left( \\frac{(2k-1)\\pi}{2n} \\right)$（其中 $k=1, \\dots, n$）计算 $n$ 个 Chebyshev 节点。\n        ii. 在这些节点上计算 $f(x)$ 的值。\n        iii. 构造第二个重心插值器。\n        iv. 在网格 $G$ 上计算多项式 $p_{n-1, \\text{Cheb}}(x)$ 的值。\n        v.  计算最大绝对误差 $E_{\\text{Cheb}} = \\max_{x \\in G} |f(x) - p_{n-1, \\text{Cheb}}(x)|$。\n\n3.  为每个 $n$ 收集配对 $[E_{\\text{Leg}}, E_{\\text{Cheb}}]$，将值四舍五入到8位小数，并根据问题规范将最终输出格式化为单行字符串。\n\n对于 $n=1$ 的特殊情况，唯一的 Legendre 根是 $x=0$（因为 $P_1(x)=x$），唯一的 Chebyshev 节点是 $x_1=\\cos(\\pi/2)=0$。因此，两种方法使用相同的节点，得到相同的常数插值多项式 $p_0(x) = f(0) = 1$。误差为 $\\max_{x \\in [-1,1]} |(1+25x^2)^{-1} - 1| = |(1+25(1)^2)^{-1} - 1| = 25/26 \\approx 0.96153846$。这可作为对程序的一个基本检验。对于更高的 $n$，两种方法预计都会表现出良好的收敛性，由于 Chebyshev 节点的极小化极大性质，其产生的最大误差通常会略低一些。", "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre\nfrom scipy.interpolate import BarycentricInterpolator\n\ndef solve():\n    \"\"\"\n    Constructs and compares polynomial interpolants for the Runge function\n    using Legendre and Chebyshev nodes, and computes the maximum absolute error.\n    \"\"\"\n    # Define the set of degrees to test\n    degrees = [1, 5, 10, 25]\n\n    # Define the high-resolution grid for error evaluation\n    M = 2001\n    grid_points = np.linspace(-1.0, 1.0, M)\n\n    def target_function(x):\n        \"\"\"The Runge function.\"\"\"\n        return 1.0 / (1.0 + 25.0 * x**2)\n\n    # Evaluate the function on the grid\n    f_on_grid = target_function(grid_points)\n\n    all_results = []\n\n    for n in degrees:\n        # --- Case (a): Legendre Polynomial Roots ---\n\n        # 1. Get the n roots of the Legendre polynomial P_n(x).\n        # These are the nodes for Gauss-Legendre quadrature.\n        # The function returns roots and weights; we only need the roots.\n        leg_nodes, _ = roots_legendre(n)\n\n        # 2. Evaluate the function at the Legendre nodes.\n        leg_values = target_function(leg_nodes)\n\n        # 3. Construct the interpolant using the barycentric formula for stability.\n        leg_interpolator = BarycentricInterpolator(leg_nodes, leg_values)\n        p_leg_on_grid = leg_interpolator(grid_points)\n\n        # 4. Compute the maximum absolute error on the grid.\n        error_leg = np.max(np.abs(f_on_grid - p_leg_on_grid))\n\n        # --- Case (b): Chebyshev Nodes of the First Kind ---\n\n        # 1. Get the n Chebyshev nodes, which are the roots of T_n(x).\n        k = np.arange(1, n + 1)\n        cheb_nodes = np.cos((2 * k - 1) * np.pi / (2 * n))\n        # Ensure nodes are sorted for robustness, though not strictly necessary for BarycentricInterpolator.\n        cheb_nodes = np.sort(cheb_nodes)\n\n        # 2. Evaluate the function at the Chebyshev nodes.\n        cheb_values = target_function(cheb_nodes)\n\n        # 3. Construct the interpolant.\n        cheb_interpolator = BarycentricInterpolator(cheb_nodes, cheb_values)\n        p_cheb_on_grid = cheb_interpolator(grid_points)\n\n        # 4. Compute the maximum absolute error on the grid.\n        error_cheb = np.max(np.abs(f_on_grid - p_cheb_on_grid))\n\n        # Store the pair of rounded errors for the current n\n        all_results.append([error_leg, error_cheb])\n\n    # Format the final output string as per the problem specification.\n    # e.g., [[val1,val2],[val3,val4],...] with 8 decimal places.\n    formatted_pairs = []\n    for pair in all_results:\n        formatted_pair_str = f\"[{pair[0]:.8f},{pair[1]:.8f}]\"\n        formatted_pairs.append(formatted_pair_str)\n    \n    final_output_string = f\"[{','.join(formatted_pairs)}]\"\n\n    print(final_output_string)\n\nsolve()\n```", "id": "2378832"}]}