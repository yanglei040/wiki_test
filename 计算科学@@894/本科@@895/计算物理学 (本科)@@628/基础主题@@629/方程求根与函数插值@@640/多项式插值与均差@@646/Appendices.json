{"hands_on_practices": [{"introduction": "在实验物理学中，我们常常从离散的测量点中获取数据。一个基本而重要的任务是估计这些测量点之间的数值。本练习将引导你应用多项式插值来解决一个典型的物理问题：根据散射实验中在几个特定角度测得的微分截面数据，估算在另一角度的微分截面值 [@problem_id:2428275]。这个实践不仅能巩固你对牛顿插值法的理解，还能让你体会到它在处理真实物理数据时的实用价值。", "problem": "某个散射实验报告了在若干个极角 $\\theta$（角度单位：弧度）下微分截面 $\\sigma(\\theta)$ 的离散测量值，单位为靶恩/球面度 (barn/sr)。假设在每种情况下，$\\sigma(\\theta)$ 在给定数据所覆盖的角度区间内足够平滑，请通过计算唯一存在的、能够精确拟合所提供数据点的最低阶多项式，来确定每种情况下 $\\sigma(\\pi/2)$ 的插值估计值。角度必须以弧度为单位进行处理和计算。最终的插值结果必须以靶恩/球面度表示，并四舍五入到 $10$ 位小数。\n\n请使用以下三个独立的测试用例。在每个用例中，输入包括一个严格递增的弧度角度列表 $\\{\\theta_i\\}$ 和对应的测量截面值 $\\{\\sigma_i\\}$（单位：靶恩/球面度）。对于每个用例，请计算 $\\sigma(\\pi/2)$ 的插值估计值（单位：靶恩/球面度）。\n\n测试用例 A（常规内部插值）：\n- 角度 $\\{\\theta_i\\}$: $\\{0.5,\\,1.2,\\,2.0\\}$ 弧度。\n- 截面 $\\{\\sigma_i\\}$: $\\{12.2,\\,10.1,\\,7.3\\}$ barn/sr。\n\n测试用例 B（目标角度作为数据节点包含在内，在精确计算中可实现精确匹配）：\n- 角度 $\\{\\theta_i\\}$: $\\{0.2,\\,1.0,\\,1.5707963267948966,\\,2.4\\}$ 弧度。\n- 截面 $\\{\\sigma_i\\}$: $\\{11.0,\\,10.0,\\,9.87654321,\\,7.0\\}$ barn/sr。\n\n测试用例 C（节点非均匀分布且数量更多）：\n- 角度 $\\{\\theta_i\\}$: $\\{0.1,\\,0.9,\\,1.3,\\,1.8,\\,2.5\\}$ 弧度。\n- 截面 $\\{\\sigma_i\\}$: $\\{15.0,\\,11.0,\\,9.5,\\,8.2,\\,6.0\\}$ barn/sr。\n\n你的程序必须：\n- 对于每个用例，构建一个阶数至多为 $n-1$ 的唯一多项式，该多项式对 $n$ 个给定点 $(\\theta_i,\\sigma_i)$ 进行插值。\n- 计算该多项式在 $\\theta=\\pi/2$ 弧度处的值。\n- 将每个结果值四舍五入到 $10$ 位小数。\n- 生成单行输出，其中包含按 A、B、C 顺序排列的三个用例的结果。结果应为逗号分隔的列表，并用方括号括起来，例如 $[\\text{result}_A,\\text{result}_B,\\text{result}_C]$。\n\n角度单位：弧度。截面必须以靶恩/球面度 (barn/sr) 为单位报告，并四舍五入到 $10$ 位小数。最终输出必须是与上述格式完全一致的单行文本。", "solution": "问题陈述已经过验证，并被确认是有效的。它在计算物理学中有科学依据，在数学上是适定的，并且是一个客观定义的多项式插值问题。三个测试用例所需的全部数据和条件均已提供，且无内部矛盾。因此，我将继续提供完整解答。\n\n目标是针对三个独立的数据集，估计在特定极角 $\\theta = \\pi/2$ 弧度处的微分截面 $\\sigma(\\theta)$。指定的方法是使用穿过给定数据点 $(\\theta_i, \\sigma_i)$ 的唯一最低阶插值多项式。对于一组 $n$ 个不同的点，这对应于阶数最多为 $n-1$ 的唯一多项式。\n\n完成此任务的一种数值稳健且计算高效的方法是插值多项式的 Newton 形式，该方法利用均差。这种方法特别适用，因为它避免了通过 Vandermonde 矩阵在单项式基中求解多项式系数时常出现的病态问题。\n\n给定一组 $n$ 个数据点 $(x_0, y_0), (x_1, y_1), \\dots, (x_{n-1}, y_{n-1})$，插值多项式 $P(x)$ 的 Newton 形式由下式给出：\n$$ P(x) = \\sum_{k=0}^{n-1} c_k \\prod_{j=0}^{k-1} (x - x_j) $$\n其中系数 $c_k$ 是均差，定义为 $c_k = f[x_0, x_1, \\dots, x_k]$。这些系数通过递归方式计算：\n$$ f[x_i] = y_i $$\n$$ f[x_i, \\dots, x_{i+j}] = \\frac{f[x_{i+1}, \\dots, x_{i+j}] - f[x_i, \\dots, x_{i+j-1}]}{x_{i+j} - x_i} $$\n系数 $c_k$ 是均差表的顶部对角线项。一旦确定了这些系数，就可以使用 Horner 方法高效地计算多项式在某点 $x_{\\text{eval}}$ 的值：\n$$ P(x_{\\text{eval}}) = c_{n-1}(x_{\\text{eval}} - x_{n-2}) + c_{n-2})(x_{\\text{eval}} - x_{n-3}) + \\dots)(x_{\\text{eval}} - x_0) + c_0 $$\n此表达式可从内向外计算，或者在实现中更常见的是迭代计算：\n令 $val = c_{n-1}$。\n对于 $i$ 从 $n-2$ 递减到 $0$：$val = val \\cdot (x_{\\text{eval}} - x_i) + c_i$。\n最终的 $val$ 即为 $P(x_{\\text{eval}})$。\n\n我们现在将此过程应用于每个测试用例，其中 $\\theta$ 对应于 $x$，$\\sigma(\\theta)$ 对应于 $y$。目标角度为 $\\theta_{\\text{eval}} = \\pi/2$。\n\n测试用例 A：\n提供的数据为 $n=3$ 个点：\n- 角度 $\\{\\theta_i\\}: \\{0.5, 1.2, 2.0\\}$\n- 截面 $\\{\\sigma_i\\}: \\{12.2, 10.1, 7.3\\}$\n插值多项式的阶数最高为 $3-1 = 2$。我们构建均差表：\n- 零阶均差：$f[\\theta_0] = 12.2$, $f[\\theta_1] = 10.1$, $f[\\theta_2] = 7.3$\n- 一阶均差：\n  - $f[\\theta_0, \\theta_1] = \\frac{10.1 - 12.2}{1.2 - 0.5} = \\frac{-2.1}{0.7} = -3.0$\n  - $f[\\theta_1, \\theta_2] = \\frac{7.3 - 10.1}{2.0 - 1.2} = \\frac{-2.8}{0.8} = -3.5$\n- 二阶均差：\n  - $f[\\theta_0, \\theta_1, \\theta_2] = \\frac{-3.5 - (-3.0)}{2.0 - 0.5} = \\frac{-0.5}{1.5} = -1/3$\nNewton 多项式的系数为 $c_0 = 12.2$，$c_1 = -3.0$ 和 $c_2 = -1/3$。我们在 $\\theta = \\pi/2$ 处计算该多项式的值：\n$P(\\pi/2) = c_2 \\cdot (\\pi/2 - \\theta_1) + c_1$\n$P(\\pi/2) = (P(\\pi/2)) \\cdot (\\pi/2 - \\theta_0) + c_0$\n数值计算结果为：\n$P(\\pi/2) = (-1/3) \\cdot (\\pi/2 - 1.2) - 3.0$\n$P(\\pi/2) = ((-1/3) \\cdot (\\pi/2 - 1.2) - 3.0) \\cdot (\\pi/2 - 0.5) + 12.2 \\approx 8.8552689974$。\n\n测试用例 B：\n提供的数据为 $n=4$ 个点：\n- 角度 $\\{\\theta_i\\}: \\{0.2, 1.0, 1.5707963267948966, 2.4\\}$\n- 截面 $\\{\\sigma_i\\}: \\{11.0, 10.0, 9.87654321, 7.0\\}$\n插值目标角度为 $\\theta = \\pi/2$。我们观察到第三个数据节点 $\\theta_2 = 1.5707963267948966$ 是 $\\pi/2$ 的浮点表示。根据定义，插值多项式必须精确地穿过所有给定的数据点。因此，对于所有 $i = 0, 1, 2, 3$，$P(\\theta_i) = \\sigma_i$ 均成立。\n因此，当 $\\theta = \\theta_2 = \\pi/2$ 时，多项式的值就是对应的截面值 $\\sigma_2$。\n$P(\\pi/2) = \\sigma_2 = 9.87654321$。无需进一步计算。\n\n测试用例 C：\n提供的数据为 $n=5$ 个点：\n- 角度 $\\{\\theta_i\\}: \\{0.1, 0.9, 1.3, 1.8, 2.5\\}$\n- 截面 $\\{\\sigma_i\\}: \\{15.0, 11.0, 9.5, 8.2, 6.0\\}$\n插值多项式的阶数最高为 $5-1=4$。此过程与用例 A 相同，但用于更大的一组点。我们计算均差以找到 Newton 系数 $c_0, c_1, c_2, c_3, c_4$。\n- $c_0 = f[\\theta_0] = 15.0$\n- $c_1 = f[\\theta_0, \\theta_1] = -5.0$\n- $c_2 = f[\\theta_0, \\theta_1, \\theta_2] \\approx 1.0416666667$\n- $c_3 = f[\\theta_0, \\theta_1, \\theta_2, \\theta_3] \\approx 0.1388888889$\n- $c_4 = f[\\theta_0, \\theta_1, \\theta_2, \\theta_3, \\theta_4] \\approx -0.50843254$\n使用这些系数和 Horner 方法计算 $P(\\pi/2)$ 的值：\n$P(\\pi/2) = ((((c_4(\\pi/2 - \\theta_3) + c_3)(\\pi/2 - \\theta_2) + c_2)(\\pi/2 - \\theta_1) + c_1)(\\pi/2 - \\theta_0) + c_0)$\n此计算得出的值为 $P(\\pi/2) \\approx 8.9410183358$。\n\n根据要求，将用例 A、B 和 C 的最终结果四舍五入到 $10$ 位小数，分别为 $8.8552689974$、$9.87654321$ 和 $8.9410183358$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the polynomial interpolation problem for three test cases.\n    \"\"\"\n\n    # --- Test Cases ---\n    test_cases = [\n        # Case A: General interior interpolation\n        (np.array([0.5, 1.2, 2.0]), np.array([12.2, 10.1, 7.3])),\n        # Case B: Target angle is a data node\n        (np.array([0.2, 1.0, 1.5707963267948966, 2.4]), np.array([11.0, 10.0, 9.87654321, 7.0])),\n        # Case C: Nonuniform spacing with more nodes\n        (np.array([0.1, 0.9, 1.3, 1.8, 2.5]), np.array([15.0, 11.0, 9.5, 8.2, 6.0])),\n    ]\n\n    target_angle = np.pi / 2\n    results = []\n\n    def get_newton_coeffs(x_nodes: np.ndarray, y_nodes: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Computes the coefficients of the Newton form of the interpolating polynomial.\n        The algorithm computes the divided differences table in-place.\n        \"\"\"\n        n = len(x_nodes)\n        coeffs = np.copy(y_nodes).astype(float)\n        for k in range(1, n):\n            # To compute the k-th order differences, we need x distance of k\n            # coeffs[i] becomes f[x_{i-k}, ..., x_i]\n            for i in range(n - 1, k - 1, -1):\n                coeffs[i] = (coeffs[i] - coeffs[i - 1]) / (x_nodes[i] - x_nodes[i - k])\n        return coeffs\n\n    def eval_newton_poly(x_nodes: np.ndarray, coeffs: np.ndarray, x_eval: float) -> float:\n        \"\"\"\n        Evaluates the Newton polynomial at a given point using Horner's method.\n        \"\"\"\n        n = len(coeffs)\n        # Start from the highest order coefficient\n        result = coeffs[n - 1]\n        # Apply Horner's method\n        for i in range(n - 2, -1, -1):\n            result = result * (x_eval - x_nodes[i]) + coeffs[i]\n        return result\n\n    for x_nodes, y_nodes in test_cases:\n        # Check if the target angle is one of the nodes\n        # Use np.isclose for robust floating-point comparison\n        is_node, indices = np.isclose(x_nodes, target_angle), np.where(np.isclose(x_nodes, target_angle))\n        if np.any(is_node):\n            # If the target is a node, the interpolated value is the node's y-value\n            result = y_nodes[indices[0][0]]\n        else:\n            # Otherwise, perform Newton interpolation\n            coeffs = get_newton_coeffs(x_nodes, y_nodes)\n            result = eval_newton_poly(x_nodes, coeffs, target_angle)\n        \n        # Round the result to 10 decimal places\n        results.append(round(result, 10))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2428275"}, {"introduction": "许多物理量本质上是复数，例如交流电路的阻抗、量子力学中的波函数或材料的介电常数。幸运的是，多项式插值的数学框架具有很好的普适性。本练习将挑战你将牛顿差分法从实数域推广到复数域，用于处理一个电路的复阻抗数据 [@problem_id:2428278]。通过这个实践，你将发现插值算法的代数本质，并学会如何将其应用于更广泛的、涉及复数的物理情境中。", "problem": "您的任务是通过多项式插值重建一个关于角频率的复值阻抗函数。该阻抗被定义为函数 $Z(\\omega) = R(\\omega) + i X(\\omega)$，其中 $\\omega$ 是角频率（单位为弧度/秒），$R(\\omega)$ 是实部（单位为欧姆），$X(\\omega)$ 是虚部（单位为欧姆），$i$ 表示虚数单位。目标是针对一小组样本频率及其复阻抗，在复数域上数值地构建唯一的插值多项式，然后在一系列指定的查询频率上对该多项式进行求值。您必须使用通过复数域上的差商构建的牛顿多项式插值法。\n\n基本原理：使用以下定义：存在一个次数至多为 $n$ 的唯一多项式 $p\\_n(\\omega)$，它对 $n+1$ 个不同的样本点 $\\{(\\omega\\_k, Z(\\omega\\_k))\\}$ 进行插值。将差商定义为与 $p\\_n(\\omega)$ 的唯一性相一致的递归定义的离散导数。根据复数域的代数规则处理复数值，并使用复数绝对值 $|z|$（其中 $z \\in \\mathbb{C}$）来量化误差。\n\n您的程序必须：\n- 使用在 $\\mathbb{C}$ 上的差商为给定样本构建牛顿形式的插值多项式。\n- 在指定的查询角频率处对插值多项式进行求值。\n- 计算在所有给定查询中的最大绝对误差大小 $E = \\max\\_j |Z\\_{\\mathrm{interp}}(\\omega\\_j) - Z\\_{\\mathrm{true}}(\\omega\\_j)|$（单位为欧姆）。\n- 将每个测试用例的最大误差 $E$ 报告为一个实数（单位为欧姆），四舍五入到小数点后六位。\n\n所有角频率的单位均为弧度/秒。所有阻抗量的单位均为欧姆。角度不直接出现；请勿转换单位。\n\n测试套件：\n- 测试用例 1（串联电阻-电感，恰好为 1 次多项式）：\n  - 真实阻抗：$Z(\\omega) = R + i \\,\\omega L$，其中 $R = 47\\,\\mathrm{\\Omega}$ 且 $L = 0.01\\,\\mathrm{H}$。\n  - 样本节点：$\\{\\omega\\_0,\\omega\\_1\\} = \\{100, 700\\}$。\n  - 查询点：$\\{150, 1000\\}$。\n  - 预期行为：由于 $Z(\\omega)$ 是关于 $\\omega$ 的线性函数，因此对于任何 $\\omega$，插值都应是精确的；最大误差在舍入误差范围内应为数值 0。\n- 测试用例 2（串联电阻-电感-电容，非 $\\omega$ 的多项式）：\n  - 真实阻抗：$Z(\\omega) = R + i\\left(\\omega L - \\dfrac{1}{\\omega C}\\right)$，其中 $R = 10\\,\\mathrm{\\Omega}$，$L = 0.005\\,\\mathrm{H}$，$C = 20\\times 10^{-6}\\,\\mathrm{F}$。\n  - 样本节点：$\\{\\omega\\_0,\\omega\\_1,\\omega\\_2,\\omega\\_3,\\omega\\_4\\} = \\{100, 400, 700, 1000, 1300\\}$。\n  - 查询点：$\\{250, 450, 900, 1100\\}$。\n  - 预期行为：插值是一个近似；报告最大绝对误差大小（单位为欧姆）。\n- 测试用例 3（纯电容，单个样本的边界情况）：\n  - 真实阻抗：$Z(\\omega) = -\\dfrac{i}{\\omega C}$，其中 $C = 50\\times 10^{-6}\\,\\mathrm{F}$。\n  - 样本节点：$\\{\\omega\\_0\\} = \\{500\\}$。\n  - 查询点：$\\{250, 1000\\}$。\n  - 预期行为：插值函数是一个常数，等于在 $\\omega = 500$ 处的采样值，因此误差反映了常数插值函数与真实函数的偏差；报告最大绝对误差大小（单位为欧姆）。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个最大误差大小，每个误差都四舍五入到小数点后六位，形式为用方括号括起来的逗号分隔列表，即 $[e\\_1,e\\_2,e\\_3]$，其中每个 $e\\_k$ 的单位都是欧姆，并且是格式化为小数点后六位的实数。", "solution": "所给出的问题是数值分析中的一个标准练习，具体而言是应用多项式插值来近似一个复值函数。任务是使用带有差商的牛顿形式，在复数域 $\\mathbb{C}$ 上构建一个插值多项式，并评估其准确性。对问题陈述进行彻底验证是强制性的第一步。\n\n### 步骤 1：提取已知条件\n- **目标**：使用牛顿多项式插值重建复值阻抗函数 $Z(\\omega) = R(\\omega) + i X(\\omega)$。\n- **方法**：使用在 $\\mathbb{C}$ 上的差商来找到牛顿形式插值多项式的系数。\n- **评估指标**：在指定的查询频率上计算最大绝对误差 $E = \\max_j |Z_{\\mathrm{interp}}(\\omega_j) - Z_{\\mathrm{true}}(\\omega_j)|$。\n- **测试用例 1**：\n    - 真实函数：$Z(\\omega) = R + i \\,\\omega L$，其中 $R = 47\\,\\mathrm{\\Omega}$ 且 $L = 0.01\\,\\mathrm{H}$。\n    - 样本节点：$\\omega \\in \\{100, 700\\}$。\n    - 查询节点：$\\omega \\in \\{150, 1000\\}$。\n- **测试用例 2**：\n    - 真实函数：$Z(\\omega) = R + i\\left(\\omega L - \\dfrac{1}{\\omega C}\\right)$，其中 $R = 10\\,\\mathrm{\\Omega}$，$L = 0.005\\,\\mathrm{H}$，且 $C = 20\\times 10^{-6}\\,\\mathrm{F}$。\n    - 样本节点：$\\omega \\in \\{100, 400, 700, 1000, 1300\\}$。\n    - 查询节点：$\\omega \\in \\{250, 450, 900, 1100\\}$。\n- **测试用例 3**：\n    - 真实函数：$Z(\\omega) = -\\dfrac{i}{\\omega C}$，其中 $C = 50\\times 10^{-6}\\,\\mathrm{F}$。\n    - 样本节点：$\\omega \\in \\{500\\}$。\n    - 查询节点：$\\omega \\in \\{250, 1000\\}$。\n- **输出格式**：一个包含三个最大误差值的列表，`[e_1, e_2, e_3]`，四舍五入到小数点后六位。\n\n### 步骤 2：使用提取的已知条件进行验证\n对问题进行严格验证。\n\n- **科学依据**：该问题基于电气工程（RLC 电路阻抗）和数学（复数域上的多项式插值）的基本原理。所用的物理模型和数学方法都是公认且事实合理的。根据此标准，该问题是有效的。\n- **适定性**：对于每个测试用例，不同样本节点的数量足以定义一个唯一的插值多项式。真实函数已指定，从而可以计算误差。问题提供了所有必要的数据并定义了明确的目标。它是适定的。\n- **客观性**：问题陈述使用了精确、无歧义的数学和物理术语。没有主观或基于观点性的元素。该问题是客观的。\n\n该问题没有表现出任何诸如科学上不合理、歧义或不完整性等缺陷。元件值和频率在物理上是现实的。\n\n### 步骤 3：结论与行动\n该问题被视为**有效**。将构建一个解决方案。\n\n### 解决方案推导\n\n该问题的基础是插值多项式的存在性与唯一性。对于一组给定的 $n+1$ 个不同数据点 $\\{(\\omega_0, z_0), (\\omega_1, z_1), \\dots, (\\omega_n, z_n)\\}$，其中 $\\omega_k \\in \\mathbb{R}$ 是不同的样本频率，而 $z_k = Z(\\omega_k) \\in \\mathbb{C}$ 是对应的复阻抗，存在一个次数至多为 $n$ 的唯一多项式 $P_n(\\omega)$，使得对所有 $k \\in \\{0, \\dots, n\\}$ 都有 $P_n(\\omega_k) = z_k$。\n\n我们采用该多项式的牛顿形式，其表达式为：\n$$\nP_n(\\omega) = \\sum_{k=0}^{n} c_k \\prod_{j=0}^{k-1} (\\omega - \\omega_j)\n$$\n其中，对于 $k=0$ 的乘积项 $\\prod_{j=0}^{-1} (\\dots)$ 定义为 $1$。系数 $c_k$ 是递归定义的差商。所有算术运算都在复数域 $\\mathbb{C}$ 中执行。\n\n差商由以下公式给出：\n- 零阶：$c_0 = f[\\omega_0] = z_0$\n- $k$ 阶：$c_k = f[\\omega_0, \\omega_1, \\dots, \\omega_k]$\n通用递归定义为：\n$$\nf[\\omega_i, \\dots, \\omega_j] = \\frac{f[\\omega_{i+1}, \\dots, \\omega_j] - f[\\omega_i, \\dots, \\omega_{j-1}]}{\\omega_j - \\omega_i}\n$$\n出于计算目的，我们构建一个差商表。系数 $c_k = f[\\omega_0, \\dots, \\omega_k]$ 构成了此表的顶部对角线。一种高效的算法逐列计算，只存储必要的中间值。\n\n一旦确定了系数 $\\{c_0, c_1, \\dots, c_n\\}$，就可以使用嵌套形式在任何查询点 $\\omega_{query}$ 对多项式 $P_n(\\omega)$ 进行求值，这是霍纳法则为了数值稳定性和效率的应用：\n$$\nP_n(\\omega_{query}) = c_0 + (\\omega_{query} - \\omega_0)(c_1 + (\\omega_{query} - \\omega_1)(c_2 + \\dots + (\\omega_{query} - \\omega_{n-1})c_n)\\dots)\n$$\n求值从最内层项向外进行。\n\n在查询点 $\\omega_{query}$ 的绝对误差计算为插值与真实值之差的模：\n$$\n\\text{Error} = |P_n(\\omega_{query}) - Z_{\\mathrm{true}}(\\omega_{query})|\n$$\n每个测试用例的最终结果是所有指定查询点上这些误差的最大值。\n\n**测试用例分析：**\n\n- **测试用例 1：** 真实阻抗函数 $Z(\\omega) = 47 + i(0.01)\\omega$ 是一个关于 $\\omega$ 的 1 次多项式。我们给定了两个不同的样本点 $(\\omega_0, \\omega_1) = (100, 700)$。穿过这两个点的次数至多为 1 的唯一插值多项式必须是 $Z(\\omega)$ 函数本身。\n    - $z_0 = Z(100) = 47 + 1i$\n    - $z_1 = Z(700) = 47 + 7i$\n    - $c_0 = z_0 = 47 + 1i$\n    - $c_1 = \\frac{z_1 - z_0}{\\omega_1 - \\omega_0} = \\frac{(47 + 7i) - (47 + 1i)}{700 - 100} = \\frac{6i}{600} = 0.01i$\n    - $P_1(\\omega) = c_0 + c_1(\\omega - \\omega_0) = (47 + 1i) + 0.01i(\\omega - 100) = 47 + 1i + 0.01i\\omega - 1i = 47 + 0.01i\\omega$。\n    这与 $Z_{\\mathrm{true}}(\\omega)$ 完全相同。因此，在任何查询点上的误差都将为 $0$。最大误差 $E_1$ 必须为 $0$，仅受机器精度限制。\n\n- **测试用例 2：** 真实函数 $Z(\\omega) = 10 + i(\\omega L - 1/(\\omega C))$ 包含一个与 $1/\\omega$ 成正比的项，因此它不是一个多项式。用一个 4 次多项式（因为有 5 个样本点）进行插值将是一个近似。预计会产生误差。必须数值化地执行所述算法以找到此误差。\n\n- **测试用例 3：** 我们给出了一个样本点 $(\\omega_0) = (500)$。插值多项式的次数必须至多为 $1-1=0$，这意味着它是一个常数。\n    - $z_0 = Z_{\\mathrm{true}}(500) = -\\dfrac{i}{500 \\times 50 \\times 10^{-6}} = -\\dfrac{i}{0.025} = -40i$。\n    - 插值多项式是 $P_0(\\omega) = z_0 = -40i$。\n    我们在查询点评估误差：\n    - 在 $\\omega_{q1} = 250$ 处：\n        - $Z_{\\mathrm{interp}}(250) = -40i$。\n        - $Z_{\\mathrm{true}}(250) = -\\dfrac{i}{250 \\times 50 \\times 10^{-6}} = -80i$。\n        - 误差$_1 = |-40i - (-80i)| = |40i| = 40$。\n    - 在 $\\omega_{q2} = 1000$ 处：\n        - $Z_{\\mathrm{interp}}(1000) = -40i$。\n        - $Z_{\\mathrm{true}}(1000) = -\\dfrac{i}{1000 \\times 50 \\times 10^{-6}} = -20i$。\n        - 误差$_2 = |-40i - (-20i)| = |-20i| = 20$。\n    最大误差为 $E_3 = \\max(40, 20) = 40.0$。\n\n实现将精确遵循此逻辑，对所有情况使用数值计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_newton_coeffs(sample_nodes: np.ndarray, sample_values: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the coefficients for Newton's divided difference interpolating polynomial.\n    This implementation uses an efficient, space-optimized algorithm that reuses a\n    single array to compute the coefficients, which are the top diagonal of the\n    divided difference table.\n    \n    Args:\n        sample_nodes (np.ndarray): The x-coordinates of the sample points (real).\n        sample_values (np.ndarray): The y-coordinates of the sample points (complex).\n\n    Returns:\n        np.ndarray: The array of complex-valued Newton coefficients.\n    \"\"\"\n    n = len(sample_nodes)\n    if n == 0:\n        return np.array([], dtype=np.complex128)\n        \n    # Use a copy of sample_values to build the divided differences in-place\n    F = np.copy(sample_values)\n    coeffs = np.zeros(n, dtype=np.complex128)\n    coeffs[0] = F[0]\n    \n    # For each order of difference k > 0\n    for k in range(1, n):\n        # Update the F array to represent the k-th column of the DD table\n        # F[j] will become f[x_{j-k}, ..., x_j]\n        for j in range(n - 1, k - 1, -1):\n            denominator = sample_nodes[j] - sample_nodes[j-k]\n            if denominator == 0:\n                # This should not happen with distinct nodes\n                raise ValueError(\"Sample nodes must be distinct.\")\n            F[j] = (F[j] - F[j-1]) / denominator\n        coeffs[k] = F[k]\n        \n    return coeffs\n\ndef evaluate_newton_poly(sample_nodes: np.ndarray, coeffs: np.ndarray, query_point: float) -> np.complex128:\n    \"\"\"\n    Evaluates the Newton-form polynomial at a given query point.\n    Uses Horner's method for numerical stability and efficiency.\n    \n    P(x) = c_0 + (x - x_0)(c_1 + (x - x_1)(c_2 + ...))\n    \n    Args:\n        sample_nodes (np.ndarray): The original sample nodes x_0, x_1, ...\n        coeffs (np.ndarray): The Newton coefficients c_0, c_1, ...\n        query_point (float): The point at which to evaluate the polynomial.\n\n    Returns:\n        np.complex128: The value of the polynomial at the query point.\n    \"\"\"\n    n = len(coeffs) - 1\n    if n < 0:\n        return np.complex128(0.0) # Or handle as an error for empty coefficients\n        \n    # Horner's method evaluation, starting from the innermost term\n    p_val = coeffs[n]\n    for k in range(n - 1, -1, -1):\n        p_val = coeffs[k] + (query_point - sample_nodes[k]) * p_val\n    return p_val\n\ndef solve_case(Z_true, sample_nodes_list, query_nodes_list):\n    \"\"\"\n    Orchestrates the solution for a single test case.\n    \n    Args:\n        Z_true (callable): The true impedance function Z(omega).\n        sample_nodes_list (list): List of sample frequencies.\n        query_nodes_list (list): List of query frequencies.\n\n    Returns:\n        float: The maximum absolute error.\n    \"\"\"\n    sample_nodes = np.array(sample_nodes_list, dtype=float)\n    query_nodes = np.array(query_nodes_list, dtype=float)\n\n    # 1. Generate sample impedance values from the true function\n    sample_impedances = Z_true(sample_nodes)\n\n    # 2. Compute the Newton polynomial coefficients from the samples\n    coeffs = get_newton_coeffs(sample_nodes, sample_impedances)\n\n    # 3. Evaluate the interpolating polynomial at each query frequency\n    interp_impedances = np.array([evaluate_newton_poly(sample_nodes, coeffs, q) for q in query_nodes], dtype=np.complex128)\n    \n    # 4. Evaluate the true function at each query frequency\n    true_impedances_at_query = Z_true(query_nodes)\n    \n    # 5. Compute the absolute errors and find the maximum\n    errors = np.abs(interp_impedances - true_impedances_at_query)\n    max_error = np.max(errors) if errors.size > 0 else 0.0\n    \n    return max_error\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"Z_true\": lambda omega: 47.0 + 1j * omega * 0.01,\n            \"samples\": [100.0, 700.0],\n            \"queries\": [150.0, 1000.0]\n        },\n        {\n            \"Z_true\": lambda omega: 10.0 + 1j * (omega * 0.005 - 1.0 / (omega * 20e-6)),\n            \"samples\": [100.0, 400.0, 700.0, 1000.0, 1300.0],\n            \"queries\": [250.0, 450.0, 900.0, 1100.0]\n        },\n        {\n            \"Z_true\": lambda omega: -1j / (omega * 50e-6),\n            \"samples\": [500.0],\n            \"queries\": [250.0, 1000.0]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Calculate the maximum error for one case.\n        max_error = solve_case(case[\"Z_true\"], case[\"samples\"], case[\"queries\"])\n        results.append(max_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "2428278"}, {"introduction": "多项式插值不仅能用于估算函数值，还能用于探索函数或数据背后的深层几何特性。在这个高级练习中，你将使用二次插值来逼近一个圆弧，并进而估算该圆的圆心和半径 [@problem_id:2428257]。这个过程巧妙地将插值与微分几何中的曲率概念联系起来，因为插值多项式的二阶导数可以用来近似计算曲线的曲率。此外，本练习还将揭示一个重要的数值计算问题：使用插值法进行数值微分时，结果对输入数据的噪声会异常敏感，这是一个在所有科学计算中都必须警惕的关键实践教训。", "problem": "给定三个不同的样本点 $\\left(x_0,y_0\\right)$、$\\left(x_1,y_1\\right)$ 和 $\\left(x_2,y_2\\right)$，它们位于一条光滑的平面曲线上。在 $x_1$ 附近，该曲线可以表示为单值函数 $y=y(x)$。假设该基础曲线是一个未知圆心为 $\\left(a,b\\right)$、未知半径为 $R$ 的圆。您的任务是使用通过牛顿均差构建的多项式插值，仅根据这三个点来估计圆的圆心和半径，然后检验这些估计值对 $y$ 坐标观测噪声的敏感性。\n\n基本依据和目标：\n- 从牛顿均差的定义和构建穿过 $\\left(x_0,y_0\\right)$、$\\left(x_1,y_1\\right)$ 和 $\\left(x_2,y_2\\right)$ 的二次插值多项式出发。\n- 仅使用这些基础知识和核心几何事实，从第一性原理推导如何在不借助任何无法从定义中推导出的结果的情况下，获得二次插值式在 $x_1$ 处的一阶和二阶导数。\n- 从平面曲线的曲率与密切圆之间的几何关系出发，推导 $x_1$ 处的曲率如何决定密切圆的半径，以及其圆心相对于点 $\\left(x_1,y_1\\right)$ 及局部切线和法线方向的位置。\n- 用代码实现此方法，并在一个小型测试套件上进行评估。该套件包括无噪声和含噪声数据、对称和非对称节点布局，以及一个近乎笔直的弧（大半径）情况。所有量均视为无量纲；不涉及任何物理单位。\n\n详细要求：\n1. 使用牛顿均差构建穿过给定三个点的唯一二次插值式 $p_2(x)$。基于节点 $x_0$、$x_1$ 和 $x_2$ 以牛顿形式表示 $p_2(x)$。然后，通过对该多项式求导，获得 $p_2'(x)$ 和 $p_2''(x)$，从而直接从均差计算出 $p_2'(x_1)$ 和 $p_2''(x_1)$。除了从均差定义和多项式微分中得出的结论外，不要假设任何特殊公式。\n2. 根据几何原理，以 $y=y(x)$ 形式给出的平面曲线的曲率 $\\kappa$ 与其某点处的一阶和二阶导数相关。利用此关系将 $x_1$ 处的曲率与密切圆的半径 $R$ 联系起来。此外，通过从 $\\left(x_1,y_1\\right)$ 沿适当的单位法线方向移动等于半径的距离，来确定密切圆的圆心 $\\left(a,b\\right)$。利用局部凹性的符号来选择正确的法线方向。在您的推导中，除了基本的微分几何定义和向量归一化外，不要假设任何封闭形式的捷径。\n3. 实现一个程序，对每个提供的测试用例执行以下操作：\n   - 使用 $y_i=b+s\\sqrt{R^2-\\left(x_i-a\\right)^2}$（对于指定的分支符号 $s\\in\\{+1,-1\\}$）在具有给定真实参数 $\\left(a,b,R\\right)$ 的圆上生成三个点 $\\left(x_i,y_i\\right)$。在以下所有情况中均使用 $s=+1$。\n   - 可选地，向每个 $y_i$ 添加具有指定标准差 $\\sigma$ 的独立、零均值高斯噪声，保持 $x_i$ 不变，以获得观测值 $\\tilde{y}_i$。\n   - 构建穿过 $\\left(x_i,\\tilde{y}_i\\right)$ 的二次牛顿插值式，计算在 $x_1$ 处的一阶和二阶导数，并由此计算出密切圆圆心 $\\left(\\hat{a},\\hat{b}\\right)$ 和半径 $\\hat{R}$。\n   - 报告该案例的绝对误差 $\\left(|\\hat{a}-a|,|\\hat{b}-b|,|\\hat{R}-R|\\right)$。\n\n数值和格式化要求：\n- 所有计算都是无量纲的。\n- 如果使用噪声，则它是从均值为零、标准差为指定值 $\\sigma$ 的正态分布中抽取的独立样本，并加到每个 $y_i$ 上。为了可复现性，请使用提供的随机种子。如果在推导中隐式涉及角度，则无需报告，也不需要角度单位。\n- 对于每个测试用例，报告一个包含三个浮点数的列表，对应于 $\\left(|\\hat{a}-a|,|\\hat{b}-b|,|\\hat{R}-R|\\right)$。在打印前，将每个报告的浮点数四舍五入到 $12$ 位小数。\n- 您的程序应生成单行输出，其中包含结果，形式为一个用方括号括起来的、以逗号分隔的列表，每个测试用例的三元组都包含在其自己的方括号内，且没有空格。例如，有效格式为 $\\left[\\left[0.0,0.0,0.0\\right],\\left[1.0,2.0,3.0\\right]\\right]$。\n\n测试套件：\n- 案例 $1$ (无噪声、对称节点、中等曲率):\n  - 真实参数: $\\left(a,b,R\\right)=\\left(0.75,-0.5,1.9\\right)$。\n  - 节点: $x_0=a-0.5$, $x_1=a$, $x_2=a+0.5$。\n  - 分支: $s=+1$。\n  - 噪声: $\\sigma=0$。\n- 案例 $2$ (无噪声、非对称节点、中等曲率):\n  - 真实参数: $\\left(a,b,R\\right)=\\left(0.75,-0.5,1.9\\right)$。\n  - 节点: $x_0=a-0.6$, $x_1=a+0.1$, $x_2=a+0.7$。\n  - 分支: $s=+1$。\n  - 噪声: $\\sigma=0$。\n- 案例 $3$ (含噪声、对称节点、中等曲率):\n  - 真实参数: $\\left(a,b,R\\right)=\\left(0.75,-0.5,1.9\\right)$。\n  - 节点: $x_0=a-0.5$, $x_1=a$, $x_2=a+0.5$。\n  - 分支: $s=+1$。\n  - 噪声: $\\sigma=10^{-5}$，随机种子 $12345$。\n- 案例 $4$ (无噪声、对称节点、近乎笔直的弧):\n  - 真实参数: $\\left(a,b,R\\right)=\\left(10.0,-20.0,1000.0\\right)$。\n  - 节点: $x_0=a-0.1$, $x_1=a$, $x_2=a+0.1$。\n  - 分支: $s=+1$。\n  - 噪声: $\\sigma=0$。\n- 案例 $5$ (含噪声、对称节点、近乎笔直的弧):\n  - 真实参数: $\\left(a,b,R\\right)=\\left(10.0,-20.0,1000.0\\right)$。\n  - 节点: $x_0=a-0.1$, $x_1=a$, $x_2=a+0.1$。\n  - 分支: $s=+1$。\n  - 噪声: $\\sigma=10^{-8}$，随机种子 $24680$。\n\n最终输出格式：\n- 单行，包含一个五个误差三元组的列表，按案例 $1$ 到 $5$ 的顺序排列，作为一个用方括号括起来的、以逗号分隔的列表，没有空格，每个三元组都四舍五入到 $12$ 位小数。例如：$\\left[\\left[e_{1a},e_{1b},e_{1R}\\right],\\left[e_{2a},e_{2b},e_{2R}\\right],\\left[e_{3a},e_{3b},e_{3R}\\right],\\left[e_{4a},e_{4b},e_{4R}\\right],\\left[e_{5a},e_{5b},e_{5R}\\right]\\right]$，其中每个 $e$ 表示相应的绝对误差。", "solution": "所提出的问题陈述是有效的。它在科学上基于数值分析和微分几何的原理，提法清晰，目标明确，并提供了进行唯一求解所需的所有信息。任务是利用通过牛顿均差构建的二次插值式，并使用其在中心点的密切圆的几何性质，从三个样本点估计圆的参数。这是计算物理学中一个标准且可验证的问题。\n\n我们将严格遵循指定的要求，进行推导和求解。\n\n**第一部分：二次插值式及其导数**\n\n给定三个不同的点 $(x_0, y_0)$、$(x_1, y_1)$ 和 $(x_2, y_2)$，且它们的横坐标各不相同，那么存在一个唯一的、次数至多为二的多项式穿过这些点。我们使用牛顿形式来构建这个多项式 $p_2(x)$。\n\n首先，我们定义所需的均差：\n零阶均差就是函数值本身：\n$$f[x_i] = y_i$$\n一阶均差是两点之间割线的斜率：\n$$f[x_i, x_j] = \\frac{f[x_j] - f[x_i]}{x_j - x_i}$$\n二阶均差是一阶均差的差：\n$$f[x_i, x_j, x_k] = \\frac{f[x_j, x_k] - f[x_i, x_j]}{x_k - x_i}$$\n\n穿过 $(x_0, y_0)$、$(x_1, y_1)$ 和 $(x_2, y_2)$ 的二次插值多项式的牛顿形式由下式给出：\n$$p_2(x) = f[x_0] + f[x_0, x_1](x - x_0) + f[x_0, x_1, x_2](x - x_0)(x - x_1)$$\n我们把作为系数的均差表示为 $c_0 = f[x_0]$、$c_1 = f[x_0, x_1]$ 和 $c_2 = f[x_0, x_1, x_2]$。那么多项式就是：\n$$p_2(x) = c_0 + c_1(x - x_0) + c_2(x - x_0)(x - x_1)$$\n\n为了找到插值多项式的一阶和二阶导数，我们对 $p_2(x)$ 关于 $x$ 求导。\n一阶导数 $p_2'(x)$ 是：\n$$p_2'(x) = \\frac{d}{dx} \\left[ c_0 + c_1(x - x_0) + c_2(x^2 - (x_0 + x_1)x + x_0x_1) \\right]$$\n$$p_2'(x) = 0 + c_1 + c_2(2x - (x_0 + x_1))$$\n$$p_2'(x) = c_1 + c_2((x - x_0) + (x - x_1))$$\n我们在中心点 $x_1$ 处计算该值：\n$$p_2'(x_1) = c_1 + c_2((x_1 - x_0) + (x_1 - x_1)) = c_1 + c_2(x_1 - x_0)$$\n代入均差 $c_1$ 和 $c_2$ 的定义：\n$$p_2'(x_1) = f[x_0, x_1] + f[x_0, x_1, x_2](x_1 - x_0)$$\n\n二阶导数 $p_2''(x)$ 通过对 $p_2'(x)$ 求导得到：\n$$p_2''(x) = \\frac{d}{dx} \\left[ c_1 + c_2(2x - x_0 - x_1) \\right] = 2c_2$$\n二次多项式的二阶导数是常数。因此，在 $x_1$ 处：\n$$p_2''(x_1) = 2c_2 = 2f[x_0, x_1, x_2]$$\n这些关于 $p_2'(x_1)$ 和 $p_2''(x_1)$ 的表达式是直接从牛顿多项式的定义中推导出来的，我们将用它们进行计算。\n\n**第二部分：密切圆参数**\n\n曲线上某一点的密切圆是在该点最能近似曲线的圆。它的半径是曲率的倒数，圆心位于法线上。\n\n对于由 $y = y(x)$ 定义的曲线，其曲率 $\\kappa$ 由以下公式给出：\n$$\\kappa(x) = \\frac{|y''(x)|}{(1 + [y'(x)]^2)^{3/2}}$$\n我们用插值多项式 $p_2(x)$ 在 $x=x_1$ 处的曲率来近似基础曲线在 $(x_1, y_1)$ 处的曲率。设此曲率为 $\\hat{\\kappa}$。\n$$\\hat{\\kappa} = \\frac{|p_2''(x_1)|}{(1 + [p_2'(x_1)]^2)^{3/2}}$$\n密切圆的估计半径 $\\hat{R}$ 是该曲率的倒数：\n$$\\hat{R} = \\frac{1}{\\hat{\\kappa}} = \\frac{(1 + [p_2'(x_1)]^2)^{3/2}}{|p_2''(x_1)|}$$\n\n密切圆的圆心 $(\\hat{a}, \\hat{b})$ 位于距离点 $(x_1, y_1)$ 为 $\\hat{R}$ 的单位法向量上。曲线 $y=p_2(x)$ 在 $x_1$ 处的切向量与 $\\langle 1, p_2'(x_1) \\rangle$ 成比例。因此，法向量与 $\\langle -p_2'(x_1), 1 \\rangle$ 成比例。单位法向量 $\\vec{n}$ 为：\n$$\\vec{n} = \\frac{\\langle -p_2'(x_1), 1 \\rangle}{\\sqrt{(-p_2'(x_1))^2 + 1^2}} = \\frac{\\langle -p_2'(x_1), 1 \\rangle}{\\sqrt{1 + [p_2'(x_1)]^2}}$$\n该向量指向上方（$y$ 分量为正）。如果曲线是上凹的（$p_2''(x_1) > 0$），则曲率中心位于此方向；如果曲线是下凹的（$p_2''(x_1) < 0$），则位于相反方向。因此，我们可以将从 $(x_1, y_1)$ 到 $(\\hat{a}, \\hat{b})$ 的位移向量表示为 $\\hat{R} \\cdot \\text{sign}(p_2''(x_1)) \\cdot \\vec{n}$。\n\n圆心的位置向量是：\n$$\\langle \\hat{a}, \\hat{b} \\rangle = \\langle x_1, y_1 \\rangle + \\hat{R} \\cdot \\text{sign}(p_2''(x_1)) \\cdot \\vec{n}$$\n代入 $\\hat{R}$ 和 $\\vec{n}$ 的表达式：\n$$\\langle \\hat{a}, \\hat{b} \\rangle = \\langle x_1, y_1 \\rangle + \\frac{(1 + [p_2'(x_1)]^2)^{3/2}}{|p_2''(x_1)|} \\cdot \\text{sign}(p_2''(x_1)) \\cdot \\frac{\\langle -p_2'(x_1), 1 \\rangle}{\\sqrt{1 + [p_2'(x_1)]^2}}$$\n使用恒等式 $|z| \\cdot \\text{sign}(z) = z$，令 $z = p_2''(x_1)$，我们简化标量部分：\n$$\\frac{(1 + [p_2'(x_1)]^2)^{3/2}}{p_2''(x_1)} \\cdot \\frac{1}{\\sqrt{1 + [p_2'(x_1)]^2}} = \\frac{1 + [p_2'(x_1)]^2}{p_2''(x_1)}$$\n圆心的向量方程变为：\n$$\\langle \\hat{a}, \\hat{b} \\rangle = \\langle x_1, y_1 \\rangle + \\frac{1 + [p_2'(x_1)]^2}{p_2''(x_1)} \\langle -p_2'(x_1), 1 \\rangle$$\n由此，我们提取出估计圆心的坐标：\n$$\\hat{a} = x_1 - p_2'(x_1) \\frac{1 + [p_2'(x_1)]^2}{p_2''(x_1)}$$\n$$\\hat{b} = y_1 + \\frac{1 + [p_2'(x_1)]^2}{p_2''(x_1)}$$\n请注意，$\\hat{b}$ 公式中使用的 $y$ 坐标是观测（且可能含噪声）的值 $\\tilde{y}_1$，因为这是构建密切圆所依据的插值多项式上的点。\n\n将这些推导出的公式予以实现，以求解每个测试用例的估计参数及其误差。对噪声的敏感性在曲率小（半径大）的情况下尤其明显，此时 $p_2''(x_1)$ 接近于零，使得 $\\hat{a}$、$\\hat{b}$ 和 $\\hat{R}$ 的表达式在数值上不稳定。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the estimated circle parameters using a quadratic interpolant\n    and calculates the absolute errors for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1: noise-free, symmetric, moderate curvature\n        {'true_params': (0.75, -0.5, 1.9), 'a_offset': -0.5, 'c_offset': 0.5,\n         'noise_sigma': 0.0, 'seed': None},\n        # Case 2: noise-free, asymmetric, moderate curvature\n        {'true_params': (0.75, -0.5, 1.9), 'a_offset': -0.6, 'c_offset': 0.7,\n         'x1_offset': 0.1, 'noise_sigma': 0.0, 'seed': None},\n        # Case 3: noisy, symmetric, moderate curvature\n        {'true_params': (0.75, -0.5, 1.9), 'a_offset': -0.5, 'c_offset': 0.5,\n         'noise_sigma': 1e-5, 'seed': 12345},\n        # Case 4: noise-free, symmetric, large radius\n        {'true_params': (10.0, -20.0, 1000.0), 'a_offset': -0.1, 'c_offset': 0.1,\n         'noise_sigma': 0.0, 'seed': None},\n        # Case 5: noisy, symmetric, large radius\n        {'true_params': (10.0, -20.0, 1000.0), 'a_offset': -0.1, 'c_offset': 0.1,\n         'noise_sigma': 1e-8, 'seed': 24680},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        a_true, b_true, R_true = case['true_params']\n        sigma = case['noise_sigma']\n        seed = case['seed']\n        \n        # Define nodes\n        x0 = a_true + case['a_offset']\n        x1 = a_true + case.get('x1_offset', 0.0) # a_true if symmetric\n        x2 = a_true + case['c_offset']\n        \n        xs = np.array([x0, x1, x2])\n        \n        # Generate true y-values on the upper branch (s=+1)\n        ys_true = b_true + np.sqrt(R_true**2 - (xs - a_true)**2)\n        \n        # Add noise if specified\n        ys_observed = ys_true.copy()\n        if sigma > 0:\n            rng = np.random.default_rng(seed)\n            noise = rng.normal(0, sigma, 3)\n            ys_observed += noise\n        \n        y0_obs, y1_obs, y2_obs = ys_observed\n        \n        # Calculate divided differences\n        # c0 = f[x0]\n        # c1 = f[x0, x1]\n        # c2 = f[x0, x1, x2]\n        c0 = y0_obs\n        \n        # First order differences\n        f_x0_x1 = (y1_obs - y0_obs) / (x1 - x0)\n        f_x1_x2 = (y2_obs - y1_obs) / (x2 - x1)\n        \n        c1 = f_x0_x1\n        \n        # Second order difference\n        c2 = (f_x1_x2 - f_x0_x1) / (x2 - x0)\n        \n        # Calculate derivatives of the interpolant p2(x) at x1\n        p2_prime_x1 = c1 + c2 * (x1 - x0)\n        p2_double_prime_x1 = 2 * c2\n        \n        # Check for near-zero second derivative (collinear points)\n        if abs(p2_double_prime_x1) < 1e-15:\n            # For collinear points, radius is infinite, center is at infinity.\n            # This problem's setup avoids this, but it's good practice.\n            # Report large error.\n            errors = [np.inf, np.inf, np.inf]\n            results.append(errors)\n            continue\n            \n        # Estimate parameters of the osculating circle\n        y_prime_sq = p2_prime_x1**2\n        common_term = (1 + y_prime_sq) / p2_double_prime_x1\n        \n        a_hat = x1 - p2_prime_x1 * common_term\n        b_hat = y1_obs + common_term\n        R_hat = np.abs((1 + y_prime_sq)**(3/2) / p2_double_prime_x1)\n\n        # Calculate absolute errors\n        error_a = abs(a_hat - a_true)\n        error_b = abs(b_hat - b_true)\n        error_R = abs(R_hat - R_true)\n        \n        results.append([error_a, error_b, error_R])\n\n    # Format the final output string as per requirements\n    formatted_results = []\n    for res_triple in results:\n        formatted_triple = f\"[{res_triple[0]:.12f},{res_triple[1]:.12f},{res_triple[2]:.12f}]\"\n        formatted_results.append(formatted_triple)\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2428257"}]}