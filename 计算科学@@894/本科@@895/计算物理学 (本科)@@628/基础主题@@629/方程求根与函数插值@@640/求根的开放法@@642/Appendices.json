{"hands_on_practices": [{"introduction": "掌握了开放方法的理论基础后，首要的实践是亲手实现这些算法。本练习将指导你实现牛顿法和割线法，并将其应用于一个经典的数值分析问题——求解切比雪夫多项式 $T_n(x)$ 的根 [@problem_id:2422749]。通过将数值计算结果与已知的解析解进行比较，你不仅能验证算法的正确性，还能直观地感受这些迭代方法的收敛能力和精度。", "problem": "您被要求设计并实现一个完整、可运行的程序，该程序能够数值计算第一类 Chebyshev 多项式的根，并量化其与已知解析结果的吻合程度。您的实现必须使用开放法进行求根（例如，Newton 法和割线法），并且不得依赖于区间法。所有使用的角度都必须以弧度表示。\n\n起点与基本依据：请使用以下基本事实和定义，不得在解题陈述中提供任何捷径公式。第一类 Chebyshev 多项式，记为 $T_n(x)$，是在区间 $[-1,1]$ 上关于权重 $(1-x^2)^{-1/2}$ 的一个正交多项式序列。它们满足三项递推关系\n$$\nT_0(x)=1,\\quad T_1(x)=x,\\quad T_{k+1}(x)=2x\\,T_k(x)-T_{k-1}(x),\n$$\n并且，余弦的倍角恒等式意味着存在以下表示形式\n$$\nT_n(\\cos\\theta)=\\cos(n\\theta),\n$$\n对任意实数 $\\theta$ 成立。其导数通过以下关系与第二类 Chebyshev 多项式 $U_n(x)$ 相关联：\n$$\n\\frac{d}{dx}T_n(x)=n\\,U_{n-1}(x),\n$$\n其中 $U_n(x)$ 满足递推关系\n$$\nU_0(x)=1,\\quad U_1(x)=2x,\\quad U_{k+1}(x)=2x\\,U_k(x)-U_{k-1}(x).\n$$\n基于这些依据以及 $T_n(\\cos\\theta)=\\cos(n\\theta)$ 这一事实，$T_n(x)$ 在 $(-1,1)$ 内的解析根具有已知的闭合形式；您必须使用这个经过充分检验的事实来构建用于比较的参考值，并确保所有角度都以弧度表示。\n\n需要实现的开放法：为标量函数 $f(x)$ 实现至少两种求根的开放法：由迭代式\n$$\nx_{m+1}=x_m-\\frac{f(x_m)}{f'(x_m)},\n$$\n给出的 Newton 法，以及由迭代式\n$$\nx_{m+1}=x_m - f(x_m)\\,\\frac{x_m-x_{m-1}}{f(x_m)-f(x_{m-1})}.\n$$\n给出的割线法。在您的解答中，这些公式必须从第一性原理推导得出，而不能仅仅作为现成公式直接陈述。\n\n数值任务：对于每个指定的测试用例，执行以下操作。\n- 对于给定的阶数 $n$，使用 $T_n(x)$ 的稳定三项递推关系定义函数 $f(x)=T_n(x)$。\n- 对于 Newton 法，使用 $U_{n-1}(x)$ 的稳定三项递推关系定义 $f'(x)=n\\,U_{n-1}(x)$。\n- 为 $(-1,1)$ 内的 $n$ 个不同根生成初始猜测值。您可以使用这 $n$ 个根的已知精确表达式作为初始种子，也可以加上微小扰动。对于割线法，每个根需要提供两个初始值。\n- 应用所选的开放法来收敛到每个根。使用基于 $|f(x)|\\le \\varepsilon$ 或 $|x_{m+1}-x_m|\\le \\varepsilon$ 的停止准则，其中 $\\varepsilon$ 是一个预设的容差。\n- 使用已知的精确表达式（角度单位为弧度）计算解析根以进行比较，并将数值根和解析根都按升序排序。\n- 对于每个测试用例，报告一个实数，该实数等于所有 $n$ 个根中，对应的数值根和解析根之间的最大绝对差。\n\n测试套件：您的程序必须无需任何外部输入即可运行以下四个测试用例，并以双精度生成结果。\n- 用例 A（理想路径，最小非平凡阶数）：$n=1$，方法 = Newton，容差 $\\varepsilon=10^{-13}$。\n- 用例 B（中等阶数）：$n=5$，方法 = Newton，容差 $\\varepsilon=10^{-13}$。\n- 用例 C（较高阶数，根在端点附近聚集）：$n=32$，方法 = Newton，容差 $\\varepsilon=10^{-13}$。\n- 用例 D（使用不同开放法的较高阶数）：$n=50$，方法 = 割线法，容差 $\\varepsilon=10^{-13}$。\n\n角度单位要求：当您根据闭合形式表达式计算解析根时，请将所有角度视为弧度。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[r_A,r_B,r_C,r_D]\"）。每个条目必须是一个浮点数，等于按 A、B、C、D 顺序排列的相应测试用例的最大绝对差。\n\n所有计算都必须在无量纲单位下进行。不允许用户交互；程序必须是完全自包含和确定性的。", "solution": "所述问题已经过验证，被认定为科学上合理、适定且客观。该问题不含逻辑矛盾，为获得唯一解提供了所有必要数据，并且完全属于计算物理和数值分析的范畴。因此，我将着手提供一个完整的解答。任务是使用指定的开放法计算第一类 Chebyshev 多项式的根，并对照已知的解析解来量化这些数值结果的准确性。\n\n首先，必须从基本原理出发，推导求根开放法所需的迭代公式。\n\nNewton 法的推导\n\n设 $x^{*}$ 是一个可微函数 $f(x)$ 的根，使得 $f(x^{*}) = 0$。设 $x_m$ 是根 $x^{*}$ 的一个当前近似值。我们寻求一个更好的近似值 $x_{m+1}$。我们可以用 $f(x)$ 在点 $x_m$ 附近的一阶泰勒级数展开来表示它：\n$$\nf(x) \\approx f(x_m) + f'(x_m)(x - x_m)\n$$\n我们寻找使 $f(x)=0$ 的 $x$ 值。令这个值为我们的下一个近似值 $x_{m+1}$。将 $x = x_{m+1}$ 代入泰勒展开式并令其为零，我们得到：\n$$\n0 \\approx f(x_m) + f'(x_m)(x_{m+1} - x_m)\n$$\n假设导数 $f'(x_m)$ 非零，可以解出 $x_{m+1}$：\n$$\nf'(x_m)(x_{m+1} - x_m) = -f(x_m)\n$$\n$$\nx_{m+1} = x_m - \\frac{f(x_m)}{f'(x_m)}\n$$\n这就是众所周知的 Newton 法迭代公式。只要初始猜测值 $x_0$ 足够接近根且根为单根，其收敛速度通常是二次的。\n\n割线法的推导\n\nNewton 法的一个实际限制是需要导数 $f'(x)$ 的解析表达式。当导数不可用或计算成本高昂时，可以用近似值代替。割线法用基于最近两次迭代值 $x_m$ 和 $x_{m-1}$ 的有限差分来近似导数。导数 $f'(x_m)$ 由连接点 $(x_{m-1}, f(x_{m-1}))$ 和 $(x_m, f(x_m))$ 的割线斜率来近似：\n$$\nf'(x_m) \\approx \\frac{f(x_m) - f(x_{m-1})}{x_m - x_{m-1}}\n$$\n将这个近似值代入 Newton 法的公式，就得到了割线法的迭代式：\n$$\nx_{m+1} = x_m - \\frac{f(x_m)}{\\left(\\frac{f(x_m) - f(x_{m-1})}{x_m - x_{m-1}}\\right)} = x_m - f(x_m)\\frac{x_m - x_{m-1}}{f(x_m) - f(x_{m-1})}\n$$\n该方法需要两个初始猜测值 $x_0$ 和 $x_1$，并表现出超线性收敛性，其收敛速度慢于 Newton 法但快于线性收敛。\n\n在 Chebyshev 多项式上的应用\n\n我们要求根的函数是第一类 Chebyshev 多项式 $T_n(x)$。\n\n$T_n(x)$ 的解析根\n问题给出了恒等式 $T_n(\\cos\\theta) = \\cos(n\\theta)$。我们寻找在区间 $(-1, 1)$ 内使 $T_n(x) = 0$ 的根 $x$。通过令 $x = \\cos\\theta$（其中 $\\theta \\in (0, \\pi)$），我们将问题转化为求解满足以下条件的 $\\theta$：\n$$\n\\cos(n\\theta) = 0\n$$\n这个三角方程的通解是 $n\\theta = (k + \\frac{1}{2})\\pi$，其中 $k$ 是一个整数。按照规定，所有角度都必须是弧度。这给出：\n$$\n\\theta_k = \\frac{(k + \\frac{1}{2})\\pi}{n} = \\frac{(2k+1)\\pi}{2n}\n$$\n为了在区间 $x \\in (-1, 1)$ 内获得 $n$ 个不同的根，我们需要在区间 $(0, \\pi)$ 内找到 $n$ 个不同的角度 $\\theta_k$。选择 $k = 0, 1, \\dots, n-1$ 会在此范围内产生 $n$ 个唯一的角度。对应的根 $x_k$ 是：\n$$\nx_k = \\cos\\left(\\frac{(2k+1)\\pi}{2n}\\right), \\quad k = 0, 1, \\dots, n-1\n$$\n这些就是 $T_n(x)$ 的 $n$ 个解析根，它们将作为我们进行准确性评估的参考值。\n\n$T_n(x)$ 及其导数的数值计算\n为了实现求根方法，我们需要计算 $T_n(x)$ 的值，对于 Newton 法，还需要计算其导数。\n函数 $f(x) = T_n(x)$ 使用所提供的三项递推关系进行求值：\n$$\nT_0(x)=1, \\quad T_1(x)=x, \\quad T_{k+1}(x)=2x\\,T_k(x)-T_{k-1}(x)\n$$\n对于 $x \\in [-1, 1]$，该递推关系是数值稳定的。\n对于 Newton 法，导数 $f'(x)$ 由 $\\frac{d}{dx}T_n(x) = n\\,U_{n-1}(x)$ 给出，其中 $U_{n-1}(x)$ 是 $n-1$ 阶的第二类 Chebyshev 多项式。它使用其自身的三项递推关系进行计算：\n$$\nU_0(x)=1, \\quad U_1(x)=2x, \\quad U_{k+1}(x)=2x\\,U_k(x)-U_{k-1}(x)\n$$\n为了效率，这两个多项式都将通过迭代算法而非递归来实现。\n\n计算步骤\n对于每个由阶数 $n$、方法和容差 $\\varepsilon$ 指定的测试用例，执行以下步骤：\n$1$. 使用上面推导的公式计算 $n$ 个解析根 $x_k^{\\text{exact}}$。将它们按升序排序作为参考。\n$2$. 对 $n$ 个根中的每一个，启动一次数值搜索。\n    - 从相应的解析根生成初始猜测值。这确保了每次搜索都收敛到一个唯一的、预先识别的根，从而可以直接比较准确性。\n    - 对于 Newton 法，初始猜测值设为 $x_0 = x_k^{\\text{exact}}$。\n    - 对于割线法，需要两个初始猜测值。我们使用 $x_1 = x_k^{\\text{exact}}$ 和一个略微扰动的点 $x_0 = x_1 - \\delta$，其中 $\\delta$ 是一个小常数（例如 $\\delta = 10^{-8}$）。\n$3$. 应用所选的迭代方法（Newton 或割线法），直到满足停止准则。准则为 $|f(x_m)| \\le \\varepsilon$，或者作为保障措施，$|x_{m+1} - x_m| \\le \\varepsilon$。同时也会设置最大迭代次数，以防止在不收敛的情况下出现无限循环。\n$4$. 收集数值计算出的根，并按升序排序。\n$5$. 计算排序后的数值根与排序后的解析根之间的最大绝对差：$\\max_{k} |x_k^{\\text{numerical}} - x_k^{\\text{exact}}|$。这个单一的值量化了该方法在给定测试用例下的准确性。\n\n对所有四个测试用例重复此过程：\n- 用例 A：$n=1$，Newton 法，$\\varepsilon=10^{-13}$。\n- 用例 B：$n=5$，Newton 法，$\\varepsilon=10^{-13}$。\n- 用例 C：$n=32$，Newton 法，$\\varepsilon=10^{-13}$。\n- 用例 D：$n=50$，割线法，$\\varepsilon=10^{-13}$。\n\n最终输出将是一个列表，包含四个最大绝对差值，每个用例一个。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# No scipy is needed as the methods are implemented from first principles.\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the entire process.\n    It runs the specified test cases and prints the final result.\n    \"\"\"\n\n    def T(n, x):\n        \"\"\"\n        Computes the Chebyshev polynomial of the first kind, T_n(x),\n        using the three-term recurrence relation.\n        \"\"\"\n        if n == 0:\n            return 1.0\n        if n == 1:\n            return x\n        \n        T_k_minus_1 = 1.0  # T_0\n        T_k = x            # T_1\n        for _ in range(2, n + 1):\n            T_k_plus_1 = 2.0 * x * T_k - T_k_minus_1\n            T_k_minus_1 = T_k\n            T_k = T_k_plus_1\n        return T_k\n\n    def U(n, x):\n        \"\"\"\n        Computes the Chebyshev polynomial of the second kind, U_n(x),\n        using the three-term recurrence relation.\n        \"\"\"\n        if n == 0:\n            return 1.0\n        if n == 1:\n            return 2.0 * x\n            \n        U_k_minus_1 = 1.0  # U_0\n        U_k = 2.0 * x      # U_1\n        for _ in range(2, n + 1):\n            U_k_plus_1 = 2.0 * x * U_k - U_k_minus_1\n            U_k_minus_1 = U_k\n            U_k = U_k_plus_1\n        return U_k\n\n    def newton_method(f, df, x0, tol, max_iter=50):\n        \"\"\"\n        Finds a root of f(x) using Newton's method.\n        f: function\n        df: derivative of the function\n        x0: initial guess\n        tol: tolerance for stopping\n        max_iter: maximum number of iterations\n        \"\"\"\n        x = x0\n        for _ in range(max_iter):\n            fx = f(x)\n            if abs(fx) <= tol:\n                return x\n            \n            dfx = df(x)\n            if dfx == 0:\n                # Derivative is zero, method fails. Unlikely for this problem.\n                break\n                \n            x_next = x - fx / dfx\n            if abs(x_next - x) <= tol:\n                return x_next\n            x = x_next\n        return x\n\n    def secant_method(f, x0, x1, tol, max_iter=50):\n        \"\"\"\n        Finds a root of f(x) using the secant method.\n        f: function\n        x0, x1: two initial guesses\n        tol: tolerance for stopping\n        max_iter: maximum number of iterations\n        \"\"\"\n        fx0 = f(x0)\n        fx1 = f(x1)\n        for _ in range(max_iter):\n            if abs(fx1) <= tol:\n                return x1\n            \n            # Avoid division by zero\n            if (fx1 - fx0) == 0:\n                break\n            \n            x_next = x1 - fx1 * (x1 - x0) / (fx1 - fx0)\n            \n            if abs(x_next - x1) <= tol:\n                return x_next\n            \n            x0, x1 = x1, x_next\n            fx0, fx1 = fx1, f(x1)\n        return x1\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'n': 1, 'method': 'newton', 'tol': 1e-13},  # Case A\n        {'n': 5, 'method': 'newton', 'tol': 1e-13},  # Case B\n        {'n': 32, 'method': 'newton', 'tol': 1e-13}, # Case C\n        {'n': 50, 'method': 'secant', 'tol': 1e-13}, # Case D\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        n = case['n']\n        method = case['method']\n        tol = case['tol']\n\n        # 1. Compute analytical roots for reference and seeding\n        # Formula: x_k = cos((2k+1)pi / (2n)) for k=0, ..., n-1\n        k = np.arange(n)\n        analytical_roots = np.cos((2 * k + 1) * np.pi / (2 * n))\n        analytical_roots.sort() # Ensure ascending order\n\n        numerical_roots = []\n\n        # 2. Find roots numerically\n        for i in range(n):\n            initial_seed = analytical_roots[i]\n            \n            if method == 'newton':\n                # Define function f(x) = T_n(x) and its derivative f'(x) = n*U_{n-1}(x)\n                f = lambda x: T(n, x)\n                df = lambda x: n * U(n - 1, x) if n > 0 else 0.0\n                root = newton_method(f, df, initial_seed, tol)\n                numerical_roots.append(root)\n            \n            elif method == 'secant':\n                f = lambda x: T(n, x)\n                # Two initial guesses: the analytical root and a slightly perturbed version\n                x1 = initial_seed\n                x0 = initial_seed - 1e-8 # Small perturbation\n                root = secant_method(f, x0, x1, tol)\n                numerical_roots.append(root)\n        \n        numerical_roots = np.array(numerical_roots)\n        numerical_roots.sort()\n\n        # 3. Compute the maximum absolute difference\n        max_abs_diff = np.max(np.abs(numerical_roots - analytical_roots))\n        results.append(max_abs_diff)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "2422749"}, {"introduction": "在许多科学和工程应用中，函数并非以显式公式给出，而是通过一组离散的数据点来定义。本练习将引导你解决一个更贴近实际的问题：寻找一个由数据点定义的保形分段三次插值函数的根 [@problem_id:2424134]。这个过程结合了函数逼近和求根技术，让你体验如何在没有解析表达式的情况下，从实验数据中提取关键信息。", "problem": "给定您的数据集包含严格递增的横坐标 $x_0 < x_1 < \\dots < x_{n-1}$ 和对应的纵坐标 $y_0, y_1, \\dots, y_{n-1}$。标量函数 $f(x)$ 并非直接可用；它被定义为使用分段三次Hermite插值从数据集构建的唯一保形分段三次插值函数。您的任务是编写一个程序，为测试套件中的每个数据集，找出 $f(x)=0$ 在闭区间 $\\left[x_0, x_{n-1}\\right]$ 内的所有实根。\n\n基本原理和建模假设：\n- 插值函数在每个子区间 $\\left[x_k,x_{k+1}\\right]$ 上由一个三次Hermite多项式定义，该多项式满足子区间端点处的函数值和斜率匹配。令 $h_k = x_{k+1}-x_k$ 且 $t=(x-x_k)/h_k\\in[0,1]$。在 $\\left[x_k,x_{k+1}\\right]$ 上，插值函数 $p_k(x)$ 定义为\n$$\np_k(x) = y_k h_{00}(t) + h_k m_k h_{10}(t) + y_{k+1} h_{01}(t) + h_k m_{k+1} h_{11}(t),\n$$\n其中三次Hermite基多项式为\n$$\nh_{00}(t) = 2t^3 - 3t^2 + 1,\\quad\nh_{10}(t) = t^3 - 2t^2 + t,\\quad\nh_{01}(t) = -2t^3 + 3t^2,\\quad\nh_{11}(t) = t^3 - t^2.\n$$\n- 斜率 $m_k$ 通过一个保持单调性的规则（Fritsch–Carlson方法）来选择，该规则应用于割线斜率 $\\delta_k = \\dfrac{y_{k+1}-y_k}{x_{k+1}-x_k}$，确保如果 $y_k$ 在 $x$上是单调的，那么插值函数不会引入虚假的振荡或过冲。具体来说，如果 $\\delta_{k-1}$ 和 $\\delta_k$ 符号相反或其中任一为零，则 $m_k=0$；否则，$m_k$ 是 $\\delta_{k-1}$ 和 $\\delta_k$ 的一个加权调和平均值，用以保持局部形状。端点斜率 $m_0$ 和 $m_{n-1}$ 的选择方式与此一致，以避免过冲。\n- 根是满足 $f(x^\\star)=0$ 的任意 $x^\\star \\in [x_0, x_{n-1}]$。根可能出现在子区间内部（作为三次方程 $p_k(x)=0$ 的解），或者恰好在满足 $y_k=0$ 的节点 $x_k$ 处。\n\n算法要求：\n- 对于每个数据集，按所述方法构造分段三次Hermite插值函数 $f(x)$。然后，对每个子区间，求解三次方程 $p_k(x)=0$ 以得到在 $[x_k, x_{k+1}]$ 内的实根。同时，将任何满足 $y_k=0$ 的节点 $x_k$ 也作为根。由于数值舍入误差，丢弃任何在 $\\left[x_0,x_{n-1}\\right]$ 之外的根。移除相互之间距离小于一个很小容差的重复根。\n- 将根按升序排序。将每个根四舍五入到小数点后 $6$ 位。\n\n角度单位：当数据集中出现三角函数时，角度应解释为弧度。\n\n输出格式：\n- 您的程序应生成单行输出，其中包含所有结果，形式为列表的列表，每个数据集一个列表，每个内部列表包含按升序排列的四舍五入后的根。使用逗号分隔的表示法，并用方括号括起来，不含任何空白字符。例如：\"[[r11,r12],[r21],[...]]\"。对根使用标准十进制浮点表示法，小数点后精确到 $6$ 位。空列表应表示为 \"[]\"。\n\n测试套件：\n为进行稳健的评估，请在以下四个数据集上运行您的程序。对于每个数据集，$x$ 都是严格递增的。\n\n- 测试用例 $1$（一个内部根，不在节点上）：\n  - $x = [0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5]$\n  - $y = [\\sin(0.5), \\sin(1.0), \\sin(1.5), \\sin(2.0), \\sin(2.5), \\sin(3.0), \\sin(3.5)]$，其中角度单位为弧度。\n\n- 测试用例 $2$（定义域内无根）：\n  - $x = [-2.0, -1.0, 0.0, 1.0, 2.0]$\n  - $y = [(-2.0)^2 + 1.0, (-1.0)^2 + 1.0, 0.0^2 + 1.0, 1.0^2 + 1.0, 2.0^2 + 1.0]$。\n\n- 测试用例 $3$（多个根恰好在节点上）：\n  - $x = [0, $\\tfrac{\\pi}{4}$, $\\tfrac{\\pi}{2}$, $\\tfrac{3\\pi}{4}$, $\\pi$, $\\tfrac{5\\pi}{4}$, $\\tfrac{3\\pi}{2}$, $\\tfrac{7\\pi}{4}$, $2\\pi$]$\n  - $y = [\\sin(0), \\sin($\\tfrac{\\pi}{4}$), \\sin($\\tfrac{\\pi}{2}$), \\sin($\\tfrac{3\\pi}{4}$), \\sin($\\pi$), \\sin($\\tfrac{5\\pi}{4}$), \\sin($\\tfrac{3\\pi}{2}$), \\sin($\\tfrac{7\\pi}{4}$), \\sin($2\\pi$)]$，其中角度单位为弧度。\n\n- 测试用例 $4$（根在右边界上）：\n  - $x = [0.0, 0.5, 1.0, 1.5, 2.0]$\n  - $y = [0.0-2.0, 0.5-2.0, 1.0-2.0, 1.5-2.0, 2.0-2.0]$。\n\n数值和验证细节：\n- 使用一个小的绝对容差（例如，$10^{-12}$）来判断一个值是否为零（在检测节点处的根和去重相邻子区间的根时使用）。\n- 必须仅报告闭合定义域内的实根。\n- 将每个根四舍五入到小数点后恰好 $6$ 位，并确保在四舍五入后，内部列表中的元素严格按升序排列。\n\n您的程序必须实现上述要求，并生成一行包含四个测试用例汇总结果的输出，其格式为指定格式，输出行中不含任何多余的打印或空白。", "solution": "所陈述的问题是有效的。它提出了一个计算工程领域内明确定义的任务，具体涉及数值分析和逼近理论领域。该问题在分段多项式插值理论中有科学依据，是客观的，并提供了构建唯一、可验证解所需的所有信息。它没有矛盾、歧义，也不依赖于非科学的前提。\n\n目标是找到一个在闭区间 $[x_0, x_{n-1}]$ 上定义的函数 $f(x)$ 的所有实根，其中 $f(x)$ 是根据给定数据点集 $(x_k, y_k)$（对于 $k=0, 1, \\dots, n-1$）构建的保形分段三次Hermite插值函数。\n\n分段三次Hermite插值是一种样条，通过连接多个三次多项式来构造，每个子区间 $[x_k, x_{k+1}]$ 对应一个多项式。为了使插值函数平滑，在节点 $x_k$ 处，函数值和一阶导数值必须一致。设 $p_k(x)$ 是在区间 $[x_k, x_{k+1}]$ 上的三次多项式。它由四条信息定义：函数值 $y_k = f(x_k)$ 和 $y_{k+1} = f(x_{k+1})$，以及导数值 $m_k = f'(x_k)$ 和 $m_{k+1} = f'(x_{k+1})$。\n\n在 $[x_k, x_{k+1}]$ 上的插值函数 $p_k(x)$ 可以使用Hermite基多项式来表示。设 $h_k = x_{k+1} - x_k$ 并定义一个归一化变量 $t = (x - x_k) / h_k$，这样当 $x$ 从 $x_k$ 变化到 $x_{k+1}$ 时，$t \\in [0, 1]$。插值函数由下式给出：\n$$\np_k(x(t)) = y_k h_{00}(t) + y_{k+1} h_{01}(t) + h_k m_k h_{10}(t) + h_k m_{k+1} h_{11}(t)\n$$\n其中Hermite基函数为：\n$$\n\\begin{aligned}\nh_{00}(t) &= 2t^3 - 3t^2 + 1 \\\\\nh_{01}(t) &= -2t^3 + 3t^2 \\\\\nh_{10}(t) &= t^3 - 2t^2 + t \\\\\nh_{11}(t) &= t^3 - t^2\n\\end{aligned}\n$$\n这些基函数具有 $h_{00}(0)=1$, $h_{01}(1)=1$, $h'_{10}(0)=1$, $h'_{11}(1)=1$ 的性质，而在 $0$ 和 $1$ 处的其他值和导数为零，这确保了插值条件得到满足。\n\n关键部分是导数值 $m_k$ 的选择。标准的立方样条强制二阶导数的连续性，但这可能会引入原始数据中不存在的虚假振荡。问题指定了一种“保形”或“保持单调性”的方法，特别是 Fritsch–Carlson 方法。该方法根据数据的局部几何形状来确定斜率 $m_k$，这由割线斜率 $\\delta_k = (y_{k+1} - y_k) / (x_{k+1} - x_k)$ 定义。\n对于内部节点 $x_k$（$k=1, \\dots, n-2$），其原理如下：\n1. 如果相邻的割线斜率符号不同，即 $\\delta_{k-1} \\delta_k \\le 0$，则数据在 $x_k$ 周围不是单调的。为防止过冲，此非单调点处的导数设为零：$m_k = 0$。\n2. 如果割线斜率符号相同，即 $\\delta_{k-1} \\delta_k > 0$，则数据是局部单调的。选择导数 $m_k$ 以保持这种单调性。一个常见的选择是（如标准库中的实现）使用 $\\delta_{k-1}$ 和 $\\delta_k$ 的加权调和平均值，以确保 $|m_k|$ 被适当地限制。\n端点斜率 $m_0$ 和 $m_{n-1}$ 使用与这些原则一致的单边方案来确定，以避免在边界附近出现过冲。\n\n一旦所有 $k$ 的斜率 $m_k$ 都被确定，分段多项式 $f(x)$ 就被完全定义了。任务简化为在 $[x_0, x_{n-1}]$ 上寻找 $f(x)=0$ 的根。这涉及两种不同情况：\n1. 节点处的根：如果对应的纵坐标 $y_k = 0$，则在节点 $x_k$ 处存在一个根。\n2. 子区间内的根：如果在开区间 $(x_k, x_{k+1})$ 中三次多项式 $p_k(x)$ 有一个零点，则该区间内存在一个根。\n\n要找到区间内的根，我们必须解 $p_k(x) = 0$。通过代入Hermite基函数并按 $t$ 的幂次收集项，方程变成一个标准的三次方程 $at^3 + bt^2 + ct + d = 0$，其中系数为：\n$$\n\\begin{aligned}\na &= 2(y_k - y_{k+1}) + h_k(m_k + m_{k+1}) \\\\\nb &= 3(y_{k+1} - y_k) - h_k(2m_k + m_{k+1}) \\\\\nc &= h_k m_k \\\\\nd &= y_k\n\\end{aligned}\n$$\n这个三次方程可以求解其实根 $t^\\star$。任何位于 $[0, 1]$ 区间内的根 $t^\\star$ 都对应于插值函数的一个有效根 $x^\\star = x_k + t^\\star h_k$。\n\n计算策略如下：\n1. 对于每个数据集，使用 `scipy.interpolate.PchipInterpolator` 类。这提供了 Fritsch-Carlson 方法的一个稳健且数值稳定的实现，用于构建保形分段三次插值。\n2. 寻根过程分为两部分以确保完整性：\n    a. 通过检查输入纵坐标值 $y_k$ 是否在小容差 $\\epsilon = 10^{-12}$ 内接近零来识别节点处的根。\n    b. 使用插值器对象的 `.roots()` 方法找到开区间 $(x_k, x_{k+1})$ 内的根。该方法高效且准确地找到分段多项式在其定义域内的所有实根，但它不会报告全局边界 $x_0$ 和 $x_{n-1}$ 处的根。\n3. 将来自这两个来源的根收集到一个集合中。\n4. 将此集合按升序排序。如果一个节点处的根被两种方法同时找到，就可能出现重复根，通过遍历排序后的列表并仅保留相差超过容差 $\\epsilon$ 的根来移除重复项。\n5. 最后，将唯一的、已排序的根四舍五入到小数点后 $6$ 位，并按要求格式化。此方法保证了在闭区间 $[x_0, x_{n-1}]$ 内的所有实根都能被找到并正确报告。", "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import PchipInterpolator\n\ndef solve():\n    \"\"\"\n    Solves for the real roots of shape-preserving piecewise cubic Hermite interpolants\n    for a suite of test cases.\n    \"\"\"\n    # Tolerance for floating-point comparisons (zero-checking and de-duplication).\n    TOL = 1e-12\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1: one interior root, not at a knot\n        {\n            \"x\": np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5]),\n            \"y\": np.sin(np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5]))\n        },\n        # Test case 2: no roots in the domain\n        {\n            \"x\": np.array([-2.0, -1.0, 0.0, 1.0, 2.0]),\n            \"y\": np.array([-2.0, -1.0, 0.0, 1.0, 2.0])**2 + 1.0\n        },\n        # Test case 3: multiple roots exactly at knots\n        {\n            \"x\": np.array([0, np.pi/4, np.pi/2, 3*np.pi/4, np.pi, 5*np.pi/4, 3*np.pi/2, 7*np.pi/4, 2*np.pi]),\n            \"y\": np.sin(np.array([0, np.pi/4, np.pi/2, 3*np.pi/4, np.pi, 5*np.pi/4, 3*np.pi/2, 7*np.pi/4, 2*np.pi]))\n        },\n        # Test case 4: root at the right boundary\n        {\n            \"x\": np.array([0.0, 0.5, 1.0, 1.5, 2.0]),\n            \"y\": np.array([0.0, 0.5, 1.0, 1.5, 2.0]) - 2.0\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        x_data, y_data = case[\"x\"], case[\"y\"]\n\n        # 1. Construct the shape-preserving piecewise cubic Hermite interpolant.\n        #    PchipInterpolator implements the Fritsch–Carlson method.\n        interpolator = PchipInterpolator(x_data, y_data)\n\n        # 2. Find roots. This requires a two-pronged approach.\n        \n        # 2a. Find roots within open subintervals using the PPoly.roots() method.\n        # This method correctly finds roots within (x_k, x_{k+1}) for all k,\n        # but does not report roots at the global boundaries x_0 and x_{n-1}.\n        interior_roots = interpolator.roots(extrapolate=False)\n\n        # 2b. Find roots that occur exactly at the knots.\n        knot_roots = x_data[np.abs(y_data) < TOL]\n        \n        # 3. Combine, sort, and de-duplicate the roots.\n        if interior_roots.size == 0 and knot_roots.size == 0:\n            unique_sorted_roots = []\n        else:\n            all_found_roots = np.concatenate((interior_roots, knot_roots))\n            # Sort all roots to prepare for de-duplication.\n            all_found_roots.sort()\n\n            # De-duplicate roots that are closer than the tolerance.\n            if len(all_found_roots) > 0:\n                unique_sorted_roots = [all_found_roots[0]]\n                for root in all_found_roots[1:]:\n                    if root - unique_sorted_roots[-1] > TOL:\n                        unique_sorted_roots.append(root)\n            else:\n                unique_sorted_roots = []\n\n        # 4. Format the output: round to 6 decimal places.\n        # The f-string format ensures exactly 6 digits are printed, even for whole numbers.\n        formatted_roots = [f\"{root:.6f}\" for root in unique_sorted_roots]\n        all_results.append(f\"[{','.join(formatted_roots)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2424134"}, {"introduction": "虽然开放方法收敛速度快，但它们可能不稳定；而区间法虽然可靠，但速度较慢。为了兼顾两者的优点，现代数值库广泛采用混合策略。本练习将挑战你设计并实现一个三阶段混合求根算法，它能根据与根的距离智能地在区间二分法、割线法和牛顿法之间切换 [@problem_id:2402195]。这不仅是一项编码任务，更是对算法设计中在速度与稳健性之间权衡取舍思想的深刻实践。", "problem": "设计并实现一个三元混合求根算法，该算法结合了区间对分、基于斜率的外推和线性化局部校正，以求解标量非线性方程。目标是在给定的括号区间 $[a,b]$（其中 $f(a)\\,f(b)\\le 0$）内，计算连续函数 $f(x)$ 的一个实根的近似值，并通过一个有原则的切换方案在三个阶段之间切换：当远离根时，采用保守的区间对分阶段；当相当接近时，采用基于斜率的方法阶段；最后是基于线性化局部模型的精化阶段。所有涉及三角函数的函数参数必须以弧度表示。\n\n从以下基本基础出发，推导并论证一个鲁棒的切换策略，指明为保持安全性所需的接受和回退条件，并实现一个完整的程序，在提供的测试集上执行此策略。\n\n基本基础：\n- 根的定义：一个点 $x^\\ast$，使得 $f(x^\\ast)=0$。\n- 连续性与介值定理 (IVT)：如果函数 $f$ 在 $[a,b]$ 上连续，且 $f(a)\\,f(b)\\le 0$，则在 $[a,b]$ 内至少存在一个根。\n- 可微函数的一阶 Taylor 展开：对于在 $x_k$ 点可微的函数 $f$，当 $x$ 接近 $x_k$ 时，有 $f(x)\\approx f(x_k)+f'(x_k)\\,(x-x_k)$。\n- 区间上导数的有限差分近似：对于不同的 $x_1$ 和 $x_2$，有 $f'(x)\\approx \\dfrac{f(x_2)-f(x_1)}{x_2-x_1}$。\n\n三元混合切换方案的要求：\n- 区间不变性：始终保持区间 $[a,b]$ 满足 $f(a)\\,f(b)\\le 0$。\n- 第一阶段（区间对分）：当当前区间长度 $L=b-a$ 相对于初始长度 $L_0=b_0-a_0$ 较大时，选择中点候选值 $m=(a+b)/2$。此阶段应在 $L>\\tau_{\\text{far}}\\,L_0$ 时使用。\n- 第二阶段（基于斜率的方法）：当区间中等大小但非极小时，使用根据当前括号区间数据构建的线性模型来提出一个严格位于 $[a,b]$ 内部的候选点。此阶段应在 $\\tau_{\\text{near}}\\,L_0 < L \\le \\tau_{\\text{far}}\\,L_0$ 时使用。\n- 第三阶段（局部精化）：当区间非常小时，使用围绕当前内部点的一阶局部线性化来提出一个精化步。仅当该步骤的结果仍在 $[a,b]$ 内部且局部斜率的绝对值不太小时才接受该步骤；否则，回退到更安全的第二阶段或第一阶段步骤。\n- 接受与回退策略：任何在 $[a,b]$ 之外的候选值都必须被拒绝；如果局部斜率的绝对值低于指定阈值，则避免局部线性化步骤；如果线性模型步骤不可接受，则恢复为区间对分。\n- 区间更新：计算出候选值 $x_c$ 后，评估 $f(x_c)$ 的值。如果 $f(a)\\,f(x_c)\\le 0$，则设 $b\\leftarrow x_c$；否则设 $a\\leftarrow x_c$。这可以保持区间不变性。\n\n停止准则：\n- 如果当前中点的绝对残差 $|f(m)|$ 至多为 $f_{\\text{tol}}$，或者区间长度 $L=b-a$ 至多为 $x_{\\text{tol}}$，则停止。\n- 使用 $x_{\\text{tol}}=10^{-12}$ 和 $f_{\\text{tol}}=10^{-12}$。\n- 最多使用 $N_{\\max}=200$ 次迭代。\n\n切换阈值与安全保障：\n- 使用 $\\tau_{\\text{far}}=0.25$ 和 $\\tau_{\\text{near}}=10^{-3}$。\n- 对于局部线性化，要求 $|f'(x)|\\ge \\delta_{\\min}$（其中 $\\delta_{\\min}=10^{-14}$）才能尝试精化步骤。\n\n您的程序必须实现上述算法，并将其应用于以下函数和区间的测试集。所有角度必须为弧度。测试集中的每个函数在指定区间上都是连续可微的。请在您的实现中提供解析一阶导数 $f'(x)$。\n\n测试集：\n- 案例 1：函数 $f_1(x)=x^3-x-2$，区间为 $[1,2]$，其导数为 $f_1'(x)=3x^2-1$。\n- 案例 2：函数 $f_2(x)=\\cos(x)-x$，区间为 $[0,1]$，其导数为 $f_2'(x)=-\\sin(x)-1$。\n- 案例 3：函数 $f_3(x)=e^{x}-3x$，区间为 $[1,2]$，其导数为 $f_3'(x)=e^{x}-3$。\n- 案例 4：函数 $f_4(x)=x-\\tanh(x)$，区间为 $[-2,2]$，其导数为 $f_4'(x)=1-\\operatorname{sech}^2(x)=1-\\frac{1}{\\cosh^2(x)}$。\n\n最终输出规范：\n- 对于每个案例，将近似根输出为精确到小数点后 $10$ 位的浮点数。\n- 将四个结果按顺序聚合为单个 Python 风格的列表字面量，不含内嵌空格，即单行应为 $[r_1,r_2,r_3,r_4]$ 形式，其中每个 $r_i$ 在小数点后恰好有 $10$ 位数字。\n\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3,r_4]$）。不允许用户输入；所有常量和函数必须在程序内部定义。答案没有物理单位，也不涉及百分比。三角函数中的角度必须是弧度。", "solution": "所提出的问题要求设计并实现一个三元混合算法，用于在指定的括号区间 $[a, b]$ 内寻找标量非线性函数 $f(x)$ 的一个根。对问题陈述的严格验证证实了其科学和数学上的合理性。它基于数值分析的既定原则——介值定理、Taylor 定理和迭代法——并提供了一套完整、一致且明确的要求。因此，该问题被认为是有效的，我们继续进行所需算法的推导和实现。\n\n一个鲁棒的求根算法的核心原则是，将一个安全方法（如区间对分法）的保证收敛性与更快、开放的方法（如 Secant 法或 Newton-Raphson 法）的快速收敛性相结合。所提出的混合策略通过根据当前搜索区间的相对宽度将求解过程划分为三个阶段，从而将这一原则形式化。\n\n**1. 区间不变性与基本原则**\n\n该算法的基础是维持一个括号区间 $[a, b]$，使得根 $x^\\ast$ 始终被包含在内。这一点由介值定理保证，该定理指出，对于一个连续函数 $f$，如果 $f(a)$ 和 $f(b)$ 异号，即 $f(a)f(b) \\le 0$，则在 $[a, b]$ 内必然存在至少一个根 $x^\\ast \\in [a, b]$。\n\n在每次迭代中，我们提出一个候选根 $x_c \\in (a, b)$。然后我们计算 $f(x_c)$ 并更新区间以维持不变性：\n- 如果 $f(a)f(x_c) \\le 0$，则根必在 $[a, x_c]$ 内，因此我们通过更新 $b \\leftarrow x_c$ 将新区间设为 $[a, x_c]$。\n- 否则，必有 $f(x_c)f(b) \\le 0$，所以根在 $[x_c, b]$ 内，我们更新 $a \\leftarrow x_c$。\n此过程保证了区间 $[a, b]$ 总是包含一个根，并且其长度 $L = b-a$ 会系统地减小。\n\n**2. 三元混合切换方案**\n\n候选点 $x_c$ 的选择取决于当前区间长度 $L$ 相对于初始长度 $L_0 = b_0 - a_0$ 的大小。这定义了三阶段策略。\n\n**第一阶段：区间对分（Bisection Method）**\n\n这是最保守且全局收敛的阶段。候选点就是区间的中点：\n$$\nx_c = m = \\frac{a+b}{2}\n$$\n二分法（bisection method）表现出线性收敛，其区间长度在每一步都会减半。只要维持区间不变性，该方法就是无条件安全的。由于其收敛速度慢，它最适用于区间较大且我们远离根的情况。\n**激活条件：**当区间较大，$L > \\tau_{\\text{far}} L_0$ 时，或当更激进的方法失败时作为回退方案，使用此阶段。给定的阈值为 $\\tau_{\\text{far}} = 0.25$。\n\n**第二阶段：基于斜率的外推（Secant Method）**\n\n当区间已充分缩小时，我们可以通过使用基于两个端点 $(a, f(a))$ 和 $(b, f(b))$ 的函数线性模型来加速收敛。穿过这些点的直线（割线）的根给出了下一个候选点：\n$$\nx_c = b - f(b) \\frac{b-a}{f(b)-f(a)} = \\frac{a f(b) - b f(a)}{f(b) - f(a)}\n$$\nSecant 法具有超线性收敛率，阶数约为 $\\phi \\approx 1.618$。\n**激活条件：**此阶段用于中等大小的区间，其中 $\\tau_{\\text{near}} L_0 < L \\le \\tau_{\\text{far}} L_0$，阈值为 $\\tau_{\\text{near}} = 10^{-3}$ 和 $\\tau_{\\text{far}} = 0.25$。\n**安全保障：**只有当 Secant 步骤是“可接受的”，即所提出的候选值 $x_c$ 严格位于当前括号区间内，即 $x_c \\in (a, b)$ 时，才接受该步骤。如果 $x_c$ 落在此范围之外，则拒绝该步骤，算法必须回退到更安全的二分法。\n\n**第三阶段：局部线性化（Newton-Raphson Method）**\n\n当区间非常小时，我们假设我们已经足够接近根，以至于基于 Taylor 定理的局部模型具有很高的准确性。函数 $f(x)$ 在点 $x_k$ 周围的一阶 Taylor 展开为：\n$$\nf(x) \\approx f(x_k) + f'(x_k)(x-x_k)\n$$\n令 $f(x)=0$ 并求解 $x$，可得到 Newton-Raphson 更新规则：\n$$\nx_{k+1} = x_k - \\frac{f(x_k)}{f'(x_k)}\n$$\n对于单根，此方法提供二次收敛。对于我们的算法，我们选择当前区间中点 $m=(a+b)/2$ 作为线性化点，即 $x_k=m$。候选值为：\n$$\nx_c = m - \\frac{f(m)}{f'(m)}\n$$\n**激活条件：**此精化阶段在区间非常小，$L \\le \\tau_{\\text{near}} L_0$ 时被激活。\n**安全保障：**Newton-Raphson 步骤功能强大但可能不稳定。需要两个关键的安全保障措施：\n1.  **可接受性：**与 Secant 法一样，候选值 $x_c$ 必须位于括号区间 $(a, b)$ 内。\n2.  **导数大小：**非常小的导数 $|f'(m)| \\approx 0$ 表示切线几乎是水平的，这可能导致步长巨大且不收敛。因此，我们仅在导数大小超过最小阈值时才尝试 Newton 步：$|f'(m)| \\ge \\delta_{\\min}$，其中 $\\delta_{\\min}=10^{-14}$。\n如果任一安全保障失败，算法必须回退到更安全的方法——首先是第二阶段（Secant 法），如果该法也失败，则回退到第一阶段（Bisection 法）。\n\n**3. 集成算法与回退逻辑**\n\n完整的算法将这三个阶段与清晰的回退层级结合起来，以确保鲁棒性。在每次迭代中，检查停止准则（$L \\le x_{\\text{tol}}$ 或 $|f(m)| \\le f_{\\text{tol}}$）后，按如下方式确定候选值 $x_c$：\n\n1.  计算当前区间长度 $L = b-a$。\n2.  **尝试第三阶段 (Newton)：**如果 $L \\le \\tau_{\\text{near}} L_0$，计算中点 $m$ 处的导数 $f'(m)$。如果 $|f'(m)| \\ge \\delta_{\\min}$，计算 Newton 候选值 $x_c$。如果 $a < x_c < b$，则接受它。\n3.  **尝试第二阶段 (Secant)：**如果没有接受 Newton 候选值且 $L \\le \\tau_{\\text{far}} L_0$，则计算 Secant 候选值 $x_c$。为防止数值不稳定，仅当分母 $|f(b)-f(a)|$ 不会过小时才应执行此操作。如果 $a < x_c < b$，则接受它。\n4.  **使用第一阶段 (Bisection)：**如果 Newton 步和 Secant 步都未被接受，则回退到二分法候选值 $x_c = m$。此步骤始终有效并确保取得进展。\n\n一旦选择了有效的 $x_c$，就更新括号区间 $[a, b]$，并重复该过程，直到满足停止准则或超过最大迭代次数 $N_{\\max}=200$。最终解取为最后计算区间的中点。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the hybrid root-finding algorithm.\n    The results are printed in the specified format.\n    \"\"\"\n\n    def hybrid_solver(f, df, a, b, xtol, ftol, n_max, tau_far, tau_near, delta_min):\n        \"\"\"\n        Implements the ternary hybrid root-finding algorithm.\n\n        Args:\n            f (callable): The function for which to find a root.\n            df (callable): The analytic derivative of the function f.\n            a (float): The lower bound of the bracketing interval.\n            b (float): The upper bound of the bracketing interval.\n            xtol (float): Tolerance for the interval length.\n            ftol (float): Tolerance for the function value at the midpoint.\n            n_max (int): Maximum number of iterations.\n            tau_far (float): Threshold for switching to/from bisection.\n            tau_near (float): Threshold for switching to/from Newton's method.\n            delta_min (float): Minimum slope magnitude for Newton/Secant steps.\n\n        Returns:\n            float: The approximated root.\n        \"\"\"\n        a0, b0 = float(a), float(b)\n        L0 = b0 - a0\n        \n        fa = f(a0)\n        fb = f(b0)\n\n        if fa * fb > 0:\n            # Per problem spec, this should not happen for the given test cases.\n            raise ValueError(\"Root not bracketed or function has same sign at endpoints.\")\n\n        for _ in range(n_max):\n            L = b0 - a0\n            # Use a stable midpoint calculation\n            m = a0 + (b0 - a0) / 2.0\n            fm = f(m)\n\n            # Check stopping criteria\n            if L <= xtol or abs(fm) <= ftol:\n                return m\n\n            candidate_found = False\n            xc = None\n\n            # Phase III: Newton-Raphson Method\n            if L <= tau_near * L0:\n                dfm = df(m)\n                if abs(dfm) >= delta_min:\n                    xc_newton = m - fm / dfm\n                    # Admissibility check\n                    if a0 < xc_newton < b0:\n                        xc = xc_newton\n                        candidate_found = True\n\n            # Phase II: Secant Method (also serves as fallback for Phase III)\n            if not candidate_found and L <= tau_far * L0:\n                # Denominator safety check\n                if abs(fb - fa) >= delta_min:\n                    xc_secant = (a0 * fb - b0 * fa) / (fb - fa)\n                    # Admissibility check\n                    if a0 < xc_secant < b0:\n                        xc = xc_secant\n                        candidate_found = True\n\n            # Phase I: Bisection Method (ultimate fallback)\n            if not candidate_found:\n                xc = m\n            \n            fc = f(xc)\n\n            # Update bracket\n            if fa * fc <= 0:\n                b0 = xc\n                fb = fc\n            else:\n                a0 = xc\n                fa = fc\n        \n        # Return best guess if max iterations reached\n        return (a0 + b0) / 2.0\n\n    # Test Suite Definition\n    test_cases = [\n        {'func': lambda x: x**3 - x - 2, 'dfunc': lambda x: 3*x**2 - 1, 'bracket': (1, 2)},\n        {'func': lambda x: np.cos(x) - x, 'dfunc': lambda x: -np.sin(x) - 1, 'bracket': (0, 1)},\n        {'func': lambda x: np.exp(x) - 3*x, 'dfunc': lambda x: np.exp(x) - 3, 'bracket': (1, 2)},\n        {'func': lambda x: x - np.tanh(x), 'dfunc': lambda x: 1 - (1/np.cosh(x))**2, 'bracket': (-2, 2)}\n    ]\n\n    # Algorithm Parameters\n    params = {\n        'xtol': 1e-12,\n        'ftol': 1e-12,\n        'n_max': 200,\n        'tau_far': 0.25,\n        'tau_near': 1e-3,\n        'delta_min': 1e-14\n    }\n\n    results = []\n    for case in test_cases:\n        root = hybrid_solver(\n            f=case['func'],\n            df=case['dfunc'],\n            a=case['bracket'][0],\n            b=case['bracket'][1],\n            **params\n        )\n        results.append(f\"{root:.10f}\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2402195"}]}