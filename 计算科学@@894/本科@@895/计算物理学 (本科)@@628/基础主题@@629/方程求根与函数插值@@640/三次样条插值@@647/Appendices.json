{"hands_on_practices": [{"introduction": "三次样条插值的核心在于保证数据点之间的平滑连接，这一特性由连接点处连续的二阶导数决定。本练习将引导你直接处理定义样条曲线形状的关键方程。通过为一个简单的三点数据集计算内部节点的二阶导数值 ([@problem_id:2164958])，你将亲身体验构建样条曲线所需满足的基本数学约束，为理解更复杂的情况奠定基础。", "problem": "函数 $S(x)$ 是一个对一组数据点进行插值的自然三次样条。根据定义，三次样条是一个由三次多项式组成的分段函数，它本身及其一阶和二阶导数都是连续的。“自然”三次样条具有一个附加属性，即其二阶导数在插值区间的两个端点处为零。\n\n考虑一个通过以下三个数据点的自然三次样条 $S(x)$：$(x_0, y_0) = (0, 0)$，$(x_1, y_1) = (1, 1)$ 和 $(x_2, y_2) = (2, 0)$。\n\n计算该样条在 $x=1$ 处的二阶导数值，记为 $S''(1)$。", "solution": "令 $x_{0}=0$, $x_{1}=1$, $x_{2}=2$ 且 $y_{0}=0$, $y_{1}=1$, $y_{2}=0$。对于自然三次样条，其在节点处的二阶导数 $M_{i}=S''(x_{i})$ 满足 $M_{0}=0$ 和 $M_{2}=0$，且内部方程为\n$$\nh_{i-1}M_{i-1}+2(h_{i-1}+h_{i})M_{i}+h_{i}M_{i+1}\n=6\\left(\\frac{y_{i+1}-y_{i}}{h_{i}}-\\frac{y_{i}-y_{i-1}}{h_{i-1}}\\right),\n$$\n对 $i=1,\\ldots,n-1$，其中 $h_{i}=x_{i+1}-x_{i}$。此处 $h_{0}=x_{1}-x_{0}=1$ 且 $h_{1}=x_{2}-x_{1}=1$，在 $i=1$ 处有一个唯一的内部方程：\n$$\n1\\cdot M_{0}+2(1+1)M_{1}+1\\cdot M_{2}\n=6\\left(\\frac{y_{2}-y_{1}}{1}-\\frac{y_{1}-y_{0}}{1}\\right).\n$$\n代入 $M_{0}=0$, $M_{2}=0$, $y_{2}-y_{1}=0-1=-1$ 和 $y_{1}-y_{0}=1-0=1$ 可得\n$$\n4M_{1}=6(-1-1)=6(-2)=-12,\n$$\n因此\n$$\nM_{1}=-3.\n$$\n所以 $S''(1)=M_{1}=-3$。", "answer": "$$\\boxed{-3}$$", "id": "2164958"}, {"introduction": "虽然三次样条插值能生成通过所有数据点的光滑曲线，但当数据包含噪声时，这种“完美”的拟合可能会产生误导。这个概念性练习探讨了在面对含有显著随机误差的真实世界数据时，样条插值可能出现的振荡行为。通过分析这种现象的原因 ([@problem_id:2164967])，你将学会批判性地评估插值方法的适用性，并理解平滑（smoothing）与插值（interpolation）之间的重要区别。", "problem": "一位数据科学家正在分析一个从物理实验中收集的数据集。该数据集由一系列测量值对 $(x_i, y_i)$ 组成，其中 $i=1, 2, \\dots, n$。已知测量值 $y_i$ 包含显著的高频随机噪声，而 $x_i$ 值是精确的，并按升序排列。该科学家决定通过对数据点拟合一条自然三次样条来为潜在函数建模。\n\n自然三次样条是一个函数 $S(x)$，它是一个分段三次多项式。它满足以下条件：\n1.  对于所有的 $i=1, \\dots, n$，都有 $S(x_i) = y_i$。\n2.  $S(x)$、其一阶导数 $S'(x)$ 和二阶导数 $S''(x)$ 在整个区间 $[x_1, x_n]$ 上都是连续的。\n3.  在端点处的二阶导数为零：$S''(x_1) = 0$ 且 $S''(x_n) = 0$。\n\n在绘制出得到的样条曲线 $S(x)$ 后，科学家观察到该曲线确实按要求精确地穿过每个数据点，但它在数据点之间的区间内表现出大幅度的、物理上不切实际的振荡。下列哪个陈述为这种振荡行为提供了最准确的解释？\n\nA. 问题在于使用了三次多项式；一个穿过所有点的高次多项式会产生更平滑的结果。\n\nB. 强制样条曲线精确地穿过每个带噪声的数据点，同时在每个点上强制其二阶导数的连续性，导致曲线为了保持平滑而“过冲”并振荡。\n\nC. 构造三次样条是为了最小化一阶导数平方的积分 $\\int (S'(x))^2 dx$。这迫使曲线的斜率为了适应噪声而迅速变化，从而导致振荡。\n\nD. $y_i$ 值中的随机噪声违反了潜在函数的二阶导数必须很小的基本要求。\n\nE. 将端点处二阶导数设为零的“自然”边界条件限制性太强，并引入了从端点向定义域内部传播的人为“摆动”。", "solution": "我们的目标是理解为什么当应用于带噪声的数据时，三次样条插值函数会表现出振荡行为。让我们来分析三次样条的属性以及噪声的影响。\n\n三次样条 $S(x)$ 是一个分段函数，由多个三次多项式组成，每个多项式对应一个区间 $[x_i, x_{i+1}]$。定义该样条的核心约束是：\n1.  **插值性：** 样条必须穿过每个数据点。即，对于所有的 $i$，都有 $S(x_i) = y_i$。\n2.  **平滑性：** 样条及其一阶和二阶导数 $S'(x)$ 和 $S''(x)$ 必须在“节点”（即内部数据点 $x_2, \\dots, x_{n-1}$）处连续。\n\n考虑两个相邻的数据点 $(x_i, y_i)$ 和 $(x_{i+1}, y_{i+1})$。由于存在随机噪声，$y_i$ 的值可能是对真实潜在值的显著高估，而 $y_{i+1}$ 则可能是低估。在区间 $[x_i, x_{i+1}]$ 内的样条段必须从 $(x_i, y_i)$ 开始，到 $(x_{i+1}, y_{i+1})$ 结束。\n\n在节点处二阶导数 $S''(x)$ 的连续性是关键。二阶导数是衡量曲线曲率的指标。条件 $S(x_i) = y_i$ 迫使样条曲线必须经过每一个点，包括那些带噪声的点。为了从一个虚假的“高”点到一个虚假的“低”点，曲线必须显著弯曲。更重要的是，它必须以特定的斜率和曲率到达每个节点，以便平滑地连接到下一段分段函数。\n\n例如，为了穿过一个比其邻近点 $(x_{i-1}, y_{i-1})$ 和 $(x_{i+1}, y_{i+1})$ 高得多的点 $(x_i, y_i)$，曲线在 $x_i$ 之前必须有很大的正曲率（向上弯曲），在 $x_i$ 之后必须有很大的负曲率（向下弯曲）。$S''(x)$ 必须连续的要求意味着样条曲线的曲率不能突然改变。相反，三次多项式必须平滑地从一个曲率过渡到下一个曲率。为了精确地击中带噪声的点，这种强制的平滑过渡常常导致在节点之间出现“过冲”或“下冲”现象，我们将其视为振荡。样条试图在必须击中每个带噪声点的硬约束下，最小化其总弯曲能量（与 $\\int (S''(x))^2 dx$ 成正比），而这种权衡导致了波动的曲线。\n\n让我们来评估给出的选项：\n\n**A. 问题在于使用了三次多项式；一个穿过所有点的高次多项式会产生更平滑的结果。**\n这是不正确的。用单个高次多项式对许多点进行插值，是出了名的容易出现剧烈振荡，尤其是在端点附近，这种现象被称为龙格现象（Runge's phenomenon）。引入分段多项式（如样条）正是为了解决这种不稳定性。\n\n**B. 强制样条曲线精确地穿过每个带噪声的数据点，同时在每个点上强制其二阶导数的连续性，导致曲线为了保持平滑而“过冲”并振荡。**\n这是正确的解释。两个严格要求的结合——穿过每个带噪声的点（`插值性`）和保持 $C^2$ 连续性（`平滑性`）——是根本原因。样条曲线为了同时满足这两个条件而被迫过度弯曲，从而导致数据点之间的振荡。\n\n**C. 构造三次样条是为了最小化一阶导数平方的积分 $\\int (S'(x))^2 dx$。这迫使曲线的斜率为了适应噪声而迅速变化，从而导致振荡。**\n这是不正确的。自然三次样条是唯一的插值函数，它能最小化*二阶*导数平方的积分 $\\int (S''(x))^2 dx$。这个积分与曲线的总“弯曲能量”有关。样条试图尽可能地“直”（最小化曲率），而不是尽可能地“短”（这与一阶导数有关）。\n\n**D. $y_i$ 值中的随机噪声违反了潜在函数的二阶导数必须很小的基本要求。**\n这种说法歪曲了问题。对于构造样条曲线而言，对潜在函数并没有所谓的“基本要求”。样条可以为任何数据集构建。问题不在于违反了某个要求，而在于*因为*数据带噪声，所以得到的样条曲线的属性（振荡）是不理想的。大的二阶导数是对带噪声数据拟合样条的一个*结果*，而不是违反了一个前提条件。\n\n**E. 将端点处二阶导数设为零的“自然”边界条件限制性太强，并引入了从端点向定义域内部传播的人为“摆动”。**\n虽然边界条件确实会影响样条的形状，尤其是在端点附近，但当数据带噪声时，它们并不是整个定义域内部出现振荡的主要原因。振荡行为是对带噪声数据进行样条插值的一个普遍特征，即使使用其他边界条件（如“钳位”样条），这种行为也依然存在。核心问题是由每个内部节点的 $C^2$ 连续性驱动的局部行为。", "answer": "$$\\boxed{B}$$", "id": "2164967"}, {"introduction": "掌握了理论基础和概念上的细微差别之后，现在是时候将所有知识融会贯通，构建一个完整的计算工具了。这个实践任务要求你编写一个程序，实现自然三次样条插值的全过程，包括建立并求解决定样条曲线二阶导数的线性方程组。通过完成这个编码练习 ([@problem_id:2384309])，你不仅能将抽象的数学公式转化为可执行的代码，还将获得解决实际计算物理问题的宝贵实践技能。", "problem": "给定在一系列严格递增节点上采样的一维数据。对于一组节点 $x_0 < x_1 < \\dots < x_n$ 及其对应值 $y_0, y_1, \\dots, y_n$，考虑由以下属性定义的唯一自然三次样条 $S(x)$：在每个区间 $[x_i, x_{i+1}]$ 上，函数 $S(x)$ 是一个三次多项式；函数 $S(x)$ 对所有 $0 \\le i \\le n$ 的 $i$ 满足插值条件 $S(x_i) = y_i$；一阶导数 $S'(x)$ 在 $[x_0, x_n]$ 上连续；二阶导数 $S''(x)$ 在 $[x_0, x_n]$ 上连续；并且满足自然边界条件 $S''(x_0) = 0$ 和 $S''(x_n) = 0$。您的任务是编写一个完整的程序，对下方的每个测试用例，为所提供的数据集构建唯一的自然三次样条 $S(x)$，并在指定的查询点 $x_q$ 处计算 $S(x)$ 的值。\n\n测试套件中的所有输入均在下方明确给出。每个测试用例都是独立的。在每个案例中，使用所提供的数组 $x$ 和 $y$ 作为精确数据来构建 $S(x)$，然后计算标量值 $S(x_q)$。不允许也不需要任何外部数据源。所有计算都是纯数值和无量纲的；不涉及物理单位。\n\n测试套件（每一项都是一个三元组 $(x, y, x_q)$，需按给定顺序独立处理）：\n- 测试用例 1：$x = [\\,0,\\,0.5,\\,1.7,\\,2.2,\\,3.0\\,]$，$y = [\\,0.0,\\,0.5,\\,1.8,\\,2.1,\\,1.2\\,]$，$x_q = 1.3$。\n- 测试用例 2：$x = [\\,0,\\,0.5,\\,1.7,\\,2.2,\\,3.0\\,]$，$y = [\\,0.0,\\,0.5,\\,1.8,\\,2.1,\\,1.2\\,]$，$x_q = 0.0$。\n- 测试用例 3：$x = [\\,0,\\,0.5,\\,1.7,\\,2.2,\\,3.0\\,]$，$y = [\\,0.0,\\,0.5,\\,1.8,\\,2.1,\\,1.2\\,]$，$x_q = 3.0$。\n- 测试用例 4：$x = [\\,0,\\,0.5,\\,1.7,\\,2.2,\\,3.0\\,]$，$y = [\\,0.0,\\,0.5,\\,1.8,\\,2.1,\\,1.2\\,]$，$x_q = 2.2$。\n- 测试用例 5：$x = [\\,-1.0,\\,2.0\\,]$，$y = [\\,-1.0,\\,4.0\\,]$，$x_q = 0.5$。\n\n您的程序必须按顺序计算上述 5 个案例中每个案例的 $S(x_q)$，并生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。输出列表中的每个数字必须是四舍五入到恰好 8 位小数的浮点值。例如，要求的输出格式为 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_i$ 是测试用例 $i$ 的 $S(x_q)$ 值，四舍五入到 8 位小数。", "solution": "目标是根据给定的数据 $(x_i, y_i)$（其中 $0 \\le i \\le n$ 且 $x_0 < x_1 < \\dots < x_n$）构建唯一的自然三次样条 $S(x)$。根据定义，$S(x)$ 在每个区间 $[x_i, x_{i+1}]$ 上是分段三次的，对数据进行插值 $S(x_i) = y_i$，其一阶和二阶导数在 $[x_0, x_n]$ 上连续，且满足自然边界条件 $S''(x_0) = 0$ 和 $S''(x_n) = 0$。\n\n一种标准的构建方法是引入节点处的未知二阶导数向量，记为 $M_i = S''(x_i)$，其中 $0 \\le i \\le n$。步长为 $h_i = x_{i+1} - x_i$，其中 $0 \\le i \\le n-1$。对于内部索引 $i$（$1 \\le i \\le n-1$），$S'(x)$ 和 $S''(x)$ 在节点上的连续性导致了一个关于内部二阶导数 $M_1, M_2, \\dots, M_{n-1}$ 的线性方程组：\n$$\nh_{i-1} M_{i-1} + 2(h_{i-1} + h_{i}) M_i + h_i M_{i+1} = 6\\left( \\frac{y_{i+1} - y_i}{h_i} - \\frac{y_i - y_{i-1}}{h_{i-1}} \\right),\n$$\n并带有自然边界条件 $M_0 = 0$ 和 $M_n = 0$。当 $n = 1$（即两个节点）时，没有内部未知数，自然三次样条精确地退化为两点之间的线性插值，这与 $M_0 = 0$ 和 $M_1 = 0$ 是一致的。\n\n该系统关于 $(M_1, \\dots, M_{n-1})$ 的系数矩阵是三对角的，对于 $1 \\le i \\le n-1$，其各项如下：\n- 主对角线：$b_i = 2(h_{i-1} + h_i)$。\n- 次对角线：$a_i = h_{i-1}$，对于 $i \\ge 2$。\n- 超对角线：$c_i = h_i$，对于 $i \\le n-2$。\n右侧项为 $d_i = 6\\left( \\frac{y_{i+1} - y_i}{h_i} - \\frac{y_i - y_{i-1}}{h_{i-1}} \\right)$。\n\n对于严格递增的 $x_i$（即 $h_i > 0$），该线性系统是严格对角占优的，这确保了唯一解的存在。求解三对角线性系统的一种高效精确方法是在 $\\mathcal{O}(n)$ 时间内完成，该方法包括一个消除次对角线元素的向前消元阶段，以及一个恢复未知数的回代阶段。具体来说，假设该系统用紧凑的符号表示为\n$$\na_i M_{i-1} + b_i M_i + c_i M_{i+1} = d_i, \\quad \\text{for } i = 1, 2, \\dots, n-1,\n$$\n并约定 $a_1 = 0$ 和 $c_{n-1} = 0$。向前消元步骤构建修正后的对角线和右侧项：\n对于 $i = 2, 3, \\dots, n-1$，\n$$\nw = \\frac{a_i}{b_{i-1}}, \\quad\nb_i \\leftarrow b_i - w c_{i-1}, \\quad\nd_i \\leftarrow d_i - w d_{i-1}.\n$$\n然后，回代计算\n$$\nM_{n-1} = \\frac{d_{n-1}}{b_{n-1}}, \\quad\nM_i = \\frac{d_i - c_i M_{i+1}}{b_i} \\quad \\text{for } i = n-2, n-3, \\dots, 1.\n$$\n最后，设置 $M_0 = 0$ 和 $M_n = 0$ 以获得完整的向量 $(M_0, M_1, \\dots, M_n)$。\n\n当二阶导数已知后，可以使用类埃尔米特表示法在区间 $[x_i, x_{i+1}]$ 上对任意 $x \\in [x_i, x_{i+1}]$ 计算样条值\n$$\nS(x) = A y_i + B y_{i+1} + \\frac{h_i^2}{6} \\left[ (A^3 - A) M_i + (B^3 - B) M_{i+1} \\right],\n$$\n其中 $h_i = x_{i+1} - x_i$，$A = \\frac{x_{i+1} - x}{h_i}$，以及 $B = \\frac{x - x_i}{h_i}$。根据构造，该表示法满足 $S(x_i) = y_i$、$S(x_{i+1}) = y_{i+1}$ 以及连续性条件。如果 $n = 1$，那么对所有索引 $M_i = 0$，该公式简化为线性插值 $S(x) = A y_0 + B y_1$。\n\n要计算 $S(x_q)$ 的值，先确定区间 $[x_i, x_{i+1}]$ 使得 $x_q \\in [x_i, x_{i+1}]$。如果 $x_q = x_n$，则选择最后一个区间 $[x_{n-1}, x_n]$。计算 $A$ 和 $B$，然后通过上述公式计算 $S(x_q)$。对每个测试用例重复此过程，即可生成所需的标量输出。每个结果最终四舍五入到恰好 8 位小数，并按指定顺序以单个方括号括起来的逗号分隔列表的形式输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef natural_cubic_spline_second_derivatives(x, y):\n    \"\"\"\n    Compute second derivatives M at knots for the natural cubic spline.\n    x: list or array of strictly increasing floats\n    y: list or array of floats of same length as x\n    Returns: list of M values (second derivatives) at each knot.\n    \"\"\"\n    n = len(x) - 1  # number of intervals\n    if n  1:\n        raise ValueError(\"At least two data points are required.\")\n    if n == 1:\n        # Two nodes: linear interpolation, M = 0 at both ends.\n        return [0.0, 0.0]\n\n    h = [x[i+1] - x[i] for i in range(n)]\n    # Build tridiagonal system for M[1..n-1]\n    m = n - 1  # number of interior unknowns\n    a = [0.0] * m  # sub-diagonal (a[0] unused or zero)\n    b = [0.0] * m  # main diagonal\n    c = [0.0] * m  # super-diagonal (c[m-1] unused or zero)\n    d = [0.0] * m  # right-hand side\n\n    for i in range(m):\n        hi_prev = h[i] if i >= 0 else None\n        hi = h[i+1] if (i + 1)  n else None\n        # Using indices: interior i corresponds to global index i+1\n        if i == 0:\n            a[i] = 0.0\n        else:\n            a[i] = h[i]\n        if i == m - 1:\n            c[i] = 0.0\n        else:\n            c[i] = h[i+1]\n        b[i] = 2.0 * (h[i] + h[i+1])\n\n        # Right-hand side\n        yi_minus = y[i]\n        yi = y[i+1]\n        yi_plus = y[i+2]\n        d[i] = 6.0 * ((yi_plus - yi) / h[i+1] - (yi - yi_minus) / h[i])\n\n    # Thomas algorithm: forward elimination\n    for i in range(1, m):\n        if b[i-1] == 0.0:\n            raise ZeroDivisionError(\"Singular tridiagonal system encountered.\")\n        w = a[i] / b[i-1]\n        b[i] -= w * c[i-1]\n        d[i] -= w * d[i-1]\n\n    # Back substitution\n    M_interior = [0.0] * m\n    M_interior[-1] = d[-1] / b[-1]\n    for i in range(m - 2, -1, -1):\n        M_interior[i] = (d[i] - c[i] * M_interior[i + 1]) / b[i]\n\n    # Assemble full M with natural boundary conditions\n    M = [0.0] + M_interior + [0.0]\n    return M\n\ndef evaluate_natural_cubic_spline(x, y, M, xq):\n    \"\"\"\n    Evaluate the natural cubic spline defined by (x, y, M) at xq.\n    x: list of knots (strictly increasing)\n    y: list of values\n    M: list of second derivatives at knots\n    xq: query point within [x[0], x[-1]]\n    \"\"\"\n    n = len(x) - 1\n    if xq = x[0]:\n        i = 0\n    elif xq >= x[-1]:\n        i = n - 1\n    else:\n        # Find right interval i such that x[i] = xq = x[i+1]\n        # Using binary search\n        left, right = 0, n\n        while left = right:\n            mid = (left + right) // 2\n            if x[mid] = xq:\n                left = mid + 1\n            else:\n                right = mid - 1\n        i = max(0, min(right, n - 1))\n\n    h = x[i+1] - x[i]\n    if h == 0.0:\n        raise ZeroDivisionError(\"Zero interval width encountered.\")\n    A = (x[i+1] - xq) / h\n    B = (xq - x[i]) / h\n    # S(x) formula using second derivatives M\n    term = ((A**3 - A) * M[i] + (B**3 - B) * M[i+1]) * (h**2) / 6.0\n    Sx = A * y[i] + B * y[i+1] + term\n    return Sx\n\ndef solve():\n    # Define the test cases from the problem statement.\n    xA = [0.0, 0.5, 1.7, 2.2, 3.0]\n    yA = [0.0, 0.5, 1.8, 2.1, 1.2]\n    test_cases = [\n        (xA, yA, 1.3),\n        (xA, yA, 0.0),\n        (xA, yA, 3.0),\n        (xA, yA, 2.2),\n        ([-1.0, 2.0], [-1.0, 4.0], 0.5),\n    ]\n\n    results = []\n    for x, y, xq in test_cases:\n        # Compute second derivatives for the dataset\n        M = natural_cubic_spline_second_derivatives(x, y)\n        # Evaluate spline at query point\n        val = evaluate_natural_cubic_spline(x, y, M, xq)\n        results.append(val)\n\n    # Final print statement in the exact required format: 8 decimal places, no spaces\n    formatted = \"[\" + \",\".join(f\"{r:.8f}\" for r in results) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2384309"}]}