{"hands_on_practices": [{"introduction": "要掌握插值误差的微妙之处，最好的方法是从一个经典例子开始。本练习将使用一个简单、平滑的函数——量子力学中无限深势阱的定态波函数 $\\psi_n(x)$——作为测试平台。通过直接比较等距节点和切比雪夫节点在高阶多项式插值中的表现，你将亲眼见证龙格现象的出现以及如何有效规避它。[@problem_id:2436069]", "problem": "考虑宽度为 $L$ 的一维(1D)无限深方势阱中的不含时薛定谔方程，其归一化定态在闭区间 $[0,L]$ 上由 $\\psi_{n}(x)=\\sin\\!\\left(\\dfrac{n\\pi x}{L}\\right)$ 给出，其中 $n$ 是一个正整数，且正弦函数的参数以弧度为单位。对于给定的整数 $M\\geq 2$，定义一个插值节点集 $\\{x_{j}\\}_{j=0}^{M-1}\\subset[0,L]$，以及一个次数最多为 $M-1$ 的唯一多项式 $p(x)$，该多项式对所有 $j$ 均满足 $p(x_{j})=\\psi_{n}(x_{j})$。对于下方测试套件中的每种情况，你的任务是在一个由 $Q$ 个点组成的均匀评估网格上计算最大绝对插值误差 $E$，其定义如下：\n$$E=\\max_{0\\leq k \\leq Q-1}\\left|\\psi_{n}(x_{k})-p(x_{k})\\right|,\\quad x_{k}=\\frac{k\\,L}{Q-1},$$\n其中 $Q=10001$。所有量均为无量纲，所有角度均以弧度为单位。\n\n将使用两种节点集类型：\n- 等距节点：$x_{j}=\\dfrac{j\\,L}{M-1}$，其中 $j=0,1,\\dots,M-1$。\n- 映射到 $[0,L]$ 的 Chebyshev–Lobatto (CL) 节点：$x_{j}=\\dfrac{L}{2}\\left(1-\\cos\\!\\left(\\dfrac{j\\pi}{M-1}\\right)\\right)$，其中 $j=0,1,\\dots,M-1$。\n\n对于测试套件中的每个参数元组 $(L,n,M,\\text{node\\_type})$，构建相应的多项式插值 $p(x)$ 并计算如上定义的 $E$。\n\n测试套件 (输出时需严格遵循此顺序)：\n1. $(L=\\;1,\\;n=\\;3,\\;M=\\;9,\\;\\text{node\\_type}=\\text{等距})$,\n2. $(L=\\;1,\\;n=\\;15,\\;M=\\;9,\\;\\text{node\\_type}=\\text{等距})$,\n3. $(L=\\;1,\\;n=\\;15,\\;M=\\;9,\\;\\text{node\\_type}=\\text{CL})$,\n4. $(L=\\;1,\\;n=\\;20,\\;M=\\;21,\\;\\text{node\\_type}=\\text{等距})$,\n5. $(L=\\;1,\\;n=\\;20,\\;M=\\;21,\\;\\text{node\\_type}=\\text{CL})$,\n6. $(L=\\;2,\\;n=\\;15,\\;M=\\;21,\\;\\text{node\\_type}=\\text{等距})$,\n7. $(L=\\;1,\\;n=\\;50,\\;M=\\;51,\\;\\text{node\\_type}=\\text{等距})$,\n8. $(L=\\;1.1,\\;n=\\;50,\\;M=\\;51,\\;\\text{node\\_type}=\\text{CL})$.\n\n你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，列表内含8个结果，顺序与测试套件相同。每个结果必须是一个浮点数，等于相应情况下的 $E$ 值，并四舍五入到小数点后恰好8位 (例如，$[0.12345679,0.00000001,\\dots]$)。", "solution": "所提出的问题是计算物理学和数值分析中一个定义明确的练习，具体涉及多项式插值的误差分析。它要求计算在使用多项式插值函数来近似一个给定函数（该函数源自一维量子无限深方势阱的定态）时的最大绝对误差。问题的核心是比较两种不同插值节点集（等距节点和 Chebyshev-Lobatto 节点）的有效性。\n\n该问题在科学和数学上是合理的。待插值的函数是 $\\psi_{n}(x) = \\sin\\left(\\frac{n\\pi x}{L}\\right)$，它在整个实数轴上是解析函数，因此无限可微，非常适合此类分析。任务是构建一个次数最多为 $M-1$ 的唯一多项式 $p(x)$，该多项式穿过 $M$ 个给定点 $(x_j, \\psi_{n}(x_j))$。此类多项式的存在性和唯一性是数值分析的基石。\n\n解决此问题的方法包括以下步骤：\n$1$. 对于由参数 $(L, n, M, \\text{node\\_type})$ 指定的每个测试用例，在区间 $[0, L]$ 内生成包含 $M$ 个插值节点的集合 $\\{x_j\\}_{j=0}^{M-1}$。\n    - 对于等距节点，公式为 $x_j = j \\frac{L}{M-1}$。\n    - 对于 Chebyshev-Lobatto (CL) 节点，公式为 $x_j = \\frac{L}{2}\\left(1 - \\cos\\left(\\frac{j\\pi}{M-1}\\right)\\right)$。此分布将第一类 Chebyshev 多项式 $T_{M-1}(t)$ 的极值点从规范区间 $[-1, 1]$ 映射到 $[0, L]$。\n\n$2$. 计算相应的函数值 $\\{y_j = \\psi_n(x_j)\\}_{j=0}^{M-1}$。\n\n$3$. 构建插值多项式 $p(x)$。虽然 Lagrange 公式提供了 $p(x)$ 的理论定义，但其直接实现在高次情况下数值不稳定。一种更优越的求值方法是重心插值公式。给定节点 $x_j$ 和值 $y_j$，多项式在任意点 $x$ 的值可以计算为：\n$$ p(x) = \\frac{\\sum_{j=0}^{M-1} \\frac{w_j}{x - x_j} y_j}{\\sum_{j=0}^{M-1} \\frac{w_j}{x - x_j}} $$\n其中 $w_j$ 是重心权重。这种形式数值稳定且高效。`scipy.interpolate.BarycentricInterpolator` 类提供了这种方法的稳健实现。\n\n$4$. 为了找到最大插值误差 $E$，在 $[0, L]$ 上创建一个由 $Q=10001$ 个评估点组成的精细均匀网格 $\\{x_k\\}_{k=0}^{Q-1}$。\n\n$5$. 在每个评估点 $x_k$ 处计算绝对误差 $|\\psi_n(x_k) - p(x_k)|$。这些值的最大值即为结果 $E$：\n$$ E = \\max_{k} |\\psi_n(x_k) - p(x_k)| $$\n\n此问题旨在展示逼近论中的一个关键概念：插值节点的选择深刻影响近似的精度。多项式插值的误差由一个项界定，该项取决于函数的 $(M)$ 阶导数和节点多项式 $\\omega(x) = \\prod_{j=0}^{M-1}(x - x_j)$。Chebyshev-Lobatto 节点能够最小化区间上 $|\\omega(x)|$ 的最大值，与等距节点相比，这能导向一个更小的理论误差界。对于等距节点，随着 $M$ 的增加，插值误差在区间边界附近可能不可控地增长，这种行为被称为 Runge 现象。当被插值函数具有大的导数时（例如 $k$ 很大时的 $\\sin(k x)$），这种现象尤其明显。该问题的测试用例旨在凸显这种确切的行为。对于 $n$ 与 $M$ 之比较大且使用等距节点的情况，预计会产生巨大的误差，而使用 Chebyshev-Lobatto 节点将显著减小这种误差。\n\n该算法使用 Python 实现，利用 `numpy` 库的向量化方法进行高效的数组计算，并使用 `scipy.interpolate.BarycentricInterpolator` 进行稳定的多项式构建和求值。针对八个测试用例中的每一个执行此程序，并将所得的最大误差按规定格式收集和格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import BarycentricInterpolator\n\ndef solve():\n    \"\"\"\n    Solves the interpolation error problem for the given test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, n, M, node_type)\n        (1.0, 3, 9, 'equispaced'),\n        (1.0, 15, 9, 'equispaced'),\n        (1.0, 15, 9, 'CL'),\n        (1.0, 20, 21, 'equispaced'),\n        (1.0, 20, 21, 'CL'),\n        (2.0, 15, 21, 'equispaced'),\n        (1.0, 50, 51, 'equispaced'),\n        (1.0, 50, 51, 'CL'),\n    ]\n\n    results = []\n    Q = 10001 # Number of evaluation points\n\n    for L, n, M, node_type in test_cases:\n        # 1. Define the function to be interpolated\n        # psi_n(x) = sin(n*pi*x/L)\n        psi_n = lambda x: np.sin(n * np.pi * x / L)\n\n        # 2. Generate M interpolation nodes\n        if node_type == 'equispaced':\n            x_interp = np.linspace(0.0, L, M)\n        elif node_type == 'CL':\n            j = np.arange(M)\n            # Chebyshev-Lobatto nodes mapped from [-1, 1] to [0, L]\n            x_interp = L / 2.0 * (1.0 - np.cos(j * np.pi / (M - 1)))\n        \n        # 3. Compute function values at interpolation nodes\n        y_interp = psi_n(x_interp)\n\n        # 4. Construct the barycentric interpolant\n        poly = BarycentricInterpolator(x_interp, y_interp)\n\n        # 5. Define the fine evaluation grid\n        x_eval = np.linspace(0.0, L, Q)\n\n        # 6. Evaluate the true function and the polynomial on the grid\n        y_true = psi_n(x_eval)\n        y_poly = poly(x_eval)\n\n        # 7. Compute the maximum absolute error\n        max_error = np.max(np.abs(y_true - y_poly))\n        results.append(max_error)\n\n    # Final print statement in the exact required format.\n    # Each result is rounded to exactly 8 digits after the decimal point.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```", "id": "2436069"}, {"introduction": "在掌握了基本原理之后，让我们将这些概念应用到一个更具挑战性的真实物理模型中。本练习关注量子隧穿效应，其透射概率函数 $T(E)$ 在势垒高度 $E=V_0$ 处虽然连续但非解析。这个特性使得它成为检验插值方法在“不完美”函数上表现的绝佳案例，让你能更深入地理解为什么切比雪夫节点在计算物理实践中如此重要。[@problem_id:2436011]", "problem": "编写一个完整、可运行的程序，用于量化插值误差，并说明在使用全局多项式插值函数逼近量子力学隧穿概率函数时，龙格现象（Runge's phenomenon）的出现或缓解情况。考虑一个质量为 $m$ 的非相对论性粒子，入射到一个高度为 $V_0$、宽度为 $a$ 的一维矩形势垒上。其透射概率作为动能 $E \\ge 0$ 的函数，由以下分段函数定义，并以国际单位制（SI）表示：\n\n对于 $0 \\le E < V_0$,\n$$\nT(E) = \\frac{1}{1 + \\dfrac{V_0^2 \\sinh^2\\!\\big(\\kappa a\\big)}{4 E (V_0 - E)}}, \\quad \\kappa = \\frac{\\sqrt{2 m (V_0 - E)}}{\\hbar}.\n$$\n\n对于 $E = V_0$,\n$$\nT(E) = \\frac{1}{1 + \\dfrac{m V_0 a^2}{2 \\hbar^2}}.\n$$\n\n对于 $E > V_0$,\n$$\nT(E) = \\frac{1}{1 + \\dfrac{V_0^2 \\sin^2\\!\\big(k_2 a\\big)}{4 E (E - V_0)}}, \\quad k_2 = \\frac{\\sqrt{2 m (E - V_0)}}{\\hbar}.\n$$\n\n如果 $E = 0$，则取 $T(0) = 0$。此处 $\\hbar$ 是约化普朗克常数。函数 $T(E)$ 是无量纲的。这些公式内的所有计算都必须使用国际单位制（SI）进行。以电子伏特为单位的能量必须使用 $1\\ \\text{electronvolt} = 1.602176634 \\times 10^{-19}\\ \\text{joule}$ 转换为焦耳，以纳米为单位的长度必须使用 $1\\ \\text{nanometer} = 1.0 \\times 10^{-9}\\ \\text{meter}$ 转换为米，约化普朗克常数和电子质量必须取值为\n$$\n\\hbar = 1.054571817 \\times 10^{-34}\\ \\text{joule}\\cdot\\text{second}, \\quad m_e = 9.1093837015 \\times 10^{-31}\\ \\text{kilogram}.\n$$\n\n对于下面测试套件中的每个测试用例，执行以下操作：\n\n1. 使用 $m = m_e$。\n2. 将能量区间定义为 $[0, E_{\\max}]$，其中 $E_{\\max} = \\alpha V_0$。$\\alpha$ 是测试用例中提供的无量纲因子，并且在 $T(E)$ 内部，$E_{\\max}$ 和 $V_0$ 都必须以焦耳为单位使用。\n3. 构建一个次数最多为 $N-1$ 的唯一多项式插值函数，它在 $[0, E_{\\max}]$ 区间内的 $N$ 个节点上对 $T(E)$ 进行插值，其中节点集由一个节点类型标志指定：\n   - 如果节点类型为 “equispaced”，节点为 $x_i = \\dfrac{i}{N-1} E_{\\max}$，其中 $i = 0, 1, \\ldots, N-1$。\n   - 如果节点类型为 “Chebyshev”，节点为从 $[-1,1]$ 映射到 $[0, E_{\\max}]$ 的 $N$ 个第一类 Chebyshev 点，即 $x_i = \\dfrac{E_{\\max}}{2}\\left(1 + \\cos\\!\\left(\\dfrac{2 i + 1}{2 N} \\pi\\right)\\right)$，其中 $i = 0, 1, \\ldots, N-1$。\n4. 在 $[0, E_{\\max}]$ 区间内一个包含 $1001$ 个点的均匀评估网格上，即集合 $\\left\\{ 0, \\dfrac{E_{\\max}}{1000}, \\dfrac{2 E_{\\max}}{1000}, \\ldots, E_{\\max} \\right\\}$ 上，通过将插值函数与这些网格点上的精确 $T(E)$ 值进行比较，来评估最大绝对插值误差。将最大绝对误差报告为一个无量纲的十进制数。\n\n你的程序必须计算并单行输出以下测试套件的最大绝对误差列表，并按所列顺序排列：\n\n- 测试用例 1：$V_0 = 0.6\\ \\text{electronvolt}$，$a = 1.0\\ \\text{nanometer}$，$\\alpha = 1.2$，$N = 11$，节点类型 = equispaced。\n- 测试用例 2：$V_0 = 0.6\\ \\text{electronvolt}$，$a = 1.0\\ \\text{nanometer}$，$\\alpha = 1.2$，$N = 11$，节点类型 = Chebyshev。\n- 测试用例 3：$V_0 = 0.6\\ \\text{electronvolt}$，$a = 1.0\\ \\text{nanometer}$，$\\alpha = 1.2$，$N = 41$，节点类型 = equispaced。\n- 测试用例 4：$V_0 = 0.6\\ \\text{electronvolt}$，$a = 1.0\\ \\text{nanometer}$，$\\alpha = 1.2$，$N = 41$，节点类型 = Chebyshev。\n- 测试用例 5：$V_0 = 0.8\\ \\text{electronvolt}$，$a = 2.0\\ \\text{nanometer}$，$\\alpha = 1.2$，$N = 21$，节点类型 = equispaced。\n- 测试用例 6：$V_0 = 0.3\\ \\text{electronvolt}$，$a = 0.3\\ \\text{nanometer}$，$\\alpha = 1.2$，$N = 21$，节点类型 = equispaced。\n\n最终所需的输出格式为一行，包含一个由方括号括起来的、逗号分隔的六个最大绝对误差列表，例如，“[e1,e2,e3,e4,e5,e6]”，其中每个 $e_k$ 是一个四舍五入到六位有效数字的十进制数。误差是无量纲的，因此输出中无需指明物理单位。不得打印任何额外文本。", "solution": "所提供的问题陈述经过了严格验证，并被认定为有效。它在科学上是合理的、适定的，并包含了获得唯一、可验证解所需的所有必要信息。该物理模型基于粒子隧穿矩形势垒的标准量子力学处理方法，这是入门量子力学的基石之一。该数值任务涉及多项式插值和龙格现象（Runge's phenomenon）的分析，是计算物理和数值分析中的一个典型问题。所有参数、常数和程序步骤都以足够的精度被指定。\n\n问题的核心是使用一个次数最多为 $N-1$ 的单项多项式插值函数 $P_{N-1}(E)$ 来逼近给定的函数，即量子隧穿概率 $T(E)$。然后对该逼近的误差进行量化。函数 $T(E)$ 是为质量为 $m$、动能为 $E \\ge 0$、入射到高度为 $V_0$、宽度为 $a$ 的势垒上的粒子定义的。该函数是分段的，其解析形式取决于能量 $E$ 是小于、等于还是大于势垒高度 $V_0$。定义如下：\n对于 $0 \\le E < V_0$:\n$$\nT(E) = \\frac{1}{1 + \\dfrac{V_0^2 \\sinh^2\\!\\big(\\kappa a\\big)}{4 E (V_0 - E)}}, \\quad \\text{其中} \\quad \\kappa = \\frac{\\sqrt{2 m (V_0 - E)}}{\\hbar}\n$$\n对于 $E = V_0$:\n$$\nT(E) = \\frac{1}{1 + \\dfrac{m V_0 a^2}{2 \\hbar^2}}\n$$\n对于 $E > V_0$:\n$$\nT(E) = \\frac{1}{1 + \\dfrac{V_0^2 \\sin^2\\!\\big(k_2 a\\big)}{4 E (E - V_0)}}, \\quad \\text{其中} \\quad k_2 = \\frac{\\sqrt{2 m (E - V_0)}}{\\hbar}\n$$\n给出了 $E=0$ 的特殊情况，此时 $T(0)=0$。此处，$\\hbar$ 是约化普朗克常数。分析表明，函数 $T(E)$ 对于所有 $E \\ge 0$ 都是连续的。然而，从双曲正弦（对于 $E < V_0$）到三角正弦（对于 $E > V_0$）的转变表明，该函数在 $E=V_0$ 处不解析。当使用等距节点的高次多项式插值函数时，这种非解析性是导致龙格现象（Runge's phenomenon）出现的关键条件。\n\n插值在能量区间 $[0, E_{\\max}]$ 上进行，其中 $E_{\\max} = \\alpha V_0$。构造多项式 $P_{N-1}(E)$，使其在 $N$ 个指定点（或称节点）$\\{x_i\\}_{i=0}^{N-1}$ 处与精确函数 $T(E)$ 相匹配。考虑了两种类型的节点分布：\n$1$. 等距节点（Equispaced nodes）：$x_i = \\dfrac{i}{N-1} E_{\\max}$，其中 $i=0, 1, \\ldots, N-1$。已知对于非解析函数，这些节点会在区间端点附近导致大的振荡，这种行为被称为龙格现象（Runge's phenomenon）。\n$2$. Chebyshev 节点：$x_i = \\dfrac{E_{\\max}}{2}\\left(1 + \\cos\\!\\left(\\dfrac{(2i+1)\\pi}{2N}\\right)\\right)$，其中 $i=0, 1, \\ldots, N-1$。这些节点是第一类 Chebyshev 多项式 $T_N(x)$ 的根，经过缩放和平移以适应区间 $[0, E_{\\max}]$。它们在端点附近的密度更高，这被证明可以抑制或缓解龙格现象（Runge's phenomenon），从而为连续函数带来更优的收敛特性。\n\n该解决方案按以下算法实现。对于每个测试用例，使用参数 $V_0$、$a$、$\\alpha$、$N$ 和节点类型。所有以非国际单位制（电子伏特、纳米）给出的物理量，首先使用提供的转换因子转换为其对应的国际单位制（焦耳、米）。粒子质量 $m$ 被设定为电子质量 $m_e$。\n\n首先，根据指定的类型生成包含 $N$ 个插值节点的集合 $\\{x_i\\}$。然后，在每个节点上计算精确函数值 $y_i = T(x_i)$，从而创建数据集 $\\{(x_i, y_i)\\}_{i=0}^{N-1}$。接着，构造一个穿过这 $N$ 个点的单项多项式插值函数 $P_{N-1}(E)$。为了数值稳定性和效率，特别是对于大的 $N$，重心插值公式是首选方法。`scipy.interpolate.BarycentricInterpolator` 类提供了这种技术的稳健实现。\n\n为了量化逼近的质量，在区间 $[0, E_{\\max}]$ 上估计最大绝对误差 $\\|T - P_{N-1}\\|_{\\infty}$。这是通过在一个包含 $1001$ 个评估点的精细均匀网格 $\\{E_j\\}_{j=0}^{1000}$ 上计算误差来完成的，其中 $E_j = j \\cdot E_{\\max} / 1000$。然后，最大绝对误差计算如下：\n$$\n\\text{Error} = \\max_{j} | T(E_j) - P_{N-1}(E_j) |\n$$\n对于问题陈述中指定的六个测试用例中的每一个，重复此过程。将所得的最大误差值收集起来，并格式化为六位有效数字。最终输出是这些误差值的列表，形式为单行文本。等距节点与 Chebyshev 节点的比较，以及增加多项式次数 $N-1$ 的效果，将直接说明数值分析中关于插值误差和龙格现象（Runge's phenomenon）的理论预测。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import BarycentricInterpolator\n\ndef t_prob(E_J, V0_J, a_m):\n    \"\"\"\n    Calculates the quantum tunneling transmission probability T(E).\n    All inputs must be in SI units.\n    \"\"\"\n    # Physical constants in SI units\n    hbar = 1.054571817e-34  # J*s\n    m_e = 9.1093837015e-31  # kg\n\n    # Ensure E_J is a numpy array for vectorized operations\n    E = np.atleast_1d(E_J).astype(float)\n    T = np.zeros_like(E)\n\n    # Define condition masks for the piecewise function\n    mask_zero = (E == 0)\n    mask_tunnel = (E > 0) & (E  V0_J)\n    mask_barrier_top = (E == V0_J)\n    mask_above_barrier = (E > V0_J)\n\n    # Case 1: T(0) = 0\n    T[mask_zero] = 0.0\n\n    # Case 2: 0  E  V0 (tunneling)\n    if np.any(mask_tunnel):\n        E_sub = E[mask_tunnel]\n        kappa = np.sqrt(2 * m_e * (V0_J - E_sub)) / hbar\n        sinh_term = np.sinh(kappa * a_m)\n        denom_term = (V0_J**2 * sinh_term**2) / (4 * E_sub * (V0_J - E_sub))\n        T[mask_tunnel] = 1.0 / (1.0 + denom_term)\n\n    # Case 3: E = V0\n    if np.any(mask_barrier_top):\n        denom_term = (m_e * V0_J * a_m**2) / (2 * hbar**2)\n        T[mask_barrier_top] = 1.0 / (1.0 + denom_term)\n\n    # Case 4: E > V0 (above-barrier transmission)\n    if np.any(mask_above_barrier):\n        E_sup = E[mask_above_barrier]\n        k2 = np.sqrt(2 * m_e * (E_sup - V0_J)) / hbar\n        sin_term = np.sin(k2 * a_m)\n        denom_term = (V0_J**2 * sin_term**2) / (4 * E_sup * (E_sup - V0_J))\n        T[mask_above_barrier] = 1.0 / (1.0 + denom_term)\n\n    # Return scalar if input was scalar\n    return T[0] if np.isscalar(E_J) else T\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    # Unit conversion factors\n    eV_to_J = 1.602176634e-19\n    nm_to_m = 1.0e-9\n\n    # Test cases from the problem statement\n    test_cases = [\n        # (V0_eV, a_nm, alpha, N, node_type)\n        (0.6, 1.0, 1.2, 11, \"equispaced\"),\n        (0.6, 1.0, 1.2, 11, \"Chebyshev\"),\n        (0.6, 1.0, 1.2, 41, \"equispaced\"),\n        (0.6, 1.0, 1.2, 41, \"Chebyshev\"),\n        (0.8, 2.0, 1.2, 21, \"equispaced\"),\n        (0.3, 0.3, 1.2, 21, \"equispaced\"),\n    ]\n\n    results = []\n    for V0_eV, a_nm, alpha, N, node_type in test_cases:\n        # Convert parameters to SI units\n        V0_J = V0_eV * eV_to_J\n        a_m = a_nm * nm_to_m\n\n        # Define the interpolation interval\n        E_max = alpha * V0_J\n\n        # Generate interpolation nodes based on type\n        if node_type == \"equispaced\":\n            x_nodes = np.linspace(0, E_max, N)\n        elif node_type == \"Chebyshev\":\n            # Chebyshev nodes of the first kind mapped to [0, E_max]\n            i = np.arange(N)\n            # The formula produces nodes in descending order, which is acceptable\n            cos_term = np.cos((2 * i + 1) * np.pi / (2 * N))\n            x_nodes = 0.5 * E_max * (1 + cos_term)\n        \n        # Compute exact function values at interpolation nodes\n        y_nodes = t_prob(x_nodes, V0_J, a_m)\n\n        # Construct the barycentric polynomial interpolant\n        poly_interpolant = BarycentricInterpolator(x_nodes, y_nodes)\n\n        # Create a fine grid for error evaluation\n        eval_grid = np.linspace(0, E_max, 1001)\n\n        # Evaluate the exact function and the interpolant on the grid\n        T_exact = t_prob(eval_grid, V0_J, a_m)\n        T_interp = poly_interpolant(eval_grid)\n        \n        # Find the maximum absolute error\n        max_error = np.max(np.abs(T_exact - T_interp))\n        \n        # Format result to six significant digits and store\n        results.append(\"{:.6g}\".format(max_error))\n\n    # Print the final list of errors in the required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2436011"}, {"introduction": "数值误差不仅仅是抽象的数字，它们可能导致与物理现实相悖的结论。本练习将探讨这一关键问题，要求你从模拟的实验数据（分箱数据）中重建一个概率密度函数（PDF）。你将使用在等距节点上的高阶多项式插值，并检验结果是否满足PDF的基本物理约束，即非负性和总概率为1。这项实践将直观地揭示龙格现象如何导致出现“负概率”等非物理结果，从而强调在科学计算中选择恰当数值方法的重要性。[@problem_id:2436095]", "problem": "您的任务是使用全局多项式插值从分箱直方图数据中重建一个概率密度函数（PDF），并评估该重建是否满足两个基本属性：在其支集上的非负性和归一化为1。本练习将插值误差和Runge现象与概率密度函数的物理约束联系起来。使用的基本依据是以下定义：概率密度函数（PDF）$f(x)$在其支集上对所有$x$都是非负的，并且其积分为$1$，即$\\int_{a}^{b} f(x)\\,dx = 1$；以及直方图是$f(x)$的分段常数近似，其区间平均值近似于$f(x)$在每个区间上的局部平均值。目标是理解当使用高次多项式时，插值误差，特别是通过Runge现象在等距节点上强调的振荡行为，会如何违反这些约束。\n\n从基本原理构建以下算法：\n1. 设分布的支集为一个闭区间$[a,b]$，并将其划分为$m$个等宽区间，其边界为$x_0=a, x_1, \\ldots, x_m=b$，区间宽度为$\\Delta x = (b-a)/m$。设区间中心为$c_i = (x_i + x_{i+1})/2$，其中$i=0,\\ldots,m-1$。\n2. 给定一个定义在$[a,b]$上的已知目标密度函数$f(x)$（以下每个案例都定义了$f(x)$并确保$\\int_a^b f(x)\\,dx = 1$），使用精确的数值积分计算每个区间的精确概率$p_i = \\int_{x_i}^{x_{i+1}} f(x)\\,dx$，然后计算区间平均密度$\\bar{f}_i = p_i / \\Delta x$。\n3. 构建一个$n$次全局多项式$P_n(x)$，使其在区间中心点上插值区间平均密度数据，即对所有$i$均有$P_n(c_i) = \\bar{f}_i$。使用等距的中心点$\\{c_i\\}$，而非任何特殊节点。\n4. 评估插值多项式是否满足两个PDF约束：\n   - 非负性：检查对于所有$x \\in [a,b]$，是否有$P_n(x) \\ge 0$在指定的容差$T_{\\mathrm{pos}}$范围内成立。这可实现为$ \\min_{x \\in \\mathcal{G}} P_n(x) \\ge -T_{\\mathrm{pos}}$，其中$\\mathcal{G}$是$[a,b]$上一个足够精细的均匀网格。\n   - 归一化：通过对多项式进行解析积分，精确计算$P_n(x)$在$[a,b]$上的积分，并检查$|\\int_a^b P_n(x)\\,dx - 1| \\le T_{\\mathrm{int}}$是否成立。\n5. 使用容差值$T_{\\mathrm{pos}} = 10^{-6}$和$T_{\\mathrm{int}} = 10^{-3}$，两者均为无量纲。\n\n使用以下三个案例组成的测试套件，它们共同探讨了一种理想情况、一种容易出现振荡的高次等距节点场景，以及一种边界集中的平滑密度：\n- 案例1（$[-1,1]$上的类Runge密度，多个区间）：设$f(x) = C_{\\mathrm{R}} \\, \\frac{1}{1 + 25 x^2}$在$[a,b]=[-1,1]$上，其中$C_{\\mathrm{R}}$的选择使得$\\int_{-1}^{1} f(x)\\,dx = 1$。精确积分为$\\int_{-1}^{1} \\frac{dx}{1+25x^2} = \\frac{2}{5}\\arctan(5)$；因此$C_{\\mathrm{R}} = \\frac{5}{2\\arctan(5)}$。使用$m=21$个区间，多项式次数为$n=20$。\n- 案例2（$[-3,3]$上的截断高斯分布，中等数量的区间）：设$f(x) = C_{\\mathrm{G}} \\exp\\!\\left(-\\frac{x^2}{2}\\right)$在$[a,b]=[-3,3]$上，其中$C_{\\mathrm{G}}$用于归一化在$[-3,3]$上的积分。精确积分为$\\int_{-3}^{3} \\exp\\!\\left(-\\frac{x^2}{2}\\right)\\,dx = \\sqrt{2\\pi}\\,\\mathrm{erf}\\!\\left(\\frac{3}{\\sqrt{2}}\\right)$，因此$C_{\\mathrm{G}} = \\left[\\sqrt{2\\pi}\\,\\mathrm{erf}\\!\\left(\\frac{3}{\\sqrt{2}}\\right)\\right]^{-1}$。使用$m=11$个区间，多项式次数为$n=10$。\n- 案例3（$[0,1]$上具有中等偏度的贝塔密度，少量区间）：设$f(x)= \\mathrm{BetaPDF}_{\\alpha,\\beta}(x)$在$[a,b]=[0,1]$上，其中$\\alpha=2$和$\\beta=5$，即$f(x) = C_{\\mathrm{B}}\\, x^{\\alpha-1}(1-x)^{\\beta-1}$，其中$C_{\\mathrm{B}} = \\frac{\\Gamma(\\alpha+\\beta)}{\\Gamma(\\alpha)\\Gamma(\\beta)} = \\frac{\\Gamma(7)}{\\Gamma(2)\\Gamma(5)} = 30$。使用$m=6$个区间，多项式次数为$n=5$。\n\n角度单位不适用。物理单位不适用。所有容差和误差均表示为无量纲量。\n\n程序要求：\n- 使用足够精确的确定性方法（例如，使用每个区间至少有$64$个节点的高斯-勒让德积分）为$p_i$实现数值积分。\n- 构建插值多项式$P_n(x)$，使其在等距区间中心点上与区间平均值完全匹配。\n- 在$[a,b]$内至少$20001$个点的均匀网格上评估非负性。\n- 通过解析反求导精确地积分多项式。\n- 对每个测试案例，生成两个布尔值：\n  - 第一个布尔值，如果$P_n(x)$在$[a,b]$上在容差$T_{\\mathrm{pos}}$内为非负，则为真，否则为假。\n  - 第二个布尔值，如果积分误差在$T_{\\mathrm{int}}$内，则为真，否则为假。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。聚合输出必须按顺序为案例1列出非负性布尔值和归一化布尔值，然后是案例2的相同对，再然后是案例3。例如，一个包含三个案例的输出可能看起来像“[True,False,True,True,False,True]”，其中每对按顺序对应一个案例。", "solution": "对所述问题进行验证。\n\n**第1步：提取已知条件**\n- **定义域与分箱：** 概率密度函数（PDF）的支集是一个闭区间$[a,b]$。该区间被划分为$m$个等宽区间，区间宽度为$\\Delta x = (b-a)/m$。区间边界为$x_i = a + i\\Delta x$，其中$i=0, \\ldots, m$，区间中心为$c_i = (x_i + x_{i+1})/2$，其中$i=0, \\ldots, m-1$。\n- **目标PDF与区间平均密度：** 每个案例都给出了一个目标PDF $f(x)$，其被归一化以满足$\\int_a^b f(x)\\,dx = 1$。精确的区间概率为$p_i = \\int_{x_i}^{x_{i+1}} f(x)\\,dx$，区间平均密度为$\\bar{f}_i = p_i / \\Delta x$。\n- **插值：** 构建一个$n$次全局多项式$P_n(x)$来插值区间中心点的区间平均密度数据，满足对所有$i=0, \\ldots, m-1$均有$P_n(c_i) = \\bar{f}_i$。次数被指定为$n=m-1$。\n- **约束与容差：**\n    - 非负性：$\\min_{x \\in \\mathcal{G}} P_n(x) \\ge -T_{\\mathrm{pos}}$，其中$\\mathcal{G}$是$[a,b]$上的一个均匀网格。容差$T_{\\mathrm{pos}} = 10^{-6}$。\n    - 归一化：$|\\int_a^b P_n(x)\\,dx - 1| \\le T_{\\mathrm{int}}$。容差$T_{\\mathrm{int}} = 10^{-3}$。\n- **测试案例：**\n    - **案例1：** 在$[a,b]=[-1,1]$上的$f(x) = C_{\\mathrm{R}} \\, \\frac{1}{1 + 25 x^2}$，其中$C_{\\mathrm{R}} = \\frac{5}{2\\arctan(5)}$。参数：$m=21$个区间，次数$n=20$。\n    - **案例2：** 在$[a,b]=[-3,3]$上的$f(x) = C_{\\mathrm{G}} \\exp(-\\frac{x^2}{2})$，其中$C_{\\mathrm{G}} = [\\sqrt{2\\pi}\\,\\mathrm{erf}(3/\\sqrt{2})]^{-1}$。参数：$m=11$个区间，次数$n=10$。\n    - **案例3：** 在$[a,b]=[0,1]$上的$f(x)= 30 x(1-x)^4$。这是一个参数为$\\alpha=2, \\beta=5$的贝塔分布PDF。参数：$m=6$个区间，次数$n=5$。\n- **实现要求：**\n    - $p_i$的积分方法：高斯-勒让德积分，每个区间至少64个节点。\n    - 插值多项式$P_n(x)$必须在区间中心点上与区间平均值完全匹配。\n    - 非负性检查网格：至少20001个点。\n    - 多项式积分：必须精确（解析）。\n    - 输出：对每个案例，输出一对关于非负性和归一化的布尔值。最终输出是这些布尔值的扁平化列表，格式为特定字符串。\n\n**第2步：问题陈述的验证**\n对问题的有效性进行审查。\n- **科学依据：** 该问题牢固地植根于数值分析的原理，特别是多项式插值和数值积分。将其应用于概率密度函数的物理约束是计算物理学中一个有效且富有启发性的练习。所涉及的数学概念——龙格现象、PDF的性质、多项式插值——都是标准的，并且描述正确。\n- **良定性：** 该问题是良定的。对于每个案例，都有$m$个不同的插值节点（区间中心$c_i$）和$m$个对应的值（$\\bar{f}_i$）。任务是找到一个$n=m-1$次的多项式，该多项式穿过这$m$个点。根据多项式插值基本定理，这样的多项式存在且唯一。\n- **客观性：** 问题使用精确、无歧义的数学语言陈述。所有参数和成功标准都得到了客观定义。\n- **完整性与一致性：** 问题提供了所有必要信息：函数、其定义域、归一化常数、区间数量、多项式次数，以及精确的容差和评估标准。这些规范是一致的。点数（$m$）和多项式次数（$n=m-1$）正确地定义了一个唯一的插值多项式。\n\n**第3步：结论与行动**\n问题陈述在科学上是合理的、良定的，并且是自洽的。没有发现可识别的缺陷。因此，该问题被判定为**有效**，我将继续构建解决方案。\n\n---\n\n目标是从概率密度函数的分箱表示中重建它，方法是使用一个全局插值多项式，并评估此重建是否保持了PDF的基本物理性质：非负性和单位归一化。该分析突出了高次多项式在等距节点上的插值会如何失败，这一失败集中体现在龙格现象中。该过程是系统性的。\n\n**第1步：生成插值数据**\n用于插值原始数据的不是特定点上的函数值，而是有限区间（分箱）上的平均值。对于一个划分为$m$个宽度为$\\Delta x = (b-a)/m$的区间的定义域$[a,b]$，第$i$个区间占据区间$[x_i, x_{i+1}]$，其中$x_i = a + i\\Delta x$。在区间中心$c_i = (x_i + x_{i+1})/2$处要插值的值是区间平均密度$\\bar{f}_i$。其计算方式如下：\n$$\n\\bar{f}_i = \\frac{1}{\\Delta x} p_i = \\frac{1}{\\Delta x} \\int_{x_i}^{x_{i+1}} f(x) \\, dx\n$$\n区间概率$p_i$的积分必须以高精度计算，以确保插值数据是可靠的。问题指定使用至少64个节点的高斯-勒让德积分。这是一种高阶方法，适用于所考虑的平滑函数，确保数值积分误差与正在研究的插值误差和模型误差相比可以忽略不计。\n\n**第2步：构建插值多项式**\n给定$m$个数据点集合$\\{(c_i, \\bar{f}_i)\\}_{i=0}^{m-1}$，我们寻求唯一的$n=m-1$次多项式$P_n(x)$，使其满足插值条件$P_n(c_i) = \\bar{f}_i$。我们可以用单项式基来表示这个多项式：\n$$\nP_n(x) = \\sum_{k=0}^{n} a_k x^k\n$$\n系数$\\{a_k\\}$由求解以下$m$个线性方程组确定：\n$$\n\\sum_{k=0}^{n} a_k c_i^k = \\bar{f}_i, \\quad \\text{for } i = 0, 1, \\ldots, n\n$$\n这是一个范德蒙（Vandermonde）线性系统，$\\mathbf{V}\\mathbf{a} = \\mathbf{\\bar{f}}$。虽然对于高次多项式而言，这在数值上可能很敏感，但对于指定的次数（$n=5, 10, 20$），标准的数值线性代数程序，如`numpy.polyfit`中封装的那些，可以稳健地确定系数$a_k$。\n\n**第3步：验证PDF性质**\n得到的多项式$P_n(x)$是PDF的一个候选。必须根据两个基本性质对其进行测试。\n\n首先，**非负性**：对于所有$x \\in [a,b]$，必须满足$P_n(x) \\ge 0$。众所周知，等距节点上的高次多项式插值在区间边界附近表现出振荡行为（龙格现象）。这些振荡可能导致多项式的值降到零以下，违反了概率论的一个核心原则。这通过在$[a,b]$内的一个密集网格$\\mathcal{G}$上评估$P_n(x)$，并验证其最小值不小于一个小的负容差来进行数值检查，即$\\min_{x \\in \\mathcal{G}} P_n(x) \\ge -T_{\\mathrm{pos}}$。\n\n其次，**归一化**：总概率必须为一，即$\\int_a^b P_n(x) \\, dx = 1$。多项式$P_n(x)$的积分可以解析计算，从而为模型得出一个精确值。$P_n(x)$的反导数是：\n$$\n\\int P_n(x) \\, dx = \\sum_{k=0}^{n} a_k \\frac{x^{k+1}}{k+1} + C\n$$\n因此，定积分为：\n$$\n\\int_a^b P_n(x) \\, dx = \\sum_{k=0}^{n} a_k \\left( \\frac{b^{k+1} - a^{k+1}}{k+1} \\right)\n$$\n然后将此计算出的积分与$1$进行比较，其绝对偏差必须在指定的容差$T_{\\mathrm{int}}$之内。\n\n**测试案例分析**\n- **案例1 (类Runge)：** 函数$f(x) \\propto 1/(1+25x^2)$是展示龙格现象的典型例子。对于$n=20$个等距节点，预计在$x=-1$和$x=1$附近会出现大的振荡。这些振荡几乎肯定会导致$P_{20}(x)$变为负值，从而无法通过非负性测试。由于边界处的近似效果差，归一化也可能失败。\n- **案例2 (截断高斯)：** 高斯函数异常平滑且衰减迅速。即使次数为$n=10$，插值多项式预计也会表现良好，因为函数值在$[-3,3]$的边界附近非常小，这减轻了龙格现象特有的边界振荡。非负性和归一化性质很可能都会得到保持。\n- **案例3 (贝塔密度)：** 目标函数$f(x)=30x(1-x)^4$本身就是一个5次多项式。我们正在用一个相同次数的$P_5(x)$多项式来插值由它派生的数据。尽管插值数据是区间平均值而不是点值，但得到的插值多项式预计将是真实函数的极好近似。可以预期，两个PDF性质都将轻松满足。\n\n提供的代码将为每个案例执行此协议。", "answer": "```python\nimport numpy as np\nfrom scipy import special\nfrom scipy.integrate import fixed_quad\n\ndef solve():\n    \"\"\"\n    Solves the problem of validating a polynomial PDF reconstruction for three test cases.\n    \"\"\"\n\n    def solve_case(f_target, a, b, m, T_pos, T_int):\n        \"\"\"\n        Processes a single test case according to the problem description.\n\n        Args:\n            f_target (callable): The target probability density function.\n            a (float): The lower bound of the support.\n            b (float): The upper bound of the support.\n            m (int): The number of bins.\n            T_pos (float): The tolerance for non-negativity.\n            T_int (float): The tolerance for normalization.\n\n        Returns:\n            tuple[bool, bool]: A pair of booleans indicating if the non-negativity\n                               and normalization constraints are met, respectively.\n        \"\"\"\n        n = m - 1  # Polynomial degree\n        delta_x = (b - a) / m\n        \n        # 1. Define bin edges and centers\n        bin_edges = np.linspace(a, b, m + 1)\n        bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2.0\n\n        # 2. Compute bin-averaged densities\n        f_bar = np.zeros(m)\n        quad_nodes = 64  # As per problem requirement\n        for i in range(m):\n            x_i, x_i_plus_1 = bin_edges[i], bin_edges[i+1]\n            \n            # Use high-order Gauss-Legendre quadrature for bin probability\n            p_i, _ = fixed_quad(f_target, x_i, x_i_plus_1, n=quad_nodes)\n            f_bar[i] = p_i / delta_x\n\n        # 3. Form the global interpolating polynomial\n        # np.polyfit with degree m-1 on m points gives the interpolating polynomial\n        poly_coeffs = np.polyfit(bin_centers, f_bar, n)\n\n        # 4. Assess PDF constraints\n        # 4.a Non-negativity check\n        grid_points = 20001 # As per problem requirement\n        x_grid = np.linspace(a, b, grid_points)\n        poly_values = np.polyval(poly_coeffs, x_grid)\n        \n        is_non_negative = np.min(poly_values) >= -T_pos\n\n        # 4.b Normalization check\n        # Integrate the polynomial analytically\n        integral_poly = np.polyint(poly_coeffs)\n        integral_value = np.polyval(integral_poly, b) - np.polyval(integral_poly, a)\n        \n        is_normalized = abs(integral_value - 1.0) = T_int\n\n        return is_non_negative, is_normalized\n\n    # Tolerances\n    T_pos = 1e-6\n    T_int = 1e-3\n\n    # --- Test Case 1: Runge-like density ---\n    C_R = 5.0 / (2.0 * np.arctan(5.0))\n    def f_runge(x):\n        return C_R / (1.0 + 25.0 * x**2)\n    case1_params = {'f_target': f_runge, 'a': -1.0, 'b': 1.0, 'm': 21}\n\n    # --- Test Case 2: Truncated Gaussian ---\n    norm_const = np.sqrt(2.0 * np.pi) * special.erf(3.0 / np.sqrt(2.0))\n    C_G = 1.0 / norm_const\n    def f_gauss(x):\n        return C_G * np.exp(-x**2 / 2.0)\n    case2_params = {'f_target': f_gauss, 'a': -3.0, 'b': 3.0, 'm': 11}\n    \n    # --- Test Case 3: Beta density ---\n    # Beta(alpha=2, beta=5) PDF is C_B * x^(alpha-1) * (1-x)^(beta-1)\n    # C_B = Gamma(alpha+beta) / (Gamma(alpha)*Gamma(beta))\n    # For alpha=2, beta=5, C_B = Gamma(7)/(Gamma(2)*Gamma(5)) = 6!/(1!*4!) = 720/24 = 30\n    def f_beta(x):\n        return 30.0 * x**1 * (1.0 - x)**4\n    case3_params = {'f_target': f_beta, 'a': 0.0, 'b': 1.0, 'm': 6}\n\n    test_cases = [case1_params, case2_params, case3_params]\n    \n    results = []\n    for case_params in test_cases:\n        res_pair = solve_case(**case_params, T_pos=T_pos, T_int=T_int)\n        results.extend(res_pair)\n\n    # Format the final output string\n    # Convert Python booleans to lowercase 'true'/'false' for JSON-like format\n    results_str = [str(r).lower() for r in results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "2436095"}]}