{"hands_on_practices": [{"introduction": "我们从一个基础练习开始，探索切比雪夫多项式近似不同类型函数的能力。本练习将使用一维像素数据作为理想化信号，来展示切比雪夫近似的一个关键优势：对于光滑函数的快速“谱”收敛特性，以及它在处理非光滑或高频振荡信号时的行为[@problem_id:2379175]。通过这个实践，你将建立起关于该方法为何以及何时特别有效的核心直觉。", "problem": "构建一个程序，该程序对于给定的像素强度一维序列，计算其在第一类切比雪夫多项式基上的展开，并量化截断级数的影响。设 $M$ 表示单行中的像素数量，像素索引为 $i \\in \\{0,1,\\dots,M-1\\}$。通过 $x_i = -1 + \\dfrac{2 i}{M-1}$（对所有 $i$）将像素位置映射到切比雪夫区间。设 $\\{T_k(x)\\}_{k \\ge 0}$ 表示在区间 $[-1,1]$ 上定义的第一类切比雪夫多项式，其递推关系为 $T_0(x) = 1$，$T_1(x) = x$ 以及 $T_{k+1}(x) = 2 x T_k(x) - T_{k-1}(x)$（对于 $k \\ge 1$）。对于给定的整数截断阶数 $N \\ge 0$，用多项式 $p_N(x) = \\sum_{k=0}^{N} c_k T_k(x)$ 来近似一个像素行，其系数 $\\{c_k\\}_{k=0}^{N}$ 使得离散平方误差 $\\sum_{i=0}^{M-1} \\left(p_N(x_i) - y_i\\right)^2$ 相对于给定的像素强度 $\\{y_i\\}_{i=0}^{M-1}$ 最小。通过均方根误差 (RMSE) 来量化近似质量，其定义为 $\\mathrm{RMSE}(N) = \\sqrt{\\dfrac{1}{M} \\sum_{i=0}^{M-1} \\left(p_N(x_i) - y_i\\right)^2}$。所有三角函数的参数都应理解为弧度。\n\n使用以下测试套件。在每个测试用例中，设 $M = 64$ 并如上定义 $x_i$。对每个测试用例，计算截断阶数 $N \\in \\{0,1,3,7,15,31\\}$ 时的 $\\mathrm{RMSE}(N)$。\n\n测试用例 $1$ (平滑，中低频内容):\n- 像素强度：对所有 $i$，$y_i = 0.5 + 0.4 \\cos(\\pi x_i) + 0.1 \\cos(5 \\pi x_i)$。\n\n测试用例 $2$ (阶跃边缘):\n- 像素强度：对所有 $i$，如果 $x_i < 0$，则 $y_i = 0.1$；如果 $x_i \\ge 0$，则 $y_i = 0.9$。\n\n测试用例 $3$ (高频振荡):\n- 像素强度：对所有 $i$，$y_i = 0.5 + 0.45 \\cos(15 \\pi x_i)$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其顺序和结构如下：一个长度为 $3$ 的外部列表，对应于上述顺序的三个测试用例，其中每个元素是一个长度为 $6$ 的内部列表，按 $N \\in \\{0,1,3,7,15,31\\}$ 的顺序包含 $6$ 个 $\\mathrm{RMSE}(N)$ 值。例如，格式必须严格形如 $[[r_{1,1},r_{1,2},r_{1,3},r_{1,4},r_{1,5},r_{1,6}],[r_{2,1},\\dots,r_{2,6}],[r_{3,1},\\dots,r_{3,6}]]$，其中每个 $r_{j,\\ell}$ 是一个实数。", "solution": "所述问题具有科学依据，是适定的、客观的。它构成了数值逼近理论中的一个标准问题，而数值逼近理论是计算物理学的一个基本组成部分。所有参数和目标都得到了足够严格的定义。因此，我们着手推导解决方案。\n\n目标是使用一个 $N$ 阶的截断切比雪夫级数来近似在点网格 $\\{x_i\\}_{i=0}^{M-1}$ 上定义的离散信号 $\\{y_i\\}_{i=0}^{M-1}$。该近似是一个多项式 $p_N(x) = \\sum_{k=0}^{N} c_k T_k(x)$，其中 $T_k(x)$ 是 $k$ 阶的第一类切比雪夫多项式。系数 $\\{c_k\\}_{k=0}^{N}$ 的选择必须使离散平方误差 $S$ 最小化：\n$$\nS = \\sum_{i=0}^{M-1} \\left(p_N(x_i) - y_i\\right)^2 = \\sum_{i=0}^{M-1} \\left(\\left(\\sum_{k=0}^{N} c_k T_k(x_i)\\right) - y_i\\right)^2\n$$\n这是一个经典的线性最小二乘问题。我们可以用矩阵-向量表示法来表达。设 $\\mathbf{y} \\in \\mathbb{R}^M$ 是像素强度的列向量，$\\mathbf{y} = [y_0, y_1, \\dots, y_{M-1}]^T$。设 $\\mathbf{c} \\in \\mathbb{R}^{N+1}$ 是未知系数的列向量，$\\mathbf{c} = [c_0, c_1, \\dots, c_N]^T$。我们定义一个矩阵 $\\mathbf{A} \\in \\mathbb{R}^{M \\times (N+1)}$，其元素由基函数在网格点上的值给出：\n$$\nA_{ik} = T_k(x_i) \\quad \\text{for } i \\in \\{0, \\dots, M-1\\}, k \\in \\{0, \\dots, N\\}\n$$\n在网格点上的近似值向量由矩阵-向量乘积 $\\mathbf{p}_N = \\mathbf{A}\\mathbf{c}$ 给出。平方误差之和 $S$ 是残差向量 $\\mathbf{r} = \\mathbf{A}\\mathbf{c} - \\mathbf{y}$ 的欧几里得范数的平方：\n$$\nS = \\|\\mathbf{A}\\mathbf{c} - \\mathbf{y}\\|_2^2\n$$\n最小化该量的系数向量 $\\mathbf{c}$ 是最小二乘解。它由法方程的解正式给出：\n$$\n(\\mathbf{A}^T \\mathbf{A}) \\mathbf{c} = \\mathbf{A}^T \\mathbf{y}\n$$\n为了数值稳定性，尤其是在 $\\mathbf{A}$ 的列向量近似线性相关时，不建议构造并求逆矩阵 $\\mathbf{A}^T \\mathbf{A}$。相反，应采用如 QR 分解或奇异值分解 (SVD) 等稳健的数值方法。标准数值库提供了实现这些稳定算法的求解器。\n\n指定的网格点 $x_i = -1 + \\frac{2i}{M-1}$ 是均匀分布的。它们不是切比雪夫节点（$T_M(x)$ 的根或极值点）。因此，基向量 $\\{ \\mathbf{v}_k \\}_{k=0}^N$（其中 $(\\mathbf{v}_k)_i = T_k(x_i)$）相对于标准点积并非正交。这就需要解一个一般的最小二乘系统，而不是简单地将数据投影到基向量上——如果基是正交的，后者是可行的。\n\n为每个测试用例计算所需均方根误差 (RMSE) 的算法如下：\n$1$. 设置像素数量 $M=64$。定义截断阶数集合 $N \\in \\{0, 1, 3, 7, 15, 31\\}$。\n$2$. 构建网格点向量 $\\mathbf{x} = [x_0, x_1, \\dots, x_{M-1}]^T$，其中 $x_i = -1 + \\frac{2i}{M-1}$。\n$3$. 对于每个测试用例，根据其指定函数生成像素强度向量 $\\mathbf{y} = [y_0, y_1, \\dots, y_{M-1}]^T$。\n$4$. 对于指定集合中的每个截断阶数 $N$：\n    a. 构建 $M \\times (N+1)$ 矩阵 $\\mathbf{A}$。$\\mathbf{A}$ 的列是在网格点上求值的切比雪夫多项式。它们使用以下递推关系生成：\n    $$\n    T_0(x) = 1\n    $$\n    $$\n    T_1(x) = x\n    $$\n    $$\n    T_{k+1}(x) = 2x T_k(x) - T_{k-1}(x) \\quad \\text{for } k \\ge 1\n    $$\n    $\\mathbf{A}$ 的第 $k$ 列是向量 $[T_k(x_0), T_k(x_1), \\dots, T_k(x_{M-1})]^T$。\n    b. 解线性最小二乘问题 $\\mathbf{A}\\mathbf{c} \\approx \\mathbf{y}$ 以找到最优系数向量 $\\mathbf{c}$。这将得到最小残差平方和 $S_{min} = \\|\\mathbf{A}\\mathbf{c} - \\mathbf{y}\\|_2^2$。\n    c. 使用均方根误差计算近似质量：\n    $$\n    \\mathrm{RMSE}(N) = \\sqrt{\\frac{1}{M} \\sum_{i=0}^{M-1} (p_N(x_i) - y_i)^2} = \\sqrt{\\frac{S_{min}}{M}}\n    $$\n$5$. 收集每个测试用例的 $\\mathrm{RMSE}(N)$ 值，并按规定格式化输出。\n\n预计在不同测试用例中，$\\mathrm{RMSE}(N)$ 的行为会有显著差异。对于测试用例 1 中的平滑低频函数，切比雪夫级数应非常快速地收敛，导致随着 $N$ 的增加 $\\mathrm{RMSE}(N)$ 迅速减小。对于测试用例 2 中的阶跃函数，不连续点的存在将导致 Gibbs 现象和慢收敛；$\\mathrm{RMSE}(N)$ 的减小速度会慢得多。对于测试用例 3 中的高频函数，当 $N$ 较小时近似效果会很差，但一旦 $N$ 大到足以解析振荡（即，当 $N$ 与由 $\\pi$ 缩放的余弦函数参数相当时），近似效果应会显著改善。现在将实施此过程。", "answer": "```python\nimport numpy as np\n\ndef build_chebyshev_matrix(x, n_degree):\n    \"\"\"\n    Constructs the design matrix A_ik = T_k(x_i) for k=0...n_degree.\n    \n    Args:\n        x (np.ndarray): Array of points of shape (M,).\n        n_degree (int): The maximum degree N of the Chebyshev polynomials.\n\n    Returns:\n        np.ndarray: The design matrix A of shape (M, N+1).\n    \"\"\"\n    m_pixels = len(x)\n    A = np.zeros((m_pixels, n_degree + 1))\n    \n    # T_0(x) = 1\n    A[:, 0] = 1.0\n    \n    if n_degree > 0:\n        # T_1(x) = x\n        A[:, 1] = x\n    \n    # T_{k+1}(x) = 2*x*T_k(x) - T_{k-1}(x)\n    for k in range(1, n_degree):\n        A[:, k + 1] = 2 * x * A[:, k] - A[:, k - 1]\n        \n    return A\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute RMSE values.\n    \"\"\"\n    M = 64\n    N_degrees = [0, 1, 3, 7, 15, 31]\n    \n    x = -1.0 + 2.0 * np.arange(M) / (M - 1.0)\n    \n    # Define test case functions\n    def case1_func(x_pts):\n        return 0.5 + 0.4 * np.cos(np.pi * x_pts) + 0.1 * np.cos(5 * np.pi * x_pts)\n        \n    def case2_func(x_pts):\n        y = np.full_like(x_pts, 0.9)\n        y[x_pts < 0] = 0.1\n        return y\n        \n    def case3_func(x_pts):\n        return 0.5 + 0.45 * np.cos(15 * np.pi * x_pts)\n\n    test_cases = [\n        case1_func,\n        case2_func,\n        case3_func\n    ]\n\n    all_results = []\n    \n    for case_func in test_cases:\n        y = case_func(x)\n        case_results = []\n        for N in N_degrees:\n            A = build_chebyshev_matrix(x, N)\n            \n            # Solve the least-squares problem.\n            # `lstsq` returns coefficients, residuals, rank, and singular values.\n            # The 'residuals' is a one-element array containing the sum of squared errors.\n            _coeffs, residuals, _rank, _s = np.linalg.lstsq(A, y, rcond=None)\n            \n            # If the system is full rank, `residuals` contains the sum of squared errors.\n            if residuals.size > 0:\n                sum_sq_res = residuals[0]\n            else:\n                # If no solution or system is rank deficient, calculate manually.\n                p_N = A @ _coeffs\n                sum_sq_res = np.sum((p_N - y)**2)\n\n            rmse = np.sqrt(sum_sq_res / M)\n            case_results.append(rmse)\n        \n        all_results.append(case_results)\n\n    # Format the final output string precisely as required, with no spaces.\n    outer_list_str = []\n    for res_list in all_results:\n      # Use a general format specifier to avoid trailing zeros and ensure precision.\n      inner_list_str = \",\".join(format(n, 'g') for n in res_list)\n      outer_list_str.append(f\"[{inner_list_str}]\")\n    final_output = f\"[{','.join(outer_list_str)}]\"\n\n    print(final_output)\n\nsolve()\n```", "id": "2379175"}, {"introduction": "接下来，我们将应用所学技能解决一个缺乏简单解析解的真实物理问题。我们将从普朗克定律出发，推导定义黑体辐射峰值波长的超越方程，然后利用切比雪夫多项式求根来确定维恩位移定律中的基本常数[@problem_id:2379178]。这个练习展示了如何将一个复杂的分析问题转化为一个可通过数值方法精确求解的计算问题。", "problem": "您将实现一个完整的程序，通过构建并求解一个 Chebyshev 多项式逼近，来模拟黑体辐射的峰值波长（记为 $\\lambda_{\\max}(T)$，单位为米）作为绝对温度 $T$（单位为开尔文）的函数。该 Chebyshev 多项式逼近的对象，是使光谱辐射率对波长最大化所产生的超越驻点条件的根。请仅从以下基础出发：黑体的 Planck 单位波长光谱辐射率，由下式给出\n$$\nB_{\\lambda}(\\lambda, T) = \\frac{2 h c^{2}}{\\lambda^{5}} \\cdot \\frac{1}{\\exp\\!\\left(\\frac{h c}{\\lambda k_{\\mathrm{B}} T}\\right) - 1},\n$$\n其中 $h$ 是 Planck 常数（单位为焦耳-秒），$c$ 是真空中的光速（单位为米/秒），$k_{\\mathrm{B}}$ 是 Boltzmann 常数（单位为焦耳/开尔文）。峰值波长 $\\lambda_{\\max}(T)$ 是在固定温度 $T$ 下使 $B_{\\lambda}(\\lambda, T)$ 最大化的 $\\lambda$ 值。\n\n您的任务是：\n- 从驻点条件 $\\frac{\\partial B_{\\lambda}}{\\partial \\lambda}(\\lambda, T) = 0$ 出发，并使用一个合适的正无量纲变量 $x$ 进行无量纲化，推导出一个关于 $x$ 的超越方程。该方程的唯一正根通过 $\\lambda_{\\max}(T) = \\frac{b}{T}$ 决定峰值波长，其中 $b$ 是一个仅依赖于基本常数和根 $x$ 的常数。\n- 在一个包含唯一正根的闭区间 $[x_{\\min}, x_{\\max}]$ 上，为该超越方程的左侧构造一个 $n$ 次的 Chebyshev 多项式逼近 $p_{n}(x)$。您必须使用 $[-1,1]$ 上的 Chebyshev 多项式，并通过仿射映射将其变换到 $[x_{\\min}, x_{\\max}]$ 上。选择一个多项式次数 $n \\geq 12$ 和一个与 Chebyshev 逼近一致的采样策略（例如，映射后的 Chebyshev 节点）。然后，通过求解 $p_{n}(x) = 0$ 来逼近根 $x^{\\star}$，并选择位于 $[x_{\\min}, x_{\\max}]$ 内具有物理意义的实根。\n- 使用得到的近似根 $x^{\\star}$，计算常数 $b$，然后为每个测试温度计算 $\\lambda_{\\max}(T)$。\n\n物理单位和角度规定：\n- 所有波长必须以米表示。\n- 所有温度均为开尔文。\n- 本任务不涉及角度。\n\n测试组：\n- 使用以下温度（开尔文）：$[\\,2.7255,\\;300.0,\\;1000.0,\\;3000.0,\\;5772.0,\\;10000.0\\,]$。\n- 对列表中的每个温度 $T$，计算 $\\lambda_{\\max}(T)$（单位为米）。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。列表中的每个值都是以米为单位的波长，并格式化为具有 $12$ 位有效数字的科学记数法。例如：$\\texttt{[1.23456789012e-03,2.34567890123e-04,...]}$。\n- 最终输出必须与测试组温度的顺序相同。\n\n您的解决方案必须是一个单一、自包含、可运行的程序，该程序执行推导的计算部分，构建 Chebyshev 逼近，求解近似根，并以指定格式打印最终列表。不允许用户输入。所有常数必须在程序中使用国际单位制（SI）的国际公认值进行定义。", "solution": "所述问题是有效的。它在科学上基于量子力学和统计物理学的原理，特别是 Planck 的黑体辐射定律。该问题定义明确、客观，并提供了一条清晰、可形式化的路径，以使用计算物理学中的标准数值方法获得唯一解。问题陈述中没有矛盾、歧义或事实不准确之处。因此，我们可以着手求解。\n\n目标是确定黑体在给定绝对温度 $T$ 下的峰值发射波长 $\\lambda_{\\max}(T)$。此波长使 Planck 光谱辐射率函数 $B_{\\lambda}(\\lambda, T)$ 达到最大值。出发点是所提供的 $B_{\\lambda}(\\lambda, T)$ 表达式：\n$$\nB_{\\lambda}(\\lambda, T) = \\frac{2 h c^{2}}{\\lambda^{5}} \\cdot \\frac{1}{\\exp\\left(\\frac{h c}{\\lambda k_{\\mathrm{B}} T}\\right) - 1}\n$$\n其中 $h$ 是 Planck 常数，$c$ 是光速，$k_{\\mathrm{B}}$ 是 Boltzmann 常数。\n\n为求最大值，我们必须求解驻点条件 $\\frac{\\partial B_{\\lambda}}{\\partial \\lambda} = 0$。为方便起见，我们定义一个常数 $A = 2hc^2$ 和一个无量纲变量 $x = \\frac{hc}{\\lambda k_{\\mathrm{B}} T}$。辐射率函数可写作：\n$$\nB_{\\lambda}(\\lambda, T) = A \\lambda^{-5} \\left(e^{x} - 1\\right)^{-1}\n$$\n我们对 $\\lambda$ 应用乘积法则求导。注意 $x$ 是 $\\lambda$ 的函数。\n$$\n\\frac{\\partial B_{\\lambda}}{\\partial \\lambda} = A \\left[ \\left(\\frac{d}{d\\lambda}\\lambda^{-5}\\right) \\left(e^{x} - 1\\right)^{-1} + \\lambda^{-5} \\left(\\frac{d}{d\\lambda}\\left(e^{x} - 1\\right)^{-1}\\right) \\right] = 0\n$$\n各自的导数为：\n$$\n\\frac{d}{d\\lambda}\\lambda^{-5} = -5\\lambda^{-6}\n$$\n$$\n\\frac{d}{d\\lambda}\\left(e^{x} - 1\\right)^{-1} = -1 \\left(e^{x} - 1\\right)^{-2} e^{x} \\frac{dx}{d\\lambda}\n$$\n$x$ 对 $\\lambda$ 的导数为：\n$$\n\\frac{dx}{d\\lambda} = \\frac{d}{d\\lambda} \\left(\\frac{hc}{\\lambda k_{\\mathrm{B}} T}\\right) = \\frac{hc}{k_{\\mathrm{B}} T} \\left(-\\frac{1}{\\lambda^2}\\right) = -\\frac{x}{\\lambda}\n$$\n将此代回，我们得到：\n$$\n\\frac{d}{d\\lambda}\\left(e^{x} - 1\\right)^{-1} = - \\left(e^{x} - 1\\right)^{-2} e^{x} \\left(-\\frac{x}{\\lambda}\\right) = \\frac{x e^{x}}{\\lambda (e^{x} - 1)^2}\n$$\n现在我们整理驻点条件：\n$$\nA \\left[ -5\\lambda^{-6} \\left(e^{x} - 1\\right)^{-1} + \\lambda^{-5} \\frac{x e^{x}}{\\lambda (e^{x} - 1)^2} \\right] = 0\n$$\n将整个方程乘以非零因子 $\\frac{\\lambda^6 (e^x - 1)^2}{A}$ 可简化表达式：\n$$\n-5(e^x - 1) + \\lambda \\frac{x e^x}{\\lambda} = 0\n$$\n$$\n-5e^x + 5 + x e^x = 0\n$$\n这可以重写为我们必须求解的关于 $x$ 的超越方程的最终形式：\n$$\nf(x) = (x-5)e^x + 5 = 0\n$$\n该方程的根，我们称其为 $x^{\\star}$，决定了 $\\lambda_{\\max}$ 和 $T$ 之间的关系。根据 $x$ 的定义，我们有 $\\lambda_{\\max} = \\frac{hc}{x^{\\star} k_{\\mathrm{B}} T}$。这正是 Wien 位移定律，$\\lambda_{\\max}(T) = \\frac{b}{T}$，其中常数 $b$ 由 $b = \\frac{hc}{x^{\\star} k_{\\mathrm{B}}}$ 给出。\n\n为找到 $x^{\\star}$，我们首先确定根的位置。在简单的整数点上计算函数 $f(x)$ 的值：\n$f(4) = (4-5)e^4 + 5 = -e^4 + 5 \\approx -54.6 + 5 < 0$。\n$f(5) = (5-5)e^5 + 5 = 5 > 0$。\n其导数为 $f'(x) = e^x + (x-5)e^x = (x-4)e^x$。对于 $x > 4$，$f'(x) > 0$，因此函数在区间 $[4, 5]$ 上是连续且严格递增的。这保证了在该区间内存在唯一的根。因此，我们选择 $[x_{\\min}, x_{\\max}] = [4, 5]$ 作为逼近域。\n\n遵循问题要求，我们在区间 $[4, 5]$ 上为函数 $f(x)$ 构建一个 Chebyshev 多项式逼近 $p_n(x)$。我们选择次数 $n = 20$，这大于所要求的最小值 $n=12$。该逼近是通过插值构建的。具体来说，我们在区间 $[4, 5]$ 上的 $N = n+1 = 21$ 个第一类 Chebyshev 节点上计算 $f(x)$ 的值。这些节点 $x_k$ 是通过从 $[-1, 1]$ 上的规范节点 $z_k$ 进行仿射映射得到的：\n$$\nz_k = \\cos\\left(\\frac{2k+1}{2N}\\pi\\right), \\quad k = 0, 1, \\dots, n\n$$\n$$\nx_k = \\frac{x_{\\max} - x_{\\min}}{2} z_k + \\frac{x_{\\max} + x_{\\min}}{2} = 0.5 z_k + 4.5\n$$\nChebyshev 插值多项式 $p_n(x)$ 是次数至多为 $n$ 的唯一多项式，它满足对所有 $k=0, \\dots, n$ 都有 $p_n(x_k) = f(x_k)$。现代数值库提供了稳健的例程来计算此多项式的系数。然后通过求解多项式方程 $p_n(x) = 0$ 来找到近似根 $x^{\\star}$。这是一个标准的代数过程。从所得的根中，我们选择位于我们所选区间 $[4, 5]$ 内的实根。\n\n利用数值方法得到的高精度 $x^{\\star}$ 值，我们计算 Wien 常数：\n$$\nb = \\frac{hc}{x^{\\star} k_{\\mathrm{B}}}\n$$\n使用物理常数 $h$、$c$ 和 $k_{\\mathrm{B}}$ 的 2018 年 CODATA 值。最后，对于测试组 $[\\,2.7255,\\;300.0,\\;1000.0,\\;3000.0,\\;5772.0,\\;10000.0\\,]$ 中的每个温度 $T$，我们计算峰值波长：\n$$\n\\lambda_{\\max}(T) = \\frac{b}{T}\n$$\n程序实现将通过计算来完成这些步骤。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the peak wavelength of black-body radiation using a Chebyshev approximation.\n\n    The method involves:\n    1. Defining the transcendental equation derived from Planck's law's stationarity condition.\n    2. Constructing a Chebyshev polynomial approximation of the function in this equation.\n    3. Finding the relevant root of the polynomial to approximate the true root x_star.\n    4. Using x_star to compute Wien's displacement constant, b.\n    5. Calculating the peak wavelength lambda_max = b/T for a set of test temperatures.\n    \"\"\"\n\n    # Physical constants (2018 CODATA values, SI units)\n    # h: Planck's constant in J·s\n    # c: Speed of light in vacuum in m/s\n    # k_B: Boltzmann constant in J/K\n    h = 6.62607015e-34\n    c = 299792458.0\n    k_B = 1.380649e-23\n\n    # Test suite temperatures in Kelvin\n    temperatures = np.array([2.7255, 300.0, 1000.0, 3000.0, 5772.0, 10000.0])\n\n    # Transcendental function f(x) = (x-5)exp(x) + 5, whose root we need to find.\n    def f(x):\n        return (x - 5.0) * np.exp(x) + 5.0\n\n    # Step 1: Set up Chebyshev approximation\n    # Degree of the polynomial (n >= 12)\n    degree = 20\n    # Interval [xmin, xmax] known to contain the root\n    xmin, xmax = 4.0, 5.0\n    \n    # Step 2: Construct the Chebyshev polynomial interpolant\n    # We interpolate f(x) at the Chebyshev nodes of the first kind.\n    # We need degree + 1 points to define a polynomial of degree `degree`.\n    num_points = degree + 1\n    \n    # Generate Chebyshev nodes of the first kind in the canonical interval [-1, 1]\n    # These are the roots of the Chebyshev polynomial T_{num_points}(z).\n    z_nodes = np.cos(np.pi * (2 * np.arange(num_points) + 1) / (2 * num_points))\n    \n    # Map nodes to the approximation interval [xmin, xmax]\n    x_nodes = (xmax - xmin) / 2.0 * z_nodes + (xmax + xmin) / 2.0\n    \n    # Evaluate the function at these nodes\n    y_values = f(x_nodes)\n    \n    # Use numpy's Chebyshev.fit to create the polynomial approximation.\n    # The `domain` parameter correctly maps the problem domain to the canonical window [-1, 1].\n    p_cheb = np.polynomial.chebyshev.Chebyshev.fit(x_nodes, y_values, degree, domain=[xmin, xmax])\n\n    # Step 3: Find the approximate root x_star\n    # Find all roots of the polynomial approximation.\n    roots = p_cheb.roots()\n    \n    # Filter the roots to find the unique real root within our interval [xmin, xmax].\n    x_star = None\n    for r in roots:\n        # We are only interested in real roots.\n        if np.isreal(r):\n            real_r = np.real(r)\n            # Check if the root is within the physically meaningful interval.\n            if xmin <= real_r <= xmax:\n                x_star = real_r\n                break\n    \n    if x_star is None:\n        # This guard is for robustness; with a good approximation, a root must be found.\n        raise RuntimeError(\"Could not find the root in the specified interval.\")\n\n    # Step 4: Compute Wien's displacement constant, b\n    b = (h * c) / (x_star * k_B)\n    \n    # Step 5: Compute lambda_max for each temperature in the test suite\n    results = []\n    for T in temperatures:\n        lambda_max = b / T\n        results.append(lambda_max)\n    \n    # Final print statement in the exact required format.\n    # Format each result to scientific notation with 12 significant digits.\n    # The format code \"{:.11e}\" provides 1 digit before the decimal point and 11 after.\n    formatted_results = [f\"{val:.11e}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2379178"}, {"introduction": "最后的练习将介绍切比雪夫多项式在计算物理中的一个高级应用：求解微分方程。我们将实现一个谱多区域方法（spectral multi-domain method）来求解一个在物理学和工程学中常见的边值问题 $u''(x)=f(x)$ [@problem_id:2379161]。这个实践让你一窥以高精度著称的谱方法的世界，为你解决更复杂的物理模型打下基础。", "problem": "考虑在区间 $[-2,2]$ 上的标量场 $u(x)$ 的边值问题，该问题由二阶常微分方程 $u''(x)=f(x)$ 以及边界条件 $u(-2)=\\alpha$ 和 $u(2)=\\beta$ 定义。计算域被分解为两个不重叠的子区间 $[-2,0]$ 和 $[0,2]$。在每个子区间上，未知场由一个最高次数为 $n$ 的多项式表示；记为在 $[-2,0]$ 上的 $p_{-}(x)$ 和在 $[0,2]$ 上的 $p_{+}(x)$。必须满足以下离散条件：\n\n- 在每个子区间 $[a,b]$上，将在 $[-1,1]$ 上的 Chebyshev–Gauss–Lobatto 节点 $t_j=\\cos\\left(\\dfrac{\\pi j}{n}\\right)$（其中 $j=0,1,\\dots,n$）仿射映射到 $x$ 节点 $x_j=\\dfrac{a+b}{2}+\\dfrac{b-a}{2}\\,t_j$。对于每个子区间上的所有内部节点（即所有 $j=1,2,\\dots,n-1$ 的 $x_j$），强形式残差必须为零：$p_{\\pm}''(x_j)=f(x_j)$。\n- 必须在物理端点上满足边界条件：$p_{-}(-2)=\\alpha$ 和 $p_{+}(2)=\\beta$。\n- 在 $x=0$ 的界面上，要求场及其一阶导数都连续：$p_{-}(0)=p_{+}(0)$ 和 $p_{-}'(0)=p_{+}'(0)$。\n\n对于下面的每个测试用例，都存在一个由给定的 $f(x)$、$\\alpha$ 和 $\\beta$ 确定的唯一精确解 $u_{\\text{exact}}(x)$。对于给定的次数 $n$，确定满足上述所有离散条件的多项式对 $(p_{-},p_{+})$，然后评估最大绝对误差\n$$\nE=\\max_{x\\in\\mathcal{G}}\\left|p(x)-u_{\\text{exact}}(x)\\right|,\n$$\n其中，当 $x\\in[-2,0)$ 时，$p(x)=p_{-}(x)$；当 $x\\in(0,2]$ 时，$p(x)=p_{+}(x)$；在 $x=0$ 处可使用任意一侧的值（条件已强制两者相等）。评估网格 $\\mathcal{G}$ 是在 $[-2,2]$ 上的 $1001$ 个等距点的集合。每个测试用例的输出必须是一个等于 $E$ 的实数，并四舍五入到八位小数。\n\n测试套件（每个测试由 $(f,\\alpha,\\beta,n)$ 及相应的精确解 $u_{\\text{exact}}$ 指定）：\n\n- 测试 $1$：$f(x)=1$，$\\alpha=0$，$\\beta=0$， $n=10$。精确解为 $u_{\\text{exact}}(x)=\\dfrac{1}{2}x^{2}-2$。\n- 测试 $2$：$f(x)=\\sin(\\pi x)$，$\\alpha=0$，$\\beta=0$， $n=12$。精确解为 $u_{\\text{exact}}(x)=-\\dfrac{\\sin(\\pi x)}{\\pi^{2}}$。\n- 测试 $3$：$f(x)=e^{x}$，$\\alpha=e^{-2}$，$\\beta=e^{2}$，$n=14$。精确解为 $u_{\\text{exact}}(x)=e^{x}$。\n- 测试 $4$：$f(x)=\\begin{cases}-1, & x < 0 \\\\ 1, & x > 0 \\\\ 0, & x = 0\\end{cases}$，$\\alpha=0$，$\\beta=0$，$n=24$。精确解为\n$$\nu_{\\text{exact}}(x) = \\begin{cases} -\\dfrac{1}{2}x^2 - x, & x \\le 0 \\\\ \\dfrac{1}{2}x^2 - x, & x \\ge 0 \\end{cases}\n$$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的列表，该列表按上述顺序包含测试 1 到测试 4 的四个误差，例如 $\\left[\\text{result}_{1},\\text{result}_{2},\\text{result}_{3},\\text{result}_{4}\\right]$，其中每个 $\\text{result}_{k}$ 都四舍五入到八位小数。", "solution": "所给问题是一个以两点边值问题形式出现的二阶常微分方程(ODE)，将使用多域谱配置法进行求解。\n\n### 步骤 1：提取已知条件\n- **微分方程：**  在区间 $[-2, 2]$ 上为 $u''(x) = f(x)$。\n- **边界条件：** $u(-2) = \\alpha$, $u(2) = \\beta$。\n- **区域分解：** 域被划分为两个不重叠的子区间： $I_{-} = [-2, 0]$ 和 $I_{+} = [0, 2]$。\n- **解的拟设：** 解 $u(x)$ 由一对多项式近似，即在 $I_{-}$ 上的 $p_{-}(x)$ 和在 $I_{+}$ 上的 $p_{+}(x)$，每个多项式的次数最高为 $n$。\n- **配置条件：**\n    1.  在每个子区间的内部 Chebyshev-Gauss-Lobatto (CGL) 节点上必须满足常微分方程。$[-1, 1]$ 上的 CGL 节点为 $t_j = \\cos(\\frac{\\pi j}{n})$，其中 $j = 0, \\dots, n$。对于区间 $[a, b]$，这些节点被映射为 $x_j = \\frac{a+b}{2} + \\frac{b-a}{2} t_j$。条件为 $p_{\\pm}''(x_j) = f(x_j)$，其中 $j = 1, \\dots, n-1$。\n    2.  必须满足物理边界条件：$p_{-}(-2) = \\alpha$ 和 $p_{+}(2) = \\beta$。\n    3.  在界面 $x=0$ 处施加连续性条件：$p_{-}(0) = p_{+}(0)$ 和 $p_{-}'(0) = p_{+}'(0)$。\n- **误差评估：** 将在 $[-2, 2]$ 上的 $1001$ 个等距点构成的网格 $\\mathcal{G}$ 上计算最大绝对误差 $E = \\max_{x\\in\\mathcal{G}}\\left|p(x)-u_{\\text{exact}}(x)\\right|$。\n- **测试用例：** 提供了四个测试用例，指定了 $f(x)$, $\\alpha$, $\\beta$, $n$ 以及精确解 $u_{\\text{exact}}(x)$。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题是谱方法的一个标准应用，具体来说是使用区域分解技术（谱多域方法）来求解一个线性二阶常微分方程。\n- **科学依据：** 该方法在数值分析和计算科学中是成熟的。所有原理都基于标准的微积分和线性代数。为所有测试用例提供的精确解都正确满足给定的常微分方程和边界条件。该问题在事实上是可靠的。\n- **适定性：** 该问题为两个多项式的 $2(n+1)$ 个自由度（系数）指定了 $2(n+1)$ 个约束条件。方程的数量与未知数的数量相匹配。这种谱配置方法的设置通常会产生一个非奇异的线性系统，从而确保存在唯一解。该问题是适定的。\n- **客观性：** 该问题使用精确的数学语言表述，没有歧义或主观论断。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。它是自洽的、科学上可靠的、适定的且客观的。将构建一个解。\n\n### 解的推导\n该问题将通过为多项式 $p_{-}(x)$ 和 $p_{+}(x)$ 在其各自子域内的 CGL 节点上的值构建并求解一个线性方程组来解决。\n\n**1. 离散化与节点表示**\n设 $[-1, 1]$ 上的标准 CGL 节点为 $t_j = \\cos(\\frac{\\pi j}{n})$，其中 $j=0, \\dots, n$。这些节点从 $1$ 递减排列到 $-1$。\n\n对于子域 $I_{-} = [-2, 0]$，仿射映射为 $x = -1 + t$。节点为 $x_j^{-} = -1 + t_j$。注意 $x_0^{-} = 0$ 且 $x_n^{-} = -2$。\n对于子域 $I_{+} = [0, 2]$，仿射映射为 $x = 1 + t$。节点为 $x_j^{+} = 1 + t_j$。注意 $x_0^{+} = 2$ 且 $x_n^{+} = 0$。\n\n未知解由其在这些节点上的值的两个向量表示：\n- $\\vec{u}_{-} = [p_{-}(x_0^{-}), \\dots, p_{-}(x_n^{-})]^T$\n- $\\vec{u}_{+} = [p_{+}(x_0^{+}), \\dots, p_{+}(x_n^{+})]^T$\n\n未知数的总数为 $2(n+1)$。\n\n**2. Chebyshev 微分矩阵**\n一个由其在 CGL 节点上的值表示的多项式，其导数可以通过将其节点值向量乘以一个微分矩阵来求得。设 $D_n$ 是 $[-1,1]$ 上节点 $t_j$ 的一阶 Chebyshev 微分矩阵。二阶微分矩阵为 $D_n^{(2)} = (D_n)^2$。\n\n对于定义在 $[a, b]$ 上的函数 $g(x)$，其关于 $x$ 的导数通过链式法则与关于标准变量 $t \\in [-1, 1]$ 的导数相关联：$\\frac{d}{dx} = \\frac{2}{b-a} \\frac{d}{dt}$ 和 $\\frac{d^2}{dx^2} = \\left(\\frac{2}{b-a}\\right)^2 \\frac{d^2}{dt^2}$。对于子域 $[-2, 0]$ 和 $[0, 2]$，区间长度均为 $b-a = 2$。缩放因子 $\\frac{2}{b-a}$ 为 $1$。因此，两个子域的微分矩阵就是 $D_n$ 和 $D_n^{(2)}$。\n\n**3. 组装线性系统**\n我们为组合向量 $\\mathbf{U} = [\\vec{u}_{-}^T, \\vec{u}_{+}^T]^T$ 中的 $2(n+1)$ 个未知数建立一个包含 $2(n+1)$ 个方程的线性系统。\n\n方程如下：\n- **在 $I_{-}$ 上的常微分方程：** 对于 $n-1$ 个内部节点（$j=1, \\dots, n-1$），必须满足常微分方程：\n  $$ (D_n^{(2)} \\vec{u}_{-})_j = f(x_j^{-}) $$\n  这构成了 $n-1$ 个仅涉及 $\\vec{u}_{-}$ 元素的线性方程。\n\n- **在 $I_{+}$ 上的常微分方程：** 类似地，对于右子域上的 $n-1$ 个内部节点：\n  $$ (D_n^{(2)} \\vec{u}_{+})_j = f(x_j^{+}) $$\n  这给出了另外 $n-1$ 个仅涉及 $\\vec{u}_{+}$ 元素的方程。\n\n- **物理边界条件：**\n  - 在 $x=-2$ 处：这是左子域上的节点 $x_n^{-}$。条件 $p_{-}(-2) = \\alpha$ 变为：\n    $$ u_{-}^{(n)} = \\alpha $$\n  - 在 $x=2$ 处：这是右子域上的节点 $x_0^{+}$。条件 $p_{+}(2) = \\beta$ 变为：\n    $$ u_{+}^{(0)} = \\beta $$\n\n- **在 $x=0$ 处的界面条件：**\n  - 点 $x=0$ 对应于左边的节点 $x_0^{-}$ 和右边的节点 $x_n^{+}$。\n  - 场的连续性，$p_{-}(0) = p_{+}(0)$，意味着：\n    $$ u_{-}^{(0)} = u_{+}^{(n)} $$\n  - 一阶导数的连续性，$p_{-}'(0) = p_{+}'(0)$，使用一阶微分矩阵 $D_n$ 表示：\n    $$ (D_n \\vec{u}_{-})_0 = (D_n \\vec{u}_{+})_n $$\n    展开为：\n    $$ \\sum_{k=0}^{n} (D_n)_{0k} u_{-}^{(k)} = \\sum_{k=0}^{n} (D_n)_{nk} u_{+}^{(k)} $$\n\n这 $2(n-1) + 2 + 2 = 2(n+1)$ 个方程构成一个线性系统 $A\\mathbf{U} = \\mathbf{B}$，可以解出未知向量 $\\mathbf{U}$。\n\n**4. 插值与误差计算**\n一旦求得节点值 $\\vec{u}_{-}$ 和 $\\vec{u}_{+}$，就可以在每个子域内的任意点上使用重心拉格朗日插值（barycentric Lagrange interpolation）来评估解，该方法对于 Chebyshev 节点是数值稳定的且高效的。\n\n对于标准区间 $[-1, 1]$ 中的一组评估点 $\\xi$，插值由下式给出：\n$$ P(\\xi) = \\frac{\\sum_{j=0}^{n} \\frac{w_j}{\\xi - t_j} v_j}{\\sum_{j=0}^{n} \\frac{w_j}{\\xi - t_j}} $$\n其中 $v_j$ 是在节点 $t_j = \\cos(\\frac{\\pi j}{n})$ 处的函数值，重心权重（barycentric weights）为 $w_j = (-1)^j \\delta_j$，其中 $\\delta_0 = \\delta_n = 1/2$ 且对于 $j=1, \\dots, n-1$，$\\delta_j = 1$。\n\n要在精细网格 $\\mathcal{G}$ 上评估数值解 $p(x)$，将 $[-2, 0]$ 中的点通过 $t = x+1$ 映射到 $[-1, 1]$ 并使用 $\\vec{u}_{-}$ 进行插值。将 $(0, 2]$ 中的点通过 $t = x-1$ 映射并使用 $\\vec{u}_{+}$ 进行插值。在网格 $\\mathcal{G}$ 上，插值解 $p(x)$ 与精确解 $u_{\\text{exact}}(x)$ 之间的最大绝对差值即为误差 $E$。", "answer": "```python\nimport numpy as np\n\ndef chebyshev_diff_matrix(n):\n    \"\"\"\n    Constructs the Chebyshev differentiation matrix for n+1 CGL nodes.\n    \"\"\"\n    if n == 0:\n        return np.zeros((1, 1))\n    \n    t = np.cos(np.pi * np.arange(n + 1) / n)\n    t = t.reshape(-1, 1)\n    \n    # Off-diagonal entries\n    c = np.ones(n + 1)\n    c[0] = 2.0\n    c[n] = 2.0\n    c_inv = 1.0 / c\n    \n    d_matrix = c[:, None] * c_inv[None, :] * (-1.0)**(np.arange(n + 1)[:, None] + np.arange(n + 1)[None, :])\n    \n    t_diff = t - t.T\n    np.fill_diagonal(t_diff, 1.0) # Avoid division by zero\n    \n    d_matrix /= t_diff\n    np.fill_diagonal(d_matrix, 0.0)\n    \n    # Diagonal entries\n    row_sums = np.sum(d_matrix, axis=1)\n    np.fill_diagonal(d_matrix, -row_sums)\n    \n    return d_matrix\n\ndef barycentric_interpolate(eval_pts, node_pts, node_vals):\n    \"\"\"\n    Performs barycentric Lagrange interpolation on Chebyshev nodes.\n    \n    eval_pts: Points to evaluate the interpolant at (in [-1, 1]).\n    node_pts: Chebyshev nodes t_j (in [-1, 1]).\n    node_vals: Function values at the nodes.\n    \"\"\"\n    n = len(node_pts) - 1\n    \n    # Barycentric weights for CGL nodes\n    weights = (-1.0)**np.arange(n + 1)\n    weights[0] *= 0.5\n    weights[n] *= 0.5\n    \n    numer = np.zeros_like(eval_pts, dtype=float)\n    denom = np.zeros_like(eval_pts, dtype=float)\n    interpolated_vals = np.full_like(eval_pts, np.nan, dtype=float)\n    \n    for j in range(n + 1):\n        # Find points that are very close to a node to avoid division by zero\n        is_node = np.isclose(eval_pts, node_pts[j])\n        interpolated_vals[is_node] = node_vals[j]\n        \n        not_node = ~is_node\n        if np.any(not_node):\n            term = weights[j] / (eval_pts[not_node] - node_pts[j])\n            numer[not_node] += term * node_vals[j]\n            denom[not_node] += term\n\n    valid_mask = np.isnan(interpolated_vals)\n    # Avoid division by zero in denom\n    denom_is_zero = np.isclose(denom, 0.0)\n    if np.any(denom_is_zero & valid_mask):\n         # This can happen if eval_pts is a node, handled above.\n         # Or if weights and points conspire to cancel, should be rare.\n         interpolated_vals[denom_is_zero & valid_mask] = 0.0\n\n    safe_denom_mask = ~denom_is_zero & valid_mask\n    interpolated_vals[safe_denom_mask] = numer[safe_denom_mask] / denom[safe_denom_mask]\n    \n    return interpolated_vals\n\ndef solve():\n    test_cases = [\n        {\n            \"f\": lambda x: 1.0, \"alpha\": 0.0, \"beta\": 0.0, \"n\": 10,\n            \"u_exact\": lambda x: 0.5 * x**2 - 2.0\n        },\n        {\n            \"f\": lambda x: np.sin(np.pi * x), \"alpha\": 0.0, \"beta\": 0.0, \"n\": 12,\n            \"u_exact\": lambda x: -np.sin(np.pi * x) / np.pi**2\n        },\n        {\n            \"f\": lambda x: np.exp(x), \"alpha\": np.exp(-2.0), \"beta\": np.exp(2.0), \"n\": 14,\n            \"u_exact\": lambda x: np.exp(x)\n        },\n        {\n            \"f\": lambda x: np.sign(x), \"alpha\": 0.0, \"beta\": 0.0, \"n\": 24,\n            \"u_exact\": lambda x: np.piecewise(x, [x <= 0, x > 0],\n                                             [lambda y: -0.5 * y**2 - y,\n                                              lambda y: 0.5 * y**2 - y])\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        n = case[\"n\"]\n        f = case[\"f\"]\n        alpha = case[\"alpha\"]\n        beta = case[\"beta\"]\n        u_exact = case[\"u_exact\"]\n        \n        N = n + 1\n        \n        # Differentiation matrices\n        D1 = chebyshev_diff_matrix(n)\n        D2 = D1 @ D1\n        \n        # CGL nodes\n        t_nodes = np.cos(np.pi * np.arange(N) / n)\n        \n        # Mapped nodes for subdomains\n        x_minus = -1.0 + t_nodes  # on [-2, 0], x_0 = 0, x_n = -2\n        x_plus = 1.0 + t_nodes   # on [0, 2],  x_0 = 2,  x_n = 0\n        \n        # System matrix A and RHS vector B\n        A = np.zeros((2*N, 2*N))\n        B = np.zeros(2*N)\n        \n        row = 0\n        # Collocation on [-2, 0]\n        for j in range(1, n):\n            A[row, 0:N] = D2[j, :]\n            B[row] = f(x_minus[j])\n            row += 1\n            \n        # Collocation on [0, 2]\n        for j in range(1, n):\n            A[row, N:2*N] = D2[j, :]\n            B[row] = f(x_plus[j])\n            row += 1\n            \n        # BC: p_(-2) = alpha\n        A[row, n] = 1.0\n        B[row] = alpha\n        row += 1\n        \n        # BC: p_(2) = beta\n        A[row, N] = 1.0 # u_plus[0]\n        B[row] = beta\n        row += 1\n        \n        # Continuity: p_-(0) = p_+(0)\n        A[row, 0] = 1.0   # u_minus[0]\n        A[row, 2*N-1] = -1.0 # u_plus[n]\n        B[row] = 0.0\n        row += 1\n        \n        # Derivative continuity: p_-'(0) = p_+'(0)\n        A[row, 0:N] = D1[0, :]\n        A[row, N:2*N] = -D1[n, :]\n        B[row] = 0.0\n        \n        # Solve the system\n        U = np.linalg.solve(A, B)\n        u_minus = U[:N]\n        u_plus = U[N:]\n        \n        # Error evaluation\n        eval_grid = np.linspace(-2.0, 2.0, 1001)\n        grid_minus = eval_grid[eval_grid <= 0]\n        grid_plus = eval_grid[eval_grid > 0]\n        \n        # Map evaluation grid to canonical interval [-1, 1]\n        eval_t_minus = grid_minus + 1.0\n        eval_t_plus = grid_plus - 1.0\n        \n        p_vals_minus = barycentric_interpolate(eval_t_minus, t_nodes, u_minus)\n        p_vals_plus = barycentric_interpolate(eval_t_plus, t_nodes, u_plus)\n        \n        p_vals = np.concatenate((p_vals_minus, p_vals_plus))\n        \n        u_exact_vals = u_exact(eval_grid)\n        \n        error = np.max(np.abs(p_vals - u_exact_vals))\n        results.append(f\"{error:.8f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2379161"}]}