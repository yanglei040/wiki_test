{"hands_on_practices": [{"introduction": "This first practice delves into the fundamental physics governing the positions of the amide I and II bands. By applying the harmonic oscillator model, you will explore how isotopic substitution—a powerful experimental technique—alters vibrational frequencies. This exercise will solidify your understanding of the direct relationship between mass and frequency, demonstrating why deuteration significantly shifts the N-H bending mode of the amide II band, while heavy-atom labeling affects the C=O stretching mode of the amide I band [@problem_id:3692261].", "problem": "A polypeptide shows an amide I band and an amide II band in infrared spectroscopy. The amide I band is dominated by the carbonyl stretching coordinate of the peptide bond, which can be modeled as a single diatomic harmonic oscillator involving the carbon atom and the oxygen atom. The amide II band is dominated by the in-plane bending of the nitrogen–hydrogen bond, which for small angular displacements can be modeled as a harmonic angular oscillator whose kinetic energy is characterized by an effective moment of inertia around the nitrogen. Assume the following for the protiated, naturally abundant sample:\n- The observed amide I band wavenumber is $1650\\,\\mathrm{cm}^{-1}$.\n- The observed amide II band wavenumber is $1550\\,\\mathrm{cm}^{-1}$.\n\nYou perform two independent isotopic modifications:\n1. For the amide I mode only, you replace the carbonyl with isotopes ${}^{13}\\mathrm{C}$ and ${}^{18}\\mathrm{O}$.\n2. For the amide II mode only, you fully deuterate the peptide so that the nitrogen–hydrogen bonds become nitrogen–deuterium bonds.\n\nUse the following physically justified modeling assumptions and constants:\n- For the carbonyl stretching mode, treat the vibration as a diatomic harmonic oscillator with angular frequency $\\omega = \\sqrt{k/\\mu}$, where $k$ is an isotopically invariant force constant and $\\mu$ is the reduced mass $\\mu = \\frac{m_{\\mathrm{C}} m_{\\mathrm{O}}}{m_{\\mathrm{C}} + m_{\\mathrm{O}}}$. The wavenumber is $\\tilde{\\nu} = \\omega/(2\\pi c)$, so at fixed $k$ the wavenumber scales as $\\tilde{\\nu} \\propto \\mu^{-1/2}$.\n- For the amide II bending mode, model the small-angle in-plane bend as an angular harmonic oscillator with angular frequency $\\omega = \\sqrt{k_{\\mathrm{b}}/I}$, where $k_{\\mathrm{b}}$ is an isotopically invariant bending force constant and $I$ is the effective moment of inertia about the nitrogen. Assume the nitrogen is effectively fixed by the peptide framework so that $I \\approx m_{X} r^{2}$ with $X \\in \\{\\mathrm{H},\\mathrm{D}\\}$ and fixed bond length $r$, yielding the scaling $\\tilde{\\nu} \\propto I^{-1/2} \\propto m_{X}^{-1/2}$ when replacing $\\mathrm{H}$ with $\\mathrm{D}$.\n- Atomic masses (in unified atomic mass units) are: $m(^{12}\\mathrm{C}) = 12.000000$, $m(^{13}\\mathrm{C}) = 13.003355$, $m(^{16}\\mathrm{O}) = 15.994915$, $m(^{18}\\mathrm{O}) = 17.999160$, $m(\\mathrm{H}) = 1.007825$, $m(\\mathrm{D}) = 2.014102$.\n- The speed of light $c$ and bond length $r$ are constants that cancel in the required ratios; do not substitute numerical values for them.\n\nStarting from these fundamentals and scaling relations, compute the predicted amide I wavenumber after ${}^{13}\\mathrm{C}$/${}^{18}\\mathrm{O}$ labeling and the predicted amide II wavenumber after deuteration. Then, compute the single quantity equal to the difference of these two wavenumbers. Express your final answer in $\\mathrm{cm}^{-1}$ and round your final result to four significant figures. Do not carry units inside intermediate mathematical expressions; include units only in verbal statements of given or final values.", "solution": "The problem is first validated against the required criteria.\n\n### Step 1: Extract Givens\n- **Model for Amide I band (carbonyl stretch)**: Diatomic harmonic oscillator.\n  - Angular frequency: $\\omega = \\sqrt{k/\\mu}$\n  - Force constant $k$ is isotopically invariant.\n  - Reduced mass: $\\mu = \\frac{m_{\\mathrm{C}} m_{\\mathrm{O}}}{m_{\\mathrm{C}} + m_{\\mathrm{O}}}$\n  - Wavenumber scaling: $\\tilde{\\nu} \\propto \\mu^{-1/2}$\n- **Model for Amide II band (N-H bend)**: Angular harmonic oscillator.\n  - Angular frequency: $\\omega = \\sqrt{k_{\\mathrm{b}}/I}$\n  - Bending force constant $k_{\\mathrm{b}}$ is isotopically invariant.\n  - Effective moment of inertia: $I \\approx m_{X} r^{2}$ for $X \\in \\{\\mathrm{H},\\mathrm{D}\\}$, with fixed bond length $r$.\n  - Wavenumber scaling: $\\tilde{\\nu} \\propto m_{X}^{-1/2}$\n- **Observed Wavenumbers (protiated)**:\n  - Amide I band: $\\tilde{\\nu}_{\\text{I, unlab}} = 1650\\,\\mathrm{cm}^{-1}$\n  - Amide II band: $\\tilde{\\nu}_{\\text{II, unlab}} = 1550\\,\\mathrm{cm}^{-1}$\n- **Isotopic Modifications**:\n  1. For Amide I: ${}^{12}\\mathrm{C}={}^{16}\\mathrm{O}$ is replaced by ${}^{13}\\mathrm{C}={}^{18}\\mathrm{O}$.\n  2. For Amide II: N-H is replaced by N-D.\n- **Atomic Masses (in u)**:\n  - $m(^{12}\\mathrm{C}) = 12.000000$\n  - $m(^{13}\\mathrm{C}) = 13.003355$\n  - $m(^{16}\\mathrm{O}) = 15.994915$\n  - $m(^{18}\\mathrm{O}) = 17.999160$\n  - $m(\\mathrm{H}) = 1.007825$\n  - $m(\\mathrm{D}) = 2.014102$\n- **Task**: Compute the predicted amide I wavenumber after ${}^{13}\\mathrm{C}$/${}^{18}\\mathrm{O}$ labeling and the predicted amide II wavenumber after deuteration. Then, compute the difference of these two new wavenumbers, rounded to four significant figures.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is assessed for validity:\n- **Scientifically Grounded**: The problem is well-grounded in the principles of vibrational spectroscopy. The use of the harmonic oscillator model to describe molecular vibrations and the scaling of vibrational frequency with reduced mass (for stretching) or effective mass/moment of inertia (for bending) are standard, textbook approximations (the Born-Oppenheimer approximation implies the force constant is independent of isotopic substitution).\n- **Well-Posed**: The problem provides all necessary data and a clear, unambiguous set of instructions to calculate a unique numerical answer.\n- **Objective**: The problem is stated in precise, quantitative terms without any subjective or opinion-based content. The assumptions are explicitly given.\n- The problem does not violate any of the invalidity criteria. It is scientifically sound, formalizable, complete, and well-structured.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. A full solution will be provided.\n\n### Solution Derivation\n\nThe problem requires the calculation of isotopically shifted wavenumbers for the amide I and amide II bands and then their difference. We will address each band separately.\n\n#### Amide I Band Calculation\nThe amide I band is modeled as a diatomic harmonic oscillator. The vibrational wavenumber, $\\tilde{\\nu}$, is related to the angular frequency, $\\omega$, by $\\tilde{\\nu} = \\frac{\\omega}{2\\pi c}$, where $c$ is the speed of light. The angular frequency is given by $\\omega = \\sqrt{\\frac{k}{\\mu}}$, where $k$ is the force constant and $\\mu$ is the reduced mass. Since $k$ is assumed to be invariant upon isotopic substitution, the wavenumber $\\tilde{\\nu}$ scales with the reduced mass as $\\tilde{\\nu} \\propto \\mu^{-1/2}$.\n\nLet $\\tilde{\\nu}_{\\text{I, unlab}}$ and $\\mu_{\\text{unlab}}$ be the wavenumber and reduced mass for the unlabeled ${}^{12}\\mathrm{C}={}^{16}\\mathrm{O}$ species, and let $\\tilde{\\nu}_{\\text{I, lab}}$ and $\\mu_{\\text{lab}}$ be the corresponding quantities for the isotopically labeled ${}^{13}\\mathrm{C}={}^{18}\\mathrm{O}$ species. The scaling relationship is:\n$$ \\frac{\\tilde{\\nu}_{\\text{I, lab}}}{\\tilde{\\nu}_{\\text{I, unlab}}} = \\sqrt{\\frac{\\mu_{\\text{unlab}}}{\\mu_{\\text{lab}}}} $$\nThus, the predicted wavenumber for the labeled amide I band is:\n$$ \\tilde{\\nu}_{\\text{I, lab}} = \\tilde{\\nu}_{\\text{I, unlab}} \\times \\sqrt{\\frac{\\mu_{\\text{unlab}}}{\\mu_{\\text{lab}}}} $$\n\nFirst, we calculate the reduced masses.\nFor the unlabeled species (${}^{12}\\mathrm{C}={}^{16}\\mathrm{O}$):\n$$ \\mu_{\\text{unlab}} = \\frac{m(^{12}\\mathrm{C}) m(^{16}\\mathrm{O})}{m(^{12}\\mathrm{C}) + m(^{16}\\mathrm{O})} = \\frac{(12.000000)(15.994915)}{12.000000 + 15.994915} = \\frac{191.93898}{27.994915} \\approx 6.856353\\,\\text{u} $$\nFor the labeled species (${}^{13}\\mathrm{C}={}^{18}\\mathrm{O}$):\n$$ \\mu_{\\text{lab}} = \\frac{m(^{13}\\mathrm{C}) m(^{18}\\mathrm{O})}{m(^{13}\\mathrm{C}) + m(^{18}\\mathrm{O})} = \\frac{(13.003355)(17.999160)}{13.003355 + 17.999160} = \\frac{234.051493}{31.002515} \\approx 7.549429\\,\\text{u} $$\n\nNow, we can calculate the predicted amide I wavenumber:\n$$ \\tilde{\\nu}_{\\text{I, lab}} = 1650\\,\\mathrm{cm}^{-1} \\times \\sqrt{\\frac{6.856353}{7.549429}} \\approx 1650 \\times \\sqrt{0.908194} \\approx 1650 \\times 0.95300 = 1572.45\\,\\mathrm{cm}^{-1} $$\nUsing higher precision for intermediate steps:\n$$ \\tilde{\\nu}_{\\text{I, lab}} = 1650 \\times \\sqrt{\\frac{6.85635338}{7.54942935}} \\approx 1572.4498\\,\\mathrm{cm}^{-1} $$\n\n#### Amide II Band Calculation\nThe amide II band is modeled such that its wavenumber scales as $\\tilde{\\nu} \\propto m_{X}^{-1/2}$, where $m_X$ is the mass of the atom at the periphery of the bending motion, which is H for the unlabeled peptide and D for the deuterated peptide.\n\nLet $\\tilde{\\nu}_{\\text{II, unlab}}$ be the wavenumber for the protiated (N-H) species and $\\tilde{\\nu}_{\\text{II, lab}}$ be the wavenumber for the deuterated (N-D) species. The scaling relationship is:\n$$ \\frac{\\tilde{\\nu}_{\\text{II, lab}}}{\\tilde{\\nu}_{\\text{II, unlab}}} = \\sqrt{\\frac{m(\\mathrm{H})}{m(\\mathrm{D})}} $$\nThus, the predicted wavenumber for the labeled amide II band is:\n$$ \\tilde{\\nu}_{\\text{II, lab}} = \\tilde{\\nu}_{\\text{II, unlab}} \\times \\sqrt{\\frac{m(\\mathrm{H})}{m(\\mathrm{D})}} $$\n\nUsing the given masses $m(\\mathrm{H}) = 1.007825\\,\\text{u}$ and $m(\\mathrm{D}) = 2.014102\\,\\text{u}$, and the given initial wavenumber $\\tilde{\\nu}_{\\text{II, unlab}} = 1550\\,\\mathrm{cm}^{-1}$:\n$$ \\tilde{\\nu}_{\\text{II, lab}} = 1550\\,\\mathrm{cm}^{-1} \\times \\sqrt{\\frac{1.007825}{2.014102}} \\approx 1550 \\times \\sqrt{0.500384} \\approx 1550 \\times 0.707378 = 1096.44\\,\\mathrm{cm}^{-1} $$\nUsing higher precision for intermediate steps:\n$$ \\tilde{\\nu}_{\\text{II, lab}} = 1550 \\times \\sqrt{\\frac{1.007825}{2.014102}} \\approx 1096.4365\\,\\mathrm{cm}^{-1} $$\n\n#### Final Calculation\nThe problem asks for the difference between the two predicted wavenumbers, $\\Delta\\tilde{\\nu} = \\tilde{\\nu}_{\\text{I, lab}} - \\tilde{\\nu}_{\\text{II, lab}}$.\n$$ \\Delta\\tilde{\\nu} = 1572.4498\\,\\mathrm{cm}^{-1} - 1096.4365\\,\\mathrm{cm}^{-1} = 476.0133\\,\\mathrm{cm}^{-1} $$\nThe final result must be rounded to four significant figures.\nThe value $476.0133$ rounded to four significant figures is $476.0$.\nTherefore, the difference is $476.0\\,\\mathrm{cm}^{-1}$.", "answer": "$$\\boxed{476.0}$$", "id": "3692261"}, {"introduction": "Moving from fundamental models to practical computational chemistry, this exercise addresses a common challenge: the systematic deviation between theoretically computed harmonic frequencies and experimentally measured anharmonic frequencies. You will implement an empirical linear scaling method, a standard procedure used to correct computational predictions and improve their agreement with experimental data. This practice provides hands-on experience with calibrating theoretical models, a crucial skill for accurately interpreting and predicting vibrational spectra in modern research [@problem_id:3692255].", "problem": "You are tasked with designing a complete, runnable program that performs computational prediction and empirical scaling of vibrational wavenumbers for the Amide I and Amide II bands used in spectrometric identification of organic compounds. Begin from the fundamental base of the quantum harmonic oscillator and the definition of wavenumber, then construct a linear empirical correction model and determine its parameters via a principled optimization criterion. Finally, evaluate prediction accuracy and apply the calibrated model to new computational predictions. All physical answers involving wavenumbers must be expressed in $\\mathrm{cm}^{-1}$ with the rounding rules specified below.\n\nUse the following scientific foundations as your starting point:\n- The quantum harmonic oscillator frequency is given by $\\omega = \\sqrt{k / \\mu}$, where $\\omega$ is angular frequency, $k$ is the force constant, and $\\mu$ is the reduced mass.\n- The infrared (IR) vibrational wavenumber is defined as $\\tilde{\\nu} = \\omega / (2\\pi c)$, where $c$ is the speed of light.\n- In practical computational spectroscopy, harmonic predictions from Density Functional Theory (DFT) systematically deviate from measured fundamentals (for example, by anharmonicity and method/basis-set errors). We seek an empirical linear mapping from computed harmonic wavenumbers to measured fundamental wavenumbers to correct these deviations for each band.\n\nConstruct the following model and estimation task entirely within your program, without using any external input:\n- Let the computed harmonic wavenumbers be $x_i$ and the measured Fourier Transform Infrared (FTIR) fundamentals be $y_i$ for $i = 1,\\dots,n$ within a calibration dataset for one band (either Amide I or Amide II). Suppose the empirical relationship between measured and computed is modeled by $y_i \\approx s x_i + b$, where $s$ is a dimensionless scaling factor and $b$ is an offset in $\\mathrm{cm}^{-1}$.\n- Determine $s$ and $b$ by minimizing the sum of squared residuals $\\sum_{i=1}^{n} \\left(y_i - (s x_i + b)\\right)^2$ over the calibration dataset. Your implementation must handle the degenerate boundary case $\\mathrm{Var}(x_i) = 0$ robustly: when the variance of $x_i$ is zero (or effectively zero numerically), set $s = 0$ and $b$ equal to the mean of $y_i$.\n- After calibration, compute the root-mean-square deviation (RMSD) on the calibration set as $\\mathrm{RMSD} = \\sqrt{\\frac{1}{n} \\sum_{i=1}^{n} \\left(y_i - (s x_i + b)\\right)^2}$ in $\\mathrm{cm}^{-1}$.\n- Apply the calibrated mapping $\\hat{y} = s x + b$ to new computed predictions $x$ to obtain scaled predictions in $\\mathrm{cm}^{-1}$.\n\nRounding and output requirements:\n- Round $s$ to $6$ decimal places (dimensionless).\n- Round $b$ to $2$ decimal places in $\\mathrm{cm}^{-1}$.\n- Round $\\mathrm{RMSD}$ to $2$ decimal places in $\\mathrm{cm}^{-1}$.\n- Round each scaled prediction to $1$ decimal place in $\\mathrm{cm}^{-1}$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[\\mathrm{result1},\\mathrm{result2},\\mathrm{result3}]$). Each test case’s result must itself be a list of the form $[s, b, \\mathrm{RMSD}, [\\text{scaled predictions}]]$, where the final nested list contains the scaled predictions for that case.\n\nTest suite to be implemented verbatim in your program. For each case, treat it independently and perform calibration and prediction as described above.\n\n- Case $1$ (Amide I, happy path): Calibration data $x = [1710,1695,1660,1650]\\,\\mathrm{cm}^{-1}$, $y = [1665,1650,1610,1605]\\,\\mathrm{cm}^{-1}$. Predict for $x_{\\text{new}} = [1700,1655]\\,\\mathrm{cm}^{-1}$.\n- Case $2$ (Amide II, happy path): Calibration data $x = [1570,1555,1530,1515]\\,\\mathrm{cm}^{-1}$, $y = [1540,1528,1502,1490]\\,\\mathrm{cm}^{-1}$. Predict for $x_{\\text{new}} = [1560,1520]\\,\\mathrm{cm}^{-1}$.\n- Case $3$ (boundary condition, zero variance in $x$): Calibration data $x = [1700,1700,1700]\\,\\mathrm{cm}^{-1}$, $y = [1660,1665,1655]\\,\\mathrm{cm}^{-1}$. Predict for $x_{\\text{new}} = [1700,1690]\\,\\mathrm{cm}^{-1}$.\n- Case $4$ (edge case, small dataset): Calibration data $x = [1565,1525]\\,\\mathrm{cm}^{-1}$, $y = [1535,1495]\\,\\mathrm{cm}^{-1}$. Predict for $x_{\\text{new}} = [1545]\\,\\mathrm{cm}^{-1}$.\n\nScientific realism and interpretation:\n- Amide I band fundamentals typically occur near $1600–1700\\,\\mathrm{cm}^{-1}$ and Amide II near $1480–1575\\,\\mathrm{cm}^{-1}$. The calibration datasets above are designed to be scientifically plausible, reflecting that $x_i$ values from harmonic DFT often overestimate $y_i$ fundamentals.\n\nYour program must implement the above test suite and produce the single-line output in the exact specified format. All wavenumber quantities must be in $\\mathrm{cm}^{-1}$ and must follow the rounding rules stated above.", "solution": "The problem statement has been critically validated and is deemed valid. It is scientifically grounded in the principles of vibrational spectroscopy and computational chemistry, mathematically well-posed, objective, and self-contained. The task is to implement a standard empirical correction procedure used in computational spectroscopy, specifically linear regression to scale calculated harmonic vibrational wavenumbers to match experimental fundamental wavenumbers.\n\nThe core of the problem is to determine the parameters of a linear model, $y_i \\approx s x_i + b$, where $x_i$ represents the computed harmonic wavenumbers and $y_i$ the corresponding measured fundamental wavenumbers. The parameters, the dimensionless scaling factor $s$ and the offset $b$ (in units of $\\mathrm{cm^{-1}}$), are found by the principle of least squares, which involves minimizing the sum of squared residuals (SSR):\n\n$$\n\\mathrm{SSR} = \\sum_{i=1}^{n} \\left(y_i - (s x_i + b)\\right)^2\n$$\n\nTo find the values of $s$ and $b$ that minimize this quantity, we take the partial derivatives of SSR with respect to $s$ and $b$ and set them to zero. This yields the normal equations, the solution of which provides the estimators for the slope $s$ and intercept $b$:\n\n$$\ns = \\frac{\\sum_{i=1}^{n}(x_i - \\bar{x})(y_i - \\bar{y})}{\\sum_{i=1}^{n}(x_i - \\bar{x})^2} = \\frac{\\mathrm{Cov}(x, y)}{\\mathrm{Var}(x)}\n$$\n\n$$\nb = \\bar{y} - s\\bar{x}\n$$\n\nwhere $\\bar{x}$ and $\\bar{y}$ are the arithmetic means of the $x_i$ and $y_i$ data, respectively. The numerator of the expression for $s$ is the sum of products of deviations, proportional to the covariance, and the denominator is the sum of squared deviations of $x$, proportional to its variance.\n\nA critical aspect of the implementation is handling the degenerate case where the variance of the independent variable, $\\mathrm{Var}(x)$, is zero. This occurs when all $x_i$ values in the calibration set are identical. In this situation, the slope $s$ is undefined. The problem provides a scientifically reasonable prescription for this scenario: set $s=0$ and estimate $b$ as the mean of the observed values, $b = \\bar{y}$. This implies that if the computed value provides no information (zero variance), the best prediction for the measured value is simply the average of the measurements.\n\nOnce the parameters $s$ and $b$ are determined from the calibration data, the model's goodness-of-fit on this same dataset is quantified using the root-mean-square deviation (RMSD):\n\n$$\n\\mathrm{RMSD} = \\sqrt{\\frac{1}{n} \\sum_{i=1}^{n} \\left(y_i - (s x_i + b)\\right)^2} = \\sqrt{\\frac{\\mathrm{SSR}}{n}}\n$$\n\nFinally, the calibrated linear model, $\\hat{y} = s x + b$, is used to predict scaled wavenumbers $\\hat{y}$ for a new set of computed wavenumbers $x$.\n\nThe program will be structured to process each test case independently. For each case, it receives a calibration dataset ($x$, $y$) and a set of new points to predict ($x_{\\text{new}}$). The implementation will use the `numpy` library for efficient vectorized numerical operations. It will first compute the variance of the calibration $x$ data. If this variance is numerically indistinguishable from zero, the boundary condition logic is applied. Otherwise, the standard ordinary least squares formulas for $s$ and $b$ are used. Subsequently, the RMSD and the scaled predictions for $x_{\\text{new}}$ are calculated. All calculations are performed using full floating-point precision, and the final results are formatted to the specified number of decimal places only at the output stage, ensuring numerical accuracy. The final output is a single-line string composed of the formatted results for all test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs computational prediction and empirical scaling of vibrational\n    wavenumbers for Amide I and Amide II bands based on a linear regression model.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Case 1 (Amide I, happy path)\",\n            \"x_calib\": [1710, 1695, 1660, 1650],\n            \"y_calib\": [1665, 1650, 1610, 1605],\n            \"x_new\": [1700, 1655]\n        },\n        {\n            \"name\": \"Case 2 (Amide II, happy path)\",\n            \"x_calib\": [1570, 1555, 1530, 1515],\n            \"y_calib\": [1540, 1528, 1502, 1490],\n            \"x_new\": [1560, 1520]\n        },\n        {\n            \"name\": \"Case 3 (boundary condition, zero variance in x)\",\n            \"x_calib\": [1700, 1700, 1700],\n            \"y_calib\": [1660, 1665, 1655],\n            \"x_new\": [1700, 1690]\n        },\n        {\n            \"name\": \"Case 4 (edge case, small dataset)\",\n            \"x_calib\": [1565, 1525],\n            \"y_calib\": [1535, 1495],\n            \"x_new\": [1545]\n        }\n    ]\n\n    results_str_list = []\n    \n    for case in test_cases:\n        x_calib = np.array(case[\"x_calib\"], dtype=np.float64)\n        y_calib = np.array(case[\"y_calib\"], dtype=np.float64)\n        x_new = np.array(case[\"x_new\"], dtype=np.float64)\n        \n        n = len(x_calib)\n        \n        # Using a small tolerance for floating point comparison to zero\n        var_x = np.var(x_calib, ddof=0)\n        \n        if n  2 or var_x  1e-9:\n            # Handle degenerate case: variance of x is zero (or n2)\n            s = 0.0\n            b = np.mean(y_calib) if n > 0 else 0.0\n        else:\n            # Standard Ordinary Least Squares (OLS) calculation\n            # Use population variance/covariance (ddof=0) as it aligns with OLS formulas\n            # s = Cov(x,y) / Var(x)\n            cov_xy = np.cov(x_calib, y_calib, ddof=0)[0, 1]\n            s = cov_xy / var_x\n            \n            # b = mean(y) - s * mean(x)\n            b = np.mean(y_calib) - s * np.mean(x_calib)\n            \n        # Calculate predicted y for calibration set to find RMSD\n        y_pred_calib = s * x_calib + b\n        \n        # Calculate Root-Mean-Square Deviation (RMSD)\n        if n > 0:\n            rmsd = np.sqrt(np.mean((y_calib - y_pred_calib)**2))\n        else:\n            rmsd = 0.0\n\n        # Apply the calibrated model to new predictions\n        scaled_predictions = s * x_new + b\n        \n        # Format results according to specifications\n        s_fmt = f\"{s:.6f}\"\n        b_fmt = f\"{b:.2f}\"\n        rmsd_fmt = f\"{rmsd:.2f}\"\n        \n        # Format each scaled prediction to 1 decimal place\n        scaled_preds_fmt = \",\".join([f\"{p:.1f}\" for p in scaled_predictions])\n        scaled_preds_str = f\"[{scaled_preds_fmt}]\"\n        \n        # Assemble the final string for the current case\n        case_result_str = f\"[{s_fmt},{b_fmt},{rmsd_fmt},{scaled_preds_str}]\"\n        results_str_list.append(case_result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str_list)}]\")\n\nsolve()\n```", "id": "3692255"}, {"introduction": "This final practice demonstrates a key application of amide I spectroscopy: the quantitative analysis of protein secondary structure. The observed amide I band is a composite of overlapping contributions from different structural motifs like $\\alpha$-helices and $\\beta$-sheets. In this exercise, you will implement a spectral deconvolution algorithm based on non-negative least squares to determine the fractional contribution of each secondary structure component from a complex lineshape, showcasing how vibrational spectroscopy can provide detailed insights into macromolecular conformation [@problem_id:3692260].", "problem": "You are given a model-based, physically grounded task from Fourier Transform Infrared (FTIR) spectroscopy for the spectrometric identification of organic compounds, focused on the amide I band. The amide I band arises primarily from the carbonyl stretch in peptide bonds and is sensitive to secondary structure (for example, alpha-helix, beta-sheet, and random coil). The computational goal is to estimate the quantitative secondary structure fractions from an amide I absorbance spectrum under a physically justified model.\n\nFundamental base to be used:\n- Beer–Lambert law: $A(\\tilde{\\nu}) = \\ell \\sum_{i=1}^{N} \\varepsilon_{i}(\\tilde{\\nu}) c_{i}$, where $A(\\tilde{\\nu})$ is dimensionless absorbance at wavenumber $\\tilde{\\nu}$ (in $\\mathrm{cm}^{-1}$), $\\ell$ is path length (in $\\mathrm{cm}$), $\\varepsilon_{i}(\\tilde{\\nu})$ is the decadic molar absorptivity (in $\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{cm}^{-1}$) for component $i$, and $c_{i}$ is the molar concentration (in $\\mathrm{mol}\\,\\mathrm{L}^{-1}$).\n- Line shape representation: Each secondary-structure component $i$ contributes a lineshape represented by a Gaussian function $g_{i}(\\tilde{\\nu}) = \\exp\\!\\left[-\\dfrac{(\\tilde{\\nu}-\\tilde{\\nu}_{i})^{2}}{2\\sigma_{i}^{2}}\\right]$, with center $\\tilde{\\nu}_{i}$ (in $\\mathrm{cm}^{-1}$) and width parameter $\\sigma_{i}$ (in $\\mathrm{cm}^{-1}$). The molar absorptivity is modeled as $\\varepsilon_{i}(\\tilde{\\nu}) = \\varepsilon_{i}^{\\max}\\,g_{i}(\\tilde{\\nu})$, where $\\varepsilon_{i}^{\\max}$ (in $\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{cm}^{-1}$) is the peak decadic molar absorptivity for component $i$.\n\nYou must treat the unknown concentrations $c_{i}$ as non-negative. The fraction of each secondary structure component is defined as $f_{i} = \\dfrac{c_{i}}{\\sum_{j=1}^{N} c_{j}}$.\n\nYou are given three components to represent the amide I band:\n- Component $1$ (alpha-helix): $\\tilde{\\nu}_{1} = 1654\\,\\mathrm{cm}^{-1}$, $\\sigma_{1} = 8\\,\\mathrm{cm}^{-1}$, $\\varepsilon_{1}^{\\max} = 800\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{cm}^{-1}$.\n- Component $2$ (beta-sheet): $\\tilde{\\nu}_{2} = 1630\\,\\mathrm{cm}^{-1}$, $\\sigma_{2} = 10\\,\\mathrm{cm}^{-1}$, $\\varepsilon_{2}^{\\max} = 1100\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{cm}^{-1}$.\n- Component $3$ (random coil): $\\tilde{\\nu}_{3} = 1645\\,\\mathrm{cm}^{-1}$, $\\sigma_{3} = 12\\,\\mathrm{cm}^{-1}$, $\\varepsilon_{3}^{\\max} = 700\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{cm}^{-1}$.\n\nMeasurement grid:\n- Wavenumbers $\\tilde{\\nu}_{k}$ for $k = 0,1,\\dots,100$ defined by $\\tilde{\\nu}_{k} = 1600 + k$ in $\\mathrm{cm}^{-1}$, that is, from $1600\\,\\mathrm{cm}^{-1}$ to $1700\\,\\mathrm{cm}^{-1}$ inclusive, in steps of $1\\,\\mathrm{cm}^{-1}$.\n\nGiven a test case with known path length $\\ell$ and total concentration $c_{\\mathrm{tot}}$, and ground-truth fractions $(f_{1},f_{2},f_{3})$, the synthetic absorbance is constructed deterministically by:\n$$\nA(\\tilde{\\nu}_{k}) = \\ell \\sum_{i=1}^{3} \\left( \\varepsilon_{i}^{\\max}\\,g_{i}(\\tilde{\\nu}_{k}) \\right)\\, c_{i}, \\quad \\text{with } c_{i} = f_{i}\\,c_{\\mathrm{tot}}, \\quad c_{i} \\ge 0.\n$$\n\nAlgorithmic task:\n- For each test case, estimate the non-negative concentrations $c_{i}$ by minimizing the squared residual\n$$\n\\sum_{k=0}^{100} \\left[ A(\\tilde{\\nu}_{k}) - \\ell \\sum_{i=1}^{3} \\varepsilon_{i}^{\\max} g_{i}(\\tilde{\\nu}_{k}) c_{i} \\right]^{2},\n$$\nsubject to $c_{i} \\ge 0$ for all $i$. Then compute fractions $f_{i} = \\dfrac{c_{i}}{\\sum_{j=1}^{3} c_{j}}$. Express the fractions as decimals rounded to four decimal places.\n\nUnits:\n- Absorbance $A$ is dimensionless.\n- Wavenumber $\\tilde{\\nu}$ is in $\\mathrm{cm}^{-1}$.\n- Path length $\\ell$ is in $\\mathrm{cm}$.\n- Concentration $c_{i}$ and $c_{\\mathrm{tot}}$ are in $\\mathrm{mol}\\,\\mathrm{L}^{-1}$.\n- Decadic molar absorptivity $\\varepsilon_{i}^{\\max}$ is in $\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{cm}^{-1}$.\n\nTest suite:\n- Case $1$: $\\ell = 0.010\\,\\mathrm{cm}$, $c_{\\mathrm{tot}} = 0.010\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$, $(f_{1},f_{2},f_{3}) = (1.0, 0.0, 0.0)$.\n- Case $2$: $\\ell = 0.010\\,\\mathrm{cm}$, $c_{\\mathrm{tot}} = 0.012\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$, $(f_{1},f_{2},f_{3}) = (0.6, 0.3, 0.1)$.\n- Case $3$: $\\ell = 0.010\\,\\mathrm{cm}$, $c_{\\mathrm{tot}} = 0.008\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$, $(f_{1},f_{2},f_{3}) = (0.0, 1.0, 0.0)$.\n- Case $4$: $\\ell = 0.005\\,\\mathrm{cm}$, $c_{\\mathrm{tot}} = 0.020\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$, $(f_{1},f_{2},f_{3}) = (0.4, 0.4, 0.2)$.\n- Case $5$: $\\ell = 0.010\\,\\mathrm{cm}$, $c_{\\mathrm{tot}} = 0.015\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$, $(f_{1},f_{2},f_{3}) = (0.45, 0.0, 0.55)$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the estimated fractions for all test cases as a comma-separated Python-style list of lists with each inner list ordered as $[f_{1},f_{2},f_{3}]$ and values rounded to four decimal places, for example, $[[0.1234,0.5678,0.3088],[\\dots],\\dots]$.\n\nAngle unit specification:\n- No angles are involved.\n\nPercentages:\n- Fractions must be reported as decimals, not with a percentage sign.\n\nYour program must implement the non-negative least squares estimation and produce the final output in the exact format and rounding specified.", "solution": "We start from the Beer–Lambert law, which states that the dimensionless absorbance $A(\\tilde{\\nu})$ at wavenumber $\\tilde{\\nu}$ is proportional to the path length $\\ell$ and the sum of contributions from each absorbing species. For multiple components, indexed by $i = 1,2,3$, the law is:\n$$\nA(\\tilde{\\nu}) = \\ell \\sum_{i=1}^{3} \\varepsilon_{i}(\\tilde{\\nu})\\, c_{i},\n$$\nwhere $\\varepsilon_{i}(\\tilde{\\nu})$ is the decadic molar absorptivity (in $\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{cm}^{-1}$) of component $i$ at $\\tilde{\\nu}$, and $c_{i}$ (in $\\mathrm{mol}\\,\\mathrm{L}^{-1}$) is the molar concentration of that component. In the amide I region, the molar absorptivity spectra of secondary-structure motifs can be represented by Gaussian line shapes centered at characteristic wavenumbers, capturing the broadening from environmental heterogeneity, with\n$$\ng_{i}(\\tilde{\\nu}) = \\exp\\!\\left[-\\frac{(\\tilde{\\nu}-\\tilde{\\nu}_{i})^{2}}{2\\sigma_{i}^{2}}\\right], \\quad \\varepsilon_{i}(\\tilde{\\nu}) = \\varepsilon_{i}^{\\max}\\, g_{i}(\\tilde{\\nu}).\n$$\nThus,\n$$\nA(\\tilde{\\nu}) = \\ell \\sum_{i=1}^{3} \\varepsilon_{i}^{\\max}\\, g_{i}(\\tilde{\\nu})\\, c_{i}.\n$$\nWe discretize the measurement over $k = 0,1,\\dots,100$ at $\\tilde{\\nu}_{k} = 1600 + k$ in $\\mathrm{cm}^{-1}$. Writing the model in matrix-vector form, define a design matrix $X \\in \\mathbb{R}^{101 \\times 3}$ with elements\n$$\nX_{k,i} = \\ell \\, \\varepsilon_{i}^{\\max}\\, g_{i}(\\tilde{\\nu}_{k}),\n$$\nand the unknown vector $\\mathbf{c} = [c_{1},c_{2},c_{3}]^{\\top}$. The measured absorbance vector $\\mathbf{A} \\in \\mathbb{R}^{101}$ satisfies\n$$\n\\mathbf{A} = X \\mathbf{c}.\n$$\nIn each synthetic test case, we construct $\\mathbf{A}$ deterministically from ground-truth parameters using\n$$\nc_{i} = f_{i}\\, c_{\\mathrm{tot}}, \\quad \\mathbf{A}_{k} = \\sum_{i=1}^{3} X_{k,i} c_{i}.\n$$\nThe estimation problem is to recover $\\mathbf{c}$ from $\\mathbf{A}$ given $X$, with the constraint $c_{i} \\ge 0$. This is a convex quadratic optimization problem, specifically a non-negative least squares (NNLS) problem:\n$$\n\\min_{\\mathbf{c} \\in \\mathbb{R}^{3}} \\left\\| \\mathbf{A} - X\\mathbf{c} \\right\\|_{2}^{2} \\quad \\text{subject to } c_{i} \\ge 0 \\text{ for } i=1,2,3.\n$$\nBecause the Beer–Lambert law is linear in concentration and the line shapes are fixed, the NNLS approach is justified as the maximum-likelihood estimator under Gaussian measurement noise and as a least-squares solution in the noiseless synthetic case.\n\nOnce $\\mathbf{c}$ is estimated, we compute the fractions:\n$$\nf_{i} = \\frac{c_{i}}{\\sum_{j=1}^{3} c_{j}}, \\quad i = 1,2,3.\n$$\nIf $\\sum_{j=1}^{3} c_{j} = 0$ (which would correspond to a zero-absorbance edge case), we define $f_{i} = 0$ for all $i$ to avoid division by zero; however, in the provided test suite this does not occur.\n\nAlgorithmic steps:\n1. Construct the wavenumber grid $\\tilde{\\nu}_{k} = 1600 + k$ for $k = 0,\\dots,100$.\n2. For each component $i$, compute $g_{i}(\\tilde{\\nu}_{k}) = \\exp\\!\\left[-\\dfrac{(\\tilde{\\nu}_{k}-\\tilde{\\nu}_{i})^{2}}{2\\sigma_{i}^{2}}\\right]$ and then $\\varepsilon_{i}(\\tilde{\\nu}_{k}) = \\varepsilon_{i}^{\\max}\\, g_{i}(\\tilde{\\nu}_{k})$.\n3. For each test case, with given $\\ell$, $c_{\\mathrm{tot}}$, and fractions $(f_{1},f_{2},f_{3})$, form $X_{k,i} = \\ell\\, \\varepsilon_{i}(\\tilde{\\nu}_{k})$ and compute the synthetic absorbance $\\mathbf{A} = X \\mathbf{c}$ where $\\mathbf{c} = c_{\\mathrm{tot}}\\,[f_{1},f_{2},f_{3}]^{\\top}$.\n4. Solve the NNLS problem to obtain $\\hat{\\mathbf{c}}$ that minimizes $\\|\\mathbf{A}-X\\mathbf{\\hat{c}}\\|_{2}^{2}$ subject to non-negativity.\n5. Compute $\\hat{f}_{i} = \\dfrac{\\hat{c}_{i}}{\\sum_{j=1}^{3} \\hat{c}_{j}}$.\n6. Round each $\\hat{f}_{i}$ to four decimal places.\n7. Aggregate results for all test cases and print as a single Python-style list of lists in one line.\n\nScientific realism and edge coverage:\n- The chosen centers $\\tilde{\\nu}_{i}$ and widths $\\sigma_{i}$ are consistent with known positions and broadening of amide I sub-bands for alpha-helix, beta-sheet, and random coil motifs.\n- The molar absorptivity peaks $\\varepsilon_{i}^{\\max}$ are ordered with beta-sheet often exhibiting stronger absorption.\n- The test suite includes pure-component cases ($f_{i}$ at bounds $0$ or $1$), mixed cases with overlapping bands, and a case with shorter path length to challenge sensitivity. These probe identifiability, non-negativity constraints, and overlap resolution.\n\nFinally, the program implements the NNLS solver to enforce $c_{i} \\ge 0$ and outputs the fractions in the specified format, rounded to four decimals.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import nnls\n\ndef gaussian(nu, nu0, sigma):\n    \"\"\"Gaussian line shape g(nu) centered at nu0 with width sigma.\"\"\"\n    return np.exp(-((nu - nu0) ** 2) / (2.0 * (sigma ** 2)))\n\ndef build_epsilon(nu_grid, centers, sigmas, eps_peaks):\n    \"\"\"\n    Build epsilon_i(nu) arrays for each component i:\n    epsilon_i(nu) = eps_peak_i * gaussian(nu; center_i, sigma_i)\n    \"\"\"\n    eps_list = []\n    for nu0, sigma, eps_peak in zip(centers, sigmas, eps_peaks):\n        g = gaussian(nu_grid, nu0, sigma)\n        eps_list.append(eps_peak * g)\n    return np.column_stack(eps_list)  # shape: (len(nu_grid), n_components)\n\ndef synth_absorbance(X, fractions, c_tot):\n    \"\"\"Construct synthetic absorbance A = X * c with c_i = fractions_i * c_tot.\"\"\"\n    c = np.array(fractions, dtype=float) * float(c_tot)\n    return X @ c\n\ndef estimate_fractions(X, A):\n    \"\"\"\n    Solve non-negative least squares to estimate c >= 0 from A ~ X c,\n    then compute fractions f_i = c_i / sum(c_j).\n    \"\"\"\n    c_hat, _ = nnls(X, A)\n    total = c_hat.sum()\n    if total = 0.0:\n        f_hat = np.zeros_like(c_hat)\n    else:\n        f_hat = c_hat / total\n    # Round to 4 decimal places\n    f_hat = np.round(f_hat, 4)\n    return f_hat.tolist()\n\ndef solve():\n    # Wavenumber grid: 1600 to 1700 cm^-1 inclusive, step 1 cm^-1\n    nu_grid = np.arange(1600.0, 1700.0 + 1.0, 1.0)\n\n    # Component definitions (amide I sub-bands)\n    # Alpha-helix\n    nu1 = 1654.0\n    sigma1 = 8.0\n    eps1 = 800.0  # L mol^-1 cm^-1\n    # Beta-sheet\n    nu2 = 1630.0\n    sigma2 = 10.0\n    eps2 = 1100.0  # L mol^-1 cm^-1\n    # Random coil\n    nu3 = 1645.0\n    sigma3 = 12.0\n    eps3 = 700.0  # L mol^-1 cm^-1\n\n    centers = [nu1, nu2, nu3]\n    sigmas = [sigma1, sigma2, sigma3]\n    eps_peaks = [eps1, eps2, eps3]\n\n    # Build epsilon(nu) for each component\n    epsilon_matrix = build_epsilon(nu_grid, centers, sigmas, eps_peaks)\n\n    # Define the test cases: (ell, c_tot, fractions)\n    test_cases = [\n        (0.010, 0.010, [1.0, 0.0, 0.0]),           # Case 1\n        (0.010, 0.012, [0.6, 0.3, 0.1]),           # Case 2\n        (0.010, 0.008, [0.0, 1.0, 0.0]),           # Case 3\n        (0.005, 0.020, [0.4, 0.4, 0.2]),           # Case 4\n        (0.010, 0.015, [0.45, 0.0, 0.55]),         # Case 5\n    ]\n\n    results = []\n    for ell, c_tot, fractions in test_cases:\n        # Build design matrix X = ell * epsilon(nu)\n        X = ell * epsilon_matrix  # shape (101, 3)\n        # Synthesize absorbance A from ground-truth fractions\n        A = synth_absorbance(X, fractions, c_tot)\n        # Estimate fractions via non-negative least squares\n        f_hat = estimate_fractions(X, A)\n        results.append(f_hat)\n\n    # Final print statement in the exact required format.\n    # Single-line output: list of lists, with inner lists [f1,f2,f3]\n    def format_inner(lst):\n        return \"[\" + \",\".join(f\"{x:.4f}\" for x in lst) + \"]\"\n    print(\"[\" + \",\".join(format_inner(r) for r in results) + \"]\")\n\nsolve()\n```", "id": "3692260"}]}