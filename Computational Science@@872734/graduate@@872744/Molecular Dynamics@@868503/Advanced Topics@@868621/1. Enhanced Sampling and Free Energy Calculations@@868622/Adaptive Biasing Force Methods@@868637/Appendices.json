{"hands_on_practices": [{"introduction": "The Adaptive Biasing Force (ABF) method reconstructs a free energy landscape by integrating the mean force. A key principle of vector calculus states that the line integral of a conservative vector field is path-independent. This exercise [@problem_id:3394488] challenges you to explore what happens when this ideal condition is broken by the inevitable presence of statistical noise, a scenario central to any real-world ABF simulation. By computationally comparing integrals along different paths for a noisy force field, you will gain a tangible understanding of how sampling error leads to path-dependent artifacts in the reconstructed potential of mean force.", "problem": "Consider a two-dimensional collective variable space with coordinates $\\xi = (\\xi_1,\\xi_2) \\in \\mathbb{R}^2$. In the Adaptive Biasing Force (ABF) method, the mean force field is defined as the negative gradient of the free energy (also called the potential of mean force) $A(\\xi)$, namely $M(\\xi) = -\\nabla A(\\xi)$. From the fundamental theorem of line integrals in vector calculus, if $M(\\xi)$ is exactly conservative, then the line integral of $M(\\xi)$ from a point $\\xi^{(0)}$ to a point $\\xi^{(1)}$ is path-independent and equals $A(\\xi^{(0)}) - A(\\xi^{(1)})$. In computational practice, the estimated mean force field contains noise and may be written as $\\widetilde{M}(\\xi) = M(\\xi) + \\eta(\\xi)$, where $\\eta(\\xi)$ is a zero-mean perturbation, making the line integral path-dependent for any particular realization of $\\eta(\\xi)$. Your task is to quantify the discrepancy induced by such noise for given analytic free energies $A(\\xi_1,\\xi_2)$.\n\nStarting only from the base definitions above and standard calculus, do the following for each test case:\n1. Use the provided analytic $A(\\xi)$ to define $M(\\xi) = -\\nabla A(\\xi)$ exactly.\n2. For fixed endpoints $\\xi^{(0)}$ and $\\xi^{(1)}$, construct two distinct integration paths:\n   - Path S (straight line): $\\xi(t) = \\xi^{(0)} + t\\left(\\xi^{(1)} - \\xi^{(0)}\\right)$ for $t \\in [0,1]$.\n   - Path L (two-leg $L$-shaped path): move first along $\\xi_1$ at fixed $\\xi_2 = \\xi_2^{(0)}$ from $\\xi_1^{(0)}$ to $\\xi_1^{(1)}$, then along $\\xi_2$ at fixed $\\xi_1 = \\xi_1^{(1)}$ from $\\xi_2^{(0)}$ to $\\xi_2^{(1)}$.\n3. Define the noisy estimate $\\widetilde{M}(\\xi) = M(\\xi) + \\eta$, where at each quadrature segment $\\eta$ is an independent draw from a bivariate normal distribution with zero mean and covariance $\\sigma^2 I_2$. Use a fixed random seed per test case so that the result is reproducible; use independent seeds for Path S and Path L within the same test case.\n4. Compute the line integral along each path using a midpoint quadrature with $N = 20000$ equal segments along the path parameterization, namely approximate\n   $$\\int_{\\mathcal{C}} \\widetilde{M}(\\xi) \\cdot d\\xi \\approx \\sum_{k=0}^{N-1} \\widetilde{M}\\!\\left(\\frac{\\xi_k + \\xi_{k+1}}{2}\\right) \\cdot \\left(\\xi_{k+1} - \\xi_k\\right),$$\n   where $\\{\\xi_k\\}_{k=0}^{N}$ are the successive discretization nodes along the path.\n5. Let $\\Delta A_{\\mathrm{exact}} = A(\\xi^{(0)}) - A(\\xi^{(1)})$ be the exact free energy difference. For each path $p \\in \\{\\mathrm{S},\\mathrm{L}\\}$, compute the absolute error $e_p = \\left|\\int_{\\mathcal{C}_p} \\widetilde{M}(\\xi) \\cdot d\\xi - \\Delta A_{\\mathrm{exact}}\\right|$.\n6. Compute the absolute path discrepancy $d = \\left|\\int_{\\mathcal{C}_{\\mathrm{S}}} \\widetilde{M}(\\xi) \\cdot d\\xi - \\int_{\\mathcal{C}_{\\mathrm{L}}} \\widetilde{M}(\\xi) \\cdot d\\xi\\right|$.\n7. Report all energies in units of Boltzmann constant times temperature ($k_{\\mathrm{B}}T$), as dimensionless numbers. Report each output float rounded to six decimal places.\n\nYou must implement a complete, runnable program that performs the above computations for the following test suite. Each test case specifies the analytic free energy $A(\\xi_1,\\xi_2)$, the endpoints, the noise standard deviation $\\sigma$, and the random seed base. For each test case, your program must output a list $[e_{\\mathrm{S}}, e_{\\mathrm{L}}, d]$.\n\nTest Suite:\n- Test 1 (happy path, zero-noise baseline):\n  - $A(\\xi_1,\\xi_2) = \\tfrac{1}{2}\\left(k_1 \\xi_1^2 + k_2 \\xi_2^2\\right) + c \\,\\xi_1 \\xi_2$ with $k_1 = 1.0$, $k_2 = 2.0$, $c = 0.3$.\n  - $\\xi^{(0)} = (-1.0,-1.0)$, $\\xi^{(1)} = (1.0,1.0)$.\n  - $\\sigma = 0.0$, seed base $s = 100$.\n- Test 2 (same analytic $A$ as Test 1, moderate noise):\n  - Same $A$ and endpoints as Test 1.\n  - $\\sigma = 0.2$, seed base $s = 101$.\n- Test 3 (nonlinear anharmonic free energy, small noise):\n  - $A(\\xi_1,\\xi_2) = \\tfrac{1}{4}\\xi_1^4 + \\tfrac{1}{4}\\xi_2^4 + \\tfrac{1}{2}\\xi_1^2 - \\xi_1 \\xi_2$.\n  - $\\xi^{(0)} = (-1.0, 0.5)$, $\\xi^{(1)} = (1.5, -0.5)$.\n  - $\\sigma = 0.1$, seed base $s = 102$.\n- Test 4 (nonlinear anharmonic free energy, longer path and higher noise):\n  - Same $A$ as Test 3.\n  - $\\xi^{(0)} = (-2.0, 2.0)$, $\\xi^{(1)} = (2.0, -2.0)$.\n  - $\\sigma = 0.3$, seed base $s = 103$.\n\nAngle units are not applicable. All energies must be expressed in $k_{\\mathrm{B}}T$ units as dimensionless numbers. Your program should produce a single line of output containing the results as a comma-separated list of lists enclosed in square brackets and with each float rounded to six decimal places, for example, \"[[eS1,eL1,d1],[eS2,eL2,d2],[eS3,eL3,d3],[eS4,eL4,d4]]\" with no spaces.", "solution": "The user's request is a valid computational problem grounded in the principles of statistical mechanics and vector calculus, specifically as applied to the Adaptive Biasing Force (ABF) method in molecular dynamics. The problem is well-posed, scientifically sound, and contains all necessary information for its resolution.\n\nThe core task is to quantify the path-dependence of a line integral for a noisy vector field. In the context of ABF, the exact mean force field $M(\\xi)$ on a set of collective variables $\\xi$ is conservative, as it is the negative gradient of a potential, the free energy $A(\\xi)$, i.e., $M(\\xi) = -\\nabla A(\\xi)$. Consequently, the work done by this force, represented by the line integral $\\int M(\\xi) \\cdot d\\xi$, is path-independent. However, any numerical estimate of the mean force, denoted $\\widetilde{M}(\\xi)$, will contain stochastic noise, $\\widetilde{M}(\\xi) = M(\\xi) + \\eta(\\xi)$. This noise term generally breaks the conservative property, making the line integral path-dependent. The problem asks to compute and compare this integral over two different paths and quantify the resulting discrepancy.\n\nHere is a step-by-step derivation of the solution methodology.\n\n### 1. Analytic Free Energy and Mean Force\n\nTwo analytic free energy surfaces $A(\\xi_1, \\xi_2)$ are provided. The mean force $M(\\xi)$ is derived from these by taking the negative gradient, $M(\\xi) = -\\nabla A(\\xi) = -(\\partial A / \\partial \\xi_1, \\partial A / \\partial \\xi_2)$.\n\n**Case 1: Quadratic Potential (Tests 1 & 2)**\nThe free energy is given by a general quadratic form:\n$$A(\\xi_1, \\xi_2) = \\frac{1}{2}(k_1 \\xi_1^2 + k_2 \\xi_2^2) + c \\xi_1 \\xi_2$$\nThe corresponding mean force is:\n$$M(\\xi_1, \\xi_2) = -\\nabla A(\\xi_1, \\xi_2) = -\\begin{pmatrix} k_1 \\xi_1 + c \\xi_2 \\\\ k_2 \\xi_2 + c \\xi_1 \\end{pmatrix}$$\n\n**Case 2: Anharmonic Potential (Tests 3 & 4)**\nThe free energy is a nonlinear, anharmonic potential:\n$$A(\\xi_1, \\xi_2) = \\frac{1}{4}\\xi_1^4 + \\frac{1}{4}\\xi_2^4 + \\frac{1}{2}\\xi_1^2 - \\xi_1 \\xi_2$$\nThe corresponding mean force is:\n$$M(\\xi_1, \\xi_2) = -\\nabla A(\\xi_1, \\xi_2) = -\\begin{pmatrix} \\xi_1^3 + \\xi_1 - \\xi_2 \\\\ \\xi_2^3 - \\xi_1 \\end{pmatrix}$$\n\n### 2. Path Definitions and Parameterization\n\nFor given endpoints $\\xi^{(0)}$ and $\\xi^{(1)}$, two distinct paths are defined.\n\n**Path S (Straight Line):**\nThis path is a direct linear interpolation between the endpoints. It can be parameterized by $t \\in [0, 1]$:\n$$\\xi(t) = \\xi^{(0)} + t(\\xi^{(1)} - \\xi^{(0)})$$\nThe differential path element is $d\\xi = (\\xi^{(1)} - \\xi^{(0)}) dt$.\n\n**Path L (L-shaped):**\nThis path consists of two orthogonal legs.\n- **Leg 1:** Moves along the $\\xi_1$ direction from $\\xi_1^{(0)}$ to $\\xi_1^{(1)}$ while holding $\\xi_2$ constant at $\\xi_2^{(0)}$.\n- **Leg 2:** Moves along the $\\xi_2$ direction from $\\xi_2^{(0)}$ to $\\xi_2^{(1)}$ while holding $\\xi_1$ constant at $\\xi_1^{(1)}$.\n\n### 3. Numerical Integration with Noise\n\nThe line integral of the noisy force field $\\widetilde{M}(\\xi) = M(\\xi) + \\eta$ is computed using a composite midpoint quadrature rule with $N=20000$ segments. The integral along a path $\\mathcal{C}$ is approximated as:\n$$\\int_{\\mathcal{C}} \\widetilde{M}(\\xi) \\cdot d\\xi \\approx \\sum_{k=0}^{N-1} \\widetilde{M}\\!\\left(\\xi_k^{\\text{mid}}\\right) \\cdot \\Delta\\xi_k$$\nwhere $\\xi_k^{\\text{mid}} = (\\xi_k + \\xi_{k+1})/2$ is the midpoint of the $k$-th segment and $\\Delta\\xi_k = \\xi_{k+1} - \\xi_k$ is the vector representing that segment. The noise $\\eta$ at each midpoint is an independent random vector drawn from a bivariate normal distribution with zero mean and covariance $\\sigma^2 I_2$, where $I_2$ is the $2 \\times 2$ identity matrix.\n\n**For Path S:** The path is divided into $N$ segments of equal length. The vector for the $k$-th segment is $\\Delta\\xi_k = (\\xi^{(1)} - \\xi^{(0)})/N$.\n\n**For Path L:** The total number of segments $N$ is distributed between the two legs proportionally to their lengths. Let $L_1 = |\\xi_1^{(1)} - \\xi_1^{(0)}|$ and $L_2 = |\\xi_2^{(1)} - \\xi_2^{(0)}|$. The number of segments for Leg 1 is $N_1 = \\text{round}(N \\cdot L_1 / (L_1+L_2))$, and for Leg 2 is $N_2 = N - N_1$.\n- The integral for Leg 1 is approximated by a sum over $N_1$ segments: $\\sum_{k=0}^{N_1-1} \\widetilde{M}_{1}(\\xi_{1,k}^{\\text{mid}}, \\xi_2^{(0)}) \\cdot \\Delta\\xi_{1,k}$, where $\\Delta\\xi_{1,k} = (\\xi_1^{(1)} - \\xi_1^{(0)})/N_1$.\n- The integral for Leg 2 is approximated by a sum over $N_2$ segments: $\\sum_{k=0}^{N_2-1} \\widetilde{M}_{2}(\\xi_1^{(1)}, \\xi_{2,k}^{\\text{mid}}) \\cdot \\Delta\\xi_{2,k}$, where $\\Delta\\xi_{2,k} = (\\xi_2^{(1)} - \\xi_2^{(0)})/N_2$.\nThe total integral for Path L is the sum of the results from the two legs.\n\n### 4. Quantifying Error and Discrepancy\n\nThe following metrics are computed to assess the impact of the noise:\n\n1.  **Exact Free Energy Difference:** The true path-independent value of the integral is $\\Delta A_{\\mathrm{exact}} = A(\\xi^{(0)}) - A(\\xi^{(1)})$.\n2.  **Absolute Error:** For each path $p \\in \\{\\mathrm{S}, \\mathrm{L}\\}$, the absolute error $e_p$ measures the deviation of the numerical integral from the exact value:\n    $$e_p = \\left| \\int_{\\mathcal{C}_p} \\widetilde{M}(\\xi) \\cdot d\\xi - \\Delta A_{\\mathrm{exact}} \\right|$$\n3.  **Absolute Path Discrepancy:** The discrepancy $d$ measures the difference between the integral values computed along the two paths:\n    $$d = \\left| \\int_{\\mathcal{C}_{\\mathrm{S}}} \\widetilde{M}(\\xi) \\cdot d\\xi - \\int_{\\mathcal{C}_{\\mathrm{L}}} \\widetilde{M}(\\xi) \\cdot d\\xi \\right|$$\n\nThis computational procedure is applied to each test case specified, using independent random seeds for Path S and Path L within each test to ensure their stochastic errors are uncorrelated. The final results $[e_{\\mathrm{S}}, e_{\\mathrm{L}}, d]$ are reported for each case. For the zero-noise case ($\\sigma=0$), any non-zero error is solely due to the quadrature approximation, which is expected to be minimal for the large value of $N$ used.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes path-dependent discrepancies in line integrals of noisy force fields.\n    \"\"\"\n    N_segments = 20000\n\n    # Define the free energy and mean force functions for the test cases.\n    def A1(xi, k1, k2, c):\n        x, y = xi\n        return 0.5 * (k1 * x**2 + k2 * y**2) + c * x * y\n\n    def M1(xi, k1, k2, c):\n        x, y = xi\n        return -np.array([k1 * x + c * y, k2 * y + c * x])\n\n    def A2(xi):\n        x, y = xi\n        return 0.25 * x**4 + 0.25 * y**4 + 0.5 * x**2 - x * y\n\n    def M2(xi):\n        x, y = xi\n        return -np.array([x**3 + x - y, y**3 - x])\n\n    # Test suite definition\n    test_cases = [\n        {\n            \"A_func\": lambda xi: A1(xi, k1=1.0, k2=2.0, c=0.3),\n            \"M_func\": lambda xi: M1(xi, k1=1.0, k2=2.0, c=0.3),\n            \"xi0\": np.array([-1.0, -1.0]),\n            \"xi1\": np.array([1.0, 1.0]),\n            \"sigma\": 0.0,\n            \"seed_base\": 100,\n        },\n        {\n            \"A_func\": lambda xi: A1(xi, k1=1.0, k2=2.0, c=0.3),\n            \"M_func\": lambda xi: M1(xi, k1=1.0, k2=2.0, c=0.3),\n            \"xi0\": np.array([-1.0, -1.0]),\n            \"xi1\": np.array([1.0, 1.0]),\n            \"sigma\": 0.2,\n            \"seed_base\": 101,\n        },\n        {\n            \"A_func\": A2,\n            \"M_func\": M2,\n            \"xi0\": np.array([-1.0, 0.5]),\n            \"xi1\": np.array([1.5, -0.5]),\n            \"sigma\": 0.1,\n            \"seed_base\": 102,\n        },\n        {\n            \"A_func\": A2,\n            \"M_func\": M2,\n            \"xi0\": np.array([-2.0, 2.0]),\n            \"xi1\": np.array([2.0, -2.0]),\n            \"sigma\": 0.3,\n            \"seed_base\": 103,\n        }\n    ]\n\n    def integrate_path_S(M_func, xi0, xi1, N, sigma, seed):\n        \"\"\"Computes the line integral along a straight path.\"\"\"\n        rng = np.random.default_rng(seed)\n        path_vec = xi1 - xi0\n        segment_vec = path_vec / N\n        total_integral = 0.0\n        \n        for k in range(N):\n            midpoint = xi0 + (k + 0.5) * segment_vec\n            mean_force = M_func(midpoint)\n            noise = rng.normal(loc=0.0, scale=sigma, size=2) if sigma > 0 else np.zeros(2)\n            noisy_force = mean_force + noise\n            total_integral += np.dot(noisy_force, segment_vec)\n            \n        return total_integral\n\n    def integrate_path_L(M_func, xi0, xi1, N, sigma, seed):\n        \"\"\"Computes the line integral along an L-shaped path.\"\"\"\n        rng = np.random.default_rng(seed)\n        total_integral = 0.0\n        \n        # Determine segment distribution\n        L1 = np.abs(xi1[0] - xi0[0])\n        L2 = np.abs(xi1[1] - xi0[1])\n        L_total = L1 + L2\n        \n        if L_total == 0:\n            return 0.0\n            \n        N1 = int(round(N * L1 / L_total))\n        N2 = N - N1\n\n        # Leg 1: along xi_1\n        if N1 > 0:\n            d_xi1 = (xi1[0] - xi0[0]) / N1\n            for k in range(N1):\n                mid_xi1 = xi0[0] + (k + 0.5) * d_xi1\n                midpoint = np.array([mid_xi1, xi0[1]])\n                mean_force = M_func(midpoint)\n                noise = rng.normal(loc=0.0, scale=sigma, size=2) if sigma > 0 else np.zeros(2)\n                noisy_force = mean_force + noise\n                total_integral += noisy_force[0] * d_xi1\n                \n        # Leg 2: along xi_2\n        if N2 > 0:\n            d_xi2 = (xi1[1] - xi0[1]) / N2\n            for k in range(N2):\n                mid_xi2 = xi0[1] + (k + 0.5) * d_xi2\n                midpoint = np.array([xi1[0], mid_xi2])\n                mean_force = M_func(midpoint)\n                noise = rng.normal(loc=0.0, scale=sigma, size=2) if sigma > 0 else np.zeros(2)\n                noisy_force = mean_force + noise\n                total_integral += noisy_force[1] * d_xi2\n\n        return total_integral\n\n    all_results = []\n    for case in test_cases:\n        A_func = case[\"A_func\"]\n        M_func = case[\"M_func\"]\n        xi0 = case[\"xi0\"]\n        xi1 = case[\"xi1\"]\n        sigma = case[\"sigma\"]\n        seed_base = case[\"seed_base\"]\n        \n        delta_A_exact = A_func(xi0) - A_func(xi1)\n        \n        # Path S\n        integral_S = integrate_path_S(M_func, xi0, xi1, N_segments, sigma, seed_base)\n        e_S = abs(integral_S - delta_A_exact)\n        \n        # Path L\n        integral_L = integrate_path_L(M_func, xi0, xi1, N_segments, sigma, seed_base + 1)\n        e_L = abs(integral_L - delta_A_exact)\n        \n        # Discrepancy\n        d = abs(integral_S - integral_L)\n        \n        all_results.append([e_S, e_L, d])\n\n    # Format output\n    formatted_results = []\n    for res_list in all_results:\n        formatted_list_str = \",\".join([f\"{x:.6f}\" for x in res_list])\n        formatted_results.append(f\"[{formatted_list_str}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3394488"}, {"introduction": "Obtaining a numerical value for a free energy difference is only the first step; a rigorous scientific study also requires quantifying its uncertainty. This practice [@problem_id:3394466] moves beyond simple error bars to a comprehensive uncertainty analysis for an ABF calculation. You will learn to dissect the total error into its two primary components: the statistical error arising from finite sampling and the systematic error introduced by the discretization of the collective variable. By applying the delta method for variance propagation and the Euler–Maclaurin formula for discretization bias, you will construct a robust estimator for the total uncertainty, a critical skill for assessing the reliability of any simulation result.", "problem": "You are analyzing a one-dimensional Adaptive Biasing Force (ABF) free-energy computation along a dimensionless collective variable $\\xi \\in [0,1]$. The potential of mean force $A(\\xi)$ is defined so that its derivative is the negative of the mean force, that is $A'(\\xi) = -\\mathcal{F}(\\xi)$, where $\\mathcal{F}(\\xi)$ denotes the equilibrium mean generalized force along $\\xi$. In an ABF simulation, $\\xi$ is discretized uniformly with spacing $h$ and the mean force is estimated at the grid nodes. You wish to construct a rigorous estimator of the uncertainty in $A(\\xi)$ that accounts for both sampling error in the mean-force estimates and the systematic discretization error introduced by the finite $\\xi$-grid, using a delta-method calculation and a first nonvanishing term from the Euler–Maclaurin summation formula.\n\nAssume a uniform grid with $h = 0.25$ and nodes $\\xi_j = j h$ for $j \\in \\{0,1,2,3,4\\}$. Let $\\widehat{\\mathcal{F}}_j$ denote the sample mean force at node $\\xi_j$, obtained from $n_j$ samples, and assume $\\widehat{\\mathcal{F}}_j$ is unbiased with sampling variance $\\sigma_j^2/n_j$, where $\\sigma_j^2$ is the sample variance of the instantaneous generalized force in node $j$. You will estimate the free-energy difference $A(1) - A(0)$ via the composite trapezoidal rule applied to the mean force and then convert it to the ABF estimate $\\widehat{A}(1) - \\widehat{A}(0)$ by negating that integral approximation.\n\nThe delta method may be used to propagate the sampling error through the linear functional of the mean-force estimates to obtain an approximate variance for $\\widehat{A}(1)-\\widehat{A}(0)$. For the systematic discretization error of the composite trapezoidal rule, use the first Euler–Maclaurin correction, which involves the endpoint derivatives $\\mathcal{F}'(1)$ and $\\mathcal{F}'(0)$. Since $\\mathcal{F}'$ is unknown, estimate $\\mathcal{F}'(0)$ and $\\mathcal{F}'(1)$ by one-sided first-order finite differences using the observed $\\widehat{\\mathcal{F}}_j$. Treat this systematic discretization as a bias term that contributes additively in quadrature to define an estimated standard uncertainty as the square root of the estimated mean-squared error.\n\nCarry out the derivation and then validate the resulting estimator on the following synthetic dataset (energies in kilojoules per mole). The ABF force estimates and sampling statistics at the five nodes are:\n- $\\xi_0 = 0$: $\\widehat{\\mathcal{F}}_0 = 0$, $n_0 = 200$, $\\sigma_0^2 = 4.0$,\n- $\\xi_1 = 0.25$: $\\widehat{\\mathcal{F}}_1 = -0.125$, $n_1 = 400$, $\\sigma_1^2 = 1.0$,\n- $\\xi_2 = 0.5$: $\\widehat{\\mathcal{F}}_2 = 0$, $n_2 = 300$, $\\sigma_2^2 = 1.44$,\n- $\\xi_3 = 0.75$: $\\widehat{\\mathcal{F}}_3 = 0.375$, $n_3 = 500$, $\\sigma_3^2 = 2.25$,\n- $\\xi_4 = 1.0$: $\\widehat{\\mathcal{F}}_4 = 1.0$, $n_4 = 200$, $\\sigma_4^2 = 9.0$.\n\nBy definition, the trapezoidal estimate of the mean-force integral over $[0,1]$ is\n$$\n\\widehat{I}_T = h\\left(\\tfrac{1}{2}\\widehat{\\mathcal{F}}_0 + \\widehat{\\mathcal{F}}_1 + \\widehat{\\mathcal{F}}_2 + \\widehat{\\mathcal{F}}_3 + \\tfrac{1}{2}\\widehat{\\mathcal{F}}_4\\right),\n$$\nand the ABF free-energy difference estimate is $\\widehat{A}(1) - \\widehat{A}(0) = -\\widehat{I}_T$.\n\nConstruct a delta-method estimator for the variance $\\operatorname{Var}[\\widehat{A}(1) - \\widehat{A}(0)]$ assuming independence between nodes. For the systematic discretization bias $b_A$ in $\\widehat{A}(1) - \\widehat{A}(0)$, use the first Euler–Maclaurin correction for the composite trapezoid, which at leading order depends on $\\mathcal{F}'(1) - \\mathcal{F}'(0)$, and estimate this difference by one-sided first-order finite differences of $\\widehat{\\mathcal{F}}_j$ at the endpoints. Combine the variance and squared bias to form an estimated mean-squared error, and define the estimated one-sigma uncertainty as $u_A = \\sqrt{\\widehat{\\operatorname{Var}} + \\widehat{b}_A^{\\,2}}$.\n\nCompute $u_A$ from the synthetic dataset, express your final answer in kilojoules per mole, and round your answer to four significant figures.", "solution": "The user-provided problem is critically examined and validated before a solution is attempted.\n\n### Step 1: Extract Givens\n- **System**: One-dimensional Adaptive Biasing Force (ABF) computation.\n- **Collective Variable**: $\\xi \\in [0,1]$.\n- **Thermodynamic Quantity**: Potential of Mean Force $A(\\xi)$.\n- **Definition**: $A'(\\xi) = -\\mathcal{F}(\\xi)$, where $\\mathcal{F}(\\xi)$ is the mean generalized force.\n- **Discretization**: Uniform grid with spacing $h = 0.25$ and nodes $\\xi_j = j h$ for $j \\in \\{0,1,2,3,4\\}$.\n- **Force Estimators**: $\\widehat{\\mathcal{F}}_j$ is the sample mean force at node $\\xi_j$ from $n_j$ samples.\n- **Statistical Properties**: $\\widehat{\\mathcal{F}}_j$ is unbiased with $\\operatorname{Var}[\\widehat{\\mathcal{F}}_j] = \\sigma_j^2/n_j$. The estimates $\\widehat{\\mathcal{F}}_j$ at different nodes are independent.\n- **Free Energy Estimator**: The estimate for the free energy difference, denoted $\\widehat{\\Delta A} = \\widehat{A}(1) - \\widehat{A}(0)$, is given by the negative of the composite trapezoidal rule integral of the mean forces:\n$$\n\\widehat{\\Delta A} = -\\widehat{I}_T = -h\\left(\\tfrac{1}{2}\\widehat{\\mathcal{F}}_0 + \\widehat{\\mathcal{F}}_1 + \\widehat{\\mathcal{F}}_2 + \\widehat{\\mathcal{F}}_3 + \\tfrac{1}{2}\\widehat{\\mathcal{F}}_4\\right)\n$$\n- **Uncertainty Definition**: The total estimated uncertainty $u_A$ is the square root of the estimated mean-squared error (MSE), which is the sum of the sampling variance and the squared systematic bias: $u_A = \\sqrt{\\widehat{\\operatorname{Var}}[\\widehat{\\Delta A}] + \\widehat{b}_{\\Delta A}^{\\,2}}$.\n- **Bias Estimation**: The systematic discretization bias $b_{\\Delta A}$ is to be estimated from the first Euler–Maclaurin correction term, $\\frac{h^2}{12}(\\mathcal{F}'(1) - \\mathcal{F}'(0))$. The derivatives $\\mathcal{F}'(0)$ and $\\mathcal{F}'(1)$ are to be estimated using one-sided first-order finite differences of the sample mean forces $\\widehat{\\mathcal{F}}_j$.\n- **Synthetic Dataset**:\n  - $\\xi_0 = 0$: $\\widehat{\\mathcal{F}}_0 = 0$, $n_0 = 200$, $\\sigma_0^2 = 4.0$.\n  - $\\xi_1 = 0.25$: $\\widehat{\\mathcal{F}}_1 = -0.125$, $n_1 = 400$, $\\sigma_1^2 = 1.0$.\n  - $\\xi_2 = 0.5$: $\\widehat{\\mathcal{F}}_2 = 0$, $n_2 = 300$, $\\sigma_2^2 = 1.44$.\n  - $\\xi_3 = 0.75$: $\\widehat{\\mathcal{F}}_3 = 0.375$, $n_3 = 500$, $\\sigma_3^2 = 2.25$.\n  - $\\xi_4 = 1.0$: $\\widehat{\\mathcal{F}}_4 = 1.0$, $n_4 = 200$, $\\sigma_4^2 = 9.0$.\n- **Final Output Requirement**: Compute $u_A$ and round to four significant figures.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is assessed to be **valid**.\n- **Scientifically Grounded**: The problem is rooted in standard practices of statistical mechanics, numerical analysis, and error theory as applied to molecular dynamics simulations. The concepts of potential of mean force, adaptive biasing force, trapezoidal rule integration, Euler-Maclaurin error analysis, and the delta method for error propagation are all well-established. Combining statistical (sampling) and systematic (discretization) errors in quadrature to form a mean-squared error is a standard procedure in metrology.\n- **Well-Posed**: The problem provides all necessary data and definitions to arrive at a unique numerical solution. The instructions for estimating both the variance and the bias are explicit and unambiguous.\n- **Objective**: The problem statement is free of subjective language and relies on formal mathematical and statistical definitions.\n- **Completeness and Consistency**: The provided data and conditions are self-contained and consistent. No external information or unstated assumptions are required.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete solution will be developed.\n\nThe objective is to calculate the total uncertainty $u_A = \\sqrt{\\widehat{\\operatorname{Var}}[\\widehat{\\Delta A}] + \\widehat{b}_{\\Delta A}^{\\,2}}$. This requires calculating two components: the sampling variance $\\widehat{\\operatorname{Var}}[\\widehat{\\Delta A}]$ and the systematic bias estimator $\\widehat{b}_{\\Delta A}$.\n\n**1. Estimation of Sampling Variance, $\\widehat{\\operatorname{Var}}[\\widehat{\\Delta A}]$**\n\nThe estimator for the free energy difference $\\widehat{\\Delta A} = \\widehat{A}(1) - \\widehat{A}(0)$ is a linear combination of the random variables $\\widehat{\\mathcal{F}}_j$:\n$$\n\\widehat{\\Delta A} = -h\\left(\\frac{1}{2}\\widehat{\\mathcal{F}}_0 + \\widehat{\\mathcal{F}}_1 + \\widehat{\\mathcal{F}}_2 + \\widehat{\\mathcal{F}}_3 + \\frac{1}{2}\\widehat{\\mathcal{F}}_4\\right)\n$$\nSince the estimates $\\widehat{\\mathcal{F}}_j$ for different nodes are assumed to be independent, the variance of their linear combination is the linear combination of their variances with squared coefficients. This is a direct application of error propagation rules (an exact form of the delta method for linear functions).\n$$\n\\operatorname{Var}[\\widehat{\\Delta A}] = \\operatorname{Var}\\left[-h\\left(\\frac{1}{2}\\widehat{\\mathcal{F}}_0 + \\sum_{j=1}^{3}\\widehat{\\mathcal{F}}_j + \\frac{1}{2}\\widehat{\\mathcal{F}}_4\\right)\\right]\n$$\n$$\n\\operatorname{Var}[\\widehat{\\Delta A}] = (-h)^2 \\left( \\left(\\frac{1}{2}\\right)^2\\operatorname{Var}[\\widehat{\\mathcal{F}}_0] + \\sum_{j=1}^{3}\\operatorname{Var}[\\widehat{\\mathcal{F}}_j] + \\left(\\frac{1}{2}\\right)^2\\operatorname{Var}[\\widehat{\\mathcal{F}}_4] \\right)\n$$\nSubstituting the given sampling variance $\\operatorname{Var}[\\widehat{\\mathcal{F}}_j] = \\sigma_j^2/n_j$, we obtain the estimator for the variance, which we denote $\\widehat{\\operatorname{Var}}[\\widehat{\\Delta A}]$:\n$$\n\\widehat{\\operatorname{Var}}[\\widehat{\\Delta A}] = h^2 \\left( \\frac{\\sigma_0^2}{4n_0} + \\frac{\\sigma_1^2}{n_1} + \\frac{\\sigma_2^2}{n_2} + \\frac{\\sigma_3^2}{n_3} + \\frac{\\sigma_4^2}{4n_4} \\right)\n$$\nUsing the provided data with $h=0.25$:\n$$\n\\frac{\\sigma_0^2}{n_0} = \\frac{4.0}{200} = 0.02, \\quad \\frac{\\sigma_1^2}{n_1} = \\frac{1.0}{400} = 0.0025, \\quad \\frac{\\sigma_2^2}{n_2} = \\frac{1.44}{300} = 0.0048, \\quad \\frac{\\sigma_3^2}{n_3} = \\frac{2.25}{500} = 0.0045, \\quad \\frac{\\sigma_4^2}{n_4} = \\frac{9.0}{200} = 0.045\n$$\nSubstituting these values:\n$$\n\\widehat{\\operatorname{Var}}[\\widehat{\\Delta A}] = (0.25)^2 \\left( \\frac{0.02}{4} + 0.0025 + 0.0048 + 0.0045 + \\frac{0.045}{4} \\right)\n$$\n$$\n\\widehat{\\operatorname{Var}}[\\widehat{\\Delta A}] = 0.0625 \\left( 0.005 + 0.0025 + 0.0048 + 0.0045 + 0.01125 \\right)\n$$\n$$\n\\widehat{\\operatorname{Var}}[\\widehat{\\Delta A}] = 0.0625 \\left( 0.02805 \\right) = 0.001753125\n$$\n\n**2. Estimation of Systematic Bias, $\\widehat{b}_{\\Delta A}$**\n\nThe true free energy difference is $\\Delta A = A(1)-A(0) = -\\int_0^1 \\mathcal{F}(\\xi) d\\xi$. The expected value of our estimator, assuming unbiased force estimates, is $E[\\widehat{\\Delta A}] = -I_T$, where $I_T$ is the composite trapezoidal rule approximation of the integral. The bias is $b_{\\Delta A} = E[\\widehat{\\Delta A}] - \\Delta A = -I_T - (-\\int_0^1 \\mathcal{F}(\\xi) d\\xi) = \\int_0^1 \\mathcal{F}(\\xi) d\\xi - I_T$.\nThe Euler-Maclaurin formula gives the leading error term for the composite trapezoidal rule as $\\int_a^b f(x)dx - I_T \\approx -\\frac{h^2}{12}(f'(b)-f'(a))$.\nThe bias in the ABF estimate is therefore $b_{\\Delta A} = -(\\text{error in } I_T) = \\frac{h^2}{12}(\\mathcal{F}'(1) - \\mathcal{F}'(0))$.\nWe estimate the derivatives using one-sided first-order finite differences:\n$$\n\\widehat{\\mathcal{F}}'(0) = \\frac{\\widehat{\\mathcal{F}}_1 - \\widehat{\\mathcal{F}}_0}{h}, \\quad \\widehat{\\mathcal{F}}'(1) = \\frac{\\widehat{\\mathcal{F}}_4 - \\widehat{\\mathcal{F}}_3}{h}\n$$\nThe bias estimator $\\widehat{b}_{\\Delta A}$ is then:\n$$\n\\widehat{b}_{\\Delta A} = \\frac{h^2}{12}(\\widehat{\\mathcal{F}}'(1) - \\widehat{\\mathcal{F}}'(0)) = \\frac{h^2}{12}\\left(\\frac{\\widehat{\\mathcal{F}}_4 - \\widehat{\\mathcal{F}}_3}{h} - \\frac{\\widehat{\\mathcal{F}}_1 - \\widehat{\\mathcal{F}}_0}{h}\\right)\n$$\n$$\n\\widehat{b}_{\\Delta A} = \\frac{h}{12}(\\widehat{\\mathcal{F}}_4 - \\widehat{\\mathcal{F}}_3 - \\widehat{\\mathcal{F}}_1 + \\widehat{\\mathcal{F}}_0)\n$$\nSubstituting the numerical values:\n$$\n\\widehat{b}_{\\Delta A} = \\frac{0.25}{12}(1.0 - 0.375 - (-0.125) + 0) = \\frac{0.25}{12}(1.0 - 0.375 + 0.125)\n$$\n$$\n\\widehat{b}_{\\Delta A} = \\frac{0.25}{12}(0.75) = \\frac{1/4}{12}(3/4) = \\frac{1}{48} \\frac{3}{4} = \\frac{3}{192} = \\frac{1}{64}\n$$\n$$\n\\widehat{b}_{\\Delta A} = 0.015625\n$$\nThe squared bias is $\\widehat{b}_{\\Delta A}^{\\,2} = (0.015625)^2 = 0.000244140625$.\n\n**3. Calculation of Total Uncertainty, $u_A$**\n\nThe total uncertainty is the square root of the estimated Mean-Squared Error (MSE), which is the sum of the sampling variance and the squared bias.\n$$\nu_A = \\sqrt{\\widehat{\\operatorname{Var}}[\\widehat{\\Delta A}] + \\widehat{b}_{\\Delta A}^{\\,2}}\n$$\n$$\nu_A = \\sqrt{0.001753125 + 0.000244140625} = \\sqrt{0.001997265625}\n$$\n$$\nu_A \\approx 0.044690778...\n$$\nRounding to four significant figures, as required by the problem statement:\n$$\nu_A \\approx 0.04469\n$$", "answer": "$$\n\\boxed{0.04469}\n$$", "id": "3394466"}, {"introduction": "Extending free energy calculations to multiple dimensions introduces new layers of complexity, particularly in the reconstruction of the potential surface from a gridded force field. This advanced practice [@problem_id:3394473] focuses on the crucial role of numerical integration (quadrature) in this process. You will implement and compare several quadrature rules—from the simple trapezoidal rule to higher-order methods like Simpson's and Gauss-Legendre—to appreciate the trade-offs between accuracy and computational cost. Furthermore, by testing these methods on both ideal and contaminated force fields, you will investigate how non-conservative (rotational) components, a common artifact in multi-dimensional ABF, can corrupt the reconstructed landscape.", "problem": "You are asked to implement, analyze, and compare numerical quadrature for reconstructing a scalar potential of mean force from an estimated mean force field on a two-dimensional collective variable (CV) space. The context is adaptive biasing force (ABF) methods in molecular dynamics, where one estimates the gradient of the potential of mean force and then reconstructs the scalar potential by integration over paths on a mesh. The task requires you to write a complete, runnable program that performs the following steps using only the specifications provided here. No input is required; the program must internally define all parameters and produce a single-line output in the specified format.\n\nDefinitions and setup:\n- Consider a two-dimensional collective variable space (CV) domain $$\\Omega = [0,1]\\times[0,1].$$\n- Let the potential of mean force be a sufficiently smooth scalar field $$A:\\Omega\\to\\mathbb{R},$$ and let its gradient (the mean force field) be $$\\nabla A.$$\n- In Adaptive Biasing Force (ABF), one constructs an estimator of the mean force, denoted $$\\widehat{A}_{,i}(\\boldsymbol{\\xi})$$ for components $$i\\in\\{1,2\\},$$ where $$\\boldsymbol{\\xi}=(\\xi_{1},\\xi_{2}).$$ In this problem, you will use analytically defined surrogate fields on a triangulated mesh of $$\\Omega$$ to emulate estimated mean forces.\n\nMesh and triangulation:\n- Use a uniform grid with $$n=17$$ nodes per axis, i.e., coordinates $$x_{i}=i/(n-1)$$ and $$y_{j}=j/(n-1)$$ for $$i,j\\in\\{0,1,\\dots,n-1\\}.$$\n- Build a triangulated mesh by connecting each axis-aligned unit square cell $$[x_{i},x_{i+1}]\\times[y_{j},y_{j+1}]$$ with the diagonal from $$(x_{i},y_{j})$$ to $$(x_{i+1},y_{j+1}).$$\n- Define the undirected edge set $$E$$ to include all horizontal edges, all vertical edges, and the chosen diagonal edges from the triangulation. Let $$V$$ be the set of all nodes.\n\nQuadrature rules for line integrals:\n- For an edge from $$\\mathbf{r}_{0}=(x_{0},y_{0})$$ to $$\\mathbf{r}_{1}=(x_{1},y_{1}),$$ parameterize the straight segment by $$\\mathbf{r}(t)=\\mathbf{r}_{0}+t(\\mathbf{r}_{1}-\\mathbf{r}_{0}),\\; t\\in[0,1],$$ and let $$\\mathbf{F}(\\mathbf{r})$$ denote the estimated mean force at point $$\\mathbf{r}.$$ The line integral contributing to the potential difference along the edge is\n$$\n\\Delta A = \\int_{0}^{1} \\mathbf{F}(\\mathbf{r}(t))\\cdot(\\mathbf{r}_{1}-\\mathbf{r}_{0})\\,dt.\n$$\n- Implement the following three quadrature rules to approximate this integral:\n  1. Trapezoidal rule: $$\\Delta A\\approx \\tfrac{1}{2}\\left[\\mathbf{F}(\\mathbf{r}_{0})+\\mathbf{F}(\\mathbf{r}_{1})\\right]\\cdot(\\mathbf{r}_{1}-\\mathbf{r}_{0}).$$\n  2. Simpson rule: $$\\Delta A\\approx \\tfrac{1}{6}\\left[\\mathbf{F}(\\mathbf{r}_{0})+4\\,\\mathbf{F}\\!\\left(\\tfrac{\\mathbf{r}_{0}+\\mathbf{r}_{1}}{2}\\right)+\\mathbf{F}(\\mathbf{r}_{1})\\right]\\cdot(\\mathbf{r}_{1}-\\mathbf{r}_{0}).$$\n  3. Three-point Gauss–Legendre rule on $$[0,1]:$$ with nodes $$t_{1}=\\tfrac{1}{2}-\\tfrac{\\sqrt{15}}{10},\\; t_{2}=\\tfrac{1}{2},\\; t_{3}=\\tfrac{1}{2}+\\tfrac{\\sqrt{15}}{10}$$ and weights $$w_{1}=\\tfrac{5}{18},\\; w_{2}=\\tfrac{8}{18},\\; w_{3}=\\tfrac{5}{18},$$\n  $$\n  \\Delta A\\approx \\sum_{k=1}^{3} w_{k}\\,\\mathbf{F}(\\mathbf{r}(t_{k}))\\cdot(\\mathbf{r}_{1}-\\mathbf{r}_{0}).\n  $$\n\nReconstruction by graph integration:\n- Choose the reference node at the origin $$(0,0)$$ with arbitrary reference potential; to remove the arbitrary constant for error evaluation, use mean-offset removal as defined below.\n- Construct any spanning tree of the mesh graph (for example, by breadth-first search on the undirected graph with node set $$V$$ and edge set $$E$$). Define the reconstructed potential $$\\widehat{A}$$ on all nodes by accumulating edge line-integral contributions along tree paths from the reference node.\n\nAccuracy and smoothness metrics:\n- For a given ground-truth potential $$A$$ and reconstructed $$\\widehat{A},$$ define the mean-offset $$c=\\frac{1}{|V|}\\sum_{\\mathbf{v}\\in V}\\left(\\widehat{A}(\\mathbf{v})-A(\\mathbf{v})\\right).$$\n- Define the root-mean-square error (RMSE) as\n$$\n\\mathrm{RMSE}=\\sqrt{\\frac{1}{|V|}\\sum_{\\mathbf{v}\\in V}\\left(\\widehat{A}(\\mathbf{v})-A(\\mathbf{v})-c\\right)^{2}}.\n$$\n- Define a smoothness metric as the mean squared edge difference\n$$\nS=\\frac{1}{|E|}\\sum_{(\\mathbf{u},\\mathbf{v})\\in E}\\left(\\widehat{A}(\\mathbf{u})-\\widehat{A}(\\mathbf{v})\\right)^{2}.\n$$\n\nTest suite:\n- Use the following four test cases, each providing a ground-truth scalar potential $$A$$ and an estimated mean force field $$\\mathbf{F}_{\\mathrm{est}}.$$ In all cases, errors are evaluated against the specified $$A.$$\n  1. Conservative, smooth:\n     - $$A(x,y)=\\sin(2\\pi x)\\sin(2\\pi y).$$\n     - $$\\mathbf{F}_{\\mathrm{est}}(x,y)=\\nabla A(x,y).$$\n  2. Conservative, higher frequency:\n     - $$A(x,y)=\\sin(6\\pi x)\\sin(6\\pi y).$$\n     - $$\\mathbf{F}_{\\mathrm{est}}(x,y)=\\nabla A(x,y).$$\n  3. Conservative with deterministic pseudo-noise of amplitude $$\\sigma=0.2:$$\n     - $$A(x,y)=\\sin(2\\pi x)\\sin(2\\pi y).$$\n     - $$\\mathbf{F}_{\\mathrm{est}}(x,y)=\\nabla A(x,y)+\\boldsymbol{\\eta}(x,y),$$ where the pseudo-noise is defined componentwise by\n       $$\n       \\eta_{1}(x,y)=\\sigma\\left(2\\,\\mathrm{frac}\\!\\left(\\sin(a_{1}x+b_{1}y)\\,c_{1}\\right)-1\\right),\\quad\n       \\eta_{2}(x,y)=\\sigma\\left(2\\,\\mathrm{frac}\\!\\left(\\sin(a_{2}x+b_{2}y)\\,c_{2}\\right)-1\\right),\n       $$\n       with constants $$a_{1}=12.9898,\\; b_{1}=78.233,\\; c_{1}=43758.5453$$ and $$a_{2}=93.9898,\\; b_{2}=67.345,\\; c_{2}=12731.3719,$$ and $$\\mathrm{frac}(z)=z-\\lfloor z\\rfloor.$$\n  4. Non-conservative (rotational contamination) with amplitude $$\\alpha=0.4:$$\n     - $$A(x,y)=\\sin(2\\pi x)\\sin(2\\pi y).$$\n     - Define a streamfunction $$\\psi(x,y)=\\sin(2\\pi x)\\sin(2\\pi y),$$ and a rotational field $$\\mathbf{R}(x,y)=\\left(-\\frac{\\partial \\psi}{\\partial y},\\;\\frac{\\partial \\psi}{\\partial x}\\right).$$\n     - $$\\mathbf{F}_{\\mathrm{est}}(x,y)=\\nabla A(x,y)+\\alpha\\,\\mathbf{R}(x,y).$$\n\nTasks:\n- Implement the three quadrature rules to approximate the edge line integrals.\n- Reconstruct $$\\widehat{A}$$ on all nodes via spanning-tree accumulation starting from the reference node $$(0,0).$$\n- For each test case and each quadrature rule, compute the pair $$(\\mathrm{RMSE},S).$$\n\nFinal output format:\n- Your program should produce a single line of output containing a flat, comma-separated list of floating-point numbers enclosed in square brackets. The entries must be ordered by test case $$1\\to 4,$$ and within each test case by quadrature rule in the order trapezoidal, Simpson, Gauss–Legendre, and within each rule the pair $$(\\mathrm{RMSE},S)$$ in that order. Concretely, the output should be\n$$\n[\\mathrm{RMSE}_{1,\\mathrm{trap}},S_{1,\\mathrm{trap}},\\mathrm{RMSE}_{1,\\mathrm{simp}},S_{1,\\mathrm{simp}},\\mathrm{RMSE}_{1,\\mathrm{gl3}},S_{1,\\mathrm{gl3}},\\dots,\\mathrm{RMSE}_{4,\\mathrm{trap}},S_{4,\\mathrm{trap}},\\mathrm{RMSE}_{4,\\mathrm{simp}},S_{4,\\mathrm{simp}},\\mathrm{RMSE}_{4,\\mathrm{gl3}},S_{4,\\mathrm{gl3}}].\n$$\n- There are $$24$$ numbers in total. No units are required; all quantities are dimensionless. Angles, where present inside trigonometric functions, are in radians by construction.", "solution": "The problem posed is a well-defined numerical task grounded in the principles of vector calculus and numerical analysis, with direct application to computational physics, specifically the reconstruction of a potential of mean force (PMF) in molecular dynamics simulations. The problem is self-contained, scientifically sound, and all parameters and procedures are specified unambiguously. Therefore, the problem is valid.\n\nThe core of the problem is to reconstruct a scalar potential field, $$A(\\boldsymbol{\\xi})$$, from its gradient, the mean force field $$\\mathbf{F}(\\boldsymbol{\\xi}) = \\nabla A(\\boldsymbol{\\xi})$$, on a two-dimensional domain $$\\Omega = [0,1]\\times[0,1]$$. The relationship between the potential and the force is given by the fundamental theorem of calculus for line integrals: the potential difference between two points $$\\mathbf{r}_0$$ and $$\\mathbf{r}_1$$ is the line integral of the force along any path connecting them, $$\\Delta A = A(\\mathbf{r}_1) - A(\\mathbf{r}_0) = \\int_{\\mathbf{r}_0}^{\\mathbf{r}_1} \\mathbf{F} \\cdot d\\mathbf{r}$$.\n\nThe solution is implemented algorithmically through the following steps:\n\n1.  **Discretization of the Domain**: The continuous domain $$\\Omega$$ is discretized into a uniform grid of $$n \\times n$$ nodes, where $$n=17$$. The set of nodes is denoted by $$V$$. These nodes are connected to form a graph, $$G=(V, E)$$, where the edge set $$E$$ consists of horizontal, vertical, and one diagonal connection for each grid cell. This structure defines the paths available for integration. The grid coordinates for a node indexed by $$(i, j)$$ (for $$i, j \\in \\{0, 1, \\dots, n-1\\}$$) are $$(x_i, y_j) = (i/(n-1), j/(n-1))$$.\n\n2.  **Path-Integral Formulation on the Graph**: To reconstruct the potential $$\\widehat{A}$$ at every node, we must compute line integrals. Since for a conservative force field the integral is path-independent, any path from a reference node to a target node yields the same potential difference. To ensure a unique path for every node and thus a well-defined reconstructed potential, we select a spanning tree of the graph $$G$$. A spanning tree is a subgraph that connects all vertices together without any cycles. In this implementation, a spanning tree is generated using a Breadth-First Search (BFS) algorithm starting from the reference node at the origin, $$(0,0)$$. The potential at this reference node is set to $$\\widehat{A}(0,0) = 0$$. The potential at any other node $$\\mathbf{v} \\in V$$ is then computed by summing the potential differences $$\\Delta \\widehat{A}$$ along the unique path in the spanning tree from the origin to $$\\mathbf{v}$$.\n\n3.  **Numerical Quadrature for Line Integrals**: The line integral along each edge of the spanning tree, from a parent node $$\\mathbf{r}_0$$ to a child node $$\\mathbf{r}_1$$, is approximated numerically. The problem specifies three quadrature rules of increasing order of accuracy for smooth integrands:\n    -   **Trapezoidal Rule**: A first-order method that approximates the integrand linearly, using force evaluations at the edge endpoints. $$\\Delta A\\approx \\tfrac{1}{2}\\left[\\mathbf{F}(\\mathbf{r}_{0})+\\mathbf{F}(\\mathbf{r}_{1})\\right]\\cdot(\\mathbf{r}_{1}-\\mathbf{r}_{0})$$.\n    -   **Simpson's Rule**: A second-order method that uses a quadratic approximation, requiring an additional force evaluation at the edge midpoint. $$\\Delta A\\approx \\tfrac{1}{6}\\left[\\mathbf{F}(\\mathbf{r}_{0})+4\\,\\mathbf{F}\\!\\left(\\tfrac{\\mathbf{r}_{0}+\\mathbf{r}_{1}}{2}\\right)+\\mathbf{F}(\\mathbf{r}_{1})\\right]\\cdot(\\mathbf{r}_{1}-\\mathbf{r}_{0})$$.\n    -   **Three-Point Gauss-Legendre Rule**: A higher-order rule, exact for polynomials up to degree $$5$$. It uses a weighted sum of force evaluations at three specific, non-uniformly spaced points along the edge. $$\\Delta A\\approx \\sum_{k=1}^{3} w_{k}\\,\\mathbf{F}(\\mathbf{r}(t_{k}))\\cdot(\\mathbf{r}_{1}-\\mathbf{r}_{0})$$.\n\n4.  **Analysis of Test Cases**: Four test cases are used to evaluate the methods.\n    -   Cases $$1$$ and $$2$$ use conservative force fields ($$\\mathbf{F}_{\\mathrm{est}} = \\nabla A$$). The only source of error is the numerical quadrature. Case $$2$$ has a higher spatial frequency, which poses a greater challenge to the quadrature rules, expecting larger errors.\n    -   Case $$3$$ introduces a high-frequency, pseudo-random, non-conservative noise component, $$\\boldsymbol{\\eta}(x,y)$$, to a conservative field. This mimics the statistical noise in ABF simulations. The integrand is no longer smooth, which challenges the assumption of polynomial-approximability that underlies higher-order quadrature, potentially diminishing their advantage.\n    -   Case $$4$$ introduces a non-conservative rotational component, $$\\mathbf{R}(x,y)$$, where $$\\nabla \\times \\mathbf{R} \\neq \\mathbf{0}$$. For such a field, the line integral is path-dependent. Consequently, the reconstructed potential $$\\widehat{A}$$ will depend on the chosen spanning tree, and it cannot perfectly represent the field. This introduces a fundamental, path-dependent error separate from the quadrature error.\n\n5.  **Evaluation Metrics**: The performance of each quadrature rule on each test case is quantified by two metrics:\n    -   **Root-Mean-Square Error (RMSE)**: This measures the accuracy of the reconstructed potential $$\\widehat{A}$$ against the true potential $$A$$. An arbitrary potential offset, which is physically meaningless, is removed by subtracting the mean difference $$c = \\langle \\widehat{A} - A \\rangle_V$$ before computing the RMSE. This ensures the comparison is based on the shape of the potential surface.\n    -   **Smoothness Metric ($$S$$)**: Defined as the mean squared potential difference across all edges in the full graph $$E$$, $$S = \\langle (\\widehat{A}(\\mathbf{u})-\\widehat{A}(\\mathbf{v}))^2 \\rangle_E$$. Since the potential difference approximates the work done by the force, this metric is related to the mean squared magnitude of the force field as captured by the reconstruction. It provides a measure of the \"activity\" or \"roughness\" of the reconstructed potential landscape.\n\nThe program systematically constructs the grid and graph, generates a spanning tree, implements the specified force fields and quadrature rules, and computes the $$\\mathrm{RMSE}$$ and $$S$$ metrics for all $$4 \\times 3 = 12$$ combinations, yielding $$24$$ final values.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import breadth_first_order\n\ndef solve():\n    \"\"\"\n    Main function to solve the numerical quadrature problem for PMF reconstruction.\n    \"\"\"\n    n = 17\n    N_nodes = n * n\n\n    # --- 1. Mesh, Graph, and Spanning Tree Setup ---\n    # Node coordinates\n    x_coords = np.linspace(0.0, 1.0, n)\n    y_coords = np.linspace(0.0, 1.0, n)\n    xv, yv = np.meshgrid(x_coords, y_coords)\n    nodes = np.vstack([xv.ravel(), yv.ravel()]).T\n\n    # Adjacency matrix and edge list\n    adj_matrix = np.zeros((N_nodes, N_nodes), dtype=int)\n    edge_set = set()\n\n    def add_edge(u, v):\n        adj_matrix[u, v] = 1\n        adj_matrix[v, u] = 1\n        edge_set.add(tuple(sorted((u, v))))\n\n    for j in range(n):\n        for i in range(n):\n            idx = j * n + i\n            # Horizontal edge\n            if i  n - 1:\n                idx_right = j * n + (i + 1)\n                add_edge(idx, idx_right)\n            # Vertical edge\n            if j  n - 1:\n                idx_down = (j + 1) * n + i\n                add_edge(idx, idx_down)\n            # Diagonal edge\n            if i  n - 1 and j  n - 1:\n                idx_diag = (j + 1) * n + (i + 1)\n                add_edge(idx, idx_diag)\n\n    edges = list(edge_set)\n    graph_csr = csr_matrix(adj_matrix)\n\n    # Spanning tree via BFS\n    start_node = 0\n    bfs_order, predecessors = breadth_first_order(\n        csgraph=graph_csr, i_start=start_node, directed=False, return_predecessors=True\n    )\n\n    # --- 2. Test Case Definitions ---\n    pi = np.pi\n    \n    # Test Case 1\n    def A_true_1(x, y): return np.sin(2 * pi * x) * np.sin(2 * pi * y)\n    def F_est_1(x, y):\n        fx = 2 * pi * np.cos(2 * pi * x) * np.sin(2 * pi * y)\n        fy = 2 * pi * np.sin(2 * pi * x) * np.cos(2 * pi * y)\n        return np.array([fx, fy]).T\n\n    # Test Case 2\n    def A_true_2(x, y): return np.sin(6 * pi * x) * np.sin(6 * pi * y)\n    def F_est_2(x, y):\n        fx = 6 * pi * np.cos(6 * pi * x) * np.sin(6 * pi * y)\n        fy = 6 * pi * np.sin(6 * pi * x) * np.cos(6 * pi * y)\n        return np.array([fx, fy]).T\n\n    # Test Case 3\n    A_true_3 = A_true_1\n    def F_est_3(x, y):\n        F_base = F_est_1(x, y)\n        sigma = 0.2\n        a1, b1, c1 = 12.9898, 78.233, 43758.5453\n        a2, b2, c2 = 93.9898, 67.345, 12731.3719\n        \n        arg1 = np.sin(a1 * x + b1 * y) * c1\n        eta1 = sigma * (2 * (arg1 - np.floor(arg1)) - 1)\n        \n        arg2 = np.sin(a2 * x + b2 * y) * c2\n        eta2 = sigma * (2 * (arg2 - np.floor(arg2)) - 1)\n        \n        noise = np.array([eta1, eta2]).T\n        return F_base + noise\n\n    # Test Case 4\n    A_true_4 = A_true_1\n    def F_est_4(x, y):\n        alpha = 0.4\n        F_grad = F_est_1(x, y)\n        Rx = -2 * pi * np.sin(2 * pi * x) * np.cos(2 * pi * y)\n        Ry = 2 * pi * np.cos(2 * pi * x) * np.sin(2 * pi * y)\n        R = np.array([Rx, Ry]).T\n        return F_grad + alpha * R\n\n    test_cases = [ (A_true_1, F_est_1), (A_true_2, F_est_2), (A_true_3, F_est_3), (A_true_4, F_est_4) ]\n\n    # --- 3. Quadrature Rule Definitions ---\n    # Trapezoid rule\n    def trapezoid_rule(F_func, r0, r1):\n        dr = r1 - r0\n        F0 = F_func(r0[0], r0[1])\n        F1 = F_func(r1[0], r1[1])\n        return 0.5 * np.dot(F0 + F1, dr)\n\n    # Simpson's rule\n    def simpson_rule(F_func, r0, r1):\n        dr = r1 - r0\n        rmid = 0.5 * (r0 + r1)\n        F0 = F_func(r0[0], r0[1])\n        Fmid = F_func(rmid[0], rmid[1])\n        F1 = F_func(r1[0], r1[1])\n        return (1/6) * np.dot(F0 + 4 * Fmid + F1, dr)\n\n    # 3-point Gauss-Legendre rule\n    def gauss_legendre_3pt_rule(F_func, r0, r1):\n        dr = r1 - r0\n        t = np.array([0.5 - np.sqrt(15)/10, 0.5, 0.5 + np.sqrt(15)/10])\n        w = np.array([5/18, 8/18, 5/18])\n        \n        points_x = r0[0] + t * dr[0]\n        points_y = r0[1] + t * dr[1]\n        \n        F_vals = F_func(points_x, points_y)\n        integral = np.dot(w, F_vals)\n        return np.dot(integral, dr)\n\n    quadrature_rules = [\n        (\"trap\", trapezoid_rule),\n        (\"simp\", simpson_rule),\n        (\"gl3\", gauss_legendre_3pt_rule)\n    ]\n    \n    final_results = []\n    \n    # --- 4. Main Calculation Loop ---\n    for A_true_func, F_est_func in test_cases:\n        A_true_values = A_true_func(nodes[:, 0], nodes[:, 1])\n        \n        for quad_name, quad_rule in quadrature_rules:\n            # Reconstruct potential\n            A_hat = np.zeros(N_nodes)\n            for u_idx in bfs_order:\n                if u_idx == start_node:\n                    continue\n                p_idx = predecessors[u_idx]\n                r0 = nodes[p_idx]\n                r1 = nodes[u_idx]\n                delta_A = quad_rule(F_est_func, r0, r1)\n                A_hat[u_idx] = A_hat[p_idx] + delta_A\n\n            # Calculate metrics\n            # RMSE\n            offset = np.mean(A_hat - A_true_values)\n            rmse = np.sqrt(np.mean((A_hat - A_true_values - offset)**2))\n            \n            # Smoothness S\n            squared_diffs = []\n            for u_idx, v_idx in edges:\n                diff = A_hat[u_idx] - A_hat[v_idx]\n                squared_diffs.append(diff**2)\n            s_metric = np.mean(squared_diffs)\n            \n            final_results.extend([rmse, s_metric])\n\n    # --- 5. Final Output ---\n    print(f\"[{','.join(f'{x:.12f}' for x in final_results)}]\")\n\nsolve()\n```", "id": "3394473"}]}