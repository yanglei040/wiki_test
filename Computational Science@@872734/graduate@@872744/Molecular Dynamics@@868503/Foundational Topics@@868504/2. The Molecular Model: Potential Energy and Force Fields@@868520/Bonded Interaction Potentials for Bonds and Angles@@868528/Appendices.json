{"hands_on_practices": [{"introduction": "This first practice grounds your understanding of molecular dynamics in its most fundamental calculation: deriving atomic forces from a potential energy function. You will begin with the simplest bonded interaction, the harmonic bond potential $U(r) = \\frac{1}{2} k_b (r - r_0)^2$, and apply the chain rule to the gradient operator to find the force vectors on each atom. This exercise not only translates a simple scalar potential into the directed forces that drive motion but also provides a direct, satisfying verification of Newton's third law in a molecular context. [@problem_id:3399229]", "problem": "Consider two atoms connected by a bond in a Molecular Dynamics (MD) simulation. The atoms have position vectors $\\mathbf{r}_1$ and $\\mathbf{r}_2$ in three-dimensional space, with $\\mathbf{r}_1 = (0.000, 0.000, 0.000)$ nm and $\\mathbf{r}_2 = (0.140, 0.060, -0.020)$ nm. Let the bond length be $r = |\\mathbf{r}_2 - \\mathbf{r}_1|$ and the equilibrium bond length be $r_0 = 0.154$ nm. In the harmonic approximation about $r_0$ with curvature (bond force constant) $k_b$ at the minimum, the bonded interaction potential energy is expanded to second order in the bond extension $r - r_0$ with curvature $k_b = 1200$ kJ mol⁻¹ nm⁻².\n\nStarting from first principles, specifically Newton’s second law and the definition of conservative force as the negative gradient of potential energy, derive the force vectors on each atom as functions of $k_b$, $r_0$, and the atom positions. Then use the provided numerical values to compute the force magnitude and direction on each atom for the given bond extension. Explicitly demonstrate Newton’s third law by showing that the forces on the two atoms are equal in magnitude and opposite in direction.\n\nProvide your final numerical answer as the ordered six-tuple $(F_{1x}, F_{1y}, F_{1z}, F_{2x}, F_{2y}, F_{2z})$ corresponding to the force components on atoms $1$ and $2$, expressed in $\\text{kJ mol}^{-1} \\text{nm}^{-1}$. Round each component to four significant figures. The answer must be a single analytic or numeric expression.", "solution": "The problem is evaluated as scientifically grounded, well-posed, and complete. All necessary parameters are provided, and the requested derivation and calculation are based on fundamental principles of classical mechanics. The numerical values are physically realistic for a covalent bond. Therefore, the problem is valid, and a solution is provided below.\n\nThe force $\\mathbf{F}_i$ on an atom $i$ is derived from the potential energy $U$ via the conservative force definition, which states that the force is the negative gradient of the potential with respect to the atom's position coordinates $\\mathbf{r}_i$:\n$$\n\\mathbf{F}_i = -\\nabla_{\\mathbf{r}_i} U\n$$\nThe bonded interaction potential is given by the harmonic approximation, expanded to second order around the equilibrium bond length $r_0$:\n$$\nU(r) = \\frac{1}{2} k_b (r - r_0)^2\n$$\nwhere $k_b$ is the bond force constant, and $r$ is the instantaneous bond length. The bond length $r$ is the magnitude of the interatomic distance vector $\\mathbf{r}_{12} = \\mathbf{r}_2 - \\mathbf{r}_1$:\n$$\nr = |\\mathbf{r}_{12}| = |\\mathbf{r}_2 - \\mathbf{r}_1| = \\sqrt{(x_2-x_1)^2 + (y_2-y_1)^2 + (z_2-z_1)^2}\n$$\nThe potential $U$ is a function of the scalar distance $r$, which in turn is a function of the vector coordinates $\\mathbf{r}_1$ and $\\mathbf{r}_2$. To find the force on atom $1$, we apply the chain rule for differentiation:\n$$\n\\mathbf{F}_1 = -\\nabla_{\\mathbf{r}_1} U(r(\\mathbf{r}_1, \\mathbf{r}_2)) = -\\frac{dU}{dr} \\nabla_{\\mathbf{r}_1} r\n$$\nFirst, we compute the derivative of the potential with respect to the bond length $r$:\n$$\n\\frac{dU}{dr} = \\frac{d}{dr} \\left[ \\frac{1}{2} k_b (r - r_0)^2 \\right] = k_b (r - r_0)\n$$\nNext, we compute the gradient of the bond length $r$ with respect to the position of atom $1$, $\\mathbf{r}_1 = (x_1, y_1, z_1)$:\n$$\n\\nabla_{\\mathbf{r}_1} r = \\left( \\frac{\\partial r}{\\partial x_1}, \\frac{\\partial r}{\\partial y_1}, \\frac{\\partial r}{\\partial z_1} \\right)\n$$\nThe partial derivatives are:\n$$\n\\frac{\\partial r}{\\partial x_1} = \\frac{\\partial}{\\partial x_1} \\sqrt{(x_2-x_1)^2 + (y_2-y_1)^2 + (z_2-z_1)^2} = \\frac{1}{2r} \\cdot 2(x_2-x_1)(-1) = -\\frac{x_2-x_1}{r}\n$$\nSimilarly, $\\frac{\\partial r}{\\partial y_1} = -\\frac{y_2-y_1}{r}$ and $\\frac{\\partial r}{\\partial z_1} = -\\frac{z_2-z_1}{r}$. Combining these components gives the gradient vector:\n$$\n\\nabla_{\\mathbf{r}_1} r = -\\frac{\\mathbf{r}_2 - \\mathbf{r}_1}{r} = -\\frac{\\mathbf{r}_{12}}{r} = -\\hat{\\mathbf{r}}_{12}\n$$\nwhere $\\hat{\\mathbf{r}}_{12}$ is the unit vector pointing from atom $1$ to atom $2$.\n\nSubstituting these results back into the expression for $\\mathbf{F}_1$:\n$$\n\\mathbf{F}_1 = - \\left( k_b(r-r_0) \\right) \\left( -\\frac{\\mathbf{r}_{12}}{r} \\right) = k_b(r-r_0) \\frac{\\mathbf{r}_{12}}{r} = k_b(r-r_0)\\hat{\\mathbf{r}}_{12}\n$$\nSimilarly, for the force on atom $2$, $\\mathbf{F}_2$:\n$$\n\\mathbf{F}_2 = -\\nabla_{\\mathbf{r}_2} U(r(\\mathbf{r}_1, \\mathbf{r}_2)) = -\\frac{dU}{dr} \\nabla_{\\mathbf{r}_2} r\n$$\nThe gradient of $r$ with respect to $\\mathbf{r}_2$ is:\n$$\n\\frac{\\partial r}{\\partial x_2} = \\frac{1}{2r} \\cdot 2(x_2-x_1)(1) = \\frac{x_2-x_1}{r}\n$$\nThis leads to:\n$$\n\\nabla_{\\mathbf{r}_2} r = \\frac{\\mathbf{r}_2 - \\mathbf{r}_1}{r} = \\frac{\\mathbf{r}_{12}}{r} = \\hat{\\mathbf{r}}_{12}\n$$\nSubstituting into the expression for $\\mathbf{F}_2$:\n$$\n\\mathbf{F}_2 = - \\left( k_b(r-r_0) \\right) \\left( \\frac{\\mathbf{r}_{12}}{r} \\right) = -k_b(r-r_0)\\hat{\\mathbf{r}}_{12}\n$$\nComparing the expressions for $\\mathbf{F}_1$ and $\\mathbf{F}_2$, we see that $\\mathbf{F}_1 = -\\mathbf{F}_2$. This explicitly demonstrates Newton's third law: the forces on the two atoms are equal in magnitude and opposite in direction.\n\nNow, we proceed with the numerical calculation using the provided values:\n$\\mathbf{r}_1 = (0.000, 0.000, 0.000)\\,\\mathrm{nm}$, $\\mathbf{r}_2 = (0.140, 0.060, -0.020)\\,\\mathrm{nm}$, $r_0 = 0.154\\,\\mathrm{nm}$, and $k_b = 1200\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-2}$.\n\nFirst, we calculate the bond vector $\\mathbf{r}_{12}$:\n$$\n\\mathbf{r}_{12} = \\mathbf{r}_2 - \\mathbf{r}_1 = (0.140 - 0.000, 0.060 - 0.000, -0.020 - 0.000)\\,\\mathrm{nm} = (0.140, 0.060, -0.020)\\,\\mathrm{nm}\n$$\nNext, we calculate the current bond length $r$:\n$$\nr = |\\mathbf{r}_{12}| = \\sqrt{(0.140)^2 + (0.060)^2 + (-0.020)^2}\\,\\mathrm{nm} = \\sqrt{0.0196 + 0.0036 + 0.0004}\\,\\mathrm{nm}\n$$\n$$\nr = \\sqrt{0.0236}\\,\\mathrm{nm} \\approx 0.1536229\\,\\mathrm{nm}\n$$\nThe bond is compressed, as $r  r_0$. This implies a repulsive force pushing the atoms apart.\n\nWe now calculate the scalar force magnitude term, $k_b(r-r_0)$:\n$$\nk_b(r - r_0) = 1200\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-2} \\times (0.1536229\\,\\mathrm{nm} - 0.154\\,\\mathrm{nm})\n$$\n$$\nk_b(r - r_0) = 1200 \\times (-0.0003771)\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-1} \\approx -0.45252\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-1}\n$$\nNow we compute the force vectors. The unit vector $\\hat{\\mathbf{r}}_{12}$ is:\n$$\n\\hat{\\mathbf{r}}_{12} = \\frac{\\mathbf{r}_{12}}{r} = \\frac{(0.140, 0.060, -0.020)}{0.1536229}\n$$\nThe force on atom $1$ is:\n$$\n\\mathbf{F}_1 = k_b(r-r_0)\\hat{\\mathbf{r}}_{12} \\approx -0.45252 \\times \\frac{(0.140, 0.060, -0.020)}{0.1536229} \\approx (-0.41237, -0.17673, 0.05891)\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-1}\n$$\nThis force is in the direction opposite to $\\mathbf{r}_{12}$, pushing atom $1$ away from atom $2$.\n\nThe force on atom $2$ is:\n$$\n\\mathbf{F}_2 = -\\mathbf{F}_1 \\approx (0.41237, 0.17673, -0.05891)\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-1}\n$$\nThis force is in the direction of $\\mathbf{r}_{12}$, pushing atom $2$ away from atom $1$.\n\nThe magnitude of the force on each atom is:\n$$\n|\\mathbf{F}_1| = |\\mathbf{F}_2| = |k_b(r-r_0)| \\approx |-0.45252|\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-1} \\approx 0.4525\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-1}.\n$$\nThe direction of $\\mathbf{F}_1$ is along $-\\hat{\\mathbf{r}}_{12}$ and the direction of $\\mathbf{F}_2$ is along $\\hat{\\mathbf{r}}_{12}$.\n\nRounding the force components to four significant figures as requested:\n$F_{1x} = -0.4124\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-1}$\n$F_{1y} = -0.1767\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-1}$\n$F_{1z} = 0.05891\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-1}$\n$F_{2x} = 0.4124\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-1}$\n$F_{2y} = 0.1767\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-1}$\n$F_{2z} = -0.05891\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-1}$\n\nThe final answer is the ordered six-tuple $(F_{1x}, F_{1y}, F_{1z}, F_{2x}, F_{2y}, F_{2z})$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n-0.4124  -0.1767  0.05891  0.4124  0.1767  -0.05891\n\\end{pmatrix}\n}\n$$", "id": "3399229"}, {"introduction": "Moving from two-body to three-body interactions, this practice addresses the ubiquitous angle bending potential. You will implement the force calculation for a harmonic angle potential, which requires a more careful application of the chain rule due to the geometric definition of the angle. Critically, you will then verify that your implementation correctly conserves both linear and angular momentum, a fundamental requirement for any valid internal force in a physical system and a non-negotiable test for any robust MD simulation code. [@problem_id:3399277]", "problem": "You are to implement a self-contained program that, for a single angular bonded interaction in Molecular Dynamics (MD), computes the forces on three atoms and verifies two conservation properties: linear momentum conservation (sum of forces equals zero) and angular momentum conservation (sum of torques about an arbitrary origin equals zero). The interaction is defined by an angle at atom $j$ formed by the two bonds $(i,j)$ and $(k,j)$. The goal is to derive the force expressions from first principles and then numerically check the conservation laws to high precision.\n\nFundamental base to use:\n- Newton's Second Law and the definition of conservative forces: the force on atom $n$ is $\\mathbf{F}_n = -\\nabla_{\\mathbf{r}_n} U$, where $U$ is the potential energy and $\\mathbf{r}_n$ is the position vector of atom $n$.\n- The angle potential for a single angle interaction is a function of the angle $\\theta$ only, with the potential energy $U(\\theta)$ given by a harmonic form $U(\\theta) = \\frac{1}{2} k_\\theta (\\theta - \\theta_0)^2$, where $k_\\theta$ is the angle stiffness and $\\theta_0$ is the equilibrium angle.\n- Angle definition at the vertex $j$: let $\\mathbf{a} = \\mathbf{r}_i - \\mathbf{r}_j$ and $\\mathbf{b} = \\mathbf{r}_k - \\mathbf{r}_j$, then the angle $\\theta$ satisfies $\\cos\\theta = \\frac{\\mathbf{a} \\cdot \\mathbf{b}}{\\|\\mathbf{a}\\| \\|\\mathbf{b}\\|}$.\n- Forces are computed using the chain rule from $U(\\theta)$ to position derivatives, without assuming any shortcut expressions or tabulated formulas beyond the fundamentals specified above.\n\nAngle units: all angles must be in radians.\n\nNumerical verification tasks:\n- Compute $\\mathbf{F}_i$, $\\mathbf{F}_j$, and $\\mathbf{F}_k$ from $U(\\theta)$ and the positions $\\mathbf{r}_i$, $\\mathbf{r}_j$, $\\mathbf{r}_k$ using the gradient relation $\\mathbf{F}_n = -\\nabla_{\\mathbf{r}_n} U(\\theta)$.\n- Verify linear momentum conservation: check that $\\mathbf{F}_i + \\mathbf{F}_j + \\mathbf{F}_k$ equals $\\mathbf{0}$ within a specified numerical tolerance.\n- Verify angular momentum conservation: for each specified origin $\\mathbf{o}$, compute the net torque $\\boldsymbol{\\tau}_{\\text{net}}(\\mathbf{o}) = (\\mathbf{r}_i - \\mathbf{o}) \\times \\mathbf{F}_i + (\\mathbf{r}_j - \\mathbf{o}) \\times \\mathbf{F}_j + (\\mathbf{r}_k - \\mathbf{o}) \\times \\mathbf{F}_k$ and check that it equals $\\mathbf{0}$ within the same tolerance.\n\nTolerance requirement:\n- Use a strict tolerance of $\\varepsilon = 10^{-10}$ for the norms of the net force and each net torque vector. That is, accept conservation if the Euclidean norm is less than or equal to $\\varepsilon$.\n\nTest suite:\nImplement your program to evaluate the following five test cases. In each case, angles are in radians and positions are in Cartesian coordinates (unitless for this task). The parameter $k_\\theta$ has units of energy per radian squared, but you need not assume any particular units for energy; the verification is dimensionless.\n\n- Case $1$ (general $3$-dimensional configuration):\n  - $\\mathbf{r}_i = [0.0, 0.0, 0.0]$\n  - $\\mathbf{r}_j = [1.0, 0.0, 0.0]$\n  - $\\mathbf{r}_k = [1.0, 1.0, 0.0]$\n  - $k_\\theta = 100.0$\n  - $\\theta_0 = 1.2$\n- Case $2$ (right angle at the origin):\n  - $\\mathbf{r}_i = [1.0, 0.0, 0.0]$\n  - $\\mathbf{r}_j = [0.0, 0.0, 0.0]$\n  - $\\mathbf{r}_k = [0.0, 1.0, 0.0]$\n  - $k_\\theta = 50.0$\n  - $\\theta_0 = \\pi/2$\n- Case $3$ (near-collinear configuration):\n  - $\\mathbf{r}_i = [-1.0, 0.0, 0.0]$\n  - $\\mathbf{r}_j = [0.0, 0.0, 0.0]$\n  - $\\mathbf{r}_k = [1.0, 10^{-6}, 0.0]$\n  - $k_\\theta = 0.001$\n  - $\\theta_0 = \\pi$\n- Case $4$ (random $3$-dimensional configuration):\n  - $\\mathbf{r}_i = [0.2, -0.7, 1.1]$\n  - $\\mathbf{r}_j = [-0.3, 0.4, -0.5]$\n  - $\\mathbf{r}_k = [0.9, 0.3, 0.2]$\n  - $k_\\theta = 10.0$\n  - $\\theta_0 = 1.0$\n- Case $5$ (small bond length on one side):\n  - $\\mathbf{r}_i = [10^{-4}, 0.0, 0.0]$\n  - $\\mathbf{r}_j = [0.0, 0.0, 0.0]$\n  - $\\mathbf{r}_k = [0.0, 1.0, 0.0]$\n  - $k_\\theta = 200.0$\n  - $\\theta_0 = \\pi/3$\n\nFor each case, check torque conservation about three origins:\n- $\\mathbf{o}_1 = [0.0, 0.0, 0.0]$\n- $\\mathbf{o}_2 = \\mathbf{r}_j$ (the vertex atom position)\n- $\\mathbf{o}_3 = [0.5, -1.0, 2.0]$\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element corresponds to one test case and is a boolean indicating whether both conservation checks passed for that case (net force norm $\\le \\varepsilon$ and each net torque norm $\\le \\varepsilon$). For example, the output should look like `[True,False,...]`.", "solution": "The problem is valid as it is scientifically grounded in classical mechanics, well-posed with a complete set of definitions and data, and objective in its formulation. It presents a standard, non-trivial problem in computational physics that is solvable using the provided principles.\n\nThe solution is derived from the fundamental principle that a conservative force is the negative gradient of its potential energy. For the force on atom $n$ with position vector $\\mathbf{r}_n$, this is expressed as $\\mathbf{F}_n = -\\nabla_{\\mathbf{r}_n} U$. The potential energy $U$ for an angle interaction is a function only of the angle $\\theta$ between the vectors $\\mathbf{a} = \\mathbf{r}_i - \\mathbf{r}_j$ and $\\mathbf{b} = \\mathbf{r}_k - \\mathbf{r}_j$. The specified harmonic form is $U(\\theta) = \\frac{1}{2} k_\\theta (\\theta - \\theta_0)^2$.\n\nTo compute the forces, we apply the chain rule:\n$$\n\\mathbf{F}_n = -\\frac{dU}{d\\theta} \\nabla_{\\mathbf{r}_n} \\theta\n$$\nThe first term is straightforward:\n$$\n\\frac{dU}{d\\theta} = k_\\theta (\\theta - \\theta_0)\n$$\nTo find the gradient of the angle, $\\nabla_{\\mathbf{r}_n} \\theta$, it is more convenient to first compute the gradient of $\\cos\\theta$. Differentiating the relation $\\cos\\theta = \\frac{\\mathbf{a} \\cdot \\mathbf{b}}{\\|\\mathbf{a}\\| \\|\\mathbf{b}\\|}$ with respect to $\\theta$ yields $-\\sin\\theta$. Using the chain rule again, $\\nabla_{\\mathbf{r}_n} (\\cos\\theta) = -\\sin\\theta \\, (\\nabla_{\\mathbf{r}_n} \\theta)$, which gives:\n$$\n\\nabla_{\\mathbf{r}_n} \\theta = -\\frac{1}{\\sin\\theta} \\nabla_{\\mathbf{r}_n} (\\cos\\theta)\n$$\nThis expression is undefined for collinear configurations where $\\theta=0$ or $\\theta=\\pi$, but the provided test cases avoid these exact singularities.\n\nCombining these results gives the force expression:\n$$\n\\mathbf{F}_n = \\frac{k_\\theta (\\theta - \\theta_0)}{\\sin\\theta} \\nabla_{\\mathbf{r}_n} (\\cos\\theta)\n$$\n\nThe next step is to derive the gradients of $\\cos\\theta = \\frac{\\mathbf{a} \\cdot \\mathbf{b}}{ab}$, where $a = \\|\\mathbf{a}\\|$ and $b = \\|\\mathbf{b}\\|$. Let $\\hat{\\mathbf{a}} = \\mathbf{a}/a$ and $\\hat{\\mathbf{b}} = \\mathbf{b}/b$ be the unit vectors.\n\nFor atom $i$, $\\mathbf{r}_i$ only appears in $\\mathbf{a}$. Using standard vector calculus identities, the gradient is:\n$$\n\\nabla_{\\mathbf{r}_i} (\\cos\\theta) = \\nabla_{\\mathbf{r}_i} (\\hat{\\mathbf{a}} \\cdot \\hat{\\mathbf{b}}) = \\frac{1}{ab} \\left( \\mathbf{b} - \\frac{(\\mathbf{a} \\cdot \\mathbf{b})}{a^2} \\mathbf{a} \\right) = \\frac{\\hat{\\mathbf{b}} - \\cos\\theta \\, \\hat{\\mathbf{a}}}{a}\n$$\nThus, the force on atom $i$ is:\n$$\n\\mathbf{F}_i = \\frac{k_\\theta (\\theta - \\theta_0)}{\\sin\\theta} \\left( \\frac{\\hat{\\mathbf{b}} - \\cos\\theta \\, \\hat{\\mathbf{a}}}{a} \\right)\n$$\nBy symmetry, swapping $\\mathbf{a}$ with $\\mathbf{b}$ and $i$ with $k$, the force on atom $k$ is:\n$$\n\\mathbf{F}_k = \\frac{k_\\theta (\\theta - \\theta_0)}{\\sin\\theta} \\left( \\frac{\\hat{\\mathbf{a}} - \\cos\\theta \\, \\hat{\\mathbf{b}}}{b} \\right)\n$$\nThe force on the central atom $j$ can be found by noting that the potential energy $U$ depends only on the relative positions of the atoms. This translational invariance dictates that the sum of all forces must be zero (conservation of linear momentum). Therefore:\n$$\n\\mathbf{F}_j = -(\\mathbf{F}_i + \\mathbf{F}_k)\n$$\nThe numerical verification of $\\|\\mathbf{F}_i + \\mathbf{F}_j + \\mathbf{F}_k\\| \\le \\varepsilon$ where $\\varepsilon=10^{-10}$ serves as a check on the computational implementation and floating-point precision.\n\nFor angular momentum conservation, we must verify that the net torque $\\boldsymbol{\\tau}_{\\text{net}}$ about an arbitrary origin $\\mathbf{o}$ is zero. The net torque is given by:\n$$\n\\boldsymbol{\\tau}_{\\text{net}}(\\mathbf{o}) = \\sum_{n=i,j,k} (\\mathbf{r}_n - \\mathbf{o}) \\times \\mathbf{F}_n\n$$\nSince $\\sum \\mathbf{F}_n = \\mathbf{0}$, we can write $\\boldsymbol{\\tau}_{\\text{net}}(\\mathbf{o}) = \\sum \\mathbf{r}_n \\times \\mathbf{F}_n - \\mathbf{o} \\times (\\sum \\mathbf{F}_n) = \\sum \\mathbf{r}_n \\times \\mathbf{F}_n$. This demonstrates that the net torque is independent of the choice of origin. We can prove it is zero by choosing a convenient origin, such as the position of the vertex atom, $\\mathbf{o} = \\mathbf{r}_j$:\n$$\n\\boldsymbol{\\tau}_{\\text{net}}(\\mathbf{r}_j) = (\\mathbf{r}_i - \\mathbf{r}_j) \\times \\mathbf{F}_i + (\\mathbf{r}_j - \\mathbf{r}_j) \\times \\mathbf{F}_j + (\\mathbf{r}_k - \\mathbf{r}_j) \\times \\mathbf{F}_k = \\mathbf{a} \\times \\mathbf{F}_i + \\mathbf{b} \\times \\mathbf{F}_k\n$$\nSubstituting the force expressions and letting $C = \\frac{k_\\theta (\\theta - \\theta_0)}{\\sin\\theta}$:\n$$\n\\mathbf{a} \\times \\mathbf{F}_i = \\mathbf{a} \\times C \\left( \\frac{\\hat{\\mathbf{b}} - \\cos\\theta \\, \\hat{\\mathbf{a}}}{a} \\right) = \\frac{C}{a} (\\mathbf{a} \\times \\hat{\\mathbf{b}}) = C (\\hat{\\mathbf{a}} \\times \\hat{\\mathbf{b}})\n$$\n$$\n\\mathbf{b} \\times \\mathbf{F}_k = \\mathbf{b} \\times C \\left( \\frac{\\hat{\\mathbf{a}} - \\cos\\theta \\, \\hat{\\mathbf{b}}}{b} \\right) = \\frac{C}{b} (\\mathbf{b} \\times \\hat{\\mathbf{a}}) = C (\\hat{\\mathbf{b}} \\times \\hat{\\mathbf{a}})\n$$\nSumming these two terms gives:\n$$\n\\boldsymbol{\\tau}_{\\text{net}}(\\mathbf{r}_j) = C (\\hat{\\mathbf{a}} \\times \\hat{\\mathbf{b}} + \\hat{\\mathbf{b}} \\times \\hat{\\mathbf{a}}) = C (\\hat{\\mathbf{a}} \\times \\hat{\\mathbf{b}} - \\hat{\\mathbf{a}} \\times \\hat{\\mathbf{b}}) = \\mathbf{0}\n$$\nThis analytical result confirms that the forces, if calculated correctly, will conserve angular momentum. The numerical verification $\\|\\boldsymbol{\\tau}_{\\text{net}}(\\mathbf{o})\\| \\le \\varepsilon$ for all specified origins provides a robust test of the force calculation's correctness.\n\nThe implementation will compute vectors $\\mathbf{a}$ and $\\mathbf{b}$, their norms, and the angle $\\theta = \\arccos(\\hat{\\mathbf{a}} \\cdot \\hat{\\mathbf{b}})$. A numerically safe practice is to clip the argument of $\\arccos$ to the range $[-1, 1]$. Then, forces $\\mathbf{F}_i$ and $\\mathbf{F}_k$ are computed, followed by $\\mathbf{F}_j = -(\\mathbf{F}_i + \\mathbf{F}_k)$. Finally, the norms of the net force and net torques (for each specified origin) are compared against the tolerance $\\varepsilon$ to determine the validity of the conservation laws for each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (general 3-dimensional configuration)\n        {\n            \"ri\": np.array([0.0, 0.0, 0.0]),\n            \"rj\": np.array([1.0, 0.0, 0.0]),\n            \"rk\": np.array([1.0, 1.0, 0.0]),\n            \"k_theta\": 100.0,\n            \"theta_0\": 1.2\n        },\n        # Case 2 (right angle at the origin)\n        {\n            \"ri\": np.array([1.0, 0.0, 0.0]),\n            \"rj\": np.array([0.0, 0.0, 0.0]),\n            \"rk\": np.array([0.0, 1.0, 0.0]),\n            \"k_theta\": 50.0,\n            \"theta_0\": np.pi / 2\n        },\n        # Case 3 (near-collinear configuration)\n        {\n            \"ri\": np.array([-1.0, 0.0, 0.0]),\n            \"rj\": np.array([0.0, 0.0, 0.0]),\n            \"rk\": np.array([1.0, 1e-6, 0.0]),\n            \"k_theta\": 0.001,\n            \"theta_0\": np.pi\n        },\n        # Case 4 (random 3-dimensional configuration)\n        {\n            \"ri\": np.array([0.2, -0.7, 1.1]),\n            \"rj\": np.array([-0.3, 0.4, -0.5]),\n            \"rk\": np.array([0.9, 0.3, 0.2]),\n            \"k_theta\": 10.0,\n            \"theta_0\": 1.0\n        },\n        # Case 5 (small bond length on one side)\n        {\n            \"ri\": np.array([1e-4, 0.0, 0.0]),\n            \"rj\": np.array([0.0, 0.0, 0.0]),\n            \"rk\": np.array([0.0, 1.0, 0.0]),\n            \"k_theta\": 200.0,\n            \"theta_0\": np.pi / 3\n        }\n    ]\n\n    origins = [\n        np.array([0.0, 0.0, 0.0]),\n        None,  # Placeholder for r_j\n        np.array([0.5, -1.0, 2.0])\n    ]\n    tolerance = 1e-10\n\n    results = []\n    for i, case in enumerate(test_cases):\n        # Set the second origin to be the vertex atom's position r_j\n        current_origins = origins[:]\n        current_origins[1] = case[\"rj\"]\n        \n        result = compute_and_verify(\n            case[\"ri\"], case[\"rj\"], case[\"rk\"],\n            case[\"k_theta\"], case[\"theta_0\"],\n            current_origins, tolerance\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_and_verify(ri, rj, rk, k_theta, theta_0, origins, tolerance):\n    \"\"\"\n    Computes forces for a three-atom angle and verifies conservation laws.\n\n    Args:\n        ri (np.ndarray): Position vector of atom i.\n        rj (np.ndarray): Position vector of atom j (vertex).\n        rk (np.ndarray): Position vector of atom k.\n        k_theta (float): Angle stiffness constant.\n        theta_0 (float): Equilibrium angle in radians.\n        origins (list of np.ndarray): Origins for torque calculation.\n        tolerance (float): Numerical tolerance for verification.\n\n    Returns:\n        bool: True if all conservation laws are met, False otherwise.\n    \"\"\"\n    # 1. Compute vectors from the central atom j\n    a_vec = ri - rj\n    b_vec = rk - rj\n\n    # 2. Compute vector norms (bond lengths)\n    a_norm = np.linalg.norm(a_vec)\n    b_norm = np.linalg.norm(b_vec)\n\n    # Prevent division by zero if a bond length is zero\n    if a_norm == 0 or b_norm == 0:\n        return False # Invalid configuration for angle potential\n\n    # 3. Compute unit vectors\n    a_hat = a_vec / a_norm\n    b_hat = b_vec / b_norm\n\n    # 4. Compute the angle theta\n    # Clip to handle potential floating-point inaccuracies\n    cos_theta = np.clip(np.dot(a_hat, b_hat), -1.0, 1.0)\n    theta = np.arccos(cos_theta)\n\n    # 5. Compute the derivative of potential energy w.r.t. theta\n    dU_dtheta = k_theta * (theta - theta_0)\n    \n    # Check for collinear cases to avoid division by zero\n    sin_theta = np.sin(theta)\n    if np.isclose(sin_theta, 0.0):\n        # If theta is near 0 or pi, and it is the equilibrium angle, forces are zero.\n        if np.isclose(theta, theta_0):\n            Fi, Fj, Fk = np.zeros(3), np.zeros(3), np.zeros(3)\n        else:\n            # The formula has a 0/0 form near equilibrium, use L'Hopital's rule limit.\n            # C = k_theta * (theta - theta_0) / sin(theta)\n            # as theta - theta_0 (where theta_0 is 0 or pi), C - k_theta * sign(theta-theta_0) * 1\n            # But forces should be orthogonal to the bond axis, which is ill-defined.\n            # MD engines handle this with specific routines. For this problem's scope,\n            # this indicates a potentially unstable calculation. However, test case 3\n            # is near-collinear and has a non-zero force, handled by the general formula.\n            # If sin_theta is truly zero, it's a singularity unless dU_dtheta is also zero.\n            return False # Unstable case not handled beyond equilibrium\n\n    # 6. Compute forces using the derived formulas\n    # Pre-factor from the chain rule\n    C = dU_dtheta / sin_theta\n    \n    Fi = C * (b_hat - cos_theta * a_hat) / a_norm\n    Fk = C * (a_hat - cos_theta * b_hat) / b_norm\n    \n    # Force on the central atom by translational invariance\n    Fj = -(Fi + Fk)\n\n    # 7. Verify linear momentum conservation\n    F_net = Fi + Fj + Fk\n    if np.linalg.norm(F_net)  tolerance:\n        return False\n\n    # 8. Verify angular momentum conservation for each origin\n    for o in origins:\n        tau_i = np.cross(ri - o, Fi)\n        tau_j = np.cross(rj - o, Fj)\n        tau_k = np.cross(rk - o, Fk)\n        tau_net = tau_i + tau_j + tau_k\n        if np.linalg.norm(tau_net)  tolerance:\n            return False\n\n    # If all checks pass\n    return True\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3399277"}, {"introduction": "The choice of a potential's functional form is not merely an academic exercise; it has profound consequences for the numerical stability of a simulation. This hands-on problem delves into a classic challenge: the singularity in the force calculation for standard harmonic angle potentials in near-linear molecules. By implementing and comparing the numerical behavior of a traditional $\\theta$-based potential against a more robust formulation based on $\\cos\\theta$, you will gain tangible insight into a critical aspect of force field design and the reasons behind specific choices made in production-level MD software. [@problem_id:3399282]", "problem": "You are to construct a three-atom test system and compute bonded angle forces using two different potential formulations, then compare their numerical behavior near linear geometries. The system involves three point particles with positions $\\mathbf{r}_i$, $\\mathbf{r}_j$, and $\\mathbf{r}_k$, forming a single angle at atom $j$ via the vectors $\\mathbf{a} = \\mathbf{r}_i - \\mathbf{r}_j$ and $\\mathbf{b} = \\mathbf{r}_k - \\mathbf{r}_j$. The angle $\\theta$ is defined by the dot product, where $\\cos\\theta = \\dfrac{\\mathbf{a}\\cdot\\mathbf{b}}{\\lVert \\mathbf{a}\\rVert \\lVert \\mathbf{b}\\rVert}$. The fundamental base you should use is Newton's second law and the definition of conservative forces as gradients of potentials: for a potential energy $U$, the force on coordinate $\\mathbf{r}$ is $\\mathbf{F} = -\\nabla_{\\mathbf{r}} U$. Use the chain rule to express forces via derivatives of $\\theta$ or $\\cos\\theta$ with respect to Cartesian coordinates.\n\nConsider two angle potential formulations:\n1. A harmonic angle potential in the angle variable $\\theta$: $U_\\theta(\\theta) = \\dfrac{k}{2}\\left(\\theta - \\theta_0\\right)^2$.\n2. A harmonic potential in the cosine of the angle: $U_c(\\cos\\theta) = \\dfrac{k_c}{2}\\left(\\cos\\theta - \\cos\\theta_0\\right)^2$.\n\nYour derivation should start from the definitions of $\\theta$, $\\cos\\theta$, and the gradient rule $\\mathbf{F} = -\\nabla U$, and proceed to obtain expressions for the forces on the three atoms for each potential using the chain rule. The algorithmic implementation should avoid unphysical shortcuts and must directly reflect the mathematical derivation.\n\nConstruct the following test molecule geometry for each test case: place atom $j$ at the origin $\\mathbf{r}_j = (0,0,0)$, place atom $i$ at $\\mathbf{r}_i = (-1,0,0)$, and place atom $k$ at $\\mathbf{r}_k = (1,\\varepsilon,0)$, with $\\varepsilon$ specified per test case. This produces a near-linear angle at $j$ when $\\varepsilon$ is small. Use dimensionless units for positions and forces, and measure angles in radians. Take $k = 1$ and $k_c = 1$, with $\\theta_0 = \\pi$ and $\\cos\\theta_0 = -1$.\n\nFor each test case, compute the maximum force magnitude among the three atoms for the $\\theta$-based potential and for the $\\cos\\theta$-based potential. Specifically, compute\n$$\nF_{\\max}^{(\\theta)} = \\max(\\lVert \\mathbf{F}_i^{(\\theta)}\\rVert, \\lVert \\mathbf{F}_j^{(\\theta)}\\rVert, \\lVert \\mathbf{F}_k^{(\\theta)}\\rVert),\\quad\nF_{\\max}^{(c)} = \\max(\\lVert \\mathbf{F}_i^{(c)}\\rVert, \\lVert \\mathbf{F}_j^{(c)}\\rVert, \\lVert \\mathbf{F}_k^{(c)}\\rVert),\n$$\nwhere superscripts $(\\theta)$ and $(c)$ denote forces computed from $U_\\theta(\\theta)$ and $U_c(\\cos\\theta)$ respectively.\n\nTest suite (dimensionless $\\varepsilon$ values):\n- Case 1 (exactly linear): $\\varepsilon = 0.0$.\n- Case 2 (extremely close to linear): $\\varepsilon = 10^{-9}$.\n- Case 3 (very close to linear): $\\varepsilon = 10^{-6}$.\n- Case 4 (near linear): $\\varepsilon = 10^{-3}$.\n- Case 5 (moderately bent): $\\varepsilon = 2\\times 10^{-1}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $[F_{\\max}^{(\\theta)}\\text{(Case 1)},F_{\\max}^{(c)}\\text{(Case 1)},F_{\\max}^{(\\theta)}\\text{(Case 2)},F_{\\max}^{(c)}\\text{(Case 2)},\\dots,F_{\\max}^{(\\theta)}\\text{(Case 5)},F_{\\max}^{(c)}\\text{(Case 5)}]$. All outputs are real numbers (floats) in dimensionless units. Angles must be treated in radians throughout.", "solution": "The problem requires the calculation and comparison of atomic forces derived from two distinct bonded angle potential energy functions, particularly in the regime of near-linear angles. The foundation for this calculation is the relationship between a conservative force $\\mathbf{F}$ and its corresponding potential energy $U$, given by $\\mathbf{F} = -\\nabla U$. The system consists of three atoms with positions $\\mathbf{r}_i$, $\\mathbf{r}_j$, and $\\mathbf{r}_k$, forming an angle at the central atom $j$.\n\nLet us define the bond vectors originating from the central atom $j$ as $\\mathbf{a} = \\mathbf{r}_i - \\mathbf{r}_j$ and $\\mathbf{b} = \\mathbf{r}_k - \\mathbf{r}_j$. The norms of these vectors are $a = \\lVert \\mathbf{a} \\rVert$ and $b = \\lVert \\mathbf{b} \\rVert$, and their corresponding unit vectors are $\\hat{\\mathbf{a}} = \\mathbf{a}/a$ and $\\hat{\\mathbf{b}} = \\mathbf{b}/b$. The angle $\\theta$ between these vectors is defined by its cosine, $\\cos\\theta = \\hat{\\mathbf{a}} \\cdot \\hat{\\mathbf{b}}$.\n\nThe force on a given atom, say atom $i$, is the negative gradient of the potential with respect to its Cartesian coordinates: $\\mathbf{F}_i = -\\nabla_{\\mathbf{r}_i} U$. Since both potential functions are expressed in terms of the angle $\\theta$, we must employ the chain rule.\n\nFor a potential $U(\\xi)$, where $\\xi$ is a function of the angle (either $\\theta$ or $\\cos\\theta$), the force on atom $i$ is:\n$$\n\\mathbf{F}_i = -\\frac{dU}{d\\xi} \\nabla_{\\mathbf{r}_i} \\xi\n$$\nSimilar expressions apply to atoms $j$ and $k$. The total force on the system is zero due to translational invariance, so $\\mathbf{F}_j = -(\\mathbf{F}_i + \\mathbf{F}_k)$. This implies we only need to derive the gradients for atoms $i$ and $k$.\n\nFirst, we derive the gradient of $\\cos\\theta$ with respect to the atomic coordinates. For atom $i$:\n$$\n\\nabla_{\\mathbf{r}_i} \\cos\\theta = \\nabla_{\\mathbf{r}_i} \\left( \\frac{\\mathbf{a} \\cdot \\mathbf{b}}{ab} \\right)\n$$\nUsing the product rule for vector calculus and the identities $\\nabla_{\\mathbf{r}_i} \\mathbf{a} = I$ (identity matrix), $\\nabla_{\\mathbf{r}_i} \\mathbf{b} = 0$, $\\nabla_{\\mathbf{r}_i} a = \\hat{\\mathbf{a}}$, and $\\nabla_{\\mathbf{r}_i} b = \\mathbf{0}$, we obtain:\n$$\n\\nabla_{\\mathbf{r}_i} \\cos\\theta = \\frac{1}{ab} (\\nabla_{\\mathbf{r}_i}(\\mathbf{a} \\cdot \\mathbf{b})) + (\\mathbf{a} \\cdot \\mathbf{b}) \\nabla_{\\mathbf{r}_i}((ab)^{-1}) = \\frac{\\mathbf{b}}{ab} - \\frac{\\mathbf{a} \\cdot \\mathbf{b}}{a^3b} \\mathbf{a} = \\frac{1}{a} \\left(\\frac{\\mathbf{b}}{b} - \\frac{\\mathbf{a} \\cdot \\mathbf{b}}{ab} \\frac{\\mathbf{a}}{a}\\right) = \\frac{\\hat{\\mathbf{b}} - (\\cos\\theta)\\hat{\\mathbf{a}}}{a}\n$$\nBy symmetry, swapping $i \\leftrightarrow k$ and $\\mathbf{a} \\leftrightarrow \\mathbf{b}$:\n$$\n\\nabla_{\\mathbf{r}_k} \\cos\\theta = \\frac{\\hat{\\mathbf{a}} - (\\cos\\theta)\\hat{\\mathbf{b}}}{b}\n$$\nThese expressions are well-defined for all non-collinear and non-coincident configurations.\n\nNow we can write the forces for both potential forms.\n\n1.  **Harmonic Cosine Potential**: $U_c = \\dfrac{k_c}{2}(\\cos\\theta - \\cos\\theta_0)^2$.\n    Here, $\\xi = \\cos\\theta$. The derivative with respect to $\\xi$ is $\\frac{dU_c}{d(\\cos\\theta)} = k_c(\\cos\\theta - \\cos\\theta_0)$.\n    The forces on atoms $i$ and $k$ are:\n    $$\n    \\mathbf{F}_i^{(c)} = -k_c(\\cos\\theta - \\cos\\theta_0) \\nabla_{\\mathbf{r}_i} \\cos\\theta = -k_c(\\cos\\theta - \\cos\\theta_0) \\frac{\\hat{\\mathbf{b}} - (\\cos\\theta)\\hat{\\mathbf{a}}}{a}\n    $$\n    $$\n    \\mathbf{F}_k^{(c)} = -k_c(\\cos\\theta - \\cos\\theta_0) \\nabla_{\\mathbf{r}_k} \\cos\\theta = -k_c(\\cos\\theta - \\cos\\theta_0) \\frac{\\hat{\\mathbf{a}} - (\\cos\\theta)\\hat{\\mathbf{b}}}{b}\n    $$\n    These force expressions are computationally stable, including at linear geometries where $\\theta = 0$ or $\\theta = \\pi$. At the equilibrium angle $\\theta_0=\\pi$, the term $(\\cos\\theta - \\cos\\theta_0)$ becomes zero, and all forces vanish, which is physically correct.\n\n2.  **Harmonic Angle Potential**: $U_\\theta = \\dfrac{k}{2}(\\theta - \\theta_0)^2$.\n    Here, $\\xi = \\theta$. The derivative is $\\frac{dU_\\theta}{d\\theta} = k(\\theta - \\theta_0)$. The gradient of $\\theta$ is found by another application of the chain rule: $\\nabla \\theta = \\frac{d\\theta}{d(\\cos\\theta)} \\nabla\\cos\\theta = \\frac{-1}{\\sin\\theta} \\nabla\\cos\\theta$.\n    The forces on atoms $i$ and $k$ are:\n    $$\n    \\mathbf{F}_i^{(\\theta)} = -k(\\theta - \\theta_0) \\nabla_{\\mathbf{r}_i} \\theta = -k(\\theta - \\theta_0) \\left( \\frac{-1}{\\sin\\theta} \\nabla_{\\mathbf{r}_i} \\cos\\theta \\right) = \\frac{k(\\theta - \\theta_0)}{\\sin\\theta} \\nabla_{\\mathbf{r}_i} \\cos\\theta\n    $$\n    $$\n    \\mathbf{F}_k^{(\\theta)} = \\frac{k(\\theta - \\theta_0)}{\\sin\\theta} \\nabla_{\\mathbf{r}_k} \\cos\\theta\n    $$\n    The term $1/\\sin\\theta$ introduces a singularity at linear geometries ($\\theta=0$ or $\\theta=\\pi$) where $\\sin\\theta=0$. For the specified equilibrium angle $\\theta_0 = \\pi$, as $\\theta \\to \\pi$, the numerator $k(\\theta - \\theta_0)$ also tends to zero. This creates a $0/0$ indeterminate form. While the analytical limit exists, its numerical evaluation via `(arccos(c) - pi) / sqrt(1 - c*c)` can lead to catastrophic cancellation and floating-point errors, making this formulation numerically unstable.\n\nFor the special case where the geometry is exactly linear ($\\varepsilon=0$), we have $\\theta=\\pi=\\theta_0$. The system is at its potential minimum for both $U_c$ and $U_\\theta$. The energy is zero, and the gradient of the energy (and thus the forces on all atoms) must be zero. The implementation will explicitly set forces to zero for this case. For $\\varepsilon > 0$, the derived formulas are applied directly to compute the forces and their maximum magnitudes. The scaling behavior near the linear geometry ($\\varepsilon \\to 0$) shows $|\\mathbf{F}^{(\\theta)}| \\sim \\varepsilon$ while $|\\mathbf{F}^{(c)}| \\sim \\varepsilon^3$, highlighting the unphysical torque exerted by the $\\theta$-based potential for small deviations from linearity.\n\nThe algorithm proceeds as follows for each value of $\\varepsilon$:\n1.  Define atomic positions $\\mathbf{r}_i, \\mathbf{r}_j, \\mathbf{r}_k$.\n2.  If $\\varepsilon=0$, the forces are zero. Return $F_{\\max}^{(\\theta)}=0$ and $F_{\\max}^{(c)}=0$.\n3.  If $\\varepsilon>0$, compute bond vectors $\\mathbf{a}, \\mathbf{b}$, their norms $a, b$, and unit vectors $\\hat{\\mathbf{a}}, \\hat{\\mathbf{b}}$.\n4.  Calculate $\\cos\\theta = \\hat{\\mathbf{a}} \\cdot \\hat{\\mathbf{b}}$ and subsequently $\\theta = \\arccos(\\cos\\theta)$ and $\\sin\\theta = \\sqrt{1 - \\cos^2\\theta}$.\n5.  Compute the gradients of $\\cos\\theta$ with respect to $\\mathbf{r}_i$ and $\\mathbf{r}_k$.\n6.  For the $U_c$ potential, calculate forces $\\mathbf{F}_i^{(c)}$, $\\mathbf{F}_k^{(c)}$, and $\\mathbf{F}_j^{(c)} = -(\\mathbf{F}_i^{(c)} + \\mathbf{F}_k^{(c)})$.\n7.  For the $U_\\theta$ potential, calculate forces $\\mathbf{F}_i^{(\\theta)}$, $\\mathbf{F}_k^{(\\theta)}$, and $\\mathbf{F}_j^{(\\theta)} = -(\\mathbf{F}_i^{(\\theta)} + \\mathbf{F}_k^{(\\theta)})$.\n8.  Compute the Euclidean norms of all force vectors and find the maximum magnitude for each potential type, $F_{\\max}^{(c)}$ and $F_{\\max}^{(\\theta)}$.\nThe results for all test cases are then collected and formatted.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_forces(epsilon):\n    \"\"\"\n    Computes maximum force magnitudes for two angle potentials for a given geometry.\n\n    Args:\n        epsilon (float): The y-coordinate of atom k, controlling the angle.\n\n    Returns:\n        tuple[float, float]: A tuple containing (F_max_theta, F_max_c).\n    \"\"\"\n    # Define physical constants and system parameters\n    k = 1.0\n    k_c = 1.0\n    theta_0 = np.pi\n    cos_theta_0 = -1.0\n\n    # Set up atom coordinates\n    r_i = np.array([-1.0, 0.0, 0.0])\n    r_j = np.array([0.0, 0.0, 0.0])\n    r_k = np.array([1.0, epsilon, 0.0])\n\n    # Handle the exactly linear case (epsilon = 0)\n    # The angle is exactly the equilibrium angle, U=0, so the forces must be zero.\n    # A naive calculation for the theta-potential would result in 0/0 (NaN).\n    if epsilon == 0.0:\n        return 0.0, 0.0\n\n    # Calculate bond vectors and their properties\n    a_vec = r_i - r_j\n    b_vec = r_k - r_j\n\n    a_norm = np.linalg.norm(a_vec)\n    b_norm = np.linalg.norm(b_vec)\n\n    a_hat = a_vec / a_norm\n    b_hat = b_vec / b_norm\n\n    # Calculate angle-related quantities\n    cos_theta = np.dot(a_hat, b_hat)\n    # Clipping can prevent domain errors in np.arccos due to floating point inaccuracies.\n    cos_theta = np.clip(cos_theta, -1.0, 1.0)\n    \n    # theta is needed for the theta-based potential.\n    theta = np.arccos(cos_theta)\n    \n    # sin_theta is required for the derivative d(theta)/dr.\n    # This calculation is more stable than np.sin(np.arccos(cos_theta)).\n    sin_theta = np.sqrt(1.0 - cos_theta**2)\n\n    # --- Forces from the cosine-based potential U_c ---\n    \n    # The force is F = -dU/dr = -(dU/d(cos(theta))) * (d(cos(theta))/dr)\n    # The pre-multiplier is -dU/d(cos(theta)) = -k_c * (cos(theta) - cos_theta_0)\n    premultiplier_c = -k_c * (cos_theta - cos_theta_0)\n\n    # Gradients of cos(theta) with respect to atomic positions\n    grad_cos_theta_i = (b_hat - cos_theta * a_hat) / a_norm\n    grad_cos_theta_k = (a_hat - cos_theta * b_hat) / b_norm\n    \n    F_i_c = premultiplier_c * grad_cos_theta_i\n    F_k_c = premultiplier_c * grad_cos_theta_k\n    # Total force must sum to zero: F_i + F_j + F_k = 0\n    F_j_c = -(F_i_c + F_k_c)\n    \n    # Find the maximum force magnitude\n    F_max_c = max(np.linalg.norm(F_i_c), np.linalg.norm(F_j_c), np.linalg.norm(F_k_c))\n\n    # --- Forces from the angle-based potential U_theta ---\n    \n    # The force is F = -dU/dr = -(dU/d(theta)) * (d(theta)/dr)\n    # and d(theta)/dr = d(arccos(cos_theta))/dr = (-1/sin(theta)) * d(cos(theta))/dr\n    # so F = -k*(theta-theta_0) * (-1/sin(theta)) * d(cos(theta))/dr\n    # The premultiplier is k*(theta-theta_0)/sin(theta)\n    \n    # This premultiplier is numerically unstable as sin(theta) - 0.\n    # For small epsilon  0, theta is near pi, so sin(theta) is small.\n    # (theta - theta_0) is also small. Division of two small numbers can amplify errors.\n    if np.isclose(sin_theta, 0.0):\n        # This condition is met for epsilon=0, handled above. In theory, for very\n        # small epsilon, it could also be triggered, representing the singularity.\n        # The analytical limit of the force is zero, so we set it here.\n        F_max_theta = 0.0\n    else:\n        premultiplier_theta = k * (theta - theta_0) / sin_theta\n    \n        # Reuse the stable gradients of cos(theta)\n        F_i_theta = premultiplier_theta * grad_cos_theta_i\n        F_k_theta = premultiplier_theta * grad_cos_theta_k\n        F_j_theta = -(F_i_theta + F_k_theta)\n        \n        # Find the maximum force magnitude\n        F_max_theta = max(np.linalg.norm(F_i_theta), np.linalg.norm(F_j_theta), np.linalg.norm(F_k_theta))\n\n    return F_max_theta, F_max_c\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        0.0,\n        1e-9,\n        1e-6,\n        1e-3,\n        2e-1,\n    ]\n\n    results = []\n    for epsilon in test_cases:\n        f_max_theta, f_max_c = calculate_forces(epsilon)\n        results.append(f_max_theta)\n        results.append(f_max_c)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3399282"}]}