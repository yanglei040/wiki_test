{"hands_on_practices": [{"introduction": "We begin our hands-on journey with a classic problem in physics and mathematics that serves as an ideal training ground for handling constrained dynamics. The Thomson problem of finding the minimum energy configuration of charges on a sphere provides a clean, intuitive system for implementing a core molecular dynamics technique: projecting forces to satisfy a holonomic constraint. By simulating this system with overdamped dynamics, you will gain practical experience in writing an integrator that respects a system's geometry, a crucial skill for modeling molecules with fixed bond lengths or those confined to surfaces [@problem_id:3409578].", "problem": "You are asked to implement a complete, runnable program that uses the Thomson problem as a constrained Molecular Dynamics (MD) challenge: place $N$ identical point charges on the surface of a sphere of radius $R$ and relax the system under Coulombic interactions, while enforcing the holonomic constraint that all particles remain on the sphere. Your program must start from first principles and must not rely on specialized shortcut formulas other than widely accepted core physical laws. You should derive and implement a principled projected-dynamics integrator that respects the constraint by updating along the tangent manifold of the sphere. After relaxation, you must compute the total electrostatic energy and compare it to analytically minimal energies for the selected small-$N$ cases. All energies must be expressed in reduced electrostatic energy units where $k_e q^2 = 1$, so the energy is dimensionless and the sphere radius $R$ is dimensionless. No angle unit is required.\n\nFundamental base to use:\n- Coulomb’s law for point charges: the force between two charges is proportional to the vector displacement divided by the cube of the separation, and the pairwise potential energy depends on the inverse of the separation.\n- Newton’s second law and overdamped relaxation (first-order dynamics) restricted to the constraint manifold.\n- Holonomic constraints enforced via projection onto the tangent space of the sphere.\n\nDefinitions to use:\n- Let $N \\in \\mathbb{N}$ be the number of charges.\n- Let $\\mathbf{r}_i \\in \\mathbb{R}^3$ be the position of particle $i$ with $\\lVert \\mathbf{r}_i \\rVert = R$.\n- The total potential energy is $U(\\{\\mathbf{r}_i\\}) = \\sum_{1 \\le i < j \\le N} \\frac{1}{\\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert}$ in reduced units $k_e q^2 = 1$.\n- The unconstrained force on particle $i$ is $\\mathbf{F}_i = \\sum_{j \\ne i} \\frac{\\mathbf{r}_i - \\mathbf{r}_j}{\\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert^3}$.\n- The constraint manifold is the sphere defined by $g(\\mathbf{r}_i) = \\lVert \\mathbf{r}_i \\rVert - R = 0$.\n\nAlgorithmic requirement:\n- Use overdamped projected dynamics: update each $\\mathbf{r}_i$ along the tangent component of the force, $\\mathbf{F}_i^{\\mathrm{tan}} = \\mathbf{F}_i - \\left(\\mathbf{F}_i \\cdot \\mathbf{n}_i\\right)\\mathbf{n}_i$, where $\\mathbf{n}_i = \\mathbf{r}_i / \\lVert \\mathbf{r}_i \\rVert$ is the local outward normal.\n- Use a time step $dt > 0$ and iterate a fixed number of steps.\n- After each update, renormalize positions to exactly enforce $\\lVert \\mathbf{r}_i \\rVert = R$.\n- Initialize positions deterministically on the sphere (for example, using an even distribution like a Fibonacci lattice) so that no randomness is required.\n\nComparison requirement:\n- For the small-$N$ test cases listed below, compare the final relaxed energy $U_{\\mathrm{MD}}$ to the analytically minimal energy $U_{\\min}$ for these $N$ values on a sphere of radius $R$. For the chosen cases, $U_{\\min}$ is known from symmetry and geometry; derive $U_{\\min}$ in your solution. Use the values your derivation yields inside your program. For general $R$, note that the minimal energy scales as $U_{\\min}(N,R) = U_{\\min}(N,1)/R$ because all chord lengths scale linearly with $R$.\n- For each test case, compute the absolute energy difference $\\Delta U = U_{\\mathrm{MD}} - U_{\\min}$.\n\nUnits and output specification:\n- Express all energies in reduced dimensionless units with $k_e q^2 = 1$ and radius $R$ dimensionless.\n- Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each number rounded to $6$ decimal places, in the order of the test suite below, for example, $\\left[\\text{result}_1,\\text{result}_2,\\dots\\right]$. No additional text may be printed.\n\nTest suite:\n- Case $A$: $N = 1$, $R = 1$, $dt = 0.01$, $\\text{steps} = 200$.\n- Case $B$: $N = 2$, $R = 1$, $dt = 0.01$, $\\text{steps} = 800$.\n- Case $C$: $N = 3$, $R = 1$, $dt = 0.01$, $\\text{steps} = 1200$.\n- Case $D$: $N = 4$, $R = 1$, $dt = 0.01$, $\\text{steps} = 1500$.\n- Case $E$: $N = 6$, $R = 1$, $dt = 0.01$, $\\text{steps} = 2000$.\n- Case $F$: $N = 2$, $R = 2$, $dt = 0.01$, $\\text{steps} = 800$.\n\nYour program must implement the projected overdamped dynamics, compute $U_{\\mathrm{MD}}$ at the end of relaxation for each case, compute $U_{\\min}$ via geometric reasoning (derived in your solution), then output the list $\\left[\\Delta U_A,\\Delta U_B,\\Delta U_C,\\Delta U_D,\\Delta U_E,\\Delta U_F\\right]$ rounded to $6$ decimal places, in exactly that order and format.", "solution": "The user has provided a valid, well-posed problem statement from the field of computational physics. The task is to simulate the relaxation of $N$ point charges on a sphere, a classic problem known as the Thomson problem, using a projected overdamped dynamics approach. The solution requires both the derivation of the underlying theoretical model and its implementation into a runnable program. The final output must compare the numerically obtained energies to analytically derived minimal energies for several test cases.\n\nThe physical model consists of $N$ identical point charges, each with charge $q$, constrained to the surface of a sphere of radius $R$. The electrostatic interaction between any two charges, $i$ and $j$, is governed by Coulomb's law. In the specified reduced units, where the electrostatic constant and charge product $k_e q^2$ is set to $1$, the pairwise potential energy is $U_{ij} = 1/\\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert$, and the total potential energy of the system is the sum over all unique pairs:\n$$\nU(\\{\\mathbf{r}_i\\}) = \\sum_{1 \\le i < j \\le N} \\frac{1}{\\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert}\n$$\nThe force exerted by particle $j$ on particle $i$ is $\\mathbf{F}_{ij} = -\\nabla_{\\mathbf{r}_i} U_{ij} = \\frac{\\mathbf{r}_i - \\mathbf{r}_j}{\\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert^3}$. The total unconstrained force on particle $i$ is the vector sum over all other particles:\n$$\n\\mathbf{F}_i = -\\nabla_{\\mathbf{r}_i} U = \\sum_{j \\ne i} \\frac{\\mathbf{r}_i - \\mathbf{r}_j}{\\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert^3}\n$$\nThe system is modeled using overdamped dynamics, where inertial effects are ignored. The velocity of each particle is taken to be directly proportional to the applied force, $\\mathbf{v}_i \\propto \\mathbf{F}_i$. This describes a system relaxing towards a minimum of the potential energy, equivalent to a gradient descent optimization where the force acts as the negative gradient of the potential energy. The basic update rule for a particle's position $\\mathbf{r}_i$ over a small time step $dt$ is $\\mathbf{r}_i(t+dt) = \\mathbf{r}_i(t) + \\alpha dt \\mathbf{F}_i(t)$, where $\\alpha$ is a mobility constant. The problem statement effectively sets $\\alpha=1$.\n\nThe holonomic constraint that all particles must remain on the sphere, $g(\\mathbf{r}_i) = \\lVert \\mathbf{r}_i \\rVert - R = 0$, must be respected. An unconstrained update would generally move particles off this constraint manifold. To prevent this, the dynamics are projected onto the tangent space of the sphere at each particle's position. The unit normal vector to the sphere at $\\mathbf{r}_i$ is $\\mathbf{n}_i = \\mathbf{r}_i / \\lVert \\mathbf{r}_i \\rVert = \\mathbf{r}_i / R$. Any force vector $\\mathbf{F}_i$ can be decomposed into a component normal to the surface, $\\mathbf{F}_i^{\\mathrm{norm}}$, and a component tangential to it, $\\mathbf{F}_i^{\\mathrm{tan}}$. The tangential component, which drives the dynamics along the manifold, is found by subtracting the normal component from the total force:\n$$\n\\mathbf{F}_i^{\\mathrm{tan}} = \\mathbf{F}_i - \\mathbf{F}_i^{\\mathrm{norm}} = \\mathbf{F}_i - (\\mathbf{F}_i \\cdot \\mathbf{n}_i)\\mathbf{n}_i\n$$\nThe position update rule is therefore modified to use only the tangential force:\n$$\n\\mathbf{r}_i(t+dt) \\approx \\mathbf{r}_i(t) + dt \\cdot \\mathbf{F}_i^{\\mathrm{tan}}(t)\n$$\nThis is a first-order Euler integration step. Due to the curvature of the sphere, this linear step in the tangent plane results in a new position that is slightly outside the sphere, with $\\lVert \\mathbf{r}_i(t+dt) \\rVert > R$. To correct this numerical artifact and strictly enforce the constraint, the position vector is renormalized back onto the sphere after each update step:\n$$\n\\mathbf{r}_i \\leftarrow R \\frac{\\mathbf{r}_i}{\\lVert \\mathbf{r}_i \\rVert}\n$$\nTo ensure deterministic and reproducible simulations, the initial positions of the $N$ particles are generated using a Fibonacci lattice, which provides a near-uniform distribution on the sphere's surface. For the $k$-th particle (with $k$ from $0$ to $N-1$), the coordinates are:\n$z_k = R(1 - (2k+1)/N)$\n$\\rho_k = \\sqrt{R^2 - z_k^2}$\n$\\theta_k = k \\phi$, where $\\phi = \\pi(3-\\sqrt{5})$ is the golden angle.\nThe Cartesian coordinates are then $(x_k, y_k, z_k) = (\\rho_k \\cos\\theta_k, \\rho_k \\sin\\theta_k, z_k)$.\n\nTo validate the simulation results, the final numerically obtained energy, $U_{\\mathrm{MD}}$, is compared against the analytically known minimal energy, $U_{\\min}$, for specific small values of $N$. These minimal energies correspond to configurations that form regular polyhedra. The problem states the scaling rule $U_{\\min}(N,R) = U_{\\min}(N,1)/R$, so we derive the values for $R=1$.\n\nCase $N=1$: With only one charge, there are no pairs, and the potential energy is trivially $U_{\\min}(1,1) = 0$.\n\nCase $N=2$: The two charges maximize their separation by occupying antipodal points. The distance is the sphere's diameter, $d=2R$. The energy is $U_{\\min}(2,R) = 1/(2R)$. For $R=1$, $U_{\\min}(2,1) = 1/2 = 0.5$.\n\nCase $N=3$: The charges form an equilateral triangle on a great circle. The angle between their position vectors is $2\\pi/3$. The chord distance $d$ is given by the law of cosines: $d^2 = R^2+R^2-2R^2\\cos(2\\pi/3) = 3R^2$, so $d=R\\sqrt{3}$. There are $\\binom{3}{2}=3$ such pairs. The total energy is $U_{\\min}(3,R) = 3 \\times (1/(R\\sqrt{3})) = \\sqrt{3}/R$. For $R=1$, $U_{\\min}(3,1) = \\sqrt{3}$.\n\nCase $N=4$: The charges form a regular tetrahedron. The edge length of a tetrahedron inscribed in a sphere of radius $R$ is $d = R\\sqrt{8/3}$. There are $\\binom{4}{2}=6$ edges. The total energy is $U_{\\min}(4,R) = 6 \\times (1/(R\\sqrt{8/3})) = 6\\sqrt{3}/(R\\sqrt{8}) = 3\\sqrt{6}/(2R)$. For $R=1$, $U_{\\min}(4,1) = 3\\sqrt{6}/2$.\n\nCase $N=6$: The charges form a regular octahedron, with vertices at $(\\pm R,0,0)$, $(0,\\pm R,0)$, $(0,0,\\pm R)$. There are two sets of distances: $12$ pairs of adjacent vertices with distance $d_1 = R\\sqrt{2}$ (e.g., $(R,0,0)$ to $(0,R,0)$), and $3$ pairs of opposite vertices with distance $d_2 = 2R$. The total energy is $U_{\\min}(6,R) = 12/(R\\sqrt{2}) + 3/(2R) = (6\\sqrt{2} + 3/2)/R = (12\\sqrt{2}+3)/(2R)$. For $R=1$, $U_{\\min}(6,1) = (12\\sqrt{2}+3)/2$.\n\nThe implemented algorithm will iterate through the provided test cases. For each case, it initializes the particle positions, then enters a simulation loop for a specified number of steps. In each step, it calculates all pairwise forces, projects them onto the tangent planes, updates the positions, and renormalizes them. After the simulation, it calculates the final total potential energy $U_{\\mathrm{MD}}$ and computes the difference $\\Delta U = U_{\\mathrm{MD}} - U_{\\min}$, where $U_{\\min}$ is calculated from the appropriate analytical formula derived above, scaled by the given radius $R$. The list of these differences is the final output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are imported, complying with the problem constraints.\n\ndef get_minimal_energies():\n    \"\"\"\n    Returns a dictionary of analytically derived minimal energies for N particles\n    on a sphere of radius R=1. The energy is in reduced units where k_e*q^2 = 1.\n    \"\"\"\n    U_min_base = {\n        1: 0.0,\n        2: 0.5,  # 1 / (2*R)\n        3: np.sqrt(3),  # 3 / (R*sqrt(3))\n        4: 3 * np.sqrt(6) / 2,  # 6 / (R*sqrt(8/3))\n        6: (12 * np.sqrt(2) + 3) / 2,  # 12/(R*sqrt(2)) + 3/(2*R)\n    }\n    return U_min_base\n\ndef run_simulation(N, R, dt, steps):\n    \"\"\"\n    Runs a projected overdamped dynamics simulation for N charges on a sphere.\n\n    Args:\n        N (int): The number of particles.\n        R (float): The radius of the sphere.\n        dt (float): The integration time step.\n        steps (int): The number of simulation steps.\n\n    Returns:\n        float: The final total potential energy of the system.\n    \"\"\"\n    if N <= 1:\n        return 0.0\n\n    # 1. Initialize positions using a Fibonacci lattice for even distribution.\n    positions = np.zeros((N, 3))\n    phi = np.pi * (3. - np.sqrt(5.))  # Golden angle\n\n    for i in range(N):\n        z = R * (1 - (2 * i + 1.0) / N)\n        rho = np.sqrt(R**2 - z**2)\n        theta = phi * i\n        \n        x = rho * np.cos(theta)\n        y = rho * np.sin(theta)\n        \n        positions[i] = [x, y, z]\n\n    # 2. Main simulation loop\n    for _ in range(steps):\n        # Calculate forces using a vectorized approach.\n        # rij[i,j,:] = positions[i] - positions[j]\n        rij = positions[:, np.newaxis, :] - positions[np.newaxis, :, :]\n        \n        # dist_sq[i,j] = ||rij_ij||^2\n        dist_sq = np.sum(rij**2, axis=-1)\n        \n        # Calculate 1/dist^3, handling the i=j diagonal.\n        # Add a small epsilon to avoid division by zero in case particles overlap,\n        # although with this dynamics, it's unlikely.\n        dist_cubed = (dist_sq + 1e-12)**1.5\n        inv_dist_cubed = np.reciprocal(dist_cubed)\n        np.fill_diagonal(inv_dist_cubed, 0.)\n\n        # F_i = sum_j (rij_ij / ||rij_ij||^3)\n        forces = np.sum(rij * inv_dist_cubed[:, :, np.newaxis], axis=1)\n\n        # 3. Project forces onto the tangent manifold of the sphere.\n        # Normal vector n_i = r_i / R\n        normals = positions / R\n        # Force projection along normal: (F . n) * n\n        f_dot_n = np.sum(forces * normals, axis=1, keepdims=True)\n        tangent_forces = forces - f_dot_n * normals\n\n        # 4. Update positions using Euler's method.\n        positions += dt * tangent_forces\n\n        # 5. Renormalize positions to strictly enforce the constraint ||r_i|| = R.\n        norms = np.sqrt(np.sum(positions**2, axis=1, keepdims=True))\n        positions = R * positions / norms\n\n    # 6. Calculate the final potential energy of the relaxed system.\n    total_energy = 0.0\n    for i in range(N):\n        for j in range(i + 1, N):\n            dist = np.linalg.norm(positions[i] - positions[j])\n            total_energy += 1.0 / dist\n            \n    return total_energy\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        # (N, R, dt, steps)\n        (1, 1.0, 0.01, 200),   # Case A\n        (2, 1.0, 0.01, 800),   # Case B\n        (3, 1.0, 0.01, 1200),  # Case C\n        (4, 1.0, 0.01, 1500),  # Case D\n        (6, 1.0, 0.01, 2000),  # Case E\n        (2, 2.0, 0.01, 800),   # Case F\n    ]\n\n    U_min_base = get_minimal_energies()\n    \n    delta_U_list = []\n    \n    for N, R, dt, steps in test_cases:\n        U_md = run_simulation(N, R, dt, steps)\n        \n        # Calculate the analytical minimal energy for the current R.\n        # The scaling law is U_min(N, R) = U_min(N, 1) / R.\n        if N in U_min_base:\n            U_min = U_min_base[N] / R\n        else:\n            # This case should not be reached with the given test suite.\n            U_min = np.nan\n        \n        delta_U = U_md - U_min\n        delta_U_list.append(delta_U)\n        \n    # Format the results to 6 decimal places and print in the required format.\n    formatted_results = [f\"{res:.6f}\" for res in delta_U_list]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3409578"}, {"introduction": "Having explored dynamics in a finite system, we now tackle the challenge of modeling bulk materials, which requires the use of periodic boundary conditions. The long-range nature of the Coulomb interaction makes a simple summation conditionally convergent and computationally prohibitive in a periodic lattice. This exercise guides you through the implementation of the elegant solution to this problem: the Ewald summation method [@problem_id:3409609]. By deriving and coding the real-space, reciprocal-space, and self-interaction terms from first principles, you will demystify one of the most fundamental algorithms in computational physics and chemistry.", "problem": "Consider a set of point charges in a three-dimensional periodic cubic cell of side length $L$ under periodic boundary conditions. The total electrostatic energy of this system is defined by superposition from Coulomb’s law and is to be computed using a decomposition that introduces a Gaussian screening characterized by parameter $\\alpha$. The decomposition partitions the energy into a short-range real-space part truncated at a cutoff $r_c$, a long-range reciprocal-space part truncated at a wave-vector magnitude bound $k_{\\max}$, and a self-interaction correction. The physical model assumes conducting boundary conditions and reduced units where $1/(4\\pi\\varepsilon_0)=1$, so the resulting energy is dimensionless. Your task is to implement the necessary calculations from first principles, starting from the definitions of electrostatic potential and Fourier analysis of periodic functions, and produce numerical errors associated with finite truncations for different values of $\\alpha$.\n\nFundamental base to use:\n- Coulomb’s law for point charges, superposition, and periodic boundary conditions in a cubic cell of side length $L$.\n- Representation of periodic functions using Fourier series, where reciprocal vectors are $\\mathbf{k}=\\frac{2\\pi}{L}\\mathbf{n}$ with $\\mathbf{n}\\in\\mathbb{Z}^3$.\n- Gaussian screening to separate short-range and long-range contributions consistently in real space and reciprocal space.\n- The energy contribution arising from the screening procedure includes a self-interaction correction for each charge.\n\nSystem specification (reduced, dimensionless units):\n- Box length: $L=1.0$.\n- Number of charges: $N=4$.\n- Charges: $\\{q_i\\}_{i=1}^4 = \\{+1.0,-1.0,+1.0,-1.0\\}$ (net charge is zero).\n- Positions in the box, in Cartesian coordinates with each component in $[0,L)$:\n  - $\\mathbf{r}_1 = (0.10, 0.10, 0.10)$\n  - $\\mathbf{r}_2 = (0.90, 0.10, 0.10)$\n  - $\\mathbf{r}_3 = (0.50, 0.60, 0.20)$\n  - $\\mathbf{r}_4 = (0.20, 0.70, 0.80)$\n\nComputation requirements:\n- Real-space part: sum over all distinct pairs $(i,j)$ with $i<j$, and over all lattice translations $\\mathbf{T}=L\\mathbf{n}$ where $\\mathbf{n}\\in\\mathbb{Z}^3$, but only include terms whose pair separation $r_{ij,\\mathbf{T}}=\\lVert(\\mathbf{r}_j-\\mathbf{r}_i)+\\mathbf{T}\\rVert$ satisfies $r_{ij,\\mathbf{T}}\\le r_c$. You must numerically implement the short-range screened interaction corresponding to Gaussian screening characterized by $\\alpha$; the necessary explicit functional forms are to be derived and justified in your solution using the stated fundamental base, not assumed.\n- Reciprocal-space part: sum over all nonzero reciprocal lattice vectors $\\mathbf{k}=\\frac{2\\pi}{L}\\mathbf{n}$ with $\\lVert\\mathbf{k}\\rVert\\le k_{\\max}$, using the structure factor $S(\\mathbf{k})=\\sum_{i=1}^N q_i e^{i\\mathbf{k}\\cdot\\mathbf{r}_i}$ and the long-range screened interaction consistent with the same Gaussian screening characterized by $\\alpha$. The required reciprocal-space expression must be derived from first principles in your solution and then implemented.\n- Self-interaction correction: include the appropriate self term implied by the Gaussian screening decomposition, derived from first principles in your solution and then implemented.\n- Conducting boundary (tin-foil) conditions must be assumed; no additional surface-term correction is to be included.\n\nError analysis protocol:\n- Define a high-accuracy reference energy using a single fixed screening parameter and sufficiently large truncations in both real and reciprocal space. Use the following values for the reference: $\\alpha_{\\text{ref}}=5.0$, $r_{c,\\text{ref}}=2.0$, and $k_{\\max,\\text{ref}}=30\\pi$.\n- For each test case listed below, compute the approximate energy using its $(\\alpha,r_c,k_{\\max})$ and report the absolute error as a float, defined as $\\lvert E_{\\text{approx}}-E_{\\text{ref}}\\rvert$, in the same reduced, dimensionless units.\n\nTest suite:\n- Case $1$: $\\alpha=4.0$, $r_c=0.49$, $k_{\\max}=24\\pi$.\n- Case $2$: $\\alpha=8.0$, $r_c=0.30$, $k_{\\max}=12\\pi$.\n- Case $3$: $\\alpha=1.5$, $r_c=0.20$, $k_{\\max}=40\\pi$.\n- Case $4$ (edge, no reciprocal-space): $\\alpha=3.0$, $r_c=0.49$, $k_{\\max}=0$.\n- Case $5$ (edge, no real-space): $\\alpha=3.0$, $r_c=0.00$, $k_{\\max}=40\\pi$.\n\nYour program must implement the above and produce the specified errors for the given test suite. The final numerical answers are dimensionless floats. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[x_1,x_2,x_3,x_4,x_5]$).", "solution": "The user wants a solution for a computational physics problem.\nThe plan is:\n1. Validate the problem statement.\n2. If valid, derive the Ewald summation formulas from first principles as requested.\n3. Implement the formulas in Python to calculate the energy for the given system.\n4. Calculate a high-accuracy reference energy.\n5. Calculate approximate energies for a suite of test cases and report the absolute error relative to the reference.\n6. Format the output according to the specified XML and code block structure.\n\n**Problem Validation**\n\n*   **Step 1: Extract Givens**\n    *   **System**: Periodic cubic cell, side length $L=1.0$.\n    *   **Particles**: $N=4$ point charges.\n    *   **Charges**: $\\{q_i\\} = \\{+1.0, -1.0, +1.0, -1.0\\}$. The system is charge-neutral.\n    *   **Positions**: $\\mathbf{r}_1=(0.1, 0.1, 0.1)$, $\\mathbf{r}_2=(0.9, 0.1, 0.1)$, $\\mathbf{r}_3=(0.5, 0.6, 0.2)$, $\\mathbf{r}_4=(0.2, 0.7, 0.8)$.\n    *   **Physics Model**: Electrostatic energy via Coulomb's law with periodic boundary conditions, decomposed using a Gaussian screening parameter $\\alpha$. Units are reduced such that $1/(4\\pi\\varepsilon_0)=1$.\n    *   **Boundary Conditions**: Conducting (\"tin-foil\").\n    *   **Computational Cutoffs**: Real-space cutoff $r_c$, reciprocal-space cutoff $k_{\\max}$.\n    *   **Reference Calculation**: $\\alpha_{\\text{ref}}=5.0$, $r_{c,\\text{ref}}=2.0$, $k_{\\max,\\text{ref}}=30\\pi$.\n    *   **Test Cases**:\n        1.  $(\\alpha, r_c, k_{\\max}) = (4.0, 0.49, 24\\pi)$\n        2.  $(\\alpha, r_c, k_{\\max}) = (8.0, 0.30, 12\\pi)$\n        3.  $(\\alpha, r_c, k_{\\max}) = (1.5, 0.20, 40\\pi)$\n        4.  $(\\alpha, r_c, k_{\\max}) = (3.0, 0.49, 0)$\n        5.  $(\\alpha, r_c, k_{\\max}) = (3.0, 0.00, 40\\pi)$\n    *   **Output**: List of absolute errors $|E_{\\text{approx}} - E_{\\text{ref}}|$.\n\n*   **Step 2: Validate Using Extracted Givens**\n    *   **Scientific Groundedness**: The problem describes the Ewald summation method, a fundamental and standard technique in computational physics and chemistry for calculating long-range interactions in periodic systems. The underlying principles (Coulomb's law, Fourier series, Gaussian functions) are well-established. It is scientifically sound.\n    *   **Well-Posedness**: The problem is well-posed. All necessary parameters ($L$, $q_i$, $\\mathbf{r}_i$, $\\alpha$, $r_c$, $k_{\\max}$) are provided. The objective—to calculate and report numerical errors—is specific and achievable. A unique numerical result exists for each calculation.\n    *   **Objectivity**: The problem is stated in precise, objective, and quantitative terms, free from ambiguity or subjective content.\n    *   **Potential Flaws**:\n        *   The description of the real-space summation (\"sum over all distinct pairs $(i,j)$ with $i<j$\") is slightly imprecise, as it omits the necessary interaction terms of a charge with its own periodic images. However, in the context of a \"first principles\" derivation, this is interpreted as a simplification in wording, not a flaw in the model itself. The standard, complete Ewald formulation, which includes these terms, is unequivocally implied and required for correctness. This minor ambiguity is resolvable by adhering to the standard physics of the method, thus it does not render the problem invalid.\n\n*   **Step 3: Verdict and Action**\n    *   **Verdict**: The problem is valid.\n    *   **Action**: Proceed to a complete, reasoned solution.\n\n**Derivation of Ewald Summation Formulas**\n\nThe total electrostatic energy $E$ of a system of $N$ point charges $q_i$ at positions $\\mathbf{r}_i$ within a primary cubic cell of side $L$, interacting with all their periodic images, is given by pairwise superposition according to Coulomb's law. In reduced units where the Coulomb constant $1/(4\\pi\\varepsilon_0)=1$, this is:\n$$ E = \\frac{1}{2} \\sum_{i=1}^{N} \\sum_{j=1}^{N} \\sum_{\\mathbf{n} \\in \\mathbb{Z}^3}' \\frac{q_i q_j}{|\\mathbf{r}_i - \\mathbf{r}_j - \\mathbf{T_n}|} $$\nHere, $\\mathbf{T_n} = L\\mathbf{n}$ is a lattice translation vector for an integer vector $\\mathbf{n}=(n_x, n_y, n_z)$. The primed summation excludes self-interaction terms, i.e., pairs where $i=j$ and $\\mathbf{n}=\\mathbf{0}$ simultaneously. This sum is conditionally convergent and converges very slowly.\n\nThe Ewald method accelerates convergence by splitting the $1/r$ interaction into two parts using an arbitrary screening parameter $\\alpha > 0$ and the identity $\\text{erf}(x) + \\text{erfc}(x) = 1$:\n$$ \\frac{1}{r} = \\underbrace{\\frac{\\text{erfc}(\\alpha r)}{r}}_{\\text{short-range}} + \\underbrace{\\frac{\\text{erf}(\\alpha r)}{r}}_{\\text{long-range}} $$\nThe first term, involving the complementary error function $\\text{erfc}$, decays rapidly in real space. The second term, involving the error function $\\text{erf}$, is a smooth, long-ranged function that is suitable for treatment in reciprocal (Fourier) space.\n\nSubstituting this identity into the energy expression splits the total energy into three components: a real-space sum $E_{\\text{real}}$, a reciprocal-space sum $E_{\\text{recip}}$, and a self-interaction correction $E_{\\text{self}}$.\n$$ E = E_{\\text{real}} + E_{\\text{recip}} + E_{\\text{self}} $$\n\n1.  **Real-Space Energy ($E_{\\text{real}}$)**\n    The short-range contribution gives the real-space energy. Due to the rapid decay of $\\text{erfc}(\\alpha r)/r$, this sum can be truncated at a cutoff radius $r_c$ with controlled error. The sum includes interactions between all pairs of particles $i$ and $j$ over all periodic images $\\mathbf{n}$, excluding the $i=j, \\mathbf{n}=\\mathbf{0}$ term.\n    $$ E_{\\text{real}}(r_c) = \\frac{1}{2} \\sum_{i=1}^{N} \\sum_{j=1}^{N} q_i q_j \\sum_{\\substack{\\mathbf{n} \\in \\mathbb{Z}^3 \\\\ 0 < |\\mathbf{r}_{ij, \\mathbf{n}}| \\le r_c}} \\frac{\\text{erfc}(\\alpha |\\mathbf{r}_{ij, \\mathbf{n}}|)}{|\\mathbf{r}_{ij, \\mathbf{n}}|} $$\n    where $\\mathbf{r}_{ij, \\mathbf{n}} = \\mathbf{r}_j - \\mathbf{r}_i + L\\mathbf{n}$. For implementation, this is often expressed as:\n    $$ E_{\\text{real}}(r_c) = \\frac{1}{2}\\sum_{i=1}^N\\sum_{j=1}^N q_i q_j \\sum_{\\mathbf{n} \\in \\mathbb{Z}^3}' \\left[ \\frac{\\text{erfc}(\\alpha |\\mathbf{r}_j - \\mathbf{r}_i + L\\mathbf{n}|)}{|\\mathbf{r}_j - \\mathbf{r}_i + L\\mathbf{n}|} \\right]_{|\\mathbf{r}_j-\\mathbf{r}_i+L\\mathbf{n}|\\le r_c} $$\n    The prime on the sum indicates that for $i=j$, the $\\mathbf{n}=\\mathbf{0}$ term is omitted.\n\n2.  **Reciprocal-Space Energy ($E_{\\text{recip}}$)**\n    The long-range contribution is handled in reciprocal space. This term corresponds to the energy of a periodic lattice of Gaussian charge distributions $\\rho_i(\\mathbf{r}) = q_i (\\alpha/\\sqrt{\\pi})^3 \\exp(-\\alpha^2 |\\mathbf{r}-\\mathbf{r}_i|^2)$. The potential energy of such a system is most readily calculated using Fourier series.\n    The charge density of the periodic system of Gaussians is $\\rho_G(\\mathbf{r}) = \\sum_{i, \\mathbf{n}} q_i \\mathcal{G}_\\alpha(\\mathbf{r} - (\\mathbf{r}_i + \\mathbf{T_n}))$. Its Fourier transform leads to the energy expression. Using Poisson's equation $\\nabla^2 \\phi = -4\\pi\\rho$ (in given units) and Parseval's theorem, the energy is expressed as a sum over reciprocal lattice vectors $\\mathbf{k} = \\frac{2\\pi}{L}\\mathbf{m}$ for integer vectors $\\mathbf{m} \\in \\mathbb{Z}^3$.\n    The Fourier transform of the long-range potential term $\\text{erf}(\\alpha r)/r$ is $\\frac{4\\pi}{k^2}e^{-k^2/(4\\alpha^2)}$. This leads to the reciprocal-space energy:\n    $$ E_{\\text{recip}} = \\frac{1}{2V} \\sum_{\\mathbf{k} \\ne \\mathbf{0}} \\frac{4\\pi}{k^2} e^{-k^2/(4\\alpha^2)} \\left| \\sum_{j=1}^{N} q_j e^{i\\mathbf{k} \\cdot \\mathbf{r}_j} \\right|^2 $$\n    where $V=L^3$ is the cell volume. The term $\\sum_j q_j e^{i\\mathbf{k} \\cdot \\mathbf{r}_j}$ is the structure factor $S(\\mathbf{k})$. The $\\mathbf{k}=\\mathbf{0}$ term is excluded. For a charge-neutral system ($\\sum q_i = 0$), $S(\\mathbf{0})=0$, so this term would be zero anyway. Its omission is also consistent with the specified conducting (tin-foil) boundary conditions.\n    Truncating the sum at a maximum wave-vector magnitude $k_{\\max}$, the final expression is:\n    $$ E_{\\text{recip}}(k_{\\max}) = \\frac{2\\pi}{L^3} \\sum_{\\substack{0 < |\\mathbf{k}| \\le k_{\\max} \\\\ \\mathbf{k} = \\frac{2\\pi}{L}\\mathbf{m}}} \\frac{e^{-k^2/(4\\alpha^2)}}{k^2} |S(\\mathbf{k})|^2 $$\n\n3.  **Self-Interaction Correction ($E_{\\text{self}}$)**\n    The decomposition introduces an artificial self-interaction term. The real-space sum correctly excludes the unphysical, infinite self-energy of a point charge. The reciprocal-space sum, however, is derived from smooth Gaussian charge distributions, which have a finite self-energy. We have effectively replaced the infinite self-energy of a point charge with the finite self-energy of a Gaussian. This must be corrected.\n    The correction arises from adding and subtracting the $i=j, \\mathbf{n}=\\mathbf{0}$ term in the long-range part of the original sum:\n    $$ E_{\\text{correction}} = -\\frac{1}{2} \\sum_{i=1}^{N} q_i^2 \\lim_{r \\to 0} \\frac{\\text{erf}(\\alpha r)}{r} $$\n    Using the Taylor expansion of $\\text{erf}(x) = \\frac{2}{\\sqrt{\\pi}}(x - \\frac{x^3}{3} + \\dots)$, the limit is evaluated as:\n    $$ \\lim_{r \\to 0} \\frac{\\text{erf}(\\alpha r)}{r} = \\lim_{r \\to 0} \\frac{ (2/\\sqrt{\\pi})(\\alpha r) }{r} = \\frac{2\\alpha}{\\sqrt{\\pi}} $$\n    Thus, the self-interaction correction term is:\n    $$ E_{\\text{self}} = -\\frac{1}{2} \\sum_{i=1}^{N} q_i^2 \\left(\\frac{2\\alpha}{\\sqrt{\\pi}}\\right) = -\\frac{\\alpha}{\\sqrt{\\pi}} \\sum_{i=1}^{N} q_i^2 $$\n\nThe total energy is the sum of these three components, each truncated according to its respective cutoff parameter. The implementation will compute these three terms for the given system parameters to find the total electrostatic energy. The error analysis then proceeds by comparing results from the test parameters against a high-precision reference calculation.", "answer": "```python\nimport numpy as np\nfrom scipy.special import erfc\n\ndef calculate_energy(alpha, rc, kmax, charges, positions, L):\n    \"\"\"\n    Calculates the electrostatic energy of a periodic system of charges\n    using the Ewald summation method.\n    \n    Args:\n        alpha (float): Ewald screening parameter.\n        rc (float): Real-space cutoff radius.\n        kmax (float): Reciprocal-space cutoff magnitude.\n        charges (np.ndarray): Array of charges of shape (N,).\n        positions (np.ndarray): Array of particle positions of shape (N, 3).\n        L (float): Side length of the cubic periodic cell.\n        \n    Returns:\n        float: The total electrostatic energy.\n    \"\"\"\n    N = len(charges)\n    V = L**3\n    \n    # --- Real-space energy ---\n    E_real = 0.0\n    if rc > 0:\n        # Sum over all pairs (i, j) and periodic images n\n        # This implementation sums over i=0..N-1, j=0..N-1 and multiplies by 0.5\n        # to correct for double counting of (i,j) and (j,i) pairs.\n        \n        # Determine the maximum number of image cells to check\n        nmax_real = int(np.ceil(rc / L))\n        \n        for i in range(N):\n            for j in range(N):\n                for nx in range(-nmax_real, nmax_real + 1):\n                    for ny in range(-nmax_real, nmax_real + 1):\n                        for nz in range(-nmax_real, nmax_real + 1):\n                            # Exclude self-interaction at n=(0,0,0)\n                            if i == j and nx == 0 and ny == 0 and nz == 0:\n                                continue\n                            \n                            r_vec = positions[j] - positions[i] + np.array([nx, ny, nz]) * L\n                            r_mag = np.linalg.norm(r_vec)\n                            \n                            if r_mag <= rc:\n                                E_real += charges[i] * charges[j] * erfc(alpha * r_mag) / r_mag\n\n    E_real *= 0.5 # Correct for double counting\n\n    # --- Reciprocal-space energy ---\n    E_recip = 0.0\n    if kmax > 0:\n        # Determine the maximum integer indices for k-vectors\n        m_max_recip = int(np.ceil(kmax * L / (2 * np.pi)))\n        \n        for mx in range(-m_max_recip, m_max_recip + 1):\n            for my in range(-m_max_recip, m_max_recip + 1):\n                for mz in range(-m_max_recip, m_max_recip + 1):\n                    # Exclude k=0 vector\n                    if mx == 0 and my == 0 and mz == 0:\n                        continue\n                    \n                    m_vec = np.array([mx, my, mz])\n                    k_vec = (2 * np.pi / L) * m_vec\n                    k_sq = np.dot(k_vec, k_vec)\n                    \n                    if np.sqrt(k_sq) <= kmax:\n                        # Structure factor S(k)\n                        S_k = np.sum(charges * np.exp(1j * np.dot(positions, k_vec)))\n                        S_k_mag_sq = np.abs(S_k)**2\n                        \n                        E_recip += (np.exp(-k_sq / (4 * alpha**2)) / k_sq) * S_k_mag_sq\n    \n    E_recip *= (2 * np.pi / V)\n\n    # --- Self-interaction correction ---\n    sum_q_sq = np.sum(charges**2)\n    E_self = - (alpha / np.sqrt(np.pi)) * sum_q_sq\n    \n    return E_real + E_recip + E_self\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem as specified.\n    \"\"\"\n    # System specification\n    L = 1.0\n    charges = np.array([1.0, -1.0, 1.0, -1.0])\n    positions = np.array([\n        [0.10, 0.10, 0.10],\n        [0.90, 0.10, 0.10],\n        [0.50, 0.60, 0.20],\n        [0.20, 0.70, 0.80]\n    ])\n\n    # Reference calculation parameters\n    alpha_ref = 5.0\n    rc_ref = 2.0\n    kmax_ref = 30.0 * np.pi\n\n    # Calculate high-accuracy reference energy\n    E_ref = calculate_energy(alpha_ref, rc_ref, kmax_ref, charges, positions, L)\n\n    # Test suite parameters\n    test_cases = [\n        {'alpha': 4.0, 'rc': 0.49, 'kmax': 24.0 * np.pi},\n        {'alpha': 8.0, 'rc': 0.30, 'kmax': 12.0 * np.pi},\n        {'alpha': 1.5, 'rc': 0.20, 'kmax': 40.0 * np.pi},\n        {'alpha': 3.0, 'rc': 0.49, 'kmax': 0.0},\n        {'alpha': 3.0, 'rc': 0.00, 'kmax': 40.0 * np.pi},\n    ]\n\n    results = []\n    for case in test_cases:\n        E_approx = calculate_energy(case['alpha'], case['rc'], case['kmax'], charges, positions, L)\n        error = np.abs(E_approx - E_ref)\n        results.append(error)\n    \n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3409609"}, {"introduction": "After mastering the correct calculation of electrostatic energies in periodic systems, we turn to the practical trade-offs that govern the efficiency of large-scale simulations. The real-space component of the Ewald sum is computationally expensive, and its cost is typically reduced by using a neighbor list. This exercise delves into the consequences of this essential optimization [@problem_id:3409615]. You will quantify the numerical error in energies and forces that arises from using a \"stale\" neighbor list, gaining a quantitative understanding of the critical balance between computational speed and physical accuracy that every molecular dynamics practitioner must manage.", "problem": "Consider a system of $N$ point charges in a cubic box with Periodic Boundary Conditions (PBC). The electrostatic interaction is modeled via Coulomb’s law, and the system uses the Particle Mesh Ewald (PME) method, which splits the interaction into a short-range real-space part and a long-range reciprocal-space part. The simulation uses a neighbor list for the real-space pairs built at discrete times, and the list is not continually rebuilt at every timestep. This causes errors when particles move into the cutoff region after the neighbor list was last built. Your task is to quantify the error introduced by infrequent neighbor list rebuilds by mapping the rebuild period to two metrics: total energy drift and instantaneous force error.\n\nStart from the following fundamental bases and facts:\n- Coulomb’s law for point charges in vacuum under classical mechanics, with the force proportional to the product of charges and inversely proportional to the square of the separation distance.\n- Newton’s second law of motion in a classical Molecular Dynamics setting, with continuous positions and velocities.\n- The PME splitting framework, which expresses the electrostatic potential energy of periodic systems as a sum of short-range (real-space) and long-range (reciprocal-space) contributions, augmented by a self-energy correction for point charges.\n- The neighbor list method for the real-space interaction under a cutoff and a nonzero skin distance.\n\nAssume the following definitions and conventions:\n- The box is cubic with edge length $L$ in nanometers (nm).\n- The PME splitting uses a screening parameter $\\alpha$ in inverse nanometers ($\\mathrm{nm}^{-1}$) and truncates the reciprocal-space sum at a maximum integer wave index $k_{\\max}$ in each Cartesian direction.\n- The real-space interaction uses a cutoff radius $r_c$ in nanometers and a neighbor-list skin distance $s$ in nanometers. The neighbor list is built at time $t = 0$ from all pairs with minimum-image separation less than or equal to $r_c + s$.\n- Positions evolve linearly as $\\mathbf{r}_i(t) = \\mathbf{r}_i(0) + \\mathbf{v}_i t$, with velocities in nanometers per picosecond ($\\mathrm{nm} / \\mathrm{ps}$), and are wrapped into the box using PBC.\n- The reciprocal-space force and energy are computed exactly within the PME truncation for the given $\\alpha$ and $k_{\\max}$ and do not depend on the neighbor list. The neighbor list affects only the real-space part.\n- The system is net-neutral, that is, $\\sum_i q_i = 0$.\n\nFor this problem:\n- Use $N = 8$ charges with values $q_i \\in \\{-1, +1\\}$ in elementary charge units, specifically four charges with $+1$ and four with $-1$.\n- Use edge length $L = 3.0$ nm, cutoff $r_c = 1.0$ nm, screening parameter $\\alpha = 3.5$ $\\mathrm{nm}^{-1}$, and maximum wave index $k_{\\max} = 4$.\n- Use Coulomb’s constant in Molecular Dynamics units as $k_C = 138.935456$ $\\mathrm{kJ} \\, \\mathrm{mol}^{-1} \\, \\mathrm{nm} \\, e^{-2}$.\n- Generate initial positions uniformly in $[0, L)$ in each Cartesian dimension and velocities from a normal distribution with zero mean and standard deviation $0.2$ $\\mathrm{nm}/\\mathrm{ps}$, using a fixed pseudorandom seed of $42$ to ensure reproducibility. Wrap positions at all times using PBC.\n\nDefine:\n- The “true” PME energy at time $t$ as the sum of the real-space energy (over all pairs within the cutoff $r_c$ at time $t$, using the minimum-image convention), the reciprocal-space energy truncated at $k_{\\max}$, and the self-energy correction. The “true” force is the sum of the corresponding real-space and reciprocal-space forces.\n- The “approximate” energy at time $t$ uses the same reciprocal-space energy and self-energy as the “true” energy, but the real-space energy is computed only over those pairs that were included in the neighbor list constructed at $t = 0$ (i.e., pairs with separation less than or equal to $r_c + s$ at $t = 0$) and that are within the cutoff $r_c$ at time $t$. The “approximate” force is computed analogously.\n\nAt a given rebuild period $T$ (in picoseconds), evaluate the following at time $t = T$:\n- The total energy drift defined as the absolute difference between the “approximate” and “true” total energies, expressed in kilojoules per mole ($\\mathrm{kJ}/\\mathrm{mol}$) and rounded to six decimal places.\n- The instantaneous force error defined as the root-mean-square (RMS) of the per-particle Euclidean norm of the difference between the “approximate” and “true” total forces, expressed in $\\mathrm{kJ} \\, \\mathrm{mol}^{-1} \\, \\mathrm{nm}^{-1}$ and rounded to six decimal places.\n\nUse the following test suite of neighbor-list rebuild periods $T$ (in picoseconds) and skin distances $s$ (in nanometers):\n- Case $1$: $T = 0.0$, $s = 0.20$.\n- Case $2$: $T = 0.10$, $s = 0.05$.\n- Case $3$: $T = 0.25$, $s = 0.10$.\n- Case $4$: $T = 0.50$, $s = 0.10$.\n\nYour program should:\n- Construct the neighbor list at $t = 0$ from all pairs with separation less than or equal to $r_c + s$.\n- Propagate positions to $t = T$ under linear motion with the given velocities, wrapped with PBC.\n- Compute the “true” energy and forces at $t = T$ under PME with the given truncation parameters.\n- Compute the “approximate” energy and forces at $t = T$ using the stale neighbor list for the real-space part.\n- Produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with entries ordered as $[\\text{drift}_1,\\text{force\\_error}_1,\\text{drift}_2,\\text{force\\_error}_2,\\text{drift}_3,\\text{force\\_error}_3,\\text{drift}_4,\\text{force\\_error}_4]$, where each drift is in $\\mathrm{kJ}/\\mathrm{mol}$ and each force error is in $\\mathrm{kJ} \\, \\mathrm{mol}^{-1} \\, \\mathrm{nm}^{-1}$, both rounded to six decimal places.", "solution": "The user-provided problem is valid. It is scientifically grounded in the principles of classical electrostatics and molecular dynamics, well-posed with all necessary parameters and definitions provided, and objective in its formulation. The task is to quantify a specific type of numerical error in a standard simulation method, which is a meaningful problem in computational science.\n\nHerein, a detailed solution is provided.\n\n### 1. Theoretical Framework\n\nThe problem asks for an analysis of errors arising from infrequent updates of a neighbor list in the context of a Particle Mesh Ewald (PME) electrostatic calculation. The PME method partitions the total electrostatic energy $E$ of a periodic system of charges into three components: a short-range real-space term ($E_{\\text{real}}$), a long-range reciprocal-space term ($E_{\\text{recip}}$), and a self-interaction correction ($E_{\\text{self}}$).\n\n$$ E = E_{\\text{real}} + E_{\\text{recip}} + E_{\\text{self}} $$\n\nThe problem defines \"true\" and \"approximate\" models for energy and forces. The key distinction lies in the real-space component, which is computed using a cutoff radius $r_c$. The reciprocal-space and self-energy terms are independent of the neighbor list and are assumed to be computed identically in both models. Consequently, when calculating the energy drift ($\\Delta E$) and force error ($\\Delta \\mathbf{F}_i$), these terms cancel out:\n\n$$ \\Delta E = |E_{\\text{approx}} - E_{\\text{true}}| = |(E_{\\text{real,approx}} + E_{\\text{recip}} + E_{\\text{self}}) - (E_{\\text{real,true}} + E_{\\text{recip}} + E_{\\text{self}})| = |E_{\\text{real,approx}} - E_{\\text{real,true}}| $$\n$$ \\Delta \\mathbf{F}_i = \\mathbf{F}_{\\text{approx},i} - \\mathbf{F}_{\\text{true},i} = (\\mathbf{F}_{\\text{real,approx},i} + \\mathbf{F}_{\\text{recip},i}) - (\\mathbf{F}_{\\text{real,true},i} + \\mathbf{F}_{\\text{recip},i}) = \\mathbf{F}_{\\text{real,approx},i} - \\mathbf{F}_{\\text{real,true},i} $$\n\nThis crucial simplification means we only need to implement the real-space contributions to energy and forces.\n\nThe real-space potential energy between two charges $q_i$ and $q_j$ separated by a minimum-image distance $r_{ij}$ is given by a screened Coulomb potential:\n$$ U_{\\text{real}}(r_{ij}) = k_C \\frac{q_i q_j \\text{erfc}(\\alpha r_{ij})}{r_{ij}} $$\nwhere $k_C$ is Coulomb's constant, $\\alpha$ is the Ewald screening parameter, and $\\text{erfc}$ is the complementary error function. The total real-space energy is the sum over all unique pairs $(i, j)$ with $i < j$ whose separation $r_{ij}$ is within the cutoff $r_c$:\n$$ E_{\\text{real}} = \\sum_{i<j, r_{ij} \\le r_c} U_{\\text{real}}(r_{ij}) $$\n\nThe corresponding force on particle $i$ due to particle $j$ is $\\mathbf{F}_{ij} = -\\nabla_{\\mathbf{r}_i} U_{\\text{real}}(r_{ij})$. This evaluates to:\n$$ \\mathbf{F}_{ij} = k_C q_i q_j \\left( \\frac{\\text{erfc}(\\alpha r_{ij})}{r_{ij}^3} + \\frac{2\\alpha}{\\sqrt{\\pi}} \\frac{\\exp(-\\alpha^2 r_{ij}^2)}{r_{ij}^2} \\right) \\mathbf{r}_{ij} $$\nwhere $\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$ is the minimum-image separation vector. The total real-space force on particle $i$ is $\\mathbf{F}_{\\text{real},i} = \\sum_{j \\neq i, r_{ij} \\le r_c} \\mathbf{F}_{ij}$.\n\n### 2. Algorithmic Implementation\n\nThe solution proceeds by implementing the logic for the \"true\" and \"approximate\" real-space calculations for each test case.\n\n**Step 1: Initialization**\nWe begin by setting the physical constants and system parameters as specified: $N=8$, $L=3.0\\,\\text{nm}$, $r_c=1.0\\,\\text{nm}$, $\\alpha=3.5\\,\\text{nm}^{-1}$, and $k_C = 138.935456\\,\\mathrm{kJ} \\, \\mathrm{mol}^{-1} \\, \\mathrm{nm} \\, e^{-2}$. The charges are set to four $+1\\,e$ and four $-1\\,e$. Initial positions $\\mathbf{r}_i(0)$ and velocities $\\mathbf{v}_i$ are generated from the specified distributions using a fixed pseudorandom seed of $42$ to ensure reproducibility.\n\n**Step 2: Time Evolution**\nFor each test case with rebuild period $T$, particle positions are propagated linearly to time $t=T$:\n$$ \\mathbf{r}_i(T) = \\mathbf{r}_i(0) + \\mathbf{v}_i T $$\nThe resulting positions are then wrapped back into the primary cubic box $[0, L)^3$ to enforce periodic boundary conditions. The minimum image convention is applied to all pair separations $\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$, using the formula $\\mathbf{d}_{\\text{mic}} = \\mathbf{d} - L \\cdot \\text{round}(\\mathbf{d}/L)$.\n\n**Step 3: \"True\" and \"Approximate\" Calculations**\nA single loop over all unique pairs of particles $(i, j)$ with $i < j$ is used to compute both \"true\" and \"approximate\" contributions efficiently.\n\nFor each pair $(i, j)$:\n1.  The separation distance $r_{ij}(0)$ at time $t=0$ is computed. This determines if the pair belongs to the neighbor list, i.e., if $r_{ij}(0) \\le r_c + s$.\n2.  The separation distance $r_{ij}(T)$ at time $t=T$ is computed. This determines if the pair is currently a candidate for interaction, i.e., if $r_{ij}(T) \\le r_c$.\n\n-   **True Calculation**: A pair contributes to $E_{\\text{real,true}}$ and $\\mathbf{F}_{\\text{real,true}}$ if and only if its separation at time $T$ satisfies $r_{ij}(T) \\le r_c$.\n-   **Approximate Calculation**: A pair contributes to $E_{\\text{real,approx}}$ and $\\mathbf{F}_{\\text{real,approx}}$ if and only if it was in the neighbor list from $t=0$ (i.e., $r_{ij}(0) \\le r_c + s$) AND its separation at time $T$ satisfies $r_{ij}(T) \\le r_c$.\n\nThe energy and force contributions for an interacting pair are calculated using the formulas provided in the theoretical framework.\n\n**Step 4: Error Metrics**\nAfter iterating through all pairs, the total real-space energies ($E_{\\text{real,true}}, E_{\\text{real,approx}}$) and force vectors ($\\mathbf{F}_{\\text{real,true}}, \\mathbf{F}_{\\text{real,approx}}$) are fully assembled. The required metrics are then calculated.\n\n-   **Total Energy Drift**: This is the absolute difference between the approximate and true real-space energies.\n    $$ \\text{drift} = |E_{\\text{real,approx}} - E_{\\text{real,true}}| $$\n-   **Instantaneous Force Error**: This is the root-mean-square of the Euclidean norm of the per-particle force differences.\n    $$ \\text{force\\_error} = \\sqrt{\\frac{1}{N} \\sum_{i=1}^N ||\\mathbf{F}_{\\text{real,approx},i} - \\mathbf{F}_{\\text{real,true},i}||^2} $$\n\nThis procedure is repeated for all four test cases defined in the problem, and the results are collected and formatted. For the case $T=0.0$, the positions do not change, so any pair with $r_{ij}(0) \\le r_c$ will also satisfy the neighbor list condition $r_{ij}(0) \\le r_c + s$ (for $s \\ge 0$). Thus, the \"true\" and \"approximate\" interaction sets are identical, leading to zero drift and error, which serves as a validation of the algorithm.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erfc\n\ndef solve():\n    \"\"\"\n    Calculates the energy drift and force error due to infrequent neighbor list\n    rebuilds in a PME simulation.\n    \"\"\"\n    # Define system parameters and constants from the problem statement.\n    N = 8\n    L = 3.0  # Box edge length in nm\n    rc = 1.0  # Real-space cutoff in nm\n    alpha = 3.5  # Ewald screening parameter in nm^-1\n    kC = 138.935456  # Coulomb's constant in kJ mol^-1 nm e^-2\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Rebuild period T in ps, skin distance s in nm)\n        (0.0, 0.20),\n        (0.10, 0.05),\n        (0.25, 0.10),\n        (0.50, 0.10),\n    ]\n\n    # Generate initial positions and velocities using a fixed seed for reproducibility.\n    rng = np.random.default_rng(seed=42)\n    charges = np.array([1.0] * 4 + [-1.0] * 4)  # 4x +1e, 4x -1e\n    pos_0 = rng.uniform(0, L, size=(N, 3))\n    vel = rng.normal(loc=0.0, scale=0.2, size=(N, 3))  # nm/ps\n\n    results = []\n\n    def calculate_pair_interaction(q_i, q_j, r_vec, r_norm):\n        \"\"\"\n        Calculates the real-space PME energy and force for a single pair.\n        \"\"\"\n        if r_norm == 0:\n            return 0.0, np.zeros(3)\n\n        qiqj = q_i * q_j\n        erfc_alpha_r = erfc(alpha * r_norm)\n\n        # Energy contribution\n        energy = kC * qiqj * erfc_alpha_r / r_norm\n\n        # Force contribution (vector)\n        f_scalar_part = kC * qiqj * (\n            erfc_alpha_r / r_norm**3 +\n            (2 * alpha / np.sqrt(np.pi)) * np.exp(-alpha**2 * r_norm**2) / r_norm**2\n        )\n        force_vec = f_scalar_part * r_vec\n\n        return energy, force_vec\n\n    # Process each test case\n    for T, s in test_cases:\n        # Propagate positions linearly to time T\n        pos_T = pos_0 + vel * T\n        # Apply periodic boundary conditions (wrap positions into [0, L))\n        pos_T = pos_T - L * np.floor(pos_T / L)\n\n        E_true = 0.0\n        F_true = np.zeros((N, 3))\n        E_approx = 0.0\n        F_approx = np.zeros((N, 3))\n\n        # Iterate over all unique pairs to calculate contributions\n        for i in range(N):\n            for j in range(i + 1, N):\n                # Minimum Image Convention for separation vector at t=0\n                r_vec_0 = pos_0[i] - pos_0[j]\n                r_vec_0 -= L * np.round(r_vec_0 / L)\n                r_norm_0 = np.linalg.norm(r_vec_0)\n\n                # Minimum Image Convention for separation vector at t=T\n                r_vec_T = pos_T[i] - pos_T[j]\n                r_vec_T -= L * np.round(r_vec_T / L)\n                r_norm_T = np.linalg.norm(r_vec_T)\n                \n                # Check for interaction at t=T and compute contributions\n                if r_norm_T > 0 and r_norm_T <= rc:\n                    energy, force = calculate_pair_interaction(charges[i], charges[j], r_vec_T, r_norm_T)\n                    \n                    # Always add to \"true\" calculation if within cutoff at t=T\n                    E_true += energy\n                    F_true[i] += force\n                    F_true[j] -= force\n\n                    # Add to \"approximate\" calculation only if also in neighbor list from t=0\n                    is_in_nl = (r_norm_0 <= rc + s)\n                    if is_in_nl:\n                        E_approx += energy\n                        F_approx[i] += force\n                        F_approx[j] -= force\n\n        # Calculate final metrics for the current case\n        energy_drift = abs(E_approx - E_true)\n        force_difference_vectors = F_approx - F_true\n        \n        # RMS of the per-particle Euclidean norm of the force difference\n        rms_force_error = np.sqrt(np.mean(np.sum(force_difference_vectors**2, axis=1)))\n\n        results.extend([round(energy_drift, 6), round(rms_force_error, 6)])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3409615"}]}