{"hands_on_practices": [{"introduction": "The Beeman integrator is often chosen over simpler methods like the Verlet algorithm due to its higher formal accuracy. This practice delves into the mathematical justification for this preference. By performing a Taylor series expansion, you will directly compare the numerical update formula to the \"true\" solution over a small time step, $h$, and derive the leading error term, known as the local truncation error, which quantifies the integrator's accuracy. This exercise is fundamental to understanding any numerical integrator, as it reveals the order of accuracy and the specific derivatives of motion that govern the error, providing a theoretical basis for choosing an appropriate time step [@problem_id:3396862].", "problem": "Consider a single classical particle in one spatial dimension of mass $m$ evolving under a smooth force $F(x,t)$ so that Newton’s second law gives $m\\,\\ddot{x}(t)=F(x(t),t)$. Define the acceleration $a(t)=\\ddot{x}(t)$, the jerk $j(t)=\\dot{a}(t)$, and the snap $s(t)=\\ddot{a}(t)$. Assume $a(t)$ is sufficiently smooth so that all time derivatives up to the required order exist and are bounded. The Beeman integrator used in molecular dynamics is a two-step predictor-corrector scheme. In its commonly used corrector form, the position and velocity updates over a constant time step $h>0$ are given by\n$$\nx_{\\mathrm{B}}(t+h)=x(t)+v(t)\\,h+\\left(\\frac{2}{3}\\,a(t)-\\frac{1}{6}\\,a(t-h)\\right)h^{2},\n$$\n$$\nv_{\\mathrm{B}}(t+h)=v(t)+\\frac{h}{6}\\left(2\\,a(t+h)+5\\,a(t)-a(t-h)\\right),\n$$\nwhere $v(t)=\\dot{x}(t)$ and $a(\\cdot)$ is evaluated from the force at the indicated time. For the purposes of local truncation error analysis, interpret $a(t\\pm h)$ as the exact acceleration along the exact trajectory at times $t\\pm h$.\n\nUsing only Newton’s second law, the definitions $v=\\dot{x}$, $a=\\ddot{x}$, $j=\\dot{a}$, $s=\\ddot{a}$, and Taylor expansions about time $t$, derive the leading-order local truncation errors for the position and velocity updates, defined respectively by\n$$\n\\Delta x_{\\mathrm{loc}}=x(t+h)-x_{\\mathrm{B}}(t+h),\\qquad \\Delta v_{\\mathrm{loc}}=v(t+h)-v_{\\mathrm{B}}(t+h),\n$$\nexpressed in terms of the snap $s(t)$, up to and including the first nonzero term in powers of $h$. Then, extract the corresponding dimensionless error constants $C_{x}$ and $C_{v}$ defined by\n$$\n\\Delta x_{\\mathrm{loc}}=C_{x}\\,s(t)\\,h^{4}+O\\!\\left(h^{5}\\right),\\qquad \\Delta v_{\\mathrm{loc}}=C_{v}\\,s(t)\\,h^{3}+O\\!\\left(h^{4}\\right).\n$$\nReport your final answer as the ordered pair $(C_{x}, C_{v})$. No numerical evaluation is required. Express your final answer as a single composite expression as specified. If you introduce any intermediate truncated series, keep constants symbolic and do not substitute numerical values beyond those already present in the scheme. The final answer must be given as a pair of exact rational numbers. Units are not required for the error constants.", "solution": "The objective is to determine the local truncation errors for the position and velocity as given by the Beeman integrator. This is achieved by comparing the Taylor series expansion of the exact solution with the expansion of the numerical scheme.\n\nLet us begin by writing the Taylor series expansions for the exact position $x(t+h)$ and velocity $v(t+h)$ around time $t$. Using the provided definitions, we have:\n$\\dot{x}(t) = v(t)$\n$\\ddot{x}(t) = a(t)$\n$\\dddot{x}(t) = \\dot{a}(t) = j(t)$\n$x^{(4)}(t) = \\ddot{a}(t) = s(t)$\n$x^{(5)}(t) = \\dot{s}(t)$\n\nThe expansion for the exact position is:\n$$x(t+h) = x(t) + h\\dot{x}(t) + \\frac{h^2}{2!}\\ddot{x}(t) + \\frac{h^3}{3!}\\dddot{x}(t) + \\frac{h^4}{4!}x^{(4)}(t) + O(h^5)$$\n$$x(t+h) = x(t) + v(t)h + \\frac{1}{2}a(t)h^2 + \\frac{1}{6}j(t)h^3 + \\frac{1}{24}s(t)h^4 + O(h^5)$$\n\nSimilarly, for the exact velocity:\n$\\dot{v}(t) = a(t)$\n$\\ddot{v}(t) = \\dot{a}(t) = j(t)$\n$\\dddot{v}(t) = \\ddot{a}(t) = s(t)$\n\nThe expansion for the exact velocity is:\n$$v(t+h) = v(t) + h\\dot{v}(t) + \\frac{h^2}{2!}\\ddot{v}(t) + \\frac{h^3}{3!}\\dddot{v}(t) + O(h^4)$$\n$$v(t+h) = v(t) + a(t)h + \\frac{1}{2}j(t)h^2 + \\frac{1}{6}s(t)h^3 + O(h^4)$$\n\nNext, we expand the terms in the Beeman integrator updates.\n\n**Position Error Analysis**\nThe Beeman position update is:\n$$x_{\\mathrm{B}}(t+h) = x(t)+v(t)\\,h+\\left(\\frac{2}{3}\\,a(t)-\\frac{1}{6}\\,a(t-h)\\right)h^{2}$$\nTo analyze this, we need the Taylor expansion of $a(t-h)$ around $t$:\n$$a(t-h) = a(t) - j(t)h + \\frac{1}{2}s(t)h^2 + O(h^3)$$\nSubstituting this into the term in the parenthesis of the $x_{\\mathrm{B}}(t+h)$ expression:\n$$\\left(\\frac{2}{3}\\,a(t)-\\frac{1}{6}\\,a(t-h)\\right) = \\frac{2}{3}a(t) - \\frac{1}{6}\\left(a(t) - j(t)h + \\frac{1}{2}s(t)h^2 + O(h^3)\\right)$$\n$$= \\frac{2}{3}a(t) - \\frac{1}{6}a(t) + \\frac{1}{6}j(t)h - \\frac{1}{12}s(t)h^2 + O(h^3)$$\n$$= \\left(\\frac{4-1}{6}\\right)a(t) + \\frac{1}{6}j(t)h - \\frac{1}{12}s(t)h^2 + O(h^3)$$\n$$= \\frac{1}{2}a(t) + \\frac{1}{6}j(t)h - \\frac{1}{12}s(t)h^2 + O(h^3)$$\nNow, we multiply this by $h^2$ and substitute back into the expression for $x_{\\mathrm{B}}(t+h)$:\n$$x_{\\mathrm{B}}(t+h) = x(t) + v(t)h + \\left(\\frac{1}{2}a(t) + \\frac{1}{6}j(t)h - \\frac{1}{12}s(t)h^2 + O(h^3)\\right)h^2$$\n$$x_{\\mathrm{B}}(t+h) = x(t) + v(t)h + \\frac{1}{2}a(t)h^2 + \\frac{1}{6}j(t)h^3 - \\frac{1}{12}s(t)h^4 + O(h^5)$$\nThe local truncation error for the position is $\\Delta x_{\\mathrm{loc}} = x(t+h) - x_{\\mathrm{B}}(t+h)$.\n$$\\Delta x_{\\mathrm{loc}} = \\left(x(t) + v(t)h + \\frac{1}{2}a(t)h^2 + \\frac{1}{6}j(t)h^3 + \\frac{1}{24}s(t)h^4 + O(h^5)\\right) - \\left(x(t) + v(t)h + \\frac{1}{2}a(t)h^2 + \\frac{1}{6}j(t)h^3 - \\frac{1}{12}s(t)h^4 + O(h^5)\\right)$$\nSubtracting term by term, we find that terms up to order $h^3$ cancel.\n$$\\Delta x_{\\mathrm{loc}} = \\left(\\frac{1}{24}s(t)h^4\\right) - \\left(-\\frac{1}{12}s(t)h^4\\right) + O(h^5)$$\n$$\\Delta x_{\\mathrm{loc}} = \\left(\\frac{1}{24} + \\frac{2}{24}\\right)s(t)h^4 + O(h^5) = \\frac{3}{24}s(t)h^4 + O(h^5)$$\n$$\\Delta x_{\\mathrm{loc}} = \\frac{1}{8}s(t)h^4 + O(h^5)$$\nBy comparing with the required form $\\Delta x_{\\mathrm{loc}}=C_{x}\\,s(t)\\,h^{4}+O(h^{5})$, we identify the constant $C_x$ as:\n$$C_x = \\frac{1}{8}$$\n\n**Velocity Error Analysis**\nThe Beeman velocity update is:\n$$v_{\\mathrm{B}}(t+h) = v(t)+\\frac{h}{6}\\left(2\\,a(t+h)+5\\,a(t)-a(t-h)\\right)$$\nTo analyze this, we need the Taylor expansions of $a(t+h)$ and $a(t-h)$ around $t$:\n$$a(t+h) = a(t) + j(t)h + \\frac{1}{2}s(t)h^2 + O(h^3)$$\n$$a(t-h) = a(t) - j(t)h + \\frac{1}{2}s(t)h^2 + O(h^3)$$\nSubstituting these into the term in the parenthesis of the $v_{\\mathrm{B}}(t+h)$ expression:\n$$2a(t+h)+5a(t)-a(t-h) = 2\\left(a(t) + j(t)h + \\frac{1}{2}s(t)h^2\\right) + 5a(t) - \\left(a(t) - j(t)h + \\frac{1}{2}s(t)h^2\\right) + O(h^3)$$\nWe group terms by derivatives of $a(t)$:\nCoefficient of $a(t)$: $2+5-1 = 6$\nCoefficient of $j(t)h$: $2 - (-1) = 3$\nCoefficient of $s(t)h^2$: $2 \\cdot \\frac{1}{2} - \\frac{1}{2} = 1 - \\frac{1}{2} = \\frac{1}{2}$\nSo the expression becomes:\n$$6a(t) + 3j(t)h + \\frac{1}{2}s(t)h^2 + O(h^3)$$\nNow, we substitute this back into the formula for $v_{\\mathrm{B}}(t+h)$:\n$$v_{\\mathrm{B}}(t+h) = v(t) + \\frac{h}{6}\\left(6a(t) + 3j(t)h + \\frac{1}{2}s(t)h^2 + O(h^3)\\right)$$\n$$v_{\\mathrm{B}}(t+h) = v(t) + a(t)h + \\frac{3}{6}j(t)h^2 + \\frac{1}{12}s(t)h^3 + O(h^4)$$\n$$v_{\\mathrm{B}}(t+h) = v(t) + a(t)h + \\frac{1}{2}j(t)h^2 + \\frac{1}{12}s(t)h^3 + O(h^4)$$\nThe local truncation error for the velocity is $\\Delta v_{\\mathrm{loc}} = v(t+h) - v_{\\mathrm{B}}(t+h)$.\n$$\\Delta v_{\\mathrm{loc}} = \\left(v(t) + a(t)h + \\frac{1}{2}j(t)h^2 + \\frac{1}{6}s(t)h^3 + O(h^4)\\right) - \\left(v(t) + a(t)h + \\frac{1}{2}j(t)h^2 + \\frac{1}{12}s(t)h^3 + O(h^4)\\right)$$\nSubtracting term by term, we find that terms up to order $h^2$ cancel.\n$$\\Delta v_{\\mathrm{loc}} = \\left(\\frac{1}{6}s(t)h^3\\right) - \\left(\\frac{1}{12}s(t)h^3\\right) + O(h^4)$$\n$$\\Delta v_{\\mathrm{loc}} = \\left(\\frac{2}{12} - \\frac{1}{12}\\right)s(t)h^3 + O(h^4)$$\n$$\\Delta v_{\\mathrm{loc}} = \\frac{1}{12}s(t)h^3 + O(h^4)$$\nBy comparing with the required form $\\Delta v_{\\mathrm{loc}}=C_{v}\\,s(t)\\,h^{3}+O(h^{4})$, we identify the constant $C_v$ as:\n$$C_v = \\frac{1}{12}$$\n\nThe ordered pair of dimensionless error constants is $(C_x, C_v) = (\\frac{1}{8}, \\frac{1}{12})$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{8}  \\frac{1}{12}\n\\end{pmatrix}\n}\n$$", "id": "3396862"}, {"introduction": "While accuracy over a single step is important, the long-term stability of a molecular dynamics simulation often depends on preserving structural properties like time-reversibility. This practice challenges you to first investigate this property for a common predictor scheme and then use your findings to engineer a superior algorithm. By proving that a predictor is not time-reversible and subsequently designing a corrector that is, you will gain insight into how fundamental physical principles can be embedded into the structure of a numerical method to ensure robust long-term behavior [@problem_id:3396867].", "problem": "Consider a one-dimensional Molecular Dynamics (MD) system with mass $m$ obeying Newton's second law, $m\\,\\ddot{x}(t)=F(x(t))$, where $F(x)$ is sufficiently smooth so that all derivatives up to the third time derivative of the acceleration exist and are continuous. Define the acceleration as $a(t)=\\frac{F(x(t))}{m}$, its time derivative (the jerk) as $j(t)=\\frac{d a(t)}{d t}$, and its second time derivative (the snap) as $s(t)=\\frac{d^{2} a(t)}{d t^{2}}$. Let $x_{n}=x(t_{n})$, $v_{n}=\\dot{x}(t_{n})$, $a_{n}=a(t_{n})$, and $\\Delta t=t_{n+1}-t_{n}$.\n\nStarting from Newton’s law and Taylor expansions around $t_{n}$, derive the third-order accurate position-update formula that uses $a_{n}$ and $a_{n-1}$ only (this is the form associated with Beeman’s predictor for position). Then, test its invariance under the transformation $\\Delta t\\to -\\Delta t$ by writing the corresponding backward step from $(x_{n+1},v_{n+1},a_{n+1})$ to $(x_{n},v_{n},a_{n})$ and deciding whether the forward and backward maps are identical as algebraic expressions in $\\Delta t$ and the accelerations at adjacent steps. Conclude whether the uncorrected Beeman position update is time-reversible.\n\nNext, design a minimal predictor-corrector position update that restores time-reversibility while retaining third-order accuracy in $x$. To that end, consider a corrected position update of the form\n$$\nx_{n+1}^{(\\mathrm{corr})}=x_{n}+v_{n}\\,\\Delta t+C\\,a_{n}\\,\\Delta t^{2}+E\\left(a_{n+1}^{(\\mathrm{pred})}-a_{n-1}\\right)\\Delta t^{2},\n$$\nwhere $a_{n+1}^{(\\mathrm{pred})}$ is the predicted acceleration obtained from a third-order position predictor (you may use your derived Beeman-type predictor to obtain $x_{n+1}^{(\\mathrm{pred})}$ and then compute $a_{n+1}^{(\\mathrm{pred})}=a(x_{n+1}^{(\\mathrm{pred})})$). Impose the following design requirements:\n\n- The corrected update is invariant under $\\Delta t\\to -\\Delta t$ in the sense that the algebraic form of the update is unchanged when indexes are reversed ($n+1 \\leftrightarrow n-1$) and $\\Delta t$ changes sign.\n- The corrected update reproduces the exact Taylor expansion of $x(t_{n+1})$ through order $\\Delta t^{3}$ for general smooth $F(x)$.\n\nDetermine the unique values of the coefficients $C$ and $E$ that meet these requirements for the given minimal form, and report them as exact rational numbers. Express your final answer as a row matrix using the LaTeX pmatrix environment, with entries $C$ and $E$ in that order. No rounding is required, and no units are necessary in the final answer.", "solution": "**Part 1: Derivation of the Beeman predictor for position**\n\nWe start with the Taylor series expansion for the position $x(t)$ around time $t_{n}$ to predict $x_{n+1}=x(t_{n}+\\Delta t)$:\n$$x_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} a_n \\Delta t^2 + \\frac{1}{6} j_n \\Delta t^3 + O(\\Delta t^4)$$\nThe goal is to find a third-order accurate formula that uses only $a_n$ and $a_{n-1}$. This means we need to approximate the jerk, $j_n$, using information available at times $t_n$ and $t_{n-1}$. We can use a first-order backward finite difference for the jerk, derived from the Taylor expansion of the acceleration $a(t)$ around $t_n$:\n$$a_{n-1} = a(t_n - \\Delta t) = a_n - j_n \\Delta t + O(\\Delta t^2)$$\nSolving for $j_n$ gives:\n$$j_n = \\frac{a_n - a_{n-1}}{\\Delta t} + O(\\Delta t)$$\nSubstituting this approximation for $j_n$ into the expansion for $x_{n+1}$:\n$$x_{n+1} \\approx x_n + v_n \\Delta t + \\frac{1}{2} a_n \\Delta t^2 + \\frac{1}{6} \\left(\\frac{a_n - a_{n-1}}{\\Delta t}\\right) \\Delta t^3$$\n$$x_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} a_n \\Delta t^2 + \\frac{1}{6} a_n \\Delta t^2 - \\frac{1}{6} a_{n-1} \\Delta t^2$$\nCombining the terms with $a_n$:\n$$x_{n+1} = x_n + v_n \\Delta t + \\left(\\frac{1}{2} + \\frac{1}{6}\\right) a_n \\Delta t^2 - \\frac{1}{6} a_{n-1} \\Delta t^2$$\n$$x_{n+1} = x_n + v_n \\Delta t + \\frac{2}{3} a_n \\Delta t^2 - \\frac{1}{6} a_{n-1} \\Delta t^2$$\nThis is the position-update formula for Beeman's predictor. To confirm its accuracy, we note that the error in the approximation of $j_n$ is $O(\\Delta t)$. When multiplied by $\\Delta t^3$ in the Taylor expansion, this introduces a local truncation error of $O(\\Delta t^4)$ in the position, making the formula third-order accurate.\n\n**Part 2: Time-reversibility test of the Beeman predictor**\n\nAn integrator is time-reversible if applying the algorithm for a time step $\\Delta t$ and then for a time step $-\\Delta t$ returns the system to its initial state. Algebraically, this can be tested by comparing the forward map with the rearranged backward map.\n\nThe forward map from step $n$ to $n+1$ is:\n$$x_{n+1} = x_n + v_n \\Delta t + \\frac{2}{3} a_n \\Delta t^2 - \\frac{1}{6} a_{n-1} \\Delta t^2$$\nTo obtain the backward map from step $n+1$ to $n$, we apply the same algorithm starting from state $(x_{n+1}, v_{n+1})$ with a time step of $-\\Delta t$. The \"current\" acceleration is $a_{n+1}$ and the \"previous\" acceleration is $a_n$.\n$$x_n = x_{n+1} + v_{n+1} (-\\Delta t) + \\frac{2}{3} a_{n+1} (-\\Delta t)^2 - \\frac{1}{6} a_n (-\\Delta t)^2$$\n$$x_n = x_{n+1} - v_{n+1} \\Delta t + \\frac{2}{3} a_{n+1} \\Delta t^2 - \\frac{1}{6} a_n \\Delta t^2$$\nNow, we can rearrange the forward map to solve for $x_n$:\n$$x_n = x_{n+1} - v_n \\Delta t - \\frac{2}{3} a_n \\Delta t^2 + \\frac{1}{6} a_{n-1} \\Delta t^2$$\nComparing the algebraic form of the backward map with the rearranged forward map, we see they are not identical. For instance, the terms involving accelerations are different:\n$$ \\text{Backward map:} \\quad \\left(\\frac{2}{3} a_{n+1} - \\frac{1}{6} a_n\\right)\\Delta t^2 $$\n$$ \\text{Rearranged forward map:} \\quad \\left(-\\frac{2}{3} a_n + \\frac{1}{6} a_{n-1}\\right)\\Delta t^2 $$\nThese expressions are clearly different. The asymmetric dependence on past ($a_{n-1}$) and present ($a_n$) accelerations, without involving future information ($a_{n+1}$), breaks the time symmetry. Therefore, the uncorrected Beeman position update is not time-reversible.\n\n**Part 3: Design of a time-reversible, third-order accurate corrector**\n\nWe are tasked with finding the coefficients $C$ and $E$ for the corrected position update:\n$$x_{n+1}^{(\\mathrm{corr})}=x_{n}+v_{n}\\,\\Delta t+C\\,a_{n}\\,\\Delta t^{2}+E\\left(a_{n+1}^{(\\mathrm{pred})}-a_{n-1}\\right)\\Delta t^{2}$$\nsuch that it is third-order accurate and time-reversible. We will determine the coefficients by enforcing third-order accuracy and then confirm that the resulting scheme meets the reversibility requirement.\n\nTo check for third-order accuracy, we compare the formula with the exact Taylor expansion of $x(t_{n+1})$ around $t_n$:\n$$x(t_{n+1}) = x_n + v_n \\Delta t + \\frac{1}{2} a_n \\Delta t^2 + \\frac{1}{6} j_n \\Delta t^3 + O(\\Delta t^4)$$\nWe need to expand the term $(a_{n+1}^{(\\mathrm{pred})}-a_{n-1})$ in the corrector formula in powers of $\\Delta t$.\nThe predicted acceleration $a_{n+1}^{(\\mathrm{pred})}$ is calculated as $a(x_{n+1}^{(\\mathrm{pred})})$. As shown in Part 1, the predictor for position is third-order accurate, i.e., $x_{n+1}^{(\\mathrm{pred})} = x(t_{n+1}) + O(\\Delta t^4)$.\nThus, $a_{n+1}^{(\\mathrm{pred})} = a(x(t_{n+1}) + O(\\Delta t^4)) = a(x(t_{n+1})) + a'(x(t_{n+1})) O(\\Delta t^4) = a_{n+1}^{\\text{exact}} + O(\\Delta t^4)$. The error in the predicted acceleration is of order $O(\\Delta t^4)$. When this is multiplied by $\\Delta t^2$ in the corrector, the contribution to the position error is $O(\\Delta t^6)$, which is a higher order than we need to consider for a third-order scheme. Therefore, we can replace $a_{n+1}^{(\\mathrm{pred})}$ with the exact acceleration $a_{n+1}$ in our analysis.\n\nWe use Taylor expansions for $a_{n+1}$ and $a_{n-1}$ around $t_n$:\n$$a_{n+1} = a_n + j_n \\Delta t + \\frac{1}{2} s_n \\Delta t^2 + O(\\Delta t^3)$$\n$$a_{n-1} = a_n - j_n \\Delta t + \\frac{1}{2} s_n \\Delta t^2 - O(\\Delta t^3)$$\nSubtracting these gives the central difference approximation for the jerk:\n$$a_{n+1} - a_{n-1} = 2 j_n \\Delta t + O(\\Delta t^3)$$\nSubstituting this into the corrector equation:\n$$x_{n+1}^{(\\mathrm{corr})} = x_n + v_n \\Delta t + C a_n \\Delta t^2 + E(2 j_n \\Delta t + O(\\Delta t^3))\\Delta t^2$$\n$$x_{n+1}^{(\\mathrm{corr})} = x_n + v_n \\Delta t + C a_n \\Delta t^2 + 2E j_n \\Delta t^3 + O(\\Delta t^5)$$\nTo achieve third-order accuracy, this expansion must match the exact Taylor expansion of $x(t_{n+1})$ up to the $\\Delta t^3$ term.\n$$x(t_{n+1}) = x_n + v_n \\Delta t + \\frac{1}{2} a_n \\Delta t^2 + \\frac{1}{6} j_n \\Delta t^3 + O(\\Delta t^4)$$\nBy comparing the coefficients of the powers of $\\Delta t$:\n- For the $\\Delta t^2$ term: $C a_n \\Delta t^2 = \\frac{1}{2} a_n \\Delta t^2 \\implies C = \\frac{1}{2}$.\n- For the $\\Delta t^3$ term: $2E j_n \\Delta t^3 = \\frac{1}{6} j_n \\Delta t^3 \\implies 2E = \\frac{1}{6} \\implies E = \\frac{1}{12}$.\n\nThese values are uniquely determined by the accuracy requirement. The specific form of the corrector, with the term $E(a_{n+1} - a_{n-1})$, which is symmetric in time about the midpoint $t_n$ (it is a central difference), is what allows for the restoration of time-reversibility. To be explicit, an integrator based on this corrector (e.g., combined with a reversible velocity update like the Velocity Verlet trapezoidal rule) can be shown to generate a time-reversible trajectory. For instance, combining the forward update for $x_{n+1}$ and the corresponding backward update for $x_{n-1}$ leads to the manifestly time-reversible Stoermer-Verlet-like equation $x_{n+1} - 2x_n + x_{n-1} = a_n\\Delta t^2 + \\frac{1}{12}(a_{n+1}-2a_n+a_{n-1})\\Delta t^2$, which depends only on even powers of $\\Delta t$ and is symmetric upon swapping indices $n+1$ and $n-1$. The derived values of $C$ and $E$ are consistent with such a formulation.\n\nThe unique values for the coefficients are $C = 1/2$ and $E = 1/12$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{2}  \\frac{1}{12}\n\\end{pmatrix}\n}\n$$", "id": "3396867"}, {"introduction": "Theoretical analysis provides invaluable insight, but the ultimate test of an integrator is its performance in a practical simulation. This capstone practice challenges you to bridge the gap between theory and implementation. You will design a \"calibrated\" predictor-corrector integrator that is perfectly energy-conserving for the harmonic oscillator, a feat standard methods like Beeman cannot achieve. By implementing this custom algorithm and testing its transferability to an anharmonic potential, you will gain hands-on experience with the critical trade-off between specialization and generality in computational physics [@problem_id:3396786].", "problem": "You are asked to design, analyze, and implement a one-step predictor–corrector molecular dynamics integrator whose coefficients are calibrated so that for the harmonic oscillator governed by Newton’s second law $m \\, x''(t) = - k \\, x(t)$ with $m = 1$ and $k = \\omega^2$, the discrete-time update conserves the exact continuous-time mechanical energy $E = \\tfrac{1}{2} \\, v^2 + \\tfrac{1}{2} \\, \\omega^2 x^2$ for any time step $\\Delta t$ within stability limits, and then test its transferability to weak anharmonicity. Work in one spatial dimension with unit mass and use radians for all angles.\n\nYour derivation must start from the following fundamentals only:\n- Newton’s second law $x''(t) = a(x)$ with $a(x) = - \\partial V/\\partial x$.\n- Definitions of velocity $v = dx/dt$ and acceleration $a = dv/dt$.\n- For the harmonic oscillator $V(x) = \\tfrac{1}{2} \\, \\omega^2 x^2$, the exact solution is a rotation in phase space with angular increment $\\theta = \\omega \\, \\Delta t$, which implies a linear, norm-preserving map.\n- For weak anharmonicity, use $V(x) = \\tfrac{1}{2} \\, \\omega^2 x^2 + \\tfrac{\\varepsilon}{4} x^4$ with small $\\varepsilon$ and $a(x) = - \\omega^2 x - \\varepsilon x^3$.\n\nYour tasks:\n- Calibrate a predictor–corrector of the form “predict positions, evaluate predicted accelerations, correct velocities and positions using linear combinations of current and predicted accelerations” so that, for the harmonic oscillator, the resulting one-step map is exactly energy-preserving for any $\\Delta t$ satisfying stability requirements. The calibration is allowed to depend on $\\theta = \\omega \\, \\Delta t$.\n- Justify stability limits in terms of $\\theta$ and explain why the harmonic oscillator admits an energy-preserving discrete map of rotation type.\n- Implement your calibrated predictor–corrector integrator and, for comparison, implement the Beeman integrator as a baseline predictor–corrector that uses $a_{n-1}$, $a_n$, and a predicted $a_{n+1}$.\n- For each test, simulate the system for a specified number of steps and compute the maximum relative energy deviation $\\max_{0 \\le n \\le N} \\lvert E_n - E_0 \\rvert / \\lvert E_0 \\rvert$ as a floating-point number (unitless). All energies must be computed in joules, positions in meters, velocities in meters per second, angular frequency in radians per second, and time in seconds.\n\nTest suite:\n- Test $1$ (harmonic, “happy path”): $V(x) = \\tfrac{1}{2} \\, \\omega^2 x^2$, with $\\omega = 3.0 \\text{ rad/s}$, $\\Delta t = 0.2 \\text{ s}$, $N = 2000$ steps, initial state $x_0 = 1.0 \\text{ m}$, $v_0 = 0.0 \\text{ m/s}$. Output the maximum relative energy deviation for your calibrated predictor–corrector as a float.\n- Test $2$ (harmonic, baseline): same parameters as Test $1$, but output the maximum relative energy deviation using the Beeman integrator as a float.\n- Test $3$ (harmonic, boundary case near stability limit): $V(x) = \\tfrac{1}{2} \\, \\omega^2 x^2$, with $\\omega = 2.0 \\text{ rad/s}$, $\\Delta t = 0.99 \\pi / \\omega \\text{ s}$, $N = 500$ steps, initial state $x_0 = 1.0 \\text{ m}$, $v_0 = 0.0 \\text{ m/s}$. Output the maximum relative energy deviation for your calibrated predictor–corrector as a float.\n- Test $4$ (weak anharmonicity, transferability check I): $V(x) = \\tfrac{1}{2} \\, \\omega^2 x^2 + \\tfrac{\\varepsilon}{4} x^4$, with $\\omega = 1.0 \\text{ rad/s}$, $\\varepsilon = 1.0 \\times 10^{-3} \\text{ m}^{-2}\\text{s}^{-2}$, $\\Delta t = 0.2 \\text{ s}$, $N = 2000$ steps, initial state $x_0 = 0.5 \\text{ m}$, $v_0 = 0.0 \\text{ m/s}$. Output a two-element list $[e_{\\text{cal}}, e_{\\text{bee}}]$ containing the maximum relative energy deviations for your calibrated predictor–corrector and for Beeman, respectively.\n- Test $5$ (moderate anharmonicity, transferability check II): $V(x) = \\tfrac{1}{2} \\, \\omega^2 x^2 + \\tfrac{\\varepsilon}{4} x^4$, with $\\omega = 1.0 \\text{ rad/s}$, $\\varepsilon = 5.0 \\times 10^{-2} \\text{ m}^{-2}\\text{s}^{-2}$, $\\Delta t = 0.05 \\text{ s}$, $N = 2000$ steps, initial state $x_0 = 0.5 \\text{ m}$, $v_0 = 0.0 \\text{ m/s}$. Output a two-element list $[e_{\\text{cal}}, e_{\\text{bee}}]$ as in Test $4$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the following order:\n$[ \\text{Test1}, \\text{Test2}, \\text{Test3}, \\text{Test4\\_cal}, \\text{Test4\\_bee}, \\text{Test5\\_cal}, \\text{Test5\\_bee} ]$.\nAll outputs must be floating-point numbers. For Tests $4$ and $5$, you must flatten the two-element results into the single list as specified above.", "solution": "We begin with Newton’s second law for a unit mass, $x''(t) = a(x)$, where $a(x) = - \\partial V/\\partial x$. For the harmonic oscillator with $V(x) = \\tfrac{1}{2} \\, \\omega^2 x^2$, the exact flow over one time step $\\Delta t$ is a rotation in phase space by angle $\\theta = \\omega \\, \\Delta t$:\n$$\n\\begin{pmatrix} x_{n+1} \\\\ v_{n+1} \\end{pmatrix}\n=\n\\begin{pmatrix}\n\\cos \\theta  \\frac{\\sin \\theta}{\\omega} \\\\\n- \\omega \\sin \\theta  \\cos \\theta\n\\end{pmatrix}\n\\begin{pmatrix} x_n \\\\ v_n \\end{pmatrix}.\n$$\nThis map preserves the quadratic energy $E = \\tfrac{1}{2} \\, v^2 + \\tfrac{1}{2} \\, \\omega^2 x^2$ exactly because it is orthogonal with respect to the metric induced by that quadratic form. Stability for the harmonic oscillator requires $\\lvert \\cos \\theta \\rvert \\le 1$, hence $0 \\le \\theta \\le \\pi$, or equivalently $0 \\le \\Delta t \\le \\pi / \\omega$.\n\nWe seek a predictor–corrector (one-step, explicit after a single force evaluation at the predicted position) with the following structure:\n- Predictor of position using current acceleration:\n$$\nx_{n+1}^{\\mathrm{p}} = x_n + \\Delta t \\, v_n + c_{\\mathrm{p}} \\, a_n \\, \\Delta t^2,\n$$\nwhere $a_n = a(x_n)$ and the subscript $\\mathrm{p}$ denotes predicted.\n- Evaluate predicted acceleration $a_{n+1}^{\\mathrm{p}} = a(x_{n+1}^{\\mathrm{p}})$.\n- Correct velocity and position with affine combinations of current and predicted accelerations:\n$$\nv_{n+1} = v_n + \\Delta t \\, \\big( \\alpha \\, a_{n+1}^{\\mathrm{p}} + \\beta \\, a_n \\big), \\quad\nx_{n+1} = x_n + \\Delta t \\, v_n + \\Delta t^2 \\, \\big( \\alpha' \\, a_{n+1}^{\\mathrm{p}} + \\beta' \\, a_n \\big).\n$$\n\nCalibration for the harmonic oscillator. For $a(x) = - \\omega^2 x$, we require this explicit predictor–corrector to reproduce the exact rotation map for any $\\theta = \\omega \\, \\Delta t$. Write the predictor for the harmonic oscillator:\n$$\nx_{n+1}^{\\mathrm{p}} = x_n + \\Delta t \\, v_n - c_{\\mathrm{p}} \\, \\omega^2 \\, x_n \\, \\Delta t^2.\n$$\nTherefore,\n$$\na_{n+1}^{\\mathrm{p}} = - \\omega^2 x_{n+1}^{\\mathrm{p}} = - \\omega^2 x_n - \\omega^2 \\Delta t \\, v_n + c_{\\mathrm{p}} \\, \\omega^4 \\, x_n \\, \\Delta t^2.\n$$\nInsert $a_{n+1}^{\\mathrm{p}}$ into the velocity corrector:\n$$\nv_{n+1}\n=\nv_n + \\Delta t \\left[ \\alpha \\left( - \\omega^2 x_n - \\omega^2 \\Delta t \\, v_n + c_{\\mathrm{p}} \\, \\omega^4 \\, x_n \\, \\Delta t^2 \\right) + \\beta \\left( - \\omega^2 x_n \\right) \\right].\n$$\nCollect terms by $v_n$ and $x_n$, and enforce equality with the exact rotation:\n$$\nv_{n+1} = \\cos \\theta \\, v_n - \\omega \\sin \\theta \\, x_n.\n$$\nEquating coefficients yields\n$$\n1 - \\alpha \\, \\omega^2 \\Delta t^2 = \\cos \\theta, \\qquad\n- (\\alpha + \\beta) \\, \\omega^2 + \\alpha \\, c_{\\mathrm{p}} \\, \\omega^4 \\Delta t^2 = - \\omega^2 \\, \\frac{\\sin \\theta}{\\theta}.\n$$\nIn terms of $\\theta = \\omega \\Delta t$, this becomes\n$$\n\\alpha = \\frac{1 - \\cos \\theta}{\\theta^2}, \\qquad\n\\alpha \\, c_{\\mathrm{p}} \\, \\theta^2 - (\\alpha + \\beta) = - \\frac{\\sin \\theta}{\\theta}.\n$$\nFor the position corrector, substitute $a_{n+1}^{\\mathrm{p}}$ into\n$$\nx_{n+1} = x_n + \\Delta t \\, v_n + \\Delta t^2 \\left[ \\alpha' \\left( - \\omega^2 x_n - \\omega^2 \\Delta t \\, v_n + c_{\\mathrm{p}} \\, \\omega^4 \\, x_n \\, \\Delta t^2 \\right) + \\beta' \\left( - \\omega^2 x_n \\right) \\right],\n$$\nand enforce\n$$\nx_{n+1} = \\cos \\theta \\, x_n + \\frac{\\sin \\theta}{\\omega} \\, v_n.\n$$\nMatching coefficients of $v_n$ gives\n$$\n\\Delta t \\left( 1 - \\alpha' \\, \\omega^2 \\Delta t^2 \\right) = \\frac{\\sin \\theta}{\\omega} \\ \\ \\Rightarrow \\ \\ \\alpha' = \\frac{1 - (\\sin \\theta)/\\theta}{\\theta^2}.\n$$\nMatching the coefficient of $x_n$ gives\n$$\n1 - (\\alpha' + \\beta') \\, \\theta^2 + \\alpha' \\, c_{\\mathrm{p}} \\, \\theta^4 = \\cos \\theta \\ \\ \\Rightarrow \\ \\ \\alpha' \\, c_{\\mathrm{p}} \\, \\theta^2 - (\\alpha' + \\beta') = \\frac{\\cos \\theta - 1}{\\theta^2} = - \\alpha.\n$$\nWe now choose a consistent and accurate predictor coefficient $c_{\\mathrm{p}} = \\tfrac{1}{2}$ so that the predicted position matches the second-order Taylor expansion as $\\theta \\to 0$. With $c_{\\mathrm{p}} = \\tfrac{1}{2}$, the remaining coefficients are determined uniquely:\n$$\n\\alpha = \\frac{1 - \\cos \\theta}{\\theta^2}, \\qquad\n\\alpha' = \\frac{1 - (\\sin \\theta)/\\theta}{\\theta^2},\n$$\n$$\n\\beta = \\frac{\\sin \\theta}{\\theta} + \\frac{1 - \\cos \\theta}{2} - \\alpha, \\qquad\n\\beta' = \\frac{1}{2} \\, \\alpha' \\, \\theta^2 + \\alpha - \\alpha'.\n$$\nSmall-$\\theta$ asymptotics ensure numerical robustness:\n$$\n\\alpha = \\frac{1}{2} - \\frac{\\theta^2}{24} + \\mathcal{O}(\\theta^4), \\quad\n\\alpha' = \\frac{1}{6} - \\frac{\\theta^2}{120} + \\mathcal{O}(\\theta^4),\n$$\n$$\n\\beta = \\frac{1}{2} + \\frac{\\theta^2}{8} - \\frac{\\theta^4}{72} + \\mathcal{O}(\\theta^6), \\quad\n\\beta' = \\frac{1}{3} + \\frac{\\theta^2}{20} - \\frac{\\theta^4}{336} + \\mathcal{O}(\\theta^6).\n$$\nWith these coefficients, for the harmonic oscillator the predictor–corrector reproduces the exact rotation map; consequently, it preserves the exact continuous energy $E$ for any $\\theta$ in the stability interval $[0, \\pi]$. This follows because the resulting discrete update equals the exact orthogonal map in the $(x, v)$ phase plane for quadratic $V$.\n\nTransferability to weak anharmonicity. For $V(x) = \\tfrac{1}{2} \\, \\omega^2 x^2 + \\tfrac{\\varepsilon}{4} x^4$ with small $\\varepsilon$, the force is $a(x) = - \\omega^2 x - \\varepsilon x^3$. The calibrated coefficients remain functions of $\\theta = \\omega \\, \\Delta t$, built from the harmonic reference. The method is then no longer exactly energy-preserving, but it remains time-reversible to leading order and exhibits good energy behavior for sufficiently small $\\varepsilon$ and adequately small $\\Delta t$. The Beeman method, a classic predictor–corrector, provides a baseline:\n- Position update using $a_{n-1}$ and $a_n$:\n$$\nx_{n+1} = x_n + v_n \\, \\Delta t + \\left( \\frac{2}{3} a_n - \\frac{1}{6} a_{n-1} \\right) \\Delta t^2.\n$$\n- Predict $a_{n+1}$ from $x_{n+1}$ and correct velocity:\n$$\nv_{n+1} = v_n + \\left( \\frac{1}{3} a_{n+1} + \\frac{5}{6} a_n - \\frac{1}{6} a_{n-1} \\right) \\Delta t.\n$$\nA one-step method such as velocity Verlet can be used to start Beeman for the first step (to avoid an ad hoc $a_{-1}$).\n\nAlgorithmic design summary:\n- Given $(x_n, v_n)$, compute $a_n = - \\omega^2 x_n - \\varepsilon x_n^3$.\n- Set $\\theta = \\omega \\, \\Delta t$ and compute $(\\alpha, \\beta, \\alpha', \\beta')$ by the formulas above, using series expansions for small $\\theta$ to avoid cancellation.\n- Predictor: $x_{n+1}^{\\mathrm{p}} = x_n + \\Delta t \\, v_n + \\tfrac{1}{2} a_n \\, \\Delta t^2$; evaluate $a_{n+1}^{\\mathrm{p}}$ at $x_{n+1}^{\\mathrm{p}}$.\n- Corrector:\n$$\nv_{n+1} = v_n + \\Delta t \\, \\big( \\alpha \\, a_{n+1}^{\\mathrm{p}} + \\beta \\, a_n \\big), \\qquad\nx_{n+1} = x_n + \\Delta t \\, v_n + \\Delta t^2 \\, \\big( \\alpha' \\, a_{n+1}^{\\mathrm{p}} + \\beta' \\, a_n \\big).\n$$\n- Energy monitoring: $E_n = \\tfrac{1}{2} v_n^2 + \\tfrac{1}{2} \\omega^2 x_n^2 + \\tfrac{\\varepsilon}{4} x_n^4$.\n- For the Beeman baseline, start with one velocity Verlet step to obtain $(x_1, v_1, a_1)$, then apply Beeman updates thereafter.\n\nStability and exactness for the harmonic case:\n- The calibrated coefficients enforce the exact rotation mapping for harmonic dynamics, hence preserve $E$ exactly for any $\\theta$ with $0 \\le \\theta \\le \\pi$.\n- Near the boundary $\\theta \\lesssim \\pi$, $x_{n+1} \\approx - x_{n-1}$ and energy remains constant; numerical roundoff manifests as tiny fluctuations.\n\nThe program implements both integrators, runs the prescribed test suite, and reports the maximum relative energy deviations in the required order as a single-line bracketed list of floating-point numbers. All angles are in radians, and time is in seconds. The outputs are unitless relative errors, expressed as decimals.", "answer": "```python\nimport numpy as np\n\ndef coeffs_calibrated(theta):\n    \"\"\"\n    Compute calibrated predictor-corrector coefficients (alpha, beta, alpha', beta')\n    as functions of theta = omega * dt, using stable series for small theta.\n    \"\"\"\n    th = theta\n    abs_th = abs(th)\n    if abs_th  1e-6:\n        # Series expansions\n        th2 = th * th\n        th4 = th2 * th2\n        alpha = 0.5 - th2/24.0 + th4/720.0\n        alpha_p = 1.0/6.0 - th2/120.0 + th4/5040.0  # alpha'\n        beta = 0.5 + th2/8.0 - th4/72.0\n        beta_p = 1.0/3.0 + th2/20.0 - th4/336.0     # beta'\n    else:\n        sinth = np.sin(th)\n        costh = np.cos(th)\n        # Direct formulas\n        alpha = (1.0 - costh) / (th * th)\n        alpha_p = (1.0 - (sinth / th)) / (th * th)\n        beta = (sinth / th) + 0.5 * (1.0 - costh) - alpha\n        beta_p = 0.5 * alpha_p * (th * th) + alpha - alpha_p\n    return alpha, beta, alpha_p, beta_p\n\ndef accel(x, omega, eps):\n    # a(x) = -dV/dx = -omega^2 x - eps x^3\n    return - (omega * omega) * x - eps * (x ** 3)\n\ndef energy(x, v, omega, eps):\n    # E = 1/2 v^2 + 1/2 omega^2 x^2 + eps/4 x^4\n    return 0.5 * v * v + 0.5 * (omega * omega) * x * x + 0.25 * eps * (x ** 4)\n\ndef integrate_calibrated(x0, v0, omega, eps, dt, steps):\n    \"\"\"\n    Calibrated predictor-corrector integrator.\n    Returns timeseries of energies for monitoring.\n    \"\"\"\n    theta = omega * dt\n    alpha, beta, alpha_p, beta_p = coeffs_calibrated(theta)\n    x = x0\n    v = v0\n    a = accel(x, omega, eps)\n    energies = [energy(x, v, omega, eps)]\n    for _ in range(steps):\n        # Predictor for position\n        x_pred = x + dt * v + 0.5 * a * dt * dt\n        a_pred = accel(x_pred, omega, eps)\n        # Correctors\n        v_new = v + dt * (alpha * a_pred + beta * a)\n        x_new = x + dt * v + (dt * dt) * (alpha_p * a_pred + beta_p * a)\n        x, v = x_new, v_new\n        a = accel(x, omega, eps)\n        energies.append(energy(x, v, omega, eps))\n    return np.array(energies)\n\ndef integrate_beeman(x0, v0, omega, eps, dt, steps):\n    \"\"\"\n    Beeman integrator with velocity Verlet startup.\n    Returns timeseries of energies for monitoring.\n    \"\"\"\n    # Startup with velocity Verlet for one step\n    x = x0\n    v = v0\n    a = accel(x, omega, eps)\n    energies = [energy(x, v, omega, eps)]\n    # One velocity Verlet step to get a previous acceleration consistent\n    x1 = x + dt * v + 0.5 * a * dt * dt\n    a1 = accel(x1, omega, eps)\n    v1 = v + 0.5 * (a + a1) * dt\n\n    # Record first step\n    x_prev = x\n    a_prev = a\n    x = x1\n    v = v1\n    a = a1\n    energies.append(energy(x, v, omega, eps))\n\n    for _ in range(steps - 1):\n        # Beeman position\n        x_next = x + dt * v + ((2.0/3.0) * a - (1.0/6.0) * a_prev) * dt * dt\n        a_next = accel(x_next, omega, eps)\n        # Beeman velocity\n        v_next = v + ((1.0/3.0) * a_next + (5.0/6.0) * a - (1.0/6.0) * a_prev) * dt\n\n        # Shift\n        x_prev = x\n        a_prev = a\n        x, v = x_next, v_next\n        a = a_next\n        energies.append(energy(x, v, omega, eps))\n\n    return np.array(energies)\n\ndef max_relative_energy_error(energies):\n    E0 = energies[0]\n    errs = np.abs(energies - E0) / (abs(E0) if E0 != 0.0 else 1.0)\n    return float(np.max(errs))\n\ndef solve():\n    results = []\n\n    # Test 1: Harmonic, happy path\n    omega = 3.0\n    dt = 0.2\n    N = 2000\n    x0 = 1.0\n    v0 = 0.0\n    eps = 0.0\n    E_cal = integrate_calibrated(x0, v0, omega, eps, dt, N)\n    err1 = max_relative_energy_error(E_cal)\n    results.append(err1)\n\n    # Test 2: Harmonic, Beeman baseline\n    E_bee = integrate_beeman(x0, v0, omega, eps, dt, N)\n    err2 = max_relative_energy_error(E_bee)\n    results.append(err2)\n\n    # Test 3: Harmonic, near stability limit\n    omega = 2.0\n    dt = 0.99 * np.pi / omega\n    N = 500\n    x0 = 1.0\n    v0 = 0.0\n    eps = 0.0\n    E_cal = integrate_calibrated(x0, v0, omega, eps, dt, N)\n    err3 = max_relative_energy_error(E_cal)\n    results.append(err3)\n\n    # Test 4: Weak anharmonicity\n    omega = 1.0\n    eps = 1.0e-3\n    dt = 0.2\n    N = 2000\n    x0 = 0.5\n    v0 = 0.0\n    E_cal = integrate_calibrated(x0, v0, omega, eps, dt, N)\n    E_bee = integrate_beeman(x0, v0, omega, eps, dt, N)\n    err4_cal = max_relative_energy_error(E_cal)\n    err4_bee = max_relative_energy_error(E_bee)\n    results.append(err4_cal)\n    results.append(err4_bee)\n\n    # Test 5: Moderate anharmonicity\n    omega = 1.0\n    eps = 5.0e-2\n    dt = 0.05\n    N = 2000\n    x0 = 0.5\n    v0 = 0.0\n    E_cal = integrate_calibrated(x0, v0, omega, eps, dt, N)\n    E_bee = integrate_beeman(x0, v0, omega, eps, dt, N)\n    err5_cal = max_relative_energy_error(E_cal)\n    err5_bee = max_relative_energy_error(E_bee)\n    results.append(err5_cal)\n    results.append(err5_bee)\n\n    # Final print in required flattened list format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3396786"}]}