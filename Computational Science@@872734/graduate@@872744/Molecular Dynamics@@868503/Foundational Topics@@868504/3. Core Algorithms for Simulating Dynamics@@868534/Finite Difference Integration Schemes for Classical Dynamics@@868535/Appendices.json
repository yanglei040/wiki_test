{"hands_on_practices": [{"introduction": "To appreciate the sophistication of modern integration schemes, it is instructive to first experience the failure of simpler methods. This exercise serves as a practical demonstration of the pitfalls of non-symplectic integrators. By applying the explicit Euler method to a simple Lennard-Jones dimer, you will observe and quantify the systematic energy drift that violates a fundamental conservation law of Hamiltonian dynamics, directly motivating the need for the more robust, structure-preserving algorithms used in production simulations [@problem_id:3412384].", "problem": "Consider two identical point particles of mass $m$ interacting via a Lennard–Jones potential in three spatial dimensions, modeled in reduced Lennard–Jones units where $m=1$, $\\varepsilon=1$, and $\\sigma=1$. In these units, the natural time unit is $\\tau=\\sigma\\sqrt{m/\\varepsilon}=1$. The Lennard–Jones potential is defined as\n$$\nU(r) = 4\\varepsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right],\n$$\nand the pairwise force on particle $1$ due to particle $2$ is given by\n$$\n\\mathbf{F}_{12} = -\\nabla U(r) = 24\\varepsilon\\left[2\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]\\frac{\\mathbf{r}}{r^2},\n$$\nwhere $\\mathbf{r}=\\mathbf{x}_1-\\mathbf{x}_2$ and $r=\\|\\mathbf{r}\\|$. The system evolves according to Newton’s second law, with the total energy\n$$\nE(t) = \\sum_{i=1}^{2}\\frac{1}{2}m\\|\\mathbf{v}_i(t)\\|^2 + U(\\|\\mathbf{x}_1(t)-\\mathbf{x}_2(t)\\|).\n$$\nYou will approximate the dynamics using the explicit Euler finite difference method for classical dynamics:\n$$\n\\mathbf{x}_i^{n+1} = \\mathbf{x}_i^n + \\Delta t\\,\\mathbf{v}_i^n,\\quad\n\\mathbf{v}_i^{n+1} = \\mathbf{v}_i^n + \\Delta t\\,\\mathbf{a}_i(\\mathbf{x}_1^n,\\mathbf{x}_2^n),\n$$\nwhere $\\mathbf{a}_i=\\mathbf{F}_i/m$ and $\\Delta t$ is the time step.\n\nInitialization: Let $r_{\\mathrm{eq}}=2^{1/6}\\sigma$ be the equilibrium separation of the Lennard–Jones potential minimum. Set the initial positions along the $x$-axis symmetrically so that the center of mass is at the origin,\n$$\n\\mathbf{x}_1(0)=\\left(\\frac{r_0}{2},0,0\\right),\\quad \\mathbf{x}_2(0)=\\left(-\\frac{r_0}{2},0,0\\right),\n$$\nwith $r_0=r_{\\mathrm{eq}}(1+a)$ and $a=0.02$. Set the initial velocities to zero, $\\mathbf{v}_1(0)=\\mathbf{0}$ and $\\mathbf{v}_2(0)=\\mathbf{0}$. Use the reduced units $m=1$, $\\varepsilon=1$, and $\\sigma=1$ throughout. Evolve the system for a total physical time $T=50\\tau$.\n\nTask: For each specified time step $\\Delta t$, integrate the system from $t=0$ to $t=T$ using the explicit Euler method defined above. Compute the global energy drift per unit time,\n$$\nD(\\Delta t) = \\frac{E(T)-E(0)}{T},\n$$\nexpressed in units of $\\varepsilon/\\tau$. Report $D(\\Delta t)$ rounded to six significant figures.\n\nExplain, in terms of first principles and appropriate linearization near the potential minimum, why the dependence of $D(\\Delta t)$ on $\\Delta t$ that you observe is obtained.\n\nTest Suite: Use the following time steps, all in units of $\\tau$,\n- $\\Delta t_1=5\\times 10^{-5}$,\n- $\\Delta t_2=2\\times 10^{-4}$,\n- $\\Delta t_3=8\\times 10^{-4}$,\n- $\\Delta t_4=1.2\\times 10^{-3}$.\n\nFinal Output Format: Your program should produce a single line of output containing the computed drifts $[D(\\Delta t_1),D(\\Delta t_2),D(\\Delta t_3),D(\\Delta t_4)]$ as a comma-separated list enclosed in square brackets, with each entry rounded to six significant figures, and with values expressed in units of $\\varepsilon/\\tau$.", "solution": "The starting point is Newton’s second law for two identical particles of mass $m$ interacting via a central potential $U(r)$,\n$$\nm\\ddot{\\mathbf{x}}_1 = \\mathbf{F}_{12},\\quad m\\ddot{\\mathbf{x}}_2 = \\mathbf{F}_{21}=-\\mathbf{F}_{12},\n$$\nwith $\\mathbf{F}_{12}=-\\nabla U(r)$ and $r=\\|\\mathbf{x}_1-\\mathbf{x}_2\\|$. The Lennard–Jones potential is\n$$\nU(r)=4\\varepsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12}-\\left(\\frac{\\sigma}{r}\\right)^6\\right],\n$$\nso its radial derivative is\n$$\n\\frac{dU}{dr}=4\\varepsilon\\left(-12\\frac{\\sigma^{12}}{r^{13}}+6\\frac{\\sigma^6}{r^7}\\right),\n$$\nand the force vector follows from $\\mathbf{F}=-\\frac{dU}{dr}\\frac{\\mathbf{r}}{r}$ as\n$$\n\\mathbf{F}_{12}=4\\varepsilon\\left(12\\frac{\\sigma^{12}}{r^{14}}-6\\frac{\\sigma^6}{r^8}\\right)\\mathbf{r} = 24\\varepsilon\\left[2\\left(\\frac{\\sigma}{r}\\right)^{12}-\\left(\\frac{\\sigma}{r}\\right)^6\\right]\\frac{\\mathbf{r}}{r^2}.\n$$\nThe total energy is the sum of kinetic and potential energies,\n$$\nE(t) = \\frac{1}{2}m\\|\\mathbf{v}_1(t)\\|^2 + \\frac{1}{2}m\\|\\mathbf{v}_2(t)\\|^2 + U(\\|\\mathbf{x}_1(t)-\\mathbf{x}_2(t)\\|).\n$$\nIn continuous time, with exact dynamics, $E(t)$ is conserved because the force is conservative. When discretizing with explicit Euler, the updates are\n$$\n\\mathbf{x}_i^{n+1} = \\mathbf{x}_i^n + \\Delta t\\,\\mathbf{v}_i^n,\\quad \\mathbf{v}_i^{n+1} = \\mathbf{v}_i^n + \\Delta t\\,\\frac{\\mathbf{F}_i(\\mathbf{x}_1^n,\\mathbf{x}_2^n)}{m}.\n$$\nExplicit Euler is a first-order method that is not symplectic and does not preserve energy for Hamiltonian systems; thus a systematic energy drift is expected.\n\nTo analyze the $\\Delta t$ dependence near equilibrium, linearize the dynamics about the Lennard–Jones minimum at separation $r_{\\mathrm{eq}}=2^{1/6}\\sigma$, where $U'(r_{\\mathrm{eq}})=0$. For small displacements $q=r-r_{\\mathrm{eq}}$, a Taylor expansion yields\n$$\nU(r) \\approx U(r_{\\mathrm{eq}}) + \\frac{1}{2}k\\,q^2,\\quad k=U''(r_{\\mathrm{eq}}).\n$$\nIn reduced units with $m=1$ and $\\sigma=\\varepsilon=1$, the relative coordinate obeys the effective one-dimensional equation for small oscillations. For two equal masses, the relative coordinate $\\mathbf{r}=\\mathbf{x}_1-\\mathbf{x}_2$ satisfies\n$$\n\\ddot{\\mathbf{r}} = \\frac{2}{m}\\mathbf{F}(\\mathbf{r}) \\approx -\\omega^2 \\mathbf{q},\\quad \\omega^2 = \\frac{k}{\\mu},\\quad \\mu=\\frac{m}{2}.\n$$\nHere, $\\mu$ is the reduced mass and $\\mathbf{q}$ is the deviation from equilibrium along the line of centers. For a harmonic oscillator $\\ddot{q}=-\\omega^2 q$, the explicit Euler method applied to the first-order system\n$$\n\\dot{q}=v,\\quad \\dot{v}=-\\omega^2 q\n$$\nupdates according to\n$$\n\\begin{pmatrix} q^{n+1} \\\\ v^{n+1} \\end{pmatrix}\n=\n\\begin{pmatrix}\n1  \\Delta t \\\\\n-\\omega^2 \\Delta t  1\n\\end{pmatrix}\n\\begin{pmatrix} q^{n} \\\\ v^{n} \\end{pmatrix}.\n$$\nThe eigenvalues of this update matrix are\n$$\n\\lambda_{\\pm} = 1 \\pm i\\,\\omega\\,\\Delta t,\n$$\nwith magnitude\n$$\n|\\lambda_{\\pm}| = \\sqrt{1+\\omega^2\\Delta t^2} = 1 + \\frac{1}{2}\\omega^2\\Delta t^2 + \\mathcal{O}(\\Delta t^4).\n$$\nTherefore, the amplitude grows by a factor $|\\lambda|$ per step, and the energy—proportional to amplitude squared for the harmonic approximation—grows per step by a factor\n$$\n|\\lambda|^2 = 1 + \\omega^2\\Delta t^2 + \\mathcal{O}(\\Delta t^4).\n$$\nThe per-step energy increment is thus\n$$\n\\Delta E_{\\text{step}} \\approx \\omega^2 \\Delta t^2\\, E.\n$$\nOver $N=T/\\Delta t$ steps, the total energy change satisfies approximately\n$$\nE(T) - E(0) \\approx N\\,\\Delta E_{\\text{step}} \\approx \\frac{T}{\\Delta t}\\,\\omega^2\\Delta t^2\\,E(0) = \\omega^2 E(0)\\, T\\, \\Delta t,\n$$\nup to higher-order corrections and the slow change of $E$ during the integration. Dividing by $T$ gives the global energy drift per unit time,\n$$\nD(\\Delta t) = \\frac{E(T)-E(0)}{T} \\approx \\omega^2 E(0)\\,\\Delta t,\n$$\nwhich is linear in $\\Delta t$ for sufficiently small $\\Delta t$. This argument relies on linearization near the minimum and the first-order nature of explicit Euler; the method’s global truncation error is $\\mathcal{O}(\\Delta t)$, and the non-symplectic discretization causes secular energy growth.\n\nAlgorithmic design:\n- Use reduced Lennard–Jones units with $m=\\varepsilon=\\sigma=1$, so forces and energies are dimensionless and time is measured in multiples of $\\tau=1$.\n- Initialize two particles symmetrically at $r_0=r_{\\mathrm{eq}}(1+a)$ with $a=0.02$, zero velocities, ensuring the center of mass is at the origin.\n- Implement explicit Euler:\n  - Compute the separation vector $\\mathbf{r}$, its norm $r$, and the Lennard–Jones force $\\mathbf{F}_{12}$.\n  - Update positions via $\\mathbf{x}_i^{n+1}=\\mathbf{x}_i^n+\\Delta t\\,\\mathbf{v}_i^n$.\n  - Update velocities via $\\mathbf{v}_1^{n+1}=\\mathbf{v}_1^n+\\Delta t\\,\\mathbf{F}_{12}/m$ and $\\mathbf{v}_2^{n+1}=\\mathbf{v}_2^n-\\Delta t\\,\\mathbf{F}_{12}/m$.\n- Compute the total energy at $t=0$ and $t=T$ and report $D(\\Delta t)$ as $(E(T)-E(0))/T$.\n- Repeat for the test suite $\\Delta t\\in\\{5\\times 10^{-5}, 2\\times 10^{-4}, 8\\times 10^{-4}, 1.2\\times 10^{-3}\\}$.\n- Round each $D(\\Delta t)$ to six significant figures and output in units of $\\varepsilon/\\tau$.\n\nInterpretation of results:\n- For the smallest $\\Delta t$, $D(\\Delta t)$ should be very small and scale approximately linearly with $\\Delta t$, consistent with the $\\mathcal{O}(\\Delta t)$ global energy drift per unit time derived from the harmonic approximation and the explicit Euler scheme properties.\n- As $\\Delta t$ increases within the small-step regime, $D(\\Delta t)$ increases approximately proportionally to $\\Delta t$, validating the theoretical dependence. Deviations at larger $\\Delta t$ may occur due to the breakdown of the linear approximation and the growth of oscillation amplitude, but the trend remains indicative of the method’s first-order, non-symplectic character.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef lj_force(r_vec, epsilon=1.0, sigma=1.0):\n    \"\"\"\n    Compute the Lennard-Jones force vector on particle 1 due to particle 2.\n    r_vec: separation vector r = x1 - x2\n    \"\"\"\n    r2 = np.dot(r_vec, r_vec)\n    r = np.sqrt(r2)\n    # Avoid division by zero; if r is extremely small, cap the force direction\n    if r == 0.0:\n        return np.zeros_like(r_vec)\n    inv_r2 = 1.0 / r2\n    inv_r6 = (sigma**2 * inv_r2)**3  # (sigma/r)^6\n    inv_r12 = inv_r6**2              # (sigma/r)^12\n    # Force magnitude factor for vector form:\n    # F = 24*epsilon * [2*(sigma/r)^12 - (sigma/r)^6] * r_vec / r^2\n    factor = 24.0 * epsilon * (2.0 * inv_r12 - inv_r6) * inv_r2\n    return factor * r_vec\n\ndef lj_potential(r, epsilon=1.0, sigma=1.0):\n    \"\"\"\n    Compute Lennard-Jones potential U(r).\n    \"\"\"\n    inv_r6 = (sigma / r)**6\n    inv_r12 = inv_r6**2\n    return 4.0 * epsilon * (inv_r12 - inv_r6)\n\ndef total_energy(x1, v1, x2, v2, epsilon=1.0, sigma=1.0, m=1.0):\n    \"\"\"\n    Compute total energy: kinetic + potential.\n    \"\"\"\n    ke = 0.5 * m * np.dot(v1, v1) + 0.5 * m * np.dot(v2, v2)\n    r = np.linalg.norm(x1 - x2)\n    pe = lj_potential(r, epsilon=epsilon, sigma=sigma)\n    return ke + pe\n\ndef energy_drift_per_unit_time(dt, T=50.0, a=0.02, epsilon=1.0, sigma=1.0, m=1.0):\n    \"\"\"\n    Integrate the Lennard-Jones dimer with explicit Euler and compute\n    the global energy drift per unit time (E(T) - E(0)) / T.\n    Units: epsilon/tau, with tau=1 in reduced units.\n    \"\"\"\n    # Equilibrium separation for LJ minimum\n    r_eq = 2.0**(1.0/6.0) * sigma\n    r0 = r_eq * (1.0 + a)\n\n    # Initial positions and velocities (center of mass at origin)\n    x1 = np.array([0.5 * r0, 0.0, 0.0], dtype=float)\n    x2 = np.array([-0.5 * r0, 0.0, 0.0], dtype=float)\n    v1 = np.zeros(3, dtype=float)\n    v2 = np.zeros(3, dtype=float)\n\n    E0 = total_energy(x1, v1, x2, v2, epsilon=epsilon, sigma=sigma, m=m)\n\n    # Number of steps\n    N = int(np.floor(T / dt))\n    # Time integration via explicit Euler\n    for _ in range(N):\n        # Compute force on particle 1 due to particle 2\n        r_vec = x1 - x2\n        F12 = lj_force(r_vec, epsilon=epsilon, sigma=sigma)\n\n        # Update positions\n        x1 = x1 + dt * v1\n        x2 = x2 + dt * v2\n\n        # Update velocities\n        v1 = v1 + dt * (F12 / m)\n        v2 = v2 - dt * (F12 / m)\n\n    E_end = total_energy(x1, v1, x2, v2, epsilon=epsilon, sigma=sigma, m=m)\n    drift = (E_end - E0) / T  # Units: epsilon/tau in reduced units\n    return drift\n\ndef solve():\n    # Define the test cases from the problem statement (time steps in tau units).\n    test_cases = [\n        5e-5,\n        2e-4,\n        8e-4,\n        1.2e-3,\n    ]\n\n    results = []\n    for dt in test_cases:\n        d = energy_drift_per_unit_time(dt)\n        # Round to six significant figures as specified\n        results.append(f\"{d:.6g}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3412384"}, {"introduction": "While symplectic integrators like Velocity Verlet (VV) offer excellent long-term energy stability, their performance is not guaranteed in isolation. This hands-on practice explores the crucial interplay between the integrator and the force calculation, a common scenario when potentials are pre-computed on a grid. You will discover how the choice of a finite-difference scheme to approximate the force—specifically, symmetric versus asymmetric schemes—directly impacts energy conservation, demonstrating that preserving the Hamiltonian structure requires care in all parts of the simulation loop [@problem_id:3412357].", "problem": "Consider a single classical particle of mass $m$ moving in one spatial dimension under a scalar potential energy function $V_{\\text{true}}(r)$. The motion obeys Newton's second law $m\\,d^2 r/dt^2 = F(r)$, where $F(r)$ is the force as a function of position $r$. In molecular dynamics, forces are often computed from tabulated values of $V(r)$ on a grid via finite differences. Your task is to implement and compare three finite-difference force estimators built from a tabulated potential, and then integrate the equations of motion using the Velocity Verlet (VV) method to quantify the systematic energy drift induced by asymmetric force discretizations.\n\nUse the following physically plausible and smooth double-well potential as the reference potential:\n$$\nV_{\\text{true}}(r) = \\tfrac{1}{4}\\,r^4 - \\tfrac{1}{2}\\,r^2.\n$$\n\nTabulate this potential on a uniform grid $r_i = r_{\\min} + i\\,h$ for $i=0,1,\\dots,n-1$ with $r_{\\min}=-2$, $r_{\\max}=2$, and spacing $h$ specified by each test case. The tabulated values are $V_i = V_{\\text{true}}(r_i)$. For any off-grid position $r$ encountered during integration, define the cell index\n$$\ni = \\left\\lfloor \\frac{r - r_{\\min}}{h} \\right\\rfloor,\n$$\nand constrain array accesses so they remain within valid index ranges for each scheme. From the tabulated $V_i$, define three force estimators $F_{\\text{fd}}(r)$ as follows:\n- Forward difference (piecewise constant slope over the current cell $[r_i,r_{i+1})$):\n$$\nF_{\\text{fwd}}(r) = -\\frac{V_{i+1} - V_{i}}{h}.\n$$\n- Backward difference (slope over the previous cell $[r_{i-1},r_{i})$):\n$$\nF_{\\text{bwd}}(r) = -\\frac{V_{i} - V_{i-1}}{h}.\n$$\n- Centered difference (symmetric two-point slope across $[r_{i-1},r_{i+1}]$):\n$$\nF_{\\text{cen}}(r) = -\\frac{V_{i+1} - V_{i-1}}{2h}.\n$$\n\nIntegrate the equations of motion using the Velocity Verlet (VV) algorithm, constructed from Newton's second law and the definition of velocity $v = dr/dt$, to advance position $r$ and velocity $v$ over time with constant time step $\\Delta t$ specified by each test case. Use the chosen $F_{\\text{fd}}(r)$ to compute accelerations $a(r) = F_{\\text{fd}}(r)/m$ within the VV updates. Throughout the simulation, compute the instantaneous total energy using the reference potential,\n$$\nE(t) = \\tfrac{1}{2}\\,m\\,v(t)^2 + V_{\\text{true}}(r(t)).\n$$\nQuantify the systematic energy drift by performing an ordinary least-squares linear regression of $E(t)$ versus $t$ over the entire simulated trajectory, and report the best-fit slope $dE/dt$ as a single scalar per test case. Express each reported slope in energy units per unit time.\n\nThe following test suite specifies all parameters. For each case, use $m=1$ (dimensionless mass), initial position $r(0)=1.2$, and initial velocity $v(0)=0$. For all cases, take $r_{\\min}=-2$ and $r_{\\max}=2$. For each case, simulate for $N_{\\text{steps}}$ time steps of size $\\Delta t$, and compute the least-squares slope $dE/dt$ as described above.\n\n- Case $1$ (happy path, fine grid, symmetric force): scheme $=$ centered, $h=0.02$, $\\Delta t = 0.02$, $N_{\\text{steps}}=30000$.\n- Case $2$ (fine grid, asymmetric forward force): scheme $=$ forward, $h=0.02$, $\\Delta t = 0.02$, $N_{\\text{steps}}=30000$.\n- Case $3$ (fine grid, asymmetric backward force): scheme $=$ backward, $h=0.02$, $\\Delta t = 0.02$, $N_{\\text{steps}}=30000$.\n- Case $4$ (coarse grid, symmetric force): scheme $=$ centered, $h=0.20$, $\\Delta t = 0.02$, $N_{\\text{steps}}=30000$.\n- Case $5$ (coarse grid, asymmetric forward force): scheme $=$ forward, $h=0.20$, $\\Delta t = 0.02$, $N_{\\text{steps}}=30000$.\n- Case $6$ (coarse grid, asymmetric backward force): scheme $=$ backward, $h=0.20$, $\\Delta t = 0.02$, $N_{\\text{steps}}=30000$.\n\nYour program must implement the tabulation and force estimators exactly as defined, use the standard Velocity Verlet algorithm derived from Newton's laws, and compute the least-squares slope for each case. If $r$ leaves the tabulated interval $[r_{\\min}, r_{\\max}]$ due to numerical error, constrain the finite difference index so that array access remains valid and continue the integration; do not apply any additional boundary forces.\n\nFinal output format requirement:\n- Produce a single line of output containing the six drift rates in order from Case $1$ to Case $6$, expressed in energy units per unit time. The line must be a comma-separated list enclosed in square brackets, for example, $[x_1,x_2,x_3,x_4,x_5,x_6]$. Scientific notation is allowed. No other text may be printed.", "solution": "The problem requires an investigation into the long-term energy conservation properties of the Velocity Verlet integration algorithm when combined with different finite-difference schemes for force calculation. We will simulate the one-dimensional motion of a classical particle and quantify the systematic energy drift that arises from numerical inaccuracies, particularly the asymmetry of the force estimators.\n\nThe particle has a mass $m$ and moves according to Newton's second law, $m\\ddot{r} = F(r)$, where $r$ is the position and $F(r)$ is the force. The true physical system is defined by a smooth, continuous potential energy function $V_{\\text{true}}(r) = \\tfrac{1}{4}r^4 - \\tfrac{1}{2}r^2$. The corresponding true force is $F_{\\text{true}}(r) = -dV_{\\text{true}}/dr = - (r^3 - r)$. In this exact physical system, the total energy $E(t) = \\tfrac{1}{2}m v(t)^2 + V_{\\text{true}}(r(t))$ is a conserved quantity, meaning $dE/dt = 0$.\n\nIn a typical numerical simulation, the force is not known analytically but is derived from a potential energy surface that is tabulated on a discrete grid. We are given a grid of points $r_i = r_{\\min} + i h$ for $i=0, \\dots, n-1$, where the potential values are $V_i = V_{\\text{true}}(r_i)$. The force on the particle at an arbitrary position $r$ must then be estimated from these tabulated values. The problem specifies three common finite-difference estimators. For a particle at position $r$ located in the grid cell $[r_i, r_{i+1})$, where $i = \\lfloor (r - r_{\\min})/h \\rfloor$, the estimators are:\n\n1.  **Forward difference**: $F_{\\text{fwd}}(r) = -\\frac{V_{i+1} - V_{i}}{h}$. This estimator is based on the slope of the potential over the cell the particle currently occupies. It is a first-order accurate approximation to the true derivative, with an error of order $\\mathcal{O}(h)$. It is inherently asymmetric.\n2.  **Backward difference**: $F_{\\text{bwd}}(r) = -\\frac{V_{i} - V_{i-1}}{h}$. This uses the slope over the cell the particle just left. It is also first-order accurate, $\\mathcal{O}(h)$, and asymmetric.\n3.  **Centered difference**: $F_{\\text{cen}}(r) = -\\frac{V_{i+1} - V_{i-1}}{2h}$. This symmetrically uses points on either side of the current cell's base point $r_i$. It is a second-order accurate approximation, with error $\\mathcal{O}(h^2)$.\n\nThe particle's trajectory is generated by integrating the equations of motion numerically. The problem specifies the Velocity Verlet (VV) algorithm, a standard choice in molecular dynamics due to its excellent stability and long-term energy conservation properties. Given the position $r(t)$, velocity $v(t)$, and acceleration $a(t) = F_{\\text{fd}}(r(t))/m$ at time $t$, the state at time $t+\\Delta t$ is computed as:\n$$\nr(t+\\Delta t) = r(t) + v(t)\\Delta t + \\tfrac{1}{2}a(t)(\\Delta t)^2\n$$\n$$\na(t+\\Delta t) = F_{\\text{fd}}(r(t+\\Delta t))/m\n$$\n$$\nv(t+\\Delta t) = v(t) + \\tfrac{1}{2}\\left[ a(t) + a(t+\\Delta t) \\right] \\Delta t\n$$\nThe VV algorithm is time-reversible and symplectic. When combined with a force calculation that is the exact gradient of some potential (i.e., a conservative force), VV exactly conserves a nearby \"shadow\" Hamiltonian, leading to bounded energy fluctuations around a constant value. However, the finite-difference forces defined here are piecewise constant and are not, in general, the gradient of a single, smooth potential function. The quality of energy conservation is therefore determined by the properties of the force approximation. The symmetric centered-difference scheme is expected to yield superior energy conservation (minimal systematic drift), whereas the asymmetric forward and backward schemes are expected to produce a non-zero systematic drift, causing the energy to steadily increase or decrease over time. The magnitude of this effect should be more pronounced for a coarser grid (larger $h$).\n\nOur implementation will proceed as follows for each test case:\n1.  **System Setup**: The parameters $m=1$, $r_{\\min}=-2$, $r_{\\max}=2$, and the initial conditions $r(0)=1.2$, $v(0)=0$ are set. The specific scheme, grid spacing $h$, and time step $\\Delta t$ for the case are selected.\n2.  **Potential Tabulation**: A grid of positions $r_i$ from $r_{\\min}$ to $r_{\\max}$ with spacing $h$ is created. The potential $V_{\\text{true}}(r_i)$ is evaluated and stored for each grid point, creating the table $V_i$. The number of grid points is $n = (r_{\\max} - r_{\\min}) / h + 1$.\n3.  **Force Function**: A function is implemented to calculate the force $F_{\\text{fd}}(r)$. This function first determines the grid index $i = \\lfloor(r - r_{\\min})/h\\rfloor$. It then performs index clamping to ensure that all lookups into the $V_i$ table are within the valid bounds $[0, n-1]$. For example, for the centered scheme, $i$ is clamped to the range $[1, n-2]$ to ensure $i-1$ and $i+1$ are valid indices. The appropriate finite-difference formula is then applied using the clamped index.\n4.  **Numerical Integration**: A loop runs for $N_{\\text{steps}}$ iterations. In each iteration, the Velocity Verlet algorithm updates the particle's position and velocity using the force calculated by the function from step $3$. After each step, the total energy $E(t) = \\tfrac{1}{2}m v^2 + V_{\\text{true}}(r)$ is computed using the true, continuous potential function. The time and corresponding energy are stored.\n5.  **Drift Analysis**: After the simulation is complete, we have a time series of total energy values, $\\{E(t_k)\\}$. An ordinary least-squares linear regression is performed on these data against time, fitting a model $E(t) = at+b$. The resulting slope, $a = dE/dt$, provides a quantitative measure of the systematic energy drift. This slope is the final result for each case.\n\nBy comparing the resulting drift rates, we will empirically validate the theoretical expectation that symmetric force discretizations are crucial for long-term energy conservation in symplectic integration schemes.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    \n    # Define physical constants and initial conditions as per the problem.\n    M_PARTICLE = 1.0\n    R_MIN = -2.0\n    R_MAX = 2.0\n    R_INITIAL = 1.2\n    V_INITIAL = 0.0\n\n    # Define the reference potential energy function.\n    def V_true(r):\n        \"\"\"\n        Calculates the true potential energy V_true(r) = 1/4*r^4 - 1/2*r^2.\n        \"\"\"\n        return 0.25 * r**4 - 0.5 * r**2\n\n    def run_simulation(scheme, h, dt, n_steps):\n        \"\"\"\n        Runs a single molecular dynamics simulation for a given set of parameters.\n\n        Args:\n            scheme (str): The force estimation scheme ('centered', 'forward', 'backward').\n            h (float): The grid spacing for the potential tabulation.\n            dt (float): The time step for the Velocity Verlet integrator.\n            n_steps (int): The total number of integration steps.\n\n        Returns:\n            float: The slope of the energy vs. time, representing the energy drift rate.\n        \"\"\"\n        # 1. Tabulate the potential on a uniform grid.\n        # Use round() to avoid float precision issues in calculating n_grid.\n        n_grid = int(round((R_MAX - R_MIN) / h)) + 1\n        r_grid = np.linspace(R_MIN, R_MAX, n_grid)\n        V_grid = V_true(r_grid)\n\n        # 2. Define the force calculation function based on the tabulated potential.\n        def get_force(r_pos):\n            \"\"\"\n            Calculates the force at position r_pos using a finite-difference scheme.\n            Includes index clamping to handle boundary conditions.\n            \"\"\"\n            # Determine the grid cell index for the current position.\n            i_float = (r_pos - R_MIN) / h\n            i = int(np.floor(i_float))\n\n            # Apply index clamping to ensure array access is always valid.\n            if scheme == 'centered':\n                i = np.clip(i, 1, n_grid - 2)\n                force = -(V_grid[i + 1] - V_grid[i - 1]) / (2.0 * h)\n            elif scheme == 'forward':\n                i = np.clip(i, 0, n_grid - 2)\n                force = -(V_grid[i + 1] - V_grid[i]) / h\n            elif scheme == 'backward':\n                i = np.clip(i, 1, n_grid - 1)\n                force = -(V_grid[i] - V_grid[i - 1]) / h\n            else:\n                # This case should not be reached with valid problem inputs.\n                raise ValueError(f\"Unknown scheme: {scheme}\")\n            \n            return force\n\n        # 3. Initialize simulation variables.\n        r = R_INITIAL\n        v = V_INITIAL\n        \n        times = np.arange(n_steps + 1) * dt\n        energies = np.zeros(n_steps + 1)\n        \n        # Store initial energy.\n        energies[0] = 0.5 * M_PARTICLE * v**2 + V_true(r)\n        \n        # Calculate initial acceleration.\n        a = get_force(r) / M_PARTICLE\n\n        # 4. Perform the Velocity Verlet integration.\n        for step in range(n_steps):\n            # Update position.\n            r_new = r + v * dt + 0.5 * a * dt**2\n            \n            # Update force/acceleration at the new position.\n            a_new = get_force(r_new) / M_PARTICLE\n            \n            # Update velocity.\n            v_new = v + 0.5 * (a + a_new) * dt\n            \n            # Update state for the next iteration.\n            r, v, a = r_new, v_new, a_new\n            \n            # Calculate and store the total energy using the true potential.\n            energies[step + 1] = 0.5 * M_PARTICLE * v**2 + V_true(r)\n\n        # 5. Quantify energy drift via linear regression.\n        # np.polyfit(x, y, 1) returns [slope, intercept] for a linear fit.\n        slope, _ = np.polyfit(times, energies, 1)\n        \n        return slope\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path, fine grid, symmetric force)\n        {'scheme': 'centered', 'h': 0.02, 'dt': 0.02, 'n_steps': 30000},\n        # Case 2 (fine grid, asymmetric forward force)\n        {'scheme': 'forward',  'h': 0.02, 'dt': 0.02, 'n_steps': 30000},\n        # Case 3 (fine grid, asymmetric backward force)\n        {'scheme': 'backward', 'h': 0.02, 'dt': 0.02, 'n_steps': 30000},\n        # Case 4 (coarse grid, symmetric force)\n        {'scheme': 'centered', 'h': 0.20, 'dt': 0.02, 'n_steps': 30000},\n        # Case 5 (coarse grid, asymmetric forward force)\n        {'scheme': 'forward',  'h': 0.20, 'dt': 0.02, 'n_steps': 30000},\n        # Case 6 (coarse grid, asymmetric backward force)\n        {'scheme': 'backward', 'h': 0.20, 'dt': 0.02, 'n_steps': 30000},\n    ]\n\n    results = []\n    for case in test_cases:\n        drift_rate = run_simulation(case['scheme'], case['h'], case['dt'], case['n_steps'])\n        results.append(drift_rate)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6e}' for r in results)}]\")\n\nsolve()\n```", "id": "3412357"}, {"introduction": "Real-world molecular systems often evolve on multiple time scales, making a fixed integration step inefficient. This exercise delves into adaptive time-stepping, a powerful technique for optimizing simulations by adjusting the step size $\\Delta t$ based on a local error estimate. By implementing an adaptive Velocity Verlet scheme, you will uncover a fundamental trade-off: while local accuracy is controlled, the act of varying the time step breaks the algorithm's strict symplecticity, reintroducing a long-term energy drift that is absent in the fixed-step counterpart [@problem_id:3412413].", "problem": "You will implement and analyze adaptive time-stepping for classical dynamics using the Velocity Verlet (VV) method. Start from Newton's second law of motion and work within the reduced, dimensionless unit system typical of molecular dynamics where mass and potential parameters are normalized. Your task combines principled derivation, algorithm design, and quantitative assessment of long-time energy behavior.\n\nUse the following physical setup and unit conventions:\n- The system is a one-dimensional harmonic oscillator with mass $m$ and spring constant $k$, where the force satisfies $F(x) = -kx$ and $m=1$, $k=1$ in reduced units.\n- The state is position $x(t)$ and velocity $v(t)$, with total energy $E(t) = \\tfrac{1}{2} m v(t)^2 + \\tfrac{1}{2} k x(t)^2$ in dimensionless units.\n\nRequired algorithmic components:\n1. Derive the explicit update rules of the Velocity Verlet (VV) integrator from $m \\ddot{x} = F(x)$, then implement it.\n2. Implement a local error estimator by comparing one full VV step of size $\\Delta t$ to two successive VV half-steps of size $\\Delta t/2$, both starting from the same current state $(x,v)$. Define the local error as the state-space norm\n$$\ne = \\sqrt{\\left(x_{\\mathrm{full}} - x_{\\mathrm{half}}\\right)^2 + \\left(\\Delta t\\,(v_{\\mathrm{full}} - v_{\\mathrm{half}})\\right)^2}\\,,\n$$\nwhich balances position and velocity differences using the current $\\Delta t$ so both terms have the units of position.\n3. Implement an adaptive time-step controller driven by the estimated local error $e$ with tolerance $\\varepsilon$:\n   - If $e \\le \\varepsilon$, accept the step and advance time by $\\Delta t$. Use the two half-steps state $(x_{\\mathrm{half}},v_{\\mathrm{half}})$ as the accepted next state.\n   - If $e  \\varepsilon$, reject the step, reduce $\\Delta t$ by a factor $r_{\\downarrow}$, and recompute from the same current state without advancing time.\n   - After an accepted step, if $e  \\varepsilon/2$, increase $\\Delta t$ by a factor $r_{\\uparrow}$ for the next proposal; otherwise, keep $\\Delta t$ unchanged.\n   - Enforce $\\Delta t \\in [\\Delta t_{\\min}, \\Delta t_{\\max}]$ at all times.\n4. In parallel, run a baseline fixed-step VV simulation using the initial step size $\\Delta t_0$ without any adaptivity.\n5. Quantify long-time energy drift for both the adaptive and fixed-step runs by fitting a straight line to $E(t)$ versus $t$ over the full simulated interval and taking the absolute value of the slope. That is, compute the least-squares fit parameters $(\\alpha,\\beta)$ minimizing $\\sum_i \\left(E(t_i) - (\\alpha t_i + \\beta)\\right)^2$, and report $D = |\\alpha|$ as the drift rate in energy per unit time (dimensionless).\n6. Discuss, in your solution, the trade-off introduced by breaking symplecticity when $\\Delta t$ varies, and relate it to the observed energy drift.\n\nSimulation and units:\n- Use reduced, dimensionless units with $m=1$ and $k=1$, so that time, position, velocity, and energy are dimensionless.\n- Express the final energy drift rates $D$ in dimensionless energy per unit time.\n\nTest suite:\nFor each test case, run both the adaptive and the fixed-step simulations from the same initial condition $(x(0),v(0))$ and total simulated time $T$, and report the three metrics specified below. Use the following parameter sets:\n\n- Test case $1$: $T=200$, $x(0)=1$, $v(0)=0$, $\\Delta t_0=0.1$, $\\varepsilon=10^{-5}$, $\\Delta t_{\\min}=10^{-4}$, $\\Delta t_{\\max}=0.3$, $r_{\\uparrow}=1.25$, $r_{\\downarrow}=0.5$.\n- Test case $2$: $T=50$, $x(0)=1$, $v(0)=0$, $\\Delta t_0=0.05$, $\\varepsilon=10^{-8}$, $\\Delta t_{\\min}=10^{-5}$, $\\Delta t_{\\max}=0.2$, $r_{\\uparrow}=1.25$, $r_{\\downarrow}=0.5$.\n- Test case $3$: $T=200$, $x(0)=1$, $v(0)=0$, $\\Delta t_0=0.1$, $\\varepsilon=10^{-3}$, $\\Delta t_{\\min}=10^{-4}$, $\\Delta t_{\\max}=0.5$, $r_{\\uparrow}=1.25$, $r_{\\downarrow}=0.5$.\n- Test case $4$: $T=200$, $x(0)=1$, $v(0)=0$, $\\Delta t_0=0.2$, $\\varepsilon=5\\times 10^{-4}$, $\\Delta t_{\\min}=10^{-4}$, $\\Delta t_{\\max}=0.8$, $r_{\\uparrow}=1.25$, $r_{\\downarrow}=0.5$.\n\nFinal output format:\n- For each test case $j$, compute:\n  1. $D_{\\mathrm{adapt}}^{(j)}$: the absolute energy drift rate of the adaptive VV run.\n  2. $D_{\\mathrm{fixed}}^{(j)}$: the absolute energy drift rate of the fixed-step VV run.\n  3. $\\langle \\Delta t \\rangle^{(j)}$: the average accepted step size over the adaptive VV run.\n- Your program should produce a single line of output containing all results as a comma-separated list enclosed in square brackets, flattened across test cases in order $j=1,2,3,4$:\n$$\n\\bigl[D_{\\mathrm{adapt}}^{(1)},\\,D_{\\mathrm{fixed}}^{(1)},\\,\\langle \\Delta t \\rangle^{(1)},\\,D_{\\mathrm{adapt}}^{(2)},\\,D_{\\mathrm{fixed}}^{(2)},\\,\\langle \\Delta t \\rangle^{(2)},\\,D_{\\mathrm{adapt}}^{(3)},\\,D_{\\mathrm{fixed}}^{(3)},\\,\\langle \\Delta t \\rangle^{(3)},\\,D_{\\mathrm{adapt}}^{(4)},\\,D_{\\mathrm{fixed}}^{(4)},\\,\\langle \\Delta t \\rangle^{(4)}\\bigr]\\,.\n$$\nAll quantities are dimensionless floats.", "solution": "The problem requires the implementation and analysis of an adaptive time-stepping scheme for the Velocity Verlet (VV) integrator, applied to a one-dimensional harmonic oscillator. The performance of this adaptive scheme is to be compared against a standard fixed-step VV simulation, with a focus on long-term energy conservation.\n\nThe system is a particle of mass $m=1$ subject to a linear restoring force $F(x) = -kx$ with spring constant $k=1$, in a reduced, dimensionless unit system. The total energy is the sum of kinetic and potential energies:\n$$\nE(t) = \\frac{1}{2} m v(t)^2 + \\frac{1}{2} k x(t)^2 = \\frac{1}{2} v(t)^2 + \\frac{1}{2} x(t)^2\n$$\n\nFirst, we derive the update rules for the Velocity Verlet integrator. The algorithm is derived from Taylor series expansions of position $x(t)$ and velocity $v(t)$.\nThe position at time $t+\\Delta t$ is expanded to second order:\n$$\nx(t+\\Delta t) = x(t) + v(t)\\Delta t + \\frac{1}{2} a(t) \\Delta t^2 + \\mathcal{O}(\\Delta t^3)\n$$\nwhere $v(t) = \\dot{x}(t)$ is the velocity and $a(t) = \\ddot{x}(t) = F(x(t))/m$ is the acceleration.\n\nThe velocity update is constructed to be time-symmetric, which is key to the algorithm's stability and symplectic nature. We approximate the velocity integral using the trapezoidal rule, averaging the acceleration at the beginning and end of the time step:\n$$\nv(t+\\Delta t) = v(t) + \\int_{t}^{t+\\Delta t} a(\\tau) d\\tau \\approx v(t) + \\frac{1}{2}\\left[ a(t) + a(t+\\Delta t) \\right] \\Delta t\n$$\nwhere $a(t+\\Delta t) = F(x(t+\\Delta t))/m$. This leads to the following widely-used implementation of a single Velocity Verlet step:\n1.  Calculate the new position $x_{n+1} = x(t+\\Delta t)$ from the state at time $t_n=t$:\n    $$x_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} a_n \\Delta t^2$$\n2.  Calculate the new acceleration $a_{n+1}$ using the new position:\n    $$a_{n+1} = \\frac{F(x_{n+1})}{m}$$\n3.  Calculate the new velocity $v_{n+1} = v(t+\\Delta t)$:\n    $$v_{n+1} = v_n + \\frac{1}{2} (a_n + a_{n+1}) \\Delta t$$\nThis algorithm is time-reversible and, for a fixed step size $\\Delta t$, symplectic.\n\nNext, we design the adaptive time-stepping scheme. The core idea is to estimate the local truncation error of a single step and adjust $\\Delta t$ to keep this error below a specified tolerance $\\varepsilon$. A common method for error estimation is to compare the result of one step of size $\\Delta t$ with the result of two steps of size $\\Delta t/2$.\nLet the state at time $t$ be $(x, v)$.\n-   A single \"full\" step of size $\\Delta t$ yields the state $(x_{\\mathrm{full}}, v_{\\mathrm{full}})$.\n-   Two successive \"half\" steps of size $\\Delta t/2$ yield the state $(x_{\\mathrm{half}}, v_{\\mathrm{half}})$.\nThe two-half-step result is more accurate. The difference between these two computed states provides an estimate of the local error. The problem defines a specific scalar error measure $e$:\n$$\ne = \\sqrt{\\left(x_{\\mathrm{full}} - x_{\\mathrm{half}}\\right)^2 + \\left(\\Delta t\\,(v_{\\mathrm{full}} - v_{\\mathrm{half}})\\right)^2}\n$$\nThe factor of $\\Delta t$ in the velocity term ensures both terms have units of position, providing a balanced state-space error norm.\n\nThe step size controller operates as follows for a proposed step $\\Delta t$:\n1.  If the estimated error $e$ is greater than the tolerance $\\varepsilon$ ($e > \\varepsilon$), the step is rejected. The time step is reduced, $\\Delta t \\to \\Delta t \\times r_{\\downarrow}$, and the step is re-attempted from the same initial state. Time does not advance.\n2.  If the error is within the tolerance ($e \\le \\varepsilon$), the step is accepted. The system state is advanced to the more accurate half-step result, $(x, v) \\to (x_{\\mathrm{half}}, v_{\\mathrm{half}})$, and time advances by $\\Delta t$.\n3.  After an accepted step, the step size for the next proposal is adjusted. If the error was comfortably small, $e  \\varepsilon/2$, the step size is increased: $\\Delta t \\to \\Delta t \\times r_{\\uparrow}$. Otherwise, it remains unchanged.\n4.  At all times, the step size is clamped to the range $[\\Delta t_{\\min}, \\Delta t_{\\max}]$.\n\nA crucial aspect of this problem is the trade-off between local accuracy and long-term stability. The fixed-step Velocity Verlet integrator is symplectic. For a Hamiltonian system, this means it exactly conserves a \"shadow\" Hamiltonian, $H_{\\Delta t}$, which is close to the true Hamiltonian $H$. This property leads to bounded energy fluctuations around a constant value over very long simulations and an absence of systematic energy drift. When the time step $\\Delta t$ is varied, as in our adaptive scheme, the integrator switches between different symplectic maps at each step, each corresponding to a different shadow Hamiltonian. The composition of these maps is no longer symplectic. Consequently, no single shadow Hamiltonian is conserved, and the excellent long-term energy conservation is lost. This typically manifests as a systematic, linear drift in the total energy, even though the local error is controlled at every step.\n\nTo quantify this, we compare the adaptive simulation to a baseline fixed-step simulation using the initial step size $\\Delta t_0$. For both runs, we compute the energy drift rate $D$ by performing a linear least-squares fit to the energy data $E(t_i)$ versus time $t_i$. The drift $D$ is the absolute value of the slope of this fit, $D=|\\alpha|$, where the fit is $E(t) = \\alpha t + \\beta$. We expect $D_{\\mathrm{fixed}}$ to be very close to zero (reflecting bounded oscillations), while $D_{\\mathrm{adapt}}$ will be larger, demonstrating the energy drift induced by breaking symplecticity. We also compute the average accepted time step $\\langle \\Delta t \\rangle$ for the adaptive run to gauge its efficiency.\n\nThe implementation will simulate the system for each test case, running both the adaptive and fixed-step schemes. It will then calculate the three specified metrics ($D_{\\mathrm{adapt}}$, $D_{\\mathrm{fixed}}$, $\\langle \\Delta t \\rangle$) and report them in the required format. The linear fit is performed using NumPy's `polyfit` function. All simulations are carried out in the specified dimensionless units.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy is not needed, numpy.polyfit is sufficient.\n\ndef solve():\n    \"\"\"\n    Main function to run the simulations and print the final results.\n    \"\"\"\n    # Define physical constants in reduced units\n    M_MASS = 1.0\n    K_SPRING = 1.0\n\n    def force(x):\n        \"\"\"Calculates the force F(x) = -kx for the harmonic oscillator.\"\"\"\n        return -K_SPRING * x\n\n    def energy(x, v):\n        \"\"\"Calculates the total energy E = 1/2*m*v^2 + 1/2*k*x^2.\"\"\"\n        return 0.5 * M_MASS * v**2 + 0.5 * K_SPRING * x**2\n\n    def vv_step(x, v, dt):\n        \"\"\"\n        Performs a single step of the Velocity Verlet algorithm.\n        \"\"\"\n        a = force(x) / M_MASS\n        x_new = x + v * dt + 0.5 * a * dt**2\n        a_new = force(x_new) / M_MASS\n        v_new = v + 0.5 * (a + a_new) * dt\n        return x_new, v_new\n\n    def run_fixed_step(x0, v0, T, dt0):\n        \"\"\"\n        Runs a simulation with a fixed time step.\n        \"\"\"\n        t = 0.0\n        x, v = x0, v0\n        \n        times = [t]\n        energies = [energy(x, v)]\n        \n        while t  T:\n            # Ensure the last step hits T exactly\n            current_dt = min(dt0, T - t)\n            if current_dt  1e-12: break\n            \n            x, v = vv_step(x, v, current_dt)\n            t += current_dt\n            \n            times.append(t)\n            energies.append(energy(x, v))\n            \n        return np.array(times), np.array(energies)\n\n    def run_adaptive_step(x0, v0, T, dt0, eps, dt_min, dt_max, r_up, r_down):\n        \"\"\"\n        Runs a simulation with an adaptive time step.\n        \"\"\"\n        t = 0.0\n        x, v = x0, v0\n        dt = dt0\n        \n        times = [t]\n        energies = [energy(x, v)]\n        accepted_dts = []\n\n        while t  T:\n            actual_dt = min(dt, T - t)\n            \n            # Failsafe for the very last, potentially tiny step\n            if actual_dt  1e-12:\n                break\n\n            step_accepted = False\n            while not step_accepted:\n                # One full step\n                x_full, v_full = vv_step(x, v, actual_dt)\n                \n                # Two half steps\n                x_mid, v_mid = vv_step(x, v, actual_dt / 2.0)\n                x_half, v_half = vv_step(x_mid, v_mid, actual_dt / 2.0)\n\n                # Calculate local error\n                error = np.sqrt((x_full - x_half)**2 + (actual_dt * (v_full - v_half))**2)\n\n                if error = eps:  # Accept step\n                    step_accepted = True\n                    \n                    # Advance to new state using more accurate half-step result\n                    t += actual_dt\n                    x, v = x_half, v_half\n                    \n                    times.append(t)\n                    energies.append(energy(x, v))\n                    accepted_dts.append(actual_dt)\n                    \n                    # Update dt for the NEXT proposal\n                    if error  eps / 2.0 and dt  dt_max:\n                        dt_proposal = dt * r_up\n                    else:\n                        dt_proposal = dt\n                    \n                    dt = min(dt_max, dt_proposal)\n\n                else:  # Reject step\n                    dt_proposal = dt * r_down\n                    dt = max(dt_min, dt_proposal)\n                    actual_dt = min(dt, T - t) # Update dt for retry\n                    if actual_dt  1e-12: # Avoid infinite loop if dt becomes too small\n                        step_accepted = True # effectively give up and finish\n                        t = T \n\n        return np.array(times), np.array(energies), np.array(accepted_dts)\n\n    def calculate_drift(times, energies):\n        \"\"\"\n        Calculates the energy drift rate |alpha| from a linear fit E(t) = alpha*t + beta.\n        \"\"\"\n        if len(times)  2:\n            return 0.0\n        slope, _ = np.polyfit(times, energies, 1)\n        return abs(slope)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # T, x0, v0, dt0, eps, dt_min, dt_max, r_up, r_down\n        (200.0, 1.0, 0.0, 0.1, 1e-5, 1e-4, 0.3, 1.25, 0.5),\n        (50.0, 1.0, 0.0, 0.05, 1e-8, 1e-5, 0.2, 1.25, 0.5),\n        (200.0, 1.0, 0.0, 0.1, 1e-3, 1e-4, 0.5, 1.25, 0.5),\n        (200.0, 1.0, 0.0, 0.2, 5e-4, 1e-4, 0.8, 1.25, 0.5),\n    ]\n\n    results = []\n    for case in test_cases:\n        T, x0, v0, dt0, eps, dt_min, dt_max, r_up, r_down = case\n        \n        # Adaptive run\n        t_adapt, E_adapt, dts_adapt = run_adaptive_step(x0, v0, T, dt0, eps, dt_min, dt_max, r_up, r_down)\n        D_adapt = calculate_drift(t_adapt, E_adapt)\n        avg_dt = np.mean(dts_adapt) if len(dts_adapt)  0 else 0.0\n\n        # Fixed-step run\n        t_fixed, E_fixed = run_fixed_step(x0, v0, T, dt0)\n        D_fixed = calculate_drift(t_fixed, E_fixed)\n        \n        results.extend([D_adapt, D_fixed, avg_dt])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3412413"}]}