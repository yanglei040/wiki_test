{"hands_on_practices": [{"introduction": "A crucial skill in computational science is the ability to verify the correctness and stability of a numerical simulation. In molecular dynamics, this begins with a thorough energy audit. This exercise introduces three fundamental diagnostics: the secular energy drift rate ($s$), the amplitude of energy fluctuations ($R$), and the time-reversibility error ($J$). By implementing and comparing a symplectic integrator (velocity Verlet) against a general-purpose non-symplectic one (classical fourth-order Runge-Kutta), you will gain direct, hands-on experience with their profoundly different behaviors in long-term simulations of conservative systems [@problem_id:3409941].", "problem": "Consider a deterministic, closed classical system in molecular dynamics with a Hamiltonian $H(q,p) = T(p) + U(q)$, where $q$ denotes positions, $p$ denotes momenta, $T(p)$ is the kinetic energy, and $U(q)$ is the potential energy. The exact dynamics follow Newton's second law and Hamilton's equations, ensuring that the total energy $E(t) = H(q(t),p(t))$ is conserved, i.e., $dE/dt = 0$ for the continuous trajectory. In a discrete-time numerical simulation with time step $\\Delta t$, the numerical flow depends on the integrator. Symplectic, time-reversible integrators (for example, the velocity Verlet method) are known to exhibit near-conservation of a modified (shadow) Hamiltonian over long times, while generic non-symplectic integrators (for example, the classical fourth-order Runge–Kutta method) may exhibit secular energy drift. Energy audits and diagnostics quantify energy conservation, drift, and long-term stability of an algorithm on a given system.\n\nYour task is to implement two numerical integrators for two systems, run long trajectories, and compute three diagnostics for each test case:\n\n- A linear energy drift rate $s$ defined by the slope of the least-squares fit of $\\Delta E(t) = E(t) - E(0)$ as a function of $t$.\n- The root-mean-square fluctuation amplitude $R$ of $\\Delta E(t)$ after subtracting the best-fit line, i.e., the square root of the mean of the squared residuals of the fit.\n- A time-reversibility error $J$ computed by integrating forward for $N$ steps, reversing velocities, integrating for another $N$ steps, and measuring the Euclidean phase-space error between the final state and the initial state.\n\nBase your work on the following fundamental laws and definitions only:\n- Newton's second law: $m \\, \\ddot{q} = F(q)$ with $F(q) = - \\nabla U(q)$.\n- Kinematics: $\\dot{q} = v$, $\\dot{v} = a(q)$ with $a(q) = F(q)/m$.\n- Kinetic and potential energy definitions appropriate to each system.\n- Standard, widely used numerical schemes (velocity Verlet and classical fourth-order Runge–Kutta) applied to the first-order system in $(q,v)$.\n\nImplement both integrators for two closed systems in reduced units:\n\nSystem A (one-dimensional harmonic oscillator):\n- Mass $m = 1$.\n- Spring constant $k = 1$.\n- Force $F(x) = -k x$.\n- Energy $E = \\tfrac{1}{2} m v^2 + \\tfrac{1}{2} k x^2$.\n\nSystem B (two-particle Lennard–Jones dimer in three dimensions):\n- Two identical particles with mass $m = 1$.\n- Lennard–Jones parameters $\\varepsilon = 1$, $\\sigma = 1$. The pair potential for interparticle distance $r$ is $U(r) = 4 \\varepsilon \\left[ (\\sigma/r)^{12} - (\\sigma/r)^6 \\right]$.\n- Forces are central and equal in magnitude and opposite in direction on the two particles.\n- Energy $E = \\sum_{i=1}^{2} \\tfrac{1}{2} m \\|v_i\\|^2 + U(\\|r_1 - r_2\\|)$.\n\nDiagnostics to compute for each test case:\n- Fit $\\Delta E(t)$ to a straight line $\\Delta E(t) \\approx s \\, t + b$ by least squares over the full trajectory including $t = 0$, and report the fitted slope $s$.\n- Report $R = \\sqrt{\\tfrac{1}{M} \\sum_{j=1}^{M} [\\Delta E(t_j) - (s \\, t_j + b)]^2}$ where $M$ is the number of sampled time points.\n- For time reversibility, start at $(q_0,v_0)$, integrate forward $N$ steps to $(q_N, v_N)$, set $(q^*, v^*) = (q_N, -v_N)$, integrate forward another $N$ steps to $(\\tilde{q}, \\tilde{v})$, and report $J = \\sqrt{\\| \\tilde{q} - q_0 \\|^2 + \\| \\tilde{v} - v_0 \\|^2}$.\n\nUse the following test suite. All quantities are specified in reduced units, and all outputs must be reported as decimal floats in reduced energy units per unit time for $s$, in reduced energy units for $R$, and in reduced units for $J$.\n\nTest case $1$ (System A, velocity Verlet):\n- Initial condition: $x(0) = 1$, $v(0) = 0$.\n- Time step: $\\Delta t = 0.1$.\n- Number of steps: $N = 20000$.\n\nTest case $2$ (System A, classical fourth-order Runge–Kutta):\n- Initial condition: $x(0) = 1$, $v(0) = 0$.\n- Time step: $\\Delta t = 0.1$.\n- Number of steps: $N = 20000$.\n\nTest case $3$ (System B, velocity Verlet):\n- Initial positions: $r_1(0) = (-0.65, 0, 0)$, $r_2(0) = (0.65, 0, 0)$ so that the initial separation is $r(0) = 1.3$.\n- Initial velocities: $v_1(0) = (0, 0, 0)$, $v_2(0) = (0, 0, 0)$.\n- Time step: $\\Delta t = 0.002$.\n- Number of steps: $N = 20000$.\n\nTest case $4$ (System A, velocity Verlet, near stability boundary):\n- Initial condition: $x(0) = 1$, $v(0) = 0$.\n- Time step: $\\Delta t = 1.9$.\n- Number of steps: $N = 5000$.\n\nNumerical requirements:\n- Implement both the velocity Verlet and the classical fourth-order Runge–Kutta integrators applied to the first-order system in $(q,v)$.\n- Use double-precision arithmetic.\n- Sample and use the energy at every integer multiple of $\\Delta t$ from $t = 0$ to $t = N \\Delta t$, inclusive, for the regression.\n- The least-squares fit must include an intercept $b$.\n- The time-reversibility test uses the same $\\Delta t$ and $N$ as the energy audit for each case.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to a test case and is itself a three-element list $[s,R,J]$ in that order. For example, produce a line of the form $[[s_1,R_1,J_1],[s_2,R_2,J_2],[s_3,R_3,J_3],[s_4,R_4,J_4]]$ with no embedded spaces.", "solution": "The problem posed requires a numerical investigation into the properties of two common integration algorithms used in molecular dynamics: the velocity Verlet method and the classical fourth-order Runge-Kutta (RK4) method. The investigation will be conducted on two representative physical systems: a one-dimensional harmonic oscillator and a three-dimensional two-particle Lennard-Jones system. The core of the task is to quantify three critical performance metrics for these integrators: the long-term energy drift rate ($s$), the amplitude of energy fluctuations ($R$), and the time-reversibility error ($J$). This analysis highlights the fundamental differences between symplectic, time-reversible integrators and general-purpose, non-symplectic ones in the context of long-term simulations of conservative systems.\n\n**Numerical Integration Algorithms**\n\nThe dynamics of the systems are governed by Newton's second law, which can be expressed as a system of first-order ordinary differential equations (ODEs):\n$$\n\\frac{d\\mathbf{q}}{dt} = \\mathbf{v}\n$$\n$$\n\\frac{d\\mathbf{v}}{dt} = \\mathbf{a}(\\mathbf{q}) = \\frac{\\mathbf{F}(\\mathbf{q})}{m}\n$$\nwhere $\\mathbf{q}$, $\\mathbf{v}$, and $\\mathbf{a}$ are the generalized positions, velocities, and accelerations, respectively, and $m$ is the mass.\n\n**Velocity Verlet Integrator**\nThe velocity Verlet algorithm is a geometric integrator, specifically designed for Hamiltonian systems. It advances the state from time $t$ to $t+\\Delta t$ through the following sequence:\n$1$. Update velocity to a half-step:\n$$\n\\mathbf{v}(t + \\tfrac{1}{2}\\Delta t) = \\mathbf{v}(t) + \\tfrac{1}{2}\\mathbf{a}(t)\\Delta t\n$$\n$2$. Update position to the full step:\n$$\n\\mathbf{q}(t + \\Delta t) = \\mathbf{q}(t) + \\mathbf{v}(t + \\tfrac{1}{2}\\Delta t)\\Delta t\n$$\n$3$. Compute the new acceleration $\\mathbf{a}(t+\\Delta t)$ from the force at the new position $\\mathbf{q}(t+\\Delta t)$.\n$4$. Complete the velocity update to the full step:\n$$\n\\mathbf{v}(t + \\Delta t) = \\mathbf{v}(t + \\tfrac{1}{2}\\Delta t) + \\tfrac{1}{2}\\mathbf{a}(t + \\Delta t)\\Delta t\n$$\nThe key properties of the velocity Verlet method are that it is both symplectic and time-reversible. Symplecticity ensures that the integrator exactly preserves a \"shadow\" Hamiltonian, a conserved quantity that is a close approximation to the true Hamiltonian of the system. This leads to bounded oscillations of the measured energy $E(t)$ around its initial value and precludes systematic, long-term energy drift. Time-reversibility ensures that integrating backward in time perfectly undoes a forward integration step, a property crucial for long-term stability.\n\n**Classical Fourth-Order Runge-Kutta (RK4) Integrator**\nThe RK4 method is a widely used, high-accuracy, general-purpose ODE solver. For a first-order system $\\dot{\\mathbf{y}} = f(\\mathbf{y})$, where the state vector is $\\mathbf{y} = (\\mathbf{q}, \\mathbf{v})$ and the time-independent derivative is $f(\\mathbf{y}) = (\\mathbf{v}, \\mathbf{a}(\\mathbf{q}))$, a single step from $\\mathbf{y}_n$ to $\\mathbf{y}_{n+1}$ is given by:\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{\\Delta t}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\nThe intermediate stage vectors $\\mathbf{k}_i$ are calculated as:\n$$\n\\begin{aligned}\n\\mathbf{k}_1 = f(\\mathbf{y}_n) \\\\\n\\mathbf{k}_2 = f(\\mathbf{y}_n + \\tfrac{1}{2}\\Delta t \\mathbf{k}_1) \\\\\n\\mathbf{k}_3 = f(\\mathbf{y}_n + \\tfrac{1}{2}\\Delta t \\mathbf{k}_2) \\\\\n\\mathbf{k}_4 = f(\\mathbf{y}_n + \\Delta t \\mathbf{k}_3)\n\\end{aligned}\n$$\nWhile RK4 has a high local accuracy (step error of order $O(\\Delta t^5)$), it is not a symplectic algorithm. As a result, it does not conserve a shadow Hamiltonian and, for Hamiltonian systems, typically introduces a secular (systematic) drift in the total energy over long simulation times. It is also not time-reversible, which is another contributor to its poor long-term stability in this context.\n\n**Physical Systems**\n\n**System A: 1D Harmonic Oscillator**\nThis is a fundamental linear system with mass $m=1$ and spring constant $k=1$.\n- Potential energy: $U(x) = \\tfrac{1}{2} k x^2 = \\tfrac{1}{2} x^2$\n- Force: $F(x) = -\\frac{dU}{dx} = -k x = -x$\n- Acceleration: $a(x) = F(x)/m = -x$\n- Total energy: $E = T + U = \\tfrac{1}{2} m v^2 + \\tfrac{1}{2} k x^2 = \\tfrac{1}{2} v^2 + \\tfrac{1}{2} x^2$\n\n**System B: 3D Lennard-Jones Dimer**\nThis system consists of two identical particles of mass $m=1$ interacting via the Lennard-Jones potential with parameters $\\varepsilon=1$ and $\\sigma=1$. Let $\\mathbf{r}_1, \\mathbf{r}_2$ be the position vectors and $\\mathbf{v}_1, \\mathbf{v}_2$ be the velocity vectors. The inter-particle separation vector is $\\mathbf{r}_{12} = \\mathbf{r}_1 - \\mathbf{r}_2$ and its magnitude is $r = \\|\\mathbf{r}_{12}\\|_2$.\n- Potential energy: $U(r) = 4\\varepsilon [(\\frac{\\sigma}{r})^{12} - (\\frac{\\sigma}{r})^6] = 4(r^{-12} - r^{-6})$\n- The force on particle $1$ is $\\mathbf{F}_1 = -\\nabla_{\\mathbf{r}_1} U(r) = -\\frac{dU}{dr} \\frac{\\mathbf{r}_{12}}{r}$. The derivative of the potential is $\\frac{dU}{dr} = 24\\varepsilon(\\sigma^6 r^{-7} - 2\\sigma^{12} r^{-13})$. With the given parameters, this becomes:\n$$\n\\mathbf{F}_1 = -24(r^{-7} - 2r^{-13}) \\frac{\\mathbf{r}_{12}}{r} = 24(2r^{-14} - r^{-8})\\mathbf{r}_{12}\n$$\n- By Newton's third law, the force on particle $2$ is $\\mathbf{F}_2 = -\\mathbf{F}_1$.\n- Accelerations are $\\mathbf{a}_1 = \\mathbf{F}_1/m = \\mathbf{F}_1$ and $\\mathbf{a}_2 = \\mathbf{F}_2/m = \\mathbf{F}_2$.\n- Total energy: $E = \\sum_{i=1}^2 \\tfrac{1}{2}m_i \\|\\mathbf{v}_i\\|^2 + U(r) = \\tfrac{1}{2}(\\|\\mathbf{v}_1\\|^2 + \\|\\mathbf{v}_2\\|^2) + 4(r^{-12} - r^{-6})$.\n\n**Diagnostic Metrics**\n\nFor each of the $4$ test cases, three diagnostics are computed to assess the performance of the integrator.\n1.  **Energy Drift Rate ($s$) and Fluctuation Amplitude ($R$)**: The change in total energy from its initial value, $\\Delta E(t_j) = E(t_j) - E(0)$, is calculated at each time step $t_j = j \\Delta t$ for $j \\in [0, N]$. A linear model $\\Delta E(t) \\approx s t + b$ is fitted to this data via least squares. The resulting slope $s$ is the energy drift rate. The root-mean-square of the residuals of this fit, $R = \\sqrt{\\frac{1}{M} \\sum_{j=0}^{N} [\\Delta E(t_j) - (s t_j + b)]^2}$ (where $M=N+1$), quantifies the amplitude of energy fluctuations around the fitted drift line.\n2.  **Time-Reversibility Error ($J$)**: This metric quantifies the deviation from perfect time-reversibility. First, a simulation is run forward for $N$ steps, from an initial state $(\\mathbf{q}_0, \\mathbf{v}_0)$ to a final state $(\\mathbf{q}_N, \\mathbf{v}_N)$. The velocities are then inverted, $(\\mathbf{q}_N, -\\mathbf{v}_N)$, and the simulation is run forward again for another $N$ steps to reach a state $(\\tilde{\\mathbf{q}}, \\tilde{\\mathbf{v}})$. The error is the Euclidean distance in phase space between the final and initial states:\n    $$\n    J = \\sqrt{\\| \\tilde{\\mathbf{q}} - \\mathbf{q}_0 \\|^2 + \\| \\tilde{\\mathbf{v}} - \\mathbf{v}_0 \\|^2}\n    $$\n    For a perfectly time-reversible integrator and exact arithmetic, $J$ would be zero.\n\n**Implementation Strategy**\nThe solution is implemented in Python using the `numpy` library for efficient vectorized computations. A main `solve` function orchestrates the $4$ test cases. For each case, a simulation is executed by repeatedly calling the appropriate integration step function (`step_verlet` or `step_rk4`). These stepper functions are designed to be general, taking the current state and an acceleration function as input. System-specific functions (`acc_ho`, `energy_ho`, `acc_lj`, `energy_lj`) provide the physics. After generating the energy trajectory, a linear regression is performed using `numpy.polyfit` to determine $s$ and $b$, from which $R$ is calculated. A separate simulation is run for the time-reversibility test to compute $J$. All calculations are performed in double-precision arithmetic. The results are collected and formatted into the specified string output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy is not needed, numpy is sufficient as allowed.\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n\n    # --- System A: 1D Harmonic Oscillator ---\n    def acc_ho(q, m=1.0, k=1.0):\n        \"\"\"Acceleration for 1D harmonic oscillator.\"\"\"\n        return -k * q / m\n\n    def energy_ho(q, v, m=1.0, k=1.0):\n        \"\"\"Total energy for 1D harmonic oscillator.\"\"\"\n        return 0.5 * m * v**2 + 0.5 * k * q**2\n\n    # --- System B: 3D Lennard-Jones Dimer ---\n    def acc_lj(q, m=1.0, epsilon=1.0, sigma=1.0):\n        \"\"\"Acceleration for 3D LJ dimer.\"\"\"\n        r1, r2 = q.reshape(2, 3)\n        r12 = r1 - r2\n        dist_sq = np.sum(r12**2)\n        \n        # Protective check for particle overlap\n        if dist_sq == 0:\n            return np.zeros_like(q)\n\n        inv_dist_sq = 1.0 / dist_sq\n        inv_dist_6 = inv_dist_sq**3\n        \n        # Force calculation based on dU/dr\n        # F1 = 24 * epsilon * (2 * sigma^12 * r^-14 - sigma^6 * r^-8) * r12\n        force_mag_term = 24.0 * epsilon * (2.0 * (sigma**12) * inv_dist_6**2 * inv_dist_sq - (sigma**6) * inv_dist_6 * inv_dist_sq)\n        f1 = force_mag_term * r12\n        f2 = -f1\n        \n        # Since mass is 1 for both particles\n        a1 = f1 / m\n        a2 = f2 / m\n        \n        return np.array([a1, a2]).flatten()\n\n    def energy_lj(q, v, m=1.0, epsilon=1.0, sigma=1.0):\n        \"\"\"Total energy for 3D LJ dimer.\"\"\"\n        r1, r2 = q.reshape(2, 3)\n        v1, v2 = v.reshape(2, 3)\n        \n        ke = 0.5 * m * (np.sum(v1**2) + np.sum(v2**2))\n        \n        r12 = r1 - r2\n        dist_sq = np.sum(r12**2)\n        \n        # Protective check\n        if dist_sq == 0:\n            pe = np.inf\n        else:\n            inv_dist_sq = 1.0 / dist_sq\n            inv_dist_6 = inv_dist_sq**3\n            pe = 4.0 * epsilon * (inv_dist_6**2 - inv_dist_6)\n\n        return ke + pe\n\n    # --- Numerical Integrators ---\n    def step_verlet(q, v, dt, acc_func):\n        \"\"\"A single step of the velocity Verlet integrator.\"\"\"\n        a = acc_func(q)\n        v_half = v + 0.5 * dt * a\n        q_next = q + dt * v_half\n        a_next = acc_func(q_next)\n        v_next = v_half + 0.5 * dt * a_next\n        return q_next, v_next\n\n    def step_rk4(q, v, dt, acc_func):\n        \"\"\"A single step of the classical 4th-order Runge-Kutta integrator.\"\"\"\n        # k1\n        k1_q = v\n        k1_v = acc_func(q)\n        # k2\n        k2_q = v + 0.5 * dt * k1_v\n        k2_v = acc_func(q + 0.5 * dt * k1_q)\n        # k3\n        k3_q = v + 0.5 * dt * k2_v\n        k3_v = acc_func(q + 0.5 * dt * k2_q)\n        # k4\n        k4_q = v + dt * k3_v\n        k4_v = acc_func(q + dt * k3_q)\n        # update\n        q_next = q + (dt / 6.0) * (k1_q + 2.0 * k2_q + 2.0 * k3_q + k4_q)\n        v_next = v + (dt / 6.0) * (k1_v + 2.0 * k2_v + 2.0 * k3_v + k4_v)\n        return q_next, v_next\n\n    # --- Simulation and Diagnostics ---\n    def run_simulation(q0, v0, dt, N, step_func, acc_func, energy_func):\n        \"\"\"Runs a simulation and returns diagnostic metrics.\"\"\"\n        q, v = np.copy(q0), np.copy(v0)\n        \n        # Energy audit\n        energies = np.zeros(N + 1, dtype=np.float64)\n        energies[0] = energy_func(q, v)\n        \n        for i in range(1, N + 1):\n            q, v = step_func(q, v, dt, acc_func)\n            energies[i] = energy_func(q, v)\n\n        times = np.arange(N + 1) * dt\n        e0 = energies[0]\n        delta_e = energies - e0\n        \n        # Calculate s and R\n        s, b = np.polyfit(times, delta_e, 1)\n        residuals = delta_e - (s * times + b)\n        R = np.sqrt(np.mean(residuals**2))\n\n        # Time-reversibility test\n        q, v = np.copy(q0), np.copy(v0)\n        for _ in range(N):\n            q, v = step_func(q, v, dt, acc_func)\n        \n        # Reverse and integrate back\n        v = -v\n        for _ in range(N):\n            q, v = step_func(q, v, dt, acc_func)\n        \n        q_tilde, v_tilde = q, v\n        \n        # Calculate J\n        q_error = np.linalg.norm(q_tilde - q0)\n        v_error = np.linalg.norm(v_tilde - v0)\n        J = np.sqrt(q_error**2 + v_error**2)\n        \n        return s, R, J\n\n    test_cases = [\n        # Case 1: System A, Verlet\n        dict(q0=np.array([1.0]), v0=np.array([0.0]), dt=0.1, N=20000, \n             step_func=step_verlet, acc_func=acc_ho, energy_func=energy_ho),\n        # Case 2: System A, RK4\n        dict(q0=np.array([1.0]), v0=np.array([0.0]), dt=0.1, N=20000, \n             step_func=step_rk4, acc_func=acc_ho, energy_func=energy_ho),\n        # Case 3: System B, Verlet\n        dict(q0=np.array([-0.65, 0, 0, 0.65, 0, 0]), \n             v0=np.array([0, 0, 0, 0, 0, 0]), \n             dt=0.002, N=20000, \n             step_func=step_verlet, acc_func=acc_lj, energy_func=energy_lj),\n        # Case 4: System A, Verlet, near stability boundary\n        dict(q0=np.array([1.0]), v0=np.array([0.0]), dt=1.9, N=5000, \n             step_func=step_verlet, acc_func=acc_ho, energy_func=energy_ho),\n    ]\n\n    results = []\n    for case in test_cases:\n        s, R, J = run_simulation(case['q0'], case['v0'], case['dt'], case['N'], \n                                   case['step_func'], case['acc_func'], case['energy_func'])\n        results.append([s, R, J])\n        \n    def format_list(lst):\n        return '[' + ','.join(f'{x:.8e}' for x in lst) + ']'\n    \n    # Custom formatting to remove spaces\n    result_str = '[' + ','.join(map(format_list, results)) + ']'\n    print(result_str)\n\nsolve()\n```", "id": "3409941"}, {"introduction": "After observing that different integrators exhibit varying levels of energy drift, the next logical step is to quantify how this error depends on the chosen time step, $\\Delta t$. The theoretical order of an integrator, $p$, dictates that its global error scales as $\\mathcal{O}(\\Delta t^p)$. This practice guides you through empirically measuring this scaling exponent for both the second-order velocity Verlet and the fourth-order Runge-Kutta methods. By performing a log-log analysis of an energy deviation metric versus the time step, you will concretely verify the theoretical order of accuracy and develop an intuition for the trade-offs between computational cost and precision [@problem_id:3409975].", "problem": "Consider a deterministic microcanonical Molecular Dynamics (MD) simulation of a small system evolving under Newton’s second law, where the equations of motion for positions $x_i(t)$ and velocities $v_i(t)$ of $N$ identical particles of mass $m$ are given by $m\\,\\dfrac{d^2 x_i}{dt^2} = F_i(x)$ with $F_i(x) = -\\nabla_{x_i} V(x)$. Assume the total energy $E(x,v) = K(v) + V(x)$, where the kinetic energy is $K(v) = \\dfrac{1}{2} \\sum_{i=1}^{N} m\\, v_i^2$, and the potential energy $V(x)$ is conservative and time-independent. The system is integrated numerically using explicit time-stepping with time step $\\Delta t$. The numerical integrator has method order $p$, meaning that the global error of state variables after a fixed total time scales as $\\mathcal{O}(\\Delta t^p)$.\n\nYou will test long-term energy conservation and drift scaling in two boundary-condition settings: a periodic cell and fixed soft walls. The goal is to quantify how an energy drift metric scales with $\\Delta t^p$, and to estimate the scaling exponent $p$ empirically via a log-log fit.\n\nFundamental base for the setup:\n- Newton’s second law for particle $i$: $m\\,\\dfrac{d^2 x_i}{dt^2} = F_i(x)$.\n- Velocity is defined by $v_i = \\dfrac{dx_i}{dt}$.\n- Total energy $E(t) = K(t) + V(t)$ must be conserved for the exact dynamics because the potential is time-independent and the system is isolated (microcanonical ensemble).\n\nSystem specification:\n- Use $N = 2$ particles in one spatial dimension with positions $x_1$ and $x_2$ and velocities $v_1$ and $v_2$.\n- Reduced Lennard-Jones units are used: length in units of $\\sigma$, energy in units of $\\varepsilon$, and time in units of $\\sigma \\sqrt{m/\\varepsilon}$.\n- Pairwise interaction is through a shifted-force Lennard-Jones potential truncated at cutoff $r_c$ to ensure force continuity at $r_c$. Define the unshifted Lennard-Jones potential\n$$\nV_{\\mathrm{LJ}}(r) = 4\\varepsilon\\left[\\left(\\dfrac{\\sigma}{r}\\right)^{12} - \\left(\\dfrac{\\sigma}{r}\\right)^6\\right],\n$$\nwith the corresponding force magnitude (acting along the interparticle separation direction)\n$$\nf_{\\mathrm{LJ}}(r) = 24\\varepsilon\\left[\\dfrac{2\\sigma^{12}}{r^{13}} - \\dfrac{\\sigma^6}{r^7}\\right] = 24\\varepsilon\\left[\\dfrac{2\\left(\\dfrac{\\sigma}{r}\\right)^{12} - \\left(\\dfrac{\\sigma}{r}\\right)^6}{r}\\right].\n$$\nLet $r_c$ be the cutoff, and denote $V_c = V_{\\mathrm{LJ}}(r_c)$ and $f_c = f_{\\mathrm{LJ}}(r_c)$. The shifted-force potential and force for $r  r_c$ are\n$$\nV_{\\mathrm{SF}}(r) = V_{\\mathrm{LJ}}(r) - V_c - (r - r_c)\\, \\left.\\dfrac{d V_{\\mathrm{LJ}}}{dr}\\right|_{r_c},\n$$\n$$\nf_{\\mathrm{SF}}(r) = f_{\\mathrm{LJ}}(r) - f_c,\n$$\nand for $r \\ge r_c$ both are zero. In one dimension, the force on particle $i$ due to $j$ is $F_{i \\leftarrow j} = f_{\\mathrm{SF}}(|r|)\\,\\mathrm{sign}(x_i - x_j)$ with $r = x_i - x_j$.\n\nBoundary conditions:\n- Periodic cell of length $L$: compute interparticle distance using the minimum image convention. For any separation $r = x_2 - x_1$, define $r_{\\mathrm{MIC}} = r - L\\,\\mathrm{round}(r/L)$ and use $|r_{\\mathrm{MIC}}|$ in $V_{\\mathrm{SF}}$ and $f_{\\mathrm{SF}}$. Positions should be wrapped back into the primary cell $[0,L)$ after each step to avoid unbounded coordinates; this wrapping does not affect forces under the minimum image convention.\n- Fixed soft walls at $x=0$ and $x=L$: in addition to the pair interaction, include a smooth repulsive wall potential for each particle,\n$$\nV_{\\mathrm{wall}}(x) = \\varepsilon_w \\left[\\left(\\dfrac{\\sigma_w}{x}\\right)^{12} + \\left(\\dfrac{\\sigma_w}{L - x}\\right)^{12}\\right],\n$$\nwith the corresponding wall force\n$$\nF_{\\mathrm{wall}}(x) = -\\dfrac{d V_{\\mathrm{wall}}}{dx} = 12 \\varepsilon_w \\sigma_w^{12}\\left[\\dfrac{1}{x^{13}} - \\dfrac{1}{(L - x)^{13}}\\right].\n$$\n\nNumerical integrators to compare:\n- Velocity Verlet (a second-order symplectic method): update positions and velocities using the standard staggered half-step velocity algorithm. Method order $p = 2$.\n- Classical fourth-order Runge–Kutta method: apply the standard Butcher tableau to the state $\\left[x, v\\right]$ with $x' = v$ and $v' = a(x) = F(x)/m$. Method order $p = 4$.\n\nEnergy drift metric:\n- For a given $\\Delta t$ and total simulation time $T$, record the energy time series $E(t_n)$ at steps $t_n = n\\,\\Delta t$ for $n = 0, 1, \\dots, N_t$ with $N_t = T/\\Delta t$.\n- Define the energy deviation $\\delta E(t_n) = E(t_n) - E(0)$.\n- Define the root-mean-square energy deviation\n$$\nD(\\Delta t) = \\sqrt{\\dfrac{1}{N_t + 1}\\sum_{n=0}^{N_t}\\left[\\delta E(t_n)\\right]^2}.\n$$\nEmpirically estimate the scaling exponent $p$ by performing a least-squares fit of $\\log D(\\Delta t)$ versus $\\log \\Delta t$ over a set of $\\Delta t$ values, and take the slope as the estimate $\\hat{p}$.\n\nInitial conditions and parameters (in reduced units) common to all tests unless explicitly varied:\n- Number of particles: $N = 2$.\n- Mass: $m = 1$ for each particle.\n- Lennard-Jones parameters: $\\varepsilon = 1$, $\\sigma = 1$, cutoff $r_c = 2.5$.\n- Cell length: $L = 5$.\n- Wall parameters (only for fixed-wall cases): $\\varepsilon_w = 0.5$, $\\sigma_w = 0.5$.\n- Total simulation time: $T = 10$.\n- Initial positions: $x_1(0) = 1.25$, $x_2(0) = 3.60$.\n- Initial velocities: $v_1(0) = 0.15$, $v_2(0) = -0.10$.\n\nTest suite:\n- Case $1$: periodic boundaries, velocity Verlet integrator, $\\Delta t$ values $\\{0.01, 0.005, 0.0025\\}$.\n- Case $2$: periodic boundaries, fourth-order Runge–Kutta integrator, $\\Delta t$ values $\\{0.012, 0.006, 0.003\\}$.\n- Case $3$: fixed soft walls, velocity Verlet integrator, $\\Delta t$ values $\\{0.008, 0.004, 0.002\\}$.\n- Case $4$: fixed soft walls, fourth-order Runge–Kutta integrator, $\\Delta t$ values $\\{0.01, 0.005, 0.0025\\}$.\n\nRequired outputs:\n- For each case, compute the estimated scaling exponent $\\hat{p}$ as a float. No physical units are required because $\\hat{p}$ is dimensionless.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $\\left[\\hat{p}_1, \\hat{p}_2, \\hat{p}_3, \\hat{p}_4\\right]$, with each float formatted to three decimal places (for example, $\\left[2.003,3.998,2.012,3.955\\right]$).\n\nAll quantities in the simulation are expressed in reduced Lennard-Jones units; angles are not involved; no percentages are used. The program must be self-contained and require no user input.", "solution": "The problem statement has been validated and is deemed sound. It is scientifically grounded, well-posed, and objective. All necessary parameters and definitions for a deterministic simulation are provided, and there are no internal contradictions or ambiguities. The task is to implement a molecular dynamics simulation to study energy conservation properties of two standard numerical integrators.\n\nThe objective is to empirically determine the scaling exponent $\\hat{p}$ of an energy drift metric $D(\\Delta t)$ with respect to the integration time step $\\Delta t$. This metric is expected to scale as $D(\\Delta t) \\propto (\\Delta t)^p$, where $p$ is the order of the numerical integration method. The exponent $\\hat{p}$ is estimated as the slope of a linear fit to $\\log D(\\Delta t)$ versus $\\log \\Delta t$.\n\nThe simulation involves a system of $N=2$ particles of mass $m=1$ in one dimension, interacting via a shifted-force Lennard-Jones potential. Two scenarios for boundary conditions are considered: periodic boundary conditions (PBC) in a cell of length $L=5$, and fixed soft repulsive walls at positions $x=0$ and $x=L=5$. Two numerical integration schemes are tested: the second-order Velocity Verlet (VV) algorithm and the fourth-order classical Runge-Kutta (RK4) method. All quantities are in reduced Lennard-Jones units, with $\\varepsilon=1$ and $\\sigma=1$.\n\nThe core of the solution involves the following steps:\n1.  Define the physical model, including the potential energy functions and the corresponding forces.\n2.  Implement the numerical integrators to evolve the system's state (positions and velocities) over time.\n3.  Execute simulations for each of the four specified test cases, varying the time step $\\Delta t$.\n4.  For each simulation, calculate the total energy time series and the root-mean-square energy deviation metric $D(\\Delta t)$.\n5.  For each test case, perform a linear regression on the logarithmic data $(\\log \\Delta t, \\log D(\\Delta t))$ to find the scaling exponent $\\hat{p}$.\n\n**1. Potential and Force Calculation**\n\nThe total force on each particle is the negative gradient of the total potential energy. The potential energy function changes depending on the boundary conditions.\n\nThe pairwise interaction is governed by the shifted-force Lennard-Jones potential, which is zero for inter-particle distances $r \\ge r_c$. For $r  r_c = 2.5$, the potential is:\n$$\nV_{\\mathrm{SF}}(r) = V_{\\mathrm{LJ}}(r) - V_{\\mathrm{LJ}}(r_c) - (r - r_c) \\left.\\frac{dV_{\\mathrm{LJ}}}{dr}\\right|_{r=r_c}\n$$\nThe corresponding force magnitude is:\n$$\nf_{\\mathrm{SF}}(r) = -\\frac{dV_{\\mathrm{SF}}}{dr} = f_{\\mathrm{LJ}}(r) - f_{\\mathrm{LJ}}(r_c)\n$$\nwhere $V_{\\mathrm{LJ}}(r) = 4\\varepsilon[(\\sigma/r)^{12} - (\\sigma/r)^6]$ and $f_{\\mathrm{LJ}}(r) = -\\frac{dV_{\\mathrm{LJ}}}{dr} = 24\\varepsilon/r[2(\\sigma/r)^{12} - (\\sigma/r)^6]$. With $\\varepsilon=1$ and $\\sigma=1$, these simplify to $V_{\\mathrm{LJ}}(r) = 4(r^{-12} - r^{-6})$ and $f_{\\mathrm{LJ}}(r) = 24(2r^{-13} - r^{-7})$.\n\n**a) Periodic Boundary Conditions (PBC):**\nThe total potential energy is $V(x_1, x_2) = V_{\\mathrm{SF}}(|r_{\\mathrm{MIC}}|)$, where $r_{\\mathrm{MIC}} = (x_2-x_1) - L\\,\\mathrm{round}((x_2-x_1)/L)$ is the separation under the minimum image convention. The forces on the particles are equal and opposite: $F_1 = -F_2$, where $F_2 = f_{\\mathrm{SF}}(|r_{\\mathrm{MIC}}|) \\mathrm{sign}(r_{\\mathrm{MIC}})$. The total energy is $E = \\frac{1}{2}m(v_1^2 + v_2^2) + V_{\\mathrm{SF}}(|r_{\\mathrm{MIC}}|)$.\n\n**b) Fixed Soft Walls:**\nThe particles are confined between walls at $x=0$ and $x=L$. The total potential energy includes the pair interaction and the wall interactions for each particle:\n$$\nV(x_1, x_2) = V_{\\mathrm{SF}}(|x_2-x_1|) + V_{\\mathrm{wall}}(x_1) + V_{\\mathrm{wall}}(x_2)\n$$\nThe wall potential for a particle at position $x$ is $V_{\\mathrm{wall}}(x) = \\varepsilon_w [(\\sigma_w/x)^{12} + (\\sigma_w/(L - x))^{12}]$. The force on particle $i$ is $F_i = F_{i \\leftarrow j} + F_{\\mathrm{wall}}(x_i)$, where $F_{i \\leftarrow j}$ is the pairwise force and $F_{\\mathrm{wall}}(x) = -\\frac{dV_{\\mathrm{wall}}}{dx}$. The total energy is $E = \\frac{1}{2}m(v_1^2 + v_2^2) + V(x_1, x_2)$.\n\n**2. Numerical Integration**\n\nLet the state of the system be described by the position vector $x = (x_1, x_2)$ and velocity vector $v = (v_1, v_2)$. The acceleration is $a(x) = F(x)/m$.\n\n**a) Velocity Verlet (VV):**\nThis is a second-order ($p=2$), symplectic integrator. One step from time $t$ to $t+\\Delta t$ is computed as:\n1.  Calculate half-step velocity: $v(t + \\frac{1}{2}\\Delta t) = v(t) + \\frac{1}{2} a(x(t)) \\Delta t$.\n2.  Update positions: $x(t + \\Delta t) = x(t) + v(t + \\frac{1}{2}\\Delta t) \\Delta t$.\n3.  Apply position wrapping for PBC: $x(t + \\Delta t) \\leftarrow x(t + \\Delta t) \\pmod L$.\n4.  Calculate new accelerations $a(x(t + \\Delta t))$ using the new positions.\n5.  Update full-step velocity: $v(t + \\Delta t) = v(t + \\frac{1}{2}\\Delta t) + \\frac{1}{2} a(x(t + \\Delta t)) \\Delta t$.\nFor symplectic integrators, the numerical energy does not exhibit a systematic drift over long times for Hamiltonian systems; instead, it oscillates around the initial value. The amplitude of these oscillations is expected to scale as $\\mathcal{O}(\\Delta t^2)$.\n\n**b) Fourth-Order Runge-Kutta (RK4):**\nThis is a general-purpose, fourth-order ($p=4$) integrator. Let the system state be a single vector $Y = [x_1, x_2, v_1, v_2]$. The time derivative is $\\frac{dY}{dt} = f(t, Y) = [v_1, v_2, a_1(x), a_2(x)]$. One step is:\n1.  $k_1 = \\Delta t \\cdot f(t_n, Y_n)$\n2.  $k_2 = \\Delta t \\cdot f(t_n + \\frac{\\Delta t}{2}, Y_n + \\frac{k_1}{2})$\n3.  $k_3 = \\Delta t \\cdot f(t_n + \\frac{\\Delta t}{2}, Y_n + \\frac{k_2}{2})$\n4.  $k_4 = \\Delta t \\cdot f(t_n + \\Delta t, Y_n + k_3)$\n5.  $Y_{n+1} = Y_n + \\frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4)$\n6.  Apply position wrapping for PBC on the position components of $Y_{n+1}$.\nRK4 is not symplectic, and for long simulations, it typically leads to a systematic drift in the total energy. The accumulated error and thus the energy deviation metric $D(\\Delta t)$ is expected to scale as $\\mathcal{O}(\\Delta t^4)$.\n\n**3. Simulation and Analysis**\nFor each case, we run simulations with a given set of $\\Delta t$ values for a total time $T=10$.\n1.  Initialize the system to $x_1(0)=1.25, x_2(0)=3.60, v_1(0)=0.15, v_2(0)=-0.10$.\n2.  Calculate the initial total energy $E(0)$.\n3.  At each time step $t_n = n \\Delta t$, from $n=0$ to $N_t = T/\\Delta t$, calculate the total energy $E(t_n)$ and the squared deviation $[\\delta E(t_n)]^2 = [E(t_n) - E(0)]^2$.\n4.  Compute the root-mean-square energy deviation $D(\\Delta t) = \\sqrt{\\frac{1}{N_t+1}\\sum_{n=0}^{N_t} [\\delta E(t_n)]^2}$.\n5.  After obtaining $D(\\Delta t)$ for all $\\Delta t$ values in a test case, we assume a power-law relationship $D(\\Delta t) \\approx C(\\Delta t)^{\\hat{p}}$. Taking the logarithm gives $\\log D(\\Delta t) \\approx \\log C + \\hat{p} \\log \\Delta t$.\n6.  The exponent $\\hat{p}$ is estimated by performing a linear least-squares fit on the collected data points $(\\log \\Delta t, \\log D(\\Delta t))$ and taking the slope. This is accomplished using `numpy.polyfit`.\n\nThe expected results are $\\hat{p} \\approx 2$ for the Velocity Verlet cases and $\\hat{p} \\approx 4$ for the RK4 cases, reflecting the order of the integrators.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the molecular dynamics energy drift scaling problem.\n    \"\"\"\n    # System and potential parameters in reduced units\n    N_PARTICLES = 2\n    MASS = 1.0\n    EPSILON = 1.0\n    SIGMA = 1.0\n    RC = 2.5\n    L = 5.0\n    EPSILON_W = 0.5\n    SIGMA_W = 0.5\n    T_TOTAL = 10.0\n\n    # Initial conditions\n    INITIAL_CONDITIONS = {\n        'pos': np.array([1.25, 3.60]),\n        'vel': np.array([0.15, -0.10]),\n    }\n\n    # Pre-calculate Lennard-Jones constants at the cutoff\n    _rc_pow6 = RC**6\n    _rc_pow12 = _rc_pow6**2\n    V_LJ_RC = 4.0 * EPSILON * ((SIGMA**12 / _rc_pow12) - (SIGMA**6 / _rc_pow6))\n    F_LJ_RC = 24.0 * EPSILON / RC * (2.0 * (SIGMA**12 / _rc_pow12) - (SIGMA**6 / _rc_pow6))\n    _sw12 = SIGMA_W**12\n\n    def get_accel_and_potential(pos, bc_type):\n        \"\"\"Calculates accelerations and potential energy for the 2-particle system.\"\"\"\n        accel = np.zeros(N_PARTICLES)\n        potential = 0.0\n        \n        # Pair interaction\n        r12 = pos[1] - pos[0]\n        dr = r12\n        if bc_type == 'periodic':\n            dr = dr - L * np.round(dr / L)\n        \n        r_abs = np.abs(dr)\n        \n        if r_abs > 0 and r_abs  RC:\n            r_inv = SIGMA / r_abs\n            r_inv6 = r_inv**6\n            r_inv12 = r_inv6**2\n            \n            v_lj = 4.0 * EPSILON * (r_inv12 - r_inv6)\n            f_lj_mag = 24.0 * EPSILON / r_abs * (2.0 * r_inv12 - r_inv6)\n            \n            # Shifted-force potential and force\n            potential_pair = v_lj - V_LJ_RC + (r_abs - RC) * F_LJ_RC\n            force_mag = f_lj_mag - F_LJ_RC\n\n            potential += potential_pair\n            force_on_2 = force_mag * np.sign(dr)\n            accel[1] += force_on_2 / MASS\n            accel[0] -= force_on_2 / MASS\n\n        # Wall interactions for 'fixed' boundary conditions\n        if bc_type == 'fixed':\n            for i in range(N_PARTICLES):\n                x = pos[i]\n                if x > 0 and x  L:\n                    term1 = (SIGMA_W / x)**12\n                    term2 = (SIGMA_W / (L - x))**12\n                    potential += EPSILON_W * (term1 + term2)\n                    \n                    force_wall = 12.0 * EPSILON_W * _sw12 * (x**-13 - (L - x)**-13)\n                    accel[i] += force_wall / MASS\n\n        return accel, potential\n\n    def step_vv(pos, vel, dt, bc_type):\n        \"\"\"A single step of the Velocity Verlet integrator.\"\"\"\n        accel, _ = get_accel_and_potential(pos, bc_type)\n        vel_half = vel + 0.5 * accel * dt\n        pos_new = pos + vel_half * dt\n        if bc_type == 'periodic':\n            pos_new = pos_new % L\n        \n        accel_new, _ = get_accel_and_potential(pos_new, bc_type)\n        vel_new = vel_half + 0.5 * accel_new * dt\n        return pos_new, vel_new\n\n    def get_state_derivative(state, bc_type):\n        \"\"\"Calculates the time derivative of the state vector [pos, vel] for RK4.\"\"\"\n        pos = state[:N_PARTICLES]\n        vel = state[N_PARTICLES:]\n        accel, _ = get_accel_and_potential(pos, bc_type)\n        return np.concatenate((vel, accel))\n\n    def step_rk4(pos, vel, dt, bc_type):\n        \"\"\"A single step of the classic 4th-order Runge-Kutta integrator.\"\"\"\n        state = np.concatenate((pos, vel))\n        \n        k1 = get_state_derivative(state, bc_type)\n        k2 = get_state_derivative(state + 0.5 * dt * k1, bc_type)\n        k3 = get_state_derivative(state + 0.5 * dt * k2, bc_type)\n        k4 = get_state_derivative(state + dt * k3, bc_type)\n        \n        state_new = state + dt / 6.0 * (k1 + 2*k2 + 2*k3 + k4)\n        \n        pos_new = state_new[:N_PARTICLES]\n        vel_new = state_new[N_PARTICLES:]\n        \n        if bc_type == 'periodic':\n            pos_new = pos_new % L\n            \n        return pos_new, vel_new\n\n    def run_simulation(integrator_func, bc_type, dt, ic):\n        \"\"\"Runs a simulation and returns the RMS energy deviation.\"\"\"\n        pos, vel = ic['pos'].copy(), ic['vel'].copy()\n        \n        num_steps = int(round(T_TOTAL / dt))\n        \n        _, v0 = get_accel_and_potential(pos, bc_type)\n        k0 = 0.5 * MASS * np.sum(vel**2)\n        e0 = k0 + v0\n        \n        energy_devs_sq = [0.0]\n        \n        for _ in range(num_steps):\n            pos, vel = integrator_func(pos, vel, dt, bc_type)\n            _, v_current = get_accel_and_potential(pos, bc_type)\n            k_current = 0.5 * MASS * np.sum(vel**2)\n            e_current = k_current + v_current\n            \n            delta_e = e_current - e0\n            energy_devs_sq.append(delta_e**2)\n            \n        return np.sqrt(np.mean(energy_devs_sq))\n\n    def estimate_p_hat(dts, Ds):\n        \"\"\"Estimates the scaling exponent p from log-log data.\"\"\"\n        log_dts = np.log(dts)\n        log_Ds = np.log(Ds)\n        # polyfit returns [slope, intercept] for degree 1\n        slope, _ = np.polyfit(log_dts, log_Ds, 1)\n        return slope\n        \n    test_cases = [\n        {'integrator': step_vv, 'bc_type': 'periodic', 'dts': [0.01, 0.005, 0.0025]},\n        {'integrator': step_rk4, 'bc_type': 'periodic', 'dts': [0.012, 0.006, 0.003]},\n        {'integrator': step_vv, 'bc_type': 'fixed', 'dts': [0.008, 0.004, 0.002]},\n        {'integrator': step_rk4, 'bc_type': 'fixed', 'dts': [0.01, 0.005, 0.0025]},\n    ]\n    \n    results = []\n    for case in test_cases:\n        dts = np.array(case['dts'])\n        Ds = np.array([run_simulation(case['integrator'], case['bc_type'], dt, INITIAL_CONDITIONS) for dt in dts])\n        p_hat = estimate_p_hat(dts, Ds)\n        results.append(p_hat)\n        \n    print(f\"[{','.join(f'{p:.3f}' for p in results)}]\")\n\nsolve()\n```", "id": "3409975"}, {"introduction": "The superior long-term stability of symplectic integrators is not magic; it is a direct consequence of the fact that they exactly conserve a modified Hamiltonian, often called a \"shadow Hamiltonian\" ($\\tilde{H}$). While the true energy $H$ exhibits bounded oscillations, the shadow energy $\\tilde{H}$ remains constant. This final practice provides a remarkable bridge from numerical observation to deep theory. By carefully fitting the time-averaged energy from a simulation to a polynomial in the time step, $\\Delta t$, you will empirically measure the leading-order terms of the shadow Hamiltonian and compare them to the predictions of backward error analysis, thereby \"unveiling\" the very quantity that underpins the stability of the method [@problem_id:3409974].", "problem": "Construct a complete, runnable program that investigates the identification of a shadow Hamiltonian for a symplectic molecular dynamics integrator through a polynomial fit in the time step to the measured energy time series, and compares the fitted coefficients to those predicted by theoretical backward error analysis. Use the one-dimensional harmonic oscillator as the model system, with unit mass and angular frequency $\\omega$. The fundamental starting point is Newton's second law and Hamiltonian dynamics: $\\dot{q} = \\partial H / \\partial p$, $\\dot{p} = -\\partial H / \\partial q$, with Hamiltonian $H(q,p) = \\frac{1}{2} p^2 + \\frac{1}{2} \\omega^2 q^2$. The numerical integrator is the time-reversible symplectic velocity Verlet method, applied with time step $\\Delta t$:\n- $p_{n+1/2} = p_n - \\frac{\\Delta t}{2} \\, \\omega^2 q_n$,\n- $q_{n+1} = q_n + \\Delta t \\, p_{n+1/2}$,\n- $p_{n+1} = p_{n+1/2} - \\frac{\\Delta t}{2} \\, \\omega^2 q_{n+1}$.\n\nThe aim is to empirically detect the shadow Hamiltonian $\\tilde{H}$ that the symplectic method nearly preserves by fitting the deviation of the time-averaged true energy from its initial value as a polynomial in $\\Delta t^2$, and then compare against a theoretical prediction obtained from backward error analysis.\n\nYour program must implement the following steps based on first principles:\n1. For each specified $\\Delta t$, simulate the harmonic oscillator using the velocity Verlet scheme for a prescribed number of steps $N$, from specified initial conditions $(q_0, p_0)$. At each discrete time $t_n = n \\, \\Delta t$, compute and accumulate the true energy $E_n = \\frac{1}{2} p_n^2 + \\frac{1}{2} \\omega^2 q_n^2$. Compute the time average $\\overline{E}(\\Delta t) = \\frac{1}{N} \\sum_{n=0}^{N-1} E_n$.\n2. For the set of $\\Delta t$ values in the case, form the data pairs $(u, y)$ with $u = (\\Delta t)^2$ and $y = \\overline{E}(\\Delta t) - E_0$, where $E_0 = \\frac{1}{2} p_0^2 + \\frac{1}{2} \\omega^2 q_0^2$ is the initial true energy. Fit the model $y \\approx c_2 \\, u + c_4 \\, u^2$ by least squares over the provided $u$ values to obtain empirical coefficients $c_2^{\\mathrm{emp}}$ and $c_4^{\\mathrm{emp}}$.\n3. Independently derive the theoretical prediction for the leading shadow Hamiltonian correction coefficients using backward error analysis. For the velocity Verlet method applied to the quadratic Hamiltonian of the harmonic oscillator, there exists an exact quadratic invariant (the shadow energy) $\\tilde{E}(q,p; \\Delta t) = \\frac{1}{2} p^2 + \\frac{1}{2} \\omega^2 \\left(1 - \\frac{\\omega^2 (\\Delta t)^2}{4}\\right) q^2$ that is conserved by the discrete map. Expanding $\\tilde{E} - E$ in powers of $\\Delta t$ gives $\\tilde{E} - E = -\\frac{\\omega^4 q^2}{8} (\\Delta t)^2 + \\mathcal{O}((\\Delta t)^4)$. Therefore, the theoretical coefficients for the polynomial approximation of the energy deviation are $c_2^{\\mathrm{th}} = -\\frac{\\omega^4 q_0^2}{8}$ and $c_4^{\\mathrm{th}} = 0$.\n4. Compute and report, for each test case, the absolute errors $|c_2^{\\mathrm{emp}} - c_2^{\\mathrm{th}}|$ and $|c_4^{\\mathrm{emp}} - c_4^{\\mathrm{th}}|$.\n\nAll quantities are dimensionless; do not include physical units.\n\nTest suite:\n- Case 1 (general small-step regime): $\\omega = 1.0$, $q_0 = 1.0$, $p_0 = 0.0$, $N = 20000$, $\\Delta t \\in \\{0.01, 0.02, 0.05, 0.10, 0.15, 0.20\\}$.\n- Case 2 (edge with zero initial position): $\\omega = 1.5$, $q_0 = 0.0$, $p_0 = 1.0$, $N = 20000$, $\\Delta t \\in \\{0.01, 0.02, 0.03, 0.05, 0.08, 0.10\\}$.\n- Case 3 (mixed initial conditions, broader $\\Delta t$ spread well within stability): $\\omega = 0.7$, $q_0 = 0.8$, $p_0 = -0.6$, $N = 20000$, $\\Delta t \\in \\{0.01, 0.03, 0.05, 0.08, 0.10, 0.20, 0.40, 0.60\\}$.\n- Case 4 (near the stability boundary, large steps): $\\omega = 1.0$, $q_0 = 0.5$, $p_0 = 0.2$, $N = 20000$, $\\Delta t \\in \\{0.40, 0.80, 1.20, 1.60, 1.80\\}$. The stability condition for velocity Verlet on this system is $\\omega \\, \\Delta t  2$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain, in order, for each case, the two floats $|c_2^{\\mathrm{emp}} - c_2^{\\mathrm{th}}|$ and $|c_4^{\\mathrm{emp}} - c_4^{\\mathrm{th}}|$. For example, the format must be $[e_{2,1},e_{4,1},e_{2,2},e_{4,2},e_{2,3},e_{4,3},e_{2,4},e_{4,4}]$ where $e_{2,i}$ and $e_{4,i}$ denote the absolute errors for case $i$.", "solution": "The problem requires an investigation into the concept of a shadow Hamiltonian for a symplectic numerical integrator by comparing empirically fitted coefficients against their theoretical predictions. The physical system is the one-dimensional simple harmonic oscillator, and the integrator is the velocity Verlet method.\n\nThe core principle rests on the properties of symplectic integrators in Hamiltonian mechanics. While these integrators do not perfectly conserve the true Hamiltonian (energy) $H$, they exactly conserve a nearby, modified Hamiltonian, often called a shadow Hamiltonian, $\\tilde{H}$. This property ensures long-term stability and prevents systematic energy drift, which are hallmarks of high-quality geometric integrators. For the specific case of the velocity Verlet method applied to the simple harmonic oscillator, a rare and convenient property emerges: the shadow Hamiltonian is not just a formal infinite series but a simple, exact quadratic invariant of the discrete map.\n\nThe Hamiltonian for the system is given by:\n$$\nH(q,p) = \\frac{1}{2} p^2 + \\frac{1}{2} \\omega^2 q^2\n$$\nwhere $q$ is the position, $p$ is the momentum, and $\\omega$ is the angular frequency. The mass is taken to be unity. The equations of motion are $\\dot{q} = p$ and $\\dot{p} = -\\omega^2 q$.\n\nThe velocity Verlet algorithm, a specific form of a symplectic leapfrog integrator, is applied to the Hamiltonian system. For a Hamiltonian $H = T(p) + V(q)$, the algorithm is a second-order splitting method. With $T(p) = p^2/2$ (for unit mass) and $V(q) = \\omega^2 q^2 / 2$, the force is $F(q) = -dV/dq = -\\omega^2 q$. The integration steps to advance the state $(q_n, p_n)$ to $(q_{n+1}, p_{n+1})$ over a time step $\\Delta t$ are:\n1.  Update momentum by a half step using the force at the current position:\n    $$p_{n+1/2} = p_n + \\frac{\\Delta t}{2} F(q_n) = p_n - \\frac{\\Delta t}{2} \\omega^2 q_n$$\n2.  Update position for the full time step using the half-step momentum:\n    $$q_{n+1} = q_n + \\Delta t \\, p_{n+1/2}$$\n3.  Complete the momentum update using the force at the new position:\n    $$p_{n+1} = p_{n+1/2} + \\frac{\\Delta t}{2} F(q_{n+1}) = p_{n+1/2} - \\frac{\\Delta t}{2} \\omega^2 q_{n+1}$$\nThis matches the formulation given in the problem statement.\n\nThe methodology involves the following computational steps:\n\nFirst, for each set of parameters provided in a test case, we perform a series of numerical simulations. Each simulation corresponds to a specific value of the time step $\\Delta t$ from the given set. Starting from initial conditions $(q_0, p_0)$, the system is evolved for $N$ steps using the velocity Verlet algorithm. During the simulation, the true energy $E_n = H(q_n, p_n)$ is calculated at each step $n$. After the simulation is complete, the time-averaged energy is computed:\n$$\n\\overline{E}(\\Delta t) = \\frac{1}{N} \\sum_{n=0}^{N-1} E_n\n$$\n\nSecond, we analyze the deviation of this time-averaged energy from the initial energy $E_0 = H(q_0, p_0)$. According to backward error analysis, this deviation should be an even-powered series in $\\Delta t$. We form data pairs $(u, y)$ where $u = (\\Delta t)^2$ and $y = \\overline{E}(\\Delta t) - E_0$. We then fit this data to a quadratic polynomial model:\n$$\ny(u) \\approx c_2^{\\mathrm{emp}} u + c_4^{\\mathrm{emp}} u^2\n$$\nThe coefficients $c_2^{\\mathrm{emp}}$ and $c_4^{\\mathrm{emp}}$ are determined by a linear least-squares fit. This can be expressed as a matrix problem $\\mathbf{A}\\mathbf{c} = \\mathbf{y}$, where $\\mathbf{y}$ is the vector of observed energy deviations, $\\mathbf{c} = [c_2^{\\mathrm{emp}}, c_4^{\\mathrm{emp}}]^T$ is the vector of coefficients to be found, and $\\mathbf{A}$ is the design matrix with rows $[u_i, u_i^2]$ for each $\\Delta t_i$. The solution is given by $\\mathbf{c} = (\\mathbf{A}^T\\mathbf{A})^{-1}\\mathbf{A}^T\\mathbf{y}$.\n\nThird, we compute the theoretical benchmark coefficients. The problem provides the exact quadratic invariant (the shadow energy) for this system and integrator:\n$$\n\\tilde{E}(q,p; \\Delta t) = \\frac{1}{2} p^2 + \\frac{1}{2} \\omega^2 \\left(1 - \\frac{\\omega^2 (\\Delta t)^2}{4}\\right) q^2\n$$\nThis shadow energy $\\tilde{E}$ is exactly conserved by the discrete dynamics, so $\\tilde{E}(q_n, p_n) = \\tilde{E}(q_0, p_0)$ for all $n$. The average true energy $\\overline{E}$ is expected to be close to the conserved shadow energy $\\tilde{E}(q_0, p_0)$. The deviation of this value from the initial true energy $E_0$ can be expanded in powers of $\\Delta t$.\n$$\n\\tilde{E}(q_0, p_0) - E_0 = \\left[ \\frac{1}{2} p_0^2 + \\frac{1}{2} \\omega^2 q_0^2 - \\frac{\\omega^4 q_0^2}{8} (\\Delta t)^2 \\right] - \\left[ \\frac{1}{2} p_0^2 + \\frac{1}{2} \\omega^2 q_0^2 \\right] = -\\frac{\\omega^4 q_0^2}{8} (\\Delta t)^2\n$$\nThis suggests that the deviation $\\overline{E}(\\Delta t) - E_0$ should be well-approximated by a polynomial in $u = (\\Delta t)^2$. Following the problem's prompt, we compare the empirical fit to theoretical coefficients derived from this initial deviation:\n$$\nc_2^{\\mathrm{th}} = -\\frac{\\omega^4 q_0^2}{8} \\quad \\text{and} \\quad c_4^{\\mathrm{th}} = 0\n$$\n\nFinally, for each test case, we compute the absolute errors between the empirically fitted and theoretically defined coefficients: $|c_2^{\\mathrm{emp}} - c_2^{\\mathrm{th}}|$ and $|c_4^{\\mathrm{emp}} - c_4^{\\mathrm{th}}|$. The collection of these errors for all test cases constitutes the final result.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Investigates the shadow Hamiltonian for a symplectic integrator by fitting\n    the energy time series of a harmonic oscillator and comparing with theory.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1: General small-step regime\n        {\n            \"omega\": 1.0, \"q0\": 1.0, \"p0\": 0.0, \"N\": 20000,\n            \"dts\": np.array([0.01, 0.02, 0.05, 0.10, 0.15, 0.20])\n        },\n        # Case 2: Edge with zero initial position\n        {\n            \"omega\": 1.5, \"q0\": 0.0, \"p0\": 1.0, \"N\": 20000,\n            \"dts\": np.array([0.01, 0.02, 0.03, 0.05, 0.08, 0.10])\n        },\n        # Case 3: Mixed initial conditions, broad dt spread\n        {\n            \"omega\": 0.7, \"q0\": 0.8, \"p0\": -0.6, \"N\": 20000,\n            \"dts\": np.array([0.01, 0.03, 0.05, 0.08, 0.10, 0.20, 0.40, 0.60])\n        },\n        # Case 4: Near the stability boundary\n        {\n            \"omega\": 1.0, \"q0\": 0.5, \"p0\": 0.2, \"N\": 20000,\n            \"dts\": np.array([0.40, 0.80, 1.20, 1.60, 1.80])\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        omega = case[\"omega\"]\n        q0 = case[\"q0\"]\n        p0 = case[\"p0\"]\n        N = case[\"N\"]\n        dts = case[\"dts\"]\n        \n        u_values = []\n        y_values = []\n        \n        E0 = 0.5 * p0**2 + 0.5 * omega**2 * q0**2\n        \n        for dt in dts:\n            q, p = q0, p0\n            total_energy = 0.0\n            \n            # Pre-calculate constant factor for force\n            force_factor = omega**2\n            \n            # Simulation loop\n            for _ in range(N):\n                # Calculate and accumulate energy for the current step (q_n, p_n)\n                current_energy = 0.5 * p**2 + 0.5 * force_factor * q**2\n                total_energy += current_energy\n                \n                # Velocity Verlet integration step\n                # p_{n+1/2} = p_n - (dt/2) * omega^2 * q_n\n                p_half = p - 0.5 * dt * force_factor * q\n                # q_{n+1} = q_n + dt * p_{n+1/2}\n                q_next = q + dt * p_half\n                # p_{n+1} = p_{n+1/2} - (dt/2) * omega^2 * q_{n+1}\n                p_next = p_half - 0.5 * dt * force_factor * q_next\n                \n                q, p = q_next, p_next\n            \n            # Calculate time-averaged energy and its deviation from initial\n            E_avg = total_energy / N\n            y = E_avg - E0\n            \n            # Store u = dt^2 and y for fitting\n            u_values.append(dt**2)\n            y_values.append(y)\n            \n        # Perform least-squares fit: y = c2*u + c4*u^2\n        u_vals = np.array(u_values)\n        y_vals = np.array(y_values)\n        \n        # Design matrix A for the fit Ax = y\n        # Column 1 is u, Column 2 is u^2\n        A = np.vstack([u_vals, u_vals**2]).T\n        \n        # Solve for coefficients [c2, c4]\n        coeffs, _, _, _ = np.linalg.lstsq(A, y_vals, rcond=None)\n        c2_emp, c4_emp = coeffs[0], coeffs[1]\n        \n        # Calculate theoretical coefficients\n        # c2_th fromtilde{E} - E evaluated at t=0\n        c2_th = - (omega**4 * q0**2) / 8.0\n        c4_th = 0.0\n        \n        # Calculate absolute errors\n        error_c2 = np.abs(c2_emp - c2_th)\n        error_c4 = np.abs(c4_emp - c4_th)\n        \n        results.extend([error_c2, error_c4])\n\n    print(f\"[{','.join(f'{x:.6f}' for x in results)}]\")\n\nsolve()\n```", "id": "3409974"}]}