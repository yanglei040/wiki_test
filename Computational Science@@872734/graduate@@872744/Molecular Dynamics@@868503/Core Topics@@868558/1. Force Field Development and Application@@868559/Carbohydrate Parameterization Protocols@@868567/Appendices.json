{"hands_on_practices": [{"introduction": "Accurately modeling electrostatics is a cornerstone of any molecular simulation, as it governs interactions with solvent and other molecules. This exercise guides you through a foundational parameterization task: deriving atom-centered partial charges using the Restrained Electrostatic Potential (RESP) fitting method [@problem_id:3400174]. You will implement a robust protocol that fits charges to quantum mechanical data while enforcing essential physical constraints such as net neutrality and chemical symmetry, a crucial skill for developing high-quality force fields.", "problem": "You are tasked with implementing a physically grounded, equality-constrained electrostatic potential (ESP) charge fitting protocol suitable for carbohydrate hydroxyl parameterization in molecular dynamics. The protocol must fit atom-centered point charges to quantum mechanical electrostatic potential data computed at Hartree–Fock (HF) with the 6-31G* basis set, while enforcing chemically motivated symmetry and equivalence constraints and exact charge neutrality. The fitting must be performed across multiple hydroxyl rotamers simultaneously, with a single shared charge per atom across rotamers.\n\nStart from the following fundamental base:\n- The electrostatic potential at a field point due to fixed point charges is defined by $V(\\mathbf{r})=\\sum_{i=1}^{N} \\dfrac{q_i}{\\lVert \\mathbf{r}-\\mathbf{R}_i\\rVert}$, where $q_i$ are the unknown partial charges (in units of elementary charge $e$), $\\mathbf{R}_i$ are atomic coordinates (in $\\mathrm{\\AA}$), and $\\mathbf{r}$ is a grid point position (in $\\mathrm{\\AA}$).\n- The least-squares criterion with equality constraints is the logically minimal approach to reconcile many ESP observations with a parsimonious set of point charges subject to physical constraints.\n- A small quadratic restraint (ridge) on $q_i$ values may be used to ensure numerical stability and emulate restrained electrostatic potential fitting.\n\nYour fitting target is a minimal hydroxyl-bearing fragment used to emulate a carbohydrate hydroxyl substituent: a methanol-like moiety with $N=6$ atoms indexed as follows: $1$ (oxygen O), $2$ (hydroxyl hydrogen H$_\\mathrm{oh}$), $3$ (carbon C), $4$ (methyl hydrogen H$_\\mathrm{c1}$), $5$ (methyl hydrogen H$_\\mathrm{c2}$), $6$ (methyl hydrogen H$_\\mathrm{c3}$). Two hydroxyl rotamers are considered and must be fit simultaneously with a single shared set of charges $\\{q_i\\}_{i=1}^6$.\n\nGeometries (in $\\mathrm{\\AA}$) of the two rotamers are defined by atomic Cartesian coordinates:\n\n- Rotamer A:\n  - O: $(1.43, 0.00, 0.00)$\n  - H$_\\mathrm{oh}$: $(0.95, 0.00, 0.831)$\n  - C: $(0.00, 0.00, 0.00)$\n  - H$_\\mathrm{c1}$: $(-1.09, 0.00, 0.00)$\n  - H$_\\mathrm{c2}$: $(0.00, 1.09, 0.00)$\n  - H$_\\mathrm{c3}$: $(0.00, 0.00, 1.09)$\n\n- Rotamer B (hydroxyl hydrogen rotated about the C–O bond):\n  - O: $(1.43, 0.00, 0.00)$\n  - H$_\\mathrm{oh}$: $(0.95, 0.00, -0.831)$\n  - C: $(0.00, 0.00, 0.00)$\n  - H$_\\mathrm{c1}$: $(-1.09, 0.00, 0.00)$\n  - H$_\\mathrm{c2}$: $(0.00, 1.09, 0.00)$\n  - H$_\\mathrm{c3}$: $(0.00, 0.00, 1.09)$\n\nElectrostatic potential grid points (in $\\mathrm{\\AA}$) to be used for each rotamer are defined as sets of Cartesian coordinates. For Rotamer A and Rotamer B in Test Case $1$ and Test Case $2$, use the following $8$ grid points per rotamer:\n- $(2.50, 0.00, 0.00)$\n- $(2.50, 2.50, 0.00)$\n- $(0.00, 2.50, 2.50)$\n- $(-2.50, 0.00, 0.00)$\n- $(0.00, -2.50, 2.50)$\n- $(2.00, 0.00, 2.00)$\n- $(-2.00, -2.00, 0.00)$\n- $(0.00, 0.00, -2.50)$\n\nFor Test Case $3$, use the following $6$ grid points per rotamer (chosen to enforce identical distances to H$_\\mathrm{c2}$ and H$_\\mathrm{c3}$ via $y=z$ symmetry):\n- $(2.00, 1.00, 1.00)$\n- $(0.00, 2.00, 2.00)$\n- $(-2.00, -1.00, -1.00)$\n- $(1.00, 0.50, 0.50)$\n- $(-1.00, -0.50, -0.50)$\n- $(0.50, 1.50, 1.50)$\n\nDefine the design matrix $\\mathbf{A}$ for a given rotamer as $\\mathbf{A}_{k i}=\\dfrac{1}{r_{k i}}$, where $r_{k i}$ is the Euclidean distance (in $\\mathrm{\\AA}$) between grid point $k$ and atom $i$. Concatenate all rotamer-specific rows to form a global $\\mathbf{A}$ across rotamers. Let $\\mathbf{q}\\in\\mathbb{R}^{6}$ be the vector of charges and $\\mathbf{V}^{\\mathrm{QM}}\\in\\mathbb{R}^{M}$ the vector of quantum mechanical electrostatic potentials (in $e/\\mathrm{\\AA}$) at all $M$ grid points across all rotamers.\n\nTo ensure a self-contained numerical definition of the test suite, you must use synthetic but physically consistent $\\mathbf{V}^{\\mathrm{QM}}$ generated from the reference charges\n$$\n\\mathbf{q}^{\\mathrm{ref}}=\\big[-0.66,\\; 0.43,\\; -0.02,\\; 0.083,\\; 0.083,\\; 0.083\\big]\n$$\nin units of $e$ via $V^{\\mathrm{QM}}_k=\\sum_{i=1}^{6}\\dfrac{q^{\\mathrm{ref}}_i}{r_{k i}}$ with no added noise. All distances $r_{k i}$ are computed from the coordinates above in $\\mathrm{\\AA}$, so $V^{\\mathrm{QM}}$ is in $e/\\mathrm{\\AA}$.\n\nFit $\\mathbf{q}$ by minimizing the weighted least-squares objective with a small quadratic restraint,\n$$\n\\min_{\\mathbf{q}} \\;\\; \\frac{1}{2}\\left\\lVert \\mathbf{A}\\mathbf{q}-\\mathbf{V}^{\\mathrm{QM}}\\right\\rVert_2^2+\\frac{\\kappa}{2}\\left\\lVert \\mathbf{q}\\right\\rVert_2^2\n$$\nsubject to linear equality constraints encoding physical requirements:\n- Exact total neutrality: $\\sum_{i=1}^{6} q_i=0$.\n- Methyl hydrogen equivalence: $q_4=q_5$ and $q_5=q_6$.\n\nAngles are not required; if you need to introduce any angles internally, express them in degrees, but the problem does not demand any angle computations.\n\nImplement a program that performs this fit for three test cases that vary the number and placement of grid points and the restraint strength $\\kappa$:\n\n- Test Case $1$ (general, overdetermined): Use all $8$ grid points per rotamer for both rotamers (total $M=16$), with $\\kappa=10^{-5}$.\n- Test Case $2$ (boundary, underdetermined without restraint): Use only the first $3$ grid points per rotamer from the list above (total $M=6$), with $\\kappa=10^{-3}$.\n- Test Case $3$ (symmetry-induced column degeneracy): Use the $6$ special grid points per rotamer where $y=z$ (total $M=12$), with $\\kappa=10^{-4}$.\n\nFor each test case, compute the fitted charge vector $\\mathbf{q}^{\\ast}$ that satisfies the constraints exactly and then compute the neutrality compliance as the absolute value of the total charge,\n$$\n\\left|\\sum_{i=1}^{6} q^{\\ast}_i\\right| \\;\\; \\text{in units of } e.\n$$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[\\text{result1},\\text{result2},\\text{result3}]$), where each element is the neutrality compliance for a test case expressed as a floating-point number (unit $e$). The expected magnitudes should be near zero if constraints are correctly enforced. All computations of distances must use $\\mathrm{\\AA}$, electrostatic potentials must be in $e/\\mathrm{\\AA}$, and charges must be in $e$.", "solution": "The problem presents a task of determining atom-centered partial charges for a methanol-like molecular fragment by fitting them to quantum-mechanical electrostatic potential (ESP) data. This is a standard procedure in the development of molecular mechanics force fields, often referred to as Restrained Electrostatic Potential (RESP) fitting. The problem is formulated as a mathematically well-posed, linearly-constrained quadratic optimization problem.\n\nFirst, a validation of the problem statement is performed.\n\n**Step 1: Extraction of Givens**\n- **Model for Electrostatic Potential**: The potential at a point $\\mathbf{r}$ due to $N$ atomic charges $q_i$ at positions $\\mathbf{R}_i$ is $V(\\mathbf{r})=\\sum_{i=1}^{N} \\dfrac{q_i}{\\lVert \\mathbf{r}-\\mathbf{R}_i\\rVert}$.\n- **Objective Function**: The charges $\\mathbf{q}$ are found by minimizing the objective function $J(\\mathbf{q}) = \\frac{1}{2}\\left\\lVert \\mathbf{A}\\mathbf{q}-\\mathbf{V}^{\\mathrm{QM}}\\right\\rVert_2^2+\\frac{\\kappa}{2}\\left\\lVert \\mathbf{q}\\right\\rVert_2^2$, where $\\kappa$ is a restraint parameter.\n- **Molecular System**: A $N=6$ atom fragment with indices $1$(O), $2$(H$_\\mathrm{oh}$), $3$(C), $4$(H$_\\mathrm{c1}$), $5$(H$_\\mathrm{c2}$), and $6$(H$_\\mathrm{c3}$).\n- **Conformations**: Two rotamers (A and B) are considered simultaneously.\n- **Geometries** (in $\\mathrm{\\AA}$):\n  - Rotamer A: O: $(1.43, 0.00, 0.00)$, H$_\\mathrm{oh}$: $(0.95, 0.00, 0.831)$, C: $(0.00, 0.00, 0.00)$, H$_\\mathrm{c1}$: $(-1.09, 0.00, 0.00)$, H$_\\mathrm{c2}$: $(0.00, 1.09, 0.00)$, H$_\\mathrm{c3}$: $(0.00, 0.00, 1.09)$.\n  - Rotamer B: O: $(1.43, 0.00, 0.00)$, H$_\\mathrm{oh}$: $(0.95, 0.00, -0.831)$, C: $(0.00, 0.00, 0.00)$, H$_\\mathrm{c1}$: $(-1.09, 0.00, 0.00)$, H$_\\mathrm{c2}$: $(0.00, 1.09, 0.00)$, H$_\\mathrm{c3}$: $(0.00, 0.00, 1.09)$.\n- **ESP Grid Points** (in $\\mathrm{\\AA}$):\n  - For Test Cases $1$ & $2$: A set of $8$ points per rotamer: $(2.50, 0.00, 0.00)$, $(2.50, 2.50, 0.00)$, $(0.00, 2.50, 2.50)$, $(-2.50, 0.00, 0.00)$, $(0.00, -2.50, 2.50)$, $(2.00, 0.00, 2.00)$, $(-2.00, -2.00, 0.00)$, $(0.00, 0.00, -2.50)$.\n  - For Test Case $3$: A set of $6$ points per rotamer: $(2.00, 1.00, 1.00)$, $(0.00, 2.00, 2.00)$, $(-2.00, -1.00, -1.00)$, $(1.00, 0.50, 0.50)$, $(-1.00, -0.50, -0.50)$, $(0.50, 1.50, 1.50)$.\n- **Design Matrix**: The matrix element $\\mathbf{A}_{ki}$ is defined as $\\dfrac{1}{r_{ki}}$, where $r_{ki}$ is the distance between grid point $k$ and atom $i$.\n- **Synthetic Target Data**: The vector $\\mathbf{V}^{\\mathrm{QM}}$ is computed as $\\mathbf{V}^{\\mathrm{QM}} = \\mathbf{A}\\mathbf{q}^{\\mathrm{ref}}$, using the reference charge vector $\\mathbf{q}^{\\mathrm{ref}}=\\big[-0.66,\\; 0.43,\\; -0.02,\\; 0.083,\\; 0.083,\\; 0.083\\big]$ (units of $e$).\n- **Equality Constraints**:\n  - Charge neutrality: $\\sum_{i=1}^{6} q_i=0$.\n  - Methyl hydrogen equivalence: $q_4=q_5$ and $q_5=q_6$.\n- **Test Cases**:\n  - Test Case $1$: $M=16$ grid points, $\\kappa=10^{-5}$.\n  - Test Case $2$: $M=6$ grid points, $\\kappa=10^{-3}$.\n  - Test Case $3$: $M=12$ grid points, $\\kappa=10^{-4}$.\n- **Required Output**: For each test case, the neutrality compliance, defined as $\\left|\\sum_{i=1}^{6} q^{\\ast}_i\\right|$.\n\n**Step 2: Validation of Givens**\nThe problem is scientifically sound, reproducing a standard methodology in computational chemistry. The physical basis (Coulomb's law), mathematical formulation (constrained least squares), and chemical concepts (charge neutrality, atom equivalence) are all correct and consistent. All required data (geometries, grid points, parameters) are provided, making the problem self-contained and numerically verifiable. The objective function is convex, and the constraints are linear, which defines a well-posed quadratic programming problem with a unique solution. The inclusion of the Tikhonov regularization term (with $\\kappa > 0$) ensures numerical stability, even in cases where the design matrix $\\mathbf{A}$ might be rank-deficient (as is intentionally the case in Test Case $3$).\n\n**Step 3: Verdict and Action**\nThe problem is deemed **valid**. A solution will be developed.\n\n**Principle-Based Solution Design**\n\nThe problem is to find the charge vector $\\mathbf{q} \\in \\mathbb{R}^6$ that minimizes the regularized least-squares objective function:\n$$ J(\\mathbf{q}) = \\frac{1}{2} \\left( \\mathbf{A}\\mathbf{q} - \\mathbf{V}^{\\mathrm{QM}} \\right)^T \\left( \\mathbf{A}\\mathbf{q} - \\mathbf{V}^{\\mathrm{QM}} \\right) + \\frac{\\kappa}{2} \\mathbf{q}^T \\mathbf{q} $$\nThis can be rewritten in standard quadratic form, ignoring constant terms, as:\n$$ \\min_{\\mathbf{q}} \\frac{1}{2} \\mathbf{q}^T (\\mathbf{A}^T\\mathbf{A} + \\kappa\\mathbf{I}) \\mathbf{q} - \\mathbf{q}^T \\mathbf{A}^T \\mathbf{V}^{\\mathrm{QM}} $$\nwhere $\\mathbf{I}$ is the identity matrix.\n\nThe minimization is subject to a set of linear equality constraints:\n1.  Neutrality: $q_1 + q_2 + q_3 + q_4 + q_5 + q_6 = 0$\n2.  Equivalence: $q_4 - q_5 = 0$\n3.  Equivalence: $q_5 - q_6 = 0$\n\nThese constraints can be expressed in matrix form as $\\mathbf{Cq} = \\mathbf{d}$, where:\n$$\n\\mathbf{C} = \\begin{pmatrix} 1 & 1 & 1 & 1 & 1 & 1 \\\\ 0 & 0 & 0 & 1 & -1 & 0 \\\\ 0 & 0 & 0 & 0 & 1 & -1 \\end{pmatrix}, \\quad\n\\mathbf{q} = \\begin{pmatrix} q_1 \\\\ q_2 \\\\ q_3 \\\\ q_4 \\\\ q_5 \\\\ q_6 \\end{pmatrix}, \\quad\n\\mathbf{d} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix}\n$$\n\nThis constrained optimization problem is solved using the method of Lagrange multipliers. The Lagrangian function $\\mathcal{L}$ is constructed by adjoining the constraints to the objective function via a vector of Lagrange multipliers $\\boldsymbol{\\lambda} \\in \\mathbb{R}^3$:\n$$ \\mathcal{L}(\\mathbf{q}, \\boldsymbol{\\lambda}) = J(\\mathbf{q}) + \\boldsymbol{\\lambda}^T (\\mathbf{Cq} - \\mathbf{d}) $$\n\nThe necessary conditions for a minimum are found by setting the gradients of $\\mathcal{L}$ with respect to $\\mathbf{q}$ and $\\boldsymbol{\\lambda}$ to zero:\n$$ \\nabla_{\\mathbf{q}} \\mathcal{L} = (\\mathbf{A}^T\\mathbf{A} + \\kappa\\mathbf{I})\\mathbf{q} - \\mathbf{A}^T\\mathbf{V}^{\\mathrm{QM}} + \\mathbf{C}^T\\boldsymbol{\\lambda} = \\mathbf{0} $$\n$$ \\nabla_{\\boldsymbol{\\lambda}} \\mathcal{L} = \\mathbf{Cq} - \\mathbf{d} = \\mathbf{0} $$\n\nThese two equations form a system of linear equations. Let $\\mathbf{P} = \\mathbf{A}^T\\mathbf{A} + \\kappa\\mathbf{I}$ and $\\mathbf{s} = \\mathbf{A}^T\\mathbf{V}^{\\mathrm{QM}}$. The system can be written as:\n$$ \\mathbf{Pq} + \\mathbf{C}^T\\boldsymbol{\\lambda} = \\mathbf{s} $$\n$$ \\mathbf{Cq} = \\mathbf{d} $$\n\nThis is a Karush-Kuhn-Tucker (KKT) system, which can be expressed in a single block matrix equation:\n$$\n\\begin{pmatrix}\n\\mathbf{P} & \\mathbf{C}^T \\\\\n\\mathbf{C} & \\mathbf{0}\n\\end{pmatrix}\n\\begin{pmatrix}\n\\mathbf{q} \\\\\n\\boldsymbol{\\lambda}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\mathbf{s} \\\\\n\\mathbf{d}\n\\end{pmatrix}\n$$\nHere, the block matrix on the left is a $(6+3) \\times (6+3) = 9 \\times 9$ matrix, and the right-hand side is a $9 \\times 1$ vector.\n\nThe algorithmic procedure is as follows:\n1.  For each test case, define the system consisting of Rotamer A and Rotamer B. The total number of ESP grid points, $M$, is the sum of points for each rotamer.\n2.  Construct the global design matrix $\\mathbf{A}$ of size $M \\times 6$. For each of the $M$ grid points, a row is computed where the $i$-th element is the reciprocal of the distance from the grid point to atom $i$.\n3.  Construct the global synthetic potential vector $\\mathbf{V}^{\\mathrm{QM}}$ of size $M \\times 1$. For each grid point $k$, the value $V_k^{\\mathrm{QM}}$ is computed by $\\sum_{i=1}^{6} q_i^{\\mathrm{ref}} / r_{ki}$ using the provided reference charges.\n4.  Form the matrix $\\mathbf{P} = \\mathbf{A}^T\\mathbf{A} + \\kappa\\mathbf{I}$ and the vector $\\mathbf{s} = \\mathbf{A}^T\\mathbf{V}^{\\mathrm{QM}}$.\n5.  Assemble the $9 \\times 9$ KKT matrix and the $9 \\times 1$ right-hand side vector.\n6.  Solve the linear system to obtain the solution vector containing both the optimal charges $\\mathbf{q}^*$ (the first $6$ elements) and the Lagrange multipliers $\\boldsymbol{\\lambda}$ (the last $3$ elements).\n7.  Extract the charge vector $\\mathbf{q}^*$ and compute the neutrality compliance as the absolute value of the sum of its elements, $\\left|\\sum_{i=1}^{6} q_i^*\\right|$. This value, arising from finite-precision arithmetic, serves as a verification of the correct implementation of the constraints.\nThis procedure is applied to each of the three specified test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the constrained ESP charge fitting problem for three test cases.\n    \"\"\"\n\n    # --- Geometries and Reference Charges ---\n    # Atomic coordinates are given in Angstroms.\n    coords_rot_A = np.array([\n        [1.43, 0.00, 0.000],  # O (1)\n        [0.95, 0.00, 0.831],  # H_oh (2)\n        [0.00, 0.00, 0.000],  # C (3)\n        [-1.09, 0.00, 0.000], # H_c1 (4)\n        [0.00, 1.09, 0.000],  # H_c2 (5)\n        [0.00, 0.00, 1.090],  # H_c3 (6)\n    ])\n\n    coords_rot_B = np.array([\n        [1.43, 0.00, 0.000],   # O (1)\n        [0.95, 0.00, -0.831],  # H_oh (2)\n        [0.00, 0.00, 0.000],   # C (3)\n        [-1.09, 0.00, 0.000],  # H_c1 (4)\n        [0.00, 1.09, 0.000],   # H_c2 (5)\n        [0.00, 0.00, 1.090],   # H_c3 (6)\n    ])\n    \n    rotamer_coords = [coords_rot_A, coords_rot_B]\n\n    # Reference charges (in elementary charge e) for generating synthetic V_QM.\n    q_ref = np.array([-0.66, 0.43, -0.02, 0.083, 0.083, 0.083])\n    \n    # --- Grid Points for Test Cases ---\n    grid_points_12 = np.array([\n        [2.50, 0.00, 0.00],\n        [2.50, 2.50, 0.00],\n        [0.00, 2.50, 2.50],\n        [-2.50, 0.00, 0.00],\n        [0.00, -2.50, 2.50],\n        [2.00, 0.00, 2.00],\n        [-2.00, -2.00, 0.00],\n        [0.00, 0.00, -2.50],\n    ])\n\n    grid_points_3 = np.array([\n        [2.00, 1.00, 1.00],\n        [0.00, 2.00, 2.00],\n        [-2.00, -1.00, -1.00],\n        [1.00, 0.50, 0.50],\n        [-1.00, -0.50, -0.50],\n        [0.50, 1.50, 1.50],\n    ])\n\n    test_cases = [\n        {'kappa': 1e-5, 'grid_points': grid_points_12, 'num_points_per_rotamer': 8, 'case_id': 1},\n        {'kappa': 1e-3, 'grid_points': grid_points_12, 'num_points_per_rotamer': 3, 'case_id': 2},\n        {'kappa': 1e-4, 'grid_points': grid_points_3, 'num_points_per_rotamer': 6, 'case_id': 3},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        kappa = case['kappa']\n        grid_points = case['grid_points'][:case['num_points_per_rotamer']]\n        \n        A_rows = []\n        V_qm_vals = []\n\n        # Build the global design matrix A and target vector V_qm\n        for R_atoms in rotamer_coords:\n            for r_grid in grid_points:\n                # Calculate distances from grid point to all atoms\n                distances = np.linalg.norm(R_atoms - r_grid, axis=1)\n                \n                # Append row to design matrix A (1/r)\n                A_rows.append(1.0 / distances)\n                \n                # Calculate and append V_qm from reference charges\n                v_k = np.sum(q_ref / distances)\n                V_qm_vals.append(v_k)\n\n        A = np.array(A_rows)\n        V_qm = np.array(V_qm_vals)\n\n        num_charges = q_ref.shape[0]\n\n        # --- Set up and solve the KKT system for constrained optimization ---\n        \n        # P = A.T @ A + kappa * I\n        P = A.T @ A + kappa * np.identity(num_charges)\n        \n        # s = A.T @ V_qm\n        s = A.T @ V_qm\n\n        # Constraint matrix C\n        C = np.zeros((3, num_charges))\n        C[0, :] = 1.0        # Sum of charges = 0\n        C[1, 3] = 1.0; C[1, 4] = -1.0  # q4 - q5 = 0\n        C[2, 4] = 1.0; C[2, 5] = -1.0  # q5 - q6 = 0\n        \n        # Constraint vector d\n        d = np.zeros(C.shape[0])\n\n        # Assemble the KKT block matrix\n        num_constraints = C.shape[0]\n        KKT_matrix = np.block([\n            [P, C.T],\n            [C, np.zeros((num_constraints, num_constraints))]\n        ])\n        \n        # Assemble the KKT right-hand side vector\n        KKT_rhs = np.concatenate([s, d])\n\n        # Solve the linear system KKT_matrix * x = KKT_rhs\n        solution = np.linalg.solve(KKT_matrix, KKT_rhs)\n        \n        # Extract the fitted charges q*\n        q_fit = solution[:num_charges]\n        \n        # Calculate neutrality compliance\n        neutrality_compliance = np.abs(np.sum(q_fit))\n        results.append(neutrality_compliance)\n\n    # Print results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3400174"}, {"introduction": "Beyond static charges, a force field must correctly capture the conformational dynamics of a molecule. This practice focuses on parameterizing the crucial glycosidic dihedral angles, $\\phi$ and $\\psi$, that dictate the flexibility and accessible shapes of carbohydrates [@problem_id:3400156]. You will fit a two-dimensional potential energy surface to synthetic quantum data using a Fourier series and then validate your model by computing an ensemble-averaged property—an NOE-derived distance—and comparing it to a target value, linking your parameters directly to experimental observables.", "problem": "You are tasked with implementing a physically sound, algorithmic protocol to refit glycosidic dihedral parameters for glucose disaccharides that models the glycosidic torsions using a truncated Fourier expansion and validates the refit by reproducing Nuclear Overhauser Effect (NOE) derived distances. The focus is on the glycosidic dihedral angles $\\phi$ and $\\psi$, and on matching the NOE intensity-derived effective distance defined by the sixth-moment average $\\langle r^{-6}\\rangle^{-1/6}$. The computational protocol must start from foundational principles, specifically periodicity of torsional potentials and Boltzmann statistics for ensemble averages, and must not rely on pre-given fitted parameters or empirical shortcuts.\n\nBegin from the following fundamental base:\n- Classical torsional potentials for a dihedral angle are periodic functions. Any sufficiently smooth $2\\pi$-periodic function $V(\\theta)$ can be represented by a Fourier series, and a truncated series is routinely used in molecular mechanics force fields. Use the representation $V(\\phi,\\psi)$ expanded on a set of trigonometric basis functions.\n- Equilibrium populations over torsional states follow Boltzmann statistics. For a potential $V(\\phi,\\psi)$ at temperature $T$, the probability density is $p(\\phi,\\psi)\\propto\\exp\\left(-\\beta V(\\phi,\\psi)\\right)$ where $\\beta=1/\\left(k_{\\mathrm{B}}T\\right)$ and $k_{\\mathrm{B}}$ is the Boltzmann constant.\n- The Nuclear Overhauser Effect (NOE) effective proton–proton distance is $r_{\\mathrm{eff}}=\\left\\langle r^{-6}\\right\\rangle^{-1/6}$, with the ensemble average taken over the Boltzmann distribution.\n\nYour program must implement the following protocol:\n1. Generate synthetic ab initio torsion scan energies that emulate second-order Møller–Plesset perturbation theory (MP2) with the correlation-consistent polarized valence triple-zeta basis set (cc-pVTZ). The scans span a uniform grid over the two torsions $\\phi$ and $\\psi$ in radians. The synthetic \"true\" energy surface is constructed from a known set of Fourier amplitudes and phases, plus a realistic cross term, and then perturbed by adding small Gaussian noise to emulate quantum chemistry imperfections. This represents the input data.\n2. Fit a truncated Fourier model to the noisy synthetic energies using linear least squares on the trigonometric basis functions. Use the following linear basis to represent the refit potential $V_{\\mathrm{fit}}(\\phi,\\psi)$: a constant term, $\\cos(n\\phi)$ and $\\sin(n\\phi)$ for $n=1,2,3$, $\\cos(m\\psi)$ and $\\sin(m\\psi)$ for $m=1,2,3$, and a single coupling term with $\\cos(\\phi-\\psi)$ and $\\sin(\\phi-\\psi)$. Solve for the linear coefficients that minimize the squared error to the noisy energies across the grid.\n3. Validate the refit by computing $r_{\\mathrm{eff}}$ for one representative proton–proton pair whose distance depends on the glycosidic torsions via a physically reasonable trigonometric map $r(\\phi,\\psi)=r_{0}+a\\cos\\left(\\phi-\\phi_{0}\\right)+b\\cos\\left(\\psi-\\psi_{0}\\right)$, with constants provided per test case. Compute two effective distances: $r_{\\mathrm{eff}}^{\\mathrm{fit}}$ using $V_{\\mathrm{fit}}(\\phi,\\psi)$ and $r_{\\mathrm{eff}}^{\\mathrm{true}}$ using the noise-free \"true\" potential. Use discrete Boltzmann averaging over the uniform grid to evaluate $\\left\\langle r^{-6}\\right\\rangle$ and then take the inverse sixth root.\n4. Report the root-mean-square error (RMSE) between the refit and the noisy synthetic energies to quantify the fit quality, and determine whether the refit reproduces the NOE-derived distance by checking if $\\left|r_{\\mathrm{eff}}^{\\mathrm{fit}}-r_{\\mathrm{eff}}^{\\mathrm{true}}\\right|\\leq \\mathrm{tol}$, where $\\mathrm{tol}$ is a tolerance specified per test case.\n\nAngles must be in radians, energies must be in kilojoules per mole, temperature must be in Kelvin, and distances must be in Angstroms. When reporting RMSE and $r_{\\mathrm{eff}}^{\\mathrm{fit}}$, round to three decimal places. The Boltzmann constant must be used in units of kilojoules per mole per Kelvin.\n\nImplement the following details for the model construction and validation:\n- Use a uniform grid with $N_{\\phi}=36$ and $N_{\\psi}=36$ samples, covering $\\phi\\in[-\\pi,\\pi)$ and $\\psi\\in[-\\pi,\\pi)$.\n- The synthetic \"true\" energy surface is defined as\n$$\nV_{\\mathrm{true}}(\\phi,\\psi)=\\sum_{n=1}^{3}K_{\\phi,n}\\left[1-\\cos\\left(n\\phi-\\delta_{\\phi,n}\\right)\\right]+\\sum_{m=1}^{3}K_{\\psi,m}\\left[1-\\cos\\left(m\\psi-\\delta_{\\psi,m}\\right)\\right]+K_{c}\\left[1-\\cos\\left(\\phi-\\psi-\\delta_{c}\\right)\\right],\n$$\nwith all $K$ in kilojoules per mole and all phase shifts $\\delta$ in radians. The noisy synthetic energies are $V_{\\mathrm{QM}}(\\phi,\\psi)=V_{\\mathrm{true}}(\\phi,\\psi)+\\epsilon$, where $\\epsilon$ is Gaussian noise with zero mean and standard deviation $\\sigma_{E}$ in kilojoules per mole. Use per-case random seeds for reproducibility.\n- The refit model is the linear expansion\n$$\nV_{\\mathrm{fit}}(\\phi,\\psi)=C+\\sum_{n=1}^{3}\\left[A_{\\phi,n}\\cos(n\\phi)+B_{\\phi,n}\\sin(n\\phi)\\right]+\\sum_{m=1}^{3}\\left[A_{\\psi,m}\\cos(m\\psi)+B_{\\psi,m}\\sin(m\\psi)\\right]+A_{c}\\cos(\\phi-\\psi)+B_{c}\\sin(\\phi-\\psi),\n$$\nwhere the coefficients are determined by least squares against $V_{\\mathrm{QM}}(\\phi,\\psi)$ evaluated over the full grid.\n\nFor Boltzmann averaging on the grid:\n- Define $\\beta=1/\\left(k_{\\mathrm{B}}T\\right)$ with $k_{\\mathrm{B}}=0.008314462618$ kilojoules per mole per Kelvin.\n- To improve numerical stability, subtract the minimum energy $V_{\\min}$ from the energy surface before exponentiation, i.e., use weights $w_{ij}=\\exp\\left(-\\beta\\left[V(\\phi_{i},\\psi_{j})-V_{\\min}\\right]\\right)$ and normalize by $Z=\\sum_{ij}w_{ij}$.\n- Compute $\\left\\langle r^{-6}\\right\\rangle=\\sum_{ij}\\left[w_{ij}/Z\\right]\\cdot r(\\phi_{i},\\psi_{j})^{-6}$, then $r_{\\mathrm{eff}}=\\left\\langle r^{-6}\\right\\rangle^{-1/6}$.\n\nTest suite:\nImplement three test cases that exercise different behaviors. For each case, you are given the \"true\" amplitudes and phases for $\\phi$, $\\psi$, and the coupling term; the distance-map constants; the temperature $T$; the energy-noise level $\\sigma_{E}$; the tolerance $\\mathrm{tol}$; and the random seed.\n\n- Case $1$ (representative $\\alpha$ linkage):\n  - $K_{\\phi}=\\left[2.5,1.2,0.5\\right]$, $\\delta_{\\phi}=\\left[0.0,\\frac{\\pi}{3},\\frac{\\pi}{2}\\right]$.\n  - $K_{\\psi}=\\left[3.0,0.8,0.4\\right]$, $\\delta_{\\psi}=\\left[\\frac{\\pi}{6},\\frac{\\pi}{2},\\frac{\\pi}{3}\\right]$.\n  - $K_{c}=0.6$, $\\delta_{c}=\\frac{\\pi}{4}$.\n  - Distance map constants: $r_{0}=3.0$, $a=0.35$, $b=0.25$, $\\phi_{0}=0.0$, $\\psi_{0}=\\frac{\\pi}{3}$.\n  - $T=300$, $\\sigma_{E}=0.1$, $\\mathrm{tol}=0.06$, seed $=42$.\n\n- Case $2$ (representative $\\beta$ linkage):\n  - $K_{\\phi}=\\left[1.5,0.7,0.3\\right]$, $\\delta_{\\phi}=\\left[\\frac{\\pi}{2},0.0,\\frac{\\pi}{2}\\right]$.\n  - $K_{\\psi}=\\left[2.2,1.0,0.4\\right]$, $\\delta_{\\psi}=\\left[0.0,\\frac{\\pi}{3},\\frac{\\pi}{2}\\right]$.\n  - $K_{c}=0.2$, $\\delta_{c}=0.0$.\n  - Distance map constants: $r_{0}=2.8$, $a=0.30$, $b=0.35$, $\\phi_{0}=\\frac{\\pi}{6}$, $\\psi_{0}=\\frac{\\pi}{4}$.\n  - $T=298$, $\\sigma_{E}=0.15$, $\\mathrm{tol}=0.05$, seed $=123$.\n\n- Case $3$ (near-flat edge case):\n  - $K_{\\phi}=\\left[0.2,0.1,0.0\\right]$, $\\delta_{\\phi}=\\left[0.0,0.0,0.0\\right]$.\n  - $K_{\\psi}=\\left[0.2,0.1,0.0\\right]$, $\\delta_{\\psi}=\\left[0.0,0.0,0.0\\right]$.\n  - $K_{c}=0.0$, $\\delta_{c}=0.0$.\n  - Distance map constants: $r_{0}=3.2$, $a=0.20$, $b=0.20$, $\\phi_{0}=0.0$, $\\psi_{0}=0.0$.\n  - $T=310$, $\\sigma_{E}=0.05$, $\\mathrm{tol}=0.08$, seed $=7$.\n\nYour program should compute, for each case:\n- The root-mean-square error $\\mathrm{RMSE}$ in kilojoules per mole between $V_{\\mathrm{fit}}$ and $V_{\\mathrm{QM}}$ over the grid, rounded to three decimal places.\n- The NOE effective distance $r_{\\mathrm{eff}}^{\\mathrm{fit}}$ in Angstroms, rounded to three decimal places.\n- A boolean indicating whether $\\left|r_{\\mathrm{eff}}^{\\mathrm{fit}}-r_{\\mathrm{eff}}^{\\mathrm{true}}\\right|\\leq \\mathrm{tol}$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list of per-case triplets, each triplet enclosed in square brackets, and the whole list enclosed in square brackets. For example, the output should look like $\\left[\\left[\\mathrm{RMSE}_{1},r_{\\mathrm{eff},1},\\mathrm{pass}_{1}\\right],\\left[\\mathrm{RMSE}_{2},r_{\\mathrm{eff},2},\\mathrm{pass}_{2}\\right],\\left[\\mathrm{RMSE}_{3},r_{\\mathrm{eff},3},\\mathrm{pass}_{3}\\right]\\right]$, where $\\mathrm{pass}_{i}$ is either $\\mathrm{True}$ or $\\mathrm{False}$. All angles must be in radians, energies in kilojoules per mole, temperature in Kelvin, and distances in Angstroms, and all floating point values must be rounded to three decimal places where specified.", "solution": "The problem presents a valid and well-defined task in computational chemistry, specifically in the domain of molecular mechanics force field parameterization. It requires the implementation of an algorithmic protocol to refit dihedral parameters for a disaccharide's glycosidic linkage. The protocol is grounded in fundamental principles of statistical mechanics and is validated against a physically meaningful observable, the Nuclear Overhauser Effect (NOE)-derived interproton distance. The problem is self-contained, scientifically sound, and computationally tractable. We shall proceed with a detailed solution.\n\nThe objective is to refit the potential energy surface $V(\\phi,\\psi)$ governing the glycosidic torsion angles $\\phi$ and $\\psi$ and to validate this fit by its ability to reproduce an ensemble-averaged structural property. The protocol is designed from first principles, avoiding empirical shortcuts.\n\n**1. Theoretical and Physical Foundation**\n\nThe conformational landscape of a molecule is determined by its potential energy surface (PES). For dihedral angles, the potential energy is a periodic function. Any sufficiently smooth $2\\pi$-periodic function can be approximated by a truncated Fourier series. This is the cornerstone of dihedral parameterization in most classical force fields.\n\nWe begin with a synthetic \"true\" potential energy surface, $V_{\\mathrm{true}}(\\phi,\\psi)$, which emulates a high-quality quantum mechanical scan. Its functional form is a sum of periodic terms for each torsion and a coupling term:\n$$\nV_{\\mathrm{true}}(\\phi,\\psi)=\\sum_{n=1}^{3}K_{\\phi,n}\\left[1-\\cos\\left(n\\phi-\\delta_{\\phi,n}\\right)\\right]+\\sum_{m=1}^{3}K_{\\psi,m}\\left[1-\\cos\\left(m\\psi-\\delta_{\\psi,m}\\right)\\right]+K_{c}\\left[1-\\cos\\left(\\phi-\\psi-\\delta_{c}\\right)\\right]\n$$\nHere, $K$ represents the amplitude (barrier height) in units of kilojoules per mole (kJ/mol), and $\\delta$ is the phase shift in radians. The synthetic \"quantum mechanical\" data, $V_{\\mathrm{QM}}(\\phi,\\psi)$, is generated by adding Gaussian noise, $\\epsilon$, with standard deviation $\\sigma_E$ to this true surface: $V_{\\mathrm{QM}}(\\phi,\\psi)=V_{\\mathrm{true}}(\\phi,\\psi)+\\epsilon$.\n\nThe model to be fitted, $V_{\\mathrm{fit}}(\\phi,\\psi)$, is constructed from a linear combination of trigonometric basis functions. This choice ensures the required periodicity and allows for a straightforward solution via linear least squares. The basis set includes a constant term and sinusoidal functions up to a frequency of $3$ for each angle, plus a single cross-term:\n$$\nV_{\\mathrm{fit}}(\\phi,\\psi)=C+\\sum_{n=1}^{3}\\left[A_{\\phi,n}\\cos(n\\phi)+B_{\\phi,n}\\sin(n\\phi)\\right]+\\sum_{m=1}^{3}\\left[A_{\\psi,m}\\cos(m\\psi)+B_{\\psi,m}\\sin(m\\psi)\\right]+A_{c}\\cos(\\phi-\\psi)+B_{c}\\sin(\\phi-\\psi)\n$$\nThe connection between the microscopic potential energy surface and macroscopic observables is established by statistical mechanics. At thermal equilibrium at a temperature $T$, the probability of finding the system in a state with coordinates $(\\phi,\\psi)$ is given by the Boltzmann distribution:\n$$\np(\\phi,\\psi) = \\frac{1}{Z} \\exp\\left(-\\beta V(\\phi,\\psi)\\right)\n$$\nwhere $\\beta = 1/(k_{\\mathrm{B}}T)$ is the inverse thermal energy, $k_{\\mathrm{B}}$ is the Boltzmann constant ($0.008314462618~\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$), and $Z = \\int \\int \\exp(-\\beta V(\\phi,\\psi)) d\\phi d\\psi$ is the partition function.\n\nThe validation relies on the NOE, which provides experimental constraints on interproton distances. The NOE signal intensity is proportional to $\\langle r^{-6} \\rangle$, where $r$ is the interproton distance and the angle brackets denote an ensemble average over the Boltzmann distribution. The effective distance is thus defined as:\n$$\nr_{\\mathrm{eff}}=\\left\\langle r^{-6}\\right\\rangle^{-1/6}\n$$\nThe distance $r$ itself is a function of the dihedral angles, given by the trigonometric map $r(\\phi,\\psi)=r_{0}+a\\cos\\left(\\phi-\\phi_{0}\\right)+b\\cos\\left(\\psi-\\psi_{0}\\right)$.\n\n**2. Algorithmic Protocol and Implementation**\n\nThe protocol is implemented as a sequence of discrete computational steps. All operations are carried out on a uniform grid of $N_{\\phi}=36 \\times N_{\\psi}=36$ points spanning $\\phi, \\psi \\in [-\\pi, \\pi)$.\n\n**Step 1: Data Generation**\nFor each test case, we first construct the two-dimensional grid of torsion angles $(\\phi_i, \\psi_j)$. We then evaluate the analytical expression for $V_{\\mathrm{true}}(\\phi_i, \\psi_j)$ at each grid point. A specific random seed is used to generate a grid of Gaussian noise values, $\\epsilon_{ij}$, with mean $0$ and standard deviation $\\sigma_E$. These are added to $V_{\\mathrm{true}}$ to produce the target data for fitting, $V_{\\mathrm{QM}}$.\n\n**Step 2: Linear Least-Squares Fitting**\nThe core of the refitting procedure is to determine the coefficients $\\{C, A_{\\phi,n}, B_{\\phi,n}, \\ldots, B_c\\}$ of the $V_{\\mathrm{fit}}$ model. This is formulated as a linear least-squares problem, $\\mathbf{A}\\mathbf{c} \\approx \\mathbf{v}_{\\mathrm{QM}}$.\n- The vector $\\mathbf{v}_{\\mathrm{QM}}$ is a flattened array of the $N_{\\phi} \\times N_{\\psi} = 1296$ values from the $V_{\\mathrm{QM}}$ surface.\n- The vector $\\mathbf{c}$ contains the $15$ unknown coefficients to be determined.\n- The design matrix $\\mathbf{A}$ has dimensions $(1296 \\times 15)$. Each row corresponds to a grid point $(\\phi_i, \\psi_j)$, and each column corresponds to one of the $15$ basis functions evaluated at that point. For example, the first column is all ones (for the coefficient $C$), the second is $\\cos(\\phi_i)$, the third is $\\sin(\\phi_i)$, and so on.\n\nThe optimal coefficient vector $\\mathbf{c}$ that minimizes the squared Euclidean norm $\\|\\mathbf{A}\\mathbf{c} - \\mathbf{v}_{\\mathrm{QM}}\\|^2$ is found using a standard linear least-squares solver, specifically `numpy.linalg.lstsq`. Once $\\mathbf{c}$ is obtained, the fitted potential surface $V_{\\mathrm{fit}}$ is reconstructed by computing the matrix-vector product $\\mathbf{A}\\mathbf{c}$ and reshaping the result into a $36 \\times 36$ grid. The quality of this fit is quantified by the root-mean-square error (RMSE) between the fitted surface $V_{\\mathrm{fit}}$ and the noisy data $V_{\\mathrm{QM}}$:\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{N_{\\phi}N_{\\psi}}\\sum_{i,j}\\left(V_{\\mathrm{fit}}(\\phi_i,\\psi_j) - V_{\\mathrm{QM}}(\\phi_i,\\psi_j)\\right)^2}\n$$\n\n**Step 3: Validation via Ensemble Averaging**\nThe crucial validation step assesses whether the fitted potential can reproduce the physical properties of the \"true\" system. We compute the ensemble average $\\langle r^{-6} \\rangle$ using a discrete sum over the grid points, weighted by their Boltzmann probabilities. For a generic potential surface $V$, the average of a function $f(\\phi,\\psi)$ is:\n$$\n\\langle f \\rangle \\approx \\frac{\\sum_{i,j} f(\\phi_i, \\psi_j) w_{ij}}{\\sum_{i,j} w_{ij}}\n$$\nwhere the statistical weights are $w_{ij}=\\exp\\left(-\\beta\\left[V(\\phi_{i},\\psi_{j})-V_{\\min}\\right]\\right)$. Subtracting the minimum energy $V_{\\min}$ before exponentiation is a standard technique to prevent numerical overflow.\n\nThis calculation is performed twice:\n1. Using $V_{\\mathrm{true}}$ to compute the \"ground truth\" effective distance, $r_{\\mathrm{eff}}^{\\mathrm{true}}$.\n2. Using $V_{\\mathrm{fit}}$ to compute the effective distance from our model, $r_{\\mathrm{eff}}^{\\mathrm{fit}}$.\n\nThe refit is deemed successful if the absolute difference between these two distances is within a specified tolerance, i.e., $|r_{\\mathrm{eff}}^{\\mathrm{fit}} - r_{\\mathrm{eff}}^{\\mathrm{true}}| \\leq \\mathrm{tol}$. The final program implements this complete workflow for each test case and reports the RMSE of the fit, the calculated $r_{\\mathrm{eff}}^{\\mathrm{fit}}$, and the boolean outcome of the validation check.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Implements a full protocol for refitting and validating glycosidic\n    dihedral parameters based on synthetic QM data and NOE-derived distances.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (representative alpha linkage)\n        {\n            \"K_phi\": [2.5, 1.2, 0.5], \"d_phi\": [0.0, np.pi/3, np.pi/2],\n            \"K_psi\": [3.0, 0.8, 0.4], \"d_psi\": [np.pi/6, np.pi/2, np.pi/3],\n            \"K_c\": 0.6, \"d_c\": np.pi/4,\n            \"dist_map\": {\"r0\": 3.0, \"a\": 0.35, \"b\": 0.25, \"phi0\": 0.0, \"psi0\": np.pi/3},\n            \"T\": 300, \"sigma_E\": 0.1, \"tol\": 0.06, \"seed\": 42\n        },\n        # Case 2 (representative beta linkage)\n        {\n            \"K_phi\": [1.5, 0.7, 0.3], \"d_phi\": [np.pi/2, 0.0, np.pi/2],\n            \"K_psi\": [2.2, 1.0, 0.4], \"d_psi\": [0.0, np.pi/3, np.pi/2],\n            \"K_c\": 0.2, \"d_c\": 0.0,\n            \"dist_map\": {\"r0\": 2.8, \"a\": 0.30, \"b\": 0.35, \"phi0\": np.pi/6, \"psi0\": np.pi/4},\n            \"T\": 298, \"sigma_E\": 0.15, \"tol\": 0.05, \"seed\": 123\n        },\n        # Case 3 (near-flat edge case)\n        {\n            \"K_phi\": [0.2, 0.1, 0.0], \"d_phi\": [0.0, 0.0, 0.0],\n            \"K_psi\": [0.2, 0.1, 0.0], \"d_psi\": [0.0, 0.0, 0.0],\n            \"K_c\": 0.0, \"d_c\": 0.0,\n            \"dist_map\": {\"r0\": 3.2, \"a\": 0.20, \"b\": 0.20, \"phi0\": 0.0, \"psi0\": 0.0},\n            \"T\": 310, \"sigma_E\": 0.05, \"tol\": 0.08, \"seed\": 7\n        }\n    ]\n\n    # Global parameters\n    N_PHI = 36\n    N_PSI = 36\n    K_B = 0.008314462618  # kJ/mol/K\n\n    def generate_true_potential(phi, psi, K_phi, d_phi, K_psi, d_psi, K_c, d_c):\n        \"\"\"Generates the true potential energy surface V_true.\"\"\"\n        V = np.zeros_like(phi)\n        for n in range(1, 4):\n            if n-1 < len(K_phi):\n                V += K_phi[n-1] * (1 - np.cos(n * phi - d_phi[n-1]))\n        for m in range(1, 4):\n            if m-1 < len(K_psi):\n                V += K_psi[m-1] * (1 - np.cos(m * psi - d_psi[m-1]))\n        V += K_c * (1 - np.cos(phi - psi - d_c))\n        return V\n\n    def build_design_matrix(phi, psi):\n        \"\"\"Builds the design matrix A for the linear least squares fit.\"\"\"\n        num_points = phi.size\n        # 1(const) + 3*2(phi) + 3*2(psi) + 2(couple) = 15 columns\n        A = np.zeros((num_points, 15))\n        \n        phi_flat = phi.flatten()\n        psi_flat = psi.flatten()\n        \n        A[:, 0] = 1.0  # Constant term\n        col_idx = 1\n        for n in range(1, 4):\n            A[:, col_idx] = np.cos(n * phi_flat)\n            A[:, col_idx+1] = np.sin(n * phi_flat)\n            col_idx += 2\n            \n        for m in range(1, 4):\n            A[:, col_idx] = np.cos(m * psi_flat)\n            A[:, col_idx+1] = np.sin(m * psi_flat)\n            col_idx += 2\n            \n        A[:, col_idx] = np.cos(phi_flat - psi_flat)\n        A[:, col_idx+1] = np.sin(phi_flat - psi_flat)\n        \n        return A\n\n    def calculate_effective_distance(V, phi, psi, T, r0, a, b, phi0, psi0):\n        \"\"\"Calculates the NOE effective distance r_eff from a potential surface V.\"\"\"\n        beta = 1.0 / (K_B * T)\n        \n        # Numerically stable Boltzmann weights\n        V_min = np.min(V)\n        weights = np.exp(-beta * (V - V_min))\n        Z = np.sum(weights)\n        probs = weights / Z\n        \n        # Distance map\n        R = r0 + a * np.cos(phi - phi0) + b * np.cos(psi - psi0)\n        \n        # Ensemble average of r^-6\n        r_m6_avg = np.sum(probs * (R**(-6)))\n        \n        # Effective distance\n        r_eff = r_m6_avg**(-1.0/6.0)\n        \n        return r_eff\n\n    results = []\n    \n    # Grid setup\n    phi_1d = np.linspace(-np.pi, np.pi, N_PHI, endpoint=False)\n    psi_1d = np.linspace(-np.pi, np.pi, N_PSI, endpoint=False)\n    PHI, PSI = np.meshgrid(phi_1d, psi_1d)\n\n    A_matrix = build_design_matrix(PHI, PSI)\n\n    for case in test_cases:\n        # 1. Generate synthetic data\n        V_true = generate_true_potential(PHI, PSI, case[\"K_phi\"], case[\"d_phi\"],\n                                         case[\"K_psi\"], case[\"d_psi\"], case[\"K_c\"], case[\"d_c\"])\n        \n        rng = np.random.default_rng(case[\"seed\"])\n        noise = rng.normal(0, case[\"sigma_E\"], size=(N_PSI, N_PHI))\n        V_QM = V_true + noise\n        \n        # 2. Fit the model using linear least squares\n        b = V_QM.flatten()\n        coeffs, _, _, _ = np.linalg.lstsq(A_matrix, b, rcond=None)\n        \n        V_fit_flat = A_matrix @ coeffs\n        V_fit = V_fit_flat.reshape((N_PSI, N_PHI))\n        \n        # 4. Calculate RMSE\n        rmse = np.sqrt(np.mean((V_fit - V_QM)**2))\n        \n        # 3. Validate with NOE distance\n        r_eff_true = calculate_effective_distance(V_true, PHI, PSI, case[\"T\"], **case[\"dist_map\"])\n        r_eff_fit = calculate_effective_distance(V_fit, PHI, PSI, case[\"T\"], **case[\"dist_map\"])\n        \n        # 4. Check tolerance\n        passes_check = np.abs(r_eff_fit - r_eff_true) <= case[\"tol\"]\n        \n        # Format results\n        results.append([round(rmse, 3), round(r_eff_fit, 3), bool(passes_check)])\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\".replace(\" \", \"\").replace(\"True\", \"True\").replace(\"False\", \"False\"))\n\nsolve()\n```", "id": "3400156"}, {"introduction": "A robust force field must not only be accurate but also stable, preventing unphysical transformations during a simulation. This exercise tackles the critical task of maintaining correct molecular stereochemistry by designing an improper torsional restraint [@problem_id:3400183]. Based on statistical mechanics, you will calculate the minimum force constant required to suppress the inversion of a chiral center, providing a principled method for refining a force field and ensuring its physical realism.", "problem": "You are given a protocol design task arising in carbohydrate parameterization for molecular dynamics. During high-temperature sampling of a carbohydrate anomeric center, a chiral center has been observed to invert. You must design a single improper torsion restraint that suppresses this inversion while minimally perturbing nearby proper dihedrals. Use a harmonic improper potential anchored at the observed geometry and determine the weakest force constant that meets a probabilistic inversion-suppression target at a specified high temperature. Your program must calculate this from first principles.\n\nFundamental base to use:\n- The Boltzmann distribution implies that for a coordinate with harmonic energy, fluctuations are Gaussian with variance determined by thermal energy. If the potential is harmonic, $U(\\phi) = \\tfrac{1}{2} k \\left(\\phi - \\phi_{0}\\right)^{2},$ then at temperature $T$ the stationary distribution of $\\phi$ is Gaussian with mean $\\phi_{0}$ and variance $\\sigma^{2} = \\dfrac{R T}{k},$ where $R$ is the universal gas constant per mole.\n- For a univariate Gaussian with mean $\\mu$ and standard deviation $\\sigma,$ the one-sided tail probability beyond a threshold at distance $\\mu/\\sigma$ is $\\tfrac{1}{2}\\,\\mathrm{erfc}\\!\\left(\\dfrac{\\mu}{\\sqrt{2}\\,\\sigma}\\right),$ where $\\mathrm{erfc}$ is the complementary error function.\n\nDesign objectives and definitions:\n- You must compute the signed improper dihedral angle $\\phi_{0}$ in radians from four atom positions that define the improper quadruplet ordered as $(\\text{peripheral }1,\\, \\text{center},\\, \\text{peripheral }2,\\, \\text{peripheral }3).$ The improper dihedral is the signed angle between the planes formed by $(\\text{peripheral }1,\\, \\text{center},\\, \\text{peripheral }2)$ and $(\\text{center},\\, \\text{peripheral }2,\\, \\text{peripheral }3),$ computed by the standard arctangent of a ratio of scalar triple products and dot products. Use the following vector-geometry convention. Given positions $\\mathbf{r}_{0}, \\mathbf{r}_{1}, \\mathbf{r}_{2}, \\mathbf{r}_{3}$:\n    1. Define bond vectors: $\\mathbf{b}_{0} = \\mathbf{r}_{1} - \\mathbf{r}_{0}$, $\\mathbf{b}_{1} = \\mathbf{r}_{2} - \\mathbf{r}_{1}$, and $\\mathbf{b}_{2} = \\mathbf{r}_{3} - \\mathbf{r}_{2}$.\n    2. Compute normal vectors to the two planes: $\\mathbf{n}_{0} = \\mathbf{b}_{0} \\times \\mathbf{b}_{1}$ and $\\mathbf{n}_{1} = \\mathbf{b}_{1} \\times \\mathbf{b}_{2}$.\n    3. Compute the components for the four-quadrant arctangent: $x = \\mathbf{n}_{0} \\cdot \\mathbf{n}_{1}$ and $y = \\lVert \\mathbf{b}_{1} \\rVert\\, (\\mathbf{b}_{0} \\cdot \\mathbf{n}_{1})$.\n    4. The angle is given by $\\phi = \\mathrm{atan2}(y, x)$.\nTake $\\phi_{0} = \\phi,$ ensuring $\\phi_{0} \\in (-\\pi,\\pi].$\n- To suppress inversion of chirality, require that at the specified high temperature $T_{\\mathrm{high}}$ the one-sided probability that thermal fluctuations carry $\\phi$ across the inversion boundary at $\\phi = 0$ is at most a target fraction $p_{\\max}.$ Because the improper is centered at $\\phi_{0},$ inversion requires a fluctuation of magnitude at least $\\lvert \\phi_{0}\\rvert.$ Using the Gaussian model above, select the smallest harmonic force constant $k$ (in kilojoules per mole per radian squared) that satisfies this one-sided probability bound; this choice minimizes perturbation to nearby proper dihedrals.\n\nConstants and units:\n- Use $R = 8.31446261815324 \\times 10^{-3}$ kilojoule per mole per Kelvin.\n- Temperatures are in Kelvin, angles in radians, energies in kilojoule per mole.\n\nYour task:\n- For each test case below, compute $\\phi_{0}$ from coordinates, then compute the minimal $k$ that makes the one-sided crossing probability at $T_{\\mathrm{high}}$ no larger than $p_{\\max}.$ Report also the achieved probability under your chosen $k$ to verify the design.\n\nNumerical details to implement:\n- Use the one-sided Gaussian tail probability $p = \\tfrac{1}{2}\\,\\mathrm{erfc}\\!\\left(\\dfrac{\\lvert \\phi_{0}\\rvert}{\\sqrt{2}\\,\\sigma}\\right)$ with $\\sigma = \\sqrt{\\dfrac{R T_{\\mathrm{high}}}{k}}.$\n- Choose $k$ as the smallest value that satisfies $p \\le p_{\\max}.$\n- Round every reported floating-point number to exactly $6$ decimal places in the final output.\n\nTest suite:\nProvide a solution for each of the following independently parameterized cases. In each case, the quadruplet is ordered as $(\\text{peripheral }1,\\, \\text{center},\\, \\text{peripheral }2,\\, \\text{peripheral }3).$ Positions are Cartesian coordinates in ångström (the units cancel in the angle calculation), temperatures in Kelvin, and probabilities are unitless fractions.\n\n- Case $1$:\n  - Coordinates: $\\left( (1.0,\\, 0.0,\\, 0.0),\\ (0.1,\\, 0.2,\\, 0.0),\\ (0.0,\\, 1.0,\\, 0.0),\\ (0.0,\\, 0.2,\\, 0.9) \\right)$\n  - $T_{\\mathrm{high}} = 600.0$\n  - $p_{\\max} = 1.0\\times 10^{-6}$\n- Case $2$:\n  - Coordinates: $\\left( (1.0,\\, 0.0,\\, 0.0),\\ (0.1,\\, 0.2,\\, 0.0),\\ (0.0,\\, 1.0,\\, 0.0),\\ (0.0,\\, 0.2,\\, -0.9) \\right)$\n  - $T_{\\mathrm{high}} = 600.0$\n  - $p_{\\max} = 1.0\\times 10^{-8}$\n- Case $3$:\n  - Coordinates: $\\left( (1.0,\\, 0.0,\\, 0.0),\\ (0.1,\\, 0.2,\\, 0.0),\\ (0.0,\\, 1.0,\\, 0.0),\\ (0.0,\\, 0.2,\\, 0.02) \\right)$\n  - $T_{\\mathrm{high}} = 800.0$\n  - $p_{\\max} = 1.0\\times 10^{-4}$\n- Case $4$:\n  - Coordinates: $\\left( (1.5,\\, -0.2,\\, 0.0),\\ (0.0,\\, 0.0,\\, 0.0),\\ (0.0,\\, 1.2,\\, 0.0),\\ (-0.1,\\, 0.1,\\, 1.0) \\right)$\n  - $T_{\\mathrm{high}} = 1200.0$\n  - $p_{\\max} = 1.0\\times 10^{-6}$\n\nOutput specification:\n- For each test case, output a list $[\\ k,\\ \\phi_{0},\\ p\\ ]$ where $k$ is the designed force constant in kilojoule per mole per radian squared, $\\phi_{0}$ is the equilibrium improper angle in radians, and $p$ is the resulting one-sided inversion probability at $T_{\\mathrm{high}}$ under your $k.$\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list of the four lists, enclosed in square brackets, for example $\\left[\\ [\\cdot,\\cdot,\\cdot],\\ [\\cdot,\\cdot,\\cdot],\\ [\\cdot,\\cdot,\\cdot],\\ [\\cdot,\\cdot,\\cdot]\\ \\right].$\n- Round every floating-point number in the output to exactly $6$ decimal places.\n\nNotes on scientific realism:\n- In the context of carbohydrate parameterization protocols, the chosen improper center is the chiral carbon, and the three peripherals are its substituents defining the local stereochemistry. Selecting the minimal $k$ that meets the probabilistic inversion constraint ensures the restraint is as weak as possible and therefore minimally perturbs neighboring torsional degrees of freedom, aligning with best practices for non-invasive chirality enforcement.", "solution": "The problem requires the design of a harmonic improper torsion potential to suppress chiral inversion at a specific atomic center. The core task is to determine the minimum force constant, $$k$$, for the potential $$U(\\phi) = \\frac{1}{2} k (\\phi - \\phi_{0})^2$$ that limits the probability of the improper angle $$\\phi$$ crossing the inversion boundary at $$\\phi = 0$$ to a maximum value $$p_{\\max}$$ at a given high temperature $$T_{\\mathrm{high}}$$. The solution involves two primary steps: first, calculating the equilibrium improper angle $$\\phi_{0}$$ from the provided atomic coordinates, and second, deriving the force constant $$k$$ based on the principles of statistical mechanics.\n\n**Step 1: Calculation of the Equilibrium Improper Angle ($$\\phi_{0}$$)**\n\nThe equilibrium improper angle, $$\\phi_{0}$$, is defined by the geometry of the four atoms involved. The problem specifies a quadruplet of atoms ordered as $$(\\text{peripheral }1,\\, \\text{center},\\, \\text{peripheral }2,\\, \\text{peripheral }3)$$, corresponding to position vectors $$\\mathbf{r}_{0}, \\mathbf{r}_{1}, \\mathbf{r}_{2}, \\mathbf{r}_{3}$$, respectively. The improper dihedral angle is the signed angle between the plane defined by atoms $$(\\mathbf{r}_{0}, \\mathbf{r}_{1}, \\mathbf{r}_{2})$$ and the plane defined by atoms $$(\\mathbf{r}_{1}, \\mathbf{r}_{2}, \\mathbf{r}_{3})$$.\n\nThe calculation proceeds as follows:\n1.  Define the three vectors that connect the four atoms:\n    $$ \\mathbf{b}_{0} = \\mathbf{r}_{1} - \\mathbf{r}_{0} $$\n    $$ \\mathbf{b}_{1} = \\mathbf{r}_{2} - \\mathbf{r}_{1} $$\n    $$ \\mathbf{b}_{2} = \\mathbf{r}_{3} - \\mathbf{r}_{2} $$\n\n2.  Compute the normal vectors to the two planes using the cross product. The first plane is spanned by $$\\mathbf{b}_{0}$$ and $$\\mathbf{b}_{1}$$, and the second plane is spanned by $$\\mathbf{b}_{1}$$ and $$\\mathbf{b}_{2}$$.\n    $$ \\mathbf{n}_{0} = \\mathbf{b}_{0} \\times \\mathbf{b}_{1} $$\n    $$ \\mathbf{n}_{1} = \\mathbf{b}_{1} \\times \\mathbf{b}_{2} $$\n\n3.  The angle $$\\phi_{0}$$ between these two planes is determined using the `atan2` function, which correctly handles the quadrant and yields a result in the range $$(-\\pi, \\pi]$$. The arguments to `atan2`, denoted as $$y$$ and $$x$$, are calculated according to the specified convention:\n    $$ x = \\mathbf{n}_{0} \\cdot \\mathbf{n}_{1} $$\n    $$ y = \\lVert \\mathbf{b}_{1} \\rVert (\\mathbf{b}_{0} \\cdot \\mathbf{n}_{1}) $$\n    The term involving $$\\lVert \\mathbf{b}_{1} \\rVert$$ and the scalar triple product $$\\mathbf{b}_{0} \\cdot (\\mathbf{b}_{1} \\times \\mathbf{b}_{2})$$ gives the correct sign for the angle.\n\n4.  The equilibrium improper angle is then:\n    $$ \\phi_{0} = \\mathrm{atan2}(y, x) $$\n\n**Step 2: Derivation of the Minimal Force Constant ($$k$$)**\n\nThe problem states that for a harmonic potential, the distribution of the angle $$\\phi$$ at a temperature $$T$$ is Gaussian, with a mean equal to the equilibrium angle $$\\phi_{0}$$ and a variance $$\\sigma^2 = \\frac{R T}{k}$$, where $$R$$ is the universal gas constant.\n\nThe chiral inversion occurs when $$\\phi$$ crosses the boundary at $$\\phi = 0$$. For a distribution centered at $$\\phi_{0}$$, this requires a fluctuation of magnitude at least $$|\\phi_{0}|$$. The probability $$p$$ of such an event is given by the one-sided tail probability of the Gaussian distribution:\n$$ p = \\frac{1}{2} \\mathrm{erfc}\\left( \\frac{|\\phi_{0}|}{\\sqrt{2} \\sigma} \\right) $$\nwhere $$\\mathrm{erfc}$$ is the complementary error function.\n\nSubstituting the expression for $$\\sigma$$ with $$T = T_{\\mathrm{high}}$$:\n$$ p = \\frac{1}{2} \\mathrm{erfc}\\left( \\frac{|\\phi_{0}|}{\\sqrt{2} \\sqrt{R T_{\\mathrm{high}} / k}} \\right) = \\frac{1}{2} \\mathrm{erfc}\\left( |\\phi_{0}| \\sqrt{\\frac{k}{2 R T_{\\mathrm{high}}}} \\right) $$\n\nThe design objective is to find the smallest $$k$$ that satisfies the constraint $$p \\le p_{\\max}$$. Since $$\\mathrm{erfc}(z)$$ is a monotonically decreasing function for non-negative $$z$$, the probability $$p$$ decreases as $$k$$ increases. To find the minimal $$k$$, we set the probability $$p$$ equal to its maximum allowed value, $$p_{\\max}$$.\n$$ p_{\\max} = \\frac{1}{2} \\mathrm{erfc}\\left( |\\phi_{0}| \\sqrt{\\frac{k}{2 R T_{\\mathrm{high}}}} \\right) $$\n\nWe now solve this equation for $$k$$:\n1.  Multiply by $$2$$:\n    $$ 2 p_{\\max} = \\mathrm{erfc}\\left( |\\phi_{0}| \\sqrt{\\frac{k}{2 R T_{\\mathrm{high}}}} \\right) $$\n2.  Apply the inverse complementary error function, $$\\mathrm{erfcinv}$$, to both sides:\n    $$ \\mathrm{erfcinv}(2 p_{\\max}) = |\\phi_{0}| \\sqrt{\\frac{k}{2 R T_{\\mathrm{high}}}} $$\n3.  Square both sides to eliminate the square root:\n    $$ \\left[ \\mathrm{erfcinv}(2 p_{\\max}) \\right]^2 = \\phi_{0}^2 \\left( \\frac{k}{2 R T_{\\mathrm{high}}} \\right) $$\n4.  Finally, isolate $$k$$:\n    $$ k = \\frac{2 R T_{\\mathrm{high}} \\left[ \\mathrm{erfcinv}(2 p_{\\max}) \\right]^2}{\\phi_{0}^2} $$\n\nThis equation provides the minimal force constant $$k$$ in units of kilojoule per mole per radian squared, using the given value $$R = 8.31446261815324 \\times 10^{-3} \\text{ kJ mol}^{-1} \\text{ K}^{-1}$$.\n\n**Summary of the Algorithm for Each Test Case:**\n1.  Given the four atomic coordinate vectors, $$T_{\\mathrm{high}}$$, and $$p_{\\max}$$.\n2.  Calculate the vectors $$\\mathbf{b}_{0}, \\mathbf{b}_{1}, \\mathbf{b}_{2}$$ and normals $$\\mathbf{n}_{0}, \\mathbf{n}_{1}$$.\n3.  Compute $$\\phi_{0}$$ using the `atan2` formula.\n4.  Compute $$k$$ using the derived formula involving $$\\mathrm{erfcinv}$$.\n5.  As a verification step, calculate the achieved probability $$p$$ using the computed $$k$$ and the formula for the Gaussian tail probability. This value should be equal to $$p_{\\max}$$ within floating-point precision.\n6.  Report the values of $$k$$, $$\\phi_{0}$$, and $$p$$, each rounded to $$6$$ decimal places.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erfcinv, erfc\n\ndef solve():\n    \"\"\"\n    Calculates the minimal harmonic force constant for an improper torsion restraint\n    to suppress chiral inversion in molecular dynamics simulations.\n    \"\"\"\n    # Universal gas constant in kJ/(mol·K)\n    R = 8.31446261815324e-3\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"coords\": np.array([\n                [1.0, 0.0, 0.0],\n                [0.1, 0.2, 0.0],\n                [0.0, 1.0, 0.0],\n                [0.0, 0.2, 0.9]\n            ]),\n            \"T_high\": 600.0,\n            \"p_max\": 1.0e-6\n        },\n        {\n            \"coords\": np.array([\n                [1.0, 0.0, 0.0],\n                [0.1, 0.2, 0.0],\n                [0.0, 1.0, 0.0],\n                [0.0, 0.2, -0.9]\n            ]),\n            \"T_high\": 600.0,\n            \"p_max\": 1.0e-8\n        },\n        {\n            \"coords\": np.array([\n                [1.0, 0.0, 0.0],\n                [0.1, 0.2, 0.0],\n                [0.0, 1.0, 0.0],\n                [0.0, 0.2, 0.02]\n            ]),\n            \"T_high\": 800.0,\n            \"p_max\": 1.0e-4\n        },\n        {\n            \"coords\": np.array([\n                [1.5, -0.2, 0.0],\n                [0.0, 0.0, 0.0],\n                [0.0, 1.2, 0.0],\n                [-0.1, 0.1, 1.0]\n            ]),\n            \"T_high\": 1200.0,\n            \"p_max\": 1.0e-6\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        coords = case[\"coords\"]\n        T_high = case[\"T_high\"]\n        p_max = case[\"p_max\"]\n\n        # Step 1: Calculate the equilibrium improper angle (phi_0)\n        r0, r1, r2, r3 = coords[0], coords[1], coords[2], coords[3]\n        \n        b0 = r1 - r0\n        b1 = r2 - r1\n        b2 = r3 - r2\n\n        n0 = np.cross(b0, b1)\n        n1 = np.cross(b1, b2)\n\n        x = np.dot(n0, n1)\n        y = np.linalg.norm(b1) * np.dot(b0, n1)\n        \n        phi0 = np.arctan2(y, x)\n\n        # Step 2: Calculate the minimal force constant (k)\n        # Handle the case of a perfectly planar structure, though not expected\n        # in these test cases. If phi0 is zero, any finite k results in p=0.5.\n        if np.isclose(phi0, 0.0):\n            # This case is ill-defined for p_max < 0.5.\n            # We can assign infinity or NaN, but based on test data, this path isn't taken.\n            k = np.inf\n        else:\n            # Z = erfcinv(2 * p_max)\n            Z = erfcinv(2.0 * p_max)\n            # k = (2 * R * T_high * Z^2) / phi0^2\n            k = (2.0 * R * T_high * Z**2) / (phi0**2)\n\n        # Step 3: Verify the achieved probability (p) with the calculated k\n        # sigma = sqrt(R * T_high / k)\n        sigma = np.sqrt(R * T_high / k)\n        # p = 0.5 * erfc(|phi0| / (sqrt(2) * sigma))\n        p_achieved = 0.5 * erfc(np.abs(phi0) / (np.sqrt(2.0) * sigma))\n        \n        results.append([k, phi0, p_achieved])\n\n    # Final print statement in the exact required format.\n    # Format: [[k1,phi0_1,p1],[k2,phi0_2,p2],...]\n    formatted_results = []\n    for res in results:\n        # Round every floating-point number to exactly 6 decimal places.\n        k_str = f\"{res[0]:.6f}\"\n        phi0_str = f\"{res[1]:.6f}\"\n        p_str = f\"{res[2]:.6f}\"\n        formatted_results.append(f\"[{k_str},{phi0_str},{p_str}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3400183"}]}