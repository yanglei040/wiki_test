{"hands_on_practices": [{"introduction": "Constraints in molecular dynamics are not merely mathematical conveniences; they represent real physical forces that contribute to the system's macroscopic properties. This foundational exercise guides you through the derivation of the constraint contribution to the virial, linking the microscopic Lagrange multipliers to the system's pressure ([@problem_id:3421524]). Mastering this derivation is essential for understanding how to correctly compute thermodynamic observables in any simulation that employs bond constraints.", "problem": "Consider a system of $N$ atoms in a constant-temperature Molecular Dynamics (MD) simulation at temperature $T$ and volume $V$, subject to $M$ holonomic distance constraints that are enforced using the LINear Constraint Solver (LINCS) algorithm. Each constraint $\\alpha \\in \\{1,\\dots,M\\}$ fixes the distance between a specific atom pair $(a_{\\alpha}, b_{\\alpha})$ to a prescribed value $d_{\\alpha}$ via the constraint function\n$$\ng_{\\alpha}(\\mathbf{r}) = |\\mathbf{r}_{a_{\\alpha}} - \\mathbf{r}_{b_{\\alpha}}| - d_{\\alpha} = 0,\n$$\nwhere $\\mathbf{r}_{i}$ is the position vector of atom $i$. Assume a standard formulation with Lagrange multipliers $\\lambda_{\\alpha}$ yielding constraint forces\n$$\n\\mathbf{f}_{c,i} = \\sum_{\\alpha=1}^{M} \\lambda_{\\alpha} \\nabla_{\\mathbf{r}_{i}} g_{\\alpha}.\n$$\nThe total force on atom $i$ is $\\mathbf{f}_{i} = \\mathbf{f}_{nb,i} + \\mathbf{f}_{c,i}$, where $\\mathbf{f}_{nb,i}$ arises from nonbonded interactions. Assume no external fields and that periodic boundary conditions eliminate surface terms, so the standard virial theorem applies.\n\nStarting from Newton’s second law and the virial definition, derive the closed-form expression for the contribution of the constraint forces to the virial and then write the pressure as a single analytic expression that includes both the kinetic term and the full virial with constraints. Your final expression should be in terms of $N$, $k_{B}$ (Boltzmann’s constant), $T$, $V$, the nonbonded virial\n$$\nW_{nb} = \\sum_{i=1}^{N} \\mathbf{r}_{i} \\cdot \\mathbf{f}_{nb,i},\n$$\nand the constraint parameters $\\{\\lambda_{\\alpha}, d_{\\alpha}\\}_{\\alpha=1}^{M}$. Express the pressure in Pascals. The final answer must be a single closed-form analytic expression, not an equation to be solved.", "solution": "The user wants me to solve a problem. As a meticulous professor, I must first validate the problem statement.\n\n**Step 1: Extract Givens**\n- A system of $N$ atoms in a constant-temperature Molecular Dynamics (MD) simulation.\n- Temperature: $T$.\n- Volume: $V$.\n- Number of holonomic distance constraints: $M$.\n- Constraint algorithm: LINCS.\n- Constraint function $\\alpha$: $g_{\\alpha}(\\mathbf{r}) = |\\mathbf{r}_{a_{\\alpha}} - \\mathbf{r}_{b_{\\alpha}}| - d_{\\alpha} = 0$.\n- Particle position vector: $\\mathbf{r}_{i}$.\n- Lagrange multipliers: $\\lambda_{\\alpha}$.\n- Constraint forces: $\\mathbf{f}_{c,i} = \\sum_{\\alpha=1}^{M} \\lambda_{\\alpha} \\nabla_{\\mathbf{r}_{i}} g_{\\alpha}$.\n- Total force on atom $i$: $\\mathbf{f}_{i} = \\mathbf{f}_{nb,i} + \\mathbf{f}_{c,i}$.\n- Nonbonded virial: $W_{nb} = \\sum_{i=1}^{N} \\mathbf{r}_{i} \\cdot \\mathbf{f}_{nb,i}$.\n- Conditions: No external fields, periodic boundary conditions, standard virial theorem applies.\n- Task 1: Derive the closed-form expression for the contribution of the constraint forces to the virial.\n- Task 2: Write the pressure $P$ as a single analytic expression in terms of $N, k_{B}, T, V, W_{nb}, \\{\\lambda_{\\alpha}, d_{\\alpha}\\}_{\\alpha=1}^{M}$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded, well-posed, and objective. It describes a standard scenario in computational chemistry and statistical physics. The definitions of constraint forces via Lagrange multipliers, the virial, and the pressure equation of state are all standard. The problem is self-contained and provides all necessary information to perform the requested derivation. No scientific flaws, contradictions, or ambiguities are present.\n\n**Verdict:** The problem is valid.\n\n**Solution Derivation:**\n\nThe pressure $P$ of a system in a volume $V$ at temperature $T$ can be calculated using the virial equation of state. For a system of $N$ particles, this is commonly expressed in molecular dynamics as:\n$$\nP V = N k_{B} T + \\frac{1}{3} \\langle W \\rangle\n$$\nwhere $k_{B}$ is the Boltzmann constant, and $\\langle W \\rangle$ is the time-averaged total internal virial. In the context of an instantaneous configuration from an MD trajectory, we can write the instantaneous pressure using the instantaneous virial $W$:\n$$\nP = \\frac{N k_{B} T}{V} + \\frac{W}{3V}\n$$\nThe total virial $W$ is defined as the sum over all particles $i$ of the dot product of the particle's position vector $\\mathbf{r}_{i}$ and the total force $\\mathbf{f}_{i}$ acting on it:\n$$\nW = \\sum_{i=1}^{N} \\mathbf{r}_{i} \\cdot \\mathbf{f}_{i}\n$$\nThe total force $\\mathbf{f}_{i}$ is given as the sum of nonbonded forces $\\mathbf{f}_{nb,i}$ and constraint forces $\\mathbf{f}_{c,i}$. Therefore, the total virial can be decomposed into two corresponding parts:\n$$\nW = \\sum_{i=1}^{N} \\mathbf{r}_{i} \\cdot (\\mathbf{f}_{nb,i} + \\mathbf{f}_{c,i}) = \\sum_{i=1}^{N} \\mathbf{r}_{i} \\cdot \\mathbf{f}_{nb,i} + \\sum_{i=1}^{N} \\mathbf{r}_{i} \\cdot \\mathbf{f}_{c,i}\n$$\nThe first term is given in the problem statement as the nonbonded virial, $W_{nb}$. The second term is the contribution from the constraint forces, which we will denote as $W_{c}$:\n$$\nW_{c} = \\sum_{i=1}^{N} \\mathbf{r}_{i} \\cdot \\mathbf{f}_{c,i}\n$$\nOur first task is to derive a closed-form expression for $W_{c}$. We substitute the given expression for the constraint force $\\mathbf{f}_{c,i}$:\n$$\nW_{c} = \\sum_{i=1}^{N} \\mathbf{r}_{i} \\cdot \\left( \\sum_{\\alpha=1}^{M} \\lambda_{\\alpha} \\nabla_{\\mathbf{r}_{i}} g_{\\alpha} \\right)\n$$\nBy swapping the order of the summations, we can group terms by constraint $\\alpha$:\n$$\nW_{c} = \\sum_{\\alpha=1}^{M} \\lambda_{\\alpha} \\left( \\sum_{i=1}^{N} \\mathbf{r}_{i} \\cdot \\nabla_{\\mathbf{r}_{i}} g_{\\alpha} \\right)\n$$\nNow we must evaluate the inner sum for a single constraint $\\alpha$. The constraint function $g_{\\alpha}$ is:\n$$\ng_{\\alpha}(\\mathbf{r}) = |\\mathbf{r}_{a_{\\alpha}} - \\mathbf{r}_{b_{\\alpha}}| - d_{\\alpha}\n$$\nThe gradient $\\nabla_{\\mathbf{r}_{i}} g_{\\alpha}$ is non-zero only for the two atoms involved in the constraint, i.e., when $i=a_{\\alpha}$ or $i=b_{\\alpha}$. Let $\\mathbf{r}_{ab} = \\mathbf{r}_{a_{\\alpha}} - \\mathbf{r}_{b_{\\alpha}}$ and let $\\mathbf{u}_{ab} = \\mathbf{r}_{ab} / |\\mathbf{r}_{ab}|$ be the unit vector along the bond. The gradients are:\n$$\n\\nabla_{\\mathbf{r}_{a_{\\alpha}}} g_{\\alpha} = \\mathbf{u}_{ab}\n$$\n$$\n\\nabla_{\\mathbf{r}_{b_{\\alpha}}} g_{\\alpha} = -\\mathbf{u}_{ab}\n$$\nThe inner sum in the expression for $W_{c}$ thus reduces to just two terms:\n$$\n\\sum_{i=1}^{N} \\mathbf{r}_{i} \\cdot \\nabla_{\\mathbf{r}_{i}} g_{\\alpha} = \\mathbf{r}_{a_{\\alpha}} \\cdot (\\nabla_{\\mathbf{r}_{a_{\\alpha}}} g_{\\alpha}) + \\mathbf{r}_{b_{\\alpha}} \\cdot (\\nabla_{\\mathbf{r}_{b_{\\alpha}}} g_{\\alpha})\n$$\nSubstituting the calculated gradients:\n$$\n= \\mathbf{r}_{a_{\\alpha}} \\cdot \\mathbf{u}_{ab} + \\mathbf{r}_{b_{\\alpha}} \\cdot (-\\mathbf{u}_{ab}) = (\\mathbf{r}_{a_{\\alpha}} - \\mathbf{r}_{b_{\\alpha}}) \\cdot \\mathbf{u}_{ab}\n$$\nSubstituting the definition of the unit vector $\\mathbf{u}_{ab}$:\n$$\n= \\mathbf{r}_{ab} \\cdot \\frac{\\mathbf{r}_{ab}}{|\\mathbf{r}_{ab}|} = \\frac{|\\mathbf{r}_{ab}|^2}{|\\mathbf{r}_{ab}|} = |\\mathbf{r}_{ab}|\n$$\nAccording to the constraint equation, $g_{\\alpha}=0$, which implies that the distance between the atoms is fixed to its prescribed value: $|\\mathbf{r}_{a_{\\alpha}} - \\mathbf{r}_{b_{\\alpha}}| = d_{\\alpha}$.\nTherefore, the inner sum simplifies to:\n$$\n\\sum_{i=1}^{N} \\mathbf{r}_{i} \\cdot \\nabla_{\\mathbf{r}_{i}} g_{\\alpha} = d_{\\alpha}\n$$\nNow we substitute this result back into the expression for the constraint virial $W_{c}$:\n$$\nW_{c} = \\sum_{\\alpha=1}^{M} \\lambda_{\\alpha} d_{\\alpha}\n$$\nThis is the closed-form expression for the contribution of the constraint forces to the virial.\n\nThe final step is to assemble the complete expression for the pressure $P$. The total virial is $W = W_{nb} + W_{c}$. Substituting the derived expression for $W_{c}$:\n$$\nW = W_{nb} + \\sum_{\\alpha=1}^{M} \\lambda_{\\alpha} d_{\\alpha}\n$$\nPlugging this total virial into the pressure equation:\n$$\nP = \\frac{N k_{B} T}{V} + \\frac{1}{3V} \\left( W_{nb} + \\sum_{\\alpha=1}^{M} \\lambda_{\\alpha} d_{\\alpha} \\right)\n$$\nThis is the final expression for the pressure. If all quantities are given in SI units ($N$ is dimensionless, $k_B$ in $\\text{J/K}$, $T$ in $\\text{K}$, $V$ in $\\text{m}^3$, $W_{nb}$ in $\\text{J}$, $\\lambda_{\\alpha}$ in $\\text{N}$, $d_{\\alpha}$ in $\\text{m}$), the resulting pressure $P$ will be in Pascals ($\\text{N/m}^2$ or $\\text{J/m}^3$), as requested.", "answer": "$$\n\\boxed{\\frac{N k_{B} T}{V} + \\frac{1}{3V} \\left( W_{nb} + \\sum_{\\alpha=1}^{M} \\lambda_{\\alpha} d_{\\alpha} \\right)}\n$$", "id": "3421524"}, {"introduction": "While the LINCS algorithm is highly efficient, its stability depends on the invertibility of the constraint coupling matrix, which is approximated using a series expansion. This hands-on practice explores a critical failure mode that arises from geometric singularities, where near-linear dependencies among constraints can cause the approximation to diverge ([@problem_id:3421489]). By constructing a problematic molecular geometry, you will numerically investigate the stability condition and pinpoint the origin of the algorithm's breakdown.", "problem": "You are to analyze the stability of the Linear Constraint Solver (LINCS) constraint projection in molecular dynamics by constructing a small molecular geometry that deliberately introduces nearly dependent constraint rows. Begin from fundamental principles of classical mechanics and holonomic constraints, and derive the algebraic objects needed to evaluate the stability of the LINCS fixed-point correction based on a Neumann series. Then implement and execute the derived formulas for a parametric family of geometries that approaches a singular configuration.\n\nConsider a system of $N=4$ point masses with equal mass $m$ in three-dimensional space. Let the positions be $\\mathbf{r}_i \\in \\mathbb{R}^3$ for $i \\in \\{1,2,3,4\\}$. We prescribe the parametric geometry\n$$\n\\mathbf{r}_1 = (0,0,0),\\quad\n\\mathbf{r}_2 = (1,\\varepsilon,0),\\quad\n\\mathbf{r}_3 = (2,0,0),\\quad\n\\mathbf{r}_4 = (3,\\varepsilon,0),\n$$\nwith parameter $\\varepsilon \\ge 0$. This creates a nearly colinear chain for small $\\varepsilon$. Impose $K=5$ fixed bond-length constraints corresponding to the pairs\n$$\n(1,2),\\ (2,3),\\ (3,4),\\ (1,3),\\ (2,4),\n$$\ninterpreted as holonomic constraints of the form $g_k(\\mathbf{q}) = 0$ where $g_k(\\mathbf{q})$ enforces a fixed squared distance between atom pairs, i.e., for $(i,j)$ the constraint is $g_{ij}(\\mathbf{q}) = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|^2 - d_{ij}^2=0$. Here $\\mathbf{q}$ stacks the Cartesian coordinates of all atoms, and $d_{ij}$ is the target bond length for pair $(i,j)$. Use the instantaneous geometry above to define the target distances $d_{ij}$, so that initially all constraints are exactly satisfied.\n\nStarting from Newton’s second law and holonomic constraints with Lagrange multipliers, and working with the linearization of $g_k(\\mathbf{q})=0$ in Cartesian coordinates, perform the following derivations and computations:\n\n1. Derive the constraint Jacobian $J \\in \\mathbb{R}^{K \\times 3N}$ whose $k$-th row is the gradient $\\nabla_{\\mathbf{q}} g_k(\\mathbf{q})$ evaluated at the given geometry. For a pair $(i,j)$, the nonzero blocks should reflect the dependence on $\\mathbf{r}_i$ and $\\mathbf{r}_j$. Use the squared-distance form so that the block gradients are proportional to $(\\mathbf{r}_i - \\mathbf{r}_j)$ and $(\\mathbf{r}_j - \\mathbf{r}_i)$, respectively.\n\n2. Introduce the diagonal mass matrix $M \\in \\mathbb{R}^{3N \\times 3N}$ with identical masses $m$ on the diagonal. From the linearized constraint impulse balance, identify the symmetric positive semidefinite matrix\n$$\nS_{\\mathrm{raw}} = J M^{-1} J^\\top \\in \\mathbb{R}^{K \\times K}.\n$$\n\n3. Normalize $S_{\\mathrm{raw}}$ to obtain a coupling matrix with unit diagonal. Define $D = \\mathrm{diag}(S_{\\mathrm{raw}})$ and construct\n$$\nS = D^{-1/2} S_{\\mathrm{raw}} D^{-1/2}.\n$$\nThis normalization yields a matrix $S$ with diagonal entries equal to $1$.\n\n4. Consider the fixed-point (Neumann series) approximation used in Linear Constraint Solver (LINCS), where an inverse of $S$ is approximated by a truncated series of the matrix\n$$\nC = I - S.\n$$\nFrom the Neumann series for $(I - C)^{-1}$, the convergence criterion requires the spectral radius $\\rho(C) < 1$. Using this principle, define a stability metric as the spectral radius $\\rho(C)$.\n\n5. Implement a program that, for the mass choice $m=1$ (dimensionless), constructs the geometry for the parameter values $\\varepsilon \\in \\{0.2, 0.02, 0.0\\}$, forms $J$, builds $S_{\\mathrm{raw}}$, normalizes to $S$, computes $C=I-S$, and returns the spectral radius $\\rho(C)$ for each $\\varepsilon$.\n\n6. Scientific and numerical expectations: As $\\varepsilon \\to 0$, the constraints in the closed loop become nearly redundant and the rows of $J$ become nearly linearly dependent, making $S$ nearly singular. Accordingly, you should see $\\rho(C)$ approach or exceed $1$, signaling potential LINCS failure as the Neumann series ceases to converge.\n\nYour program must implement the above derivations precisely and output the results for the three parameter values. There are no physical units in this problem; treat all quantities as dimensionless numbers. The output must be a single line, containing a comma-separated list enclosed in square brackets. The list must be ordered as $[\\rho(C;\\varepsilon{=}0.2),\\rho(C;\\varepsilon{=}0.02),\\rho(C;\\varepsilon{=}0.0)]$, where each entry is a float rounded to exactly six digits after the decimal point. For example, an output line might look like $[0.123456,0.987654,1.234567]$.\n\nTest suite to cover different regimes:\n- A regular, well-conditioned geometry with $\\varepsilon=0.2$ (happy path).\n- A nearly singular geometry with $\\varepsilon=0.02$ (near failure).\n- An exactly colinear geometry with $\\varepsilon=0.0$ (edge case with rank deficiency).\n\nYour program should produce a single line of output in the exact format described above.", "solution": "We construct the stability analysis for Linear Constraint Solver (LINCS) by starting from classical mechanics and holonomic constraints, then reducing to an algebraic condition on a coupling matrix.\n\nWe consider $N=4$ point masses with equal mass $m$. Let $\\mathbf{q} \\in \\mathbb{R}^{3N}$ be the Cartesian coordinates, stacking $\\mathbf{r}_1,\\dots,\\mathbf{r}_N$. We impose $K=5$ holonomic constraints of the form $g_k(\\mathbf{q})=0$, each being a fixed squared-distance for a pair $(i,j)$:\n$$\ng_{ij}(\\mathbf{q}) = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|^2 - d_{ij}^2.\n$$\nWe choose $d_{ij}$ equal to the instantaneous distances at the constructed geometry so that initially $g_{ij}(\\mathbf{q})=0$. The gradient of $g_{ij}$ with respect to $\\mathbf{q}$ is concentrated on atoms $i$ and $j$:\n$$\n\\nabla_{\\mathbf{r}_i} g_{ij} = 2(\\mathbf{r}_i - \\mathbf{r}_j),\\quad\n\\nabla_{\\mathbf{r}_j} g_{ij} = 2(\\mathbf{r}_j - \\mathbf{r}_i),\\quad\n\\nabla_{\\mathbf{r}_k} g_{ij} = \\mathbf{0}\\ \\text{for}\\ k \\notin \\{i,j\\}.\n$$\nStacking these row gradients for all constraints yields the Jacobian $J \\in \\mathbb{R}^{K \\times 3N}$, where the $k$-th row is $\\nabla_{\\mathbf{q}} g_k(\\mathbf{q})^\\top$.\n\nFrom Newton’s second law with holonomic constraints, the constraint impulses enforce\n$$\nM \\Delta \\dot{\\mathbf{q}} = \\mathbf{f}\\Delta t + J^\\top \\boldsymbol{\\lambda},\\quad \\text{with}\\quad J \\Delta \\mathbf{q} = -\\mathbf{g},\n$$\nwhere $M \\in \\mathbb{R}^{3N \\times 3N}$ is the diagonal mass matrix, $\\boldsymbol{\\lambda} \\in \\mathbb{R}^{K}$ are Lagrange multipliers, and $\\mathbf{g}$ are current constraint values. Linearizing in time and eliminating $\\Delta \\mathbf{q}$ or $\\Delta \\dot{\\mathbf{q}}$ produces a symmetric system for $\\boldsymbol{\\lambda}$ involving $J M^{-1} J^\\top$. The core matrix is\n$$\nS_{\\mathrm{raw}} = J M^{-1} J^\\top \\in \\mathbb{R}^{K \\times K},\n$$\nwhich is symmetric positive semidefinite. If the constraint gradients are linearly independent, then $S_{\\mathrm{raw}}$ is symmetric positive definite.\n\nTo emulate the normalization inherent in Linear Constraint Solver (LINCS), we scale rows to unit mass-weighted norm. Let $D = \\mathrm{diag}(S_{\\mathrm{raw}})$ be the diagonal matrix containing the row-wise quadratic forms, and define the normalized coupling matrix\n$$\nS = D^{-1/2} S_{\\mathrm{raw}} D^{-1/2}.\n$$\nBy construction, $S$ has unit diagonal entries, i.e., $S_{kk} = 1$ for all $k$. In this representation, the off-diagonal elements measure pairwise couplings among constraints.\n\nThe Linear Constraint Solver (LINCS) approximates $S^{-1}$ via a truncated Neumann series. Let\n$$\nC = I - S.\n$$\nIf the spectral radius $\\rho(C) < 1$, then the Neumann series converges and\n$$\nS^{-1} = (I - C)^{-1} = \\sum_{\\ell=0}^{\\infty} C^\\ell,\n$$\nwith truncation at order $p$ producing an error bounded in a consistent operator norm by\n$$\n\\left\\| \\sum_{\\ell=p+1}^{\\infty} C^\\ell \\right\\| \\le \\frac{\\|C\\|^{p+1}}{1 - \\|C\\|},\\quad \\text{valid when}\\ \\|C\\|<1.\n$$\nThus, the key stability metric is $\\rho(C)$: if $\\rho(C) \\ge 1$, the series does not converge and LINCS fails in principle; if $\\rho(C)$ is close to $1$, truncation errors become large.\n\nWe now construct the parametric geometry to approach rank deficiency. Place atoms at\n$$\n\\mathbf{r}_1 = (0,0,0),\\ \n\\mathbf{r}_2 = (1,\\varepsilon,0),\\ \n\\mathbf{r}_3 = (2,0,0),\\ \n\\mathbf{r}_4 = (3,\\varepsilon,0),\n$$\nwith $\\varepsilon \\in \\{0.2, 0.02, 0.0\\}$. The constraints form a loop:\n$$\n(1,2),\\ (2,3),\\ (3,4),\\ (1,3),\\ (2,4).\n$$\nWhen $\\varepsilon \\to 0$, all four atoms lie on a straight line. In that limit, the constraint gradients become nearly colinear combinations around the loop. More precisely, consider the row vectors of $J$ corresponding to these constraints; the loop closure introduces a near-linear dependence among these rows in the colinear geometry. Consequently, $S_{\\mathrm{raw}}$ becomes nearly singular, and since $S$ is the normalized version of $S_{\\mathrm{raw}}$, the smallest eigenvalue of $S$ tends to $0$. The eigenvalues of $C = I - S$ are $1 - \\lambda_i(S)$. Hence, as the smallest $\\lambda_i(S) \\to 0$, there is an eigenvalue of $C$ approaching $1$, so $\\rho(C) \\to 1$ or can exceed $1$ if some $\\lambda_i(S) > 2$. This reflects the loss of convergence of the Neumann series and the practical failure of LINCS near singular geometries.\n\nImplementation details for the computation:\n- Set $m=1$, so that $M = I$ and $S_{\\mathrm{raw}} = J J^\\top$.\n- Construct $J$ by placing, for each constraint $(i,j)$,\n$$\n\\text{row}_{ij}[\\mathbf{r}_i] = 2(\\mathbf{r}_i - \\mathbf{r}_j),\\quad\n\\text{row}_{ij}[\\mathbf{r}_j] = 2(\\mathbf{r}_j - \\mathbf{r}_i),\\quad\n\\text{zeros elsewhere}.\n$$\n- Form $S_{\\mathrm{raw}}$, compute $D$ and $S$, then $C = I - S$.\n- Compute $\\rho(C)$ as the maximum absolute value among eigenvalues of $C$.\n- Report the three values $\\rho(C;\\varepsilon)$ for $\\varepsilon \\in \\{0.2, 0.02, 0.0\\}$ in the required format, rounding each to $6$ digits after the decimal point.\n\nQualitative results:\n- For $\\varepsilon = 0.2$, the geometry is well-conditioned; we expect $\\rho(C)$ significantly less than $1$.\n- For $\\varepsilon = 0.02$, the geometry is nearly singular; we expect $\\rho(C)$ close to $1$.\n- For $\\varepsilon = 0.0$, the geometry is exactly colinear; we expect at least one eigenvalue of $S$ to be zero, hence an eigenvalue of $C$ equal to $1$, making $\\rho(C) \\ge 1$ and indicating failure.\n\nThe provided program constructs the matrices and computes the spectral radii accordingly, producing the requested single-line output with three floats rounded to six decimal places.", "answer": "```python\nimport numpy as np\n\ndef build_geometry(epsilon: float):\n    # Four atoms with small zig-zag in y to control near-colinearity\n    r1 = np.array([0.0, 0.0, 0.0])\n    r2 = np.array([1.0, epsilon, 0.0])\n    r3 = np.array([2.0, 0.0, 0.0])\n    r4 = np.array([3.0, epsilon, 0.0])\n    R = np.vstack([r1, r2, r3, r4])  # shape (4,3)\n    return R\n\ndef constraints_pairs():\n    # Pairs: (1,2),(2,3),(3,4),(1,3),(2,4) using 0-based indexing\n    return [(0,1),(1,2),(2,3),(0,2),(1,3)]\n\ndef build_J(R: np.ndarray, pairs):\n    N = R.shape[0]\n    K = len(pairs)\n    J = np.zeros((K, 3*N), dtype=float)\n    for k, (i, j) in enumerate(pairs):\n        rij = R[i] - R[j]\n        # Gradient for squared-distance constraint: 2*(ri - rj) and 2*(rj - ri)\n        gi = 2.0 * rij\n        gj = -2.0 * rij\n        # Place into row k at blocks for atoms i and j\n        J[k, 3*i:3*i+3] = gi\n        J[k, 3*j:3*j+3] = gj\n    return J\n\ndef normalized_S(J: np.ndarray, mass: float = 1.0):\n    # M = m * I, so M^{-1} = (1/m) * I; thus S_raw = (1/m) * J J^T\n    S_raw = (J @ J.T) / mass\n    # Normalize to unit diagonal: S = D^{-1/2} S_raw D^{-1/2}\n    d = np.diag(S_raw).copy()\n    # Guard against numerical zeros on diagonal (should not occur since rows nonzero)\n    d_sqrt_inv = 1.0 / np.sqrt(d)\n    D_half_inv = np.diag(d_sqrt_inv)\n    S = D_half_inv @ S_raw @ D_half_inv\n    return S\n\ndef spectral_radius_C(S: np.ndarray):\n    # C = I - S; compute spectral radius of C (max abs eigenvalue)\n    K = S.shape[0]\n    C = np.eye(K) - S\n    # Use eigh for symmetric matrix to improve numerical stability\n    evals = np.linalg.eigvalsh(C)\n    rho = float(np.max(np.abs(evals)))\n    return rho\n\ndef compute_rho_for_epsilon(epsilon: float):\n    R = build_geometry(epsilon)\n    pairs = constraints_pairs()\n    J = build_J(R, pairs)\n    S = normalized_S(J, mass=1.0)\n    rho = spectral_radius_C(S)\n    return rho\n\ndef solve():\n    test_cases = [0.2, 0.02, 0.0]\n    results = []\n    for eps in test_cases:\n        rho = compute_rho_for_epsilon(eps)\n        results.append(rho)\n    # Format with exactly six digits after decimal, no spaces\n    out = \"[\" + \",\".join(f\"{x:.6f}\" for x in results) + \"]\"\n    print(out)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3421489"}, {"introduction": "Beyond geometric singularities, a second common challenge for LINCS stability arises from systems with large mass ratios, such as light hydrogen atoms bonded to heavy atoms. This exercise demonstrates how extreme mass differences can lead to a poorly conditioned coupling matrix, jeopardizing the convergence of the algorithm ([@problem_id:3421519]). You will not only analyze the problem but also implement a practical mass-scaling strategy, a robust technique used in modern simulation software to ensure numerical stability without altering the system's dynamics.", "problem": "Consider a system of point particles with positions $\\mathbf{q} \\in \\mathbb{R}^{3N}$ and masses $m_i > 0$ for $i \\in \\{1,\\dots,N\\}$, evolving under Newton's Second Law with holonomic bond-length constraints $g_k(\\mathbf{q}) = \\|\\mathbf{r}_{a(k)} - \\mathbf{r}_{b(k)}\\| - \\ell_k = 0$ for $k \\in \\{1,\\dots,n_c\\}$, where $a(k), b(k) \\in \\{1,\\dots,N\\}$ are atom indices, $\\mathbf{r}_i \\in \\mathbb{R}^3$ is the position of atom $i$, and $\\ell_k > 0$ is the target bond length for constraint $k$. Let $G(\\mathbf{q}) \\in \\mathbb{R}^{n_c \\times 3N}$ be the Jacobian of the constraints with respect to $\\mathbf{q}$, and let $M \\in \\mathbb{R}^{3N \\times 3N}$ be the diagonal mass matrix, $M = \\mathrm{diag}(m_1 I_3, \\dots, m_N I_3)$. The mass-weighted constraint coupling matrix is defined as $C(\\mathbf{q}, M) = G(\\mathbf{q}) M^{-1} G(\\mathbf{q})^\\top \\in \\mathbb{R}^{n_c \\times n_c}$. Define the strictly off-diagonal, symmetrically normalized coupling matrix $S \\in \\mathbb{R}^{n_c \\times n_c}$ by\n$$\nS_{ij} =\n\\begin{cases}\n\\displaystyle \\frac{C_{ij}}{\\sqrt{C_{ii}\\, C_{jj}}}, & i \\neq j, \\\\\n0, & i = j.\n\\end{cases}\n$$\nThe Linear Constraint Solver (LINCS) algorithm for constrained Molecular Dynamics uses a truncated Neumann series to approximate the inverse of a preconditioned system whose convergence and stability are governed by the spectral radius $\\rho(S)$.\n\nTask: Starting from the definitions above, analyze the effect of extreme mass ratios (e.g., a light atom attached to heavy neighbors such that $m_{\\mathrm{light}}/m_{\\mathrm{heavy}} \\to 0$) on the entries of $S$ and its spectral radius $\\rho(S)$. Based on this analysis, propose and implement a robust mass-scaling strategy that modifies a subset of the masses to keep $\\rho(S)$ bounded by a prescribed target $\\rho_{\\mathrm{target}} \\in (0,1)$. Your strategy must:\n- Derive from first principles why increasing the mass of atoms shared by multiple constraints reduces the magnitude of off-diagonal entries in $S$ and monotonically decreases $\\rho(S)$.\n- Use only the geometric information in $G(\\mathbf{q})$ and the diagonal mass structure of $M$.\n- Be constructive and numerically implementable: for a given $\\rho_{\\mathrm{target}}$, return a set of scaled masses $\\tilde{m}_i \\ge m_i$ for a selected subset of atoms that ensures $\\rho(S(\\tilde{M})) \\le \\rho_{\\mathrm{target}}$, where $\\tilde{M} = \\mathrm{diag}(\\tilde{m}_1 I_3,\\dots,\\tilde{m}_N I_3)$.\n\nImplementation details to be followed by your program:\n1. Construct $G(\\mathbf{q})$ by assembling, for each constraint $k$ with bond between atoms $a$ and $b$, a row with the $3$-vector block at columns corresponding to atom $a$ equal to $(\\mathbf{r}_a - \\mathbf{r}_b)/\\|\\mathbf{r}_a - \\mathbf{r}_b\\|$, the block at atom $b$ equal to $(\\mathbf{r}_b - \\mathbf{r}_a)/\\|\\mathbf{r}_a - \\mathbf{r}_b\\|$, and zeros elsewhere.\n2. Form $C = G M^{-1} G^\\top$ and then $S$ as above. Compute $\\rho(S)$ as the largest absolute eigenvalue of $S$.\n3. Propose a robust mass-scaling strategy that targets atoms incident to at least two constraints and increases their masses uniformly to a floor value $\\mu$ (leaving other masses unchanged), i.e., $\\tilde{m}_i = \\max\\{m_i, \\mu\\}$ for those atoms, with $\\mu$ chosen minimally to ensure $\\rho(S(\\tilde{M})) \\le \\rho_{\\mathrm{target}}$. Your program should determine $\\mu$ via a numerically stable one-dimensional search and output the resulting before/after spectral radii.\n\nScientific assumptions and requirements:\n- Use only dimensionless quantities in the final results; no physical units are required.\n- Angles must implicitly be in radians if needed for construction of geometry; however, in this problem geometry is specified by Cartesian coordinates, so no explicit angle computations are required.\n- All numerical results must be computed in double precision.\n- Ensure all constructed configurations are physically plausible: all bond lengths must be strictly positive.\n\nTest suite to implement and evaluate:\nYour program must hard-code and evaluate the following four test cases, each specified by $(\\mathbf{q}, \\text{constraints}, m, \\rho_{\\mathrm{target}})$:\n\n- Case A (linear triatomic with light center): \n  - Atoms $N = 3$ with positions $\\mathbf{r}_1 = (0,0,0)$, $\\mathbf{r}_2 = (1,0,0)$, $\\mathbf{r}_3 = (2,0,0)$.\n  - Constraints: bonds $(1,2)$ and $(2,3)$.\n  - Masses: $m = [12.0, 0.1, 12.0]$.\n  - Target: $\\rho_{\\mathrm{target}} = 0.8$.\n\n- Case B (right-angle triatomic, extreme light center):\n  - Positions $\\mathbf{r}_1 = (0,0,0)$, $\\mathbf{r}_2 = (1,0,0)$, $\\mathbf{r}_3 = (1,1,0)$.\n  - Constraints: bonds $(1,2)$ and $(2,3)$.\n  - Masses: $m = [12.0, 0.001, 12.0]$.\n  - Target: $\\rho_{\\mathrm{target}} = 0.8$.\n\n- Case C (linear four-atom chain with two light interior atoms):\n  - Positions $\\mathbf{r}_1 = (0,0,0)$, $\\mathbf{r}_2 = (1,0,0)$, $\\mathbf{r}_3 = (2,0,0)$, $\\mathbf{r}_4 = (3,0,0)$.\n  - Constraints: bonds $(1,2)$, $(2,3)$, $(3,4)$.\n  - Masses: $m = [12.0, 0.1, 0.1, 12.0]$.\n  - Target: $\\rho_{\\mathrm{target}} = 0.8$.\n\n- Case D (bent triatomic with obtuse angle $\\approx 150^\\circ$ at the center, light center):\n  - Positions $\\mathbf{r}_1 = (0,0,0)$, $\\mathbf{r}_2 = (1,0,0)$, $\\mathbf{r}_3 = (1 + \\cos(30^\\circ), \\sin(30^\\circ), 0)$, i.e., $\\mathbf{r}_3 = (1 + \\sqrt{3}/2, 1/2, 0)$.\n  - Constraints: bonds $(1,2)$ and $(2,3)$.\n  - Masses: $m = [12.0, 0.05, 12.0]$.\n  - Target: $\\rho_{\\mathrm{target}} = 0.8$.\n\nFor each case, your program must:\n- Compute the initial spectral radius $\\rho_{\\mathrm{init}} = \\rho(S(M))$.\n- Compute the scaled masses $\\tilde{m}$ by your strategy and then $\\rho_{\\mathrm{scaled}} = \\rho(S(\\tilde{M}))$.\n- Produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a list of two floats $[\\rho_{\\mathrm{init}}, \\rho_{\\mathrm{scaled}}]$. The final output format must be:\n\"[[rA_init,rA_scaled],[rB_init,rB_scaled],[rC_init,rC_scaled],[rD_init,rD_scaled]]\"\nwith all numbers printed as decimal floats. All outputs are dimensionless.", "solution": "The problem requires an analysis of the spectral radius of the normalized coupling matrix $S$ used in the LINCS algorithm, its behavior under extreme mass ratios, and the development of a mass-scaling strategy to bound this spectral radius.\n\n### Theoretical Analysis\n\nLet the system comprise $N$ atoms with positions $\\mathbf{q} \\in \\mathbb{R}^{3N}$ and masses $m_i > 0$. The $n_c$ holonomic bond constraints are $g_k(\\mathbf{q}) = \\|\\mathbf{r}_{a(k)} - \\mathbf{r}_{b(k)}\\| - \\ell_k = 0$, where $\\mathbf{r}_i \\in \\mathbb{R}^3$ is the position of atom $i$, and $a(k), b(k)$ are the indices of atoms involved in constraint $k$.\n\nThe Jacobian of the constraints, $G(\\mathbf{q}) \\in \\mathbb{R}^{n_c \\times 3N}$, has rows given by the gradients of the constraint functions, $\\nabla_{\\mathbf{q}} g_k$. The $k$-th row of $G$, denoted $G_k$, has non-zero $3$-dimensional blocks only for atoms $a(k)$ and $b(k)$. Let $\\mathbf{u}_k = (\\mathbf{r}_{a(k)} - \\mathbf{r}_{b(k)}) / \\|\\mathbf{r}_{a(k)} - \\mathbf{r}_{b(k)}\\|$ be the normalized bond vector for constraint $k$. The gradient blocks are $\\nabla_{\\mathbf{r}_{a(k)}} g_k = \\mathbf{u}_k^\\top$ and $\\nabla_{\\mathbf{r}_{b(k)}} g_k = -\\mathbf{u}_k^\\top$.\n\nThe diagonal mass matrix is $M = \\mathrm{diag}(m_1 I_3, \\dots, m_N I_3)$, where $I_3$ is the $3 \\times 3$ identity matrix. Its inverse is $M^{-1} = \\mathrm{diag}(m_1^{-1} I_3, \\dots, m_N^{-1} I_3)$. The mass-weighted constraint coupling matrix is $C = G M^{-1} G^\\top$. An element $C_{ij}$ is given by $C_{ij} = G_i M^{-1} G_j^\\top$. This can be computed as a sum over all atoms $p$:\n$$C_{ij} = \\sum_{p=1}^{N} \\frac{1}{m_p} (\\nabla_{\\mathbf{r}_p} g_i) \\cdot (\\nabla_{\\mathbf{r}_p} g_j)$$\n\nThe diagonal elements $C_{ii}$ are:\n$$C_{ii} = \\frac{1}{m_{a(i)}} (\\mathbf{u}_i \\cdot \\mathbf{u}_i) + \\frac{1}{m_{b(i)}} ((-\\mathbf{u}_i) \\cdot (-\\mathbf{u}_i)) = \\frac{1}{m_{a(i)}} + \\frac{1}{m_{b(i)}}$$\nThis is the sum of the inverse masses of the two atoms participating in constraint $i$.\n\nThe off-diagonal elements $C_{ij}$ are non-zero only if constraints $i$ and $j$ share at least one atom. Consider two constraints $i$ and $j$ that are connected through a single common atom $p$. Let constraint $i$ involve atoms $(p_1, p)$ and constraint $j$ involve atoms $(p_2, p)$. We can set the atom ordering within the constraints such that $b(i) = p$ and $b(j) = p$. Then $\\nabla_{\\mathbf{r}_p} g_i = -\\mathbf{u}_i$ and $\\nabla_{\\mathbf{r}_p} g_j = -\\mathbf{u}_j$. The only non-zero contribution to the sum for $C_{ij}$ comes from atom $p$:\n$$C_{ij} = \\frac{1}{m_p} (-\\mathbf{u}_i) \\cdot (-\\mathbf{u}_j) = \\frac{1}{m_p} \\mathbf{u}_i \\cdot \\mathbf{u}_j$$\nHere, $\\mathbf{u}_i \\cdot \\mathbf{u}_j$ represents the cosine of the angle, $\\theta_{ij}$, between the two bond vectors pointing towards the shared atom $p$. Thus, $C_{ij} = \\frac{\\cos\\theta_{ij}}{m_p}$. Note that the sign of $C_{ij}$ depends on the arbitrary atom ordering within the constraint definitions, but the spectral radius $\\rho(S)$ is invariant to this choice. We proceed assuming an ordering that yields $C_{ij} = \\frac{\\cos\\theta_{ij}}{m_p}$, where $\\theta_{ij}$ is the angle between the bonds at atom $p$.\n\nThe normalized coupling matrix $S$ is defined as $S_{ij} = C_{ij} / \\sqrt{C_{ii}C_{jj}}$ for $i \\neq j$ and $S_{ii}=0$. For the coupled constraints $i, j$ at atom $p$:\n$$S_{ij} = \\frac{\\frac{\\cos\\theta_{ij}}{m_p}}{\\sqrt{\\left(\\frac{1}{m_{p_1}} + \\frac{1}{m_p}\\right) \\left(\\frac{1}{m_{p_2}} + \\frac{1}{m_p}\\right)}}$$\n\n### Effect of Extreme Mass Ratios\n\nConsider the case where the shared atom $p$ is very light compared to its neighbors, i.e., $m_p \\to 0$, while $m_{p_1}$ and $m_{p_2}$ are large and fixed. In this limit, the $1/m_p$ terms dominate the expressions for $C_{ii}$ and $C_{jj}$:\n$$ C_{ii} \\approx \\frac{1}{m_p}, \\quad C_{jj} \\approx \\frac{1}{m_p} $$\nThe off-diagonal element $S_{ij}$ becomes:\n$$ S_{ij} \\approx \\frac{\\frac{\\cos\\theta_{ij}}{m_p}}{\\sqrt{\\frac{1}{m_p} \\cdot \\frac{1}{m_p}}} = \\cos\\theta_{ij} $$\nThe magnitude $|S_{ij}|$ approaches $|\\cos\\theta_{ij}|$. For bond angles significantly different from $90^\\circ$ (where $\\cos\\theta_{ij}=0$), this value can be close to $1$. For a simple two-constraint system, $\\rho(S) = |S_{12}|$. If $|S_{12}|$ approaches $1$, the convergence of the LINCS algorithm's Neumann series expansion $(I-S)^{-1} = \\sum_{k=0}^{\\infty} S^k$ is destroyed. This is a critical numerical stability issue when simulating systems with light atoms (like hydrogen) bonded to multiple heavy atoms.\n\n### Mass-Scaling Strategy\n\nTo counteract this effect, we propose a strategy to increase the mass of atoms that are shared by two or more constraints. Let $I_{\\text{shared}}$ be the set of indices of such shared atoms. We introduce a uniform mass floor, $\\mu$, for these atoms. The scaled mass matrix $\\tilde{M}$ is constructed using masses $\\tilde{m}_i$:\n$$ \\tilde{m}_i = \\begin{cases} \\max(m_i, \\mu), & i \\in I_{\\text{shared}} \\\\ m_i, & i \\notin I_{\\text{shared}} \\end{cases} $$\nWe must find the minimal $\\mu$ such that for the new matrix $S(\\tilde{M})$, the spectral radius $\\rho(S(\\tilde{M})) \\le \\rho_{\\mathrm{target}}$.\n\nLet's analyze the effect of scaling the mass of a shared atom $p$ from $m_p$ to $\\tilde{m}_p = \\max(m_p, \\mu) \\ge m_p$. The magnitude of the corresponding off-diagonal element $|S_{ij}|$ is:\n$$ |S_{ij}(\\tilde{m}_p)| = \\frac{\\frac{|\\cos\\theta_{ij}|}{\\tilde{m}_p}}{\\sqrt{\\left(\\frac{1}{m_{p_1}} + \\frac{1}{\\tilde{m}_p}\\right) \\left(\\frac{1}{m_{p_2}} + \\frac{1}{\\tilde{m}_p}\\right)}} = \\frac{|\\cos\\theta_{ij}|}{\\sqrt{\\left(\\frac{\\tilde{m}_p}{m_{p_1}} + 1\\right) \\left(\\frac{\\tilde{m}_p}{m_{p_2}} + 1\\right)}} $$\nThis expression is a manifestly monotonically decreasing function of $\\tilde{m}_p$ for $\\tilde{m}_p > 0$. Increasing the mass of a shared atom thus directly reduces the magnitude of the coupling between the constraints meeting at that atom. These couplings are precisely the terms that become large for small masses. Although other, smaller elements of $|S|$ might slightly increase, the dominant effect on $\\rho(S)$ comes from the reduction of these largest off-diagonal elements. Therefore, we expect $\\rho(S(\\mu))$ to be a monotonically decreasing function of the mass floor $\\mu$.\n\nThis monotonicity allows us to find the minimal required $\\mu$ using an efficient one-dimensional root-finding algorithm. We define an objective function $f(\\mu) = \\rho(S(\\mu)) - \\rho_{\\mathrm{target}}$ and search for the smallest $\\mu \\ge \\max_{i \\in I_{\\text{shared}}} m_i$ for which $f(\\mu) \\le 0$. A bracketing method like Brent's method is suitable for this task, as we can easily find an interval $[\\mu_{\\text{low}}, \\mu_{\\text{high}}]$ where $f(\\mu_{\\text{low}}) > 0$ (the unscaled system) and $f(\\mu_{\\text{high}}) < 0$ (for a sufficiently large mass floor).", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef calculate_rho(positions, constraints, masses):\n    \"\"\"\n    Computes the spectral radius rho(S) for a given molecular system.\n\n    Parameters:\n    positions (np.ndarray): (N, 3) array of atomic positions.\n    constraints (np.ndarray): (nc, 2) array of atom indices for each constraint bond.\n    masses (np.ndarray): (N,) array of atomic masses.\n\n    Returns:\n    float: The spectral radius rho(S).\n    \"\"\"\n    num_atoms = len(masses)\n    num_constraints = len(constraints)\n\n    if num_constraints == 0:\n        return 0.0\n\n    # 1. Construct the Jacobian G\n    G = np.zeros((num_constraints, 3 * num_atoms), dtype=np.float64)\n    for k, (a_idx, b_idx) in enumerate(constraints):\n        r_a = positions[a_idx]\n        r_b = positions[b_idx]\n        r_ab = r_a - r_b\n        dist = np.linalg.norm(r_ab)\n        if dist < 1e-9:\n            raise ValueError(f\"Constraint {k} has zero length.\")\n        u = r_ab / dist\n        \n        G[k, 3 * a_idx : 3 * a_idx + 3] = u\n        G[k, 3 * b_idx : 3 * b_idx + 3] = -u\n        \n    # 2. Form C = G M^-1 G^T\n    inv_masses_rep = np.repeat(1.0 / masses, 3)\n    GM_inv = G * inv_masses_rep # Broadcasting\n    C = GM_inv @ G.T\n    \n    # 3. Form S\n    C_diag = np.diag(C)\n    if np.any(C_diag <= 0):\n        raise ValueError(\"Non-positive diagonal elements in C.\")\n    \n    denom = np.sqrt(np.outer(C_diag, C_diag))\n    # Handle potential division by zero if C_diag has zero elements, though it shouldn't\n    denom[denom < 1e-30] = 1.0\n    \n    S = C / denom\n    np.fill_diagonal(S, 0.0)\n\n    # 4. Compute spectral radius rho(S)\n    if S.shape[0] <= 1:\n        return 0.0\n    \n    eigvals = np.linalg.eigvals(S)\n    rho = np.max(np.abs(eigvals))\n    \n    return rho\n\ndef solve():\n    \"\"\"\n    Main function to run the mass-scaling analysis for the given test cases.\n    \"\"\"\n    # Test cases defined with 0-based indexing for atoms.\n    test_cases = [\n        # Case A: linear triatomic with light center\n        {\n            \"positions\": np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [2.0, 0.0, 0.0]], dtype=np.float64),\n            \"constraints\": np.array([[0, 1], [1, 2]], dtype=int),\n            \"masses\": np.array([12.0, 0.1, 12.0], dtype=np.float64),\n            \"rho_target\": 0.8\n        },\n        # Case B: right-angle triatomic, extreme light center\n        {\n            \"positions\": np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [1.0, 1.0, 0.0]], dtype=np.float64),\n            \"constraints\": np.array([[0, 1], [1, 2]], dtype=int),\n            \"masses\": np.array([12.0, 0.001, 12.0], dtype=np.float64),\n            \"rho_target\": 0.8\n        },\n        # Case C: linear four-atom chain with two light interior atoms\n        {\n            \"positions\": np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [2.0, 0.0, 0.0], [3.0, 0.0, 0.0]], dtype=np.float64),\n            \"constraints\": np.array([[0, 1], [1, 2], [2, 3]], dtype=int),\n            \"masses\": np.array([12.0, 0.1, 0.1, 12.0], dtype=np.float64),\n            \"rho_target\": 0.8\n        },\n        # Case D: bent triatomic with light center\n        {\n            \"positions\": np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [1.0 + np.cos(np.pi/6), np.sin(np.pi/6), 0.0]], dtype=np.float64),\n            \"constraints\": np.array([[0, 1], [1, 2]], dtype=int),\n            \"masses\": np.array([12.0, 0.05, 12.0], dtype=np.float64),\n            \"rho_target\": 0.8\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        q, constraints, m, rho_target = case[\"positions\"], case[\"constraints\"], case[\"masses\"], case[\"rho_target\"]\n        \n        rho_init = calculate_rho(q, constraints, m)\n        \n        if rho_init <= rho_target:\n            results.append([rho_init, rho_init])\n            continue\n            \n        atom_counts = np.bincount(constraints.flatten(), minlength=len(m))\n        shared_atoms_indices = np.where(atom_counts >= 2)[0]\n        \n        if len(shared_atoms_indices) == 0:\n            results.append([rho_init, rho_init])\n            continue\n\n        def rho_objective_func(mu):\n            scaled_masses = m.copy()\n            for i in shared_atoms_indices:\n                scaled_masses[i] = max(m[i], mu)\n            return calculate_rho(q, constraints, scaled_masses) - rho_target\n\n        mu_low = np.max(m[shared_atoms_indices])\n\n        mu_high = mu_low + 1.0  # Initial guess for upper bound\n        if mu_low == 0: mu_high = 1.0\n        \n        max_iter = 100\n        iter_count = 0\n        while rho_objective_func(mu_high) > 0 and iter_count < max_iter:\n            mu_high *= 2.0\n            iter_count += 1\n        if iter_count == max_iter:\n            raise RuntimeError(\"Failed to find an upper bound for the mass search.\")\n\n        optimal_mu = brentq(rho_objective_func, mu_low, mu_high)\n        \n        final_masses = m.copy()\n        for i in shared_atoms_indices:\n            final_masses[i] = max(m[i], optimal_mu)\n            \n        rho_scaled = calculate_rho(q, constraints, final_masses)\n        \n        results.append([rho_init, rho_scaled])\n\n    output_str = f\"[{','.join([f'[{r[0]},{r[1]}]' for r in results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3421519"}]}