{"hands_on_practices": [{"introduction": "Understanding a complex algorithm often begins with its simplest non-trivial application. This practice takes you back to the foundational principles of SHAKE by focusing on a single bond between two particles. By deriving the analytical solution for the position corrections from scratch, you will gain a concrete understanding of how the algorithm minimizes mass-weighted displacements to satisfy a constraint exactly, a core concept that underpins its use in large-scale molecular simulations [@problem_id:3444923].", "problem": "Consider two atoms $i$ and $j$ in a Molecular Dynamics (MD) simulation, with masses $m_i$ and $m_j$, respectively. After an unconstrained position update over a time step, their predicted positions are $\\tilde{\\mathbf{r}}_i$ and $\\tilde{\\mathbf{r}}_j$. A single holonomic bond-length constraint requires that the final, corrected positions $\\mathbf{r}_i = \\tilde{\\mathbf{r}}_i + \\delta \\mathbf{r}_i$ and $\\mathbf{r}_j = \\tilde{\\mathbf{r}}_j + \\delta \\mathbf{r}_j$ satisfy $|\\mathbf{r}_i - \\mathbf{r}_j| = d$, where $d$ is a prescribed constant bond length. Define $\\tilde{\\mathbf{r}}_{ij} \\equiv \\tilde{\\mathbf{r}}_i - \\tilde{\\mathbf{r}}_j$ and assume $|\\tilde{\\mathbf{r}}_{ij}| \\neq 0$.\n\nUsing only first principles (Newtonian mechanics, holonomic constraints, and the defining principle of the SHAKE algorithm that position corrections minimize the mass-weighted displacement subject to the constraint being exactly satisfied at the end of the time step), derive closed-form expressions for the position corrections $\\delta \\mathbf{r}_i$ and $\\delta \\mathbf{r}_j$ that enforce the constraint exactly for this single bond. Express your final answer in terms of $m_i$, $m_j$, $\\tilde{\\mathbf{r}}_{ij}$, and $d$. Choose the solution that yields the smallest mass-weighted displacement from $(\\tilde{\\mathbf{r}}_i, \\tilde{\\mathbf{r}}_j)$ and preserves the original bond orientation, and assume no other constraints are present.\n\nGive your final answer as the pair $\\delta \\mathbf{r}_i$ and $\\delta \\mathbf{r}_j$ in a single row matrix. No numerical evaluation is required, and no units should be included in the final answer.", "solution": "The problem requires the derivation of the atomic position corrections, $\\delta \\mathbf{r}_i$ and $\\delta \\mathbf{r}_j$, for two atoms of mass $m_i$ and $m_j$ respectively, to satisfy a single bond-length constraint. The derivation is based on the core principle of the SHAKE algorithm: the corrections must minimize the total mass-weighted squared displacement while exactly satisfying the constraint.\n\nThe objective is to minimize the function $S$:\n$$S(\\delta \\mathbf{r}_i, \\delta \\mathbf{r}_j) = m_i |\\delta \\mathbf{r}_i|^2 + m_j |\\delta \\mathbf{r}_j|^2$$\nsubject to the holonomic constraint that the final separation between the atoms is a constant distance $d$. The final positions are given by $\\mathbf{r}_i = \\tilde{\\mathbf{r}}_i + \\delta \\mathbf{r}_i$ and $\\mathbf{r}_j = \\tilde{\\mathbf{r}}_j + \\delta \\mathbf{r}_j$, where $\\tilde{\\mathbf{r}}_i$ and $\\tilde{\\mathbf{r}}_j$ are the unconstrained predicted positions.\n\nThe constraint equation is:\n$$\\sigma(\\mathbf{r}_i, \\mathbf{r}_j) = |\\mathbf{r}_i - \\mathbf{r}_j|^2 - d^2 = 0$$\nUsing the definitions of the corrected positions, the constraint becomes:\n$$|(\\tilde{\\mathbf{r}}_i + \\delta \\mathbf{r}_i) - (\\tilde{\\mathbf{r}}_j + \\delta \\mathbf{r}_j)|^2 - d^2 = 0$$\nLet $\\tilde{\\mathbf{r}}_{ij} = \\tilde{\\mathbf{r}}_i - \\tilde{\\mathbf{r}}_j$. The constraint equation is then:\n$$|\\tilde{\\mathbf{r}}_{ij} + \\delta \\mathbf{r}_i - \\delta \\mathbf{r}_j|^2 - d^2 = 0$$\n\nThis is a constrained optimization problem, which we will solve using the method of Lagrange multipliers. We define the Lagrangian function $\\mathcal{L}$:\n$$\\mathcal{L} = m_i |\\delta \\mathbf{r}_i|^2 + m_j |\\delta \\mathbf{r}_j|^2 - \\lambda (|\\tilde{\\mathbf{r}}_{ij} + \\delta \\mathbf{r}_i - \\delta \\mathbf{r}_j|^2 - d^2)$$\nwhere $\\lambda$ is the Lagrange multiplier. To find the minimum, we set the gradients of $\\mathcal{L}$ with respect to the optimization variables $\\delta \\mathbf{r}_i$ and $\\delta \\mathbf{r}_j$ to zero.\n\nTaking the gradient with respect to $\\delta \\mathbf{r}_i$:\n$$\\nabla_{\\delta \\mathbf{r}_i} \\mathcal{L} = 2 m_i \\delta \\mathbf{r}_i - 2 \\lambda (\\tilde{\\mathbf{r}}_{ij} + \\delta \\mathbf{r}_i - \\delta \\mathbf{r}_j) = \\mathbf{0}$$\nTaking the gradient with respect to $\\delta \\mathbf{r}_j$:\n$$\\nabla_{\\delta \\mathbf{r}_j} \\mathcal{L} = 2 m_j \\delta \\mathbf{r}_j - 2 \\lambda (-1) (\\tilde{\\mathbf{r}}_{ij} + \\delta \\mathbf{r}_i - \\delta \\mathbf{r}_j) = \\mathbf{0}$$\nLet the final, corrected interatomic vector be $\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j = \\tilde{\\mathbf{r}}_{ij} + \\delta \\mathbf{r}_i - \\delta \\mathbf{r}_j$. The gradient equations simplify to:\n$$m_i \\delta \\mathbf{r}_i = \\lambda \\mathbf{r}_{ij}$$\n$$m_j \\delta \\mathbf{r}_j = - \\lambda \\mathbf{r}_{ij}$$\nFrom these two equations, we can solve for the position corrections $\\delta \\mathbf{r}_i$ and $\\delta \\mathbf{r}_j$ in terms of $\\lambda$ and $\\mathbf{r}_{ij}$:\n$$\\delta \\mathbf{r}_i = \\frac{\\lambda}{m_i} \\mathbf{r}_{ij}$$\n$$\\delta \\mathbf{r}_j = -\\frac{\\lambda}{m_j} \\mathbf{r}_{ij}$$\nA direct consequence is that $m_i \\delta \\mathbf{r}_i + m_j \\delta \\mathbf{r}_j = \\mathbf{0}$. This shows that the corrections do not displace the center of mass of the two-atom system, a fundamental property of internal forces.\n\nNow, we substitute these expressions back into the definition of $\\mathbf{r}_{ij}$:\n$$\\mathbf{r}_{ij} = \\tilde{\\mathbf{r}}_{ij} + \\delta \\mathbf{r}_i - \\delta \\mathbf{r}_j = \\tilde{\\mathbf{r}}_{ij} + \\left(\\frac{\\lambda}{m_i} \\mathbf{r}_{ij}\\right) - \\left(-\\frac{\\lambda}{m_j} \\mathbf{r}_{ij}\\right)$$\n$$\\mathbf{r}_{ij} = \\tilde{\\mathbf{r}}_{ij} + \\lambda \\left(\\frac{1}{m_i} + \\frac{1}{m_j}\\right) \\mathbf{r}_{ij}$$\nRearranging the terms to solve for $\\mathbf{r}_{ij}$:\n$$\\mathbf{r}_{ij} \\left[1 - \\lambda \\left(\\frac{1}{m_i} + \\frac{1}{m_j}\\right)\\right] = \\tilde{\\mathbf{r}}_{ij}$$\nThis equation shows that the final interatomic vector $\\mathbf{r}_{ij}$ must be parallel to the unconstrained interatomic vector $\\tilde{\\mathbf{r}}_{ij}$. The constraint requires the magnitude of $\\mathbf{r}_{ij}$ to be $d$, i.e., $|\\mathbf{r}_{ij}| = d$. The problem statement also specifies that the original bond orientation should be preserved. This means that $\\mathbf{r}_{ij}$ must point in the same direction as $\\tilde{\\mathbf{r}}_{ij}$. Therefore, we can write:\n$$\\mathbf{r}_{ij} = d \\frac{\\tilde{\\mathbf{r}}_{ij}}{|\\tilde{\\mathbf{r}}_{ij}|}$$\nThis is valid since the problem states $|\\tilde{\\mathbf{r}}_{ij}| \\neq 0$.\n\nWe can now determine the Lagrange multiplier $\\lambda$ by substituting this expression for $\\mathbf{r}_{ij}$ into the rearranged equation:\n$$\\left(d \\frac{\\tilde{\\mathbf{r}}_{ij}}{|\\tilde{\\mathbf{r}}_{ij}|}\\right) \\left[1 - \\lambda \\left(\\frac{1}{m_i} + \\frac{1}{m_j}\\right)\\right] = \\tilde{\\mathbf{r}}_{ij}$$\nDividing both sides by the vector $\\tilde{\\mathbf{r}}_{ij}$ (or, more formally, taking the magnitude of both sides) yields a scalar equation:\n$$\\frac{d}{|\\tilde{\\mathbf{r}}_{ij}|} \\left[1 - \\lambda \\left(\\frac{1}{m_i} + \\frac{1}{m_j}\\right)\\right] = 1$$\nSolving for $\\lambda$:\n$$1 - \\lambda \\left(\\frac{1}{m_i} + \\frac{1}{m_j}\\right) = \\frac{|\\tilde{\\mathbf{r}}_{ij}|}{d}$$\n$$\\lambda \\left(\\frac{m_i + m_j}{m_i m_j}\\right) = 1 - \\frac{|\\tilde{\\mathbf{r}}_{ij}|}{d}$$\n$$\\lambda = \\frac{m_i m_j}{m_i+m_j} \\left(1 - \\frac{|\\tilde{\\mathbf{r}}_{ij}|}{d}\\right)$$\nNow we have all the components to find the final expressions for $\\delta \\mathbf{r}_i$ and $\\delta \\mathbf{r}_j$. Substituting the expressions for $\\lambda$ and $\\mathbf{r}_{ij}$ into the equations for the corrections:\nFor $\\delta \\mathbf{r}_i$:\n$$\\delta \\mathbf{r}_i = \\frac{\\lambda}{m_i} \\mathbf{r}_{ij} = \\frac{1}{m_i} \\left[\\frac{m_i m_j}{m_i+m_j} \\left(1 - \\frac{|\\tilde{\\mathbf{r}}_{ij}|}{d}\\right)\\right] \\left(d \\frac{\\tilde{\\mathbf{r}}_{ij}}{|\\tilde{\\mathbf{r}}_{ij}|}\\right)$$\n$$\\delta \\mathbf{r}_i = \\frac{m_j}{m_i+m_j} \\left(\\frac{d - |\\tilde{\\mathbf{r}}_{ij}|}{d}\\right) \\frac{d}{|\\tilde{\\mathbf{r}}_{ij}|} \\tilde{\\mathbf{r}}_{ij}$$\n$$\\delta \\mathbf{r}_i = \\frac{m_j}{m_i+m_j} \\left(\\frac{d - |\\tilde{\\mathbf{r}}_{ij}|}{|\\tilde{\\mathbf{r}}_{ij}|}\\right) \\tilde{\\mathbf{r}}_{ij}$$\nThis can be written more cleanly as:\n$$\\delta \\mathbf{r}_i = \\frac{m_j}{m_i+m_j} \\left(\\frac{d}{|\\tilde{\\mathbf{r}}_{ij}|} - 1\\right) \\tilde{\\mathbf{r}}_{ij}$$\nFor $\\delta \\mathbf{r}_j$:\n$$\\delta \\mathbf{r}_j = -\\frac{\\lambda}{m_j} \\mathbf{r}_{ij} = -\\frac{1}{m_j} \\left[\\frac{m_i m_j}{m_i+m_j} \\left(1 - \\frac{|\\tilde{\\mathbf{r}}_{ij}|}{d}\\right)\\right] \\left(d \\frac{\\tilde{\\mathbf{r}}_{ij}}{|\\tilde{\\mathbf{r}}_{ij}|}\\right)$$\n$$\\delta \\mathbf{r}_j = -\\frac{m_i}{m_i+m_j} \\left(\\frac{d - |\\tilde{\\mathbf{r}}_{ij}|}{d}\\right) \\frac{d}{|\\tilde{\\mathbf{r}}_{ij}|} \\tilde{\\mathbf{r}}_{ij}$$\n$$\\delta \\mathbf{r}_j = -\\frac{m_i}{m_i+m_j} \\left(\\frac{d - |\\tilde{\\mathbf{r}}_{ij}|}{|\\tilde{\\mathbf{r}}_{ij}|}\\right) \\tilde{\\mathbf{r}}_{ij}$$\nWhich can be written as:\n$$\\delta \\mathbf{r}_j = -\\frac{m_i}{m_i+m_j} \\left(\\frac{d}{|\\tilde{\\mathbf{r}}_{ij}|} - 1\\right) \\tilde{\\mathbf{r}}_{ij}$$\nThese are the closed-form expressions for the position corrections that satisfy the bond-length constraint exactly while minimizing the mass-weighted displacement.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{m_j}{m_i+m_j} \\left(\\frac{d}{|\\tilde{\\mathbf{r}}_{ij}|} - 1\\right) \\tilde{\\mathbf{r}}_{ij}  -\\frac{m_i}{m_i+m_j} \\left(\\frac{d}{|\\tilde{\\mathbf{r}}_{ij}|} - 1\\right) \\tilde{\\mathbf{r}}_{ij}\n\\end{pmatrix}\n}\n$$", "id": "3444923"}, {"introduction": "While the two-particle case provides crucial intuition, real molecular systems involve a network of coupled constraints that must be solved simultaneously. This exercise serves as a bridge to this complexity, asking you to derive the mathematical components—specifically the constraint Jacobian $G(q)$ and the mass-weighted metric $A(q)$—that form the building blocks of the larger linear system. Mastering these components is essential for understanding how algorithms like SHAKE and RATTLE are formulated and implemented for general systems [@problem_id:3444945].", "problem": "Consider a system of $N$ point particles in three-dimensional space with positions $q = (\\mathbf{r}_{1}, \\mathbf{r}_{2}, \\ldots, \\mathbf{r}_{N}) \\in \\mathbb{R}^{3N}$ and positive masses $m_{1}, m_{2}, \\ldots, m_{N}$. The constraint between particles $i$ and $j$ is holonomic and given by\n$$\ng(q) = \\|\\mathbf{r}_{i} - \\mathbf{r}_{j}\\|^{2} - d^{2},\n$$\nwhere $d > 0$ is a prescribed distance and $\\|\\cdot\\|$ denotes the Euclidean norm in $\\mathbb{R}^{3}$. Let $G(q)$ be the Jacobian row vector of $g$ with respect to $q$, i.e., $G(q) = \\nabla_{q} g(q)$, and let the mass matrix be\n$$\nM = \\mathrm{diag}(m_{1} I_{3}, m_{2} I_{3}, \\ldots, m_{N} I_{3}) \\in \\mathbb{R}^{3N \\times 3N},\n$$\nwhere $I_{3}$ is the $3 \\times 3$ identity matrix. In the family of constraint algorithms such as SHAKE and RATTLE, the scalar\n$A(q) = \\nabla g(q)^{\\top} M^{-1} \\nabla g(q)$\nappears as the mass-weighted metric of the constraint gradient.\n\nStarting from the given definitions and using standard multivariable calculus along with the block-diagonal structure of $M$, compute the nonzero entries of $G(q)$ corresponding to particles $i$ and $j$, and derive the expression for $A(q)$ in terms of $m_{i}$, $m_{j}$, and the relative vector $\\mathbf{r}_{i} - \\mathbf{r}_{j}$.\n\nYour final answer must provide, in order: the $3$-vector nonzero block of $G(q)$ at particle $i$, the $3$-vector nonzero block of $G(q)$ at particle $j$, and the scalar $A(q)$ as a closed-form analytic expression. No rounding is required, and no physical units are to be reported in the final answer.", "solution": "The problem is validated as scientifically grounded, well-posed, and objective. It is a standard derivation in the field of computational chemistry and molecular dynamics, specifically related to constraint algorithms like SHAKE and RATTLE. All necessary information is provided, and the problem is free of contradictions or ambiguities that would prevent a unique solution, although care must be taken with vector and gradient notation.\n\nThe task is to compute the nonzero blocks of the gradient of the constraint function $g(q)$ and then to derive an expression for the scalar $A(q)$.\n\nThe constraint function is given by\n$$\ng(q) = \\|\\mathbf{r}_{i} - \\mathbf{r}_{j}\\|^{2} - d^{2}\n$$\nwhere $q = (\\mathbf{r}_{1}, \\ldots, \\mathbf{r}_{N})$ is the vector of all particle positions. We can write the squared norm as a dot product:\n$$\ng(q) = (\\mathbf{r}_{i} - \\mathbf{r}_{j}) \\cdot (\\mathbf{r}_{i} - \\mathbf{r}_{j}) - d^{2}\n$$\nThe problem defines $G(q) = \\nabla_q g(q)$ as the Jacobian row vector. However, the expression for $A(q) = \\nabla g(q)^{\\top} M^{-1} \\nabla g(q)$ is a quadratic form that requires $\\nabla g(q)$ to be a column vector. This is a common notational variance. We will interpret $\\nabla g(q)$ as the standard gradient column vector of dimension $3N \\times 1$. The Jacobian row vector $G(q)$ would then be $G(q) = (\\nabla g(q))^\\top$. The problem's request for the \"3-vector nonzero block\" further supports the interpretation that we should compute the column vector components of the gradient.\n\nThe gradient of $g(q)$ with respect to the full position vector $q$ is a column vector composed of blocks, where each block is the gradient with respect to a particle's position vector $\\mathbf{r}_k$:\n$$\n\\nabla_q g(q) = \\begin{pmatrix} \\nabla_{\\mathbf{r}_1} g(q) \\\\ \\vdots \\\\ \\nabla_{\\mathbf{r}_N} g(q) \\end{pmatrix}\n$$\nThe function $g(q)$ only depends on $\\mathbf{r}_i$ and $\\mathbf{r}_j$. Therefore, for any particle $k$ where $k \\neq i$ and $k \\neq j$, the gradient block is zero:\n$$\n\\nabla_{\\mathbf{r}_k} g(q) = \\mathbf{0} \\quad \\text{for } k \\neq i, j\n$$\n\nWe now compute the two nonzero blocks of the gradient.\n\nFirst, for particle $i$, we use the rule for the gradient of a dot product, $\\nabla(\\mathbf{u} \\cdot \\mathbf{u}) = 2(\\nabla \\mathbf{u})^\\top \\mathbf{u}$. Here, we are taking the gradient with respect to $\\mathbf{r}_i$. Let $\\mathbf{v}(\\mathbf{r}_i, \\mathbf{r}_j) = \\mathbf{r}_i - \\mathbf{r}_j$.\n$$\n\\nabla_{\\mathbf{r}_i} g(q) = \\nabla_{\\mathbf{r}_i} (\\mathbf{v} \\cdot \\mathbf{v})\n$$\nThe gradient of $\\mathbf{v}$ with respect to $\\mathbf{r}_i$ is the $3 \\times 3$ identity matrix $I_3$, since $\\nabla_{\\mathbf{r}_i} \\mathbf{r}_i = I_3$ and $\\nabla_{\\mathbf{r}_i} \\mathbf{r}_j = 0$.\nApplying the chain rule (or product rule for vector calculus):\n$$\n\\nabla_{\\mathbf{r}_i} g(q) = 2 (\\nabla_{\\mathbf{r}_i} \\mathbf{v})^\\top \\mathbf{v} = 2 I_3^\\top (\\mathbf{r}_i - \\mathbf{r}_j) = 2(\\mathbf{r}_i - \\mathbf{r}_j)\n$$\nThis is the first requested quantity: the $3$-vector nonzero block corresponding to particle $i$.\n\nSecond, for particle $j$, we compute the gradient similarly.\nThe gradient of $\\mathbf{v}$ with respect to $\\mathbf{r}_j$ is the negative identity matrix, $-I_3$, since $\\nabla_{\\mathbf{r}_j} \\mathbf{r}_i = 0$ and $\\nabla_{\\mathbf{r}_j} \\mathbf{r}_j = I_3$.\n$$\n\\nabla_{\\mathbf{r}_j} g(q) = 2 (\\nabla_{\\mathbf{r}_j} \\mathbf{v})^\\top \\mathbf{v} = 2 (-I_3)^\\top (\\mathbf{r}_i - \\mathbf{r}_j) = -2(\\mathbf{r}_i - \\mathbf{r}_j)\n$$\nThis is the second requested quantity: the $3$-vector nonzero block corresponding to particle $j$.\n\nNext, we derive the expression for $A(q)$. The definition is:\n$A(q) = (\\nabla g(q))^{\\top} M^{-1} \\nabla g(q)$\nThe mass matrix $M$ and its inverse $M^{-1}$ are block-diagonal:\n$$\nM = \\mathrm{diag}(m_{1} I_{3}, \\ldots, m_{N} I_{3}) \\implies M^{-1} = \\mathrm{diag}(m_{1}^{-1} I_{3}, \\ldots, m_{N}^{-1} I_{3})\n$$\nWriting the quadratic form for $A(q)$ in terms of the gradient blocks:\n$A(q) = \\sum_{k=1}^N (\\nabla_{\\mathbf{r}_k} g(q))^\\top (m_k^{-1} I_3) (\\nabla_{\\mathbf{r}_k} g(q))$\nSince the gradient blocks are zero for $k \\ne i, j$, this sum reduces to two terms:\n$A(q) = (\\nabla_{\\mathbf{r}_i} g(q))^\\top (m_i^{-1} I_3) (\\nabla_{\\mathbf{r}_i} g(q)) + (\\nabla_{\\mathbf{r}_j} g(q))^\\top (m_j^{-1} I_3) (\\nabla_{\\mathbf{r}_j} g(q))$\nSubstituting the expressions for the gradient blocks we found:\n$A(q) = \\frac{1}{m_i} (2(\\mathbf{r}_i - \\mathbf{r}_j))^\\top (2(\\mathbf{r}_i - \\mathbf{r}_j)) + \\frac{1}{m_j} (-2(\\mathbf{r}_i - \\mathbf{r}_j))^\\top (-2(\\mathbf{r}_i - \\mathbf{r}_j))$\nFactoring out the constants:\n$A(q) = \\frac{4}{m_i} (\\mathbf{r}_i - \\mathbf{r}_j)^\\top (\\mathbf{r}_i - \\mathbf{r}_j) + \\frac{4}{m_j} (\\mathbf{r}_i - \\mathbf{r}_j)^\\top (\\mathbf{r}_i - \\mathbf{r}_j)$\nRecognizing that $(\\mathbf{r}_i - \\mathbf{r}_j)^\\top (\\mathbf{r}_i - \\mathbf{r}_j) = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|^2$:\n$A(q) = \\frac{4}{m_i} \\|\\mathbf{r}_i - \\mathbf{r}_j\\|^2 + \\frac{4}{m_j} \\|\\mathbf{r}_i - \\mathbf{r}_j\\|^2$\nFactoring the common terms yields the final expression for $A(q)$:\n$A(q) = 4 \\left( \\frac{1}{m_i} + \\frac{1}{m_j} \\right) \\|\\mathbf{r}_i - \\mathbf{r}_j\\|^2$\nThis is the third requested quantity.\nThe three results are presented in the specified order.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2(\\mathbf{r}_i - \\mathbf{r}_j)  -2(\\mathbf{r}_i - \\mathbf{r}_j)  4\\left(\\frac{1}{m_i} + \\frac{1}{m_j}\\right) \\|\\mathbf{r}_i - \\mathbf{r}_j\\|^2\n\\end{pmatrix}\n}\n$$", "id": "3444945"}, {"introduction": "Theoretical algorithms must prove their worth in the world of finite-precision arithmetic and practical application. This hands-on coding exercise moves from analytical derivation to numerical implementation, challenging you to explore a critical aspect of SHAKE's performance: its convergence properties. By simulating a simple diatomic system with varying mass ratios, you will directly observe how the algorithm's iterative nature behaves under numerically 'stiff' conditions, a common scenario in real-world molecular dynamics [@problem_id:2436786].", "problem": "Consider a system of two point particles in three spatial dimensions with positions $\\mathbf{r}_1 \\in \\mathbb{R}^3$ and $\\mathbf{r}_2 \\in \\mathbb{R}^3$, and masses $m_1$ and $m_2$ (in $\\mathrm{kg}$). The particles are linked by a rigid holonomic constraint that fixes their separation to a prescribed bond length $d$ (in $\\mathrm{m}$), namely\n$$\n\\phi(\\mathbf{r}_1,\\mathbf{r}_2) \\equiv \\lVert \\mathbf{r}_2 - \\mathbf{r}_1 \\rVert^2 - d^2 = 0.\n$$\nThere are no external forces. Let the initial positions and velocities be\n$$\n\\mathbf{r}_1(0) = (0,0,0)\\ \\mathrm{m},\\quad \\mathbf{r}_2(0) = (d,0,0)\\ \\mathrm{m},\n$$\n$$\n\\mathbf{v}_1(0) = (0,+v_0,0)\\ \\mathrm{m/s},\\quad \\mathbf{v}_2(0) = (0,-v_0,0)\\ \\mathrm{m/s},\n$$\nwith $d = 1.0\\ \\mathrm{m}$ and $v_0 = 1.0\\ \\mathrm{m/s}$. Evolve the system in time using a uniform time step $h = 0.01\\ \\mathrm{s}$ for $T = 50$ steps. At each time step, perform a free-flight position prediction using uniform-velocity motion,\n$$\n\\mathbf{r}_i^{\\ast} = \\mathbf{r}_i + h\\,\\mathbf{v}_i\\quad \\text{for } i \\in \\{1,2\\},\n$$\nand then enforce the holonomic constraint $\\phi(\\mathbf{r}_1,\\mathbf{r}_2)=0$ by iteratively updating the positions along the constraint gradient using mass-weighted corrections until the absolute constraint violation $|\\phi| \\le \\varepsilon = 10^{-12}\\ \\mathrm{m}^2$. One iteration is defined as one application of such a mass-weighted correction computed from the current iterate to reduce the residual of $\\phi$. After positions are corrected at a time step, enforce the corresponding velocity-level constraint at the corrected positions so that $\\dot{\\phi} = \\nabla_{\\mathbf{r}_1}\\phi \\cdot \\mathbf{v}_1 + \\nabla_{\\mathbf{r}_2}\\phi \\cdot \\mathbf{v}_2 = 0$ holds at the end of the time step.\n\nUsing the above setup, for each of the following four test cases of $(m_1,m_2)$ in $\\mathrm{kg}$:\n- Test case $1$: $(1.0,\\,1.0)$,\n- Test case $2$: $(1000.0,\\,1.0)$,\n- Test case $3$: $(10^{8},\\,1.0)$,\n- Test case $4$: $(10^{12},\\,1.0)$,\n\nsimulate the system and determine, for each test case, the maximum number of inner position-correction iterations required over all $T$ time steps to achieve $|\\phi| \\le \\varepsilon$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases $1$ through $4$, where each entry is an integer. For example, the required format is\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4].\n$$\nAll physical quantities must be interpreted and computed in the specified International System of Units (SI). Angles, if any occur in intermediate computations, must be interpreted in radians, but the final reported results are unitless integers as defined above.", "solution": "The user has provided a computational physics problem that requires simulating a two-particle system with a rigid bond constraint. I must first validate the problem statement.\n\n### Step 1: Extract Givens\n- **System**: Two point particles in three-dimensional space.\n- **State variables**: Positions $\\mathbf{r}_1, \\mathbf{r}_2 \\in \\mathbb{R}^3$ and velocities $\\mathbf{v}_1, \\mathbf{v}_2 \\in \\mathbb{R}^3$.\n- **Parameters**: Masses $m_1, m_2$ (in $\\mathrm{kg}$), bond length $d = 1.0\\ \\mathrm{m}$, initial velocity component $v_0 = 1.0\\ \\mathrm{m/s}$.\n- **Holonomic constraint**: $\\phi(\\mathbf{r}_1,\\mathbf{r}_2) \\equiv \\lVert \\mathbf{r}_2 - \\mathbf{r}_1 \\rVert^2 - d^2 = 0$.\n- **Initial conditions**:\n  - $\\mathbf{r}_1(0) = (0,0,0)\\ \\mathrm{m}$, $\\mathbf{r}_2(0) = (d,0,0)\\ \\mathrm{m}$.\n  - $\\mathbf{v}_1(0) = (0,+v_0,0)\\ \\mathrm{m/s}$, $\\mathbf{v}_2(0) = (0,-v_0,0)\\ \\mathrm{m/s}$.\n- **Dynamics**: No external forces.\n- **Numerical method**:\n  - Time step $h = 0.01\\ \\mathrm{s}$.\n  - Number of steps $T = 50$.\n  - **Position Prediction**: Free-flight (uniform velocity) motion: $\\mathbf{r}_i^{\\ast} = \\mathbf{r}_i + h\\,\\mathbf{v}_i$.\n  - **Position Correction (SHAKE)**: Iteratively correct positions $\\mathbf{r}_i$ to satisfy $|\\phi| \\le \\varepsilon = 10^{-12}\\ \\mathrm{m}^2$. Corrections are mass-weighted and applied along the constraint gradient.\n  - **Velocity Correction (RATTLE)**: After position correction, velocities are adjusted to satisfy the time-differentiated constraint $\\dot{\\phi} = 0$.\n- **Task**: For four test cases of $(m_1, m_2)$ in $\\mathrm{kg}$:\n  1. $(1.0,\\,1.0)$,\n  2. $(1000.0,\\,1.0)$,\n  3. $(10^{8},\\,1.0)$,\n  4. $(10^{12},\\,1.0)$,\n  determine the maximum number of SHAKE iterations required across all $T$ time steps.\n- **Output format**: `[result_1,result_2,result_3,result_4]`\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded**: The problem describes a system under a holonomic constraint, a fundamental topic in classical and computational mechanics. The specified algorithms, SHAKE and RATTLE, are standard and widely used numerical methods for molecular dynamics simulations with constraints. The setup is scientifically sound.\n2.  **Well-Posed**: The problem is well-defined. Initial conditions, system parameters, the algorithm, and the stopping criterion are all precisely specified. A unique trajectory and a corresponding numerical result (maximum iteration count) are computable.\n3.  **Objective**: The problem is stated using objective, mathematical language, free from ambiguity or subjective claims.\n4.  **Incomplete or Contradictory Setup**: The setup is complete. The initial conditions are consistent with the constraints: $\\phi(\\mathbf{r}_1(0), \\mathbf{r}_2(0)) = \\lVert (d,0,0) - (0,0,0) \\rVert^2 - d^2 = 0$, and $\\dot{\\phi}(0) = 2(\\mathbf{r}_2(0)-\\mathbf{r}_1(0)) \\cdot (\\mathbf{v}_2(0)-\\mathbf{v}_1(0)) = 2(d,0,0)\\cdot(0,-2v_0,0) = 0$. There are no contradictions.\n5.  **Unrealistic or Infeasible**: While the mass ratios in test cases 3 and 4 are extreme, they are designed to test the numerical stability and performance of the algorithm under stiff conditions, which is a valid scientific investigation. The problem is numerically feasible.\n6.  **All other criteria**: The problem passes all other validity checks. It is formalizable, relevant to the topic, not ill-posed, and its result is scientifically verifiable.\n\n### Step 3: Verdict and Action\nThe problem is valid. I will proceed with providing a solution.\n\n### Principle-Based Design of the Solution\n\nThe problem requires the implementation of a simulation loop incorporating the SHAKE and RATTLE constraint algorithms, which are extensions of the Verlet integration scheme.\n\n#### The Simulation Loop\nThe system evolves from time $t_n$ to $t_{n+1} = t_n + h$. Let $\\mathbf{r}_i(n)$ and $\\mathbf{v}_i(n)$ be the positions and velocities of particle $i$ at time $t_n$.\n\n1.  **Position Prediction**: In the absence of external forces, particles move at a constant velocity. The predicted positions $\\mathbf{r}_i^*$ are:\n    $$ \\mathbf{r}_i^{\\ast} = \\mathbf{r}_i(n) + h\\,\\mathbf{v}_i(n) $$\n    These predicted positions, in general, will not satisfy the bond length constraint.\n\n2.  **Position Correction (SHAKE Algorithm)**: The SHAKE algorithm iteratively corrects the predicted positions until the constraint is met. Let $\\mathbf{r}_i^{(k)}$ be the position of particle $i$ at the $k$-th SHAKE iteration, with $\\mathbf{r}_i^{(0)} = \\mathbf{r}_i^*$. The correction at each step, $\\delta\\mathbf{r}_i^{(k)} = \\mathbf{r}_i^{(k+1)} - \\mathbf{r}_i^{(k)}$, is directed along the constraint gradient $\\nabla_{\\mathbf{r}_i}\\phi$ and weighted by the inverse mass $1/m_i$.\n\n    The constraint is $\\phi = \\lVert \\mathbf{r}_2 - \\mathbf{r}_1 \\rVert^2 - d^2 = 0$.\n    The gradients are $\\nabla_{\\mathbf{r}_1}\\phi = -2(\\mathbf{r}_2 - \\mathbf{r}_1)$ and $\\nabla_{\\mathbf{r}_2}\\phi = 2(\\mathbf{r}_2 - \\mathbf{r}_1)$.\n    The corrections are $\\delta\\mathbf{r}_i^{(k)} = \\lambda_k \\frac{1}{m_i} \\nabla_{\\mathbf{r}_i}\\phi^{(k)}$, where $\\lambda_k$ is a single Lagrange multiplier for the constraint.\n\n    To find $\\lambda_k$, we linearize the constraint equation around the current iterate $\\mathbf{r}^{(k)}$:\n    $$ \\phi(\\mathbf{r}^{(k+1)}) \\approx \\phi(\\mathbf{r}^{(k)}) + \\sum_{i=1}^2 \\nabla_{\\mathbf{r}_i}\\phi^{(k)} \\cdot \\delta\\mathbf{r}_i^{(k)} = 0 $$\n    Substituting the expression for $\\delta\\mathbf{r}_i^{(k)}$:\n    $$ \\phi^{(k)} + \\lambda_k \\sum_{i=1}^2 \\frac{1}{m_i} \\lVert \\nabla_{\\mathbf{r}_i}\\phi^{(k)} \\rVert^2 = 0 $$\n    Letting $\\mathbf{r}_{12}^{(k)} = \\mathbf{r}_2^{(k)} - \\mathbf{r}_1^{(k)}$, we have $\\lVert\\nabla_{\\mathbf{r}_1}\\phi\\rVert^2 = \\lVert\\nabla_{\\mathbf{r}_2}\\phi\\rVert^2 = 4\\lVert\\mathbf{r}_{12}^{(k)}\\rVert^2$. The denominator becomes $4\\lVert\\mathbf{r}_{12}^{(k)}\\rVert^2 (\\frac{1}{m_1} + \\frac{1}{m_2})$.\n    Solving for $\\lambda_k$:\n    $$ \\lambda_k = - \\frac{\\phi^{(k)}}{4 \\lVert\\mathbf{r}_{12}^{(k)}\\rVert^2 \\left(\\frac{1}{m_1} + \\frac{1}{m_2}\\right)} $$\n    The iterative update rule is thus:\n    $$ \\mathbf{r}_1^{(k+1)} = \\mathbf{r}_1^{(k)} - 2\\lambda_k \\frac{1}{m_1}\\mathbf{r}_{12}^{(k)} $$\n    $$ \\mathbf{r}_2^{(k+1)} = \\mathbf{r}_2^{(k)} + 2\\lambda_k \\frac{1}{m_2}\\mathbf{r}_{12}^{(k)} $$\n    This process is repeated until $|\\phi^{(k)}| \\le \\varepsilon$. The number of iterations $k$ is tracked. The final corrected positions are denoted $\\mathbf{r}_i(n+1)$.\n\n3.  **Velocity Correction (RATTLE Algorithm)**: After obtaining the corrected positions $\\mathbf{r}_i(n+1)$, the velocities must be updated. A temporary velocity $\\mathbf{v}_i'$ is first calculated consistent with the position change:\n    $$ \\mathbf{v}_i' = \\frac{\\mathbf{r}_i(n+1) - \\mathbf{r}_i(n)}{h} $$\n    These velocities do not necessarily satisfy the velocity-level constraint $\\dot{\\phi}=0$. A correction $\\delta\\mathbf{v}_i$ is added, analogous to the SHAKE correction: $\\mathbf{v}_i(n+1) = \\mathbf{v}_i' + \\delta\\mathbf{v}_i$. The correction is $\\delta\\mathbf{v}_i = \\gamma \\frac{1}{m_i} \\nabla_{\\mathbf{r}_i}\\phi(n+1)$, where $\\gamma$ is another Lagrange multiplier.\n\n    We enforce $\\dot{\\phi}(n+1) = \\sum_{i=1}^2 \\nabla_{\\mathbf{r}_i}\\phi(n+1) \\cdot \\mathbf{v}_i(n+1) = 0$.\n    $$ \\sum_{i=1}^2 \\nabla_{\\mathbf{r}_i}\\phi \\cdot \\mathbf{v}_i' + \\gamma \\sum_{i=1}^2 \\frac{1}{m_i} \\lVert\\nabla_{\\mathbf{r}_i}\\phi\\rVert^2 = 0 $$\n    Letting $\\mathbf{r}_{12}(n+1) = \\mathbf{r}_2(n+1) - \\mathbf{r}_1(n+1)$, the first term is $2\\mathbf{r}_{12}(n+1) \\cdot (\\mathbf{v}_2'-\\mathbf{v}_1')$. The corrected positions satisfy $\\lVert\\mathbf{r}_{12}(n+1)\\rVert^2 \\approx d^2$.\n    Solving for $\\gamma$:\n    $$ \\gamma = - \\frac{2\\mathbf{r}_{12}(n+1) \\cdot (\\mathbf{v}_2' - \\mathbf{v}_1')}{4d^2\\left(\\frac{1}{m_1} + \\frac{1}{m_2}\\right)} $$\n    The final velocities for the next time step are:\n    $$ \\mathbf{v}_1(n+1) = \\mathbf{v}_1' - \\frac{2\\gamma}{m_1}\\mathbf{r}_{12}(n+1) $$\n    $$ \\mathbf{v}_2(n+1) = \\mathbf{v}_2' + \\frac{2\\gamma}{m_2}\\mathbf{r}_{12}(n+1) $$\n\nThis entire sequence (Predict-Correct-Correct) comprises one time step. The simulation is run for $T$ steps for each mass combination, and the maximum number of SHAKE iterations is recorded. The extreme mass ratios in the test cases are expected to highlight numerical stiffness and potential degradation of convergence due to finite floating-point precision, where the corrective displacement for the heavy particle becomes vanishingly small compared to its position's magnitude.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Simulates a two-particle system with a rigid bond constraint using the\n    SHAKE and RATTLE algorithms and determines the maximum number of SHAKE\n    iterations required for various mass ratios.\n    \"\"\"\n    \n    # Define physical constants and simulation parameters\n    d = 1.0  # Bond length in meters\n    v0 = 1.0  # Initial velocity component in m/s\n    h = 0.01  # Time step in seconds\n    T_steps = 50  # Total number of time steps\n    tolerance = 1e-12  # Constraint tolerance in m^2\n\n    # Test cases for masses (m1, m2) in kg\n    test_cases = [\n        (1.0, 1.0),\n        (1000.0, 1.0),\n        (1.0e8, 1.0),\n        (1.0e12, 1.0),\n    ]\n\n    results = []\n\n    for m1, m2 in test_cases:\n        # Convert masses to numpy float64 for consistent calculations\n        m1_np = np.float64(m1)\n        m2_np = np.float64(m2)\n        inv_m1 = np.float64(1.0) / m1_np\n        inv_m2 = np.float64(1.0) / m2_np\n\n        # Initial conditions for positions and velocities\n        r1 = np.array([0.0, 0.0, 0.0], dtype=np.float64)\n        r2 = np.array([d, 0.0, 0.0], dtype=np.float64)\n        v1 = np.array([0.0, v0, 0.0], dtype=np.float64)\n        v2 = np.array([0.0, -v0, 0.0], dtype=np.float64)\n\n        max_iterations = 0\n\n        # Main simulation loop\n        for _ in range(T_steps):\n            r1_old, r2_old = r1.copy(), r2.copy()\n\n            # --- 1. Position Prediction (Free-flight) ---\n            # r_i* = r_i(n) + h * v_i(n)\n            r1_pred = r1 + h * v1\n            r2_pred = r2 + h * v2\n\n            # --- 2. Position Correction (SHAKE) ---\n            shake_iterations = 0\n            r1_corr, r2_corr = r1_pred.copy(), r2_pred.copy()\n            \n            while True:\n                r12 = r2_corr - r1_corr\n                r12_sq = np.dot(r12, r12)\n                phi = r12_sq - d*d\n\n                if np.abs(phi) = tolerance:\n                    break\n                \n                shake_iterations += 1\n                \n                # Calculate Lagrange multiplier lambda\n                # Grad_r1(phi) = -2*r12, Grad_r2(phi) = 2*r12\n                # Denominator term: (1/m1)*||Grad_r1||^2 + (1/m2)*||Grad_r2||^2\n                # = (inv_m1 * 4 * r12_sq) + (inv_m2 * 4 * r12_sq)\n                # = 4 * r12_sq * (inv_m1 + inv_m2)\n                denominator = 4.0 * r12_sq * (inv_m1 + inv_m2)\n\n                # Avoid division by zero, though unlikely in this problem\n                if denominator == 0:\n                    break\n\n                lagrange_lambda = -phi / denominator\n\n                # Update positions\n                # delta_r1 = lambda * (1/m1) * Grad_r1(phi)\n                # delta_r2 = lambda * (1/m2) * Grad_r2(phi)\n                r1_corr += lagrange_lambda * inv_m1 * (-2.0 * r12)\n                r2_corr += lagrange_lambda * inv_m2 * (2.0 * r12)\n\n            if shake_iterations  max_iterations:\n                max_iterations = shake_iterations\n            \n            # Final corrected positions for the time step\n            r1, r2 = r1_corr, r2_corr\n\n            # --- 3. Velocity Correction (RATTLE) ---\n            # First, compute uncorrected velocities\n            v1_prime = (r1 - r1_old) / h\n            v2_prime = (r2 - r2_old) / h\n            \n            # Constraint at velocity level: Grad_phi . v = 0\n            # Grad_r1 . v1 + Grad_r2 . v2 = 0\n            # Solve for Lagrange multiplier gamma\n            r12_final = r2 - r1\n            v12_prime = v2_prime - v1_prime\n            \n            # Numerator term: Grad_r1 . v1' + Grad_r2 . v2'\n            # = -2 * r12_final . v1' + 2 * r12_final . v2'\n            # = 2 * r12_final . (v2' - v1')\n            numerator_gamma = 2.0 * np.dot(r12_final, v12_prime)\n            \n            # Denominator is same form as in SHAKE, evaluated at final positions\n            # Here, r12_sq is guaranteed to be d*d to high precision\n            denominator_gamma = 4.0 * d*d * (inv_m1 + inv_m2)\n\n            if denominator_gamma == 0: # Failsafe\n                lagrange_gamma = 0.0\n            else:\n                lagrange_gamma = -numerator_gamma / denominator_gamma\n            \n            # Update velocities\n            v1 = v1_prime + lagrange_gamma * inv_m1 * (-2.0 * r12_final)\n            v2 = v2_prime + lagrange_gamma * inv_m2 * (2.0 * r12_final)\n        \n        results.append(max_iterations)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2436786"}]}