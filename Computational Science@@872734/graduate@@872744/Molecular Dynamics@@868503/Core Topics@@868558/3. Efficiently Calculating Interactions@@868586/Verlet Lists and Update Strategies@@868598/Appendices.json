{"hands_on_practices": [{"introduction": "The simplest strategy for managing Verlet lists is to rebuild them at a fixed time interval. But how long is a list \"safe\" to use? This practice connects the macroscopic concept of list lifetime to the microscopic physics of particle motion. By treating particle speeds as a random variable described by the Maxwell-Boltzmann distribution, you will derive a statistical model for when a list is likely to become invalid, providing a quantitative basis for choosing a rebuild frequency in a simulation [@problem_id:3460172].", "problem": "You are tasked with deriving, implementing, and applying a principled estimator for the lifetime of Verlet neighbor lists in molecular dynamics across a nonuniform temperature field. Use fundamental mechanical and statistical bases and make no assumptions beyond those stated.\n\nConsider a system of identical particles of mass $m$ evolving under Newtonian dynamics. In regions where the system is locally equilibrated at temperature $T(\\mathbf{r})$, assume the instantaneous velocity components are independent, normally distributed with mean $0$ and variance $\\sigma^{2} = k_{\\mathrm{B}} T(\\mathbf{r}) / m$, where $k_{\\mathrm{B}}$ is the Boltzmann constant. Consequently, the particle speed $v$ follows the classical Maxwell speed distribution in three dimensions. A Verlet neighbor list is constructed with a radial cutoff $r_{\\mathrm{c}}$ and an additional buffer (skin) thickness $s  0$. A widely used conservative update strategy is to rebuild the neighbor list when any particle’s displacement since the last build exceeds a threshold $\\Delta$, where a common choice is $\\Delta = s/2$. Assume that between list builds the motion relevant to displacement over the short time window is ballistic, so the displacement magnitude over time $t$ is approximated by $d(t) = v t$.\n\nYour tasks are:\n\n1. Derive the probability density function of the neighbor list lifetime $t$ in a region with temperature $T(\\mathbf{r})$, defined as the random time until the displacement first exceeds the threshold $\\Delta  0$, under the ballistic approximation $t = \\Delta / v$ with $v$ distributed according to the local Maxwell speed distribution. From this distribution, derive expressions for the mean $\\mathbb{E}[t]$ and the variance $\\mathrm{Var}(t)$ in terms of $m$, $k_{\\mathrm{B}}$, $T(\\mathbf{r})$, and $\\Delta$.\n\n2. Let $t_{\\mathrm{thr}}  0$ be an early-rebuild threshold time. Derive the local probability $P_{\\mathrm{early}}(\\mathbf{r})$ that a region requires an early rebuild before time $t_{\\mathrm{thr}}$ under the same local equilibrium and ballistic assumptions. Your expression must be written in terms of the Maxwell speed cumulative distribution function and the given parameters.\n\n3. Implement a program that, for each provided temperature field instance, computes:\n   - The list of spatial region indices (flattened in row-major order starting from $0$) where $P_{\\mathrm{early}}(\\mathbf{r})$ strictly exceeds a given probability cutoff $p_{\\mathrm{cut}}$.\n   - The global mean of neighbor list lifetimes over the field, defined as the arithmetic mean of the local $\\mathbb{E}[t]$ values across all regions in the field.\n   - The global variance of neighbor list lifetimes over the field, defined as the arithmetic mean of the local $\\mathrm{Var}(t)$ values across all regions in the field.\n\nAssume each field is specified as a finite grid with given temperatures. The Maxwell speed distribution must be applied locally using the temperature of the corresponding region. Use $k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}$ joules per kelvin. Express all times in seconds and probabilities as decimals. No angles are involved.\n\nTest Suite:\n\nProvide a program that evaluates the following three cases. In all cases use $\\Delta = s/2$.\n\n- Case A (happy path, two-dimensional nonuniform field):\n  - Mass $m = 6.63 \\times 10^{-26}$ kilograms.\n  - Skin thickness $s = 0.6 \\times 10^{-9}$ meters, so $\\Delta = 0.3 \\times 10^{-9}$ meters.\n  - Early-rebuild threshold $t_{\\mathrm{thr}} = 1.0 \\times 10^{-12}$ seconds.\n  - Probability cutoff $p_{\\mathrm{cut}} = 0.6$.\n  - Field shape $3 \\times 3$ with temperatures in kelvins given by the matrix\n    $$\n    \\begin{bmatrix}\n    200  300  200 \\\\\n    300  600  300 \\\\\n    200  300  200\n    \\end{bmatrix}.\n    $$\n  - Flattening order is row-major: indices $0$ through $8$.\n\n- Case B (boundary coverage: one-dimensional gradient, heavier mass):\n  - Mass $m = 1.0 \\times 10^{-25}$ kilograms.\n  - Skin thickness $s = 0.4 \\times 10^{-9}$ meters, so $\\Delta = 0.2 \\times 10^{-9}$ meters.\n  - Early-rebuild threshold $t_{\\mathrm{thr}} = 0.8 \\times 10^{-12}$ seconds.\n  - Probability cutoff $p_{\\mathrm{cut}} = 0.5$.\n  - Field shape $1 \\times 5$ with temperatures in kelvins given by\n    $$\n    [150, 200, 250, 300, 350].\n    $$\n  - Flattening order yields indices $0$ through $4$.\n\n- Case C (edge case: very small skin, strongly nonuniform field):\n  - Mass $m = 6.63 \\times 10^{-26}$ kilograms.\n  - Skin thickness $s = 0.1 \\times 10^{-9}$ meters, so $\\Delta = 0.05 \\times 10^{-9}$ meters.\n  - Early-rebuild threshold $t_{\\mathrm{thr}} = 0.5 \\times 10^{-12}$ seconds.\n  - Probability cutoff $p_{\\mathrm{cut}} = 0.3$.\n  - Field shape $2 \\times 2$ with temperatures in kelvins given by the matrix\n    $$\n    \\begin{bmatrix}\n    400  400 \\\\\n    700  100\n    \\end{bmatrix}.\n    $$\n  - Flattening order yields indices $0$ through $3$.\n\nFinal Output Format:\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result must be a list of the form\n$[\\text{high\\_risk\\_indices}, \\text{global\\_mean\\_lifetime\\_seconds}, \\text{global\\_variance\\_seconds}^2]$,\nwhere $\\text{high\\_risk\\_indices}$ itself is a list of integers. For example, the overall output should look like\n$[[[i\\_1,i\\_2,\\dots],m\\_A,v\\_A],[[j\\_1,j\\_2,\\dots],m\\_B,v\\_B],[[k\\_1,k\\_2,\\dots],m\\_C,v\\_C]]$\nwith all times in seconds and variances in $\\text{seconds}^2$.", "solution": "The problem is valid as it is scientifically grounded, self-contained, well-posed, and objective. It presents a solvable physics problem based on fundamental principles of statistical mechanics and molecular dynamics. We proceed with the derivation and implementation.\n\nThe analysis is divided into three parts as requested: derivation of the lifetime distribution and its moments, derivation of the early-rebuild probability, and implementation of the calculations for the given test cases.\n\n### 1. Derivation of the Lifetime Distribution and Moments\n\nWe begin with the probability density function (PDF) of particle speed $v$ in three dimensions, the Maxwell speed distribution, which is valid for a system in local thermal equilibrium at temperature $T(\\mathbf{r})$:\n$$ f_V(v) = \\sqrt{\\frac{2}{\\pi}} \\left(\\frac{m}{k_{\\mathrm{B}}T}\\right)^{3/2} v^2 \\exp\\left(-\\frac{mv^2}{2k_{\\mathrm{B}}T}\\right) \\quad \\text{for } v \\ge 0 $$\nwhere $m$ is the particle mass and $k_{\\mathrm{B}}$ is the Boltzmann constant. It is convenient to define a parameter $a = \\sqrt{k_{\\mathrm{B}}T/m}$, which represents the most probable speed up to a constant factor. The PDF can then be written as:\n$$ f_V(v) = \\sqrt{\\frac{2}{\\pi}} \\frac{1}{a^3} v^2 \\exp\\left(-\\frac{v^2}{2a^2}\\right) $$\nThe problem defines the neighbor list lifetime $t$ as the time it takes for a particle with speed $v$ to travel a distance $\\Delta = s/2$ under the ballistic approximation $d(t) = vt$. Thus, the lifetime $t$ is a random variable related to the speed $v$ by the transformation:\n$$ t = \\frac{\\Delta}{v} \\implies v = \\frac{\\Delta}{t} $$\nSince $v \\ge 0$ and $\\Delta  0$, the domain for $t$ is $t  0$. We can find the PDF of $t$, denoted $g_T(t)$, using the change of variables formula for probability distributions:\n$$ g_T(t) = f_V(v(t)) \\left| \\frac{dv}{dt} \\right| $$\nThe Jacobian of the transformation is $\\left| \\frac{d}{dt}\\left(\\frac{\\Delta}{t}\\right) \\right| = \\left| -\\frac{\\Delta}{t^2} \\right| = \\frac{\\Delta}{t^2}$.\nSubstituting $v = \\Delta/t$ and the Jacobian into the formula for $g_T(t)$:\n$$ g_T(t) = \\left( \\sqrt{\\frac{2}{\\pi}} \\frac{1}{a^3} \\left(\\frac{\\Delta}{t}\\right)^2 \\exp\\left(-\\frac{(\\Delta/t)^2}{2a^2}\\right) \\right) \\cdot \\frac{\\Delta}{t^2} $$\n$$ g_T(t) = \\sqrt{\\frac{2}{\\pi}} \\frac{\\Delta^3}{a^3} \\frac{1}{t^4} \\exp\\left(-\\frac{\\Delta^2}{2a^2t^2}\\right) \\quad \\text{for } t  0 $$\nThis is the PDF for the neighbor list lifetime $t$.\n\n**Mean Lifetime $\\mathbb{E}[t]$**\n\nThe mean lifetime $\\mathbb{E}[t]$ can be calculated as a transformation of the random variable $V$:\n$$ \\mathbb{E}[t] = \\mathbb{E}\\left[\\frac{\\Delta}{v}\\right] = \\Delta \\, \\mathbb{E}\\left[\\frac{1}{v}\\right] $$\nWe compute the expectation of $1/v$:\n$$ \\mathbb{E}\\left[\\frac{1}{v}\\right] = \\int_0^\\infty \\frac{1}{v} f_V(v) dv = \\int_0^\\infty \\frac{1}{v} \\left( \\sqrt{\\frac{2}{\\pi}} \\frac{1}{a^3} v^2 \\exp\\left(-\\frac{v^2}{2a^2}\\right) \\right) dv $$\n$$ = \\sqrt{\\frac{2}{\\pi}} \\frac{1}{a^3} \\int_0^\\infty v \\exp\\left(-\\frac{v^2}{2a^2}\\right) dv $$\nLet $u = v^2/(2a^2)$, so $du = (v/a^2) dv$. The integral becomes:\n$$ \\int_0^\\infty v \\exp\\left(-\\frac{v^2}{2a^2}\\right) dv = a^2 \\int_0^\\infty e^{-u} du = a^2 [-e^{-u}]_0^\\infty = a^2(0 - (-1)) = a^2 $$\nSubstituting this back:\n$$ \\mathbb{E}\\left[\\frac{1}{v}\\right] = \\sqrt{\\frac{2}{\\pi}} \\frac{1}{a^3} (a^2) = \\sqrt{\\frac{2}{\\pi}} \\frac{1}{a} $$\nTherefore, the mean lifetime is:\n$$ \\mathbb{E}[t] = \\Delta \\sqrt{\\frac{2}{\\pi}} \\frac{1}{a} = \\Delta \\sqrt{\\frac{2m}{\\pi k_{\\mathrm{B}}T}} $$\n\n**Variance of Lifetime $\\mathrm{Var}(t)$**\n\nThe variance is given by $\\mathrm{Var}(t) = \\mathbb{E}[t^2] - (\\mathbb{E}[t])^2$. First, we find $\\mathbb{E}[t^2]$:\n$$ \\mathbb{E}[t^2] = \\mathbb{E}\\left[\\left(\\frac{\\Delta}{v}\\right)^2\\right] = \\Delta^2 \\, \\mathbb{E}\\left[\\frac{1}{v^2}\\right] $$\nWe compute the expectation of $1/v^2$:\n$$ \\mathbb{E}\\left[\\frac{1}{v^2}\\right] = \\int_0^\\infty \\frac{1}{v^2} f_V(v) dv = \\int_0^\\infty \\frac{1}{v^2} \\left( \\sqrt{\\frac{2}{\\pi}} \\frac{1}{a^3} v^2 \\exp\\left(-\\frac{v^2}{2a^2}\\right) \\right) dv $$\n$$ = \\sqrt{\\frac{2}{\\pi}} \\frac{1}{a^3} \\int_0^\\infty \\exp\\left(-\\frac{v^2}{2a^2}\\right) dv $$\nThis is half of a standard Gaussian integral, $\\int_0^\\infty \\exp(-x^2/(2\\sigma^2))dx = \\frac{1}{2}\\sqrt{2\\pi\\sigma^2}$. Here, $\\sigma=a$.\n$$ \\int_0^\\infty \\exp\\left(-\\frac{v^2}{2a^2}\\right) dv = \\frac{1}{2} \\sqrt{2\\pi a^2} = a\\sqrt{\\frac{\\pi}{2}} $$\nSubstituting this result:\n$$ \\mathbb{E}\\left[\\frac{1}{v^2}\\right] = \\sqrt{\\frac{2}{\\pi}} \\frac{1}{a^3} \\left( a\\sqrt{\\frac{\\pi}{2}} \\right) = \\frac{1}{a^2} $$\nSo, the second moment of $t$ is:\n$$ \\mathbb{E}[t^2] = \\Delta^2 \\frac{1}{a^2} = \\frac{\\Delta^2 m}{k_{\\mathrm{B}}T} $$\nFinally, we can find the variance:\n$$ \\mathrm{Var}(t) = \\mathbb{E}[t^2] - (\\mathbb{E}[t])^2 = \\frac{\\Delta^2}{a^2} - \\left(\\Delta \\sqrt{\\frac{2}{\\pi}} \\frac{1}{a}\\right)^2 = \\frac{\\Delta^2}{a^2} - \\frac{2\\Delta^2}{\\pi a^2} $$\n$$ \\mathrm{Var}(t) = \\frac{\\Delta^2}{a^2} \\left(1 - \\frac{2}{\\pi}\\right) = \\frac{\\Delta^2 m}{k_{\\mathrm{B}}T} \\left(1 - \\frac{2}{\\pi}\\right) $$\n\n### 2. Derivation of the Early Rebuild Probability\n\nThe local probability of an early rebuild, $P_{\\mathrm{early}}(\\mathbf{r})$, is the probability that the lifetime $t$ is less than a threshold time $t_{\\mathrm{thr}}$:\n$$ P_{\\mathrm{early}}(\\mathbf{r}) = P(t  t_{\\mathrm{thr}}) $$\nUsing the relation $t = \\Delta/v$, this condition becomes:\n$$ \\frac{\\Delta}{v}  t_{\\mathrm{thr}} \\iff v  \\frac{\\Delta}{t_{\\mathrm{thr}}} $$\nWe define a threshold speed $v_{\\mathrm{thr}} = \\Delta / t_{\\mathrm{thr}}$. The probability is then $P(v  v_{\\mathrm{thr}})$. This is calculated by integrating the Maxwell speed PDF from $v_{\\mathrm{thr}}$ to infinity, or more simply, as $1$ minus the cumulative distribution function (CDF) evaluated at $v_{\\mathrm{thr}}$:\n$$ P(v  v_{\\mathrm{thr}}) = 1 - F_V(v_{\\mathrm{thr}}) = 1 - \\int_0^{v_{\\mathrm{thr}}} f_V(v) dv $$\nThe CDF of the Maxwell speed distribution, $F_V(v)$, can be expressed in terms of the error function $\\mathrm{erf}(x) = \\frac{2}{\\sqrt{\\pi}}\\int_0^x e^{-z^2}dz$:\n$$ F_V(v) = \\mathrm{erf}\\left(\\frac{v}{\\sqrt{2}a}\\right) - \\sqrt{\\frac{2}{\\pi}}\\frac{v}{a}\\exp\\left(-\\frac{v^2}{2a^2}\\right) $$\nTherefore, the early rebuild probability is:\n$$ P_{\\mathrm{early}}(\\mathbf{r}) = 1 - \\left[ \\mathrm{erf}\\left(\\frac{v_{\\mathrm{thr}}}{\\sqrt{2}a}\\right) - \\sqrt{\\frac{2}{\\pi}}\\frac{v_{\\mathrm{thr}}}{a}\\exp\\left(-\\frac{v_{\\mathrm{thr}}^2}{2a^2}\\right) \\right] $$\nwhere $a=\\sqrt{k_{\\mathrm{B}}T(\\mathbf{r})/m}$ and $v_{\\mathrm{thr}} = \\Delta/t_{\\mathrm{thr}}$. This expression provides the required probability in terms of the given parameters.\n\n### 3. Implementation and Results\n\nThe derived formulae are implemented in a Python program to evaluate the specified test cases. For each region in a temperature field, local values for $\\mathbb{E}[t]$, $\\mathrm{Var}(t)$, and $P_{\\mathrm{early}}$ are computed. The program then finds regions where $P_{\\mathrm{early}}$ exceeds $p_{\\mathrm{cut}}$ and calculates the global mean lifetime and global variance of lifetimes as the arithmetic mean of their respective local values across all regions in the field, as defined in the problem. The final output is formatted as a list of lists containing the high-risk indices, global mean lifetime, and global variance of lifetime for each case.", "answer": "```python\nimport numpy as np\nfrom scipy.special import erf\n\ndef solve():\n    \"\"\"\n    Solves the Verlet list lifetime problem for the specified test cases.\n    \"\"\"\n    \n    # Define constants\n    K_B = 1.380649e-23  # Boltzmann constant in J/K\n\n    test_cases = [\n        # Case A\n        {\n            \"m\": 6.63e-26,  # kg\n            \"s\": 0.6e-9,    # m\n            \"t_thr\": 1.0e-12, # s\n            \"p_cut\": 0.6,\n            \"T_field\": np.array([\n                [200, 300, 200],\n                [300, 600, 300],\n                [200, 300, 200]\n            ])\n        },\n        # Case B\n        {\n            \"m\": 1.0e-25,\n            \"s\": 0.4e-9,\n            \"t_thr\": 0.8e-12,\n            \"p_cut\": 0.5,\n            \"T_field\": np.array([150, 200, 250, 300, 350])\n        },\n        # Case C\n        {\n            \"m\": 6.63e-26,\n            \"s\": 0.1e-9,\n            \"t_thr\": 0.5e-12,\n            \"p_cut\": 0.3,\n            \"T_field\": np.array([\n                [400, 400],\n                [700, 100]\n            ])\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        m = case[\"m\"]\n        s = case[\"s\"]\n        t_thr = case[\"t_thr\"]\n        p_cut = case[\"p_cut\"]\n        T_field = case[\"T_field\"]\n        \n        delta = s / 2.0\n        v_thr = delta / t_thr\n        \n        T_flat = T_field.flatten()\n        \n        local_means = []\n        local_vars = []\n        high_risk_indices = []\n        \n        for i, T in enumerate(T_flat):\n            # Parameter 'a' from the Maxwell distribution\n            # a^2 = k_B * T / m\n            a_sq = K_B * T / m\n            a = np.sqrt(a_sq)\n            \n            # --- 1. Local Mean and Variance of Lifetime ---\n            # E[t] = delta * sqrt(2/pi) * (1/a)\n            mean_t = delta * np.sqrt(2.0 / np.pi) / a\n            local_means.append(mean_t)\n            \n            # Var(t) = (delta^2 / a^2) * (1 - 2/pi)\n            var_t = (delta**2 / a_sq) * (1.0 - 2.0 / np.pi)\n            local_vars.append(var_t)\n            \n            # --- 2. Early Rebuild Probability ---\n            # P_early = 1 - CDF(v_thr)\n            # CDF(v) = erf(v / (sqrt(2)*a)) - sqrt(2/pi) * (v/a) * exp(-(v^2)/(2*a^2))\n            arg_erf = v_thr / (np.sqrt(2.0) * a)\n            term_exp = np.sqrt(2.0 / np.pi) * (v_thr / a) * np.exp(-arg_erf**2)\n            \n            cdf_v_thr = erf(arg_erf) - term_exp\n            p_early = 1.0 - cdf_v_thr\n            \n            if p_early  p_cut:\n                high_risk_indices.append(i)\n\n        # --- 3. Global Aggregation ---\n        global_mean_lifetime = np.mean(local_means)\n        global_variance_lifetime = np.mean(local_vars)\n        \n        result_tuple = (high_risk_indices, global_mean_lifetime, global_variance_lifetime)\n        all_results.append(result_tuple)\n\n    # --- Final Output Formatting ---\n    results_str_parts = []\n    for res in all_results:\n        indices_str = f'[{\",\".join(map(str, res[0]))}]'\n        mean_str = f'{res[1]:.7e}' # Use scientific notation for consistency\n        var_str = f'{res[2]:.7e}'\n        results_str_parts.append(f'[{indices_str},{mean_str},{var_str}]')\n    \n    final_output = f\"[{','.join(results_str_parts)}]\"\n    print(final_output)\n\nsolve()\n\n```", "id": "3460172"}, {"introduction": "While fixed-interval updates are simple, they can be highly inefficient, leading to many unnecessary rebuilds or the storage of \"wasted\" neighbor pairs that never interact. This exercise introduces a more intelligent, event-driven approach where the list is only rebuilt when a new interaction is imminent. By implementing and comparing both strategies in a system with predictable ballistic trajectories, you will gain a practical understanding of algorithmic efficiency and the core principles of discrete-event simulation in MD [@problem_id:3460151].", "problem": "Consider a dilute gas Molecular Dynamics (MD) system in which particles move ballistically between collisions, so that the position of particle $i$ with initial position $\\mathbf{r}_i(0)$ and velocity $\\mathbf{v}_i$ evolves as $\\mathbf{r}_i(t) = \\mathbf{r}_i(0) + \\mathbf{v}_i t$ according to Newton's first law. A neighbor list is used to restrict pairwise interactions to those within a cutoff radius. Let the cutoff radius be $r_{\\text{cut}}$ and the neighbor list radius be $r_{\\text{list}} = r_{\\text{cut}} + r_{\\text{skin}}$, where $r_{\\text{skin}}$ is a positive \"skin\" distance.\n\nDefine a \"wasted neighbor\" under a particular neighbor list refresh strategy as follows: at a refresh time $t_R$, the neighbor list $\\mathcal{L}(t_R)$ contains all particle pairs $(i,j)$ such that the Euclidean distance $d_{ij}(t_R) = \\|\\mathbf{r}_i(t_R) - \\mathbf{r}_j(t_R)\\|$ satisfies $d_{ij}(t_R) \\le r_{\\text{list}}$. Over the interval $[t_R, t_{R}^{+}]$ until the next refresh (or the final simulation time if there is no subsequent refresh), a pair $(i,j)$ counted in $\\mathcal{L}(t_R)$ is \"used\" if there exists a time $t \\in [t_R, t_{R}^{+}]$ such that $d_{ij}(t) \\le r_{\\text{cut}}$. Otherwise, it is \"wasted.\" The total wasted neighbors for a strategy over a simulation horizon is the sum of wasted pairs counted at each refresh time.\n\nYour task is to implement and compare two neighbor list refresh strategies in terms of total wasted neighbors over a fixed simulation horizon:\n\n1. A conventional fixed-interval strategy that refreshes the neighbor list at times $t_k = k \\tau$ for integers $k \\ge 0$ until the horizon time $T$, where $\\tau$ is a fixed refresh interval.\n\n2. A rare-event-driven strategy that refreshes the neighbor list only at times when an \"imminent collision\" is predicted. An imminent collision time for a pair $(i,j)$ is any entrance time $t_{\\text{enter}}$ such that there exists an interval $[t_{\\text{enter}}, t_{\\text{exit}}]$ with $t_{\\text{enter}} \\ge 0$ where $d_{ij}(t) \\le r_{\\text{cut}}$ for all $t \\in [t_{\\text{enter}}, t_{\\text{exit}}]$, derived from the ballistic kinematics and Euclidean geometry. The rare-event refresh times are the sorted unique set of all $t_{\\text{enter}}$ within $[0, T]$ across all pairs. At each such event time $t_{\\text{event}}$, the neighbor list is refreshed and the wasted neighbors are counted over the interval until the next event time (or $T$ if no further event occurs).\n\nStarting from the foundational kinematics $\\mathbf{r}_{ij}(t) = \\mathbf{r}_i(t) - \\mathbf{r}_j(t)$ and $\\mathbf{v}_{ij} = \\mathbf{v}_i - \\mathbf{v}_j$, and the Euclidean distance $d_{ij}(t) = \\|\\mathbf{r}_{ij}(t)\\|$, derive from first principles the conditions that determine whether and when $d_{ij}(t) \\le r_{\\text{cut}}$ for a pair, and implement algorithms to compute:\n- For each pair $(i,j)$, whether there is an interval of times $[t_{\\text{enter}}, t_{\\text{exit}}]$ with $t_{\\text{enter}} \\ge 0$ for which $d_{ij}(t) \\le r_{\\text{cut}}$, and to find $t_{\\text{enter}}$ and $t_{\\text{exit}}$ when it exists.\n- The neighbor lists at refresh times for each strategy, and the total number of wasted neighbors over the simulation horizon for each strategy.\n\nAssume two-dimensional motion with no boundary conditions and no force updates (pure ballistic trajectories). Use meters ($\\mathrm{m}$) for positions, meters per second ($\\mathrm{m/s}$) for velocities, and seconds ($\\mathrm{s}$) for time. The final outputs are total counts of wasted neighbors (integers) for each strategy per test case; no unit needs to be attached to the output numbers.\n\nImplement a single program that uses the following test suite of parameter values and initial conditions, each given as explicit arrays of positions and velocities:\n\n- Test Case $1$ (no collisions, static configuration):\n  - $N = 4$, $r_{\\text{cut}} = 0.5\\,\\mathrm{m}$, $r_{\\text{skin}} = 0.5\\,\\mathrm{m}$, $r_{\\text{list}} = 1.0\\,\\mathrm{m}$, $\\tau = 0.25\\,\\mathrm{s}$, $T = 1.0\\,\\mathrm{s}$.\n  - Positions: $\\big[(0.0, 0.0), (0.8, 0.0), (3.0, 0.0), (0.0, 3.0)\\big]\\,\\mathrm{m}$.\n  - Velocities: $\\big[(0.0, 0.0), (0.0, 0.0), (0.0, 0.0), (0.0, 0.0)\\big]\\,\\mathrm{m/s}$.\n\n- Test Case $2$ (one collision pair and one co-moving near neighbor):\n  - $N = 3$, $r_{\\text{cut}} = 0.5\\,\\mathrm{m}$, $r_{\\text{skin}} = 0.5\\,\\mathrm{m}$, $r_{\\text{list}} = 1.0\\,\\mathrm{m}$, $\\tau = 0.2\\,\\mathrm{s}$, $T = 2.0\\,\\mathrm{s}$.\n  - Positions: $\\big[(0.0, 0.0), (2.0, 0.0), (0.9, 0.3)\\big]\\,\\mathrm{m}$.\n  - Velocities: $\\big[(1.0, 0.0), (-1.0, 0.0), (1.0, 0.0)\\big]\\,\\mathrm{m/s}$.\n\n- Test Case $3$ (late collision beyond horizon, multiple co-moving near neighbors):\n  - $N = 5$, $r_{\\text{cut}} = 0.4\\,\\mathrm{m}$, $r_{\\text{skin}} = 0.6\\,\\mathrm{m}$, $r_{\\text{list}} = 1.0\\,\\mathrm{m}$, $\\tau = 0.1\\,\\mathrm{s}$, $T = 1.0\\,\\mathrm{s}$.\n  - Positions: $\\big[(0.0, 0.0), (1.4, 0.0), (0.6, 0.4), (3.0, 0.0), (0.0, 1.1)\\big]\\,\\mathrm{m}$.\n  - Velocities: $\\big[(0.5, 0.0), (-0.5, 0.0), (0.5, 0.0), (0.0, 0.0), (0.5, 0.0)\\big]\\,\\mathrm{m/s}$.\n\nFor each test case, compute:\n- The total number of wasted neighbors under the rare-event-driven strategy over $[0, T]$.\n- The total number of wasted neighbors under the fixed-interval strategy over $[0, T]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a two-element list $[W_{\\text{event}}, W_{\\text{fixed}}]$ with integer entries, in the order of the test cases. For example, the output format must be exactly like $[[w_1^{\\text{event}}, w_1^{\\text{fixed}}],[w_2^{\\text{event}}, w_2^{\\text{fixed}}],[w_3^{\\text{event}}, w_3^{\\text{fixed}}]]$ with no extra text.", "solution": "The problem requires the implementation and comparison of two distinct neighbor list refresh strategies in a two-dimensional molecular dynamics simulation with ballistic particle motion. The comparison is based on the total count of \"wasted neighbors\" over a simulation horizon $T$. A wasted neighbor is a pair of particles that is included in a neighbor list at a refresh time but does not come within the interaction cutoff radius $r_{\\text{cut}}$ before the next list refresh.\n\nTo solve this, we must first derive from first principles the conditions under which two particles interact, i.e., their distance falls below $r_{\\text{cut}}$.\n\n### First Principles: Derivation of Collision Times\n\nThe position of particle $i$ at time $t$ is given by the equation of ballistic motion:\n$$ \\mathbf{r}_i(t) = \\mathbf{r}_i(0) + \\mathbf{v}_i t $$\nwhere $\\mathbf{r}_i(0)$ is the initial position and $\\mathbf{v}_i$ is the constant velocity.\n\nThe relative position vector between particles $i$ and $j$ is $\\mathbf{r}_{ij}(t) = \\mathbf{r}_j(t) - \\mathbf{r}_i(t)$. Substituting the equation of motion:\n$$ \\mathbf{r}_{ij}(t) = (\\mathbf{r}_j(0) - \\mathbf{r}_i(0)) + (\\mathbf{v}_j - \\mathbf{v}_i)t $$\nLet's define the initial relative position $\\mathbf{r}_{ij,0} = \\mathbf{r}_j(0) - \\mathbf{r}_i(0)$ and the constant relative velocity $\\mathbf{v}_{ij} = \\mathbf{v}_j - \\mathbf{v}_i$. The relative position evolves as:\n$$ \\mathbf{r}_{ij}(t) = \\mathbf{r}_{ij,0} + \\mathbf{v}_{ij} t $$\nThe squared Euclidean distance between the particles is $d_{ij}^2(t) = \\|\\mathbf{r}_{ij}(t)\\|^2 = \\mathbf{r}_{ij}(t) \\cdot \\mathbf{r}_{ij}(t)$.\n$$ d_{ij}^2(t) = (\\mathbf{r}_{ij,0} + \\mathbf{v}_{ij} t) \\cdot (\\mathbf{r}_{ij,0} + \\mathbf{v}_{ij} t) = (\\mathbf{v}_{ij} \\cdot \\mathbf{v}_{ij})t^2 + 2(\\mathbf{r}_{ij,0} \\cdot \\mathbf{v}_{ij})t + (\\mathbf{r}_{ij,0} \\cdot \\mathbf{r}_{ij,0}) $$\nThis is a quadratic function of time, $d_{ij}^2(t) = At^2 + Bt + C$, where:\n- $A = \\mathbf{v}_{ij} \\cdot \\mathbf{v}_{ij} = \\|\\mathbf{v}_{ij}\\|^2$\n- $B = 2(\\mathbf{r}_{ij,0} \\cdot \\mathbf{v}_{ij})$\n- $C = \\mathbf{r}_{ij,0} \\cdot \\mathbf{r}_{ij,0} = \\|\\mathbf{r}_{ij,0}\\|^2$\n\nAn interaction, or \"collision,\" occurs when $d_{ij}(t) \\le r_{\\text{cut}}$, which is equivalent to $d_{ij}^2(t) \\le r_{\\text{cut}}^2$. We must solve the quadratic inequality:\n$$ At^2 + Bt + C \\le r_{\\text{cut}}^2 \\implies At^2 + Bt + (C - r_{\\text{cut}}^2) \\le 0 $$\nThe roots of the equation $At^2 + Bt + (C - r_{\\text{cut}}^2) = 0$ determine the time interval of the collision. Let's analyze the solutions based on the coefficients.\n\nCase 1: $A = 0$. This implies $\\mathbf{v}_{ij} = \\mathbf{0}$, meaning the particles have zero relative velocity. The inequality becomes $B t + (C - r_{\\text{cut}}^2) \\le 0$. Since $A=0$, $B = 2(\\mathbf{r}_{ij,0} \\cdot \\mathbf{0}) = 0$. The inequality simplifies to $C - r_{\\text{cut}}^2 \\le 0$, which means $\\|\\mathbf{r}_{ij,0}\\|^2 \\le r_{\\text{cut}}^2$. If this condition holds, the particles are always within the cutoff distance. If not, they are never within it.\n\nCase 2: $A  0$. The quadratic $f(t) = At^2 + Bt + (C - r_{\\text{cut}}^2)$ describes an upward-opening parabola. The inequality $f(t) \\le 0$ is satisfied between the real roots of $f(t)=0$. We find these roots using the quadratic formula, where the discriminant is $\\Delta = B^2 - 4A(C - r_{\\text{cut}}^2)$.\n- If $\\Delta  0$, the quadratic is always positive, meaning $d_{ij}^2(t)$ is always greater than $r_{\\text{cut}}^2$. No collision occurs. This corresponds to the case where the minimum distance of approach is greater than $r_{\\text{cut}}$.\n- If $\\Delta \\ge 0$, there are real roots $t_1 = \\frac{-B - \\sqrt{\\Delta}}{2A}$ and $t_2 = \\frac{-B + \\sqrt{\\Delta}}{2A}$. The collision occurs for all $t$ in the interval $[t_1, t_2]$.\n\nThe problem considers the simulation from $t=0$ onwards. The \"imminent collision time\" is the entrance time $t_{\\text{enter}} \\ge 0$.\n- If particles start inside the cutoff ($C \\le r_{\\text{cut}}^2$), the collision period starts at $t=0$. The entrance time relevant for the simulation is $t_{\\text{enter}} = 0$.\n- If particles start outside ($C  r_{\\text{cut}}^2$), they must be approaching for a collision to occur ($B  0$). If $\\Delta \\ge 0$, both roots $t_1, t_2$ will be positive. The entrance time is $t_{\\text{enter}} = t_1$.\n\nThe collision interval $[t_{\\text{enter}}, t_{\\text{exit}}]$ for $t \\ge 0$ can thus be determined for any pair of particles.\n\n### Algorithmic Design for Refresh Strategies\n\nWith the ability to determine the exact collision interval for any pair, we can now define the algorithms for both strategies.\n\n**1. Fixed-Interval Strategy**\nThis strategy refreshes the neighbor list at predetermined, regular time intervals.\n1.  **Generate Refresh Times**: The refresh times are $t_k = k \\tau$ for non-negative integers $k$ such that $k\\tau  T$. This creates a set of times $\\mathcal{T}_{\\text{fixed}} = \\{0, \\tau, 2\\tau, \\ldots\\}$.\n2.  **Iterate and Count**: Initialize total wasted pairs $W_{\\text{fixed}} = 0$. For each refresh time $t_R \\in \\mathcal{T}_{\\text{fixed}}$, define the subsequent check interval $[t_R, t_R^+]$, where $t_R^+$ is the next refresh time or $T$ if $t_R$ is the last one.\n    a.  **Build Neighbor List**: Construct $\\mathcal{L}(t_R) = \\{(i,j) \\mid d_{ij}(t_R) \\le r_{\\text{list}}, ij\\}$.\n    b.  **Check for Wasted Pairs**: For each pair $(i,j) \\in \\mathcal{L}(t_R)$:\n        i.  Determine the pair's collision interval $[t_{\\text{coll,start}}, t_{\\text{coll,end}}]$.\n        ii. If this interval does not exist, or if it does not overlap with the check interval $[t_R, t_R^+]$, the pair is \"wasted\". The overlap condition is $t_{\\text{coll,start}} \\le t_R^+$ and $t_R \\le t_{\\text{coll,end}}$.\n        iii. If the pair is wasted, increment $W_{\\text{fixed}}$.\n3.  The final result is the total count $W_{\\text{fixed}}$.\n\n**2. Rare-Event-Driven Strategy**\nThis strategy is adaptive, refreshing the neighbor list only when a collision is about to begin.\n1.  **Generate Refresh Times**: The refresh times are the set of all unique \"imminent collision\" times.\n    a.  For each pair of particles $(i,j)$, calculate its collision interval $[t_{\\text{coll,start}}, t_{\\text{coll,end}}]$ for $t \\ge 0$.\n    b.  The entrance time is $t_{\\text{enter}} = t_{\\text{coll,start}}$.\n    c.  Collect all such $t_{\\text{enter}}$ that fall within the simulation horizon, i.e., $0 \\le t_{\\text{enter}} \\le T$.\n    d.  The set of refresh times, $\\mathcal{T}_{\\text{event}}$, is the sorted, unique list of these collected times.\n2.  **Iterate and Count**: If $\\mathcal{T}_{\\text{event}}$ is empty, no neighbor lists are ever constructed, and the total wasted neighbor count $W_{\\text{event}}$ is $0$. Otherwise, proceed as with the fixed-interval strategy, but using the refresh times from $\\mathcal{T}_{\\text{event}}$. Initialize $W_{\\text{event}} = 0$ and for each $t_R \\in \\mathcal{T}_{\\text{event}}$:\n    a.  Define the check interval $[t_R, t_R^+]$.\n    b.  Construct the neighbor list $\\mathcal{L}(t_R)$.\n    c.  For each pair in $\\mathcal{L}(t_R)$, check if it is used in $[t_R, t_R^+]$. If not, increment $W_{\\text{event}}$.\n3.  The final result is the total count $W_{\\text{event}}$.\n\nThis rare-event-driven approach is designed to be more efficient by avoiding list builds when no new interactions are starting. It links the simulation's event-based nature (collisions) directly to the algorithm managing interaction calculations, a core principle of discrete-event simulation. In contrast, the fixed-interval strategy is simpler but may perform unnecessary work, leading to a higher count of wasted neighbors, particularly in dilute systems or when particle velocities are low.\n\nThe implementation will apply these algorithms to the provided test cases.", "answer": "```python\nimport numpy as np\n\ndef get_collision_interval(r_ij0, v_ij, r_cut):\n    \"\"\"\n    Calculates the time interval [t_enter, t_exit] during which two particles are\n    within r_cut of each other, for t = 0.\n    \"\"\"\n    r_cut_sq = r_cut**2\n    \n    # Coefficients for the quadratic equation of squared distance: At^2 + Bt + C\n    A = np.dot(v_ij, v_ij)\n    B = 2 * np.dot(r_ij0, v_ij)\n    C = np.dot(r_ij0, r_ij0)\n\n    # Floating point tolerance\n    tol = 1e-9\n\n    if A  tol:  # Relative velocity is zero\n        if C = r_cut_sq:\n            return 0.0, np.inf # Always colliding or starting inside\n        else:\n            return None # Never colliding\n\n    # Discriminant for the quadratic equation At^2 + Bt + (C - r_cut^2) = 0\n    delta = B**2 - 4 * A * (C - r_cut_sq)\n\n    if delta  0:\n        return None # No real roots, never collide\n\n    sqrt_delta = np.sqrt(delta)\n    \n    # Roots of the quadratic equation\n    t1 = (-B - sqrt_delta) / (2 * A)\n    t2 = (-B + sqrt_delta) / (2 * A)\n    \n    # We are interested in the interval for t = 0\n    if t2  -tol: # Collision is entirely in the past\n        return None\n    \n    t_enter = max(0.0, t1)\n    t_exit = t2\n    \n    return t_enter, t_exit\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Test Case 1\n        {\n            \"N\": 4, \"r_cut\": 0.5, \"r_skin\": 0.5, \"tau\": 0.25, \"T\": 1.0,\n            \"pos\": np.array([[0.0, 0.0], [0.8, 0.0], [3.0, 0.0], [0.0, 3.0]]),\n            \"vel\": np.array([[0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0]])\n        },\n        # Test Case 2\n        {\n            \"N\": 3, \"r_cut\": 0.5, \"r_skin\": 0.5, \"tau\": 0.2, \"T\": 2.0,\n            \"pos\": np.array([[0.0, 0.0], [2.0, 0.0], [0.9, 0.3]]),\n            \"vel\": np.array([[1.0, 0.0], [-1.0, 0.0], [1.0, 0.0]])\n        },\n        # Test Case 3\n        {\n            \"N\": 5, \"r_cut\": 0.4, \"r_skin\": 0.6, \"tau\": 0.1, \"T\": 1.0,\n            \"pos\": np.array([[0.0, 0.0], [1.4, 0.0], [0.6, 0.4], [3.0, 0.0], [0.0, 1.1]]),\n            \"vel\": np.array([[0.5, 0.0], [-0.5, 0.0], [0.5, 0.0], [0.0, 0.0], [0.5, 0.0]])\n        }\n    ]\n\n    final_results = []\n    tol = 1e-9\n\n    for case in test_cases:\n        N = case[\"N\"]\n        r_cut = case[\"r_cut\"]\n        r_list = case[\"r_cut\"] + case[\"r_skin\"]\n        r_list_sq = r_list**2\n        T = case[\"T\"]\n        tau = case[\"tau\"]\n        pos0 = case[\"pos\"]\n        vel = case[\"vel\"]\n\n        num_pairs = N * (N - 1) // 2\n        pairs = []\n        for i in range(N):\n            for j in range(i + 1, N):\n                pairs.append((i, j))\n        \n        collision_intervals = {}\n        for i, j in pairs:\n            r_ij0 = pos0[j] - pos0[i]\n            v_ij = vel[j] - vel[i]\n            interval = get_collision_interval(r_ij0, v_ij, r_cut)\n            collision_intervals[(i,j)] = interval\n\n        # Strategy 2: Rare-event-driven\n        event_times = []\n        for i, j in pairs:\n            interval = collision_intervals.get((i, j))\n            if interval:\n                t_enter, t_exit = interval\n                if t_enter = T + tol:\n                    event_times.append(t_enter)\n        \n        event_refresh_times = sorted(list(set(np.round(event_times, 9)))) # Round to handle float precision issues\n        \n        wasted_event = 0\n        if event_refresh_times:\n            for k, t_R in enumerate(event_refresh_times):\n                t_R_plus = event_refresh_times[k + 1] if k + 1  len(event_refresh_times) else T\n                \n                neighbor_list = []\n                for i, j in pairs:\n                    pos_i_t = pos0[i] + vel[i] * t_R\n                    pos_j_t = pos0[j] + vel[j] * t_R\n                    d_sq = np.sum((pos_j_t - pos_i_t)**2)\n                    if d_sq = r_list_sq + tol:\n                        neighbor_list.append((i,j))\n\n                for i, j in neighbor_list:\n                    coll_interval = collision_intervals.get((i,j))\n                    is_used = False\n                    if coll_interval:\n                        t_coll_start, t_coll_end = coll_interval\n                        if max(t_R, t_coll_start) = min(t_R_plus, t_coll_end) + tol:\n                            is_used = True\n                    if not is_used:\n                        wasted_event += 1\n        \n        # Strategy 1: Fixed-interval\n        fixed_refresh_times = np.arange(0, T, tau)\n        \n        wasted_fixed = 0\n        for k, t_R in enumerate(fixed_refresh_times):\n            t_R_plus = fixed_refresh_times[k + 1] if k + 1  len(fixed_refresh_times) else T\n            \n            neighbor_list = []\n            for i, j in pairs:\n                pos_i_t = pos0[i] + vel[i] * t_R\n                pos_j_t = pos0[j] + vel[j] * t_R\n                d_sq = np.sum((pos_j_t - pos_i_t)**2)\n                if d_sq = r_list_sq + tol:\n                    neighbor_list.append((i, j))\n\n            for i, j in neighbor_list:\n                coll_interval = collision_intervals.get((i,j))\n                is_used = False\n                if coll_interval:\n                    t_coll_start, t_coll_end = coll_interval\n                    if max(t_R, t_coll_start) = min(t_R_plus, t_coll_end) + tol:\n                        is_used = True\n                if not is_used:\n                    wasted_fixed += 1\n\n        final_results.append(f\"[{wasted_event},{wasted_fixed}]\")\n\n    print(f\"[{','.join(final_results)}]\")\n\nsolve()\n```", "id": "3460151"}, {"introduction": "Many important physical phenomena, from plastic deformation in crystals to the rheology of complex fluids, are studied in simulation boxes that are not simple cubes. This practice extends the concept of neighbor listing to triclinic and shearing periodic cells, where the geometry of the space itself is time-dependent. You will implement the correct minimal image convention for these complex geometries and derive a robust, conservative update condition that guarantees no interactions are missed, even as the simulation cell deforms [@problem_id:3460089].", "problem": "Implement a program that constructs Verlet neighbor lists in three-dimensional periodic simulation boxes that may be triclinic or undergoing Lees–Edwards shear, and that evaluates a conservative neighbor-list update condition that avoids topological neighbor errors. The program must apply consistent imaging rules for minimal-image distances in triclinic and sheared geometries and test whether the conservative update condition guarantees that no pair omitted from the neighbor list at the build time can become an interacting pair before the declared update time.\n\nStart from the following fundamental base and definitions:\n\n- Newtonian mechanics defines the particle positions $\\mathbf{x}_i(t) \\in \\mathbb{R}^3$ and velocities $\\mathbf{v}_i(t) \\in \\mathbb{R}^3$ through $\\mathrm{d}\\mathbf{x}_i/\\mathrm{d}t=\\mathbf{v}_i$. Over a short interval where forces are not explicitly integrated, assume linear kinematics $\\mathbf{x}_i(t)=\\mathbf{x}_i(0)+\\mathbf{v}_i\\,t$.\n\n- Periodic boundary conditions in a triclinic cell are represented by a time-dependent lattice deformation (cell) matrix $\\mathbf{H}(t) \\in \\mathbb{R}^{3\\times 3}$ that maps reduced (fractional) coordinates $\\mathbf{s}_i(t)\\in [0,1)^3$ to Cartesian positions via\n$$\n\\mathbf{x}_i(t) = \\mathbf{H}(t)\\,\\mathbf{s}_i(t).\n$$\nThe minimal-image displacement between particles $i$ and $j$ at time $t$ is\n$$\n\\mathbf{r}_{ij}(t) = \\mathbf{H}(t)\\,\\big(\\Delta \\mathbf{s}_{ij}(t) - \\mathbf{n}\\big),\n$$\nwhere $\\Delta \\mathbf{s}_{ij}(t)=\\mathbf{s}_j(t)-\\mathbf{s}_i(t)$ and $\\mathbf{n}\\in \\mathbb{Z}^3$ is the lattice-image integer vector that minimizes the Euclidean norm $\\|\\mathbf{r}_{ij}(t)\\|_2$.\n\n- Lees–Edwards shear uses a time-dependent shear strain $\\gamma(t)$ with shear applied in the $x$ direction proportional to the $y$ coordinate. A consistent choice of the cell matrix is\n$$\n\\mathbf{H}(t)=\\begin{bmatrix}\nL_x  \\gamma(t)\\,L_y  0\\\\\n0  L_y  0\\\\\n0  0  L_z\n\\end{bmatrix},\n$$\nwith $\\gamma(t)=\\gamma_0+\\dot{\\gamma}\\,t$, and $L_x$, $L_y$, $L_z$ constants.\n\n- A Verlet neighbor list at build time $t_0$ includes all unordered pairs $(i,j)$ for which the minimal-image distance at $t_0$ satisfies $\\|\\mathbf{r}_{ij}(t_0)\\|_2 \\le r_c+\\delta$, where $r_c$ is the interaction cutoff and $\\delta0$ is the skin distance.\n\n- A topological neighbor error occurs if there exists a pair $(i,j)$ such that $\\|\\mathbf{r}_{ij}(t_1)\\|_2 \\le r_c$ at some $t_1t_0$ but $(i,j)$ was not included in the neighbor list built at $t_0$.\n\nTask requirements:\n\n1) Imaging rule. Your program must implement a minimal-image rule for triclinic and sheared cells that is consistent with the above definition. To avoid ambiguities in skewed cells, you must implement the minimization over a fixed, finite stencil by checking all $\\mathbf{n}\\in\\{-1,0,1\\}^3$ around the nearest-integer central image in reduced coordinates and selecting the $\\mathbf{n}$ that yields the smallest $\\|\\mathbf{H}(t)\\,(\\Delta \\mathbf{s}_{ij}(t)-\\mathbf{n})\\|_2$.\n\n2) Conservative update condition. Derive and implement a sufficient condition that guarantees no topological neighbor error can occur up to time $t_1$ without rebuilding the neighbor list. Use only kinematics and matrix norms:\n   - Let $d_{\\max}(t_1)=\\max_i \\|\\mathbf{x}_i(t_1)-\\mathbf{x}_i(t_0)\\|_2$.\n   - Let $\\Delta \\mathbf{H}=\\mathbf{H}(t_1)-\\mathbf{H}(t_0)$ and $\\|\\cdot\\|_2$ denote the spectral norm.\n   - Use a conservative sufficient condition of the form\n$$\n2\\,d_{\\max}(t_1) + C_H(t_0,t_1)  \\delta,\n$$\n   where $C_H(t_0,t_1)$ is a bound derived from $\\|\\Delta \\mathbf{H}\\|_2$ that safely accounts for cell deformation and possible re-imaging. You must derive a valid expression for $C_H(t_0,t_1)$ from the base principles and implement it.\n\n3) Validation logic. For a given $t_1$, if the conservative condition indicates no update is needed, your program must verify by direct computation that no topological neighbor error occurs by comparing the set of neighbors within $r_c$ at $t_1$ to the neighbor list built at $t_0$. If the condition indicates an update is needed, then by definition no error occurs because you would rebuild; treat that case as successful for the purpose of the boolean result.\n\n4) Units. All quantities are non-dimensional; report all numerical outputs as pure numbers without units.\n\n5) Test suite. Implement the following four test cases exactly as specified. In each case, set $t_0=0$ and evaluate at the listed $t_1$. For each case, construct the neighbor list at $t_0$ using cutoff $r_c+\\delta$, apply the conservative update condition to decide whether an update is needed by $t_1$, and if no update is indicated, verify directly that no topological neighbor error occurs at $t_1$.\n\n- Test A (triclinic, static box, near-boundary fractional coordinates):\n  - Cell matrix $\\mathbf{H}(t)\\equiv \\mathbf{H}_0=\\begin{bmatrix}3.00.80.2\\\\0.02.50.5\\\\0.00.02.0\\end{bmatrix}$.\n  - Number of particles $N=3$ with reduced coordinates at $t_0$ given by $\\mathbf{s}_1=(0.49,0.49,0.49)$, $\\mathbf{s}_2=(0.51,0.52,0.48)$, $\\mathbf{s}_3=(0.10,0.10,0.10)$. Cartesian positions at $t_0$ are $\\mathbf{x}_i(0)=\\mathbf{H}_0\\,\\mathbf{s}_i$.\n  - Velocities $\\mathbf{v}_i=\\mathbf{0}$ for all $i$.\n  - Cutoff $r_c=1.2$, skin $\\delta=0.3$, evaluation time $t_1=5.0$.\n\n- Test B (Lees–Edwards shear, small deformation, zero velocities):\n  - $L_x=5.0$, $L_y=5.0$, $L_z=5.0$, $\\gamma_0=0.0$, $\\dot{\\gamma}=0.02$ so that $\\gamma(t)=0.02\\,t$.\n  - Number of particles $N=3$ with reduced coordinates at $t_0$ given by $\\mathbf{s}_1=(0.20,0.10,0.10)$, $\\mathbf{s}_2=(0.25,0.12,0.10)$, $\\mathbf{s}_3=(0.80,0.90,0.10)$. Cartesian positions at $t_0$ use $\\mathbf{H}(0)$.\n  - Velocities $\\mathbf{v}_i=\\mathbf{0}$ for all $i$.\n  - Cutoff $r_c=1.0$, skin $\\delta=0.5$, evaluation time $t_1=2.0$.\n\n- Test C (orthorhombic, particles move to cross the cutoff):\n  - Cell matrix $\\mathbf{H}(t)\\equiv \\mathrm{diag}(10.0,10.0,10.0)$.\n  - Number of particles $N=3$ with Cartesian positions at $t_0$: $\\mathbf{x}_1(0)=(0.0,0.0,0.0)$, $\\mathbf{x}_2(0)=(1.6,0.0,0.0)$, $\\mathbf{x}_3(0)=(5.0,5.0,5.0)$.\n  - Velocities: $\\mathbf{v}_1=(1.0,0.0,0.0)$, $\\mathbf{v}_2=(-1.0,0.0,0.0)$, $\\mathbf{v}_3=(0.0,0.0,0.0)$.\n  - Cutoff $r_c=1.0$, skin $\\delta=0.3$, evaluation time $t_1=0.4$.\n\n- Test D (Lees–Edwards shear, larger deformation triggers update):\n  - $L_x=8.0$, $L_y=8.0$, $L_z=8.0$, $\\gamma_0=0.0$, $\\dot{\\gamma}=0.1$ so that $\\gamma(t)=0.1\\,t$.\n  - Number of particles $N=3$ with reduced coordinates at $t_0$: $\\mathbf{s}_1=(0.15,0.15,0.15)$, $\\mathbf{s}_2=(0.35,0.35,0.35)$, $\\mathbf{s}_3=(0.75,0.75,0.25)$. Cartesian positions at $t_0$ use $\\mathbf{H}(0)$.\n  - Velocities $\\mathbf{v}_i=\\mathbf{0}$ for all $i$.\n  - Cutoff $r_c=1.0$, skin $\\delta=0.4$, evaluation time $t_1=2.0$.\n\nRequired outputs:\n\n- For each test case, output a single boolean indicating whether the conservative update strategy avoids topological neighbor errors up to $t_1$ under the specified conditions. Interpret as follows: if the conservative condition indicates an update is needed, output the boolean value $\\mathrm{True}$ (because updating avoids errors by construction); if it indicates no update is needed, output $\\mathrm{True}$ only if direct verification at $t_1$ confirms that no topological neighbor error occurs, otherwise $\\mathrm{False}$.\n\nFinal output format:\n\n- Your program should produce a single line of output containing the four boolean results in order for Tests A, B, C, D as a comma-separated list enclosed in square brackets, for example, $\\mathrm{[True,False,True,True]}$.", "solution": "The problem requires the implementation and validation of a conservative neighbor-list update strategy for molecular dynamics simulations in triclinic and shearing periodic cells. I will first derive the conservative update condition, then detail the step-by-step procedure for its implementation and validation against the provided test cases.\n\n### Derivation of the Conservative Update Condition\n\nA Verlet neighbor list built at time $t_0$ contains all particle pairs $(i,j)$ for which the minimal-image distance $\\|\\mathbf{r}_{ij}(t_0)\\|_2 \\le r_c + \\delta$, where $r_c$ is the interaction cutoff and $\\delta$ is the skin distance. A topological neighbor error occurs if, at a later time $t_1$, a pair $(i,j)$ not in the list (i.e., $\\|\\mathbf{r}_{ij}(t_0)\\|_2  r_c + \\delta$) is found to have a distance $\\|\\mathbf{r}_{ij}(t_1)\\|_2 \\le r_c$.\n\nTo prevent this, the neighbor list must be rebuilt before such an event can happen. A sufficient condition for avoiding a topological error is that for any pair $(i,j)$ not in the list, its distance at $t_1$ remains greater than $r_c$. The worst-case scenario is a pair just outside the skin region at $t_0$, with $\\|\\mathbf{r}_{ij}(t_0)\\|_2 = r_c + \\delta$. For this pair, we must guarantee that the decrease in their distance is less than $\\delta$.\n$$\n\\|\\mathbf{r}_{ij}(t_0)\\|_2 - \\|\\mathbf{r}_{ij}(t_1)\\|_2  \\delta\n$$\nThis can be ensured by bounding the maximum possible change in distance for any pair between $t_0$ and $t_1$. A conservative bound can be formed by summing the worst-case contributions from particle motion and cell deformation.\n\n$1$. **Contribution from Particle Motion**: The problem assumes linear kinematics in Cartesian space, $\\mathbf{x}_i(t) = \\mathbf{x}_i(0) + \\mathbf{v}_i t$. The displacement of particle $i$ over the interval $[t_0, t_1]$ is $\\Delta \\mathbf{x}_i = \\mathbf{x}_i(t_1) - \\mathbf{x}_i(t_0)$. The maximum displacement is $d_{\\max}(t_1) = \\max_i \\|\\Delta \\mathbf{x}_i\\|_2$. The change in distance between particles $i$ and $j$ due to their movements in a fixed metric is bounded by the sum of their displacements along the line connecting them. In the worst case, they move directly toward each other, so the maximum decrease in their separation distance is bounded by $\\|\\Delta \\mathbf{x}_i\\|_2 + \\|\\Delta \\mathbf{x}_j\\|_2 \\le 2d_{\\max}(t_1)$.\n\n$2$. **Contribution from Cell Deformation**: The cell deformation, represented by the change in the cell matrix from $\\mathbf{H}(t_0)$ to $\\mathbf{H}(t_1)$, alters the metric of the space. The minimal-image displacement is given by $\\mathbf{r}_{ij}(t) = \\mathbf{H}(t) \\mathbf{w}_{ij}(t)$, where $\\mathbf{w}_{ij}(t) = \\mathbf{s}_j(t) - \\mathbf{s}_i(t) - \\mathbf{n}_{ij}(t)$ is the minimal-image displacement in fractional coordinates. If we consider particles with fixed fractional coordinates, the change in their Cartesian separation vector is $\\Delta \\mathbf{r}_{ij} = (\\mathbf{H}(t_1) - \\mathbf{H}(t_0))\\mathbf{w}_{ij}(t_0) = \\Delta \\mathbf{H} \\mathbf{w}_{ij}(t_0)$. The change in distance is bounded by $\\|\\Delta\\mathbf{H} \\mathbf{w}_{ij}(t_0)\\|_2 \\le \\|\\Delta\\mathbf{H}\\|_2 \\|\\mathbf{w}_{ij}(t_0)\\|_2$.\n\nWe must find a bound for $\\|\\mathbf{w}_{ij}(t_0)\\|_2$. The problem specifies an imaging rule: the minimal image is found by checking integer vectors $\\mathbf{n}$ in a $3 \\times 3 \\times 3$ stencil around the nearest-integer image. Let $\\Delta \\mathbf{s} = \\mathbf{s}_j - \\mathbf{s}_i$. The nearest integer vector is $\\mathbf{n}_c = \\text{round}(\\Delta\\mathbf{s})$. The stencil checks vectors $\\mathbf{n} = \\mathbf{n}_c + \\mathbf{d}$ where $\\mathbf{d} \\in \\{-1,0,1\\}^3$. The fractional displacement vector is $\\mathbf{w} = \\Delta\\mathbf{s} - \\mathbf{n} = (\\Delta\\mathbf{s} - \\mathbf{n}_c) - \\mathbf{d}$. Each component of $\\Delta\\mathbf{s} - \\mathbf{n}_c$ is in $[-0.5, 0.5]$ by definition. Each component of $\\mathbf{d}$ is in $\\{-1,0,1\\}$. Therefore, each component of $\\mathbf{w}$ is bounded by $[-1.5, 1.5]$. The squared norm is thus bounded: $\\|\\mathbf{w}\\|_2^2 \\le 1.5^2 + 1.5^2 + 1.5^2 = 6.75$. This gives a maximal fractional vector magnitude of $S_{\\max} = \\sqrt{6.75} = 1.5\\sqrt{3}$.\n\nThe change in distance from cell deformation is therefore bounded by $C_H(t_0, t_1) = \\|\\Delta\\mathbf{H}\\|_2 S_{\\max}$. This term conservatively accounts for the stretching of space and the possibility of re-imaging due to the lattice deformation.\n\n**Sufficient Condition**: Combining these effects, the maximum possible decrease in distance is bounded by the sum of the maximum change from particle motion and the maximum change from cell deformation. A sufficient condition to ensure no topological errors occur is:\n$\n2 d_{\\max}(t_1) + C_H(t_0, t_1)  \\delta\n$\nwhere $C_H(t_0, t_1) = \\|\\mathbf{H}(t_1) - \\mathbf{H}(t_0)\\|_2 \\times 1.5\\sqrt{3}$.\n\n### Algorithmic Implementation\n\nThe validation for each test case proceeds as follows:\n\n1.  **Initialization**: Define the cell matrix $\\mathbf{H}(t)$, particle positions $\\mathbf{x}_i(0)$, velocities $\\mathbf{v}_i$, and parameters $r_c, \\delta, t_1$. For test cases where initial positions are given in fractional coordinates $\\mathbf{s}_i(0)$, compute $\\mathbf{x}_i(0) = \\mathbf{H}(0)\\mathbf{s}_i(0)$. Set $t_0=0$.\n\n2.  **Minimal-Image Distance Calculation**: A function `min_img_dist(p1, p2, H)` is implemented. Given two Cartesian position vectors and a cell matrix $\\mathbf{H}$, it computes the minimal-image distance by:\n    a. Calculating the inverse cell matrix $\\mathbf{H}^{-1}$.\n    b. Finding the fractional displacement $\\Delta \\mathbf{s} = \\mathbf{H}^{-1}(\\mathbf{p}_2 - \\mathbf{p}_1)$.\n    c. Finding the nearest-integer central image vector $\\mathbf{n}_c = \\text{round}(\\Delta\\mathbf{s})$.\n    d. Iterating through the $27$ image vectors $\\mathbf{n} = \\mathbf{n}_c + \\mathbf{d}$ where $\\mathbf{d} \\in \\{-1,0,1\\}^3$. For each $\\mathbf{n}$, calculate the squared norm of the trial displacement vector $\\mathbf{r} = \\mathbf{H}(\\Delta\\mathbf{s} - \\mathbf{n})$.\n    e. The function returns the square root of the minimum squared norm found.\n\n3.  **Neighbor List Construction at $t_0$**: A neighbor list, `nlist_t0`, is constructed. It stores all unordered pairs $(i,j)$ for which `min_img_dist`$(\\mathbf{x}_i(0), \\mathbf{x}_j(0), \\mathbf{H}(0)) \\le r_c + \\delta$.\n\n4.  **Evaluate Update Condition**:\n    a. Calculate the final positions $\\mathbf{x}_i(t_1) = \\mathbf{x}_i(0) + \\mathbf{v}_i t_1$.\n    b. Compute $d_{\\max}(t_1) = t_1 \\max_i \\|\\mathbf{v}_i\\|_2$.\n    c. Compute the final cell matrix $\\mathbf{H}(t_1)$ and the change $\\Delta\\mathbf{H} = \\mathbf{H}(t_1) - \\mathbf{H}(0)$.\n    d. Compute the spectral norm $\\|\\Delta\\mathbf{H}\\|_2$.\n    e. Evaluate the condition $2 d_{\\max}(t_1) + \\|\\Delta\\mathbf{H}\\|_2 \\times 1.5\\sqrt{3}  \\delta$. If the inequality is false, an update is deemed necessary (`needs_update = True`).\n\n5.  **Final Validation and Output**:\n    a. If `needs_update` is `True`, the strategy is successful by definition (an update would prevent errors). The result for the test case is `True`.\n    b. If `needs_update` is `False`, a direct check is performed. Iterate through all pairs $(i,j)$ that are *not* in `nlist_t0`. For each such pair, calculate their distance at $t_1$, $d_{ij}(t_1) = \\text{min_img_dist}(\\mathbf{x}_i(t_1), \\mathbf{x}_j(t_1), \\mathbf{H}(t_1))$. If $d_{ij}(t_1) \\le r_c$ for any such pair, a topological error has occurred. The result is `True` if no such error is found, and `False` otherwise.\n\nThis complete procedure is applied to each of the four test cases specified in the problem.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for Verlet list update strategy.\n    \n    The program implements and validates a conservative neighbor-list update condition\n    for molecular dynamics simulations in triclinic and shearing periodic cells.\n    \"\"\"\n\n    def get_h_matrix(case, t):\n        \"\"\"Computes the cell matrix H at a given time t for a test case.\"\"\"\n        if case['type'] == 'triclinic':\n            return case['H0']\n        elif case['type'] == 'orthorhombic':\n            return case['H0']\n        elif case['type'] == 'lees_edwards':\n            L_x, L_y, L_z = case['L']\n            gamma = case['gamma0'] + case['gamma_dot'] * t\n            return np.array([\n                [L_x, gamma * L_y, 0.0],\n                [0.0, L_y, 0.0],\n                [0.0, 0.0, L_z]\n            ])\n        return None\n\n    def min_img_dist(p1, p2, H):\n        \"\"\"\n        Calculates the minimal-image distance between two particles in a triclinic cell.\n        Uses the specified 27-image stencil check method.\n        \n        Args:\n            p1 (np.ndarray): Cartesian position of particle 1.\n            p2 (np.ndarray): Cartesian position of particle 2.\n            H (np.ndarray): 3x3 cell matrix.\n            \n        Returns:\n            float: The minimal-image distance.\n        \"\"\"\n        try:\n            H_inv = np.linalg.inv(H)\n        except np.linalg.LinAlgError:\n            return np.inf\n\n        # Fractional displacement vector\n        ds = H_inv @ (p2 - p1)\n        \n        # Central image integer vector\n        n_c = np.round(ds)\n        \n        min_dist_sq = np.inf\n        \n        # Iterate over the 3x3x3=27 images in the stencil around the central image\n        for i in range(-1, 2):\n            for j in range(-1, 2):\n                for k in range(-1, 2):\n                    d = np.array([i, j, k])\n                    n = n_c + d\n                    # Cartesian displacement vector for this image\n                    r_vec = H @ (ds - n)\n                    dist_sq = r_vec.dot(r_vec)\n                    if dist_sq  min_dist_sq:\n                        min_dist_sq = dist_sq\n                        \n        return np.sqrt(min_dist_sq)\n\n    def run_test(case):\n        \"\"\"Runs a single test case and returns the boolean result.\"\"\"\n        t0 = 0.0\n        t1 = case['t1']\n        rc = case['rc']\n        delta = case['delta']\n        \n        # 1. Initialization\n        H0 = get_h_matrix(case, t0)\n        \n        if 's0' in case:\n            x0 = np.array([H0 @ s for s in case['s0']])\n        else:\n            x0 = case['x0']\n        \n        v = case['v']\n        num_particles = len(x0)\n        \n        # 2. Build neighbor list at t0\n        nlist_t0 = set()\n        for i in range(num_particles):\n            for j in range(i + 1, num_particles):\n                dist_t0 = min_img_dist(x0[i], x0[j], H0)\n                if dist_t0 = rc + delta:\n                    nlist_t0.add(tuple(sorted((i, j))))\n\n        # 3. Check conservative update condition\n        # Kinematics\n        x1 = x0 + v * t1\n        H1 = get_h_matrix(case, t1)\n        \n        # Max particle displacement\n        if v.shape[0]  0:\n            d_max = t1 * np.max(np.linalg.norm(v, axis=1))\n        else:\n            d_max = 0.0\n            \n        # Box deformation term\n        delta_H = H1 - H0\n        norm_delta_H = np.linalg.norm(delta_H, 2)\n        S_max = 1.5 * np.sqrt(3.0)\n        C_H = norm_delta_H * S_max\n        \n        # Evaluate condition\n        needs_update = (2 * d_max + C_H = delta)\n        \n        if needs_update:\n            return True\n            \n        # 4. If no update needed, perform direct verification\n        topological_error_found = False\n        for i in range(num_particles):\n            for j in range(i + 1, num_particles):\n                if tuple(sorted((i, j))) not in nlist_t0:\n                    dist_t1 = min_img_dist(x1[i], x1[j], H1)\n                    if dist_t1 = rc:\n                        topological_error_found = True\n                        break\n            if topological_error_found:\n                break\n                \n        return not topological_error_found\n\n    test_cases = [\n        # Test A: Triclinic, static, near-boundary\n        {\n            'type': 'triclinic',\n            'H0': np.array([[3.0, 0.8, 0.2], [0.0, 2.5, 0.5], [0.0, 0.0, 2.0]]),\n            's0': np.array([[0.49, 0.49, 0.49], [0.51, 0.52, 0.48], [0.10, 0.10, 0.10]]),\n            'v': np.zeros((3, 3)),\n            'rc': 1.2, 'delta': 0.3, 't1': 5.0\n        },\n        # Test B: Lees-Edwards, small deformation\n        {\n            'type': 'lees_edwards',\n            'L': (5.0, 5.0, 5.0), 'gamma0': 0.0, 'gamma_dot': 0.02,\n            's0': np.array([[0.20, 0.10, 0.10], [0.25, 0.12, 0.10], [0.80, 0.90, 0.10]]),\n            'v': np.zeros((3, 3)),\n            'rc': 1.0, 'delta': 0.5, 't1': 2.0\n        },\n        # Test C: Orthorhombic, particles move\n        {\n            'type': 'orthorhombic',\n            'H0': np.diag([10.0, 10.0, 10.0]),\n            'x0': np.array([[0.0, 0.0, 0.0], [1.6, 0.0, 0.0], [5.0, 5.0, 5.0]]),\n            'v': np.array([[1.0, 0.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 0.0]]),\n            'rc': 1.0, 'delta': 0.3, 't1': 0.4\n        },\n        # Test D: Lees-Edwards, larger deformation\n        {\n            'type': 'lees_edwards',\n            'L': (8.0, 8.0, 8.0), 'gamma0': 0.0, 'gamma_dot': 0.1,\n            's0': np.array([[0.15, 0.15, 0.15], [0.35, 0.35, 0.35], [0.75, 0.75, 0.25]]),\n            'v': np.zeros((3, 3)),\n            'rc': 1.0, 'delta': 0.4, 't1': 2.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_test(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3460089"}]}