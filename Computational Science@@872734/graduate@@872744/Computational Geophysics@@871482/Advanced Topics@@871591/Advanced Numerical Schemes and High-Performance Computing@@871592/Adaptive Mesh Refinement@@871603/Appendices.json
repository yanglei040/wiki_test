{"hands_on_practices": [{"introduction": "When a new, finer grid is created in an AMR simulation, it must be initialized with data consistent with the parent coarse grid. This process, known as prolongation, is not a simple interpolation; it must be done carefully to conserve physical quantities and avoid introducing spurious oscillations, especially near sharp features like shocks or contact discontinuities. This exercise [@problem_id:3503480] guides you through the implementation of a robust prolongation method based on piecewise linear reconstruction with slope limiters, a cornerstone technique for high-fidelity data transfer between grid levels.", "problem": "Consider a one-dimensional finite volume representation of density for a compressible flow with a contact discontinuity in a computational astrophysics context. Adaptive Mesh Refinement (AMR) aims to construct fine-level initial data from coarse-level cell averages while preserving conservation and avoiding spurious extrema. The fundamental base is the finite volume definition of a cell average and Total Variation Diminishing (TVD) reconstruction with slope limiters.\n\nLet the coarse-level grid be uniform with cell centers at $x_i$ and width $\\Delta x$. The coarse-level cell-average density is $\\bar{\\rho}_i = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} \\rho(x)\\,dx$. For prolongation, each coarse cell $i$ is subdivided into $r$ fine subcells indexed by $j \\in \\{0,1,\\dots,r-1\\}$, each of width $\\Delta x / r$. Use a piecewise linear reconstruction within each coarse cell $i$,\n$$\n\\rho_i(x) = \\bar{\\rho}_i + s_i \\frac{x - x_i}{\\Delta x},\n$$\nwhere $s_i$ is a limited slope computed from neighboring coarse averages to enforce the TVD property. Define backward and forward differences\n$$\n\\Delta_- = \\bar{\\rho}_i - \\bar{\\rho}_{i-1}, \\quad \\Delta_+ = \\bar{\\rho}_{i+1} - \\bar{\\rho}_i,\n$$\nand the following slope limiters:\n- Minmod limiter: $\\mathrm{mm}(a,b) = \\begin{cases}\\mathrm{sign}(a)\\min(|a|,|b|),  ab > 0, \\\\ 0,  \\text{otherwise.}\\end{cases}$ with $s_i = \\mathrm{mm}(\\Delta_-,\\Delta_+)$.\n- Monotonized Central (MC) limiter: $s_i = \\mathrm{mm}_3\\left(\\frac{\\Delta_- + \\Delta_+}{2}, 2\\Delta_-, 2\\Delta_+\\right)$ where $\\mathrm{mm}_3(a,b,c)$ returns $\\mathrm{sign}(a)\\min(|a|,|b|,|c|)$ if $ab0$ and $ac0$, and $0$ otherwise.\n- Van Leer limiter: $s_i = \\begin{cases}\\frac{2\\Delta_- \\Delta_+}{\\Delta_- + \\Delta_+},  \\Delta_- \\Delta_+ > 0, \\\\ 0,  \\text{otherwise.}\\end{cases}$.\n\nAt domain boundaries, where a neighbor is unavailable, set $s_i = 0$ to remain conservative. The subcell-average density for subcell $j$ inside coarse cell $i$ is\n$$\n\\bar{\\rho}_{i,j} = \\frac{r}{\\Delta x}\\int_{x_{i-1/2} + \\frac{j}{r}\\Delta x}^{x_{i-1/2} + \\frac{j+1}{r}\\Delta x} \\rho_i(x)\\,dx.\n$$\nFor the piecewise linear $\\rho_i(x)$ above, the subcell average equals the value at the subcell midpoint, yielding\n$$\n\\bar{\\rho}_{i,j} = \\bar{\\rho}_i + s_i\\,c_j,\\quad c_j = \\left(\\frac{j+\\frac{1}{2}}{r} - \\frac{1}{2}\\right).\n$$\nTo avoid spurious extrema at contact discontinuities, impose a bound-preserving clipping for each coarse cell $i$ with local bounds\n$$\n\\rho_{\\min,i} = \\min\\{\\bar{\\rho}_{i-1},\\bar{\\rho}_i,\\bar{\\rho}_{i+1}\\},\\quad \\rho_{\\max,i} = \\max\\{\\bar{\\rho}_{i-1},\\bar{\\rho}_i,\\bar{\\rho}_{i+1}\\},\n$$\nusing only available neighbors at boundaries. Enforce\n$$\n\\bar{\\rho}_{i,j} \\leftarrow \\min\\left(\\rho_{\\max,i}, \\max\\left(\\rho_{\\min,i}, \\bar{\\rho}_{i,j}\\right)\\right).\n$$\n\nImplement a program that:\n1. Computes limited slopes $s_i$ according to a specified limiter.\n2. Computes fine-level subcell averages $\\bar{\\rho}_{i,j}$ for a given refinement ratio $r$ using the formula above.\n3. Applies the bound-preserving clipping per coarse cell.\n4. Outputs the refined subcell averages for each test case as a list of floats.\n\nAll densities are in dimensionless code units; no physical unit conversion is required. Angles are not involved. The program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a bracketed comma-separated list of the refined cell-average densities for the corresponding test case, with no spaces. For example: $[[a_1,a_2,\\dots],[b_1,b_2,\\dots]]$.\n\nUse the following test suite, designed to cover smooth behavior, sharp contact discontinuity, oscillatory patterns, and boundary effects:\n- Test $1$ (smooth monotone increase, Minmod, $r=2$): coarse averages $\\left[\\,1.0,\\,1.1,\\,1.2,\\,1.3\\,\\right]$.\n- Test $2$ (contact discontinuity, MC, $r=2$): coarse averages $\\left[\\,1.0,\\,1.0,\\,5.0,\\,5.0\\,\\right]$.\n- Test $3$ (oscillatory pattern, Van Leer, $r=4$): coarse averages $\\left[\\,3.0,\\,1.0,\\,3.0,\\,1.0\\,\\right]$.\n- Test $4$ (isolated jump with symmetric neighbors, Minmod, $r=2$): coarse averages $\\left[\\,0.5,\\,0.5,\\,2.0,\\,0.5,\\,0.5\\,\\right]$.\n\nFor each test case, the output should be the flattened fine-level list $\\left[\\,\\bar{\\rho}_{0,0},\\dots,\\bar{\\rho}_{0,r-1},\\bar{\\rho}_{1,0},\\dots,\\bar{\\rho}_{1,r-1},\\dots\\,\\right]$ in the specified format. The final output must be a single line of the form $[ \\text{case1\\_list}, \\text{case2\\_list}, \\text{case3\\_list}, \\text{case4\\_list} ]$ with no spaces anywhere.", "solution": "The problem statement is assessed as valid. It presents a well-defined computational task grounded in established principles of numerical methods for fluid dynamics, specifically concerning Adaptive Mesh Refinement (AMR). The provided formulas for piecewise linear reconstruction, slope limiters, and subcell averaging are standard and correct. The problem is self-contained, with all necessary data and boundary conditions specified, enabling a unique solution for each test case.\n\nThe procedure to prolong coarse-level cell-average densities, $\\bar{\\rho}_i$, to a refined grid with a refinement ratio $r$ involves three primary steps: slope calculation, subcell average computation, and bound-preserving clipping.\n\n### 1. Limited Slope Calculation\nFor each coarse cell $i$, a slope $s_i$ is computed to define a piecewise linear reconstruction, $\\rho_i(x) = \\bar{\\rho}_i + s_i \\frac{x - x_i}{\\Delta x}$, where $x_i$ is the center of cell $i$ and $\\Delta x$ is its width. To prevent the introduction of spurious oscillations near sharp features (a property known as Total Variation Diminishing or TVD), the slope $s_i$ is limited based on the local data.\n\nThe calculation depends on the cell's position:\n-   **Boundary Cells**: For the first ($i=0$) and last ($i=N-1$) cells in the domain, a full set of neighbors is unavailable. To maintain a conservative and simple treatment, the slope is set to zero, i.e., $s_0 = 0$ and $s_{N-1} = 0$. This corresponds to a piecewise constant reconstruction at the boundaries.\n-   **Interior Cells**: For any interior cell $i$, the slope is determined by its immediate neighbors. We first compute the backward and forward differences:\n    $$\n    \\Delta_- = \\bar{\\rho}_i - \\bar{\\rho}_{i-1} \\quad ; \\quad \\Delta_+ = \\bar{\\rho}_{i+1} - \\bar{\\rho}_i\n    $$\n    These differences are then passed to a slope limiter function. The problem specifies three such limiters:\n\n    1.  **Minmod Limiter**: This is the most dissipative limiter, which strongly suppresses oscillations. The slope is given by:\n        $$\n        s_i = \\mathrm{mm}(\\Delta_-, \\Delta_+) = \\begin{cases}\\mathrm{sign}(\\Delta_-)\\min(|\\Delta_-|,|\\Delta_+|),  \\Delta_- \\Delta_+ > 0 \\\\ 0,  \\text{otherwise}\\end{cases}\n        $$\n        The slope is non-zero only if the data is locally monotonic (i.e., $\\Delta_-$ and $\\Delta_+$ have the same sign). At local extrema, the slope is zero.\n\n    2.  **Monotonized Central (MC) Limiter**: This limiter is designed to be more accurate in smooth regions than Minmod. It is defined using a three-argument minmod function:\n        $$\n        s_i = \\mathrm{mm}_3\\left(\\frac{\\Delta_- + \\Delta_+}{2}, 2\\Delta_-, 2\\Delta_+\\right)\n        $$\n        where $\\mathrm{mm}_3(a,b,c)$ returns $\\mathrm{sign}(a)\\min(|a|,|b|,|c|)$ if $a, b, c$ all have the same sign, and $0$ otherwise. This limiter considers the central difference slope, $(\\Delta_- + \\Delta_+)/2$, and limits it by twice the one-sided differences.\n\n    3.  **Van Leer Limiter**: This limiter offers a smooth transition between the one-sided differences and is known for providing good resolution of contact discontinuities. It is the harmonic mean of the two differences:\n        $$\n        s_i = \\begin{cases}\\frac{2\\Delta_- \\Delta_+}{\\Delta_- + \\Delta_+},  \\Delta_- \\Delta_+ > 0 \\\\ 0,  \\text{otherwise}\\end{cases}\n        $$\n\n### 2. Subcell Average Prolongation\nOnce the slope $s_i$ for each coarse cell $i$ is known, we can determine the average density, $\\bar{\\rho}_{i,j}$, for each of the $r$ subcells within it. A subcell is indexed by $j \\in \\{0, 1, \\dots, r-1\\}$. The average value of a linear function over an interval is equal to the function's value at the interval's midpoint. This simplifies the integral definition to an algebraic one. The midpoint of subcell $j$ in coarse cell $i$ is offset from the coarse cell center $x_i$ by a distance factor. This leads to the formula:\n$$\n\\bar{\\rho}_{i,j} = \\bar{\\rho}_i + s_i\\,c_j\n$$\nwhere the coefficient $c_j$ depends only on the subcell index $j$ and the refinement ratio $r$:\n$$\nc_j = \\left(\\frac{j+\\frac{1}{2}}{r} - \\frac{1}{2}\\right)\n$$\nThese coefficients represent the normalized distance of each subcell's center from the parent cell's center. For example, for $r=2$, we have $c_0 = -0.25$ and $c_1 = 0.25$.\n\n### 3. Bound-Preserving Clipping\nThe TVD slope limiters are designed to prevent the reconstructed point values at cell interfaces from creating new extrema. However, to strictly enforce that the new *cell averages* also do not create new local extrema, an additional clipping step is applied. For each coarse cell $i$, we define local bounds based on the cell average itself and its available neighbors:\n$$\n\\rho_{\\min,i} = \\min\\{\\bar{\\rho}_{k} \\mid k \\in \\{i-1, i, i+1\\} \\cap [0, N-1]\\}\n$$\n$$\n\\rho_{\\max,i} = \\max\\{\\bar{\\rho}_{k} \\mid k \\in \\{i-1, i, i+1\\} \\cap [0, N-1]\\}\n$$\nFor a boundary cell $i=0$, the neighborhood is $\\{0, 1\\}$. For an interior cell, it is $\\{i-1, i, i+1\\}$.\n\nEach computed subcell average $\\bar{\\rho}_{i,j}$ is then forced to lie within these bounds:\n$$\n\\bar{\\rho}_{i,j} \\leftarrow \\min\\left(\\rho_{\\max,i}, \\max\\left(\\rho_{\\min,i}, \\bar{\\rho}_{i,j}\\right)\\right)\n$$\nThis ensures that the refined data field remains locally bounded by the original coarse data, which is crucial for stability and physical realism, especially at contact discontinuities.\n\n### Example Walkthrough: Test Case 1\n-   **Input**: Coarse averages $\\bar{\\rho} = [1.0, 1.1, 1.2, 1.3]$, Limiter: Minmod, $r=2$.\n-   **Slopes**:\n    -   $s_0 = 0$ (boundary).\n    -   $i=1$: $\\Delta_- = 1.1-1.0=0.1$, $\\Delta_+ = 1.2-1.1=0.1$. $\\mathrm{mm}(0.1, 0.1) = 0.1$. So, $s_1=0.1$.\n    -   $i=2$: $\\Delta_- = 1.2-1.1=0.1$, $\\Delta_+ = 1.3-1.2=0.1$. $\\mathrm{mm}(0.1, 0.1) = 0.1$. So, $s_2=0.1$.\n    -   $s_3 = 0$ (boundary).\n    -   The slope vector is $s = [0, 0.1, 0.1, 0]$.\n-   **Subcell Averages ($r=2 \\implies c_0=-0.25, c_1=0.25$)**:\n    -   $i=0$: $\\bar{\\rho}_{0,0} = 1.0 + 0 \\cdot (-0.25) = 1.0$; $\\bar{\\rho}_{0,1} = 1.0 + 0 \\cdot (0.25) = 1.0$.\n    -   $i=1$: $\\bar{\\rho}_{1,0} = 1.1 + 0.1 \\cdot (-0.25) = 1.075$; $\\bar{\\rho}_{1,1} = 1.1 + 0.1 \\cdot (0.25) = 1.125$.\n    -   $i=2$: $\\bar{\\rho}_{2,0} = 1.2 + 0.1 \\cdot (-0.25) = 1.175$; $\\bar{\\rho}_{2,1} = 1.2 + 0.1 \\cdot (0.25) = 1.225$.\n    -   $i=3$: $\\bar{\\rho}_{3,0} = 1.3 + 0 \\cdot (-0.25) = 1.3$; $\\bar{\\rho}_{3,1} = 1.3 + 0 \\cdot (0.25) = 1.3$.\n-   **Clipping**:\n    -   $i=0$: Bounds are $[\\min(1.0, 1.1), \\max(1.0, 1.1)] = [1.0, 1.1]$. Values $[1.0, 1.0]$ are within bounds.\n    -   $i=1$: Bounds are $[\\min(1.0, 1.1, 1.2), \\max(1.0, 1.1, 1.2)] = [1.0, 1.2]$. Values $[1.075, 1.125]$ are within bounds.\n    -   $i=2$: Bounds are $[\\min(1.1, 1.2, 1.3), \\max(1.1, 1.2, 1.3)] = [1.1, 1.3]$. Values $[1.175, 1.225]$ are within bounds.\n    -   $i=3$: Bounds are $[\\min(1.2, 1.3), \\max(1.2, 1.3)] = [1.2, 1.3]$. Values $[1.3, 1.3]$ are within bounds.\n    -   In this case, the clipping step does not change any values, as the Minmod limiter already ensures the reconstruction is non-oscillatory.\n-   **Final Result**: The flattened list of fine-cell averages is $[1.0, 1.0, 1.075, 1.125, 1.175, 1.225, 1.3, 1.3]$.", "answer": "```python\nimport numpy as np\n\ndef minmod_limiter(delta_minus, delta_plus):\n    \"\"\"Computes the Minmod limited slope.\"\"\"\n    if delta_minus * delta_plus  0:\n        return np.sign(delta_minus) * min(abs(delta_minus), abs(delta_plus))\n    return 0.0\n\ndef mm3(a, b, c):\n    \"\"\"Generalized minmod function for three arguments.\"\"\"\n    sa, sb, sc = np.sign(a), np.sign(b), np.sign(c)\n    if sa == sb and sa == sc:\n        return sa * min(abs(a), abs(b), abs(c))\n    return 0.0\n\ndef mc_limiter(delta_minus, delta_plus):\n    \"\"\"Computes the Monotonized Central (MC) limited slope.\"\"\"\n    return mm3((delta_minus + delta_plus) / 2.0, 2.0 * delta_minus, 2.0 * delta_plus)\n\ndef van_leer_limiter(delta_minus, delta_plus):\n    \"\"\"Computes the Van Leer limited slope.\"\"\"\n    if delta_minus * delta_plus  0:\n        # The check for d- * d+  0 prevents division by zero,\n        # as d- + d+ could only be zero if both were zero.\n        return (2.0 * delta_minus * delta_plus) / (delta_minus + delta_plus)\n    return 0.0\n\ndef process_case(coarse_rho, limiter_name, r):\n    \"\"\"\n    Performs AMR prolongation for a given set of coarse cell averages.\n\n    Args:\n        coarse_rho (list[float]): The coarse-level cell averages.\n        limiter_name (str): The name of the slope limiter to use ('Minmod', 'MC', 'Van Leer').\n        r (int): The refinement ratio.\n\n    Returns:\n        list[float]: The flattened list of fine-level cell averages after clipping.\n    \"\"\"\n    limiter_funcs = {\n        'Minmod': minmod_limiter,\n        'MC': mc_limiter,\n        'Van Leer': van_leer_limiter\n    }\n    \n    n_coarse = len(coarse_rho)\n    slopes = np.zeros(n_coarse)\n    limiter_func = limiter_funcs[limiter_name]\n\n    # 1. Compute limited slopes for interior cells\n    for i in range(1, n_coarse - 1):\n        delta_minus = coarse_rho[i] - coarse_rho[i-1]\n        delta_plus = coarse_rho[i+1] - coarse_rho[i]\n        slopes[i] = limiter_func(delta_minus, delta_plus)\n    # Slopes at boundaries (i=0, i=n_coarse-1) remain 0\n\n    # 2. Compute fine-level subcell averages with bound-preserving clipping\n    c_j_coeffs = (np.arange(r, dtype=float) + 0.5) / r - 0.5\n    fine_rho = []\n    \n    for i in range(n_coarse):\n        # Determine local bounds from available neighbors\n        neighbors = [coarse_rho[i]]\n        if i  0:\n            neighbors.append(coarse_rho[i-1])\n        if i  n_coarse - 1:\n            neighbors.append(coarse_rho[i+1])\n        \n        rho_min_i = min(neighbors)\n        rho_max_i = max(neighbors)\n\n        # Compute, clip, and store subcell values\n        for j in range(r):\n            # Calculate value from piecewise linear reconstruction\n            val = coarse_rho[i] + slopes[i] * c_j_coeffs[j]\n            # Apply bound-preserving clipping\n            clipped_val = min(rho_max_i, max(rho_min_i, val))\n            fine_rho.append(clipped_val)\n            \n    return fine_rho\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite, then prints the formatted results.\n    \"\"\"\n    test_cases = [\n        {'coarse_rho': [1.0, 1.1, 1.2, 1.3], 'limiter': 'Minmod', 'r': 2},\n        {'coarse_rho': [1.0, 1.0, 5.0, 5.0], 'limiter': 'MC', 'r': 2},\n        {'coarse_rho': [3.0, 1.0, 3.0, 1.0], 'limiter': 'Van Leer', 'r': 4},\n        {'coarse_rho': [0.5, 0.5, 2.0, 0.5, 0.5], 'limiter': 'Minmod', 'r': 2},\n    ]\n\n    all_results_str = []\n    for case in test_cases:\n        result = process_case(case['coarse_rho'], case['limiter'], case['r'])\n        # Format the list of floats into a string \"[f1,f2,...]\"\n        result_str = '[' + ','.join(map(str, result)) + ']'\n        all_results_str.append(result_str)\n\n    # Combine all case strings into the final output format \"[[...],[...],...]\"\n    # with no spaces.\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```", "id": "3503480"}, {"introduction": "Efficiency in AMR hinges on using different time steps for different grid levels, a technique called subcycling. The maximum stable time step for an explicit solver is constrained by the Courant–Friedrichs–Lewy (CFL) condition, which links the time step $\\Delta t$ to the grid spacing $\\Delta x$ and wave speed $a$. Since finer grids have smaller $\\Delta x$, they require smaller time steps. This practice [@problem_id:3503472] tackles the essential calculations for managing a multi-level time-stepping scheme, ensuring stability on all levels while synchronizing them at coarse-level intervals for data exchange.", "problem": "Consider a one-dimensional explicit finite-volume solver for a hyperbolic conservation law in a computational astrophysics simulation employing Adaptive Mesh Refinement (AMR). The mesh hierarchy consists of three levels: a coarse level $\\ell = 0$, a finer level $\\ell = 1$ refined by factor $r_{1} = 3$ relative to level $\\ell = 0$, and a finest level $\\ell = 2$ refined by factor $r_{2} = 2$ relative to level $\\ell = 1$. The coarse-level spatial step is $\\Delta x_{0} = 9.6 \\times 10^{9}$ meters, so that $\\Delta x_{1} = \\Delta x_{0}/r_{1}$ and $\\Delta x_{2} = \\Delta x_{1}/r_{2}$. The maximum characteristic speeds (the largest absolute values of eigenvalues of the flux Jacobian) resolved on each level are $a_{0} = 2.0 \\times 10^{7}$ meters per second on level $\\ell = 0$, $a_{1} = 3.3 \\times 10^{7}$ meters per second on level $\\ell = 1$, and $a_{2} = 4.0 \\times 10^{7}$ meters per second on level $\\ell = 2$. The Courant–Friedrichs–Lewy (CFL) number is $C_{\\mathrm{CFL}} = 0.45$.\n\nUsing the Courant–Friedrichs–Lewy stability requirement appropriate to explicit finite-volume discretizations of hyperbolic systems, first compute the allowable time step on each AMR level, denoted $\\Delta t_{\\ell}^{\\max}$ for $\\ell \\in \\{0,1,2\\}$. Then, suppose the coarse level advances by one time step of length $\\Delta t_{0} = \\Delta t_{0}^{\\max}$. Implement level-synchronous subcycling on finer levels by choosing integers $n_{1}$ and $n_{2}$ such that level $\\ell = 1$ takes $n_{1}$ substeps and level $\\ell = 2$ takes $n_{2}$ substeps over the single coarse-level advance, with $\\Delta t_{1} = \\Delta t_{0}/n_{1} \\le \\Delta t_{1}^{\\max}$ and $\\Delta t_{2} = \\Delta t_{0}/n_{2} \\le \\Delta t_{2}^{\\max}$, and with $n_{2}$ being a positive integer multiple of $n_{1}$ to ensure nested synchronization. Among all admissible choices, select the minimal $n_{1}$ and the minimal multiple $n_{2}$ that satisfy these constraints.\n\nDefine the synchronization times within the interval $[0,\\Delta t_{0}]$ as the set of times at which all finer levels have simultaneously completed an integer number of their substeps and thus can perform flux correction with their parent level; under the above constraint that $n_{2}$ is a multiple of $n_{1}$, these are the level $\\ell = 1$ substep boundaries. List these times, including the start and end of the coarse-level step. Express all time quantities in seconds.\n\nProvide, in order, the triple $\\left(\\Delta t_{0}^{\\max}, \\Delta t_{1}^{\\max}, \\Delta t_{2}^{\\max}\\right)$, the actual subcycled time steps $\\left(\\Delta t_{0}, \\Delta t_{1}, \\Delta t_{2}\\right)$, and the ordered synchronization times $\\left(t_{0}, t_{1}, t_{2}, t_{3}, t_{4}, t_{5}\\right)$ over one coarse-level step, as a single row in your final answer. No rounding is required.", "solution": "The user has provided a problem in computational astrophysics concerning time-stepping in an Adaptive Mesh Refinement (AMR) simulation. The problem requires the calculation of time steps based on the Courant-Friedrichs-Lewy (CFL) stability condition and the determination of subcycling parameters and synchronization times.\n\nThe problem is first validated against the required criteria.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- AMR levels: $\\ell \\in \\{0, 1, 2\\}$.\n- Refinement factor from level $\\ell=0$ to $\\ell=1$: $r_{1} = 3$.\n- Refinement factor from level $\\ell=1$ to $\\ell=2$: $r_{2} = 2$.\n- Coarse-level spatial step: $\\Delta x_{0} = 9.6 \\times 10^{9}$ meters.\n- Spatial step relations: $\\Delta x_{1} = \\Delta x_{0}/r_{1}$ and $\\Delta x_{2} = \\Delta x_{1}/r_{2}$.\n- Maximum characteristic speeds on each level: $a_{0} = 2.0 \\times 10^{7}$ m/s, $a_{1} = 3.3 \\times 10^{7}$ m/s, $a_{2} = 4.0 \\times 10^{7}$ m/s.\n- Courant-Friedrichs-Lewy (CFL) number: $C_{\\mathrm{CFL}} = 0.45$.\n- Coarse-level time step for the advance: $\\Delta t_{0} = \\Delta t_{0}^{\\max}$.\n- Subcycling constraints:\n  - Level $\\ell=1$ takes $n_{1}$ substeps, with $\\Delta t_{1} = \\Delta t_{0}/n_{1} \\le \\Delta t_{1}^{\\max}$.\n  - Level $\\ell=2$ takes $n_{2}$ substeps, with $\\Delta t_{2} = \\Delta t_{0}/n_{2} \\le \\Delta t_{2}^{\\max}$.\n- Synchronization constraint: $n_{2}$ is a positive integer multiple of $n_{1}$.\n- Minimality constraint: $n_{1}$ is the minimal integer satisfying its constraint, and $n_{2}$ is the minimal multiple of $n_{1}$ satisfying its constraint.\n- Synchronization times: The boundaries of the level $\\ell=1$ substeps within the coarse-level step interval $[0, \\Delta t_{0}]$.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientific Groundedness**: The problem is based on the CFL condition, a fundamental principle for the stability of explicit numerical methods for hyperbolic equations. AMR with subcycling is a standard, scientifically valid technique in computational fluid dynamics and astrophysics. The problem is firmly grounded in established numerical analysis.\n- **Well-Posedness**: All necessary parameters ($\\Delta x_0$, $r_1$, $r_2$, $a_\\ell$, $C_{\\mathrm{CFL}}$) are provided. The constraints on the subcycling integers ($n_1, n_2$) are clearly defined and lead to a unique, minimal solution. The problem is self-contained and mathematically well-posed.\n- **Objectivity**: The problem is formulated using precise, unambiguous mathematical terms and physical quantities. It is free from subjective language.\n\n**Step 3: Verdict and Action**\nThe problem is valid as it is scientifically sound, well-posed, and objective. A complete solution will be provided.\n\n### Solution\n\nThe solution proceeds in several steps:\n1.  Compute the spatial step size $\\Delta x_{\\ell}$ for each level $\\ell$.\n2.  Compute the maximum allowable time step $\\Delta t_{\\ell}^{\\max}$ for each level using the CFL condition.\n3.  Determine the integer subcycling numbers $n_{1}$ and $n_{2}$ that satisfy the given constraints.\n4.  Calculate the actual time steps $\\Delta t_{\\ell}$ used for the subcycled advance.\n5.  List the synchronization times over one coarse-level step.\n\n**1. Spatial Step Sizes**\nThe spatial step sizes for the finer levels are determined by the given refinement factors.\n- Level $\\ell=0$: $\\Delta x_{0} = 9.6 \\times 10^{9} \\, \\text{m}$.\n- Level $\\ell=1$: $\\Delta x_{1} = \\frac{\\Delta x_{0}}{r_{1}} = \\frac{9.6 \\times 10^{9}}{3} = 3.2 \\times 10^{9} \\, \\text{m}$.\n- Level $\\ell=2$: $\\Delta x_{2} = \\frac{\\Delta x_{1}}{r_{2}} = \\frac{3.2 \\times 10^{9}}{2} = 1.6 \\times 10^{9} \\, \\text{m}$.\n\n**2. Maximum Allowable Time Steps**\nThe CFL condition for a one-dimensional explicit finite-volume scheme states that for stability, the time step $\\Delta t$ must satisfy $\\Delta t \\le C_{\\mathrm{CFL}} \\frac{\\Delta x}{a}$, where $a$ is the maximum characteristic speed. The maximum allowable time step on level $\\ell$ is therefore $\\Delta t_{\\ell}^{\\max} = C_{\\mathrm{CFL}} \\frac{\\Delta x_{\\ell}}{a_{\\ell}}$.\n\n- Level $\\ell=0$:\n$$ \\Delta t_{0}^{\\max} = C_{\\mathrm{CFL}} \\frac{\\Delta x_{0}}{a_{0}} = 0.45 \\times \\frac{9.6 \\times 10^{9} \\, \\text{m}}{2.0 \\times 10^{7} \\, \\text{m/s}} = 0.45 \\times (4.8 \\times 10^{2} \\, \\text{s}) = 216 \\, \\text{s} $$\n- Level $\\ell=1$:\n$$ \\Delta t_{1}^{\\max} = C_{\\mathrm{CFL}} \\frac{\\Delta x_{1}}{a_{1}} = 0.45 \\times \\frac{3.2 \\times 10^{9} \\, \\text{m}}{3.3 \\times 10^{7} \\, \\text{m/s}} = 0.45 \\times \\frac{3.2}{3.3} \\times 10^{2} \\, \\text{s} = \\frac{1.44}{3.3} \\times 10^{2} \\, \\text{s} = \\frac{144}{3.3} \\, \\text{s} = \\frac{1440}{33} \\, \\text{s} = \\frac{480}{11} \\, \\text{s} $$\n- Level $\\ell=2$:\n$$ \\Delta t_{2}^{\\max} = C_{\\mathrm{CFL}} \\frac{\\Delta x_{2}}{a_{2}} = 0.45 \\times \\frac{1.6 \\times 10^{9} \\, \\text{m}}{4.0 \\times 10^{7} \\, \\text{m/s}} = 0.45 \\times (0.4 \\times 10^{2} \\, \\text{s}) = 18 \\, \\text{s} $$\nThe first requested set of values is $(\\Delta t_{0}^{\\max}, \\Delta t_{1}^{\\max}, \\Delta t_{2}^{\\max}) = (216, \\frac{480}{11}, 18)$.\n\n**3. Subcycling Integers**\nThe coarse level advances by one step of size $\\Delta t_{0} = \\Delta t_{0}^{\\max} = 216 \\, \\text{s}$.\nFor level $\\ell=1$, the number of substeps $n_{1}$ must satisfy $\\Delta t_{1} = \\frac{\\Delta t_{0}}{n_{1}} \\le \\Delta t_{1}^{\\max}$. This implies:\n$$ n_{1} \\ge \\frac{\\Delta t_{0}}{\\Delta t_{1}^{\\max}} = \\frac{216}{\\frac{480}{11}} = \\frac{216 \\times 11}{480} = \\frac{9 \\times 24 \\times 11}{20 \\times 24} = \\frac{99}{20} = 4.95 $$\nSince $n_{1}$ must be an integer, the minimal value for $n_{1}$ is $\\lceil 4.95 \\rceil = 5$.\n\nFor level $\\ell=2$, the number of substeps $n_{2}$ must satisfy $\\Delta t_{2} = \\frac{\\Delta t_{0}}{n_{2}} \\le \\Delta t_{2}^{\\max}$. This implies:\n$$ n_{2} \\ge \\frac{\\Delta t_{0}}{\\Delta t_{2}^{\\max}} = \\frac{216}{18} = 12 $$\nAdditionally, $n_{2}$ must be a positive integer multiple of $n_{1}=5$. We must find the smallest multiple of $5$ that is greater than or equal to $12$. The relevant multiples of $5$ are $5, 10, 15, \\dots$. The smallest such multiple is $15$.\nThus, the selected subcycling integers are $n_{1} = 5$ and $n_{2} = 15$.\n\n**4. Actual Subcycled Time Steps**\nThe actual time steps for each level are calculated based on the subcycling integers.\n- Level $\\ell=0$: $\\Delta t_{0} = 216 \\, \\text{s}$.\n- Level $\\ell=1$: $\\Delta t_{1} = \\frac{\\Delta t_{0}}{n_{1}} = \\frac{216}{5} = 43.2 \\, \\text{s}$.\n- Level $\\ell=2$: $\\Delta t_{2} = \\frac{\\Delta t_{0}}{n_{2}} = \\frac{216}{15} = \\frac{72}{5} = 14.4 \\, \\text{s}$.\nThe second requested set of values is $(\\Delta t_{0}, \\Delta t_{1}, \\Delta t_{2}) = (216, 43.2, 14.4)$.\n\n**5. Synchronization Times**\nThe synchronization times are the boundaries of the level $\\ell=1$ substeps. Since level $\\ell=1$ takes $n_{1}=5$ substeps of duration $\\Delta t_{1} = 43.2 \\, \\text{s}$, the synchronization times $t_j$ are given by $t_j = j \\cdot \\Delta t_{1}$ for $j=0, 1, \\dots, 5$.\n- $t_{0} = 0 \\times 43.2 = 0 \\, \\text{s}$\n- $t_{1} = 1 \\times 43.2 = 43.2 \\, \\text{s}$\n- $t_{2} = 2 \\times 43.2 = 86.4 \\, \\text{s}$\n- $t_{3} = 3 \\times 43.2 = 129.6 \\, \\text{s}$\n- $t_{4} = 4 \\times 43.2 = 172.8 \\, \\text{s}$\n- $t_{5} = 5 \\times 43.2 = 216.0 \\, \\text{s}$\nThe third requested set of values is $(0, 43.2, 86.4, 129.6, 172.8, 216.0)$.\n\nThese three sets of results are combined into a single row matrix for the final answer.\n- $(\\Delta t_{0}^{\\max}, \\Delta t_{1}^{\\max}, \\Delta t_{2}^{\\max}) = (216, \\frac{480}{11}, 18)$\n- $(\\Delta t_{0}, \\Delta t_{1}, \\Delta t_{2}) = (216, 43.2, 14.4)$\n- $(t_0, \\dots, t_5) = (0, 43.2, 86.4, 129.6, 172.8, 216)$", "answer": "$$\n\\boxed{\\begin{pmatrix} 216  \\frac{480}{11}  18  216  43.2  14.4  0  43.2  86.4  129.6  172.8  216 \\end{pmatrix}}\n$$", "id": "3503472"}, {"introduction": "Many phenomena in geophysics, such as faults, shear layers, or plumes, have highly directional features where the solution changes rapidly in one direction but slowly in another. Isotropic refinement with square or cubic cells can be computationally wasteful in these scenarios. This exercise [@problem_id:3573786] introduces the powerful concept of anisotropic AMR, where mesh elements are stretched and oriented to align with the solution's structure. You will learn to compute a Hessian-based metric tensor, which uses the local curvature of the solution to prescribe the optimal shape and orientation of mesh cells, leading to significant gains in efficiency and accuracy.", "problem": "You are given sampled values of a twice continuously differentiable scalar field $u(x,y)$ on a uniform Cartesian grid with grid spacings $h_x$ and $h_y$. Your task is to implement a complete program that, for several prescribed test fields and points, computes a symmetric Hessian-based anisotropic refinement metric and deduces the resulting directional refinement information.\n\nStarting from the second-order Taylor expansion of $u$ about a point $(x_0,y_0)$, the Hessian matrix $H(u)$ captures the second-order variation:\n$$\nu(x_0+\\Delta x,y_0+\\Delta y) \\approx u(x_0,y_0) + \\nabla u(x_0,y_0) \\cdot \\begin{bmatrix}\\Delta x\\\\ \\Delta y\\end{bmatrix} + \\tfrac{1}{2} \\begin{bmatrix}\\Delta x  \\Delta y\\end{bmatrix} H(u)(x_0,y_0) \\begin{bmatrix}\\Delta x\\\\ \\Delta y\\end{bmatrix}.\n$$\nOn a uniform grid, approximate $H(u)(x_0,y_0)$ using second-order central differences with a minimal $3 \\times 3$ stencil:\n- The second partial derivatives are approximated as\n$$\n\\partial_{xx} u(x_0,y_0) \\approx \\frac{u(x_0+h_x,y_0) - 2\\,u(x_0,y_0) + u(x_0-h_x,y_0)}{h_x^2},\n$$\n$$\n\\partial_{yy} u(x_0,y_0) \\approx \\frac{u(x_0,y_0+h_y) - 2\\,u(x_0,y_0) + u(x_0,y_0-h_y)}{h_y^2},\n$$\n$$\n\\partial_{xy} u(x_0,y_0) \\approx \\frac{u(x_0+h_x,y_0+h_y) - u(x_0+h_x,y_0-h_y) - u(x_0-h_x,y_0+h_y) + u(x_0-h_x,y_0-h_y)}{4\\,h_x\\,h_y}.\n$$\nForm the symmetric Hessian\n$$\nH(u)(x_0,y_0) \\approx \\begin{bmatrix} \\partial_{xx}u  \\partial_{xy}u \\\\ \\partial_{xy}u  \\partial_{yy}u \\end{bmatrix}.\n$$\nDefine the metric tensor for anisotropic refinement as $M = \\alpha\\,H(u)$, where $\\alpha > 0$ is a user-prescribed scalar. Denote the eigen-decomposition of $H(u)$ by $H(u)=Q \\Lambda Q^\\top$, where $Q$ is orthogonal and $\\Lambda=\\mathrm{diag}(\\lambda_1,\\lambda_2)$ with real eigenvalues $\\lambda_i$ and orthonormal eigenvectors $q_i$.\n\nTo determine directional refinement scales, use the magnitudes of the eigenvalues. Introduce a small floor $\\delta > 0$ to avoid division by zero, and compute\n$$\nh_i = \\sqrt{\\frac{\\alpha}{\\max(|\\lambda_i|,\\delta)}},\n$$\nthen clamp to bounds $h_{\\min} \\le h_i \\le h_{\\max}$ via\n$$\nh_i \\leftarrow \\min\\left(h_{\\max}, \\max\\left(h_{\\min}, h_i\\right)\\right).\n$$\nDefine the aspect ratio as\n$$\n\\mathrm{AR} = \\frac{\\max(h_1,h_2)}{\\min(h_1,h_2)}.\n$$\nDefine the orientation angle $\\theta$ (in radians) of the strongest refinement direction as the angle of the eigenvector associated with the smallest $h_i$ (that is, the largest $|\\lambda_i|$). If there is a tie in $|\\lambda_i|$, choose the eigenvector corresponding to the larger algebraic value $\\lambda_i$. Compute $\\theta = \\mathrm{atan2}(v_y,v_x)$ for the chosen unit eigenvector $v=[v_x,v_y]^\\top$, and normalize $\\theta$ to the interval $[-\\pi/2,\\pi/2)$ by adding or subtracting $\\pi$ if needed to enforce that range.\n\nImplement the above for the following test suite of fields $u(x,y)$, points $(x_0,y_0)$, and parameters $(h_x,h_y,\\alpha,h_{\\min},h_{\\max},\\delta)$:\n\n- Test $1$: $u(x,y) = x^2 + 3\\,y^2$, $(x_0,y_0)=(0,0)$, $h_x=h_y=0.01$, $\\alpha=1.0$, $h_{\\min}=0.05$, $h_{\\max}=1.0$, $\\delta=10^{-12}$.\n- Test $2$: $u(x,y) = (x+y)^2$, $(x_0,y_0)=(0,0)$, $h_x=h_y=0.01$, $\\alpha=1.0$, $h_{\\min}=0.05$, $h_{\\max}=1.0$, $\\delta=10^{-6}$.\n- Test $3$: $u(x,y) = x^2 - y^2$, $(x_0,y_0)=(0,0)$, $h_x=h_y=0.01$, $\\alpha=1.0$, $h_{\\min}=0.05$, $h_{\\max}=1.0$, $\\delta=10^{-12}$.\n- Test $4$: $u(x,y) = e^{0.5\\,x}\\cos(y)$, $(x_0,y_0)=(0.1,-0.2)$, $h_x=h_y=0.01$, $\\alpha=0.25$, $h_{\\min}=0.05$, $h_{\\max}=0.5$, $\\delta=10^{-12}$.\n\nYour program should, for each test, compute at $(x_0,y_0)$:\n- the Hessian entries $H_{xx}$, $H_{xy}$, $H_{yy}$,\n- the eigenvalues $\\lambda_1,\\lambda_2$ sorted by descending $|\\lambda_i|$ with the tie-breaker rule described above,\n- the aspect ratio $\\mathrm{AR}$,\n- the orientation angle $\\theta$ in radians,\n- the metric entries $M_{xx}$, $M_{xy}$, $M_{yy}$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a sublist of the form\n$$\n[H_{xx}, H_{xy}, H_{yy}, \\lambda_1, \\lambda_2, \\mathrm{AR}, \\theta, M_{xx}, M_{xy}, M_{yy}],\n$$\nwith all values rounded to $6$ decimal places. That is, the final output must be a single line like\n$[[\\cdots],[\\cdots],[\\cdots],[\\cdots]]$\nwith no spaces. The angle must be in radians. No physical units are involved. All numbers in the printed output must be rounded to $6$ decimal places as specified.", "solution": "The problem requires the computation of a Hessian-based anisotropic refinement metric for a given scalar field $u(x,y)$. This is a standard technique in computational science, particularly in adaptive mesh generation for solving partial differential equations, where the mesh density and orientation are adapted to capture local features of the solution, such as sharp gradients or high-curvature regions. The Hessian matrix, which contains the second partial derivatives of the field, provides information about the field's local curvature. The eigenvalues and eigenvectors of the Hessian indicate the principal directions and magnitudes of this curvature. This information is then used to define a metric tensor that prescribes the desired size and orientation of mesh elements.\n\nThe solution process is broken down into the following sequential steps, which will be applied to each test case.\n\n**Step 1: Numerical Approximation of the Hessian Matrix**\n\nGiven a scalar field $u(x,y)$, its Hessian matrix is defined as:\n$$\nH(u) = \\begin{bmatrix} \\partial_{xx}u  \\partial_{xy}u \\\\ \\partial_{yx}u  \\partial_{yy}u \\end{bmatrix}\n$$\nSince the problem states that $u(x,y)$ is twice continuously differentiable, Schwarz's theorem ensures that $\\partial_{xy}u = \\partial_{yx}u$, making the Hessian symmetric. The problem provides second-order accurate central difference formulas to approximate the partial derivatives at a point $(x_0, y_0)$ on a grid with spacings $h_x$ and $h_y$.\n\nThe second partial derivatives are computed as follows:\n- Pure second derivative with respect to $x$:\n$$\nH_{xx} = \\partial_{xx} u(x_0,y_0) \\approx \\frac{u(x_0+h_x,y_0) - 2\\,u(x_0,y_0) + u(x_0-h_x,y_0)}{h_x^2}\n$$\n- Pure second derivative with respect to $y$:\n$$\nH_{yy} = \\partial_{yy} u(x_0,y_0) \\approx \\frac{u(x_0,y_0+h_y) - 2\\,u(x_0,y_0) + u(x_0,y_0-h_y)}{h_y^2}\n$$\n- Mixed second derivative:\n$$\nH_{xy} = \\partial_{xy} u(x_0,y_0) \\approx \\frac{u(x_0+h_x,y_0+h_y) - u(x_0+h_x,y_0-h_y) - u(x_0-h_x,y_0+h_y) + u(x_0-h_x,y_0-h_y)}{4\\,h_x\\,h_y}\n$$\nThese three values form the approximate symmetric Hessian matrix at $(x_0,y_0)$:\n$$\nH \\approx \\begin{bmatrix} H_{xx}  H_{xy} \\\\ H_{xy}  H_{yy} \\end{bmatrix}\n$$\n\n**Step 2: Eigendecomposition of the Hessian**\n\nThe Hessian matrix $H$ is a $2 \\times 2$ real symmetric matrix. It therefore has two real eigenvalues, $\\lambda_1$ and $\\lambda_2$, and a corresponding set of orthonormal eigenvectors, $q_1$ and $q_2$. The eigendecomposition is $H = Q \\Lambda Q^\\top$, where $\\Lambda = \\mathrm{diag}(\\lambda_1, \\lambda_2)$ and $Q = [q_1 | q_2]$ is an orthogonal matrix whose columns are the eigenvectors.\n\nThe problem specifies a sorting order for the eigenvalues: they are to be sorted primarily in descending order of their absolute values. If a tie occurs (i.e., $|\\lambda_a| = |\\lambda_b|$), the tie is broken by sorting in descending order of their algebraic values. This defines the ordered pair $(\\lambda_1, \\lambda_2)$ such that either $|\\lambda_1|  |\\lambda_2|$, or $|\\lambda_1| = |\\lambda_2|$ and $\\lambda_1 \\ge \\lambda_2$.\n\n**Step 3: Calculation of Refinement Scales and Aspect Ratio**\n\nThe eigenvalues capture the magnitude of curvature. In directions where fine resolution is needed (large curvature, large $|\\lambda_i|$), the desired mesh size $h_i$ should be small. This relationship is given by:\n$$\nh_i = \\sqrt{\\frac{\\alpha}{\\max(|\\lambda_i|,\\delta)}}\n$$\nwhere $\\alpha$ is a scaling factor and $\\delta$ is a small positive constant to prevent division by zero or near-zero eigenvalues, which would lead to excessively large mesh sizes.\n\nThe computed scales $h_i$ are then clamped to a prescribed valid range $[h_{\\min}, h_{\\max}]$:\n$$\nh_i \\leftarrow \\min\\left(h_{\\max}, \\max\\left(h_{\\min}, h_i\\right)\\right)\n$$\nAfter clamping, the aspect ratio $\\mathrm{AR}$ of the desired anisotropic mesh element is computed as the ratio of the larger to the smaller refinement scale:\n$$\n\\mathrm{AR} = \\frac{\\max(h_1, h_2)}{\\min(h_1, h_2)}\n$$\n\n**Step 4: Determination of Orientation Angle**\n\nThe orientation of the desired refinement is aligned with the principal directions of curvature, i.e., the eigenvectors of the Hessian. The direction of strongest refinement corresponds to the smallest desired mesh size $h_i$, which in turn corresponds to the eigenvalue $\\lambda_i$ with the largest absolute value. According to our sorting, this is always $\\lambda_1$.\n\nThe orientation angle $\\theta$ is defined as the angle of the eigenvector $q_1$ associated with $\\lambda_1$. For an eigenvector $q_1 = [v_x, v_y]^\\top$, the angle is calculated using the two-argument arctangent function:\n$$\n\\theta_{\\text{raw}} = \\mathrm{atan2}(v_y, v_x)\n$$\nThis angle, which lies in $(-\\pi, \\pi]$, represents the direction of the eigenvector. However, for mesh orientation, a direction and its opposite are equivalent (e.g., the line defined by $q_1$ is the same as that defined by $-q_1$). Therefore, the angle is normalized to the interval $[-\\pi/2, \\pi/2)$ by adding or subtracting multiples of $\\pi$ as needed. A convenient formula for this normalization is $\\theta = \\mathrm{mod}(\\theta_{\\text{raw}} + \\pi/2, \\pi) - \\pi/2$.\n\n**Step 5: Construction of the Metric Tensor**\n\nFinally, the metric tensor $M$ is defined as a simple scaling of the Hessian matrix:\n$$\nM = \\alpha H = \\begin{bmatrix} \\alpha H_{xx}  \\alpha H_{xy} \\\\ \\alpha H_{xy}  \\alpha H_{yy} \\end{bmatrix}\n$$\nThis tensor $M$ can be used by mesh generation software to create elements that are small and aligned in the directions of high curvature, and large and elongated in directions of low curvature.\n\n**Execution for Test Cases**\n\nThe above five-step procedure is systematically applied to each test case provided. For each case, we define the function $u(x,y)$, the point $(x_0, y_0)$, and the set of parameters $(h_x, h_y, \\alpha, h_{\\min}, h_{\\max}, \\delta)$. The algorithm is then executed to compute the ten required output values: $(H_{xx}, H_{xy}, H_{yy}, \\lambda_1, \\lambda_2, \\mathrm{AR}, \\theta, M_{xx}, M_{xy}, M_{yy})$. The numerical results are then rounded to six decimal places for the final output. This entire process is encapsulated in the provided Python program.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It computes Hessian-based refinement metrics and formats the output.\n    \"\"\"\n    \n    test_cases = [\n        {'u': lambda x, y: x**2 + 3*y**2, 'p': (0.0, 0.0), 'h': (0.01, 0.01), 'alpha': 1.0, 'h_bounds': (0.05, 1.0), 'delta': 1e-12},\n        {'u': lambda x, y: (x + y)**2, 'p': (0.0, 0.0), 'h': (0.01, 0.01), 'alpha': 1.0, 'h_bounds': (0.05, 1.0), 'delta': 1e-6},\n        {'u': lambda x, y: x**2 - y**2, 'p': (0.0, 0.0), 'h': (0.01, 0.01), 'alpha': 1.0, 'h_bounds': (0.05, 1.0), 'delta': 1e-12},\n        {'u': lambda x, y: np.exp(0.5*x)*np.cos(y), 'p': (0.1, -0.2), 'h': (0.01, 0.01), 'alpha': 0.25, 'h_bounds': (0.05, 0.5), 'delta': 1e-12},\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        result = compute_refinement_info(case)\n        all_results.append(result)\n\n    # Format the final output string as a list of lists, with values rounded to 6 decimal places.\n    output_str = \"[\" + \",\".join(\n        \"[\" + \",\".join(f\"{val:.6f}\" for val in res) + \"]\" for res in all_results\n    ) + \"]\"\n    print(output_str)\n\ndef compute_refinement_info(case):\n    \"\"\"\n    Computes the anisotropic refinement information for a single test case.\n    \"\"\"\n    u_func = case['u']\n    x0, y0 = case['p']\n    hx, hy = case['h']\n    alpha = case['alpha']\n    h_min, h_max = case['h_bounds']\n    delta = case['delta']\n\n    # Step 1: Compute Hessian components using central differences\n    u_c = u_func(x0, y0)\n    \n    # H_xx\n    u_xp = u_func(x0 + hx, y0)\n    u_xm = u_func(x0 - hx, y0)\n    H_xx = (u_xp - 2*u_c + u_xm) / hx**2\n    \n    # H_yy\n    u_yp = u_func(x0, y0 + hy)\n    u_ym = u_func(x0, y0 - hy)\n    H_yy = (u_yp - 2*u_c + u_ym) / hy**2\n    \n    # H_xy\n    u_pp = u_func(x0 + hx, y0 + hy)\n    u_pm = u_func(x0 + hx, y0 - hy)\n    u_mp = u_func(x0 - hx, y0 + hy)\n    u_mm = u_func(x0 - hx, y0 - hy)\n    H_xy = (u_pp - u_pm - u_mp + u_mm) / (4 * hx * hy)\n    \n    H = np.array([[H_xx, H_xy], [H_xy, H_yy]])\n\n    # Step 2: Eigendecomposition and sorting\n    evals, evecs = np.linalg.eig(H)\n    \n    # Pair eigenvalues with eigenvectors and sort\n    # Sort by |lambda| descending. Break ties with lambda descending.\n    e_pairs = sorted(zip(evals, evecs.T), key=lambda p: (abs(p[0]), p[0]), reverse=True)\n    \n    lambda1, q1 = e_pairs[0]\n    lambda2, q2 = e_pairs[1]\n\n    # Step 3: Refinement scales and aspect ratio\n    h1 = np.sqrt(alpha / max(abs(lambda1), delta))\n    h2 = np.sqrt(alpha / max(abs(lambda2), delta))\n    \n    # Clamp to [h_min, h_max]\n    h1_clamped = min(h_max, max(h_min, h1))\n    h2_clamped = min(h_max, max(h_min, h2))\n    \n    # Aspect Ratio\n    AR = max(h1_clamped, h2_clamped) / min(h1_clamped, h2_clamped)\n\n    # Step 4: Orientation angle\n    # The orientation is the angle of the eigenvector q1 (associated with lambda1)\n    vx, vy = q1\n    theta = np.arctan2(vy, vx)\n    \n    # Normalize theta to [-pi/2, pi/2)\n    # This formula maps theta to the desired interval.\n    theta = np.mod(theta + np.pi/2, np.pi) - np.pi/2\n\n    # Step 5: Metric Tensor\n    M = alpha * H\n    M_xx, M_xy, M_yy = M[0,0], M[0,1], M[1,1]\n\n    return [H_xx, H_xy, H_yy, lambda1, lambda2, AR, theta, M_xx, M_xy, M_yy]\n\nsolve()\n```", "id": "3573786"}]}