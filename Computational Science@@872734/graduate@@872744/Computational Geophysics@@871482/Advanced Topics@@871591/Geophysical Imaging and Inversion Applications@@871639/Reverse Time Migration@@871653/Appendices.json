{"hands_on_practices": [{"introduction": "To build a robust understanding of Reverse Time Migration (RTM), it is essential to construct the imaging algorithm from its fundamental components. This first practice guides you through implementing a 2D frequency-domain RTM, starting from the Helmholtz equation and the single-scattering Born approximation. By calculating source and receiver wavefields and applying the cross-correlation imaging condition, you will build a foundational intuition for how adjoint-state methods produce a subsurface image, culminating in stacking multiple frequencies to approximate a broadband result [@problem_id:3613775].", "problem": "Implement a frequency-domain Reverse Time Migration (RTM) imaging experiment for a two-dimensional constant-density acoustic medium using the single-frequency Helmholtz equation. Start from the constant-density acoustic wave equation and derive a frequency-domain formulation suitable for constructing a single-scatterer Born approximation. Use this to define a forward modeling operator for the background wavefield, a secondary source for the scattered field due to a localized perturbation in squared slowness, and an adjoint (back-propagation) operator for imaging by a correlation-type imaging condition.\n\nYour program must construct a computational grid, assemble the discrete Helmholtz operator with homogeneous Dirichlet boundary conditions and a small complex shift to emulate weak absorption, solve the forward and adjoint fields, compute the image for a single frequency, and then perform a multi-frequency stack to approximate the bandwidth and resolution of a time-domain image. The final output for each test case is a scalar metric that quantifies peak-to-sidelobe contrast at the known scatterer location.\n\nFoundational basis and definitions:\n- The constant-density acoustic wave equation in physical space is given by\n$$\n\\frac{\\partial^2 p(\\mathbf{x},t)}{\\partial t^2} - v(\\mathbf{x})^2 \\nabla^2 p(\\mathbf{x},t) = s(\\mathbf{x},t),\n$$\nwhere $p$ is pressure, $v$ is wave speed in $\\mathrm{m/s}$, $\\nabla^2$ is the Laplacian, and $s$ is a source term.\n- Under a single-frequency time-harmonic ansatz $p(\\mathbf{x},t) = \\Re\\{u(\\mathbf{x},\\omega) e^{-i \\omega t}\\}$ with angular frequency $\\omega$ in $\\mathrm{rad/s}$, the field $u(\\mathbf{x},\\omega)$ satisfies the inhomogeneous Helmholtz equation\n$$\n\\left(\\nabla^2 + \\omega^2 m(\\mathbf{x})\\right) u(\\mathbf{x},\\omega) = q(\\mathbf{x},\\omega),\n$$\nwhere $m(\\mathbf{x}) = v(\\mathbf{x})^{-2}$ is squared slowness in $\\mathrm{s^2/m^2}$ and $q$ is the frequency-domain source.\n- For a small perturbation $\\delta m(\\mathbf{x})$ in squared slowness relative to a known background $m_0(\\mathbf{x})$, the first Born approximation yields the scattered field $u_s$ solving\n$$\n\\left(\\nabla^2 + \\omega^2 m_0(\\mathbf{x})\\right) u_s(\\mathbf{x},\\omega) = - \\omega^2 \\delta m(\\mathbf{x}) u_0(\\mathbf{x},\\omega),\n$$\nwhere $u_0$ is the background field solving\n$$\n\\left(\\nabla^2 + \\omega^2 m_0(\\mathbf{x})\\right) u_0(\\mathbf{x},\\omega) = q(\\mathbf{x},\\omega).\n$$\n\nDiscretization and numerical setup:\n- Work on a uniform Cartesian grid of size $N_x \\times N_z = 50 \\times 50$ with spacings $\\Delta x = \\Delta z = 10\\,\\mathrm{m}$. The computational domain has homogeneous Dirichlet boundary conditions (zero pressure on the boundary). To mimic weak absorption and reduce artificial reflections, use a complex shift in the mass term so that the discrete operator is\n$$\n\\mathbf{A}(\\omega) = \\mathbf{L} + \\omega^2 m_0 (1 - i \\eta)\\mathbf{I},\n$$\nwhere $\\mathbf{L}$ is the standard five-point discrete Laplacian with Dirichlet boundary treatment, $\\mathbf{I}$ is the identity, and $\\eta = 0.05$ is a dimensionless damping parameter.\n- Use a uniform background velocity $v_0 = 2000\\,\\mathrm{m/s}$, so that $m_0 = v_0^{-2}$ in $\\mathrm{s^2/m^2}$.\n- Place a single point source one grid cell below the surface at horizontal center. This is at index $(i_x,i_z) = (N_x/2, 1)$ using zero-based indexing in code. Model the source as a unit-amplitude Kronecker delta in the right-hand side $q$.\n- Place receivers along a horizontal line one grid cell below the surface at every grid column excluding the boundaries. That is, for $i_x \\in \\{1,2,\\dots,N_x-2\\}$ at $i_z = 1$.\n- Place a single localized squared-slowness perturbation at the domain center at index $(i_x,i_z) = (N_x/2, N_z/2)$ with amplitude\n$$\n\\delta m(\\mathbf{x}_\\star) = \\alpha m_0,\\quad \\alpha = 0.02,\n$$\nand zero elsewhere. This defines a single-scatterer Born model.\n\nForward modeling and imaging:\n- For a given frequency $f$ in $\\mathrm{Hz}$, compute $\\omega = 2\\pi f$. Solve for the background field $\\mathbf{u}_0$ from $\\mathbf{A}(\\omega)\\mathbf{u}_0 = \\mathbf{q}$.\n- Form the secondary source vector $\\mathbf{s}_\\mathrm{sc} = -\\omega^2\\,\\delta \\mathbf{m} \\odot \\mathbf{u}_0$, where $\\odot$ denotes pointwise multiplication and $\\delta \\mathbf{m}$ is the discretized perturbation field. Solve for the scattered field $\\mathbf{u}_s$ from $\\mathbf{A}(\\omega)\\mathbf{u}_s = \\mathbf{s}_\\mathrm{sc}$.\n- Extract the recorded data vector $\\mathbf{d}$ at receiver indices from $\\mathbf{u}_s$.\n- Back-propagate the data by solving $\\mathbf{A}(\\omega)\\boldsymbol{\\lambda} = \\mathbf{r}$, where $\\mathbf{r}$ is a vector of zeros with entries equal to the recorded data at the receiver locations (modeled as point injections).\n- Form the single-frequency image by the correlation-type imaging condition\n$$\n\\mathbf{I}_f = \\Re\\left\\{\\overline{\\mathbf{u}_0} \\odot \\boldsymbol{\\lambda}\\right\\}.\n$$\n\nMulti-frequency stacking:\n- For a list of frequencies $\\{f_k\\}$, compute $\\mathbf{I}_{f_k}$ for each $k$ and stack by simple summation\n$$\n\\mathbf{I}_\\mathrm{stack} = \\sum_k \\mathbf{I}_{f_k}.\n$$\n\nMetric for testable outputs:\n- Let $\\mathbf{x}_\\star$ denote the true scatterer grid index. Define the peak-to-sidelobe ratio at frequency $f$ as\n$$\nR(f) = \\frac{\\left|\\mathbf{I}_f(\\mathbf{x}_\\star)\\right|}{\\max_{\\mathbf{x} \\in \\Omega \\setminus \\mathcal{N}} \\left|\\mathbf{I}_f(\\mathbf{x})\\right| + \\varepsilon},\n$$\nwhere $\\Omega$ is the set of all grid points, $\\mathcal{N}$ is an exclusion neighborhood around $\\mathbf{x}_\\star$ of radius $r_\\mathrm{exc} = 3$ grid cells in the $\\ell_\\infty$ sense, and $\\varepsilon = 10^{-12}$ is a small stabilizer. For the multi-frequency stack, define $R_\\mathrm{stack}$ analogously by replacing $\\mathbf{I}_f$ with $\\mathbf{I}_\\mathrm{stack}$.\n\nUnits and numerical precision:\n- All physical inputs use the units stated above. The metric $R$ is dimensionless and must be reported as a floating-point number rounded to six digits after the decimal point.\n\nTest suite:\n- Use the following four test cases, each producing one scalar result:\n    - Case $1$ (single frequency): $f = 25\\,\\mathrm{Hz}$.\n    - Case $2$ (single frequency): $f = 35\\,\\mathrm{Hz}$.\n    - Case $3$ (multi-frequency stack): $f \\in \\{20\\,\\mathrm{Hz}, 25\\,\\mathrm{Hz}, 30\\,\\mathrm{Hz}, 35\\,\\mathrm{Hz}\\}$.\n    - Case $4$ (edge case, low frequency): $f = 10\\,\\mathrm{Hz}$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results for the four cases as a comma-separated list enclosed in square brackets, for example\n$[\\;r_1,r_2,r_3,r_4\\;]$,\nwhere $r_j$ are the four rounded floating-point metrics as specified above, with no additional text printed.", "solution": "We begin from the constant-density acoustic wave equation\n$$\n\\frac{\\partial^2 p(\\mathbf{x},t)}{\\partial t^2} - v(\\mathbf{x})^2 \\nabla^2 p(\\mathbf{x},t) = s(\\mathbf{x},t).\n$$\nFor time-harmonic fields at angular frequency $\\omega$ with the ansatz $p(\\mathbf{x},t) = \\Re\\{u(\\mathbf{x},\\omega) e^{-i \\omega t}\\}$, substitution yields\n$$\n(-\\omega^2) u(\\mathbf{x},\\omega) - v(\\mathbf{x})^2 \\nabla^2 u(\\mathbf{x},\\omega) = s_\\omega(\\mathbf{x}),\n$$\nor equivalently\n$$\n\\left(\\nabla^2 + \\omega^2 m(\\mathbf{x})\\right) u(\\mathbf{x},\\omega) = q(\\mathbf{x},\\omega),\n$$\nwith $m(\\mathbf{x}) = v(\\mathbf{x})^{-2}$ and $q(\\mathbf{x},\\omega) = v(\\mathbf{x})^{-2} s_\\omega(\\mathbf{x})$. In a medium expressed as a background plus a small perturbation, $m(\\mathbf{x}) = m_0(\\mathbf{x}) + \\delta m(\\mathbf{x})$ with $\\|\\delta m\\| \\ll \\|m_0\\|$, the background field $u_0$ and scattered field $u_s$ satisfy the pair of equations\n$$\n\\left(\\nabla^2 + \\omega^2 m_0\\right) u_0 = q,\\qquad\n\\left(\\nabla^2 + \\omega^2 m_0\\right) u_s = -\\omega^2 \\delta m\\, u_0,\n$$\nwhich is the first Born approximation. The right-hand side of the scattered equation plays the role of an equivalent source resulting from the perturbation interacting with the background field.\n\nFor Reverse Time Migration (RTM), one uses the adjoint of the modeling operator to back-propagate recorded data to the image space. In the frequency domain with real background $m_0$ and homogeneous boundary conditions, the Helmholtz operator is self-adjoint apart from boundary radiation conditions. Numerically, to mitigate spurious reflections from truncated domains, we add a small complex shift to emulate absorption, forming an operator\n$$\n\\mathbf{A}(\\omega) = \\mathbf{L} + \\omega^2 m_0 (1 - i \\eta)\\mathbf{I},\n$$\nwhere $\\mathbf{L}$ is the five-point discrete Laplacian, $\\mathbf{I}$ is the identity, and $\\eta > 0$ is small. This preserves a consistent adjoint action in the discrete setting. We discretize on a regular $N_x \\times N_z$ grid with spacings $\\Delta x$ and $\\Delta z$, and enforce homogeneous Dirichlet boundary conditions by replacing rows corresponding to boundary nodes with identity rows, which sets the boundary field to zero.\n\nGiven a single source at one grid cell below the surface and receivers along a shallow horizontal line, we proceed as follows for a given frequency $f$ with $\\omega = 2\\pi f$:\n1. Assemble $\\mathbf{A}(\\omega)$ from $\\mathbf{L}$ and the complex-shifted mass term $\\omega^2 m_0 (1 - i \\eta)$. The five-point Laplacian with Dirichlet boundaries uses the stencil\n$$\n\\left(\\mathbf{L} u\\right)_{i,j} = \\frac{u_{i+1,j} - 2 u_{i,j} + u_{i-1,j}}{\\Delta x^2} + \\frac{u_{i,j+1} - 2 u_{i,j} + u_{i,j-1}}{\\Delta z^2},\n$$\napplied only to interior nodes; boundary values are set to zero via identity rows.\n2. Solve for the background field $\\mathbf{A}(\\omega)\\mathbf{u}_0 = \\mathbf{q}$, with $\\mathbf{q}$ a unit-amplitude discrete delta at the source grid index.\n3. Construct the discrete Born source $\\mathbf{s}_\\mathrm{sc} = -\\omega^2 \\delta \\mathbf{m} \\odot \\mathbf{u}_0$ and solve $\\mathbf{A}(\\omega)\\mathbf{u}_s = \\mathbf{s}_\\mathrm{sc}$.\n4. Extract the data vector $\\mathbf{d}$ by sampling $\\mathbf{u}_s$ at the receiver locations.\n5. Back-propagate by injecting the recorded data at receiver positions: form $\\mathbf{r}$ which is zero everywhere except equals $\\mathbf{d}$ at receiver indices, and solve $\\mathbf{A}(\\omega)\\boldsymbol{\\lambda} = \\mathbf{r}$.\n6. Apply the correlation-type imaging condition\n$$\n\\mathbf{I}_f = \\Re\\{\\overline{\\mathbf{u}_0} \\odot \\boldsymbol{\\lambda}\\}.\n$$\n\nTo approximate the broadband character of time-domain imaging, perform multi-frequency stacking over a set of frequencies $\\{f_k\\}$ by summing the single-frequency images,\n$$\n\\mathbf{I}_\\mathrm{stack} = \\sum_k \\mathbf{I}_{f_k}.\n$$\nThis stacking reduces frequency-dependent sidelobes and improves resolution by constructive interference at the true scatterer location and partial cancellation elsewhere.\n\nFor quantitative assessment, we compute the peak-to-sidelobe ratio\n$$\nR(f) = \\frac{\\left|\\mathbf{I}_f(\\mathbf{x}_\\star)\\right|}{\\max_{\\mathbf{x}\\in \\Omega \\setminus \\mathcal{N}} \\left|\\mathbf{I}_f(\\mathbf{x})\\right| + \\varepsilon},\n$$\nwith an exclusion neighborhood $\\mathcal{N}$ of radius $r_\\mathrm{exc} = 3$ grid cells around the true location $\\mathbf{x}_\\star$, and a stabilizer $\\varepsilon = 10^{-12}$. The same formula defines $R_\\mathrm{stack}$ when $\\mathbf{I}_f$ is replaced by $\\mathbf{I}_\\mathrm{stack}$.\n\nAlgorithmic design choices and numerical considerations:\n- The homogeneous Dirichlet boundary condition and complex shift $\\eta = 0.05$ reduce non-physical boundary reflections while keeping the solver simple and robust. The grid spacing $\\Delta x = \\Delta z = 10\\,\\mathrm{m}$ and frequencies up to $f = 35\\,\\mathrm{Hz}$ yield at least several grid points per wavelength for $v_0 = 2000\\,\\mathrm{m/s}$, ensuring a reasonable discretization of the Helmholtz operator.\n- The Born perturbation amplitude $\\alpha = 0.02$ is small enough to be consistent with linearization while producing a measurable scattered signal.\n- The back-propagation right-hand side $\\mathbf{r}$ directly inserts the recorded pressure at receiver positions; because the operator is complex symmetric with a small absorption, this emulates the adjoint action needed for RTM.\n- The image is taken as the real part of the correlation $\\overline{\\mathbf{u}_0} \\odot \\boldsymbol{\\lambda}$ to remove phase ambiguity, consistent with conventional single-frequency imaging conditions.\n\nTest suite interpretation:\n- Case $1$ ($f = 25\\,\\mathrm{Hz}$) provides a mid-band single-frequency image with moderate resolution and contrast.\n- Case $2$ ($f = 35\\,\\mathrm{Hz}$) increases resolution; we expect an increased peak-to-sidelobe ratio due to shorter wavelength and better focusing.\n- Case $3$ (stack over $f \\in \\{20,25,30,35\\}\\,\\mathrm{Hz}$) approximates a broader bandwidth; we expect constructive summation at the true location with partial sidelobe cancellation, improving the ratio relative to most single-frequency cases.\n- Case $4$ ($f = 10\\,\\mathrm{Hz}$) represents a low-frequency, long-wavelength regime; we expect poorer resolution and thus a lower ratio.\n\nThe final program assembles the operator, computes the fields and images for the specified cases, evaluates the metric $R$, rounds each to six decimal places, and prints a single line in the required list format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef build_helmholtz_operator(nx, nz, dx, dz, m0, omega, eta):\n    \"\"\"\n    Build 2D Helmholtz operator with homogeneous Dirichlet boundary conditions\n    and a small complex shift (1 - i*eta) on the mass term.\n    \"\"\"\n    n = nx * nz\n    rows = []\n    cols = []\n    data = []\n    k2 = (omega ** 2) * m0 * (1.0 - 1j * eta)\n\n    inv_dx2 = 1.0 / (dx * dx)\n    inv_dz2 = 1.0 / (dz * dz)\n\n    def idx(ix, iz):\n        return iz * nx + ix\n\n    for iz in range(nz):\n        for ix in range(nx):\n            p = idx(ix, iz)\n            # Boundary nodes: enforce u = 0 by identity row\n            if ix == 0 or ix == nx - 1 or iz == 0 or iz == nz - 1:\n                rows.append(p); cols.append(p); data.append(1.0 + 0j)\n            else:\n                # Center\n                diag = -2.0 * inv_dx2 - 2.0 * inv_dz2 + k2\n                rows.append(p); cols.append(p); data.append(diag)\n                # Left neighbor\n                rows.append(p); cols.append(idx(ix - 1, iz)); data.append(inv_dx2)\n                # Right neighbor\n                rows.append(p); cols.append(idx(ix + 1, iz)); data.append(inv_dx2)\n                # Up neighbor\n                rows.append(p); cols.append(idx(ix, iz - 1)); data.append(inv_dz2)\n                # Down neighbor\n                rows.append(p); cols.append(idx(ix, iz + 1)); data.append(inv_dz2)\n\n    A = csr_matrix((np.array(data, dtype=np.complex128),\n                    (np.array(rows, dtype=np.int32), np.array(cols, dtype=np.int32))),\n                   shape=(n, n))\n    return A\n\ndef solve_field(A, rhs):\n    return spsolve(A, rhs)\n\ndef rtm_single_frequency(f_hz, nx, nz, dx, dz, v0, eta, alpha, src_ix, src_iz, rec_iz, scat_ix, scat_iz):\n    \"\"\"\n    Compute single-frequency RTM image and return the peak-to-sidelobe ratio at the true scatterer.\n    \"\"\"\n    omega = 2.0 * np.pi * f_hz\n    m0 = 1.0 / (v0 * v0)\n\n    # Build operator\n    A = build_helmholtz_operator(nx, nz, dx, dz, m0, omega, eta)\n\n    n = nx * nz\n    def lin(ix, iz):\n        return iz * nx + ix\n\n    # Source RHS\n    q = np.zeros(n, dtype=np.complex128)\n    q[lin(src_ix, src_iz)] = 1.0 + 0j\n\n    # Background field\n    u0 = solve_field(A, q)\n\n    # Born perturbation\n    dm = np.zeros(n, dtype=np.complex128)\n    dm[lin(scat_ix, scat_iz)] = alpha * m0\n\n    # Scattered field RHS\n    s_sc = - (omega ** 2) * dm * u0\n    us = solve_field(A, s_sc)\n\n    # Receivers along a horizontal line rec_iz at all interior ix\n    rec_ixs = list(range(1, nx - 1))\n    rec_ids = [lin(ix, rec_iz) for ix in rec_ixs]\n    d = us[rec_ids].copy()\n\n    # Back-propagation RHS: inject recorded data at receivers\n    r = np.zeros(n, dtype=np.complex128)\n    r[rec_ids] = d\n\n    lamb = solve_field(A, r)\n\n    # Imaging condition\n    I = np.real(np.conj(u0) * lamb)\n\n    # Peak-to-sidelobe ratio at true scatterer\n    I2d = I.reshape(nz, nx)\n    peak_val = abs(I2d[scat_iz, scat_ix])\n\n    # Exclude a neighborhood around the true location\n    r_exc = 3\n    mask = np.ones((nz, nx), dtype=bool)\n    i0 = max(0, scat_iz - r_exc)\n    i1 = min(nz, scat_iz + r_exc + 1)\n    j0 = max(0, scat_ix - r_exc)\n    j1 = min(nx, scat_ix + r_exc + 1)\n    mask[i0:i1, j0:j1] = False\n\n    side_max = np.max(np.abs(I2d[mask])) if np.any(mask) else 0.0\n    eps = 1e-12\n    ratio = peak_val / (side_max + eps)\n    return ratio, I2d\n\ndef rtm_stack_frequencies(f_list, nx, nz, dx, dz, v0, eta, alpha, src_ix, src_iz, rec_iz, scat_ix, scat_iz):\n    \"\"\"\n    Compute multi-frequency stacked RTM image and return the peak-to-sidelobe ratio at the true scatterer.\n    \"\"\"\n    I_stack = np.zeros((nz, nx), dtype=np.float64)\n    for f in f_list:\n        ratio, I2d = rtm_single_frequency(f, nx, nz, dx, dz, v0, eta, alpha,\n                                          src_ix, src_iz, rec_iz, scat_ix, scat_iz)\n        I_stack += I2d\n\n    peak_val = abs(I_stack[scat_iz, scat_ix])\n    r_exc = 3\n    mask = np.ones_like(I_stack, dtype=bool)\n    i0 = max(0, scat_iz - r_exc)\n    i1 = min(nz, scat_iz + r_exc + 1)\n    j0 = max(0, scat_ix - r_exc)\n    j1 = min(nx, scat_ix + r_exc + 1)\n    mask[i0:i1, j0:j1] = False\n\n    side_max = np.max(np.abs(I_stack[mask])) if np.any(mask) else 0.0\n    eps = 1e-12\n    ratio = peak_val / (side_max + eps)\n    return ratio\n\ndef solve():\n    # Grid and physical parameters\n    nx, nz = 50, 50\n    dx = dz = 10.0  # meters\n    v0 = 2000.0     # m/s\n    eta = 0.05      # dimensionless damping\n    alpha = 0.02    # relative perturbation in m0\n\n    # Geometry\n    src_ix = nx // 2\n    src_iz = 1\n    rec_iz = 1\n    scat_ix = nx // 2\n    scat_iz = nz // 2\n\n    # Test cases:\n    # 1: single frequency 25 Hz\n    # 2: single frequency 35 Hz\n    # 3: stack frequencies [20, 25, 30, 35] Hz\n    # 4: single frequency 10 Hz (low-frequency edge case)\n    test_cases = [\n        (\"single\", 25.0),\n        (\"single\", 35.0),\n        (\"stack\", [20.0, 25.0, 30.0, 35.0]),\n        (\"single\", 10.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        mode, val = case\n        if mode == \"single\":\n            ratio, _ = rtm_single_frequency(val, nx, nz, dx, dz, v0, eta, alpha,\n                                            src_ix, src_iz, rec_iz, scat_ix, scat_iz)\n            results.append(f\"{ratio:.6f}\")\n        elif mode == \"stack\":\n            ratio = rtm_stack_frequencies(val, nx, nz, dx, dz, v0, eta, alpha,\n                                          src_ix, src_iz, rec_iz, scat_ix, scat_iz)\n            results.append(f\"{ratio:.6f}\")\n        else:\n            # Should not occur\n            results.append(f\"{0.0:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3613775"}, {"introduction": "While the final RTM image provides a structural picture of the subsurface, its accuracy depends critically on the migration velocity model. This practice introduces a powerful diagnostic tool, the angle-domain common image gather (ADCIG), used to validate the velocity model. You will implement a common technique to generate these gathers by estimating local wavenumber vectors from the wavefield's phase gradient and using them to compute the scattering angle at each image point [@problem_id:3613787].", "problem": "Consider Reverse Time Migration (RTM) angle-domain common image gathers constructed from local plane-wave estimates. Assume a two-dimensional spatial grid with coordinates $x$ and $z$, and complex time-harmonic snapshots of the source wavefield $u_s(x,z)$ and receiver wavefield $u_r(x,z)$. The objective is to compute local wavenumber vectors and construct angle-domain energy gathers, then validate focusing for known incident configurations.\n\nFundamental basis to use:\n- Acoustic wave propagation is described by the acoustic wave equation, which in the time-harmonic regime reduces to the Helmholtz equation. It admits plane-wave solutions for which the spatial phase gradient equals the local wavenumber vector.\n- The zero-lag cross-correlation imaging condition in Reverse Time Migration (RTM) relates reflectivity to the correlation of source and receiver wavefields.\n- Angle-domain common image gathers (ADCIG) are constructed by mapping local wavenumber pairs to scattering angles, which quantify the angle between the source and receiver local propagation directions.\n\nTasks:\n1. Given complex fields $u_s(x,z)$ and $u_r(x,z)$ defined on a uniform grid with $N_x$ samples along $x$ and $N_z$ samples along $z$, and spacings $\\Delta x$ and $\\Delta z$ (in meters), estimate the local wavenumber vectors $\\mathbf{k}_s(x,z)$ and $\\mathbf{k}_r(x,z)$ using the phase-gradient principle that relates the imaginary part of $\\nabla u / u$ to the phase gradient. Use central finite differences to approximate spatial gradients with step sizes $\\Delta x$ and $\\Delta z$.\n2. For each grid location where both $\\|\\mathbf{k}_s(x,z)\\|$ and $\\|\\mathbf{k}_r(x,z)\\|$ exceed a small threshold (to avoid division by near-zero values), map the pair $\\big(\\mathbf{k}_s(x,z), \\mathbf{k}_r(x,z)\\big)$ to an angle of scattering $\\theta(x,z)$ in radians in $[0,\\pi]$, defined as the angle between the two local wavenumber vectors. Construct an angle-domain energy histogram $E(\\theta)$ by accumulating a nonnegative weight $w(x,z)$ at the corresponding angle bin. Use $w(x,z) = |u_s(x,z)|\\,|u_r(x,z)|$ as the weight. The histogram must have $N_\\theta$ bins spanning $[0,\\pi]$ uniformly.\n3. For each specified test case, compute a focusing metric $F$ as the ratio of energy in the bin containing the known true scattering angle $\\theta_{\\text{true}}$ to the total energy across all bins. If no valid samples contribute to the histogram, define $F$ to be $0.0$. Express $\\theta$ in radians for all computations. The final outputs are dimensionless floats.\n4. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\").\n\nGrid and units:\n- Use a Cartesian grid with $N_x$ and $N_z$ samples, spacings $\\Delta x$ and $\\Delta z$ in meters.\n- Angles must be treated and reported internally in radians.\n\nTest suite:\nFor each test case, construct $u_s(x,z)$ and $u_r(x,z)$ as complex plane waves with known wavenumber directions, except where specified otherwise. Let $k_0$ be the common magnitude of the wavenumber vectors in radians per meter. Define angles $\\alpha_s$ and $\\alpha_r$ (in radians) for $\\mathbf{k}_s$ and $\\mathbf{k}_r$ relative to the $x$-axis, so that $\\mathbf{k}_s = k_0[\\cos(\\alpha_s),\\sin(\\alpha_s)]$ and $\\mathbf{k}_r = k_0[\\cos(\\alpha_r),\\sin(\\alpha_r)]$. Construct the wavefields as $u_s(x,z) = \\exp\\big(i(\\mathbf{k}_s \\cdot \\mathbf{x})\\big)$ and $u_r(x,z) = \\exp\\big(i(\\mathbf{k}_r \\cdot \\mathbf{x})\\big)$, where $\\mathbf{x} = [x,z]$. For the edge case, set $u_r(x,z)$ to a spatially constant field with zero phase variation, which makes $\\mathbf{k}_r = \\mathbf{0}$ everywhere.\n\n- Test case $1$ (happy path): $N_x = 64$, $N_z = 64$, $\\Delta x = 10\\,\\text{m}$, $\\Delta z = 10\\,\\text{m}$, $k_0 = 0.2\\,\\text{rad/m}$, $\\alpha_s = 0.0\\,\\text{rad}$, $\\alpha_r = 0.0\\,\\text{rad}$, $N_\\theta = 180$. The true angle is $\\theta_{\\text{true}} = 0.0\\,\\text{rad}$.\n- Test case $2$ (oblique, general): $N_x = 64$, $N_z = 64$, $\\Delta x = 10\\,\\text{m}$, $\\Delta z = 10\\,\\text{m}$, $k_0 = 0.4\\,\\text{rad/m}$, $\\alpha_s = 0.3\\,\\text{rad}$, $\\alpha_r = 1.1\\,\\text{rad}$, $N_\\theta = 180$. The true angle is $\\theta_{\\text{true}} = |\\alpha_r - \\alpha_s|\\,\\text{rad}$.\n- Test case $3$ (near-opposite directions): $N_x = 64$, $N_z = 64$, $\\Delta x = 10\\,\\text{m}$, $\\Delta z = 10\\,\\text{m}$, $k_0 = 0.5\\,\\text{rad/m}$, $\\alpha_s = 0.0\\,\\text{rad}$, $\\alpha_r = \\pi\\,\\text{rad}$, $N_\\theta = 180$. The true angle is $\\theta_{\\text{true}} = \\pi\\,\\text{rad}$.\n- Test case $4$ (edge case with invalid receiver wavenumber): $N_x = 64$, $N_z = 64$, $\\Delta x = 10\\,\\text{m}$, $\\Delta z = 10\\,\\text{m}$, $k_0 = 0.3\\,\\text{rad/m}$, $\\alpha_s = 0.7\\,\\text{rad}$, and $u_r(x,z)$ is spatially constant with no phase variation (so $\\mathbf{k}_r = \\mathbf{0}$). Use $N_\\theta = 180$. The expected focusing metric is $F = 0.0$ because no valid angle can be formed.\n\nAlgorithmic specifics:\n- Use central differences to compute $\\partial u/\\partial x$ and $\\partial u/\\partial z$.\n- Estimate local wavenumbers by $\\mathbf{k}(x,z) \\approx \\operatorname{Im}\\left(\\frac{\\nabla u(x,z)}{u(x,z)}\\right)$ applied componentwise.\n- Define a small threshold $\\varepsilon = 10^{-8}$ (in radians per meter) and exclude any grid points where $\\|\\mathbf{k}_s(x,z)\\| < \\varepsilon$ or $\\|\\mathbf{k}_r(x,z)\\| < \\varepsilon$.\n- The histogram weight must be $w(x,z) = |u_s(x,z)|\\,|u_r(x,z)|$.\n- The final output must be a single line of the form \"[F1,F2,F3,F4]\" where each $Fj$ is a float.\n\nYour program should implement the above and output the focusing metrics in the specified format as a comma-separated list enclosed in square brackets on a single line.", "solution": "**1. Estimation of Local Wavenumber Vectors**\n\nFor a monochromatic acoustic wavefield described by a complex function $u(\\mathbf{x}) = A(\\mathbf{x}) e^{i\\phi(\\mathbf{x})}$, where $A(\\mathbf{x})$ is the amplitude and $\\phi(\\mathbf{x})$ is the phase at position $\\mathbf{x} = [x, z]$, the local wavenumber vector $\\mathbf{k}(\\mathbf{x})$ is defined as the gradient of the phase:\n$$\n\\mathbf{k}(\\mathbf{x}) = \\nabla \\phi(\\mathbf{x})\n$$\nThe gradient of the complex field is $\\nabla u = (\\nabla A) e^{i\\phi} + A (i\\nabla\\phi) e^{i\\phi}$. Dividing by $u$ gives:\n$$\n\\frac{\\nabla u}{u} = \\frac{\\nabla A}{A} + i \\nabla \\phi = \\frac{\\nabla A}{A} + i\\mathbf{k}\n$$\nBy taking the imaginary part of this expression, we can isolate the local wavenumber vector:\n$$\n\\mathbf{k}(\\mathbf{x}) = \\operatorname{Im}\\left(\\frac{\\nabla u(\\mathbf{x})}{u(\\mathbf{x})}\\right)\n$$\nThis principle is applied to both the source wavefield, $u_s(x,z)$, and the receiver wavefield, $u_r(x,z)$, to obtain their respective local wavenumber vector fields, $\\mathbf{k}_s(x,z)$ and $\\mathbf{k}_r(x,z)$.\n\nNumerically, the spatial grid is discrete, with spacings $\\Delta x$ and $\\Delta z$. The gradient $\\nabla u = [\\frac{\\partial u}{\\partial x}, \\frac{\\partial u}{\\partial z}]$ is approximated using a second-order accurate central finite difference scheme. For an interior grid point $(x_i, z_j)$, the derivatives are:\n$$\n\\frac{\\partial u}{\\partial x}(x_i, z_j) \\approx \\frac{u(x_{i+1}, z_j) - u(x_{i-1}, z_j)}{2\\Delta x}\n$$\n$$\n\\frac{\\partial u}{\\partial z}(x_i, z_j) \\approx \\frac{u(x_i, z_{j+1}) - u(x_i, z_{j-1})}{2\\Delta z}\n$$\nThis computation is performed across the entire grid for both $u_s$ and $u_r$.\n\n**2. Mapping Wavenumbers to Scattering Angles**\n\nAt each grid point $(x,z)$, the pair of local wavenumber vectors $(\\mathbf{k}_s, \\mathbf{k}_r)$ represents the local propagation directions of the source and receiver wavefields. The scattering angle, $\\theta(x,z)$, is the angle between these two vectors. It is computed using the dot product formula:\n$$\n\\theta(x,z) = \\arccos\\left(\\frac{\\mathbf{k}_s(x,z) \\cdot \\mathbf{k}_r(x,z)}{\\|\\mathbf{k}_s(x,z)\\| \\|\\mathbf{k}_r(x,z)\\|}\\right)\n$$\nThe result of the $\\arccos$ function is naturally in the required range $[0, \\pi]$. This calculation is only performed at grid locations deemed valid, i.e., where the magnitudes of both wavenumber vectors exceed a small threshold $\\varepsilon = 10^{-8}$. This condition prevents numerical instability from division by zero, which would occur in regions of zero or constant phase where the wavenumber is null.\n\n**3. Histogram Construction and Focusing Metric**\n\nAn angle-domain common image gather (ADCIG) is constructed as a histogram, $E(\\theta)$, which accumulates energy as a function of the scattering angle. The range $[0, \\pi]$ is divided into $N_\\theta$ uniform bins. For each valid grid point $(x,z)$, the computed scattering angle $\\theta(x,z)$ determines the bin, and a weight $w(x,z)$ is added to that bin's accumulator. The problem specifies the weight as:\n$$\nw(x,z) = |u_s(x,z)|\\,|u_r(x,z)|\n$$\nAfter processing all valid grid points, the total energy in the histogram is $E_{\\text{total}} = \\sum_{j=1}^{N_\\theta} E(\\theta_j)$.\n\nThe focusing metric, $F$, quantifies how well the energy is concentrated at the theoretically known true scattering angle, $\\theta_{\\text{true}}$. It is defined as the ratio of the energy in the specific bin that contains $\\theta_{\\text{true}}$ to the total energy in the histogram:\n$$\nF = \\frac{E(\\text{bin containing } \\theta_{\\text{true}})}{E_{\\text{total}}}\n$$\nIf the histogram is empty because no valid grid points were found (as in Test Case 4), both the numerator and denominator are zero, and $F$ is defined to be $0.0$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_focusing_metric(\n    Nx, Nz, dx, dz, us_func, ur_func, N_theta, theta_true, k_thresh\n):\n    \"\"\"\n    Computes the focusing metric for angle-domain common image gathers.\n    \n    Args:\n        Nx (int): Number of grid points in x.\n        Nz (int): Number of grid points in z.\n        dx (float): Grid spacing in x (meters).\n        dz (float): Grid spacing in z (meters).\n        us_func (callable): Function to generate source wavefield u_s(x, z).\n        ur_func (callable): Function to generate receiver wavefield u_r(x, z).\n        N_theta (int): Number of angle bins for the histogram.\n        theta_true (float): True scattering angle (radians).\n        k_thresh (float): Threshold for wavenumber magnitude.\n\n    Returns:\n        float: The focusing metric F.\n    \"\"\"\n    # 1. Create grid and wavefields\n    x = np.arange(Nx) * dx\n    z = np.arange(Nz) * dz\n    xx, zz = np.meshgrid(x, z)\n\n    u_s = us_func(xx, zz)\n    u_r = ur_func(xx, zz)\n\n    # 2. Estimate local wavenumbers using phase-gradient\n    # np.gradient returns gradients along each axis. For a 2D array (Nz, Nx),\n    # it returns (grad_z, grad_x). The spacings must be provided in the same order (dz, dx).\n    grad_s_z, grad_s_x = np.gradient(u_s, dz, dx, edge_order=2)\n    grad_r_z, grad_r_x = np.gradient(u_r, dz, dx, edge_order=2)\n    \n    # Add a small epsilon to the denominator to avoid division by zero\n    # in case u_s or u_r is zero somewhere, although not for the given test cases.\n    denom_s = u_s + 1e-12\n    denom_r = u_r + 1e-12\n\n    k_s_x = np.imag(grad_s_x / denom_s)\n    k_s_z = np.imag(grad_s_z / denom_s)\n    \n    k_r_x = np.imag(grad_r_x / denom_r)\n    k_r_z = np.imag(grad_r_z / denom_r)\n\n    # 3. Filter points based on wavenumber magnitude\n    k_s_norm = np.sqrt(k_s_x**2 + k_s_z**2)\n    k_r_norm = np.sqrt(k_r_x**2 + k_r_z**2)\n    \n    valid_mask = (k_s_norm >= k_thresh) & (k_r_norm >= k_thresh)\n    \n    if not np.any(valid_mask):\n        return 0.0\n\n    # 4. Map valid wavenumbers to scattering angles\n    k_s_x_valid = k_s_x[valid_mask]\n    k_s_z_valid = k_s_z[valid_mask]\n    k_r_x_valid = k_r_x[valid_mask]\n    k_r_z_valid = k_r_z[valid_mask]\n\n    k_s_norm_valid = k_s_norm[valid_mask]\n    k_r_norm_valid = k_r_norm[valid_mask]\n    \n    dot_product = k_s_x_valid * k_r_x_valid + k_s_z_valid * k_r_z_valid\n    \n    # Clip argument to arccos to handle potential floating point inaccuracies\n    cos_theta = np.clip(dot_product / (k_s_norm_valid * k_r_norm_valid), -1.0, 1.0)\n    angles = np.arccos(cos_theta)\n    \n    # 5. Construct angle-domain energy histogram\n    weights = np.abs(u_s[valid_mask]) * np.abs(u_r[valid_mask])\n    \n    bin_edges = np.linspace(0, np.pi, N_theta + 1)\n    hist_E, _ = np.histogram(angles, bins=bin_edges, weights=weights)\n\n    total_E = np.sum(hist_E)\n    \n    if total_E == 0:\n        return 0.0\n\n    # 6. Compute focusing metric F\n    bin_width = np.pi / N_theta\n    # Calculate the index of the bin containing the true angle\n    # Handle the edge case where theta_true = pi\n    true_bin_index = int(theta_true / bin_width)\n    if true_bin_index >= N_theta:\n        true_bin_index = N_theta - 1\n        \n    E_true = hist_E[true_bin_index]\n    \n    F = E_true / total_E\n    \n    return F\n\ndef solve():\n    \"\"\"\n    Main solver function that runs all test cases and prints the results.\n    \"\"\"\n    def make_plane_wave(k0, alpha):\n        kx = k0 * np.cos(alpha)\n        kz = k0 * np.sin(alpha)\n        return lambda x, z: np.exp(1j * (kx * x + kz * z))\n\n    def make_constant_field():\n        return lambda x, z: np.ones_like(x, dtype=np.complex128)\n\n    test_cases = [\n        # Case 1: Happy path\n        {'Nx': 64, 'Nz': 64, 'dx': 10.0, 'dz': 10.0, 'k0': 0.2, 'alpha_s': 0.0, 'alpha_r': 0.0, 'N_theta': 180},\n        # Case 2: Oblique, general\n        {'Nx': 64, 'Nz': 64, 'dx': 10.0, 'dz': 10.0, 'k0': 0.4, 'alpha_s': 0.3, 'alpha_r': 1.1, 'N_theta': 180},\n        # Case 3: Near-opposite directions\n        {'Nx': 64, 'Nz': 64, 'dx': 10.0, 'dz': 10.0, 'k0': 0.5, 'alpha_s': 0.0, 'alpha_r': np.pi, 'N_theta': 180},\n        # Case 4: Edge case with invalid receiver wavenumber\n        {'Nx': 64, 'Nz': 64, 'dx': 10.0, 'dz': 10.0, 'k0': 0.3, 'alpha_s': 0.7, 'N_theta': 180},\n    ]\n\n    results = []\n    k_thresh = 1e-8\n\n    for i, params in enumerate(test_cases):\n        if i == 3: # Test Case 4\n            us_func = make_plane_wave(params['k0'], params['alpha_s'])\n            ur_func = make_constant_field()\n            # As per problem, kr is zero, so no valid angle can be formed. \n            # The manual calculation is not strictly needed as the code handles it.\n            theta_true = 0.0 # dummy value, not used for F=0 case\n        else:\n            us_func = make_plane_wave(params['k0'], params['alpha_s'])\n            ur_func = make_plane_wave(params['k0'], params['alpha_r'])\n            theta_true = np.abs(params['alpha_r'] - params['alpha_s'])\n        \n        F = compute_focusing_metric(\n            params['Nx'], params['Nz'], params['dx'], params['dz'],\n            us_func, ur_func, params['N_theta'], theta_true, k_thresh\n        )\n        results.append(F)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3613787"}, {"introduction": "The theoretical elegance of RTM meets a significant practical challenge in its computational cost, particularly the massive storage required for the source wavefield. This hands-on exercise moves from imaging theory to implementation strategy, asking you to model the performance of a hybrid boundary-saving and sparse checkpointing scheme. By analyzing the trade-offs between storage, re-computation, and I/O bandwidth, you will develop a quantitative understanding of what it takes to make RTM feasible for large-scale industrial problems [@problem_id:3613773].", "problem": "You are asked to design and analyze a hybrid boundary-saving plus sparse checkpointing scheme for Reverse Time Migration (RTM) in computational geophysics. Consider a two-dimensional acoustic finite-difference time-domain wave propagation used in RTM. Use the following fundamental basis and assumptions to derive the required input/output model and compute the I/O bandwidth necessary to avoid throttling the compute pipeline.\n\nFundamental basis and modeling assumptions:\n- The acoustic wave equation in a homogeneous medium is given by the second-order linear partial differential equation\n$$\n\\frac{\\partial^2 u}{\\partial t^2} = v^2 \\left( \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial z^2} \\right),\n$$\nwhere $u$ is the pressure field and $v$ is the wave speed. In finite-difference time-domain discretization, the spatial derivatives are approximated using a stencil of half-width $h$ grid points, which implies saving a boundary of thickness $h$ is sufficient to regenerate the interior during reverse-time replay when using a second-order-in-time scheme.\n- Let the grid be of size $N_x \\times N_z$ points, and the number of time steps be $N_t$. Let each scalar field sample occupy $b$ bytes. Assume one scalar field component per sample is stored at the boundary and in snapshots, with $n_b$ components per boundary sample and $n_s$ components per snapshot sample, where $n_b, n_s \\in \\{1,2,\\dots\\}$.\n- Let $f_{\\text{gp}}$ denote the floating-point operation count per grid point per time step, and $P$ denote the sustained floating-point performance in floating-point operations per second (FLOP/s). Then the compute time per time step is\n$$\nt_c = \\frac{N_x N_z f_{\\text{gp}}}{P}.\n$$\n\nHybrid boundary-saving and sparse checkpointing design:\n- At every time step, save only the boundary region of thickness $h$ around the model domain so that the reverse-time reconstruction can be driven from these boundary conditions. The boundary point count is\n$$\nN_{\\text{bnd}} = 2 h N_x + 2 h (N_z - 2 h) = 2 h \\bigl( N_x + N_z - 2 h \\bigr).\n$$\nThe boundary data volume per time step is\n$$\nD_b = N_{\\text{bnd}} \\cdot n_b \\cdot b \\quad \\text{bytes}.\n$$\n- In addition, save a full-volume sparse checkpoint (a snapshot) every $k$ time steps, with $k \\in \\mathbb{N}$, $k \\ge 1$. A snapshot data volume is\n$$\nD_s = N_x N_z \\cdot n_s \\cdot b \\quad \\text{bytes}.\n$$\n- Allow the special case $k=0$ to represent a pure boundary-saving scheme with no snapshots, so that $D_s$ is effectively never incurred.\n\nBandwidth definitions to avoid compute throttling:\n- Define the per-step synchronous bandwidth requirement (no inter-step amortization) as the minimal I/O bandwidth $B_{\\text{sync}}$ such that all I/O that logically occurs at a step completes within that same stepâ€™s compute time $t_c$:\n    - If $k=0$, then\n    $$\n    B_{\\text{sync}} = \\frac{D_b}{t_c}.\n    $$\n    - If $k \\ge 1$, then in the snapshot steps the I/O volume is $D_b + D_s$, and in non-snapshot steps it is $D_b$. To avoid throttling in every step,\n    $$\n    B_{\\text{sync}} = \\max\\left( \\frac{D_b}{t_c}, \\frac{D_b + D_s}{t_c} \\right) = \\frac{D_b + D_s}{t_c}.\n    $$\n- Define the sustained bandwidth requirement (deeply buffered streaming) as the minimal I/O bandwidth $B_{\\text{sust}}$ such that I/O averaged over a window of $k$ steps does not exceed the compute time of those steps. With adequate buffering, snapshots can be amortized across the window:\n    - If $k=0$, then\n    $$\n    B_{\\text{sust}} = \\frac{D_b}{t_c}.\n    $$\n    - If $k \\ge 1$, then over $k$ steps the I/O volume is $k D_b + D_s$, and the compute time is $k t_c$, hence the average-rate requirement is\n    $$\n    \\frac{k D_b + D_s}{k t_c}.\n    $$\n    However, the boundary stream must still be sustained each step, so the required sustained bandwidth is\n    $$\n    B_{\\text{sust}} = \\max\\left( \\frac{D_b}{t_c}, \\frac{k D_b + D_s}{k t_c} \\right).\n    $$\n\nForward and backward phases:\n- In RTM, forward modeling writes boundary and snapshot data; backward propagation reads them. Assume the read and write phases are non-overlapping in time. Then the peak bandwidth requirement is governed by the larger of the forward or backward per-step rates. Under symmetric assumptions, both phases have the same per-step I/O volume, so the required bandwidth expressions above suffice without additional scaling.\n\nYour task:\n- Implement a program that, for a given set of parameters, computes $B_{\\text{sync}}$ and $B_{\\text{sust}}$ in gigabytes per second (GB/s). Report both values for each test case. Convert bytes per second to GB/s by dividing by $10^9$. Round each reported bandwidth to three decimal places. No user input is required; the program must compute the answers for the built-in test suite below.\n\nTest suite:\n- Use the following four parameter sets, which probe typical, precision-change, large-model, and boundary-only edge cases.\n    1. Happy path:\n        - $N_x = 2000$, $N_z = 1000$, $N_t = 4000$, $h = 4$, $b = 4$, $n_b = 1$, $n_s = 1$, $f_{\\text{gp}} = 50$, $P = 1 \\times 10^{11}$, $k = 200$.\n    2. Dense checkpointing and double precision:\n        - $N_x = 2000$, $N_z = 1000$, $N_t = 4000$, $h = 4$, $b = 8$, $n_b = 1$, $n_s = 1$, $f_{\\text{gp}} = 50$, $P = 1 \\times 10^{11}$, $k = 1$.\n    3. Large model with higher performance and different stencil cost:\n        - $N_x = 8000$, $N_z = 4000$, $N_t = 4000$, $h = 4$, $b = 4$, $n_b = 1$, $n_s = 1$, $f_{\\text{gp}} = 60$, $P = 2 \\times 10^{11}$, $k = 100$.\n    4. Boundary-only scheme (no snapshots):\n        - $N_x = 1500$, $N_z = 1500$, $N_t = 4000$, $h = 8$, $b = 4$, $n_b = 1$, $n_s = 1$, $f_{\\text{gp}} = 50$, $P = 8 \\times 10^{10}$, $k = 0$.\n\nAnswer specification:\n- For each test case, compute two floats: $B_{\\text{sync}}$ and $B_{\\text{sust}}$, both in GB/s, rounded to three decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list of lists, each inner list holding the pair for one test case, in the exact format\n\"[[Bsync_case1,Bsust_case1],[Bsync_case2,Bsust_case2],[Bsync_case3,Bsust_case3],[Bsync_case4,Bsust_case4]]\".", "solution": "The objective is to calculate two key I/O performance metrics, the synchronous bandwidth $B_{\\text{sync}}$ and the sustained bandwidth $B_{\\text{sust}}$, for a hybrid boundary-saving and sparse checkpointing scheme in RTM. The calculations are based on a set of provided parameters and formulae. The final results must be reported in gigabytes per second (GB/s), rounded to three decimal places.\n\nThe analytical process involves several steps derived from the principles outlined in the problem statement.\n\nFirst, we calculate the fundamental quantities that underpin the bandwidth requirements.\nThe compute time per time step, $t_c$, is the time available for I/O operations at each step without stalling the computation. It is defined as a function of the grid size ($N_x$, $N_z$), the floating-point operations per grid point per step ($f_{\\text{gp}}$), and the machine's sustained performance ($P$):\n$$\nt_c = \\frac{N_x N_z f_{\\text{gp}}}{P}\n$$\nThe data volume for the boundary region, $D_b$, is the amount of data written at every time step. It depends on the stencil half-width $h$, the grid dimensions ($N_x$, $N_z$), the number of components per boundary sample $n_b$, and the bytes per sample $b$. The number of boundary points is $N_{\\text{bnd}} = 2h(N_x + N_z - 2h)$. The data volume is thus:\n$$\nD_b = N_{\\text{bnd}} \\cdot n_b \\cdot b = 2h(N_x + N_z - 2h) \\cdot n_b \\cdot b\n$$\nThe data volume for a full-volume snapshot, $D_s$, is the amount of data written intermittently every $k$ steps. It depends on the grid size, the number of components per snapshot sample $n_s$, and the bytes per sample $b$:\n$$\nD_s = N_x N_z \\cdot n_s \\cdot b\n$$\n\nSecond, we use these quantities to compute the required bandwidths, $B_{\\text{sync}}$ and $B_{\\text{sust}}$, according to their definitions, handling the cases for $k=0$ and $k \\ge 1$ separately.\n\nFor synchronous bandwidth, $B_{\\text{sync}}$, the system must handle the peak I/O load within a single time step's compute time, $t_c$.\nIf $k=0$ (boundary saving only), the per-step I/O is always $D_b$.\n$$\nB_{\\text{sync}} = \\frac{D_b}{t_c} \\quad (\\text{for } k=0)\n$$\nIf $k \\ge 1$, the worst-case I/O occurs on steps where both a boundary and a snapshot are saved, with a total volume of $D_b + D_s$.\n$$\nB_{\\text{sync}} = \\frac{D_b + D_s}{t_c} \\quad (\\text{for } k \\ge 1)\n$$\n\nFor sustained bandwidth, $B_{\\text{sust}}$, the I/O for snapshots can be amortized over the $k$ time steps between them, assuming a sufficiently deep I/O buffer.\nIf $k=0$, there is no amortization, and the sustained requirement is the same as the synchronous one.\n$$\nB_{\\text{sust}} = \\frac{D_b}{t_c} \\quad (\\text{for } k=0)\n$$\nIf $k \\ge 1$, the total data written over a window of $k$ steps is $k D_b + D_s$, and the total compute time is $k t_c$. The average bandwidth requirement is $(k D_b + D_s)/(k t_c)$. However, the stream of boundary data $D_b$ must still be written at each step, imposing a minimum bandwidth of $D_b/t_c$. The sustained bandwidth is therefore the maximum of these two rates.\n$$\nB_{\\text{sust}} = \\max\\left( \\frac{D_b}{t_c}, \\frac{k D_b + D_s}{k t_c} \\right) = \\max\\left( \\frac{D_b}{t_c}, \\frac{D_b}{t_c} + \\frac{D_s}{k t_c} \\right) \\quad (\\text{for } k \\ge 1)\n$$\nSince $D_s$, $k$, and $t_c$ are all positive for $k \\ge 1$, the second term is always larger. Thus, for $k \\ge 1$, the expression simplifies to:\n$$\nB_{\\text{sust}} = \\frac{k D_b + D_s}{k t_c} = \\frac{D_b}{t_c} + \\frac{D_s}{k t_c}\n$$\n\nFinally, the results in bytes per second are converted to gigabytes per second by dividing by $10^9$, and then rounded to three decimal places as specified.\n\nLet us demonstrate the calculation for the first test case:\n$N_x = 2000$, $N_z = 1000$, $h = 4$, $b = 4$, $n_b = 1$, $n_s = 1$, $f_{\\text{gp}} = 50$, $P = 1 \\times 10^{11}$, $k = 200$.\n\n$1$. Compute $t_c$:\n$$t_c = \\frac{2000 \\cdot 1000 \\cdot 50}{1 \\times 10^{11}} = \\frac{10^8}{10^{11}} = 0.001 \\text{ s}$$\n$2$. Compute $D_b$:\n$$N_{\\text{bnd}} = 2 \\cdot 4 \\cdot (2000 + 1000 - 2 \\cdot 4) = 8 \\cdot 2992 = 23936$$\n$$D_b = 23936 \\cdot 1 \\cdot 4 = 95744 \\text{ bytes}$$\n$3$. Compute $D_s$:\n$$D_s = 2000 \\cdot 1000 \\cdot 1 \\cdot 4 = 8 \\times 10^6 \\text{ bytes}$$\n$4$. Compute bandwidths. Since $k=200 \\ge 1$:\n$$B_{\\text{sync}} = \\frac{95744 + 8 \\times 10^6}{0.001} = 8,095,744,000 \\text{ bytes/s} \\approx 8.096 \\text{ GB/s}$$\n$$B_{\\text{sust}} = \\frac{200 \\cdot 95744 + 8 \\times 10^6}{200 \\cdot 0.001} = \\frac{19,148,800 + 8,000,000}{0.2} = \\frac{27,148,800}{0.2} = 135,744,000 \\text{ bytes/s} \\approx 0.136 \\text{ GB/s}$$\n\nApplying this procedure to all four test cases yields the following results:\nCase $1$: $B_{\\text{sync}} = 8.096$ GB/s, $B_{\\text{sust}} = 0.136$ GB/s.\nCase $2$: $B_{\\text{sync}} = 16.191$ GB/s, $B_{\\text{sust}} = 16.191$ GB/s.\nCase $3$: $B_{\\text{sync}} = 13.373$ GB/s, $B_{\\text{sust}} = 0.173$ GB/s.\nCase $4$: $B_{\\text{sync}} = 0.136$ GB/s, $B_{\\text{sust}} = 0.136$ GB/s.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other special libraries from scipy etc. are needed.\n\ndef solve():\n    \"\"\"\n    Computes synchronous and sustained I/O bandwidth requirements for RTM\n    based on a hybrid checkpointing scheme for a given set of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1. Happy path:\n        {'Nx': 2000, 'Nz': 1000, 'h': 4, 'b': 4, 'nb': 1, 'ns': 1, 'fgp': 50, 'P': 1e11, 'k': 200},\n        # 2. Dense checkpointing and double precision:\n        {'Nx': 2000, 'Nz': 1000, 'h': 4, 'b': 8, 'nb': 1, 'ns': 1, 'fgp': 50, 'P': 1e11, 'k': 1},\n        # 3. Large model with higher performance and different stencil cost:\n        {'Nx': 8000, 'Nz': 4000, 'h': 4, 'b': 4, 'nb': 1, 'ns': 1, 'fgp': 60, 'P': 2e11, 'k': 100},\n        # 4. Boundary-only scheme (no snapshots):\n        {'Nx': 1500, 'Nz': 1500, 'h': 8, 'b': 4, 'nb': 1, 'ns': 1, 'fgp': 50, 'P': 8e10, 'k': 0},\n    ]\n\n    results = []\n    for params in test_cases:\n        # Unpack parameters for clarity\n        Nx, Nz = params['Nx'], params['Nz']\n        h, b = params['h'], params['b']\n        nb, ns = params['nb'], params['ns']\n        fgp, P, k = params['fgp'], params['P'], params['k']\n\n        # 1. Calculate compute time per time step (tc) in seconds.\n        # tc = (N_x * N_z * f_gp) / P\n        tc = (Nx * Nz * fgp) / P\n\n        # 2. Calculate boundary data volume per time step (Db) in bytes.\n        # N_bnd = 2*h*(N_x + N_z - 2*h)\n        # Db = N_bnd * n_b * b\n        N_bnd = 2 * h * (Nx + Nz - 2 * h)\n        Db = N_bnd * nb * b\n\n        # 3. Calculate full snapshot data volume (Ds) in bytes.\n        # Ds = N_x * N_z * n_s * b\n        Ds = Nx * Nz * ns * b\n\n        # 4. Calculate synchronous (B_sync) and sustained (B_sust) bandwidths\n        # in bytes per second (B/s).\n        B_sync_bps = 0.0\n        B_sust_bps = 0.0\n\n        if k == 0:\n            # Boundary-only scheme\n            # B_sync = Db / tc\n            # B_sust = Db / tc\n            B_sync_bps = Db / tc\n            B_sust_bps = B_sync_bps\n        else:  # k >= 1\n            # Hybrid boundary-saving and sparse checkpointing scheme\n            # B_sync = (Db + Ds) / tc\n            B_sync_bps = (Db + Ds) / tc\n            \n            # B_sust = max( Db/tc, (k*Db + Ds)/(k*tc) )\n            # The second term is always greater or equal, so we can simplify.\n            B_sust_bps = (k * Db + Ds) / (k * tc)\n        \n        # 5. Convert from B/s to GB/s (1 GB = 10^9 B) and round to 3 decimal places.\n        GB_CONVERSION_FACTOR = 1e9\n        B_sync_gbs = round(B_sync_bps / GB_CONVERSION_FACTOR, 3)\n        B_sust_gbs = round(B_sust_bps / GB_CONVERSION_FACTOR, 3)\n        \n        results.append([B_sync_gbs, B_sust_gbs])\n\n    # Final print statement in the exact required format.\n    # \"[[Bsync_case1,Bsust_case1],[Bsync_case2,Bsust_case2],...]\"\n    # We construct the string manually to avoid spaces introduced by default list-to-string conversion.\n    inner_lists = [f\"[{res[0]},{res[1]}]\" for res in results]\n    output_string = f\"[{','.join(inner_lists)}]\"\n    print(output_string)\n\nsolve()\n```", "id": "3613773"}]}