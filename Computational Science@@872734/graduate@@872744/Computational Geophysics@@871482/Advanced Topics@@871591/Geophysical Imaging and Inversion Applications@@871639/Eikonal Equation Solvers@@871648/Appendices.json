{"hands_on_practices": [{"introduction": "Before implementing a full solver, it is crucial to understand the local problem: how to update the travel time at a single grid point using its neighbors. This foundational exercise [@problem_id:3588080] guides you through the derivation of the first-order Godunov-type upwind scheme, starting from the continuous eikonal equation $| \\nabla T | = s$. Mastering this derivation will clarify the causal logic behind the method and the critical condition that determines whether a wavefront is best approximated as arriving from one principal direction or from an intermediate angle between two.", "problem": "Consider first-arrival seismic travel time in a two-dimensional isotropic medium, where the travel-time field $T(x,y)$ satisfies the eikonal equation $|\\nabla T| = s(x,y)$, with slowness $s(x,y) = 1/v(x,y)$. On a uniform Cartesian grid of spacing $h$, use a monotone first-order upwind finite difference discretization consistent with the Godunov flux to update the unknown node $(i,j)$ from already accepted neighbor values. Suppose that at $(i,j)$ the only accepted neighbors contributing to the update are the ones in two orthogonal directions (e.g., west and south), with travel times $a$ and $b$, respectively, where $a \\le b$. Assume that $s$ is known and constant within the cell containing $(i,j)$.\n \nStarting from the continuous eikonal equation and the monotone upwind discretization (without invoking any pre-derived update formulas), derive the scalar algebraic equation for the local update at $(i,j)$ and solve it to obtain an explicit expression for the updated $T$ in terms of $a$, $b$, $h$, and $s$. Clearly identify the condition under which the update reduces to a one-sided expression that depends only on the smallest neighbor. \n\nThen, evaluate the updated $T$ for the following physically plausible parameters:\n- Neighbor travel times: $a = 0.100 \\ \\mathrm{s}$ and $b = 0.120 \\ \\mathrm{s}$.\n- Grid spacing: $h = 10 \\ \\mathrm{m}$.\n- Constant velocity: $v = 2000 \\ \\mathrm{m} \\ \\mathrm{s}^{-1}$ (so $s = 1/v$).\n\nExpress the final updated $T$ in seconds and round your answer to four significant figures. Report only the computed updated $T$.", "solution": "The problem asks for the derivation of the finite difference update for the travel time $T$ governed by the eikonal equation, its solution under specific conditions, and a numerical evaluation. The problem is well-posed and scientifically sound, meriting a full solution.\n\nThe two-dimensional eikonal equation is given by:\n$$|\\nabla T|^2 = s^2(x,y)$$\nwhere $T(x,y)$ is the travel-time field and $s(x,y)$ is the slowness field. In Cartesian coordinates, this expands to:\n$$\\left(\\frac{\\partial T}{\\partial x}\\right)^2 + \\left(\\frac{\\partial T}{\\partial y}\\right)^2 = s^2$$\n\nWe are to use a first-order upwind finite difference scheme on a uniform Cartesian grid with spacing $h$. An upwind scheme approximates the gradient components using only nodes with smaller travel time values, respecting the direction of information flow (causality).\n\nLet $T$ be the unknown travel time at node $(i,j)$. The problem states that the update is from two accepted orthogonal neighbors, which we can label as the west neighbor $(i-1,j)$ and the south neighbor $(i,j-1)$ without loss of generality. Their travel times are given as $a$ and $b$, with $a \\le b$. Let $T_{i-1,j} = a$ and $T_{i,j-1} = b$. For an update to occur, the new travel time $T$ must be greater than that of its known neighbors, i.e., $T>a$ and $T>b$.\n\nUnder the assumption that the wavefront arrives from a direction between the south and west axes (a two-sided update), both neighbors contribute. The partial derivatives at $(i,j)$ are approximated using first-order backward differences:\n$$\\frac{\\partial T}{\\partial x} \\approx \\frac{T - T_{i-1,j}}{h} = \\frac{T-a}{h}$$\n$$\\frac{\\partial T}{\\partial y} \\approx \\frac{T - T_{i,j-1}}{h} = \\frac{T-b}{h}$$\nSubstituting these approximations into the eikonal equation yields the scalar algebraic equation for the update at node $(i,j)$:\n$$\\left(\\frac{T-a}{h}\\right)^2 + \\left(\\frac{T-b}{h}\\right)^2 = s^2$$\nThis can be rewritten as:\n$$(T-a)^2 + (T-b)^2 = (sh)^2$$\n\nTo solve for $T$, we expand the equation:\n$$T^2 - 2aT + a^2 + T^2 - 2bT + b^2 = (sh)^2$$\n$$2T^2 - 2(a+b)T + (a^2+b^2 - (sh)^2) = 0$$\nThis is a quadratic equation for $T$ of the form $CT^2+DT+E=0$ with coefficients $C=2$, $D=-2(a+b)$, and $E=a^2+b^2-(sh)^2$. Applying the quadratic formula $T = \\frac{-D \\pm \\sqrt{D^2-4CE}}{2C}$:\n$$T = \\frac{2(a+b) \\pm \\sqrt{4(a+b)^2 - 8(a^2+b^2 - (sh)^2)}}{4}$$\n$$T = \\frac{a+b}{2} \\pm \\frac{\\sqrt{(a+b)^2 - 2(a^2+b^2 - (sh)^2)}}{2}$$\n$$T = \\frac{a+b}{2} \\pm \\frac{\\sqrt{a^2+2ab+b^2 - 2a^2-2b^2 + 2(sh)^2}}{2}$$\n$$T = \\frac{a+b}{2} \\pm \\frac{\\sqrt{2(sh)^2 - (a^2-2ab+b^2)}}{2}$$\n$$T = \\frac{a+b}{2} \\pm \\frac{\\sqrt{2(sh)^2 - (b-a)^2}}{2}$$\nSince the updated time $T$ must be greater than the neighbor times $a$ and $b$, we choose the positive root:\n$$T = \\frac{a+b + \\sqrt{2(sh)^2 - (b-a)^2}}{2}$$\nThis formula is valid only if the discriminant is non-negative, i.e., $2(sh)^2 \\ge (b-a)^2$, or $|b-a| \\le \\sqrt{2} sh$.\n\nMore rigorously, a first-order Godunov-type scheme is based on a choice between potential updates. The general discretized equation is:\n$$(\\max(0, \\frac{T-a}{h}))^2 + (\\max(0, \\frac{T-b}{h}))^2 = s^2$$\nWe assume $a \\le b$. An update requires $T > a$. Two cases arise:\n1.  The update is two-sided ($T>b$): This leads to the quadratic equation and solution derived above. This case is self-consistent if the resulting $T$ is indeed greater than $b$. This leads to the condition:\n    $$\\frac{a+b + \\sqrt{2(sh)^2 - (b-a)^2}}{2} > b$$\n    $$\\sqrt{2(sh)^2 - (b-a)^2} > b-a$$\n    Squaring both sides (which is valid if $b-a \\ge 0$ and the term in the square root is non-negative) gives:\n    $$2(sh)^2 - (b-a)^2 > (b-a)^2 \\implies 2(sh)^2 > 2(b-a)^2 \\implies sh > b-a$$\n2.  The update is one-sided ($a < T \\le b$): In this case, $\\max(0, \\frac{T-b}{h})=0$. The stencil effectively reduces to one dimension along the axis of the neighbor with time $a$. The discrete equation becomes:\n    $$\\left(\\frac{T-a}{h}\\right)^2 = s^2 \\implies T-a = sh \\implies T = a+sh$$\n    This case is self-consistent if the resulting $T$ is indeed less than or equal to $b$:\n    $$a+sh \\le b \\implies sh \\le b-a$$\n\nTherefore, the condition under which the update reduces to a one-sided expression depending only on the smallest neighbor ($a$) is $b-a \\ge sh$.\n\nNow, we evaluate the updated $T$ for the given parameters:\n-   Neighbor travel times: $a = 0.100 \\ \\mathrm{s}$, $b = 0.120 \\ \\mathrm{s}$.\n-   Grid spacing: $h = 10 \\ \\mathrm{m}$.\n-   Velocity: $v = 2000 \\ \\mathrm{m \\ s^{-1}}$.\n\nFirst, we calculate the required quantities:\n-   Slowness: $s = \\frac{1}{v} = \\frac{1}{2000} \\ \\mathrm{s \\ m^{-1}} = 0.0005 \\ \\mathrm{s \\ m^{-1}}$.\n-   Time to cross one grid cell: $sh = (0.0005 \\ \\mathrm{s \\ m^{-1}}) \\times (10 \\ \\mathrm{m}) = 0.005 \\ \\mathrm{s}$.\n-   Difference in neighbor travel times: $b-a = 0.120 \\ \\mathrm{s} - 0.100 \\ \\mathrm{s} = 0.020 \\ \\mathrm{s}$.\n\nNext, we check the condition to determine which update formula to use:\nIs $b-a \\ge sh$?\n$$0.020 \\ \\mathrm{s} \\ge 0.005 \\ \\mathrm{s}$$\nThe condition is satisfied. This means the update is one-sided, and the wavefront effectively arrives from the direction of the closest neighbor only.\n\nWe use the one-sided update formula:\n$$T = a + sh$$\n$$T = 0.100 \\ \\mathrm{s} + 0.005 \\ \\mathrm{s} = 0.105 \\ \\mathrm{s}$$\n\nThe problem requires the answer to be rounded to four significant figures.\n$$T = 0.1050 \\ \\mathrm{s}$$\nThis is the final updated travel time.", "answer": "$$\\boxed{0.1050}$$", "id": "3588080"}, {"introduction": "With the local update rule established, we can now construct a complete solver capable of computing the travel-time field across an entire domain. This practice [@problem_id:3588118] challenges you to implement the Fast Marching Method (FMM), a highly efficient, single-pass algorithm that organizes local updates within a Dijkstra-like priority-queue framework. You will further extend the solver to handle multiple sources, observing how the competition between wavefronts naturally partitions the domain into Voronoi-like cells, a fundamental concept in many geophysical applications.", "problem": "You are asked to design and implement a numerical solver for the isotropic eikonal equation to compute a multi-source travel-time field on a uniform two-dimensional Cartesian grid and to identify the Voronoi-like partition of the domain into regions of dependence of each point source. The foundational base for this task is geometric optics in the high-frequency limit, where travel time along a curve is additive and rays extremize travel time. This leads to the Hamilton–Jacobi form of the isotropic eikonal equation. The problem must be solved in purely mathematical terms on a rectangular grid, with clear physical units specified for all quantities.\n\nStarting point and definitions. Consider a bounded rectangular domain discretized on a uniform grid with spacing $h$ in both directions. Let $v(x,y)$ denote an isotropic speed field that is strictly positive and bounded on the domain, with units meters per second. For a finite set of point sources $\\{x_s^{(i)}\\}_{i=1}^M$, the multi-source travel time $T(x,y)$ satisfies the eikonal equation\n$$\n\\lvert \\nabla T(x,y) \\rvert \\;=\\; \\frac{1}{v(x,y)} \\quad \\text{in the domain,}\n$$\nwith Dirichlet boundary conditions $T(x_s^{(i)}) = 0$ for all sources $i \\in \\{1,\\dots,M\\}$. The domain of dependence (Voronoi-like cell) for a source $i$ is the set of points where $i$ realizes the minimum arrival time among all sources.\n\nAlgorithmic requirements. You must derive from first principles an upwind, monotone discretization for the eikonal equation suitable for a Dijkstra-like acceptance ordering (that is, a single-pass method based on increasing travel times). Your solver must:\n- Use only local upwind information to update a grid node’s travel time from already accepted neighbors.\n- Guarantee causality by always accepting the currently smallest tentative travel time from a min-priority queue.\n- Correctly handle multiple sources by initializing all source nodes with zero travel time and propagating a label field that identifies which source each accepted node depends on. In case two or more sources produce exactly equal travel times at a node to within a small tolerance, break ties deterministically by selecting the smallest source index.\n- Use four-neighbor connectivity on the grid.\n- Produce travel times $T$ in seconds, when $v$ is in meters per second and the grid coordinates are in meters.\n\nYour program must implement the solver and produce answers for the following test suite. In all cases, the domain is $[0,1]\\times[0,1]$ meters, discretized by $N \\times N$ grid points with $N=101$, so that the grid spacing is $h = 1/(N-1)$ meters. Grid point coordinates are located at $(x_i,y_j) = (i h, j h)$ for integers $i,j \\in \\{0,\\dots,N-1\\}$. All angles, if any, must be in radians, but angles do not explicitly appear in this problem.\n\nTest suite:\n1. Constant-speed, single source accuracy. Let $v(x,y) \\equiv 2.0$ meters per second. Place a single source at $(x_s,y_s) = (0.25,0.5)$ meters, located on the nearest grid point. Compute the numerical travel-time field $T_{\\text{num}}$. For this constant-speed case, the analytic solution is $T_{\\text{ana}}(x,y) = \\sqrt{(x-x_s)^2 + (y-y_s)^2} / 2.0$ seconds. Compute the maximum absolute error $E_{\\infty} = \\max_{i,j} \\lvert T_{\\text{num}}(x_i,y_j) - T_{\\text{ana}}(x_i,y_j) \\rvert$ in seconds.\n2. Constant-speed, two sources partition balance. Let $v(x,y) \\equiv 2.0$ meters per second. Place two sources at $(x_s^{(1)},y_s^{(1)}) = (0.10,0.50)$ meters and $(x_s^{(2)},y_s^{(2)}) = (0.90,0.50)$ meters, each on the nearest grid point. Compute the label field $\\ell(x_i,y_j) \\in \\{0,1\\}$ that identifies which source yields the minimum arrival time at each grid point, with ties broken toward the smallest index. Compute the fraction $f_0$ of grid points labeled $\\ell=0$. Report the absolute deviation $\\lvert f_0 - 0.5 \\rvert$ as a dimensionless decimal.\n3. Heterogeneous-speed scaling invariance of partition. Let the baseline speed field be $v(x,y) = 2.0$ meters per second everywhere except inside the disk of radius $0.15$ meters centered at $(0.35,0.50)$ meters where $v(x,y) = 0.5$ meters per second. Place two sources at $(x_s^{(1)},y_s^{(1)}) = (0.10,0.50)$ meters and $(x_s^{(2)},y_s^{(2)}) = (0.90,0.50)$ meters, each on the nearest grid point. Compute the label field $\\ell_{\\text{base}}$ for the baseline $v$. Then define a scaled speed field $v'(x,y) = \\alpha v(x,y)$ with $\\alpha = 3.7$ (dimensionless), and compute the label field $\\ell_{\\text{scaled}}$ under $v'$. Report a boolean indicating whether $\\ell_{\\text{base}}$ and $\\ell_{\\text{scaled}}$ are exactly identical on all grid points.\n\nFinal output format. Your program must produce a single line of output containing the results for the three test cases as a comma-separated list enclosed in square brackets and in the following order: $[E_{\\infty}, \\lvert f_0 - 0.5 \\rvert, \\text{label\\_invariance}]$. The first number $E_{\\infty}$ must be expressed in seconds and rounded to six decimal places, the second number $\\lvert f_0 - 0.5 \\rvert$ must be rounded to six decimal places, and the third value must be the literal boolean token True or False. For example, the output format must look like $[0.003127,0.000000,True]$.", "solution": "The problem of computing a multi-source travel-time field on a Cartesian grid is a classic application of solving the eikonal equation, a cornerstone of geometric optics and computational geophysics. The solution requires deriving a numerical scheme and implementing an efficient solver that respects causality.\n\nThe governing equation is the isotropic eikonal equation:\n$$\n|\\nabla T(x,y)| = \\frac{1}{v(x,y)} = s(x,y)\n$$\nHere, $T(x,y)$ is the travel-time field in seconds, $v(x,y)$ is the wave propagation speed in meters per second, and $s(x,y)$ is the slowness in seconds per meter. The equation is a non-linear partial differential equation of the Hamilton-Jacobi type. The boundary conditions are given by $T(x_s^{(i)}) = 0$ for a set of sources $\\{x_s^{(i)}\\}$. The multi-source travel-time field is the minimum arrival time from any source, $T(x,y) = \\min_i T_i(x,y)$, where $T_i$ is the travel time from source $i$.\n\nThe core physical principle is causality: the travel time at a point can only be determined by points with smaller travel times. This suggests an ordering in the computation, propagating information outward from the sources, much like Huygens' principle. The Fast Marching Method (FMM) is designed for this. It is a grid-based algorithm that uses a Dijkstra-like approach to solve the eikonal equation in a single pass. Grid points are categorized into three sets:\n1.  **Accepted (or Frozen)**: Points for which the final travel time has been computed.\n2.  **Trial (or Narrow Band)**: Points adjacent to the Accepted set, for which a tentative travel time has been computed. These are candidates for acceptance.\n3.  **Unseen (or Far Away)**: All other points, with travel times initialized to infinity.\n\nThe FMM algorithm maintains a min-priority queue of the Trial points, ordered by their tentative travel times. The algorithm proceeds by repeatedly accepting the Trial point with the minimum travel time, moving it to the Accepted set, and then updating the travel times of its Unseen or Trial neighbors.\n\nTo derive the update rule, we discretize the eikonal equation on a uniform grid with spacing $h$. An upwind, first-order finite difference scheme is necessary to ensure stability and respect for causality. At a grid point $(i,j)$, the squared gradient $|\\nabla T|^2 = (\\partial T/\\partial x)^2 + (\\partial T/\\partial y)^2$ is approximated as:\n$$\n\\left(\\max\\left( \\frac{T_{i,j}-T_{i-1,j}}{h}, \\frac{T_{i,j}-T_{i+1,j}}{-h}, 0 \\right)\\right)^2 + \\left(\\max\\left( \\frac{T_{i,j}-T_{i,j-1}}{h}, \\frac{T_{i,j}-T_{i,j+1}}{-h}, 0 \\right)\\right)^2 = s_{i,j}^2\n$$\nIn the FMM, when we update $T_{i,j}$, we only use information from already Accepted neighbors, which have smaller travel times. Let $T_x = \\min(T_{i-1,j}, T_{i+1,j})$ and $T_y = \\min(T_{i,j-1}, T_{i,j+1})$ be the minimum travel times among the Accepted neighbors in the $x$ and $y$ directions, respectively. Since we expect $T_{i,j}$ to be larger than its accepted neighbors, the equation simplifies to:\n$$\n\\left(\\frac{T_{i,j}-T_x}{h}\\right)^2 + \\left(\\frac{T_{i,j}-T_y}{h}\\right)^2 = s_{i,j}^2\n$$\nThis is a quadratic equation for the new time $T = T_{i,j}$: $aT^2 + bT + c = 0$, with $a=2$, $b=-2(T_x+T_y)$, and $c=T_x^2+T_y^2-(hs_{i,j})^2$. Taking the larger root (which corresponds to outward propagation) gives:\n$$\nT = \\frac{T_x+T_y+\\sqrt{2(hs_{i,j})^2 - (T_x-T_y)^2}}{2}\n$$\nThis two-dimensional update is only physically meaningful if the wavefront arrives from a direction that involves both axes. A simple and robust condition is to compare the one-dimensional update time with the travel time of the farther neighbor. Let $T_1 = \\min(T_x, T_y)$ and $T_2 = \\max(T_x, T_y)$. If the wavefront propagates purely from the direction of $T_1$, the update would be $T = T_1 + hs_{i,j}$. If this 1D-updated time is less than or equal to $T_2$, it implies the characteristic from the $T_2$ neighbor does not reach the point $(i,j)$, so the 1D update is appropriate. Thus, the update rule is:\n1.  If only one neighbor (e.g., in $x$) is accepted, use the 1D update: $T = T_x + hs_{i,j}$.\n2.  If neighbors in both directions are accepted, let $T_1=\\min(T_x, T_y)$ and $T_2=\\max(T_x, T_y)$.\n    - If $T_2 - T_1 \\ge hs_{i,j}$, use the 1D update: $T = T_1 + hs_{i,j}$.\n    - Otherwise, use the 2D quadratic solution above.\n\nTo handle multiple sources and determine the Voronoi-like partition, we modify the FMM to track the source of each propagating wavefront. We initialize the priority queue with all source locations, each with zero travel time. The items in the priority queue become tuples of the form `(time, source_index, i, j)`. Python's `heapq` library, when used on such tuples, will sort by time first, and then by `source_index` as a tie-breaker. This elegantly and correctly implements the specified tie-breaking rule. When a node is accepted, its travel time and its dependency on a specific source (its label) are finalized simultaneously. The label of the accepted node is then propagated to its neighbors during their update step. This integrated approach computes the minimum travel-time field and the source-dependency partition in a single, efficient pass.\n\nThe test cases verify three key aspects:\n1.  **Accuracy**: Comparison against an analytical solution in a constant-velocity medium checks the correctness and convergence order of the numerical scheme.\n2.  **Partitioning**: A symmetric two-source problem in a constant-velocity medium tests the multi-source logic and the tie-breaking rule. Due to symmetry, the domain should be split nearly in half, with any deviation arising from the discrete grid and the deterministic tie-breaking rule.\n3.  **Invariance**: The eikonal equation possesses a scaling symmetry. If the slowness field is scaled by a constant, $s'(x,y) = s(x,y)/\\alpha$, the travel times are also scaled, $T'(x,y) = T(x,y)/\\alpha$. However, the ray paths, which are paths of minimum travel time, remain invariant. Consequently, the Voronoi-like partition of the domain based on first-arrival times should be identical for $v(x,y)$ and $v'(x,y) = \\alpha v(x,y)$. This test validates a fundamental physical property of the solution.", "answer": "```python\nimport numpy as np\nimport heapq\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the eikonal solver.\n    \"\"\"\n\n    def run_fmm_solver(N, h, speed_field, sources_coords):\n        \"\"\"\n        Solves the isotropic eikonal equation for multiple sources on a 2D grid\n        using the Fast Marching Method (FMM).\n\n        Args:\n            N (int): Grid dimension (N x N).\n            h (float): Grid spacing in meters.\n            speed_field (np.ndarray): N x N array of wave speeds (m/s).\n            sources_coords (list): A list of (x, y) tuples for source locations in meters.\n\n        Returns:\n            tuple: A tuple containing:\n                - times (np.ndarray): N x N array of first-arrival travel times (s).\n                - labels (np.ndarray): N x N array of source indices for the first arrival.\n        \"\"\"\n        # State constants for grid points\n        ACCEPTED = 0\n        TRIAL = 1\n        UNSEEN = 2\n\n        # Initialize data structures\n        times = np.full((N, N), np.inf, dtype=np.float64)\n        labels = np.full((N, N), -1, dtype=np.int32)\n        states = np.full((N, N), UNSEEN, dtype=np.int8)\n        pq = []  # Min-priority queue\n\n        slowness_field = 1.0 / speed_field\n\n        # Initialize sources in the priority queue\n        for label_idx, (sx, sy) in enumerate(sources_coords):\n            i_s = int(round(sx / h))\n            j_s = int(round(sy / h))\n            \n            i_s = np.clip(i_s, 0, N - 1)\n            j_s = np.clip(j_s, 0, N - 1)\n\n            # In case multiple sources map to the same grid point, the one with the\n            # smaller index will be processed first due to tie-breaking in the heap.\n            if times[i_s, j_s] > 0.0:\n                times[i_s, j_s] = 0.0\n                states[i_s, j_s] = TRIAL\n                heapq.heappush(pq, (0.0, label_idx, i_s, j_s))\n\n        # Main FMM loop\n        while pq:\n            time, label, i, j = heapq.heappop(pq)\n\n            if states[i, j] == ACCEPTED:\n                continue\n            \n            states[i, j] = ACCEPTED\n            labels[i, j] = label\n\n            # Propagate information to neighbors\n            for ni, nj in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                # Check boundary conditions and if neighbor is already accepted\n                if not (0 = ni  N and 0 = nj  N) or states[ni, nj] == ACCEPTED:\n                    continue\n\n                # Find minimum times of accepted neighbors in x and y directions\n                t_x_min = np.inf\n                if ni > 0 and states[ni - 1, nj] == ACCEPTED:\n                    t_x_min = min(t_x_min, times[ni - 1, nj])\n                if ni  N - 1 and states[ni + 1, nj] == ACCEPTED:\n                    t_x_min = min(t_x_min, times[ni + 1, nj])\n                \n                t_y_min = np.inf\n                if nj > 0 and states[ni, nj - 1] == ACCEPTED:\n                    t_y_min = min(t_y_min, times[ni, nj - 1])\n                if nj  N - 1 and states[ni, nj + 1] == ACCEPTED:\n                    t_y_min = min(t_y_min, times[ni, nj + 1])\n                \n                # Calculate time update based on available neighbors\n                hs = h * slowness_field[ni, nj]\n                t_new = np.inf\n\n                if t_x_min != np.inf and t_y_min != np.inf:\n                    t1, t2 = (t_x_min, t_y_min) if t_x_min  t_y_min else (t_y_min, t_x_min)\n                    if (t2 - t1)  hs:\n                        radicand = 2.0 * hs**2 - (t1 - t2)**2\n                        t_new = (t1 + t2 + math.sqrt(radicand)) / 2.0\n                    else:\n                        t_new = t1 + hs\n                elif t_x_min != np.inf:\n                    t_new = t_x_min + hs\n                elif t_y_min != np.inf:\n                    t_new = t_y_min + hs\n                \n                # If a shorter path to the neighbor is found, update it and push to queue\n                if t_new  times[ni, nj]:\n                    times[ni, nj] = t_new\n                    states[ni, nj] = TRIAL\n                    heapq.heappush(pq, (t_new, label, ni, nj))\n\n        return times, labels\n\n    N = 101\n    h = 1.0 / (N - 1)\n    results = []\n\n    # --- Test Case 1: Constant-speed, single source accuracy ---\n    v1 = 2.0\n    speed_field_1 = np.full((N, N), v1)\n    source_1_coord = (0.25, 0.5)\n    sources_1 = [source_1_coord]\n    \n    t_num_1, _ = run_fmm_solver(N, h, speed_field_1, sources_1)\n    \n    x_coords = np.linspace(0, 1, N)\n    y_coords = np.linspace(0, 1, N)\n    xx, yy = np.meshgrid(x_coords, y_coords, indexing='ij')\n    \n    t_ana_1 = np.sqrt((xx - source_1_coord[0])**2 + (yy - source_1_coord[1])**2) / v1\n    \n    e_inf = np.max(np.abs(t_num_1 - t_ana_1))\n    results.append(round(e_inf, 6))\n\n    # --- Test Case 2: Constant-speed, two sources partition balance ---\n    v2 = 2.0\n    speed_field_2 = np.full((N, N), v2)\n    sources_2 = [(0.10, 0.50), (0.90, 0.50)]\n    \n    _, labels_2 = run_fmm_solver(N, h, speed_field_2, sources_2)\n    \n    f0 = np.sum(labels_2 == 0) / (N * N)\n    dev_f0 = abs(f0 - 0.5)\n    results.append(round(dev_f0, 6))\n\n    # --- Test Case 3: Heterogeneous-speed scaling invariance of partition ---\n    v_bg = 2.0\n    v_slow = 0.5\n    disk_center = (0.35, 0.50)\n    disk_radius = 0.15\n    \n    speed_field_3_base = np.full((N, N), v_bg)\n    is_in_disk = (xx - disk_center[0])**2 + (yy - disk_center[1])**2 = disk_radius**2\n    speed_field_3_base[is_in_disk] = v_slow\n    \n    sources_3 = [(0.10, 0.50), (0.90, 0.50)]\n    \n    _, labels_base = run_fmm_solver(N, h, speed_field_3_base, sources_3)\n    \n    alpha = 3.7\n    speed_field_3_scaled = alpha * speed_field_3_base\n    _, labels_scaled = run_fmm_solver(N, h, speed_field_3_scaled, sources_3)\n    \n    label_invariance = np.array_equal(labels_base, labels_scaled)\n    results.append(label_invariance)\n\n    # Format and print final output\n    print(f\"[{results[0]},{results[1]},{results[2]}]\")\n\nsolve()\n```", "id": "3588118"}, {"introduction": "Real-world geophysical media are rarely simple; they often contain complex structures like impermeable salt bodies or voids that obstruct and diffract wave propagation. This advanced practice [@problem_id:3588086] applies the FMM solver to the practical problem of modeling wave propagation around obstacles, which create so-called \"shadow zones.\" By completing this exercise, you will gain experience in adapting numerical solvers to handle complex domain topologies and in quantifying the travel-time delays caused by such detours, a key skill for seismic imaging and hazard assessment.", "problem": "Consider isotropic first-arrival travel time in two spatial dimensions governed by the eikonal equation, which for a scalar travel time field $T(\\mathbf{x})$ and speed field $v(\\mathbf{x})$ on a domain $\\Omega \\subset \\mathbb{R}^2$ reads\n$$\n\\lvert \\nabla T(\\mathbf{x}) \\rvert = \\frac{1}{v(\\mathbf{x})} \\quad \\text{for } \\mathbf{x} \\in \\Omega,\n$$\nwith the Dirichlet boundary condition $T(\\mathbf{x}_s)=0$ at a point source $\\mathbf{x}_s \\in \\Omega$. Let a subset $\\mathcal{H} \\subset \\Omega$ represent impermeable voids (holes), and define the computational domain $D = \\Omega \\setminus \\mathcal{H}$. The travel time $T(\\mathbf{x})$ is defined only on $D$ and characteristics cannot cross $\\partial \\mathcal{H}$. You will study how the topology of $\\mathcal{H}$ creates shadow regions, quantified as additional travel time relative to the homogeneous unobstructed case.\n\nYou must implement a solver based on upwind causal propagation consistent with the Fast Marching Method (FMM), using a uniform Cartesian grid with grid spacing $\\Delta x = \\Delta y = h$ and four-point stencil, to compute an approximation of $T(\\mathbf{x})$ on $D$. Start from the fundamental variational principle that physical travel time follows paths that minimize the path integral of slowness, and from the definition of the eikonal equation. Derive a strictly upwind local update at a grid point that is consistent with monotone discretization of the norm of the gradient and respects causality. Do not permit updates inside holes; these locations are excluded from $D$.\n\nDefine a homogeneous speed $v(\\mathbf{x}) \\equiv v_0$ in meters per second and a square domain $\\Omega = [0,L]\\times[0,L]$ in meters. Use a point source at $\\mathbf{x}_s=(x_s,y_s)$ with $T(\\mathbf{x}_s)=0$. Let a probe point $\\mathbf{x}_p=(x_p,y_p)$ be used to quantify travel-time delay.\n\nTo quantify shadow effects due to holes, define for any grid point $\\mathbf{x}$ the unobstructed homogeneous baseline\n$$\nT_{\\mathrm{free}}(\\mathbf{x}) = \\frac{\\|\\mathbf{x}-\\mathbf{x}_s\\|_2}{v_0},\n$$\nand say that a grid point is line-of-sight blocked if the line segment joining $\\mathbf{x}_s$ and $\\mathbf{x}$ intersects the interior of any hole in $\\mathcal{H}$. For a given threshold $\\delta$ in seconds, define the shadow set\n$$\nS_{\\mathrm{shadow}} = \\left\\{ \\mathbf{x} \\in D \\,:\\, \\text{line-of-sight blocked and } T(\\mathbf{x}) - T_{\\mathrm{free}}(\\mathbf{x}) \\ge \\delta \\text{ and } T(\\mathbf{x}) \\text{ is finite} \\right\\}.\n$$\nLet the shadow area fraction be the ratio of the number of grid points in $S_{\\mathrm{shadow}}$ to the number of grid points in $D$.\n\nImplement the following test suite, with all distances in meters and times in seconds:\n\n- Grid and source parameters common to all tests:\n  - $L = 1000$, $h=10$, so $N_x=N_y=101$ grid points with coordinates $x_i=i\\,h$, $y_j=j\\,h$ for integers $i,j \\in \\{0,1,\\ldots,100\\}$.\n  - $v_0 = 2000\\,\\mathrm{m/s}$, so slowness is $1/v_0$ in $\\mathrm{s/m}$.\n  - Source at $\\mathbf{x}_s=(100,500)$, i.e., grid indices $(i_s,j_s)=(10,50)$.\n  - Probe at $\\mathbf{x}_p=(800,500)$, i.e., grid indices $(i_p,j_p)=(80,50)$.\n  - Threshold $\\delta=0.01$ (seconds).\n\n- Test case $1$ (single finite obstacle causing detour but reachability): One rectangular hole $\\mathcal{H}_1 = [450,550]\\times[400,600]$.\n\n- Test case $2$ (no obstacle baseline): $\\mathcal{H}_2 = \\varnothing$.\n\n- Test case $3$ (disconnecting wall creating unreachable region): One vertical rectangular hole spanning the domain height, $\\mathcal{H}_3 = [450,550]\\times[0,1000]$.\n\nFor each test case $k \\in \\{1,2,3\\}$, compute:\n- The delay at the probe in seconds, defined as $D_k = T_k(\\mathbf{x}_p) - T_{\\mathrm{free}}(\\mathbf{x}_p)$, where $T_k$ is the computed field for test $k$. If $\\mathbf{x}_p$ is unreachable in test $k$, use $+\\infty$ for $T_k(\\mathbf{x}_p)$ so that $D_k=+\\infty$.\n- The shadow area fraction $F^{\\mathrm{shadow}}_k$ as defined above (unitless decimal).\n- The unreachable fraction $F^{\\mathrm{unreach}}_k$, defined as the ratio of the number of grid points in $D$ where $T_k$ is not finite to the total number of grid points in $D$ (unitless decimal).\n\nAll times must be expressed in seconds, and all fractions must be expressed as decimals in $[0,1]$. Angle units are not used in this problem.\n\nYour program must produce a single line of output containing the results aggregated as a list of lists in the following exact format (no spaces): \n- The output must be\n$$\n\\big[ [D_1, F^{\\mathrm{shadow}}_1, F^{\\mathrm{unreach}}_1], [D_2, F^{\\mathrm{shadow}}_2, F^{\\mathrm{unreach}}_2], [D_3, F^{\\mathrm{shadow}}_3, F^{\\mathrm{unreach}}_3] \\big],\n$$\nprinted as a single line using standard floating-point string representations, with the brackets and commas exactly as shown and no other text. For example: \n$[[0.0123,0.045,0.0],[0.0,0.0,0.0],[inf,0.12,0.49]]$.\n\nYour implementation must be self-contained and must not read any input. The answer for each test in the suite must be a float triple. The final program must adhere to the specified execution environment.", "solution": "The posed problem is valid as it is scientifically grounded in the principles of wave propagation, mathematically well-posed, and specified with objective, unambiguous parameters. I will now proceed with a complete solution.\n\nThe problem asks for the computation of first-arrival travel times in a two-dimensional medium containing impermeable voids. The physical process is governed by the eikonal equation, a non-linear first-order partial differential equation.\n\nThe eikonal equation is given by\n$$\n\\lvert \\nabla T(\\mathbf{x}) \\rvert = s(\\mathbf{x}),\n$$\nwhere $T(\\mathbf{x})$ is the travel time field and $s(\\mathbf{x}) = 1/v(\\mathbf{x})$ is the slowness (inverse of speed). In this problem, the medium is homogeneous with speed $v_0$, so the slowness $s$ is a constant, $s=1/v_0$. In two Cartesian coordinates, this equation expands to:\n$$\n\\left( \\frac{\\partial T}{\\partial x} \\right)^2 + \\left( \\frac{\\partial T}{\\partial y} \\right)^2 = s^2.\n$$\nThis equation is a static Hamilton-Jacobi equation. It is solved with a boundary condition $T(\\mathbf{x}_s) = 0$ at the source point $\\mathbf{x}_s$. The solution $T(\\mathbf{x})$ represents the shortest time of travel from $\\mathbf{x}_s$ to any point $\\mathbf{x}$ in the domain.\n\nWe are tasked to solve this equation numerically on a uniform Cartesian grid with spacing $h=\\Delta x = \\Delta y$. The solution method must be consistent with the Fast Marching Method (FMM), which respects the causality of wave propagation. FMM solves the equation by systematically constructing the solution outwards from the source. The core of the method is a local update rule for the travel time at a grid point based on the times of its already-computed \"upwind\" neighbors.\n\n**Derivation of the Upwind Finite-Difference Scheme**\n\nThe principle of causality dictates that the travel time $T$ at a grid point $(i,j)$ can only depend on neighbors with smaller travel times. We approximate the partial derivatives using first-order, one-sided upwind differences. An upwind scheme for the squared gradient norm is:\n$$\n\\left( \\max\\left( D^{-x}_{i,j}T, -D^{+x}_{i,j}T, 0 \\right) \\right)^2 + \\left( \\max\\left( D^{-y}_{i,j}T, -D^{+y}_{i,j}T, 0 \\right) \\right)^2 = s^2,\n$$\nwhere $D^{-x}_{i,j}T = (T_{i,j} - T_{i-1,j})/h$, $D^{+x}_{i,j}T = (T_{i+1,j} - T_{i,j})/h$, and so on. In the context of FMM, when we compute the time $T_{i,j}$, we only use neighbor values that have already been finalized (accepted). Let the minimum accepted neighbor times in the $x$ and $y$ directions be $T_x = \\min(T_{i-1,j}, T_{i+1,j})$ and $T_y = \\min(T_{i,j-1}, T_{i,j+1})$, respectively. The discrete eikonal equation for the unknown time $T \\equiv T_{i,j}$ becomes:\n$$\n(\\max(0, T - T_x))^2 + (\\max(0, T - T_y))^2 = (sh)^2.\n$$\nAssuming $T  T_x$ and $T  T_y$, this simplifies to a quadratic equation for $T$:\n$$\n(T - T_x)^2 + (T - T_y)^2 = (sh)^2.\n$$\nExpanding this gives $2T^2 - 2T(T_x + T_y) + (T_x^2 + T_y^2 - (sh)^2) = 0$. Solving for $T$ and taking the physically meaningful larger root yields:\n$$\nT_{quad} = \\frac{T_x + T_y + \\sqrt{2(sh)^2 - (T_x - T_y)^2}}{2}.\n$$\nThis solution is valid only if the discriminant is non-negative, i.e., $2(sh)^2 \\ge (T_x - T_y)^2$, or $|T_x - T_y| \\le \\sqrt{2}sh$. In many implementations, a simpler criterion $|T_x - T_y| \\le sh$ is used, which corresponds to checking if $T_{quad}$ is greater than both $T_x$ and $T_y$. If this condition is not met, it implies the wave arrives primarily from one direction. The update should then be based only on the neighbor with the minimum time, say $T_{min} = \\min(T_x, T_y)$. The update rule degenerates to the one-dimensional eikonal equation $(T - T_{min})^2 = (sh)^2$, which gives $T = T_{min} + sh$.\n\nThe complete local solver is thus:\n1. Identify the minimum accepted neighbor times $T_x$ and $T_y$.\n2. If only one is finite (e.g., $T_x$), the update is $T = T_x + sh$.\n3. If both are finite, check if the discriminant $2(sh)^2 - (T_x - T_y)^2$ is non-negative.\n   a. If yes, the update is $T = \\frac{1}{2}(T_x + T_y + \\sqrt{2(sh)^2 - (T_x - T_y)^2})$.\n   b. If no, the update is $T = \\min(T_x, T_y) + sh$.\n\n**The Fast Marching Method (FMM) Algorithm**\n\nFMM is a grid-based algorithm analogous to Dijkstra's algorithm for finding the shortest path on a graph. It classifies grid points into three sets:\n- **ALIVE**: Points for which the travel time has been finalized.\n- **TRIAL**: Points that are neighbors of ALIVE points, for which a tentative travel time has been computed. These are candidate points for the next ALIVE point.\n- **FAR**: All other points, with travel time initialized to infinity.\n\nThe algorithm proceeds as follows:\n1.  **Initialization**:\n    - The travel time array $T$ is initialized to $\\infty$, except for the source point $T(\\mathbf{x}_s) = 0$.\n    - The state of all points is `FAR`.\n    - A min-priority queue (min-heap) is created to store `TRIAL` points, ordered by their tentative travel time.\n    - The source point $\\mathbf{x}_s$ is added to the priority queue with time $0$, and its state is set to `TRIAL`.\n\n2.  **Marching Loop**: While the priority queue is not empty:\n    a. Extract the point $\\mathbf{x}_{min}$ with the minimum travel time from the queue.\n    b. If its state is already `ALIVE`, ignore it and continue (this handles cases where multiple, decreasing time estimates for a single point were added to the queue).\n    c. Set the state of $\\mathbf{x}_{min}$ to `ALIVE`. Its time is now final.\n    d. For each neighbor $\\mathbf{x}_n$ of $\\mathbf{x}_{min}$:\n        i.  If $\\mathbf{x}_n$ is inside a hole or is already `ALIVE`, ignore it.\n        ii. Using the local solver described above, calculate a new tentative time for $\\mathbf{x}_n$ based on its `ALIVE` neighbors.\n        iii. If this new time is less than the current time stored for $\\mathbf{x}_n$, update $T(\\mathbf{x}_n)$ to the new time, set the state of $\\mathbf{x}_n$ to `TRIAL`, and add $(\\text{new time}, \\mathbf{x}_n)$ to the priority queue.\n\nThe loop terminates when the queue is empty. At this point, all reachable points in the domain $D = \\Omega \\setminus \\mathcal{H}$ will have their correct first-arrival travel time. Points in regions disconnected from the source will retain their initial travel time of $\\infty$.\n\n**Calculation of Metrics**\n\nFor each test case, after computing the travel time field $T_k$, we calculate the required metrics:\n- **Delay $D_k$**: The difference between the computed time at the probe, $T_k(\\mathbf{x}_p)$, and the straight-ray time, $T_{\\mathrm{free}}(\\mathbf{x}_p) = \\|\\mathbf{x}_p - \\mathbf{x}_s\\|_2/v_0$. If $T_k(\\mathbf{x}_p)$ is $\\infty$, $D_k$ is $\\infty$.\n- **Unreachable Fraction $F^{\\mathrm{unreach}}_k$**: The number of points in the computational domain $D$ where $T_k = \\infty$, divided by the total number of points in $D$.\n- **Shadow Area Fraction $F^{\\mathrm{shadow}}_k$**: The number of points in the shadow set $S_{\\mathrm{shadow}}$ divided by the total number of points in $D$. A point $\\mathbf{x}$ is in $S_{\\mathrm{shadow}}$ if it satisfies three conditions:\n    1.  Its travel time $T_k(\\mathbf{x})$ is finite.\n    2.  The travel time delay $T_k(\\mathbfx) - T_{\\mathrm{free}}(\\mathbf{x})$ is at least $\\delta$.\n    3.  The straight-line path from $\\mathbf{x}_s$ to $\\mathbf{x}$ is blocked by a hole. This line-of-sight check is performed using a robust segment-rectangle intersection test (e.g., Liang-Barsky algorithm), which determines if the line segment intersects the interior of any hole rectangle.\nThe implementation will follow these principles to solve the three specified test cases.", "answer": "```python\nimport numpy as np\nimport heapq\n\ndef solve():\n    \"\"\"\n    Solves the eikonal equation for three test cases using the Fast Marching Method,\n    and computes travel-time delay, shadow fraction, and unreachable fraction.\n    \"\"\"\n    # Define common parameters\n    L = 1000.0\n    h = 10.0\n    v0 = 2000.0\n    source_pos = (100.0, 500.0)\n    probe_pos = (800.0, 500.0)\n    delta = 0.01\n\n    slowness = 1.0 / v0\n    sh = slowness * h\n    sh_sq = sh**2\n\n    nx = int(L / h) + 1\n    ny = int(L / h) + 1\n    source_idx = (int(source_pos[0] / h), int(source_pos[1] / h))\n    probe_idx = (int(probe_pos[0] / h), int(probe_pos[1] / h))\n\n    # Pre-calculate coordinate and free-space travel time grids\n    x_coords = np.arange(nx) * h\n    y_coords = np.arange(ny) * h\n    grid_x, grid_y = np.meshgrid(x_coords, y_coords, indexing='ij')\n    \n    dist_from_source = np.sqrt((grid_x - source_pos[0])**2 + (grid_y - source_pos[1])**2)\n    T_free_grid = dist_from_source / v0\n\n    # Define test cases with hole geometries\n    test_cases = [\n        {'rects': [[450.0, 550.0, 400.0, 600.0]]}, # Case 1\n        {'rects': []},                            # Case 2\n        {'rects': [[450.0, 550.0, 0.0, 1000.0]]}   # Case 3\n    ]\n\n    # FMM states\n    FAR, TRIAL, ALIVE = 0, 1, 2\n\n    def get_hole_mask(rects):\n        mask = np.zeros((nx, ny), dtype=bool)\n        if not rects:\n            return mask\n        for rect in rects:\n            x_min, x_max, y_min, y_max = rect\n            mask |= (grid_x >= x_min)  (grid_x = x_max)  (grid_y >= y_min)  (grid_y = y_max)\n        return mask\n\n    def solve_eikonal_fmm(hole_mask):\n        times = np.full((nx, ny), np.inf, dtype=np.float64)\n        states = np.full((nx, ny), FAR, dtype=np.uint8)\n        \n        times[source_idx] = 0.0\n        pq = [(0.0, source_idx[0], source_idx[1])]\n        states[source_idx] = TRIAL\n\n        while pq:\n            time, ix, iy = heapq.heappop(pq)\n            \n            if states[ix, iy] == ALIVE:\n                continue\n            \n            states[ix, iy] = ALIVE\n            \n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx_ix, nx_iy = ix + dx, iy + dy\n                \n                if not (0 = nx_ix  nx and 0 = nx_iy  ny and not hole_mask[nx_ix, nx_iy]):\n                    continue\n                \n                if states[nx_ix, nx_iy] == ALIVE:\n                    continue\n\n                t_x_neighbors = []\n                if nx_ix > 0 and states[nx_ix - 1, nx_iy] == ALIVE: t_x_neighbors.append(times[nx_ix - 1, nx_iy])\n                if nx_ix  nx - 1 and states[nx_ix + 1, nx_iy] == ALIVE: t_x_neighbors.append(times[nx_ix + 1, nx_iy])\n\n                t_y_neighbors = []\n                if nx_iy > 0 and states[nx_ix, nx_iy - 1] == ALIVE: t_y_neighbors.append(times[nx_ix, nx_iy - 1])\n                if nx_iy  ny - 1 and states[nx_ix, nx_iy + 1] == ALIVE: t_y_neighbors.append(times[nx_ix, nx_iy + 1])\n                \n                t_x = min(t_x_neighbors) if t_x_neighbors else np.inf\n                t_y = min(t_y_neighbors) if t_y_neighbors else np.inf\n                \n                new_time = np.inf\n                if t_x != np.inf and t_y != np.inf:\n                    discriminant = 2 * sh_sq - (t_x - t_y)**2\n                    if discriminant >= 0:\n                        new_time = (t_x + t_y + np.sqrt(discriminant)) / 2.0\n                    else:\n                        new_time = min(t_x, t_y) + sh\n                elif t_x != np.inf:\n                    new_time = t_x + sh\n                elif t_y != np.inf:\n                    new_time = t_y + sh\n                \n                if new_time  times[nx_ix, nx_iy]:\n                    times[nx_ix, nx_iy] = new_time\n                    states[nx_ix, nx_iy] = TRIAL\n                    heapq.heappush(pq, (new_time, nx_ix, nx_iy))\n                    \n        return times\n\n    def is_los_blocked(ix, iy, rects):\n        if not rects:\n            return False\n        x_s, y_s = source_pos\n        x_p, y_p = ix * h, iy * h\n        \n        for rect in rects:\n            x_min, x_max, y_min, y_max = rect\n            dx, dy = x_p - x_s, y_p - y_s\n            \n            t_near, t_far = 0.0, 1.0\n            slabs = [ (x_s, dx, x_min, x_max), (y_s, dy, y_min, y_max) ]\n            \n            intersect = True\n            for p, d, slab_min, slab_max in slabs:\n                if abs(d)  1e-9: # Parallel to slab\n                    if not (slab_min  p  slab_max):\n                        intersect = False\n                        break\n                else:\n                    t1 = (slab_min - p) / d\n                    t2 = (slab_max - p) / d\n                    if t1 > t2: t1, t2 = t2, t1\n                    t_near = max(t_near, t1)\n                    t_far = min(t_far, t2)\n                \n            if intersect and t_near  t_far:\n                return True\n        return False\n\n    final_results = []\n    for case in test_cases:\n        rects = case['rects']\n        hole_mask = get_hole_mask(rects)\n        \n        computed_times = solve_eikonal_fmm(hole_mask)\n        \n        # 1. Delay at probe\n        T_probe = computed_times[probe_idx]\n        T_free_probe = T_free_grid[probe_idx]\n        delay = T_probe - T_free_probe\n\n        # 2. Fractions\n        domain_mask = ~hole_mask\n        num_domain_points = np.sum(domain_mask)\n\n        unreachable_mask = domain_mask  (computed_times == np.inf)\n        num_unreachable = np.sum(unreachable_mask)\n        frac_unreachable = num_unreachable / num_domain_points if num_domain_points > 0 else 0.0\n\n        delay_grid = computed_times - T_free_grid\n        \n        shadow_count = 0\n        domain_indices = np.argwhere(domain_mask)\n        for ix, iy in domain_indices:\n            if np.isfinite(computed_times[ix, iy]) and delay_grid[ix, iy] >= delta:\n                if is_los_blocked(ix, iy, rects):\n                    shadow_count += 1\n        \n        frac_shadow = shadow_count / num_domain_points if num_domain_points > 0 else 0.0\n        \n        final_results.append([delay, frac_shadow, frac_unreachable])\n        \n    # Format output string\n    result_strings = []\n    for res in final_results:\n        d, fs, fu = res\n        d_str = str(d).lower()\n        result_strings.append(f\"[{d_str},{fs},{fu}]\")\n        \n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "3588086"}]}