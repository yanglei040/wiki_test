{"hands_on_practices": [{"introduction": "The Kirchhoff migration integral theoretically sums recorded data over the entire acquisition surface. In practice, this is computationally prohibitive and can introduce noise. This exercise explores the crucial concept of the migration aperture, a finite integration domain whose size represents a trade-off between imaging accuracy, computational cost, and artifact suppression. By deriving criteria based on the Fresnel zone, geologic dip, and acquisition limits, you will develop a practical understanding of how to define an optimal and efficient migration operator.", "problem": "Design and implement a program that formalizes the selection of the migration aperture radius in Kirchhoff migration from first principles. Your program must operationalize selection of an aperture radius $R(\\mathbf{x})$ that is consistent with local dip constraints and acquisition aperture, and must evaluate imaging artifacts when a user-proposed aperture $R_{\\text{user}}$ is too small or too large relative to the first Fresnel zone.\n\nFundamental base and derivation targets:\n- Start from the scalar wave equation in a homogeneous medium with constant propagation speed $v$ and the Huygensâ€“Fresnel principle (superposition of secondary wavelets) together with the method of stationary phase. Use a small-angle expansion of traveltime about the stationary point to motivate a first Fresnel zone radius at depth $z$, and relate it to the dominant wavelength $\\lambda$.\n- Use basic geometric optics to relate a local maximum allowable dip angle $\\theta_{\\max}$ to the lateral migration aperture via the exploding reflector model, and constrain the aperture further by the acquisition half-aperture $A$ (the maximum usable lateral extent on the acquisition surface).\n- Use the Fresnel zone radius to define quantitative criteria for when a user-specified aperture $R_{\\text{user}}$ is too small or too large. In particular, introduce lower and upper multipliers $c_1$ and $c_2$ on the first Fresnel radius to define a balanced regime.\n\nYou must implement the following definitions and computations:\n1. Dominant wavelength: $\\lambda = v/f_0$, where $f_0$ is the dominant frequency.\n2. First Fresnel radius at depth (one-way, exploding reflector model): $r_F = \\sqrt{\\lambda z}$.\n3. Dip-limited aperture radius: $R_{\\text{dip}} = z \\tan(\\theta_{\\max})$.\n4. Acquisition-limited radius: $R_{\\text{acq}} = A$.\n5. Target Fresnel-guided radius: $R_{\\text{target}} = \\beta \\, r_F$, with $\\beta \\in \\mathbb{R}^+$ chosen a priori to lie strictly between $c_1$ and $c_2$.\n6. Recommended aperture: $R_{\\text{rec}} = \\min\\{R_{\\text{dip}}, R_{\\text{acq}}, R_{\\text{target}}\\}$.\n7. User-proposed aperture: $R_{\\text{user}} = \\gamma \\, r_F$, where $\\gamma \\in \\mathbb{R}^+$ is provided.\n8. Artifact criteria evaluated on $R_{\\text{user}}$:\n   - Too small if $R_{\\text{user}} < c_1 \\, r_F$.\n   - Too large if $R_{\\text{user}} > c_2 \\, r_F$.\n   - Balanced otherwise.\n\nUse the fixed constants $c_1 = 1.0$, $c_2 = 2.0$, and $\\beta = 1.5$. Angles must be provided in degrees and converted to radians in the computation. All distances must be expressed in meters, the wave speed in meters per second, the frequency in hertz, and angles in degrees on input and radians internally.\n\nTest suite:\nProvide the following test cases, each as a tuple $(v, f_0, z, \\theta_{\\max}^{\\circ}, A, \\gamma)$, with the specified units:\n- Case $1$: $(2500, 30, 1500, 35, 5000, 5.657)$.\n- Case $2$: $(2000, 60, 1000, 5, 1000, 0.548)$.\n- Case $3$: $(3000, 20, 3000, 60, 800, 1.044)$.\n- Case $4$: $(1800, 80, 300, 45, 200, 1.819)$.\n- Case $5$: $(2500, 10, 4000, 80, 10000, 5.000)$.\n- Case $6$: $(2200, 55, 1200, 25, 1500, 2.000)$.\n\nFor each test case, your program must compute:\n- The recommended aperture $R_{\\text{rec}}$ in meters.\n- The Fresnel radius $r_F$ in meters.\n- A boolean flag indicating whether $R_{\\text{user}}$ is too small relative to $c_1 r_F$.\n- A boolean flag indicating whether $R_{\\text{user}}$ is too large relative to $c_2 r_F$.\n\nOutput requirements:\n- Express $R_{\\text{rec}}$ and $r_F$ in meters, rounded to $3$ decimals.\n- The boolean flags must be exact Python booleans ($\\text{True}$ or $\\text{False}$).\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, where each element is a list of the form $[R_{\\text{rec}}, r_F, \\text{too\\_small}, \\text{too\\_large}]$, for each case in the same order as above. There must be no spaces anywhere in the output string. For example: $[[r_{11},r_{12},b_{11},b_{12}],[r_{21},r_{22},b_{21},b_{22}],\\dots]$.\n\nScientific realism:\n- Assume a homogeneous isotropic medium.\n- All parameters are realistic for marine or land seismic settings.\n- Angle unit for input is degrees; your program must convert to radians internally for trigonometric functions.\n\nYour implementation must be a complete, runnable program. It must not require any user input or external files and must be deterministic.", "solution": "The problem of selecting an appropriate migration aperture in Kirchhoff migration is a quintessential example of balancing imaging accuracy, computational cost, and artifact suppression in computational geophysics. We shall first formalize the underlying principles and then construct the required computational procedure.\n\nThe theoretical foundation of Kirchhoff migration is the integral solution to the scalar wave equation, which expresses a wavefield at a target point `$\\mathbf{x}$` in the subsurface as a superposition of recorded wavefields on the acquisition surface `$S$`. This solution is a mathematical embodiment of the Huygens-Fresnel principle, stating that every point on a wavefront acts as a source of secondary spherical wavelets. For an imaging point `$\\mathbf{x}$` at depth `$z$`, the migration integral can be written as:\n$$\nI(\\mathbf{x}) = \\int_S w(\\mathbf{x}, \\mathbf{x_s}) U(\\mathbf{x_s}, t = \\tau(\\mathbf{x}, \\mathbf{x_s})) \\, dS\n$$\nwhere `$U(\\mathbf{x_s}, t)$` is the recorded wavefield at surface location `$\\mathbf{x_s}$`, `$\\tau(\\mathbf{x}, \\mathbf{x_s})$` is the traveltime from `$\\mathbf{x}$` to `$\\mathbf{x_s}$`, and `$w(\\mathbf{x}, \\mathbf{x_s})$` is a weighting function that accounts for geometrical spreading and other factors. The integral sums the energy along a diffraction hyperbola defined by the traveltime function `$\\tau$`.\n\nThe method of stationary phase provides a crucial insight: the dominant contribution to this integral arises from the region on the surface `$S$` where the phase of the integrand is stationary. The phase is proportional to the traveltime `$\\tau$`. The stationary point corresponds to the geometric ray path connecting the image point `$\\mathbf{x}$` to the surface. Contributions from points far from this stationary point have rapidly varying phases and tend to cancel each other out through destructive interference. This observation justifies limiting the integration domain `$S$` to a finite region around the stationary point, known as the migration aperture. The size of this aperture is critical.\n\nA standard way to determine the necessary size of this region is by analyzing the first Fresnel zone. Within this zone, the path length difference from the stationary-phase path results in a phase shift of no more than `$\\pi$` radians, corresponding to a traveltime difference of half the dominant period. All contributions from this zone interfere constructively.\n\nTo formalize the Fresnel zone radius, we consider the exploding reflector model in a homogeneous medium with constant velocity `$v$`. The one-way traveltime from an image point at depth `$z$` to a surface point at a lateral distance `$r$` from the point `$(0,0,z)$` is given by:\n$$\n\\tau(r) = \\frac{\\sqrt{z^2 + r^2}}{v}\n$$\nThe traveltime to the stationary point (directly above, at `$r=0$`) is `$\\tau(0) = z/v$`. For small lateral distances relative to the depth (`$r \\ll z$`), we can perform a Taylor expansion of `$\\tau(r)$`:\n$$\n\\tau(r) = \\frac{z}{v} \\sqrt{1 + \\left(\\frac{r}{z}\\right)^2} \\approx \\frac{z}{v} \\left(1 + \\frac{1}{2}\\frac{r^2}{z^2}\\right) = \\tau(0) + \\frac{r^2}{2vz}\n$$\nThe traveltime difference is `$\\Delta\\tau = \\tau(r) - \\tau(0) = r^2 / (2vz)$`. The boundary of the first Fresnel zone is defined by the condition that this traveltime difference equals half the dominant period, `$\\Delta\\tau = T_0/2 = 1/(2f_0)$`, where `$f_0$` is the dominant frequency. Equating the two expressions for `$\\Delta\\tau$`:\n$$\n\\frac{r^2}{2vz} = \\frac{1}{2f_0} \\implies r^2 = \\frac{vz}{f_0}\n$$\nUsing the definition of the dominant wavelength, `$\\lambda = v/f_0$`, we arrive at the expression for the first Fresnel radius, `$r_F$`:\n$$\nr_F = \\sqrt{\\lambda z}\n$$\nThis radius provides a physically motivated scale for the migration aperture. However, other constraints must also be considered.\n\nThe migration aperture must be large enough to image dipping reflectors. From geometric optics, a reflector segment at depth `$z$` with a dip angle `$\\theta$` will have its reflection point on the surface laterally offset by `$x = z \\tan(\\theta)$`. To properly image all structures up to a maximum expected dip `$\\theta_{\\max}$`, the aperture radius must be at least this large. This leads to the dip-limited aperture radius:\n$$\nR_{\\text{dip}} = z \\tan(\\theta_{\\max})\n$$\nwhere `$\\theta_{\\max}$` must be converted to radians for computation.\n\nFurthermore, the aperture is fundamentally limited by the physical extent of the seismic survey. The data are only available up to a certain maximum lateral distance from the center of the survey line or area. This maximum usable half-aperture is denoted by `$A$`, giving the acquisition-limited radius:\n$$\nR_{\\text{acq}} = A\n$$\nFinally, we incorporate the Fresnel zone concept as a practical guideline. While the first Fresnel zone is key, using an aperture slightly larger can improve the summation result. A common heuristic is to use a multiple of the Fresnel radius. However, an excessively large aperture provides diminishing returns in image quality while substantially increasing computational cost and potentially summing incoherent noise. The problem defines a target Fresnel-guided radius using a multiplier `$\\beta = 1.5$`, which lies within a \"balanced\" regime defined by multipliers `$c_1 = 1.0$` and `$c_2 = 2.0$`. This gives:\n$$\nR_{\\text{target}} = \\beta \\, r_F = 1.5 \\, r_F\n$$\nThe recommended aperture, `$R_{\\text{rec}}$`, must satisfy all three constraints simultaneously. It cannot be larger than what the acquisition allows (`$R_{\\text{acq}}$`), it should be large enough to image the desired dips (`$R_{\\text{dip}}$`), and it should be computationally efficient (`$R_{\\text{target}}$`). Therefore, the optimal choice is the most restrictive of these:\n$$\nR_{\\text{rec}} = \\min\\{R_{\\text{dip}}, R_{\\text{acq}}, R_{\\text{target}}\\}\n$$\nThe problem also requires an evaluation of a user-proposed aperture, `$R_{\\text{user}} = \\gamma \\, r_F$`, where `$\\gamma$` is a user-supplied factor. We can assess this aperture based on its relation to the first Fresnel zone.\n- If `$R_{\\text{user}} < c_1 \\, r_F$` (i.e., `$R_{\\text{user}} < r_F$`), the aperture is too small. It fails to capture the full constructive interference of the first Fresnel zone. This leads to a loss of lateral resolution, smearing of the image point, and potential artifacts from the abrupt truncation of the integral.\n- If `$R_{\\text{user}} > c_2 \\, r_F$` (i.e., `$R_{\\text{user}} > 2 r_F$`), the aperture is too large. It integrates far-field data where the phase changes rapidly. This adds significant computational expense for marginal improvement and can increase migration noise by summing weakly coherent or incoherent energy.\n- An aperture is considered \"balanced\" if `$c_1 \\, r_F \\le R_{\\text{user}} \\le c_2 \\, r_F$`.\n\nWe now implement these principles to process the given test cases. For each tuple `$(v, f_0, z, \\theta_{\\max}^{\\circ}, A, \\gamma)$`, we calculate `$r_F$`, `$R_{\\text{rec}}$`, and evaluate the conditions on `$R_{\\text{user}}$`. All angular inputs in degrees must first be converted to radians.\n\nFor example, for Case $1$: `$(v=2500, f_0=30, z=1500, \\theta_{\\max}^{\\circ}=35, A=5000, \\gamma=5.657)$`.\n1.  Wavelength: `$\\lambda = v/f_0 = 2500 / 30 \\approx 83.333$` m.\n2.  Fresnel radius: `$r_F = \\sqrt{\\lambda z} = \\sqrt{(2500/30) \\times 1500} = \\sqrt{125000} \\approx 353.553$` m.\n3.  Dip-limited aperture: `$R_{\\text{dip}} = z \\tan(\\theta_{\\max}) = 1500 \\times \\tan(35^{\\circ}) \\approx 1050.311$` m.\n4.  Acquisition-limited aperture: `$R_{\\text{acq}} = 5000$` m.\n5.  Target aperture: `$R_{\\text{target}} = 1.5 \\times r_F \\approx 1.5 \\times 353.553 = 530.330$` m.\n6.  Recommended aperture: `$R_{\\text{rec}} = \\min\\{1050.311, 5000, 530.330\\} = 530.330$` m.\n7.  User aperture evaluation:\n    - User radius: `$R_{\\text{user}} = \\gamma \\times r_F = 5.657 \\times 353.553 \\approx 2000.009$` m.\n    - Lower bound: `$c_1 r_F = 1.0 \\times 353.553 = 353.553$` m.\n    - Upper bound: `$c_2 r_F = 2.0 \\times 353.553 = 707.107$` m.\n    - Is `$R_{\\text{user}} < c_1 r_F$`? `$2000.009 < 353.553$` is `False`.\n    - Is `$R_{\\text{user}} > c_2 r_F$`? `$2000.009 > 707.107$` is `True`.\nThe final program will systematically apply this logic to all test cases and format the results as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the recommended Kirchhoff migration aperture and evaluates a\n    user-proposed aperture based on geophysical principles and given parameters.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (v, f0, z, theta_max_deg, A, gamma)\n    test_cases = [\n        (2500, 30, 1500, 35, 5000, 5.657),  # Case 1\n        (2000, 60, 1000, 5, 1000, 0.548),   # Case 2\n        (3000, 20, 3000, 60, 800, 1.044),   # Case 3\n        (1800, 80, 300, 45, 200, 1.819),   # Case 4\n        (2500, 10, 4000, 80, 10000, 5.000), # Case 5\n        (2200, 55, 1200, 25, 1500, 2.000),  # Case 6\n    ]\n\n    # Fixed constants from the problem description\n    c1 = 1.0\n    c2 = 2.0\n    beta = 1.5\n\n    all_results = []\n    for case in test_cases:\n        v, f0, z, theta_max_deg, A, gamma = case\n\n        # 1. Dominant wavelength\n        # lambda = v / f0\n        # This is used directly in the r_F calculation.\n        \n        # 2. First Fresnel radius at depth\n        # r_F = sqrt(lambda * z) = sqrt((v/f0) * z)\n        r_F = np.sqrt((v / f0) * z)\n\n        # 3. Dip-limited aperture radius\n        # Convert theta_max from degrees to radians for trigonometric functions\n        theta_max_rad = np.deg2rad(theta_max_deg)\n        R_dip = z * np.tan(theta_max_rad)\n\n        # 4. Acquisition-limited radius\n        R_acq = float(A)\n\n        # 5. Target Fresnel-guided radius\n        R_target = beta * r_F\n\n        # 6. Recommended aperture\n        # R_rec = min(R_dip, R_acq, R_target)\n        R_rec = min(R_dip, R_acq, R_target)\n\n        # 7. User-proposed aperture\n        R_user = gamma * r_F\n\n        # 8. Artifact criteria evaluation\n        too_small = R_user < c1 * r_F\n        too_large = R_user > c2 * r_F\n        \n        # Store the results for this case.\n        # The values for R_rec and r_F are not rounded here,\n        # but will be formatted to 3 decimal places in the final print string.\n        all_results.append([R_rec, r_F, too_small, too_large])\n\n    # Format the final output string exactly as required,\n    # with no spaces and with floats formatted to 3 decimal places.\n    sub_list_strings = []\n    for R_rec, r_F, is_too_small, is_too_large in all_results:\n        # str(bool) correctly produces 'True' or 'False'.\n        # f-string formatting handles rounding to 3 decimal places.\n        sub_str = f\"[{R_rec:.3f},{r_F:.3f},{is_too_small},{is_too_large}]\"\n        sub_list_strings.append(sub_str)\n    \n    final_output_string = f\"[{','.join(sub_list_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output_string)\n\nsolve()\n```", "id": "3605983"}, {"introduction": "Seismic data are recorded at discrete locations, a reality that can lead to significant imaging artifacts if not handled properly. This practice addresses the critical issue of spatial aliasing, which arises when the receiver spacing is too coarse to adequately sample steeply dipping seismic events. You will derive the relationship between an event's local slope and the required sampling, and then design a dip-adaptive anti-aliasing filter, providing a fundamental tool for ensuring the fidelity of migrated images from real-world, discretely sampled data.", "problem": "A two-dimensional acoustic medium with constant propagation velocity is considered. An impulse point scatterer at depth generates a family of equal-travel-time curves known as isochrons in the receiver domain. Kirchhoff migration forms an image by summing along isochrons. Sparse receiver sampling can cause spatial aliasing during the summation if the spatial sampling does not satisfy the sampling requirements implied by the local event dip. The objective is to analyze aliasing in sparse receiver lines by linking the receiver spacing to the local geometry of isochrons and then design a dip-adaptive anti-alias filter in the time-space domain before migration, using only foundational principles.\n\nStarting points for the derivation must be limited to fundamental laws and core definitions:\n- The acoustic isotropic constant-velocity kinematics for a two-way travel time from a point diffractor at depth $z$ beneath lateral position $x=0$ is given by the equal-time curve $t(x)$ defined by two-way travel time along straight rays, yielding an isochron $t(x)$ proportional to the path length.\n- The Nyquist-Shannon Sampling Theorem (NSST) in space states that, for a band-limited spatial frequency content with maximum spatial wavenumber magnitude $k_{x,\\max}$, uniform sampling at spacing $\\Delta x_r$ must satisfy $k_{x,\\max} \\le \\pi / \\Delta x_r$ to avoid spatial aliasing.\n- A local plane wave in the recorded data can be represented as a function with phase $\\phi(t,x) = \\omega t - k_x x$, where $\\omega$ is the angular frequency and $k_x$ is the spatial wavenumber. Along a constant-phase trajectory, the local slope $p = \\mathrm{d}t/\\mathrm{d}x$ relates $\\omega$ and $k_x$ by the kinematic requirement that phase is stationary.\n\nTasks:\n1. Derive the relation between the local slope $p(t,x) = \\mathrm{d}t/\\mathrm{d}x$ and the spatial wavenumber $k_x$ of the recorded event. Use this to express a condition on the maximum permissible temporal frequency $f$ (in Hertz) that avoids spatial aliasing for a given receiver spacing $\\Delta x_r$ (in meters). Your final condition must be written entirely in terms of $\\Delta x_r$, the local slope magnitude $\\lvert p \\rvert$, and $f$.\n2. For a point diffractor in a constant-velocity medium with speed $v$ (in meters per second) and depth $z$ (in meters), write the isochron $t(x)$ as a function of lateral coordinate $x$ (in meters). From $t(x)$, compute the first derivative $p(x) = \\mathrm{d}t/\\mathrm{d}x$ (in seconds per meter) and the second derivative $\\kappa(x) = \\mathrm{d}^2 t/\\mathrm{d}x^2$ (in seconds per meter squared). Show that within a finite aperture $x \\in [-X, X]$ (with $X$ in meters), the maximum slope $p_{\\max}$ occurs at the edge of the aperture and the maximum curvature $\\kappa_{\\max}$ occurs at the apex $x=0$. Express $p_{\\max}$ and $\\kappa_{\\max}$ in terms of $v$, $z$, and $X$.\n3. Propose a dip-adaptive anti-alias low-pass filter applied in the time-space domain $(t,x)$ prior to migration, which limits the temporal bandwidth at each sample based on the local slope $p$. Your design must specify a cutoff frequency $f_c(t,x)$ in Hertz that ensures compliance with the spatial sampling requirement. Also, impose the temporal Nyquist limit based on the time sampling interval $\\Delta t$ (in seconds).\n4. Assess time-interpolation aliasing near the apex due to curvature by comparing the second-order temporal variation across adjacent receivers with the time sampling interval. Use the curvature $\\kappa_{\\max}$ and spacing $\\Delta x_r$ to form a sufficient condition that the second-order travel-time offset between adjacent receivers remains below the time sampling interval $\\Delta t$.\n\nImplementation:\n- Implement a program that, for each test case, computes:\n  - The maximum slope $p_{\\max}$ on the aperture.\n  - The maximum curvature $\\kappa_{\\max}$.\n  - The dip-adaptive cutoff $f_c = \\min\\left(\\frac{1}{2\\Delta t}, \\frac{1}{2\\Delta x_r \\lvert p_{\\max} \\rvert}\\right)$ in Hertz.\n  - A boolean $A_s$ indicating whether spatial aliasing would occur at the source peak frequency $f_s$ (in Hertz) without filtering, defined by $A_s = \\bigl(f_s > \\frac{1}{2\\Delta x_r \\lvert p_{\\max} \\rvert}\\bigr)$.\n  - A boolean $A_t$ indicating the risk of time-interpolation aliasing near the apex, defined by $A_t = \\bigl(\\kappa_{\\max} \\Delta x_r^2 > \\Delta t\\bigr)$.\n- Express the cutoff frequencies in Hertz and the booleans as fundamental types. Frequencies must be rounded to three decimal places. Distances must be in meters and times in seconds.\n\nTest Suite:\nUse the following parameter sets for $(v, z, \\Delta x_r, X, \\Delta t, f_s)$, all in International System of Units:\n- Case 1 (general case): $(2500, 1500, 10, 1000, 0.002, 60)$.\n- Case 2 (aliasing risk): $(2000, 1000, 25, 2000, 0.004, 60)$.\n- Case 3 (boundary condition): $(3000, 2000, 21.22, 2000, 0.002, 50)$.\n- Case 4 (high curvature edge): $(2000, 200, 30, 500, 0.001, 80)$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element of the list corresponds to one test case and must itself be a list of three elements $[f_c, A_s, A_t]$, where $f_c$ is a float rounded to three decimal places (in Hertz), $A_s$ is a boolean, and $A_t$ is a boolean. For example, the output must look like $[[f_{c1}, A_{s1}, A_{t1}],[f_{c2}, A_{s2}, A_{t2}],\\dots]$.", "solution": "The problem statement is evaluated to be scientifically grounded, well-posed, objective, and complete. It is based on established principles of wave propagation and signal processing as applied to geophysical imaging. All necessary parameters and definitions are provided for a unique and meaningful solution. We may therefore proceed with the derivation and implementation.\n\nThe solution is developed in four parts, corresponding to the tasks outlined in the problem.\n\n**Part 1: Derivation of the Spatial Anti-Aliasing Condition**\n\nThe relationship between the temporal frequency and spatial wavenumber of a local plane wave is fundamental to this analysis. A local plane wave event in the recorded data can be described by a constant phase trajectory. The phase is given by $\\phi(t,x) = \\omega t - k_x x$, where $\\omega = 2\\pi f$ is the angular temporal frequency, $f$ is the temporal frequency in Hertz, and $k_x$ is the spatial wavenumber.\n\nFor the phase to be stationary along the event's trajectory, defined by the travel time curve $t(x)$, its total differential must be zero:\n$$ \\mathrm{d}\\phi = \\frac{\\partial\\phi}{\\partial t}\\mathrm{d}t + \\frac{\\partial\\phi}{\\partial x}\\mathrm{d}x = \\omega \\mathrm{d}t - k_x \\mathrm{d}x = 0 $$\nDividing by $\\mathrm{d}x$, we obtain a relationship between the local slope of the event, $p(x) = \\frac{\\mathrm{d}t}{\\mathrm{d}x}$, and the wave parameters:\n$$ \\omega \\frac{\\mathrm{d}t}{\\mathrm{d}x} - k_x = 0 \\implies k_x = \\omega p(x) $$\nThe Nyquist-Shannon Sampling Theorem (NSST) in the spatial domain dictates that to avoid aliasing, the magnitude of the highest spatial wavenumber present in the signal, $|k_x|_{\\max}$, must not exceed the spatial Nyquist wavenumber. For a uniform receiver spacing $\\Delta x_r$, the sampling wavenumber is $k_{s,x} = 2\\pi/\\Delta x_r$, and the Nyquist wavenumber is $k_{Nyq,x} = k_{s,x} / 2 = \\pi/\\Delta x_r$. The anti-aliasing condition is therefore:\n$$ |k_x| \\le \\frac{\\pi}{\\Delta x_r} $$\nSubstituting the expression for $k_x$:\n$$ |\\omega p(x)| \\le \\frac{\\pi}{\\Delta x_r} $$\nSince $\\omega > 0$, we have $\\omega |p(x)| \\le \\frac{\\pi}{\\Delta x_r}$. Replacing $\\omega$ with $2\\pi f$:\n$$ (2\\pi f) |p(x)| \\le \\frac{\\pi}{\\Delta x_r} $$\nSolving for the temporal frequency $f$, we arrive at the condition for the maximum permissible frequency that avoids spatial aliasing for a given receiver spacing $\\Delta x_r$ and a local slope magnitude $|p(x)|$:\n$$ f \\le \\frac{1}{2 \\Delta x_r |p(x)|} $$\n\n**Part 2: Kinematics of a Point Diffractor**\n\nFor a point diffractor at depth $z$ under position $x=0$ in a constant velocity medium with speed $v$, the two-way travel time for a zero-offset acquisition (coincident source and receiver at lateral position $x$) is determined by the total path length. The path from the surface at $(x, 0)$ to the diffractor at $(0, -z)$ and back has a length of $2 \\sqrt{x^2 + z^2}$. The travel time $t(x)$ is thus:\n$$ t(x) = \\frac{2\\sqrt{x^2 + z^2}}{v} $$\nThis equation describes the hyperbolic diffraction curve, or isochron.\n\nThe first derivative, $p(x) = \\mathrm{d}t/\\mathrm{d}x$, represents the local slope:\n$$ p(x) = \\frac{\\mathrm{d}}{\\mathrm{d}x} \\left( \\frac{2}{v} (x^2 + z^2)^{1/2} \\right) = \\frac{2}{v} \\cdot \\frac{1}{2} (x^2 + z^2)^{-1/2} (2x) = \\frac{2x}{v\\sqrt{x^2 + z^2}} $$\nThe magnitude of the slope $|p(x)|$ increases with increasing $|x|$. Therefore, over a finite aperture $x \\in [-X, X]$, the maximum slope magnitude $p_{\\max}$ occurs at the edges of the aperture, i.e., at $x=\\pm X$:\n$$ p_{\\max} = |p(X)| = \\frac{2X}{v\\sqrt{X^2 + z^2}} $$\nThe second derivative, $\\kappa(x) = \\mathrm{d}^2t/\\mathrm{d}x^2$, represents the curvature of the isochron:\n$$ \\kappa(x) = \\frac{\\mathrm{d}p}{\\mathrm{d}x} = \\frac{\\mathrm{d}}{\\mathrm{d}x} \\left( \\frac{2x}{v(x^2 + z^2)^{1/2}} \\right) = \\frac{2v\\sqrt{x^2+z^2} - 2x \\cdot \\frac{vx}{\\sqrt{x^2+z^2}}}{v^2(x^2+z^2)} = \\frac{2v(x^2+z^2) - 2vx^2}{v^2(x^2+z^2)^{3/2}} = \\frac{2vz^2}{v^2(x^2+z^2)^{3/2}} $$\n$$ \\kappa(x) = \\frac{2z^2}{v(x^2 + z^2)^{3/2}} $$\nThe curvature $\\kappa(x)$ is a decreasing function of $|x|$. Its maximum value, $\\kappa_{\\max}$, occurs at the apex of the hyperbola, where $x=0$:\n$$ \\kappa_{\\max} = \\kappa(0) = \\frac{2z^2}{v(0 + z^2)^{3/2}} = \\frac{2z^2}{vz^3} = \\frac{2}{vz} $$\n\n**Part 3: Dip-Adaptive Anti-Alias Filter Design**\n\nBased on the condition derived in Part 1, spatial aliasing can be prevented by ensuring that the temporal frequency content of the signal at each trace location $x$ does not exceed a maximum value determined by the local slope $|p(x)|$. This suggests a dip-adaptive low-pass filter whose cutoff frequency varies with spatial position.\n\nThe cutoff frequency, $f_{aa}(x)$, required to prevent spatial aliasing at position $x$ is:\n$$ f_{aa}(x) = \\frac{1}{2 \\Delta x_r |p(x)|} $$\nFurthermore, any digital signal is inherently band-limited by the temporal sampling. For a time sampling interval $\\Delta t$, the temporal Nyquist frequency is $f_{Nyq,t} = \\frac{1}{2\\Delta t}$. The effective cutoff frequency $f_c(x)$ at any position $x$ must satisfy both constraints. Therefore, it is the minimum of the two:\n$$ f_c(x) = \\min\\left(f_{Nyq,t}, f_{aa}(x)\\right) = \\min\\left(\\frac{1}{2\\Delta t}, \\frac{1}{2 \\Delta x_r |p(x)|}\\right) $$\nIn practice, the local slope $p(x)$ is estimated from the data. For the purposes of this problem's implementation, a single conservative cutoff frequency is calculated for the entire aperture by using the maximum slope $p_{\\max}$. This ensures that no part of the event is aliased.\n$$ f_c = \\min\\left(\\frac{1}{2\\Delta t}, \\frac{1}{2\\Delta x_r p_{\\max}}\\right) $$\n\n**Part 4: Time-Interpolation Aliasing**\n\nDuring Kirchhoff migration, seismic data are summed along the discrete points of the hyperbolic operator. If the hyperbola is strongly curved, there can be a large time step between samples on adjacent traces, a phenomenon sometimes termed \"operator aliasing\" or time-interpolation aliasing. This is most severe near the apex of the hyperbola where the curvature $\\kappa$ is maximal.\n\nWe can quantify this effect by examining the second central difference of the travel time function $t(x)$ at the apex ($x=0$), which approximates the second derivative scaled by the sampling interval squared. Let's consider travel times at three adjacent receivers located at $x=-\\Delta x_r$, $x=0$, and $x=\\Delta x_r$.\n$$ \\Delta^2 t_0 = t(\\Delta x_r) - 2t(0) + t(-\\Delta x_r) $$\nSince $t(x)$ is an even function, $t(-\\Delta x_r) = t(\\Delta x_r)$, so:\n$$ \\Delta^2 t_0 = 2(t(\\Delta x_r) - t(0)) $$\nUsing a second-order Taylor expansion of $t(x)$ around $x=0$, where $p(0)=0$ and $\\kappa(0)=\\kappa_{\\max}$:\n$$ t(\\Delta x_r) \\approx t(0) + p(0)\\Delta x_r + \\frac{1}{2}\\kappa(0)(\\Delta x_r)^2 = t(0) + \\frac{1}{2}\\kappa_{\\max}(\\Delta x_r)^2 $$\nSubstituting this into the expression for $\\Delta^2 t_0$:\n$$ \\Delta^2 t_0 \\approx 2\\left(\\frac{1}{2}\\kappa_{\\max}(\\Delta x_r)^2\\right) = \\kappa_{\\max}(\\Delta x_r)^2 $$\nThis quantity represents the non-linear change in travel time over a two-trace interval. If this change exceeds the time sampling interval $\\Delta t$, the discrete representation of the migration operator becomes a poor approximation of the continuous hyperbola, potentially leading to artifacts. Thus, the condition for a high risk of time-interpolation aliasing is:\n$$ \\kappa_{\\max} (\\Delta x_r)^2 > \\Delta t $$\nThis completes the theoretical derivations required for the implementation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates aliasing parameters for Kirchhoff migration based on a series of test cases.\n    \"\"\"\n    # Test cases: (v, z, delta_xr, X, delta_t, f_s)\n    # v: velocity (m/s)\n    # z: depth (m)\n    # delta_xr: receiver spacing (m)\n    # X: half-aperture width (m)\n    # delta_t: time sampling interval (s)\n    # f_s: source peak frequency (Hz)\n    test_cases = [\n        (2500, 1500, 10, 1000, 0.002, 60),\n        (2000, 1000, 25, 2000, 0.004, 60),\n        (3000, 2000, 21.22, 2000, 0.002, 50),\n        (2000, 200, 30, 500, 0.001, 80),\n    ]\n\n    results = []\n    for case in test_cases:\n        v, z, dx_r, X, dt, f_s = case\n\n        # Task 2: Compute maximum slope and curvature\n        # Maximum slope p_max at the edge of the aperture\n        if (X**2 + z**2) > 0:\n            p_max = (2 * X) / (v * np.sqrt(X**2 + z**2))\n        else:\n            p_max = 0.0\n\n        # Maximum curvature kappa_max at the apex\n        k_max = 2 / (v * z)\n\n        # Task 3: Compute dip-adaptive cutoff frequency\n        # Anti-aliasing frequency limit based on p_max\n        if dx_r > 0 and p_max > 0:\n            f_aa = 1 / (2 * dx_r * p_max)\n        else:\n            f_aa = float('inf')\n\n        # Temporal Nyquist frequency\n        f_nyq_t = 1 / (2 * dt)\n\n        # The effective cutoff frequency is the minimum of the two\n        f_c = min(f_nyq_t, f_aa)\n\n        # Task 4 & Implementation: Compute aliasing booleans\n        # A_s: Spatial aliasing check for source frequency\n        A_s = f_s > f_aa\n\n        # A_t: Time-interpolation aliasing check\n        A_t = (k_max * dx_r**2) > dt\n        \n        # Round f_c to three decimal places as required\n        f_c_rounded = round(f_c, 3)\n\n        results.append([f_c_rounded, A_s, A_t])\n\n    # Format the final output string exactly as specified, without spaces\n    # Example: [[fc1,As1,At1],[fc2,As2,At2],...]\n    output_str_parts = []\n    for res in results:\n        # Manually format each inner list to avoid spaces introduced by str(list)\n        # f-string automatically calls repr() on booleans, yielding 'True'/'False'\n        part = f\"[{res[0]},{res[1]},{res[2]}]\"\n        output_str_parts.append(part)\n    \n    final_output = f\"[{','.join(output_str_parts)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3606031"}, {"introduction": "Every imaging method has inherent resolution limits and potential directional biases. This advanced practice treats the entire imaging workflow as a linear system and asks you to analyze its performance by computing the point-spread function (PSF), which is the response of the system to an idealized point diffractor. By implementing the action of the migration normal operator (or Hessian) and quantifying the resulting PSF's anisotropy, you will gain deep insight into how acquisition geometry and velocity variations control the ultimate resolution and quality of a migrated seismic image.", "problem": "Consider Two-Dimensional (2D) acoustic wave propagation in a heterogeneous medium with a free surface at depth coordinate $y = 0$ and a spatially varying velocity field $v(\\mathbf{x})$, where $\\mathbf{x} = (x,y)$. The acoustic pressure field $p(\\mathbf{x}, t)$ obeys the constant-density acoustic wave equation\n$$\\frac{1}{v^2(\\mathbf{x})}\\frac{\\partial^2 p(\\mathbf{x}, t)}{\\partial t^2} - \\nabla^2 p(\\mathbf{x}, t) = s(\\mathbf{x}, t),$$\nwhere $s(\\mathbf{x}, t)$ is a source term. Under the linearized Born approximation for weak perturbations, the recorded data can be written as a linear operator acting on reflectivity $m(\\mathbf{x})$. The Kirchhoff migration operator is the adjoint of the linearized forward operator with appropriate geometric and band-limited weighting. The normal operator (also called the Hessian) is $H = L^\\dagger L$, where $L$ is the forward operator and $L^\\dagger$ is its adjoint.\n\nYour tasks are as follows, all under the high-frequency (ray-theoretic) regime, adopting a straight-ray approximation consistent with a smooth heterogeneous $v(\\mathbf{x})$:\n\n- Starting from the acoustic wave equation and the Kirchhoff integral representation, derive the adjoint-stacking interpretation of Kirchhoff migration for zero-offset acquisition, where sources and receivers are co-located at the surface. Show how $H = L^\\dagger L$ acting on a localized reflectivity at $\\mathbf{x}_0$ produces a point-spread function (PSF) $\\mathrm{PSF}(\\mathbf{x}; \\mathbf{x}_0)$ that can be interpreted as a band-limited summation over acquisition aperture governed by stationary-phase traveltime fitting.\n\n- Define a physically plausible and computationally tractable heterogeneous velocity model and acquisition geometry, and specify a band-limited time-selection kernel. Then, write a complete, runnable program to compute an approximation to the normal operator acting on a unit impulse at $\\mathbf{x}_0$, i.e., compute $\\mathrm{PSF}(\\mathbf{x}; \\mathbf{x}_0)$ on a local image grid around $\\mathbf{x}_0$, and analyze the PSF anisotropy as a function of local reflector dip and acquisition aperture.\n\nUse the following scientifically sound and self-consistent specifications:\n\n- Medium and velocity: Let $v(\\mathbf{x}) = v_0 + \\gamma y$, with $v_0 = 2000$ in $\\mathrm{m/s}$ and $\\gamma = 0.6$ in $\\mathrm{s}^{-1}$ so that $v(\\mathbf{x})$ increases linearly with depth.\n\n- Acquisition: Zero-offset sources at the free surface $y = 0$ with lateral positions $x_s$ uniformly spaced over a symmetric aperture $[-A, A]$ with spacing $\\Delta x_s = 25$ in $\\mathrm{m}$. For each test case aperture $A$, use all source positions in this range.\n\n- Image point and grid: Choose the analysis point $\\mathbf{x}_0 = (0, 1000)$ in $\\mathrm{m}$. Compute the PSF on a local image grid centered at $\\mathbf{x}_0$ spanning $[x_0 - L_x, x_0 + L_x] \\times [y_0 - L_y, y_0 + L_y]$ with $L_x = 200$ in $\\mathrm{m}$, $L_y = 200$ in $\\mathrm{m}$, and uniform sampling $\\Delta x = \\Delta y = 10$ in $\\mathrm{m}$.\n\n- Traveltimes: For each source position $x_s$ and grid point $\\mathbf{x} = (x,y)$, approximate the one-way traveltime by straight-ray integration along the line segment using a midpoint approximation,\n$$\\tau(\\mathbf{x}; x_s) \\approx \\frac{L(\\mathbf{x}; x_s)}{\\bar{v}(\\mathbf{x})}, \\quad L(\\mathbf{x}; x_s) = \\sqrt{(x - x_s)^2 + y^2}, \\quad \\bar{v}(\\mathbf{x}) = v_0 + \\gamma \\frac{y}{2}.$$\nFor zero-offset migration, use the two-way time $t(\\mathbf{x}; x_s) = 2 \\tau(\\mathbf{x}; x_s)$.\n\n- Band-limited time-selection kernel: Use a Gaussian time gate to approximate band-limited matched filtering around stationary phase. With a dominant frequency $f_0 = 20$ in $\\mathrm{Hz}$, define the time standard deviation $\\sigma_t = 0.25 / f_0$ in $\\mathrm{s}$. For a unit reflectivity at $\\mathbf{x}_0$, the contribution from source $x_s$ to the PSF at $\\mathbf{x}$ is weighted by\n$$w_t(\\mathbf{x}; x_s) = \\exp\\!\\left( - \\frac{(t(\\mathbf{x}; x_s) - t(\\mathbf{x}_0; x_s))^2}{2 \\sigma_t^2} \\right).$$\n\n- Geometric amplitude: Include a simple geometric spreading factor $w_g(\\mathbf{x}; x_s) = 1 / \\big(L(\\mathbf{x}; x_s) + \\epsilon\\big)$ with a small regularizer $\\epsilon = 1$ in $\\mathrm{m}$, and form the PSF by summing $w_t(\\mathbf{x}; x_s) \\, w_g(\\mathbf{x}; x_s)$ over all sources $x_s$ in the aperture.\n\n- PSF anisotropy analysis: For a given local dip angle $\\theta$ in degrees, define the anisotropy metrics from the PSF on the local grid as follows. Use the PSF values as nonnegative weights to compute the weighted covariance matrix of offsets $\\mathbf{r} = (x - x_0, y - y_0)$,\n$$\\Sigma = \\frac{\\sum_i w_i \\, (\\mathbf{r}_i - \\bar{\\mathbf{r}})(\\mathbf{r}_i - \\bar{\\mathbf{r}})^\\top}{\\sum_i w_i}, \\quad \\bar{\\mathbf{r}} = \\frac{\\sum_i w_i \\, \\mathbf{r}_i}{\\sum_i w_i}, \\quad w_i = \\mathrm{PSF}(\\mathbf{x}_i; \\mathbf{x}_0).$$\nLet the eigenvalues of $\\Sigma$ be $\\lambda_{\\max} \\ge \\lambda_{\\min} \\ge 0$ with corresponding unit eigenvector $\\mathbf{e}_{\\max}$. Define the anisotropy ratio as the ratio of standard deviations $R = \\sqrt{\\lambda_{\\max}} / \\sqrt{\\lambda_{\\min}}$. Define the PSF major-axis orientation angle $\\phi_{\\max}$ in degrees as the angle of $\\mathbf{e}_{\\max}$ measured from the horizontal (positive $x$-axis), and define the orientation difference relative to the local dip direction angle $\\theta$ (in degrees) as the minimal undirected angle\n$$\\Delta \\phi = \\min\\!\\left( \\left| \\phi_{\\max} - \\theta \\right| , \\, 180 - \\left| \\phi_{\\max} - \\theta \\right| \\right) \\quad \\text{in degrees}.$$\n\nYour program must implement the above and produce the anisotropy ratio $R$ (dimensionless) and the orientation difference $\\Delta \\phi$ in degrees for each test case listed below.\n\nTest suite:\n\n- Case $1$: Dip $\\theta = 0$ in degrees, aperture half-width $A = 1000$ in $\\mathrm{m}$.\n\n- Case $2$: Dip $\\theta = 60$ in degrees, aperture half-width $A = 1000$ in $\\mathrm{m}$.\n\n- Case $3$: Dip $\\theta = 60$ in degrees, aperture half-width $A = 200$ in $\\mathrm{m}$.\n\n- Case $4$: Dip $\\theta = 80$ in degrees, aperture half-width $A = 2000$ in $\\mathrm{m}$.\n\n- Case $5$: Dip $\\theta = 0$ in degrees, aperture half-width $A = 50$ in $\\mathrm{m}$.\n\nFinal output format:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases. For each case, append the anisotropy ratio $R$ followed by the orientation difference $\\Delta \\phi$, both as floats. For example, the output should look like $\\left[\\text{case1\\_R}, \\text{case1\\_DeltaPhi}, \\text{case2\\_R}, \\text{case2\\_DeltaPhi}, \\ldots \\right]$.\n\nAll distances must be in $\\mathrm{m}$, all times in $\\mathrm{s}$, velocities in $\\mathrm{m/s}$, and all angles in degrees. The program must be self-contained and must not read any input or external files. The normal operator computation must reflect the specified physics and approximations and must be implemented explicitly, not using black-box migration functions.", "solution": "The problem is assessed to be valid. It is scientifically grounded in the principles of wave theory and seismic imaging, well-posed with all necessary parameters and equations defined, and computationally feasible. The use of approximations, such as the straight-ray traveltime calculation, is explicitly stated as part of the problem definition and does not constitute a flaw.\n\nThe solution is presented in two parts as requested: first, a theoretical derivation of the Kirchhoff migration operator and the resulting point-spread function (PSF), followed by the implementation of a program to compute and analyze the PSF.\n\n### Part 1: Theoretical Derivation\n\nThe problem is rooted in the constant-density acoustic wave equation for a pressure field $p(\\mathbf{x}, t)$ in a heterogeneous medium with velocity $v(\\mathbf{x})$:\n$$ \\left( \\frac{1}{v^2(\\mathbf{x})} \\frac{\\partial^2}{\\partial t^2} - \\nabla^2 \\right) p(\\mathbf{x}, t) = s(\\mathbf{x}, t) $$\nwhere $\\mathbf{x} = (x, y)$ are the spatial coordinates, $t$ is time, and $s(\\mathbf{x}, t)$ is the source term.\n\nWe consider a background velocity model $v_b(\\mathbf{x})$ and a true velocity model $v(\\mathbf{x})$. The subsurface reflectivity, or scattering potential, is defined by the model perturbation $m(\\mathbf{x})$:\n$$ m(\\mathbf{x}) = \\frac{1}{v_b^2(\\mathbf{x})} - \\frac{1}{v^2(\\mathbf{x})} $$\nUnder the first-order Born approximation, which is valid for weak scattering ($m(\\mathbf{x})$ is small), the total wavefield $p$ is decomposed into a background field $p_b$ and a scattered field $p_s$, where $p=p_b+p_s$. The scattered field is linearly related to the reflectivity model $m(\\mathbf{x})$. The recorded scattered data $d$ at a receiver location $\\mathbf{x}_r$ due to a source at $\\mathbf{x}_s$ firing at time $t=0$ with wavelet $w(t)$ can be expressed as a linear forward operator $L$ acting on the model $m(\\mathbf{x})$:\n$$ d(\\mathbf{x}_r, t; \\mathbf{x}_s) = (L m)(\\mathbf{x}_r, t; \\mathbf{x}_s) = \\int_V d\\mathbf{x} \\, m(\\mathbf{x}) \\left( \\frac{\\partial^2}{\\partial t^2} p_b(\\mathbf{x}, t; \\mathbf{x}_s) \\right) * G(\\mathbf{x}_r, t; \\mathbf{x}) $$\nHere, $p_b(\\mathbf{x}, t; \\mathbf{x}_s)$ is the background wavefield at point $\\mathbf{x}$ due to the source, which can be approximated by $w(t) * G(\\mathbf{x}, t; \\mathbf{x}_s)$, and $G$ is the Green's function for the background medium. The asterisk $*$ denotes temporal convolution. In the high-frequency (ray-theoretic) limit, the Green's function is an impulse delayed by the traveltime $\\tau$, so the data can be written as:\n$$ d(\\mathbf{x}_r, t; \\mathbf{x}_s) \\approx \\int_V d\\mathbf{x} \\, m(\\mathbf{x}) \\, A(\\mathbf{x}_s, \\mathbf{x}, \\mathbf{x}_r) \\, w''(t - \\tau(\\mathbf{x}_s, \\mathbf{x}) - \\tau(\\mathbf{x}, \\mathbf{x}_r)) $$\nwhere $A$ contains geometric spreading and other amplitude factors, and $\\tau(\\mathbf{a}, \\mathbf{b})$ is the one-way traveltime from $\\mathbf{a}$ to $\\mathbf{b}$.\n\nKirchhoff migration is the process of generating an image of the reflectivity, $m_{\\text{mig}}(\\mathbf{x})$, from the recorded data $d$. It is formulated as the adjoint operator $L^\\dagger$ applied to the data. The adjoint operator can be found by inspecting the forward modeling integral. For each image point $\\mathbf{x}$, migration sums the data contributions along kinematic traveltime surfaces. For a zero-offset acquisition geometry where the source and receiver are co-located at the surface, $\\mathbf{x}_s = \\mathbf{x}_r = (x_s, 0)$, the two-way traveltime is $t(\\mathbf{x}; x_s) = 2 \\tau((x_s, 0), \\mathbf{x})$. The migration operator $L^\\dagger$ becomes a weighted stack over the source locations:\n$$ m_{\\text{mig}}(\\mathbf{x}) = (L^\\dagger d)(\\mathbf{x}) = \\int_{\\text{aperture}} dx_s \\, W(\\mathbf{x}; x_s) d(x_s, t = t(\\mathbf{x}; x_s)) $$\nHere, $W(\\mathbf{x}; x_s)$ is a weight function that includes geometric spreading and other factors. This integral represents the \"adjoint-stacking\" interpretation: for each image point $\\mathbf{x}$, we compute its expected two-way traveltime $t(\\mathbf{x}; x_s)$ for each source $x_s$, sample the data trace recorded at $x_s$ at that time, and add it to the image with an appropriate weight.\n\nThe normal operator, or Hessian, $H = L^\\dagger L$, describes the combined effect of forward modeling and migration. It acts as a blurring or resolution operator in the image space. The point-spread function (PSF) is the result of the Hessian acting on an idealized point diffractor. Let the true model be a unit-amplitude point diffractor at $\\mathbf{x}_0$, i.e., $m(\\mathbf{x}) = \\delta(\\mathbf{x} - \\mathbf{x}_0)$.\n\n1.  **Forward Modeling ($L$)**: We first generate synthetic data by applying $L$ to $m(\\mathbf{x})$. The integral for the data simplifies to evaluating the kernel at $\\mathbf{x} = \\mathbf{x}_0$:\n    $$ d_{\\text{syn}}(x_s, t) = (L m)(x_s, t) \\approx A(\\mathbf{x}_0; x_s) \\, w''(t - t(\\mathbf{x}_0; x_s)) $$\n    This means the recorded data for each source $x_s$ is simply the (second derivative of the) source wavelet, scaled by an amplitude $A$ and delayed by the two-way traveltime $t(\\mathbf{x}_0; x_s)$ to the diffractor.\n\n2.  **Migration ($L^\\dagger$)**: Next, we apply the migration operator $L^\\dagger$ to this synthetic data $d_{\\text{syn}}$ to obtain the PSF:\n    $$ \\mathrm{PSF}(\\mathbf{x}; \\mathbf{x}_0) = (L^\\dagger d_{\\text{syn}})(\\mathbf{x}) = \\int_{\\text{aperture}} dx_s \\, W(\\mathbf{x}; x_s) d_{\\text{syn}}(x_s, t = t(\\mathbf{x}; x_s)) $$\n    Substituting the expression for $d_{\\text{syn}}$:\n    $$ \\mathrm{PSF}(\\mathbf{x}; \\mathbf{x}_0) \\approx \\int_{\\text{aperture}} dx_s \\, W(\\mathbf{x}; x_s) A(\\mathbf{x}_0; x_s) \\, w''(t(\\mathbf{x}; x_s) - t(\\mathbf{x}_0; x_s)) $$\n    This expression shows that the PSF at an image point $\\mathbf{x}$ is formed by summing contributions from all sources $x_s$ over the acquisition aperture. The contribution from each source is non-zero only when the traveltime difference $\\Delta t = t(\\mathbf{x}; x_s) - t(\\mathbf{x}_0; x_s)$ is small, within the duration of the wavelet $w''$. The condition $\\Delta t \\approx 0$ is the stationary-phase condition that governs the constructive interference creating the image. This demonstrates the interpretation of the PSF as a \"band-limited summation over acquisition aperture governed by stationary-phase traveltime fitting.\"\n\nThe computational part of the problem directly implements a discrete version of this final integral. The term $w''(t(\\mathbf{x}; x_s) - t(\\mathbf{x}_0; x_s))$ corresponds to the band-limited time-selection kernel $w_t(\\mathbf{x}; x_s)$, and the combined amplitude terms $W(\\mathbf{x}; x_s) A(\\mathbf{x}_0; x_s)$ are approximated by the geometric spreading factor $w_g(\\mathbf{x}; x_s)$. The integral over $x_s$ becomes a sum over the discrete source positions.\n\n### Part 2: Computational Analysis\n\nThe provided Python code implements the procedure to compute and analyze the PSF.\n\n- **Setup**: It defines all physical and computational parameters, including the velocity model ($v_0, \\gamma$), acquisition geometry ($\\Delta x_s$, and per-case aperture $A$), image grid specifications ($L_x, L_y, \\Delta x, \\Delta y$), and imaging parameters ($f_0, \\sigma_t, \\epsilon$).\n\n- **PSF Computation**: For each test case, it iterates through all specified source positions $x_s$. For each source, it calculates a contribution to the PSF on the entire image grid. This calculation is vectorized for efficiency.\n    - The two-way traveltimes to the true point diffractor $\\mathbf{x}_0=(0, 1000)$ and to every point $\\mathbf{x}$ on the grid are computed using the specified straight-ray, midpoint-velocity approximation: $t(\\mathbf{x}; x_s) = 2 \\sqrt{(x-x_s)^2+y^2} / (v_0+\\gamma y/2)$.\n    - The time-selection weight $w_t$ (a Gaussian function of the traveltime difference) and the geometric spreading weight $w_g$ are computed for every grid point.\n    - The product of these weights gives the contribution from the source $x_s$, which is accumulated into the `PSF` array.\n\n- **Anisotropy Analysis**: After summing contributions from all sources, the resulting `PSF` array is analyzed.\n    - The `PSF` values act as weights for a weighted covariance analysis of the grid point positions relative to the center $\\mathbf{x}_0$.\n    - The $2 \\times 2$ weighted covariance matrix $\\Sigma$ of the spatial offsets is computed. The eigenvalues of $\\Sigma$, $\\lambda_{\\max}$ and $\\lambda_{\\min}$, quantify the variance (spread) of the PSF along its principal axes. The corresponding eigenvectors define the orientation of these axes.\n    - The anisotropy ratio $R = \\sqrt{\\lambda_{\\max}/\\lambda_{\\min}}$ is computed. A large value of $R$ indicates a highly elongated, anisotropic PSF, corresponding to poor resolution in one direction.\n    - The orientation angle of the major axis, $\\phi_{\\max}$, is calculated from the eigenvector corresponding to $\\lambda_{\\max}$.\n    - Finally, the orientation difference $\\Delta\\phi$ is calculated as the minimum undirected angle between the PSF's major axis orientation $\\phi_{\\max}$ and the reference dip angle $\\theta$, providing a measure of how the imaging artifact aligns with a geologic feature of that dip.\n\n- **Execution**: The code iterates through the five test cases provided, computes $(R, \\Delta\\phi)$ for each, and prints the collected results in the specified format. The results numerically demonstrate how PSF anisotropy and orientation depend on acquisition aperture and the dip being analyzed. For example, a smaller aperture generally leads to a larger anisotropy ratio $R$, indicating poorer resolution.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and analyzes the Point Spread Function (PSF) for Kirchhoff migration\n    under specified approximations for a series of test cases.\n    \"\"\"\n    \n    # ----------------------------------------------------------------------\n    # Define physical and computational constants from the problem statement\n    # ----------------------------------------------------------------------\n    \n    # Medium and velocity model\n    v0 = 2000.0  # Velocity at surface, in m/s\n    gamma = 0.6  # Velocity gradient, in s^-1\n    \n    # Acquisition parameters\n    dx_s = 25.0  # Source spacing, in m\n    \n    # Image point and grid\n    x0, y0 = 0.0, 1000.0  # Center of analysis, in m\n    Lx, Ly = 200.0, 200.0  # Half-widths of the local image grid, in m\n    dx, dy = 10.0, 10.0   # Grid sampling, in m\n    \n    # Imaging parameters\n    f0 = 20.0  # Dominant frequency, in Hz\n    sigma_t = 0.25 / f0  # Time standard deviation for Gaussian kernel, in s\n    epsilon = 1.0  # Regularizer for geometric spreading, in m\n    \n    # ----------------------------------------------------------------------\n    # Setup image grid\n    # ----------------------------------------------------------------------\n    x_coords = np.arange(x0 - Lx, x0 + Lx + dx, dx)\n    y_coords = np.arange(y0 - Ly, y0 + Ly + dy, dy)\n    xx, yy = np.meshgrid(x_coords, y_coords)\n    \n    # ----------------------------------------------------------------------\n    # Define test cases\n    # ----------------------------------------------------------------------\n    test_cases = [\n        # (Aperture half-width A [m], Dip angle theta [degrees])\n        (1000.0, 0.0),   # Case 1\n        (1000.0, 60.0),  # Case 2\n        (200.0, 60.0),   # Case 3\n        (2000.0, 80.0),  # Case 4\n        (50.0, 0.0)      # Case 5\n    ]\n    \n    results = []\n\n    # ----------------------------------------------------------------------\n    # Main loop over test cases\n    # ----------------------------------------------------------------------\n    for A, theta in test_cases:\n        \n        # 1. DEFINE SOURCE POSITIONS\n        source_pos = np.arange(-A, A + dx_s, dx_s)\n        \n        # 2. COMPUTE PSF\n        PSF = np.zeros_like(xx)\n        \n        # Pre-calculate velocity at grid depths\n        v_bar_grid = v0 + gamma * yy / 2.0\n        \n        for xs in source_pos:\n            # Traveltime to the true point diffractor x0\n            L0 = np.sqrt((x0 - xs)**2 + y0**2)\n            v_bar0 = v0 + gamma * y0 / 2.0\n            t0 = 2.0 * L0 / v_bar0\n            \n            # Traveltimes to all points on the image grid\n            L_grid = np.sqrt((xx - xs)**2 + yy**2)\n            t_grid = 2.0 * L_grid / v_bar_grid\n            \n            # Calculate weights\n            w_t = np.exp(-((t_grid - t0)**2) / (2.0 * sigma_t**2))\n            w_g = 1.0 / (L_grid + epsilon)\n            \n            # Accumulate PSF\n            PSF += w_t * w_g\n\n        # 3. ANALYZE PSF ANISOTROPY\n        \n        # Total weight\n        W_sum = np.sum(PSF)\n        \n        # If PSF is effectively zero everywhere, skip to avoid division by zero\n        if W_sum < 1e-15:\n            results.extend([np.inf, 0.0])\n            continue\n            \n        # Weighted mean offset r_bar = (rx_bar, ry_bar)\n        rx_bar = np.sum(PSF * (xx - x0)) / W_sum\n        ry_bar = np.sum(PSF * (yy - y0)) / W_sum\n        \n        # Components of the weighted covariance matrix Sigma\n        dxx = xx - x0 - rx_bar\n        dyy = yy - y0 - ry_bar\n        \n        Sigma_xx = np.sum(PSF * dxx**2) / W_sum\n        Sigma_yy = np.sum(PSF * dyy**2) / W_sum\n        Sigma_xy = np.sum(PSF * dxx * dyy) / W_sum\n        \n        Sigma = np.array([[Sigma_xx, Sigma_xy], [Sigma_xy, Sigma_yy]])\n\n        # Eigen decomposition of the covariance matrix\n        eigvals, eigvecs = np.linalg.eig(Sigma)\n        \n        # Sort eigenvalues and eigenvectors\n        sort_indices = np.argsort(eigvals)\n        lambda_min = eigvals[sort_indices[0]]\n        lambda_max = eigvals[sort_indices[1]]\n        e_max = eigvecs[:, sort_indices[1]]\n        \n        # Calculate anisotropy ratio R\n        # Add a small value to lambda_min to prevent division by zero for nearly 1D PSF\n        if lambda_min < 1e-15:\n            R = np.inf\n        else:\n            R = np.sqrt(lambda_max / lambda_min)\n        \n        # Calculate orientation of major axis, phi_max\n        phi_max_rad = np.arctan2(e_max[1], e_max[0])\n        phi_max_deg = np.rad2deg(phi_max_rad)\n\n        # Calculate orientation difference Delta_phi\n        # This correctly computes the minimal undirected angle between two lines\n        delta_phi_abs = np.abs(phi_max_deg - theta)\n        Delta_phi = np.min([delta_phi_abs, 180.0 - delta_phi_abs])\n        \n        results.extend([R, Delta_phi])\n\n    # ----------------------------------------------------------------------\n    # Final print statement in the exact required format\n    # ----------------------------------------------------------------------\n    print(f\"[{','.join(f'{val:.6f}' for val in results)}]\")\n\nsolve()\n```", "id": "3605972"}]}