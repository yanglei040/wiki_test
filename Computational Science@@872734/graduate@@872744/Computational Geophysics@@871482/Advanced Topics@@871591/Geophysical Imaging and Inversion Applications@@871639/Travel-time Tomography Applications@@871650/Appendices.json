{"hands_on_practices": [{"introduction": "The first step in travel-time tomography is to translate the physical problem of wave propagation into a manageable mathematical framework. This involves discretizing the Earth model into cells and expressing the observed travel times as a linear combination of the unknown slowness values in each cell, formulated as the matrix equation $\\mathbf{d} = \\mathbf{G}\\mathbf{m}$. This foundational exercise ([@problem_id:3617796]) provides direct practice in constructing the geometry matrix $\\mathbf{G}$ by calculating the lengths of ray paths within each model cell. By assembling $\\mathbf{G}$ and the corresponding normal matrix $\\mathbf{G}^T\\mathbf{G}$, you will gain a concrete understanding of how survey geometry shapes the characteristics of the inverse problem.", "problem": "Consider a two-dimensional (2D) square domain denoted by $D = [0,2] \\times [0,2]$ measured in $\\mathrm{km}$, partitioned into four equal square cells of side length $1\\,\\mathrm{km}$. Label the cells by indices $j \\in \\{1,2,3,4\\}$ as follows: $C_{1} = [0,1] \\times [0,1]$ (bottom-left), $C_{2} = [1,2] \\times [0,1]$ (bottom-right), $C_{3} = [0,1] \\times [1,2]$ (top-left), and $C_{4} = [1,2] \\times [1,2]$ (top-right). In the straight-ray, high-frequency approximation of travel-time tomography, the travel time $t_{i}$ of ray $i$ is modeled by the line integral $t_{i} = \\int_{\\gamma_{i}} s(\\mathbf{x}) \\,\\mathrm{d}s$, where $s(\\mathbf{x})$ is the slowness and $\\gamma_{i}$ is the ray path. When $s(\\mathbf{x})$ is assumed piecewise constant over the cells, with unknown slowness parameters $m_{j}$ for cell $j$, the discrete forward model is $t_{i} = \\sum_{j=1}^{4} G_{ij} m_{j}$, where $G_{ij}$ equals the path length of ray $i$ within cell $j$.\n\nThree straight rays are observed, each defined by a source and a receiver position (both in $\\mathrm{km}$), and taken to propagate as straight line segments across $D$:\n\n- Ray $1$: source at $(-0.2,\\,0.5)$ and receiver at $(2.2,\\,0.5)$.\n- Ray $2$: source at $(0.5,\\,-0.2)$ and receiver at $(0.5,\\,2.2)$.\n- Ray $3$: source at $(-0.2,\\,1.5)$ and receiver at $(2.2,\\,1.5)$.\n\nAssume rays do not bend and only their segments inside $D$ contribute to $G$. Using geometric intersection of each ray with the cell boundaries, compute the entries $G_{ij}$ (in $\\mathrm{km}$) as the path lengths through each cell for $i \\in \\{1,2,3\\}$ and $j \\in \\{1,2,3,4\\}$. Then assemble the normal matrix $G^{T} G$ explicitly (units $\\mathrm{km}^{2}$). Finally, compute the determinant of $G^{T} G$ and express your final answer in $\\mathrm{km}^{8}$. Provide the exact value; no rounding is required.", "solution": "The problem is well-posed, scientifically grounded, and contains all necessary information to proceed. The task is to compute the geometry matrix $G$, the normal matrix $G^T G$, and its determinant, based on the provided a $2\\mathrm{D}$ tomographic setup.\n\nThe domain is a square $D = [0,2] \\times [0,2]$ in units of $\\mathrm{km}$. It is divided into four equal square cells, each of side length $1\\,\\mathrm{km}$:\n-   $C_{1} = [0,1] \\times [0,1]$ (bottom-left)\n-   $C_{2} = [1,2] \\times [0,1]$ (bottom-right)\n-   $C_{3} = [0,1] \\times [1,2]$ (top-left)\n-   $C_{4} = [1,2] \\times [1,2]$ (top-right)\n\nThe matrix elements $G_{ij}$ represent the path length of ray $i$ within cell $j$. We compute these lengths for each of the three given rays. The units of $G_{ij}$ will be $\\mathrm{km}$.\n\nRay $1$: Source at $(-0.2, 0.5)$ and receiver at $(2.2, 0.5)$.\nThis ray is a horizontal straight line segment described by the equation $y=0.5$. We consider its intersection with the domain $D$, which is the segment for $x \\in [0,2]$.\n-   Intersection with $C_{1}$: The ray at $y=0.5$ is within the $y$-range $[0,1]$ of $C_{1}$. It traverses this cell from $x=0$ to $x=1$. The path length is $G_{11} = 1-0 = 1$.\n-   Intersection with $C_{2}$: The ray at $y=0.5$ is within the $y$-range $[0,1]$ of $C_{2}$. It traverses this cell from $x=1$ to $x=2$. The path length is $G_{12} = 2-1 = 1$.\n-   Intersection with $C_{3}$ and $C_{4}$: The ray at $y=0.5$ is outside the $y$-range $[1,2]$ of these cells. Thus, the path lengths are $G_{13} = 0$ and $G_{14} = 0$.\nThe first row of the matrix $G$ is $[1, 1, 0, 0]$.\n\nRay $2$: Source at $(0.5, -0.2)$ and receiver at $(0.5, 2.2)$.\nThis ray is a vertical straight line segment described by the equation $x=0.5$. We consider its intersection with the domain $D$, which is the segment for $y \\in [0,2]$.\n-   Intersection with $C_{1}$: The ray at $x=0.5$ is within the $x$-range $[0,1]$ of $C_{1}$. It traverses this cell from $y=0$ to $y=1$. The path length is $G_{21} = 1-0 = 1$.\n-   Intersection with $C_{3}$: The ray at $x=0.5$ is within the $x$-range $[0,1]$ of $C_{3}$. It traverses this cell from $y=1$ to $y=2$. The path length is $G_{23} = 2-1 = 1$.\n-   Intersection with $C_{2}$ and $C_{4}$: The ray at $x=0.5$ is outside the $x$-range $[1,2]$ of these cells. Thus, the path lengths are $G_{22} = 0$ and $G_{24} = 0$.\nThe second row of the matrix $G$ is $[1, 0, 1, 0]$.\n\nRay $3$: Source at $(-0.2, 1.5)$ and receiver at $(2.2, 1.5)$.\nThis ray is a horizontal straight line segment described by the equation $y=1.5$. We consider its intersection with the domain $D$, which is the segment for $x \\in [0,2]$.\n-   Intersection with $C_{3}$: The ray at $y=1.5$ is within the $y$-range $[1,2]$ of $C_{3}$. It traverses this cell from $x=0$ to $x=1$. The path length is $G_{33} = 1-0 = 1$.\n-   Intersection with $C_{4}$: The ray at $y=1.5$ is within the $y$-range $[1,2]$ of $C_{4}$. It traverses this cell from $x=1$ to $x=2$. The path length is $G_{34} = 2-1 = 1$.\n-   Intersection with $C_{1}$ and $C_{2}$: The ray at $y=1.5$ is outside the $y$-range $[0,1]$ of these cells. Thus, the path lengths are $G_{31} = 0$ and $G_{32} = 0$.\nThe third row of the matrix $G$ is $[0, 0, 1, 1]$.\n\nCombining these results, the geometry matrix $G$ is a $3 \\times 4$ matrix with entries in $\\mathrm{km}$:\n$$\nG = \\begin{pmatrix}\n1  1  0  0 \\\\\n1  0  1  0 \\\\\n0  0  1  1\n\\end{pmatrix}\n$$\nNext, we compute the normal matrix $N = G^{T} G$. First, the transpose of $G$ is:\n$$\nG^{T} = \\begin{pmatrix}\n1  1  0 \\\\\n1  0  0 \\\\\n0  1  1 \\\\\n0  0  1\n\\end{pmatrix}\n$$\nNow, we perform the matrix multiplication $N = G^{T} G$:\n$$\nN = \\begin{pmatrix}\n1  1  0 \\\\\n1  0  0 \\\\\n0  1  1 \\\\\n0  0  1\n\\end{pmatrix}\n\\begin{pmatrix}\n1  1  0  0 \\\\\n1  0  1  0 \\\\\n0  0  1  1\n\\end{pmatrix}\n= \\begin{pmatrix}\n(1)(1)+(1)(1)+(0)(0)  (1)(1)+(1)(0)+(0)(0)  (1)(0)+(1)(1)+(0)(1)  (1)(0)+(1)(0)+(0)(1) \\\\\n(1)(1)+(0)(1)+(0)(0)  (1)(1)+(0)(0)+(0)(0)  (1)(0)+(0)(1)+(0)(1)  (1)(0)+(0)(0)+(0)(1) \\\\\n(0)(1)+(1)(1)+(1)(0)  (0)(1)+(1)(0)+(1)(0)  (0)(0)+(1)(1)+(1)(1)  (0)(0)+(1)(0)+(1)(1) \\\\\n(0)(1)+(0)(1)+(1)(0)  (0)(1)+(0)(0)+(1)(0)  (0)(0)+(0)(1)+(1)(1)  (0)(0)+(0)(0)+(1)(1)\n\\end{pmatrix}\n$$\n$$\nN = G^{T} G = \\begin{pmatrix}\n2  1  1  0 \\\\\n1  1  0  0 \\\\\n1  0  2  1 \\\\\n0  0  1  1\n\\end{pmatrix}\n$$\nThe entries of this matrix are in units of $\\mathrm{km}^{2}$.\n\nFinally, we compute the determinant of the $4 \\times 4$ matrix $N = G^{T} G$. We can use cofactor expansion along the fourth row, as it contains two zero entries. The determinant is given by $\\det(N) = \\sum_{j=1}^{4} (-1)^{4+j} N_{4j} M_{4j}$, where $M_{4j}$ is the minor corresponding to the element $N_{4j}$.\n$$\n\\det(N) = 0 \\cdot C_{41} + 0 \\cdot C_{42} + N_{43} C_{43} + N_{44} C_{44}\n$$\nwhere $C_{ij}$ is the cofactor.\nThe relevant cofactors are $C_{43}$ and $C_{44}$:\n$$\nC_{43} = (-1)^{4+3} \\det \\begin{pmatrix}\n2  1  0 \\\\\n1  1  0 \\\\\n1  0  1\n\\end{pmatrix} = (-1) \\left[ 0 - 0 + 1 \\cdot \\det \\begin{pmatrix} 2  1 \\\\ 1  1 \\end{pmatrix} \\right] = (-1)[(2)(1) - (1)(1)] = -1\n$$\n$$\nC_{44} = (-1)^{4+4} \\det \\begin{pmatrix}\n2  1  1 \\\\\n1  1  0 \\\\\n1  0  2\n\\end{pmatrix} = (+1) \\left[ 1 \\cdot \\det \\begin{pmatrix} 1  1 \\\\ 1  0 \\end{pmatrix} - 0 + 2 \\cdot \\det \\begin{pmatrix} 2  1 \\\\ 1  1 \\end{pmatrix} \\right] = [(1)(0)-(1)(1)] + 2[(2)(1)-(1)(1)] = -1 + 2(1) = 1\n$$\nSubstituting these values back into the determinant expression:\n$$\n\\det(N) = (1)(C_{43}) + (1)(C_{44}) = (1)(-1) + (1)(1) = -1 + 1 = 0\n$$\nAn alternative method is to use row reduction.\n$$\n\\det \\begin{pmatrix}\n2  1  1  0 \\\\\n1  1  0  0 \\\\\n1  0  2  1 \\\\\n0  0  1  1\n\\end{pmatrix}\n\\xrightarrow{R_1 \\leftrightarrow R_2}\n-\\det \\begin{pmatrix}\n1  1  0  0 \\\\\n2  1  1  0 \\\\\n1  0  2  1 \\\\\n0  0  1  1\n\\end{pmatrix}\n\\xrightarrow[R_3 \\to R_3-R_1]{R_2 \\to R_2-2R_1}\n-\\det \\begin{pmatrix}\n1  1  0  0 \\\\\n0  -1  1  0 \\\\\n0  -1  2  1 \\\\\n0  0  1  1\n\\end{pmatrix}\n\\xrightarrow{R_3 \\to R_3-R_2}\n-\\det \\begin{pmatrix}\n1  1  0  0 \\\\\n0  -1  1  0 \\\\\n0  0  1  1 \\\\\n0  0  1  1\n\\end{pmatrix}\n$$\nSince two rows are identical (row $3$ and row $4$), the determinant is $0$.\nThe determinant of $G^{T} G$ is $0$. The units of the determinant are $(\\mathrm{km}^{2})^{4} = \\mathrm{km}^{8}$.\nThe value is $0 \\, \\mathrm{km}^{8}$.", "answer": "$$\\boxed{0}$$", "id": "3617796"}, {"introduction": "In practice, tomographic systems are often ill-posed, meaning a unique, stable solution for the model parameters $\\mathbf{m}$ is not guaranteed from the data alone. This exercise ([@problem_id:3617733]) introduces Tikhonov regularization, a fundamental technique for stabilizing the inversion by adding a penalty term that favors simpler models. By analytically working through a regularized least-squares problem, you will quantitatively explore the critical trade-off between model resolution (how detailed a picture we can obtain) and solution variance (how sensitive our result is to noise), a central theme in geophysical inverse theory.", "problem": "In travel-time tomography, the first-order perturbation to travel time along a ray is given by the line integral of slowness perturbation, which under discretization over cells becomes a linear relation $\\mathbf{d} \\approx \\mathbf{G}\\,\\mathbf{m}$, where $\\mathbf{d}$ are dimensionless travel-time residuals, $\\mathbf{m}$ are dimensionless slowness perturbations, and $\\mathbf{G}$ is the dimensionless path-length Jacobian. Consider a two-cell model with two straight rays such that\n$$\n\\mathbf{G} = \\begin{pmatrix} 3  2 \\\\ 1  4 \\end{pmatrix}, \\quad \\mathbf{d} = \\begin{pmatrix} 5 \\\\ 9 \\end{pmatrix}.\n$$\nAssume the data have been whitened so that the data noise covariance is the identity, and Tikhonov damping is applied to the model norm. Derive from first principles the Tikhonov-regularized least-squares estimator $\\widehat{\\mathbf{m}}(\\lambda)$ as the minimizer of the objective $J(\\mathbf{m}) = \\|\\mathbf{G}\\mathbf{m} - \\mathbf{d}\\|_{2}^{2} + \\lambda^{2} \\|\\mathbf{m}\\|_{2}^{2}$, where $\\lambda$ is a dimensionless damping parameter. Evaluate $\\widehat{\\mathbf{m}}(\\lambda)$ for the specific values $\\lambda = 0$, $\\lambda = 1$, and $\\lambda = 3$.\n\nDefine and derive the model resolution matrix $\\mathbf{R}(\\lambda)$ and the posterior model covariance $\\mathbf{C}_{m}(\\lambda)$ under the assumption of identity data covariance, expressing both analytically in terms of $\\lambda$. Using these expressions, provide an analytical comparison between resolution and variance as functions of $\\lambda$.\n\nFinally, determine the value of the damping parameter $\\lambda$ such that the trace of the resolution matrix satisfies $\\mathrm{tr}(\\mathbf{R}(\\lambda)) = 1.5$. Round your answer to four significant figures. Express the final value of $\\lambda$ in dimensionless units.", "solution": "The problem is valid as it is scientifically grounded in the principles of geophysical inverse theory, specifically Tikhonov regularization. It is well-posed, with all necessary data provided, and is free of contradictions or vagueness.\n\nFirst, we derive the Tikhonov-regularized least-squares estimator $\\widehat{\\mathbf{m}}(\\lambda)$ by minimizing the objective function $J(\\mathbf{m})$. The objective function is given as:\n$$J(\\mathbf{m}) = \\|\\mathbf{G}\\mathbf{m} - \\mathbf{d}\\|_{2}^{2} + \\lambda^{2} \\|\\mathbf{m}\\|_{2}^{2}$$\nIn matrix notation, this is:\n$$J(\\mathbf{m}) = (\\mathbf{G}\\mathbf{m} - \\mathbf{d})^T (\\mathbf{G}\\mathbf{m} - \\mathbf{d}) + \\lambda^{2} \\mathbf{m}^T \\mathbf{m}$$\nExpanding the expression:\n$$J(\\mathbf{m}) = \\mathbf{m}^T \\mathbf{G}^T \\mathbf{G}\\mathbf{m} - \\mathbf{m}^T \\mathbf{G}^T \\mathbf{d} - \\mathbf{d}^T \\mathbf{G}\\mathbf{m} + \\mathbf{d}^T \\mathbf{d} + \\lambda^{2} \\mathbf{m}^T \\mathbf{m}$$\nSince the scalar term $\\mathbf{d}^T \\mathbf{G}\\mathbfm$ is equal to its transpose $\\mathbf{m}^T \\mathbf{G}^T \\mathbf{d}$, we can combine terms:\n$$J(\\mathbf{m}) = \\mathbf{m}^T (\\mathbf{G}^T \\mathbf{G} + \\lambda^2 \\mathbf{I}) \\mathbf{m} - 2 \\mathbf{m}^T \\mathbf{G}^T \\mathbf{d} + \\mathbf{d}^T \\mathbf{d}$$\nTo find the model vector $\\mathbf{m}$ that minimizes $J(\\mathbf{m})$, we compute the gradient of $J$ with respect to $\\mathbf{m}$ and set it to the zero vector.\n$$\\nabla_{\\mathbf{m}} J(\\mathbf{m}) = 2(\\mathbf{G}^T \\mathbf{G} + \\lambda^2 \\mathbf{I})\\mathbf{m} - 2\\mathbf{G}^T \\mathbf{d}$$\nSetting the gradient to zero yields the normal equations for the estimator $\\widehat{\\mathbf{m}}$:\n$$2(\\mathbf{G}^T \\mathbf{G} + \\lambda^2 \\mathbf{I})\\widehat{\\mathbf{m}} - 2\\mathbf{G}^T \\mathbf{d} = 0$$\n$$(\\mathbf{G}^T \\mathbf{G} + \\lambda^2 \\mathbf{I})\\widehat{\\mathbf{m}} = \\mathbf{G}^T \\mathbf{d}$$\nSolving for $\\widehat{\\mathbf{m}}$ gives the Tikhonov-regularized estimator:\n$$\\widehat{\\mathbf{m}}(\\lambda) = (\\mathbf{G}^T \\mathbf{G} + \\lambda^2 \\mathbf{I})^{-1} \\mathbf{G}^T \\mathbf{d}$$\nNext, we evaluate this estimator for the given matrices and specific values of $\\lambda$. The given matrices are:\n$$\\mathbf{G} = \\begin{pmatrix} 3  2 \\\\ 1  4 \\end{pmatrix}, \\quad \\mathbf{d} = \\begin{pmatrix} 5 \\\\ 9 \\end{pmatrix}$$\nWe compute the required matrix products:\n$$\\mathbf{G}^T = \\begin{pmatrix} 3  1 \\\\ 2  4 \\end{pmatrix}$$\n$$\\mathbf{G}^T \\mathbf{G} = \\begin{pmatrix} 3  1 \\\\ 2  4 \\end{pmatrix} \\begin{pmatrix} 3  2 \\\\ 1  4 \\end{pmatrix} = \\begin{pmatrix} 10  10 \\\\ 10  20 \\end{pmatrix}$$\n$$\\mathbf{G}^T \\mathbf{d} = \\begin{pmatrix} 3  1 \\\\ 2  4 \\end{pmatrix} \\begin{pmatrix} 5 \\\\ 9 \\end{pmatrix} = \\begin{pmatrix} 24 \\\\ 46 \\end{pmatrix}$$\nThe term $(\\mathbf{G}^T \\mathbf{G} + \\lambda^2 \\mathbf{I})$ is:\n$$\\mathbf{G}^T \\mathbf{G} + \\lambda^2 \\mathbf{I} = \\begin{pmatrix} 10+\\lambda^2  10 \\\\ 10  20+\\lambda^2 \\end{pmatrix}$$\nThe determinant of this matrix is $\\det(\\mathbf{G}^T \\mathbf{G} + \\lambda^2 \\mathbf{I}) = (10+\\lambda^2)(20+\\lambda^2) - 100 = \\lambda^4 + 30\\lambda^2 + 100$.\nThe inverse is:\n$$(\\mathbf{G}^T \\mathbf{G} + \\lambda^2 \\mathbf{I})^{-1} = \\frac{1}{\\lambda^4 + 30\\lambda^2 + 100} \\begin{pmatrix} 20+\\lambda^2  -10 \\\\ -10  10+\\lambda^2 \\end{pmatrix}$$\nThus, the estimator is:\n$$\\widehat{\\mathbf{m}}(\\lambda) = \\frac{1}{\\lambda^4 + 30\\lambda^2 + 100} \\beginpmatrix} 20+\\lambda^2  -10 \\\\ -10  10+\\lambda^2 \\end{pmatrix} \\begin{pmatrix} 24 \\\\ 46 \\end{pmatrix} = \\frac{1}{\\lambda^4 + 30\\lambda^2 + 100} \\begin{pmatrix} 20 + 24\\lambda^2 \\\\ 220 + 46\\lambda^2 \\end{pmatrix}$$\nFor $\\lambda=0$:\n$\\widehat{\\mathbf{m}}(0) = \\frac{1}{100} \\begin{pmatrix} 20 \\\\ 220 \\end{pmatrix} = \\begin{pmatrix} 1/5 \\\\ 11/5 \\end{pmatrix}$.\nFor $\\lambda=1$:\n$\\widehat{\\mathbf{m}}(1) = \\frac{1}{1^4 + 30(1)^2 + 100} \\begin{pmatrix} 20 + 24(1)^2 \\\\ 220 + 46(1)^2 \\end{pmatrix} = \\frac{1}{131} \\begin{pmatrix} 44 \\\\ 266 \\end{pmatrix}$.\nFor $\\lambda=3$:\n$\\widehat{\\mathbf{m}}(3) = \\frac{1}{3^4 + 30(3)^2 + 100} \\begin{pmatrix} 20 + 24(3)^2 \\\\ 220 + 46(3)^2 \\end{pmatrix} = \\frac{1}{81 + 270 + 100} \\begin{pmatrix} 20 + 216 \\\\ 220 + 414 \\end{pmatrix} = \\frac{1}{451} \\begin{pmatrix} 236 \\\\ 634 \\end{pmatrix}$.\n\nThe model resolution matrix $\\mathbf{R}(\\lambda)$ relates the estimated model to the true model $\\mathbf{m}_{\\text{true}}$. The data are $\\mathbf{d} = \\mathbf{G}\\mathbf{m}_{\\text{true}} + \\mathbf{n}$, where $\\mathbf{n}$ is data noise. Substituting this into the estimator equation gives:\n$$\\widehat{\\mathbf{m}} = (\\mathbf{G}^T \\mathbf{G} + \\lambda^2 \\mathbf{I})^{-1} \\mathbf{G}^T (\\mathbf{G}\\mathbf{m}_{\\text{true}} + \\mathbf{n}) = [(\\mathbf{G}^T \\mathbf{G} + \\lambda^2 \\mathbf{I})^{-1} \\mathbf{G}^T \\mathbf{G}] \\mathbf{m}_{\\text{true}} + \\dots$$\nThe resolution matrix is the term that premultiplies $\\mathbf{m}_{\\text{true}}$:\n$$\\mathbf{R}(\\lambda) = (\\mathbf{G}^T \\mathbf{G} + \\lambda^2 \\mathbf{I})^{-1} \\mathbf{G}^T \\mathbf{G}$$\nThe posterior model covariance $\\mathbf{C}_{m}(\\lambda)$ describes the propagation of data noise into the model estimate. Assuming data covariance $\\mathbf{C}_d = \\mathbf{I}$, the covariance of the estimator is:\n$$\\mathbf{C}_{m}(\\lambda) = \\mathbb{E}[(\\widehat{\\mathbf{m}} - \\mathbb{E}[\\widehat{\\mathbf{m}}])(\\widehat{\\mathbf{m}} - \\mathbb{E}[\\widehat{\\mathbf{m}}])^T] = [(\\mathbf{G}^T \\mathbf{G} + \\lambda^2 \\mathbf{I})^{-1} \\mathbf{G}^T] \\mathbf{C}_d [(\\mathbf{G}^T \\mathbf{G} + \\lambda^2 \\mathbf{I})^{-1} \\mathbf{G}^T]^T$$\n$$\\mathbf{C}_{m}(\\lambda) = (\\mathbf{G}^T \\mathbf{G} + \\lambda^2 \\mathbf{I})^{-1} \\mathbf{G}^T \\mathbf{G} (\\mathbf{G}^T \\mathbf{G} + \\lambda^2 \\mathbf{I})^{-1}$$\nFor $\\lambda \\to 0$, $\\mathbf{R}(\\lambda) \\to \\mathbf{I}$ (perfect resolution), and $\\mathbf{C}_m(\\lambda) \\to (\\mathbf{G}^T\\mathbf{G})^{-1}$ (maximum variance). For $\\lambda \\to \\infty$, $\\mathbf{R}(\\lambda) \\to \\mathbf{0}$ (no resolution), and $\\mathbf{C}_m(\\lambda) \\to \\mathbf{0}$ (zero variance). This demonstrates the classic trade-off: increasing $\\lambda$ decreases model variance at the expense of resolution.\n\nFinally, we determine $\\lambda$ such that $\\mathrm{tr}(\\mathbf{R}(\\lambda)) = 1.5$. First, we compute the analytical expression for $\\mathbf{R}(\\lambda)$:\n$$\\mathbf{R}(\\lambda) = \\frac{1}{\\lambda^4 + 30\\lambda^2 + 100} \\begin{pmatrix} 20+\\lambda^2  -10 \\\\ -10  10+\\lambda^2 \\end{pmatrix} \\begin{pmatrix} 10  10 \\\\ 10  20 \\end{pmatrix}$$\n$$\\mathbf{R}(\\lambda) = \\frac{1}{\\lambda^4 + 30\\lambda^2 + 100} \\begin{pmatrix} 100 + 10\\lambda^2  10\\lambda^2 \\\\ 10\\lambda^2  100 + 20\\lambda^2 \\end{pmatrix}$$\nThe trace is the sum of the diagonal elements:\n$$\\mathrm{tr}(\\mathbf{R}(\\lambda)) = \\frac{(100 + 10\\lambda^2) + (100 + 20\\lambda^2)}{\\lambda^4 + 30\\lambda^2 + 100} = \\frac{200 + 30\\lambda^2}{\\lambda^4 + 30\\lambda^2 + 100}$$\nWe set this equal to $1.5$ (which is $3/2$):\n$$\\frac{200 + 30\\lambda^2}{\\lambda^4 + 30\\lambda^2 + 100} = \\frac{3}{2}$$\n$$2(200 + 30\\lambda^2) = 3(\\lambda^4 + 30\\lambda^2 + 100)$$\n$$400 + 60\\lambda^2 = 3\\lambda^4 + 90\\lambda^2 + 300$$\n$$3\\lambda^4 + 30\\lambda^2 - 100 = 0$$\nLet $x = \\lambda^2$. The equation is a quadratic in $x$: $3x^2 + 30x - 100 = 0$. Using the quadratic formula:\n$$x = \\frac{-30 \\pm \\sqrt{30^2 - 4(3)(-100)}}{2(3)} = \\frac{-30 \\pm \\sqrt{900 + 1200}}{6} = \\frac{-30 \\pm \\sqrt{2100}}{6}$$\nSince $\\lambda$ is a real parameter, $\\lambda^2 = x$ must be non-negative. We take the positive root:\n$$\\lambda^2 = \\frac{-30 + \\sqrt{2100}}{6} = \\frac{-15 + 5\\sqrt{21}}{3}$$\nThe value of $\\lambda$ is the square root of this quantity.\n$$\\lambda = \\sqrt{\\frac{-15 + 5\\sqrt{21}}{3}}$$\nNumerically, $\\sqrt{21} \\approx 4.582576$.\n$$\\lambda^2 \\approx \\frac{-15 + 5(4.582576)}{3} \\approx \\frac{7.91288}{3} \\approx 2.637626$$\n$$\\lambda \\approx \\sqrt{2.637626} \\approx 1.624077$$\nRounding to four significant figures, we get $\\lambda \\approx 1.624$. This value is dimensionless as specified.", "answer": "$$\\boxed{1.624}$$", "id": "3617733"}, {"introduction": "Our previous examples assumed that ray paths are straight lines, but in reality, seismic waves bend according to Snell's Law as they travel through regions of varying velocity. This dependency of the ray path on the unknown velocity model makes the tomographic problem non-linear. This advanced, hands-on coding practice ([@problem_id:3617783]) guides you through implementing the Gauss-Newton method, an iterative algorithm that solves non-linear problems by successively refining a linear approximation. By building a simple inversion for a two-layer refraction model, you will tackle the challenge of ray bending and take a significant step from idealized linear theory toward more realistic geophysical imaging.", "problem": "You are tasked with implementing two Gauss–Newton iterations for estimating a slowness contrast in a two-layer refraction setting used in travel-time tomography applications. The physical setting is a horizontally layered medium with a single planar interface at depth $h$, with the top layer having slowness $s_1$ and the bottom layer having slowness $s_2$. Slowness is the reciprocal of velocity and is measured in seconds per meter (s/m). Rays propagate piecewise linearly in each homogeneous layer and refract at the interface according to Snell's law. All sources are located in the upper layer ($z_s  h$) and all receivers are located in the lower layer ($z_r  h$), ensuring a single refraction at the interface. The program will start from a homogeneous initial model with $s_2^{(0)} = s_1$ and estimate the slowness contrast $\\delta s = s_2 - s_1$ by performing two Gauss–Newton iterations. Angles appearing in the derivation are to be interpreted in radians.\n\nFundamental base:\n- Fermat’s principle: travel times follow paths that make travel time stationary.\n- Snell’s law at a planar interface: horizontal slowness is conserved, expressed as $s_1 \\sin \\theta_1 = s_2 \\sin \\theta_2$, where $\\theta_i$ is the angle to the interface normal in layer $i$.\n- For a fixed ray path in homogeneous layers, the travel time is a sum of slowness times segment lengths, $T = s_1 L_1 + s_2 L_2$, where $L_1$ and $L_2$ are the path lengths in the top and bottom layers, respectively.\n\nProblem formulation:\n1. Geometry and path parameterization:\n   - Let the interface be the horizontal line $z = h$.\n   - For a source at $(x_s, z_s)$ with $z_s  h$ and a receiver at $(x_r, z_r)$ with $z_r  h$, the physically admissible bent ray consists of two straight segments: from source to an interface crossing point $(x^\\star, h)$ in the top layer and from $(x^\\star, h)$ to the receiver in the bottom layer.\n   - The interface crossing point $x^\\star$ satisfies the Snell condition expressed in geometric form:\n     $$ s_1 \\frac{x^\\star - x_s}{\\sqrt{(x^\\star - x_s)^2 + (h - z_s)^2}} = s_2 \\frac{x_r - x^\\star}{\\sqrt{(x_r - x^\\star)^2 + (z_r - h)^2}}. $$\n   - For a given $s_1$ and $s_2$, the ray segment lengths are\n     $$ L_1 = \\sqrt{(x^\\star - x_s)^2 + (h - z_s)^2}, \\quad L_2 = \\sqrt{(x_r - x^\\star)^2 + (z_r - h)^2}. $$\n   - The travel time is $T(s_2) = s_1 L_1(s_2) + s_2 L_2(s_2)$, where $L_1$ and $L_2$ depend on $s_2$ via $x^\\star$.\n\n2. Gauss–Newton update:\n   - Assume the top-layer slowness $s_1$ is known and fixed (equal to the homogeneous initial slowness).\n   - Let $T_i^{\\text{obs}}$ denote the observed travel time for ray $i$, generated by ground-truth slowness $s_2^{\\text{true}}$ using the physically correct bent ray. Let $T_i^{(k)}$ denote the predicted travel time at iteration $k$, computed using the bent ray geometry corresponding to the current estimate $s_2^{(k)}$.\n   - Linearize the travel time around the current ray paths by treating the segment lengths as fixed with respect to $s_2$ during each iteration (path recalculation is performed between iterations). The Jacobian entry for ray $i$ is $J_i^{(k)} = \\partial T_i / \\partial s_2 \\approx L_{2,i}^{(k)}$, where $L_{2,i}^{(k)}$ is the bottom-layer path length evaluated at $s_2^{(k)}$.\n   - Let the residual be $r_i^{(k)} = T_i^{(k)} - T_i^{\\text{obs}}$. The Gauss–Newton update for the single unknown $s_2$ is\n     $$ \\Delta s_2^{(k)} = -\\frac{\\sum_i J_i^{(k)} r_i^{(k)}}{\\sum_i \\left(J_i^{(k)}\\right)^2}, \\quad s_2^{(k+1)} = s_2^{(k)} + \\Delta s_2^{(k)}. $$\n   - Perform two iterations starting from $s_2^{(0)} = s_1$ and report the final estimate of the slowness contrast $\\delta s^{(2)} = s_2^{(2)} - s_1$.\n\nUnits:\n- Distances in meters (m).\n- Slowness in seconds per meter (s/m).\n- Travel times in seconds (s).\n- Angles in radians.\n\nInput data (embedded in the program) and test suite:\nEach test case defines the geometry and the ground truth bottom-layer slowness. For each test case, use the provided set of source–receiver pairs to generate observed travel times with the ground-truth $s_2^{\\text{true}}$. Then apply two Gauss–Newton iterations as specified above to estimate $\\delta s$.\n\nTest Case 1 (general “happy path”):\n- Initial homogeneous velocity $v_0 = 2000$ meters per second.\n- Top-layer slowness $s_1 = 1 / v_0$.\n- Interface depth $h = 500$ meters.\n- Horizontal separation $x_r - x_s = 1000$ meters with $x_s = 0$, $x_r = 1000$.\n- Ground-truth bottom-layer velocity $v_2^{\\text{true}} = 3000$ meters per second, so $s_2^{\\text{true}} = 1 / v_2^{\\text{true}}$.\n- Source–receiver pairs:\n  - $(x_s, z_s) = (0, 100)$, $(x_r, z_r) = (1000, 600)$\n  - $(x_s, z_s) = (0, 300)$, $(x_r, z_r) = (1000, 800)$\n  - $(x_s, z_s) = (0, 450)$, $(x_r, z_r) = (1000, 1000)$\n  - $(x_s, z_s) = (0, 100)$, $(x_r, z_r) = (1000, 1000)$\n\nTest Case 2 (near-equal velocities boundary condition):\n- Initial homogeneous velocity $v_0 = 2500$ meters per second.\n- Top-layer slowness $s_1 = 1 / v_0$.\n- Interface depth $h = 300$ meters.\n- Horizontal separation $x_r - x_s = 500$ meters with $x_s = 0$, $x_r = 500$.\n- Ground-truth bottom-layer velocity $v_2^{\\text{true}} = 2600$ meters per second, so $s_2^{\\text{true}} = 1 / v_2^{\\text{true}}$.\n- Source–receiver pairs:\n  - $(x_s, z_s) = (0, 50)$, $(x_r, z_r) = (500, 400)$\n  - $(x_s, z_s) = (0, 100)$, $(x_r, z_r) = (500, 550)$\n  - $(x_s, z_s) = (0, 200)$, $(x_r, z_r) = (500, 600)$\n\nTest Case 3 (high-contrast edge case):\n- Initial homogeneous velocity $v_0 = 1800$ meters per second.\n- Top-layer slowness $s_1 = 1 / v_0$.\n- Interface depth $h = 400$ meters.\n- Horizontal separation $x_r - x_s = 800$ meters with $x_s = 0$, $x_r = 800$.\n- Ground-truth bottom-layer velocity $v_2^{\\text{true}} = 6000$ meters per second, so $s_2^{\\text{true}} = 1 / v_2^{\\text{true}}$.\n- Source–receiver pairs:\n  - $(x_s, z_s) = (0, 390)$, $(x_r, z_r) = (800, 600)$\n  - $(x_s, z_s) = (0, 100)$, $(x_r, z_r) = (800, 700)$\n  - $(x_s, z_s) = (0, 10)$, $(x_r, z_r) = (800, 900)$\n\nOutput specification:\n- Your program should compute the estimated slowness contrast $\\delta s^{(2)} = s_2^{(2)} - s_1$ after two Gauss–Newton iterations for each test case, expressed in seconds per meter (s/m).\n- Your program should produce a single line of output containing the three results as a comma-separated list enclosed in square brackets, in the order of Test Case 1, Test Case 2, and Test Case 3. For example: \"[result_case1,result_case2,result_case3]\".", "solution": "The problem requires the implementation of a geophysical inversion algorithm to estimate the slowness of a subterranean layer. The inversion is based on the Gauss–Newton method, utilizing travel-time data from seismic rays that propagate through a two-layer medium. The process involves two main components: a forward model to predict travel times for a given medium, and an inverse algorithm to update the medium's properties to better match observed travel times.\n\nThe validation of the problem statement confirms that it is scientifically sound, well-posed, and provides all necessary information to construct a unique and verifiable solution. The physical principles of ray propagation, Snell's law, and the mathematical framework of Gauss–Newton optimization are standard and correctly formulated for this application in travel-time tomography.\n\n**Part 1: The Forward Problem — Ray Tracing and Travel-Time Calculation**\n\nThe forward problem consists of calculating the total travel time of a seismic ray from a source to a receiver for a given velocity (or slowness) model. The model is defined by two layers with slownesses $s_1$ and $s_2$, separated by a horizontal interface at depth $z=h$. The source is at $(x_s, z_s)$ with $z_s  h$, and the receiver is at $(x_r, z_r)$ with $z_r  h$.\n\nAccording to Fermat's principle, the ray follows a path of stationary travel time. For a piecewise homogeneous medium, this path consists of straight line segments in each layer, with refraction occurring at the interface. The point of refraction on the interface, $(x^\\star, h)$, is determined by Snell's law, which states that the horizontal component of the slowness vector is conserved across the interface. Geometrically, this is expressed as:\n$$ s_1 \\sin\\theta_1 = s_2 \\sin\\theta_2 $$\nwhere $\\theta_1$ and $\\theta_2$ are the angles the ray makes with the normal to the interface in layer $1$ and layer $2$, respectively.\n\nExpressing the sines of the angles in terms of the geometry of the ray path yields the equation for the unknown crossing point $x^\\star$:\n$$ s_1 \\frac{x^\\star - x_s}{\\sqrt{(x^\\star - x_s)^2 + (h - z_s)^2}} = s_2 \\frac{x_r - x^\\star}{\\sqrt{(x_r - x^\\star)^2 + (z_r - h)^2}} $$\nLet $L_1(x^\\star)$ and $L_2(x^\\star)$ be the path lengths in the top and bottom layers, respectively. The equation can be written as a function of $x^\\star$ whose root we must find:\n$$ f(x^\\star; s_1, s_2) = s_1 \\frac{x^\\star - x_s}{L_1(x^\\star)} - s_2 \\frac{x_r - x^\\star}{L_2(x^\\star)} = 0 $$\nThis is a non-linear equation in $x^\\star$. For a physically realistic path, $x^\\star$ must lie between $x_s$ and $x_r$. We can solve for $x^\\star$ numerically using a root-finding algorithm, such as the bisection or Brent's method, within the interval $(x_s, x_r)$.\n\nOnce $x^\\star$ is determined for a given pair of slownesses $(s_1, s_2)$, the segment lengths $L_1$ and $L_2$ are calculated, and the total travel time $T$ is computed as the sum of the times spent in each layer:\n$$ T(s_1, s_2) = s_1 L_1(x^\\star) + s_2 L_2(x^\\star) $$\n\n**Part 2: The Inverse Problem — Gauss–Newton Inversion**\n\nThe inverse problem aims to find the unknown model parameter, $s_2$, given a set of observed travel times, $T_i^{\\text{obs}}$, for multiple source-receiver pairs (rays) $i=1, \\dots, N$. The top layer slowness $s_1$ is assumed to be known. This is a non-linear least-squares problem where we seek to minimize the objective function $\\Phi(s_2)$:\n$$ \\Phi(s_2) = \\sum_{i=1}^{N} \\left( T_i(s_2) - T_i^{\\text{obs}} \\right)^2 $$\nThe Gauss–Newton method is an iterative procedure for solving such problems. Starting from an initial guess $s_2^{(0)}$, it generates a sequence of estimates $s_2^{(k)}$ that progressively converge towards the solution.\n\nAt each iteration $k$, the travel time function $T_i(s_2)$ is linearized around the current estimate $s_2^{(k)}$:\n$$ T_i(s_2) \\approx T_i(s_2^{(k)}) + J_i^{(k)} (s_2 - s_2^{(k)}) $$\nwhere $J_i^{(k)}$ is the Jacobian (the partial derivative of $T_i$ with respect to $s_2$), evaluated at $s_2^{(k)}$. The problem specifies a key simplification based on Fermat's principle, which states that the travel time is stationary with respect to path perturbations. This allows us to approximate the derivative by ignoring the dependence of the path lengths on $s_2$:\n$$ J_i^{(k)} = \\frac{\\partial T_i}{\\partial s_2} \\bigg|_{s_2=s_2^{(k)}} = \\frac{\\partial}{\\partial s_2} (s_1 L_{1,i} + s_2 L_{2,i}) \\bigg|_{s_2=s_2^{(k)}} \\approx L_{2,i}^{(k)} $$\nHere, $L_{2,i}^{(k)}$ is the path length in the second layer for ray $i$, computed using the ray path corresponding to the slowness estimate $s_2^{(k)}$.\n\nLet the model update be $\\Delta s_2^{(k)} = s_2 - s_2^{(k)}$ and the travel-time residual be $r_i^{(k)} = T_i(s_2^{(k)}) - T_i^{\\text{obs}}$. Substituting the linearization into the objective function, we want to minimize:\n$$ \\Phi(\\Delta s_2^{(k)}) = \\sum_{i=1}^{N} \\left( J_i^{(k)} \\Delta s_2^{(k)} + r_i^{(k)} \\right)^2 $$\nTo find the minimum, we differentiate with respect to $\\Delta s_2^{(k)}$ and set the result to zero:\n$$ \\frac{d\\Phi}{d(\\Delta s_2^{(k)})} = 2 \\sum_{i=1}^{N} J_i^{(k)} \\left( J_i^{(k)} \\Delta s_2^{(k)} + r_i^{(k)} \\right) = 0 $$\nSolving for the update $\\Delta s_2^{(k)}$ gives the standard Gauss–Newton update formula for a single parameter:\n$$ \\Delta s_2^{(k)} = - \\frac{\\sum_{i=1}^{N} J_i^{(k)} r_i^{(k)}}{\\sum_{i=1}^{N} \\left(J_i^{(k)}\\right)^2} $$\nThe next slowness estimate is then obtained by:\n$$ s_2^{(k+1)} = s_2^{(k)} + \\Delta s_2^{(k)} $$\n\n**Part 3: Algorithmic Implementation**\n\nThe overall algorithm proceeds as follows for each test case:\n$1$. **Initialization**: Define the fixed parameters: $s_1$, $h$, and the set of source-receiver pairs. The ground-truth slowness $s_2^{\\text{true}}$ is also defined.\n$2$. **Data Generation**: For each source-receiver pair $i$, compute the \"observed\" travel time $T_i^{\\text{obs}}$ by solving the forward problem with slownesses $(s_1, s_2^{\\text{true}})$. This involves finding the correct ray path by solving for $x_i^\\star$ and then calculating $T_i$.\n$3$. **Iterative Inversion**:\n    a. Start with the initial model $s_2^{(0)} = s_1$.\n    b. Perform two iterations ($k=0$ and $k=1$). In each iteration:\n        i. Initialize sums for the numerator and denominator of the update formula: $\\sum J r = 0$ and $\\sum J^2 = 0$.\n        ii. For each ray $i=1, \\dots, N$:\n            - Solve the forward problem using the current slowness estimate $(s_1, s_2^{(k)})$. This yields the predicted travel time $T_i^{(k)}$ and the Jacobian component $J_i^{(k)} = L_{2,i}^{(k)}$.\n            - Compute the residual $r_i^{(k)} = T_i^{(k)} - T_i^{\\text{obs}}$.\n            - Update the sums: $\\sum J r \\leftarrow \\sum J r + J_i^{(k)} r_i^{(k)}$ and $\\sum J^2 \\leftarrow \\sum J^2 + (J_i^{(k)})^2$.\n        iii. Calculate the slowness update $\\Delta s_2^{(k)} = -(\\sum J r) / (\\sum J^2)$.\n        iv. Update the slowness estimate: $s_2^{(k+1)} = s_2^{(k)} + \\Delta s_2^{(k)}$.\n$4$. **Final Result**: After two iterations, compute the final estimated slowness contrast $\\delta s^{(2)} = s_2^{(2)} - s_1$.\n\nThis procedure is applied to each of the three test cases provided in the problem statement to obtain the required results.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Main function to run the Gauss-Newton tomography inversion for all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"v0\": 2000.0,\n            \"h\": 500.0,\n            \"v2_true\": 3000.0,\n            \"pairs\": [\n                ((0, 100), (1000, 600)),\n                ((0, 300), (1000, 800)),\n                ((0, 450), (1000, 1000)),\n                ((0, 100), (1000, 1000)),\n            ],\n        },\n        {\n            \"v0\": 2500.0,\n            \"h\": 300.0,\n            \"v2_true\": 2600.0,\n            \"pairs\": [\n                ((0, 50), (500, 400)),\n                ((0, 100), (500, 550)),\n                ((0, 200), (500, 600)),\n            ],\n        },\n        {\n            \"v0\": 1800.0,\n            \"h\": 400.0,\n            \"v2_true\": 6000.0,\n            \"pairs\": [\n                ((0, 390), (800, 600)),\n                ((0, 100), (800, 700)),\n                ((0, 10), (800, 900)),\n            ],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_inversion_case(case)\n        results.append(f\"{result:.10e}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef _snell_function(x_star, s1, s2, xs, zs, xr, zr, h):\n    \"\"\"\n    The function f(x_star) = 0 that represents Snell's law geometrically.\n    The root of this function provides the interface crossing point.\n    \"\"\"\n    delta_z1 = h - zs\n    delta_z2 = zr - h\n    \n    term1_num = x_star - xs\n    term1_den = np.sqrt(term1_num**2 + delta_z1**2)\n    \n    term2_num = xr - x_star\n    term2_den = np.sqrt(term2_num**2 + delta_z2**2)\n    \n    # Avoid division by zero if x_star is exactly xs or xr\n    if term1_den == 0: term1 = 0\n    else: term1 = s1 * term1_num / term1_den\n    \n    if term2_den == 0: term2 = 0\n    else: term2 = s2 * term2_num / term2_den\n\n    return term1 - term2\n\ndef _find_x_star(s1, s2, xs, zs, xr, zr, h):\n    \"\"\"\n    Numerically solves for the interface crossing point x_star using Brent's method.\n    \"\"\"\n    # The crossing point must be between the source and receiver x-coordinates.\n    # A small buffer is added to avoid issues at the boundaries.\n    a = xs + 1e-9\n    b = xr - 1e-9\n    \n    try:\n        x_star = brentq(_snell_function, a, b, args=(s1, s2, xs, zs, xr, zr, h))\n    except ValueError:\n        # Should not happen for the given test cases, but good practice.\n        # This could occur if the function has the same sign at both ends of the interval.\n        return (xs + xr) / 2.0\n        \n    return x_star\n\ndef calculate_forward(s1, s2, source, receiver, h):\n    \"\"\"\n    Performs the forward calculation: finds the ray path and computes travel time.\n    Returns:\n        T (float): The total travel time.\n        L2 (float): The path length in the second layer (our Jacobian).\n    \"\"\"\n    xs, zs = source\n    xr, zr = receiver\n    \n    x_star = _find_x_star(s1, s2, xs, zs, xr, zr, h)\n    \n    l1 = np.sqrt((x_star - xs)**2 + (h - zs)**2)\n    l2 = np.sqrt((xr - x_star)**2 + (zr - h)**2)\n    \n    travel_time = s1 * l1 + s2 * l2\n    \n    return travel_time, l2\n    \ndef run_inversion_case(case_data):\n    \"\"\"\n    Runs the two-iteration Gauss-Newton inversion for a single test case.\n    \"\"\"\n    v0 = case_data[\"v0\"]\n    h = case_data[\"h\"]\n    v2_true = case_data[\"v2_true\"]\n    pairs = case_data[\"pairs\"]\n    \n    s1 = 1.0 / v0\n    s2_true = 1.0 / v2_true\n    \n    # 1. Generate \"observed\" data using the true model\n    observed_times = []\n    for source, receiver in pairs:\n        t_obs, _ = calculate_forward(s1, s2_true, source, receiver, h)\n        observed_times.append(t_obs)\n        \n    # 2. Perform two Gauss-Newton iterations\n    s2_k = s1  # Initial guess s2^(0) = s1\n    \n    for _ in range(2): # k = 0, 1\n        sum_Jr = 0.0\n        sum_JJ = 0.0\n        \n        for i, (source, receiver) in enumerate(pairs):\n            # Calculate predicted time and Jacobian for the current model s2_k\n            t_pred, jacobian_L2 = calculate_forward(s1, s2_k, source, receiver, h)\n            \n            # Get the corresponding observed time\n            t_obs = observed_times[i]\n            \n            # Calculate residual\n            residual = t_pred - t_obs\n            \n            # Accumulate sums for the normal equation\n            sum_Jr += jacobian_L2 * residual\n            sum_JJ += jacobian_L2**2\n            \n        # Calculate the model update\n        if sum_JJ == 0:\n            delta_s2 = 0.0 # Avoid division by zero\n        else:\n            delta_s2 = -sum_Jr / sum_JJ\n        \n        # Update the model\n        s2_k = s2_k + delta_s2\n        \n    # Final estimate after two iterations is s2_k (which is s2^(2))\n    s2_final = s2_k\n    \n    # 3. Calculate the final slowness contrast\n    delta_s_final = s2_final - s1\n    \n    return delta_s_final\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3617783"}]}