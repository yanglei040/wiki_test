{"hands_on_practices": [{"introduction": "Grid-based solvers are workhorses in computational seismology for calculating first-arrival travel times. This exercise challenges you to implement and contrast two foundational algorithms: a graph-theory approach using Dijkstra's algorithm and a finite-difference approach with the Fast Marching Method (FMM). By quantifying the numerical anisotropy of each method, you will gain critical insight into how the choice of discretization impacts the accuracy and physical fidelity of solutions to the eikonal equation [@problem_id:3614039].", "problem": "Let a two-dimensional Cartesian grid of size $N \\times N$ with spatial step $h$ (in meters) and a uniform slowness field $s(\\mathbf{x}) \\equiv s_0$ (in seconds per meter) be given. The point-source is at the grid center. The first-arrival travel time field $T(\\mathbf{x})$ for seismic rays in a smoothly varying, isotropic medium is governed by the eikonal equation $|\\nabla T(\\mathbf{x})| = s(\\mathbf{x})$. In computational geophysics, two widely used numerical approaches are:\n\n1. A graph-based shortest path using Dijkstra's algorithm on a grid graph, where edges connect grid neighbors and each edge cost equals the path integral of slowness along that edge.\n2. The Fast Marching Method (FMM), which is a monotone, upwind finite-difference solver for the eikonal equation.\n\nYour task is to implement both methods for a uniform $s(\\mathbf{x}) = s_0$ and quantify the directional bias introduced by each numerical stencil. Start from fundamental principles: Fermat's principle states that seismic rays follow paths of stationary travel time, and the eikonal equation is the high-frequency limit of the wave equation. On a grid, Dijkstra's algorithm minimizes the discrete sum of edge costs, while FMM enforces an upwind discretization of the eikonal relation with local updates that couple orthogonal directions. You must:\n\n- Implement Dijkstra's algorithm on the $4$-neighbor grid graph (edges along the Cartesian axes only) with edge cost equal to the product of slowness and geometric edge length. Use the center point as the source with $T=0$.\n- Implement the Fast Marching Method (FMM) on the same grid, using a first-order, monotone upwind discretization for the isotropic eikonal, ensuring causality by accepting nodes in increasing order of $T$.\n\nDefine the anisotropy index $\\mathcal{A}$ of a numerical stencil at a given physical radius $r$ (in meters) by sampling directions $\\theta_k$ (in radians) uniformly on $[0, 2\\pi)$, mapping each direction to the nearest grid node at the target radius, and computing the apparent slowness $s_{\\mathrm{app}}(\\theta_k) = T_{\\mathrm{num}}(\\theta_k)/d(\\theta_k)$, where $d(\\theta_k)$ is the Euclidean distance from the source to the sampled grid node (in meters). The anisotropy index is\n$$\n\\mathcal{A} = \\frac{\\max_k s_{\\mathrm{app}}(\\theta_k)}{\\min_k s_{\\mathrm{app}}(\\theta_k)} - 1,\n$$\nwhich is dimensionless. This quantity captures directional bias: for a perfectly isotropic discretization in a uniform medium, $s_{\\mathrm{app}}(\\theta)$ would be constant and $\\mathcal{A}$ would be $0$.\n\nAngle unit must be radians. Travel times must be computed in seconds. Distances must be computed in meters. You must round each reported anisotropy index to six decimal places.\n\nTest Suite:\n- Case 1 (happy path): $N=101$, $h=10$ m, $s_0 = 0.0005$ s/m, $r=200$ m, $K=36$ angles.\n- Case 2 (near-source boundary condition): $N=101$, $h=10$ m, $s_0 = 0.0005$ s/m, $r=10$ m, $K=36$ angles.\n- Case 3 (larger domain, larger radius): $N=201$, $h=10$ m, $s_0 = 0.0005$ s/m, $r=700$ m, $K=72$ angles.\n\nFor each case, compute two numbers: the anisotropy index for Dijkstra's $4$-neighbor method and the anisotropy index for the Fast Marching Method. The final output is a single line containing a comma-separated list of the three case results, where each case result is itself a two-element list ordered as $[\\mathcal{A}_{\\text{Dijkstra}},\\mathcal{A}_{\\text{FMM}}]$. The exact output format must be\n$$\n\\texttt{[[a\\_11,a\\_12],[a\\_21,a\\_22],[a\\_31,a\\_32]]}\n$$\nwith no spaces, and each $a\\_{ij}$ rounded to six decimal places.", "solution": "The user wants to quantify the numerical anisotropy of two common methods for solving the eikonal equation on a grid: Dijkstra's algorithm and the Fast Marching Method (FMM).\n\n### Principle-Based Design\n\nThis problem lies at the intersection of wave propagation physics and numerical analysis. The core principle is that the eikonal equation, $|\\nabla T| = s$, describes the travel time $T$ of a wavefront in a medium with slowness $s$. In a uniform medium ($s(\\mathbf{x}) = s_0$), the solution for a point source is $T(\\mathbf{x}) = s_0 d(\\mathbf{x}, \\mathbf{x}_{\\text{source}})$, where $d$ is the Euclidean distance. The travel time contours (isochrones) are perfect circles.\n\nNumerical methods on a Cartesian grid inevitably introduce errors that depend on the direction of propagation relative to the grid axes. This directional dependency is called numerical anisotropy. Our task is to implement two standard algorithms and measure this effect.\n\n#### 1. Dijkstra's Algorithm on a 4-Neighbor Graph\n\n**Underlying Principle**: Dijkstra's algorithm finds the shortest path from a source to all other nodes in a graph with non-negative edge weights. By modeling the grid as a graph where nodes are grid points and edges connect neighbors, we can approximate the travel time. The principle of stationary time (Fermat's principle) is here replaced by a discrete path minimization.\n\n**Algorithmic Design**:\n-   **Graph Representation**: The $N \\times N$ grid points are the graph's vertices. Edges connect each point $(i, j)$ to its four cardinal neighbors: $(i\\pm1, j)$ and $(i, j\\pm1)$.\n-   **Edge Cost**: The travel time along an edge is the product of the slowness $s_0$ and the path length. Since the distance between adjacent grid points is the grid spacing $h$, the cost for each edge is uniform: $w = s_0 h$.\n-   **Implementation**: A standard implementation of Dijkstra's algorithm uses a min-priority queue to efficiently explore nodes in increasing order of travel time.\n    1.  Initialize a travel time array $T$ of size $N \\times N$ with infinity, and set $T=0$ at the source node.\n    2.  Add the source node `(time=0, index)` to a priority queue.\n    3.  While the queue is not empty, extract the node with the minimum time.\n    4.  If this node has already been finalized, skip it. Otherwise, mark it as finalized.\n    5.  For each of its four neighbors, calculate the potential new travel time. If this time is less than the neighbor's current recorded time, update the neighbor's time in the $T$ array and add it to the priority queue.\n\n**Expected Anisotropy**: This method restricts paths to the grid lines. The shortest path between two points is a \"Manhattan\" path. The travel time to a point $(i, j)$ relative to the source is $T_{\\text{Dijkstra}} = s_0 h (|i| + |j|)$. The apparent slowness is $s_{\\text{app}} = T / d = s_0 h (|i|+|j|) / (h\\sqrt{i^2+j^2}) = s_0 (|i|+|j|)/\\sqrt{i^2+j^2}$. This value is minimized ($s_0$) along the grid axes and maximized ($\\sqrt{2} s_0$) along the grid diagonals, leading to a theoretical anisotropy index $\\mathcal{A}_{\\text{Dijkstra}} = \\sqrt{2} - 1 \\approx 0.414$.\n\n#### 2. First-Order Fast Marching Method (FMM)\n\n**Underlying Principle**: FMM is a more sophisticated grid-based method that directly solves a finite-difference approximation of the eikonal equation. It respects causality by propagating the solution outwards from the source, similar to how a wave propagates. Like Dijkstra's, it uses a priority queue to select the next node to finalize.\n\n**Algorithmic Design**:\n-   **Discretization**: The gradient operator $\\nabla T$ is approximated using upwind finite differences. For the isotropic eikonal equation $|\\nabla T|^2 = s_0^2$, the first-order scheme at a grid point $(i,j)$ is:\n    $$ \\left( \\frac{T_{i,j} - T_x}{h} \\right)^2 + \\left( \\frac{T_{i,j} - T_y}{h} \\right)^2 = s_0^2 $$\n    Here, $T_x = \\min(T_{i-1,j}, T_{i+1,j})$ and $T_y = \\min(T_{i,j-1}, T_{i,j+1})$ are the travel times of the already-computed neighbors.\n-   **Update Rule**: To calculate the time $T_{i,j}$ for a new node, we solve the quadratic equation above. Let $a$ and $b$ be the known travel times of the upwind neighbors in the x and y directions. The equation is $(T-a)^2 + (T-b)^2 = (s_0 h)^2$. To ensure causality ($T > a$ and $T > b$), we must take the larger root:\n    $$ T = \\frac{a+b + \\sqrt{2(s_0 h)^2 - (a-b)^2}}{2} $$\n    This formula is valid only if the term under the square root is non-negative. If it is negative, it implies the characteristic direction is aligned with one of the axes, and the update simplifies to a 1D propagation: $T = \\min(a,b) + s_0 h$.\n-   **Implementation**: The overall structure is similar to Dijkstra's. Nodes are categorized as KNOWN (finalized time), TRIAL (in the priority queue), and FAR (unvisited). The algorithm systematically moves nodes from TRIAL to KNOWN and updates their FAR neighbors, turning them into TRIAL nodes.\n\n**Expected Anisotropy**: This method couples the spatial dimensions in its update rule, producing a much more accurate and isotropic wavefront than the 4-neighbor Dijkstra. However, as a first-order scheme, it still exhibits some grid anisotropy. The analysis shows that the apparent slowness is minimal along the axes ($s_0$) and maximal along the diagonals, with a value of $s_0(1/\\sqrt{2}+1/2)$. This leads to a theoretical anisotropy index of $\\mathcal{A}_{\\text{FMM}} = 1/\\sqrt{2} - 1/2 \\approx 0.207$.\n\n#### 3. Anisotropy Index Calculation\n\nThe anisotropy index $\\mathcal{A}$ is a quantitative measure of the directional error.\n$$\n\\mathcal{A} = \\frac{\\max_k s_{\\mathrm{app}}(\\theta_k)}{\\min_k s_{\\mathrm{app}}(\\theta_k)} - 1\n$$\n-   **Procedure**: We sample $K$ points on a circle of physical radius $r$ centered at the source. For each angle $\\theta_k$, we find the nearest grid node.\n-   **Apparent Slowness**: For each sampled grid node, we calculate the apparent slowness $s_{\\text{app}} = T_{\\text{num}} / d$, where $T_{\\text{num}}$ is the travel time computed by the numerical method and $d$ is the true Euclidean distance from the source to that specific grid node.\n-   **Interpretation**: In a perfectly isotropic simulation, $s_{\\text{app}}$ would be constant and equal to $s_0$, yielding $\\mathcal{A}=0$. A non-zero $\\mathcal{A}$ reveals the extent of the numerical error's directional dependency.\n\nThe implementation will consist of three main functions: one for Dijkstra's algorithm, one for FMM, and one to compute the anisotropy index from the resulting travel time fields. These will be called for each test case to produce the final result.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n\n    # --- State Constants for FMM ---\n    _FAR = 0\n    _TRIAL = 1\n    _KNOWN = 2\n\n    def dijkstra_4n(N, h, s0):\n        \"\"\"\n        Computes first-arrival times using Dijkstra's algorithm on a 4-neighbor graph.\n        \"\"\"\n        center_idx = (N - 1) // 2\n        source = (center_idx, center_idx)\n\n        times = np.full((N, N), np.inf, dtype=np.float64)\n        times[source] = 0.0\n\n        pq = [(0.0, source[0], source[1])]\n        visited = np.zeros((N, N), dtype=bool)\n        edge_cost = s0 * h\n\n        while pq:\n            time, r, c = heapq.heappop(pq)\n\n            if visited[r, c]:\n                continue\n            \n            visited[r, c] = True\n\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = r + dr, c + dc\n\n                if 0 = nr  N and 0 = nc  N:\n                    new_time = time + edge_cost\n                    if new_time  times[nr, nc]:\n                        times[nr, nc] = new_time\n                        heapq.heappush(pq, (new_time, nr, nc))\n        \n        return times\n\n    def fmm_1st_order(N, h, s0):\n        \"\"\"\n        Computes first-arrival times using the first-order Fast Marching Method.\n        \"\"\"\n        center_idx = (N - 1) // 2\n        source = (center_idx, center_idx)\n\n        times = np.full((N, N), np.inf, dtype=np.float64)\n        states = np.full((N, N), _FAR, dtype=np.int8)\n        \n        times[source] = 0.0\n        \n        pq = [(0.0, source[0], source[1])] # The 'TRIAL' set\n        states[source] = _TRIAL\n        \n        c_sq = (s0 * h)**2\n\n        while pq:\n            time, r, c = heapq.heappop(pq)\n            \n            if states[r, c] == _KNOWN:\n                continue\n            \n            states[r, c] = _KNOWN\n\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = r + dr, c + dc\n                \n                if not (0 = nr  N and 0 = nc  N) or states[nr, nc] == _KNOWN:\n                    continue\n\n                # Find minimum times of KNOWN neighbors in x and y directions\n                t_x_min = np.inf\n                if nr > 0 and states[nr - 1, nc] == _KNOWN:\n                    t_x_min = min(t_x_min, times[nr - 1, nc])\n                if nr  N - 1 and states[nr + 1, nc] == _KNOWN:\n                    t_x_min = min(t_x_min, times[nr + 1, nc])\n\n                t_y_min = np.inf\n                if nc > 0 and states[nr, nc - 1] == _KNOWN:\n                    t_y_min = min(t_y_min, times[nr, nc - 1])\n                if nc  N - 1 and states[nr, nc + 1] == _KNOWN:\n                    t_y_min = min(t_y_min, times[nr, nc + 1])\n                \n                # Solve for new time at (nr, nc)\n                new_time_cand = np.inf\n                has_x = t_x_min != np.inf\n                has_y = t_y_min != np.inf\n                \n                if has_x and has_y:\n                    diff_sq = (t_x_min - t_y_min)**2\n                    if c_sq * 2.0 >= diff_sq:\n                        term_sqrt = np.sqrt(c_sq * 2.0 - diff_sq)\n                        new_time_cand = (t_x_min + t_y_min + term_sqrt) / 2.0\n                    else:\n                        new_time_cand = min(t_x_min, t_y_min) + s0 * h\n                elif has_x:\n                    new_time_cand = t_x_min + s0 * h\n                elif has_y:\n                    new_time_cand = t_y_min + s0 * h\n                \n                if new_time_cand  times[nr, nc]:\n                    times[nr, nc] = new_time_cand\n                    heapq.heappush(pq, (new_time_cand, nr, nc))\n                    states[nr, nc] = _TRIAL\n                    \n        return times\n\n    def compute_anisotropy(times_field, N, h, r, K):\n        \"\"\"\n        Computes the anisotropy index for a given travel time field.\n        \"\"\"\n        center_idx = (N - 1) // 2\n        y_c = center_idx * h # physical y-coord of source (row)\n        x_c = center_idx * h # physical x-coord of source (col)\n        \n        thetas = np.linspace(0, 2 * np.pi, K, endpoint=False)\n        \n        s_app_list = []\n        \n        for theta in thetas:\n            # Target coordinates on the geometric circle\n            x_target = x_c + r * np.cos(theta)\n            y_target = y_c + r * np.sin(theta)\n            \n            # Find nearest grid node, mapping physical (x,y) to grid (j,i)\n            j_target = np.round(x_target / h).astype(int)\n            i_target = np.round(y_target / h).astype(int)\n            \n            # Clamp to grid bounds\n            i_target = max(0, min(N - 1, i_target))\n            j_target = max(0, min(N - 1, j_target))\n            \n            t_num = times_field[i_target, j_target]\n            \n            # Physical coordinates of the sampled node\n            x_node = j_target * h\n            y_node = i_target * h\n            \n            dist = np.sqrt((x_node - x_c)**2 + (y_node - y_c)**2)\n            \n            if dist > 1e-9:\n                s_app = t_num / dist\n                s_app_list.append(s_app)\n        \n        if not s_app_list or len(s_app_list)  2:\n            return 0.0\n            \n        min_s_app = np.min(s_app_list)\n        max_s_app = np.max(s_app_list)\n\n        if min_s_app  1e-9:\n            return np.inf\n\n        anisotropy = max_s_app / min_s_app - 1.0\n        return anisotropy\n\n    test_cases = [\n        # (N, h, s0, r, K)\n        (101, 10.0, 0.0005, 200.0, 36),\n        (101, 10.0, 0.0005, 10.0, 36),\n        (201, 10.0, 0.0005, 700.0, 72),\n    ]\n\n    results = []\n    for N, h, s0, r, K in test_cases:\n        # Dijkstra's method\n        times_dijkstra = dijkstra_4n(N, h, s0)\n        anisotropy_dijkstra = compute_anisotropy(times_dijkstra, N, h, r, K)\n        \n        # Fast Marching Method\n        times_fmm = fmm_1st_order(N, h, s0)\n        anisotropy_fmm = compute_anisotropy(times_fmm, N, h, r, K)\n        \n        results.append([anisotropy_dijkstra, anisotropy_fmm])\n\n    case_strings = [f\"[{res[0]:.6f},{res[1]:.6f}]\" for res in results]\n    final_output = f\"[{','.join(case_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3614039"}, {"introduction": "The eikonal equation and the concept of a ray path are two sides of the same coin; rays are the characteristic curves that propagate along the gradient of the travel time field. This practice guides you to implement this fundamental connection by first solving for the travel time field using the Fast Marching Method and then tracing rays backward through that field. Comparing the ray-integrated travel time with the original field value provides a powerful, hands-on method for assessing the self-consistency and numerical error of your implementation [@problem_id:3614052].", "problem": "Design and implement a complete program that, for a two-dimensional isotropic medium with spatially varying slowness, quantifies numerical error in first-arrival travel times by comparing two independently computed quantities at prescribed receiver locations: (i) the interpolated solution of the eikonal travel-time field defined by the partial differential equation $|\\nabla T| = s(\\mathbf{x})$ and (ii) the line integral of slowness along numerically traced rays obtained by following the local gradient of the travel-time field. Your implementation must start from fundamental principles appropriate to seismic ray tracing methods in computational geophysics, namely Fermat’s principle and the Hamilton–Jacobi form of the eikonal equation. No shortcut formulas beyond these foundations may be assumed; all algorithmic steps must be justified by causality and upwind consistency. You must resolve the following requirements.\n\n- Physical and mathematical setting:\n  - Consider a two-dimensional Cartesian domain $\\Omega = \\{(x,z): 0 \\le x \\le 4 \\ \\text{km}, \\ 0 \\le z \\le 2 \\ \\text{km}\\}$ with uniform grid spacing $h = 0.02 \\ \\text{km}$ in both $x$ and $z$ directions.\n  - Define the background velocity as $v_0 = 3.0 \\ \\text{km/s}$, so the background slowness is $s_0 = 1/v_0 \\ \\text{s/km}$.\n  - Superimpose a focusing Gaussian slow lens (higher slowness) centered at $(x_c,z_c) = (2.0 \\ \\text{km}, 1.0 \\ \\text{km})$ with relative amplitude $A = 0.5$ and standard deviation $\\sigma = 0.3 \\ \\text{km}$, so that the slowness field is\n    $$ s(x,z) = s_0 \\left( 1 + A \\exp\\!\\left( -\\frac{(x-x_c)^2 + (z-z_c)^2}{2 \\sigma^2} \\right) \\right) \\ \\text{s/km}. $$\n  - Place a point source at $(x_s,z_s) = (0.2 \\ \\text{km}, 1.0 \\ \\text{km})$.\n\n- Fundamental base and algorithmic tasks to implement:\n  - From Fermat’s principle, the travel time accumulated along a parametric path $\\gamma(\\ell)$ with arclength parameter $\\ell$ is the functional\n    $$ \\mathcal{T}[\\gamma] = \\int_{\\ell_0}^{\\ell_1} s(\\gamma(\\ell)) \\, d\\ell \\ \\text{s}. $$\n    The first-arrival travel-time field $T(\\mathbf{x})$ is the viscosity solution of the Hamilton–Jacobi eikonal equation\n    $$ |\\nabla T(\\mathbf{x})| = s(\\mathbf{x}). $$\n  - Implement a first-order, monotone, upwind Fast Marching Method that computes a discrete travel-time field $T_h$ on the grid for the given slowness $s(x,z)$, honoring causality. Do not assume any closed-form updates beyond what follows from upwind consistency and local quadratic solves implied by the discrete Hamilton–Jacobi structure. Initialize $T_h$ at the grid node nearest to $(x_s,z_s)$ with $T = 0 \\ \\text{s}$.\n  - Implement ray back-tracing from a receiver location $\\mathbf{x}_r$ to the source by following the negative normalized gradient of the computed $T_h$ (i.e., a characteristic curve), using a step in arclength $\\Delta \\ell$ and bilinear interpolation of both $T_h$ and $s$ at off-grid points. The ordinary differential equation to integrate is\n    $$ \\frac{d\\mathbf{x}}{d\\ell} = - \\frac{\\nabla T(\\mathbf{x})}{|\\nabla T(\\mathbf{x})|}, $$\n    with termination when $\\|\\mathbf{x} - \\mathbf{x}_s\\|$ is within one grid spacing. Accumulate the line integral\n    $$ \\widehat{T}_{\\text{ray}}(\\mathbf{x}_r) = \\int_0^{L(\\mathbf{x}_r)} s(\\mathbf{x}(\\ell)) \\, d\\ell \\ \\text{s}, $$\n    where $L(\\mathbf{x}_r)$ is the traced path length to the source. Compute also the interpolated eikonal time $\\widehat{T}_{\\text{eik}}(\\mathbf{x}_r)$ by bilinear interpolation of $T_h$ at $\\mathbf{x}_r$.\n  - For each receiver, report the signed mismatch\n    $$ \\Delta(\\mathbf{x}_r) = \\widehat{T}_{\\text{ray}}(\\mathbf{x}_r) - \\widehat{T}_{\\text{eik}}(\\mathbf{x}_r) \\ \\text{s}. $$\n\n- Units and numerics:\n  - All distances must be in kilometers, all travel times in seconds, and all slowness values in seconds per kilometer. No angles are required. When integrating rays, use a constant arclength step $\\Delta \\ell = 0.005 \\ \\text{km}$ and terminate when the Euclidean distance to $(x_s,z_s)$ is less than $0.02 \\ \\text{km}$ or a maximum of $10000$ steps is reached, whichever occurs first. Use bilinear interpolation for field samples at off-grid points.\n\n- Test suite:\n  - Use the following receiver coordinates (in kilometers) to exercise normal propagation, near-caustic focusing along the optical axis, off-axis near-caustic behavior, passage through the lens, and a far-field boundary case:\n    - $\\mathbf{x}_{r,1} = (0.5, 1.0)$\n    - $\\mathbf{x}_{r,2} = (3.5, 1.0)$\n    - $\\mathbf{x}_{r,3} = (3.5, 0.8)$\n    - $\\mathbf{x}_{r,4} = (2.0, 1.0)$\n    - $\\mathbf{x}_{r,5} = (3.9, 1.0)$\n\n- Required output:\n  - Your program must produce a single line containing the list of signed mismatches in seconds for the above receivers, in the same order, formatted as decimal floats to six digits after the decimal point, enclosed in square brackets and comma-separated (for example, $[0.000123,-0.000456,\\dots]$). Express the final values in seconds, with the sign preserved.\n\nYour design must be fully self-contained and deterministic, and the program must not read any input or require any external files or network access. The program must implement the numerical methods from first principles per the above description and produce the required output in the specified format.", "solution": "The problem requires the design and implementation of a numerical experiment to quantify the self-consistency error in seismic travel-time computation. This is accomplished by comparing two quantities derived from the same underlying numerical construct: (i) the travel time at a receiver location, $\\widehat{T}_{\\text{eik}}(\\mathbf{x}_r)$, obtained by interpolating the solution of the eikonal equation, and (ii) the travel time, $\\widehat{T}_{\\text{ray}}(\\mathbf{x}_r)$, computed by integrating the slowness field along a ray path traced through the eikonal solution field. The entire procedure is grounded in Fermat's principle, which states that the path taken by a seismic wave between two points is the path of stationary, and for first arrivals, minimum, travel time.\n\nThe mathematical formulation of this principle leads to the Hamilton-Jacobi eikonal equation, a fundamental partial differential equation in geophysics:\n$$ |\\nabla T(\\mathbf{x})| = s(\\mathbf{x}) $$\nwhere $T(\\mathbf{x})$ is the first-arrival travel-time field from a source, and $s(\\mathbf{x})$ is the slowness (reciprocal of velocity) of the medium at position $\\mathbf{x}$. The ray paths are the characteristics of this equation.\n\nThe solution proceeds in two primary stages: first, computing the discrete travel-time field $T_h$ on a grid, and second, tracing rays and integrating travel times using this field.\n\n**1. Physical and Computational Domain Setup**\n\nThe problem is set in a two-dimensional Cartesian domain $\\Omega = \\{(x,z) \\mid 0 \\le x \\le 4 \\ \\text{km}, \\ 0 \\le z \\le 2 \\ \\text{km}\\}$. This domain is discretized into a uniform grid with spacing $h = 0.02 \\ \\text{km}$. This results in a grid of $N_x \\times N_z$ nodes, where $N_x = 4/0.02 + 1 = 201$ and $N_z = 2/0.02 + 1 = 101$.\n\nThe slowness field $s(x,z)$ is defined by a constant background slowness $s_0 = 1/v_0 = 1/3.0 \\ \\text{s/km}$ superimposed with a Gaussian anomaly:\n$$ s(x,z) = s_0 \\left( 1 + A \\exp\\!\\left( -\\frac{(x-x_c)^2 + (z-z_c)^2}{2 \\sigma^2} \\right) \\right) $$\nwith parameters $A = 0.5$, $(x_c, z_c) = (2.0, 1.0) \\ \\text{km}$, and $\\sigma = 0.3 \\ \\text{km}$. This slowness function is evaluated at each grid node $(x_i, z_j)$ to create a discrete slowness field $s_{i,j}$.\n\n**2. Eikonal Solution via the Fast Marching Method (FMM)**\n\nThe discrete travel-time field $T_h$ is computed using a first-order Fast Marching Method. FMM is an efficient grid-based algorithm that solves the eikonal equation by systematically advancing a wavefront, respecting causality. This is analogous to Huygens' principle. The algorithm uses a min-priority queue to ensure that grid points are processed in increasing order of travel time.\n\nThe state of each grid node is classified as one of three types:\n- `KNOWN`: The travel time is finalized.\n- `TRIAL`: An estimate of the travel time exists; the node is a candidate for finalization. These nodes form the narrow band or wavefront.\n- `FAR`: The node is untouched.\n\nThe FMM algorithm proceeds as follows:\n- **Initialization**: The travel-time array $T_h$ is initialized to infinity for all nodes. The grid node $(i_s, j_s)$ nearest the source at $(x_s, z_s) = (0.2, 1.0) \\ \\text{km}$ is assigned $T_{i_s, j_s} = 0$. This node is added to a min-priority queue, and its state is set to `TRIAL`.\n- **Iteration**: The main loop of the algorithm repeatedly extracts the `TRIAL` node with the smallest travel time from the priority queue. This node's state is changed to `KNOWN`. For each of its neighbors that is not `KNOWN`, a new travel time is calculated.\n- **Upwind Finite-Difference Update**: The travel time for a node $(i,j)$ is updated based on the finalized (`KNOWN`) values of its neighbors. This upwind scheme recognizes that information flows away from the source. Let $T_x$ and $T_z$ be the minimum travel times of the `KNOWN` neighbors of node $(i,j)$ along the $x$ and $z$ axes, respectively. Let $s_{i,j}$ be the slowness at the node. The updated time $T'_{i,j}$ is determined by a Godunov scheme:\n  1.  If only one upwind neighbor is available (e.g., $T_x$ is finite, $T_z$ is infinite), or if the wave arrives much earlier from one direction, a one-dimensional update is used. This occurs if $|\\min(T_x,T_z) + h s_{i,j}| \\le \\max(T_x,T_z)$. The update is $T'_{i,j} = \\min(T_x, T_z) + h s_{i,j}$.\n  2.  Otherwise, the wavefront is constructed from contributions from both axes. The update is found by solving the quadratic equation derived from the discretized eikonal equation, $(\\frac{T' - T_x}{h})^2 + (\\frac{T' - T_z}{h})^2 = s_{i,j}^2$. The correct causal solution is $T'_{i,j} = \\frac{T_x + T_z + \\sqrt{2(h s_{i,j})^2 - (T_x-T_z)^2}}{2}$.\n- If the newly calculated time $T'_{i,j}$ is less than the current time stored at node $(i,j)$, the value is updated, the node's state is set to `TRIAL`, and it is added to the priority queue. The algorithm terminates when the priority queue is empty.\n\nFinally, the travel time at an arbitrary receiver location $\\mathbf{x}_r$, denoted $\\widehat{T}_{\\text{eik}}(\\mathbf{x}_r)$, is obtained via bilinear interpolation of the final discrete travel-time field $T_h$.\n\n**3. Ray Tracing and Travel-Time Integration**\n\nSeismic rays are the characteristic curves of the eikonal equation, oriented along the gradient of the travel-time field, $\\nabla T$. To trace a ray from a receiver $\\mathbf{x}_r$ back to the source $\\mathbf{x}_s$, we integrate the ordinary differential equation (ODE) for the ray path $\\mathbf{x}(\\ell)$ parameterized by arclength $\\ell$:\n$$ \\frac{d\\mathbf{x}}{d\\ell} = - \\frac{\\nabla T(\\mathbf{x})}{|\\nabla T(\\mathbf{x})|} $$\nThe negative sign indicates back-propagation toward the source. This ODE is solved numerically.\n\n- **Numerical Integration**: A forward Euler method with a constant arclength step $\\Delta \\ell = 0.005 \\ \\text{km}$ is used:\n  $$ \\mathbf{x}_{k+1} = \\mathbf{x}_k - \\Delta\\ell \\frac{\\nabla T_h(\\mathbf{x}_k)}{|\\nabla T_h(\\mathbf{x}_k)|} $$\n  where $\\mathbf{x}_k$ is the position at step $k$. The gradient of the computed field, $\\nabla T_h(\\mathbf{x}_k)$, is required at each step. Since $\\mathbf{x}_k$ is generally not on a grid node, its value is found by first computing the gradient of $T_h$ on the entire grid using second-order finite differences, and then using bilinear interpolation to evaluate the gradient components at $\\mathbf{x}_k$. The norm $|\\nabla T_h(\\mathbf{x}_k)|$ is computed from this interpolated gradient vector.\n- **Travel-Time Accumulation**: The total travel time along the ray, $\\widehat{T}_{\\text{ray}}(\\mathbf{x}_r)$, is the line integral of the slowness field along the traced path. This integral is approximated by a sum (a simple rectangular quadrature rule):\n  $$ \\widehat{T}_{\\text{ray}}(\\mathbf{x}_r) = \\int_{0}^{L} s(\\mathbf{x}(\\ell)) \\, d\\ell \\approx \\sum_{k} s(\\mathbf{x}_k) \\Delta\\ell $$\n  The slowness $s(\\mathbf{x}_k)$ at each off-grid point is also obtained via bilinear interpolation of the discrete slowness field $s_{i,j}$.\n- **Termination**: The ray tracing process for a given receiver terminates when its Euclidean distance to the source $(x_s, z_s)$ becomes less than one grid spacing ($h = 0.02 \\ \\text{km}$), or if a maximum of $10000$ steps is reached.\n\n**4. Error Quantification**\n\nThe core task is to compute the signed mismatch $\\Delta(\\mathbf{x}_r)$ for each specified receiver $\\mathbf{x}_r$. This value is defined as:\n$$ \\Delta(\\mathbf{x}_r) = \\widehat{T}_{\\text{ray}}(\\mathbf{x}_r) - \\widehat{T}_{\\text{eik}}(\\mathbf{x}_r) $$\nA non-zero $\\Delta(\\mathbf{x}_r)$ is expected and represents the numerical error accumulated from several sources: the first-order accuracy of the FMM, inaccuracies in the finite-difference gradient estimation, the first-order accuracy of the Euler method for ray integration, and errors from repeated bilinear interpolation. This metric serves as a measure of the self-consistency of the implemented numerical methods.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\nfrom scipy.interpolate import RegularGridInterpolator\n\ndef solve():\n    \"\"\"\n    Computes numerical error in seismic travel times by comparing an FMM eikonal solution\n    with line integrals along traced rays.\n    \"\"\"\n    # 1. Physical and mathematical setting\n    W, H = 4.0, 2.0  # Domain size in km\n    h = 0.02  # Grid spacing in km\n    v0 = 3.0  # Background velocity in km/s\n    s0 = 1.0 / v0  # Background slowness in s/km\n\n    # Gaussian lens parameters\n    xc, zc = 2.0, 1.0  # Center in km\n    A = 0.5  # Relative amplitude (dimensionless)\n    sigma = 0.3  # Standard deviation in km\n\n    # Source and receiver locations\n    xs, zs = 0.2, 1.0  # Source in km\n    source_pos_np = np.array([xs, zs])\n    receivers = [\n        (0.5, 1.0),\n        (3.5, 1.0),\n        (3.5, 0.8),\n        (2.0, 1.0),\n        (3.9, 1.0),\n    ]\n\n    # Numerical parameters for ray tracing\n    delta_l = 0.005  # Arclength step in km\n    max_ray_steps = 10000\n    termination_dist = h\n\n    # 2. Grid and slowness field setup\n    nx = int(W / h) + 1\n    nz = int(H / h) + 1\n    x_ax = np.linspace(0, W, nx)\n    z_ax = np.linspace(0, H, nz)\n    X, Z = np.meshgrid(x_ax, z_ax)\n\n    s_field = s0 * (1.0 + A * np.exp(-((X - xc)**2 + (Z - zc)**2) / (2.0 * sigma**2)))\n\n    # 3. Fast Marching Method (FMM)\n    T = np.full((nz, nx), np.inf)\n    FAR, TRIAL, KNOWN = 0, 1, 2\n    states = np.zeros((nz, nx), dtype=np.int8)\n    pq = []\n\n    # Initialize source\n    isrc = int(np.round(xs / h))\n    jsrc = int(np.round(zs / h))\n    \n    T[jsrc, isrc] = 0.0\n    states[jsrc, isrc] = TRIAL\n    heapq.heappush(pq, (0.0, jsrc, isrc))\n\n    # FMM main loop\n    while pq:\n        time, j, i = heapq.heappop(pq)\n\n        if states[j, i] == KNOWN:\n            continue\n        states[j, i] = KNOWN\n\n        # Process neighbors\n        for dj, di in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            jn, i_n = j + dj, i + di\n\n            if not (0 = jn  nz and 0 = i_n  nx):\n                continue\n            if states[jn, i_n] == KNOWN:\n                continue\n\n            # Get minimum times from known neighbors of the target node (jn, i_n)\n            tx_min = np.inf\n            if i_n > 0 and states[jn, i_n - 1] == KNOWN:\n                tx_min = T[jn, i_n - 1]\n            if i_n  nx - 1 and states[jn, i_n + 1] == KNOWN:\n                tx_min = min(tx_min, T[jn, i_n + 1])\n\n            tz_min = np.inf\n            if jn > 0 and states[jn - 1, i_n] == KNOWN:\n                tz_min = T[jn - 1, i_n]\n            if jn  nz - 1 and states[jn + 1, i_n] == KNOWN:\n                tz_min = min(tz_min, T[jn + 1, i_n])\n\n            if tx_min == np.inf and tz_min == np.inf:\n                continue\n\n            # Godunov upwind update\n            t_cand = sorted([tx_min, tz_min])\n            t1, t2 = t_cand[0], t_cand[1]\n            s_val = s_field[jn, i_n]\n            h_s = h * s_val\n            t_new = np.inf\n\n            if t1 + h_s = t2 or t2 == np.inf:  # 1D update\n                t_new = t1 + h_s\n            else:  # 2D update\n                # Solve: (t-t1)^2 + (t-t2)^2 = (h*s)^2\n                a, b, c = 2.0, -2.0 * (t1 + t2), t1**2 + t2**2 - h_s**2\n                discriminant = b**2 - 4 * a * c\n                if discriminant >= 0:\n                    t_new = (-b + np.sqrt(discriminant)) / (2.0 * a)\n\n            if t_new  T[jn, i_n]:\n                T[jn, i_n] = t_new\n                states[jn, i_n] = TRIAL\n                heapq.heappush(pq, (t_new, jn, i_n))\n\n    # 4. Ray Tracing setup\n    # Create interpolators for T, s, and gradients\n    # Note: RegularGridInterpolator expects points in (z, x) order\n    interp_T = RegularGridInterpolator((z_ax, x_ax), T, bounds_error=False, fill_value=None)\n    interp_s = RegularGridInterpolator((z_ax, x_ax), s_field, bounds_error=False, fill_value=None)\n\n    # Gradients of T: dT/dz, dT/dx\n    gz, gx = np.gradient(T, h, h)\n    interp_dTdx = RegularGridInterpolator((z_ax, x_ax), gx, bounds_error=False, fill_value=None)\n    interp_dTdz = RegularGridInterpolator((z_ax, x_ax), gz, bounds_error=False, fill_value=None)\n    \n    results = []\n    \n    # 5. Compute mismatch for each receiver\n    for xr, zr in receivers:\n        # (i) Get interpolated eikonal travel time\n        T_eik = interp_T([zr, xr])[0]\n\n        # (ii) Trace ray and integrate slowness\n        current_pos = np.array([xr, zr])\n        ray_time = 0.0\n\n        for _ in range(max_ray_steps):\n            if np.linalg.norm(current_pos - source_pos_np)  termination_dist:\n                break\n            \n            # Interpolator expects (z, x) point format\n            pos_for_interp = [current_pos[1], current_pos[0]] \n\n            s_val = interp_s(pos_for_interp)[0]\n            grad_T_x = interp_dTdx(pos_for_interp)[0]\n            grad_T_z = interp_dTdz(pos_for_interp)[0]\n            grad_T = np.array([grad_T_x, grad_T_z])\n            grad_T_norm = np.linalg.norm(grad_T)\n\n            if grad_T_norm  1e-12: # Avoid division by zero\n                break\n\n            # Euler step for ray path ODE\n            direction = -grad_T / grad_T_norm\n            current_pos += direction * delta_l\n\n            # Accumulate time via line integral (simple quadrature)\n            ray_time += s_val * delta_l\n        \n        delta = ray_time - T_eik\n        results.append(delta)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "3614052"}, {"introduction": "Beyond calculating travel times (kinematics), ray theory also describes how energy is focused or defocused (dynamics), leading to phenomena like caustics where amplitudes can become very large. This advanced practice requires you to derive the Jacobi equation for infinitesimal ray separation from first principles and implement a numerical solver to locate these caustic surfaces. This exercise will deepen your understanding of dynamic ray tracing and its ability to predict complex wavefield features in heterogeneous media [@problem_id:3614032].", "problem": "You are given an isotropic, radially symmetric seismic medium in two spatial dimensions whose scalar slowness is prescribed by $s(r)=s_0\\big(1+\\alpha \\exp(-r^2/\\sigma^2)\\big)$, where $r=\\sqrt{x^2+y^2}$ is the distance from the origin, $s_00$ is a constant background slowness, $\\alpha$ is a dimensionless contrast parameter, and $\\sigma0$ is a characteristic length scale. Let $c(r)=1/s(r)$ be the scalar wave speed. Consider high-frequency rays launched from the origin with initial takeoff angle $\\varphi$ in the plane, and analyze the formation of caustics by computing conjugate points via the Jacobi equation for infinitesimal transverse ray separations.\n\nStarting from first principles of geometrical seismology, namely Fermat's principle and the eikonal equation, treat rays as bicharacteristics of the Hamilton–Jacobi system parameterized by physical travel time $t$ (in $\\mathrm{s}$). Using only these fundamental bases, derive the ordinary differential equation governing the infinitesimal normal separation $y(t)$ between neighboring rays (a scalar Jacobi field), and specify physically correct initial conditions consistent with a point source at the origin. Show how the medium’s inhomogeneity enters the coefficient of this Jacobi equation solely through spatial derivatives of $c(r)$ evaluated along the central ray. You must then specialize the general Jacobi equation to the present radially symmetric medium and implement a robust numerical algorithm to locate the first conjugate point $t_c0$ defined as the smallest positive travel time at which $y(t)$ returns to zero (a caustic).\n\nRequirements and conventions:\n- Use the Hamiltonian/eikonal framework as the starting point. Do not assume any shortcut paraxial formulas a priori; the Jacobi equation and its coefficient must be obtained from the fundamental laws.\n- Treat the reference ray as launched from the origin at angle $\\varphi$ (in radians). The computation should be universal for any $\\varphi$ by symmetry, but you must state and use correct initial conditions in your derivation with the parameter $t$ being physical travel time (in $\\mathrm{s}$).\n- Angles must be expressed in radians. Distances must be in $\\mathrm{km}$. Times must be in $\\mathrm{s}$.\n- For the radially symmetric profile $s(r)$ given above, implement a solver that integrates the reference ray and the scalar Jacobi equation and detects the first positive zero crossing of $y(t)$ (the first conjugate point). If no zero occurs before a specified maximum time $T_{\\max}$ (in $\\mathrm{s}$), return the sentinel value $-1.000$ for that case.\n- Numerical accuracy: detect zero crossings robustly for smooth functions. When reporting $t_c$, round to three decimal places.\n- Your program must run without any user input and must evaluate the following test suite of parameter sets (each specified as $(s_0,\\alpha,\\sigma,\\varphi,T_{\\max})$):\n    1. $(s_0=\\;0.5\\ \\mathrm{s}/\\mathrm{km},\\ \\alpha=\\;0.6,\\ \\sigma=\\;10\\ \\mathrm{km},\\ \\varphi=\\;0.2\\ \\mathrm{rad},\\ T_{\\max}=\\;120\\ \\mathrm{s})$\n    2. $(s_0=\\;0.5\\ \\mathrm{s}/\\mathrm{km},\\ \\alpha=\\;0.0,\\ \\sigma=\\;10\\ \\mathrm{km},\\ \\varphi=\\;0.3\\ \\mathrm{rad},\\ T_{\\max}=\\;120\\ \\mathrm{s})$\n    3. $(s_0=\\;1/3\\ \\mathrm{s}/\\mathrm{km},\\ \\alpha=\\;0.7,\\ \\sigma=\\;8\\ \\mathrm{km},\\ \\varphi=\\;0.1\\ \\mathrm{rad},\\ T_{\\max}=\\;100\\ \\mathrm{s})$\n    4. $(s_0=\\;0.5\\ \\mathrm{s}/\\mathrm{km},\\ \\alpha=\\;0.3,\\ \\sigma=\\;4\\ \\mathrm{km},\\ \\varphi=\\;1.0\\ \\mathrm{rad},\\ T_{\\max}=\\;80\\ \\mathrm{s})$\n- Final output format: Your program should produce a single line of output containing the results for these four test cases as a comma-separated list of floats in seconds, rounded to three decimal places, enclosed in square brackets, in the same order as the test suite (for example, $[12.345,-1.000,6.789,3.210]$). If a conjugate point occurs, report its $t_c$ in $\\mathrm{s}$. If no conjugate point occurs before $T_{\\max}$, report $-1.000$.\n\nThe problem is universally applicable in that it asks for derivation and numerical realization directly from the foundational laws of high-frequency wave propagation in isotropic media, with all quantities specified in standard physical units and angles in radians. The answer for each test case is a single float number representing the computed first conjugate time in $\\mathrm{s}$, or the sentinel $-1.000$ if none is found before $T_{\\max}$.", "solution": "The problem is to find the first conjugate point (caustic) for seismic rays propagating from the origin in a 2D isotropic medium with a radially symmetric slowness profile. This requires deriving and solving the Jacobi equation for the infinitesimal normal separation between adjacent rays.\n\n### Step 1: Theoretical Formulation\n\n#### 1.1 Hamiltonian Ray Tracing\nWe begin from the eikonal equation, which is a Hamilton-Jacobi equation for the travel time field $T(\\mathbf{x})$. In an isotropic medium with slowness $s(\\mathbf{x}) = 1/c(\\mathbf{x})$, where $c(\\mathbf{x})$ is the wave speed, the eikonal equation is $(\\nabla T)^2 = s^2(\\mathbf{x})$.\nThis can be formulated using a Hamiltonian $H(\\mathbf{x}, \\mathbf{p})$, where $\\mathbf{x}$ is the position and $\\mathbf{p} = \\nabla T$ is the slowness vector. The rays are the bicharacteristic curves of the eikonal equation, which lie on the zero-Hamiltonian surface $H=0$. A suitable Hamiltonian is:\n$$ H(\\mathbf{x}, \\mathbf{p}) = \\frac{1}{2} \\left( \\mathbf{p} \\cdot \\mathbf{p} - s^2(\\mathbf{x}) \\right) = 0 $$\nThe ray paths $\\mathbf{x}(t)$ and the slowness vector $\\mathbf{p}(t)$ along them evolve according to Hamilton's equations, parameterized by a variable $\\tau$:\n$$ \\frac{d\\mathbf{x}}{d\\tau} = \\frac{\\partial H}{\\partial \\mathbf{p}} = \\mathbf{p}, \\quad \\frac{d\\mathbf{p}}{d\\tau} = -\\frac{\\partial H}{\\partial \\mathbf{x}} = s(\\mathbf{x})\\nabla s(\\mathbf{x}) $$\nThe problem requires parameterization by physical travel time $t$. The relation between $d\\tau$ and $dt$ is $dt = s(\\mathbf{x}) |d\\mathbf{x}| = s(\\mathbf{x}) |\\dot{\\mathbf{x}}| d\\tau$. Since $|\\mathbf{p}| = s(\\mathbf{x})$ on the ray, we have $|\\dot{\\mathbf{x}}| = |\\mathbf{p}| = s(\\mathbf{x})$, so $dt = s^2(\\mathbf{x}) d\\tau$. Thus, $\\frac{d}{dt} = \\frac{1}{s^2(\\mathbf{x})} \\frac{d}{d\\tau}$.\n\nThe ray equations parameterized by travel time $t$ become:\n$$ \\frac{d\\mathbf{x}}{dt} = \\frac{1}{s^2(\\mathbf{x})} \\frac{d\\mathbf{x}}{d\\tau} = \\frac{\\mathbf{p}}{s^2(\\mathbf{x})} = c^2(\\mathbf{x})\\mathbf{p} $$\n$$ \\frac{d\\mathbf{p}}{dt} = \\frac{1}{s^2(\\mathbf{x})} \\frac{d\\mathbf{p}}{d\\tau} = \\frac{s(\\mathbf{x})\\nabla s(\\mathbf{x})}{s^2(\\mathbf{x})} = \\frac{\\nabla s(\\mathbf{x})}{s(\\mathbf{x})} = \\nabla(\\ln s(\\mathbf{x})) = -\\nabla(\\ln c(\\mathbf{x})) $$\nThese are the fundamental ray tracing equations.\n\n#### 1.2 The Jacobi Equation\nTo study caustics, we analyze the behavior of a narrow beam of rays. We consider a central ray $\\mathbf{x}(t)$ and its infinitesimal separation $\\mathbf{J}(t)$ from a neighboring ray. The separation vector $\\mathbf{J}(t)$ is called the Jacobi field. Its component $y(t)$ normal to the central ray quantifies the beam's width. A caustic occurs where $y(t)$ goes to zero, causing adjacent rays to cross. The evolution of $y(t)$ is governed by the Jacobi equation, a second-order linear ordinary differential equation. This equation can be derived by linearizing the ray tracing equations, a procedure known as dynamic ray tracing. For a 2D isotropic medium, the Jacobi equation for the normal separation $y(t)$ takes the form:\n$$ \\frac{d^2 y(t)}{dt^2} + K(t) y(t) = 0 $$\nThe coefficient $K(t)$ depends on the properties of the medium evaluated along the central ray. It is given by a standard result from geometrical seismology:\n$$ K(t) = -c(t) \\left. \\frac{\\partial^2 c}{\\partial n^2} \\right|_{\\text{ray}} $$\nwhere $c(t) = c(\\mathbf{x}(t))$ is the wave speed along the ray, and $\\frac{\\partial^2 c}{\\partial n^2}$ is the second derivative of the wave speed in the direction $\\hat{\\mathbf{n}}$ normal to the ray. This coefficient dictates the focusing or defocusing of the ray tube.\n\n#### 1.3 Specialization to the Radially Symmetric Medium\nThe given slowness is $s(r) = s_0(1+\\alpha \\exp(-r^2/\\sigma^2))$, with $r=\\sqrt{x^2+y^2}$. The medium is radially symmetric.\nFor a ray launched from the origin, its trajectory is a straight line. This can be verified from the ray equation for $\\mathbf{p}$:\n$\\frac{d\\mathbf{p}}{dt} = -\\frac{\\nabla c}{c}$. Since $c$ depends only on $r$, $\\nabla c = \\frac{dc}{dr} \\hat{\\mathbf{r}} = \\frac{dc}{dr} \\frac{\\mathbf{x}}{r}$. If a ray starts at $\\mathbf{x}(0)=\\mathbf{0}$ with an initial direction $\\hat{\\mathbf{r}}_0$, its position will be of the form $\\mathbf{x}(t) = r(t)\\hat{\\mathbf{r}}_0$. Thus, $\\nabla c$ is always parallel or anti-parallel to the ray's position vector and thus to its velocity vector. The slowness vector $\\mathbf{p}$ will remain aligned with $\\hat{\\mathbf{r}}_0$, and the ray path is a straight line.\nThe distance from origin $r(t)$ is governed by $\\frac{dr}{dt} = c(r(t))$.\n\nSince the ray is a straight line, we can, without loss of generality, align it with the $x$-axis ($\\varphi=0$). A point on the ray is $(r, 0)$. The normal direction $\\hat{\\mathbf{n}}$ is the $y$-direction. We need to compute $K(r) = -c(r) \\frac{\\partial^2 c}{\\partial y^2}|_{y=0}$.\nThe wave speed is $c(x,y) = c(\\sqrt{x^2+y^2})$. Its derivatives with respect to $y$ are:\n$$ \\frac{\\partial c}{\\partial y} = \\frac{dc}{dr} \\frac{\\partial r}{\\partial y} = \\frac{dc}{dr} \\frac{y}{r} $$\n$$ \\frac{\\partial^2 c}{\\partial y^2} = \\frac{\\partial}{\\partial y} \\left( \\frac{dc}{dr} \\frac{y}{r} \\right) = \\frac{d^2c}{dr^2} \\left(\\frac{y}{r}\\right)^2 + \\frac{dc}{dr} \\left( \\frac{1}{r} - \\frac{y^2}{r^3} \\right) $$\nEvaluating on the ray, where $y=0$ and $r=x$:\n$$ \\left. \\frac{\\partial^2 c}{\\partial y^2} \\right|_{y=0} = \\frac{1}{r} \\frac{dc}{dr} $$\nThus, the coefficient of the Jacobi equation is:\n$$ K(r) = -c(r) \\left( \\frac{1}{r} \\frac{dc}{dr} \\right) $$\nLet's find $\\frac{dc}{dr}$. Given $c(r) = c_0 (1+\\alpha e^{-r^2/\\sigma^2})^{-1}$, where $c_0=1/s_0$:\n$$ \\frac{dc}{dr} = -c_0 (1+\\alpha e^{-r^2/\\sigma^2})^{-2} \\left( \\alpha e^{-r^2/\\sigma^2} \\cdot \\frac{-2r}{\\sigma^2} \\right) = \\frac{2c_0\\alpha r}{\\sigma^2} \\frac{e^{-r^2/\\sigma^2}}{(1+\\alpha e^{-r^2/\\sigma^2})^2} $$\nThen $K(r)$ becomes:\n$$ K(r) = -c(r) \\frac{1}{r} \\left( \\frac{2c_0\\alpha r}{\\sigma^2} \\frac{e^{-r^2/\\sigma^2}}{(1+\\alpha e^{-r^2/\\sigma^2})^2} \\right) = -\\frac{2c_0\\alpha}{\\sigma^2} \\frac{c(r) e^{-r^2/\\sigma^2}}{(1+\\alpha e^{-r^2/\\sigma^2})^2} $$\nThis expression is well-defined at $r=0$, where $\\lim_{r\\to 0} \\frac{1}{r}\\frac{dc}{dr} = \\frac{d^2c}{dr^2}|_{r=0}$.\n\n#### 1.4 Initial Conditions\nWe need initial conditions for $y(t)$ for a point source at the origin. The rays in the beam are parameterized by their launch angle $\\varphi$. The Jacobi field is $\\mathbf{J}(t) = \\frac{\\partial \\mathbf{x}(\\varphi,t)}{\\partial \\varphi}$.\nAt $t=0$, $\\mathbf{x}(\\varphi, 0) = \\mathbf{0}$ for all $\\varphi$, so $\\mathbf{J}(0) = \\mathbf{0}$. This immediately implies $y(0) = \\mathbf{J}(0) \\cdot \\hat{\\mathbf{n}}(0) = 0$.\nTo find $\\dot{y}(0)$, we consider $\\dot{\\mathbf{J}}(t) = \\frac{\\partial \\dot{\\mathbf{x}}(\\varphi,t)}{\\partial \\varphi}$. At $t=0$:\n$$ \\dot{\\mathbf{x}}(\\varphi, 0) = c^2(\\mathbf{0})\\mathbf{p}(\\varphi,0) = c^2(0)s(0)[\\cos\\varphi, \\sin\\varphi] = c(0)[\\cos\\varphi, \\sin\\varphi] $$\n$$ \\dot{\\mathbf{J}}(0) = \\left. \\frac{\\partial}{\\partial \\varphi} \\left( c(0)[\\cos\\varphi, \\sin\\varphi] \\right) \\right|_{\\varphi_0} = c(0)[-\\sin\\varphi_0, \\cos\\varphi_0] = c(0)\\hat{\\mathbf{n}}(0) $$\nwhere $\\hat{\\mathbf{n}}(0)$ is the initial normal vector.\nThen, $\\dot{y}(t) = \\dot{\\mathbf{J}}(t)\\cdot\\hat{\\mathbf{n}}(t) + \\mathbf{J}(t)\\cdot\\dot{\\hat{\\mathbf{n}}}(t)$. At $t=0$:\n$$ \\dot{y}(0) = \\dot{\\mathbf{J}}(0)\\cdot\\hat{\\mathbf{n}}(0) + \\mathbf{J}(0)\\cdot\\dot{\\hat{\\mathbf{n}}}(0) = (c(0)\\hat{\\mathbf{n}}(0))\\cdot\\hat{\\mathbf{n}}(0) + 0 = c(0) $$\nSo, the initial conditions are $y(0)=0$ and $\\dot{y}(0)=c(0)$.\n\n### Step 2: Numerical Implementation\nWe must solve the following system of coupled first-order ODEs for the state vector $[r(t), y(t), z(t)]$, where $z(t) = \\dot{y}(t)$:\n1. $\\frac{dr}{dt} = c(r)$\n2. $\\frac{dy}{dt} = z$\n3. $\\frac{dz}{dt} = -K(r)y$\n\nInitial conditions at $t=0$:\n- $r(0) = 0$\n- $y(0) = 0$\n- $z(0) = c(0) = c_0/(1+\\alpha)$\n\nWe will integrate this system numerically from $t=0$ up to $T_{\\max}$. A conjugate point $t_c$ is the first time $t>0$ for which $y(t_c)=0$. We use an ODE solver with a root-finding (event detection) capability. To avoid the trivial root at $t=0$, the search for a zero-crossing of $y(t)$ will begin at a small time $t > 0$. The potential division-by-zero in the expression for $K(r)$ is handled by using its well-defined limit at $r=0$.\n\nFor the case $\\alpha=0$, the medium is homogeneous ($s(r)=s_0$, $c(r)=c_0$). Then $\\frac{dc}{dr}=0$, so $K(r)=0$. The Jacobi equation becomes $\\ddot{y}=0$. With initial conditions $y(0)=0, \\dot{y}(0)=c_0$, the solution is $y(t)=c_0 t$. This never returns to zero for $t>0$, so no caustic forms. The algorithm must correctly return the sentinel value in this case.", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Main solver function to process test cases for caustic formation.\n    \"\"\"\n\n    test_cases = [\n        # (s0, alpha, sigma, phi, Tmax)\n        (0.5, 0.6, 10.0, 0.2, 120.0),\n        (0.5, 0.0, 10.0, 0.3, 120.0),\n        (1.0/3.0, 0.7, 8.0, 0.1, 100.0),\n        (0.5, 0.3, 4.0, 1.0, 80.0)\n    ]\n\n    results = []\n    for s0, alpha, sigma, phi, Tmax in test_cases:\n        tc = compute_tc(s0, alpha, sigma, Tmax)\n        results.append(f\"{tc:.3f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef compute_tc(s0, alpha, sigma, Tmax):\n    \"\"\"\n    Computes the first conjugate time for a given set of medium parameters.\n\n    Args:\n        s0 (float): Background slowness (s/km).\n        alpha (float): Dimensionless contrast parameter.\n        sigma (float): Characteristic length scale (km).\n        Tmax (float): Maximum integration time (s).\n\n    Returns:\n        float: The first conjugate time t_c > 0 in seconds, or -1.0 if none is found.\n    \"\"\"\n    c0 = 1.0 / s0\n    \n    # Handle the homogeneous case where no caustics form.\n    if alpha == 0.0:\n        return -1.0\n\n    # Cache parameters for use in ODE functions\n    params = {'c0': c0, 'alpha': alpha, 'sigma': sigma}\n\n    def speed_c(r, p):\n        \"\"\"Computes wave speed c(r).\"\"\"\n        exp_term = np.exp(-r**2 / p['sigma']**2)\n        return p['c0'] / (1.0 + p['alpha'] * exp_term)\n\n    def K_coeff(r, p):\n        \"\"\"Computes the Jacobi equation coefficient K(r).\"\"\"\n        # To avoid division by zero, use the limit of K(r) as r->0\n        # K(0) = -c(0) * c''(0)\n        # c(0) = c0 / (1+alpha)\n        # c''(0) = (2 * c0 * alpha) / (sigma^2 * (1+alpha)^2)\n        # K(0) = - (2 * c0^2 * alpha) / (sigma^2 * (1+alpha)^3)\n        if r  1e-9:\n            return -2.0 * p['c0']**2 * p['alpha'] / (p['sigma']**2 * (1.0 + p['alpha'])**3)\n\n        # For r > 0, K(r) = -c(r)/r * c'(r)\n        # c'(r) = (2*c0*alpha*r/sigma^2) * exp(-r^2/sigma^2) / (1+alpha*exp(-r^2/sigma^2))^2\n        exp_term = np.exp(-r**2 / p['sigma']**2)\n        c_r = p['c0'] / (1.0 + p['alpha'] * exp_term)\n        \n        # This is -c(r) * (c'(r)/r)\n        k_val = -(c_r) * (2.0 * p['c0'] * p['alpha'] / p['sigma']**2) * \\\n                exp_term / (1.0 + p['alpha'] * exp_term)**2\n        return k_val\n        \n\n    def ode_system(t, state, p):\n        \"\"\"\n        Defines the system of first-order ODEs for ray tracing and Jacobi field.\n        state[0]: r, distance from origin\n        state[1]: y, normal separation\n        state[2]: z = dy/dt\n        \"\"\"\n        r, y, z = state\n        \n        dr_dt = speed_c(r, p)\n        dy_dt = z\n        dz_dt = -K_coeff(r, p) * y\n        \n        return [dr_dt, dy_dt, dz_dt]\n\n    # Event function to find when y(t) = 0.\n    def caustic_event(t, state, p):\n        return state[1]  # Trigger when y=0\n    \n    caustic_event.terminal = True  # Stop integration at the first event\n    caustic_event.direction = 0  # Trigger on any zero crossing\n\n    # Initial conditions at t=0\n    r_init = 0.0\n    y_init = 0.0\n    c_at_0 = speed_c(0.0, params)\n    z_init = c_at_0\n    \n    # To find the first *positive* zero crossing, we start integration at a\n    # very small time t_start > 0.\n    t_start = 1e-8\n    \n    # Approximate initial state at t_start using Taylor expansion\n    # r(t_start) approx r(0) + dr/dt(0) * t_start = c(0) * t_start\n    # y(t_start) approx y(0) + dy/dt(0) * t_start = z(0) * t_start = c(0) * t_start\n    # z(t_start) approx z(0) + dz/dt(0) * t_start = c(0) - K(0)*y(0)*t_start = c(0)\n    r0 = c_at_0 * t_start\n    y0 = c_at_0 * t_start\n    z0 = c_at_0\n    initial_state = [r0, y0, z0]\n\n    sol = solve_ivp(\n        ode_system,\n        t_span=[t_start, Tmax],\n        y0=initial_state,\n        args=(params,),\n        events=caustic_event,\n        method='RK45',\n        dense_output=True,\n        rtol=1e-8,\n        atol=1e-8\n    )\n\n    # Check if a caustic was found\n    if sol.t_events[0].size > 0:\n        return sol.t_events[0][0]\n    else:\n        return -1.0\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3614032"}]}