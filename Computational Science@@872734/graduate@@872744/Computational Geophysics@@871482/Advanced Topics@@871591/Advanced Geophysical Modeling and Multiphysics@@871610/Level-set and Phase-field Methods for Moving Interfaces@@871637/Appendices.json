{"hands_on_practices": [{"introduction": "In many physical models, the evolution of an interface depends on its curvature, a quantity that involves second-order spatial derivatives. Computing curvature accurately, particularly near domain boundaries, is a classic challenge in numerical methods. This analytical exercise explores how to construct a boundary condition stencil for the level-set function that preserves second-order accuracy, a fundamental step in building reliable simulation codes. [@problem_id:3607078]", "problem": "In computational geophysics, moving interfaces such as magma fronts or saline intrusion tongues are often represented by a scalar level-set function $\\phi(x,y)$ whose zero level-set delineates the advancing boundary. The mean curvature $\\kappa$ of the level-set is defined by the divergence of the unit normal field $\\,\\mathbf{n} = \\nabla \\phi / |\\nabla \\phi|\\,$, namely $\\kappa = \\nabla \\cdot \\mathbf{n}$. Accurate computation of $\\kappa$ near impermeable walls requires careful treatment of boundary conditions and ghost-node stencils so that discrete approximations remain second-order accurate.\n\nConsider a two-dimensional Cartesian grid with uniform spacing $h$ in the $y$-direction, a wall at $y=0$, and interior nodes at $y_j = j h$ for $j \\geq 0$. Let $\\phi$ be smooth and, in a local neighborhood near the wall, take the form\n$$\n\\phi(x,y) = y + a y^{2} + s x,\n$$\nwith constants $a$ and $s$ representing local quadratic variation in the wall-normal direction and a uniform gradient in the wall-tangential direction, respectively. This generic local model is designed to expose the sensitivity of curvature to wall-normal second derivatives and the role of tangential gradients.\n\nTo approximate $\\kappa$ at the wall node $(x_i,y_0)$ using second-order centered differences, a ghost value $\\phi_{i,-1}$ at $y=-h$ is needed. Assume a wall-normal Neumann boundary condition is imposed at $y=0$:\n$$\n\\left.\\frac{\\partial \\phi}{\\partial y}\\right|_{y=0} = g,\n$$\nwith $g$ equal to the exact value $\\left.\\frac{\\partial \\phi}{\\partial y}\\right|_{y=0}$ for the given $\\phi$. Propose a family of one-ghost-node Neumann stencils of the form\n$$\n\\phi_{i,-1} = \\phi_{i,1} - m\\, h\\, g,\n$$\nwhere $m$ is a constant to be determined so that the discrete curvature $\\kappa$ computed from $\\phi$ at $(x_i,y_0)$ remains second-order accurate in $h$.\n\nStarting from the geometric definition $\\kappa = \\nabla \\cdot \\left( \\nabla \\phi / |\\nabla \\phi| \\right)$ and using second-order centered differences in both $x$ and $y$ directions, analyze the effect of the above Neumann ghost-node stencil on the discrete wall-normal second derivative needed for curvature. Derive the unique value of the scalar $m$ that eliminates $O(h^{-1})$ contamination and ensures a second-order accurate discrete curvature at the wall node for the given local model $\\phi(x,y) = y + a y^{2} + s x$.\n\nExpress your final answer for $m$ as a single real number. No rounding is required. No units are required.", "solution": "The problem requires us to determine the value of a constant $m$ in a ghost-node stencil for a Neumann boundary condition, such that the finite difference approximation of the mean curvature $\\kappa$ is second-order accurate at a wall.\n\nThe mean curvature $\\kappa$ of the level-set $\\phi(x,y)=C$ is given by the divergence of the unit normal vector $\\mathbf{n} = \\nabla \\phi / |\\nabla \\phi|$. The full expression is:\n$$\n\\kappa = \\nabla \\cdot \\left( \\frac{\\nabla \\phi}{|\\nabla \\phi|} \\right) = \\frac{\\phi_{xx} \\phi_y^2 - 2 \\phi_x \\phi_y \\phi_{xy} + \\phi_{yy} \\phi_x^2}{(\\phi_x^2 + \\phi_y^2)^{3/2}}\n$$\nwhere subscripts denote partial derivatives (e.g., $\\phi_x = \\frac{\\partial \\phi}{\\partial x}$, $\\phi_{yy} = \\frac{\\partial^2 \\phi}{\\partial y^2}$).\n\nWe are asked to evaluate the discrete approximation of $\\kappa$ at a wall node $(x_i, y_0)$, where $y_0=0$. The problem specifies the use of second-order centered differences. The key challenge arises in approximating derivatives at the boundary $y=0$, which requires a value $\\phi_{i,-1} = \\phi(x_i, -h)$ at a \"ghost\" node outside the domain.\n\nThe provided local model for the level-set function is:\n$$\n\\phi(x,y) = y + a y^{2} + s x\n$$\nThe Neumann boundary condition at $y=0$ is $\\left.\\frac{\\partial \\phi}{\\partial y}\\right|_{y=0} = g$. We can calculate $g$ exactly from the given $\\phi(x,y)$:\n$$\n\\frac{\\partial \\phi}{\\partial y} = 1 + 2ay\n$$\n$$\ng = \\left.\\frac{\\partial \\phi}{\\partial y}\\right|_{y=0} = 1 + 2a(0) = 1\n$$\n\nThe proposed ghost-node stencil is:\n$$\n\\phi_{i,-1} = \\phi_{i,1} - m h g\n$$\nSince $g=1$, this simplifies to $\\phi_{i,-1} = \\phi_{i,1} - m h$.\n\nThe problem states that the $O(h^{-1})$ contamination in the discrete curvature arises from the wall-normal second derivative, $\\phi_{yy}$. Let us analyze the centered difference approximation for $\\phi_{yy}$ at the wall node $(x_i, y_0=0)$. Let $\\tilde{\\phi}_{yy}$ denote this discrete approximation.\n$$\n\\tilde{\\phi}_{yy}(x_i, 0) = \\frac{\\phi(x_i, h) - 2\\phi(x_i, 0) + \\phi(x_i, -h)}{h^2} = \\frac{\\phi_{i,1} - 2\\phi_{i,0} + \\phi_{i,-1}}{h^2}\n$$\nSubstitute the ghost-node stencil $\\phi_{i,-1} = \\phi_{i,1} - m h g$ into this expression:\n$$\n\\tilde{\\phi}_{yy}(x_i, 0) = \\frac{\\phi_{i,1} - 2\\phi_{i,0} + (\\phi_{i,1} - m h g)}{h^2} = \\frac{2\\phi_{i,1} - 2\\phi_{i,0} - m h g}{h^2}\n$$\nTo analyze the accuracy of this approximation, we perform a Taylor series expansion of $\\phi_{i,1} = \\phi(x_i, h)$ around the point $(x_i, 0)$:\n$$\n\\phi(x_i, h) = \\phi(x_i, 0) + h \\left.\\frac{\\partial \\phi}{\\partial y}\\right|_{(x_i,0)} + \\frac{h^2}{2} \\left.\\frac{\\partial^2 \\phi}{\\partial y^2}\\right|_{(x_i,0)} + O(h^3)\n$$\nUsing the notation $\\phi_{i,0} = \\phi(x_i, 0)$, $\\left.\\frac{\\partial \\phi}{\\partial y}\\right|_{(x_i,0)} = g$, and $\\left.\\frac{\\partial^2 \\phi}{\\partial y^2}\\right|_{(x_i,0)} = \\phi_{yy}(x_i,0)$, we have:\n$$\n\\phi_{i,1} = \\phi_{i,0} + h g + \\frac{h^2}{2}\\phi_{yy}(x_i,0) + O(h^3)\n$$\nNow, substitute this expansion back into the expression for $\\tilde{\\phi}_{yy}$:\n$$\n\\tilde{\\phi}_{yy}(x_i, 0) = \\frac{2\\left(\\phi_{i,0} + h g + \\frac{h^2}{2}\\phi_{yy}(x_i,0) + O(h^3)\\right) - 2\\phi_{i,0} - m h g}{h^2}\n$$\n$$\n\\tilde{\\phi}_{yy}(x_i, 0) = \\frac{2\\phi_{i,0} + 2hg + h^2\\phi_{yy}(x_i,0) - 2\\phi_{i,0} - mhg + O(h^3)}{h^2}\n$$\n$$\n\\tilde{\\phi}_{yy}(x_i, 0) = \\frac{(2-m)hg + h^2\\phi_{yy}(x_i,0) + O(h^3)}{h^2}\n$$\n$$\n\\tilde{\\phi}_{yy}(x_i, 0) = \\phi_{yy}(x_i,0) + \\frac{(2-m)g}{h} + O(h)\n$$\nThe exact value of the second derivative is $\\phi_{yy}(x_i,0)$. The error in our approximation is $\\tilde{\\phi}_{yy}(x_i, 0) - \\phi_{yy}(x_i,0) = \\frac{(2-m)g}{h} + O(h)$.\n\nThis expression clearly shows an error term of order $O(h^{-1})$, which is the contamination referred to in the problem. This term will cause the numerical solution to diverge as the grid spacing $h$ is refined, unless it is eliminated. To eliminate this term, its coefficient must be zero:\n$$\n(2-m)g = 0\n$$\nAs we calculated, $g=1$. Since $g \\neq 0$, we must have:\n$$\n2 - m = 0 \\implies m = 2\n$$\nThis is the unique value of $m$ that eliminates the $O(h^{-1})$ contamination.\nWith $m=2$, the approximation for the second derivative becomes $\\tilde{\\phi}_{yy}(x_i, 0) = \\phi_{yy}(x_i,0) + O(h)$, which is a first-order accurate approximation.\n\nFor the specific $\\phi(x,y)=y+ay^2+sx$, we have $\\phi_{yyy} = 0$, so the $\\phi_{i,1}$ Taylor expansion terminates and the $O(h^3)$ term is zero. This makes the approximation for $\\phi_{yy}$ with $m=2$ exact: $\\tilde{\\phi}_{yy} = \\phi_{yy} = 2a$.\nFurthermore, for this specific polynomial, the centered difference approximations for $\\phi_x, \\phi_{xx}, \\phi_{xy}$ are exact. With $m=2$, the approximation $\\tilde{\\phi}_y = \\frac{\\phi_{i,1}-\\phi_{i,-1}}{2h} = \\frac{mhg}{2h} = \\frac{2(1)(1)}{2}=1$ is also exact. Since all derivatives in the curvature formula are approximated exactly, the discrete curvature $\\tilde{\\kappa}$ will be equal to the exact curvature $\\kappa$. An error of zero is trivially $O(h^2)$, thus satisfying the second-order accuracy requirement.\n\nThe crucial step, and the explicit requirement of the problem, is the elimination of the $O(h^{-1})$ term, which uniquely determines $m$.\nThe value of $m$ is $2$.", "answer": "$$\\boxed{2}$$", "id": "3607078"}, {"introduction": "A significant challenge in simulating geophysical phenomena is accurately modeling sharp discontinuities in material properties across an interface, such as thermal conductivity between rock and magma. Standard numerical schemes can struggle here, but the Ghost-Fluid Method (GFM) provides an elegant solution. This practice guides you through implementing the GFM to solve a steady-state heat conduction problem, demonstrating how to enforce physical jump conditions correctly at the discrete level. [@problem_id:3607108]", "problem": "Consider one-dimensional thermal conduction along a segment with spatial coordinate $x \\in [0,L]$ and unknown temperature field $T(x)$ at steady state. The material has a discontinuous thermal conductivity described by a level-set function $\\phi(x,t)$ that identifies a moving interface at $\\phi=0$. In this problem, the interface location is $x=s(t)$, and the level-set function is $\\phi(x,t)=x-s(t)$. The thermal conductivity is piecewise constant: $k(x)=k_{-}$ for $xs(t)$ and $k(x)=k_{+}$ for $xs(t)$. Assume continuity of temperature across the interface and continuity of heat flux. The steady conduction equation with no sources is the divergence of flux condition $\\frac{d}{dx}\\left(k(x)\\frac{dT}{dx}\\right)=0$ and Fourier's law $q(x)=-k(x)\\frac{dT}{dx}$ holds. Dirichlet boundary conditions $T(0)=T_0$ and $T(L)=T_L$ are imposed.\n\nTask:\n- Starting only from Fourier's law and the divergence form of steady conduction, derive the discrete flux across a face that straddles the interface $\\phi=0$ using a Ghost-Fluid Method (GFM) argument. Express the flux in terms of distances from neighboring nodal points to the interface and material conductivities, and explain how temperature continuity is enforced at the interface.\n- Implement a finite-volume discretization on a uniform node-centered grid $x_i=i\\Delta x$ for $i=0,\\dots,N-1$ and $\\Delta x=L/(N-1)$. For a face between nodes $i$ and $i+1$ that does not intersect the interface, use a standard constant-coefficient face conductance. For a face that intersects the interface (i.e., $\\phi(x_i)\\phi(x_{i+1})0$), use the GFM series-resistance flux derived from your first task.\n- Solve the resulting linear system to obtain the discrete temperature $\\{T_i\\}_{i=0}^{N-1}$.\n- Compute the exact steady-state solution $T_{\\mathrm{exact}}(x)$ by enforcing constant flux and temperature continuity across $x=s(t)$. The exact solution is piecewise linear with a constant heat flux determined by boundary conditions and the series resistance of the two materials.\n- For each test case specified below, compute the maximum absolute error $\\max_i |T_i - T_{\\mathrm{exact}}(x_i)|$ and report it as a floating-point number in Kelvins. Express all reported errors in Kelvin (K).\n\nFundamental base to use:\n- Fourier's law $q(x)=-k(x)\\frac{dT}{dx}$.\n- Steady conduction in one dimension as flux conservation $\\frac{d}{dx}\\left(k(x)\\frac{dT}{dx}\\right)=0$.\n- Continuity of temperature and flux at the interface $\\phi=0$.\n\nTest suite:\nFor all tests, produce the outputs in Kelvin (K). Use a uniform grid and the parameters given.\n\n- Test 1 (happy path): $L=1\\,\\mathrm{m}$, $N=129$, $k_{-}=1\\,\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$, $k_{+}=5\\,\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$, $s=0.37\\,\\mathrm{m}$, $T_0=0\\,\\mathrm{K}$, $T_L=1\\,\\mathrm{K}$.\n- Test 2 (interface exactly at a node): $L=1\\,\\mathrm{m}$, $N=129$, $k_{-}=1\\,\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$, $k_{+}=10\\,\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$, $s=0.5\\,\\mathrm{m}$, $T_0=100\\,\\mathrm{K}$, $T_L=300\\,\\mathrm{K}$.\n- Test 3 (extreme conductivity contrast): $L=1\\,\\mathrm{m}$, $N=257$, $k_{-}=0.1\\,\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$, $k_{+}=1000\\,\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$, $s=0.8\\,\\mathrm{m}$, $T_0=10\\,\\mathrm{K}$, $T_L=11\\,\\mathrm{K}$.\n- Test 4 (near-face intersection): $L=1\\,\\mathrm{m}$, $N=129$, $k_{-}=2\\,\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$, $k_{+}=2\\,\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$, $s=0.499\\,\\mathrm{m}$, $T_0=0\\,\\mathrm{K}$, $T_L=1\\,\\mathrm{K}$.\n- Test 5 (interface near boundary): $L=1\\,\\mathrm{m}$, $N=129$, $k_{-}=0.5\\,\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$, $k_{+}=3.5\\,\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$, $s=0.02\\,\\mathrm{m}$, $T_0=0\\,\\mathrm{K}$, $T_L=1\\,\\mathrm{K}$.\n\nFinal output specification:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5]\"). Each result must be the maximum absolute error in Kelvin (K) for the corresponding test case, in the order listed above.", "solution": "The user-provided problem is a valid boundary value problem in steady-state heat conduction. It is scientifically grounded, well-posed, objective, and contains all necessary information to proceed with a unique solution.\n\n### 1. Theoretical Framework\n\n#### 1.1. Exact Analytical Solution\nThe problem describes one-dimensional steady-state heat conduction governed by the equation $\\frac{d}{dx}\\left(k(x)\\frac{dT}{dx}\\right)=0$. Integrating this equation once shows that the heat flux, $q(x) = -k(x)\\frac{dT}{dx}$, must be constant throughout the domain $x \\in [0, L]$. Let this constant flux be $q_c$.\n\nThe thermal conductivity $k(x)$ is piecewise constant, with a discontinuity at the interface $x=s$:\n$$\nk(x) = \\begin{cases} k_{-}  x  s \\\\ k_{+}  x  s \\end{cases}\n$$\nIntegrating Fourier's law, $dT/dx = -q_c/k(x)$, gives a piecewise linear temperature profile.\nFor $x \\in [0, s]$, applying the boundary condition $T(0)=T_0$:\n$$ T(x) = T_0 - \\frac{q_c}{k_{-}}x $$\nThe temperature at the interface is $T(s) = T_0 - \\frac{q_c s}{k_{-}}$. Due to the continuity of temperature, this value is used as the starting point for the second region.\nFor $x \\in [s, L]$:\n$$ T(x) = T(s) - \\frac{q_c}{k_{+}}(x-s) = \\left(T_0 - \\frac{q_c s}{k_{-}}\\right) - \\frac{q_c}{k_{+}}(x-s) $$\nApplying the boundary condition $T(L)=T_L$:\n$$ T_L = T_0 - q_c \\left( \\frac{s}{k_{-}} + \\frac{L-s}{k_{+}} \\right) $$\nThe term in the parenthesis is the total thermal resistance of the composite material, which is the sum of the series resistances of the two segments: $R_{total} = \\frac{s}{k_{-}} + \\frac{L-s}{k_{+}}$.\nSolving for the constant flux $q_c$:\n$$ q_c = - \\frac{T_L - T_0}{R_{total}} = - \\frac{T_L - T_0}{\\frac{s}{k_{-}} + \\frac{L-s}{k_{+}}} $$\nWith $q_c$ known, the exact temperature $T_{\\mathrm{exact}}(x)$ at any point can be computed. This serves as the benchmark for our numerical solution.\n\n#### 1.2. Ghost-Fluid Method (GFM) and Interface Flux\nWe are asked to derive the flux across a control volume face that straddles the interface using a GFM argument. Consider a uniform grid $x_i = i\\Delta x$ and two adjacent nodes $x_j$ and $x_{j+1}$ such that the interface is located between them: $x_j  s  x_{j+1}$. The physical principles of temperature and flux continuity must hold at $x=s$.\n\nAssuming a locally linear temperature profile, the constant flux $q_c$ can be approximated from the left and right sides of the interface:\nFlux from the left, using nodes $T_j$ at $x_j$ and an unknown interface temperature $T_s$ at $x=s$:\n$$ q_c \\approx -k_{-} \\frac{T_s - T_j}{s - x_j} $$\nFlux from the right, using nodes $T_{j+1}$ at $x_{j+1}$ and $T_s$ at $x=s$:\n$$ q_c \\approx -k_{+} \\frac{T_{j+1} - T_s}{x_{j+1} - s} $$\nEnforcing flux continuity by equating these two expressions allows us to solve for the interface temperature $T_s$:\n$$ k_{-} \\frac{T_s - T_j}{s - x_j} = k_{+} \\frac{T_{j+1} - T_s}{x_{j+1} - s} \\implies T_s = \\frac{k_{-}(x_{j+1}-s)T_j + k_{+}(s-x_j)T_{j+1}}{k_{-}(x_{j+1}-s) + k_{+}(s-x_j)} $$\nSubstituting this $T_s$ back into either flux approximation gives the desired flux between nodes $j$ and $j+1$, which we denote $q_{j+1/2}$:\n$$ q_{j+1/2} = -k_{-} \\frac{1}{s-x_j} \\left( \\frac{k_{-}(x_{j+1}-s)T_j + k_{+}(s-x_j)T_{j+1}}{k_{-}(x_{j+1}-s) + k_{+}(s-x_j)} - T_j \\right) $$\nAfter algebraic simplification, this becomes:\n$$ q_{j+1/2} = - \\left( \\frac{k_{-}k_{+}}{k_{+}(s-x_j) + k_{-}(x_{j+1}-s)} \\right) (T_{j+1} - T_j) $$\nThis expression is equivalent to a series-resistance model. The term in the denominator of the fraction multiplying the temperature difference is the total resistance between the nodes: $R_{j,j+1} = \\frac{s-x_j}{k_{-}} + \\frac{x_{j+1}-s}{k_{+}}$. The numerical flux is then $q_{j+1/2} = -\\frac{T_{j+1}-T_j}{R_{j,j+1}}$. The effective conductance for this cell pair is $C^{\\text{eff}}_{j+1/2} = 1/R_{j,j+1}$.\n\n### 2. Numerical Implementation\n\nWe use a node-centered finite-volume method. For an interior node $i$ (from $i=1$ to $N-2$), the control volume is $[x_{i-1/2}, x_{i+1/2}]$, where $x_{i\\pm1/2} = (x_i+x_{i\\pm1})/2$. Integrating the conservation law over this volume yields a flux balance:\n$$ \\int_{x_{i-1/2}}^{x_{i+1/2}} \\frac{d}{dx}q(x) dx = q(x_{i+1/2}) - q(x_{i-1/2}) = 0 $$\nThe fluxes at the faces are approximated as $q_{i+1/2} = -C_{i+1/2}(T_{i+1}-T_i)$, where $C_{i+1/2}$ is the conductance between nodes $i$ and $i+1$.\nThe equation for node $i$ is:\n$$ -C_{i-1/2}(T_i - T_{i-1}) - (-C_{i+1/2}(T_{i+1} - T_i)) = 0 $$\n$$ C_{i-1/2}T_{i-1} - (C_{i-1/2} + C_{i+1/2})T_i + C_{i+1/2}T_{i+1} = 0 $$\nThe conductance $C_{i+1/2}$ depends on whether the interface $s$ lies in the interval $(x_i, x_{i+1})$:\n- **No Interface:** If the interval $(x_i, x_{i+1})$ has a constant conductivity $k$ (which is $k_{-}$ if $x_{i+1/2}  s$ and $k_{+}$ if $x_{i+1/2}  s$), the standard conductance is $C_{i+1/2} = k / \\Delta x$.\n- **Interface Present:** If $x_i  s  x_{i+1}$, the conductance is the effective conductance derived from the GFM: $C_{i+1/2} = C^{\\text{eff}}_{i+1/2} = \\left(\\frac{s-x_i}{k_{-}} + \\frac{x_{i+1}-s}{k_{+}}\\right)^{-1}$.\n\nThese equations for $i=1, \\dots, N-2$, along with the Dirichlet boundary conditions $T_0=T_0$ and $T_{N-1}=T_L$, form an $N \\times N$ tridiagonal linear system $A\\mathbf{T}=\\mathbf{b}$ for the vector of nodal temperatures $\\mathbf{T} = [T_0, \\dots, T_{N-1}]^T$. This system is solved to find the numerical solution.\n\n### 3. Error Calculation\nSince the numerical scheme is constructed to be an exact analogue of the continuous problem (which has a piecewise linear solution), the numerical solution evaluated at the nodes should be identical to the exact analytical solution evaluated at the same nodes, up to machine floating-point precision. The maximum absolute error, $\\max_i |T_i - T_{\\mathrm{exact}}(x_i)|$, is computed to verify this.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that iterates through test cases and prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1 (happy path)\n        {'L': 1.0, 'N': 129, 'k_minus': 1.0, 'k_plus': 5.0, 's': 0.37, 'T0': 0.0, 'T_L': 1.0},\n        # Test 2 (interface exactly at a node)\n        {'L': 1.0, 'N': 129, 'k_minus': 1.0, 'k_plus': 10.0, 's': 0.5, 'T0': 100.0, 'T_L': 300.0},\n        # Test 3 (extreme conductivity contrast)\n        {'L': 1.0, 'N': 257, 'k_minus': 0.1, 'k_plus': 1000.0, 's': 0.8, 'T0': 10.0, 'T_L': 11.0},\n        # Test 4 (near-face intersection and k-=k+)\n        {'L': 1.0, 'N': 129, 'k_minus': 2.0, 'k_plus': 2.0, 's': 0.499, 'T0': 0.0, 'T_L': 1.0},\n        # Test 5 (interface near boundary)\n        {'L': 1.0, 'N': 129, 'k_minus': 0.5, 'k_plus': 3.5, 's': 0.02, 'T0': 0.0, 'T_L': 1.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        error = compute_error_for_case(**case)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_error_for_case(L, N, k_minus, k_plus, s, T0, T_L):\n    \"\"\"\n    Computes the maximum absolute error for a single test case.\n    \"\"\"\n    # 1. Setup Grid\n    dx = L / (N - 1)\n    x = np.linspace(0.0, L, N)\n\n    # 2. Assemble Linear System Ax = b\n    A = np.zeros((N, N))\n    b = np.zeros(N)\n\n    # Boundary Conditions\n    A[0, 0] = 1.0\n    b[0] = T0\n    A[N - 1, N - 1] = 1.0\n    b[N - 1] = T_L\n\n    # Function to get conductance between nodes i and i+1\n    def get_conductance(i):\n        # Check if interface s is strictly within the interval (x[i], x[i+1])\n        if x[i]  s and x[i+1] > s:\n            # GFM / Series Resistance model for interface-straddling cell\n            dist_minus = s - x[i]\n            dist_plus = x[i+1] - s\n            resistance = dist_minus / k_minus + dist_plus / k_plus\n            return 1.0 / resistance\n        else:\n            # Standard model for cell with constant conductivity\n            # Use conductivity at the face midpoint to decide which k to use.\n            mid_point = (x[i] + x[i+1]) / 2.0\n            k = k_minus if mid_point  s else k_plus\n            return k / dx\n\n    # Interior Nodes: assemble equations from i=1 to N-2\n    for i in range(1, N - 1):\n        # Conductance for flux q_{i-1/2} (between i-1 and i)\n        C_left = get_conductance(i - 1)\n        \n        # Conductance for flux q_{i+1/2} (between i and i+1)\n        C_right = get_conductance(i)\n        \n        A[i, i - 1] = C_left\n        A[i, i] = -(C_left + C_right)\n        A[i, i + 1] = C_right\n        b[i] = 0.0\n\n    # 3. Solve for Numerical Temperature\n    T_num = np.linalg.solve(A, b)\n\n    # 4. Calculate Exact Solution\n    res_minus = s / k_minus if s > 0 else 0.0\n    res_plus = (L - s) / k_plus if s  L else 0.0\n    total_resistance = res_minus + res_plus\n    \n    # Avoid division by zero if total_resistance is 0 (e.g., L=0)\n    q_c = -(T_L - T0) / total_resistance if total_resistance > 0 else 0.0\n\n    # Vectorized calculation of exact temperature at all grid points\n    resistance_at_x = np.where(x = s, x / k_minus, s / k_minus + (x - s) / k_plus)\n    T_exact = T0 - q_c * resistance_at_x\n    \n    # 5. Compute Maximum Absolute Error\n    max_error = np.max(np.abs(T_num - T_exact))\n    \n    return max_error\n\n# Execute the solver\nsolve()\n```", "id": "3607108"}, {"introduction": "One of the most powerful features of implicit interface methods is their natural ability to handle topological changes, such as the merging of two fluid bodies or the splitting of a single one. However, level-set and phase-field methods achieve this in fundamentally different ways. This computational exercise tasks you with simulating the collision and merging of two vortex rings using both models, providing a direct comparison of their dynamics and highlighting their respective strengths and weaknesses in practice. [@problem_id:2408605]", "problem": "Consider two alternative implicit-interface models on a periodic square domain that approximate the collision of two coaxial vortex ring cross-sections by transporting closed curves in a two-dimensional plane. Let the computational domain be the square $\\left[-1,1\\right]\\times\\left[-1,1\\right]$ with periodic boundaries in both directions. Let $N\\times N$ be the uniform grid resolution with grid spacing $\\Delta x=\\Delta y=\\dfrac{2}{N}$. Define a spatially varying, time-independent velocity field $\\mathbf{u}(x,y)=\\left(u_x(x),u_y(x)\\right)$ with\n$$\nu_x(x)=-U\\tanh\\!\\left(\\dfrac{x}{\\delta}\\right),\\quad u_y(x)=0,\n$$\nwhere $U0$ and $\\delta0$ are given constants. Two initial circular interfaces represent the cross-sections of two identical vortex rings: circles of radius $R$ centered at $\\left(-a,0\\right)$ and $\\left(+a,0\\right)$, respectively, with $0Ra1$.\n\nYou must implement and advance in time, up to a specified final time $T$, the following two interface descriptions:\n\n1. Level-set formulation. Let $\\phi(x,y,t)$ be a scalar field whose zero level set represents the interface and whose negative region represents the interior of the “vortex core” set. The evolution is given by the linear advection equation\n$$\n\\partial_t \\phi + \\mathbf{u}\\cdot\\nabla \\phi = 0,\n$$\nwith the initial condition $\\phi(x,y,0)=d(x,y)$ equal to the signed distance to the union of the two initial circles, i.e.,\n$$\nd(x,y)=\\min\\!\\Big(\\sqrt{(x+a)^2+y^2}-R,\\;\\sqrt{(x-a)^2+y^2}-R\\Big),\n$$\nwith $d(x,y)0$ inside either circle.\n\n2. Phase-field formulation (advected Allen–Cahn). Let $c(x,y,t)$ be a scalar order parameter that approximates a diffuse interface with thickness controlled by $\\epsilon0$. The evolution is given by the advected Allen–Cahn equation\n$$\n\\partial_t c + \\mathbf{u}\\cdot\\nabla c = \\dfrac{1}{\\tau}\\Big(\\epsilon^2\\nabla^2 c - f'(c)\\Big),\n$$\nwhere $\\tau0$ is a relaxation time and $f(c)=\\dfrac{1}{2}c^2(1-c)^2$ so that $f'(c)=c(1-c)(1-2c)$. The initial condition is a smooth diffuse representation of the same two circles,\n$$\nc(x,y,0)=\\dfrac{1}{2}\\left(1-\\tanh\\!\\left(\\dfrac{d(x,y)}{\\sqrt{2}\\,\\epsilon}\\right)\\right),\n$$\nso that $c\\approx 1$ inside and $c\\approx 0$ outside.\n\nFor each formulation at time $t=T$, define the binary “core” set\n$$\n\\Omega_{\\mathrm{LS}}(T)=\\{(x,y):\\phi(x,y,T)0\\},\\qquad \\Omega_{\\mathrm{PF}}(T)=\\{(x,y):c(x,y,T)\\tfrac{1}{2}\\}.\n$$\nOn the periodic domain, define the number of connected components of a binary set using $8$-connectivity with periodic wrap-around. To reduce spurious numerical speckles, before counting components, discard any connected component whose area (in number of grid points) is strictly less than $A_{\\min}$, where\n$$\nA_{\\min}=\\left\\lfloor \\theta N^2 \\right\\rfloor,\\quad \\theta=0.002.\n$$\n\nYour task is to compute, for each parameter set in the test suite below, the pair of integers $\\left(C_{\\mathrm{LS}},C_{\\mathrm{PF}}\\right)$, where $C_{\\mathrm{LS}}$ is the number of connected components of $\\Omega_{\\mathrm{LS}}(T)$ and $C_{\\mathrm{PF}}$ is the number of connected components of $\\Omega_{\\mathrm{PF}}(T)$.\n\nTest suite (each case specifies $\\left(N,R,a,U,\\delta,\\epsilon,\\tau,T\\right)$):\n\n- Case $1$: $\\left(96,\\;0.22,\\;0.34,\\;0.40,\\;0.10,\\;0.03,\\;1.0,\\;0.295\\right)$.\n- Case $2$: $\\left(96,\\;0.22,\\;0.34,\\;0.20,\\;0.10,\\;0.02,\\;1.0,\\;0.12\\right)$.\n- Case $3$: $\\left(96,\\;0.22,\\;0.34,\\;0.50,\\;0.10,\\;0.03,\\;1.0,\\;0.35\\right)$.\n\nAll quantities are nondimensional. Angles, if any arise in your implementation, must be in radians.\n\nYour program should produce a single line of output containing the results as a comma-separated list of six integers enclosed in square brackets, in the order\n$$\n\\left[C_{\\mathrm{LS}}^{(1)},C_{\\mathrm{PF}}^{(1)},C_{\\mathrm{LS}}^{(2)},C_{\\mathrm{PF}}^{(2)},C_{\\mathrm{LS}}^{(3)},C_{\\mathrm{PF}}^{(3)}\\right],\n$$\ncorresponding to Cases $1$, $2$, and $3$ in the test suite. For example, an output of the form $\\left[2,1,2,2,1,1\\right]$ indicates two components for the level-set and one component for the phase-field in Case $1$, two and two in Case $2$, and one and one in Case $3$.", "solution": "The problem statement is subjected to validation and is found to be scientifically grounded, well-posed, and complete. It describes a standard numerical experiment in computational engineering, comparing two canonical methods for interface tracking—the level-set and phase-field models. All parameters, equations, and initial and boundary conditions are specified unambiguously, allowing for a unique solution. The problem is valid.\n\nThe solution requires the numerical integration of two partial differential equations (PDEs) on a two-dimensional periodic domain. The governing equations are the linear advection equation for the level-set field $\\phi$ and the advected Allen-Cahn equation for the phase-field order parameter $c$.\n\nFirst, a computational grid is established. The domain $\\left[-1,1\\right]\\times\\left[-1,1\\right]$ is discretized into a uniform grid of $N\\times N$ points, with grid spacing $\\Delta x = \\Delta y = 2/N$. The grid coordinates are defined as $x_i = -1 + i\\Delta x$ and $y_j = -1 + j\\Delta y$ for $i,j \\in \\{0, \\dots, N-1\\}$. The velocity field $\\mathbf{u}(x,y)$, which is purely horizontal, $u_x(x)=-U\\tanh(x/\\delta)$, $u_y=0$, is evaluated at each grid point $x_i$.\n\nThe spatial operators in the PDEs are discretized using finite difference methods that respect the periodic boundary conditions. Periodicity is handled efficiently using `numpy.roll` for shifting grid data.\nThe advection term, $\\mathbf{u}\\cdot\\nabla\\psi = u_x(x)\\partial_x\\psi$, is discretized using a first-order upwind scheme. This choice is crucial for maintaining numerical stability in advection-dominated problems. The scheme computes the spatial derivative $\\partial_x\\psi$ using a backward difference where the velocity $u_x$ is positive and a forward difference where $u_x$ is negative.\nThe Laplacian operator, $\\nabla^2 c$, in the Allen-Cahn equation is discretized using the standard five-point stencil, which is a second-order accurate central difference approximation.\n\nThe time evolution of the fields $\\phi(x,y,t)$ and $c(x,y,t)$ is achieved by integrating the semi-discretized equations (a system of ordinary differential equations in time) from $t=0$ to the final time $T$. A fourth-order Runge-Kutta (RK4) method is employed for this integration due to its high accuracy and favorable stability properties. The time step, $\\Delta t$, must be chosen to satisfy the Courant-Friedrichs-Lewy (CFL) stability conditions for both the advection and diffusion processes across all parameter sets. A conservative global $\\Delta t$ is calculated based on the most restrictive conditions: $\\Delta t \\le \\nu \\cdot \\min(\\Delta x/U_{max}, \\tau (\\Delta x)^2/(4\\epsilon_{min}^2))$, where a safety factor $\\nu  1$ is used.\n\nThe evolution process for a single test case is as follows:\n1. Initialize the fields $\\phi_0 = \\phi(x,y,0)$ and $c_0 = c(x,y,0)$ on the grid according to the provided initial condition formulas, which are based on the signed distance function $d(x,y)$ to the initial pair of circles.\n2. For each model (level-set and phase-field), integrate forward in time using the RK4 scheme until $t=T$.\n3. At $t=T$, create the binary core sets $\\Omega_{\\mathrm{LS}}(T)$ and $\\Omega_{\\mathrm{PF}}(T)$ by applying the specified thresholds: $\\phi(x,y,T)  0$ and $c(x,y,T)  1/2$, respectively.\n\nThe final step is to count the number of connected components for each binary set, subject to two key constraints: periodic boundaries and a minimum area filter.\nStandard connected component algorithms, such as `scipy.ndimage.label`, do not inherently handle periodic connections. A correct implementation for a periodic domain is therefore required. The procedure is as follows:\n1. Apply the standard `scipy.ndimage.label` with $8$-connectivity to the binary mask, which assigns a unique integer label to each non-periodic component.\n2. Create a Disjoint Set Union (DSU) data structure to track the merging of labels that are connected across the periodic boundaries.\n3. Iterate over the pixels on the domain boundaries (e.g., $x= -1$ and $y=-1$). For each pixel belonging to a component, check its eight neighbors in the periodic sense. If a neighbor belongs to a component with a different label, the two labels are merged using the DSU `union` operation.\n4. After processing all boundary pixels, the DSU structure contains the equivalence classes of labels that form true periodic components.\n5. Calculate the total area of each periodic component by summing the areas (pixel counts) of all its constituent labels. Pixel counts for initial labels are efficiently obtained using `numpy.bincount`.\n6. Finally, count the number of merged components whose total area is greater than or equal to the minimum area threshold, $A_{\\min} = \\lfloor \\theta N^2 \\rfloor$. This yields the final component counts, $C_{\\mathrm{LS}}$ and $C_{\\mathrm{PF}}$.\n\nThis entire process is repeated for each of the three parameter sets provided in the test suite, and the six resulting integers are formatted into the required output string.", "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import label\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to solve the vortex collision problem for all test cases.\n    \"\"\"\n\n    # --- Data structure for periodic component merging ---\n    class DSU:\n        def __init__(self, n):\n            self.parent = list(range(n))\n        def find(self, i):\n            if self.parent[i] == i:\n                return i\n            self.parent[i] = self.find(self.parent[i])\n            return self.parent[i]\n        def union(self, i, j):\n            root_i = self.find(i)\n            root_j = self.find(j)\n            if root_i != root_j:\n                self.parent[root_j] = root_i\n\n    # --- Periodic connected component counting function ---\n    def count_components_periodic(mask, N, theta):\n        s = np.ones((3, 3), dtype=int)  # 8-connectivity\n        labeled_array, num_features = label(mask, structure=s, output=np.int32)\n\n        if num_features == 0:\n            return 0\n\n        dsu = DSU(num_features + 1)\n        \n        # Check connections across periodic boundaries (8-connectivity)\n        # Left-Right boundary\n        for i in range(N):\n            if mask[i, 0]:\n                label_left = labeled_array[i, 0]\n                # Neighbors of (i, 0) across the boundary are at x = -1 (N-1)\n                for i_offset in [-1, 0, 1]:\n                    ni = (i + i_offset + N) % N\n                    if mask[ni, -1]:\n                        dsu.union(label_left, labeled_array[ni, -1])\n        \n        # Top-Bottom boundary\n        for j in range(N):\n            if mask[0, j]:\n                label_top = labeled_array[0, j]\n                # Neighbors of (0, j) across the boundary are at y = -1 (N-1)\n                for j_offset in [-1, 0, 1]:\n                    nj = (j + j_offset + N) % N\n                    if mask[-1, nj]:\n                        dsu.union(label_top, labeled_array[-1, nj])\n\n        # Calculate areas of merged components\n        pixel_counts = np.bincount(labeled_array.ravel())\n        root_areas = {}\n        for i in range(1, num_features + 1):\n            if pixel_counts[i] > 0:\n                root = dsu.find(i)\n                if root not in root_areas:\n                    root_areas[root] = 0\n                root_areas[root] += pixel_counts[i]\n\n        # Filter by area\n        A_min = math.floor(theta * N**2)\n        valid_components = sum(1 for area in root_areas.values() if area >= A_min)\n        \n        return valid_components\n\n    # --- PDE Solver for a single case ---\n    def solve_single_case(params):\n        N, R, a, U, delta, epsilon, tau, T = params\n        theta = 0.002\n        \n        # Grid setup\n        dx = 2.0 / N\n        grid_pts = np.linspace(-1, 1, N, endpoint=False)\n        x, y = np.meshgrid(grid_pts, grid_pts)\n\n        # Velocity field\n        ux = -U * np.tanh(x / delta)\n\n        # Initial conditions\n        d = np.minimum(np.sqrt((x + a)**2 + y**2) - R, np.sqrt((x - a)**2 + y**2) - R)\n        phi0 = d\n        c0 = 0.5 * (1.0 - np.tanh(d / (np.sqrt(2.0) * epsilon)))\n        \n        # --- Spatial operators ---\n        inv_dx = 1.0 / dx\n        inv_dx2 = 1.0 / (dx**2)\n\n        def advection(field, u_field):\n            grad_fwd = (np.roll(field, -1, axis=1) - field) * inv_dx\n            grad_bwd = (field - np.roll(field, 1, axis=1)) * inv_dx\n            return np.where(u_field >= 0, u_field * grad_bwd, u_field * grad_fwd)\n\n        def laplacian(field):\n            return (np.roll(field, -1, axis=1) + np.roll(field, 1, axis=1) +\n                    np.roll(field, -1, axis=0) + np.roll(field, 1, axis=0) - 4 * field) * inv_dx2\n\n        # --- RHS of PDEs for RK4 ---\n        def rhs_ls(phi):\n            return -advection(phi, ux)\n\n        def rhs_pf(c):\n            f_prime = c * (1.0 - c) * (1.0 - 2.0 * c)\n            adv = advection(c, ux)\n            reaction_diffusion = (1.0 / tau) * (epsilon**2 * laplacian(c) - f_prime)\n            return -adv + reaction_diffusion\n            \n        # --- RK4 Time Stepper ---\n        def rk4_step(field, rhs_func, dt):\n            k1 = rhs_func(field)\n            k2 = rhs_func(field + 0.5 * dt * k1)\n            k3 = rhs_func(field + 0.5 * dt * k2)\n            k4 = rhs_func(field + dt * k3)\n            return field + (dt / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n\n        # CFL-based time step\n        dt_adv = dx / U\n        dt_diff = tau * dx**2 / (4 * epsilon**2)\n        dt = 0.25 * min(dt_adv, dt_diff)\n        \n        # --- Time integration loop ---\n        # Level-Set\n        phi = np.copy(phi0)\n        t = 0.0\n        while t  T:\n            current_dt = min(dt, T - t)\n            phi = rk4_step(phi, rhs_ls, current_dt)\n            t += current_dt\n\n        # Phase-Field\n        c = np.copy(c0)\n        t = 0.0\n        while t  T:\n            current_dt = min(dt, T - t)\n            c = rk4_step(c, rhs_pf, current_dt)\n            t += current_dt\n        \n        # --- Component Counting ---\n        mask_ls = phi  0\n        mask_pf = c > 0.5\n        \n        C_LS = count_components_periodic(mask_ls, N, theta)\n        C_PF = count_components_periodic(mask_pf, N, theta)\n\n        return C_LS, C_PF\n\n    # --- Test Suite ---\n    test_cases = [\n        (96, 0.22, 0.34, 0.40, 0.10, 0.03, 1.0, 0.295),\n        (96, 0.22, 0.34, 0.20, 0.10, 0.02, 1.0, 0.12),\n        (96, 0.22, 0.34, 0.50, 0.10, 0.03, 1.0, 0.35),\n    ]\n\n    results = []\n    for params in test_cases:\n        C_LS, C_PF = solve_single_case(params)\n        results.extend([C_LS, C_PF])\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2408605"}]}