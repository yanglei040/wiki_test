{"hands_on_practices": [{"introduction": "Geological formations, such as layered sedimentary rocks or fractured systems, rarely exhibit uniform hydraulic properties in all directions. This property, known as anisotropy, is a fundamental characteristic of most natural porous media. This practice [@problem_id:3614543] provides a foundational exercise in applying Darcy's law, $\\mathbf{q} = -K \\nabla h$, in an anisotropic setting by requiring the direct calculation of the flux vector. Mastering the tensor rotation of the hydraulic conductivity matrix $K$ is an essential prerequisite for developing or using any numerical model intended to simulate flow in realistic geological environments.", "problem": "Consider a two-dimensional, homogeneous, saturated aquifer under single-phase groundwater flow. Assume constant fluid density and viscosity, negligible inertial effects, and steady-state conditions. Let the hydraulic conductivity be anisotropic, with principal conductivities aligned to a coordinate frame obtained by rotating the global $x$–$y$ frame counterclockwise by an angle $\\theta$ about the out-of-plane axis. The hydraulic conductivity tensor in the global frame is given by $K = R \\Lambda R^{\\top}$, where $R$ is the rotation matrix and $\\Lambda$ is the diagonal matrix of principal conductivities.\n\nStarting from Darcy’s law for saturated single-phase flow and the tensor transformation of second-order material properties, derive the global-frame flux for a specified configuration and compute its numerical value without rounding. Use the International System of Units (SI).\n\nData:\n- Rotation angle $\\theta = \\pi/6$.\n- Rotation matrix $R = \\begin{pmatrix}\\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta\\end{pmatrix}$.\n- Principal hydraulic conductivities $\\Lambda = \\operatorname{diag}(k_1, k_2)$ with $k_1 = 1.0 \\times 10^{-4}$ and $k_2 = 4.0 \\times 10^{-5}$ (units: meters per second).\n- Constant hydraulic head gradient $\\nabla h = \\begin{pmatrix}2.0 \\times 10^{-2} \\\\ -1.0 \\times 10^{-2}\\end{pmatrix}$ (units: dimensionless per meter, since hydraulic head is in meters).\n\nTask:\n1. Using the fundamental constitutive relation of Darcy’s law and proper tensor rotation, derive the global-frame hydraulic conductivity components in terms of $\\theta$, $k_1$, and $k_2$, then specialize to $\\theta = \\pi/6$.\n2. Compute the global-frame flux $\\mathbf{q}$ associated with the given $\\nabla h$ via Darcy’s law.\n\nExpress the final flux components in meters per second, exactly (no rounding). Provide your final answer as the two components of $\\mathbf{q}$.", "solution": "The user's request is to solve a two-dimensional, anisotropic, steady-state groundwater flow problem.\n\n### Step 1: Extract Givens\n- **Physical System**: A two-dimensional, homogeneous, saturated aquifer.\n- **Flow Conditions**: Single-phase groundwater flow, constant fluid density and viscosity, negligible inertial effects, steady-state.\n- **Anisotropy**: The principal conductivities are aligned with a coordinate frame rotated by an angle $\\theta$ counterclockwise from the global $x$–$y$ frame.\n- **Rotation Angle**: $\\theta = \\pi/6$.\n- **Rotation Matrix**: $R = \\begin{pmatrix}\\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta\\end{pmatrix}$.\n- **Principal Hydraulic Conductivities**: $\\Lambda = \\operatorname{diag}(k_1, k_2)$, with $k_1 = 1.0 \\times 10^{-4}$ m/s and $k_2 = 4.0 \\times 10^{-5}$ m/s.\n- **Hydraulic Conductivity Tensor (Global Frame)**: $K = R \\Lambda R^{\\top}$.\n- **Hydraulic Head Gradient (Global Frame)**: $\\nabla h = \\begin{pmatrix}2.0 \\times 10^{-2} \\\\ -1.0 \\times 10^{-2}\\end{pmatrix}$ (dimensionless).\n- **Constitutive Law**: Darcy's law for anisotropic media, $\\mathbf{q} = -K \\nabla h$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is evaluated against the validation criteria:\n- **Scientifically Grounded**: The problem is based on Darcy's law and the principles of tensor transformation for material properties, which are foundational concepts in hydrogeology and continuum mechanics. The physical scenario is a standard representation of anisotropic groundwater flow. The given numerical values are physically plausible for typical aquifer materials.\n- **Well-Posed**: The problem provides a complete set of data and a clear objective: to compute the flux vector $\\mathbf{q}$. The relationship $\\mathbf{q} = -K \\nabla h$ ensures that a unique solution exists and can be directly calculated.\n- **Objective**: The problem is stated using precise, unambiguous scientific language.\n- **Completeness and Consistency**: All necessary parameters ($k_1$, $k_2$, $\\theta$, $\\nabla h$) are provided. The units are given in the International System of Units (SI) and are consistent throughout. The formulation does not contain internal contradictions.\n- **Other Flaws**: The problem is not unrealistic, ill-posed, pseudo-profound, or unverifiable. It is a standard, well-defined physics problem.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. A solution will be provided.\n\n### Solution Derivation\n\nThe task is to compute the global-frame flux vector $\\mathbf{q}$, which is defined by Darcy's law for an anisotropic medium:\n$$\n\\mathbf{q} = -K \\nabla h\n$$\nwhere $\\mathbf{q}$ is the specific discharge vector (flux), $K$ is the hydraulic conductivity tensor in the global frame, and $\\nabla h$ is the hydraulic head gradient vector in the global frame.\n\nThe solution proceeds in two parts as requested.\n\n**Part 1: Derive the global-frame hydraulic conductivity tensor $K$.**\n\nThe hydraulic conductivity tensor $K$ in the global $x$–$y$ frame is obtained by rotating the diagonal tensor of principal conductivities, $\\Lambda$, from the principal coordinate system. The transformation rule is given as $K = R \\Lambda R^{\\top}$.\n\nThe matrices are:\n$$\nR = \\begin{pmatrix}\\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta\\end{pmatrix}\n$$\n$$\n\\Lambda = \\begin{pmatrix}k_1 & 0 \\\\ 0 & k_2\\end{pmatrix}\n$$\n$$\nR^{\\top} = \\begin{pmatrix}\\cos\\theta & \\sin\\theta \\\\ -\\sin\\theta & \\cos\\theta\\end{pmatrix}\n$$\n\nFirst, we compute the product $R\\Lambda$:\n$$\nR\\Lambda = \\begin{pmatrix}\\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta\\end{pmatrix} \\begin{pmatrix}k_1 & 0 \\\\ 0 & k_2\\end{pmatrix} = \\begin{pmatrix}k_1\\cos\\theta & -k_2\\sin\\theta \\\\ k_1\\sin\\theta & k_2\\cos\\theta\\end{pmatrix}\n$$\nNext, we multiply this result by $R^{\\top}$ to find $K$:\n$$\nK = (R\\Lambda)R^{\\top} = \\begin{pmatrix}k_1\\cos\\theta & -k_2\\sin\\theta \\\\ k_1\\sin\\theta & k_2\\cos\\theta\\end{pmatrix} \\begin{pmatrix}\\cos\\theta & \\sin\\theta \\\\ -\\sin\\theta & \\cos\\theta\\end{pmatrix}\n$$\nPerforming the matrix multiplication yields the components of $K = \\begin{pmatrix}K_{11} & K_{12} \\\\ K_{21} & K_{22}\\end{pmatrix}$:\n$$\nK_{11} = (k_1\\cos\\theta)(\\cos\\theta) + (-k_2\\sin\\theta)(-\\sin\\theta) = k_1\\cos^{2}\\theta + k_2\\sin^{2}\\theta\n$$\n$$\nK_{12} = (k_1\\cos\\theta)(\\sin\\theta) + (-k_2\\sin\\theta)(\\cos\\theta) = (k_1 - k_2)\\sin\\theta\\cos\\theta\n$$\n$$\nK_{21} = (k_1\\sin\\theta)(\\cos\\theta) + (k_2\\cos\\theta)(-\\sin\\theta) = (k_1 - k_2)\\sin\\theta\\cos\\theta\n$$\n$$\nK_{22} = (k_1\\sin\\theta)(\\sin\\theta) + (k_2\\cos\\theta)(\\cos\\theta) = k_1\\sin^{2}\\theta + k_2\\cos^{2}\\theta\n$$\nThis gives the general analytical expression for the components of the global-frame hydraulic conductivity tensor.\n\nNow, we specialize to the given angle $\\theta = \\pi/6$:\n- $\\sin(\\pi/6) = 1/2$\n- $\\cos(\\pi/6) = \\sqrt{3}/2$\n- $\\sin^{2}(\\pi/6) = (1/2)^2 = 1/4$\n- $\\cos^{2}(\\pi/6) = (\\sqrt{3}/2)^2 = 3/4$\n- $\\sin(\\pi/6)\\cos(\\pi/6) = (1/2)(\\sqrt{3}/2) = \\sqrt{3}/4$\n\nSubstituting these into the components of $K$:\n$$\nK_{11} = k_1(\\frac{3}{4}) + k_2(\\frac{1}{4}) = \\frac{3k_1 + k_2}{4}\n$$\n$$\nK_{12} = K_{21} = (k_1 - k_2)\\frac{\\sqrt{3}}{4}\n$$\n$$\nK_{22} = k_1(\\frac{1}{4}) + k_2(\\frac{3}{4}) = \\frac{k_1 + 3k_2}{4}\n$$\nNow, we substitute the numerical values for the principal conductivities, $k_1 = 1.0 \\times 10^{-4}$ m/s and $k_2 = 4.0 \\times 10^{-5}$ m/s:\n$$\nK_{11} = \\frac{3(1.0 \\times 10^{-4}) + (4.0 \\times 10^{-5})}{4} = \\frac{3.0 \\times 10^{-4} + 0.4 \\times 10^{-4}}{4} = \\frac{3.4 \\times 10^{-4}}{4} = 0.85 \\times 10^{-4} \\text{ m/s}\n$$\n$$\nK_{12} = K_{21} = \\frac{(1.0 \\times 10^{-4} - 4.0 \\times 10^{-5})\\sqrt{3}}{4} = \\frac{(0.6 \\times 10^{-4})\\sqrt{3}}{4} = 0.15\\sqrt{3} \\times 10^{-4} \\text{ m/s}\n$$\n$$\nK_{22} = \\frac{(1.0 \\times 10^{-4}) + 3(4.0 \\times 10^{-5})}{4} = \\frac{1.0 \\times 10^{-4} + 1.2 \\times 10^{-4}}{4} = \\frac{2.2 \\times 10^{-4}}{4} = 0.55 \\times 10^{-4} \\text{ m/s}\n$$\nThus, the hydraulic conductivity tensor in the global frame is:\n$$\nK = \\begin{pmatrix} 0.85 \\times 10^{-4} & 0.15\\sqrt{3} \\times 10^{-4} \\\\ 0.15\\sqrt{3} \\times 10^{-4} & 0.55 \\times 10^{-4} \\end{pmatrix} \\text{ m/s}\n$$\n\n**Part 2: Compute the global-frame flux $\\mathbf{q}$.**\n\nWe use Darcy's law, $\\mathbf{q} = -K \\nabla h$, with the calculated tensor $K$ and the given gradient $\\nabla h = \\begin{pmatrix} 2.0 \\times 10^{-2} \\\\ -1.0 \\times 10^{-2} \\end{pmatrix}$.\nLet $\\mathbf{q} = \\begin{pmatrix} q_x \\\\ q_y \\end{pmatrix}$.\n$$\n\\begin{pmatrix} q_x \\\\ q_y \\end{pmatrix} = -\\begin{pmatrix} 0.85 \\times 10^{-4} & 0.15\\sqrt{3} \\times 10^{-4} \\\\ 0.15\\sqrt{3} \\times 10^{-4} & 0.55 \\times 10^{-4} \\end{pmatrix} \\begin{pmatrix} 2.0 \\times 10^{-2} \\\\ -1.0 \\times 10^{-2} \\end{pmatrix}\n$$\nWe compute the components $q_x$ and $q_y$:\n$$\nq_x = - \\left[ (0.85 \\times 10^{-4})(2.0 \\times 10^{-2}) + (0.15\\sqrt{3} \\times 10^{-4})(-1.0 \\times 10^{-2}) \\right]\n$$\n$$\nq_x = - \\left[ 1.7 \\times 10^{-6} - 0.15\\sqrt{3} \\times 10^{-6} \\right] = - (1.7 - 0.15\\sqrt{3}) \\times 10^{-6} = (0.15\\sqrt{3} - 1.7) \\times 10^{-6} \\text{ m/s}\n$$\nThe multiplier is $0.15\\sqrt{3} - 1.7 \\approx 0.2598 - 1.7 = -1.4402$. Since $1 \\le |-1.4402| < 10$, this expression is in standard scientific notation.\n\n$$\nq_y = - \\left[ (0.15\\sqrt{3} \\times 10^{-4})(2.0 \\times 10^{-2}) + (0.55 \\times 10^{-4})(-1.0 \\times 10^{-2}) \\right]\n$$\n$$\nq_y = - \\left[ 0.3\\sqrt{3} \\times 10^{-6} - 0.55 \\times 10^{-6} \\right] = - (0.3\\sqrt{3} - 0.55) \\times 10^{-6} = (0.55 - 0.3\\sqrt{3}) \\times 10^{-6} \\text{ m/s}\n$$\nTo express this in standard scientific notation, where the leading coefficient's absolute value is between $1$ and $10$, we evaluate the coefficient: $0.55 - 0.3\\sqrt{3} \\approx 0.55 - 0.5196 = 0.0304$. This is not in the required range. We adjust the exponent:\n$$\nq_y = (0.55 - 0.3\\sqrt{3}) \\times 10^{-6} = (55 - 30\\sqrt{3}) \\times 10^{-8} \\text{ m/s}\n$$\nThe new multiplier is $55 - 30\\sqrt{3} \\approx 55 - 51.96 = 3.04$. Since $1 \\le |3.04| < 10$, this is the correct standard scientific notation.\n\nThe final components of the flux vector are:\n$q_x = (0.15\\sqrt{3} - 1.7) \\times 10^{-6}$ m/s\n$q_y = (55 - 30\\sqrt{3}) \\times 10^{-8}$ m/s", "answer": "$$\n\\boxed{\\begin{pmatrix} (0.15\\sqrt{3} - 1.7) \\times 10^{-6} \\\\ (55 - 30\\sqrt{3}) \\times 10^{-8} \\end{pmatrix}}\n$$", "id": "3614543"}, {"introduction": "One of the most significant challenges in subsurface flow simulation is the accurate representation of spatial heterogeneity, particularly the sharp contrasts in material properties found at the boundaries between different geological units. This hands-on coding exercise [@problem_id:3614550] guides you through a controlled numerical experiment to compare the performance of finite difference and finite element methods in a high-contrast, checkerboard conductivity field. By implementing and evaluating different averaging schemes for interface conductivity, such as arithmetic and harmonic means, you will gain critical insight into the sources of numerical error and the importance of choosing physically appropriate discretization strategies.", "problem": "You are to investigate, by first-principles derivation and controlled computation, how a checkerboard spatial variability of hydraulic conductivity affects the accuracy of two classical discretizations of steady single-phase groundwater flow: a cell-centered two-point flux finite difference (often equivalent to a finite volume on a Cartesian mesh) and a conforming linear finite element method on triangles. You must quantify the impact of conductivity averaging and mesh alignment on solution quality, and demonstrate a remedy.\n\nFundamental base. Start from the law of mass conservation and Darcy’s law. In a saturated, single-phase, incompressible medium, mass conservation in the absence of volumetric storage reads $$\\nabla \\cdot \\boldsymbol{q} = s,$$ where $\\boldsymbol{q}$ is the volumetric flux (specific discharge) in $\\mathrm{m/s}$ and $s$ is a volumetric source term in $\\mathrm{s}^{-1}$ that is positive for injection. Darcy’s law for isotropic media gives $$\\boldsymbol{q} = -K(\\boldsymbol{x}) \\nabla h,$$ where $K(\\boldsymbol{x})$ is hydraulic conductivity in $\\mathrm{m}/\\mathrm{s}$ and $h$ is hydraulic head in $\\mathrm{m}$. Combining both yields the second-order elliptic boundary value problem in divergence form $$-\\nabla \\cdot \\left( K(\\boldsymbol{x}) \\nabla h(\\boldsymbol{x}) \\right) = s(\\boldsymbol{x}).$$ For this problem, set the source term to zero, $$s(\\boldsymbol{x}) = 0,$$ and impose Dirichlet boundary conditions $$h(\\boldsymbol{x}) = h_D(\\boldsymbol{x}) \\text{ on } \\partial \\Omega,$$ with a prescribed boundary head $h_D$.\n\nDomain and boundary data. Let the domain be the unit square $$\\Omega = [0,1] \\times [0,1] \\text{ in } \\mathrm{m},$$ with Dirichlet boundary condition $$h_D(x,y) = 1 - x \\text{ in } \\mathrm{m}.$$ This boundary condition enforces a horizontal hydraulic gradient from left to right.\n\nHydraulic conductivity field. Define a “checkerboard” hydraulic conductivity as a piecewise constant, square-tiled field with two values $K_{\\mathrm{high}}$ and $K_{\\mathrm{low}}$ alternating in both $x$ and $y$. Partition $[0,1]$ into $m_c$ equal intervals in each direction; each square tile thus has side length $$\\ell = 1/m_c \\text{ in } \\mathrm{m}.$$ For a given offset $(\\delta_x,\\delta_y)$ with $0 \\le \\delta_x,\\delta_y < \\ell$, define $$\\tilde{x} = (x + \\delta_x) \\bmod 1, \\quad \\tilde{y} = (y + \\delta_y) \\bmod 1,$$ and tile indices $$i = \\left\\lfloor m_c \\tilde{x} \\right\\rfloor, \\quad j = \\left\\lfloor m_c \\tilde{y} \\right\\rfloor.$$ Then set $$K(x,y) = \\begin{cases} K_{\\mathrm{high}}, & \\text{if } (i + j) \\bmod 2 = 0, \\\\ K_{\\mathrm{low}}, & \\text{if } (i + j) \\bmod 2 = 1. \\end{cases}$$\n\nDiscretizations to compare.\n\n- Cell-centered two-point flux finite difference. Consider a uniform Cartesian grid with $N_x$ by $N_y$ rectangular cells, each of size $$\\Delta x = 1/N_x, \\quad \\Delta y = 1/N_y \\text{ in } \\mathrm{m}.$$ Unknowns are cell-centered heads $h_{i,j}$ for $i = 0,\\dots,N_x-1$, $j=0,\\dots,N_y-1$. Fluxes across faces use two-point transmissibilities with face hydraulic conductivity $K_f$ computed by either arithmetic average $$K_f^{\\mathrm{arith}} = \\frac{1}{2}\\left(K_L + K_R\\right)$$ or harmonic average $$K_f^{\\mathrm{harm}} = \\left(\\frac{1}{2}\\left(\\frac{1}{K_L} + \\frac{1}{K_R}\\right)\\right)^{-1},$$ where $K_L$ and $K_R$ are the conductivities of the two adjacent cells. Boundary faces use one-sided transmissibilities consistent with a half-cell distance ($\\Delta x/2$ or $\\Delta y/2$) and the cell’s own conductivity. Dirichlet boundary conditions $h_D$ are incorporated into the right-hand side via face transmissibilities. This yields a sparse linear system $$\\mathbf{A}_{\\mathrm{FD}} \\mathbf{h}_{\\mathrm{FD}} = \\mathbf{b}_{\\mathrm{FD}}.$$\n\n- Conforming linear finite element method on a right-triangle mesh. Subdivide a uniform $(N_x \\times N_y)$ grid of squares into $2N_x N_y$ right triangles by the fixed diagonal. Let $P_1$ basis functions be defined at vertices (nodes). The stiffness matrix is assembled elementwise from $$a(u,v) = \\int_{\\Omega} K \\nabla u \\cdot \\nabla v \\, \\mathrm{d}\\Omega,$$ approximating $K$ by its value at the element centroid. Apply Dirichlet conditions strongly by overwriting boundary rows and right-hand side with $h_D$ values. This yields $$\\mathbf{A}_{\\mathrm{FE}} \\mathbf{h}_{\\mathrm{FE}} = \\mathbf{b}_{\\mathrm{FE}}.$$\n\nReference solution. Since a closed-form solution is not available for discontinuous $K$, define as a reference a fine-mesh finite element solution on a uniform $(N_x^{\\mathrm{ref}} \\times N_y^{\\mathrm{ref}})$ grid with $N_x^{\\mathrm{ref}}$ and $N_y^{\\mathrm{ref}}$ integer multiples of the coarse $N_x$ and $N_y$.\n\nError metrics. For any discrete field $\\hat{h}$ and a reference field $h^{\\mathrm{ref}}$, define the discrete approximation to the continuous $\\mathrm{L}^2$ error norm by a Riemann sum. For the cell-centered finite difference unknowns at cell centers $(x_{i+1/2},y_{j+1/2})$ with uniform area $\\Delta x \\Delta y$, define $$E_{\\mathrm{FD}} = \\left( \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\left( \\hat{h}_{i,j} - h^{\\mathrm{ref}}(x_{i+1/2}, y_{j+1/2}) \\right)^2 \\, \\Delta x \\Delta y \\right)^{1/2} \\text{ in } \\mathrm{m}.$$ For the finite element nodal unknowns at nodes $(x_p,y_p)$, approximate $$E_{\\mathrm{FE}} = \\left( \\sum_{p=1}^{N_{\\mathrm{nodes}}} \\left( \\hat{h}_p - h^{\\mathrm{ref}}(x_p, y_p) \\right)^2 \\, w \\right)^{1/2} \\text{ in } \\mathrm{m},$$ with uniform nodal weight $$w = \\frac{|\\Omega|}{N_{\\mathrm{nodes}}} = \\frac{1}{N_{\\mathrm{nodes}}} \\text{ in } \\mathrm{m}^2.$$\n\nTests. Use the following parameterized tests, each with the same coarse grid and reference grid:\n\n- Coarse grid for both finite difference and finite element: $$N_x = N_y = 16.$$\n- Reference finite element grid: $$N_x^{\\mathrm{ref}} = N_y^{\\mathrm{ref}} = 64.$$\n- Checkerboard tiling count: $$m_c = 8.$$\n\nThree tests are to be run:\n\n- Test A (aligned, high contrast): $$K_{\\mathrm{high}} = 10^{-3} \\text{ in } \\mathrm{m}/\\mathrm{s}, \\quad K_{\\mathrm{low}} = 10^{-6} \\text{ in } \\mathrm{m}/\\mathrm{s}, \\quad (\\delta_x,\\delta_y) = (0,0).$$\n- Test B (misaligned, high contrast): $$K_{\\mathrm{high}} = 10^{-3} \\text{ in } \\mathrm{m}/\\mathrm{s}, \\quad K_{\\mathrm{low}} = 10^{-6} \\text{ in } \\mathrm{m}/\\mathrm{s}, \\quad (\\delta_x,\\delta_y) = \\left(\\frac{1}{2 m_c}, 0\\right).$$\n- Test C (aligned, low contrast): $$K_{\\mathrm{high}} = 10^{-4} \\text{ in } \\mathrm{m}/\\mathrm{s}, \\quad K_{\\mathrm{low}} = 10^{-5} \\text{ in } \\mathrm{m}/\\mathrm{s}, \\quad (\\delta_x,\\delta_y) = (0,0).$$\n\nFor each test, compute three errors:\n\n- $$E_{\\mathrm{FD}}^{\\mathrm{arith}}$$ using the arithmetic face conductivity in the finite difference method,\n- $$E_{\\mathrm{FD}}^{\\mathrm{harm}}$$ using the harmonic face conductivity in the finite difference method,\n- $$E_{\\mathrm{FE}}$$ for the coarse finite element solution.\n\nFinal output format. Your program must produce a single line containing a Python-style list of $9$ floating-point numbers in meters, ordered as $$\\left[ E_{\\mathrm{FD}}^{\\mathrm{arith}}(\\text{A}), E_{\\mathrm{FD}}^{\\mathrm{harm}}(\\text{A}), E_{\\mathrm{FE}}(\\text{A}), E_{\\mathrm{FD}}^{\\mathrm{arith}}(\\text{B}), E_{\\mathrm{FD}}^{\\mathrm{harm}}(\\text{B}), E_{\\mathrm{FE}}(\\text{B}), E_{\\mathrm{FD}}^{\\mathrm{arith}}(\\text{C}), E_{\\mathrm{FD}}^{\\mathrm{harm}}(\\text{C}), E_{\\mathrm{FE}}(\\text{C}) \\right],$$ without additional text. All reported values must be in $\\mathrm{m}$.\n\nYour program must be a complete, runnable implementation that constructs the two discretizations, assembles and solves the resulting linear systems, constructs the reference finite element solution, evaluates the reference at required locations, computes the $\\mathrm{L}^2$ errors as specified, and prints the list in the exact required format. No user input is permitted; all parameters are fixed as stated above.", "solution": "The user has provided a well-posed problem in computational geophysics, specifically concerning the numerical simulation of single-phase groundwater flow. The task requires a comparison of two standard discretization schemes—a cell-centered finite difference (FD) method and a conforming linear finite element (FE) method—in the presence of a discontinuous, checkerboard-patterned hydraulic conductivity field $K(\\boldsymbol{x})$. The core of the problem lies in quantifying the numerical error introduced by the discretization of the elliptic operator $-\\nabla \\cdot (K \\nabla h)$ when $K$ is discontinuous, and how different numerical treatments affect the accuracy.\n\nThe problem is valid as it is scientifically grounded in the principles of mass conservation and Darcy's law, is mathematically well-posed, and all parameters and conditions are explicitly defined. We will proceed with a full solution.\n\nThe solution methodology involves the following principled steps:\n1.  **Reference Solution**: A highly accurate numerical solution is required to serve as a proxy for the true analytical solution, which is unavailable. We will compute this reference solution using the finite element method on a fine grid ($N_x^{\\mathrm{ref}} = N_y^{\\mathrm{ref}} = 64$), as specified. The resulting piecewise linear field, $h^{\\mathrm{ref}}$, can be evaluated at any point in the domain via barycentric interpolation. We will use `scipy.interpolate.LinearNDInterpolator` for this purpose.\n\n2.  **Finite Element (FE) Implementation**: We will implement a standard $P_1$ conforming finite element method. The domain $\\Omega = [0,1]^2$ is meshed by first creating a grid of $N_x \\times N_y$ squares and then subdividing each square into two right triangles using a consistent diagonal.\n    -   The weak form of the governing equation, $-\\nabla \\cdot (K \\nabla h) = 0$, is $a(h, v) = 0$ for all valid test functions $v$, where the bilinear form is $a(u,v) = \\int_{\\Omega} K(\\boldsymbol{x}) \\nabla u \\cdot \\nabla v \\, d\\Omega$.\n    -   The discrete problem is $\\mathbf{A}_{\\mathrm{FE}} \\mathbf{h}_{\\mathrm{FE}} = \\mathbf{b}_{\\mathrm{FE}}$. The stiffness matrix $\\mathbf{A}_{\\mathrm{FE}}$ is assembled by looping over each triangular element $e$, computing the local $3 \\times 3$ stiffness matrix $\\mathbf{A}_e$, and adding its entries to the global matrix.\n    -   The entries of the local stiffness matrix are given by $(\\mathbf{A}_e)_{ij} = \\int_e K_e \\nabla \\phi_i \\cdot \\nabla \\phi_j \\, d\\Omega$, where $\\phi_i$ are the linear basis functions. Since $\\nabla \\phi_i$ are constant on each element, this simplifies to $(\\mathbf{A}_e)_{ij} = K_e (\\nabla \\phi_i \\cdot \\nabla \\phi_j) \\mathrm{Area}(e)$. As per the problem, the conductivity $K_e$ is approximated as constant over the element, using its value at the element's centroid.\n    -   Dirichlet boundary conditions, $h(\\boldsymbol{x}) = 1-x$, are applied \"strongly\" by directly modifying the rows of $\\mathbf{A}_{\\mathrm{FE}}$ and the corresponding entries of $\\mathbf{b}_{\\mathrm{FE}}$ for all boundary nodes.\n\n3.  **Finite Difference (FD) Implementation**: A cell-centered, two-point flux approximation finite difference scheme is implemented on a uniform $N_x \\times N_y$ Cartesian grid.\n    -   Integrating the governing equation over a control volume (a cell) $(i,j)$ of size $\\Delta x \\times \\Delta y$ and applying the divergence theorem yields $\\int_{\\partial C_{ij}} \\boldsymbol{q} \\cdot \\boldsymbol{n} \\, dS = 0$. This states that the net flux across the cell boundaries is zero.\n    -   The flux across each of the four faces is approximated using a two-point stencil. For example, the flux across the east face between cell $(i,j)$ and $(i+1,j)$ is $q_E \\approx - K_f \\frac{h_{i+1,j} - h_{i,j}}{\\Delta x}$, where $h_{i,j}$ is the head at the center of cell $(i,j)$ and $K_f$ is the hydraulic conductivity at the face.\n    -   The critical choice is the method for averaging the conductivities of the adjacent cells, $K_L$ and $K_R$, to obtain $K_f$. We will implement two methods:\n        -   **Arithmetic mean**: $K_f^{\\mathrm{arith}} = \\frac{1}{2}(K_L + K_R)$. This is known to be inaccurate for high-contrast media.\n        -   **Harmonic mean**: $K_f^{\\mathrm{harm}} = \\left(\\frac{1}{2}\\left(\\frac{1}{K_L} + \\frac{1}{K_R}\\right)\\right)^{-1}$. This is derived from considering flow through two layers in series and is known to be the correct effective conductivity for one-dimensional flow perpendicular to layers. It is generally more accurate for discontinuous $K$.\n    -   For boundary faces, a one-sided transmissibility is used, incorporating the known Dirichlet head values into the right-hand side vector $\\mathbf{b}_{\\mathrm{FD}}$. The distance from the cell center to the boundary is $\\Delta x/2$ or $\\Delta y/2$.\n    -   The resulting system of linear equations is $\\mathbf{A}_{\\mathrm{FD}} \\mathbf{h}_{\\mathrm{FD}} = \\mathbf{b}_{\\mathrm{FD}}$.\n\n4.  **Error Calculation**: The accuracy of each approximate solution ($\\hat{h}$) is measured against the reference solution ($h^{\\mathrm{ref}}$) using the specified discrete $\\mathrm{L}^2$ error norms.\n    -   For FD: $E_{\\mathrm{FD}} = \\left( \\sum_{i,j} (\\hat{h}_{i,j} - h^{\\mathrm{ref}}(x_{i+1/2}, y_{j+1/2}))^2 \\Delta x \\Delta y \\right)^{1/2}$.\n    -   For FE: $E_{\\mathrm{FE}} = \\left( \\sum_{p} (\\hat{h}_p - h^{\\mathrm{ref}}(x_p, y_p))^2 / N_{\\mathrm{nodes}} \\right)^{1/2}$.\n\n5.  **Test Execution**: The three specified test cases (A, B, C) are executed. These cases vary the conductivity contrast and the alignment of the discretization grid with the checkerboard conductivity field. The alignment is particularly important for FD, as misaligning the grid such that cell faces coincide with jumps in $K$ is expected to highlight the difference between arithmetic and harmonic averaging. The nine resulting error values will be collected and presented. For numerical stability and efficiency, all linear systems are constructed as sparse matrices using `scipy.sparse` and solved with `scipy.sparse.linalg.spsolve`.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\nfrom scipy.interpolate import LinearNDInterpolator\n\ndef get_K(coords, mc, K_high, K_low, delta_x, delta_y):\n    \"\"\"\n    Computes hydraulic conductivity K for a checkerboard field.\n    \n    Args:\n        coords (np.ndarray): (N, 2) array of (x, y) coordinates.\n        mc (int): Number of checkerboard tiles in each dimension.\n        K_high (float): High conductivity value.\n        K_low (float): Low conductivity value.\n        delta_x (float): Offset in x-direction.\n        delta_y (float): Offset in y-direction.\n\n    Returns:\n        np.ndarray: (N,) array of conductivity values.\n    \"\"\"\n    x_shifted = (coords[:, 0] + delta_x) % 1.0\n    y_shifted = (coords[:, 1] + delta_y) % 1.0\n    \n    i = np.floor(mc * x_shifted).astype(int)\n    j = np.floor(mc * y_shifted).astype(int)\n    \n    k_values = np.where((i + j) % 2 == 0, K_high, K_low)\n    return k_values\n\ndef solve_fe(Nx, Ny, mc, K_high, K_low, delta_x, delta_y):\n    \"\"\"\n    Solves the groundwater flow equation using the Finite Element method\n    on a grid of right triangles.\n    \"\"\"\n    num_nodes = (Nx + 1) * (Ny + 1)\n    \n    # Generate node coordinates\n    x_nodes = np.linspace(0, 1, Nx + 1)\n    y_nodes = np.linspace(0, 1, Ny + 1)\n    xv, yv = np.meshgrid(x_nodes, y_nodes)\n    node_coords = np.vstack([xv.ravel(), yv.ravel()]).T\n\n    A = lil_matrix((num_nodes, num_nodes))\n    b = np.zeros(num_nodes)\n\n    # Assemble stiffness matrix\n    for i in range(Nx):\n        for j in range(Ny):\n            # Global indices of the four nodes of the square cell (i,j)\n            n0 = j * (Nx + 1) + i       # bottom-left\n            n1 = j * (Nx + 1) + (i + 1) # bottom-right\n            n2 = (j + 1) * (Nx + 1) + (i + 1) # top-right\n            n3 = (j + 1) * (Nx + 1) + i # top-left\n            \n            triangles = [(n0, n1, n2), (n0, n2, n3)]\n\n            for tri_nodes in triangles:\n                v_coords = node_coords[list(tri_nodes)]\n                centroid = np.mean(v_coords, axis=0)\n                K_e = get_K(np.array([centroid]), mc, K_high, K_low, delta_x, delta_y)[0]\n\n                (x1, y1), (x2, y2), (x3, y3) = v_coords\n                area = 0.5 * np.abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))\n                \n                b_coeffs = np.array([y2 - y3, y3 - y1, y1 - y2]) / (2 * area)\n                c_coeffs = np.array([x3 - x2, x1 - x3, x2 - x1]) / (2 * area)\n                \n                # Local stiffness matrix\n                Ke_local = np.zeros((3, 3))\n                for r in range(3):\n                    for c in range(3):\n                        Ke_local[r,c] = (b_coeffs[r] * b_coeffs[c] + c_coeffs[r] * c_coeffs[c])\n                Ke_local *= K_e * area\n\n                for r in range(3):\n                    for c in range(3):\n                        A[tri_nodes[r], tri_nodes[c]] += Ke_local[r, c]\n\n    # Apply Dirichlet boundary conditions strongly\n    boundary_nodes = [p for p in range(num_nodes) if node_coords[p,0] == 0 or node_coords[p,0] == 1 or node_coords[p,1] == 0 or node_coords[p,1] == 1]\n    \n    for p in boundary_nodes:\n        h_D = 1.0 - node_coords[p, 0]\n        A[p, :] = 0\n        A[p, p] = 1.0\n        b[p] = h_D\n\n    h = spsolve(A.tocsr(), b)\n    return h, node_coords\n\ndef solve_fd(Nx, Ny, mc, K_high, K_low, delta_x, delta_y, avg_method):\n    \"\"\"\n    Solves the groundwater flow equation using a cell-centered Finite Difference method.\n    \"\"\"\n    dx, dy = 1.0 / Nx, 1.0 / Ny\n    num_unknowns = Nx * Ny\n    A = lil_matrix((num_unknowns, num_unknowns))\n    b = np.zeros(num_unknowns)\n\n    x_centers = np.linspace(dx/2, 1-dx/2, Nx)\n    y_centers = np.linspace(dy/2, 1-dy/2, Ny)\n    cx, cy = np.meshgrid(x_centers, y_centers)\n    cell_coords = np.vstack([cx.ravel(), cy.ravel()]).T\n    K_cells_flat = get_K(cell_coords, mc, K_high, K_low, delta_x, delta_y)\n    K_cells = K_cells_flat.reshape((Ny, Nx)).T\n\n    avg_func = (lambda K1, K2: 0.5 * (K1 + K2)) if avg_method == 'arith' else (lambda K1, K2: 2.0 / (1.0/K1 + 1.0/K2))\n    \n    for i in range(Nx):\n        for j in range(Ny):\n            k = i * Ny + j\n            K_ij = K_cells[i,j]\n            \n            # East face\n            if i < Nx - 1:\n                T_E = avg_func(K_ij, K_cells[i+1, j]) * dy / dx\n                A[k, k] += T_E; A[k, (i+1)*Ny + j] -= T_E\n            else:\n                T_E = K_ij / (dx / 2.0) * dy\n                A[k, k] += T_E; b[k] += T_E * (1.0 - (i+1)*dx)\n            # West face\n            if i > 0:\n                T_W = avg_func(K_ij, K_cells[i-1, j]) * dy / dx\n                A[k, k] += T_W; A[k, (i-1)*Ny + j] -= T_W\n            else:\n                T_W = K_ij / (dx / 2.0) * dy\n                A[k, k] += T_W; b[k] += T_W * (1.0 - 0.0)\n            # North face\n            if j < Ny - 1:\n                T_N = avg_func(K_ij, K_cells[i, j+1]) * dx / dy\n                A[k, k] += T_N; A[k, i*Ny + j + 1] -= T_N\n            else:\n                T_N = K_ij / (dy / 2.0) * dx\n                A[k, k] += T_N; b[k] += T_N * (1.0 - (i+0.5)*dx)\n            # South face\n            if j > 0:\n                T_S = avg_func(K_ij, K_cells[i, j-1]) * dx / dy\n                A[k, k] += T_S; A[k, i*Ny + j - 1] -= T_S\n            else:\n                T_S = K_ij / (dy / 2.0) * dx\n                A[k, k] += T_S; b[k] += T_S * (1.0 - (i+0.5)*dx)\n\n    h = spsolve(A.tocsr(), b)\n    return h, cell_coords.reshape(Nx, Ny, 2).transpose(1,0,2).reshape(Nx*Ny, 2)\n\n\ndef compute_errors_for_case(Nx, Ny, Nx_ref, Ny_ref, mc, K_high, K_low, delta_x, delta_y):\n    \"\"\"\n    Orchestrates the computation of errors for one test case.\n    \"\"\"\n    h_ref, ref_node_coords = solve_fe(Nx_ref, Ny_ref, mc, K_high, K_low, delta_x, delta_y)\n    ref_interpolator = LinearNDInterpolator(ref_node_coords, h_ref)\n    \n    errors = []\n\n    # FD errors\n    h_fd_arith, fd_coords = solve_fd(Nx, Ny, mc, K_high, K_low, delta_x, delta_y, 'arith')\n    h_fd_harm, _ = solve_fd(Nx, Ny, mc, K_high, K_low, delta_x, delta_y, 'harm')\n    h_ref_at_centers = ref_interpolator(fd_coords)\n    dx, dy = 1.0/Nx, 1.0/Ny\n    errors.append(np.sqrt(np.sum((h_fd_arith - h_ref_at_centers)**2) * dx * dy))\n    errors.append(np.sqrt(np.sum((h_fd_harm - h_ref_at_centers)**2) * dx * dy))\n    \n    # FE error\n    h_fe, fe_node_coords = solve_fe(Nx, Ny, mc, K_high, K_low, delta_x, delta_y)\n    h_ref_at_nodes = ref_interpolator(fe_node_coords)\n    num_nodes = (Nx + 1) * (Ny + 1)\n    weight = 1.0 / num_nodes\n    errors.append(np.sqrt(np.sum((h_fe - h_ref_at_nodes)**2) * weight))\n    \n    return errors\n\ndef solve():\n    \"\"\"Main function to run all test cases and print results.\"\"\"\n    # Define common parameters for all tests.\n    test_params = {\n        'Nx': 16, 'Ny': 16,\n        'Nx_ref': 64, 'Ny_ref': 64,\n        'mc': 8,\n    }\n\n    # Define the three specific test cases.\n    test_cases = [\n        # Test A: aligned, high contrast\n        {'K_high': 1e-3, 'K_low': 1e-6, 'delta_x': 0.0, 'delta_y': 0.0},\n        # Test B: misaligned, high contrast\n        {'K_high': 1e-3, 'K_low': 1e-6, 'delta_x': 1.0 / (2 * test_params['mc']), 'delta_y': 0.0},\n        # Test C: aligned, low contrast\n        {'K_high': 1e-4, 'K_low': 1e-5, 'delta_x': 0.0, 'delta_y': 0.0}\n    ]\n\n    results = []\n    for case_config in test_cases:\n        # Combine common params with case-specific params\n        current_params = {**test_params, **case_config}\n        case_errors = compute_errors_for_case(**current_params)\n        results.extend(case_errors)\n\n    # Format the final output as specified.\n    print(f\"[{','.join(f'{r:.6e}' for r in results)}]\")\n\nsolve()\n```", "id": "3614550"}, {"introduction": "A robust numerical model must do more than generate a plausible-looking solution; it must also respect the fundamental physical principles of the system it simulates. This advanced practice [@problem_id:3614531] challenges you to use a numerical solver to verify the principle of reciprocity, a fundamental symmetry in potential flow problems that stems from the self-adjoint nature of the governing elliptic operator. By numerically confirming that the head response at point $\\mathbf{x}_a$ due to a source at $\\mathbf{x}_b$ is equal to the response at $\\mathbf{x}_b$ from a source at $\\mathbf{x}_a$, you will not only build confidence in your solver but also deepen your understanding of the crucial link between the physics of the continuous system and the properties of its discrete approximation.", "problem": "Consider steady single-phase groundwater flow of an incompressible fluid in a saturated porous medium occupying the unit square domain $\\Omega = [0,1]\\times[0,1]$. Let $h(x,y)$ denote hydraulic head in meters and let the hydraulic conductivity tensor be diagonal with components $k_x(x,y)$ and $k_y(x,y)$ in meters per second. The governing equation in strong form is the partial differential equation $-\\nabla\\cdot(\\mathbf{K}\\nabla h)=q$ in $\\Omega$, where $\\mathbf{K}=\\mathrm{diag}(k_x,k_y)$ and $q$ is a volumetric source term per unit volume in reciprocal seconds ($\\mathrm{s}^{-1}$). Boundary conditions on $\\partial\\Omega$ are specified as linear types that may include Dirichlet (prescribed head), Neumann (prescribed normal flux), or leaky Robin (linear head-to-flux relation against an external head). You will verify numerically the reciprocity of the head response, namely that for two interior points $\\mathbf{x}_a$ and $\\mathbf{x}_b$ in $\\Omega$, the Green’s function symmetry condition $h(\\mathbf{x}_a;\\delta(\\mathbf{x}-\\mathbf{x}_b))=h(\\mathbf{x}_b;\\delta(\\mathbf{x}-\\mathbf{x}_a))$ holds to within numerical tolerance under various discretizations and boundary mixes.\n\nStarting from fundamental conservation of mass and Darcy’s law, discretize the governing equation on a uniform Cartesian mesh with $N_x \\times N_y$ rectangular control volumes using a conservative cell-centered scheme. Represent the point source $\\delta(\\mathbf{x}-\\mathbf{x}_0)$ as a unit source distributed over the single control volume that contains $\\mathbf{x}_0$, so that the integrated source over that control volume equals $Q=1$ in units of cubic meters per second per unit thickness (i.e., $1\\,\\mathrm{m^2/s}$). Implement two choices of face conductivity averaging for the two-point flux approximation across interior faces: harmonic averaging and arithmetic averaging. For boundary faces, implement:\n- Dirichlet: prescribed head $h_D$ in meters.\n- Neumann: prescribed outward normal flux density $q_n$ in meters per second; the integrated flux across a boundary face of length $\\ell$ is $q_n\\,\\ell$.\n- Leaky Robin: $-(\\mathbf{K}\\nabla h)\\cdot \\mathbf{n} = \\lambda (h - h_{\\mathrm{ext}})$ on the boundary with outward unit normal $\\mathbf{n}$, where $\\lambda$ is a leakance coefficient in reciprocal seconds and $h_{\\mathrm{ext}}$ is an external head in meters. The integrated flux across a boundary face of length $\\ell$ is $\\lambda \\,\\ell\\,(h - h_{\\mathrm{ext}})$.\n\nYour program must, for each test case, assemble and solve the resulting linear system for the head field twice: once with a unit source at $\\mathbf{x}_b$ and once with a unit source at $\\mathbf{x}_a$. Let $h^b$ be the solution associated with the source at $\\mathbf{x}_b$ and $h^a$ be the solution associated with the source at $\\mathbf{x}_a$. Extract the head values $h^b(\\mathbf{x}_a)$ and $h^a(\\mathbf{x}_b)$ by sampling at the indices of the control volumes containing $\\mathbf{x}_a$ and $\\mathbf{x}_b$, respectively, and compute the absolute reciprocity residual $r = \\left|h^b(\\mathbf{x}_a) - h^a(\\mathbf{x}_b)\\right|$ in meters.\n\nPhysical units: All heads must be in meters, flux densities in meters per second, conductivity in meters per second, and leakance in reciprocal seconds. The final outputs required below are residuals $r$ and must be expressed in meters.\n\nTest suite. Your code must evaluate and report the reciprocity residual for each of the following test cases. In each case, the domain is $[0,1]\\times[0,1]$ in meters, the total source strength is $Q=1$ in cubic meters per second per unit thickness (implemented by $q=Q/(\\Delta x \\Delta y)$ at the single source cell), and the sampling points are strictly interior. The face conductivity averaging “mode” is either “harmonic” or “arithmetic”.\n\n- Test case $1$ (coarse, isotropic, mixed Dirichlet–Neumann):\n  - Grid: $N_x = 16$, $N_y = 16$.\n  - Conductivity: $k_x(x,y)=1$, $k_y(x,y)=1$ (constant).\n  - Boundary conditions: left Dirichlet $h=1$, right Dirichlet $h=0$, top Neumann $q_n=0$, bottom Neumann $q_n=0$.\n  - Averaging mode: harmonic.\n  - Points: $\\mathbf{x}_a=(0.31,0.61)$, $\\mathbf{x}_b=(0.73,0.42)$.\n\n- Test case $2$ (refined, isotropic, same boundary mix):\n  - Grid: $N_x = 64$, $N_y = 64$.\n  - Conductivity: $k_x(x,y)=1$, $k_y(x,y)=1$.\n  - Boundary conditions: left Dirichlet $h=1$, right Dirichlet $h=0$, top Neumann $q_n=0$, bottom Neumann $q_n=0$.\n  - Averaging mode: harmonic.\n  - Points: $\\mathbf{x}_a=(0.29,0.77)$, $\\mathbf{x}_b=(0.61,0.38)$.\n\n- Test case $3$ (aligned anisotropy, mixed Dirichlet–Neumann):\n  - Grid: $N_x = 40$, $N_y = 40$.\n  - Conductivity: $k_x(x,y)=10$, $k_y(x,y)=1$ (constants).\n  - Boundary conditions: left Dirichlet $h=1$, right Dirichlet $h=0$, top Neumann $q_n=0$, bottom Neumann $q_n=0$.\n  - Averaging mode: harmonic.\n  - Points: $\\mathbf{x}_a=(0.27,0.71)$, $\\mathbf{x}_b=(0.66,0.33)$.\n\n- Test case $4$ (isotropic with leaky Robin, mixed):\n  - Grid: $N_x = 40$, $N_y = 40$.\n  - Conductivity: $k_x(x,y)=1$, $k_y(x,y)=1$ (constants).\n  - Boundary conditions: left Dirichlet $h=1$, right Dirichlet $h=0$, bottom Neumann $q_n=0$, top Robin with $\\lambda=5$ and $h_{\\mathrm{ext}}=0.25$.\n  - Averaging mode: harmonic.\n  - Points: $\\mathbf{x}_a=(0.35,0.55)$, $\\mathbf{x}_b=(0.62,0.41)$.\n\n- Test case $5$ (heterogeneous inclusion, isotropic outside, arithmetic averaging):\n  - Grid: $N_x = 40$, $N_y = 40$.\n  - Conductivity: $k_x(x,y)=k_y(x,y)=20$ inside the inclusion box $[0.4,0.6]\\times[0.4,0.6]$, and $k_x(x,y)=k_y(x,y)=1$ elsewhere.\n  - Boundary conditions: left Dirichlet $h=1$, right Dirichlet $h=0$, top Neumann $q_n=0$, bottom Neumann $q_n=0$.\n  - Averaging mode: arithmetic.\n  - Points: $\\mathbf{x}_a=(0.37,0.63)$, $\\mathbf{x}_b=(0.74,0.29)$.\n\nFinal output format. Your program should produce a single line of output containing the reciprocity residuals for the five test cases, expressed in meters, as a comma-separated Python-style list in one line, for example $[r_1,r_2,r_3,r_4,r_5]$ where each $r_i$ is a floating-point number in meters. No additional text must be printed. The solution must be self-contained and must not read input or files or access a network.", "solution": "The problem requires the numerical verification of the reciprocity principle for steady-state single-phase groundwater flow in a two-dimensional domain. The governing equation is a second-order elliptic partial differential equation (PDE), which is derived from the principle of mass conservation and Darcy's law. We will discretize this equation using a cell-centered finite volume method and solve the resulting linear system to find the hydraulic head distribution.\n\nThe principle of conservation of mass for a steady, incompressible flow in a porous medium is expressed as:\n$$ -\\nabla \\cdot \\mathbf{v} = q $$\nwhere $\\mathbf{v}$ is the Darcy velocity or specific discharge vector (in m/s), and $q$ is the volumetric source/sink term per unit volume (in s⁻¹). We consider a 2D problem, effectively integrating over a unit thickness, so the governing equation is posed on a 2D domain $\\Omega$.\n\nDarcy's law relates the specific discharge to the hydraulic head $h$ (in m):\n$$ \\mathbf{v} = -\\mathbf{K} \\nabla h $$\nwhere $\\mathbf{K}$ is the hydraulic conductivity tensor (in m/s). For this problem, $\\mathbf{K}$ is a diagonal tensor, $\\mathbf{K} = \\mathrm{diag}(k_x, k_y)$.\n\nSubstituting Darcy's law into the conservation equation yields the governing PDE in strong form:\n$$ -\\nabla \\cdot (\\mathbf{K} \\nabla h) = q' $$\nwhere we use $q'$ to represent the source term per unit area (in m/s), which is what the problem seems to imply by \"volumetric source term per unit area\", despite the confusing units. Integrating this over the area of a control volume $V_{i,j}$ (a grid cell) gives:\n$$ \\int_{V_{i,j}} -\\nabla \\cdot (\\mathbf{K} \\nabla h) \\, dA = \\int_{V_{i,j}} q' \\, dA $$\nApplying the divergence theorem to the left-hand side converts the area integral into a line integral over the boundary $\\partial V_{i,j}$ of the control volume:\n$$ -\\oint_{\\partial V_{i,j}} (\\mathbf{K} \\nabla h) \\cdot \\mathbf{n} \\, dL = Q_{i,j} $$\nwhere $\\mathbf{n}$ is the outward-pointing unit normal vector to the boundary of the control volume, and $Q_{i,j} = \\int_{V_{i,j}} q' \\, dA$ is the total source/sink rate from the cell (in m²/s, which is m³/s per meter of thickness, consistent with the problem statement's $Q=1$). A point source $\\delta(\\mathbf{x}-\\mathbf{x}_0)$ is modeled by setting $Q_{i_0,j_0}=1$ for the cell $(i_0,j_0)$ containing $\\mathbf{x}_0$, and $Q_{i,j}=0$ for all other cells.\n\nThe domain $\\Omega=[0,1]\\times[0,1]$ is discretized into a uniform Cartesian grid of $N_x \\times N_y$ cells. Each cell $(i,j)$ has dimensions $\\Delta x = 1/N_x$ and $\\Delta y = 1/N_y$. The hydraulic head $h_{i,j}$ is defined at the center of the cell. The integral equation is approximated by summing the fluxes across the four faces of the cell. The flux out of cell $(i,j)$ across its right face (the interface with cell $(i+1,j)$) is approximated using a two-point flux approximation (TPFA):\n$$ F_{i+1/2, j} \\approx - K_{x, i+1/2, j} \\frac{h_{i+1,j} - h_{i,j}}{\\Delta x} \\Delta y = T_{i+1/2, j} (h_{i,j} - h_{i+1,j}) $$\nwhere $T_{i+1/2, j} = K_{x, i+1/2, j} \\frac{\\Delta y}{\\Delta x}$ is the transmissivity across the face. $K_{x, i+1/2, j}$ is an effective hydraulic conductivity at the face, computed by averaging the conductivities of the adjacent cells, $k_{x,i,j}$ and $k_{x,i+1,j}$. The problem specifies two averaging methods:\n-   Harmonic average: $K_{x, i+1/2, j} = \\frac{2 k_{x,i,j} k_{x,i+1,j}}{k_{x,i,j} + k_{x,i+1,j}}$\n-   Arithmetic average: $K_{x, i+1/2, j} = \\frac{k_{x,i,j} + k_{x,i+1,j}}{2}$\nSimilar expressions hold for the other three faces. The discretized equation for an interior cell $(i,j)$ is a sum of the fluxes out of the cell, which must equal the net source from the cell:\n$$ T_{i+1/2, j}(h_{i,j}-h_{i+1,j}) + T_{i-1/2, j}(h_{i,j}-h_{i-1,j}) + T_{i, j+1/2}(h_{i,j}-h_{i,j+1}) + T_{i, j-1/2}(h_{i,j}-h_{i,j-1}) = Q_{i,j} $$\nThis can be rearranged into a linear equation relating $h_{i,j}$ to its four neighbors.\n\nFor cells on the boundary of the domain $\\Omega$, one or more of these flux terms are replaced by a boundary condition. Let's consider a cell $(0,j)$ on the left boundary ($x=0$):\n-   Dirichlet condition ($h=h_D$): The flux across the boundary face is approximated as being driven by the difference between the cell-center head $h_{0,j}$ and the boundary head $h_D$ over a distance of $\\Delta x/2$. The flux out of the cell is $F_{out,L} = \\frac{k_{x,0,j} \\Delta y}{\\Delta x/2}(h_{0,j}-h_D)$. This modifies the linear equation by adding a term to the main diagonal of the system matrix and a known value to the right-hand side vector.\n-   Neumann condition (prescribed outward flux $q_n$): The outward flux through the face is simply $q_n \\Delta y$. The linear equation is modified by subtracting this known flux from the right-hand side. For a no-flow condition ($q_n=0$), this term is zero.\n-   Robin condition ($-(\\mathbf{K}\\nabla h)\\cdot \\mathbf{n} = \\lambda (h - h_{\\mathrm{ext}})$): The outward flux density is $\\lambda(h-h_{\\text{ext}})$. Approximating $h$ at the boundary by the cell-center head $h_{0,j}$, the outward flux is $\\lambda \\Delta y (h_{0,j}-h_{\\text{ext}})$. This modifies both the diagonal of the system matrix and the right-hand side vector.\n\nAssembling the equations for all $N=N_x N_y$ cells results in a large, sparse linear system of the form $\\mathbf{A} \\mathbf{h} = \\mathbf{b}$, where $\\mathbf{h}$ is the vector of unknown cell-center heads. The coefficient matrix $\\mathbf{A}$ is constructed based on the transmissivities and boundary conditions, while the vector $\\mathbf{b}$ contains the source terms and boundary condition values. Both harmonic and arithmetic averaging on a uniform grid, combined with the given boundary condition types, result in a symmetric matrix $\\mathbf{A}$.\n\nThe reciprocity principle states that the head at point $\\mathbf{x}_a$ due to a source at $\\mathbf{x}_b$ is equal to the head at $\\mathbf{x}_b$ due to a source at $\\mathbf{x}_a$. In the discrete system, this translates to $h_{k_a}^b = h_{k_b}^a$, where $k_a$ and $k_b$ are the indices for the cells containing $\\mathbf{x}_a$ and $\\mathbf{x}_b$. This property, $h_{k_a}^b = (\\mathbf{A}^{-1}\\mathbf{b}^b)_{k_a}$ and $h_{k_b}^a = (\\mathbf{A}^{-1}\\mathbf{b}^a)_{k_b}$, holds if the inverse matrix $\\mathbf{A}^{-1}$ is symmetric. Since the matrix $\\mathbf{A}$ is symmetric, its inverse is also symmetric. Therefore, the reciprocity should hold to within the limits of floating-point precision.\n\nThe algorithm proceeds as follows for each test case:\n1.  Define the grid, hydraulic conductivity field, and boundary conditions.\n2.  Construct the system matrix $\\mathbf{A}$ and a base right-hand side vector $\\mathbf{b}_{BC}$ containing only boundary condition contributions.\n3.  First solve for a source at $\\mathbf{x}_b$:\n    a. Determine the cell index $k_b$ for point $\\mathbf{x}_b$.\n    b. Create the full RHS vector $\\mathbf{b}^b = \\mathbf{b}_{BC}$, and add the source term $Q=1$ at index $k_b$.\n    c. Solve the system $\\mathbf{A} \\mathbf{h}^b = \\mathbf{b}^b$ for the head field $\\mathbf{h}^b$.\n    d. Determine the cell index $k_a$ for point $\\mathbf{x}_a$ and extract the head $h^b(\\mathbf{x}_a) = h^b_{k_a}$.\n4.  Then solve for a source at $\\mathbf{x}_a$:\n    a. Create the RHS vector $\\mathbf{b}^a = \\mathbf{b}_{BC}$, and add the source term $Q=1$ at index $k_a$.\n    b. Solve the system $\\mathbf{A} \\mathbf{h}^a = \\mathbf{b}^a$ for the head field $\\mathbf{h}^a$.\n    c. Extract the head $h^a(\\mathbf{x}_b) = h^a_{k_b}$.\n5.  Compute the absolute reciprocity residual $r = |h^b(\\mathbf{x}_a) - h^a(\\mathbf{x}_b)|$.\n\nThis procedure is repeated for all five test cases provided. The construction of the matrix $\\mathbf{A}$ and vector $\\mathbf{b}$ is performed by iterating through all cell faces to compute transmissivities and then through boundary cells to incorporate boundary terms. A sparse linear solver is used for efficiency.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import coo_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to run the groundwater flow simulation for all test cases\n    and report the reciprocity residuals.\n    \"\"\"\n    \n    test_cases = [\n        # Test case 1\n        {'Nx': 16, 'Ny': 16, 'k_field': {'type': 'constant', 'kx': 1.0, 'ky': 1.0},\n         'bcs': {'left': ('dirichlet', 1.0), 'right': ('dirichlet', 0.0), 'top': ('neumann', 0.0), 'bottom': ('neumann', 0.0)},\n         'avg_mode': 'harmonic', 'xa': (0.31, 0.61), 'xb': (0.73, 0.42)},\n        # Test case 2\n        {'Nx': 64, 'Ny': 64, 'k_field': {'type': 'constant', 'kx': 1.0, 'ky': 1.0},\n         'bcs': {'left': ('dirichlet', 1.0), 'right': ('dirichlet', 0.0), 'top': ('neumann', 0.0), 'bottom': ('neumann', 0.0)},\n         'avg_mode': 'harmonic', 'xa': (0.29, 0.77), 'xb': (0.61, 0.38)},\n        # Test case 3\n        {'Nx': 40, 'Ny': 40, 'k_field': {'type': 'constant', 'kx': 10.0, 'ky': 1.0},\n         'bcs': {'left': ('dirichlet', 1.0), 'right': ('dirichlet', 0.0), 'top': ('neumann', 0.0), 'bottom': ('neumann', 0.0)},\n         'avg_mode': 'harmonic', 'xa': (0.27, 0.71), 'xb': (0.66, 0.33)},\n        # Test case 4\n        {'Nx': 40, 'Ny': 40, 'k_field': {'type': 'constant', 'kx': 1.0, 'ky': 1.0},\n         'bcs': {'left': ('dirichlet', 1.0), 'right': ('dirichlet', 0.0), 'top': ('robin', 5.0, 0.25), 'bottom': ('neumann', 0.0)},\n         'avg_mode': 'harmonic', 'xa': (0.35, 0.55), 'xb': (0.62, 0.41)},\n        # Test case 5\n        {'Nx': 40, 'Ny': 40, 'k_field': {'type': 'inclusion', 'kx_out': 1.0, 'ky_out': 1.0, 'kx_in': 20.0, 'ky_in': 20.0, 'box': [0.4, 0.6, 0.4, 0.6]},\n         'bcs': {'left': ('dirichlet', 1.0), 'right': ('dirichlet', 0.0), 'top': ('neumann', 0.0), 'bottom': ('neumann', 0.0)},\n         'avg_mode': 'arithmetic', 'xa': (0.37, 0.63), 'xb': (0.74, 0.29)},\n    ]\n\n    results = [_run_case(case) for case in test_cases]\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _run_case(params):\n    \"\"\"\n    Solves a single test case for the reciprocity residual.\n    \"\"\"\n    Nx, Ny = params['Nx'], params['Ny']\n    domain_size = (1.0, 1.0)\n    dx, dy = domain_size[0] / Nx, domain_size[1] / Ny\n    N = Nx * Ny\n\n    # Create hydraulic conductivity fields\n    k_field_params = params['k_field']\n    kx_vals = np.full((Ny, Nx), k_field_params.get('kx', k_field_params.get('kx_out', 1.0)))\n    ky_vals = np.full((Ny, Nx), k_field_params.get('ky', k_field_params.get('ky_out', 1.0)))\n\n    if k_field_params['type'] == 'inclusion':\n        x_coords = (np.arange(Nx) + 0.5) * dx\n        y_coords = (np.arange(Ny) + 0.5) * dy\n        xv, yv = np.meshgrid(x_coords, y_coords)\n        box = k_field_params['box']\n        mask = (xv >= box[0]) & (xv <= box[1]) & (yv >= box[2]) & (yv <= box[3])\n        kx_vals[mask] = k_field_params['kx_in']\n        ky_vals[mask] = k_field_params['ky_in']\n\n    # Get cell indices for points a and b\n    xa, xb = params['xa'], params['xb']\n    ia, ja = int(xa[0] / dx), int(xa[1] / dy)\n    ib, jb = int(xb[0] / dx), int(xb[1] / dy)\n    ka = ia + ja * Nx\n    kb = ib + jb * Nx\n\n    # Assemble the system matrix A and RHS vector b for boundary conditions\n    row, col, data = [], [], []\n    b = np.zeros(N)\n\n    # Face averaging function\n    if params['avg_mode'] == 'harmonic':\n        def avg(k1, k2):\n            return 2 * k1 * k2 / (k1 + k2)\n    else: # arithmetic\n        def avg(k1, k2):\n            return 0.5 * (k1 + k2)\n\n    # Interior faces\n    # Horizontal faces\n    for j in range(Ny):\n        for i in range(Nx - 1):\n            k1, k2 = i + j * Nx, (i + 1) + j * Nx\n            K_face = avg(kx_vals[j, i], kx_vals[j, i + 1])\n            T = K_face * dy / dx\n            row.extend([k1, k2, k1, k2]); col.extend([k1, k2, k2, k1]); data.extend([T, T, -T, -T])\n    \n    # Vertical faces\n    for j in range(Ny - 1):\n        for i in range(Nx):\n            k1, k2 = i + j * Nx, i + (j + 1) * Nx\n            K_face = avg(ky_vals[j, i], ky_vals[j + 1, i])\n            T = K_face * dx / dy\n            row.extend([k1, k2, k1, k2]); col.extend([k1, k2, k2, k1]); data.extend([T, T, -T, -T])\n\n    # Boundary conditions\n    bcs = params['bcs']\n    # Left (x=0) and Right (x=1)\n    for j in range(Ny):\n        # Left\n        k = 0 + j * Nx\n        bc_type, *bc_vals = bcs['left']\n        if bc_type == 'dirichlet':\n            hD = bc_vals[0]\n            T_L = kx_vals[j, 0] * dy / (0.5 * dx)\n            row.append(k); col.append(k); data.append(T_L)\n            b[k] += T_L * hD\n        elif bc_type == 'neumann':\n            qn = bc_vals[0]\n            b[k] -= qn * dy\n        # Right\n        k = (Nx - 1) + j * Nx\n        bc_type, *bc_vals = bcs['right']\n        if bc_type == 'dirichlet':\n            hD = bc_vals[0]\n            T_R = kx_vals[j, Nx - 1] * dy / (0.5 * dx)\n            row.append(k); col.append(k); data.append(T_R)\n            b[k] += T_R * hD\n        elif bc_type == 'neumann':\n            qn = bc_vals[0]\n            b[k] -= qn * dy\n\n    # Bottom (y=0) and Top (y=1)\n    for i in range(Nx):\n        # Bottom\n        k = i + 0 * Nx\n        bc_type, *bc_vals = bcs['bottom']\n        if bc_type == 'dirichlet':\n            hD = bc_vals[0]\n            T_B = ky_vals[0, i] * dx / (0.5 * dy)\n            row.append(k); col.append(k); data.append(T_B)\n            b[k] += T_B * hD\n        elif bc_type == 'neumann':\n            qn = bc_vals[0]\n            b[k] -= qn * dx\n            \n        # Top\n        k = i + (Ny - 1) * Nx\n        bc_type, *bc_vals = bcs['top']\n        if bc_type == 'dirichlet':\n            hD = bc_vals[0]\n            T_T = ky_vals[Ny - 1, i] * dx / (0.5 * dy)\n            row.append(k); col.append(k); data.append(T_T)\n            b[k] += T_T * hD\n        elif bc_type == 'neumann':\n            qn = bc_vals[0]\n            b[k] -= qn * dx\n        elif bc_type == 'robin':\n            lam, h_ext = bc_vals\n            T_Robin = lam * dx\n            row.append(k); col.append(k); data.append(T_Robin)\n            b[k] += T_Robin * h_ext\n            \n    A = coo_matrix((data, (row, col)), shape=(N, N)).tocsc()\n\n    # Solve for source at b, measure at a\n    b_b = np.copy(b)\n    b_b[kb] += 1.0 # Source term Q=1\n    h_b = spsolve(A, b_b)\n    h_at_a_from_b = h_b[ka]\n\n    # Solve for source at a, measure at b\n    b_a = np.copy(b)\n    b_a[ka] += 1.0 # Source term Q=1\n    h_a = spsolve(A, b_a)\n    h_at_b_from_a = h_a[kb]\n\n    return abs(h_at_a_from_b - h_at_b_from_a)\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3614531"}]}