{"hands_on_practices": [{"introduction": "Many systems in geophysics, from the oscillation of the Earth's normal modes to the dynamics of planetary cores, can be modeled as oscillators. This exercise introduces a fundamental challenge in perturbation theory: the appearance of secular terms that cause solutions to grow without bound, rendering them physically unrealistic over long times. You will apply the Lindstedt–Poincaré method, a powerful technique for obtaining uniformly valid solutions by systematically adjusting the oscillation frequency to cancel these problematic terms [@problem_id:3576366].", "problem": "In computational seismology and global geodynamics, the displacement associated with a single normal mode of a homogeneous elastic body can be modeled, to leading order, as a linear oscillator with angular frequency $\\omega_{0}$. Weak geometric or material nonlinearities introduce small corrections that can be represented by a cubic term in the equation of motion. Consider the weakly nonlinear oscillator\n$$\n\\ddot{q}(t) + \\omega_{0}^{2}\\,q(t) + \\epsilon\\,\\alpha\\,q^{3}(t) = 0,\n$$\nwhere $q(t)$ is the modal coordinate, $\\omega_{0} > 0$ is the linear angular frequency of the unperturbed mode, $\\alpha$ is a real constant characterizing the strength and sign of the cubic nonlinearity, and $0  \\epsilon \\ll 1$ is a dimensionless small parameter measuring the weakness of the nonlinearity. Suppose the mode is excited from rest with $q(0) = A$ and $\\dot{q}(0) = 0$, where $A>0$ is the initial displacement amplitude.\n\nA naive regular perturbation expansion of $q(t)$ in $\\epsilon$ produces secular growth due to near-resonance between the forcing and the homogeneous solution at the linear frequency, making the approximation non-uniformly valid at long times. To obtain a uniformly valid approximation, apply the Lindstedt–Poincaré (LP) method by introducing a stretched time variable and a frequency correction so that the leading-order oscillation remains periodic and all secular terms are eliminated at $\\mathcal{O}(\\epsilon)$.\n\nStarting from the given equation of motion and the LP method, derive the first-order frequency correction $\\omega_{1}$ required to remove secular terms in the $\\mathcal{O}(\\epsilon)$ problem. Your derivation must explicitly show the rescaling of time, the expansion of the solution and the frequency, and the solvability condition that enforces the elimination of resonant forcing. Express your final answer as a single symbolic expression for $\\omega_{1}$ in terms of $\\omega_{0}$, $\\alpha$, and $A$. No numerical evaluation is required and no units are needed. The corrected angular frequency to first order is $\\omega = \\omega_{0} + \\epsilon\\,\\omega_{1}$; however, report only the frequency correction $\\omega_{1}$.", "solution": "The problem requires the derivation of the first-order frequency correction for a weakly nonlinear oscillator using the Lindstedt–Poincaré (LP) method. The governing equation of motion is the Duffing equation without damping:\n$$\n\\ddot{q}(t) + \\omega_{0}^{2}\\,q(t) + \\epsilon\\,\\alpha\\,q^{3}(t) = 0,\n$$\nwith initial conditions $q(0) = A$ and $\\dot{q}(0) = 0$. The parameters $\\omega_{0}$, $\\alpha$, and $A$ are positive constants, and $0  \\epsilon \\ll 1$ is a small parameter.\n\nThe core idea of the Lindstedt–Poincaré (LP) method is to seek a periodic solution by introducing a new, stretched time variable $\\tau$ and expanding both the solution $q$ and the frequency $\\omega$ in a power series of the small parameter $\\epsilon$. This procedure is designed to remove secular terms (terms that grow unboundedly with time) that appear in a straightforward regular perturbation expansion, thereby ensuring the uniform validity of the approximation for all times.\n\nFirst, we introduce the stretched time variable $\\tau$:\n$$\n\\tau = \\omega t\n$$\nwhere $\\omega$ is the corrected angular frequency of the oscillation, which we assume depends on $\\epsilon$. Using the chain rule, we transform the time derivatives with respect to $t$ into derivatives with respect to $\\tau$:\n$$\n\\frac{d}{dt} = \\frac{d\\tau}{dt}\\frac{d}{d\\tau} = \\omega \\frac{d}{d\\tau}\n$$\n$$\n\\frac{d^2}{dt^2} = \\frac{d}{dt}\\left(\\omega \\frac{d}{d\\tau}\\right) = \\omega^2 \\frac{d^2}{d\\tau^2}\n$$\nSubstituting these into the original differential equation gives:\n$$\n\\omega^2 q''(\\tau) + \\omega_{0}^{2} q(\\tau) + \\epsilon \\alpha q^{3}(\\tau) = 0\n$$\nwhere the prime denotes differentiation with respect to $\\tau$.\n\nNext, we expand both the solution $q(\\tau)$ and the frequency $\\omega$ as power series in $\\epsilon$:\n$$\nq(\\tau) = q_{0}(\\tau) + \\epsilon q_{1}(\\tau) + \\epsilon^2 q_{2}(\\tau) + \\dots\n$$\n$$\n\\omega = \\omega_{0} + \\epsilon \\omega_{1} + \\epsilon^2 \\omega_{2} + \\dots\n$$\nFor the term $\\omega^2$, we need its expansion up to order $\\mathcal{O}(\\epsilon)$:\n$$\n\\omega^2 = (\\omega_{0} + \\epsilon \\omega_{1} + \\dots)^2 = \\omega_{0}^2 + 2\\epsilon\\omega_{0}\\omega_{1} + \\mathcal{O}(\\epsilon^2)\n$$\nSubstituting these expansions into the transformed differential equation:\n$$\n(\\omega_{0}^2 + 2\\epsilon\\omega_{0}\\omega_{1} + \\dots)(q_{0}'' + \\epsilon q_{1}'' + \\dots) + \\omega_{0}^2 (q_{0} + \\epsilon q_{1} + \\dots) + \\epsilon\\alpha(q_{0} + \\epsilon q_{1} + \\dots)^3 = 0\n$$\nWe expand the cubic term: $(q_{0} + \\epsilon q_{1} + \\dots)^3 = q_{0}^3 + 3\\epsilon q_{0}^2 q_{1} + \\mathcal{O}(\\epsilon^2)$. For the purpose of finding the $\\mathcal{O}(\\epsilon)$ equation, we only need the leading term $q_0^3$. Inserting this and collecting terms by powers of $\\epsilon$:\n$$\n(\\omega_{0}^2 q_{0}'' + \\omega_{0}^2 q_{0}) + \\epsilon(\\omega_{0}^2 q_{1}'' + \\omega_{0}^2 q_{1} + 2\\omega_{0}\\omega_{1} q_{0}'' + \\alpha q_{0}^3) + \\mathcal{O}(\\epsilon^2) = 0\n$$\nThis equation must hold for all small $\\epsilon$, so we can set the coefficients of each power of $\\epsilon$ to zero.\n\nAt order $\\mathcal{O}(\\epsilon^0)$:\n$$\n\\omega_{0}^2 q_{0}'' + \\omega_{0}^2 q_{0} = 0 \\implies q_{0}'' + q_{0} = 0\n$$\nThe general solution is $q_{0}(\\tau) = C_0 \\cos(\\tau) + D_0 \\sin(\\tau)$.\n\nAt order $\\mathcal{O}(\\epsilon^1)$:\n$$\n\\omega_{0}^2 q_{1}'' + \\omega_{0}^2 q_{1} = -2\\omega_{0}\\omega_{1} q_{0}'' - \\alpha q_{0}^3\n$$\nwhich can be rewritten as:\n$$\nq_{1}'' + q_{1} = -\\frac{2\\omega_{1}}{\\omega_{0}} q_{0}'' - \\frac{\\alpha}{\\omega_{0}^2} q_{0}^3\n$$\n\nWe must now transform the initial conditions. At $t=0$, we have $\\tau=0$.\nThe condition $q(0)=A$ becomes:\n$q(0) = q_{0}(0) + \\epsilon q_{1}(0) + \\dots = A$.\nThis implies $q_{0}(0) = A$ and $q_{1}(0) = 0$, $q_{2}(0) = 0$, etc.\n\nThe condition $\\dot{q}(0)=0$ becomes:\n$\\dot{q}(t) = \\omega \\frac{dq}{d\\tau} = (\\omega_{0} + \\epsilon\\omega_{1} + \\dots)(q_{0}'(\\tau) + \\epsilon q_{1}'(\\tau) + \\dots)$.\nAt $t=0$ ($\\tau=0$):\n$\\dot{q}(0) = (\\omega_{0} + \\epsilon\\omega_{1} + \\dots)(q_{0}'(0) + \\epsilon q_{1}'(0) + \\dots) = 0$.\nSince $\\omega_{0} \\neq 0$, this requires the entire second parenthesis to be zero. Expanding it and equating powers of $\\epsilon$ to zero yields $q_{0}'(0) = 0$, $q_{1}'(0) = 0$, etc.\n\nApplying these initial conditions to the $\\mathcal{O}(\\epsilon^0)$ solution:\n$q_{0}(0) = C_0 \\cos(0) + D_0 \\sin(0) = C_0 = A$.\n$q_{0}'(0) = -C_0 \\sin(0) + D_0 \\cos(0) = D_0 = 0$.\nSo, the leading-order solution is:\n$$\nq_{0}(\\tau) = A \\cos(\\tau)\n$$\nFrom the $\\mathcal{O}(\\epsilon^0)$ differential equation, we also have $q_{0}'' = -q_{0} = -A \\cos(\\tau)$.\n\nNow, we substitute $q_{0}$ and $q_{0}''$ into the right-hand side (RHS) of the $\\mathcal{O}(\\epsilon^1)$ equation:\n$$\nq_{1}'' + q_{1} = -\\frac{2\\omega_{1}}{\\omega_{0}}(-A\\cos(\\tau)) - \\frac{\\alpha}{\\omega_{0}^2}(A\\cos(\\tau))^3\n$$\n$$\nq_{1}'' + q_{1} = \\frac{2A\\omega_{1}}{\\omega_{0}}\\cos(\\tau) - \\frac{\\alpha A^3}{\\omega_{0}^2}\\cos^3(\\tau)\n$$\nThe term $\\cos(\\tau)$ on the RHS is a resonant forcing term, as it matches a solution of the homogeneous equation $q_{1}'' + q_{1} = 0$. Such a term would lead to a solution for $q_{1}$ that grows linearly with $\\tau$ (a secular term), of the form $\\tau \\sin(\\tau)$. To ensure the solution remains periodic (and thus uniformly valid), we must eliminate all resonant forcing terms.\n\nTo do this, we use the trigonometric identity $\\cos(3x) = 4\\cos^3(x) - 3\\cos(x)$, which gives $\\cos^3(x) = \\frac{1}{4}(\\cos(3x) + 3\\cos(x))$. Substituting this into the RHS:\n$$\nRHS = \\frac{2A\\omega_{1}}{\\omega_{0}}\\cos(\\tau) - \\frac{\\alpha A^3}{\\omega_{0}^2}\\left(\\frac{1}{4}\\cos(3\\tau) + \\frac{3}{4}\\cos(\\tau)\\right)\n$$\n$$\nRHS = \\left(\\frac{2A\\omega_{1}}{\\omega_{0}} - \\frac{3\\alpha A^3}{4\\omega_{0}^2}\\right)\\cos(\\tau) - \\frac{\\alpha A^3}{4\\omega_{0}^2}\\cos(3\\tau)\n$$\nThe solvability condition of the LP method requires that the coefficient of the resonant term $\\cos(\\tau)$ must be zero.\n$$\n\\frac{2A\\omega_{1}}{\\omega_{0}} - \\frac{3\\alpha A^3}{4\\omega_{0}^2} = 0\n$$\nWe solve this equation for $\\omega_{1}$. Since $A>0$ and $\\omega_0>0$, we can rearrange and simplify:\n$$\n\\frac{2A\\omega_{1}}{\\omega_{0}} = \\frac{3\\alpha A^3}{4\\omega_{0}^2}\n$$\n$$\n\\omega_{1} = \\left(\\frac{3\\alpha A^3}{4\\omega_{0}^2}\\right) \\left(\\frac{\\omega_{0}}{2A}\\right)\n$$\n$$\n\\omega_{1} = \\frac{3\\alpha A^2}{8\\omega_{0}}\n$$\nThis expression provides the first-order correction to the frequency required to eliminate secular terms from the solution, yielding a uniformly valid asymptotic approximation. The corrected frequency to first order is $\\omega \\approx \\omega_{0} + \\epsilon \\frac{3\\alpha A^2}{8\\omega_{0}}$.", "answer": "$$\n\\boxed{\\frac{3 \\alpha A^{2}}{8 \\omega_{0}}}\n$$", "id": "3576366"}, {"introduction": "In seismic exploration, the Normal Moveout (NMO) velocity is a critical parameter used to process reflection data and infer subsurface properties. While simple formulas exist for horizontal layers, real geology is often more complex. This practice demonstrates how perturbation methods can be used to derive corrections to the NMO velocity that account for small geological dips, and it then validates this analytical approximation against a numerical \"exact\" solution derived from ray tracing [@problem_id:3576297].", "problem": "A two-dimensional isotropic acoustic Earth model is considered, with a free surface at depth coordinate $z = 0$ and positive depth increasing downward. A single planar reflector is present, with small structural dip angle $\\theta$ relative to the horizontal, parameterized by $\\epsilon = \\tan \\theta$ with $\\epsilon \\ll 1$. The in-medium wave speed $v$ is constant within each layer, and for this problem you may treat the special case of a single homogeneous layer as the canonical validation model. The quantity of interest is the Normal Moveout (NMO) velocity, denoted $V_{\\mathrm{NMO}}(\\epsilon)$, defined by the coefficient of the quadratic moveout of the two-way reflection traveltime $t(x)$ near zero source–receiver offset $x$, via the local hyperbolic approximation\n$$\nt^2(x) = t_0^2 + \\frac{x^2}{V_{\\mathrm{NMO}}^2} + \\mathcal{O}(x^4),\n$$\nwhere $t_0$ is the zero-offset two-way traveltime and $x$ is the source–receiver offset along the horizontal $x$-axis. In a horizontally layered isotropic medium with a horizontal reflector, the zero-dip NMO velocity is the well-known root-mean-square (RMS) velocity\n$$\nV_{\\mathrm{RMS}}^2(t_0) = \\frac{1}{t_0} \\int_{0}^{t_0} v^2\\big(t'\\big)\\, \\mathrm{d}t',\n$$\nwhich, for a single homogeneous layer of thickness $z_0$ and speed $v$, reduces to $V_{\\mathrm{RMS}} = v$ and $t_0 = 2 z_0 / v$. For a planar reflector with small dip, the dip modifies the NMO velocity.\n\nYour tasks are as follows:\n\n- Starting from Fermat’s principle and the isotropic eikonal framework, together with the definition of RMS velocity in horizontally layered media, derive a perturbative expansion for the NMO velocity $V_{\\mathrm{NMO}}(\\epsilon)$ about $\\epsilon = 0$ up to and including second order in $\\epsilon$, assuming $\\epsilon = \\tan \\theta \\ll 1$. State your final expansion explicitly in terms of $V_{\\mathrm{RMS}}$ and $\\epsilon$, and justify why the linear term in $\\epsilon$ vanishes by symmetry.\n- Implement a computational validation using synthetic ray tracing in the special case of a single homogeneous layer over a dipping planar reflector:\n  - Use the exact image-method traveltime in a homogeneous isotropic medium: the two-way traveltime from a source at $(-x/2, 0)$ to a receiver at $(+x/2, 0)$ reflecting on the plane $z = z_0 + \\epsilon x$ equals\n    $$\n    t(x) = \\frac{\\cos \\theta}{v} \\sqrt{x^2 + \\big(2 z_0\\big)^2}, \\quad \\text{with } \\theta = \\arctan \\epsilon.\n    $$\n  - Estimate $V_{\\mathrm{NMO}}$ numerically from the “ray-traced” $t(x)$ by least-squares fitting the quadratic coefficient near $x=0$; equivalently, regress $t^2(x) - t_0^2$ versus $x^2$ for small $|x|$ and take $V_{\\mathrm{NMO}} = 1/\\sqrt{\\text{slope}}$.\n  - Compare the perturbative $V_{\\mathrm{NMO}}(\\epsilon)$ you derived to the ray-traced estimate and report the absolute relative error, defined as $\\big|V_{\\mathrm{pert}} - V_{\\mathrm{rt}}\\big| / V_{\\mathrm{rt}}$, as a dimensionless decimal.\n\nPhysical units and conventions:\n\n- Use meters per second for all velocities ($\\mathrm{m/s}$).\n- Use meters for depths and offsets ($\\mathrm{m}$).\n- Use radians for all angles.\n- The parameter $\\epsilon$ is dimensionless.\n\nYour program must hard-code and evaluate the following test suite, which covers a zero-dip boundary, a weak-dip regime, and progressively stronger dips, all in a single-layer homogeneous medium where $V_{\\mathrm{RMS}} = v$ and the image-method traveltime is exact:\n\n- Test $1$: $(v, z_0, \\epsilon) = (2000\\,\\mathrm{m/s}, 1500\\,\\mathrm{m}, 0)$.\n- Test $2$: $(v, z_0, \\epsilon) = (2500\\,\\mathrm{m/s}, 1500\\,\\mathrm{m}, 0.05)$.\n- Test $3$: $(v, z_0, \\epsilon) = (2500\\,\\mathrm{m/s}, 1500\\,\\mathrm{m}, 0.3)$.\n- Test $4$: $(v, z_0, \\epsilon) = (3000\\,\\mathrm{m/s}, 3000\\,\\mathrm{m}, 0.6)$.\n\nFor the regression in each test, use a symmetric set of small offsets around zero (for example, $x \\in \\{-x_{\\max}, \\ldots, -\\Delta x, 0, \\Delta x, \\ldots, x_{\\max}\\}$ with $x_{\\max}$ chosen so that $x_{\\max} \\ll 2 z_0$). The result for each test case is the absolute relative error as a floating-point number.\n\nFinal output format:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[r_1,r_2,r_3,r_4]$, where $r_k$ denotes the absolute relative error for test $k$ as a decimal.", "solution": "We proceed from first principles. In an isotropic acoustic medium, geometrical rays satisfy Fermat’s principle: the actual reflection path renders the two-way traveltime $t$ stationary with respect to perturbations of the path. In a horizontally layered isotropic medium with a horizontal reflector, the common midpoint traveltime $t(x)$ near zero offset $x$ admits a hyperbolic expansion\n$$\nt^2(x) = t_0^2 + \\frac{x^2}{V_{\\mathrm{NMO}}^2} + \\mathcal{O}(x^4),\n$$\nwhere $t_0$ is the two-way zero-offset time and $V_{\\mathrm{NMO}}$ is the Normal Moveout velocity. The coefficient $1/V_{\\mathrm{NMO}}^2$ is determined by the second derivative of $t^2$ at $x = 0$. In horizontally layered isotropic media this coefficient equals the reciprocal of the squared root-mean-square (RMS) velocity,\n$$\n\\frac{1}{V_{\\mathrm{NMO}}^2(0)} = \\frac{1}{V_{\\mathrm{RMS}}^2(t_0)}, \\qquad V_{\\mathrm{RMS}}^2(t_0) = \\frac{1}{t_0} \\int_{0}^{t_0} v^2\\big(t'\\big)\\, \\mathrm{d}t'.\n$$\nThis is a well-tested result that follows from linearizing the double-square-root (one-way) equation or, equivalently, from dynamic ray-tracing analysis in layered isotropic media. For a single homogeneous layer with speed $v$ and reflector depth $z_0$, one has $V_{\\mathrm{RMS}} = v$ and $t_0 = 2 z_0 / v$.\n\nWe now introduce a small structural dip. Consider a planar reflector that deviates from horizontal by a dip angle $\\theta$; we let $\\epsilon = \\tan \\theta$ with $\\epsilon \\ll 1$. The geometry of specular reflection in an isotropic medium implies that the zero-offset ray is normal to the reflector. Near zero offset, the moveout is governed by the curvature of $t^2(x)$, which depends on how the horizontal offset $x$ projects onto the direction orthogonal to the reflector. Because the reflector is tilted by $\\theta$, the horizontal offset $x$ projects onto the reflector-normal direction with factor $\\cos \\theta$, and the effective path-length change per unit $x$ is reduced by $\\cos \\theta$. Consequently, the coefficient multiplying $x^2$ in $t^2(x)$ is multiplied by $\\cos^2 \\theta$, which, in turn, divides the NMO velocity by $\\cos \\theta$:\n$$\n\\frac{1}{V_{\\mathrm{NMO}}^2(\\theta)} = \\frac{\\cos^2 \\theta}{V_{\\mathrm{RMS}}^2}, \\qquad \\Rightarrow \\qquad V_{\\mathrm{NMO}}(\\theta) = \\frac{V_{\\mathrm{RMS}}}{\\cos \\theta}.\n$$\nThis result is exact in a single homogeneous layer and holds as the correct second-order (in offset) moveout for a plane dipping reflector above a horizontally layered isotropic overburden when expressed in terms of $V_{\\mathrm{RMS}}$ computed to the reflector.\n\nA perturbative expansion in the small parameter $\\epsilon = \\tan \\theta$ uses the identity $\\cos \\theta = 1/\\sqrt{1 + \\tan^2 \\theta} = 1/\\sqrt{1 + \\epsilon^2}$. Therefore,\n$$\n\\frac{1}{\\cos \\theta} = \\sqrt{1 + \\epsilon^2} = 1 + \\frac{1}{2}\\epsilon^2 - \\frac{1}{8}\\epsilon^4 + \\mathcal{O}(\\epsilon^6).\n$$\nTo second order in $\\epsilon$, we obtain\n$$\nV_{\\mathrm{NMO}}(\\epsilon) = V_{\\mathrm{RMS}} \\left(1 + \\frac{1}{2}\\epsilon^2\\right) + \\mathcal{O}(\\epsilon^4).\n$$\nThere is no linear term in $\\epsilon$ because the problem is invariant under reversing the dip direction ($\\theta \\to -\\theta$), which leaves $V_{\\mathrm{NMO}}$ unchanged; thus $V_{\\mathrm{NMO}}$ must be an even function of $\\theta$ and hence of $\\epsilon$.\n\nFor validation, we use the homogeneous single-layer case, where $V_{\\mathrm{RMS}} = v$ and exact traveltimes for a dipping plane are available from the image method. If the plane reflector is $z = z_0 + \\epsilon x$, the unit normal is $\\mathbf{n} = (-\\sin \\theta, \\cos \\theta)$, and reflecting the receiver about the plane reduces the problem to a straight-line path. The exact two-way traveltime as a function of offset $x$ is\n$$\nt(x) = \\frac{\\cos \\theta}{v} \\sqrt{x^2 + \\big(2 z_0\\big)^2}, \\qquad \\theta = \\arctan \\epsilon.\n$$\nTherefore,\n$$\nt^2(x) = \\left(\\frac{2 z_0 \\cos \\theta}{v}\\right)^2 + \\left(\\frac{\\cos \\theta}{v}\\right)^2 x^2,\n$$\nwhich is hyperbolic in $x$ with exact NMO velocity $V_{\\mathrm{NMO}}^{\\mathrm{exact}} = v/\\cos \\theta$. The perturbative formula to second order is\n$$\nV_{\\mathrm{NMO}}^{\\mathrm{pert}}(\\epsilon) = v \\left(1 + \\frac{1}{2}\\epsilon^2\\right).\n$$\nWe estimate $V_{\\mathrm{NMO}}^{\\mathrm{rt}}$ numerically from synthetic “ray-traced” traveltimes by least-squares fitting the slope of $t^2(x) - t_0^2$ versus $x^2$ for small offsets $|x| \\le x_{\\max}$ with $x_{\\max} \\ll 2 z_0$. The absolute relative error is\n$$\n\\mathrm{err} = \\frac{\\left|V_{\\mathrm{NMO}}^{\\mathrm{pert}} - V_{\\mathrm{NMO}}^{\\mathrm{rt}}\\right|}{V_{\\mathrm{NMO}}^{\\mathrm{rt}}}.\n$$\n\nWe apply this to the specified test suite:\n- Test $1$: $(v, z_0, \\epsilon) = (2000\\,\\mathrm{m/s}, 1500\\,\\mathrm{m}, 0)$. Here $\\theta = 0$, $V_{\\mathrm{NMO}}^{\\mathrm{exact}} = v = 2000\\,\\mathrm{m/s}$, and $V_{\\mathrm{NMO}}^{\\mathrm{pert}} = v$, giving $\\mathrm{err} \\approx 0$ up to numerical regression error.\n- Test $2$: $(v, z_0, \\epsilon) = (2500\\,\\mathrm{m/s}, 1500\\,\\mathrm{m}, 0.05)$. Here $\\theta = \\arctan 0.05$, so $V_{\\mathrm{NMO}}^{\\mathrm{exact}} = v/\\cos \\theta \\approx v \\sqrt{1 + \\epsilon^2} \\approx v (1 + \\epsilon^2/2)$. The perturbative prediction is second-order accurate; regression should yield negligible error at this $\\epsilon$.\n- Test $3$: $(v, z_0, \\epsilon) = (2500\\,\\mathrm{m/s}, 1500\\,\\mathrm{m}, 0.3)$. Here the difference between $\\sqrt{1 + \\epsilon^2}$ and $1 + \\epsilon^2/2$ is $\\mathcal{O}(\\epsilon^4)$, so a small but noticeable error is expected.\n- Test $4$: $(v, z_0, \\epsilon) = (3000\\,\\mathrm{m/s}, 3000\\,\\mathrm{m}, 0.6)$. This is a stronger dip, so the truncation at $\\mathcal{O}(\\epsilon^2)$ induces a larger deviation.\n\nThe program constructs symmetric offset samples, evaluates exact $t(x)$, regresses the quadratic curvature to get $V_{\\mathrm{NMO}}^{\\mathrm{rt}}$, computes $V_{\\mathrm{NMO}}^{\\mathrm{pert}}$ using the second-order formula, and prints the list of absolute relative errors $[\\mathrm{err}_1,\\mathrm{err}_2,\\mathrm{err}_3,\\mathrm{err}_4]$ on a single line as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef perturbative_vnmo(v_rms: float, epsilon: float) - float:\n    \"\"\"\n    Second-order perturbative NMO velocity:\n    V_NMO(eps) = V_RMS * (1 + 0.5 * eps^2) + O(eps^4)\n    For a single homogeneous layer, V_RMS = v.\n    \"\"\"\n    return v_rms * (1.0 + 0.5 * epsilon**2)\n\n\ndef exact_traveltime_homogeneous(v: float, z0: float, epsilon: float, x: np.ndarray) - np.ndarray:\n    \"\"\"\n    Exact two-way traveltime t(x) for a homogeneous isotropic medium with\n    a planar reflector z = z0 + epsilon * x. Uses the image method:\n    t(x) = (cos(theta)/v) * sqrt( x^2 + (2 z0)^2 ), with theta = arctan(epsilon).\n    \"\"\"\n    theta = np.arctan(epsilon)\n    cos_theta = np.cos(theta)\n    return (cos_theta / v) * np.sqrt(x**2 + (2.0 * z0)**2)\n\n\ndef estimate_vnmo_by_regression(t_of_x: np.ndarray, x: np.ndarray) - float:\n    \"\"\"\n    Estimate V_NMO from regression of t^2(x) - t0^2 versus x^2 near x=0.\n    Return V_NMO = 1 / sqrt(slope).\n    \"\"\"\n    # Compute t0 as t(x=0); assume x is symmetric and includes 0\n    # To be robust, take the mean of t at the smallest |x| samples around zero:\n    idx0 = np.argmin(np.abs(x))\n    t0 = t_of_x[idx0]\n    y = t_of_x**2 - t0**2\n    X = x**2\n\n    # Linear regression y = s * X (no intercept)\n    # Use least squares slope s = (X^T y) / (X^T X), excluding the x=0 point to avoid 0/0\n    mask = X  0\n    Xm = X[mask]\n    ym = y[mask]\n    s_num = float(np.dot(Xm, ym))\n    s_den = float(np.dot(Xm, Xm))\n    if s_den == 0.0:\n        # Degenerate case: all offsets are zero\n        return np.inf\n    slope = s_num / s_den\n    if slope = 0.0:\n        # Numerical safety: slope should be positive\n        return np.inf\n    vnmo = 1.0 / np.sqrt(slope)\n    return vnmo\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case is a tuple: (v [m/s], z0 [m], epsilon [dimensionless])\n    test_cases = [\n        (2000.0, 1500.0, 0.0),\n        (2500.0, 1500.0, 0.05),\n        (2500.0, 1500.0, 0.30),\n        (3000.0, 3000.0, 0.60),\n    ]\n\n    # Offset sampling parameters for regression:\n    # Ensure x_max  2*z0 for good local curvature estimation.\n    # Use a small step to have multiple samples.\n    results = []\n    for v, z0, eps in test_cases:\n        # Choose offset range relative to depth to satisfy small-offset assumption\n        x_max = min(200.0, 0.1 * (2.0 * z0))  # cap at 200 m or 10% of two-way depth\n        n_side = 10  # number of samples on each side (excluding zero)\n        xs_neg = -np.linspace(x_max, x_max / n_side, n_side)\n        xs_pos = np.linspace(x_max / n_side, x_max, n_side)\n        x = np.concatenate([xs_neg, np.array([0.0]), xs_pos])\n\n        # Exact traveltimes via image-method formula\n        t = exact_traveltime_homogeneous(v, z0, eps, x)\n\n        # Estimate V_NMO by regression (ray-trace-based estimate)\n        vnmo_rt = estimate_vnmo_by_regression(t, x)\n\n        # Perturbative V_NMO to second order, with V_RMS = v in a single homogeneous layer\n        vnmo_pert = perturbative_vnmo(v, eps)\n\n        # Absolute relative error\n        err = abs(vnmo_pert - vnmo_rt) / vnmo_rt\n        results.append(err)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda r: f'{r:.8g}', results))}]\")\n\nsolve()\n```", "id": "3576297"}, {"introduction": "Geophysical tomography aims to image the Earth's interior by inverting wavefield data, a computationally intensive task. Asymptotic methods offer a path to create efficient algorithms by simplifying the underlying physics in a controlled manner. This exercise guides you through implementing a high-frequency approximation of the inversion gradient, which is the key component guiding the model update, by leveraging the separation of scales between the rapidly oscillating wave phase and its slowly varying amplitude [@problem_id:3576398].", "problem": "Consider the scalar acoustic wave equation in a heterogeneous medium with wave speed field $c(\\mathbf{x})$,\n$$\n\\frac{1}{c^2(\\mathbf{x})}\\,\\partial_{tt} u(\\mathbf{x},t)-\\Delta u(\\mathbf{x},t)=s(\\mathbf{x},t),\n$$\nand its time-harmonic Fourier transform at angular frequency $\\omega0$,\n$$\n\\Delta u(\\mathbf{x};\\omega)+\\omega^2 m(\\mathbf{x})\\,u(\\mathbf{x};\\omega)=q(\\mathbf{x};\\omega),\n$$\nwhere $m(\\mathbf{x})=1/c^2(\\mathbf{x})$ is the squared slowness, $u(\\mathbf{x};\\omega)$ is the complex-valued frequency-domain wavefield, $q(\\mathbf{x};\\omega)$ is the source term, and $\\Delta$ is the Laplacian. Introduce the high-frequency ansatz with $\\epsilon=1/\\omega\\ll 1$,\n$$\nu(\\mathbf{x};\\omega)=A(\\mathbf{x})\\,e^{i\\omega T(\\mathbf{x})},\n$$\nwhere $A(\\mathbf{x})$ is a slowly varying amplitude and $T(\\mathbf{x})$ is the phase (travel time). Assume a misfit functional for a single frequency and a set of point receivers,\n$$\nJ=\\frac{1}{2}\\sum_{r}\\left|P_r u-d_r\\right|^2,\n$$\nwhere $P_r$ extracts the field at receiver position $\\mathbf{x}_r$, and $d_r$ is the observed data. Using the adjoint-state method in the frequency domain, the gradient with respect to $m(\\mathbf{x})$ can be expressed in terms of the forward wavefield $u$ and the adjoint wavefield $\\lambda$ that solves the adjoint Helmholtz equation with point sources at receivers proportional to the residuals. In the asymptotic limit $\\epsilon\\to 0$, separate the fast oscillations $e^{i\\omega T}$ from the slow amplitude $A(\\mathbf{x})$ and derive a transport-driven gradient approximation in which the product $u(\\mathbf{x})\\,\\lambda(\\mathbf{x})$ is approximated by the product of slowly varying amplitudes and a rapidly oscillatory phase factor constructed from travel times from the source and from the receivers to the spatial point.\n\nSpecialize to a one-dimensional spatial domain with coordinate $x\\in\\mathbb{R}$ and piecewise constant wave speed $c(x)$, so that $c(x)=c_\\ell$ on intervals $[x_\\ell^{\\text{L}},x_\\ell^{\\text{R}}]$ that partition the domain without overlap. In one dimension under the high-frequency ansatz, the eikonal equation reduces to\n$$\n\\left|\\frac{dT}{dx}\\right|=\\sqrt{m(x)}=\\frac{1}{c(x)},\n$$\nand the leading-order transport equation implies a constant amplitude along rays in each piecewise constant segment. Use these facts to obtain a dimensionless normalized gradient model at a point $x$ of the form\n$$\ng_{\\text{norm}}(x)\\equiv \\cos\\Big(\\omega\\,[T_s(x)+T_r(x)]\\Big),\n$$\nwhere $T_s(x)$ is the travel time from the source location $x_s$ to the point $x$, $T_r(x)$ is the travel time from $x$ to the receiver location $x_r$, and $\\omega=2\\pi f$ with $f$ given in Hertz. Here, the travel times are computed by line integration of $1/c(x)$ along the straight one-dimensional path, that is,\n$$\nT(a\\to b)=\\int_{a}^{b}\\frac{1}{c(x)}\\,dx=\\sum_{\\ell}\\frac{\\text{length of }[a,b]\\cap [x_\\ell^{\\text{L}},x_\\ell^{\\text{R}}]}{c_\\ell}.\n$$\nYour task is to implement a program that computes $g_{\\text{norm}}(x)$ for specified test cases. All distances must be in meters, speeds in meters per second, frequencies in Hertz, and angles in the cosine function must be in radians. The outputs to be printed are the values of $g_{\\text{norm}}(x)$, which are dimensionless. For numerical reporting, round each result to six decimal places.\n\nImplement the following test suite. For each test case, compute $g_{\\text{norm}}(x)$ for each specified evaluation point and aggregate all results, in the order listed, into a single output line as described below.\n\n- Test Case 1 (homogeneous medium, varied positions):\n  - Layers: one layer $\\left([0,1000],\\,c=2000\\right)$.\n  - Source $x_s=100$, receiver $x_r=900$.\n  - Frequency $f=10$.\n  - Evaluation points $x\\in\\{50,100,200,500,900,950\\}$.\n\n- Test Case 2 (two-layer medium, crossing the interface):\n  - Layers: two layers $\\left([0,500],\\,c=1800\\right)$ and $\\left([500,1000],\\,c=2200\\right)$.\n  - Source $x_s=100$, receiver $x_r=900$.\n  - Frequency $f=5$.\n  - Evaluation points $x\\in\\{400,500,600,50,950\\}$.\n\n- Test Case 3 (coincident source and receiver, near-field variation):\n  - Layers: one layer $\\left([0,1000],\\,c=1500\\right)$.\n  - Source $x_s=500$, receiver $x_r=500$.\n  - Frequency $f=20$.\n  - Evaluation points $x\\in\\{500,550,450\\}$.\n\n- Test Case 4 (homogeneous medium, long path, higher frequency):\n  - Layers: one layer $\\left([0,1000],\\,c=3000\\right)$.\n  - Source $x_s=0$, receiver $x_r=1000$.\n  - Frequency $f=50$.\n  - Evaluation points $x\\in\\{0,250,750,1000,1200,-200\\}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, \"[result1,result2,result3]\"). Each value must be rounded to six decimal places, with no additional text printed.", "solution": "The problem statement has been critically examined and is determined to be valid. It is scientifically grounded in the principles of wave propagation and asymptotic analysis, specifically within the context of geophysical inversion. The problem is well-posed, objective, and contains all necessary information to compute a unique and meaningful solution. All terms are defined, and the computational task is explicit.\n\nThe objective is to compute the dimensionless normalized gradient model, $g_{\\text{norm}}(x)$, at several specified spatial points $x$ for a series of test cases. The governing formula is given as:\n$$\ng_{\\text{norm}}(x) \\equiv \\cos\\Big(\\omega\\,[T_s(x)+T_r(x)]\\Big)\n$$\nwhere $\\omega = 2\\pi f$ is the angular frequency, $T_s(x)$ is the acoustic travel time from a source at $x_s$ to the point $x$, and $T_r(x)$ is the travel time from the point $x$ to a receiver at $x_r$.\n\nThe core of the problem lies in the accurate computation of the travel time $T(a \\to b)$ in a one-dimensional medium with a piecewise constant wave speed $c(x)$. The problem provides the defining formula for this travel time as an integral over the slowness $1/c(x)$:\n$$\nT(a\\to b)=\\int_{a}^{b}\\frac{1}{c(x)}\\,dx\n$$\nThis is to be interpreted as an integral over the spatial segment between points $a$ and $b$, so its value is always non-negative, i.e., $T(a \\to b) = \\int_{\\min(a,b)}^{\\max(a,b)} \\frac{1}{c(x)}\\,dx$. Given that the medium is defined by a set of non-overlapping layers, each with a constant speed $c_\\ell$ on an interval $[x_\\ell^{\\text{L}}, x_\\ell^{\\text{R}}]$, the integral simplifies to a sum over these layers:\n$$\nT(a\\to b)=\\sum_{\\ell}\\frac{\\text{length of }[\\min(a,b), \\max(a,b)] \\cap [x_\\ell^{\\text{L}},x_\\ell^{\\text{R}}]}{c_\\ell}\n$$\nThis formula correctly accounts for paths that cross layer boundaries and paths that may extend beyond the domain where the velocity model is defined. For any part of the path $[\\min(a,b), \\max(a,b)]$ that does not intersect with any layer $[x_\\ell^{\\text{L}},x_\\ell^{\\text{R}}]$, the corresponding travel time contribution is zero, as the length of the intersection is zero.\n\nThe computational procedure is as follows:\n1.  A function is designed to calculate the travel time $T(a \\to b)$ based on the summation formula above. This function takes the start point $a$, end point $b$, and the layer definitions as inputs. For a given path segment $[\\min(a,b), \\max(a,b)]$, it iterates through each defined layer, calculates the length of the overlap between the path segment and the layer interval, divides this length by the speed in that layer, and accumulates these contributions to find the total travel time.\n\n2.  For each test case specified in the problem, the provided parameters (layers, source location $x_s$, receiver location $x_r$, and frequency $f$) are used. The angular frequency is calculated as $\\omega = 2\\pi f$.\n\n3.  For each evaluation point $x$ within a test case, the source-to-point travel time $T_s(x) = T(x_s \\to x)$ and the point-to-receiver travel time $T_r(x) = T(x \\to x_r)$ are computed using the travel time function from step 1.\n\n4.  The total travel time for the path $x_s \\to x \\to x_r$ is the sum $T_{\\text{total}} = T_s(x) + T_r(x)$.\n\n5.  The value of the normalized gradient is then calculated as $g_{\\text{norm}}(x) = \\cos(\\omega T_{\\text{total}})$.\n\n6.  Following the output specification, each computed value is formatted to six decimal places. All results are aggregated in the specified order into a single list.\n\nThis methodology is systematically applied to all test cases to produce the final output. The use of high-precision floating-point arithmetic is essential, and care must be taken with the numerical implementation of the intersection logic and the final formatting of the results.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational problem by calculating the normalized gradient model\n    for all specified test cases.\n    \"\"\"\n\n    def calculate_travel_time(start_pos, end_pos, layers):\n        \"\"\"\n        Calculates the travel time between two points in a 1D piecewise-constant medium.\n\n        Args:\n            start_pos (float): The starting position.\n            end_pos (float): The ending position.\n            layers (list): A list of tuples, where each tuple contains\n                           ((layer_start, layer_end), speed).\n\n        Returns:\n            float: The total travel time.\n        \"\"\"\n        path_start = min(start_pos, end_pos)\n        path_end = max(start_pos, end_pos)\n\n        if path_start == path_end:\n            return 0.0\n\n        total_time = 0.0\n        for (layer_bounds, speed) in layers:\n            layer_start, layer_end = layer_bounds\n            \n            # Calculate the intersection of the path and the current layer\n            overlap_start = max(path_start, layer_start)\n            overlap_end = min(path_end, layer_end)\n\n            # If there is a non-zero overlap, add its contribution to the time\n            if overlap_start  overlap_end:\n                overlap_length = overlap_end - overlap_start\n                time_in_layer = overlap_length / speed\n                total_time += time_in_layer\n        \n        return total_time\n\n    test_cases = [\n        {\n            \"layers\": [([0, 1000], 2000)],\n            \"xs\": 100,\n            \"xr\": 900,\n            \"f\": 10,\n            \"eval_points\": [50, 100, 200, 500, 900, 950],\n        },\n        {\n            \"layers\": [([0, 500], 1800), ([500, 1000], 2200)],\n            \"xs\": 100,\n            \"xr\": 900,\n            \"f\": 5,\n            \"eval_points\": [400, 500, 600, 50, 950],\n        },\n        {\n            \"layers\": [([0, 1000], 1500)],\n            \"xs\": 500,\n            \"xr\": 500,\n            \"f\": 20,\n            \"eval_points\": [500, 550, 450],\n        },\n        {\n            \"layers\": [([0, 1000], 3000)],\n            \"xs\": 0,\n            \"xr\": 1000,\n            \"f\": 50,\n            \"eval_points\": [0, 250, 750, 1000, 1200, -200],\n        },\n    ]\n\n    all_results = []\n    for case in test_cases:\n        layers = case[\"layers\"]\n        xs = case[\"xs\"]\n        xr = case[\"xr\"]\n        f = case[\"f\"]\n        eval_points = case[\"eval_points\"]\n\n        omega = 2 * np.pi * f\n\n        for x in eval_points:\n            # Travel time from source to point x\n            Ts_x = calculate_travel_time(xs, x, layers)\n            # Travel time from point x to receiver\n            Tr_x = calculate_travel_time(x, xr, layers)\n            \n            total_time = Ts_x + Tr_x\n            \n            g_norm = np.cos(omega * total_time)\n            \n            # Format to precisely six decimal places\n            all_results.append(\"{:.6f}\".format(g_norm))\n\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "3576398"}]}