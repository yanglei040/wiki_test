{"hands_on_practices": [{"introduction": "The convolution theorem provides more than just a computational shortcut; it offers a powerful lens for analyzing the fundamental characteristics of a linear system. By transforming a system's impulse response into the frequency domain, we can uncover its intrinsic properties, such as causality and stability, by examining its spectrum. This exercise [@problem_id:3616300] guides you through an analytical derivation for a simple viscoacoustic model, demonstrating the profound connection between the location of poles in the complex frequency plane and the physical behavior of the system over time.", "problem": "A one-dimensional viscoacoustic half-space is modeled as a causal Linear Time-Invariant (LTI) system whose Green’s function (impulse response) is given by the exponentially decaying function $x(t)=\\exp(-a t)\\,u(t)$ with $a0$, where $u(t)$ is the unit step. In computational geophysics, a recorded seismogram $y(t)$ generated by a compact source wavelet $s(t)$ can be represented as the convolution $y(t)=(x*s)(t)$ of the Green’s function with the source. The convolution theorem for linear systems connects this time-domain convolution to a frequency-domain product of their spectra, a fact used routinely in seismic deconvolution and attenuation compensation.\n\nStarting strictly from the definition of the angular-frequency Fourier transform,\n$$\nX(\\omega)=\\int_{-\\infty}^{\\infty} x(t)\\,\\exp(-i\\,\\omega\\,t)\\,dt,\n$$\nand the definition of the unit step $u(t)$, derive an explicit closed-form expression for $X(\\omega)$ for the given $x(t)$. Then interpret the location of its pole in the complex $\\omega$-plane by identifying the complex value $\\omega_{\\text{pole}}$ at which $X(\\omega)$ becomes unbounded, and explain in words (in your derivation) how this pole placement is consistent with causality and Bounded-Input Bounded-Output (BIBO) stability of the underlying LTI attenuation operator when viewed through the convolution theorem and its standard analytic continuation.\n\nProvide your final answer as two entries in a single row matrix: first the analytic expression for $X(\\omega)$, and second the complex pole location $\\omega_{\\text{pole}}$. No numerical evaluation is required, and no units are needed in the final answer. If you choose to include any approximations in intermediate reasoning, do not apply them to the final result.", "solution": "The problem requires the derivation of the Fourier transform, denoted as $X(\\omega)$, for the given Green's function $x(t)$, the identification of its pole in the complex $\\omega$-plane, and an interpretation of the pole's location in the context of system causality and stability.\n\nThe given Green's function, or impulse response, is $x(t) = \\exp(-a t) u(t)$, where $a$ is a positive real constant ($a0$) and $u(t)$ is the Heaviside unit step function. The unit step function is defined as:\n$$\nu(t) = \\begin{cases} 0  \\text{for } t  0 \\\\ 1  \\text{for } t \\ge 0 \\end{cases}\n$$\nThe problem specifies the definition of the angular-frequency Fourier transform as:\n$$\nX(\\omega) = \\int_{-\\infty}^{\\infty} x(t) \\exp(-i \\omega t) dt\n$$\n\nTo find $X(\\omega)$, we substitute the expression for $x(t)$ into the integral definition:\n$$\nX(\\omega) = \\int_{-\\infty}^{\\infty} \\exp(-a t) u(t) \\exp(-i \\omega t) dt\n$$\nThe presence of the unit step function $u(t)$ makes the integrand equal to zero for all $t  0$. Consequently, the lower limit of integration can be changed from $-\\infty$ to $0$. For $t \\ge 0$, $u(t) = 1$. The integral simplifies to:\n$$\nX(\\omega) = \\int_{0}^{\\infty} \\exp(-a t) \\exp(-i \\omega t) dt\n$$\nWe can combine the exponential terms in the integrand:\n$$\nX(\\omega) = \\int_{0}^{\\infty} \\exp(-(a + i \\omega) t) dt\n$$\nThis is a standard improper integral of an exponential function. To evaluate it, we find the antiderivative of the integrand with respect to $t$:\n$$\n\\int \\exp(-(a + i \\omega) t) dt = -\\frac{1}{a + i \\omega} \\exp(-(a + i \\omega) t)\n$$\nNow, we evaluate this antiderivative at the limits of integration, from $t=0$ to $t \\to \\infty$:\n$$\nX(\\omega) = \\left[ -\\frac{1}{a + i \\omega} \\exp(-(a + i \\omega) t) \\right]_{0}^{\\infty}\n$$\n$$\nX(\\omega) = \\lim_{T \\to \\infty} \\left( -\\frac{1}{a + i \\omega} \\exp(-(a + i \\omega) T) \\right) - \\left( -\\frac{1}{a + i \\omega} \\exp(-(a + i \\omega) \\cdot 0) \\right)\n$$\nLet's analyze the limit term. The exponential can be written as $\\exp(-aT) \\exp(-i\\omega T)$. For a real-valued angular frequency $\\omega$, the term $\\exp(-i\\omega T)$ is a complex phasor with unit magnitude, $|\\exp(-i\\omega T)| = 1$. The term $\\exp(-aT)$ determines the behavior of the magnitude. Since it is given that $a  0$, as $T \\to \\infty$, $\\exp(-aT) \\to 0$. Therefore, the entire limit term evaluates to zero.\n$$\n\\lim_{T \\to \\infty} \\exp(-(a + i \\omega) T) = 0\n$$\nThe second term evaluates to:\n$$\n-\\left( -\\frac{1}{a + i \\omega} \\exp(0) \\right) = \\frac{1}{a + i \\omega}\n$$\nCombining these results, we obtain the explicit closed-form expression for the Fourier transform $X(\\omega)$:\n$$\nX(\\omega) = \\frac{1}{a + i \\omega}\n$$\n\nNext, we identify the pole of $X(\\omega)$. A pole is a value in the complex plane where the function becomes unbounded. For a rational function like $X(\\omega)$, this occurs where the denominator is zero. Let $\\omega_{\\text{pole}}$ be the complex value of $\\omega$ at which the pole is located. We set the denominator to zero and solve for $\\omega_{\\text{pole}}$:\n$$\na + i \\omega_{\\text{pole}} = 0\n$$\n$$\ni \\omega_{\\text{pole}} = -a\n$$\n$$\n\\omega_{\\text{pole}} = \\frac{-a}{i} = \\frac{-a(-i)}{i(-i)} = \\frac{ia}{1} = ia\n$$\nThus, the pole is located at the purely imaginary value $\\omega_{\\text{pole}} = ia$ in the complex $\\omega$-plane.\n\nFinally, we interpret the significance of this pole's location with respect to causality and Bounded-Input Bounded-Output (BIBO) stability. The argument hinges on the analytic continuation of $X(\\omega)$ to a complex variable $\\tilde{\\omega} = \\omega_r + i\\omega_i$. The Fourier integral converges only for values of $\\tilde{\\omega}$ for which the real part of the exponent coefficient, $a - \\text{Im}(\\tilde{\\omega})$, is positive. This defines the Region of Convergence (ROC) as $\\text{Im}(\\tilde{\\omega})  a$.\n\nCausality of an LTI system means its impulse response $x(t)$ must be zero for $t  0$. Our $x(t)$ fulfills this by definition due to the $u(t)$ factor. For the Fourier transform convention $\\exp(-i\\omega t)$, a causal (right-sided) time-domain signal implies that its frequency-domain representation $X(\\tilde{\\omega})$ must be analytic in a lower half-plane. This means all poles of $X(\\tilde{\\omega})$ must lie in the complementary upper half-plane. Our pole is at $\\omega_{\\text{pole}} = ia$. Since the problem states $a  0$, the imaginary part of the pole is positive, $\\text{Im}(\\omega_{\\text{pole}}) = a  0$. The pole is therefore located in the upper half of the complex $\\omega$-plane, which is consistent with the causality of the system.\n\nBIBO stability of an LTI system requires its impulse response to be absolutely integrable, i.e., $\\int_{-\\infty}^{\\infty} |x(t)| dt  \\infty$. For our system, this condition is:\n$$\n\\int_{-\\infty}^{\\infty} |\\exp(-at) u(t)| dt = \\int_{0}^{\\infty} \\exp(-at) dt = \\left[ -\\frac{1}{a} \\exp(-at) \\right]_{0}^{\\infty} = \\frac{1}{a}\n$$\nSince $a  0$, this integral is finite, and the system is BIBO stable. In the frequency domain, stability requires that the real axis, $\\text{Im}(\\tilde{\\omega}) = 0$, be included within the ROC. Our ROC is $\\text{Im}(\\tilde{\\omega})  a$. Since $a  0$, the real axis (where $\\text{Im}(\\tilde{\\omega}) = 0$) is indeed strictly contained within the ROC. This implies that no poles can lie on the real axis, which would correspond to undamped oscillations and marginal stability or instability. Our pole at $\\omega_{\\text{pole}} = ia$ is not on the real axis. Therefore, the location of the pole strictly in the upper half-plane ($a0$) is fully consistent with the system being both causal and BIBO stable.", "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{1}{a + i \\omega}  i a \\end{pmatrix}}\n$$", "id": "3616300"}, {"introduction": "Moving from continuous-time theory to discrete-time computation on a computer requires careful consideration. While the convolution theorem elegantly states that $Y(\\omega) = H(\\omega)X(\\omega)$, its digital counterpart using the Discrete Fourier Transform (DFT) implicitly assumes that our signals are periodic. This assumption leads to circular convolution, which can produce wrap-around artifacts that do not exist in the true linear convolution. This coding practice [@problem_id:3616259] is designed to make this distinction tangible, challenging you to implement and compare linear convolution with the results of DFT-based circular convolution, and to master the zero-padding technique required to correctly compute linear convolution in the frequency domain.", "problem": "Consider a discrete-time, finite-length seismic trace modeled as a real-valued sequence $x[n]$ with $0 \\le n \\le N-1$, and a real-valued, finite impulse response $h[n]$ with $0 \\le n \\le M-1$. A linear time-invariant system is defined by the discrete-time linear convolution, which produces the true output $y_{\\text{true}}[n]$ of length $L = N + M - 1$ by $y_{\\text{true}}[n] = \\sum_{k=0}^{N-1} x[k] h[n-k]$ for all integer $n$, with implicit zero extension outside the support. The Discrete Fourier Transform (DFT) of a length-$K$ sequence $s[n]$, $0 \\le n \\le K-1$, is defined by $S[k] = \\sum_{n=0}^{K-1} s[n] e^{-i 2 \\pi k n / K}$ for $0 \\le k \\le K-1$, and the inverse Discrete Fourier Transform (IDFT) by $s[n] = \\frac{1}{K} \\sum_{k=0}^{K-1} S[k] e^{i 2 \\pi k n / K}$. In computational geophysics, frequency-domain methods compute system outputs by multiplying transforms and then inverting the transform. However, the DFT represents periodic sequences of period $K$, so frequency-domain multiplication with equal-length DFTs realizes circular convolution of period $K$ in the time domain. For finite seismic traces, this can introduce wrap-around artifacts unless zero-padding or block processing strategies are used.\n\nYour task is to:\n- Derive, from the given definitions, the precise relationship between circular convolution at length $K$ and frequency-domain multiplication of length-$K$ DFTs, and explain why using equal-length DFTs to compute outputs assumes periodic extension of the sequences.\n- Design an algorithmic procedure to compute three outputs from the same $(x[n], h[n])$ pair:\n  1. A naive circular-convolution output $y_{\\text{circ}}[n]$ of length $N$ computed by equal-length DFT multiplication and IDFT.\n  2. A zero-padded frequency-domain output $y_{\\text{zp}}[n]$ of length $L = N + M - 1$ computed by padding both $x[n]$ and $h[n]$ to length $L$, multiplying their DFTs, and applying the IDFT.\n  3. An overlap-add output $y_{\\text{ola}}[n]$ of length $L = N + M - 1$ computed by partitioning $x[n]$ into blocks of size $B$, zero-padding each block sufficiently to prevent aliasing, multiplying by the zero-padded transform of $h[n]$, and summing overlapped partial results. Choose the frequency-domain length $K_{\\text{ola}}$ such that $K_{\\text{ola}} \\ge B + M - 1$, and for efficiency take $K_{\\text{ola}}$ to be the smallest power of two satisfying this bound.\n- Quantify wrap-around artifacts introduced by circular convolution when compared to the true linear convolution. Define the artifact error vector by $e_{\\text{circ}}[n] = y_{\\text{circ}}[n] - y_{\\text{true}}[n]$ for $0 \\le n \\le N-1$. Compute the relative artifact energy ratio $R_{\\text{circ}} = \\frac{\\sum_{n=0}^{N-1} e_{\\text{circ}}[n]^2}{\\sum_{n=0}^{N-1} y_{\\text{true}}[n]^2}$. Further, quantify the concentration of wrap-around by computing the fraction of the artifact energy in the leading edge of width $M-1$: $F_{\\text{edge}} = \\frac{\\sum_{n=0}^{M-2} e_{\\text{circ}}[n]^2}{\\sum_{n=0}^{N-1} e_{\\text{circ}}[n]^2}$, with the convention $F_{\\text{edge}} = 0$ if the denominator is zero.\n- Quantify the accuracy of the zero-padded and overlap-add outputs relative to the true linear convolution by computing $R_{\\text{zp}} = \\frac{\\sum_{n=0}^{L-1} \\left(y_{\\text{zp}}[n] - y_{\\text{true}}[n]\\right)^2}{\\sum_{n=0}^{L-1} y_{\\text{true}}[n]^2}$ and $R_{\\text{ola}} = \\frac{\\sum_{n=0}^{L-1} \\left(y_{\\text{ola}}[n] - y_{\\text{true}}[n]\\right)^2}{\\sum_{n=0}^{L-1} y_{\\text{true}}[n]^2}$.\n- Implement all computations in a single program that constructs test inputs and computes the specified metrics for a set of test cases.\n\nConstruct $x[n]$ and $h[n]$ for each test case as follows:\n- Create a sparse reflectivity $x[n]$ by placing $K_{\\text{spk}}$ spikes at random positions in $0 \\le n \\le N-1$ with amplitudes drawn uniformly from $[-1, 1]$, and zeros elsewhere. Fix randomness via a case-specific seed to ensure reproducibility.\n- Create a wavelet impulse response $h[n]$ of length $M$ as a discrete Ricker wavelet with unit energy, parameterized by a dimensionless peak parameter $f_0$. Let $t[n] = n - \\frac{M-1}{2}$, and define $h[n] = \\left(1 - 2 (\\pi f_0 t[n])^2 \\right) \\exp\\left( - (\\pi f_0 t[n])^2 \\right)$, normalized to have $\\sum_{n=0}^{M-1} h[n]^2 = 1$.\n\nUse the following test suite, where each tuple specifies $(N, M, f_0, K_{\\text{spk}}, \\text{seed}, B)$:\n- Case $1$: $(256, 51, 0.12, 12, 1, 64)$.\n- Case $2$: $(128, 65, 0.20, 8, 2, 32)$.\n- Case $3$: $(64, 63, 0.25, 6, 3, 16)$.\n- Case $4$: $(300, 41, 0.15, 15, 4, 100)$.\n\nFor each case, compute and return the list $[R_{\\text{circ}}, F_{\\text{edge}}, R_{\\text{zp}}, R_{\\text{ola}}]$ where all quantities are defined as above. Your program should produce a single line of output containing the results as a comma-separated list of these per-case lists enclosed in square brackets, in the format $[[r_{1,1}, r_{1,2}, r_{1,3}, r_{1,4}], [r_{2,1}, r_{2,2}, r_{2,3}, r_{2,4}], [r_{3,1}, r_{3,2}, r_{3,3}, r_{3,4}], [r_{4,1}, r_{4,2}, r_{4,3}, r_{4,4}]]$. There are no physical units in this problem, and angles do not appear; therefore no unit conversions are required. All outputs must be real-valued floats.", "solution": "The problem at hand requires a rigorous comparison of different discrete convolution methods based on the Discrete Fourier Transform (DFT), a cornerstone of computational signal processing in fields such as geophysics. We must derive the theoretical underpinnings, design algorithms for several convolution variants, and quantify their performance and artifacts.\n\n### 1. Theoretical Foundation: The Convolution Theorem and Its Implications\n\nThe relationship between time-domain convolution and frequency-domain multiplication is governed by the convolution theorem. We first establish this relationship for the DFT and clarify its consequences for finite-length signals.\n\nLet $x[n]$ and $h[n]$ be two finite-length sequences of length $N$ and $M$ respectively. The linear convolution, which models the output of a linear time-invariant (LTI) system, is defined as:\n$$y_{\\text{true}}[n] = (x * h)[n] = \\sum_{k=-\\infty}^{\\infty} x[k] h[n-k]$$\nGiven that $x[n]$ is non-zero only for $0 \\le n \\le N-1$ and $h[n]$ is non-zero only for $0 \\le n \\le M-1$, the resulting sequence $y_{\\text{true}}[n]$ is non-zero only for $0 \\le n \\le N+M-2$. Thus, its total length is $L = N+M-1$.\n\nThe DFT and its inverse (IDFT) are defined for a length-$K$ sequence $s[n]$ as:\n$$S[k] = \\text{DFT}_K\\{s[n]\\} = \\sum_{n=0}^{K-1} s[n] e^{-i 2 \\pi k n / K}$$\n$$s[n] = \\text{IDFT}_K\\{S[k]\\} = \\frac{1}{K} \\sum_{k=0}^{K-1} S[k] e^{i 2 \\pi k n / K}$$\nA critical property of the DFT is that it implicitly treats any finite input sequence of length $K$ as a single period of an infinitely periodic sequence with period $K$. This is because the basis functions $e^{i 2 \\pi k n / K}$ are themselves periodic in $n$ with period $K$.\n\nLet us derive the time-domain operation corresponding to multiplication in the frequency domain. Let $y[n] = \\text{IDFT}_K\\{X[k]H[k]\\}$, where $X[k]=\\text{DFT}_K\\{x[n]\\}$ and $H[k]=\\text{DFT}_K\\{h[n]\\}$ (assuming both sequences are first padded or truncated to length $K$).\n$$y[n] = \\frac{1}{K} \\sum_{k=0}^{K-1} X[k]H[k] e^{i 2 \\pi k n / K}$$\nSubstitute the definition of $H[k]$:\n$$y[n] = \\frac{1}{K} \\sum_{k=0}^{K-1} X[k] \\left( \\sum_{m=0}^{K-1} h[m] e^{-i 2 \\pi k m / K} \\right) e^{i 2 \\pi k n / K}$$\nRearranging the terms:\n$$y[n] = \\sum_{m=0}^{K-1} h[m] \\left( \\frac{1}{K} \\sum_{k=0}^{K-1} X[k] e^{i 2 \\pi k (n-m) / K} \\right)$$\nThe term in the parenthesis is the definition of $\\text{IDFT}_K\\{X[k]\\}$ evaluated at time $(n-m)$. This is simply $x[n-m]$. However, due to the periodic nature of the DFT, this index is implicitly taken modulo $K$. Thus:\n$$y[n] = \\sum_{m=0}^{K-1} h[m] x[(n-m) \\pmod K]$$\nThis is the definition of **circular convolution** of length $K$. Therefore, multiplying the DFTs of two sequences is equivalent to performing circular convolution in the time domain, not linear convolution.\n\nTo compute linear convolution using the DFT, we must prevent the \"wrap-around\" effect of circular convolution. The linear convolution result has length $L = N+M-1$. If we choose a DFT length $K \\ge L$, the result of the circular convolution will have enough space to not wrap around. The result of the $K$-point circular convolution will be identical to the linear convolution result for the first $L$ points, followed by $K-L$ zeros.\n\n### 2. Algorithmic Design and Analysis\n\nBased on the theory above, we design the required computational procedures.\n\n**1. True Linear Convolution ($y_{\\text{true}}[n]$)**\nThis is the ground truth, computed directly in the time domain using the definition of linear convolution. This can be implemented via a direct summation or standard library functions (e.g., `numpy.convolve`). The output has length $L = N+M-1$.\n\n**2. Naive Circular Convolution ($y_{\\text{circ}}[n]$)**\nThis procedure demonstrates the wrap-around artifact. The length is specified as $N$.\n- Pad the impulse response $h[n]$ with zeros to match the length of the input signal, $N$. Let this be $h_N[n]$.\n- Compute the length-$N$ DFTs: $X[k] = \\text{DFT}_N\\{x[n]\\}$ and $H_N[k] = \\text{DFT}_N\\{h_N[n]\\}$.\n- Multiply the transforms: $Y_{\\text{circ}}[k] = X[k] \\cdot H_N[k]$.\n- Compute the inverse transform: $y_{\\text{circ}}[n] = \\text{IDFT}_N\\{Y_{\\text{circ}}[k]\\}$.\nThe result is a length-$N$ sequence. The portion of the linear convolution that would extend past index $N-1$ (the \"tail\") wraps around and is added to the beginning of the sequence. For $0 \\le n \\le M-2$, $y_{\\text{circ}}[n] = y_{\\text{true}}[n] + y_{\\text{true}}[n+N]$, which is the source of the artifact $e_{\\text{circ}}[n]$ in this range.\n\n**3. Zero-Padded Frequency-Domain Convolution ($y_{\\text{zp}}[n]$)**\nThis is the standard and correct method for computing linear convolution via the FFT.\n- Determine the required output length: $L = N+M-1$.\n- Pad both $x[n]$ and $h[n]$ with zeros to length $L$. Let these be $x_L[n]$ and $h_L[n]$.\n- Compute the length-$L$ DFTs: $X_L[k] = \\text{DFT}_L\\{x_L[n]\\}$ and $H_L[k] = \\text{DFT}_L\\{h_L[n]\\}$.\n- Multiply the transforms and invert: $y_{\\text{zp}}[n] = \\text{IDFT}_L\\{X_L[k] \\cdot H_L[k]\\}$.\nThe resulting sequence $y_{\\text{zp}}[n]$ will be of length $L$ and, ignoring floating-point errors, will be identical to $y_{\\text{true}}[n]$.\n\n**4. Overlap-Add Block Convolution ($y_{\\text{ola}}[n]$)**\nThis is an efficient method for convolving a long signal $x[n]$ with a shorter filter $h[n]$.\n- Partition the input signal $x[n]$ into non-overlapping blocks of size $B$.\n- Determine the FFT size, $K_{\\text{ola}}$, required to compute the linear convolution of a block with $h[n]$ without aliasing. We need $K_{\\text{ola}} \\ge B+M-1$. For efficiency, $K_{\\text{ola}}$ is chosen as the smallest power of two satisfying this condition.\n- Pre-compute the zero-padded, length-$K_{\\text{ola}}$ DFT of the filter: $h[n]$ is padded to length $K_{\\text{ola}}$ and transformed to $H_{\\text{ola}}[k]$.\n- Initialize an output buffer $y_{\\text{ola}}[n]$ of length $L = N+M-1$ to all zeros.\n- For each block $x_i[n]$ of $x[n]$ (starting at time index $i \\cdot B$):\n    - Pad the block $x_i[n]$ to length $K_{\\text{ola}}$.\n    - Compute its DFT, $X_i[k]$, and multiply by the stored $H_{\\text{ola}}[k]$ to get $Y_i[k]$.\n    - Compute the inverse DFT, $y_i[n] = \\text{IDFT}_{K_{\\text{ola}}}\\{Y_i[k]\\}$. This is the linear convolution of the block.\n    - Add this result $y_i[n]$ into the main output buffer $y_{\\text{ola}}[n]$ at the correct starting position, $i \\cdot B$. The results of consecutive blocks will overlap by $M-1$ samples and are summed together.\nLike $y_{\\text{zp}}[n]$, the final result $y_{\\text{ola}}[n]$ should be identical to $y_{\\text{true}}[n]$ up to numerical precision.\n\n### 3. Quantification of Artifacts and Accuracy\n\nThe problem requires a set of metrics to quantify the differences between these methods.\n- **Relative Circular Artifact Energy ($R_{\\text{circ}}$)**: $R_{\\text{circ}} = \\frac{\\sum_{n=0}^{N-1} (y_{\\text{circ}}[n] - y_{\\text{true}}[n])^2}{\\sum_{n=0}^{N-1} y_{\\text{true}}[n]^2}$. This measures the energy of the error introduced by circular wrap-around, relative to the energy of the true signal over the same interval.\n- **Leading Edge Error Fraction ($F_{\\text{edge}}$)**: $F_{\\text{edge}} = \\frac{\\sum_{n=0}^{M-2} e_{\\text{circ}}[n]^2}{\\sum_{n=0}^{N-1} e_{\\text{circ}}[n]^2}$. This quantifies how much of the total wrap-around error energy is concentrated in the first $M-1$ samples of the output, which is the region directly affected by the tail wrapping around.\n- **Relative Accuracy of Padded/Overlap-Add Methods ($R_{\\text{zp}}, R_{\\text{ola}}$)**:\n  $R_{\\text{zp}} = \\frac{\\sum_{n=0}^{L-1} (y_{\\text{zp}}[n] - y_{\\text{true}}[n])^2}{\\sum_{n=0}^{L-1} y_{\\text{true}}[n]^2}$ and $R_{\\text{ola}} = \\frac{\\sum_{n=0}^{L-1} (y_{\\text{ola}}[n] - y_{\\text{true}}[n])^2}{\\sum_{n=0}^{L-1} y_{\\text{true}}[n]^2}$. These measure the relative mean squared error for the zero-padded and overlap-add methods compared to the true linear convolution. Since these methods are theoretically exact, these values should be extremely small, on the order of machine precision, reflecting only floating-point arithmetic inaccuracies.\n  \nThe implementation will construct the specified input signals and compute these four metrics for each test case.", "answer": "```python\nimport numpy as np\nfrom scipy.fft import fft, ifft\n\ndef compute_metrics_for_case(case_params):\n    \"\"\"\n    Computes all required convolution variants and error metrics for a single test case.\n    \"\"\"\n    N, M, f0, K_spk, seed, B = case_params\n    L = N + M - 1\n\n    # --- 1. Construct input signals x[n] and h[n] ---\n    \n    # Sparse reflectivity x[n]\n    rng = np.random.default_rng(seed)\n    spike_indices = rng.choice(N, size=K_spk, replace=False)\n    spike_amplitudes = rng.uniform(-1, 1, size=K_spk)\n    x = np.zeros(N)\n    x[spike_indices] = spike_amplitudes\n\n    # Ricker wavelet h[n]\n    t = np.arange(M) - (M - 1) / 2.0\n    term = (np.pi * f0 * t)**2\n    h = (1 - 2 * term) * np.exp(-term)\n    h /= np.linalg.norm(h) # Normalize to unit energy\n\n    # --- 2. Compute convolution outputs ---\n\n    # Method 1: True Linear Convolution (ground truth)\n    y_true = np.convolve(x, h)\n\n    # Method 2: Naive Circular Convolution\n    h_N = np.zeros(N)\n    if M  0:\n      h_N[:M] = h\n    Y_circ_k = fft(x) * fft(h_N)\n    y_circ = ifft(Y_circ_k).real\n\n    # Method 3: Zero-Padded Frequency-Domain Convolution\n    x_L = np.zeros(L)\n    x_L[:N] = x\n    h_L = np.zeros(L)\n    h_L[:M] = h\n    Y_zp_k = fft(x_L) * fft(h_L)\n    y_zp = ifft(Y_zp_k).real\n    \n    # Method 4: Overlap-Add Block Convolution\n    L_block = B + M - 1\n    # Smallest power of 2 = L_block\n    K_ola = 1  (L_block - 1).bit_length() if L_block  0 else 1\n    \n    h_ola = np.zeros(K_ola)\n    h_ola[:M] = h\n    H_ola_k = fft(h_ola)\n    \n    y_ola = np.zeros(L)\n    num_blocks = int(np.ceil(N / B))\n\n    for i in range(num_blocks):\n        start = i * B\n        end = min((i + 1) * B, N)\n        x_block = x[start:end]\n        \n        x_block_padded = np.zeros(K_ola)\n        x_block_padded[:len(x_block)] = x_block\n        \n        Y_block_k = fft(x_block_padded) * H_ola_k\n        y_block = ifft(Y_block_k).real\n        \n        add_len = min(K_ola, L - start)\n        y_ola[start : start + add_len] += y_block[:add_len]\n\n    # --- 3. Quantify artifacts and accuracy ---\n\n    # R_circ and F_edge\n    y_true_N = y_true[:N]\n    e_circ = y_circ - y_true_N\n    \n    den_y_true_N_sq = np.sum(y_true_N**2)\n    R_circ = np.sum(e_circ**2) / den_y_true_N_sq if den_y_true_N_sq  0 else 0.0\n\n    err_e_circ_sq = np.sum(e_circ**2)\n    F_edge = np.sum(e_circ[:M-1]**2) / err_e_circ_sq if err_e_circ_sq  0 else 0.0\n\n    # R_zp and R_ola\n    den_y_true_sq = np.sum(y_true**2)\n    \n    e_zp = y_zp - y_true\n    R_zp = np.sum(e_zp**2) / den_y_true_sq if den_y_true_sq  0 else 0.0\n    \n    e_ola = y_ola - y_true\n    R_ola = np.sum(e_ola**2) / den_y_true_sq if den_y_true_sq  0 else 0.0\n    \n    return [R_circ, F_edge, R_zp, R_ola]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (N, M, f0, K_spk, seed, B)\n        (256, 51, 0.12, 12, 1, 64),\n        (128, 65, 0.20, 8, 2, 32),\n        (64, 63, 0.25, 6, 3, 16),\n        (300, 41, 0.15, 15, 4, 100),\n    ]\n\n    results = []\n    for case in test_cases:\n        case_results = compute_metrics_for_case(case)\n        results.append(case_results)\n\n    # Format the final output string\n    # str(list) automatically adds brackets, so map(str, results) and then join\n    # gives the desired \"[[...],[...]]\" structure.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3616259"}, {"introduction": "The accuracy of any geophysical model depends critically on the fidelity of the digital data it uses. Before we even apply the convolution theorem, we must ensure our continuous real-world signals are properly sampled into discrete sequences. This numerical experiment [@problem_id:3616254] bridges the gap between continuous reality and discrete computation, tasking you with simulating a marine source deghosting scenario. By comparing convolutions performed on signals sampled at different rates against a high-fidelity reference, you will quantify the impact of aliasing and gain a practical understanding of how the Nyquist sampling theorem is a crucial prerequisite for obtaining meaningful results from LTI system analysis.", "problem": "Design and implement a numerical experiment to evaluate the equivalence of direct time-domain linear convolution and frequency-domain convolution via the Fast Fourier Transform (FFT) for a marine source deghosting operator, and to quantify aliasing errors introduced when sampling violates the Nyquist criterion for the source signature. The system under investigation is a linear time-invariant operator with impulse response $g(t)$ acting on a source signature $s(t)$ to produce a data trace $d(t)$, where $d(t)$ equals the linear convolution of $g(t)$ and $s(t)$. The experiment must be constructed purely in mathematical terms as follows.\n\n1. Define the marine source ghost operator as a two-tap impulse response $g(t) = \\delta(t) - \\alpha \\,\\delta(t - \\tau)$, where $\\delta(t)$ denotes the Dirac delta, $\\alpha \\in (0,1]$ is a reflection coefficient, and $\\tau$ is the free-surface ghost delay. Use $\\alpha = 0.98$ (dimensionless), $\\tau = 2 z / c$, with source depth $z = 6\\,\\mathrm{m}$ and water sound speed $c = 1500\\,\\mathrm{m/s}$. All times must be expressed in seconds.\n\n2. Define the source signature $s(t)$ as a sum of two Ricker wavelets with central frequencies $f_{0}$ and $f_{1}$, respectively:\n$$\ns(t) = w(t; f_{0}) + 0.5\\, w(t; f_{1}) ,\n$$\nwhere the Ricker wavelet is given by\n$$\nw(t; f) = \\left(1 - 2 \\pi^{2} f^{2} t^{2}\\right)\\exp\\left(-\\pi^{2} f^{2} t^{2}\\right).\n$$\nFrequencies are in $\\mathrm{Hz}$, time is in $\\mathrm{s}$, and amplitudes are dimensionless.\n\n3. Construct a uniform time grid on the symmetric interval $[-T/2, T/2]$ with step $\\Delta t$ for the discrete-time experiment, and a fine reference grid with step $\\Delta t_{\\mathrm{ref}}$ such that $\\Delta t_{\\mathrm{ref}}$ exactly divides $\\Delta t$. Use $T = 1.0\\,\\mathrm{s}$ and $\\Delta t_{\\mathrm{ref}} = 0.0005\\,\\mathrm{s}$. The fine-grid discrete convolution of the corresponding sampled $g(t)$ and $s(t)$ will serve as a reference approximation to the continuous-time convolution. Downsample the fine-grid convolution by integer factor $M = \\Delta t / \\Delta t_{\\mathrm{ref}}$ to obtain the reference on the coarse grid.\n\n4. Implement two methods to compute the discrete linear convolution on the coarse grid:\n   - Direct time-domain convolution using the definition of linear convolution for sequences sampled on the coarse grid.\n   - Frequency-domain convolution via the Fast Fourier Transform (FFT), implemented as linear convolution by zero-padding each input sequence to a length $L \\geq N+M-1$ (where $N$ and $M$ are the lengths of the two discrete sequences), multiplying the Discrete Fourier Transforms (DFTs) element-wise, and then applying the inverse DFT, followed by truncation to the first $N+M-1$ samples.\n\n5. Define two quantitative error metrics:\n   - Convolution-method consistency error:\n     $$\n     \\varepsilon_{\\mathrm{method}} = \\frac{\\lVert d_{\\mathrm{time}} - d_{\\mathrm{fft}} \\rVert_{2}}{\\lVert d_{\\mathrm{time}} \\rVert_{2}} ,\n     $$\n     where $d_{\\mathrm{time}}$ and $d_{\\mathrm{fft}}$ are the linear convolution results from the direct and FFT-based methods, respectively.\n   - Aliasing error relative to the downsampled fine-grid reference:\n     $$\n     \\varepsilon_{\\mathrm{alias}} = \\frac{\\lVert d_{\\mathrm{time}} - d_{\\mathrm{ref}\\downarrow} \\rVert_{2}}{\\lVert d_{\\mathrm{ref}\\downarrow} \\rVert_{2}} ,\n     $$\n     where $d_{\\mathrm{ref}\\downarrow}$ is the downsampled fine-grid reference. Both errors are dimensionless and must be reported as decimals, not percentages.\n\n6. Use the following test suite of parameter values to probe both a typical case and aliasing edge cases. For each case, specify $(\\Delta t, f_{0}, f_{1})$:\n   - Case $1$ (happy path, well below Nyquist): $(\\Delta t = 0.002\\,\\mathrm{s}, f_{0} = 20\\,\\mathrm{Hz}, f_{1} = 120\\,\\mathrm{Hz})$.\n   - Case $2$ (boundary, near Nyquist for the higher component): $(\\Delta t = 0.004\\,\\mathrm{s}, f_{0} = 30\\,\\mathrm{Hz}, f_{1} = 120\\,\\mathrm{Hz})$.\n   - Case $3$ (aliased, violates Nyquist for the higher component): $(\\Delta t = 0.008\\,\\mathrm{s}, f_{0} = 30\\,\\mathrm{Hz}, f_{1} = 120\\,\\mathrm{Hz})$.\n\n7. For each test case, compute and return the two metrics $\\varepsilon_{\\mathrm{method}}$ and $\\varepsilon_{\\mathrm{alias}}$. Your program should produce a single line of output containing all six results as a comma-separated list enclosed in square brackets in the order\n$$\n[\\varepsilon_{\\mathrm{method},1}, \\varepsilon_{\\mathrm{alias},1}, \\varepsilon_{\\mathrm{method},2}, \\varepsilon_{\\mathrm{alias},2}, \\varepsilon_{\\mathrm{method},3}, \\varepsilon_{\\mathrm{alias},3}] .\n$$\n\nEnsure that all computations use seconds for time and Hertz for frequency. All final answers must be dimensionless decimals. The output must be fully reproducible and require no user input.", "solution": "The problem statement has been critically validated and is deemed scientifically sound, well-posed, objective, and complete. All parameters and definitions are sufficient to construct a unique and meaningful numerical experiment. The scenario is a standard application of digital signal processing principles to a simplified but realistic geophysical problem. The specified tasks directly test the equivalence of time- and frequency-domain convolution and the effects of aliasing as dictated by the Nyquist-Shannon sampling theorem.\n\nThe solution proceeds by implementing a numerical simulation according to the problem's specifications. The core of the experiment is to compute a geophysical data trace, $d(t)$, which results from the linear convolution of a source signature, $s(t)$, with a marine ghost operator, $g(t)$. The relationship is $d(t) = (g*s)(t)$.\n\nFirst, we define the parameters and continuous-time functions. The marine ghost operator, which models the reflection from the sea surface, is given by the impulse response $g(t) = \\delta(t) - \\alpha \\,\\delta(t - \\tau)$. The reflection coefficient is $\\alpha = 0.98$. The ghost delay $\\tau$ is determined by the source depth $z=6\\,\\mathrm{m}$ and the speed of sound in water $c=1500\\,\\mathrm{m/s}$, yielding $\\tau = 2z/c = 2 \\times 6 / 1500 = 0.008\\,\\mathrm{s}$. The source signature $s(t)$ is a composite signal formed by the sum of two Ricker wavelets: $s(t) = w(t; f_{0}) + 0.5\\, w(t; f_{1})$, where the Ricker wavelet is defined as $w(t; f) = \\left(1 - 2 \\pi^{2} f^{2} t^{2}\\right)\\exp\\left(-\\pi^{2} f^{2} t^{2}\\right)$.\n\nThe numerical experiment is conducted on discrete time grids. A fine reference grid is established over the time interval $[-T/2, T/2]$ with $T=1.0\\,\\mathrm{s}$ and a time step of $\\Delta t_{\\mathrm{ref}} = 0.0005\\,\\mathrm{s}$. This grid has $N_{\\mathrm{ref}} = T/\\Delta t_{\\mathrm{ref}} + 1 = 2001$ points. For each test case, a corresponding coarse grid is defined with a time step $\\Delta t$, resulting in $N_{\\mathrm{coarse}} = T/\\Delta t + 1$ points. The continuous functions $s(t)$ and $g(t)$ are sampled on these grids to produce the discrete sequences $s_{\\mathrm{ref}}$, $g_{\\mathrm{ref}}$, $s_{\\mathrm{coarse}}$, and $g_{\\mathrm{coarse}}$. The Dirac delta function $\\delta(t-t_0)$ is numerically represented as a Kronecker delta: a sequence with a value of $1$ at the sample index corresponding to time $t_0$ and $0$ otherwise. Since the ghost delay $\\tau=0.008\\,\\mathrm{s}$ is an integer multiple of $\\Delta t_{\\mathrm{ref}}$ and all coarse $\\Delta t$ values, the Kronecker delta falls exactly on a grid point, simplifying the discretization.\n\nThe experiment requires computing the discrete linear convolution in three ways:\n\n1.  **Reference Convolution, $d_{\\mathrm{ref}\\downarrow}$**: The high-fidelity reference signal, $d_{\\mathrm{ref}}$, is computed by performing a full linear convolution of the finely-sampled sequences $s_{\\mathrm{ref}}$ and $g_{\\mathrm{ref}}$. The result is a sequence of length $2N_{\\mathrm{ref}}-1$. This is then downsampled by an integer factor $M = \\Delta t / \\Delta t_{\\mathrm{ref}}$ by taking every $M$-th sample. This yields the downsampled reference $d_{\\mathrm{ref}\\downarrow}$, which has a length of $2N_{\\mathrm{coarse}}-1$ and can be directly compared to the results from the coarse grid.\n\n2.  **Direct Time-Domain Convolution, $d_{\\mathrm{time}}$**: This is computed by the direct application of the linear convolution sum on the coarse-grid sequences, $d_{\\mathrm{time}} = \\mathrm{convolve}(s_{\\mathrm{coarse}}, g_{\\mathrm{coarse}})$. This operation is performed using `numpy.convolve` with `mode='full'`, resulting in a sequence of length $2N_{\\mathrm{coarse}}-1$.\n\n3.  **Frequency-Domain Convolution, $d_{\\mathrm{fft}}$**: The convolution theorem states that convolution in the time domain is equivalent to multiplication in the frequency domain. This is implemented by zero-padding $s_{\\mathrm{coarse}}$ and $g_{\\mathrm{coarse}}$ to the length of the full convolution ($2N_{\\mathrm{coarse}}-1$), computing their Discrete Fourier Transforms (DFTs) via the Fast Fourier Transform (FFT) algorithm, multiplying the resulting spectra element-wise, and finally applying an inverse FFT to obtain $d_{\\mathrm{fft}}$. This procedure yields a result that is, in theory, identical to $d_{\\mathrm{time}}$.\n\nFinally, two error metrics are computed for each test case.\nThe convolution-method consistency error, $\\varepsilon_{\\mathrm{method}} = \\lVert d_{\\mathrm{time}} - d_{\\mathrm{fft}} \\rVert_{2} / \\lVert d_{\\mathrm{time}} \\rVert_{2}$, quantifies the numerical difference between the direct and FFT-based convolution methods. Due to the properties of the DFT, this error is expected to be near machine precision.\nThe aliasing error, $\\varepsilon_{\\mathrm{alias}} = \\lVert d_{\\mathrm{time}} - d_{\\mathrm{ref}\\downarrow} \\rVert_{2} / \\lVert d_{\\mathrm{ref}\\downarrow} \\rVert_{2}$, measures the error introduced by sampling the continuous signal $s(t)$ at a rate $\\Delta t$ that may be insufficient. According to the Nyquist criterion, a signal must be sampled at a rate greater than twice its highest frequency component to avoid aliasing.\n- For Case 1 ($\\Delta t = 0.002\\,\\mathrm{s}$), the Nyquist frequency is $f_{\\mathrm{Nyq}} = 250\\,\\mathrm{Hz}$, well above the significant frequencies in $s(t)$, so $\\varepsilon_{\\mathrm{alias}}$ should be small.\n- For Case 2 ($\\Delta t = 0.004\\,\\mathrm{s}$), $f_{\\mathrm{Nyq}} = 125\\,\\mathrm{Hz}$, which is very close to the higher frequency component $f_1=120\\,\\mathrm{Hz}$, so some aliasing is expected.\n- For Case 3 ($\\Delta t = 0.008\\,\\mathrm{s}$), $f_{\\mathrm{Nyq}} = 62.5\\,\\mathrm{Hz}$, which is significantly lower than $f_1=120\\,\\mathrm{Hz}$, leading to substantial aliasing and a large $\\varepsilon_{\\mathrm{alias}}$.\n\nThe code implements this procedure for each of the three specified test cases and formats the six resulting error metrics into the required output string.", "answer": "```python\nimport numpy as np\nfrom scipy.signal import fftconvolve\n\ndef solve():\n    \"\"\"\n    Designs and implements a numerical experiment to evaluate convolution methods\n    and quantify aliasing errors for a marine source deghosting problem.\n    \"\"\"\n    # Define physical and simulation constants\n    ALPHA = 0.98  # Reflection coefficient\n    Z = 6.0       # Source depth in meters\n    C = 1500.0    # Water sound speed in m/s\n    T = 1.0       # Total time duration in seconds\n    DT_REF = 0.0005 # Time step for fine reference grid in seconds\n\n    # Define the test suite of parameters (dt, f0, f1)\n    test_cases = [\n        (0.002, 20.0, 120.0),  # Case 1: Well-sampled\n        (0.004, 30.0, 120.0),  # Case 2: Near Nyquist boundary\n        (0.008, 30.0, 120.0),  # Case 3: Aliased\n    ]\n\n    # Calculate the free-surface ghost delay\n    tau = 2 * Z / C\n\n    def ricker_wavelet(t, f):\n        \"\"\"Computes a Ricker wavelet for a given time array and central frequency.\"\"\"\n        pi2_f2_t2 = (np.pi * f * t)**2\n        return (1.0 - 2.0 * pi2_f2_t2) * np.exp(-pi2_f2_t2)\n\n    def source_signature(t, f0, f1):\n        \"\"\"Computes the composite source signature.\"\"\"\n        return ricker_wavelet(t, f0) + 0.5 * ricker_wavelet(t, f1)\n\n    results = []\n    \n    # Process each test case\n    for dt, f0, f1 in test_cases:\n        # 1. Construct Time Grids\n        # Fine reference grid\n        n_ref = int(T / DT_REF) + 1\n        t_ref = np.linspace(-T / 2, T / 2, n_ref)\n\n        # Coarse grid for the current test case\n        n_coarse = int(T / dt) + 1\n        t_coarse = np.linspace(-T / 2, T / 2, n_coarse)\n\n        # 2. Generate Discrete-Time Signals\n        # Signals on the fine reference grid\n        s_ref = source_signature(t_ref, f0, f1)\n        g_ref = np.zeros(n_ref)\n        idx_0_ref = n_ref // 2\n        idx_tau_ref = idx_0_ref + int(round(tau / DT_REF))\n        g_ref[idx_0_ref] = 1.0\n        g_ref[idx_tau_ref] = -ALPHA\n\n        # Signals on the coarse grid\n        s_coarse = source_signature(t_coarse, f0, f1)\n        g_coarse = np.zeros(n_coarse)\n        idx_0_coarse = n_coarse // 2\n        idx_tau_coarse = idx_0_coarse + int(round(tau / dt))\n        g_coarse[idx_0_coarse] = 1.0\n        g_coarse[idx_tau_coarse] = -ALPHA\n        \n        # 3. Compute Convolutions\n        # High-fidelity reference convolution on the fine grid\n        d_ref_full = fftconvolve(s_ref, g_ref, mode='full')\n        \n        # Downsample the reference to match the coarse grid convolution length\n        M = int(dt / DT_REF)\n        d_ref_down = d_ref_full[::M]\n        \n        # Method 1: Direct time-domain convolution on the coarse grid\n        d_time = np.convolve(s_coarse, g_coarse, mode='full')\n        \n        # Method 2: Frequency-domain convolution via FFT on the coarse grid\n        d_fft = fftconvolve(s_coarse, g_coarse, mode='full')\n\n        # Ensure lengths are consistent for comparison\n        expected_len = 2 * n_coarse - 1\n        if len(d_ref_down) != expected_len:\n            # Truncate if there's a minor length mismatch from slicing\n            d_ref_down = d_ref_down[:expected_len]\n\n        # 4. Calculate Error Metrics\n        # Convolution-method consistency error\n        norm_d_time = np.linalg.norm(d_time)\n        if norm_d_time > 0:\n            eps_method = np.linalg.norm(d_time - d_fft) / norm_d_time\n        else:\n            eps_method = 0.0\n\n        # Aliasing error relative to the downsampled reference\n        norm_d_ref_down = np.linalg.norm(d_ref_down)\n        if norm_d_ref_down > 0:\n            eps_alias = np.linalg.norm(d_time - d_ref_down) / norm_d_ref_down\n        else:\n            eps_alias = 0.0 if np.linalg.norm(d_time) == 0 else 1.0\n\n        results.extend([eps_method, eps_alias])\n\n    # Format and print the final output string\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3616254"}]}