{"hands_on_practices": [{"introduction": "Fast convolution via the Fast Fourier Transform (FFT) is a fundamental tool in signal processing, but its naive application can produce significant errors. This exercise provides a concrete demonstration of time-domain aliasing, which occurs when performing convolution in the frequency domain without adequate zero-padding [@problem_id:3616396]. By manually calculating the wrap-around artifacts, you will gain a deeper, quantitative understanding of the relationship between linear and circular convolution and appreciate why correct padding is non-negotiable for accurate results.", "problem": "In exploration seismology, the recorded trace is often modeled as the linear convolution of a band-limited source wavelet and a sparse reflectivity series. Frequency-domain implementations accelerate this operation using the Discrete Fourier Transform (DFT), computed by the Fast Fourier Transform (FFT). When the DFT length is insufficient relative to the total convolution length, the inverse DFT produces a circular convolution, causing time-domain wrap-around artifacts that corrupt early samples.\n\nConsider a finite source wavelet $w[n]$ and reflectivity series $r[n]$, indexed by $n \\in \\{0,1,2,\\dots\\}$ and zero outside their stated support. Let $w[n]$ have length $L=4$ with samples\n$$\nw[0]=2,\\quad w[1]=-1,\\quad w[2]=3,\\quad w[3]=1,\n$$\nand let $r[n]$ have length $M=5$ with samples\n$$\nr[0]=1,\\quad r[1]=-2,\\quad r[2]=0,\\quad r[3]=1,\\quad r[4]=2.\n$$\nDefine the linear convolution $y[n] = \\sum_{m=0}^{L-1} w[m]\\,r[n-m]$ for $n=0,1,\\dots,L+M-2$ with the convention that $r[n]=0$ for $n<0$ or $n>M-1$. Suppose we compute the convolution via frequency-domain multiplication using an $N$-point Discrete Fourier Transform (DFT) with $N=6$ (i.e., both $w[n]$ and $r[n]$ are zero-padded to length $N=6$, multiplied in the DFT domain, and then inverse transformed), yielding the $N$-point circular convolution $y^{(N)}[n]$, $n=0,1,\\dots,5$.\n\nStarting from the definition of the Discrete Fourier Transform (DFT) and its inverse, and the definition of linear convolution, determine quantitatively which time-domain samples of $y^{(N)}[n]$ are contaminated by wrap-around artifacts and compute their values. Report the contaminated sample values of $y^{(N)}[n]$ in order of increasing sample index as a single vector. No rounding is required. Use zero-based indexing throughout and assume sequences are real-valued.", "solution": "The problem requires the identification and calculation of time-domain samples from a circular convolution that are contaminated by wrap-around artifacts. This occurs when implementing linear convolution using the Discrete Fourier Transform (DFT) with a transform length $N$ that is insufficient to hold the full result of the linear convolution.\n\nFirst, we state the definitions and given data. The source wavelet, $w[n]$, is a sequence of length $L=4$ with values:\n$$\nw[0]=2, \\quad w[1]=-1, \\quad w[2]=3, \\quad w[3]=1\n$$\nThe reflectivity series, $r[n]$, is a sequence of length $M=5$ with values:\n$$\nr[0]=1, \\quad r[1]=-2, \\quad r[2]=0, \\quad r[3]=1, \\quad r[4]=2\n$$\nBoth sequences are zero for all other indices $n$.\n\nThe linear convolution, $y[n]$, of these two sequences is defined as:\n$$\ny[n] = (w * r)[n] = \\sum_{m=-\\infty}^{\\infty} w[m] r[n-m]\n$$\nFor finite-duration causal sequences, this becomes $y[n] = \\sum_{m=0}^{L-1} w[m] r[n-m]$. The resulting sequence $y[n]$ is non-zero over a support of length $L+M-1$. In this case, the length of $y[n]$ is $4+5-1 = 8$. The non-zero samples are for indices $n \\in \\{0, 1, \\dots, 7\\}$.\n\nThe problem states that the convolution is computed via an $N$-point DFT, with $N=6$. This involves zero-padding $w[n]$ and $r[n]$ to length $N=6$, computing their respective $N$-point DFTs, multiplying the DFTs, and performing an $N$-point inverse DFT. This procedure produces the $N$-point circular convolution of the padded sequences, which we denote as $y^{(N)}[n]$ or $y^{(6)}[n]$.\n\nThe relationship between the linear convolution $y[n]$ and the circular convolution $y^{(N)}[n]$ is given by the time-domain aliasing formula:\n$$\ny^{(N)}[n] = \\sum_{k=-\\infty}^{\\infty} y[n+kN]\n$$\nfor $n=0, 1, \\dots, N-1$. Here, $N=6$. This formula shows that the circular convolution is a sum of the linear convolution and its shifted (aliased) copies.\n\nA sample $y^{(N)}[n]$ is considered \"contaminated\" or affected by wrap-around if it is not equal to the corresponding linear convolution sample $y[n]$. This occurs when at least one term $y[n+kN]$ is non-zero for $k \\neq 0$. For a linear convolution $y[n]$ of length $L+M-1=8$, and a DFT length $N=6$, the samples of $y[n]$ with indices $n \\geq N$ will wrap around. In this case, the samples $y[6]$ and $y[7]$ will alias.\n\nThe sample $y[6]$ corresponds to $n=0$ and $k=1$ in the summation, since $0+1 \\cdot 6 = 6$. Thus, $y[6]$ will be added to $y[0]$, contaminating the circular convolution sample $y^{(6)}[0]$.\nThe sample $y[7]$ corresponds to $n=1$ and $k=1$ in the summation, since $1+1 \\cdot 6 = 7$. Thus, $y[7]$ will be added to $y[1]$, contaminating the circular convolution sample $y^{(6)}[1]$.\nFor indices $n \\in \\{2, 3, 4, 5\\}$, the term $y[n+k \\cdot 6]$ is non-zero only for $k=0$, because $y[n]$ is zero for $n \\geq 8$. Therefore, the samples $y^{(6)}[2]$ through $y^{(6)}[5]$ are uncontaminated and equal to their linear convolution counterparts.\n\nThe contaminated samples are at indices $n=0$ and $n=1$. To find their values, we must first compute the required samples of the linear convolution $y[n]$.\nThe linear convolution sequence $y[n]$ is calculated as follows:\n$y[0] = w[0]r[0] = (2)(1) = 2$\n$y[1] = w[0]r[1] + w[1]r[0] = (2)(-2) + (-1)(1) = -4 - 1 = -5$\n$y[2] = w[0]r[2] + w[1]r[1] + w[2]r[0] = (2)(0) + (-1)(-2) + (3)(1) = 0 + 2 + 3 = 5$\n$y[3] = w[0]r[3] + w[1]r[2] + w[2]r[1] + w[3]r[0] = (2)(1) + (-1)(0) + (3)(-2) + (1)(1) = 2 - 6 + 1 = -3$\n$y[4] = w[0]r[4] + w[1]r[3] + w[2]r[2] + w[3]r[1] = (2)(2) + (-1)(1) + (3)(0) + (1)(-2) = 4 - 1 - 2 = 1$\n$y[5] = w[1]r[4] + w[2]r[3] + w[3]r[2] = (-1)(2) + (3)(1) + (1)(0) = -2 + 3 = 1$\n$y[6] = w[2]r[4] + w[3]r[3] = (3)(2) + (1)(1) = 6 + 1 = 7$\n$y[7] = w[3]r[4] = (1)(2) = 2$\n\nNow we can calculate the values of the contaminated samples of the circular convolution $y^{(6)}[n]$.\nFor $n=0$:\n$$\ny^{(6)}[0] = \\sum_{k=-\\infty}^{\\infty} y[0+6k] = \\dots + y[-6] + y[0] + y[6] + y[12] + \\dots\n$$\nSince $y[n]$ is non-zero only for $n \\in \\{0, \\dots, 7\\}$, this sum reduces to:\n$$\ny^{(6)}[0] = y[0] + y[6] = 2 + 7 = 9\n$$\nFor $n=1$:\n$$\ny^{(6)}[1] = \\sum_{k=-\\infty}^{\\infty} y[1+6k] = \\dots + y[-5] + y[1] + y[7] + y[13] + \\dots\n$$\nThis sum reduces to:\n$$\ny^{(6)}[1] = y[1] + y[7] = -5 + 2 = -3\n$$\nThe contaminated samples are $y^{(6)}[0]=9$ and $y^{(6)}[1]=-3$. The problem asks for these values as a single vector in order of increasing index.", "answer": "$$\n\\boxed{\\begin{pmatrix} 9 & -3 \\end{pmatrix}}\n$$", "id": "3616396"}, {"introduction": "Estimating the precise frequency of a signal component is a common task in geophysical data analysis, but the true frequency rarely falls exactly on a Discrete Fourier Transform (DFT) bin. This exercise explores how zero-padding can be used as a powerful tool to improve the accuracy of frequency estimation [@problem_id:3616424]. Through a hands-on coding task involving quadratic interpolation, you will quantify how densifying the DFT grid enhances the precision of sub-bin peak localization.", "problem": "Consider a length-$N$ discrete-time complex sinusoid $x[n]$ with unit amplitude and fixed phase, whose normalized digital frequency corresponds to $m+0.3$ Discrete Fourier Transform (DFT) bins, where $m$ is an integer. By definition, the $k$-th DFT bin corresponds to the angular frequency $2\\pi k/N$ radians per sample. The base principles are: (i) the Discrete Fourier Transform (DFT) is a uniform sampling of the Discrete-Time Fourier Transform (DTFT) on the discrete frequency grid $2\\pi k/N$, and (ii) zero-padding a time-domain sequence to length $L>N$ computes DFT samples on a denser frequency grid while leaving the underlying DTFT unchanged. You will quantify the effect of zero-padding on interpolated spectral peak localization by comparing $N$-point and $2N$-point DFT-based peak estimates for the same finite-duration sinusoid.\n\nTasks:\n1. Signal model and synthesis. For each test case $(N,m)$, synthesize the length-$N$ complex exponential\n$$\nx[n] = \\exp\\left(j\\left(2\\pi \\frac{m+0.3}{N} n + \\phi\\right)\\right), \\quad n=0,1,\\ldots,N-1,\n$$\nwith fixed phase $\\phi = \\pi/7$ (radians) and unit amplitude. Here $j$ denotes the imaginary unit.\n\n2. Spectral estimation with and without zero-padding. Compute the following:\n- An $N$-point DFT of $x[n]$ using a Fast Fourier Transform (FFT) algorithm, and determine the index $\\hat{k}$ of the maximum magnitude bin. Using only the magnitudes of the three bins at indices $\\hat{k}-1$, $\\hat{k}$, and $\\hat{k}+1$ (with circular wrap-around modulo $N$), fit a quadratic to estimate a sub-bin offset $\\delta \\in [-0.5,0.5]$ of the true maximum relative to $\\hat{k}$. The resulting interpolated peak location in $N$-bin units is $\\hat{\\kappa}_N = \\hat{k} + \\delta$. Report $\\hat{\\kappa}_N$ modulo $N$ so that $\\hat{\\kappa}_N \\in [0,N)$.\n- A $2N$-point DFT of the same $x[n]$ by zero-padding $x[n]$ with $N$ trailing zeros to length $2N$, again determining the index $\\hat{k}_{2N}$ of the maximum magnitude bin and computing a quadratic sub-bin offset $\\delta_{2N}$ using the three neighboring magnitudes at indices $\\hat{k}_{2N}-1$, $\\hat{k}_{2N}$, and $\\hat{k}_{2N}+1$ (with circular wrap-around modulo $2N$). Convert the resulting interpolated peak location to the original $N$-bin units: $\\hat{\\kappa}_{2N} = \\left(\\hat{k}_{2N} + \\delta_{2N}\\right)/2$, and report $\\hat{\\kappa}_{2N}$ modulo $N$ so that $\\hat{\\kappa}_{2N} \\in [0,N)$.\n\n3. Error quantification. For each method, compute the absolute error in $N$-bin units relative to the known true bin location $k_{\\text{true}} = m+0.3$:\n$$\ne_N = \\left|\\hat{\\kappa}_N - (m+0.3)\\right|, \\quad e_{2N} = \\left|\\hat{\\kappa}_{2N} - (m+0.3)\\right|.\n$$\n\n4. Numerical and algorithmic bases. You must:\n- Use the Discrete Fourier Transform (DFT) and a Fast Fourier Transform (FFT) algorithm to compute it.\n- Implement the quadratic peak interpolation by fitting a parabola to three points around the discrete maximum in the magnitude spectrum. Do not use any external peak-fitting utilities.\n\n5. Test suite. Use the following five test cases to exercise different regimes:\n- Case $1$: $N=64$, $m=10$ (general case).\n- Case $2$: $N=64$, $m=0$ (near direct current).\n- Case $3$: $N=64$, $m=31$ (near Nyquist for even $N$).\n- Case $4$: $N=257$, $m=100$ (non-power-of-two, large $N$).\n- Case $5$: $N=15$, $m=7$ (small odd $N$).\n\n6. Output specification. For each test case, your program must return a list of four floats:\n$$\n\\left[\\hat{\\kappa}_N, \\hat{\\kappa}_{2N}, e_N, e_{2N}\\right],\n$$\nrounded to $10^{-6}$ in $N$-bin units. Aggregate the five per-case lists into a single list in the same order as above. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example\n$$\n\\left[\\left[\\cdot,\\cdot,\\cdot,\\cdot\\right],\\left[\\cdot,\\cdot,\\cdot,\\cdot\\right],\\left[\\cdot,\\cdot,\\cdot,\\cdot\\right],\\left[\\cdot,\\cdot,\\cdot,\\cdot\\right],\\left[\\cdot,\\cdot,\\cdot,\\cdot\\right]\\right].\n$$\n\nNotes:\n- There are no physical units involved in this problem; report all values in $N$-bin units.\n- Angles are in radians.\n- Ensure numerical robustness at spectral boundaries by using circular wrap-around indexing when accessing neighboring bins.\n- Do not provide or rely on any closed-form estimator of the sinusoidal frequency; you must employ the DFT samples and a quadratic fit to three magnitude points as described.", "solution": "The problem requires an analysis of spectral peak estimation accuracy for a complex sinusoid using the Discrete Fourier Transform (DFT). We compare the performance of a standard $N$-point DFT with a $2N$-point DFT obtained by zero-padding the signal. The core of the estimation is a quadratic interpolation of the DFT magnitude spectrum around its peak.\n\nThe process for each test case $(N, m)$ is as follows:\n\n1.  **Signal Synthesis**: First, we construct the discrete-time complex sinusoidal signal $x[n]$ of length $N$. The signal is defined by the equation:\n    $$\n    x[n] = \\exp\\left(j\\left(2\\pi \\frac{k_{\\text{true}}}{N} n + \\phi\\right)\\right), \\quad n=0,1,\\ldots,N-1\n    $$\n    where $j$ is the imaginary unit, the phase is $\\phi = \\pi/7$, and the true normalized frequency is $k_{\\text{true}} = m+0.3$ bins. The time index vector is $n = [0, 1, \\ldots, N-1]$.\n\n2.  **$N$-Point DFT Analysis**:\n    -   We compute the $N$-point DFT of $x[n]$, denoted as $X[k]$, using a Fast Fourier Transform (FFT) algorithm.\n    -   We find the index $\\hat{k}$ corresponding to the maximum magnitude of the DFT spectrum: $\\hat{k} = \\arg\\max_k |X[k]|$.\n    -   To refine this estimate, we perform quadratic interpolation. This involves fitting a parabola to three points from the magnitude spectrum: $(\\hat{k}-1, |X[\\hat{k}-1]|)$, $(\\hat{k}, |X[\\hat{k}]|)$, and $(\\hat{k}+1, |X[\\hat{k}+1]|)$. The indices are handled with circular wrap-around, i.e., index $i$ is taken as $i \\pmod N$.\n    -   Let the three magnitude values be $y_{-1} = |X[(\\hat{k}-1) \\pmod N]|$, $y_0 = |X[\\hat{k}]|$, and $y_{1} = |X[(\\hat{k}+1) \\pmod N]|$. We find the vertex of the parabola passing through points $(-1, y_{-1})$, $(0, y_0)$, and $(1, y_{1})$. The horizontal coordinate of the vertex gives the sub-bin offset $\\delta$. The formula for $\\delta$ is:\n    $$\n    \\delta = \\frac{y_{-1} - y_{1}}{2(y_{-1} - 2y_0 + y_{1})}\n    $$\n    This offset $\\delta$ should be in the range $[-0.5, 0.5]$ since $\\hat{k}$ is the bin with maximum magnitude.\n    -   The interpolated peak location in $N$-bin units is $\\hat{\\kappa}_N = \\hat{k} + \\delta$. We apply a modulo $N$ operation as a safeguard to ensure the result is in $[0, N)$: $\\hat{\\kappa}_N = (\\hat{k} + \\delta) \\pmod N$.\n\n3.  **$2N$-Point DFT Analysis (with Zero-Padding)**:\n    -   The principle of zero-padding is that it provides a denser sampling of the signal's underlying Discrete-Time Fourier Transform (DTFT) without altering its shape. We create a new signal $x_{\\text{pad}}[n]$ of length $2N$ by appending $N$ zeros to the original signal $x[n]$.\n    -   We compute the $2N$-point DFT of $x_{\\text{pad}}[n]$, denoted $X_{2N}[k]$, using an FFT.\n    -   Similar to the $N$-point case, we find the peak magnitude bin index $\\hat{k}_{2N} = \\arg\\max_k |X_{2N}[k]|$.\n    -   We apply the same quadratic interpolation formula using the magnitudes at indices $(\\hat{k}_{2N}-1) \\pmod{2N}$, $\\hat{k}_{2N}$, and $(\\hat{k}_{2N}+1) \\pmod{2N}$ to find a sub-bin offset $\\delta_{2N}$.\n    -   The interpolated peak location in $2N$-bin units is $\\hat{k}_{2N} + \\delta_{2N}$. To compare this with the $N$-point estimate and the true frequency, we must convert it back to the original $N$-bin unit system by dividing by $2$:\n    $$\n    \\hat{\\kappa}_{2N} = \\frac{\\hat{k}_{2N} + \\delta_{2N}}{2}\n    $$\n    Again, we ensure the result is in $[0, N)$ by applying a modulo $N$ operation.\n\n4.  **Error Quantification**:\n    -   For both estimation methods, we compute the absolute error with respect to the known true frequency $k_{\\text{true}} = m+0.3$.\n    -   The errors are given by:\n    $$\n    e_N = |\\hat{\\kappa}_N - k_{\\text{true}}|\n    $$\n    $$\n    e_{2N} = |\\hat{\\kappa}_{2N} - k_{\\text{true}}|\n    $$\n    The results from these calculations will demonstrate that zero-padding (i.e., denser sampling of the DTFT) generally improves the accuracy of the quadratic interpolation frequency estimator.\n\n5.  **Implementation for Test Cases**: This entire procedure is applied to each of the five $(N, m)$ test cases. The final results, $[\\hat{\\kappa}_N, \\hat{\\kappa}_{2N}, e_N, e_{2N}]$, are collected for each case, rounded to $10^{-6}$, and formatted into a single list of lists as specified.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of estimating a sinusoid's frequency using DFT\n    with and without zero-padding, and quantifies the estimation error.\n    \"\"\"\n    \n    # Test cases as specified in the problem statement: (N, m)\n    test_cases = [\n        (64, 10),\n        (64, 0),\n        (64, 31),\n        (257, 100),\n        (15, 7),\n    ]\n\n    results = []\n\n    # Fixed phase for the sinusoid\n    phi = np.pi / 7.0\n\n    for N, m in test_cases:\n        # 1. Signal model and synthesis\n        k_true = m + 0.3\n        n = np.arange(N)\n        # Angular frequency in radians per sample\n        omega = 2.0 * np.pi * k_true / N\n        # Synthesize complex exponential signal\n        x_n = np.exp(1j * (omega * n + phi))\n\n        # 2. Spectral estimation without zero-padding (N-point DFT)\n        X_N = np.fft.fft(x_n)\n        X_N_mag = np.abs(X_N)\n        k_hat = int(np.argmax(X_N_mag))\n\n        # Quadratic interpolation for N-point DFT\n        # Get magnitudes of the peak and its immediate neighbors\n        y_m1 = X_N_mag[(k_hat - 1) % N]\n        y_0 = X_N_mag[k_hat]\n        y_p1 = X_N_mag[(k_hat + 1) % N]\n\n        # Parabola vertex formula for sub-bin offset delta\n        denominator_N = 2.0 * (y_m1 - 2.0 * y_0 + y_p1)\n        if np.isclose(denominator_N, 0):\n            delta_N = 0.0\n        else:\n            delta_N = (y_m1 - y_p1) / denominator_N\n        \n        # Interpolated peak location in N-bin units\n        kappa_hat_N = (k_hat + delta_N) % N\n\n        # 3. Spectral estimation with zero-padding (2N-point DFT)\n        # Pad the signal with N zeros to get a length 2N signal\n        x_padded = np.pad(x_n, (0, N), 'constant')\n        \n        X_2N = np.fft.fft(x_padded)\n        X_2N_mag = np.abs(X_2N)\n        k_hat_2N = int(np.argmax(X_2N_mag))\n        \n        # Quadratic interpolation for 2N-point DFT\n        y_m1_2N = X_2N_mag[(k_hat_2N - 1) % (2 * N)]\n        y_0_2N = X_2N_mag[k_hat_2N]\n        y_p1_2N = X_2N_mag[(k_hat_2N + 1) % (2 * N)]\n\n        denominator_2N = 2.0 * (y_m1_2N - 2.0 * y_0_2N + y_p1_2N)\n        if np.isclose(denominator_2N, 0):\n            delta_2N = 0.0\n        else:\n            delta_2N = (y_m1_2N - y_p1_2N) / denominator_2N\n        \n        # Interpolated peak location, converted back to N-bin units\n        kappa_hat_2N = ((k_hat_2N + delta_2N) / 2.0) % N\n\n        # 4. Error quantification\n        e_N = np.abs(kappa_hat_N - k_true)\n        e_2N = np.abs(kappa_hat_2N - k_true)\n\n        # 6. Output specification: round and collect results\n        case_result = [\n            round(kappa_hat_N, 6),\n            round(kappa_hat_2N, 6),\n            round(e_N, 6),\n            round(e_2N, 6)\n        ]\n        results.append(case_result)\n\n    # Format the final output string exactly as required\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3616424"}, {"introduction": "While standard Fast Fourier Transform (FFT) libraries are highly optimized, they typically favor data lengths that are powers of two, a condition rarely met by real-world data segments. This advanced practice delves into Bluestein's algorithm, an elegant method that computes an exact Discrete Fourier Transform (DFT) for any length by reformulating the problem as a circular convolution [@problem_id:3616423]. Implementing this algorithm from scratch will deepen your understanding of the \"fast algorithms\" themselves and allow you to quantitatively compare its accuracy and computational cost against a common but approximate workaround.", "problem": "You are to implement, from first principles, a program that computes the discrete Fourier transform (DFT) of arbitrary-length discrete windows using Bluestein’s method (also called the chirp-$z$ transform formulation for DFT), and compares its numerical error and a proxy for speed against a zero-padded radix-$2$ fast Fourier transform (FFT) approximation. The context is short microseismic windows, but the task is purely mathematical and algorithmic. All angles must be treated in radians.\n\nFundamental base and definitions to be used:\n- The discrete Fourier transform of length $N$ is defined by $X_{k} = \\sum_{n=0}^{N-1} x_{n}\\,\\exp\\!\\left(-\\mathrm{i}\\,2\\pi\\,\\frac{k n}{N}\\right)$ for $k \\in \\{0,1,\\dots,N-1\\}$, where $\\mathrm{i}$ is the imaginary unit.\n- A radix-$2$ FFT computes the DFT in $\\mathcal{O}(L \\log_{2} L)$ operations when $L$ is a power of two.\n- Bluestein’s method reduces the length-$N$ DFT to a linear convolution that is computable via FFTs of length $M \\ge 2N-1$.\n\nSignal model for the microseismic window:\n- For a given integer window length $N \\ge 1$ and sampling frequency $f_{s}$ in hertz, define $t_{n} = n/f_{s}$ for $n=0,1,\\dots,N-1$.\n- Construct the discrete-time signal $x_{n}$ as the superposition of a damped sinusoid and a Ricker wavelet centered in the window:\n  1. Damped sinusoid: $x_{n}^{(1)} = A_{1}\\,\\exp(-\\beta\\,t_{n})\\,\\sin(2\\pi f_{0}\\,t_{n} + \\varphi)$.\n  2. Ricker wavelet: $x_{n}^{(2)} = A_{2}\\,\\left(1 - 2(\\pi f_{c}\\,(t_{n}-t_{0}))^{2}\\right)\\exp\\!\\left(-(\\pi f_{c}\\,(t_{n}-t_{0}))^{2}\\right)$ with $t_{0} = \\frac{N-1}{2 f_{s}}$.\n  3. Total: $x_{n} = x_{n}^{(1)} + x_{n}^{(2)}$.\n- Use the following fixed parameters and units: $f_{s} = 2000\\,\\mathrm{Hz}$, $A_{1} = 0.7$ (dimensionless), $\\beta = 30.0\\,\\mathrm{s}^{-1}$, $f_{0} = 120.0\\,\\mathrm{Hz}$, $\\varphi = 0.3\\,\\mathrm{rad}$, $A_{2} = 1.0$ (dimensionless), $f_{c} = 50.0\\,\\mathrm{Hz}$. Angles are in radians and time in seconds.\n\nAlgorithmic requirements:\n1. Implement a direct DFT evaluator from its definition as a baseline reference for validation. This is the $\\mathcal{O}(N^{2})$ method that applies the definition of the DFT.\n2. Implement Bluestein’s method for the exact length-$N$ DFT. You must base your derivation on the DFT definition and elementary algebraic identities without assuming any specialized formula. The algorithm must reduce the DFT to a linear convolution and then compute that convolution using FFTs of a power-of-two length $M \\ge 2N-1$.\n3. Implement a zero-padded radix-$2$ FFT approximation procedure for comparison: zero-pad the length-$N$ input to length $P$, where $P$ is the smallest power-of-two such that $P \\ge N$. Compute the length-$P$ DFT via a radix-$2$ FFT and create an approximate length-$N$ spectrum by sampling the $P$-length spectrum at indices $j_{k} = \\left\\lfloor \\operatorname{round}\\!\\left(\\frac{k P}{N}\\right) \\right\\rfloor \\bmod P$ for $k = 0,1,\\dots,N-1$.\n4. For each test case, compute the following:\n   - The reference spectrum $X^{\\mathrm{ref}}$ using the direct DFT.\n   - The Bluestein spectrum $X^{\\mathrm{B}}$ using Bluestein’s method.\n   - The zero-padded approximation $X^{\\mathrm{ZP}}$ using the procedure above.\n   - The relative $\\ell_2$ errors\n     $$E_{\\mathrm{B}} = \\frac{\\lVert X^{\\mathrm{B}} - X^{\\mathrm{ref}} \\rVert_{2}}{\\lVert X^{\\mathrm{ref}} \\rVert_{2}}, \\quad E_{\\mathrm{ZP}} = \\frac{\\lVert X^{\\mathrm{ZP}} - X^{\\mathrm{ref}} \\rVert_{2}}{\\lVert X^{\\mathrm{ref}} \\rVert_{2}}.$$\n   - A proxy for speed based on operation counts. Let the FFT operation count model be $C_{\\mathrm{FFT}}(L) = L \\log_{2} L$ for $L \\ge 2$ and $C_{\\mathrm{FFT}}(1) = 1$. Define $M$ as the smallest power of two with $M \\ge 2N-1$, and $P$ as the smallest power of two with $P \\ge N$. Use the Bluestein proxy count $C_{\\mathrm{B}} = 3\\,C_{\\mathrm{FFT}}(M)$ and the zero-padded proxy count $C_{\\mathrm{ZP}} = C_{\\mathrm{FFT}}(P)$. Report the ratio\n     $$S_{\\mathrm{proxy}} = \\frac{C_{\\mathrm{ZP}}}{C_{\\mathrm{B}}}.$$\n\nTest suite:\n- Use the following five window lengths $N$: $N \\in \\{997, 1024, 1500, 1, 2\\}$.\n- For each $N$ in the set above, construct $x_{n}$ using the fixed parameters provided and compute $E_{\\mathrm{B}}$, $E_{\\mathrm{ZP}}$, and $S_{\\mathrm{proxy}}$ as specified.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where the $i$-th entry is itself a list of three floats $[E_{\\mathrm{B}}, E_{\\mathrm{ZP}}, S_{\\mathrm{proxy}}]$ for the $i$-th test case in the order of the specified $N$ values. For example, the output format must be of the form\n  $$\\big[\\,[\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot]\\,\\big]$$\nwith no additional text. The entries are dimensionless. The program must not read any input.", "solution": "The problem requires the implementation and comparative analysis of three methods for computing the Discrete Fourier Transform (DFT) of a discrete-time signal. The methods are the direct summation based on the DFT definition, Bluestein's algorithm (a chirp-$z$ transform formulation), and a zero-padded Fast Fourier Transform (FFT) approximation. The comparison will be based on numerical accuracy against the direct method and a proxy for computational complexity.\n\nThe one-dimensional DFT of a sequence $x_n$ of length $N$ is defined as:\n$$X_{k} = \\sum_{n=0}^{N-1} x_{n}\\,\\exp\\!\\left(-\\mathrm{i}\\,2\\pi\\,\\frac{k n}{N}\\right), \\quad \\text{for } k \\in \\{0,1,\\dots,N-1\\}$$\nwhere $\\mathrm{i}$ is the imaginary unit.\n\nThe input signal $x_{n}$ for a given window length $N$ is constructed based on a model of a microseismic window. The signal is sampled at a frequency $f_{s} = 2000\\,\\mathrm{Hz}$, with time points $t_{n} = n/f_{s}$ for $n \\in \\{0, 1, \\dots, N-1\\}$. The signal is a superposition of two components, $x_n = x_{n}^{(1)} + x_{n}^{(2)}$:\n1.  A damped sinusoid: $x_{n}^{(1)} = A_{1}\\,\\exp(-\\beta\\,t_{n})\\,\\sin(2\\pi f_{0}\\,t_{n} + \\varphi)$.\n2.  A Ricker wavelet centered at $t_{0} = \\frac{N-1}{2 f_{s}}$: $x_{n}^{(2)} = A_{2}\\,\\left(1 - 2(\\pi f_{c}\\,(t_{n}-t_{0}))^{2}\\right)\\exp\\!\\left(-(\\pi f_{c}\\,(t_{n}-t_{0}))^{2}\\right)$.\n\nThe fixed physical parameters are: $A_{1} = 0.7$, $\\beta = 30.0\\,\\mathrm{s}^{-1}$, $f_{0} = 120.0\\,\\mathrm{Hz}$, $\\varphi = 0.3\\,\\mathrm{rad}$, $A_{2} = 1.0$, and $f_{c} = 50.0\\,\\mathrm{Hz}$.\n\nWe will now detail the three algorithmic approaches for computing the DFT.\n\n**1. Direct DFT (Reference Method)**\nThis method implements the definition of the DFT directly. For each frequency component $X_k$, it calculates the sum over all $N$ samples. This involves a matrix-vector multiplication where the matrix elements are $W_{kn} = \\exp(-\\mathrm{i}\\,2\\pi kn/N)$. The computational complexity is $\\mathcal{O}(N^2)$. This method, while slow for large $N$, is arithmetically straightforward and serves as the reference $X^{\\mathrm{ref}}$ for measuring the numerical error of the other algorithms.\n\n**2. Bluestein's Algorithm**\nBluestein’s algorithm computes the DFT of an arbitrary length $N$ by reformulating it as a linear convolution, which can then be computed efficiently using FFTs. The derivation is based on the identity $2kn = k^2 + n^2 - (k-n)^2$. Substituting this into the DFT exponent gives:\n$$X_{k} = \\sum_{n=0}^{N-1} x_{n}\\,\\exp\\!\\left(-\\mathrm{i}\\,\\frac{\\pi}{N}\\,(k^2 + n^2 - (k-n)^2)\\right)$$\n$$X_{k} = \\exp\\!\\left(-\\mathrm{i}\\,\\frac{\\pi k^2}{N}\\right) \\sum_{n=0}^{N-1} \\left(x_{n}\\,\\exp\\!\\left(-\\mathrm{i}\\,\\frac{\\pi n^2}{N}\\right)\\right) \\exp\\!\\left(\\mathrm{i}\\,\\frac{\\pi (k-n)^2}{N}\\right)$$\nThis expression has the form of a convolution. Let us define two sequences:\n- A modified input sequence: $a_n = x_n \\exp(-\\mathrm{i}\\,\\pi n^2/N)$ for $n \\in \\{0, \\dots, N-1\\}$.\n- A \"chirp\" filter sequence: $h_j = \\exp(\\mathrm{i}\\,\\pi j^2/N)$.\n\nThe summation becomes a linear convolution of $a_n$ and $h_n$:\n$$y_k = (a * h)_k = \\sum_{n=0}^{N-1} a_n h_{k-n}$$\nThe DFT is then obtained by a final multiplication:\n$$X_k = \\exp\\!\\left(-\\mathrm{i}\\,\\frac{\\pi k^2}{N}\\right) y_k$$\nThe linear convolution $(a * h)_k$ can be computed efficiently using the convolution theorem. This requires zero-padding both sequences to a length $M$ such that $M \\ge N + N - 1 = 2N - 1$. For optimal FFT performance, $M$ is chosen as the smallest power of two satisfying this condition. The procedure is as follows:\n1.  Choose $M$ as the smallest power of two such that $M \\ge 2N-1$.\n2.  Construct the length-$M$ filter $H = \\text{FFT}(h')$, where $h'_j = \\exp(\\mathrm{i}\\,\\pi j^2/N)$ for $j \\in \\{0, \\dots, N-1\\}$, $h'_j = \\exp(\\mathrm{i}\\,\\pi (j-M)^2/N)$ for $j \\in \\{M-N+1, \\dots, M-1\\}$, and $h'_j = 0$ otherwise. This construction correctly implements the acyclic convolution using a cyclic one.\n3.  Construct the length-$M$ modified input $A = \\text{FFT}(a')$, where $a'_n = x_n \\exp(-\\mathrm{i}\\,\\pi n^2/N)$ for $n \\in \\{0, \\dots, N-1\\}$ and $a'_n = 0$ for $n \\ge N$.\n4.  Compute the inverse FFT of the element-wise product: $y = \\text{IFFT}(A \\cdot H)$.\n5.  Extract the first $N$ elements of $y$.\n6.  Calculate the final DFT spectrum $X^{\\mathrm{B}}$ by multiplying with the post-chirp: $X^{\\mathrm{B}}_k = y_k \\exp(-\\mathrm{i}\\,\\pi k^2/N)$ for $k \\in \\{0, \\dots, N-1\\}$.\nSince this algorithm is mathematically equivalent to the DFT definition, its numerical error arises only from floating-point inaccuracies.\n\n**3. Zero-Padded FFT Approximation**\nThis method provides an approximate DFT for a length-$N$ signal by using a standard radix-$2$ FFT.\n1.  Zero-pad the input signal $x_n$ to the smallest power-of-two length $P$ such that $P \\ge N$.\n2.  Compute the $P$-point DFT, $Y = \\text{FFT}(x_{\\text{padded}})$. This spectrum $Y$ has frequency bins at intervals of $f_s/P$.\n3.  The desired $N$-point DFT, $X^{\\mathrm{ZP}}$, has frequency bins at intervals of $f_s/N$. To approximate this, the spectrum $Y$ is sampled at the indices closest to the target frequencies. For each desired frequency index $k \\in \\{0, \\dots, N-1\\}$, the corresponding index $j_k$ in the $P$-point spectrum is found using the provided formula:\n    $$j_{k} = \\left\\lfloor \\operatorname{round}\\!\\left(\\frac{k P}{N}\\right) \\right\\rfloor \\bmod P$$\n4.  The approximate spectrum is constructed as $X^{\\mathrm{ZP}}_k = Y_{j_k}$.\nThis method is an approximation because the frequency bins of the $P$-point DFT generally do not align with those of the desired $N$-point DFT, and the nearest-neighbor sampling introduces errors.\n\n**Comparison Metrics**\nThe performance of the algorithms is quantified by two error metrics and a speed proxy ratio.\n- The reference spectrum is $X^{\\mathrm{ref}}$, computed via the direct method.\n- The relative $\\ell_2$-norm errors for Bluestein's method ($E_{\\mathrm{B}}$) and the zero-padded approximation ($E_{\\mathrm{ZP}}$) are:\n  $$E_{\\mathrm{B}} = \\frac{\\lVert X^{\\mathrm{B}} - X^{\\mathrm{ref}} \\rVert_{2}}{\\lVert X^{\\mathrm{ref}} \\rVert_{2}}, \\quad E_{\\mathrm{ZP}} = \\frac{\\lVert X^{\\mathrm{ZP}} - X^{\\mathrm{ref}} \\rVert_{2}}{\\lVert X^{\\mathrm{ref}} \\rVert_{2}}$$\n- A proxy for the computational cost is defined based on the number of operations for an FFT of length $L$, $C_{\\mathrm{FFT}}(L)$, where $C_{\\mathrm{FFT}}(1) = 1$ and $C_{\\mathrm{FFT}}(L) = L \\log_{2} L$ for $L \\ge 2$.\n- The cost for Bluestein's algorithm, involving three FFTs of length $M$, is $C_{\\mathrm{B}} = 3\\,C_{\\mathrm{FFT}}(M)$.\n- The cost for the zero-padded method, involving a single FFT of length $P$, is $C_{\\mathrm{ZP}} = C_{\\mathrm{FFT}}(P)$.\n- The speed proxy ratio to be reported is $S_{\\mathrm{proxy}} = C_{\\mathrm{ZP}} / C_{\\mathrm{B}}$.\n\nThe analysis will be performed for the test suite of window lengths $N \\in \\{997, 1024, 1500, 1, 2\\}$, and the three metrics ($E_{\\mathrm{B}}$, $E_{\\mathrm{ZP}}$, $S_{\\mathrm{proxy}}$) will be computed for each case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.fft import fft, ifft\n\ndef solve():\n    \"\"\"\n    Main function to run the DFT comparison for specified test cases.\n    \"\"\"\n\n    # --- Signal Generation ---\n    def generate_signal(N):\n        \"\"\"Constructs the discrete-time signal for a given window length N.\"\"\"\n        if N == 0:\n            return np.array([], dtype=float)\n        \n        # Fixed parameters\n        fs = 2000.0  # Hz\n        A1 = 0.7\n        beta = 30.0  # s^-1\n        f0 = 120.0  # Hz\n        phi = 0.3  # rad\n        A2 = 1.0\n        fc = 50.0  # Hz\n\n        t = np.arange(N) / fs\n        \n        # Damped sinusoid\n        x1 = A1 * np.exp(-beta * t) * np.sin(2 * np.pi * f0 * t + phi)\n\n        # Ricker wavelet\n        t0 = (N - 1) / (2 * fs)\n        rick_arg = np.pi * fc * (t - t0)\n        rick_arg_sq = rick_arg**2\n        x2 = A2 * (1 - 2 * rick_arg_sq) * np.exp(-rick_arg_sq)\n        \n        return x1 + x2\n\n    # --- DFT Algorithms ---\n    def direct_dft(x):\n        \"\"\"Computes DFT using the direct O(N^2) definition.\"\"\"\n        N = len(x)\n        if N == 0:\n            return np.array([], dtype=complex)\n        k = np.arange(N)\n        n = k.reshape((N, 1))\n        W = np.exp(-2j * np.pi * k * n / N)\n        return np.dot(W, x)\n\n    def bluestein_dft(x):\n        \"\"\"Computes DFT using Bluestein's algorithm for arbitrary N.\"\"\"\n        N = len(x)\n        if N == 0:\n            return np.array([], dtype=complex)\n\n        # Find smallest power of two M >= 2N - 1\n        if N == 1:\n            M = 1\n        else:\n            M = 1 << (2 * N - 2).bit_length()\n\n        # Step 1: Chirp multiplication\n        n = np.arange(N)\n        chirp_exp = (n**2) / (2 * N)\n        a = x * np.exp(-1j * 2 * np.pi * chirp_exp)\n\n        # Step 2: Convolution via FFT\n        # Define the chirp filter for convolution\n        k_h = np.arange(M)\n        h_exp = np.zeros(M)\n        \n        # Positive frequencies\n        if N > 0:\n            pos_indices = np.arange(N)\n            h_exp[pos_indices] = (pos_indices**2) / (2 * N)\n        # Negative frequencies (wrapped around)\n        if N > 1:\n            neg_indices = np.arange(M - N + 1, M)\n            h_exp[neg_indices] = ((neg_indices - M)**2) / (2 * N)\n            \n        h = np.exp(1j * 2 * np.pi * h_exp)\n\n        # Pad 'a' and convolve\n        a_padded = np.zeros(M, dtype=complex)\n        a_padded[:N] = a\n        \n        y = ifft(fft(a_padded) * fft(h))\n\n        # Step 3: Final chirp multiplication\n        k = np.arange(N)\n        final_chirp_exp = (k**2) / (2 * N)\n        X_B = y[:N] * np.exp(-1j * 2 * np.pi * final_chirp_exp)\n        \n        return X_B\n\n    def zeropad_dft_approx(x):\n        \"\"\"Computes approximate DFT via zero-padding and FFT resampling.\"\"\"\n        N = len(x)\n        if N == 0:\n            return np.array([], dtype=complex)\n        \n        # Find smallest power of two P >= N\n        if N == 1:\n            P = 1\n        else:\n             P = 1 << (N - 1).bit_length()\n\n        # Zero-pad and compute P-point FFT\n        x_padded = np.zeros(P, dtype=complex)\n        x_padded[:N] = x\n        Y = fft(x_padded)\n        \n        # Resample Y to get approximate N-point DFT\n        X_ZP = np.zeros(N, dtype=complex)\n        k = np.arange(N)\n        \n        # The problem states round() and floor(), though np.round provides half-to-even\n        # For compatibility we use a custom round to match the problem's implicit round-half-up\n        jk_float = k * P / N\n        jk = np.floor(jk_float + 0.5).astype(int) % P\n        \n        X_ZP = Y[jk]\n        \n        return X_ZP\n\n    # --- Metrics Calculation ---\n    def get_metrics(N, x_ref, x_b, x_zp):\n        \"\"\"Calculates error and speed proxy metrics.\"\"\"\n        # Errors\n        norm_ref = np.linalg.norm(x_ref)\n        if norm_ref == 0:\n             # Handle case where signal is all zero e.g. N=0\n             e_b = 0.0 if np.linalg.norm(x_b - x_ref) == 0 else np.inf\n             e_zp = 0.0 if np.linalg.norm(x_zp - x_ref) == 0 else np.inf\n        else:\n             e_b = np.linalg.norm(x_b - x_ref) / norm_ref\n             e_zp = np.linalg.norm(x_zp - x_ref) / norm_ref\n\n        # Speed Proxy\n        if N > 0:\n            if N == 1:\n                 M, P = 1, 1\n            else:\n                 M = 1 << (2 * N - 2).bit_length()\n                 P = 1 << (N - 1).bit_length()\n        else: # N=0 case\n            M, P = 0, 0\n\n        def c_fft(L):\n            if L <= 1:\n                return 1\n            return L * np.log2(L)\n\n        c_b = 3 * c_fft(M)\n        c_zp = c_fft(P)\n\n        if c_b == 0: # Avoid division by zero if N=0\n           s_proxy = float('nan') if c_zp !=0 else 1.0\n        else:\n           s_proxy = c_zp / c_b\n           \n        return [e_b, e_zp, s_proxy]\n\n    # --- Main Loop ---\n    test_cases = [997, 1024, 1500, 1, 2]\n    results = []\n    \n    for N in test_cases:\n        x = generate_signal(N)\n        \n        # Compute DFTs\n        X_ref = direct_dft(x)\n        X_B = bluestein_dft(x)\n        X_ZP = zeropad_dft_approx(x)\n        \n        # Calculate metrics\n        metrics = get_metrics(N, X_ref, X_B, X_ZP)\n        results.append(metrics)\n\n    # Format and print the final output\n    output_str = \"[\" + \",\".join([f\"[{e_b:.15e},{e_zp:.15e},{s_proxy:.15e}]\" for e_b, e_zp, s_proxy in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "3616423"}]}