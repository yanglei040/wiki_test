{"hands_on_practices": [{"introduction": "The power of standardized numerical quadrature rules, such as Gauss-Legendre, lies in their definition on a canonical interval like $[-1, 1]$. To apply these rules to a real-world integral over an arbitrary interval $[\\alpha, \\beta]$, a transformation is required. This foundational exercise guides you through deriving the necessary affine mapping and understanding the role of the Jacobian, a critical first step in making theoretical quadrature rules practically useful in any computational context.[@problem_id:3612140]", "problem": "In computational geophysics, frequency- and wavenumber-domain formulations of the acoustic and elastic wave equations often lead to integrals of smooth kernels over finite bands, for example an integral of the form $\\int_{\\alpha}^{\\beta} f(x) \\, dx$ representing a band-limited spectral energy or a slowness-weighted Green’s function contribution. Suppose a quadrature rule (either a closed Newton–Cotes rule or a Gaussian rule such as Gauss–Legendre) has already been constructed on a reference interval $[a,b]$ with nodes $\\{t_i\\}_{i=1}^{n} \\subset [a,b]$ and weights $\\{w_i\\}_{i=1}^{n}$, understood to approximate $\\int_{a}^{b} g(t) \\, dt$ by $\\sum_{i=1}^{n} w_i \\, g(t_i)$ for sufficiently smooth $g$.\n\nStarting from the change-of-variables theorem for one-dimensional integrals and the requirement that the mapping between intervals be affine, derive the unique affine transformation $x=\\varphi(t)$ that maps $[a,b]$ onto $[\\alpha,\\beta]$, and write the transformed integral $\\int_{\\alpha}^{\\beta} f(x) \\, dx$ as an integral over $[a,b]$ with the Jacobian factor made explicit. Then express how the given quadrature rule on $[a,b]$ induces an approximation to $\\int_{\\alpha}^{\\beta} f(x) \\, dx$ that uses the same nodes $\\{t_i\\}$ and weights $\\{w_i\\}$, making the Jacobian factor explicit in the sum.\n\nYour final answer should be the ordered pair consisting of the affine mapping $\\varphi(t)$ and its Jacobian $\\frac{d\\varphi}{dt}$, written as a single row matrix. No numerical evaluation is required.", "solution": "The problem requires the derivation of an affine transformation to map a reference interval for numerical quadrature to a target interval, and the subsequent transformation of the integral and its quadrature approximation.\n\nFirst, we must find the unique affine transformation $x = \\varphi(t)$ that maps the reference interval $[a,b]$ onto the target interval $[\\alpha,\\beta]$. An affine transformation in one dimension is a linear function of the form:\n$$\n\\varphi(t) = mt + c\n$$\nwhere $m$ and $c$ are constants. The condition that this transformation maps $[a,b]$ to $[\\alpha,\\beta]$ implies a mapping of the endpoints. We assume an orientation-preserving mapping, such that $\\varphi(a)=\\alpha$ and $\\varphi(b)=\\beta$. This provides a system of two linear equations for the two unknowns $m$ and $c$:\n$$\n\\begin{cases}\nma + c = \\alpha \\\\\nmb + c = \\beta\n\\end{cases}\n$$\nTo solve for $m$, we subtract the first equation from the second:\n$$\nm(b - a) = \\beta - \\alpha\n$$\nAssuming $a \\neq b$, which is a necessary condition for a non-degenerate interval, we can solve for $m$:\n$$\nm = \\frac{\\beta - \\alpha}{b - a}\n$$\nThis constant $m$ is the slope of the affine map. To find the intercept $c$, we substitute the expression for $m$ back into the first equation:\n$$\nc = \\alpha - ma = \\alpha - \\left(\\frac{\\beta - \\alpha}{b - a}\\right) a\n$$\nBy placing the terms over a common denominator, we get:\n$$\nc = \\frac{\\alpha(b - a) - a(\\beta - \\alpha)}{b - a} = \\frac{\\alpha b - \\alpha a - a \\beta + a \\alpha}{b - a} = \\frac{\\alpha b - a \\beta}{b - a}\n$$\nTherefore, the unique affine transformation is:\n$$\nx = \\varphi(t) = \\left(\\frac{\\beta - \\alpha}{b - a}\\right) t + \\frac{\\alpha b - a \\beta}{b - a}\n$$\nThis transformation is unique because the system of linear equations for $m$ and $c$ has a unique solution when $b-a \\neq 0$.\n\nNext, we apply the change-of-variables theorem for one-dimensional integrals. The theorem states that if $x = \\varphi(t)$, then $dx = \\varphi'(t) \\, dt$. The integral of a function $f(x)$ over $[\\alpha,\\beta]$ can be transformed into an integral over $[a,b]$ as follows:\n$$\n\\int_{\\alpha}^{\\beta} f(x) \\, dx = \\int_{a}^{b} f(\\varphi(t)) \\varphi'(t) \\, dt\n$$\nThe term $\\varphi'(t)$ is the Jacobian of the transformation. For our affine map, the Jacobian is the derivative of $\\varphi(t)$ with respect to $t$:\n$$\n\\frac{d\\varphi}{dt} = \\frac{d}{dt} \\left( mt + c \\right) = m = \\frac{\\beta - \\alpha}{b - a}\n$$\nThe Jacobian is a constant, as expected for an affine map. Substituting this into the transformed integral expression, we make the Jacobian factor explicit:\n$$\n\\int_{\\alpha}^{\\beta} f(x) \\, dx = \\int_{a}^{b} f(\\varphi(t)) \\left(\\frac{\\beta - \\alpha}{b - a}\\right) \\, dt\n$$\nNow, we consider the quadrature rule provided for the reference interval $[a,b]$. The integral of a sufficiently smooth function $g(t)$ is approximated by a weighted sum:\n$$\n\\int_{a}^{b} g(t) \\, dt \\approx \\sum_{i=1}^{n} w_i \\, g(t_i)\n$$\nTo approximate the integral $\\int_{\\alpha}^{\\beta} f(x) \\, dx$, we apply this rule to its equivalent form on the interval $[a,b]$. The integrand function on the reference interval is $g(t) = f(\\varphi(t)) \\left(\\frac{\\beta - \\alpha}{b - a}\\right)$.\nApplying the quadrature rule to this $g(t)$ gives:\n$$\n\\int_{a}^{b} f(\\varphi(t)) \\left(\\frac{\\beta - \\alpha}{b - a}\\right) \\, dt \\approx \\sum_{i=1}^{n} w_i \\left[ f(\\varphi(t_i)) \\left(\\frac{\\beta - \\alpha}{b - a}\\right) \\right]\n$$\nSince the Jacobian factor $\\left(\\frac{\\beta - \\alpha}{b - a}\\right)$ is a constant, it can be factored out of the summation:\n$$\n\\int_{\\alpha}^{\\beta} f(x) \\, dx \\approx \\left(\\frac{\\beta - \\alpha}{b - a}\\right) \\sum_{i=1}^{n} w_i \\, f(\\varphi(t_i))\n$$\nThis expression shows how the given quadrature rule on $[a,b]$ induces an approximation for the integral on $[\\alpha,\\beta]$. The approximation uses the original nodes $\\{t_i\\}$ transformed by $\\varphi$ into the new domain, the original weights $\\{w_i\\}$, and a global scaling factor equal to the Jacobian of the transformation. Specifically, the function $f$ is evaluated at points $x_i = \\varphi(t_i)$ in the interval $[\\alpha, \\beta]$.\n\nThe final answer requires the ordered pair consisting of the affine mapping $\\varphi(t)$ and its Jacobian $\\frac{d\\varphi}{dt}$.\nThe mapping is $\\varphi(t) = \\left(\\frac{\\beta - \\alpha}{b - a}\\right) t + \\frac{\\alpha b - a \\beta}{b - a}$.\nThe Jacobian is $\\frac{d\\varphi}{dt} = \\frac{\\beta - \\alpha}{b - a}$.", "answer": "$$\n\\boxed{\\begin{pmatrix} \\left(\\frac{\\beta - \\alpha}{b - a}\\right) t + \\frac{\\alpha b - a \\beta}{b - a} & \\frac{\\beta - \\alpha}{b - a} \\end{pmatrix}}\n$$", "id": "3612140"}, {"introduction": "Gaussian quadrature achieves superior accuracy by tailoring its nodes and weights to a specific weight function, $w(x)$. This practice moves beyond using pre-calculated rules to understanding their construction from first principles, a crucial skill for tackling specialized integrals in geophysics. By deriving a Gauss-Hermite rule for a Gaussian weight function, you will see how the principles of moment matching and symmetry give rise to the optimal node placement and weights that grant these methods their high degree of polynomial exactness.[@problem_id:3612134]", "problem": "In modeling thermal attenuation of seismic waves in heterogeneous media, integrals of even-power polynomials against a Gaussian weight arise when computing cumulants of an assumed Gaussian distribution of microstructural property fluctuations. Consider the weighted integral with the Gaussian weight function, $$w(x)=\\exp(-x^{2}),$$ on the entire real line. Construct a Gaussian quadrature rule tailored to this weight (Gauss–Hermite quadrature) that is exact for all polynomials of degree up to and including degree $$5$$ in the factor $$f(x)$$ of the integrand $$w(x) f(x).$$ Do not use any pre-tabulated nodes or weights; derive the nodes and weights from first principles by invoking symmetry of $$w(x)$$ and exactness constraints based on the lowest even moments of the Gaussian measure. Then apply your constructed rule to approximate the integral $$\\int_{-\\infty}^{\\infty} \\exp(-x^{2})\\, x^{4}\\, dx$$ and report the resulting value as a single closed-form analytic expression. No rounding is required, and no physical units are involved in this computation.", "solution": "The user has submitted a problem for validation and solution.\n\n### Step 1: Extract Givens\n- **Weight Function**: $w(x)=\\exp(-x^{2})$\n- **Integration Domain**: The entire real line, $(-\\infty, \\infty)$\n- **Task 1**: Construct a Gaussian quadrature rule of the form $\\int_{-\\infty}^{\\infty} w(x) f(x) dx \\approx \\sum_{i=1}^{n} W_i f(x_i)$\n- **Condition**: The rule must be exact for all polynomials $f(x)$ of degree up to and including $5$.\n- **Methodology**: Derive the nodes $x_i$ and weights $W_i$ from first principles, using symmetry and exactness constraints (moments). Pre-tabulated values are forbidden.\n- **Task 2**: Apply the constructed rule to approximate the integral $\\int_{-\\infty}^{\\infty} \\exp(-x^{2})\\, x^{4}\\, dx$.\n- **Output Requirement**: A single closed-form analytic expression for the result.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is subjected to validation against the specified criteria.\n\n- **Scientific Grounding**: The problem is well-grounded in the established mathematical field of numerical analysis, specifically concerning numerical quadrature. Gauss-Hermite quadrature, which is the specific rule to be derived, is a standard and fundamental method. The connection to computational geophysics is a valid and common application context. The problem is scientifically sound.\n- **Well-Posedness**: The problem is well-posed. A Gaussian quadrature rule with $n$ nodes is exact for polynomials of degree up to $2n-1$. The requirement of exactness up to degree $5$ implies $2n-1 \\geq 5$, which gives $n \\geq 3$. The minimal number of nodes is $n=3$. The derivation of the $3$ nodes and $3$ weights for a given weight function is a determinate problem with a unique solution.\n- **Objectivity**: The problem is stated in precise, objective mathematical language, free from any subjective or biased phrasing.\n- **Completeness and Consistency**: The problem is self-contained. It provides all necessary information to derive the solution from first principles, as requested. There are no contradictions in the setup.\n- **Realism**: The problem is a standard exercise in numerical methods and is entirely realistic from a mathematical and computational standpoint.\n\n### Step 3: Verdict and Action\nThe problem is valid. It is a standard, well-posed problem in numerical analysis that can be solved from first principles. I will proceed with the solution.\n\nThe problem requires the construction of a Gaussian quadrature rule for the weight function $w(x) = \\exp(-x^2)$ on the interval $(-\\infty, \\infty)$ that is exact for polynomials $f(x)$ of degree up to $5$. The general form of an $n$-point Gaussian quadrature rule is:\n$$\n\\int_{-\\infty}^{\\infty} \\exp(-x^2) f(x) \\, dx \\approx \\sum_{i=1}^{n} W_i f(x_i)\n$$\nA rule with $n$ nodes ($x_i$) and $n$ weights ($W_i$) has $2n$ free parameters. These can be chosen to make the rule exact for all polynomials of degree up to $2n-1$. The problem demands exactness for polynomials of degree up to $5$. Therefore, we must have $2n-1 \\geq 5$, which implies $2n \\geq 6$, so the minimum number of nodes is $n=3$. We will construct a $3$-point rule.\n\nThe rule must be exact for $f(x) = x^k$ for $k = 0, 1, 2, 3, 4, 5$. This gives the system of equations:\n$$\n\\sum_{i=1}^{3} W_i x_i^k = \\int_{-\\infty}^{\\infty} \\exp(-x^2) x^k \\, dx \\equiv M_k\n$$\nwhere $M_k$ is the $k$-th moment of the Gaussian weight function.\n\nThe weight function $w(x) = \\exp(-x^2)$ is an even function, and the integration interval $(-\\infty, \\infty)$ is symmetric about $x=0$. For a Gaussian quadrature rule, this symmetry implies that the nodes must be symmetric about the origin and the weights of symmetric nodes must be equal. For $n=3$, this means one node must be at the center, $x_2=0$, and the other two must be opposites, $x_1 = -x_0$ and $x_3 = x_0$ for some $x_0 > 0$. The corresponding weights must be $W_1 = W_3$. Let's denote $W_1 = W_3 = W_A$ and $W_2 = W_B$.\n\nThe quadrature rule is:\n$$\n\\int_{-\\infty}^{\\infty} \\exp(-x^2) f(x) \\, dx \\approx W_A f(-x_0) + W_B f(0) + W_A f(x_0)\n$$\n\nNext, we calculate the required moments $M_k$. For any odd integer $k$, the integrand $\\exp(-x^2)x^k$ is an odd function, so its integral over a symmetric interval is zero. Thus, $M_1 = M_3 = M_5 = 0$. Our symmetric choice of nodes and weights automatically satisfies these conditions:\nFor $k=1,3,5$: $\\sum W_i x_i^k = W_A(-x_0)^k + W_B(0)^k + W_A(x_0)^k = -W_A x_0^k + W_A x_0^k = 0$.\n\nWe only need to enforce the conditions for even $k=0, 2, 4$:\n$M_0 = \\int_{-\\infty}^{\\infty} \\exp(-x^2) \\, dx = \\sqrt{\\pi}$ (the standard Gaussian integral).\n$M_2 = \\int_{-\\infty}^{\\infty} x^2 \\exp(-x^2) \\, dx$. We use integration by parts with $u=x$ and $dv=x\\exp(-x^2)dx$, so $du=dx$ and $v=-\\frac{1}{2}\\exp(-x^2)$.\n$$\nM_2 = \\left[-\\frac{1}{2}x\\exp(-x^2)\\right]_{-\\infty}^{\\infty} - \\int_{-\\infty}^{\\infty} \\left(-\\frac{1}{2}\\exp(-x^2)\\right) \\, dx = 0 + \\frac{1}{2} \\int_{-\\infty}^{\\infty} \\exp(-x^2) \\, dx = \\frac{1}{2}M_0 = \\frac{\\sqrt{\\pi}}{2}\n$$\n$M_4 = \\int_{-\\infty}^{\\infty} x^4 \\exp(-x^2) \\, dx$. We use integration by parts with $u=x^3$ and $dv=x\\exp(-x^2)dx$, so $du=3x^2dx$ and $v=-\\frac{1}{2}\\exp(-x^2)$.\n$$\nM_4 = \\left[-\\frac{1}{2}x^3\\exp(-x^2)\\right]_{-\\infty}^{\\infty} - \\int_{-\\infty}^{\\infty} \\left(-\\frac{3}{2}x^2\\exp(-x^2)\\right) \\, dx = 0 + \\frac{3}{2} \\int_{-\\infty}^{\\infty} x^2\\exp(-x^2) \\, dx = \\frac{3}{2}M_2 = \\frac{3}{2}\\left(\\frac{\\sqrt{\\pi}}{2}\\right) = \\frac{3\\sqrt{\\pi}}{4}\n$$\n\nNow we set up the system of equations for the unknowns $x_0, W_A, W_B$:\n1. For $k=0$ ($f(x)=1$): $W_A \\cdot 1 + W_B \\cdot 1 + W_A \\cdot 1 = M_0 \\implies 2W_A + W_B = \\sqrt{\\pi}$\n2. For $k=2$ ($f(x)=x^2$): $W_A(-x_0)^2 + W_B(0)^2 + W_A(x_0)^2 = M_2 \\implies 2W_A x_0^2 = \\frac{\\sqrt{\\pi}}{2}$\n3. For $k=4$ ($f(x)=x^4$): $W_A(-x_0)^4 + W_B(0)^4 + W_A(x_0)^4 = M_4 \\implies 2W_A x_0^4 = \\frac{3\\sqrt{\\pi}}{4}$\n\nWe have three equations and three unknowns. We can solve this system. Divide equation (3) by equation (2):\n$$\n\\frac{2W_A x_0^4}{2W_A x_0^2} = \\frac{3\\sqrt{\\pi}/4}{\\sqrt{\\pi}/2} \\implies x_0^2 = \\frac{3\\sqrt{\\pi}}{4} \\cdot \\frac{2}{\\sqrt{\\pi}} = \\frac{3}{2}\n$$\nThis gives the non-zero nodes: $x_0 = \\sqrt{\\frac{3}{2}}$. The three nodes are $x_1 = -\\sqrt{\\frac{3}{2}}$, $x_2=0$, and $x_3=\\sqrt{\\frac{3}{2}}$.\n\nSubstitute $x_0^2 = \\frac{3}{2}$ into equation (2):\n$$\n2W_A \\left(\\frac{3}{2}\\right) = \\frac{\\sqrt{\\pi}}{2} \\implies 3W_A = \\frac{\\sqrt{\\pi}}{2} \\implies W_A = \\frac{\\sqrt{\\pi}}{6}\n$$\nThis gives the outer weights: $W_1 = W_3 = \\frac{\\sqrt{\\pi}}{6}$.\n\nSubstitute $W_A = \\frac{\\sqrt{\\pi}}{6}$ into equation (1):\n$$\n2\\left(\\frac{\\sqrt{\\pi}}{6}\\right) + W_B = \\sqrt{\\pi} \\implies \\frac{\\sqrt{\\pi}}{3} + W_B = \\sqrt{\\pi} \\implies W_B = \\sqrt{\\pi} - \\frac{\\sqrt{\\pi}}{3} = \\frac{2\\sqrt{\\pi}}{3}\n$$\nThis gives the central weight: $W_2 = \\frac{2\\sqrt{\\pi}}{3}$.\n\nThe constructed $3$-point Gauss-Hermite quadrature rule is:\nNodes: $x_1 = -\\sqrt{\\frac{3}{2}}$, $x_2=0$, $x_3=\\sqrt{\\frac{3}{2}}$\nWeights: $W_1 = \\frac{\\sqrt{\\pi}}{6}$, $W_2 = \\frac{2\\sqrt{\\pi}}{3}$, $W_3 = \\frac{\\sqrt{\\pi}}{6}$\n\nNow, we apply this rule to the integral $I = \\int_{-\\infty}^{\\infty} \\exp(-x^{2}) x^{4} dx$.\nIn this case, the function $f(x)$ is $x^4$. The degree of this polynomial is $4$. Since our rule is exact for all polynomials of degree up to $5$, the value given by the quadrature rule will be the exact value of the integral.\n\nApplying the rule:\n$$\nI = \\sum_{i=1}^{3} W_i f(x_i) = W_1 f(x_1) + W_2 f(x_2) + W_3 f(x_3)\n$$\nThe function values at the nodes are:\n$f(x_1) = f(-\\sqrt{\\frac{3}{2}}) = \\left(-\\sqrt{\\frac{3}{2}}\\right)^4 = \\left(\\frac{3}{2}\\right)^2 = \\frac{9}{4}$\n$f(x_2) = f(0) = 0^4 = 0$\n$f(x_3) = f(\\sqrt{\\frac{3}{2}}) = \\left(\\sqrt{\\frac{3}{2}}\\right)^4 = \\left(\\frac{3}{2}\\right)^2 = \\frac{9}{4}$\n\nSubstituting these values and the weights into the quadrature sum:\n$$\nI = \\left(\\frac{\\sqrt{\\pi}}{6}\\right) \\left(\\frac{9}{4}\\right) + \\left(\\frac{2\\sqrt{\\pi}}{3}\\right) (0) + \\left(\\frac{\\sqrt{\\pi}}{6}\\right) \\left(\\frac{9}{4}\\right)\n$$\n$$\nI = 2 \\left(\\frac{\\sqrt{\\pi}}{6} \\cdot \\frac{9}{4}\\right) = \\frac{\\sqrt{\\pi}}{3} \\cdot \\frac{9}{4} = \\frac{9\\sqrt{\\pi}}{12} = \\frac{3\\sqrt{\\pi}}{4}\n$$\nThis result is identical to the moment $M_4$ we calculated analytically, which serves as a verification of our derived rule. The problem asks for the value obtained by applying the rule, which is this exact value.", "answer": "$$\n\\boxed{\\frac{3\\sqrt{\\pi}}{4}}\n$$", "id": "3612134"}, {"introduction": "Real-world integrands, such as those describing seismic wave attenuation, are rarely smooth and well-behaved across the entire domain of integration. This advanced coding practice challenges you to build a robust, adaptive quadrature driver that intelligently switches between different integration strategies—a high-order Gauss-Kronrod rule for smooth regions and a composite Newton-Cotes rule for rough ones. By implementing a solution for a realistic geophysical model, you will gain hands-on experience in error estimation, algorithmic decision-making, and the creation of professional-grade numerical tools.[@problem_id:3612152]", "problem": "You are tasked with implementing an adaptive quadrature driver that evaluates frequency-domain attenuation integrals arising in computational seismology. The driver must switch between a Gaussian rule with a Kronrod extension and a composite Newton–Cotes rule based on a smoothness estimator derived from sampled seismic quality factor data, denoted as $Q(\\omega)$. Your code must produce a single line of output containing the numerical values of the specified integrals for a provided test suite.\n\nDefinitions and modeling assumptions:\n\n- The angular frequency is $\\omega$ in radians per second. All angles are in radians and all frequency-related quantities are in radians per second. The integral values must be expressed in radians per second.\n\n- The attenuation model uses a baseline power-law quality factor $Q_{\\mathrm{b}}(\\omega)$ and superimposed resonant relaxation mechanisms that modify the effective quality factor $Q(\\omega)$ via the reciprocal $R(\\omega) = 1 / Q(\\omega)$. The baseline is\n$$\nQ_{\\mathrm{b}}(\\omega) = Q_{\\mathrm{ref}} \\left(\\frac{\\omega}{\\omega_{\\mathrm{ref}}}\\right)^{\\alpha},\n$$\nwith $Q_{\\mathrm{ref}} > 0$, $\\omega_{\\mathrm{ref}} = 1$, and real exponent $\\alpha \\ge 0$. To avoid division by zero at $\\omega = 0$, you must evaluate the baseline term at $\\max(\\omega, \\varepsilon_{\\omega})$ with $\\varepsilon_{\\omega} = 10^{-6}$.\n\n- The reciprocal effective quality factor $R(\\omega)$ is modeled as\n$$\nR(\\omega) \\equiv \\frac{1}{Q(\\omega)} = \\frac{1}{Q_{\\mathrm{b}}(\\omega)} + \\sum_{i=1}^{M} \\frac{A_i \\, \\Gamma_i^2}{(\\omega - \\omega_i)^2 + \\Gamma_i^2},\n$$\nwhere each term represents a resonance centered at $\\omega_i$ with half-width $\\Gamma_i > 0$ and nonnegative amplitude $A_i \\ge 0$. This guarantees $Q(\\omega) > 0$ and prevents nonphysical negative damping.\n\n- The resonance-dominated source spectrum is modeled as a sum of Lorentzian peaks,\n$$\nL(\\omega) = \\sum_{i=1}^{M} \\frac{\\beta_i \\, \\Gamma_i}{(\\omega - \\omega_i)^2 + \\Gamma_i^2},\n$$\nwith amplitudes $\\beta_i \\ge 0$.\n\n- The attenuated spectrum integrand is\n$$\nS(\\omega) = L(\\omega) \\exp\\!\\left(-\\frac{\\omega \\, \\tau}{2 \\, Q(\\omega)}\\right),\n$$\nwith travel time parameter $\\tau > 0$.\n\n- The integral of interest is\n$$\nI = \\int_{\\omega_{\\min}}^{\\omega_{\\max}} S(\\omega) \\, d\\omega,\n$$\nwhich has units of radians per second.\n\nAdaptive quadrature driver requirements:\n\n- On any subinterval $I = [a, b]$, estimate smoothness using only sampled reciprocal quality factor values. Let $m = 7$ equispaced sample points $\\{\\omega_j\\}_{j=0}^{m-1}$ in $[a, b]$ with step $h = (b-a)/(m-1)$, and define $r_j = 1/Q(\\omega_j)$. The smoothness indicator is\n$$\n\\kappa(I) = \\frac{\\max_{0 \\le j \\le m-3} \\left| r_{j+2} - 2 r_{j+1} + r_{j} \\right|}{h^2 \\left(\\epsilon + \\frac{1}{m}\\sum_{j=0}^{m-1} |r_j|\\right)},\n$$\nwith $\\epsilon = 10^{-12}$. Interpret $\\kappa(I)$ as a dimensionless curvature-based roughness measure for $1/Q(\\omega)$ on $I$.\n\n- Method switching rule: if $\\kappa(I) \\le \\kappa_0$ with threshold $\\kappa_0 = 1$, use a $7$–$15$-point Gauss–Kronrod rule on $I$ and estimate the local error by the absolute difference between the Gauss and Kronrod estimates; otherwise, use composite Simpson’s rule (closed Newton–Cotes of degree $2$) on $I$, refining the number of subpanels by repeated halving of the step size until the Richardson extrapolation error estimate $\\approx |S_{2n} - S_n|/15$ falls below the local tolerance.\n\n- Adaptivity: if the locally chosen rule does not satisfy the local absolute error tolerance on $I$, bisect $I$ and apply the same logic recursively on the two halves. Use a maximum recursion depth of $20$. Distribute the absolute tolerance uniformly upon bisection: if a subinterval $I$ has tolerance $T$, then its children each inherit tolerance $T/2$.\n\n- Your implementation must not use any black-box adaptive integrator. You must implement both the Gauss–Kronrod $7$–$15$ rule and composite Simpson’s rule yourself. You must implement the smoothness estimator exactly as defined above.\n\nTest suite:\n\nImplement your program to compute $I$ for each of the following four parameter sets. In all cases, take $\\omega_{\\mathrm{ref}} = 1$ and $\\varepsilon_{\\omega} = 10^{-6}$. All $\\omega$ and $\\Gamma$ are in radians per second, all $\\tau$ are in seconds, and the answers must be in radians per second.\n\n- Case $1$ (general multi-peak, moderate smoothness):\n  - $\\omega_{\\min} = 0$, $\\omega_{\\max} = 400$, $\\tau = 1.0$, $Q_{\\mathrm{ref}} = 200$, $\\alpha = 0.1$, $M = 2$.\n  - Resonances: $(\\omega_1, \\Gamma_1, A_1, \\beta_1) = (100, 10, 0.02, 1.0)$, $(\\omega_2, \\Gamma_2, A_2, \\beta_2) = (250, 20, 0.01, 0.7)$.\n  - Absolute tolerance $T = 10^{-6}$.\n\n- Case $2$ (sharp narrow peak inside the interval):\n  - $\\omega_{\\min} = 120$, $\\omega_{\\max} = 180$, $\\tau = 0.5$, $Q_{\\mathrm{ref}} = 100$, $\\alpha = 0.05$, $M = 2$.\n  - Resonances: $(\\omega_1, \\Gamma_1, A_1, \\beta_1) = (150, 1, 0.05, 0.8)$, $(\\omega_2, \\Gamma_2, A_2, \\beta_2) = (160, 5, 0.02, 0.6)$.\n  - Absolute tolerance $T = 10^{-7}$.\n\n- Case $3$ (peak at the boundary):\n  - $\\omega_{\\min} = 250$, $\\omega_{\\max} = 300$, $\\tau = 0.2$, $Q_{\\mathrm{ref}} = 150$, $\\alpha = 0$, $M = 2$.\n  - Resonances: $(\\omega_1, \\Gamma_1, A_1, \\beta_1) = (300, 2, 0.03, 1.2)$, $(\\omega_2, \\Gamma_2, A_2, \\beta_2) = (270, 3, 0.01, 0.3)$.\n  - Absolute tolerance $T = 10^{-7}$.\n\n- Case $4$ (smooth baseline, no resonances):\n  - $\\omega_{\\min} = 0$, $\\omega_{\\max} = 500$, $\\tau = 1.0$, $Q_{\\mathrm{ref}} = 400$, $\\alpha = 0.2$, $M = 0$.\n  - Resonances: none.\n  - Absolute tolerance $T = 10^{-6}$.\n\nImplementation constraints and required output:\n\n- Your program must implement the hybrid adaptive driver exactly as described, including the smoothness-based switching between Gauss–Kronrod and composite Newton–Cotes. You must not rely on any external adaptive integration routine.\n\n- Your program should produce a single line of output containing the four integral values as a comma-separated list enclosed in square brackets, in the order of cases $1$ through $4$, using the default string representation of double-precision floating-point numbers (for example, $[x_1,x_2,x_3,x_4]$). The values must be in radians per second.\n\n- No user input is allowed; all parameters must be defined in code and must match the test suite above.", "solution": "The user requires the implementation of a specialized adaptive quadrature driver to solve a class of integrals encountered in computational seismology. The core of the task is to develop a hybrid numerical integration scheme that dynamically selects between a high-order Gauss-Kronrod rule and a robust composite Newton-Cotes rule based on a real-time estimate of the integrand's local smoothness.\n\n**Problem Validation**\n\nThe problem statement has been rigorously evaluated and is determined to be **valid**. It is scientifically grounded in the established physics of wave attenuation, mathematically well-posed, and all parameters, functions, and algorithmic requirements are specified objectively and without ambiguity. The models for the seismic quality factor $Q(\\omega)$ and the attenuated spectrum $S(\\omega)$ are standard representations in the field. The numerical methods prescribed—Gauss-Kronrod quadrature, composite Simpson's rule, and a recursive adaptive bisection strategy—are canonical techniques in scientific computing. The test cases provided are well-defined and cover a range of scenarios relevant to testing the robustness of such a numerical driver. The problem is self-contained and complete, with the minor exception of not providing the standard constants for the Gauss-Kronrod rule, which are non-controversial, widely published values that a practitioner is expected to know or be able to reference.\n\n**Principle-Based Solution Design**\n\nThe solution will be constructed based on the following principles of numerical analysis and physics modeling.\n\n**1. Attenuation Model Formulation**\n\nThe integral to be computed is $I = \\int_{\\omega_{\\min}}^{\\omega_{\\max}} S(\\omega) \\, d\\omega$, where $S(\\omega)$ is the attenuated spectrum. This integrand is a product of a source spectrum $L(\\omega)$ and an exponential attenuation term.\n\nThe source spectrum $L(\\omega)$ is modeled as a sum of $M$ Lorentzian functions:\n$$\nL(\\omega) = \\sum_{i=1}^{M} \\frac{\\beta_i \\, \\Gamma_i}{(\\omega - \\omega_i)^2 + \\Gamma_i^2}\n$$\nEach term represents a resonance peak with amplitude $\\beta_i \\ge 0$ centered at frequency $\\omega_i$ with half-width $\\Gamma_i > 0$.\n\nThe attenuation is controlled by the seismic quality factor $Q(\\omega)$, whose reciprocal $R(\\omega) = 1/Q(\\omega)$ is given by:\n$$\nR(\\omega) = \\frac{1}{Q(\\omega)} = \\frac{1}{Q_{\\mathrm{b}}(\\omega)} + \\sum_{i=1}^{M} \\frac{A_i \\, \\Gamma_i^2}{(\\omega - \\omega_i)^2 + \\Gamma_i^2}\n$$\nThis model combines a baseline power-law attenuation, $Q_{\\mathrmb}(\\omega)$, with the same resonant relaxation mechanisms present in the source. The baseline quality factor is:\n$$\nQ_{\\mathrmb}(\\omega) = Q_{\\mathrm{ref}} \\left(\\frac{\\max(\\omega, \\varepsilon_{\\omega})}{\\omega_{\\mathrm{ref}}}\\right)^{\\alpha}\n$$\nThe use of $\\max(\\omega, \\varepsilon_{\\omega})$ with $\\varepsilon_{\\omega} = 10^{-6}$ is a standard regularization to prevent division by zero at $\\omega=0$.\n\nThe final integrand is then constructed as:\n$$\nS(\\omega) = L(\\omega) \\exp\\!\\left(-\\frac{\\omega \\, \\tau}{2} R(\\omega)\\right) = L(\\omega) \\exp\\!\\left(-\\frac{\\omega \\, \\tau}{2 \\, Q(\\omega)}\\right)\n$$\nwhere $\\tau > 0$ is a travel time parameter.\n\n**2. Adaptive Quadrature Framework**\n\nThe integral $I$ is approximated using a recursive, adaptive algorithm. The principle of adaptive quadrature is to concentrate computational effort on subintervals where the integrand is \"difficult\" (i.e., less smooth or rapidly varying) and use fewer resources where it is \"easy\" (i.e., smooth). This is achieved by:\n1.  Estimating the integration error on the current interval.\n2.  If the error is within a specified tolerance, the result is accepted.\n3.  If the error is too large, the interval is subdivided (bisected), and the algorithm is applied recursively to each subinterval with a proportionally smaller error tolerance.\n\nThe recursion is limited by a maximum depth to prevent infinite loops in pathological cases. The absolute error tolerance $T$ for an interval $[a, b]$ is distributed equally to its children, $[a, (a+b)/2]$ and $[(a+b)/2, b]$, each receiving a tolerance of $T/2$.\n\n**3. Smoothness-Based Method Switching**\n\nA key requirement of this problem is a hybrid approach. The choice of numerical integration rule on any given subinterval $I=[a, b]$ is determined by the local smoothness of the reciprocal quality factor, $R(\\omega) = 1/Q(\\omega)$. The smoothness indicator $\\kappa(I)$ is defined as a normalized finite-difference approximation of the second derivative:\n$$\n\\kappa(I) = \\frac{\\max_{0 \\le j \\le m-3} \\left| r_{j+2} - 2 r_{j+1} + r_{j} \\right|}{h^2 \\left(\\epsilon + \\frac{1}{m}\\sum_{j=0}^{m-1} |r_j|\\right)}\n$$\nwhere $r_j = R(\\omega_j)$ are samples at $m=7$ equispaced points in $[a, b]$, $h=(b-a)/(m-1)$ is the step size, and $\\epsilon=10^{-12}$ is a regularization constant. A small value of $\\kappa(I)$ suggests that $R(\\omega)$ is smooth on the interval, while a large value indicates high curvature or roughness, likely due to proximity to a resonance peak.\n\nThe switching rule is:\n- If $\\kappa(I) \\le \\kappa_0 = 1$, the function is considered smooth, and a $7$–$15$-point Gauss-Kronrod rule is employed.\n- If $\\kappa(I) > \\kappa_0 = 1$, the function is considered rough, and a more robust composite Simpson's rule is used.\n\n**4. Quadrature Rule Implementations**\n\n**a) Gauss-Kronrod Quadrature ($7$–$15$ Rule)**\nThis method is highly efficient for smooth functions. It computes two integral estimates: a $7$-point Gaussian quadrature estimate, $I_{G7}$, and a higher-order $15$-point Kronrod quadrature estimate, $I_{K15}$. The Kronrod rule is constructed to reuse all $7$ function evaluation points from the Gaussian rule, adding $8$ new points. The principle is that $I_{K15}$ is a much more accurate estimate than $I_{G7}$. Therefore, their absolute difference, $|I_{K15} - I_{G7}|$, provides a reliable and computationally inexpensive estimate of the error in the lower-order rule, which is then taken as the error in $I_{K15}$ for adaptive purposes.\n\nThe definite integral $\\int_a^b f(x) dx$ is calculated by first making a linear change of variables $x = \\frac{b-a}{2}t + \\frac{a+b}{2}$ to transform the domain to $[-1, 1]$. The integral becomes:\n$$\n\\int_{-1}^{1} f\\left(\\frac{b-a}{2}t + \\frac{a+b}{2}\\right) \\frac{b-a}{2} dt \\approx \\frac{b-a}{2} \\sum_{i=1}^{N} w_i f\\left(\\frac{b-a}{2}t_i + \\frac{a+b}{2}\\right)\n$$\nwhere $\\{t_i, w_i\\}_{i=1}^N$ are the standard $N$-point quadrature nodes and weights for the interval $[-1, 1]$. We will use the pre-computed, standard constants for the 7-point Gauss and 15-point Kronrod rules.\n\n**b) Composite Simpson's Rule with Refinement**\nFor non-smooth functions, the polynomial approximation underlying high-order Gauss rules can be poor. Simpson's rule, a lower-order Newton-Cotes formula, is more robust. In its composite form, the interval $[a, b]$ is divided into $n$ panels (or $2n$ subintervals of width $\\Delta x = (b-a)/(2n)$). The integral is approximated by:\n$$\n\\int_a^b f(x) dx \\approx \\frac{\\Delta x}{3} \\left[ f(x_0) + 4f(x_1) + 2f(x_2) + \\dots + 4f(x_{2n-1}) + f(x_{2n}) \\right]\n$$\nThe error of this rule is of order $O(h^4)$ where $h$ is the panel width. The problem requires an iterative refinement process: if the integral estimates from $n$ panels ($S_n$) and $2n$ panels ($S_{2n}$) do not satisfy the error criterion, the process is repeated with $2n$ and $4n$ panels. The error is estimated using Richardson extrapolation:\n$$\nE \\approx \\frac{|S_{2n} - S_n|}{2^4 - 1} = \\frac{|S_{2n} - S_n|}{15}\n$$\nThis refinement loop continues until $E$ is less than or equal to the local tolerance on the subinterval.\n\n**5. Synthesized Algorithm**\n\nThe complete algorithm can be encapsulated in a recursive function, `adaptive_driver(f, r, a, b, tol, depth)`:\n1.  **Termination Check:** If `depth` exceeds the maximum of $20$, compute the integral over $[a, b]$ with the high-accuracy $I_{K15}$ rule and return, accepting the result regardless of error.\n2.  **Smoothness Estimation:** Compute $\\kappa([a, b])$ using the function `r` (representing $1/Q(\\omega)$).\n3.  **Method Selection and Execution:**\n    - If $\\kappa \\le 1$:\n        - Compute $I_{G7}$ and $I_{K15}$ for the integrand `f` over $[a, b]$.\n        - Calculate error $E = |I_{K15} - I_{G7}|$.\n        - Set the integral estimate $I_{est} = I_{K15}$.\n    - If $\\kappa > 1$:\n        - Use the iterative composite Simpson's rule on `f` over $[a, b]$ until the Richardson error estimate $E$ is less than or equal to `tol`.\n        - Set the integral estimate $I_{est}$ to the final, most accurate Simpson's value.\n4.  **Adaptive Step:**\n    - If the calculated error $E \\le tol$, return $I_{est}$.\n    - Otherwise, bisect the interval: $m = (a+b)/2$. Recursively call the driver for the left and right halves and sum the results:\n      `return adaptive_driver(f, r, a, m, tol/2, depth+1) + adaptive_driver(f, r, m, b, tol/2, depth+1)`.\n\nThis design rigorously adheres to all problem specifications, providing a robust and efficient solution.", "answer": "```python\nimport numpy as np\nimport math\n\n# --- Gauss-Kronrod 7-15 Quadrature Constants for [-1, 1] ---\n# These are standard, pre-computed values.\n# Positive nodes (abscissae) for the 15-point Kronrod rule.\n# The G7 nodes are a subset of these.\nGK15_NODES_POS = np.array([\n    0.2077849550078985,\n    0.4058451513773972,\n    0.5860872354676911,\n    0.7415311855993944,\n    0.8648644233597691,\n    0.9491079123427585,\n    0.9914553711208126\n])\n\n# Weights for the 15-point Kronrod rule (for positive nodes and center).\nK15_WEIGHTS_POS = np.array([\n    0.2044329400752989,\n    0.1903505780647854,\n    0.1690047266392679,\n    0.1406532597155259,\n    0.1047900103222502,\n    0.06309209262997855,\n    0.02293532201052922\n])\nK15_WEIGHT_0 = 0.2094821410847278\n\n# Weights for the 7-point Gauss rule (for corresponding nodes and center).\n# G7 nodes correspond to indices 1, 3, 5 of the positive nodes array.\nG7_WEIGHTS_POS = np.array([\n    0.0,\n    0.3818300505051189,\n    0.0,\n    0.2797053914892766,\n    0.0,\n    0.1294849661688697,\n    0.0\n])\nG7_WEIGHT_0 = 0.4179591836734694\n\n\ndef _gauss_kronrod_7_15(f, a, b):\n    \"\"\"Computes the G7 and K15 integrals on the interval [a, b].\"\"\"\n    center = 0.5 * (a + b)\n    half_length = 0.5 * (b - a)\n\n    # Evaluate integrand at the center point\n    f_center = f(center)\n    \n    # Evaluate integrand at positive and negative nodes\n    f_pos = f(center + half_length * GK15_NODES_POS)\n    f_neg = f(center - half_length * GK15_NODES_POS)\n\n    # Compute K15 integral\n    result_k15 = half_length * (K15_WEIGHT_0 * f_center + np.sum(K15_WEIGHTS_POS * (f_pos + f_neg)))\n\n    # Compute G7 integral (uses a subset of the previous evaluations)\n    result_g7 = half_length * (G7_WEIGHT_0 * f_center + np.sum(G7_WEIGHTS_POS * (f_pos + f_neg)))\n    \n    return result_g7, result_k15\n\ndef _composite_simpson(f, a, b, n):\n    \"\"\"Computes the integral on [a, b] using composite Simpson's rule with n panels.\"\"\"\n    if n == 0:\n        return 0.0 # No panels, no area\n    h = (b - a) / (2 * n)\n    x = np.linspace(a, b, 2 * n + 1)\n    y = f(x)\n    \n    # Simpson's rule: h/3 * [y0 + 4y1 + 2y2 + ... + 4y(2n-1) + yn]\n    result = y[0] + y[-1] + 4 * np.sum(y[1:-1:2]) + 2 * np.sum(y[2:-1:2])\n    return result * h / 3.0\n\ndef _refined_composite_simpson(f, a, b, tol):\n    \"\"\"Iteratively refines composite Simpson's rule until tolerance is met.\"\"\"\n    n = 2  # Start with 2 panels (5 points)\n    max_refinements = 15 # Safety break\n    \n    s_n = _composite_simpson(f, a, b, n)\n    \n    for _ in range(max_refinements):\n        n *= 2\n        s_2n = _composite_simpson(f, a, b, n)\n        error = abs(s_2n - s_n) / 15.0\n        if error <= tol:\n            return s_2n, error\n        s_n = s_2n\n        \n    return s_2n, error  # Return best effort\n\ndef _calculate_smoothness(r_func, a, b):\n    \"\"\"Calculates the smoothness indicator kappa on [a, b].\"\"\"\n    m = 7\n    eps_kappa = 1e-12\n    if a == b: return 0.0\n\n    omega_j = np.linspace(a, b, m)\n    r_j = r_func(omega_j)\n    h = (b - a) / (m - 1)\n\n    numerators = np.abs(r_j[2:] - 2 * r_j[1:-1] + r_j[:-2])\n    max_numerator = np.max(numerators) if numerators.size > 0 else 0.0\n    \n    denominator = h**2 * (eps_kappa + np.mean(np.abs(r_j)))\n    \n    if denominator == 0: return float('inf')\n    return max_numerator / denominator\n\ndef _adaptive_quadrature_driver(f, r_func, a, b, tol, depth, max_depth, kappa_0):\n    \"\"\"The main recursive adaptive quadrature driver.\"\"\"\n    if depth > max_depth:\n        # Max depth reached, return best estimate with K15 and stop recursion.\n        _, integral = _gauss_kronrod_7_15(f, a, b)\n        return integral\n\n    kappa = _calculate_smoothness(r_func, a, b)\n\n    if kappa <= kappa_0:\n        # Smooth region: use Gauss-Kronrod\n        integral_g7, integral_k15 = _gauss_kronrod_7_15(f, a, b)\n        error = abs(integral_k15 - integral_g7)\n        estimate = integral_k15\n    else:\n        # Rough region: use refined composite Simpson's\n        estimate, error = _refined_composite_simpson(f, a, b, tol)\n\n    if error <= tol:\n        return estimate\n    else:\n        # Error too large, bisect and recurse\n        mid = 0.5 * (a + b)\n        left_integral = _adaptive_quadrature_driver(f, r_func, a, mid, tol / 2.0, depth + 1, max_depth, kappa_0)\n        right_integral = _adaptive_quadrature_driver(f, r_func, mid, b, tol / 2.0, depth + 1, max_depth, kappa_0)\n        return left_integral + right_integral\n\ndef solve():\n    \"\"\"Main function to run the test suite and print results.\"\"\"\n    test_cases = [\n        # Case 1\n        {'w_min': 0, 'w_max': 400, 'tau': 1.0, 'Q_ref': 200, 'alpha': 0.1, 'M': 2,\n         'resonances': [(100, 10, 0.02, 1.0), (250, 20, 0.01, 0.7)], 'tol': 1e-6},\n        # Case 2\n        {'w_min': 120, 'w_max': 180, 'tau': 0.5, 'Q_ref': 100, 'alpha': 0.05, 'M': 2,\n         'resonances': [(150, 1, 0.05, 0.8), (160, 5, 0.02, 0.6)], 'tol': 1e-7},\n        # Case 3\n        {'w_min': 250, 'w_max': 300, 'tau': 0.2, 'Q_ref': 150, 'alpha': 0.0, 'M': 2,\n         'resonances': [(300, 2, 0.03, 1.2), (270, 3, 0.01, 0.3)], 'tol': 1e-7},\n        # Case 4\n        {'w_min': 0, 'w_max': 500, 'tau': 1.0, 'Q_ref': 400, 'alpha': 0.2, 'M': 0,\n         'resonances': [], 'tol': 1e-6}\n    ]\n\n    results = []\n    w_ref = 1.0\n    eps_w = 1e-6\n    max_rec_depth = 20\n    kappa_0 = 1.0\n\n    for case in test_cases:\n        Q_ref = case['Q_ref']\n        alpha = case['alpha']\n        resonances = case['resonances']\n        tau = case['tau']\n        M = case['M']\n        w_min = case['w_min']\n        w_max = case['w_max']\n        tol = case['tol']\n        \n        # Vectorized implementation of the model functions\n        def q_b(w):\n            w_eff = np.maximum(w, eps_w)\n            # handle w=0 correctly even with alpha=0, (0/1)^0 is nan\n            if alpha == 0: return np.full_like(w, Q_ref)\n            return Q_ref * (w_eff / w_ref)**alpha\n\n        def r_func(w):\n            res_sum = np.zeros_like(w, dtype=float)\n            if M > 0:\n                for w_i, gamma_i, A_i, _ in resonances:\n                    res_sum += A_i * gamma_i**2 / ((w - w_i)**2 + gamma_i**2)\n            return 1.0 / q_b(w) + res_sum\n\n        def l_func(w):\n            lor_sum = np.zeros_like(w, dtype=float)\n            if M > 0:\n                for w_i, gamma_i, _, beta_i in resonances:\n                    lor_sum += beta_i * gamma_i / ((w - w_i)**2 + gamma_i**2)\n            return lor_sum\n\n        def s_func(w):\n            # To handle single float inputs\n            w = np.asarray(w)\n            if M == 0:\n                # If M=0, L(w)=0, so S(w)=0. The integral is 0.\n                return np.zeros_like(w)\n            return l_func(w) * np.exp(-w * tau * r_func(w) / 2.0)\n\n        integral_val = _adaptive_quadrature_driver(s_func, r_func, w_min, w_max, tol, 0, max_rec_depth, kappa_0)\n        results.append(integral_val)\n\n    # Format output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3612152"}]}