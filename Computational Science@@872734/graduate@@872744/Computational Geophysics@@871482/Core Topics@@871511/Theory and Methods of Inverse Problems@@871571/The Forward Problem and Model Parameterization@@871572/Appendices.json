{"hands_on_practices": [{"introduction": "Before building complex numerical simulations, we must ensure our physical model is fundamentally sound. This exercise is a foundational practice in dimensional analysis, which serves as a critical sanity check on the governing equations of a forward problem. By verifying the dimensional consistency of the Helmholtz equation and the chosen model parameterization [@problem_id:3616698], you will reinforce your understanding of the physical principles that underpin wave-based modeling and confirm the validity of your mathematical framework.", "problem": "Consider a frequency-domain acoustic forward problem in a lossless, inviscid fluid with constant mass density $\\,\\rho\\,$, where the time dependence of all fields is harmonic as $\\exp(-\\mathrm{i}\\,\\omega t)$. The measurable data are pressure amplitudes $\\,p(\\mathbf{x};\\omega)\\,$ recorded at receiver locations $\\,\\mathbf{x}_r\\,$. The forward model is the scalar Helmholtz equation\n$$\n\\nabla^{2} p(\\mathbf{x};\\omega) + \\omega^{2}\\,m(\\mathbf{x})\\,p(\\mathbf{x};\\omega) \\;=\\; f(\\mathbf{x};\\omega),\n$$\nwith model parameterization $\\,m(\\mathbf{x}) = c(\\mathbf{x})^{-2}\\,$, where $\\,c(\\mathbf{x})\\,$ is the position-dependent acoustic wavespeed. Assume the base physical dimensions of length $\\,L\\,$, time $\\,T\\,$, and mass $\\,M\\,$, and take pressure to have the dimension $[p] = M\\,L^{-1}\\,T^{-2}$, angular frequency $[\\omega] = T^{-1}$, and wavespeed $[c] = L\\,T^{-1}$.\n\nDefine the following two dimensionless consistency indices:\n$$\n\\chi \\;:=\\; \\frac{[\\omega^{2}\\,m\\,p]}{[\\nabla^{2} p]}, \n\\qquad\n\\eta \\;:=\\; \\frac{[f]}{[\\nabla^{2} p]}.\n$$\nUsing only dimensional analysis grounded in the fundamental linear acoustics framework (linearized momentum balance, mass conservation, and an equation of state), compute $\\,\\chi\\,$ and, under the requirement that pressure-valued data $\\,p(\\mathbf{x}_r;\\omega)\\,$ must be predicted coherently by the forward operator, compute $\\,\\eta\\,$. Express your final answer as a row matrix using the LaTeX `pmatrix` format. No rounding is required, and no units should be included in your final numeric expression.", "solution": "The appropriate starting point is the set of linearized acoustic equations for small perturbations in a homogeneous, inviscid fluid: the linearized momentum balance, the linearized mass conservation, and a linear equation of state. Let $\\,\\mathbf{u}(\\mathbf{x},t)\\,$ denote particle velocity, $\\,p(\\mathbf{x},t)\\,$ pressure, and $\\,\\rho\\,$ the constant background density. The linearized momentum balance (Newton's Second Law in continuum form) is\n$$\n\\rho\\,\\frac{\\partial \\mathbf{u}}{\\partial t} = -\\,\\nabla p,\n$$\nand the linearized mass conservation (continuity) is\n$$\n\\frac{\\partial \\rho'}{\\partial t} + \\rho\\,\\nabla\\cdot \\mathbf{u} = s_\\rho,\n$$\nwhere $\\,\\rho'(\\mathbf{x},t)\\,$ is the density perturbation and $\\,s_\\rho\\,$ a source term representing mass injection rate density (for dimensional analysis it suffices to recognize that sources carry the dimensions needed to balance the equations). The linear equation of state for small perturbations is\n$$\np' = c^{2}\\,\\rho',\n$$\nwhere $\\,p'(\\mathbf{x},t)\\,$ is the pressure perturbation and $\\,c(\\mathbf{x})\\,$ is the wavespeed, which in a homogeneous fluid satisfies $\\,c^{2} = K/\\rho\\,$ with $\\,K\\,$ the bulk modulus. Eliminating $\\,\\mathbf{u}\\,$ and $\\,\\rho'\\,$ yields the familiar acoustic wave equation for pressure,\n$$\n\\nabla^{2} p(\\mathbf{x},t) - \\frac{1}{c^{2}}\\,\\frac{\\partial^{2} p(\\mathbf{x},t)}{\\partial t^{2}} = s(\\mathbf{x},t),\n$$\nwith a source term $\\,s(\\mathbf{x},t)\\,$ whose dimensions are determined by the requirement that both sides of the equation be consistent.\n\nUnder harmonic time dependence $p(\\mathbf{x},t) = \\Re\\{p(\\mathbf{x};\\omega)\\exp(-\\mathrm{i}\\omega t)\\}$, the second time derivative contributes a factor $(-\\omega^{2})$, leading to the frequency-domain Helmholtz equation\n$$\n\\nabla^{2} p(\\mathbf{x};\\omega) + \\omega^{2}\\,c^{-2}(\\mathbf{x})\\,p(\\mathbf{x};\\omega) = f(\\mathbf{x};\\omega),\n$$\nwhich we write in terms of the model parameter $m(\\mathbf{x}) = c^{-2}(\\mathbf{x})$ as\n$$\n\\nabla^{2} p(\\mathbf{x};\\omega) + \\omega^{2}\\,m(\\mathbf{x})\\,p(\\mathbf{x};\\omega) \\;=\\; f(\\mathbf{x};\\omega).\n$$\nWe now perform dimensional analysis to verify that $\\,m=c^{-2}\\,$ is consistent and that pressure-valued data are predicted coherently.\n\nFirst, we list the base dimensions:\n- Pressure has dimension $[p] = M\\,L^{-1}\\,T^{-2}$.\n- Angular frequency has dimension $[\\omega] = T^{-1}$.\n- Wavespeed has dimension $[c] = L\\,T^{-1}$, hence $[c^{-2}] = T^{2}\\,L^{-2}$.\n- The Laplacian contributes $[\\nabla^{2}] = L^{-2}$, so $[\\nabla^{2} p] = [p]\\,L^{-2} = M\\,L^{-3}\\,T^{-2}$.\n\nNext, compute the dimension of the mass term $\\,\\omega^{2} m p\\,$ when $\\,m=c^{-2}\\,$:\n$$\n[\\omega^{2} m p] = [\\omega]^{2}\\,[m]\\,[p] = T^{-2} \\cdot T^{2} L^{-2} \\cdot M\\,L^{-1}\\,T^{-2}\n= M\\,L^{-3}\\,T^{-2}.\n$$\nTherefore,\n$$\n\\chi = \\frac{[\\omega^{2} m p]}{[\\nabla^{2} p]} \n= \\frac{M\\,L^{-3}\\,T^{-2}}{M\\,L^{-3}\\,T^{-2}} = 1,\n$$\nwhich verifies the consistency of $\\,m=c^{-2}\\,$ in the Helmholtz forward problem.\n\nFinally, the source term $\\,f(\\mathbf{x};\\omega)\\,$ must carry the same dimensions as the left-hand side to ensure the equation balances and that the predicted field $\\,p(\\mathbf{x};\\omega)\\,$ is physically meaningful in pressure units at receivers. Hence\n$$\n[f] = [\\nabla^{2} p] = M\\,L^{-3}\\,T^{-2},\n$$\nand thus\n$$\n\\eta = \\frac{[f]}{[\\nabla^{2} p]} = 1.\n$$\nThis shows that the model parameterization $\\,m=c^{-2}\\,$ is dimensionally consistent with the Helmholtz operator, and that pressure-valued data are predicted coherently provided the source term has the same dimension as $\\,\\nabla^{2} p\\,$, which is the standard requirement in the forward problem.", "answer": "$$\\boxed{\\begin{pmatrix} 1  1 \\end{pmatrix}}$$", "id": "3616698"}, {"introduction": "Moving from a continuous differential equation to a computer simulation is a core skill in computational geophysics. This practice guides you through the process of discretizing the 1D acoustic wave equation using finite differences to build an explicit forward modeling engine. Furthermore, you will explore the crucial concept of model sensitivity by deriving and numerically verifying Fréchet derivatives [@problem_id:3616640], providing quantitative insight into how different parameterizations, such as wave speed $c$ versus its logarithm $\\ln(c)$, affect the forward problem's output.", "problem": "Consider the $1$-dimensional acoustic wave equation $u_{tt}(x,t) = c^2(x)\\,u_{xx}(x,t) + s(x,t)$ on the spatial interval $[0,L]$ with homogeneous Dirichlet boundary conditions $u(0,t)=u(L,t)=0$ and initial conditions $u(x,0)=0$ and $u_t(x,0)=0$. Here $u(x,t)$ is the displacement field, $c(x)$ is the spatially varying wave speed, and $s(x,t)$ is a prescribed source term. All quantities are non-dimensionalized, and trigonometric functions use radians.\n\nTask A (discretization): Starting from the central finite difference definitions for the second time derivative and the second spatial derivative, derive the explicit leapfrog-type update for the interior grid points that advances $u^n$ to $u^{n+1}$ in time, where the spatial grid uses $N$ uniformly spaced points $x_i = i\\,\\Delta x$ for $i=0,1,\\dots,N-1$ with $\\Delta x = L/(N-1)$, the time grid uses time step $\\Delta t$, and $u_i^n \\approx u(x_i, n\\,\\Delta t)$. Enforce the boundary conditions $u_0^n = u_{N-1}^n = 0$ for all $n$. Clearly identify the discrete operator that approximates $u_{xx}$ and specify precisely how the model parameterization $c(x)$ enters the discrete operator for the equation $u_{tt}=c^2(x)\\,u_{xx}+s(x,t)$.\n\nTask B (model parameterization and sensitivity): Let $S$ denote the discrete second spatial derivative operator (the standard centered second-order finite difference stencil) applied to a grid function, and let $C(c)$ denote the diagonal operator with diagonal entries $c_i^2$. Consider the one-step explicit update mapping $F(c): u^n \\mapsto u^{n+1}$ at fixed $u^{n}$ and $u^{n-1}$ and fixed $s^n = s(\\cdot, n\\,\\Delta t)$. Using the chain rule, derive the Fréchet derivative of $F$ with respect to the model parameterization in two cases: (i) directly parameterizing by $c$ (so the model vector is $p=c$), and (ii) parameterizing by $m=\\log c$ (so $c_i=\\exp(m_i)$). Express the directional derivatives $\\partial u^{n+1}/\\partial c_j$ and $\\partial u^{n+1}/\\partial m_j$ for a single grid index $j$ in terms of $u^n$, $S u^n$, and $c_j$.\n\nNumerical experiment and test suite: Implement the derived scheme and sensitivities to verify the analytic Fréchet derivatives against finite differences. Use the following parameter values and procedures.\n\n- Spatial domain length: $L = 1$.\n- Number of grid points: $N = 201$.\n- Spatial step: $\\Delta x = L/(N-1)$.\n- Heterogeneous wave speed: $c(x) = c_0 \\left(1 + a \\sin\\!\\left(2\\pi x/L\\right)\\right)$ with $c_0=1$ and $a=0.2$. Evaluate $c_i = c(x_i)$ for each grid node.\n- Time step: choose $\\Delta t = 0.9\\,\\Delta x / \\max_i c_i$ to satisfy the Courant–Friedrichs–Lewy (CFL) stability condition conservatively for the explicit scheme.\n- Source: a point Ricker wavelet at grid index $i_s = \\lfloor 0.3\\,(N-1)\\rfloor$, i.e., $s_i^n = r(n\\,\\Delta t)$ if $i=i_s$ and $s_i^n = 0$ otherwise, with $r(t) = \\left(1 - 2(\\pi f_0 (t-t_0))^2\\right)\\exp\\!\\left(-(\\pi f_0 (t-t_0))^2\\right)$, center frequency $f_0=5$, and time shift $t_0 = 3/f_0$.\n- Time stepping: advance the solution from $t=0$ to $t = K\\,\\Delta t$ with $K=100$ steps using the explicit update derived in Task A. This produces a pair $(u^{K-1}, u^K)$ for use in the sensitivity check at the next step.\n- At time index $n=K$, form the one-step update $u^{K+1}$ using $u^K$, $u^{K-1}$, $c$, and $s^K$, and compute the analytic Fréchet derivative vectors with respect to the model at the specified indices using your result from Task B.\n- Finite-difference verification: for a small perturbation $\\varepsilon = 10^{-6}$, construct finite-difference approximations of the sensitivity by perturbing the model at a single index and recomputing the one-step update $u^{K+1}$ with all else fixed.\n\nDefine the following three test cases to assess different facets of the implementation.\n\n- Test case $1$ (interior point, direct $c$-parameterization): index $j_1 = \\lfloor N/2 \\rfloor$. Compute the relative $2$-norm error between the analytic derivative vector $\\partial u^{K+1}/\\partial c_{j_1}$ and the finite-difference approximation based on perturbing only $c_{j_1}$ by $+\\varepsilon$.\n- Test case $2$ (boundary-adjacent point, direct $c$-parameterization): index $j_2 = 1$ (the first interior node next to the boundary). Compute the relative $2$-norm error as in test case $1$ but for $j_2$.\n- Test case $3$ (interior point, logarithmic parameterization $m=\\log c$): index $j_3 = \\lfloor N/3 \\rfloor$. Compute the relative $2$-norm error between the analytic derivative vector $\\partial u^{K+1}/\\partial m_{j_3}$ and the finite-difference approximation based on perturbing only $m_{j_3}$ by $+\\varepsilon$ and mapping back via $c_i=\\exp(m_i)$.\n\nAll computations are in non-dimensional units. Angles in the sine and Ricker functions use radians.\n\nOutput specification: Your program should produce a single line of output containing the three relative errors for the three test cases as a comma-separated list enclosed in square brackets, in the order $[\\text{error}_1,\\text{error}_2,\\text{error}_3]$. Each entry must be a floating-point number.", "solution": "The problem requires the derivation and validation of a numerical scheme for the $1$-dimensional acoustic wave equation, along with its sensitivity with respect to model parameters. The validation proceeds in two stages: theoretical derivation followed by numerical implementation and verification.\n\n### Problem Validation\nThe problem statement is parsed and validated against the specified criteria.\n\n**Givens:**\n-   **PDE**: $u_{tt}(x,t) = c^2(x)\\,u_{xx}(x,t) + s(x,t)$ on $x \\in [0,L]$.\n-   **Boundary Conditions**: $u(0,t)=u(L,t)=0$ (homogeneous Dirichlet).\n-   **Initial Conditions**: $u(x,0)=0, u_t(x,0)=0$.\n-   **Discretization**: Finite differences on a uniform grid $x_i=i\\,\\Delta x$, $i=0,\\dots,N-1$, with $\\Delta x=L/(N-1)$. Time step $\\Delta t$.\n-   **Numerical Parameters**: $L=1$, $N=201$, $K=100$.\n-   **Wave Speed**: $c(x) = c_0 (1 + a \\sin(2\\pi x/L))$ with $c_0=1, a=0.2$.\n-   **Time Step**: $\\Delta t = 0.9\\,\\Delta x / \\max_i c_i$.\n-   **Source**: Ricker wavelet $r(t) = (1 - 2(\\pi f_0 (t-t_0))^2)\\exp(-(\\pi f_0 (t-t_0))^2)$ with $f_0=5, t_0=3/f_0$, applied at $x_{i_s}$ where $i_s = \\lfloor 0.3(N-1)\\rfloor$.\n-   **Sensitivity Analysis**: At time step $n=K$, check analytic Fréchet derivatives against finite-difference approximations for a perturbation $\\varepsilon=10^{-6}$.\n-   **Test Cases**: Relative $L_2$-norm errors for: (1) $\\partial u^{K+1}/\\partial c_j$ at $j = \\lfloor N/2 \\rfloor$; (2) $\\partial u^{K+1}/\\partial c_j$ at $j = 1$; (3) $\\partial u^{K+1}/\\partial m_j$ (where $m=\\log c$) at $j = \\lfloor N/3 \\rfloor$.\n\n**Verdict:**\nThe problem is **valid**. It is a well-posed, scientifically grounded problem from computational geophysics. The physical model, numerical methods, and validation procedures are standard and clearly specified. All required parameters and conditions are provided, and there are no contradictions or ambiguities.\n\n### Task A: Discretization\n\nThe $1$-dimensional acoustic wave equation is given by\n$$ u_{tt}(x,t) = c^2(x)\\,u_{xx}(x,t) + s(x,t) $$\nWe discretize this equation on a grid with spatial points $x_i = i\\,\\Delta x$ and time points $t_n = n\\,\\Delta t$. The displacement field is approximated as $u_i^n \\approx u(x_i, t_n)$.\n\nThe second time derivative $u_{tt}$ is approximated using a second-order centered finite difference at time $t_n$:\n$$ u_{tt}(x_i, t_n) \\approx \\frac{u_i^{n+1} - 2u_i^n + u_i^{n-1}}{(\\Delta t)^2} $$\nThe second spatial derivative $u_{xx}$ is approximated using a second-order centered finite difference at position $x_i$:\n$$ u_{xx}(x_i, t_n) \\approx \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{(\\Delta x)^2} $$\nThis defines the action of the discrete spatial derivative operator, denoted $S$, on the grid function $u^n$:\n$$ (S u^n)_i = \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{(\\Delta x)^2} $$\nSubstituting these approximations into the PDE, we get the discrete equation for each interior grid point $i \\in \\{1, \\dots, N-2\\}$:\n$$ \\frac{u_i^{n+1} - 2u_i^n + u_i^{n-1}}{(\\Delta t)^2} = c(x_i)^2 (S u^n)_i + s(x_i, t_n) $$\nLetting $c_i=c(x_i)$ and $s_i^n=s(x_i,t_n)$, we can rearrange this to solve for $u_i^{n+1}$, yielding the explicit leapfrog-type update rule:\n$$ u_i^{n+1} = 2u_i^n - u_i^{n-1} + (\\Delta t)^2 \\left( c_i^2 (S u^n)_i + s_i^n \\right) $$\nThe homogeneous Dirichlet boundary conditions $u(0,t)=u(L,t)=0$ are enforced by setting $u_0^n=0$ and $u_{N-1}^n=0$ for all time steps $n$. These conditions are naturally incorporated into the computation of $(S u^n)_i$ at points adjacent to the boundary (e.g., for $i=1$, $u_0^n$ is used).\n\nThe model parameterization $c(x)$ enters the discrete system after being evaluated at each grid point $x_i$ to form the vector of velocities $c_i$. In the update equation, the squared velocity $c_i^2$ acts as a scalar multiplier on the corresponding component of the discrete spatial Laplacian vector, $(S u^n)_i$. In matrix-vector notation, if we consider vectors of the interior grid points, the term is $(\\Delta t)^2 C (S u^n)$, where $C$ is a diagonal matrix with entries $c_i^2$.\n\n### Task B: Model Parameterization and Sensitivity\n\nThe one-step update map $F$ takes the state $(u^n, u^{n-1})$ to $u^{n+1}$ and depends on the model parameters (the velocity vector $c$). For a fixed state and source, we analyze the sensitivity of the next state $u^{n+1}$ to perturbations in the model. The update for the $i$-th component of the solution vector is:\n$$ u_i^{n+1} = F_i(c; u^n, u^{n-1}, s^n) = 2u_i^n - u_i^{n-1} + (\\Delta t)^2 c_i^2 (S u^n)_i + (\\Delta t)^2 s_i^n $$\nThe terms $u^n$, $u^{n-1}$, and $s^n$ are held constant. The Fréchet derivative of the vector $u^{n+1}$ with respect to a single model parameter is a vector whose components are the partial derivatives of each $u_i^{n+1}$ with respect to that parameter.\n\n**(i) Direct parameterization, $p=c$:**\nWe seek the derivative of the vector $u^{n+1}$ with respect to the parameter $c_j$. The $i$-th component of this derivative vector is $\\partial u_i^{n+1} / \\partial c_j$.\n$$ \\frac{\\partial u_i^{n+1}}{\\partial c_j} = \\frac{\\partial}{\\partial c_j} \\left[ 2u_i^n - u_i^{n-1} + (\\Delta t)^2 c_i^2 (S u^n)_i + (\\Delta t)^2 s_i^n \\right] $$\nOnly the term involving $c_i^2$ depends on the model. Using the properties of partial derivatives:\n$$ \\frac{\\partial u_i^{n+1}}{\\partial c_j} = (\\Delta t)^2 (S u^n)_i \\frac{\\partial (c_i^2)}{\\partial c_j} = (\\Delta t)^2 (S u^n)_i \\cdot (2 c_i \\delta_{ij}) $$\nwhere $\\delta_{ij}$ is the Kronecker delta. This shows that the vector $\\partial u^{n+1}/\\partial c_j$ is zero everywhere except at index $i=j$. The non-zero component is:\n$$ \\left(\\frac{\\partial u^{n+1}}{\\partial c_j}\\right)_j = 2 (\\Delta t)^2 c_j (S u^n)_j $$\n\n**(ii) Logarithmic parameterization, $m=\\log c$ (i.e., $c_i=\\exp(m_i)$):**\nWe seek the derivative of $u^{n+1}$ with respect to the parameter $m_j$. Using the chain rule:\n$$ \\frac{\\partial u_i^{n+1}}{\\partial m_j} = \\frac{\\partial}{\\partial m_j} \\left[ (\\Delta t)^2 c_i^2 (S u^n)_i \\right] = (\\Delta t)^2 (S u^n)_i \\frac{\\partial (c_i^2)}{\\partial m_j} $$\nWe evaluate the derivative of $c_i^2$ with respect to $m_j$:\n$$ \\frac{\\partial (c_i^2)}{\\partial m_j} = 2 c_i \\frac{\\partial c_i}{\\partial m_j} = 2 c_i \\frac{\\partial (\\exp(m_i))}{\\partial m_j} = 2 c_i (\\exp(m_i) \\delta_{ij}) = 2 c_i^2 \\delta_{ij} $$\nSubstituting this back, we find that the derivative vector $\\partial u^{n+1}/\\partial m_j$ is again non-zero only at index $i=j$. The non-zero component is:\n$$ \\left(\\frac{\\partial u^{n+1}}{\\partial m_j}\\right)_j = 2 (\\Delta t)^2 c_j^2 (S u^n)_j $$\nThese analytic expressions are used for verification against finite-difference approximations in the numerical experiment.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the full numerical experiment to derive and verify sensitivities\n    for the 1D acoustic wave equation.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Parameter set 1): Handled by j1\n        # (Parameter set 2): Handled by j2\n        # (Parameter set 3): Handled by j3\n    ]\n\n    # --- Setup Constants and Grid ---\n    L = 1.0\n    N = 201\n    K = 100\n    epsilon = 1e-6\n    c0 = 1.0\n    a = 0.2\n    f0 = 5.0\n    t0 = 3.0 / f0\n\n    # Grid setup\n    dx = L / (N - 1)\n    x = np.linspace(0, L, N)\n    \n    # --- Define Model and Source ---\n    # Model parameterization (heterogeneous wave speed)\n    c = c0 * (1.0 + a * np.sin(2.0 * np.pi * x / L))\n    \n    # Time step from CFL condition\n    dt = 0.9 * dx / np.max(c)\n\n    # Source setup\n    # Note: problem statement floor can be achieved with integer division //\n    i_s = (3 * (N - 1)) // 10\n    \n    def ricker(t, f0, t0):\n        # Ricker wavelet function\n        arg = (np.pi * f0 * (t - t0))**2\n        return (1.0 - 2.0 * arg) * np.exp(-arg)\n\n    # Source time function\n    time_vec = np.arange(K + 1) * dt\n    stf = ricker(time_vec, f0, t0)\n    \n    # --- Implement Forward Simulation ---\n    # Initialize wavefields\n    u_past = np.zeros(N)  # u^{n-1}\n    u_now = np.zeros(N)   # u^n\n    \n    # Special first time step (n=0) based on u_t(x,0)=0\n    # u^1 = 0.5 * dt^2 * s^0\n    s0 = np.zeros(N)\n    s0[i_s] = stf[0]\n    u_now = 0.5 * dt**2 * s0  # u_now is now u^1\n    # u_past remains u^0 = 0\n    \n    # Main time-stepping loop for n from 1 to K-1\n    for n in range(1, K):\n        S_u_now = np.zeros(N)\n        S_u_now[1:-1] = (u_now[2:] - 2.0 * u_now[1:-1] + u_now[:-2]) / dx**2\n        \n        u_fut = np.zeros(N)\n        u_fut[1:-1] = 2.0 * u_now[1:-1] - u_past[1:-1] + dt**2 * c[1:-1]**2 * S_u_now[1:-1]\n        \n        u_fut[i_s] += dt**2 * stf[n]\n\n        u_past, u_now = u_now, u_fut\n\n    # State for sensitivity analysis: u_K = u_now, u_K_minus_1 = u_past\n    u_K = u_now\n    u_K_minus_1 = u_past\n    \n    # --- Sensitivity Analysis at n=K ---\n    def one_step_update(u_n, u_n_minus_1, c_vec, s_n_scalar):\n        u_n_plus_1 = np.zeros_like(u_n)\n        S_u_n = np.zeros_like(u_n)\n        S_u_n[1:-1] = (u_n[2:] - 2.0 * u_n[1:-1] + u_n[:-2]) / dx**2\n        \n        u_n_plus_1[1:-1] = 2.0 * u_n[1:-1] - u_n_minus_1[1:-1] + \\\n                           dt**2 * c_vec[1:-1]**2 * S_u_n[1:-1]\n        \n        u_n_plus_1[i_s] += dt**2 * s_n_scalar\n        return u_n_plus_1\n\n    u_K_plus_1_base = one_step_update(u_K, u_K_minus_1, c, stf[K])\n    \n    S_u_K = np.zeros(N)\n    S_u_K[1:-1] = (u_K[2:] - 2.0 * u_K[1:-1] + u_K[:-2]) / dx**2\n    \n    results = []\n    \n    # --- Test Case 1 ---\n    j1 = N // 2\n    grad_c1_analytic = np.zeros(N)\n    grad_c1_analytic[j1] = 2.0 * dt**2 * c[j1] * S_u_K[j1]\n    \n    c_perturbed = c.copy()\n    c_perturbed[j1] += epsilon\n    u_K_plus_1_pert_c1 = one_step_update(u_K, u_K_minus_1, c_perturbed, stf[K])\n    grad_c1_fd = (u_K_plus_1_pert_c1 - u_K_plus_1_base) / epsilon\n    \n    norm_analytic_1 = np.linalg.norm(grad_c1_analytic)\n    if norm_analytic_1  1e-15:\n        error1 = 0.0 if np.linalg.norm(grad_c1_fd)  1e-15 else float('inf')\n    else:\n        error1 = np.linalg.norm(grad_c1_analytic - grad_c1_fd) / norm_analytic_1\n    results.append(error1)\n    \n    # --- Test Case 2 ---\n    j2 = 1\n    grad_c2_analytic = np.zeros(N)\n    grad_c2_analytic[j2] = 2.0 * dt**2 * c[j2] * S_u_K[j2]\n    \n    c_perturbed = c.copy()\n    c_perturbed[j2] += epsilon\n    u_K_plus_1_pert_c2 = one_step_update(u_K, u_K_minus_1, c_perturbed, stf[K])\n    grad_c2_fd = (u_K_plus_1_pert_c2 - u_K_plus_1_base) / epsilon\n    \n    norm_analytic_2 = np.linalg.norm(grad_c2_analytic)\n    if norm_analytic_2  1e-15:\n        error2 = 0.0 if np.linalg.norm(grad_c2_fd)  1e-15 else float('inf')\n    else:\n        error2 = np.linalg.norm(grad_c2_analytic - grad_c2_fd) / norm_analytic_2\n    results.append(error2)\n    \n    # --- Test Case 3 ---\n    j3 = N // 3\n    m = np.log(c)\n    grad_m3_analytic = np.zeros(N)\n    grad_m3_analytic[j3] = 2.0 * dt**2 * c[j3]**2 * S_u_K[j3]\n    \n    m_perturbed = m.copy()\n    m_perturbed[j3] += epsilon\n    c_from_m_perturbed = np.exp(m_perturbed)\n    u_K_plus_1_pert_m3 = one_step_update(u_K, u_K_minus_1, c_from_m_perturbed, stf[K])\n    grad_m3_fd = (u_K_plus_1_pert_m3 - u_K_plus_1_base) / epsilon\n\n    norm_analytic_3 = np.linalg.norm(grad_m3_analytic)\n    if norm_analytic_3  1e-15:\n        error3 = 0.0 if np.linalg.norm(grad_m3_fd)  1e-15 else float('inf')\n    else:\n        error3 = np.linalg.norm(grad_m3_analytic - grad_m3_fd) / norm_analytic_3\n    results.append(error3)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3616640"}, {"introduction": "For inverse problems involving a large number of model parameters, calculating the gradient of the misfit functional efficiently is paramount. This exercise introduces the powerful adjoint-state method, the computational workhorse of large-scale inversion. By deriving the adjoint formulation for an elliptic PDE from first principles and implementing it [@problem_id:3616704], you will learn how to compute the action of the adjoint Jacobian on a data residual vector, $J^T r$, without ever explicitly forming the Jacobian matrix $J$, a technique that dramatically reduces computational cost.", "problem": "Consider the scalar elliptic partial differential equation (PDE) $\\,\\nabla\\cdot(\\sigma\\nabla\\phi)=q\\,$ on the unit square domain $\\Omega=[0,1]^2$ with homogeneous Dirichlet boundary conditions $\\,\\phi=0\\,$ on $\\partial\\Omega$. The unknown field is the potential $\\,\\phi(x,y)\\,$, the model parameter is the conductivity $\\,\\sigma(x,y)0\\,$, and $\\,q(x,y)\\,$ is a prescribed source distribution. Measurements are given by a linear operator $\\,P\\,$ acting on $\\,\\phi\\,$ to produce $\\,d=P\\phi\\,$. Let $\\,r\\,$ denote the data residual vector. The forward problem and model parameterization are posed in the following terms:\n\n- The forward operator maps $\\,\\sigma\\,$ to data $\\,d=P\\phi\\,$, where $\\,\\phi\\,$ solves $\\,\\nabla\\cdot(\\sigma\\nabla\\phi)=q\\,$ with $\\,\\phi=0\\,$ on $\\,\\partial\\Omega$.\n- The Jacobian $\\,J\\,$ is the Fréchet derivative of the data mapping with respect to the parameter $\\,\\sigma\\,$, and $\\,J^T r\\,$ denotes the adjoint action on the data residual $\\,r\\,$.\n- You must compute $\\,J^T r\\,$ using the adjoint-state method without resorting to any shortcut formulas. Start from the weak form of the PDE and first principles of the calculus of variations and linear operators, and derive an algorithm to evaluate the action $\\,\\delta\\sigma\\mapsto r^T P\\,\\delta\\phi\\,$ as an $\\,L^2(\\Omega)\\,$ inner product between $\\,J^T r\\,$ and a perturbation $\\,\\delta\\sigma$.\n\nYou will discretize $\\,\\Omega\\,$ using a uniform Cartesian grid of $\\,N\\times N\\,$ points with spacing $\\,h=\\frac{1}{N-1}\\,$ in both directions, enforce $\\,\\phi=0\\,$ on the boundary points, and assemble a symmetric positive definite linear system representing the discrete operator associated with $\\,\\nabla\\cdot(\\sigma\\nabla\\phi)\\,$ using face-centered arithmetic averaging of $\\,\\sigma\\,$. You will implement the following computational tasks:\n\n1. Solve the forward problem to obtain $\\,\\phi\\,$.\n2. Construct the adjoint source from the data residual $\\,r\\,$ in a way consistent with the measurement operator $\\,P\\,$, and solve the adjoint problem to obtain the adjoint field $\\,\\lambda\\,$.\n3. Compute a discrete approximation of the field $\\,J^T r\\,$ over the grid from first principles.\n4. Verify, for a given perturbation $\\,\\delta\\sigma\\,$, that the linearized response identity holds numerically by comparing the scalar quantities $\\,r^T P\\,\\delta\\phi\\,$ and the domain integral $\\,\\int_\\Omega (J^T r)\\,\\delta\\sigma\\,\\mathrm{d}x\\,\\mathrm{d}y\\,$, where $\\,\\delta\\phi\\,$ solves the linearized forward equation induced by $\\,\\delta\\sigma\\,$. Report the absolute mismatch as a floating-point number.\n\nYou must explain how the adjoint sources are constructed from the data residuals $\\,r\\,$, for general linear measurement operators $\\,P\\,$ and for the special case when $\\,P\\,$ samples $\\,\\phi\\,$ at grid points.\n\nYour program must implement the above and produce a single line of output containing the absolute mismatches for the test suite described below as a comma-separated list enclosed in square brackets. Each mismatch must be a floating-point number.\n\nUse the following test suite. All quantities are dimensionless.\n\n- Test Case 1 (baseline, constant conductivity, residual tied to forward data):\n  - Grid size: $\\,N=32$.\n  - Conductivity: $\\,\\sigma(x,y)=1$ everywhere.\n  - Source: a unit point source at the central grid point, i.e., set $\\,q_{i_0,j_0}=1\\,$ with $\\,i_0=j_0=\\lfloor N/2\\rfloor\\,$ and zero elsewhere.\n  - Measurements: $\\,P\\,$ samples $\\,\\phi\\,$ at three interior points with indices $\\,[(\\lfloor N/4\\rfloor,\\lfloor N/4\\rfloor),(\\lfloor N/2\\rfloor,\\lfloor N/3\\rfloor),(\\lfloor 3N/4\\rfloor,\\lfloor 3N/4\\rfloor)]$.\n  - Residual: set $\\,d_{\\text{obs}}=0\\,$ and $\\,r=d_{\\text{obs}}-P\\phi\\,$.\n  - Perturbation: $\\,\\delta\\sigma\\,$ is a small zero-mean random field drawn from a uniform distribution on $\\,[-0.1,0.1]\\,$, with a fixed random seed for reproducibility.\n\n- Test Case 2 (heterogeneous conductivity, prescribed residual):\n  - Grid size: $\\,N=40$.\n  - Conductivity: $\\,\\sigma(x,y)=1+0.5\\sin(2\\pi x)\\sin(2\\pi y)$ evaluated at grid points.\n  - Source: a unit point source at indices $\\,(\\lfloor N/3\\rfloor,\\lfloor N/2\\rfloor)$.\n  - Measurements: $\\,P\\,$ samples $\\,\\phi\\,$ at five interior points with indices $\\,[(\\lfloor N/5\\rfloor,\\lfloor N/5\\rfloor),(\\lfloor 2N/5\\rfloor,\\lfloor 3N/7\\rfloor),(\\lfloor N/2\\rfloor,\\lfloor 2N/3\\rfloor),(\\lfloor 3N/5\\rfloor,\\lfloor 2N/5\\rfloor),(\\lfloor 4N/5\\rfloor,\\lfloor 4N/5\\rfloor)]$.\n  - Residual: $\\,r=[1,-0.5,0.25,-0.25,0.1]^T$.\n  - Perturbation: $\\,\\delta\\sigma\\,$ is a small zero-mean random field drawn from a uniform distribution on $\\,[-0.05,0.05]\\,$, with a fixed random seed for reproducibility.\n\n- Test Case 3 (edge case, zero forward field):\n  - Grid size: $\\,N=24$.\n  - Conductivity: $\\,\\sigma(x,y)=1$ everywhere.\n  - Source: $\\,q=0\\,$ everywhere.\n  - Measurements: a single boundary point at indices $\\, (0,\\lfloor N/2\\rfloor)$.\n  - Residual: $\\,r=[1]^T$.\n  - Perturbation: $\\,\\delta\\sigma\\,$ is a small zero-mean random field drawn from a uniform distribution on $\\,[-0.02,0.02]\\,$, with a fixed random seed for reproducibility.\n\nYour program should produce a single line of output containing the absolute mismatches for the three test cases as a comma-separated list enclosed in square brackets, for example, $\\,[m_1,m_2,m_3]\\,$ where $\\,m_k\\,$ is the mismatch for the $\\,k$-th test case.", "solution": "The problem requires the derivation and implementation of the adjoint-state method to compute the quantity $J^T r$, representing the action of the adjoint of the data sensitivity Jacobian on the data residual vector. The physical model is governed by the scalar elliptic PDE $\\nabla\\cdot(\\sigma\\nabla\\phi)=q$ on the unit square $\\Omega=[0,1]^2$ with homogeneous Dirichlet boundary conditions $\\phi=0$ on $\\partial\\Omega$. We must derive the algorithm from first principles and verify it numerically.\n\nThe core of the method is to find an explicit expression for the field $G = J^T r$ that satisfies the defining relation of the adjoint operator:\n$$\n\\langle r, J \\delta\\sigma \\rangle_{\\text{data}} = \\langle J^T r, \\delta\\sigma \\rangle_{L^2(\\Omega)}\n$$\nwhere $\\delta\\sigma$ is a perturbation in the model parameter (conductivity $\\sigma$), and $J\\delta\\sigma$ is the resulting change in the predicted data. The predicted data $d=P\\phi$ is obtained via a linear measurement operator $P$ acting on the potential field $\\phi$. The change in data is thus $J\\delta\\sigma = P\\delta\\phi$, where $\\delta\\phi$ is the change in the potential. The identity to verify becomes $r^T(P\\delta\\phi) = \\int_\\Omega (J^T r)\\delta\\sigma \\, d\\Omega$.\n\nOur derivation proceeds in three steps:\n1.  **Linearized Forward Equation**: We start from the weak form of the PDE, $\\int_\\Omega \\sigma \\nabla\\phi \\cdot \\nabla v \\, d\\Omega = -\\int_\\Omega q v \\, d\\Omega$ for all suitable test functions $v$. By linearizing this with respect to a perturbation $\\delta\\sigma$, we find the equation governing the corresponding potential perturbation $\\delta\\phi$:\n    $$\n    \\int_\\Omega \\sigma \\nabla\\delta\\phi \\cdot \\nabla v \\, d\\Omega = -\\int_\\Omega \\delta\\sigma \\nabla\\phi \\cdot \\nabla v \\, d\\Omega\n    $$\n2.  **Adjoint Equation**: We introduce an adjoint field $\\lambda$ to relate the term $r^T P\\delta\\phi$ back to the linearized equation. The term $r^T P\\delta\\phi$ can be written as an inner product in the function space, $\\langle P^T r, \\delta\\phi \\rangle = \\int_\\Omega (P^T r) \\delta\\phi \\, d\\Omega$. We define the adjoint field $\\lambda$ as the solution to the adjoint PDE, $\\nabla \\cdot (\\sigma \\nabla \\lambda) = P^T r$, with $\\lambda=0$ on $\\partial\\Omega$. As the differential operator is self-adjoint, this equation has the same form as the forward PDE. Its weak form is $\\int_\\Omega \\sigma \\nabla\\lambda \\cdot \\nabla w \\, d\\Omega = -\\int_\\Omega (P^T r) w \\, d\\Omega$. Choosing the test function $w = \\delta\\phi$, we get:\n    $$\n    -\\int_\\Omega (P^T r) \\delta\\phi \\, d\\Omega = -r^T P\\delta\\phi = \\int_\\Omega \\sigma \\nabla\\lambda \\cdot \\nabla \\delta\\phi \\, d\\Omega\n    $$\n3.  **Identification of $J^T r$**: By choosing the test function $v = \\lambda$ in the linearized forward equation, we get $\\int_\\Omega \\sigma \\nabla\\delta\\phi \\cdot \\nabla \\lambda \\, d\\Omega = -\\int_\\Omega \\delta\\sigma \\nabla\\phi \\cdot \\nabla \\lambda \\, d\\Omega$. The left-hand side is identical to the right-hand side of the adjoint relation derived above. Equating the remaining terms gives:\n    $$\n    -r^T P\\delta\\phi = -\\int_\\Omega (\\nabla\\phi \\cdot \\nabla \\lambda) \\delta\\sigma \\, d\\Omega\n    $$\n    This simplifies to $r^T P\\delta\\phi = \\int_\\Omega (\\nabla\\phi \\cdot \\nabla \\lambda) \\delta\\sigma \\, d\\Omega$. Comparing this with the definition of the adjoint action, we identify the explicit expression for the sought-after field:\n    $$\n    J^T r = \\nabla\\phi \\cdot \\nabla\\lambda\n    $$\nFor point-wise measurements, the adjoint source $P^T r$ becomes a sum of Dirac delta distributions located at the measurement points, weighted by the corresponding residual values. In the discrete setting, this means placing the residual values at the respective grid nodes.\n\nThe following program implements this adjoint-state method. It numerically solves the forward problem for $\\phi$, the adjoint problem for $\\lambda$, and computes $J^T r$ as the dot product of their gradients. It then explicitly calculates both sides of the identity $r^T P\\delta\\phi = \\int (J^T r) \\delta\\sigma \\,d\\Omega$ and reports their absolute difference to verify the correctness of the derivation and implementation. The discretization employs a five-point finite difference scheme on the interior nodes of the grid, resulting in a sparse, symmetric, positive-definite linear system that is solved efficiently.", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csr_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n\n    def solve_case(N, sigma_func, q_loc, meas_loc_indices, r_val, delta_sigma_dist, seed):\n        \"\"\"\n        Solves a single test case for the adjoint verification problem.\n        \"\"\"\n        h = 1.0 / (N - 1)\n        x = np.linspace(0, 1, N)\n        y = np.linspace(0, 1, N)\n        xx, yy = np.meshgrid(x, y)\n\n        sigma = sigma_func(xx, yy)\n        q_grid = np.zeros((N, N))\n        if q_loc:\n            q_grid[q_loc] = 1.0\n\n        meas_loc_indices = np.array(meas_loc_indices)\n        meas_rows, meas_cols = meas_loc_indices[:, 0], meas_loc_indices[:, 1]\n\n        np.random.seed(seed)\n        delta_sigma = np.random.uniform(delta_sigma_dist[0], delta_sigma_dist[1], size=(N, N))\n        delta_sigma -= np.mean(delta_sigma)\n\n        def build_operator(s_field):\n            \"\"\"Builds the discrete operator B for -div(sigma*grad).\"\"\"\n            n_int = N - 2\n            n_dof = n_int * n_int\n            A = lil_matrix((n_dof, n_dof))\n\n            for i_int in range(n_int):\n                for j_int in range(n_int):\n                    k = i_int * n_int + j_int\n                    i, j = i_int + 1, j_int + 1\n\n                    diag_val = 0.0\n\n                    # East neighbor\n                    s_e = 0.5 * (s_field[i, j] + s_field[i, j + 1])\n                    diag_val += s_e\n                    if j_int  n_int - 1:\n                        A[k, k + 1] = -s_e / h**2\n\n                    # West neighbor\n                    s_w = 0.5 * (s_field[i, j] + s_field[i, j - 1])\n                    diag_val += s_w\n                    if j_int > 0:\n                        A[k, k - 1] = -s_w / h**2\n\n                    # North neighbor\n                    s_n = 0.5 * (s_field[i, j] + s_field[i + 1, j])\n                    diag_val += s_n\n                    if i_int  n_int - 1:\n                        A[k, k + n_int] = -s_n / h**2\n\n                    # South neighbor\n                    s_s = 0.5 * (s_field[i, j] + s_field[i - 1, j])\n                    diag_val += s_s\n                    if i_int > 0:\n                        A[k, k - n_int] = -s_s / h**2\n                        \n                    A[k, k] = diag_val / h**2\n            return csr_matrix(A)\n\n        # 1. Solve forward problem for phi: B*phi = -q\n        B_op = build_operator(sigma)\n        q_interior = q_grid[1:-1, 1:-1].flatten()\n        phi_vec = spsolve(B_op, -q_interior)\n        phi = np.zeros((N, N))\n        phi[1:-1, 1:-1] = phi_vec.reshape((N - 2, N - 2))\n\n        # Define residual r\n        if r_val is None:\n            d_calc = phi[meas_rows, meas_cols]\n            d_obs = 0.0\n            r = d_obs - d_calc\n        else:\n            r = np.array(r_val)\n\n        # 2. Solve adjoint problem for lambda: B*lambda = -q_adj\n        q_adj_grid = np.zeros((N, N))\n        for idx, res_val in zip(meas_loc_indices, r):\n            if 1 = idx[0]  N - 1 and 1 = idx[1]  N - 1:\n                q_adj_grid[tuple(idx)] = res_val\n        \n        q_adj_interior = q_adj_grid[1:-1, 1:-1].flatten()\n        lambda_vec = spsolve(B_op, -q_adj_interior)\n        lam = np.zeros((N, N))\n        if q_adj_interior.any(): # Avoid reshaping empty array if all sources are on boundary\n            lam[1:-1, 1:-1] = lambda_vec.reshape((N - 2, N - 2))\n        \n        # 3. Compute J^T r field\n        grad_phi_y, grad_phi_x = np.gradient(phi, h, edge_order=2)\n        grad_lam_y, grad_lam_x = np.gradient(lam, h, edge_order=2)\n        JTr_field = grad_phi_x * grad_lam_x + grad_phi_y * grad_lam_y\n\n        # 4. Verify identity\n        # LHS: r^T P delta_phi\n        # Solve B*delta_phi = -[B(sigma+delta_sigma) - B(sigma)]*phi\n        B_perturbed = build_operator(sigma + delta_sigma)\n        phi_interior_vec = phi[1:-1, 1:-1].flatten()\n        \n        b_lin_vec = - (B_perturbed - B_op) @ phi_interior_vec\n        delta_phi_vec = spsolve(B_op, b_lin_vec)\n        delta_phi = np.zeros((N, N))\n        delta_phi[1:-1, 1:-1] = delta_phi_vec.reshape((N - 2, N - 2))\n        \n        P_delta_phi = delta_phi[meas_rows, meas_cols]\n        lhs = r @ P_delta_phi\n        \n        # RHS: integral of (J^T r) * delta_sigma\n        rhs = np.sum(JTr_field * delta_sigma) * h**2\n        \n        mismatch = np.abs(lhs - rhs)\n        return mismatch\n\n    # Test Case 1\n    N1 = 32\n    case1_params = {\n        'N': N1,\n        'sigma_func': lambda x, y: 1.0 + 0 * x,\n        'q_loc': (N1 // 2, N1 // 2),\n        'meas_loc_indices': [(N1 // 4, N1 // 4), (N1 // 2, N1 // 3), (3 * N1 // 4, 3 * N1 // 4)],\n        'r_val': None,\n        'delta_sigma_dist': (-0.1, 0.1),\n        'seed': 0\n    }\n\n    # Test Case 2\n    N2 = 40\n    case2_params = {\n        'N': N2,\n        'sigma_func': lambda x, y: 1.0 + 0.5 * np.sin(2 * np.pi * x) * np.sin(2 * np.pi * y),\n        'q_loc': (N2 // 3, N2 // 2),\n        'meas_loc_indices': [(N2 // 5, N2 // 5), (2 * N2 // 5, 3 * N2 // 7), (N2 // 2, 2 * N2 // 3), (3 * N2 // 5, 2 * N2 // 5), (4 * N2 // 5, 4 * N2 // 5)],\n        'r_val': [1.0, -0.5, 0.25, -0.25, 0.1],\n        'delta_sigma_dist': (-0.05, 0.05),\n        'seed': 1\n    }\n\n    # Test Case 3\n    N3 = 24\n    case3_params = {\n        'N': N3,\n        'sigma_func': lambda x, y: 1.0 + 0 * x,\n        'q_loc': None,\n        'meas_loc_indices': [(0, N3 // 2)],\n        'r_val': [1.0],\n        'delta_sigma_dist': (-0.02, 0.02),\n        'seed': 2\n    }\n\n    test_cases = [case1_params, case2_params, case3_params]\n    results = []\n    for params in test_cases:\n        mismatch = solve_case(**params)\n        results.append(mismatch)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3616704"}]}