{"hands_on_practices": [{"introduction": "Our journey into the practical aspects of explicit schemes begins not with coding, but with a crucial analytical technique. A finite difference scheme is an approximation, and a fundamental question is to characterize the nature of this approximation. This practice guides you through a modified equation analysis, a powerful method that uses Taylor series expansions to derive the partial differential equation that the numerical scheme implicitly solves, revealing the presence of artificial, non-physical terms that govern the scheme's accuracy and stability [@problem_id:3590501]. Mastering this analysis provides deep insight into phenomena like numerical diffusion and helps explain why a scheme behaves the way it does.", "problem": "Consider $1$-dimensional transient heat conduction in a homogeneous geophysical medium, modeled by the heat equation $u_{t} = \\kappa u_{xx}$, where $u(x,t)$ is temperature and $\\kappa$ is constant thermal diffusivity. Let a uniform spatial grid with spacing $\\Delta x$ and a uniform time step $\\Delta t$ be used to approximate the solution by the explicit Forward Time Centered Space (FTCS) scheme\n$$\nu^{n+1}_{i} = u^{n}_{i} + r \\left(u^{n}_{i+1} - 2 u^{n}_{i} + u^{n}_{i-1}\\right),\n$$\nwhere $r = \\kappa \\Delta t / \\Delta x^{2}$. Starting from the partial differential equation and the definition of the discrete scheme, perform a modified equation analysis by systematically expanding in Taylor series about the continuous solution. Derive the modified differential equation that the scheme solves and identify the leading artificial higher-order spatial term it introduces. Then, provide the analytic expression for the coefficient that multiplies the leading artificial fourth spatial derivative term $u_{xxxx}$ in the modified equation, simplified in terms of $\\kappa$, $\\Delta x$, and $\\Delta t$. Use International System of Units (SI) consistently; if evaluated numerically, the coefficient would have units of $\\mathrm{m}^{4}\\,\\mathrm{s}^{-1}$, but do not include units in the final boxed expression. Finally, briefly interpret how the sign and magnitude of this coefficient influence the effective physical diffusion and the smoothness of the numerical solution in computational geophysics applications such as lithospheric thermal modeling. The final answer must be a single closed-form analytic expression for the coefficient of $u_{xxxx}$.", "solution": "The problem asks for a modified equation analysis of the Forward Time Centered Space (FTCS) scheme for the $1$-dimensional heat equation, the derivation of the coefficient of the leading artificial spatial derivative term, and an interpretation of its effect.\n\nThe governing partial differential equation (PDE) is the heat equation:\n$$\n\\frac{\\partial u}{\\partial t} = \\kappa \\frac{\\partial^2 u}{\\partial x^2}\n$$\nwhere $u(x,t)$ is temperature, $t$ is time, $x$ is the spatial coordinate, and $\\kappa$ is the constant thermal diffusivity.\n\nThe FTCS numerical scheme is given by:\n$$\nu^{n+1}_{i} = u^{n}_{i} + r \\left(u^{n}_{i+1} - 2 u^{n}_{i} + u^{n}_{i-1}\\right)\n$$\nwhere $u^n_i$ represents the numerical approximation of $u(x_i, t_n)$ at grid point $x_i = i\\Delta x$ and time $t_n = n\\Delta t$. The parameter $r$ is defined as $r = \\kappa \\Delta t / \\Delta x^{2}$.\n\nTo perform the modified equation analysis, we substitute Taylor series expansions for each term in the numerical scheme around the point $(x_i, t_n)$. We assume that the numerical solution $u^n_i$ is a sufficiently smooth function that can be represented by these expansions. Let's rewrite the scheme by dividing by $\\Delta t$:\n$$\n\\frac{u^{n+1}_{i} - u^{n}_{i}}{\\Delta t} = \\frac{\\kappa \\Delta t}{\\Delta x^{2}} \\frac{1}{\\Delta t} \\left(u^{n}_{i+1} - 2 u^{n}_{i} + u^{n}_{i-1}\\right) = \\kappa \\frac{u^{n}_{i+1} - 2 u^{n}_{i} + u^{n}_{i-1}}{\\Delta x^{2}}\n$$\n\nThe left-hand side (LHS) is an approximation of the time derivative. Its Taylor series expansion in time around $(x_i, t_n)$ is:\n$$\n\\text{LHS} = \\frac{u(x_i, t_n + \\Delta t) - u(x_i, t_n)}{\\Delta t} = \\frac{\\left(u + \\Delta t u_t + \\frac{\\Delta t^2}{2} u_{tt} + \\frac{\\Delta t^3}{6} u_{ttt} + \\dots\\right) - u}{\\Delta t}\n$$\n$$\n\\text{LHS} = u_t + \\frac{\\Delta t}{2} u_{tt} + \\frac{\\Delta t^2}{6} u_{ttt} + O(\\Delta t^3)\n$$\nwhere all partial derivatives are evaluated at $(x_i, t_n)$.\n\nThe right-hand side (RHS) is an approximation of the spatial second derivative. Its Taylor series expansion in space around $(x_i, t_n)$ is derived from:\n$$\nu^{n}_{i \\pm 1} = u(x_i \\pm \\Delta x, t_n) = u \\pm \\Delta x u_x + \\frac{\\Delta x^2}{2} u_{xx} \\pm \\frac{\\Delta x^3}{6} u_{xxx} + \\frac{\\Delta x^4}{24} u_{xxxx} \\pm \\dots\n$$\nCombining these to form the centered difference operator:\n$$\nu^{n}_{i+1} - 2u^{n}_{i} + u^{n}_{i-1} = (\\Delta x^2 u_{xx} + \\frac{\\Delta x^4}{12} u_{xxxx} + \\frac{\\Delta x^6}{360} u_{xxxxxx} + \\dots)\n$$\nThus, the RHS of the scheme is:\n$$\n\\text{RHS} = \\kappa \\frac{\\Delta x^2 u_{xx} + \\frac{\\Delta x^4}{12} u_{xxxx} + \\dots}{\\Delta x^2} = \\kappa \\left( u_{xx} + \\frac{\\Delta x^2}{12} u_{xxxx} + O(\\Delta x^4) \\right)\n$$\n\nThe numerical scheme enforces that LHS $=$ RHS. Therefore, the differential equation that the numerical solution actually satisfies is:\n$$\nu_t + \\frac{\\Delta t}{2} u_{tt} + \\frac{\\Delta t^2}{6} u_{ttt} + \\dots = \\kappa u_{xx} + \\frac{\\kappa \\Delta x^2}{12} u_{xxxx} + \\frac{\\kappa \\Delta x^4}{360} u_{xxxxxx} + \\dots\n$$\nTo obtain the modified equation in a standard form, we express all higher-order time derivatives in terms of spatial derivatives. We do this by repeatedly using the equation itself, starting with its lowest-order approximation, which is the original PDE, $u_t = \\kappa u_{xx}$. Differentiating this with respect to time gives:\n$$\nu_{tt} = \\frac{\\partial}{\\partial t} (\\kappa u_{xx}) = \\kappa \\frac{\\partial^2}{\\partial x^2} (u_t)\n$$\nNow, substituting $u_t = \\kappa u_{xx}$ into this expression yields:\n$$\nu_{tt} = \\kappa \\frac{\\partial^2}{\\partial x^2} (\\kappa u_{xx}) = \\kappa^2 u_{xxxx}\n$$\nWe only need to go to this order to find the leading artificial term. Substituting this into the expanded equation:\n$$\nu_t + \\frac{\\Delta t}{2} (\\kappa^2 u_{xxxx}) + O(\\Delta t^2) = \\kappa u_{xx} + \\frac{\\kappa \\Delta x^2}{12} u_{xxxx} + O(\\Delta x^4)\n$$\nRearranging the terms to isolate $u_t$ gives the modified differential equation:\n$$\nu_t = \\kappa u_{xx} + \\left( \\frac{\\kappa \\Delta x^2}{12} - \\frac{\\kappa^2 \\Delta t}{2} \\right) u_{xxxx} + \\text{h.o.t.}\n$$\nwhere \"h.o.t.\" represents higher-order terms involving $\\Delta t^2$, $\\Delta x^4$, and their products.\n\nThe leading artificial higher-order spatial term is the one containing the fourth spatial derivative, $u_{xxxx}$. The analytic expression for the coefficient multiplying this term is:\n$$\n\\frac{\\kappa \\Delta x^2}{12} - \\frac{\\kappa^2 \\Delta t}{2}\n$$\n\nFinally, we provide the requested interpretation. The modified equation shows that the FTCS scheme solves a PDE that is different from the original heat equation. The term $C u_{xxxx}$, where $C = \\frac{\\kappa \\Delta x^2}{12} - \\frac{\\kappa^2 \\Delta t}{2}$, represents an artificial physical process. The sign and magnitude of the coefficient $C$ significantly influence the numerical solution's behavior. The von Neumann stability condition for the FTCS scheme is $r = \\kappa \\Delta t / \\Delta x^2 \\le 1/2$.\n- If $C  0$ (which occurs when $r > 1/6$), the term $C u_{xxxx}$ acts as an artificial numerical diffusion, or hyper-dissipation. This term enhances the dissipative nature of the scheme, particularly for short-wavelength features. In computational geophysics applications like lithospheric thermal modeling, this would cause excessive smoothing of the temperature field, artificially thickening thermal boundary layers and smearing sharp gradients.\n- If $C > 0$ (which occurs when $r  1/6$), the term $C u_{xxxx}$ is anti-dissipative. It counteracts the physical diffusion and can lead to a negative effective diffusivity for high-wavenumber modes. This manifests as spurious, high-frequency oscillations in the numerical solution (numerical dispersion), which reduces its smoothness and can cause unphysical behavior, such as temperatures outside the expected physical range near sharp interfaces or sources.\nThe magnitude of $C$ determines the severity of these artificial effects, which are reduced by refining the grid (smaller $\\Delta x$ and $\\Delta t$). The special case $C=0$, occurring at $r=1/6$, eliminates this leading error term entirely, yielding a more accurate scheme.", "answer": "$$\n\\boxed{\\frac{\\kappa \\Delta x^{2}}{12} - \\frac{\\kappa^{2} \\Delta t}{2}}\n$$", "id": "3590501"}, {"introduction": "Having theoretically dissected the explicit scheme, we now turn to the essential task of practical code verification. This exercise introduces the Method of Manufactured Solutions (MMS), a cornerstone of modern scientific computing for testing the correctness and accuracy of a numerical solver. You will implement a 2D explicit heat equation solver and, instead of seeking a known physical solution, you will manufacture one, derive the necessary source term, and use it to rigorously test if your code achieves its theoretical convergence rate [@problem_id:3590474]. This practice is fundamental for building confidence in your numerical implementations.", "problem": "Consider the two-dimensional heat equation with a constant thermal diffusivity $\\kappa$ on the unit square domain $\\Omega = [0,1]\\times[0,1]$ and a smooth source term $s(\\mathbf{x},t)$,\n$$\n\\frac{\\partial u}{\\partial t}(\\mathbf{x},t) \\;=\\; \\kappa \\,\\Delta u(\\mathbf{x},t) \\;+\\; s(\\mathbf{x},t), \\qquad \\mathbf{x}=(x,y)\\in\\Omega,\\; t\\in[0,T],\n$$\nsubject to homogeneous Dirichlet boundary conditions $u(\\mathbf{x},t)=0$ for $\\mathbf{x}\\in\\partial\\Omega$ and a specified initial condition $u(\\mathbf{x},0)=u_0(\\mathbf{x})$. Use the method of manufactured solutions to construct a smooth, nontrivial function $u(\\mathbf{x},t)$ and deduce the corresponding source term $s(\\mathbf{x},t)$ such that the manufactured $u(\\mathbf{x},t)$ exactly satisfies the partial differential equation and boundary conditions. Then design and implement a fully explicit forward Euler in time and centered differences in space scheme for this problem, derive and enforce its stability restriction, and numerically verify the observed convergence rates in time and space.\n\nYour manufactured solution must be\n$$\nu(x,y,t) \\;=\\; e^{t}\\,\\sin(2\\pi x)\\,\\sin(2\\pi y),\n$$\non $\\Omega$ and for $t\\in[0,T]$. Starting from the governing equation and the chosen $u(x,y,t)$, compute the source term $s(x,y,t)$ required to make $u$ satisfy the equation. Use the homogeneous Dirichlet boundary values induced by $u$ and the initial condition $u(x,y,0)$. Discretize $\\Omega$ using a uniform Cartesian grid with $N_x+1$ points in $x$ and $N_y+1$ points in $y$ (including boundaries), with spacings $\\Delta x=1/N_x$ and $\\Delta y=1/N_y$. Let $u_{i,j}^n$ denote the numerical approximation at grid index $i,j$ and time level $t^n$.\n\nYour explicit scheme must update interior grid points $i=1,\\dots,N_x-1$ and $j=1,\\dots,N_y-1$ according to\n$$\nu_{i,j}^{n+1} \\;=\\; u_{i,j}^{n} \\;+\\; \\Delta t \\left\\{ \\kappa\\left(\\frac{u_{i+1,j}^{n}-2u_{i,j}^{n}+u_{i-1,j}^{n}}{\\Delta x^2} \\;+\\; \\frac{u_{i,j+1}^{n}-2u_{i,j}^{n}+u_{i,j-1}^{n}}{\\Delta y^2}\\right) \\;+\\; s(x_i,y_j,t^n) \\right\\},\n$$\nwith boundary values set to zero at each time level. Use the Courant-Friedrichs-Lewy (CFL) stability restriction for the two-dimensional explicit scheme,\n$$\n\\Delta t \\;\\le\\; \\frac{1}{2\\,\\kappa\\left(\\frac{1}{\\Delta x^2}+\\frac{1}{\\Delta y^2}\\right)},\n$$\nand, for $\\Delta x=\\Delta y$, this simplifies to $\\Delta t \\le \\frac{\\Delta x^2}{4\\kappa}$.\n\nDefine the discrete $L^2$ error at final time $T$ by\n$$\nE \\;=\\; \\left(\\sum_{i=0}^{N_x}\\sum_{j=0}^{N_y} \\left(u_{i,j}^{N_t} - u(x_i,y_j,T)\\right)^2 \\,\\Delta x\\,\\Delta y \\right)^{1/2},\n$$\nwhere $N_t$ denotes the final time index such that $N_t\\,\\Delta t \\approx T$. Use $\\Delta t$ adjusted so that the time grid lands exactly at $T$, i.e., $\\Delta t_{\\mathrm{eff}} = T/N_t$ with integer $N_t$ and $\\Delta t_{\\mathrm{eff}} \\le \\Delta t$.\n\nNumerically estimate the temporal convergence rate $p_t$ by fixing a fine spatial grid and computing errors $E(\\Delta t_k)$ for a sequence of time steps $\\Delta t_k$ related by successive halving. Estimate $p_t$ from the slope of $\\log E$ versus $\\log \\Delta t$. Similarly, estimate the spatial convergence rate $p_x$ by fixing a stable time step (consistent with the CFL condition) and computing errors $E(\\Delta x_\\ell)$ for spatial grids with $\\Delta x_\\ell$ related by successive halving, estimating $p_x$ from the slope of $\\log E$ versus $\\log \\Delta x$.\n\nTest Suite:\n- Case A (temporal convergence, happy path): $\\kappa=0.1$, $N_x=N_y=64$, $T=0.1$, and $\\Delta t$ values $\\Delta t_0=0.8\\,\\Delta t_{\\mathrm{CFL}}$, $\\Delta t_1=\\Delta t_0/2$, $\\Delta t_2=\\Delta t_1/2$ where $\\Delta t_{\\mathrm{CFL}}=\\Delta x^2/(4\\kappa)$. Report the measured $p_t$.\n- Case B (spatial convergence, happy path): $\\kappa=0.1$, $T=0.1$, grids with $N_x=N_y\\in\\{20,40,80\\}$ and, for each grid, take $\\Delta t=0.4\\,\\Delta t_{\\mathrm{CFL}}$. Report the measured $p_x$.\n- Case C (temporal convergence at the stability boundary, edge case): $\\kappa=0.1$, $N_x=N_y=50$, $T=0.05$, and $\\Delta t$ values $\\Delta t_0=\\Delta t_{\\mathrm{CFL}}$, $\\Delta t_1=\\Delta t_0/2$, $\\Delta t_2=\\Delta t_1/2$. Report the measured $p_t$.\n\nYour program must:\n- Compute $s(x,y,t)$ from the manufactured $u(x,y,t)$ and the heat equation.\n- Implement the explicit scheme with homogeneous Dirichlet boundaries and the CFL restriction.\n- For each case, estimate the convergence rate by linear regression on the pairs $(\\log \\Delta t_k, \\log E_k)$ or $(\\log \\Delta x_\\ell, \\log E_\\ell)$ as appropriate.\n- Produce a single line of output containing the three results, rounded to three decimal places, as a comma-separated list enclosed in square brackets, in the order $[p_t^{\\mathrm{A}},p_x^{\\mathrm{B}},p_t^{\\mathrm{C}}]$. No physical units are required because the quantities are dimensionless.\n\nThe final outputs for all provided test cases must be floats. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\").", "solution": "We start from the governing two-dimensional heat equation with constant thermal diffusivity $\\kappa$,\n$$\n\\frac{\\partial u}{\\partial t} \\;=\\; \\kappa \\,\\Delta u \\;+\\; s,\n$$\non the unit square domain $\\Omega=[0,1]\\times[0,1]$ with homogeneous Dirichlet boundary conditions, i.e., $u|_{\\partial\\Omega}=0$, and a prescribed initial condition. In the method of manufactured solutions, we choose a smooth function $u(x,y,t)$ and deduce the source term $s(x,y,t)$ such that the chosen $u$ satisfies the equation and boundary conditions exactly. This allows us to assess the numerical method’s convergence properties by comparing the numerical solution against the exact manufactured solution.\n\nWe choose\n$$\nu(x,y,t) \\;=\\; e^{t}\\,\\sin(2\\pi x)\\,\\sin(2\\pi y).\n$$\nThis function satisfies the homogeneous Dirichlet boundary conditions because $\\sin(2\\pi x)=0$ on $x=0$ and $x=1$, and similarly $\\sin(2\\pi y)=0$ on $y=0$ and $y=1$, so $u=0$ on $\\partial\\Omega$ for all $t$. Its initial condition is $u(x,y,0)=\\sin(2\\pi x)\\sin(2\\pi y)$.\n\nTo compute the source term $s$, we use the definitions of the time derivative and Laplacian:\n$$\n\\frac{\\partial u}{\\partial t} \\;=\\; e^{t}\\,\\sin(2\\pi x)\\,\\sin(2\\pi y) \\;=\\; u,\n$$\nand\n$$\n\\Delta u \\;=\\; \\frac{\\partial^2 u}{\\partial x^2} \\;+\\; \\frac{\\partial^2 u}{\\partial y^2}\n\\;=\\; -\\,(2\\pi)^2\\,e^{t}\\,\\sin(2\\pi x)\\,\\sin(2\\pi y) \\;-\\; (2\\pi)^2\\,e^{t}\\,\\sin(2\\pi x)\\,\\sin(2\\pi y)\n\\;=\\; -\\,8\\pi^2\\,u.\n$$\nSubstituting into the heat equation gives\n$$\nu_t \\;=\\; \\kappa\\,\\Delta u \\;+\\; s \\;\\;\\Rightarrow\\;\\; s \\;=\\; u_t \\;-\\; \\kappa\\,\\Delta u \\;=\\; u \\;-\\; \\kappa\\,(-8\\pi^2\\,u) \\;=\\; \\left(1+8\\pi^2\\kappa\\right)\\,u.\n$$\nThus, the forcing term is\n$$\ns(x,y,t) \\;=\\; \\left(1+8\\pi^2\\kappa\\right)\\,e^{t}\\,\\sin(2\\pi x)\\,\\sin(2\\pi y).\n$$\n\nWe discretize the spatial domain with a uniform Cartesian grid:\n$$\nx_i \\;=\\; i\\,\\Delta x,\\quad i=0,\\dots,N_x,\\qquad \\Delta x \\;=\\; \\frac{1}{N_x},\n$$\n$$\ny_j \\;=\\; j\\,\\Delta y,\\quad j=0,\\dots,N_y,\\qquad \\Delta y \\;=\\; \\frac{1}{N_y}.\n$$\nLet $u_{i,j}^n$ denote the numerical approximation to $u(x_i,y_j,t^n)$ at time level $t^n=n\\,\\Delta t$. The explicit forward Euler in time and second-order centered differences in space scheme for interior points $i=1,\\dots,N_x-1$ and $j=1,\\dots,N_y-1$ is\n$$\nu_{i,j}^{n+1} \\;=\\; u_{i,j}^{n} \\;+\\; \\Delta t \\left\\{ \\kappa\\left(\\frac{u_{i+1,j}^{n}-2u_{i,j}^{n}+u_{i-1,j}^{n}}{\\Delta x^2} \\;+\\; \\frac{u_{i,j+1}^{n}-2u_{i,j}^{n}+u_{i,j-1}^{n}}{\\Delta y^2}\\right) \\;+\\; s(x_i,y_j,t^n) \\right\\},\n$$\nwith boundary values $u_{0,j}^n=u_{N_x,j}^n=u_{i,0}^n=u_{i,N_y}^n=0$ for all $n$. This scheme is first order accurate in time and second order accurate in space, under appropriate smoothness assumptions on $u$.\n\nFor stability, the Courant-Friedrichs-Lewy (CFL) restriction for the two-dimensional explicit diffusion scheme with constant $\\kappa$ is\n$$\n\\Delta t \\;\\le\\; \\frac{1}{2\\,\\kappa\\left(\\frac{1}{\\Delta x^2}+\\frac{1}{\\Delta y^2}\\right)}.\n$$\nIn the special case $\\Delta x=\\Delta y$, this simplifies to\n$$\n\\Delta t \\;\\le\\; \\frac{\\Delta x^2}{4\\,\\kappa}.\n$$\nWe enforce this restriction by computing a candidate $\\Delta t$ and then adjusting with $\\Delta t_{\\mathrm{eff}}=T/N_t$ where $N_t=\\left\\lceil T/\\Delta t\\right\\rceil$ so that the time grid lands exactly at $T$ while maintaining stability.\n\nTo quantify numerical error at final time $T$, we use the discrete $L^2$ norm,\n$$\nE \\;=\\; \\left(\\sum_{i=0}^{N_x}\\sum_{j=0}^{N_y} \\left(u_{i,j}^{N_t} - u(x_i,y_j,T)\\right)^2 \\,\\Delta x\\,\\Delta y \\right)^{1/2}.\n$$\nThe observed temporal convergence rate $p_t$ is estimated by computing errors $E_k=E(\\Delta t_k)$ on a fixed fine grid for time step sizes $\\Delta t_k$ related by successive halving, and performing a linear regression of $\\log E_k$ versus $\\log \\Delta t_k$. Similarly, the observed spatial convergence rate $p_x$ is estimated by computing errors $E_\\ell=E(\\Delta x_\\ell)$ at a fixed stable time step for grids with $\\Delta x_\\ell$ halved successively, and performing a linear regression of $\\log E_\\ell$ versus $\\log \\Delta x_\\ell$. Since the scheme is first order in time and second order in space, we expect $p_t\\approx 1$ and $p_x\\approx 2$.\n\nAlgorithmic steps for each test case:\n1. Set $\\kappa$, $T$, and the grid sizes $N_x,N_y$.\n2. Compute $\\Delta x=1/N_x$ and $\\Delta y=1/N_y$; form grids $x_i$ and $y_j$ and the manufactured initial condition $u(x,y,0)$.\n3. Choose candidate $\\Delta t$ values consistent with the CFL restriction. For temporal studies, use $\\Delta t$ sequences related by halving. For spatial studies, adjust $\\Delta t$ per grid via a fixed fraction of the CFL limit to remain stable and reasonably efficient.\n4. For each $\\Delta t$, set $N_t=\\lceil T/\\Delta t\\rceil$ and use $\\Delta t_{\\mathrm{eff}}=T/N_t$ to exactly reach $T$. Advance the explicit scheme for $N_t$ steps:\n   - At each step $n$, evaluate $s(x_i,y_j,t^n)$ from the manufactured solution and update interior points using the explicit formula; enforce boundary values $u=0$.\n5. At final time $T$, compute the discrete $L^2$ error $E$ against the exact $u(x,y,T)$.\n6. Assemble errors versus $\\Delta t$ or $\\Delta x$ and estimate $p_t$ or $p_x$ via linear regression on $(\\log \\Delta t,\\log E)$ or $(\\log \\Delta x,\\log E)$.\n7. Report the measured rates rounded to three decimal places.\n\nTest Suite specifics:\n- Case A: $\\kappa=0.1$, $N_x=N_y=64$, $T=0.1$; time step sequence $\\Delta t_0=0.8\\,\\Delta x^2/(4\\kappa)$, $\\Delta t_1=\\Delta t_0/2$, $\\Delta t_2=\\Delta t_1/2$; estimate $p_t$.\n- Case B: $\\kappa=0.1$, $T=0.1$; grids $N_x=N_y\\in\\{20,40,80\\}$; for each, set $\\Delta t=0.4\\,\\Delta x^2/(4\\kappa)$; estimate $p_x$.\n- Case C: $\\kappa=0.1$, $N_x=N_y=50$, $T=0.05$; time step sequence $\\Delta t_0=\\Delta x^2/(4\\kappa)$, $\\Delta t_1=\\Delta t_0/2$, $\\Delta t_2=\\Delta t_1/2$; estimate $p_t$.\n\nThe final program output must be a single line containing $[p_t^{\\mathrm{A}},p_x^{\\mathrm{B}},p_t^{\\mathrm{C}}]$ as a comma-separated list enclosed in square brackets, with each number rounded to three decimal places. No physical units are required since the measured rates are dimensionless.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef manufactured_u(x, y, t):\n    \"\"\"Exact manufactured solution u(x,y,t) = exp(t) * sin(2πx) * sin(2πy).\"\"\"\n    return np.exp(t) * np.sin(2.0 * np.pi * x) * np.sin(2.0 * np.pi * y)\n\ndef source_s(x, y, t, kappa):\n    \"\"\"Source term s = (1 + 8π^2 κ) * u(x,y,t).\"\"\"\n    return (1.0 + 8.0 * (np.pi ** 2) * kappa) * manufactured_u(x, y, t)\n\ndef explicit_heat_2d(kappa, Nx, Ny, T, dt_candidate):\n    \"\"\"\n    Solve the forced heat equation using an explicit scheme on [0,1]x[0,1] with Dirichlet 0 BCs.\n    Uses dt_eff = T / Nt with Nt = ceil(T / dt_candidate) to land exactly at T.\n    Returns the discrete L2 error at time T with respect to the manufactured solution.\n    \"\"\"\n    Lx, Ly = 1.0, 1.0\n    dx = Lx / Nx\n    dy = Ly / Ny\n\n    # CFL time step limit for explicit scheme in 2D with dx=1/Nx, dy=1/Ny:\n    dt_cfl = 1.0 / (2.0 * kappa * (1.0 / dx**2 + 1.0 / dy**2))\n    # Ensure candidate dt is not larger than CFL limit\n    dt = min(dt_candidate, dt_cfl)\n    Nt = int(np.ceil(T / dt))\n    dt_eff = T / Nt  # adjust to land exactly at T, maintains stability since dt_eff = dt\n\n    # Grids\n    x = np.linspace(0.0, Lx, Nx + 1)\n    y = np.linspace(0.0, Ly, Ny + 1)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # Initial condition from manufactured solution at t=0\n    u = manufactured_u(X, Y, 0.0)\n\n    # Enforce boundary conditions (Dirichlet zero) explicitly: they are already zero by construction,\n    # but we maintain the boundary to zero at each time step.\n    u[0, :] = 0.0\n    u[-1, :] = 0.0\n    u[:, 0] = 0.0\n    u[:, -1] = 0.0\n\n    # Time stepping\n    t = 0.0\n    inv_dx2 = 1.0 / dx**2\n    inv_dy2 = 1.0 / dy**2\n    for n in range(Nt):\n        # Source term evaluated at current time\n        s = source_s(X, Y, t, kappa)\n\n        # Compute Laplacian with centered differences on interior points\n        # Vectorized update for interior\n        u_center = u[1:-1, 1:-1]\n        lap = (u[2:, 1:-1] - 2.0 * u_center + u[:-2, 1:-1]) * inv_dx2 \\\n            + (u[1:-1, 2:] - 2.0 * u_center + u[1:-1, :-2]) * inv_dy2\n\n        # Update interior\n        u[1:-1, 1:-1] = u_center + dt_eff * (kappa * lap + s[1:-1, 1:-1])\n\n        # Enforce boundary zeros each step\n        u[0, :] = 0.0\n        u[-1, :] = 0.0\n        u[:, 0] = 0.0\n        u[:, -1] = 0.0\n\n        t += dt_eff\n\n    # Exact solution at final time\n    u_exact_T = manufactured_u(X, Y, T)\n\n    # Discrete L2 error over the whole grid\n    err = u - u_exact_T\n    E = np.sqrt(np.sum(err**2) * dx * dy)\n    return E, dx, dy, dt_eff\n\ndef estimate_rate(xs, Es):\n    \"\"\"\n    Estimate convergence rate by linear regression of log(Es) vs log(xs).\n    xs: array of step sizes (Δt or Δx)\n    Es: corresponding errors\n    Returns slope (rate)\n    \"\"\"\n    logx = np.log(xs)\n    logE = np.log(Es)\n    # Fit logE = a + p * logx; p is slope (rate)\n    p, a = np.polyfit(logx, logE, 1)\n    return p\n\ndef case_temporal_convergence(kappa, Nx, Ny, T, dt0, num_levels=3):\n    \"\"\"\n    Measure temporal convergence rate by halving dt on a fixed grid.\n    \"\"\"\n    dts = [dt0 / (2**i) for i in range(num_levels)]\n    errors = []\n    for dt in dts:\n        E, _, _, dt_eff = explicit_heat_2d(kappa, Nx, Ny, T, dt)\n        errors.append(E)\n    # Compute rate using regression on (log dt_eff, log E)\n    dts_eff = np.array([explicit_heat_2d(kappa, Nx, Ny, T, dt)[3] for dt in dts])\n    rate = estimate_rate(dts_eff, np.array(errors))\n    return rate\n\ndef case_spatial_convergence(kappa, Ns, T, dt_fraction=0.4):\n    \"\"\"\n    Measure spatial convergence rate by halving Δx with dt set as a fixed fraction of the CFL limit.\n    Ns: list of N values for Nx=Ny.\n    \"\"\"\n    dxs = []\n    errors = []\n    for N in Ns:\n        # For each N, set dt = dt_fraction * dt_cfl\n        dx = 1.0 / N\n        dy = dx\n        dt_cfl = 1.0 / (2.0 * kappa * (1.0 / dx**2 + 1.0 / dy**2))\n        dt = dt_fraction * dt_cfl\n        E, _, _, _ = explicit_heat_2d(kappa, N, N, T, dt)\n        dxs.append(dx)\n        errors.append(E)\n    rate = estimate_rate(np.array(dxs), np.array(errors))\n    return rate\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Case A: Temporal convergence, happy path\n    kappa_A = 0.1\n    Nx_A = Ny_A = 64\n    T_A = 0.1\n    dx_A = 1.0 / Nx_A\n    dt_cfl_A = dx_A**2 / (4.0 * kappa_A)  # for dx=dy\n    dt0_A = 0.8 * dt_cfl_A\n    p_t_A = case_temporal_convergence(kappa_A, Nx_A, Ny_A, T_A, dt0_A, num_levels=3)\n\n    # Case B: Spatial convergence, happy path\n    kappa_B = 0.1\n    T_B = 0.1\n    Ns_B = [20, 40, 80]\n    p_x_B = case_spatial_convergence(kappa_B, Ns_B, T_B, dt_fraction=0.4)\n\n    # Case C: Temporal convergence at the stability boundary, edge case\n    kappa_C = 0.1\n    Nx_C = Ny_C = 50\n    T_C = 0.05\n    dx_C = 1.0 / Nx_C\n    dt_cfl_C = dx_C**2 / (4.0 * kappa_C)\n    dt0_C = dt_cfl_C\n    p_t_C = case_temporal_convergence(kappa_C, Nx_C, Ny_C, T_C, dt0_C, num_levels=3)\n\n    results = [p_t_A, p_x_B, p_t_C]\n\n    # Final print statement in the exact required format (rounded to three decimals).\n    print(f\"[{','.join(f'{r:.3f}' for r in results)}]\")\n\nsolve()\n```", "id": "3590474"}, {"introduction": "Building on a verified solver for the heat equation, this final practice takes a critical step towards modeling realistic geophysical systems where multiple physical processes occur simultaneously. Here, we explore operator splitting, a modular and powerful technique for solving complex equations like the advection-diffusion equation by combining simpler, single-process solvers. You will implement both Lie and Strang splitting methods, analyze the combined stability constraints, and quantify the splitting error, thereby learning how to construct and evaluate sophisticated multi-physics models from trusted components [@problem_id:3590410].", "problem": "Consider the one-dimensional advection–diffusion form of the heat equation with constant coefficients,\n$$\n\\frac{\\partial T}{\\partial t} + u \\frac{\\partial T}{\\partial x} = \\kappa \\frac{\\partial^2 T}{\\partial x^2},\n$$\nposed on a periodic domain of length $L$ with uniform grid spacing $\\Delta x$ and time step $\\Delta t$. Here $T(x,t)$ is temperature, $u$ is a uniform solid velocity (solid advection of heat), and $\\kappa$ is thermal diffusivity. This setting is a simplified surrogate for the along-slab thermal evolution in a subduction zone, capturing the interplay between solid-state advection and thermal diffusion.\n\nYou must design an explicit operator-splitting time integrator that combines:\n- an explicit first-order upwind scheme for the advection substep, and\n- an explicit forward Euler central-difference scheme for the diffusion substep,\n\nwith periodic boundaries. Implement two splitting variants:\n- Lie splitting: in each full time step, apply advection for $\\Delta t$ followed by diffusion for $\\Delta t$,\n- Strang splitting: in each full time step, apply advection for $\\Delta t/2$, diffusion for $\\Delta t$, and advection for $\\Delta t/2$.\n\nDerive, from first principles, the combined Courant–Friedrichs–Lewy (CFL) stability constraints for this explicit composition. Quantify the splitting error by comparing the numerical solutions to the exact solution of the constant-coefficient advection–diffusion equation on a periodic domain, evaluated via the discrete Fourier transform. For a grid with $N$ points, grid spacing $\\Delta x = L/N$, discrete wavenumbers $k_n = 2\\pi n/L$ with $n \\in \\{0,1,\\dots,N-1\\}$ mapped to signed frequencies, and initial condition $\\widehat{T}(k_n,0)$, the exact spectral solution is given by\n$$\n\\widehat{T}(k_n,t) = \\widehat{T}(k_n,0)\\,\\exp\\!\\big(-\\kappa k_n^2 t\\big)\\,\\exp\\!\\big(-\\mathrm{i} k_n u t\\big),\n$$\nand the physical-space solution is obtained by inverse transform. Use this exact solution to compute relative $\\ell^2$ errors.\n\nAdopt the initial condition\n$$\nT(x,0) = \\cos\\!\\Big(\\frac{2\\pi x}{L}\\Big) + \\frac{1}{2}\\cos\\!\\Big(\\frac{4\\pi x}{L} + \\phi\\Big),\n$$\nwith phase $\\phi = 0.3$ in radians. Angles must be in radians.\n\nDefine the nondimensional parameters\n$$\nr = \\frac{|u|\\,\\Delta t}{\\Delta x}, \\qquad \\mu = \\frac{\\kappa\\,\\Delta t}{\\Delta x^2}.\n$$\n\nYour program must:\n1. Implement Lie and Strang splitting integrators with periodic boundaries, using the explicit first-order upwind advection substep and explicit forward Euler diffusion substep.\n2. Compute the exact reference solution at a specified final time $t_{\\mathrm{end}}$ using the spectral formula above.\n3. Compute the relative $\\ell^2$ error\n$$\nE = \\frac{\\|T_{\\mathrm{num}}(\\cdot,t_{\\mathrm{end}}) - T_{\\mathrm{exact}}(\\cdot,t_{\\mathrm{end}})\\|_2}{\\|T_{\\mathrm{exact}}(\\cdot,t_{\\mathrm{end}})\\|_2}.\n$$\n4. Estimate the observed order of accuracy in time for each splitting by comparing errors at $\\Delta t$ and $\\Delta t/2$ for the same $t_{\\mathrm{end}}$:\n$$\np = \\frac{\\log\\big(E(\\Delta t)/E(\\Delta t/2)\\big)}{\\log(2)}.\n$$\n5. Compute the combined stability-limited time step $\\Delta t_{\\max}$ implied by your derived constraints. Express any time quantities in seconds.\n\nUse the following test suite of parameter sets. All lengths must be in meters, time in seconds, velocity in meters per second, diffusivity in square meters per second, and the phase $\\phi$ in radians.\n\n- Test Case A (convergence exponents under diffusion-limited constraint):\n  - $L = 10{,}000$, $\\Delta x = 50$, $\\kappa = 10^{-6}$, $u = 0.05/31557600$, $\\phi = 0.3$.\n  - Let $\\Delta t_{\\max}$ be the combined stability-limited time step you derive.\n  - Set $\\Delta t = 0.4\\,\\Delta t_{\\max}$, $\\Delta t/2$ as the refined step, and $t_{\\mathrm{end}} = 100\\,\\Delta t$.\n  - Compute $p_{\\mathrm{Lie}}$ and $p_{\\mathrm{Strang}}$ as defined above.\n\n- Test Case B (near-boundary stability metrics under advection-limited constraint):\n  - $L = 200{,}000$, $\\Delta x = 1{,}000$, $\\kappa = 10^{-6}$, $u = 0.08/31557600$, $\\phi = 0.3$.\n  - Compute $\\Delta t_{\\max}$ in seconds from the combined constraints.\n  - Use $\\Delta t = 0.99\\,\\Delta t_{\\max}$ and evaluate $r$ and $\\mu$.\n  - Report $\\Delta t_{\\max}$ (in seconds), $r$, $\\mu$, and a boolean $S$ that is true if and only if $r \\le 1$ and $\\mu \\le 1/2$.\n\n- Test Case C (splitting error ratio at a moderate step):\n  - $L = 10{,}000$, $\\Delta x = 50$, $\\kappa = 10^{-6}$, $u = 0.05/31557600$, $\\phi = 0.3$.\n  - Compute $\\Delta t_{\\max}$; use $\\Delta t = 0.2\\,\\Delta t_{\\max}$ and $t_{\\mathrm{end}} = 100\\,\\Delta t$.\n  - Compute the ratio $R = E_{\\mathrm{Strang}}/E_{\\mathrm{Lie}}$ at the same $\\Delta t$.\n\nFinal output format:\n- Your program should produce a single line containing a comma-separated list enclosed in square brackets with the following entries in order:\n  - $p_{\\mathrm{Lie}}$ for Test Case A,\n  - $p_{\\mathrm{Strang}}$ for Test Case A,\n  - $\\Delta t_{\\max}$ for Test Case B (in seconds),\n  - $r$ for Test Case B,\n  - $\\mu$ for Test Case B,\n  - $S$ for Test Case B (a boolean),\n  - $R$ for Test Case C.\nFor example: \"[pLieA,pStrangA,dtmaxB,rB,muB,SB,Rc]\".", "solution": "We start from the one-dimensional advection–diffusion heat equation with constant coefficients,\n$$\n\\frac{\\partial T}{\\partial t} + u \\frac{\\partial T}{\\partial x} = \\kappa \\frac{\\partial^2 T}{\\partial x^2},\n$$\non a periodic domain of length $L$. The operator-splitting approach uses the decomposition into an advection operator $A$ and a diffusion operator $D$,\n$$\nA[T] = -u \\frac{\\partial T}{\\partial x}, \\qquad D[T] = \\kappa \\frac{\\partial^2 T}{\\partial x^2},\n$$\nso that the full generator is $L = A + D$.\n\nStability constraints are derived from Von Neumann analysis applied to the discrete substeps. For the advection substep, we choose an explicit first-order upwind scheme. On a uniform grid with spacing $\\Delta x$ and time step $\\Delta t$, when $u \\ge 0$ the update reads\n$$\nT_i^{n+1} = T_i^n - r\\,(T_i^n - T_{i-1}^n), \\quad r = \\frac{u\\,\\Delta t}{\\Delta x},\n$$\nwith periodic indexing. The amplification factor for a Fourier mode $e^{\\mathrm{i} k i \\Delta x}$ is\n$$\ng_A(k) = 1 - r\\,(1 - e^{-\\mathrm{i} k \\Delta x}).\n$$\nA standard result for the upwind scheme is that stability requires\n$$\n|g_A(k)| \\le 1 \\quad \\text{for all } k \\quad \\Longleftrightarrow \\quad 0 \\le r \\le 1,\n$$\nand by symmetry for $u \\le 0$ one requires $0 \\le |r| \\le 1$. Thus the advection CFL constraint is\n$$\nr = \\frac{|u|\\,\\Delta t}{\\Delta x} \\le 1 \\quad \\Longleftrightarrow \\quad \\Delta t \\le \\frac{\\Delta x}{|u|}.\n$$\n\nFor the diffusion substep, we use an explicit forward Euler central-difference scheme,\n$$\nT_i^{n+1} = T_i^n + \\mu\\,\\big(T_{i+1}^n - 2 T_i^n + T_{i-1}^n\\big), \\quad \\mu = \\frac{\\kappa\\,\\Delta t}{\\Delta x^2}.\n$$\nIts Fourier amplification factor is\n$$\ng_D(k) = 1 - 4\\mu \\sin^2\\!\\Big(\\frac{k \\Delta x}{2}\\Big).\n$$\nStability requires $|g_D(k)| \\le 1$ for all $k$, which holds if and only if\n$$\n0 \\le \\mu \\le \\frac{1}{2} \\quad \\Longleftrightarrow \\quad \\Delta t \\le \\frac{\\Delta x^2}{2\\kappa}.\n$$\n\nBecause we explicitly compose the substeps within each full time step, a sufficient combined stability condition is that both substeps be individually stable. Therefore the combined time-step constraint is\n$$\n\\Delta t \\le \\min\\!\\left(\\frac{\\Delta x}{|u|}, \\frac{\\Delta x^2}{2\\kappa}\\right) \\equiv \\Delta t_{\\max}.\n$$\n\nWe next justify the splitting-error orders. The exact solution operator over one time step is the semigroup $e^{\\Delta t (A+D)}$. Lie splitting applies $e^{\\Delta t A}$ followed by $e^{\\Delta t D}$, which can be related to the exact operator via the Baker–Campbell–Hausdorff (BCH) formula:\n$$\ne^{\\Delta t A} e^{\\Delta t D} = e^{\\Delta t (A+D) + \\frac{\\Delta t^2}{2}[A,D] + \\mathcal{O}(\\Delta t^3)},\n$$\nwhere $[A,D] = AD - DA$ is the commutator. As $[A,D] \\ne 0$ for $u \\ne 0$ and $\\kappa \\ne 0$, the local error per time step is $\\mathcal{O}(\\Delta t^2)$ and the global error after $t_{\\mathrm{end}}/\\Delta t$ steps accumulates to $\\mathcal{O}(\\Delta t)$. Thus Lie splitting is first order in time. Strang splitting uses the symmetric composition $e^{\\frac{\\Delta t}{2} A} e^{\\Delta t D} e^{\\frac{\\Delta t}{2} A}$, for which the BCH expansion yields cancellation of the leading commutator term and\n$$\ne^{\\frac{\\Delta t}{2} A} e^{\\Delta t D} e^{\\frac{\\Delta t}{2} A} = e^{\\Delta t (A+D) + \\mathcal{O}(\\Delta t^3)}.\n$$\nHence the local error is $\\mathcal{O}(\\Delta t^3)$ and the global error is $\\mathcal{O}(\\Delta t^2)$, i.e., second order in time.\n\nTo quantify the error, we compare to the exact periodic solution available spectrally. Let $N = L/\\Delta x$ and discrete wavenumbers $k_n = 2\\pi n/L$, with $n \\in \\{0,1,\\dots,N-1\\}$ mapped to signed frequencies using the standard discrete Fourier transform convention. If $\\widehat{T}(k_n,0)$ is the discrete Fourier transform of $T(\\cdot,0)$, then the exact evolution is\n$$\n\\widehat{T}(k_n,t) = \\widehat{T}(k_n,0)\\,\\exp\\!\\big(-\\kappa k_n^2 t\\big)\\,\\exp\\!\\big(-\\mathrm{i} k_n u t\\big),\n$$\nand the exact $T(\\cdot,t)$ is the inverse transform. Relative $\\ell^2$ errors use\n$$\nE = \\frac{\\|T_{\\mathrm{num}} - T_{\\mathrm{exact}}\\|_2}{\\|T_{\\mathrm{exact}}\\|_2},\n$$\nand the observed order is estimated by\n$$\np = \\frac{\\log\\big(E(\\Delta t)/E(\\Delta t/2)\\big)}{\\log 2}.\n$$\n\nAlgorithmic design for the program:\n- Construct the uniform grid $x_j = j\\,\\Delta x$ for $j = 0,1,\\dots,N-1$ with periodicity.\n- Initialize $T(x,0) = \\cos(2\\pi x/L) + \\frac{1}{2}\\cos(4\\pi x/L + \\phi)$ with $\\phi = 0.3$ (radians).\n- Define the explicit upwind advection substep. For $u \\ge 0$,\n$$\nT_j^{\\star} = T_j - r\\,(T_j - T_{j-1}), \\quad r = \\frac{u\\Delta t}{\\Delta x},\n$$\nand for $u  0$,\n$$\nT_j^{\\star} = T_j - r\\,(T_{j+1} - T_j), \\quad r = \\frac{u\\Delta t}{\\Delta x},\n$$\nwith periodic indexing for $j \\pm 1$.\n- Define the explicit forward Euler diffusion substep,\n$$\nT_j^{\\mathrm{new}} = T_j^{\\star} + \\mu\\,(T_{j+1}^{\\star} - 2 T_j^{\\star} + T_{j-1}^{\\star}), \\quad \\mu = \\frac{\\kappa \\Delta t}{\\Delta x^2}.\n$$\n- Compose substeps as per Lie and Strang for a chosen $\\Delta t$ and number of steps $n = t_{\\mathrm{end}}/\\Delta t$.\n- Compute the exact solution at $t_{\\mathrm{end}}$ using the discrete Fourier transform formula above.\n- Compute relative $\\ell^2$ errors and observed orders.\n- For stability metrics, compute $r$ and $\\mu$ for the chosen $\\Delta t$ and return whether $r \\le 1$ and $\\mu \\le 1/2$.\n\nWe apply this to the three specified test cases:\n\n- Test Case A:\n  - $L = 10{,}000$, $\\Delta x = 50$, $\\kappa = 10^{-6}$, $u = 0.05/31557600$, $\\phi = 0.3$.\n  - $\\Delta t_{\\max} = \\min\\!\\big(\\Delta x/|u|,\\ \\Delta x^2/(2\\kappa)\\big)$.\n  - Use $\\Delta t = 0.4\\,\\Delta t_{\\max}$, $t_{\\mathrm{end}} = 100\\,\\Delta t$.\n  - Compute $p_{\\mathrm{Lie}}$ and $p_{\\mathrm{Strang}}$.\n\n- Test Case B:\n  - $L = 200{,}000$, $\\Delta x = 1{,}000$, $\\kappa = 10^{-6}$, $u = 0.08/31557600$, $\\phi = 0.3$.\n  - Compute $\\Delta t_{\\max}$, then with $\\Delta t = 0.99\\,\\Delta t_{\\max}$ report $\\Delta t_{\\max}$, $r$, $\\mu$, and $S = (r \\le 1)\\wedge(\\mu \\le 1/2)$.\n\n- Test Case C:\n  - $L = 10{,}000$, $\\Delta x = 50$, $\\kappa = 10^{-6}$, $u = 0.05/31557600$, $\\phi = 0.3$.\n  - With $\\Delta t = 0.2\\,\\Delta t_{\\max}$ and $t_{\\mathrm{end}} = 100\\,\\Delta t$, compute $R = E_{\\mathrm{Strang}}/E_{\\mathrm{Lie}}$.\n\nAll time quantities must be expressed in seconds. The final printed output must be a single line in the format $[p_{\\mathrm{Lie}}^{(A)},p_{\\mathrm{Strang}}^{(A)},\\Delta t_{\\max}^{(B)},r^{(B)},\\mu^{(B)},S^{(B)},R^{(C)}]$.", "answer": "```python\nimport numpy as np\n\ndef upwind_advection_step(T, u, dx, dt):\n    \"\"\"First-order upwind advection with periodic boundaries.\"\"\"\n    r = u * dt / dx\n    if u = 0.0:\n        return T - r * (T - np.roll(T, 1))\n    else:\n        return T - r * (np.roll(T, -1) - T)\n\ndef diffusion_step(T, kappa, dx, dt):\n    \"\"\"Explicit forward Euler diffusion (FTCS) with periodic boundaries.\"\"\"\n    mu = kappa * dt / (dx * dx)\n    return T + mu * (np.roll(T, -1) - 2.0 * T + np.roll(T, 1))\n\ndef lie_splitting(T0, u, kappa, dx, dt, nsteps):\n    \"\"\"Advance by nsteps of Lie splitting: A(dt) then D(dt).\"\"\"\n    T = T0.copy()\n    for _ in range(nsteps):\n        T = upwind_advection_step(T, u, dx, dt)\n        T = diffusion_step(T, kappa, dx, dt)\n    return T\n\ndef strang_splitting(T0, u, kappa, dx, dt, nsteps):\n    \"\"\"Advance by nsteps of Strang splitting: A(dt/2), D(dt), A(dt/2).\"\"\"\n    T = T0.copy()\n    half_dt = 0.5 * dt\n    for _ in range(nsteps):\n        T = upwind_advection_step(T, u, dx, half_dt)\n        T = diffusion_step(T, kappa, dx, dt)\n        T = upwind_advection_step(T, u, dx, half_dt)\n    return T\n\ndef exact_solution_fft(T0, u, kappa, L, dx, t):\n    \"\"\"Exact periodic solution via discrete Fourier transform.\"\"\"\n    N = T0.size\n    # Wavenumbers in radians per meter\n    k = 2.0 * np.pi * np.fft.fftfreq(N, d=dx)\n    T0_hat = np.fft.fft(T0)\n    phase = np.exp(-(kappa * (k ** 2)) * t) * np.exp(-1j * k * u * t)\n    T_hat_t = T0_hat * phase\n    T_t = np.fft.ifft(T_hat_t).real\n    return T_t\n\ndef initial_condition(x, L, phi):\n    \"\"\"Initial condition: cos(2π x/L) + 0.5 cos(4π x/L + phi).\"\"\"\n    return np.cos(2.0 * np.pi * x / L) + 0.5 * np.cos(4.0 * np.pi * x / L + phi)\n\ndef rel_l2_error(a, b):\n    denom = np.linalg.norm(b)\n    if denom == 0.0:\n        return np.inf\n    return np.linalg.norm(a - b) / denom\n\ndef combined_dt_max(dx, u, kappa):\n    \"\"\"Combined explicit stability limit: min(dx/|u|, dx^2/(2*kappa)).\"\"\"\n    adv = np.inf if u == 0.0 else dx / abs(u)\n    diff = (dx * dx) / (2.0 * kappa)\n    return min(adv, diff)\n\ndef observed_order(errors_dt, errors_dt2):\n    \"\"\"Compute observed order p = log(E(dt)/E(dt/2))/log(2).\"\"\"\n    return np.log(errors_dt / errors_dt2) / np.log(2.0)\n\ndef run_test_case_A():\n    # Parameters\n    L = 10000.0\n    dx = 50.0\n    kappa = 1e-6\n    seconds_per_year = 31557600.0\n    u = 0.05 / seconds_per_year  # 0.05 m/yr in m/s\n    phi = 0.3\n    N = int(round(L / dx))\n    x = np.arange(N) * dx\n    T0 = initial_condition(x, L, phi)\n\n    dt_max = combined_dt_max(dx, u, kappa)\n    dt = 0.4 * dt_max\n    dt2 = 0.5 * dt\n    nsteps = 100\n    tend = nsteps * dt\n\n    # Lie splitting errors at dt and dt/2\n    T_lie_dt = lie_splitting(T0, u, kappa, dx, dt, nsteps)\n    T_exact = exact_solution_fft(T0, u, kappa, L, dx, tend)\n    E_lie_dt = rel_l2_error(T_lie_dt, T_exact)\n\n    nsteps2 = int(2 * nsteps)  # to keep same tend\n    T_lie_dt2 = lie_splitting(T0, u, kappa, dx, dt2, nsteps2)\n    E_lie_dt2 = rel_l2_error(T_lie_dt2, T_exact)\n\n    p_lie = observed_order(E_lie_dt, E_lie_dt2)\n\n    # Strang splitting errors at dt and dt/2\n    T_strang_dt = strang_splitting(T0, u, kappa, dx, dt, nsteps)\n    E_strang_dt = rel_l2_error(T_strang_dt, T_exact)\n\n    T_strang_dt2 = strang_splitting(T0, u, kappa, dx, dt2, nsteps2)\n    E_strang_dt2 = rel_l2_error(T_strang_dt2, T_exact)\n\n    p_strang = observed_order(E_strang_dt, E_strang_dt2)\n\n    return float(p_lie), float(p_strang)\n\ndef run_test_case_B():\n    L = 200000.0\n    dx = 1000.0\n    kappa = 1e-6\n    seconds_per_year = 31557600.0\n    u = 0.08 / seconds_per_year  # 0.08 m/yr in m/s\n\n    dt_max = combined_dt_max(dx, u, kappa)\n    dt = 0.99 * dt_max\n    r = abs(u) * dt / dx\n    mu = kappa * dt / (dx * dx)\n    stable = (r = 1.0) and (mu = 0.5)\n    return float(dt_max), float(r), float(mu), bool(stable)\n\ndef run_test_case_C():\n    L = 10000.0\n    dx = 50.0\n    kappa = 1e-6\n    seconds_per_year = 31557600.0\n    u = 0.05 / seconds_per_year  # 0.05 m/yr in m/s\n    phi = 0.3\n    N = int(round(L / dx))\n    x = np.arange(N) * dx\n    T0 = initial_condition(x, L, phi)\n\n    dt_max = combined_dt_max(dx, u, kappa)\n    dt = 0.2 * dt_max\n    nsteps = 100\n    tend = nsteps * dt\n\n    T_exact = exact_solution_fft(T0, u, kappa, L, dx, tend)\n\n    T_lie = lie_splitting(T0, u, kappa, dx, dt, nsteps)\n    E_lie = rel_l2_error(T_lie, T_exact)\n\n    T_strang = strang_splitting(T0, u, kappa, dx, dt, nsteps)\n    E_strang = rel_l2_error(T_strang, T_exact)\n\n    R = E_strang / E_lie if E_lie != 0.0 else np.nan\n    return float(R)\n\ndef solve():\n    # Run all test cases and aggregate results in the specified order.\n    p_lie_A, p_strang_A = run_test_case_A()\n    dtmax_B, r_B, mu_B, S_B = run_test_case_B()\n    R_C = run_test_case_C()\n\n    results = [p_lie_A, p_strang_A, dtmax_B, r_B, mu_B, S_B, R_C]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3590410"}]}