{"hands_on_practices": [{"introduction": "The Crank-Nicolson scheme is celebrated for its second-order accuracy and unconditional stability, but it harbors a significant flaw: it can produce severe, non-physical oscillations when applied to problems with sharp gradients or discontinuities, such as the initial thermal state of a magmatic dike. This exercise provides hands-on experience in diagnosing and mitigating these oscillations using common \"start-up\" strategies. By implementing and comparing a pure Crank-Nicolson method against a more dissipative backward Euler start-up and a time-filtering approach, you will develop a practical understanding of how to ensure the physical realism of your simulations in the face of non-smooth initial data [@problem_id:3616320].", "problem": "Consider the one-dimensional heat conduction equation (a prototypical parabolic partial differential equation used in computational geophysics) on a finite line segment representing a symmetric dike-cooling benchmark. Work in a nondimensional setting in which thermal diffusivity, space, time, and temperature are nondimensional. The problem is posed on the spatial domain $x \\in [-L,L]$ with Dirichlet boundary conditions $u(-L,t)=T_c$ and $u(L,t)=T_c$, and with a discontinuous initial condition representing a hot dike embedded in a cold host:\n$$\n\\frac{\\partial u}{\\partial t} = \\kappa \\frac{\\partial^2 u}{\\partial x^2}, \\quad u(x,0) = \\begin{cases}\nT_h,  |x|\\le a,\\\\\nT_c,  |x|a,\n\\end{cases}\n\\quad u(-L,t)=T_c,\\; u(L,t)=T_c.\n$$\nHere $u(x,t)$ is the nondimensional temperature, $\\kappa$ is the nondimensional thermal diffusivity, $T_h$ is the nondimensional hot temperature, $T_c$ is the nondimensional cold temperature, and $a$ is the nondimensional half-width of the dike. Because $u(x,0)$ is discontinuous, nonphysical Gibbs-like oscillations are known to arise with certain time discretizations, particularly with the trapezoidal rule also known as the Crank–Nicolson method. Your task is to investigate three start-up strategies for the Crank–Nicolson method over early times and to quantitatively compare their behavior in terms of the $L^{\\infty}$ overshoot and $L^2$ error.\n\nYou must implement a uniform grid in space with spacing $\\Delta x$ and a uniform time step $\\Delta t$. Consider the following three strategies:\n- Pure Crank–Nicolson (CN): Apply the Crank–Nicolson scheme at all time steps starting at $t=0$.\n- Backward Euler to Crank–Nicolson (BE$\\rightarrow$CN): Apply a specified number $m$ of start-up steps with Backward Euler, then switch to Crank–Nicolson for the remaining steps. This approach is sometimes referred to as Rannacher start-up in the numerical analysis literature.\n- Crank–Nicolson with a time filter (CN+TF): At each time step $n \\ge 1$, after computing the Crank–Nicolson update $u^{n+1}$, apply a three-level time filter to the interior grid values,\n$$\nu^{n+1} \\leftarrow u^{n+1} + \\alpha\\left(u^{n} - 2u^{n+1} + u^{n-1}\\right),\n$$\nwith a given filter strength $\\alpha$. At $n=0$, use $u^{-1}=u^{0}$ for the filter if needed.\n\nYou must compute two quantitative diagnostics over the early time window $t \\in [0,T_{\\mathrm{end}}]$:\n- The $L^{\\infty}$ overshoot magnitude over the whole early-time evolution, defined as\n$$\n\\max_{0\\le n\\le N}\\left(\\max_x u^n(x) - \\max_x u^0(x),\\,0\\right),\n$$\nwhich measures any positive excursion above the initial maximum value. Report this as a nonnegative scalar.\n- The $L^2$ error at $t=T_{\\mathrm{end}}$ computed against the infinite-domain analytical solution for the given discontinuous initial condition,\n$$\nu_{\\mathrm{exact}}(x,t) = T_c + \\frac{T_h - T_c}{2}\\left[\\operatorname{erf}\\!\\left(\\frac{x+a}{2\\sqrt{\\kappa t}}\\right) - \\operatorname{erf}\\!\\left(\\frac{x-a}{2\\sqrt{\\kappa t}}\\right)\\right],\n$$\nusing the discrete $L^2$ norm on the full grid (including endpoints) with weight $\\Delta x$:\n$$\n\\|u(\\cdot,T_{\\mathrm{end}})-u_{\\mathrm{exact}}(\\cdot,T_{\\mathrm{end}})\\|_{2} = \\left(\\Delta x \\sum_j \\left[u(x_j,T_{\\mathrm{end}})-u_{\\mathrm{exact}}(x_j,T_{\\mathrm{end}})\\right]^2\\right)^{1/2}.\n$$\nHere $\\operatorname{erf}(\\cdot)$ denotes the Gauss error function. Assume the boundaries are sufficiently far that the infinite-domain solution is a valid reference over the specified early-time windows.\n\nYour spatial discretization must use a standard second-order central finite-difference approximation for the Laplacian on the interior nodes with Dirichlet boundary conditions at the endpoints, and your time discretizations must implement the fully implicit Backward Euler scheme and the Crank–Nicolson scheme as defined by their standard two-level formulations. All quantities are nondimensional, so no physical units are required.\n\nTest suite. For each parameter set below, run all three strategies and compute, for each strategy, the pair consisting of the $L^{\\infty}$ overshoot over $t \\in [0,T_{\\mathrm{end}}]$ and the $L^2$ error at $t=T_{\\mathrm{end}}$. The spatial grid should be $x_j = -L + j \\Delta x$ for $j=0,1,\\dots,N_x-1$ where $N_x = 2L/\\Delta x + 1$ is assumed to be an integer. The time grid should be $t^n = n\\Delta t$ for $n=0,1,\\dots,N$ where $N=T_{\\mathrm{end}}/\\Delta t$ is assumed to be an integer. Use the following three cases:\n- Case A (coarse time step to induce oscillations): $L=5$, $a=1$, $\\kappa=1$, $\\Delta x=0.02$, $\\Delta t=0.02$, $T_{\\mathrm{end}}=0.1$, $T_h=1$, $T_c=0$, $m=2$, $\\alpha=0.1$.\n- Case B (moderate time step): $L=5$, $a=0.5$, $\\kappa=1$, $\\Delta x=0.02$, $\\Delta t=0.002$, $T_{\\mathrm{end}}=0.04$, $T_h=1$, $T_c=0$, $m=2$, $\\alpha=0.1$.\n- Case C (fine resolution): $L=5$, $a=0.5$, $\\kappa=1$, $\\Delta x=0.01$, $\\Delta t=0.0001$, $T_{\\mathrm{end}}=0.01$, $T_h=1$, $T_c=0$, $m=2$, $\\alpha=0.1$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Concatenate the six floating-point results for each case in the order\n$$\n[\\text{overshoot}_{\\mathrm{CN}},\\; \\|e\\|_{2,\\mathrm{CN}},\\; \\text{overshoot}_{\\mathrm{BE\\rightarrow CN}},\\; \\|e\\|_{2,\\mathrm{BE\\rightarrow CN}},\\; \\text{overshoot}_{\\mathrm{CN+TF}},\\; \\|e\\|_{2,\\mathrm{CN+TF}}],\n$$\nand then list Case A, then Case B, then Case C, resulting in a flat list of $18$ numbers:\n$$\n[\\text{A}_{1},\\text{A}_{2},\\dots,\\text{A}_{6},\\text{B}_{1},\\dots,\\text{B}_{6},\\text{C}_{1},\\dots,\\text{C}_{6}].\n$$\nNo additional text should be printed. All computations and outputs are nondimensional scalars as specified above.", "solution": "The problem requires the numerical solution of the one-dimensional heat conduction equation, a parabolic partial differential equation (PDE), given a discontinuous initial condition. We will investigate three numerical strategies designed to handle the Gibbs-like oscillations that can arise from such initial data, particularly with the Crank-Nicolson method. The solution will be developed by first discretizing the PDE in space and time, then implementing the specified numerical schemes, and finally computing the required diagnostic metrics.\n\nThe governing PDE is:\n$$\n\\frac{\\partial u}{\\partial t} = \\kappa \\frac{\\partial^2 u}{\\partial x^2}\n$$\non the domain $x \\in [-L, L]$ and $t \\ge 0$. The initial condition is a step function:\n$$\nu(x,0) = \\begin{cases}\nT_h,  |x|\\le a,\\\\\nT_c,  |x|a,\n\\end{cases}\n$$\nand the Dirichlet boundary conditions are $u(-L,t)=T_c$ and $u(L,t)=T_c$.\n\nFirst, we discretize the spatial domain into a uniform grid with $N_x$ points $x_j = -L + j \\Delta x$ for $j=0, 1, \\dots, N_x-1$, where $\\Delta x = 2L / (N_x-1)$. The time domain is discretized as $t^n = n \\Delta t$ for $n=0, 1, \\dots, N$, where $\\Delta t = T_{\\mathrm{end}}/N$. Let $u_j^n$ denote the numerical approximation of $u(x_j, t^n)$.\n\nThe second spatial derivative is approximated using a second-order central finite difference for the interior grid points ($j=1, \\dots, N_x-2$):\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{x_j, t^n} \\approx \\frac{u_{j-1}^n - 2u_j^n + u_{j+1}^n}{(\\Delta x)^2}\n$$\nSubstituting this into the PDE yields a system of ordinary differential equations (ODEs), a method known as the method of lines:\n$$\n\\frac{du_j}{dt} = \\frac{\\kappa}{(\\Delta x)^2} (u_{j-1} - 2u_j + u_{j+1})\n$$\nWe can express the time evolution using a general $\\theta$-scheme:\n$$\n\\frac{u_j^{n+1} - u_j^n}{\\Delta t} = \\frac{\\kappa}{(\\Delta x)^2} \\left[ \\theta(u_{j-1}^{n+1} - 2u_j^{n+1} + u_{j+1}^{n+1}) + (1-\\theta)(u_{j-1}^n - 2u_j^n + u_{j+1}^n) \\right]\n$$\nwhere $\\theta=0$ gives the Forward Euler method, $\\theta=1$ gives the Backward Euler method, and $\\theta=1/2$ gives the Crank-Nicolson method. Let $\\lambda = \\frac{\\kappa \\Delta t}{(\\Delta x)^2}$ be the non-dimensional diffusion number. Rearranging the equation to group terms at time level $n+1$ on the left-hand side (LHS) and terms at time level $n$ on the right-hand side (RHS) gives:\n$$\n-\\theta\\lambda u_{j-1}^{n+1} + (1+2\\theta\\lambda)u_j^{n+1} - \\theta\\lambda u_{j+1}^{n+1} = (1-\\theta)\\lambda u_{j-1}^n + (1-2(1-\\theta)\\lambda)u_j^n + (1-\\theta)\\lambda u_{j+1}^n\n$$\nThis represents a tridiagonal system of linear equations for the unknown values $u_j^{n+1}$ at the interior grid points.\n\nThe three strategies are implemented as follows:\n\n1.  **Pure Crank–Nicolson (CN)**: This corresponds to $\\theta = 1/2$. The scheme is applied at every time step. The system for the interior nodes becomes:\n    $$\n    -\\frac{\\lambda}{2} u_{j-1}^{n+1} + (1+\\lambda) u_j^{n+1} - \\frac{\\lambda}{2} u_{j+1}^{n+1} = \\frac{\\lambda}{2} u_{j-1}^{n} + (1-\\lambda) u_j^{n} + \\frac{\\lambda}{2} u_{j+1}^{n}\n    $$\n    This method is unconditionally stable and second-order accurate in time, but it is known to produce spurious oscillations when applied to problems with non-smooth initial data, as the scheme's damping of high-frequency modes approaches zero.\n\n2.  **Backward Euler to Crank–Nicolson (BE$\\rightarrow$CN)**: This strategy uses the Backward Euler (BE) scheme for the first $m$ time steps and then switches to Crank-Nicolson. The BE scheme corresponds to $\\theta=1$:\n    $$\n    -\\lambda u_{j-1}^{n+1} + (1+2\\lambda) u_j^{n+1} - \\lambda u_{j+1}^{n+1} = u_j^n\n    $$\n    BE is first-order in time and strongly dissipative (L-stable), which effectively damps the high-frequency oscillations arising from the initial discontinuity. After a few initial BE steps, the numerical solution is smoothed, and one can switch to the more accurate CN scheme for the remainder of the simulation.\n\n3.  **Crank–Nicolson with a Time Filter (CN+TF)**: This approach applies a filter after each standard CN step to suppress oscillations. At each time step $n$, we first compute a provisional solution $\\tilde{u}^{n+1}$ using the CN scheme. Then, we apply a three-level filter to the interior nodes:\n    $$\n    u^{n+1} \\leftarrow \\tilde{u}^{n+1} + \\alpha(u^{n} - 2\\tilde{u}^{n+1} + u^{n-1})\n    $$\n    The filter strength is given by $\\alpha$. For the first step ($n=0$), we require a value at $t^{-1} = -\\Delta t$. As specified, we set $u^{-1} = u^0$, which simplifies the filter for the first step to $u^1 \\leftarrow \\tilde{u}^1 + \\alpha(u^0 - 2\\tilde{u}^1 + u^0) = (1-2\\alpha)\\tilde{u}^1 + 2\\alpha u^0$.\n\nFor all strategies, the resulting tridiagonal systems of equations for the interior nodes are solved at each time step using an efficient algorithm, such as `scipy.linalg.solve_banded`. Boundary conditions $u_0^{n+1} = T_c$ and $u_{N_x-1}^{n+1} = T_c$ are incorporated into the first and last equations of the linear system. Since $T_c=0$ in the test cases, these boundary terms simply become zero.\n\nThe diagnostics are computed as follows:\n-   **$L^{\\infty}$ Overshoot**: The maximum temperature is tracked at each time step $n$. The overshoot at step $n$ is $\\max_j u_j^n - \\max_j u_j^0$. The final reported value is the maximum of this quantity over all time steps $n \\in [0, N]$, floored at $0$.\n-   **$L^2$ Error**: At the final time $T_{\\mathrm{end}}$, the error is computed against the provided analytical solution for an infinite domain:\n    $$\n    u_{\\mathrm{exact}}(x,t) = T_c + \\frac{T_h - T_c}{2}\\left[\\operatorname{erf}\\!\\left(\\frac{x+a}{2\\sqrt{\\kappa t}}\\right) - \\operatorname{erf}\\!\\left(\\frac{x-a}{2\\sqrt{\\kappa t}}\\right)\\right]\n    $$\n    The discrete $L^2$ norm is then calculated over all grid points, including boundaries:\n    $$\n    \\|e\\|_{2} = \\left(\\Delta x \\sum_{j=0}^{N_x-1} \\left[u_j^N - u_{\\mathrm{exact}}(x_j, T_{\\mathrm{end}})\\right]^2\\right)^{1/2}\n    $$\nThe overall implementation involves a main function that iterates through the provided test cases. For each case, it sets up the grid and initial conditions, then runs a simulation for each of the three strategies. Each simulation performs the time-stepping loop, solves the linear system at each step, and applies any required filtering. After the simulation, the diagnostics are computed and collected for the final output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\nfrom scipy.special import erf\n\ndef setup_simulation(params):\n    \"\"\"Sets up grid and initial conditions.\"\"\"\n    L, a, kappa, dx, dt, T_end, Th, Tc, m, alpha = params\n    \n    # Grid setup\n    Nx = int(round(2 * L / dx)) + 1\n    x = np.linspace(-L, L, Nx)\n    Nt = int(round(T_end / dt))\n    \n    # Nondimensional diffusion number\n    lambda_ = kappa * dt / (dx**2)\n    \n    # Initial Condition\n    u0 = np.full(Nx, Tc)\n    u0[np.abs(x) = a] = Th\n    \n    return x, Nx, Nt, lambda_, u0, Tc\n\ndef get_analytical_solution(x, t, params):\n    \"\"\"Computes the analytical solution.\"\"\"\n    L, a, kappa, dx, dt, T_end, Th, Tc, m, alpha = params\n    if t == 0:\n        # Handle t=0 case separately to avoid division by zero\n        u_exact = np.full_like(x, Tc)\n        u_exact[np.abs(x) = a] = Th\n        return u_exact\n    \n    denom = 2.0 * np.sqrt(kappa * t)\n    arg1 = (x + a) / denom\n    arg2 = (x - a) / denom\n    u_exact = Tc + (Th - Tc) / 2.0 * (erf(arg1) - erf(arg2))\n    return u_exact\n\ndef run_simulation(params, strategy):\n    \"\"\"Runs a single simulation for a given strategy.\"\"\"\n    L, a, kappa, dx, dt, T_end, Th, Tc, m, alpha = params\n    x, Nx, Nt, lambda_, u0, Tc = setup_simulation(params)\n    \n    u_curr = u0.copy()\n    max_initial_temp = np.max(u0)\n    max_overshoot = 0.0\n    \n    num_interior_nodes = Nx - 2\n\n    # --- Strategy-specific setup ---\n    \n    # Pure CN\n    if strategy == 'CN' or strategy == 'CN_TF' or (strategy == 'BE_CN' and Nt  m):\n        ab_cn = np.zeros((3, num_interior_nodes))\n        ab_cn[0, 1:] = -lambda_ / 2.0\n        ab_cn[1, :] = 1.0 + lambda_\n        ab_cn[2, :-1] = -lambda_ / 2.0\n    \n    # BE\n    if strategy == 'BE_CN':\n        if m  0:\n            ab_be = np.zeros((3, num_interior_nodes))\n            ab_be[0, 1:] = -lambda_\n            ab_be[1, :] = 1.0 + 2.0 * lambda_\n            ab_be[2, :-1] = -lambda_\n    \n    # CN+TF\n    if strategy == 'CN_TF':\n        u_prev = u0.copy()\n\n    # --- Time-stepping loop ---\n    for n in range(Nt):\n        # Select scheme for BE-CN\n        if strategy == 'BE_CN' and n  m:\n            ab = ab_be\n            rhs = u_curr[1:-1]\n        else: # CN for all other cases\n            ab = ab_cn\n            rhs = (lambda_ / 2.0) * (u_curr[:-2] + u_curr[2:]) + (1.0 - lambda_) * u_curr[1:-1]\n\n        # Solve for interior nodes\n        u_next_interior = solve_banded((1, 1), ab, rhs)\n        \n        u_next = np.empty(Nx)\n        u_next[0], u_next[-1] = Tc, Tc\n        u_next[1:-1] = u_next_interior\n        \n        # Apply Time Filter if required\n        if strategy == 'CN_TF':\n            u_tilde = u_next.copy()\n            u_next[1:-1] = (1.0 - 2.0 * alpha) * u_tilde[1:-1] + alpha * (u_curr[1:-1] + u_prev[1:-1])\n            u_prev[:] = u_curr\n        \n        # Update solution for next step\n        u_curr[:] = u_next\n        \n        # Update overshoot diagnostic\n        current_max = np.max(u_curr)\n        overshoot = current_max - max_initial_temp\n        if overshoot  max_overshoot:\n            max_overshoot = overshoot\n\n    # --- Final diagnostics ---\n    u_final = u_curr\n    u_exact = get_analytical_solution(x, T_end, params)\n    \n    # L2 Error\n    error_vec = u_final - u_exact\n    l2_error = np.sqrt(dx * np.sum(error_vec**2))\n    \n    return max_overshoot, l2_error\n\ndef solve():\n    \"\"\"Main solver function to run all test cases and print results.\"\"\"\n    test_cases = [\n        # Case A (L, a, kappa, dx, dt, T_end, Th, Tc, m, alpha)\n        (5.0, 1.0, 1.0, 0.02, 0.02, 0.1, 1.0, 0.0, 2, 0.1),\n        # Case B\n        (5.0, 0.5, 1.0, 0.02, 0.002, 0.04, 1.0, 0.0, 2, 0.1),\n        # Case C\n        (5.0, 0.5, 1.0, 0.01, 0.0001, 0.01, 1.0, 0.0, 2, 0.1)\n    ]\n    \n    strategies = ['CN', 'BE_CN', 'CN_TF']\n    \n    all_results = []\n    \n    for case_params in test_cases:\n        for strategy in strategies:\n            overshoot, l2_error = run_simulation(case_params, strategy)\n            all_results.append(overshoot)\n            all_results.append(l2_error)\n            \n    # Format results for printing\n    result_str = \",\".join(f\"{res:.8f}\" for res in all_results)\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "3616320"}, {"introduction": "Choosing an appropriate time step $\\Delta t$ is often seen as an art, but it can be grounded in rigorous analysis. The accuracy of the Crank-Nicolson scheme depends on how well it approximates the true decay of different spatial frequency components (eigenmodes) present in the solution. This advanced exercise moves from using the scheme to designing its application based on first principles. You will perform a modal analysis to derive an explicit relationship between the nondimensional time step $r = \\kappa \\Delta t / \\Delta x^2$ and the numerical error, allowing you to create a time-step controller that precisely meets predefined accuracy targets for both the amplitude and phase of the solution [@problem_id:3616345].", "problem": "Consider the one-dimensional heat conduction problem relevant to tectonic cooling in the lithosphere, governed by the parabolic partial differential equation (PDE)\n$$\n\\frac{\\partial T}{\\partial t}(z,t) \\;=\\; \\kappa \\,\\frac{\\partial^2 T}{\\partial z^2}(z,t) \\;+\\; \\frac{q(z,t)}{\\rho\\,c_p},\n$$\non a finite domain $z \\in [0,L]$ with Dirichlet boundary conditions $T(0,t) = T_s$ and $T(L,t) = T_b$, and an initial condition $T(z,0) = T_{\\mathrm{init}}$. Here $T$ is temperature in $\\mathrm{K}$, $\\kappa$ is thermal diffusivity in $\\mathrm{m}^2/\\mathrm{s}$, $q$ is volumetric heat production in $\\mathrm{W}/\\mathrm{m}^3$, $\\rho$ is density in $\\mathrm{kg}/\\mathrm{m}^3$, and $c_p$ is specific heat capacity in $\\mathrm{J}/(\\mathrm{kg}\\cdot\\mathrm{K})$. The heat production $q(z,t)$ is assumed piecewise constant in depth and undergoes a sudden change at time $t_{\\mathrm{jump}}$: in the upper crustal layer $0 \\le z \\le z_h$, $q(z,t) = q_0$ for $t  t_{\\mathrm{jump}}$ and $q(z,t) = q_1$ for $t \\ge t_{\\mathrm{jump}}$, while $q(z,t) = 0$ for $z  z_h$.\n\nYour tasks are:\n- Derive and implement a variable time-step Crank–Nicolson (CN) scheme using the generalized trapezoidal rule in time so that second-order accuracy in time is retained for nonuniform time steps. Explicitly handle the source term by evaluating $q(z,t)$ at both ends of each time interval and averaging, and ensure that any time step that would cross the discontinuity at $t_{\\mathrm{jump}}$ is split so that the discontinuity occurs at a time node.\n- Discretize the spatial operator using a second-order centered finite difference on a uniform grid with $M$ nodes, spacing $\\Delta z = L/(M-1)$, and enforce the Dirichlet boundary conditions at $z=0$ and $z=L$ directly.\n- Validate the observed order of accuracy in time by a step-doubling test. For each test case, perform three runs to final time $t_{\\mathrm{final}}$ using nonuniform time-step schedules with base steps $\\Delta t_{\\mathrm{pre}}$ for $t  t_{\\mathrm{jump}}$ and $\\Delta t_{\\mathrm{post}}$ for $t \\ge t_{\\mathrm{jump}}$, and then scaled by factors $1$, $1/2$, and $1/4$. Construct the schedule by marching forward with the applicable base step and, whenever the next step would overrun either $t_{\\mathrm{jump}}$ or $t_{\\mathrm{final}}$, shorten it to land exactly on the breakpoint. Compute the temperature fields $U_{\\Delta t}$, $U_{\\Delta t/2}$, and $U_{\\Delta t/4}$ at $t_{\\mathrm{final}}$, and estimate the observed order\n$$\np \\;=\\; \\frac{\\log\\!\\left(\\frac{\\|U_{\\Delta t} - U_{\\Delta t/2}\\|_2}{\\|U_{\\Delta t/2} - U_{\\Delta t/4}\\|_2}\\right)}{\\log(2)},\n$$\nwhere $\\|\\cdot\\|_2$ denotes the discrete Euclidean norm over all grid nodes.\n\nYou must write a complete, runnable program that carries out the above for the following three scientifically plausible test cases (all physical quantities must be used in SI units internally; years must be converted to seconds using $1\\,\\mathrm{yr} = 365.25 \\times 24 \\times 3600\\,\\mathrm{s}$):\n\n- Test Case A (happy path, nonuniform time steps, jump not aligned with base steps):\n    - $L = 40000\\,\\mathrm{m}$, $M = 101$, $\\kappa = 1.0 \\times 10^{-6}\\,\\mathrm{m}^2/\\mathrm{s}$,\n      $\\rho = 2700\\,\\mathrm{kg}/\\mathrm{m}^3$, $c_p = 1000\\,\\mathrm{J}/(\\mathrm{kg}\\cdot\\mathrm{K})$,\n      $T_s = 273\\,\\mathrm{K}$, $T_b = 1300\\,\\mathrm{K}$, $T_{\\mathrm{init}} = 1300\\,\\mathrm{K}$,\n      $z_h = 15000\\,\\mathrm{m}$, $q_0 = 1.0 \\times 10^{-6}\\,\\mathrm{W}/\\mathrm{m}^3$, $q_1 = 0.3 \\times 10^{-6}\\,\\mathrm{W}/\\mathrm{m}^3$,\n      $t_{\\mathrm{jump}} = 3.0\\,\\mathrm{Myr}$, $t_{\\mathrm{final}} = 10.0\\,\\mathrm{Myr}$,\n      $\\Delta t_{\\mathrm{pre}} = 0.7\\,\\mathrm{Myr}$, $\\Delta t_{\\mathrm{post}} = 1.3\\,\\mathrm{Myr}$.\n\n- Test Case B (boundary case: early jump, smaller domain time, different nonuniform steps):\n    - $L = 50000\\,\\mathrm{m}$, $M = 121$, $\\kappa = 1.0 \\times 10^{-6}\\,\\mathrm{m}^2/\\mathrm{s}$,\n      $\\rho = 2700\\,\\mathrm{kg}/\\mathrm{m}^3$, $c_p = 1000\\,\\mathrm{J}/(\\mathrm{kg}\\cdot\\mathrm{K})$,\n      $T_s = 273\\,\\mathrm{K}$, $T_b = 1200\\,\\mathrm{K}$, $T_{\\mathrm{init}} = 1200\\,\\mathrm{K}$,\n      $z_h = 20000\\,\\mathrm{m}$, $q_0 = 1.5 \\times 10^{-6}\\,\\mathrm{W}/\\mathrm{m}^3$, $q_1 = 0.0\\,\\mathrm{W}/\\mathrm{m}^3$,\n      $t_{\\mathrm{jump}} = 0.2\\,\\mathrm{Myr}$, $t_{\\mathrm{final}} = 5.0\\,\\mathrm{Myr}$,\n      $\\Delta t_{\\mathrm{pre}} = 0.3\\,\\mathrm{Myr}$, $\\Delta t_{\\mathrm{post}} = 0.8\\,\\mathrm{Myr}$.\n\n- Test Case C (edge case: large amplitude change and longer evolution):\n    - $L = 60000\\,\\mathrm{m}$, $M = 151$, $\\kappa = 1.0 \\times 10^{-6}\\,\\mathrm{m}^2/\\mathrm{s}$,\n      $\\rho = 2700\\,\\mathrm{kg}/\\mathrm{m}^3$, $c_p = 1000\\,\\mathrm{J}/(\\mathrm{kg}\\cdot\\mathrm{K})$,\n      $T_s = 273\\,\\mathrm{K}$, $T_b = 1300\\,\\mathrm{K}$, $T_{\\mathrm{init}} = 1300\\,\\mathrm{K}$,\n      $z_h = 25000\\,\\mathrm{m}$, $q_0 = 2.0 \\times 10^{-6}\\,\\mathrm{W}/\\mathrm{m}^3$, $q_1 = 0.2 \\times 10^{-6}\\,\\mathrm{W}/\\mathrm{m}^3$,\n      $t_{\\mathrm{jump}} = 8.0\\,\\mathrm{Myr}$, $t_{\\mathrm{final}} = 20.0\\,\\mathrm{Myr}$,\n      $\\Delta t_{\\mathrm{pre}} = 1.1\\,\\mathrm{Myr}$, $\\Delta t_{\\mathrm{post}} = 2.0\\,\\mathrm{Myr}$.\n\nFor each test case, compute the observed order $p$ as described. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[p_A,p_B,p_C]$. The outputs $p_A$, $p_B$, and $p_C$ must be real numbers (floats) without units. All intermediate quantities in the computation must be handled in SI units, and angles are not involved in this problem. The final outputs are dimensionless.", "solution": "The user requests the derivation and implementation of a variable time-step Crank-Nicolson method to solve a one-dimensional heat conduction problem, followed by a numerical validation of its temporal order of accuracy.\n\n### 1. Problem Specification\n\nThe governing equation is the one-dimensional heat equation with a source term:\n$$\n\\frac{\\partial T}{\\partial t}(z,t) \\;=\\; \\kappa \\,\\frac{\\partial^2 T}{\\partial z^2}(z,t) \\;+\\; S(z,t)\n$$\nwhere $S(z,t) = q(z,t)/(\\rho c_p)$ is the normalized volumetric heat production. The problem is defined on the domain $z \\in [0,L]$ for time $t \\in [0, t_{\\mathrm{final}}]$. The boundary conditions are of Dirichlet type: $T(0,t) = T_s$ and $T(L,t) = T_b$. The initial condition is $T(z,0) = T_{\\mathrm{init}}$.\n\nThe source term $q(z,t)$ is piecewise constant in both space and time:\n$$\nq(z,t) =\n\\begin{cases}\nq_0  \\text{for } 0 \\le z \\le z_h \\text{ and } t  t_{\\mathrm{jump}} \\\\\nq_1  \\text{for } 0 \\le z \\le z_h \\text{ and } t \\ge t_{\\mathrm{jump}} \\\\\n0    \\text{for } z  z_h\n\\end{cases}\n$$\n\n### 2. Numerical Discretization\n\nWe discretize the problem on a uniform spatial grid and a non-uniform temporal grid.\nLet $T_j^n \\approx T(z_j, t_n)$, where $z_j = j \\Delta z$ for $j=0, 1, \\dots, M-1$ with $\\Delta z = L/(M-1)$, and $t_n$ is the time at step $n$.\n\n#### 2.1. Spatial Discretization\n\nThe spatial second derivative is approximated using a second-order centered finite difference scheme for the interior nodes ($j=1, 2, \\dots, M-2$):\n$$\n\\left. \\frac{\\partial^2 T}{\\partial z^2} \\right|_{z_j, t_n} \\approx \\frac{T_{j-1}^n - 2T_j^n + T_{j+1}^n}{(\\Delta z)^2}\n$$\nLet $\\mathbf{U}(t)$ be the vector of temperatures at the $N_{int} = M-2$ interior nodes, i.e., $\\mathbf{U}_j(t) = T_{j+1}(t)$ for $j=0, \\dots, N_{int}-1$. The semi-discretized system of ordinary differential equations (ODEs) can be written in matrix form:\n$$\n\\frac{d\\mathbf{U}}{dt} = \\frac{\\kappa}{(\\Delta z)^2} \\mathbf{A} \\mathbf{U} + \\frac{\\kappa}{(\\Delta z)^2} \\mathbf{b} + \\mathbf{S}(t)\n$$\nHere, $\\mathbf{A}$ is the $N_{int} \\times N_{int}$ tridiagonal matrix representing the discrete Laplacian operator for the interior nodes:\n$$\n\\mathbf{A} = \\begin{pmatrix}\n-2  1  0  \\dots  0 \\\\\n1  -2  1  \\dots  0 \\\\\n0  \\ddots  \\ddots  \\ddots  0 \\\\\n0  \\dots  1  -2  1 \\\\\n0  \\dots  0  1  -2\n\\end{pmatrix}\n$$\nThe vector $\\mathbf{b}$ incorporates the constant Dirichlet boundary conditions:\n$$\n\\mathbf{b} = [T_s, 0, \\dots, 0, T_b]^T\n$$\nAnd $\\mathbf{S}(t)$ is the vector of the source term evaluated at the interior grid points.\n\n#### 2.2. Temporal Discretization\n\nTo retain second-order accuracy with non-uniform time steps $\\Delta t_n = t_{n+1} - t_n$, we apply the trapezoidal rule (Crank-Nicolson method) to the semi-discretized system. Integrating the ODE system from $t_n$ to $t_{n+1}$ yields:\n$$\n\\mathbf{U}^{n+1} - \\mathbf{U}^n = \\int_{t_n}^{t_{n+1}} \\left( \\frac{\\kappa}{(\\Delta z)^2} (\\mathbf{A} \\mathbf{U}(t) + \\mathbf{b}) + \\mathbf{S}(t) \\right) dt\n$$\nApplying the trapezoidal rule to the integral gives:\n$$\n\\frac{\\mathbf{U}^{n+1} - \\mathbf{U}^n}{\\Delta t_n} = \\frac{1}{2} \\left[ \\left(\\frac{\\kappa}{(\\Delta z)^2} (\\mathbf{A} \\mathbf{U}^{n+1} + \\mathbf{b}) + \\mathbf{S}^{n+1}\\right) + \\left(\\frac{\\kappa}{(\\Delta z)^2} (\\mathbf{A} \\mathbf{U}^{n} + \\mathbf{b}) + \\mathbf{S}^{n}\\right) \\right]\n$$\nThis scheme is unconditionally stable and second-order accurate in time. Rearranging the terms to solve for the unknown state $\\mathbf{U}^{n+1}$:\n$$\n\\left(\\mathbf{I} - \\frac{\\kappa \\Delta t_n}{2(\\Delta z)^2} \\mathbf{A}\\right) \\mathbf{U}^{n+1} = \\left(\\mathbf{I} + \\frac{\\kappa \\Delta t_n}{2(\\Delta z)^2} \\mathbf{A}\\right) \\mathbf{U}^{n} + \\frac{\\kappa \\Delta t_n}{(\\Delta z)^2} \\mathbf{b} + \\frac{\\Delta t_n}{2} (\\mathbf{S}^{n+1} + \\mathbf{S}^{n})\n$$\nLetting $\\mu = \\frac{\\kappa \\Delta t_n}{2(\\Delta z)^2}$, the equation takes the form of a linear system $\\mathbf{L} \\mathbf{U}^{n+1} = \\mathbf{R}$, where:\n$$\n\\mathbf{L} = \\mathbf{I} - \\mu \\mathbf{A}\n$$\n$$\n\\mathbf{R} = (\\mathbf{I} + \\mu \\mathbf{A})\\mathbf{U}^{n} + 2\\mu \\mathbf{b} + \\frac{\\Delta t_n}{2} (\\mathbf{S}^{n+1} + \\mathbf{S}^{n})\n$$\nThe matrix $\\mathbf{L}$ is tridiagonal, which allows for an efficient solution of the linear system in $O(M)$ time using an algorithm such as the Thomas algorithm.\n\n### 3. Time-Stepping and Source Term Management\n\nThe time stepping must be constructed to ensure that a time node coincides with the discontinuity at $t_{\\mathrm{jump}}$. Starting from $t=0$, a time step $\\Delta t$ is chosen based on whether the current time is before or after $t_{\\mathrm{jump}}$. This step is then shortened if it would step over $t_{\\mathrm{jump}}$ or $t_{\\mathrm{final}}$. Specifically, for a current time $t_{curr}$, the next step is $\\Delta t_{actual} = \\min(\\Delta t_{base}, t_{break} - t_{curr})$, where $t_{break}$ is the next significant time point ($t_{\\mathrm{jump}}$ or $t_{\\mathrm{final}}$). The source vector $\\mathbf{S}(t)$ is computed at each time point based on the value of $q(z,t)$ at the spatial nodes.\n\n### 4. Accuracy Validation\n\nThe observed order of accuracy, $p$, is determined using a step-doubling test (a form of Richardson extrapolation). The simulation is run to $t_{\\mathrm{final}}$ three times with base time step sizes $(\\Delta t_{\\mathrm{pre}}, \\Delta t_{\\mathrm{post}})$, scaled by factors of $1$, $1/2$, and $1/4$, yielding solutions $U_{\\Delta t}$, $U_{\\Delta t/2}$, and $U_{\\Delta t/4}$. The order $p$ is then estimated by:\n$$\np \\;=\\; \\frac{\\log\\!\\left(\\frac{\\|U_{\\Delta t} - U_{\\Delta t/2}\\|_2}{\\|U_{\\Delta t/2} - U_{\\Delta t/4}\\|_2}\\right)}{\\log(2)}\n$$\nwhere $\\|\\cdot\\|_2$ is the Euclidean norm computed over all spatial grid nodes. For a second-order scheme, we expect $p \\approx 2$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and compute the observed order of accuracy 'p' for each.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        { # Test Case A\n            'L': 40000.0, 'M': 101, 'kappa': 1.0e-6, 'rho': 2700.0, 'cp': 1000.0,\n            'Ts': 273.0, 'Tb': 1300.0, 'T_init': 1300.0, 'zh': 15000.0,\n            'q0': 1.0e-6, 'q1': 0.3e-6, 't_jump': 3.0, 't_final': 10.0,\n            'dt_pre': 0.7, 'dt_post': 1.3\n        },\n        { # Test Case B\n            'L': 50000.0, 'M': 121, 'kappa': 1.0e-6, 'rho': 2700.0, 'cp': 1000.0,\n            'Ts': 273.0, 'Tb': 1200.0, 'T_init': 1200.0, 'zh': 20000.0,\n            'q0': 1.5e-6, 'q1': 0.0, 't_jump': 0.2, 't_final': 5.0,\n            'dt_pre': 0.3, 'dt_post': 0.8\n        },\n        { # Test Case C\n            'L': 60000.0, 'M': 151, 'kappa': 1.0e-6, 'rho': 2700.0, 'cp': 1000.0,\n            'Ts': 273.0, 'Tb': 1300.0, 'T_init': 1300.0, 'zh': 25000.0,\n            'q0': 2.0e-6, 'q1': 0.2e-6, 't_jump': 8.0, 't_final': 20.0,\n            'dt_pre': 1.1, 'dt_post': 2.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        p = compute_p_for_case(case)\n        results.append(p)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\ndef compute_p_for_case(case_params):\n    \"\"\"\n    Computes the observed order of accuracy 'p' for a single test case.\n    \"\"\"\n    dt_pre_base = case_params['dt_pre']\n    dt_post_base = case_params['dt_post']\n    \n    # Run 1: Base time steps\n    T1 = run_simulation(case_params, dt_pre_base, dt_post_base)\n    # Run 2: Time steps halved\n    T2 = run_simulation(case_params, dt_pre_base / 2.0, dt_post_base / 2.0)\n    # Run 3: Time steps quartered\n    T3 = run_simulation(case_params, dt_pre_base / 4.0, dt_post_base / 4.0)\n\n    # Compute the L2 norms of the differences between solutions.\n    norm12 = np.linalg.norm(T1 - T2)\n    norm23 = np.linalg.norm(T2 - T3)\n\n    # Calculate the observed order of accuracy 'p'.\n    if norm23 == 0.0:\n        return np.nan if norm12  0.0 else 2.0 # Converged solution\n    \n    p = np.log(norm12 / norm23) / np.log(2.0)\n    return p\n\ndef run_simulation(params, dt_pre_myr, dt_post_myr):\n    \"\"\"\n    Performs a single heat conduction simulation for a given set of parameters.\n    \"\"\"\n    # Unpack parameters\n    L, M, kappa, rho, cp = params['L'], params['M'], params['kappa'], params['rho'], params['cp']\n    Ts, Tb, T_init, zh = params['Ts'], params['Tb'], params['T_init'], params['zh']\n    q0, q1 = params['q0'], params['q1']\n    t_jump_myr, t_final_myr = params['t_jump'], params['t_final']\n\n    # Unit conversions (Myr - s)\n    s_per_yr = 365.25 * 24.0 * 3600.0\n    t_jump = t_jump_myr * 1e6 * s_per_yr\n    t_final = t_final_myr * 1e6 * s_per_yr\n    dt_pre = dt_pre_myr * 1e6 * s_per_yr\n    dt_post = dt_post_myr * 1e6 * s_per_yr\n\n    # Spatial grid setup\n    dz = L / (M - 1)\n    z_nodes = np.linspace(0, L, M)\n    num_interior_nodes = M - 2\n    \n    # Initial condition\n    T_initial = np.full(M, T_init)\n    T_initial[0], T_initial[-1] = Ts, Tb\n    U = T_initial[1:-1].copy()\n\n    # Pre-calculate constants and source term configuration\n    alpha_const = kappa / (dz * dz)\n    interior_z = z_nodes[1:-1]\n    source_indices = np.where(interior_z = zh)[0]\n    \n    def get_S_vector(t_s):\n        q_val = q0 if t_s  t_jump else q1\n        s_val = q_val / (rho * cp)\n        S_vec = np.zeros(num_interior_nodes)\n        if s_val != 0.0:\n            S_vec[source_indices] = s_val\n        return S_vec\n\n    def generate_time_steps(tf, tj, dtp, dtpo):\n        current_t = 0.0\n        while current_t  tf * (1. - 1e-12):\n            dt_base = dtp if current_t  tj else dtpo\n            dt_to_jump = tj - current_t if current_t  tj else float('inf')\n            dt_to_final = tf - current_t\n            \n            dt = min(dt_base, dt_to_jump, dt_to_final)\n            if dt = 1e-9: break\n            \n            next_t = current_t + dt\n            yield current_t, next_t\n            current_t = next_t\n\n    # --- Time-stepping loop ---\n    for t_curr, t_next in generate_time_steps(t_final, t_jump, dt_pre, dt_post):\n        dt = t_next - t_curr\n        mu = 0.5 * dt * alpha_const\n\n        # --- Assemble RHS vector ---\n        # 1. (I + mu*A_hat) * U_n term\n        rhs = (1.0 - 2.0 * mu) * U\n        if num_interior_nodes  1:\n            rhs[1:] += mu * U[:-1]\n            rhs[:-1] += mu * U[1:]\n\n        # 2. Boundary condition contribution: 2*mu*b\n        if num_interior_nodes  0:\n            rhs[0] += 2.0 * mu * Ts\n            rhs[-1] += 2.0 * mu * Tb\n        \n        # 3. Source term contribution\n        S_n = get_S_vector(t_curr)\n        S_n_1 = get_S_vector(t_next)\n        rhs += 0.5 * dt * (S_n + S_n_1)\n\n        # --- Solve the linear system ---\n        if num_interior_nodes  0:\n            l_and_u = 1\n            ab = np.zeros((3, num_interior_nodes))\n            ab[0, 1:] = -mu\n            ab[1, :] = 1.0 + 2.0 * mu\n            ab[2, :-1] = -mu\n            U = solve_banded((l_and_u, l_and_u), ab, rhs, overwrite_ab=True, overwrite_b=True)\n\n    # Reconstruct full temperature vector at t_final\n    T_final = np.empty(M)\n    T_final[0], T_final[-1] = Ts, Tb\n    if num_interior_nodes  0:\n        T_final[1:-1] = U\n    \n    return T_final\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3616345"}, {"introduction": "Choosing an appropriate time step $\\Delta t$ is often seen as an art, but it can be grounded in rigorous analysis. The accuracy of the Crank-Nicolson scheme depends on how well it approximates the true decay of different spatial frequency components (eigenmodes) present in the solution. This advanced exercise moves from using the scheme to designing its application based on first principles. You will perform a modal analysis to derive an explicit relationship between the nondimensional time step $r = \\kappa \\Delta t / \\Delta x^2$ and the numerical error, allowing you to create a time-step controller that precisely meets predefined accuracy targets for both the amplitude and phase of the solution [@problem_id:3616370].", "problem": "You are to design and implement an accuracy-based time-step controller for the Crank–Nicolson scheme applied to parabolic equations in the context of lithospheric cooling. The underlying physical model is the one-dimensional thermal diffusion equation for temperature evolution in a finite slab representing a segment of lithosphere,\n$$\n\\frac{\\partial u}{\\partial t} = \\kappa \\frac{\\partial^2 u}{\\partial x^2},\n$$\nposed on the interval $x \\in [0,L]$ with homogeneous Dirichlet boundary conditions $u(0,t) = 0$ and $u(L,t) = 0$. Here, $u(x,t)$ is the temperature, $\\kappa$ is the thermal diffusivity, and $L$ is the slab thickness. The discretization in space uses a uniform grid with $N$ interior points and grid spacing $\\Delta x = L/(N+1)$, producing the semi-discrete system\n$$\n\\frac{d\\mathbf{u}}{dt} = \\frac{\\kappa}{\\Delta x^2} \\mathbf{L}\\,\\mathbf{u},\n$$\nwhere $\\mathbf{L}$ is the classic second-difference matrix with homogeneous Dirichlet conditions. Time integration uses the Crank–Nicolson method with nondimensional parameter $r = \\kappa\\,\\Delta t/\\Delta x^2$, where $\\Delta t$ is the time step.\n\nYour task is to calibrate the nondimensional parameter $r$ to control numerical errors for decaying eigenmodes of the semi-discrete operator $\\mathbf{L}$, focusing on the worst-case mode in the spectrum. The calibration must enforce two accuracy requirements:\n\n1. Amplitude error control: For the worst-case discrete eigenmode of $\\mathbf{L}$ with eigenvalue $\\mu_{\\max}  0$, define the nondimensional per-step decay $s = r|\\mu_{\\max}|$ and let the exact semi-discrete per-step amplitude be $A_{\\mathrm{exact}}(s) = e^{-s}$. Define the Crank–Nicolson per-step amplification factor $A_{\\mathrm{CN}}(s)$, and let the per-step relative amplitude error be\n$$\nE_{\\mathrm{amp}}(s) = \\frac{|A_{\\mathrm{CN}}(s) - A_{\\mathrm{exact}}(s)|}{A_{\\mathrm{exact}}(s)}.\n$$\nYou must choose $r$ such that $E_{\\mathrm{amp}}(s) \\le \\varepsilon_{\\mathrm{amp}}$ for the worst-case mode, where $\\varepsilon_{\\mathrm{amp}}$ is a given tolerance. This condition must be enforced per time step.\n\n2. Phase error control: Since thermal diffusion produces monotonic decay without oscillations, the discrete per-step amplification must remain nonnegative for the worst-case mode to avoid unphysical sign reversals. Define the per-step \"phase\" as the argument of the amplification factor measured in radians. The controller must ensure this phase equals $0$ for the worst-case mode, which is equivalent to requiring a nonnegative amplification factor. Express the phase requirement in radians and enforce it as a Boolean constraint.\n\nYou must derive the discrete worst-mode eigenvalue $|\\mu_{\\max}|$ of the second-difference matrix $\\mathbf{L}$ for the uniform grid and homogeneous Dirichlet boundary conditions, and use it to construct an algorithm that selects the largest $r$ satisfying both the amplitude error constraint and the non-negativity (zero-phase) constraint. Once $r$ is selected, you must determine the number of time steps $M$ required to cover a target simulation horizon $T$ by using a uniform time step $\\Delta t$ such that $\\Delta t \\le \\Delta t_{\\max}$ implied by the selected $r$ and the grid spacing, with\n$$\n\\Delta t_{\\max} = \\frac{r\\,\\Delta x^2}{\\kappa}.\n$$\nUse $M = \\lceil T / \\Delta t_{\\max} \\rceil$ and then set the actual $\\Delta t = T/M$ to exactly cover $T$. The final nondimensional parameter used in the simulation is\n$$\nr_{\\mathrm{final}} = \\frac{\\kappa\\,\\Delta t}{\\Delta x^2}.\n$$\n\nFor each test case below, compute and report:\n- $r_{\\mathrm{final}}$ (float),\n- $M$ (integer),\n- the worst-mode per-step relative amplitude error $E_{\\mathrm{amp}}(r_{\\mathrm{final}}|\\mu_{\\max}|)$ (float),\n- a Boolean indicating whether the phase constraint is satisfied (nonnegative worst-mode amplification per step),\n- a Boolean indicating whether the amplitude constraint is satisfied (per-step $E_{\\mathrm{amp}} \\le \\varepsilon_{\\mathrm{amp}}$).\n\nAll physical quantities must be handled in International System of Units (SI units): $\\kappa$ in $\\mathrm{m}^2/\\mathrm{s}$, $L$ in $\\mathrm{m}$, $T$ in $\\mathrm{s}$. The phase must be measured in radians. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[[r1,M1,err1,phase_ok1,amp_ok1],[r2,M2,err2,phase_ok2,amp_ok2]]\").\n\nTest Suite:\n- Case 1 (happy path): $\\kappa = 1.0\\times 10^{-6}\\ \\mathrm{m}^2/\\mathrm{s}$, $L = 1.0\\times 10^{5}\\ \\mathrm{m}$, $N = 100$, $T = 1.0\\times 10^{12}\\ \\mathrm{s}$, $\\varepsilon_{\\mathrm{amp}} = 1.0\\times 10^{-3}$.\n- Case 2 (tight amplitude control): $\\kappa = 1.0\\times 10^{-6}\\ \\mathrm{m}^2/\\mathrm{s}$, $L = 1.0\\times 10^{5}\\ \\mathrm{m}$, $N = 100$, $T = 1.0\\times 10^{12}\\ \\mathrm{s}$, $\\varepsilon_{\\mathrm{amp}} = 1.0\\times 10^{-6}$.\n- Case 3 (coarse grid, moderate amplitude control): $\\kappa = 1.0\\times 10^{-6}\\ \\mathrm{m}^2/\\mathrm{s}$, $L = 1.0\\times 10^{5}\\ \\mathrm{m}$, $N = 10$, $T = 1.0\\times 10^{12}\\ \\mathrm{s}$, $\\varepsilon_{\\mathrm{amp}} = 1.0\\times 10^{-2}$.\n- Case 4 (loose amplitude control, phase-limited): $\\kappa = 1.0\\times 10^{-6}\\ \\mathrm{m}^2/\\mathrm{s}$, $L = 1.0\\times 10^{5}\\ \\mathrm{m}$, $N = 100$, $T = 1.0\\times 10^{12}\\ \\mathrm{s}$, $\\varepsilon_{\\mathrm{amp}} = 5.0\\times 10^{-1}$.\n\nYour implementation must be general and applicable for arbitrary test parameters of the same form. The final output must strictly follow the single-line, comma-separated list enclosed in square brackets format described above.", "solution": "The user-provided problem is valid as it is scientifically grounded in the principles of numerical analysis and heat transfer, is well-posed, and contains all necessary information for a unique solution. We proceed with the derivation and implementation.\n\nThe problem requires the design of a time-step controller for the Crank-Nicolson scheme applied to the one-dimensional heat equation, $\\frac{\\partial u}{\\partial t} = \\kappa \\frac{\\partial^2 u}{\\partial x^2}$. The controller must select the nondimensional time step parameter $r = \\kappa \\Delta t / \\Delta x^2$ to satisfy constraints on numerical amplitude and phase error for the worst-case eigenmode of the spatially discretized system.\n\n### 1. Eigenvalues of the Spatial Discretization\nThe spatial domain $x \\in [0, L]$ is discretized with $N$ interior points, yielding a grid spacing of $\\Delta x = L/(N+1)$. The semi-discretized system is $\\frac{d\\mathbf{u}}{dt} = \\frac{\\kappa}{\\Delta x^2} \\mathbf{L}\\,\\mathbf{u}$, where $\\mathbf{L}$ is the $N \\times N$ second-difference matrix for homogeneous Dirichlet boundary conditions. The eigenvalues of $\\mathbf{L}$ are well-known and are given by:\n$$\n\\mu_j = -4 \\sin^2\\left(\\frac{j\\pi}{2(N+1)}\\right), \\quad \\text{for } j = 1, 2, \\dots, N\n$$\nAll eigenvalues $\\mu_j$ are real and negative. The \"worst-case\" mode for stability and accuracy is the one that decays most rapidly, corresponding to the eigenvalue with the largest magnitude. The magnitude is $|\\mu_j| = 4 \\sin^2\\left(\\frac{j\\pi}{2(N+1)}\\right)$, which is maximized for the largest value of $j$, i.e., $j=N$. The worst-case eigenvalue, denoted $\\mu_{\\max}$ in the problem, is therefore $\\mu_N$. Its magnitude is:\n$$\n|\\mu_{\\max}| = |\\mu_N| = 4 \\sin^2\\left(\\frac{N\\pi}{2(N+1)}\\right) = 4 \\cos^2\\left(\\frac{\\pi}{2(N+1)}\\right)\n$$\n\n### 2. Crank-Nicolson Amplification Factor\nThe Crank-Nicolson method applied to a scalar ordinary differential equation $\\frac{du}{dt} = \\lambda u$ yields the amplification factor $A = \\frac{1 + \\lambda \\Delta t/2}{1 - \\lambda \\Delta t/2}$. For the semi-discrete system, the matrix operator has eigenvalues $\\lambda_j = \\frac{\\kappa}{\\Delta x^2}\\mu_j$. The amplification factor for the $j$-th eigenmode is:\n$$\nA_j = \\frac{1 + \\frac{1}{2}\\frac{\\kappa \\mu_j \\Delta t}{\\Delta x^2}}{1 - \\frac{1}{2}\\frac{\\kappa \\mu_j \\Delta t}{\\Delta x^2}} = \\frac{1 + \\frac{1}{2} r \\mu_j}{1 - \\frac{1}{2} r \\mu_j}\n$$\nFor the worst-case mode, we use $\\mu_{\\max}$. Introducing the problem's nondimensional decay parameter $s = r|\\mu_{\\max}| = -r\\mu_{\\max}$, we can write the worst-mode amplification factor $A_{\\mathrm{CN}}$ as:\n$$\nA_{\\mathrm{CN}}(s) = \\frac{1 - s/2}{1 + s/2}\n$$\n\n### 3. Constraint Analysis\nTwo constraints must be satisfied by choosing the largest possible $r$.\n\n**Phase Error Constraint:** The amplification factor must be non-negative to prevent unphysical oscillations.\n$$\nA_{\\mathrm{CN}}(s) = \\frac{1 - s/2}{1 + s/2} \\ge 0\n$$\nSince $s0$, the denominator $1+s/2$ is always positive. The constraint thus simplifies to $1-s/2 \\ge 0$, which implies $s \\le 2$. This provides an upper bound on $s$, and consequently on $r$:\n$$\ns \\le 2 \\implies r|\\mu_{\\max}| \\le 2 \\implies r \\le \\frac{2}{|\\mu_{\\max}|}\n$$\nLet this limit be $r_{\\text{phase}} = 2/|\\mu_{\\max}|$.\n\n**Amplitude Error Constraint:** The per-step relative amplitude error for the worst-case mode must be bounded by a tolerance $\\varepsilon_{\\mathrm{amp}}$. The exact amplification factor over one time step is $A_{\\mathrm{exact}} = e^{\\lambda_{\\max} \\Delta t} = e^{\\frac{\\kappa\\mu_{\\max}\\Delta t}{\\Delta x^2}} = e^{r\\mu_{\\max}} = e^{-s}$. The relative error is:\n$$\nE_{\\mathrm{amp}}(s) = \\frac{|A_{\\mathrm{CN}}(s) - A_{\\mathrm{exact}}(s)|}{A_{\\mathrm{exact}}(s)} \\le \\varepsilon_{\\mathrm{amp}}\n$$\nSubstituting the expressions for the amplification factors, we have:\n$$\n\\left| \\frac{\\frac{1-s/2}{1+s/2} - e^{-s}}{e^{-s}} \\right| = \\left| \\frac{e^s(1-s/2)}{1+s/2} - 1 \\right| \\le \\varepsilon_{\\mathrm{amp}}\n$$\nFor $s \\in (0, 2]$, it can be shown that $A_{\\mathrm{CN}}(s)  A_{\\mathrm{exact}}(s)$, meaning the numerical scheme is slightly more dissipative than the exact solution. Thus, the quantity inside the absolute value is negative, and the error is:\n$$\nE_{\\mathrm{amp}}(s) = 1 - \\frac{e^s(1-s/2)}{1+s/2}\n$$\nThis error function $E_{\\mathrm{amp}}(s)$ is monotonically increasing for $s  0$. We must find the largest $s$, denoted $s_{\\text{amp}}$, such that $E_{\\mathrm{amp}}(s_{\\text{amp}}) \\le \\varepsilon_{\\mathrm{amp}}$. Since $E_{\\mathrm{amp}}$ is monotonic, this is equivalent to solving the equation $E_{\\mathrm{amp}}(s) = \\varepsilon_{\\mathrm{amp}}$ for $s$. This transcendental equation does not have a simple analytical solution and must be solved numerically, for instance, using a root-finding algorithm like the bisection or Brent's method. This solution $s_{\\text{amp}}$ gives the amplitude-limited $r$-value as $r_{\\text{amp}} = s_{\\text{amp}}/|\\mu_{\\max}|$.\n\n### 4. Algorithm for Time Step Selection\nFor each test case, the algorithm is as follows:\n1.  Calculate the grid spacing $\\Delta x = L/(N+1)$.\n2.  Calculate the magnitude of the worst-case eigenvalue $|\\mu_{\\max}| = 4 \\cos^2(\\frac{\\pi}{2(N+1)})$.\n3.  Determine the maximum allowed value of $s$ from the phase constraint, $s_{\\text{phase}} = 2$.\n4.  Numerically solve the equation $1 - \\frac{e^s(1-s/2)}{1+s/2} = \\varepsilon_{\\mathrm{amp}}$ for $s$ in the interval $(0, 2]$ to find $s_{\\text{amp}}$.\n5.  Select the most restrictive $s_{\\max} = \\min(s_{\\text{phase}}, s_{\\text{amp}})$.\n6.  Calculate the maximum allowed nondimensional parameter $r_{\\max} = s_{\\max} / |\\mu_{\\max}|$.\n7.  Compute the corresponding maximum physical time step $\\Delta t_{\\max} = \\frac{r_{\\max} \\Delta x^2}{\\kappa}$.\n8.  Determine the number of time steps $M$ needed to cover the simulation horizon $T$: $M = \\lceil T / \\Delta t_{\\max} \\rceil$.\n9.  Calculate the actual time step to exactly match the horizon $T$: $\\Delta t = T / M$.\n10. Compute the final nondimensional parameter used in the simulation: $r_{\\mathrm{final}} = \\frac{\\kappa \\Delta t}{\\Delta x^2}$.\n11. Using this $r_{\\mathrm{final}}$, calculate the final effective decay parameter $s_{\\mathrm{final}} = r_{\\mathrm{final}} |\\mu_{\\max}|$.\n12. With $s_{\\mathrm{final}}$, compute the final per-step relative amplitude error $E_{\\mathrm{amp,final}} = 1 - \\frac{e^{s_{\\mathrm{final}}}(1-s_{\\mathrm{final}}/2)}{1+s_{\\mathrm{final}}/2}$.\n13. Verify the constraints:\n    - Phase constraint is satisfied if $s_{\\mathrm{final}} \\le 2$.\n    - Amplitude constraint is satisfied if $E_{\\mathrm{amp,final}} \\le \\varepsilon_{\\mathrm{amp}}$. Due to the choice of $\\Delta t \\le \\Delta t_{\\max}$, both constraints will be satisfied mathematically. The boolean check serves as verification.\n14. Report the tuple $(r_{\\mathrm{final}}, M, E_{\\mathrm{amp,final}}, \\text{phase\\_ok}, \\text{amp\\_ok})$.\n\nThis procedure guarantees that the numerical simulation respects both accuracy and non-oscillatory behavior criteria for all resolved modes, by controlling the behavior of the most challenging mode.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import optimize\n\ndef solve():\n    \"\"\"\n    Solves the Crank-Nicolson time-step calibration problem for several test cases.\n    \"\"\"\n    \n    # Test cases from the problem statement.\n    test_cases = [\n        # (kappa, L, N, T, eps_amp)\n        (1.0e-6, 1.0e5, 100, 1.0e12, 1.0e-3), # Case 1: happy path\n        (1.0e-6, 1.0e5, 100, 1.0e12, 1.0e-6), # Case 2: tight amplitude control\n        (1.0e-6, 1.0e5, 10,  1.0e12, 1.0e-2), # Case 3: coarse grid, moderate amplitude control\n        (1.0e-6, 1.0e5, 100, 1.0e12, 5.0e-1), # Case 4: loose amplitude control, phase-limited\n    ]\n\n    results = []\n    \n    def amplitude_error_func(s, eps_amp):\n        \"\"\"\n        Error function E_amp(s) - eps_amp = 0 to be solved for s.\n        E_amp(s) = 1 - (e^s * (1 - s/2)) / (1 + s/2)\n        \"\"\"\n        # Handle s=0 case to avoid division by zero if ever used, although s0 is expected.\n        if s == 0:\n            return -eps_amp\n        # The equation to solve is E_amp(s) = eps_amp\n        return 1.0 - (np.exp(s) * (1.0 - s / 2.0)) / (1.0 + s / 2.0) - eps_amp\n\n    for case in test_cases:\n        kappa, L, N, T, eps_amp = case\n        \n        # 1. Calculate grid spacing\n        delta_x = L / (N + 1.0)\n        \n        # 2. Calculate the worst-mode eigenvalue magnitude\n        mu_max_mag = 4.0 * np.cos(np.pi / (2.0 * (N + 1.0)))**2\n        \n        # 3. Phase constraint: s_phase_limit = 2\n        s_phase_limit = 2.0\n        \n        # 4. Amplitude constraint: solve for s_amp_limit\n        # The root must be in (0, 2]. Using a small positive number for the lower bound.\n        # If eps_amp is large (=1), a root might not exist in (0, 2).\n        # E_amp at s=2 is 1. For eps_amp  1, a root exists in (0, 2).\n        if eps_amp = 1.0:\n            # The error can never reach this value below the phase limit\n            s_amp_limit = s_phase_limit\n        else:\n            # Use brentq to find the root of amplitude_error_func\n            s_amp_limit = optimize.brentq(amplitude_error_func, 1e-12, s_phase_limit, args=(eps_amp,))\n            \n        # 5. The most restrictive s is the minimum of the two limits\n        s_max = min(s_phase_limit, s_amp_limit)\n        \n        # 6. Calculate max allowed r\n        r_max = s_max / mu_max_mag\n        \n        # 7. Compute max physical time step\n        delta_t_max = (r_max * delta_x**2) / kappa\n        \n        # 8. Determine number of steps M\n        if delta_t_max = 0: # Avoid division by zero if T is large and dt_max is tiny/zero\n             M = int(1e18) # A huge number, effectively not stepping.\n        else:\n             M = int(np.ceil(T / delta_t_max))\n\n        # 9. Calculate actual time step dt\n        delta_t = T / M\n        \n        # 10. Compute final non-dimensional parameter\n        r_final = (kappa * delta_t) / delta_x**2\n        \n        # 11. Calculate final decay parameter s_final\n        s_final = r_final * mu_max_mag\n        \n        # 12. Compute final amplitude error\n        # Use amplitude_error_func(s_final, 0) which is just E_amp(s_final)\n        E_amp_final = amplitude_error_func(s_final, 0)\n        \n        # 13. Verify constraints\n        phase_ok = (s_final = 2.0)\n        # Add a small tolerance for floating point comparison\n        amp_ok = (E_amp_final = eps_amp * (1.0 + 1e-9))\n        \n        # 14. Store results\n        # Format: r_final (float), M (integer), E_amp_final (float), phase_ok (bool), amp_ok (bool)\n        results.append([r_final, M, E_amp_final, phase_ok, amp_ok])\n\n    # Format the final output string exactly as specified.\n    # e.g., '[[r1,M1,E1,P1,A1],[r2,M2,E2,P2,A2]]'\n    sub_results_str = [f\"[{r},{m},{e},{str(p)},{str(a)}]\" for r, m, e, p, a in results]\n    final_output_str = f\"[{','.join(sub_results_str)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```", "id": "3616370"}]}