{"hands_on_practices": [{"introduction": "A foundational skill in potential field geophysics is the ability to derive anomaly expressions for simple geologic structures from first principles. This exercise [@problem_id:3613236] guides you through the analytical derivation of the gravitational and magnetic fields for an infinite horizontal cylinder, a canonical 2D source. Mastering this classic problem builds essential mathematical proficiency and provides intuition for how source parameters control anomaly shape and amplitude.", "problem": "An infinite, straight, horizontal circular cylinder of radius $a$ is embedded in a homogeneous half-space. The cylinder’s axis is parallel to the $y$-axis and its center lies at $(x,z)=(0,z_{0})$ with $z$ measured positive downward and the observation surface at $z=0$. Assume $z_{0}>a$ so the observation points are outside the cylinder. Two independent physical property contrasts are considered:\n\n1. Gravity: a constant density contrast $\\Delta \\rho$ between the cylinder and the host.\n2. Magnetics: a uniform magnetization vector $\\mathbf{M}$ of the cylinder confined to the $x$–$z$ plane, i.e., $\\mathbf{M} = M_{x}\\,\\hat{\\mathbf{x}} + M_{z}\\,\\hat{\\mathbf{z}}$ with no component along the cylinder axis.\n\nStarting only from the following fundamental bases:\n\n- Newtonian gravitation in the International System of Units (SI): the gravitational field $\\mathbf{g}$ is $\\mathbf{g}(\\mathbf{r}) = -\\nabla \\Phi(\\mathbf{r})$, where the potential $\\Phi$ satisfies $\\nabla^{2}\\Phi = 4\\pi G \\rho$, with $G$ the gravitational constant and $\\rho$ the mass density.\n- Magnetostatics in free space (no conduction currents in the region of observation): the magnetic field intensity $\\mathbf{H}$ derives from a scalar potential $U$ such that $\\mathbf{H} = -\\nabla U$ in regions where the magnetization is zero, and $U$ satisfies Laplace’s equation $\\nabla^{2}U = 0$ outside the body. The body’s uniform magnetization $\\mathbf{M}$ gives an equivalent dipole moment per unit length equal to the cross-sectional area times $\\mathbf{M}$.\n\nDerive closed-form expressions along a surface profile for:\n\n- The downward (positive $z$) component of the gravitational acceleration anomaly, $g_{z}(x)$, due solely to the cylinder.\n- The downward (positive $z$) component of the magnetic induction anomaly in free space, $B_{z}(x)$, due solely to the cylinder, using $B_{z} = \\mu_{0} H_{z}$ with $\\mu_{0}$ the magnetic permeability of free space.\n\nYour derivation must account for all geometric factors, including the horizontal offset $x$ along the profile relative to the vertical above the cylinder axis and the burial depth $z_{0}$. Express the final results as explicit functions of $x$, $a$, $z_{0}$, $\\Delta \\rho$, $G$, $\\mu_{0}$, $M_{x}$, and $M_{z}$. Assume observations are made at $z=0$ in air. Provide:\n\n- $g_{z}(x)$ in $\\mathrm{m}\\,\\mathrm{s}^{-2}$.\n- $B_{z}(x)$ in $\\mathrm{T}$.\n\nNo numerical evaluation is required; present each result in closed analytical form. The final answer must be a single analytical expression collecting both $g_{z}(x)$ and $B_{z}(x)$ as a two-entry row matrix in terms of the specified symbols only.", "solution": "The problem is assessed to be valid as it is scientifically grounded in Newtonian gravitation and magnetostatics, well-posed, objective, and contains sufficient information for a unique solution.\n\nThe problem requires the derivation of the downward vertical component of the gravitational and magnetic anomalies, $g_z(x)$ and $B_z(x)$, produced by an infinite horizontal cylinder. The infinite nature of the cylinder along the $y$-axis reduces the problem to two dimensions in the $x$-$z$ plane.\n\n**Part 1: Gravitational Anomaly $g_z(x)$**\n\nThe problem provides the fundamental basis for gravitation: the gravitational field $\\mathbf{g}$ is the negative gradient of a potential $\\Phi$, $\\mathbf{g} = -\\nabla \\Phi$, where $\\Phi$ satisfies Poisson's equation $\\nabla^2\\Phi = 4\\pi G \\rho$.\n\nDue to the cylindrical symmetry of the mass distribution, for any observation point outside the cylinder, the gravitational field is identical to that of an infinite line mass located on the cylinder's axis with the same mass per unit length. This is an extension of Newton's shell theorem to cylindrical geometry, derivable from Gauss's law for gravity.\n\nThe cylinder has a radius $a$ and a constant density contrast $\\Delta \\rho$ with the host medium. The cross-sectional area of the cylinder is $A_{cyl} = \\pi a^2$. The mass per unit length (linear mass density) of the anomalous mass is $\\lambda = \\Delta \\rho A_{cyl} = \\pi \\Delta \\rho a^2$.\n\nThe axis of the cylinder is located at $(x,z) = (0,z_0)$, and observations are made along the surface profile $z=0$. We can, therefore, model the source as an infinite line mass $\\lambda$ located at $(0, z_0)$.\n\nTo find the gravitational acceleration $\\mathbf{g}$ at an observation point $\\mathbf{r}_{obs} = (x,0,0)$, we integrate the contributions from each mass element $dm = \\lambda dy'$ along the line source located at $\\mathbf{r}_{src} = (0, y', z_0)$. The vector from the source element to the observation point is $\\mathbf{R} = \\mathbf{r}_{obs} - \\mathbf{r}_{src} = (x, -y', -z_0)$. The gravitational field is attractive, so it points from the observation point towards the source, in the direction of $-\\mathbf{R} = (-x, y', z_0)$.\n\nThe field contribution from a mass element $dm$ is given by Newton's law of universal gravitation:\n$$\nd\\mathbf{g} = G \\frac{dm}{|\\mathbf{R}|^2} \\frac{-\\mathbf{R}}{|\\mathbf{R}|} = -G \\lambda dy' \\frac{(x, -y', -z_0)}{(x^2 + y'^2 + z_0^2)^{3/2}}\n$$\nWe integrate this expression with respect to $y'$ from $-\\infty$ to $\\infty$ to find the total field $\\mathbf{g}$. By symmetry, the $y$-component of the field is zero. We are interested in the $z$-component, which is defined as positive downward.\n$$\ng_z(x) = \\int_{-\\infty}^{\\infty} -G \\lambda \\frac{-z_0}{(x^2 + y'^2 + z_0^2)^{3/2}} dy' = G \\lambda z_0 \\int_{-\\infty}^{\\infty} \\frac{dy'}{(x^2 + y'^2 + z_0^2)^{3/2}}\n$$\nLet $r_p^2 = x^2+z_0^2$. The integral is a standard form:\n$$\n\\int_{-\\infty}^{\\infty} \\frac{dy'}{(r_p^2 + y'^2)^{3/2}} = \\left[ \\frac{y'}{r_p^2 \\sqrt{r_p^2 + y'^2}} \\right]_{-\\infty}^{\\infty} = \\frac{2}{r_p^2} = \\frac{2}{x^2+z_0^2}\n$$\nSubstituting this back into the expression for $g_z(x)$:\n$$\ng_z(x) = G \\lambda z_0 \\left(\\frac{2}{x^2+z_0^2}\\right) = \\frac{2G\\lambda z_0}{x^2+z_0^2}\n$$\nFinally, we substitute the expression for the linear mass density $\\lambda = \\pi \\Delta \\rho a^2$:\n$$\ng_z(x) = \\frac{2G(\\pi \\Delta \\rho a^2) z_0}{x^2+z_0^2} = \\frac{2\\pi G \\Delta\\rho a^2 z_0}{x^2+z_0^2}\n$$\n\n**Part 2: Magnetic Anomaly $B_z(x)$**\n\nThe problem states that outside the magnetized body, the magnetic field intensity $\\mathbf{H}$ can be expressed as the negative gradient of a scalar potential $U$, $\\mathbf{H} = -\\nabla U$, where $U$ satisfies Laplace's equation $\\nabla^2 U = 0$. The cylinder has a uniform magnetization $\\mathbf{M} = M_x \\hat{\\mathbf{x}} + M_z \\hat{\\mathbf{z}}$. The equivalent dipole moment per unit length is given as $\\mathbf{m} = A_{cyl} \\mathbf{M} = \\pi a^2 \\mathbf{M}$.\n\nThe external potential of a uniformly magnetized cylinder is equivalent to that of a magnetic line dipole located at its center. We first derive the potential for a 2D line dipole. The magnetic scalar potential for a 3D point dipole $\\mathbf{p}$ is $U_{3D}(\\mathbf{r}) = -\\frac{1}{4\\pi} \\frac{\\mathbf{p} \\cdot \\mathbf{r}}{r^3}$, where $\\mathbf{r}$ is the vector from the dipole to the observation point.\n\nTo find the potential of an infinite line of dipoles with moment $\\mathbf{m}$ per unit length, we integrate the 3D potential over an infinite line source. Let the observation point be at $\\mathbf{r}_{obs} = (x,z,0)$ and the source line be along the $y$-axis, so an element is at $\\mathbf{r}_{src}=(0,0,y')$. In the problem's coordinates, this corresponds to an observation point $(x,z)$ and a line source element at $(0,z_0)$ for the central axis cross-section, and we integrate along the $y$-axis. Let the observation point be $(x,z)$ in the $x-z$ plane, and the source line be at $(0, z_0)$. The vector from a source element at $(0, y', z_0)$ to the observation point at $(x, 0, z)$ is $\\mathbf{R} = (x, -y', z-z_0)$. The dipole element is $d\\mathbf{p} = \\mathbf{m} dy'$.\n$$\nU(x,z) = \\int_{-\\infty}^{\\infty} -\\frac{1}{4\\pi} \\frac{(\\mathbf{m}dy') \\cdot (x, -y', z-z_0)}{ (x^2 + y'^2 + (z-z_0)^2)^{3/2} }\n$$\nSince $\\mathbf{m}$ is in the $x-z$ plane, $\\mathbf{m} \\cdot (x, -y', z-z_0) = m_x x + m_z (z-z_0)$.\n$$\nU(x,z) = -\\frac{m_x x + m_z(z-z_0)}{4\\pi} \\int_{-\\infty}^{\\infty} \\frac{dy'}{(x^2 + (z-z_0)^2 + y'^2)^{3/2}}\n$$\nUsing the same integral result as in the gravity case, with $r_p^2 = x^2+(z-z_0)^2$:\n$$\nU(x,z) = -\\frac{m_x x + m_z(z-z_0)}{4\\pi} \\left( \\frac{2}{x^2+(z-z_0)^2} \\right) = -\\frac{1}{2\\pi} \\frac{m_x x + m_z(z-z_0)}{x^2+(z-z_0)^2}\n$$\nSubstituting $\\mathbf{m} = \\pi a^2 \\mathbf{M} = \\pi a^2 (M_x \\hat{\\mathbf{x}} + M_z \\hat{\\mathbf{z}})$:\n$$\nU(x,z) = -\\frac{\\pi a^2}{2\\pi} \\frac{M_x x + M_z(z-z_0)}{x^2+(z-z_0)^2} = -\\frac{a^2}{2} \\frac{M_x x + M_z(z-z_0)}{x^2+(z-z_0)^2}\n$$\nThe downward component of the magnetic field intensity is $H_z = -\\frac{\\partial U}{\\partial z}$.\n$$\nH_z(x,z) = -\\frac{\\partial}{\\partial z} \\left( -\\frac{a^2}{2} \\frac{M_x x + M_z(z-z_0)}{x^2+(z-z_0)^2} \\right) = \\frac{a^2}{2} \\frac{\\partial}{\\partial z} \\left( \\frac{M_x x + M_z(z-z_0)}{x^2+(z-z_0)^2} \\right)\n$$\nUsing the quotient rule, we get:\n$$\nH_z(x,z) = \\frac{a^2}{2} \\frac{ M_z(x^2+(z-z_0)^2) - (M_x x + M_z(z-z_0))(2(z-z_0)) }{ (x^2+(z-z_0)^2)^2 }\n$$\n$$\nH_z(x,z) = \\frac{a^2}{2} \\frac{ M_z x^2 + M_z(z-z_0)^2 - 2M_x x (z-z_0) - 2M_z(z-z_0)^2 }{ (x^2+(z-z_0)^2)^2 }\n$$\n$$\nH_z(x,z) = \\frac{a^2}{2} \\frac{ M_z(x^2 - (z-z_0)^2) - 2M_x x (z-z_0) }{ (x^2+(z-z_0)^2)^2 }\n$$\nWe evaluate this expression on the observation surface $z=0$:\n$$\nH_z(x) = \\frac{a^2}{2} \\frac{ M_z(x^2 - (-z_0)^2) - 2M_x x (-z_0) }{ (x^2+(-z_0)^2)^2 } = \\frac{a^2}{2} \\frac{ M_z(x^2-z_0^2) + 2M_x x z_0 }{ (x^2+z_0^2)^2 }\n$$\nThe problem asks for the magnetic induction anomaly $B_z(x) = \\mu_0 H_z(x)$.\n$$\nB_z(x) = \\frac{\\mu_0 a^2}{2} \\frac{2M_x x z_0 + M_z(x^2-z_0^2)}{(x^2+z_0^2)^2}\n$$\nThe derived expressions for $g_z(x)$ and $B_z(x)$ are provided in the requested matrix format.", "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{2\\pi G \\Delta\\rho a^2 z_0}{x^2+z_0^2} & \\frac{\\mu_0 a^2}{2} \\frac{2 M_x x z_0 + M_z(x^2-z_0^2)}{(x^2+z_0^2)^2} \\end{pmatrix}}\n$$", "id": "3613236"}, {"introduction": "While analytical solutions are invaluable, modeling complex geological bodies requires robust numerical methods like the Boundary Element Method (BEM). A critical challenge in BEM is the accurate evaluation of nearly singular integrals that arise when computing fields close to a source's boundary. This practice [@problem_id:3613227] delves into this advanced topic, comparing a naive numerical quadrature with the far more accurate singularity subtraction technique, a cornerstone of modern potential field modeling software.", "problem": "Consider Newtonian gravity for a homogeneous body with constant mass density, where the gravitational potential outside the body satisfies the Laplace equation. In potential field theory, the single-layer surface potential representation over a boundary is central to the Boundary Element Method (BEM). Let the gravitational potential be represented by a single-layer over a planar facet with a possibly spatially varying equivalent surface density. The potential at a field point is given by the surface integral of the kernel. The normal derivative of the potential is required for near-field evaluation in BEM and is sensitive to kernel singularities.\n\nYou must implement a program that evaluates the near-field normal derivative of the gravitational potential due to the top rectangular face of a polygonal prism by two numerical strategies and one analytic singular integral, and then compare the accuracy. The rectangular face is defined by the Cartesian coordinates $x \\in [x_1,x_2]$, $y \\in [y_1,y_2]$ at a fixed plane $z = z_{\\mathrm{top}}$. The gravitational potential at a field point $(x_0,y_0,z_0)$ due to a surface density $\\sigma(x,y)$ is defined by the single-layer integral\n$$\n\\Phi(x_0,y_0,z_0) \\;=\\; G \\int_{y_1}^{y_2} \\int_{x_1}^{x_2} \\frac{\\sigma(x,y)}{\\sqrt{(x-x_0)^2 + (y-y_0)^2 + (z_{\\mathrm{top}} - z_0)^2}} \\, \\mathrm{d}x \\, \\mathrm{d}y,\n$$\nwhere $G$ is Newton's gravitational constant. The normal derivative of interest along the outward unit normal of the top face (taken to be in the $+\\hat{z}$ direction) is\n$$\n\\partial_n \\Phi(x_0,y_0,z_0) \\;=\\; \\frac{\\partial \\Phi}{\\partial z_0}(x_0,y_0,z_0) \\;=\\; -G \\int_{y_1}^{y_2} \\int_{x_1}^{x_2} \\frac{z_0 - z_{\\mathrm{top}}}{\\left[(x-x_0)^2 + (y-y_0)^2 + (z_{\\mathrm{top}} - z_0)^2\\right]^{3/2}} \\, \\sigma(x,y) \\, \\mathrm{d}x \\, \\mathrm{d}y.\n$$\nDefine the local offsets $u = x - x_0$, $v = y - y_0$, and $z = z_0 - z_{\\mathrm{top}}$ so that $z > 0$ for field points above the top face. To control the near-field behavior when $z$ is small, derive and use the analytic singular integral for the case of constant surface density. Specifically, for a rectangular facet and constant $\\sigma$, show that\n$$\nI_z(x_0,y_0,z; x_1,x_2,y_1,y_2) \\;=\\; \\int_{y_1}^{y_2} \\int_{x_1}^{x_2} \\frac{z}{\\left[u^2 + v^2 + z^2\\right]^{3/2}} \\, \\mathrm{d}x \\, \\mathrm{d}y \\;=\\; \\sum_{i \\in \\{1,2\\}} \\sum_{j \\in \\{1,2\\}} \\arctan\\!\\left( \\frac{U_i V_j}{z \\sqrt{U_i^2 + V_j^2 + z^2}} \\right),\n$$\nwith $U_1 = x_0 - x_1$, $U_2 = x_2 - x_0$, $V_1 = y_0 - y_1$, $V_2 = y_2 - y_0$, assuming $(x_0,y_0)$ projects inside the facet so that $U_i > 0$ and $V_j > 0$. Then for constant density $\\sigma = \\sigma_0$, the normal derivative is\n$$\n\\partial_n \\Phi_{\\mathrm{const}}(x_0,y_0,z_0) \\;=\\; -G \\, \\sigma_0 \\, I_z(x_0,y_0,z; x_1,x_2,y_1,y_2).\n$$\nTo compare numerical strategies, consider a linearly varying surface density\n$$\n\\sigma(x,y) \\;=\\; \\sigma_0 \\left( 1 + \\alpha x + \\beta y \\right),\n$$\nwith given parameters $\\alpha$ and $\\beta$. Implement two numerical evaluations of $\\partial_n \\Phi$:\n\n- A naive tensor-product Gauss–Legendre quadrature of the integral for $\\partial_n \\Phi$ with the given $\\sigma(x,y)$, using a fixed order that is not excessively high.\n- A quadrature with singularity subtraction, where one writes $\\sigma(x,y) = \\sigma(x_0,y_0) + \\Delta\\sigma(x,y)$, evaluates $-G \\, \\sigma(x_0,y_0) \\, I_z$ analytically using the above formula, and then numerically integrates the smoother remainder\n$$\n-G \\int_{y_1}^{y_2} \\int_{x_1}^{x_2} \\Delta\\sigma(x,y) \\, \\frac{z}{\\left[u^2 + v^2 + z^2\\right]^{3/2}} \\, \\mathrm{d}x \\, \\mathrm{d}y\n$$\nby Gauss–Legendre quadrature of the same order.\n\nAs a reference, compute a high-accuracy estimate of $\\partial_n \\Phi$ for the same $\\sigma(x,y)$ using a high-order tensor-product Gauss–Legendre quadrature, and treat this result as the ground truth for error assessment. Use Newton's gravitational constant $G = 6.67430 \\times 10^{-11}$ in $\\mathrm{m}^3 \\, \\mathrm{kg}^{-1} \\, \\mathrm{s}^{-2}$, a base surface density $\\sigma_0$ in $\\mathrm{kg} \\, \\mathrm{m}^{-2}$, and express all output in $\\mathrm{m} \\, \\mathrm{s}^{-2}$. Angles inside inverse tangent functions are dimensionless, but no angle unit is required since all arguments are ratios of lengths.\n\nGeometry and parameters:\n- Rectangular facet: $x \\in [0,1]$ $\\mathrm{m}$, $y \\in [0,2]$ $\\mathrm{m}$.\n- Top plane: $z_{\\mathrm{top}} = 1$ $\\mathrm{m}$.\n- Base surface density: $\\sigma_0 = 5000$ $\\mathrm{kg} \\, \\mathrm{m}^{-2}$.\n- Gauss–Legendre orders: naive and subtraction methods should use order $n = 16$ in each direction; the reference should use order $n_{\\mathrm{ref}} = 120$ in each direction.\n\nTest suite of field points and density parameters:\n- Case $1$: $(x_0,y_0,z_0) = (0.5,1.0,1.0 + 10^{-3})$ $\\mathrm{m}$, $\\alpha = 0$, $\\beta = 0$.\n- Case $2$: $(x_0,y_0,z_0) = (0.5,1.0,1.0 + 10^{-3})$ $\\mathrm{m}$, $\\alpha = 0.5$ $\\mathrm{m}^{-1}$, $\\beta = -0.3$ $\\mathrm{m}^{-1}$.\n- Case $3$: $(x_0,y_0,z_0) = (1.0 - 10^{-6},1.0,1.0 + 10^{-4})$ $\\mathrm{m}$, $\\alpha = 0$, $\\beta = 0$.\n- Case $4$: $(x_0,y_0,z_0) = (1.0 - 10^{-6},2.0 - 10^{-6},1.0 + 10^{-4})$ $\\mathrm{m}$, $\\alpha = 0.5$ $\\mathrm{m}^{-1}$, $\\beta = 0.5$ $\\mathrm{m}^{-1}$.\n- Case $5$: $(x_0,y_0,z_0) = (0.5,1.0,1.0 + 10^{-1})$ $\\mathrm{m}$, $\\alpha = 0$, $\\beta = 0$.\n\nYour program must:\n- Implement the analytic singular integral $I_z$ as above.\n- Implement the naive quadrature and singularity-subtraction quadrature for $\\partial_n \\Phi$ for the given $\\sigma(x,y)$.\n- Implement the high-order reference quadrature and use it as ground truth.\n- For each test case, compute two floats: the absolute error of the naive quadrature relative to the reference, and the absolute error of the singularity-subtraction quadrature relative to the reference. These must be expressed in $\\mathrm{m} \\, \\mathrm{s}^{-2}$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with values ordered as\n$$\n[\\mathrm{err}_{\\mathrm{naive},1},\\mathrm{err}_{\\mathrm{sub},1},\\mathrm{err}_{\\mathrm{naive},2},\\mathrm{err}_{\\mathrm{sub},2},\\mathrm{err}_{\\mathrm{naive},3},\\mathrm{err}_{\\mathrm{sub},3},\\mathrm{err}_{\\mathrm{naive},4},\\mathrm{err}_{\\mathrm{sub},4},\\mathrm{err}_{\\mathrm{naive},5},\\mathrm{err}_{\\mathrm{sub},5}],\n$$\nwhere $\\mathrm{err}_{\\mathrm{naive},k}$ and $\\mathrm{err}_{\\mathrm{sub},k}$ denote the absolute errors for case $k$, respectively, in $\\mathrm{m} \\, \\mathrm{s}^{-2}$, with no additional text or spaces.", "solution": "The fundamental task is to evaluate the normal derivative of the gravitational potential, $\\partial_n\\Phi$, at a point $(x_0, y_0, z_0)$ near a planar rectangular surface defined by $x \\in [x_1, x_2]$ and $y \\in [y_1, y_2]$ at a constant elevation $z=z_{\\mathrm{top}}$. The potential is generated by a single layer of mass with a spatially varying surface density $\\sigma(x,y)$. The normal direction is taken as the positive $\\hat{z}$ direction.\n\nThe normal derivative of the potential $\\Phi$ is given by the integral:\n$$\n\\partial_n \\Phi(x_0,y_0,z_0) \\;=\\; \\frac{\\partial \\Phi}{\\partial z_0}(x_0,y_0,z_0) \\;=\\; -G \\int_{y_1}^{y_2} \\int_{x_1}^{x_2} \\frac{z_0 - z_{\\mathrm{top}}}{\\left[(x-x_0)^2 + (y-y_0)^2 + (z_{\\mathrm{top}} - z_0)^2\\right]^{3/2}} \\, \\sigma(x,y) \\, \\mathrm{d}x \\, \\mathrm{d}y\n$$\nwhere $G$ is the gravitational constant. Using the local coordinates $u=x-x_0$, $v=y-y_0$, and $z=z_0-z_{\\mathrm{top}}$ (where $z>0$ indicates a field point above the surface), the expression simplifies to:\n$$\n\\partial_n \\Phi \\;=\\; -G \\int_{y_1}^{y_2} \\int_{x_1}^{x_2} \\sigma(x,y) \\, K(x-x_0, y-y_0, z) \\, \\mathrm{d}x \\, \\mathrm{d}y\n$$\nwhere the integration kernel is $K(u,v,z) = z / (u^2 + v^2 + z^2)^{3/2}$.\n\nThe primary challenge arises in 'near-field' evaluations, where the distance $z$ is small compared to the dimensions of the facet. In this regime, as the integration point $(x,y)$ approaches the field point's projection $(x_0,y_0)$, the kernel $K$ becomes sharply peaked. The value of the kernel at $(u,v)=(0,0)$ is $1/z^2$, which grows rapidly as $z \\to 0$. This near-singular behavior poses a significant challenge for standard numerical quadrature schemes, such as Gauss-Legendre quadrature, which are designed for smooth functions.\n\nFor the special case of a constant surface density $\\sigma(x,y) = \\sigma_0$, the integral can be solved analytically. The normal derivative is then:\n$$\n\\partial_n \\Phi_{\\mathrm{const}} = -G \\sigma_0 I_z, \\quad \\text{where} \\quad I_z = \\int_{y_1}^{y_2} \\int_{x_1}^{x_2} \\frac{z}{\\left[(x-x_0)^2 + (y-y_0)^2 + z^2\\right]^{3/2}} \\, \\mathrm{d}x \\, \\mathrm{d}y\n$$\nThe definite integral $I_z$ over the rectangle has a closed-form solution in terms of the arctangent function, which physically represents the solid angle subtended by the rectangle at the field point:\n$$\nI_z(x_0,y_0,z; x_1,x_2,y_1,y_2) \\;=\\; \\sum_{i \\in \\{1,2\\}} \\sum_{j \\in \\{1,2\\}} \\arctan\\!\\left( \\frac{U_i V_j}{z \\sqrt{U_i^2 + V_j^2 + z^2}} \\right)\n$$\nwhere $U_1 = x_0 - x_1$, $U_2 = x_2 - x_0$, $V_1 = y_0 - y_1$, and $V_2 = y_2 - y_0$. This formula is valid when the projection $(x_0,y_0)$ is inside the facet, ensuring $U_i > 0$ and $V_j > 0$.\n\nFor a linearly varying density $\\sigma(x,y) = \\sigma_0 ( 1 + \\alpha x + \\beta y )$, we compare two numerical strategies.\n\n1.  **Naive Gauss-Legendre Quadrature:** This method directly applies a $n \\times n$ tensor-product Gauss-Legendre quadrature rule to the full integral for $\\partial_n\\Phi$. This involves transforming the integration domain $[x_1, x_2] \\times [y_1, y_2]$ to the canonical square $[-1, 1]^2$ and approximating the integral as a weighted sum of the integrand evaluated at the mapped Gauss nodes. Due to the peaked nature of the kernel for small $z$, this method is expected to yield low accuracy unless a very high quadrature order $n$ is used.\n\n2.  **Singularity Subtraction:** This technique regularizes the integrand before numerical integration. The surface density $\\sigma(x,y)$ is split into two parts: its value at the field point projection, $\\sigma(x_0,y_0)$, and the remainder, $\\Delta\\sigma(x,y) = \\sigma(x,y) - \\sigma(x_0,y_0)$.\n    $$\n    \\sigma(x,y) = \\sigma(x_0, y_0) + \\Delta\\sigma(x,y)\n    $$\n    The integral for $\\partial_n\\Phi$ is correspondingly split into a singular part and a regular part:\n    $$\n    \\partial_n\\Phi = \\underbrace{-G \\sigma(x_0, y_0) \\int_{y_1}^{y_2} \\int_{x_1}^{x_2} K \\, \\mathrm{d}x\\mathrm{d}y}_{\\text{Singular Part (Analytic)}} \\quad \\underbrace{-G \\int_{y_1}^{y_2} \\int_{x_1}^{x_2} \\Delta\\sigma(x,y) K \\, \\mathrm{d}x\\mathrm{d}y}_{\\text{Regular Part (Numerical)}}\n    $$\n    The singular part is mathematically identical to the integral for a constant density $\\sigma(x_0, y_0)$, and thus can be evaluated analytically using the $I_z$ formula. The regular part involves the integrand $\\Delta\\sigma(x,y) K$. For the given linear density, $\\Delta\\sigma(x,y) = \\sigma_0(\\alpha(x-x_0) + \\beta(y-y_0))$. This term approaches $0$ as $(x,y) \\to (x_0,y_0)$, effectively canceling the singularity of the kernel $K$. The resulting integrand is a smooth, well-behaved function that can be integrated accurately using a low-order Gauss-Legendre quadrature.\n\nTo assess accuracy, both methods are compared against a high-accuracy reference solution, computed using a very high-order Gauss-Legendre quadrature ($n_{\\mathrm{ref}}=120 \\times 120$) on the original integral. The absolute difference between each method's result and this reference value quantifies the numerical error. The implementation will demonstrate that for near-field evaluations, the singularity subtraction method provides a dramatic improvement in accuracy over the naive approach for the same computational cost (i.e., the same quadrature order $n$).", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Solves the potential field theory problem by comparing naive quadrature\n    and singularity subtraction for evaluating a nearly singular integral.\n    \"\"\"\n    \n    # Define physical and geometric constants\n    G_CONST = 6.67430e-11  # m^3 kg^-1 s^-2\n    SIGMA0 = 5000.0  # kg m^-2\n    X1, X2 = 0.0, 1.0  # m\n    Y1, Y2 = 0.0, 2.0  # m\n    Z_TOP = 1.0  # m\n\n    # Define numerical parameters\n    N_QUAD = 16\n    N_REF = 120\n\n    # Define the test cases from the problem statement.\n    # Format: ((x0, y0, z0), (alpha, beta))\n    test_cases = [\n        ((0.5, 1.0, 1.0 + 1e-3), (0.0, 0.0)),\n        ((0.5, 1.0, 1.0 + 1e-3), (0.5, -0.3)),\n        ((1.0 - 1e-6, 1.0, 1.0 + 1e-4), (0.0, 0.0)),\n        ((1.0 - 1e-6, 2.0 - 1e-6, 1.0 + 1e-4), (0.5, 0.5)),\n        ((0.5, 1.0, 1.0 + 1e-1), (0.0, 0.0)),\n    ]\n\n    memoized_quad_nodes = {}\n\n    def get_quad_nodes(n):\n        \"\"\"Memoized retrieval of Gauss-Legendre nodes and weights.\"\"\"\n        if n in memoized_quad_nodes:\n            return memoized_quad_nodes[n]\n        else:\n            nodes, weights = roots_legendre(n)\n            memoized_quad_nodes[n] = (nodes, weights)\n            return nodes, weights\n\n    def analytic_I_z(x0, y0, z, x1, x2, y1, y2):\n        \"\"\"Computes the analytic integral for constant density.\"\"\"\n        U = np.array([x0 - x1, x2 - x0])\n        V = np.array([y0 - y1, y2 - y0])\n        total_angle = 0.0\n        for u_val in U:\n            for v_val in V:\n                root_term = np.sqrt(u_val**2 + v_val**2 + z**2)\n                # The problem constraints ensure z > 0 and root_term > 0\n                arg = (u_val * v_val) / (z * root_term)\n                total_angle += np.arctan(arg)\n        return total_angle\n\n    def gauss_quad_2d(func, x1, x2, y1, y2, n):\n        \"\"\"Performs 2D Gauss-Legendre quadrature of func using n*n points.\"\"\"\n        nodes, weights = get_quad_nodes(n)\n        \n        x_mapped = 0.5 * (x2 - x1) * nodes + 0.5 * (x2 + x1)\n        y_mapped = 0.5 * (y2 - y1) * nodes + 0.5 * (y2 + y1)\n\n        xv, yv = np.meshgrid(x_mapped, y_mapped)\n        wv = np.outer(weights, weights)\n\n        f_vals = func(xv, yv)\n        \n        integral = np.sum(wv * f_vals)\n        integral *= 0.25 * (x2 - x1) * (y2 - y1)\n        return integral\n\n    results = []\n    for case in test_cases:\n        (x0, y0, z0), (alpha, beta) = case\n        z = z0 - Z_TOP\n        \n        def sigma_func(x, y):\n            return SIGMA0 * (1.0 + alpha * x + beta * y)\n\n        def kernel(x, y):\n            return z / ((x - x0)**2 + (y - y0)**2 + z**2)**1.5\n\n        # 1. High-accuracy reference calculation\n        integrand_ref = lambda x, y: sigma_func(x, y) * kernel(x, y)\n        ref_val = -G_CONST * gauss_quad_2d(integrand_ref, X1, X2, Y1, Y2, N_REF)\n\n        # 2. Naive quadrature calculation\n        integrand_naive = lambda x, y: sigma_func(x, y) * kernel(x, y)\n        naive_val = -G_CONST * gauss_quad_2d(integrand_naive, X1, X2, Y1, Y2, N_QUAD)\n\n        # 3. Singularity subtraction calculation\n        sigma_at_x0y0 = sigma_func(x0, y0)\n        \n        # Analytic part\n        analytic_part_integral = analytic_I_z(x0, y0, z, X1, X2, Y1, Y2)\n        analytic_val = -G_CONST * sigma_at_x0y0 * analytic_part_integral\n        \n        # Numerical part (regular integrand)\n        def integrand_sub(x, y):\n            delta_sigma = SIGMA0 * (alpha * (x - x0) + beta * (y - y0))\n            return delta_sigma * kernel(x, y)\n        \n        # Only compute if there is a variable part\n        if abs(alpha) > 0 or abs(beta) > 0:\n            numeric_val = -G_CONST * gauss_quad_2d(integrand_sub, X1, X2, Y1, Y2, N_QUAD)\n        else: # delta_sigma is zero everywhere\n            numeric_val = 0.0\n\n        sub_val = analytic_val + numeric_val\n\n        # Calculate and store absolute errors\n        err_naive = abs(naive_val - ref_val)\n        err_sub = abs(sub_val - ref_val)\n        results.extend([err_naive, err_sub])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3613227"}, {"introduction": "A primary goal of geophysical surveys is to determine the location and depth of subsurface sources, a classic inverse problem. This exercise [@problem_id:3613216] focuses on Euler deconvolution, a powerful technique that estimates source parameters by leveraging the field's homogeneity property. By implementing the method and testing its performance against violations of its core assumptions, you will gain practical insight into both the power and the potential pitfalls of this widely-used interpretation tool.", "problem": "You will investigate the stability of estimating depth to a source using Euler deconvolution based on local homogeneity of a scalar potential-field proxy. You must derive from first principles the linear relation used in Euler deconvolution without using any pre-derived shortcut formulas, implement a solver to estimate the source depth from synthetic data, construct synthetic examples that violate the homogeneity assumption in controlled ways, and diagnose the resulting estimation errors quantitatively.\n\nStart from the following fundamental base:\n- A scalar potential-field proxy $T(\\mathbf{r})$ arising from an isolated source is locally homogeneous of degree $-N$ about the source location $\\mathbf{r}_0$, meaning that $T(\\lambda(\\mathbf{r}-\\mathbf{r}_0)) = \\lambda^{-N} T(\\mathbf{r}-\\mathbf{r}_0)$ for any scalar $\\lambda &gt; 0$ near the source, where $N$ is a known positive integer called the structural index.\n- Euler’s theorem for homogeneous functions states that if $f(\\mathbf{r})$ is homogeneous of degree $k$, then $\\mathbf{r} \\cdot \\nabla f(\\mathbf{r}) = k f(\\mathbf{r})$.\n- The measured field can include a constant base level $B$ and smooth regional trends over the survey area.\n- All measurements are taken on a horizontal plane at $z=0$.\n\nTask requirements:\n1. Using the homogeneity assumption for $T$ and Euler’s theorem, starting from first principles, derive a linear relation between the measurement coordinates $(x,y,0)$, the first spatial derivatives $\\partial T/\\partial x$, $\\partial T/\\partial y$, $\\partial T/\\partial z$, the field $T$, the structural index $N$, and the unknowns $(x_0,y_0,z_0,B)$. The relation must hold for each data point under the homogeneity assumption and must be amenable to solution by linear least squares for $(x_0,y_0,z_0,B)$.\n2. Implement a program that:\n   - Generates synthetic scalar fields on a regular grid using isolated sources with amplitude $A$, location $(x_0,y_0,z_0)$, and structural index $N_{\\text{true}}$, with the analytic form\n     $$T(\\mathbf{r}) = \\sum_{s=1}^{S} \\frac{A_s}{\\left\\|\\mathbf{r} - \\mathbf{r}_{0,s}\\right\\|^{N_{\\text{true},s}}} + B + L_x x + L_y y,$$\n     where $\\mathbf{r}=(x,y,0)$ denotes the observation point and $\\mathbf{r}_{0,s}=(x_{0,s},y_{0,s},z_{0,s})$ denotes the $s$-th source location. The regional trend is linear with coefficients $L_x$ and $L_y$.\n   - Computes the required spatial derivatives analytically for the constructed field. For a single source term $\\frac{A}{r^{N}}$ with $r=\\sqrt{(x-x_0)^2+(y-y_0)^2+z_0^2}$, derive the expressions for $\\partial T/\\partial x$, $\\partial T/\\partial y$, and $\\partial T/\\partial z$ at $z=0$ using the chain rule. Superposition applies linearly when there are multiple sources and when adding the regional trend.\n   - Assembles the linear system implied by your derivation in item $1$ for all grid points and solves in the least-squares sense for $(\\hat{x}_0,\\hat{y}_0,\\hat{z}_0,\\hat{B})$ assuming a user-chosen structural index $N_{\\text{assumed}}$.\n   - Computes two diagnostic quantities for each synthetic test case:\n     a) The absolute depth error $\\left|\\hat{z}_0 - z_{0,\\text{primary}}\\right|$ in meters, where $z_{0,\\text{primary}}$ is the true depth of the primary source of interest.\n     b) A normalized Euler residual defined as\n     $$R_{\\text{norm}} = \\frac{\\sqrt{\\frac{1}{M}\\sum_{i=1}^{M} r_i^2}}{\\sqrt{\\frac{1}{M}\\sum_{i=1}^{M} b_i^2} + \\varepsilon},$$\n     where $r_i$ is the algebraic residual of the $i$-th equation after plugging in $(\\hat{x}_0,\\hat{y}_0,\\hat{z}_0,\\hat{B})$, $b_i$ is the right-hand-side term of the $i$-th linear equation implied by your derivation, $M$ is the number of grid points, and $\\varepsilon$ is a small positive stabilizer to avoid division by zero. This residual gauges the degree to which local homogeneity is violated for the chosen modeling and assumptions.\n3. Use the following grid and units:\n   - Observation plane: $z=0$.\n   - Grid extent: $x \\in [-500, 500]$ meters, $y \\in [-500, 500]$ meters.\n   - Grid resolution: $21 \\times 21$ uniformly spaced points.\n   - Express all final depth errors in meters, rounded by the default floating-point representation. Angles are not used.\n4. Implement the following five test cases to probe stability and homogeneity violations. In all cases, report results with respect to the first source listed (the “primary” source) when computing depth error. For each case, use the specified $N_{\\text{assumed}}$ in your Euler inversion, and construct the field using the specified $N_{\\text{true}}$ values.\n   - Case $1$ (isolated homogeneous source, happy path):\n     - Sources: $S=1$ with $(x_0,y_0,z_0) = (0,0,200)$ meters, amplitude $A=1$, $N_{\\text{true}}=2$.\n     - Base level and trend: $B=0$, $L_x=0$, $L_y=0$.\n     - Inversion: $N_{\\text{assumed}}=2$.\n   - Case $2$ (constant base level present but modeled):\n     - Sources: $S=1$ with $(x_0,y_0,z_0) = (0,0,200)$ meters, $A=1$, $N_{\\text{true}}=2$.\n     - Base level and trend: $B=10^{-5}$, $L_x=0$, $L_y=0$.\n     - Inversion: $N_{\\text{assumed}}=2$.\n   - Case $3$ (linear regional trend violates homogeneity):\n     - Sources: $S=1$ with $(x_0,y_0,z_0) = (0,0,200)$ meters, $A=1$, $N_{\\text{true}}=2$.\n     - Base level and trend: $B=0$, $L_x=10^{-8}$, $L_y=-10^{-8}$.\n     - Inversion: $N_{\\text{assumed}}=2$.\n   - Case $4$ (superposition of nearby sources violates single-origin homogeneity):\n     - Sources: $S=2$, primary $(x_0,y_0,z_0) = (0,0,200)$ meters with $A=1$, $N_{\\text{true}}=2$; secondary $(x_0,y_0,z_0) = (150,0,150)$ meters with $A=0.6$, $N_{\\text{true}}=2$.\n     - Base level and trend: $B=0$, $L_x=0$, $L_y=0$.\n     - Inversion: $N_{\\text{assumed}}=2$.\n   - Case $5$ (structural index mismatch):\n     - Sources: $S=1$ with $(x_0,y_0,z_0) = (0,0,200)$ meters, $A=1$, $N_{\\text{true}}=3$.\n     - Base level and trend: $B=0$, $L_x=0$, $L_y=0$.\n     - Inversion: $N_{\\text{assumed}}=2$.\n5. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is a two-element list $[\\text{depth\\_error\\_m}, \\text{normalized\\_residual}]$ for the five cases in the order $1$ through $5$. For example: \"[[e1,r1],[e2,r2],[e3,r3],[e4,r4],[e5,r5]]\". Each $e_k$ and $r_k$ must be a floating-point number.\n\nAll computations must be self-contained and must not require any user input. The only allowed external libraries are specified in the execution environment. The final results must be reproducible exactly from the provided specifications.", "solution": "The user wants to investigate the stability of Euler deconvolution for potential field interpretation. This requires a derivation from first principles, implementation of a solver for synthetic data, and analysis of results from several test cases designed to probe the method's limitations.\n\n### **Problem Validation**\n\n**Step 1: Extract Givens**\n\n- **Fundamental Base:**\n    - A scalar potential-field proxy $T(\\mathbf{r})$ is locally homogeneous of degree $-N$ about the source location $\\mathbf{r}_0$, meaning $T(\\lambda(\\mathbf{r}-\\mathbf{r}_0)) = \\lambda^{-N} T(\\mathbf{r}-\\mathbf{r}_0)$ for a scalar $\\lambda > 0$. $N$ is the structural index.\n    - Euler's theorem for homogeneous functions: if $f(\\mathbf{r})$ is homogeneous of degree $k$, then $\\mathbf{r} \\cdot \\nabla f(\\mathbf{r}) = k f(\\mathbf{r})$.\n    - The measured field can include a constant base level $B$ and smooth regional trends.\n    - All measurements are on a horizontal plane at $z=0$.\n- **Task 1: Derivation:**\n    - Derive a linear relation for the unknowns $(x_0, y_0, z_0, B)$ using the provided base assumptions.\n- **Task 2: Implementation:**\n    - Generate synthetic field $T(\\mathbf{r}) = \\sum_{s=1}^{S} \\frac{A_s}{\\left\\|\\mathbf{r} - \\mathbf{r}_{0,s}\\right\\|^{N_{\\text{true},s}}} + B + L_x x + L_y y$ on a grid.\n    - Analytically compute derivatives $\\partial T/\\partial x$, $\\partial T/\\partial y$, $\\partial T/\\partial z$.\n    - Assemble and solve the linear system for $(\\hat{x}_0, \\hat{y}_0, \\hat{z}_0, \\hat{B})$ using a chosen $N_{\\text{assumed}}$.\n    - Compute diagnostics: absolute depth error $|\\hat{z}_0 - z_{0,\\text{primary}}|$ and normalized Euler residual $R_{\\text{norm}} = \\frac{\\sqrt{\\frac{1}{M}\\sum r_i^2}}{\\sqrt{\\frac{1}{M}\\sum b_i^2} + \\varepsilon}$.\n- **Task 3: Grid and Units:**\n    - Observation plane: $z=0$.\n    - Grid: $x, y \\in [-500, 500]$ meters, $21 \\times 21$ points.\n    - All depth errors in meters.\n- **Task 4: Test Cases:**\n    - Case 1: Ideal case. $S=1, (0,0,200), A=1, N_{\\text{true}}=2$. No regional. $N_{\\text{assumed}}=2$.\n    - Case 2: Ideal case with base level. $S=1, (0,0,200), A=1, N_{\\text{true}}=2$. $B=10^{-5}$. $N_{\\text{assumed}}=2$.\n    - Case 3: Violation by regional trend. $S=1, (0,0,200), A=1, N_{\\text{true}}=2$. $L_x=10^{-8}, L_y=-10^{-8}$. $N_{\\text{assumed}}=2$.\n    - Case 4: Violation by source interference. $S=2$. Primary: $(0,0,200), A=1, N_{\\text{true}}=2$. Secondary: $(150,0,150), A=0.6, N_{\\text{true}}=2$. $N_{\\text{assumed}}=2$.\n    - Case 5: Violation by structural index mismatch. $S=1, (0,0,200), A=1, N_{\\text{true}}=3$. $N_{\\text{assumed}}=2$.\n- **Task 5: Output Format:**\n    - Single line: `[[e1,r1],[e2,r2],[e3,r3],[e4,r4],[e5,r5]]`.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is scientifically grounded in potential field theory, specifically the application of Euler's theorem to homogeneous fields for source parameter estimation. It is well-posed, providing all necessary parameters, equations, and definitions to construct and solve a deterministic computational problem. The problem is objective and avoids ambiguity. The test cases are systematically designed to test the robustness of the method against common violations of its underlying assumptions (presence of unmodeled regional trends, interference from multiple sources, incorrect model parameterization). The problem is self-contained and computationally verifiable.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. A full solution will be provided.\n\n---\n\n### **Part 1: Derivation of the Euler Deconvolution Equation**\n\nWe start from the fundamental principles provided. Let the total measured field be $T_m(\\mathbf{r})$, where $\\mathbf{r}=(x,y,z)$ is the observation point. This field is a superposition of the field from an isolated source, a constant base level $B$, and a regional trend. The Euler deconvolution method assumes that the source field itself is homogeneous. We define a proxy field, $T_p(\\mathbf{r})$, which is the part of the signal assumed to be homogeneous. In the standard formulation which solves for a constant background $B$, the proxy field is $T_p(\\mathbf{r}) = T_m(\\mathbf{r}) - B$. The regional trend terms $L_x x + L_y y$ are considered unmodeled interferences that violate the homogeneity assumption.\n\nThe key assumption is that the source field $T_p(\\mathbf{r})$ is a homogeneous function of degree $-N$ about the source location $\\mathbf{r}_0 = (x_0, y_0, z_0)$. This property is more formally stated by defining a new function $F(\\mathbf{v}) = T_p(\\mathbf{r}_0 + \\mathbf{v})$. The homogeneity of $T_p$ about $\\mathbf{r}_0$ means that $F$ is a homogeneous function of degree $-N$ about the origin. Thus, for any scalar $\\lambda > 0$, it satisfies:\n$$F(\\lambda \\mathbf{v}) = \\lambda^{-N} F(\\mathbf{v})$$\nAccording to Euler's theorem for homogeneous functions, $F(\\mathbf{v})$ must satisfy:\n$$\\mathbf{v} \\cdot \\nabla_{\\mathbf{v}} F(\\mathbf{v}) = -N F(\\mathbf{v})$$\nwhere $\\nabla_{\\mathbf{v}}$ is the gradient with respect to the components of $\\mathbf{v}$. We now transform this equation back into the original coordinate system $(\\mathbf{r})$.\nLet $\\mathbf{v} = \\mathbf{r} - \\mathbf{r}_0$. The chain rule for differentiation gives $\\nabla_{\\mathbf{v}} = \\nabla_{\\mathbf{r}}$. Substituting back, we have:\n- $F(\\mathbf{v}) = T_p(\\mathbf{r}_0 + (\\mathbf{r}-\\mathbf{r}_0)) = T_p(\\mathbf{r})$\n- $\\nabla_{\\mathbf{v}} F(\\mathbf{v}) = \\nabla_{\\mathbf{r}} T_p(\\mathbf{r})$\n\nThis leads to the Euler homogeneity equation for the proxy field $T_p$:\n$$(\\mathbf{r} - \\mathbf{r}_0) \\cdot \\nabla T_p(\\mathbf{r}) = -N T_p(\\mathbf{r})$$\nWe now introduce the measured field $T_m$ and the constant base level $B$. Since $T_p = T_m - B$, we have $\\nabla T_p = \\nabla (T_m - B) = \\nabla T_m$. Substituting these into the homogeneity equation yields:\n$$(\\mathbf{r} - \\mathbf{r}_0) \\cdot \\nabla T_m(\\mathbf{r}) = -N (T_m(\\mathbf{r}) - B)$$\nExpanding the dot product with $\\mathbf{r}=(x,y,z)$ and $\\mathbf{r}_0=(x_0,y_0,z_0)$:\n$$(x - x_0) \\frac{\\partial T_m}{\\partial x} + (y - y_0) \\frac{\\partial T_m}{\\partial y} + (z - z_0) \\frac{\\partial T_m}{\\partial z} = -N (T_m - B)$$\nMeasurements are taken on a horizontal plane where $z=0$. Substituting $z=0$ gives:\n$$(x - x_0) \\frac{\\partial T_m}{\\partial x} + (y - y_0) \\frac{\\partial T_m}{\\partial y} - z_0 \\frac{\\partial T_m}{\\partial z} = -N T_m + N B$$\nOur goal is to find a linear relation for the unknowns $(x_0, y_0, z_0, B)$. We rearrange the equation to group terms containing the unknowns on one side:\n$$x \\frac{\\partial T_m}{\\partial x} - x_0 \\frac{\\partial T_m}{\\partial x} + y \\frac{\\partial T_m}{\\partial y} - y_0 \\frac{\\partial T_m}{\\partial y} - z_0 \\frac{\\partial T_m}{\\partial z} = -N T_m + N B$$\n$$x_0 \\frac{\\partial T_m}{\\partial x} + y_0 \\frac{\\partial T_m}{\\partial y} + z_0 \\frac{\\partial T_m}{\\partial z} + N B = x \\frac{\\partial T_m}{\\partial x} + y \\frac{\\partial T_m}{\\partial y} + N T_m$$\nThis is the required linear relation. For each measurement point $(x_i, y_i)$, we have the measured field $T_{m,i}$ and its spatial derivatives. The structural index $N$ is assumed known ($N = N_{\\text{assumed}}$). The equation can be written in matrix form for a single point $i$:\n$$\n\\begin{bmatrix} \\frac{\\partial T_m}{\\partial x} & \\frac{\\partial T_m}{\\partial y} & \\frac{\\partial T_m}{\\partial z} & N_{\\text{assumed}} \\end{bmatrix}_i\n\\begin{bmatrix} x_0 \\\\ y_0 \\\\ z_0 \\\\ B \\end{bmatrix}\n=\n\\left[ x \\frac{\\partial T_m}{\\partial x} + y \\frac{\\partial T_m}{\\partial y} + N_{\\text{assumed}} T_m \\right]_i\n$$\nBy collecting these equations for all $M$ measurement points, we form an overdetermined linear system $\\mathbf{G}\\mathbf{m} = \\mathbf{d}$, which can be solved for the model parameters $\\mathbf{m} = [x_0, y_0, z_0, B]^T$ using linear least squares.\n\n### **Part 2: Analytic Derivatives**\nFor a single source term $T_s(\\mathbf{r}) = A_s / \\|\\mathbf{r} - \\mathbf{r}_{0,s}\\|^{N_{\\text{true},s}}$, where $\\|\\mathbf{r} - \\mathbf{r}_{0,s}\\| = r_s$, we can write $T_s = A_s r_s^{-N_{\\text{true},s}}$. The derivatives are found using the chain rule. With $r_s^2 = (x-x_{0,s})^2 + (y-y_{0,s})^2 + (z-z_{0,s})^2$:\n$$ \\frac{\\partial r_s}{\\partial x} = \\frac{x-x_{0,s}}{r_s}, \\quad \\frac{\\partial r_s}{\\partial y} = \\frac{y-y_{0,s}}{r_s}, \\quad \\frac{\\partial r_s}{\\partial z} = \\frac{z-z_{0,s}}{r_s} $$\nThe derivatives of the field term are:\n$$ \\frac{\\partial T_s}{\\partial x} = \\frac{d T_s}{d r_s} \\frac{\\partial r_s}{\\partial x} = (-N_{\\text{true},s} A_s r_s^{-N_{\\text{true},s}-1}) \\left(\\frac{x-x_{0,s}}{r_s}\\right) = -N_{\\text{true},s} A_s \\frac{x-x_{0,s}}{r_s^{N_{\\text{true},s}+2}} $$\n$$ \\frac{\\partial T_s}{\\partial y} = -N_{\\text{true},s} A_s \\frac{y-y_{0,s}}{r_s^{N_{\\text{true},s}+2}} $$\n$$ \\frac{\\partial T_s}{\\partial z} = -N_{\\text{true},s} A_s \\frac{z-z_{0,s}}{r_s^{N_{\\text{true},s}+2}} $$\nFor a total field $T_m = \\sum_s T_s + B + L_x x + L_y y$, the derivatives are obtained by superposition:\n$$ \\frac{\\partial T_m}{\\partial x} = \\sum_s \\frac{\\partial T_s}{\\partial x} + L_x, \\quad \\frac{\\partial T_m}{\\partial y} = \\sum_s \\frac{\\partial T_s}{\\partial y} + L_y, \\quad \\frac{\\partial T_m}{\\partial z} = \\sum_s \\frac{\\partial T_s}{\\partial z} $$\nThese expressions are evaluated at the measurement plane $z=0$. For this problem, we adopt a coordinate system where the $z$-axis is positive downwards. Therefore, a source at a depth of $200$ meters has a coordinate $z_0=200$.\n\n### **Part 3: Implementation and Analysis of Test Cases**\nThe derived linear system is implemented and solved for the five specified test cases. The code generates synthetic data, computes analytical derivatives, constructs the matrix system $\\mathbf{G}\\mathbf{m} = \\mathbf{d}$, solves for $\\mathbf{m}$ via least-squares, and calculates the required diagnostic metrics: absolute depth error and normalized Euler residual. The results from each case demonstrate how violations of the underlying homogeneity assumption affect the accuracy of the depth estimate.\n- **Cases 1 & 2** (Ideal Conditions): The method performs exceptionally well, with negligible error and residual, confirming the correctness of the derivation and implementation. The model's ability to solve for a constant background $B$ is validated.\n- **Case 3** (Regional Trend): The unmodeled linear trend introduces systematic errors into the computed derivatives, violating the homogeneity assumption. This results in a significant estimation error and a higher residual, quantifying the model misspecification.\n- **Case 4** (Source Interference): The superposition of fields from two distinct sources creates a total field that is not homogeneous about any single point. This interference acts as a spatially-varying \"geologic noise\", leading to substantial errors in the estimated location of the primary source.\n- **Case 5** (Structural Index Mismatch): Using an incorrect structural index ($N_{\\text{assumed}} \\neq N_{\\text{true}}$) fundamentally misspecifies the expected decay rate of the field in the model. This leads to a poorly conditioned system and large errors in the estimated parameters, highlighting the sensitivity of the method to this crucial parameter.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef generate_field_and_derivatives(x_coords, y_coords, sources, regional):\n    \"\"\"\n    Generates synthetic potential field data and its spatial derivatives on a grid.\n    \n    Args:\n        x_coords (np.ndarray): 1D array of x-coordinates for the grid.\n        y_coords (np.ndarray): 1D array of y-coordinates for the grid.\n        sources (list): A list of source parameters. Each source is a dict:\n                        {'A': amplitude, 'x0': x_coord, 'y0': y_coord, \n                         'z0': z_coord, 'N_true': structural_index}.\n        regional (dict): A dict with regional field parameters:\n                         {'B': base_level, 'Lx': x_trend, 'Ly': y_trend}.\n\n    Returns:\n        tuple: A tuple containing flattened 1D arrays for T, Tx, Ty, Tz.\n    \"\"\"\n    xx, yy = np.meshgrid(x_coords, y_coords)\n    x_flat = xx.flatten()\n    y_flat = yy.flatten()\n    z_obs = 0.0\n\n    T = np.zeros_like(x_flat, dtype=np.float64)\n    Tx = np.zeros_like(x_flat, dtype=np.float64)\n    Ty = np.zeros_like(x_flat, dtype=np.float64)\n    Tz = np.zeros_like(x_flat, dtype=np.float64)\n\n    for src in sources:\n        A, x0, y0, z0, N_true = src['A'], src['x0'], src['y0'], src['z0'], src['N_true']\n        \n        r_sq = (x_flat - x0)**2 + (y_flat - y0)**2 + (z_obs - z0)**2\n        # Avoid division by zero at the source epicenter if it's on the plane\n        r_sq[r_sq == 0] = 1e-12\n        r = np.sqrt(r_sq)\n\n        r_inv_N = r**(-N_true)\n        r_inv_N_plus_2 = r**(-(N_true + 2))\n        \n        T += A * r_inv_N\n        Tx += -N_true * A * (x_flat - x0) * r_inv_N_plus_2\n        Ty += -N_true * A * (y_flat - y0) * r_inv_N_plus_2\n        Tz += -N_true * A * (z_obs - z0) * r_inv_N_plus_2\n\n    B, Lx, Ly = regional['B'], regional['Lx'], regional['Ly']\n    T += B + Lx * x_flat + Ly * y_flat\n    Tx += Lx\n    Ty += Ly\n    \n    return T, Tx, Ty, Tz\n\n\ndef solve_euler_deconvolution(x_coords, y_coords, T, Tx, Ty, Tz, N_assumed):\n    \"\"\"\n    Solves the Euler deconvolution linear system.\n\n    Args:\n        x_coords, y_coords (np.ndarray): Flattened 1D arrays of grid coordinates.\n        T, Tx, Ty, Tz (np.ndarray): Flattened 1D arrays of field and derivatives.\n        N_assumed (int): The assumed structural index for the inversion.\n\n    Returns:\n        tuple: (m_hat, G, d) where m_hat is the solution vector [x0, y0, z0, B],\n               G is the system matrix, and d is the data vector.\n    \"\"\"\n    M = len(x_coords)\n    G = np.zeros((M, 4), dtype=np.float64)\n    G[:, 0] = Tx\n    G[:, 1] = Ty\n    G[:, 2] = Tz\n    G[:, 3] = N_assumed\n\n    d = x_coords * Tx + y_coords * Ty + N_assumed * T\n\n    m_hat, _, _, _ = np.linalg.lstsq(G, d, rcond=None)\n    \n    return m_hat, G, d\n\n\ndef calculate_diagnostics(m_hat, G, d, z0_primary):\n    \"\"\"\n    Calculates the depth error and normalized residual.\n\n    Args:\n        m_hat (np.ndarray): Estimated model parameters [x0, y0, z0, B].\n        G (np.ndarray): System matrix.\n        d (np.ndarray): Data vector.\n        z0_primary (float): True depth of the primary source.\n\n    Returns:\n        tuple: (depth_error, normalized_residual).\n    \"\"\"\n    # Absolute depth error\n    z0_hat = m_hat[2]\n    depth_error = np.abs(z0_hat - z0_primary)\n\n    # Normalized Euler residual\n    residuals = d - (G @ m_hat)\n    rms_residuals = np.sqrt(np.mean(residuals**2))\n    rms_d = np.sqrt(np.mean(d**2))\n    \n    epsilon = np.finfo(float).eps\n    R_norm = rms_residuals / (rms_d + epsilon)\n    \n    return depth_error, R_norm\n\ndef run_case(case_params):\n    \"\"\"\n    Runs a single test case for Euler deconvolution.\n    \"\"\"\n    # Grid setup\n    x_grid = np.linspace(-500.0, 500.0, 21)\n    y_grid = np.linspace(-500.0, 500.0, 21)\n    \n    # Generate synthetic data\n    T, Tx, Ty, Tz = generate_field_and_derivatives(\n        x_grid, y_grid, case_params['sources'], case_params['regional']\n    )\n    \n    # Solve system\n    m_hat, G, d = solve_euler_deconvolution(\n        np.meshgrid(x_grid, y_grid)[0].flatten(),\n        np.meshgrid(x_grid, y_grid)[1].flatten(),\n        T, Tx, Ty, Tz, case_params['N_assumed']\n    )\n    \n    # Calculate diagnostics\n    depth_error, R_norm = calculate_diagnostics(\n        m_hat, G, d, case_params['primary_depth']\n    )\n    \n    return [depth_error, R_norm]\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run them, and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1 (isolated homogeneous source, happy path)\n        {\n            'sources': [{'A': 1.0, 'x0': 0.0, 'y0': 0.0, 'z0': 200.0, 'N_true': 2}],\n            'regional': {'B': 0.0, 'Lx': 0.0, 'Ly': 0.0},\n            'N_assumed': 2,\n            'primary_depth': 200.0,\n        },\n        # Case 2 (constant base level present but modeled)\n        {\n            'sources': [{'A': 1.0, 'x0': 0.0, 'y0': 0.0, 'z0': 200.0, 'N_true': 2}],\n            'regional': {'B': 1e-5, 'Lx': 0.0, 'Ly': 0.0},\n            'N_assumed': 2,\n            'primary_depth': 200.0,\n        },\n        # Case 3 (linear regional trend violates homogeneity)\n        {\n            'sources': [{'A': 1.0, 'x0': 0.0, 'y0': 0.0, 'z0': 200.0, 'N_true': 2}],\n            'regional': {'B': 0.0, 'Lx': 1e-8, 'Ly': -1e-8},\n            'N_assumed': 2,\n            'primary_depth': 200.0,\n        },\n        # Case 4 (superposition of nearby sources violates single-origin homogeneity)\n        {\n            'sources': [\n                {'A': 1.0, 'x0': 0.0, 'y0': 0.0, 'z0': 200.0, 'N_true': 2},\n                {'A': 0.6, 'x0': 150.0, 'y0': 0.0, 'z0': 150.0, 'N_true': 2},\n            ],\n            'regional': {'B': 0.0, 'Lx': 0.0, 'Ly': 0.0},\n            'N_assumed': 2,\n            'primary_depth': 200.0,\n        },\n        # Case 5 (structural index mismatch)\n        {\n            'sources': [{'A': 1.0, 'x0': 0.0, 'y0': 0.0, 'z0': 200.0, 'N_true': 3}],\n            'regional': {'B': 0.0, 'Lx': 0.0, 'Ly': 0.0},\n            'N_assumed': 2,\n            'primary_depth': 200.0,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3613216"}]}