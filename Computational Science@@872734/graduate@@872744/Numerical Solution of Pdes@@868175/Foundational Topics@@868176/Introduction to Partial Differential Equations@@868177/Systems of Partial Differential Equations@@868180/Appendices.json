{"hands_on_practices": [{"introduction": "The Godunov method is the cornerstone of modern numerical schemes for hyperbolic systems, built upon solving local Riemann problems at cell interfaces to determine the flow of information. This first practice grounds your understanding by tasking you with implementing a Godunov-type finite volume method for the linear acoustic equations, a fundamental model for wave propagation. By deriving the scheme from its eigenstructure and verifying it against an exact solution [@problem_id:3452358], you will build the foundational skills of characteristic decomposition and wave-based upwinding essential for tackling more advanced problems.", "problem": "Consider a strictly hyperbolic linear system of conservation laws in one spatial dimension of the form $$\\partial_t \\boldsymbol{q}(x,t) + \\partial_x \\boldsymbol{f}(\\boldsymbol{q}(x,t)) = \\boldsymbol{0},$$ where the state vector is $$\\boldsymbol{q} = \\begin{bmatrix} u \\\\ p \\end{bmatrix} \\in \\mathbb{R}^2,$$ and the flux is linear $$\\boldsymbol{f}(\\boldsymbol{q}) = \\boldsymbol{A} \\boldsymbol{q},$$ with constant coefficient matrix $$\\boldsymbol{A} = \\begin{bmatrix} 0  1/\\rho_0 \\\\ \\rho_0 c^2  0 \\end{bmatrix},$$ where $\\rho_0  0$ is a constant reference density and $c  0$ is a constant wave speed. This system represents the one-dimensional linearized acoustics equations and is strictly hyperbolic with two real, distinct eigenvalues.\n\nStarting from the fundamentals of conservation laws and the property of strict hyperbolicity, derive and implement a Godunov-type finite volume method for this $2 \\times 2$ system that advances piecewise constant cell averages in time. Your derivation must begin from the finite volume update $$\\boldsymbol{q}_i^{n+1} = \\boldsymbol{q}_i^n - \\frac{\\Delta t}{\\Delta x} \\left( \\boldsymbol{F}_{i+\\frac{1}{2}}^n - \\boldsymbol{F}_{i-\\frac{1}{2}}^n \\right),$$ where $\\boldsymbol{q}_i^n$ is the cell average over cell $i$ at time level $n$, and $\\boldsymbol{F}_{i\\pm \\frac{1}{2}}^n$ are numerical fluxes. Construct the numerical fluxes by solving the Riemann problem at each interface $x_{i+\\frac{1}{2}}$ using wave-by-wave assembly based on the eigen-decomposition of $\\boldsymbol{A}$. Specifically, use the spectral splitting $$\\boldsymbol{A} = \\boldsymbol{R} \\boldsymbol{\\Lambda} \\boldsymbol{R}^{-1}, \\quad \\boldsymbol{A}^+ = \\boldsymbol{R} \\boldsymbol{\\Lambda}^+ \\boldsymbol{R}^{-1}, \\quad \\boldsymbol{A}^- = \\boldsymbol{R} \\boldsymbol{\\Lambda}^- \\boldsymbol{R}^{-1},$$ with $$\\boldsymbol{\\Lambda} = \\mathrm{diag}(\\lambda_1,\\lambda_2), \\quad \\boldsymbol{\\Lambda}^+ = \\mathrm{diag}(\\max(\\lambda_1,0),\\max(\\lambda_2,0)), \\quad \\boldsymbol{\\Lambda}^- = \\mathrm{diag}(\\min(\\lambda_1,0),\\min(\\lambda_2,0)),$$ and assemble the Godunov-type flux $$\\boldsymbol{F}_{i+\\frac{1}{2}}^n = \\boldsymbol{A}^+ \\boldsymbol{q}_i^n + \\boldsymbol{A}^- \\boldsymbol{q}_{i+1}^n.$$ For the given $\\boldsymbol{A}$, compute the eigenvalues and eigenvectors explicitly and explain the contribution of each characteristic wave to the flux.\n\nAdopt periodic boundary conditions on the domain $$[0,L],$$ with $L$ dimensionless. Use piecewise constant reconstruction (first-order Godunov) and enforce a Courant-Friedrichs-Lewy (CFL) stability condition $$\\Delta t \\le \\mathrm{CFL} \\frac{\\Delta x}{\\max_j |\\lambda_j|},$$ where $\\lambda_j$ are the eigenvalues of $\\boldsymbol{A}$.\n\nFor verification, derive the exact solution for the linear acoustic system using Riemann invariants. Let the initial data be smooth and periodic, constructed as $$u(x,0) = A_u \\sin(2\\pi k x), \\quad p(x,0) = A_p \\cos(2\\pi k x),$$ where $A_u$ and $A_p$ are real amplitudes and $k$ is a nonnegative integer wave number. Using the characteristic variables $$\\alpha_+(x,0) = \\frac{1}{2}\\left(u(x,0) + \\frac{p(x,0)}{\\rho_0 c}\\right), \\quad \\alpha_-(x,0) = \\frac{1}{2}\\left(u(x,0) - \\frac{p(x,0)}{\\rho_0 c}\\right),$$ the exact solution at time $t$ is $$u(x,t) = \\alpha_+(x - c t,0) + \\alpha_-(x + c t,0), \\quad p(x,t) = \\rho_0 c \\left(\\alpha_+(x - c t,0) - \\alpha_-(x + c t,0)\\right),$$ interpreted with periodicity on $[0,L]$.\n\nImplement the method in a single program that:\n- Discretizes the domain into $N$ uniform cells, with $\\Delta x = L/N$.\n- Advances the scheme to a specified final time $T$ using a constant time step $\\Delta t = \\mathrm{CFL} \\cdot \\Delta x / c$ and a final corrective step if needed so that the final time is exactly $T$ with $\\Delta t \\le \\mathrm{CFL} \\cdot \\Delta x / c$.\n- Computes the exact solution using the provided formula at $t=T$.\n- Returns, for each test case, the discrete root-mean-square error $$E = \\sqrt{\\frac{1}{N} \\sum_{i=0}^{N-1} \\left( \\left(u_i^{\\mathrm{num}} - u_i^{\\mathrm{exact}}\\right)^2 + \\left(p_i^{\\mathrm{num}} - p_i^{\\mathrm{exact}}\\right)^2 \\right)},$$ where $u_i^{\\mathrm{num}}$ and $p_i^{\\mathrm{num}}$ are the numerical cell averages and $u_i^{\\mathrm{exact}}$, $p_i^{\\mathrm{exact}}$ are the exact solution sampled at cell centers $x_i$.\n\nAll quantities are dimensionless, so no physical units are required. Angles, if any, should be interpreted in radians.\n\nUse the following test suite of parameter values, representing a set of distinct scenarios:\n- Case $1$ (happy path): $N = 200$, $L = 1$, $\\rho_0 = 1$, $c = 1$, $\\mathrm{CFL} = 0.5$, $k = 1$, $A_u = 1$, $A_p = 1$, $T = 0.5$.\n- Case $2$ (near-CFL boundary): $N = 200$, $L = 1$, $\\rho_0 = 1$, $c = 1$, $\\mathrm{CFL} = 0.99$, $k = 2$, $A_u = 1$, $A_p = 0.5$, $T = 0.25$.\n- Case $3$ (coarse grid): $N = 20$, $L = 1$, $\\rho_0 = 1$, $c = 1$, $\\mathrm{CFL} = 0.9$, $k = 1$, $A_u = 0.5$, $A_p = 1.5$, $T = 0.5$.\n- Case $4$ (constant state edge case): $N = 128$, $L = 1$, $\\rho_0 = 1$, $c = 1$, $\\mathrm{CFL} = 0.8$, $k = 0$, $A_u = 0$, $A_p = 1$, $T = 0.3$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the cases above, for example, $$[E_1,E_2,E_3,E_4],$$ where each $E_j$ is a floating-point number.", "solution": "The user wants me to solve a problem about a Godunov-type finite volume method for a linear hyperbolic system.\n\nHere's my plan:\n1.  **Problem Validation**: I need to go through the problem statement with a fine-toothed comb.\n    *   **Step 1: Extract Givens**: List everything given in the problem statement verbatim. This includes the PDE system, the matrix $\\boldsymbol{A}$, the finite volume update formula, the numerical flux formulation, the CFL condition, the domain, boundary conditions, the initial conditions, the exact solution formula, the error metric, and the specific test cases.\n    *   **Step 2: Validate**: Check if the problem is scientifically grounded, well-posed, objective, and complete.\n        *   **Scientific Grounding**: The system is the 1D linearized acoustics equations. This is a standard, well-established system in fluid dynamics and wave physics. The Godunov method is a cornerstone of numerical methods for conservation laws. The eigen-decomposition approach is standard for linear systems. The exact solution via characteristics (Riemann invariants) is also textbook material for this system. The problem seems scientifically sound.\n        *   **Well-Posedness**: The system is linear and strictly hyperbolic. With periodic initial data on a periodic domain, the Cauchy problem is well-posed. The numerical method is a first-order upwind scheme, which is known to be stable under the given CFL condition. The problem asks for a unique, stable solution, which should exist.\n        *   **Objectivity**: The language is precise and mathematical. There are no subjective terms.\n        *   **Completeness**: All necessary parameters ($\\rho_0, c, L, N, \\mathrm{CFL}, k, A_u, A_p, T$) are provided for each test case. The equations are clearly stated. The method to construct the numerical flux is specified. The error metric is defined. The initial and boundary conditions are given. The problem seems self-contained and consistent.\n    *   **Step 3: Verdict**: Based on the validation, the problem appears to be valid.\n\n2.  **Solution Derivation**: If the problem is valid, I will proceed to derive the solution.\n    *   **Eigen-decomposition of A**:\n        *   First, I need to find the eigenvalues and eigenvectors of the matrix $\\boldsymbol{A} = \\begin{bmatrix} 0  1/\\rho_0 \\\\ \\rho_0 c^2  0 \\end{bmatrix}$.\n        *   Characteristic equation: $\\det(\\boldsymbol{A} - \\lambda \\boldsymbol{I}) = 0$.\n        *   $(-\\lambda)(-\\lambda) - (1/\\rho_0)(\\rho_0 c^2) = \\lambda^2 - c^2 = 0$.\n        *   Eigenvalues: $\\lambda_1 = -c$ and $\\lambda_2 = c$. The problem states the system is strictly hyperbolic, which requires distinct, real eigenvalues. Since $c  0$, we have $\\lambda_1 \\neq \\lambda_2$. This is correct. The maximum absolute eigenvalue is $|\\lambda_j|_{\\max} = c$.\n        *   Eigenvectors:\n            *   For $\\lambda_1 = -c$: $(\\boldsymbol{A} - \\lambda_1 \\boldsymbol{I}) \\boldsymbol{r}_1 = \\boldsymbol{0}$.\n                $\\begin{bmatrix} c  1/\\rho_0 \\\\ \\rho_0 c^2  c \\end{bmatrix} \\begin{bmatrix} r_{11} \\\\ r_{12} \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$.\n                This gives $c r_{11} + (1/\\rho_0) r_{12} = 0$, so $r_{12} = -\\rho_0 c r_{11}$.\n                Let's choose $r_{11} = 1$, so $\\boldsymbol{r}_1 = \\begin{bmatrix} 1 \\\\ -\\rho_0 c \\end{bmatrix}$.\n            *   For $\\lambda_2 = c$: $(\\boldsymbol{A} - \\lambda_2 \\boldsymbol{I}) \\boldsymbol{r}_2 = \\boldsymbol{0}$.\n                $\\begin{bmatrix} -c  1/\\rho_0 \\\\ \\rho_0 c^2  -c \\end{bmatrix} \\begin{bmatrix} r_{21} \\\\ r_{22} \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$.\n                This gives $-c r_{21} + (1/\\rho_0) r_{22} = 0$, so $r_{22} = \\rho_0 c r_{21}$.\n                Let's choose $r_{21} = 1$, so $\\boldsymbol{r}_2 = \\begin{bmatrix} 1 \\\\ \\rho_0 c \\end{bmatrix}$.\n        *   The right eigenvector matrix is $\\boldsymbol{R} = [\\boldsymbol{r}_1, \\boldsymbol{r}_2] = \\begin{bmatrix} 1  1 \\\\ -\\rho_0 c  \\rho_0 c \\end{bmatrix}$.\n        *   The eigenvalue matrix is $\\boldsymbol{\\Lambda} = \\begin{bmatrix} -c  0 \\\\ 0  c \\end{bmatrix}$.\n        *   Now, I need the inverse of $\\boldsymbol{R}$, which is $\\boldsymbol{L}$, the matrix of left eigenvectors.\n            $\\det(\\boldsymbol{R}) = (\\rho_0 c) - (-\\rho_0 c) = 2 \\rho_0 c$.\n            $\\boldsymbol{R}^{-1} = \\frac{1}{2 \\rho_0 c} \\begin{bmatrix} \\rho_0 c  -1 \\\\ \\rho_0 c  1 \\end{bmatrix} = \\frac{1}{2} \\begin{bmatrix} 1  -1/(\\rho_0 c) \\\\ 1  1/(\\rho_0 c) \\end{bmatrix}$.\n            Let's check $\\boldsymbol{R}^{-1} \\boldsymbol{R} = \\boldsymbol{I}$.\n            $\\frac{1}{2 \\rho_0 c} \\begin{bmatrix} \\rho_0 c  -1 \\\\ \\rho_0 c  1 \\end{bmatrix} \\begin{bmatrix} 1  1 \\\\ -\\rho_0 c  \\rho_0 c \\end{bmatrix} = \\frac{1}{2 \\rho_0 c} \\begin{bmatrix} \\rho_0 c + \\rho_0 c  \\rho_0 c - \\rho_0 c \\\\ \\rho_0 c - \\rho_0 c  \\rho_0 c + \\rho_0 c \\end{bmatrix} = \\frac{1}{2 \\rho_0 c} \\begin{bmatrix} 2 \\rho_0 c  0 \\\\ 0  2 \\rho_0 c \\end{bmatrix} = \\boldsymbol{I}$. Correct.\n\n    *   **Constructing the Numerical Flux**: The problem specifies the Godunov-type flux as $\\boldsymbol{F}_{i+1/2} = \\boldsymbol{A}^+ \\boldsymbol{q}_i + \\boldsymbol{A}^- \\boldsymbol{q}_{i+1}$. This is a flux-splitting scheme.\n        *   We need to compute $\\boldsymbol{A}^+$ and $\\boldsymbol{A}^-$.\n        *   $\\boldsymbol{\\Lambda} = \\mathrm{diag}(-c, c)$. Since $c0$, we have:\n            $\\boldsymbol{\\Lambda}^+ = \\mathrm{diag}(\\max(-c,0), \\max(c,0)) = \\mathrm{diag}(0, c) = \\begin{bmatrix} 0  0 \\\\ 0  c \\end{bmatrix}$.\n            $\\boldsymbol{\\Lambda}^- = \\mathrm{diag}(\\min(-c,0), \\min(c,0)) = \\mathrm{diag}(-c, 0) = \\begin{bmatrix} -c  0 \\\\ 0  0 \\end{bmatrix}$.\n        *   Now compute $\\boldsymbol{A}^+ = \\boldsymbol{R} \\boldsymbol{\\Lambda}^+ \\boldsymbol{R}^{-1}$.\n            $\\boldsymbol{A}^+ = \\begin{bmatrix} 1  1 \\\\ -\\rho_0 c  \\rho_0 c \\end{bmatrix} \\begin{bmatrix} 0  0 \\\\ 0  c \\end{bmatrix} \\frac{1}{2 \\rho_0 c} \\begin{bmatrix} \\rho_0 c  -1 \\\\ \\rho_0 c  1 \\end{bmatrix}$\n            $\\boldsymbol{A}^+ = \\begin{bmatrix} 1  1 \\\\ -\\rho_0 c  \\rho_0 c \\end{bmatrix} \\frac{1}{2 \\rho_0 c} \\begin{bmatrix} 0  0 \\\\ c \\rho_0 c  c \\end{bmatrix} = \\begin{bmatrix} 1  1 \\\\ -\\rho_0 c  \\rho_0 c \\end{bmatrix} \\frac{1}{2 \\rho_0} \\begin{bmatrix} 0  0 \\\\ \\rho_0 c  1/c \\end{bmatrix}$\n            $\\boldsymbol{A}^+ = \\frac{1}{2 \\rho_0} \\begin{bmatrix} \\rho_0 c  1/c \\\\ -\\rho_0^2 c^2 + \\rho_0^2 c^2  - \\rho_0 + \\rho_0 \\end{bmatrix} = \\frac{1}{2 \\rho_0} \\begin{bmatrix} \\rho_0 c  1/c \\\\ 0  0 \\end{bmatrix}$ - wait, mistake.\n            Let's recompute $\\boldsymbol{R} \\boldsymbol{\\Lambda}^+$.\n            $\\boldsymbol{R} \\boldsymbol{\\Lambda}^+ = \\begin{bmatrix} 1  1 \\\\ -\\rho_0 c  \\rho_0 c \\end{bmatrix} \\begin{bmatrix} 0  0 \\\\ 0  c \\end{bmatrix} = \\begin{bmatrix} 0  c \\\\ 0  \\rho_0 c^2 \\end{bmatrix}$.\n            Now $\\boldsymbol{A}^+ = (\\boldsymbol{R} \\boldsymbol{\\Lambda}^+) \\boldsymbol{R}^{-1} = \\begin{bmatrix} 0  c \\\\ 0  \\rho_0 c^2 \\end{bmatrix} \\frac{1}{2} \\begin{bmatrix} 1  -1/(\\rho_0 c) \\\\ 1  1/(\\rho_0 c) \\end{bmatrix}$.\n            $\\boldsymbol{A}^+ = \\frac{1}{2} \\begin{bmatrix} c  c/(\\rho_0 c) \\\\ \\rho_0 c^2  \\rho_0 c^2 / (\\rho_0 c) \\end{bmatrix} = \\frac{1}{2} \\begin{bmatrix} c  1/\\rho_0 \\\\ \\rho_0 c^2  c \\end{bmatrix}$.\n        *   Now compute $\\boldsymbol{A}^- = \\boldsymbol{R} \\boldsymbol{\\Lambda}^- \\boldsymbol{R}^{-1}$.\n            $\\boldsymbol{R} \\boldsymbol{\\Lambda}^- = \\begin{bmatrix} 1  1 \\\\ -\\rho_0 c  \\rho_0 c \\end{bmatrix} \\begin{bmatrix} -c  0 \\\\ 0  0 \\end{bmatrix} = \\begin{bmatrix} -c  0 \\\\ \\rho_0 c^2  0 \\end{bmatrix}$.\n            Now $\\boldsymbol{A}^- = (\\boldsymbol{R} \\boldsymbol{\\Lambda}^-) \\boldsymbol{R}^{-1} = \\begin{bmatrix} -c  0 \\\\ \\rho_0 c^2  0 \\end{bmatrix} \\frac{1}{2} \\begin{bmatrix} 1  -1/(\\rho_0 c) \\\\ 1  1/(\\rho_0 c) \\end{bmatrix}$.\n            $\\boldsymbol{A}^- = \\frac{1}{2} \\begin{bmatrix} -c  c/(\\rho_0 c) \\\\ \\rho_0 c^2  -\\rho_0 c^2 / (\\rho_0 c) \\end{bmatrix} = \\frac{1}{2} \\begin{bmatrix} -c  1/\\rho_0 \\\\ \\rho_0 c^2  -c \\end{bmatrix}$.\n        *   Let's check if $\\boldsymbol{A}^+ + \\boldsymbol{A}^- = \\boldsymbol{A}$.\n            $\\boldsymbol{A}^+ + \\boldsymbol{A}^- = \\frac{1}{2} \\left( \\begin{bmatrix} c  1/\\rho_0 \\\\ \\rho_0 c^2  c \\end{bmatrix} + \\begin{bmatrix} -c  1/\\rho_0 \\\\ \\rho_0 c^2  -c \\end{bmatrix} \\right) = \\frac{1}{2} \\begin{bmatrix} 0  2/\\rho_0 \\\\ 2 \\rho_0 c^2  0 \\end{bmatrix} = \\begin{bmatrix} 0  1/\\rho_0 \\\\ \\rho_0 c^2  0 \\end{bmatrix} = \\boldsymbol{A}$. This is correct.\n\n    *   **Wave-by-wave interpretation**: The flux is $\\boldsymbol{F}_{i+1/2} = \\boldsymbol{A}^+ \\boldsymbol{q}_i + \\boldsymbol{A}^- \\boldsymbol{q}_{i+1}$. This corresponds to a wave decomposition of the jump $\\Delta \\boldsymbol{q} = \\boldsymbol{q}_{i+1} - \\boldsymbol{q}_i$. The standard Godunov flux is $\\frac{1}{2}(\\boldsymbol{f}(\\boldsymbol{q}_i) + \\boldsymbol{f}(\\boldsymbol{q}_{i+1})) - \\frac{1}{2} |\\boldsymbol{A}|(\\boldsymbol{q}_{i+1} - \\boldsymbol{q}_i)$, where $|\\boldsymbol{A}| = \\boldsymbol{A}^+ - \\boldsymbol{A}^-$.\n        Let's check if my flux formula is equivalent to this standard one.\n        $\\boldsymbol{F}_{i+1/2} = \\boldsymbol{A}^+ \\boldsymbol{q}_i + \\boldsymbol{A}^- \\boldsymbol{q}_{i+1} = \\boldsymbol{A}^+ \\boldsymbol{q}_i + (\\boldsymbol{A} - \\boldsymbol{A}^+) \\boldsymbol{q}_{i+1} = \\boldsymbol{A} \\boldsymbol{q}_{i+1} + \\boldsymbol{A}^+ (\\boldsymbol{q}_i - \\boldsymbol{q}_{i+1})$. It can also be written as $\\boldsymbol{F}_{i+1/2} = (\\boldsymbol{A} - \\boldsymbol{A}^-) \\boldsymbol{q}_i + \\boldsymbol{A}^- \\boldsymbol{q}_{i+1} = \\boldsymbol{A} \\boldsymbol{q}_i - \\boldsymbol{A}^- (\\boldsymbol{q}_i - \\boldsymbol{q}_{i+1})$.\n        Let's check the standard form.\n        $\\boldsymbol{F}_{i+1/2} = \\frac{1}{2}(\\boldsymbol{A}\\boldsymbol{q}_i + \\boldsymbol{A}\\boldsymbol{q}_{i+1}) - \\frac{1}{2}(\\boldsymbol{A}^+ - \\boldsymbol{A}^-)(\\boldsymbol{q}_{i+1} - \\boldsymbol{q}_i)$.\n        Substitute $\\boldsymbol{A} = \\boldsymbol{A}^+ + \\boldsymbol{A}^-$ and $\\boldsymbol{A}^- = \\boldsymbol{A} - \\boldsymbol{A}^+$.\n        $\\boldsymbol{F}_{i+1/2} = \\frac{1}{2}(\\boldsymbol{A}\\boldsymbol{q}_i + \\boldsymbol{A}\\boldsymbol{q}_{i+1}) - \\frac{1}{2}(\\boldsymbol{A}^+ - (\\boldsymbol{A} - \\boldsymbol{A}^+))(\\boldsymbol{q}_{i+1} - \\boldsymbol{q}_i) = \\frac{1}{2}(\\boldsymbol{A}\\boldsymbol{q}_i + \\boldsymbol{A}\\boldsymbol{q}_{i+1}) - \\frac{1}{2}(2\\boldsymbol{A}^+ - \\boldsymbol{A})(\\boldsymbol{q}_{i+1} - \\boldsymbol{q}_i)$. This doesn't seem to simplify easily to the given form.\n\n        Let's try another form. The flux is $\\boldsymbol{F}(\\boldsymbol{q}_L, \\boldsymbol{q}_R) = \\boldsymbol{A}^+ \\boldsymbol{q}_L + \\boldsymbol{A}^- \\boldsymbol{q}_R$. This is the **Lax-Friedrichs flux splitting** (or Steger-Warming splitting for Euler equations). The true Godunov flux is the flux evaluated at the exact solution of the Riemann problem at $x/t=0$. For a linear system, the solution to the Riemann problem $\\boldsymbol{q}(x,0) = \\boldsymbol{q}_L$ for $x0$ and $\\boldsymbol{q}_R$ for $x0$ is $\\boldsymbol{q}(x,t) = \\boldsymbol{q}_L + \\sum_{\\lambda_j t  x} \\alpha_j \\boldsymbol{r}_j$, where $\\boldsymbol{q}_R - \\boldsymbol{q}_L = \\sum_j \\alpha_j \\boldsymbol{r}_j$.\n        The characteristic variables are $\\boldsymbol{w} = \\boldsymbol{R}^{-1} \\boldsymbol{q}$. The jump $\\boldsymbol{q}_R - \\boldsymbol{q}_L$ is decomposed into eigenvectors: $\\boldsymbol{q}_R - \\boldsymbol{q}_L = \\alpha_1 \\boldsymbol{r}_1 + \\alpha_2 \\boldsymbol{r}_2$. The $\\alpha_j$ are the components of $\\boldsymbol{R}^{-1}(\\boldsymbol{q}_R - \\boldsymbol{q}_L)$.\n        The solution at the interface $x=0$ is $\\boldsymbol{q}^* = \\boldsymbol{q}(0,t)$. It consists of the left state plus the waves moving to the left (negative speed). Or, the right state minus the waves moving to the right (positive speed).\n        $\\boldsymbol{q}^* = \\boldsymbol{q}_L + \\sum_{\\lambda_j  0} \\alpha_j \\boldsymbol{r}_j$. In our case, only $\\lambda_1 = -c$ is negative. So $\\boldsymbol{q}^* = \\boldsymbol{q}_L + \\alpha_1 \\boldsymbol{r}_1$.\n        Also, $\\boldsymbol{q}^* = \\boldsymbol{q}_R - \\sum_{\\lambda_j  0} \\alpha_j \\boldsymbol{r}_j$. In our case, only $\\lambda_2 = c$ is positive. So $\\boldsymbol{q}^* = \\boldsymbol{q}_R - \\alpha_2 \\boldsymbol{r}_2$.\n        The Godunov flux is $\\boldsymbol{F}_{Godunov} = \\boldsymbol{A} \\boldsymbol{q}^* = \\boldsymbol{A}(\\boldsymbol{q}_L + \\alpha_1 \\boldsymbol{r}_1) = \\boldsymbol{A}\\boldsymbol{q}_L + \\alpha_1 \\boldsymbol{A}\\boldsymbol{r}_1 = \\boldsymbol{A}\\boldsymbol{q}_L + \\alpha_1 \\lambda_1 \\boldsymbol{r}_1$.\n        Also $\\boldsymbol{F}_{Godunov} = \\boldsymbol{A}(\\boldsymbol{q}_R - \\alpha_2 \\boldsymbol{r}_2) = \\boldsymbol{A}\\boldsymbol{q}_R - \\alpha_2 \\boldsymbol{A}\\boldsymbol{r}_2 = \\boldsymbol{A}\\boldsymbol{q}_R - \\alpha_2 \\lambda_2 \\boldsymbol{r}_2$.\n        The flux splitting $\\boldsymbol{A}^+ \\boldsymbol{q}_L + \\boldsymbol{A}^- \\boldsymbol{q}_R$ is indeed the Godunov flux for linear systems. Let's prove it.\n        We want to show $\\boldsymbol{A}^+ \\boldsymbol{q}_L + \\boldsymbol{A}^- \\boldsymbol{q}_R = \\boldsymbol{A} \\boldsymbol{q}^*$.\n        $\\boldsymbol{A}^+ \\boldsymbol{q}_L + \\boldsymbol{A}^- \\boldsymbol{q}_R = (\\boldsymbol{A} - \\boldsymbol{A}^-)\\boldsymbol{q}_L + \\boldsymbol{A}^- \\boldsymbol{q}_R = \\boldsymbol{A} \\boldsymbol{q}_L - \\boldsymbol{A}^-(\\boldsymbol{q}_L - \\boldsymbol{q}_R) = \\boldsymbol{A} \\boldsymbol{q}_L + \\boldsymbol{A}^- (\\boldsymbol{q}_R - \\boldsymbol{q}_L)$.\n        Let $\\Delta \\boldsymbol{q} = \\boldsymbol{q}_R - \\boldsymbol{q}_L = \\sum_j \\alpha_j \\boldsymbol{r}_j$.\n        Then $\\boldsymbol{A}^- \\Delta \\boldsymbol{q} = \\boldsymbol{A}^- \\sum_j \\alpha_j \\boldsymbol{r}_j = \\sum_j \\alpha_j \\boldsymbol{A}^- \\boldsymbol{r}_j$.\n        $\\boldsymbol{A}^- = \\boldsymbol{R} \\boldsymbol{\\Lambda}^- \\boldsymbol{R}^{-1}$. So $\\boldsymbol{A}^- \\boldsymbol{r}_j = \\boldsymbol{R} \\boldsymbol{\\Lambda}^- \\boldsymbol{R}^{-1} \\boldsymbol{r}_j$. Since $\\boldsymbol{R}^{-1} \\boldsymbol{r}_j = \\boldsymbol{e}_j$ (standard basis vector), $\\boldsymbol{A}^- \\boldsymbol{r}_j = \\boldsymbol{R} \\boldsymbol{\\Lambda}^- \\boldsymbol{e}_j$.\n        $\\boldsymbol{\\Lambda}^- \\boldsymbol{e}_j$ is the $j$-th column of $\\boldsymbol{\\Lambda}^-$. So $\\boldsymbol{R} (\\boldsymbol{\\Lambda}^- \\boldsymbol{e}_j)$ is $\\boldsymbol{r}_j$ scaled by the $j$-th element of $\\boldsymbol{\\Lambda}^-$. This is $\\min(\\lambda_j, 0) \\boldsymbol{r}_j$.\n        So, $\\boldsymbol{A}^- \\Delta \\boldsymbol{q} = \\sum_j \\alpha_j \\min(\\lambda_j, 0) \\boldsymbol{r}_j$.\n        The flux is $\\boldsymbol{A} \\boldsymbol{q}_L + \\sum_j \\alpha_j \\min(\\lambda_j, 0) \\boldsymbol{r}_j$.\n        Now let's check the Godunov flux $\\boldsymbol{A} \\boldsymbol{q}^*$.\n        $\\boldsymbol{q}^* = \\boldsymbol{q}_L + \\sum_{\\lambda_j0} \\alpha_j \\boldsymbol{r}_j$.\n        $\\boldsymbol{A} \\boldsymbol{q}^* = \\boldsymbol{A}\\boldsymbol{q}_L + \\boldsymbol{A}\\sum_{\\lambda_j0} \\alpha_j \\boldsymbol{r}_j = \\boldsymbol{A}\\boldsymbol{q}_L + \\sum_{\\lambda_j0} \\alpha_j \\boldsymbol{A}\\boldsymbol{r}_j = \\boldsymbol{A}\\boldsymbol{q}_L + \\sum_{\\lambda_j0} \\alpha_j \\lambda_j \\boldsymbol{r}_j$.\n        This is $\\boldsymbol{A}\\boldsymbol{q}_L + \\sum_j \\alpha_j \\min(\\lambda_j, 0) \\boldsymbol{r}_j$ since $\\min(\\lambda_j, 0)$ is $\\lambda_j$ if $\\lambda_j  0$ and $0$ otherwise.\n        So yes, the provided flux formula is the correct Godunov flux for a linear system.\n\n    *   **Explanation of Contribution**:\n        *   The matrix $\\boldsymbol{A}^+$ is constructed from the part of the wave spectrum with positive speeds ($\\lambda_2=c$). It propagates information from left to right across the interface. Thus, it acts on the left state $\\boldsymbol{q}_i$.\n        *   The matrix $\\boldsymbol{A}^-$ is constructed from the part of the wave spectrum with negative speeds ($\\lambda_1=-c$). It propagates information from right to left across the interface. Thus, it acts on the right state $\\boldsymbol{q}_{i+1}$.\n        *   The total flux is a superposition of these two effects. The wave with speed $c$ carries information from cell $i$ to the interface $i+1/2$, and the wave with speed $-c$ carries information from cell $i+1$ to the interface $i+1/2$.\n        *   The state at the interface, $\\boldsymbol{q}^*$, is determined by these incoming characteristics. The flux through the interface is then $\\boldsymbol{f}(\\boldsymbol{q}^*) = \\boldsymbol{A} \\boldsymbol{q}^*$.\n\n3.  **Implementation Details**:\n    *   **Discretization**:\n        *   Domain $[0, L]$ is divided into $N$ cells. Cell $i$ is $[x_{i-1/2}, x_{i+1/2}]$.\n        *   Cell centers are $x_i = (i + 0.5) \\Delta x$ for $i=0, ..., N-1$.\n        *   $\\Delta x = L/N$.\n    *   **Initial Conditions**:\n        *   The problem gives continuous initial conditions $u(x,0)$ and $p(x,0)$.\n        *   The numerical initial condition $\\boldsymbol{q}_i^0$ should be the cell average of the continuous IC over cell $i$.\n            $\\boldsymbol{q}_i^0 = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} \\boldsymbol{q}(x,0) dx$.\n        *   For a first-order method, it is common and acceptable to initialize with point values at cell centers: $\\boldsymbol{q}_i^0 = \\boldsymbol{q}(x_i, 0)$. This introduces an $O(\\Delta x^2)$ error in the initial data, but since the method is first-order accurate overall, this is acceptable. I will use this simplification.\n        *   So, $\\boldsymbol{q}_i^0 = \\begin{bmatrix} u(x_i, 0) \\\\ p(x_i, 0) \\end{bmatrix}$ where $x_i = (i+0.5)\\Delta x$.\n    *   **Time Marching**:\n        *   A constant time step is specified: $\\Delta t = \\mathrm{CFL} \\cdot \\Delta x / c$. The max eigenvalue is indeed $c$.\n        *   Loop from $t=0$ to $t=T$.\n        *   `num_steps = floor(T / dt)`.\n        *   `t_final = num_steps * dt`.\n        *   A corrective final step `dt_final = T - t_final` is needed if `T` is not an integer multiple of `dt`. The problem states: \"a final corrective step if needed so that the final time is exactly T with $\\Delta t \\le \\mathrm{CFL} \\cdot \\Delta x / c$.\" This implies that the last step might be smaller.\n        *   I will calculate `num_steps = ceil(T / dt_max)`, where `dt_max = CFL * dx / c`. Then `dt = T / num_steps`. This ensures a constant `dt` for all steps and that `t_final = T` exactly, while also satisfying `dt = dt_max`. This is a cleaner way to implement it.\n    *   **Finite Volume Update**:\n        *   At each time step $n$:\n            1.  Create a temporary array for $\\boldsymbol{q}^{n+1}$.\n            2.  Loop over cells $i=0, ..., N-1$.\n            3.  For each cell $i$, identify the left and right neighbor states for the interfaces.\n                *   At interface $x_{i+1/2}$: left state is $\\boldsymbol{q}_i^n$, right state is $\\boldsymbol{q}_{i+1}^n$.\n                *   At interface $x_{i-1/2}$: left state is $\\boldsymbol{q}_{i-1}^n$, right state is $\\boldsymbol{q}_i^n$.\n            4.  Handle periodic boundary conditions: if $i=0$, the left neighbor is cell $N-1$. If $i=N-1$, the right neighbor is cell $0$.\n            5.  Calculate the fluxes $\\boldsymbol{F}_{i+1/2}^n$ and $\\boldsymbol{F}_{i-1/2}^n$.\n                *   $\\boldsymbol{F}_{i+1/2}^n = \\boldsymbol{A}^+ \\boldsymbol{q}_i^n + \\boldsymbol{A}^- \\boldsymbol{q}_{i+1}^n$.\n                *   $\\boldsymbol{F}_{i-1/2}^n = \\boldsymbol{A}^+ \\boldsymbol{q}_{i-1}^n + \\boldsymbol{A}^- \\boldsymbol{q}_i^n$.\n                *   I'll need to implement the matrix-vector products for $\\boldsymbol{A}^+$ and $\\boldsymbol{A}^-$.\n            6.  Update the state: $\\boldsymbol{q}_i^{n+1} = \\boldsymbol{q}_i^n - \\frac{\\Delta t}{\\Delta x} (\\boldsymbol{F}_{i+1/2}^n - \\boldsymbol{F}_{i-1/2}^n)$.\n    *   **Exact Solution**:\n        *   At $t=T$, calculate the exact solution at each cell center $x_i$.\n        *   Use the provided formulas:\n            *   $\\alpha_+(x,0) = \\frac{1}{2}\\left(A_u \\sin(2\\pi k x) + \\frac{A_p \\cos(2\\pi k x)}{\\rho_0 c}\\right)$\n            *   $\\alpha_-(x,0) = \\frac{1}{2}\\left(A_u \\sin(2\\pi k x) - \\frac{A_p \\cos(2\\pi k x)}{\\rho_0 c}\\right)$\n            *   $u(x_i,T) = \\alpha_+(x_i - cT, 0) + \\alpha_-(x_i + cT, 0)$\n            *   $p(x_i,T) = \\rho_0 c (\\alpha_+(x_i - cT, 0) - \\alpha_-(x_i + cT, 0))$\n        *   The arguments to $\\alpha$ need to be handled with periodicity.\n            The functions $\\sin(2\\pi k x)$ and $\\cos(2\\pi k x)$ (with integer $k$) are periodic on $[0,1]$ if $L=1$.\n            If $x' = x - cT$, the value is $\\alpha_{+}(x', 0)$.\n            For a domain $[0, L]$, the argument to the trig functions is $2\\pi k x / L$.\n            Let's re-verify the periodicity. Initial condition is $f(x) = \\sin(2\\pi k x)$. This implies $L=1$. The problem statement says the domain is $[0,L]$, but the IC formula uses $2\\pi k x$. This is slightly ambiguous. I'll assume the argument should be $2\\pi k x / L$. All test cases use $L=1$, so it makes no difference. I'll code it with the general $L$.\n            $u(x,0) = A_u \\sin(2\\pi k x / L)$\n            $p(x,0) = A_p \\cos(2\\pi k x / L)$\n            So $\\alpha_+(x,0) = \\frac{1}{2}\\left(A_u \\sin(2\\pi k x/L) + \\frac{A_p \\cos(2\\pi k x/L)}{\\rho_0 c}\\right)$\n            The exact solution involves evaluating $\\alpha_\\pm$ at shifted positions.\n            $\\alpha_+(x - c t, 0)$: Here $x$ is the evaluation point. For us, $x=x_i$.\n            $x_{\\mathrm{shifted}+} = x_i - cT$. We need to map this back to $[0, L]$.\n            $x_{\\mathrm{shifted}+, \\mathrm{mod}} = (x_i - cT) \\pmod L$. In Python, this is `(x_i - c*T) % L`.\n            $x_{\\mathrm{shifted}-, \\mathrm{mod}} = (x_i + cT) \\pmod L$.\n            Then we evaluate the `alpha_` functions at these new positions.\n    *   **Error Calculation**:\n        *   $E = \\sqrt{\\frac{1}{N} \\sum_{i=0}^{N-1} \\left( (u_i^{\\mathrm{num}} - u_i^{\\mathrm{exact}})^2 + (p_i^{\\mathrm{num}} - p_i^{\\mathrm{exact}})^2 \\right)}$\n        *   This is a standard discrete L2 norm of the error vector.\n\n4.  **Code Structure**:\n    *   I'll define a main `solve()` function as requested.\n    *   Inside `solve()`, I'll define a helper function, say `run_simulation(params)`, that takes one test case's parameters and returns the error $E$.\n    *   The `test_cases` list will hold the tuples of parameters.\n    *   A loop will call `run_simulation` for each case and collect the results.\n    *   Finally, format the output string.\n\nLet's write down the explicit update steps for implementation using the matrices `A+` and `A-`.\n$\\boldsymbol{q} = \\begin{bmatrix} u \\\\ p \\end{bmatrix}$.\n$\\boldsymbol{A}^+ = \\frac{1}{2} \\begin{bmatrix} c  1/\\rho_0 \\\\ \\rho_0 c^2  c \\end{bmatrix}$\n$\\boldsymbol{A}^- = \\frac{1}{2} \\begin{bmatrix} -c  1/\\rho_0 \\\\ \\rho_0 c^2  -c \\end{bmatrix}$\n\nLet's compute the flux $\\boldsymbol{F}_{i+1/2} = \\boldsymbol{A}^+ \\boldsymbol{q}_i + \\boldsymbol{A}^- \\boldsymbol{q}_{i+1}$ where $\\boldsymbol{q}_i = \\begin{bmatrix} u_i \\\\ p_i \\end{bmatrix}$ and $\\boldsymbol{q}_{i+1} = \\begin{bmatrix} u_{i+1} \\\\ p_{i+1} \\end{bmatrix}$.\n\n$\\boldsymbol{A}^+ \\boldsymbol{q}_i = \\frac{1}{2} \\begin{bmatrix} c u_i + p_i/\\rho_0 \\\\ \\rho_0 c^2 u_i + c p_i \\end{bmatrix}$\n$\\boldsymbol{A}^- \\boldsymbol{q}_{i+1} = \\frac{1}{2} \\begin{bmatrix} -c u_{i+1} + p_{i+1}/\\rho_0 \\\\ \\rho_0 c^2 u_{i+1} - c p_{i+1} \\end{bmatrix}$\n\nSo $\\boldsymbol{F}_{i+1/2} = \\begin{bmatrix} F_u \\\\ F_p \\end{bmatrix}_{i+1/2}$ where\n$F_{u, i+1/2} = \\frac{1}{2} \\left[ c(u_i - u_{i+1}) + \\frac{1}{\\rho_0}(p_i + p_{i+1}) \\right]$\n$F_{p, i+1/2} = \\frac{1}{2} \\left[ \\rho_0 c^2 (u_i + u_{i+1}) + c(p_i - p_{i+1}) \\right]$\n\nLet's verify this. This is the Roe flux for this linear system.\nThe Roe flux is $\\frac{1}{2}(\\boldsymbol{f}_L + \\boldsymbol{f}_R) - \\frac{1}{2}|\\boldsymbol{A}_{Roe}|(\\boldsymbol{q}_R - \\boldsymbol{q}_L)$. For a linear system, $\\boldsymbol{A}_{Roe}$ is just $\\boldsymbol{A}$. So this is $\\frac{1}{2}(\\boldsymbol{A}\\boldsymbol{q}_L + \\boldsymbol{A}\\boldsymbol{q}_R) - \\frac{1}{2}|\\boldsymbol{A}|(\\boldsymbol{q}_R - \\boldsymbol{q}_L)$.\n$|\\boldsymbol{A}| = \\boldsymbol{R} |\\boldsymbol{\\Lambda}| \\boldsymbol{R}^{-1}$. $|\\boldsymbol{\\Lambda}| = \\mathrm{diag}(c, c) = c \\boldsymbol{I}$. So $|\\boldsymbol{A}| = c \\boldsymbol{I}$.\nThis gives Roe flux $\\boldsymbol{F}_{Roe} = \\frac{1}{2}(\\boldsymbol{A}\\boldsymbol{q}_L + \\boldsymbol{A}\\boldsymbol{q}_R) - \\frac{c}{2}(\\boldsymbol{q}_R - \\boldsymbol{q}_L)$.\nLet's expand it.\n$\\boldsymbol{A}\\boldsymbol{q} = \\begin{bmatrix} p/\\rho_0 \\\\ \\rho_0 c^2 u \\end{bmatrix}$.\n$F_{u, Roe} = \\frac{1}{2} \\left( \\frac{p_L}{\\rho_0} + \\frac{p_R}{\\rho_0} \\right) - \\frac{c}{2}(u_R - u_L) = \\frac{1}{2} \\left( c(u_L - u_R) + \\frac{1}{\\rho_0}(p_L + p_R) \\right)$. This matches my $F_u$.\n$F_{p, Roe} = \\frac{1}{2} \\left( \\rho_0 c^2 u_L + \\rho_0 c^2 u_R \\right) - \\frac{c}{2}(p_R - p_L) = \\frac{1}{2} \\left( \\rho_0 c^2 (u_L + u_R) + c(p_L - p_R) \\right)$. This matches my $F_p$.\nSo the specified flux splitting scheme is equivalent to the Roe solver for this linear system. Ok, good.\n\nThe update step:\n$\\boldsymbol{q}_i^{n+1} = \\boldsymbol{q}_i^n - \\frac{\\Delta t}{\\Delta x} (\\boldsymbol{F}_{i+1/2} - \\boldsymbol{F}_{i-1/2})$.\nThis is vectorized. We can compute all fluxes $\\boldsymbol{F}_{i+1/2}$ for $i=0, ..., N-1$.\nThe array of fluxes `F` will be of size `N x 2`. `F[i, :]` will hold $\\boldsymbol{F}_{i+1/2}$.\nThe left state is `q`, the right state is `q` shifted. For periodic BCs, `q_right = np.roll(q, -1, axis=0)`.\nLet `q` be `N x 2`. `q_left` is `q`. `q_right` is `np.roll(q, -1, axis=0)`.\n$u_L = q[:, 0], p_L = q[:, 1]$.\n$u_R = q_{right}[:, 0], p_R = q_{right}[:, 1]$.\nThen we compute the flux array `F`.\n`F_u = 0.5 * (c * (u_L - u_R) + (p_L + p_R) / rho0)`\n`F_p = 0.5 * (rho0 * c**2 * (u_L + u_R) + c * (p_L - p_R))`\n`F` is a `N x 2` array where `F[i]` is the flux at interface `i+1/2`.\nNow we need `F_{i-1/2}`. This is `F` shifted: `F_left = np.roll(F, 1, axis=0)`.\nUpdate: `q_new = q - (dt/dx) * (F - F_left)`.\n\nFinal check on the `k=0` case.\n$u(x,0) = A_u \\sin(0) = 0$.\n$p(x,0) = A_p \\cos(0) = A_p$.\nSo the initial state is $\\boldsymbol{q}(x,0) = \\begin{bmatrix} 0 \\\\ A_p \\end{bmatrix}$, a constant state.\nThe update law is $\\boldsymbol{q}_i^{n+1} = \\boldsymbol{q}_i^n - \\frac{\\Delta t}{\\Delta x} (\\boldsymbol{F}_{i+1/2} - \\boldsymbol{F}_{i-1/2})$.\nIf the state is constant, $\\boldsymbol{q}_i = \\boldsymbol{q}_{i+1} = \\boldsymbol{q}_{i-1}$ for all $i$.\nThen $\\boldsymbol{F}_{i+1/2} = \\boldsymbol{A}^+\\boldsymbol{q}_i + \\boldsymbol{A}^-\\boldsymbol{q}_{i+1} = (\\boldsymbol{A}^+ + \\boldsymbol{A}^-) \\boldsymbol{q}_{i} = \\boldsymbol{A} \\boldsymbol{q}_i$.\nAnd $\\boldsymbol{F}_{i-1/2} = \\boldsymbol{A}^+\\boldsymbol{q}_{i-1} + \\boldsymbol{A}^-\\boldsymbol{q}_{i} = (\\boldsymbol{A}^+ + \\boldsymbol{A}^-) \\boldsymbol{q}_{i} = \\boldsymbol{A} \\boldsymbol{q}_i$.\nThe flux difference is $\\boldsymbol{F}_{i+1/2} - \\boldsymbol{F}_{i-1/2} = \\boldsymbol{A}\\boldsymbol{q}_i - \\boldsymbol{A}\\boldsymbol{q}_i = \\boldsymbol{0}$.\nSo $\\boldsymbol{q}_i^{n+1} = \\boldsymbol{q}_i^n$. The state should not change. This is a good sanity check. The scheme should be exact for a constant state.\nWhat is the exact solution for this case?\n$\\alpha_+(x,0) = \\frac{1}{2}\\left(0 + \\frac{A_p}{\\rho_0 c}\\right) = \\frac{A_p}{2\\rho_0 c}$.\n$\\alpha_-(x,0) = \\frac{1}{2}\\left(0 - \\frac{A_p}{\\rho_0 c}\\right) = -\\frac{A_p}{2\\rho_0 c}$.\nThese are constants.\n$u(x,t) = \\alpha_+(x-ct,0) + \\alpha_-(x+ct,0) = \\frac{A_p}{2\\rho_0 c} - \\frac{A_p}{2\\rho_0 c} = 0$.\n$p(x,t) = \\rho_0 c (\\alpha_+(x-ct,0) - \\alpha_-(x-ct,0)) = \\rho_0 c \\left( \\frac{A_p}{2\\rho_0 c} - (-\\frac{A_p}{2\\rho_0 c}) \\right) = \\rho_0 c \\left(\\frac{A_p}{\\rho_0 c}\\right) = A_p$.\nThe exact solution is $\\boldsymbol{q}(x, t) = \\begin{bmatrix} 0 \\\\ A_p \\end{bmatrix}$, which is constant in time.\nSo for Case 4, the numerical solution should be identical to the initial condition (up to machine precision), and the exact solution is also the initial condition. The error should be close to zero. The parameters for Case 4 are $k=0, A_u=0, A_p=1$. My derivation is correct. So $u(x,0)=0, p(x,0)=1$. The numerical scheme should preserve this state exactly. The error will test the implementation correctness.\n\nFinal check on the time-stepping part. `dt = CFL * dx / c`. This is the maximum allowed `dt`. The problem says \"a constant time step $\\Delta t = \\mathrm{CFL} \\cdot \\Delta x / c$ and a final corrective step if needed\". This is a bit ambiguous. Let's re-read: \"advances the scheme to a specified final time $T$ using a constant time step $\\Delta t = \\mathrm{CFL} \\cdot \\Delta x / c$ and a final corrective step if needed so that the final time is exactly $T$ with $\\Delta t \\le \\mathrm{CFL} \\cdot \\Delta x / c$\".\nThis could be interpreted in two ways:\n1. Use `dt = CFL * dx / c` for as many steps as you can, then use a smaller `dt_final = T - n*dt`.\n2. Find the number of steps `N_steps` such that `N_steps * dt = T` and `dt = CFL * dx / c`. This would mean `dt = T / ceil(T / dt_max)`. This gives a constant `dt` for all steps.\n\nThe wording \"using a constant time step ... and a final corrective step\" suggests option 1.\nLet `dt_max = CFL * dx / c`.\n`num_steps = floor(T / dt_max)`.\n`dt = dt_max`.\nLoop for `num_steps`.\n`t_current = num_steps * dt`.\n`dt_final = T - t_current`.\nIf `dt_final  1e-9` (or some small tolerance), take one more step with `dt_final`.\n\nThis seems more faithful to the phrasing. Let's implement it this way.\nExample: T=0.5, dt_max=0.12.\nnum_steps = floor(0.5/0.12) = floor(4.166) = 4.\nt_current = 4 * 0.12 = 0.48.\ndt_final = 0.5 - 0.48 = 0.02.\nSo I do 4 steps with dt=0.12 and one final step with dt=0.02.\nThis seems correct and robust.\n\nFinal check on the exact solution periodicity.\nThe initial condition is specified using $2\\pi k x$. This implies the domain is $[0,1]$.\n$L$ is specified separately. The problem then says \"interpreted with periodicity on $[0,L]$\".\nSo, the functions should be $u(x,0) = A_u \\sin(2\\pi k x/L)$ and $p(x,0) = A_p \\cos(2\\pi k x/L)$.\nThis makes the functions $L$-periodic.\nSo, $\\alpha_+(x-cT, 0)$ is evaluated at argument $(x_i - cT) \\pmod L$.\nLet `x_mod = (x - c*T) % L`. If the result is negative, add `L`.\n`x_mod = (x - c*T) % L`. In Python, `%` operator behaves as a mathematical modulo for positive divisor `L`, i.e., result has same sign as divisor. So `(-0.2) % 1.0` is `0.8`. This is what I want.\nExample: $L=1, x_i=0.1, c=1, T=0.5$. `x_shifted = 0.1 - 0.5 = -0.4`. `(-0.4) % 1.0 = 0.6$. The functions are then evaluated at $x=0.6$. This is correct.\n\nLooks like I have all the pieces. I will now write down the solution structure.\nStart with the problem validation.\nThen the derivation of $\\boldsymbol{A}^+, \\boldsymbol{A}^-$.\nDescription of the numerical scheme.\nThen the implementation details.\nFinally, the python code.\n\nThe structure of the solution text:\n1.  **Problem Validation**: Formal check, which will pass.\n2.  **Derivation of the Godunov-type scheme**:\n    *   **Eigen-decomposition**: State the matrix $\\boldsymbol{A}$. Compute its eigenvalues $\\lambda_1, \\lambda_2$ and eigenvectors $\\boldsymbol{r}_1, \\boldsymbol{r}_2$. Form the matrices $\\boldsymbol{R}$ and $\\boldsymbol{R}^{-1}$.\n    *   **Flux Splitting**: Define $\\boldsymbol{\\Lambda}^+, \\boldsymbol{\\Lambda}^-$. Compute $\\boldsymbol{A}^+ = \\boldsymbol{R} \\boldsymbol{\\Lambda}^+ \\boldsymbol{R}^{-1}$ and $\\boldsymbol{A}^- = \\boldsymbol{R} \\boldsymbol{\\Lambda}^- \\boldsymbol{R}^{-1}$ explicitly. Show the resulting matrices.\n    *   **Numerical Flux**: Explain that the flux $\\boldsymbol{F}_{i+1/2}^n = \\boldsymbol{A}^+ \\boldsymbol{q}_i^n + \\boldsymbol{A}^- \\boldsymbol{q}_{i+1}^n$ is the Godunov flux for this linear system. Explain the wave contributions.\n    *   **Final Algorithm**: Write out the full update formula $\\boldsymbol{q}_i^{n+1} = \\boldsymbol{q}_i^n - \\frac{\\Delta t}{\\Delta x}(\\boldsymbol{F}_{i+\\frac{1}{2}}^n - \\boldsymbol{F}_{i-\\frac{1}{2}}^n)$ with the explicit vectorized component-wise expressions for the flux terms derived previously.\n\n3.  **Implementation Strategy**:\n    *   **Discretization and Initialization**: Grid setup, cell centers, initial condition sampling.\n    *   **Time Integration**: Explain the time-stepping logic with the final corrective step.\n    *   **Boundary Conditions**: Explain how periodic BCs are handled using `numpy.roll`.\n    *   **Exact Solution and Error**: Detail the calculation of the exact solution at time $T$ including periodic wrapping of coordinates, and the final RMS error formula.\n\nThis seems comprehensive and follows the spirit of the 'meticulous professor' persona. I will be careful with LaTeX formatting for every single mathematical entity.\n\nTest case 4: $k=0, A_u=0, A_p=1$.\n$u(x,0) = 0, p(x,0) = 1$.\n$u(x,t) = 0, p(x,t) = 1$.\nNumerical initial condition: $u_{i}^0 = 0, p_{i}^0=1$.\nFlux calculation:\n$u_i=u_{i+1}=0$. $p_i=p_{i+1}=1$.\n$F_{u, i+1/2} = \\frac{1}{2} \\left[ c(0 - 0) + \\frac{1}{\\rho_0}(1 + 1) \\right] = 1/\\rho_0$.\n$F_{p, i+1/2} = \\frac{1}{2} \\left[ \\rho_0 c^2 (0 + 0) + c(1 - 1) \\right] = 0$.\nSo $\\boldsymbol{F}_{i+1/2} = \\begin{bmatrix} 1/\\rho_0 \\\\ 0 \\end{bmatrix}$.\nThis is constant for all interfaces. So $\\boldsymbol{F}_{i+1/2} - \\boldsymbol{F}_{i-1/2} = \\boldsymbol{0}$.\nThe update is zero, solution is stationary. $u_i^n=0, p_i^n=1$.\nError computation:\n$u_i^{\\mathrm{num}} = 0, u_i^{\\mathrm{exact}} = 0$.\n$p_i^{\\mathrm{num}} = 1, p_i^{\\mathrm{exact}} = 1$.\nThe error should be $0$. Excellent.\n\nThis walkthrough confirms my understanding of the problem and desired method. The derivation is straightforward, and the implementation logic is clear. I'm ready to write the solution.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1: (N, L, rho0, c, CFL, k, Au, Ap, T)\n        (200, 1.0, 1.0, 1.0, 0.5, 1, 1.0, 1.0, 0.5),\n        # Case 2: (N, L, rho0, c, CFL, k, Au, Ap, T)\n        (200, 1.0, 1.0, 1.0, 0.99, 2, 1.0, 0.5, 0.25),\n        # Case 3: (N, L, rho0, c, CFL, k, Au, Ap, T)\n        (20, 1.0, 1.0, 1.0, 0.9, 1, 0.5, 1.5, 0.5),\n        # Case 4: (N, L, rho0, c, CFL, k, Au, Ap, T)\n        (128, 1.0, 1.0, 1.0, 0.8, 0, 0.0, 1.0, 0.3),\n    ]\n\n    results = []\n    for params in test_cases:\n        error = run_simulation(*params)\n        results.append(f\"{error:.7e}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef run_simulation(N, L, rho0, c, CFL, k, Au, Ap, T):\n    \"\"\"\n    Runs a single simulation for a given set of parameters.\n    \"\"\"\n    # 1. Discretization and Initial Conditions\n    dx = L / N\n    x = np.linspace(dx / 2, L - dx / 2, N)\n    \n    # Initialize state vector q = [u, p]\n    q = np.zeros((N, 2))\n    pi_factor = 2 * np.pi * k / L\n    \n    # Using cell-center values for initialization, which is standard for 1st order schemes\n    if k == 0: # Handle k=0 case to avoid issues with sin(0) and cos(0)\n        q[:, 0] = Au * 0.0\n        q[:, 1] = Ap * 1.0\n    else:\n        q[:, 0] = Au * np.sin(pi_factor * x)\n        q[:, 1] = Ap * np.cos(pi_factor * x)\n\n    # 2. Time Integration\n    t = 0.0\n    dt_max = CFL * dx / c\n\n    # Time-stepping logic: use dt_max for most steps, with a final corrective step.\n    num_steps = int(np.floor(T / dt_max))\n    dt_final = T - num_steps * dt_max\n    \n    # Pre-calculate constants for flux computation\n    c_half = 0.5 * c\n    rho0c_sq_half = 0.5 * rho0 * c**2\n    one_over_2rho0 = 0.5 / rho0\n\n    for _ in range(num_steps):\n        q = time_step(q, dx, dt_max, c_half, rho0c_sq_half, one_over_2rho0)\n    \n    if dt_final  1e-12: # Check if a final corrective step is needed\n        q = time_step(q, dx, dt_final, c_half, rho0c_sq_half, one_over_2rho0)\n        \n    q_numerical = q\n\n    # 3. Exact Solution\n    q_exact = np.zeros((N, 2))\n    \n    # Define characteristic variables at t=0\n    def alpha_plus(x_loc, L, k, Au, Ap, rho0, c):\n        pi_factor_loc = 2 * np.pi * k / L\n        if k == 0:\n            u0 = Au * 0.0\n            p0 = Ap * 1.0\n        else:\n            u0 = Au * np.sin(pi_factor_loc * x_loc)\n            p0 = Ap * np.cos(pi_factor_loc * x_loc)\n        return 0.5 * (u0 + p0 / (rho0 * c))\n    \n    def alpha_minus(x_loc, L, k, Au, Ap, rho0, c):\n        pi_factor_loc = 2 * np.pi * k / L\n        if k == 0:\n            u0 = Au * 0.0\n            p0 = Ap * 1.0\n        else:\n            u0 = Au * np.sin(pi_factor_loc * x_loc)\n            p0 = Ap * np.cos(pi_factor_loc * x_loc)\n        return 0.5 * (u0 - p0 / (rho0 * c))\n\n    # Evaluate exact solution at cell centers x at time T\n    x_shifted_plus = (x - c * T) % L\n    x_shifted_minus = (x + c * T) % L\n    \n    alpha_p_vals = alpha_plus(x_shifted_plus, L, k, Au, Ap, rho0, c)\n    alpha_m_vals = alpha_minus(x_shifted_minus, L, k, Au, Ap, rho0, c)\n    \n    q_exact[:, 0] = alpha_p_vals + alpha_m_vals\n    q_exact[:, 1] = rho0 * c * (alpha_p_vals - alpha_m_vals)\n\n    # 4. Error Calculation\n    error = np.sqrt(np.mean((q_numerical[:, 0] - q_exact[:, 0])**2 + (q_numerical[:, 1] - q_exact[:, 1])**2))\n    \n    return error\n\ndef time_step(q, dx, dt, c_half, rho0c_sq_half, one_over_2rho0):\n    \"\"\"\n    Advances the solution by one time step using the Godunov scheme.\n    \"\"\"\n    # Left and right states for interface flux calculations\n    q_left = q\n    q_right = np.roll(q, -1, axis=0) # Periodic boundary condition\n\n    u_L, p_L = q_left[:, 0], q_left[:, 1]\n    u_R, p_R = q_right[:, 0], q_right[:, 1]\n    \n    # Compute interface fluxes F_{i+1/2} using the derived explicit formula\n    flux = np.zeros_like(q)\n    flux[:, 0] = c_half * (u_L - u_R) + one_over_2rho0 * (p_L + p_R)\n    flux[:, 1] = rho0c_sq_half * (u_L + u_R) + c_half * (p_L - p_R)\n    \n    # Flux at interface F_{i-1/2} is the F_{i+1/2} of the previous cell\n    flux_prev = np.roll(flux, 1, axis=0)\n    \n    # Finite volume update\n    q_new = q - (dt / dx) * (flux - flux_prev)\n    return q_new\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3452358"}, {"introduction": "Not all hyperbolic systems are \"strictly\" hyperbolic; some important physical models possess a degenerate wave structure, which requires special care. This exercise delves into such a case, where the system's coefficient matrix is not diagonalizable and has a Jordan block structure. The task involves analyzing the exact viscous solution to see how this structure couples the characteristic fields, producing unique wave phenomena that a naive, decoupled approach would fail to capture. This practice [@problem_id:3452289] provides a crucial lesson on the importance of a complete eigenstructure analysis for ensuring the physical and mathematical fidelity of a numerical solver.", "problem": "Consider the linear $2 \\times 2$ system of partial differential equations for the vector field $U(x,t) \\in \\mathbb{R}^2$,\n$$\n\\partial_t U(x,t) + A \\, \\partial_x U(x,t) = \\varepsilon \\, \\partial_{xx} U(x,t),\n$$\nwhere $A \\in \\mathbb{R}^{2 \\times 2}$ is a constant matrix and $\\varepsilon  0$ is a small viscosity parameter. Throughout, take\n$$\nA = \\begin{pmatrix} a  1 \\\\ 0  a \\end{pmatrix}, \\quad a \\in \\mathbb{R}.\n$$\nThis matrix has a single eigenvalue $a$ with algebraic multiplicity $2$ and is not diagonalizable; it has a Jordan block of size $2$. Let the initial data be a Riemann problem\n$$\nU(x,0) = \\begin{cases} U_L,  x  0, \\\\ U_R,  x  0, \\end{cases}\n$$\nwith $U_L, U_R \\in \\mathbb{R}^2$ constants. Write $U = (u, v)^\\top$.\n\nYour tasks are to design and compare two Riemann solvers at advanced-graduate level, grounded in first principles:\n\n1. Starting from the definition of hyperbolicity and the Jordan decomposition, explain why this system is non-strictly hyperbolic and derive how the Jordan structure influences wave decomposition. Construct an eigenstructure-aware viscous Riemann solver that respects the Jordan chain structure and vanishing viscosity, and produces the solution $U(x,t)$ for given $a$, $\\varepsilon$, $U_L$, $U_R$, on a computational grid at a specified time $t$.\n\n2. Construct a naive solver that ignores the generalized eigenvector and treats both components $u$ and $v$ as independent scalar convection-diffusion problems.\n\n3. Using a fundamental self-similar analysis base, quantify the following at a specified final time $t$:\n   - The relative $L^2$ error of the naive solver for the $u$-component against the eigenstructure-aware viscous solver, computed on the spatial grid with standard trapezoidal quadrature.\n   - The excess mass in $u$ beyond its scalar convection-diffusion step profile, integrated over the spatial domain, compared with the Jordan-chain prediction $- t [v]$ in the vanishing viscosity limit, where $[v] = v_R - v_L$. Report the absolute difference as a float.\n   - The change in the quadratic entropy of the second component, $\\eta(v) = \\tfrac{1}{2} v^2$, from $t=0$ to the final time $t$, integrated over the spatial domain with trapezoidal quadrature. This quantity should be non-positive due to viscosity; report it as a float.\n\nThe program must implement both solvers and compute the above three quantities for each of the following test cases (test suite), each with a uniform spatial grid $x \\in [-L, L]$ and spacing $\\Delta x$:\n\n- Test case $1$ (general case): $a = 1$, $\\varepsilon = 10^{-2}$, $U_L = (1, 0)^\\top$, $U_R = (0, 1)^\\top$, $t = 0.5$, $L = 1.0$, $\\Delta x = 0.002$.\n- Test case $2$ (boundary case with zero jump in $v$): $a = 1$, $\\varepsilon = 10^{-2}$, $U_L = (1, 0)^\\top$, $U_R = (0, 0)^\\top$, $t = 0.5$, $L = 1.0$, $\\Delta x = 0.002$.\n- Test case $3$ (edge case with very small viscosity): $a = 1$, $\\varepsilon = 10^{-4}$, $U_L = (0, 0)^\\top$, $U_R = (1, 1)^\\top$, $t = 0.5$, $L = 1.0$, $\\Delta x = 0.001$.\n\nYour program should produce a single line of output containing the results for the three test cases as a comma-separated list enclosed in square brackets, where each test caseâ€™s result is itself a comma-separated list with the three floats described above, in the order specified. For example, the output format must be:\n$$\n[\\,[r_{1,1},r_{1,2},r_{1,3}],\\,[r_{2,1},r_{2,2},r_{2,3}],\\,[r_{3,1},r_{3,2},r_{3,3}]\\,],\n$$\nwith no spaces in the printed line.", "solution": "The problem statement is assessed to be valid. It is scientifically grounded in the theory of partial differential equations, specifically non-strictly hyperbolic systems with viscous regularization. The problem is well-posed, objective, and provides all necessary information to construct a unique, verifiable solution.\n\n### System Analysis and Hyperbolicity\n\nThe governing system of partial differential equations is given by:\n$$\n\\partial_t U(x,t) + A \\, \\partial_x U(x,t) = \\varepsilon \\, \\partial_{xx} U(x,t)\n$$\nwhere $U = (u, v)^\\top$ and the matrix $A$ is:\n$$\nA = \\begin{pmatrix} a  1 \\\\ 0  a \\end{pmatrix}\n$$\nThe hyperbolicity of the corresponding first-order system (with $\\varepsilon = 0$) is determined by the eigenstructure of $A$. The characteristic equation is $\\det(A - \\lambda I) = (a - \\lambda)^2 = 0$, which yields a single eigenvalue $\\lambda = a$ with algebraic multiplicity $2$.\n\nTo find the eigenvectors, we solve $(A - aI)r = 0$:\n$$\n\\begin{pmatrix} 0  1 \\\\ 0  0 \\end{pmatrix} \\begin{pmatrix} r_1 \\\\ r_2 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}\n$$\nThis implies $r_2 = 0$, so the eigenvectors are of the form $c \\cdot (1, 0)^\\top$ for any $c \\in \\mathbb{R} \\setminus \\{0\\}$. The eigenspace is one-dimensional, spanned by the eigenvector $r^{(1)} = (1, 0)^\\top$. Since the geometric multiplicity ($1$) is less than the algebraic multiplicity ($2$), the matrix $A$ is not diagonalizable. A system of conservation laws is hyperbolic if its coefficient matrix is diagonalizable with real eigenvalues. Since $A$ is not diagonalizable, this system is classified as **non-strictly hyperbolic**.\n\nThe lack of a full basis of eigenvectors necessitates the use of a Jordan decomposition. We find a generalized eigenvector $r^{(2)}$ that forms a Jordan chain, satisfying $(A - aI)r^{(2)} = r^{(1)}$.\n$$\n\\begin{pmatrix} 0  1 \\\\ 0  0 \\end{pmatrix} \\begin{pmatrix} r_{2,1} \\\\ r_{2,2} \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}\n$$\nThis gives $r_{2,2} = 1$. We can choose $r^{(2)} = (0, 1)^\\top$. The matrix of basis vectors $P = [r^{(1)}, r^{(2)}]$ is the identity matrix $I$. The Jordan normal form is $J = P^{-1}AP = A$. The system is already in its Jordan canonical form.\n\nThe components $u$ and $v$ are the characteristic variables corresponding to this Jordan basis. The system can be written component-wise as:\n$$\n\\begin{align*}\n\\partial_t u + a \\partial_x u + \\partial_x v = \\varepsilon \\partial_{xx} u \\\\\n\\partial_t v + a \\partial_x v = \\varepsilon \\partial_{xx} v\n\\end{align*}\nThe Jordan structure manifests as a one-way coupling: the equation for $v$ is a standard scalar convection-diffusion equation, but its solution, through the term $\\partial_x v$, acts as a source term for the equation for $u$.\n\n### 1. Eigenstructure-Aware Viscous Riemann Solver\n\nThis solver respects the coupled structure derived above.\n\nFirst, we solve for $v(x,t)$. The equation is a standard scalar convection-diffusion equation with Riemann initial data $v(x,0) = v_L$ for $x  0$ and $v_R$ for $x  0$. The analytical solution is well-known and can be found by transforming to a moving frame $\\xi = x - at$, which reduces the PDE to the heat equation. The solution is:\n$$\nv(x,t) = v_L + \\frac{[v]}{2} \\left( 1 + \\text{erf}\\left(\\frac{x-at}{\\sqrt{4\\varepsilon t}}\\right) \\right)\n$$\nwhere $[v] = v_R - v_L$ is the jump in the initial data for $v$, and $\\text{erf}$ is the error function. For conciseness, we denote this exact solution as $v_{exact}(x,t)$.\n\nNext, we solve for $u(x,t)$. The equation is a forced convection-diffusion equation:\n$$\n\\partial_t u + a \\partial_x u - \\varepsilon \\partial_{xx} u = -\\partial_x v_{exact}\n$$\nThe solution $u(x,t)$ is the sum of the homogeneous solution $u_h(x,t)$ and a particular solution $u_p(x,t)$.\nThe homogeneous part satisfies the unforced equation with the initial condition $u(x,0)$. Its solution has the same form as that for $v(x,t)$:\n$$\nu_h(x,t) = u_L + \\frac{[u]}{2} \\left( 1 + \\text{erf}\\left(\\frac{x-at}{\\sqrt{4\\varepsilon t}}\\right) \\right)\n$$\nwhere $[u] = u_R - u_L$.\n\nFor the particular solution $u_p(x,t)$, we observe that a solution of the form $u_p(x,t) = C t \\, \\partial_x v_{exact}(x,t)$ is a promising ansatz, motivated by the structure of the solution in the vanishing viscosity limit ($\\varepsilon \\to 0$). Substituting this into the PDE for $u$ and using the fact that $v_{exact}$ solves its own PDE, we find that $C=-1$. Thus, a particular solution is $u_p(x,t) = -t \\, \\partial_x v_{exact}(x,t)$. The derivative of $v_{exact}$ is:\n$$\n\\partial_x v_{exact}(x,t) = \\frac{[v]}{\\sqrt{4\\pi\\varepsilon t}} e^{-\\frac{(x-at)^2}{4\\varepsilon t}}\n$$\nCombining these parts, the complete eigenstructure-aware solution $U_{exact} = (u_{exact}, v_{exact})^\\top$ is:\n$$\nv_{exact}(x,t) = v_L + \\frac{[v]}{2} \\left( 1 + \\text{erf}\\left(\\frac{x-at}{\\sqrt{4\\varepsilon t}}\\right) \\right)\n$$\n$$\nu_{exact}(x,t) = \\left( u_L + \\frac{[u]}{2} \\left( 1 + \\text{erf}\\left(\\frac{x-at}{\\sqrt{4\\varepsilon t}}\\right) \\right) \\right) - \\frac{t [v]}{\\sqrt{4\\pi\\varepsilon t}} e^{-\\frac{(x-at)^2}{4\\varepsilon t}}\n$$\n\n### 2. Naive Solver\n\nThe naive solver incorrectly assumes the system is fully decoupled, equivalent to having a diagonal matrix $A = aI$. This ignores the off-diagonal $1$ in the Jordan block, which represents the influence of the generalized eigenvector. The system is treated as:\n$$\n\\begin{align*}\n\\partial_t u + a \\partial_x u = \\varepsilon \\partial_{xx} u \\\\\n\\partial_t v + a \\partial_x v = \\varepsilon \\partial_{xx} v\n\\end{align*}\nThe solution, denoted $U_{naive} = (u_{naive}, v_{naive})^\\top$, consists of two independent scalar travelling wave solutions:\n$$\nu_{naive}(x,t) = u_L + \\frac{[u]}{2} \\left( 1 + \\text{erf}\\left(\\frac{x-at}{\\sqrt{4\\varepsilon t}}\\right) \\right)\n$$\n$$\nv_{naive}(x,t) = v_L + \\frac{[v]}{2} \\left( 1 + \\text{erf}\\left(\\frac{x-at}{\\sqrt{4\\varepsilon t}}\\right) \\right)\n$$\nNote that $v_{naive}(x,t) = v_{exact}(x,t)$, and $u_{naive}(x,t) = u_h(x,t)$ from the previous section.\n\n### 3. Quantification of Differences\n\nThe following quantities are calculated on a discrete spatial grid $x_j$ using trapezoidal quadrature for all integrals.\n\n**I. Relative $L^2$ error of the naive solver for $u$:**\nThis metric quantifies the error incurred by ignoring the Jordan chain coupling.\n$$\n\\text{Error} = \\frac{\\|u_{exact} - u_{naive}\\|_{L^2}}{\\|u_{exact}\\|_{L^2}} = \\frac{\\left( \\int_{-L}^L (u_{exact}(x,t) - u_{naive}(x,t))^2 dx \\right)^{1/2}}{\\left( \\int_{-L}^L (u_{exact}(x,t))^2 dx \\right)^{1/2}}\n$$\nThe difference $u_{exact} - u_{naive}$ is precisely the particular solution component $-t \\, \\partial_x v_{exact}$.\n\n**II. Excess mass in $u$:**\nIn the vanishing viscosity limit ($\\varepsilon \\to 0$), the solution to the hyperbolic system develops a Dirac delta-like component in $u$ with total mass $-t[v]$. The viscous term regularizes this into a Gaussian-like pulse. The \"excess mass\" measures the integrated strength of this pulse. It is defined as the integral of the difference between the true solution $u_{exact}$ and the simple travelling wave profile $u_{naive}$.\n$$\nM_{excess} = \\int_{-L}^L (u_{exact}(x,t) - u_{naive}(x,t)) dx\n$$\nThe theoretical prediction for an infinite domain is $\\int_{-\\infty}^\\infty (u_{exact} - u_{naive}) dx = -t[v]$. We report the absolute difference between the numerically computed $M_{excess}$ on $[-L, L]$ and this prediction: $|M_{excess} + t[v]|$.\n\n**III. Change in quadratic entropy of $v$:**\nFor a scalar convection-diffusion equation, the total \"entropy\" associated with a convex function of the solution is dissipated by viscosity. We measure this for the quadratic entropy $\\eta(v) = \\frac{1}{2} v^2$. The change in total entropy from $t=0$ to the final time is:\n$$\n\\Delta S_v = \\int_{-L}^L \\frac{1}{2} v_{exact}(x,t)^2 dx - \\int_{-L}^L \\frac{1}{2} v(x,0)^2 dx\n$$\nThe initial total entropy $\\int \\frac{1}{2} v(x,0)^2 dx$ is computed over the discretized initial step-function profile. Due to the dissipative term $-\\varepsilon \\int (\\partial_x v)^2 dx$ in the entropy balance equation, this quantity is guaranteed to be non-positive.\n\nThe implementation of the solution involves discretizing the spatial domain $[-L, L]$ according to the given $\\Delta x$ and evaluating the analytical formulas for $u_{exact}$, $v_{exact}$, and $u_{naive}$ at each grid point. The integrals for the three specified quantities are then computed using the trapezoidal rule.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf\n\ndef solve():\n    \"\"\"\n    Implements the solution for the given systems of PDEs problem.\n    It computes three specified metrics for two solvers across three test cases.\n    \"\"\"\n    \n    test_cases = [\n        # Test case 1 (general case)\n        {'a': 1.0, 'eps': 1e-2, 'UL': np.array([1.0, 0.0]), 'UR': np.array([0.0, 1.0]), 't': 0.5, 'L': 1.0, 'dx': 0.002},\n        # Test case 2 (boundary case with zero jump in v)\n        {'a': 1.0, 'eps': 1e-2, 'UL': np.array([1.0, 0.0]), 'UR': np.array([0.0, 0.0]), 't': 0.5, 'L': 1.0, 'dx': 0.002},\n        # Test case 3 (edge case with very small viscosity)\n        {'a': 1.0, 'eps': 1e-4, 'UL': np.array([0.0, 0.0]), 'UR': np.array([1.0, 1.0]), 't': 0.5, 'L': 1.0, 'dx': 0.001},\n    ]\n\n    all_results = []\n\n    for params in test_cases:\n        a = params['a']\n        eps = params['eps']\n        uL, vL = params['UL']\n        uR, vR = params['UR']\n        t = params['t']\n        L = params['L']\n        dx = params['dx']\n\n        # Setup computational grid\n        num_points = int(2 * L / dx) + 1\n        x = np.linspace(-L, L, num_points)\n\n        # Calculate jumps\n        du = uR - uL\n        dv = vR - vL\n\n        # Common terms for the analytical solutions\n        # Prevent division by zero at t=0, although problem specifies t  0\n        if t == 0: \n            # This case is not in the test suite but is a good practice\n            v_exact = np.where(x  0, vL, vR)\n            u_naive = np.where(x  0, uL, uR)\n            u_exact = u_naive\n            correction_term = np.zeros_like(x)\n        else:\n            sqrt_4_eps_t = np.sqrt(4 * eps * t)\n            arg_erf = (x - a * t) / sqrt_4_eps_t\n            \n            # --- Eigenstructure-aware and Naive Solver Solutions ---\n            \n            # v_exact solution (same for both solvers)\n            v_exact = vL + (dv / 2.0) * (1.0 + erf(arg_erf))\n            \n            # u_naive solution (scalar convection-diffusion)\n            u_naive = uL + (du / 2.0) * (1.0 + erf(arg_erf))\n\n            # Correction term for u_exact due to Jordan structure\n            gauss_term = np.exp(-arg_erf**2) / np.sqrt(np.pi)\n            correction_term = - (t * dv) / sqrt_4_eps_t * gauss_term\n            \n            # u_exact solution (eigenstructure-aware)\n            u_exact = u_naive + correction_term\n            \n        # --- Quantification of Differences ---\n\n        # 1. Relative L2 error of the naive u-component\n        # Numerator: ||u_exact - u_naive||^2 = ||correction_term||^2\n        # Denominator: ||u_exact||^2\n        norm_err_sq = np.trapz(correction_term**2, x)\n        norm_uexact_sq = np.trapz(u_exact**2, x)\n        \n        # Avoid division by zero if u_exact is zero everywhere\n        if norm_uexact_sq  1e-15:\n            rel_l2_error = 0.0\n        else:\n            rel_l2_error = np.sqrt(norm_err_sq / norm_uexact_sq)\n\n        # 2. Excess mass in u\n        # Integral of the difference u_exact - u_naive\n        excess_mass_numerical = np.trapz(correction_term, x)\n        # Theoretical prediction for infinite domain\n        excess_mass_theoretical = -t * dv\n        # Absolute difference between numerical and theoretical\n        excess_mass_diff = np.abs(excess_mass_numerical - excess_mass_theoretical)\n\n        # 3. Change in quadratic entropy of v\n        # Entropy at final time t\n        entropy_t = 0.5 * np.trapz(v_exact**2, x)\n        # Entropy at initial time t=0\n        v_initial = np.where(x  0, vL, vR)\n        entropy_0 = 0.5 * np.trapz(v_initial**2, x)\n        # Change in entropy\n        entropy_change = entropy_t - entropy_0\n        \n        case_results = [rel_l2_error, excess_mass_diff, entropy_change]\n        # Format results for this case into a string '[r1,r2,r3]'\n        all_results.append(f\"[{','.join(f'{r:.12f}' for r in case_results)}]\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "3452289"}, {"introduction": "For most nonlinear systems, finding the exact solution to the Riemann problem is computationally expensive or analytically intractable. This reality motivates the use of approximate Riemann solvers, which are the workhorses of modern computational fluid dynamics. In this final practice, you will derive and implement the celebrated Harten-Lax-van Leer (HLL) solver for the nonlinear shallow water equations, a classic model for rivers and coastal flows. By constructing the simplified wave model and justifying the necessary wave speed estimates [@problem_id:3452354], you will gain hands-on experience with a robust and practical tool used to simulate complex, nonlinear wave phenomena.", "problem": "Consider the one-dimensional shallow water equations without source terms, written in conservative form as $U_{t} + F(U)_{x} = 0$ with the conserved state $U = (h, hu)^{\\top}$ and flux $F(U) = \\left( hu, \\, hu^{2} + \\tfrac{1}{2} g h^{2} \\right)^{\\top}$, where $h$ is the water depth, $u$ is the depth-averaged velocity, and $g$ is the gravitational acceleration. A discontinuity in the data at an interface $x=0$ produces a Riemann problem with left state $U_{L}$ for $x0$ and right state $U_{R}$ for $x0$. The eigenvalues of the Jacobian $\\partial F / \\partial U$ for the shallow water equations are the characteristic speeds $u \\pm c$, where $c = \\sqrt{g h}$ is the gravity wave speed.\n\nYour tasks are:\n\n1. Starting from the integral form of conservation across a control volume in the x-t plane and the Rankine-Hugoniot jump condition for each bounding wave, derive the Harten-Lax-van Leer (HLL) approximate Riemann solver. Specifically, approximate the self-similar Riemann fan by two waves with constant speeds $S_{L}$ and $S_{R}$ that bound a single constant intermediate state $U^{\\ast}$ and an associated constant interfacial flux $F^{\\ast}$. Show that the intermediate state and flux satisfy\n$$\nS_{L} \\big( U^{\\ast} - U_{L} \\big) = F^{\\ast} - F(U_{L}), \\qquad\nS_{R} \\big( U_{R} - U^{\\ast} \\big) = F(U_{R}) - F^{\\ast},\n$$\nand use these relations, together with conservation, to obtain an explicit closed-form formula for $F^{\\ast}$ in terms of $U_{L}$, $U_{R}$, $F(U_{L})$, $F(U_{R})$, $S_{L}$, and $S_{R}$.\n\n2. Justify the following Davis-type wave speed estimates for the shallow water system based on bounding the characteristic speeds by their left and right state values:\n$$\nS_{L} = \\min \\big( u_{L} - c_{L}, \\, u_{R} - c_{R} \\big), \\qquad\nS_{R} = \\max \\big( u_{L} + c_{L}, \\, u_{R} + c_{R} \\big),\n$$\nwhere $c_{K} = \\sqrt{g h_{K}}$ for $K \\in \\{L, R\\}$. Your justification should appeal to the hyperbolic structure (characteristic speeds $u \\pm c$) and the requirement that all true waves of the exact Riemann solution be enclosed within the approximate wave fan.\n\n3. For the specific Riemann data\n$$\ng = 9.81, \\quad h_{L} = 2.0, \\quad u_{L} = 1.5, \\quad h_{R} = 1.0, \\quad u_{R} = 0.0,\n$$\ncompute the HLL numerical mass flux across $x=0$ (that is, the first component of $F^{\\ast}$) using the Davis wave speed estimates from part 2. Express your final answer in $\\mathrm{m}^{2} \\, \\mathrm{s}^{-1}$ and round to four significant figures.", "solution": "The problem is valid as it is scientifically grounded in the established theory of hyperbolic conservation laws and numerical methods, specifically the shallow water equations and the Harten-Lax-van Leer (HLL) approximate Riemann solver. It is well-posed, objective, and contains all necessary information to derive the required formulas and compute the numerical result.\n\n### Part 1: Derivation of the HLL Flux Formula\n\nThe HLL approximate Riemann solver simplifies the solution structure of a Riemann problem. For a system of conservation laws $U_{t} + F(U)_{x} = 0$, the exact solution to a Riemann problem with initial data $U(x,0) = U_L$ for $x0$ and $U(x,0) = U_R$ for $x0$ is self-similar, i.e., $U(x,t) = W(x/t)$. This solution, known as the Riemann fan, can be complex, involving shocks, rarefaction waves, and contact discontinuities.\n\nThe HLL approximation replaces this complex structure with a simplified, three-state model. The solution is assumed to be piecewise constant:\n$$\nU(x,t) =\n\\begin{cases}\nU_L  \\text{if } x/t  S_L \\\\\nU^*  \\text{if } S_L  x/t  S_R \\\\\nU_R  \\text{if } x/t  S_R\n\\end{cases}\n$$\nHere, $S_L$ and $S_R$ are the speeds of the leftmost and rightmost waves, respectively, which bound a single, constant intermediate state $U^*$.\n\nLet's consider the integral form of the conservation law over a control volume in the x-t plane. For any region $\\Omega$, Green's theorem implies $\\iint_{\\Omega} (U_t + F_x) \\,dx\\,dt = \\oint_{\\partial \\Omega} (U\\,dx - F\\,dt) = 0$.\n\nApplying the Rankine-Hugoniot jump condition, which is a direct consequence of this integral form across a line of discontinuity moving with speed $s$, we have $s[U] = [F]$, where $[ \\cdot ]$ denotes the jump across the discontinuity.\n\nThe HLL model has two discontinuities, one at $x=S_L t$ and another at $x=S_R t$. A key feature of the HLL (and HLLC) family of solvers is that they do not assume the flux in the intermediate region, $F^*$, is necessarily equal to $F(U^*)$. Instead, they enforce jump conditions that define $U^*$ and $F^*$.\n\nAcross the left wave with speed $S_L$, the jump is from $U_L$ to $U^*$. The corresponding jump condition is:\n$$ S_L (U^* - U_L) = F^* - F(U_L) \\quad (1) $$\nAcross the right wave with speed $S_R$, the jump is from $U^*$ to $U_R$. The corresponding jump condition is:\n$$ S_R (U_R - U^*) = F(U_R) - F^* \\quad (2) $$\nThese are the two relations the problem asks to be shown. They are the foundational relations of the HLL model, analogous to the Rankine-Hugoniot conditions, defining the intermediate state $U^*$ and its associated constant flux $F^*$. The consistency of these relations is ensured by satisfying the integral conservation law over the entire fan. Integrating the conservation law over the region $[S_L T, S_R T]$ from $t=0$ to $t=T$ and taking the average yields an expression for $U^*$ that is consistent with the one obtained by combining equations $(1)$ and $(2)$.\n\nOur goal is to find an explicit formula for the intermediate flux $F^*$. We have a system of two linear vector equations for the two unknown vectors $U^*$ and $F^*$. We can solve this system to eliminate $U^*$.\n\nFrom equation $(1)$, we can write $S_L U^* = S_L U_L + F^* - F(U_L)$.\nFrom equation $(2)$, we can write $S_R U^* = S_R U_R - F(U_R) + F^*$.\n\nTo eliminate $U^*$, we multiply the first expression by $S_R$ and the second by $S_L$:\n$$ S_R S_L U^* = S_R(S_L U_L + F^* - F(U_L)) $$\n$$ S_L S_R U^* = S_L(S_R U_R - F(U_R) + F^*) $$\nEquating the right-hand sides:\n$$ S_R S_L U_L + S_R F^* - S_R F(U_L) = S_L S_R U_R - S_L F(U_R) + S_L F^* $$\nNow, we collect terms involving $F^*$ on one side:\n$$ S_R F^* - S_L F^* = S_L S_R U_R - S_R S_L U_L + S_R F(U_L) - S_L F(U_R) $$\n$$ F^*(S_R - S_L) = S_R F(U_L) - S_L F(U_R) + S_L S_R (U_R - U_L) $$\nAssuming $S_R \\neq S_L$, we can solve for $F^*$:\n$$ F^* = \\frac{S_R F(U_L) - S_L F(U_R) + S_L S_R (U_R - U_L)}{S_R - S_L} $$\nThis is the celebrated HLL flux formula, which provides the numerical flux at the interface. The flux $F^*$ corresponds to the constant flux $F_{i+1/2}$ used in finite-volume schemes for the cell interface located at the site of the Riemann problem.\n\n### Part 2: Justification of Davis-Type Wave Speed Estimates\n\nThe HLL solver's accuracy and robustness depend critically on the choice of the wave speeds $S_L$ and $S_R$. For the scheme to be physically meaningful, the region between $S_L$ and $S_R$ must encompass the entire true Riemann fan. This means that $S_L$ must be less than or equal to the speed of the slowest wave in the exact solution, and $S_R$ must be greater than or equal to the speed of the fastest wave.\nLet $\\lambda_{\\min}$ and $\\lambda_{\\max}$ be the minimum and maximum characteristic speeds over all states present in the exact solution fan. Then we require:\n$$ S_L \\le \\lambda_{\\min} \\quad \\text{and} \\quad S_R \\ge \\lambda_{\\max} $$\nThe characteristic speeds for the shallow water equations are $\\lambda_{1,2} = u \\pm c$, where $c = \\sqrt{gh}$. The slowest possible wave speed is associated with $\\lambda_1 = u - c$, and the fastest with $\\lambda_2 = u + c$.\n\nThe exact states within the Riemann fan are unknown without solving the full nonlinear problem. Therefore, $S_L$ and $S_R$ must be estimated using only the known initial data, $U_L$ and $U_R$. Various estimation strategies exist. The Davis wave speed estimates (1988) provide a simple and robust choice by taking the extremal characteristic speeds evaluated at the left and right states.\n\nThe minimum characteristic speed in the exact solution is bounded below by the minimum of the characteristic speeds evaluated at all possible states in the solution. A simple, practical estimate is to assume this minimum is bounded by the minimum of the slowest characteristic speeds evaluated only at the initial left and right states.\nThus, the estimate for the leftmost wave speed $S_L$ is:\n$$ S_L = \\min ( \\lambda_{1}(U_L), \\lambda_{1}(U_R) ) = \\min ( u_L - c_L, u_R - c_R ) $$\nwhere $c_L = \\sqrt{g h_L}$ and $c_R = \\sqrt{g h_R}$.\n\nSimilarly, the estimate for the rightmost wave speed $S_R$ is taken as the maximum of the fastest characteristic speeds evaluated at the initial left and right states:\n$$ S_R = \\max ( \\lambda_{2}(U_L), \\lambda_{2}(U_R) ) = \\max ( u_L + c_L, u_R + c_R ) $$\n\nThis choice ensures that the waves emanating from the boundaries of the Riemann fan are enclosed within the HLL fan. While this estimate can be overly diffusive if the true wave speeds are much less extreme, it guarantees stability and prevents waves from \"leaking\" out of the computational stencil for the update, which is a crucial property for a numerical scheme.\n\n### Part 3: Numerical Calculation of HLL Mass Flux\n\nWe are given the following data:\n$g = 9.81 \\, \\mathrm{m}/\\mathrm{s}^2$\nLeft state: $h_L = 2.0 \\, \\mathrm{m}$, $u_L = 1.5 \\, \\mathrm{m}/\\mathrm{s}$\nRight state: $h_R = 1.0 \\, \\mathrm{m}$, $u_R = 0.0 \\, \\mathrm{m}/\\mathrm{s}$\n\nFirst, we compute the state vectors $U$, flux vectors $F$, and wave speeds $c$ for the left and right states.\n\n**Left State ($L$):**\n- Water depth: $h_L = 2.0$\n- Velocity: $u_L = 1.5$\n- Wave speed: $c_L = \\sqrt{g h_L} = \\sqrt{9.81 \\times 2.0} = \\sqrt{19.62} \\, \\mathrm{m}/\\mathrm{s}$\n- State vector: $U_L = \\begin{pmatrix} h_L \\\\ h_L u_L \\end{pmatrix} = \\begin{pmatrix} 2.0 \\\\ 2.0 \\times 1.5 \\end{pmatrix} = \\begin{pmatrix} 2.0 \\\\ 3.0 \\end{pmatrix}$\n- Flux vector: $F(U_L) = \\begin{pmatrix} h_L u_L \\\\ h_L u_L^2 + \\tfrac{1}{2} g h_L^2 \\end{pmatrix} = \\begin{pmatrix} 3.0 \\\\ 2.0 \\times (1.5)^2 + \\tfrac{1}{2}(9.81)(2.0)^2 \\end{pmatrix} = \\begin{pmatrix} 3.0 \\\\ 4.5 + 19.62 \\end{pmatrix} = \\begin{pmatrix} 3.0 \\\\ 24.12 \\end{pmatrix}$\n\n**Right State ($R$):**\n- Water depth: $h_R = 1.0$\n- Velocity: $u_R = 0.0$\n- Wave speed: $c_R = \\sqrt{g h_R} = \\sqrt{9.81 \\times 1.0} = \\sqrt{9.81} \\, \\mathrm{m}/\\mathrm{s}$\n- State vector: $U_R = \\begin{pmatrix} h_R \\\\ h_R u_R \\end{pmatrix} = \\begin{pmatrix} 1.0 \\\\ 1.0 \\times 0.0 \\end{pmatrix} = \\begin{pmatrix} 1.0 \\\\ 0.0 \\end{pmatrix}$\n- Flux vector: $F(U_R) = \\begin{pmatrix} h_R u_R \\\\ h_R u_R^2 + \\tfrac{1}{2} g h_R^2 \\end{pmatrix} = \\begin{pmatrix} 0.0 \\\\ 1.0 \\times (0.0)^2 + \\tfrac{1}{2}(9.81)(1.0)^2 \\end{pmatrix} = \\begin{pmatrix} 0.0 \\\\ 4.905 \\end{pmatrix}$\n\nNext, we compute the Davis wave speed estimates $S_L$ and $S_R$.\n- $u_L - c_L = 1.5 - \\sqrt{19.62} \\approx 1.5 - 4.4294469 = -2.9294469 \\, \\mathrm{m}/\\mathrm{s}$\n- $u_R - c_R = 0.0 - \\sqrt{9.81} \\approx -3.13209195 \\, \\mathrm{m}/\\mathrm{s}$\n- $S_L = \\min(-2.9294469, -3.13209195) = -3.13209195 \\, \\mathrm{m}/\\mathrm{s}$\n- $u_L + c_L = 1.5 + \\sqrt{19.62} \\approx 1.5 + 4.4294469 = 5.9294469 \\, \\mathrm{m}/\\mathrm{s}$\n- $u_R + c_R = 0.0 + \\sqrt{9.81} \\approx 3.13209195 \\, \\mathrm{m}/\\mathrm{s}$\n- $S_R = \\max(5.9294469, 3.13209195) = 5.9294469 \\, \\mathrm{m}/\\mathrm{s}$\n\nWe need to compute the HLL numerical mass flux, which is the first component of the flux vector $F^*$, denoted as $F^*_1$. The vector components are $U = (U_1, U_2)^{\\top}$ and $F = (F_1, F_2)^{\\top}$.\nThe formula for the first component is:\n$$ F^*_1 = \\frac{S_R F_1(U_L) - S_L F_1(U_R) + S_L S_R (U_1(U_R) - U_1(U_L))}{S_R - S_L} $$\nWe have the values:\n- $F_1(U_L) = h_L u_L = 3.0$\n- $F_1(U_R) = h_R u_R = 0.0$\n- $U_1(U_L) = h_L = 2.0$\n- $U_1(U_R) = h_R = 1.0$\n- $S_L \\approx -3.13209195$\n- $S_R \\approx 5.9294469$\n\nLet's compute the terms in the formula for $F^*_1$:\n- $S_R - S_L \\approx 5.9294469 - (-3.13209195) = 9.06153885$\n- Numerator:\n  - $S_R F_1(U_L) \\approx 5.9294469 \\times 3.0 = 17.7883407$\n  - $-S_L F_1(U_R) \\approx -(-3.13209195) \\times 0.0 = 0$\n  - $S_L S_R (U_1(U_R) - U_1(U_L)) \\approx (-3.13209195)(5.9294469)(1.0 - 2.0)$\n    $ \\approx (-18.572186) \\times (-1.0) = 18.572186$\n- Numerator $\\approx 17.7883407 + 0 + 18.572186 = 36.3605267$\n\nFinally, we compute $F^*_1$:\n$$ F^*_1 \\approx \\frac{36.3605267}{9.06153885} \\approx 4.012646 $$\nThe units are those of $hu$, which are $\\mathrm{m} \\times \\mathrm{m}/\\mathrm{s} = \\mathrm{m}^2/\\mathrm{s}$. The problem asks for the answer rounded to four significant figures.\n\n$F^*_1 \\approx 4.013 \\, \\mathrm{m}^2/\\mathrm{s}$.", "answer": "$$\n\\boxed{4.013}\n$$", "id": "3452354"}]}