{"hands_on_practices": [{"introduction": "The convection-diffusion equation models a wide range of physical phenomena where a quantity is transported by a flow. When the convective effect strongly dominates the diffusive one, naively applying standard numerical methods can lead to unphysical results. This practice [@problem_id:3419376] provides a hands-on demonstration of this failure, showing how a centered finite difference scheme produces spurious oscillations that violate the maximum principle at high Péclet numbers, and how the simple fix of upwinding restores stability by enforcing a discrete maximum principle.", "problem": "Consider the one-dimensional steady convection–diffusion boundary value problem on the unit interval, with constant coefficients and Dirichlet boundary conditions:\nFind a function $u(x)$ on $(0,1)$ such that\n$$ - \\epsilon \\, u''(x) + a \\, u'(x) = 0 \\quad \\text{for } x \\in (0,1), $$\nwith boundary conditions $u(0) = 0$ and $u(1) = 1$, where $\\epsilon  0$ is the diffusion coefficient and $a \\in \\mathbb{R}$ is the uniform convection speed. For this continuous, uniformly elliptic operator, the continuous maximum principle holds: the maximum and minimum of $u$ occur on the boundary, hence $u(x) \\in [0,1]$ for all $x \\in [0,1]$.\n\nYour task is to demonstrate, via numerical discretization and computation, that centered differences for the convection term can violate a discrete maximum principle at high Péclet number, and that upwinding restores it.\n\nStarting from fundamental numerical definitions, proceed as follows:\n- Use a uniform grid with $n$ interior points. Let the mesh size be $h = 1/(n+1)$, with grid nodes $x_i = i h$ for $i=0,1,\\dots,n+1$. Unknowns are $u_i \\approx u(x_i)$ for $i=1,\\dots,n$, while $u_0 = 0$ and $u_{n+1} = 1$ are fixed by the boundary values.\n- Implement two discrete operators for the interior equations:\n  1. A centered scheme that uses the standard second-order central difference for $u''$ and the centered first-order difference for $u'$.\n  2. An upwind scheme that uses central difference for $u''$ and a first-order upwind difference for $u'$, switching direction according to the sign of $a$.\n- Assemble the corresponding linear systems for the interior unknowns $u_1,\\dots,u_n$ with the given Dirichlet data, solve them, and reconstruct the full grid solution including the boundaries.\n- Define a discrete maximum principle check for this homogeneous-source problem (right-hand side equal to $0$): the discrete solution must satisfy $u_i \\in [0,1]$ for all grid nodes $i=0,1,\\dots,n+1$. Declare a violation if $\\min_i u_i  0$ or $\\max_i u_i  1$. Use a numerical tolerance $\\tau = 10^{-12}$, i.e., treat the conditions as violated if $\\min_i u_i  0 - \\tau$ or $\\max_i u_i  1 + \\tau$.\n- For each test case in the suite below, compute two booleans:\n  - $b_{\\mathrm{cent}}$: whether the centered scheme violates the discrete maximum principle as defined above.\n  - $b_{\\mathrm{up}}$: whether the upwind scheme violates the discrete maximum principle as defined above.\n\nTest suite:\n- Case $1$: $\\epsilon = 10^{-3}$, $a = 2$, $n = 49$.\n- Case $2$: $\\epsilon = 10^{-1}$, $a = 1$, $n = 49$.\n- Case $3$: $\\epsilon = 10^{-2}$, $a = 1$, $n = 49$.\n- Case $4$: $\\epsilon = 10^{-3}$, $a = -2$, $n = 49$.\n- Case $5$: $\\epsilon = 5 \\cdot 10^{-3}$, $a = 20$, $n = 19$.\n\nNotes:\n- The local cell Péclet number is $Pe = \\frac{|a| \\, h}{2 \\epsilon}$. High values of $Pe$ are expected to trigger violations for the centered scheme.\n- There are no physical units to report; all quantities are nondimensional.\n\nFinal output format:\n- Your program must produce a single line of output containing a comma-separated list of pairs, one pair per test case, with no spaces. Each pair must be of the form $[b_{\\mathrm{cent}},b_{\\mathrm{up}}]$, where each boolean is printed as the literal $True$ or $False$.\n- For example, a line with two cases would look like $[[True,False],[False,False]]$.", "solution": "The user-provided problem is assessed to be valid. It is a well-defined task from the field of numerical analysis for partial differential equations, grounded in established mathematical principles and free of any contradictions, ambiguities, or invalid premises. The objective is to numerically demonstrate a known property of finite difference schemes for the convection-diffusion equation.\n\nThe problem requires solving the one-dimensional steady convection-diffusion equation on the domain $x \\in (0,1)$:\n$$-\\epsilon u''(x) + a u'(x) = 0$$\nwith Dirichlet boundary conditions $u(0)=0$ and $u(1)=1$. Here, $\\epsilon  0$ is the diffusion coefficient and $a \\in \\mathbb{R}$ is the constant convection speed. The continuous solution to this problem is known to satisfy a maximum principle, meaning its values are bounded by the minimum and maximum of the boundary data, i.e., $u(x) \\in [0,1]$. We will investigate whether this property holds for discrete approximations.\n\nWe discretize the domain $(0,1)$ using a uniform grid with $n$ interior points. The grid nodes are $x_i = ih$ for $i=0, 1, \\dots, n+1$, where the mesh size is $h = 1/(n+1)$. The values $u_0=0$ and $u_{n+1}=1$ are given. We seek the approximate solution $u_i \\approx u(x_i)$ for the interior nodes $i=1, \\dots, n$.\n\nAt any interior node $x_i$, we approximate the derivatives using finite differences. The second derivative is approximated by the standard second-order central difference:\n$$u''(x_i) \\approx \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}$$\nSubstituting this into the governing equation gives the discretized form:\n$$-\\epsilon \\left(\\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}\\right) + a \\cdot (\\text{approx } u'(x_i)) = 0$$\n\nWe will now analyze two different schemes for the first derivative term.\n\n**1. Centered Difference Scheme**\n\nThe centered difference approximation for the first derivative is second-order accurate:\n$$u'(x_i) \\approx \\frac{u_{i+1} - u_{i-1}}{2h}$$\nSubstituting this into the discretized equation and multiplying by $h^2$ yields:\n$$-\\epsilon(u_{i+1} - 2u_i + u_{i-1}) + a \\frac{h}{2}(u_{i+1} - u_{i-1}) = 0$$\nWe rearrange the terms to group the unknowns $u_{i-1}$, $u_i$, and $u_{i+1}$:\n$$\\left(-\\epsilon - \\frac{ah}{2}\\right)u_{i-1} + (2\\epsilon)u_i + \\left(-\\epsilon + \\frac{ah}{2}\\right)u_{i+1} = 0$$\nThis equation holds for each interior node $i=1, \\dots, n$. This forms a system of $n$ linear equations for the $n$ unknowns $\\boldsymbol{u} = [u_1, u_2, \\dots, u_n]^T$. The system can be written as $A\\boldsymbol{u} = \\boldsymbol{b}$. The matrix $A$ is an $n \\times n$ tridiagonal matrix with the following entries on row $i$:\n\\begin{itemize}\n    \\item Sub-diagonal ($j = i-1$): $A_{i, i-1} = -\\epsilon - \\frac{ah}{2}$\n    \\item Diagonal ($j = i$): $A_{i, i} = 2\\epsilon$\n    \\item Super-diagonal ($j = i+1$): $A_{i, i+1} = -\\epsilon + \\frac{ah}{2}$\n\\end{itemize}\nThe right-hand side vector $\\boldsymbol{b}$ is formed by moving terms involving the known boundary values to the right.\nFor $i=1$: The term with $u_0=0$ vanishes.\nFor $i=n$: The term involving $u_{n+1}=1$ is moved to the right:\n$$A_{n, n-1} u_{n-1} + A_{n,n} u_n = -A_{n,n+1} u_{n+1} = -\\left(-\\epsilon + \\frac{ah}{2}\\right) \\cdot 1 = \\epsilon - \\frac{ah}{2}$$\nSo, $\\boldsymbol{b} = [0, 0, \\dots, 0, \\epsilon - ah/2]^T$.\n\nA discrete maximum principle is guaranteed if the matrix $A$ is an M-matrix. A sufficient condition for this is that $A$ is diagonally dominant with positive diagonal entries and non-positive off-diagonal entries. The diagonal entries $2\\epsilon$ are positive. The off-diagonal entries must be non-positive:\n$$-\\epsilon - \\frac{ah}{2} \\le 0 \\quad \\text{and} \\quad -\\epsilon + \\frac{ah}{2} \\le 0$$\nThis simplifies to $|ah| \\le 2\\epsilon$, or $\\frac{|a|h}{2\\epsilon} \\le 1$. The quantity $Pe = \\frac{|a|h}{2\\epsilon}$ is the cell Péclet number. If $Pe  1$, one of the off-diagonal entries becomes positive, the matrix is no longer guaranteed to be an M-matrix, and spurious oscillations violating the maximum principle can occur.\n\n**2. Upwind Difference Scheme**\n\nThe upwind scheme uses a first-order one-sided difference for the convection term, with the direction chosen based on the sign of the convection speed $a$.\n\nCase 1: $a \\ge 0$ (flow to the right)\nWe use a backward difference: $u'(x_i) \\approx \\frac{u_i - u_{i-1}}{h}$.\nThe discretized equation is:\n$$-\\epsilon \\left(\\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}\\right) + a \\left(\\frac{u_i - u_{i-1}}{h}\\right) = 0$$\nMultiplying by $h^2$ and rearranging:\n$$(-\\epsilon - ah)u_{i-1} + (2\\epsilon + ah)u_i - \\epsilon u_{i+1} = 0$$\nThe matrix entries are: $A_{i, i-1} = -\\epsilon - ah$, $A_{i, i} = 2\\epsilon + ah$, $A_{i, i+1} = -\\epsilon$.\nThe right-hand side for the last equation ($i=n$) becomes $b_n = -A_{n,n+1} u_{n+1} = -(-\\epsilon) \\cdot 1 = \\epsilon$.\n\nCase 2: $a  0$ (flow to the left)\nWe use a forward difference: $u'(x_i) \\approx \\frac{u_{i+1} - u_i}{h}$.\nThe discretized equation is:\n$$-\\epsilon \\left(\\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}\\right) + a \\left(\\frac{u_{i+1} - u_i}{h}\\right) = 0$$\nMultiplying by $h^2$ and rearranging:\n$$-\\epsilon u_{i-1} + (2epsilon - ah)u_i + (-\\epsilon + ah)u_{i+1} = 0$$\nThe matrix entries are: $A_{i, i-1} = -\\epsilon$, $A_{i, i} = 2\\epsilon - ah$, $A_{i, i+1} = -\\epsilon + ah$.\nThe right-hand side for the last equation ($i=n$) becomes $b_n = -A_{n,n+1} u_{n+1} = -(-\\epsilon + ah) \\cdot 1 = \\epsilon - ah$.\n\nIn both upwind cases, for any $\\epsilon  0$ and $h  0$, the diagonal entries are positive and the off-diagonal entries are non-positive. The matrix is diagonally dominant. Thus, it is an M-matrix, and the discrete maximum principle is always satisfied, regardless of the Péclet number.\n\n**Numerical Verification**\nThe procedure for each test case is as follows:\n1. For a given set of parameters $(\\epsilon, a, n)$, calculate the mesh size $h$.\n2. For both the centered and upwind schemes, assemble the $n \\times n$ tridiagonal matrix $A$ and the $n \\times 1$ right-hand side vector $\\boldsymbol{b}$.\n3. Solve the linear system $A\\boldsymbol{u} = \\boldsymbol{b}$ for the interior solution vector $\\boldsymbol{u}$.\n4. Construct the full solution by prepending $u_0=0$ and appending $u_{n+1}=1$.\n5. Check if the full solution violates the maximum principle: $\\min(u)  0 - \\tau$ or $\\max(u)  1 + \\tau$ for a tolerance $\\tau=10^{-12}$.\n6. Record the boolean results for violation, $b_{\\mathrm{cent}}$ and $b_{\\mathrm{up}}$.\n\nThis process is repeated for each test case provided in the problem statement, demonstrating the failure of the centered scheme at high Péclet numbers and the robustness of the upwind scheme.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef compute_solution_and_check_violation(epsilon, a, n, scheme, tau):\n    \"\"\"\n    Solves the 1D convection-diffusion equation and checks for max principle violation.\n\n    Args:\n        epsilon (float): Diffusion coefficient.\n        a (float): Convection speed.\n        n (int): Number of interior grid points.\n        scheme (str): 'centered' or 'upwind'.\n        tau (float): Numerical tolerance for violation check.\n\n    Returns:\n        bool: True if the maximum principle is violated, False otherwise.\n    \"\"\"\n    # Grid setup\n    h = 1.0 / (n + 1)\n    \n    # Boundary values\n    u0 = 0.0\n    u_np1 = 1.0\n    \n    # Initialize linear system\n    A = np.zeros((n, n))\n    b = np.zeros(n)\n    \n    # Assemble matrix A and vector b based on the scheme\n    if scheme == 'centered':\n        c_sub = -epsilon - a * h / 2.0\n        c_diag = 2.0 * epsilon\n        c_super = -epsilon + a * h / 2.0\n        \n        # Populate diagonals\n        if n > 0:\n            np.fill_diagonal(A, c_diag)\n        if n > 1:\n            np.fill_diagonal(A[1:], c_sub)\n            np.fill_diagonal(A[:, 1:], c_super)\n        \n        # Boundary conditions in RHS\n        # b[0] -= c_sub * u0 is a no-op since u0=0\n        if n > 0:\n            b[n-1] -= c_super * u_np1\n\n    elif scheme == 'upwind':\n        if a >= 0: # Upstream is i-1\n            c_sub = -epsilon - a * h\n            c_diag = 2.0 * epsilon + a * h\n            c_super = -epsilon\n        else: # a  0, upstream is i+1\n            c_sub = -epsilon\n            c_diag = 2.0 * epsilon - a * h\n            c_super = -epsilon + a * h\n            \n        # Populate diagonals\n        if n > 0:\n            np.fill_diagonal(A, c_diag)\n        if n > 1:\n            np.fill_diagonal(A[1:], c_sub)\n            np.fill_diagonal(A[:, 1:], c_super)\n            \n        # Boundary conditions in RHS\n        # b[0] -= c_sub * u0 is a no-op since u0=0\n        if n > 0:\n            b[n-1] -= c_super * u_np1\n    else:\n        raise ValueError(f\"Unknown scheme: {scheme}\")\n        \n    # Solve for interior points\n    if n > 0:\n        u_interior = np.linalg.solve(A, b)\n    else:\n        u_interior = np.array([])\n    \n    # Reconstruct full solution including boundaries\n    u_full = np.concatenate(([u0], u_interior, [u_np1]))\n    \n    # Check for maximum principle violation\n    min_u = np.min(u_full)\n    max_u = np.max(u_full)\n    \n    violation = (min_u  (0.0 - tau)) or (max_u > (1.0 + tau))\n    \n    return violation\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1e-3, 2, 49),          # Case 1\n        (1e-1, 1, 49),          # Case 2\n        (10e-3, 1, 49),         # Case 3 (epsilon=10e-3 is 1e-2)\n        (1e-3, -2, 49),         # Case 4\n        (5e-3, 20, 19),         # Case 5\n    ]\n    \n    # Numerical tolerance for checking the violation\n    tau = 1e-12\n\n    results_list = []\n    for case in test_cases:\n        eps, a, n = case\n        \n        # Check violation for centered scheme\n        b_cent = compute_solution_and_check_violation(eps, a, n, 'centered', tau)\n        \n        # Check violation for upwind scheme\n        b_up = compute_solution_and_check_violation(eps, a, n, 'upwind', tau)\n        \n        # Format as string '[Bool,Bool]'\n        results_list.append(f\"[{b_cent},{b_up}]\")\n\n    # Final print statement in the exact required format.\n    # e.g., [[True,False],[False,False]]\n    print(f\"[{','.join(results_list)}]\")\n\nsolve()\n```", "id": "3419376"}, {"introduction": "Unlike finite difference methods on structured grids, the stability of the Finite Element Method (FEM) is intricately linked to the geometry of the mesh. For certain problems, the Discrete Maximum Principle (DMP) is only guaranteed if the mesh triangles satisfy specific angle conditions. This exercise [@problem_id:3419375] explores this classic result by having you construct a triangulation with an obtuse angle, demonstrating how it can break the M-matrix property of the stiffness matrix and lead to a numerical solution that overshoots the bounds set by the boundary data.", "problem": "Consider the scalar diffusion model problem for an elliptic partial differential equation on the square domain $\\Omega = [0,1]\\times [0,1]$ with Dirichlet boundary conditions. The continuous model is: find $u:\\Omega\\to\\mathbb{R}$ such that\n$$\n-\\Delta u = f \\quad \\text{in } \\Omega, \\qquad u = g \\quad \\text{on } \\partial\\Omega,\n$$\nwith the constant source $f(x,y) = -1$ and the boundary data $g(x,y) = x$. The strong maximum principle states that if $-\\Delta u \\le 0$ (equivalently, $f \\le 0$), then the maximum of the solution is attained at the boundary. Therefore, the continuous solution satisfies $\\max_{\\Omega} u \\le \\max_{\\partial \\Omega} g = 1$.\n\nWe discretize this model using a conforming piecewise linear Finite Element Method (FEM) on a triangulation of $\\Omega$. The assembly uses the standard bilinear form with local element gradients that are constant per triangle. For a triangle with vertices $(x_i,y_i)$ for $i\\in\\{1,2,3\\}$, denote the area by $A$ and the gradients of the local shape functions by $\\nabla N_i = \\frac{1}{2A}(b_i,c_i)$, where $b_i$ and $c_i$ are computed from the vertex coordinates in the usual way. The local stiffness coefficients satisfy\n$$\nK_e(i,j) = \\int_{T} \\nabla N_i \\cdot \\nabla N_j\\,dx = \\frac{b_i b_j + c_i c_j}{4A},\n$$\nand for constant source $f=-1$ the local load vector entries are\n$$\nF_e(i) = \\int_{T} N_i f\\,dx = -\\frac{A}{3}.\n$$\nGlobal assembly followed by strong imposition of Dirichlet boundary conditions yields a sparse linear system $K u_h = F$ for the nodal values $u_h$.\n\nThe Discrete Maximum Principle (DMP) for FEM states that if the global stiffness matrix is an $M$-matrix (which is guaranteed on non-obtuse triangulations for isotropic diffusion), then for $f\\le 0$ one has $\\max_{\\Omega_h} u_h \\le \\max_{\\partial\\Omega_h} g$. However, on triangulations containing obtuse triangles the off-diagonal entries of the stiffness matrix can become positive, violating the $M$-matrix structure and potentially breaking the DMP, enabling overshoot beyond the boundary maximum.\n\nYour task is to:\n- Construct specific triangulations of $\\Omega$ that illustrate both satisfaction and violation of the FEM DMP.\n- Solve the discrete FEM problem for each triangulation.\n- Quantify the overshoot, defined as\n$$\n\\text{overshoot} := \\max\\left\\{0,\\ \\max_i u_h(i) - \\max_{j\\in\\partial\\Omega} g_j\\right\\},\n$$\nwhere the maximum over boundary nodal values is $\\max_{j\\in\\partial\\Omega} g_j = 1$ because $g(x,y)=x$ on $\\partial\\Omega$.\n\nFundamental base assumptions to use:\n- The strong maximum principle for elliptic operators with $f\\le 0$ implies an upper bound by boundary maximum in the continuous case.\n- The stiffness assembly for piecewise linear (affine) FEM uses constant gradients on triangles with the local formulae above.\n- The discrete maximum principle for FEM holds when the assembled stiffness matrix is an $M$-matrix, which is ensured on non-obtuse meshes for isotropic diffusion.\n\nTriangulation design:\n- Use a simple $5$-node mesh consisting of the four corners of the unit square and a single interior node. Connect the interior node to all four corners to form $4$ triangles.\n- For non-obtuse triangulations, place the interior node at the center $(0.5,0.5)$, which yields right angles at the interior node.\n- For obtuse triangulations, move the interior node along an axis towards the boundary to introduce obtuse angles. Determining whether the stiffness matrix loses the $M$-matrix property can be done by checking for positive off-diagonal entries in the globally assembled matrix.\n\nTest suite:\n- Case $\\mathbf{A}$ (happy path, DMP satisfied): interior node at $(0.5,0.5)$.\n- Case $\\mathbf{B}$ (obtuse via vertical shift): interior node searched along the vertical line $x=0.5$ to find a location $(0.5,y)$ such that the assembled global stiffness matrix has at least one positive off-diagonal, indicating DMP violation.\n- Case $\\mathbf{C}$ (obtuse via horizontal shift): interior node searched along the horizontal line $y=0.5$ to find a location $(x,0.5)$ with the same positivity condition on an off-diagonal.\n\nAlgorithmic requirements:\n- Assemble the global stiffness matrix $K$ and load vector $F$ using the local triangle formulas with $f=-1$.\n- Impose Dirichlet boundary conditions strongly by resetting rows and columns appropriately and setting diagonal entries to $1$ for boundary nodes, with the right-hand side set to the boundary data $g$ at those nodes.\n- Solve $K u_h = F$.\n- Compute the overshoot as defined above for each case.\n\nAngle unit: If any angles are used conceptually for checking obtuseness, all angles should be treated in degrees; however, the program will check the $M$-matrix condition numerically via the sign of off-diagonals and will not require explicit angle computations.\n\nFinal output format:\n- Your program should produce a single line of output containing the overshoot results for Cases $\\mathbf{A}$, $\\mathbf{B}$, and $\\mathbf{C}$ as a comma-separated list enclosed in square brackets (e.g., $[r_A,r_B,r_C]$), where each $r_\\cdot$ is a floating-point number.\n\nNo external input is required. All computations are dimensionless; no physical units are involved. Ensure numerical stability by using double precision arithmetic.", "solution": "The user wants to validate and solve a problem concerning the Discrete Maximum Principle (DMP) for a Finite Element Method (FEM) discretization of the Poisson equation.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n-   **PDE Model**: Find $u:\\Omega\\to\\mathbb{R}$ such that $-\\Delta u = f$ in $\\Omega = [0,1]\\times [0,1]$.\n-   **Source Term**: $f(x,y) = -1$.\n-   **Boundary Conditions**: $u = g$ on $\\partial\\Omega$, where $g(x,y) = x$.\n-   **Continuous Maximum Principle Consequence**: $\\max_{\\Omega} u \\le \\max_{\\partial \\Omega} g = 1$.\n-   **Discretization**: Conforming piecewise linear Finite Element Method (P1 FEM).\n-   **Local Stiffness Formula**: For a triangle $T$ with area $A$ and vertices $i,j,k$, the stiffness coefficients are $K_e(i,j) = \\int_{T} \\nabla N_i \\cdot \\nabla N_j\\,dx = \\frac{b_i b_j + c_i c_j}{4A}$, where the shape function gradients are $\\nabla N_i = \\frac{1}{2A}(b_i,c_i)$.\n-   **Local Load Vector Formula**: For $f=-1$, the load vector entries are $F_e(i) = \\int_{T} N_i f\\,dx = -\\frac{A}{3}$.\n-   **Boundary Condition Implementation**: Strong imposition.\n-   **Discrete Maximum Principle Condition**: The global stiffness matrix $K$ must be an M-matrix, which for isotropic diffusion is guaranteed on non-obtuse triangulations.\n-   **Overshoot Definition**: $\\text{overshoot} := \\max\\left\\{0,\\ \\max_i u_h(i) - \\max_{j\\in\\partial\\Omega} g_j\\right\\}$. The boundary maximum is $\\max g = 1$.\n-   **Mesh Geometry**: A $5$-node mesh comprising the four corners of the unit square $(0,0), (1,0), (1,1), (0,1)$ and one interior node, forming $4$ triangles.\n-   **Test Cases**:\n    -   Case A (non-obtuse): Interior node at $(0.5,0.5)$.\n    -   Case B (obtuse): Interior node at $(0.5,y)$ chosen to make $K$ not an M-matrix.\n    -   Case C (obtuse): Interior node at $(x,0.5)$ chosen to make $K$ not an M-matrix.\n\n**Step 2: Validate Using Extracted Givens**\n\n-   **Scientifically Grounded**: The problem is based on standard, well-established principles of the numerical analysis of partial differential equations, specifically the Finite Element Method for elliptic problems. The connection between the Discrete Maximum Principle, M-matrices, and mesh geometry (non-obtuse vs. obtuse angles) is a classic topic. The provided formulas are correct for P1 FEM. The problem is scientifically sound.\n-   **Well-Posed**: The continuous problem is a well-posed Poisson equation with Dirichlet boundary data. The discrete problem involves solving a linear system $K u_h = F$. For this specific mesh with one interior degree of freedom, the system reduces to a single scalar equation for the interior nodal value. Since the stiffness matrix $K$ is symmetric positive definite for the operator $-\\Delta$, the diagonal entry for the interior node will be strictly positive, guaranteeing a unique solution. The problem is well-posed.\n-   **Objective**: The language is formal, precise, and mathematical. There are no subjective or ambiguous statements.\n-   **Completeness and Consistency**: All necessary data, equations, and definitions are provided. The problem asks to \"search\" for node locations in Cases B and C, which can be satisfied by providing a single valid instance derived from analysis, demonstrating the principle. The setup is complete and consistent.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. A reasoned solution will be provided.\n\n### Solution\n\nThe problem requires solving a Poisson equation, $-\\Delta u = -1$, on the unit square $\\Omega = [0,1]\\times[0,1]$ with boundary data $u(x,y)=x$. We are tasked with demonstrating the satisfaction and violation of the Discrete Maximum Principle (DMP) using a piecewise linear Finite Element Method (FEM).\n\nThe DMP is a discrete analogue of the continuous maximum principle. For the given problem, the continuous solution attains its maximum on the boundary, i.e., $u(x,y) \\le \\max_{\\partial\\Omega} g = 1$. The DMP states that under certain conditions, the discrete solution $u_h$ also satisfies this property: $\\max_i u_h(i) \\le \\max_{j \\in \\partial\\Omega_h} g_j$. For the FEM, a sufficient condition for the DMP to hold is that the global stiffness matrix $K$ is an M-matrix. An M-matrix has positive diagonal entries and non-positive off-diagonal entries.\n\nFor the operator $-\\Delta$, the off-diagonal entry $K_{ij}$ of the stiffness matrix corresponding to an interior edge shared by two triangles $T_1$ and $T_2$ is given by $K_{ij} = -\\frac{1}{2}\\left(\\cot\\theta_1 + \\cot\\theta_2\\right)$, where $\\theta_1$ and $\\theta_2$ are the angles opposite the edge $(i,j)$ in each triangle. If the triangulation is non-obtuse (all angles $\\le 90^\\circ$), then all cotangents are non-negative, and thus all off-diagonal entries $K_{ij}$ are non-positive. This ensures $K$ is an M-matrix and the DMP holds. If a triangle contains an obtuse angle (e.g., $\\theta_1 > 90^\\circ$), its cotangent is negative. If $|\\cot\\theta_1| > \\cot\\theta_2$, the entry $K_{ij}$ becomes positive, violating the M-matrix property and potentially leading to a loss of the DMP, enabling non-physical oscillations or \"overshoot\" where the numerical solution exceeds the boundary maximum.\n\nWe construct a $5$-node mesh with nodes at the corners of the unit square, indexed $0$ to $3$, and one interior node, indexed $4$. This forms four triangles. The degrees of freedom are the nodal values $u_h(i)$. The values at the boundary nodes ($0,1,2,3$) are fixed by the Dirichlet condition $g(x,y)=x$. The only unknown is the value $u_h(4)$ at the interior node.\n\nThe FEM discretization leads to a linear system $K u_h = F$. After assembly, we apply the boundary conditions. The system can be partitioned into interior ($I$) and boundary ($B$) nodes. The equation for the interior degrees of freedom $u_I$ is $K_{II} u_I = F_I - K_{IB} g_B$. In our case, $I=\\{4\\}$, so this simplifies to a single scalar equation:\n$$\nK_{44} u_h(4) = F_4 - \\sum_{j=0}^{3} K_{4j} g(x_j, y_j)\n$$\nThe boundary values are $g_0 = g(0,0) = 0$, $g_1 = g(1,0) = 1$, $g_2 = g(1,1) = 1$, and $g_3 = g(0,1) = 0$. The maximum boundary value is $\\max_{j\\in\\partial\\Omega} g_j = 1$. The overshoot is computed as $\\max\\{0, u_h(4) - 1\\}$.\n\nThe procedure is to:\n1.  Define the node coordinates for each test case.\n2.  Assemble the $5\\times5$ global stiffness matrix $K$ and $5\\times1$ load vector $F$ using the provided local formulas. The source term $f=-1$ implies the total load on the interior node is $F_4 = \\sum_e (-A_e/3) = -(\\text{Total Area})/3 = -1/3$, independent of the interior node's position.\n3.  Solve the scalar equation for $u_h(4)$.\n4.  Calculate the overshoot.\n\n**Case A: Interior node at $(0.5, 0.5)$**\nThe four triangles are identical, isosceles, and right-angled. The angles are $90^\\circ$ and $45^\\circ$. The triangulation is non-obtuse. The stiffness matrix $K$ will be an M-matrix. The DMP holds, and we expect zero overshoot. Calculation shows $u_h(4) = 5/12 \\approx 0.4167$, which is less than $1$, so the overshoot is $0$.\n\n**Case B: Obtuse triangulation with interior node at $(0.5, y)$**\nTo violate the M-matrix property, we must introduce an obtuse angle. Placing the interior node at $(0.5, y)$ with $|y|  0.5$ makes the angle at this node within the triangle $(0,1,4)$ obtuse. We select $y=0.1$ as a representative point. This choice makes an off-diagonal entry of $K$ positive, breaking the M-matrix structure and allowing for a possible overshoot.\n\n**Case C: Obtuse triangulation with interior node at $(x, 0.5)$**\nBy symmetry with Case B, we place the interior node at $(x, 0.5)$ with $|x|  0.5$. We select $x=0.1$. This makes the angle at the interior node within the triangle $(0,3,4)$ obtuse, again violating the M-matrix condition.\n\nThe Python code below implements this procedure for the three cases and computes the resulting overshoot.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _calculate_local_matrices(coords: np.ndarray):\n    \"\"\"\n    Computes the local stiffness matrix and load vector for a single triangular element.\n\n    Args:\n        coords: A 3x2 numpy array of vertex coordinates (x, y).\n\n    Returns:\n        A tuple (Ke, Fe) where Ke is the 3x3 local stiffness matrix and\n        Fe is the 3-element local load vector.\n    \"\"\"\n    p1, p2, p3 = coords\n    x1, y1 = p1\n    x2, y2 = p2\n    x3, y3 = p3\n\n    # Area of the triangle using the shoelace formula\n    area = 0.5 * np.abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))\n    if area  1e-12:\n        raise ValueError(\"Triangle with zero or near-zero area detected.\")\n\n    # b and c coefficients related to the gradients of the P1 basis functions\n    # For a cycle (i,j,k), b_i = y_j - y_k, c_i = x_k - x_j\n    b_coeffs = np.array([y2 - y3, y3 - y1, y1 - y2])\n    c_coeffs = np.array([x3 - x2, x1 - x3, x2 - x1])\n\n    # Local stiffness matrix Ke(i,j) = (b_i*b_j + c_i*c_j) / (4*Area)\n    # This derives from integrating grad(N_i) . grad(N_j) over the triangle.\n    Ke = np.zeros((3, 3), dtype=np.float64)\n    for i in range(3):\n        for j in range(3):\n            Ke[i, j] = (b_coeffs[i] * b_coeffs[j] + c_coeffs[i] * c_coeffs[j]) / (4.0 * area)\n\n    # Local load vector for a constant source f = -1\n    # Fe(i) = integral(N_i * f) dx = f * Area / 3\n    Fe = (-area / 3.0) * np.ones(3, dtype=np.float64)\n\n    return Ke, Fe\n\ndef _calculate_overshoot(interior_node_coords: tuple[float, float]):\n    \"\"\"\n    Assembles the global system for the 5-node mesh, solves for the single \n    interior node, and computes the overshoot.\n\n    Args:\n        interior_node_coords: A tuple (x, y) for the interior node.\n\n    Returns:\n        The computed overshoot value.\n    \"\"\"\n    # 5-node mesh: 4 corners of the unit square and 1 interior node\n    nodes = np.array([\n        [0.0, 0.0],  # Node 0: (0,0)\n        [1.0, 0.0],  # Node 1: (1,0)\n        [1.0, 1.0],  # Node 2: (1,1)\n        [0.0, 1.0],  # Node 3: (0,1)\n        interior_node_coords  # Node 4: interior\n    ], dtype=np.float64)\n\n    # Triangulation: connect interior node to all corners\n    elements = np.array([\n        [0, 1, 4],\n        [1, 2, 4],\n        [2, 3, 4],\n        [3, 0, 4]\n    ])\n\n    num_nodes = len(nodes)\n    K = np.zeros((num_nodes, num_nodes), dtype=np.float64)\n    F = np.zeros(num_nodes, dtype=np.float64)\n\n    # Assemble global stiffness matrix K and load vector F\n    for i, elem_nodes in enumerate(elements):\n        elem_coords = nodes[elem_nodes]\n        Ke, Fe = _calculate_local_matrices(elem_coords)\n        \n        # Add local contributions to global matrices\n        for local_i in range(3):\n            global_i = elem_nodes[local_i]\n            F[global_i] += Fe[local_i]\n            for local_j in range(3):\n                global_j = elem_nodes[local_j]\n                K[global_i, global_j] += Ke[local_i, local_j]\n    \n    # Boundary values g(x,y)=x. Nodes 0,1,2,3 are on the boundary.\n    g_boundary = np.array([\n        nodes[0, 0],  # g(0,0) = 0\n        nodes[1, 0],  # g(1,0) = 1\n        nodes[2, 0],  # g(1,1) = 1\n        nodes[3, 0]   # g(0,1) = 0\n    ], dtype=np.float64)\n\n    # Apply strong Dirichlet BCs by solving for the single interior node (node 4)\n    # The system is K_II * u_I = F_I - K_IB * u_B, where I={4} and B={0,1,2,3}\n    boundary_indices = [0, 1, 2, 3]\n    interior_index = 4\n    \n    # K_IB * u_B part of the equation\n    rhs_boundary_contribution = 0.0\n    for i, b_idx in enumerate(boundary_indices):\n        rhs_boundary_contribution += K[interior_index, b_idx] * g_boundary[i]\n    \n    # Full RHS: F_I - K_IB * u_B\n    rhs_total = F[interior_index] - rhs_boundary_contribution\n    \n    # Solve the 1x1 system for the interior node: K_II * u_I = rhs_total\n    u4 = rhs_total / K[interior_index, interior_index]\n    \n    # Full discrete solution vector\n    u_h = np.zeros(num_nodes, dtype=np.float64)\n    u_h[boundary_indices] = g_boundary\n    u_h[interior_index] = u4\n    \n    # Maximum value of the boundary data g is 1\n    max_g = 1.0\n    \n    # Overshoot is the amount by which the solution maximum exceeds the boundary maximum\n    overshoot = max(0.0, np.max(u_h) - max_g)\n    \n    return overshoot\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Test suite from the problem statement.\n    # Locations for Cases B and C are chosen based on analysis to produce\n    # obtuse triangles and violate the M-matrix condition.\n    test_cases = [\n        (0.5, 0.5),  # Case A: Non-obtuse, DMP satisfied\n        (0.5, 0.1),  # Case B: Obtuse via vertical shift, DMP violated\n        (0.1, 0.5),  # Case C: Obtuse via horizontal shift, DMP violated\n    ]\n\n    results = []\n    for case_coords in test_cases:\n        overshoot = _calculate_overshoot(case_coords)\n        results.append(overshoot)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3419375"}, {"introduction": "Beyond its theoretical importance, the maximum principle serves as a powerful and practical tool for code verification in scientific computing. By designing problems with known analytical bounds—a technique known as the method of manufactured solutions—we can create automated tests to confirm that our numerical solvers are stable and correctly implemented. This practice [@problem_id:3419390] guides you through building such a test harness to verify the DMP for both elliptic (Poisson) and parabolic (heat) equation solvers, highlighting how to detect regressions or instabilities.", "problem": "Consider the discrete verification of the maximum principle for elliptic and parabolic partial differential equations using the method of manufactured solutions. The goal is to build a test harness that automatically detects violations of the Discrete Maximum Principle (DMP) in finite difference schemes when boundary data and initial conditions impose known $L^{\\infty}$ bounds. All quantities are non-dimensional. Throughout, the spatial computational domain is the unit square $\\Omega = [0,1] \\times [0,1]$, and grids are uniform and aligned. The following foundational facts are assumed: (i) the continuous weak maximum principle for the Laplacian states that if $\\Delta u \\ge 0$ in $\\Omega$ and $u$ is continuous on $\\overline{\\Omega}$, then the maximum of $u$ over $\\overline{\\Omega}$ is attained on $\\partial \\Omega$; and if $\\Delta u \\le 0$, then the minimum of $u$ is attained on $\\partial \\Omega$; (ii) for the heat equation $u_t = \\Delta u$ with Dirichlet boundary conditions, the maximum principle states that for $t \\ge 0$, the essential supremum of $u$ in space-time does not exceed the supremum of the union of the initial and boundary data, and similarly for the infimum. These principles motivate monotonicity constraints in discrete schemes.\n\nYou must implement the following verification tasks:\n\n1. Elliptic verification (Laplace and Poisson):\n   - Use the five-point finite difference approximation of the operator $-\\Delta$ on a uniform interior grid of size $N \\times N$ with grid spacing $h = 1/(N+1)$ on interior indices $(i,j)$ for $i,j \\in \\{1,\\dots,N\\}$. For the discrete Laplacian, construct the sparse matrix with diagonal entries $4/h^2$ and immediate neighbor entries $-1/h^2$ in the four cardinal directions. Incorporate Dirichlet boundary conditions via modification of the right-hand side (by adding known boundary values multiplied by $1/h^2$ when neighbor nodes lie on the boundary).\n   - Manufactured boundary data case (harmonic boundary extension): Impose boundary data $u(x,y) = x$ on $\\partial \\Omega$ and solve the discrete Laplace equation $-\\Delta_h u_h = 0$ on interior nodes. The discrete maximum principle predicts $u_h$ is bounded in the interval $[0,1]$ since the boundary data achieves a minimum of $0$ and maximum of $1$.\n   - Manufactured source case (nonnegative forcing): Impose homogeneous Dirichlet boundary data $u = 0$ on $\\partial \\Omega$ and solve the discrete Poisson problem $-\\Delta_h u_h = f$ with $f(x,y) = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y) \\ge 0$ on interior nodes. The discrete minimum principle predicts $u_h \\ge 0$ on interior nodes when the matrix is an $M$-matrix and $f \\ge 0$.\n   - For both elliptic tests, verify the corresponding DMP assertions numerically within a tolerance $\\tau = 10^{-12}$ on interior nodes.\n\n2. Parabolic verification (explicit forward Euler scheme for the heat equation):\n   - Consider the finite difference scheme for $u_t = \\Delta u$ with Dirichlet boundary conditions $u = 0$ on $\\partial \\Omega$, using the explicit forward Euler method on a uniform grid of interior size $N \\times N$ and spacing $h = 1/(N+1)$. Let $r = \\Delta t / h^2$. The scheme updates interior nodes via\n     $$u_{i,j}^{n+1} = u_{i,j}^{n} + r\\left(u_{i+1,j}^{n} + u_{i-1,j}^{n} + u_{i,j+1}^{n} + u_{i,j-1}^{n} - 4u_{i,j}^{n}\\right).$$\n     - Use initial condition $u^0(x,y) = \\sin(\\pi x)\\sin(\\pi y)$, which satisfies $u^0 \\ge 0$ and $\\|u^0\\|_{\\infty} = 1$ on interior nodes, and zero boundary data $u^n = 0$ on $\\partial \\Omega$ for all $n$.\n     - Verify the discrete maximum principle assertion for each time step $n$ over $T$ steps: specifically, check that $u_{i,j}^{n}$ remains in the interval $[0, \\|u^0\\|_{\\infty}]$ within a tolerance $\\tau = 10^{-12}$ provided that the coefficient constraint $r \\le 1/4$ holds, which makes the update a convex combination of neighboring values and thus monotone.\n     - Demonstrate detection of DMP violation by running a case with $r  1/4$; if at any step $u_{i,j}^{n}$ falls outside the interval $[0, \\|u^0\\|_{\\infty}]$ beyond tolerance, flag a violation.\n\nYou must implement a single program that constructs and runs the following test suite. For all tests, use $N = 31$, tolerance $\\tau = 10^{-12}$, and in parabolic tests use $T = 50$ steps. Each test returns a Boolean indicating whether the DMP condition is satisfied.\n\n- Test $\\mathsf{E1}$ (elliptic, harmonic boundary): $-\\Delta_h u_h = 0$, boundary data $u|_{\\partial\\Omega} = x$, assert $\\min(u_h) \\ge 0 - \\tau$ and $\\max(u_h) \\le 1 + \\tau$.\n- Test $\\mathsf{E2}$ (elliptic, nonnegative source): $-\\Delta_h u_h = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$, boundary data $u|_{\\partial\\Omega} = 0$, assert $\\min(u_h) \\ge 0 - \\tau$.\n- Test $\\mathsf{P1}$ (parabolic, stable time step): explicit scheme with $r = 0.24$, boundary data $u^n|_{\\partial\\Omega} = 0$, initial $u^0 = \\sin(\\pi x)\\sin(\\pi y)$, assert at each step $n$ that $\\min(u^n) \\ge 0 - \\tau$ and $\\max(u^n) \\le 1 + \\tau$.\n- Test $\\mathsf{P2}$ (parabolic, unstable time step): explicit scheme with $r = 0.26$, boundary data $u^n|_{\\partial\\Omega} = 0$, initial $u^0 = \\sin(\\pi x)\\sin(\\pi y)$, assert as in $\\mathsf{P1}$; expect violation.\n- Test $\\mathsf{P3}$ (parabolic, critical time step): explicit scheme with $r = 0.25$, boundary data $u^n|_{\\partial\\Omega} = 0$, initial $u^0 = \\sin(\\pi x)\\sin(\\pi y)$, assert as in $\\mathsf{P1}$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5]\"). Each result must be a Boolean for the corresponding test case in the order $\\mathsf{E1}$, $\\mathsf{E2}$, $\\mathsf{P1}$, $\\mathsf{P2}$, $\\mathsf{P3}$.", "solution": "The verification framework is built on the maximum principles for elliptic and parabolic operators and their discrete analogues. The foundation is the following set of principles and properties.\n\nFor elliptic equations, consider an operator $L u = -\\Delta u$ on a bounded domain $\\Omega$ with Dirichlet boundary conditions. The continuous maximum and minimum principles state that if $L u \\ge 0$ (equivalently $\\Delta u \\le 0$, $u$ is superharmonic), then the minimum of $u$ occurs on the boundary $\\partial \\Omega$, and if $L u \\le 0$ (equivalently $\\Delta u \\ge 0$, $u$ is subharmonic), then the maximum of $u$ occurs on $\\partial \\Omega$. For the five-point stencil discretization, the resulting linear system on interior nodes is $A u = b$ where $A$ has entries $A_{p,p} = 4/h^2$ and $A_{p,q} = -1/h^2$ for nearest neighbors $q$ of $p$, and $A_{p,q} = 0$ otherwise, and the right-hand side $b$ accounts for internal forcing $f$ and boundary contributions $\\sum (1/h^2) g$ with $g$ the Dirichlet boundary values. This matrix $A$ is an $M$-matrix: $A$ is a Z-matrix (off-diagonal entries are $\\le 0$), diagonally dominant and strictly positive definite, implying $A^{-1} \\ge 0$ componentwise. Therefore, if $b \\ge 0$ componentwise (e.g., due to nonnegative $f$ and nonnegative boundary contributions), the discrete solution $u = A^{-1} b$ is nonnegative, consistent with the discrete minimum principle. For homogeneous right-hand side $f \\equiv 0$, the maximum and minimum of the discrete solution $u$ lie within the convex hull of boundary values when the scheme is monotone. Constructed boundary data $u|_{\\partial \\Omega} = x$ on a square yields values in $[0,1]$, and the discrete solution inherits these bounds.\n\nFor parabolic equations, consider $u_t = \\Delta u$ with Dirichlet boundary conditions. The explicit forward Euler scheme on a uniform grid is\n$$u_{i,j}^{n+1} = (1 - 4r) u_{i,j}^{n} + r\\left(u_{i+1,j}^{n} + u_{i-1,j}^{n} + u_{i,j+1}^{n} + u_{i,j-1}^{n}\\right),$$\nwhere $r = \\Delta t / h^2$. If $r \\le 1/4$, all coefficients in this update are nonnegative and sum to $1$, making $u_{i,j}^{n+1}$ a convex combination of current and neighboring values. With nonnegative initial data and zero Dirichlet boundary data, the discrete solution preserves nonnegativity and remains bounded above by the initial supremum, matching the discrete maximum principle analogue. If $r  1/4$, the central coefficient becomes negative, breaking monotonicity and potentially causing overshoots or undershoots that violate the maximum principle.\n\nAlgorithmic design for the verification harness:\n\n1. Discrete elliptic solver:\n   - Construct the sparse $N^2 \\times N^2$ five-point Laplacian matrix $A$ for interior nodes. Map $(i,j)$ with $i,j \\in \\{1,\\dots,N\\}$ to a single index via $p = (i-1) N + (j-1)$.\n   - Compute the right-hand side $b$ by sampling the manufactured source $f(x_i,y_j)$ at interior coordinates $(x_i,y_j) = (i h, j h)$ and adding Dirichlet boundary contributions. Each neighbor outside the interior adds $(1/h^2) g$ to $b$, where $g$ is the boundary value at the neighbor’s coordinate. This yields the discrete system $A u = b$ representing $-\\Delta_h u_h = f$.\n   - Solve the system using a sparse linear solver. Then check DMP assertions: for the harmonic boundary test ($f \\equiv 0$, boundary $u|_{\\partial \\Omega} = x$), verify $\\min(u_h) \\ge 0 - \\tau$ and $\\max(u_h) \\le 1 + \\tau$. For the nonnegative source test ($f \\ge 0$, boundary $u|_{\\partial \\Omega} = 0$), verify $\\min(u_h) \\ge 0 - \\tau$.\n\n2. Explicit parabolic scheme:\n   - Initialize $u^0_{i,j} = \\sin(\\pi x_i)\\sin(\\pi y_j)$ on interior nodes and set boundary nodes to zero for all times. Compute the initial supremum $\\|u^0\\|_{\\infty}$ on the interior.\n   - For a given $r = \\Delta t / h^2$, iterate the explicit update for $T$ time steps. At each step, enforce boundary zero at the edges. After each update, verify DMP assertions: check that the minimum on the interior is at least $0 - \\tau$ and the maximum does not exceed $\\|u^0\\|_{\\infty} + \\tau$.\n   - For $r \\le 1/4$, the update is a convex combination, guaranteeing monotonicity and DMP preservation; for $r  1/4$, detect violations by the bound checks.\n\nTest suite and outputs:\n- Test $\\mathsf{E1}$: $N = 31$, $h = 1/(N+1)$, boundary $u|_{\\partial \\Omega} = x$, right-hand side $f \\equiv 0$, return a Boolean indicating whether both $\\min(u_h) \\ge 0 - \\tau$ and $\\max(u_h) \\le 1 + \\tau$ hold.\n- Test $\\mathsf{E2}$: $N = 31$, boundary $u|_{\\partial \\Omega} = 0$, $f(x,y) = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$, return a Boolean indicating whether $\\min(u_h) \\ge 0 - \\tau$ holds.\n- Test $\\mathsf{P1}$: $N = 31$, $r = 0.24$, $T = 50$, initial $u^0 = \\sin(\\pi x)\\sin(\\pi y)$, boundary zero; return a Boolean indicating whether DMP bounds hold at all steps.\n- Test $\\mathsf{P2}$: $N = 31$, $r = 0.26$, $T = 50$, same initial and boundary conditions; return a Boolean indicating whether DMP bounds hold (expected to be false).\n- Test $\\mathsf{P3}$: $N = 31$, $r = 0.25$, $T = 50$, same initial and boundary conditions; return a Boolean indicating whether DMP bounds hold.\n\nThe final program aggregates the five test results in order and prints them as a single line in the required format, ensuring self-contained execution without external inputs.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csr_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef build_5pt_laplacian_matrix(N, h):\n    \"\"\"\n    Build the sparse matrix A for the 5-point discretization of -Delta on an N x N interior grid.\n    Diagonal entries: 4/h^2\n    Off-diagonal (neighbors): -1/h^2\n    \"\"\"\n    n = N * N\n    A = lil_matrix((n, n))\n    inv_h2 = 1.0 / (h * h)\n    for i in range(N):\n        for j in range(N):\n            p = i * N + j\n            # center\n            A[p, p] = 4.0 * inv_h2\n            # left neighbor\n            if i > 0:\n                A[p, (i - 1) * N + j] = -1.0 * inv_h2\n            # right neighbor\n            if i  N - 1:\n                A[p, (i + 1) * N + j] = -1.0 * inv_h2\n            # down neighbor\n            if j > 0:\n                A[p, i * N + (j - 1)] = -1.0 * inv_h2\n            # up neighbor\n            if j  N - 1:\n                A[p, i * N + (j + 1)] = -1.0 * inv_h2\n    return csr_matrix(A)\n\ndef solve_dirichlet_poisson(N, boundary_func, rhs_func):\n    \"\"\"\n    Solve -Delta_h u = f on an N x N interior grid with Dirichlet boundary conditions.\n    boundary_func(x, y) gives boundary value u on the boundary.\n    rhs_func(x, y) gives f at interior points.\n    Returns u_interior (N x N) array of solution values on interior nodes.\n    \"\"\"\n    h = 1.0 / (N + 1)\n    A = build_5pt_laplacian_matrix(N, h)\n    n = N * N\n    b = np.zeros(n, dtype=float)\n    inv_h2 = 1.0 / (h * h)\n\n    # Coordinates: interior nodes at (i=1..N, j=1..N) mapped to x=i*h, y=j*h\n    # Boundary indices are at i=0 and i=N+1 for x, and j=0 and j=N+1 for y.\n    for i in range(1, N + 1):\n        x_i = i * h\n        for j in range(1, N + 1):\n            y_j = j * h\n            p = (i - 1) * N + (j - 1)\n            # RHS f\n            b[p] = rhs_func(x_i, y_j)\n            # Boundary contributions: check neighbors outside interior domain\n            # left neighbor at i-1\n            if i - 1 == 0:\n                # boundary at x=0, interior y_j\n                g = boundary_func(0.0, y_j)\n                b[p] += inv_h2 * g\n            # right neighbor at i+1\n            if i + 1 == N + 1:\n                # boundary at x=1, interior y_j\n                g = boundary_func(1.0, y_j)\n                b[p] += inv_h2 * g\n            # down neighbor at j-1\n            if j - 1 == 0:\n                # boundary at y=0, interior x_i\n                g = boundary_func(x_i, 0.0)\n                b[p] += inv_h2 * g\n            # up neighbor at j+1\n            if j + 1 == N + 1:\n                # boundary at y=1, interior x_i\n                g = boundary_func(x_i, 1.0)\n                b[p] += inv_h2 * g\n\n    # Solve\n    u_vec = spsolve(A, b)\n    u_interior = u_vec.reshape((N, N))\n    return u_interior\n\ndef test_E1(N, tol):\n    \"\"\"\n    Elliptic test E1: -Delta_h u = 0 with boundary u|_{∂Ω} = x.\n    Check that interior solution lies within [0, 1] up to tolerance.\n    \"\"\"\n    h = 1.0 / (N + 1)\n    def boundary_func(x, y):\n        return x\n    def rhs_func(x, y):\n        return 0.0\n\n    u_interior = solve_dirichlet_poisson(N, boundary_func, rhs_func)\n    umin = np.min(u_interior)\n    umax = np.max(u_interior)\n    ok = (umin >= -tol) and (umax = 1.0 + tol)\n    return ok\n\ndef test_E2(N, tol):\n    \"\"\"\n    Elliptic test E2: -Delta_h u = f with f(x,y) = 2*pi^2*sin(pi x)*sin(pi y), and boundary u=0.\n    Check discrete minimum principle: u_interior >= 0 (within tolerance).\n    \"\"\"\n    pi = np.pi\n    def boundary_func(x, y):\n        return 0.0\n    def rhs_func(x, y):\n        return 2.0 * (pi ** 2) * np.sin(pi * x) * np.sin(pi * y)\n\n    u_interior = solve_dirichlet_poisson(N, boundary_func, rhs_func)\n    umin = np.min(u_interior)\n    ok = (umin >= -tol)\n    return ok\n\ndef run_heat_explicit(N, r, T, tol):\n    \"\"\"\n    Run explicit forward Euler for u_t = Delta u with zero Dirichlet boundary.\n    Initial condition u0 = sin(pi x) sin(pi y).\n    Check DMP at each step: interior u stays within [0, initial_max] within tolerance.\n    \"\"\"\n    h = 1.0 / (N + 1)\n    pi = np.pi\n\n    # Full grid including boundaries: (N+2) x (N+2)\n    u = np.zeros((N + 2, N + 2), dtype=float)\n\n    # Initialize interior\n    for i in range(1, N + 1):\n        x_i = i * h\n        for j in range(1, N + 1):\n            y_j = j * h\n            u[i, j] = np.sin(pi * x_i) * np.sin(pi * y_j)\n\n    initial_max = np.max(u[1:N+1, 1:N+1])\n\n    # Time stepping\n    for n in range(T):\n        u_new = np.copy(u)\n        # Update interior using 5-point Laplacian explicit scheme\n        # zero Dirichlet boundaries remain zero\n        for i in range(1, N + 1):\n            for j in range(1, N + 1):\n                u_new[i, j] = (\n                    u[i, j]\n                    + r * (\n                        u[i + 1, j] + u[i - 1, j] + u[i, j + 1] + u[i, j - 1]\n                        - 4.0 * u[i, j]\n                    )\n                )\n        # Enforce boundary zeros explicitly (optional redundancy)\n        u_new[0, :] = 0.0\n        u_new[N + 1, :] = 0.0\n        u_new[:, 0] = 0.0\n        u_new[:, N + 1] = 0.0\n\n        u = u_new\n\n        # Check DMP bounds on interior\n        umin = np.min(u[1:N+1, 1:N+1])\n        umax = np.max(u[1:N+1, 1:N+1])\n        if not (umin >= -tol and umax = initial_max + tol):\n            return False\n    return True\n\ndef test_P1(N, tol):\n    \"\"\"\n    Parabolic test P1: Explicit scheme with r = 0.24 (stable).\n    \"\"\"\n    r = 0.24\n    T = 50\n    return run_heat_explicit(N, r, T, tol)\n\ndef test_P2(N, tol):\n    \"\"\"\n    Parabolic test P2: Explicit scheme with r = 0.26 (unstable, expect DMP violation).\n    \"\"\"\n    r = 0.26\n    T = 50\n    return run_heat_explicit(N, r, T, tol)\n\ndef test_P3(N, tol):\n    \"\"\"\n    Parabolic test P3: Explicit scheme with r = 0.25 (critical, should preserve DMP).\n    \"\"\"\n    r = 0.25\n    T = 50\n    return run_heat_explicit(N, r, T, tol)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    N = 31\n    tol = 1e-12\n    # Run tests E1, E2, P1, P2, P3 in order.\n    results = []\n    results.append(test_E1(N, tol))\n    results.append(test_E2(N, tol))\n    results.append(test_P1(N, tol))\n    results.append(test_P2(N, tol))\n    results.append(test_P3(N, tol))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3419390"}]}