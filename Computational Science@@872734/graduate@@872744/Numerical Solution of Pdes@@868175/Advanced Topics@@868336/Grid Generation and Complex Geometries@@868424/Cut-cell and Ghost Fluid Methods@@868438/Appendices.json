{"hands_on_practices": [{"introduction": "A primary challenge in explicit time-stepping schemes on cut-cell grids is the \"small cell problem.\" The stability of these schemes is often constrained by the size of the smallest cell, leading to impractically small time steps. This practice provides a direct, hands-on experience with this instability by first asking you to compute an update with a naive explicit method and then to stabilize it using the cell-merging technique. This exercise [@problem_id:3376330] is fundamental to understanding why naive implementations fail and how to fix them.", "problem": "Consider the one-dimensional, nondimensional heat equation $u_{t}=\\kappa\\,u_{xx}$ with constant diffusivity $\\kappa>0$ on a short segment represented by two finite volume cells, where an immersed solid boundary cuts the left cell into a tiny fluid subcell adjacent to a regular fluid cell. The left cell $C_{0}$ nominally spans $[0,\\Delta x]$, and the right cell $C_{1}$ spans $[\\Delta x,2\\Delta x]$, with uniform grid spacing $\\Delta x$. An immersed boundary intersects $C_{0}$ at position $x_{L}=\\Delta x-\\varepsilon\\,\\Delta x$, leaving a fluid subcell of length $\\ell=\\varepsilon\\,\\Delta x$ adjacent to the face at $x=\\Delta x$. The external right boundary at $x=2\\Delta x$ is subject to a homogeneous Neumann condition. The value of $u$ on the immersed boundary is prescribed by a Dirichlet condition $u(x_{L},t)=u_{b}$, enforced using the Ghost Fluid Method (GFM) in which the diffusive flux at the cut face is computed from a one-sided linear gradient between the cellâ€™s representative value and the boundary value over the geometric distance to the cut face.\n\nYou are given the following nondimensional parameters and initial data:\n- $\\Delta x=1$,\n- $\\varepsilon=0.1$ (so $\\ell=0.1$),\n- $\\kappa=1$,\n- time step $\\Delta t=0.2$ (Forward Euler),\n- $u_{b}=0$ at $x=x_{L}$,\n- initial cell averages $U_{0}^{n}=1$ in $C_{0}$ and $U_{1}^{n}=1$ in $C_{1}$.\n\nGeometric data:\n- The fluid portion of $C_{0}$ occupies $[x_{L},\\Delta x]=[0.9,1]$, so its centroid is at $x_{c,0}=0.95$ and volume (length) $V_{0}=\\ell=0.1$.\n- The regular cell $C_{1}$ occupies $[1,2]$, with centroid $x_{c,1}=1.5$ and volume $V_{1}=1$.\n- Distances from centroids to the interface at $x=1$ are $d_{0}=1-x_{c,0}=0.05$ and $d_{1}=x_{c,1}-1=0.5$. The distance from $x_{c,0}$ to the cut face at $x_{L}$ is $d_{L}=x_{c,0}-x_{L}=0.05$.\n\nTask A (naive explicit update on the cut cell): Using the finite volume method derived from conservation for $u_{t}=\\kappa u_{xx}$, approximate the gradients at faces with linear two-point formulas consistent with nonuniform distances. For the internal face at $x=1$, use the common two-point approximation $\\partial u/\\partial x\\big|_{1} \\approx (U_{1}^{n}-U_{0}^{n})/(d_{0}+d_{1})$. For the immersed boundary face at $x=x_{L}$, enforce the Dirichlet boundary via GFM by taking $\\partial u/\\partial x\\big|_{x_{L}^{+}} \\approx (U_{0}^{n}-u_{b})/d_{L}$. Perform a single Forward Euler step for $C_{0}$ to compute $U_{0,\\text{naive}}^{n+1}$.\n\nTask B (cell-merging stabilized update): Merge $C_{0}$ and $C_{1}$ into a single control volume of length $V_{m}=V_{0}+V_{1}=1.1$. Let the merged average be $U_{m}^{n}=(V_{0}U_{0}^{n}+V_{1}U_{1}^{n})/V_{m}$. The merged centroid is $x_{c,m}=(V_{0}x_{c,0}+V_{1}x_{c,1})/V_{m}$, and the distance from $x_{c,m}$ to the cut face is $d_{m}=x_{c,m}-x_{L}$. Update the merged average by a single Forward Euler step using only external boundary faces:\n- At $x=2$, impose $\\partial u/\\partial x=0$.\n- At $x=x_{L}$, approximate $\\partial u/\\partial x\\big|_{x_{L}^{+}} \\approx (U_{m}^{n}-u_{b})/d_{m}$.\nSet $U_{0,\\text{merge}}^{n+1}:=U_{m}^{n+1}$ as the stabilized cut-cell value after merging.\n\nCompute the scalar difference\n$$\\delta \\;=\\; U_{0,\\text{merge}}^{n+1}\\;-\\;U_{0,\\text{naive}}^{n+1}.$$\nReport $\\delta$ as a dimensionless number, rounded to four significant figures.", "solution": "The problem statement is found to be valid as it is scientifically grounded in the principles of numerical methods for partial differential equations, is well-posed with all necessary information provided, and is expressed in objective, unambiguous language. We can therefore proceed with the solution.\n\nThe problem asks for the difference between two updated values for a cut cell, one computed with a naive explicit method and the other with a stabilized cell-merging method. We address each task sequentially.\n\nFirst, we address Task A: the naive explicit update for the cut cell $C_{0}$. The one-dimensional heat equation is $u_{t}=\\kappa u_{xx}$. Applying the finite volume method to the fluid portion of cell $C_{0}$, which has volume (length) $V_{0}$ and occupies the interval $[x_{L}, \\Delta x]$, we integrate the PDE over this volume:\n$$ \\int_{V_0} u_t \\,dx = \\int_{V_0} \\kappa u_{xx} \\,dx $$\nAssuming the cell average is $U_{0}(t) = \\frac{1}{V_{0}} \\int_{V_0} u(x,t) \\,dx$, the left-hand side becomes $V_{0}\\frac{dU_{0}}{dt}$. The right-hand side becomes, by the fundamental theorem of calculus, $\\kappa u_{x}|_{\\Delta x} - \\kappa u_{x}|_{x_{L}}$. This yields the semi-discrete equation:\n$$ V_{0} \\frac{dU_{0}}{dt} = \\kappa \\left( \\frac{\\partial u}{\\partial x}\\bigg|_{x=\\Delta x} - \\frac{\\partial u}{\\partial x}\\bigg|_{x=x_{L}} \\right) $$\nApplying the Forward Euler time integration scheme with a time step $\\Delta t$, we get the fully discrete update formula:\n$$ U_{0}^{n+1} = U_{0}^{n} + \\frac{\\Delta t \\kappa}{V_{0}} \\left( \\left(\\frac{\\partial u}{\\partial x}\\right)\\bigg|_{x=\\Delta x}^{n} - \\left(\\frac{\\partial u}{\\partial x}\\right)\\bigg|_{x=x_{L}}^{n} \\right) $$\nThe problem specifies the approximations for the spatial derivatives (fluxes):\n- At the internal face $x=\\Delta x=1$: $\\left(\\frac{\\partial u}{\\partial x}\\right)\\big|_{x=\\Delta x}^{n} \\approx \\frac{U_{1}^{n}-U_{0}^{n}}{d_{0}+d_{1}}$\n- At the immersed boundary face $x=x_{L}$: $\\left(\\frac{\\partial u}{\\partial x}\\right)\\big|_{x=x_{L}^{+}}^{n} \\approx \\frac{U_{0}^{n}-u_{b}}{d_{L}}$\n\nWe substitute the given numerical values: $\\Delta x=1$, $\\varepsilon=0.1$, $\\kappa=1$, $\\Delta t=0.2$, $u_{b}=0$, $U_{0}^{n}=1$, $U_{1}^{n}=1$.\nGeometric data: $V_{0}=0.1$, $x_{L}=0.9$, $x_{c,0}=0.95$, $d_{0}=1-x_{c,0}=0.05$, $d_{1}=x_{c,1}-1=0.5$, and $d_{L}=x_{c,0}-x_{L}=0.05$.\n\nFirst, we compute the approximate gradients at step $n$:\n$$ \\left(\\frac{\\partial u}{\\partial x}\\right)\\bigg|_{x=1}^{n} \\approx \\frac{1-1}{0.05+0.5} = \\frac{0}{0.55} = 0 $$\n$$ \\left(\\frac{\\partial u}{\\partial x}\\right)\\bigg|_{x=0.9}^{n} \\approx \\frac{1-0}{0.05} = 20 $$\nNow, we substitute these into the update formula for $U_{0,\\text{naive}}^{n+1}$:\n$$ U_{0,\\text{naive}}^{n+1} = U_{0}^{n} + \\frac{\\Delta t \\kappa}{V_{0}} \\left( 0 - 20 \\right) = 1 + \\frac{0.2 \\times 1}{0.1} \\left(-20\\right) = 1 + 2(-20) = 1 - 40 = -39 $$\nSo, $U_{0,\\text{naive}}^{n+1} = -39$. The large magnitude and negative sign indicate a numerical instability, which is expected for an explicit scheme on a small cut cell with this time step.\n\nNext, we address Task B: the cell-merging stabilized update. The cut cell $C_{0}$ is merged with its neighbor $C_{1}$ to form a single larger control volume $C_{m}$.\nFirst, we determine the properties of the merged cell.\n- Merged volume: $V_{m} = V_{0} + V_{1} = 0.1 + 1 = 1.1$.\n- Merged cell-average at time $n$: $U_{m}^{n} = \\frac{V_{0}U_{0}^{n} + V_{1}U_{1}^{n}}{V_{m}} = \\frac{0.1 \\times 1 + 1 \\times 1}{1.1} = \\frac{1.1}{1.1} = 1$.\n- Merged cell centroid: $x_{c,m} = \\frac{V_{0}x_{c,0} + V_{1}x_{c,1}}{V_{m}} = \\frac{0.1 \\times 0.95 + 1 \\times 1.5}{1.1} = \\frac{0.095 + 1.5}{1.1} = \\frac{1.595}{1.1} = 1.45$.\n- Distance from the merged centroid to the cut face: $d_{m} = x_{c,m} - x_{L} = 1.45 - 0.9 = 0.55$.\n\nThe merged control volume occupies the interval $[x_{L}, 2\\Delta x] = [0.9, 2]$. The finite volume update is performed on this larger cell, using only the fluxes at its external boundaries ($x=x_{L}$ and $x=2$).\n$$ U_{m}^{n+1} = U_{m}^{n} + \\frac{\\Delta t \\kappa}{V_{m}} \\left( \\left(\\frac{\\partial u}{\\partial x}\\right)\\bigg|_{x=2}^{n} - \\left(\\frac{\\partial u}{\\partial x}\\right)\\bigg|_{x=x_{L}}^{n} \\right) $$\nThe boundary conditions for the merged-cell update are:\n- At $x=2$: Homogeneous Neumann condition, $\\frac{\\partial u}{\\partial x} = 0$.\n- At $x=x_{L}$: Ghost Fluid Method approximation, $\\left(\\frac{\\partial u}{\\partial x}\\right)\\big|_{x=x_{L}^{+}}^{n} \\approx \\frac{U_{m}^{n} - u_{b}}{d_{m}}$.\n\nWe compute the required gradient at $x=x_{L}$:\n$$ \\left(\\frac{\\partial u}{\\partial x}\\right)\\bigg|_{x=0.9}^{n} \\approx \\frac{1 - 0}{0.55} = \\frac{1}{0.55} $$\nSubstituting into the update formula for $U_{m}^{n+1}$:\n$$ U_{m}^{n+1} = U_{m}^{n} + \\frac{\\Delta t \\kappa}{V_{m}} \\left( 0 - \\frac{1}{0.55} \\right) = 1 + \\frac{0.2 \\times 1}{1.1} \\left( -\\frac{1}{0.55} \\right) = 1 - \\frac{0.2}{1.1 \\times 0.55} = 1 - \\frac{0.2}{0.605} $$\n$$ U_{m}^{n+1} = 1 - \\frac{200}{605} = 1 - \\frac{40}{121} = \\frac{121 - 40}{121} = \\frac{81}{121} $$\nThe stabilized cut-cell value is set to this merged value: $U_{0,\\text{merge}}^{n+1} = U_{m}^{n+1} = \\frac{81}{121}$.\nNumerically, this is approximately $0.6694214876$.\n\nFinally, we compute the scalar difference $\\delta$:\n$$ \\delta = U_{0,\\text{merge}}^{n+1} - U_{0,\\text{naive}}^{n+1} $$\n$$ \\delta = \\frac{81}{121} - (-39) = 39 + \\frac{81}{121} \\approx 39 + 0.6694214876 = 39.6694214876 $$\nThe problem requires this value rounded to four significant figures. The number is $39.6694...$. The first four significant digits are $3$, $9$, $6$, $6$. The fifth digit is $9$, which is $\\ge 5$, so we round up the fourth digit.\n$$ \\delta \\approx 39.67 $$\nThis result highlights the dramatic difference between the unstable naive update and the stable cell-merging approach for handling small cut cells in explicit time-stepping schemes.", "answer": "$$\n\\boxed{39.67}\n$$", "id": "3376330"}, {"introduction": "The power of the Ghost Fluid Method (GFM) lies in its ability to sharply impose physical conditions at an interface. For two-phase flows with surface tension, this means accurately representing the Laplace pressure jump, which is proportional to the interface curvature, $\\Delta p = \\sigma \\kappa$. This coding exercise [@problem_id:3376339] shifts our focus from temporal stability to the crucial role of spatial accuracy, challenging you to quantify the error introduced by different interface reconstruction schemes. By comparing linear and quadratic reconstructions for a known sinusoidal interface, you will directly measure how geometric fidelity impacts the physical accuracy of the GFM.", "problem": "Consider a two-dimensional incompressible two-phase interface captured by the Volume of Fluid (VOF) method, with pressure coupling via the Ghost Fluid Method (GFM). The GFM imposes a discontinuity in pressure across the interface according to the capillary pressure jump. The jump is given by the Laplace law, which states that the pressure jump equals the surface tension multiplied by the interface curvature. The interface is smooth, and local curvature is computed from a reconstruction of the interface shape within a uniform grid.\n\nFundamental base:\n- Laplace pressure jump: If the interface curvature is $\\,\\kappa\\,$ and the surface tension coefficient is $\\,\\sigma\\,$, then the pressure jump across the interface is $\\,\\Delta p = \\sigma \\kappa\\,$.\n- Curvature of a planar curve parameterized as $\\,y(x)\\,$ is given by\n$$\n\\kappa(x) = \\frac{y''(x)}{\\left(1 + \\left(y'(x)\\right)^2\\right)^{3/2}}.\n$$\n\nInterface configuration:\n- The interface is given analytically as a sinusoid,\n$$\ny(x) = a \\sin\\left( \\frac{2\\pi}{\\lambda} x \\right),\n$$\nwhere $\\,a\\,$ is the amplitude in meters and $\\,\\lambda\\,$ is the wavelength in meters.\n- The spatial domain is periodic in $\\,x\\,$ over one wavelength $\\,\\lambda\\,$.\n- A uniform grid of $\\,N_x\\,$ points samples the interface at locations $\\,x_i = i \\Delta x\\,$ for $\\,i=0,1,\\dots,N_x-1\\,$ with $\\,\\Delta x = \\lambda/N_x\\,$.\n\nReconstruction strategies:\n- Linear interface reconstruction: Approximate the local interface near $\\,x_i\\,$ by a first-degree polynomial,\n$$\ny(x) \\approx \\alpha_i + \\beta_i (x - x_i),\n$$\nwhich yields $\\,y''(x_i) \\approx 0\\,$ and therefore $\\,\\kappa_{\\text{lin}}(x_i) \\approx 0\\,$.\n- Quadratic interface reconstruction: Approximate the local interface near $\\,x_i\\,$ by a second-degree polynomial over a symmetric stencil of five points $\\,\\{x_{i-2}, x_{i-1}, x_{i}, x_{i+1}, x_{i+2}\\}\\,$ using least squares,\n$$\ny(x) \\approx a_{0,i} + a_{1,i} (x - x_i) + a_{2,i} (x - x_i)^2,\n$$\nfrom which\n$$\ny'(x_i) \\approx a_{1,i}, \\quad y''(x_i) \\approx 2 a_{2,i}, \\quad \\kappa_{\\text{quad}}(x_i) \\approx \\frac{2 a_{2,i}}{\\left( 1 + a_{1,i}^2 \\right)^{3/2}}.\n$$\n\nExact curvature:\nFrom the analytic interface, compute $\\,y'(x) = a \\left(\\frac{2\\pi}{\\lambda}\\right) \\cos\\left(\\frac{2\\pi}{\\lambda}x\\right)\\,$ and $\\,y''(x) = -a \\left(\\frac{2\\pi}{\\lambda}\\right)^2 \\sin\\left(\\frac{2\\pi}{\\lambda}x\\right)\\,$ to obtain the exact curvature\n$$\n\\kappa_{\\text{exact}}(x) = \\frac{-a \\left( \\frac{2\\pi}{\\lambda} \\right)^2 \\sin\\left( \\frac{2\\pi}{\\lambda} x \\right)}{\\left(1 + a^2 \\left( \\frac{2\\pi}{\\lambda} \\right)^2 \\cos^2\\left( \\frac{2\\pi}{\\lambda} x \\right) \\right)^{3/2}}.\n$$\n\nPressure jump error quantification:\n- For each grid location $\\,x_i\\,$, compute the exact pressure jump $\\,\\Delta p_{\\text{exact}}(x_i) = \\sigma \\kappa_{\\text{exact}}(x_i)\\,$ in Pascals.\n- Compute the estimated pressure jumps based on reconstruction:\n$$\n\\Delta p_{\\text{lin}}(x_i) = \\sigma \\kappa_{\\text{lin}}(x_i), \\quad \\Delta p_{\\text{quad}}(x_i) = \\sigma \\kappa_{\\text{quad}}(x_i).\n$$\n- Quantify the error via the root-mean-square error (RMSE) across the periodic domain,\n$$\n\\text{RMSE}_{\\text{lin}} = \\sqrt{\\frac{1}{N_x} \\sum_{i=0}^{N_x-1} \\left( \\Delta p_{\\text{lin}}(x_i) - \\Delta p_{\\text{exact}}(x_i) \\right)^2 },\n$$\n$$\n\\text{RMSE}_{\\text{quad}} = \\sqrt{\\frac{1}{N_x} \\sum_{i=0}^{N_x-1} \\left( \\Delta p_{\\text{quad}}(x_i) - \\Delta p_{\\text{exact}}(x_i) \\right)^2 }.\n$$\n\nScientific realism:\nThis setup models the curvature-induced pressure jump that a Ghost Fluid Method would impose across a VOF-reconstructed interface. The linear reconstruction, while standard for Piecewise Linear Interface Calculation (PLIC), cannot represent curvature at leading order, and the quadratic reconstruction captures second derivatives needed for curvature. The resulting error directly quantifies the mis-imposed capillary pressure in Pascals, which affects the numerical solution of partial differential equations governing two-phase incompressible flow.\n\nTest suite:\nFor each test case, the program shall compute $\\,\\text{RMSE}_{\\text{lin}}\\,$ and $\\,\\text{RMSE}_{\\text{quad}}\\,$ in Pascals.\n\n- Test Case $\\,1\\,$ (happy path): $\\,\\sigma = 0.072\\,$ N/m, $\\,\\lambda = 1.0\\,$ m, $\\,a = 0.05\\,$ m, $\\,N_x = 128\\,$.\n- Test Case $\\,2\\,$ (higher curvature amplitude): $\\,\\sigma = 0.072\\,$ N/m, $\\,\\lambda = 1.0\\,$ m, $\\,a = 0.20\\,$ m, $\\,N_x = 128\\,$.\n- Test Case $\\,3\\,$ (higher frequency): $\\,\\sigma = 0.072\\,$ N/m, $\\,\\lambda = 0.25\\,$ m, $\\,a = 0.05\\,$ m, $\\,N_x = 128\\,$.\n- Test Case $\\,4\\,$ (coarser grid resolution): $\\,\\sigma = 0.072\\,$ N/m, $\\,\\lambda = 1.0\\,$ m, $\\,a = 0.05\\,$ m, $\\,N_x = 32\\,$.\n\nAngle units are implicit in the trigonometric functions defined over radians. All lengths are in meters and pressure is in Pascals. Your program must compute and report $\\,\\text{RMSE}_{\\text{lin}}\\,$ and $\\,\\text{RMSE}_{\\text{quad}}\\,$ for each test case.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order\n$$\n\\left[ \\text{RMSE}_{\\text{lin}}^{(1)}, \\text{RMSE}_{\\text{quad}}^{(1)}, \\text{RMSE}_{\\text{lin}}^{(2)}, \\text{RMSE}_{\\text{quad}}^{(2)}, \\text{RMSE}_{\\text{lin}}^{(3)}, \\text{RMSE}_{\\text{quad}}^{(3)}, \\text{RMSE}_{\\text{lin}}^{(4)}, \\text{RMSE}_{\\text{quad}}^{(4)} \\right],\n$$\nwhere the superscript denotes the test case number. Each value must be a floating-point number in Pascals.", "solution": "The problem statement has been critically examined and is determined to be **valid**. It is scientifically grounded in the principles of computational fluid dynamics, mathematically well-posed, self-contained, and free of ambiguity or contradiction. It presents a rigorous and meaningful task in numerical analysis, specifically concerning the accuracy of interface curvature estimation, which is a critical component in the numerical simulation of two-phase flows with surface tension.\n\nThe task is to compute the root-mean-square error (RMSE) of the capillary pressure jump across a sinusoidal interface for two different interface reconstruction methods: linear and quadratic. The solution proceeds by first discretizing the analytical interface, then computing the exact curvature and pressure jump at each grid point. Subsequently, the pressure jump is estimated using each reconstruction method, and the RMSE is calculated by comparing these estimates to the exact values.\n\n**1. Discretization and Exact Solution**\n\nThe domain is a single wavelength $\\lambda$ of the sinusoid, sampled by $N_x$ equidistant points. The grid spacing is $\\Delta x = \\lambda/N_x$, and the grid points are $x_i = i \\Delta x$ for $i=0, 1, \\dots, N_x-1$.\n\nThe interface is defined by $y(x) = a \\sin(kx)$ where $k = 2\\pi/\\lambda$. The exact first and second derivatives are:\n$$\ny'(x) = ak \\cos(kx)\n$$\n$$\ny''(x) = -ak^2 \\sin(kx)\n$$\nThe exact curvature, $\\kappa_{\\text{exact}}(x_i)$, at each grid point $x_i$ is calculated using the provided formula:\n$$\n\\kappa_{\\text{exact}}(x_i) = \\frac{y''(x_i)}{\\left(1 + \\left(y'(x_i)\\right)^2\\right)^{3/2}} = \\frac{-ak^2 \\sin(kx_i)}{\\left(1 + (ak)^2 \\cos^2(kx_i)\\right)^{3/2}}\n$$\nThe exact pressure jump is then $\\Delta p_{\\text{exact}}(x_i) = \\sigma \\kappa_{\\text{exact}}(x_i)$, where $\\sigma$ is the surface tension coefficient.\n\n**2. Linear Reconstruction Error ($\\text{RMSE}_{\\text{lin}}$)**\n\nThe linear interface reconstruction approximates the interface locally with a straight line. This implies that the second derivative, and thus the curvature, is zero.\n$$\n\\kappa_{\\text{lin}}(x_i) = 0 \\implies \\Delta p_{\\text{lin}}(x_i) = \\sigma \\kappa_{\\text{lin}}(x_i) = 0\n$$\nThe error for the linear reconstruction at each point is $\\Delta p_{\\text{lin}}(x_i) - \\Delta p_{\\text{exact}}(x_i) = -\\Delta p_{\\text{exact}}(x_i)$. The RMSE is therefore the root mean square of the exact pressure jump itself:\n$$\n\\text{RMSE}_{\\text{lin}} = \\sqrt{\\frac{1}{N_x} \\sum_{i=0}^{N_x-1} \\left(0 - \\Delta p_{\\text{exact}}(x_i)\\right)^2} = \\sqrt{\\frac{1}{N_x} \\sum_{i=0}^{N_x-1} \\left(\\Delta p_{\\text{exact}}(x_i)\\right)^2}\n$$\n\n**3. Quadratic Reconstruction Error ($\\text{RMSE}_{\\text{quad}}$)**\n\nFor the quadratic reconstruction, the interface near $x_i$ is approximated by a parabola, $y(x) \\approx P_i(x) = a_{0,i} + a_{1,i}(x-x_i) + a_{2,i}(x-x_i)^2$. The coefficients $a_{0,i}$, $a_{1,i}$, and $a_{2,i}$ are determined by a least-squares fit to the true interface values $y_j = y(x_j)$ on a symmetric $5$-point stencil: $\\{x_{i-2}, x_{i-1}, x_i, x_{i+1}, x_{i+2}\\}$. The problem is periodic, so indices are taken modulo $N_x$.\n\nThis is a linear least-squares problem, solved by the normal equations $\\mathbf{A}^T\\mathbf{A}\\mathbf{c}_i = \\mathbf{A}^T\\mathbf{y}_{\\text{stencil},i}$, where $\\mathbf{y}_{\\text{stencil},i} = [y_{i-2}, y_{i-1}, y_i, y_{i+1}, y_{i+2}]^T$ and $\\mathbf{A}$ is the design matrix, which depends only on the relative positions in the stencil. The solution for the coefficients can be expressed as pre-computed finite difference stencils.\nWe are interested in $a_{1,i}$ and $a_{2,i}$, which can be found using the following stencils:\n$$\na_{1,i} = \\frac{1}{10\\Delta x}(-2y_{i-2} - y_{i-1} + y_{i+1} + 2y_{i+2})\n$$\n$$\na_{2,i} = \\frac{1}{14(\\Delta x)^2}(2y_{i-2} - y_{i-1} - 2y_i - y_{i+1} + 2y_{i+2})\n$$\nThese stencils are applied to the entire grid of $y_i$ values to obtain a vector of coefficients $a_{1}$ and $a_{2}$ for all grid points. Computationally, this is performed efficiently using vectorized operations with periodic boundary conditions.\n\nFrom the quadratic approximation, the derivatives at $x_i$ are estimated as $y'(x_i) \\approx a_{1,i}$ and $y''(x_i) \\approx 2a_{2,i}$. The curvature is then:\n$$\n\\kappa_{\\text{quad}}(x_i) = \\frac{2a_{2,i}}{\\left(1 + a_{1,i}^2\\right)^{3/2}}\n$$\nThe corresponding pressure jump is $\\Delta p_{\\text{quad}}(x_i) = \\sigma \\kappa_{\\text{quad}}(x_i)$.\n\nFinally, the RMSE for the quadratic reconstruction is computed:\n$$\n\\text{RMSE}_{\\text{quad}} = \\sqrt{\\frac{1}{N_x} \\sum_{i=0}^{N_x-1} \\left( \\Delta p_{\\text{quad}}(x_i) - \\Delta p_{\\text{exact}}(x_i) \\right)^2 }\n$$\nThe implementation will compute these quantities for each of the four specified test cases.", "answer": "```python\nimport numpy as np\n\ndef calculate_errors(sigma, lam, a, Nx):\n    \"\"\"\n    Calculates the RMSE for pressure jump estimation using linear and quadratic reconstructions.\n\n    Args:\n        sigma (float): Surface tension coefficient (N/m).\n        lam (float): Wavelength of the sinusoid (m).\n        a (float): Amplitude of the sinusoid (m).\n        Nx (int): Number of grid points.\n\n    Returns:\n        tuple[float, float]: A tuple containing (RMSE_lin, RMSE_quad) in Pascals.\n    \"\"\"\n    # 1. Setup Grid\n    dx = lam / Nx\n    x = np.arange(Nx) * dx\n\n    # 2. Exact Interface, Derivatives, and Curvature\n    k = 2.0 * np.pi / lam\n    y = a * np.sin(k * x)\n    y_prime_exact = a * k * np.cos(k * x)\n    y_prime_prime_exact = -a * k**2 * np.sin(k * x)\n    \n    # Denominator for the exact curvature formula\n    denom_exact = (1.0 + y_prime_exact**2)**1.5\n    kappa_exact = y_prime_prime_exact / denom_exact\n\n    # 3. Exact Pressure Jump\n    dp_exact = sigma * kappa_exact\n\n    # 4. Linear Reconstruction Error\n    # For linear reconstruction, kappa_lin = 0, so dp_lin = 0.\n    # The error is the difference between 0 and dp_exact.\n    rmse_lin = np.sqrt(np.mean(dp_exact**2))\n\n    # 5. Quadratic Reconstruction Curvature\n    # The coefficients a_{1,i} and a_{2,i} are computed using stencils derived\n    # from a 5-point least-squares fit.\n    # We use np.roll to handle periodic boundary conditions efficiently.\n    # A positive shift k in np.roll corresponds to index i-k.\n    y_m2 = np.roll(y, 2)  # y_{i-2}\n    y_m1 = np.roll(y, 1)  # y_{i-1}\n    y_p1 = np.roll(y, -1) # y_{i+1}\n    y_p2 = np.roll(y, -2) # y_{i+2}\n\n    # Stencil for a_{1,i}, which approximates y'(x_i)\n    a1_quad = (1.0 / (10.0 * dx)) * (-2.0 * y_m2 - y_m1 + y_p1 + 2.0 * y_p2)\n\n    # Stencil for a_{2,i}, where 2*a_{2,i} approximates y''(x_i)\n    a2_quad = (1.0 / (14.0 * dx**2)) * (2.0 * y_m2 - y_m1 - 2.0 * y - y_p1 + 2.0 * y_p2)\n\n    y_prime_quad = a1_quad\n    y_prime_prime_quad = 2.0 * a2_quad\n    \n    # Denominator for the quadratic curvature formula\n    denom_quad = (1.0 + y_prime_quad**2)**1.5\n    kappa_quad = y_prime_prime_quad / denom_quad\n    dp_quad = sigma * kappa_quad\n    \n    # 6. Quadratic Reconstruction Error\n    rmse_quad = np.sqrt(np.mean((dp_quad - dp_exact)**2))\n\n    return rmse_lin, rmse_quad\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (sigma, lambda, a, Nx)\n        (0.072, 1.0, 0.05, 128),  # Test Case 1\n        (0.072, 1.0, 0.20, 128),  # Test Case 2\n        (0.072, 0.25, 0.05, 128), # Test Case 3\n        (0.072, 1.0, 0.05, 32),   # Test Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        sigma, lam, a, Nx = case\n        rmse_lin, rmse_quad = calculate_errors(sigma, lam, a, Nx)\n        results.append(rmse_lin)\n        results.append(rmse_quad)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```", "id": "3376339"}, {"introduction": "Real-world applications often involve complex embedded geometries with sharp corners and arbitrary alignment with the computational grid, creating significant implementation challenges. This practice [@problem_id:3376303] tasks you with building a robust Ghost Fluid Method solver for the Poisson equation in the presence of a polygonal boundary. You will implement rules to handle corner singularities and cells cut by multiple faces, moving beyond idealized scenarios to develop a solver that can withstand the rigors of complex geometric configurations, a key skill for practical computational fluid dynamics.", "problem": "Consider the two-dimensional Poisson equation with an embedded internal Dirichlet boundary. Let the computational box be $\\Omega = [0,1] \\times [0,1]$ and let $\\Gamma \\subset \\Omega$ denote a simple, closed, convex polygonal curve (the embedded boundary) that divides $\\Omega$ into a fluid region $\\Omega_f = \\Omega \\setminus K$ and a solid region $K$ (the interior of $\\Gamma$). We study the boundary value problem\n$$\n-\\Delta u = f \\quad \\text{in } \\Omega_f,\n$$\nwith Dirichlet boundary conditions\n$$\nu = 0 \\quad \\text{on } \\partial \\Omega, \\qquad u = g \\quad \\text{on } \\Gamma.\n$$\nTo enable exact verification, use the method of manufactured solutions with the smooth target solution\n$$\nu^\\star(x,y) = \\sin(\\pi x)\\sin(\\pi y),\n$$\nwhich implies\n$$\nf(x,y) = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y), \\quad g(x,y) = u^\\star(x,y).\n$$\nDiscretize on a uniform Cartesian grid with spacing $h = 1/N$ and grid nodes $(x_i,y_j) = (i h, j h)$ for integers $i,j \\in \\{0,1,\\dots,N\\}$. Use the five-point finite difference approximation of the Laplacian in the interior of $\\Omega_f$. For edges where a neighbor lies across the embedded boundary $\\Gamma$, apply a Ghost Fluid Method (GFM) treatment derived from linear interpolation to the interface intersection along the grid link. The Ghost Fluid Method (GFM) is an interface method that uses ghost values extrapolated from the physical side to enforce boundary/interface conditions. Specifically, if $(x_i,y_j)$ is a fluid node and its neighbor $(x_{i\\pm1},y_j)$ or $(x_i,y_{j\\pm1})$ lies in $K$, define $\\alpha \\in (0,1]$ as the fraction (measured from the fluid node toward the neighbor along the grid segment) at which the segment intersects $\\Gamma$, and denote by $g^\\star$ the Dirichlet value $g$ evaluated at the intersection point. Enforce the discrete flux across that cut face by replacing the standard neighbor difference term with\n$$\n\\frac{u_g - u_{i,j}}{h^2} = \\frac{g^\\star - u_{i,j}}{\\alpha h^2},\n$$\nwhich follows from requiring linear variation between the fluid node value and a ghost value $u_g$ such that the interpolated value at the interface equals $g^\\star$. This yields the diagonal contribution $1/(\\alpha h^2)$ and right-hand side contribution $g^\\star/(\\alpha h^2)$ for the cut link. For uncut links to fluid neighbors, use the standard $1/h^2$ stencil coupling. For links to nodes on $\\partial \\Omega$ or to grid nodes that lie exactly on $\\Gamma$, treat those neighbors as Dirichlet with known values. To robustly handle corner singularities where $\\Gamma$ passes through a grid node or intersects grid lines to create multi-cut cells, implement the following rules:\n- If a grid node lies on $\\Gamma$ (within a geometric tolerance proportional to $h$), treat it as a Dirichlet node with value $u^\\star$ at that node.\n- If a cell has multiple cut faces, simply sum the cut-face contributions; this corresponds to a multi-constraint treatment that is equivalent to a least-squares enforcement of the interface condition along each intersected face when the local variation is taken as linear.\n- To avoid small-cell ill-conditioning when $\\alpha$ is extremely small but nonzero, clamp $\\alpha$ below by a small threshold proportional to $h$-independent machine tolerance (e.g., $\\alpha_{\\min} = 10^{-3}$), which is a form of flux redistribution regularization; if $\\alpha$ is exactly zero at a node, the node is flagged as lying on $\\Gamma$ and is treated as Dirichlet.\n\nAssemble the sparse linear system for the unknowns at fluid grid nodes that are not on $\\Gamma$ and not on $\\partial \\Omega$, and solve it. Compute the discrete $\\ell^2$ error norm over all fluid nodes (including Dirichlet nodes on $\\Gamma$ by taking their prescribed values) as\n$$\nE_{L^2} = \\left( h^2 \\sum_{(i,j)\\in \\mathcal{F}} \\left(u_{i,j}^{\\text{num}} - u^\\star(x_i,y_j)\\right)^2 \\right)^{1/2},\n$$\nwhere $\\mathcal{F}$ is the set of all fluid grid nodes (interior unknowns and fluid Dirichlet nodes on $\\Gamma$ and on $\\partial \\Omega$).\n\nYour task is to implement a complete program that:\n- Constructs three convex polygonal embedded boundaries (each $\\Gamma$ is specified by an ordered list of vertices) that induce corner singularities and multi-cut cells relative to the grid:\n  1. A diamond with vertices $(0.2,0.5)$, $(0.5,0.2)$, $(0.8,0.5)$, $(0.5,0.8)$ on a grid with $N=40$.\n  2. The same diamond on a grid with $N=41$.\n  3. A shifted diamond with vertices $(0.2,0.52)$, $(0.52,0.2)$, $(0.8,0.48)$, $(0.48,0.8)$ on a grid with $N=64$.\n- For each case, assembles and solves the linear system using the GFM treatment described above, with robust handling of corner singularities as specified.\n- Computes $E_{L^2}$ for each case.\n\nThe final output must be a single line containing a Python list of the three error values in this order, formatted as real numbers. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\").\n\nUse only dimensionless quantities. All angles, if any appear in your code or reasoning, should be treated in radians. The test suite is the three cases above, and each answer must be a real number (floating-point). No user input is required; all parameters are hard-coded in the program. The program must be a complete, runnable script in the specified environment.", "solution": "This problem requires the implementation of a finite difference solver for the Poisson equation on a Cartesian grid with a complex, embedded polygonal boundary. The solution follows a multi-step process detailed below, which is directly implemented in the provided Python code.\n\n**1. Geometric Classification of Grid Nodes**\n\nThe first crucial step is to classify every grid node $(x_i, y_j)$ based on its location relative to the embedded polygon $\\Gamma$ and the outer domain boundary $\\partial\\Omega$. Each node is assigned one of four types:\n- `NODE_BOUNDARY`: A node on the outer boundary of the unit square. The solution value is known (Dirichlet, $u=0$).\n- `NODE_GAMMA`: A node that lies directly on the polygonal boundary $\\Gamma$, determined by checking if the point-to-segment distance is within a small tolerance. The solution value is known (Dirichlet, $u = g(x_i, y_j)$).\n- `NODE_SOLID`: A node inside the polygon $\\Gamma$ but not on its boundary. These nodes are not part of the computational domain. A point-in-convex-polygon test (checking if the point is on the same side of all polygon edges) is used for this classification.\n- `NODE_FLUID`: A node that is neither on any boundary nor inside the solid region. The solution values at these nodes are the unknowns to be solved for.\n\n**2. Assembling the Linear System**\n\nA sparse linear system, $A\\mathbf{u}=\\mathbf{b}$, is constructed for the unknown values at the `NODE_FLUID` locations. The program iterates through each fluid node to build one row of the system, based on the five-point finite difference stencil for the negative Laplacian: $-\\Delta u \\approx \\frac{4u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}}{h^2} = f_{i,j}$.\n\nFor each fluid node $(i,j)$, its four neighbors are examined:\n- **If a neighbor is a `FLUID` node**: A standard finite difference coupling is used. A contribution of $1/h^2$ is added to the diagonal entry of matrix $A$ corresponding to node $(i,j)$, and an off-diagonal entry of $-1/h^2$ is created for the connection to the neighbor.\n- **If a neighbor is a `BOUNDARY` or `GAMMA` node**: The neighbor's value is known from the Dirichlet conditions. A contribution of $1/h^2$ is added to the diagonal, and the known value is moved to the right-hand side vector $\\mathbf{b}$. For a neighbor with value $u_{\\text{known}}$, this adds $u_{\\text{known}}/h^2$ to the RHS element for node $(i,j)$.\n- **If a neighbor is a `SOLID` node**: This indicates a \"cut link\" that must be handled by the Ghost Fluid Method. The code first computes the intersection point of the grid line segment connecting the fluid and solid nodes with the polygon $\\Gamma$. This yields the fractional distance $\\alpha$ from the fluid node to the interface and the intersection point coordinates. The value of the solution at the interface, $g^\\star$, is evaluated using the manufactured solution. As specified, a contribution of $1/(\\alpha h^2)$ is added to the diagonal of $A$, and $g^\\star/(\\alpha h^2)$ is added to the RHS vector $\\mathbf{b}$. The value of $\\alpha$ is clamped below by $\\alpha_{\\min}=10^{-3}$ to prevent ill-conditioning.\n\nThe source term $f(x_i, y_j)$ is also added to the RHS for each fluid node.\n\n**3. Solving and Error Computation**\n\nAfter assembling the sparse matrix $A$ and the RHS vector $\\mathbf{b}$, the system is solved using a sparse direct solver (`scipy.sparse.linalg.spsolve`) to find the vector of unknown values $\\mathbf{u}$.\n\nFinally, the discrete $\\ell^2$ error is computed. The code sums the squared differences between the numerical solution $u_{i,j}^{\\text{num}}$ and the exact manufactured solution $u^\\star(x_i,y_j)$ over all fluid nodes. The sum is then multiplied by the area element $h^2$, and the square root is taken, yielding the final error $E_{L^2}$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\n# Suppress potential harmless floating point warnings in geometry calculations.\nnp.seterr(divide='ignore', invalid='ignore')\n\ndef u_star(x, y):\n    \"\"\"\n    The exact manufactured solution u*(x,y).\n    \"\"\"\n    return np.sin(math.pi * x) * np.sin(math.pi * y)\n\ndef f_source(x, y):\n    \"\"\"\n    The corresponding source term f = -Delta u*.\n    \"\"\"\n    return 2 * math.pi**2 * np.sin(math.pi * x) * np.sin(math.pi * y)\n\ndef get_polygon_orientation(poly):\n    \"\"\"\n    Determines if polygon vertices are ordered CW or CCW using the shoelace formula.\n    Returns \"ccw\" for counter-clockwise, \"cw\" for clockwise.\n    \"\"\"\n    area = 0.0\n    for i in range(len(poly)):\n        p1 = poly[i]\n        p2 = poly[(i + 1) % len(poly)]\n        area += (p1[0] * p2[1]) - (p2[0] * p1[1])\n    return \"ccw\" if area > 0 else \"cw\"\n\ndef is_inside_convex(p, ccw_poly, tol=1e-12):\n    \"\"\"\n    Checks if a point p is inside a convex polygon with CCW vertices.\n    A point is inside if it is to the left of all directed edges.\n    \"\"\"\n    for i in range(len(ccw_poly)):\n        p1 = ccw_poly[i]\n        p2 = ccw_poly[(i + 1) % len(ccw_poly)]\n        cross_product = (p2[0] - p1[0]) * (p[1] - p1[1]) - (p2[1] - p1[1]) * (p[0] - p1[0])\n        if cross_product  -tol:\n            return False\n    return True\n\ndef dist_point_to_line_segment(p, a, b):\n    \"\"\"\n    Calculates the shortest distance from a point p to a line segment ab.\n    \"\"\"\n    px, py = p[0] - a[0], p[1] - a[1]\n    bx, by = b[0] - a[0], b[1] - a[1]\n    \n    len_sq_b = bx * bx + by * by\n    if len_sq_b == 0:\n        return np.sqrt(px * px + py * py)\n\n    t = (px * bx + py * by) / len_sq_b\n    \n    if t  0:\n        return np.sqrt((p[0] - a[0])**2 + (p[1] - a[1])**2)\n    elif t > 1:\n        return np.sqrt((p[0] - b[0])**2 + (p[1] - b[1])**2)\n    \n    closest_x, closest_y = a[0] + t * bx, a[1] + t * by\n    return np.sqrt((p[0] - closest_x)**2 + (p[1] - closest_y)**2)\n\ndef is_on_gamma(p, poly, tol=1e-9):\n    \"\"\"\n    Checks if a point p lies on the polygonal boundary Gamma.\n    \"\"\"\n    for i in range(len(poly)):\n        p1 = poly[i]\n        p2 = poly[(i + 1) % len(poly)]\n        if dist_point_to_line_segment(p, p1, p2)  tol:\n            return True\n    return False\n\ndef find_intersection(p_fluid, p_solid, ccw_poly):\n    \"\"\"\n    Finds the unique intersection of a line segment (from an exterior fluid point\n    to an interior solid point) with a convex polygon.\n    Returns the intersection point and the fractional distance alpha from the fluid point.\n    \"\"\"\n    x1, y1 = p_fluid\n    x2, y2 = p_solid\n    \n    min_alpha = float('inf')\n    intersect_pt = None\n\n    for i in range(len(ccw_poly)):\n        x3, y3 = ccw_poly[i]\n        x4, y4 = ccw_poly[(i + 1) % len(ccw_poly)]\n        \n        den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n        if abs(den)  1e-12: continue\n            \n        t_num = (x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)\n        u_num = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3))\n        \n        t = t_num / den\n        u = u_num / den\n        \n        if 0  t = 1 and 0 = u = 1:\n            if t  min_alpha:\n                min_alpha = t\n                intersect_pt = (x1 + t * (x2 - x1), y1 + t * (y2 - y1))\n    \n    if intersect_pt is None:\n        raise RuntimeError(f\"No intersection found for segment {p_fluid} to {p_solid}. This indicates a logic or floating point issue.\")\n\n    return intersect_pt, min_alpha\n\ndef solve_poisson_gfm(N, poly_verts):\n    \"\"\"\n    Assembles and solves the Poisson problem for a given grid size N and polygon.\n    \"\"\"\n    h = 1.0 / N\n    alpha_min = 1e-3\n\n    if get_polygon_orientation(poly_verts) == \"cw\":\n        poly_verts_ccw = poly_verts[::-1]\n    else:\n        poly_verts_ccw = poly_verts\n\n    NODE_FLUID, NODE_SOLID, NODE_BOUNDARY, NODE_GAMMA = 0, 1, 2, 3\n    node_type = np.full((N + 1, N + 1), NODE_FLUID, dtype=int)\n    coords = np.linspace(0, 1, N + 1)\n    \n    for i in range(N + 1):\n        for j in range(N + 1):\n            p = (coords[i], coords[j])\n            if i == 0 or i == N or j == 0 or j == N:\n                node_type[i, j] = NODE_BOUNDARY\n            elif is_on_gamma(p, poly_verts_ccw, tol=h*1e-6): # Using h-dependent tolerance\n                node_type[i, j] = NODE_GAMMA\n            elif is_inside_convex(p, poly_verts_ccw):\n                node_type[i, j] = NODE_SOLID\n\n    fluid_nodes_ij = np.argwhere(node_type == NODE_FLUID)\n    num_unknowns = len(fluid_nodes_ij)\n    ij_to_k = {tuple(ij): k for k, ij in enumerate(fluid_nodes_ij)}\n\n    A = lil_matrix((num_unknowns, num_unknowns), dtype=float)\n    b = np.zeros(num_unknowns, dtype=float)\n    inv_h2 = 1.0 / (h * h)\n    \n    for k, (i, j) in enumerate(fluid_nodes_ij):\n        x, y = coords[i], coords[j]\n        b[k] = f_source(x, y)\n        diag_val = 0.0\n        \n        neighbors = [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]\n        \n        for ni, nj in neighbors:\n            ntype = node_type[ni, nj]\n            \n            if ntype == NODE_FLUID:\n                diag_val += inv_h2\n                A[k, ij_to_k[(ni, nj)]] = -inv_h2\n            elif ntype == NODE_BOUNDARY:\n                diag_val += inv_h2\n                # RHS contribution is 0 since u=0 on boundary\n            elif ntype == NODE_GAMMA:\n                diag_val += inv_h2\n                nx, ny = coords[ni], coords[nj]\n                g_val = u_star(nx, ny)\n                b[k] += g_val * inv_h2\n            elif ntype == NODE_SOLID:\n                p_star, alpha = find_intersection((x, y), (coords[ni], coords[nj]), poly_verts_ccw)\n                alpha_clamped = max(alpha, alpha_min)\n                g_star = u_star(p_star[0], p_star[1])\n                \n                contrib_diag = 1.0 / (alpha_clamped * h * h)\n                contrib_rhs = g_star / (alpha_clamped * h * h)\n                \n                diag_val += contrib_diag\n                b[k] += contrib_rhs\n        A[k, k] = diag_val\n\n    u_sol = spsolve(A.tocsr(), b)\n\n    total_error_sq = 0.0\n    for k, (i, j) in enumerate(fluid_nodes_ij):\n        x, y = coords[i], coords[j]\n        error = u_sol[k] - u_star(x, y)\n        total_error_sq += error * error\n    \n    # The sum for the error norm is over all fluid nodes, which includes those on Gamma or the boundary\n    # whose contribution to the error sum is 0. So summing over the computed nodes is sufficient.\n    l2_error = np.sqrt((h * h) * total_error_sq)\n    return l2_error\n\ndef solve():\n    \"\"\"\n    Main entry point to run all test cases and print results in the specified format.\n    \"\"\"\n    test_cases = [\n        {\"N\": 40, \"poly\": [(0.2, 0.5), (0.5, 0.2), (0.8, 0.5), (0.5, 0.8)]},\n        {\"N\": 41, \"poly\": [(0.2, 0.5), (0.5, 0.2), (0.8, 0.5), (0.5, 0.8)]},\n        {\"N\": 64, \"poly\": [(0.2, 0.52), (0.52, 0.2), (0.8, 0.48), (0.48, 0.8)]},\n    ]\n\n    results = []\n    for case in test_cases:\n        error = solve_poisson_gfm(case[\"N\"], case[\"poly\"])\n        results.append(error)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3376303"}]}