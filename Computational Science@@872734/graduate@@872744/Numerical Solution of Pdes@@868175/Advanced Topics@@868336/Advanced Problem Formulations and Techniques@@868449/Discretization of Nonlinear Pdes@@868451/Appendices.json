{"hands_on_practices": [{"introduction": "The $p$-Laplacian equation serves as a fundamental model for nonlinear diffusion phenomena, appearing in fields like non-Newtonian fluid dynamics and image processing. Solving it numerically requires moving beyond the linear solvers used for the standard Laplacian, typically involving iterative methods like Newton's method. This exercise [@problem_id:3380993] provides a crucial hands-on experience in this process, guiding you through the derivation of the Jacobian matrix for the Finite Element discretization and tackling the practical issue of degeneracy with a regularization strategy.", "problem": "Consider the nonlinear Partial Differential Equation (PDE) $-\\nabla \\cdot \\left(|\\nabla u|^{p-2}\\nabla u\\right) = f$ in a bounded polygonal domain $\\Omega \\subset \\mathbb{R}^{2}$ with homogeneous Dirichlet boundary condition $u=0$ on $\\partial \\Omega$. Let $V := H_{0}^{1}(\\Omega)$ and recall the weak formulation: find $u \\in V$ such that $\\int_{\\Omega}|\\nabla u|^{p-2}\\nabla u \\cdot \\nabla v \\, \\mathrm{d}x = \\int_{\\Omega} f v \\, \\mathrm{d}x$ for all $v \\in V$. Use the standard continuous, piecewise-linear Finite Element Method (FEM) on a conforming triangulation of $\\Omega$, and denote by $\\{\\varphi_{i}\\}$ the global nodal basis.\n\nTasks:\n1) Starting from the weak form and the definition of the Galerkin residual $R(u_{h}) \\in \\mathbb{R}^{N}$ with components $R_{i}(u_{h}) := \\int_{\\Omega}|\\nabla u_{h}|^{p-2}\\nabla u_{h}\\cdot \\nabla \\varphi_{i}\\,\\mathrm{d}x - \\int_{\\Omega} f \\varphi_{i} \\,\\mathrm{d}x$, derive the Newton system $J(u_{h}^{(k)})\\,\\delta u^{(k)} = -R(u_{h}^{(k)})$ by computing the Gâteaux derivative of the residual in the direction of an increment $w_{h}$. Express the Jacobian entries $J_{ij}(u_{h}^{(k)})$ in terms of element-wise integrals involving $\\nabla \\varphi_{i}$, $\\nabla \\varphi_{j}$, and $\\nabla u_{h}^{(k)}$ only, using only fundamental differentiation rules (chain rule and product rule) and the definition of the Gâteaux derivative.\n2) Propose a regularization strategy to handle degeneracy at $|\\nabla u|=0$, and justify it from first principles by ensuring differentiability of the nonlinear flux mapping in the direction of arbitrary test functions.\n3) On the single triangular element $T$ with vertices $(0,0)$, $(1,0)$, $(0,1)$, consider the local piecewise-linear basis functions $\\{\\phi_{1},\\phi_{2},\\phi_{3}\\}$ associated with these vertices, and consider one Newton iteration for the case $p=3$ and regularization parameter $\\varepsilon = 10^{-3}$. Let the current iterate’s nodal values on $T$ be $u_{1}^{(k)} = 0.3$, $u_{2}^{(k)} = 1.2$, $u_{3}^{(k)} = -0.4$. Using your derived regularized Jacobian, compute the single local Jacobian entry $J_{23}^{(T)}(u_{h}^{(k)})$ and return its numerical value. Round your answer to four significant figures. No units are required. The final response must be only this number.", "solution": "The problem is divided into three tasks: 1) deriving the Jacobian for the Newton method, 2) proposing a regularization for the resulting system, and 3) computing a specific entry of the local regularized Jacobian matrix.\n\n**Part 1: Derivation of the Jacobian Matrix**\n\nThe problem concerns the numerical solution of the $p$-Laplacian equation $-\\nabla \\cdot (|\\nabla u|^{p-2}\\nabla u) = f$ using the Finite Element Method (FEM). The discrete solution $u_h = \\sum_{j=1}^{N} c_j \\varphi_j$ is found by solving the nonlinear system of equations $R(u_h) = 0$, where the residual vector $R(u_h) \\in \\mathbb{R}^{N}$ has components\n$$R_i(u_h) := \\int_{\\Omega}|\\nabla u_h|^{p-2}\\nabla u_h \\cdot \\nabla \\varphi_i\\,\\mathrm{d}x - \\int_{\\Omega} f \\varphi_i \\,\\mathrm{d}x = 0$$\nfor $i=1, \\dots, N$. Here, $\\{\\varphi_i\\}$ is the global nodal basis for the space of continuous piecewise-linear functions $V_h \\subset H_0^1(\\Omega)$, and $\\{c_j\\}$ are the nodal values of $u_h$.\n\nNewton's method is used to solve this system. Given an iterate $u_h^{(k)}$, the next iterate is $u_h^{(k+1)} = u_h^{(k)} + \\delta u_h^{(k)}$, where the update $\\delta u_h^{(k)}$ is the solution to the linear system $J(u_h^{(k)}) \\delta u_h^{(k)} = -R(u_h^{(k)})$. The matrix $J(u_h^{(k)})$ is the Jacobian of the residual $R$ evaluated at $u_h^{(k)}$.\n\nThe entries of the Jacobian, $J_{ij}$, are given by the Gâteaux derivative of the $i$-th component of the residual, $R_i$, with respect to $u_h$ in the direction of the basis function $\\varphi_j$. The Gâteaux derivative of a functional $F(u)$ at $u$ in the direction $w$ is defined as\n$$DF(u)[w] = \\lim_{t\\to 0} \\frac{F(u+tw) - F(u)}{t}$$\nLet's denote the nonlinear operator in the residual as $\\mathbf{A}(\\mathbf{q}) = |\\mathbf{q}|^{p-2}\\mathbf{q}$. The residual is $R_i(u_h) = \\int_{\\Omega} \\mathbf{A}(\\nabla u_h) \\cdot \\nabla \\varphi_i \\,\\mathrm{d}x - \\text{constant}$. The Jacobian entry $J_{ij}(u_h)$ is the Gâteaux derivative of $R_i(u_h)$ in the direction $\\varphi_j$:\n$$J_{ij}(u_h) = DR_i(u_h)[\\varphi_j] = \\lim_{t\\to 0} \\frac{1}{t} \\left( \\int_{\\Omega} \\mathbf{A}(\\nabla u_h + t\\nabla\\varphi_j) \\cdot \\nabla\\varphi_i \\,\\mathrm{d}x - \\int_{\\Omega} \\mathbf{A}(\\nabla u_h) \\cdot \\nabla\\varphi_i \\,\\mathrm{d}x \\right)$$\nAssuming sufficient regularity to interchange the limit and integral, we have\n$$J_{ij}(u_h) = \\int_{\\Omega} \\left( \\lim_{t\\to 0} \\frac{\\mathbf{A}(\\nabla u_h + t\\nabla\\varphi_j) - \\mathbf{A}(\\nabla u_h)}{t} \\right) \\cdot \\nabla\\varphi_i \\,\\mathrm{d}x$$\nThe term in the limit is the Gâteaux derivative of $\\mathbf{A}(\\mathbf{q})$ at $\\mathbf{q}=\\nabla u_h$ in the direction $\\delta\\mathbf{q} = \\nabla\\varphi_j$. Let's compute this derivative, $D\\mathbf{A}(\\mathbf{q})[\\delta\\mathbf{q}]$. We use the product rule for differentiation on $\\mathbf{A}(\\mathbf{q}) = (|\\mathbf{q}|^2)^{\\frac{p-2}{2}}\\mathbf{q}$:\n$$D\\mathbf{A}(\\mathbf{q})[\\delta\\mathbf{q}] = D\\left((|\\mathbf{q}|^2)^{\\frac{p-2}{2}}\\right)[\\delta\\mathbf{q}] \\, \\mathbf{q} + (|\\mathbf{q}|^2)^{\\frac{p-2}{2}} D(\\mathbf{q})[\\delta\\mathbf{q}]$$\nThe derivative of $|\\mathbf{q}|^2 = \\mathbf{q} \\cdot \\mathbf{q}$ is $2\\mathbf{q}\\cdot\\delta\\mathbf{q}$. Using the chain rule:\n$$D\\left((|\\mathbf{q}|^2)^{\\frac{p-2}{2}}\\right)[\\delta\\mathbf{q}] = \\frac{p-2}{2}(|\\mathbf{q}|^2)^{\\frac{p-4}{2}}(2\\mathbf{q}\\cdot\\delta\\mathbf{q}) = (p-2)|\\mathbf{q}|^{p-4}(\\mathbf{q}\\cdot\\delta\\mathbf{q})$$\nThe derivative of $\\mathbf{q}$ is simply $\\delta\\mathbf{q}$. Combining these, we get:\n$$D\\mathbf{A}(\\mathbf{q})[\\delta\\mathbf{q}] = (p-2)|\\mathbf{q}|^{p-4}(\\mathbf{q}\\cdot\\delta\\mathbf{q})\\mathbf{q} + |\\mathbf{q}|^{p-2}\\delta\\mathbf{q}$$\nSubstituting this back into the integral for $J_{ij}(u_h)$ with $\\mathbf{q}=\\nabla u_h^{(k)}$ and $\\delta\\mathbf{q}=\\nabla\\varphi_j$:\n$$J_{ij}(u_h^{(k)}) = \\int_{\\Omega} \\left( (p-2)|\\nabla u_h^{(k)}|^{p-4}(\\nabla u_h^{(k)}\\cdot\\nabla\\varphi_j)\\nabla u_h^{(k)} + |\\nabla u_h^{(k)}|^{p-2}\\nabla\\varphi_j \\right) \\cdot \\nabla\\varphi_i \\,\\mathrm{d}x$$\nDistributing the dot product with $\\nabla \\varphi_i$ yields the final expression for the Jacobian entries:\n$$J_{ij}(u_h^{(k)}) = \\int_{\\Omega} \\left( |\\nabla u_h^{(k)}|^{p-2}(\\nabla\\varphi_i \\cdot \\nabla\\varphi_j) + (p-2)|\\nabla u_h^{(k)}|^{p-4}(\\nabla u_h^{(k)}\\cdot\\nabla\\varphi_i)(\\nabla u_h^{(k)}\\cdot\\nabla\\varphi_j) \\right)\\mathrm{d}x$$\nSince $u_h^{(k)}$ is piecewise-linear, $\\nabla u_h^{(k)}$ is constant on each element $T$ of the triangulation. The global Jacobian is an assembly of element Jacobians, $J = \\sum_{T} J^{(T)}$, where\n$$J_{ij}^{(T)}(u_h^{(k)}) = \\int_{T} \\left( |\\nabla u_h^{(k)}|^{p-2}(\\nabla\\varphi_i \\cdot \\nabla\\varphi_j) + (p-2)|\\nabla u_h^{(k)}|^{p-4}(\\nabla u_h^{(k)}\\cdot\\nabla\\varphi_i)(\\nabla u_h^{(k)}\\cdot\\nabla\\varphi_j) \\right)\\mathrm{d}x$$\nAs the integrand is constant on $T$, this simplifies to the integrand multiplied by the area of the element, $\\text{Area}(T)$.\n\n**Part 2: Regularization Strategy**\n\nThe derived Jacobian entries contain the terms $|\\nabla u_h^{(k)}|^{p-2}$ and $|\\nabla u_h^{(k)}|^{p-4}$. If $p4$, the term $|\\nabla u_h^{(k)}|^{p-4}$ is singular at points where $\\nabla u_h^{(k)} = \\mathbf{0}$. This degeneracy poses a problem for the Newton method, as the Jacobian may not be well-defined.\n\nA standard method to address this is to introduce a regularization parameter $\\varepsilon  0$. The non-differentiable term $|\\mathbf{q}|$ is replaced by a smooth approximation $\\sqrt{|\\mathbf{q}|^2 + \\varepsilon^2}$. The nonlinear flux operator $\\mathbf{A}(\\mathbf{q})$ is replaced by a regularized version $\\mathbf{A}_\\varepsilon(\\mathbf{q})$:\n$$\\mathbf{A}_\\varepsilon(\\mathbf{q}) = (|\\mathbf{q}|^2 + \\varepsilon^2)^{\\frac{p-2}{2}} \\mathbf{q}$$\nThis function is differentiable for any $\\mathbf{q} \\in \\mathbb{R}^2$ as long as $\\varepsilon  0$. The regularized weak formulation seeks $u_h \\in V_h$ such that for all $v_h \\in V_h$:\n$$\\int_{\\Omega} (|\\nabla u_h|^2 + \\varepsilon^2)^{\\frac{p-2}{2}}\\nabla u_h \\cdot \\nabla v_h \\,\\mathrm{d}x = \\int_{\\Omega} f v_h \\,\\mathrm{d}x$$\nThe derivation of the Jacobian for the regularized problem follows the same steps as in Part 1, replacing $|\\mathbf{q}|^2$ with $|\\mathbf{q}|^2+\\varepsilon^2$. The Gâteaux derivative of $\\mathbf{A}_\\varepsilon$ is:\n$$D\\mathbf{A}_\\varepsilon(\\mathbf{q})[\\delta\\mathbf{q}] = (p-2)(|\\mathbf{q}|^2+\\varepsilon^2)^{\\frac{p-4}{2}}(\\mathbf{q}\\cdot\\delta\\mathbf{q})\\mathbf{q} + (|\\mathbf{q}|^2+\\varepsilon^2)^{\\frac{p-2}{2}}\\delta\\mathbf{q}$$\nThe regularized Jacobian entries $J_{ij, \\varepsilon}$ are therefore given by:\n$$J_{ij, \\varepsilon}(u_h) = \\int_{\\Omega} \\left( (|\\nabla u_h|^2+\\varepsilon^2)^{\\frac{p-2}{2}}(\\nabla\\varphi_i \\cdot \\nabla\\varphi_j) + (p-2)(|\\nabla u_h|^2+\\varepsilon^2)^{\\frac{p-4}{2}}(\\nabla u_h\\cdot\\nabla\\varphi_i)(\\nabla u_h\\cdot\\nabla\\varphi_j) \\right)\\mathrm{d}x$$\nFor any $\\varepsilon  0$, the terms in the integrand are well-defined for all $\\nabla u_h$, resolving the degeneracy.\n\n**Part 3: Numerical Computation of a Jacobian Entry**\n\nWe are asked to compute the local Jacobian entry $J_{23}^{(T)}$ on a specific triangular element $T$ with vertices $V_1=(0,0)$, $V_2=(1,0)$, and $V_3=(0,1)$.\nThe area of this triangle is $\\text{Area}(T) = \\frac{1}{2}|(1-0)(1-0) - (0-0)(0-0)| = \\frac{1}{2}$.\nThe local linear basis functions $\\{\\phi_i\\}_{i=1}^3$ are defined by $\\phi_i(V_j) = \\delta_{ij}$. They are:\n$\\phi_1(x,y) = 1-x-y \\implies \\nabla\\phi_1 = \\begin{pmatrix} -1 \\\\ -1 \\end{pmatrix}$\n$\\phi_2(x,y) = x \\quad \\quad \\implies \\nabla\\phi_2 = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$\n$\\phi_3(x,y) = y \\quad \\quad \\implies \\nabla\\phi_3 = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}$\n\nThe current iterate $u_h^{(k)}$ on $T$ is given by its nodal values: $u_1^{(k)} = 0.3$, $u_2^{(k)} = 1.2$, $u_3^{(k)} = -0.4$.\nThe gradient $\\nabla u_h^{(k)}$ is constant on $T$:\n$$\\nabla u_h^{(k)}|_T = u_1^{(k)}\\nabla\\phi_1 + u_2^{(k)}\\nabla\\phi_2 + u_3^{(k)}\\nabla\\phi_3 = 0.3\\begin{pmatrix} -1 \\\\ -1 \\end{pmatrix} + 1.2\\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} - 0.4\\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} -0.3+1.2 \\\\ -0.3-0.4 \\end{pmatrix} = \\begin{pmatrix} 0.9 \\\\ -0.7 \\end{pmatrix}$$\nLet $\\mathbf{g} = \\nabla u_h^{(k)}|_T$. We compute its squared magnitude: $|\\mathbf{g}|^2 = (0.9)^2 + (-0.7)^2 = 0.81 + 0.49 = 1.3$.\n\nWe need to compute $J_{23}^{(T)}(u_h^{(k)})$ for $p=3$ and $\\varepsilon = 10^{-3}$. The element-wise formula for the regularized Jacobian is:\n$$J_{ij, \\varepsilon}^{(T)}(u_h) = \\text{Area}(T) \\left( (|\\nabla u_h|^2+\\varepsilon^2)^{\\frac{p-2}{2}}(\\nabla\\phi_i \\cdot \\nabla\\phi_j) + (p-2)(|\\nabla u_h|^2+\\varepsilon^2)^{\\frac{p-4}{2}}(\\nabla u_h\\cdot\\nabla\\phi_i)(\\nabla u_h\\cdot\\nabla\\phi_j) \\right)$$\nFor $i=2, j=3, p=3$:\n$$J_{23, \\varepsilon}^{(T)}(u_h^{(k)}) = \\text{Area}(T) \\left( (|\\mathbf{g}|^2+\\varepsilon^2)^{\\frac{1}{2}}(\\nabla\\phi_2 \\cdot \\nabla\\phi_3) + (1)(|\\mathbf{g}|^2+\\varepsilon^2)^{-\\frac{1}{2}}(\\mathbf{g}\\cdot\\nabla\\phi_2)(\\mathbf{g}\\cdot\\nabla\\phi_3) \\right)$$\nWe compute the necessary dot products:\n$\\nabla\\phi_2 \\cdot \\nabla\\phi_3 = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} \\cdot \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = 0$.\n$\\mathbf{g}\\cdot\\nabla\\phi_2 = \\begin{pmatrix} 0.9 \\\\ -0.7 \\end{pmatrix} \\cdot \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = 0.9$.\n$\\mathbf{g}\\cdot\\nabla\\phi_3 = \\begin{pmatrix} 0.9 \\\\ -0.7 \\end{pmatrix} \\cdot \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = -0.7$.\nAlso, we have $|\\mathbf{g}|^2=1.3$ and $\\varepsilon^2 = (10^{-3})^2 = 10^{-6}$. So, $|\\mathbf{g}|^2 + \\varepsilon^2 = 1.300001$.\n\nSubstituting these values into the formula:\n$$J_{23, \\varepsilon}^{(T)} = 0.5 \\left( (1.300001)^{\\frac{1}{2}}(0) + (1.300001)^{-\\frac{1}{2}}(0.9)(-0.7) \\right)$$\n$$J_{23, \\varepsilon}^{(T)} = 0.5 \\left( \\frac{-0.63}{\\sqrt{1.300001}} \\right) = \\frac{-0.315}{\\sqrt{1.300001}}$$\nNow, we compute the numerical value:\n$$J_{23, \\varepsilon}^{(T)} \\approx \\frac{-0.315}{1.14017586} \\approx -0.27626900$$\nRounding to four significant figures, we get $-0.2763$.", "answer": "$$\\boxed{-0.2763}$$", "id": "3380993"}, {"introduction": "While Finite Element Methods are powerful, other discretization strategies like pseudo-spectral methods offer superior accuracy for certain problems, particularly those with smooth solutions on simple geometries. However, handling nonlinear terms in spectral methods introduces a unique challenge: aliasing error, which can corrupt the solution and lead to instability. This practice [@problem_id:3405943] allows you to explore this phenomenon directly by implementing and testing the classic \"Two-Thirds Rule,\" a de-aliasing technique essential for developing robust spectral codes for nonlinear PDEs like the Navier-Stokes equations.", "problem": "Consider a one-dimensional periodic domain with interval $[0,2\\pi]$ discretized by a uniform structured mesh of $N$ points. Let $x_n = \\frac{2\\pi n}{N}$ for integer $n \\in \\{0,1,\\dots,N-1\\}$. Define a real-valued field $u(x)$ by a finite Fourier series composed of sines and cosines with specified integer wavenumbers. The nonlinear term of interest is $g(x) = u(x)^2$. In pseudo-spectral methods, the nonlinear product $u(x)^2$ is evaluated pointwise in physical space, which, due to discrete sampling and truncated spectra, introduces aliasing into the resolved low modes. The Two-Thirds de-aliasing rule mitigates aliasing for quadratic nonlinearities by filtering out Fourier modes above a cutoff wavenumber before multiplication.\n\nThe fundamental base you must use is the Fourier series on a periodic domain and the Discrete Fourier Transform (DFT) definition. The DFT of a discrete periodic signal $f_n = f(x_n)$ is $\\hat{f}_m = \\sum_{n=0}^{N-1} f_n \\exp\\left(-\\frac{2\\pi i n m}{N}\\right)$, and its inverse $f_n = \\frac{1}{N} \\sum_{m=0}^{N-1} \\hat{f}_m \\exp\\left(\\frac{2\\pi i n m}{N}\\right)$. The convolution theorem states that the Fourier transform of a product is a convolution of the transforms, and discrete sampling with a finite number of points causes wrap-around (aliasing) of the convolution sums into the resolved spectral range. The Two-Thirds de-aliasing rule zeroes modes above $k_c = \\lfloor N/3 \\rfloor$ prior to evaluating the product, thereby eliminating aliasing for quadratic nonlinearities in the resolved range.\n\nYour task is to implement a program that, for each test case below, computes the relative error between:\n- An unfiltered pseudo-spectral evaluation of $u^2$ (naive pointwise multiplication at resolution $N$), and a reference low-mode projection of $u^2$ built from a high-resolution computation.\n- A filtered pseudo-spectral evaluation applying the Two-Thirds de-aliasing rule (zeroing modes with $|k|  \\lfloor N/3 \\rfloor$ prior to multiplication), and the same reference low-mode projection.\n\nFor the reference low-mode projection of $g(x) = u(x)^2$ at resolution $N$, use an oversampled grid of $N_{\\mathrm{ref}} = 8N$, evaluate $u(x)$ analytically, compute $g(x) = u(x)^2$, take its DFT $\\hat{g}_{\\mathrm{ref}}$, and project the low wavenumber content into the $N$-point spectrum by copying centered Fourier coefficients for $|k| \\leq N/2$ with appropriate scaling so that continuous Fourier coefficients are preserved (scale the copied coefficient by the ratio $N/N_{\\mathrm{ref}}$ to account for different DFT normalizations). Then invert to obtain the physical-space reference field $g_{\\mathrm{true}}(x_n)$ on the $N$-point grid.\n\nDefine the relative $\\ell^2$ error of a candidate field $g(x_n)$ against the reference $g_{\\mathrm{true}}(x_n)$ as\n$$\nE = \\frac{\\left( \\frac{1}{N} \\sum_{n=0}^{N-1} \\left| g(x_n) - g_{\\mathrm{true}}(x_n) \\right|^2 \\right)^{1/2}}{\\left( \\frac{1}{N} \\sum_{n=0}^{N-1} \\left| g_{\\mathrm{true}}(x_n) \\right|^2 \\right)^{1/2}}.\n$$\n\nImplement the Two-Thirds de-aliasing rule by:\n1. Computing the DFT $\\hat{u}$ of the $N$-point field $u(x_n)$.\n2. Zeroing centered Fourier coefficients with $|k|  \\lfloor N/3 \\rfloor$ to obtain $\\hat{u}_{\\mathrm{filtered}}$.\n3. Inverting to get $u_{\\mathrm{filtered}}(x_n)$, then forming $g_{\\mathrm{filtered}}(x_n) = u_{\\mathrm{filtered}}(x_n)^2$.\n4. Projecting $g_{\\mathrm{filtered}}$ to the $|k| \\leq N/2$ range (low modes of the $N$-point spectrum) before inverting back to the physical space for comparison.\n\nFor the unfiltered case, simply form $g_{\\mathrm{naive}}(x_n) = u(x_n)^2$ and project it to the $|k| \\leq N/2$ range of the $N$-point spectrum before inversion.\n\nTest Suite:\nFor each case, the domain is $[0,2\\pi]$ and angles are in radians. Define $u(x)$ as the sum of sines and cosines given below.\n\n- Case 1 (happy path, moderate $N$, mixed modes below Two-Thirds cutoff):\n  $N = 96$, $u(x) = 1.0 \\cos(30 x) + 0.5 \\sin(31 x) + 0.25 \\cos(2 x)$.\n- Case 2 (edge case, one mode near Nyquist, stronger aliasing potential):\n  $N = 48$, $u(x) = 1.0 \\cos(23 x) + 1.0 \\sin(16 x) + 0.3 \\cos(5 x)$.\n- Case 3 (composite high modes near cutoff plus a low mode):\n  $N = 64$, $u(x) = 0.8 \\sin(20 x) + 0.7 \\cos(21 x) - 0.6 \\sin(22 x) + 0.2 \\cos(3 x)$.\n- Case 4 (boundary case at exactly Two-Thirds cutoff):\n  $N = 60$, $u(x) = 1.0 \\sin(20 x) + 0.9 \\cos(19 x) + 0.5 \\sin(21 x)$.\n\nYour program must compute, for each case, the pair of relative $\\ell^2$ errors $(E_{\\mathrm{naive}}, E_{\\mathrm{filtered}})$ and aggregate them into a single output line. The final output format must be a single line containing a flat list of all errors in the following order:\n$[E_{\\mathrm{naive}}^{(1)},E_{\\mathrm{filtered}}^{(1)},E_{\\mathrm{naive}}^{(2)},E_{\\mathrm{filtered}}^{(2)},E_{\\mathrm{naive}}^{(3)},E_{\\mathrm{filtered}}^{(3)},E_{\\mathrm{naive}}^{(4)},E_{\\mathrm{filtered}}^{(4)}]$.\n\nThe final outputs are floats. No physical units apply.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,\\dots]$).", "solution": "The problem is assessed to be valid. It is scientifically grounded in the principles of numerical analysis for partial differential equations, specifically concerning aliasing errors in pseudo-spectral methods. The problem is well-posed, objective, and provides all necessary information to construct a unique, computable solution. The procedure is a standard numerical experiment to evaluate the effectiveness of the Two-Thirds de-aliasing rule.\n\nThe task is to compute the relative error of two different pseudo-spectral approximations of a quadratic nonlinearity, $g(x) = u(x)^2$, against a high-resolution reference solution. The domain is the one-dimensional periodic interval $[0, 2\\pi]$, discretized by a uniform grid of $N$ points, $x_n = \\frac{2\\pi n}{N}$ for $n \\in \\{0, 1, \\dots, N-1\\}$.\n\n### 1. Fourier Transform and Discretization\n\nThe problem is set in the context of Fourier spectral methods. The Discrete Fourier Transform (DFT) of a sequence $f_n$ of length $N$ is defined as:\n$$\n\\hat{f}_m = \\sum_{n=0}^{N-1} f_n \\exp\\left(-\\frac{2\\pi i n m}{N}\\right)\n$$\nThe corresponding inverse DFT (IDFT) is:\n$$\nf_n = \\frac{1}{N} \\sum_{m=0}^{N-1} \\hat{f}_m \\exp\\left(\\frac{2\\pi i n m}{N}\\right)\n$$\nThe integer $m$ represents the discrete wavenumber. For a real signal $f_n$, the wavenumbers are typically interpreted in the centered range, approximately from $-N/2$ to $N/2$. The highest representable wavenumber magnitude is the Nyquist wavenumber, $k_{\\mathrm{Nyquist}} = N/2$.\n\n### 2. Reference Solution: $g_{\\mathrm{true}}(x_n)$\n\nTo establish a ground truth for the low-wavenumber content of $g(x) = u(x)^2$, we use a high-resolution calculation to avoid aliasing.\n1.  An oversampled grid is created with $N_{\\mathrm{ref}} = 8N$ points, $x_j^{\\mathrm{ref}} = \\frac{2\\pi j}{N_{\\mathrm{ref}}}$. The Nyquist wavenumber for this grid is $4N$, which is sufficiently high to resolve all products of wavenumbers present in the test cases without aliasing.\n2.  The analytical function $u(x)$ is evaluated on this high-resolution grid to obtain $u_j^{\\mathrm{ref}} = u(x_j^{\\mathrm{ref}})$.\n3.  The quadratic nonlinearity is computed pointwise: $g_j^{\\mathrm{ref}} = (u_j^{\\mathrm{ref}})^2$.\n4.  The DFT of this high-resolution product is computed: $\\hat{g}_{\\mathrm{ref}} = \\text{DFT}(g^{\\mathrm{ref}})$.\n5.  The true low-wavenumber spectrum, $\\hat{g}_{\\mathrm{true}}$, is obtained by extracting the coefficients from $\\hat{g}_{\\mathrm{ref}}$ corresponding to the wavenumbers resolved by the $N$-point grid, i.e., $|k| \\leq N/2$. A scaling factor is applied to account for the different normalization of the DFT with grid size. The relation between a continuous Fourier coefficient $c_k$ and a discrete one $\\hat{f}_k$ is approximately $\\hat{f}_k \\approx M c_k$ for a grid of size $M$. Thus, to preserve the continuous coefficient when moving from a DFT on $N_{\\mathrm{ref}}$ points to one on $N$ points, we scale by the ratio of grid sizes:\n    $$\n    \\hat{g}_{\\mathrm{true}, k} = \\hat{g}_{\\mathrm{ref}, k} \\times \\frac{N}{N_{\\mathrm{ref}}}\n    $$\n    for wavenumbers $k$ in the range resolved by the $N$-point grid.\n6.  Finally, the physical-space reference solution on the low-resolution grid is obtained by applying the inverse DFT to the projected spectrum: $g_{\\mathrm{true}}(x_n) = \\text{IDFT}(\\hat{g}_{\\mathrm{true}})$.\n\n### 3. Naive Pseudo-Spectral Method: $g_{\\mathrm{naive}}(x_n)$\n\nThe simplest pseudo-spectral approach computes the nonlinearity directly in physical space.\n1.  The analytical function $u(x)$ is evaluated on the $N$-point grid: $u_n = u(x_n)$.\n2.  The product is computed pointwise: $g_{\\mathrm{naive}, n} = u_n^2$.\n\nThis method is computationally efficient but suffers from aliasing. When the spectrum of $u(x)$ contains wavenumbers up to $k_{\\mathrm{max}}$, the spectrum of $u(x)^2$ contains wavenumbers up to $2k_{\\mathrm{max}}$. If $2k_{\\mathrm{max}}  k_{\\mathrm{Nyquist}}$, the high-wavenumber components are \"folded\" back into the resolved range, corrupting the lower-wavenumber coefficients.\n\n### 4. Filtered Pseudo-Spectral Method (Two-Thirds Rule): $g_{\\mathrm{filtered}}(x_n)$\n\nThe Two-Thirds de-aliasing rule is designed to mitigate this aliasing error for quadratic nonlinearities. A filtered version of the field, $u_{\\mathrm{filtered}}$, is created by removing high-wavenumber content before the multiplication.\n1.  The field $u_n = u(x_n)$ is computed on the $N$-point grid.\n2.  Its DFT is taken: $\\hat{u} = \\text{DFT}(u)$.\n3.  A spectral filter is applied. All Fourier coefficients $\\hat{u}_k$ for which the wavenumber magnitude $|k|$ exceeds a cutoff $k_c = \\lfloor N/3 \\rfloor$ are set to zero. This creates a filtered spectrum $\\hat{u}_{\\mathrm{filtered}}$.\n    $$\n    \\hat{u}_{\\mathrm{filtered}, k} = \\begin{cases} \\hat{u}_k  \\text{if } |k| \\leq k_c \\\\ 0  \\text{if } |k|  k_c \\end{cases}\n    $$\n4.  The filtered spectrum is transformed back to physical space: $u_{\\mathrm{filtered}} = \\text{IDFT}(\\hat{u}_{\\mathrm{filtered}})$.\n5.  The nonlinearity is then computed using this filtered field: $g_{\\mathrm{filtered}, n} = (u_{\\mathrm{filtered}, n})^2$.\n\nBy filtering the input so that its maximum wavenumber is $k_c \\approx N/3$, the maximum wavenumber in the quadratic product becomes $2k_c \\approx 2N/3$. Any aliasing from these product modes will fall into the wavenumber range $|k|  k_c$, thus leaving the \"de-aliased\" range $|k| \\leq k_c$ uncontaminated.\n\n### 5. Error Calculation\n\nFor each method (naive and filtered), the relative $\\ell^2$ error is computed against the reference solution $g_{\\mathrm{true}}$. The error $E$ for a candidate solution $g$ is:\n$$\nE = \\frac{\\| g - g_{\\mathrm{true}} \\|_2}{\\| g_{\\mathrm{true}} \\|_2} = \\frac{\\left( \\sum_{n=0}^{N-1} \\left| g_n - g_{\\mathrm{true},n} \\right|^2 \\right)^{1/2}}{\\left( \\sum_{n=0}^{N-1} \\left| g_{\\mathrm{true},n} \\right|^2 \\right)^{1/2}}\n$$\nwhere the factor of $1/N$ in the problem's definition cancels. The algorithm proceeds by computing $(E_{\\mathrm{naive}}, E_{\\mathrm{filtered}})$ for each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef u_analytical(x, terms):\n    \"\"\"\n    Computes the analytical function u(x) given a list of its Fourier components.\n\n    Args:\n        x (np.ndarray): Array of points to evaluate the function at.\n        terms (list): A list of tuples, where each tuple is (amplitude, type, wavenumber).\n                      Type is 'sin' or 'cos'.\n\n    Returns:\n        np.ndarray: The values of u(x) at the given points.\n    \"\"\"\n    result = np.zeros_like(x, dtype=float)\n    for amp, f_type, k in terms:\n        if f_type == 'cos':\n            result += amp * np.cos(k * x)\n        elif f_type == 'sin':\n            result += amp * np.sin(k * x)\n    return result\n\ndef get_g_true(N, u_terms):\n    \"\"\"\n    Computes the reference solution g_true on an N-point grid using a\n    high-resolution intermediate calculation to avoid aliasing.\n    \"\"\"\n    N_ref = 8 * N\n    x_ref = np.linspace(0, 2 * np.pi, N_ref, endpoint=False)\n    \n    u_ref = u_analytical(x_ref, u_terms)\n    g_ref_physical = u_ref**2\n    \n    g_hat_ref = np.fft.fft(g_ref_physical)\n    \n    # Project the high-resolution spectrum onto the low-resolution grid\n    # by extracting the low-wavenumber modes.\n    g_hat_true = np.zeros(N, dtype=np.complex128)\n    \n    # For even N, fftfreq gives k = [0, 1, ..., N/2-1, -N/2, ..., -1]\n    # We copy the positive frequencies (and zero) and negative frequencies.\n    half_N = N // 2\n    \n    # Positive frequencies including k=0\n    g_hat_true[0:half_N] = g_hat_ref[0:half_N]\n    \n    # Nyquist and negative frequencies for np.fft convention\n    # The k=-1 mode in an N-point FFT is at index N-1.\n    g_hat_true[half_N:] = g_hat_ref[N_ref - half_N:]\n\n    # Scale coefficients to account for DFT normalization difference\n    g_hat_true *= (N / N_ref)\n    \n    g_true_physical = np.fft.ifft(g_hat_true)\n    \n    return g_true_physical.real\n\ndef calculate_errors(case):\n    \"\"\"\n    Calculates the naive and filtered errors for a single test case.\n    \"\"\"\n    N, u_terms = case\n    k_c = N // 3\n    \n    # 1. Setup low-resolution grid and evaluate u(x)\n    x = np.linspace(0, 2 * np.pi, N, endpoint=False)\n    u_on_grid = u_analytical(x, u_terms)\n    \n    # 2. Compute the high-resolution reference solution\n    g_true = get_g_true(N, u_terms)\n    norm_g_true = np.linalg.norm(g_true)\n    \n    # 3. Naive method\n    g_naive = u_on_grid**2\n    error_naive = np.linalg.norm(g_naive - g_true) / norm_g_true\n    \n    # 4. Filtered method (2/3 rule)\n    u_hat = np.fft.fft(u_on_grid)\n    k_vec = np.fft.fftfreq(N, d=1.0) * N  # Integer wavenumbers\n    \n    u_hat_filtered = u_hat.copy()\n    u_hat_filtered[np.abs(k_vec)  k_c] = 0.0\n    \n    u_filtered = np.fft.ifft(u_hat_filtered)\n    # The squared field should be real, .real handles minor numerical noise\n    g_filtered = u_filtered.real**2\n    \n    error_filtered = np.linalg.norm(g_filtered - g_true) / norm_g_true\n    \n    return error_naive, error_filtered\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case 1: N=96, u(x) = 1.0*cos(30x) + 0.5*sin(31x) + 0.25*cos(2x)\n        (96, [(1.0, 'cos', 30), (0.5, 'sin', 31), (0.25, 'cos', 2)]),\n        \n        # Case 2: N=48, u(x) = 1.0*cos(23x) + 1.0*sin(16x) + 0.3*cos(5x)\n        (48, [(1.0, 'cos', 23), (1.0, 'sin', 16), (0.3, 'cos', 5)]),\n        \n        # Case 3: N=64, u(x) = 0.8*sin(20x) + 0.7*cos(21x) - 0.6*sin(22x) + 0.2*cos(3x)\n        (64, [(0.8, 'sin', 20), (0.7, 'cos', 21), (-0.6, 'sin', 22), (0.2, 'cos', 3)]),\n        \n        # Case 4: N=60, u(x) = 1.0*sin(20x) + 0.9*cos(19x) + 0.5*sin(21x)\n        (60, [(1.0, 'sin', 20), (0.9, 'cos', 19), (0.5, 'sin', 21)]),\n    ]\n\n    results = []\n    for case in test_cases:\n        err_naive, err_filtered = calculate_errors(case)\n        results.append(err_naive)\n        results.append(err_filtered)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```", "id": "3405943"}, {"introduction": "As computational problems grow in scale, solving the resulting large nonlinear systems becomes a major bottleneck, demanding parallel algorithms. Domain decomposition methods provide a powerful framework for this, breaking a large problem into smaller, coupled subproblems that can be solved concurrently. This advanced exercise [@problem_id:3381001] delves into this topic by having you implement and compare two prominent nonlinear domain decomposition techniques: Nonlinear Additive Schwarz (NAS) and Additive Schwarz Preconditioned Inexact Newton (ASPIN), providing direct insight into their scalability and performance characteristics.", "problem": "Consider the quasilinear diffusion boundary value problem on the unit interval with homogeneous Dirichlet boundary conditions,\n$$\n-\\frac{d}{dx}\\left(a(x,u)\\frac{du}{dx}\\right)=f(x),\\quad x\\in(0,1),\\qquad u(0)=0,\\quad u(1)=0,\n$$\nwhere the nonlinear diffusion coefficient is\n$$\na(x,u)=a_0(x)\\left(1+\\alpha\\,u^2\\right),\n$$\nwith spatial heterogeneity\n$$\na_0(x)=\\begin{cases}\n1, x\\leq 1/2,\\\\\n\\gamma, x1/2,\n\\end{cases}\n$$\nfor a given contrast parameter $\\gamma\\ge 1$, and nonlinear strength $\\alpha0$. Let the forcing be constant,\n$$\nf(x)\\equiv 1.\n$$\n\nDiscretize the problem on a uniform grid of $N$ interior points with spacing $h=1/(N+1)$, nodes $x_i=ih$ for integers $i=0,1,\\dots,N+1$, and unknowns $u_i\\approx u(x_i)$ for $i=1,\\dots,N$. Use a conservative finite-difference flux discretization with face-centered diffusion:\n$$\n\\mathcal{R}_i(\\mathbf{u})=\\frac{1}{h^2}\\left(A_{i+1/2}\\left(u_{i+1}-u_i\\right)-A_{i-1/2}\\left(u_i-u_{i-1}\\right)\\right)-f_i,\\quad i=1,\\dots,N,\n$$\nwhere the face diffusion coefficients are\n$$\nA_{i+1/2}=a\\!\\left(x_{i+1/2},\\frac{u_{i+1}+u_i}{2}\\right),\\quad x_{i+1/2}=(i+1/2)h,\n$$\nand $f_i=f(x_i)=1$. Impose the boundary values $u_0=0$ and $u_{N+1}=0$ when computing the discrete residual.\n\nDefine a one-dimensional overlapping domain decomposition of the interior index set $\\{1,2,\\dots,N\\}$ into $n_s$ contiguous core subdomains and extend each core by an overlap of $\\delta\\in\\{0,1,2,\\dots\\}$ grid points on each side (clipped to remain within $\\{1,\\dots,N\\}$). Denote the extended subdomain index ranges by $[L_s,U_s]$, $s=1,\\dots,n_s$. Let the partition-of-unity weights $w_i$ be defined by $w_i=1/n_i$ where $n_i$ is the number of extended subdomains covering index $i$.\n\nConsider the following two nonlinear solvers:\n\n- Nonlinear Additive Schwarz (NAS) iteration: Given a current global iterate $\\mathbf{u}^{(k)}$, for each subdomain $s$ solve the local nonlinear discrete problem with Dirichlet boundary values taken from $\\mathbf{u}^{(k)}$ at the artificial interfaces to obtain the local solution $\\mathbf{u}^{(k)}_s$. Form the local correction on the extended subdomain range, $\\mathbf{c}_s=\\mathbf{u}^{(k)}_s-\\mathbf{u}^{(k)}|_{[L_s,U_s]}$. Assemble the global correction by partition-of-unity injection,\n$$\nd_i=\\sum_{s:\\,i\\in[L_s,U_s]} w_i\\,(\\mathbf{c}_s)_i,\n$$\nand update $\\mathbf{u}^{(k+1)}=\\mathbf{u}^{(k)}+\\mathbf{d}$. Repeat until the global residual norm $\\|\\mathcal{R}(\\mathbf{u}^{(k)})\\|_2$ falls below a prescribed tolerance.\n\n- Additive Schwarz Preconditioned Inexact Newton (ASPIN): Given $\\mathbf{u}^{(k)}$, for each subdomain $s$ form the local residual vector and local Jacobian matrix (the Jacobian is the matrix of partial derivatives of the local residual with respect to local unknowns, accounting for the dependence of $A_{i\\pm 1/2}$ on $u$ through the arithmetic average). Solve the local linear system for the correction $\\delta_s$,\n$$\nJ_s(\\mathbf{u}^{(k)})\\,\\delta_s=-\\mathcal{R}_s(\\mathbf{u}^{(k)}),\n$$\nwith Dirichlet boundary values taken from $\\mathbf{u}^{(k)}$ at the artificial interfaces. Inject the local corrections by the same partition-of-unity scheme to obtain a global search direction $\\mathbf{p}$. Perform a backtracking line search along $\\mathbf{p}$ to decrease the global residual norm, and update $\\mathbf{u}^{(k+1)}=\\mathbf{u}^{(k)}+\\alpha\\,\\mathbf{p}$ with a selected step length $\\alpha\\in(0,1]$. Repeat until convergence.\n\nStarting from the zero initial vector $\\mathbf{u}^{(0)}=\\mathbf{0}$, investigate the scalability of these two methods with respect to the contrast $\\gamma$ and the overlap size $\\delta$ for a fixed number of subdomains $n_s$ and fixed nonlinear strength $\\alpha$. Use $N=64$ interior points and $\\alpha=1.0$. For each test case below, run both NAS and ASPIN until the global residual norm $\\|\\mathcal{R}(\\mathbf{u})\\|_2$ is less than $10^{-8}$, or until a maximum of $50$ global iterations is reached. Record the number of global iterations required by each method.\n\nTest suite parameter sets $(\\gamma,\\delta,n_s)$:\n- $(1.0,0,2)$,\n- $(10.0,0,4)$,\n- $(100.0,0,4)$,\n- $(100.0,4,4)$,\n- $(1000.0,0,4)$,\n- $(1000.0,4,4)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case's result must be a list of two integers $[\\mathrm{it}_{\\mathrm{NAS}},\\mathrm{it}_{\\mathrm{ASPIN}}]$ indicating the number of global iterations for NAS and ASPIN, respectively. For example, the final output format must be like\n$$\n[\\,[\\mathrm{it}_{\\mathrm{NAS},1},\\mathrm{it}_{\\mathrm{ASPIN},1}],\\,[\\mathrm{it}_{\\mathrm{NAS},2},\\mathrm{it}_{\\mathrm{ASPIN},2}],\\,\\dots\\,].\n$$\nNo physical units are involved in this problem.", "solution": "The user wants to solve a one-dimensional quasilinear boundary value problem using two different parallel iterative schemes based on domain decomposition. The task is to implement these schemes and report the number of iterations required for convergence for a given set of test parameters.\n\n### **1. Problem Formulation and Discretization**\n\nThe governing partial differential equation (PDE) is a quasilinear diffusion equation:\n$$\n-\\frac{d}{dx}\\left(a(x,u)\\frac{du}{dx}\\right)=f(x),\\quad x\\in(0,1)\n$$\nwith homogeneous Dirichlet boundary conditions $u(0)=0$ and $u(1)=0$.\n\nThe diffusion coefficient $a(x,u)$ is nonlinear and spatially heterogeneous:\n$$\na(x,u)=a_0(x)\\left(1+\\alpha\\,u^2\\right), \\quad \\text{where} \\quad a_0(x)=\\begin{cases}\n1, x\\leq 1/2\\\\\n\\gamma, x1/2\n\\end{cases}\n$$\nThe parameters $\\alpha  0$ and $\\gamma \\ge 1$ control the strength of the nonlinearity and the contrast in the medium, respectively. The forcing term is constant, $f(x)=1$.\n\nWe discretize the domain $(0,1)$ using a uniform grid with $N$ interior nodes $x_i = ih$ for $i=1, \\dots, N$, where the grid spacing is $h=1/(N+1)$. The boundary nodes are $x_0=0$ and $x_{N+1}=1$. Let $u_i \\approx u(x_i)$ be the discrete approximation of the solution at the interior nodes. The boundary conditions are $u_0=0$ and $u_{N+1}=0$.\n\nA conservative finite difference scheme is employed. The discrete residual $\\mathcal{R}_i$ for each interior node $i=1, \\dots, N$ is given by:\n$$\n\\mathcal{R}_i(\\mathbf{u})=\\frac{1}{h^2}\\left(A_{i+1/2}\\left(u_{i+1}-u_i\\right)-A_{i-1/2}\\left(u_i-u_{i-1}\\right)\\right)-f_i\n$$\nThis represents a system of $N$ nonlinear algebraic equations, $\\mathcal{R}(\\mathbf{u})=\\mathbf{0}$. The face-centered diffusion coefficients $A_{i\\pm1/2}$ are evaluated using an arithmetic mean for the solution $u$:\n$$\nA_{i+1/2}=a\\left(x_{i+1/2},\\frac{u_{i+1}+u_i}{2}\\right)\n$$\nwhere $x_{i+1/2} = (i+1/2)h$.\n\n### **2. Domain Decomposition and Solvers**\n\nThe set of interior indices $\\{1, \\dots, N\\}$ is partitioned into $n_s$ contiguous core subdomains. Each core is extended by $\\delta$ grid points on each side to create overlapping extended subdomains. A partition of unity, defined by weights $w_i = 1/n_i$ (where $n_i$ is the number of subdomains covering node $i$), is used to combine local corrections into a global update.\n\nWe implement two iterative solvers starting from $\\mathbf{u}^{(0)}=\\mathbf{0}$.\n\n#### **Nonlinear Additive Schwarz (NAS)**\nThe NAS method is a parallel nonlinear block Gauss-Seidel/Jacobi-type iteration. At each global iteration $k$:\n1. For each subdomain $s$, solve a local nonlinear boundary value problem. The unknowns are the values of $u$ on the interior of the extended subdomain, with Dirichlet boundary values at the artificial interfaces taken from the current global iterate $\\mathbf{u}^{(k)}$.\n2. This local solve yields a local solution $\\mathbf{u}_s^{(k)}$. The local correction is $\\mathbf{c}_s = \\mathbf{u}_s^{(k)} - \\mathbf{u}^{(k)}|_s$.\n3. A global correction $\\mathbf{d}$ is assembled by summing the local corrections, weighted by the partition of unity: $d_i = \\sum_{s} w_i (\\mathbf{c}_s)_i$.\n4. The global solution is updated: $\\mathbf{u}^{(k+1)} = \\mathbf{u}^{(k)} + \\mathbf{d}$.\n\nThe local nonlinear solves must be performed using an inner iterative method. We will use a general-purpose nonlinear solver (`scipy.optimize.root`) for this task.\n\n#### **Additive Schwarz Preconditioned Inexact Newton (ASPIN)**\nASPIN is an inexact Newton method where the Newton correction is computed in parallel using an Additive Schwarz preconditioner for the Jacobian system. At each global iteration $k$:\n1. For each subdomain $s$, compute the local residual $\\mathcal{R}_s(\\mathbf{u}^{(k)})$ and the local Jacobian matrix $J_s(\\mathbf{u}^{(k)})$. The Jacobian is the matrix of partial derivatives of the local residual with respect to the local unknowns.\n2. Solve the local linear system $J_s(\\mathbf{u}^{(k)}) \\delta_s = -\\mathcal{R}_s(\\mathbf{u}^{(k)})$ for the local correction $\\delta_s$. This system corresponds to a single Newton step on the subdomain, with homogeneous Dirichlet boundary conditions for the correction $\\delta_s$ at the artificial interfaces.\n3. Assemble the global search direction $\\mathbf{p}$ by summing the local corrections, weighted by the partition of unity: $p_i = \\sum_{s} w_i (\\delta_s)_i$.\n4. Perform a backtracking line search to find a step length $\\alpha_{LS} \\in (0,1]$ that ensures a sufficient decrease in the global residual norm, i.e., $\\|\\mathcal{R}(\\mathbf{u}^{(k)} + \\alpha_{LS}\\mathbf{p})\\|_2  \\|\\mathcal{R}(\\mathbf{u}^{(k)})\\|_2$.\n5. Update the global solution: $\\mathbf{u}^{(k+1)} = \\mathbf{u}^{(k)} + \\alpha_{LS}\\mathbf{p}$.\n\nThe entries of the local Jacobian matrix $J_s$ are derived by differentiating the discrete residual $\\mathcal{R}_i$ with respect to the unknowns $u_j$. Since $A_{i\\pm1/2}$ depends nonlinearly on $u$, the chain rule is applied. The resulting Jacobian is tridiagonal for this one-dimensional problem.\n\n### **3. Implementation Details**\n\nThe implementation will be encapsulated within a single function `solve()`, which will define all necessary helper functions and execute the test suite.\n- **Grid and Parameters**: We set $N=64$, $\\alpha=1.0$, and the convergence tolerance to $10^{-8}$.\n- **Subdomain Creation**: The interior indices from $0$ to $N-1$ are split into nearly equal-sized core subdomains. These are then extended by $\\delta$ points, respecting the global domain boundaries.\n- **NAS Inner Solver**: `scipy.optimize.root` with the `hybr` method is used to solve the local nonlinear systems.\n- **ASPIN Linear Solver**: Standard `numpy.linalg.solve` is used for the local Jacobian systems, which are small enough that a specialized banded solver is not strictly necessary.\n- **Jacobian Calculation**: The entries of the tridiagonal Jacobian are computed analytically and assembled. Vectorized NumPy operations are used for efficiency.\n- **Convergence**: Iterations for both methods proceed until the $L_2$-norm of the global residual falls below the tolerance or a maximum of $50$ iterations is reached. If the maximum is reached, this number is reported, indicating failure to converge.\n- **Output**: The results for each test case, consisting of the iteration counts for NAS and ASPIN, are formatted into a list of lists as specified.", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import root\n\ndef solve():\n    \"\"\"\n    Solves the specified quasilinear diffusion problem using NAS and ASPIN methods\n    for a suite of test cases and prints the iteration counts.\n    \"\"\"\n    \n    # --- Problem Definition ---\n    N = 64\n    ALPHA = 1.0\n    TOL = 1e-8\n    MAX_ITER = 50\n    H = 1.0 / (N + 1)\n\n    # --- Helper Functions (defined internally for self-containment) ---\n\n    def a0_func(x, gamma):\n        \"\"\"Vectorized spatial heterogeneity function a_0(x).\"\"\"\n        a0 = np.ones_like(x)\n        if gamma != 1.0:\n            a0[x  0.5] = gamma\n        return a0\n\n    def a_func(x, u, gamma):\n        \"\"\"Vectorized nonlinear diffusion coefficient a(x,u).\"\"\"\n        return a0_func(x, gamma) * (1.0 + ALPHA * u**2)\n\n    def compute_residual(u, gamma):\n        \"\"\"Computes the global residual vector R(u).\"\"\"\n        u_full = np.concatenate(([0.0], u, [0.0]))\n        \n        u_faces = (u_full[:-1] + u_full[1:]) / 2.0\n        x_faces = H * (np.arange(N + 1) + 0.5)\n\n        A = a_func(x_faces, u_faces, gamma)\n        F = A * (u_full[1:] - u_full[:-1]) / H\n        \n        R = -(F[1:] - F[:-1]) / H - 1.0\n        return R\n\n    def create_subdomains(ns, delta):\n        \"\"\"Creates subdomain definitions and partition of unity weights.\"\"\"\n        core_indices = np.array_split(np.arange(N), ns)\n        subdomains = []\n        for core in core_indices:\n            L_core, U_core = core[0], core[-1]\n            L_ext = max(0, L_core - delta)\n            U_ext = min(N - 1, U_core + delta)\n            subdomains.append(np.arange(L_ext, U_ext + 1))\n\n        n_coverage = np.zeros(N)\n        for sub_indices in subdomains:\n            n_coverage[sub_indices] += 1\n        weights = 1.0 / n_coverage\n        return subdomains, weights\n\n    # --- Nonlinear Solvers ---\n\n    def solve_nas(gamma, delta, ns):\n        \"\"\"Nonlinear Additive Schwarz (NAS) solver.\"\"\"\n        u = np.zeros(N)\n        subdomains, weights = create_subdomains(ns, delta)\n        \n        for k in range(MAX_ITER):\n            if np.linalg.norm(compute_residual(u, gamma))  TOL:\n                return k\n            \n            d = np.zeros(N)\n            u_full = np.concatenate(([0.0], u, [0.0]))\n            \n            for ext_indices in subdomains:\n                local_size = len(ext_indices)\n                u_bnd_L = u_full[ext_indices[0]]\n                u_bnd_R = u_full[ext_indices[-1] + 2]\n                \n                def local_residual_func(u_local):\n                    u_local_full = np.concatenate(([u_bnd_L], u_local, [u_bnd_R]))\n                    u_faces_local = (u_local_full[:-1] + u_local_full[1:]) / 2.0\n                    x_faces_local = H * (ext_indices[0] + np.arange(local_size + 1) + 0.5)\n                    A_local = a_func(x_faces_local, u_faces_local, gamma)\n                    F_local = A_local * (u_local_full[1:] - u_local_full[:-1]) / H\n                    R_local = -(F_local[1:] - F_local[:-1]) / H - 1.0\n                    return R_local\n\n                u_local_initial = u[ext_indices]\n                sol = root(local_residual_func, u_local_initial, method='hybr', tol=TOL*1e-2)\n                \n                if not sol.success:\n                    return MAX_ITER\n\n                c_s = sol.x - u_local_initial\n                d[ext_indices] += weights[ext_indices] * c_s\n            \n            u += d\n            \n        return MAX_ITER\n\n    def solve_aspin(gamma, delta, ns):\n        \"\"\"Additive Schwarz Preconditioned Inexact Newton (ASPIN) solver.\"\"\"\n        u = np.zeros(N)\n        subdomains, weights = create_subdomains(ns, delta)\n        \n        for k in range(MAX_ITER):\n            R_k = compute_residual(u, gamma)\n            norm_R_k = np.linalg.norm(R_k)\n            if norm_R_k  TOL:\n                return k\n\n            p = np.zeros(N)\n            u_full = np.concatenate(([0.0], u, [0.0]))\n\n            for ext_indices in subdomains:\n                local_size = len(ext_indices)\n                u_local_full = np.concatenate(([u_full[ext_indices[0]]], u[ext_indices], [u_full[ext_indices[-1] + 2]]))\n                \n                # Local residual\n                u_faces_local = (u_local_full[:-1] + u_local_full[1:]) / 2.0\n                x_faces_local = H * (ext_indices[0] + np.arange(local_size + 1) + 0.5)\n                A_local = a_func(x_faces_local, u_faces_local, gamma)\n                F_local = A_local * (u_local_full[1:] - u_local_full[:-1]) / H\n                R_local = -(F_local[1:] - F_local[:-1]) / H - 1.0\n\n                # Local Jacobian\n                J_local = np.zeros((local_size, local_size))\n                a0_faces_local = a0_func(x_faces_local, gamma)\n                dAdu_term = ALPHA * a0_faces_local * u_faces_local\n                u_diffs = u_local_full[1:] - u_local_full[:-1]\n                \n                diag = (dAdu_term[1:-1] * u_diffs[1:-1]   - A_local[1:-1] \n                       - dAdu_term[:-2]  * u_diffs[:-2]    - A_local[:-2]) / H**2\n                np.fill_diagonal(J_local, diag)\n\n                if local_size  1:\n                    sub_diag = (A_local[:-2] - dAdu_term[:-2] * u_diffs[:-2]) / H**2\n                    np.fill_diagonal(J_local[1:], sub_diag)\n                    \n                    sup_diag = (A_local[2:] + dAdu_term[2:] * u_diffs[2:]) / H**2\n                    np.fill_diagonal(J_local[:, 1:], sup_diag)\n                \n                try:\n                    delta_s = np.linalg.solve(J_local, -R_local)\n                except np.linalg.LinAlgError:\n                    return MAX_ITER\n                \n                p[ext_indices] += weights[ext_indices] * delta_s\n\n            # Backtracking line search\n            alpha_ls = 1.0\n            found_step = False\n            for _ in range(10): \n                u_new = u + alpha_ls * p\n                norm_R_new = np.linalg.norm(compute_residual(u_new, gamma))\n                if norm_R_new  norm_R_k:\n                    u = u_new\n                    found_step = True\n                    break\n                alpha_ls /= 2.0\n            \n            if not found_step:\n                return MAX_ITER\n\n        return MAX_ITER\n\n    # --- Main execution loop ---\n    test_cases = [\n        (1.0, 0, 2),\n        (10.0, 0, 4),\n        (100.0, 0, 4),\n        (100.0, 4, 4),\n        (1000.0, 0, 4),\n        (1000.0, 4, 4),\n    ]\n\n    results = []\n    for gamma, delta, ns in test_cases:\n        it_nas = solve_nas(gamma, delta, ns)\n        it_aspin = solve_aspin(gamma, delta, ns)\n        results.append([it_nas, it_aspin])\n    \n    formatted_results = [f\"[{r[0]},{r[1]}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3381001"}]}