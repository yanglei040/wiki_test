{"hands_on_practices": [{"introduction": "This first practice is your entry point into implementing Alternating Direction Implicit (ADI) methods. You will code the classic Peaceman–Rachford scheme for the 2D heat equation, which cleverly transforms a complex 2D problem into a series of simple 1D tridiagonal solves. This exercise ([@problem_id:2446320]) builds foundational coding skills for finite difference methods and demonstrates the core efficiency of ADI.", "problem": "Consider the two-dimensional heat equation on the unit square with homogeneous Dirichlet boundary conditions and a separable analytic solution. Let $u(x,y,t)$ satisfy\n$$\n\\frac{\\partial u}{\\partial t}(x,y,t) \\;=\\; \\kappa \\left( \\frac{\\partial^2 u}{\\partial x^2}(x,y,t) + \\frac{\\partial^2 u}{\\partial y^2}(x,y,t) \\right), \\quad (x,y)\\in (0,1)\\times(0,1), \\; t\\in (0,T],\n$$\nwith $u(x,y,t) = 0$ for $(x,y)$ on the boundary $\\partial([0,1]\\times[0,1])$ and $t\\ge 0$. The initial condition is\n$$\nu(x,y,0) \\;=\\; \\sin(m\\pi x)\\,\\sin(n\\pi y),\n$$\nwhich yields the exact solution\n$$\nu(x,y,t) \\;=\\; \\sin(m\\pi x)\\,\\sin(n\\pi y)\\,\\exp\\!\\left( -\\,\\kappa \\pi^2 (m^2+n^2)\\, t \\right).\n$$\nDiscretize the spatial domain with $N_x$ and $N_y$ interior points in the $x$- and $y$-directions, respectively. Let $h_x = 1/(N_x+1)$ and $h_y = 1/(N_y+1)$, and let the interior grid points be $(x_i,y_j) = (i\\,h_x, j\\,h_y)$ for $i\\in\\{1,\\dots,N_x\\}$ and $j\\in\\{1,\\dots,N_y\\}$. Discretize time with time step $\\Delta t$ such that $N_t = T/\\Delta t$ is an integer and $t^n = n\\,\\Delta t$ for $n\\in\\{0,1,\\dots,N_t\\}$.\n\nUse the Peaceman–Rachford Alternating Direction Implicit (ADI) scheme to advance the solution from $t^n$ to $t^{n+1}$ via the two-stage update at each time step. Define the interior grid function $U^n_{i,j} \\approx u(x_i,y_j,t^n)$. With $\\lambda_x = \\kappa \\Delta t /(2 h_x^2)$ and $\\lambda_y = \\kappa \\Delta t /(2 h_y^2)$, the two half-steps are:\n$$\n\\text{Stage 1:}\\quad\n\\big(I - \\lambda_x A_x\\big)\\, U^{\\star} \\;=\\; \\big(I + \\lambda_y A_y\\big)\\, U^n,\n$$\n$$\n\\text{Stage 2:}\\quad\n\\big(I - \\lambda_y A_y\\big)\\, U^{n+1} \\;=\\; \\big(I + \\lambda_x A_x\\big)\\, U^{\\star},\n$$\nwhere $A_x$ and $A_y$ are the standard second-difference operators acting along $x$ and $y$ on interior points with homogeneous Dirichlet boundary values outside the interior. Concretely, for interior indices,\n$$\n(A_x U)_{i,j} \\;=\\; U_{i-1,j} - 2U_{i,j} + U_{i+1,j},\\qquad\n(A_y U)_{i,j} \\;=\\; U_{i,j-1} - 2U_{i,j} + U_{i,j+1},\n$$\nwith the understanding that any $U$ value indexed outside the interior uses the boundary value $0$.\n\nImplement this scheme on the interior grid and advance exactly $N_t$ full steps to time $T$. For each test case below, compute the relative discrete $L^2$ error at time $T$,\n$$\n\\varepsilon \\;=\\; \\frac{\\left( \\sum_{i=1}^{N_x} \\sum_{j=1}^{N_y} \\big(U^{N_t}_{i,j} - u(x_i,y_j,T)\\big)^2\\, h_x h_y \\right)^{1/2}}{\\left( \\sum_{i=1}^{N_x} \\sum_{j=1}^{N_y} \\big(u(x_i,y_j,T)\\big)^2\\, h_x h_y \\right)^{1/2}},\n$$\nwhich is dimensionless.\n\nTest Suite:\n- Case $1$ (general case): $\\kappa = 1$, $m = 1$, $n = 1$, $N_x = 20$, $N_y = 20$, $\\Delta t = 10^{-4}$, $T = 10^{-2}$.\n- Case $2$ (anisotropic spatial frequencies and grid): $\\kappa = 1$, $m = 2$, $n = 1$, $N_x = 12$, $N_y = 8$, $\\Delta t = 5\\times 10^{-4}$, $T = 2\\times 10^{-2}$.\n- Case $3$ (coarse grid and large time step): $\\kappa = 1$, $m = 1$, $n = 1$, $N_x = 2$, $N_y = 2$, $\\Delta t = 10^{-1}$, $T = 10^{-1}$.\n- Case $4$ (finer grid and small time step): $\\kappa = 1$, $m = 3$, $n = 2$, $N_x = 50$, $N_y = 50$, $\\Delta t = 5\\times 10^{-5}$, $T = 5\\times 10^{-3}$.\n\nAll quantities are dimensionless. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,r_3,r_4]$), where each $r_k$ is the relative discrete $L^2$ error $\\varepsilon$ computed for the corresponding test case in the order listed above. The program must be fully self-contained and produce these four numbers without requiring any user input or external files.", "solution": "The problem statement is subjected to validation and is found to be valid. It is scientifically grounded, well-posed, objective, and internally consistent. It presents a standard problem in computational science: the numerical solution of the two-dimensional heat equation using the Peaceman–Rachford Alternating Direction Implicit (ADI) scheme. All parameters and definitions required for a unique numerical solution are provided, and the task is a direct application of established numerical methods.\n\nThe objective is to solve the two-dimensional heat equation\n$$\n\\frac{\\partial u}{\\partial t} \\;=\\; \\kappa \\left( \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} \\right)\n$$\non a unit square domain $(x,y)\\in (0,1)\\times(0,1)$ with homogeneous Dirichlet boundary conditions. The provided initial condition $u(x,y,0) = \\sin(m\\pi x)\\sin(n\\pi y)$ corresponds to a known analytical solution, which serves as a benchmark for verifying the accuracy of the numerical implementation.\n\nThe Peaceman–Rachford ADI method is a finite difference scheme that is second-order accurate in both space and time, and it is unconditionally stable for the heat equation. Its principal advantage lies in its computational efficiency. A fully implicit two-dimensional scheme would require solving a large, sparse linear system with a block-tridiagonal structure. The ADI method circumvents this by splitting the time step $\\Delta t$ into two half-steps. Each half-step is implicit only in one spatial direction, which results in systems of equations that are merely tridiagonal.\n\nThe method advances the discrete solution $U^n$, an approximation of $u(x,y,t^n)$ on the grid, to $U^{n+1}$ via an intermediate step $U^{\\star}$. The grid is defined by $N_x \\times N_y$ interior points, with spacings $h_x = 1/(N_x+1)$ and $h_y = 1/(N_y+1)$.\n\nThe two stages of the ADI scheme are:\n\nStage 1: Implicit in the $x$-direction.\n$$\n\\big(I - \\lambda_x A_x\\big)\\, U^{\\star} \\;=\\; \\big(I + \\lambda_y A_y\\big)\\, U^n\n$$\nHere, $\\lambda_x = \\kappa \\Delta t /(2 h_x^2)$ and $\\lambda_y = \\kappa \\Delta t /(2 h_y^2)$. The operator $A_x$ is the one-dimensional second-difference operator in $x$, and $A_y$ is the corresponding operator in $y$. For each grid row, indexed by $j \\in \\{1, \\dots, N_y\\}$, this equation forms an independent tridiagonal system of $N_x$ linear equations for the unknowns $U^{\\star}_{1,j}, \\dots, U^{\\star}_{N_x,j}$. The system for a given row $j$ is:\n$$\n-\\lambda_x U^{\\star}_{i-1,j} + (1 + 2\\lambda_x) U^{\\star}_{i,j} - \\lambda_x U^{\\star}_{i+1,j} \\;=\\; d_{i,j}, \\quad i \\in \\{1, \\dots, N_x\\}\n$$\nwhere $d = (I + \\lambda_y A_y)U^n$ is the right-hand side, which is known from the solution at time $t^n$. The boundary conditions imply $U^{\\star}_{0,j} = U^{\\star}_{N_x+1,j} = 0$.\n\nStage 2: Implicit in the $y$-direction.\n$$\n\\big(I - \\lambda_y A_y\\big)\\, U^{n+1} \\;=\\; \\big(I + \\lambda_x A_x\\big)\\, U^{\\star}\n$$\nFollowing the first stage, this equation is solved for $U^{n+1}$. For each grid column, indexed by $i \\in \\{1, \\dots, N_x\\}$, this forms an independent tridiagonal system of $N_y$ linear equations for the unknowns $U^{n+1}_{i,1}, \\dots, U^{n+1}_{i,N_y}$. The system for a given column $i$ is:\n$$\n-\\lambda_y U^{n+1}_{i,j-1} + (1 + 2\\lambda_y) U^{n+1}_{i,j} - \\lambda_y U^{n+1}_{i,j+1} \\;=\\; e_{i,j}, \\quad j \\in \\{1, \\dots, N_y\\}\n$$\nwhere $e = (I + \\lambda_x A_x)U^{\\star}$ is the right-hand side, known from the intermediate solution $U^{\\star}$. The boundary conditions imply $U^{n+1}_{i,0} = U^{n+1}_{i,N_y+1} = 0$.\n\nThe implementation strategy is as follows:\n1.  Initialize the solution. A two-dimensional array $U$ of size $N_y \\times N_x$ is initialized with the values from the initial condition $u(x,y,0) = \\sin(m\\pi x)\\sin(n\\pi y)$ evaluated at the interior grid points $(x_i, y_j)$.\n2.  Construct the tridiagonal system matrices. More precisely, we construct the banded representations of the matrices $(I-\\lambda_x A_x)$ and $(I-\\lambda_y A_y)$ required by a numerical solver.\n3.  Iterate for $N_t = T/\\Delta t$ time steps. In each step:\n    a. Calculate the right-hand side of Stage 1, $RHS_1 = (I + \\lambda_y A_y)U^n$. This is achieved using vectorized array operations on $U^n$, accounting for the zero Dirichlet boundary conditions.\n    b. Solve the $N_y$ tridiagonal systems for the rows of $U^{\\star}$. This is done efficiently using a vectorized call to a banded linear system solver, such as `scipy.linalg.solve_banded`, by transposing the $RHS_1$ matrix.\n    c. Calculate the right-hand side of Stage 2, $RHS_2 = (I + \\lambda_x A_x)U^{\\star}$, again using vectorized operations on the intermediate solution $U^{\\star}$.\n    d. Solve the $N_x$ tridiagonal systems for the columns of $U^{n+1}$. This is a direct application of the banded solver to the columns of $RHS_2$.\n    e. Update the solution: $U \\leftarrow U^{n+1}$.\n4.  After the final time step, calculate the exact solution $u(x,y,T)$ on the same grid.\n5.  Compute the relative discrete $L^2$ error, $\\varepsilon$. The formula provided is equivalent to the ratio of the Frobenius norms of the error matrix and the exact solution matrix:\n    $$\n    \\varepsilon = \\frac{|| U^{N_t} - u(\\cdot, \\cdot, T) ||_F}{|| u(\\cdot, \\cdot, T) ||_F}\n    $$\n    where $||A||_F = \\left(\\sum_{i,j} |A_{ij}|^2\\right)^{1/2}$. This is computationally straightforward.\n\nThis procedure is systematically applied to the four test cases specified in the problem statement. The final output consists of the computed error $\\varepsilon$ for each case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to solve the 2D heat equation for all test cases\n    using the Peaceman-Rachford ADI method and compute the errors.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (kappa, m, n, Nx, Ny, dt, T)\n        (1.0, 1, 1, 20, 20, 1e-4, 1e-2),\n        (1.0, 2, 1, 12, 8, 5e-4, 2e-2),\n        (1.0, 1, 1, 2, 2, 1e-1, 1e-1),\n        (1.0, 3, 2, 50, 50, 5e-5, 5e-3),\n    ]\n\n    results = []\n    for case in test_cases:\n        error = solve_one_case(case)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_one_case(params):\n    \"\"\"\n    Solves the 2D heat equation for a single set of parameters.\n    \"\"\"\n    kappa, m, n, Nx, Ny, dt, T = params\n\n    # 1. Calculate derived parameters\n    hx = 1.0 / (Nx + 1)\n    hy = 1.0 / (Ny + 1)\n    Nt = round(T / dt)  # Problem guarantees this is integer\n\n    lx = kappa * dt / (2.0 * hx**2)\n    ly = kappa * dt / (2.0 * hy**2)\n\n    # 2. Create spatial grid\n    x = np.linspace(hx, 1.0 - hx, Nx)\n    y = np.linspace(hy, 1.0 - hy, Ny)\n    X, Y = np.meshgrid(x, y) # X has shape (Ny, Nx), Y has shape (Ny, Nx)\n\n    # 3. Set initial condition\n    U = np.sin(m * np.pi * X) * np.sin(n * np.pi * Y)\n\n    # 4. Construct banded matrices for the tridiagonal solvers\n    # Stage 1: systems in x-direction (size Nx)\n    ab_x = np.zeros((3, Nx))\n    ab_x[0, 1:] = -lx\n    ab_x[1, :] = 1.0 + 2.0 * lx\n    ab_x[2, :-1] = -lx\n\n    # Stage 2: systems in y-direction (size Ny)\n    ab_y = np.zeros((3, Ny))\n    ab_y[0, 1:] = -ly\n    ab_y[1, :] = 1.0 + 2.0 * ly\n    ab_y[2, :-1] = -ly\n\n    # 5. Time-stepping loop\n    for _ in range(Nt):\n        # --- Stage 1: (I - lx*Ax) U_star = (I + ly*Ay) U ---\n\n        # Calculate RHS_1 = (I + ly*Ay) * U\n        # Ay applied to columns of U, with homogeneous Dirichlet BCs\n        RHS1 = np.zeros_like(U)\n        if Ny > 1:\n            RHS1[1:-1, :] = U[1:-1, :] + ly * (U[0:-2, :] - 2.0 * U[1:-1, :] + U[2:, :])\n            RHS1[0, :] = U[0, :] + ly * (-2.0 * U[0, :] + U[1, :])      # j=0\n            RHS1[-1, :] = U[-1, :] + ly * (U[-2, :] - 2.0 * U[-1, :])  # j=Ny-1\n        else: # Ny == 1\n            RHS1[0, :] = U[0, :] + ly * (-2.0 * U[0, :])\n\n        # Solve for U_star (systems are along rows)\n        # We transpose RHS1 to feed rows as columns to solve_banded\n        U_star_T = solve_banded((1, 1), ab_x, RHS1.T, overwrite_ab=False, overwrite_b=False)\n        U_star = U_star_T.T\n\n        # --- Stage 2: (I - ly*Ay) U_np1 = (I + lx*Ax) U_star ---\n        \n        # Calculate RHS_2 = (I + lx*Ax) * U_star\n        # Ax applied to rows of U_star, with homogeneous Dirichlet BCs\n        RHS2 = np.zeros_like(U_star)\n        if Nx > 1:\n            RHS2[:, 1:-1] = U_star[:, 1:-1] + lx * (U_star[:, 0:-2] - 2.0 * U_star[:, 1:-1] + U_star[:, 2:])\n            RHS2[:, 0] = U_star[:, 0] + lx * (-2.0 * U_star[:, 0] + U_star[:, 1])    # i=0\n            RHS2[:, -1] = U_star[:, -1] + lx * (U_star[:, -2] - 2.0 * U_star[:, -1])  # i=Nx-1\n        else: # Nx == 1\n            RHS2[:, 0] = U_star[:, 0] + lx * (-2.0 * U_star[:, 0])\n\n        # Solve for U_np1 (systems are along columns)\n        U_np1 = solve_banded((1, 1), ab_y, RHS2, overwrite_ab=False, overwrite_b=False)\n        \n        # Update solution for next time step\n        U = U_np1\n\n    # 6. Compute exact solution at final time T\n    U_exact = np.sin(m * np.pi * X) * np.sin(n * np.pi * Y) * np.exp(-kappa * np.pi**2 * (m**2 + n**2) * T)\n\n    # 7. Compute relative discrete L2 error\n    # The term sqrt(hx*hy) cancels in numerator and denominator.\n    # So error is ratio of Frobenius norms.\n    norm_diff = np.linalg.norm(U - U_exact)\n    norm_exact = np.linalg.norm(U_exact)\n\n    if norm_exact == 0:\n        return 0.0 if norm_diff == 0 else np.inf\n\n    return norm_diff / norm_exact\n\nsolve()\n```", "id": "2446320"}, {"introduction": "Real-world simulations demand efficiency, and a fixed time step is often suboptimal. Building on the foundational solver from the previous exercise, this practice ([@problem_id:3363234]) moves beyond the basics to implement an adaptive time-step controller. You will use a measure of the method's splitting error to dynamically adjust the time step, ensuring both accuracy and computational efficiency.", "problem": "You are to design and implement an adaptive time-step controller for a linear Alternating Direction Implicit (ADI) method for a diffusion-type partial differential equation. The starting point is the two-dimensional diffusion equation with homogeneous Dirichlet boundary conditions on the unit square,\n$$\n\\frac{\\partial u}{\\partial t} = k_x \\frac{\\partial^2 u}{\\partial x^2} + k_y \\frac{\\partial^2 u}{\\partial y^2}, \\quad (x,y) \\in (0,1)\\times(0,1), \\quad t \\ge 0,\n$$\nwith\n$$\nu(0,x,y) = \\sin(\\pi x)\\sin(\\pi y), \\quad u(t,0,y)=u(t,1,y)=u(t,x,0)=u(t,x,1)=0.\n$$\nDiscretize the spatial domain using a uniform grid of $N_x$ interior points in the $x$-direction and $N_y$ interior points in the $y$-direction, with spacings $h_x = 1/(N_x+1)$ and $h_y = 1/(N_y+1)$. Let $u^n \\in \\mathbb{R}^{N_y \\times N_x}$ denote the grid function at time level $t^n$, representing values at interior grid points. Define the one-dimensional centered second difference operators acting along each axis with homogeneous Dirichlet boundary treatment, yielding linear operators $A_x$ and $A_y$ acting on $u^n$ by\n$$\n(A_x u)_{i,j} = k_x \\frac{u_{i,j-1} - 2u_{i,j} + u_{i,j+1}}{h_x^2}, \\quad (A_y u)_{i,j} = k_y \\frac{u_{i-1,j} - 2u_{i,j} + u_{i+1,j}}{h_y^2},\n$$\nwhere out-of-range indices correspond to boundary values equal to $0$. Consider the factorized implicit Euler ADI update,\n$$\n(I - \\Delta t A_y) v = u^n, \\quad (I - \\Delta t A_x) u^{n+1} = v,\n$$\nwhich is algebraically equivalent to $(I - \\Delta t A_x)(I - \\Delta t A_y)u^{n+1} = u^n$.\n\nAt the start of each step, estimate the splitting defect using the linearized defect formula\n$$\nd^{n+1}(\\Delta t; u^n) = \\Big(I - \\Delta t A_x\\Big)\\Big(I - \\Delta t A_y\\Big) u^n - \\Big(I - \\Delta t (A_x + A_y)\\Big) u^n,\n$$\nwhich simplifies exactly to\n$$\nd^{n+1}(\\Delta t; u^n) = \\Delta t^2 A_x A_y u^n,\n$$\nand use its infinity norm $\\|d^{n+1}\\|_\\infty$ to adaptively control $\\Delta t$ so that this surrogate of the splitting error remains within a target tolerance. For each step, define a local tolerance\n$$\n\\mathrm{tol}_n = \\mathrm{atol} + \\mathrm{rtol}\\,\\|u^n\\|_\\infty.\n$$\nAccept the step if $\\|d^{n+1}\\|_\\infty \\le \\mathrm{tol}_n$; otherwise, reject it. In both cases, update the next time step using a proportional controller based on the expected quadratic scaling of the defect with respect to the time step,\n$$\n\\Delta t_{\\text{new}} = \\Delta t \\cdot \\mathrm{safety} \\cdot \\left(\\frac{\\mathrm{tol}_n}{\\max(\\|d^{n+1}\\|_\\infty,\\varepsilon)}\\right)^{1/2},\n$$\nbounded by user-chosen multiplicative limits $g_{\\min} \\le \\Delta t_{\\text{new}}/\\Delta t \\le g_{\\max}$ and an absolute maximum $\\Delta t \\le \\Delta t_{\\max}$. Here $\\varepsilon$ is a tiny positive number to avoid division by zero. On rejection, enforce $\\Delta t_{\\text{new}} \\le \\Delta t$; on acceptance, permit $\\Delta t_{\\text{new}} \\ge \\Delta t$ within the chosen bounds. Ensure that the time integration lands exactly at the final time by clipping $\\Delta t$ to the remaining time as needed.\n\nImplement the above with the following requirements:\n- Use the ADI factorization with tridiagonal solves in each direction for the two linear systems per accepted step.\n- Use the infinity norm for both $\\|u^n\\|_\\infty$ and $\\|d^{n+1}\\|_\\infty$.\n- Use the initial condition $u(0,x,y)=\\sin(\\pi x)\\sin(\\pi y)$ sampled at interior grid points $x_j = (j+1)h_x$, $y_i = (i+1)h_y$.\n\nTest suite. Run your implementation on the three parameter sets below. For each case, return the number of rejected steps (an integer) incurred by the controller over the whole integration. The three cases are:\n- Case 1 (balanced diffusion): $k_x = 1.0$, $k_y = 1.0$, $N_x = 32$, $N_y = 32$, $T = 0.1$, initial $\\Delta t_0 = 10^{-4}$, $\\Delta t_{\\max} = 10^{-2}$, $\\mathrm{rtol} = 10^{-3}$, $\\mathrm{atol} = 10^{-8}$.\n- Case 2 (anisotropic diffusion): $k_x = 1.0$, $k_y = 10.0$, $N_x = 32$, $N_y = 32$, $T = 0.05$, initial $\\Delta t_0 = 5 \\cdot 10^{-5}$, $\\Delta t_{\\max} = 5 \\cdot 10^{-3}$, $\\mathrm{rtol} = 5 \\cdot 10^{-4}$, $\\mathrm{atol} = 10^{-8}$.\n- Case 3 (degenerate in $y$): $k_x = 1.0$, $k_y = 0.0$, $N_x = 32$, $N_y = 32$, $T = 0.1$, initial $\\Delta t_0 = 10^{-3}$, $\\Delta t_{\\max} = 2 \\cdot 10^{-2}$, $\\mathrm{rtol} = 10^{-3}$, $\\mathrm{atol} = 10^{-8}$.\n\nController constants to use for all cases: $\\mathrm{safety} = 0.9$, $g_{\\min} = 0.2$, $g_{\\max} = 2.5$, and $\\varepsilon = 10^{-300}$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list of the three integers in order of the test cases, enclosed in square brackets, for example,\n\"[r1,r2,r3]\".", "solution": "The user requires the implementation of an adaptive time-stepping controller for the Alternating Direction Implicit (ADI) method applied to the two-dimensional diffusion equation on the unit square $[0,1] \\times [0,1]$:\n$$\n\\frac{\\partial u}{\\partial t} = k_x \\frac{\\partial^2 u}{\\partial x^2} + k_y \\frac{\\partial^2 u}{\\partial y^2}\n$$\nwith homogeneous Dirichlet boundary conditions and a given initial condition $u(0,x,y) = \\sin(\\pi x)\\sin(\\pi y)$.\n\nThe solution proceeds by first discretizing the problem, then implementing the ADI time-stepping scheme, and finally integrating the adaptive controller logic.\n\n### 1. Spatial Discretization\nThe continuous domain is discretized into a grid of $N_y \\times N_x$ interior points. The solution $u(t,x,y)$ at a time $t^n$ is represented by a matrix $u^n \\in \\mathbb{R}^{N_y \\times N_x}$, where $u^n_{i,j}$ approximates the solution at $(x_j, y_i) = ((j+1)h_x, (i+1)h_y)$. The grid spacings are $h_x = 1/(N_x+1)$ and $h_y = 1/(N_y+1)$.\n\nThe second partial derivatives are approximated using centered finite differences. This gives rise to two linear operators, $A_x$ and $A_y$, which act on the grid function $u^n$:\n- $A_x$ applies the one-dimensional second-difference stencil scaled by $k_x/h_x^2$ to each row of the matrix $u^n$.\n- $A_y$ applies the one-dimensional second-difference stencil scaled by $k_y/h_y^2$ to each column of the matrix $u^n$.\nThe homogeneous Dirichlet boundary conditions are handled by assuming that any grid function value at an index outside the interior domain is zero. In the implementation, this is achieved by padding the grid function matrix with zeros before applying the finite difference stencils.\n\n### 2. ADI Method\nThe time evolution is governed by the semi-discretized equation $\\frac{du}{dt} = (A_x + A_y)u$. The ADI method, specifically the factorized implicit Euler variant specified, splits the time step $\\Delta t$ into two sub-steps. This approach transforms a large two-dimensional problem into a series of smaller, independent one-dimensional problems, which are computationally efficient to solve.\n\nThe update from time $t^n$ to $t^{n+1} = t^n + \\Delta t$ is performed in two stages:\n1.  **Y-direction implicit step**: Solve for an intermediate state $v$:\n    $$ (I - \\Delta t A_y) v = u^n $$\n    This equation represents a set of $N_x$ independent tridiagonal linear systems, one for each column of the grid function $v$.\n2.  **X-direction implicit step**: Solve for the new state $u^{n+1}$:\n    $$ (I - \\Delta t A_x) u^{n+1} = v $$\n    This equation represents a set of $N_y$ independent tridiagonal linear systems, one for each row of the grid function $u^{n+1}$.\n\nEach set of tridiagonal systems is solved efficiently a single call to `scipy.linalg.solve_banded`, which is optimized for this task. For the X-direction step, which acts on rows, the intermediate matrix $v$ is transposed, the solver is called, and the result is transposed back.\n\n### 3. Adaptive Time-Step Control\nAn adaptive controller adjusts the time step $\\Delta t$ to maintain a measure of the local error below a specified tolerance. This improves efficiency by allowing larger steps when the solution is smooth and smaller steps when it changes rapidly.\n\n-   **Error Estimation**: The error used for control is a surrogate based on the ADI splitting defect, given by $d^{n+1} = \\Delta t^2 A_x A_y u^n$. Its infinity norm, $\\|d^{n+1}\\|_\\infty$, is used as the error measure for the current step. This quantity is computed by sequentially applying the implemented discrete operators $A_y$ and then $A_x$ to the current solution $u^n$.\n\n-   **Tolerance**: At each step, a local tolerance is computed as $\\mathrm{tol}_n = \\mathrm{atol} + \\mathrm{rtol}\\,\\|u^n\\|_\\infty$, where $\\mathrm{atol}$ and $\\mathrm{rtol}$ are absolute and relative tolerance parameters, respectively.\n\n-   **Accept/Reject Mechanism**: A step of size $\\Delta t$ is attempted.\n    - If $\\|d^{n+1}\\|_\\infty \\le \\mathrm{tol}_n$, the step is **accepted**. The solution and time are updated: $u^{n+1}$ is computed and becomes the new $u^n$, and $t$ advances by $\\Delta t$.\n    - If $\\|d^{n+1}\\|_\\infty > \\mathrm{tol}_n$, the step is **rejected**. The solution and time are not changed, and the number of rejected steps is incremented.\n\n-   **Step Size Update**: In both cases (acceptance or rejection), a new prospective time step $\\Delta t_{\\text{new}}$ is calculated using a proportional-integral (PI) type control law. The problem specifies a proportional controller:\n    $$ \\Delta t_{\\text{new}} = \\Delta t \\cdot \\mathrm{safety} \\cdot \\left(\\frac{\\mathrm{tol}_n}{\\max(\\|d^{n+1}\\|_\\infty,\\varepsilon)}\\right)^{1/2} $$\n    The tiny value $\\varepsilon$ prevents division by zero. The resulting step size change ratio, $\\Delta t_{\\text{new}}/\\Delta t$, is constrained to lie within $[g_{\\min}, g_{\\max}]$, and the new step size is capped by an absolute maximum $\\Delta t_{\\max}$. If a step is rejected, the newly computed $\\Delta t_{\\text{new}}$ (which will be smaller) is used to retry the step. If accepted, $\\Delta t_{\\text{new}}$ is used for the subsequent time step.\n\n### 4. Implementation Logic\nThe overall process is encapsulated in a function that runs the simulation for a given set of parameters.\n1.  Initialize the grid, the initial condition $u^0$ by sampling $\\sin(\\pi x)\\sin(\\pi y)$, the current time $t=0$, the initial step size $\\Delta t = \\Delta t_0$, and a counter for rejected steps.\n2.  A `while` loop runs as long as $t  T$.\n3.  Inside the loop, the current $\\Delta t$ is first clipped to not exceed $\\Delta t_{\\max}$ and to ensure the final step lands exactly at $t=T$.\n4.  The error a posteriori, $\\|d^{n+1}\\|_\\infty$, is calculated based on the current $u^n$ and the attempted $\\Delta t$.\n5.  A decision to accept or reject is made.\n6.  The new step size is calculated using the control formula and associated bounds.\n7.  If the step is accepted, time and the solution are advanced. The `dt` for the next iteration is set to the newly calculated step size.\n8.  If the step is rejected, the counter is incremented, and the `dt` for the next iteration (which is a retry of the current step) is set to the newly calculated (smaller) step size.\n9.  This process repeats until the final time $T$ is reached. The total number of rejected steps is returned. This logic is applied to each of the three test cases specified.\n\nA special case arises when $k_y = 0$, as in Case 3. Here, $A_y=0$, making the splitting defect $d^{n+1}$ identically zero. The implementation correctly handles this: the error norm is always zero, so every step is accepted, and the step size controller will increase $\\Delta t$ at the maximum allowed rate, $g_{\\max}$, until it is limited by $\\Delta t_{\\max}$.", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef run_simulation(kx, ky, Nx, Ny, T, dt0, dt_max, rtol, atol, safety, g_min, g_max, eps):\n    \"\"\"\n    Runs the adaptive ADI simulation for one parameter set.\n    \"\"\"\n    # 1. Grid and Initial Condition Setup\n    hx = 1.0 / (Nx + 1)\n    hy = 1.0 / (Ny + 1)\n    \n    x = (np.arange(Nx) + 1) * hx\n    y = (np.arange(Ny) + 1) * hy\n    X, Y = np.meshgrid(x, y)\n    \n    u = np.sin(np.pi * X) * np.sin(np.pi * Y)\n\n    t = 0.0\n    dt = dt0\n    rejected_steps = 0\n\n    # Helper functions for applying discrete operators\n    def apply_Ax(u_mat, k, h):\n        padded = np.pad(u_mat, ((0, 0), (1, 1)), 'constant')\n        diff = padded[:, :-2] - 2 * padded[:, 1:-1] + padded[:, 2:]\n        return (k / h**2) * diff\n\n    def apply_Ay(u_mat, k, h):\n        padded = np.pad(u_mat, ((1, 1), (0, 0)), 'constant')\n        diff = padded[:-2, :] - 2 * padded[1:-1, :] + padded[2:, :]\n        return (k / h**2) * diff\n\n    # 2. Main Time-Stepping Loop\n    while t  T:\n        # Clip dt by global max and to land on T\n        dt_attempt = min(dt, dt_max)\n        if t + dt_attempt > T:\n            dt_attempt = T - t\n        \n        # 3. Defect and Tolerance Calculation\n        u_norm = np.max(np.abs(u))\n        tol = atol + rtol * u_norm\n\n        if ky == 0.0 or kx == 0.0:\n            err_norm = 0.0\n        else:\n            d = (dt_attempt**2) * apply_Ax(apply_Ay(u, ky, hy), kx, hx)\n            err_norm = np.max(np.abs(d))\n\n        # 4. Accept/Reject Step\n        accepted = err_norm = tol\n\n        # 5. Calculate new step size\n        if err_norm  eps: # To handle err_norm == 0 or very small\n             factor = g_max\n        else:\n            factor_raw = safety * (tol / err_norm)**0.5\n            factor = max(g_min, min(g_max, factor_raw))\n        \n        dt_new = dt_attempt * factor\n\n        if accepted:\n            # Perform ADI step\n            # Y-sweep: (I - dt*Ay) v = u\n            if ky != 0.0:\n                cy = -dt_attempt * ky / hy**2\n                diag_y = 1.0 - 2.0 * cy\n                ab_y = np.zeros((3, Ny))\n                ab_y[0, 1:] = cy\n                ab_y[1, :] = diag_y\n                ab_y[2, :-1] = cy\n                v = solve_banded((1, 1), ab_y, u, overwrite_ab=True, overwrite_b=False)\n            else:\n                v = u\n\n            # X-sweep: (I - dt*Ax) u_new = v\n            if kx != 0.0:\n                cx = -dt_attempt * kx / hx**2\n                diag_x = 1.0 - 2.0 * cx\n                ab_x = np.zeros((3, Nx))\n                ab_x[0, 1:] = cx\n                ab_x[1, :] = diag_x\n                ab_x[2, :-1] = cx\n                u_new_T = solve_banded((1, 1), ab_x, v.T, overwrite_ab=True, overwrite_b=False)\n                u = u_new_T.T\n            else:\n                u = v\n            \n            t += dt_attempt\n            dt = dt_new\n        else:\n            rejected_steps += 1\n            # Retry with smaller step size\n            dt = dt_new\n            \n    return rejected_steps\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Controller constants\n    safety = 0.9\n    g_min = 0.2\n    g_max = 2.5\n    eps = 1e-300\n\n    test_cases = [\n        # Case 1: balanced diffusion\n        {\"kx\": 1.0, \"ky\": 1.0, \"Nx\": 32, \"Ny\": 32, \"T\": 0.1, \n         \"dt0\": 1e-4, \"dt_max\": 1e-2, \"rtol\": 1e-3, \"atol\": 1e-8},\n        # Case 2: anisotropic diffusion\n        {\"kx\": 1.0, \"ky\": 10.0, \"Nx\": 32, \"Ny\": 32, \"T\": 0.05,\n         \"dt0\": 5e-5, \"dt_max\": 5e-3, \"rtol\": 5e-4, \"atol\": 1e-8},\n        # Case 3: degenerate in y\n        {\"kx\": 1.0, \"ky\": 0.0, \"Nx\": 32, \"Ny\": 32, \"T\": 0.1,\n         \"dt0\": 1e-3, \"dt_max\": 2e-2, \"rtol\": 1e-3, \"atol\": 1e-8}\n    ]\n\n    results = []\n    for params in test_cases:\n        rejections = run_simulation(\n            kx=params[\"kx\"], ky=params[\"ky\"],\n            Nx=params[\"Nx\"], Ny=params[\"Ny\"],\n            T=params[\"T\"], dt0=params[\"dt0\"], dt_max=params[\"dt_max\"],\n            rtol=params[\"rtol\"], atol=params[\"atol\"],\n            safety=safety, g_min=g_min, g_max=g_max, eps=eps\n        )\n        results.append(rejections)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3363234"}, {"introduction": "The classical ADI method's power relies on the separability of the spatial operator, a condition that breaks down in many physical systems involving anisotropic diffusion with mixed derivatives like $u_{xy}$. This exercise ([@problem_id:3388352]) challenges you to analyze why the method fails in such cases and to identify a powerful, general strategy to restore its stability. This practice deepens your understanding of the method's theoretical underpinnings and its extension to more complex problems.", "problem": "Consider the two-dimensional heat equation with a constant, symmetric positive-definite diffusion tensor,\n$$\nu_t \\;=\\; \\nabla \\cdot \\big( \\mathbf{D} \\nabla u \\big) \\;=\\; a\\,u_{xx} \\;+\\; 2b\\,u_{xy} \\;+\\; c\\,u_{yy},\n$$\nwhere $a>0$, $c>0$, and $|b|\\sqrt{ac}$ so that $\\mathbf{D}=\\begin{pmatrix}a  b\\\\ b  c\\end{pmatrix}$ is symmetric positive-definite. Consider a uniform Cartesian grid with spacing $h$ in both directions on a square domain with periodic boundary conditions, and second-order central differences for the spatial derivatives that produce the semi-discrete system\n$$\n\\frac{d}{dt} \\mathbf{u}(t) \\;=\\; \\mathbf{L}\\,\\mathbf{u}(t) \\;=\\; \\big(\\mathbf{A}_x+\\mathbf{A}_y+\\mathbf{A}_{xy}\\big)\\,\\mathbf{u}(t),\n$$\nwhere $\\mathbf{A}_x$ discretizes $a\\,\\partial_{xx}$, $\\mathbf{A}_y$ discretizes $c\\,\\partial_{yy}$, and $\\mathbf{A}_{xy}$ discretizes $2b\\,\\partial_{xy}$. Let $\\Delta t>0$ be a time step. A classical Alternating Direction Implicit (ADI) method of Peaceman–Rachford type for operators without mixed derivatives splits the two-dimensional operator into one-dimensional factors and updates according to a two-stage process comprised of line solves in the $x$- and $y$-directions.\n\nPart 1. Using Fourier mode analysis on the periodic grid, explain why the classical ADI splitting that factors only $\\mathbf{A}_x$ and $\\mathbf{A}_y$ (and either omits $\\mathbf{A}_{xy}$ or treats it explicitly) fails to be unconditionally stable when $b\\neq 0$. In your explanation, identify the Fourier symbols of $\\mathbf{A}_x$, $\\mathbf{A}_y$, and $\\mathbf{A}_{xy}$ and reason from the sign properties of the mixed derivative symbol and the non-commutativity of the split operators why a product of one-dimensional resolvents cannot uniformly control the mixed term for all wave numbers and all $\\Delta t>0$.\n\nPart 2. Consider modifications that alter the operator factorization or representation. Which option correctly explains the failure mechanism in Part 1 and describes a modified factorization that restores unconditional stability, in the sense that the amplification factor for every Fourier mode has magnitude at most one for all $\\Delta t>0$?\n\nA. The classical ADI splitting remains unconditionally stable even with $u_{xy}$ because the mixed derivative term commutes with both $\\mathbf{A}_x$ and $\\mathbf{A}_y$ on a Cartesian grid, so the product of one-dimensional resolvents still reproduces the full resolvent. No modification is necessary.\n\nB. Stability loss originates from temporal stiffness; the remedy is to treat all terms explicitly using a high-order strong-stability-preserving Runge–Kutta method, which restores unconditional stability independently of the mixed derivative.\n\nC. The failure is due to omitting $\\mathbf{A}_{xy}$. One can restore stability by placing the entire mixed derivative implicitly into only one factor, for example approximating $\\mathbf{I}-\\Delta t(\\mathbf{A}_x+\\mathbf{A}_y+\\mathbf{A}_{xy})$ by $\\big(\\mathbf{I}-\\Delta t(\\mathbf{A}_x+\\mathbf{A}_{xy})\\big)\\big(\\mathbf{I}-\\Delta t\\,\\mathbf{A}_y\\big)$ so that standard line solves in $x$ and $y$ can still be used.\n\nD. The failure stems from the indefinite sign of the mixed-derivative Fourier symbol and the non-commutativity of the split operators, which prevents the product of one-dimensional resolvents from dominating the full resolvent uniformly. A modified factorization that restores unconditional stability is to diagonalize the diffusion tensor $\\mathbf{D}=\\mathbf{Q}^\\top\\boldsymbol{\\Lambda}\\,\\mathbf{Q}$ with an orthogonal matrix $\\mathbf{Q}$, change coordinates to the principal axes so that $u_t=\\lambda_1\\,u_{\\xi\\xi}+\\lambda_2\\,u_{\\eta\\eta}$ with $\\lambda_1,\\lambda_2>0$, and then apply the classical ADI split along the principal directions. In these rotated coordinates, there is no mixed derivative, and the Peaceman–Rachford ADI amplification factor becomes a product of one-dimensional factors that are bounded by one for all $\\Delta t>0$.", "solution": "The user has provided a problem statement regarding the stability of Alternating Direction Implicit (ADI) methods for the two-dimensional heat equation with a mixed derivative term. I will first validate the problem statement and then proceed to a full solution and evaluation of the options.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n*   **PDE:** The two-dimensional heat equation with a constant, symmetric positive-definite diffusion tensor $\\mathbf{D}$:\n    $$u_t \\;=\\; \\nabla \\cdot \\big( \\mathbf{D} \\nabla u \\big) \\;=\\; a\\,u_{xx} \\;+\\; 2b\\,u_{xy} \\;+\\; c\\,u_{yy}$$\n*   **Diffusion Tensor and Coefficients:** $\\mathbf{D}=\\begin{pmatrix}a  b\\\\ b  c\\end{pmatrix}$ is symmetric positive-definite, which implies $a>0$, $c>0$, and $\\det(\\mathbf{D}) = ac-b^2 > 0$, or $|b|\\sqrt{ac}$.\n*   **Discretization Setup:** A uniform Cartesian grid with spacing $h$ in both directions on a square domain with periodic boundary conditions.\n*   **Numerical Method:** Second-order central differences for spatial derivatives.\n*   **Semi-discrete System:** The spatial discretization leads to a system of ordinary differential equations:\n    $$\\frac{d}{dt} \\mathbf{u}(t) \\;=\\; \\mathbf{L}\\,\\mathbf{u}(t) \\;=\\; \\big(\\mathbf{A}_x+\\mathbf{A}_y+\\mathbf{A}_{xy}\\big)\\,\\mathbf{u}(t)$$\n    where $\\mathbf{A}_x$ discretizes $a\\,\\partial_{xx}$, $\\mathbf{A}_y$ discretizes $c\\,\\partial_{yy}$, and $\\mathbf{A}_{xy}$ discretizes $2b\\,\\partial_{xy}$.\n*   **Time Integration:** A time step $\\Delta t>0$ is used with a classical Peaceman–Rachford type ADI method.\n*   **Problem Objective:** Part 1 asks for an explanation of why the classical ADI splitting fails to be unconditionally stable when $b\\neq 0$. Part 2 asks for a correct explanation and a modified, unconditionally stable factorization.\n\n**Step 2: Validate Using Extracted Givens**\n\n*   **Scientifically Grounded:** The problem statement is firmly rooted in the field of numerical analysis for partial differential equations. The anisotropic heat equation is a fundamental model for diffusion processes. The conditions on the diffusion tensor $\\mathbf{D}$ are physically and mathematically correct for a well-posed diffusion problem. Fourier (von Neumann) stability analysis is the standard tool for analyzing finite difference methods on periodic domains. The issue of ADI instability for operators with mixed derivatives is a classic topic.\n*   **Well-Posed:** The problem is well-posed. It asks for a scientific explanation of a known phenomenon and the description of a valid solution, which exist and are well-established in the literature.\n*   **Objective:** The language is formal, precise, and objective.\n\n**Flaw Checklist:**\n1.  **Scientific or Factual Unsoundness:** None. The premises are sound.\n2.  **Non-Formalizable or Irrelevant:** None. The problem is formal and directly relevant to the stated topic.\n3.  **Incomplete or Contradictory Setup:** None. All necessary information for a Fourier analysis is provided (PDE, discretization type, boundary conditions).\n4.  **Unrealistic or Infeasible:** None. Anisotropic diffusion is a common physical phenomenon.\n5.  **Ill-Posed or Poorly Structured:** None. The question is clear and leads to a definite answer.\n6.  **Pseudo-Profound, Trivial, or Tautological:** None. The problem addresses a non-trivial conceptual issue in numerical methods.\n7.  **Outside Scientific Verifiability:** None. The claims can be verified through standard mathematical analysis.\n\n**Step 3: Verdict and Action**\n\nThe problem statement is **valid**. I will proceed with the solution.\n\n### Derivation and Option Analysis\n\nThe problem consists of two parts: explaining the failure of the classical ADI method for equations with mixed derivatives and identifying a stable modification.\n\n**Part 1: Explanation of Instability**\n\nWe perform a Fourier analysis (also known as von Neumann stability analysis) on the semi-discrete system. We consider a single Fourier mode of the form $u_{j,k}(t) = \\hat{u}(t)e^{i(j\\theta_x + k\\theta_y)}$, where $x_j=jh$, $y_k=kh$, and $\\theta_x = \\xi_p h$, $\\theta_y = \\eta_q h$ are the normalized wave numbers for a grid spacing $h$. Applying the second-order central difference operators to this mode yields their Fourier symbols (eigenvalues).\n\n1.  **Symbol of $\\mathbf{A}_x$**: The operator $\\mathbf{A}_x$ discretizes $a\\,\\partial_{xx}$. The central difference operator for $\\partial_{xx}$ is $(\\delta_x^2/h^2)u_{j,k} = (u_{j+1,k}-2u_{j,k}+u_{j-1,k})/h^2$. Its symbol is $\\frac{e^{i\\theta_x}-2+e^{-i\\theta_x}}{h^2} = \\frac{2(\\cos(\\theta_x)-1)}{h^2} = -\\frac{4}{h^2}\\sin^2(\\frac{\\theta_x}{2})$.\n    Thus, the symbol of $\\mathbf{A}_x$ is:\n    $$\\hat{A}_x(\\theta_x) = -\\frac{4a}{h^2}\\sin^2\\left(\\frac{\\theta_x}{2}\\right) \\le 0$$\n    This symbol is real and non-positive.\n\n2.  **Symbol of $\\mathbf{A}_y$**: Similarly, the symbol of $\\mathbf{A}_y$ (discretizing $c\\,\\partial_{yy}$) is:\n    $$\\hat{A}_y(\\theta_y) = -\\frac{4c}{h^2}\\sin^2\\left(\\frac{\\theta_y}{2}\\right) \\le 0$$\n    This symbol is also real and non-positive.\n\n3.  **Symbol of $\\mathbf{A}_{xy}$**: The operator $\\mathbf{A}_{xy}$ discretizes $2b\\,\\partial_{xy}$. The standard central difference for $\\partial_{xy}$ is $(\\delta_x\\delta_y/h^2)u_{j,k}=(u_{j+1,k+1}-u_{j+1,k-1}-u_{j-1,k+1}+u_{j-1,k-1})/(4h^2)$. Its symbol is $\\frac{(e^{i\\theta_x}-e^{-i\\theta_x})(e^{i\\theta_y}-e^{-i\\theta_y})}{4h^2} = \\frac{(2i\\sin\\theta_x)(2i\\sin\\theta_y)}{4h^2} = -\\frac{\\sin\\theta_x\\sin\\theta_y}{h^2}$.\n    Thus, the symbol of $\\mathbf{A}_{xy}$ is:\n    $$\\hat{A}_{xy}(\\theta_x, \\theta_y) = -\\frac{2b}{h^2}\\sin(\\theta_x)\\sin(\\theta_y)$$\n    This symbol is real, but its sign depends on the signs of $b$, $\\sin(\\theta_x)$, and $\\sin(\\theta_y)$. It is an **indefinite** symbol, meaning it can be positive for some wave numbers and negative for others (unless $b=0$).\n\nThe classical Peaceman–Rachford ADI method for $u_t = (A_x+A_y)u$ is unconditionally stable because the amplification factor for each mode is $g = \\frac{1+\\frac{\\Delta t}{2}\\hat{A}_x}{1-\\frac{\\Delta t}{2}\\hat{A}_x} \\cdot \\frac{1+\\frac{\\Delta t}{2}\\hat{A}_y}{1-\\frac{\\Delta t}{2}\\hat{A}_y}$. Since $\\hat{A}_x, \\hat{A}_y \\le 0$, each factor is a Cayley transform of a non-positive real number, which has magnitude less than or equal to $1$.\n\nWhen the mixed derivative term $\\mathbf{A}_{xy}$ is present, it must be accounted for. The problem states it is either \"omitted\" (which is incorrect) or \"treated explicitly\". A common explicit treatment within an ADI framework adds the term $\\Delta t \\mathbf{A}_{xy} \\mathbf{u}^n$ to the right-hand side. The amplification factor for such a scheme becomes:\n$$g(\\theta_x, \\theta_y) = \\frac{(1+\\frac{\\Delta t}{2}\\hat{A}_x)(1+\\frac{\\Delta t}{2}\\hat{A}_y)}{(1-\\frac{\\Delta t}{2}\\hat{A}_x)(1-\\frac{\\Delta t}{2}\\hat{A}_y)} + \\frac{\\Delta t \\hat{A}_{xy}}{(1-\\frac{\\Delta t}{2}\\hat{A}_x)(1-\\frac{\\Delta t}{2}\\hat{A}_y)}$$\nThe first term has magnitude $\\le 1$. The second term is the error term. For large $\\Delta t$, the denominator is of order $(\\Delta t)^2$, while the numerator is of order $\\Delta t$. The term goes to zero for $\\Delta t \\to \\infty$. However, this is not the full story. The stability of splitting methods is subtle. The core issue is that the stability of the ADI splitting for $A_x+A_y$ relies on the dissipativity (negative semi-definiteness) of $A_x$ and $A_y$. The operator $A_{xy}$ is not dissipative; it is indefinite. Any splitting that fails to treat this term implicitly in a balanced way can lead to growth for certain wave numbers and intermediate values of $\\Delta t$. The non-commutativity of the operators, particularly involving the non-dissipative $A_{xy}$, prevents the factorization from being stable. The product of 1D resolvents (the ADI update) cannot control the growth from the explicit, indefinite mixed term.\n\n**Part 2: A Stable Modification**\n\nThe most robust way to handle the mixed derivative term is to eliminate it from the PDE itself. This is possible by a change of coordinates. Since the diffusion tensor $\\mathbf{D}$ is symmetric and positive-definite, it is diagonalizable by an orthogonal matrix $\\mathbf{Q}$ (a rotation):\n$$ \\mathbf{D} = \\mathbf{Q} \\mathbf{\\Lambda} \\mathbf{Q}^\\top, \\quad \\text{where} \\quad \\mathbf{\\Lambda} = \\begin{pmatrix} \\lambda_1  0 \\\\ 0  \\lambda_2 \\end{pmatrix} $$\nThe eigenvalues $\\lambda_1, \\lambda_2$ are the principal diffusivities and are strictly positive. The columns of $\\mathbf{Q}$ are the orthogonal eigenvectors, which define the principal axes of diffusion.\nLet a new coordinate system $(\\xi, \\eta)$ be defined by this rotation: $\\begin{pmatrix} \\xi \\\\ \\eta \\end{pmatrix} = \\mathbf{Q}^\\top \\begin{pmatrix} x \\\\ y \\end{pmatrix}$.\nIn these new coordinates, the PDE transforms to a separable form:\n$$ u_t = \\lambda_1 u_{\\xi\\xi} + \\lambda_2 u_{\\eta\\eta} $$\nThis equation now involves no mixed derivative. We can apply the standard, unconditionally stable Peaceman–Rachford ADI method by splitting along the new principal directions $\\xi$ and $\\eta$. The operators to be split are $L_\\xi = \\lambda_1\\partial_{\\xi\\xi}$ and $L_\\eta = \\lambda_2\\partial_{\\eta\\eta}$. Discretizing on a grid aligned with the $(\\xi, \\eta)$ axes results in discrete operators $\\mathbf{A}_\\xi$ and $\\mathbf{A}_\\eta$ that are dissipative and commute. The resulting ADI scheme is unconditionally stable.\n\n---\n\n**Evaluation of Options**\n\n**A. The classical ADI splitting remains unconditionally stable even with $u_{xy}$ because the mixed derivative term commutes with both $\\mathbf{A}_x$ and $\\mathbf{A}_y$ on a Cartesian grid, so the product of one-dimensional resolvents still reproduces the full resolvent. No modification is necessary.**\nThis statement is fundamentally flawed. The classical ADI splitting, when applied to an equation with a mixed derivative that is treated explicitly, is known to be only conditionally stable, not unconditionally stable. The reasoning provided is also incorrect; even if the discrete operators commute (which they do for the specific central difference stencils on a uniform periodic grid), treating the indefinite $\\mathbf{A}_{xy}$ term explicitly leads to instability.\n**Verdict: Incorrect.**\n\n**B. Stability loss originates from temporal stiffness; the remedy is to treat all terms explicitly using a high-order strong-stability-preserving Runge–Kutta method, which restores unconditional stability independently of the mixed derivative.**\nThis is incorrect. The point of implicit methods like ADI is to overcome the severe stability constraint ($\\Delta t = O(h^2)$) imposed by stiffness when using explicit methods. No explicit method, including SSP-RK methods, can be unconditionally stable for the heat equation. Their stability regions are bounded, which always leads to a conditional stability requirement on $\\Delta t$.\n**Verdict: Incorrect.**\n\n**C. The failure is due to omitting $\\mathbf{A}_{xy}$. One can restore stability by placing the entire mixed derivative implicitly into only one factor, for example approximating $\\mathbf{I}-\\Delta t(\\mathbf{A}_x+\\mathbf{A}_y+\\mathbf{A}_{xy})$ by $\\big(\\mathbf{I}-\\Delta t(\\mathbf{A}_x+\\mathbf{A}_{xy})\\big)\\big(\\mathbf{I}-\\Delta t\\,\\mathbf{A}_y\\big)$ so that standard line solves in $x$ and $y$ can still be used.**\nThis is incorrect. The proposed factorization involves the matrix $\\mathbf{I}-\\Delta t(\\mathbf{A}_x+\\mathbf{A}_{xy})$. The operator $\\mathbf{A}_{xy}$ (with a standard 9-point stencil) couples grid points $(i, j)$ with their diagonal neighbors $(i\\pm 1, j\\pm 1)$. This means the matrix for this operator is not simply tridiagonal (or block-tridiagonal corresponding to line solves). A \"line solve\" in the $x$-direction would be coupled to the adjacent lines $j-1$ and $j+1$, destroying the primary computational advantage of ADI, which is to solve uncoupled 1D problems. Thus, the claim \"standard line solves can still be used\" is false.\n**Verdict: Incorrect.**\n\n**D. The failure stems from the indefinite sign of the mixed-derivative Fourier symbol and the non-commutativity of the split operators, which prevents the product of one-dimensional resolvents from dominating the full resolvent uniformly. A modified factorization that restores unconditional stability is to diagonalize the diffusion tensor $\\mathbf{D}=\\mathbf{Q}^\\top\\boldsymbol{\\Lambda}\\,\\mathbf{Q}$ with an orthogonal matrix $\\mathbf{Q}$, change coordinates to the principal axes so that $u_t=\\lambda_1\\,u_{\\xi\\xi}+\\lambda_2\\,u_{\\eta\\eta}$ with $\\lambda_1,\\lambda_2>0$, and then apply the classical ADI split along the principal directions. In these rotated coordinates, there is no mixed derivative, and the Peaceman–Rachford ADI amplification factor becomes a product of one-dimensional factors that are bounded by one for all $\\Delta t>0$.**\nThis option provides a correct and complete analysis. It accurately identifies the two main sources of instability: the indefinite nature of the mixed derivative operator's symbol and the inability of simple splitting schemes to handle this (framed here in terms of non-commutativity, which is the key issue in operator splitting theory). The proposed solution—rotating the coordinate system to eliminate the mixed derivative term—is the standard and most robust method to restore unconditional stability for ADI. After the rotation, the PDE is separable, and the classical ADI method performs as desired, with an amplification factor bounded by one for all time steps and wave numbers.\n**Verdict: Correct.**", "answer": "$$\\boxed{D}$$", "id": "3388352"}]}