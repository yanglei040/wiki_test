{"hands_on_practices": [{"introduction": "The foundation of any spectral method is the ability to represent functions as a series of basis polynomials. This exercise [@problem_id:3370275] explores this core task by having you compute the Chebyshev coefficients for the smooth function $f(x) = \\exp(x)$ and quantify the remarkable accuracy of the resulting truncated series approximation. By comparing analytical coefficients, derived from an elegant connection to Bessel functions, with those obtained via numerical quadrature, you will gain practical insight into both the theory and implementation of spectral approximation.", "problem": "Consider the Chebyshev polynomials of the first kind defined by $T_n(x) = \\cos(n \\arccos x)$ on the interval $[-1,1]$. For a sufficiently smooth function $f:[-1,1]\\to\\mathbb{R}$, the Chebyshev spectral expansion is the series\n$$\nf(x) \\sim \\frac{\\hat{f}_0}{2} + \\sum_{n=1}^{\\infty} \\hat{f}_n T_n(x),\n$$\nwhere the Chebyshev coefficients $\\hat{f}_n$ are defined by the orthogonality of $\\cos(n\\theta)$ on $[0,\\pi]$ and given by the integral representation\n$$\n\\hat{f}_n = \\frac{2}{\\pi}\\int_{0}^{\\pi} f(\\cos\\theta)\\,\\cos(n\\theta)\\,d\\theta, \\quad n\\ge 0,\n$$\nwith the angle $\\theta$ measured in radians. In Chebyshev spectral methods, the truncated expansion of degree $N$,\n$$\nf_N(x) := \\frac{\\hat{f}_0}{2} + \\sum_{n=1}^{N} \\hat{f}_n T_n(x),\n$$\nis used as a high-order approximation to $f(x)$.\n\nYou are asked to compute the Chebyshev coefficients for the specific function $f(x)=e^x$, construct the truncated series $f_{10}(x)$, and evaluate pointwise errors against $f(x)$ in specified scenarios. Your derivation and algorithm must begin from the fundamental definitions above and use only well-tested mathematical facts, not shortcut formulas.\n\nAngle unit specification: all angles must be handled in radians.\n\nImplement a complete, runnable program that performs the following computations:\n\n1. Using the most precise derivation available from first principles, compute the Chebyshev coefficients $\\hat{f}_n$ for $f(x)=e^x$ for $n=0,1,\\dots,10$, construct $f_{10}(x)$, and compute the absolute pointwise error $|f(0.5)-f_{10}(0.5)|$.\n\n2. Approximate the Chebyshev coefficients $\\hat{f}_n$ for $f(x)=e^x$ using numerical quadrature of the defining integral for $n=0,1,\\dots,10$ with a composite trapezoidal rule over $\\theta\\in[0,\\pi]$ using $M=16384$ equally spaced panels (i.e., $M+1$ nodes). Use these approximate coefficients to construct $f_{10}(x)$ and compute the absolute pointwise error $|f(0.5)-f_{10}(0.5)|$.\n\n3. Using the most precise coefficients from Item 1, compute the supremum norm error of $f_{10}(x)$ on $[-1,1]$, defined as $\\max_{x\\in[-1,1]} |f(x)-f_{10}(x)|$, by evaluating the error on a uniform grid of $K=20001$ points in $[-1,1]$ and taking the maximum absolute value.\n\nTest suite and answer specification:\n- Test Case 1 (happy path): Item 1 described above, output a single float equal to the absolute error at $x=0.5$.\n- Test Case 2 (numerical integration coverage): Item 2 described above, output a single float equal to the absolute error at $x=0.5$.\n- Test Case 3 (boundary coverage via supremum norm on a dense grid): Item 3 described above, output a single float equal to the computed maximum absolute error.\n\nFinal output format:\nYour program should produce a single line of output containing the results of the three test cases as a comma-separated list enclosed in square brackets, in the order [Test Case 1 result, Test Case 2 result, Test Case 3 result]. For example, \n$$\n[\\text{result1},\\text{result2},\\text{result3}]\n$$\nwhere each entry is a float.", "solution": "The problem statement is validated as scientifically grounded, well-posed, and objective. It is a standard problem in numerical analysis concerning the application of Chebyshev spectral methods. It is self-contained and free of contradictions or ambiguities.\n\nThe problem requires the analysis of the Chebyshev spectral approximation for the function $f(x) = e^x$ on the interval $x \\in [-1, 1]$. The Chebyshev series approximation of degree $N$ is given by\n$$\nf_N(x) = \\frac{\\hat{f}_0}{2} + \\sum_{n=1}^{N} \\hat{f}_n T_n(x)\n$$\nwhere $T_n(x)$ are the Chebyshev polynomials of the first kind and $\\hat{f}_n$ are the Chebyshev coefficients. The coefficients are defined by the integral\n$$\n\\hat{f}_n = \\frac{2}{\\pi}\\int_{0}^{\\pi} f(\\cos\\theta)\\,\\cos(n\\theta)\\,d\\theta, \\quad n \\ge 0.\n$$\n\nFor the specific function $f(x) = e^x$, the integrand becomes $f(\\cos\\theta) = e^{\\cos\\theta}$. The expression for the coefficients is therefore\n$$\n\\hat{f}_n = \\frac{2}{\\pi}\\int_{0}^{\\pi} e^{\\cos\\theta}\\cos(n\\theta)\\,d\\theta.\n$$\nThis integral is directly related to a standard integral representation of the modified Bessel function of the first kind, $I_n(z)$, which for integer order $n$ is given by\n$$\nI_n(z) = \\frac{1}{\\pi} \\int_0^\\pi e^{z \\cos\\theta} \\cos(n\\theta) d\\theta.\n$$\nBy setting $z=1$, we can establish a direct relationship between the Chebyshev coefficients of $e^x$ and the values of the modified Bessel functions.\n$$\n\\hat{f}_n = 2 \\left( \\frac{1}{\\pi} \\int_0^\\pi e^{1 \\cdot \\cos\\theta} \\cos(n\\theta) d\\theta \\right) = 2 I_n(1).\n$$\nThis provides an analytical expression for the \"exact\" coefficients required in Test Cases 1 and 3. These values can be computed to high precision using standard scientific libraries.\n\nTo evaluate the truncated series $f_N(x)$, we employ Clenshaw's algorithm, which is a stable and efficient method for summing series of polynomials that satisfy a three-term recurrence relation. The Chebyshev polynomials satisfy the recurrence\n$$\nT_0(x) = 1, \\quad T_1(x) = x, \\quad T_{n+1}(x) = 2x T_n(x) - T_{n-1}(x) \\text{ for } n \\ge 1.\n$$\nLet the series to be evaluated be $S(x) = \\sum_{k=0}^{N} c'_k T_k(x)$, where $c'_0 = \\hat{f}_0/2 = I_0(1)$ and $c'_k = \\hat{f}_k = 2I_k(1)$ for $k \\ge 1$. Clenshaw's algorithm proceeds as follows:\nInitialize $b_{N+2} = 0$ and $b_{N+1} = 0$.\nThen, for $k = N, N-1, \\dots, 1$, compute\n$$\nb_k = c'_k + 2x b_{k+1} - b_{k+2}.\n$$\nThe value of the series is then given by $S(x) = c'_0 + x b_1 - b_2$.\n\n**Test Case 1: Pointwise error with analytically derived coefficients**\nThe Chebyshev coefficients $\\hat{f}_n$ for $n=0, 1, \\dots, 10$ are computed using the identity $\\hat{f}_n = 2 I_n(1)$. The numerical values for $I_n(1)$ are obtained from the `scipy.special.iv` function. These coefficients are used to construct the Clenshaw coefficient array $c'$. The polynomial $f_{10}(x)$ is then evaluated at $x=0.5$ using Clenshaw's algorithm. The absolute error is calculated as $|e^{0.5} - f_{10}(0.5)|$.\n\n**Test Case 2: Pointwise error with numerically integrated coefficients**\nThe Chebyshev coefficients $\\hat{f}_n$ for $n=0, 1, \\dots, 10$ are approximated by numerically evaluating the defining integral. The composite trapezoidal rule is applied to the integral $\\int_{0}^{\\pi} e^{\\cos\\theta}\\cos(n\\theta)\\,d\\theta$ over a uniform grid of $\\theta$ values. The interval $[0, \\pi]$ is divided into $M=16384$ panels, creating $M+1$ nodes $\\theta_j = j\\pi/M$ for $j=0, \\dots, M$. The integral $I$ of a function $g(\\theta)$ is approximated by\n$$\nI \\approx h \\left( \\frac{g(\\theta_0) + g(\\theta_M)}{2} + \\sum_{j=1}^{M-1} g(\\theta_j) \\right),\n$$\nwhere $h = \\pi/M$ is the step size. For each $n$, the corresponding integrand $g_n(\\theta) = e^{\\cos\\theta}\\cos(n\\theta)$ is used. The resulting approximate coefficients, $\\hat{f}_n^{(\\text{num})}$, are then used to construct a new polynomial approximation $f_{10}^{(\\text{num})}(x)$. This polynomial is evaluated at $x=0.5$ and the absolute error $|e^{0.5} - f_{10}^{(\\text{num})}(0.5)|$ is computed.\n\n**Test Case 3: Supremum norm error**\nThis test case requires computing an approximation to the supremum norm of the error, defined as $\\max_{x\\in[-1,1]} |f(x)-f_{10}(x)|$. The approximation is found by evaluating the error on a dense, uniform grid of $K=20001$ points spanning the interval $[-1, 1]$. The polynomial $f_{10}(x)$ is constructed using the analytically derived coefficients from Test Case 1. A vectorized version of Clenshaw's algorithm is used to efficiently evaluate $f_{10}(x_j)$ at all grid points $x_j$ simultaneously. The absolute error $|e^{x_j} - f_{10}(x_j)|$ is computed for each point, and the maximum value among these errors is reported as the result.", "answer": "```python\nimport numpy as np\nfrom scipy.special import iv\n\ndef clenshaw_eval(x, c_prime):\n    \"\"\"\n    Evaluates a Chebyshev series using Clenshaw's algorithm.\n    Can handle both scalar and NumPy array inputs for x.\n    \n    Args:\n        x (float or np.ndarray): The point(s) at which to evaluate the series.\n        c_prime (np.ndarray): The coefficients of the series, where c_prime[k]\n                             is the coefficient of T_k(x). The series is\n                             assumed to be sum_{k=0 to N} c_prime[k] T_k(x).\n\n    Returns:\n        float or np.ndarray: The value(s) of the Chebyshev series.\n    \"\"\"\n    N = len(c_prime) - 1\n    if N < 0:\n        return 0.0 if not isinstance(x, np.ndarray) else np.zeros_like(x)\n\n    # Ensure x is a NumPy array for vectorized operations\n    is_scalar = not isinstance(x, np.ndarray)\n    if is_scalar:\n        x_arr = np.array([x])\n    else:\n        x_arr = x\n\n    # Initialize b_{N+2} and b_{N+1}\n    b_k_plus_2 = np.zeros_like(x_arr)\n    b_k_plus_1 = np.zeros_like(x_arr)\n\n    # Recurrence loop\n    for k in range(N, 0, -1):\n        b_k = c_prime[k] + 2 * x_arr * b_k_plus_1 - b_k_plus_2\n        b_k_plus_2 = b_k_plus_1\n        b_k_plus_1 = b_k\n    \n    # Final value calculation\n    # val = c_prime[0] * T_0(x) + b_1 * T_1(x) - b_2 * T_0(x)\n    val = c_prime[0] + x_arr * b_k_plus_1 - b_k_plus_2\n    \n    return val.item() if is_scalar else val\n\ndef solve():\n    \"\"\"\n    Solves the three test cases as described in the problem statement.\n    \"\"\"\n    results = []\n    \n    # --- Parameters from the problem statement ---\n    N_degree = 10\n    M_panels = 16384\n    K_points = 20001\n    x_eval_point = 0.5\n\n    # --- Test Case 1: Pointwise error with analytically derived coefficients ---\n\n    # n = 0, 1, ..., N\n    n_values = np.arange(0, N_degree + 1)\n\n    # Exact coefficients f_hat_n = 2 * I_n(1)\n    f_hat_exact = 2 * iv(n_values, 1.0)\n    \n    # Create coefficients for Clenshaw's algorithm (c'_0 = f_hat_0 / 2)\n    c_prime_exact = np.copy(f_hat_exact)\n    c_prime_exact[0] /= 2.0\n    \n    # Evaluate at x = 0.5\n    f_val_exact_pt = np.exp(x_eval_point)\n    f10_val_exact_pt = clenshaw_eval(x_eval_point, c_prime_exact)\n    \n    error1 = np.abs(f_val_exact_pt - f10_val_exact_pt)\n    results.append(error1)\n\n    # --- Test Case 2: Pointwise error with numerically integrated coefficients ---\n    \n    theta = np.linspace(0, np.pi, M_panels + 1)\n    exp_cos_theta = np.exp(np.cos(theta))\n    \n    f_hat_num = np.zeros(N_degree + 1)\n    for n in n_values:\n        integrand = exp_cos_theta * np.cos(n * theta)\n        integral = np.trapz(integrand, theta)\n        f_hat_num[n] = (2.0 / np.pi) * integral\n    \n    # Create coefficients for Clenshaw's algorithm\n    c_prime_num = np.copy(f_hat_num)\n    c_prime_num[0] /= 2.0\n    \n    # Evaluate at x = 0.5\n    f10_val_num_pt = clenshaw_eval(x_eval_point, c_prime_num)\n    \n    error2 = np.abs(f_val_exact_pt - f10_val_num_pt)\n    results.append(error2)\n\n    # --- Test Case 3: Supremum norm error ---\n    \n    x_grid = np.linspace(-1.0, 1.0, K_points)\n    \n    # Use exact coefficients from Test Case 1\n    f10_on_grid = clenshaw_eval(x_grid, c_prime_exact)\n    f_on_grid = np.exp(x_grid)\n    \n    error3 = np.max(np.abs(f_on_grid - f10_on_grid))\n    results.append(error3)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3370275"}, {"introduction": "Once a function is represented in a polynomial basis, a crucial next step is to compute its derivative, a fundamental operation for solving differential equations. This practice [@problem_id:3370324] guides you through constructing differentiation matrices from first principles for both Chebyshev and Legendre-Gauss-Lobatto nodes. This exercise demystifies the \"black box\" of spectral differentiation, forcing a deeper engagement with the properties of Lagrange interpolants and the importance of node distribution.", "problem": "Consider the polynomial spectral differentiation of a smooth function on the interval $[-1,1]$. Let $N$ denote the polynomial degree and let the $N+1$ interpolation nodes be denoted by $\\{x_j\\}_{j=0}^{N}$. Define the Lagrange basis polynomials $\\{\\ell_j(x)\\}_{j=0}^{N}$ associated with these nodes by the conditions $\\ell_j(x_k)=\\delta_{jk}$, where $\\delta_{jk}$ is the Kronecker delta. The spectral differentiation matrix $D\\in\\mathbb{R}^{(N+1)\\times(N+1)}$ is defined by evaluating the derivatives of the basis polynomials at the nodes, so that the vector of derivative values of an interpolating polynomial $p(x)=\\sum_{j=0}^{N} u_j \\ell_j(x)$ at the nodes is $Dp$, where each entry is formed from $\\sum_{j=0}^{N} u_j \\ell_j'(x_i)$.\n\nThe base for this construction is the fundamental definition of polynomial interpolation and its Lagrange form: any polynomial of degree at most $N$ that interpolates data $\\{(x_j, u_j)\\}_{j=0}^{N}$ is uniquely represented as $p(x)=\\sum_{j=0}^{N} u_j \\ell_j(x)$, and by linearity of differentiation, $p'(x)=\\sum_{j=0}^{N} u_j \\ell_j'(x)$. The derivative values at the nodes are then determined by the matrix with entries $D_{ij}=\\ell_j'(x_i)$. You must construct $D$ directly from these principles, without using pre-tabulated closed-form formulas for any special node set.\n\nYou will use two classical spectral grids:\n- Chebyshev–Gauss–Lobatto nodes of the first kind (CGL): $x_j=\\cos\\left(\\frac{\\pi j}{N}\\right)$ for $j=0,1,\\dots,N$.\n- Legendre–Gauss–Lobatto nodes (LGL): $x_0=-1$, $x_N=1$, and the interior nodes $\\{x_j\\}_{j=1}^{N-1}$ are the $N-1$ distinct roots in $(-1,1)$ of the derivative of the Legendre polynomial of degree $N$, $P_N'(x)=0$. Use the Legendre differential equation to devise a Newton iteration that refines initial guesses for these interior roots. The Legendre differential equation is $(1-x^2)P_N''(x)-2xP_N'(x)+N(N+1)P_N(x)=0$. You must use this relationship to obtain a Newton update that does not rely on pre-tabulated formulas for the roots.\n\nFor a target function $u(x)=\\sin(5x)$ (angles in radians), approximate $u'(x)$ at the nodes by applying the spectral differentiation matrix $D$ to the nodal values of $u(x)$, and compare this approximation to the exact derivative $u'(x)=5\\cos(5x)$ at the same nodes. For each case, compute the $\\ell^\\infty$ error defined as\n$$\nE_{\\infty}=\\max_{0\\le i\\le N} \\left| (Du)_i - u'(x_i) \\right|.\n$$\n\nYour program must implement the construction of $D$ from first principles using the Lagrange basis derivative evaluated at the nodes (you are allowed to use the general barycentric Lagrange machinery, but you must not use any explicit closed-form differentiation matrix tailored to a specific node family). For the Legendre–Gauss–Lobatto nodes, initialize the Newton iteration for the interior roots using the Chebyshev–Gauss–Lobatto nodes and derive the Newton update using the Legendre differential equation.\n\nUse the following test suite, which varies both the node family and the degree:\n1. CGL with $N=8$.\n2. CGL with $N=32$.\n3. CGL with $N=64$.\n4. LGL with $N=8$.\n5. LGL with $N=32$.\n6. LGL with $N=64$.\n\nFor each test case, the output must be the single floating-point number $E_{\\infty}$. Your program should produce a single line of output containing the six results as a comma-separated list enclosed in square brackets (e.g., \"[e1,e2,e3,e4,e5,e6]\"). No other text should be printed. All angles are in radians. No physical units apply.", "solution": "The problem requires the construction of spectral differentiation matrices for Chebyshev and Legendre grids and their application to approximate the derivative of a given function. The construction must be performed from first principles, without recourse to known closed-form expressions for the differentiation matrices themselves. The core of the problem lies in the correct implementation of the node generation algorithms, particularly for Legendre–Gauss–Lobatto nodes, and the subsequent construction of the differentiation matrix using the general properties of Lagrange interpolants.\n\n### 1. General Formulation of the Spectral Differentiation Matrix\n\nGiven a set of $N+1$ distinct interpolation nodes $\\{x_j\\}_{j=0}^{N}$ on the interval $[-1, 1]$, any polynomial $p(x)$ of degree at most $N$ can be uniquely represented using the Lagrange basis polynomials $\\{\\ell_j(x)\\}_{j=0}^{N}$ as:\n$$\np(x) = \\sum_{j=0}^{N} u_j \\ell_j(x)\n$$\nwhere $u_j = p(x_j)$ are the function values at the nodes, and the basis polynomials satisfy the property $\\ell_j(x_k) = \\delta_{jk}$. The derivative of this polynomial is given by the linear combination of the derivatives of the basis polynomials:\n$$\np'(x) = \\sum_{j=0}^{N} u_j \\ell_j'(x)\n$$\nEvaluating this derivative at the interpolation nodes $x_i$ yields:\n$$\np'(x_i) = \\sum_{j=0}^{N} u_j \\ell_j'(x_i)\n$$\nThis relationship can be expressed as a matrix-vector product, $\\boldsymbol{u}' = D\\boldsymbol{u}$, where $\\boldsymbol{u}$ is the vector of nodal values $[u_0, u_1, \\dots, u_N]^T$, $\\boldsymbol{u}'$ is the vector of derivative values at the nodes $[p'(x_0), \\dots, p'(x_N)]^T$, and $D$ is the spectral differentiation matrix. The entries of this matrix are given by:\n$$\nD_{ij} = \\ell_j'(x_i)\n$$\nThe problem forbids the use of pre-computed formulas for $D_{ij}$ for specific node families but allows the use of general barycentric machinery. The Lagrange basis polynomial is defined as $\\ell_j(x) = \\prod_{k=0, k \\neq j}^{N} \\frac{x-x_k}{x_j-x_k}$. A general and stable method to compute its derivative at the nodes involves barycentric weights.\n\nThe barycentric weight $w_j$ for each node $x_j$ is defined from first principles as:\n$$\nw_j = \\frac{1}{\\prod_{k=0, k \\neq j}^{N} (x_j - x_k)}\n$$\nUsing these weights, the entries of the differentiation matrix can be expressed as:\n$$\nD_{ij} = \\frac{w_j/w_i}{x_i - x_j} \\quad \\text{for } i \\neq j\n$$\nFor the diagonal entries $D_{ii}$, one could use the formula $D_{ii} = \\sum_{k=0, k \\neq i}^{N} \\frac{1}{x_i-x_k}$. However, a more numerically robust approach is to utilize the property that the derivative of a constant must be zero. The constant function $f(x)=1$ is interpolated exactly by $p(x)=1$, which corresponds to a vector of nodal values $\\boldsymbol{u} = [1, 1, \\dots, 1]^T$. Its derivative is zero everywhere, which implies that $D\\boldsymbol{1} = \\boldsymbol{0}$. This means that the sum of each row of the differentiation matrix must be zero:\n$$\n\\sum_{j=0}^{N} D_{ij} = 0 \\quad \\text{for each } i = 0, \\dots, N\n$$\nFrom this property, we can compute the diagonal elements as the negative sum of the off-diagonal elements in the same row:\n$$\nD_{ii} = - \\sum_{j=0, j \\neq i}^{N} D_{ij}\n$$\nThis set of formulas provides a general algorithm to construct $D$ for any set of distinct nodes.\n\n### 2. Node Generation and Matrix Construction\n\nWe will apply this general procedure to two specific sets of nodes.\n\n#### 2.1. Chebyshev–Gauss–Lobatto (CGL) Nodes\nThe CGL nodes are the extrema of the Chebyshev polynomial of the first kind, $T_N(x)$. They are given by the explicit formula:\n$$\nx_j = \\cos\\left(\\frac{\\pi j}{N}\\right) \\quad \\text{for } j=0, 1, \\dots, N\n$$\nFor a given degree $N$, we first generate these $N+1$ nodes. Then, we compute the barycentric weights $w_j$ for each node using the fundamental product definition. Finally, we construct the CGL differentiation matrix $D^{\\text{CGL}}$ using the general barycentric formulas for $D_{ij}$.\n\n#### 2.2. Legendre–Gauss–Lobatto (LGL) Nodes\nThe LGL nodes include the endpoints of the interval, $x_0 = -1$ and $x_N = 1$. The $N-1$ interior nodes, $\\{x_j\\}_{j=1}^{N-1}$, are the roots of $P_N'(x)$, where $P_N(x)$ is the Legendre polynomial of degree $N$.\n\nThe problem mandates finding these roots via Newton's method, with initial guesses provided by the interior CGL nodes. The Newton iteration for finding a root of a function $f(x)$ is $x_{k+1} = x_k - f(x_k)/f'(x_k)$. For our case, $f(x) = P_N'(x)$, so the iteration is:\n$$\nx_{k+1} = x_k - \\frac{P_N'(x_k)}{P_N''(x_k)}\n$$\nWe must derive an expression for the update term using the Legendre differential equation:\n$$\n(1-x^2)P_N''(x) - 2xP_N'(x) + N(N+1)P_N(x) = 0\n$$\nSolving for $P_N''(x)$ yields:\n$$\nP_N''(x) = \\frac{2xP_N'(x) - N(N+1)P_N(x)}{1-x^2}\n$$\nSubstituting this into the Newton iteration gives the update step:\n$$\nx_{k+1} = x_k - \\frac{P_N'(x_k)}{\\frac{2x_k P_N'(x_k) - N(N+1)P_N(x_k)}{1-x_k^2}} = x_k - \\frac{(1-x_k^2)P_N'(x_k)}{2x_k P_N'(x_k) - N(N+1)P_N(x_k)}\n$$\nTo implement this iteration, we need to evaluate $P_N(x)$ and $P_N'(x)$. Values of Legendre polynomials $P_k(x)$ can be computed using the three-term recurrence relation, or standard library functions. The derivative $P_N'(x)$ can be found efficiently using the identity:\n$$\n(1-x^2)P_N'(x) = N(P_{N-1}(x) - xP_N(x))\n$$\nThe procedure for generating LGL nodes is:\n1. Set the endpoints $x_0 = -1$ and $x_N = 1$.\n2. For the interior nodes, take the initial guesses $x_j^{(0)} = \\cos(\\frac{\\pi j}{N})$ for $j=1, \\dots, N-1$.\n3. For each guess, iterate using the derived Newton update formula until the root converges to a desired tolerance. This requires evaluating $P_N(x)$ and $P_{N-1}(x)$ at each step.\n4. Collect the endpoints and the converged interior roots to form the set of LGL nodes $\\{x_j\\}_{j=0}^{N}$.\n5. With the nodes determined, the LGL differentiation matrix $D^{\\text{LGL}}$ is constructed using the same general barycentric method as for the CGL case.\n\n### 3. Error Calculation\n\nFor each test case (a node family and a degree $N$):\n1.  The appropriate set of nodes $\\{x_j\\}$ is generated.\n2.  The corresponding differentiation matrix $D$ is constructed.\n3.  The target function $u(x) = \\sin(5x)$ is evaluated at the nodes to form the vector $\\boldsymbol{u}$.\n4.  The numerical approximation of the derivative at the nodes is calculated via the matrix-vector product $\\boldsymbol{u}'_{approx} = D\\boldsymbol{u}$.\n5.  The exact derivative, $u'(x) = 5\\cos(5x)$, is evaluated at the nodes to form the vector $\\boldsymbol{u}'_{exact}$.\n6.  The $\\ell^\\infty$ error is computed as the maximum absolute difference between the approximated and exact derivative values:\n    $$\n    E_{\\infty} = \\max_{0\\le i\\le N} \\left| (\\boldsymbol{u}'_{approx})_i - (\\boldsymbol{u}'_{exact})_i \\right|\n    $$\nThis procedure is repeated for all specified test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import eval_legendre\n\ndef get_cgl_nodes(N):\n    \"\"\"Generates Chebyshev-Gauss-Lobatto nodes.\"\"\"\n    if N == 0:\n        return np.array([0.0])\n    j = np.arange(N + 1)\n    nodes = np.cos(np.pi * j / N)\n    return nodes\n\ndef get_lgl_nodes(N, tol=1e-15, max_iter=100):\n    \"\"\"\n    Generates Legendre-Gauss-Lobatto nodes.\n    The interior nodes are the roots of P_N'(x), found via Newton's method.\n    \"\"\"\n    if N == 0:\n        return np.array([0.0])\n    if N == 1:\n        return np.array([-1.0, 1.0])\n    \n    nodes = np.zeros(N + 1)\n    nodes[0] = -1.0\n    nodes[N] = 1.0\n    \n    # Initial guesses for interior roots are interior CGL nodes\n    j_int = np.arange(1, N)\n    guesses = np.cos(np.pi * j_int / N)\n    \n    for i in range(len(guesses)):\n        x_k = guesses[i]\n        \n        for _ in range(max_iter):\n            # The formulas are valid for x in (-1, 1).\n            # Newton iteration may push x_k slightly outside, clip it.\n            if abs(x_k) > 1.0:\n                x_k = np.sign(x_k)\n\n            # Evaluate Legendre polynomials P_N(x) and P_{N-1}(x)\n            PN_val = eval_legendre(N, x_k)\n            PN_minus_1_val = eval_legendre(N - 1, x_k)\n            \n            # Derivative P_N'(x) using relation (1-x^2)P_N'(x) = N(P_{N-1}(x) - xP_N(x))\n            dPN_val = N * (PN_minus_1_val - x_k * PN_val) / (1 - x_k**2)\n\n            # Newton update for a root of P_N'(x), derived from Legendre DE.\n            # update = (1-x^2)P_N'(x) / (2xP_N'(x) - N(N+1)P_N(x))\n            numerator = (1 - x_k**2) * dPN_val\n            denominator = 2 * x_k * dPN_val - N * (N + 1) * PN_val\n            \n            if abs(denominator) < 1e-14:\n                # This may happen if the guess is already a root of the denominator.\n                # In such cases, the iteration is stuck; we just break.\n                break\n                \n            update = numerator / denominator\n            x_k -= update\n            \n            if abs(update) < tol:\n                break\n        \n        nodes[i + 1] = x_k\n        \n    nodes.sort() # Ensure nodes are in descending order (or ascending)\n    return nodes\n\ndef build_diff_matrix(nodes):\n    \"\"\"\n    Constructs the spectral differentiation matrix from first principles\n    using the barycentric formulation for any set of nodes.\n    \"\"\"\n    N = len(nodes) - 1\n    if N == 0:\n        return np.array([[0.0]])\n        \n    D = np.zeros((N + 1, N + 1))\n    \n    # Calculate barycentric weights from their fundamental definition\n    weights = np.zeros(N + 1)\n    for j in range(N + 1):\n        # Create an array of differences (x_j - x_k) for k != j\n        diffs = nodes[j] - np.delete(nodes, j)\n        weights[j] = 1.0 / np.prod(diffs)\n\n    # Off-diagonal entries using D_ij = (w_j/w_i) / (x_i - x_j)\n    for i in range(N + 1):\n        for j in range(N + 1):\n            if i != j:\n                D[i, j] = (weights[j] / weights[i]) / (nodes[i] - nodes[j])\n    \n    # Diagonal entries using the row-sum property: D_ii = -sum(D_ij) for j != i\n    for i in range(N + 1):\n        D[i, i] = -np.sum(D[i, :])\n        \n    return D\n\ndef compute_error(node_type, N):\n    \"\"\"\n    Main logic to compute the l-infinity error for a given case.\n    \"\"\"\n    if node_type == 'cgl':\n        nodes = get_cgl_nodes(N)\n    elif node_type == 'lgl':\n        nodes = get_lgl_nodes(N)\n    else:\n        raise ValueError(\"Unknown node type\")\n\n    D = build_diff_matrix(nodes)\n    \n    # Target function u(x) and its exact derivative u'(x)\n    u_func = lambda x: np.sin(5 * x)\n    du_exact_func = lambda x: 5 * np.cos(5 * x)\n    \n    # Evaluate at the nodes\n    u_vals = u_func(nodes)\n    du_exact_vals = du_exact_func(nodes)\n    \n    # Approximate derivative using the differentiation matrix\n    du_approx_vals = D @ u_vals\n    \n    # Compute the L-infinity error\n    error = np.max(np.abs(du_approx_vals - du_exact_vals))\n    return error\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ('cgl', 8),\n        ('cgl', 32),\n        ('cgl', 64),\n        ('lgl', 8),\n        ('lgl', 32),\n        ('lgl', 64),\n    ]\n\n    results = []\n    for case in test_cases:\n        node_type, N = case\n        error = compute_error(node_type, N)\n        results.append(f\"{error:.15e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3370324"}, {"introduction": "We now combine the concepts of function approximation and differentiation to solve a simple yet illustrative boundary value problem. This exercise [@problem_id:3370311] challenges you to implement the spectral element method for a one-dimensional Poisson equation, starting from its weak formulation. By building and assembling element matrices on a partitioned domain, you will experience firsthand how the high-order accuracy of local polynomial bases translates into a powerful and efficient numerical solver.", "problem": "Consider the boundary value problem for the one-dimensional Poisson equation on the interval $[0,1]$: find $u(x)$ such that $-u''(x) = x$ for $x \\in (0,1)$ with homogeneous Dirichlet boundary conditions $u(0) = 0$ and $u(1) = 0$. Starting from the weak formulation that seeks $u$ in the Sobolev space of square integrable functions with square integrable derivative and zero trace at the endpoints, denoted $H_0^1([0,1])$, such that for all test functions $v \\in H_0^1([0,1])$,\n$$\n\\int_{0}^{1} u'(x) \\, v'(x) \\, dx = \\int_{0}^{1} x \\, v(x) \\, dx,\n$$\nconstruct a spectral element approximation. Partition the domain $[0,1]$ into $E$ uniform elements. On each element, approximate $u$ by a polynomial of degree $p=4$ using a nodal basis at the Legendre-Gauss-Lobatto points on the reference element $[-1,1]$, and use the standard mapping from the reference element to physical coordinates to assemble a global $C^0$ conforming approximation. Use quadrature rules that are consistent with the chosen nodal points to approximate the element integrals appearing in the weak form. Impose the essential (Dirichlet) boundary conditions by eliminating the corresponding degrees of freedom.\n\nYour program must implement the above procedure to compute the global nodal values of the spectral element approximation for several choices of the number of elements $E$, with polynomial degree fixed at $p=4$. The following test suite specifies the values of $E$ to use:\n- Test case 1 (happy path): $E = 1$.\n- Test case 2 (refined mesh): $E = 2$.\n- Test case 3 (significant refinement edge case): $E = 5$.\n\nFor each test case, the output should be the list of nodal values of the computed spectral element solution ordered from left ($x=0$) to right ($x=1$). No physical units are involved in this problem.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each result is itself a list of floating-point numbers representing nodal values, for example, $[ [\\dots], [\\dots], [\\dots] ]$. Concretely, the exact required output format is a single line with no spaces: one bracketed list containing three bracketed sublists, one per test case, each sublist containing the nodal values in order from $x=0$ to $x=1$.", "solution": "The user wants to solve the one-dimensional Poisson equation $-u''(x) = x$ on the domain $[0,1]$ with homogeneous Dirichlet boundary conditions $u(0)=0$ and $u(1)=0$, using the spectral element method.\n\n### Step 1: Extract Givens\n- **Governing Equation**: $-u''(x) = x$ for $x \\in (0,1)$.\n- **Boundary Conditions**: $u(0)=0$, $u(1)=0$.\n- **Weak Formulation**: Find $u \\in H_0^1([0,1])$ such that for all $v \\in H_0^1([0,1])$, $\\int_{0}^{1} u'(x) \\, v'(x) \\, dx = \\int_{0}^{1} x \\, v(x) \\, dx$.\n- **Numerical Method**: Spectral Element Method.\n- **Domain Discretization**: The domain $[0,1]$ is partitioned into $E$ uniform elements.\n- **Approximation Space**: Within each element, the solution is approximated by a polynomial of degree $p=4$.\n- **Basis**: A nodal basis defined by the Legendre-Gauss-Lobatto (LGL) points on the reference element $[-1,1]$.\n- **Assembly**: A global $C^0$ conforming approximation is constructed by \"gluing\" elements together.\n- **Integration**: Quadrature rules based on the LGL nodes are used to evaluate integrals in the weak form.\n- **Boundary Condition Enforcement**: Essential (Dirichlet) boundary conditions are imposed by eliminating the corresponding degrees of freedom from the global system of equations.\n- **Test Cases**: The number of elements $E$ will be $1$, $2$, and $5$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is subjected to validation against the established criteria.\n\n- **Scientifically Grounded**: The problem is a standard application of the spectral element method to a classic elliptic boundary value problem (the Poisson equation). The mathematical framework, including the weak formulation in a Sobolev space and the specifics of the spectral element method (LGL nodes, reference element mapping, quadrature), is well-established in the field of numerical analysis for partial differential equations.\n- **Well-Posed**: The underlying boundary value problem is well-posed and admits a unique solution by the Lax-Milgram theorem. The specified numerical scheme (Galerkin method with a specific choice of basis and test functions) is standard and leads to a non-singular linear system for the unknown nodal values, thus ensuring a unique numerical solution exists.\n- **Objective**: The problem is stated in precise, formal mathematical language, free from any subjectivity or ambiguity.\n\nThe problem does not exhibit any of the invalidity flaws:\n1.  **Scientific Unsoundness**: The problem is mathematically and scientifically sound.\n2.  **Non-Formalizable/Irrelevant**: The problem is a formal and relevant task in numerical methods.\n3.  **Incomplete/Contradictory**: All necessary parameters ($p=4$), methods (LGL-based SEM), and test cases ($E=1,2,5$) are provided. The setup is self-consistent.\n4.  **Unrealistic/Infeasible**: This is a purely mathematical problem; physical realism is not applicable.\n5.  **Ill-Posed/Poorly Structured**: The problem is well-posed.\n6.  **Pseudo-Profound/Trivial**: The problem requires a non-trivial implementation of the spectral element method, involving concepts like reference-to-physical mapping, element matrix calculation, global assembly, and boundary condition enforcement.\n7.  **Outside Scientific Verifiability**: The numerical solution can be computed and verified, for instance, by comparing it to the known analytical solution $u(x) = (x-x^3)/6$.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be provided.\n\n### Solution Derivation\n\nThe spectral element method for this problem involves the following steps:\n\n1.  **Reference Element and Basis**: The method is formulated on a reference element $\\hat{\\Omega} = [-1,1]$ with coordinate $\\xi$. For a polynomial degree $p=4$, we use $p+1=5$ Legendre-Gauss-Lobatto (LGL) nodes, denoted $\\{\\xi_j\\}_{j=0}^4$. These nodes are the roots of $(1-\\xi^2)L_4'(\\xi)$, where $L_4(\\xi)$ is the Legendre polynomial of degree $4$. The basis functions on this element are the Lagrange polynomials $\\{h_j(\\xi)\\}_{j=0}^4$ satisfying $h_j(\\xi_k) = \\delta_{jk}$.\n\n2.  **Element-to-Physical Mapping**: The global domain $[0,1]$ is divided into $E$ uniform elements $\\Omega_k$ of length $\\Delta x = 1/E$. For each element $\\Omega_k = [x_k, x_{k+1}]$, where $x_k=(k-1)\\Delta x$ for $k=1, \\dots, E$, we define a linear mapping from the reference coordinate $\\xi$ to the physical coordinate $x$:\n    $$x(\\xi) = x_k + \\frac{\\Delta x}{2}(\\xi + 1)$$\n    The Jacobian of this transformation is $J = \\frac{dx}{d\\xi} = \\frac{\\Delta x}{2}$. The inverse mapping for the derivative is $\\frac{d}{dx} = \\frac{d\\xi}{dx}\\frac{d}{d\\xi} = \\frac{1}{J}\\frac{d}{d\\xi}$.\n\n3.  **Element Matrices**: The weak form involves integrals that are sums over the elements. On each element $\\Omega_k$, the solution $u(x)$ and test function $v(x)$ are approximated as $u^k(x) = \\sum_{j=0}^{p} u_j^k h_j(\\xi(x))$ and $v^k(x) = \\sum_{i=0}^{p} v_i^k h_i(\\xi(x))$. This leads to element-level stiffness matrices $A^k$ and load vectors $F^k$.\n\n    -   **Stiffness Matrix**: The entries of the element stiffness matrix are given by:\n        $$A^k_{ij} = \\int_{\\Omega_k} (h_i^k)'(x) (h_j^k)'(x) \\, dx = \\int_{-1}^{1} \\left(\\frac{1}{J}h_i'(\\xi)\\right) \\left(\\frac{1}{J}h_j'(\\xi)\\right) J \\, d\\xi = \\frac{1}{J} \\int_{-1}^{1} h_i'(\\xi) h_j'(\\xi) \\, d\\xi$$\n        The integral is evaluated using LGL quadrature, which is exact for this integrand. Let $D$ be the differentiation matrix with entries $D_{mi} = h_i'(\\xi_m)$, and $w_m$ be the quadrature weights. The integral becomes $\\sum_{m=0}^p D_{mi} D_{mj} w_m$, which in matrix form is $(D^T W D)_{ij}$, where $W$ is a diagonal matrix of the weights. Since the mesh is uniform, $J$ is constant, and the element stiffness matrix $A^k$ is the same for all elements.\n\n    -   **Load Vector**: The entries of the element load vector are:\n        $$F^k_i = \\int_{\\Omega_k} x(x) h_i^k(x) \\, dx = \\int_{-1}^{1} x(\\xi) h_i(\\xi) J \\, d\\xi$$\n        Using LGL quadrature, $F^k_i \\approx \\sum_{m=0}^p x(\\xi_m) h_i(\\xi_m) J w_m$. Due to the property $h_i(\\xi_m) = \\delta_{im}$, the sum collapses to a single term: $F^k_i = x(\\xi_i) J w_i$. Here, $x(\\xi_i)$ is the physical coordinate of the $i$-th local node within element $k$.\n\n4.  **Global Assembly**: The global stiffness matrix $A$ and load vector $F$ are assembled by summing the contributions from all element matrices and vectors, a process known as direct stiffness summation. The total number of degrees of freedom (nodes) is $N_{dof} = E \\cdot p + 1$. For an element $k$ (1-indexed), its local nodes $j=0, \\dots, p$ map to global nodes $g = (k-1)p+j, \\dots, kp$. The contributions $A^k_{ij}$ and $F^k_i$ are added to the corresponding global locations $A_{g_i, g_j}$ and $F_{g_i}$.\n\n5.  **Boundary Conditions**: The homogeneous Dirichlet conditions $u(0)=0$ and $u(1)=0$ correspond to fixing the first ($U_0$) and last ($U_{N_{dof}-1}$) nodal values to zero. Following the problem, this is done by eliminating the first and last rows and columns of the global matrix $A$ and the first and last entries of the global vector $F$. This reduces the system to $A_{int} U_{int} = F_{int}$, where the subscript 'int' denotes the interior nodes.\n\n6.  **Solve and Reconstruct**: The reduced linear system is solved for the interior nodal values $U_{int}$. The full solution vector $U$ is then constructed by embedding $U_{int}$ between the zero boundary values. This vector $U$ contains the computed nodal values of the spectral element solution, ordered from $x=0$ to $x=1$. This procedure is repeated for each test case ($E=1, 2, 5$).", "answer": "```python\nimport numpy as np\nfrom numpy.polynomial.legendre import Legendre\n\ndef _get_lgl_data(p):\n    \"\"\"\n    Computes Legendre-Gauss-Lobatto (LGL) nodes, weights, and the differentiation matrix\n    for a given polynomial degree p.\n    \"\"\"\n    if p < 1:\n        if p == 0: return np.array([-1.0]), np.array([2.0]), np.array([[0.0]])\n        return np.array([]), np.array([]), np.array([[]])\n\n    # Nodes xi are the roots of (1-xi^2) * Lp'(xi).\n    # These are -1, 1, and the roots of the derivative of the Legendre polynomial Lp.\n    Lp = Legendre.basis(p)\n    Lp_deriv = Lp.deriv(1)\n    \n    # Get interior nodes from roots of the derivative\n    int_nodes = Lp_deriv.roots()\n    # Combine with boundary nodes and sort\n    nodes_xi = np.concatenate(([-1.0], np.sort(int_nodes), [1.0]))\n    \n    # Calculate weights using the formula w_j = 2 / (p * (p + 1) * [Lp(xi_j)]^2)\n    Lp_at_nodes = Lp(nodes_xi)\n    weights_w = 2.0 / (p * (p + 1) * Lp_at_nodes**2)\n    \n    # Calculate the differentiation matrix D_ij = h'_j(xi_i)\n    p_plus_1 = p + 1\n    D = np.zeros((p_plus_1, p_plus_1))\n    \n    for i in range(p_plus_1):\n        for j in range(p_plus_1):\n            if i == j:\n                if i == 0:\n                    D[i, j] = -p * (p + 1) / 4.0\n                elif i == p:\n                    D[i, j] = p * (p + 1) / 4.0\n                else:\n                    D[i, j] = 0.0\n            else:\n                # Formula for off-diagonal elements: D_ij = Lp(xi_i) / (Lp(xi_j) * (xi_i - xi_j))\n                D[i, j] = Lp_at_nodes[i] / (Lp_at_nodes[j] * (nodes_xi[i] - nodes_xi[j]))\n    \n    return nodes_xi, weights_w, D\n\ndef solve():\n    \"\"\"\n    Implements the Spectral Element Method to solve the 1D Poisson equation.\n    \"\"\"\n    # Fixed parameters from the problem statement\n    p = 4\n    test_cases = [1, 2, 5]\n\n    # Pre-compute reference element data once, as p is fixed.\n    xi, w, D = _get_lgl_data(p)\n    p_plus_1 = p + 1\n\n    # Reference element stiffness matrix: A_ref_ij = integral(h'_i(xi) * h'_j(xi) dxi)\n    # This is computed exactly by LGL quadrature: sum_m( h'_i(xi_m) * h'_j(xi_m) * w_m )\n    # which corresponds to matrix multiplication: D.T @ diag(w) @ D\n    A_ref = D.T @ np.diag(w) @ D\n\n    all_results = []\n    \n    # Main loop over test cases for the number of elements E\n    for E in test_cases:\n        # 1. Setup global parameters for the current mesh\n        n_dof = E * p + 1\n        delta_x = 1.0 / E\n        # Jacobian of the mapping from reference [-1,1] to physical element\n        J = delta_x / 2.0\n\n        # 2. Element stiffness matrix (independent of element k for a uniform mesh)\n        # A_elem = (1/J) * A_ref\n        A_elem = (1.0 / J) * A_ref\n\n        # 3. Assemble global stiffness matrix and load vector\n        A_glob = np.zeros((n_dof, n_dof))\n        F_glob = np.zeros(n_dof)\n        \n        for k in range(E):  # Loop over E elements (0-indexed)\n            # Element load vector F_elem_i = integral(x * N_i dx) over the element.\n            # Computed by LGL quadrature: sum_m( x(xi_m) * N_i(xi_m) * w_m * J )\n            # Since N_i(xi_m) = h_i(xi_m) = delta_im, the sum simplifies.\n            x_nodes_k = k * delta_x + J * (xi + 1.0)\n            F_elem_k = x_nodes_k * J * w # Uses element-wise product\n\n            # Map local indices (0 to p) to global indices\n            global_indices = np.arange(k * p, k * p + p_plus_1)\n            \n            # Add element contributions to the global system using direct stiffness summation.\n            ix_ = np.ix_(global_indices, global_indices)\n            A_glob[ix_] += A_elem\n            F_glob[global_indices] += F_elem_k\n\n        # 4. Apply homogeneous Dirichlet boundary conditions u(0)=0 and u(1)=0 by elimination.\n        # This involves solving for the interior degrees of freedom only.\n        A_int = A_glob[1:-1, 1:-1]\n        F_int = F_glob[1:-1]\n        \n        # 5. Solve the linear system for interior nodal values.\n        U_int = np.linalg.solve(A_int, F_int)\n        \n        # 6. Reconstruct the full solution vector, including boundary nodes.\n        U_sol = np.zeros(n_dof)\n        U_sol[1:-1] = U_int  # U_sol[0] and U_sol[-1] remain 0.0 as required.\n        \n        all_results.append(U_sol.tolist())\n\n    # Format the final output string as a single line with no spaces\n    # Example: [[...],[...],[...]]\n    output_str = str(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```", "id": "3370311"}]}