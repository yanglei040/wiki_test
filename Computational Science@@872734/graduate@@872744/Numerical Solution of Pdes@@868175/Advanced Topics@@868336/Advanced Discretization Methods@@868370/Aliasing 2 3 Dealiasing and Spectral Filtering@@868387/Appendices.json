{"hands_on_practices": [{"introduction": "Before diving into complex simulations, it is crucial to have a firm grasp of how discrete sampling can misrepresent high-frequency information. This exercise challenges you to derive the Discrete Fourier Transform (DFT) of a simple sinusoidal function from first principles, allowing you to witness firsthand the phenomenon of aliasing, where a high-wavenumber component masquerades as a low-wavenumber one on a finite grid [@problem_id:3362811]. Mastering this fundamental calculation builds the intuition needed to diagnose and understand aliasing errors in more complex spectral methods.", "problem": "Consider the periodic function $u(x) = \\sin(3x) + \\sin(9x)$ on the interval $[0,2\\pi)$ sampled on an equispaced grid of $N=8$ points at locations $x_j = \\frac{2\\pi j}{N}$ for $j=0,1,\\dots,N-1$. Let the Discrete Fourier Transform (DFT) be defined by\n$$\n\\hat{u}_k \\;=\\; \\sum_{j=0}^{N-1} u(x_j)\\,\\exp\\!\\left(-\\mathrm{i}\\,\\frac{2\\pi k j}{N}\\right), \\quad k=0,1,\\dots,N-1,\n$$\nwith the inverse given by\n$$\nu(x_j) \\;=\\; \\frac{1}{N}\\sum_{k=0}^{N-1} \\hat{u}_k\\,\\exp\\!\\left(\\mathrm{i}\\,\\frac{2\\pi k j}{N}\\right).\n$$\nStarting from these definitions and from first principles about periodic sampling and trigonometric identities, derive the exact DFT coefficients $\\hat{u}_k$ for $k=0,1,\\dots,N-1$ when $N=8$. In your derivation, identify which discrete indices carry nonzero energy for each of the two components $\\sin(3x)$ and $\\sin(9x)$, and explain which high-frequency component aliases to which index and with what complex amplitude due to sampling on $N=8$. Conclude by writing the complete vector of $\\hat{u}_k$ (for $k=0,1,\\dots,7$) as a single row. No numerical rounding is required. Express all mathematical quantities in exact form.", "solution": "The problem requires the derivation of the Discrete Fourier Transform (DFT) coefficients $\\hat{u}_k$ for the function $u(x) = \\sin(3x) + \\sin(9x)$ sampled on a grid of $N=8$ points.\n\nThe given function is $u(x) = \\sin(3x) + \\sin(9x)$. The sampling points are $x_j = \\frac{2\\pi j}{N}$ for $j=0, 1, \\dots, N-1$. The DFT of the sampled sequence $u(x_j)$ is given by\n$$\n\\hat{u}_k \\;=\\; \\sum_{j=0}^{N-1} u(x_j)\\,\\exp\\!\\left(-\\mathrm{i}\\,\\frac{2\\pi k j}{N}\\right), \\quad k=0,1,\\dots,N-1.\n$$\nTo proceed from first principles, we express the sine functions using Euler's formula, $\\sin(\\theta) = \\frac{1}{2\\mathrm{i}}(e^{\\mathrm{i}\\theta} - e^{-\\mathrm{i}\\theta})$.\nThe function $u(x)$ can be written as the sum of four complex exponentials:\n$$\nu(x) = \\frac{1}{2\\mathrm{i}}\\left(e^{\\mathrm{i}3x} - e^{-\\mathrm{i}3x}\\right) + \\frac{1}{2\\mathrm{i}}\\left(e^{\\mathrm{i}9x} - e^{-\\mathrm{i}9x}\\right)\n$$\nDue to the linearity of the DFT, we can find the transform of each component separately and sum the results. Let's analyze the DFT of a general complex exponential term $f_m(x) = e^{\\mathrm{i}mx}$ sampled on the grid, where $m$ is an integer wavenumber. At the grid points $x_j$, this becomes $f_m(x_j) = e^{\\mathrm{i}m(2\\pi j/N)} = \\exp(\\frac{2\\pi \\mathrm{i} m j}{N})$.\n\nThe DFT of this sequence is\n$$\n\\hat{f}_{m,k} = \\sum_{j=0}^{N-1} \\exp\\left(\\frac{2\\pi \\mathrm{i} m j}{N}\\right) \\exp\\left(-\\frac{2\\pi \\mathrm{i} k j}{N}\\right) = \\sum_{j=0}^{N-1} \\exp\\left(\\frac{2\\pi \\mathrm{i} (m-k) j}{N}\\right)\n$$\nThis is a geometric series. According to the orthogonality property of discrete complex exponentials, this sum evaluates to:\n$$\n\\sum_{j=0}^{N-1} \\left(\\exp\\left(\\frac{2\\pi \\mathrm{i} (m-k)}{N}\\right)\\right)^j =\n\\begin{cases}\nN  \\text{if } m-k \\text{ is an integer multiple of } N \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\nSince the DFT indices $k$ are in the range $\\{0, 1, \\dots, N-1\\}$, the condition \"$m-k$ is an integer multiple of $N$\" simplifies to $k \\equiv m \\pmod N$. For any integer wavenumber $m$, there is a unique index $k$ in this range that satisfies the congruence.\n\nWe now apply this result to each of the four exponential terms in $u(x)$ with $N=8$.\n\nComponent 1: $\\frac{1}{2\\mathrm{i}}e^{\\mathrm{i}3x}$. Here, the wavenumber is $m=3$. The congruence $k \\equiv 3 \\pmod 8$ is satisfied by $k=3$. This term contributes to the DFT coefficient $\\hat{u}_3$. The contribution is its amplitude multiplied by $N$: $\\frac{1}{2\\mathrm{i}} \\times N = \\frac{N}{2\\mathrm{i}} = -\\frac{\\mathrm{i}N}{2}$.\n\nComponent 2: $-\\frac{1}{2\\mathrm{i}}e^{-\\mathrm{i}3x}$. Here, the wavenumber is $m=-3$. The congruence $k \\equiv -3 \\pmod 8$ is satisfied by $k=-3+8=5$. This term contributes to $\\hat{u}_5$. The contribution is its amplitude multiplied by $N$: $-\\frac{1}{2\\mathrm{i}} \\times N = -\\frac{N}{2\\mathrm{i}} = \\frac{\\mathrm{i}N}{2}$.\nThe energy for the $\\sin(3x)$ component is therefore located at indices $k=3$ and $k=5$.\n\nComponent 3: $\\frac{1}{2\\mathrm{i}}e^{\\mathrm{i}9x}$. Here, the wavenumber is $m=9$. This is where aliasing occurs. The Nyquist frequency for a grid of $N=8$ points corresponds to a wavenumber of $N/2=4$. Since $|m|=9 > 4$, this frequency is aliased. We find its aliased index $k$ from the congruence $k \\equiv 9 \\pmod 8$. Since $9=1 \\times 8 + 1$, we have $k=1$. This high-frequency component is indistinguishable from the component with wavenumber $m=1$ on the discrete grid. Its contribution to the DFT is at index $\\hat{u}_1$. The amplitude is $\\frac{1}{2\\mathrm{i}}$, so the contribution is $\\frac{1}{2\\mathrm{i}} \\times N = -\\frac{\\mathrm{i}N}{2}$.\n\nComponent 4: $-\\frac{1}{2\\mathrm{i}}e^{-\\mathrm{i}9x}$. Here, the wavenumber is $m=-9$. The congruence is $k \\equiv -9 \\pmod 8$. Since $-9=-2 \\times 8 + 7$, we have $k=7$. (Alternatively, $-9 \\equiv -1 \\pmod 8$, which corresponds to index $k=N-1=7$). This component is aliased to the mode with wavenumber $m=-1$. Its contribution to the DFT is at index $\\hat{u}_7$. The amplitude is $-\\frac{1}{2\\mathrm{i}}$, so the contribution is $-\\frac{1}{2\\mathrm{i}} \\times N = \\frac{\\mathrm{i}N}{2}$.\nThe high-frequency component $\\sin(9x)$ aliases to the low-frequency component $\\sin(x)$ on the grid because $e^{\\mathrm{i}9x_j}=e^{\\mathrm{i}9(2\\pi j/8)}=e^{\\mathrm{i}(8+1)(2\\pi j/8)}=e^{\\mathrm{i}2\\pi j}e^{\\mathrm{i}1(2\\pi j/8)}=e^{\\mathrm{i}x_j}$. Similarly, $e^{-\\mathrm{i}9x_j}=e^{-\\mathrm{i}x_j}$. The energy for the $\\sin(9x)$ component is aliased to indices $k=1$ and $k=7$.\n\nWe assemble the complete vector of DFT coefficients $\\hat{u}_k$ by summing the contributions at each index $k \\in \\{0, 1, \\dots, 7\\}$ for $N=8$.\n- $\\hat{u}_0 = 0$, as there is no zero-frequency (constant) term.\n- $\\hat{u}_1$: Contribution from aliased $e^{\\mathrm{i}9x}$ term: $-\\frac{\\mathrm{i}N}{2} = -\\frac{8\\mathrm{i}}{2} = -4\\mathrm{i}$.\n- $\\hat{u}_2 = 0$.\n- $\\hat{u}_3$: Contribution from $e^{\\mathrm{i}3x}$ term: $-\\frac{\\mathrm{i}N}{2} = -\\frac{8\\mathrm{i}}{2} = -4\\mathrm{i}$.\n- $\\hat{u}_4 = 0$.\n- $\\hat{u}_5$: Contribution from $e^{-\\mathrm{i}3x}$ term: $\\frac{\\mathrm{i}N}{2} = \\frac{8\\mathrm{i}}{2} = 4\\mathrm{i}$. (Index $k=5 = 8-3$).\n- $\\hat{u}_6 = 0$.\n- $\\hat{u}_7$: Contribution from aliased $e^{-\\mathrm{i}9x}$ term: $\\frac{\\mathrm{i}N}{2} = \\frac{8\\mathrm{i}}{2} = 4\\mathrm{i}$. (Index $k=7 = 8-1$).\n\nThe complete vector of DFT coefficients is $(\\hat{u}_0, \\hat{u}_1, \\hat{u}_2, \\hat{u}_3, \\hat{u}_4, \\hat{u}_5, \\hat{u}_6, \\hat{u}_7)$.\nSubstituting the calculated values yields:\n$$\n(0, -4\\mathrm{i}, 0, -4\\mathrm{i}, 0, 4\\mathrm{i}, 0, 4\\mathrm{i})\n$$\nThis result reflects the property that for a real-valued input signal $u(x_j)$, the DFT coefficients must satisfy the conjugate symmetry property $\\hat{u}_k = \\overline{\\hat{u}_{N-k}}$ for $k=1, \\dots, N-1$.\nLet's check:\n$\\hat{u}_1 = -4\\mathrm{i}$, $\\hat{u}_{8-1}=\\hat{u}_7 = 4\\mathrm{i}$. $\\overline{\\hat{u}_7} = -4\\mathrm{i} = \\hat{u}_1$. Correct.\n$\\hat{u}_2 = 0$, $\\hat{u}_{8-2}=\\hat{u}_6 = 0$. $\\overline{\\hat{u}_6} = 0 = \\hat{u}_2$. Correct.\n$\\hat{u}_3 = -4\\mathrm{i}$, $\\hat{u}_{8-3}=\\hat{u}_5 = 4\\mathrm{i}$. $\\overline{\\hat{u}_5} = -4\\mathrm{i} = \\hat{u}_3$. Correct.\n$\\hat{u}_4=0$, $\\hat{u}_{8-4}=\\hat{u}_4=0$. This coefficient must be real, which it is. Correct.\nThe derivation is consistent.", "answer": "$$\n\\boxed{\\pmatrix{0  -4\\mathrm{i}  0  -4\\mathrm{i}  0  4\\mathrm{i}  0  4\\mathrm{i}}}\n$$", "id": "3362811"}, {"introduction": "Having understood how aliasing occurs, the next logical step is to learn how to prevent it. This practice provides a hands-on coding exercise to verify one of the most common dealiasing techniques: the 3/2 padding rule. You will implement a test to demonstrate that for a quadratic nonlinearity, performing the calculation on a padded grid correctly computes the non-aliased convolution for the resolved modes [@problem_id:3362836]. This exercise bridges theory and practice, giving you confidence in the implementation and efficacy of dealiasing algorithms.", "problem": "Consider a one-dimensional, $2\\pi$-periodic function represented on a uniform grid of $N$ points and its Discrete Fourier Transform (DFT). Let the DFT conventions be those used by standard numerical libraries: the forward DFT of a grid function $u_j$, $j=0,\\dots,N-1$, is given by\n$$\n\\hat{u}_k = \\sum_{j=0}^{N-1} u_j \\, e^{-2\\pi i j k / N},\n$$\nand the inverse DFT is given by\n$$\nu_j = \\frac{1}{N} \\sum_{k=0}^{N-1} \\hat{u}_k \\, e^{2\\pi i j k / N}.\n$$\nPointwise multiplication in physical space corresponds to circular convolution in spectral space. Specifically, for the product $w_j = u_j v_j$, one has\n$$\n\\widehat{w}_k = \\frac{1}{N} \\sum_{p=0}^{N-1} \\hat{u}_p \\, \\hat{v}_{(k-p) \\bmod N}.\n$$\nAliasing arises because the spectral convolution is taken modulo $N$. When the input spectra are band-limited to $|k| \\le K_{\\max}$ and one is interested in the product spectrum for $|k| \\le K_{\\max}$, zero-padding the spectra to a longer length $M$ with $M \\ge \\frac{3}{2} N$ (the so-called three-halves rule) and performing the pseudoproduct at this higher resolution prevents wrap-around in the convolution for the resolved band, thereby eliminating aliasing for quadratic nonlinearities.\n\nYour task is to implement a computation for $N=12$ with input spectra supported in $|k| \\le 4$ that demonstrates the following statement:\nfor all resolved modes $|k| \\le 4$, the three-halves padding (zero-padding to $M = \\frac{3}{2} N = 18$) yields the same spectral coefficients $\\widehat{(uv)}_k$ as the exact, non-aliased convolution\n$$\n\\widehat{(uv)}_k^{\\mathrm{exact}} = \\frac{1}{M} \\sum_{p=-4}^{4} \\hat{u}_p \\, \\hat{v}_{k-p},\n$$\nwhere terms with $k-p$ outside $[-4,4]$ are treated as zero. In other words, when the spectra of $u$ and $v$ vanish outside $|k| \\le 4$ and the product is formed by inverse DFT at length $M=18$, multiplication in physical space followed by forward DFT produces\n$$\n\\widehat{(uv)}_k^{\\mathrm{pad}} = \\frac{1}{M} \\sum_{p=-4}^{4} \\hat{u}_p \\, \\hat{v}_{k-p}\n$$\nfor all $|k| \\le 4$, with no circular wrap-around influencing these modes.\n\nImplement a program that:\n- Constructs test spectra $\\hat{u}_k$ and $\\hat{v}_k$ supported in $|k| \\le 4$ on the $N=12$ grid, represented using the $N$-point DFT binning convention for even $N$: the integer wavenumbers $k$ correspond to DFT bins with $k=0,1,\\dots,5,-6,-5,\\dots,-1$ mapped to indices $0,1,\\dots,5,6,7,\\dots,11$ respectively.\n- Builds $M=18$-length zero-padded spectra by placing the same $\\hat{u}_k$ and $\\hat{v}_k$ values at the corresponding $M$-point DFT bins for $k=-4,-3,\\dots,4$ (with $M$ even, bins correspond to $k=0,1,\\dots,8,-9,-8,\\dots,-1$ mapped to indices $0,1,\\dots,8,9,10,\\dots,17$).\n- Computes the padded pseudoproduct by inverse DFT to physical space at length $M$, pointwise multiplication, and forward DFT back to spectral space, yielding $\\widehat{(uv)}_k^{\\mathrm{pad}}$ for $|k| \\le 4$ from the $M$-point transform.\n- Computes the exact, non-aliased convolution coefficients $\\widehat{(uv)}_k^{\\mathrm{exact}}$ for $|k| \\le 4$ using the linear (non-modular) sum shown above with the factor $\\frac{1}{M}$, treating $\\hat{u}_p$ and $\\hat{v}_{q}$ as zero when $p$ or $q$ lie outside $[-4,4]$.\n- Reports, for each test case, the maximum absolute discrepancy\n$$\n\\max_{|k| \\le 4} \\left| \\widehat{(uv)}_k^{\\mathrm{pad}} - \\widehat{(uv)}_k^{\\mathrm{exact}} \\right|.\n$$\n\nDesign a test suite of four cases to exercise different facets:\n1. A general case with random complex coefficients for $\\hat{u}_k$ and $\\hat{v}_k$ over $k=-4,\\dots,4$, using a fixed random seed for reproducibility.\n2. A boundary case where only the highest resolved modes are nonzero: $\\hat{u}_{\\pm 4}$ and $\\hat{v}_{\\pm 4}$ nonzero, all other coefficients zero.\n3. A real-valued function case where $\\hat{u}_k$ satisfies Hermitian symmetry $\\hat{u}_{-k} = \\overline{\\hat{u}_k}$ and $\\hat{u}_0$ is real, while $\\hat{v}_k$ is general complex, both supported in $|k| \\le 4$.\n4. A constant times band-limited case: $\\hat{u}_0$ nonzero and all other $\\hat{u}_k=0$, while $\\hat{v}_k$ is general complex supported in $|k| \\le 4$.\n\nFor each case, your program should compute the maximum discrepancy as specified above. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example:\n$$\n[\\text{e}_1,\\text{e}_2,\\text{e}_3,\\text{e}_4]\n$$\nwhere each $\\text{e}_i$ is a floating-point number. No physical units or angle units are involved. All four outputs must be floats. The expected outcome is that each $\\text{e}_i$ is on the order of machine precision, thereby demonstrating that three-halves padding reproduces the exact, non-aliased convolution for the resolved band $|k| \\le 4$ under the given conditions.", "solution": "The problem statement requires a numerical verification of the three-halves ($3/2$) dealiasing rule for a quadratic nonlinearity in a spectral method context. The problem is scientifically sound, well-posed, and all necessary parameters and definitions for its solution are provided. It is a canonical exercise in understanding the mechanics of spectral transforms and aliasing control.\n\nThe fundamental principle being tested is that pointwise multiplication of two functions, $u(x)$ and $v(x)$, in physical space corresponds to a convolution of their spectra, $\\hat{u}_k$ and $\\hat{v}_k$, in spectral space. When using a Discrete Fourier Transform (DFT) on a finite grid of $N$ points, this convolution becomes circular (i.e., modulo $N$). This circularity can cause high-frequency components of the product to \"wrap around\" and corrupt the low-frequency components, an effect known as aliasing.\n\nThe three-halves rule is a specific form of the more general zero-padding or padding method to eliminate this aliasing. If the input functions $u$ and $v$ are band-limited, with spectra non-zero only for wavenumbers $|k| \\le K_{\\max}$, their product $w = uv$ will have a spectrum band-limited to $|k| \\le 2K_{\\max}$. To prevent aliasing in the original resolved band ($|k| \\le K_{\\max}$), we must perform the calculation on a grid large enough to ensure that wrap-around does not occur. The condition for a quadratic nonlinearity is that the padded grid size $M$ must satisfy $M > 3K_{\\max}$.\n\nIn this problem, we are given $N=12$ and the input spectra are band-limited to $K_{\\max}=4$. The three-halves rule suggests padding to $M = \\frac{3}{2}N = 18$. This satisfies the dealiasing condition, since $M=18 > 3K_{\\max} = 3 \\times 4 = 12$. The task is to show that for the resolved modes $|k| \\le 4$, the result of this padded computation is identical to the exact, non-aliased convolution sum.\n\nThe solution proceeds by implementing and comparing two computational paths for the product spectrum $\\widehat{(uv)}_k$.\n\n**Path 1: Padded Pseudospectral Product $\\widehat{(uv)}_k^{\\mathrm{pad}}$**\n\nThis path simulates the numerical procedure used in spectral codes.\n1.  **Spectrum Representation**: The input spectral coefficients, $\\hat{u}_k$ and $\\hat{v}_k$ for $|k| \\le 4$, are generated for each test case.\n2.  **Zero-Padding**: Two complex-valued arrays of length $M=18$ are initialized to zero. The input coefficients $\\hat{u}_k$ and $\\hat{v}_k$ are placed into these arrays at the indices corresponding to their respective wavenumbers $k \\in [-4, 4]$. The mapping from wavenumber $k$ to a DFT array index for a given transform size is provided by standard library functions, such as `numpy.fft.fftfreq`. For $M=18$, the integer wavenumbers are ordered as $k=0, 1, \\dots, 8, -9, -8, \\dots, -1$.\n3.  **Transform to Physical Space**: An inverse DFT of size $M$ is applied to each padded spectral array, $\\hat{u}^{\\mathrm{pad}}$ and $\\hat{v}^{\\mathrm{pad}}$, to obtain the corresponding functions on the padded physical grid, $u_j$ and $v_j$ for $j=0, \\dots, M-1$. Following the standard convention given, the inverse DFT includes a normalization factor of $1/M$:\n    $$u_j = \\frac{1}{M} \\sum_{k} \\hat{u}^{\\mathrm{pad}}_k e^{2\\pi i j k / M}$$\n4.  **Pointwise Multiplication**: The functions are multiplied pointwise on the $M$-point physical grid: $w_j = u_j v_j$.\n5.  **Transform to Spectral Space**: A forward DFT of size $M$ is applied to the product $w_j$ to obtain its spectrum, $\\widehat{(uv)}_k^{\\mathrm{pad}}$.\n\n**Path 2: Exact Non-Aliased Convolution $\\widehat{(uv)}_k^{\\mathrm{exact}}$**\n\nThis path computes the mathematically exact, linear convolution sum, which serves as the ground truth. The convolution theorem for the DFT states that the padded procedure yields:\n$$ \\widehat{(uv)}_k^{\\mathrm{pad}} = \\frac{1}{M} \\sum_{p} \\hat{u}^{\\mathrm{pad}}_p \\hat{v}^{\\mathrm{pad}}_{(k-p) \\pmod M} $$\nAs established, for $|k| \\le 4$, $|p| \\le 4$, and $M=18$, the sum of wavenumbers $p+(k-p)$ will not alias into the range of interest. Therefore, the modulo operation is inconsequential, and the result should match the linear convolution. We compute this sum directly:\n$$ \\widehat{(uv)}_k^{\\mathrm{exact}} = \\frac{1}{M} \\sum_{p=-4}^{4} \\hat{u}_p \\hat{v}_{k-p} $$\nwhere the input coefficients $\\hat{u}_p$ and $\\hat{v}_{k-p}$ are taken to be zero if their corresponding wavenumbers are outside the range $[-4, 4]$. This sum is computed for each target wavenumber $k \\in [-4, 4]$.\n\n**Comparison and Verification**\n\nFor each of the four test cases, the program computes both $\\widehat{(uv)}_k^{\\mathrm{pad}}$ and $\\widehat{(uv)}_k^{\\mathrm{exact}}$ for all wavenumbers in the original resolved band, $|k| \\le 4$. The maximum absolute difference between the results of the two paths is calculated:\n$$ \\max_{|k| \\le 4} \\left| \\widehat{(uv)}_k^{\\mathrm{pad}} - \\widehat{(uv)}_k^{\\mathrm{exact}} \\right| $$\nAs predicted by the theory, this difference should be on the order of machine floating-point precision, numerically demonstrating that the three-halves padding rule successfully eliminates aliasing error for the resolved spectral modes. The four test cases are designed to probe different scenarios (general, boundary, real-valued, constant) to ensure the robustness of this conclusion.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_discrepancy(u_hat_coeffs, v_hat_coeffs, M, K_max):\n    \"\"\"\n    Calculates the maximum discrepancy between the padded pseudospectral product\n    and the exact non-aliased convolution.\n\n    Args:\n        u_hat_coeffs (dict): Coefficients for u_hat, mapping k - value.\n        v_hat_coeffs (dict): Coefficients for v_hat, mapping k - value.\n        M (int): Padded grid size.\n        K_max (int): Maximum wavenumber for inputs.\n\n    Returns:\n        float: The maximum absolute discrepancy.\n    \"\"\"\n    # Define the wavenumbers we are interested in for both input and output.\n    wavenumbers_of_interest = list(range(-K_max, K_max + 1))\n\n    # --- Path 1: Padded Pseudospectral Product ---\n\n    # Map integer wavenumbers to their indices in the M-point DFT array.\n    k_vals_M = np.fft.fftfreq(M, 1/M)\n    k_map_M = {int(round(k)): i for i, k in enumerate(k_vals_M)}\n\n    # Create M-length spectral arrays and populate them (zero-padding).\n    u_hat_M = np.zeros(M, dtype=complex)\n    v_hat_M = np.zeros(M, dtype=complex)\n    \n    for k in wavenumbers_of_interest:\n        # Check if the wavenumber k is representable on the M-grid\n        if k in k_map_M:\n            idx = k_map_M[k]\n            u_hat_M[idx] = u_hat_coeffs.get(k, 0)\n            v_hat_M[idx] = v_hat_coeffs.get(k, 0)\n\n    # IFFT to physical space, pointwise multiply, then FFT back to spectral space.\n    # numpy's ifft includes the 1/M normalization factor as per the problem.\n    u_M = np.fft.ifft(u_hat_M)\n    v_M = np.fft.ifft(v_hat_M)\n    w_M = u_M * v_M\n    w_hat_padded = np.fft.fft(w_M)\n\n    # --- Path 2: Exact Non-Aliased Convolution ---\n\n    w_hat_exact = {}\n    for k in wavenumbers_of_interest:\n        conv_sum = 0.0 + 0.0j\n        # Sum over p from -K_max to K_max\n        for p in wavenumbers_of_interest:\n            u_p = u_hat_coeffs.get(p, 0)\n            # v_q where q = k-p. .get() handles cases where k-p is out of band.\n            v_k_minus_p = v_hat_coeffs.get(k - p, 0)\n            conv_sum += u_p * v_k_minus_p\n        \n        w_hat_exact[k] = (1 / M) * conv_sum\n\n    # --- Comparison ---\n\n    max_discrepancy = 0.0\n    for k in wavenumbers_of_interest:\n        # Get the coefficient from the padded product result array.\n        idx = k_map_M[k]\n        val_padded = w_hat_padded[idx]\n        \n        # Get the coefficient from the exact convolution calculation.\n        val_exact = w_hat_exact[k]\n        \n        discrepancy = np.abs(val_padded - val_exact)\n        if discrepancy  max_discrepancy:\n            max_discrepancy = discrepancy\n\n    return max_discrepancy\n\ndef solve():\n    \"\"\"\n    Main function to run the four test cases and print results.\n    \"\"\"\n    # Define problem parameters\n    N = 12\n    M = int(N * 3 / 2)  # M = 18\n    K_max = 4\n\n    wavenumbers = list(range(-K_max, K_max + 1))\n    \n    # --- Test Case Generation ---\n\n    # Case 1: General case with random complex coefficients\n    rng1 = np.random.default_rng(seed=123)\n    u_hat_1 = {k: rng1.uniform(-1, 1) + 1j * rng1.uniform(-1, 1) for k in wavenumbers}\n    v_hat_1 = {k: rng1.uniform(-1, 1) + 1j * rng1.uniform(-1, 1) for k in wavenumbers}\n\n    # Case 2: Boundary case where only the highest resolved modes are nonzero\n    rng2 = np.random.default_rng(seed=456)\n    u_hat_2 = {\n        4: rng2.uniform(-1, 1) + 1j * rng2.uniform(-1, 1),\n        -4: rng2.uniform(-1, 1) + 1j * rng2.uniform(-1, 1)\n    }\n    v_hat_2 = {\n        4: rng2.uniform(-1, 1) + 1j * rng2.uniform(-1, 1),\n        -4: rng2.uniform(-1, 1) + 1j * rng2.uniform(-1, 1)\n    }\n\n    # Case 3: Real-valued function u (Hermitian symmetry)\n    rng3 = np.random.default_rng(seed=789)\n    u_hat_3 = {}\n    u_hat_3[0] = rng3.uniform(-1, 1)  # u_0 must be real\n    for k in range(1, K_max + 1):\n        val = rng3.uniform(-1, 1) + 1j * rng3.uniform(-1, 1)\n        u_hat_3[k] = val\n        u_hat_3[-k] = np.conj(val)\n    v_hat_3 = {k: rng3.uniform(-1, 1) + 1j * rng3.uniform(-1, 1) for k in wavenumbers}\n\n    # Case 4: Constant times band-limited case (u has only k=0 mode)\n    rng4 = np.random.default_rng(seed=101)\n    u_hat_4 = {0: rng4.uniform(-1, 1) + 1j * rng4.uniform(-1, 1)}\n    v_hat_4 = {k: rng4.uniform(-1, 1) + 1j * rng4.uniform(-1, 1) for k in wavenumbers}\n    \n    test_cases = [\n        (u_hat_1, v_hat_1),\n        (u_hat_2, v_hat_2),\n        (u_hat_3, v_hat_3),\n        (u_hat_4, v_hat_4),\n    ]\n\n    results = []\n    for u_coeffs, v_coeffs in test_cases:\n        discrepancy = calculate_discrepancy(u_coeffs, v_coeffs, M, K_max)\n        results.append(discrepancy)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3362836"}, {"introduction": "Why is dealiasing so critical in practice? This advanced exercise puts you in the driver's seat of a pseudo-spectral simulation for the viscous Burgers equation, a canonical model for nonlinear fluid dynamics. Your mission is to design and run a numerical experiment to quantify the unphysical energy transfer caused by aliasing errors when computing the nonlinear term [@problem_id:3362824]. By comparing a simulation with and without the two-thirds dealiasing rule, you will directly measure the spurious energy injected into low-wavenumber modes, revealing the importance of proper dealiasing for the stability and physical accuracy of numerical solutions.", "problem": "Consider the one-dimensional viscous Burgers equation on a periodic domain with angle measured in radians,\n$$\nu_t + \\frac{1}{2}\\partial_x\\left(u^2\\right) = \\nu\\, u_{xx}, \\quad x \\in [0,2\\pi], \\quad t \\ge 0,\n$$\nwhere $u(x,t)$ is a scalar field, $\\nu \\ge 0$ is the viscosity, and periodic boundary conditions are imposed at $x=0$ and $x=2\\pi$. A pseudo-spectral method evolves the Fourier coefficients $\\hat{u}_k(t)$ of $u(x,t)$ using the Fast Fourier Transform (FFT), and computes products such as $u^2$ in physical space. The discrete convolution in spectral space of nonlinear terms can lead to aliasing: unresolved triads $(k_1,k_2,k_3)$ with $k_3=k_1+k_2$ that lie beyond the highest resolvable wavenumber fold back and spuriously inject energy into low modes. A standard mitigation is the two-thirds dealiasing rule, which for a quadratic nonlinearity sets to zero all Fourier modes with $|k| > \\lfloor N/3 \\rfloor$ in the nonlinear term, where $N$ is the number of grid points and Fourier modes.\n\nDesign and implement a numerical experiment that empirically maps the energy transfer into low modes due to aliasing for the pseudo-spectral discretization of the viscous Burgers equation, by comparing the case with no dealiasing to the case with the two-thirds rule. Use the following fundamental base:\n\n- The Fourier series on $[0,2\\pi]$ is $u(x,t) = \\sum_{k=-\\infty}^{\\infty} \\hat{u}_k(t) e^{\\mathrm{i}k x}$, and on a discrete grid of $N$ points, the resolvable wavenumbers are $k \\in \\{-N/2, \\dots, N/2-1\\}$ for even $N$.\n- The pseudo-spectral method computes $u^2$ in physical space and then transforms to Fourier space, yielding a discrete convolution for $\\widehat{u^2}_k$.\n- For any signal $u$, Parseval's identity on the discrete grid implies $\\sum_{j=0}^{N-1} |u(x_j,t)|^2 = \\frac{1}{N} \\sum_{k} |\\hat{u}_k(t)|^2$, where $x_j$ are grid points.\n- The modal energy transfer rate into a set of low modes $\\mathcal{K}_\\ell = \\{k: |k| \\le k_\\ell\\}$ due solely to the nonlinear term $\\mathcal{N}[u] = -\\frac{1}{2}\\partial_x(u^2)$ is defined by\n$$\n\\dot{E}_\\ell(t) = \\frac{1}{N}\\sum_{k \\in \\mathcal{K}_\\ell} \\Re\\left\\{\\hat{u}_k^*(t)\\,\\widehat{\\mathcal{N}[u]}_k(t)\\right\\}.\n$$\nThis measures the rate of energy flowing into the low-mode band from nonlinear interactions at time $t$. The cumulative injected energy over $[0,T]$ is $I = \\int_0^T \\dot{E}_\\ell(t)\\,\\mathrm{d}t$.\n\nYour program must:\n\n1. Implement a pseudo-spectral time integrator for $u_t = -\\frac{1}{2}\\partial_x(u^2) + \\nu\\,u_{xx}$ that maintains the state in Fourier space, evaluates the nonlinear term in physical space, and uses a fourth-order Runge–Kutta scheme. The derivative operators in spectral space are $\\partial_x \\leftrightarrow \\mathrm{i}k$ and $\\partial_{xx} \\leftrightarrow -k^2$.\n2. At each time step, compute the nonlinear term twice from the same current state $u(\\cdot,t)$:\n   - Without dealiasing: $\\widehat{\\mathcal{N}}^{\\mathrm{unal}}_k(t) = -\\frac{1}{2}\\mathrm{i}k\\,\\widehat{u^2}_k(t)$ with no filtering.\n   - With the two-thirds rule: $\\widehat{\\mathcal{N}}^{2/3}_k(t) = -\\frac{1}{2}\\mathrm{i}k\\,\\left[\\widehat{u^2}_k(t)\\,\\mathbf{1}_{\\{|k|\\le \\lfloor N/3 \\rfloor\\}}\\right]$, where $\\mathbf{1}_{\\{|k|\\le \\lfloor N/3 \\rfloor\\}}$ is the indicator that sets modes with $|k|$ exceeding the cutoff to zero.\n3. Evolve $u$ in time using the filtered nonlinear term $\\widehat{\\mathcal{N}}^{2/3}_k(t)$ combined with viscosity, so that the state is not contaminated by aliasing as the experiment proceeds.\n4. Measure the low-mode energy transfer rate $\\dot{E}_\\ell$ for both cases, $\\dot{E}_\\ell^{\\mathrm{unal}}(t)$ and $\\dot{E}_\\ell^{2/3}(t)$, at each time step using the definition above. Approximate the cumulative injected energy by a Riemann sum $I \\approx \\sum_n \\dot{E}_\\ell(t_n)\\,\\Delta t$.\n5. Report, for each test case, the scalar quantity $D = I^{\\mathrm{unal}} - I^{2/3}$, which quantifies the excess cumulative low-mode energy injection attributable to aliasing.\n\nUse the deterministic initial condition\n$$\nu(x,0) = A_1\\sin(m_1 x) + A_2\\cos(m_2 x + \\phi) + A_3\\sin(m_3 x),\n$$\nwith $A_1=1.0$, $A_2=0.8$, $A_3=0.5$, $\\phi=0.3$, and\n$$\nm_1 = \\left\\lfloor \\frac{N}{4} \\right\\rfloor,\\quad m_2 = \\left\\lfloor \\frac{N}{5} \\right\\rfloor,\\quad m_3 = \\left\\lfloor \\frac{N}{3} \\right\\rfloor - 1.\n$$\nChoose a time step based on a Courant–Friedrichs–Lewy (CFL) constraint $ \\Delta t = \\alpha\\,\\Delta x/\\max_x |u(x,0)|$ with $\\alpha=0.2$ and grid spacing $\\Delta x = 2\\pi/N$, and round the number of steps up to an integer so that the final time is attained exactly.\n\nYour program should use the following test suite to ensure coverage of different scenarios:\n\n- Test 1 (happy path): $N=64$, $\\nu=10^{-3}$, $T=0.5$, $k_\\ell=4$.\n- Test 2 (moderate viscosity, more modes): $N=96$, $\\nu=5\\times 10^{-3}$, $T=0.4$, $k_\\ell=8$.\n- Test 3 (edge case, low resolution and zero viscosity, short time): $N=32$, $\\nu=0$, $T=0.2$, $k_\\ell=3$.\n- Test 4 (higher resolution, stronger viscosity): $N=128$, $\\nu=10^{-2}$, $T=0.3$, $k_\\ell=6$.\n\nFor each test case, compute the scalar $D$ as defined above. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"). All quantities are dimensionless; angles are in radians, and you must report the outputs as plain decimal numbers without units.", "solution": "The user-provided problem is valid. It presents a well-posed, scientifically sound numerical experiment on a standard topic in the computational solution of partial differential equations. All necessary parameters and definitions are provided, and there are no internal contradictions or ambiguities that would prevent a unique solution.\n\nThe problem asks to quantify the effect of aliasing in a pseudo-spectral simulation of the one-dimensional viscous Burgers equation, $u_t + \\frac{1}{2}\\partial_x\\left(u^2\\right) = \\nu\\, u_{xx}$ on a periodic domain $x \\in [0, 2\\pi]$. The core of the task is to compare the energy transferred into low-wavenumber modes by the nonlinear term, with and without the application of the two-thirds dealiasing rule.\n\nThe solution is implemented as a pseudo-spectral solver that evolves the system in Fourier space. The state of the system at any time $t$ is represented by the set of Fourier coefficients $\\hat{u}_k(t)$, where $u(x,t) = \\sum_k \\hat{u}_k(t) e^{\\mathrm{i}k x}$. On a discrete grid of $N$ points, the wavenumbers $k$ take integer values in a range determined by $N$, typically from approximately $-N/2$ to $N/2$.\n\nThe Burgers equation in Fourier space reads:\n$$\n\\frac{d\\hat{u}_k}{dt} = \\widehat{\\mathcal{N}[u]}_k + \\widehat{\\mathcal{L}[u]}_k\n$$\nwhere $\\widehat{\\mathcal{L}[u]}_k$ is the linear (viscous) term and $\\widehat{\\mathcal{N}[u]}_k$ is the nonlinear (advection) term. The linear term is computed exactly in spectral space as $\\widehat{\\mathcal{L}[u]}_k = \\nu \\widehat{u_{xx}}_k = -\\nu k^2 \\hat{u}_k$, leveraging the property that differentiation becomes multiplication by $\\mathrm{i}k$.\n\nThe nonlinear term $\\mathcal{N}[u] = -\\frac{1}{2}\\partial_x(u^2)$ is handled with a pseudo-spectral approach to avoid a computationally expensive convolution in Fourier space. The procedure is as follows:\n$1$. Transform the state to physical space: $u(x_j) = \\text{iFFT}(\\hat{u}_k)$.\n$2$. Compute the quadratic product in physical space: $u^2(x_j)$.\n$3$. Transform the product back to Fourier space: $\\widehat{u^2}_k = \\text{FFT}(u^2(x_j))$.\n$4$. Apply the spectral derivative: $\\widehat{\\mathcal{N}[u]}_k = -\\frac{1}{2}(\\mathrm{i}k) \\widehat{u^2}_k$.\n\nThis process introduces aliasing errors. The product of two signals band-limited to $|k| \\le K_{\\max}$ results in a signal with frequencies up to $|k| \\le 2K_{\\max}$. On a discrete grid resolving up to $|k| \\approx N/2$, any frequency content generated beyond this limit is aliased, or \"folded back,\" into the resolved wavenumber range, appearing as spurious contributions to lower modes. For a quadratic nonlinearity, the two-thirds dealiasing rule mitigates this. It involves truncating the Fourier-transformed product term $\\widehat{u^2}_k$, setting to zero all modes where $|k| > \\lfloor N/3 \\rfloor$. This ensures that the highest wavenumber in the resultant nonlinear term, $2\\lfloor N/3 \\rfloor$, is less than $N - \\lfloor N/3 \\rfloor$, which prevents the aliased modes from contaminating the retained modes $|k| \\le \\lfloor N/3 \\rfloor$.\n\nThe numerical experiment is designed to isolate and measure the aliasing error. The system's state $\\hat{u}_k(t)$ is evolved using a fourth-order Runge-Kutta (RK4) scheme. Crucially, the time-evolution step always uses the dealiased nonlinear term, $\\widehat{\\mathcal{N}}^{2/3}_k$, to ensure the reference state remains uncontaminated. At each time step $t_n$, before the RK4 update, the current state $\\hat{u}_k(t_n)$ is used to compute the instantaneous energy transfer rate into a band of low modes $\\mathcal{K}_\\ell = \\{k : |k| \\le k_\\ell\\}$. This rate is defined as $\\dot{E}_\\ell(t) = \\frac{1}{N}\\sum_{k \\in \\mathcal{K}_\\ell} \\Re\\left\\{\\hat{u}_k^*(t)\\,\\widehat{\\mathcal{N}[u]}_k(t)\\right\\}$. We calculate it for two cases:\n$1$. $\\dot{E}_\\ell^{\\mathrm{unal}}(t_n)$, using the raw, aliased nonlinear term $\\widehat{\\mathcal{N}}^{\\mathrm{unal}}_k$.\n$2$. $\\dot{E}_\\ell^{2/3}(t_n)$, using the dealiased nonlinear term $\\widehat{\\mathcal{N}}^{2/3}_k$.\n\nThe cumulative energy injected into the low-mode band over the integration time $[0, T]$ is approximated by a Riemann sum, $I \\approx \\sum_n \\dot{E}_\\ell(t_n) \\Delta t$. The final reported quantity, $D = I^{\\mathrm{unal}} - I^{2/3}$, represents the total excess energy spuriously injected into the low modes due to aliasing.\n\nThe implementation details are as follows. The initial condition is constructed directly in spectral space to avoid discretization errors from sampling. The time step $\\Delta t$ is determined from a CFL condition based on the initial maximum velocity, and the number of steps is adjusted to ensure the final time $T$ is reached precisely. The algorithm is implemented in Python using the `numpy` library for efficient FFT calculations and array manipulations. The solver iterates through the provided test cases, calculates $D$ for each, and reports the results.", "answer": "```python\nimport numpy as np\nfrom scipy import __version__ as scipy_version\nimport sys\n\ndef solve():\n    \"\"\"\n    Main function to run the numerical experiment for all test cases.\n    \"\"\"\n\n    def solve_case(N, nu, T, k_ell):\n        \"\"\"\n        Solves one test case for the Burgers equation aliasing problem.\n        \n        Args:\n            N (int): Number of grid points.\n            nu (float): Viscosity coefficient.\n            T (float): Total integration time.\n            k_ell (int): Cutoff wavenumber for low-mode energy measurement.\n\n        Returns:\n            float: The scalar quantity D, representing excess aliased energy.\n        \"\"\"\n        # Grid and wavenumbers\n        # We use the standard numpy.fft.fftfreq convention {-N/2, ..., N/2-1} for even N.\n        # This is required for compatibility with numpy's FFT algorithms.\n        dx = 2 * np.pi / N\n        k = np.fft.fftfreq(N, d=1.0 / N)  # Integer wavenumbers for domain [0, 2pi]\n\n        # Initial condition parameters\n        A1, A2, A3, phi = 1.0, 0.8, 0.5, 0.3\n        m1 = int(np.floor(N / 4))\n        m2 = int(np.floor(N / 5))\n        m3 = int(np.floor(N / 3)) - 1\n        \n        # Construct initial condition in spectral space\n        u_hat0 = np.zeros(N, dtype=np.complex128)\n        k_indices = {int(ki): i for i, ki in enumerate(k)}\n\n        # A1*sin(m1*x) = A1 * (e^{im1x} - e^{-im1x}) / 2i\n        if m1 in k_indices: u_hat0[k_indices[m1]] += A1 * N / (2j)\n        if -m1 in k_indices: u_hat0[k_indices[-m1]] -= A1 * N / (2j)\n        \n        # A2*cos(m2*x + phi) = A2 * (e^{i(m2x+phi)} + e^{-i(m2x+phi)}) / 2\n        if m2 in k_indices: u_hat0[k_indices[m2]] += A2 * N / 2 * np.exp(1j * phi)\n        if -m2 in k_indices: u_hat0[k_indices[-m2]] += A2 * N / 2 * np.exp(-1j * phi)\n\n        # A3*sin(m3*x)\n        if m3 in k_indices: u_hat0[k_indices[m3]] += A3 * N / (2j)\n        if -m3 in k_indices: u_hat0[k_indices[-m3]] -= A3 * N / (2j)\n\n        # Time step calculation\n        u_phys0 = np.fft.ifft(u_hat0)\n        u_max = np.max(np.abs(u_phys0))\n        alpha = 0.2\n        \n        if u_max  1e-9:\n            dt_cfl = alpha * dx / u_max\n        else:\n            # Fallback for zero initial condition, though not expected here\n            dt_cfl = 1e-3 \n\n        num_steps = int(np.ceil(T / dt_cfl))\n        dt = T / num_steps\n        \n        # Masks for dealiasing and energy measurement\n        dealias_cutoff = int(np.floor(N / 3))\n        dealias_mask = np.abs(k) = dealias_cutoff\n        low_mode_mask = np.abs(k) = k_ell\n        \n        # RK4 right-hand-side function (evolves with dealiasing)\n        def rhs(u_hat_in):\n            u_phys = np.fft.ifft(u_hat_in)\n            u_sq_phys = u_phys**2\n            u_sq_hat = np.fft.fft(u_sq_phys)\n            \n            # Apply 2/3 dealiasing rule\n            u_sq_hat_dealiased = u_sq_hat * dealias_mask\n            \n            nonlinear_term = -0.5j * k * u_sq_hat_dealiased\n            viscous_term = -nu * (k**2) * u_hat_in\n            return nonlinear_term + viscous_term\n\n        # Initialize state and cumulative energy sums\n        u_hat = u_hat0.copy()\n        I_unal = 0.0\n        I_23 = 0.0\n        \n        # Time integration loop\n        for _ in range(num_steps):\n            # Measure energy transfer rate at the start of the step\n            u_phys = np.fft.ifft(u_hat)\n            u_sq_phys = u_phys**2\n            u_sq_hat = np.fft.fft(u_sq_phys)\n            \n            # Unaliased nonlinear term\n            N_hat_unal = -0.5j * k * u_sq_hat\n            # Dealiased nonlinear term\n            N_hat_23 = N_hat_unal * dealias_mask\n\n            # Energy transfer rates into low modes\n            Edot_unal = (1/N) * np.real(np.sum(np.conj(u_hat) * N_hat_unal * low_mode_mask))\n            Edot_23 = (1/N) * np.real(np.sum(np.conj(u_hat) * N_hat_23 * low_mode_mask))\n            \n            # Accumulate energy injection (Riemann sum)\n            I_unal += Edot_unal * dt\n            I_23 += Edot_23 * dt\n            \n            # Evolve state using RK4\n            k1 = rhs(u_hat)\n            k2 = rhs(u_hat + dt / 2 * k1)\n            k3 = rhs(u_hat + dt / 2 * k2)\n            k4 = rhs(u_hat + dt * k3)\n            u_hat += dt / 6 * (k1 + 2 * k2 + 2 * k3 + k4)\n            \n        D = I_unal - I_23\n        return D\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (64, 1e-3, 0.5, 4),    # Test 1\n        (96, 5e-3, 0.4, 8),    # Test 2\n        (32, 0.0, 0.2, 3),     # Test 3\n        (128, 1e-2, 0.3, 6),   # Test 4\n    ]\n\n    results = []\n    for case in test_cases:\n        N, nu, T, k_ell = case\n        result = solve_case(N, nu, T, k_ell)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3362824"}]}