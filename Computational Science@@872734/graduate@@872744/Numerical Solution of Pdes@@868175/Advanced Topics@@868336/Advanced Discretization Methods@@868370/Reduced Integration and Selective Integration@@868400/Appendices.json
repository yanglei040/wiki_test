{"hands_on_practices": [{"introduction": "To truly understand numerical artifacts like volumetric locking, it is invaluable to observe them firsthand. This first practice provides a computational experiment to do just that, using a manufactured solution for a linear elasticity problem in the nearly incompressible regime. By comparing the results from a standard full integration scheme with those from a selective integration scheme, you will directly quantify the dramatic error reduction that selective integration provides, giving you a concrete appreciation for its role as a critical tool in computational solid mechanics [@problem_id:3439252].", "problem": "Consider two-dimensional, static, small-strain, homogeneous, isotropic linear elasticity on the unit square domain $\\Omega = [0,1] \\times [0,1]$ with Lamé parameters $(\\lambda,\\mu)$ in plane strain. Let the displacement field be $u: \\Omega \\to \\mathbb{R}^2$, with components $u_1$ and $u_2$. The governing equations are the equilibrium law $-\\nabla \\cdot \\sigma = f$ and the constitutive relation $\\sigma = 2\\mu\\,\\nabla^s u + \\lambda\\,(\\nabla \\cdot u)\\,I$, where $\\nabla^s u = \\tfrac{1}{2}(\\nabla u + \\nabla u^\\top)$ is the symmetric gradient. Consider the weak form in the standard Sobolev space where $u$ is constrained by Dirichlet boundary conditions on the entire boundary $\\partial\\Omega$.\n\nTo study the numerical effects of reduced integration and selective integration in the nearly incompressible regime, use the Finite Element Method (FEM) with bilinear (four-node) quadrilateral elements ($Q_1$) on a structured grid of the unit square. Employ a manufactured solution for the displacement field,\n$$\nu_{\\text{exact}}(x,y) = \\begin{bmatrix}\n\\sin(\\pi x)\\sin(\\pi y) \\\\\n\\sin(\\pi x)\\sin(\\pi y)\n\\end{bmatrix},\n$$\nand enforce Dirichlet boundary conditions $u = u_{\\text{exact}}$ on $\\partial\\Omega$. Derive the corresponding body force $f$ consistent with the partial differential equation so that $u_{\\text{exact}}$ is an exact solution of the strong form. Assemble and solve the discrete linear systems for two formulations:\n- Full integration: integrate both the deviatoric term $\\int_{\\Omega} 2\\mu\\,\\nabla^s u : \\nabla^s v\\,\\mathrm{d}\\Omega$ and the volumetric term $\\int_{\\Omega} \\lambda\\,(\\nabla \\cdot u)(\\nabla \\cdot v)\\,\\mathrm{d}\\Omega$ using the $2\\times 2$ Gaussian quadrature on the reference square.\n- Selective integration: integrate the deviatoric term using the $2\\times 2$ Gaussian quadrature but integrate the volumetric term using a $1$-point Gaussian quadrature at the element center on the reference square.\n\nStarting from the weak form derived from the equilibrium law and constitutive relation, construct the discrete system using the bilinear shape functions and standard isoparametric mapping. For both formulations, compute the numerical solution $u_h$ and quantify:\n1. The displacement $L^2$-norm error,\n$$\nE_u = \\left( \\int_{\\Omega} \\|u_h - u_{\\text{exact}}\\|^2 \\,\\mathrm{d}\\Omega \\right)^{1/2}.\n$$\n2. The volumetric $L^2$-norm error,\n$$\nE_{\\nabla\\cdot u} = \\left( \\int_{\\Omega} \\left( \\nabla \\cdot u_h - \\nabla \\cdot u_{\\text{exact}} \\right)^2 \\,\\mathrm{d}\\Omega \\right)^{1/2}.\n$$\n\nUse the $2\\times 2$ Gaussian quadrature to evaluate these errors. Define the locking mitigation factor as the ratio $R_{\\text{lock}} = E_u^{\\text{full}} / E_u^{\\text{sel}}$; values greater than $1$ indicate that selective integration reduces the displacement error relative to full integration (mitigates locking). Define the volumetric error factor as $R_{\\text{vol}} = E_{\\nabla\\cdot u}^{\\text{sel}} / E_{\\nabla\\cdot u}^{\\text{full}}$; values greater than $1$ indicate that selective integration increases the volumetric error relative to full integration.\n\nYour program must:\n- Derive and implement the body force $f$ consistent with $u_{\\text{exact}}$ using the strong form $-\\nabla\\cdot\\sigma=f$ with $\\sigma = 2\\mu\\,\\nabla^s u + \\lambda(\\nabla\\cdot u) I$.\n- Assemble the stiffness matrices for both full and selective integration schemes exactly as described.\n- Assemble the load vector using the $2\\times 2$ Gaussian quadrature.\n- Enforce Dirichlet boundary conditions $u=u_{\\text{exact}}$ on $\\partial\\Omega$.\n- Solve both discrete systems and compute $E_u$ and $E_{\\nabla\\cdot u}$ for each.\n\nTest suite:\nProvide four test cases as tuples $(N_x,N_y,\\lambda,\\mu)$, where $N_x$ and $N_y$ are the number of elements in the $x$ and $y$ directions:\n1. $(8,8,1,1)$: compressible baseline.\n2. $(8,8,10^3,1)$: moderately nearly incompressible.\n3. $(8,8,10^6,1)$: strongly nearly incompressible.\n4. $(4,4,10^6,1)$: coarse mesh under strong near-incompressibility.\n\nFor each test case, compute and return the list\n$$\n\\left[ E_u^{\\text{full}},\\, E_u^{\\text{sel}},\\, R_{\\text{lock}},\\, E_{\\nabla\\cdot u}^{\\text{full}},\\, E_{\\nabla\\cdot u}^{\\text{sel}},\\, R_{\\text{vol}} \\right].\n$$\n\nFinal output format:\nYour program should produce a single line of output containing the results for all test cases as a comma-separated list of lists enclosed in square brackets, for example, \n$[ [\\text{case1\\_results}], [\\text{case2\\_results}], [\\text{case3\\_results}], [\\text{case4\\_results}] ]$.\nNo physical units are involved in this problem. Angles, if any appear, must be measured in radians. All numerical answers must be floats.", "solution": "The user-provided problem is validated as scientifically grounded, well-posed, and objective. It is a standard verification problem in computational solid mechanics designed to analyze volumetric locking in the Finite Element Method (FEM) and the efficacy of selective integration as a remedy. The solution proceeds as follows.\n\n### 1. Governing Equations and Weak Form\nThe problem concerns two-dimensional, static, linear elasticity on the unit square domain $\\Omega = [0,1] \\times [0,1]$. The governing equations consist of the equilibrium law and the constitutive relation for a homogeneous, isotropic material under plane strain conditions:\n$$-\\nabla \\cdot \\sigma = f \\quad \\text{in } \\Omega$$\n$$\\sigma = 2\\mu\\,\\nabla^s u + \\lambda\\,(\\nabla \\cdot u)\\,I$$\nwhere $u$ is the displacement field, $f$ is the body force per unit volume, $\\sigma$ is the Cauchy stress tensor, $\\lambda$ and $\\mu$ are the Lamé parameters, $\\nabla^s u = \\frac{1}{2}(\\nabla u + (\\nabla u)^\\top)$ is the symmetric gradient (engineering strain tensor), and $I$ is the identity tensor.\n\nThe weak form is derived by multiplying the equilibrium equation by a vector-valued test function $v$ (from a suitable function space where $v=0$ on the Dirichlet boundary) and integrating over $\\Omega$. Applying integration by parts (Green's identity) and substituting the constitutive relation yields the bilinear form $a(u,v)$ and linear form $L(v)$:\n$$a(u,v) = \\int_{\\Omega} \\sigma(u) : \\nabla^s v \\, \\mathrm{d}\\Omega = \\int_{\\Omega} \\left( 2\\mu\\,\\nabla^s u : \\nabla^s v + \\lambda\\,(\\nabla \\cdot u)(\\nabla \\cdot v) \\right) \\mathrm{d}\\Omega$$\n$$L(v) = \\int_{\\Omega} f \\cdot v \\, \\mathrm{d}\\Omega$$\nThe task is to find the trial function $u$ satisfying the Dirichlet boundary conditions such that $a(u,v) = L(v)$ for all admissible test functions $v$. The bilinear form $a(u,v)$ is naturally decomposed into a deviatoric part (related to shape change at constant volume) and a volumetric part (related to volume change):\n$$a_{dev}(u,v) = \\int_{\\Omega} 2\\mu\\,\\nabla^s u : \\nabla^s v \\,\\mathrm{d}\\Omega$$\n$$a_{vol}(u,v) = \\int_{\\Omega} \\lambda\\,(\\nabla \\cdot u)(\\nabla \\cdot v)\\,\\mathrm{d}\\Omega$$\n\n### 2. Body Force Derivation\nA manufactured solution $u_{\\text{exact}}(x,y) = [\\sin(\\pi x)\\sin(\\pi y), \\sin(\\pi x)\\sin(\\pi y)]^T$ is used for verification. The corresponding body force $f$ is derived by inserting $u_{\\text{exact}}$ into the strong form of the equilibrium equation, $f = -\\nabla \\cdot \\sigma(u_{\\text{exact}})$.\n\nFirst, we compute the gradient and divergence of $u_{\\text{exact}}$:\n$$\\nabla u_{\\text{exact}} = \\pi \\begin{bmatrix} \\cos(\\pi x)\\sin(\\pi y) & \\sin(\\pi x)\\cos(\\pi y) \\\\ \\cos(\\pi x)\\sin(\\pi y) & \\sin(\\pi x)\\cos(\\pi y) \\end{bmatrix}$$\n$$\\nabla \\cdot u_{\\text{exact}} = \\pi\\cos(\\pi x)\\sin(\\pi y) + \\pi\\sin(\\pi x)\\cos(\\pi y) = \\pi\\sin(\\pi(x+y))$$\nThe stress tensor components are then:\n$$\\sigma_{11} = (\\lambda+2\\mu)\\frac{\\partial u_1}{\\partial x} + \\lambda\\frac{\\partial u_2}{\\partial y} = (\\lambda+2\\mu)\\pi\\cos(\\pi x)\\sin(\\pi y) + \\lambda\\pi\\sin(\\pi x)\\cos(\\pi y)$$\nNo, the problem states $\\sigma = 2\\mu\\,\\nabla^s u + \\lambda\\,(\\nabla \\cdot u)\\,I$. This definition is slightly different. Re-deriving with the given form:\n$$ \\sigma_{11} = 2\\mu (\\nabla^s u)_{11} + \\lambda (\\nabla \\cdot u) = 2\\mu \\frac{\\partial u_1}{\\partial x} + \\lambda (\\nabla \\cdot u) = 2\\mu\\pi\\cos(\\pi x)\\sin(\\pi y) + \\lambda\\pi\\sin(\\pi(x+y)) $$\n$$ \\sigma_{22} = 2\\mu (\\nabla^s u)_{22} + \\lambda (\\nabla \\cdot u) = 2\\mu \\frac{\\partial u_2}{\\partial y} + \\lambda (\\nabla \\cdot u) = 2\\mu\\pi\\sin(\\pi x)\\cos(\\pi y) + \\lambda\\pi\\sin(\\pi(x+y)) $$\n$$ \\sigma_{12} = 2\\mu (\\nabla^s u)_{12} = \\mu \\left( \\frac{\\partial u_1}{\\partial y} + \\frac{\\partial u_2}{\\partial x} \\right) = \\mu\\pi(\\sin(\\pi x)\\cos(\\pi y) + \\cos(\\pi x)\\sin(\\pi y)) = \\mu\\pi\\sin(\\pi(x+y))$$\nFinally, taking the negative divergence of the stress tensor $\\sigma$:\n$$f_1 = -(\\frac{\\partial\\sigma_{11}}{\\partial x} + \\frac{\\partial\\sigma_{12}}{\\partial y}) = 2\\mu\\pi^2\\sin(\\pi x)\\sin(\\pi y) - (\\lambda+\\mu)\\pi^2\\cos(\\pi(x+y))$$\n$$f_2 = -(\\frac{\\partial\\sigma_{21}}{\\partial x} + \\frac{\\partial\\sigma_{22}}{\\partial y}) = 2\\mu\\pi^2\\sin(\\pi x)\\sin(\\pi y) - (\\lambda+\\mu)\\pi^2\\cos(\\pi(x+y))$$\nThe body force is $f = [f_1, f_2]^T$.\n\n### 3. Finite Element Discretization\nThe domain $\\Omega$ is discretized into a structured mesh of $N_x \\times N_y$ bilinear quadrilateral ($Q_1$) elements. Within each element, the displacement field is approximated as $u_h(x,y) = \\sum_{a=1}^{4} N_a(\\xi,\\eta) d_a$, where $d_a$ is the nodal displacement vector at node $a$, and $N_a$ are the bilinear shape functions on the reference square $[-1,1] \\times [-1,1]$.\n\nThe discrete system of equations is $Kd=F$, where $K$ is the global stiffness matrix, $F$ is the global force vector, and $d$ is the vector of all nodal displacements. The element stiffness matrix $K^e$ and force vector $F^e$ are computed via numerical integration (Gaussian quadrature) over the element domain $\\Omega_e$:\n$$K^e_{ij} = a(v_j, v_i)|_{\\Omega_e}, \\quad F^e_i = L(v_i)|_{\\Omega_e}$$\nwhere $v_i$ are the basis functions associated with the element's degrees of freedom. Using Voigt notation for strains $\\varepsilon = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^T$, the element stiffness matrix can be written as $K^e = \\int_{\\Omega_e} B^T D B \\, \\mathrm{d}\\Omega$, where $B$ is the standard strain-displacement matrix and $D$ is the constitutive matrix for plane strain.\n\nThe key to this problem lies in the integration scheme for $K^e$. The stiffness matrix is additively decomposed, $K^e = K^e_{dev} + K^e_{vol}$, corresponding to the deviatoric and volumetric parts of the weak form.\n- $K^e_{dev}$ arises from $a_{dev}(u,v)$ and is integrated using $2\\mu \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1/2 \\end{pmatrix}$ as the deviatoric part of the constitutive matrix.\n- $K^e_{vol}$ arises from $a_{vol}(u,v)$ and is integrated from $\\lambda \\begin{pmatrix} 1 & 1 & 0 \\\\ 1 & 1 & 0 \\\\ 0 & 0 & 0 \\end{pmatrix}$ as the volumetric part.\n\nTwo integration schemes are implemented:\n1.  **Full Integration**: Both $K^e_{dev}$ and $K^e_{vol}$ are computed by numerically integrating their respective integrands using a $2 \\times 2$ Gaussian quadrature rule on the reference element.\n2.  **Selective Integration**: $K^e_{dev}$ is computed using $2 \\times 2$ Gaussian quadrature, but $K^e_{vol}$ is computed using a single-point ($1 \\times 1$) Gaussian quadrature at the element center $(\\xi=0, \\eta=0)$. This under-integration of the volumetric term is a standard technique to alleviate volumetric locking in nearly incompressible materials ($\\lambda \\gg \\mu$).\n\nThe load vector $F$ is assembled using a $2 \\times 2$ Gaussian quadrature for all cases.\n\n### 4. System Solution and Error Computation\nDirichlet boundary conditions $u_h = u_{\\text{exact}}$ are enforced for all nodes on the boundary $\\partial\\Omega$. The global system $Kd=F$ is partitioned into interior and boundary degrees of freedom. The system is modified to solve for the unknown interior displacements, after which the full solution vector is reconstructed.\n\nWith the numerical solution $u_h$ obtained for both integration schemes, the following errors are computed using a $2 \\times 2$ Gaussian quadrature:\n-   Displacement $L^2$-norm error: $E_u = \\left( \\sum_e \\int_{\\Omega_e} \\|u_h - u_{\\text{exact}}\\|^2 \\,\\mathrm{d}\\Omega \\right)^{1/2}$\n-   Volumetric $L^2$-norm error: $E_{\\nabla\\cdot u} = \\left( \\sum_e \\int_{\\Omega_e} \\left( \\nabla \\cdot u_h - \\nabla \\cdot u_{\\text{exact}} \\right)^2 \\,\\mathrm{d}\\Omega \\right)^{1/2}$\n\nFinally, the locking mitigation factor $R_{\\text{lock}} = E_u^{\\text{full}} / E_u^{\\text{sel}}$ and the volumetric error factor $R_{\\text{vol}} = E_{\\nabla\\cdot u}^{\\text{sel}} / E_{\\nabla\\cdot u}^{\\text{full}}$ are calculated to quantify the performance of selective integration.", "answer": "```python\nimport numpy as np\nimport scipy.linalg\n\ndef solve():\n    \"\"\"\n    Main function to solve the specified FEM problem for all test cases.\n    \"\"\"\n    # Test cases: (Nx, Ny, lambda, mu)\n    test_cases = [\n        (8, 8, 1.0, 1.0),\n        (8, 8, 1e3, 1.0),\n        (8, 8, 1e6, 1.0),\n        (4, 4, 1e6, 1.0)\n    ]\n\n    # Gauss quadrature points and weights\n    # 2x2 Gauss quadrature\n    gp_2x2_coords = np.array([-1.0/np.sqrt(3.0), 1.0/np.sqrt(3.0)])\n    gp_2x2_weights = np.array([1.0, 1.0])\n\n    # 1-point Gauss quadrature (at center)\n    gp_1x1_coords = np.array([0.0])\n    gp_1x1_weights = np.array([2.0])\n\n    def shape_functions_quad4(xi, eta):\n        \"\"\"\n        Computes shape functions and their derivatives for a 4-node quad element.\n        N: shape function values (4,)\n        dNdxi_eta: derivatives w.r.t. xi, eta (2, 4)\n        \"\"\"\n        N = 0.25 * np.array([\n            (1.0 - xi) * (1.0 - eta),\n            (1.0 + xi) * (1.0 - eta),\n            (1.0 + xi) * (1.0 + eta),\n            (1.0 - xi) * (1.0 + eta)\n        ])\n        \n        dNdxi_eta = 0.25 * np.array([\n            [-(1.0 - eta), (1.0 - eta), (1.0 + eta), -(1.0 + eta)],  # d/dxi\n            [-(1.0 - xi), -(1.0 + xi), (1.0 + xi), (1.0 - xi)]   # d/deta\n        ])\n        \n        return N, dNdxi_eta\n\n    def get_b_matrix_and_jacobian_det(dNdxi_eta, el_nodes_coords):\n        \"\"\"\n        Computes the Jacobian, its determinant, and the B matrix.\n        \"\"\"\n        J = dNdxi_eta @ el_nodes_coords # Jacobian matrix (2, 2)\n        detJ = np.linalg.det(J)\n        \n        if detJ <= 0.0:\n            raise ValueError(\"Jacobian determinant is non-positive.\")\n        \n        J_inv = np.linalg.inv(J)\n        dNdx_dy = J_inv @ dNdxi_eta # (2, 4)\n        \n        B = np.zeros((3, 8))\n        for i in range(4):\n            B[0, 2*i] = dNdx_dy[0, i]\n            B[1, 2*i+1] = dNdx_dy[1, i]\n            B[2, 2*i] = dNdx_dy[1, i]\n            B[2, 2*i+1] = dNdx_dy[0, i]\n            \n        return B, detJ\n\n    def u_exact(x, y):\n        val = np.sin(np.pi * x) * np.sin(np.pi * y)\n        return np.array([val, val])\n\n    def div_u_exact(x, y):\n        return np.pi * np.sin(np.pi * (x + y))\n\n    def body_force(x, y, lam, mu):\n        pi2 = np.pi**2\n        sxy = np.sin(np.pi * x) * np.sin(np.pi * y)\n        cxy_sum = np.cos(np.pi * (x + y))\n        f_val = 2.0 * mu * pi2 * sxy - (lam + mu) * pi2 * cxy_sum\n        return np.array([f_val, f_val])\n\n    def run_fem_analysis(Nx, Ny, lam, mu):\n        # 1. Mesh Generation\n        num_nodes_x = Nx + 1\n        num_nodes_y = Ny + 1\n        num_nodes = num_nodes_x * num_nodes_y\n        num_elements = Nx * Ny\n        \n        x_coords = np.linspace(0.0, 1.0, num_nodes_x)\n        y_coords = np.linspace(0.0, 1.0, num_nodes_y)\n        \n        nodes = np.array([[x, y] for y in y_coords for x in x_coords])\n        \n        elements = np.zeros((num_elements, 4), dtype=int)\n        for ey in range(Ny):\n            for ex in range(Nx):\n                el_idx = ey * Nx + ex\n                n1 = ey * num_nodes_x + ex             # Bottom-left\n                n2 = ey * num_nodes_x + (ex + 1)       # Bottom-right\n                n3 = (ey + 1) * num_nodes_x + (ex + 1) # Top-right\n                n4 = (ey + 1) * num_nodes_x + ex       # Top-left\n                elements[el_idx] = [n1, n2, n3, n4]\n                \n        # 2. Constitutive Matrices (for integration)\n        D_vol = lam * np.array([[1.0, 1.0, 0.0], [1.0, 1.0, 0.0], [0.0, 0.0, 0.0]])\n        D_dev = 2.0 * mu * np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 0.5]])\n        \n        # 3. Assembly\n        num_dofs = 2 * num_nodes\n        K_full = np.zeros((num_dofs, num_dofs))\n        K_sel = np.zeros((num_dofs, num_dofs))\n        F = np.zeros(num_dofs)\n        \n        for el_idx in range(num_elements):\n            el_node_indices = elements[el_idx]\n            el_nodes_coords = nodes[el_node_indices]\n            dofs = np.ravel([[2*n, 2*n+1] for n in el_node_indices])\n            \n            Ke_dev = np.zeros((8, 8))\n            Ke_vol_full = np.zeros((8, 8))\n            \n            # 2x2 Quadrature for dev, vol_full and Force\n            for w_eta, eta in zip(gp_2x2_weights, gp_2x2_coords):\n                for w_xi, xi in zip(gp_2x2_weights, gp_2x2_coords):\n                    N, dNdxi_eta = shape_functions_quad4(xi, eta)\n                    B, detJ = get_b_matrix_and_jacobian_det(dNdxi_eta, el_nodes_coords)\n                    weight = w_xi * w_eta * detJ\n                    \n                    Ke_dev += B.T @ D_dev @ B * weight\n                    Ke_vol_full += B.T @ D_vol @ B * weight\n                    \n                    x_gp, y_gp = N @ el_nodes_coords\n                    f_gp = body_force(x_gp, y_gp, lam, mu)\n                    for i in range(4):\n                        F[dofs[2*i]]   += N[i] * f_gp[0] * weight\n                        F[dofs[2*i+1]] += N[i] * f_gp[1] * weight\n            \n            # 1-point Quadrature for vol_sel\n            xi_c, eta_c = gp_1x1_coords[0], gp_1x1_coords[0]\n            w_c = gp_1x1_weights[0] * gp_1x1_weights[0]\n            N_c, dNdxi_eta_c = shape_functions_quad4(xi_c, eta_c)\n            B_c, detJ_c = get_b_matrix_and_jacobian_det(dNdxi_eta_c, el_nodes_coords)\n            Ke_vol_sel = B_c.T @ D_vol @ B_c * (w_c * detJ_c)\n            \n            ix = np.ix_(dofs, dofs)\n            K_full[ix] += Ke_dev + Ke_vol_full\n            K_sel[ix] += Ke_dev + Ke_vol_sel\n\n        # 4. Boundary Conditions\n        b_nodes = set(np.concatenate([\n            np.arange(num_nodes_x), # Bottom\n            np.arange(num_nodes - num_nodes_x, num_nodes), # Top\n            np.arange(0, num_nodes, num_nodes_x), # Left\n            np.arange(num_nodes_x - 1, num_nodes, num_nodes_x) # Right\n        ]))\n        \n        boundary_dofs = np.ravel([[2*n, 2*n+1] for n in sorted(list(b_nodes))])\n        interior_dofs = np.setdiff1d(np.arange(num_dofs), boundary_dofs)\n        \n        d_B = np.array([u_exact(nodes[dof//2, 0], nodes[dof//2, 1])[dof%2] for dof in boundary_dofs])\n        \n        def solve_system(K):\n            K_II = K[np.ix_(interior_dofs, interior_dofs)]\n            K_IB = K[np.ix_(interior_dofs, boundary_dofs)]\n            F_I = F[interior_dofs]\n            F_mod = F_I - K_IB @ d_B\n            d_I = scipy.linalg.solve(K_II, F_mod, assume_a='sym')\n            d = np.zeros(num_dofs)\n            d[interior_dofs] = d_I\n            d[boundary_dofs] = d_B\n            return d\n\n        d_full = solve_system(K_full)\n        d_sel = solve_system(K_sel)\n\n        # 5. Error Calculation\n        def calculate_errors(d_sol):\n            err_u_sq, err_div_u_sq = 0.0, 0.0\n            for el_idx in range(num_elements):\n                el_node_indices, el_nodes_coords = elements[el_idx], nodes[elements[el_idx]]\n                d_elem = d_sol[np.ravel([[2*n, 2*n+1] for n in el_node_indices])]\n                \n                for w_eta, eta in zip(gp_2x2_weights, gp_2x2_coords):\n                    for w_xi, xi in zip(gp_2x2_weights, gp_2x2_coords):\n                        N, dNdxi_eta = shape_functions_quad4(xi, eta)\n                        B, detJ = get_b_matrix_and_jacobian_det(dNdxi_eta, el_nodes_coords)\n                        weight = w_xi * w_eta * detJ\n                        \n                        x_gp, y_gp = N @ el_nodes_coords\n                        u_h_gp = np.array([N @ d_elem[0::2], N @ d_elem[1::2]])\n                        err_u_sq += np.sum((u_h_gp - u_exact(x_gp, y_gp))**2) * weight\n                        \n                        strain_h_gp = B @ d_elem\n                        err_div_u_sq += (strain_h_gp[0] + strain_h_gp[1] - div_u_exact(x_gp, y_gp))**2 * weight\n            return np.sqrt(err_u_sq), np.sqrt(err_div_u_sq)\n\n        Eu_full, Edivu_full = calculate_errors(d_full)\n        Eu_sel, Edivu_sel = calculate_errors(d_sel)\n        \n        R_lock = Eu_full / Eu_sel if Eu_sel > 1e-15 else 0.0\n        R_vol = Edivu_sel / Edivu_full if Edivu_full > 1e-15 else 0.0\n        \n        return [Eu_full, Eu_sel, R_lock, Edivu_full, Edivu_sel, R_vol]\n\n    all_results = [run_fem_analysis(*case) for case in test_cases]\n    \n    # Format the final output string\n    result_str = \"[\" + \", \".join([str(res) for res in all_results]) + \"]\"\n    print(result_str)\n\nsolve()\n```", "id": "3439252"}, {"introduction": "Having witnessed the macroscopic effect of selective integration in mitigating locking, we now drill down to the microscopic level of a single finite element. This exercise requires a first-principles, analytical derivation of an element's strain energy under a specific deformation mode. By calculating the energy ratio between a selectively integrated element and a fully integrated one, you will uncover the precise mechanism by which this technique softens the element's response to certain deformations, providing the fundamental insight behind its success [@problem_id:3439222].", "problem": "Consider isotropic linear elasticity in plane strain on a single isoparametric bilinear quadrilateral ($Q_1$) finite element. The element occupies the physical square $\\Omega_e = [0,L] \\times [0,L]$ with $L>0$. Use the standard reference square $(\\xi,\\eta) \\in [-1,1] \\times [-1,1]$ with affine mapping $x = \\frac{L}{2}(\\xi+1)$, $y = \\frac{L}{2}(\\eta+1)$, so the Jacobian determinant is $|J| = \\frac{L^2}{4}$.\n\nLet the four $Q_1$ shape functions be\n$$\nN_1(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta),\\quad\nN_2(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta),\\quad\nN_3(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta),\\quad\nN_4(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta).\n$$\nAssume the displacement field is interpolated as $u(x,y) = \\sum_{i=1}^{4} N_i(\\xi,\\eta)\\,u_i$ and $v(x,y) = \\sum_{i=1}^{4} N_i(\\xi,\\eta)\\,v_i$, where $(u_i,v_i)$ are the nodal values in the $x$- and $y$-directions, respectively. Consider the specific nodal vector where only the $x$-displacement at node $1$ is nonzero: $u_1=1$, $v_1=0$, and $u_2=u_3=u_4=v_2=v_3=v_4=0$.\n\nUse the small-strain definition $\\boldsymbol{\\varepsilon} = \\frac{1}{2}(\\nabla \\mathbf{u} + \\nabla \\mathbf{u}^{\\top})$ so that $\\varepsilon_{xx} = \\partial u/\\partial x$, $\\varepsilon_{yy} = \\partial v/\\partial y$, and $\\varepsilon_{xy} = \\frac{1}{2}(\\partial u/\\partial y + \\partial v/\\partial x)$. Adopt the volumetric-deviatoric split in two dimensions: $\\boldsymbol{\\varepsilon}_{\\text{dev}} = \\boldsymbol{\\varepsilon} - \\frac{1}{2}(\\operatorname{tr}\\boldsymbol{\\varepsilon})\\,\\mathbf{I}$, with energy density\n$$\nw(\\boldsymbol{\\varepsilon}) = \\mu\\,\\boldsymbol{\\varepsilon}_{\\text{dev}}:\\boldsymbol{\\varepsilon}_{\\text{dev}} + \\frac{\\kappa}{2}\\,(\\operatorname{tr}\\boldsymbol{\\varepsilon})^2,\n$$\nwhere $\\mu>0$ is the shear modulus and $\\kappa = \\lambda + \\mu$ is the two-dimensional bulk modulus expressed in terms of the Lamé parameter $\\lambda>0$ and $\\mu$.\n\nDefine the element energy for a given displacement field as $E = \\int_{\\Omega_e} w(\\boldsymbol{\\varepsilon})\\, d\\Omega$. Compute the following two energies for the given nodal vector:\n- $E_{\\text{full}}$, using the standard full $2\\times 2$ Gaussian quadrature on the reference element for both the deviatoric and volumetric contributions.\n- $E_{\\text{sel}}$, using selective integration: apply full $2\\times 2$ Gaussian quadrature for the deviatoric contribution and reduced $1\\times 1$ Gaussian quadrature (evaluation at $(\\xi,\\eta)=(0,0)$ with weight $4$ on the reference element) for the volumetric contribution.\n\nFrom first principles and the definitions above, derive $E_{\\text{full}}$ and $E_{\\text{sel}}$ and report the single closed-form analytic expression for the ratio\n$$\nr \\equiv \\frac{E_{\\text{sel}}}{E_{\\text{full}}}\n$$\nas a function of $\\lambda$ and $\\mu$. No numerical rounding is required. Express the final answer as a single analytic expression.", "solution": "The user wants to compute the ratio of elastic energies for a single finite element under a specific deformation, calculated with two different numerical integration schemes: full quadrature and selective-reduced quadrature.\n\nFirst, we must validate the problem statement.\n1.  **Extract Givens**: The problem provides the geometry of a bilinear quadrilateral element, the mapping from a reference element, the shape functions $N_i$, a specific nodal displacement vector, the definitions for strain and a volumetric-deviatoric split of the strain energy density, material parameters $\\mu$ and $\\kappa = \\lambda + \\mu$, and the definition of two integration schemes (full $2 \\times 2$ Gaussian quadrature and selective $2 \\times 2 / 1 \\times 1$ quadrature).\n2.  **Validate**: The problem is scientifically grounded in the theory of linear elasticity and the finite element method. All definitions and constants are standard in this field. The problem is well-posed, with a clear objective and all necessary information provided. There are no contradictions, ambiguities, or pseudoscientific claims.\n3.  **Verdict**: The problem is valid.\n\nWe now proceed to derive the solution.\n\nThe displacement field $(\\,u(\\xi,\\eta), v(\\xi,\\eta)\\,)$ within the element is interpolated from the nodal values $(u_i,v_i)$ using the shape functions $N_i(\\xi,\\eta)$. Given the nodal displacement vector $u_1=1$ and all other $u_i, v_i$ are zero, the displacement field simplifies to:\n$$\nu(\\xi,\\eta) = N_1(\\xi,\\eta) \\cdot u_1 = N_1(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta)\n$$\n$$\nv(\\xi,\\eta) = 0\n$$\n\nTo compute the strain tensor $\\boldsymbol{\\varepsilon}$, we need the spatial derivatives of the displacement field. The mapping from the reference coordinates $(\\xi,\\eta)$ to physical coordinates $(x,y)$ is given by $x = \\frac{L}{2}(\\xi+1)$ and $y = \\frac{L}{2}(\\eta+1)$. The Jacobian matrix of this transformation is:\n$$\n\\mathbf{J} = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix} = \\begin{pmatrix} \\frac{L}{2} & 0 \\\\ 0 & \\frac{L}{2} \\end{pmatrix}\n$$\nThe determinant of the Jacobian is $|J| = \\frac{L^2}{4}$, which is constant. The inverse Jacobian is:\n$$\n\\mathbf{J}^{-1} = \\begin{pmatrix} \\frac{2}{L} & 0 \\\\ 0 & \\frac{2}{L} \\end{pmatrix}\n$$\nThe gradient operator in physical coordinates is related to the gradient in reference coordinates by $\\begin{pmatrix} \\partial/\\partial x \\\\ \\partial/\\partial y \\end{pmatrix} = \\mathbf{J}^{-1} \\begin{pmatrix} \\partial/\\partial \\xi \\\\ \\partial/\\partial \\eta \\end{pmatrix}$.\nThe derivatives of the displacement components are:\n$$\n\\frac{\\partial u}{\\partial x} = \\frac{2}{L} \\frac{\\partial u}{\\partial \\xi} = \\frac{2}{L} \\left( -\\frac{1}{4}(1-\\eta) \\right) = -\\frac{1}{2L}(1-\\eta) = \\frac{1}{2L}(\\eta-1)\n$$\n$$\n\\frac{\\partial u}{\\partial y} = \\frac{2}{L} \\frac{\\partial u}{\\partial \\eta} = \\frac{2}{L} \\left( -\\frac{1}{4}(1-\\xi) \\right) = -\\frac{1}{2L}(1-\\xi) = \\frac{1}{2L}(\\xi-1)\n$$\n$$\n\\frac{\\partial v}{\\partial x} = 0, \\quad \\frac{\\partial v}{\\partial y} = 0\n$$\nThe components of the small-strain tensor $\\boldsymbol{\\varepsilon}$ are:\n$$\n\\varepsilon_{xx} = \\frac{\\partial u}{\\partial x} = \\frac{1}{2L}(\\eta-1)\n$$\n$$\n\\varepsilon_{yy} = \\frac{\\partial v}{\\partial y} = 0\n$$\n$$\n\\varepsilon_{xy} = \\frac{1}{2}\\left(\\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x}\\right) = \\frac{1}{2} \\frac{1}{2L}(\\xi-1) = \\frac{1}{4L}(\\xi-1)\n$$\nThe trace of the strain tensor is $\\operatorname{tr}\\boldsymbol{\\varepsilon} = \\varepsilon_{xx} + \\varepsilon_{yy} = \\frac{1}{2L}(\\eta-1)$.\n\nThe element's total strain energy $E$ is the integral of the energy density $w(\\boldsymbol{\\varepsilon})$ over the element's area $\\Omega_e$. The energy density is split into deviatoric and volumetric parts: $w(\\boldsymbol{\\varepsilon}) = w_{\\text{dev}} + w_{\\text{vol}}$.\n$$\nw_{\\text{vol}} = \\frac{\\kappa}{2}(\\operatorname{tr}\\boldsymbol{\\varepsilon})^2 = \\frac{\\kappa}{2} \\left(\\frac{1}{2L}(\\eta-1)\\right)^2 = \\frac{\\kappa}{8L^2}(1-\\eta)^2\n$$\nThe deviatoric strain tensor components are $\\boldsymbol{\\varepsilon}_{\\text{dev}} = \\boldsymbol{\\varepsilon} - \\frac{1}{2}(\\operatorname{tr}\\boldsymbol{\\varepsilon})\\mathbf{I}$:\n$$\n\\varepsilon_{\\text{dev},xx} = \\varepsilon_{xx} - \\frac{1}{2}\\operatorname{tr}\\boldsymbol{\\varepsilon} = \\frac{1}{2L}(\\eta-1) - \\frac{1}{4L}(\\eta-1) = \\frac{1}{4L}(\\eta-1)\n$$\n$$\n\\varepsilon_{\\text{dev},yy} = \\varepsilon_{yy} - \\frac{1}{2}\\operatorname{tr}\\boldsymbol{\\varepsilon} = 0 - \\frac{1}{4L}(\\eta-1) = -\\frac{1}{4L}(\\eta-1)\n$$\n$$\n\\varepsilon_{\\text{dev},xy} = \\varepsilon_{xy} = \\frac{1}{4L}(\\xi-1)\n$$\nThe deviatoric energy density is $w_{\\text{dev}} = \\mu\\,\\boldsymbol{\\varepsilon}_{\\text{dev}}:\\boldsymbol{\\varepsilon}_{\\text{dev}} = \\mu ((\\varepsilon_{\\text{dev},xx})^2 + (\\varepsilon_{\\text{dev},yy})^2 + 2(\\varepsilon_{\\text{dev},xy})^2)$:\n$$\nw_{\\text{dev}} = \\mu \\left[ \\left(\\frac{\\eta-1}{4L}\\right)^2 + \\left(-\\frac{\\eta-1}{4L}\\right)^2 + 2\\left(\\frac{\\xi-1}{4L}\\right)^2 \\right] = \\frac{\\mu}{16L^2} \\left[ 2(1-\\eta)^2 + 2(1-\\xi)^2 \\right] = \\frac{\\mu}{8L^2} \\left[ (1-\\xi)^2 + (1-\\eta)^2 \\right]\n$$\nThe total energy is $E = \\int_{\\Omega_e} w(\\boldsymbol{\\varepsilon}) d\\Omega = \\int_{-1}^{1}\\int_{-1}^{1} w(\\boldsymbol{\\varepsilon}(\\xi,\\eta)) |J| d\\xi d\\eta$. We define the integrands over the reference element:\n$$\nI_{\\text{dev}}(\\xi,\\eta) = w_{\\text{dev}} |J| = \\frac{\\mu}{8L^2} \\left[ (1-\\xi)^2 + (1-\\eta)^2 \\right] \\frac{L^2}{4} = \\frac{\\mu}{32} \\left[ (1-\\xi)^2 + (1-\\eta)^2 \\right]\n$$\n$$\nI_{\\text{vol}}(\\xi,\\eta) = w_{\\text{vol}} |J| = \\frac{\\kappa}{8L^2}(1-\\eta)^2 \\frac{L^2}{4} = \\frac{\\kappa}{32}(1-\\eta)^2\n$$\nSince the integrands are quadratic polynomials, the $2 \\times 2$ Gaussian quadrature is exact. Let's compute the exact integrals, which will correspond to the full integration scheme.\nThe deviatoric energy is:\n$$\nE_{\\text{dev}} = \\int_{-1}^{1}\\int_{-1}^{1} I_{\\text{dev}}(\\xi,\\eta) d\\xi d\\eta = \\frac{\\mu}{32} \\int_{-1}^{1}\\int_{-1}^{1} \\left[ (1-\\xi)^2 + (1-\\eta)^2 \\right] d\\xi d\\eta\n$$\nWe use the fact that $\\int_{-1}^{1} (1-t)^2 dt = \\left[-\\frac{(1-t)^3}{3}\\right]_{-1}^{1} = 0 - (-\\frac{8}{3}) = \\frac{8}{3}$.\n$$\nE_{\\text{dev}} = \\frac{\\mu}{32} \\left[ \\left(\\frac{8}{3}\\right) \\cdot \\int_{-1}^1 d\\eta + \\left(\\frac{8}{3}\\right) \\cdot \\int_{-1}^1 d\\xi \\right] = \\frac{\\mu}{32} \\left[ \\frac{8}{3} \\cdot 2 + \\frac{8}{3} \\cdot 2 \\right] = \\frac{\\mu}{32} \\left(\\frac{32}{3}\\right) = \\frac{\\mu}{3}\n$$\nThe volumetric energy under full integration is:\n$$\nE_{\\text{vol,full}} = \\int_{-1}^{1}\\int_{-1}^{1} I_{\\text{vol}}(\\xi,\\eta) d\\xi d\\eta = \\frac{\\kappa}{32} \\int_{-1}^{1}\\int_{-1}^{1} (1-\\eta)^2 d\\xi d\\eta = \\frac{\\kappa}{32} \\left(\\frac{8}{3}\\right) \\cdot 2 = \\frac{\\kappa}{32} \\left(\\frac{16}{3}\\right) = \\frac{\\kappa}{6}\n$$\nTherefore, the total energy with full integration is:\n$$\nE_{\\text{full}} = E_{\\text{dev}} + E_{\\text{vol,full}} = \\frac{\\mu}{3} + \\frac{\\kappa}{6} = \\frac{2\\mu+\\kappa}{6}\n$$\nNow we compute the energy using selective integration, $E_{\\text{sel}}$. The deviatoric part uses full $2 \\times 2$ quadrature, so $E_{\\text{sel,dev}} = E_{\\text{dev}} = \\frac{\\mu}{3}$. The volumetric part uses reduced $1 \\times 1$ quadrature (point $(\\xi,\\eta)=(0,0)$, weight $w=4$).\n$$\nE_{\\text{sel,vol}} = w \\cdot I_{\\text{vol}}(0,0) = 4 \\cdot \\left[ \\frac{\\kappa}{32}(1-0)^2 \\right] = \\frac{4\\kappa}{32} = \\frac{\\kappa}{8}\n$$\nThe total energy with selective integration is:\n$$\nE_{\\text{sel}} = E_{\\text{sel,dev}} + E_{\\text{sel,vol}} = \\frac{\\mu}{3} + \\frac{\\kappa}{8} = \\frac{8\\mu+3\\kappa}{24}\n$$\nFinally, we compute the ratio $r = E_{\\text{sel}} / E_{\\text{full}}$.\n$$\nr = \\frac{\\frac{8\\mu+3\\kappa}{24}}{\\frac{2\\mu+\\kappa}{6}} = \\frac{8\\mu+3\\kappa}{24} \\cdot \\frac{6}{2\\mu+\\kappa} = \\frac{8\\mu+3\\kappa}{4(2\\mu+\\kappa)}\n$$\nThe problem requires the answer in terms of Lamé parameters $\\lambda$ and $\\mu$. We substitute $\\kappa = \\lambda + \\mu$:\n$$\nr = \\frac{8\\mu+3(\\lambda+\\mu)}{4(2\\mu+(\\lambda+\\mu))} = \\frac{8\\mu+3\\lambda+3\\mu}{4(3\\mu+\\lambda)} = \\frac{11\\mu+3\\lambda}{4(3\\mu+\\lambda)}\n$$", "answer": "$$\n\\boxed{\\frac{3\\lambda + 11\\mu}{4(\\lambda + 3\\mu)}}\n$$", "id": "3439222"}, {"introduction": "If reducing the integration order for the volumetric term is beneficial, a natural question arises: why not use reduced integration for all terms to maximize computational efficiency? This path leads to a new challenge—spurious, non-physical \"hourglass\" modes that can corrupt the solution. This final practice guides you through implementing a classic remedy, the Flanagan-Belytschko hourglass control scheme, to stabilize an under-integrated element, and then verifying its correctness with the patch test to ensure fundamental accuracy is preserved [@problem_id:3439243].", "problem": "You are to implement and verify stabilization by the Flanagan–Belytschko hourglass control for an under-integrated bilinear quadrilateral element in small-strain linear elasticity. The fundamental base is the small-strain equilibrium equations and the standard isoparametric bilinear quadrilateral finite element formulation. The governing equations are the balance of linear momentum with no body forces under quasi-static conditions in a homogeneous, isotropic material with Young’s modulus $E$ and Poisson’s ratio $\\nu$ in plane stress. The small-strain tensor is $\\boldsymbol{\\varepsilon} = \\nabla^{s} \\mathbf{u}$, and the constitutive law is $\\boldsymbol{\\sigma} = \\mathbf{D}\\,\\boldsymbol{\\varepsilon}$, where $\\mathbf{D}$ is the plane stress elasticity tensor. The bilinear quadrilateral ($Q4$) element under one-point (reduced) Gaussian integration has an element stiffness that can exhibit spurious zero-energy modes known as hourglass modes. The Flanagan–Belytschko hourglass control augments the element stiffness to penalize these modes while preserving the exact performance under constant strain fields.\n\nYour program must:\n- Construct the element-level reduced-integration stiffness matrix $K_e^{\\mathrm{RI}}$ for a $Q4$ element using a single Gauss point at the element center. Let the standard bilinear shape functions be $N_i(\\xi,\\eta)$, and compute the strain-displacement matrix $\\mathbf{B}$ at $(\\xi,\\eta)=(0,0)$ using the isoparametric mapping with Jacobian $\\mathbf{J}$ at the center. Take the integration weight $w=4$ (the area of the square in natural coordinates) and thickness $t$. The plane stress elasticity matrix is\n$$\n\\mathbf{D} = \\frac{E}{1-\\nu^2}\n\\begin{bmatrix}\n1 & \\nu & 0\\\\\n\\nu & 1 & 0\\\\\n0 & 0 & \\frac{1-\\nu}{2}\n\\end{bmatrix}.\n$$\nThen\n$$\nK_e^{\\mathrm{RI}} = t\\,w\\,\\det(\\mathbf{J}) \\,\\mathbf{B}^\\top \\mathbf{D}\\,\\mathbf{B}.\n$$\n- Implement a Flanagan–Belytschko hourglass control term $K_e^{\\mathrm{HG}}$ that annihilates linear displacement fields. Let the nodal displacement vector be $d_e \\in \\mathbb{R}^{8}$ ordered as $(u_1,v_1,u_2,v_2,u_3,v_3,u_4,v_4)^\\top$, where $(u_i,v_i)$ are the displacements of node $i$. Define the linear field subspace spanned by the six basis vectors corresponding to the displacement fields $u=a+b\\,x+c\\,y$ and $v=d+e\\,x+f\\,y$ (with $a,b,c,d,e,f$ as scalar coefficients), namely $u$-translation, $v$-translation, $u=x$, $u=y$, $v=x$, $v=y$. Form the orthonormal basis matrix $\\mathbf{Q}_\\ell \\in \\mathbb{R}^{8\\times 6}$ of this subspace, and define the hourglass projector\n$$\n\\mathbf{P}_{\\mathrm{hg}} = \\mathbf{I}_{8} - \\mathbf{Q}_\\ell \\mathbf{Q}_\\ell^\\top.\n$$\nSet the hourglass stiffness as\n$$\nK_e^{\\mathrm{HG}} = \\alpha\\,\\mathbf{P}_{\\mathrm{hg}},\n$$\nwith the stabilization scale\n$$\n\\alpha = c_{\\mathrm{hg}}\\,\\mu\\,t\\,\\frac{A}{L_c},\n$$\nwhere $c_{\\mathrm{hg}}$ is a dimensionless control coefficient, $\\mu = \\frac{E}{2(1+\\nu)}$ is the shear modulus, $A = w\\,\\det(\\mathbf{J})$ is the element area, and $L_c$ is a characteristic length taken as the average edge length of the physical quadrilateral. The stabilized element stiffness is\n$$\nK_e = K_e^{\\mathrm{RI}} + K_e^{\\mathrm{HG}}.\n$$\n- Prove numerically that the stabilized element passes the patch test under reduced integration: for any linear displacement field parameters $(a,b,c,d,e,f)$, the added hourglass control does not contribute to the internal force and the computed strain at the Gauss point equals the exact constant strain. Specifically, for each test case, construct $d_e$ from the prescribed linear field using the element node coordinates $(x_i,y_i)$:\n$$\nu_i = a + b\\,x_i + c\\,y_i,\\quad v_i = d + e\\,x_i + f\\,y_i,\n$$\nand verify the two conditions\n$$\n\\text{(i)}\\quad d_e^\\top K_e^{\\mathrm{HG}}\\,d_e = 0 \\quad\\text{(within a numerical tolerance)},\\qquad\n\\text{(ii)}\\quad \\mathbf{B}\\,d_e = \\begin{bmatrix} b \\\\ f \\\\ c+e \\end{bmatrix} \\quad\\text{(within a numerical tolerance)}.\n$$\nBoth conditions must hold for the stabilized element to pass the patch test.\n\nPhysical units: Use meters (m) for geometry and thickness, and Pascals (Pa) for material stiffness. The strain is dimensionless. Report numerical tolerances and errors as floats with no unit.\n\nAngle unit: Not applicable.\n\nTest Suite:\nProvide three test cases, each specifying the element node coordinates in meters, material parameters in Pascals, thickness in meters, hourglass coefficient $c_{\\mathrm{hg}}$, and linear displacement parameters $(a,b,c,d,e,f)$:\n\n- Case 1 (happy path, regular element): Nodes $(0,0)$, $(1,0)$, $(1,1)$, $(0,1)$; $E=1000$, $\\nu=0.3$, $t=1$, $c_{\\mathrm{hg}}=0.1$; Linear field $(a,b,c,d,e,f)=(0,0.01,0,0,0,0)$, expecting $\\boldsymbol{\\varepsilon}=[0.01,0,0]^\\top$.\n\n- Case 2 (distorted element, skewed geometry): Nodes $(0,0)$, $(1.2,-0.1)$, $(1.1,1.05)$, $(-0.05,1.1)$; $E=1000$, $\\nu=0.3$, $t=1$, $c_{\\mathrm{hg}}=0.1$; Linear field $(a,b,c,d,e,f)=(0,0.01,0,0,0,0)$, expecting $\\boldsymbol{\\varepsilon}=[0.01,0,0]^\\top$.\n\n- Case 3 (edge case, high aspect ratio and pure shear): Nodes $(0,0)$, $(2,0)$, $(2,0.5)$, $(0,0.5)$; $E=1000$, $\\nu=0.3$, $t=1$, $c_{\\mathrm{hg}}=0.1$; Linear field $(a,b,c,d,e,f)=(0,0,0.01,0,0.01,0)$, expecting $\\boldsymbol{\\varepsilon}=[0,0,0.02]^\\top$.\n\nTolerance specification:\n- Let the energy tolerance be $\\tau_E = 10^{-12}\\,\\alpha$ so that condition (i) holds if $|d_e^\\top K_e^{\\mathrm{HG}}\\,d_e| \\le \\tau_E$.\n- Let the strain tolerance be $\\tau_\\varepsilon = 10^{-12}$ so that condition (ii) holds if the Euclidean norm of the strain difference is $\\le \\tau_\\varepsilon$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each entry a boolean indicating whether both conditions (i) and (ii) are satisfied for the corresponding test case (e.g., \"[True,False,True]\").", "solution": "The user requests the implementation and numerical verification of the Flanagan–Belytschko hourglass control scheme for a bilinear quadrilateral element ($Q4$) under reduced one-point integration. The verification is to be performed via the patch test, a fundamental criterion in finite element analysis that ensures an element can exactly reproduce a constant strain state. A linear displacement field, which results in a constant strain field, must be represented exactly.\n\nThe core of the problem lies in demonstrating two properties for any applied linear displacement field:\n1.  The hourglass stabilization term must not generate any spurious forces. This means the hourglass contribution to the internal force vector, and by extension the virtual work, must be zero.\n2.  The strain computed at the element's single integration point (the center) must exactly match the constant strain corresponding to the applied linear displacement field.\n\nWe will systematically construct the necessary matrices and vectors and then perform the verification for the specified test cases. All mathematical entities are rendered in LaTeX as required.\n\n**1. Element Formulation for a Bilinear Quadrilateral ($Q4$)**\n\nThe geometry of a $Q4$ element is mapped from a square parent element in natural coordinates $(\\xi, \\eta) \\in [-1, 1] \\times [-1, 1]$ to the physical coordinates $(x, y)$ using isoparametric mapping:\n$$\nx(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) x_i \\quad , \\quad y(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) y_i\n$$\nwhere $(x_i, y_i)$ are the coordinates of the $i$-th node, and $N_i$ are the bilinear shape functions:\n$$\n\\begin{aligned}\nN_1(\\xi, \\eta) &= \\frac{1}{4}(1-\\xi)(1-\\eta) \\\\\nN_2(\\xi, \\eta) &= \\frac{1}{4}(1+\\xi)(1-\\eta) \\\\\nN_3(\\xi, \\eta) &= \\frac{1}{4}(1+\\xi)(1+\\eta) \\\\\nN_4(\\xi, \\eta) &= \\frac{1}{4}(1-\\xi)(1+\\eta)\n\\end{aligned}\n$$\nThe same shape functions interpolate the displacement field $(\\_u, v)$ from nodal displacements $(u_i, v_i)$.\n\nThe relationship between derivatives in physical and natural coordinates is given by the Jacobian matrix $\\mathbf{J}$:\n$$\n\\begin{Bmatrix} \\frac{\\partial}{\\partial \\xi} \\\\ \\frac{\\partial}{\\partial \\eta} \\end{Bmatrix} = \\mathbf{J} \\begin{Bmatrix} \\frac{\\partial}{\\partial x} \\\\ \\frac{\\partial}{\\partial y} \\end{Bmatrix} \\quad \\text{where} \\quad \\mathbf{J} = \\begin{bmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\xi} \\\\ \\frac{\\partial x}{\\partial \\eta} & \\frac{\\partial y}{\\partial \\eta} \\end{bmatrix}\n$$\nFor a single-point quadrature scheme, all element-level quantities are evaluated at the center $(\\xi, \\eta) = (0, 0)$. At this point, the Jacobian is:\n$$\n\\mathbf{J}|_{(0,0)} = \\sum_{i=1}^{4} \\begin{bmatrix} \\frac{\\partial N_i}{\\partial \\xi} \\\\ \\frac{\\partial N_i}{\\partial \\eta} \\end{bmatrix} [x_i, y_i] \\Bigg|_{(\\xi, \\eta)=(0,0)} = \\frac{1}{4} \\begin{bmatrix} -x_1+x_2+x_3-x_4 & -y_1+y_2+y_3-y_4 \\\\ -x_1-x_2+x_3+x_4 & -y_1-y_2+y_3+y_4 \\end{bmatrix}\n$$\n\nThe strain-displacement matrix, $\\mathbf{B}$, relates the strain vector $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^\\top$ to the element nodal displacement vector $d_e = [u_1, v_1, \\dots, u_4, v_4]^\\top$ as $\\boldsymbol{\\varepsilon} = \\mathbf{B} d_e$. The matrix $\\mathbf{B}$ is constructed from the physical derivatives of the shape functions:\n$$\n\\mathbf{B} = [\\mathbf{B}_1, \\mathbf{B}_2, \\mathbf{B}_3, \\mathbf{B}_4] \\quad \\text{with} \\quad \\mathbf{B}_i = \\begin{bmatrix} \\frac{\\partial N_i}{\\partial x} & 0 \\\\ 0 & \\frac{\\partial N_i}{\\partial y} \\\\ \\frac{\\partial N_i}{\\partial y} & \\frac{\\partial N_i}{\\partial x} \\end{bmatrix}\n$$\nThe physical derivatives are obtained via the inverse Jacobian: $\\begin{Bmatrix} \\partial N_i/\\partial x \\\\ \\partial N_i/\\partial y \\end{Bmatrix} = \\mathbf{J}^{-1} \\begin{Bmatrix} \\partial N_i/\\partial \\xi \\\\ \\partial N_i/\\partial \\eta \\end{Bmatrix}$.\n\n**2. Flanagan–Belytschko Hourglass Control**\n\nThe one-point integrated stiffness matrix, $K_e^{\\mathrm{RI}} = t\\,w\\,\\det(\\mathbf{J}) \\,\\mathbf{B}^\\top \\mathbf{D}\\,\\mathbf{B}$ (with $w=4$), is rank-deficient and admits non-physical zero-energy modes, known as hourglass modes. The Flanagan–Belytschko method adds a stabilization stiffness $K_e^{\\mathrm{HG}}$ to penalize these modes.\n\nThe key idea is to project any displacement field onto the \"hourglass subspace,\" which is the orthogonal complement of the subspace of linear displacement fields. Any physically meaningful constant-strain deformation should not be penalized. A linear displacement field of the form $u=a+b\\,x+c\\,y$ and $v=d+e\\,x+f\\,y$ must produce zero hourglass resisting force.\n\nThe subspace of linear displacement fields is spanned by six basis vectors defined at the nodes:\n1.  $u=1, v=0$ (rigid body translation in $x$)\n2.  $u=0, v=1$ (rigid body translation in $y$)\n3.  $u=x, v=0$ (constant strain $\\varepsilon_{xx}$)\n4.  $u=y, v=0$ (constant strain $\\gamma_{xy}$, and rigid body rotation)\n5.  $u=0, v=x$ (constant strain $\\gamma_{xy}$, and rigid body rotation)\n6.  $u=0, v=y$ (constant strain $\\varepsilon_{yy}$)\n\nThese six nodal displacement vectors, formed from the element node coordinates $(x_i, y_i)$, constitute the columns of a matrix $\\mathbf{L} \\in \\mathbb{R}^{8 \\times 6}$. An orthonormal basis $\\mathbf{Q}_\\ell \\in \\mathbb{R}^{8 \\times 6}$ for the column space of $\\mathbf{L}$ is obtained, for instance, via QR decomposition.\n\nThe hourglass projector $\\mathbf{P}_{\\mathrm{hg}}$ maps a displacement vector onto the hourglass subspace, which is orthogonal to the linear field subspace:\n$$\n\\mathbf{P}_{\\mathrm{hg}} = \\mathbf{I}_{8} - \\mathbf{Q}_\\ell \\mathbf{Q}_\\ell^\\top\n$$\nwhere $\\mathbf{I}_{8}$ is the $8 \\times 8$ identity matrix. By construction, if $d_e$ represents a linear displacement field, it lies in the column space of $\\mathbf{Q}_\\ell$, and thus $\\mathbf{P}_{\\mathrm{hg}} d_e = \\mathbf{0}$.\n\nThe hourglass stiffness matrix is then defined as:\n$$\nK_e^{\\mathrm{HG}} = \\alpha\\,\\mathbf{P}_{\\mathrm{hg}}\n$$\nwhere $\\alpha$ is a stabilization parameter that scales the penalty. The problem specifies the scale as:\n$$\n\\alpha = c_{\\mathrm{hg}}\\,\\mu\\,t\\,\\frac{A}{L_c}\n$$\nHere, $c_{\\mathrm{hg}}$ is a user-defined coefficient, $\\mu = \\frac{E}{2(1+\\nu)}$ is the shear modulus, $t$ is the element thickness, $A = w\\,\\det(\\mathbf{J}) = 4\\,\\det(\\mathbf{J})$ is the element area from one-point quadrature, and $L_c$ is a characteristic length, taken as the average of the four edge lengths.\n\n**3. Patch Test Verification**\n\nThe patch test verifies that the stabilization scheme is consistent. For a nodal displacement vector $d_e$ derived from any linear field, two conditions must be met.\n\n**Condition (i): Zero Hourglass Energy**\nA linear displacement vector $d_e$ must produce zero hourglass force. This is equivalent to showing the associated energy is zero. Since $K_e^{\\mathrm{HG}}$ is positive semi-definite, we verify:\n$$\nd_e^\\top K_e^{\\mathrm{HG}}\\,d_e = \\alpha \\, d_e^\\top \\mathbf{P}_{\\mathrm{hg}} d_e = 0\n$$\nAs argued above, this must be true up to numerical precision because $d_e$ lies in the null space of $\\mathbf{P}_{\\mathrm{hg}}$. We check if $|d_e^\\top K_e^{\\mathrm{HG}}\\,d_e| \\le \\tau_E$, where $\\tau_E = 10^{-12}\\,\\alpha$.\n\n**Condition (ii): Exact Strain Representation**\nFor a linear displacement field $u(\\text{x,y}) = a+bx+cy$ and $v(\\text{x,y}) = d+ex+fy$, the resulting strain field is constant:\n$$\n\\varepsilon_{xx} = \\frac{\\partial u}{\\partial x} = b, \\quad \\varepsilon_{yy} = \\frac{\\partial v}{\\partial y} = f, \\quad \\gamma_{xy} = \\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x} = c+e\n$$\nThe second condition of the patch test verifies that the strain computed at the special integration point $(\\xi, \\eta)=(0,0)$ using the B-matrix exactly matches this theoretical constant strain:\n$$\n\\mathbf{B}\\,d_e = \\begin{bmatrix} b \\\\ f \\\\ c+e \\end{bmatrix}\n$$\nThis is a well-known property of the central Gauss point in a bilinear element. We check if the Euclidean norm of the difference between the computed and exact strain vectors is below a tolerance $\\tau_\\varepsilon = 10^{-12}$.\n\n**Implementation Strategy**\nThe program will loop through each test case. For each case, it will:\n1.  Define the element geometry and material/control parameters.\n2.  Compute the Jacobian $\\mathbf{J}$ at $(\\xi,\\eta)=(0,0)$ and the strain-displacement matrix $\\mathbf{B}$.\n3.  Construct the matrix $\\mathbf{L}$ of linear displacement modes and find its orthonormal basis $\\mathbf{Q}_\\ell$.\n4.  Calculate the stabilization parameter $\\alpha$ and the hourglass stiffness $K_e^{\\mathrm{HG}} = \\alpha(\\mathbf{I}_{8} - \\mathbf{Q}_\\ell \\mathbf{Q}_\\ell^\\top)$.\n5.  Generate the nodal displacement vector $d_e$ corresponding to the prescribed linear field.\n6.  Numerically verify conditions (i) and (ii) against their respective tolerances.\n7.  Return a boolean value indicating if both conditions are satisfied.\nThe results for all test cases will be collected and formatted into the required output string.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import orth\n\ndef verify_patch_test(nodes, E, nu, t, chg, field_params):\n    \"\"\"\n    Performs the patch test for a single Q4 element with hourglass control.\n\n    Args:\n        nodes (np.ndarray): 4x2 array of nodal coordinates (x, y).\n        E (float): Young's modulus.\n        nu (float): Poisson's ratio.\n        t (float): Element thickness.\n        chg (float): Hourglass control coefficient.\n        field_params (tuple): Parameters (a,b,c,d,e,f) for the linear displacement field.\n\n    Returns:\n        bool: True if both patch test conditions are met, False otherwise.\n    \"\"\"\n    # 1. Element Formulation (at center xi=0, eta=0)\n    # Derivatives of shape functions w.r.t. natural coordinates\n    GN_nat = 0.25 * np.array([[-1., -1.], [1., -1.], [1., 1.], [-1., 1.]])\n    \n    # Jacobian matrix\n    J = GN_nat.T @ nodes\n    det_J = np.linalg.det(J)\n    \n    # Check for degenerate element\n    if np.abs(det_J) < 1e-15:\n        return False\n        \n    J_inv = np.linalg.inv(J)\n    \n    # Derivatives of shape functions w.r.t. physical coordinates\n    GN_phys = GN_nat @ J_inv\n    \n    # Strain-displacement matrix (B-matrix)\n    B = np.zeros((3, 8))\n    for i in range(4):\n        # GN_phys[i, 0] is dN_i/dx, GN_phys[i, 1] is dN_i/dy\n        B[0, 2 * i] = GN_phys[i, 0]\n        B[1, 2 * i + 1] = GN_phys[i, 1]\n        B[2, 2 * i] = GN_phys[i, 1]\n        B[2, 2 * i + 1] = GN_phys[i, 0]\n\n    # 2. Flanagan-Belytschko Hourglass Control\n    # 2.1. Basis for the linear displacement subspace (L)\n    L = np.zeros((8, 6))\n    x_coords = nodes[:, 0]\n    y_coords = nodes[:, 1]\n    \n    L[:, 0] = np.tile([1, 0], 4)      # u=1, v=0 (u-translation)\n    L[:, 1] = np.tile([0, 1], 4)      # u=0, v=1 (v-translation)\n    L[0::2, 2] = x_coords             # u=x, v=0\n    L[0::2, 3] = y_coords             # u=y, v=0\n    L[1::2, 4] = x_coords             # u=0, v=x\n    L[1::2, 5] = y_coords             # u=0, v=y\n    \n    # 2.2. Orthonormal basis Ql\n    Ql = orth(L)\n    \n    # 2.3. Hourglass projector Phg\n    Phg = np.eye(8) - Ql @ Ql.T\n    \n    # 2.4. Stabilization scale alpha\n    mu = E / (2. * (1. + nu))\n    A = 4. * det_J # Area from 1-point quadrature\n    \n    # Characteristic length Lc (average edge length)\n    p1, p2, p3, p4 = nodes\n    l1 = np.linalg.norm(p2 - p1)\n    l2 = np.linalg.norm(p3 - p2)\n    l3 = np.linalg.norm(p4 - p3)\n    l4 = np.linalg.norm(p1 - p4)\n    Lc = (l1 + l2 + l3 + l4) / 4.\n    \n    if Lc < 1e-15: # Degenerate geometry (e.g., all nodes at same point)\n        return False\n        \n    alpha = chg * mu * t * A / Lc\n    \n    # 2.5. Hourglass stiffness matrix\n    Ke_HG = alpha * Phg\n    \n    # 3. Nodal displacements from linear field\n    a, b, c, d, e, f = field_params\n    u = a + b * x_coords + c * y_coords\n    v = d + e * x_coords + f * y_coords\n    d_e = np.empty(8)\n    d_e[0::2] = u\n    d_e[1::2] = v\n    \n    # 4. Patch Test Verification\n    # 4.1. Condition (i): Zero hourglass energy\n    E_hg = d_e.T @ Ke_HG @ d_e\n    \n    # alpha can't be zero for valid inputs, so tau_E will be a small positive number\n    tau_E = 1.0e-12 * alpha \n    cond1 = np.abs(E_hg) <= tau_E\n\n    # 4.2. Condition (ii): Exact strain at center\n    eps_computed = B @ d_e\n    eps_exact = np.array([b, f, c + e])\n    \n    strain_error = np.linalg.norm(eps_computed - eps_exact)\n    tau_eps = 1.0e-12\n    cond2 = strain_error <= tau_eps\n\n    return cond1 and cond2\n\ndef solve():\n    \"\"\"\n    Main function to run the patch test verification for all specified test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1: Happy path, regular square element\n        {\n            \"nodes\": np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]]),\n            \"E\": 1000.0, \"nu\": 0.3, \"t\": 1.0, \"chg\": 0.1,\n            \"field_params\": (0, 0.01, 0, 0, 0, 0)\n        },\n        # Case 2: Distorted element, skewed geometry\n        {\n            \"nodes\": np.array([[0.0, 0.0], [1.2, -0.1], [1.1, 1.05], [-0.05, 1.1]]),\n            \"E\": 1000.0, \"nu\": 0.3, \"t\": 1.0, \"chg\": 0.1,\n            \"field_params\": (0, 0.01, 0, 0, 0, 0)\n        },\n        # Case 3: Edge case, high aspect ratio and pure shear\n        {\n            \"nodes\": np.array([[0.0, 0.0], [2.0, 0.0], [2.0, 0.5], [0.0, 0.5]]),\n            \"E\": 1000.0, \"nu\": 0.3, \"t\": 1.0, \"chg\": 0.1,\n            \"field_params\": (0, 0, 0.01, 0, 0.01, 0)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = verify_patch_test(\n            case[\"nodes\"],\n            case[\"E\"],\n            case[\"nu\"],\n            case[\"t\"],\n            case[\"chg\"],\n            case[\"field_params\"]\n        )\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3439243"}]}