{"hands_on_practices": [{"introduction": "This first practice serves as our starting point for understanding why stabilized methods are essential. You will begin by implementing the standard Galerkin finite element method for a simple 1D advection-diffusion problem and observe its failure to produce a physically realistic solution when advection dominates. This exercise will then guide you through deriving and implementing the Streamline-Upwind/Petrov-Galerkin (SUPG) method, allowing you to directly contrast the unstable and stable results [@problem_id:3447423].", "problem": "Consider the steady one-dimensional advection-diffusion Partial Differential Equation (PDE) on the unit interval with homogeneous and inhomogeneous Dirichlet boundary conditions: find $u(x)$ such that\n$$\n- \\epsilon \\, u''(x) + \\beta \\, u'(x) = f(x), \\quad x \\in (0,1),\n$$\nwith boundary conditions $u(0)=0$ and $u(1)=1$. Assume constant parameters $\\epsilon > 0$, $\\beta \\in \\mathbb{R}$, and $f(x)=0$. Starting from the strong form, derive the weak form using the standard procedure of multiplying by a test function $v(x)$, integrating over the domain, and applying integration by parts where appropriate. Use the Finite Element Method (FEM) with continuous, piecewise linear basis functions on a uniform mesh to obtain a discrete Galerkin system. Discuss why the resulting Galerkin discretization becomes numerically unstable for advection-dominated regimes, and define the element Péclet number in terms of mesh size $h$, advection speed $\\beta$, and diffusivity $\\epsilon$. The Péclet number should be defined as a dimensionless ratio that quantifies the relative strength of advection to diffusion at the element level.\n\nTo address instability, construct a stabilized formulation using the Streamline Upwind/Petrov-Galerkin (SUPG) method. Starting from the residual-based idea, enrich the test space in the streamline direction and show how this leads to an additional consistent stabilization term. Derive an expression for the stabilization parameter in terms of the local Péclet number that is asymptotically correct in both diffusion-dominated and advection-dominated limits. Your derivation must proceed from first principles of the weak formulation and the residual-based enrichment mechanism, without quoting or assuming any ready-made formulas.\n\nImplement two solvers on a uniform mesh with $N$ elements:\n- The standard Galerkin FEM solver.\n- The SUPG-stabilized FEM solver using your derived stabilization parameter and consistent addition along streamlines.\n\nFor each solver, assemble the global linear system, impose the Dirichlet boundary conditions strongly, and solve for the nodal values $u_i$.\n\nDefine a monotonicity check for the discrete solution as follows: the solution is monotone non-decreasing if $u_{i+1}-u_i \\ge 0$ for all interior node indices $i$. Use a numerical tolerance of $10^{-12}$ to account for floating-point effects, i.e., treat $u_{i+1}-u_i \\ge -10^{-12}$ as non-decreasing. For each test case, compute:\n- The maximum element Péclet number $Pe_{\\max}$ over the mesh, expressed as a floating-point number.\n- A boolean indicating whether the Galerkin solution is monotone.\n- A boolean indicating whether the SUPG solution is monotone.\n\nUse the following test suite of parameter values $(N,\\beta,\\epsilon)$, which covers a range of regimes:\n1. $(100, 1.0, 10^{-2})$ representing moderately diffusion-dominated behavior.\n2. $(40, 1.0, 5 \\times 10^{-3})$ representing a regime where advection begins to dominate.\n3. $(50, 1.0, 10^{-4})$ representing strongly advection-dominated behavior.\n4. $(50, 0.0, 10^{-2})$ representing pure diffusion (no advection).\n\nAll quantities here are dimensionless. Your program should produce a single line of output containing the results as a comma-separated list of four inner lists, one per test case, where each inner list is of the form $[Pe_{\\max}, M_G, M_S]$ with $Pe_{\\max}$ as a float, and $M_G$, $M_S$ as booleans for the monotonicity of the Galerkin and SUPG solutions, respectively. For example, the final output format must be\n$$\n\\texttt{[[Pe1,MG1,MS1],[Pe2,MG2,MS2],[Pe3,MG3,MS3],[Pe4,MG4,MS4]]}.\n$$", "solution": "The repository of this solution is structured into four main parts: a critical validation of the problem statement, a detailed theoretical derivation of the required numerical methods, the implementation architecture of the final Python code, and the final program itself.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n- **Governing Equation:** The steady one-dimensional advection-diffusion PDE is given by $- \\epsilon \\, u''(x) + \\beta \\, u'(x) = f(x)$ for $x \\in (0,1)$.\n- **Parameters:** The diffusivity $\\epsilon$ is positive ($\\epsilon > 0$), the advection speed $\\beta$ is a real number ($\\beta \\in \\mathbb{R}$), and the source term $f(x)$ is zero ($f(x)=0$).\n- **Boundary Conditions:** Inhomogeneous Dirichlet conditions are prescribed: $u(0)=0$ and $u(1)=1$.\n- **Numerical Method:** The Finite Element Method (FEM) is to be used with continuous, piecewise linear basis functions on a uniform mesh with $N$ elements.\n- **Tasks:**\n    1.  Derive the weak form of the PDE.\n    2.  Formulate the standard Galerkin discrete system.\n    3.  Analyze the numerical instability of the Galerkin method in advection-dominated regimes and define the element Péclet number.\n    4.  Derive the Streamline Upwind/Petrov-Galerkin (SUPG) stabilized formulation, including the expression for the stabilization parameter $\\tau$.\n    5.  Implement both the Galerkin and SUPG solvers.\n    6.  For a given set of test cases, compute the maximum element Péclet number ($Pe_{\\max}$), and check the monotonicity of the Galerkin solution ($M_G$) and the SUPG solution ($M_S$).\n- **Monotonicity Criterion:** A discrete solution $\\{u_i\\}$ is considered monotone non-decreasing if $u_{i+1} - u_i \\ge -10^{-12}$ for all adjacent node pairs.\n- **Test Cases:** The analysis is to be performed for four parameter sets $(N, \\beta, \\epsilon)$:\n    1. $(100, 1.0, 10^{-2})$\n    2. $(40, 1.0, 5 \\times 10^{-3})$\n    3. $(50, 1.0, 10^{-4})$\n    4. $(50, 0.0, 10^{-2})$\n\n**Step 2: Validate Using Extracted Givens**\n\n- **Scientific Grounding:** The problem is fundamentally sound. The advection-diffusion equation is a canonical model in transport phenomena. The Galerkin FEM and SUPG stabilization are cornerstone techniques in the field of numerical methods for PDEs. All concepts are well-established within the scientific literature.\n- **Well-Posedness and Completeness:** The problem is well-posed. The PDE combined with the Dirichlet boundary conditions forms a valid boundary value problem with a unique solution. The tasks are specific, and all necessary information (equations, parameters, boundary conditions, numerical methods) is provided.\n- **Objectivity and Feasibility:** The problem is stated in objective, mathematical terms. The required derivations and implementations are standard exercises in computational science and engineering, and the provided test cases are computationally feasible.\n\n**Step 3: Verdict and Action**\n\nThe problem is deemed **valid**. It is a well-defined and standard problem in numerical analysis that requires the derivation and implementation of fundamental FEM techniques. The solution process will now proceed.\n\n### Theoretical Derivation and Formulation\n\n#### 1. Weak Formulation\nWe begin with the strong form of the PDE on the domain $\\Omega = (0,1)$:\n$$\n- \\epsilon u''(x) + \\beta u'(x) = 0, \\quad x \\in (0,1)\n$$\nwith boundary conditions $u(0)=0$ and $u(1)=1$.\n\nTo derive the weak form, we multiply the equation by a test function $v(x)$ from a suitable function space and integrate over the domain $\\Omega$. The test functions are chosen from the space $H^1_0(\\Omega)$, which consists of functions that are square-integrable, have square-integrable first derivatives, and vanish at the boundaries where Dirichlet conditions are specified. In this case, $H^1_0(\\Omega) = \\{v \\in H^1(\\Omega) \\mid v(0)=0, v(1)=0\\}$.\n\n$$\n\\int_0^1 \\left( - \\epsilon u''(x) + \\beta u'(x) \\right) v(x) \\, dx = 0\n$$\n\nThe term with the second derivative is handled using integration by parts:\n$$\n\\int_0^1 - \\epsilon u''(x) v(x) \\, dx = - \\epsilon \\left[ u'(x) v(x) \\right]_0^1 + \\int_0^1 \\epsilon u'(x) v'(x) \\, dx\n$$\nSince $v \\in H^1_0(\\Omega)$, we have $v(0)=0$ and $v(1)=0$. Therefore, the boundary term $- \\epsilon [u'(x)v(x)]_0^1$ vanishes.\n\nSubstituting this back into the integrated equation gives the weak form: Find a function $u \\in H^1(\\Omega)$ satisfying the Dirichlet boundary conditions $u(0)=0$ and $u(1)=1$ such that for all test functions $v \\in H^1_0(\\Omega)$, the following holds:\n$$\n\\int_0^1 \\left( \\epsilon u'(x) v'(x) + \\beta u'(x) v(x) \\right) \\, dx = 0\n$$\nThis can be written compactly as $B(u, v) = 0$, where $B(u, v)$ is the bilinear form associated with the operator.\n\n#### 2. Galerkin Finite Element Discretization\nWe discretize the domain $\\Omega=[0,1]$ with a uniform mesh of $N$ elements, resulting in $N+1$ nodes $x_i = i h$ for $i \\in \\{0, 1, \\dots, N\\}$, where the mesh size is $h = 1/N$.\n\nWe approximate the solution $u(x)$ using continuous, piecewise linear basis functions $\\phi_i(x)$ (hat functions):\n$$\nu_h(x) = \\sum_{j=0}^{N} U_j \\phi_j(x)\n$$\nwhere $U_j$ is the unknown nodal value of the solution at node $x_j$, i.e., $U_j \\approx u(x_j)$. The basis function $\\phi_j(x)$ has the property that $\\phi_j(x_i) = \\delta_{ij}$ (the Kronecker delta).\n\nThe discrete Galerkin formulation requires the weak form to hold for all test functions in a finite-dimensional subspace $V_h \\subset H^1_0(\\Omega)$. This subspace is spanned by the basis functions corresponding to the interior nodes: $V_h = \\text{span}\\{\\phi_1, \\phi_2, \\dots, \\phi_{N-1}\\}$.\n\nThe Galerkin problem is: Find $u_h(x)$ with nodal values $U_0=0$ and $U_N=1$ such that\n$$\n\\int_0^1 \\left( \\epsilon u_h'(x) v_h'(x) + \\beta u_h'(x) v_h(x) \\right) \\, dx = 0 \\quad \\forall v_h \\in V_h\n$$\nBy linearity, this must hold for each basis function $v_h = \\phi_i(x)$ for $i \\in \\{1, \\dots, N-1\\}$. Substituting the expansion for $u_h(x)$ yields a system of linear equations:\n$$\n\\sum_{j=0}^{N} U_j \\left( \\int_0^1 \\left( \\epsilon \\phi_j'(x) \\phi_i'(x) + \\beta \\phi_j'(x) \\phi_i(x) \\right) \\, dx \\right) = 0 \\quad \\text{for } i=1, \\dots, N-1\n$$\nThis defines a linear system $A \\mathbf{U} = \\mathbf{F}$, where $\\mathbf{U} = [U_1, \\dots, U_{N-1}]^T$ is the vector of unknown interior nodal values. The entries of the system matrix and right-hand side are constructed by assembling contributions from each element $K_e = [x_{e-1}, x_e]$. On a generic element $K_e$, the solution is interpolated by the two local basis functions, $N_1(\\xi) = 1 - \\xi/h$ and $N_2(\\xi) = \\xi/h$, where $\\xi = x-x_{e-1}$. The element matrix $A^e$ has entries $A^e_{ij} = B(\\phi_j, \\phi_i)|_{K_e}$. The local derivatives are $N_1' = -1/h$ and $N_2' = 1/h$.\n\nThe element diffusion (stiffness) matrix is:\n$$\nK^e = \\int_{K_e} \\epsilon N_i' N_j' \\, dx = \\frac{\\epsilon}{h} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}\n$$\nThe element advection matrix is:\n$$\nC^e = \\int_{K_e} \\beta N_j' N_i \\, dx = \\frac{\\beta}{2} \\begin{pmatrix} -1 & 1 \\\\ -1 & 1 \\end{pmatrix}\n$$\nThe Galerkin element matrix is $A^e_{Gal} = K^e + C^e$:\n$$\nA^e_{Gal} = \\begin{pmatrix} \\frac{\\epsilon}{h} - \\frac{\\beta}{2} & -\\frac{\\epsilon}{h} + \\frac{\\beta}{2} \\\\ -\\frac{\\epsilon}{h} - \\frac{\\beta}{2} & \\frac{\\epsilon}{h} + \\frac{\\beta}{2} \\end{pmatrix}\n$$\n\n#### 3. Numerical Instability and the Péclet Number\nThe Galerkin method, being equivalent to a central difference scheme in this 1D case, is prone to producing non-physical, spurious oscillations when advection dominates diffusion. This occurs because the centered stencil is not consistent with the directional nature of advective transport.\n\nThe relative strength of advection to diffusion at the element level is quantified by the dimensionless **element Péclet number**, defined as:\n$$\nPe_h = \\frac{|\\beta| h}{2 \\epsilon}\n$$\nThis number compares the cell advection \"time\" ($h/|\\beta|$) to the cell diffusion \"time\" ($h^2/(2\\epsilon)$). When $Pe_h \\gg 1$, advection dominates, and the Galerkin solution becomes unstable, exhibiting oscillations that violate the physical principle of monotonicity. Stability is typically guaranteed only for $Pe_h \\le 1$.\n\n#### 4. Streamline Upwind/Petrov-Galerkin (SUPG) Formulation\nTo counteract these oscillations, a stabilization term is added to the Galerkin formulation. The SUPG method achieves this by enriching the test space. Specifically, each test function $v_h$ is perturbed by a term proportional to its derivative in the streamline (advection) direction. The modified test function is $\\tilde{v}_h = v_h + \\tau_e \\beta v_h'$, where $\\tau_e$ is a stabilization parameter defined on each element $K_e$.\n\nThe motivation for this form comes from a residual-based argument. The exact solution $u$ satisfies the PDE, so its residual $R(u) = -\\epsilon u'' + \\beta u' = 0$. The discrete solution $u_h$ does not, so its element-wise residual is non-zero. For piecewise linear elements, $u_h''=0$ within each element, so the residual simplifies to $R(u_h)|_{K_e} = \\beta u_h'$. The SUPG method adds a term to the weak form that is the integral of this residual against the test function perturbation:\n$$\nB_{SUPG}(u_h, v_h) = B_{Gal}(u_h, v_h) + \\sum_{e=1}^N \\int_{K_e} (\\beta u_h')(\\tau_e \\beta v_h') \\, dx = 0\n$$\nThe full stabilized weak formulation is:\n$$\n\\int_0^1 \\left( \\epsilon u_h' v_h' + \\beta u_h' v_h \\right) \\, dx + \\sum_{e=1}^N \\int_{K_e} \\tau_e \\beta^2 u_h' v_h' \\, dx = 0\n$$\nThe stabilization term introduces an artificial diffusion $\\tau_e \\beta^2$ that acts only along the streamline direction, thus it is often called streamline diffusion. The method is consistent because the added term depends on the residual, which vanishes for the exact solution.\n\nThe element stabilization matrix is:\n$$\nS^e = \\int_{K_e} \\tau_e \\beta^2 N_i' N_j' \\, dx = \\frac{\\tau_e \\beta^2}{h} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}\n$$\nThe SUPG element matrix is $A^e_{SUPG} = A^e_{Gal} + S^e$.\n\nThe stabilization parameter $\\tau_e$ must be chosen carefully. An optimal choice in 1D, which yields nodally exact solutions, is derived to be a function of the element Péclet number:\n$$\n\\tau_e = \\frac{h}{2|\\beta|} \\xi(Pe_h) \\quad \\text{where} \\quad \\xi(Pe_h) = \\coth(Pe_h) - \\frac{1}{Pe_h}\n$$\nThis form has the correct asymptotic behavior:\n- **Advection-dominated limit ($Pe_h \\to \\infty$):** $\\coth(Pe_h) \\to 1$, so $\\xi(Pe_h) \\to 1$. This gives $\\tau_e \\to \\frac{h}{2|\\beta|}$. The artificial diffusion becomes $\\tau_e \\beta^2 = \\frac{|\\beta|h}{2}$, which recovers the first-order upwind scheme.\n- **Diffusion-dominated limit ($Pe_h \\to 0$):** Using the Taylor expansion $\\coth(x) \\approx 1/x + x/3$, we get $\\xi(Pe_h) \\approx Pe_h/3$. This gives $\\tau_e \\approx \\frac{h}{2|\\beta|} \\frac{Pe_h}{3} = \\frac{h^2}{12\\epsilon}$. The artificial diffusion $\\tau_e \\beta^2 = \\frac{h^2 \\beta^2}{12\\epsilon}$ vanishes as $Pe_h \\to 0$, recovering the standard Galerkin method.\nFor the case $\\beta=0$, the Péclet number is $0$, and the stabilization term $\\tau_e\\beta^2$ is manifestly zero, so SUPG correctly reduces to the Galerkin method.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D advection-diffusion problem using Galerkin FEM and SUPG-FEM,\n    and analyzes the monotonicity of the solutions for different regimes.\n    \"\"\"\n\n    test_cases = [\n        # (N, beta, epsilon)\n        (100, 1.0, 1e-2),\n        (40, 1.0, 5e-3),\n        (50, 1.0, 1e-4),\n        (50, 0.0, 1e-2),\n    ]\n\n    results = []\n    for N, beta, epsilon in test_cases:\n        # 1. Calculate problem parameters\n        h = 1.0 / N\n        # The Peclet number is constant over the uniform mesh\n        # Handle the case epsilon > 0 but beta=0, where Pe=0.\n        if abs(beta)  1e-12 or epsilon == 0:\n            pe_max = 0.0\n        else:\n            pe_max = abs(beta) * h / (2 * epsilon)\n\n        # 2. Solve using Galerkin and SUPG methods\n        sol_galerkin = run_fem_solver(N, beta, epsilon, supg=False)\n        sol_supg = run_fem_solver(N, beta, epsilon, supg=True)\n\n        # 3. Perform monotonicity check\n        tol = -1e-12\n        mono_galerkin = np.all(np.diff(sol_galerkin) >= tol)\n        mono_supg = np.all(np.diff(sol_supg) >= tol)\n\n        # 4. Store results\n        results.append([pe_max, bool(mono_galerkin), bool(mono_supg)])\n    \n    # Final output formatting\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_fem_solver(N, beta, epsilon, supg):\n    \"\"\"\n    Assembles and solves the linear system for the 1D advection-diffusion\n    equation using either standard Galerkin or SUPG stabilization.\n\n    Args:\n        N (int): Number of elements.\n        beta (float): Advection coefficient.\n        epsilon (float): Diffusion coefficient.\n        supg (bool): If True, use SUPG stabilization.\n\n    Returns:\n        np.array: The full solution vector of nodal values, including boundaries.\n    \"\"\"\n    h = 1.0 / N\n    \n    # Calculate stabilization parameter tau for SUPG\n    tau = 0.0\n    if supg and abs(beta) > 1e-12:\n        pe_h = abs(beta) * h / (2.0 * epsilon)\n        # Use Taylor expansion for coth(x) - 1/x for small x to avoid overflow/underflow\n        if pe_h  1e-8:\n            xi_pe = pe_h / 3.0\n        else:\n            xi_pe = 1.0 / np.tanh(pe_h) - 1.0 / pe_h\n\n        tau = (h / (2.0 * abs(beta))) * xi_pe\n        \n    # Element matrix coefficients\n    # A_e = [[a11, a12], [a21, a22]]\n    # Diffusion part\n    k11 = epsilon / h\n    k12 = -epsilon / h\n    # Advection part\n    c11 = -beta / 2.0\n    c12 = beta / 2.0\n    # Stabilization part (artificial diffusion)\n    s11 = tau * beta**2 / h\n    s12 = -tau * beta**2 / h\n    \n    # Assemble element matrix A_e\n    a11 = k11 + c11 + s11\n    a12 = k12 + c12 + s12\n    a21 = k12 - c12 + s12 # Uses symmetry in diffusion and stab, anti-symm in advection\n    a22 = k11 - c11 + s11\n\n    # Assemble the (N-1)x(N-1) global system for interior nodes\n    num_unknowns = N - 1\n    if num_unknowns == 0:\n        return np.array([0.0, 1.0])\n\n    A_glob = np.zeros((num_unknowns, num_unknowns))\n\n    # Diagonal entries\n    diag_val = a22 + a11\n    np.fill_diagonal(A_glob, diag_val)\n\n    # Super-diagonal entries\n    if num_unknowns > 1:\n        super_diag_val = a12\n        np.fill_diagonal(A_glob[0:, 1:], super_diag_val)\n\n    # Sub-diagonal entries\n    if num_unknowns > 1:\n        sub_diag_val = a21\n        np.fill_diagonal(A_glob[1:, 0:], sub_diag_val)\n\n    # Construct the right-hand side vector F\n    # F is zero everywhere except for the last entry due to u(1)=1 BC\n    F_glob = np.zeros(num_unknowns)\n    F_glob[-1] = -a12 * 1.0 # u(N) = 1\n\n    # Solve the linear system A*U_int = F for interior nodes U_int\n    try:\n        U_interior = np.linalg.solve(A_glob, F_glob)\n    except np.linalg.LinAlgError:\n        # In extreme cases, the matrix might be singular. Return a non-monotone array.\n        U_interior = np.full(num_unknowns, np.nan)\n\n    # Combine with boundary conditions to form the full solution vector\n    U_full = np.concatenate(([0.0], U_interior, [1.0]))\n\n    return U_full\n\n\nsolve()\n```", "id": "3447423"}, {"introduction": "Having seen the effectiveness of the SUPG method, a natural question arises: where does the stabilization parameter $\\tau$ come from? This exercise provides a deeper theoretical justification by connecting stabilization to the exact Green's function of the local adjoint operator, revealing the \"optimal\" choice for the parameter. By comparing this theoretically-grounded method with a simplified version often used in practice, you will gain insight into the trade-offs between accuracy and heuristic design in numerical methods [@problem_id:3447447].", "problem": "Consider the steady one-dimensional advection-diffusion boundary value problem on the unit interval with Dirichlet boundary conditions:\n$$\n-\\varepsilon\\,u''(x) + \\beta\\,u'(x) = f(x)\\quad\\text{for }x\\in(0,1),\\qquad u(0)=0,\\quad u(1)=1,\n$$\nwhere $\\varepsilon0$ is the diffusion coefficient, $\\beta0$ is the constant advection speed, and $f(x)=0$. Let $\\mathcal{L}u=-\\varepsilon u''+\\beta u'$ denote the differential operator and $\\mathcal{L}^\\ast w=-\\varepsilon w''-\\beta w'$ its formal adjoint in the standard inner product of the space of square-integrable functions.\n\nYou will work with a uniform mesh of $N$ elements on $[0,1]$, piecewise linear trial functions, and a Petrov-Galerkin method. The goal is to derive and use a Petrov-Galerkin test function on each element based on the exact element Green's function of the adjoint operator and to compare the resulting discrete method to a classic Streamline Upwind Petrov-Galerkin (SUPG) stabilization on a boundary layer problem.\n\nStart from the following fundamental notions and facts:\n- The weak form is obtained by multiplying the differential equation by a test function and integrating over the domain.\n- The Green's function $G(x,\\xi)$ for an operator solves $\\mathcal{L}^\\ast_x G(x,\\xi)=\\delta(x-\\xi)$ with appropriate homogeneous boundary conditions, and represents the response at $x$ to a point source at $\\xi$.\n- On each element of a uniform mesh, with constant $\\varepsilon$ and $\\beta$, the Green's function for the adjoint operator restricted to the element is a linear combination of exponentials that satisfies continuity and jump conditions dictated by the delta distribution.\n- In Petrov-Galerkin methods, optimal local test functions may be constructed by convolving the trial basis with the local Green's function of the adjoint operator.\n\nTasks:\n1. Derive, on a single generic element of length $h$, the exact element Green's function for the adjoint operator $\\mathcal{L}^\\ast w=-\\varepsilon w''-\\beta w'$ with homogeneous Dirichlet boundary conditions at the element endpoints. Then, using this Green's function, construct the corresponding Petrov-Galerkin test function $\\tilde{w}$ associated to a piecewise-linear trial function $\\phi$. Show that this yields a modification of the standard Galerkin bilinear form that can be expressed as an element-wise additional term of the form\n$$\n\\sum_{e} \\tau_e\\,\\beta^2 \\int_{e} u'(x)\\,v'(x)\\,dx,\n$$\nwhere $u$ is the trial function, $v$ is the standard test function, and $\\tau_e$ is a scalar stabilization parameter that depends on the local mesh Péclet number $Pe_e=\\dfrac{\\beta h}{2\\varepsilon}$.\n2. Determine the explicit formula for the stabilization parameter $\\tau_e$ produced by this exact Green's-function-based Petrov-Galerkin construction, expressed in terms of $h$, $\\beta$, $\\varepsilon$, and $Pe_e$. Your derivation should proceed from the exact Green's function on the element and must not assume any pre-known stabilization formula.\n3. Implement two numerical schemes on a uniform mesh with piecewise linear trial functions:\n   - Scheme A (Green–Petrov-Galerkin): Use the stabilization form from Task $1$ with the $\\tau_e$ you derived in Task $2$.\n   - Scheme B (classic SUPG): Use the same discrete form, but with the heuristic classic choice $\\tau_e=\\dfrac{h}{2\\beta}$, which corresponds to the large Péclet number limit and is commonly used in practice.\n4. For each scheme, assemble the global linear system, enforce the Dirichlet boundary conditions $u(0)=0$ and $u(1)=1$, and solve for the nodal values of $u$.\n5. For assessment, use the exact solution for $f(x)=0$ and $\\beta0$,\n$$\nu_{\\mathrm{exact}}(x)=\\frac{e^{\\beta x/\\varepsilon}-1}{e^{\\beta/\\varepsilon}-1},\n$$\nand compute, at the mesh nodes, the root-mean-square error\n$$\nE_{\\mathrm{RMS}} = \\left(\\frac{1}{M}\\sum_{i=0}^{M-1}\\big(u_i - u_{\\mathrm{exact}}(x_i)\\big)^2\\right)^{1/2},\n$$\nwhere $M=N+1$ is the number of nodes, $x_i$ are the nodes, and $u_i$ are the numerical solutions at nodes. Also compute the magnitude of violation of the Dirichlet bounds as\n$$\nV = \\max\\{0,\\ \\max_i u_i - 1\\} + \\max\\{0,\\ 0 - \\min_i u_i\\}.\n$$\nThis $V$ measures any overshoot above $1$ and undershoot below $0$ at the nodes.\n\nTest suite:\n- Case $1$: $\\varepsilon=10^{-2}$, $\\beta=1$, $N=50$.\n- Case $2$: $\\varepsilon=10^{-4}$, $\\beta=1$, $N=100$.\n- Case $3$: $\\varepsilon=10^{-2}$, $\\beta=1$, $N=10$.\n- Case $4$: $\\varepsilon=1$, $\\beta=1$, $N=10$.\n\nYour program must, for each case, compute four numbers in the order $[E_{\\mathrm{RMS}}^{\\mathrm{Green}}, E_{\\mathrm{RMS}}^{\\mathrm{SUPG}}, V^{\\mathrm{Green}}, V^{\\mathrm{SUPG}}]$, and aggregate the results of all cases into a single line of output as a comma-separated list of lists enclosed in square brackets, for example, $[[a,b,c,d],[\\dots],\\dots]$.\n\nAll quantities are nondimensional; do not include any units in the output. Angles are not involved. Percentages are not involved.\n\nYour final submission must be a single, complete, runnable program that implements both schemes, evaluates the test suite, and prints the final results in the exact format specified.", "solution": "The problem is valid as it presents a well-posed, scientifically grounded problem in the field of numerical methods for partial differential equations. All necessary data and definitions are provided, and the tasks form a logical progression from theoretical derivation to numerical implementation and assessment.\n\nWe begin by deriving the stabilization parameter $\\tau_e$ for the Petrov-Galerkin method, as specified in Tasks 1 and 2. The subsequent sections detail the numerical implementation and evaluation.\n\n### Derivation of the Stabilization Parameter $\\tau_e$\n\nThe one-dimensional advection-diffusion problem is given by:\n$$ \\mathcal{L}u = -\\varepsilon u''(x) + \\beta u'(x) = 0 \\quad \\text{for } x \\in (0,1) $$\nwith boundary conditions $u(0)=0$ and $u(1)=1$. The standard weak formulation, obtained by multiplying by a test function $v$ and integrating by parts, is to find $u \\in H^1_E$ such that for all $v \\in H^1_0$:\n$$ B(u, v) = \\int_0^1 (\\varepsilon u'(x)v'(x) + \\beta u'(x)v(x))\\,dx = 0 $$\nIn a standard Galerkin finite element method using piecewise linear basis functions $\\{\\phi_i\\}$, both the trial function $u_h$ and test function $v_h$ are drawn from the same space $V_h = \\text{span}\\{\\phi_i\\}$. This approach is known to produce spurious oscillations for advection-dominated problems (i.e., when $\\varepsilon$ is small compared to $\\beta h$).\n\nThe Petrov-Galerkin method uses a test space $W_h$ different from the trial space $V_h$. A common construction for a stabilized method is to define the test functions as $w = v + \\delta_v$, where $v \\in V_h$ and $\\delta_v$ is a correction term designed to add stability. The weak form becomes $B(u_h, w_h) = B(u_h, v_h) + B(u_h, \\delta_v) = 0$. The additional term $B(u_h, \\delta_v)$ provides the stabilization.\n\nIn residual-based methods like SUPG or GGLS, the correction term $\\delta_v$ is constructed to act on the residual of the strong equation, $\\mathcal{L}u_h$. For a piecewise linear trial function $u_h$, its second derivative $u_h''$ is zero inside each element, so the element-wise residual is simply $\\mathcal{L}u_h = \\beta u_h'$. The stabilization term added to the weak form is typically $\\sum_e \\int_e \\delta_v (\\mathcal{L}u_h) dx$, where the correction is chosen as $\\delta_v = \\tau_e \\mathcal{L}v = \\tau_e \\beta v'$. This yields the additional term:\n$$ \\sum_{e} \\int_{e} (\\tau_e \\beta v'(x)) (\\beta u'(x)) \\,dx = \\sum_{e} \\tau_e\\,\\beta^2 \\int_{e} u'(x)\\,v'(x)\\,dx $$\nThis matches the form given in the problem statement. Our goal is to derive the \"optimal\" stabilization parameter $\\tau_e$ using the element Green's function for the adjoint operator, $\\mathcal{L}^\\ast w = -\\varepsilon w'' - \\beta w'$.\n\nThe theory of optimal test functions (related to Residual-Free Bubbles) states that the correction $\\delta_v$ on an element $K_e$ should be the solution of the local adjoint problem with the element residual of the test function $v$ as the source term:\n$$ \\mathcal{L}^\\ast \\delta_v = \\mathcal{L}v \\quad \\text{on } K_e, \\qquad \\delta_v = 0 \\quad \\text{on } \\partial K_e $$\nThe solution to this can be expressed using the element Green's function $G_e(x, \\xi)$ for the operator $\\mathcal{L}^\\ast$ on $K_e$:\n$$ \\delta_v(x) = \\int_{K_e} G_e(x, \\xi) (\\mathcal{L}v)(\\xi) \\,d\\xi $$\nFor a linear test function $v$ on an element of length $h$, $v''=0$ and $v'$ is a constant. Thus, $\\mathcal{L}v = \\beta v'$. The stabilization term becomes:\n$$ \\int_{K_e} (\\mathcal{L}u_h) \\delta_v(x) \\,dx = \\int_{K_e} (\\beta u') \\left( \\int_{K_e} G_e(x, \\xi) (\\beta v') \\,d\\xi \\right) \\,dx $$\nSince $u'$ and $v'$ are constant on the element for piecewise linear functions, we can write:\n$$ \\beta^2 u' v' \\int_{K_e} \\int_{K_e} G_e(x, \\xi) \\,d\\xi \\,dx = \\tau_e \\beta^2 \\int_{K_e} u' v' \\,dx = \\tau_e \\beta^2 u' v' h $$\nFrom this, we identify the stabilization parameter $\\tau_e$ as:\n$$ \\tau_e = \\frac{1}{h} \\int_{K_e} \\int_{K_e} G_e(x, \\xi) \\,d\\xi \\,dx $$\nTo find $\\tau_e$, we can avoid a direct, cumbersome computation of the double integral of $G_e(x, \\xi)$. Let $I(x) = \\int_{K_e} G_e(x, \\xi) \\,d\\xi$. Applying the operator $\\mathcal{L}^\\ast$ to $I(x)$ gives:\n$$ \\mathcal{L}^\\ast I(x) = \\int_{K_e} \\mathcal{L}^\\ast_x G_e(x, \\xi) \\,d\\xi = \\int_{K_e} \\delta(x-\\xi) \\,d\\xi = 1 \\quad \\text{for } x \\in K_e $$\nThe boundary conditions for $G_e$ imply that $I(x)$ must also be zero at the element boundaries. Let the element be $[0, h]$. We solve the auxiliary boundary value problem:\n$$ -\\varepsilon I''(x) - \\beta I'(x) = 1 \\quad \\text{for } x \\in (0,h), \\qquad I(0)=0,\\quad I(h)=0 $$\nThe general solution to the homogeneous equation $-\\varepsilon w'' - \\beta w' = 0$ is $w_h(x) = C_1 + C_2 e^{-\\beta x/\\varepsilon}$. A particular solution to the full equation is $w_p(x) = -x/\\beta$. Thus, the general solution for $I(x)$ is $I(x) = C_1 + C_2 e^{-\\beta x/\\varepsilon} - x/\\beta$.\nApplying the boundary conditions:\n$I(0) = 0 \\implies C_1 + C_2 = 0 \\implies C_1 = -C_2$.\n$I(h) = 0 \\implies C_1 + C_2 e^{-\\beta h/\\varepsilon} - h/\\beta = 0$.\nSubstituting $C_1 = -C_2$ gives $C_2(e^{-\\beta h/\\varepsilon} - 1) = h/\\beta$, so $C_2 = \\frac{h/\\beta}{e^{-\\beta h/\\varepsilon}-1}$.\nThis yields $I(x) = \\frac{h/\\beta}{1-e^{-\\beta h/\\varepsilon}}(1 - e^{-\\beta x/\\varepsilon}) - x/\\beta$.\n\nNow, we compute $\\tau_e = \\frac{1}{h} \\int_0^h I(x)\\,dx$:\n$$ \\tau_e h = \\int_0^h \\left( \\frac{h/\\beta}{1-e^{-\\beta h/\\varepsilon}}(1 - e^{-\\beta x/\\varepsilon}) - \\frac{x}{\\beta} \\right) dx $$\n$$ \\tau_e h = \\frac{h/\\beta}{1-e^{-\\beta h/\\varepsilon}} \\left[x + \\frac{\\varepsilon}{\\beta}e^{-\\beta x/\\varepsilon}\\right]_0^h - \\frac{1}{\\beta}\\left[\\frac{x^2}{2}\\right]_0^h $$\n$$ \\tau_e h = \\frac{h/\\beta}{1-e^{-\\beta h/\\varepsilon}} \\left( \\left(h+\\frac{\\varepsilon}{\\beta}e^{-\\beta h/\\varepsilon}\\right) - \\left(0+\\frac{\\varepsilon}{\\beta}\\right) \\right) - \\frac{h^2}{2\\beta} $$\n$$ \\tau_e h = \\frac{h/\\beta}{1-e^{-\\beta h/\\varepsilon}} \\left( h - \\frac{\\varepsilon}{\\beta}(1-e^{-\\beta h/\\varepsilon}) \\right) - \\frac{h^2}{2\\beta} $$\n$$ \\tau_e h = \\frac{h^2/\\beta}{1-e^{-\\beta h/\\varepsilon}} - \\frac{h\\varepsilon}{\\beta^2} - \\frac{h^2}{2\\beta} = \\frac{h^2}{2\\beta} \\left( \\frac{2}{1-e^{-\\beta h/\\varepsilon}} - 1 \\right) - \\frac{h\\varepsilon}{\\beta^2} $$\nLet $s = \\beta h/\\varepsilon = 2Pe_e$, where $Pe_e$ is the element Péclet number.\n$$ \\tau_e = \\frac{h}{2\\beta} \\left( \\frac{2}{1-e^{-s}} - 1 \\right) - \\frac{\\varepsilon}{\\beta^2} = \\frac{h}{2\\beta} \\left( \\frac{2 - (1-e^{-s})}{1-e^{-s}} \\right) - \\frac{\\varepsilon}{\\beta^2} = \\frac{h}{2\\beta} \\frac{1+e^{-s}}{1-e^{-s}} - \\frac{\\varepsilon}{\\beta^2} $$\nUsing the identity $\\coth(y) = \\frac{e^y+e^{-y}}{e^y-e^{-y}} = \\frac{1+e^{-2y}}{1-e^{-2y}}$, we have $\\frac{1+e^{-s}}{1-e^{-s}} = \\coth(s/2) = \\coth(Pe_e)$.\nSo, $\\tau_e = \\frac{h}{2\\beta}\\coth(Pe_e) - \\frac{\\varepsilon}{\\beta^2}$.\nTo match the standard form, we note that $\\frac{1}{Pe_e} = \\frac{2\\varepsilon}{\\beta h}$. Then $\\frac{\\varepsilon}{\\beta^2} = \\frac{h}{2\\beta} \\frac{2\\varepsilon}{h\\beta} = \\frac{h}{2\\beta} \\frac{1}{Pe_e}$.\nFinally, we obtain the explicit formula for the stabilization parameter:\n$$ \\tau_e = \\frac{h}{2\\beta} \\left( \\coth(Pe_e) - \\frac{1}{Pe_e} \\right) $$\nThis expression is known as the Hughes parameter. As $Pe_e \\to \\infty$ (advection-dominated limit), $\\coth(Pe_e) \\to 1$ and $1/Pe_e \\to 0$, so $\\tau_e \\to \\frac{h}{2\\beta}$. This is exactly the classic SUPG parameter used in Scheme B, which is optimal only in the high Péclet number limit. For small $Pe_e$, a Taylor expansion gives $\\coth(Pe_e) - 1/Pe_e \\approx Pe_e/3$, so $\\tau_e \\approx \\frac{h}{2\\beta} \\frac{Pe_e}{3} = \\frac{h^2}{12\\varepsilon}$, which appropriately scales down the artificial diffusion.\n\n### Numerical Implementation Details\n\nThe finite element method is implemented on a uniform mesh of $N$ elements, with element size $h=1/N$. The solution is approximated by a linear combination of piecewise linear basis functions, $u_h(x) = \\sum_{j=0}^{N} U_j \\phi_j(x)$, where $U_j$ are the nodal values to be determined.\n\nThe local $2 \\times 2$ element matrix $A^e$ on an element is the sum of the standard diffusion, advection, and stabilization matrices:\n$A^e = K^e + C^e + S^e$, where\n$$ K^e = \\frac{\\varepsilon}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}, \\quad C^e = \\frac{\\beta}{2} \\begin{pmatrix} -1  1 \\\\ -1  1 \\end{pmatrix}, \\quad S^e = \\frac{\\tau_e \\beta^2}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} $$\nThese matrices are assembled into a global $(N+1) \\times (N+1)$ matrix $A$. The right-hand side vector $F$ is initially zero as the source term $f(x)=0$.\n\nThe Dirichlet boundary conditions $u(0)=U_0=0$ and $u(1)=U_N=1$ are enforced by modifying the linear system. We solve for the $N-1$ interior unknowns $U_1, \\dots, U_{N-1}$. The system is formed by the submatrix $A_{1:N, 1:N}$ of the global matrix. The right-hand side vector is adjusted to account for the known value $U_N=1$, which affects the equation for $U_{N-1}$. The system for the interior nodes becomes $A_{int} U_{int} = F_{int}$, which is solved using a standard linear solver. The final solution vector is constructed by combining the computed interior values with the known boundary values.\n\nTwo schemes are implemented: Scheme A uses the derived \"optimal\" $\\tau_e$, while Scheme B uses the classical SUPG parameter $\\tau_e = h/(2\\beta)$. Errors are computed against the provided exact solution. Special care is taken in the implementation to handle numerical issues, such as using a Taylor series approximation for $\\tau_e$ at very small $Pe_e$ and using an asymptotic form for the exact solution at very large global Péclet numbers to prevent floating-point overflow.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy is not used as per the problem constraints.\n\ndef coth(x: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the hyperbolic cotangent element-wise.\n    \n    Args:\n        x: Input array.\n\n    Returns:\n        The hyperbolic cotangent of the input.\n    \"\"\"\n    return np.cosh(x) / np.sinh(x)\n\ndef solve_fem(eps: float, beta: float, N: int, tau: float) -> np.ndarray:\n    \"\"\"\n    Solves the 1D advection-diffusion problem using the Finite Element Method\n    with a given stabilization parameter tau.\n\n    Args:\n        eps: Diffusion coefficient.\n        beta: Advection speed.\n        N: Number of elements.\n        tau: Stabilization parameter.\n\n    Returns:\n        The numerical solution at the mesh nodes.\n    \"\"\"\n    h = 1.0 / N\n    M = N + 1  # Number of nodes\n\n    # --- Element Stiffness Matrix ---\n    # Standard diffusion matrix component\n    K_e = (eps / h) * np.array([[1.0, -1.0], [-1.0, 1.0]])\n    # Standard advection matrix component\n    C_e = (beta / 2.0) * np.array([[-1.0, 1.0], [-1.0, 1.0]])\n    # Stabilization matrix component\n    S_e = (tau * beta**2 / h) * np.array([[1.0, -1.0], [-1.0, 1.0]])\n    \n    # Total element stiffness matrix\n    A_e = K_e + C_e + S_e\n\n    # --- Assembly ---\n    # Assemble the global stiffness matrix A\n    A = np.zeros((M, M))\n    for k in range(N):  # Iterate through elements 0 to N-1\n        # Global indices for the element are k and k+1\n        i, j = k, k + 1\n        A[i, i] += A_e[0, 0]\n        A[i, j] += A_e[0, 1]\n        A[j, i] += A_e[1, 0]\n        A[j, j] += A_e[1, 1]\n\n    # --- Boundary Conditions and Solution ---\n    # We solve for the N-1 interior nodes U_1, ..., U_{N-1}.\n    # The linear system is defined by the interior part of the global matrix.\n    A_internal = A[1:N, 1:N]\n    F_internal = np.zeros(N - 1)\n    \n    # Boundary conditions: u(0) = 0 and u(1) = 1.\n    # The equation for U_1: A[1,0]U_0 + A[1,1]U_1 + A[1,2]U_2 = 0.\n    # Since U_0=0, the RHS is not modified.\n    #\n    # The equation for U_{N-1}: A[N-1,N-2]U_{N-2} + A[N-1,N-1]U_{N-1} + A[N-1,N]U_N = 0.\n    # Since U_N=1, this becomes: A[N-1,N-2]U_{N-2} + A[N-1,N-1]U_{N-1} = -A[N-1,N].\n    # So, we modify the last entry of the internal RHS vector.\n    if N-1 > 0:\n        F_internal[-1] -= A[N - 1, N] * 1.0\n    \n    # Solve the linear system for interior nodes\n    try:\n        if N-1 > 0:\n            U_internal = np.linalg.solve(A_internal, F_internal)\n        else:\n            U_internal = np.array([])\n    except np.linalg.LinAlgError:\n        return np.full(M, np.nan)\n\n    # Reconstruct the full solution vector U including boundaries\n    U = np.zeros(M)\n    U[0] = 0.0\n    U[N] = 1.0\n    if N-1 > 0:\n        U[1:N] = U_internal\n    \n    return U\n\ndef solve_case(eps: float, beta: float, N: int) -> list[float]:\n    \"\"\"\n    Computes the specified error metrics for a given test case for both\n    Green-Petrov-Galerkin and classic SUPG schemes.\n\n    Args:\n        eps: Diffusion coefficient.\n        beta: Advection speed.\n        N: Number of elements.\n\n    Returns:\n        A list containing [E_rms_Green, E_rms_SUPG, V_Green, V_SUPG].\n    \"\"\"\n    h = 1.0 / N\n    M = N + 1  # Number of nodes\n    nodes = np.linspace(0.0, 1.0, M)\n\n    # --- Scheme A: Green-Petrov-Galerkin (Optimal tau) ---\n    Pe = (beta * h) / (2.0 * eps)\n    # Use Taylor expansion for small Pe to avoid numerical instability of coth(x) - 1/x\n    if Pe  1e-8:\n        # For small x, coth(x) - 1/x ≈ x/3\n        tau_A = (h / (2.0 * beta)) * (Pe / 3.0) \n    else:\n        tau_A = (h / (2.0 * beta)) * (coth(Pe) - 1.0 / Pe)\n    \n    U_A = solve_fem(eps, beta, N, tau_A)\n\n    # --- Scheme B: Classic SUPG (High-Pe limit tau) ---\n    tau_B = h / (2.0 * beta)\n    U_B = solve_fem(eps, beta, N, tau_B)\n\n    # --- Error Calculation ---\n    # Exact solution\n    Peclet_global = beta / eps\n    # Use asymptotic approximation for large Peclet_global to avoid np.exp overflow\n    if Peclet_global > 700: \n        u_exact = np.exp(Peclet_global * (nodes - 1.0))\n        u_exact[-1] = 1.0  # Ensure BC is met exactly\n    else:\n        num = np.exp(Peclet_global * nodes) - 1.0\n        den = np.exp(Peclet_global) - 1.0\n        if den == 0: den = 1e-16 # Avoid division by zero for very small Peclet_global\n        u_exact = num / den\n\n    # Root Mean Square Error\n    E_rms_A = np.sqrt(np.mean((U_A - u_exact)**2))\n    E_rms_B = np.sqrt(np.mean((U_B - u_exact)**2))\n\n    # Violation of discrete maximum principle (overshoot/undershoot)\n    V_A = max(0.0, np.max(U_A) - 1.0) + max(0.0, 0.0 - np.min(U_A))\n    V_B = max(0.0, np.max(U_B) - 1.0) + max(0.0, 0.0 - np.min(U_B))\n    \n    return [E_rms_A, E_rms_B, V_A, V_B]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results in the specified format.\n    \"\"\"\n    test_cases = [\n        (1e-2, 1.0, 50),\n        (1e-4, 1.0, 100),\n        (1e-2, 1.0, 10),\n        (1.0, 1.0, 10)\n    ]\n\n    all_results = []\n    for case in test_cases:\n        eps, beta, N = case\n        results_case = solve_case(eps, beta, N)\n        all_results.append(results_case)\n\n    # Format the output string as a list of lists of numbers.\n    list_of_strings = [f\"[{','.join(f'{x:.6e}' for x in item)}]\" for item in all_results]\n    final_output = f\"[{','.join(list_of_strings)}]\"\n    \n    # The final print statement must produce ONLY the specified output string.\n    print(final_output)\n\nsolve()\n\n```", "id": "3447447"}, {"introduction": "Our final practice moves from the idealized 1D setting to a more realistic 2D domain, where new challenges emerge. When the advection direction is not aligned with the mesh, standard SUPG stabilization proves insufficient, leading to non-physical \"crosswind\" oscillations. This exercise introduces you to the limitations of SUPG and explores more robust solutions, including the Galerkin/Least-Squares (GLS) method and the concept of artificial crosswind diffusion to restore solution quality [@problem_id:3447460].", "problem": "Consider the stationary linear advection-diffusion equation posed on the unit square domain $[0,1]\\times[0,1]$,\n$$ \\boldsymbol{b}\\cdot\\nabla u - \\varepsilon \\Delta u = 0 \\quad \\text{in } \\Omega, $$\nwith essential boundary conditions chosen as follows: on inflow portions of the boundary (where the outward unit normal $\\boldsymbol{n}$ satisfies $\\boldsymbol{b}\\cdot \\boldsymbol{n}  0$), prescribe $u=1$, and on outflow portions ($\\boldsymbol{b}\\cdot \\boldsymbol{n} \\ge 0$), prescribe $u=0$. The vector $\\boldsymbol{b}$ is constant and misaligned with the mesh axes, and the diffusion coefficient $\\varepsilon  0$ is small.\n\nYou will discretize this problem using the standard continuous Galerkin finite element method with quadratic Lagrange basis functions on a structured anisotropic mesh of axis-aligned rectangles, and compare two stabilized formulations: the Streamline Upwind/Petrov-Galerkin (SUPG) and the Galerkin/Least-Squares (GLS) methods. Additionally, you will quantify the effect of adding crosswind diffusion (an artificial diffusion orthogonal to the flow direction) on crosswind oscillations.\n\nThe variational base starts from the weak form: find $u \\in H^1(\\Omega)$ satisfying\n$$ a(u,v) = 0 \\quad \\forall v \\in H^1_0(\\Omega), $$\nwhere\n$$ a(u,v) = \\int_{\\Omega} \\varepsilon \\nabla u \\cdot \\nabla v \\, d\\Omega + \\int_{\\Omega} (\\boldsymbol{b}\\cdot \\nabla u) v \\, d\\Omega. $$\n\nThe stabilized formulations modify $a(u,v)$ by adding terms defined elementwise on each mesh cell $\\Omega_e$:\n- Streamline Upwind/Petrov-Galerkin (SUPG): add\n$$ s_{\\mathrm{SUPG}}(u,v) = \\sum_{e} \\int_{\\Omega_e} \\tau_e \\, (\\boldsymbol{b}\\cdot \\nabla u)\\, (\\boldsymbol{b}\\cdot \\nabla v) \\, d\\Omega. $$\n- Galerkin/Least-Squares (GLS): add\n$$ s_{\\mathrm{GLS}}(u,v) = \\sum_{e} \\int_{\\Omega_e} \\tau_e \\, r(u)\\, r(v)\\, d\\Omega, \\quad r(w) := \\boldsymbol{b}\\cdot \\nabla w - \\varepsilon \\Delta w. $$\n\nThe crosswind diffusion augments the physical diffusion by a tensor term orthogonal to the flow direction. Let $\\widehat{\\boldsymbol{b}} = \\boldsymbol{b}/\\|\\boldsymbol{b}\\|$ and define the orthogonal projector onto the crosswind subspace\n$$ \\mathbf{P}_{\\perp} = \\mathbf{I} - \\widehat{\\boldsymbol{b}}\\, \\widehat{\\boldsymbol{b}}^\\top. $$\nWith crosswind diffusion coefficient $\\mu_{\\perp} \\ge 0$, add\n$$ d_{\\perp}(u,v) = \\int_{\\Omega} \\mu_{\\perp}\\, (\\nabla u)^\\top \\mathbf{P}_{\\perp}\\, \\nabla v \\, d\\Omega. $$\n\nUse quadratic ($Q_2$) Lagrange finite elements on rectangles, with the standard reference nodes at $\\xi, \\eta \\in \\{-1, 0, 1\\}$ and the one-dimensional basis functions\n$$ \\ell_{-1}(\\xi) = \\tfrac{1}{2}\\xi(\\xi - 1), \\quad \\ell_0(\\xi) = 1 - \\xi^2, \\quad \\ell_{+1}(\\xi) = \\tfrac{1}{2}\\xi(\\xi + 1), $$\nand their derivatives $\\ell'_{-1}(\\xi) = \\xi - \\tfrac{1}{2}$, $\\ell'_0(\\xi) = -2\\xi$, $\\ell'_{+1}(\\xi) = \\xi + \\tfrac{1}{2}$, and second derivatives $\\ell''_{-1}(\\xi) = 1$, $\\ell''_0(\\xi) = -2$, $\\ell''_{+1}(\\xi) = 1$. On each element with physical sizes $h_x$ and $h_y$, the gradients and Laplacians of shape functions are obtained via the affine mapping $(\\xi,\\eta)\\mapsto (x,y)$:\n$$ \\nabla N(\\xi,\\eta) = \\begin{bmatrix} \\tfrac{2}{h_x}\\,\\partial_{\\xi} N \\\\ \\tfrac{2}{h_y}\\,\\partial_{\\eta} N \\end{bmatrix}, \\quad \\Delta N(\\xi,\\eta) = \\left(\\tfrac{2}{h_x}\\right)^2 \\partial_{\\xi\\xi} N + \\left(\\tfrac{2}{h_y}\\right)^2 \\partial_{\\eta\\eta} N. $$\n\nChoose a stabilization parameter $\\tau_e$ per element based on the directional mesh size along the flow and the Péclet number. Let $\\widehat{\\boldsymbol{b}}=(\\cos\\theta,\\sin\\theta)$, and define the element-wise streamline length\n$$ h_{\\parallel} = \\sqrt{(h_x \\cos\\theta)^2 + (h_y \\sin\\theta)^2}, \\quad \\mathrm{Pe} = \\frac{\\|\\boldsymbol{b}\\|\\, h_{\\parallel}}{2\\varepsilon}. $$\nSet\n$$ \\tau_e = \\frac{h_{\\parallel}}{2\\|\\boldsymbol{b}\\|} \\left(\\coth(\\mathrm{Pe}) - \\frac{1}{\\mathrm{Pe}}\\right), $$\nwith the convention that for very small $\\mathrm{Pe}$, one uses the series approximation $\\coth(\\mathrm{Pe}) - 1/\\mathrm{Pe} \\approx \\mathrm{Pe}/3$.\n\nTo quantify crosswind oscillations, compute two metrics:\n1. The crosswind gradient index,\n$$ I_{\\perp} = \\frac{\\left\\| \\mathbf{P}_{\\perp} \\nabla u \\right\\|_{L^2(\\Omega)}^2}{\\left\\| \\nabla u \\right\\|_{L^2(\\Omega)}^2} = \\frac{\\int_{\\Omega} \\left( \\mathbf{P}_{\\perp} \\nabla u \\right)\\cdot \\left( \\mathbf{P}_{\\perp} \\nabla u \\right)\\, d\\Omega}{\\int_{\\Omega} \\nabla u \\cdot \\nabla u \\, d\\Omega}, $$\nwhich represents the fraction of gradient energy orthogonal to the flow direction.\n2. The interior overshoot/undershoot amplitude,\n$$ A_{\\mathrm{osc}} = \\max\\{0, \\max_{\\Omega^\\circ} u - 1\\} + \\max\\{0, -\\min_{\\Omega^\\circ} u\\}, $$\nwhere $\\Omega^\\circ$ denotes interior degrees of freedom (excluding Dirichlet boundary nodes). This measures nonphysical oscillations above the inflow value 1 and below the outflow value 0.\n\nImplement Gaussian quadrature on the reference square with three points in each dimension to compute element integrals exactly for polynomials up to degree five. Assemble the global linear system, impose essential boundary conditions strongly, and solve the resulting non-symmetric system.\n\nTest Suite:\nUse the following fixed parameters for all tests unless toggled as specified:\n- Mesh: $N_x = 18$ elements in $x$, $N_y = 6$ elements in $y$ (anisotropic with $h_x = 1/N_x$, $h_y = 1/N_y$).\n- Advection: $\\boldsymbol{b}$ of magnitude $\\|\\boldsymbol{b}\\|=1$ with angle $\\theta = 33^\\circ$ relative to the $x$-axis, i.e., $\\boldsymbol{b}=(\\cos\\theta,\\sin\\theta)$ in radians.\n- Diffusion: $\\varepsilon = 10^{-4}$.\n- Crosswind diffusion coefficient: $\\mu_{\\perp} = \\alpha_{\\perp} \\, \\|\\boldsymbol{b}\\|\\, h_{\\perp}$, where $h_{\\perp} = \\sqrt{(h_x \\sin\\theta)^2 + (h_y \\cos\\theta)^2}$ and $\\alpha_{\\perp}$ is toggled per test; set $\\alpha_{\\perp}=0$ when off and $\\alpha_{\\perp}=0.05$ when on.\n\nDefine four test cases to compare methods and the effect of crosswind diffusion:\n- Test 1: SUPG stabilization, crosswind diffusion off ($\\alpha_{\\perp}=0$).\n- Test 2: GLS stabilization, crosswind diffusion off ($\\alpha_{\\perp}=0$).\n- Test 3: SUPG stabilization, crosswind diffusion on ($\\alpha_{\\perp}=0.05$).\n- Test 4: GLS stabilization, crosswind diffusion on ($\\alpha_{\\perp}=0.05$).\n\nYour program should produce a single line of output containing the results for these four tests as a comma-separated list enclosed in square brackets. For each test, output two floats: first the crosswind gradient index $I_{\\perp}$, and second the overshoot/undershoot amplitude $A_{\\mathrm{osc}}$. The final output format must be\n$$ [I_{\\perp}^{(1)},A_{\\mathrm{osc}}^{(1)},I_{\\perp}^{(2)},A_{\\mathrm{osc}}^{(2)},I_{\\perp}^{(3)},A_{\\mathrm{osc}}^{(3)},I_{\\perp}^{(4)},A_{\\mathrm{osc}}^{(4)}] $$\nwhere the superscript indicates the test number in the order listed above. All floating-point numbers should be printed in standard decimal notation.", "solution": "The user wants to solve a stationary advection-diffusion problem and compare different finite element stabilization techniques. The solution will be implemented using Python and the NumPy library.\n\n### 1. Problem Formulation and Discretization\n\nThe governing equation is the stationary linear advection-diffusion equation on the unit square $\\Omega = [0,1]^2$:\n$$ \\boldsymbol{b}\\cdot\\nabla u - \\varepsilon \\Delta u = 0 $$\nwhere $\\boldsymbol{b}$ is a constant advection velocity, and $\\varepsilon  0$ is a small diffusion coefficient. This setup models a transport process where advection dominates diffusion. Boundary conditions are $u=1$ on the inflow boundary (where $\\boldsymbol{b}\\cdot\\boldsymbol{n}  0$, with $\\boldsymbol{n}$ being the outward normal) and $u=0$ on the outflow boundary ($\\boldsymbol{b}\\cdot\\boldsymbol{n} \\ge 0$).\n\nThe standard Galerkin Finite Element Method (FEM) is applied for discretization. Multiplying the PDE by a test function $v \\in H^1_0(\\Omega)$ and integrating by parts on the diffusion term gives the weak form: find $u \\in H^1(\\Omega)$ such that $u$ satisfies the essential boundary conditions and\n$$ a(u,v) = \\int_{\\Omega} (\\boldsymbol{b}\\cdot \\nabla u) v \\, d\\Omega + \\int_{\\Omega} \\varepsilon \\nabla u \\cdot \\nabla v \\, d\\Omega = 0 \\quad \\forall v \\in H^1_0(\\Omega). $$\nFor advection-dominated problems (small $\\varepsilon$), the standard Galerkin method is known to produce non-physical, spurious oscillations in the numerical solution. This necessitates the use of stabilization techniques.\n\nThe domain is discretized using a structured mesh of $N_x \\times N_y$ rectangular elements, and the solution is approximated using continuous quadratic ($Q_2$) Lagrange basis functions. Each rectangular element has $9$ nodes.\n\n### 2. Stabilization Methods\n\nTwo stabilization methods are considered: Streamline Upwind/Petrov-Galerkin (SUPG) and Galerkin/Least-Squares (GLS). Both methods add terms to the weak form that act along the streamline direction to counteract the instabilities.\n\n**SUPG Stabilization:**\nThe SUPG method modifies the test function to be $v + \\tau_e \\boldsymbol{b}\\cdot\\nabla v$. In the context of modifying the bilinear form, this is equivalent to adding the term:\n$$ s_{\\mathrm{SUPG}}(u,v) = \\sum_{e} \\int_{\\Omega_e} \\tau_e \\, (\\boldsymbol{b}\\cdot \\nabla u)\\, (\\boldsymbol{b}\\cdot \\nabla v) \\, d\\Omega $$\nThis term introduces artificial diffusion purely in the direction of the flow (the streamline direction), damping oscillations that form along streamlines.\n\n**GLS Stabilization:**\nThe GLS method is more comprehensive and adds a term proportional to the PDE's residual, applied to both the trial and test functions. The added term is:\n$$ s_{\\mathrm{GLS}}(u,v) = \\sum_{e} \\int_{\\Omega_e} \\tau_e \\, r(u)\\, r(v)\\, d\\Omega, \\quad \\text{where } r(w) := \\boldsymbol{b}\\cdot \\nabla w - \\varepsilon \\Delta w. $$\nSince the residual $r(u)$ is zero for the exact solution, this method is consistent. When expanded, the GLS term contains the SUPG term plus additional terms involving the Laplacian, providing more stability.\n\nThe stabilization parameter $\\tau_e$ is crucial and is defined based on the element size and local Péclet number, $\\mathrm{Pe} = \\|\\boldsymbol{b}\\| h_{\\parallel} / (2\\varepsilon)$, where $h_\\parallel$ is the effective mesh size along the streamline. The provided formula is a standard choice that provides optimal stability.\n\n### 3. Crosswind Diffusion\n\nWhile SUPG and GLS effectively handle oscillations along streamlines, they do not address oscillations that can occur in the crosswind direction, particularly near sharp gradients or internal layers. To mitigate this, artificial crosswind diffusion is introduced. This is achieved by adding a diffusion term that acts only in the direction orthogonal to the flow. The term is:\n$$ d_{\\perp}(u,v) = \\int_{\\Omega} \\mu_{\\perp}\\, (\\nabla u)^\\top \\mathbf{P}_{\\perp}\\, \\nabla v \\, d\\Omega. $$\nHere, $\\mathbf{P}_{\\perp} = \\mathbf{I} - \\widehat{\\boldsymbol{b}}\\, \\widehat{\\boldsymbol{b}}^\\top$ is the projection matrix onto the subspace orthogonal to the normalized flow direction $\\widehat{\\boldsymbol{b}}$. The coefficient $\\mu_{\\perp}$ controls the amount of added diffusion.\n\n### 4. Implementation Strategy\n\nThe solution is implemented by constructing a finite element solver that can handle the specified variations.\n\n- **Element-wise Computation:** The core of the solver is a loop over all elements in the mesh. For each element, a $9 \\times 9$ local stiffness matrix is computed.\n- **Numerical Integration:** Integrals over the element are approximated using a $3 \\times 3$ Gaussian quadrature rule on the reference square $[-1,1]^2$. This is sufficient to exactly integrate the resulting polynomials.\n- **Basis Functions:** At each quadrature point, the values of the $9$ quadratic basis functions $N_i$ and their gradients $\\nabla N_i$ and Laplacians $\\Delta N_i$ are computed using the provided formulas and the chain rule for the affine element mapping.\n- **Matrix Assembly:** For each pair of trial function $N_j$ and test function $N_i$, the integrand of the full weak form (including stabilization and crosswind terms) is evaluated at the quadrature point and multiplied by the quadrature weight and Jacobian determinant. This value is added to the local stiffness matrix. The local matrices are then assembled into a global system matrix $K$.\n- **Boundary Conditions:** Essential (Dirichlet) boundary conditions are enforced strongly. The global system of equations $KU=F$ is partitioned into known (Dirichlet) and unknown (interior) degrees of freedom. A reduced system is solved for the interior nodes, and the full solution vector is then reconstructed.\n- **Solving:** The resulting linear system is non-symmetric and is solved using a direct solver, `numpy.linalg.solve`.\n\n### 5. Evaluation Metrics\n\nAfter obtaining the discrete solution vector $U$, two metrics are computed to quantify the performance of each method.\n\n1.  **Crosswind Gradient Index ($I_{\\perp}$):** This metric measures the proportion of the solution's gradient energy that is oriented perpendicular to the flow direction. A high value indicates significant crosswind oscillations or smearing. It is computed as the ratio of two $L^2$ norms, evaluated using the same Gaussian quadrature scheme:\n    $$ I_{\\perp} = \\frac{\\int_{\\Omega} \\|\\mathbf{P}_{\\perp} \\nabla u_h \\|^2 \\, d\\Omega}{\\int_{\\Omega} \\|\\nabla u_h\\|^2 \\, d\\Omega} $$\n2.  **Overshoot/Undershoot Amplitude ($A_{\\mathrm{osc}}$):** This metric quantifies the violation of the discrete maximum principle. The exact solution is bounded by its boundary values, $[0, 1]$. The numerical solution may exhibit non-physical oscillations, with values greater than $1$ (overshoots) or less than $0$ (undershoots). This metric sums the magnitudes of the largest overshoot and undershoot found at any interior node:\n    $$ A_{\\mathrm{osc}} = \\max\\{0, \\max_{\\Omega^\\circ} u_h - 1\\} + \\max\\{0, -\\min_{\\Omega^\\circ} u_h\\} $$\n\nBy computing these metrics for the four specified test cases (SUPG vs GLS, with and without crosswind diffusion), a quantitative comparison of the methods' effectiveness in mitigating numerical oscillations is achieved.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the four test cases and print the results.\n    \"\"\"\n\n    def coth(x):\n        \"\"\"Hyperbolic cotangent, with guards for large arguments.\"\"\"\n        # For large |x|, coth(x) approaches +/-1.\n        # This avoids overflow/underflow issues in np.exp.\n        if x > 50:\n            return 1.0\n        if x  -50:\n            return -1.0\n        return np.cosh(x) / np.sinh(x)\n\n    def run_fem_solver(stabilization, alpha_perp):\n        \"\"\"\n        Solves the advection-diffusion problem for a given stabilization method\n        and crosswind diffusion parameter.\n        \"\"\"\n        # --- 1. Define Parameters ---\n        # Fixed parameters from problem statement\n        Nx, Ny = 18, 6\n        theta_deg = 33.0\n        epsilon = 1e-4\n\n        # Derived parameters\n        hx, hy = 1.0 / Nx, 1.0 / Ny\n        theta_rad = np.deg2rad(theta_deg)\n        b = np.array([np.cos(theta_rad), np.sin(theta_rad)])\n        b_norm = np.linalg.norm(b)\n        b_hat = b / b_norm\n\n        # Mesh-dependent lengths for stabilization parameters\n        h_parallel = np.sqrt((hx * np.cos(theta_rad))**2 + (hy * np.sin(theta_rad))**2)\n        h_perp = np.sqrt((hx * np.sin(theta_rad))**2 + (hy * np.cos(theta_rad))**2)\n        \n        # Péclet number and stabilization parameter tau\n        Pe = b_norm * h_parallel / (2.0 * epsilon)\n        if np.abs(Pe)  1e-6:\n            coth_pe_minus_1_pe = Pe / 3.0\n        else:\n            coth_pe_minus_1_pe = coth(Pe) - 1.0 / Pe\n        tau = (h_parallel / (2.0 * b_norm)) * coth_pe_minus_1_pe\n        \n        # Crosswind diffusion coefficient\n        mu_perp = alpha_perp * b_norm * h_perp\n\n        # --- 2. FEM Discretization Setup ---\n        num_nodes_x = 2 * Nx + 1\n        num_nodes_y = 2 * Ny + 1\n        total_nodes = num_nodes_x * num_nodes_y\n\n        # 1D Q2 Lagrange basis functions and their derivatives\n        def l_vals(xi): return np.array([0.5 * xi * (xi - 1), 1 - xi**2, 0.5 * xi * (xi + 1)])\n        def l_derivs(xi): return np.array([xi - 0.5, -2 * xi, xi + 0.5])\n        def l_derivs2(xi): return np.array([1.0, -2.0, 1.0])\n\n        # 3-point Gaussian quadrature nodes and weights\n        gp_loc = np.array([-np.sqrt(3.0/5.0), 0.0, np.sqrt(3.0/5.0)])\n        gp_w = np.array([5.0/9.0, 8.0/9.0, 5.0/9.0])\n        \n        K = np.zeros((total_nodes, total_nodes))\n\n        # --- 3. Assemble Global Stiffness Matrix K ---\n        for ey in range(Ny):\n            for ex in range(Nx):\n                Ke = np.zeros((9, 9))\n                \n                # Element-to-global node mapping\n                local_to_global = np.array(\n                    [ (2*ey+dy) * num_nodes_x + (2*ex+dx) \n                      for dy in range(3) for dx in range(3) ], dtype=int\n                )\n\n                # Loop over Gauss points for numerical integration\n                d_vol_factor = (hx / 2.0) * (hy / 2.0)\n                for i_eta, eta in enumerate(gp_loc):\n                    for i_xi, xi in enumerate(gp_loc):\n                        weight = gp_w[i_eta] * gp_w[i_xi]\n                        d_vol = d_vol_factor * weight\n\n                        # Evaluate 1D basis functions at the current Gauss point\n                        vals_xi, d_vals_xi, d2_vals_xi = l_vals(xi), l_derivs(xi), l_derivs2(xi)\n                        vals_eta, d_vals_eta, d2_vals_eta = l_vals(eta), l_derivs(eta), l_derivs2(eta)\n                        \n                        N, grad_N, lap_N = np.zeros(9), np.zeros((9, 2)), np.zeros(9)\n                        for k in range(9):\n                            k_xi, k_eta = k % 3, k // 3\n                            N[k] = vals_xi[k_xi] * vals_eta[k_eta]\n                            grad_N[k, 0] = d_vals_xi[k_xi] * vals_eta[k_eta] * (2 / hx)\n                            grad_N[k, 1] = vals_xi[k_xi] * d_vals_eta[k_eta] * (2 / hy)\n                            lap_N[k] = (d2_vals_xi[k_xi] * vals_eta[k_eta] * (2 / hx)**2 +\n                                        vals_xi[k_xi] * d2_vals_eta[k_eta] * (2 / hy)**2)\n\n                        # Compute contributions to element stiffness matrix Ke\n                        for i in range(9):  # Test function index\n                            for j in range(9):  # Trial function index\n                                term_diff = epsilon * np.dot(grad_N[j], grad_N[i])\n                                term_adv = np.dot(b, grad_N[j]) * N[i]\n                                integrand = term_diff + term_adv\n                                \n                                if stabilization == 'SUPG':\n                                    term_supg = tau * np.dot(b, grad_N[j]) * np.dot(b, grad_N[i])\n                                    integrand += term_supg\n                                elif stabilization == 'GLS':\n                                    res_j = np.dot(b, grad_N[j]) - epsilon * lap_N[j]\n                                    res_i = np.dot(b, grad_N[i]) - epsilon * lap_N[i]\n                                    term_gls = tau * res_j * res_i\n                                    integrand += term_gls\n\n                                if alpha_perp > 0:\n                                    P_perp_g_j = grad_N[j] - np.dot(grad_N[j], b_hat) * b_hat\n                                    term_crosswind = mu_perp * np.dot(P_perp_g_j, grad_N[i])\n                                    integrand += term_crosswind\n                                \n                                Ke[i, j] += integrand * d_vol\n                \n                # Assemble local matrix into global matrix\n                K[np.ix_(local_to_global, local_to_global)] += Ke\n\n        # --- 4. Apply Boundary Conditions and Solve ---\n        dirichlet_dofs, interior_dofs = [], []\n        U = np.zeros(total_nodes)\n        for iy in range(num_nodes_y):\n            for ix in range(num_nodes_x):\n                g_idx = iy * num_nodes_x + ix\n                if ix == 0 or iy == 0:  # Inflow boundaries\n                    U[g_idx] = 1.0\n                    dirichlet_dofs.append(g_idx)\n                elif ix == num_nodes_x - 1 or iy == num_nodes_y - 1:  # Outflow boundaries\n                    U[g_idx] = 0.0\n                    dirichlet_dofs.append(g_idx)\n                else:\n                    interior_dofs.append(g_idx)\n        \n        F_interior = -K[np.ix_(interior_dofs, dirichlet_dofs)] @ U[dirichlet_dofs]\n        K_interior = K[np.ix_(interior_dofs, interior_dofs)]\n        \n        U_interior = np.linalg.solve(K_interior, F_interior)\n        U[interior_dofs] = U_interior\n\n        # --- 5. Post-Processing: Compute Metrics ---\n        # Metric 1: Crosswind Gradient Index (I_perp)\n        num_integral, den_integral = 0.0, 0.0\n        for ey in range(Ny):\n            for ex in range(Nx):\n                local_to_global = np.array(\n                    [ (2*ey+dy) * num_nodes_x + (2*ex+dx)\n                      for dy in range(3) for dx in range(3) ], dtype=int\n                )\n                U_local = U[local_to_global]\n\n                d_vol_factor = (hx / 2.0) * (hy / 2.0)\n                for i_eta, eta in enumerate(gp_loc):\n                    for i_xi, xi in enumerate(gp_loc):\n                        weight = gp_w[i_eta] * gp_w[i_xi]\n                        d_vol = d_vol_factor * weight\n                        \n                        vals_xi, d_vals_xi = l_vals(xi), l_derivs(xi)\n                        vals_eta, d_vals_eta = l_vals(eta), l_derivs(eta)\n                        \n                        grad_u = np.zeros(2)\n                        for k in range(9):\n                            k_xi, k_eta = k % 3, k // 3\n                            grad_u[0] += U_local[k] * (d_vals_xi[k_xi] * vals_eta[k_eta] * (2 / hx))\n                            grad_u[1] += U_local[k] * (vals_xi[k_xi] * d_vals_eta[k_eta] * (2 / hy))\n                        \n                        P_perp_grad_u = grad_u - np.dot(grad_u, b_hat) * b_hat\n                        num_integral += np.dot(P_perp_grad_u, P_perp_grad_u) * d_vol\n                        den_integral += np.dot(grad_u, grad_u) * d_vol\n        \n        I_perp = num_integral / den_integral if den_integral > 1e-12 else 0.0\n\n        # Metric 2: Overshoot/Undershoot Amplitude (A_osc)\n        U_interior_only = U[interior_dofs]\n        max_u = np.max(U_interior_only) if U_interior_only.size > 0 else 0.0\n        min_u = np.min(U_interior_only) if U_interior_only.size > 0 else 0.0\n        A_osc = max(0, max_u - 1.0) + max(0, -min_u)\n\n        return I_perp, A_osc\n\n    # Define test cases\n    test_cases = [\n        {'stabilization': 'SUPG', 'alpha_perp': 0.0},\n        {'stabilization': 'GLS', 'alpha_perp': 0.0},\n        {'stabilization': 'SUPG', 'alpha_perp': 0.05},\n        {'stabilization': 'GLS', 'alpha_perp': 0.05}\n    ]\n\n    results = []\n    for case in test_cases:\n        I_perp, A_osc = run_fem_solver(case['stabilization'], case['alpha_perp'])\n        results.extend([I_perp, A_osc])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3447460"}]}