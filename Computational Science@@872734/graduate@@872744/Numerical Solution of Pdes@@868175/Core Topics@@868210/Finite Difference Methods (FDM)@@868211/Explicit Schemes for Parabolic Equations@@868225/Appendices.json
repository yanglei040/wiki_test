{"hands_on_practices": [{"introduction": "Our journey into the practical aspects of explicit schemes begins with the foundational Forward-Time Centered-Space (FTCS) method. While simple to implement, its stability is paramount for producing physically meaningful results. This first practice [@problem_id:3389096] explores the critical link between the stability parameter $\\mu$ and the Discrete Maximum Principle, demonstrating through a sharp 'grid spike' initial condition how violating the stability bound leads to the creation of non-physical oscillations.", "problem": "Consider the one-dimensional heat equation (a parabolic Partial Differential Equation (PDE)) on a finite interval with homogeneous Dirichlet boundary conditions. Let the diffusivity be a positive constant denoted by $\\alpha>0$. Use a uniform spatial grid with $N$ nodes on the closed interval $[0,1]$ with spacing $h$, and an explicit forward Euler time discretization with time step $k$. Denote by $u_i^n$ the numerical approximation to the exact solution at spatial node $x_i$ and time level $t^n$. Define the dimensionless ratio $\\mu := \\alpha\\,k/h^2$. The initial condition is a single grid spike: all nodes are zero except one interior node which has value one. The boundaries remain at zero for all times.\n\nYour tasks are as follows:\n\n- Starting from the definition of the heat equation and the forward Euler method in time together with the standard centered finite-difference approximation of the second derivative in space, derive the explicit scheme on interior nodes and the associated discrete update coefficients in terms of $\\mu$.\n- Using the discrete scheme and only first principles, argue whether a single time step can create new extrema that were not present in the initial data, depending on the value of $\\mu$. A “new extremum” means that either the new minimum drops below the initial minimum or the new maximum rises above the initial maximum.\n- Implement the derived one-step explicit update numerically for the spike initial condition and homogeneous Dirichlet boundaries. For each parameter set in the test suite below, perform exactly a single time step and report whether a new extremum is created (output a boolean for each case).\n\nAssumptions and setup to be used in your code:\n\n- Spatial domain: $[0,1]$ with $N$ uniformly spaced nodes and spacing $h=1/(N-1)$.\n- Homogeneous Dirichlet boundary conditions: $u_0^n=0$ and $u_{N-1}^n=0$ for all $n$.\n- Initial data (single spike): $u_{i^\\star}^0=1$ at a chosen interior index $i^\\star$, and $u_i^0=0$ for all $i\\neq i^\\star$.\n- Use $\\alpha=1$ to instantiate $\\mu = k/h^2$ in your code; however, your implementation should update by a single step using $\\mu$ directly.\n\nDetection criterion for a new extremum after one step:\n\n- Let $\\min^0$ and $\\max^0$ denote the minimum and maximum over all grid nodes at the initial time.\n- Let $\\min^1$ and $\\max^1$ denote the minimum and maximum over all grid nodes after one explicit time step.\n- Output the boolean value $\\big(\\min^1\\min^0\\big)\\ \\lor\\ \\big(\\max^1\\max^0\\big)$.\n\nTest suite:\n\n- Use $N=11$ and $i^\\star=5$ for all cases. Use the following four values of $\\mu$:\n    - Case $1$: $\\mu=0$.\n    - Case $2$: $\\mu=0.49$.\n    - Case $3$: $\\mu=0.5$.\n    - Case $4$: $\\mu=0.51$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test suite (for example, $[\\text{False},\\text{True},\\text{False},\\text{True}]$). No physical units are required in the output since all quantities are dimensionless by construction. The only allowed output types are booleans as specified above.", "solution": "The problem is valid as it is scientifically grounded, well-posed, and objective. It addresses fundamental concepts in the numerical solution of partial differential equations using standard, verifiable methods.\n\nThe problem requires a three-part response: the derivation of a numerical scheme, a theoretical analysis of its properties, and a numerical implementation to verify the analysis.\n\n**1. Derivation of the Explicit Scheme**\n\nThe one-dimensional heat equation is a parabolic partial differential equation (PDE) given by:\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}\n$$\nwhere $u(x, t)$ is the temperature at position $x$ and time $t$, and $\\alpha > 0$ is the thermal diffusivity.\n\nWe discretize this equation on a uniform grid with spatial step size $h$ and time step size $k$. The approximation of the solution at grid point $(x_i, t^n)$ is denoted by $u_i^n$.\n\nThe time derivative $\\frac{\\partial u}{\\partial t}$ is approximated using a first-order forward difference (Forward Euler method):\n$$\n\\frac{\\partial u}{\\partial t} \\bigg|_{(x_i, t^n)} \\approx \\frac{u_i^{n+1} - u_i^n}{k}\n$$\n\nThe second spatial derivative $\\frac{\\partial^2 u}{\\partial x^2}$ is approximated using a second-order centered difference:\n$$\n\\frac{\\partial^2 u}{\\partial x^2} \\bigg|_{(x_i, t^n)} \\approx \\frac{u_{i-1}^n - 2u_i^n + u_{i+1}^n}{h^2}\n$$\n\nSubstituting these discrete approximations into the PDE yields the finite difference equation:\n$$\n\\frac{u_i^{n+1} - u_i^n}{k} = \\alpha \\left( \\frac{u_{i-1}^n - 2u_i^n + u_{i+1}^n}{h^2} \\right)\n$$\n\nTo find the update rule for $u_i^{n+1}$, we rearrange the terms:\n$$\nu_i^{n+1} = u_i^n + \\frac{\\alpha k}{h^2} \\left( u_{i-1}^n - 2u_i^n + u_{i+1}^n \\right)\n$$\n\nThe problem defines the dimensionless ratio $\\mu := \\alpha k / h^2$. Substituting $\\mu$ into the equation gives:\n$$\nu_i^{n+1} = u_i^n + \\mu (u_{i-1}^n - 2u_i^n + u_{i+1}^n)\n$$\n\nFinally, we group terms from the time level $n$ to obtain the explicit update scheme for any interior node $i$:\n$$\nu_i^{n+1} = \\mu u_{i-1}^n + (1 - 2\\mu) u_i^n + \\mu u_{i+1}^n\n$$\n\nThe discrete update coefficients for the stencil at time level $n$ are:\n-   Coefficient for $u_{i-1}^n$: $\\mu$\n-   Coefficient for $u_i^n$: $1 - 2\\mu$\n-   Coefficient for $u_{i+1}^n$: $\\mu$\n\n**2. Analysis of New Extrema Creation**\n\nA \"new extremum\" is created if, after one time step, the new minimum is less than the initial minimum ($\\min^1  \\min^0$) or the new maximum is greater than the initial maximum ($\\max^1  \\max^0$).\n\nThe update rule shows that $u_i^{n+1}$ is a linear combination of its neighboring values at the previous time step. For the scheme to not create new extrema, it must satisfy a discrete maximum principle. This is guaranteed if the update is a convex combination, which requires all coefficients to be non-negative. The sum of the coefficients is $\\mu + (1 - 2\\mu) + \\mu = 1$.\n\nThe conditions for the coefficients to be non-negative are:\n1.  $\\mu \\ge 0$: Since $\\alpha > 0$, $k \\ge 0$, and $h^2 > 0$, this condition is always met. The case $\\mu=0$ corresponds to $k=0$, where the solution does not evolve.\n2.  $1 - 2\\mu \\ge 0$: This implies $2\\mu \\le 1$, or $\\mu \\le 0.5$.\n\n**Case A: $0 \\le \\mu \\le 0.5$**\nIn this case, all coefficients in the update rule are non-negative. The value $u_i^{n+1}$ is a convex combination of $u_{i-1}^n$, $u_i^n$, and $u_{i+1}^n$. Therefore, its value is bounded by the minimum and maximum of these three values:\n$$\n\\min(u_{i-1}^n, u_i^n, u_{i+1}^n) \\le u_i^{n+1} \\le \\max(u_{i-1}^n, u_i^n, u_{i+1}^n)\n$$\nThis implies that for any interior node $i$, $\\min^n \\le u_i^{n+1} \\le \\max^n$. The homogeneous Dirichlet boundary conditions ensure $u_0^{n+1} = u_{N-1}^{n+1} = 0$. Given the initial condition where $\\min^0=0$ and $\\max^0=1$, the boundary values remain within this range.\nThus, for all nodes $i=0, \\dots, N-1$, we have $\\min^0 \\le u_i^1 \\le \\max^0$. This means $\\min^1 \\ge \\min^0$ and $\\max^1 \\le \\max^0$. No new extrema are created. The test criterion $(\\min^1  \\min^0) \\lor (\\max^1  \\max^0)$ will evaluate to **False**.\n\n**Case B: $\\mu  0.5$**\nIn this case, the coefficient $1 - 2\\mu$ is negative. The update is no longer a convex combination, and the discrete maximum principle is violated. Let's analyze the effect on the given spike initial condition: $u_{i^\\star}^0=1$ and $u_i^0=0$ for all $i \\neq i^\\star$. The initial extrema are $\\min^0=0$ and $\\max^0=1$.\n\nWe calculate the values at time $n=1$ for the nodes near the spike:\n-   For $i = i^\\star-1$: $u_{i^\\star-1}^1 = \\mu u_{i^\\star-2}^0 + (1-2\\mu)u_{i^\\star-1}^0 + \\mu u_{i^\\star}^0 = \\mu(0) + (1-2\\mu)(0) + \\mu(1) = \\mu$.\n-   For $i = i^\\star+1$: $u_{i^\\star+1}^1 = \\mu u_{i^\\star}^0 + (1-2\\mu)u_{i^\\star+1}^0 + \\mu u_{i^\\star+2}^0 = \\mu(1) + (1-2\\mu)(0) + \\mu(0) = \\mu$.\n-   For $i = i^\\star$: $u_{i^\\star}^1 = \\mu u_{i^\\star-1}^0 + (1-2\\mu)u_{i^\\star}^0 + \\mu u_{i^\\star+1}^0 = \\mu(0) + (1-2\\mu)(1) + \\mu(0) = 1 - 2\\mu$.\nAll other nodes $u_i^1$ will be $0$.\n\nSince $\\mu  0.5$, we have $2\\mu  1$, which means $u_{i^\\star}^1 = 1 - 2\\mu  0$.\nThe minimum value at time $n=1$ is $\\min^1 = \\min(0, \\mu, 1-2\\mu) = 1-2\\mu$.\nWe have $\\min^1  0$, while $\\min^0=0$. Therefore, $\\min^1  \\min^0$. A new minimum has been created, which is a physically unrealistic undershoot. The test criterion $(\\min^1  \\min^0) \\lor (\\max^1  \\max^0)$ evaluates to **True**.\n\nThe condition $\\mu \\le 0.5$ is the well-known CFL (Courant-Friedrichs-Lewy) stability condition for this explicit scheme.\n\n**3. Numerical Test Case Predictions**\n\n-   **Case 1 ($\\mu=0$):** $0 \\le 0.5$. Expect **False**.\n-   **Case 2 ($\\mu=0.49$):** $0.49 \\le 0.5$. Expect **False**.\n-   **Case 3 ($\\mu=0.5$):** $0.5 \\le 0.5$. This is the stability boundary. Expect **False**.\n-   **Case 4 ($\\mu=0.51$):** $0.51  0.5$. Scheme is unstable. Expect **True**.\n\nThe implementation will proceed based on this validated analysis.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of detecting new extrema in a one-step explicit finite\n    difference scheme for the 1D heat equation.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a value for the dimensionless ratio mu.\n    test_cases = [0.0, 0.49, 0.5, 0.51]\n\n    # Shared parameters for all test cases\n    N = 11      # Number of spatial grid nodes\n    i_star = 5  # Index of the initial spike\n\n    results = []\n    for mu in test_cases:\n        # Perform the one-step update for a single case.\n\n        # 1. Set up initial condition (u0)\n        # u^0 has a single spike at i_star and is zero everywhere else.\n        u0 = np.zeros(N, dtype=float)\n        u0[i_star] = 1.0\n\n        # Initial minimum and maximum are fixed by the problem description.\n        min0 = 0.0\n        max0 = 1.0\n\n        # 2. Compute the solution after one time step (u1)\n        # Initialize u1 to all zeros. The Dirichlet boundary conditions\n        # u1[0] = 0 and u1[N-1] = 0 are thus automatically satisfied.\n        u1 = np.zeros(N, dtype=float)\n\n        # Apply the explicit update rule for interior nodes (i=1 to N-2).\n        # u_i^{n+1} = mu*u_{i-1}^n + (1 - 2*mu)*u_i^n + mu*u_{i+1}^n\n        # A vectorized update is efficient and concise.\n        u1[1:-1] = mu * u0[:-2] + (1.0 - 2.0 * mu) * u0[1:-1] + mu * u0[2:]\n\n        # 3. Detect new extrema\n        # Find the minimum and maximum of the solution at the new time step.\n        min1 = np.min(u1)\n        max1 = np.max(u1)\n\n        # Apply the detection criterion given in the problem statement.\n        # A new extremum is created if the new min is below the old min,\n        # OR the new max is above the old max.\n        new_extremum_created = (min1  min0) or (max1  max0)\n        results.append(new_extremum_created)\n\n    # Final print statement in the exact required format.\n    # The format is a string representation of a Python list of booleans.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3389096"}, {"introduction": "Beyond stability, the accuracy of a numerical scheme is its most important characteristic, indicating how rapidly the error decreases as we refine the discretization. This practice [@problem_id:3389099] provides a framework for empirically verifying theoretical convergence rates through a refinement study, a fundamental skill in computational science. By using a problem setup that cleverly eliminates spatial discretization error, you will isolate and confirm the temporal accuracy of first, second, and fourth-order explicit methods.", "problem": "Consider the one-dimensional heat equation, a canonical parabolic partial differential equation, given by $u_t = \\alpha u_{xx}$ on the spatial interval $(0,1)$ with homogeneous Dirichlet boundary conditions $u(0,t) = 0$ and $u(1,t) = 0$, and smooth initial condition $u(x,0) = \\sin(\\pi x)$. By separation of variables and the eigenfunction structure of the spatial Laplacian under homogeneous Dirichlet boundary conditions, the solution remains a single mode for all $t \\ge 0$, and can be written as $u(x,t) = a(t)\\sin(\\pi x)$ where the modal amplitude $a(t)$ satisfies the linear ordinary differential equation (ODE) $a'(t) = -\\lambda a(t)$ with $\\lambda = \\alpha \\pi^2$ and $a(0) = 1$. The exact solution of this ODE is $a(t) = \\exp(-\\lambda t)$.\n\nThis reduction eliminates spatial discretization error for the single excited eigenmode, which is equivalent to taking the spatial resolution so fine that spatial error is negligible. In this setting, you are to design and implement an explicit-in-time refinement study that isolates temporal convergence. Your program must implement three explicit time-marching schemes applied to the scalar ODE $a'(t) = -\\lambda a(t)$:\n- First-order explicit forward Euler.\n- Second-order explicit midpoint Runge–Kutta.\n- Classical fourth-order explicit Runge–Kutta.\n\nFor each method, conduct a refinement study over a specified sequence of time steps $\\Delta t$ and a fixed final time $T$. For each $\\Delta t$ in the sequence, advance the numerical solution from $t=0$ to $t=T$ using exactly $N = T / \\Delta t$ steps (choose $T$ and $\\Delta t$ so that $N$ is an integer), then compute the absolute error $E(\\Delta t) = \\lvert a_{\\mathrm{num}}(T) - a_{\\mathrm{exact}}(T) \\rvert$ where $a_{\\mathrm{exact}}(T) = \\exp(-\\lambda T)$. Estimate the observed order $p$ between successive time steps $\\Delta t_1$ and $\\Delta t_2$ via the scaling relationship $E(\\Delta t) \\approx C (\\Delta t)^p$, by computing $p = \\log\\left(E(\\Delta t_1) / E(\\Delta t_2)\\right) \\big/ \\log\\left(\\Delta t_1 / \\Delta t_2\\right)$.\n\nFundamental base to be used:\n- The heat equation $u_t = \\alpha u_{xx}$ and its modal decomposition under homogeneous Dirichlet boundary conditions.\n- The resulting scalar ODE for the first eigenmode $a'(t) = -\\lambda a(t)$ with $\\lambda = \\alpha \\pi^2$, and its exact solution $a(t) = \\exp(-\\lambda t)$.\n- Definitions of the explicit forward Euler and explicit Runge–Kutta methods applied to ODEs.\n\nYou must implement the following test suite of parameter values to assess different facets of the refinement study. In all cases use $\\alpha = 1$, so $\\lambda = \\pi^2$:\n1. Happy path case for forward Euler:\n   - Method: forward Euler\n   - Final time: $T = 0.3$\n   - Time steps: $\\Delta t \\in \\{0.05, 0.025, 0.0125\\}$\n\n2. Happy path case for explicit midpoint Runge–Kutta (second order):\n   - Method: explicit midpoint Runge–Kutta\n   - Final time: $T = 1.0$\n   - Time steps: $\\Delta t \\in \\{0.2, 0.1, 0.05\\}$\n\n3. Happy path case for classical fourth-order Runge–Kutta:\n   - Method: classical fourth-order Runge–Kutta\n   - Final time: $T = 0.3$\n   - Time steps: $\\Delta t \\in \\{0.1, 0.05, 0.025\\}$\n\n4. Boundary-stability case near the edge of the stability region for forward Euler on the negative real axis:\n   - Method: forward Euler\n   - Final time: $T = 0.95$\n   - Time steps: $\\Delta t \\in \\{0.19, 0.095, 0.0475\\}$\n\nFor each test case, compute observed orders for the first pair and the second pair of successive time steps in the sequence (that is, from the first to second value, and from the second to third value). The program must return these observed orders as floating-point values.\n\nFinal output format requirement:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with the observed orders ordered by test case and by pair within each test case. Specifically, the output should be of the form\n$[\\text{p}_{1,1},\\text{p}_{1,2},\\text{p}_{2,1},\\text{p}_{2,2},\\text{p}_{3,1},\\text{p}_{3,2},\\text{p}_{4,1},\\text{p}_{4,2}]$\nwhere $\\text{p}_{j,k}$ denotes the observed order for test case $j$ and pair $k$. No physical units are involved, and all angles, if any, are not applicable here. The values in the list must be plain decimal numbers.", "solution": "The problem requires the implementation and analysis of a temporal refinement study for several explicit time-integration schemes applied to a model ordinary differential equation (ODE). This ODE arises from the modal decomposition of the one-dimensional heat equation, $u_t = \\alpha u_{xx}$, with homogeneous Dirichlet boundary conditions. The specific setup, using an initial condition $u(x,0) = \\sin(\\pi x)$ that excites only the first eigenmode, simplifies the partial differential equation (PDE) to an ODE for the time-dependent amplitude $a(t)$ of that mode. This procedure effectively isolates temporal discretization error from spatial discretization error.\n\nThe ODE governing the amplitude of the first mode is given as:\n$$\na'(t) = -\\lambda a(t)\n$$\nwith the initial condition $a(0) = 1$. The constant $\\lambda$ is the eigenvalue corresponding to the first eigenmode $\\sin(\\pi x)$, which is $\\lambda = \\alpha \\pi^2$. For all test cases, we use $\\alpha=1$, so $\\lambda = \\pi^2$.\n\nThe exact solution to this initial value problem is found by direct integration:\n$$\na_{\\mathrm{exact}}(t) = \\exp(-\\lambda t)\n$$\n\nThe core of the task is to numerically solve this ODE from $t=0$ to a final time $T$ using a fixed time step $\\Delta t$, and to study how the error at the final time behaves as $\\Delta t$ is refined. The number of steps for each simulation is $N = T / \\Delta t$.\n\nWe will implement three explicit numerical methods:\n\n1.  **First-Order Explicit Forward Euler:**\n    This is the simplest explicit method. The solution at step $n+1$ is advanced from step $n$ using the formula:\n    $$\n    a_{n+1} = a_n + \\Delta t \\cdot f(t_n, a_n)\n    $$\n    where $f(t_n, a_n) = -\\lambda a_n$. Substituting this into the formula gives the iterative map:\n    $$\n    a_{n+1} = a_n + \\Delta t (-\\lambda a_n) = (1 - \\lambda \\Delta t) a_n\n    $$\n\n2.  **Second-Order Explicit Midpoint Runge–Kutta (RK2):**\n    This method achieves second-order accuracy by using a predictor-corrector approach. It first evaluates the slope at the midpoint in time using the Euler-predicted value, and then uses this midpoint slope to take a full step.\n    The stages are:\n    $$\n    k_1 = f(t_n, a_n) = -\\lambda a_n\n    $$\n    $$\n    k_2 = f\\left(t_n + \\frac{\\Delta t}{2}, a_n + \\frac{\\Delta t}{2} k_1\\right) = -\\lambda \\left(a_n + \\frac{\\Delta t}{2} k_1\\right)\n    $$\n    The update rule is:\n    $$\n    a_{n+1} = a_n + \\Delta t \\cdot k_2\n    $$\n\n3.  **Classical Fourth-Order Explicit Runge–Kutta (RK4):**\n    This is a widely used method that provides fourth-order accuracy by using a weighted average of four slope estimates within the interval $\\Delta t$.\n    The four stages are:\n    $$\n    k_1 = f(t_n, a_n) = -\\lambda a_n\n    $$\n    $$\n    k_2 = f\\left(t_n + \\frac{\\Delta t}{2}, a_n + \\frac{\\Delta t}{2} k_1\\right) = -\\lambda \\left(a_n + \\frac{\\Delta t}{2} k_1\\right)\n    $$\n    $$\n    k_3 = f\\left(t_n + \\frac{\\Delta t}{2}, a_n + \\frac{\\Delta t}{2} k_2\\right) = -\\lambda \\left(a_n + \\frac{\\Delta t}{2} k_2\\right)\n    $$\n    $$\n    k_4 = f(t_n + \\Delta t, a_n + \\Delta t k_3) = -\\lambda (a_n + \\Delta t k_3)\n    $$\n    The final update is a weighted average of these slopes:\n    $$\n    a_{n+1} = a_n + \\frac{\\Delta t}{6} (k_1 + 2k_2 + 2k_3 + k_4)\n    $$\n\nFor each test case, a refinement study is conducted. This involves the following steps:\n1.  For a given method, final time $T$, and a sequence of decreasing time steps $(\\Delta t_1, \\Delta t_2, \\ldots)$, numerically integrate the ODE from $a(0)=1$ to obtain the numerical solution $a_{\\mathrm{num}}(T)$ for each $\\Delta t_i$.\n2.  Calculate the exact solution at the final time, $a_{\\mathrm{exact}}(T) = \\exp(-\\lambda T)$.\n3.  Compute the absolute error for each simulation: $E(\\Delta t_i) = |a_{\\mathrm{num}}(T) - a_{\\mathrm{exact}}(T)|$.\n4.  The theoretical convergence of a method of order $p$ implies that the error behaves as $E(\\Delta t) \\approx C (\\Delta t)^p$ for sufficiently small $\\Delta t$. From two simulations with time steps $\\Delta t_1$ and $\\Delta t_2$, the observed order of convergence, $p$, can be estimated using the formula:\n    $$\n    p = \\frac{\\log\\left(E(\\Delta t_1) / E(\\Delta t_2)\\right)}{\\log\\left(\\Delta t_1 / \\Delta t_2\\right)}\n    $$\n\nThe program will execute this procedure for each of the four specified test cases, calculating two observed orders for each case (from the first and second pairs of successive time steps), and will output these eight values in the prescribed format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the refinement study across all specified test cases.\n    \"\"\"\n\n    def solve_ode(method: str, T: float, dt: float, lambda_val: float) - float:\n        \"\"\"\n        Solves the ODE a'(t) = -lambda * a(t) from t=0 to T with time step dt.\n\n        Args:\n            method: The name of the numerical scheme ('forward_euler', 'rk2', 'rk4').\n            T: The final integration time.\n            dt: The time step size.\n            lambda_val: The coefficient lambda in the ODE.\n\n        Returns:\n            The numerical solution a_num(T).\n        \"\"\"\n        # Ensure the number of steps is an integer, as per problem statement.\n        # Use round to handle potential floating point inaccuracies.\n        N = int(round(T / dt))\n        a_n = 1.0  # Initial condition a(0) = 1\n\n        if method == \"forward_euler\":\n            for _ in range(N):\n                a_n = a_n + dt * (-lambda_val * a_n)\n        elif method == \"rk2\":\n            for _ in range(N):\n                k1 = -lambda_val * a_n\n                k2 = -lambda_val * (a_n + dt / 2.0 * k1)\n                a_n = a_n + dt * k2\n        elif method == \"rk4\":\n            for _ in range(N):\n                k1 = -lambda_val * a_n\n                k2 = -lambda_val * (a_n + dt / 2.0 * k1)\n                k3 = -lambda_val * (a_n + dt / 2.0 * k2)\n                k4 = -lambda_val * (a_n + dt * k3)\n                a_n = a_n + dt / 6.0 * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n        \n        return a_n\n\n    # Map problem statement method names to internal function identifiers.\n    method_map = {\n        \"forward Euler\": \"forward_euler\",\n        \"explicit midpoint Runge–Kutta\": \"rk2\",\n        \"classical fourth-order Runge–Kutta\": \"rk4\"\n    }\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\"method\": \"forward Euler\", \"T\": 0.3, \"dts\": [0.05, 0.025, 0.0125]},\n        {\"method\": \"explicit midpoint Runge–Kutta\", \"T\": 1.0, \"dts\": [0.2, 0.1, 0.05]},\n        {\"method\": \"classical fourth-order Runge–Kutta\", \"T\": 0.3, \"dts\": [0.1, 0.05, 0.025]},\n        {\"method\": \"forward Euler\", \"T\": 0.95, \"dts\": [0.19, 0.095, 0.0475]}\n    ]\n\n    # Global parameter alpha and derived lambda\n    alpha = 1.0\n    lambda_val = alpha * np.pi**2\n\n    all_orders = []\n\n    for case in test_cases:\n        T = case[\"T\"]\n        dts = case[\"dts\"]\n        method_str = case[\"method\"]\n        method_id = method_map[method_str]\n\n        # Calculate exact solution at final time T\n        a_exact_T = np.exp(-lambda_val * T)\n        \n        # Calculate numerical solution and error for each time step\n        errors = []\n        for dt in dts:\n            a_num_T = solve_ode(method_id, T, dt, lambda_val)\n            error = np.abs(a_num_T - a_exact_T)\n            errors.append(error)\n\n        # Calculate observed convergence orders\n        # p = log(E1/E2) / log(dt1/dt2)\n        \n        # Order for the first pair of time steps (dt_1, dt_2)\n        dt_ratio_1 = dts[0] / dts[1]\n        order1 = np.log(errors[0] / errors[1]) / np.log(dt_ratio_1)\n        all_orders.append(order1)\n        \n        # Order for the second pair of time steps (dt_2, dt_3)\n        dt_ratio_2 = dts[1] / dts[2]\n        order2 = np.log(errors[1] / errors[2]) / np.log(dt_ratio_2)\n        all_orders.append(order2)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{order:.7f}' for order in all_orders)}]\")\n\nsolve()\n```", "id": "3389099"}, {"introduction": "Having explored stability in one dimension and the verification of temporal accuracy, we now turn to a more complex scenario. Physical processes often occur in multiple dimensions with material properties that vary by direction, a phenomenon known as anisotropy. This practice [@problem_id:3389038] challenges you to extend stability analysis to the two-dimensional anisotropic heat equation, deriving the maximum stable time step that respects the Discrete Maximum Principle on a rectangular grid.", "problem": "Consider the two-dimensional parabolic partial differential equation $u_t = \\nabla \\cdot (K \\nabla u)$ posed on a rectangular domain, where $K$ is a constant, symmetric, positive-definite diffusion tensor. To construct a specific anisotropy and grid orientation free of mixed derivative contributions while still imposing a strict constraint on the explicit time step through the discrete maximum principle (DMP), take $K$ aligned with the coordinate axes, $K = \\mathrm{diag}(\\kappa_x,\\kappa_y)$, with anisotropic entries $\\kappa_x = 7.5$ and $\\kappa_y = 0.3$. Let the grid be a uniform rectangular grid oriented along the $x$ and $y$ axes, with spacings $h_x = 0.02$ and $h_y = 0.015$. Discretize in space with second-order central differences on the five-point stencil and in time with the forward Euler method. The DMP requires that the explicit update at each grid point be a convex combination of the current and neighboring values, which is enforced by nonnegative update weights. Compute the largest allowable time step $\\Delta t_{\\max}$ such that all update weights are nonnegative for this discretization and data, thereby demonstrating that any $\\Delta t  \\Delta t_{\\max}$ breaks the DMP by yielding a negative weight. Report $\\Delta t_{\\max}$ as a dimensionless number rounded to four significant figures.", "solution": "The problem is first validated to ensure it is self-contained, scientifically grounded, and well-posed.\n\n### Step 1: Extract Givens\n-   **Partial Differential Equation (PDE):** $u_t = \\nabla \\cdot (K \\nabla u)$ on a rectangular domain.\n-   **Diffusion Tensor ($K$):** Constant, symmetric, positive-definite. Specifically, $K$ is diagonal, $K = \\mathrm{diag}(\\kappa_x, \\kappa_y)$.\n-   **Tensor Components:** $\\kappa_x = 7.5$ and $\\kappa_y = 0.3$.\n-   **Grid:** Uniform rectangular grid aligned with the $x$ and $y$ axes.\n-   **Grid Spacings:** $h_x = 0.02$ and $h_y = 0.015$.\n-   **Spatial Discretization:** Second-order central differences on a five-point stencil.\n-   **Time Discretization:** Forward Euler method.\n-   **Constraint:** The Discrete Maximum Principle (DMP) must hold, which is enforced by the condition that all update weights in the explicit scheme are nonnegative.\n-   **Objective:** Compute the largest allowable time step, $\\Delta t_{\\max}$, rounded to four significant figures.\n\n### Step 2: Validate Using Extracted Givens\n-   **Scientifically Grounded:** The problem describes the Forward-Time Centered-Space (FTCS) discretization of the anisotropic heat/diffusion equation. The stability condition derived from the Discrete Maximum Principle is a standard and fundamental concept in the numerical analysis of parabolic PDEs. The problem is scientifically and mathematically sound.\n-   **Well-Posed:** All parameters ($\\kappa_x, \\kappa_y, h_x, h_y$) are provided, and the discretization scheme is explicitly defined. The condition for the DMP leads to a well-defined inequality from which a unique maximum time step $\\Delta t_{\\max}$ can be determined.\n-   **Objective:** The problem is stated using precise, standard terminology from numerical analysis. There are no subjective or ambiguous statements.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. It is a well-defined problem in numerical analysis. The solution process may proceed.\n\n### Solution Derivation\nThe given parabolic partial differential equation is $u_t = \\nabla \\cdot (K \\nabla u)$. With the diagonal diffusion tensor $K = \\mathrm{diag}(\\kappa_x, \\kappa_y)$ where $\\kappa_x$ and $\\kappa_y$ are constants, the equation expands to:\n$$\nu_t = \\frac{\\partial}{\\partial x}\\left(\\kappa_x \\frac{\\partial u}{\\partial x}\\right) + \\frac{\\partial}{\\partial y}\\left(\\kappa_y \\frac{\\partial u}{\\partial y}\\right) = \\kappa_x \\frac{\\partial^2 u}{\\partial x^2} + \\kappa_y \\frac{\\partial^2 u}{\\partial y^2}\n$$\n\nLet $u_{i,j}^n$ be the numerical approximation of the solution $u$ at the grid point $(x_i, y_j) = (i h_x, j h_y)$ and time $t_n = n \\Delta t$.\n\nWe discretize the PDE using the specified methods.\nThe time derivative $u_t$ is approximated using the forward Euler method:\n$$\nu_t \\approx \\frac{u_{i,j}^{n+1} - u_{i,j}^n}{\\Delta t}\n$$\nThe spatial second derivatives are approximated using second-order central differences:\n$$\n\\frac{\\partial^2 u}{\\partial x^2} \\approx \\frac{u_{i+1,j}^n - 2u_{i,j}^n + u_{i-1,j}^n}{h_x^2}\n$$\n$$\n\\frac{\\partial^2 u}{\\partial y^2} \\approx \\frac{u_{i,j+1}^n - 2u_{i,j}^n + u_{i,j-1}^n}{h_y^2}\n$$\nSubstituting these approximations into the PDE yields the FTCS (Forward-Time, Centered-Space) scheme:\n$$\n\\frac{u_{i,j}^{n+1} - u_{i,j}^n}{\\Delta t} = \\kappa_x \\left( \\frac{u_{i+1,j}^n - 2u_{i,j}^n + u_{i-1,j}^n}{h_x^2} \\right) + \\kappa_y \\left( \\frac{u_{i,j+1}^n - 2u_{i,j}^n + u_{i,j-1}^n}{h_y^2} \\right)\n$$\nTo find the update weights, we solve for $u_{i,j}^{n+1}$:\n$$\nu_{i,j}^{n+1} = u_{i,j}^n + \\Delta t \\left[ \\kappa_x \\left( \\frac{u_{i+1,j}^n - 2u_{i,j}^n + u_{i-1,j}^n}{h_x^2} \\right) + \\kappa_y \\left( \\frac{u_{i,j+1}^n - 2u_{i,j}^n + u_{i,j-1}^n}{h_y^2} \\right) \\right]\n$$\nLet us define the dimensionless mesh Fourier numbers (or CFL-like numbers) for each direction:\n$$\nr_x = \\frac{\\kappa_x \\Delta t}{h_x^2} \\quad \\text{and} \\quad r_y = \\frac{\\kappa_y \\Delta t}{h_y^2}\n$$\nSubstituting these into the scheme and grouping terms by their spatial location at time level $n$:\n$$\nu_{i,j}^{n+1} = u_{i,j}^n + r_x(u_{i+1,j}^n - 2u_{i,j}^n + u_{i-1,j}^n) + r_y(u_{i,j+1}^n - 2u_{i,j}^n + u_{i,j-1}^n)\n$$\n$$\nu_{i,j}^{n+1} = (1 - 2r_x - 2r_y)u_{i,j}^n + r_x u_{i+1,j}^n + r_x u_{i-1,j}^n + r_y u_{i,j+1}^n + r_y u_{i,j-1}^n\n$$\nThe value at the new time step, $u_{i,j}^{n+1}$, is a linear combination of the values at the current time step from the five-point stencil. The coefficients (weights) are:\n-   Weight of the central node $u_{i,j}^n$: $w_C = 1 - 2r_x - 2r_y$\n-   Weights of the $x$-neighbor nodes $u_{i\\pm 1,j}^n$: $w_{E,W} = r_x$\n-   Weights of the $y$-neighbor nodes $u_{i,j\\pm 1}^n$: $w_{N,S} = r_y$\n\nThe Discrete Maximum Principle (DMP) requires that the numerical solution at any point $(i,j)$ at time $n+1$ is bounded by the minimum and maximum of the solution values at time $n$ over the computational domain. For this explicit scheme, a sufficient condition to satisfy the DMP is that the update is a convex combination, which means all aformentioned weights must be nonnegative.\n\nSince $\\kappa_x, \\kappa_y, \\Delta t, h_x, h_y$ are all positive, the weights $r_x$ and $r_y$ are inherently nonnegative. The only nontrivial constraint comes from the weight of the central node:\n$$\nw_C = 1 - 2r_x - 2r_y \\ge 0\n$$\nSubstituting the definitions of $r_x$ and $r_y$:\n$$\n1 - 2\\left(\\frac{\\kappa_x \\Delta t}{h_x^2}\\right) - 2\\left(\\frac{\\kappa_y \\Delta t}{h_y^2}\\right) \\ge 0\n$$\nWe can solve this inequality for $\\Delta t$:\n$$\n1 \\ge 2\\Delta t \\left(\\frac{\\kappa_x}{h_x^2} + \\frac{\\kappa_y}{h_y^2}\\right)\n$$\n$$\n\\Delta t \\le \\frac{1}{2 \\left(\\frac{\\kappa_x}{h_x^2} + \\frac{\\kappa_y}{h_y^2}\\right)}\n$$\nThe largest allowable time step, $\\Delta t_{\\max}$, corresponds to the equality:\n$$\n\\Delta t_{\\max} = \\frac{1}{2 \\left(\\frac{\\kappa_x}{h_x^2} + \\frac{\\kappa_y}{h_y^2}\\right)}\n$$\nAny time step $\\Delta t  \\Delta t_{\\max}$ would result in $w_C  0$, violating the nonnegativity of weights and thus breaking the DMP.\n\nNow, we substitute the given numerical values: $\\kappa_x = 7.5$, $\\kappa_y = 0.3$, $h_x = 0.02$, and $h_y = 0.015$.\nFirst, compute the terms in the denominator:\n$$\n\\frac{\\kappa_x}{h_x^2} = \\frac{7.5}{(0.02)^2} = \\frac{7.5}{0.0004} = 18750\n$$\n$$\n\\frac{\\kappa_y}{h_y^2} = \\frac{0.3}{(0.015)^2} = \\frac{0.3}{0.000225} = \\frac{3000}{2.25} = \\frac{4000}{3} \\approx 1333.33...\n$$\nNow, calculate the sum of these terms:\n$$\n\\frac{\\kappa_x}{h_x^2} + \\frac{\\kappa_y}{h_y^2} = 18750 + \\frac{4000}{3} = \\frac{56250}{3} + \\frac{4000}{3} = \\frac{60250}{3}\n$$\nFinally, compute $\\Delta t_{\\max}$:\n$$\n\\Delta t_{\\max} = \\frac{1}{2 \\left(\\frac{60250}{3}\\right)} = \\frac{1}{\\frac{120500}{3}} = \\frac{3}{120500}\n$$\nTo obtain the numerical value, we perform the division:\n$$\n\\Delta t_{\\max} = 0.00002489626556...\n$$\nThe problem requires this value to be rounded to four significant figures. The first four significant figures are $2$, $4$, $8$, and $9$. The fifth significant figure is $6$. Since $6 \\ge 5$, we round up the fourth figure. Rounding $9$ up results in $0$ and a carry-over, so $2489$ becomes $2490$.\nThus, $\\Delta t_{\\max} \\approx 0.00002490$. In scientific notation, this is $2.490 \\times 10^{-5}$.", "answer": "$$\n\\boxed{2.490 \\times 10^{-5}}\n$$", "id": "3389038"}]}