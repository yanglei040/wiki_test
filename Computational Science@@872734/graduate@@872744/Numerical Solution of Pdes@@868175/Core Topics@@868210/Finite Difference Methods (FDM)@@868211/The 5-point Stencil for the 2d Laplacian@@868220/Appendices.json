{"hands_on_practices": [{"introduction": "The theoretical derivation of the 5-point stencil suggests it is second-order accurate, but how can we confirm this in practice? This exercise introduces the concept of a numerical convergence study by measuring the local truncation errorâ€”the difference between the discrete and continuous Laplacian. By applying the stencil to known smooth functions and observing how the error changes with grid spacing $h$, you will empirically verify the stencil's $O(h^2)$ behavior, a fundamental skill in code verification [@problem_id:2406729].", "problem": "Write a complete, runnable program that, for smooth functions in two spatial dimensions, analyzes the local truncation error of the standard $5$-point stencil approximation to the two-dimensional Laplace operator as a function of the grid spacing $h$, and confirms that it is of order $O(h^2)$. Use the following precise mathematical definitions.\n\nFor a smooth function $u:\\mathbb{R}^2 \\to \\mathbb{R}$ and grid spacing $h>0$, define the discrete $5$-point stencil approximation to the Laplacian at a point $(x,y)$ by\n$$\n\\Delta_h u(x,y) \\;=\\; \\frac{u(x+h,y)+u(x-h,y)+u(x,y+h)+u(x,y-h)-4\\,u(x,y)}{h^2}.\n$$\nDefine the local truncation error $\\tau_h$ at $(x_0,y_0)$ by\n$$\n\\tau_h(x_0,y_0) \\;=\\; \\Delta_h u(x_0,y_0)\\;-\\;\\Delta u(x_0,y_0),\n$$\nwhere $\\Delta u \\equiv u_{xx}+u_{yy}$ is the continuous Laplace operator. All angles appearing in trigonometric functions must be interpreted in radians.\n\nYour program must evaluate $\\tau_h$ numerically according to the definition above and, based solely on those evaluations at specified $h$ values, produce quantitative evidence of the scaling $\\tau_h=O(h^2)$ in the form of real numbers as specified in the test suite below.\n\nTest suite to implement exactly:\n- Case $1$ (general smooth trigonometric): $u_1(x,y)=\\sin(x)\\cos(y)$, point $(x_0,y_0)=(0.3,-0.2)$, spacings $h_k=2^{-k}$ for $k\\in\\{1,2,3,4,5,6\\}$. Output a single real number $p_1$ representing the observed convergence order in $h$ inferred from the data $\\{(h_k,\\lvert \\tau_{h_k}(x_0,y_0)\\rvert)\\}$.\n- Case $2$ (general smooth exponential): $u_2(x,y)=\\exp(x+2y)$, point $(x_0,y_0)=(-0.7,0.4)$, spacings $h_k=2^{-k}$ for $k\\in\\{1,2,3,4,5,6\\}$. Output a single real number $p_2$ representing the observed convergence order in $h$ inferred from the data $\\{(h_k,\\lvert \\tau_{h_k}(x_0,y_0)\\rvert)\\}$.\n- Case $3$ (edge case with a quartic polynomial): $u_3(x,y)=x^4+y^4$, point $(x_0,y_0)=(0.5,-0.5)$, spacing $h=2^{-3}$. Output a single real number $c_3$ equal to the ratio $\\lvert \\tau_h(x_0,y_0)\\rvert/h^2$.\n\nYour program must produce as its final output a single line containing a Python list literal with three real numbers $[p_1,p_2,c_3]$, where $p_1$ and $p_2$ quantify the observed order of accuracy and $c_3$ quantifies the leading-order coefficient in Case $3$. All three real numbers must be rounded to exactly three digits after the decimal point. No physical units are involved in the answer, and all angles must be in radians. The final line format must be exactly one line of the form $[p_1,p_2,c_3]$ with comma separation and no additional text.", "solution": "The problem statement is subjected to validation and is found to be valid. It is scientifically grounded, well-posed, and objective. It presents a standard problem in the numerical analysis of partial differential equations, with all necessary data and definitions provided. The task is to analyze the local truncation error of the 5-point finite difference stencil for the two-dimensional Laplacian, a fundamental concept in computational physics.\n\nThe analysis begins with the Taylor series expansion of a sufficiently smooth function $u(x,y)$ around a point $(x,y)$. The expansions in the $x$-direction are:\n$$\nu(x+h, y) = u + h u_x + \\frac{h^2}{2!} u_{xx} + \\frac{h^3}{3!} u_{xxx} + \\frac{h^4}{4!} u_{xxxx} + O(h^5)\n$$\n$$\nu(x-h, y) = u - h u_x + \\frac{h^2}{2!} u_{xx} - \\frac{h^3}{3!} u_{xxx} + \\frac{h^4}{4!} u_{xxxx} - O(h^5)\n$$\nwhere all partial derivatives are evaluated at $(x,y)$. Summing these two expressions cancels the odd-order derivative terms:\n$$\nu(x+h,y) + u(x-h,y) = 2u + h^2 u_{xx} + \\frac{h^4}{12} u_{xxxx} + O(h^6)\n$$\nAn analogous expression holds for the expansions in the $y$-direction:\n$$\nu(x,y+h) + u(x,y-h) = 2u + h^2 u_{yy} + \\frac{h^4}{12} u_{yyyy} + O(h^6)\n$$\nThe discrete Laplacian operator $\\Delta_h u(x,y)$ is defined as:\n$$\n\\Delta_h u(x,y) = \\frac{u(x+h,y)+u(x-h,y)+u(x,y+h)+u(x,y-h)-4u(x,y)}{h^2}\n$$\nSubstituting the Taylor series sums into this definition yields:\n$$\n\\Delta_h u(x,y) = \\frac{(2u + h^2 u_{xx} + \\frac{h^4}{12} u_{xxxx}) + (2u + h^2 u_{yy} + \\frac{h^4}{12} u_{yyyy}) - 4u + O(h^6)}{h^2}\n$$\n$$\n\\Delta_h u(x,y) = \\frac{h^2(u_{xx} + u_{yy}) + \\frac{h^4}{12}(u_{xxxx} + u_{yyyy}) + O(h^6)}{h^2}\n$$\n$$\n\\Delta_h u(x,y) = (u_{xx} + u_{yy}) + \\frac{h^2}{12}(u_{xxxx} + u_{yyyy}) + O(h^4)\n$$\nThe continuous Laplacian is $\\Delta u = u_{xx} + u_{yy}$. The local truncation error $\\tau_h$ is the difference between the discrete and continuous operators:\n$$\n\\tau_h(x,y) = \\Delta_h u(x,y) - \\Delta u(x,y) = \\frac{h^2}{12}(u_{xxxx} + u_{yyyy}) + O(h^4)\n$$\nThis derivation rigorously shows that the leading term of the error is proportional to $h^2$, and thus $\\tau_h = O(h^2)$. For small $h$, the magnitude of the error can be approximated as $|\\tau_h| \\approx C h^p$, where $p$ is the order of convergence. To find $p$ from numerical data, we take the natural logarithm:\n$$\n\\ln(|\\tau_h|) \\approx \\ln(C) + p \\ln(h)\n$$\nThis reveals a linear relationship between $\\ln(|\\tau_h|)$ and $\\ln(h)$, where the slope is the order of convergence $p$. We can therefore compute $p$ by performing a linear least-squares regression on the data points $(\\ln(h_k), \\ln(|\\tau_{h_k}|))$.\n\nThe problem requires implementation of this analysis for three specific cases.\n\nFor Case $1$ and Case $2$, we must find the observed order of convergence, $p_1$ and $p_2$. For each case, the test function $u(x,y)$ and its analytical Laplacian $\\Delta u(x,y)$ are defined. We compute $\\tau_{h_k}$ for a sequence of grid spacings $h_k = 2^{-k}$. Then, we compute the slope of the line of best fit for $\\ln(|\\tau_{h_k}|)$ versus $\\ln(h_k)$ using `numpy.polyfit` to determine the order $p$.\n- For $u_1(x,y) = \\sin(x)\\cos(y)$, the continuous Laplacian is $\\Delta u_1 = -\\sin(x)\\cos(y) - \\sin(x)\\cos(y) = -2\\sin(x)\\cos(y)$.\n- For $u_2(x,y) = \\exp(x+2y)$, the continuous Laplacian is $\\Delta u_2 = \\exp(x+2y) + 4\\exp(x+2y) = 5\\exp(x+2y)$.\n\nFor Case $3$, the function is a quartic polynomial, $u_3(x,y)=x^4+y^4$. For such a function, all partial derivatives of order higher than four are identically zero. The Taylor series expansion becomes exact, and the $O(h^4)$ term in the expression for $\\tau_h$ vanishes.\nThe fourth derivatives are $u_{xxxx} = 24$ and $u_{yyyy} = 24$. Therefore, the truncation error is given exactly by the leading term:\n$$\n\\tau_h(x,y) = \\frac{h^2}{12}(u_{xxxx} + u_{yyyy}) = \\frac{h^2}{12}(24 + 24) = 4h^2\n$$\nThis result is independent of the point $(x,y)$. The problem asks for the ratio $c_3 = |\\tau_h(x_0,y_0)|/h^2$ for a specific $h$. Based on the analytical derivation, this ratio must be exactly $4$. The program will compute this value numerically to confirm the theoretical result. The continuous Laplacian required for the numerical computation of $\\tau_h$ is $\\Delta u_3 = 12x^2 + 12y^2$.\n\nThe final program will implement these calculations, round the resulting numbers $p_1, p_2, c_3$ to three decimal places, and present them in the specified list format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the order of convergence and error coefficients for the 5-point\n    stencil approximation of the 2D Laplacian.\n    \"\"\"\n\n    # === Case 1: u(x,y) = sin(x)cos(y) ===\n    def u1(x, y):\n        return np.sin(x) * np.cos(y)\n\n    def delta_u1(x, y):\n        # u_xx = -sin(x)cos(y), u_yy = -sin(x)cos(y)\n        return -2.0 * np.sin(x) * np.cos(y)\n\n    # === Case 2: u(x,y) = exp(x+2y) ===\n    def u2(x, y):\n        return np.exp(x + 2.0 * y)\n    \n    def delta_u2(x, y):\n        # u_xx = exp(x+2y), u_yy = 4*exp(x+2y)\n        return 5.0 * np.exp(x + 2.0 * y)\n\n    # === Case 3: u(x,y) = x^4 + y^4 ===\n    def u3(x, y):\n        return x**4 + y**4\n\n    def delta_u3(x, y):\n        # u_xx = 12x^2, u_yy = 12y^2\n        return 12.0 * (x**2 + y**2)\n\n    def discrete_laplacian(u_func, x, y, h):\n        \"\"\"Computes the 5-point stencil discrete Laplacian.\"\"\"\n        u_iph = u_func(x + h, y)\n        u_imh = u_func(x - h, y)\n        u_jph = u_func(x, y + h)\n        u_jmh = u_func(x, y - h)\n        u_ij = u_func(x, y)\n        return (u_iph + u_imh + u_jph + u_jmh - 4.0 * u_ij) / h**2\n\n    def get_convergence_order(u_func, delta_u_func, x0, y0, h_values):\n        \"\"\"\n        Calculates the convergence order by performing a linear fit on\n        the log-log plot of truncation error vs. grid spacing.\n        \"\"\"\n        errors = []\n        for h in h_values:\n            delta_h_u = discrete_laplacian(u_func, x0, y0, h)\n            analytic_delta_u = delta_u_func(x0, y0)\n            tau_h = delta_h_u - analytic_delta_u\n            errors.append(np.abs(tau_h))\n        \n        log_h = np.log(h_values)\n        log_error = np.log(errors)\n        \n        # Fit a line: log_error = p * log_h + C\n        # The slope p is the order of convergence.\n        p, _ = np.polyfit(log_h, log_error, 1)\n        return p\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"id\": 1,\n            \"u_func\": u1,\n            \"delta_u_func\": delta_u1,\n            \"point\": (0.3, -0.2),\n            \"h_k_range\": range(1, 7)\n        },\n        {\n            \"id\": 2,\n            \"u_func\": u2,\n            \"delta_u_func\": delta_u2,\n            \"point\": (-0.7, 0.4),\n            \"h_k_range\": range(1, 7)\n        },\n        {\n            \"id\": 3,\n            \"u_func\": u3,\n            \"delta_u_func\": delta_u3,\n            \"point\": (0.5, -0.5),\n            \"h\": 2.0**(-3)\n        },\n    ]\n\n    results = []\n    \n    # Process Case 1\n    case1 = test_cases[0]\n    x0_1, y0_1 = case1[\"point\"]\n    h_values_1 = [2.0**(-k) for k in case1[\"h_k_range\"]]\n    p1 = get_convergence_order(case1[\"u_func\"], case1[\"delta_u_func\"], x0_1, y0_1, h_values_1)\n    \n    # Process Case 2\n    case2 = test_cases[1]\n    x0_2, y0_2 = case2[\"point\"]\n    h_values_2 = [2.0**(-k) for k in case2[\"h_k_range\"]]\n    p2 = get_convergence_order(case2[\"u_func\"], case2[\"delta_u_func\"], x0_2, y0_2, h_values_2)\n\n    # Process Case 3\n    case3 = test_cases[2]\n    x0_3, y0_3 = case3[\"point\"]\n    h_3 = case3[\"h\"]\n    delta_h_u3 = discrete_laplacian(case3[\"u_func\"], x0_3, y0_3, h_3)\n    analytic_delta_u3 = case3[\"delta_u_func\"](x0_3, y0_3)\n    tau_h3 = delta_h_u3 - analytic_delta_u3\n    c3 = np.abs(tau_h3) / h_3**2\n    \n    # Final print statement in the exact required format.\n    print(f\"[{p1:.3f},{p2:.3f},{c3:.3f}]\")\n\nsolve()\n```", "id": "2406729"}, {"introduction": "The guarantees of accuracy for finite difference methods rely on the underlying function being sufficiently smooth. This practice explores what happens when that assumption is violated, a common scenario in problems involving shocks or material interfaces. By applying the 5-point stencil to functions with a jump discontinuity and a sharp kink, you will investigate how the stencil behaves near singularities and numerically confirm the scaling of the error, providing crucial insight into the method's limitations [@problem_id:3230782].", "problem": "You will write a complete, runnable program that investigates the numerical behavior of the five-point Laplacian stencil on a uniform Cartesian grid when the underlying scalar field $u(x,y)$ has a discontinuity or a sharp kink, and contrast this with a smooth baseline. The analysis must be grounded in the definition of the Laplacian operator and the use of second-order central differences on a uniform grid.\n\nFundamental base: The continuous Laplacian is defined by $\\Delta u = u_{xx} + u_{yy}$. On a uniform grid covering a rectangular domain, second-order central differences approximate second partial derivatives using neighboring grid values. Use these approximations to construct the discrete operator $\\Delta_h$ that acts on grid samples of $u$.\n\nDomain and grid:\n- Consider the square domain $[0,1] \\times [0,1]$.\n- Use a uniform grid of $N \\times N$ nodes with grid spacing $h = \\frac{1}{N-1}$.\n- Let $(x_i, y_j)$ denote the coordinates of the grid nodes, where $x_i = i h$ and $y_j = j h$ for integers $i,j \\in \\{0,1,\\dots,N-1\\}$.\n- Apply Dirichlet boundary values taken from the analytic definition of $u(x,y)$; that is, the boundary grid nodes must be assigned $u$ according to the same function used for the interior nodes.\n\nDiscrete operator:\n- Construct the discrete Laplacian $\\Delta_h$ on the interior grid nodes using second-order central difference approximations of $u_{xx}$ and $u_{yy}$ on the uniform grid. Do not use any formula beyond this fundamental base in the problem statement; derive the explicit stencil in your solution.\n\nMetrics to compute:\n- For each test case, compute the discrete Laplacian $\\Delta_h u$ on the interior grid nodes. Then compute the maximum absolute magnitude over the interior, denoted $\\max_{\\text{interior}} |\\Delta_h u|$.\n- Normalize this maximum according to the type of feature present in $u$ as specified in the test suite.\n\nTest suite:\n1. Discontinuity case: $u(x,y) = 1$ if $x > 0.5$ and $u(x,y) = 0$ otherwise, on a grid with $N = 129$. Compute the interior maximum $M_{\\text{step}} := h^2 \\cdot \\max_{\\text{interior}} |\\Delta_h u|$. This normalization assesses the expected $O(h^{-2})$ growth near jump discontinuities.\n2. Sharp kink case: $u(x,y) = |x - 0.5|$ on a grid with $N = 129$. Compute the interior maximum $M_{\\text{kink}} := h \\cdot \\max_{\\text{interior}} |\\Delta_h u|$. This normalization assesses the expected $O(h^{-1})$ growth near slope discontinuities.\n3. Smooth baseline and convergence: $u(x,y) = \\sin(\\pi x)\\sin(\\pi y)$ with analytic Laplacian $\\Delta u(x,y) = -2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$. Use two grids: $N_1 = 33$ and $N_2 = 65$. For each $N$, compute the infinity-norm error\n   $$ E_\\infty(h) := \\max_{\\text{interior}} \\left| \\Delta_h u - \\Delta u \\right|. $$\n   Then compute the observed order of accuracy\n   $$ p := \\frac{\\log\\left( E_\\infty(h_1) / E_\\infty(h_2) \\right)}{\\log\\left( h_1 / h_2 \\right)}, $$\n   where $h_k = \\frac{1}{N_k - 1}$ for $k \\in \\{1,2\\}$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets:\n  - The list must be ordered as $[M_{\\text{step}}, M_{\\text{kink}}, E_\\infty(h_1), E_\\infty(h_2), p]$.\n- All outputs must be plain floating-point numbers. No units are involved in this problem.\n\nScientific realism and rationale:\n- The discontinuity and kink are common features in scientific computing, and the requested normalizations are chosen to reveal scale-invariant behavior of the discrete operator near non-smooth features. The smooth baseline case validates the second-order accuracy of the five-point Laplacian stencil via an empirically observed order $p$.\n\nYour program must not require any user input and must adhere to the specified execution environment. It should implement the computations exactly as specified above and print the single-line final result in the required format.", "solution": "The problem requires a numerical investigation of the five-point Laplacian stencil on a uniform Cartesian grid. The core of this task lies in deriving the discrete operator and then applying it to three distinct scalar fields $u(x,y)$: one with a jump discontinuity, one with a sharp kink (a derivative discontinuity), and one that is smooth. This allows for a comprehensive analysis of the stencil's behavior, from its failure to converge at singularities to its second-order accuracy for smooth functions.\n\nFirst, we establish the discrete Laplacian operator, $\\Delta_h$. The continuous Laplacian is given by $\\Delta u = u_{xx} + u_{yy}$, which is the sum of the second partial derivatives of $u$ with respect to the Cartesian coordinates. On a uniform grid with spacing $h$, we can approximate these derivatives using second-order central differences. For a function $f(x)$, the second derivative $f''(x)$ is approximated as:\n$$ f''(x) \\approx \\frac{f(x+h) - 2f(x) + f(x-h)}{h^2} $$\nApplying this formula to the partial derivatives $u_{xx}$ and $u_{yy}$ at a grid node $(x_i, y_j)$, where $x_i=ih$ and $y_j=jh$, we get:\n$$ u_{xx}(x_i, y_j) \\approx \\frac{u(x_{i+1}, y_j) - 2u(x_i, y_j) + u(x_{i-1}, y_j)}{h^2} = \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} $$\n$$ u_{yy}(x_i, y_j) \\approx \\frac{u(x_i, y_{j+1}) - 2u(x_i, y_j) + u(x_i, y_{j-1})}{h^2} = \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2} $$\nHere, we use the compact notation $u_{i,j} = u(x_i, y_j)$. Summing these two expressions yields the discrete Laplacian operator $\\Delta_h$ acting on the grid function value $u_{i,j}$:\n$$ (\\Delta_h u)_{i,j} = \\frac{u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}}{h^2} $$\nThis expression is the five-point Laplacian stencil. It is applied to all interior nodes of the grid, i.e., for $i,j \\in \\{1, 2, \\dots, N-2\\}$, using the function values defined on the full $N \\times N$ grid.\n\nWe now proceed to analyze the three specified test cases.\n\n**Test Case 1: Jump Discontinuity**\nThe scalar field is defined as $u(x,y) = 1$ if $x > 0.5$ and $u(x,y) = 0$ otherwise. The grid has $N = 129$ nodes, giving a grid spacing of $h = 1/(129-1) = 1/128$. The discontinuity occurs at $x = 0.5$, which coincides with the grid line at $x_{64} = 64h = 64/128 = 0.5$. Because of the strict inequality, grid values are $u_{i,j} = 0$ for $i \\le 64$ and $u_{i,j} = 1$ for $i > 64$, for any $j$.\nAt a point where the function is not differentiable, the Taylor series expansions used to derive the stencil are invalid. The stencil's output does not approximate the (undefined) continuous Laplacian. Instead, its magnitude depends on the grid spacing. Let us apply the stencil at an interior node on the column $i=64$, where $u_{64,j}=0$. The neighboring values along $x$ are $u_{63,j}=0$ and $u_{65,j}=1$. Since $u$ is constant with respect to $y$, $u_{64,j+1}=u_{64,j-1}=0$.\n$$ (\\Delta_h u)_{64,j} = \\frac{u_{65,j} + u_{63,j} + u_{64,j+1} + u_{64,j-1} - 4u_{64,j}}{h^2} = \\frac{1 + 0 + 0 + 0 - 4(0)}{h^2} = \\frac{1}{h^2} $$\nA similar calculation for the column $i=65$ yields $-1/h^2$. The maximum absolute value is therefore $\\max_{\\text{interior}}|\\Delta_h u| = 1/h^2$. The problem asks for $M_{\\text{step}} = h^2 \\cdot \\max_{\\text{interior}}|\\Delta_h u|$, which evaluates to $h^2 \\cdot (1/h^2) = 1$. This $O(h^{-2})$ scaling is characteristic of the stencil's response to a jump discontinuity.\n\n**Test Case 2: Sharp Kink**\nThe field is $u(x,y) = |x - 0.5|$, which is continuous but has a discontinuous first derivative at $x=0.5$. The grid is again $N=129$ with $h=1/128$. The grid function is $u_{i,j} = |x_i - 0.5| = |ih - 64h| = |i-64|h$.\nThe stencil is applied at the kink, i.e., at interior nodes on the column $i=64$. Here, $u_{64,j} = 0$. The neighbors are $u_{63,j}=h$ and $u_{65,j}=h$. The function is constant in $y$, so $u_{64,j+1}=u_{64,j-1}=0$.\n$$ (\\Delta_h u)_{64,j} = \\frac{u_{65,j} + u_{63,j} + u_{64,j+1} + u_{64,j-1} - 4u_{64,j}}{h^2} = \\frac{h + h + 0 + 0 - 4(0)}{h^2} = \\frac{2h}{h^2} = \\frac{2}{h} $$\nAway from the kink, $u(x,y)$ is linear in $x$, for which the second central difference is exactly zero. The maximum magnitude of the discrete Laplacian thus occurs at the kink, with value $2/h$. The requested quantity is $M_{\\text{kink}} = h \\cdot \\max_{\\text{interior}}|\\Delta_h u| = h \\cdot (2/h) = 2$. This $O(h^{-1})$ scaling is characteristic of the stencil's response to a slope discontinuity.\n\n**Test Case 3: Smooth Baseline and Convergence**\nThe field is $u(x,y) = \\sin(\\pi x)\\sin(\\pi y)$, which is infinitely smooth. The analytic Laplacian is $\\Delta u = -2\\pi^2\\sin(\\pi x)\\sin(\\pi y)$. For smooth functions, the discrete Laplacian $\\Delta_h u$ converges to the continuous Laplacian $\\Delta u$ as $h \\to 0$. The difference, or truncation error, for the five-point stencil is of order $h^2$, i.e., $|\\Delta_h u - \\Delta u| \\approx C h^2$ for some constant $C$ that depends on higher derivatives of $u$.\nTo verify this, we compute the maximum error $E_\\infty(h) = \\max_{\\text{interior}} |\\Delta_h u - \\Delta u|$ on two grids: one with $N_1 = 33$ ($h_1 = 1/32$) and one with $N_2 = 65$ ($h_2 = 1/64$). The observed order of accuracy, $p$, is determined by the relation:\n$$ \\frac{E_\\infty(h_1)}{E_\\infty(h_2)} \\approx \\left(\\frac{h_1}{h_2}\\right)^p $$\nSolving for $p$ yields the formula:\n$$ p = \\frac{\\log\\left( E_\\infty(h_1) / E_\\infty(h_2) \\right)}{\\log\\left( h_1 / h_2 \\right)} $$\nGiven that the stencil is second-order accurate, the result for $p$ should be very close to $2$. The program will compute the numerical values for $E_\\infty(h_1)$, $E_\\infty(h_2)$, and $p$.\nThe overall procedure involves first setting up the full $N \\times N$ grid of values $u_{i,j}$ for each case, then calculating $(\\Delta_h u)_{i,j}$ on the $(N-2) \\times (N-2)$ interior grid, and finally computing the specified metrics from these results.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef apply_laplacian_5pt(U, h):\n    \"\"\"\n    Applies the 5-point Laplacian stencil to a 2D grid.\n\n    Args:\n        U (np.ndarray): An N x N grid of function values.\n        h (float): The grid spacing.\n\n    Returns:\n        np.ndarray: The discrete Laplacian on the (N-2) x (N-2) interior grid.\n    \"\"\"\n    # Slicing based on matrix indices: U[j, i] corresponds to u(x_i, y_j).\n    # The stencil is (u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}) / h^2.\n    lap_U = (U[1:-1, 2:]      # East neighbor u_{i+1,j}\n             + U[1:-1, :-2]   # West neighbor u_{i-1,j}\n             + U[2:, 1:-1]    # North neighbor u_{i,j+1}\n             + U[:-2, 1:-1]   # South neighbor u_{i,j-1}\n             - 4 * U[1:-1, 1:-1]) / (h**2) # Central point u_{i,j}\n    return lap_U\n\ndef solve():\n    \"\"\"\n    Runs the full analysis for the three test cases and prints the final result.\n    \"\"\"\n    # Test Case 1: Discontinuity\n    N_step = 129\n    h_step = 1.0 / (N_step - 1)\n    x_step = np.arange(N_step) * h_step\n    u_1d_step = np.where(x_step > 0.5, 1.0, 0.0)\n    U_step = np.tile(u_1d_step, (N_step, 1))\n    lap_U_step_interior = apply_laplacian_5pt(U_step, h_step)\n    max_abs_lap_step = np.max(np.abs(lap_U_step_interior))\n    M_step = h_step**2 * max_abs_lap_step\n\n    # Test Case 2: Sharp Kink\n    N_kink = 129\n    h_kink = 1.0 / (N_kink - 1)\n    x_kink = np.arange(N_kink) * h_kink\n    u_1d_kink = np.abs(x_kink - 0.5)\n    U_kink = np.tile(u_1d_kink, (N_kink, 1))\n    lap_U_kink_interior = apply_laplacian_5pt(U_kink, h_kink)\n    max_abs_lap_kink = np.max(np.abs(lap_U_kink_interior))\n    M_kink = h_kink * max_abs_lap_kink\n\n    # Test Case 3: Smooth Baseline and Convergence\n    Ns_smooth = [33, 65]\n    errors = []\n    hs = []\n\n    for N in Ns_smooth:\n        h = 1.0 / (N - 1)\n        hs.append(h)\n        \n        # Create grid coordinates and function grid\n        x = np.arange(N) * h\n        y = np.arange(N) * h\n        X, Y = np.meshgrid(x, y, indexing='xy')\n        \n        U_smooth = np.sin(np.pi * X) * np.sin(np.pi * Y)\n        \n        # Apply discrete Laplacian\n        lap_U_discrete_interior = apply_laplacian_5pt(U_smooth, h)\n        \n        # Compute analytic Laplacian on the interior grid\n        interior_X = X[1:-1, 1:-1]\n        interior_Y = Y[1:-1, 1:-1]\n        lap_U_analytic_interior = -2.0 * np.pi**2 * np.sin(np.pi * interior_X) * np.sin(np.pi * interior_Y)\n\n        # Compute the infinity-norm error\n        error = np.max(np.abs(lap_U_discrete_interior - lap_U_analytic_interior))\n        errors.append(error)\n        \n    E_inf_h1, E_inf_h2 = errors\n    h1, h2 = hs\n    \n    # Compute the observed order of accuracy\n    p = np.log(E_inf_h1 / E_inf_h2) / np.log(h1 / h2)\n    \n    # Assemble and print the final results\n    results = [M_step, M_kink, E_inf_h1, E_inf_h2, p]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3230782"}, {"introduction": "After analyzing the stencil's local properties, the ultimate goal is to use it to solve a partial differential equation. This comprehensive exercise guides you through the entire process of solving the Poisson equation on a 2D domain, from assembling the global stiffness matrix and incorporating boundary conditions to solving the resulting linear system. By performing a refinement study on the full numerical solution, you will confirm that the local second-order accuracy of the stencil leads to a globally second-order accurate solution, tying together theory and application [@problem_id:3453785].", "problem": "Design and implement a refinement study for the scalar Poisson problem on the unit square that verifies the second-order convergence of a finite difference scheme based on the five-point stencil for the two-dimensional Laplacian. The problem domain is $\\Omega = (0,1)\\times(0,1)$. Consider the boundary value problem $- \\Delta u = f$ on $\\Omega$ with Dirichlet boundary conditions $u|_{\\partial \\Omega} = g$, where $g$ is chosen consistently from a smooth manufactured exact solution $u$. Your task is to construct and solve the discrete linear system arising from second-order central differences on a uniform grid, compute discrete $L^2$ errors for a sequence of grid spacings $h$, and estimate the observed convergence rate.\n\nStart from the following fundamental bases:\n- The definition of the Laplacian $\\Delta u = \\partial^2 u/\\partial x^2 + \\partial^2 u/\\partial y^2$.\n- The second-order central difference approximation to the one-dimensional second derivative constructed via Taylor expansions about a grid point.\n- The discrete $L^2$ norm on a uniform grid with spacing $h$, defined as $\\|e_h\\|_{L^2_h} = \\left(h^2 \\sum_{i,j} |e_{i,j}|^2\\right)^{1/2}$ for an error field $e_{i,j}$ sampled at interior grid points.\n\nYou must not use any pre-stated stencil formula in your derivation of the discrete operator; derive the five-point stencil starting from the Taylor expansions and combine the one-dimensional approximations dimension by dimension.\n\nConstruct a uniform Cartesian grid with $n$ interior points per direction and spacing $h = 1/(n+1)$ for each refinement level. Assemble the linear system corresponding to the discrete operator for $- \\Delta$ with Dirichlet boundary conditions enforced by incorporating boundary values into the right-hand side. Solve the linear system for the interior unknowns using any robust direct linear solver.\n\nDefine the discrete $L^2$ error at grid spacing $h$ as\n$$\nE(h) = \\left(h^2 \\sum_{i=1}^{n}\\sum_{j=1}^{n}\\left(u_h(x_i,y_j) - u(x_i,y_j)\\right)^2\\right)^{1/2},\n$$\nwhere $x_i = i h$, $y_j = j h$, and $u_h$ is the numerical solution defined on the interior nodes. For successive mesh spacings $h$ and $h/2$, define the observed order\n$$\np(h \\to h/2) = \\frac{\\log\\left(E(h)/E(h/2)\\right)}{\\log(2)}.\n$$\n\nImplement a refinement study for each manufactured exact solution $u$ listed in the test suite below, using the sequence of interior grid sizes $\\{n\\} = \\{7, 15, 31, 63\\}$, which corresponds to spacings $h \\in \\{1/8, 1/16, 1/32, 1/64\\}$. For each $u$, compute the sequence of errors $\\{E(h)\\}$ and the sequence of observed orders $\\{p(h \\to h/2)\\}$ for the three refinement steps. Report, for each $u$, the observed order based on the two finest levels (that is, between $h=1/32$ and $h=1/64$), and also report a boolean indicating whether all three observed orders lie within the tolerance interval $[1.8, 2.2]$.\n\nTest suite:\n- Case $\\mathrm{A}$ (zero boundary data): $u(x,y) = \\sin(2\\pi x)\\,\\sin(3\\pi y)$, so that $f(x,y) = -\\Delta u(x,y) = \\left((2\\pi)^2 + (3\\pi)^2\\right) \\sin(2\\pi x)\\,\\sin(3\\pi y)$ and $g$ is $u$ restricted to $\\partial \\Omega$.\n- Case $\\mathrm{B}$ (nonzero boundary data, exponential): $u(x,y) = e^{x+y}$, so that $f(x,y) = -\\Delta u(x,y) = -2 e^{x+y}$ and $g$ is $u$ restricted to $\\partial \\Omega$.\n- Case $\\mathrm{C}$ (polynomial with mixed boundary behavior): $u(x,y) = x^2 y^2$, so that $f(x,y) = -\\Delta u(x,y) = -2(x^2 + y^2)$ and $g$ is $u$ restricted to $\\partial \\Omega$.\n\nYour program should:\n- For each of the three cases, perform the refinement study on the specified grid sequence, compute the error sequence $\\{E(h)\\}$, compute the observed orders $\\{p(h \\to h/2)\\}$, extract the finest-level observed order $p_\\mathrm{fine}$ from the last refinement step, and check whether all three observed orders lie in $[1.8, 2.2]$.\n- Produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain, in order: the three finest-level observed orders (one per case, as floating-point numbers), followed by three booleans (one per case) indicating whether all observed orders for that case are within $[1.8, 2.2]$. For example, the output must have the format\n$[p_{\\mathrm{A}}, p_{\\mathrm{B}}, p_{\\mathrm{C}}, b_{\\mathrm{A}}, b_{\\mathrm{B}}, b_{\\mathrm{C}}]$,\nwhere each $p_{\\mathrm{case}}$ is a floating-point number and each $b_{\\mathrm{case}}$ is either True or False.\n\nAll quantities are nondimensional; no physical units are required. Angles, where present in trigonometric functions, are in radians. The program must be completely self-contained, accept no input, and print exactly one line in the specified format.", "solution": "The problem requires the design and implementation of a numerical verification study for a second-order finite difference scheme applied to the two-dimensional Poisson equation, $-\\Delta u = f$, on the unit square domain $\\Omega = (0,1) \\times (0,1)$ with Dirichlet boundary conditions $u|_{\\partial\\Omega} = g$. The core of the task is to derive the discrete operator, construct and solve the resulting linear system, and perform a refinement study to confirm the method's theoretical second-order convergence. This is accomplished using the method of manufactured solutions.\n\nFirst, we derive the necessary finite difference approximation for the Laplacian operator, $\\Delta = \\partial^2/\\partial x^2 + \\partial^2/\\partial y^2$. This is done by first principles using Taylor series expansions. For a sufficiently smooth one-dimensional function $u(x)$, the expansions about a point $x_i$ for a step size $h$ are:\n$$\nu(x_i + h) = u(x_i) + h u'(x_i) + \\frac{h^2}{2} u''(x_i) + \\frac{h^3}{6} u'''(x_i) + \\frac{h^4}{24} u^{(4)}(x_i) + O(h^5)\n$$\n$$\nu(x_i - h) = u(x_i) - h u'(x_i) + \\frac{h^2}{2} u''(x_i) - \\frac{h^3}{6} u'''(x_i) + \\frac{h^4}{24} u^{(4)}(x_i) - O(h^5)\n$$\nSumming these two expressions serves to cancel the odd-order derivative terms, yielding:\n$$\nu(x_i + h) + u(x_i - h) = 2u(x_i) + h^2 u''(x_i) + \\frac{h^4}{12} u^{(4)}(x_i) + O(h^6)\n$$\nBy rearranging this equation to isolate the second derivative, we obtain:\n$$\nu''(x_i) = \\frac{u(x_i - h) - 2u(x_i) + u(x_i + h)}{h^2} - \\frac{h^2}{12} u^{(4)}(x_i) + O(h^4)\n$$\nThis provides the standard second-order central difference approximation for the second derivative, with a leading truncation error term of $O(h^2)$.\n\nTo discretize the two-dimensional Laplacian, we set up a uniform Cartesian grid on the domain with grid points $(x_i, y_j) = (ih, jh)$, where $h=1/(n+1)$ is the grid spacing in both directions and the indices for interior points are $i,j \\in \\{1, 2, \\dots, n\\}$. Let $u_{i,j} = u(x_i, y_j)$. We apply the one-dimensional approximation along each coordinate axis at a generic interior point $(x_i, y_j)$:\n$$\n\\left.\\frac{\\partial^2 u}{\\partial x^2}\\right|_{(x_i, y_j)} \\approx \\frac{u_{i-1,j} - 2u_{i,j} + u_{i+1,j}}{h^2}\n$$\n$$\n\\left.\\frac{\\partial^2 u}{\\partial y^2}\\right|_{(x_i, y_j)} \\approx \\frac{u_{i,j-1} - 2u_{i,j} + u_{i,j+1}}{h^2}\n$$\nThe Laplacian is the sum of these partial derivatives. Summing the approximations yields the well-known five-point stencil for the Laplacian:\n$$\n(\\Delta u)_{i,j} \\approx \\frac{u_{i-1,j} + u_{i+1,j} + u_{i,j-1} + u_{i,j+1} - 4u_{i,j}}{h^2}\n$$\nThe local truncation error for this approximation is $O(h^2)$, provided the solution $u$ possesses sufficiently high-order continuous derivatives.\n\nSubstituting this discrete operator into the Poisson equation, $-\\Delta u = f$, we obtain a linear equation for each interior grid point $(x_i, y_j)$:\n$$\n-\\frac{u_{i-1,j} + u_{i+1,j} + u_{i,j-1} + u_{i,j+1} - 4u_{i,j}}{h^2} \\approx f(x_i, y_j)\n$$\nMultiplying by $-h^2$ and rearranging leads to the discrete equation:\n$$\n4u_{i,j} - u_{i-1,j} - u_{i+1,j} - u_{i,j-1} - u_{i,j+1} \\approx h^2 f_{i,j}\n$$\nThis set of $N=n^2$ equations for the $N$ unknown interior values $u_{i,j}$ forms a linear system $A \\mathbf{u}_h = \\mathbf{b}$. To construct the system explicitly, we map the two-dimensional grid of unknowns $(u_{i,j})$ to a one-dimensional vector $\\mathbf{u}_h$ of length $N$. A standard choice is row-major ordering, where the grid point $(i,j)$ maps to vector index $k = (j-1)n + (i-1)$ for $i,j \\in \\{1,\\dots,n\\}$.\n\nThe matrix $A$ represents the discrete negative Laplacian. The equation at point $(i,j)$ (row $k$ of the matrix) involves $u_{i,j}$ and its four neighbors. This structure leads to an $N \\times N$ matrix $A$ with five non-zero diagonals:\n- The main diagonal (stencil center, coefficient $4$) is at offset $0$.\n- The sub- and super-diagonals (x-neighbors, coefficient $-1$) are at offsets $\\pm 1$.\n- The far sub- and super-diagonals (y-neighbors, coefficient $-1$) are at offsets $\\pm n$.\nThe matrix $A$ is sparse, symmetric, and positive-definite.\n\nThe right-hand side vector $\\mathbf{b}$ incorporates the source term $f$ and the Dirichlet boundary conditions $g$. For an equation centered at $(x_i, y_j)$, the corresponding component of $\\mathbf{b}$ starts as $h^2 f(x_i, y_j)$. If any of the four neighbors in the stencil lie on the boundary $\\partial\\Omega$ (e.g., $u_{i-1,j}$ when $i=1$), its value is known from the boundary function $g$ (e.g., $u_{0,j} = g(0, y_j)$). This known value is moved to the right-hand side of the equation. The complete expression for the component of the right-hand side corresponding to point $(x_i, y_j)$ is:\n$$\nb_{i,j} = h^2 f(x_i, y_j) + \\delta_{i,1}g(0, y_j) + \\delta_{i,n}g(1, y_j) + \\delta_{j,1}g(x_i, 0) + \\delta_{j,n}g(x_i, 1)\n$$\nwhere $\\delta$ represents the Kronecker delta. The vector $\\mathbf{b}$ is assembled by flattening the grid of $b_{i,j}$ values, maintaining the same row-major ordering used for $\\mathbf{u}_h$.\n\nThe refinement study proceeds by solving the system $A\\mathbf{u}_h=\\mathbf{b}$ for a sequence of decreasing grid spacings $h$, corresponding to the given interior grid sizes $n \\in \\{7, 15, 31, 63\\}$. For each solution $u_h$, we compute the discrete $L^2$ error:\n$$\nE(h) = \\left(h^2 \\sum_{i=1}^{n}\\sum_{j=1}^{n}\\left(u_h(x_i,y_j) - u(x_i,y_j)\\right)^2\\right)^{1/2}\n$$\nThe observed order of convergence $p$ is then estimated between two successive refinements (e.g., with spacings $h$ and $h/2$) using the formula:\n$$\np(h \\to h/2) = \\frac{\\log\\left(E(h)/E(h/2)\\right)}{\\log(2)}\n$$\nFor a second-order accurate scheme, we anticipate that as $h \\to 0$, $p$ will approach $2$. The implementation will calculate this order for each refinement step and check if the results fall within a specified tolerance of the theoretical value.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags\nfrom scipy.sparse.linalg import spsolve\nimport math\n\n# --- Problem Definition ---\n\n# The scalar Poisson problem is -Delta u = f on Omega = (0,1)x(0,1)\n# with Dirichlet boundary conditions u|dOmega = g.\n\n# --- Numerical Scheme ---\n\n# The implementation uses a second-order central finite difference scheme\n# on a uniform Cartesian grid with n interior points per direction.\n# This results in the 5-point stencil for the negative Laplacian. The\n# discrete equation at an interior node (i,j) is:\n#   4*u_ij - u_{i-1,j} - u_{i+1,j} - u_{i,j-1} - u_{i,j+1} = h^2 * f_ij\n#\n# This leads to a linear system A*u_h = b, where A is a sparse,\n# symmetric positive-definite matrix. Boundary conditions are incorporated\n# into the right-hand side vector b.\n\ndef run_refinement_study(u_exact, f_source, n_list):\n    \"\"\"\n    Performs a grid refinement study for a given manufactured solution.\n\n    Args:\n        u_exact (callable): The exact solution u(x, y).\n        f_source (callable): The source term f(x, y) = -Delta u.\n        n_list (list of int): A sequence of interior grid sizes.\n\n    Returns:\n        tuple: A tuple containing:\n            - float: The observed order of convergence on the finest grid.\n            - bool: True if all observed orders are within [1.8, 2.2].\n    \"\"\"\n    errors = []\n    g_boundary = u_exact\n\n    for n in n_list:\n        # Total number of interior unknowns\n        N = n * n\n        # Grid spacing\n        h = 1.0 / (n + 1)\n\n        # 1. Construct the sparse matrix A for the negative Laplacian operator.\n        # The matrix has 5 diagonals based on the 5-point stencil.\n        # We use row-major ordering for mapping (i,j) -> k.\n        \n        # Main diagonal (coefficient 4)\n        d0 = np.ones(N) * 4\n        \n        # Off-diagonals for x-derivatives (coefficient -1)\n        d1 = np.ones(N - 1) * -1\n        # Set stencil connections at row boundaries to zero.\n        d1[n - 1::n] = 0\n        \n        # Off-diagonals for y-derivatives (coefficient -1)\n        dn = np.ones(N - n) * -1\n        \n        A = diags([d0, d1, d1, dn, dn], [0, 1, -1, n, -n], format='csr')\n\n        # 2. Construct the right-hand side vector b.\n        x_coords = np.linspace(h, 1 - h, n)\n        y_coords = np.linspace(h, 1 - h, n)\n        xx, yy = np.meshgrid(x_coords, y_coords, indexing='xy')\n        \n        # Start with the source term f\n        b_grid = h**2 * f_source(xx, yy)\n        \n        # Add contributions from Dirichlet boundary conditions\n        b_grid[:, 0] += g_boundary(0.0, y_coords)      # Left boundary (i=1)\n        b_grid[:, -1] += g_boundary(1.0, y_coords)     # Right boundary (i=n)\n        b_grid[0, :] += g_boundary(x_coords, 0.0)      # Bottom boundary (j=1)\n        b_grid[-1, :] += g_boundary(x_coords, 1.0)     # Top boundary (j=n)\n        \n        # Note on meshgrid indexing: with 'xy', grid[j, i] corresponds to (x_i, y_j)\n        # So b_grid[0,:] is for j=0 (Python index), which is the first interior row.\n        # The order of adding boundary terms to b_grid doesn't matter,\n        # but the logic above is slightly easier to read if grouped by dimension.\n        \n        b_vec = b_grid.flatten('F') # Flatten column-wise due to meshgrid 'xy' + row-major A\n\n        # 3. Solve the linear system A * u_h = b\n        u_h_vec = spsolve(A, b_vec)\n        u_h_grid = u_h_vec.reshape((n, n), order='F')\n\n        # 4. Compute the discrete L2 error\n        u_exact_grid = u_exact(xx, yy)\n        error_grid = u_h_grid - u_exact_grid\n        \n        # E(h) = (h^2 * sum(e_ij^2))^(1/2) = h * ||e_ij||_F\n        l2_error = h * np.linalg.norm(error_grid)\n        errors.append(l2_error)\n\n    # 5. Compute the observed orders of convergence\n    orders = []\n    for i in range(len(errors) - 1):\n        # p = log(E(h)/E(h/2)) / log(2)\n        order = math.log(errors[i] / errors[i+1]) / math.log(2)\n        orders.append(order)\n        \n    finest_order = orders[-1]\n    all_in_tolerance = all(1.8 = o = 2.2 for o in orders)\n    \n    return finest_order, all_in_tolerance\n\n\ndef solve():\n    \"\"\"\n    Main driver function to run the test cases and print the final result.\n    \"\"\"\n    # Define the sequence of interior grid sizes for the refinement study\n    n_list = [7, 15, 31, 63]\n\n    # Test Case A: Smooth trigonometric solution, zero on boundary\n    u_A = lambda x, y: np.sin(2 * np.pi * x) * np.sin(3 * np.pi * y)\n    f_A = lambda x, y: ((2 * np.pi)**2 + (3 * np.pi)**2) * u_A(x, y)\n\n    # Test Case B: Exponential solution, non-zero on boundary\n    u_B = lambda x, y: np.exp(x + y)\n    f_B = lambda x, y: -2.0 * np.exp(x + y)\n    \n    # Test Case C: Polynomial solution\n    u_C = lambda x, y: x**2 * y**2\n    f_C = lambda x, y: -2.0 * (x**2 + y**2)\n\n    test_cases = [\n        {\"u\": u_A, \"f\": f_A},\n        {\"u\": u_B, \"f\": f_B},\n        {\"u\": u_C, \"f\": f_C},\n    ]\n\n    # Store results for final output\n    p_results = []\n    b_results = []\n\n    for case in test_cases:\n        p_fine, b_tol = run_refinement_study(case[\"u\"], case[\"f\"], n_list)\n        p_results.append(p_fine)\n        b_results.append(b_tol)\n    \n    final_output_list = p_results + b_results\n\n    # Print the final result in the specified format\n    # The output format has been updated to match the problem statement precisely.\n    print(f\"[{p_results[0]},{p_results[1]},{p_results[2]},{b_results[0]},{b_results[1]},{b_results[2]}]\")\n\nsolve()\n```", "id": "3453785"}]}