{"hands_on_practices": [{"introduction": "The integrity of a finite element simulation rests on the accurate assembly of the global stiffness matrix. Since the matrix entries are defined by integrals that are almost always computed numerically, a crucial question arises: how accurate must our numerical quadrature be? This exercise [@problem_id:3437078] delves into this fundamental issue, asking you to determine the minimum quadrature degree needed to integrate the element stiffness matrix exactly. Mastering this concept ensures that the assembled discrete system is a faithful representation of the continuous weak form, free from integration errors.", "problem": "Consider the scalar diffusion partial differential equation (PDE) on a bounded Lipschitz domain $\\,\\Omega \\subset \\mathbb{R}^{d}\\,$ with homogeneous Dirichlet boundary conditions,\n$$\n-\\nabla \\cdot \\big(\\kappa(x) \\nabla u(x)\\big) = f(x) \\quad \\text{in } \\Omega, \\qquad u=0 \\quad \\text{on } \\partial\\Omega,\n$$\nwhere the diffusion coefficient $\\,\\kappa(x)\\,$ is assumed to be piecewise polynomial of total degree $\\,r \\ge 0\\,$ when restricted to any element of a shape-regular simplicial mesh $\\,\\mathcal{T}_h\\,$ of $\\,\\Omega\\,$. Let $\\,V_h\\,$ be the standard conforming Lagrange finite element space of degree $\\,k \\ge 1\\,$ on $\\,\\mathcal{T}_h\\,$ with affine element mappings, and let $\\{\\varphi_i\\}$ denote the global nodal basis functions for $\\,V_h\\,$.\n\nThe global stiffness matrix $\\,A\\,$ has entries\n$$\nA_{ij} \\;=\\; \\int_{\\Omega} \\kappa(x)\\,\\nabla \\varphi_i(x) \\cdot \\nabla \\varphi_j(x)\\, \\mathrm{d}x,\n$$\nobtained by assembling elementwise contributions. Suppose that, on each element $\\,K \\in \\mathcal{T}_h\\,$, the volume integral is approximated by a quadrature rule that is exact for all polynomials on $\\,K\\,$ of total degree up to $\\,Q\\,$.\n\nStarting from fundamental definitions of the conforming Galerkin method and the polynomial-degree structure of Lagrange finite elements with affine mappings, determine the minimal integer $\\,Q_{\\min}\\,$ such that, for all meshes $\\,\\mathcal{T}_h\\,$ and all piecewise polynomial $\\,\\kappa\\,$ of degree $\\,r\\,$, the assembled quadrature-based global stiffness matrix is identical to the matrix obtained by exact integration. Express your final answer as a closed-form symbolic expression in terms of $\\,r\\,$ and $\\,k\\,$. No rounding is required, and no physical units apply to your answer.", "solution": "The problem as stated is scientifically grounded, well-posed, objective, and contains all necessary information for a unique solution. It is a standard problem in the analysis of the Finite Element Method (FEM). This warrants proceeding with a full solution.\n\nThe objective is to find the minimal integer $Q_{\\min}$ such that a numerical quadrature rule, exact for all polynomials on an element $K$ of total degree up to $Q$, will compute the element stiffness matrix exactly. For the quadrature-approximated global stiffness matrix to be identical to the exactly integrated one, this condition must hold for every element $K$ in the mesh $\\mathcal{T}_h$.\n\nThe entries of the global stiffness matrix $A$ are given by\n$$\nA_{ij} = \\int_{\\Omega} \\kappa(x)\\,\\nabla \\varphi_i(x) \\cdot \\nabla \\varphi_j(x)\\, \\mathrm{d}x.\n$$\nThis global integral is assembled by summing contributions from each element $K$ in the mesh $\\mathcal{T}_h$:\n$$\nA_{ij} = \\sum_{K \\in \\mathcal{T}_h} \\int_{K} \\kappa(x)\\,\\nabla \\varphi_i(x) \\cdot \\nabla \\varphi_j(x)\\, \\mathrm{d}x.\n$$\nThe numerical quadrature is applied to the integral over each element $K$. To ensure exact computation of this integral, the quadrature rule must be exact for the integrand function, which we denote by $I_K(x)$:\n$$\nI_K(x) = \\kappa(x)|_K \\, \\big(\\nabla \\varphi_i(x)|_K \\cdot \\nabla \\varphi_j(x)|_K\\big).\n$$\nTo determine the required degree of exactness $Q$, we must find the maximum possible total polynomial degree of $I_K(x)$ on an arbitrary element $K$. This degree is the sum of the degrees of its polynomial factors.\n\nLet's analyze the polynomial degree of each component of the integrand $I_K(x)$.\n\n1.  **The diffusion coefficient $\\kappa(x)$**: The problem states that when restricted to any element $K \\in \\mathcal{T}_h$, the function $\\kappa(x)$ is a polynomial of total degree at most $r$, where $r \\ge 0$. Let $\\text{deg}(\\kappa|_K)$ denote this degree.\n    $$\n    \\text{deg}(\\kappa|_K) \\le r.\n    $$\n\n2.  **The gradients of the basis functions $\\nabla \\varphi_i(x)$ and $\\nabla \\varphi_j(x)$**: The basis functions $\\varphi_i$ and $\\varphi_j$ belong to the standard conforming Lagrange finite element space $V_h$ of degree $k \\ge 1$. This means that on any element $K$, the restriction of a basis function $\\varphi_i|_K$ is a polynomial of total degree at most $k$.\n\n    The problem specifies that the element mappings are affine. Let $\\hat{K}$ be a reference element (e.g., the unit simplex) and let $F_K: \\hat{K} \\to K$ be the affine mapping from the reference to the physical element $K$. An affine map has the form $x = F_K(\\hat{x}) = B_K \\hat{x} + b_K$, where $B_K$ is a constant, invertible matrix (the Jacobian of the mapping) and $b_K$ is a constant vector. The inverse mapping $F_K^{-1}: K \\to \\hat{K}$ is also affine.\n\n    A basis function $\\varphi_i$ restricted to $K$ is obtained by composing a reference basis function $\\hat{\\varphi}_{\\alpha}(\\hat{x})$ (which is a polynomial of degree at most $k$ on $\\hat{K}$) with the inverse mapping:\n    $$\n    \\varphi_i|_K(x) = \\hat{\\varphi}_{\\alpha}(F_K^{-1}(x)).\n    $$\n    We compute the gradient of $\\varphi_i|_K(x)$ using the chain rule:\n    $$\n    \\nabla_x \\varphi_i|_K(x) = (B_K^{-T}) \\, \\nabla_{\\hat{x}} \\hat{\\varphi}_{\\alpha}(F_K^{-1}(x)).\n    $$\n    Here, $\\nabla_{\\hat{x}} \\hat{\\varphi}_{\\alpha}$ is the gradient of a polynomial of degree at most $k$ with respect to the reference coordinates $\\hat{x}$. The gradient operator reduces the polynomial degree by one. Thus, each component of the vector $\\nabla_{\\hat{x}} \\hat{\\varphi}_{\\alpha}$ is a polynomial of degree at most $k-1$.\n\n    Since $F_K^{-1}(x)$ is an affine function of $x$, composing $\\nabla_{\\hat{x}} \\hat{\\varphi}_{\\alpha}$ with $F_K^{-1}(x)$ results in a vector of polynomials in $x$ of degree at most $k-1$. The matrix $B_K^{-T}$ is constant, so multiplying by it does not change the polynomial degree. Therefore, for an affine mapping, the gradient of a degree-$k$ basis function is a vector of polynomials of degree at most $k-1$:\n    $$\n    \\text{deg}(\\nabla \\varphi_i|_K) \\le k-1 \\quad \\text{and} \\quad \\text{deg}(\\nabla \\varphi_j|_K) \\le k-1.\n    $$\n\n3.  **The dot product term $\\nabla \\varphi_i \\cdot \\nabla \\varphi_j$**: This term is the dot product of two vectors whose components are polynomials of degree at most $k-1$. The product of two such polynomials has a degree of at most $(k-1) + (k-1) = 2k-2$. The sum of such products, as in a dot product, will also have a degree of at most $2k-2$.\n    $$\n    \\text{deg}(\\nabla \\varphi_i|_K \\cdot \\nabla \\varphi_j|_K) \\le 2(k-1).\n    $$\n\n4.  **The total degree of the integrand $I_K(x)$**: The total degree of the integrand $I_K(x) = \\kappa|_K \\, (\\nabla \\varphi_i|_K \\cdot \\nabla \\varphi_j|_K)$ is the sum of the degrees of its factors:\n    $$\n    \\text{deg}(I_K(x)) \\le \\text{deg}(\\kappa|_K) + \\text{deg}(\\nabla \\varphi_i|_K \\cdot \\nabla \\varphi_j|_K) \\le r + 2(k-1).\n    $$\n    To ensure that the assembled stiffness matrix is exact for all possible choices of meshes and piecewise polynomial coefficients $\\kappa(x)$ (of degree $r$), the quadrature rule must be exact for polynomials up to this maximum possible degree. It is possible to construct a function $\\kappa(x)$ that is exactly degree $r$ on an element and to find basis functions $\\varphi_i, \\varphi_j$ (for $k \\ge 1$) whose gradients are polynomials of exactly degree $k-1$. Therefore, the upper bound of $r + 2(k-1)$ is sharp and represents the worst-case scenario.\n\n    Thus, the minimal integer $Q_{\\min}$ for the degree of exactness of the quadrature rule must be this value.\n    $$\n    Q_{\\min} = r + 2(k-1).\n    $$\nThis ensures that for any element $K$, the integral $\\int_K I_K(x) \\, \\mathrm{d}x$ is computed exactly, which in turn guarantees that the assembled global stiffness matrix is identical to the one obtained via exact integration.", "answer": "$$\n\\boxed{2(k-1) + r}\n$$", "id": "3437078"}, {"introduction": "The choice of a quadrature rule has consequences that go beyond mere numerical accuracy, affecting the physical behavior represented by the discrete model. This hands-on coding practice explores how different schemes—full, reduced, and selective reduced integration—alter the spectral properties of the stiffness matrix for a 3D solid mechanics problem. This exercise [@problem_id:3599220] reveals how an improperly chosen rule can introduce pathological behaviors like artificial stiffening (locking) or spurious zero-energy modes (hourglassing), and how advanced techniques are designed to mitigate these issues. By computing the matrix's smallest eigenvalues, you will directly observe and diagnose these critical phenomena.", "problem": "Consider a three-dimensional small-strain, linear-elastic solid occupying the cube domain $\\Omega = [0,1] \\times [0,1] \\times [0,1]$ in $\\mathrm{m}^3$. Discretize $\\Omega$ with a uniform, structured mesh of $2 \\times 2 \\times 2$ trilinear eight-node hexahedral elements ($H_8$). Each node has three translational degrees of freedom. Impose homogeneous Dirichlet boundary conditions $u_x = u_y = u_z = 0$ on the entire face $\\{(x,y,z) \\in \\Omega \\mid z = 0\\}$ to eliminate rigid-body modes. Assume isotropic, homogeneous, linear elasticity with Young’s modulus $E$ (in $\\mathrm{Pa}$) and Poisson’s ratio $\\nu$, with Lamé parameters $\\lambda = \\dfrac{E \\nu}{(1+\\nu)(1-2\\nu)}$ and $\\mu = \\dfrac{E}{2(1+\\nu)}$. Let the constitutive tensor in Voigt notation be the standard $6 \\times 6$ matrix for three-dimensional isotropic linear elasticity built from $\\lambda$ and $\\mu$. Use small-strain kinematics. No body forces or tractions are applied.\n\nStarting from the principle of virtual work for the static, unloaded configuration,\n$$\n\\int_{\\Omega} \\boldsymbol{\\varepsilon}(\\mathbf{u}) : \\mathbb{C} : \\boldsymbol{\\varepsilon}(\\mathbf{v}) \\, \\mathrm{d}\\Omega = 0,\n$$\nwith the usual finite element Galerkin discretization using $H_8$ shape functions, assemble the global stiffness matrix $\\mathbf{K}$. The selective reduced integration (SRI) strategy decomposes the constitutive response into volumetric and deviatoric parts and integrates them with different quadrature rules to alleviate locking while avoiding spurious zero-energy modes (hourglass modes). Specifically, for the element stiffness $\\mathbf{K}^e$:\n- The deviatoric term must be integrated using a tensor-product Gaussian rule with $2$ points per direction ($2 \\times 2 \\times 2$ integration).\n- The volumetric term must be integrated using a single integration point at the element center (one-point integration).\n\nIn contrast, for reference and comparison:\n- Full integration (FI, Full Integration) integrates the full constitutive response at $2 \\times 2 \\times 2$ Gauss points.\n- Reduced integration (RI, Reduced Integration) integrates the full constitutive response at a single element-center point (one-point integration).\n\nUse standard isoparametric $H_8$ shape functions on the parent domain $[-1,1]^3$ and the exact isoparametric mapping to physical coordinates. For the $2 \\times 2 \\times 2$ Gauss rule, use the one-dimensional abscissae $\\{\\pm 1/\\sqrt{3}\\}$ with weights $1$, composed in tensor product. For the one-point rule, use the abscissa $0$ with weight $2$ in each direction composed in tensor product. Treat the mesh as a uniform partition of the unit cube, so all element mappings are rectangular and aligned.\n\nYour task is to write a complete program that:\n- Builds the $H_8$ mesh of the unit cube with $2 \\times 2 \\times 2$ elements and assembles the global stiffness matrix $\\mathbf{K}$.\n- Applies homogeneous Dirichlet boundary conditions on the face $z=0$ by eliminating the associated rows and columns.\n- Computes the $k$ smallest eigenvalues (in ascending order) of the symmetric positive semidefinite matrix $\\mathbf{K}$ under three integration schemes: FI, RI, and SRI, for parameter sets specified below. The eigenvalues must be computed for the reduced matrix after applying boundary conditions, and reported in units of $\\mathrm{N}/\\mathrm{m}$.\n- Reports the eigenvalues as floating-point numbers.\n\nUse the following test suite with $k=6$ and $E = 10^5$ (in $\\mathrm{Pa}$):\n- Case $1$: scheme FI, $\\nu = 0.3$.\n- Case $2$: scheme RI, $\\nu = 0.3$.\n- Case $3$: scheme SRI, $\\nu = 0.3$.\n- Case $4$: scheme FI, $\\nu = 0.4999$.\n- Case $5$: scheme SRI, $\\nu = 0.4999$.\n\nDesign for coverage:\n- Case $2$ should reveal spurious near-zero eigenvalues (hourglass modes) due to one-point reduced integration on $H_8$.\n- Cases $1$ and $3$ should be free of hourglass modes, with strictly positive smallest eigenvalues after boundary conditions.\n- Cases $4$ and $5$ compare the behavior near incompressibility, showing that selective reduced integration mitigates volumetric locking without introducing hourglass modes.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated Python-style list of lists. Each inner list must contain the $k$ smallest eigenvalues (in $\\mathrm{N}/\\mathrm{m}$) for one test case in ascending order, rounded to $6$ decimal places. The five inner lists must be ordered as the five cases above. For example, the output must have the form\n$[ [e_{1,1}, e_{1,2}, e_{1,3}, e_{1,4}, e_{1,5}, e_{1,6}], [e_{2,1}, \\dots, e_{2,6}], \\dots, [e_{5,1}, \\dots, e_{5,6}] ]$\nall on a single line, where $e_{i,j}$ denotes the $j$-th eigenvalue of case $i$.", "solution": "The user-provided problem is assessed as **valid**. It is a well-defined, scientifically-grounded problem in computational solid mechanics that adheres to established principles of the Finite Element Method (FEM). The problem is self-contained, with all necessary data, boundary conditions, and material properties provided. The objectives are clear and the test cases are designed to illustrate known numerical phenomena (volumetric locking and hourglassing), which is a standard pedagogical exercise.\n\n### Principle-Based Design of the Solution\n\nThe solution is based on the Finite Element Method (FEM) for three-dimensional linear elasticity. The process begins with the principle of virtual work, which, for a static solid with no external loads, is stated as:\n$$\n\\delta W = \\int_{\\Omega} \\boldsymbol{\\varepsilon}(\\delta\\mathbf{u}) : \\mathbb{C} : \\boldsymbol{\\varepsilon}(\\mathbf{u}) \\, \\mathrm{d}\\Omega = 0\n$$\nwhere $\\mathbf{u}$ is the displacement field, $\\delta\\mathbf{u}$ is a kinematically admissible virtual displacement field, $\\boldsymbol{\\varepsilon}$ is the small-strain tensor, $\\mathbb{C}$ is the fourth-order elasticity tensor, and $\\Omega$ is the material domain.\n\nThis continuous weak form is discretized by dividing the domain $\\Omega = [0,1]^3 \\ \\mathrm{m}^3$ into a mesh of $2 \\times 2 \\times 2 = 8$ trilinear hexahedral elements ($H_8$). Within each element $\\Omega_e$, the displacement field is approximated using isoparametric shape functions $N_i$ and nodal displacements $\\mathbf{d}^e$:\n$$\n\\mathbf{u}(\\boldsymbol{\\xi}) = \\sum_{i=1}^{8} N_i(\\boldsymbol{\\xi}) \\mathbf{u}_i\n$$\nwhere $\\boldsymbol{\\xi} = (\\xi, \\eta, \\zeta)$ are the coordinates in the parent element domain $[-1,1]^3$. This approximation leads to a discrete strain-displacement relationship $\\boldsymbol{\\varepsilon} = \\mathbf{B} \\mathbf{d}^e$, where $\\mathbf{B}$ is the strain-displacement matrix, which depends on the spatial derivatives of the shape functions.\n\nSubstituting the FE approximation into the principle of virtual work and considering arbitrary nodal virtual displacements $\\delta\\mathbf{d}$ yields the discrete system of linear equations $\\mathbf{K}\\mathbf{d} = \\mathbf{f}$. Since no external forces are applied, the system is homogeneous, and we analyze the properties of the global stiffness matrix $\\mathbf{K}$. The matrix $\\mathbf{K}$ is assembled from element stiffness matrices $\\mathbf{K}^e$:\n$$\n\\mathbf{K}^e = \\int_{\\Omega_e} \\mathbf{B}^T \\mathbf{C} \\mathbf{B} \\, \\mathrm{d}\\Omega\n$$\nwhere $\\mathbf{C}$ is the constitutive matrix in Voigt notation. For isotropic linear elasticity, it's defined by the Lamé parameters $\\lambda$ and $\\mu$. The integral is transformed to the parent domain and evaluated numerically using Gaussian quadrature:\n$$\n\\mathbf{K}^e = \\int_{-1}^{1}\\int_{-1}^{1}\\int_{-1}^{1} \\mathbf{B}(\\boldsymbol{\\xi})^T \\mathbf{C} \\mathbf{B}(\\boldsymbol{\\xi}) \\det(\\mathbf{J}) \\, \\mathrm{d}\\xi \\, \\mathrm{d}\\eta \\, \\mathrm{d}\\zeta \\approx \\sum_{g} w_g \\mathbf{B}(\\boldsymbol{\\xi}_g)^T \\mathbf{C} \\mathbf{B}(\\boldsymbol{\\xi}_g) \\det(\\mathbf{J}(\\boldsymbol{\\xi}_g))\n$$\nwhere $\\mathbf{J}$ is the Jacobian of the mapping from parent to physical coordinates, and $w_g$ and $\\boldsymbol{\\xi}_g$ are the quadrature weights and points, respectively. For the given uniform mesh, $\\det(\\mathbf{J})$ is constant for all elements.\n\nThe problem requires a modal analysis (computation of eigenvalues) of the stiffness matrix $\\mathbf{K}$ under three different numerical integration schemes:\n\n1.  **Full Integration (FI)**: The integral for $\\mathbf{K}^e$ is evaluated using a $2 \\times 2 \\times 2$ Gaussian quadrature rule. This rule is sufficient to exactly integrate the stiffness matrix for rectangular elements and is rank-sufficient, meaning it does not introduce non-physical zero-energy modes. However, for nearly incompressible materials ($\\nu \\to 0.5$), it can lead to \"volumetric locking,\" an artificial stiffening of the element's response.\n\n2.  **Reduced Integration (RI)**: The integral is evaluated using a single Gauss point at the element center $(\\xi, \\eta, \\zeta)=(0,0,0)$. This scheme is known to alleviate volumetric locking but is rank-deficient for $H_8$ elements, leading to spurious zero-energy modes known as \"hourglass modes.\" These modes manifest as near-zero eigenvalues in the stiffness matrix even after rigid-body motion is constrained.\n\n3.  **Selective Reduced Integration (SRI)**: This hybrid approach aims to combine the benefits of FI and RI. The constitutive behavior is decomposed into volumetric and deviatoric parts. The same decomposition applies to the stiffness matrix: $\\mathbf{K}^e = \\mathbf{K}^e_{vol} + \\mathbf{K}^e_{dev}$. The stiff volumetric part, which causes locking, is integrated using a reduced (single-point) rule, while the deviatoric part is fully integrated ($2 \\times 2 \\times 2$ rule). This simultaneously prevents locking and controls hourglass modes. The decomposition of the constitutive matrix is:\n    $$\n    \\mathbf{C} = \\mathbf{C}_{dev} + \\mathbf{C}_{vol}\n    $$\n    where $\\mathbf{C}_{vol} = K \\mathbf{m} \\mathbf{m}^T$, with $K=\\lambda + \\frac{2}{3}\\mu$ being the bulk modulus and $\\mathbf{m} = [1, 1, 1, 0, 0, 0]^T$. The element stiffness is then:\n    $$\n    \\mathbf{K}^e_{SRI} = \\left(\\int_{\\Omega_e} \\mathbf{B}^T \\mathbf{C}_{dev} \\mathbf{B} \\, \\mathrm{d}\\Omega\\right)_{\\text{FI}} + \\left(\\int_{\\Omega_e} \\mathbf{B}^T \\mathbf{C}_{vol} \\mathbf{B} \\, \\mathrm{d}\\Omega\\right)_{\\text{RI}}\n    $$\n\nThe global stiffness matrix $\\mathbf{K}$ is assembled by summing the contributions from all $8$ element matrices. Homogeneous Dirichlet boundary conditions ($u_x = u_y = u_z = 0$) are applied to the $z=0$ face. This is accomplished by identifying all degrees of freedom (DOFs) on this face and removing the corresponding rows and columns from $\\mathbf{K}$ to form a reduced, positive-definite matrix $\\mathbf{K}_{red}$ (except for the RI case).\n\nFinally, an eigenvalue analysis is performed on the symmetric matrix $\\mathbf{K}_{red}$. The $k=6$ smallest eigenvalues, which correspond to the softest deformation modes of the constrained structure, are computed using `scipy.linalg.eigh`.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef get_B_matrix(xi, eta, zeta, J_inv):\n    \"\"\"\n    Computes the strain-displacement matrix B for an H8 element at a given\n    point in parent coordinates.\n    J_inv is the inverse of the Jacobian matrix.\n    \"\"\"\n    # Parent coordinates of the 8 nodes of a standard H8 element\n    node_parent_coords = np.array([\n        [-1, -1, -1], [ 1, -1, -1], [ 1,  1, -1], [-1,  1, -1],\n        [-1, -1,  1], [ 1, -1,  1], [ 1,  1,  1], [-1,  1,  1]\n    ])\n\n    # Derivatives of shape functions w.r.t. parent coordinates (dNdxi)\n    dNdxi_eta_zeta = np.zeros((3, 8))\n    for i in range(8):\n        xi_i, eta_i, zeta_i = node_parent_coords[i]\n        dNdxi_eta_zeta[0, i] = 0.125 * xi_i * (1 + eta_i * eta) * (1 + zeta_i * zeta)\n        dNdxi_eta_zeta[1, i] = 0.125 * eta_i * (1 + xi_i * xi) * (1 + zeta_i * zeta)\n        dNdxi_eta_zeta[2, i] = 0.125 * zeta_i * (1 + xi_i * xi) * (1 + eta_i * eta)\n\n    # Derivatives of shape functions w.r.t. physical coordinates (dNdX)\n    dNdxyz = J_inv @ dNdxi_eta_zeta\n\n    # Assemble the B matrix (6x24)\n    B = np.zeros((6, 24))\n    for i in range(8):\n        dN_dx_i, dN_dy_i, dN_dz_i = dNdxyz[:, i]\n        B[0, 3*i    ] = dN_dx_i\n        B[1, 3*i + 1] = dN_dy_i\n        B[2, 3*i + 2] = dN_dz_i\n        B[3, 3*i    ] = dN_dy_i; B[3, 3*i + 1] = dN_dx_i\n        B[4, 3*i + 1] = dN_dz_i; B[4, 3*i + 2] = dN_dy_i\n        B[5, 3*i    ] = dN_dz_i; B[5, 3*i + 2] = dN_dx_i\n    return B\n\ndef calculate_element_stiffness(scheme, E, nu):\n    \"\"\"\n    Calculates the element stiffness matrix Ke for an H8 element based on the\n    integration scheme. All elements are identical cubes.\n    \"\"\"\n    h = 0.5  # Element side length\n    detJ = (h/2.0)**3\n    J_inv = np.diag([1.0 / (h / 2.0)] * 3)\n\n    # Material properties (Lamé parameters)\n    lmbda = E * nu / ((1 + nu) * (1 - 2 * nu))\n    mu = E / (2 * (1 + nu))\n\n    # Constitutive matrix C in Voigt notation\n    C = np.zeros((6, 6))\n    C[0, 0] = C[1, 1] = C[2, 2] = lmbda + 2 * mu\n    C[0, 1] = C[1, 0] = C[0, 2] = C[2, 0] = C[1, 2] = C[2, 1] = lmbda\n    C[3, 3] = C[4, 4] = C[5, 5] = mu\n    \n    Ke = np.zeros((24, 24))\n\n    if scheme == 'FI':\n        a = 1.0 / np.sqrt(3)\n        gps = [(x, y, z) for x in [-a, a] for y in [-a, a] for z in [-a, a]]\n        for xi, eta, zeta in gps:\n            B = get_B_matrix(xi, eta, zeta, J_inv)\n            Ke += B.T @ C @ B * 1.0 * detJ\n    elif scheme == 'RI':\n        B = get_B_matrix(0.0, 0.0, 0.0, J_inv)\n        Ke += B.T @ C @ B * 8.0 * detJ\n    elif scheme == 'SRI':\n        # Decompose C into deviatoric and volumetric parts\n        K_bulk = lmbda + 2.0/3.0 * mu\n        m = np.array([1, 1, 1, 0, 0, 0]).reshape(6, 1)\n        C_vol = K_bulk * (m @ m.T)\n        C_dev = C - C_vol\n\n        # Deviatoric part integrated with 2x2x2 rule\n        a = 1.0 / np.sqrt(3)\n        gps_dev = [(x, y, z) for x in [-a, a] for y in [-a, a] for z in [-a, a]]\n        for xi, eta, zeta in gps_dev:\n            B_dev = get_B_matrix(xi, eta, zeta, J_inv)\n            Ke += B_dev.T @ C_dev @ B_dev * 1.0 * detJ\n            \n        # Volumetric part integrated with 1-point rule\n        B_vol = get_B_matrix(0.0, 0.0, 0.0, J_inv)\n        Ke += B_vol.T @ C_vol @ B_vol * 8.0 * detJ\n    return Ke\n\ndef run_fem_analysis(scheme, E, nu, k):\n    \"\"\"\n    Runs the full FEM analysis: mesh, assembly, BCs, and eigenvalue solution.\n    \"\"\"\n    # Mesh properties\n    nx, ny, nz = 2, 2, 2\n    num_nodes_x, num_nodes_y, num_nodes_z = nx + 1, ny + 1, nz + 1\n    total_nodes = num_nodes_x * num_nodes_y * num_nodes_z\n    total_dofs = total_nodes * 3\n    \n    K_global = np.zeros((total_dofs, total_dofs))\n\n    # Pre-calculate the element stiffness matrix (all elements are identical)\n    Ke = calculate_element_stiffness(scheme, E, nu)\n\n    # Assemble the global stiffness matrix\n    for k_el in range(nz):\n        for j_el in range(ny):\n            for i_el in range(nx):\n                # Global node indices for this element\n                conn = np.array([\n                    (i_el)   + num_nodes_x*(j_el)   + num_nodes_x*num_nodes_y*(k_el),\n                    (i_el+1) + num_nodes_x*(j_el)   + num_nodes_x*num_nodes_y*(k_el),\n                    (i_el+1) + num_nodes_x*(j_el+1) + num_nodes_x*num_nodes_y*(k_el),\n                    (i_el)   + num_nodes_x*(j_el+1) + num_nodes_x*num_nodes_y*(k_el),\n                    (i_el)   + num_nodes_x*(j_el)   + num_nodes_x*num_nodes_y*(k_el+1),\n                    (i_el+1) + num_nodes_x*(j_el)   + num_nodes_x*num_nodes_y*(k_el+1),\n                    (i_el+1) + num_nodes_x*(j_el+1) + num_nodes_x*num_nodes_y*(k_el+1),\n                    (i_el)   + num_nodes_x*(j_el+1) + num_nodes_x*num_nodes_y*(k_el+1)\n                ], dtype=int)\n                \n                # Map element DOFs to global DOFs\n                dof_map = np.empty(24, dtype=int)\n                for i_node in range(8):\n                    dof_map[i_node*3 : i_node*3+3] = conn[i_node]*3 + np.arange(3)\n                \n                # Add element stiffness to global matrix\n                K_global[np.ix_(dof_map, dof_map)] += Ke\n\n    # Apply homogeneous Dirichlet boundary conditions on z=0 face\n    constrained_nodes = []\n    # k_node = 0 for the z=0 face\n    for j_node in range(num_nodes_y):\n        for i_node in range(num_nodes_x):\n            constrained_nodes.append(i_node + num_nodes_x * j_node)\n    \n    constrained_dofs = []\n    for node_idx in constrained_nodes:\n        constrained_dofs.extend([node_idx * 3, node_idx * 3 + 1, node_idx * 3 + 2])\n    \n    all_dofs = np.arange(total_dofs)\n    free_dofs = np.setdiff1d(all_dofs, constrained_dofs, assume_unique=True)\n    \n    K_reduced = K_global[np.ix_(free_dofs, free_dofs)]\n    \n    # Solve the eigenvalue problem for the k smallest eigenvalues\n    eigenvalues = eigh(K_reduced, eigvals_only=True, subset_by_index=[0, k-1])\n    \n    return eigenvalues\n\ndef solve():\n    test_cases = [\n        {'scheme': 'FI', 'nu': 0.3},\n        {'scheme': 'RI', 'nu': 0.3},\n        {'scheme': 'SRI', 'nu': 0.3},\n        {'scheme': 'FI', 'nu': 0.4999},\n        {'scheme': 'SRI', 'nu': 0.4999},\n    ]\n\n    E = 1e5\n    k = 6\n    \n    all_results = []\n    for case in test_cases:\n        eigenvalues = run_fem_analysis(case['scheme'], E, case['nu'], k)\n        rounded_eigs = [round(eig, 6) for eig in eigenvalues]\n        all_results.append(rounded_eigs)\n\n    # Format the output string to match the required format exactly\n    # repr() will create the string representation, then remove spaces\n    output_str = repr(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```", "id": "3599220"}, {"introduction": "Assembling the stiffness matrix is only half the battle; solving the resulting large, sparse linear system efficiently is paramount. This practical coding exercise investigates how reordering the matrix's rows and columns can dramatically impact the performance of direct solvers, which rely on matrix factorization. You will implement and compare different ordering strategies, including the widely-used Reverse Cuthill–McKee algorithm, and quantify their effectiveness by measuring matrix bandwidth and the fill-in generated during Cholesky factorization. This practice [@problem_id:3437048] highlights that the computational properties of the stiffness matrix are as important as its mathematical ones.", "problem": "Consider the symmetric, positive definite global stiffness matrix arising from a standard discretization of the homogeneous Dirichlet Poisson problem. Let $\\Omega = (0,1) \\times (0,1)$ and consider the boundary-value problem $-\\Delta u = f$ in $\\Omega$ with $u=0$ on $\\partial \\Omega$. Discretize $\\Omega$ with a uniform Cartesian grid of interior points arranged in $m$ rows and $n$ columns, with the standard $5$-point stencil for the Laplacian (this discretization is equivalent to the bilinear form from the classical conforming $\\mathcal{P}_1$ finite element method on a uniform mesh with piecewise constant diffusion, and the resulting algebraic system is identical to the $5$-point finite difference scheme). Index the unknowns in lexicographic row-major order so that each interior node $(i,j)$, with $i \\in \\{0,\\dots,m-1\\}$ and $j \\in \\{0,\\dots,n-1\\}$, maps to a global index $k = i n + j$. The resulting global stiffness matrix $K \\in \\mathbb{R}^{N \\times N}$, with $N = m n$, has entries $K_{kk} = 4$ and $K_{kl} = -1$ when nodes $k$ and $l$ are immediate $4$-neighbors on the grid (up, down, left, right), and $K_{kl} = 0$ otherwise. This matrix $K$ is symmetric and positive definite.\n\nDefine a permutation (reordering) $\\pi$ of the indices $\\{0,1,\\dots,N-1\\}$ as a bijection. Let $P \\in \\mathbb{R}^{N \\times N}$ be the corresponding permutation matrix and consider the reordered matrix $K^\\pi = P K P^\\top$. The symmetric bandwidth of $K^\\pi$ is defined as\n$$\nB(K^\\pi) = \\max_{\\substack{i,j \\in \\{0,\\dots,N-1\\} \\\\ K^\\pi_{ij} \\neq 0}} |i - j| + 1.\n$$\nConsider the Cholesky factorization $K^\\pi = L L^\\top$ where $L$ is lower triangular with positive diagonal. Define the strictly lower-triangular fill-in as the number of positions $(i,j)$ with $i > j$ such that $L_{ij} \\neq 0$ but $K^\\pi_{ij} = 0$. In concrete computations, treat entries with absolute value less than a small threshold as numerically zero.\n\nStarting from the variational formulation of the Poisson problem and the coherence of the discrete bilinear form, derive and implement algorithms that:\n- Construct the global stiffness matrix $K$ for given integers $m$ and $n$ as described above.\n- Build the adjacency graph of $K$ (ignore diagonal self-loops) and compute the Reverse Cuthill–McKee (RCM) permutation, denoted $\\pi_{\\mathrm{RCM}}$, using the graph structure.\n- Apply a given permutation $\\pi$ to form $K^\\pi$.\n- Compute $B(K^\\pi)$ as defined above.\n- Compute the strictly lower-triangular fill-in count induced by the Cholesky factorization of $K^\\pi$.\n\nYour program must implement the following reordering choices:\n- \"natural\": the identity permutation (no reordering), i.e., $\\pi(i) = i$.\n- \"rcm\": the Reverse Cuthill–McKee permutation computed from the adjacency of $K$.\n- \"random\": a random permutation computed with a fixed seed $42$ for reproducibility.\n\nUse the numerical zero threshold $\\varepsilon = 10^{-12}$ when deciding if a real-valued matrix entry is zero or nonzero.\n\nTest Suite:\nCompute the full symmetric bandwidth $B(K^\\pi)$ and the strictly lower-triangular fill-in count for the reordered stiffness matrix in each of the following cases:\n- Case $1$: $m=1$, $n=1$, ordering \"natural\".\n- Case $2$: $m=4$, $n=4$, ordering \"natural\".\n- Case $3$: $m=4$, $n=4$, ordering \"rcm\".\n- Case $4$: $m=8$, $n=4$, ordering \"natural\".\n- Case $5$: $m=8$, $n=4$, ordering \"rcm\".\n- Case $6$: $m=10$, $n=10$, ordering \"rcm\".\n- Case $7$: $m=10$, $n=10$, ordering \"random\" with seed $42$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case’s result must be a two-element list $[B, F]$, where $B$ is the full symmetric bandwidth and $F$ is the strictly lower-triangular fill-in count. The final output must therefore look like\n$$\n\\big[\\,[B_1,F_1], [B_2,F_2], \\dots, [B_7,F_7]\\,\\big].\n$$\nNo additional text must be printed.", "solution": "The user-provided problem is rigorously defined and scientifically sound, addressing a standard topic in numerical linear algebra for solving partial differential equations. All parameters, definitions, and tasks are specified with sufficient clarity and precision to permit a unique and verifiable solution. Therefore, the problem is deemed valid.\n\nThe solution proceeds systematically through the required tasks: constructing the global stiffness matrix, applying specified permutations, and calculating the resultant matrix properties—bandwidth and Cholesky factorization fill-in.\n\n### 1. Construction of the Global Stiffness Matrix $K$\n\nThe problem considers the Poisson equation $-\\Delta u = f$ on the unit square $\\Omega = (0,1) \\times (0,1)$ with homogeneous Dirichlet boundary conditions. The domain is discretized by a uniform Cartesian grid with $m$ rows and $n$ columns of interior nodes. The total number of unknowns is $N = mn$. The unknowns are indexed using a row-major lexicographic ordering, where the node at grid position $(i,j)$ for $i \\in \\{0, \\dots, m-1\\}$ and $j \\in \\{0, \\dots, n-1\\}$ corresponds to the single global index $k = i n + j$.\n\nThe standard $5$-point finite difference stencil for the negative Laplacian, $-\\Delta u$, at an interior node $(x_{i,j}, y_{i,j})$ is given by:\n$$\n-\\Delta u \\approx \\frac{4 u_{i,j} - u_{i-1, j} - u_{i+1, j} - u_{i, j-1} - u_{i, j+1}}{h^2}\n$$\nwhere $h$ is the uniform grid spacing. Ignoring the scaling factor $1/h^2$, the corresponding row in the global stiffness matrix $K$ for an interior node $k$ has a $4$ on the diagonal, and $-1$ in columns corresponding to its four immediate grid neighbors. Specifically, for a node $k$ corresponding to grid point $(i,j)$:\n- The diagonal entry is $K_{kk} = 4$.\n- The connection to the right neighbor $(i, j+1)$ (if $j < n-1$), with global index $l = i n + (j+1)$, results in $K_{kl} = -1$.\n- The connection to the neighbor below $(i+1, j)$ (if $i < m-1$), with global index $l' = (i+1)n + j$, results in $K_{kk'} = -1$.\n\nDue to the symmetry of the operator, the matrix $K$ is symmetric, i.e., $K_{lk} = K_{kl}$. All other off-diagonal entries are $0$. The matrix is constructed by iterating through all $N$ nodes and setting these non-zero entries.\n\n### 2. Matrix Reordering and Permutations\n\nFor a sparse matrix $K$, its properties like bandwidth and the fill-in during factorization depend on the ordering of its rows and columns. A permutation $\\pi$ of the indices $\\{0, \\dots, N-1\\}$ defines a reordering. If $P$ is the permutation matrix associated with $\\pi$, the reordered matrix is $K^\\pi = P K P^\\top$. In implementation, if $\\pi$ is an array of permuted indices, this corresponds to `K[pi, :][:, pi]`.\n\nThe problem requires analyzing three orderings:\n- **Natural Ordering**: The identity permutation, $\\pi(i)=i$. This is the baseline lexicographic ordering.\n- **Reverse Cuthill–McKee (RCM) Ordering**: A well-known heuristic algorithm designed to reduce the profile or envelope of a sparse matrix. A smaller profile typically leads to less fill-in during factorization like Cholesky. The algorithm works by building level sets from a peripheral node of the matrix's adjacency graph and then reversing the resulting ordering. We use the standard implementation provided by `scipy.sparse.csgraph.reverse_cuthill_mckee`.\n- **Random Ordering**: A random permutation, used here as a control to demonstrate the effects of a structure-destroying ordering. It is expected to yield poor results (large bandwidth and fill-in).\n\n### 3. Computation of Bandwidth and Fill-in\n\nTwo metrics are computed for the permuted matrix $K^\\pi$.\n\n- **Symmetric Bandwidth**: The problem defines this as $B(K^\\pi) = \\max_{i,j : K^\\pi_{ij} \\neq 0} |i - j| + 1$. This is implemented by finding all non-zero entries of $K^\\pi$ (above a numerical threshold $\\varepsilon = 10^{-12}$), calculating the absolute difference of their row and column indices, and taking the maximum of these differences, plus one.\n\n- **Strictly Lower-Triangular Fill-in**: During the Cholesky factorization $K^\\pi = LL^\\top$, new non-zero entries, known as \"fill-in,\" may appear in the factor $L$ at positions where $K^\\pi$ was zero. The fill-in count is the number of such positions. It is calculated by performing the Cholesky factorization of $K^\\pi$ to get $L$ using `scipy.linalg.cholesky`, and then counting the number of pairs $(i,j)$ with $i > j$ where $|L_{ij}|> \\varepsilon$ but $|K^\\pi_{ij}| \\le \\varepsilon$.\n\n### 4. Algorithmic Procedure\n\nThe solution involves a main function that iterates through the specified test cases. For each case $(m, n, \\text{ordering})$:\n1. Construct the $mn \\times mn$ stiffness matrix $K$ using the natural ordering.\n2. Generate the permutation array $\\pi$ based on the specified ordering type.\n3. Apply the permutation to obtain $K^\\pi = K[\\pi, :][:, \\pi]$.\n4. Compute the bandwidth $B(K^\\pi)$.\n5. Compute the Cholesky factor $L$ of $K^\\pi$.\n6. Compute the fill-in count $F$ by comparing the structures of $K^\\pi$ and $L$.\n7. Store the pair $[B, F]$ and proceed to the next case.\nFinally, the collected results are formatted into the specified string format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import reverse_cuthill_mckee\nfrom scipy.linalg import cholesky\n\ndef construct_stiffness_matrix(m, n):\n    \"\"\"\n    Constructs the global stiffness matrix K for an m x n grid.\n    \n    Args:\n        m (int): Number of rows of interior grid points.\n        n (int): Number of columns of interior grid points.\n        \n    Returns:\n        numpy.ndarray: The NxN global stiffness matrix, where N = m*n.\n    \"\"\"\n    N = m * n\n    if N == 0:\n        return np.array([[]])\n    \n    K = np.zeros((N, N), dtype=np.float64)\n    \n    for i in range(m):\n        for j in range(n):\n            k = i * n + j\n            \n            # Diagonal entry\n            K[k, k] = 4\n            \n            # Off-diagonal entries for 4-neighbors\n            # Right neighbor\n            if j < n - 1:\n                l = i * n + (j + 1)\n                K[k, l] = -1.0\n                K[l, k] = -1.0\n            \n            # Bottom neighbor\n            if i < m - 1:\n                l = (i + 1) * n + j\n                K[k, l] = -1.0\n                K[l, k] = -1.0\n                \n    return K\n\ndef compute_bandwidth(matrix, epsilon=1e-12):\n    \"\"\"\n    Computes the symmetric bandwidth of a matrix as per the problem definition.\n    B(A) = max |i-j| + 1 for A_ij != 0.\n    \n    Args:\n        matrix (numpy.ndarray): The input matrix.\n        epsilon (float): Threshold to consider an entry as non-zero.\n        \n    Returns:\n        int: The symmetric bandwidth.\n    \"\"\"\n    if matrix.shape[0] == 0:\n        return 0\n    if matrix.shape[0] == 1:\n        return 1\n\n    rows, cols = np.nonzero(np.abs(matrix) > epsilon)\n    \n    if rows.size == 0:\n        # This case won't be reached for SPD matrices of size > 0\n        return 1\n        \n    return np.max(np.abs(rows - cols)) + 1\n\ndef compute_fill_in(original_matrix, cholesky_factor, epsilon=1e-12):\n    \"\"\"\n    Computes the strictly lower-triangular fill-in count.\n    \n    Args:\n        original_matrix (numpy.ndarray): The permuted stiffness matrix K_pi.\n        cholesky_factor (numpy.ndarray): The lower triangular Cholesky factor L.\n        epsilon (float): Threshold for non-zero entries.\n        \n    Returns:\n        int: The number of fill-in entries.\n    \"\"\"\n    if original_matrix.shape[0] <= 1:\n        return 0\n        \n    # Create masks for the strictly lower triangular part\n    k_pi_lower_is_zero = np.abs(np.tril(original_matrix, k=-1)) <= epsilon\n    l_lower_is_nonzero = np.abs(np.tril(cholesky_factor, k=-1)) > epsilon\n    \n    fill_in_count = np.sum(np.logical_and(k_pi_lower_is_zero, l_lower_is_nonzero))\n    \n    return int(fill_in_count)\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # (m, n, ordering_type)\n        (1, 1, \"natural\"),\n        (4, 4, \"natural\"),\n        (4, 4, \"rcm\"),\n        (8, 4, \"natural\"),\n        (8, 4, \"rcm\"),\n        (10, 10, \"rcm\"),\n        (10, 10, \"random\"),\n    ]\n\n    epsilon = 1e-12\n    results = []\n\n    for m, n, ordering in test_cases:\n        N = m * n\n        K = construct_stiffness_matrix(m, n)\n\n        pi = None\n        if ordering == \"natural\":\n            pi = np.arange(N)\n        elif ordering == \"rcm\":\n            if N > 0:\n                # The CSR graph representation is needed for the RCM algorithm.\n                graph = csr_matrix(K)\n                pi = reverse_cuthill_mckee(graph)\n            else:\n                pi = np.array([], dtype=int)\n        elif ordering == \"random\":\n            rng = np.random.default_rng(seed=42)\n            pi = rng.permutation(N)\n\n        if N > 0:\n            # Apply the permutation to get the reordered matrix K_pi\n            K_pi = K[pi, :][:, pi]\n            \n            # Compute bandwidth\n            B = compute_bandwidth(K_pi, epsilon)\n            \n            # Compute Cholesky factorization and fill-in\n            # The matrix is SPD, so Cholesky factorization will succeed.\n            L = cholesky(K_pi, lower=True)\n            F = compute_fill_in(K_pi, L, epsilon)\n        else: # Should not happen with the given test cases\n            B, F = 0, 0\n            \n        results.append([B, F])\n\n    # Format the final output string exactly as required, without extra spaces.\n    formatted_results = [f\"[{b},{f}]\" for b, f in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3437048"}]}