{"hands_on_practices": [{"introduction": "To begin exploring the numerical behavior of the collisional Boltzmann equation, we start with a simplified yet powerful model known as the relaxation-time approximation. This approach captures the essential physical outcome of collisions—the damping of anisotropies and the evolution of the photon distribution towards an isotropic state. This exercise [@problem_id:3493968] provides a hands-on opportunity to implement a basic time-evolution algorithm and validate it against an exact analytical solution, a fundamental skill in computational physics.", "problem": "Consider the collisional Boltzmann equation for the photon angular distribution in a spatially homogeneous medium. Let the photon distribution be represented by $f(\\mu,t)$, where $\\mu \\in [-1,1]$ is the cosine of the angle between the photon propagation direction and a fixed axis, and $t$ is a dimensionless time. Assume the photon scattering is represented by an isotropic relaxation-time collision operator with a time-dependent rate $\\nu(t) \\ge 0$, so that the evolution is given by\n$$\n\\frac{\\partial f(\\mu,t)}{\\partial t} = \\mathcal{C}[f](\\mu,t), \\quad \\mathcal{C}[f](\\mu,t) = -\\nu(t)\\left(f(\\mu,t) - \\langle f \\rangle(t)\\right),\n$$\nwhere the angular mean $\\langle f \\rangle(t)$ is defined by the uniform angular average in $\\mu$,\n$$\n\\langle f \\rangle(t) = \\frac{1}{2}\\int_{-1}^{1} f(\\mu,t)\\, d\\mu.\n$$\nThis isotropic relaxation operator is a scientifically valid toy-model for Thomson scattering in the tight-coupling regime, preserving the angular mean and damping anisotropies, and it is widely used for numerical validation of schemes in numerical cosmology.\n\nYour task is to numerically evolve $f(\\mu,t)$ on a discrete angular grid using an explicit forward-Euler time integrator and validate the evolution against the exact solution in this toy-model. Use the following requirements:\n\n- Discretize $\\mu$ uniformly with $N$ bins on $[-1,1]$. Denote these grid points by $\\{\\mu_i\\}_{i=1}^N$.\n- Initialize with a dimensionless anisotropic distribution\n$$\nf(\\mu,0) = A + \\alpha\\, \\mu + \\beta\\, P_2(\\mu),\n$$\nwhere $A$, $\\alpha$, and $\\beta$ are real constants and $P_2(\\mu) = \\frac{1}{2}\\left(3\\mu^2 - 1\\right)$ is the second Legendre polynomial.\n- Evolve the discrete distribution $f_i^n \\approx f(\\mu_i,t_n)$ with $t_n = n\\, \\Delta t$, using\n$$\nf_i^{n+1} = f_i^n + \\Delta t\\left(-\\nu(t_n)\\left[f_i^n - \\overline{f}^n\\right]\\right),\n$$\nwhere $\\overline{f}^n = \\frac{1}{N}\\sum_{j=1}^{N} f_j^n$ is the arithmetic mean of the discrete angular values. This choice preserves the discrete mean exactly under the update.\n- For validation, the exact continuous-time solution for this collision operator has conserved mean and exponentially damped deviations from the mean governed by the integrated rate. Specifically, if $\\delta f(\\mu,t) = f(\\mu,t) - \\langle f \\rangle(t)$ and $\\mathcal{I}(t) = \\int_0^t \\nu(s)\\, ds$, then\n$$\n\\delta f(\\mu,t) = \\delta f(\\mu,0)\\, e^{-\\mathcal{I}(t)}, \\quad f(\\mu,t) = \\langle f \\rangle(0) + \\delta f(\\mu,0)\\, e^{-\\mathcal{I}(t)}.\n$$\n- In your implementation, compute the discrete exact solution by replacing $\\langle f \\rangle(0)$ with the discrete arithmetic mean at $t=0$ and using the appropriate closed-form for $\\mathcal{I}(T)$ given each $\\nu(t)$ specification.\n\nCompute the numerical solution at the final time $T$ for each test case below, and report the maximum absolute error over the angular grid between the numerical solution and the discrete exact solution, i.e.,\n$$\n\\epsilon_{\\max} = \\max_{i \\in \\{1,\\ldots,N\\}} \\left| f_i^{\\mathrm{num}}(T) - f_i^{\\mathrm{exact}}(T) \\right|.\n$$\nAll quantities are dimensionless; no physical units are required.\n\nImplement the program in the Python language, adhering strictly to the execution environment described in the final answer specification. Your program must hard-code the following test suite of parameter values and produce a single line of output containing the errors for all test cases as a comma-separated list enclosed in square brackets.\n\nTest Suite:\n1. Case $1$ (general validation, smooth decay): $N=200$, $\\Delta t=10^{-3}$, $T=1.0$, $A=1.0$, $\\alpha=0.07$, $\\beta=-0.11$, $\\nu(t)=1.3$ constant.\n2. Case $2$ (piecewise rate, onset of scattering): $N=50$, $\\Delta t=10^{-2}$, $T=1.0$, $A=1.0$, $\\alpha=0.2$, $\\beta=0.05$, $\\nu(t)=0$ for $0 \\le t < t_0$, and $\\nu(t)=0.8$ for $t \\ge t_0$, with $t_0=0.6$.\n3. Case $3$ (decaying optical depth rate): $N=120$, $\\Delta t=5\\times 10^{-3}$, $T=2.0$, $A=1.0$, $\\alpha=-0.15$, $\\beta=0.25$, $\\nu(t)=\\nu_0 e^{-\\lambda t}$ with $\\nu_0=1.5$ and $\\lambda=1.0$.\n4. Case $4$ (near stability boundary for explicit Euler): $N=80$, $\\Delta t=1.9$, $T=3.8$, $A=1.0$, $\\alpha=0.5$, $\\beta=-0.4$, $\\nu(t)=1.0$ constant.\n5. Case $5$ (collisionless limit): $N=30$, $\\Delta t=2\\times 10^{-2}$, $T=0.4$, $A=1.0$, $\\alpha=-0.3$, $\\beta=0.1$, $\\nu(t)=0$ constant.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4,r_5]$), where each $r_i$ is the value of $\\epsilon_{\\max}$ for the corresponding test case expressed as a floating-point number.", "solution": "The problem requires solving the collisional Boltzmann equation under the relaxation-time approximation, $\\frac{\\partial f}{\\partial t} = -\\nu(t)(f - \\langle f \\rangle)$, using a forward Euler time-stepping scheme. The solution involves several steps:\n\n1.  **Analytical Solution**: First, we identify the exact solution to the continuous equation. The angular mean $\\langle f \\rangle(t) = \\frac{1}{2}\\int_{-1}^{1} f(\\mu,t)d\\mu$ is a conserved quantity because the collision operator integrates to zero over angle. This means $\\langle f \\rangle(t) = \\langle f \\rangle(0)$ for all time. The anisotropic part of the distribution, $\\delta f(\\mu,t) = f(\\mu,t) - \\langle f \\rangle(t)$, evolves according to $\\frac{d}{dt}(\\delta f) = -\\nu(t) \\delta f$. This is a simple first-order ODE with the solution $\\delta f(\\mu,t) = \\delta f(\\mu,0) e^{-\\mathcal{I}(t)}$, where $\\mathcal{I}(t) = \\int_0^t \\nu(s)ds$ is the integrated scattering rate. The full exact solution is thus $f(\\mu,t) = \\langle f \\rangle(0) + \\delta f(\\mu,0) e^{-\\mathcal{I}(t)}$.\n\n2.  **Discretization and Numerical Scheme**:\n    *   **Angular Grid**: The angular domain $\\mu \\in [-1,1]$ is discretized into $N$ uniformly spaced points $\\mu_i$. The angular mean is approximated by the discrete arithmetic mean $\\overline{f}^n = \\frac{1}{N}\\sum_j f_j^n$.\n    *   **Time Integration**: A forward Euler scheme is used for time evolution. The discrete update rule for the distribution $f_i$ at time step $n$ is given by $f_i^{n+1} = f_i^n + \\Delta t \\, C_i^n$, where $C_i^n = -\\nu(t_n)(f_i^n - \\overline{f}^n)$ is the discrete collision operator.\n\n3.  **Implementation and Validation**:\n    *   The algorithm initializes the distribution $f_i^0$ on the angular grid based on the given formula $f(\\mu,0) = A + \\alpha\\mu + \\beta P_2(\\mu)$.\n    *   It then enters a time loop, repeatedly applying the forward Euler update for `T / dt` steps.\n    *   For validation, the discrete version of the exact solution is computed at the final time $T$. This involves calculating the initial discrete mean $\\overline{f}^0$ and the analytical integral $\\mathcal{I}(T)$ for each test case's specific $\\nu(t)$.\n    *   The final numerical solution is compared against this exact solution, and the maximum absolute error across the angular grid is reported.\n\n4.  **Test Case Analysis**: The test suite is designed to probe different aspects of the numerical solver. Case 1 is a standard validation. Case 2 tests a piecewise scattering rate. Case 3 uses an exponentially decaying rate. Case 4 tests the scheme near the stability limit of the explicit Euler method (where $\\Delta t \\cdot \\nu \\approx 2$). Case 5 tests the collisionless limit ($\\nu=0$), where the distribution should remain unchanged.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the collisional Boltzmann equation for the given test cases and\n    computes the maximum absolute error against the exact solution.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: general validation, smooth decay\n        {\n            'N': 200, 'dt': 1e-3, 'T': 1.0, 'A': 1.0, 'alpha': 0.07, 'beta': -0.11,\n            'nu': lambda t: 1.3,\n            'I_T': 1.3 * 1.0\n        },\n        # Case 2: piecewise rate, onset of scattering\n        {\n            'N': 50, 'dt': 1e-2, 'T': 1.0, 'A': 1.0, 'alpha': 0.2, 'beta': 0.05,\n            'nu': lambda t, t0=0.6: 0.8 if t >= t0 else 0.0,\n            'I_T': 0.8 * (1.0 - 0.6)\n        },\n        # Case 3: decaying optical depth rate\n        {\n            'N': 120, 'dt': 5e-3, 'T': 2.0, 'A': 1.0, 'alpha': -0.15, 'beta': 0.25,\n            'nu': lambda t, nu0=1.5, lam=1.0: nu0 * np.exp(-lam * t),\n            'I_T': (1.5 / 1.0) * (1.0 - np.exp(-1.0 * 2.0))\n        },\n        # Case 4: near stability boundary for explicit Euler\n        {\n            'N': 80, 'dt': 1.9, 'T': 3.8, 'A': 1.0, 'alpha': 0.5, 'beta': -0.4,\n            'nu': lambda t: 1.0,\n            'I_T': 1.0 * 3.8\n        },\n        # Case 5: collisionless limit\n        {\n            'N': 30, 'dt': 2e-2, 'T': 0.4, 'A': 1.0, 'alpha': -0.3, 'beta': 0.1,\n            'nu': lambda t: 0.0,\n            'I_T': 0.0\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        # Unpack parameters\n        N, dt, T = case['N'], case['dt'], case['T']\n        A, alpha, beta = case['A'], case['alpha'], case['beta']\n        nu, I_T = case['nu'], case['I_T']\n\n        # 1. Setup grid and initial condition\n        mu_grid = np.linspace(-1.0, 1.0, N)\n        P2_mu = 0.5 * (3 * mu_grid**2 - 1)\n        f_initial = A + alpha * mu_grid + beta * P2_mu\n        \n        # 2. Numerical evolution using Forward Euler\n        f_num = f_initial.copy()\n        \n        # Determine the number of time steps\n        num_steps = int(round(T / dt))\n        \n        for n in range(num_steps):\n            t_n = n * dt\n            \n            # Calculate discrete mean\n            f_bar_n = np.mean(f_num)\n            \n            # Get scattering rate at current time\n            nu_t = nu(t_n)\n            \n            # Apply forward Euler update\n            f_num = f_num - dt * nu_t * (f_num - f_bar_n)\n            \n        # f_num now holds the numerical solution at time T\n        \n        # 3. Compute the exact solution\n        \n        # Initial discrete mean\n        f_bar_0 = np.mean(f_initial)\n        \n        # Initial deviation from the mean\n        delta_f_0 = f_initial - f_bar_0\n        \n        # Exact solution at time T\n        f_exact = f_bar_0 + delta_f_0 * np.exp(-I_T)\n        \n        # 4. Calculate maximum absolute error\n        max_error = np.max(np.abs(f_num - f_exact))\n        results.append(max_error)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3493968"}, {"introduction": "After understanding the general principle of collisional relaxation, we now turn to the specific physical process governing photon interactions in the early universe: Thomson scattering. The precise mathematical form of the collision operator is determined by the Thomson scattering cross-section. This practice [@problem_id:3493982] guides you through the crucial steps of deriving the azimuthally-averaged scattering kernel from first principles and numerically verifying its fundamental properties, such as normalization and symmetry, which are essential for ensuring that any simulation correctly conserves photon number and handles isotropic distributions.", "problem": "Consider the collisional Boltzmann equation for the photon phase-space distribution function $f(\\mathbf{x}, \\mathbf{p}, t)$ under elastic Thomson scattering by stationary electrons in a spatially homogeneous setting. Neglect spatial gradients and metric effects so that the evolution is governed solely by the collision operator. The resulting ordinary differential equation is $\\partial_t f(\\hat{\\mathbf{n}}, \\nu, t) = C[f](\\hat{\\mathbf{n}}, \\nu, t)$, where $\\hat{\\mathbf{n}}$ denotes the photon propagation direction unit vector and $\\nu$ denotes the dimensionless photon frequency (treated as a parameter since Thomson scattering does not change photon energy to leading order). The Thomson differential cross section is given by the well-tested formula $\\frac{d\\sigma}{d\\Omega} = \\frac{3\\sigma_\\mathrm{T}}{16\\pi}\\left(1+\\cos^2\\theta\\right)$, where $\\theta$ is the scattering angle between incident and outgoing directions, and $\\sigma_\\mathrm{T}$ is the Thomson cross section. For stationary electrons, the corresponding collision operator redistributes photons over directions while preserving photon number. Work in a dimensionless system where the overall collision rate is captured by a single parameter $\\nu$, absorbing the electron number density, the Thomson cross section, and the speed of light into a single rate so that $C[f]$ has the structure $C[f](\\hat{\\mathbf{n}}) = \\nu\\left(-f(\\hat{\\mathbf{n}}) + \\int d\\Omega'\\, K(\\hat{\\mathbf{n}}\\cdot\\hat{\\mathbf{n}}')\\, f(\\hat{\\mathbf{n}}')\\right)$, with a normalized kernel $K$ derived from the Thomson phase function.\n\nStarting from these fundamental elements, and assuming axial symmetry about a fixed axis so that $f$ depends only on the cosine of the polar angle $\\mu = \\cos\\theta \\in [-1, 1]$, derive the axisymmetric form of the collision kernel $K$ averaged over the azimuthal angle of the incident direction. Show that the kernel normalization implies that the integral of the scattering-in term over incident solid angle equals the scattering-out term for an isotropic $f$, and that photon number $\\int d\\Omega\\, f$ is conserved by the collision operator for arbitrary $f$. Discretize the axisymmetric integral over $\\mu$ using Gauss–Legendre quadrature with $N$ nodes, and implement the discrete collision operator $C_i = \\nu\\left(-f_i + \\sum_{j=1}^{N} w_j\\, S(\\mu_i, \\mu_j)\\, f_j\\right)$, where $\\{\\mu_i, w_i\\}$ are the quadrature nodes and weights on $[-1,1]$, and $S(\\mu_i, \\mu_j)$ is the azimuth-averaged axisymmetric Thomson kernel that you derive. Your implementation should use a numerically stable construction of the kernel from first principles and must not assume any non-physical shortcuts.\n\nYou must produce a single self-contained program that constructs the discrete kernel, applies the collision operator, and performs invariant checks to test numerical precision. In particular, for the given test suite, calculate the following residuals:\n- Kernel normalization residual $r_\\mathrm{norm}(N) = \\max_i \\left| \\sum_{j=1}^{N} w_j\\, S(\\mu_i, \\mu_j) - 1 \\right|$.\n- Isotropic fixed-point residual $r_\\mathrm{iso}(N, A) = \\max_i \\left| C_i[f \\equiv A] \\right|$, for constant $f(\\mu) \\equiv A$.\n- Photon number conservation residual $r_\\mathrm{num}(N) = \\left| \\sum_{i=1}^{N} w_i\\, C_i[f] \\right|$, for a specified anisotropic $f$.\n- Kernel symmetry residual $r_\\mathrm{sym}(N) = \\max_{i,j} \\left| S(\\mu_i, \\mu_j) - S(\\mu_j, \\mu_i) \\right|$.\n\nUse the following test suite parameters:\n- Case $1$: $N = 8$, compute $r_\\mathrm{norm}(N)$.\n- Case $2$: $N = 32$, $A = 1.3$, compute $r_\\mathrm{iso}(N, A)$.\n- Case $3$: $N = 32$, anisotropic $f(\\mu) = 1 + 0.2\\, \\mu + 0.1\\, P_2(\\mu)$ where $P_2(\\mu) = \\frac{3\\mu^2 - 1}{2}$, compute $r_\\mathrm{num}(N)$.\n- Case $4$: $N = 16$, compute $r_\\mathrm{sym}(N)$.\n\nAll quantities are dimensionless; no physical units are required. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[r_\\mathrm{norm}(8), r_\\mathrm{iso}(32, 1.3), r_\\mathrm{num}(32), r_\\mathrm{sym}(16)]$. Each entry must be a real number (float). The output format must be exactly one line matching the template $[r_1,r_2,r_3,r_4]$.", "solution": "The problem requires the derivation, discretization, and implementation of the collisional Boltzmann operator for elastic Thomson scattering in a spatially homogeneous, axisymmetric system. The solution proceeds in several steps: derivation of the axisymmetric kernel, verification of its fundamental properties, numerical discretization, and implementation of numerical tests.\n\n### 1. Derivation of the Axisymmetric Scattering Kernel\n\nThe evolution of the photon phase-space distribution function $f$ under Thomson scattering is given by the collisional Boltzmann equation, which, under the specified assumptions, simplifies to $\\partial_t f(\\hat{\\mathbf{n}}) = C[f](\\hat{\\mathbf{n}})$. The collision operator $C[f]$ is given as:\n$$\nC[f](\\hat{\\mathbf{n}}) = \\nu\\left(-f(\\hat{\\mathbf{n}}) + \\int_{4\\pi} d\\Omega'\\, K(\\hat{\\mathbf{n}}\\cdot\\hat{\\mathbf{n}}')\\, f(\\hat{\\mathbf{n}}')\\right)\n$$\nHere, $\\hat{\\mathbf{n}}$ and $\\hat{\\mathbf{n}}'$ are the outgoing and incident photon direction unit vectors, respectively. The parameter $\\nu$ is the total scattering rate. The term $- \\nu f(\\hat{\\mathbf{n}})$ represents photons scattered out of the direction $\\hat{\\mathbf{n}}$, while the integral term represents photons scattered into $\\hat{\\mathbf{n}}$ from all other directions $\\hat{\\mathbf{n}}'$.\n\nThe scattering kernel $K$ is derived from the differential cross section, $\\frac{d\\sigma}{d\\Omega} = \\frac{3\\sigma_\\mathrm{T}}{16\\pi}\\left(1+\\cos^2\\Theta\\right)$, where $\\Theta$ is the scattering angle between $\\hat{\\mathbf{n}}$ and $\\hat{\\mathbf{n}}'$, i.e., $\\cos\\Theta = \\hat{\\mathbf{n}}\\cdot\\hat{\\mathbf{n}}'$. The kernel $K$ is the normalized scattering phase function, given by $K(\\hat{\\mathbf{n}}\\cdot\\hat{\\mathbf{n}}') = \\frac{1}{\\sigma_\\mathrm{T}}\\frac{d\\sigma}{d\\Omega} = \\frac{3}{16\\pi}\\left(1+(\\hat{\\mathbf{n}}\\cdot\\hat{\\mathbf{n}}')^2\\right)$. The kernel is normalized such that $\\int_{4\\pi} K(\\hat{\\mathbf{n}}\\cdot\\hat{\\mathbf{n}}') d\\Omega' = 1$.\n\nThe problem specifies axial symmetry, meaning $f$ depends only on $\\mu = \\cos\\theta$, where $\\theta$ is the polar angle with respect to a fixed axis, say $\\hat{\\mathbf{z}}$. Thus, $f(\\hat{\\mathbf{n}}) = f(\\mu)$. To obtain the collision operator for $f(\\mu)$, we average over the azimuthal angle. Let $\\hat{\\mathbf{n}}$ have polar angle $\\theta$ (so $\\mu=\\cos\\theta$) and azimuthal angle $\\phi$. Let $\\hat{\\mathbf{n}}'$ have polar angle $\\theta'$ (so $\\mu'=\\cos\\theta'$) and azimuthal angle $\\phi'$.\nThe dot product is $\\hat{\\mathbf{n}}\\cdot\\hat{\\mathbf{n}}' = \\mu\\mu' + \\sqrt{1-\\mu^2}\\sqrt{1-\\mu'^2}\\cos(\\phi-\\phi')$.\n\nThe gain term becomes $\\int_{-1}^{1} d\\mu' \\int_{0}^{2\\pi} d\\phi' K(\\hat{\\mathbf{n}}\\cdot\\hat{\\mathbf{n}}') f(\\mu')$. By axisymmetry, the resulting operator must be independent of $\\phi$. We can define an axisymmetric kernel $S(\\mu, \\mu')$ by integrating over the relative azimuth $\\Delta\\phi = \\phi - \\phi'$:\n$$\nS(\\mu, \\mu') = \\int_{0}^{2\\pi} K(\\hat{\\mathbf{n}}\\cdot\\hat{\\mathbf{n}}') d\\phi' = \\int_{0}^{2\\pi} \\frac{3}{16\\pi}\\left(1+\\left(\\mu\\mu' + \\sqrt{(1-\\mu^2)(1-\\mu'^2)}\\cos(\\Delta\\phi)\\right)^2\\right) d(\\Delta\\phi)\n$$\nExpanding the square and integrating term by term, we use the facts that $\\int_0^{2\\pi} \\cos(\\Delta\\phi) d(\\Delta\\phi) = 0$ and $\\int_0^{2\\pi} \\cos^2(\\Delta\\phi) d(\\Delta\\phi) = \\pi$:\n$$\nS(\\mu, \\mu') = \\frac{3}{16\\pi} \\left[ \\int_0^{2\\pi} \\left(1 + (\\mu\\mu')^2\\right) d(\\Delta\\phi) + (1-\\mu^2)(1-\\mu'^2) \\int_0^{2\\pi} \\cos^2(\\Delta\\phi) d(\\Delta\\phi) \\right]\n$$\n$$\nS(\\mu, \\mu') = \\frac{3}{16\\pi} \\left[ 2\\pi(1 + \\mu^2\\mu'^2) + \\pi(1-\\mu^2)(1-\\mu'^2) \\right]\n$$\nSimplifying this expression yields the final form of the axisymmetric kernel:\n$$\nS(\\mu, \\mu') = \\frac{3}{16} \\left[ 2(1 + \\mu^2\\mu'^2) + (1-\\mu^2)(1-\\mu'^2) \\right] = \\frac{3}{16} \\left( 3 - \\mu^2 - \\mu'^2 + 3\\mu^2\\mu'^2 \\right)\n$$\nThe axisymmetric Boltzmann equation is then:\n$$\n\\partial_t f(\\mu) = C[f](\\mu) = \\nu\\left(-f(\\mu) + \\int_{-1}^{1} f(\\mu') S(\\mu, \\mu') d\\mu' \\right)\n$$\n\n### 2. Verification of Fundamental Properties\n\nThe derived kernel and collision operator must satisfy key physical principles.\n\n**Kernel Normalization and Isotropic Fixed Point**: For scattering to be a redistribution process, the total probability of scattering from a given direction into any other direction must be unity. For the axisymmetric kernel, this translates to $\\int_{-1}^{1} S(\\mu, \\mu') d\\mu' = 1$. Let's verify this:\n$$\n\\int_{-1}^{1} \\frac{3}{16} \\left( 3 - \\mu^2 - \\mu'^2 + 3\\mu^2\\mu'^2 \\right) d\\mu' = \\frac{3}{16} \\int_{-1}^{1} \\left( (3-\\mu^2) + \\mu'^2(3\\mu^2 - 1) \\right) d\\mu'\n$$\n$$\n= \\frac{3}{16} \\left[ (3-\\mu^2)\\mu' + (3\\mu^2-1)\\frac{\\mu'^3}{3} \\right]_{-1}^{1} = \\frac{3}{16} \\left[ 2(3-\\mu^2) + \\frac{2}{3}(3\\mu^2-1) \\right]\n$$\n$$\n= \\frac{3}{16} \\left[ 6 - 2\\mu^2 + 2\\mu^2 - \\frac{2}{3} \\right] = \\frac{3}{16} \\left( \\frac{18-2}{3} \\right) = \\frac{3}{16} \\frac{16}{3} = 1\n$$\nThis normalization ensures that if the distribution is isotropic, $f(\\mu) = A$ (a constant), the collision operator vanishes:\n$C[f=A] = \\nu(-A + \\int_{-1}^{1} A S(\\mu, \\mu') d\\mu') = \\nu(-A + A \\int_{-1}^{1} S(\\mu, \\mu') d\\mu') = \\nu(-A+A) = 0$. This confirms that an isotropic photon field is a steady-state (fixed point) of the collision operator.\n\n**Kernel Symmetry and Photon Number Conservation**: The total number of photons in the system is proportional to $\\mathcal{N} = \\int d\\Omega f = 2\\pi \\int_{-1}^{1} f(\\mu) d\\mu$. For elastic scattering, this number must be conserved, i.e., $\\frac{d\\mathcal{N}}{dt} = 0$. This requires $\\int_{-1}^{1} C[f](\\mu) d\\mu = 0$.\n$$\n\\int_{-1}^{1} C[f](\\mu) d\\mu = \\nu \\int_{-1}^{1} \\left(-f(\\mu) + \\int_{-1}^{1} f(\\mu') S(\\mu, \\mu') d\\mu' \\right) d\\mu\n$$\n$$\n= \\nu \\left( -\\int_{-1}^{1} f(\\mu) d\\mu + \\int_{-1}^{1} d\\mu \\int_{-1}^{1} d\\mu' S(\\mu, \\mu') f(\\mu') \\right)\n$$\nBy inspection, the kernel $S(\\mu, \\mu') = \\frac{3}{16} (3 - \\mu^2 - \\mu'^2 + 3\\mu^2\\mu'^2)$ is symmetric under the exchange of $\\mu$ and $\\mu'$, i.e., $S(\\mu, \\mu') = S(\\mu', \\mu)$. Using this symmetry, we can swap the integration variables in the double integral and exchange the order of integration (Fubini's theorem):\n$$\n\\int_{-1}^{1} d\\mu' f(\\mu') \\left( \\int_{-1}^{1} S(\\mu, \\mu') d\\mu \\right) = \\int_{-1}^{1} d\\mu' f(\\mu') \\left( \\int_{-1}^{1} S(\\mu', \\mu) d\\mu \\right) = \\int_{-1}^{1} f(\\mu') \\cdot 1 \\, d\\mu'\n$$\nThe term in parentheses evaluates to $1$ due to the normalization property. The gain term integral thus equals $\\int_{-1}^{1} f(\\mu') d\\mu'$, which exactly cancels the integral of the loss term. Therefore, $\\int_{-1}^{1} C[f](\\mu) d\\mu = 0$ for any arbitrary (integrable) function $f(\\mu)$, confirming photon number conservation.\n\n### 3. Numerical Discretization and Implementation\n\nThe integral operator is discretized using Gauss-Legendre quadrature. The interval $[-1, 1]$ is discretized into a set of $N$ nodes $\\{\\mu_i\\}$ and corresponding weights $\\{w_i\\}$. The integral of a function $g(\\mu)$ is approximated as $\\int_{-1}^{1} g(\\mu) d\\mu \\approx \\sum_{j=1}^{N} w_j g(\\mu_j)$.\nApplying this to the collision operator, evaluated at node $\\mu_i$:\n$$\nC[f](\\mu_i) \\equiv C_i = \\nu\\left(-f(\\mu_i) + \\sum_{j=1}^{N} w_j S(\\mu_i, \\mu_j) f(\\mu_j)\\right)\n$$\nThis is the discrete operator to be implemented. The kernel $S(\\mu_i, \\mu_j)$ becomes an $N \\times N$ matrix $S_{ij}$.\n\nThe residuals to be calculated are numerical checks of the analytical properties derived above:\n- $r_\\mathrm{norm}(N)$: Tests the kernel normalization. It measures the maximum deviation of the discrete sum $\\sum_j w_j S_{ij}$ from the analytical value of $1$.\n- $r_\\mathrm{iso}(N, A)$: Tests the isotropic fixed-point property. It computes the maximum magnitude of the discrete operator $C_i$ for a constant input $f_i = A$. Analytically this is zero; numerically it will be proportional to $r_\\mathrm{norm}$.\n- $r_\\mathrm{num}(N)$: Tests photon number conservation. It computes the quadrature sum $\\sum_i w_i C_i$, which approximates $\\int C[f](\\mu) d\\mu$. This should be close to zero.\n- $r_\\mathrm{sym}(N)$: Tests the kernel symmetry. It measures the maximum difference $|S_{ij} - S_{ji}|$, which should be zero up to floating-point precision.\n\nThe implementation will construct the quadrature nodes and weights, build the kernel matrix $S_{ij}$, and then compute these four residuals for the specified test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef S_kernel(mu_i, mu_j):\n    \"\"\"\n    Calculates the azimuth-averaged axisymmetric Thomson scattering kernel S(mu, mu').\n\n    Args:\n        mu_i: Cosine of the outgoing polar angle(s). Can be a scalar or a broadcastable array.\n        mu_j: Cosine of the incident polar angle(s). Can be a scalar or a broadcastable array.\n\n    Returns:\n        The kernel value(s).\n    \"\"\"\n    mu_i_sq = np.square(mu_i)\n    mu_j_sq = np.square(mu_j)\n    return (3.0 / 16.0) * (3.0 - mu_i_sq - mu_j_sq + 3.0 * mu_i_sq * mu_j_sq)\n\ndef solve():\n    \"\"\"\n    Derives, discretizes, and tests the collisional Boltzmann operator for Thomson scattering.\n    \"\"\"\n    # All quantities are dimensionless. The scattering rate nu is set to 1.0.\n    nu = 1.0\n    results = []\n\n    # Case 1: Compute the kernel normalization residual r_norm(N) for N=8.\n    N1 = 8\n    mu1, w1 = roots_legendre(N1)\n    # Construct the kernel matrix S_ij = S(mu_i, mu_j).\n    # mu1[:, None] ensures that mu_i and mu_j broadcast correctly to form an NxN matrix.\n    S1 = S_kernel(mu1[:, None], mu1)\n    # The sum sum_j w_j S_ij is a matrix-vector product S @ w.\n    norm_check_vector = S1 @ w1\n    # The residual measures the deviation from the analytical result of 1.\n    r_norm = np.max(np.abs(norm_check_vector - 1.0))\n    results.append(r_norm)\n\n    # Case 2: Compute the isotropic fixed-point residual r_iso(N, A) for N=32, A=1.3.\n    N2 = 32\n    A = 1.3\n    mu2, w2 = roots_legendre(N2)\n    S2 = S_kernel(mu2[:, None], mu2)\n    # Create an isotropic distribution function f(mu) = A.\n    f_iso = np.full_like(mu2, A)\n    # Apply the discrete collision operator: C_i = nu * (-f_i + sum_j w_j S_ij f_j)\n    # The sum is evaluated as a matrix-vector product: S @ (w * f)\n    C_iso = nu * (-f_iso + S2 @ (w2 * f_iso))\n    # The residual is the maximum magnitude of the resulting operator.\n    r_iso = np.max(np.abs(C_iso))\n    results.append(r_iso)\n\n    # Case 3: Compute the photon number conservation residual r_num(N) for N=32.\n    N3 = 32\n    mu3, w3 = roots_legendre(N3)\n    S3 = S_kernel(mu3[:, None], mu3)\n    # Define the anisotropic distribution f(mu) = 1 + 0.2*mu + 0.1*P_2(mu).\n    P2_mu3 = 0.5 * (3 * np.square(mu3) - 1.0)\n    f_aniso = 1.0 + 0.2 * mu3 + 0.1 * P2_mu3\n    # Apply the collision operator.\n    C_aniso = nu * (-f_aniso + S3 @ (w3 * f_aniso))\n    # The residual is the magnitude of the quadrature integral of the operator,\n    # which approximates integral(C[f] dmu) and should be zero.\n    r_num = np.abs(np.dot(w3, C_aniso))\n    results.append(r_num)\n\n    # Case 4: Compute the kernel symmetry residual r_sym(N) for N=16.\n    N4 = 16\n    mu4, _ = roots_legendre(N4)\n    S4 = S_kernel(mu4[:, None], mu4)\n    # The residual is the maximum absolute difference between S_ij and S_ji.\n    r_sym = np.max(np.abs(S4 - S4.T))\n    results.append(r_sym)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3493982"}, {"introduction": "With a grasp of both the time evolution driven by collisions and the structure of the scattering operator, we can now design a numerical experiment to measure a key physical parameter. This practice [@problem_id:3494002] simulates a uniform slab of scattering medium to isolate the effect of the collision term. By tracking the decay of an initial anisotropy, you will quantitatively verify the theoretical prediction that anisotropies decay exponentially at a rate determined by the medium's optical depth, reinforcing the connection between the abstract Boltzmann equation and measurable physical processes.", "problem": "Consider the collisional Boltzmann equation for photons in a one-dimensional spatial slab with periodic boundaries and no free-streaming. Let the photon specific intensity be denoted by $f(x,\\mu,\\eta)$, where $x \\in [0,L)$ is the spatial coordinate, $\\mu \\in [-1,1]$ is the cosine of the angle between the photon propagation direction and the $x$-axis, and $\\eta \\ge 0$ is conformal time. Assume a spatially uniform, time-independent scattering medium that induces an isotropic-scattering collision operator with constant optical depth rate $\\dot{\\tau}$. The dynamical equation is\n$$\n\\frac{\\partial f}{\\partial \\eta}(x,\\mu,\\eta) \\;=\\; \\mathcal{C}[f](x,\\mu,\\eta)\\,,\n$$\nwith the collision operator\n$$\n\\mathcal{C}[f](x,\\mu,\\eta) \\;=\\; -\\,\\dot{\\tau}\\,\\big(f(x,\\mu,\\eta) - J(x,\\eta)\\big)\\,,\n$$\nwhere the angular mean is\n$$\nJ(x,\\eta)\\;=\\;\\frac{1}{2}\\int_{-1}^{1} f(x,\\mu',\\eta)\\,d\\mu'\\,.\n$$\nThere is no spatial transport term and the spatial domain is periodic, meaning $f(0,\\mu,\\eta)=f(L,\\mu,\\eta)$ for all $\\mu$ and $\\eta$. All quantities are dimensionless. Angles are encoded by $\\mu$, which is the cosine of the polar angle and therefore dimensionless. Time $\\eta$ is in conformal time units and is dimensionless. The intensity $f$ is dimensionless.\n\nYour task is to implement a numerical experiment that isolates the collision term and quantitatively measures the approach to isotropy in a uniform slab. You must:\n\n1. Discretize $\\mu \\in [-1,1]$ using Gaussian-Legendre quadrature with $N_\\mu$ nodes $\\{\\mu_i\\}_{i=1}^{N_\\mu}$ and corresponding positive weights $\\{w_i\\}_{i=1}^{N_\\mu}$, such that for any sufficiently smooth function $g$,\n$$\n\\int_{-1}^{1} g(\\mu)\\,d\\mu \\;\\approx\\; \\sum_{i=1}^{N_\\mu} w_i\\,g(\\mu_i)\\,.\n$$\n2. Discretize the spatial domain $x \\in [0,L)$ using $N_x$ uniformly spaced points. Impose periodic boundaries. Since there is no free-streaming, spatial periodicity will act only as a consistency condition on the discrete geometry.\n3. Initialize the photon intensity at $\\eta=0$ by\n$$\nf(x,\\mu,0) \\;=\\; 1 \\;+\\; \\alpha\\,P_1(\\mu) \\;+\\; \\beta\\,P_2(\\mu) \\;+\\; \\gamma \\cos\\!\\Big(\\frac{2\\pi m x}{L}\\Big)\\,P_1(\\mu) \\;+\\; \\delta \\sin\\!\\Big(\\frac{2\\pi n x}{L}\\Big)\\,P_2(\\mu)\\,,\n$$\nwhere $P_\\ell$ denotes the Legendre polynomial of degree $\\ell$. Use the specific constants $\\alpha=0$, $\\beta=\\tfrac{1}{5}$, $\\gamma=\\tfrac{2}{25}$, $\\delta=-\\tfrac{1}{10}$, $m=3$, and $n=2$. This initial condition is dimensionless and yields a nontrivial anisotropy with a spatially varying component. Note that the initial angular mean is spatially uniform because $\\int_{-1}^{1}P_1(\\mu)\\,d\\mu=0$ and $\\int_{-1}^{1}P_2(\\mu)\\,d\\mu=0$.\n4. Evolve the system from $\\eta=0$ to $\\eta=T_{\\mathrm{end}}$ by numerically solving the pure-collision evolution. You may use any consistent, stable method appropriate for stiff decay dynamics. The periodic boundary conditions in $x$ must be maintained.\n5. Define the anisotropy amplitude at time $\\eta$ as the root-mean-square deviation from the angular mean, averaged over space and weighted by the quadrature rule:\n$$\nA(\\eta)\\;=\\;\\left(\\frac{1}{N_x}\\sum_{j=1}^{N_x}\\frac{1}{2}\\sum_{i=1}^{N_\\mu} w_i\\,\\big(f(x_j,\\mu_i,\\eta)-J(x_j,\\eta)\\big)^2\\right)^{1/2}\\,,\n$$\nwhere\n$$\nJ(x_j,\\eta)\\;=\\;\\frac{1}{2}\\sum_{i=1}^{N_\\mu} w_i\\,f(x_j,\\mu_i,\\eta)\\,.\n$$\n6. Fit a straight line to $\\ln A(\\eta)$ as a function of $\\eta$ over the interval $[0,T_{\\mathrm{end}}]$ using uniformly spaced sample times, and report the fitted decay rate magnitude $k_{\\mathrm{fit}}$ defined by the best-fit slope $s$ via $k_{\\mathrm{fit}} = -s$. For the case $\\dot{\\tau}=0$, report $k_{\\mathrm{fit}}=0$.\n7. For each test case below, compute the absolute error\n$$\nE \\;=\\; \\big|\\,k_{\\mathrm{fit}} - \\dot{\\tau}\\,\\big|\\,.\n$$\n\nUse the following test suite, where each case is a tuple $(\\dot{\\tau},\\,T_{\\mathrm{end}},\\,N_t,\\,N_x,\\,N_\\mu,\\,L)$:\n\n- Case $1$: $(0.7,\\;3.0,\\;60,\\;32,\\;80,\\;1.0)$.\n- Case $2$: $(10^{-3},\\;2000.0,\\;200,\\;16,\\;64,\\;2.0)$.\n- Case $3$: $(20.0,\\;0.5,\\;50,\\;24,\\;96,\\;1.0)$.\n- Case $4$: $(0.0,\\;3.0,\\;50,\\;20,\\;48,\\;1.0)$.\n\nAll quantities are dimensionless. Angles are represented by $\\mu$ and need no unit. Your program should produce a single line of output containing the four absolute errors $E$ for the cases above as a comma-separated list enclosed in square brackets (for example, $[e_1,e_2,e_3,e_4]$). The entries must be floating-point numbers.", "solution": "The problem statement has been validated and is deemed valid. It is scientifically grounded in kinetic theory, specifically the relaxation approximation of the collisional Boltzmann equation. It is well-posed, objective, and provides a complete and consistent set of parameters and definitions for a numerical experiment.\n\nThe core of the problem is to solve the collisional Boltzmann equation in a simplified setting where the free-streaming term is absent. The governing equation for the photon specific intensity $f(x, \\mu, \\eta)$ is\n$$\n\\frac{\\partial f}{\\partial \\eta}(x,\\mu,\\eta) = -\\dot{\\tau}\\big(f(x,\\mu,\\eta) - J(x,\\eta)\\big)\n$$\nwhere $x$ is the spatial coordinate, $\\mu$ is the direction cosine, $\\eta$ is conformal time, $\\dot{\\tau}$ is the constant optical depth rate, and $J(x,\\eta)$ is the angular mean of $f$. Since there are no spatial derivatives, the evolution at each spatial point $x$ is independent of other spatial points.\n\nLet us analyze the equation for a fixed spatial position $x$. The angular mean $J$ is defined as $J(x,\\eta) = \\frac{1}{2}\\int_{-1}^{1} f(x,\\mu',\\eta)\\,d\\mu'$. We can find the time evolution of $J(x,\\eta)$ by taking the angular mean of the governing equation:\n$$\n\\frac{\\partial J}{\\partial \\eta} = \\frac{1}{2}\\int_{-1}^{1} \\frac{\\partial f}{\\partial \\eta}\\,d\\mu' = \\frac{1}{2}\\int_{-1}^{1} \\left[-\\dot{\\tau}\\big(f - J\\big)\\right]\\,d\\mu' = -\\dot{\\tau}\\left(\\frac{1}{2}\\int_{-1}^{1} f\\,d\\mu' - \\frac{1}{2}\\int_{-1}^{1} J\\,d\\mu'\\right)\n$$\nSince $J$ is independent of the integration variable $\\mu'$, $\\int_{-1}^{1} J\\,d\\mu' = J \\int_{-1}^{1} d\\mu' = 2J$. By definition, $\\frac{1}{2}\\int_{-1}^{1} f\\,d\\mu' = J$. Thus, the equation simplifies to:\n$$\n\\frac{\\partial J}{\\partial \\eta} = -\\dot{\\tau}\\big(J - J\\big) = 0\n$$\nThis demonstrates that the angular mean $J$ is a conserved quantity at each spatial point: $J(x, \\eta) = J(x, 0)$ for all $\\eta \\ge 0$.\n\nNow, let us define the anisotropic part of the distribution as $f_a(x,\\mu,\\eta) = f(x,\\mu,\\eta) - J(x,\\eta)$. Its time evolution is given by:\n$$\n\\frac{\\partial f_a}{\\partial \\eta} = \\frac{\\partial f}{\\partial \\eta} - \\frac{\\partial J}{\\partial \\eta} = \\left[-\\dot{\\tau}\\big(f - J\\big)\\right] - 0 = -\\dot{\\tau} f_a\n$$\nThis is a simple first-order ordinary differential equation with the solution:\n$$\nf_a(x,\\mu,\\eta) = f_a(x,\\mu,0) \\, e^{-\\dot{\\tau}\\eta}\n$$\nThe full solution for the specific intensity is therefore $f(x,\\mu,\\eta) = J(x,0) + \\big(f(x,\\mu,0) - J(x,0)\\big)e^{-\\dot{\\tau}\\eta}$.\n\nThis analytical solution for the semi-discretized system (discretized in angle but continuous in time) provides the most accurate method for \"evolving\" the system, as requested. It is an exact time integrator, thereby eliminating any source of time-stepping error.\n\nThe anisotropy amplitude $A(\\eta)$ is defined as the root-mean-square of the anisotropic part, averaged over space. Using the analytical solution for $f-J = f_a$:\n$$\nA(\\eta)^2 = \\frac{1}{N_x}\\sum_{j=1}^{N_x}\\frac{1}{2}\\sum_{i=1}^{N_\\mu} w_i\\,\\big(f(x_j,\\mu_i,\\eta)-J(x_j,\\eta)\\big)^2 = \\frac{1}{N_x}\\sum_{j=1}^{N_x}\\frac{1}{2}\\sum_{i=1}^{N_\\mu} w_i\\,\\left(\\big(f(x_j,\\mu_i,0)-J(x_j,0)\\big)e^{-\\dot{\\tau}\\eta}\\right)^2\n$$\n$$\nA(\\eta)^2 = e^{-2\\dot{\\tau}\\eta} \\left( \\frac{1}{N_x}\\sum_{j=1}^{N_x}\\frac{1}{2}\\sum_{i=1}^{N_\\mu} w_i\\,\\big(f(x_j,\\mu_i,0)-J(x_j,0)\\big)^2 \\right) = \\left(A(0)e^{-\\dot{\\tau}\\eta}\\right)^2\n$$\nTaking the square root, we find $A(\\eta) = A(0)e^{-\\dot{\\tau}\\eta}$. Taking the natural logarithm gives:\n$$\n\\ln A(\\eta) = \\ln A(0) - \\dot{\\tau}\\eta\n$$\nThis is a linear function of $\\eta$ with a slope $s = -\\dot{\\tau}$. The problem asks to find the fitted decay rate magnitude $k_{\\mathrm{fit}} = -s$. Therefore, an ideal numerical experiment should yield $k_{\\mathrm{fit}} = \\dot{\\tau}$, and the error $E = |k_{\\mathrm{fit}} - \\dot{\\tau}|$ should be close to zero, limited only by floating-point precision.\n\nThe numerical implementation proceeds as follows:\n1.  For each test case $(\\dot{\\tau}, T_{\\mathrm{end}}, N_t, N_x, N_\\mu, L)$, handle the special case where $\\dot{\\tau}=0$, for which the problem defines $k_{\\mathrm{fit}}=0$ and thus the error $E=0$.\n2.  Discretize the spatial domain $x \\in [0,L)$ into $N_x$ points and the angular domain $\\mu \\in [-1,1]$ using $N_\\mu$-point Gaussian-Legendre quadrature, obtaining nodes $\\{\\mu_i\\}$ and weights $\\{w_i\\}$.\n3.  Construct the initial distribution function $f(x_j, \\mu_i, 0)$ on the discrete grid using the given formula, which involves Legendre polynomials $P_1(\\mu)$ and $P_2(\\mu)$.\n4.  Compute the initial angular mean $J(x_j, 0) = \\frac{1}{2}\\sum_{i=1}^{N_\\mu} w_i f(x_j, \\mu_i, 0)$ for each spatial point $x_j$.\n5.  Based on the analytical result, the anisotropy amplitude at a series of uniformly spaced sample times $\\eta_k \\in [0, T_{\\mathrm{end}}]$ can be calculated as $A(\\eta_k) = A(0)e^{-\\dot{\\tau}\\eta_k}$, where $A(0)$ is computed directly from the initial conditions.\n6.  Perform a linear least-squares fit on the points $(\\eta_k, \\ln A(\\eta_k))$ to determine the slope $s$.\n7.  Calculate the fitted decay rate $k_{\\mathrm{fit}} = -s$.\n8.  Compute the absolute error $E = |k_{\\mathrm{fit}} - \\dot{\\tau}|$.\n\nThis procedure accurately measures the collisional relaxation rate inherent in the model, free from numerical integration artifacts.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre, eval_legendre\n\ndef calculate_error_for_case(case_params):\n    \"\"\"\n    Computes the absolute error for a single test case.\n    \"\"\"\n    dtau, T_end, N_t, N_x, N_mu, L = case_params\n\n    # Per the problem description, for the case dtau=0, k_fit is reported as 0.\n    # The error E = |k_fit - dtau| = |0 - 0| is thus 0.\n    if dtau == 0.0:\n        return 0.0\n\n    # Constants for the initial condition from the problem statement\n    beta = 1.0 / 5.0\n    gamma = 2.0 / 25.0\n    delta = -1.0 / 10.0\n    m = 3\n    n = 2\n\n    # Step 1: Set up discrete grids\n    # Spatial grid\n    x_grid = np.linspace(0, L, N_x, endpoint=False)\n    # Angular grid using Gaussian-Legendre quadrature\n    mu_nodes, mu_weights = roots_legendre(N_mu)\n\n    # Step 2: Construct the initial intensity distribution f(x, mu, 0)\n    # Evaluate Legendre polynomials at quadrature nodes\n    P1_mu = eval_legendre(1, mu_nodes)\n    P2_mu = eval_legendre(2, mu_nodes)\n    \n    # Reshape arrays for broadcasting to create the (N_x, N_mu) grid\n    x_col = x_grid[:, np.newaxis]\n    mu_row = mu_nodes[np.newaxis, :]\n    weights_row = mu_weights[np.newaxis, :]\n    P1_row = P1_mu[np.newaxis, :]\n    P2_row = P2_mu[np.newaxis, :]\n\n    cos_term = gamma * np.cos(2 * np.pi * m * x_col / L)\n    sin_term = delta * np.sin(2 * np.pi * n * x_col / L)\n    \n    # Initial intensity f(x, mu, 0)\n    f0 = 1.0 + beta * P2_row + cos_term * P1_row + sin_term * P2_row\n\n    # Step 3: Compute initial angular mean J(x,0) and anisotropy\n    # The sum of weights is 2, so the factor 1/2 is included in the mean definition.\n    J0 = 0.5 * np.sum(f0 * weights_row, axis=1, keepdims=True)\n    \n    # Initial anisotropic part: f_a(x, mu, 0) = f(x, mu, 0) - J(x, 0)\n    f_aniso_0 = f0 - J0\n\n    # Step 4: Compute anisotropy amplitude A(eta)\n    # Analytically, A(eta) = A(0) * exp(-dtau * eta). First, calculate A(0).\n    # A(0)^2 = (1/N_x) * sum_x [ (1/2) * sum_mu w_mu * (f_a(x,mu,0))^2 ]\n    \n    # The inner sum over mu for each x\n    anisotropy_per_x_sq = 0.5 * np.sum(weights_row * f_aniso_0**2, axis=1)\n    \n    # The outer average over x\n    A_sq_at_0 = np.mean(anisotropy_per_x_sq)\n    \n    # If the initial state is isotropic, the decay rate is undefined.\n    # In this case, k_fit would be 0, and error is |0 - dtau|.\n    if A_sq_at_0 = 0.0:\n        return np.abs(dtau)\n        \n    A_at_0 = np.sqrt(A_sq_at_0)\n    \n    # Generate time samples\n    eta_samples = np.linspace(0, T_end, N_t)\n    \n    # The problem asks to fit ln(A(eta)), so we generate this series.\n    # From analytics, ln(A(eta)) = ln(A(0)) - dtau*eta\n    log_A_eta = np.log(A_at_0) - dtau * eta_samples\n\n    # Step 5: Fit a straight line to ln(A(eta)) vs eta\n    # np.polyfit returns [slope, intercept] for degree 1\n    slope, _ = np.polyfit(eta_samples, log_A_eta, 1)\n\n    # Step 6: Compute the fitted decay rate and the absolute error\n    k_fit = -slope\n    error = np.abs(k_fit - dtau)\n    \n    return error\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.7, 3.0, 60, 32, 80, 1.0),\n        (1e-3, 2000.0, 200, 16, 64, 2.0),\n        (20.0, 0.5, 50, 24, 96, 1.0),\n        (0.0, 3.0, 50, 20, 48, 1.0)\n    ]\n\n    results = []\n    for case in test_cases:\n        error = calculate_error_for_case(case)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3494002"}]}