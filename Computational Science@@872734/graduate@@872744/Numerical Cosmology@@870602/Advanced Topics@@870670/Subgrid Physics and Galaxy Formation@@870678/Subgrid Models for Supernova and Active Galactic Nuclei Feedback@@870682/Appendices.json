{"hands_on_practices": [{"introduction": "The primary motivation for sophisticated subgrid feedback models is the numerical 'overcooling' problem. When energy is injected into a simulation cell, it can be radiated away unphysically fast if the grid resolution cannot capture the subsequent hydrodynamic expansion. This practice [@problem_id:3491443] guides you through deriving and implementing a dimensionless parameter, $\\Pi$, which compares the cooling and dynamical timescales to predict the onset of this critical numerical artifact.", "problem": "Consider idealized one-zone energy injection events used in subgrid models for supernova (SN) and active galactic nuclei (AGN) feedback in numerical cosmology. A single hydrodynamic resolution element (a cubic cell of edge length) receives an instantaneous thermal energy injection. We wish to define a dimensionless parameter that predicts the onset of numerical overcooling by comparing radiative cooling and hydrodynamic response timescales. Your task is to derive, implement, and validate such a parameter.\n\nStarting from fundamental principles and widely accepted approximations:\n\n- Use the ideal gas internal energy relation and sound speed for a monatomic ideal gas with adiabatic index $\\gamma = 5/3$. Assume ionized gas with mean molecular weight $\\mu = 0.6$.\n- Use the definition of temperature $T$ immediately after thermal energy injection $E$ into a cell of volume $V = \\Delta x^3$ filled with hydrogen number density $n$, assuming all of $E$ becomes thermal internal energy.\n- Use the definition of sound crossing time across the resolution element $\\Delta x$: the sound speed is $c_s = \\sqrt{\\gamma k_B T / (\\mu m_p)}$, where $k_B$ is the Boltzmann constant and $m_p$ is the proton mass. The sound crossing time is $t_{\\mathrm{sc}} = \\Delta x / c_s$.\n- Use the optically thin radiative cooling time in the isochoric limit $t_{\\mathrm{cool}} = \\dfrac{(3/2) n k_B T}{n_e n_i \\Lambda(T)}$. For fully ionized hydrogen, assume $n_e \\approx n_i \\approx n$, so $n_e n_i \\approx n^2$. The radiative cooling function is $\\Lambda(T)$ with units $\\mathrm{erg\\,cm^3\\,s^{-1}}$.\n\nDefine the dimensionless parameter $\\Pi$ as a function of the injected energy, the gas density, grid scale, and the cooling function by\n$$\n\\Pi \\equiv \\frac{t_{\\mathrm{cool}}}{t_{\\mathrm{sc}}}.\n$$\nA value $\\Pi  1$ indicates the cooling time is shorter than the hydrodynamic response time across a resolution element, predicting the onset of numerical overcooling.\n\nValidation protocol via controlled energy injection tests:\n- Evolve the one-zone internal energy $E(t)$ for a duration equal to one initial sound crossing time $t_{\\mathrm{sc}}$ under pure radiative losses with\n$$\n\\frac{dE}{dt} = - n^2 \\Lambda(T) V,\n$$\nand the thermodynamic closure\n$$\nE = \\frac{3}{2} n V k_B T \\quad \\Rightarrow \\quad T(E) = \\frac{2 E}{3 n V k_B}.\n$$\n- Classify the evolution as “overcooling” if the fractional energy retained after one initial sound crossing time is less than one half, i.e., if $E(t_{\\mathrm{sc}})/E(0)  1/2$.\n- Compare this measured classification to the prediction based on $\\Pi$: predict overcooling if and only if $\\Pi  1$.\n\nAdopt the following constants and unit conventions:\n- Use cgs units for all physical quantities: $E$ in $\\mathrm{erg}$, $n$ in $\\mathrm{cm^{-3}}$, $\\Delta x$ in $\\mathrm{pc}$ converted to $\\mathrm{cm}$ using $1\\,\\mathrm{pc} = 3.08567758\\times 10^{18}\\,\\mathrm{cm}$, $k_B = 1.380649\\times 10^{-16}\\,\\mathrm{erg\\,K^{-1}}$, $m_p = 1.67262192369\\times 10^{-24}\\,\\mathrm{g}$, $\\mu = 0.6$, and $\\gamma = 5/3$.\n- Use the following piecewise analytic approximation for the cooling function $\\Lambda(T)$ (fully ionized, near-solar metallicity, optically thin), continuous across regimes and valid for $T \\ge 10^{4}\\,\\mathrm{K}$:\n  - For $10^{4}\\,\\mathrm{K} \\le T  10^{5}\\,\\mathrm{K}$: $\\Lambda(T) = 10^{-22}\\,\\left(\\dfrac{T}{10^{5}\\,\\mathrm{K}}\\right)^{1/2}\\,\\mathrm{erg\\,cm^3\\,s^{-1}}$.\n  - For $10^{5}\\,\\mathrm{K} \\le T \\le 10^{7}\\,\\mathrm{K}$: $\\Lambda(T) = 2\\times 10^{-23}\\,\\left(\\dfrac{T}{10^{6}\\,\\mathrm{K}}\\right)^{-0.7}\\,\\mathrm{erg\\,cm^3\\,s^{-1}}$.\n  - For $T  10^{7}\\,\\mathrm{K}$: $\\Lambda(T) = 10^{-23}\\,\\left(\\dfrac{T}{10^{7}\\,\\mathrm{K}}\\right)^{1/2}\\,\\mathrm{erg\\,cm^3\\,s^{-1}}$.\nFor numerical stability, you should enforce a floor $T \\ge 10^{4}\\,\\mathrm{K}$ inside $\\Lambda(T)$.\n\nNumerical integration requirements:\n- Integrate the ordinary differential equation for $E(t)$ with a fixed time step and a stable method over $[0, t_{\\mathrm{sc}}]$. Use a fourth-order explicit Runge–Kutta method with at least $N = 10^{4}$ equal steps to ensure convergence in these test cases.\n- Use the initial temperature $T(0)$ to compute $t_{\\mathrm{sc}}$; keep $\\Delta x$ fixed during the evolution.\n\nTest suite:\nImplement your program to evaluate the following four controlled energy injection tests. For each test, compute the dimensionless parameter $\\Pi$, perform the one-zone evolution, and return a boolean indicating whether the $\\Pi$-based prediction agrees with the measured classification. All inputs are listed as $(E, n, \\Delta x)$:\n\n1. Supernova in dense gas, coarse resolution (overcooling expected): $(E = 10^{51}\\,\\mathrm{erg},\\; n = 10\\,\\mathrm{cm^{-3}},\\; \\Delta x = 100\\,\\mathrm{pc})$.\n2. Supernova in diffuse gas, fine resolution (no overcooling expected): $(E = 10^{51}\\,\\mathrm{erg},\\; n = 1\\,\\mathrm{cm^{-3}},\\; \\Delta x = 1\\,\\mathrm{pc})$.\n3. Active Galactic Nuclei (AGN) bubble in intracluster medium (no overcooling expected): $(E = 10^{57}\\,\\mathrm{erg},\\; n = 10^{-3}\\,\\mathrm{cm^{-3}},\\; \\Delta x = 1000\\,\\mathrm{pc})$.\n4. Near-threshold supernova case (marginal resolution): $(E = 10^{51}\\,\\mathrm{erg},\\; n = 1\\,\\mathrm{cm^{-3}},\\; \\Delta x = 60\\,\\mathrm{pc})$.\n\nFinal output specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with no spaces. Each entry must be a boolean where each boolean is true if and only if the $\\Pi$-based overcooling prediction matches the measured classification for that test case, in the same order as listed above. For example: \"[True,False,True,True]\".", "solution": "The problem requires the derivation and validation of a dimensionless parameter, $\\Pi$, designed to predict the onset of numerical overcooling in simulations of astrophysical feedback. This phenomenon occurs when the radiative cooling timescale is shorter than the hydrodynamic response time within a single resolution element, causing the injected energy to be radiated away before it can do mechanical work on the surrounding gas.\n\nFirst, we derive the expression for $\\Pi$ in terms of the fundamental physical parameters of the problem: the injected energy $E$, the ambient hydrogen number density $n$, and the grid cell size $\\Delta x$.\n\nThe dimensionless parameter $\\Pi$ is defined as the ratio of the cooling time $t_{\\mathrm{cool}}$ to the sound crossing time $t_{\\mathrm{sc}}$:\n$$\n\\Pi \\equiv \\frac{t_{\\mathrm{cool}}}{t_{\\mathrm{sc}}}\n$$\n\nThe sound crossing time, $t_{\\mathrm{sc}}$, is the time it takes for a sound wave to traverse the resolution element of size $\\Delta x$. It is given by:\n$$\nt_{\\mathrm{sc}} = \\frac{\\Delta x}{c_s}\n$$\nwhere $c_s$ is the sound speed in the gas. For a monatomic ideal gas with adiabatic index $\\gamma = 5/3$ and mean molecular weight $\\mu = 0.6$, the sound speed is:\n$$\nc_s = \\sqrt{\\frac{\\gamma k_B T}{\\mu m_p}}\n$$\nHere, $k_B$ is the Boltzmann constant, $T$ is the temperature, and $m_p$ is the proton mass. The temperature $T$ immediately after the instantaneous injection of thermal energy $E$ into a cubic cell of volume $V = \\Delta x^3$ is determined by the ideal gas internal energy relation:\n$$\nE = \\frac{3}{2} n V k_B T = \\frac{3}{2} n (\\Delta x)^3 k_B T\n$$\nSolving for $T$, we find the initial temperature $T_0$:\n$$\nT_0 = \\frac{2 E}{3 n (\\Delta x)^3 k_B}\n$$\nSubstituting this expression for $T_0$ into the formula for $c_s$, we can express the initial sound crossing time $t_{\\mathrm{sc},0}$ in terms of the primary variables:\n$$\nt_{\\mathrm{sc},0} = \\frac{\\Delta x}{\\sqrt{\\frac{\\gamma k_B}{\\mu m_p} \\left( \\frac{2 E}{3 n (\\Delta x)^3 k_B} \\right)}} = \\frac{\\Delta x}{\\sqrt{\\frac{2 \\gamma E}{3 n (\\Delta x)^3 \\mu m_p}}} = \\Delta x \\sqrt{\\frac{3 n (\\Delta x)^3 \\mu m_p}{2 \\gamma E}} = (\\Delta x)^{5/2} \\sqrt{\\frac{3 n \\mu m_p}{2 \\gamma E}}\n$$\n\nNext, we derive the initial cooling time, $t_{\\mathrm{cool},0}$. It is defined as the ratio of the thermal energy density to the radiative cooling rate per unit volume. For an isochoric process:\n$$\nt_{\\mathrm{cool}} = \\frac{(3/2) n k_B T}{n_e n_i \\Lambda(T)}\n$$\nwhere $\\Lambda(T)$ is the radiative cooling function. For a fully ionized hydrogen gas, the electron and ion number densities are approximately equal to the hydrogen number density, $n_e \\approx n_i \\approx n$. The thermal energy density $(3/2) n k_B T$ is simply the total energy $E$ divided by the volume $V = (\\Delta x)^3$. Thus, the initial cooling time is:\n$$\nt_{\\mathrm{cool},0} = \\frac{E/V}{n^2 \\Lambda(T_0)} = \\frac{E}{(\\Delta x)^3 n^2 \\Lambda(T_0)}\n$$\n\nNow we can form the dimensionless parameter $\\Pi$ by dividing $t_{\\mathrm{cool},0}$ by $t_{\\mathrm{sc},0}$:\n$$\n\\Pi = \\frac{t_{\\mathrm{cool},0}}{t_{\\mathrm{sc},0}} = \\frac{E / ((\\Delta x)^3 n^2 \\Lambda(T_0))}{(\\Delta x)^{5/2} \\sqrt{3 n \\mu m_p / (2 \\gamma E)}} = \\frac{E}{n^2 (\\Delta x)^{11/2} \\Lambda(T_0)} \\sqrt{\\frac{2 \\gamma E}{3 n \\mu m_p}}\n$$\n$$\n\\Pi = \\frac{E^{3/2}}{n^{5/2} (\\Delta x)^{11/2} \\Lambda(T_0)} \\sqrt{\\frac{2 \\gamma}{3 \\mu m_p}}\n$$\nA value of $\\Pi  1$ suggests that cooling dominates over hydrodynamics, leading to numerical overcooling.\n\nTo validate this criterion, we perform a numerical experiment as specified. We solve the ordinary differential equation (ODE) for the evolution of the internal energy $E(t)$ under pure radiative losses:\n$$\n\\frac{dE}{dt} = -n^2 \\Lambda(T(E)) V\n$$\nwhere the temperature $T$ is related to the energy $E$ at any time via the thermodynamic closure:\n$$\nT(E) = \\frac{2 E}{3 n V k_B}\n$$\nThis ODE is integrated from $t=0$ to $t=t_{\\mathrm{sc},0}$, the initial sound crossing time. We use the fourth-order explicit Runge-Kutta (RK4) method with a total of $N=10^4$ fixed time steps, $\\Delta t = t_{\\mathrm{sc},0}/N$. For a given time step $i$, the energy is updated from $E_i$ to $E_{i+1}$ as follows, where $f(E) = dE/dt$:\n$$\nk_1 = \\Delta t \\cdot f(E_i)\n$$\n$$\nk_2 = \\Delta t \\cdot f(E_i + 0.5 k_1)\n$$\n$$\nk_3 = \\Delta t \\cdot f(E_i + 0.5 k_2)\n$$\n$$\nk_4 = \\Delta t \\cdot f(E_i + k_3)\n$$\n$$\nE_{i+1} = E_i + \\frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n$$\nAfter integrating up to $t=t_{\\mathrm{sc},0}$ to find the final energy $E(t_{\\mathrm{sc},0})$, we classify the evolution as \"measured overcooling\" if the fractional energy retained is less than one half:\n$$\n\\frac{E(t_{\\mathrm{sc},0})}{E(0)}  \\frac{1}{2}\n$$\nThe validation for each test case consists of checking if the prediction (overcooling if $\\Pi  1$, no overcooling if $\\Pi \\ge 1$) matches the classification from the numerical experiment.\n\nThe piecewise cooling function $\\Lambda(T)$ is implemented as specified, with a floor at $T=10^4\\,\\mathrm{K}$. All calculations are performed in cgs units. The provided test cases are evaluated according to this procedure. The final output is a list of booleans, where each entry is `True` if the prediction from $\\Pi$ agrees with the measured outcome for the corresponding test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, implements, and validates a dimensionless parameter for numerical\n    overcooling in astrophysical simulations.\n    \"\"\"\n\n    # Physical constants in cgs units\n    K_B = 1.380649e-16  # Boltzmann constant in erg/K\n    M_P = 1.67262192369e-24  # Proton mass in g\n    PC_TO_CM = 3.08567758e18  # Parsec to cm conversion\n\n    # Gas properties\n    GAMMA = 5.0 / 3.0  # Adiabatic index for monatomic gas\n    MU = 0.6  # Mean molecular weight for ionized gas\n\n    def lambda_cooling_func(T):\n        \"\"\"\n        Calculates the radiative cooling function Lambda(T) in erg cm^3 s^-1.\n        The function is a piecewise power-law approximation.\n        A temperature floor of 1e4 K is enforced.\n        \"\"\"\n        T_eff = np.maximum(T, 1.0e4)\n\n        if T_eff  1.0e5:\n            return 1.0e-22 * np.sqrt(T_eff / 1.0e5)\n        elif T_eff = 1.0e7:\n            return 2.0e-23 * (T_eff / 1.0e6)**(-0.7)\n        else:  # T_eff  1.0e7\n            return 1.0e-23 * np.sqrt(T_eff / 1.0e7)\n\n    def run_simulation(E_init, n, delta_x_pc):\n        \"\"\"\n        Runs a single simulation case to compare the Pi-based prediction\n        with the measured overcooling outcome.\n        \"\"\"\n        # --- Convert units and calculate cell volume ---\n        delta_x_cm = delta_x_pc * PC_TO_CM\n        V = delta_x_cm**3\n\n        # --- Calculate initial state and Pi parameter ---\n        # Initial Temperature\n        T_0 = (2.0 * E_init) / (3.0 * n * V * K_B)\n        \n        # Initial cooling function value\n        lambda_0 = lambda_cooling_func(T_0)\n        \n        # Initial cooling time\n        if lambda_0  0:\n            t_cool_0 = E_init / (n**2 * V * lambda_0)\n        else:\n            t_cool_0 = np.inf\n\n        # Initial sound speed\n        c_s_0 = np.sqrt(GAMMA * K_B * T_0 / (MU * M_P))\n        \n        # Initial sound crossing time\n        t_sc_0 = delta_x_cm / c_s_0\n        \n        # Dimensionless parameter Pi\n        Pi = t_cool_0 / t_sc_0\n\n        # Prediction based on Pi\n        predicted_overcooling = (Pi  1.0)\n        \n        # --- Perform numerical integration using RK4 ---\n        N_steps = 10000\n        dt = t_sc_0 / N_steps\n        \n        E_current = E_init\n\n        # Define the ODE function dE/dt = f(E)\n        def dE_dt(E):\n            if E = 0:\n                return 0.0\n            T_current = (2.0 * E) / (3.0 * n * V * K_B)\n            lambda_val = lambda_cooling_func(T_current)\n            return -n**2 * V * lambda_val\n\n        for _ in range(N_steps):\n            k1 = dt * dE_dt(E_current)\n            k2 = dt * dE_dt(E_current + 0.5 * k1)\n            k3 = dt * dE_dt(E_current + 0.5 * k2)\n            k4 = dt * dE_dt(E_current + k3)\n            E_current += (k1 + 2*k2 + 2*k3 + k4) / 6.0\n            if E_current  0:\n                 E_current = 0\n                 break # Energy fully radiated away\n\n        E_final = E_current\n\n        # Measurement from simulation\n        measured_overcooling = (E_final / E_init)  0.5\n        \n        # Compare prediction and measurement\n        return predicted_overcooling == measured_overcooling\n\n    # Test suite: (E [erg], n [cm^-3], delta_x [pc])\n    test_cases = [\n        # 1. Supernova in dense gas, coarse resolution\n        (1.0e51, 10.0, 100.0),\n        # 2. Supernova in diffuse gas, fine resolution\n        (1.0e51, 1.0, 1.0),\n        # 3. AGN bubble in intracluster medium\n        (1.0e57, 1.0e-3, 1000.0),\n        # 4. Near-threshold supernova case\n        (1.0e51, 1.0, 60.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        E, n, dx = case\n        agreement = run_simulation(E, n, dx)\n        results.append(agreement)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3491443"}, {"introduction": "Beyond resolving physical timescales, the numerical algorithm used to couple feedback energy can introduce its own biases. Operator splitting, a common technique to handle multiple physical processes, is not commutative, meaning the order of operations matters. This exercise [@problem_id:3491413] delves into this implementation detail by having you compare different operator orderings against an exact analytical solution, allowing you to quantify the resulting errors in energy conservation and wind velocity.", "problem": "Consider a one-zone subgrid model for feedback coupling in Numerical Cosmology, where the wind driven by Supernova (SN) and Active Galactic Nuclei (AGN) feedback is modeled as a single parcel with speed $v(t)$ and mass $m$. Feedback is represented as a constant energy injection rate (power) $L$ delivered uniformly over a finite duration $T_{\\mathrm{inj}}$. Momentum coupling to the ambient interstellar medium is approximated by a linear drag characterized by a timescale $\\tau_{\\mathrm{d}}$, which removes kinetic energy according to a dissipative power $P_{\\mathrm{drag}}(t) = m v(t)^2 / \\tau_{\\mathrm{d}}$. The governing base is the work-energy theorem, Newton's second law, and the definition of kinetic energy $K(t) = \\tfrac{1}{2} m v(t)^2$. From these, the continuous energy balance is\n$$\n\\frac{dK}{dt} = L - \\frac{m v(t)^2}{\\tau_{\\mathrm{d}}}.\n$$\nAssume at time $t=0$ the wind has speed $v_0$ and kinetic energy $K_0 = \\tfrac{1}{2} m v_0^2$. We consider operator splitting in a numerical time-integration scheme that alternates between an injection operator and a drag operator with subcycling.\n\nDefine a global time step $\\Delta t$, and an integer subcycling count $n_{\\mathrm{sub}} \\geq 1$. Within each global step, perform $n_{\\mathrm{sub}}$ subcycles of size $\\delta t = \\Delta t / n_{\\mathrm{sub}}$ according to one of two operator orderings:\n- Injection-then-Drag ($\\mathrm{I} \\rightarrow \\mathrm{D}$): For each subcycle, first apply the injection operator that increases kinetic energy by $L \\delta t$ (i.e., update $v$ such that $K \\leftarrow K + L \\delta t$), then apply the drag operator that updates $v$ using a forward-Euler decrement with linear drag $v \\leftarrow v \\left( 1 - \\delta t / \\tau_{\\mathrm{d}} \\right)$, and approximates the energy dissipated by drag in that subcycle as $D_{\\mathrm{sub}} \\approx m v_{\\mathrm{pre}}^2 \\delta t / \\tau_{\\mathrm{d}}$, where $v_{\\mathrm{pre}}$ is the speed just before applying the drag operator in that subcycle.\n- Drag-then-Injection ($\\mathrm{D} \\rightarrow \\mathrm{I}$): For each subcycle, first apply the drag operator as above, then apply the injection operator that increases kinetic energy by $L \\delta t$.\n\nAcross the whole injection duration $T_{\\mathrm{inj}}$, integrate with global steps of size $\\Delta t$ until $t = T_{\\mathrm{inj}}$ (taking the final global step smaller if necessary so that the total time exactly equals $T_{\\mathrm{inj}}$). The total injected energy is $E_{\\mathrm{in}} = L T_{\\mathrm{inj}}$ (expressed in Joules), and the total dissipated energy is $D_{\\mathrm{num}}$ (the sum of $D_{\\mathrm{sub}}$ over all drag subcycles, in Joules). The numerical kinetic energy change is $\\Delta K_{\\mathrm{num}} = \\tfrac{1}{2} m v(T_{\\mathrm{inj}})^2 - \\tfrac{1}{2} m v_0^2$ (in Joules). Define the energy conservation error as the dimensionless fraction\n$$\n\\varepsilon_E = \\frac{E_{\\mathrm{in}} - \\Delta K_{\\mathrm{num}} - D_{\\mathrm{num}}}{E_{\\mathrm{in}}}.\n$$\nFor the continuous system, derive from first principles the exact $v(t)$ and the exact drag energy $D_{\\mathrm{exact}}$ by integrating the base energy balance over $[0, T_{\\mathrm{inj}}]$. Using these, compute the final exact wind speed $v_{\\mathrm{exact}} = v(T_{\\mathrm{inj}})$ and define the fractional bias in wind speed (dimensionless) as\n$$\n\\varepsilon_v = \\begin{cases}\n\\dfrac{v_{\\mathrm{num}} - v_{\\mathrm{exact}}}{v_{\\mathrm{exact}}},  v_{\\mathrm{exact}} \\neq 0 \\\\\n0,  v_{\\mathrm{exact}} = 0\n\\end{cases}\n$$\nwhere $v_{\\mathrm{num}}$ is the numerically obtained wind speed at $t = T_{\\mathrm{inj}}$. All velocities must be expressed in $\\mathrm{m/s}$, all times in $\\mathrm{s}$, power in $\\mathrm{J/s}$, mass in $\\mathrm{kg}$, and energies in $\\mathrm{J}$. The final answers $\\varepsilon_E$ and $\\varepsilon_v$ for each test case must each be returned as real numbers without unit symbols, and must be represented as decimals (floats).\n\nImplement a program that, given fixed physical parameters $(m, \\tau_{\\mathrm{d}}, L, v_0, T_{\\mathrm{inj}})$ and a set of numerical parameters $(\\Delta t, n_{\\mathrm{sub}}, \\text{ordering})$, computes $(\\varepsilon_E, \\varepsilon_v)$ for each test case as specified above. The injection operator must update speed by enforcing the kinetic energy increment $L \\delta t$. The drag operator must use forward-Euler speed update $v \\leftarrow v (1 - \\delta t/\\tau_{\\mathrm{d}})$ and must approximate dissipated energy in that subcycle as $m v_{\\mathrm{pre}}^2 \\delta t/\\tau_{\\mathrm{d}}$.\n\nYour program should handle the following test suite, with common physical parameters $m = 1.0$ (in $\\mathrm{kg}$), $\\tau_{\\mathrm{d}} = 2.0$ (in $\\mathrm{s}$), $L = 1.0$ (in $\\mathrm{J/s}$), $v_0 = 0.0$ (in $\\mathrm{m/s}$), $T_{\\mathrm{inj}} = 4.0$ (in $\\mathrm{s}$). The numerical parameters for each case are:\n- Case $1$: $\\Delta t = 0.1$ (in $\\mathrm{s}$), $n_{\\mathrm{sub}} = 1$, ordering $=$ $\\mathrm{I} \\rightarrow \\mathrm{D}$.\n- Case $2$: $\\Delta t = 0.1$ (in $\\mathrm{s}$), $n_{\\mathrm{sub}} = 1$, ordering $=$ $\\mathrm{D} \\rightarrow \\mathrm{I}$.\n- Case $3$: $\\Delta t = 0.5$ (in $\\mathrm{s}$), $n_{\\mathrm{sub}} = 1$, ordering $=$ $\\mathrm{I} \\rightarrow \\mathrm{D}$.\n- Case $4$: $\\Delta t = 0.5$ (in $\\mathrm{s}$), $n_{\\mathrm{sub}} = 5$, ordering $=$ $\\mathrm{I} \\rightarrow \\mathrm{D}$.\n- Case $5$: $\\Delta t = 2.0$ (in $\\mathrm{s}$), $n_{\\mathrm{sub}} = 1$, ordering $=$ $\\mathrm{D} \\rightarrow \\mathrm{I}$.\n\nYour program should produce a single line of output containing the results as a comma-separated Python-style list, where each element corresponds to one test case and is itself a list of two floats $[\\varepsilon_E, \\varepsilon_v]$. For example, the output format must be\n$$\n[\\,[\\varepsilon_{E,1}, \\varepsilon_{v,1}], [\\varepsilon_{E,2}, \\varepsilon_{v,2}], \\dots ].\n$$\nThe ordering labels must be interpreted exactly as written above. All required units have been specified; ensure any numeric answers derived for energies and velocities are based on these units. The program must not read input; it must embed the test suite and print the single output line. The numerical scheme must implement the operator splitting and subcycling as described, and the exact reference must be derived from the given base laws. Report each $\\varepsilon_E$ and each $\\varepsilon_v$ as floats without rounding to a fixed number of decimal places.", "solution": "The user-provided problem has been assessed and is valid.\n\n### Problem Validation\n\n#### Step 1: Extract Givens\n\nThe provided problem statement specifies the following givens:\n- **Physical Model**: A one-zone subgrid model for wind with speed $v(t)$ and mass $m$.\n- **Energy Injection**: Constant power $L$ over a duration $T_{\\mathrm{inj}}$.\n- **Energy Dissipation**: A linear drag characterized by timescale $\\tau_{\\mathrm{d}}$, with dissipative power $P_{\\mathrm{drag}}(t) = m v(t)^2 / \\tau_{\\mathrm{d}}$.\n- **Governing Equation**: The energy balance for kinetic energy $K(t) = \\tfrac{1}{2} m v(t)^2$ is given by:\n$$ \\frac{dK}{dt} = L - \\frac{m v(t)^2}{\\tau_{\\mathrm{d}}} $$\n- **Initial Condition**: At $t=0$, speed is $v_0$ and kinetic energy is $K_0 = \\tfrac{1}{2} m v_0^2$.\n- **Numerical Scheme**: Operator splitting with global time step $\\Delta t$ and subcycling count $n_{\\mathrm{sub}} \\geq 1$. Subcycle step size is $\\delta t = \\Delta t / n_{\\mathrm{sub}}$.\n- **Operators**:\n    - **Injection Operator ($\\mathrm{I}$)**: Increases kinetic energy: $K \\leftarrow K + L \\delta t$. The speed $v$ is updated accordingly.\n    - **Drag Operator ($\\mathrm{D}$)**: Updates speed via forward-Euler: $v \\leftarrow v \\left( 1 - \\delta t / \\tau_{\\mathrm{d}} \\right)$.\n- **Dissipated Energy Calculation (Numerical)**: In each subcycle, the dissipated energy is approximated as $D_{\\mathrm{sub}} \\approx m v_{\\mathrm{pre}}^2 \\delta t / \\tau_{\\mathrm{d}}$, where $v_{\\mathrm{pre}}$ is the speed before the drag operator is applied. The total numerical dissipated energy $D_{\\mathrm{num}}$ is the sum of all $D_{\\mathrm{sub}}$.\n- **Operator Orderings**:\n    - Injection-then-Drag ($\\mathrm{I} \\rightarrow \\mathrm{D}$)\n    - Drag-then-Injection ($\\mathrm{D} \\rightarrow \\mathrm{I}$)\n- **Integration Period**: Integration proceeds from $t=0$ to $t=T_{\\mathrm{inj}}$.\n- **Error Definitions**:\n    - Total injected energy: $E_{\\mathrm{in}} = L T_{\\mathrm{inj}}$.\n    - Numerical change in kinetic energy: $\\Delta K_{\\mathrm{num}} = \\tfrac{1}{2} m v(T_{\\mathrm{inj}})^2 - \\tfrac{1}{2} m v_0^2$.\n    - Energy conservation error: $\\varepsilon_E = (E_{\\mathrm{in}} - \\Delta K_{\\mathrm{num}} - D_{\\mathrm{num}})/E_{\\mathrm{in}}$.\n    - Fractional bias in wind speed: $\\varepsilon_v = (v_{\\mathrm{num}} - v_{\\mathrm{exact}})/v_{\\mathrm{exact}}$ for $v_{\\mathrm{exact}} \\neq 0$, and $\\varepsilon_v = 0$ for $v_{\\mathrm{exact}}=0$.\n- **Physical Parameters**: $m = 1.0\\,\\mathrm{kg}$, $\\tau_{\\mathrm{d}} = 2.0\\,\\mathrm{s}$, $L = 1.0\\,\\mathrm{J/s}$, $v_0 = 0.0\\,\\mathrm{m/s}$, $T_{\\mathrm{inj}} = 4.0\\,\\mathrm{s}$.\n- **Test Cases**:\n    - Case 1: $\\Delta t = 0.1\\,\\mathrm{s}$, $n_{\\mathrm{sub}} = 1$, ordering = $\\mathrm{I} \\rightarrow \\mathrm{D}$.\n    - Case 2: $\\Delta t = 0.1\\,\\mathrm{s}$, $n_{\\mathrm{sub}} = 1$, ordering = $\\mathrm{D} \\rightarrow \\mathrm{I}$.\n    - Case 3: $\\Delta t = 0.5\\,\\mathrm{s}$, $n_{\\mathrm{sub}} = 1$, ordering = $\\mathrm{I} \\rightarrow \\mathrm{D}$.\n    - Case 4: $\\Delta t = 0.5\\,\\mathrm{s}$, $n_{\\mathrm{sub}} = 5$, ordering = $\\mathrm{I} \\rightarrow \\mathrm{D}$.\n    - Case 5: $\\Delta t = 2.0\\,\\mathrm{s}$, $n_{\\mathrm{sub}} = 1$, ordering = $\\mathrm{D} \\rightarrow \\mathrm{I}$.\n\n#### Step 2: Validate Using Extracted Givens\nThe problem is analyzed against the validation criteria:\n- **Scientifically Grounded**: The problem describes a simplified, but physically consistent, model of feedback processes. The governing equation is a standard energy balance equation. The numerical methods (operator splitting, forward Euler) are standard techniques. The model is a valid simplification used in computational astrophysics.\n- **Well-Posed**: The problem provides a first-order ordinary differential equation with an initial condition, which has a unique solution. The numerical scheme is explicitly defined, leading to a deterministic outcome for each test case. All parameters are specified.\n- **Objective**: The problem is stated using precise mathematical and physical language. The requirements for the solution and output format are unambiguous. There are no subjective or opinion-based statements.\n- **Completeness**: All necessary parameters, initial conditions, equations, and procedures are provided to derive the exact solution and implement the numerical model.\n- **Consistency**: There are no internal contradictions in the problem statement. The definitions for the operators and error metrics are consistent.\n\n#### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be provided.\n\n### Solution Derivation and Algorithmic Design\n\nThe solution requires two components: the derivation of the exact analytical solution to serve as a benchmark, and the implementation of the specified numerical scheme.\n\n#### 1. Exact Analytical Solution\n\nThe governing equation for the kinetic energy $K(t)$ is:\n$$ \\frac{dK}{dt} = L - \\frac{m v(t)^2}{\\tau_{\\mathrm{d}}} $$\nUsing the definition $K(t) = \\frac{1}{2}mv(t)^2$, we can rewrite the equation in terms of $K(t)$ alone:\n$$ \\frac{dK}{dt} = L - \\frac{2K(t)}{\\tau_{\\mathrm{d}}} $$\nThis is a first-order linear ordinary differential equation. We can rearrange it into the standard form:\n$$ \\frac{dK}{dt} + \\frac{2}{\\tau_{\\mathrm{d}}} K(t) = L $$\nThe solution can be found using the method of integrating factors. The integrating factor is $I(t) = \\exp\\left(\\int \\frac{2}{\\tau_{\\mathrm{d}}} dt\\right) = e^{2t/\\tau_{\\mathrm{d}}}$. Multiplying the ODE by $I(t)$ gives:\n$$ \\frac{d}{dt}\\left( K(t) e^{2t/\\tau_{\\mathrm{d}}} \\right) = L e^{2t/\\tau_{\\mathrm{d}}} $$\nIntegrating with respect to time from $0$ to $t$:\n$$ K(t)e^{2t/\\tau_{\\mathrm{d}}} - K(0)e^{0} = \\int_0^t L e^{2t'/\\tau_{\\mathrm{d}}} dt' = L \\frac{\\tau_{\\mathrm{d}}}{2} \\left( e^{2t/\\tau_{\\mathrm{d}}} - 1 \\right) $$\nWith the initial condition $K(0) = K_0$, we solve for $K(t)$:\n$$ K(t) = K_0 e^{-2t/\\tau_{\\mathrm{d}}} + \\frac{L\\tau_{\\mathrm{d}}}{2} \\left(1 - e^{-2t/\\tau_{\\mathrm{d}}}\\right) $$\nThis can be rearranged to:\n$$ K(t) = \\frac{L\\tau_{\\mathrm{d}}}{2} + \\left(K_0 - \\frac{L\\tau_{\\mathrm{d}}}{2}\\right) e^{-2t/\\tau_{\\mathrm{d}}} $$\nThe exact final kinetic energy at $t=T_{\\mathrm{inj}}$ is $K_{\\mathrm{exact}}(T_{\\mathrm{inj}})$. The exact final velocity $v_{\\mathrm{exact}}$ is then:\n$$ v_{\\mathrm{exact}} = \\sqrt{\\frac{2 K_{\\mathrm{exact}}(T_{\\mathrm{inj}})}{m}} = \\sqrt{\\frac{2}{m} \\left[ \\frac{L\\tau_{\\mathrm{d}}}{2} + \\left(\\frac{1}{2}mv_0^2 - \\frac{L\\tau_{\\mathrm{d}}}{2}\\right) e^{-2T_{\\mathrm{inj}}/\\tau_{\\mathrm{d}}} \\right]} $$\nThe total injected energy over the duration is $E_{\\mathrm{in}} = L T_{\\mathrm{inj}}$. The exact change in kinetic energy is $\\Delta K_{\\mathrm{exact}} = K_{\\mathrm{exact}}(T_{\\mathrm{inj}}) - K_0$. By energy conservation, the total energy dissipated by drag, $D_{\\mathrm{exact}}$, is:\n$$ D_{\\mathrm{exact}} = E_{\\mathrm{in}} - \\Delta K_{\\mathrm{exact}} $$\nFor the given parameters, $m=1.0$, $\\tau_{\\mathrm{d}}=2.0$, $L=1.0$, $v_0=0.0$, and $T_{\\mathrm{inj}}=4.0$, we have $K_0=0$. The exact final kinetic energy is:\n$$ K_{\\mathrm{exact}}(T_{\\mathrm{inj}}) = \\frac{1.0 \\cdot 2.0}{2} \\left(1 - e^{-2 \\cdot 4.0 / 2.0}\\right) = 1 - e^{-4} $$\nThe exact final velocity is:\n$$ v_{\\mathrm{exact}} = \\sqrt{\\frac{2(1-e^{-4})}{1.0}} = \\sqrt{2(1-e^{-4})} $$\n\n#### 2. Numerical Scheme\n\nThe numerical integration is performed over the time interval $[0, T_{\\mathrm{inj}}]$ using global steps of size $\\Delta t$. If $T_{\\mathrm{inj}}$ is not an integer multiple of $\\Delta t$, the final step is shortened to ensure the total time is exactly $T_{\\mathrm{inj}}$. Each global step is divided into $n_{\\mathrm{sub}}$ subcycles of duration $\\delta t = \\Delta t / n_{\\mathrm{sub}}$.\n\nThe state is described by the wind speed $v$. We also accumulate the total dissipated energy $D_{\\mathrm{num}}$. The process is as follows:\nInitialize $t=0$, $v=v_0$, $D_{\\mathrm{num}}=0$.\nLoop while $t  T_{\\mathrm{inj}}$:\n1. Determine current step size: $\\Delta t_{\\mathrm{current}} = \\min(\\Delta t, T_{\\mathrm{inj}} - t)$.\n2. Calculate subcycle step size: $\\delta t = \\Delta t_{\\mathrm{current}} / n_{\\mathrm{sub}}$.\n3. Perform a loop for $n_{\\mathrm{sub}}$ subcycles. In each subcycle:\n   a. Apply the injection and drag operators according to the specified `ordering`.\n\nThe operators are implemented as follows:\n\n**Injection Operator ($\\mathrm{I}$)**: Updates the kinetic energy $K \\leftarrow K + L\\delta t$.\nIf the speed before injection is $v_{\\mathrm{in}}$, the initial kinetic energy is $K_{\\mathrm{in}} = \\frac{1}{2} m v_{\\mathrm{in}}^2$.\nThe new kinetic energy is $K_{\\mathrm{out}} = K_{\\mathrm{in}} + L\\delta t$.\nThe new speed is $v_{\\mathrm{out}} = \\sqrt{2 K_{\\mathrm{out}}/m} = \\sqrt{v_{\\mathrm{in}}^2 + 2L\\delta t/m}$.\n\n**Drag Operator ($\\mathrm{D}$)**: Updates the speed with a forward-Euler step and calculates the dissipated energy.\nIf the speed before drag is $v_{\\mathrm{in}}$, the new speed is $v_{\\mathrm{out}} = v_{\\mathrm{in}}(1 - \\delta t/\\tau_{\\mathrm{d}})$.\nThe dissipated energy for the subcycle is explicitly defined as $D_{\\mathrm{sub}} = m v_{\\mathrm{in}}^2 \\delta t / \\tau_{\\mathrm{d}}$. This value is added to the total $D_{\\mathrm{num}}$.\n\nThe two required orderings are:\n- **Injection-then-Drag ($\\mathrm{I} \\rightarrow \\mathrm{D}$)**: Within a subcycle, first apply operator $\\mathrm{I}$, then apply operator $\\mathrm{D}$. The $v_{\\mathrm{pre}}$ for the drag dissipation calculation is the speed *after* the injection operator has been applied.\n- **Drag-then-Injection ($\\mathrm{D} \\rightarrow \\mathrm{I}$)**: Within a subcycle, first apply operator $\\mathrm{D}$, then apply operator $\\mathrm{I}$. The $v_{\\mathrm{pre}}$ for the drag dissipation calculation is the speed *before* the drag operator has been applied.\n\n#### 3. Error Calculation\n\nAfter the simulation loop completes at $t=T_{\\mathrm{inj}}$, we have the final numerical speed $v_{\\mathrm{num}}$ and the total numerical dissipated energy $D_{\\mathrm{num}}$. We then compute:\n- Final numerical kinetic energy: $K_{\\mathrm{num, final}} = \\frac{1}{2}m v_{\\mathrm{num}}^2$.\n- Numerical change in kinetic energy: $\\Delta K_{\\mathrm{num}} = K_{\\mathrm{num, final}} - K_0$.\n- Total injected energy: $E_{\\mathrm{in}} = L T_{\\mathrm{inj}}$.\n- Energy conservation error: $\\varepsilon_E = (E_{\\mathrm{in}} - \\Delta K_{\\mathrm{num}} - D_{\\mathrm{num}})/E_{\\mathrm{in}}$. This error arises because the update rule for kinetic energy in the drag step, $K \\leftarrow K(1-\\delta t/\\tau_d)^2$, is not perfectly consistent with the approximation used for dissipated energy, $D_{sub}$.\n- Fractional velocity bias: $\\varepsilon_v = (v_{\\mathrm{num}} - v_{\\mathrm{exact}})/v_{\\mathrm{exact}}$, using the previously derived $v_{\\mathrm{exact}}$.\n\nThe algorithm is implemented in Python to process all five test cases and format the output as requested.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the subgrid feedback model problem for a suite of test cases.\n    It calculates the exact solution and then runs a numerical simulation\n    for each case to determine the energy conservation error and velocity bias.\n    \"\"\"\n\n    # Common physical parameters\n    m = 1.0  # kg\n    tau_d = 2.0  # s\n    L = 1.0  # J/s\n    v0 = 0.0  # m/s\n    T_inj = 4.0  # s\n\n    # Test suite\n    test_cases = [\n        {'dt': 0.1, 'n_sub': 1, 'ordering': 'I-D'},\n        {'dt': 0.1, 'n_sub': 1, 'ordering': 'D-I'},\n        {'dt': 0.5, 'n_sub': 1, 'ordering': 'I-D'},\n        {'dt': 0.5, 'n_sub': 5, 'ordering': 'I-D'},\n        {'dt': 2.0, 'n_sub': 1, 'ordering': 'D-I'},\n    ]\n\n    # --- Exact Solution Calculation ---\n    K0 = 0.5 * m * v0**2\n    \n    # Exact kinetic energy at T_inj\n    K_exact_final = (L * tau_d / 2.0) + (K0 - L * tau_d / 2.0) * np.exp(-2 * T_inj / tau_d)\n    \n    # Exact final velocity\n    if K_exact_final = 0:\n        v_exact = np.sqrt(2 * K_exact_final / m)\n    else:\n        # Should not happen with given parameters\n        v_exact = 0.0\n\n    results = []\n    for case in test_cases:\n        dt = case['dt']\n        n_sub = case['n_sub']\n        ordering = case['ordering']\n\n        # --- Numerical Simulation ---\n        v = v0\n        current_time = 0.0\n        D_num = 0.0\n\n        # Loop over global time steps until T_inj is reached\n        while not np.isclose(current_time, T_inj):\n            time_step = min(dt, T_inj - current_time)\n            delta_t_sub = time_step / n_sub\n\n            # Subcycling loop\n            for _ in range(n_sub):\n                if ordering == 'I-D':\n                    # 1. Injection Operator\n                    v = np.sqrt(v**2 + 2 * L * delta_t_sub / m)\n                    \n                    # 2. Drag Operator\n                    v_pre_drag = v\n                    D_sub = m * v_pre_drag**2 * delta_t_sub / tau_d\n                    D_num += D_sub\n                    v = v_pre_drag * (1.0 - delta_t_sub / tau_d)\n\n                elif ordering == 'D-I':\n                    # 1. Drag Operator\n                    v_pre_drag = v\n                    D_sub = m * v_pre_drag**2 * delta_t_sub / tau_d\n                    D_num += D_sub\n                    v = v_pre_drag * (1.0 - delta_t_sub / tau_d)\n                    \n                    # 2. Injection Operator\n                    v = np.sqrt(v**2 + 2 * L * delta_t_sub / m)\n            \n            current_time += time_step\n\n        v_num = v\n        \n        # --- Error Calculation ---\n        E_in = L * T_inj\n        K_num_final = 0.5 * m * v_num**2\n        delta_K_num = K_num_final - K0\n        \n        # Energy conservation error\n        # Avoid division by zero if E_in is zero, though not possible in this problem.\n        epsilon_E = (E_in - delta_K_num - D_num) / E_in if E_in != 0 else 0.0\n        \n        # Fractional bias in wind speed\n        if v_exact != 0:\n            epsilon_v = (v_num - v_exact) / v_exact\n        else:\n            epsilon_v = 0.0\n            \n        results.append([epsilon_E, epsilon_v])\n\n    # Final print statement in the exact required format.\n    # The default string representation for a list includes spaces, which\n    # aligns with the Python-style list format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3491413"}, {"introduction": "Having diagnosed numerical challenges, we now move to constructing a proactive solution. Instead of only injecting thermal or kinetic energy, a more robust approach is to model the unresolved turbulent cascade that feedback drives. This practice [@problem_id:3491461] tasks you with building a simple but powerful subgrid model that tracks the evolution of turbulent kinetic energy, balancing source terms from feedback against physical dissipation and buoyancy sinks, a foundational step in developing more physically realistic simulations.", "problem": "You will design and implement a minimal subgrid model for specific turbulent kinetic energy $k$ in a one-dimensional stratified box with constant gravitational acceleration $g$, driven by volumetric energy injection from supernovae (SN) and active galactic nuclei (AGN). The model should be validated at the midplane $z=0$ by solving for the steady-state value of $k$ under the following assumptions.\n\nModeling assumptions to be treated as foundational starting points:\n- The gas is isothermal with sound speed $c_s$ and midplane density $\\rho_0$, in hydrostatic equilibrium with constant gravitational acceleration $g$, so that the characteristic isothermal pressure scale height is $H = c_s^2/g$.\n- The subgrid mixing length is modeled as $\\ell = \\alpha H$, where $\\alpha$ is a constant dimensionless parameter.\n- A fraction $f_{\\mathrm{SN}}$ of the supernova volumetric energy injection rate $e_{\\mathrm{SN},0}$ and a fraction $f_{\\mathrm{AGN}}$ of the active galactic nucleus volumetric energy injection rate $e_{\\mathrm{AGN},0}$ are converted into subgrid turbulent energy at $z=0$. The corresponding specific turbulent energy injection rate is $S = \\left(f_{\\mathrm{SN}} e_{\\mathrm{SN},0} + f_{\\mathrm{AGN}} e_{\\mathrm{AGN},0}\\right)/\\rho_0$.\n- The dissipation of turbulent energy follows the Kolmogorov scaling closure $\\varepsilon = C_\\varepsilon k^{3/2}/\\ell$, where $C_\\varepsilon$ is a constant of order unity.\n- Stable stratification induces a buoyancy sink modeled as $B = - C_b (g/c_s) k$, where $C_b$ is a dimensionless constant.\n\nStarting from the turbulent kinetic energy budget and neglecting advection at the midplane, impose the steady-state condition $\\partial_t k = 0$ at $z=0$ by balancing production and sinks. Use only the definitions given above to obtain a solvable algebraic condition for $k \\ge 0$.\n\nYour program must, for each test case below, compute the steady-state midplane value $k$ in $\\mathrm{cm}^2\\,\\mathrm{s}^{-2}$ that satisfies the steady-state balance implied by the above closures, subject to the constraints that $k \\ge 0$ and that the physically relevant solution is the unique nonnegative real root of the implied steady-state equation.\n\nPhysical units to use throughout:\n- $g$ in $\\mathrm{cm}\\,\\mathrm{s}^{-2}$,\n- $c_s$ in $\\mathrm{cm}\\,\\mathrm{s}^{-1}$,\n- $\\rho_0$ in $\\mathrm{g}\\,\\mathrm{cm}^{-3}$,\n- $e_{\\mathrm{SN},0}$ and $e_{\\mathrm{AGN},0}$ in $\\mathrm{erg}\\,\\mathrm{cm}^{-3}\\,\\mathrm{s}^{-1}$,\n- $k$ in $\\mathrm{cm}^2\\,\\mathrm{s}^{-2}$.\n\nConstants shared by all test cases:\n- $\\alpha = 0.5$,\n- $C_\\varepsilon = 1.0$,\n- $C_b = 0.5$.\n\nTest suite parameter sets (each case gives the tuple $(g, c_s, \\rho_0, e_{\\mathrm{SN},0}, f_{\\mathrm{SN}}, e_{\\mathrm{AGN},0}, f_{\\mathrm{AGN}})$):\n1. Case A (SN-dominated warm disk): $(g = 2.0\\times 10^{-9},\\ c_s = 1.0\\times 10^{6},\\ \\rho_0 = 1.67\\times 10^{-24},\\ e_{\\mathrm{SN},0} = 1.0\\times 10^{-26},\\ f_{\\mathrm{SN}} = 0.10,\\ e_{\\mathrm{AGN},0} = 0.0,\\ f_{\\mathrm{AGN}} = 0.0)$.\n2. Case B (AGN-dominated hot halo): $(g = 1.0\\times 10^{-8},\\ c_s = 1.0\\times 10^{7},\\ \\rho_0 = 1.0\\times 10^{-26},\\ e_{\\mathrm{SN},0} = 0.0,\\ f_{\\mathrm{SN}} = 0.0,\\ e_{\\mathrm{AGN},0} = 1.0\\times 10^{-25},\\ f_{\\mathrm{AGN}} = 0.30)$.\n3. Case C (combined driving): $(g = 5.0\\times 10^{-9},\\ c_s = 1.0\\times 10^{6},\\ \\rho_0 = 5.0\\times 10^{-25},\\ e_{\\mathrm{SN},0} = 3.0\\times 10^{-26},\\ f_{\\mathrm{SN}} = 0.20,\\ e_{\\mathrm{AGN},0} = 1.0\\times 10^{-25},\\ f_{\\mathrm{AGN}} = 0.05)$.\n4. Case D (no sources boundary case): $(g = 2.0\\times 10^{-9},\\ c_s = 1.0\\times 10^{6},\\ \\rho_0 = 1.67\\times 10^{-24},\\ e_{\\mathrm{SN},0} = 0.0,\\ f_{\\mathrm{SN}} = 0.0,\\ e_{\\mathrm{AGN},0} = 0.0,\\ f_{\\mathrm{AGN}} = 0.0)$.\n5. Case E (strong gravity suppression): $(g = 3.0\\times 10^{-8},\\ c_s = 1.0\\times 10^{6},\\ \\rho_0 = 1.67\\times 10^{-24},\\ e_{\\mathrm{SN},0} = 1.0\\times 10^{-26},\\ f_{\\mathrm{SN}} = 0.10,\\ e_{\\mathrm{AGN},0} = 0.0,\\ f_{\\mathrm{AGN}} = 0.0)$.\n\nNumerical requirements:\n- For each case, compute $H = c_s^2/g$ and $\\ell = \\alpha H$ using the given $g$ and $c_s$.\n- Construct the steady-state equation implied by the above closures and solve for the unique nonnegative real solution $k$.\n- Express each resulting $k$ in $\\mathrm{cm}^2\\,\\mathrm{s}^{-2}$, rounded to three significant figures.\n\nFinal output format:\n- Your program should produce a single line of output containing the list of the five rounded values in order, as a comma-separated list enclosed in square brackets, for example $[x_1,x_2,x_3,x_4,x_5]$, where each $x_i$ is a floating-point numeral rounded to three significant figures. No additional characters or whitespace are permitted.", "solution": "The problem has been validated and is deemed sound. It is a well-posed problem in applied physics, grounded in standard, albeit simplified, models used in astrophysical fluid dynamics. All necessary parameters and definitions are provided, and no internal contradictions or scientific fallacies have been identified. We may therefore proceed with a formal solution.\n\nThe problem asks for the steady-state value of the specific turbulent kinetic energy, denoted by $k$, at the midplane ($z=0$) of a stratified environment. The evolution of $k$ is governed by a budget equation that balances sources and sinks. Neglecting advection at the midplane, the budget equation is:\n$$\n\\frac{\\partial k}{\\partial t} = S - \\varepsilon - \\Lambda_B\n$$\nwhere $S$ is the specific turbulent energy injection rate, $\\varepsilon$ is the turbulent dissipation rate, and $\\Lambda_B$ is the buoyancy sink term.\n\nAccording to the problem statement, these terms are modeled as follows:\n$1$. The specific turbulent energy injection rate $S$ combines contributions from supernovae (SN) and active galactic nuclei (AGN):\n$$\nS = \\frac{f_{\\mathrm{SN}} e_{\\mathrm{SN},0} + f_{\\mathrm{AGN}} e_{\\mathrm{AGN},0}}{\\rho_0}\n$$\nwhere $e_{\\mathrm{SN},0}$ and $e_{\\mathrm{AGN},0}$ are the volumetric energy injection rates, $f_{\\mathrm{SN}}$ and $f_{\\mathrm{AGN}}$ are the respective coupling efficiencies, and $\\rho_0$ is the midplane gas density.\n\n$2$. The turbulent dissipation rate $\\varepsilon$ follows a Kolmogorov-like scaling:\n$$\n\\varepsilon = \\frac{C_\\varepsilon k^{3/2}}{\\ell}\n$$\nwhere $C_\\varepsilon$ is a dimensionless constant and $\\ell$ is the subgrid mixing length.\n\n$3$. The problem defines a buoyancy term $B = - C_b (g/c_s) k$. As this term must act as a sink, it contributes negatively to the energy budget. The sink term is $\\Lambda_B = -B = C_b (g/c_s) k$. The term as written in the problem statement $B$ is thus the negative of the sink, representing the rate of change of $k$ due to buoyancy. The budget equation can be written as $\\partial_t k = S - \\varepsilon + B$. Substituting the model for $B$:\n$$\n\\frac{\\partial k}{\\partial t} = S - \\frac{C_\\varepsilon k^{3/2}}{\\ell} - C_b \\frac{g}{c_s} k\n$$\nThis formulation is consistent with physical intuition, as both dissipation and stable stratification (buoyancy) act to damp turbulence.\n\nThe mixing length $\\ell$ is related to the isothermal pressure scale height $H$ by $\\ell = \\alpha H$, where $\\alpha$ is a dimensionless parameter. The scale height is defined as $H = c_s^2/g$, where $c_s$ is the isothermal sound speed and $g$ is the gravitational acceleration. Substituting these definitions, we find:\n$$\n\\ell = \\alpha \\frac{c_s^2}{g}\n$$\nIn the steady-state condition, $\\partial k / \\partial t = 0$, the sources and sinks must balance:\n$$\nS - \\frac{C_\\varepsilon k^{3/2}}{\\alpha c_s^2 / g} - C_b \\frac{g}{c_s} k = 0\n$$\nRearranging the terms, we get an equation for $k$:\n$$\n\\frac{C_\\varepsilon g}{\\alpha c_s^2} k^{3/2} + C_b \\frac{g}{c_s} k = S\n$$\nTo solve this equation, it is convenient to introduce the variable $x = \\sqrt{k}$. Since $k$ represents specific kinetic energy, it must be non-negative, so we seek solutions where $x \\ge 0$. In terms of $x$, the equation becomes a cubic polynomial:\n$$\n\\left(\\frac{C_\\varepsilon g}{\\alpha c_s^2}\\right) x^3 + \\left(C_b \\frac{g}{c_s}\\right) x^2 - S = 0\n$$\nThis equation is of the general form $P_3 x^3 + P_2 x^2 + P_1 x + P_0 = 0$, with coefficients:\n- $P_3 = \\frac{C_\\varepsilon g}{\\alpha c_s^2}$\n- $P_2 = C_b \\frac{g}{c_s}$\n- $P_1 = 0$\n- $P_0 = -S$\n\nThe physical parameters $g, c_s, \\alpha, C_\\varepsilon, C_b$ are all positive constants. Therefore, the coefficients $P_3$ and $P_2$ are strictly positive. The source term $S$ is non-negative ($S \\ge 0$), so $P_0 \\le 0$.\n\nLet's analyze the function $f(x) = P_3 x^3 + P_2 x^2 - S$. Its derivative is $f'(x) = 3 P_3 x^2 + 2 P_2 x$. Since $P_3  0$ and $P_2  0$, $f'(x)  0$ for all $x  0$. This means that for $x \\ge 0$, $f(x)$ is a strictly monotonically increasing function.\nAt $x=0$, we have $f(0) = -S$.\n- If $S=0$, then $f(0)=0$, and thus $x=0$ is the unique non-negative root. This corresponds to $k=0$, the physically expected result for no energy injection.\n- If $S  0$, then $f(0) = -S  0$. Since $f(x)$ is continuous, monotonic, and $\\lim_{x\\to\\infty} f(x) = \\infty$, the Intermediate Value Theorem guarantees the existence of exactly one positive real root $x_{sol}  0$.\n\nFor each test case, we will compute the coefficients $P_3$, $P_2$, and $P_0 = -S$ using the provided parameters. We will then solve the cubic equation for its roots. The unique non-negative real root, $x_{sol}$, will be squared to find the steady-state turbulent kinetic energy, $k = x_{sol}^2$. The final value will be rounded to three significant figures.\n\nThe shared constants for all cases are $\\alpha = 0.5$, $C_\\varepsilon = 1.0$, and $C_b = 0.5$. The following procedure will be implemented for each test case:\n$1$. Calculate the source term $S$ from the given parameters.\n$2$. If $S=0$, the solution is $k=0\\,\\mathrm{cm}^2\\,\\mathrm{s}^{-2}$.\n$3$. If $S0$, compute the polynomial coefficients $P_3$ and $P_2$.\n$4$. Numerically find the roots of the cubic polynomial $P_3 x^3 + P_2 x^2 - S = 0$.\n$5$. Identify the unique non-negative real root $x_{sol}$.\n$6$. Compute $k = x_{sol}^2$.\n$7$. Round the result for $k$ to three significant figures and present it in the final output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the steady-state midplane turbulent kinetic energy k for a series of test cases.\n    \"\"\"\n    # Shared constants from the problem statement.\n    ALPHA = 0.5\n    C_EPS = 1.0\n    C_B = 0.5\n\n    # Test suite parameter sets:\n    # (g, c_s, rho_0, e_SN,0, f_SN, e_AGN,0, f_AGN)\n    test_cases = [\n        # Case A (SN-dominated warm disk)\n        (2.0e-9, 1.0e6, 1.67e-24, 1.0e-26, 0.10, 0.0, 0.0),\n        # Case B (AGN-dominated hot halo)\n        (1.0e-8, 1.0e7, 1.0e-26, 0.0, 0.0, 1.0e-25, 0.30),\n        # Case C (combined driving)\n        (5.0e-9, 1.0e6, 5.0e-25, 3.0e-26, 0.20, 1.0e-25, 0.05),\n        # Case D (no sources boundary case)\n        (2.0e-9, 1.0e6, 1.67e-24, 0.0, 0.0, 0.0, 0.0),\n        # Case E (strong gravity suppression)\n        (3.0e-8, 1.0e6, 1.67e-24, 1.0e-26, 0.10, 0.0, 0.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        g, c_s, rho_0, e_sn_0, f_sn, e_agn_0, f_agn = case\n\n        # Calculate the specific turbulent energy injection rate S.\n        # Erg = g * cm^2 / s^2. S has units of cm^2/s^3.\n        s_term = (f_sn * e_sn_0 + f_agn * e_agn_0) / rho_0\n\n        if s_term == 0:\n            # If there are no sources, the turbulent kinetic energy is zero.\n            k_val = 0.0\n        else:\n            # Set up the cubic equation for x = sqrt(k): P3*x^3 + P2*x^2 - S = 0\n            # P3 = (C_epsilon * g) / (alpha * c_s^2)\n            # P2 = C_b * g / c_s\n            # P1 = 0\n            # P0 = -S\n            \n            p3 = (C_EPS * g) / (ALPHA * c_s**2)\n            p2 = (C_B * g) / c_s\n            p1 = 0.0\n            p0 = -s_term\n            \n            coeffs = [p3, p2, p1, p0]\n            \n            # Find the roots of the polynomial.\n            roots = np.roots(coeffs)\n            \n            # Find the unique non-negative real root for x = sqrt(k).\n            x_sol = None\n            for root in roots:\n                if np.isreal(root) and root.real = 0:\n                    x_sol = root.real\n                    break\n            \n            if x_sol is None:\n                # This should not happen based on the problem analysis.\n                # Raise an error for robustness.\n                raise ValueError(\"No non-negative real root found.\")\n\n            # Calculate k from x.\n            k_val = x_sol**2\n\n        # Format the result to 3 significant figures.\n        # The 'g' format specifier handles general number formatting,\n        # switching to scientific notation for large/small numbers.\n        if k_val == 0.0:\n            formatted_k = '0.0'\n        else:\n            formatted_k = format(k_val, '.3g')\n        results.append(formatted_k)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3491461"}]}