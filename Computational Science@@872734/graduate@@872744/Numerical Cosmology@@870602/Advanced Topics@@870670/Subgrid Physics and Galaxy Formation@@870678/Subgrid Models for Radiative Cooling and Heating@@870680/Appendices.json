{"hands_on_practices": [{"introduction": "The thermal state of cosmic gas is dictated by a dynamic balance between various heating and cooling mechanisms. This first exercise provides a foundational, hands-on calculation of the equilibrium temperature in the low-density Intergalactic Medium (IGM), a key environment in cosmology. By deriving the balance equation under the assumption of photoionization equilibrium, you will discover a crucial, non-intuitive result about the relationship between temperature and gas density, and then solve for the temperature numerically [@problem_id:3491059]. This practice is essential for building a first-principles understanding of what sets the temperature of diffuse gas in the universe.", "problem": "Consider an optically thin, spatially uniform parcel of the low-density Intergalactic Medium (IGM) under Photoionization Equilibrium (PIE). Let the total hydrogen number density be $n$ (in $\\mathrm{cm}^{-3}$), the neutral hydrogen number density be $n_\\mathrm{HI}$ (in $\\mathrm{cm}^{-3}$), the electron number density be $n_e$ (in $\\mathrm{cm}^{-3}$), the proton number density be $n_p$ (in $\\mathrm{cm}^{-3}$), and the metallicity be $Z$ (expressed as a fraction of the solar metallicity). Assume pure hydrogen for ionization balance and a simple subgrid cooling parameterization that includes a primordial term and a metal-line term.\n\nFundamental energy balance requires that the volumetric cooling equals the volumetric heating. Beginning from first principles, set the radiative cooling per unit volume equal to the photoheating per unit volume. Assume hydrogen is the only ionized species for ionization balance, with electrons provided by hydrogen ionization, and that the gas is optically thin so that each ionization deposits an average excess energy. The target of this problem is to compute the equilibrium temperature $T_\\mathrm{eq}$ (in $\\mathrm{K}$) satisfying energy balance and to discuss its dependence on $n$ under PIE.\n\nStart from the following base:\n- Radiative cooling per unit volume is $n_e n_\\mathrm{H} \\Lambda(T,Z)$, where $n_\\mathrm{H}$ is the total hydrogen number density and $\\Lambda(T,Z)$ (in $\\mathrm{erg}\\,\\mathrm{cm}^{3}\\,\\mathrm{s}^{-1}$) is the cooling function.\n- Photoheating per unit volume is $n_\\mathrm{HI} \\Gamma \\langle E \\rangle$, where $\\Gamma$ (in $\\mathrm{s}^{-1}$) is the hydrogen photoionization rate and $\\langle E \\rangle$ (in $\\mathrm{erg}$) is the mean excess energy deposited per photoionization.\n- Photoionization equilibrium (PIE) gives $\\Gamma n_\\mathrm{HI} = \\alpha_\\mathrm{A}(T)\\, n_e n_p$, where $\\alpha_\\mathrm{A}(T)$ is the Case A recombination coefficient (in $\\mathrm{cm}^{3}\\,\\mathrm{s}^{-1}$).\n\nUsing these bases, derive a self-consistent scalar equation for $T_\\mathrm{eq}$, and implement it numerically. For the purposes of this problem, adopt the following scientifically plausible and widely used parameterizations:\n- The Case A recombination coefficient for hydrogen:\n$$\n\\alpha_\\mathrm{A}(T) = 4.2\\times10^{-13}\\left(\\frac{T}{10^{4}\\,\\mathrm{K}}\\right)^{-0.7}\\ \\mathrm{cm}^{3}\\,\\mathrm{s}^{-1}.\n$$\n- A subgrid cooling function composed of a primordial hydrogen term and a metal-line term:\n$$\n\\Lambda(T,Z) = \\Lambda_{0}\\left(\\frac{T}{10^{4}\\,\\mathrm{K}}\\right)^{a} + Z\\, \\Lambda_{Z,0}\\left(\\frac{T}{10^{4}\\,\\mathrm{K}}\\right)^{b},\n$$\nwith constants $\\Lambda_{0} = 1.2\\times10^{-24}\\ \\mathrm{erg}\\,\\mathrm{cm}^{3}\\,\\mathrm{s}^{-1}$, $a = 0.3$, $\\Lambda_{Z,0} = 3.0\\times10^{-24}\\ \\mathrm{erg}\\,\\mathrm{cm}^{3}\\,\\mathrm{s}^{-1}$, and $b = -0.2$. Here $Z$ is a dimensionless metallicity relative to solar (e.g., $Z=0.1$ means one tenth solar).\n\nAssume $n_e \\approx n_p \\approx n_\\mathrm{H}$ for the low-density, highly ionized IGM. Derive the equilibrium condition and solve for $T_\\mathrm{eq}$ numerically.\n\nYour program must:\n- Convert the photoheating excess energy $\\langle E \\rangle$ from electron-volts to $\\mathrm{erg}$ using $1\\,\\mathrm{eV} = 1.602176634\\times10^{-12}\\,\\mathrm{erg}$.\n- Solve for $T_\\mathrm{eq}$ (in $\\mathrm{K}$) by finding the root of a scalar function of $T$ derived from the energy balance and PIE, on the interval $[3000\\,\\mathrm{K},\\,30000\\,\\mathrm{K}]$. If a test case requires a wider bracket to find a root, you may expand the upper bound up to $100000\\,\\mathrm{K}$.\n- Express each computed equilibrium temperature in $\\mathrm{K}$ as a float.\n\nDiscuss within your solution the dependence of $T_\\mathrm{eq}$ on $n$ implied by the derivation under PIE.\n\nTest Suite:\nUse the following parameter sets for $(n, Z, \\Gamma, \\langle E \\rangle)$, with $n$ in $\\mathrm{cm}^{-3}$, $Z$ dimensionless (relative to solar), $\\Gamma$ in $\\mathrm{s}^{-1}$, and $\\langle E \\rangle$ in $\\mathrm{eV}$.\n1. $(10^{-5},\\ 0.0,\\ 10^{-12},\\ 2.0)$\n2. $(10^{-4},\\ 0.0,\\ 10^{-12},\\ 2.0)$\n3. $(10^{-5},\\ 0.1,\\ 10^{-12},\\ 2.0)$\n4. $(10^{-5},\\ 0.0,\\ 10^{-12},\\ 4.0)$\n5. $(10^{-7},\\ 0.0,\\ 10^{-13},\\ 2.0)$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[T_1,T_2,T_3,T_4,T_5]$), where each $T_i$ is the equilibrium temperature in $\\mathrm{K}$ for the $i$-th test case.", "solution": "The problem requires the derivation and numerical solution of the equilibrium temperature, $T_\\mathrm{eq}$, for a parcel of the Intergalactic Medium (IGM) under photoionization equilibrium (PIE). The solution must be derived from first principles as outlined in the problem statement.\n\nThe fundamental principle governing the thermal state of the gas is energy balance. In equilibrium, the total volumetric heating rate, $\\mathcal{H}$ (in units of $\\mathrm{erg}\\,\\mathrm{s}^{-1}\\,\\mathrm{cm}^{-3}$), must equal the total volumetric cooling rate, $\\mathcal{C}$ (in the same units).\n$$\n\\mathcal{H} = \\mathcal{C}\n$$\nThe problem provides expressions for these rates. The photoheating rate per unit volume is given by:\n$$\n\\mathcal{H} = n_\\mathrm{HI} \\Gamma \\langle E \\rangle\n$$\nwhere $n_\\mathrm{HI}$ is the number density of neutral hydrogen, $\\Gamma$ is the photoionization rate, and $\\langle E \\rangle$ is the mean excess energy deposited into the gas per photoionization.\n\nThe radiative cooling rate per unit volume is given by:\n$$\n\\mathcal{C} = n_e n_\\mathrm{H} \\Lambda(T,Z)\n$$\nwhere $n_e$ is the electron number density, $n_\\mathrm{H}$ is the total hydrogen number density (which we will denote as $n$), and $\\Lambda(T,Z)$ is the temperature- and metallicity-dependent cooling function.\n\nSetting the heating and cooling rates equal yields the thermal balance equation:\n$$\nn_\\mathrm{HI} \\Gamma \\langle E \\rangle = n_e n \\Lambda(T_\\mathrm{eq}, Z)\n$$\nThis equation contains multiple density terms ($n_\\mathrm{HI}$, $n_e$, $n$). To simplify it, we must invoke the second condition provided: photoionization equilibrium (PIE). PIE dictates that the rate of photoionizations equals the rate of recombinations. For a pure hydrogen gas, this is expressed as:\n$$\n\\Gamma n_\\mathrm{HI} = \\alpha_\\mathrm{A}(T) n_e n_p\n$$\nwhere $\\alpha_\\mathrm{A}(T)$ is the Case A recombination coefficient and $n_p$ is the proton number density.\n\nWe can now substitute the expression for $\\Gamma n_\\mathrm{HI}$ from the PIE equation into the thermal balance equation. This is a critical step that links the ionization state to the thermal state.\n$$\n\\left( \\alpha_\\mathrm{A}(T_\\mathrm{eq}) n_e n_p \\right) \\langle E \\rangle = n_e n \\Lambda(T_\\mathrm{eq}, Z)\n$$\nThe problem states that for the low-density, highly ionized IGM, we can make the approximation that the gas is almost fully ionized. This implies that the electron and proton densities are approximately equal to the total hydrogen density:\n$$\nn_e \\approx n_p \\approx n_\\mathrm{H} = n\n$$\nSubstituting these approximations into the equation gives:\n$$\n\\alpha_\\mathrm{A}(T_\\mathrm{eq}) (n) (n) \\langle E \\rangle = (n) (n) \\Lambda(T_\\mathrm{eq}, Z)\n$$\nThis simplifies to:\n$$\nn^2 \\alpha_\\mathrm{A}(T_\\mathrm{eq}) \\langle E \\rangle = n^2 \\Lambda(T_\\mathrm{eq}, Z)\n$$\nA crucial result emerges from this derivation. The factor of $n^2$ appears on both sides of the equation and can be canceled out, provided $n \\neq 0$.\n$$\n\\alpha_\\mathrm{A}(T_\\mathrm{eq}) \\langle E \\rangle = \\Lambda(T_\\mathrm{eq}, Z)\n$$\nThis final equation defines the equilibrium temperature $T_\\mathrm{eq}$. It is a scalar equation in a single variable, $T_\\mathrm{eq}$.\n\nAn important physical insight arises from this result: **under the specified conditions of PIE in an optically thin medium, the equilibrium temperature $T_\\mathrm{eq}$ is independent of the gas density $n$**. This occurs because both the dominant heating mechanism (photoheating) and the dominant cooling mechanism (which includes collisional excitation and recombination cooling, both two-body processes) scale with the square of the density ($n^2$), as their rates depend on the product of the densities of the interacting particles (e.g., $n_e n_p$). When balancing these two rates, the density dependence cancels out. The equilibrium temperature is thus determined solely by the balance between the energy input per recombination event (related to $\\langle E \\rangle$, the energy from the ionizing radiation field) and the energy radiated per unit of a \"cooling coefficient\" that also depends on recombinations and collisions, encapsulated in $\\Lambda(T,Z)/\\alpha_A(T)$.\n\nTo solve for $T_\\mathrm{eq}$ numerically, we define a function $f(T)$ whose root is the equilibrium temperature.\n$$\nf(T) = \\Lambda(T, Z) - \\alpha_\\mathrm{A}(T) \\langle E \\rangle = 0\n$$\nWe must substitute the given parameterizations for $\\Lambda(T, Z)$ and $\\alpha_\\mathrm{A}(T)$:\n$$\n\\Lambda(T,Z) = \\Lambda_{0}\\left(\\frac{T}{10^{4}\\,\\mathrm{K}}\\right)^{a} + Z\\, \\Lambda_{Z,0}\\left(\\frac{T}{10^{4}\\,\\mathrm{K}}\\right)^{b}\n$$\n$$\n\\alpha_\\mathrm{A}(T) = 4.2\\times10^{-13}\\left(\\frac{T}{10^{4}\\,\\mathrm{K}}\\right)^{-0.7}\\ \\mathrm{cm}^{3}\\,\\mathrm{s}^{-1}\n$$\nThe constants are given as $\\Lambda_{0} = 1.2\\times10^{-24}\\ \\mathrm{erg}\\,\\mathrm{cm}^{3}\\,\\mathrm{s}^{-1}$, $a = 0.3$, $\\Lambda_{Z,0} = 3.0\\times10^{-24}\\ \\mathrm{erg}\\,\\mathrm{cm}^{3}\\,\\mathrm{s}^{-1}$, and $b = -0.2$. Let's denote $T_0 = 10^4\\,\\mathrm{K}$ and $\\alpha_{A,0} = 4.2\\times10^{-13}\\,\\mathrm{cm}^{3}\\,\\mathrm{s}^{-1}$. The equation for the root-finding algorithm becomes:\n$$\nf(T) = \\left[ \\Lambda_{0} \\left(\\frac{T}{T_0}\\right)^{a} + Z \\Lambda_{Z,0} \\left(\\frac{T}{T_0}\\right)^{b} \\right] - \\left[ \\alpha_{A,0} \\left(\\frac{T}{T_0}\\right)^{-0.7} \\right] \\langle E \\rangle_{\\mathrm{erg}} = 0\n$$\nThe energy $\\langle E \\rangle$ is given in electron-volts ($\\mathrm{eV}$) and must be converted to ergs using the provided conversion factor $1\\,\\mathrm{eV} = 1.602176634\\times10^{-12}\\,\\mathrm{erg}$.\n\nFor each test case, the values of $Z$ and $\\langle E \\rangle$ are inserted into this equation, which is then solved numerically for $T = T_\\mathrm{eq}$ within the specified temperature interval $[3000\\,\\mathrm{K}, 30000\\,\\mathrm{K}]$. The parameters $n$ and $\\Gamma$ from the test suite, while essential for defining the physical scenario, do not enter the final algebraic equation for $T_\\mathrm{eq}$, reinforcing the conclusion that the equilibrium temperature is independent of density and the ionization rate under these assumptions.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import optimize\n\ndef solve():\n    \"\"\"\n    Solves for the equilibrium temperature of an IGM parcel for multiple test cases.\n    \"\"\"\n    \n    # Define physical and numerical constants from the problem statement.\n    Lambda_0 = 1.2e-24  # erg cm^3 s^-1\n    a = 0.3             # dimensionless power-law index\n    Lambda_Z0 = 3.0e-24 # erg cm^3 s^-1\n    b = -0.2            # dimensionless power-law index\n    alpha_A0 = 4.2e-13  # cm^3 s^-1\n    alpha_power = -0.7  # dimensionless power-law index for recombination\n    T0 = 1.0e4          # K, reference temperature\n    eV_to_erg = 1.602176634e-12 # erg/eV\n\n    # Define the search interval for the root finder.\n    T_min = 3000.0  # K\n    T_max = 30000.0 # K\n    \n    # Test cases parameters: (n_H [cm^-3], Z [solar], Gamma [s^-1], E_mean [eV])\n    # Note: n_H and Gamma are not used in the final equation for T_eq,\n    # as they cancel out under the assumption of photoionization equilibrium.\n    test_cases = [\n        (1e-5, 0.0, 1e-12, 2.0),\n        (1e-4, 0.0, 1e-12, 2.0),\n        (1e-5, 0.1, 1e-12, 2.0),\n        (1e-5, 0.0, 1e-12, 4.0),\n        (1e-7, 0.0, 1e-13, 2.0),\n    ]\n\n    def equilibrium_function(T, Z, E_erg):\n        \"\"\"\n        The scalar function f(T) = Lambda(T, Z) - alpha_A(T) * E whose root is T_eq.\n        \n        Args:\n            T (float): Temperature in Kelvin.\n            Z (float): Metallicity relative to solar.\n            E_erg (float): Mean excess energy per photoionization in ergs.\n            \n        Returns:\n            float: Value of the function f(T).\n        \"\"\"\n        T_norm = T / T0\n        \n        # Cooling function Lambda(T, Z)\n        lambda_val = Lambda_0 * (T_norm**a) + Z * Lambda_Z0 * (T_norm**b)\n        \n        # Recombination coefficient alpha_A(T)\n        alpha_val = alpha_A0 * (T_norm**alpha_power)\n        \n        heating_term = alpha_val * E_erg\n        \n        return lambda_val - heating_term\n\n    results = []\n    for case in test_cases:\n        _, Z, _, E_eV = case\n        \n        # Convert mean energy from eV to ergs for consistency.\n        E_erg = E_eV * eV_to_erg\n        \n        # Arguments to pass to the equilibrium function (Z and E_erg).\n        args = (Z, E_erg)\n\n        try:\n            # Use the Brent's method root finder on the interval [T_min, T_max].\n            # The problem allows extending T_max up to 100000 K if needed,\n            # but the standard interval works for these cases.\n            T_eq = optimize.brentq(equilibrium_function, T_min, T_max, args=args)\n            results.append(T_eq)\n        except ValueError:\n            # Handle cases where the root is not bracketed in the initial range.\n            # Try the extended range as per the problem description.\n            try:\n                T_eq = optimize.brentq(equilibrium_function, T_min, 100000.0, args=args)\n                results.append(T_eq)\n            except ValueError:\n                # If still failing, append a marker for an unresolved case.\n                results.append(np.nan)\n\n    # Format the results into the required string format.\n    # The map(str, ...) is used to handle floating point numbers correctly.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3491059"}, {"introduction": "Accurately modeling the photoheating rate, $\\mathcal{H}$, requires integrating the product of the radiation field's spectrum and the photoionization cross-section over all ionizing frequencies, a computationally demanding task. This practice explores a common subgrid simplification known as the \"grey\" approximation, where the complex spectrum is reduced to a single representative frequency. By analytically and numerically comparing the grey heating rate to the true multi-frequency rate for different spectral shapes, you will develop a critical understanding of the model's accuracy and the trade-offs between physical fidelity and computational cost [@problem_id:3491114].", "problem": "In an optically thin neutral hydrogen medium exposed to ionizing radiation, the net photoheating rate per hydrogen atom can be computed from first principles by counting photon absorption events and the excess energy deposited per event. Let the photon-number flux per unit frequency be denoted by $F_{\\nu}$ with units $\\mathrm{s^{-1}\\,m^{-2}\\,Hz^{-1}}$, and let the hydrogen photoionization cross section be $\\sigma_{\\mathrm{HI}}(\\nu)$. A widely used and well-tested approximation for neutral hydrogen is $\\sigma_{\\mathrm{HI}}(\\nu) = \\sigma_{0}\\,(\\nu/\\nu_{0})^{-3}$ for $\\nu \\ge \\nu_{0}$ and $\\sigma_{\\mathrm{HI}}(\\nu) = 0$ for $\\nu  \\nu_{0}$, where $\\nu_{0}$ is the threshold frequency corresponding to $13.6\\,\\mathrm{eV}$ and $\\sigma_{0} = 6.3\\times 10^{-22}\\,\\mathrm{m^{2}}$. The Planck constant is $h = 6.62607015\\times 10^{-34}\\,\\mathrm{J\\,s}$, and the electronvolt-to-joule conversion is $1\\,\\mathrm{eV} = 1.602176634\\times 10^{-19}\\,\\mathrm{J}$. The exact, multi-frequency net photoheating rate per hydrogen atom (in the International System of Units (SI), joules per second per atom) is given by\n$$\n\\mathcal{H}_{\\mathrm{true}} \\;=\\; \\int_{\\nu_{0}}^{\\infty} F_{\\nu}\\,\\sigma_{\\mathrm{HI}}(\\nu)\\,\\bigl(h\\nu - h\\nu_{0}\\bigr)\\,d\\nu.\n$$\nA commonly used single-group (\"grey\") subgrid model instead compresses the radiation field to a single representative frequency and cross-section. In this problem, define the grey model as follows: characterize the radiation field by its total photon number flux\n$$\n\\dot{N} \\;=\\; \\int_{\\nu_{0}}^{\\infty} F_{\\nu}\\,d\\nu,\n$$\nthe photon-number-weighted mean frequency\n$$\n\\bar{\\nu} \\;=\\; \\frac{1}{\\dot{N}}\\int_{\\nu_{0}}^{\\infty} \\nu\\,F_{\\nu}\\,d\\nu,\n$$\nand approximate the cross-section by its threshold value $\\sigma_{0}$. The resulting grey heating rate per hydrogen atom is\n$$\n\\mathcal{H}_{\\mathrm{grey}} \\;=\\; \\dot{N}\\,\\sigma_{0}\\,\\bigl(h\\bar{\\nu} - h\\nu_{0}\\bigr).\n$$\nYou will compare $\\mathcal{H}_{\\mathrm{grey}}$ to $\\mathcal{H}_{\\mathrm{true}}$ for two families of toy spectra that share the same total photon flux $\\dot{N}$ above threshold:\n- A monochromatic spectrum at photon energy $E_{\\mathrm{mono}}$ strictly above the threshold, which may be represented as $F_{\\nu} = \\dot{N}\\,\\delta(\\nu - \\nu_{\\mathrm{mono}})$, where $\\nu_{\\mathrm{mono}} = E_{\\mathrm{mono}}/h$.\n- A power-law spectrum $F_{\\nu} \\propto \\nu^{-\\alpha}$ between $\\nu_{0}$ and an upper cutoff $\\nu_{\\max}$, normalized to the same $\\dot{N}$.\n\nStarting only from the definitions above and the stated physical constants, implement a program that computes the dimensionless fractional difference\n$$\n\\delta \\;=\\; \\frac{\\mathcal{H}_{\\mathrm{grey}} - \\mathcal{H}_{\\mathrm{true}}}{\\mathcal{H}_{\\mathrm{true}}}\n$$\nfor the following test suite (all cases use the same total photon flux $\\dot{N} = 10^{10}\\,\\mathrm{s^{-1}\\,m^{-2}}$):\n- Case A (monochromatic): $E_{\\mathrm{mono}} = 20.0\\,\\mathrm{eV}$.\n- Case B (power law): $\\alpha = 1.5$, $E_{\\max} = 54.4\\,\\mathrm{eV}$.\n- Case C (power law): $\\alpha = 0.5$, $E_{\\max} = 136.0\\,\\mathrm{eV}$.\n- Case D (monochromatic): $E_{\\mathrm{mono}} = 13.7\\,\\mathrm{eV}$.\n\nAll intermediate physical quantities must be handled in International System of Units (SI). In particular, express heating rates in $\\mathrm{J\\,s^{-1}}$ per atom internally, but the final required outputs are the dimensionless fractional differences $\\delta$ for each case, in the order listed. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[x,y,z,w]$).", "solution": "The problem has been validated and is deemed scientifically sound, well-posed, complete, and formalizable. All provided constants and models are standard within the field of astrophysics and radiative transfer. The problem statement contains no contradictions or ambiguities. We may therefore proceed with a full solution.\n\nThe objective is to compute the dimensionless fractional difference $\\delta = (\\mathcal{H}_{\\mathrm{grey}} - \\mathcal{H}_{\\mathrm{true}}) / \\mathcal{H}_{\\mathrm{true}}$ between a simplified \"grey\" model of photoheating and the exact multifrequency calculation for two types of incident radiation spectra. We will first derive analytical expressions for $\\mathcal{H}_{\\mathrm{true}}$ and $\\mathcal{H}_{\\mathrm{grey}}$ for each spectral type. All calculations will be performed in SI units, as specified.\n\nLet's begin by defining the physical constants and the threshold ionization energy $E_{0}$ and frequency $\\nu_{0}$ for hydrogen:\n- Planck constant: $h = 6.62607015 \\times 10^{-34}\\,\\mathrm{J\\,s}$\n- Electronvolt-to-Joule conversion: $1\\,\\mathrm{eV} = 1.602176634 \\times 10^{-19}\\,\\mathrm{J}$\n- Threshold energy: $E_{0} = 13.6\\,\\mathrm{eV} = 13.6 \\times 1.602176634 \\times 10^{-19}\\,\\mathrm{J} \\approx 2.17895... \\times 10^{-18}\\,\\mathrm{J}$\n- Threshold frequency: $\\nu_{0} = E_{0}/h \\approx 3.28805... \\times 10^{15}\\,\\mathrm{Hz}$\n- Cross-section at threshold: $\\sigma_{0} = 6.3 \\times 10^{-22}\\,\\mathrm{m^2}$\n\nFor convenience, we will work with photon energy $E=h\\nu$ as the independent variable. The spectral photon-number flux per unit energy, $F_E$, is related to the flux per unit frequency, $F_\\nu$, by $F_E(E) dE = F_\\nu(\\nu) d\\nu$. Since $dE = h\\,d\\nu$, we have $F_E(E) = F_\\nu(\\nu)/h$. The photoionization cross-section as a function of energy is $\\sigma_{\\mathrm{HI}}(E) = \\sigma_{0}(E/E_{0})^{-3}$ for $E \\ge E_{0}$.\n\nThe true heating rate per atom is:\n$$\n\\mathcal{H}_{\\mathrm{true}} = \\int_{E_{0}}^{\\infty} F_E(E)\\,\\sigma_{\\mathrm{HI}}(E)\\,(E - E_{0})\\,dE = \\sigma_{0} \\int_{E_{0}}^{\\infty} F_E(E)\\,(E/E_{0})^{-3}\\,(E - E_{0})\\,dE\n$$\nThe grey heating rate is defined as $\\mathcal{H}_{\\mathrm{grey}} = \\dot{N}\\,\\sigma_{0}\\,(h\\bar{\\nu} - h\\nu_{0}) = \\dot{N}\\,\\sigma_{0}\\,(\\bar{E} - E_{0})$, where $\\dot{N} = \\int_{E_{0}}^{\\infty} F_E(E)\\,dE$ is the total photon number flux and $\\bar{E} = \\frac{1}{\\dot{N}}\\int_{E_{0}}^{\\infty} E\\,F_E(E)\\,dE$ is the mean photon energy.\nA crucial insight is that the expression for the grey heating rate can be rewritten as:\n$$\n\\mathcal{H}_{\\mathrm{grey}} = \\left(\\int_{E_{0}}^{\\infty} F_E(E)\\,dE\\right)\\,\\sigma_{0}\\,\\left(\\frac{\\int_{E_{0}}^{\\infty} E\\,F_E(E)\\,dE}{\\int_{E_{0}}^{\\infty} F_E(E)\\,dE} - E_{0}\\right)\n= \\sigma_{0} \\left( \\int_{E_{0}}^{\\infty} E\\,F_E(E)\\,dE - E_{0} \\int_{E_{0}}^{\\infty} F_E(E)\\,dE \\right)\n$$\n$$\n\\mathcal{H}_{\\mathrm{grey}} = \\sigma_{0} \\int_{E_{0}}^{\\infty} F_E(E)\\,(E - E_{0})\\,dE\n$$\nThis reformulation elegantly clarifies the physical difference between the two models: $\\mathcal{H}_{\\mathrm{true}}$ includes the energy-dependent cross-section factor $(E/E_{0})^{-3}$ inside the integral, whereas $\\mathcal{H}_{\\mathrm{grey}}$ effectively approximates this factor as unity. Since $(E/E_{0})^{-3} \\le 1$ for all relevant energies $E \\ge E_{0}$, we can immediately deduce that $\\mathcal{H}_{\\mathrm{true}} \\le \\mathcal{H}_{\\mathrm{grey}}$, which implies $\\delta \\ge 0$.\n\nLet's now analyze each spectral type.\n\n**1. Monochromatic Spectrum**\nThe spectrum is given by $F_{\\nu} = \\dot{N}\\,\\delta(\\nu - \\nu_{\\mathrm{mono}})$, where $\\delta(\\cdot)$ is the Dirac delta function. In terms of energy, this is $F_E(E) = \\dot{N}\\,\\delta(E - E_{\\mathrm{mono}})$, with $E_{\\mathrm{mono}}  E_{0}$.\nUsing the sifting property of the delta function, $\\int g(x)\\delta(x-a)dx = g(a)$:\n\n$$\n\\mathcal{H}_{\\mathrm{true}} = \\sigma_{0} \\int_{E_{0}}^{\\infty} \\dot{N}\\,\\delta(E - E_{\\mathrm{mono}})\\,(E/E_{0})^{-3}\\,(E - E_{0})\\,dE = \\dot{N}\\,\\sigma_{0}\\,(E_{\\mathrm{mono}}/E_{0})^{-3}\\,(E_{\\mathrm{mono}} - E_{0})\n$$\n$$\n\\mathcal{H}_{\\mathrm{grey}} = \\sigma_{0} \\int_{E_{0}}^{\\infty} \\dot{N}\\,\\delta(E - E_{\\mathrm{mono}})\\,(E - E_{0})\\,dE = \\dot{N}\\,\\sigma_{0}\\,(E_{\\mathrm{mono}} - E_{0})\n$$\nThe fractional difference is:\n$$\n\\delta = \\frac{\\mathcal{H}_{\\mathrm{grey}} - \\mathcal{H}_{\\mathrm{true}}}{\\mathcal{H}_{\\mathrm{true}}} = \\frac{\\mathcal{H}_{\\mathrm{grey}}}{\\mathcal{H}_{\\mathrm{true}}} - 1 = \\frac{\\dot{N}\\,\\sigma_{0}\\,(E_{\\mathrm{mono}} - E_{0})}{\\dot{N}\\,\\sigma_{0}\\,(E_{\\mathrm{mono}}/E_{0})^{-3}\\,(E_{\\mathrm{mono}} - E_{0})} - 1 = \\frac{1}{(E_{\\mathrm{mono}}/E_{0})^{-3}} - 1\n$$\n$$\n\\delta = \\left(\\frac{E_{\\mathrm{mono}}}{E_{0}}\\right)^{3} - 1\n$$\nNotice that the result is independent of $\\dot{N}$ and $\\sigma_{0}$.\n\n**2. Power-Law Spectrum**\nThe spectrum is $F_{\\nu} \\propto \\nu^{-\\alpha}$ for $\\nu_0 \\le \\nu \\le \\nu_{\\max}$, which corresponds to $F_E(E) \\propto E^{-\\alpha}$ for $E_0 \\le E \\le E_{\\max}$. Let $F_E(E) = K E^{-\\alpha}$.\nThe constant $K$ is determined by normalization to the total photon flux $\\dot{N}$, but as we found, both $\\mathcal{H}_{\\mathrm{true}}$ and $\\mathcal{H}_{\\mathrm{grey}}$ are proportional to this normalization. Therefore, the constant will cancel out of the ratio $\\delta$.\nLet us introduce the dimensionless energy $x = E/E_{0}$, with the cutoff at $x_{\\max} = E_{\\max}/E_{0}$. Then $dE = E_{0}\\,dx$.\n\n$$\n\\mathcal{H}_{\\mathrm{true}} = \\sigma_{0} \\int_{E_{0}}^{E_{\\max}} K E^{-\\alpha}\\, (E/E_{0})^{-3}\\, (E - E_{0})\\,dE = K \\sigma_{0} E_{0}^{1-\\alpha} \\int_{1}^{x_{\\max}} x^{-\\alpha}\\,x^{-3}\\,(E_{0}x - E_{0})\\,dx\n$$\n$$\n\\mathcal{H}_{\\mathrm{true}} \\propto \\int_{1}^{x_{\\max}} (x-1)x^{-\\alpha-3}\\,dx = \\int_{1}^{x_{\\max}} (x^{-\\alpha-2} - x^{-\\alpha-3})\\,dx\n$$\n\n$$\n\\mathcal{H}_{\\mathrm{grey}} = \\sigma_{0} \\int_{E_{0}}^{E_{\\max}} K E^{-\\alpha}\\,(E-E_{0})\\,dE = K \\sigma_{0} E_{0}^{1-\\alpha} \\int_{1}^{x_{\\max}} x^{-\\alpha}\\,(E_{0}x - E_{0})\\,dx\n$$\n$$\n\\mathcal{H}_{\\mathrm{grey}} \\propto \\int_{1}^{x_{\\max}} (x-1)x^{-\\alpha}\\,dx = \\int_{1}^{x_{\\max}} (x^{1-\\alpha} - x^{-\\alpha})\\,dx\n$$\nThe fractional difference is the ratio of these two definite integrals minus one:\n$$\n\\delta = \\frac{\\int_{1}^{x_{\\max}} (x^{1-\\alpha} - x^{-\\alpha})\\,dx}{\\int_{1}^{x_{\\max}} (x^{-\\alpha-2} - x^{-\\alpha-3})\\,dx} - 1\n$$\nThese integrals are readily solvable for $\\alpha \\neq 1, 2$ and $\\alpha \\neq -1, -2$, which holds for the given cases ($\\alpha=1.5, 0.5$).\nLet's evaluate the numerator integral, $I_{\\mathrm{grey}}$:\n$$\nI_{\\mathrm{grey}}(x_{\\max}, \\alpha) = \\left[\\frac{x^{2-\\alpha}}{2-\\alpha} - \\frac{x^{1-\\alpha}}{1-\\alpha}\\right]_{1}^{x_{\\max}} = \\left(\\frac{x_{\\max}^{2-\\alpha}-1}{2-\\alpha}\\right) - \\left(\\frac{x_{\\max}^{1-\\alpha}-1}{1-\\alpha}\\right)\n$$\nAnd the denominator integral, $I_{\\mathrm{true}}$:\n$$\nI_{\\mathrm{true}}(x_{\\max}, \\alpha) = \\left[\\frac{x^{-\\alpha-1}}{-\\alpha-1} - \\frac{x^{-\\alpha-2}}{-\\alpha-2}\\right]_{1}^{x_{\\max}} = \\left(\\frac{1-x_{\\max}^{-\\alpha-1}}{\\alpha+1}\\right) - \\left(\\frac{1-x_{\\max}^{-\\alpha-2}}{\\alpha+2}\\right)\n$$\nThe final formula for the power-law cases is $\\delta = I_{\\mathrm{grey}}/I_{\\mathrm{true}} - 1$.\n\nThe program below implements these derived analytical formulas to calculate $\\delta$ for each of the four test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the fractional difference between grey and true photoheating rates\n    for a suite of test cases.\n    \"\"\"\n    # Define physical constants in SI units\n    h_planck = 6.62607015e-34  # J s\n    eV_to_J = 1.602176634e-19  # J/eV\n    sigma0_HI = 6.3e-22        # m^2\n\n    # Ionization threshold for Hydrogen\n    E0_eV = 13.6\n    E0_J = E0_eV * eV_to_J\n\n    # Define the test cases from the problem statement\n    # Format: (case_type, params_dict)\n    # Monochromatic case: {'E_mono_eV': float}\n    # Power-law case: {'alpha': float, 'E_max_eV': float}\n    test_cases = [\n        ('monochromatic', {'E_mono_eV': 20.0}),        # Case A\n        ('power_law',     {'alpha': 1.5, 'E_max_eV': 54.4}),   # Case B\n        ('power_law',     {'alpha': 0.5, 'E_max_eV': 136.0}),  # Case C\n        ('monochromatic', {'E_mono_eV': 13.7}),        # Case D\n    ]\n\n    results = []\n    for case_type, params in test_cases:\n        if case_type == 'monochromatic':\n            E_mono_eV = params['E_mono_eV']\n            \n            # The fractional difference delta is given by (E_mono/E_0)^3 - 1.\n            # We can use energies in eV as it is a dimensionless ratio.\n            x_mono = E_mono_eV / E0_eV\n            \n            # Since E_mono  E_0, (E_mono - E_0) is non-zero and cancels.\n            delta = x_mono**3 - 1.0\n            \n            results.append(delta)\n\n        elif case_type == 'power_law':\n            alpha = params['alpha']\n            E_max_eV = params['E_max_eV']\n            \n            # The calculation is based on the ratio of two definite integrals\n            # involving the dimensionless energy x = E/E_0.\n            x_max = E_max_eV / E0_eV\n            \n            # Numerator integral for H_grey: integral[(x^(1-alpha) - x^(-alpha))]dx from 1 to x_max\n            # This is valid for alpha != 1, 2\n            term1_grey = (x_max**(2.0 - alpha) - 1.0) / (2.0 - alpha)\n            term2_grey = (x_max**(1.0 - alpha) - 1.0) / (1.0 - alpha)\n            integral_grey = term1_grey - term2_grey\n            \n            # Denominator integral for H_true: integral[(x^(-alpha-2) - x^(-alpha-3))]dx from 1 to x_max\n            # This is valid for alpha != -1, -2\n            term1_true = (1.0 - x_max**(-alpha - 1.0)) / (alpha + 1.0)\n            term2_true = (1.0 - x_max**(-alpha - 2.0)) / (alpha + 2.0)\n            integral_true = term1_true - term2_true\n            \n            # delta = (H_grey / H_true) - 1\n            if integral_true == 0:\n                # This would happen only in a trivial case where E_max = E_0,\n                # which is not the case here.\n                delta = np.inf if integral_grey  0 else 0\n            else:\n                delta = integral_grey / integral_true - 1.0\n\n            results.append(delta)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3491114"}, {"introduction": "The radiative cooling function, $\\Lambda(T, Z)$, is a complex function of temperature and metallicity whose direct calculation within a large-scale simulation is computationally prohibitive. Therefore, subgrid models almost universally rely on pre-computed tables of $\\Lambda$ and interpolate from them. This exercise tackles the practical numerical challenge of how to perform this interpolation accurately, comparing standard bilinear interpolation with a more physically motivated log-linear approach [@problem_id:3491056]. Mastering this technique is a vital skill for implementing robust and accurate cooling physics in any astrophysical simulation code.", "problem": "Consider a two-dimensional tabulated cooling function relevant to subgrid models for radiative cooling and heating in numerical cosmology. Let $T$ denote temperature in Kelvin and $Z$ denote a dimensionless metallicity (relative to solar metallicity). Define the base-$10$ logarithmic coordinates $u = \\log_{10} T$ and $v = \\log_{10} Z$. You are given a smooth analytic test function for the radiative cooling coefficient, $\\Lambda(T,Z)$, constructed to be strictly positive and to exhibit structured variation across the domain:\n$$\n\\Lambda(T,Z) = 10^{-27}\\,T^{1/2} \\;+\\; 2\\times 10^{-23}\\, Z \\,\\exp\\!\\left(-\\frac{(\\log_{10} T - 5.5)^2}{0.4^2}\\right) \\;+\\; 10^{-24}\\, Z^{1/2}\\,\\exp\\!\\left(-\\frac{(\\log_{10} T - 6.7)^2}{0.6^2}\\right).\n$$\nThe computational domain is specified by $T \\in [10^4, 10^8]$ (in Kelvin) and $Z \\in [10^{-3}, 2]$ (dimensionless). Consequently, $u \\in [4, 8]$ and $v \\in [\\log_{10}(10^{-3}), \\log_{10}(2)] = [-3, \\log_{10} 2]$.\n\nYou must compare two interpolation schemes defined on a rectilinear grid in the $(u,v)$-plane:\n\n- Scheme A (bilinear in $(u,v)$ on $\\Lambda$): Given a grid of nodes $(u_i, v_j)$, compute $\\Lambda_{ij} = \\Lambda(10^{u_i}, 10^{v_j})$ and use standard bilinear interpolation in $(u,v)$ directly on $\\Lambda$ to approximate $\\Lambda$ at query points $(u^*, v^*)$.\n- Scheme B (log-linear in $(u,v)$ on $\\log_{10}\\Lambda$): Using the same grid of nodes $(u_i, v_j)$, compute $L_{ij} = \\log_{10}\\Lambda(10^{u_i}, 10^{v_j})$ and use standard bilinear interpolation in $(u,v)$ on $L$ to approximate $L(u^*, v^*)$. The approximation to $\\Lambda$ at $(u^*, v^*)$ is then $\\hat{\\Lambda}(u^*, v^*) = 10^{\\,\\widehat{L}(u^*, v^*)}$.\n\nFor each scheme, define the relative error at a query point $(u^*, v^*)$ by\n$$\n\\varepsilon(u^*, v^*) \\;=\\; \\frac{\\left|\\hat{\\Lambda}(u^*, v^*) \\;-\\; \\Lambda\\big(10^{u^*}, 10^{v^*}\\big)\\right|}{\\Lambda\\big(10^{u^*}, 10^{v^*}\\big)}.\n$$\nThe objective is to compute the maximum relative error over a specified dense query mesh $\\mathcal{Q}$, uniformly covering $[4,8]\\times[-3,\\log_{10}2]$ in $(u,v)$, with $256$ evenly spaced points in $u$ and $256$ evenly spaced points in $v$.\n\nFundamental base you must use:\n- The definition of base-$10$ logarithms $u = \\log_{10} T$ and $v = \\log_{10} Z$.\n- The definition of bilinear interpolation on a rectangular grid.\n- The definition of relative error as a dimensionless ratio.\n- The function $\\Lambda(T,Z)$ provided above and the domain constraints.\n\nYour task is to implement a program that, for each specified grid resolution, constructs a uniform grid in $(u,v)$, populates it with exact values from $\\Lambda$, performs Scheme A and Scheme B interpolation over the dense query mesh, and reports the maximum relative error for each scheme.\n\nTest suite:\n- Case $1$: $(N_T, N_Z) = (16, 16)$, where $N_T$ and $N_Z$ denote the number of grid nodes along $u$ and $v$, respectively.\n- Case $2$: $(N_T, N_Z) = (8, 8)$.\n- Case $3$: $(N_T, N_Z) = (64, 8)$.\n- Case $4$: $(N_T, N_Z) = (32, 64)$.\n\nFor each case, the grid nodes $(u_i)$ are uniformly spaced over $[4,8]$ with $N_T$ points, and $(v_j)$ are uniformly spaced over $[-3, \\log_{10} 2]$ with $N_Z$ points. The query mesh $\\mathcal{Q}$ is fixed to $256 \\times 256$ points uniformly spanning the same $(u,v)$ domain.\n\nOutput specification:\n- The final output must be dimensionless maximum relative errors for each case and each scheme, aggregated into a single line in the form of a list of lists: for each case, the pair $[\\varepsilon_{\\max}^{\\text{A}}, \\varepsilon_{\\max}^{\\text{B}}]$, where $\\varepsilon_{\\max}^{\\text{A}}$ and $\\varepsilon_{\\max}^{\\text{B}}$ are the maximum relative errors for Scheme A and Scheme B, respectively, computed over $\\mathcal{Q}$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example: $[[e_{11},e_{12}],[e_{21},e_{22}],\\dots]$, where each $e_{ij}$ is a floating-point number.\n\nAll reported quantities are dimensionless; no physical units must appear in the output. Angles are not involved. Percentages must not be used; report ratios as decimal numbers. Your program must be fully self-contained, take no input, and print only the single required line.", "solution": "The problem RCM-1 is a valid, well-posed numerical analysis task. No flaws were detected.\n\nThe objective is to compare a bilinear interpolation scheme and a log-linear interpolation scheme for a given two-dimensional cosmological cooling function, $\\Lambda(T,Z)$, where $T$ is temperature and $Z$ is metallicity. The comparison is based on the maximum relative error of each scheme over a dense query mesh. The interpolation is performed in a logarithmic coordinate system $(u, v)$, where $u = \\log_{10} T$ and $v = \\log_{10} Z$.\n\nThe cooling function is given by:\n$$\n\\Lambda(T,Z) = 10^{-27}\\,T^{1/2} \\;+\\; 2\\times 10^{-23}\\, Z \\,\\exp\\!\\left(-\\frac{(\\log_{10} T - 5.5)^2}{0.4^2}\\right) \\;+\\; 10^{-24}\\, Z^{1/2}\\,\\exp\\!\\left(-\\frac{(\\log_{10} T - 6.7)^2}{0.6^2}\\right)\n$$\nFor computational purposes, we express this function in terms of the logarithmic coordinates $u$ and $v$ by substituting $T = 10^u$ and $Z = 10^v$:\n$$\n\\Lambda(10^u, 10^v) = 10^{-27} \\cdot 10^{0.5u} + 2 \\times 10^{-23} \\cdot 10^v \\cdot \\exp\\left(-\\frac{(u - 5.5)^2}{0.16}\\right) + 10^{-24} \\cdot 10^{0.5v} \\cdot \\exp\\left(-\\frac{(u - 6.7)^2}{0.36}\\right)\n$$\nThis function is evaluated over the domain $u \\in [4, 8]$ and $v \\in [-3, \\log_{10} 2]$.\n\nThe numerical procedure for each test case, specified by a grid resolution $(N_T, N_Z)$, is as follows:\n\nFirst, we define the computational grids:\n1.  A tabulation grid, on which the function is sampled to build the interpolator. The grid points are uniformly spaced arrays $u_i$ of size $N_T$ over $[4, 8]$ and $v_j$ of size $N_Z$ over $[-3, \\log_{10} 2]$.\n2.  A dense query mesh $\\mathcal{Q}$, fixed at a resolution of $256 \\times 256$ points, uniformly covering the same $(u,v)$ domain. This mesh is used to evaluate the accuracy of the interpolation.\n\nNext, we compute the exact values of the cooling function, $\\Lambda_{\\text{true}} = \\Lambda(10^u, 10^v)$, on every point of the $256 \\times 256$ query mesh. These values serve as the ground truth for calculating the relative error.\n\nFor each interpolation scheme, we then perform the following steps:\n\n**Scheme A: Bilinear Interpolation on $\\Lambda$**\n1.  The cooling function $\\Lambda(u, v)$ is evaluated at each node $(u_i,v_j)$ of the $(N_T, N_Z)$ tabulation grid, creating a data table $\\Lambda_{ij}$.\n2.  A bivariate linear interpolator, $\\hat{\\Lambda}_A(u, v)$, is constructed from the grid points $(u_i, v_j)$ and the corresponding values $\\Lambda_{ij}$. This is a standard bilinear interpolation.\n3.  The interpolator $\\hat{\\Lambda}_A(u, v)$ is evaluated at every point on the dense query mesh to obtain the interpolated values, $\\hat{\\Lambda}_A^{\\text{query}}$.\n4.  The relative error $\\varepsilon_A$ is computed at each point of the query mesh using the formula $\\varepsilon = |\\hat{\\Lambda} - \\Lambda_{\\text{true}}| / \\Lambda_{\\text{true}}$.\n5.  The maximum value of this error over the entire query mesh, $\\varepsilon_{\\max}^{\\text{A}}$, is recorded.\n\n**Scheme B: Log-Linear Interpolation (Bilinear on $\\log_{10}\\Lambda$)**\n1.  The base-$10$ logarithm of the cooling function, $L(u, v) = \\log_{10}(\\Lambda(u, v))$, is evaluated at each node $(u_i,v_j)$ of the tabulation grid, creating a data table $L_{ij}$. The function $\\Lambda$ is strictly positive over its domain, so its logarithm is always well-defined.\n2.  A bivariate linear interpolator, $\\hat{L}(u, v)$, is constructed from the grid points $(u_i, v_j)$ and the corresponding logarithmic values $L_{ij}$.\n3.  The interpolator $\\hat{L}(u, v)$ is evaluated at every point on the dense query mesh to obtain the interpolated logarithmic values, $\\hat{L}^{\\text{query}}$.\n4.  The interpolated cooling function values are recovered by the inverse-logarithm transformation: $\\hat{\\Lambda}_B^{\\text{query}} = 10^{\\hat{L}^{\\text{query}}}$.\n5.  The relative error $\\varepsilon_B$ is computed similarly: $\\varepsilon_B = |\\hat{\\Lambda}_B^{\\text{query}} - \\Lambda_{\\text{true}}| / \\Lambda_{\\text{true}}$.\n6.  The maximum value of this error over the query mesh, $\\varepsilon_{\\max}^{\\text{B}}$, is recorded.\n\nThis process is repeated for each of the four specified $(N_T, N_Z)$ test cases. The final result is an aggregation of the pairs $[\\varepsilon_{\\max}^{\\text{A}}, \\varepsilon_{\\max}^{\\text{B}}]$ for each case. The implementation utilizes `numpy` for array-based computations and `scipy.interpolate.RegularGridInterpolator` to perform the bilinear interpolations efficiently.", "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import RegularGridInterpolator\n\ndef solve():\n    \"\"\"\n    Computes and compares the maximum relative errors for two interpolation schemes\n    on a cosmological cooling function.\n    \"\"\"\n\n    # Test suite: grid resolutions (N_T, N_Z)\n    test_cases = [\n        (16, 16),\n        (8, 8),\n        (64, 8),\n        (32, 64)\n    ]\n\n    # Define the computational domain in logarithmic coordinates (u, v)\n    u_min, u_max = 4.0, 8.0\n    v_min, v_max = -3.0, np.log10(2.0)\n\n    # Define the dense query mesh resolution\n    N_query = 256\n\n    def lambda_uv(u, v):\n        \"\"\"\n        Computes the cooling function Lambda in terms of log-coordinates u and v.\n        u = log10(T), v = log10(Z)\n        T = 10**u, Z = 10**v\n        \"\"\"\n        # Ensure input are numpy arrays for vectorization\n        u = np.asarray(u)\n        v = np.asarray(v)\n\n        # Term 1: Proportional to T^(1/2)\n        term1 = 1e-27 * 10**(0.5 * u)\n        \n        # Term 2: Gaussian peak in T at log10(T)=5.5, linear in Z\n        term2 = 2e-23 * 10**v * np.exp(-(u - 5.5)**2 / (0.4**2))\n        \n        # Term 3: Gaussian peak in T at log10(T)=6.7, proportional to Z^(1/2)\n        term3 = 1e-24 * 10**(0.5 * v) * np.exp(-(u - 6.7)**2 / (0.6**2))\n        \n        return term1 + term2 + term3\n\n    # Create the dense query mesh\n    u_query_pts = np.linspace(u_min, u_max, N_query)\n    v_query_pts = np.linspace(v_min, v_max, N_query)\n    U_query, V_query = np.meshgrid(u_query_pts, v_query_pts, indexing='ij')\n\n    # Calculate exact values of Lambda on the query mesh (ground truth)\n    lambda_true = lambda_uv(U_query, V_query)\n\n    # Prepare query points for the interpolator\n    query_points = np.stack((U_query.ravel(), V_query.ravel()), axis=-1)\n\n    all_results = []\n\n    for N_T, N_Z in test_cases:\n        # 1. Define the tabulation grid\n        u_grid = np.linspace(u_min, u_max, N_T)\n        v_grid = np.linspace(v_min, v_max, N_Z)\n\n        # 2. Scheme A: Bilinear interpolation on Lambda\n        U_grid, V_grid = np.meshgrid(u_grid, v_grid, indexing='ij')\n        lambda_table = lambda_uv(U_grid, V_grid)\n        \n        # Create and apply the interpolator for Scheme A\n        interpolator_A = RegularGridInterpolator((u_grid, v_grid), lambda_table, method='linear', bounds_error=False, fill_value=None)\n        lambda_hat_A = interpolator_A(query_points).reshape(N_query, N_query)\n        \n        # Calculate maximum relative error for Scheme A\n        error_A = np.abs(lambda_hat_A - lambda_true) / lambda_true\n        max_error_A = np.max(error_A)\n\n        # 3. Scheme B: Bilinear interpolation on log10(Lambda)\n        L_table = np.log10(lambda_table)\n        \n        # Create and apply the interpolator for Scheme B\n        interpolator_B = RegularGridInterpolator((u_grid, v_grid), L_table, method='linear', bounds_error=False, fill_value=None)\n        L_hat = interpolator_B(query_points).reshape(N_query, N_query)\n        \n        # Convert back from log-space\n        lambda_hat_B = 10**L_hat\n        \n        # Calculate maximum relative error for Scheme B\n        error_B = np.abs(lambda_hat_B - lambda_true) / lambda_true\n        max_error_B = np.max(error_B)\n\n        all_results.append([max_error_A, max_error_B])\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3491056"}]}