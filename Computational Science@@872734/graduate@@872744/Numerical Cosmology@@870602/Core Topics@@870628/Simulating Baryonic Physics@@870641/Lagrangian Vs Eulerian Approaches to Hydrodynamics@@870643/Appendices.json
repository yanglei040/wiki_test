{"hands_on_practices": [{"introduction": "A crucial first step in building a cosmological simulation is to correctly formulate the equations of motion in an expanding universe. This exercise begins with the analytical derivation of the comoving Euler equations, revealing the emergence of the $-H\\mathbf{v}$ \"Hubble drag\" term that anmps peculiar velocities. By then numerically solving the resulting ordinary differential equation, you will directly compare the accuracy and stability of simple time-integration schemes representative of the Eulerian (explicit, point-in-time) and Lagrangian (implicit, time-centered) philosophies [@problem_id:3477164]. This practice solidifies the foundational physics of cosmological hydrodynamics and illuminates how the choice of time-stepping can impact the fidelity of simulating even the simplest cosmic effects.", "problem": "Consider a Newtonian, non-relativistic, compressible fluid in an expanding, spatially flat universe. Let the physical (proper) coordinate be $\\mathbf{r}$, the comoving coordinate be $\\mathbf{x}$, and the cosmic scale factor be $a(t)$. The mapping between the coordinates is $\\mathbf{r}(t) = a(t)\\,\\mathbf{x}(t)$. Define the physical velocity $\\mathbf{u}(t,\\mathbf{r}) \\equiv d\\mathbf{r}/dt$ and the peculiar velocity $\\mathbf{v}(t,\\mathbf{x}) \\equiv a(t)\\,d\\mathbf{x}/dt$ so that $\\mathbf{u} = H(t)\\,\\mathbf{r} + \\mathbf{v}$ with $H(t) \\equiv \\dot{a}/a$ the Hubble parameter. Starting from conservation of mass and momentum and Newton’s second law for a fluid, derive the comoving form of the Euler equations and explicitly identify the source term proportional to $-H(t)\\,\\mathbf{v}$ (the “Hubble drag” term) in the momentum equation. State all assumptions made and define all variables clearly. You must start from the physical Euler equations and map to comoving variables by applying the chain rule and the definition of peculiar quantities; do not assume the target comoving equations.\n\nAfter completing the derivation, consider the uniform-flow and source-free limit in which spatial derivatives, pressure gradients, and peculiar gravitational forces vanish so that the peculiar velocity obeys a pure ordinary differential equation (ODE) due to Hubble drag:\n$$\n\\frac{d\\mathbf{v}}{dt} = -H(t)\\,\\mathbf{v}.\n$$\nYour task is to implement two time-discretization strategies that differ in spirit between Eulerian and Lagrangian approaches and to quantify the discretization bias of the $-H(t)\\,\\mathbf{v}$ term:\n\n- Eulerian update (grid-based viewpoint): advance the ODE with a first-order forward Euler step evaluated at the start of each step.\n- Lagrangian update (particle-following viewpoint): advance the ODE with a second-order time-centered trapezoidal step that uses $H(t)$ sampled at both the beginning and the end of the step.\n\nFor each strategy, compute the numerical solution for $\\mathbf{v}(t)$ over a finite time interval and compare it with the exact analytical solution for the given $H(t)$. Define the discretization bias for a scalar velocity amplitude $v$ at final time $t_{\\mathrm{f}}$ as the relative error\n$$\n\\epsilon \\equiv \\frac{v_{\\mathrm{num}}(t_{\\mathrm{f}}) - v_{\\mathrm{exact}}(t_{\\mathrm{f}})}{v_{\\mathrm{exact}}(t_{\\mathrm{f}})},\n$$\nexpressed as a decimal (not a percentage). Use the same initial condition $v(t_0) = v_0$ for both strategies.\n\nUnits and numerical specifications:\n- All times must be in seconds ($\\mathrm{s}$), velocities in meters per second ($\\mathrm{m/s}$), and the Hubble parameter in inverse seconds ($\\mathrm{s}^{-1}$).\n- Treat $v$ as a scalar amplitude for simplicity, and report scalar biases for each test.\n\nImplement a single program that computes the Eulerian and Lagrangian discretization biases for the following test suite. For each case, assume a single spatially uniform fluid element and focus solely on the ODE above:\n\n- Case $1$ (constant Hubble parameter, moderate step): $H(t) = H_0$ with $H_0 = 2.27\\times 10^{-18}\\,\\mathrm{s}^{-1}$, $t_0 = 0\\,\\mathrm{s}$, $v_0 = 3.0\\times 10^{5}\\,\\mathrm{m/s}$, $\\Delta t = 5.0\\times 10^{16}\\,\\mathrm{s}$, $N = 10$ steps. The exact solution is $v_{\\mathrm{exact}}(t_{\\mathrm{f}}) = v_0\\exp\\!\\left(-H_0\\,N\\,\\Delta t\\right)$.\n- Case $2$ (matter-dominated expansion): $H(t) = \\frac{2}{3\\,t}$, $t_0 = 1.0\\times 10^{16}\\,\\mathrm{s}$, $v_0 = 3.0\\times 10^{5}\\,\\mathrm{m/s}$, $\\Delta t = 5.0\\times 10^{15}\\,\\mathrm{s}$, $N = 8$ steps. The exact solution is $v_{\\mathrm{exact}}(t_{\\mathrm{f}}) = v_0\\left(\\frac{t_0}{t_0 + N\\,\\Delta t}\\right)^{2/3}$.\n- Case $3$ (constant Hubble parameter, small step boundary): $H(t) = H_0$ with $H_0 = 2.27\\times 10^{-18}\\,\\mathrm{s}^{-1}$, $t_0 = 0\\,\\mathrm{s}$, $v_0 = 3.0\\times 10^{5}\\,\\mathrm{m/s}$, $\\Delta t = 1.0\\times 10^{15}\\,\\mathrm{s}$, $N = 10$ steps. The exact solution is $v_{\\mathrm{exact}}(t_{\\mathrm{f}}) = v_0\\exp\\!\\left(-H_0\\,N\\,\\Delta t\\right)$.\n- Case $4$ (constant Hubble parameter, extreme coarse step): $H(t) = H_0$ with $H_0 = 2.27\\times 10^{-18}\\,\\mathrm{s}^{-1}$, $t_0 = 0\\,\\mathrm{s}$, $v_0 = 3.0\\times 10^{5}\\,\\mathrm{m/s}$, $\\Delta t = 5.0\\times 10^{18}\\,\\mathrm{s}$, $N = 1$ step. The exact solution is $v_{\\mathrm{exact}}(t_{\\mathrm{f}}) = v_0\\exp\\!\\left(-H_0\\,N\\,\\Delta t\\right)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each entry must be a two-element list with the Eulerian bias followed by the Lagrangian bias for the corresponding case, in the order given. For example, the output format must be\n`[[\\epsilon_{\\mathrm{E},1},\\epsilon_{\\mathrm{L},1}],[\\epsilon_{\\mathrm{E},2},\\epsilon_{\\mathrm{L},2}],[\\epsilon_{\\mathrm{E},3},\\epsilon_{\\mathrm{L},3}],[\\epsilon_{\\mathrm{E},4},\\epsilon_{\\mathrm{L},4}]]`.", "solution": "The problem is first to derive the comoving form of the Euler equations for a Newtonian fluid in an expanding universe, and second, to implement and compare two numerical schemes for solving a simplified version of the peculiar velocity evolution.\n\nThe problem statement will be validated first.\n\n**Step 1: Extract Givens**\n-   Coordinate mapping: $\\mathbf{r}(t) = a(t)\\,\\mathbf{x}(t)$, where $\\mathbf{r}$ is the physical coordinate, $\\mathbf{x}$ is the comoving coordinate, and $a(t)$ is the cosmic scale factor.\n-   Hubble parameter: $H(t) \\equiv \\dot{a}/a$.\n-   Physical velocity: $\\mathbf{u}(t,\\mathbf{r}) \\equiv d\\mathbf{r}/dt$.\n-   Peculiar velocity: $\\mathbf{v}(t,\\mathbf{x}) \\equiv a(t)\\,d\\mathbf{x}/dt$.\n-   Velocity relation: $\\mathbf{u} = H(t)\\,\\mathbf{r} + \\mathbf{v}$.\n-   Simplified ODE for peculiar velocity: $\\frac{d\\mathbf{v}}{dt} = -H(t)\\,\\mathbf{v}$, valid in the uniform-flow, source-free limit.\n-   Discretization bias definition: $\\epsilon \\equiv \\frac{v_{\\mathrm{num}}(t_{\\mathrm{f}}) - v_{\\mathrm{exact}}(t_{\\mathrm{f}})}{v_{\\mathrm{exact}}(t_{\\mathrm{f}})}$.\n-   Eulerian update: First-order forward Euler step.\n-   Lagrangian update: Second-order time-centered trapezoidal step.\n-   Case 1: $H(t) = H_0 = 2.27\\times 10^{-18}\\,\\mathrm{s}^{-1}$, $t_0 = 0\\,\\mathrm{s}$, $v_0 = 3.0\\times 10^{5}\\,\\mathrm{m/s}$, $\\Delta t = 5.0\\times 10^{16}\\,\\mathrm{s}$, $N = 10$. Exact solution: $v_{\\mathrm{exact}}(t_{\\mathrm{f}}) = v_0\\exp(-H_0\\,N\\,\\Delta t)$.\n-   Case 2: $H(t) = \\frac{2}{3\\,t}$, $t_0 = 1.0\\times 10^{16}\\,\\mathrm{s}$, $v_0 = 3.0\\times 10^{5}\\,\\mathrm{m/s}$, $\\Delta t = 5.0\\times 10^{15}\\,\\mathrm{s}$, $N = 8$. Exact solution: $v_{\\mathrm{exact}}(t_{\\mathrm{f}}) = v_0\\left(\\frac{t_0}{t_0 + N\\,\\Delta t}\\right)^{2/3}$.\n-   Case 3: $H(t) = H_0 = 2.27\\times 10^{-18}\\,\\mathrm{s}^{-1}$, $t_0 = 0\\,\\mathrm{s}$, $v_0 = 3.0\\times 10^{5}\\,\\mathrm{m/s}$, $\\Delta t = 1.0\\times 10^{15}\\,\\mathrm{s}$, $N = 10$. Exact solution: $v_{\\mathrm{exact}}(t_{\\mathrm{f}}) = v_0\\exp(-H_0\\,N\\,\\Delta t)$.\n-   Case 4: $H(t) = H_0 = 2.27\\times 10^{-18}\\,\\mathrm{s}^{-1}$, $t_0 = 0\\,\\mathrm{s}$, $v_0 = 3.0\\times 10^{5}\\,\\mathrm{m/s}$, $\\Delta t = 5.0\\times 10^{18}\\,\\mathrm{s}$, $N = 1$. Exact solution: $v_{\\mathrm{exact}}(t_{\\mathrm{f}}) = v_0\\exp(-H_0\\,N\\,\\Delta t)$.\n\n**Step 2: Validate Using Extracted Givens**\n-   **Scientifically Grounded**: The problem is set within the standard framework of Newtonian cosmology, using the fluid approximation which is a cornerstone of large-scale structure formation theory. The derivation of the comoving Euler equations is a fundamental and standard exercise in cosmology. The physical constants and parameters are of realistic orders of magnitude.\n-   **Well-Posed**: The derivation part is a standard proof. The numerical part is a well-defined initial value problem for an ODE, with specified initial conditions, time steps, and numerical methods. The exact solutions provided are correct and serve as a solid benchmark.\n-   **Objective**: The problem uses precise mathematical and physical terminology, free from subjective language.\n-   The problem does not exhibit any of the flaws listed in the validation criteria. It is scientifically sound, self-contained, and formalizable.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A solution will be provided.\n\n**Part 1: Derivation of the Comoving Euler Equations**\n\nWe begin with the Euler equations for a compressible, non-viscous fluid in physical coordinates $(\\mathbf{r}, t)$. The continuity equation (conservation of mass) and the momentum equation are:\n$$\n\\frac{\\partial \\rho}{\\partial t} + \\nabla_{\\mathbf{r}} \\cdot (\\rho \\mathbf{u}) = 0\n$$\n$$\n\\frac{\\partial \\mathbf{u}}{\\partial t} + (\\mathbf{u} \\cdot \\nabla_{\\mathbf{r}}) \\mathbf{u} = -\\frac{1}{\\rho}\\nabla_{\\mathbf{r}} P - \\nabla_{\\mathbf{r}} \\Phi\n$$\nHere, $\\rho(t,\\mathbf{r})$ is the fluid density, $P(t,\\mathbf{r})$ is the pressure, $\\mathbf{u}(t,\\mathbf{r})$ is the physical velocity field, and $\\Phi(t,\\mathbf{r})$ is the gravitational potential. The operator $\\nabla_{\\mathbf{r}}$ is the gradient with respect to physical coordinates $\\mathbf{r}$.\n\nOur goal is to transform these equations into comoving coordinates $\\mathbf{x}$, related to physical coordinates by $\\mathbf{r} = a(t) \\mathbf{x}$. The scale factor $a(t)$ describes the overall expansion of the universe.\n\nFirst, we establish the transformation rules for derivatives and velocities.\nThe gradient operator transforms as:\n$$\n\\nabla_{\\mathbf{r}} = \\frac{1}{a(t)}\\nabla_{\\mathbf{x}}\n$$\nThe partial time derivative at a fixed physical position $\\mathbf{r}$ is related to the partial time derivative at a fixed comoving position $\\mathbf{x}$. For any field $f(t, \\mathbf{r}(t, \\mathbf{x}))$, the chain rule gives:\n$$\n\\frac{\\partial f}{\\partial t}\\bigg|_{\\mathbf{x}} = \\frac{\\partial f}{\\partial t}\\bigg|_{\\mathbf{r}} + \\left(\\frac{\\partial \\mathbf{r}}{\\partial t}\\bigg|_{\\mathbf{x}}\\right) \\cdot \\nabla_{\\mathbf{r}} f\n$$\nSince $\\mathbf{r} = a(t)\\mathbf{x}$, we have $\\frac{\\partial \\mathbf{r}}{\\partial t}\\big|_{\\mathbf{x}} = \\dot{a}\\mathbf{x} = \\frac{\\dot{a}}{a} (a\\mathbf{x}) = H(t)\\mathbf{r}$. This gives:\n$$\n\\frac{\\partial}{\\partial t}\\bigg|_{\\mathbf{r}} = \\frac{\\partial}{\\partial t}\\bigg|_{\\mathbf{x}} - H(t)\\mathbf{r} \\cdot \\nabla_{\\mathbf{r}}\n$$\nThe physical velocity $\\mathbf{u}$ is the total time derivative of the physical position of a fluid element:\n$$\n\\mathbf{u} = \\frac{d\\mathbf{r}}{dt} = \\frac{d(a\\mathbf{x})}{dt} = \\dot{a}\\mathbf{x} + a\\dot{\\mathbf{x}} = H(a\\mathbf{x}) + a\\frac{d\\mathbf{x}}{dt} = H\\mathbf{r} + \\mathbf{v}\n$$\nThis matches the provided definition of the peculiar velocity $\\mathbf{v} \\equiv a(t)d\\mathbf{x}/dt$.\n\nNow we transform the continuity equation:\n$$\n\\left(\\frac{\\partial}{\\partial t}\\bigg|_{\\mathbf{x}} - H\\mathbf{r} \\cdot \\nabla_{\\mathbf{r}}\\right) \\rho + \\nabla_{\\mathbf{r}} \\cdot (\\rho \\mathbf{u}) = 0\n$$\nSubstituting $\\mathbf{r}=a\\mathbf{x}$, $\\mathbf{u}=H a \\mathbf{x} + \\mathbf{v}$, and $\\nabla_{\\mathbf{r}} = \\frac{1}{a}\\nabla_{\\mathbf{x}}$:\n$$\n\\frac{\\partial \\rho}{\\partial t} - H(a\\mathbf{x}) \\cdot \\left(\\frac{1}{a}\\nabla_{\\mathbf{x}}\\right) \\rho + \\frac{1}{a}\\nabla_{\\mathbf{x}} \\cdot (\\rho (H a \\mathbf{x} + \\mathbf{v})) = 0\n$$\n$$\n\\frac{\\partial \\rho}{\\partial t} - H(\\mathbf{x} \\cdot \\nabla_{\\mathbf{x}})\\rho + \\frac{1}{a}\\nabla_{\\mathbf{x}} \\cdot (\\rho H a \\mathbf{x}) + \\frac{1}{a}\\nabla_{\\mathbf{x}} \\cdot (\\rho \\mathbf{v}) = 0\n$$\nUsing the product rule for divergence, $\\nabla_{\\mathbf{x}} \\cdot (\\rho H a \\mathbf{x}) = H a [(\\nabla_{\\mathbf{x}}\\rho)\\cdot\\mathbf{x} + \\rho(\\nabla_{\\mathbf{x}}\\cdot\\mathbf{x})]$. With $\\nabla_{\\mathbf{x}}\\cdot\\mathbf{x}=3$, this becomes $H a [(\\mathbf{x}\\cdot\\nabla_{\\mathbf{x}}\\rho) + 3\\rho]$. The equation simplifies to:\n$$\n\\frac{\\partial \\rho}{\\partial t} - H(\\mathbf{x} \\cdot \\nabla_{\\mathbf{x}})\\rho + H(\\mathbf{x}\\cdot\\nabla_{\\mathbf{x}}\\rho) + 3H\\rho + \\frac{1}{a}\\nabla_{\\mathbf{x}} \\cdot (\\rho \\mathbf{v}) = 0\n$$\nThe $H(\\mathbf{x} \\cdot \\nabla_{\\mathbf{x}})\\rho$ terms cancel, yielding the comoving continuity equation:\n$$\n\\frac{\\partial \\rho}{\\partial t} + 3H\\rho + \\frac{1}{a}\\nabla_{\\mathbf{x}} \\cdot (\\rho \\mathbf{v}) = 0\n$$\n\nNext, we transform the momentum equation. Let's analyze the left-hand side (LHS):\nLHS = $\\frac{\\partial \\mathbf{u}}{\\partial t}\\big|_{\\mathbf{r}} + (\\mathbf{u} \\cdot \\nabla_{\\mathbf{r}}) \\mathbf{u}$.\nThe first term is:\n$$\n\\frac{\\partial \\mathbf{u}}{\\partial t}\\bigg|_{\\mathbf{r}} = \\left(\\frac{\\partial}{\\partial t}\\bigg|_{\\mathbf{x}} - H\\mathbf{r} \\cdot \\nabla_{\\mathbf{r}}\\right) \\mathbf{u} = \\frac{\\partial \\mathbf{u}}{\\partial t}\\bigg|_{\\mathbf{x}} - H(a\\mathbf{x}) \\cdot \\left(\\frac{1}{a}\\nabla_{\\mathbf{x}}\\right)(H a \\mathbf{x} + \\mathbf{v})\n$$\n$$\n\\frac{\\partial \\mathbf{u}}{\\partial t}\\bigg|_{\\mathbf{x}} = \\frac{\\partial}{\\partial t}(Ha\\mathbf{x} + \\mathbf{v}) = (\\dot{H}a + H\\dot{a})\\mathbf{x} + \\frac{\\partial \\mathbf{v}}{\\partial t} = (\\dot{H}+H^2)a\\mathbf{x} + \\frac{\\partial \\mathbf{v}}{\\partial t}\n$$\nSo, $\\frac{\\partial \\mathbf{u}}{\\partial t}\\big|_{\\mathbf{r}} = (\\dot{H}+H^2)a\\mathbf{x} + \\frac{\\partial \\mathbf{v}}{\\partial t} - H(\\mathbf{x} \\cdot \\nabla_{\\mathbf{x}})(Ha\\mathbf{x} + \\mathbf{v}) = (\\dot{H}+H^2)a\\mathbf{x} + \\frac{\\partial \\mathbf{v}}{\\partial t} - H^2a\\mathbf{x} - H(\\mathbf{x}\\cdot\\nabla_{\\mathbf{x}})\\mathbf{v} = \\dot{H}a\\mathbf{x} + \\frac{\\partial \\mathbf{v}}{\\partial t} - H(\\mathbf{x}\\cdot\\nabla_{\\mathbf{x}})\\mathbf{v}$.\n\nThe second term, the advective derivative, is:\n$$\n(\\mathbf{u} \\cdot \\nabla_{\\mathbf{r}}) \\mathbf{u} = \\left((Ha\\mathbf{x}+\\mathbf{v}) \\cdot \\frac{1}{a}\\nabla_{\\mathbf{x}}\\right) (Ha\\mathbf{x}+\\mathbf{v})\n$$\n$$\n= \\left(H\\mathbf{x}\\cdot\\nabla_{\\mathbf{x}} + \\frac{1}{a}\\mathbf{v}\\cdot\\nabla_{\\mathbf{x}}\\right) (Ha\\mathbf{x}+\\mathbf{v})\n$$\n$$\n= H\\mathbf{x}\\cdot\\nabla_{\\mathbf{x}}(Ha\\mathbf{x}) + H\\mathbf{x}\\cdot\\nabla_{\\mathbf{x}}(\\mathbf{v}) + \\frac{1}{a}(\\mathbf{v}\\cdot\\nabla_{\\mathbf{x}})(Ha\\mathbf{x}) + \\frac{1}{a}(\\mathbf{v}\\cdot\\nabla_{\\mathbf{x}})\\mathbf{v}\n$$\nThis evaluates to: $H^2a\\mathbf{x} + H(\\mathbf{x}\\cdot\\nabla_{\\mathbf{x}})\\mathbf{v} + H\\mathbf{v} + \\frac{1}{a}(\\mathbf{v}\\cdot\\nabla_{\\mathbf{x}})\\mathbf{v}$.\n\nCombining all terms on the LHS:\nLHS = $\\left(\\dot{H}a\\mathbf{x} + \\frac{\\partial \\mathbf{v}}{\\partial t} - H(\\mathbf{x}\\cdot\\nabla_{\\mathbf{x}})\\mathbf{v}\\right) + \\left(H^2a\\mathbf{x} + H(\\mathbf{x}\\cdot\\nabla_{\\mathbf{x}})\\mathbf{v} + H\\mathbf{v} + \\frac{1}{a}(\\mathbf{v}\\cdot\\nabla_{\\mathbf{x}})\\mathbf{v}\\right)$\n$$\n\\text{LHS} = \\frac{\\partial \\mathbf{v}}{\\partial t} + (\\dot{H}+H^2)a\\mathbf{x} + H\\mathbf{v} + \\frac{1}{a}(\\mathbf{v}\\cdot\\nabla_{\\mathbf{x}})\\mathbf{v}\n$$\n\nThe right-hand side (RHS) of the momentum equation is transformed as:\nRHS = $-\\frac{1}{\\rho}\\nabla_{\\mathbf{r}} P - \\nabla_{\\mathbf{r}} \\Phi = -\\frac{1}{a\\rho}\\nabla_{\\mathbf{x}} P - \\frac{1}{a}\\nabla_{\\mathbf{x}} \\Phi$.\nThe total gravitational potential $\\Phi$ is separated into a background part $\\Phi_b$ due to the mean density $\\bar{\\rho}(t)$, and a peculiar part $\\phi$ due to density fluctuations $\\delta\\rho = \\rho - \\bar{\\rho}$. The background potential satisfies $\\nabla^2_{\\mathbf{r}}\\Phi_b = 4\\pi G \\bar{\\rho}$. By Birkhoff's theorem in the Newtonian limit, the background gravitational force at $\\mathbf{r}$ is $-\\nabla_{\\mathbf{r}}\\Phi_b = -(\\frac{4\\pi G \\bar{\\rho}}{3})\\mathbf{r}$. From the second Friedmann equation for a non-relativistic fluid ($\\ddot{a}/a = \\dot{H}+H^2 = -4\\pi G \\bar{\\rho}/3$), we have $-\\nabla_{\\mathbf{r}}\\Phi_b = (\\dot{H}+H^2)\\mathbf{r} = (\\dot{H}+H^2)a\\mathbf{x}$.\nSo, $-\\frac{1}{a}\\nabla_{\\mathbf{x}}\\Phi = -\\frac{1}{a}\\nabla_{\\mathbf{x}}\\Phi_b - \\frac{1}{a}\\nabla_{\\mathbf{x}}\\phi = -\\nabla_{\\mathbf{r}}\\Phi_b - \\frac{1}{a}\\nabla_{\\mathbf{x}}\\phi = (\\dot{H}+H^2)a\\mathbf{x} - \\frac{1}{a}\\nabla_{\\mathbf{x}}\\phi$.\n\nEquating the full LHS and RHS:\n$$\n\\frac{\\partial \\mathbf{v}}{\\partial t} + (\\dot{H}+H^2)a\\mathbf{x} + H\\mathbf{v} + \\frac{1}{a}(\\mathbf{v}\\cdot\\nabla_{\\mathbf{x}})\\mathbf{v} = -\\frac{1}{a\\rho}\\nabla_{\\mathbf{x}} P + (\\dot{H}+H^2)a\\mathbf{x} - \\frac{1}{a}\\nabla_{\\mathbf{x}}\\phi\n$$\nThe background acceleration term $(\\dot{H}+H^2)a\\mathbf{x}$ cancels from both sides. We are left with the comoving momentum equation:\n$$\n\\frac{\\partial \\mathbf{v}}{\\partial t} + H\\mathbf{v} + \\frac{1}{a}(\\mathbf{v} \\cdot \\nabla_{\\mathbf{x}})\\mathbf{v} = -\\frac{1}{a\\rho}\\nabla_{\\mathbf{x}} P - \\frac{1}{a}\\nabla_{\\mathbf{x}}\\phi\n$$\nThe total or convective derivative of the peculiar velocity in comoving coordinates is $d\\mathbf{v}/dt = \\partial \\mathbf{v}/\\partial t + (\\dot{\\mathbf{x}}\\cdot\\nabla_{\\mathbf{x}})\\mathbf{v} = \\partial \\mathbf{v}/\\partial t + (\\frac{\\mathbf{v}}{a}\\cdot\\nabla_{\\mathbf{x}})\\mathbf{v}$. Thus, the equation can be written as:\n$$\n\\frac{d\\mathbf{v}}{dt} + H\\mathbf{v} = -\\frac{1}{a\\rho}\\nabla_{\\mathbf{x}} P - \\frac{1}{a}\\nabla_{\\mathbf{x}}\\phi\n$$\nRearranging to isolate the source terms on the right:\n$$\n\\frac{d\\mathbf{v}}{dt} = -H(t)\\mathbf{v} - \\frac{1}{a\\rho}\\nabla_{\\mathbf{x}} P - \\frac{1}{a}\\nabla_{\\mathbf{x}}\\phi\n$$\nThe term **$-H(t)\\mathbf{v}$** is explicitly identified as the \"Hubble drag\" term. It acts as a frictional force, damping peculiar velocities as the universe expands.\n\n**Assumptions Made:**\n1.  The fluid is ideal (non-viscous and non-conducting).\n2.  The dynamics are non-relativistic ($v \\ll c$, $P \\ll \\rho c^2$).\n3.  Gravity is described by Newtonian theory on a background FLRW metric. This is valid for scales much smaller than the Hubble radius.\n4.  The universe is spatially flat ($k=0$).\n5.  The gravitational potential is separable into a smooth background component and a peculiar perturbation.\n\n**Part 2: Numerical Calculation of Discretization Bias**\n\nWe are tasked with solving the simplified ODE $\\frac{dv}{dt} = -H(t)v$ for a scalar velocity amplitude $v$ using two different numerical schemes and computing the relative error.\n\n**Eulerian Update (Forward Euler):**\nThis is a first-order explicit method. The velocity at step $n+1$ is updated using values at step $n$:\n$$v_{n+1} = v_n + \\Delta t \\left( \\frac{dv}{dt} \\right)_n = v_n + \\Delta t (-H(t_n)v_n) = v_n(1 - H(t_n)\\Delta t)$$\n\n**Lagrangian Update (Trapezoidal Rule):**\nThis is a second-order implicit method. The update rule averages the derivative at the beginning and end of the time step:\n$$v_{n+1} = v_n + \\frac{\\Delta t}{2}\\left[ \\left(\\frac{dv}{dt}\\right)_n + \\left(\\frac{dv}{dt}\\right)_{n+1} \\right] = v_n + \\frac{\\Delta t}{2}[-H(t_n)v_n - H(t_{n+1})v_{n+1}]$$\nSolving for $v_{n+1}$:\n$$v_{n+1}\\left(1 + \\frac{\\Delta t}{2}H(t_{n+1})\\right) = v_n\\left(1 - \\frac{\\Delta t}{2}H(t_n)\\right)$$\n$$v_{n+1} = v_n \\frac{1 - \\frac{1}{2}H(t_n)\\Delta t}{1 + \\frac{1}{2}H(t_{n+1})\\Delta t}$$\n\nThe code below implements these two schemes for each test case, calculates the final velocity $v_{\\mathrm{num}}(t_f)$, compares it to the given $v_{\\mathrm{exact}}(t_f)$, and reports the discretization bias $\\epsilon = (v_{\\mathrm{num}} - v_{\\mathrm{exact}})/v_{\\mathrm{exact}}$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the discretization bias for Eulerian (Forward Euler) and\n    Lagrangian (Trapezoidal) schemes for the Hubble drag ODE.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: constant Hubble, moderate step\n        {\n            \"H_func\": lambda t, H0=2.27e-18: H0,\n            \"H0\": 2.27e-18,\n            \"t0\": 0.0,\n            \"v0\": 3.0e5,\n            \"dt\": 5.0e16,\n            \"N\": 10,\n            \"exact_sol\": lambda v0, H0, N, dt, t0: v0 * np.exp(-H0 * N * dt)\n        },\n        # Case 2: matter-dominated expansion\n        {\n            \"H_func\": lambda t: 2.0 / (3.0 * t) if t > 0 else np.inf,\n            \"t0\": 1.0e16,\n            \"v0\": 3.0e5,\n            \"dt\": 5.0e15,\n            \"N\": 8,\n            \"exact_sol\": lambda v0, H0, N, dt, t0: v0 * (t0 / (t0 + N * dt))**(2.0/3.0)\n        },\n        # Case 3: constant Hubble, small step\n        {\n            \"H_func\": lambda t, H0=2.27e-18: H0,\n            \"H0\": 2.27e-18,\n            \"t0\": 0.0,\n            \"v0\": 3.0e5,\n            \"dt\": 1.0e15,\n            \"N\": 10,\n            \"exact_sol\": lambda v0, H0, N, dt, t0: v0 * np.exp(-H0 * N * dt)\n        },\n        # Case 4: constant Hubble, extreme coarse step\n        {\n            \"H_func\": lambda t, H0=2.27e-18: H0,\n            \"H0\": 2.27e-18,\n            \"t0\": 0.0,\n            \"v0\": 3.0e5,\n            \"dt\": 5.0e18,\n            \"N\": 1,\n            \"exact_sol\": lambda v0, H0, N, dt, t0: v0 * np.exp(-H0 * N * dt)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        t0 = case[\"t0\"]\n        v0 = case[\"v0\"]\n        dt = case[\"dt\"]\n        N = case[\"N\"]\n        H_func = case[\"H_func\"]\n        H0 = case.get(\"H0\") # Will be None if not applicable\n\n        # Calculate exact solution\n        v_exact = case[\"exact_sol\"](v0, H0, N, dt, t0)\n\n        # Eulerian (Forward Euler) simulation\n        v_euler = v0\n        t_current = t0\n        for _ in range(N):\n            H_current = H_func(t_current)\n            v_euler = v_euler * (1.0 - H_current * dt)\n            t_current += dt\n        \n        bias_eulerian = (v_euler - v_exact) / v_exact\n\n        # Lagrangian (Trapezoidal) simulation\n        v_lagrange = v0\n        t_current = t0\n        for _ in range(N):\n            H_current = H_func(t_current)\n            H_next = H_func(t_current + dt)\n            \n            numerator = 1.0 - 0.5 * H_current * dt\n            denominator = 1.0 + 0.5 * H_next * dt\n            \n            v_lagrange = v_lagrange * (numerator / denominator)\n            t_current += dt\n\n        bias_lagrangian = (v_lagrange - v_exact) / v_exact\n        \n        results.append([bias_eulerian, bias_lagrangian])\n\n    # Format the final output string exactly as required\n    inner_strings = [f\"[{e_E},{e_L}]\" for e_E, e_L in results]\n    final_output = f\"[{','.join(inner_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3477164"}, {"introduction": "The transport of quantities by a velocity field, or advection, lies at the very heart of the distinction between Eulerian and Lagrangian methods. Eulerian schemes compute the flux of material across fixed cell boundaries, which can introduce numerical diffusion and dispersion, while Lagrangian schemes move the computational elements (particles) themselves, avoiding this class of error. In this exercise, you will implement and contrast a basic Eulerian finite-volume scheme with a Lagrangian translation-and-remap approach for the classic linear advection equation [@problem_id:3477134]. Using an advection speed that is incommensurate with the grid spacing will allow you to uncover the long-term accumulation of numerical artifacts and gain a practical understanding of the characteristic errors, like amplitude damping and phase shifts, that distinguish these two core strategies.", "problem": "Consider the one-dimensional conservative advection of a passive scalar field in a periodic domain, a canonical subproblem that appears in hydrodynamical components of numerical cosmology where advection over fixed spatial meshes may produce spurious phase and amplitude artifacts often referred to as “ghost flow” errors. Let the domain be $[0,L]$ with $L=1$, and let the scalar field be $u(x,t)$ satisfying the linear advection equation\n$$\n\\partial_t u(x,t) + v\\,\\partial_x u(x,t) = 0,\n$$\nwith constant velocity $v$. The initial condition is a smooth periodic pattern specified in radians:\n$$\nu(x,0) = \\sin(2\\pi x) + 0.25\\cos(6\\pi x),\n$$\nwhere the trigonometric functions take their arguments in radians. All quantities are dimensionless.\n\nYou must implement and compare, over long times, the growth of discrete $L_2$ error for two numerical approaches:\n\n- The Eulerian finite-volume method on a uniform mesh with $N$ cells, using an upwind flux consistent with the sign of $v$. The mesh is fixed in space, periodic boundary conditions apply, and stability must be ensured by an appropriate choice of the time step.\n- The Lagrangian translation followed by conservative remapping onto the fixed Eulerian mesh at each step, using the method of characteristics to obtain the field at fixed mesh locations after translation. In practice, at each time step, translate the field by the physical distance $v\\,\\Delta t$ and then remap to the original fixed mesh with linear interpolation that respects periodicity.\n\nTo eliminate commensurability effects between the velocity and the mesh that can mask long-time accumulation of error, impose an irrational Courant–Friedrichs–Lewy (CFL) number. Define the Courant number\n$$\nc \\equiv \\frac{v\\,\\Delta t}{\\Delta x},\n$$\nand set $v = \\sqrt{2}$ and $c = \\frac{\\sqrt{3}}{7}$ for every test case. Here $\\Delta x=L/N$ and $\\Delta t = c\\,\\Delta x / v$.\n\nFor each test case, evolve both schemes for $n$ time steps from $t=0$ to $t = n\\,\\Delta t$, and then compute the discrete $L_2$ error of each scheme with respect to the exact solution\n$$\nu_{\\text{exact}}(x,t) = \\sin\\!\\big(2\\pi (x - v t)\\big) + 0.25\\cos\\!\\big(6\\pi (x - v t)\\big),\n$$\nusing the discrete norm on the cell centers $x_i = (i+0.5)\\Delta x$:\n$$\n\\|e\\|_{2,\\Delta} = \\left(\\Delta x \\sum_{i=0}^{N-1} \\left[u_i - u_{\\text{exact}}(x_i,t)\\right]^2 \\right)^{1/2}.\n$$\n\nImplement both schemes from first principles, starting from the conservation law, without invoking specialized advection black-box routines. The Eulerian update must be derived from flux differences on control volumes, and the Lagrangian step must be derived from characteristics followed by interpolation-based remap consistent with periodic boundaries.\n\nAll outputs are dimensionless floats. Use radians for angles. Your program should evaluate the following test suite, which spans a “happy path,” boundary conditions on the number of steps, and resolution sensitivity:\n\n- Test $1$: $N=64$, $n=1000$.\n- Test $2$: $N=128$, $n=2000$.\n- Test $3$: $N=64$, $n=0$.\n- Test $4$: $N=64$, $n=1$.\n\nFor each test case, return a list containing two floats rounded to $6$ decimal places: the Eulerian discrete $L_2$ error and the Lagrangian discrete $L_2$ error at the final time. Your program should produce a single line of output containing the results for all test cases as a comma-separated list of such lists enclosed in square brackets. For example, the output format must be\n`[[e_{E,1},e_{L,1}],[e_{E,2},e_{L,2}],[e_{E,3},e_{L,3}],[e_{E,4},e_{L,4}]]`,\nwhere each $e_{E,k}$ and $e_{L,k}$ are floats rounded to $6$ decimal places.", "solution": "We begin from the conservation statement for passive scalar advection in one spatial dimension,\n$$\n\\partial_t u(x,t) + \\partial_x (F) = 0, \\quad F = v\\,u,\n$$\nwith constant velocity $v$. The analytical solution follows from the method of characteristics. Characteristics satisfy $dx/dt = v$, so the solution is constant along lines $x - v t = \\text{const}$, implying\n$$\nu(x,t) = u_0(x - v t),\n$$\nwhere $u_0(x)$ is the initial condition. With periodic boundary conditions on $[0,L]$, wrapping modulo $L$ preserves this form.\n\nWe define a uniform mesh with $N$ cells, cell width $\\Delta x = L/N$, and cell centers $x_i = (i+0.5)\\Delta x$ for $i \\in \\{0,\\dots,N-1\\}$. The time step is chosen based on the Courant–Friedrichs–Lewy (CFL) number $c$,\n$$\nc \\equiv \\frac{v\\,\\Delta t}{\\Delta x}.\n$$\nWe set $v=\\sqrt{2}$ and $c = \\frac{\\sqrt{3}}{7}$ which is irrational, hence\n$$\n\\Delta t = \\frac{c\\,\\Delta x}{v}.\n$$\nThis guarantees that the per-step translation is an irrational fraction of the cell width, thereby avoiding exact alignment with mesh cells over time and revealing cumulative numerical errors.\n\nEulerian finite-volume upwind scheme:\nWe integrate the conservation law over a control volume $[x_{i-1/2},x_{i+1/2}]$ and apply the divergence theorem, yielding\n$$\n\\frac{d}{dt} \\bar{u}_i(t) = -\\frac{1}{\\Delta x}\\left(F_{i+1/2} - F_{i-1/2}\\right),\n$$\nwhere $\\bar{u}_i$ is the cell-averaged value. With $v>0$, the upwind flux at an interface uses the left state, $F_{i+1/2} = v\\,\\bar{u}_i$, and $F_{i-1/2} = v\\,\\bar{u}_{i-1}$. Discretizing in time by a forward Euler step,\n$$\n\\bar{u}_i^{n+1} = \\bar{u}_i^n - \\frac{\\Delta t}{\\Delta x}\\left(v\\,\\bar{u}_i^n - v\\,\\bar{u}_{i-1}^n\\right) = \\bar{u}_i^n - c\\left(\\bar{u}_i^n - \\bar{u}_{i-1}^n\\right),\n$$\nfor $v>0$, which is stable for $0 < c \\le 1$. The periodic boundary is enforced by defining $\\bar{u}_{-1}^n \\equiv \\bar{u}_{N-1}^n$. Although we evolve point values at cell centers in practice, this discrete update is consistent with the finite-volume upwind approach for smooth fields and captures the Eulerian advection mechanism on a fixed grid.\n\nLagrangian translation with remap:\nFrom characteristics, the exact continuous solution at time $t^{n+1}$ at location $x$ is $u(x,t^{n+1}) = u(x - v\\,\\Delta t, t^n)$. To evaluate at the fixed mesh points $x_i$, we require the value of $u(\\cdot, t^n)$ at the off-grid position $y_i = x_i - v\\,\\Delta t$. On a discrete mesh, we approximate this via periodic linear interpolation between the nearest cell-centered samples. Let the fractional index corresponding to $y_i$ be\n$$\nj_i = \\frac{y_i}{\\Delta x} - 0.5,\n$$\nwith integer part $k_i = \\lfloor j_i \\rfloor$ and fractional part $\\theta_i = j_i - k_i$. The periodic indices are $k_i \\bmod N$ and $(k_i+1) \\bmod N$. The remapped value at $x_i$ is\n$$\nu_i^{n+1} = (1-\\theta_i) u_{k_i}^n + \\theta_i u_{k_i+1}^n,\n$$\nwith all indices taken modulo $N$ to enforce periodicity. This realizes a Lagrangian step (translation by $v\\,\\Delta t$) followed by a conservative remap to the fixed Eulerian grid at each time step. While the continuous characteristic solution is exact, the discrete interpolation introduces controlled error that differs in character from Eulerian numerical diffusion and dispersion.\n\nExact solution and error metric:\nAt final time $t^n = n\\,\\Delta t$, the exact solution on the mesh is\n$$\nu_{\\text{exact}}(x_i,t^n) = \\sin\\!\\big(2\\pi(x_i - v\\,t^n)\\big) + 0.25\\cos\\!\\big(6\\pi(x_i - v\\,t^n)\\big).\n$$\nWe evaluate the discrete $L_2$ error as\n$$\n\\|e\\|_{2,\\Delta} = \\left(\\Delta x \\sum_{i=0}^{N-1} \\left[u_i^n - u_{\\text{exact}}(x_i,t^n)\\right]^2 \\right)^{1/2}.\n$$\nThis discrete norm is a Riemann-sum approximation to the continuous $L_2$ norm, preserving the correct scaling with resolution.\n\nAlgorithmic design:\n- Initialize the mesh and cell centers $x_i = (i+0.5)\\Delta x$, and set $u_i^0 = \\sin(2\\pi x_i) + 0.25\\cos(6\\pi x_i)$.\n- Compute $\\Delta t = c\\,\\Delta x / v$ with $v=\\sqrt{2}$ and $c=\\sqrt{3}/7$.\n- For Eulerian advection, iterate $n$ times using the upwind update $\\bar{u}_i^{n+1} = \\bar{u}_i^n - c(\\bar{u}_i^n - \\bar{u}_{i-1}^n)$.\n- For Lagrangian translation, iterate $n$ times by periodic linear interpolation of $u^n$ evaluated at $x_i - v\\,\\Delta t$ to obtain $u^{n+1}$.\n- After $n$ steps, compute $t^n = n\\,\\Delta t$, construct $u_{\\text{exact}}(x_i,t^n)$, and evaluate the discrete $L_2$ error for each scheme.\n- Repeat for each test case. The irrational $c$ prevents synchrony between per-step shift and mesh spacing, unveiling long-time accumulation of numerical artifacts.\n\nNumerical considerations:\n- The Eulerian upwind method is first-order accurate and introduces numerical diffusion that accumulates with time, typically manifesting as amplitude damping of advected modes. Its phase error depends on $c$ and resolution.\n- The Lagrangian translation with linear remap preserves amplitude more effectively per step but introduces interpolation errors with different dispersion characteristics. Over long times, the irrational per-step displacement prevents periodic cancellation of remap errors, allowing a clear comparison of growth rates.\n- Using radians for the trigonometric functions ensures consistency with the definition of the initial pattern. All quantities are dimensionless, and no physical unit conversion is required.\n\nOutput specification:\nFor each test case, return a list $[e_E, e_L]$ where $e_E$ is the Eulerian discrete $L_2$ error and $e_L$ is the Lagrangian discrete $L_2$ error, both rounded to $6$ decimal places. Aggregate the four test case results into a single line as\n`[[e_{E,1},e_{L,1}],[e_{E,2},e_{L,2}],[e_{E,3},e_{L,3}],[e_{E,4},e_{L,4}]]`.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef initial_condition(x):\n    # Trigonometric functions use radians by default in numpy.\n    return np.sin(2.0 * np.pi * x) + 0.25 * np.cos(6.0 * np.pi * x)\n\ndef exact_solution(x, v, t):\n    return np.sin(2.0 * np.pi * (x - v * t)) + 0.25 * np.cos(6.0 * np.pi * (x - v * t))\n\ndef eulerian_upwind(u, c):\n    # v > 0 assumed; upwind uses left neighbor. Periodic wrap.\n    # u_{i}^{n+1} = u_{i}^{n} - c (u_{i}^{n} - u_{i-1}^{n})\n    u_prev = u\n    u_shift_left = np.roll(u_prev, 1)\n    return u_prev - c * (u_prev - u_shift_left)\n\ndef lagrangian_translate_linear(u, shift, dx):\n    # shift is physical distance v*dt. Map u(x - shift) to the fixed grid.\n    # Cell centers at x_i = (i + 0.5) * dx. The fractional index for y_i = x_i - shift is:\n    # j = y / dx - 0.5. Then linear interp between floor(j) and floor(j)+1 with periodic wrap.\n    N = u.size\n    # Indices grid i=0..N-1 corresponds to x_i = (i+0.5)*dx\n    # Compute j for all i in vectorized form: j_i = i - shift/dx\n    # Because j = y/dx - 0.5 = ((i+0.5)dx - shift)/dx - 0.5 = i - shift/dx\n    j = np.arange(N, dtype=float) - (shift / dx)\n    k = np.floor(j).astype(int)\n    theta = j - k\n    k0 = np.mod(k, N)\n    k1 = np.mod(k + 1, N)\n    return (1.0 - theta) * u[k0] + theta * u[k1]\n\ndef discrete_L2(u, u_exact, dx):\n    return np.sqrt(dx * np.sum((u - u_exact) ** 2))\n\ndef run_case(N, n_steps, v, c, L=1.0):\n    dx = L / N\n    dt = c * dx / v\n    x_centers = (np.arange(N, dtype=float) + 0.5) * dx\n    # Initialize\n    u0 = initial_condition(x_centers)\n    # Eulerian evolution\n    u_e = u0.copy()\n    # Lagrangian evolution\n    u_l = u0.copy()\n    # Per-step physical shift\n    shift = v * dt\n    for _ in range(n_steps):\n        u_e = eulerian_upwind(u_e, c)\n        u_l = lagrangian_translate_linear(u_l, shift, dx)\n    t_final = n_steps * dt\n    u_exact = exact_solution(x_centers, v, t_final)\n    err_e = discrete_L2(u_e, u_exact, dx)\n    err_l = discrete_L2(u_l, u_exact, dx)\n    return err_e, err_l\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is (N, n_steps)\n    test_cases = [\n        (64, 1000),\n        (128, 2000),\n        (64, 0),\n        (64, 1),\n    ]\n    # Constants: v = sqrt(2), c = sqrt(3)/7 (irrational Courant number)\n    v = np.sqrt(2.0)\n    c = np.sqrt(3.0) / 7.0\n\n    results = []\n    for N, n_steps in test_cases:\n        err_e, err_l = run_case(N, n_steps, v, c, L=1.0)\n        # Round to 6 decimal places as required\n        results.append([round(err_e, 6), round(err_l, 6)])\n\n    # Final print statement in the exact required format.\n    # Format: [[eE1,eL1],[eE2,eL2],[eE3,eL3],[eE4,eL4]]\n    print(f\"[{','.join('[' + ','.join(map(lambda x: f'{x:.6f}', pair)) + ']' for pair in results)}]\")\n\nsolve()\n```", "id": "3477134"}, {"introduction": "In the Lagrangian picture of cosmic structure formation, particle trajectories can cross, forming complex, multi-valued velocity fields known as \"multistream\" regions. The Eulerian density field, however, remains single-valued at every point in space, thus obscuring this rich phase-space information. This advanced exercise explores this information loss using the powerful mathematical framework of optimal transport to reconstruct a \"best-fit\" Lagrangian map from a given Eulerian density snapshot [@problem_id:3477115]. By comparing your reconstructed monotonic map to the true, non-monotonic map generated by a model of shell-crossing, you will directly quantify how well mass elements are recovered and gain a profound insight into the challenges of interpreting Eulerian data in the context of a complex Lagrangian history.", "problem": "Consider a one-dimensional, periodic cosmological domain with coordinate $x \\in [0,1)$ and a uniform initial Lagrangian coordinate $q \\in [0,1)$. The initial Lagrangian mass distribution is uniform with density $\\rho_{\\mathrm{L}}(q)=1$. An Eulerian snapshot at a given time is generated by a deterministic Lagrangian-to-Eulerian map $x(q)$ acting on $q$, followed by periodic wrapping modulo $1$. The Eulerian density $\\rho_{\\mathrm{E}}(x)$ is defined by conservation of mass, so that for any interval $I \\subset [0,1)$ one has $\\int_{I} \\rho_{\\mathrm{E}}(x)\\,dx = \\int_{x^{-1}(I)} \\rho_{\\mathrm{L}}(q)\\,dq$, where $x^{-1}(I)$ is the preimage in Lagrangian space. The Eulerian description can exhibit multistream regions, where multiple disjoint Lagrangian intervals map to the same Eulerian interval. \n\nYou will reconstruct a Lagrangian map $\\tilde{x}(q)$ from an Eulerian snapshot $\\rho_{\\mathrm{E}}(x)$ by solving the quadratic-cost optimal transport problem: find a measurable map $T:[0,1)\\to[0,1)$ that pushes forward $\\rho_{\\mathrm{L}}(q)\\,dq$ to $\\rho_{\\mathrm{E}}(x)\\,dx$, and minimizes the cost functional $J[T] = \\int_{0}^{1} \\left(d_{\\mathrm{per}}(T(q),q)\\right)^{2} \\rho_{\\mathrm{L}}(q)\\,dq$, where $d_{\\mathrm{per}}$ is the periodic distance on the unit circle defined by $d_{\\mathrm{per}}(x,q) = \\min\\{|x-q|,\\,1-|x-q|\\}$. In one dimension with quadratic cost, the optimal transport map is monotone non-decreasing and is uniquely characterized by mass conservation. Your program must implement this reconstruction and assess how well mass elements are recovered, especially in multistream regions.\n\nFundamental base:\n- Mass conservation: $\\int_{I} \\rho_{\\mathrm{E}}(x)\\,dx = \\int_{x^{-1}(I)} \\rho_{\\mathrm{L}}(q)\\,dq$.\n- Definition of the Lagrangian map: $x(q) = q - a \\sin(2\\pi q)$ with periodic wrapping $x(q) \\mapsto x(q)\\bmod 1$, where $a$ is a real amplitude parameter. This deterministic map is an idealized one-dimensional analogue of the Zel’dovich approximation and can produce multistreaming when $\\frac{dx}{dq}$ changes sign.\n- Quadratic-cost optimal transport in one dimension with a uniform source density and periodic domain; reconstruct a monotone map $\\tilde{x}(q)$ that minimizes $\\int_{0}^{1} \\left(d_{\\mathrm{per}}(\\tilde{x}(q),q)\\right)^{2} \\,dq$ while exactly matching the Eulerian density $\\rho_{\\mathrm{E}}(x)$.\n\nAlgorithmic requirements:\n- Discretize $q$ with $N$ equally spaced samples in $[0,1)$ and generate the Eulerian positions $x_{\\mathrm{true}}(q)=\\left(q - a \\sin(2\\pi q)\\right)\\bmod 1$ for each sample.\n- Estimate the Eulerian density $\\rho_{\\mathrm{E}}(x)$ on $M$ uniform bins covering $[0,1)$ by histogramming the set $\\{x_{\\mathrm{true}}(q)\\}$, dividing by the bin width to obtain a density consistent with $\\int_{0}^{1} \\rho_{\\mathrm{E}}(x)\\,dx = 1$.\n- Reconstruct the optimal transport map $\\tilde{x}(q)$ by solving the one-dimensional periodic quadratic-cost optimal transport problem that pushes forward the uniform Lagrangian density $\\rho_{\\mathrm{L}}(q)=1$ to the discrete Eulerian density estimate $\\rho_{\\mathrm{E}}(x)$. Implement the solution numerically via cumulative mass balance without shortcuts provided in the problem statement.\n- Define Eulerian bins by the $M$ uniform intervals. For each particle index $i$, let $b_{\\mathrm{true}}(i)$ be the index of the bin containing $x_{\\mathrm{true}}(q_i)$, and $b_{\\mathrm{OT}}(i)$ the index of the bin containing $\\tilde{x}(q_i)$.\n- Define a bin-wise multistream indicator: for each bin $b$, collect the sorted list of particle indices $\\{i: b_{\\mathrm{true}}(i)=b\\}$ ordered by $i$. Count the number of contiguous runs in this index list; a bin is called single-stream if it has exactly one contiguous run, and multistream if it has more than one contiguous run.\n- Compute the following quantitative assessments:\n    1. The optimal transport mean squared periodic displacement $C_{\\mathrm{OT}} = \\frac{1}{N}\\sum_{i=1}^{N}\\left(d_{\\mathrm{per}}(\\tilde{x}(q_i),q_i)\\right)^{2}$, expressed in dimensionless units.\n    2. The root mean squared periodic error between the reconstructed positions and the true positions $E_{\\mathrm{RMS}} = \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N}\\left(d_{\\mathrm{per}}(\\tilde{x}(q_i),x_{\\mathrm{true}}(q_i))\\right)^{2}}$, dimensionless.\n    3. The global bin-assignment accuracy $A_{\\mathrm{global}} = \\frac{1}{N}\\sum_{i=1}^{N} \\mathbf{1}\\{b_{\\mathrm{OT}}(i)=b_{\\mathrm{true}}(i)\\}$, dimensionless.\n    4. The single-stream bin-assignment accuracy $A_{\\mathrm{single}}$ computed by restricting the indicator sum to particles in single-stream bins only, dimensionless.\n    5. The multistream bin-assignment accuracy $A_{\\mathrm{multi}}$ computed by restricting the indicator sum to particles in multistream bins only, dimensionless. If there are zero multistream bins, define $A_{\\mathrm{multi}}=1.0$ by convention.\n    6. The counts $N_{\\mathrm{single}}$ and $N_{\\mathrm{multi}}$ of single-stream and multistream bins, respectively, as integers.\n\nTest suite and parameters:\n- Use $N=4096$ Lagrangian samples and $M=256$ Eulerian bins for all cases.\n- Use the following amplitudes $a$:\n    - Case $1$: $a=0.10$ (single-stream regime).\n    - Case $2$: $a=\\frac{1}{2\\pi}\\approx 0.15915494309189535$ (onset of shell crossing).\n    - Case $3$: $a=0.30$ (moderate multistream).\n    - Case $4$: $a=0.50$ (strong multistream).\nAll quantities are dimensionless; all outputs must be expressed in dimensionless units and floats should be rounded to six decimal places.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of per-case result lists, each per-case list ordered as $[C_{\\mathrm{OT}}, E_{\\mathrm{RMS}}, A_{\\mathrm{global}}, A_{\\mathrm{single}}, A_{\\mathrm{multi}}, N_{\\mathrm{single}}, N_{\\mathrm{multi}}]$, enclosed in one set of square brackets. For example, the overall output should look like $[[r_{1,1},r_{1,2},\\dots],[r_{2,1},\\dots],\\dots]$, with each $r_{i,j}$ represented as a float rounded to six decimal places or an integer as specified.", "solution": "The problem asks for the implementation and evaluation of a one-dimensional, periodic optimal transport (OT) reconstruction of a cosmological mass distribution. We are given a true, deterministic Lagrangian-to-Eulerian map, analogous to the Zel'dovich approximation, and tasked with reconstructing this map from its resulting Eulerian density. The quality of the reconstruction is to be assessed, particularly its ability to correctly place mass elements in single-stream versus multistream regions.\n\nThe core of the problem lies in the contrast between two descriptions of a fluid or particle system. The Lagrangian description tracks individual particles, labeled by an initial coordinate $q \\in [0,1)$. The Eulerian description provides a snapshot of the system's properties, such as density $\\rho_{\\mathrm{E}}(x)$, at fixed spatial locations $x \\in [0,1)$. The connection between them is the map $x(q)$, which gives the Eulerian position of the particle initially at Lagrangian coordinate $q$.\n\nThe specified \"true\" map is $x_{\\mathrm{true}}(q) = (q - a \\sin(2\\pi q)) \\pmod 1$. The parameter $a$ controls the amplitude of the displacement. The derivative of the unwrapped map is $\\frac{dx}{dq} = 1 - 2\\pi a \\cos(2\\pi q)$. If $a > 1/(2\\pi)$, this derivative can become negative for some $q$. This means the map $x_{\\mathrm{true}}(q)$ is no longer monotonic; different initial particles can be mapped to the same final position, a phenomenon known as shell-crossing or multistreaming. This creates regions of high density and overlapping streams, which are fundamental features of cosmic structure formation.\n\nOur task is to reverse this process: given the Eulerian density $\\rho_{\\mathrm{E}}(x)$ that results from this map, we want to find an \"optimal\" map $\\tilde{x}(q)$ that transforms the initial uniform Lagrangian density $\\rho_{\\mathrm{L}}(q)=1$ into the given $\\rho_{\\mathrm{E}}(x)$. The criterion for optimality is the minimization of a quadratic cost functional, $J[T] = \\int_{0}^{1} (d_{\\mathrm{per}}(T(q),q))^{2} \\rho_{\\mathrm{L}}(q)\\,dq$, where $d_{\\mathrm{per}}$ is the periodic distance. This is a problem in Optimal Transport.\n\nA key theorem in one-dimensional OT, applicable here, states that for a quadratic cost function, the optimal map $T(q)$ (which we denote $\\tilde{x}(q)$) is uniquely determined and monotonic non-decreasing. This map can be found by enforcing mass conservation in the cumulative distribution functions. Let $M_{\\mathrm{L}}(q) = \\int_0^q \\rho_{\\mathrm{L}}(q')\\,dq'$ be the cumulative mass in Lagrangian space, and $M_{\\mathrm{E}}(x) = \\int_0^x \\rho_{\\mathrm{E}}(x')\\,dx'$ be the cumulative mass in Eulerian space. The mass conservation principle dictates that the mass of particles with Lagrangian coordinate up to $q$ must equal the mass of matter with Eulerian coordinate up to $\\tilde{x}(q)$. This gives the relation $M_{\\mathrm{L}}(q) = M_{\\mathrm{E}}(\\tilde{x}(q))$.\n\nGiven that the initial density is uniform, $\\rho_{\\mathrm{L}}(q) = 1$, the Lagrangian cumulative mass is simply $M_{\\mathrm{L}}(q) = q$. The relation becomes $q = M_{\\mathrm{E}}(\\tilde{x}(q))$. Solving for our reconstructed map, we find $\\tilde{x}(q) = M_{\\mathrm{E}}^{-1}(q)$, where $M_{\\mathrm{E}}^{-1}$ is the inverse of the Eulerian cumulative mass function (also known as the quantile function).\n\nThe numerical algorithm proceeds as follows:\n1.  Discretize the Lagrangian space with $N=4096$ particles at positions $q_i = (i+0.5)/N$ for $i=0, 1, \\dots, N-1$. Each particle represents a mass element of $1/N$.\n2.  For a given amplitude $a$, compute the true Eulerian positions $x_{\\mathrm{true}}(q_i) = (q_i - a \\sin(2\\pi q_i)) \\pmod 1$.\n3.  Estimate the Eulerian density by histogramming the $N$ positions $\\{x_{\\mathrm{true}}(q_i)\\}$ into $M=256$ uniform bins on $[0,1)$. This gives the counts $N_j$ for each bin $j$. The mass in bin $j$ is $m_j = N_j/N$, and the piecewise-constant density is $\\rho_{\\mathrm{E}, j} = m_j / (1/M) = M N_j / N$.\n4.  Numerically construct the discrete Eulerian cumulative mass function, $C_j = \\sum_{k=0}^{j} m_k$, which gives the total mass up to the right edge of bin $j$. The function $M_{\\mathrm{E}}(x)$ is the piecewise-linear interpolation of these values.\n5.  To find the reconstructed position $\\tilde{x}(q_i)$, we calculate its target cumulative mass, which is its quantile in the uniform distribution: $q_i = (i+0.5)/N$. We then invert $M_{\\mathrm{E}}$ by first finding the bin $j$ such that $C_{j-1} < q_i \\le C_j$, and then linearly interpolating within that bin to find the position $\\tilde{x}(q_i)$ that corresponds to cumulative mass $q_i$.\n6.  The true map $x_{\\mathrm{true}}(q)$ is non-monotonic in multistream regions, whereas the reconstructed map $\\tilde{x}(q)$ is, by construction, monotonic. The discrepancy between them, particularly in multistream regions, is the object of study.\n7.  We define a multistream indicator for each Eulerian bin. A bin is classified as multistream if the Lagrangian particles that land in it come from more than one non-contiguous segment of the initial Lagrangian line. This is diagnosed by sorting the original indices $i$ of all particles $\\{q_i\\}$ that map into a given bin and counting the number of contiguous blocks in the sorted index list.\n8.  Finally, we compute a set of metrics to quantify the performance of the OT reconstruction. $C_{\\mathrm{OT}}$ measures the total squared displacement of the OT map itself. $E_{\\mathrm{RMS}}$ measures the root-mean-square error between the reconstructed positions $\\tilde{x}(q_i)$ and the true positions $x_{\\mathrm{true}}(q_i)$, quantifying the physical error of the reconstruction. The bin assignment accuracies $A_{\\mathrm{global}}$, $A_{\\mathrm{single}}$, and $A_{\\mathrm{multi}}$ measure the fraction of particles correctly placed into their true Eulerian bins, analyzed globally and conditioned on whether the particle's true destination is a single-stream or multistream bin. This allows a precise assessment of how OT reconstruction handles complex, folded structures.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D optimal transport reconstruction problem for four test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (amplitude a)\n        0.10,\n        1.0 / (2.0 * np.pi), # approx 0.15915494309189535\n        0.30,\n        0.50,\n    ]\n    \n    # Discretization parameters\n    N = 4096\n    M = 256\n\n    all_results = []\n\n    for a in test_cases:\n        # Step 1: Generate true particle data\n        q = (np.arange(N) + 0.5) / N\n        x_true = (q - a * np.sin(2 * np.pi * q)) % 1.0\n\n        # Step 2: Estimate Eulerian density on M bins\n        bin_width = 1.0 / M\n        # np.histogram gives counts N_j\n        counts, _ = np.histogram(x_true, bins=M, range=(0, 1))\n        \n        # Mass per bin\n        mass_per_bin = counts / N\n        # Cumulative mass function at bin edges\n        # C_j = mass up to right edge of bin j\n        cumulative_mass = np.cumsum(mass_per_bin)\n        # Prepend 0 for mass at x=0\n        cumulative_mass = np.insert(cumulative_mass, 0, 0)\n        \n        # Step 3: Reconstruct the optimal transport map x_ot(q)\n        # Target cumulative mass for each particle\n        target_mass = (np.arange(N) + 0.5) / N\n        \n        # Find the bin index for each particle via mass conservation\n        # j such that C_{j-1}  target_mass = C_j\n        bin_indices = np.searchsorted(cumulative_mass, target_mass, side='right') - 1\n        \n        # Handle cases where a bin might have zero mass.\n        # This shouldn't happen with the chosen target_mass, but as a safeguard:\n        bin_indices = np.maximum(0, bin_indices)\n\n        mass_in_found_bins = mass_per_bin[bin_indices]\n        cum_mass_before_bin = cumulative_mass[bin_indices]\n\n        # Linearly interpolate position within the bin\n        # Avoid division by zero for empty bins (though target_mass should not fall there)\n        # delta_x = (target_mass - mass_before) / density\n        # density = mass_in_bin / bin_width\n        delta_x = np.zeros_like(target_mass)\n        non_empty_mask = mass_in_found_bins > 0\n        \n        delta_mass = target_mass[non_empty_mask] - cum_mass_before_bin[non_empty_mask]\n        density_in_bin = mass_in_found_bins[non_empty_mask] / bin_width\n        delta_x[non_empty_mask] = delta_mass / density_in_bin\n\n        x_ot = (bin_indices / M) + delta_x\n        # Ensure results are within [0,1] domain\n        x_ot = np.clip(x_ot, 0.0, 1.0)\n        \n        # Step 4: Compute quantitative assessments\n        \n        def periodic_distance_sq(x1, x2):\n            d = np.abs(x1 - x2)\n            dist = np.minimum(d, 1.0 - d)\n            return dist**2\n\n        # 4.1 C_OT: optimal transport mean squared periodic displacement\n        c_ot = np.mean(periodic_distance_sq(x_ot, q))\n        \n        # 4.2 E_RMS: root mean squared periodic error\n        e_rms = np.sqrt(np.mean(periodic_distance_sq(x_ot, x_true)))\n        \n        # 4.3 Bin assignments\n        # Use np.minimum to handle x=1.0 case mapping to M instead of M-1\n        b_true = np.minimum(np.floor(x_true * M).astype(int), M - 1)\n        b_ot = np.minimum(np.floor(x_ot * M).astype(int), M - 1)\n        \n        # 4.4 Global bin-assignment accuracy\n        a_global = np.mean(b_ot == b_true)\n        \n        # 4.5 Multistream analysis\n        is_multistream_bin = np.zeros(M, dtype=bool)\n        bin_contents = [[] for _ in range(M)]\n        for i, b in enumerate(b_true):\n            bin_contents[b].append(i)\n            \n        n_single = 0\n        n_multi = 0\n        for b in range(M):\n            indices = bin_contents[b]\n            if len(indices) = 1:\n                runs = len(indices)\n            else:\n                # Indices must be sorted to count runs\n                sorted_indices = np.sort(indices)\n                runs = 1 + np.sum(np.diff(sorted_indices) > 1)\n            \n            if runs > 1:\n                is_multistream_bin[b] = True\n                n_multi += 1\n            else:\n                n_single += 1\n\n        # Particle masks for single-stream and multi-stream bins\n        particle_in_ss_bin_mask = ~is_multistream_bin[b_true]\n        particle_in_ms_bin_mask = is_multistream_bin[b_true]\n        \n        n_ss_particles = np.sum(particle_in_ss_bin_mask)\n        n_ms_particles = np.sum(particle_in_ms_bin_mask)\n        \n        # 4.6 Single-stream accuracy\n        if n_ss_particles == 0:\n            a_single = 1.0\n        else:\n            correct_ss = np.sum((b_ot == b_true)[particle_in_ss_bin_mask])\n            a_single = correct_ss / n_ss_particles\n            \n        # 4.7 Multistream accuracy\n        if n_multi == 0: # Implies n_ms_particles == 0\n            a_multi = 1.0\n        else:\n            correct_ms = np.sum((b_ot == b_true)[particle_in_ms_bin_mask])\n            a_multi = correct_ms / n_ms_particles\n\n        # Collate results for this case\n        case_results = [c_ot, e_rms, a_global, a_single, a_multi, n_single, n_multi]\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    case_strings = []\n    for res in all_results:\n        # First 5 are floats, last 2 are ints\n        float_parts = [f\"{v:.6f}\" for v in res[:5]]\n        int_parts = [str(v) for v in res[5:]]\n        s = f\"[{','.join(float_parts + int_parts)}]\"\n        case_strings.append(s)\n\n    print(f\"[{','.join(case_strings)}]\")\n\nsolve()\n```", "id": "3477115"}]}