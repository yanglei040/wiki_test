{"hands_on_practices": [{"introduction": "To build efficient gravity solvers, we must first understand the trade-off between accuracy and computational speed. This first practice provides a concrete, quantitative look at the heart of the Barnes-Hut algorithm: approximating a distant group of particles as a single point mass, or a monopole. By calculating the error of this approximation for a simple case, you will build intuition for the opening-angle criterion, $\\theta$, that governs the algorithm's accuracy [@problem_id:3501662].", "problem": "Consider Newtonian gravity in comoving code units where the gravitational constant is $G=1$. A simple configuration mimicking a single far cell in a Barnes–Hut (BH) tree consists of a target particle at the origin with mass $m_{0}$, and two source particles with masses $m_{1}=1$ and $m_{2}=1$ located at positions $\\boldsymbol{r}_{1}=(10,1,0)$ and $\\boldsymbol{r}_{2}=(10,-1,0)$. Ignore any cosmological expansion factors or periodic images and treat the interaction as purely Newtonian in three-dimensional Euclidean space.\n\nStarting from Newton’s law of gravitation and the definition of the center of mass, do the following in order:\n\n1. Compute the exact gravitational force vector $\\boldsymbol{F}_{\\text{exact}}$ on the target particle due to the two source particles.\n\n2. Approximate the contribution of the two source particles by a single BH tree cell using only the monopole term: replace the two particles by a single point mass equal to their total mass $M$ located at their center of mass position $\\boldsymbol{R}_{\\text{cm}}$. Compute the approximate force vector $\\boldsymbol{F}_{\\text{mono}}$ on the target particle.\n\n3. Using your results, compute the relative error of the monopole approximation defined as\n$$\n\\varepsilon \\equiv \\frac{\\left\\lvert \\boldsymbol{F}_{\\text{exact}}-\\boldsymbol{F}_{\\text{mono}}\\right\\rvert}{\\left\\lvert \\boldsymbol{F}_{\\text{exact}}\\right\\rvert}.\n$$\n\nTo connect with the BH opening-angle criterion, define the effective cell size as the side length $s$ of the smallest axis-aligned square that bounds the two source particles and let $d=\\lvert \\boldsymbol{R}_{\\text{cm}}\\rvert$. Report the opening angle $\\theta \\equiv s/d$ you would associate with this configuration, and interpret the numerical value of $\\varepsilon$ as the relative error realized at that $\\theta$ for this geometry.\n\nProvide as your final answer only the numerical value of $\\varepsilon$ as a dimensionless decimal, rounded to four significant figures.", "solution": "The problem is subjected to validation and is determined to be a valid, well-posed problem in Newtonian mechanics, directly applicable to the analysis of numerical algorithms in cosmology. The problem is self-contained, scientifically grounded, and unambiguous. We may therefore proceed with a formal solution.\n\nThe gravitational force $\\boldsymbol{F}_{ji}$ exerted on a particle $i$ with mass $m_i$ at position $\\boldsymbol{r}_i$ by a source particle $j$ with mass $m_j$ at position $\\boldsymbol{r}_j$ is given by Newton's law of universal gravitation:\n$$\n\\boldsymbol{F}_{ji} = G \\frac{m_j m_i}{\\left\\lvert\\boldsymbol{r}_j - \\boldsymbol{r}_i\\right\\rvert^3} (\\boldsymbol{r}_j - \\boldsymbol{r}_i)\n$$\nIn this problem, the gravitational constant is given as $G=1$. The target particle has mass $m_0$ and is located at the origin, so its position vector is $\\boldsymbol{r}_0 = (0,0,0)$. The two source particles have masses $m_1=1$ and $m_2=1$ and are located at positions $\\boldsymbol{r}_1 = (10,1,0)$ and $\\boldsymbol{r}_2 = (10,-1,0)$, respectively.\n\n**1. Exact Gravitational Force**\n\nThe exact total gravitational force on the target particle, $\\boldsymbol{F}_{\\text{exact}}$, is the vector sum of the individual forces from each source particle:\n$$\n\\boldsymbol{F}_{\\text{exact}} = \\boldsymbol{F}_{10} + \\boldsymbol{F}_{20}\n$$\nwhere $\\boldsymbol{F}_{10}$ is the force from particle $1$ on particle $0$, and $\\boldsymbol{F}_{20}$ is the force from particle $2$ on particle $0$.\n\nWe compute the individual force vectors:\nThe vector from particle $1$ to particle $0$ is $\\boldsymbol{r}_0 - \\boldsymbol{r}_1 = -\\boldsymbol{r}_1$, but the force on particle $0$ is directed towards particle $1$, so we use the vector $\\boldsymbol{r}_1 - \\boldsymbol{r}_0 = \\boldsymbol{r}_1$.\n$$\n\\boldsymbol{F}_{10} = G \\frac{m_1 m_0}{\\left\\lvert\\boldsymbol{r}_1 - \\boldsymbol{r}_0\\right\\rvert^3} (\\boldsymbol{r}_1 - \\boldsymbol{r}_0) = (1) \\frac{(1) m_0}{\\left\\lvert\\boldsymbol{r}_1\\right\\rvert^3} \\boldsymbol{r}_1\n$$\nThe squared magnitude of $\\boldsymbol{r}_1$ is $\\left\\lvert\\boldsymbol{r}_1\\right\\rvert^2 = 10^2 + 1^2 + 0^2 = 101$. Thus, $\\left\\lvert\\boldsymbol{r}_1\\right\\rvert = \\sqrt{101}$.\n$$\n\\boldsymbol{F}_{10} = \\frac{m_0}{(\\sqrt{101})^3} (10,1,0) = \\frac{m_0}{101\\sqrt{101}} (10,1,0)\n$$\nSimilarly, for particle $2$:\n$$\n\\boldsymbol{F}_{20} = G \\frac{m_2 m_0}{\\left\\lvert\\boldsymbol{r}_2 - \\boldsymbol{r}_0\\right\\rvert^3} (\\boldsymbol{r}_2 - \\boldsymbol{r}_0) = (1) \\frac{(1) m_0}{\\left\\lvert\\boldsymbol{r}_2\\right\\rvert^3} \\boldsymbol{r}_2\n$$\nThe squared magnitude of $\\boldsymbol{r}_2$ is $\\left\\lvert\\boldsymbol{r}_2\\right\\rvert^2 = 10^2 + (-1)^2 + 0^2 = 101$. Thus, $\\left\\lvert\\boldsymbol{r}_2\\right\\rvert = \\sqrt{101}$.\n$$\n\\boldsymbol{F}_{20} = \\frac{m_0}{(\\sqrt{101})^3} (10,-1,0) = \\frac{m_0}{101\\sqrt{101}} (10,-1,0)\n$$\nThe total exact force is the sum:\n$$\n\\boldsymbol{F}_{\\text{exact}} = \\boldsymbol{F}_{10} + \\boldsymbol{F}_{20} = \\frac{m_0}{101\\sqrt{101}} \\left[ (10,1,0) + (10,-1,0) \\right] = \\frac{m_0}{101\\sqrt{101}} (20,0,0)\n$$\nSo, $\\boldsymbol{F}_{\\text{exact}} = \\left(\\frac{20m_0}{101\\sqrt{101}}, 0, 0\\right)$.\n\n**2. Monopole Approximation Force**\n\nIn the monopole approximation, the two source particles are replaced by a single point mass $M$ located at their center of mass $\\boldsymbol{R}_{\\text{cm}}$.\nThe total mass is $M = m_1 + m_2 = 1 + 1 = 2$.\nThe center of mass position is:\n$$\n\\boldsymbol{R}_{\\text{cm}} = \\frac{m_1\\boldsymbol{r}_1 + m_2\\boldsymbol{r}_2}{m_1+m_2} = \\frac{(1)(10,1,0) + (1)(10,-1,0)}{2} = \\frac{(10+10, 1-1, 0+0)}{2} = \\frac{(20,0,0)}{2} = (10,0,0)\n$$\nThe approximate force, $\\boldsymbol{F}_{\\text{mono}}$, is the force exerted by this single point mass on the target particle:\n$$\n\\boldsymbol{F}_{\\text{mono}} = G \\frac{M m_0}{\\left\\lvert\\boldsymbol{R}_{\\text{cm}} - \\boldsymbol{r}_0\\right\\rvert^3} (\\boldsymbol{R}_{\\text{cm}} - \\boldsymbol{r}_0) = (1) \\frac{(2)m_0}{\\left\\lvert\\boldsymbol{R}_{\\text{cm}}\\right\\rvert^3} \\boldsymbol{R}_{\\text{cm}}\n$$\nThe magnitude of $\\boldsymbol{R}_{\\text{cm}}$ is $\\left\\lvert\\boldsymbol{R}_{\\text{cm}}\\right\\rvert = \\sqrt{10^2+0^2+0^2} = 10$.\n$$\n\\boldsymbol{F}_{\\text{mono}} = \\frac{2m_0}{10^3} (10,0,0) = \\frac{20m_0}{1000} (1,0,0) = \\frac{m_0}{50} (1,0,0) = \\left(\\frac{m_0}{50}, 0, 0\\right)\n$$\n\n**3. Relative Error**\n\nThe relative error $\\varepsilon$ is defined as $\\varepsilon \\equiv \\frac{\\left\\lvert \\boldsymbol{F}_{\\text{exact}}-\\boldsymbol{F}_{\\text{mono}}\\right\\rvert}{\\left\\lvert \\boldsymbol{F}_{\\text{exact}}\\right\\rvert}$.\n\nFirst, we find the difference vector:\n$$\n\\boldsymbol{F}_{\\text{exact}} - \\boldsymbol{F}_{\\text{mono}} = \\left(\\frac{20m_0}{101\\sqrt{101}} - \\frac{m_0}{50}\\right) (1,0,0) = m_0 \\left(\\frac{20}{101\\sqrt{101}} - \\frac{1}{50}\\right) (1,0,0)\n$$\nThe magnitude of this vector is:\n$$\n\\left\\lvert \\boldsymbol{F}_{\\text{exact}}-\\boldsymbol{F}_{\\text{mono}}\\right\\rvert = \\left\\lvert m_0 \\left(\\frac{20}{101\\sqrt{101}} - \\frac{1}{50}\\right) \\right\\rvert = m_0 \\left\\lvert \\frac{20 \\cdot 50 - 101\\sqrt{101}}{50 \\cdot 101\\sqrt{101}} \\right\\rvert\n$$\nWe note that $101\\sqrt{101} = \\sqrt{101^3} = \\sqrt{1030301} \\approx 1015.04$, while $20 \\cdot 50 = 1000$. Thus, the term inside the absolute value is negative.\n$$\n\\left\\lvert \\boldsymbol{F}_{\\text{exact}}-\\boldsymbol{F}_{\\text{mono}}\\right\\rvert = m_0 \\left(\\frac{1}{50} - \\frac{20}{101\\sqrt{101}}\\right)\n$$\nThe magnitude of the exact force is:\n$$\n\\left\\lvert \\boldsymbol{F}_{\\text{exact}}\\right\\rvert = \\left\\lvert \\frac{20m_0}{101\\sqrt{101}} (1,0,0) \\right\\rvert = \\frac{20m_0}{101\\sqrt{101}}\n$$\nNow we compute the ratio. The factor $m_0$ cancels.\n$$\n\\varepsilon = \\frac{m_0 \\left(\\frac{1}{50} - \\frac{20}{101\\sqrt{101}}\\right)}{\\frac{20m_0}{101\\sqrt{101}}} = \\frac{\\frac{1}{50}}{\\frac{20}{101\\sqrt{101}}} - 1 = \\frac{101\\sqrt{101}}{50 \\cdot 20} - 1 = \\frac{101\\sqrt{101}}{1000} - 1\n$$\nWe now compute the numerical value:\n$$\n\\varepsilon = \\frac{101\\sqrt{101}}{1000} - 1 \\approx \\frac{101 \\times 10.0498756}{1000} - 1 \\approx \\frac{1015.0374377}{1000} - 1 = 1.0150374377 - 1 = 0.0150374377\n$$\nRounding to four significant figures, we get $\\varepsilon \\approx 0.01504$.\n\nTo interpret this result, we compute the opening angle $\\theta=s/d$. The source particles are at $(10,1,0)$ and $(10,-1,0)$. The smallest axis-aligned box containing them has dimensions $\\Delta x=10-10=0$, $\\Delta y=1-(-1)=2$, $\\Delta z=0-0=0$. The cell size $s$ is the side length of the smallest bounding square, which is the maximum of these dimensions: $s = \\max(0,2,0) = 2$. The distance from the origin to the center of mass is $d = |\\boldsymbol{R}_{\\text{cm}}| = 10$.\nThe opening angle is $\\theta = s/d = 2/10 = 0.2$. The calculated value of $\\varepsilon \\approx 1.5\\%$ is the relative force error incurred when applying the monopole approximation for this specific geometry, which corresponds to an opening angle of $\\theta=0.2$. This is a typical level of accuracy for common choices of the Barnes-Hut opening angle criterion (e.g., $\\theta_{\\text{crit}}  0.5$).\nThe final requested answer is the numerical value of $\\varepsilon$.", "answer": "$$\n\\boxed{0.01504}\n$$", "id": "3501662"}, {"introduction": "A tree algorithm's performance depends not just on its physics approximations, but also on its computational efficiency in handling data. This exercise delves into Morton ordering, a powerful technique that maps 3D particle positions onto a 1D curve to dramatically improve data locality and enable efficient tree construction [@problem_id:3501689]. Implementing this \"Z-order\" space-filling curve demonstrates how memory layout can be optimized for the hierarchical nature of the N-body problem, a crucial step for high-performance computing.", "problem": "Consider $N$ point masses with positions $\\mathbf{x}_i \\in \\mathbb{R}^3$, $i \\in \\{0,1,\\dots,N-1\\}$, intended for use in a gravitational tree code following the Barnes–Hut paradigm. The construction of an octree can be accelerated by imposing a one-dimensional ordering of the leaves that preserves spatial locality. One common choice in numerical cosmology is the Z-ordering induced by $64$-bit Morton codes, which maps each $3$-dimensional point to a single integer key by interleaving the bits of fixed-precision integer representations of its coordinates. Starting from the definition of Newtonian gravity and the hierarchical multipole approximation that underlies Barnes–Hut, derive the need for a locality-preserving one-dimensional ordering of points in space as a prerequisite for efficient traversal and vectorized computation over contiguous blocks of leaves.\n\nYou must design and implement a complete program that, for each specified test case, performs the following steps in a scientifically sound and numerically consistent manner:\n\n1. Define a bounding cube for the set $\\{\\mathbf{x}_i\\}$ by letting $\\mathbf{m} = (\\min_i x_{i,0}, \\min_i x_{i,1}, \\min_i x_{i,2})$, $\\mathbf{M} = (\\max_i x_{i,0}, \\max_i x_{i,1}, \\max_i x_{i,2})$, and $L = \\max(M_0 - m_0, M_1 - m_1, M_2 - m_2)$. The cube is $[\\mathbf{m}, \\mathbf{m} + L \\mathbf{1}]$, where $\\mathbf{1}$ is the vector of ones. Normalize each position to the unit cube by $u_{i,k} = \\dfrac{x_{i,k} - m_k}{L}$ for $k \\in \\{0,1,2\\}$, with the convention that values equal to $1$ are replaced by the largest representable number strictly less than $1$ in double precision to avoid overflow in fixed-precision quantization.\n\n2. Quantize each normalized coordinate to a $21$-bit unsigned integer by $q_{i,k} = \\left\\lfloor u_{i,k} \\cdot 2^{21} \\right\\rfloor$, so that $q_{i,k} \\in \\{0,1,\\dots,2^{21}-1\\}$. Interleave the bits of $(q_{i,0},q_{i,1},q_{i,2})$ to form a $64$-bit Morton code $c_i \\in \\{0,1,\\dots,2^{64}-1\\}$, with the least significant bits of $c_i$ occupied by the least significant bits of $q_{i,0}$, $q_{i,1}$, and $q_{i,2}$ in that order, and so on for successive bit planes. Use a stable ordering for ties in $c_i$ (preserving the original index order for equal codes).\n\n3. Sort the particles by ascending $c_i$ to define the leaf order for the octree. Report the permutation $\\pi$ such that $c_{\\pi(0)} \\le c_{\\pi(1)} \\le \\dots \\le c_{\\pi(N-1)}$.\n\n4. To estimate the expected benefit for vectorized kernels that operate on contiguous leaves, compute the ratio\n$$\nR = \\frac{\\dfrac{1}{N-1}\\sum_{j=0}^{N-2} \\lVert \\mathbf{x}_{\\pi(j+1)} - \\mathbf{x}_{\\pi(j)} \\rVert_2}{\\dfrac{1}{N-1}\\sum_{j=0}^{N-2} \\lVert \\mathbf{x}_{j+1} - \\mathbf{x}_{j} \\rVert_2},\n$$\nwhich is dimensionless. The numerator measures average successive spatial separation in the Morton-sorted order, and the denominator measures average successive separation in the original input order. A smaller $R$ indicates tighter spatial locality in the sorted order and, therefore, greater expected efficiency from vectorized processing of contiguous memory segments.\n\nThe program must produce, for each test case, three outputs: the full list of sorted original indices $\\left[\\pi(0),\\pi(1),\\dots,\\pi(N-1)\\right]$; the first $8$ sorted Morton codes $\\left[c_{\\pi(0)},c_{\\pi(1)},\\dots,c_{\\pi(7)}\\right]$ (or fewer if $N8$); and the floating-point value $R$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a list of the form $\\left[ \\text{sorted\\_indices}, \\text{first\\_8\\_codes}, R \\right]$. All floating-point quantities must be printed as raw decimal numbers. No physical units are required because $R$ is dimensionless and the Morton codes are integers.\n\nTest Suite:\n- Test Case A (general case): $N=16$, positions\n$\\left[\n(0.1,0.1,0.1),(0.9,0.1,0.1),(0.1,0.9,0.1),(0.9,0.9,0.1),\n(0.1,0.1,0.9),(0.9,0.1,0.9),(0.1,0.9,0.9),(0.9,0.9,0.9),\n(0.5,0.5,0.5),(0.51,0.5,0.5),(0.5,0.51,0.5),(0.5,0.5,0.51),\n(0.2,0.8,0.2),(0.8,0.2,0.8),(0.2,0.2,0.8),(0.8,0.8,0.2)\n\\right]$.\n- Test Case B (clustered and mixed scales): $N=16$, positions\n$\\left[\n(0.02,0.03,0.01),(0.05,0.02,0.04),(0.03,0.04,0.02),(0.04,0.06,0.03),\n(0.95,0.96,0.97),(0.97,0.95,0.96),(0.96,0.97,0.95),(0.98,0.99,0.97),\n(0.52,0.51,0.53),(0.49,0.5,0.48),(0.6,0.6,0.6),(0.4,0.4,0.4),\n(0.2,0.2,0.2),(0.8,0.8,0.8),(0.75,0.78,0.76),(0.25,0.28,0.26)\n\\right]$.\n- Test Case C (boundary and near-boundary values): $N=16$, positions\n$\\left[\n(0.0,0.0,0.0),(1.0,1.0,1.0),(1e-12,0.0,0.0),(1.0 - 1e-12,1.0 - 1e-12,1.0 - 1e-12),\n(0.0,1.0,0.0),(1.0,0.0,1.0),(0.0,1.0,1.0),(1.0,0.0,0.0),\n(0.5,0.0,1.0),(0.0,0.5,1.0),(1.0,0.5,0.0),(0.5,1.0,0.0),\n(0.333333333,0.666666667,0.333333333),(0.666666667,0.333333333,0.666666667),\n(0.25,0.75,0.25),(0.75,0.25,0.75)\n\\right]$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the form\n$\\left[ \\left[ \\text{sorted\\_indices}_A, \\text{first\\_8\\_codes}_A, R_A \\right], \\left[ \\text{sorted\\_indices}_B, \\text{first\\_8\\_codes}_B, R_B \\right], \\left[ \\text{sorted\\_indices}_C, \\text{first\\_8\\_codes}_C, R_C \\right] \\right]$,\nwhere the subscript denotes the test case. All lists must use literal brackets and commas, and all integers and floats must be printed in their canonical decimal forms. The angle unit is not applicable to this problem, and no percentages are involved.", "solution": "The problem requires a derivation of the need for locality-preserving ordering in $N$-body simulations and the implementation of an algorithm to generate such an ordering using Morton codes.\n\n### Theoretical Derivation: From Newtonian Gravity to Morton Ordering\n\nThe fundamental challenge in simulating the gravitational interaction of $N$ point masses is computational complexity. The gravitational force $\\mathbf{F}_i$ on a mass $m_i$ at position $\\mathbf{x}_i \\in \\mathbb{R}^3$ due to all other masses $m_j$ at positions $\\mathbf{x}_j$ is given by Newton's law of universal gravitation:\n$$\n\\mathbf{F}_i = \\sum_{j=0, j \\neq i}^{N-1} G m_i m_j \\frac{\\mathbf{x}_j - \\mathbf{x}_i}{\\lVert \\mathbf{x}_j - \\mathbf{x}_i \\rVert^3}\n$$\nwhere $G$ is the gravitational constant. A direct summation of these pairwise forces for all $N$ particles requires approximately $N^2$ calculations, resulting in an algorithmic complexity of $O(N^2)$. This is computationally intractable for the large values of $N$ (often $10^6$ to $10^{12}$) used in modern numerical cosmology.\n\nTo overcome this, approximation methods like the Barnes–Hut algorithm are employed. The Barnes–Hut algorithm reduces the complexity to $O(N \\log N)$ by structuring the simulation domain hierarchically using a tree data structure, typically an octree in three dimensions. The space is recursively subdivided into eight cubic child cells (octants) until each leaf cell contains at most one particle.\n\nThe core principle of the Barnes-Hut algorithm is to approximate the gravitational force from a distant cluster of particles by treating the entire cluster as a single point mass located at its center of mass. The force calculation for a single particle $p$ involves traversing the octree from the root. For each node (cell) $C$ encountered, a decision is made based on the multipole acceptance criterion (MAC). A common form is the angle-based criterion:\n$$\n\\frac{s}{d}  \\theta\n$$\nwhere $s$ is the side length of the cell $C$, $d$ is the distance from particle $p$ to the center of mass of $C$, and $\\theta$ is a user-defined accuracy parameter (typically $0  \\theta  1$). If the inequality holds, the cell is sufficiently far away, and its contribution to the force on $p$ is approximated using a low-order multipole expansion (a monopole, i.e., the center of mass, in the simplest case). If the inequality does not hold, the cell is too close for an accurate approximation, and the traversal continues recursively into its child cells.\n\nWhile this hierarchical approach dramatically reduces the number of force calculations, it introduces new performance challenges related to memory access patterns. The tree traversal for each particle is data-dependent and irregular. Modern computer architectures achieve peak performance through vectorized operations (SIMD, Single Instruction, Multiple Data) and by exploiting data locality to minimize cache misses. An arbitrary or random storage order of particles in memory means that particles being processed sequentially are unlikely to be close in space. Consequently, when a small group of particles is processed in a vectorized manner, their respective force calculations will likely require traversing different paths through the octree. This divergence prevents effective vectorization and leads to poor cache utilization, as disparate parts of the tree data structure are loaded into cache for each particle.\n\nThis is where a locality-preserving one-dimensional ordering of particles becomes essential. The goal is to reorder the particle array such that particles that are close in the array are also likely to be close in three-dimensional space. This property can be achieved using a space-filling curve, which provides a continuous mapping from a higher-dimensional space ($\\mathbb{R}^3$) to a one-dimensional space ($\\mathbb{R}$). The Morton code, which generates a Z-order curve, is a common and effective choice. It is constructed by interleaving the bits of the integer representations of a particle's coordinates.\n\nSorting the particles based on their Morton codes has profound performance implications:\n1.  **Efficient Tree Construction**: A sorted list of particles can be used to build the octree efficiently, often in linear time, by leveraging the fact that particles within the same octree node will have Morton codes with a common high-order bit prefix.\n2.  **Enhanced Data Locality**: When the main particle array is sorted by Morton code, accessing one particle's data pre-fetches its spatially-proximate neighbors into the CPU cache, significantly reducing memory latency.\n3.  **Enabled Vectorization**: Most critically, a contiguous block of particles in the Morton-sorted array tends to be spatially localized. When calculating forces for this block, it is highly probable that all particles in the block will satisfy the MAC ($\\frac{s}{d}  \\theta$) for the same distant tree nodes. This allows for a vectorized tree traversal, where a single SIMD instruction can evaluate the MAC for multiple particles against a single node, and the subsequent force calculation can also be vectorized. This restores the ability to use the full power of modern processors.\n\nIn summary, the derivation proceeds as follows: the $O(N^2)$ complexity of Newtonian gravity necessitates the $O(N \\log N)$ Barnes–Hut approximation. The performance of Barnes–Hut is limited by irregular memory access during tree traversal. A locality-preserving sort, such as Morton ordering, restructures the primary data array to align memory layout with spatial proximity. This alignment is a critical prerequisite for enabling efficient cache usage and, most importantly, the vectorization of force computations, which is essential for high-performance $N$-body simulations.\n\n### Algorithmic Implementation\n\nThe program will implement the specified procedure to compute Morton codes and measure the resulting improvement in data locality.\n\n1.  **Normalization**: For a given set of $N$ positions $\\{\\mathbf{x}_i\\}$, we first compute the minimal bounding cube. This is defined by the corner $\\mathbf{m} = (\\min_i x_{i,0}, \\min_i x_{i,1}, \\min_i x_{i,2})$ and side length $L = \\max_k (\\max_i x_{i,k} - \\min_i x_{i,k})$. Each position $\\mathbf{x}_i$ is then normalized to the unit cube $[0, 1)^3$ via the transformation $u_{i,k} = (x_{i,k} - m_k) / L$. Any resulting normalized coordinate value exactly equal to $1.0$ is replaced by the largest double-precision floating-point number strictly less than $1.0$ to prevent overflow in the subsequent quantization step.\n\n2.  **Quantization**: Each normalized coordinate $u_{i,k} \\in [0, 1)$ is quantized to a $21$-bit unsigned integer $q_{i,k}$ using the formula $q_{i,k} = \\lfloor u_{i,k} \\cdot 2^{21} \\rfloor$. This maps the continuous coordinate to a discrete integer grid from $0$ to $2^{21}-1$.\n\n3.  **Morton Code Generation**: For each particle $i$, a $64$-bit Morton code $c_i$ is generated by interleaving the bits of its three $21$-bit quantized coordinates $(q_{i,0}, q_{i,1}, q_{i,2})$. The bit pattern of the resulting code will be $...b_{2,k}b_{1,k}b_{0,k}...b_{2,0}b_{1,0}b_{0,0}$, where $b_{j,k}$ is the $k$-th bit of coordinate $q_{i,j}$. This is done for $k$ from $0$ to $20$.\n\n4.  **Sorting**: The original particle indices are permuted according to a stable sort of the computed Morton codes $c_i$ in ascending order. This yields the permutation array $\\pi$, where $c_{\\pi(0)} \\le c_{\\pi(1)} \\le \\dots \\le c_{\\pi(N-1)}$.\n\n5.  **Locality Ratio Calculation**: To quantify the improvement in spatial locality, the ratio $R$ is computed:\n    $$\n    R = \\frac{\\frac{1}{N-1}\\sum_{j=0}^{N-2} \\lVert \\mathbf{x}_{\\pi(j+1)} - \\mathbf{x}_{\\pi(j)} \\rVert_2}{\\frac{1}{N-1}\\sum_{j=0}^{N-2} \\lVert \\mathbf{x}_{j+1} - \\mathbf{x}_{j} \\rVert_2}\n    $$\n    This ratio compares the average Euclidean distance between successive particles in the Morton-sorted order (numerator) to that of the original input order (denominator). A value of $R  1$ indicates that the Morton ordering has successfully grouped particles closer together in memory, suggesting a potential for improved computational performance. The program will compute the permutation $\\pi$, the first 8 sorted Morton codes, and the ratio $R$ for each provided test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    \n    test_cases = [\n        # Test Case A (general case)\n        np.array([\n            (0.1, 0.1, 0.1), (0.9, 0.1, 0.1), (0.1, 0.9, 0.1), (0.9, 0.9, 0.1),\n            (0.1, 0.1, 0.9), (0.9, 0.1, 0.9), (0.1, 0.9, 0.9), (0.9, 0.9, 0.9),\n            (0.5, 0.5, 0.5), (0.51, 0.5, 0.5), (0.5, 0.51, 0.5), (0.5, 0.5, 0.51),\n            (0.2, 0.8, 0.2), (0.8, 0.2, 0.8), (0.2, 0.2, 0.8), (0.8, 0.8, 0.2)\n        ]),\n        # Test Case B (clustered and mixed scales)\n        np.array([\n            (0.02, 0.03, 0.01), (0.05, 0.02, 0.04), (0.03, 0.04, 0.02), (0.04, 0.06, 0.03),\n            (0.95, 0.96, 0.97), (0.97, 0.95, 0.96), (0.96, 0.97, 0.95), (0.98, 0.99, 0.97),\n            (0.52, 0.51, 0.53), (0.49, 0.5, 0.48), (0.6, 0.6, 0.6), (0.4, 0.4, 0.4),\n            (0.2, 0.2, 0.2), (0.8, 0.8, 0.8), (0.75, 0.78, 0.76), (0.25, 0.28, 0.26)\n        ]),\n        # Test Case C (boundary and near-boundary values)\n        np.array([\n            (0.0, 0.0, 0.0), (1.0, 1.0, 1.0), (1e-12, 0.0, 0.0), (1.0 - 1e-12, 1.0 - 1e-12, 1.0 - 1e-12),\n            (0.0, 1.0, 0.0), (1.0, 0.0, 1.0), (0.0, 1.0, 1.0), (1.0, 0.0, 0.0),\n            (0.5, 0.0, 1.0), (0.0, 0.5, 1.0), (1.0, 0.5, 0.0), (0.5, 1.0, 0.0),\n            (0.333333333, 0.666666667, 0.333333333), (0.666666667, 0.333333333, 0.666666667),\n            (0.25, 0.75, 0.25), (0.75, 0.25, 0.75)\n        ])\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_particles(case)\n        results.append(result)\n    \n        # Format the final output string according to the problem specification.\n        # str(list) produces the required format '[item1, item2, ...]'\n        formatted_case_results = [f\"[{str(pi.tolist())}, {str(codes.tolist())}, {r}]\" for pi, codes, r in results]\n    final_output_str = f\"[{','.join(formatted_case_results)}]\"\n    print(final_output_str)\n\n\ndef get_morton_code(quantized_coords):\n    \"\"\"\n    Computes the 64-bit Morton code for a 3D point with 21-bit integer coordinates.\n    \"\"\"\n    q0, q1, q2 = quantized_coords\n    code = np.uint64(0)\n    for i in range(21):\n        # Extract i-th bit from each coordinate\n        b0 = (q0  i)  1\n        b1 = (q1  i)  1\n        b2 = (q2  i)  1\n            \n        # Interleave bits into the code. The bit pattern becomes ...q2_i q1_i q0_i...\n        code |= np.uint64(b0)  np.uint64(3 * i + 0)\n        code |= np.uint64(b1)  np.uint64(3 * i + 1)\n        code |= np.uint64(b2)  np.uint64(3 * i + 2)\n    return code\n\n\ndef process_particles(positions):\n    \"\"\"\n    Performs the full Morton ordering and analysis pipeline for a set of particle positions.\n    \"\"\"\n    N = len(positions)\n        \n    # 1. Define bounding cube and normalize positions\n    m = np.min(positions, axis=0)\n    M = np.max(positions, axis=0)\n    L = np.max(M - m)\n    if L == 0: L = 1.0 # Avoid division by zero if all points are identical\n        \n    normalized_pos = (positions - m) / L\n        \n    # Handle the edge case where a normalized coordinate is exactly 1.0\n    # Replace it with the largest representable double-precision number less than 1.0\n    val_at_1 = np.nextafter(1.0, 0.0)\n    normalized_pos[normalized_pos = 1.0] = val_at_1\n\n    # 2. Quantize normalized coordinates to 21-bit unsigned integers\n    scale_factor = 2**21\n    quantized_pos = np.floor(normalized_pos * scale_factor).astype(np.uint64)\n        \n    # 3. Compute Morton codes for all particles\n    morton_codes = np.array([get_morton_code(q_pos) for q_pos in quantized_pos], dtype=np.uint64)\n        \n    # 4. Sort particles by Morton code to get the permutation pi\n    # Use a stable sort to handle ties deterministically, as required.\n    pi = np.argsort(morton_codes, kind='stable')\n    sorted_morton_codes = morton_codes[pi]\n        \n    # 5. Compute the locality ratio R\n    if N  1:\n        sorted_positions = positions[pi]\n            \n        # Numerator: average successive distance in sorted order\n        diff_sorted = sorted_positions[1:] - sorted_positions[:-1]\n        sum_dist_sorted = np.sum(np.linalg.norm(diff_sorted, axis=1))\n            \n        # Denominator: average successive distance in original order\n        diff_original = positions[1:] - positions[:-1]\n        sum_dist_original = np.sum(np.linalg.norm(diff_original, axis=1))\n            \n        if sum_dist_original == 0:\n            # This can happen if all points are at the same location or N=2 and points are same.\n            R = 1.0 if sum_dist_sorted == 0 else np.inf\n        else:\n            R = sum_dist_sorted / sum_dist_original\n    else:\n        R = 1.0 # Or undefined, but 1.0 is a neutral choice.\n            \n    # Prepare outputs\n    sorted_indices = pi\n    first_8_codes = sorted_morton_codes[:8]\n        \n    return sorted_indices, first_8_codes, R\n    \nsolve()\n```", "id": "3501689"}, {"introduction": "Having explored the core physics approximation and a key data structuring technique, you will now simulate the full decision-making process of a Barnes-Hut tree walk. This capstone exercise requires you to traverse a pre-defined octree, applying the opening-angle criterion at each node to decide whether to use a monopole approximation or resolve the interaction further [@problem_id:3501671]. This practice solidifies your understanding of how the algorithm dynamically balances accuracy and computational cost for each particle interaction.", "problem": "In a collisionless gravitating system evolved in dimensionless code units, consider computing the gravitational acceleration on a target test particle using a Barnes–Hut (BH) tree approximation. The gravitational constant is $G=1$. The computational domain is a cube with side length $8$ spanning coordinates $[0,8]$ in each dimension. The root node (cell) has geometric center at $(4,4,4)$ and side length $w_0=8$, and is subdivided into $8$ octants of side length $4$ with geometric centers at the usual $(2,2,2)$, $(6,2,2)$, $(2,6,2)$, $(6,6,2)$, $(2,2,6)$, $(6,2,6)$, $(2,6,6)$, $(6,6,6)$. The octree is constructed by recursively subdividing any occupied node until every leaf contains at most $1$ particle.\n\nThe $N$-body system contains the following particles with positions $\\mathbf{r}_i$ and masses $m_i$:\n- One particle at $(7,1,1)$ with mass $m=2$ in the octant centered at $(6,2,2)$.\n- One particle at $(1,7,1)$ with mass $m=3$ in the octant centered at $(2,6,2)$.\n- One particle at $(1,1,7)$ with mass $m=4$ in the octant centered at $(2,2,6)$.\n- Three particles forming a compact group inside the octant centered at $(6,6,6)$ with side length $4$, located at $(5.5,5.5,5.5)$ with mass $m=1$, at $(6.5,6.0,6.0)$ with mass $m=1.5$, and at $(6.0,6.5,6.0)$ with mass $m=2$. This octant is further subdivided until each of these three particles resides alone in a leaf.\n\nA target test particle (not included among the above six) is located at $\\mathbf{r}_{\\mathrm{t}}=(1,1,1)$. Using the standard Barnes–Hut opening-angle criterion, accept an internal node of side length $w$ and center-of-mass position $\\mathbf{R}_{\\mathrm{com}}$ if\n$$\n\\frac{w}{|\\mathbf{r}_{\\mathrm{t}}-\\mathbf{R}_{\\mathrm{com}}|} \\le \\theta,\n$$\nwith opening angle $\\theta=0.5$. If an internal node is not accepted, descend to its children. If a leaf node is reached that does not contain the target, compute its particle’s direct contribution. For any accepted internal node, approximate its contribution by a monopole located at its center of mass with total mass equal to the sum of its constituent particle masses. Ignore any self-interaction; no gravitational softening is used.\n\nStarting from Newton’s law of gravitation and the above tree-walk rules, traverse the tree to compute the total gravitational acceleration on the target by summing the accepted node monopole contributions and the direct leaf interactions. Use $G=1$, and express the final acceleration vector as a row matrix $\\begin{pmatrix}a_x  a_y  a_z\\end{pmatrix}$ in code units. Round your final numerical answer to four significant figures. Angles are not involved.", "solution": "The problem asks for the gravitational acceleration on a target test particle using the Barnes-Hut (BH) tree approximation. I will first validate the problem statement and, if it is valid, proceed to a full solution.\n\n### Step 1: Extract Givens\n- **Gravitational constant:** $G=1$.\n- **Computational Domain:** Cube with side length $L=8$, coordinates in $[0,8]$ for each dimension.\n- **Root Node:** Geometric center at $(4,4,4)$, side length $w_0=8$.\n- **Octree Construction:** Recursive subdivision of occupied nodes until each leaf contains at most $1$ particle.\n- **Particle Data:**\n  - Particle 1: $\\mathbf{r}_1=(7,1,1)$, $m_1=2$.\n  - Particle 2: $\\mathbf{r}_2=(1,7,1)$, $m_2=3$.\n  - Particle 3: $\\mathbf{r}_3=(1,1,7)$, $m_3=4$.\n  - Particle 4: $\\mathbf{r}_4=(5.5,5.5,5.5)$, $m_4=1$.\n  - Particle 5: $\\mathbf{r}_5=(6.5,6.0,6.0)$, $m_5=1.5$.\n  - Particle 6: $\\mathbf{r}_6=(6.0,6.5,6.0)$, $m_6=2$.\n- **Target Particle:** Position $\\mathbf{r}_{\\mathrm{t}}=(1,1,1)$.\n- **BH Opening-Angle Criterion:** An internal node of side length $w$ and center of mass $\\mathbf{R}_{\\mathrm{com}}$ is accepted if $\\frac{w}{|\\mathbf{r}_{\\mathrm{t}}-\\mathbf{R}_{\\mathrm{com}}|} \\le \\theta$, with the opening angle $\\theta=0.5$.\n- **Interaction Rules:**\n  - If a node is accepted, its contribution is that of a monopole with its total mass $M$ at its center of mass $\\mathbf{R}_{\\mathrm{com}}$.\n  - If an internal node is not accepted, descend to its children.\n  - If a leaf node is reached, compute the particle's direct contribution.\n- **Physics:** No gravitational softening is used.\n- **Output Requirement:** Express the final acceleration vector $\\begin{pmatrix}a_x  a_y  a_z\\end{pmatrix}$ with components rounded to four significant figures.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded in Newtonian mechanics and computational physics, specifically the well-established Barnes-Hut algorithm for N-body simulations. The setup is objectively described with precise numerical values and clear, unambiguous rules. All necessary data (particle masses and positions, domain geometry, BH parameter $\\theta$) are provided. The problem is self-contained, consistent, and well-posed, admitting a unique and verifiable solution through a deterministic application of the given rules. There are no contradictions, factual errors, or infeasible conditions.\n\n### Step 3: Verdict and Action\nThe problem is deemed valid. A full solution will be derived.\n\nThe gravitational acceleration $\\mathbf{a}$ exerted by a source of mass $M$ at position $\\mathbf{R}$ on the target particle at $\\mathbf{r}_{\\mathrm{t}}$ follows Newton's law of gravitation. With $G=1$, this is:\n$$\n\\mathbf{a} = \\frac{M (\\mathbf{R} - \\mathbf{r}_{\\mathrm{t}})}{|\\mathbf{R} - \\mathbf{r}_{\\mathrm{t}}|^3}\n$$\nThe total acceleration is the vector sum of contributions from all nodes as determined by the BH tree traversal. The target particle is at $\\mathbf{r}_{\\mathrm{t}}=(1,1,1)$.\n\nThe traversal begins at the root node of the octree.\n\n**Root Node Analysis:**\nThe root node encompasses the entire domain, with side length $w_0=8$. It contains all $N=6$ particles. We must first determine if this node can be approximated as a monopole.\nTotal mass of the system:\n$M_{\\mathrm{root}} = \\sum_{i=1}^{6} m_i = 2+3+4+1+1.5+2 = 13.5$.\nThe center of mass $\\mathbf{R}_{\\mathrm{root}}$ is:\n$\\mathbf{R}_{\\mathrm{root}} = \\frac{1}{M_{\\mathrm{root}}} \\sum_{i=1}^{6} m_i \\mathbf{r}_i$\n$\\sum m_i \\mathbf{r}_i = 2(7,1,1) + 3(1,7,1) + 4(1,1,7) + 1(5.5,5.5,5.5) + 1.5(6.5,6,6) + 2(6,6.5,6)$\n$= (14,2,2) + (3,21,3) + (4,4,28) + (5.5,5.5,5.5) + (9.75,9,9) + (12,13,12)$\n$= (48.25, 54.5, 59.5)$\n$\\mathbf{R}_{\\mathrm{root}} = \\frac{1}{13.5}(48.25, 54.5, 59.5) \\approx (3.574, 4.037, 4.407)$.\nThe distance from the target to the root's center of mass is:\n$|\\mathbf{r}_{\\mathrm{t}}-\\mathbf{R}_{\\mathrm{root}}| = |(1,1,1) - (3.574, 4.037, 4.407)| = |(-2.574, -3.037, -3.407)|$\n$= \\sqrt{(-2.574)^2 + (-3.037)^2 + (-3.407)^2} \\approx \\sqrt{6.626 + 9.223 + 11.608} = \\sqrt{27.457} \\approx 5.240$.\nApplying the opening-angle criterion:\n$\\frac{w_0}{|\\mathbf{r}_{\\mathrm{t}}-\\mathbf{R}_{\\mathrm{root}}|} = \\frac{8}{5.240} \\approx 1.527$.\nSince $1.527  \\theta=0.5$, the root node is not accepted. We must descend to its children, which are the $8$ octants of side length $w=4$. We consider only the four occupied octants.\n\n**Children of the Root Node (Octants with $w=4$):**\n\n1.  **Node containing P1:** This node corresponds to the octant $[4,8]\\times[0,4]\\times[0,4]$ and contains only particle P1 at $\\mathbf{r}_1=(7,1,1)$ with mass $m_1=2$. This node will be an internal node that is repeatedly subdivided until a leaf containing only P1 is created. The tree walk will continue to open these internal nodes until it reaches the leaf. For example, checking the first internal node (octant, w=4): its COM is $\\mathbf{R}_{\\mathrm{com}}=\\mathbf{r}_1$. The distance is $|\\mathbf{r}_{\\mathrm{t}}-\\mathbf{r}_1| = \\sqrt{(1-7)^2+(1-1)^2+(1-1)^2} = 6$. The criterion check is $\\frac{w}{|\\mathbf{r}_{\\mathrm{t}}-\\mathbf{r}_1|} = \\frac{4}{6} \\approx 0.667  0.5$. This node is not accepted, so we open it. This process continues until we reach the leaf node containing P1. Per the rules, the contribution from a leaf node is always computed directly.\n    $\\mathbf{a}_1 = \\frac{m_1(\\mathbf{r}_1-\\mathbf{r}_{\\mathrm{t}})}{|\\mathbf{r}_1-\\mathbf{r}_{\\mathrm{t}}|^3} = \\frac{2((7,1,1)-(1,1,1))}{6^3} = \\frac{2(6,0,0)}{216} = (\\frac{12}{216}, 0, 0) = (\\frac{1}{18}, 0, 0)$.\n\n2.  **Node containing P2:** This node corresponds to the octant $[0,4]\\times[4,8]\\times[0,4]$ and contains only P2 at $\\mathbf{r}_2=(1,7,1)$ with $m_2=3$. As with P1, the traversal will eventually reach the leaf node for P2, triggering a direct force calculation.\n    The distance is $|\\mathbf{r}_{\\mathrm{t}}-\\mathbf{r}_2| = \\sqrt{(1-1)^2+(1-7)^2+(1-1)^2} = 6$.\n    $\\mathbf{a}_2 = \\frac{m_2(\\mathbf{r}_2-\\mathbf{r}_{\\mathrm{t}})}{|\\mathbf{r}_2-\\mathbf{r}_{\\mathrm{t}}|^3} = \\frac{3((1,7,1)-(1,1,1))}{6^3} = \\frac{3(0,6,0)}{216} = (0, \\frac{18}{216}, 0) = (0, \\frac{1}{12}, 0)$.\n\n3.  **Node containing P3:** This node corresponds to the octant $[0,4]\\times[0,4]\\times[4,8]$ and contains only P3 at $\\mathbf{r}_3=(1,1,7)$ with $m_3=4$. Similarly, this interaction will resolve to a direct calculation.\n    The distance is $|\\mathbf{r}_{\\mathrm{t}}-\\mathbf{r}_3| = \\sqrt{(1-1)^2+(1-1)^2+(1-7)^2} = 6$.\n    $\\mathbf{a}_3 = \\frac{m_3(\\mathbf{r}_3-\\mathbf{r}_{\\mathrm{t}})}{|\\mathbf{r}_3-\\mathbf{r}_{\\mathrm{t}}|^3} = \\frac{4((1,1,7)-(1,1,1))}{6^3} = \\frac{4(0,0,6)}{216} = (0, 0, \\frac{24}{216}) = (0, 0, \\frac{1}{9})$.\n\n4.  **Node containing the group (P4, P5, P6):** This internal node corresponds to the octant $[4,8]\\times[4,8]\\times[4,8]$ with side length $w=4$. It contains three particles.\n    Total mass: $M_{\\mathrm{grp}} = m_4+m_5+m_6 = 1+1.5+2 = 4.5$.\n    Center of mass $\\mathbf{R}_{\\mathrm{grp}} = \\frac{1}{M_{\\mathrm{grp}}}(m_4\\mathbf{r}_4+m_5\\mathbf{r}_5+m_6\\mathbf{r}_6)$.\n    $m_4\\mathbf{r}_4+m_5\\mathbf{r}_5+m_6\\mathbf{r}_6 = 1(5.5,5.5,5.5) + 1.5(6.5,6.0,6.0) + 2(6.0,6.5,6.0)$\n    $= (5.5,5.5,5.5) + (9.75,9.0,9.0) + (12.0,13.0,12.0) = (27.25, 27.5, 26.5)$.\n    $\\mathbf{R}_{\\mathrm{grp}} = \\frac{1}{4.5}(27.25, 27.5, 26.5) = (\\frac{109}{18}, \\frac{55}{9}, \\frac{53}{9}) \\approx (6.0556, 6.1111, 5.8889)$.\n    The displacement vector and distance are:\n    $\\mathbf{d}_{\\mathrm{grp}} = \\mathbf{R}_{\\mathrm{grp}} - \\mathbf{r}_{\\mathrm{t}} = (\\frac{109}{18}-1, \\frac{55}{9}-1, \\frac{53}{9}-1) = (\\frac{91}{18}, \\frac{46}{9}, \\frac{44}{9}) \\approx (5.0556, 5.1111, 4.8889)$.\n    $|\\mathbf{d}_{\\mathrm{grp}}| = \\sqrt{(\\frac{91}{18})^2 + (\\frac{46}{9})^2 + (\\frac{44}{9})^2} = \\sqrt{25.5586 + 26.1235 + 23.9012} \\approx \\sqrt{75.5833} \\approx 8.6939$.\n    Criterion check: $\\frac{w}{|\\mathbf{d}_{\\mathrm{grp}}|} = \\frac{4}{8.6939} \\approx 0.4601 \\le 0.5$.\n    The criterion is met. This node is accepted and treated as a monopole.\n    $\\mathbf{a}_{\\mathrm{grp}} = \\frac{M_{\\mathrm{grp}}\\mathbf{d}_{\\mathrm{grp}}}{|\\mathbf{d}_{\\mathrm{grp}}|^3} = \\frac{4.5}{(8.6939)^3}(5.0556, 5.1111, 4.8889)$.\n    $|\\mathbf{d}_{\\mathrm{grp}}|^3 \\approx 657.07$.\n    $\\mathbf{a}_{\\mathrm{grp}} \\approx \\frac{4.5}{657.07}(5.0556, 5.1111, 4.8889) \\approx 0.0068485 (5.0556, 5.1111, 4.8889)$.\n    $\\mathbf{a}_{\\mathrm{grp}} \\approx (0.034621, 0.034999, 0.033480)$.\n\n**Total Acceleration:**\nThe total acceleration is the sum of the individual contributions:\n$\\mathbf{a}_{\\mathrm{total}} = \\mathbf{a}_1 + \\mathbf{a}_2 + \\mathbf{a}_3 + \\mathbf{a}_{\\mathrm{grp}}$.\n$\\mathbf{a}_1 = (\\frac{1}{18}, 0, 0) \\approx (0.055556, 0, 0)$.\n$\\mathbf{a}_2 = (0, \\frac{1}{12}, 0) \\approx (0, 0.083333, 0)$.\n$\\mathbf{a}_3 = (0, 0, \\frac{1}{9}) \\approx (0, 0, 0.111111)$.\nSumming the components:\n$a_x = \\frac{1}{18} + 0.034621 \\approx 0.055556 + 0.034621 = 0.090177$.\n$a_y = \\frac{1}{12} + 0.034999 \\approx 0.083333 + 0.034999 = 0.118332$.\n$a_z = \\frac{1}{9} + 0.033480 \\approx 0.111111 + 0.033480 = 0.144591$.\nThe total acceleration vector is approximately $(0.090177, 0.118332, 0.144591)$.\n\nRounding each component to four significant figures:\n$a_x \\approx 0.09018$.\n$a_y \\approx 0.1183$.\n$a_z \\approx 0.1446$.\nThe final result is presented as a row matrix as requested.", "answer": "$$\n\\boxed{\\begin{pmatrix} 0.09018  0.1183  0.1446 \\end{pmatrix}}\n$$", "id": "3501671"}]}