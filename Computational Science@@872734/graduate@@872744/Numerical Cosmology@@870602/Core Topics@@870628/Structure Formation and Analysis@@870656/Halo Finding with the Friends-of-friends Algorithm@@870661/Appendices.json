{"hands_on_practices": [{"introduction": "Before applying an algorithm to complex scientific data, it is imperative to verify its correctness using controlled test cases. This practice guides you through the process of validating a Friends-of-Friends (FoF) implementation against synthetic particle distributions, for which the outcome is known analytically. By deriving the expected number of halos on perfect lattices, jittered-glass configurations, and random Poisson sets, you will build a robust understanding of the interplay between the linking length parameter $b$ and the underlying particle geometry, developing essential skills in code verification and debugging. [@problem_id:3474766]", "problem": "You are tasked with designing unit tests that validate a Friends-of-Friends (FoF) halo finder in a periodic, cubic domain using synthetic point sets that mimic common numerical cosmology inputs. The FoF algorithm links two particles if their minimum-image separation is less than or equal to a linking length, and halos are defined as connected components under the transitive closure of this link relation. All distances in this problem are dimensionless and expressed in units of the cubic box side length, which is set to $L = 1$.\n\nFundamental base and definitions:\n- Consider $N$ particles in a periodic, cubic box with volume $V = L^3 = 1$.\n- The mean interparticle separation is defined by $l_{\\mathrm{bar}} = \\left(\\frac{V}{N}\\right)^{1/3} = N^{-1/3}$.\n- The FoF linking length is $l_{\\mathrm{link}} = b \\, l_{\\mathrm{bar}}$, where $b  0$ is a dimensionless control parameter.\n- Let $\\mathbf{x}_i \\in [0,1)^3$ denote the position of the $i$-th particle.\n- The minimum-image separation between two particles $i$ and $j$ is given by the Euclidean norm of the vector $\\Delta \\mathbf{x}_{ij}$ after mapping each coordinate difference $\\Delta x = x_j - x_i$ into the interval $[-\\frac{L}{2}, \\frac{L}{2})$ via $\\Delta x \\mapsto \\Delta x - L \\,\\left\\lfloor \\Delta x/L + \\frac{1}{2} \\right\\rfloor$. The particles $i$ and $j$ are said to be friends if $\\|\\Delta \\mathbf{x}_{ij}\\| \\le l_{\\mathrm{link}}$. A halo is the set of particles in a connected component of the graph built from the friendship relation. The FoF halo count $H$ is the number of connected components.\n\nSynthetic point sets to be tested:\n1. A homogeneous Poisson point set (uniform random positions) in the periodic box.\n2. A perfect cubic lattice of $n \\times n \\times n$ points with spacing $a = \\frac{L}{n}$, located at cell centers $\\left(\\frac{i + \\frac{1}{2}}{n}, \\frac{j + \\frac{1}{2}}{n}, \\frac{k + \\frac{1}{2}}{n}\\right)$.\n3. A glass-like configuration constructed as a jittered lattice with bounded displacements, defined by starting from the lattice positions and adding a deterministic, bounded, alternating offset $\\pm \\epsilon$ in each coordinate so that nearest-neighbor axis-aligned separations are no smaller than $a - 2\\epsilon$. This mimics a blue-noise or relaxed configuration with suppressed close pairs.\n\nYour program must:\n- Implement a FoF group finder in a periodic box using the minimum-image convention and $l_{\\mathrm{link}} = b \\, l_{\\mathrm{bar}}$.\n- Construct the synthetic point sets for each test case below.\n- For each test case, derive the expected FoF halo count $H_{\\mathrm{exp}}$ purely from geometric reasoning and the definitions above. The expected count for the Poisson cases must be derived from extreme parameter regimes where the outcome is deterministic: either $b = 0$ (no links) or $l_{\\mathrm{link}} \\ge \\frac{\\sqrt{3}}{2} L$ (every pair is linked by the minimum-image metric).\n- Compare the computed halo count $H_{\\mathrm{comp}}$ from your implementation with the derived $H_{\\mathrm{exp}}$ and report whether the test passes, i.e., whether $H_{\\mathrm{comp}} = H_{\\mathrm{exp}}$.\n\nTest suite and parameters:\nLet $L = 1$ throughout and use the exact parameters given. For the lattice, set $n$ so that $N = n^3$. For the glass, use the jitter construction with the specified $\\epsilon$.\n\n- Case 1 (Lattice, below-neighbor threshold): $n = 2$, so $N = 8$, $a = \\frac{1}{2}$, $b = 0.9$. Compute $l_{\\mathrm{link}} = b \\, l_{\\mathrm{bar}}$ with $l_{\\mathrm{bar}} = \\frac{1}{2}$. Derive $H_{\\mathrm{exp}}$.\n- Case 2 (Lattice, at-neighbor threshold boundary): $n = 2$, so $N = 8$, $a = \\frac{1}{2}$, $b = 1.0$. Compute $l_{\\mathrm{link}}$ as above. Derive $H_{\\mathrm{exp}}$.\n- Case 3 (Glass-like, below jitter threshold): $n = 3$, so $N = 27$, $a = \\frac{1}{3}$, $\\epsilon = 0.05$, $b = 0.6$. Compute $l_{\\mathrm{link}} = b \\, l_{\\mathrm{bar}}$ with $l_{\\mathrm{bar}} = \\frac{1}{3}$. Use the bound on nearest-neighbor separations to derive $H_{\\mathrm{exp}}$.\n- Case 4 (Glass-like, at jitter threshold boundary): $n = 3$, so $N = 27$, $a = \\frac{1}{3}$, $\\epsilon = 0.05$, choose $b$ such that $l_{\\mathrm{link}} = a - 2\\epsilon$. Derive $H_{\\mathrm{exp}}$ numerically from this equality.\n- Case 5 (Poisson, zero linking length): $N = 10$, $b = 0$. Derive $H_{\\mathrm{exp}}$.\n- Case 6 (Poisson, super-linking regime): $N = 10$, $b = 2.0$. Compute $l_{\\mathrm{link}}$ and compare to the maximum possible minimum-image separation $\\frac{\\sqrt{3}}{2}L$. Derive $H_{\\mathrm{exp}}$.\n\nAnswer specification:\n- For each case, compute a boolean indicating whether the computed halo count equals the derived expected count.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[True,False,True,True,False,True]\").\n\nScientific realism:\n- Use the minimum-image metric for periodic boundaries.\n- Use disjoint-set union (union-find) or equivalent to compute connected components under the FoF friendship relation.\n- For the Poisson cases, use deterministic regimes ($b = 0$ or $l_{\\mathrm{link}} \\ge \\frac{\\sqrt{3}}{2} L$) to ensure non-random expected outcomes.\n\nNo angles or physical units beyond the dimensionless distances are involved. All outputs are dimensionless and unit-free numbers or booleans. The final outputs must be booleans as specified above.", "solution": "The user has provided a problem that requires the validation of a Friends-of-Friends (FoF) halo finder using several synthetic particle distributions in a periodic cubic box. The task is to implement the FoF algorithm, derive the expected number of halos ($H_{\\mathrm{exp}}$) for each test case from first principles, and compare it with the computationally determined halo count ($H_{\\mathrm{comp}}$).\n\nFirst, the an algorithm for finding FoF halos in a periodic domain is required. The problem specifies a cubic box of side length $L=1$. The minimum-image convention must be used for calculating distances. A particle pair $(i, j)$ with positions $\\mathbf{x}_i, \\mathbf{x}_j$ is linked if their minimum-image separation $\\|\\Delta\\mathbf{x}_{ij}\\|$ is less than or equal to the linking length, $l_{\\mathrm{link}}$. A halo is a connected component in the graph defined by these links. An efficient way to implement this is to use a k-d tree data structure that supports periodic boundary conditions to find all pairs within the linking length, an $O(N \\log N)$ or better operation for typical distributions, which is superior to the naive $O(N^2)$ pair search. `scipy.spatial.cKDTree` provides this functionality. Once the linked pairs are identified, the connected components can be found using a Disjoint-Set Union (DSU) or Union-Find algorithm, which is highly efficient.\n\nThe core of the problem lies in analytically deriving the expected halo count, $H_{\\mathrm{exp}}$, for each of the six test cases.\n\n**Case 1: Lattice, below-neighbor threshold**\n- Parameters: A perfect cubic lattice of $n=2$ points per side, resulting in $N=n^3=8$ particles. The lattice spacing is $a=L/n=1/2$. The mean interparticle separation is $l_{\\mathrm{bar}} = N^{-1/3} = 8^{-1/3} = 1/2$. The linking parameter is $b=0.9$.\n- Linking Length: $l_{\\mathrm{link}} = b \\, l_{\\mathrm{bar}} = 0.9 \\times (1/2) = 0.45$.\n- Geometric Analysis: For a cubic lattice, the minimum separation between any two points is the axis-aligned nearest-neighbor distance, $a=0.5$. All other separations are larger (e.g., face diagonal $\\sqrt{2}a$, space diagonal $\\sqrt{3}a$).\n- Derivation: Since the linking length $l_{\\mathrm{link}} = 0.45$ is strictly less than the minimum particle separation $a=0.5$, no two particles can be linked. Each particle is isolated in its own halo.\n- Expected Halo Count: $H_{\\mathrm{exp}} = N = 8$.\n\n**Case 2: Lattice, at-neighbor threshold boundary**\n- Parameters: Same as Case 1, but with $b=1.0$.\n- Linking Length: $l_{\\mathrm{link}} = b \\, l_{\\mathrm{bar}} = 1.0 \\times (1/2) = 0.5$.\n- Geometric Analysis: The linking length is exactly equal to the nearest-neighbor distance, $l_{\\mathrm{link}} = a = 0.5$.\n- Derivation: Every particle will be linked to its six nearest neighbors (or fewer for edge cases, but in a periodic box, all have six neighbors). For example, the particle at $(1/4, 1/4, 1/4)$ is linked to $(3/4, 1/4, 1/4)$. This creates a graph where any particle can be reached from any other by traversing the links along the lattice axes. Consequently, all $8$ particles form a single connected component.\n- Expected Halo Count: $H_{\\mathrm{exp}} = 1$.\n\n**Case 3: Glass-like, below jitter threshold**\n- Parameters: A jittered lattice with $n=3$, $N=27$, $a=1/3$, $l_{\\mathrm{bar}}=1/3$. The jitter is a deterministic offset of $\\pm\\epsilon$ with $\\epsilon=0.05$. The linking parameter is $b=0.6$.\n- Linking Length: $l_{\\mathrm{link}} = b \\, l_{\\mathrm{bar}} = 0.6 \\times (1/3) = 0.2$.\n- Geometric Analysis: The glass-like configuration is built by taking a lattice point at index $(i,j,k)$ and displacing its coordinates by $(\\pm\\epsilon, \\pm\\epsilon, \\pm\\epsilon)$, with the sign depending on the parity of the index, e.g., offset in $x$ is $(-1)^i\\epsilon$. The minimum axis-aligned separation occurs between neighbors at indices like $(i,j,k)$ and $(i+1,j,k)$, where $i$ is even. The separation is $d_{min} = a - 2\\epsilon = 1/3 - 2(0.05) = 1/3 - 0.1 \\approx 0.2333$. Separations between non-axis-aligned neighbors are larger. Thus, the minimum separation between any two particles in this configuration is $a-2\\epsilon$.\n- Derivation: The linking length is $l_{\\mathrm{link}} = 0.2$. Since $l_{\\mathrm{link}}  d_{min}$, no two particles can be linked.\n- Expected Halo Count: $H_{\\mathrm{exp}} = N = 27$.\n\n**Case 4: Glass-like, at jitter threshold boundary**\n- Parameters: Same as Case 3, but $l_{\\mathrm{link}}$ is set to the minimum separation, $l_{\\mathrm{link}} = a - 2\\epsilon = 1/3 - 0.1 = 7/30 \\approx 0.2333$.\n- Derivation: Particles are linked if their separation is exactly $l_{\\mathrm{link}}$. This occurs for axis-aligned neighbors $(i,j,k)$ and $(i',j',k')$ where the displacement reduces their separation. A link exists along an axis, say $x$, between indices $i$ and $i+1$ if $i$ is even. With $n=3$ (indices $0,1,2$), links form between index pairs $(0,1)$, but not $(1,2)$ or $(2,0)_{\\text{periodic}}$. This partitions the set of indices $\\{0,1,2\\}$ into $\\{0,1\\}$ and $\\{2\\}$. A particle belongs to a component based on which partition its indices $(i,j,k)$ belong to.\n- Components are formed based on the cartesian product of these index partitions:\n  1. $\\{0,1\\}^3$: $2^3=8$ particles, all interconnected, forming 1 halo.\n  2. $\\{2\\}\\times\\{0,1\\}^2$: $1\\times2^2=4$ particles, all interconnected, forming 1 halo. By symmetry, there are 3 such halos (for $i=2$, $j=2$, $k=2$).\n  3. $\\{2\\}^2\\times\\{0,1\\}$: $1^2\\times2=2$ particles, linked, forming 1 halo. By symmetry, there are 3 such halos.\n  4. $\\{2\\}^3$: $1^3=1$ particle, isolated, forming 1 halo.\n- Total halos: $1 + 3 + 3 + 1 = 8$.\n- Expected Halo Count: $H_{\\mathrm{exp}} = 8$.\n\n**Case 5: Poisson, zero linking length**\n- Parameters: A uniform random (Poisson) distribution of $N=10$ particles, with $b=0$.\n- Linking Length: $l_{\\mathrm{link}} = 0$.\n- Derivation: Particles are linked only if their separation is $0$. For a continuous random distribution, the probability of any two particles occupying the exact same position is zero. Therefore, no links are formed. Every particle is an isolated halo.\n- Expected Halo Count: $H_{\\mathrm{exp}} = N = 10$.\n\n**Case 6: Poisson, super-linking regime**\n- Parameters: A Poisson distribution of $N=10$ particles, with $b=2.0$.\n- Linking Length: $l_{\\mathrm{link}} = b \\, l_{\\mathrm{bar}} = 2.0 \\times 10^{-1/3} \\approx 2.0 / 2.154 \\approx 0.928$.\n- Geometric Analysis: The maximum possible separation between any two points in a periodic box of side $L=1$ under the minimum-image convention corresponds to a displacement vector of $(L/2, L/2, L/2)$. The distance is $d_{max} = \\sqrt{(1/2)^2 + (1/2)^2 + (1/2)^2} = \\sqrt{3/4} = \\sqrt{3}/2 \\approx 0.866$.\n- Derivation: The linking length $l_{\\mathrm{link}} \\approx 0.928$ is greater than the maximum possible separation $d_{max} \\approx 0.866$. This means that any pair of particles in the box will be linked, regardless of their positions. The entire set of particles forms a single, all-encompassing halo.\n- Expected Halo Count: $H_{\\mathrm{exp}} = 1$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial import cKDTree\n\ndef fof_finder(positions, l_link, L=1.0):\n    \"\"\"\n    Finds Friends-of-Friends halos in a periodic box.\n\n    Args:\n        positions (np.ndarray): Array of shape (N, 3) with particle positions.\n        l_link (float): The linking length.\n        L (float): The side length of the periodic cubic box.\n\n    Returns:\n        int: The number of halos found.\n    \"\"\"\n    N = positions.shape[0]\n    if N == 0:\n        return 0\n\n    # Use cKDTree for efficient periodic neighbor search.\n    # The 'boxsize' argument handles the minimum image convention correctly.\n    tree = cKDTree(positions, boxsize=L)\n    pairs = tree.query_pairs(r=l_link, p=2.0)  # p=2.0 for Euclidean distance\n\n    # Use a Disjoint-Set Union (DSU) or Union-Find algorithm\n    # to find connected components from the list of pairs.\n    parent = list(range(N))\n    \n    def find(i):\n        if parent[i] == i:\n            return i\n        parent[i] = find(parent[i])\n        return parent[i]\n\n    def union(i, j):\n        root_i = find(i)\n        root_j = find(j)\n        if root_i != root_j:\n            parent[root_i] = root_j\n\n    for i, j in pairs:\n        union(i, j)\n\n    # The number of halos is the number of unique roots in the DSU structure.\n    n_halos = len({find(i) for i in range(N)})\n    \n    return n_halos\n\ndef solve():\n    \"\"\"\n    Runs the full test suite and prints the final result.\n    \"\"\"\n    L = 1.0\n\n    test_cases = [\n        # Case 1: Lattice, below-neighbor threshold\n        {'type': 'lattice', 'n': 2, 'b': 0.9, 'H_exp': 8},\n        # Case 2: Lattice, at-neighbor threshold boundary\n        {'type': 'lattice', 'n': 2, 'b': 1.0, 'H_exp': 1},\n        # Case 3: Glass-like, below jitter threshold\n        {'type': 'glass', 'n': 3, 'epsilon': 0.05, 'b': 0.6, 'H_exp': 27},\n        # Case 4: Glass-like, at jitter threshold boundary\n        {'type': 'glass', 'n': 3, 'epsilon': 0.05, 'l_link_special': 'a-2e', 'H_exp': 8},\n        # Case 5: Poisson, zero linking length\n        {'type': 'poisson', 'N': 10, 'b': 0.0, 'H_exp': 10},\n        # Case 6: Poisson, super-linking regime\n        {'type': 'poisson', 'N': 10, 'b': 2.0, 'H_exp': 1},\n    ]\n\n    results = []\n    \n    # Use a fixed seed for reproducible Poisson distributions\n    np.random.seed(42)\n\n    for case in test_cases:\n        positions = None\n        l_link = 0.0\n\n        if case['type'] == 'lattice':\n            n = case['n']\n            N = n**3\n            l_bar = N**(-1/3.0)\n            l_link = case['b'] * l_bar\n            \n            indices = np.arange(n)\n            grid = np.meshgrid(indices, indices, indices, indexing='ij')\n            positions = (np.vstack([g.ravel() for g in grid]).T + 0.5) / n\n\n        elif case['type'] == 'glass':\n            n = case['n']\n            epsilon = case['epsilon']\n            N = n**3\n            a = L / n\n            \n            if 'l_link_special' in case and case['l_link_special'] == 'a-2e':\n                l_link = a - 2 * epsilon\n            else:\n                l_bar = N**(-1/3.0)\n                l_link = case['b'] * l_bar\n\n            indices = np.arange(n)\n            ii, jj, kk = np.meshgrid(indices, indices, indices, indexing='ij')\n            indices_flat = np.vstack([ii.ravel(), jj.ravel(), kk.ravel()]).T\n            \n            positions = np.zeros((N, 3))\n            for p_idx, (i, j, k) in enumerate(indices_flat):\n                pos_x = (i + 0.5) / n + epsilon * ((-1)**i)\n                pos_y = (j + 0.5) / n + epsilon * ((-1)**j)\n                pos_z = (k + 0.5) / n + epsilon * ((-1)**k)\n                positions[p_idx] = [pos_x, pos_y, pos_z]\n        \n        elif case['type'] == 'poisson':\n            N = case['N']\n            l_bar = N**(-1/3.0)\n            l_link = case['b'] * l_bar\n            \n            positions = np.random.rand(N, 3)\n\n        # Run the FoF finder and get the computed halo count\n        H_comp = fof_finder(positions, l_link, L)\n        \n        # Compare with the expected count and store the boolean result\n        results.append(H_comp == case['H_exp'])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3474766"}, {"introduction": "Cosmological simulations almost universally employ periodic boundary conditions to approximate an infinite universe without edge effects. This practice provides a focused exercise on correctly implementing the minimum image convention for distance calculations, a critical and often tricky aspect of such simulations. Using a deterministic particle configuration, you will investigate how the choice of linking length, $l_{\\mathrm{link}}$, determines whether a halo is correctly reconstructed across the box boundary or if distinct halos are spuriously merged, providing invaluable hands-on experience with the practical consequences of periodic geometry. [@problem_id:3474763]", "problem": "You are given a cubic, periodic simulation box of side length $L=1$ (dimensionless units, so all positions and distances are expressed in units of the box length). Consider halo finding with the Friends-of-Friends (FoF) algorithm, defined as follows: for a set of particles with positions $\\{\\mathbf{x}_i\\}$, connect two particles $i$ and $j$ with an edge if their separation $d_{ij}$ is less than or equal to a chosen linking length $l_\\mathrm{link}$. The FoF halos are the connected components of the resulting graph. Under periodic boundary conditions, distances must be computed using the minimum image convention: for each Cartesian component, use the displacement $\\delta_\\alpha = \\Delta_\\alpha - L \\cdot \\mathrm{round}(\\Delta_\\alpha / L)$ where $\\Delta_\\alpha$ is the naive difference in that component, and then use the Euclidean norm $d_{ij} = \\sqrt{\\delta_x^2 + \\delta_y^2 + \\delta_z^2}$.\n\nBuild a deterministic test in which one physical halo lies across the box edge and analyze how the choice of $l_\\mathrm{link}$ determines whether particles wrap and join correctly versus spuriously. Use the following fixed set of particle positions:\n- Across-edge physical halo $H_1$: six particles at\n  $(x,y,z) \\in \\{(0.98,0.5,0.5),(0.985,0.5,0.5),(0.99,0.5,0.5),(0.01,0.5,0.5),(0.015,0.5,0.5),(0.02,0.5,0.5)\\}$.\n  This halo is physically contiguous across the periodic boundary in the $x$-direction.\n- Distinct halos $H_2$ and $H_3$: three particles each at\n  $(x,y,z) \\in \\{(0.34,0.5,0.5),(0.35,0.5,0.5),(0.36,0.5,0.5)\\}$ and\n  $(x,y,z) \\in \\{(0.64,0.5,0.5),(0.65,0.5,0.5),(0.66,0.5,0.5)\\}$ respectively.\n\nImplement a Friends-of-Friends halo finder with periodic boundary conditions as described, using the closed-ball rule (i.e., link if $d_{ij} \\le l_\\mathrm{link}$). For the following test suite of linking lengths $l_\\mathrm{link}$, compute the number of halos (connected components) recovered by the algorithm:\n1. $l_\\mathrm{link} = 0.004$.\n2. $l_\\mathrm{link} = 0.010$.\n3. $l_\\mathrm{link} = 0.025$.\n4. $l_\\mathrm{link} = 0.280$.\n\nYour program must:\n- Use the minimum image convention to compute $d_{ij}$ under periodic boundary conditions.\n- Construct the FoF graph by connecting pairs with $d_{ij} \\le l_\\mathrm{link}$.\n- Return the count of connected components for each $l_\\mathrm{link}$ in the test suite.\n\nAnswer in dimensionless units (all lengths are measured in units of $L=1$). Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test suite (e.g., \"[result1,result2,result3,result4]\"). The outputs for each case must be integers representing the number of halos found. This test suite includes a general case, boundary conditions on $l_\\mathrm{link}$, and an edge case where $l_\\mathrm{link}$ equals the minimum inter-halo separation that causes a spurious merge across periodic wrapping.", "solution": "The problem requires the implementation and application of the Friends-of-Friends (FoF) halo-finding algorithm to a specified set of particles within a cubic, periodic simulation box. The objective is to determine the number of halos identified by the algorithm for a suite of different linking lengths, $l_\\mathrm{link}$. The solution is grounded in the principles of periodic distance calculation and graph-based clustering.\n\n1.  **Periodic Boundary Conditions and the Minimum Image Convention (MIC)**\n\nIn computational cosmology, simulations often employ a finite volume (typically a cube) with periodic boundary conditions (PBC) to represent a statistically homogeneous and isotropic universe, thereby avoiding spurious edge effects. Under PBC, a particle exiting the box through one face immediately re-enters through the opposite face. This necessitates a special distance metric. The standard Euclidean distance is inadequate as it fails to recognize that two particles on opposite sides of the box may be physically close.\n\nThe correct approach is the Minimum Image Convention (MIC). For a cubic box of side length $L$, the distance calculation between two particles at positions $\\mathbf{x}_i$ and $\\mathbf{x}_j$ is as follows. First, the naive displacement vector is computed: $\\mathbf{\\Delta} = \\mathbf{x}_i - \\mathbf{x}_j$. Each component of this vector, $\\Delta_\\alpha$ (where $\\alpha \\in \\{x, y, z\\}$), is then adjusted to find its shortest representation in the periodic space:\n$$\n\\delta_\\alpha = \\Delta_\\alpha - L \\cdot \\mathrm{round}\\left(\\frac{\\Delta_\\alpha}{L}\\right)\n$$\nThe `round` function maps its argument to the nearest integer. This operation effectively checks if the distance is shorter \"across the boundary\". The final MIC distance, $d_{ij}$, is the standard Euclidean norm of this corrected displacement vector, $\\mathbf{\\delta}$:\n$$\nd_{ij} = \\sqrt{\\delta_x^2 + \\delta_y^2 + \\delta_z^2}\n$$\nFor this problem, the box side length is specified as $L=1$.\n\n2.  **The Friends-of-Friends (FoF) Algorithm**\n\nThe FoF algorithm is a widely used method for identifying gravitationally bound structures (halos) in particle simulations. It is a type of single-linkage hierarchical clustering that can be described elegantly using graph theory:\n-   **Vertices**: Each particle in the simulation is treated as a vertex in a graph.\n-   **Edges**: An undirected edge is created between any two vertices $i$ and $j$ if their separation, $d_{ij}$ (computed using MIC), is less than or equal to a predefined linking length, $l_\\mathrm{link}$. That is, an edge exists if $d_{ij} \\le l_\\mathrm{link}$.\n-   **Halos**: The FoF halos are simply the connected components of the resulting graph. A connected component is a set of vertices where a path exists between any two vertices in the set, and no vertex in the set is connected to any vertex outside the set.\n\n3.  **Algorithmic Implementation and Analysis of Test Cases**\n\nThe implementation follows a clear procedure. For each given $l_\\mathrm{link}$, we analyze the connectivity of the $N=12$ particles defined in the problem.\na.  An $N \\times N$ adjacency matrix is constructed to represent the graph.\nb.  For every unique pair of particles $(i, j)$, the distance $d_{ij}$ is computed using the MIC with $L=1$.\nc.  If $d_{ij} \\le l_\\mathrm{link}$, an edge is recorded in the adjacency matrix.\nd.  A connected-components algorithm is then run on this matrix to count the number of disjoint subgraphs, which corresponds to the number of halos.\n\nThe particle set is designed to test the algorithm's behavior, particularly its handling of periodic boundaries and its sensitivity to $l_\\mathrm{link}$. The set comprises three intended physical halos: $H_1$, $H_2$, and $H_3$.\n-   **Intra-halo separations**: The particles forming $H_1$ create a chain across the periodic boundary in the $x$-direction, with the largest link distance being $d=0.02$ (between $x=0.99$ and $x=0.01$). The particles in $H_2$ and $H_3$ form simple chains with link distances of $d=0.01$.\n-   **Inter-halo separations**: The minimum distance between halos $H_2$ and $H_3$ is $d=0.28$. The minimum distance between $H_1$ and any other halo is $d=0.32$.\n\nWe now analyze the specific test cases:\n\n-   **Case 1: $l_\\mathrm{link} = 0.004$**\n    This linking length is smaller than the smallest consecutive particle separation in the entire dataset ($0.005$). As a result, no links are formed between any pair of particles. Each of the $12$ particles is isolated and is counted as its own halo.\n    Result: $12$ halos.\n\n-   **Case 2: $l_\\mathrm{link} = 0.010$**\n    This length is sufficient to link particles with separations up to $0.01$.\n    -   In $H_1$, the links with separation $0.005$ are formed, but the critical periodic link of $0.02$ is not bridged ($0.02 > 0.010$). This splits the intended $H_1$ halo into two separate groups: one with particles at $x \\in \\{0.98, 0.985, 0.99\\}$ and another at $x \\in \\{0.01, 0.015, 0.02\\}$. So $H_1$ is resolved as $2$ halos.\n    -   In both $H_2$ and $H_3$, the particle separations are $0.01$. Since $0.01 \\le l_\\mathrm{link}$, the particles in each group are successfully linked, forming one halo for each group.\n    The total number of halos is $2$ (from $H_1$) $+ 1$ (from $H_2$) $+ 1$ (from $H_3$) $= 4$.\n\n-   **Case 3: $l_\\mathrm{link} = 0.025$**\n    This length is now large enough to bridge all \"physical\" connections within the intended halos.\n    -   In $H_1$, the periodic link of $0.02$ is now bridged ($0.02 \\le 0.025$). All $6$ particles are connected into a single halo.\n    -   $H_2$ and $H_3$ each form a single halo as before.\n    -   The minimum inter-halo separation is $0.28$, which is greater than $l_\\mathrm{link}$, so no spurious merging between distinct halos occurs. This case correctly identifies the $3$ physically distinct groups.\n    The total number of halos is $1 + 1 + 1 = 3$.\n\n-   **Case 4: $l_\\mathrm{link} = 0.280$**\n    This linking length is intentionally chosen to be large enough to cause spurious catastrophic merging.\n    -   As with $l_\\mathrm{link} = 0.025$, all particles within each of $H_1, H_2, H_3$ are linked, so each forms a single group initially.\n    -   However, the minimum distance between $H_2$ and $H_3$ is exactly $0.28$ (between the particles at $x=0.36$ and $x=0.64$). Since $0.28 \\le 0.280$, the algorithm connects these two otherwise distinct halos, merging them into one large, spurious object.\n    -   $H_1$ remains separate since its minimum distance to any other particle ($0.32$) is greater than $l_\\mathrm{link}$.\n    The total number of halos is $1$ (from $H_1$) $+ 1$ (from the merged $H_2 \\cup H_3$) $= 2$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse.csgraph import connected_components\n\ndef solve():\n    \"\"\"\n    Implements a Friends-of-Friends (FoF) halo finder with periodic boundary\n    conditions and tests it on a predefined particle set and suite of\n    linking lengths.\n    \"\"\"\n    \n    # Define the physical parameters and particle positions from the problem statement.\n    L = 1.0\n    particles = np.array([\n        # H1: Across-edge physical halo (6 particles)\n        [0.98, 0.5, 0.5], [0.985, 0.5, 0.5], [0.99, 0.5, 0.5],\n        [0.01, 0.5, 0.5], [0.015, 0.5, 0.5], [0.02, 0.5, 0.5],\n        # H2: Distinct halo (3 particles)\n        [0.34, 0.5, 0.5], [0.35, 0.5, 0.5], [0.36, 0.5, 0.5],\n        # H3: Distinct halo (3 particles)\n        [0.64, 0.5, 0.5], [0.65, 0.5, 0.5], [0.66, 0.5, 0.5]\n    ])\n    num_particles = particles.shape[0]\n\n    # The problem specifies a test suite of linking lengths.\n    # This corresponds to the `test_cases` in the provided boilerplate.\n    test_cases = [0.004, 0.010, 0.025, 0.280]\n\n    results = []\n\n    def pbc_distance(pos1, pos2, box_size):\n        \"\"\"\n        Computes the Euclidean distance between two points in a periodic box\n        using the Minimum Image Convention (MIC).\n        \n        Args:\n            pos1 (np.ndarray): Position vector of the first particle.\n            pos2 (np.ndarray): Position vector of the second particle.\n            box_size (float): The side length of the cubic periodic box.\n            \n        Returns:\n            float: The MIC distance between the two particles.\n        \"\"\"\n        delta = pos1 - pos2\n        # Apply minimum image convention to each component of the vector\n        delta_mic = delta - box_size * np.round(delta / box_size)\n        return np.linalg.norm(delta_mic)\n\n    # Iterate through each linking length in the test suite\n    for l_link in test_cases:\n        # 1. Build the adjacency matrix for the graph of particles.\n        # An edge exists if the distance between two particles is = l_link.\n        adj_matrix = np.zeros((num_particles, num_particles), dtype=int)\n        for i in range(num_particles):\n            for j in range(i + 1, num_particles):\n                dist = pbc_distance(particles[i], particles[j], L)\n                if dist = l_link:\n                    adj_matrix[i, j] = 1\n                    adj_matrix[j, i] = 1\n        \n        # 2. Find the number of connected components in the graph.\n        # Each component corresponds to one FoF halo.\n        # We use scipy's optimized function for this standard graph problem.\n        n_halos, _ = connected_components(\n            csgraph=adj_matrix, \n            directed=False, \n            return_labels=True\n        )\n        results.append(n_halos)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3474763"}, {"introduction": "Modern cosmological simulations involve billions of particles, rendering serial computation entirely impractical and making parallelization an essential skill for the numerical cosmologist. This practice explores domain decomposition, a fundamental strategy for distributing the computational workload of the FoF algorithm across multiple processors. You will implement and compare a naive parallel scheme with industry-standard methods that use \"ghost zones\" to correctly identify halos spanning processor boundaries, gaining crucial insight into the challenges and solutions of high-performance scientific computing. [@problem_id:3474759]", "problem": "You are tasked with implementing and analyzing parallelization strategies for the Friends-of-Friends (FoF) algorithm in numerical cosmology. Consider a cubic simulation box of side length $L = 1$ with periodic boundary conditions in all three dimensions. There are $N$ particles at positions $\\mathbf{x}_i \\in [0,1)^3$, with $i \\in \\{0,1,\\dots,N-1\\}$. The Friends-of-Friends (FoF) algorithm defines an undirected graph on the particles where an edge $\\{i,j\\}$ exists if the periodic Euclidean distance $d_{\\mathrm{PBC}}(\\mathbf{x}_i,\\mathbf{x}_j) \\leq \\ell$, and a halo is a connected component of this graph. The linking length $\\ell$ is defined from first principles as $\\ell = b \\, \\bar{n}^{-1/3}$, where the mean number density $\\bar{n} = N / L^3$, and therefore with $L=1$ this gives $\\ell = b \\, N^{-1/3}$.\n\nThe box is decomposed into $p$ equal-width slab subdomains along the $x$-axis, with subdomain $s$ covering $x \\in [s/p,(s+1)/p)$ for $s \\in \\{0,1,\\dots,p-1\\}$. The decomposition is periodic, so subdomain $p-1$ is adjacent to subdomain $0$. You must implement three parallelization strategies and compare them to the globally correct FoF result:\n- Strategy $\\mathrm{Global}$: Construct the full FoF graph across all $N$ particles using the periodic distance $d_{\\mathrm{PBC}}$ and compute the number of halos as the number of connected components.\n- Strategy $\\mathrm{Naive}$: Partition particles by subdomain and construct FoF graphs independently within each subdomain using only particles whose $x$ coordinate lies in the subdomain interval. Count the total number of connected components summed over subdomains. No cross-subdomain links are considered.\n- Strategy $\\mathrm{Ghost}$: For each subdomain $s$, include all its local particles. Additionally include ghost particles from the two adjacent subdomains whose $x$ coordinate lies within a thickness $\\ell$ of the subdomain boundaries at $x = s/p$ and $x = (s+1)/p$, measured in the periodic $x$-axis metric. Within each subdomain, construct edges among the union of local and ghost particles, but record only edges involving at least one local particle of the subdomain so that the union of all subdomain edge sets over $s$ recovers cross-boundary links. Then compute the number of halos as the number of connected components on the $N$ original particles using the union of all recorded edges over subdomains.\n- Strategy $\\mathrm{Merge}$: Run local FoF independently within each subdomain as in $\\mathrm{Naive}$ to get within-subdomain edges. Then, for each adjacent subdomain pair $(s, (s+1) \\bmod p)$ including $(p-1, 0)$, add cross-boundary edges for any particle pair $(i,j)$ with $i$ in $s$ and $j$ in $(s+1) \\bmod p$ for which $d_{\\mathrm{PBC}}(\\mathbf{x}_i,\\mathbf{x}_j) \\leq \\ell$. Compute the number of halos as the number of connected components on the $N$ original particles using the union of within-subdomain and cross-boundary edges.\n\nAll distances must be computed using the periodic Euclidean metric: for $\\Delta \\mathbf{x} = \\mathbf{x}_i - \\mathbf{x}_j$, define the component-wise periodic displacement $\\Delta \\mathbf{x}_{\\mathrm{PBC}} = \\Delta \\mathbf{x} - \\mathrm{round}(\\Delta \\mathbf{x})$, and $d_{\\mathrm{PBC}}(\\mathbf{x}_i,\\mathbf{x}_j) = \\|\\Delta \\mathbf{x}_{\\mathrm{PBC}}\\|_2$. The domain assignment of a particle with coordinate $x$ is $s = \\lfloor x \\, p \\rfloor$ under left-inclusive, right-exclusive interval convention.\n\nYour program must compute, for each of the test cases below, the number of halos under the four strategies described above and output a single line aggregating the results for all test cases. The required final output format is a single line containing a list of lists with no spaces, where each inner list has the form $[\\mathrm{Global},\\mathrm{Naive},\\mathrm{Ghost},\\mathrm{Merge}]$ for that test case, for example $[[g_1,n_1,gh_1,m_1],[g_2,n_2,gh_2,m_2],\\dots]$.\n\nYou must use dimensionless units in this problem, with $L = 1$ and all coordinates and the linking length $\\ell$ expressed in the same unit. Angles are not involved. The only outputs are integers.\n\nImplement the program according to the following test suite, which is designed to probe correctness, boundary handling, and periodic wrap-around:\n\n- Test case $1$ (happy path, well-separated halos contained within subdomains):\n    - $N = 8$, $b = 0.30$, $p = 2$.\n    - Particle positions $\\mathbf{x}_i$:\n        - $\\mathbf{x}_0 = (0.20, 0.20, 0.20)$,\n        - $\\mathbf{x}_1 = (0.22, 0.20, 0.20)$,\n        - $\\mathbf{x}_2 = (0.20, 0.22, 0.20)$,\n        - $\\mathbf{x}_3 = (0.20, 0.20, 0.22)$,\n        - $\\mathbf{x}_4 = (0.70, 0.70, 0.70)$,\n        - $\\mathbf{x}_5 = (0.72, 0.70, 0.70)$,\n        - $\\mathbf{x}_6 = (0.70, 0.72, 0.70)$,\n        - $\\mathbf{x}_7 = (0.70, 0.70, 0.72)$.\n- Test case $2$ (boundary crossing between adjacent subdomains):\n    - $N = 10$, $b = 0.28$, $p = 3$.\n    - Particle positions $\\mathbf{x}_i$:\n        - $\\mathbf{x}_0 = (0.322, 0.200, 0.200)$,\n        - $\\mathbf{x}_1 = (0.345, 0.205, 0.200)$,\n        - $\\mathbf{x}_2 = (0.332, 0.220, 0.200)$,\n        - $\\mathbf{x}_3 = (0.318, 0.205, 0.220)$,\n        - $\\mathbf{x}_4 = (0.349, 0.220, 0.220)$,\n        - $\\mathbf{x}_5 = (0.550, 0.600, 0.600)$,\n        - $\\mathbf{x}_6 = (0.560, 0.600, 0.600)$,\n        - $\\mathbf{x}_7 = (0.550, 0.610, 0.600)$,\n        - $\\mathbf{x}_8 = (0.550, 0.600, 0.610)$,\n        - $\\mathbf{x}_9 = (0.560, 0.610, 0.610)$.\n- Test case $3$ (periodic wrap-around and transitive linking across a boundary):\n    - $N = 12$, $b = 0.25$, $p = 4$.\n    - Particle positions $\\mathbf{x}_i$:\n        - $\\mathbf{x}_0 = (0.990, 0.300, 0.300)$,\n        - $\\mathbf{x}_1 = (0.010, 0.300, 0.300)$,\n        - $\\mathbf{x}_2 = (0.985, 0.305, 0.300)$,\n        - $\\mathbf{x}_3 = (0.015, 0.295, 0.300)$,\n        - $\\mathbf{x}_4 = (0.990, 0.310, 0.295)$,\n        - $\\mathbf{x}_5 = (0.010, 0.290, 0.305)$,\n        - $\\mathbf{x}_6 = (0.240, 0.800, 0.800)$,\n        - $\\mathbf{x}_7 = (0.290, 0.800, 0.800)$,\n        - $\\mathbf{x}_8 = (0.340, 0.800, 0.800)$,\n        - $\\mathbf{x}_9 = (0.390, 0.800, 0.800)$,\n        - $\\mathbf{x}_{10} = (0.440, 0.800, 0.800)$,\n        - $\\mathbf{x}_{11} = (0.490, 0.800, 0.800)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets and with no spaces, where each element corresponds to one test case and is itself a list of four integers of the form $[\\mathrm{Global},\\mathrm{Naive},\\mathrm{Ghost},\\mathrm{Merge}]$. For example: $[[2,2,2,2],[2,3,2,2],[2,4,2,2]]$.", "solution": "The user has provided a problem that requires the implementation and comparison of four parallelization strategies for the Friends-of-Friends (FoF) halo-finding algorithm in a periodic cosmological simulation box.\n\n### Step 1: Extract Givens\n\n- **Simulation Box**: Cubic, side length $L = 1$, with periodic boundary conditions (PBC) in all three dimensions.\n- **Particles**: $N$ particles at positions $\\mathbf{x}_i \\in [0,1)^3$ for $i \\in \\{0, 1, \\dots, N-1\\}$.\n- **FoF Algorithm**: An undirected graph on the particles. An edge $\\{i,j\\}$ exists if the periodic Euclidean distance $d_{\\mathrm{PBC}}(\\mathbf{x}_i, \\mathbf{x}_j) \\leq \\ell$. A halo is a connected component of this graph.\n- **Linking Length**: $\\ell = b \\, \\bar{n}^{-1/3}$, where $\\bar{n} = N/L^3$. With $L=1$, this simplifies to $\\ell = b \\, N^{-1/3}$.\n- **Domain Decomposition**: The box is divided into $p$ equal-width slab subdomains along the $x$-axis. Subdomain $s \\in \\{0, 1, \\dots, p-1\\}$ covers $x \\in [s/p, (s+1)/p)$. The decomposition is periodic.\n- **Particle-to-Subdomain Assignment**: A particle with $x$-coordinate $x$ is in subdomain $s = \\lfloor x \\cdot p \\rfloor$.\n- **Periodic Distance Metric**: For $\\Delta \\mathbf{x} = \\mathbf{x}_i - \\mathbf{x}_j$, the component-wise periodic displacement is $\\Delta \\mathbf{x}_{\\mathrm{PBC}} = \\Delta \\mathbf{x} - \\mathrm{round}(\\Delta \\mathbf{x})$. The distance is $d_{\\mathrm{PBC}}(\\mathbf{x}_i, \\mathbf{x}_j) = \\|\\Delta \\mathbf{x}_{\\mathrm{PBC}}\\|_2$.\n- **Strategies to Implement**:\n    1.  **Global**: Full FoF graph on all $N$ particles using $d_{\\mathrm{PBC}}$.\n    2.  **Naive**: Independent FoF within each subdomain, summing the halo counts. No cross-subdomain links.\n    3.  **Ghost**: For each subdomain $s$, consider local particles plus ghost particles from adjacent subdomains within a distance $\\ell$ of the boundaries. Build an edge set from pairs involving at least one local particle. Compute connected components on the global graph with the union of all such edge sets.\n    4.  **Merge**: Run local FoF within each subdomain. Then, explicitly add cross-boundary edges between adjacent subdomains. Compute connected components on the resulting global graph.\n- **Output Format**: A single line containing a list of lists, with no spaces. Each inner list is $[\\mathrm{Global}, \\mathrm{Naive}, \\mathrm{Ghost}, \\mathrm{Merge}]$ for a given test case. Example: `[[g1,n1,gh1,m1],[g2,n2,gh2,m2],...]`.\n- **Test Cases**:\n    1.  $N = 8$, $b = 0.30$, $p = 2$. Particle positions $\\mathbf{x}_0, \\dots, \\mathbf{x}_7$ are provided.\n    2.  $N = 10$, $b = 0.28$, $p = 3$. Particle positions $\\mathbf{x}_0, \\dots, \\mathbf{x}_9$ are provided.\n    3.  $N = 12$, $b = 0.25$, $p = 4$. Particle positions $\\mathbf{x}_0, \\dots, \\mathbf{x}_{11}$ are provided.\n\n### Step 2: Validate Using Extracted Givens\n\n- **Scientifically Grounded**: The problem is set in the context of numerical cosmology, a subfield of astrophysics. The Friends-of-Friends (FoF) algorithm is a standard, widely used method for identifying dark matter halos in N-body simulations. The concepts of periodic boundary conditions, linking length, domain decomposition, and ghost zones are all fundamental and standard in computational physics and parallel scientific computing. The problem is firmly rooted in established scientific and computational principles.\n- **Well-Posed**: The problem is mathematically and algorithmically well-defined. The inputs (particle positions, parameters) are given. The construction rules for the graph in each of the four strategies are specified with sufficient precision to be implemented. The required output—the number of connected components of a graph—is a uniquely determinable quantity.\n- **Objective**: The problem statement is formal and quantitative. It is free of any subjectivity, opinion, or non-scientific claims. All definitions are precise.\n- **Flaw Checklist**:\n    1.  **Scientific/Factual Unsoundness**: None. The physics and computer science foundations are sound.\n    2.  **Non-Formalizable/Irrelevant**: The problem is highly formalizable and directly relevant to the stated topic.\n    3.  **Incomplete/Contradictory Setup**: All necessary data and definitions are provided. The definitions of the four strategies are distinct and internally consistent. For example, the `Ghost` strategy's rule to \"record only edges involving at least one local particle\" prevents the same cross-boundary link from being generated by both adjacent subdomains in a simple edge list, although for a DSU-based approach this distinction is less critical for correctness. The `Merge` strategy is also clearly specified as a two-phase process. There are no contradictions.\n    4.  **Unrealistic/Infeasible**: The particle numbers are small, making the problem computationally tractable for a test suite, which is realistic for this context. The parameters are reasonable.\n    5.  **Ill-Posed/Poorly Structured**: The problem is well-structured and leads to a unique, stable solution for each test case.\n    6.  **Pseudo-Profound/Trivial**: The problem is not trivial. It requires careful implementation of graph algorithms, geometric calculations with periodic boundaries, and the logic of domain decomposition. The comparison of the four strategies is conceptually meaningful.\n    7.  **Outside Scientific Verifiability**: The results are computationally verifiable.\n\n### Step 3: Verdict and Action\n\nThe problem is **valid** as it is scientifically grounded, well-posed, objective, and free of any of the invalidating flaws. A solution will be provided.\n\n### Solution\n\nThe core of this problem is to find the number of connected components in a graph. The vertices of the graph are the $N$ particles. The edges are defined by a proximity condition: two particles are \"friends\" (connected by an edge) if their distance is no more than a linking length $\\ell$. The halos are the connected components of this friendship graph. We will use a Disjoint Set Union (DSU) data structure, also known as a Union-Find data structure, to efficiently count these components.\n\n**Fundamental Concepts**\n\n1.  **Disjoint Set Union (DSU)**: This data structure maintains a collection of disjoint sets. It provides two primary operations: `find(i)`, which returns an identifier for the set containing element `i`, and `union(i, j)`, which merges the sets containing elements `i` and `j`. We will implement a DSU class where the number of disjoint sets can be queried at any time. Initially, each of the $N$ particles is in its own set. For every pair of friends found, we perform a `union` operation. The final number of halos is the number of disjoint sets remaining.\n\n2.  **Periodic Boundary Conditions (PBC)**: In a cubic box of side length $L=1$ with coordinates in $[0,1)$, the shortest distance vector component $\\Delta x_{\\mathrm{PBC}}$ between two points with coordinate difference $\\Delta x = x_1 - x_2$ is not simply $\\Delta x$, but accounts for \"wrapping around\" the box. The provided formula, $\\Delta x_{\\mathrm{PBC}} = \\Delta x - \\mathrm{round}(\\Delta x)$, correctly finds this shortest vector component. The total distance is the Euclidean norm of this vector: $d_{\\mathrm{PBC}} = \\sqrt{(\\Delta x_{\\mathrm{PBC}})^2 + (\\Delta y_{\\mathrm{PBC}})^2 + (\\Delta z_{\\mathrm{PBC}})^2}$.\n\n3.  **Linking Length**: The linking length is calculated as $\\ell = b \\cdot N^{-1/3}$, where $b$ is a dimensionless parameter (typically $\\approx 0.2$) and $N^{-1/3}$ is proportional to the mean inter-particle separation.\n\n**Implementation of the Four Strategies**\n\nFor each strategy, we will compute the number of halos for the given particle distributions. The `Global` strategy serves as the ground truth, while `Ghost` and `Merge` are parallelization schemes designed to reproduce the global result. `Naive` is a simplified, incorrect parallel scheme shown for comparison.\n\n1.  **Strategy `Global`**: This is the reference implementation.\n    - Initialize a DSU for all $N$ particles.\n    - Iterate through every unique pair of particles $(i, j)$ where $i  j$.\n    - Calculate the periodic distance $d_{\\mathrm{PBC}}(\\mathbf{x}_i, \\mathbf{x}_j)$.\n    - If $d_{\\mathrm{PBC}}(\\mathbf{x}_i, \\mathbf{x}_j) \\leq \\ell$, call `dsu.union(i, j)`.\n    - The result is the final number of sets in the DSU.\n\n2.  **Strategy `Naive`**: This strategy ignores all interactions across subdomain boundaries.\n    - First, partition the particles into $p$ subdomains based on their $x$-coordinate, $s_i = \\lfloor x_i \\cdot p \\rfloor$.\n    - Initialize a total halo count to zero.\n    - For each subdomain $s=0, \\dots, p-1$:\n        - Let $S_s$ be the set of indices of particles in this subdomain.\n        - If $S_s$ is not empty, perform a local FoF analysis on just these particles. This can be done by creating a new DSU for the $|S_s|$ particles, finding their connected components, and adding the count to the total.\n    - The result is the sum of halo counts from all subdomains. This method will overcount halos whenever a true halo is split by a subdomain boundary.\n\n3.  **Strategy `Ghost`**: This is a more sophisticated parallel strategy that uses ghost zones to correctly handle boundary-crossing halos.\n    - Initialize a single DSU for all $N$ particles.\n    - Partition particles into subdomains as before.\n    - For each subdomain $s=0, \\dots, p-1$:\n        - Identify its set of local particles, $S_s$.\n        - Identify a set of ghost particles, $G_s$. A particle $j$ from an adjacent subdomain is a ghost for $s$ if its periodic $x$-distance to one of $s$'s boundaries ($x=s/p$ or $x=(s+1)/p$) is less than or equal to $\\ell$.\n        - Consider the combined particle set $C_s = S_s \\cup G_s$.\n        - Iterate through all pairs $(i, j)$ in $C_s$ with $i  j$.\n        - Crucially, to satisfy the problem's constraint and avoid redundant work in a real parallel system, we only process the pair if at least one particle belongs to the local set $S_s$.\n        - If the pair $(i, j)$ meets this condition and $d_{\\mathrm{PBC}}(\\mathbf{x}_i, \\mathbf{x}_j) \\leq \\ell$, call `dsu.union(i, j)` on the *global* DSU.\n    - The result is the final number of sets in the global DSU. If implemented correctly, this will match the `Global` result.\n\n4.  **Strategy `Merge`**: This is an alternative parallel strategy. It first computes local halos and then merges them across boundaries.\n    - Initialize a single DSU for all $N$ particles.\n    - Partition particles into subdomains.\n    - **Phase 1 (Local FoF)**: For each subdomain $s$, iterate through all pairs of its local particles $(i, j)$. If $d_{\\mathrm{PBC}}(\\mathbf{x}_i, \\mathbf{x}_j) \\leq \\ell$, call `dsu.union(i, j)`.\n    - **Phase 2 (Merge)**: For each subdomain $s=0, \\dots, p-1$, consider it and its next neighbor, $s_{\\mathrm{next}} = (s+1) \\pmod p$. Iterate through all pairs $(i, j)$ where $i$ is in subdomain $s$ and $j$ is in $s_{\\mathrm{next}}$. If $d_{\\mathrm{PBC}}(\\mathbf{x}_i, \\mathbf{x}_j) \\leq \\ell$, call `dsu.union(i, j)`.\n    - The result is the final number of sets in the global DSU. This should also match the `Global` result.", "answer": "```python\nimport numpy as np\nimport math\n\nclass DSU:\n    \"\"\"Disjoint Set Union (Union-Find) data structure.\"\"\"\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.num_sets = n\n\n    def find(self, i):\n        if self.parent[i] == i:\n            return i\n        self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        root_i = self.find(i)\n        root_j = self.find(j)\n        if root_i != root_j:\n            self.parent[root_j] = root_i\n            self.num_sets -= 1\n            return True\n        return False\n\ndef pbc_distance_sq(pos1, pos2, box_size=1.0):\n    \"\"\"Calculates the squared periodic Euclidean distance.\"\"\"\n    delta = pos1 - pos2\n    delta -= np.round(delta / box_size) * box_size\n    return np.sum(delta**2)\n\ndef strategy_global(N, positions, ell):\n    \"\"\"Global FoF strategy.\"\"\"\n    dsu = DSU(N)\n    ell_sq = ell**2\n    for i in range(N):\n        for j in range(i + 1, N):\n            if pbc_distance_sq(positions[i], positions[j]) = ell_sq:\n                dsu.union(i, j)\n    return dsu.num_sets\n\ndef strategy_naive(N, p, positions, ell):\n    \"\"\"Naive parallel FoF strategy.\"\"\"\n    ell_sq = ell**2\n    subdomain_particles = [[] for _ in range(p)]\n    for i in range(N):\n        s = math.floor(positions[i, 0] * p)\n        subdomain_particles[s].append(i)\n\n    total_halos = 0\n    for s in range(p):\n        particles_in_s = subdomain_particles[s]\n        k = len(particles_in_s)\n        if k == 0:\n            continue\n        \n        local_dsu = DSU(k)\n        # Map global particle index to local DSU index\n        global_to_local_map = {p_idx: i for i, p_idx in enumerate(particles_in_s)}\n\n        for i1_idx in range(k):\n            for i2_idx in range(i1_idx + 1, k):\n                p1 = particles_in_s[i1_idx]\n                p2 = particles_in_s[i2_idx]\n                if pbc_distance_sq(positions[p1], positions[p2]) = ell_sq:\n                    local_dsu.union(global_to_local_map[p1], global_to_local_map[p2])\n        total_halos += local_dsu.num_sets\n        \n    return total_halos\n\ndef strategy_ghost(N, p, positions, ell):\n    \"\"\"Ghost-zone based parallel FoF strategy.\"\"\"\n    dsu = DSU(N)\n    ell_sq = ell**2\n    \n    subdomain_particles = [[] for _ in range(p)]\n    for i in range(N):\n        s = math.floor(positions[i, 0] * p)\n        subdomain_particles[s].append(i)\n\n    for s in range(p):\n        local_particles_set = set(subdomain_particles[s])\n        \n        s_prev = (s - 1 + p) % p\n        s_next = (s + 1) % p\n        \n        left_boundary_x = s / p\n        right_boundary_x = (s + 1) / p\n        \n        ghost_particles_set = set()\n        \n        potential_ghosts = subdomain_particles[s_prev] + subdomain_particles[s_next]\n        for p_idx in potential_ghosts:\n            x_p = positions[p_idx, 0]\n            # Periodic distance to a point on a line\n            dist_left_x = abs(x_p - left_boundary_x)\n            pbc_dist_left_x = min(dist_left_x, 1.0 - dist_left_x)\n\n            dist_right_x = abs(x_p - right_boundary_x)\n            pbc_dist_right_x = min(dist_right_x, 1.0 - dist_right_x)\n\n            if pbc_dist_left_x = ell or pbc_dist_right_x = ell:\n                ghost_particles_set.add(p_idx)\n\n        combined_particles = list(local_particles_set.union(ghost_particles_set))\n        \n        k = len(combined_particles)\n        for i1_idx in range(k):\n            for i2_idx in range(i1_idx + 1, k):\n                p1 = combined_particles[i1_idx]\n                p2 = combined_particles[i2_idx]\n                \n                # Edge must involve at least one local particle\n                if p1 in local_particles_set or p2 in local_particles_set:\n                    if pbc_distance_sq(positions[p1], positions[p2]) = ell_sq:\n                        dsu.union(p1, p2)\n\n    return dsu.num_sets\n\n\ndef strategy_merge(N, p, positions, ell):\n    \"\"\"Merge-based parallel FoF strategy.\"\"\"\n    dsu = DSU(N)\n    ell_sq = ell**2\n    \n    subdomain_particles = [[] for _ in range(p)]\n    for i in range(N):\n        s = math.floor(positions[i, 0] * p)\n        subdomain_particles[s].append(i)\n\n    # Phase 1: Local FoF\n    for s in range(p):\n        particles_in_s = subdomain_particles[s]\n        k = len(particles_in_s)\n        for i1_idx in range(k):\n            for i2_idx in range(i1_idx + 1, k):\n                p1 = particles_in_s[i1_idx]\n                p2 = particles_in_s[i2_idx]\n                if pbc_distance_sq(positions[p1], positions[p2]) = ell_sq:\n                    dsu.union(p1, p2)\n\n    # Phase 2: Cross-boundary merge\n    for s in range(p):\n        s_next = (s + 1) % p\n        particles_s = subdomain_particles[s]\n        particles_s_next = subdomain_particles[s_next]\n        \n        for p1 in particles_s:\n            for p2 in particles_s_next:\n                if pbc_distance_sq(positions[p1], positions[p2]) = ell_sq:\n                    dsu.union(p1, p2)\n\n    return dsu.num_sets\n\n\ndef solve():\n    test_cases = [\n        # Test Case 1\n        {\n            \"N\": 8, \"b\": 0.30, \"p\": 2,\n            \"positions\": np.array([\n                [0.20, 0.20, 0.20], [0.22, 0.20, 0.20], [0.20, 0.22, 0.20], [0.20, 0.20, 0.22],\n                [0.70, 0.70, 0.70], [0.72, 0.70, 0.70], [0.70, 0.72, 0.70], [0.70, 0.70, 0.72]\n            ])\n        },\n        # Test Case 2\n        {\n            \"N\": 10, \"b\": 0.28, \"p\": 3,\n            \"positions\": np.array([\n                [0.322, 0.200, 0.200], [0.345, 0.205, 0.200], [0.332, 0.220, 0.200],\n                [0.318, 0.205, 0.220], [0.349, 0.220, 0.220], [0.550, 0.600, 0.600],\n                [0.560, 0.600, 0.600], [0.550, 0.610, 0.600], [0.550, 0.600, 0.610],\n                [0.560, 0.610, 0.610]\n            ])\n        },\n        # Test Case 3\n        {\n            \"N\": 12, \"b\": 0.25, \"p\": 4,\n            \"positions\": np.array([\n                [0.990, 0.300, 0.300], [0.010, 0.300, 0.300], [0.985, 0.305, 0.300],\n                [0.015, 0.295, 0.300], [0.990, 0.310, 0.295], [0.010, 0.290, 0.305],\n                [0.240, 0.800, 0.800], [0.290, 8.00e-01, 8.00e-01], [0.340, 0.800, 0.800],\n                [0.390, 0.800, 0.800], [0.440, 0.800, 0.800], [0.490, 0.800, 0.800]\n            ])\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        N, b, p, positions = case[\"N\"], case[\"b\"], case[\"p\"], case[\"positions\"]\n        ell = b * (N ** (-1/3.0))\n        \n        num_global = strategy_global(N, positions, ell)\n        num_naive = strategy_naive(N, p, positions, ell)\n        num_ghost = strategy_ghost(N, p, positions, ell)\n        num_merge = strategy_merge(N, p, positions, ell)\n        \n        all_results.append([num_global, num_naive, num_ghost, num_merge])\n\n    # Format the final output string as per requirements\n    result_str = \",\".join(str(r).replace(\" \", \"\") for r in all_results)\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "3474759"}]}