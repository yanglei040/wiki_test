{"hands_on_practices": [{"introduction": "At the heart of extracting the scalar component of cosmological perturbations lies the Poisson equation, $\\nabla^2 \\Phi = \\delta$. When solved in Fourier space, this equation presents a singularity at the zero-wavenumber mode, $\\mathbf{k}=\\mathbf{0}$, which requires careful handling. This first exercise [@problem_id:3485164] invites you to compare the physically-grounded approach of enforcing a zero-mean potential with a common numerical shortcut, an infrared regulator, allowing you to quantify how seemingly small implementation details can impact the largest observable scales in a simulation.", "problem": "Consider a periodic, cubic, comoving simulation box of side length $L$ and a discrete grid with $N$ points per dimension. Let $\\delta(\\mathbf{x})$ be a dimensionless scalar perturbation field defined on this grid. In the scalar, vector, and tensor perturbation decomposition used in numerical cosmology, the scalar sector can be represented by a scalar potential $\\Phi(\\mathbf{x})$ sourced by $\\delta(\\mathbf{x})$ through a Poisson-type relation. Adopt the following fundamental base:\n- The scalar potential $\\Phi(\\mathbf{x})$ is determined by a Poisson equation $\\nabla^2 \\Phi(\\mathbf{x}) = \\mathcal{S}\\,\\delta(\\mathbf{x})$ with periodic boundary conditions, where $\\mathcal{S}$ is a constant normalization factor. Since only relative comparisons are required, set $\\mathcal{S}=1$ to keep all quantities dimensionless.\n- On a periodic domain, the Fourier basis diagonalizes the Laplacian operator. Denote the discrete Fourier transform of $\\Phi(\\mathbf{x})$ as $\\Phi(\\mathbf{k})$ and of $\\delta(\\mathbf{x})$ as $\\delta(\\mathbf{k})$. Then, for each nonzero wavevector $\\mathbf{k}$, one has $-k^2 \\Phi(\\mathbf{k}) = \\delta(\\mathbf{k})$, where $k \\equiv \\lvert \\mathbf{k} \\rvert$. The zero mode $\\mathbf{k}=\\mathbf{0}$ is singular since $k^2=0$.\n- The Helmholtz decomposition in a periodic domain implies that adding a spatial constant to $\\Phi(\\mathbf{x})$ does not change the scalar gradient component. Therefore, the $\\mathbf{k}=\\mathbf{0}$ component of $\\Phi(\\mathbf{x})$ can be fixed by a gauge convention. Enforcing zero mean for $\\Phi(\\mathbf{x})$ sets $\\Phi(\\mathbf{k}=\\mathbf{0})=0$ and avoids the singularity at $\\mathbf{k}=\\mathbf{0}$.\n\nTwo numerical solvers are considered:\n- Zero-mean enforcement (physically correct for the scalar potential on a periodic box): set $\\delta(\\mathbf{k}=\\mathbf{0})=0$ (equivalently, subtract the spatial average of $\\delta(\\mathbf{x})$) and solve $\\Phi_0(\\mathbf{k}) = -\\delta(\\mathbf{k})/k^2$ for all nonzero $\\mathbf{k}$; set $\\Phi_0(\\mathbf{k}=\\mathbf{0})=0$.\n- Infrared-regularized solver (often used as a naive fix in practice): solve $\\Phi_\\epsilon(\\mathbf{k}) = -\\delta(\\mathbf{k})/(k^2+\\epsilon^2)$ for all $\\mathbf{k}$, with a small, positive, infrared regulator $\\epsilon$ (in units of inverse length). This removes the singularity but also alters long-wavelength modes.\n\nYour task is to write a complete program that:\n1. Constructs $\\delta(\\mathbf{x})$ on a three-dimensional grid as independent, identically distributed, zero-mean Gaussian random variates of unit variance with a deterministic pseudorandom seed. Then, add a specified constant offset to $\\delta(\\mathbf{x})$ (possibly zero) to model a nonzero mean density contrast when indicated.\n2. Computes the discrete Fourier transforms and the corresponding wavevectors consistent with a periodic box of side $L$, using the angular convention $k_i = 2\\pi n_i/L$ with $n_i \\in \\{-\\lfloor N/2 \\rfloor,\\dots, \\lfloor(N-1)/2\\rfloor\\}$.\n3. Implements both solvers above to obtain $\\Phi_0(\\mathbf{k})$ and $\\Phi_\\epsilon(\\mathbf{k})$. For the zero-mean enforcement, set $\\Phi_0(\\mathbf{k}=\\mathbf{0})=0$ and treat only $k>0$. For the infrared-regularized solver, apply the same formula at all $\\mathbf{k}$, including $\\mathbf{0}$.\n4. Quantifies the effect on long-wavelength modes by computing the shell-averaged fractional amplitude bias at the fundamental nonzero wavenumber magnitude $k_{\\min} = 2\\pi/L$. Define the fundamental shell as all modes with magnitude exactly $k_{\\min}$ on the discrete grid. Let the shell-averaged amplitude for a field $\\Phi(\\mathbf{k})$ be the square root of the average of $\\lvert \\Phi(\\mathbf{k}) \\rvert^2$ over that shell. Report the fractional bias\n$$\nB \\equiv \\frac{\\sqrt{\\langle \\lvert \\Phi_\\epsilon(\\mathbf{k}) \\rvert^2 \\rangle_{\\lvert \\mathbf{k} \\rvert = k_{\\min}}}}{\\sqrt{\\langle \\lvert \\Phi_0(\\mathbf{k}) \\rvert^2 \\rangle_{\\lvert \\mathbf{k} \\rvert = k_{\\min}}}} - 1,\n$$\nwhich is dimensionless. A negative $B$ indicates damping of long-wavelength amplitudes by the infrared regulator $\\epsilon$.\n5. Produces a single line of output containing the results for each test case as a comma-separated list enclosed in square brackets, with each $B$ rounded to $6$ decimal places. There are no physical units in this problem; all quantities are dimensionless. No angles are used.\n\nUse the following test suite, which varies the grid resolution $N$, the box size $L$, the pseudorandom seed, the constant offset added to $\\delta(\\mathbf{x})$, and the infrared regulator chosen as a multiple of the fundamental wavenumber $k_{\\min}$:\n- Test case $1$ (happy path with nonzero mean and moderate infrared regularization): $N=32$, $L=1.0$, seed $=1234$, offset $=0.2$, $\\epsilon = 0.5\\,k_{\\min}$.\n- Test case $2$ (zero mean and weak infrared regularization): $N=24$, $L=1.0$, seed $=1$, offset $=0.0$, $\\epsilon = 0.1\\,k_{\\min}$.\n- Test case $3$ (zero mean and strong infrared regularization, probing a boundary-like case): $N=24$, $L=1.0$, seed $=42$, offset $=0.0$, $\\epsilon = 1.0\\,k_{\\min}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result1,result2,result3]$), where each entry is the scalar value of $B$ for the corresponding test case, rounded to $6$ decimal places.", "solution": "The problem asks us to quantify the effect of an infrared regularization scheme when solving the Poisson equation on a periodic grid, a common task in numerical cosmology. We are to compare two methods: a physically-motivated zero-mean enforcement and a numerically convenient infrared-regularized solver. The comparison is made by computing a fractional bias $B$ for the amplitudes of the longest-wavelength modes.\n\nThe core of the problem lies in solving the Poisson equation $\\nabla^2 \\Phi(\\mathbf{x}) = \\delta(\\mathbf{x})$ on a periodic domain of side length $L$. In Fourier space, this equation becomes $-k^2 \\Phi(\\mathbf{k}) = \\delta(\\mathbf{k})$, where $\\mathbf{k}$ is the wavevector and $k = \\lvert \\mathbf{k} \\rvert$ is its magnitude. A singularity arises at the zero-mode, $\\mathbf{k}=\\mathbf{0}$, where $k^2 = 0$.\n\nThe problem presents two distinct approaches to handle this singularity.\n\n**Method 1: Zero-Mean Enforcement (Physically Correct)**\nThe potential $\\Phi$ is only defined up to an additive constant, as $\\nabla^2(\\Phi + C) = \\nabla^2\\Phi$. In a periodic domain, this freedom corresponds to the $\\mathbf{k}=\\mathbf{0}$ mode of the potential, $\\Phi(\\mathbf{k}=\\mathbf{0})$. A standard gauge choice is to set the spatial average of the potential to zero, which implies $\\Phi(\\mathbf{k}=\\mathbf{0})=0$. For the Poisson equation to be consistent under this gauge, the source term must also have a zero mean, which in Fourier space means $\\delta(\\mathbf{k}=\\mathbf{0})=0$. This is achieved by subtracting the mean value of $\\delta(\\mathbf{x})$ from the field before solving. The solution, which we denote $\\Phi_0(\\mathbf{k})$, is then:\n$$\n\\Phi_0(\\mathbf{k}) =\n\\begin{cases}\n    -\\frac{\\delta(\\mathbf{k}) - \\delta_{\\mathbf{k},\\mathbf{0}} \\delta(\\mathbf{k}=\\mathbf{0})}{k^2} & \\text{for } k > 0 \\\\\n    0 & \\text{for } k = 0\n\\end{cases}\n$$\nwhere $\\delta_{\\mathbf{k},\\mathbf{0}}$ is the Kronecker delta. This is equivalent to taking the input field $\\delta(\\mathbf{k})$, setting its $\\mathbf{k}=\\mathbf{0}$ component to zero, and then solving for $\\Phi(\\mathbf{k})$ using the standard formula, while explicitly setting $\\Phi(\\mathbf{k}=\\mathbf{0})=0$.\n\n**Method 2: Infrared-Regularized Solver (Numerical Fix)**\nA simpler, albeit less physically rigorous, method is to add a small positive term $\\epsilon^2$ to the denominator to regularize it. The solution, denoted $\\Phi_\\epsilon(\\mathbf{k})$, is given by:\n$$\n\\Phi_\\epsilon(\\mathbf{k}) = -\\frac{\\delta(\\mathbf{k})}{k^2 + \\epsilon^2}\n$$\nfor all $\\mathbf{k}$, including $\\mathbf{k}=\\mathbf{0}$. This avoids division by zero but modifies the solution at all scales, most significantly at small $k$ (long wavelengths).\n\n**Quantifying the Bias $B$**\nWe are asked to compute the fractional bias $B$ at the fundamental nonzero wavenumber, $k_{\\min} = 2\\pi/L$. This is the longest wavelength mode that fits into the box. The bias is defined as:\n$$\nB \\equiv \\frac{\\sqrt{\\langle \\lvert \\Phi_\\epsilon(\\mathbf{k}) \\rvert^2 \\rangle_{\\lvert \\mathbf{k} \\rvert = k_{\\min}}}}{\\sqrt{\\langle \\lvert \\Phi_0(\\mathbf{k}) \\rvert^2 \\rangle_{\\lvert \\mathbf{k} \\rvert = k_{\\min}}}} - 1\n$$\nLet's analyze this metric. The shell average $\\langle \\cdot \\rangle$ is over all modes $\\mathbf{k}$ such that $\\lvert\\mathbf{k}\\rvert = k_{\\min}$. For these modes, $k > 0$, so the term $\\delta_{\\mathbf{k},\\mathbf{0}}\\delta(\\mathbf{k}=\\mathbf{0})$ in the expression for $\\Phi_0(\\mathbf{k})$ is zero. Therefore, $\\Phi_0(\\mathbf{k}) = -\\delta(\\mathbf{k}) / k_{\\min}^2$ for all modes on this shell. The corresponding expression for the regularized solver is $\\Phi_\\epsilon(\\mathbf{k}) = -\\delta(\\mathbf{k}) / (k_{\\min}^2 + \\epsilon^2)$.\n\nFor any single mode $\\mathbf{k}$ on this shell, the ratio of the squared amplitudes is:\n$$\n\\frac{\\lvert \\Phi_\\epsilon(\\mathbf{k}) \\rvert^2}{\\lvert \\Phi_0(\\mathbf{k}) \\rvert^2} = \\frac{\\lvert -\\delta(\\mathbf{k}) / (k_{\\min}^2 + \\epsilon^2) \\rvert^2}{\\lvert -\\delta(\\mathbf{k}) / k_{\\min}^2 \\rvert^2} = \\left(\\frac{k_{\\min}^2}{k_{\\min}^2 + \\epsilon^2}\\right)^2\n$$\nThis ratio is constant for all modes on the shell. Therefore, the ratio of the shell-averaged squared amplitudes is the same:\n$$\n\\frac{\\langle \\lvert \\Phi_\\epsilon(\\mathbf{k}) \\rvert^2 \\rangle_{k=k_{\\min}}}{\\langle \\lvert \\Phi_0(\\mathbf{k}) \\rvert^2 \\rangle_{k=k_{\\min}}} = \\left(\\frac{k_{\\min}^2}{k_{\\min}^2 + \\epsilon^2}\\right)^2\n$$\nTaking the square root of both sides gives the ratio of the root-mean-square amplitudes:\n$$\n\\frac{\\sqrt{\\langle \\lvert \\Phi_\\epsilon(\\mathbf{k}) \\rvert^2 \\rangle_{k=k_{\\min}}}}{\\sqrt{\\langle \\lvert \\Phi_0(\\mathbf{k}) \\rvert^2 \\rangle_{k=k_{\\min}}}} = \\frac{k_{\\min}^2}{k_{\\min}^2 + \\epsilon^2}\n$$\nSubstituting this into the definition of $B$:\n$$\nB = \\frac{k_{\\min}^2}{k_{\\min}^2 + \\epsilon^2} - 1 = \\frac{k_{\\min}^2 - (k_{\\min}^2 + \\epsilon^2)}{k_{\\min}^2 + \\epsilon^2} = -\\frac{\\epsilon^2}{k_{\\min}^2 + \\epsilon^2}\n$$\nThe problem specifies $\\epsilon$ as a multiple of $k_{\\min}$, i.e., $\\epsilon = f \\cdot k_{\\min}$ for some factor $f$. Substituting this in:\n$$\nB = -\\frac{(f \\cdot k_{\\min})^2}{k_{\\min}^2 + (f \\cdot k_{\\min})^2} = -\\frac{f^2 k_{\\min}^2}{k_{\\min}^2(1 + f^2)} = -\\frac{f^2}{1 + f^2}\n$$\nThis is a remarkable result: the bias $B$ depends only on the ratio $f = \\epsilon/k_{\\min}$ and is independent of the grid size $N$, box size $L$, the random seed, and the density offset. The numerical implementation should reproduce this analytical prediction.\n\nLet's compute the expected values for the test cases:\n1.  **Test Case 1**: $\\epsilon = 0.5\\,k_{\\min} \\implies f=0.5$.\n    $B = -0.5^2 / (1 + 0.5^2) = -0.25 / 1.25 = -0.2$.\n2.  **Test Case 2**: $\\epsilon = 0.1\\,k_{\\min} \\implies f=0.1$.\n    $B = -0.1^2 / (1 + 0.1^2) = -0.01 / 1.01 \\approx -0.00990099$.\n3.  **Test Case 3**: $\\epsilon = 1.0\\,k_{\\min} \\implies f=1.0$.\n    $B = -1.0^2 / (1 + 1.0^2) = -1.0 / 2.0 = -0.5$.\n\nThe implementation will proceed as follows:\n1.  For each test case, define parameters $N$, $L$, seed, offset, and the factor $f$ for $\\epsilon$.\n2.  Generate a 3D real-space grid of size $N \\times N \\times N$. Populate it with Gaussian random variates using the given seed, and add the constant offset to create $\\delta(\\mathbf{x})$.\n3.  Compute the 3D discrete Fourier transform to get $\\delta(\\mathbf{k}) = \\texttt{FFT}[\\delta(\\mathbf{x})]$.\n4.  Construct the 3D grid of wavevectors $\\mathbf{k}$. The components are $k_i = 2\\pi n_i/L$, where $n_i$ are the integer mode numbers provided by `numpy.fft.fftfreq`. From these, compute the grid of squared magnitudes $k^2 = k_x^2+k_y^2+k_z^2$.\n5.  Implement the zero-mean solver: create a copy of $\\delta(\\mathbf{k})$ and set its $(0,0,0)$ component to zero. Then calculate $\\Phi_0(\\mathbf{k}) = -\\delta_{\\text{zero-mean}}(\\mathbf{k})/k^2$ for $k>0$, and $\\Phi_0(\\mathbf{k}=\\mathbf{0})=0$.\n6.  Implement the regularized solver: calculate $\\Phi_\\epsilon(\\mathbf{k}) = -\\delta(\\mathbf{k})/(k^2 + \\epsilon^2)$.\n7.  Identify the fundamental shell modes where $k^2$ is exactly $(2\\pi/L)^2$.\n8.  Calculate the mean of $|\\Phi_0(\\mathbf{k})|^2$ and $|\\Phi_\\epsilon(\\mathbf{k})|^2$ over this shell, take the square root of each to get the shell-averaged amplitudes.\n9.  Compute the bias $B$ and round it to the specified precision.\nThis procedure will numerically confirm the analytical result derived above.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the numerical cosmology problem for the given test cases.\n\n    This function calculates the fractional bias B between two Poisson solvers\n    on a periodic grid: one with proper zero-mean enforcement and another\n    with an infrared cutoff regularization.\n    \"\"\"\n\n    # Test cases are defined as tuples:\n    # (N, L, seed, offset, epsilon_factor)\n    # where epsilon = epsilon_factor * k_min.\n    test_cases = [\n        (32, 1.0, 1234, 0.2, 0.5), # Test case 1\n        (24, 1.0, 1, 0.0, 0.1),    # Test case 2\n        (24, 1.0, 42, 0.0, 1.0),    # Test case 3\n    ]\n\n    results = []\n    for case in test_cases:\n        N, L, seed, offset, epsilon_factor = case\n\n        # 1. Construct the scalar perturbation field delta(x)\n        rng = np.random.default_rng(seed)\n        # Generate i.i.d. zero-mean, unit-variance Gaussian random variates\n        delta_x = rng.standard_normal(size=(N, N, N))\n        # Add the specified constant offset\n        delta_x += offset\n\n        # 2. Compute the discrete Fourier transform\n        delta_k = np.fft.fftn(delta_x)\n\n        # 3. Construct the wavevector grid\n        # The wavevector components are k_i = 2*pi*n_i/L.\n        # np.fft.fftfreq(N, d=L/N) gives frequencies f_i = n_i/L in cycles/length.\n        # We need angular frequencies k_i = 2*pi*f_i.\n        k_coords = 2 * np.pi * np.fft.fftfreq(N, d=L / N)\n        \n        # Create 3D grids for kx, ky, kz using 'ij' indexing to match\n        # numpy's array axis order (axis 0, 1, 2).\n        kx, ky, kz = np.meshgrid(k_coords, k_coords, k_coords, indexing='ij')\n\n        # Calculate the squared magnitude of the wavevector for each mode.\n        k_sq = kx**2 + ky**2 + kz**2\n\n        # 4. Implement the two solvers\n        \n        # Solver 1: Zero-mean enforcement\n        # Copy delta_k to modify for this solver.\n        delta_k_0 = delta_k.copy()\n        # Enforce zero mean for the source term by setting the k=0 mode to zero.\n        delta_k_0[0, 0, 0] = 0\n        \n        # Solve for Phi_0(k) = -delta(k)/k^2, avoiding division by zero at k=0.\n        # The result for k=0 is 0 by the gauge choice.\n        Phi_0_k = np.divide(-delta_k_0, k_sq, \n                            out=np.zeros_like(delta_k_0, dtype=np.complex128), \n                            where=(k_sq > 0))\n\n        # Solver 2: Infrared-regularized solver\n        # Calculate the fundamental wavenumber k_min and the regulator epsilon.\n        k_min = 2 * np.pi / L\n        epsilon = epsilon_factor * k_min\n        \n        # Solve for Phi_epsilon(k) = -delta(k)/(k^2 + epsilon^2).\n        # This is numerically stable for all k since epsilon > 0.\n        denominator = k_sq + epsilon**2\n        Phi_eps_k = -delta_k / denominator\n\n        # 5. Quantify the bias B at the fundamental shell\n        \n        # Identify the fundamental shell: all modes with magnitude exactly k_min.\n        # This corresponds to k^2 = k_min^2.\n        k_min_sq = k_min**2\n        # Use np.isclose for robust floating-point comparison.\n        shell_mask = np.isclose(k_sq, k_min_sq)\n\n        # Calculate the shell-averaged amplitude for each field.\n        # The amplitude is sqrt(mean of |Phi(k)|^2 over the shell).\n        # np.abs computes the modulus for complex numbers.\n        \n        # For Phi_0\n        avg_amp_sq_0 = np.mean(np.abs(Phi_0_k[shell_mask])**2)\n        amp_0 = np.sqrt(avg_amp_sq_0)\n\n        # For Phi_epsilon\n        avg_amp_sq_eps = np.mean(np.abs(Phi_eps_k[shell_mask])**2)\n        amp_eps = np.sqrt(avg_amp_sq_eps)\n\n        # Calculate the fractional bias B.\n        # Handle the unlikely case of amp_0 being zero to avoid division by zero.\n        if amp_0 == 0:\n            # This should not happen with a random field, but it is good practice.\n            # If the reference amplitude is zero, the bias is undefined.\n            # We can also say if amp_eps is also 0, bias is 0, else it's infinite.\n            # Based on the analytical derivation, amp_0 will not be zero.\n            bias = np.nan\n        else:\n            bias = (amp_eps / amp_0) - 1\n            \n        results.append(bias)\n\n    # Final print statement in the exact required format.\n    # Each result is a scalar value rounded to 6 decimal places.\n    print(f\"[{','.join(f'{b:.6f}' for b in results)}]\")\n\nsolve()\n```", "id": "3485164"}, {"introduction": "Having explored the subtleties of the scalar potential, we now turn to the tensor modes, which are isolated using a transverse-traceless (TT) projector. A projector is defined by its fundamental mathematical properties, and this exercise [@problem_id:3485224] guides you through deriving the TT projector and then implementing a unit test to verify its idempotency and orthogonality. This practice solidifies your understanding of the operator itself and introduces the crucial habit of validating numerical tools against their theoretical definitions.", "problem": "You are to implement and unit test the transverse-traceless (TT) projector used in the scalar, vector, tensor decomposition of linear perturbations in numerical cosmology. Work in three-dimensional Fourier space on a flat background with Euclidean metric. Consider a real, symmetric, rank-$2$ tensor $S_{ij}$ that represents the Fourier amplitude of a perturbation mode with wavevector $k_i \\neq 0$. The TT subspace is defined by the constraints of transversality and tracelessness, namely $k_i T_{ij} = 0$ and $\\delta^{ij} T_{ij} = 0$, where $\\delta_{ij}$ is the Kronecker delta. The TT projector is the unique linear, self-adjoint map on the vector space of symmetric tensors that leaves the TT subspace invariant and annihilates its orthogonal complement with respect to the Frobenius inner product. \n\nStarting from first principles that are appropriate for this context, namely:\n- the Fourier-space representation of linear perturbations about a flat background,\n- the definition of transverse and longitudinal decomposition via the Helmholtz theorem for vectors,\n- the characterization of the TT subspace by $k_i T_{ij} = 0$ and $\\delta^{ij} T_{ij} = 0$,\nderive an explicit, algorithmically implementable expression for the TT projector acting on symmetric tensors. Use this to implement a function that maps any real, symmetric $3\\times 3$ tensor $S_{ij}$ to its TT-projected counterpart $T^{\\mathrm{TT}}_{ij}$ for a given nonzero wavevector $k_i$.\n\nThen, devise a unit test that verifies, for several nontrivial test cases, the following two properties numerically to machine precision:\n- Idempotency: applying the projector twice yields the same result as applying it once, i.e., the Frobenius norm of $T^{\\mathrm{TT}}_{ij} - \\left(T^{\\mathrm{TT}}\\right)^{\\mathrm{TT}}_{ij}$ is negligible relative to the Frobenius norm scale.\n- Orthogonality of the projection: the TT component is orthogonal to the residual with respect to the Frobenius inner product, i.e., $\\sum_{i,j} T^{\\mathrm{TT}}_{ij}\\,\\left(S_{ij} - T^{\\mathrm{TT}}_{ij}\\right)$ is negligible relative to the product of norms.\n\nFor numerical comparisons, use a tolerance of $10^{-12}$ in the following scaled sense: for any tensor $A_{ij}$, define the Frobenius norm $\\|A\\| = \\sqrt{\\sum_{i,j} A_{ij}^2}$. Declare the idempotency test passed if $\\|T^{\\mathrm{TT}} - \\left(T^{\\mathrm{TT}}\\right)^{\\mathrm{TT}}\\| \\le 10^{-12} \\max\\{1,\\|T^{\\mathrm{TT}}\\|\\}$, and declare the orthogonality test passed if $\\left|\\sum_{i,j} T^{\\mathrm{TT}}_{ij}\\,\\left(S_{ij} - T^{\\mathrm{TT}}_{ij}\\right)\\right| \\le 10^{-12} \\max\\{1,\\|T^{\\mathrm{TT}}\\|\\,\\|S - T^{\\mathrm{TT}}\\|\\}$.\n\nYour program must:\n- Generate a real, symmetric input tensor $S_{ij}$ from a fixed random seed so that tests are deterministic.\n- For each test case, construct $S_{ij}$ and $k_i$, compute the TT projection, and perform the two tests above.\n- Return a boolean for each test case that is true if and only if both idempotency and orthogonality checks pass.\n\nTest suite (each case is a pair consisting of a wavevector $k_i$ and a random seed):\n- Case $1$: $k_i = (1,2,3)$, seed $42$.\n- Case $2$: $k_i = (0,0,1)$, seed $7$.\n- Case $3$: $k_i = (-3.5, 2.25, 0.5)$, seed $123456$.\n- Case $4$: $k_i = (10^3, -2\\times 10^3, 3\\times 10^3)$, seed $2023$.\n\nAll quantities are dimensionless, so no physical units are required.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"). Each result must be a boolean corresponding to the combined pass/fail status (idempotency and orthogonality) for one test case, in the order of the test suite above.", "solution": "The problem of constructing a transverse-traceless (TT) projector for a symmetric rank-$2$ tensor in three-dimensional Fourier space is a standard procedure in the theory of cosmological perturbations. We are given a real, symmetric tensor $S_{ij}$ associated with a wavevector $k_i \\neq 0$. The goal is to derive and implement a projector that maps $S_{ij}$ to its TT component, $T^{\\mathrm{TT}}_{ij}$, which satisfies the transversality condition, $k^i T^{\\mathrm{TT}}_{ij} = 0$, and the tracelessness condition, $\\delta^{ij} T^{\\mathrm{TT}}_{ij} = 0$. Since we are on a flat background with a Euclidean metric, we can use the Kronecker delta $\\delta_{ij}$ and do not need to distinguish between co- and contravariant indices.\n\nOur derivation proceeds constructively. We will first define a projection operator that enforces transversality and then modify it to enforce tracelessness, while ensuring the transversality property is preserved.\n\nLet $k_i$ be the wavevector. The magnitude is $k = \\sqrt{k_j k_j}$. We define the unit vector in the direction of the wavevector as $\\hat{k}_i = k_i/k$. The fundamental building block for our construction is the spatial projector $P_{ij}$ which projects any vector onto the plane orthogonal to $\\hat{k}_i$. It is defined as:\n$$\nP_{ij} = \\delta_{ij} - \\hat{k}_i \\hat{k}_j\n$$\nThis operator is idempotent ($P_{ik} P_{kj} = P_{ij}$) and self-adjoint. It annihilates any vector parallel to $\\hat{k}_i$, since $P_{ij} \\hat{k}_j = (\\delta_{ij} - \\hat{k}_i \\hat{k}_j) \\hat{k}_j = \\hat{k}_i - \\hat{k}_i (\\hat{k}_j \\hat{k}_j) = \\hat{k}_i - \\hat{k}_i = 0$. Consequently, for any tensor $A_{...j...}$, contracting with $k^j$ is equivalent to contracting with $k \\hat{k}^j$. Therefore, $k^j P_{ji} = 0$.\n\nTo make a general symmetric tensor $S_{ij}$ transverse, we must ensure that any contraction with $k_i$ yields zero. We can achieve this by applying the projector $P_{ij}$ to both indices of $S_{ij}$:\n$$\nS'_{ij} = P_{ik} S_{kl} P_{lj}\n$$\nSince $P_{ij}$ is symmetric, $P_{lj} = P_{jl}$. In matrix notation, this corresponds to $S' = PSP$. The resulting tensor $S'_{ij}$ is transverse with respect to both indices. For instance, contracting with $k^i$:\n$$\nk^i S'_{ij} = k^i P_{ik} S_{kl} P_{lj} = (k \\hat{k}^i) P_{ik} S_{kl} P_{lj} = 0\n$$\nbecause $k^i P_{ik} = 0$. The tensor $S'_{ij}$ is symmetric if $S_{ij}$ is symmetric.\n\nThe tensor $S'_{ij}$ is transverse, but it is not, in general, traceless. We must remove its trace while preserving its transversality. Let's compute the trace of $S'_{ij}$:\n$$\n\\text{Tr}(S') = \\delta^{ij} S'_{ij} = \\delta^{ij} P_{ik} S_{kl} P_{lj} = P_{ki} S_{kl} P_{li} = P_{ik} P_{il} S_{kl}\n$$\nWe can simplify the term $P_{ik} P_{il} = P_{kl}$. Thus, the trace of $S'_{ij}$ is $\\text{Tr}(S') = P_{kl} S_{kl}$.\n\nTo produce a traceless tensor from $S'_{ij}$, we can subtract a tensor proportional to the transverse projector $P_{ij}$ itself. A tensor of the form $C \\cdot P_{ij}$ for some scalar $C$ is transverse ($k^i P_{ij} = 0$), so subtracting it from $S'_{ij}$ preserves transversality. Let the final TT tensor be:\n$$\nT^{\\mathrm{TT}}_{ij} = S'_{ij} - C \\cdot P_{ij}\n$$\nWe fix the constant $C$ by requiring that the trace of $T^{\\mathrm{TT}}_{ij}$ vanishes:\n$$\n\\delta^{ij} T^{\\mathrm{TT}}_{ij} = \\delta^{ij} S'_{ij} - C \\cdot \\delta^{ij} P_{ij} = 0\n$$\nThe trace of the projector $P_{ij}$ is $\\delta^{ij} P_{ij} = \\delta^{ij}(\\delta_{ij} - \\hat{k}_i \\hat{k}_j) = \\delta_{ii} - \\hat{k}_i \\hat{k}_i = 3 - 1 = 2$.\nPlugging this in, we get:\n$$\n\\text{Tr}(S') - 2C = 0 \\implies C = \\frac{1}{2}\\text{Tr}(S') = \\frac{1}{2} P_{kl} S_{kl}\n$$\nSubstituting everything back, we obtain the final explicit expression for the TT projected tensor:\n$$\nT^{\\mathrm{TT}}_{ij} = P_{ik} S_{kl} P_{lj} - \\frac{1}{2} P_{ij} (P_{ab} S_{ab})\n$$\nThis expression defines the action of the TT projector on a symmetric tensor $S_{ij}$. We can write the projector operator $\\Lambda_{ij}^{~kl}$ as:\n$$\n\\Lambda_{ij}^{~kl}(k) = \\left(P_{im}(k)P_{jn}(k)\\right) - \\frac{1}{2} P_{ij}(k) P_{mn}(k)\n$$\nwhere $\\Lambda_{ij}^{~kl}$ acts on $S_{kl}$. This is a more formal representation, but the step-by-step procedure is more direct for implementation.\n\nThe algorithmic implementation will follow these steps:\n1.  Given the wavevector $k_i$, compute its norm $k$ and the unit vector $\\hat{k}_i = k_i/k$.\n2.  Construct the transverse projector matrix $P_{ij} = \\delta_{ij} - \\hat{k}_i \\hat{k}_j$.\n3.  Given the input symmetric tensor $S_{ij}$, compute the intermediate transverse tensor $S'_{ij} = P_{ik} S_{km} P_{mj}$. This is a matrix product $S' = PSP$.\n4.  Compute the scalar trace term $s' = P_{ab} S_{ab}$. This is the Frobenius inner product $\\langle P, S \\rangle_F = \\text{Tr}(P^T S) = \\text{Tr}(PS)$.\n5.  Construct the final transverse-traceless tensor $T^{\\mathrm{TT}}_{ij} = S'_{ij} - \\frac{1}{2} s' P_{ij}$.\n\nThe unit tests will numerically verify two fundamental properties of this projection operator. First, idempotency, which means that applying the projector to an already projected tensor leaves it unchanged: $\\Pi(\\Pi(S)) = \\Pi(S)$. Second, orthogonality, which means that the projected tensor, $T^{\\mathrm{TT}}_{ij}$, is orthogonal to the residual, $S_{ij} - T^{\\mathrm{TT}}_{ij}$, with respect to the Frobenius inner product: $\\langle T^{\\mathrm{TT}}, S - T^{\\mathrm{TT}} \\rangle_F = 0$. These tests confirm the correctness of the implementation against the defining properties of an orthogonal projector.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef project_tt(S, k):\n    \"\"\"\n    Computes the transverse-traceless (TT) projection of a symmetric 3x3 tensor.\n\n    Args:\n        S (np.ndarray): A real, symmetric 3x3 numpy array.\n        k (np.ndarray): A 3-element numpy array representing the wavevector.\n\n    Returns:\n        np.ndarray: The TT projection of S, a 3x3 numpy array.\n    \"\"\"\n    if np.all(k == 0):\n        raise ValueError(\"Wavevector k must be non-zero.\")\n\n    # 1. Compute unit vector k_hat\n    k_norm = np.linalg.norm(k)\n    k_hat = k / k_norm\n\n    # 2. Construct the transverse projector matrix P\n    # P_ij = delta_ij - k_hat_i * k_hat_j\n    P = np.eye(3) - np.outer(k_hat, k_hat)\n\n    # 3. Compute the intermediate transverse tensor S_prime = P S P\n    # Since P is symmetric (P.T = P), P S P.T = P S P\n    S_prime = P @ S @ P\n\n    # 4. Compute the scalar trace term s_prime = Tr(P S)\n    # This is equivalent to sum_{a,b} P_ab * S_ab\n    s_prime_scalar = np.trace(P @ S)\n\n    # 5. Construct the final TT tensor T_tt = S_prime - 0.5 * s_prime * P\n    T_tt = S_prime - 0.5 * s_prime_scalar * P\n    \n    return T_tt\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the TT projector.\n    \"\"\"\n    # Test suite: (k_vector, random_seed)\n    test_cases = [\n        ((1, 2, 3), 42),\n        ((0, 0, 1), 7),\n        ((-3.5, 2.25, 0.5), 123456),\n        ((1e3, -2e3, 3e3), 2023),\n    ]\n\n    results = []\n    tolerance = 1e-12\n\n    for k_val, seed in test_cases:\n        # Set up the deterministic environment for the test case\n        rng = np.random.default_rng(seed)\n        k = np.array(k_val, dtype=np.float64)\n\n        # Generate a real, symmetric 3x3 tensor S\n        A = rng.random((3, 3))\n        S = (A + A.T) / 2.0\n\n        # Compute the TT projection\n        T_tt = project_tt(S, k)\n\n        # --- Idempotency Test ---\n        # T_tt_tt should be equal to T_tt\n        T_tt_tt = project_tt(T_tt, k)\n        \n        diff_idem = T_tt - T_tt_tt\n        norm_diff_idem = np.linalg.norm(diff_idem, 'fro')\n        norm_T_tt = np.linalg.norm(T_tt, 'fro')\n        \n        idempotency_passed = norm_diff_idem = tolerance * max(1.0, norm_T_tt)\n\n        # --- Orthogonality Test ---\n        # T_tt should be orthogonal to the residual (S - T_tt)\n        residual = S - T_tt\n        \n        # Frobenius inner product: sum(A_ij * B_ij)\n        inner_product = np.sum(T_tt * residual)\n        norm_residual = np.linalg.norm(residual, 'fro')\n\n        orthogonality_passed = abs(inner_product) = tolerance * max(1.0, norm_T_tt * norm_residual)\n        \n        # The test case passes if and only if both checks pass\n        results.append(idempotency_passed and orthogonality_passed)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, [r for r in results]))}]\".replace('True', 'true').replace('False', 'false'))\n\nsolve()\n```", "id": "3485224"}, {"introduction": "With a solid grasp of the individual scalar and tensor components, you are now ready to tackle the complete scalar-vector-tensor (SVT) decomposition. This final practice [@problem_id:3485225] is a capstone exercise where you will develop a full algorithm to decompose an arbitrary symmetric tensor field on a grid. By building a test suite of synthetic pure-mode fields and then decomposing a mixed field, you will master the practical implementation and validation of this cornerstone technique in cosmological perturbation theory.", "problem": "You are given a real-valued, symmetric rank-$2$ tensor field $h_{ij}(\\mathbf{x})$ sampled on a periodic cubic grid of size $N \\times N \\times N$ with periodic box length $L$. The goal is to implement a program that performs a Scalar–Vector–Tensor (SVT) decomposition of $h_{ij}$ on the periodic domain using the Fast Fourier Transform (FFT), leveraging the fact that in Fourier space derivatives map to multiplication by $i k_i$, where $k_i$ are the Fourier wavevector components, and that divergence and trace constraints can be expressed algebraically. Work in three spatial dimensions $i,j \\in \\{0,1,2\\}$.\n\nBase your derivation and algorithm on the following fundamental principles and core definitions:\n\n- Periodic Fourier analysis on a cubic box of side $L$ with discrete modes labeled by integer triplets $(n_x,n_y,n_z)$, and wavevectors $\\mathbf{k}$ such that $k_i = 2\\pi n_i / L$.\n- The mapping of spatial derivatives to Fourier multipliers: $\\partial_i \\to i k_i$, and the associated properties of divergence and trace in Fourier space.\n- The decomposition of a symmetric perturbation tensor perturbation $h_{ij}$ into scalar, vector, and tensor contributions that satisfy the defining constraints:\n  - Scalar part comprises contributions built from scalar potentials and contributes to isotropic trace and double derivatives.\n  - Vector part is built from a transverse vector potential (divergence-free) and yields a symmetric contribution linear in derivatives that is divergence-free but not traceless in general.\n  - Tensor part is simultaneously transverse and traceless.\n- Orthogonal projectors built from the Fourier wavevector that separate longitudinal and transverse components, and the related algebraic construction to isolate transverse and traceless pieces in Fourier space.\n\nYou must outline, derive, and implement an algorithm that, given $h_{ij}(\\mathbf{x})$, computes its scalar $S_{ij}(\\mathbf{x})$, vector $V_{ij}(\\mathbf{x})$, and tensor $T_{ij}(\\mathbf{x})$ components such that $h_{ij} = S_{ij} + V_{ij} + T_{ij}$, with $V_{ij}$ being divergence-free and $T_{ij}$ being divergence-free and traceless in the sense of Fourier-space constraints.\n\nScientific and numerical handling requirements:\n\n- Treat the periodic zero mode $\\mathbf{k}=\\mathbf{0}$ by a convention that is consistent and numerically stable. Specifically, at $\\mathbf{k}=\\mathbf{0}$, you must not divide by $k^2$ and you must define a convention that assigns the isotropic trace of $h_{ij}$ to the scalar sector and sets the vector and tensor sectors to zero at this mode.\n- Treat Nyquist modes, i.e., those modes for which any component $k_i$ equals the Nyquist value in an even-sized grid, carefully. Since Nyquist modes are self-conjugate under $\\mathbf{k}\\to -\\mathbf{k}$, ensure the algebra is applied without division by zero and that the resulting Fourier coefficients are consistent with a real-valued field in real space.\n- Your algorithm must be invariant under rotations of $\\mathbf{k}$ and must rely only on algebraic operations in Fourier space plus inverse transforms back to configuration space.\n\nImplementation details required:\n\n- Use discrete Fourier transforms via the Fast Fourier Transform to map between real space and Fourier space on the periodic domain.\n- Work in three spatial dimensions, indices $i,j \\in \\{0,1,2\\}$.\n- Let the periodic box length be $L = 1$ (unitless), and compute Fourier wavevectors as $k_i = 2\\pi \\,\\mathrm{fftfreq}(N, d=L/N)$ along each axis.\n- Construct a test suite of synthetic fields to verify your implementation. For each test, you must generate a real-space tensor field by constructing its Fourier coefficients according to the following deterministic recipes, and then applying an inverse FFT.\n\nSynthetic test suite:\n\n- Test $1$ (Scalar-only, even grid): $N=8$, $L=1$. Define scalar potentials in Fourier space using real, even amplitudes\n  - $\\psi(\\mathbf{k}) = \\exp\\!\\big(-(|\\mathbf{k}|/k_0)^2\\big)$ with $k_0 = 4.0$, except set $\\psi(\\mathbf{0}) = 1.2$,\n  - $E(\\mathbf{k}) = 0.3 \\,\\exp\\!\\big(-(|\\mathbf{k}|/k_1)^2\\big)$ with $k_1 = 3.0$.\n  Construct $h^{(S)}_{ij}(\\mathbf{k}) = 2 \\,\\psi(\\mathbf{k}) \\,\\delta_{ij} - 2 \\,E(\\mathbf{k}) \\,k_i k_j$. Set vector and tensor parts to zero: $h^{(V)}_{ij}(\\mathbf{k})=0$, $h^{(T)}_{ij}(\\mathbf{k})=0$. Inverse transform to $h_{ij}(\\mathbf{x})$.\n- Test $2$ (Vector-only, even grid): $N=8$, $L=1$. Define a transverse vector field in Fourier space as follows. For each $\\mathbf{k}\\neq \\mathbf{0}$, define the transverse projector $P_{ij}(\\mathbf{k})$ built from $\\mathbf{k}$, choose a fixed unit vector $a_j$ with $a_j = (0,0,1)$, and set $n_j(\\mathbf{k}) = P_{jk}(\\mathbf{k})\\,a_k$, with the fallback $a_j=(0,1,0)$ if $n_j(\\mathbf{k})=\\mathbf{0}$. Let $A_F(\\mathbf{k}) = \\exp\\!\\big(-(|\\mathbf{k}|/k_0)^2\\big)$ with $k_0=5.0$, and define $F_j(\\mathbf{k}) = A_F(\\mathbf{k}) \\,n_j(\\mathbf{k})/\\big\\|n(\\mathbf{k})\\big\\|$. Set $F_j(\\mathbf{0})=\\mathbf{0}$. Then set $h^{(V)}_{ij}(\\mathbf{k}) = i \\,k_i F_j(\\mathbf{k}) + i \\,k_j F_i(\\mathbf{k})$. Set scalar and tensor parts to zero: $h^{(S)}_{ij}(\\mathbf{k})=0$, $h^{(T)}_{ij}(\\mathbf{k})=0$. Inverse transform to $h_{ij}(\\mathbf{x})$.\n- Test $3$ (Tensor-only, odd grid): $N=9$, $L=1$. For a constant symmetric matrix $C_{lm}=\\mathrm{diag}(1,-1,0)$ and amplitude $A_T(\\mathbf{k}) = \\exp\\!\\big(-(|\\mathbf{k}|/k_0)^2\\big)$ with $k_0=4.0$, define for each $\\mathbf{k}\\neq \\mathbf{0}$ the transverse projector $P_{ij}(\\mathbf{k})$ and construct the standard transverse-traceless operator built from $P_{ij}$. Apply it to $C_{lm}$ and multiply by $A_T(\\mathbf{k})$ to obtain $h^{(T)}_{ij}(\\mathbf{k})$, and set $h^{(T)}_{ij}(\\mathbf{0})=0$. Set scalar and vector parts to zero: $h^{(S)}_{ij}(\\mathbf{k})=0$, $h^{(V)}_{ij}(\\mathbf{k})=0$. Inverse transform to $h_{ij}(\\mathbf{x})$.\n- Test $4$ (Mixed, even grid): $N=8$, $L=1$. Construct $h^{(S)}_{ij}$ as in Test $1$, $h^{(V)}_{ij}$ as in Test $2$, and $h^{(T)}_{ij}$ as in Test $3$ but with $N=8$ and the same $k_0=4.0$. Sum all three in Fourier space and inverse transform to obtain a mixed field $h_{ij}(\\mathbf{x})$.\n\nNumerical comparison and outputs:\n\n- For each test, let $H$ denote the full input field in real space and let $(S,V,T)$ be the components returned by your decomposition algorithm in real space.\n- Define the discrete $L^2$-norm of a tensor field $X$ on the grid as the square root of the sum of squares over all components and all grid points.\n- For Test $1$, compute the following three floats:\n  - $e_{1,S} = \\|S - H\\|/\\|H\\|$,\n  - $r_{1,V} = \\|V\\|/\\|H\\|$,\n  - $r_{1,T} = \\|T\\|/\\|H\\|$.\n- For Test $2$, compute:\n  - $r_{2,S} = \\|S\\|/\\|H\\|$,\n  - $e_{2,V} = \\|V - H\\|/\\|H\\|$,\n  - $r_{2,T} = \\|T\\|/\\|H\\|$.\n- For Test $3$, compute:\n  - $r_{3,S} = \\|S\\|/\\|H\\|$,\n  - $r_{3,V} = \\|V\\|/\\|H\\|$,\n  - $e_{3,T} = \\|T - H\\|/\\|H\\|$.\n- For Test $4$, compute:\n  - $e_{4,S} = \\|S - H^{(S)}\\|/\\|H^{(S)}\\|$,\n  - $e_{4,V} = \\|V - H^{(V)}\\|/\\|H^{(V)}\\|$,\n  - $e_{4,T} = \\|T - H^{(T)}\\|/\\|H^{(T)}\\|$,\n  where $H^{(S)}$, $H^{(V)}$, and $H^{(T)}$ are the real-space components generated for the mixed field.\n\nYour program should produce a single line of output containing the $12$ results for Tests $1$ through $4$ in the following order:\n$[e_{1,S}, r_{1,V}, r_{1,T}, r_{2,S}, e_{2,V}, r_{2,T}, r_{3,S}, r_{3,V}, e_{3,T}, e_{4,S}, e_{4,V}, e_{4,T}]$,\nas a comma-separated list enclosed in square brackets. All values are unitless real numbers. Roundings are not required; print full-precision floats as obtained by the computation.\n\nConstraints and notes:\n\n- Ensure numerical stability by never dividing by $k^2$ at $\\mathbf{k}=\\mathbf{0}$, and by treating Nyquist modes like any other nonzero wavevector.\n- Ensure that the inverse FFT of the constructed Fourier-space fields produces real-valued $h_{ij}(\\mathbf{x})$ within numerical precision, by maintaining the Hermitian symmetry required for real fields.\n- The implementation must be self-contained, require no input, and follow the exact output format described above.", "solution": "The task is to perform a full scalar-vector-tensor (SVT) decomposition of a symmetric rank-2 tensor field $h_{ij}(\\mathbf{x})$ on a periodic grid. The decomposition is most easily performed in Fourier space, where derivatives become algebraic multiplications. We decompose the Fourier transform of the field, $\\tilde{h}_{ij}(\\mathbf{k})$, into its scalar, vector, and tensor parts, and then transform back to configuration space. For any non-zero wavevector $\\mathbf{k}$, the decomposition is $\\tilde{h}_{ij} = \\tilde{S}_{ij} + \\tilde{V}_{ij} + \\tilde{T}_{ij}$.\n\n**1. Derivation of the Decomposition Operators**\n\nThe three components are defined by their structure and transformation properties.\n\n- **Scalar Part ($\\tilde{S}_{ij}$):** The most general symmetric tensor that can be constructed from scalars using up to two derivatives (or multiplications by $k_i$ in Fourier space) has the form:\n  $$ \\tilde{S}_{ij}(\\mathbf{k}) = A(\\mathbf{k}) \\delta_{ij} + B(\\mathbf{k}) k_i k_j $$\n  where $A$ and $B$ are scalar functions of $\\mathbf{k}$.\n- **Vector Part ($\\tilde{V}_{ij}$):** This is constructed from a transverse vector potential $\\tilde{F}_i$ (satisfying $k^i \\tilde{F}_i=0$):\n  $$ \\tilde{V}_{ij}(\\mathbf{k}) = i (k_i \\tilde{F}_j + k_j \\tilde{F}_i) $$\n- **Tensor Part ($\\tilde{T}_{ij}$):** This is the remainder, which must be transverse ($k^i \\tilde{T}_{ij} = 0$) and traceless ($\\delta^{ij} \\tilde{T}_{ij} = 0$).\n\nBecause the three components are orthogonal, we can isolate them by taking specific contractions (projections) of $\\tilde{h}_{ij}$. For $\\mathbf{k} \\neq \\mathbf{0}$:\n\n**Isolating the Scalar Part:**\nWe need to determine the scalars $A$ and $B$. We can do this by taking the trace of $\\tilde{h}_{ij}$ and by contracting it with $k_i k_j$.\n1.  **Trace:** $\\tilde{h}_{ll} = \\delta^{ij}\\tilde{h}_{ij} = \\delta^{ij}\\tilde{S}_{ij} = 3A + k^2 B$. (The vector and tensor parts are traceless).\n2.  **Double Contraction:** $k^i k^j \\tilde{h}_{ij} = k^i k^j \\tilde{S}_{ij} = A k^2 + B k^4$. (The vector and tensor parts are transverse).\n\nThis gives a system of two linear equations for $A$ and $B$:\n$$\n\\begin{cases}\n3A + k^2 B = \\tilde{h}_{ll} \\\\\nk^2 A + k^4 B = k^i k^j \\tilde{h}_{ij}\n\\end{cases}\n$$\nSolving this system yields:\n$$\nA(\\mathbf{k}) = \\frac{1}{2} \\left( \\tilde{h}_{ll} - \\frac{k^i k^j \\tilde{h}_{ij}}{k^2} \\right)\n$$\n$$\nB(\\mathbf{k}) = \\frac{1}{2k^2} \\left( \\frac{3 k^i k^j \\tilde{h}_{ij}}{k^2} - \\tilde{h}_{ll} \\right)\n$$\nWith $A$ and $B$ determined, $\\tilde{S}_{ij}$ is fully specified.\n\n**Isolating the Vector Part:**\nWe can find the vector potential $\\tilde{F}_i$ by contracting $\\tilde{h}_{ij}$ with one power of $k_i$.\n1.  **Single Contraction:** Let $\\tilde{v}_j = i k^i \\tilde{h}_{ij}$.\n    - $i k^i \\tilde{S}_{ij} = i k^i (A\\delta_{ij} + B k_i k_j) = i(A k_j + B k^2 k_j) = i(A+Bk^2)k_j$. This is a longitudinal vector.\n    - $i k^i \\tilde{V}_{ij} = i k^i [i(k_i \\tilde{F}_j + k_j \\tilde{F}_i)] = -(k^2 \\tilde{F}_j + k_j(k^i \\tilde{F}_i)) = -k^2 \\tilde{F}_j$. This is a transverse vector because $k^j \\tilde{F}_j = 0$.\n    - $i k^i \\tilde{T}_{ij} = 0$.\nSo, $\\tilde{v}_j = i(A+Bk^2)k_j - k^2\\tilde{F}_j$. This shows that $\\tilde{v}_j$ is a sum of a longitudinal part (from the scalar component) and a transverse part (from the vector component). We can isolate the transverse part using the projector $P_{ij} = \\delta_{ij} - k_i k_j/k^2$.\n$$\n\\tilde{v}_j^{\\perp} = P_{jl} \\tilde{v}_l = -k^2 \\tilde{F}_j\n$$\nThis allows us to solve for $\\tilde{F}_j$:\n$$\n\\tilde{F}_j = -\\frac{1}{k^2} \\tilde{v}_j^{\\perp} = -\\frac{i}{k^2} P_{jl} (k^m \\tilde{h}_{ml})\n$$\nSubstituting this back into the definition of $\\tilde{V}_{ij}$ gives the explicit form for the vector component.\n\n**Isolating the Tensor Part:**\nThe tensor part is simply what is left over after subtracting the scalar and vector parts:\n$$\n\\tilde{T}_{ij} = \\tilde{h}_{ij} - \\tilde{S}_{ij} - \\tilde{V}_{ij}\n$$\nBy construction, this will be transverse and traceless.\n\n**2. Algorithm**\n\nThe overall algorithm proceeds as follows:\n1.  Given the real-space tensor field $h_{ij}(\\mathbf{x})$, compute its Fourier transform $\\tilde{h}_{ij}(\\mathbf{k})$ using an FFT.\n2.  Create grids for the wavevector components $k_x, k_y, k_z$ and the squared magnitude $k^2$.\n3.  For each mode $\\mathbf{k} \\neq \\mathbf{0}$:\n    a. Calculate the scalar functions $A(\\mathbf{k})$ and $B(\\mathbf{k})$ from $\\tilde{h}_{ij}(\\mathbf{k})$ and $\\mathbf{k}$.\n    b. Construct the scalar component $\\tilde{S}_{ij}(\\mathbf{k}) = A \\delta_{ij} + B k_i k_j$.\n    c. Calculate the transverse part of $i k^l \\tilde{h}_{lj}$, which gives $-k^2 \\tilde{F}_j$. Solve for $\\tilde{F}_j$.\n    d. Construct the vector component $\\tilde{V}_{ij}(\\mathbf{k}) = i(k_i\\tilde{F}_j + k_j\\tilde{F}_i)$.\n    e. The tensor component is the remainder: $\\tilde{T}_{ij}(\\mathbf{k}) = \\tilde{h}_{ij}(\\mathbf{k}) - \\tilde{S}_{ij}(\\mathbf{k}) - \\tilde{V}_{ij}(\\mathbf{k})$.\n4.  For the zero mode $\\mathbf{k} = \\mathbf{0}$:\n    a. The problem defines a convention. The scalar part takes the full tensor: $\\tilde{S}_{ij}(\\mathbf{0}) = \\tilde{h}_{ij}(\\mathbf{0})$.\n    b. The vector and tensor parts are zero: $\\tilde{V}_{ij}(\\mathbf{0})=0$, $\\tilde{T}_{ij}(\\mathbf{0})=0$.\n5.  Perform inverse FFTs on $\\tilde{S}_{ij}(\\mathbf{k})$, $\\tilde{V}_{ij}(\\mathbf{k})$, and $\\tilde{T}_{ij}(\\mathbf{k})$ to obtain the real-space component fields $S_{ij}(\\mathbf{x})$, $V_{ij}(\\mathbf{x})$, and $T_{ij}(\\mathbf{x})$. Take the real part to discard any small imaginary components arising from numerical noise.\nThis algorithm provides a complete and orthogonal decomposition of the tensor field.", "answer": "```python\nimport numpy as np\n\ndef l2_norm(tensor_field):\n    \"\"\"Computes the discrete L2-norm of a real tensor field on the grid.\"\"\"\n    return np.sqrt(np.sum(tensor_field**2))\n\ndef svt_decomposition(h_ij, L):\n    \"\"\"\n    Performs the Scalar-Vector-Tensor (SVT) decomposition of a symmetric rank-2 tensor field h_ij.\n    \n    Args:\n        h_ij (np.ndarray): A (3, 3, N, N, N) real-valued tensor field.\n        L (float): The side length of the periodic box.\n\n    Returns:\n        tuple: A tuple (S_ij, V_ij, T_ij) of the real-space component fields.\n    \"\"\"\n    N = h_ij.shape[-1]\n    \n    # Step 1: Fourier transform the input field.\n    h_tilde = np.fft.fftn(h_ij, axes=(-3, -2, -1))\n\n    # Step 2: Set up k-space grid.\n    k_coords = 2 * np.pi * np.fft.fftfreq(N, d=L/N)\n    kx, ky, kz = np.meshgrid(k_coords, k_coords, k_coords, indexing='ij')\n    k_vec = np.stack((kx, ky, kz), axis=0)\n    k_squared = kx**2 + ky**2 + kz**2\n\n    # Step 3: Initialize Fourier components of S, V, T.\n    S_tilde = np.zeros_like(h_tilde, dtype=complex)\n    V_tilde = np.zeros_like(h_tilde, dtype=complex)\n\n    # Step 4: Isolate k != 0 modes for algebraic operations.\n    nonzero_k_mask = k_squared > 1e-12\n    \n    if np.any(nonzero_k_mask):\n        k_vec_nz = k_vec[..., nonzero_k_mask]\n        k_squared_nz = k_squared[nonzero_k_mask]\n        h_tilde_nz = h_tilde[..., nonzero_k_mask]\n        \n        # --- Scalar part (S_tilde) for k != 0 ---\n        h_tr_nz = np.einsum('ii...->...', h_tilde_nz)\n        h_divdiv_nz = np.einsum('i...,j...,ij...->...', k_vec_nz, k_vec_nz, h_tilde_nz)\n        \n        inv_k2_nz = 1.0 / k_squared_nz\n        \n        a_nz = 0.5 * (h_tr_nz - h_divdiv_nz * inv_k2_nz)\n        b_nz = 0.5 * inv_k2_nz * (3.0 * h_divdiv_nz * inv_k2_nz - h_tr_nz)\n        \n        delta_ij = np.identity(3).reshape(3, 3, 1)\n        k_outer_k_nz = np.einsum('i...,j...->ij...', k_vec_nz, k_vec_nz)\n        S_tilde[..., nonzero_k_mask] = delta_ij * a_nz + k_outer_k_nz * b_nz\n\n        # --- Vector part (V_tilde) for k != 0 ---\n        v_j_nz = np.einsum('i...,ij...->j...', 1j * k_vec_nz, h_tilde_nz) # v_j = i k^i h_ij\n        v_dot_k_nz = np.einsum('i...,i...->...', k_vec_nz, v_j_nz) # k dot v\n        \n        v_transverse_nz = v_j_nz - k_vec_nz * v_dot_k_nz * inv_k2_nz\n        \n        # F_j = i * v_j_perp / k^2\n        F_j_nz = 1j * v_transverse_nz * inv_k2_nz\n        \n        term1 = np.einsum('i...,j...->ij...', 1j * k_vec_nz, F_j_nz)\n        V_tilde[..., nonzero_k_mask] = term1 + term1.transpose(1, 0, 2)\n\n    # Step 5: Handle the k = 0 mode according to the specified convention.\n    S_tilde[:, :, 0, 0, 0] = h_tilde[:, :, 0, 0, 0]\n    V_tilde[:, :, 0, 0, 0] = 0.0\n\n    # Step 6: The tensor part is the remainder.\n    T_tilde = h_tilde - S_tilde - V_tilde\n    \n    # Step 7: Inverse transform to get real-space fields.\n    S_ij = np.fft.ifftn(S_tilde, axes=(-3, -2, -1)).real\n    V_ij = np.fft.ifftn(V_tilde, axes=(-3, -2, -1)).real\n    T_ij = np.fft.ifftn(T_tilde, axes=(-3, -2, -1)).real\n\n    return S_ij, V_ij, T_ij\n\ndef generate_scalar_field(N, L, k0, k1):\n    k_coords = 2 * np.pi * np.fft.fftfreq(N, d=L/N)\n    kx, ky, kz = np.meshgrid(k_coords, k_coords, k_coords, indexing='ij')\n    k_squared = kx**2 + ky**2 + kz**2\n    k_abs = np.sqrt(k_squared)\n    \n    psi = np.exp(-(k_abs/k0)**2)\n    psi[0,0,0] = 1.2\n    E = 0.3 * np.exp(-(k_abs/k1)**2)\n    \n    delta_ij = np.identity(3).reshape(3,3,1,1,1)\n    k_vec = np.stack((kx, ky, kz), axis=0)\n    k_outer_k = np.einsum('i...,j...->ij...', k_vec, k_vec)\n    \n    h_S_tilde = 2.0 * delta_ij * psi - 2.0 * k_outer_k * E\n    return h_S_tilde\n\ndef generate_vector_field(N, L, k0):\n    k_coords = 2 * np.pi * np.fft.fftfreq(N, d=L/N)\n    kx, ky, kz = np.meshgrid(k_coords, k_coords, k_coords, indexing='ij')\n    k_vec = np.stack((kx, ky, kz), axis=0)\n    k_squared = kx**2 + ky**2 + kz**2\n    k_abs = np.sqrt(k_squared)\n\n    h_V_tilde = np.zeros((3,3,N,N,N), dtype=complex)\n    nonzero_k_mask = k_squared > 1e-12\n    \n    inv_k2 = np.divide(1.0, k_squared, where=nonzero_k_mask)\n    \n    a_vec = np.array([0,0,1]).reshape(3,1,1,1)\n    k_dot_a = kz\n    n_vec = a_vec - k_vec * k_dot_a * inv_k2\n\n    z_axis_mask = (np.abs(kx)  1e-9)  (np.abs(ky)  1e-9)  nonzero_k_mask\n    if np.any(z_axis_mask):\n        a_fb = np.array([0,1,0]).reshape(3,1,1,1)\n        k_dot_a_fb = ky\n        n_fb = a_fb - k_vec * k_dot_a_fb * inv_k2\n        n_vec[..., z_axis_mask] = n_fb[..., z_axis_mask]\n\n    n_norm = np.linalg.norm(n_vec, axis=0)\n    F_vec = np.zeros_like(k_vec, dtype=complex)\n    AF = np.exp(-(k_abs/k0)**2)\n\n    valid_mask = (n_norm > 1e-12)  nonzero_k_mask\n    F_vec[..., valid_mask] = (AF * np.divide(n_vec, n_norm, where=valid_mask))[..., valid_mask]\n    \n    k_otimes_F = np.einsum('i...,j...->ij...', k_vec, F_vec)\n    h_V_tilde = 1j * (k_otimes_F + k_otimes_F.transpose(1,0,2,3,4))\n    \n    return h_V_tilde\n\ndef generate_tensor_field(N, L, k0):\n    k_coords = 2 * np.pi * np.fft.fftfreq(N, d=L/N)\n    kx, ky, kz = np.meshgrid(k_coords, k_coords, k_coords, indexing='ij')\n    k_vec = np.stack((kx, ky, kz), axis=0)\n    k_squared = kx**2 + ky**2 + kz**2\n    k_abs = np.sqrt(k_squared)\n\n    h_T_tilde = np.zeros((3,3,N,N,N), dtype=complex)\n    nonzero_k_mask = k_squared > 1e-12\n    \n    inv_k2 = np.divide(1.0, k_squared, where=nonzero_k_mask)\n    C = np.diag([1.0, -1.0, 0.0]).reshape(3,3,1,1,1)\n    delta_ij = np.identity(3).reshape(3,3,1,1,1)\n    \n    P_op = np.zeros_like(h_T_tilde, dtype=float)\n    k_outer_k = np.einsum('i...,j...->ij...', k_vec, k_vec)\n    P_op[..., nonzero_k_mask] = (delta_ij - k_outer_k * inv_k2)[..., nonzero_k_mask]\n\n    PPC = np.einsum('il...,lm...,mj...->ij...', P_op, C, P_op) # P C P\n    P_trace_C = np.einsum('lm...,lm...->...', P_op, C)\n    Lambda_C = PPC - 0.5 * P_op * P_trace_C[np.newaxis, np.newaxis, ...]\n\n    AT = np.exp(-(k_abs/k0)**2)\n    h_T_tilde = AT * Lambda_C\n    h_T_tilde[..., ~nonzero_k_mask] = 0.0\n\n    return h_T_tilde\n\ndef generate_test_case(test_id, N):\n    if test_id == 1:\n        L, k0, k1 = 1.0, 4.0, 3.0\n        h_S_tilde = generate_scalar_field(N, L, k0, k1)\n        h_V_tilde = np.zeros_like(h_S_tilde)\n        h_T_tilde = np.zeros_like(h_S_tilde)\n    elif test_id == 2:\n        L, k0 = 1.0, 5.0\n        h_V_tilde = generate_vector_field(N, L, k0)\n        h_S_tilde = np.zeros_like(h_V_tilde)\n        h_T_tilde = np.zeros_like(h_V_tilde)\n    elif test_id == 3:\n        L, k0 = 1.0, 4.0\n        h_T_tilde = generate_tensor_field(N, L, k0)\n        h_S_tilde = np.zeros_like(h_T_tilde)\n        h_V_tilde = np.zeros_like(h_T_tilde)\n    elif test_id == 4:\n        L = 1.0\n        h_S_tilde = generate_scalar_field(N, L, 4.0, 3.0)\n        h_V_tilde = generate_vector_field(N, L, 5.0)\n        h_T_tilde = generate_tensor_field(N, L, 4.0)\n    else:\n        raise ValueError(\"Invalid test_id\")\n\n    h_total_tilde = h_S_tilde + h_V_tilde + h_T_tilde\n    \n    H = np.fft.ifftn(h_total_tilde, axes=(-3,-2,-1)).real\n    H_S = np.fft.ifftn(h_S_tilde, axes=(-3,-2,-1)).real\n    H_V = np.fft.ifftn(h_V_tilde, axes=(-3,-2,-1)).real\n    H_T = np.fft.ifftn(h_T_tilde, axes=(-3,-2,-1)).real\n    \n    return H, H_S, H_V, H_T, L\n\ndef solve():\n    results = []\n\n    # Test 1\n    H1, _, _, _, L1 = generate_test_case(1, N=8)\n    S1, V1, T1 = svt_decomposition(H1, L1)\n    norm_H1 = l2_norm(H1)\n    e_1_S = l2_norm(S1 - H1) / norm_H1\n    r_1_V = l2_norm(V1) / norm_H1\n    r_1_T = l2_norm(T1) / norm_H1\n    results.extend([e_1_S, r_1_V, r_1_T])\n\n    # Test 2\n    H2, _, _, _, L2 = generate_test_case(2, N=8)\n    S2, V2, T2 = svt_decomposition(H2, L2)\n    norm_H2 = l2_norm(H2)\n    r_2_S = l2_norm(S2) / norm_H2\n    e_2_V = l2_norm(V2 - H2) / norm_H2\n    r_2_T = l2_norm(T2) / norm_H2\n    results.extend([r_2_S, e_2_V, r_2_T])\n\n    # Test 3\n    H3, _, _, _, L3 = generate_test_case(3, N=9)\n    S3, V3, T3 = svt_decomposition(H3, L3)\n    norm_H3 = l2_norm(H3)\n    r_3_S = l2_norm(S3) / norm_H3\n    r_3_V = l2_norm(V3) / norm_H3\n    e_3_T = l2_norm(T3 - H3) / norm_H3\n    results.extend([r_3_S, r_3_V, e_3_T])\n\n    # Test 4\n    H4, H4_S, H4_V, H4_T, L4 = generate_test_case(4, N=8)\n    S4, V4, T4 = svt_decomposition(H4, L4)\n    norm_H4_S = l2_norm(H4_S)\n    norm_H4_V = l2_norm(H4_V)\n    norm_H4_T = l2_norm(H4_T)\n    \n    e_4_S = l2_norm(S4 - H4_S) / norm_H4_S if norm_H4_S > 1e-15 else l2_norm(S4 - H4_S)\n    e_4_V = l2_norm(V4 - H4_V) / norm_H4_V if norm_H4_V > 1e-15 else l2_norm(V4 - H4_V)\n    e_4_T = l2_norm(T4 - H4_T) / norm_H4_T if norm_H4_T > 1e-15 else l2_norm(T4 - H4_T)\n    results.extend([e_4_S, e_4_V, e_4_T])\n\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3485225"}]}