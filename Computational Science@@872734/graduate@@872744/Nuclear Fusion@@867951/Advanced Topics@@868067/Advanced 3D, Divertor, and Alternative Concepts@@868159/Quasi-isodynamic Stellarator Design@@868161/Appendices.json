{"hands_on_practices": [{"introduction": "The magnetic field strength $B$ on a stellarator's flux surface is fundamentally described by a Fourier series. This hands-on practice demonstrates the power of this representation by showing how the superposition of just two helical modes can generate remarkably diverse magnetic topologies [@problem_id:3715773]. By computationally adjusting the relative phase between these modes, you will directly manipulate the orientation of the field's iso-contours, a fundamental technique that designers use to sculpt a magnetic field towards the desired quasi-isodynamic state.", "problem": "You are given a simplified, magnetostatic representation of magnetic field strength on a single flux surface in Boozer coordinates, where the poloidal angle is $\\theta \\in [0,2\\pi)$ and the toroidal angle is $\\zeta \\in [0,2\\pi)$. The magnetic field strength is modeled as a superposition of two dominant helical Fourier modes with a phase difference. Specifically, define\n$$\nB(\\theta,\\zeta) = B_0\\left[1 + \\epsilon_1 \\cos\\left(m_1 \\theta - n_1 \\zeta + \\phi_1\\right) + \\epsilon_2 \\cos\\left(m_2 \\theta - n_2 \\zeta + \\phi_2\\right)\\right],\n$$\nwhere $B_0$ is a constant baseline field strength, $\\epsilon_1$ and $\\epsilon_2$ are small dimensionless amplitudes, $(m_1,n_1)$ and $(m_2,n_2)$ are integer mode numbers, and $\\phi_1$ and $\\phi_2$ are phases. All angles in this problem must be treated in radians.\n\nStarting from the following fundamental and widely used bases:\n- Magnetostatic equilibrium on a flux surface in Boozer coordinates implies that $B(\\theta,\\zeta)$ can be expanded as a Fourier series in $(\\theta,\\zeta)$.\n- Iso-contours of $B$ are orthogonal to $\\nabla B$; therefore, the local tangent direction of an iso-contour at a point $(\\theta,\\zeta)$ is proportional to $(-\\partial B/\\partial \\zeta,\\partial B/\\partial \\theta)$.\n- The Quasi-Isodynamic (QI) property refers to configurations where, on a flux surface, the magnetic field strength $B$ has poloidally closed contours that minimize bounce-averaged radial drifts for trapped particles. In this simplified analysis, we approximate the QI tendency by quantifying the predominance of poloidal orientation in the $B$ iso-contours.\n\nYour task is to analyze how changing the phase difference $\\Delta \\phi = \\phi_2 - \\phi_1$ between the two modes alters the topology of $B$-contours and the Quasi-Isodynamic (QI) tendency, for a fixed set of $(m_1,n_1)$ and $(m_2,n_2)$ values and amplitudes $(\\epsilon_1,\\epsilon_2)$.\n\nAlgorithm to implement:\n1. Discretize the domain with $N_\\theta \\times N_\\zeta$ grid points, where $N_\\theta = N_\\zeta = 256$, and $\\theta_i = 2\\pi i/N_\\theta$, $\\zeta_j = 2\\pi j/N_\\zeta$ for integers $i,j$.\n2. Evaluate $B(\\theta,\\zeta)$ on the grid.\n3. Approximate partial derivatives using second-order central differences with periodic boundary conditions:\n   $$\n   \\frac{\\partial B}{\\partial \\theta}\\Big|_{i,j} \\approx \\frac{B(\\theta_{i+1},\\zeta_j) - B(\\theta_{i-1},\\zeta_j)}{2\\Delta \\theta}, \\quad \\frac{\\partial B}{\\partial \\zeta}\\Big|_{i,j} \\approx \\frac{B(\\theta_i,\\zeta_{j+1}) - B(\\theta_i,\\zeta_{j-1})}{2\\Delta \\zeta},\n   $$\n   where $\\Delta \\theta = 2\\pi/N_\\theta$ and $\\Delta \\zeta = 2\\pi/N_\\zeta$.\n4. Define the (unnormalized) tangent to local $B$-contours by $\\mathbf{t} = (-\\partial B/\\partial \\zeta,\\partial B/\\partial \\theta)$ and normalize it pointwise to unit length to get components $(t_\\theta,t_\\zeta)$, with\n   $$\n   t_\\theta = \\frac{\\partial B/\\partial \\theta}{\\sqrt{\\left(\\partial B/\\partial \\theta\\right)^2 + \\left(\\partial B/\\partial \\zeta\\right)^2}},\\quad\n   t_\\zeta = \\frac{-\\partial B/\\partial \\zeta}{\\sqrt{\\left(\\partial B/\\partial \\theta\\right)^2 + \\left(\\partial B/\\partial \\zeta\\right)^2}}.\n   $$\n5. To avoid numerical singularities, discard points where the gradient magnitude is too small. Specifically, define the mask where\n   $$\n   \\sqrt{\\left(\\partial B/\\partial \\theta\\right)^2 + \\left(\\partial B/\\partial \\zeta\\right)^2} > f \\cdot \\max_{\\theta,\\zeta} \\sqrt{\\left(\\partial B/\\partial \\theta\\right)^2 + \\left(\\partial B/\\partial \\zeta\\right)^2},\n   $$\n   with $f = 10^{-3}$.\n6. Over the retained points, compute two scalar metrics:\n   - The orientation ratio\n     $$\n     R = \\frac{\\langle |t_\\zeta| \\rangle}{\\langle |t_\\theta| \\rangle},\n     $$\n     where $\\langle \\cdot \\rangle$ denotes the average over retained points. Values $R  1$ indicate that iso-contours are, on average, more poloidally oriented than toroidally oriented.\n   - The QI quality index\n     $$\n     Q = \\frac{\\#\\text{ of retained points with } |t_\\zeta|  |t_\\theta|}{\\#\\text{ of retained points}},\n     $$\n     which is a dimensionless fraction in $[0,1]$. Larger $Q$ indicates a stronger tendency toward poloidally closed $B$-contours, which is used here as a proxy for the Quasi-Isodynamic property.\n\nTest suite:\nUse $B_0 = 1$, $\\phi_1 = 0$, and set $\\phi_2 = \\Delta \\phi$ as specified. Angles are in radians. Evaluate the following four cases:\n- Case $1$ (helical counter-winding pair, in-phase):\n  $(m_1,n_1) = (2,5)$, $(m_2,n_2) = (2,-5)$, $\\epsilon_1 = 0.08$, $\\epsilon_2 = 0.08$, $\\Delta \\phi = 0$.\n- Case $2$ (helical counter-winding pair, quarter-phase shift):\n  $(m_1,n_1) = (2,5)$, $(m_2,n_2) = (2,-5)$, $\\epsilon_1 = 0.08$, $\\epsilon_2 = 0.08$, $\\Delta \\phi = \\pi/2$.\n- Case $3$ (helical mode with poloidal-only companion, out-of-phase):\n  $(m_1,n_1) = (2,5)$, $(m_2,n_2) = (1,0)$, $\\epsilon_1 = 0.06$, $\\epsilon_2 = 0.12$, $\\Delta \\phi = \\pi$.\n- Case $4$ (two unrelated helical modes, generic phase):\n  $(m_1,n_1) = (3,1)$, $(m_2,n_2) = (4,7)$, $\\epsilon_1 = 0.07$, $\\epsilon_2 = 0.05$, $\\Delta \\phi = \\pi/3$.\n\nFinal output specification:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with the two floats $R$ and $Q$ for each case concatenated in order:\n$$\n[\\;R_1,Q_1,R_2,Q_2,R_3,Q_3,R_4,Q_4\\;].\n$$\nAll output values are dimensionless. Angles must be treated in radians internally. No other text should be printed.", "solution": "The problem requires the numerical analysis of a simplified model for the magnetic field strength $B$ on a stellarator flux surface. The goal is to quantify how the relative phase, $\\Delta\\phi$, between two helical Fourier modes of the field affects the orientation of its iso-contours, which serves as a proxy for the Quasi-Isodynamic (QI) property. The solution involves discretizing the domain, calculating partial derivatives, and evaluating two specific metrics: the orientation ratio $R$ and the QI quality index $Q$.\n\nThe magnetic field strength $B$ on a flux surface described by Boozer coordinates $(\\theta, \\zeta)$ is modeled as:\n$$\nB(\\theta,\\zeta) = B_0\\left[1 + \\epsilon_1 \\cos\\left(m_1 \\theta - n_1 \\zeta + \\phi_1\\right) + \\epsilon_2 \\cos\\left(m_2 \\theta - n_2 \\zeta + \\phi_2\\right)\\right]\n$$\nHere, $\\theta$ is the poloidal angle and $\\zeta$ is the toroidal angle, both in $[0, 2\\pi)$. The parameters $B_0, \\epsilon_1, \\epsilon_2, m_1, n_1, m_2, n_2, \\phi_1, \\phi_2$ are constants defining the specific magnetic configuration. The analysis is performed for four distinct cases by varying these parameters.\n\nThe fundamental principle for analyzing the contour topology is that the gradient of a scalar field, $\\nabla B(\\theta, \\zeta)$, is everywhere perpendicular to the iso-contours of that field (lines of constant $B$). The gradient vector in the $(\\theta, \\zeta)$ coordinate system is $\\nabla B = (\\partial B / \\partial \\theta) \\hat{\\theta} + (\\partial B / \\partial \\zeta) \\hat{\\zeta}$. A vector tangent to the local iso-contour, $\\mathbf{t}$, must be orthogonal to $\\nabla B$. A convenient choice for such a tangent vector is $\\mathbf{t} = (\\partial B / \\partial \\theta) \\hat{\\theta} - (\\partial B / \\partial \\zeta) \\hat{\\zeta}$, or in component form, proportional to $(-\\partial B/\\partial \\zeta, \\partial B/\\partial \\theta)$. The problem uses this component form in a $(\\theta, \\zeta)$ plane representation of the flux surface.\n\nThe algorithm proceeds as follows:\n\n1.  **Discretization**: The continuous domain $(\\theta, \\zeta) \\in [0, 2\\pi) \\times [0, 2\\pi)$ is discretized into a uniform grid of $N_\\theta \\times N_\\zeta$ points, with $N_\\theta = N_\\zeta = 256$. The grid coordinates are $\\theta_i = 2\\pi i/N_\\theta$ and $\\zeta_j = 2\\pi j/N_\\zeta$. The field $B(\\theta, \\zeta)$ is evaluated at each point $(\\theta_i, \\zeta_j)$ to yield a $256 \\times 256$ matrix.\n\n2.  **Numerical Differentiation**: The partial derivatives $\\partial B/\\partial \\theta$ and $\\partial B/\\partial \\zeta$ are required to determine the tangent vector. These are approximated using a second-order central difference scheme with periodic boundary conditions. For a grid point $(i, j)$, the derivatives are:\n    $$\n    \\frac{\\partial B}{\\partial \\theta}\\Big|_{i,j} \\approx \\frac{B_{i+1,j} - B_{i-1,j}}{2\\Delta \\theta}, \\quad \\frac{\\partial B}{\\partial \\zeta}\\Big|_{i,j} \\approx \\frac{B_{i,j+1} - B_{i,j-1}}{2\\Delta \\zeta}\n    $$\n    where $\\Delta\\theta = 2\\pi/N_\\theta$ and $\\Delta\\zeta = 2\\pi/N_\\zeta$. The periodicity is handled by wrapping around the grid indices (e.g., $i=N_\\theta$ becomes $i=0$). In the implementation, this is efficiently achieved using `numpy.roll`.\n\n3.  **Tangent Vector Normalization and Masking**: The normalized tangent vector components, $(t_\\theta, t_\\zeta)$, are calculated pointwise. The $\\theta$-component is $t_\\theta$ and the $\\zeta$-component is $t_\\zeta$:\n    $$\n    t_\\theta = \\frac{\\partial B/\\partial \\theta}{\\sqrt{\\left(\\partial B/\\partial \\theta\\right)^2 + \\left(\\partial B/\\partial \\zeta\\right)^2}}, \\quad t_\\zeta = \\frac{-\\partial B/\\partial \\zeta}{\\sqrt{\\left(\\partial B/\\partial \\theta\\right)^2 + \\left(\\partial B/\\partial \\zeta\\right)^2}}\n    $$\n    At points where $\\nabla B = 0$ (i.e., local extrema or saddle points of $B$), the tangent is undefined. To prevent numerical instability (division by zero) and to analyze only regions with well-defined contours, points where the gradient magnitude is very small are excluded. A mask is created to retain only points where the gradient magnitude exceeds a threshold:\n    $$\n    \\sqrt{\\left(\\frac{\\partial B}{\\partial \\theta}\\right)^2 + \\left(\\frac{\\partial B}{\\partial \\zeta}\\right)^2} > f \\cdot \\max_{\\text{grid}} \\sqrt{\\left(\\frac{\\partial B}{\\partial \\theta}\\right)^2 + \\left(\\frac{\\partial B}{\\partial \\zeta}\\right)^2}\n    $$\n    with the fraction $f$ set to $10^{-3}$. All subsequent calculations are performed only on this subset of \"retained\" points.\n\n4.  **Metric Computation**: Two metrics are computed over the set of retained points to quantify the QI tendency.\n    -   The **orientation ratio** $R$ is the ratio of the average absolute toroidal tangent component to the average absolute poloidal tangent component:\n        $$\n        R = \\frac{\\langle |t_\\zeta| \\rangle}{\\langle |t_\\theta| \\rangle}\n        $$\n        A value of $R  1$ indicates that, on average, the iso-contours are more aligned with the poloidal ($\\theta$) direction than the toroidal ($\\zeta$) direction.\n    -   The **QI quality index** $Q$ measures the fraction of retained points where the tangent vector is more poloidally than toroidally oriented:\n        $$\n        Q = \\frac{\\#\\{\\text{points where } |t_\\zeta|  |t_\\theta|\\}}{\\text{Total } \\# \\text{ of retained points}}\n        $$\n        A value of $Q$ close to $1$ signifies a strong prevalence of poloidally-closed contours, a key feature of quasi-isodynamic configurations.\n\nFor each of the four test cases, these steps are executed, and the resulting pair of dimensionless metrics $(R, Q)$ is calculated. The final output concatenates these results into a single list.", "answer": "```python\nimport numpy as np\n\ndef calculate_metrics(params):\n    \"\"\"\n    Calculates QI metrics for a given set of magnetic field parameters.\n    \"\"\"\n    m1, n1, m2, n2, eps1, eps2, delta_phi = params\n\n    # 1. Discretization\n    N = 256\n    phi1 = 0.0\n    B0 = 1.0\n    f = 1e-3\n    \n    theta_vals = (2 * np.pi / N) * np.arange(N)\n    zeta_vals = (2 * np.pi / N) * np.arange(N)\n    THETA, ZETA = np.meshgrid(theta_vals, zeta_vals, indexing='ij')\n\n    delta_theta = 2 * np.pi / N\n    delta_zeta = 2 * np.pi / N\n\n    # 2. Evaluate B on the grid\n    arg1 = m1 * THETA - n1 * ZETA + phi1\n    arg2 = m2 * THETA - n2 * ZETA + delta_phi\n    B = B0 * (1.0 + eps1 * np.cos(arg1) + eps2 * np.cos(arg2))\n\n    # 3. Approximate partial derivatives using central differences\n    # np.roll handles periodic boundary conditions efficiently.\n    # axis=0 corresponds to theta, axis=1 corresponds to zeta due to indexing='ij'.\n    dB_dtheta = (np.roll(B, -1, axis=0) - np.roll(B, 1, axis=0)) / (2 * delta_theta)\n    dB_dzeta = (np.roll(B, -1, axis=1) - np.roll(B, 1, axis=1)) / (2 * delta_zeta)\n\n    # Calculate gradient magnitude\n    grad_B_mag = np.sqrt(dB_dtheta**2 + dB_dzeta**2)\n    \n    # 5. Define mask to exclude points with small gradients\n    max_grad_mag = np.max(grad_B_mag)\n    if max_grad_mag == 0:\n        return 0.0, 0.0 # Field is constant, no contours to analyze.\n    \n    threshold = f * max_grad_mag\n    mask = grad_B_mag > threshold\n\n    num_total_retained = np.sum(mask)\n    if num_total_retained == 0:\n        return 0.0, 0.0 # No points passed the threshold.\n    \n    # Apply mask to select only retained points\n    grad_theta_retained = dB_dtheta[mask]\n    grad_zeta_retained = dB_dzeta[mask]\n    grad_mag_retained = grad_B_mag[mask]\n    \n    # 4. Calculate normalized tangent components for retained points\n    t_theta = grad_theta_retained / grad_mag_retained\n    t_zeta = -grad_zeta_retained / grad_mag_retained\n\n    # 6. Compute scalar metrics\n    # Orientation Ratio R\n    mean_abs_t_theta = np.mean(np.abs(t_theta))\n    if mean_abs_t_theta == 0:\n        # Avoid division by zero if all tangents are purely toroidal.\n        R = np.inf if np.mean(np.abs(t_zeta)) > 0 else 0.0\n    else:\n        R = np.mean(np.abs(t_zeta)) / mean_abs_t_theta\n    \n    # QI Quality Index Q\n    num_qi_points = np.sum(np.abs(t_zeta)  np.abs(t_theta))\n    Q = num_qi_points / num_total_retained\n    \n    return R, Q\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test suite parameters\n    test_cases = [\n        # Case 1: (m1,n1)=(2,5), (m2,n2)=(2,-5), e1=0.08, e2=0.08, dphi=0\n        (2, 5, 2, -5, 0.08, 0.08, 0.0),\n        # Case 2: (m1,n1)=(2,5), (m2,n2)=(2,-5), e1=0.08, e2=0.08, dphi=pi/2\n        (2, 5, 2, -5, 0.08, 0.08, np.pi / 2),\n        # Case 3: (m1,n1)=(2,5), (m2,n2)=(1,0), e1=0.06, e2=0.12, dphi=pi\n        (2, 5, 1, 0, 0.06, 0.12, np.pi),\n        # Case 4: (m1,n1)=(3,1), (m2,n2)=(4,7), e1=0.07, e2=0.05, dphi=pi/3\n        (3, 1, 4, 7, 0.07, 0.05, np.pi / 3),\n    ]\n\n    results = []\n    for case in test_cases:\n        R, Q = calculate_metrics(case)\n        results.append(R)\n        results.append(Q)\n\n    # Format and print the final output as a single line\n    print(f\"[{','.join(f'{x:.8f}' for x in results)}]\")\n\nsolve()\n```", "id": "3715773"}, {"introduction": "Once a magnetic field has been shaped, we need a quantitative method to evaluate its performance. The \"gold standard\" for assessing the confinement of trapped particles is the near-constancy of the second adiabatic invariant, $J_{\\parallel}$, across a given flux surface. This practice transitions from the geometric analysis of field contours to the direct physical consequences of that geometry [@problem_id:3715774]. You will compute the variation of $J_{\\parallel}$ to directly measure and compare the superior confinement properties of a model quasi-isodynamic design against a quasi-symmetric one.", "problem": "You are given two dimensionless model magnetic field spectra, one intended to represent a Quasi-Symmetric (QS) configuration and one intended to represent a Quasi-Isodynamic (QI) configuration, on a torus parameterized by poloidal angle $\\theta$ and toroidal angle $\\zeta$, both in radians. The QS model uses a single helical harmonic, while the QI model uses predominantly toroidal variation with weak poloidal variation. The field-line label is $\\alpha = \\theta - \\iota \\,\\zeta$, where $\\iota$ is the rotational transform, such that along a field line $\\theta(\\zeta) = \\alpha + \\iota \\,\\zeta$. In dimensionless guiding-center theory, the second adiabatic invariant $J_{\\parallel}$ for a trapped particle with dimensionless energy $E$ and pitch parameter $\\lambda$ is defined as the bounce integral $J_{\\parallel}(\\alpha, E, \\lambda) = \\oint v_{\\parallel} \\, dl$, where the parallel speed is $v_{\\parallel}(\\zeta) = \\sqrt{2E}\\,\\sqrt{\\max\\{0,\\,1 - \\lambda \\, B(\\theta(\\zeta),\\zeta)\\}}$ and the line element factor is taken as $dl/d\\zeta = 1$ for simplicity. Use radians for all angles, and treat all quantities as dimensionless.\n\nYour task is to compute the numerical central finite-difference approximation to the derivative $\\partial J_{\\parallel} / \\partial \\alpha$ for both spectra across multiple test cases, and then assess which design better confines trapped particles by comparing the magnitudes of these derivatives. A smaller magnitude of $\\partial J_{\\parallel} / \\partial \\alpha$ implies better confinement of trapped particles.\n\nUse the following spectra with parameters that are scientifically plausible and self-consistent for a reduced model:\n- QS spectrum: $B_{\\mathrm{QS}}(\\theta,\\zeta) = B_0 \\left[ 1 + \\varepsilon \\cos(m\\,\\theta - n\\,\\zeta) \\right]$.\n- QI spectrum: $B_{\\mathrm{QI}}(\\theta,\\zeta) = B_0 \\left[ 1 + \\varepsilon_{\\zeta}\\cos(n\\,\\zeta) + \\varepsilon_{\\theta}\\cos(m\\,\\theta) \\right]$.\n\nUse $B_0 = 1$, $\\varepsilon = 0.3$, $\\varepsilon_{\\zeta} = 0.25$, $\\varepsilon_{\\theta} = 0.05$, $m = 1$, $n = 4$, and $\\iota = 0.45$. These choices make both spectra have the same extrema, with $B_{\\min} \\approx 0.7$ and $B_{\\max} \\approx 1.3$, ensuring that trapped-particle conditions are comparable across the two designs for the chosen pitches.\n\nDefine the bounce invariant numerically as\n$$\nJ_{\\parallel}(\\alpha, E, \\lambda) = 2 \\sqrt{2E}\\,\\int_{0}^{2\\pi} \\sqrt{\\max\\{0,\\,1 - \\lambda\\,B(\\alpha + \\iota \\zeta, \\zeta)\\}}\\, d\\zeta,\n$$\nwhich integrates the positive part of the parallel speed over one full period and doubles it to cover the full bounce cycle between turning points. Approximate the derivative by the central difference\n$$\n\\frac{\\partial J_{\\parallel}}{\\partial \\alpha}(\\alpha, E, \\lambda) \\approx \\frac{J_{\\parallel}(\\alpha + \\delta\\alpha, E, \\lambda) - J_{\\parallel}(\\alpha - \\delta\\alpha, E, \\lambda)}{2\\,\\delta\\alpha},\n$$\nwith a small step $\\delta\\alpha$.\n\nImplement the numerical integral using a uniform grid in $\\zeta \\in [0, 2\\pi]$ with a sufficiently fine resolution to capture bounce turning points induced by the spectrum. Use $\\delta\\alpha = 10^{-4}$ and a grid of $N = 20001$ points in $\\zeta$.\n\nFor each test case below, compute $\\left|\\partial J_{\\parallel}/\\partial \\alpha\\right|$ for both spectra and output a boolean indicating whether the QI spectrum yields a strictly smaller magnitude than the QS spectrum (true meaning QI is better for that case). If the particle is not trapped for either spectrum in a given case, set $J_{\\parallel} = 0$ in the computation, which will lead to a derivative of $0$, and proceed with the comparison as stated.\n\nTest suite of parameter triples $(\\alpha, E, \\lambda)$, all dimensionless and with angles in radians:\n1. $(\\alpha, E, \\lambda) = (0.7, 0.5, 1.0)$, a typical trapped case.\n2. $(\\alpha, E, \\lambda) = (2.2, 1.5, 1.3)$, a case closer to the upper trapping boundary.\n3. $(\\alpha, E, \\lambda) = (3.0, 0.2, 0.77)$, a case near the lower trapping boundary.\n4. $(\\alpha, E, \\lambda) = (1.1, 1.0, 0.9)$, another typical trapped case.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$, where each entry is a boolean corresponding to the respective test case.", "solution": "The problem requires a comparison of trapped particle confinement in two simplified stellarator magnetic field configurations: a Quasi-Symmetric (QS) model and a Quasi-Isodynamic (QI) model. The core principle being tested is that superior confinement of trapped particles in a magnetic fusion device is achieved when the second adiabatic invariant, $J_{\\parallel}$, is nearly constant across a given magnetic flux surface. A magnetic flux surface is a surface on which the magnetic field lines lie. In this simplified model, the field-line label $\\alpha$ acts as a proxy for the spatial coordinate on the flux surface, perpendicular to the magnetic field line itself. Therefore, better confinement corresponds to a smaller magnitude of the gradient of $J_{\\parallel}$ with respect to $\\alpha$, i.e., a smaller value of $|\\partial J_{\\parallel}/\\partial\\alpha|$. Our task is to calculate this quantity for both the QS and QI magnetic spectra for a given set of test parameters and determine which configuration yields a smaller value, indicating better performance for confining trapped particles.\n\nFirst, we define the mathematical components of the problem. The magnetic field-line trajectories are given by $\\theta(\\zeta) = \\alpha + \\iota\\,\\zeta$, where $\\theta$ is the poloidal angle, $\\zeta$ is the toroidal angle, $\\alpha$ is the field-line label, and $\\iota$ is the rotational transform. All angles are in radians.\n\nThe two model magnetic field spectra are given as:\n1.  Quasi-Symmetric (QS) spectrum: $B_{\\mathrm{QS}}(\\theta,\\zeta) = B_0 \\left[ 1 + \\varepsilon \\cos(m\\,\\theta - n\\,\\zeta) \\right]$. This form depends on a single helical angle $m\\theta - n\\zeta$, characteristic of a quasi-symmetric design.\n2.  Quasi-Isodynamic (QI) spectrum: $B_{\\mathrm{QI}}(\\theta,\\zeta) = B_0 \\left[ 1 + \\varepsilon_{\\zeta}\\cos(n\\,\\zeta) + \\varepsilon_{\\theta}\\cos(m\\,\\theta) \\right]$. This form is dominated by toroidal variation, which is a feature of certain quasi-isodynamic designs.\n\nThe problem specifies the following dimensionless parameters: $B_0 = 1$, $\\varepsilon = 0.3$, $\\varepsilon_{\\zeta} = 0.25$, $\\varepsilon_{\\theta} = 0.05$, $m = 1$, $n = 4$, and $\\iota = 0.45$.\n\nThe second adiabatic invariant, $J_{\\parallel}$, for a trapped particle with energy $E$ and pitch parameter $\\lambda$ is defined by the bounce integral of its parallel velocity, $v_{\\parallel}$, along a field line. The problem provides a specific numerical formulation, which integrates over one full toroidal period ($\\zeta \\in [0, 2\\pi]$) and doubles the result to account for the full bounce motion between turning points:\n$$\nJ_{\\parallel}(\\alpha, E, \\lambda) = 2 \\sqrt{2E}\\,\\int_{0}^{2\\pi} \\sqrt{\\max\\{0,\\,1 - \\lambda\\,B(\\alpha + \\iota \\zeta, \\zeta)\\}}\\, d\\zeta\n$$\nThe $\\max\\{0, \\dots\\}$ term ensures that the integrand is zero in regions where the particle is reflected (i.e., where $1 - \\lambda B  0$), which are outside the trapping well. If a particle is not trapped at all ($1 - \\lambda B \\le 0$ for all $\\zeta$), this integral correctly yields $J_{\\parallel} = 0$.\n\nTo evaluate the confinement quality, we must compute the derivative $\\partial J_{\\parallel}/\\partial\\alpha$. We will use the central finite-difference approximation with a small step size $\\delta\\alpha$:\n$$\n\\frac{\\partial J_{\\parallel}}{\\partial \\alpha}(\\alpha, E, \\lambda) \\approx \\frac{J_{\\parallel}(\\alpha + \\delta\\alpha, E, \\lambda) - J_{\\parallel}(\\alpha - \\delta\\alpha, E, \\lambda)}{2\\,\\delta\\alpha}\n$$\nThe problem specifies a step size of $\\delta\\alpha = 10^{-4}$.\n\nThe numerical procedure is as follows:\n1.  For each of the four test cases $(\\alpha, E, \\lambda)$ and for each magnetic spectrum ($B_{\\mathrm{QS}}$ and $B_{\\mathrm{QI}}$), we will calculate $J_{\\parallel}$.\n2.  The integral for $J_{\\parallel}$ will be computed numerically using the trapezoidal rule over a fine, uniform grid of $N=20001$ points for $\\zeta$ in the range $[0, 2\\pi]$.\n3.  To calculate the derivative $\\partial J_{\\parallel}/\\partial\\alpha$, we compute $J_{\\parallel}$ at two slightly perturbed values of the field-line label, $\\alpha + \\delta\\alpha$ and $\\alpha - \\delta\\alpha$.\n4.  We then substitute these two values into the central difference formula to get an approximation for $\\partial J_{\\parallel}/\\partial\\alpha$.\n5.  Finally, we take the absolute value of the derivatives for both spectra, $|\\partial J_{\\parallel}/\\partial\\alpha|_{\\mathrm{QS}}$ and $|\\partial J_{\\parallel}/\\partial\\alpha|_{\\mathrm{QI}}$.\n6.  The result for each test case is a boolean value indicating whether the QI configuration is superior, which is true if and only if $|\\partial J_{\\parallel}/\\partial\\alpha|_{\\mathrm{QI}}  |\\partial J_{\\parallel}/\\partial\\alpha|_{\\mathrm{QS}}$. This entire process will be implemented in a Python script, adhering strictly to the specified libraries and formatting.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares the gradient of the second adiabatic invariant for\n    Quasi-Symmetric (QS) and Quasi-Isodynamic (QI) stellarator magnetic fields.\n    \"\"\"\n\n    # Define physical and numerical constants from the problem statement\n    B0 = 1.0\n    EPSILON = 0.3\n    EPSILON_ZETA = 0.25\n    EPSILON_THETA = 0.05\n    M_MODE = 1\n    N_MODE = 4\n    IOTA = 0.45\n    \n    # Numerical parameters for the calculation\n    DELTA_ALPHA = 1e-4\n    N_POINTS = 20001\n    \n    # Define the grid for the toroidal angle zeta\n    ZETA_GRID = np.linspace(0, 2 * np.pi, N_POINTS)\n\n    # Define the model magnetic field spectra\n    def b_qs(theta, zeta):\n        \"\"\"QS spectrum: B = B0 * (1 + epsilon * cos(m*theta - n*zeta))\"\"\"\n        return B0 * (1 + EPSILON * np.cos(M_MODE * theta - N_MODE * zeta))\n\n    def b_qi(theta, zeta):\n        \"\"\"QI spectrum: B = B0 * (1 + epsilon_zeta*cos(n*zeta) + epsilon_theta*cos(m*theta))\"\"\"\n        return B0 * (1 + EPSILON_ZETA * np.cos(N_MODE * zeta) + EPSILON_THETA * np.cos(M_MODE * theta))\n\n    def compute_j_parallel(b_func, alpha, E, lambda_val):\n        \"\"\"\n        Computes the second adiabatic invariant J_parallel numerically.\n        The variable lambda is a keyword in Python, so lambda_val is used.\n        \"\"\"\n        if E == 0:\n            return 0.0\n            \n        # Calculate theta along the field line for the given alpha\n        theta = alpha + IOTA * ZETA_GRID\n        \n        # Calculate the magnetic field strength along the field line\n        b_values = b_func(theta, ZETA_GRID)\n        \n        # Calculate the integrand for J_parallel, handling the turning points\n        integrand = np.sqrt(np.maximum(0, 1 - lambda_val * b_values))\n        \n        # Perform the numerical integration using the trapezoidal rule\n        integral_val = np.trapz(integrand, ZETA_GRID)\n        \n        # Final formula for J_parallel\n        return 2 * np.sqrt(2 * E) * integral_val\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        (0.7, 0.5, 1.0),  # Case 1\n        (2.2, 1.5, 1.3),  # Case 2\n        (3.0, 0.2, 0.77), # Case 3\n        (1.1, 1.0, 0.9),  # Case 4\n    ]\n\n    results = []\n    for alpha, E, lambda_val in test_cases:\n        # --- QS Calculation ---\n        # J_parallel for alpha + delta_alpha\n        j_plus_qs = compute_j_parallel(b_qs, alpha + DELTA_ALPHA, E, lambda_val)\n        # J_parallel for alpha - delta_alpha\n        j_minus_qs = compute_j_parallel(b_qs, alpha - DELTA_ALPHA, E, lambda_val)\n        # Central difference for the derivative\n        dj_dalpha_qs = (j_plus_qs - j_minus_qs) / (2 * DELTA_ALPHA)\n\n        # --- QI Calculation ---\n        # J_parallel for alpha + delta_alpha\n        j_plus_qi = compute_j_parallel(b_qi, alpha + DELTA_ALPHA, E, lambda_val)\n        # J_parallel for alpha - delta_alpha\n        j_minus_qi = compute_j_parallel(b_qi, alpha - DELTA_ALPHA, E, lambda_val)\n        # Central difference for the derivative\n        dj_dalpha_qi = (j_plus_qi - j_minus_qi) / (2 * DELTA_ALPHA)\n        \n        # Compare the magnitudes of the derivatives\n        # A smaller magnitude implies better confinement\n        is_qi_better = np.abs(dj_dalpha_qi)  np.abs(dj_dalpha_qs)\n        results.append(is_qi_better)\n\n    # Format the output as a comma-separated list of booleans in brackets\n    # The str() of a boolean is 'True' or 'False' (capitalized)\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nsolve()\n```", "id": "3715774"}, {"introduction": "Designing a viable fusion reactor is an exercise in balancing competing objectives. For instance, a magnetic field configuration offering theoretically perfect particle confinement might require engineeringly infeasible magnet coils. This final practice simulates this real-world challenge by framing the design process as a multi-objective optimization problem [@problem_id:3715782]. You will learn to weigh a physics performance metric against an engineering cost proxy to identify the best compromise, a crucial skill in the practical development of modern stellarators.", "problem": "You are tasked with constructing and evaluating a simplified, yet physically grounded, multi-objective optimization to quantify the tradeoff between Quasi-Isodynamic (QI) stellarator metrics and coil complexity. The objective is to identify which magnetic field design, represented by a small set of Fourier harmonics, best balances the tendency toward quasi-isodynamic behavior against coil design simplicity under specified weights. Your final program must implement the described formulation and produce a single line result aggregating the answers for all provided test cases.\n\nStart from the guiding-center invariants and the definition of field-line labeling in Boozer coordinates. Use the following fundamental base:\n\n- The second adiabatic invariant $J_{\\parallel}$ is defined as the bounce integral $J_{\\parallel} = \\oint v_{\\parallel} \\, \\mathrm{d}l$, where $v_{\\parallel}$ is the parallel component of the particle velocity and $l$ is the coordinate along the magnetic field line.\n- The Quasi-Isodynamic (QI) requirement can be expressed as small variation of $J_{\\parallel}$ with respect to the field-line label, such that $|\\partial J_{\\parallel} / \\partial \\alpha|$ is small, where $\\alpha$ is the Boozer field-line label.\n- In Boozer coordinates, use $\\alpha = \\theta - \\iota \\, \\zeta$, where $\\theta$ is the poloidal angle, $\\zeta$ is the toroidal angle, and $\\iota$ is the rotational transform.\n- Assume a magnetic field strength model on a flux surface given by a truncated Fourier series\n$$\nB(\\theta,\\zeta) = B_0 \\left( 1 + \\sum_{k=1}^{K} A_k \\cos(m_k \\theta - n_k \\zeta) \\right),\n$$\nwhere $B_0$ is the reference magnetic field strength, $(m_k,n_k)$ are integer harmonic indices, and $A_k$ are the corresponding amplitudes. Take $B_0 = 1$ (dimensionless units).\n- Assume the particle speed has been normalized to $v=1$ and define the pitch parameter $\\lambda$ such that $v_{\\parallel}^2 = 1 - \\lambda B(\\theta,\\zeta)$. Model trapped-passing behavior by setting $v_{\\parallel}(\\theta,\\zeta) = \\sqrt{\\max\\{0,\\,1 - \\lambda B(\\theta,\\zeta)\\}}$.\n\nConstruct the QI variation metric as the root-mean-square of the derivative of $J_{\\parallel}$ with respect to $\\alpha$ across a uniform grid of $\\alpha$ values:\n$$\nQ = \\sqrt{\\frac{1}{N_\\alpha} \\sum_{j=1}^{N_\\alpha} \\left( \\frac{\\partial J_{\\parallel}(\\alpha_j)}{\\partial \\alpha} \\right)^2 },\n$$\nwith the finite-difference approximation for the derivative using periodic boundary conditions on $\\alpha \\in [0,2\\pi)$.\n\nApproximate $J_{\\parallel}(\\alpha)$ by integrating along a field line parameterized by $\\zeta \\in [0,2\\pi)$ using the field-line mapping $\\theta(\\zeta) = \\alpha + \\iota \\zeta$ and a constant line element factor such that\n$$\nJ_{\\parallel}(\\alpha) \\approx \\int_0^{2\\pi} \\sqrt{\\max\\{0,\\,1 - \\lambda B(\\alpha + \\iota \\zeta,\\,\\zeta)\\}} \\,\\mathrm{d}\\zeta,\n$$\nwhich is dimensionless under the stated normalizations. Use angle units in radians.\n\nDefine a coil complexity proxy by a weighted squared amplitude measure:\n$$\nC = \\sum_{k=1}^{K} w_k A_k^2, \\quad \\text{with} \\quad w_k = m_k^2 + n_k^2,\n$$\nwhich penalizes higher-order harmonics and thus represents increased coil complexity.\n\nForm a weighted-sum multi-objective scalarized cost for each candidate design:\n$$\n\\Phi = w_{\\text{QI}} \\, \\tilde{Q} + w_{\\text{coil}} \\, \\tilde{C},\n$$\nwhere $\\tilde{Q}$ and $\\tilde{C}$ are min-max normalized across all candidate designs being compared under the same test case,\n$$\n\\tilde{Q} = \\frac{Q - Q_{\\min}}{Q_{\\max} - Q_{\\min} + \\epsilon}, \\quad \\tilde{C} = \\frac{C - C_{\\min}}{C_{\\max} - C_{\\min} + \\epsilon},\n$$\nwith a small $\\epsilon$ to avoid division by zero. This normalization ensures that the weights $w_{\\text{QI}}$ and $w_{\\text{coil}}$ operate on comparable scales of the two objectives. All quantities are dimensionless.\n\nYour program must evaluate the following fixed set of harmonics and candidate amplitude vectors:\n- Harmonic set (with phases set to zero): $(m_k,n_k) \\in \\{(1,0),(0,1),(1,1),(2,1),(2,3)\\}$ for $k=1,\\dots,5$.\n- Candidate amplitude vectors $\\mathbf{A}$:\n    1. $\\mathbf{A}^{(0)} = [0.02, 0.03, 0.04, 0.00, 0.00]$\n    2. $\\mathbf{A}^{(1)} = [0.05, 0.03, 0.08, 0.04, 0.02]$\n    3. $\\mathbf{A}^{(2)} = [0.01, 0.02, 0.06, 0.00, 0.03]$\n    4. $\\mathbf{A}^{(3)} = [0.00, 0.00, 0.10, 0.00, 0.00]$\n\nUse the following test suite of cases, each defined by $(w_{\\text{QI}}, w_{\\text{coil}}, \\iota, \\lambda)$:\n- Case 1 (balanced): $(0.6, 0.4, 0.9, 0.7)$\n- Case 2 (QI-only): $(1.0, 0.0, 0.9, 0.7)$\n- Case 3 (coil-only): $(0.0, 1.0, 0.9, 0.7)$\n- Case 4 (near-bounce emphasis): $(0.6, 0.4, 0.5, 0.85)$\n\nFor numerical implementation:\n- Use $N_{\\alpha} = 64$ equispaced samples on $[0,2\\pi)$.\n- Use $N_{\\zeta} = 512$ equispaced samples on $[0,2\\pi)$ for the integral approximation of $J_{\\parallel}(\\alpha)$.\n- Use periodic central differences to approximate $\\partial J_{\\parallel}/\\partial \\alpha$ from the discrete $J_{\\parallel}(\\alpha_j)$ sequence.\n\nTask:\n- For each test case, compute the scalarized cost $\\Phi$ for each candidate amplitude vector.\n- Identify the candidate index (using zero-based indexing consistent with the list above) that minimizes $\\Phi$ for that test case.\n\nAngle units must be radians. All computed quantities are dimensionless. Your program should produce a single line of output containing the indices of the minimizing candidates for the four test cases as a comma-separated list enclosed in square brackets, for example $[\\text{idx}_1,\\text{idx}_2,\\text{idx}_3,\\text{idx}_4]$.", "solution": "The user-provided problem is assessed to be **valid**. It is a well-posed, scientifically grounded computational problem in the domain of stellarator plasma physics. All necessary parameters, equations, and constraints are provided, allowing for a unique and verifiable solution. The underlying model, while a simplification of a real-world design problem, is based on established principles of magnetic confinement fusion, including Boozer coordinates, the second adiabatic invariant, and Fourier representations of magnetic fields. The task is to implement a specified multi-objective optimization algorithm to identify the best magnetic field configuration from a set of candidates under different weighting scenarios.\n\nThe core of the problem is to implement a computational procedure that, for each of four test cases, identifies which of four candidate stellarator magnetic field designs is optimal. Optimality is defined by minimizing a scalarized cost function $\\Phi$, which represents a weighted tradeoff between a physics-based metric for quasi-isodynamic (QI) quality, $Q$, and a proxy for engineering coil complexity, $C$.\n\nThe procedure can be broken down into the following logical steps, which will be implemented for each test case.\n\n**1. Definition of Candidate Designs and Objective Functions**\n\nEach of the four candidate designs is defined by a vector of Fourier amplitudes $\\mathbf{A} = [A_1, \\dots, A_5]$ for a fixed set of harmonic mode numbers $(m_k, n_k)$. The total cost function is given by:\n$$\n\\Phi = w_{\\text{QI}} \\, \\tilde{Q} + w_{\\text{coil}} \\, \\tilde{C}\n$$\nHere, $w_{\\text{QI}}$ and $w_{\\text{coil}}$ are weights specified by the test case. $\\tilde{Q}$ and $\\tilde{C}$ are the normalized values of the QI metric and the coil complexity metric, respectively.\n\n**2. Calculation of the Coil Complexity Metric ($C$)**\n\nThe coil complexity metric, $C$, is a proxy that penalizes magnetic field harmonics with higher mode numbers, as these generally require more complex and difficult-to-manufacture magnet coils. It is calculated as a weighted sum of the squared amplitudes:\n$$\nC = \\sum_{k=1}^{K} w_k A_k^2, \\quad \\text{where} \\quad w_k = m_k^2 + n_k^2\n$$\nThe fixed harmonic mode numbers are $(m_k,n_k) \\in \\{(1,0),(0,1),(1,1),(2,1),(2,3)\\}$. The corresponding weights are $w_k \\in \\{1, 1, 2, 5, 13\\}$. The values of $C$ are computed for each of the four candidate amplitude vectors $\\mathbf{A}^{(0)}, \\mathbf{A}^{(1)}, \\mathbf{A}^{(2)}, \\mathbf{A}^{(3)}$. Since this calculation does not depend on the test case parameters $(\\iota, \\lambda)$, the four values of $C$ can be pre-calculated.\n\n**3. Calculation of the Quasi-Isodynamic Metric ($Q$)**\n\nThe QI metric, $Q$, quantifies the deviation from the ideal quasi-isodynamic condition, which requires that the second adiabatic invariant, $J_{\\parallel}$, does not vary on a flux surface. The variation is measured with respect to the Boozer field-line label $\\alpha = \\theta - \\iota \\zeta$. A smaller value of $Q$ indicates a better approximation to the QI state.\n\nThe calculation of $Q$ for a single candidate design and a given test case $(\\iota, \\lambda)$ involves several sub-steps:\n\n**a. Discretization:** We establish a uniform grid of $N_{\\alpha}=64$ points for the field-line label, $\\alpha_j \\in [0, 2\\pi)$, and a uniform grid of $N_{\\zeta}=512$ points for the toroidal angle, $\\zeta_l \\in [0, 2\\pi)$, to perform numerical integration and differentiation.\n\n**b. Computing $J_{\\parallel}(\\alpha)$:** The second adiabatic invariant $J_{\\parallel}$ is approximated for each discrete value $\\alpha_j$ by the integral:\n$$\nJ_{\\parallel}(\\alpha_j) \\approx \\int_0^{2\\pi} \\sqrt{\\max\\{0,\\,1 - \\lambda B(\\alpha_j + \\iota \\zeta,\\,\\zeta)\\}} \\,\\mathrm{d}\\zeta\n$$\nThis integral is numerically evaluated using the trapezoidal rule. For each point $\\zeta_l$ on the integration grid, we first calculate the corresponding poloidal angle $\\theta_l = \\alpha_j + \\iota \\zeta_l$. Then, the magnetic field strength $B(\\theta_l, \\zeta_l)$ is computed using its Fourier series representation:\n$$\nB(\\theta_l,\\zeta_l) = 1 + \\sum_{k=1}^{K} A_k \\cos(m_k \\theta_l - n_k \\zeta_l)\n$$\nThe integrand $\\sqrt{\\max\\{0, 1-\\lambda B\\}}$ is evaluated at each $\\zeta_l$, and the values are summed and multiplied by the step size $d\\zeta = 2\\pi / N_{\\zeta}$ to yield $J_{\\parallel}(\\alpha_j)$. This process is repeated for all $j=1, \\dots, N_{\\alpha}$, producing an array of $J_{\\parallel}$ values.\n\n**c. Computing the Derivative $\\partial J_{\\parallel} / \\partial \\alpha$:** The derivative of $J_{\\parallel}$ with respect to $\\alpha$ is approximated from the discrete array of $J_{\\parallel}(\\alpha_j)$ values using a periodic central difference scheme:\n$$\n\\frac{\\partial J_{\\parallel}}{\\partial \\alpha}\\bigg|_{\\alpha_j} \\approx \\frac{J_{\\parallel}(\\alpha_{j+1}) - J_{\\parallel}(\\alpha_{j-1})}{2 \\, d\\alpha}\n$$\nwhere $d\\alpha = 2\\pi / N_{\\alpha}$. Periodic boundary conditions are applied at the endpoints of the $\\alpha$ grid.\n\n**d. Computing $Q$:** Finally, the QI metric $Q$ is calculated as the root-mean-square of the computed derivative values:\n$$\nQ = \\sqrt{\\frac{1}{N_\\alpha} \\sum_{j=1}^{N_\\alpha} \\left( \\frac{\\partial J_{\\parallel}(\\alpha_j)}{\\partial \\alpha} \\right)^2 }\n$$\n\nThis entire procedure is performed for each of the four candidate designs to obtain a set of four $Q$ values for the current test case.\n\n**4. Normalization and Optimization**\n\nWith the sets of four raw values $\\{C^{(i)}\\}_{i=0}^3$ and $\\{Q^{(i)}\\}_{i=0}^3$ computed, they are separately normalized to the range $[0, 1]$ using min-max scaling to ensure they are on a comparable basis for the weighted sum:\n$$\n\\tilde{X} = \\frac{X - X_{\\min}}{X_{\\max} - X_{\\min} + \\epsilon}\n$$\nwhere $X$ is either $Q$ or $C$, and $\\epsilon$ is a small positive constant (e.g., $10^{-9}$) to prevent division by zero in the case that all values of an objective are identical.\n\nThe final scalarized cost $\\Phi^{(i)}$ is then computed for each candidate $i$ using the weights $w_{\\text{QI}}$ and $w_{\\text{coil}}$ for the current test case. The index $i$ corresponding to the minimum value of $\\Phi^{(i)}$ is identified as the optimal choice for that test case.\n\nThis complete process is repeated for all four test cases, and the resulting indices of the optimal candidates are aggregated into a final list.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the stellarator design optimization problem by calculating the optimal\n    candidate index for each test case.\n    \"\"\"\n    # Define fixed problem parameters\n    harmonics_mn = np.array([(1, 0), (0, 1), (1, 1), (2, 1), (2, 3)])\n    m_k = harmonics_mn[:, 0]\n    n_k = harmonics_mn[:, 1]\n    \n    candidate_A = [\n        np.array([0.02, 0.03, 0.04, 0.00, 0.00]),\n        np.array([0.05, 0.03, 0.08, 0.04, 0.02]),\n        np.array([0.01, 0.02, 0.06, 0.00, 0.03]),\n        np.array([0.00, 0.00, 0.10, 0.00, 0.00]),\n    ]\n\n    test_cases = [\n        # (w_QI, w_coil, iota, lambda)\n        (0.6, 0.4, 0.9, 0.7),   # Case 1: balanced\n        (1.0, 0.0, 0.9, 0.7),   # Case 2: QI-only\n        (0.0, 1.0, 0.9, 0.7),   # Case 3: coil-only\n        (0.6, 0.4, 0.5, 0.85),  # Case 4: near-bounce emphasis\n    ]\n\n    # Numerical integration and differentiation parameters\n    N_alpha = 64\n    N_zeta = 512\n    epsilon = 1e-9\n\n    # --- Helper Functions ---\n\n    def calculate_C(A, m, n):\n        \"\"\"Calculates the coil complexity metric C.\"\"\"\n        w = m**2 + n**2\n        return np.sum(w * A**2)\n\n    def calculate_Q(A, m, n, iota, lambda_val):\n        \"\"\"Calculates the quasi-isodynamic metric Q.\"\"\"\n        alpha_grid = np.linspace(0, 2 * np.pi, N_alpha, endpoint=False)\n        zeta_grid = np.linspace(0, 2 * np.pi, N_zeta, endpoint=False)\n        d_zeta = 2 * np.pi / N_zeta\n        d_alpha = 2 * np.pi / N_alpha\n\n        J_parallel_values = np.zeros(N_alpha)\n\n        for j, alpha_j in enumerate(alpha_grid):\n            theta_vals = alpha_j + iota * zeta_grid\n\n            # Calculate B field strength across the zeta grid for this alpha\n            B_vals = np.ones_like(zeta_grid) # B0 = 1\n            for k in range(len(A)):\n                if A[k] != 0:\n                    B_vals += A[k] * np.cos(m[k] * theta_vals - n[k] * zeta_grid)\n            \n            # Calculate the integrand for J_parallel\n            integrand = np.sqrt(np.maximum(0, 1 - lambda_val * B_vals))\n            \n            # Approximate the integral using the trapezoidal rule (sum * step)\n            J_parallel_values[j] = np.sum(integrand) * d_zeta\n        \n        # Calculate derivative using periodic central differences\n        dJ_dalpha = (np.roll(J_parallel_values, -1) - np.roll(J_parallel_values, 1)) / (2 * d_alpha)\n        \n        # Calculate Q as the RMS of the derivative\n        Q = np.sqrt(np.mean(np.square(dJ_dalpha)))\n        return Q\n\n    def normalize(values):\n        \"\"\"Performs min-max normalization on a numpy array.\"\"\"\n        val_min = np.min(values)\n        val_max = np.max(values)\n        denominator = val_max - val_min\n        if denominator  epsilon:\n            return np.zeros_like(values)\n        return (values - val_min) / (denominator + epsilon)\n\n    # --- Main Calculation Loop ---\n    \n    # Pre-calculate C values as they are constant across test cases\n    c_values_all = np.array([calculate_C(A, m_k, n_k) for A in candidate_A])\n\n    results = []\n    for case in test_cases:\n        w_qi, w_coil, iota, lambda_val = case\n        \n        # Calculate Q values for each candidate for the current test case\n        q_values_case = np.array([calculate_Q(A, m_k, n_k, iota, lambda_val) for A in candidate_A])\n        \n        # Normalize Q and C values across the candidates for this case\n        q_norm = normalize(q_values_case)\n        c_norm = normalize(c_values_all)\n        \n        # Calculate the scalarized cost function Phi for each candidate\n        phi_values = w_qi * q_norm + w_coil * c_norm\n        \n        # Find the index of the candidate with the minimum cost\n        best_idx = np.argmin(phi_values)\n        results.append(best_idx)\n        \n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3715782"}]}