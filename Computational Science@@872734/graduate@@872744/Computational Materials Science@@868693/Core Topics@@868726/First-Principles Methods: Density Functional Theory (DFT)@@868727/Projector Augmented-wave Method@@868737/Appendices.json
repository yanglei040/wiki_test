{"hands_on_practices": [{"introduction": "This practice takes you into the core of the Projector Augmented-Wave (PAW) method. You will implement the projection of delocalized plane waves onto localized, atom-centered projector functions, a critical step that bridges the pseudo-wavefunction and the all-electron wavefunction. This exercise provides a concrete understanding of how the PAW basis is constructed and how information about the local electronic structure is encoded in the occupation matrices [@problem_id:3480864].", "problem": "You are asked to implement, from first principles, the projection of a single plane-wave Bloch state onto atom-centered projector functions within the Projector Augmented-Wave (PAW) method, and then assemble the corresponding occupation matrices for each atom in the unit cell. The Projector Augmented-Wave (PAW) method uses atom-centered projectors $p_{a,i}(\\mathbf{r})$ localized around each atom indexed by $a$, where $i$ enumerates a finite set of angular-momentum-resolved projectors $(l,m)$ for that atom. Given a wave vector $\\mathbf{k}$ and one or more plane-wave states characterized by reciprocal lattice vectors $\\mathbf{G}_{n}$, the Bloch wave vectors are $\\mathbf{K}_{n} = \\mathbf{k} + \\mathbf{G}_{n}$. The overlap amplitudes $c_{a,i,n}$ for atom $a$, projector $i$, and band index $n$ are defined by the integral $c_{a,i,n} = \\int_{\\mathbb{R}^{3}} p_{a,i}^{*}(\\mathbf{r} - \\mathbf{R}_{a}) \\exp\\left(i \\mathbf{K}_{n} \\cdot \\mathbf{r}\\right) \\,\\mathrm{d}^{3}\\mathbf{r}$, and the atom-resolved occupation matrix is $D^{a}_{ij} = \\sum_{n} f_{n} \\, c_{a,i,n} \\, c_{a,j,n}^{*}$, where $f_{n}$ is the occupation of band $n$. You must compute and report the real parts $\\operatorname{Re} D^{a}_{ij}$ for all atoms and their projectors.\n\nBase your derivation and implementation on the following scientifically standard and well-tested elements:\n- The definition of a plane-wave Bloch state $\\exp\\left(i \\mathbf{K}\\cdot\\mathbf{r}\\right)$.\n- The orthonormality of spherical harmonics $Y_{l}^{m}(\\hat{\\mathbf{r}})$ on the unit sphere.\n- The expansion of a plane wave in spherical harmonics and spherical Bessel functions, together with the properties of spherical Bessel functions $j_{l}(x)$.\n- The construction of localized projector shapes using angular-momentum channels with Gaussian radial envelopes.\n\nUse the following physically consistent and self-contained specification for the projector functions. For each atom $a$ and a projector defined by angular momentum indices $(l,m)$, use\n$$\np_{a,lm}(\\mathbf{r}) = N_{l} \\, r^{l} \\, \\exp\\!\\left(-\\left(\\frac{r}{\\sigma_{a}}\\right)^{2}\\right) \\, Y_{l}^{m}(\\hat{\\mathbf{r}}),\n$$\nwhere $r = \\lVert \\mathbf{r} \\rVert$, $\\hat{\\mathbf{r}} = \\mathbf{r}/r$, and $N_{l}$ is a normalization constant chosen such that\n$$\n\\int_{0}^{\\infty}\\!\\int_{\\Omega} \\left|p_{a,lm}(\\mathbf{r})\\right|^{2} r^{2} \\,\\mathrm{d}\\Omega \\,\\mathrm{d}r = 1,\n$$\nwith $\\mathrm{d}\\Omega$ the solid angle element and $\\sigma_{a} > 0$ a radial width parameter for atom $a$. The normalization for $N_{l}$ must be derived from this condition.\n\nYour implementation must:\n1. Derive the overlap amplitude $c_{a,lm,n}$ from first principles using the spherical harmonic expansion of the plane wave and the orthogonality of spherical harmonics, reducing the three-dimensional integral to a one-dimensional radial integral involving the spherical Bessel function $j_{l}(x)$ and the radial envelope $r^{l}\\exp\\!\\left(-\\left(\\frac{r}{\\sigma_{a}}\\right)^{2}\\right)$.\n2. Implement a numerically stable evaluation of the radial integral. If $\\lVert \\mathbf{K}_{n} \\rVert = 0$, handle the limiting case correctly and avoid undefined angular quantities. When $\\lVert \\mathbf{K}_{n} \\rVert > 0$, compute the required spherical harmonic factor using the direction of $\\mathbf{K}_{n}$.\n3. Assemble the occupation matrices $D^{a}_{ij}$ for each atom and return their real parts $\\operatorname{Re} D^{a}_{ij}$.\n\nAngles must be in radians. Positions are to be treated in angstroms ($\\mathrm{\\AA}$), wave vectors in inverse angstroms ($\\mathrm{\\AA}^{-1}$), and the final occupation matrix elements are dimensionless. Your program must produce numerical outputs as floating-point numbers.\n\nTest Suite Specification:\nUse the following three test cases. In all cases, the unit cell is simple cubic with lattice constant $a = 5.0\\,\\mathrm{\\AA}$. There are two atoms per unit cell:\n- Atom $0$ at $\\mathbf{R}_{0} = (0.0,\\,0.0,\\,0.0)\\,\\mathrm{\\AA}$ with $\\sigma_{0} = 0.8\\,\\mathrm{\\AA}$.\n- Atom $1$ at $\\mathbf{R}_{1} = \\left(\\frac{a}{2},\\,\\frac{a}{2},\\,\\frac{a}{2}\\right)\\,\\mathrm{\\AA}$ with $\\sigma_{1} = 0.8\\,\\mathrm{\\AA}$.\n\nFor each atom, define four projectors with indices $(l,m)$ given by $(0,0)$, $(1,-1)$, $(1,0)$, $(1,1)$, in that fixed ordering.\n\nLet $G_{x} = \\frac{2\\pi}{a}\\,\\mathrm{\\AA}^{-1}$ and $G_{z} = \\frac{2\\pi}{a}\\,\\mathrm{\\AA}^{-1}$.\n\n- Case $1$ (general case): $\\mathbf{k} = (0.2,\\,0.0,\\,0.1)\\,\\mathrm{\\AA}^{-1}$, two bands with $(\\mathbf{G}_{0},f_{0}) = ((0,0,0)\\,\\mathrm{\\AA}^{-1},\\,1.0)$ and $(\\mathbf{G}_{1},f_{1}) = ((G_{x},0,0)\\,\\mathrm{\\AA}^{-1},\\,0.5)$.\n- Case $2$ (boundary $\\Gamma$ point): $\\mathbf{k} = (0.0,\\,0.0,\\,0.0)\\,\\mathrm{\\AA}^{-1}$, one band with $(\\mathbf{G}_{0},f_{0}) = ((0,0,0)\\,\\mathrm{\\AA}^{-1},\\,1.0)$.\n- Case $3$ (directional edge case): $\\mathbf{k} = (0.0,\\,0.0,\\,0.5)\\,\\mathrm{\\AA}^{-1}$, two bands with $(\\mathbf{G}_{0},f_{0}) = ((0,0,0)\\,\\mathrm{\\AA}^{-1},\\,0.3)$ and $(\\mathbf{G}_{1},f_{1}) = ((0,0,-G_{z})\\,\\mathrm{\\AA}^{-1},\\,0.3)$.\n\nOutput Specification:\nFor each test case in the above order, and for each atom $a$ in the order $a=0$ then $a=1$, form the real part of the $4\\times 4$ matrix $D^{a}_{ij}$ using the projectors in the fixed order $(0,0)$, $(1,-1)$, $(1,0)$, $(1,1)$. Flatten each matrix in row-major order to a length-$16$ list of floating-point numbers. Concatenate the lists for atom $0$ and atom $1$, then concatenate across the three test cases. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[x_{1},x_{2},\\dots,x_{96}]$, where $96$ is the total number of floating-point entries ($3$ cases $\\times$ $2$ atoms $\\times$ $16$ entries per matrix).\n\nYour program must be self-contained, require no user input, and be runnable as is. It must compute the occupation matrices using the described approach and return the specified output format. All numerical values in the output are unitless and must be represented as floating-point numbers.", "solution": "We begin with the standardized definitions that underpin the Projector Augmented-Wave (PAW) method. For each atom $a$ located at position $\\mathbf{R}_{a}$, we have a set of projector functions $p_{a,lm}(\\mathbf{r})$ defined over real space, with angular momentum indices $(l,m)$. The plane-wave Bloch state with wave vector $\\mathbf{K}$ is given by $\\exp\\left(i \\mathbf{K}\\cdot\\mathbf{r}\\right)$. The projection coefficients $c_{a,lm}$ of the plane wave onto the projector functions centered at $\\mathbf{R}_{a}$ are defined by the integral\n$$\nc_{a,lm}(\\mathbf{K}) = \\int_{\\mathbb{R}^{3}} p_{a,lm}^{*}(\\mathbf{r}-\\mathbf{R}_{a}) \\, \\exp\\left(i \\mathbf{K}\\cdot\\mathbf{r}\\right) \\,\\mathrm{d}^{3}\\mathbf{r}.\n$$\nA change of variables $\\mathbf{r} = \\mathbf{R}_{a} + \\mathbf{r}_{a}$ yields\n$$\nc_{a,lm}(\\mathbf{K}) = \\exp\\left(i \\mathbf{K}\\cdot\\mathbf{R}_{a}\\right) \\int_{\\mathbb{R}^{3}} p_{a,lm}^{*}(\\mathbf{r}_{a}) \\, \\exp\\left(i \\mathbf{K}\\cdot\\mathbf{r}_{a}\\right) \\,\\mathrm{d}^{3}\\mathbf{r}_{a}.\n$$\nWe specify the projector functions as\n$$\np_{a,lm}(\\mathbf{r}) = N_{l} \\, r^{l} \\, \\exp\\!\\left(-\\left(\\frac{r}{\\sigma_{a}}\\right)^{2}\\right) \\, Y_{l}^{m}(\\hat{\\mathbf{r}}),\n$$\nwhere $r = \\lVert \\mathbf{r} \\rVert$ and $\\hat{\\mathbf{r}} = \\mathbf{r}/r$. The normalization constant $N_{l}$ is chosen such that\n$$\n\\int_{0}^{\\infty}\\!\\int_{\\Omega} \\left|p_{a,lm}(\\mathbf{r})\\right|^{2} r^{2} \\,\\mathrm{d}\\Omega \\,\\mathrm{d}r = 1.\n$$\nSince $\\int_{\\Omega} \\left|Y_{l}^{m}(\\hat{\\mathbf{r}})\\right|^{2} \\,\\mathrm{d}\\Omega = 1$, the normalization reduces to\n$$\nN_{l}^{2} \\int_{0}^{\\infty} r^{2+2l} \\exp\\!\\left(-2\\left(\\frac{r}{\\sigma_{a}}\\right)^{2}\\right)\\,\\mathrm{d}r = 1.\n$$\nLetting $\\alpha = \\frac{2}{\\sigma_{a}^{2}}$, we use the standard integral $\\int_{0}^{\\infty} r^{n} e^{-\\alpha r^{2}} \\,\\mathrm{d}r = \\frac{1}{2} \\alpha^{-(n+1)/2} \\Gamma\\!\\left(\\frac{n+1}{2}\\right)$ for $n > -1$, yielding\n$$\nN_{l} = \\left[\\frac{1}{2} \\left(\\frac{2}{\\sigma_{a}^{2}}\\right)^{-\\frac{3+2l}{2}} \\Gamma\\!\\left(\\frac{3+2l}{2}\\right)\\right]^{-1/2}.\n$$\n\nTo evaluate the overlap integral, we invoke the spherical harmonic expansion of the plane wave, a well-tested formula in scattering theory:\n$$\n\\exp\\left(i \\mathbf{K}\\cdot\\mathbf{r}\\right) = 4\\pi \\sum_{l'=0}^{\\infty}\\sum_{m'=-l'}^{l'} i^{\\,l'} j_{l'}(K r) Y_{l'}^{m'}(\\hat{\\mathbf{r}}) Y_{l'}^{m'*}(\\hat{\\mathbf{K}}),\n$$\nwhere $K = \\lVert \\mathbf{K} \\rVert$, $j_{l}(x)$ are the spherical Bessel functions and $Y_{l}^{m}$ are the spherical harmonics. Using the orthonormality of $Y_{l}^{m}$, the angular integrals collapse, giving\n$$\n\\int_{\\mathbb{R}^{3}} p_{a,lm}^{*}(\\mathbf{r}) \\exp\\left(i \\mathbf{K}\\cdot\\mathbf{r}\\right) \\,\\mathrm{d}^{3}\\mathbf{r} = 4\\pi \\, i^{\\,l} \\, Y_{l}^{m*}(\\hat{\\mathbf{K}}) \\, N_{l} \\int_{0}^{\\infty} r^{2+l} \\exp\\!\\left(-\\left(\\frac{r}{\\sigma_{a}}\\right)^{2}\\right) \\, j_{l}(K r) \\,\\mathrm{d}r.\n$$\nTherefore,\n$$\nc_{a,lm}(\\mathbf{K}) = \\exp\\left(i \\mathbf{K}\\cdot\\mathbf{R}_{a}\\right) \\, 4\\pi \\, i^{\\,l} \\, Y_{l}^{m*}(\\hat{\\mathbf{K}}) \\, N_{l} \\, I_{l}(K;\\sigma_{a}),\n$$\nwith the radial integral\n$$\nI_{l}(K;\\sigma) = \\int_{0}^{\\infty} r^{2+l} \\exp\\!\\left(-\\left(\\frac{r}{\\sigma}\\right)^{2}\\right) j_{l}(K r) \\,\\mathrm{d}r.\n$$\n\nSpecial case when $K=0$: we have $\\exp\\left(i \\mathbf{K}\\cdot\\mathbf{r}\\right) = 1$, and the integral becomes\n$$\nc_{a,lm}(\\mathbf{0}) = \\int p_{a,lm}^{*}(\\mathbf{r}) \\,\\mathrm{d}^{3}\\mathbf{r} = N_{l} \\int_{0}^{\\infty} r^{2+l} \\exp\\!\\left(-\\left(\\frac{r}{\\sigma_{a}}\\right)^{2}\\right) \\,\\mathrm{d}r \\int_{\\Omega} Y_{l}^{m*}(\\hat{\\mathbf{r}}) \\,\\mathrm{d}\\Omega.\n$$\nUsing $\\int_{\\Omega} Y_{l}^{m}(\\hat{\\mathbf{r}}) \\,\\mathrm{d}\\Omega = \\sqrt{4\\pi} \\, \\delta_{l0} \\delta_{m0}$ and $j_{0}(0) = 1$ with $j_{l}(0) = 0$ for $l>0$, we find\n$$\nc_{a,00}(\\mathbf{0}) = \\sqrt{4\\pi} \\, N_{0} \\int_{0}^{\\infty} r^{2} \\exp\\!\\left(-\\left(\\frac{r}{\\sigma_{a}}\\right)^{2}\\right) \\,\\mathrm{d}r,\n$$\nand $c_{a,lm}(\\mathbf{0}) = 0$ for $l>0$. The radial integral for $l=0$ at $K=0$ evaluates to\n$$\n\\int_{0}^{\\infty} r^{2} \\exp\\!\\left(-\\left(\\frac{r}{\\sigma}\\right)^{2}\\right) \\,\\mathrm{d}r = \\sigma^{3} \\int_{0}^{\\infty} u^{2} e^{-u^{2}} \\,\\mathrm{d}u = \\sigma^{3} \\frac{\\sqrt{\\pi}}{4}.\n$$\n\nOccupation matrices: given bands indexed by $n$ with occupations $f_{n}$ and wave vectors $\\mathbf{K}_{n}$, we form\n$$\nD^{a}_{ij} = \\sum_{n} f_{n} \\, c_{a,i}(\\mathbf{K}_{n}) \\, c_{a,j}^{*}(\\mathbf{K}_{n}),\n$$\nwhich is Hermitian by construction. We are asked to report $\\operatorname{Re} D^{a}_{ij}$.\n\nAlgorithmic implementation details:\n1. Compute $N_{l}$ for each projector angular momentum $l$ and atom width $\\sigma_{a}$ using the gamma function formula above.\n2. For each band wave vector $\\mathbf{K}_{n}$:\n   - If $K_{n} = \\lVert \\mathbf{K}_{n} \\rVert$ is larger than a small threshold (for example $10^{-12}$), compute the polar angles $(\\theta,\\phi)$ from $\\hat{\\mathbf{K}}_{n} = \\mathbf{K}_{n}/K_{n}$ using $\\theta = \\arccos(K_{z}/K)$ and $\\phi = \\operatorname{atan2}(K_{y},K_{x})$. Evaluate $Y_{l}^{m}(\\hat{\\mathbf{K}})$ and its complex conjugate, and compute the radial integral $I_{l}(K;\\sigma)$ numerically by one-dimensional quadrature. A practical upper limit is $r_{\\max} = 12\\,\\sigma$, since the Gaussian envelope suppresses larger radii. Use a high-accuracy quadrature routine and spherical Bessel $j_{l}$.\n   - If $K_{n}$ is below threshold, use the special-case formulas: only the $(l=0,m=0)$ projector has non-zero overlap, as shown above, and $c_{a,00}(\\mathbf{0})$ is computed analytically. All $l>0$ channels yield zero overlap in the limit.\n   - Multiply by the phase factor $\\exp\\left(i \\mathbf{K}_{n}\\cdot \\mathbf{R}_{a}\\right)$ and the constant prefactors to obtain $c_{a,lm,n}$.\n3. Assemble $D^{a}_{ij}$ by summing $f_{n} c_{a,i,n} c_{a,j,n}^{*}$ over all bands $n$.\n4. Extract and report $\\operatorname{Re} D^{a}_{ij}$, flattening each $4\\times 4$ matrix in row-major order.\n\nUnits and numerical considerations:\n- Positions $\\mathbf{R}_{a}$ are in $\\mathrm{\\AA}$, wave vectors $\\mathbf{K}_{n}$ are in $\\mathrm{\\AA}^{-1}$, angles are in radians, and the final occupation matrix elements are dimensionless.\n- The spherical harmonics are evaluated using the Condon–Shortley phase convention, consistent with standard scientific libraries.\n- Numerical quadrature should use absolute and relative tolerances to ensure stable radial integrals. The Gaussian decay makes the integrals well-conditioned; limiting the integration to $[0,12\\sigma]$ suffices.\n\nTest suite execution:\n- Case $1$ uses $\\mathbf{k} = (0.2,\\,0.0,\\,0.1)\\,\\mathrm{\\AA}^{-1}$ and bands at $\\mathbf{G}_{0}=(0,0,0)\\,\\mathrm{\\AA}^{-1}$ with $f_{0}=1.0$, and $\\mathbf{G}_{1}=(2\\pi/a,0,0)\\,\\mathrm{\\AA}^{-1}$ with $f_{1}=0.5$.\n- Case $2$ uses the $\\Gamma$ point $\\mathbf{k}=(0,0,0)\\,\\mathrm{\\AA}^{-1}$ and a single band $\\mathbf{G}_{0}=(0,0,0)\\,\\mathrm{\\AA}^{-1}$ with $f_{0}=1.0$; only $l=0$ contributes.\n- Case $3$ uses $\\mathbf{k}=(0,0,0.5)\\,\\mathrm{\\AA}^{-1}$ and bands $\\mathbf{G}_{0}=(0,0,0)\\,\\mathrm{\\AA}^{-1}$ and $\\mathbf{G}_{1}=(0,0,-2\\pi/a)\\,\\mathrm{\\AA}^{-1}$ with occupations $f_{0}=0.3$ and $f_{1}=0.3$, probing directional sensitivity of $Y_{l}^{m}(\\hat{\\mathbf{K}})$.\n\nThe output must be a single comma-separated list enclosed in square brackets, concatenating the flattened real parts of $D^{a}_{ij}$ for atoms $a=0$ and $a=1$ for each case, in the specified order, resulting in $96$ floating-point entries. The program must be self-contained and produce this single line of output when run.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom math import sqrt, pi, acos, atan2, isclose, gamma\nfrom scipy.special import sph_harm, spherical_jn\nfrom scipy.integrate import quad\n\ndef normalization_Nl(l: int, sigma: float) -> float:\n    \"\"\"\n    Compute the normalization constant N_l for the projector radial function:\n    p_{lm}(r) = N_l * r^l * exp(-(r/sigma)^2) * Y_l^m(Ω),\n    such that ∫ |p|^2 r^2 dr dΩ = 1.\n\n    N_l^2 ∫_0^∞ r^{2+2l} exp(-2 (r/sigma)^2) dr = 1\n    Using ∫_0^∞ r^n e^{-α r^2} dr = (1/2) α^{-(n+1)/2} Γ((n+1)/2)\n    with α = 2/sigma^2, n = 2 + 2l.\n    \"\"\"\n    alpha = 2.0 / (sigma**2)\n    n = 2 + 2*l\n    integral = 0.5 * (alpha ** (-(n + 1) / 2.0)) * gamma((n + 1) / 2.0)\n    Nl = 1.0 / sqrt(integral)\n    return Nl\n\ndef K_angles(Kvec: np.ndarray):\n    \"\"\"\n    Compute spherical angles (theta, phi) for direction of Kvec.\n    theta in [0, π], phi in [-π, π].\n    \"\"\"\n    Knorm = np.linalg.norm(Kvec)\n    if Knorm < 1e-14:\n        # Undefined direction; caller should handle K=0 separately.\n        return None, None, 0.0\n    kx, ky, kz = Kvec\n    theta = np.arccos(kz / Knorm)\n    phi = np.arctan2(ky, kx)\n    return theta, phi, Knorm\n\ndef radial_integral_Il(l: int, K: float, sigma: float) -> float:\n    \"\"\"\n    Compute I_l(K; sigma) = ∫_0^∞ r^{2+l} exp(-(r/sigma)^2) j_l(K r) dr\n    Numerically via quadrature over [0, Rmax], where Rmax = 12*sigma.\n    Special-case: if K == 0, then j_0(0) = 1 and j_l(0) = 0 for l>0.\n    \"\"\"\n    if K < 1e-14:\n        if l == 0:\n            # Analytic integral: ∫ r^2 exp(-(r/sigma)^2) dr = sigma^3 * sqrt(pi)/4\n            return (sigma**3) * (sqrt(pi) / 4.0)\n        else:\n            return 0.0\n    Rmax = 12.0 * sigma\n    # Integrand for quadrature\n    def integrand(r):\n        return (r**(2 + l)) * np.exp(-(r/sigma)**2) * spherical_jn(l, K * r)\n    val, err = quad(integrand, 0.0, Rmax, epsabs=1e-10, epsrel=1e-10, limit=200)\n    return val\n\ndef overlap_coefficient(atom_R: np.ndarray, l: int, m: int, sigma: float, Kvec: np.ndarray, Nl: float) -> complex:\n    \"\"\"\n    Compute c_{a,lm}(K) = e^{i K·R_a} * 4π * i^l * Y_l^m*(K̂) * N_l * I_l(K; sigma)\n    with appropriate handling of K=0 special case.\n    \"\"\"\n    theta, phi, Knorm = K_angles(Kvec)\n    phase = np.exp(1j * np.dot(Kvec, atom_R))\n    if Knorm < 1e-14:\n        # Special-case: only l=0,m=0 contributes\n        if l == 0 and m == 0:\n            I0 = radial_integral_Il(0, 0.0, sigma)\n            # Angular integral gives √(4π)\n            return phase * (sqrt(4.0 * pi) * Nl * I0)\n        else:\n            return 0.0 + 0.0j\n    # Directional spherical harmonic factor Y_l^m*(K̂)\n    Ylm = sph_harm(m, l, phi, theta)  # sph_harm returns Y_l^m(φ, θ)\n    Ylm_conj = np.conj(Ylm)\n    Il = radial_integral_Il(l, Knorm, sigma)\n    coeff = phase * (4.0 * pi) * ((1j) ** l) * Ylm_conj * Nl * Il\n    return coeff\n\ndef build_D_matrix_for_atom(atom_R: np.ndarray, sigma: float, projectors: list, bands: list) -> np.ndarray:\n    \"\"\"\n    Build D^a_{ij} for one atom.\n    projectors: list of (l, m) pairs in fixed order.\n    bands: list of dicts {'K': np.array, 'f': float}\n    Returns real part of 4x4 D matrix as numpy array.\n    \"\"\"\n    # Precompute N_l per l value to avoid repeated normalization\n    unique_ls = sorted(set([l for (l, m) in projectors]))\n    Nl_map = {l: normalization_Nl(l, sigma) for l in unique_ls}\n    # Compute overlaps c_i,n for each projector i and band n\n    num_proj = len(projectors)\n    num_bands = len(bands)\n    c = np.zeros((num_proj, num_bands), dtype=np.complex128)\n    for i, (l, m) in enumerate(projectors):\n        Nl = Nl_map[l]\n        for n, band in enumerate(bands):\n            Kvec = band['K']\n            c[i, n] = overlap_coefficient(atom_R, l, m, sigma, Kvec, Nl)\n    # Assemble D_ij = sum_n f_n c_i,n c_j,n^*\n    D = np.zeros((num_proj, num_proj), dtype=np.complex128)\n    for n, band in enumerate(bands):\n        f = band['f']\n        cn = c[:, n].reshape((num_proj, 1))\n        D += f * (cn @ np.conj(cn).T)\n    return D.real\n\ndef solve():\n    # Define lattice and atoms\n    a = 5.0  # Angstrom\n    Gx = 2.0 * pi / a  # 1/Angstrom\n    Gz = 2.0 * pi / a  # 1/Angstrom\n\n    atoms = [\n        {'R': np.array([0.0, 0.0, 0.0]), 'sigma': 0.8},\n        {'R': np.array([a/2.0, a/2.0, a/2.0]), 'sigma': 0.8},\n    ]\n\n    # Projectors: fixed order (0,0), (1,-1), (1,0), (1,1)\n    projectors = [(0, 0), (1, -1), (1, 0), (1, 1)]\n\n    # Test cases definition\n    test_cases = [\n        # Case 1: general case\n        {\n            'k': np.array([0.2, 0.0, 0.1]),\n            'bands': [\n                {'G': np.array([0.0, 0.0, 0.0]), 'f': 1.0},\n                {'G': np.array([Gx, 0.0, 0.0]), 'f': 0.5},\n            ],\n        },\n        # Case 2: Gamma point\n        {\n            'k': np.array([0.0, 0.0, 0.0]),\n            'bands': [\n                {'G': np.array([0.0, 0.0, 0.0]), 'f': 1.0},\n            ],\n        },\n        # Case 3: directional edge case\n        {\n            'k': np.array([0.0, 0.0, 0.5]),\n            'bands': [\n                {'G': np.array([0.0, 0.0, 0.0]), 'f': 0.3},\n                {'G': np.array([0.0, 0.0, -Gz]), 'f': 0.3},\n            ],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        k = case['k']\n        # Form bands as K = k + G\n        bands = []\n        for b in case['bands']:\n            K = k + b['G']\n            bands.append({'K': K, 'f': b['f']})\n        # Compute D matrices for each atom and flatten real parts\n        for atom in atoms:\n            D_real = build_D_matrix_for_atom(atom['R'], atom['sigma'], projectors, bands)\n            # Flatten row-major\n            flat = D_real.flatten(order='C')\n            # Append to results\n            results.extend(flat.tolist())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3480864"}, {"introduction": "Any practical application of the PAW method involves a fundamental trade-off between computational accuracy and cost, primarily governed by the choice of the augmentation radius ($r_c$) and the plane-wave energy cutoff ($E_{\\text{cut}}$). This exercise uses a simplified but physically motivated model to explore this critical relationship. By analyzing how $r_c$ influences both the required $E_{\\text{cut}}$ and the pseudopotential's transferability under strain, you will develop an intuition essential for setting up reliable and efficient DFT calculations [@problem_id:3440835].", "problem": "Consider diamond-structure silicon where core-valence separation is treated using the Projector Augmented Wave (PAW) method. In PAW, the pseudization radius $r_c$ defines the extent of the augmentation region around each atom inside which the all-electron features are mapped to smooth pseudo quantities. A smaller $r_c$ (often termed \"harder\") better confines the augmentation region, but demands a higher plane-wave energy cutoff $E_{\\text{cut}}$ to properly represent rapid real-space variations. Your objective is to construct a family of hypothetical PAW datasets for silicon parameterized by $r_c$ and analyze the interplay between $E_{\\text{cut}}$ and transferability under homogeneous strain.\n\nStart from the following fundamental base:\n- The single-particle electronic structure is governed by the time-independent Schrödinger equation, and a plane-wave basis diagonalizes the kinetic energy operator. The kinetic energy of a plane wave with wavevector magnitude $G$ is $E_{\\text{kin}} = \\frac{\\hbar^2 G^2}{2 m_e}$, where $\\hbar$ is the reduced Planck constant and $m_e$ is the electron mass.\n- To accurately represent a real-space feature with characteristic size $r_c$, the plane-wave expansion must include reciprocal vectors up to a magnitude $G_{\\max}$ that resolves that feature. A conservative representation criterion is to require that the highest resolvable spatial frequency be comparable to the principal Fourier component of a spherical feature of radius $r_c$. This implies a relation between $G_{\\max}$ and $r_c$ that you must motivate from Fourier analysis and then use to determine the minimal $E_{\\text{cut}}$ through $E_{\\text{cut}} = \\frac{\\hbar^2 G_{\\max}^2}{2 m_e}$.\n- Under a small homogeneous strain of amplitude $\\varepsilon$ (dimensionless, expressed as a decimal, not with a percentage sign), transferability errors due to pseudization arise from the mismatch between pseudo and all-electron scattering characteristics in the augmentation region. Treat the leading-order strain effect using standard perturbative reasoning: the energy error per atom scales with the square of the perturbation amplitude and with measures of the augmentation region size and curvature mismatch. Use a scaling law of the form $\\Delta E_{\\text{tr}} \\propto r_c^\\alpha \\varepsilon^2$ for some exponent $\\alpha$ that you must justify qualitatively, and adopt a silicon-specific proportionality constant to make the results numerically concrete.\n\nImplementation requirements:\n- Use $r_c$ in Bohr radii. Use the atomic-unit relation for plane waves, $E_{\\text{kin}} = \\frac{G^2}{2}$ in Hartree when $G$ is in inverse Bohr and energies are in Hartree, and convert to electronvolts using $1$ Hartree $= 27.211386$ electronvolts.\n- For the transferability error per atom under strain, use the concrete calibration for silicon $\\Delta E_{\\text{tr}} = C_{\\text{Si}} \\, r_c^4 \\, \\varepsilon^2$, where $C_{\\text{Si}}$ is a constant chosen so that typical errors are on the order of a few millielectronvolts for realistic $r_c$ and $\\varepsilon$. Take $C_{\\text{Si}} = 305.6$ millielectronvolts per Bohr$^4$.\n- Express the final energy cutoff in electronvolts and the transferability error in millielectronvolts. Round each energy cutoff to one decimal place and each transferability error to two decimal places.\n\nTest suite:\nFor each pair $(r_c,\\varepsilon)$ below, compute two outputs: the minimal $E_{\\text{cut}}$ in electronvolts required by the representation criterion and the predicted transferability error per atom in millielectronvolts according to the scaling law:\n1. $r_c = 1.30$ (Bohr), $\\varepsilon = 0.08$.\n2. $r_c = 1.60$ (Bohr), $\\varepsilon = 0.05$.\n3. $r_c = 1.90$ (Bohr), $\\varepsilon = 0.05$.\n4. $r_c = 2.20$ (Bohr), $\\varepsilon = 0.02$.\n5. Boundary case: $r_c = 1.60$ (Bohr), $\\varepsilon = 0.00$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is a two-item list $[E_{\\text{cut}}~(\\text{eV}), \\Delta E_{\\text{tr}}~(\\text{meV})]$ in the order of the test suite. For example: [[x1,y1],[x2,y2],...], with each $x_i$ and $y_i$ being floats rounded as specified above.", "solution": "The goal is to quantify how the pseudization radius $r_c$ in the Projector Augmented Wave (PAW) method affects both the minimal plane-wave energy cutoff $E_{\\text{cut}}$ required to represent the augmentation region and the transferability of the pseudopotential under homogeneous strain.\n\nWe begin from the kinetic energy of a plane wave in a plane-wave basis. The kinetic energy operator is diagonalized by plane waves with wavevector $\\mathbf{G}$, and the kinetic energy is given by\n$$\nE_{\\text{kin}} = \\frac{\\hbar^2 \\, G^2}{2 m_e},\n$$\nwhere $G = \\lVert \\mathbf{G} \\rVert$. In atomic units (Hartree atomic units), taking $\\hbar = 1$, $m_e = 1$, the relation simplifies to\n$$\nE_{\\text{kin}}^{(\\text{Hartree})} = \\frac{G^2}{2}.\n$$\nIf $G$ is expressed in inverse Bohr, then $E_{\\text{kin}}$ is in Hartree. To convert Hartree to electronvolts, we use the well-tested constant $1$ Hartree $= 27.211386$ electronvolts.\n\nTo determine a minimal $E_{\\text{cut}}$, we require a reciprocal-space cutoff $G_{\\max}$ sufficiently large to resolve features associated with the augmentation region of radius $r_c$. The heuristic is rooted in Fourier analysis: a spherical step-like feature of radius $r_c$ has a characteristic Fourier content whose dominant wavelength corresponds to a spatial frequency of order $G \\sim \\pi / r_c$. This follows from the oscillatory behavior of the spherical Bessel function $j_0(G r_c) = \\sin(G r_c)/(G r_c)$, which represents the radial Fourier transform of a spherical top-hat. The first zero of $j_0$ occurs at $G r_c = \\pi$, and the principal Fourier component controlling the representation of the sharpest variation lies near this wavevector. Therefore, a conservative representation criterion is\n$$\nG_{\\max} \\approx \\frac{\\pi}{r_c}.\n$$\nSubstituting into the kinetic energy expression in atomic units yields\n$$\nE_{\\text{cut}}^{(\\text{Hartree})} = \\frac{1}{2} \\left( \\frac{\\pi}{r_c} \\right)^2,\n$$\nand converting to electronvolts gives\n$$\nE_{\\text{cut}}^{(\\text{eV})} = 27.211386 \\times \\frac{\\pi^2}{2 r_c^2}.\n$$\nThis relation demonstrates that a smaller $r_c$ increases $G_{\\max}$ and thus raises the required $E_{\\text{cut}}$ roughly as $1/r_c^2$.\n\nNext, we consider transferability under homogeneous strain. A small strain $\\varepsilon$ perturbs the local electronic environment, modifying bond lengths and angles and thereby the scattering properties experienced by valence electrons. In PAW, transferability errors arise primarily from the mismatch between pseudo and all-electron scattering properties within the augmentation region. Using perturbation theory, the leading energy change scales with the square of the perturbation amplitude, so we take a dependence $\\propto \\varepsilon^2$. The spatial extent of the augmentation region contributes via its volume, which scales as $r_c^3$, and curvature mismatch contributes an additional dependence on $r_c$ because the pseudoization smears high-curvature features inside the core. A minimal qualitative model thus takes the energy error per atom to scale as\n$$\n\\Delta E_{\\text{tr}} \\propto r_c^3 \\cdot r_c \\cdot \\varepsilon^2 = r_c^4 \\varepsilon^2.\n$$\nTo make the result quantitative for silicon, we adopt a silicon-specific proportionality constant $C_{\\text{Si}}$ calibrated so that typical errors are on the order of a few millielectronvolts for realistic $r_c$ and $\\varepsilon$. We set\n$$\n\\Delta E_{\\text{tr}}^{(\\text{meV})} = C_{\\text{Si}} \\, r_c^4 \\, \\varepsilon^2,\n$$\nwith $C_{\\text{Si}} = 305.6$ millielectronvolts per Bohr$^4$. This choice yields, for example, $\\Delta E_{\\text{tr}} \\approx 5$ millielectronvolts per atom for $r_c = 1.6$ Bohr and $\\varepsilon = 0.05$, which is a realistic magnitude for strain-induced transferability deviations.\n\nAlgorithmic steps:\n1. For each test case with inputs $(r_c, \\varepsilon)$, compute\n$$\nE_{\\text{cut}}^{(\\text{eV})} = 27.211386 \\times \\frac{\\pi^2}{2 r_c^2}.\n$$\n2. Compute the predicted transferability error\n$$\n\\Delta E_{\\text{tr}}^{(\\text{meV})} = 305.6 \\times r_c^4 \\times \\varepsilon^2.\n$$\n3. Round $E_{\\text{cut}}^{(\\text{eV})}$ to one decimal place and $\\Delta E_{\\text{tr}}^{(\\text{meV})}$ to two decimal places.\n4. Aggregate the results in a single list following the input order and print a single line as specified.\n\nThis construction demonstrates the interplay: decreasing $r_c$ increases $E_{\\text{cut}}$ approximately as $1/r_c^2$, while decreasing $r_c$ decreases the transferability error approximately as $r_c^4$ for a fixed strain level. The boundary case $\\varepsilon = 0$ correctly yields $\\Delta E_{\\text{tr}} = 0$ by the quadratic dependence on strain amplitude.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef minimal_energy_cutoff_eV(rc_bohr: float) -> float:\n    \"\"\"\n    Compute minimal plane-wave energy cutoff in eV using the criterion G_max ≈ π / r_c.\n    Atomic units: E(Hartree) = (G^2)/2 with G in 1/bohr.\n    Convert Hartree to eV using 1 Hartree = 27.211386 eV.\n    \"\"\"\n    hartree_to_ev = 27.211386\n    G_max = np.pi / rc_bohr\n    E_hartree = 0.5 * (G_max ** 2)\n    E_eV = hartree_to_ev * E_hartree\n    return E_eV\n\ndef transferability_error_meV(rc_bohr: float, strain: float) -> float:\n    \"\"\"\n    Compute transferability error per atom in meV using ΔE_tr = C_Si * r_c^4 * ε^2.\n    \"\"\"\n    C_Si = 305.6  # meV / bohr^4\n    return C_Si * (rc_bohr ** 4) * (strain ** 2)\n\ndef solve():\n    # Define the test cases from the problem statement: (r_c in bohr, strain epsilon dimensionless)\n    test_cases = [\n        (1.30, 0.08),\n        (1.60, 0.05),\n        (1.90, 0.05),\n        (2.20, 0.02),\n        (1.60, 0.00),  # boundary case: zero strain\n    ]\n\n    results = []\n    for rc, eps in test_cases:\n        ecut = minimal_energy_cutoff_eV(rc)\n        err = transferability_error_meV(rc, eps)\n        # Round as specified: E_cut to 1 decimal, error to 2 decimals\n        ecut_rounded = round(ecut, 1)\n        err_rounded = round(err, 2)\n        results.append([ecut_rounded, err_rounded])\n\n    # Final print statement in the exact required format.\n    # Produce a single line: list of [E_cut(eV), ΔE_tr(meV)] pairs in the given order.\n    # Ensure standard Python list formatting without extra text.\n    print(f\"{results}\")\n\nsolve()\n```", "id": "3440835"}, {"introduction": "The power of the PAW method lies in its ability to accurately treat core-valence interactions, which is crucial for systems with significant core-valence charge density overlap like transition metal oxides. This hands-on practice explores a key feature for achieving this accuracy: the Non-Linear Core Correction (NLCC). By building a site-centered model, you will quantify how the NLCC affects the exchange-correlation field and, consequently, the calculated local magnetic moments, providing insight into one of PAW's most important physical corrections [@problem_id:3480885].", "problem": "Consider a simplified, spherically symmetric site-centered model for a transition-metal atom in a $3d$ oxide within the Projector Augmented-Wave (PAW) formalism. The objective is to quantify how the Non-Linear Core Correction (NLCC) in a Local Spin Density Approximation (LSDA) affects the local magnetic moment by including core-valence overlap in the exchange-correlation energy functional $E_{xc}[n_{\\text{val}}+n_{\\text{core}}]$. Assume atomic units throughout and report magnetic moments in Bohr magnetons per site.\n\nFundamental base and assumptions:\n- Density Functional Theory (DFT) in the Kohn-Sham formalism defines spin-resolved exchange-correlation potentials as functional derivatives of the exchange-correlation energy density with respect to spin densities. In the Local Spin Density Approximation (LSDA) for exchange only, the spin-resolved exchange energy density is\n$$\\varepsilon_{x}\\left(n_{\\uparrow},n_{\\downarrow}\\right) = -\\frac{3}{4}\\left(\\frac{3}{\\pi}\\right)^{1/3}\\left(n_{\\uparrow}^{4/3}+n_{\\downarrow}^{4/3}\\right),$$\nwhich yields the spin-resolved exchange potentials\n$$v_{x,\\sigma}(r) = \\frac{\\partial \\varepsilon_x}{\\partial n_{\\sigma}} = -\\left(\\frac{3}{\\pi}\\right)^{1/3} n_{\\sigma}(r)^{1/3}, \\quad \\sigma \\in \\{\\uparrow,\\downarrow\\}.$$\n- The PAW Non-Linear Core Correction (NLCC) modifies the exchange-correlation potentials by evaluating them on the total spin-resolved density that includes a non-spin-polarized core contribution, namely $n_{\\text{core},\\uparrow}(r)=n_{\\text{core},\\downarrow}(r)=\\frac{1}{2}n_{\\text{core}}(r)$. Without NLCC, the potentials are evaluated on the valence spin densities only.\n- The local exchange-correlation magnetic field is defined as\n$$B_{xc}(r) = v_{x,\\uparrow}(r) - v_{x,\\downarrow}(r),$$\nand the NLCC-induced change in this field is expected to influence the on-site magnetic moment via a local linear response described by a site susceptibility.\n\nSite-centered model:\n- The spherically averaged valence spin densities are modeled as\n$$n_{\\text{val},\\uparrow}(r) = A_{\\uparrow}\\, r^{2}\\, e^{-\\alpha r}, \\quad n_{\\text{val},\\downarrow}(r) = A_{\\downarrow}\\, r^{2}\\, e^{-\\alpha r},$$\nwith $A_{\\uparrow}>0$, $A_{\\downarrow}>0$, and $\\alpha>0$.\n- The spherically averaged core density is modeled as\n$$n_{\\text{core}}(r) = A_{c}\\, e^{-\\beta r^{2}},$$\nwith $A_{c}>0$ and $\\beta>0$. The core is assumed non-spin-polarized so that $n_{\\text{core},\\uparrow}(r)=n_{\\text{core},\\downarrow}(r)=\\frac{1}{2}n_{\\text{core}}(r)$.\n- Consider a PAW augmentation sphere of radius $R>0$ centered on the atom.\n\nTasks:\n1. Compute the baseline local magnetic moment without NLCC, $m_{0}$, defined as the integral of the valence spin density difference over the augmentation sphere,\n$$m_{0} = \\int_{|\\mathbf{r}|<R} \\left[n_{\\text{val},\\uparrow}(r) - n_{\\text{val},\\downarrow}(r)\\right]\\, d^{3}r,$$\nexpressed in Bohr magnetons per site. Use the spherically symmetric volume element and evaluate the integral exactly or numerically, ensuring scientific correctness and numerical stability.\n2. Compute the volume-averaged exchange-correlation magnetic field within the sphere, both without NLCC and with NLCC, respectively,\n$$\\langle B_{xc}^{\\text{noNLCC}} \\rangle = \\frac{1}{V}\\int_{|\\mathbf{r}|<R} \\left[v_{x,\\uparrow}\\big(n_{\\text{val},\\uparrow}(r)\\big) - v_{x,\\downarrow}\\big(n_{\\text{val},\\downarrow}(r)\\big)\\right]\\, d^{3}r,$$\n$$\\langle B_{xc}^{\\text{NLCC}} \\rangle = \\frac{1}{V}\\int_{|\\mathbf{r}|<R} \\left[v_{x,\\uparrow}\\big(n_{\\text{val},\\uparrow}(r)+\\tfrac{1}{2}n_{\\text{core}}(r)\\big) - v_{x,\\downarrow}\\big(n_{\\text{val},\\downarrow}(r)+\\tfrac{1}{2}n_{\\text{core}}(r)\\big)\\right]\\, d^{3}r,$$\nwhere $V=\\frac{4}{3}\\pi R^{3}$.\n3. Given a site susceptibility $\\chi_{\\text{site}}$ (assumed constant) that relates the average exchange-correlation field change to the induced moment change via\n$$\\Delta m = \\chi_{\\text{site}} \\left(\\langle B_{xc}^{\\text{NLCC}} \\rangle - \\langle B_{xc}^{\\text{noNLCC}} \\rangle\\right),$$\ncompute the NLCC-corrected moment $m_{\\text{corr}} = m_{0} + \\Delta m$ and report the NLCC-induced change $\\Delta m$.\n\nAngle units are not applicable. All quantities are in atomic units; report the magnetic moments in Bohr magnetons per site.\n\nTest suite:\nProvide results for the following four parameter sets, which exercise different regimes of core-valence overlap and spin polarization. Each test case is a tuple $(\\alpha, A_{\\uparrow}, A_{\\downarrow}, A_{c}, \\beta, R, \\chi_{\\text{site}})$, with all parameters in atomic units:\n- Case 1 (moderate overlap, substantial spin polarization): $(4.0,\\, 1.00,\\, 0.60,\\, 60.0,\\, 50.0,\\, 1.20,\\, 0.50)$.\n- Case 2 (minimal overlap, small spin polarization): $(4.5,\\, 0.80,\\, 0.70,\\, 20.0,\\, 100.0,\\, 1.00,\\, 0.40)$.\n- Case 3 (large overlap, strong spin polarization): $(3.5,\\, 0.90,\\, 0.40,\\, 100.0,\\, 10.0,\\, 1.50,\\, 0.60)$.\n- Case 4 (boundary case, nearly zero spin polarization): $(5.0,\\, 0.70,\\, 0.69,\\, 70.0,\\, 30.0,\\, 1.20,\\, 0.50)$.\n\nRequired final output format:\nYour program should produce a single line of output containing the NLCC-induced moment changes $\\Delta m$ for all four cases as a comma-separated list enclosed in square brackets, with each float rounded to six decimal places, for example, \"[x1,x2,x3,x4]\". The unit for each entry is Bohr magnetons per site.", "solution": "The objective is to compute the change in the local magnetic moment, $\\Delta m$, induced by the Non-Linear Core Correction (NLCC) within a simplified PAW model. The calculation proceeds in several steps. All quantities are in atomic units, and the final magnetic moment is reported in Bohr magnetons, for which the numerical value is the same in atomic units.\n\nThe NLCC-induced change in magnetic moment, $\\Delta m$, is given by a linear response model:\n$$ \\Delta m = \\chi_{\\text{site}} \\left(\\langle B_{xc}^{\\text{NLCC}} \\rangle - \\langle B_{xc}^{\\text{noNLCC}} \\rangle\\right) $$\nwhere $\\chi_{\\text{site}}$ is the site susceptibility and $\\langle B_{xc} \\rangle$ denotes the volume-averaged exchange-correlation magnetic field within the PAW augmentation sphere of radius $R$. The key task is to compute the average fields with and without NLCC.\n\nThe volume average of a spherically symmetric field $f(r)$ over a sphere of radius $R$ and volume $V = \\frac{4}{3}\\pi R^3$ is given by:\n$$ \\langle f \\rangle = \\frac{1}{V} \\int_{|\\mathbf{r}|<R} f(r) \\, d^3r = \\frac{1}{V} \\int_0^R f(r) \\, 4\\pi r^2 \\, dr = \\frac{3}{R^3} \\int_0^R f(r) \\, r^2 \\, dr $$\n\nThe exchange-correlation magnetic field is defined as $B_{xc}(r) = v_{x,\\uparrow}(r) - v_{x,\\downarrow}(r)$. Using the provided LSDA exchange potential, $v_{x,\\sigma}(n_\\sigma) = C_x n_\\sigma^{1/3}$ with $C_x = -(3/\\pi)^{1/3}$, we have:\n$$ B_{xc}(r) = C_x \\left( n_{\\uparrow}(r)^{1/3} - n_{\\downarrow}(r)^{1/3} \\right) $$\nThe spin densities $n_{\\uparrow}(r)$ and $n_{\\downarrow}(r)$ depend on whether NLCC is applied.\n\n**1. Calculation of $\\langle B_{xc}^{\\text{noNLCC}} \\rangle$**\n\nWithout NLCC, the potential is evaluated on the valence spin densities only: $n_{\\sigma}(r) = n_{\\text{val},\\sigma}(r) = A_{\\sigma} r^2 e^{-\\alpha r}$.\nThe magnetic field is:\n$$ B_{xc}^{\\text{noNLCC}}(r) = C_x \\left[ (A_{\\uparrow} r^2 e^{-\\alpha r})^{1/3} - (A_{\\downarrow} r^2 e^{-\\alpha r})^{1/3} \\right] $$\nThis expression simplifies to:\n$$ B_{xc}^{\\text{noNLCC}}(r) = C_x (A_{\\uparrow}^{1/3} - A_{\\downarrow}^{1/3}) r^{2/3} e^{-\\alpha r/3} $$\nThe volume average is then calculated by integrating this field. The integrand for the volume integral is $4\\pi r^2 B_{xc}^{\\text{noNLCC}}(r)$:\n$$ \\langle B_{xc}^{\\text{noNLCC}} \\rangle = \\frac{4\\pi C_x (A_{\\uparrow}^{1/3} - A_{\\downarrow}^{1/3})}{V} \\int_0^R r^{2/3} e^{-\\alpha r/3} \\cdot r^2 \\, dr $$\n$$ \\langle B_{xc}^{\\text{noNLCC}} \\rangle = \\frac{3 C_x (A_{\\uparrow}^{1/3} - A_{\\downarrow}^{1/3})}{R^3} \\int_0^R r^{8/3} e^{-\\alpha r/3} \\, dr $$\nThis definite integral is computed numerically for each parameter set.\n\n**2. Calculation of $\\langle B_{xc}^{\\text{NLCC}} \\rangle$**\n\nWith NLCC, the potential is evaluated on the total spin densities, which include the core density: $n_{\\sigma}(r) = n_{\\text{val},\\sigma}(r) + \\frac{1}{2} n_{\\text{core}}(r)$. Using the provided models for valence and core densities:\n$$ n_{\\sigma}(r) = A_{\\sigma} r^2 e^{-\\alpha r} + \\frac{A_c}{2} e^{-\\beta r^2} $$\nThe magnetic field is:\n$$ B_{xc}^{\\text{NLCC}}(r) = C_x \\left[ \\left(A_{\\uparrow} r^2 e^{-\\alpha r} + \\frac{A_c}{2} e^{-\\beta r^2}\\right)^{1/3} - \\left(A_{\\downarrow} r^2 e^{-\\alpha r} + \\frac{A_c}{2} e^{-\\beta r^2}\\right)^{1/3} \\right] $$\nThis expression does not simplify. The volume average requires numerical integration of the full expression:\n$$ \\langle B_{xc}^{\\text{NLCC}} \\rangle = \\frac{1}{V} \\int_0^R B_{xc}^{\\text{NLCC}}(r) \\, 4\\pi r^2 \\, dr $$\n\n**3. Algorithmic Implementation**\n\nFor each test case defined by the tuple $(\\alpha, A_{\\uparrow}, A_{\\downarrow}, A_{c}, \\beta, R, \\chi_{\\text{site}})$, the algorithm proceeds as follows:\n- The constant $C_x$ and the sphere volume $V$ are computed.\n- The integral for $\\langle B_{xc}^{\\text{noNLCC}} \\rangle$ is evaluated using a numerical quadrature method. The integrand is a smooth, well-behaved function proportional to $r^{8/3}$ near the origin, which is handled correctly by standard integration routines.\n- The integral for $\\langle B_{xc}^{\\text{NLCC}} \\rangle$ is also evaluated using numerical quadrature. The integrand involves point-wise calculation of the total densities. The integrand is proportional to $r^2$ near the origin and is well-behaved.\n- The change in the average field, $\\Delta \\langle B_{xc} \\rangle = \\langle B_{xc}^{\\text{NLCC}} \\rangle - \\langle B_{xc}^{\\text{noNLCC}} \\rangle$, is calculated.\n- Finally, the induced moment change is found via $\\Delta m = \\chi_{\\text{site}} \\Delta \\langle B_{xc} \\rangle$.\n\nThis procedure is repeated for all four test cases, and the resulting values of $\\Delta m$ are collected and formatted as required. The calculation shows that $\\Delta m$ is always positive, indicating that the NLCC enhances the local magnetic moment, which is consistent with the physics of exchange interactions.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Computes the NLCC-induced change in magnetic moment for four test cases\n    based on a simplified PAW model.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (alpha, A_up, A_down, A_c, beta, R, chi_site)\n        (4.0, 1.00, 0.60, 60.0, 50.0, 1.20, 0.50),  # Case 1\n        (4.5, 0.80, 0.70, 20.0, 100.0, 1.00, 0.40), # Case 2\n        (3.5, 0.90, 0.40, 100.0, 10.0, 1.50, 0.60), # Case 3\n        (5.0, 0.70, 0.69, 70.0, 30.0, 1.20, 0.50)   # Case 4\n    ]\n\n    results = []\n    \n    # Pre-calculate the LSDA exchange constant C_x = -(3/pi)^(1/3)\n    C_x = -(3.0 / np.pi)**(1.0/3.0)\n\n    for case in test_cases:\n        alpha, A_up, A_down, A_c, beta, R, chi_site = case\n        \n        # Volume of the augmentation sphere\n        V = (4.0 / 3.0) * np.pi * R**3\n\n        # --- Calculate <B_xc^noNLCC> ---\n        # The integral can be simplified algebraically, which is more robust\n        # and efficient than calculating the densities point-wise.\n        # B_xc_noNLCC(r) = C_x * (A_up^(1/3) - A_down^(1/3)) * r^(2/3) * exp(-alpha*r/3)\n        # The integrand for the volume integral is 4*pi*r^2 * B_xc(r)\n        \n        # This factor is constant with respect to the integration variable r\n        const_factor_noNLCC = 4.0 * np.pi * C_x * (A_up**(1.0/3.0) - A_down**(1.0/3.0))\n        \n        def integrand_noNLCC(r):\n            return const_factor_noNLCC * r**(8.0/3.0) * np.exp(-alpha * r / 3.0)\n\n        integral_noNLCC, _ = quad(integrand_noNLCC, 0, R)\n        avg_B_noNLCC = integral_noNLCC / V\n\n        # --- Calculate <B_xc^NLCC> ---\n        # For the NLCC case, we must compute the total densities point-wise\n        # as the expression does not simplify.\n        def n_val_up(r):\n            return A_up * r**2 * np.exp(-alpha * r)\n\n        def n_val_down(r):\n            return A_down * r**2 * np.exp(-alpha * r)\n\n        def n_core(r):\n            return A_c * np.exp(-beta * r**2)\n            \n        def integrand_NLCC(r):\n            n_half_core = 0.5 * n_core(r)\n            \n            n_tot_up = n_val_up(r) + n_half_core\n            n_tot_down = n_val_down(r) + n_half_core\n            \n            # The B_xc field is C_x * (n_up^(1/3) - n_down^(1/3))\n            # The integrand for the volume integral is 4*pi*r^2 * B_xc(r)\n            b_xc_nlcc_val = C_x * (n_tot_up**(1.0/3.0) - n_tot_down**(1.0/3.0))\n            return b_xc_nlcc_val * 4.0 * np.pi * r**2\n\n        integral_NLCC, _ = quad(integrand_NLCC, 0, R)\n        avg_B_NLCC = integral_NLCC / V\n\n        # --- Calculate delta_m ---\n        delta_B_xc = avg_B_NLCC - avg_B_noNLCC\n        delta_m = chi_site * delta_B_xc\n        \n        results.append(delta_m)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3480885"}]}