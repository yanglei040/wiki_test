{"hands_on_practices": [{"introduction": "The Hellmann-Feynman theorem provides a powerful and computationally efficient way to calculate forces and stresses. This exercise, [@problem_id:3456489], brings the theorem to life by having you derive the analytical force for a simple quantum system and then verify it against the fundamental definition of force as the negative gradient of the potential energy, which you will approximate using finite differences. This practice is essential for building a concrete understanding of the theorem's validity and appreciating the elegance of analytical derivatives in computational science.", "problem": "You are given a parameter-dependent quantum-mechanical model and a simple hyperelastic model. Your goal is to derive expressions for analytic forces and stress from first principles, and verify them numerically by finite differences. All quantities are dimensionless.\n\nTask A (Hellmann-Feynman force verification):\n- Consider a one-electron, two-level system with a real symmetric Hamiltonian $H(R)$ that depends on a scalar nuclear coordinate $R$. The Hamiltonian in an orthonormal basis is\n$$\nH(R) = \\begin{pmatrix}\n\\varepsilon_1 & V(R) \\\\\nV(R) & \\varepsilon_2\n\\end{pmatrix},\n\\quad\nV(R) = t \\, e^{-\\alpha R},\n$$\nwhere $\\varepsilon_1$, $\\varepsilon_2$, $t$, and $\\alpha$ are constants, and $R \\ge 0$. Let $E(R)$ denote the ground-state energy (the smallest eigenvalue of $H(R)$), and let $\\lvert \\psi(R)\\rangle$ be its normalized eigenvector.\n- Starting only from the time-independent Schrödinger equation $H(R)\\lvert \\psi(R)\\rangle = E(R)\\lvert \\psi(R)\\rangle$, the normalization condition $\\langle \\psi(R)\\vert \\psi(R)\\rangle = 1$, and the definition of force as the negative derivative of the total energy with respect to $R$, derive an analytic expression for the force $F_{\\mathrm{analytic}}(R)$ acting along $R$ when the electronic state is stationary with respect to $H(R)$. Your derivation must rely on the stationarity of the electronic state and basic differentiation rules, without assuming any pre-quoted target formula.\n- Implement a numerical verification by central finite differences. Define\n$$\nF_{\\mathrm{FD}}(R; h) \\equiv -\\frac{E(R+h) - E(R-h)}{2h},\n$$\nfor a given small step size $h>0$.\n- For each specified test case, compute the absolute error\n$$\n\\Delta F \\equiv \\left| F_{\\mathrm{analytic}}(R) - F_{\\mathrm{FD}}(R; h) \\right|.\n$$\n\nTask B (stress from energy–strain relation):\n- Consider a cubic cell of volume $\\Omega$ containing a single pair interaction whose energy depends only on the scalar separation $r$ between two sites:\n$$\nE_{\\mathrm{pair}}(r) = \\frac{1}{2} k \\left(r - r_0\\right)^2,\n$$\nwith constants $k>0$ and $r_0 \\ge 0$. Subject the cell to a small isotropic infinitesimal strain of amplitude $\\epsilon$, so that the separation transforms as $r \\mapsto r'(\\epsilon) = (1+\\epsilon)\\,r$, and the cell volume becomes $\\Omega'(\\epsilon) = (1+\\epsilon)^3 \\Omega$. Assume small-strain thermodynamics in which the Cauchy stress tensor $\\sigma_{ij}$ satisfies\n$$\n\\frac{\\partial E}{\\partial \\epsilon_{ij}}\\bigg\\rvert_{\\epsilon=0} = \\Omega\\, \\sigma_{ij},\n$$\nwhere $\\epsilon_{ij}$ is the small-strain tensor. For isotropic strain, $\\epsilon_{ij} = \\epsilon\\, \\delta_{ij}$, the Cauchy stress is hydrostatic with $\\sigma_{ij} = s\\,\\delta_{ij}$, and\n$$\n\\frac{\\partial E}{\\partial \\epsilon}\\bigg\\rvert_{\\epsilon=0} = \\Omega\\, \\mathrm{tr}\\,\\sigma = 3\\,\\Omega\\, s.\n$$\n- Starting from these definitions, derive an analytic expression $s_{\\mathrm{analytic}}$ for the hydrostatic Cauchy stress magnitude $s$ in terms of $k$, $r$, $r_0$, and $\\Omega$.\n- Implement a numerical verification by symmetric finite differences with respect to $\\epsilon$:\n$$\ns_{\\mathrm{FD}}(\\epsilon; \\delta) \\equiv \\frac{1}{3\\Omega}\\,\\frac{E_{\\mathrm{pair}}(r'(+\\delta)) - E_{\\mathrm{pair}}(r'(-\\delta))}{2\\delta},\n$$\nwhere $r'(\\pm\\delta) = (1\\pm\\delta)\\,r$ and $\\delta>0$ is small. For each specified test case, compute the absolute error\n$$\n\\Delta s \\equiv \\left| s_{\\mathrm{analytic}} - s_{\\mathrm{FD}}(\\epsilon; \\delta) \\right|.\n$$\n\nImplementation requirements:\n- Use double-precision floating point arithmetic.\n- For eigenproblems, use a numerically stable routine to obtain the smallest eigenvalue and a normalized eigenvector.\n- Use the central finite-difference formulas exactly as given above.\n\nUnits:\n- All quantities are dimensionless; no physical units are used in this problem.\n\nTest suite:\n- Task A (forces). For each tuple $(\\varepsilon_1, \\varepsilon_2, t, \\alpha, R, h)$, compute $\\Delta F$.\n  - Case A$1$: $(0, 1, 2, 0.7, 1.5, 10^{-5})$.\n  - Case A$2$: $(-0.5, 0.8, 1.2, 1.1, 0.3, 10^{-6})$.\n  - Case A$3$: $(0.3, 0.31, 0.05, 2.5, 2.0, 10^{-7})$.\n  - Case A$4$: $(5, -4, 10, 0.2, 3.0, 10^{-6})$.\n- Task B (stress). For each tuple $(k, r_0, r, \\Omega, \\delta)$, compute $\\Delta s$.\n  - Case B$1$: $(4, 1, 1.2, 10, 10^{-6})$.\n  - Case B$2$: $(2, 2, 2, 3, 10^{-6})$.\n  - Case B$3$: $(100, 1, 1.1, 1, 10^{-7})$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain the absolute errors in the following order: $\\left[\\Delta F_{\\mathrm{A1}}, \\Delta F_{\\mathrm{A2}}, \\Delta F_{\\mathrm{A3}}, \\Delta F_{\\mathrm{A4}}, \\Delta s_{\\mathrm{B1}}, \\Delta s_{\\mathrm{B2}}, \\Delta s_{\\mathrm{B3}}\\right]$.", "solution": "The problem is valid as it is scientifically sound, self-contained, and well-posed, representing a standard exercise in computational materials science. It consists of two independent tasks: A) verification of the Hellmann-Feynman force for a two-level quantum system, and B) verification of the hydrostatic stress for a simple pair-interaction model. Both tasks require an analytical derivation from first principles followed by a numerical implementation and verification.\n\n**Task A: Hellmann-Feynman Force Derivation**\n\nThe force $F(R)$ acting along a nuclear coordinate $R$ is defined as the negative gradient of the total energy $E(R)$ with respect to that coordinate:\n$$\nF(R) = -\\frac{dE(R)}{dR}.\n$$\nThe energy $E(R)$ is the ground-state eigenvalue of the position-dependent Hamiltonian $H(R)$. For a normalized eigenstate $\\lvert \\psi(R) \\rangle$ corresponding to the eigenvalue $E(R)$, the energy can be expressed as the expectation value:\n$$\nE(R) = \\langle \\psi(R) \\vert H(R) \\vert \\psi(R) \\rangle.\n$$\nDifferentiating this expression for $E(R)$ with respect to $R$ using the product rule gives:\n$$\n\\frac{dE}{dR} = \\left( \\frac{d}{dR} \\langle \\psi(R) \\vert \\right) H(R) \\vert \\psi(R) \\rangle + \\left\\langle \\psi(R) \\left\\vert \\frac{dH(R)}{dR} \\right\\vert \\psi(R) \\right\\rangle + \\left\\langle \\psi(R) \\vert H(R) \\left( \\frac{d}{dR} \\vert \\psi(R) \\rangle \\right) \\right\\rangle.\n$$\nThe problem asks the derivation to rely on the stationarity of the electronic state, which means $\\lvert \\psi(R) \\rangle$ is an eigenstate of $H(R)$. Since $H(R)$ is Hermitian, we have $H(R) \\vert \\psi(R) \\rangle = E(R) \\vert \\psi(R) \\rangle$ and, by taking the conjugate transpose, $\\langle \\psi(R) \\vert H(R) = E(R) \\langle \\psi(R) \\vert$. Substituting these into the first and third terms yields:\n$$\n\\frac{dE}{dR} = E(R) \\left( \\frac{d}{dR} \\langle \\psi(R) \\vert \\right) \\vert \\psi(R) \\rangle + \\left\\langle \\psi(R) \\left\\vert \\frac{dH(R)}{dR} \\right\\vert \\psi(R) \\right\\rangle + E(R) \\left\\langle \\psi(R) \\vert \\left( \\frac{d}{dR} \\vert \\psi(R) \\rangle \\right) \\right\\rangle.\n$$\nFactoring out the scalar energy $E(R)$:\n$$\n\\frac{dE}{dR} = \\left\\langle \\psi(R) \\left\\vert \\frac{dH(R)}{dR} \\right\\vert \\psi(R) \\right\\rangle + E(R) \\left[ \\left( \\frac{d}{dR} \\langle \\psi(R) \\vert \\right) \\vert \\psi(R) \\rangle + \\left\\langle \\psi(R) \\vert \\left( \\frac{d}{dR} \\vert \\psi(R) \\rangle \\right) \\right] \\right].\n$$\nThe term in the square brackets is the derivative of the normalization condition, $\\langle \\psi(R) \\vert \\psi(R) \\rangle = 1$:\n$$\n\\frac{d}{dR} \\langle \\psi(R) \\vert \\psi(R) \\rangle = \\frac{d}{dR}(1) = 0.\n$$\nTherefore, the second part of the expression for $\\frac{dE}{dR}$ vanishes, leaving the Hellmann-Feynman theorem:\n$$\n\\frac{dE}{dR} = \\left\\langle \\psi(R) \\left\\vert \\frac{dH(R)}{dR} \\right\\vert \\psi(R) \\right\\rangle.\n$$\nThe analytic force is thus:\n$$\nF_{\\mathrm{analytic}}(R) = - \\left\\langle \\psi(R) \\left\\vert \\frac{dH(R)}{dR} \\right\\vert \\psi(R) \\right\\rangle.\n$$\nFor the given Hamiltonian $H(R) = \\begin{pmatrix} \\varepsilon_1 & V(R) \\\\ V(R) & \\varepsilon_2 \\end{pmatrix}$ with $V(R) = t e^{-\\alpha R}$, its derivative with respect to $R$ is:\n$$\n\\frac{dH(R)}{dR} = \\begin{pmatrix} 0 & \\frac{dV}{dR} \\\\ \\frac{dV}{dR} & 0 \\end{pmatrix} = \\begin{pmatrix} 0 & -\\alpha t e^{-\\alpha R} \\\\ -\\alpha t e^{-\\alpha R} & 0 \\end{pmatrix}.\n$$\nThis expression is used to evaluate $F_{\\mathrm{analytic}}(R)$ by first finding the ground-state eigenvector $\\lvert \\psi(R) \\rangle$ of $H(R)$ and then computing the expectation value. For the numerical verification, the ground-state energy $E(R)$ is computed at $R+h$ and $R-h$ to evaluate the central difference formula $F_{\\mathrm{FD}}(R;h) = -\\frac{E(R+h) - E(R-h)}{2h}$. The absolute error $\\Delta F = |F_{\\mathrm{analytic}}(R) - F_{\\mathrm{FD}}(R;h)|$ is subsequently calculated.\n\n**Task B: Hydrostatic Stress Derivation**\n\nThe energy of the pair interaction depends on the separation $r$. Under an isotropic strain of amplitude $\\epsilon$, the separation transforms as $r \\mapsto r'(\\epsilon) = (1+\\epsilon)r$. The energy as a function of strain is:\n$$\nE(\\epsilon) = E_{\\mathrm{pair}}(r'(\\epsilon)) = \\frac{1}{2} k \\left((1+\\epsilon)r - r_0\\right)^2.\n$$\nThe problem provides the relationship between the hydrostatic stress magnitude $s$ and the derivative of energy with respect to strain, evaluated at zero strain ($\\epsilon=0$):\n$$\ns = \\frac{1}{3\\Omega} \\frac{\\partial E}{\\partial \\epsilon}\\bigg\\rvert_{\\epsilon=0}.\n$$\nFirst, we compute the derivative of $E(\\epsilon)$ with respect to $\\epsilon$ using the chain rule:\n$$\n\\frac{\\partial E}{\\partial \\epsilon} = \\frac{\\partial}{\\partial \\epsilon} \\left[\\frac{1}{2} k \\left((1+\\epsilon)r - r_0\\right)^2 \\right] = k \\left( (1+\\epsilon)r - r_0 \\right) \\cdot \\frac{\\partial}{\\partial \\epsilon}\\left( (1+\\epsilon)r - r_0 \\right) = k r \\left( (1+\\epsilon)r - r_0 \\right).\n$$\nNext, we evaluate this derivative at $\\epsilon=0$:\n$$\n\\frac{\\partial E}{\\partial \\epsilon}\\bigg\\rvert_{\\epsilon=0} = k r \\left( (1+0)r - r_0 \\right) = k r (r-r_0).\n$$\nSubstituting this result into the expression for stress yields the analytic formula:\n$$\ns_{\\mathrm{analytic}} = \\frac{k r (r - r_0)}{3\\Omega}.\n$$\nFor numerical verification, the finite difference formula $s_{\\mathrm{FD}} = \\frac{1}{3\\Omega}\\,\\frac{E_{\\mathrm{pair}}(r'(+\\delta)) - E_{\\mathrm{pair}}(r'(-\\delta))}{2\\delta}$ is used to approximate this derivative. The absolute error $\\Delta s = |s_{\\mathrm{analytic}} - s_{\\mathrm{FD}}|$ is then computed.\n\nThe implementation uses `numpy.linalg.eigh` for the stable solution of the eigenproblem in Task A and double-precision floating-point arithmetic for all calculations, as required.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the two-part problem:\n    A) Verification of the Hellmann-Feynman force.\n    B) Verification of the hydrostatic stress from an energy-strain relation.\n    The function computes and prints the absolute errors as specified.\n    \"\"\"\n\n    # Test cases defined in the problem statement.\n    test_cases_A = [\n        # (e1, e2, t, alpha, R, h)\n        (0.0, 1.0, 2.0, 0.7, 1.5, 1e-5),\n        (-0.5, 0.8, 1.2, 1.1, 0.3, 1e-6),\n        (0.3, 0.31, 0.05, 2.5, 2.0, 1e-7),\n        (5.0, -4.0, 10.0, 0.2, 3.0, 1e-6),\n    ]\n\n    test_cases_B = [\n        # (k, r0, r, Omega, delta)\n        (4.0, 1.0, 1.2, 10.0, 1e-6),\n        (2.0, 2.0, 2.0, 3.0, 1e-6),\n        (100.0, 1.0, 1.1, 1.0, 1e-7),\n    ]\n\n    results = []\n\n    # --- Task A: Hellmann-Feynman Force Verification ---\n    def get_ground_state(R_val, e1, e2, t, alpha):\n        \"\"\"\n        Constructs the Hamiltonian H(R_val) and computes its ground state\n        (lowest eigenvalue and corresponding normalized eigenvector).\n        All calculations use double-precision floating-point numbers.\n        \"\"\"\n        V_val = t * np.exp(-alpha * R_val)\n        H = np.array([[e1, V_val], [V_val, e2]], dtype=np.float64)\n        # np.linalg.eigh is a stable solver for Hermitian matrices.\n        # It returns eigenvalues in ascending order and corresponding eigenvectors.\n        eigenvalues, eigenvectors = np.linalg.eigh(H)\n        return eigenvalues[0], eigenvectors[:, 0]\n\n    for e1, e2, t, alpha, R, h in test_cases_A:\n        # Numerical force via central finite differences.\n        E_plus_h, _ = get_ground_state(R + h, e1, e2, t, alpha)\n        E_minus_h, _ = get_ground_state(R - h, e1, e2, t, alpha)\n        F_FD = -(E_plus_h - E_minus_h) / (2.0 * h)\n\n        # Analytic force via Hellmann-Feynman theorem.\n        _, psi_R = get_ground_state(R, e1, e2, t, alpha)\n        V_R = t * np.exp(-alpha * R)\n        \n        # Derivative of the Hamiltonian matrix: dH/dR.\n        dH_dR = np.array([[0.0, -alpha * V_R], \n                          [-alpha * V_R, 0.0]], dtype=np.float64)\n        \n        # F_analytic = - <psi|dH/dR|psi> = - psi.T @ dH/dR @ psi\n        # For 1D numpy arrays, @ is the dot product.\n        F_analytic = - (psi_R @ dH_dR @ psi_R)\n\n        # Compute the absolute error.\n        delta_F = np.abs(F_analytic - F_FD)\n        results.append(delta_F)\n\n    # --- Task B: Stress from Energy–Strain Relation Verification ---\n    def E_pair(r_val, k, r0):\n        \"\"\"Calculates the pair interaction energy.\"\"\"\n        return 0.5 * k * (r_val - r0)**2\n\n    for k, r0, r, Omega, delta in test_cases_B:\n        # Numerical stress via symmetric finite differences.\n        r_plus = r * (1.0 + delta)\n        r_minus = r * (1.0 - delta)\n        \n        E_plus = E_pair(r_plus, k, r0)\n        E_minus = E_pair(r_minus, k, r0)\n        \n        # Using the finite-difference formula provided in the problem.\n        s_FD = (1.0 / (3.0 * Omega)) * (E_plus - E_minus) / (2.0 * delta)\n\n        # Analytic stress derived from the energy-strain relation.\n        s_analytic = (k * r * (r - r0)) / (3.0 * Omega)\n\n        # Compute the absolute error.\n        delta_s = np.abs(s_analytic - s_FD)\n        results.append(delta_s)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3456489"}, {"introduction": "While analytically exact, forces computed in practice, especially from complex *ab initio* calculations, often contain small numerical errors that violate fundamental physical symmetries. This practice, [@problem_id:3456501], addresses this crucial issue by guiding you to enforce translational and rotational invariance on a set of noisy forces. You will construct and apply a linear projector to 'clean' the forces, ensuring they satisfy the acoustic sum rule and the zero-torque condition, a vital post-processing step for robust and physically meaningful simulations.", "problem": "You are given a set of atomic positions and noisy Hellmann-Feynman forces for several systems. In computational materials science, the invariance of the total energy under rigid translation and rotation implies that the physically consistent forces must satisfy two linear constraints simultaneously: the acoustic sum rule and the zero-torque condition. From first principles, the invariance of the total energy under an infinitesimal rigid translation $\\delta \\mathbf{r}_I = \\mathbf{t}$ for all atoms implies $\\sum_I \\mathbf{F}_I = \\mathbf{0}$. Similarly, invariance under an infinitesimal rigid rotation $\\delta \\mathbf{r}_I = \\boldsymbol{\\omega} \\times (\\mathbf{r}_I - \\mathbf{r}_0)$ implies $\\sum_I (\\mathbf{r}_I - \\mathbf{r}_0) \\times \\mathbf{F}_I = \\mathbf{0}$ for any chosen origin $\\mathbf{r}_0$. A scientifically sound post-processing approach is to find the closest set of forces to the given noisy forces that satisfies these linear constraints.\n\nStarting only from these fundamental invariances and linear algebra, derive and implement an algorithm that, for a given system with $N$ atoms and their positions $\\{\\mathbf{r}_I\\}_{I=1}^N$ in $\\text{\\AA}$ and forces $\\{\\mathbf{F}_I\\}_{I=1}^N$ in $\\text{eV}/\\text{\\AA}$, constructs a linear projector that maps the noisy force vector to the unique closest vector (in the Euclidean norm) that satisfies both $\\sum_I \\mathbf{F}_I = \\mathbf{0}$ and $\\sum_I (\\mathbf{r}_I - \\mathbf{r}_0) \\times \\mathbf{F}_I = \\mathbf{0}$. Use the geometric centroid $\\mathbf{r}_0 = \\frac{1}{N}\\sum_I \\mathbf{r}_I$ as the origin for the torque constraint. For numerical robustness and physical unit consistency when aggregating constraint violations, scale the torque constraints by $1/\\ell$, where $\\ell = \\sqrt{\\frac{1}{N}\\sum_I \\|\\mathbf{r}_I - \\mathbf{r}_0\\|^2}$ is the root-mean-square distance in $\\text{\\AA}$. This ensures that the aggregated constraint vector has unit $\\text{eV}/\\text{\\AA}$.\n\nDefine the $3N$-vector of forces as $\\mathbf{f} = [\\mathbf{F}_1^\\top,\\dots,\\mathbf{F}_N^\\top]^\\top$ and construct a $6 \\times 3N$ constraint matrix $\\mathbf{A}$ that enforces the three components of $\\sum_I \\mathbf{F}_I = \\mathbf{0}$ and the three components of $\\sum_I \\frac{1}{\\ell}(\\mathbf{r}_I - \\mathbf{r}_0) \\times \\mathbf{F}_I = \\mathbf{0}$ as linear equations in $\\mathbf{f}$. Then compute the orthogonal projection of $\\mathbf{f}$ onto the null space of $\\mathbf{A}$. In degenerate geometries where $\\ell \\approx 0$ or the constraint rows are linearly dependent, your algorithm must remain stable by using a Moore-Penrose pseudoinverse. Your program must produce, for each test case, an evaluation list containing:\n- the pre-projection violation norm $||\\mathbf{A}\\mathbf{f}||_2$ in $\\text{eV}/\\text{\\AA}$,\n- the post-projection violation norm $||\\mathbf{A}\\mathbf{f}^\\star||_2$ in $\\text{eV}/\\text{\\AA}$, where $\\mathbf{f}^\\star$ is the cleaned force vector,\n- the correction norm $||\\mathbf{f}^\\star - \\mathbf{f}||_2$ in $\\text{eV}/\\text{\\AA}$,\n- the numerical rank of $\\mathbf{A}$ as an integer.\n\nAll angles must be treated in radians conceptually, but no explicit angle quantities are part of the input or output. The final output format must be a single line containing a comma-separated list of these per-case evaluation lists, with no spaces, enclosed in square brackets, for example, $[[a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],\\dots]$.\n\nUse the following test suite, which includes a general case, a constraint-satisfying case, a degenerate geometry, and a near-colinear arrangement. For each case, positions are given in $\\text{\\AA}$ and forces are given in $\\text{eV}/\\text{\\AA}$:\n\n- Case $1$ (general noisy triatomic):\n  - Positions: $\\left[(0.0,0.0,0.0),(1.5,-0.2,0.3),(-0.7,0.6,-0.1)\\right]$\n  - Forces: $\\left[(0.21,-0.12,0.03),(-0.09,0.04,-0.11),(-0.08,0.12,0.07)\\right]$\n- Case $2$ (already consistent tetra-atomic):\n  - Positions: $\\left[(0.0,0.0,0.0),(1.0,0.0,0.0),(0.0,1.0,0.0),(0.0,0.0,1.0)\\right]$\n  - Forces: $\\left[(-2.0,1.0,1.0),(2.0,0.0,0.0),(0.0,-1.0,0.0),(0.0,0.0,-1.0)\\right]$\n- Case $3$ (degenerate geometry; all atoms at the origin):\n  - Positions: $\\left[(0.0,0.0,0.0),(0.0,0.0,0.0),(0.0,0.0,0.0)\\right]$\n  - Forces: $\\left[(0.3,-0.1,0.2),(0.05,0.08,-0.05),(-0.2,0.04,0.01)\\right]$\n- Case $4$ (near-colinear penta-atomic):\n  - Positions: $\\left[(0.0,0.0,0.0),(0.5,0.02,-0.01),(1.0,-0.03,0.0),(1.5,0.01,0.02),(2.0,-0.02,-0.01)\\right]$\n  - Forces: $\\left[(0.12,-0.05,0.03),(-0.07,0.04,-0.02),(0.09,0.02,0.01),(-0.03,-0.01,0.05),(0.04,0.0,-0.08)\\right]$\n\nYour program must implement the projector, apply it to each case, and compute the four evaluation quantities per case as described. Express all three norms in $\\text{eV}/\\text{\\AA}$ and the rank as an integer. The final printed output must be a single line containing the per-case evaluation lists, comma-separated, enclosed in square brackets, with no spaces.", "solution": "The posed problem is to find a set of atomic forces, $\\mathbf{f}^\\star$, that is closest in the Euclidean sense to a given set of noisy forces, $\\mathbf{f}$, while strictly satisfying the physical constraints of translation and rotation invariance. These constraints manifest as the acoustic sum rule (ASR) and the zero-torque condition (ZTC). This is a classic constrained optimization problem, which can be elegantly solved using orthogonal projection.\n\nThe problem can be stated mathematically as:\n$$\n\\underset{\\mathbf{f}^\\star}{\\text{minimize}} \\quad \\frac{1}{2} ||\\mathbf{f}^\\star - \\mathbf{f}||_2^2 \\\\\n\\text{subject to} \\quad \\mathbf{A}\\mathbf{f}^\\star = \\mathbf{0}\n$$\nHere, $\\mathbf{f}$ is the $3N$-dimensional vector of concatenated noisy atomic forces, $\\mathbf{f} = [\\mathbf{F}_1^\\top, \\dots, \\mathbf{F}_N^\\top]^\\top$, for a system of $N$ atoms. The matrix $\\mathbf{A}$ is a $6 \\times 3N$ matrix that encodes the six linear constraints (three for ASR, three for ZTC). The solution $\\mathbf{f}^\\star$ is the orthogonal projection of the initial vector $\\mathbf{f}$ onto the null space of the matrix $\\mathbf{A}$, denoted $\\text{Null}(\\mathbf{A})$. This subspace contains all force vectors that satisfy the physical constraints.\n\nThe projector onto the null space is given by $\\mathbf{P}_{\\text{null}} = \\mathbf{I} - \\mathbf{A}^\\dagger \\mathbf{A}$, where $\\mathbf{I}$ is the $3N \\times 3N$ identity matrix and $\\mathbf{A}^\\dagger$ is the Moore-Penrose pseudoinverse of $\\mathbf{A}$. The corrected force vector is thus $\\mathbf{f}^\\star = \\mathbf{P}_{\\text{null}}\\mathbf{f}$. A direct computation involving the $3N \\times 3N$ projector matrix is inefficient. A more stable and efficient algorithm is derived by noting that the correction vector, $\\delta\\mathbf{f} = \\mathbf{f} - \\mathbf{f}^\\star$, is the projection of $\\mathbf{f}$ onto the row space of $\\mathbf{A}$. This projection can be written as $\\delta\\mathbf{f} = \\mathbf{A}^\\top \\boldsymbol{\\lambda}$, where $\\boldsymbol{\\lambda} \\in \\mathbb{R}^6$ is a vector of Lagrange multipliers. Solving for $\\boldsymbol{\\lambda}$ via the normal equations yields $\\boldsymbol{\\lambda} = (\\mathbf{A}\\mathbf{A}^\\top)^\\dagger (\\mathbf{A}\\mathbf{f})$. The corrected force vector is then:\n$$\n\\mathbf{f}^\\star = \\mathbf{f} - \\delta\\mathbf{f} = \\mathbf{f} - \\mathbf{A}^\\top(\\mathbf{A}\\mathbf{A}^\\top)^\\dagger(\\mathbf{A}\\mathbf{f})\n$$\nThis approach requires the pseudoinverse of a much smaller $6 \\times 6$ matrix, $\\mathbf{A}\\mathbf{A}^\\top$, ensuring numerical robustness and efficiency.\n\nThe construction of the constraint matrix $\\mathbf{A}$ is a critical step. It is built from $N$ concatenated $6 \\times 3$ blocks, $\\mathbf{A} = [\\mathbf{A}_1, \\mathbf{A}_2, \\dots, \\mathbf{A}_N]$, where each block $\\mathbf{A}_I$ pertains to atom $I$.\n\nThe first $3$ rows of $\\mathbf{A}$ enforce the ASR, $\\sum_I \\mathbf{F}_I = \\mathbf{0}$. The contribution of each atom's force vector $\\mathbf{F}_I$ to this sum is linear and unweighted. Therefore, the top $3 \\times 3$ sub-block of each $\\mathbf{A}_I$ is the identity matrix, $\\mathbf{I}_3$.\n\nThe last $3$ rows enforce the scaled ZTC, $\\sum_I \\frac{1}{\\ell}(\\mathbf{r}_I - \\mathbf{r}_0) \\times \\mathbf{F}_I = \\mathbf{0}$. Here, $\\mathbf{r}_0 = \\frac{1}{N}\\sum_J \\mathbf{r}_J$ is the geometric centroid and $\\ell = \\sqrt{\\frac{1}{N}\\sum_J ||\\mathbf{r}_J - \\mathbf{r}_0||^2}$ is the root-mean-square distance, which provides a characteristic length scale for the system. Let $\\Delta\\mathbf{r}_I = \\mathbf{r}_I - \\mathbf{r}_0$. The cross product can be written using a skew-symmetric matrix, $[\\Delta\\mathbf{r}_I]_\\times$, such that $\\Delta\\mathbf{r}_I \\times \\mathbf{F}_I = [\\Delta\\mathbf{r}_I]_\\times \\mathbf{F}_I$.\n$$\n[\\Delta\\mathbf{r}_I]_\\times = \\begin{pmatrix} 0 & -\\Delta z_I & \\Delta y_I \\\\ \\Delta z_I & 0 & -\\Delta x_I \\\\ -\\Delta y_I & \\Delta x_I & 0 \\end{pmatrix}\n$$\nThe bottom $3 \\times 3$ sub-block of $\\mathbf{A}_I$ is therefore $\\frac{1}{\\ell}[\\Delta\\mathbf{r}_I]_\\times$. The full block for atom $I$ is $\\mathbf{A}_I = \\begin{pmatrix} \\mathbf{I}_3 \\\\ \\frac{1}{\\ell} [\\Delta\\mathbf{r}_I]_{\\times} \\end{pmatrix}$.\n\nThe algorithm must robustly handle degenerate geometries. If all atoms are at the same position, $\\ell = 0$. The ZTC is trivially satisfied, and the corresponding rows in $\\mathbf{A}$ must be zero to reflect this. The implementation checks if $\\ell$ is below a numerical tolerance and if so, the ZTC rows are not constructed. In cases of near-colinear atomic arrangements, the ZTC rows become nearly linearly dependent. The use of the Moore-Penrose pseudoinverse, as provided by `numpy.linalg.pinv`, correctly handles this by working with the numerical rank of the matrix, ensuring a stable and accurate projection.\n\nThe implementation calculates four evaluation metrics:\n1.  Pre-projection violation norm, $||\\mathbf{A}\\mathbf{f}||_2$: The norm of the constraint violations for the initial noisy forces.\n2.  Post-projection violation norm, $||\\mathbf{A}\\mathbf{f}^\\star||_2$: The norm of the violations for the cleaned forces, which should be numerically close to $0$.\n3.  Correction norm, $||\\mathbf{f}^\\star - \\mathbf{f}||_2$: The magnitude of the change applied to the forces.\n4.  The numerical rank of $\\mathbf{A}$: An integer indicating the number of linearly independent constraints, determined using a singular value decomposition-based method.\n\nThis procedure provides a physically sound and numerically stable method to \"clean\" noisy ab initio forces, ensuring they conform to fundamental symmetries.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements an algorithm to project noisy Hellmann-Feynman forces\n    onto the subspace of physically consistent forces satisfying the acoustic sum\n    rule and zero-torque condition.\n    \"\"\"\n    test_cases = [\n        {\n            \"positions\": np.array([[0.0, 0.0, 0.0], [1.5, -0.2, 0.3], [-0.7, 0.6, -0.1]]),\n            \"forces\": np.array([[0.21, -0.12, 0.03], [-0.09, 0.04, -0.11], [-0.08, 0.12, 0.07]]),\n        },\n        {\n            \"positions\": np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]),\n            \"forces\": np.array([[-2.0, 1.0, 1.0], [2.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]),\n        },\n        {\n            \"positions\": np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]),\n            \"forces\": np.array([[0.3, -0.1, 0.2], [0.05, 0.08, -0.05], [-0.2, 0.04, 0.01]]),\n        },\n        {\n            \"positions\": np.array([[0.0, 0.0, 0.0], [0.5, 0.02, -0.01], [1.0, -0.03, 0.0], [1.5, 0.01, 0.02], [2.0, -0.02, -0.01]]),\n            \"forces\": np.array([[0.12, -0.05, 0.03], [-0.07, 0.04, -0.02], [0.09, 0.02, 0.01], [-0.03, -0.01, 0.05], [0.04, 0.0, -0.08]]),\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        positions = case[\"positions\"]\n        forces = case[\"forces\"]\n        \n        N = positions.shape[0]\n        dim = positions.shape[1]\n        \n        # Flatten force vector\n        f = forces.flatten()\n        \n        # 1. Calculate geometric centroid and RMS distance\n        r0 = np.mean(positions, axis=0)\n        delta_r = positions - r0\n        ell_sq = np.mean(np.sum(delta_r**2, axis=1))\n        \n        # Use a small tolerance for ell\n        ell = np.sqrt(ell_sq) if ell_sq > 1e-12 else 0.0\n        \n        # 2. Construct the 6x3N constraint matrix A\n        A = np.zeros((2 * dim, N * dim))\n        \n        for i in range(N):\n            # Acoustic Sum Rule part (ASR)\n            A[0:dim, i*dim:(i+1)*dim] = np.identity(dim)\n            \n            # Zero-Torque Condition part (ZTC)\n            if ell > 1e-9:\n                dr = delta_r[i]\n                # Skew-symmetric matrix for cross product\n                skew_matrix = np.array([\n                    [0, -dr[2], dr[1]],\n                    [dr[2], 0, -dr[0]],\n                    [-dr[1], dr[0], 0]\n                ])\n                A[dim:2*dim, i*dim:(i+1)*dim] = (1.0 / ell) * skew_matrix\n\n        # 3. Calculate pre-projection violation\n        pre_violation = A @ f\n        pre_violation_norm = np.linalg.norm(pre_violation)\n        \n        # 4. Compute the projector and apply it\n        # Efficient method: f_star = f - A.T @ pinv(A @ A.T) @ (A @ f)\n        G = A @ A.T  # 6x6 matrix\n        G_pinv = np.linalg.pinv(G)\n        \n        # Correction vector\n        delta_f = A.T @ G_pinv @ pre_violation\n        f_star = f - delta_f\n        \n        # 5. Calculate post-projection violation\n        post_violation = A @ f_star\n        post_violation_norm = np.linalg.norm(post_violation)\n        \n        # 6. Calculate correction norm\n        correction_norm = np.linalg.norm(delta_f)\n        \n        # 7. Calculate numerical rank of A\n        rank_A = np.linalg.matrix_rank(A)\n        \n        all_results.append([\n            pre_violation_norm,\n            post_violation_norm,\n            correction_norm,\n            rank_A\n        ])\n\n    # Format the final output string as requested\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3456501"}, {"introduction": "Modern density functional theory increasingly relies on nonlocal functionals to accurately capture long-range interactions, such as van der Waals forces. In this advanced exercise, [@problem_id:3456524], you will apply the formal definition of the stress tensor, $\\sigma_{\\alpha\\beta} = \\frac{1}{\\Omega}\\frac{\\partial E}{\\partial \\epsilon_{\\alpha\\beta}}$, to a nonlocal correlation energy functional. By using Fast Fourier Transforms to efficiently handle the nonlocal convolution, you will compute the interlayer stress in a model of graphite, connecting the abstract Hellmann-Feynman formalism to a tangible material property.", "problem": "You are given the nonlocal van der Waals (vdW) correlation energy functional, defined for an electronic number density $n(\\mathbf{r})$ as\n$$\nE_c^{\\mathrm{nl}} = \\frac{1}{2}\\iint n(\\mathbf{r})\\,\\Phi(\\mathbf{r},\\mathbf{r}')\\,n(\\mathbf{r}')\\,d\\mathbf{r}\\,d\\mathbf{r}'.\n$$\nYour task is to obtain the contribution to the Cauchy stress tensor $\\sigma_{\\alpha\\beta}$ from $E_c^{\\mathrm{nl}}$ by functional differentiation with respect to a small homogeneous strain tensor $\\epsilon_{\\alpha\\beta}$, starting from first principles. Use the fact that the Cauchy stress is defined by\n$$\n\\sigma_{\\alpha\\beta} = \\frac{1}{\\Omega}\\left.\\frac{\\partial E}{\\partial \\epsilon_{\\alpha\\beta}}\\right|_{\\epsilon=0},\n$$\nwhere $\\Omega$ is the undeformed cell volume, and $E$ is the total energy functional. Work under the Hellmann-Feynman principle (the density is the stationary solution of the variational problem), assume a homogeneous infinitesimal strain, and restrict to an isotropic nonlocal kernel of the form $\\Phi(\\mathbf{r},\\mathbf{r}')=\\phi(|\\mathbf{r}-\\mathbf{r}'|)$ that depends only on the scalar separation.\n\nAfter your derivation, implement a numerical evaluator that computes the $zz$-component of the nonlocal stress, $\\sigma_{zz}^{\\mathrm{nl}}$, for a simplified model of graphite consisting of two parallel graphene-like electron sheets per unit cell. To ensure universality and testability, use the following model and parameters.\n\n- Geometry and discretization:\n  - Orthorhombic periodic cell of dimensions $L_x \\times L_y \\times L_z$ with $L_x=L_y$ and $L_z=c$.\n  - Discrete grid sizes $N_x=N_y$ and $N_z$.\n  - The two electron sheets are located at $z_1=\\frac{1}{4}L_z$ and $z_2=\\frac{3}{4}L_z$.\n- Electron density:\n  - Laterally uniform Gaussian sheets along $z$, with areal electron density $n_{2\\mathrm{D}}$ per sheet and Gaussian width $s_z$ along $z$.\n  - The three-dimensional density is\n    $$\n    n(x,y,z)=\\sum_{i=1}^{2}\\frac{n_{2\\mathrm{D}}}{\\sqrt{2\\pi}\\,s_z}\\exp\\!\\left(-\\frac{d_z(z,z_i;L_z)^2}{2 s_z^2}\\right),\n    $$\n    where $d_z(z,z_i;L_z)$ is the minimum image periodic separation along $z$ between $z$ and $z_i$ in a cell of height $L_z$.\n- Nonlocal kernel:\n  - Isotropic and attractive, with short-range regularization,\n    $$\n    \\phi(R) = -\\frac{C_6}{R^6 + R_c^6},\n    $$\n    where $R=|\\mathbf{r}-\\mathbf{r}'|$, $C_6$ is a constant in electronvolt-angstrom units, and $R_c$ is a positive cutoff length in angstroms.\n\nNumerical definition of the stress to be implemented:\n- Use a central finite difference with respect to a uniaxial strain $\\epsilon_{zz}$ applied along $z$ at fixed $L_x$ and $L_y$, i.e., $L_z(\\epsilon)=L_z^{(0)}(1+\\epsilon)$, with a small strain magnitude $\\delta$.\n- The nonlocal energy is to be computed in the periodic cell by discrete convolution on the grid,\n  $$\n  E_c^{\\mathrm{nl}} \\approx \\frac{1}{2}\\sum_{\\mathbf{r}_i}\\sum_{\\mathbf{r}_j} n(\\mathbf{r}_i)\\,\\phi(\\mathbf{r}_i-\\mathbf{r}_j)\\,n(\\mathbf{r}_j)\\,\\Delta V^2,\n  $$\n  where $\\Delta V=\\frac{L_x L_y L_z}{N_x N_y N_z}$ and the periodic distance in $\\phi$ is the minimum-image distance under the cell metric. You must evaluate the discrete convolution efficiently using Fast Fourier Transforms so that the computational cost remains tractable.\n- Compute\n  $$\n  \\sigma_{zz}^{\\mathrm{nl}} \\approx \\frac{1}{\\Omega_0}\\frac{E_c^{\\mathrm{nl}}(\\epsilon=+\\delta)-E_c^{\\mathrm{nl}}(\\epsilon=-\\delta)}{2\\delta},\n  $$\n  with $\\Omega_0=L_x L_y L_z^{(0)}$ and $L_z^{(0)}=c$.\n\nUnits and constants:\n- Use $L_x=L_y=\\,$$12.0$ $\\mathrm{\\AA}$, $N_x=N_y=\\,$$16$, $N_z=\\,$$64$, $s_z=\\,$$0.35$ $\\mathrm{\\AA}$, $n_{2\\mathrm{D}}=\\,$$1.35$ $\\mathrm{electrons}/\\mathrm{\\AA}^2$, $C_6=\\,$$20.0$ $\\mathrm{eV}\\,\\mathrm{\\AA}^6$, $R_c=\\,$$2.0$ $\\mathrm{\\AA}$, and $\\delta=\\,$$10^{-3}$.\n- Express the final stress in gigapascals (GPa), using the conversion $1\\,\\mathrm{eV}/\\mathrm{\\AA}^3 = 160.21766208\\,\\mathrm{GPa}$, and report positive values for tensile response along $z$.\n\nTest suite:\n- Evaluate $\\sigma_{zz}^{\\mathrm{nl}}$ for the following interlayer spacings $c$ (in angstroms): $3.35$, $6.70$, $2.80$, $20.0$.\n- These test points cover a typical graphite separation (happy path), a doubled spacing (weak interaction regime), a compressed spacing (stronger interaction), and a far-separated limit (edge case approaching zero interaction).\n\nFinal output format:\n- Your program should produce a single line of output containing the four results as a comma-separated list enclosed in square brackets, for example, $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$.\n- Each result must be a floating-point number representing $\\sigma_{zz}^{\\mathrm{nl}}$ in $\\mathrm{GPa}$, rounded to exactly six decimal places.", "solution": "The problem asks for two tasks: first, to derive the analytical expression for the nonlocal van der Waals (vdW) contribution to the Cauchy stress tensor, and second, to implement a numerical calculation of the $zz$-component of this stress tensor for a specific model system.\n\n### Part 1: Analytical Derivation of the Nonlocal Stress Tensor\n\nThe contribution to the Cauchy stress tensor $\\sigma_{\\alpha\\beta}$ from an energy functional $E$ is defined as the derivative of the energy with respect to a homogeneous strain tensor $\\epsilon_{\\alpha\\beta}$, evaluated at zero strain:\n$$\n\\sigma_{\\alpha\\beta} = \\frac{1}{\\Omega}\\left.\\frac{\\partial E}{\\partial \\epsilon_{\\alpha\\beta}}\\right|_{\\epsilon=0},\n$$\nwhere $\\Omega$ is the volume of the undeformed system. We start with the nonlocal vdW correlation energy functional, $E_c^{\\mathrm{nl}}$:\n$$\nE_c^{\\mathrm{nl}} = \\frac{1}{2}\\iint n(\\mathbf{r})\\,\\Phi(\\mathbf{r},\\mathbf{r}')\\,n(\\mathbf{r}')\\,d\\mathbf{r}\\,d\\mathbf{r}'.\n$$\nThe problem specifies that the kernel $\\Phi$ is isotropic, i.e., $\\Phi(\\mathbf{r},\\mathbf{r}') = \\phi(|\\mathbf{r}-\\mathbf{r}'|)$.\n\nLet us apply a small, homogeneous strain described by the tensor $\\epsilon_{\\alpha\\beta}$. A point with coordinates $\\mathbf{r}$ in the undeformed lattice is mapped to a new position $\\mathbf{r}^S$ in the strained lattice:\n$$\n\\mathbf{r}^S = (\\mathbf{I} + \\boldsymbol{\\epsilon})\\mathbf{r},\n$$\nwhere $\\mathbf{I}$ is the identity matrix. The energy of the strained system, $E_c^{\\mathrm{nl}}(\\boldsymbol{\\epsilon})$, is given by the same functional form, but integrated over the strained volume and using the strained density $n^S(\\mathbf{r}^S)$.\n$$\nE_c^{\\mathrm{nl}}(\\boldsymbol{\\epsilon}) = \\frac{1}{2}\\iint n^S(\\mathbf{r}^S)\\,\\phi(|\\mathbf{r}^S-\\mathbf{r}'^S|)\\,n^S(\\mathbf{r}'^S)\\,d\\mathbf{r}^S\\,d\\mathbf{r}'^S.\n$$\nThe Hellmann-Feynman principle allows us to calculate the derivative of the energy by considering only the explicit dependence of the Hamiltonian (and thus the energy expression) on the strain, without needing the first-order response of the electron density. This is because the ground-state density is stationary with respect to variations. The transformation of the density function is governed by particle number conservation: $n^S(\\mathbf{r}^S)d\\mathbf{r}^S = n(\\mathbf{r})d\\mathbf{r}$. The transformation of the volume element is $d\\mathbf{r}^S = \\det(\\mathbf{I} + \\boldsymbol{\\epsilon})d\\mathbf{r}$.\n\nBy changing the integration variables from the strained coordinates ($\\mathbf{r}^S, \\mathbf{r}'^S$) back to the unstrained coordinates ($\\mathbf{r}, \\mathbf{r}'$), the energy becomes:\n$$\nE_c^{\\mathrm{nl}}(\\boldsymbol{\\epsilon}) = \\frac{1}{2}\\iint \\frac{n(\\mathbf{r})}{\\det(\\mathbf{I}+\\boldsymbol{\\epsilon})} \\phi(|(\\mathbf{I}+\\boldsymbol{\\epsilon})(\\mathbf{r}-\\mathbf{r}')|) \\frac{n(\\mathbf{r}')}{\\det(\\mathbf{I}+\\boldsymbol{\\epsilon})} \\left(\\det(\\mathbf{I}+\\boldsymbol{\\epsilon})\\right)^2 \\,d\\mathbf{r}\\,d\\mathbf{r}'.\n$$\nThe Jacobian determinants conveniently cancel, yielding:\n$$\nE_c^{\\mathrm{nl}}(\\boldsymbol{\\epsilon}) = \\frac{1}{2}\\iint n(\\mathbf{r})\\,\\phi(|(\\mathbf{I}+\\boldsymbol{\\epsilon})(\\mathbf{r}-\\mathbf{r}')|)\\,n(\\mathbf{r}')\\,d\\mathbf{r}\\,d\\mathbf{r}'.\n$$\nLet $\\mathbf{R} = \\mathbf{r}-\\mathbf{r}'$. The argument of the kernel is the magnitude of the strained vector $\\mathbf{R}^S = (\\mathbf{I}+\\boldsymbol{\\epsilon})\\mathbf{R}$. Let $D = |\\mathbf{R}^S|$. The squared magnitude is:\n$$\nD^2 = \\mathbf{R}^{S\\top}\\mathbf{R}^S = ((\\mathbf{I}+\\boldsymbol{\\epsilon})\\mathbf{R})^\\top ((\\mathbf{I}+\\boldsymbol{\\epsilon})\\mathbf{R}) = \\mathbf{R}^\\top (\\mathbf{I}+\\boldsymbol{\\epsilon}^\\top)(\\mathbf{I}+\\boldsymbol{\\epsilon})\\mathbf{R}.\n$$\nFor an infinitesimal strain, we can neglect terms of order $\\boldsymbol{\\epsilon}^2$. Also, assuming a symmetric strain tensor $\\boldsymbol{\\epsilon}=\\boldsymbol{\\epsilon}^\\top$ (as the antisymmetric part corresponds to a pure rotation, which leaves the isotropic kernel unchanged), we have:\n$$\nD^2 \\approx \\mathbf{R}^\\top (\\mathbf{I}+2\\boldsymbol{\\epsilon})\\mathbf{R} = R^2 + 2\\mathbf{R}^\\top\\boldsymbol{\\epsilon}\\mathbf{R} = R^2 + 2\\sum_{\\mu\\nu}\\epsilon_{\\mu\\nu}R_\\mu R_\\nu.\n$$\nNow, we differentiate the energy with respect to a component of the strain tensor, $\\epsilon_{\\alpha\\beta}$.\n$$\n\\frac{\\partial E_c^{\\mathrm{nl}}}{\\partial \\epsilon_{\\alpha\\beta}} = \\frac{1}{2}\\iint n(\\mathbf{r})\\,n(\\mathbf{r}')\\,\\frac{d\\phi(D)}{d D}\\frac{\\partial D}{\\partial\\epsilon_{\\alpha\\beta}}\\,d\\mathbf{r}\\,d\\mathbf{r}'.\n$$\nUsing the chain rule on $D^2$, we find $2D \\frac{\\partial D}{\\partial \\epsilon_{\\alpha\\beta}} = \\frac{\\partial D^2}{\\partial \\epsilon_{\\alpha\\beta}}$. From the expression for $D^2$ and assuming independent strain components, we get:\n$$\n\\frac{\\partial D^2}{\\partial \\epsilon_{\\alpha\\beta}} = 2 R_\\alpha R_\\beta,\n$$\nwhich gives $\\frac{\\partial D}{\\partial \\epsilon_{\\alpha\\beta}} = \\frac{R_\\alpha R_\\beta}{D}$. Evaluating at zero strain ($\\boldsymbol{\\epsilon}=0$), we have $D=R$, and:\n$$\n\\left.\\frac{\\partial D}{\\partial \\epsilon_{\\alpha\\beta}}\\right|_{\\boldsymbol{\\epsilon}=0} = \\frac{R_\\alpha R_\\beta}{R}.\n$$\nSubstituting this back into the derivative of the energy and evaluating at $\\boldsymbol{\\epsilon}=0$:\n$$\n\\left.\\frac{\\partial E_c^{\\mathrm{nl}}}{\\partial \\epsilon_{\\alpha\\beta}}\\right|_{\\boldsymbol{\\epsilon}=0} = \\frac{1}{2}\\iint n(\\mathbf{r})\\,n(\\mathbf{r}')\\,\\frac{d\\phi(R)}{dR}\\,\\frac{R_\\alpha R_\\beta}{R}\\,d\\mathbf{r}\\,d\\mathbf{r}',\n$$\nwhere $R=|\\mathbf{r}-\\mathbf{r}'|$. Finally, the contribution to the Cauchy stress tensor from the nonlocal correlation energy is:\n$$\n\\sigma_{\\alpha\\beta}^{\\mathrm{nl}} = \\frac{1}{2\\Omega}\\iint n(\\mathbf{r})\\,n(\\mathbf{r}')\\,\\left(-\\frac{d\\phi(R)}{dR}\\frac{R_\\alpha}{R}\\right)(-R_\\beta)\\,d\\mathbf{r}\\,d\\mathbf{r}'.\n$$\nThis expression has a clear physical interpretation. The term $-\\frac{d\\phi(R)}{dR}\\frac{\\mathbf{R}}{R}$ represents the force exerted on a particle at $\\mathbf{r}$ due to a particle at $\\mathbf{r}'$. The stress tensor is the flux of the $\\alpha$-component of this force density across a surface with normal in the $\\beta$-direction, averaged over the volume.\n\n### Part 2: Numerical Implementation Strategy\n\nThe problem requires the numerical evaluation of $\\sigma_{zz}^{\\mathrm{nl}}$ using a central finite difference approximation for the derivative with respect to a uniaxial strain $\\epsilon_{zz} = \\epsilon$:\n$$\n\\sigma_{zz}^{\\mathrm{nl}} \\approx \\frac{1}{\\Omega_0}\\frac{E_c^{\\mathrm{nl}}(\\epsilon=+\\delta)-E_c^{\\mathrm{nl}}(\\epsilon=-\\delta)}{2\\delta}.\n$$\nHere, $\\Omega_0 = L_x L_y c$ is the volume of the undeformed cell with interlayer spacing $c$, and $\\delta$ is a small strain magnitude. The strain is applied by changing the cell height to $L_z(\\epsilon) = c(1+\\epsilon)$.\n\nThe core of the calculation is the evaluation of the discrete nonlocal energy $E_c^{\\mathrm{nl}}$ for the strained cell:\n$$\nE_c^{\\mathrm{nl}} \\approx \\frac{1}{2}\\sum_{i}\\sum_{j} n(\\mathbf{r}_i)\\,\\phi(\\mathbf{r}_i-\\mathbf{r}_j)\\,n(\\mathbf{r}_j)\\,\\Delta V^2,\n$$\nwhere $\\mathbf{r}_i$ are the grid points and $\\Delta V = \\frac{L_x L_y L_z}{N_x N_y N_z}$ is the grid cell volume. The double summation is a discrete convolution. Let $n_i = n(\\mathbf{r}_i)$ and $\\phi_{i-j} = \\phi(\\mathbf{r}_i-\\mathbf{r}_j)$. The energy is:\n$$\nE_c^{\\mathrm{nl}} \\approx \\frac{(\\Delta V)^2}{2} \\sum_{i} n_i \\left( \\sum_{j} \\phi_{i-j} n_j \\right) = \\frac{(\\Delta V)^2}{2} \\sum_{i} n_i (\\phi \\circledast n)_i.\n$$\nThis convolution $(\\phi \\circledast n)$ is computed efficiently using the convolution theorem with Fast Fourier Transforms (FFT):\n$$\n\\phi \\circledast n = \\mathcal{F}^{-1}\\{\\mathcal{F}\\{\\phi\\} \\cdot \\mathcal{F}\\{n\\}\\},\n$$\nwhere $\\mathcal{F}$ and $\\mathcal{F}^{-1}$ denote the forward and inverse discrete FFT, respectively.\n\nThe numerical algorithm is as follows:\n1.  For each given interlayer spacing $c$, set the undeformed cell volume $\\Omega_0 = L_x L_y c$.\n2.  Define two strain values: $\\epsilon_+ = +\\delta$ and $\\epsilon_- = -\\delta$.\n3.  For each strain $\\epsilon \\in \\{\\epsilon_+, \\epsilon_-\\}$, calculate the corresponding energy $E_c^{\\mathrm{nl}}(\\epsilon)$:\n    a.  Set the strained cell height $L_z = c(1+\\epsilon)$. Define the grid spacings $\\Delta x, \\Delta y, \\Delta z$ and the volume element $\\Delta V$.\n    b.  Construct the 3D density array $n(\\mathbf{r})$ on the grid. The density is constant in $x$ and $y$, and along $z$ it is a sum of two Gaussians centered at $z_1 = L_z/4$ and $z_2 = 3L_z/4$. Periodic boundary conditions are handled by computing minimum image distances.\n    c.  Construct the 3D kernel array $\\phi(\\mathbf{r})$. The value at each grid point corresponds to $\\phi(R)$ where $R$ is the minimum image distance from the origin to that grid point. The coordinates for the kernel must be arranged in the specific order required by the FFT algorithm (i.e., `[0, 1, ..., N/2-1, -N/2, ..., -1]` pattern for each dimension). This is readily achieved using `numpy.fft.fftfreq`.\n    d.  Compute the FFTs of the density and kernel arrays: $\\tilde{n} = \\mathcal{F}\\{n\\}$ and $\\tilde{\\phi} = \\mathcal{F}\\{\\phi\\}$.\n    e.  Compute the element-wise product $\\tilde{V} = \\tilde{n} \\cdot \\tilde{\\phi}$.\n    f.  Compute the inverse FFT to get the convolution result in real space: $V_{\\text{conv}} = \\mathcal{F}^{-1}\\{\\tilde{V}\\}$.\n    g.  Calculate the energy: $E_c^{\\mathrm{nl}}(\\epsilon) = \\frac{1}{2}(\\Delta V)^2 \\text{np.sum}(n \\cdot \\text{real}(V_{\\text{conv}}))$.\n4.  Compute the stress using the finite difference formula: $\\sigma_{zz}^{\\mathrm{nl}} = (E_c^{\\mathrm{nl}}(\\epsilon_+) - E_c^{\\mathrm{nl}}(\\epsilon_-)) / (2\\delta\\Omega_0)$.\n5.  Convert the stress from units of $\\mathrm{eV}/\\mathrm{\\AA}^3$ to GPa using the given conversion factor.\n6.  The final result is reported for each value of $c$ in the test suite.\n\nSince the vdW interaction is attractive, the energy will be negative. Stretching the layers apart (positive strain) will make the energy less negative (increase it). Therefore, we expect $E(\\delta) > E(-\\delta)$ and a positive (tensile) stress.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the zz-component of the nonlocal stress tensor for a model of graphite.\n    \"\"\"\n    \n    # --- Physical and numerical constants from the problem statement ---\n    Lx = 12.0  # Angstrom\n    Ly = 12.0  # Angstrom\n    Nx = 16\n    Ny = 16\n    Nz = 64\n    sz = 0.35  # Angstrom\n    n2D = 1.35  # electrons/Angstrom^2\n    C6 = 20.0  # eV * Angstrom^6\n    Rc = 2.0  # Angstrom\n    delta = 1e-3  # Dimensionless strain\n    eV_per_A3_to_GPa = 160.21766208\n\n    # --- Test suite for interlayer spacing c ---\n    test_cs = [3.35, 6.70, 2.80, 20.0]\n\n    def calculate_energy(c_val, epsilon):\n        \"\"\"\n        Calculates the nonlocal correlation energy for a given cell height and strain.\n        \"\"\"\n        Lz = c_val * (1.0 + epsilon)\n        \n        # Grid parameters\n        dx, dy, dz = Lx / Nx, Ly / Ny, Lz / Nz\n        dV = dx * dy * dz\n        \n        # --- Construct 3D density grid n(r) ---\n        z_coords = np.arange(Nz) * dz\n        zg, _, _ = np.meshgrid(z_coords, np.arange(Ny), np.arange(Nx), indexing='ij')\n\n        z1 = 0.25 * Lz\n        z2 = 0.75 * Lz\n\n        # Minimum image distance along z\n        dist_z1 = zg - z1\n        dist_z1 -= Lz * np.round(dist_z1 / Lz)\n        \n        dist_z2 = zg - z2\n        dist_z2 -= Lz * np.round(dist_z2 / Lz)\n\n        prefactor = n2D / (np.sqrt(2.0 * np.pi) * sz)\n        n_grid = prefactor * (np.exp(-dist_z1**2 / (2.0 * sz**2)) + \n                               np.exp(-dist_z2**2 / (2.0 * sz**2)))\n        \n        # --- Construct 3D kernel grid phi(r) ---\n        # Create distance vectors for FFT ordering (minimum image convention)\n        dist_x_vec = Lx * np.fft.fftfreq(Nx)\n        dist_y_vec = Ly * np.fft.fftfreq(Ny)\n        dist_z_vec = Lz * np.fft.fftfreq(Nz)\n\n        Dz_grid, Dy_grid, Dx_grid = np.meshgrid(dist_z_vec, dist_y_vec, dist_x_vec, indexing='ij')\n        \n        R2 = Dx_grid**2 + Dy_grid**2 + Dz_grid**2\n        \n        # Regularized kernel phi(R) = -C6 / (R^6 + Rc^6)\n        phi_grid = -C6 / (np.power(R2, 3) + Rc**6)\n        \n        # --- Compute energy via FFT convolution ---\n        # E = 0.5 * (dV)^2 * sum_{i} n_i * (phi * n)_i\n        # where (phi * n) is discrete circular convolution\n        n_tilde = np.fft.fftn(n_grid)\n        phi_tilde = np.fft.fftn(phi_grid)\n        \n        convolution_result = np.fft.ifftn(n_tilde * phi_tilde)\n        \n        # The sum is over all grid points.\n        energy_sum = np.sum(n_grid * np.real(convolution_result))\n        \n        energy = 0.5 * dV**2 * energy_sum\n        \n        return energy\n\n    results_gpa = []\n    for c in test_cs:\n        # Undeformed volume\n        Omega0 = Lx * Ly * c\n\n        # Calculate energy at positive and negative strain\n        E_plus_delta = calculate_energy(c, +delta)\n        E_minus_delta = calculate_energy(c, -delta)\n\n        # Finite difference approximation for stress\n        stress_zz_eV_per_A3 = (E_plus_delta - E_minus_delta) / (2.0 * delta * Omega0)\n        \n        # Convert to GPa\n        stress_zz_gpa = stress_zz_eV_per_A3 * eV_per_A3_to_GPa\n        \n        results_gpa.append(stress_zz_gpa)\n\n    # Format results to 6 decimal places and print\n    formatted_results = [f\"{res:.6f}\" for res in results_gpa]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```", "id": "3456524"}]}