{"hands_on_practices": [{"introduction": "The first step in any calculation involving Brillouin zone integration is the generation of the discrete sampling points. This fundamental exercise [@problem_id:3467044] guides you through the process of implementing a Monkhorst-Pack grid generator from first principles, starting from arbitrary real-space lattice vectors. Completing this practice will solidify your understanding of reciprocal space, coordinate transformations, and the crucial algorithm for mapping $k$-points into the non-trivial geometry of the first Brillouin zone.", "problem": "You are to derive and implement, from first principles, an algorithm that constructs a uniform set of sampling points in the reciprocal space of a crystal and maps them into the First Brillouin Zone (FBZ). The algorithm must generate all points of a three-dimensional grid commonly used in band-structure calculations and ensure these points lie within the FBZ, defined as the Wigner–Seitz (WS) cell of the reciprocal lattice. The mesh must be expressed in fractional coordinates with respect to the reciprocal primitive vectors.\n\nFundamental bases and definitions to use:\n\n- Let the triple of real-space primitive lattice vectors be the columns of the matrix $\\mathbf{A} \\in \\mathbb{R}^{3 \\times 3}$ with units in Angstroms. The reciprocal lattice primitive vectors are defined by $\\mathbf{B} = 2\\pi \\left( \\mathbf{A}^{-1} \\right)^{\\top}$ and have units in inverse Angstroms. Any reciprocal lattice vector can be written as $\\mathbf{G} = n_1 \\mathbf{b}_1 + n_2 \\mathbf{b}_2 + n_3 \\mathbf{b}_3 = \\mathbf{B}\\mathbf{n}$ where $\\mathbf{n} \\in \\mathbb{Z}^3$.\n\n- A point in reciprocal space $\\mathbf{k}$ may be parameterized in fractional coordinates $\\mathbf{f} \\in \\mathbb{R}^3$ as $\\mathbf{k} = \\mathbf{B}\\mathbf{f}$.\n\n- The First Brillouin Zone (FBZ), which is the Wigner–Seitz (WS) cell of the reciprocal lattice, is the set of points $\\mathbf{k}$ that are closer to the origin $\\mathbf{0}$ than to any other reciprocal lattice point. Equivalently, $\\mathbf{k}$ is in the FBZ if for all nonzero $\\mathbf{n} \\in \\mathbb{Z}^3$, $\\lVert \\mathbf{k} \\rVert \\le \\lVert \\mathbf{k} - \\mathbf{B}\\mathbf{n} \\rVert$.\n\nYour goals:\n\n1. Starting from the requirement of uniform sampling density along each reciprocal primitive direction and symmetry about the $\\Gamma$ point (the origin), construct in fractional coordinates a three-dimensional grid with $N_1 \\times N_2 \\times N_3$ points such that along each direction the $N_i$ samples are uniformly spaced and centered with respect to the origin. Denote the fractional coordinates by $\\mathbf{f}_{m_1,m_2,m_3}$ for indices $m_i \\in \\{1,2,\\dots,N_i\\}$.\n\n2. Implement a mapping for each $\\mathbf{k} = \\mathbf{B}\\mathbf{f}$ into the FBZ by subtracting an appropriate reciprocal lattice vector $\\mathbf{G} = \\mathbf{B}\\mathbf{n}$, where $\\mathbf{n} \\in \\mathbb{Z}^3$ is chosen to minimize the Euclidean norm $\\lVert \\mathbf{k} - \\mathbf{B}\\mathbf{n} \\rVert$.\n\n3. To test the robustness of your mapping, include an optional uniform fractional offset (or “shift”) $\\mathbf{s} \\in \\mathbb{R}^3$ such that the initial fractional coordinates used to form $\\mathbf{k}$ are $\\mathbf{f}_{m_1,m_2,m_3} + \\mathbf{s}$ before mapping. The mapping must bring points back into the FBZ.\n\n4. Verification criterion for the FBZ membership must use the WS definition: for a mapped $\\mathbf{k}$, verify that $\\lVert \\mathbf{k} \\rVert \\le \\lVert \\mathbf{k} - \\mathbf{B}\\mathbf{n} \\rVert$ for all nonzero integer vectors $\\mathbf{n}$ in a symmetric bounded neighborhood of the origin in $\\mathbb{Z}^3$. Use a bounded neighborhood that is sufficient to decide FBZ membership for the points generated by your test suite.\n\nUnits and output requirements:\n\n- All real-space lattice inputs $\\mathbf{A}$ are given in Angstroms. All reciprocal-space quantities (including norms of $\\mathbf{k}$) must be computed and reported in inverse Angstroms.\n\n- Angle units do not apply in this problem.\n\n- Your program must produce a single line of output containing, for each test case, a list with three values:\n    1. An integer equal to the number of points that are outside the FBZ before mapping,\n    2. An integer equal to the number of points that remain outside the FBZ after mapping (this should be $0$ if the mapping is correct),\n    3. A float equal to the maximum Euclidean norm $\\max \\lVert \\mathbf{k} \\rVert$ among the mapped points, in inverse Angstroms, rounded to six decimal places.\n  Aggregate the lists for all test cases into one top-level comma-separated list enclosed in square brackets (e.g., \"[[a,b,c],[d,e,f],...]\").\n\nTest suite:\n\nImplement the algorithm and run it on the following four cases. In each case, construct $\\mathbf{B} = 2\\pi \\left( \\mathbf{A}^{-1} \\right)^{\\top}$ and generate the $N_1 \\times N_2 \\times N_3$ grid, apply the shift $\\mathbf{s}$, map to the FBZ, and report the three requested values.\n\n- Case 1 (happy path, orthogonal lattice):\n  $\\mathbf{A} = \\begin{bmatrix} 1.0 & 0.0 & 0.0 \\\\ 0.0 & 1.0 & 0.0 \\\\ 0.0 & 0.0 & 1.0 \\end{bmatrix}$ Angstroms, $(N_1,N_2,N_3) = (2,2,2)$, $\\mathbf{s} = \\begin{bmatrix} 0.0 \\\\ 0.0 \\\\ 0.0 \\end{bmatrix}$.\n\n- Case 2 (orthorhombic lattice with significant shift):\n  $\\mathbf{A} = \\begin{bmatrix} 3.0 & 0.0 & 0.0 \\\\ 0.0 & 2.0 & 0.0 \\\\ 0.0 & 0.0 & 1.0 \\end{bmatrix}$ Angstroms, $(N_1,N_2,N_3) = (3,3,3)$, $\\mathbf{s} = \\begin{bmatrix} 0.6 \\\\ 0.2 \\\\ -0.4 \\end{bmatrix}$.\n\n- Case 3 (skewed lattice):\n  $\\mathbf{A} = \\begin{bmatrix} 2.0 & 0.1 & 0.0 \\\\ 0.0 & 2.2 & 0.3 \\\\ 0.0 & 0.0 & 1.8 \\end{bmatrix}$ Angstroms, $(N_1,N_2,N_3) = (4,2,3)$, $\\mathbf{s} = \\begin{bmatrix} 0.3 \\\\ 0.3 \\\\ 0.3 \\end{bmatrix}$.\n\n- Case 4 (hexagonal-like lattice with large shift and minimal grid):\n  $\\mathbf{A} = \\begin{bmatrix} 1.0 & 0.5 & 0.0 \\\\ 0.0 & 0.866 & 0.0 \\\\ 0.0 & 0.0 & 2.5 \\end{bmatrix}$ Angstroms, $(N_1,N_2,N_3) = (1,1,1)$, $\\mathbf{s} = \\begin{bmatrix} 1.2 \\\\ -1.2 \\\\ 0.8 \\end{bmatrix}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes its own three-element list as described above.", "solution": "The problem requires the derivation and implementation of an algorithm to generate a uniform grid of sampling points in reciprocal space, known as a Monkhorst-Pack grid, and to map these points into the First Brillouin Zone (FBZ).\n\n### 1. Reciprocal Lattice and Coordinate Systems\n\nThe crystal structure is defined by a set of real-space primitive lattice vectors, given as the columns of a matrix $\\mathbf{A}$. The corresponding reciprocal lattice primitive vectors, which form the basis for reciprocal space, are the columns of the matrix $\\mathbf{B}$ defined as:\n$$\n\\mathbf{B} = 2\\pi (\\mathbf{A}^{-1})^\\top\n$$\nAny point $\\mathbf{k}$ in reciprocal space can be expressed in Cartesian coordinates (units of $\\AA^{-1}$) or in fractional coordinates $\\mathbf{f}$ with respect to the basis $\\mathbf{B}$:\n$$\n\\mathbf{k} = \\mathbf{Bf} = f_1 \\mathbf{b}_1 + f_2 \\mathbf{b}_2 + f_3 \\mathbf{b}_3\n$$\nA reciprocal lattice vector $\\mathbf{G}$ corresponds to a point where the fractional coordinates are integers, i.e., $\\mathbf{G} = \\mathbf{B}\\mathbf{n}$ for some integer vector $\\mathbf{n} \\in \\mathbb{Z}^3$.\n\n### 2. Monkhorst-Pack Grid Generation\n\nThe goal is to create a uniform grid of $N_1 \\times N_2 \\times N_3$ points in reciprocal space, centered at the origin ($\\Gamma$ point). This is achieved by generating a uniform grid in the space of fractional coordinates. To ensure the grid is symmetric with respect to the origin, the fractional coordinates $f_i$ along each direction $i$ are chosen as:\n$$\nf_i = \\frac{m_i - \\frac{N_i+1}{2}}{N_i} \\quad \\text{for } m_i = 1, 2, \\dots, N_i\n$$\nFor an odd $N_i$, this series includes $0$, and for an even $N_i$, it is symmetric around $0$. For example, for $N_i=3$, the fractional coordinates are $\\{-\\frac{1}{3}, 0, \\frac{1}{3}\\}$, and for $N_i=4$, they are $\\{-\\frac{3}{8}, -\\frac{1}{8}, \\frac{1}{8}, \\frac{3}{8}\\}$. All generated coordinates lie in the interval $(-0.5, 0.5)$.\n\nThe problem specifies an additional uniform shift $\\mathbf{s}$ to be applied to the grid. The final set of unmapped fractional coordinates $\\mathbf{f'}$ is therefore:\n$$\n\\mathbf{f'}_{m_1,m_2,m_3} = \\mathbf{f}_{m_1,m_2,m_3} + \\mathbf{s}\n$$\nThe initial set of k-points is then given by $\\mathbf{k}_{init} = \\mathbf{Bf'}$. These points are not guaranteed to lie within the First Brillouin Zone.\n\n### 3. Mapping to the First Brillouin Zone\n\nThe First Brillouin Zone (FBZ) is the Wigner-Seitz cell of the reciprocal lattice centered at the origin. It is defined as the set of all points $\\mathbf{k}$ that are closer to the origin ($\\mathbf{G} = \\mathbf{0}$) than to any other reciprocal lattice point $\\mathbf{G} = \\mathbf{B}\\mathbf{n}$ ($\\mathbf{n} \\neq \\mathbf{0}$):\n$$\n\\text{FBZ} = \\{ \\mathbf{k} \\in \\mathbb{R}^3 \\mid \\lVert \\mathbf{k} \\rVert \\le \\lVert \\mathbf{k} - \\mathbf{B}\\mathbf{n} \\rVert \\quad \\forall \\mathbf{n} \\in \\mathbb{Z}^3, \\mathbf{n} \\neq \\mathbf{0} \\}\n$$\nTo map an arbitrary point $\\mathbf{k}_{init}$ into the FBZ, we must subtract the specific reciprocal lattice vector $\\mathbf{G}^* = \\mathbf{B}\\mathbf{n}^*$ that is closest to $\\mathbf{k}_{init}$. The mapped point $\\mathbf{k}_{mapped} = \\mathbf{k}_{init} - \\mathbf{G}^*$ will then be closer to the origin than to any other reciprocal lattice point, fulfilling the definition of the FBZ.\n\nThis task is equivalent to solving the Closest Vector Problem (CVP) for each $\\mathbf{k}_{init}$: finding the integer vector $\\mathbf{n}^* \\in \\mathbb{Z}^3$ that minimizes the Euclidean distance $\\lVert \\mathbf{k}_{init} - \\mathbf{B}\\mathbf{n} \\rVert$.\n$$\n\\mathbf{n}^* = \\arg\\min_{\\mathbf{n} \\in \\mathbb{Z}^3} \\lVert \\mathbf{k}_{init} - \\mathbf{B}\\mathbf{n} \\rVert^2\n$$\nWhile CVP is NP-hard in general, for a low-dimensional space like $\\mathbb{R}^3$, we can solve it effectively using a search-based method. A robust strategy is to first find a good initial guess for $\\mathbf{n}$ and then search in its local vicinity.\nThe fractional coordinates of $\\mathbf{k}_{init}$ provide an excellent guess. We first compute $\\mathbf{f'} = \\mathbf{B}^{-1}\\mathbf{k}_{init}$, where $\\mathbf{B}^{-1} = \\frac{1}{2\\pi}\\mathbf{A}^\\top$. The closest integer vector in fractional space is simply $\\mathbf{n}_{guess} = \\text{round}(\\mathbf{f'})$. This corresponds to Babai's rounding algorithm for CVP.\n\nTo improve upon this, we perform a brute-force search for $\\mathbf{n}^*$ in a small integer box centered at $\\mathbf{n}_{guess}$. We search all candidate vectors $\\mathbf{n} = \\mathbf{n}_{guess} + \\Delta\\mathbf{n}$, where $\\Delta\\mathbf{n}$ is an integer vector with small components (e.g., $\\Delta n_i \\in \\{-1, 0, 1\\}$). This checks $3^3=27$ candidates for $\\mathbf{n}$ and guarantees finding the solution if it lies within this local neighborhood, which is a very safe assumption for typical physical systems.\n\nThe algorithm for mapping a point $\\mathbf{k}_{init}$ is:\n1.  Calculate the fractional coordinates $\\mathbf{f'} = \\mathbf{B}^{-1}\\mathbf{k}_{init}$.\n2.  Determine the initial guess integer vector $\\mathbf{n}_{guess} = \\text{round}(\\mathbf{f'})$.\n3.  Search through all integer vectors $\\mathbf{n}$ in a $3 \\times 3 \\times 3$ cube centered at $\\mathbf{n}_{guess}$. For each candidate $\\mathbf{n}$, compute the squared distance $d^2 = \\lVert \\mathbf{k}_{init} - \\mathbf{B}\\mathbf{n} \\rVert^2$.\n4.  Identify the vector $\\mathbf{n}^*$ that yields the minimum $d^2$.\n5.  The final mapped point is $\\mathbf{k}_{mapped} = \\mathbf{k}_{init} - \\mathbf{B}\\mathbf{n}^*$.\n\n### 4. Verification of FBZ Membership\n\nTo verify if a point $\\mathbf{k}$ is in the FBZ, we directly apply the definition. We must check if $\\lVert \\mathbf{k} \\rVert^2 \\le \\lVert \\mathbf{k} - \\mathbf{B}\\mathbf{n} \\rVert^2$ for all non-zero integer vectors $\\mathbf{n}$ in a sufficiently large neighborhood of the origin. For the test cases, a search box where $n_i \\in \\{-1, 0, 1\\}$ (26 non-zero vectors) is sufficient. A small numerical tolerance $\\epsilon$ is used to handle floating-point comparisons, i.e., we check if $\\lVert \\mathbf{k} \\rVert^2 > \\lVert \\mathbf{k} - \\mathbf{B}\\mathbf{n} \\rVert^2 + \\epsilon$ to declare a point outside the FBZ.\n\n### 5. Summary of the Procedure\nThe overall algorithm proceeds as follows for each test case:\n1.  Given $\\mathbf{A}$, compute $\\mathbf{B} = 2\\pi (\\mathbf{A}^{-1})^\\top$ and $\\mathbf{B}^{-1} = \\frac{1}{2\\pi} \\mathbf{A}^\\top$.\n2.  Generate the base Monkhorst-Pack grid of fractional coordinates $\\mathbf{f}$.\n3.  Apply the shift $\\mathbf{s}$ to get the initial coordinates $\\mathbf{f'} = \\mathbf{f} + \\mathbf{s}$.\n4.  For each $\\mathbf{f'}$, compute the initial k-point $\\mathbf{k}_{init} = \\mathbf{Bf'}$.\n5.  Count the number of initial points outside the FBZ using the verification procedure.\n6.  Map each $\\mathbf{k}_{init}$ to its FBZ equivalent $\\mathbf{k}_{mapped}$ using the CVP-based search algorithm.\n7.  Count the number of mapped points that are still outside the FBZ (this should be zero).\n8.  Determine the maximum Euclidean norm among all $\\mathbf{k}_{mapped}$ points.\n9.  Report the three computed values.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements an algorithm for Monkhorst-Pack grid generation\n    and mapping to the First Brillouin Zone for a series of test cases.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"A\": np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]),\n            \"N\": (2, 2, 2),\n            \"s\": np.array([0.0, 0.0, 0.0])\n        },\n        {\n            \"A\": np.array([[3.0, 0.0, 0.0], [0.0, 2.0, 0.0], [0.0, 0.0, 1.0]]),\n            \"N\": (3, 3, 3),\n            \"s\": np.array([0.6, 0.2, -0.4])\n        },\n        {\n            \"A\": np.array([[2.0, 0.1, 0.0], [0.0, 2.2, 0.3], [0.0, 0.0, 1.8]]),\n            \"N\": (4, 2, 3),\n            \"s\": np.array([0.3, 0.3, 0.3])\n        },\n        {\n            \"A\": np.array([[1.0, 0.5, 0.0], [0.0, 0.866, 0.0], [0.0, 0.0, 2.5]]),\n            \"N\": (1, 1, 1),\n            \"s\": np.array([1.2, -1.2, 0.8])\n        }\n    ]\n\n    results = []\n    \n    # Define the search box for integer vectors n for FBZ verification.\n    # A 3x3x3 cube around the origin is sufficient for these test cases.\n    verify_n_coords = [-1, 0, 1]\n    verify_n_vectors = []\n    for i in verify_n_coords:\n        for j in verify_n_coords:\n            for k in verify_n_coords:\n                if i == 0 and j == 0 and k == 0:\n                    continue\n                verify_n_vectors.append(np.array([i, j, k]))\n\n    def is_in_fbz(k_vec, B_mat, n_vectors, tol=1e-12):\n        \"\"\"\n        Verifies if a k-point is inside the First Brillouin Zone.\n        A point k is in the FBZ if ||k|| <= ||k - G|| for all G = B@n.\n        \"\"\"\n        k_norm_sq = np.dot(k_vec, k_vec)\n        for n in n_vectors:\n            G = B_mat @ n\n            k_shifted_norm_sq = np.dot(k_vec - G, k_vec - G)\n            if k_norm_sq > k_shifted_norm_sq + tol:\n                return False\n        return True\n\n    def map_to_fbz(k_vec, B_mat, B_inv_mat):\n        \"\"\"\n        Maps a k-point into the First Brillouin Zone by solving the\n        Closest Vector Problem over a local search grid.\n        \"\"\"\n        # Get fractional coordinates to find a good guess for integer vector n\n        f_prime = B_inv_mat @ k_vec\n        n_guess = np.round(f_prime)\n        \n        min_dist_sq = np.inf\n        best_n = np.zeros(3)\n\n        # Search in a 3x3x3 cube around the initial guess n_guess\n        for i in range(-1, 2):\n            for j in range(-1, 2):\n                for l in range(-1, 2):\n                    n_cand = n_guess + np.array([i, j, l])\n                    G_cand = B_mat @ n_cand\n                    dist_sq = np.dot(k_vec-G_cand, k_vec-G_cand)\n                    if dist_sq < min_dist_sq:\n                        min_dist_sq = dist_sq\n                        best_n = n_cand\n        \n        G_final = B_mat @ best_n\n        return k_vec - G_final\n\n    for case in test_cases:\n        A = case[\"A\"]\n        N = case[\"N\"]\n        s = case[\"s\"]\n        \n        B = 2 * np.pi * np.linalg.inv(A).T\n        B_inv = (1 / (2 * np.pi)) * A.T\n\n        # Generate Monkhorst-Pack grid points\n        N1, N2, N3 = N\n        m1_vals = np.arange(1, N1 + 1)\n        m2_vals = np.arange(1, N2 + 1)\n        m3_vals = np.arange(1, N3 + 1)\n\n        f1 = (m1_vals - (N1 + 1) / 2) / N1\n        f2 = (m2_vals - (N2 + 1) / 2) / N2\n        f3 = (m3_vals - (N3 + 1) / 2) / N3\n        \n        initial_k_points = []\n        for i in range(N1):\n            for j in range(N2):\n                for k in range(N3):\n                    f = np.array([f1[i], f2[j], f3[k]])\n                    f_shifted = f + s\n                    k_point = B @ f_shifted\n                    initial_k_points.append(k_point)\n\n        outside_before = 0\n        outside_after = 0\n        max_norm_after = 0.0\n\n        for k_init in initial_k_points:\n            if not is_in_fbz(k_init, B, verify_n_vectors):\n                outside_before += 1\n            \n            k_mapped = map_to_fbz(k_init, B, B_inv)\n            \n            if not is_in_fbz(k_mapped, B, verify_n_vectors):\n                outside_after += 1\n            \n            norm_val = np.linalg.norm(k_mapped)\n            if norm_val > max_norm_after:\n                max_norm_after = norm_val\n\n        results.append([outside_before, outside_after, round(max_norm_after, 6)])\n\n    # Format the final output string\n    output_str = \"[\" + \",\".join(map(str, results)) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "3467044"}, {"introduction": "After generating a full mesh of $k$-points, the next step toward practical, large-scale simulations is to drastically reduce the computational workload by exploiting crystal symmetry. This practice [@problem_id:3467067] challenges you to implement the logic for reducing a full Monkhorst-Pack grid to its minimal, symmetry-inequivalent subset—the irreducible Brillouin zone (IBZ). By constructing the symmetry orbits and calculating the corresponding weights, you will master a technique that is essential for efficient and scalable materials simulations.", "problem": "You are given a periodic reciprocal lattice with primitive reciprocal vectors that define fractional coordinates in reciprocal space. A fractional coordinate $\\mathbf{k}$ represents a wave vector modulo addition of integer-valued reciprocal lattice vectors, which implies the equivalence relation $\\mathbf{k} \\sim \\mathbf{k} + \\mathbf{G}$ for any integer vector $\\mathbf{G} \\in \\mathbb{Z}^3$. Consider a set of point operations $\\{ \\mathbf{R} \\}$ acting on fractional coordinates by $\\mathbf{k} \\mapsto \\mathbf{R}\\mathbf{k}$. Assume each $\\mathbf{R}$ is an integer-valued $3 \\times 3$ matrix with determinant $\\det(\\mathbf{R}) = \\pm 1$ such that the action preserves the reciprocal lattice, and that the set $\\{ \\mathbf{R} \\}$ is closed under composition and contains the identity operation. These operations represent the point part of a space group; their action on fractional coordinates is considered modulo reciprocal lattice translations, i.e., after applying $\\mathbf{R}$ one reduces the resulting $\\mathbf{k}'$ back to a canonical cell via $\\mathbf{k}' \\mapsto \\mathbf{k}' + \\mathbf{G}$ for some integer $\\mathbf{G}$ to bring it into a chosen representative region, for example the canonical hypercube $[-\\tfrac{1}{2}, \\tfrac{1}{2})^3$.\n\nYour task is to design and implement a procedure that, given:\n- a uniform Monkhorst–Pack (MP) sampling grid specified by integers $\\mathbf{N} = (N_1, N_2, N_3)$,\n- a closed set of point operations $\\{ \\mathbf{R} \\}$ in fractional reciprocal coordinates,\n\nconstructs the irreducible set of sampling points (the irreducible Brillouin zone (IBZ) with respect to $\\{ \\mathbf{R} \\}$) and computes weights $w_\\alpha$ for each irreducible representative $\\mathbf{k}_\\alpha$ such that every symmetry-equivalence class contributes proportionally to the total number of grid points.\n\nBegin from fundamental definitions and well-tested facts:\n- The Brillouin zone integral over a function $f(\\mathbf{k})$ that is invariant under all point operations, i.e., $f(\\mathbf{R}\\mathbf{k}) = f(\\mathbf{k})$ for all $\\mathbf{R} \\in \\{ \\mathbf{R} \\}$, can be approximated by a uniform sum over a discrete grid. Reducing to symmetry-inequivalent points is valid when counting multiplicities correctly.\n- An equivalence class (orbit) of a point $\\mathbf{k}$ under the action of $\\{ \\mathbf{R} \\}$ is the set $\\mathcal{O}(\\mathbf{k}) = \\left\\{ \\mathrm{wrap}\\!\\left(\\mathbf{R}\\mathbf{k}\\right) \\mid \\mathbf{R} \\in \\{ \\mathbf{R} \\} \\right\\}$, where $\\mathrm{wrap}(\\cdot)$ maps a fractional coordinate back into a canonical cell by adding an appropriate integer vector. Distinct points of the grid that lie in the same orbit are symmetry-equivalent.\n\nRequirements for your program:\n- Generate a Monkhorst–Pack grid that is symmetric about the origin and uniformly samples each reciprocal direction with $N_i$ points. The construction must honor periodicity, i.e., points differing by integer vectors are identified modulo the reciprocal lattice. Do not assume any particular centering beyond the requirement of origin symmetry and uniform spacing that is standard for Monkhorst–Pack grids.\n- Partition the entire grid into disjoint symmetry orbits under the given $\\{ \\mathbf{R} \\}$. For each orbit $\\alpha$, select a canonical representative $\\mathbf{k}_\\alpha$ (for example, the lexicographically minimal fractional coordinate in $[-\\tfrac{1}{2}, \\tfrac{1}{2})^3$) and assign a weight $w_\\alpha = \\dfrac{|\\mathcal{O}(\\mathbf{k}_\\alpha)|}{N_1 N_2 N_3}$, where $|\\cdot|$ denotes the size of the orbit. This choice ensures that the total weight sums to $1$, i.e., $\\sum_\\alpha w_\\alpha = 1$.\n- Use a numerically robust wrapping to $[-\\tfrac{1}{2}, \\tfrac{1}{2})^3$ and a tolerance to recognize grid points mapped by symmetry operations.\n\nYour program must implement the above and produce, for each test case, the following tuple of results:\n- The integer number of irreducible points $M$.\n- The float sum of all weights $S$.\n- The float minimum weight among all irreducible points $\\min w_\\alpha$.\n- The float maximum weight among all irreducible points $\\max w_\\alpha$.\n- A boolean $b$ indicating whether $|S - 1|$ is less than a small tolerance (e.g., $10^{-12}$).\n\nTest suite:\n- Case A (general \"happy path\"): $\\mathbf{N} = (N_1, N_2, N_3) = (4, 4, 4)$ with point operations given by the cyclic fourfold rotations around the $z$-axis,\n  $$\\mathbf{R}_0 = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix},\\quad\n    \\mathbf{R}_{90} = \\begin{pmatrix} 0 & -1 & 0 \\\\ 1 & 0 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix},\\quad\n    \\mathbf{R}_{180} = \\begin{pmatrix} -1 & 0 & 0 \\\\ 0 & -1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix},\\quad\n    \\mathbf{R}_{270} = \\begin{pmatrix} 0 & 1 & 0 \\\\ -1 & 0 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}.$$\n- Case B (boundary condition with no symmetry reduction): $\\mathbf{N} = (N_1, N_2, N_3) = (3, 3, 3)$ with only the identity operation,\n  $$\\mathbf{R}_0 = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}.$$\n- Case C (edge case with inversion pairing): $\\mathbf{N} = (N_1, N_2, N_3) = (2, 2, 2)$ with inversion symmetry,\n  $$\\mathbf{R}_0 = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix},\\quad\n    \\mathbf{R}_{\\mathrm{inv}} = \\begin{pmatrix} -1 & 0 & 0 \\\\ 0 & -1 & 0 \\\\ 0 & 0 & -1 \\end{pmatrix}.$$\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a list formatted as $[M,S,\\min w_\\alpha,\\max w_\\alpha,b]$. Thus the overall output must look like\n  $$\\big[ [M_A,S_A,\\min w_A,\\max w_A,b_A], [M_B,S_B,\\min w_B,\\max w_B,b_B], [M_C,S_C,\\min w_C,\\max w_C,b_C] \\big],$$\nwith all numbers printed as plain decimals and booleans as plain logical values. No physical units or angle units are involved in this problem; all quantities are dimensionless real numbers or integers.", "solution": "The problem posed is to develop a procedure for reducing a uniform Monkhorst-Pack (MP) k-point sampling grid of the Brillouin zone to its irreducible set, given a group of point symmetry operations. We must also calculate the corresponding weights for each irreducible k-point. This task is a cornerstone of modern electronic structure calculations, as it dramatically reduces computational cost by exploiting crystal symmetry. The problem is well-posed, scientifically sound, and provides sufficient information for a unique, algorithmic solution.\n\nWe begin by establishing the fundamental definitions and principles.\n\nA point $\\mathbf{k}$ in the reciprocal space is represented by fractional coordinates with respect to the primitive reciprocal lattice vectors. Periodicity implies that any two points $\\mathbf{k}$ and $\\mathbf{k}'$ are considered equivalent if they differ by an integer vector $\\mathbf{G} \\in \\mathbb{Z}^3$, i.e., $\\mathbf{k}' = \\mathbf{k} + \\mathbf{G}$. To work with a unique representation, we map all k-points into a canonical primitive cell, chosen here as the hypercube $[-\\tfrac{1}{2}, \\tfrac{1}{2})^3$. This mapping, denoted $\\mathrm{wrap}(\\mathbf{k})$, is achieved by the operation $\\mathbf{k} \\mapsto \\mathbf{k} - \\lfloor \\mathbf{k} + \\tfrac{1}{2} \\rfloor$, where the operations are performed component-wise.\n\nThe Monkhorst-Pack (MP) grid is a uniform sampling of the reciprocal space. For a grid specified by integers $\\mathbf{N} = (N_1, N_2, N_3)$, a total of $N_{tot} = N_1 N_2 N_3$ points are generated. To ensure the grid is symmetric with respect to the origin (the $\\Gamma$-point), we construct the grid points $\\mathbf{k}=(k_1, k_2, k_3)$ where each component $k_j$ is given by:\n$$k_j = \\frac{2i_j - N_j - 1}{2N_j} \\quad \\text{for } i_j = 1, 2, \\dots, N_j$$\nThis construction generates a set of k-points that is invariant under the inversion operation $\\mathbf{k} \\mapsto -\\mathbf{k}$ (modulo reciprocal lattice vectors).\n\nThe point group of the crystal is given by a set of symmetry operations $\\{ \\mathbf{R} \\}$, which are $3 \\times 3$ integer matrices with determinant $\\det(\\mathbf{R}) = \\pm 1$. The action of an operation $\\mathbf{R}$ on a k-point $\\mathbf{k}$ is a linear transformation $\\mathbf{k}' = \\mathbf{R}\\mathbf{k}$, followed by wrapping the result back into the canonical cell.\n\nTwo k-points $\\mathbf{k}_a$ and $\\mathbf{k}_b$ are symmetry-equivalent if there exists an operation $\\mathbf{R} \\in \\{ \\mathbf{R} \\}$ such that $\\mathrm{wrap}(\\mathbf{R}\\mathbf{k}_a) = \\mathbf{k}_b$. The set of all points equivalent to a given point $\\mathbf{k}$ forms its orbit, $\\mathcal{O}(\\mathbf{k}) = \\{ \\mathrm{wrap}(\\mathbf{R}\\mathbf{k}) \\mid \\mathbf{R} \\in \\{ \\mathbf{R} \\} \\}$. The fundamental property of these orbits is that they partition the full k-point grid into disjoint sets.\n\nThe goal is to find one representative k-point for each orbit. This set of representatives constitutes the irreducible Brillouin zone (IBZ) k-points for the given grid and symmetry. The choice of representative must be canonical to ensure uniqueness. A standard choice is the lexicographically smallest k-point within each orbit.\n\nThe weight $w_\\alpha$ of an irreducible k-point $\\mathbf{k}_\\alpha$ is defined as the ratio of the size of its orbit $|\\mathcal{O}(\\mathbf{k}_\\alpha)|$ to the total number of k-points in the full grid $N_{tot}$:\n$$w_\\alpha = \\frac{|\\mathcal{O}(\\mathbf{k}_\\alpha)|}{N_1 N_2 N_3}$$\nBy construction, the sum of the sizes of all disjoint orbits equals the total number of grid points, $\\sum_\\alpha |\\mathcal{O}(\\mathbf{k}_\\alpha)| = N_{tot}$. Consequently, the sum of all weights must be equal to $1$:\n$$\\sum_\\alpha w_\\alpha = \\sum_\\alpha \\frac{|\\mathcal{O}(\\mathbf{k}_\\alpha)|}{N_{tot}} = \\frac{1}{N_{tot}} \\sum_\\alpha |\\mathcal{O}(\\mathbf{k}_\\alpha)| = \\frac{N_{tot}}{N_{tot}} = 1$$\n\nThe algorithm to implement this procedure is as follows:\n1.  **Grid Generation**: Given $\\mathbf{N}=(N_1, N_2, N_3)$, generate the full grid of $N_{tot}$ k-points using the origin-symmetric construction described above.\n2.  **Partitioning**: Iterate through each k-point $\\mathbf{k}_i$ in the full grid. To avoid redundant computations, maintain a set of `visited_points`.\n    a. If $\\mathbf{k}_i$ is already in `visited_points`, skip it as it belongs to an orbit that has already been processed.\n    b. If $\\mathbf{k}_i$ has not been visited, it is the first member of a new orbit to be discovered.\n3.  **Orbit Construction**: For the new point $\\mathbf{k}_i$, compute its full orbit by applying every symmetry operation $\\mathbf{R} \\in \\{ \\mathbf{R} \\}$:\n    a. Calculate $\\mathbf{k}' = \\mathrm{wrap}(\\mathbf{R}\\mathbf{k}_i)$.\n    b. Add the resulting unique points $\\mathbf{k}'$ to a temporary set representing the current orbit. Numerical tolerance is critical here; floating-point k-vectors are considered identical if their component-wise difference is smaller than a threshold, e.g., $10^{-8}$. Hashing rounded coordinate tuples is an effective technique for managing uniqueness.\n4.  **Irreducible Point and Weight**:\n    a. The size of the orbit, $|\\mathcal{O}(\\mathbf{k}_i)|$, is the number of unique points found in the previous step.\n    b. The weight is calculated as $w_i = |\\mathcal{O}(\\mathbf{k}_i)| / N_{tot}$.\n    c. The canonical representative for this orbit is selected as the lexicographically smallest vector among all points in the orbit.\n    d. Store the canonical representative and its weight.\n5.  **Update Visited set**: Add all points from the newly computed orbit to the `visited_points` set.\n6.  **Repeat**: Continue this process until all points in the full grid have been visited.\n7.  **Final Results**: Once the iteration is complete, the list of canonical representatives is the irreducible set of k-points. From the list of weights, calculate the total number of irreducible points $M$, the sum of weights $S$, the minimum weight $\\min w_\\alpha$, and the maximum weight $\\max w_\\alpha$. Verify that $|S - 1|$ is below a numerical tolerance.\n\nThis algorithm systematically partitions the full grid and correctly identifies the irreducible set and their weights, adhering to the principles of group theory as applied to crystal lattices.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n\n    def wrap_to_canonical_cell(k_vector):\n        \"\"\"\n        Wraps a fractional coordinate vector into the canonical cell [-0.5, 0.5).\n        This is equivalent to k -> k - floor(k + 0.5).\n        \"\"\"\n        return k_vector - np.floor(k_vector + 0.5)\n\n    def get_k_point_hash(k_vector, precision=8):\n        \"\"\"\n        Creates a hashable representation of a k-vector by rounding to a\n        fixed precision to handle floating point inaccuracies.\n        \"\"\"\n        return tuple(np.round(k_vector, precision))\n\n    def generate_mp_grid(n_dims):\n        \"\"\"\n        Generates a Gamma-centered (origin-symmetric) Monkhorst-Pack grid.\n        Args:\n            n_dims (tuple): A tuple (N1, N2, N3) of grid dimensions.\n        Returns:\n            np.ndarray: A (N1*N2*N3, 3) array of k-point coordinates.\n        \"\"\"\n        k_coords = []\n        for n in n_dims:\n            # Formula for Gamma-centered grid: (2*i - N - 1) / (2*N) for i=1..N\n            k_coords.append((2 * np.arange(1, n + 1) - n - 1) / (2 * n))\n        \n        # Use meshgrid with 'ij' indexing to get Cartesian product in a standard order\n        kx, ky, kz = np.meshgrid(k_coords[0], k_coords[1], k_coords[2], indexing='ij')\n        \n        # Stack and reshape to get a list of (kx, ky, kz) vectors\n        grid = np.stack([kx, ky, kz], axis=-1).reshape(-1, 3)\n        return grid\n\n    def compute_ibz(n_dims, r_ops, tol=1e-12, hash_precision=8):\n        \"\"\"\n        Computes the irreducible Brillouin zone (IBZ) for a given MP grid\n        and a set of point group symmetry operations.\n\n        Args:\n            n_dims (tuple): Grid dimensions (N1, N2, N3).\n            r_ops (list): List of 3x3 numpy arrays for symmetry operations.\n            tol (float): Tolerance for checking if the sum of weights is 1.\n            hash_precision (int): Decimal precision for hashing k-points.\n\n        Returns:\n            tuple: (M, S, min_w, max_w, b) where\n                M: Number of irreducible points.\n                S: Sum of weights.\n                min_w: Minimum weight.\n                max_w: Maximum weight.\n                b: Boolean, True if |S-1| < tol.\n        \"\"\"\n        n_total = np.prod(n_dims)\n        full_grid = generate_mp_grid(n_dims)\n        \n        visited_k_hashes = set()\n        ir_k_points = []\n        ir_weights = []\n        \n        for k_point in full_grid:\n            # Check if point has been visited (is part of a previously found orbit)\n            # We must wrap the point first to get its canonical representation\n            # before checking the visited set.\n            canonical_k_point = wrap_to_canonical_cell(k_point)\n            k_hash = get_k_point_hash(canonical_k_point, hash_precision)\n\n            if k_hash in visited_k_hashes:\n                continue\n            \n            # If not visited, this k-point starts a new orbit.\n            # Generate the orbit by applying all symmetry operations.\n            orbit_hashes = set()\n            for r_mat in r_ops:\n                k_rotated = r_mat @ k_point\n                k_wrapped = wrap_to_canonical_cell(k_rotated)\n                orbit_hashes.add(get_k_point_hash(k_wrapped, hash_precision))\n            \n            # Calculate orbit properties\n            orbit_size = len(orbit_hashes)\n            weight = orbit_size / n_total\n            \n            # Determine canonical representative (lexicographically smallest)\n            canonical_rep_tuple = min(orbit_hashes)\n            \n            ir_k_points.append(np.array(canonical_rep_tuple))\n            ir_weights.append(weight)\n            \n            # Mark all points in the newly found orbit as visited\n            visited_k_hashes.update(orbit_hashes)\n            \n        m = len(ir_k_points)\n        s = np.sum(ir_weights)\n        min_w = np.min(ir_weights) if ir_weights else 0.0\n        max_w = np.max(ir_weights) if ir_weights else 0.0\n        b = np.abs(s - 1.0) < tol\n        \n        return m, s, min_w, max_w, b\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": (4, 4, 4),\n            \"R\": [\n                np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]),\n                np.array([[0, -1, 0], [1, 0, 0], [0, 0, 1]]),\n                np.array([[-1, 0, 0], [0, -1, 0], [0, 0, 1]]),\n                np.array([[0, 1, 0], [-1, 0, 0], [0, 0, 1]]),\n            ]\n        },\n        {\n            \"N\": (3, 3, 3),\n            \"R\": [\n                np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]),\n            ]\n        },\n        {\n            \"N\": (2, 2, 2),\n            \"R\": [\n                np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]),\n                np.array([[-1, 0, 0], [0, -1, 0], [0, 0, -1]]),\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        m, s, min_w, max_w, b_val = compute_ibz(case[\"N\"], case[\"R\"])\n        results.append(f\"[{m},{s},{min_w},{max_w},{str(b_val).lower()}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3467067"}, {"introduction": "The final critical question in setting up a Brillouin zone integration is: how dense must the $k$-point grid be to achieve the desired accuracy? This hands-on practice [@problem_id:3467022] moves beyond simple convergence tests by having you implement a robust numerical technique for a posteriori error estimation. By using results from two different grids to perform a Richardson extrapolation, you will learn how to systematically improve the accuracy of your results and gain confidence in their convergence.", "problem": "You are to implement a complete, runnable program that generates Monkhorst–Pack grids and uses them to construct a posteriori error estimates and Richardson extrapolation for Brillouin zone integrals of synthetic energy and force densities. The context is the numerical integration over the Brillouin zone in computational materials science. All angles are to be treated in radians, and all reported quantities are dimensionless.\n\nThe starting point is the following set of fundamental definitions.\n\n- The Brillouin zone is taken to be the parallelepiped spanned by the reciprocal lattice vectors $\\mathbf{b}_1$, $\\mathbf{b}_2$, and $\\mathbf{b}_3$. For a simple cubic lattice with lattice parameter normalized to unity, assume $\\mathbf{b}_1 = 2\\pi \\,\\hat{\\mathbf{e}}_x$, $\\mathbf{b}_2 = 2\\pi \\,\\hat{\\mathbf{e}}_y$, and $\\mathbf{b}_3 = 2\\pi \\,\\hat{\\mathbf{e}}_z$, so that the Brillouin zone is the cube $[-\\pi,\\pi]^3$ in Cartesian components. The Brillouin zone volume is $V_{\\mathrm{BZ}} = (2\\pi)^3$.\n\n- A Monkhorst–Pack (MP) grid is defined by three positive integers $(N_1,N_2,N_3)$ and a shift vector $\\mathbf{s} = (s_1,s_2,s_3)$ with each $s_i \\in [0,1)$. In reduced coordinates, the sampling points are\n$$\nt_i(n_i) = \\frac{n_i + s_i}{N_i}, \\quad n_i \\in \\{0,1,\\dots,N_i-1\\}, \\quad i\\in\\{1,2,3\\}.\n$$\nMapping to Cartesian reciprocal space is performed by\n$$\n\\mathbf{k}(\\mathbf{n}) = \\sum_{i=1}^3 \\left( t_i(n_i) - \\frac{1}{2} \\right) \\mathbf{b}_i,\n$$\nso that $\\mathbf{k}(\\mathbf{n}) \\in [-\\pi,\\pi]^3$ for all $\\mathbf{n}=(n_1,n_2,n_3)$.\n\n- The Brillouin zone average of a scalar integrand $f(\\mathbf{k})$ is\n$$\n\\bar{f} = \\frac{1}{V_{\\mathrm{BZ}}} \\int_{\\mathrm{BZ}} f(\\mathbf{k}) \\, d^3 k.\n$$\nA uniform MP grid quadrature approximates $\\bar{f}$ by the simple average of $f$ over the grid points, because all MP grid weights are equal. For a vector-valued integrand $\\mathbf{g}(\\mathbf{k})$, the average is applied component-wise.\n\nYou will use the following synthetic, physically plausible integrands which model a metallic Fermi surface:\n\n- The total energy density is the indicator of a Fermi sphere of radius $k_F$,\n$$\ne(\\mathbf{k}) = \\mathbf{1}_{\\{\\|\\mathbf{k}\\|\\le k_F\\}},\n$$\nso that its exact Brillouin zone average is\n$$\n\\bar{E}_{\\mathrm{exact}} = \\frac{1}{V_{\\mathrm{BZ}}} \\int_{\\mathrm{BZ}} \\mathbf{1}_{\\{\\|\\mathbf{k}\\|\\le k_F\\}} \\, d^3k = \\frac{\\frac{4}{3}\\pi k_F^3}{(2\\pi)^3} = \\frac{k_F^3}{6\\pi^2}.\n$$\n\n- The force density is a vector field proportional to $\\mathbf{k}$ inside the same Fermi sphere,\n$$\n\\mathbf{f}(\\mathbf{k}) = \\mathbf{k} \\, \\mathbf{1}_{\\{\\|\\mathbf{k}\\|\\le k_F\\}},\n$$\nwhose exact Brillouin zone average is the zero vector,\n$$\n\\bar{\\mathbf{F}}_{\\mathrm{exact}} = \\frac{1}{V_{\\mathrm{BZ}}} \\int_{\\mathrm{BZ}} \\mathbf{k}\\, \\mathbf{1}_{\\{\\|\\mathbf{k}\\|\\le k_F\\}} \\, d^3k = \\mathbf{0},\n$$\nby symmetry.\n\nOn a grid $(N,N,N)$ with shift $\\mathbf{s}^{(N)}$, define the discrete averages\n$$\nE^{(N)} = \\frac{1}{N^3} \\sum_{\\mathbf{n}} e\\!\\left(\\mathbf{k}(\\mathbf{n})\\right), \\quad \\mathbf{F}^{(N)} = \\frac{1}{N^3} \\sum_{\\mathbf{n}} \\mathbf{f}\\!\\left(\\mathbf{k}(\\mathbf{n})\\right),\n$$\nand similarly $E^{(N+1)}$ and $\\mathbf{F}^{(N+1)}$ on the $(N+1,N+1,N+1)$ grid with shift $\\mathbf{s}^{(N+1)}$. Because the indicator integrands are nonsmooth across the Fermi surface, a leading error model of the form\n$$\nE^{(N)} = \\bar{E}_{\\infty} + \\frac{C_E}{N} + \\mathcal{O}\\!\\left(\\frac{1}{N^2}\\right), \\quad \\mathbf{F}^{(N)} = \\bar{\\mathbf{F}}_{\\infty} + \\frac{\\mathbf{C}_F}{N} + \\mathcal{O}\\!\\left(\\frac{1}{N^2}\\right),\n$$\nis appropriate for sufficiently large $N$ when using uniform sampling. Under this model, Richardson extrapolation in $1/N$ can be used to eliminate the leading $\\mathcal{O}(1/N)$ error and approximate the infinite-resolution limits $\\bar{E}_{\\infty}$ and $\\bar{\\mathbf{F}}_{\\infty}$ from two consecutive grids. You must derive the extrapolation formulas from this asymptotic model, for both the scalar and vector cases, without using any pre-given shortcut formulas.\n\nConstruct a posteriori error estimates using the two complementary meshes $(N,N,N)$ with $\\mathbf{s}^{(N)}$ and $(N+1,N+1,N+1)$ with $\\mathbf{s}^{(N+1)}$, defined here to be distinct shifts. The estimator for the scalar energy should be a nonnegative scalar that depends only on the two computed discrete values, and the estimator for the forces should be a nonnegative scalar depending only on the two computed discrete vectors, for example their difference measured in a suitable norm. These estimators must not use any knowledge of the exact integrals.\n\nTasks to implement in your program:\n\n- Generate Monkhorst–Pack grids for given $(N_1,N_2,N_3)$ and shift $\\mathbf{s}$ as defined above.\n\n- For each test case, compute $E^{(N)}$, $E^{(N+1)}$, $\\mathbf{F}^{(N)}$, and $\\mathbf{F}^{(N+1)}$.\n\n- Derive and apply Richardson extrapolation in $1/N$ to obtain $E^{\\mathrm{R}}$ and $\\mathbf{F}^{\\mathrm{R}}$ from $E^{(N)}$, $E^{(N+1)}$ and $\\mathbf{F}^{(N)}$, $\\mathbf{F}^{(N+1)}$.\n\n- Construct a posteriori error estimators $\\eta_E$ and $\\eta_F$ using only the two complementary meshes.\n\n- For validation only, compute the true errors by comparing $E^{\\mathrm{R}}$ to $\\bar{E}_{\\mathrm{exact}}$ and $\\mathbf{F}^{\\mathrm{R}}$ to $\\bar{\\mathbf{F}}_{\\mathrm{exact}}$.\n\nTest suite to cover a typical case, a case with different shifts, and a small-grid edge case:\n\n- Case $1$: $N = 6$, $\\mathbf{s}^{(N)} = (0,0,0)$, $\\mathbf{s}^{(N+1)} = (0.5,0.5,0.5)$, $k_F = 1.2$.\n\n- Case $2$: $N = 3$, $\\mathbf{s}^{(N)} = (0.25,0.25,0.25)$, $\\mathbf{s}^{(N+1)} = (0.75,0.75,0.75)$, $k_F = 1.8$.\n\n- Case $3$: $N = 2$, $\\mathbf{s}^{(N)} = (0,0,0)$, $\\mathbf{s}^{(N+1)} = (0.5,0.5,0.5)$, $k_F = 0.3$.\n\nRequired final output format:\n\n- For each case, output a list of six floating-point numbers in the following order:\n    1. $E^{\\mathrm{R}}$.\n    2. $\\eta_E$.\n    3. $\\left| E^{\\mathrm{R}} - \\bar{E}_{\\mathrm{exact}} \\right|$.\n    4. $\\left\\| \\mathbf{F}^{\\mathrm{R}} \\right\\|_2$.\n    5. $\\eta_F$.\n    6. $\\left\\| \\mathbf{F}^{\\mathrm{R}} - \\bar{\\mathbf{F}}_{\\mathrm{exact}} \\right\\|_2$.\n\n- Aggregate the results for the three cases into a single line as one flat, comma-separated Python-style list, with no additional text, for example\n$$\n[\\text{case }1 \\text{ six numbers}, \\text{case }2 \\text{ six numbers}, \\text{case }3 \\text{ six numbers}].\n$$\n\nThe program must produce exactly one line in this format. All computations are to be done in radians, and all outputs are dimensionless real numbers rounded by standard floating-point representation. No external input or files are permitted; all data are contained in the program.", "solution": "The user-provided problem is a well-defined computational task in the field of computational materials science, specifically concerning the numerical integration of physical quantities over the first Brillouin zone. The problem is scientifically sound, mathematically consistent, and contains all necessary information to proceed with a solution.\n\nThe core of the problem involves the implementation of the Monkhorst-Pack (MP) method for Brillouin zone sampling, followed by an application of Richardson extrapolation to improve the accuracy of the computed integrals. We will first formalize the required derivations and then outline the computational procedure.\n\n### Monkhorst-Pack Grid Generation\n\nThe reciprocal lattice for the specified simple cubic cell is given by the vectors $\\mathbf{b}_1 = 2\\pi \\,\\hat{\\mathbf{e}}_x$, $\\mathbf{b}_2 = 2\\pi \\,\\hat{\\mathbf{e}}_y$, and $\\mathbf{b}_3 = 2\\pi \\,\\hat{\\mathbf{e}}_z$. The first Brillouin zone (BZ) corresponds to the Wigner-Seitz cell of the reciprocal lattice, which for this simple case is a cube defined by $\\mathbf{k} = (k_x, k_y, k_z)$ with $k_i \\in [-\\pi, \\pi]$. The volume of this BZ is $V_{\\mathrm{BZ}} = (2\\pi)^3$.\n\nA Monkhorst-Pack grid is defined by a set of positive integers $(N_1, N_2, N_3)$ and a shift vector $\\mathbf{s} = (s_1, s_2, s_3)$, where each component $s_i \\in [0, 1)$. The grid points, in reduced coordinates, are:\n$$\nt_i(n_i) = \\frac{n_i + s_i}{N_i}, \\quad \\text{for } n_i \\in \\{0, 1, \\dots, N_i-1\\}, \\quad i \\in \\{1, 2, 3\\}.\n$$\nThese reduced coordinates are mapped to Cartesian coordinates in reciprocal space using the provided formula:\n$$\n\\mathbf{k}(\\mathbf{n}) = \\sum_{i=1}^3 \\left( t_i(n_i) - \\frac{1}{2} \\right) \\mathbf{b}_i\n$$\nFor the specific $\\mathbf{b}_i$ vectors of the simple cubic lattice, the components of the $\\mathbf{k}$-points are:\n$$\nk_i(\\mathbf{n}) = k_i(n_i) = 2\\pi \\left( \\frac{n_i + s_i}{N_i} - \\frac{1}{2} \\right)\n$$\nThis formula generates a uniform grid of $N_1 \\times N_2 \\times N_3$ points that samples the Brillouin zone.\n\n### Numerical Quadrature of Brillouin Zone Integrals\n\nThe Brillouin zone average of a function $f(\\mathbf{k})$ is defined as:\n$$\n\\bar{f} = \\frac{1}{V_{\\mathrm{BZ}}} \\int_{\\mathrm{BZ}} f(\\mathbf{k}) \\, d^3 k\n$$\nThe Monkhorst-Pack scheme approximates this integral by a simple arithmetic mean of the function values evaluated at the grid points. For a uniform grid of size $N \\times N \\times N$, the discrete approximation $Q^{(N)}$ to an average $\\bar{q}$ is:\n$$\nQ^{(N)} = \\frac{1}{N^3} \\sum_{n_1=0}^{N-1} \\sum_{n_2=0}^{N-1} \\sum_{n_3=0}^{N-1} q(\\mathbf{k}(\\mathbf{n}))\n$$\nwhere $q$ can be the scalar energy density $e(\\mathbf{k})$ or the vector force density $\\mathbf{f}(\\mathbf{k})$. The problem specifies the following synthetic integrands:\n-   Energy density: $e(\\mathbf{k}) = \\mathbf{1}_{\\{\\|\\mathbf{k}\\|\\le k_F\\}}$, where $\\mathbf{1}$ is the indicator function. The exact average is $\\bar{E}_{\\mathrm{exact}} = k_F^3 / (6\\pi^2)$.\n-   Force density: $\\mathbf{f}(\\mathbf{k}) = \\mathbf{k} \\, \\mathbf{1}_{\\{\\|\\mathbf{k}\\| \\le k_F\\}}$. The exact average is $\\bar{\\mathbf{F}}_{\\mathrm{exact}} = \\mathbf{0}$ due to the odd symmetry of the integrand over a symmetric domain.\n\n### Derivation of Richardson Extrapolation\n\nThe problem states that for the non-smooth integrands used, the convergence of the discrete average $Q^{(N)}$ to the true value $\\bar{Q}_{\\infty}$ follows the asymptotic error model:\n$$\nQ^{(N)} = \\bar{Q}_{\\infty} + \\frac{C_Q}{N} + \\mathcal{O}\\left(\\frac{1}{N^2}\\right)\n$$\nwhere $C_Q$ is a constant. We can use two calculations on different grids to eliminate the leading-order error term $\\mathcal{O}(1/N)$. Let's consider grids of size $N$ and $N+1$. We have:\n$$\nE^{(N)} = \\bar{E}_{\\infty} + \\frac{C_E}{N} + \\mathcal{O}\\left(\\frac{1}{N^2}\\right)\n$$\n$$\nE^{(N+1)} = \\bar{E}_{\\infty} + \\frac{C_E}{N+1} + \\mathcal{O}\\left(\\frac{1}{(N+1)^2}\\right)\n$$\nNeglecting higher-order terms, we treat these as a system of two linear equations for the unknowns $\\bar{E}_{\\infty}$ and $C_E$:\n$$\nE^{(N)} \\approx \\bar{E}_{\\infty} + \\frac{C_E}{N} \\quad (1)\n$$\n$$\nE^{(N+1)} \\approx \\bar{E}_{\\infty} + \\frac{C_E}{N+1} \\quad (2)\n$$\nFrom (1), we express $C_E$ as $C_E \\approx N(E^{(N)} - \\bar{E}_{\\infty})$. Substituting this into (2) yields:\n$$\nE^{(N+1)} \\approx \\bar{E}_{\\infty} + \\frac{N(E^{(N)} - \\bar{E}_{\\infty})}{N+1}\n$$\nMultiplying by $(N+1)$ and rearranging to solve for $\\bar{E}_{\\infty}$:\n$$\n(N+1)E^{(N+1)} \\approx (N+1)\\bar{E}_{\\infty} + N(E^{(N)} - \\bar{E}_{\\infty})\n$$\n$$\n(N+1)E^{(N+1)} - NE^{(N)} \\approx (N+1)\\bar{E}_{\\infty} - N\\bar{E}_{\\infty} = \\bar{E}_{\\infty}\n$$\nThis gives the Richardson-extrapolated estimate $E^{\\mathrm{R}}$, which has an error of $\\mathcal{O}(1/N^2)$:\n$$\nE^{\\mathrm{R}} = (N+1)E^{(N+1)} - N E^{(N)}\n$$\nThe same derivation applies component-wise to the vector quantity $\\mathbf{F}^{(N)}$, leading to the analogous formula for the extrapolated force vector $\\mathbf{F}^{\\mathrm{R}}$:\n$$\n\\mathbf{F}^{\\mathrm{R}} = (N+1)\\mathbf{F}^{(N+1)} - N \\mathbf{F}^{(N)}\n$$\n\n### A Posteriori Error Estimation\n\nAn a posteriori error estimator gauges the numerical error using only the computed results, without knowledge of the exact solution. A simple yet effective choice is the magnitude of the difference between the results from the two grids.\nFor the scalar energy, we define the estimator $\\eta_E$ as:\n$$\n\\eta_E = |E^{(N+1)} - E^{(N)}|\n$$\nThis quantity is directly related to the leading-order error coefficient, as $\\eta_E \\approx |C_E|/(N(N+1))$.\nFor the vector force, we define the estimator $\\eta_F$ as the standard Euclidean norm of the difference vector:\n$$\n\\eta_F = \\|\\mathbf{F}^{(N+1)} - \\mathbf{F}^{(N)}\\|_2\n$$\nBoth $\\eta_E$ and $\\eta_F$ are non-negative scalars that measure the consistency between calculations on the two grids, serving as proxies for the true error.\n\n### Summary of Computational Steps\n\nFor each test case specified by $N$, $\\mathbf{s}^{(N)}$, $\\mathbf{s}^{(N+1)}$, and $k_F$:\n1.  Compute the discrete averages $E^{(N)}$ and $\\mathbf{F}^{(N)}$ on an $N \\times N \\times N$ grid with shift $\\mathbf{s}^{(N)}$.\n2.  Compute the discrete averages $E^{(N+1)}$ and $\\mathbf{F}^{(N+1)}$ on an $(N+1) \\times (N+1) \\times (N+1)$ grid with shift $\\mathbf{s}^{(N+1)}$.\n3.  Calculate the Richardson-extrapolated values $E^{\\mathrm{R}} = (N+1)E^{(N+1)} - N E^{(N)}$ and $\\mathbf{F}^{\\mathrm{R}} = (N+1)\\mathbf{F}^{(N+1)} - N \\mathbf{F}^{(N)}$.\n4.  Calculate the a posteriori error estimators $\\eta_E = |E^{(N+1)} - E^{(N)}|$ and $\\eta_F = \\|\\mathbf{F}^{(N+1)} - \\mathbf{F}^{(N)}\\|_2$.\n5.  Compute the exact energy average $\\bar{E}_{\\mathrm{exact}} = k_F^3 / (6\\pi^2)$. The exact force average $\\bar{\\mathbf{F}}_{\\mathrm{exact}}$ is the zero vector.\n6.  Determine the true errors of the extrapolated results: $|E^{\\mathrm{R}} - \\bar{E}_{\\mathrm{exact}}|$ and $\\|\\mathbf{F}^{\\mathrm{R}} - \\bar{\\mathbf{F}}_{\\mathrm{exact}}\\|_2 = \\|\\mathbf{F}^{\\mathrm{R}}\\|_2$.\n7.  Collect the six required floating-point numbers in the specified order: $E^{\\mathrm{R}}$, $\\eta_E$, $|E^{\\mathrm{R}} - \\bar{E}_{\\mathrm{exact}}|$, $\\|\\mathbf{F}^{\\mathrm{R}}\\|_2$, $\\eta_F$, and $\\|\\mathbf{F}^{\\mathrm{R}} - \\bar{\\mathbf{F}}_{\\mathrm{exact}}\\|_2$.\n\nThese steps are implemented in the provided Python program to generate the final numerical results.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_averages(grid_size: int, shift: np.ndarray, kF: float) -> tuple[float, np.ndarray]:\n    \"\"\"\n    Computes the discrete Brillouin zone averages for energy and force densities.\n\n    Args:\n        grid_size: The number of k-points along one dimension (N).\n        shift: The Monkhorst-Pack grid shift vector (s_1, s_2, s_3).\n        kF: The Fermi radius for the synthetic integrands.\n\n    Returns:\n        A tuple containing the average energy (scalar) and average force (3D vector).\n    \"\"\"\n    # Create 1D coordinate arrays for k_x, k_y, k_z\n    n_vals = np.arange(grid_size)\n    k_coords_1d = []\n    for i in range(3):\n        # Reduced coordinates\n        t_i = (n_vals + shift[i]) / grid_size\n        # Cartesian reciprocal coordinates\n        k_coord_i = 2 * np.pi * (t_i - 0.5)\n        k_coords_1d.append(k_coord_i)\n\n    # Create a 3D grid of k-vectors using meshgrid.\n    # 'ij' indexing ensures the output array axes correspond to kx, ky, kz.\n    kx_grid, ky_grid, kz_grid = np.meshgrid(\n        k_coords_1d[0], k_coords_1d[1], k_coords_1d[2], indexing='ij'\n    )\n    # Stack the coordinate grids to get a grid of 3D vectors.\n    # Shape: (grid_size, grid_size, grid_size, 3)\n    k_points = np.stack([kx_grid, ky_grid, kz_grid], axis=-1)\n\n    # Calculate the Euclidean norm of each k-vector in the grid.\n    k_norms = np.linalg.norm(k_points, axis=3)\n\n    # Evaluate the indicator function for the Fermi sphere.\n    # This represents the energy density e(k).\n    indicator = (k_norms <= kF).astype(float)\n\n    # The BZ average of e(k) is the simple mean over the grid.\n    E_avg = np.mean(indicator)\n\n    # Evaluate the force density f(k) = k * indicator.\n    # Use broadcasting to multiply the (N, N, N, 3) k_points grid\n    # by the (N, N, N) indicator grid.\n    f_k = k_points * indicator[..., np.newaxis]\n    \n    # The BZ average of f(k) is the mean over grid dimensions (0, 1, 2).\n    F_avg = np.mean(f_k, axis=(0, 1, 2))\n\n    return E_avg, F_avg\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'N': 6, 's_N': (0.0, 0.0, 0.0), 's_Np1': (0.5, 0.5, 0.5), 'kF': 1.2},\n        {'N': 3, 's_N': (0.25, 0.25, 0.25), 's_Np1': (0.75, 0.75, 0.75), 'kF': 1.8},\n        {'N': 2, 's_N': (0.0, 0.0, 0.0), 's_Np1': (0.5, 0.5, 0.5), 'kF': 0.3},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        N = case['N']\n        kF = case['kF']\n        s_N = np.array(case['s_N'])\n        s_Np1 = np.array(case['s_Np1'])\n\n        # Compute discrete averages for grid N and grid N+1\n        E_N, F_N = compute_averages(N, s_N, kF)\n        E_Np1, F_Np1 = compute_averages(N + 1, s_Np1, kF)\n\n        # Apply Richardson extrapolation\n        E_R = (N + 1) * E_Np1 - N * E_N\n        F_R = (N + 1) * F_Np1 - N * F_N\n\n        # Construct a posteriori error estimators\n        eta_E = np.abs(E_Np1 - E_N)\n        eta_F = np.linalg.norm(F_Np1 - F_N)\n\n        # Compute exact values for comparison\n        E_exact = kF**3 / (6 * np.pi**2)\n        F_exact_vec = np.array([0.0, 0.0, 0.0])\n\n        # Compute true errors of the extrapolated results\n        true_err_E = np.abs(E_R - E_exact)\n        norm_F_R = np.linalg.norm(F_R)\n        # The 6th required output is ||F^R - F_exact||_2, which is ||F^R - 0||_2 = ||F^R||_2\n        true_err_F = np.linalg.norm(F_R - F_exact_vec)\n\n        # Assemble the six required quantities for this test case\n        case_results = [\n            E_R,\n            eta_E,\n            true_err_E,\n            norm_F_R,\n            eta_F,\n            true_err_F,\n        ]\n        all_results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3467022"}]}