{"hands_on_practices": [{"introduction": "Before employing complex random number generation schemes, it is essential to understand the fundamental principles and limitations of the simplest generators. This first practice delves into the inner workings of the Linear Congruential Generator (LCG), a cornerstone algorithm in the history of computational science. By designing a full-period LCG for a specific hardware constraint [@problem_id:3484313], you will connect abstract number theory to the practical consequences of finite precision and discover how a generator's architecture dictates the very resolution of its random output.", "problem": "A computational materials science code for vacancy-mediated diffusion in a face-centered cubic metal uses a Linear Congruential Generator (LCG) to supply independent uniform pseudorandom variates to both a Kinetic Monte Carlo (KMC) event selector and a Molecular Dynamics (MD) thermostat. For portability and bitwise reproducibility across compilers and architectures, the generator is constrained to a $48$-bit modulus. The uniform variates returned to the simulation are defined by $U_n = x_n / m$, where $x_n$ are the internal integer states of the LCG and $m$ is the modulus.\n\nDesign an LCG with modulus $m$ corresponding to a $48$-bit state space that achieves a full period for all seeds $x_0 \\in \\{0,1,\\dots,m-1\\}$ by appropriately choosing integers $a$, $c$, and $m$ consistent with this bit-width and the full-period requirement. Then, deduce from first principles the implied resolution (the smallest nonzero spacing between distinct values) of the double-precision uniform variates $U_n$ produced by this generator.\n\nProvide your final answer as an exact analytical expression for the resolution (no units, no rounding).", "solution": "The problem requires the design of a Linear Congruential Generator (LCG) with a full period and the subsequent determination of the resolution of its output. An LCG is defined by the recurrence relation:\n$$x_{n+1} = (a x_n + c) \\pmod m$$\nwhere $a$ is the multiplier, $c$ is the increment, and $m$ is the modulus. The uniform pseudorandom variates $U_n$ are generated from the integer states $x_n$ by the normalization:\n$$U_n = \\frac{x_n}{m}$$\n\nFirst, we must establish the parameters of the LCG, specifically the modulus $m$. The problem states that the generator is constrained to a $48$-bit state space for portability and reproducibility. This implies that the number of unique integer states is $2^{48}$. Therefore, the modulus $m$ is chosen to be $m = 2^{48}$.\n\nNext, we must ensure the LCG achieves a full period. A full period for an LCG means that for any initial seed $x_0 \\in \\{0, 1, \\dots, m-1\\}$, the sequence of states $x_n$ will visit every integer in this set exactly once before repeating. The length of this period is therefore equal to the modulus $m$. The conditions for an LCG to have a full period are given by the Hull-Dobell Theorem. For a general LCG, these conditions are:\n1. The increment $c$ and the modulus $m$ must be relatively prime, i.e., $\\gcd(c, m) = 1$.\n2. The term $a-1$ must be divisible by every prime factor of $m$.\n3. If $m$ is a multiple of $4$, then $a-1$ must also be a multiple of $4$.\n\nWe apply these conditions to our specific case where the modulus is $m = 2^{48}$.\nThe only prime factor of $m = 2^{48}$ is $2$.\nLet's analyze each condition:\n1. $\\gcd(c, 2^{48}) = 1$. This condition is satisfied if and only if $c$ is not divisible by $2$, meaning $c$ must be an odd integer.\n2. $a-1$ must be divisible by the prime factor $2$. This means $a-1$ must be an even integer, which implies that the multiplier $a$ must be an odd integer.\n3. The modulus $m = 2^{48}$ is a multiple of $4$ because $48 \\ge 2$. Therefore, $a-1$ must be divisible by $4$. This can be expressed as $a-1 \\equiv 0 \\pmod 4$, or more simply, $a \\equiv 1 \\pmod 4$.\n\nThe third condition, $a \\equiv 1 \\pmod 4$, implies that $a-1$ is a multiple of $4$, which guarantees it is also a multiple of $2$. Thus, the second condition is automatically satisfied if the third is. The complete set of requirements to design a full-period LCG with $m=2^{48}$ is:\n- $m = 2^{48}$\n- $a \\equiv 1 \\pmod 4$\n- $c$ is an odd integer.\n\nChoices that satisfy these conditions are numerous, for example, the parameters used in the standard `drand48` library function: $m=2^{48}$, $a = 25214903917$, and $c = 11$. Here, $a \\pmod 4 = 1$ and $c$ is odd. The existence of such parameters confirms that the design is valid.\n\nThe crucial consequence of having a full period is that the set of integer states $\\{x_n\\}$ generated over one complete cycle is a permutation of the set of all possible integers from $0$ to $m-1$. That is, the set of all distinct values that $x_n$ can take is precisely:\n$$ \\{0, 1, 2, \\dots, m-1\\} $$\n\nThe uniform variates $U_n$ are obtained by dividing these integer states by the modulus $m$. Therefore, the set of all possible distinct values for $U_n$ is:\n$$ \\left\\{ \\frac{0}{m}, \\frac{1}{m}, \\frac{2}{m}, \\dots, \\frac{m-1}{m} \\right\\} $$\nThese values are discrete and uniformly spaced. The \"double-precision\" nature of the variates refers to their floating-point representation in memory, which for IEEE $754$ provides a $52$-bit significand. This is more than sufficient to represent each of the $2^{48}$ distinct values $k/2^{48}$ exactly, so no precision is lost in this step.\n\nThe resolution of the generator is defined as the smallest nonzero spacing between distinct values of $U_n$. By inspecting the set of possible values, we can find this spacing by taking the difference between any two adjacent values, for example $\\frac{k+1}{m}$ and $\\frac{k}{m}$:\n$$ \\Delta U = \\frac{k+1}{m} - \\frac{k}{m} = \\frac{1}{m} $$\nThis spacing is the same for all adjacent pairs and represents the smallest possible non-zero difference between any two distinct values produced by the generator.\n\nSubstituting the value of the modulus $m = 2^{48}$, we find the resolution:\n$$ \\text{Resolution} = \\frac{1}{2^{48}} = 2^{-48} $$\nThis value is determined solely by the modulus of the full-period LCG.", "answer": "$$ \\boxed{2^{-48}} $$", "id": "3484313"}, {"introduction": "Many physical models in materials science, such as the Langevin equation, are formulated in continuous time, yet our simulations proceed in discrete steps. This exercise tackles the crucial task of bridging this gap for the stochastic forces that maintain temperature in a molecular dynamics simulation [@problem_id:3484301]. You will derive from first principles how the statistical properties of the continuous-time 'white noise' translate into the specific variance required for the discrete random numbers used in your integrator, a fundamental step in ensuring your simulation accurately reflects the target physical ensemble.", "problem": "In Langevin molecular dynamics for a single Cartesian degree of freedom of an atom of mass $m$, thermostatting at temperature $T$ with linear friction coefficient $\\gamma$ is modeled by the fluctuation-dissipation theorem. Let the stochastic force $\\eta(t)$ be a stationary zero-mean Gaussian white noise satisfying\n$$\n\\langle \\eta(t) \\rangle = 0, \\qquad \\langle \\eta(t)\\,\\eta(t') \\rangle = 2\\,\\gamma\\,k_{B}\\,T\\,\\delta(t-t'),\n$$\nwhere $k_{B}$ is the Boltzmann constant and $\\delta(\\cdot)$ is the Dirac delta distribution. Consider a time-discrete integrator that, over each time step of width $\\Delta t0$ from $t_{n}$ to $t_{n+1}=t_{n}+\\Delta t$, approximates the stochastic force by a constant value equal to the time average of $\\eta(t)$ over that interval,\n$$\n\\eta_{n} \\equiv \\frac{1}{\\Delta t}\\int_{t_{n}}^{t_{n+1}} \\eta(t)\\,dt.\n$$\nWorking from the definitions above and standard properties of Gaussian processes and the Dirac delta distribution, do the following:\n\n- Derive the mean and covariance of the discrete-time sequence $\\{\\eta_{n}\\}$ under this averaging rule, and justify whether $\\eta_{n}$ is Gaussian.\n- Show that each $\\eta_{n}$ can be sampled in practice by drawing a standard normal variate and rescaling by a deterministic standard deviation $\\sigma$ that depends on $\\gamma$, $k_{B}$, $T$, and $\\Delta t$.\n- Provide the closed-form symbolic expression for this standard deviation $\\sigma$.\n\nAssume ideal pseudorandom numbers with no correlations beyond those implied by the model. Express your final answer as a single closed-form analytic expression for $\\sigma$ in terms of $\\gamma$, $k_{B}$, $T$, and $\\Delta t$. Do not include units in your final answer. If any approximations are made, state and justify them in your derivation; the final answer must be exact in the white-noise model stated above.", "solution": "The problem is well-posed and scientifically grounded in the principles of statistical mechanics, specifically the theory of Brownian motion and Langevin dynamics. All provided definitions and conditions are standard and self-consistent. We may proceed with the derivation.\n\nThe objective is to determine the statistical properties of the discrete-time stochastic force $\\eta_n$, which is defined as the time-average of the continuous-time stochastic force $\\eta(t)$ over a time interval of width $\\Delta t$. The continuous-time force $\\eta(t)$ is a stationary Gaussian white noise process with the following properties:\n$$\n\\langle \\eta(t) \\rangle = 0\n$$\n$$\n\\langle \\eta(t)\\,\\eta(t') \\rangle = 2\\,\\gamma\\,k_{B}\\,T\\,\\delta(t-t')\n$$\nThe discrete-time force $\\eta_n$ for the interval $[t_n, t_{n+1}]$ where $t_{n+1} = t_n + \\Delta t$ is defined as:\n$$\n\\eta_{n} \\equiv \\frac{1}{\\Delta t}\\int_{t_{n}}^{t_{n+1}} \\eta(t)\\,dt\n$$\n\nFirst, we derive the mean of the random variable $\\eta_n$. By linearity of the expectation operator and the integral, we can write:\n$$\n\\langle \\eta_n \\rangle = \\left\\langle \\frac{1}{\\Delta t}\\int_{t_{n}}^{t_{n+1}} \\eta(t)\\,dt \\right\\rangle = \\frac{1}{\\Delta t}\\int_{t_{n}}^{t_{n+1}} \\langle \\eta(t) \\rangle\\,dt\n$$\nUsing the given property that $\\langle \\eta(t) \\rangle = 0$ for all $t$, the integral evaluates to zero:\n$$\n\\langle \\eta_n \\rangle = \\frac{1}{\\Delta t}\\int_{t_{n}}^{t_{n+1}} 0\\,dt = 0\n$$\nThus, the sequence of discrete-time forces $\\{\\eta_n\\}$ is a zero-mean process.\n\nNext, we establish that $\\eta_n$ is a Gaussian random variable. The continuous-time process $\\eta(t)$ is stipulated to be a Gaussian process. The discrete-time variable $\\eta_n$ is obtained by a linear operation (integration) on $\\eta(t)$. A fundamental property of Gaussian processes is that any linear functional of the process yields a Gaussian-distributed random variable. Therefore, each $\\eta_n$ in the sequence is a Gaussian random variable.\n\nNow, we derive the covariance of the sequence, $\\langle \\eta_n \\eta_m \\rangle$. Using the definition of $\\eta_n$:\n$$\n\\langle \\eta_n \\eta_m \\rangle = \\left\\langle \\left( \\frac{1}{\\Delta t}\\int_{t_{n}}^{t_{n+1}} \\eta(t)\\,dt \\right) \\left( \\frac{1}{\\Delta t}\\int_{t_{m}}^{t_{m+1}} \\eta(t')\\,dt' \\right) \\right\\rangle\n$$\nWe can rearrange the terms and interchange the expectation and integration operators:\n$$\n\\langle \\eta_n \\eta_m \\rangle = \\frac{1}{(\\Delta t)^2} \\int_{t_{n}}^{t_{n+1}} dt \\int_{t_{m}}^{t_{m+1}} dt' \\langle \\eta(t)\\,\\eta(t') \\rangle\n$$\nSubstituting the given autocorrelation for $\\eta(t)$:\n$$\n\\langle \\eta_n \\eta_m \\rangle = \\frac{1}{(\\Delta t)^2} \\int_{t_{n}}^{t_{n+1}} dt \\int_{t_{m}}^{t_{m+1}} dt' \\, (2\\,\\gamma\\,k_{B}\\,T\\,\\delta(t-t'))\n$$\nThe constant prefactor can be moved outside the integrals:\n$$\n\\langle \\eta_n \\eta_m \\rangle = \\frac{2\\,\\gamma\\,k_{B}\\,T}{(\\Delta t)^2} \\int_{t_{n}}^{t_{n+1}} dt \\int_{t_{m}}^{t_{m+1}} dt' \\,\\delta(t-t')\n$$\nWe evaluate the inner integral with respect to $t'$ first. The sifting property of the Dirac delta distribution states that $\\int f(x)\\delta(x-a)dx = f(a)$. Here, the integral of $\\delta(t-t')$ over the interval $[t_m, t_{m+1}]$ yields $1$ if $t$ is within this interval, and $0$ otherwise. So,\n$$\n\\int_{t_{m}}^{t_{m+1}} \\delta(t-t')\\,dt' = \n\\begin{cases}\n1  \\text{if } t \\in [t_m, t_{m+1}] \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\nThe expression for the covariance becomes:\n$$\n\\langle \\eta_n \\eta_m \\rangle = \\frac{2\\,\\gamma\\,k_{B}\\,T}{(\\Delta t)^2} \\int_{t_{n}}^{t_{n+1}} dt \\, \\left( \\int_{t_{m}}^{t_{m+1}} \\delta(t-t')\\,dt' \\right)\n$$\nWe must now consider two cases for the remaining integral over $t$.\nCase 1: $n \\neq m$. The integration intervals $[t_n, t_{n+1}]$ and $[t_m, t_{m+1}]$ are disjoint (they only touch at a boundary point, which has measure zero). Therefore, for any $t$ in $[t_n, t_{n+1}]$, $t$ is not in $[t_m, t_{m+1}]$. The inner integral is zero for all $t$ in the domain of the outer integral. Thus:\n$$\n\\langle \\eta_n \\eta_m \\rangle = 0 \\quad \\text{for } n \\neq m\n$$\nCase 2: $n = m$. The integration intervals are identical, i.e., $[t_n, t_{n+1}]$. For any $t$ in this interval, the result of the inner integral is $1$. The expression becomes:\n$$\n\\langle \\eta_n^2 \\rangle = \\frac{2\\,\\gamma\\,k_{B}\\,T}{(\\Delta t)^2} \\int_{t_{n}}^{t_{n+1}} 1\\,dt = \\frac{2\\,\\gamma\\,k_{B}\\,T}{(\\Delta t)^2} (t_{n+1} - t_n)\n$$\nSince $t_{n+1} - t_n = \\Delta t$, we have:\n$$\n\\langle \\eta_n^2 \\rangle = \\frac{2\\,\\gamma\\,k_{B}\\,T}{(\\Delta t)^2} \\Delta t = \\frac{2\\,\\gamma\\,k_{B}\\,T}{\\Delta t}\n$$\nCombining both cases using the Kronecker delta $\\delta_{nm}$, the covariance of the sequence is:\n$$\n\\langle \\eta_n \\eta_m \\rangle = \\frac{2\\,\\gamma\\,k_{B}\\,T}{\\Delta t} \\delta_{nm}\n$$\nThis shows that the discrete-time forces are uncorrelated between different time steps. Since they are also Gaussian, they form a sequence of independent and identically distributed (i.i.d.) random variables.\n\nThe variance of $\\eta_n$ is given by $\\text{Var}(\\eta_n) = \\langle \\eta_n^2 \\rangle - \\langle \\eta_n \\rangle^2$. Since $\\langle \\eta_n \\rangle = 0$, the variance is simply:\n$$\n\\text{Var}(\\eta_n) = \\langle \\eta_n^2 \\rangle = \\frac{2\\,\\gamma\\,k_{B}\\,T}{\\Delta t}\n$$\nA Gaussian random variable $X$ with mean $\\mu$ and variance $\\sigma^2$, denoted $X \\sim \\mathcal{N}(\\mu, \\sigma^2)$, can be generated from a standard normal variate $Z \\sim \\mathcal{N}(0, 1)$ using the transformation $X = \\mu + \\sigma Z$.\nIn our case, $\\eta_n$ is a Gaussian random variable with mean $\\mu = 0$ and variance given above. Therefore, $\\eta_n$ can be sampled by drawing a standard normal variate $Z_n$ and rescaling it by the standard deviation $\\sigma = \\sqrt{\\text{Var}(\\eta_n)}$.\n$$\n\\eta_n = \\sigma Z_n, \\quad \\text{where } Z_n \\sim \\mathcal{N}(0, 1)\n$$\nThe required deterministic standard deviation $\\sigma$ is therefore:\n$$\n\\sigma = \\sqrt{\\frac{2\\,\\gamma\\,k_{B}\\,T}{\\Delta t}}\n$$\nThis expression depends only on the physical parameters $\\gamma$, $k_B$, $T$, and the integrator time step $\\Delta t$, as requested. No approximations were made beyond the initial model of white noise.", "answer": "$$\n\\boxed{\\sqrt{\\frac{2 \\gamma k_{B} T}{\\Delta t}}}\n$$", "id": "3484301"}, {"introduction": "As computational simulations scale to thousands of processors, ensuring the statistical independence of random numbers across parallel tasks becomes paramount. Naive use of PRNGs can introduce spurious correlations that silently corrupt simulation results, a particularly dangerous pitfall in domain-decomposed molecular dynamics. This advanced practice guides you through implementing a modern, robust solution using a counter-based generator with a skip-ahead strategy [@problem_id:3484374], and then asks you to empirically verify the streams' independence, providing a critical skill set for high-performance scientific computing.", "problem": "Consider independent random force generation for domain-decomposed Molecular Dynamics (MD) where the computational domain is split into $P$ non-overlapping subdomains, each advanced by a separate task. Suppose the stochastic thermostat requires a discrete-time, zero-mean, unit-variance white-noise force sequence $\\{\\eta_i(t)\\}_{t=0}^{N-1}$ per subdomain $i \\in \\{0,1,\\dots,P-1\\}$. Independence across subdomains is critical to avoid spurious correlations.\n\nYou are tasked with designing a procedure to construct $P$ independent random streams using skip-ahead on a counter-based Pseudorandom Number Generator (PRNG), and quantifying inter-stream correlation by computing cross-covariances $\\langle \\eta_i(t)\\eta_j(t+\\Delta t)\\rangle$ for $i \\neq j$. The construction and quantification must be implemented as a complete, runnable program.\n\nFundamental base:\n- A counter-based PRNG outputs a value that is a deterministic function of an integer counter and a fixed seed. Independence between separate streams is achieved by ensuring counters from different streams do not overlap.\n- For ideal white noise, for all $i \\neq j$ and all integer lags $\\Delta t \\geq 0$, $\\mathbb{E}[\\eta_i(t)] = 0$, $\\mathrm{Var}[\\eta_i(t)]=1$, and $\\mathbb{E}[\\eta_i(t)\\eta_j(t+\\Delta t)] = 0$. Empirically, cross-covariance is estimated from finite samples.\n- The sample mean of a sequence $x(t)$ is $\\bar{x} = \\frac{1}{N} \\sum_{t=0}^{N-1} x(t)$. The sample cross-covariance at lag $\\Delta t$ between sequences $x(t)$ and $y(t)$ is defined by\n$$\n\\hat{C}_{xy}(\\Delta t) = \\frac{1}{N-\\Delta t} \\sum_{t=0}^{N-\\Delta t - 1} \\big(x(t) - \\bar{x}\\big)\\big(y(t+\\Delta t)-\\bar{y}\\big),\n$$\nfor integer $0 \\leq \\Delta t  N$.\n\nRequirements:\n1. Implement a fixed counter-based PRNG using the SplitMix64 mixing function, with a $64$-bit unsigned integer counter $c$ and a $64$-bit unsigned integer seed $s$, defined by\n$$\n\\begin{aligned}\nx = (c + s) \\bmod 2^{64}, \\\\\nx = \\left(x \\oplus (x \\gg 30)\\right) \\times 0x\\mathrm{BF58476D1CE4E5B9} \\bmod 2^{64}, \\\\\nx = \\left(x \\oplus (x \\gg 27)\\right) \\times 0x\\mathrm{94D049BB133111EB} \\bmod 2^{64}, \\\\\nx = x \\oplus (x \\gg 31),\n\\end{aligned}\n$$\nwhere $\\oplus$ denotes bitwise exclusive-or and $\\gg$ denotes bitwise right shift. Convert the $64$-bit output to a floating-point uniform variate on $[0,1)$ by extracting the high $53$ bits and dividing by $2^{53}$.\n\n2. Use skip-ahead to construct $P$ streams. For stream index $i$, define a base counter offset $C_i = i \\times M$, where $M$ is a positive integer stride. For time index $t$, the counter is $c = C_i + t$. This ensures non-overlapping counters across streams provided $M$ is sufficiently large relative to $N$.\n\n3. Map the uniform variates to standard normal variates to produce $\\eta_i(t)$ using the Boxâ€“Muller transform. For each pair of uniforms $u_1,u_2 \\in (0,1)$, compute\n$$\nr = \\sqrt{-2 \\ln(u_1)}, \\quad \\theta = 2\\pi u_2, \\quad z_0 = r \\cos(\\theta), \\quad z_1 = r \\sin(\\theta),\n$$\nand use $\\{z_0,z_1\\}$ as successive samples. The angle must be in radians.\n\n4. For each test case, compute the cross-covariances between all distinct stream pairs $(i,j)$, $i \\neq j$, for each specified lag $\\Delta t$. Use the sample cross-covariance definition with the full-sequence sample means $\\bar{\\eta}_i$ and $\\bar{\\eta}_j$ for each stream.\n\n5. For each test case and each specified $\\Delta t$, report the single float\n$$\nm(\\Delta t) = \\max_{i \\neq j} \\left| \\hat{C}_{\\eta_i,\\eta_j}(\\Delta t) \\right|.\n$$\n\n6. If $P  2$ (i.e., there are no distinct pairs), define $m(\\Delta t) = 0.0$ for all specified $\\Delta t$.\n\n7. Numerical values are dimensionless. Angles are in radians. No physical units are required.\n\nTest suite:\n- Case A (happy path, non-overlapping streams): $P = 4$, $N = 200000$, $M = 2^{40}$, $s = 1469598103934665603$, lags $\\Delta t \\in \\{0,1,2\\}$.\n- Case B (boundary condition, single stream): $P = 1$, $N = 100000$, $M = 2^{20}$, $s = 1099511628211$, lags $\\Delta t \\in \\{0,1,2\\}$.\n- Case C (edge case, deliberately overlapping streams): $P = 3$, $N = 150000$, $M = 10000$, $s = 16045690984833335023$, lags $\\Delta t \\in \\{0, 10000, 20000\\}$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list of lists, each inner list corresponding to one test case and containing the floats $[m(\\Delta t_1), m(\\Delta t_2), \\dots]$ in the order of the specified lags for that case, with no spaces. For example, a valid output format is $[[a_1,a_2,a_3],[b_1,b_2,b_3],[c_1,c_2,c_3]]$.", "solution": "The problem requires the design and implementation of a procedure for generating multiple independent streams of random numbers for use in parallel Molecular Dynamics simulations. The core of the task is to use a counter-based pseudorandom number generator (PRNG) with a skip-ahead strategy to ensure stream independence, and then to quantify any residual inter-stream correlation using a sample cross-covariance metric. The solution involves several distinct algorithmic steps: implementing the PRNG, transforming its output into standard normal variates, generating the parallel streams, and finally, computing the statistical measure of their independence.\n\n**1. Counter-Based PRNG and Uniform Variate Generation**\n\nThe foundation of the method is a deterministic, counter-based PRNG. The problem specifies the SplitMix64 algorithm. Its output is a function of a $64$-bit integer state, which is formed by the sum of a $64$-bit seed $s$ and a $64$-bit counter $c$. The mixing function is defined as:\n$$\n\\begin{aligned}\nx = (c + s) \\pmod{2^{64}} \\\\\nx = \\left(x \\oplus (x \\gg 30)\\right) \\times C_1 \\pmod{2^{64}} \\\\\nx = \\left(x \\oplus (x \\gg 27)\\right) \\times C_2 \\pmod{2^{64}} \\\\\nx = x \\oplus (x \\gg 31)\n\\end{aligned}\n$$\nwhere $C_1 = 0x\\mathrm{BF58476D1CE4E5B9}$ and $C_2 = 0x\\mathrm{94D049BB133111EB}$ are $64$-bit constants. The operations are bitwise right-shift ($\\gg$), bitwise exclusive-or ($\\oplus$), and unsigned $64$-bit multiplication. To simulate unsigned $64$-bit arithmetic in Python, where integers have arbitrary precision, bitwise AND operations with a mask of $2^{64}-1$ are applied after each step that could result in a value exceeding this limit.\n\nThe resulting $64$-bit integer $x$ is then converted to a double-precision floating-point number uniformly distributed in $[0,1)$. This is achieved by taking the $53$ most significant bits of $x$ (the mantissa precision of a standard double) and scaling the result. Specifically, `(x >> 11) / 2**53`. This maps the integer range $[0, 2^{53}-1]$ to the floating-point range $[0, 1 - 2^{-53}]$.\n\n**2. Parallel Stream Generation: Skip-Ahead and Box-Muller Transform**\n\nTo generate $P$ independent streams, a skip-ahead strategy is employed. Each stream $i \\in \\{0, \\dots, P-1\\}$ is assigned a unique, non-overlapping block of the PRNG's counter sequence. This is done by defining a base counter offset $C_i = i \\times M$, where $M$ is a large integer stride. For a given stream $i$ at time step $t$, the random variates are generated using counters starting from $C_i$.\n\nThe uniform variates are transformed into standard normal variates, $\\eta_i(t)$, using the Box-Muller transform. This method takes a pair of independent uniform variates, $u_1, u_2 \\in (0,1)$, and produces a pair of independent standard normal variates, $z_0, z_1$:\n$$\nr = \\sqrt{-2 \\ln(u_1)}, \\quad \\theta = 2\\pi u_2, \\quad z_0 = r \\cos(\\theta), \\quad z_1 = r \\sin(\\theta)\n$$\nA crucial implementation detail is that $\\ln(u_1)$ is undefined if $u_1=0$. Although the probability of generating $u_1=0$ is very low, a robust implementation must handle it. If $u_1=0$, it is replaced by a small positive value, such as $2^{-53}$, which is the smallest non-zero value this generator can produce.\n\nTo generate a full sequence $\\{\\eta_i(t)\\}_{t=0}^{N-1}$ for stream $i$, we repeatedly generate pairs of uniform variates using consecutive counters, starting from $C_i$. The $k$-th pair of normal variates, $(\\eta_i(2k), \\eta_i(2k+1))$, is generated from uniform variates derived from counters $C_i+2k$ and $C_i+2k+1$. This process is repeated $\\lceil N/2 \\rceil$ times to fill the array of $N$ normal variates. If $N$ is odd, the last generated normal variate is discarded.\n\n**3. Inter-Stream Correlation Quantification**\n\nThe independence of the generated streams is assessed by computing the sample cross-covariance. For two streams, $\\eta_i(t)$ and $\\eta_j(t)$, the cross-covariance at a time lag $\\Delta t$ is estimated by:\n$$\n\\hat{C}_{\\eta_i,\\eta_j}(\\Delta t) = \\frac{1}{N-\\Delta t} \\sum_{t=0}^{N-\\Delta t - 1} \\big(\\eta_i(t) - \\bar{\\eta}_i\\big)\\big(\\eta_j(t+\\Delta t)-\\bar{\\eta}_j\\big)\n$$\nwhere $\\bar{\\eta}_i$ and $\\bar{\\eta}_j$ are the sample means of the entire sequences. For truly independent streams, this value should be close to zero for all $i \\neq j$ and all lags $\\Delta t$. This calculation is performed for all distinct ordered pairs of streams $(i,j)$ where $i \\neq j$.\n\nThe final reported metric for each lag $\\Delta t$ is the maximum absolute cross-covariance found among all these pairs:\n$$\nm(\\Delta t) = \\max_{i \\neq j} \\left| \\hat{C}_{\\eta_i,\\eta_j}(\\Delta t) \\right|\n$$\nThis metric provides a single number summarizing the worst-case spurious correlation at a given lag. If $P  2$, no distinct pairs exist, and $m(\\Delta t)$ is defined as $0.0$.\n\n**4. Analysis of Test Cases**\n\nThe test suite is designed to validate the implementation and demonstrate the principles.\n- **Case A ($M \\gg N$)**: The stride $M$ is very large, ensuring the counter ranges for different streams are widely separated. This represents the correct usage of the skip-ahead method, and we expect the resulting cross-covariances to be very small, on the order of statistical noise ($1/\\sqrt{N}$).\n- **Case B ($P=1$)**: This is a boundary case. With only one stream, the concept of inter-stream correlation is not applicable, and the result is correctly defined as $0.0$.\n- **Case C ($M  N$)**: The stride is smaller than the stream length, causing the counter ranges to overlap. This is a deliberate misconfiguration. Specifically, the uniform sequence for stream $j$ is a time-shifted version of the sequence for stream $i$, i.e., $u_j(t) = u_i(t + (j-i)M)$. Consequently, the normal variate sequences are also shifted, $\\eta_j(t) = \\eta_i(t + (j-i)M)$. This introduced dependency will result in a large cross-covariance, close to $1$, when the lag $\\Delta t$ compensates for the shift, i.e., when $\\Delta t = (j-i)M$. For the lags $\\Delta t = 10000 = M$ and $\\Delta t = 20000 = 2M$, we expect to observe a correlation peak of approximately $1.0$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\n# --- PRNG Implementation ---\n\n# 64-bit mask for unsigned integer arithmetic\nMASK64 = (1  64) - 1\n\n# Constants for SplitMix64\nC1 = 0xBF58476D1CE4E5B9\nC2 = 0x94D049BB133111EB\n\ndef splitmix64_func(state):\n    \"\"\"The mixing function of the SplitMix64 PRNG.\"\"\"\n    x = state\n    x = (x ^ (x >> 30)) * C1\n    x = MASK64\n    x = (x ^ (x >> 27)) * C2\n    x = MASK64\n    x = x ^ (x >> 31)\n    return x  MASK64\n\ndef to_uniform_float(x):\n    \"\"\"Converts a 64-bit integer to a float in [0,1) using the upper 53 bits.\"\"\"\n    return (x >> 11) * (1.0 / (1  53))\n\n# --- Stream Generation ---\n\ndef generate_stream(stream_idx, N, M, seed):\n    \"\"\"Generates a stream of N standard normal variates.\"\"\"\n    normals = np.empty(N, dtype=np.float64)\n    base_counter = stream_idx * M\n    \n    num_pairs = (N + 1) // 2\n    \n    for i in range(num_pairs):\n        # Generate two uniform variates from consecutive counters\n        counter1 = base_counter + 2 * i\n        state1 = (counter1 + seed)  MASK64\n        u_raw1 = splitmix64_func(state1)\n        u1 = to_uniform_float(u_raw1)\n        \n        counter2 = base_counter + 2 * i + 1\n        state2 = (counter2 + seed)  MASK64\n        u_raw2 = splitmix64_func(state2)\n        u2 = to_uniform_float(u_raw2)\n        \n        # Box-Muller transform\n        # Handle u1 == 0.0 to avoid log(0)\n        if u1 == 0.0:\n            # Use the smallest representable positive value from this generator\n            u1 = 1.0 / (1  53)\n            \n        r = math.sqrt(-2.0 * math.log(u1))\n        theta = 2.0 * math.pi * u2\n        \n        z0 = r * math.cos(theta)\n        z1 = r * math.sin(theta)\n        \n        # Store the generated pair, handling odd N\n        if 2 * i  N:\n            normals[2 * i] = z0\n        if 2 * i + 1  N:\n            normals[2 * i + 1] = z1\n            \n    return normals\n\n# --- Correlation Calculation ---\n\ndef calculate_cross_covariance(s1, s2, lag):\n    \"\"\"Computes the sample cross-covariance between two streams at a given lag.\"\"\"\n    N = len(s1)\n    \n    if lag >= N:\n        return 0.0\n\n    num_terms = N - lag\n    if num_terms = 0:\n        return 0.0\n        \n    s1_mean = np.mean(s1)\n    s2_mean = np.mean(s2)\n    \n    s1_demeaned = s1 - s1_mean\n    s2_demeaned = s2 - s2_mean\n    \n    # Sum of products: (s1[t]-mean1) * (s2[t+lag]-mean2) for t from 0 to N-lag-1\n    covariance_sum = np.dot(s1_demeaned[:num_terms], s2_demeaned[lag:N])\n    \n    return covariance_sum / num_terms\n\n# --- Main Solver ---\n\ndef solve():\n    \"\"\"Main function to run test cases and produce the final output.\"\"\"\n    test_cases = [\n        # Case A: happy path, non-overlapping streams\n        {'P': 4, 'N': 200000, 'M': 2**40, 's': 1469598103934665603, 'lags': [0, 1, 2]},\n        # Case B: boundary condition, single stream\n        {'P': 1, 'N': 100000, 'M': 2**20, 's': 1099511628211, 'lags': [0, 1, 2]},\n        # Case C: edge case, deliberately overlapping streams\n        {'P': 3, 'N': 150000, 'M': 10000, 's': 16045690984833335023, 'lags': [0, 10000, 20000]}\n    ]\n\n    all_results = []\n    for case in test_cases:\n        P, N, M, s, lags = case['P'], case['N'], case['M'], case['s'], case['lags']\n        \n        case_results = []\n        \n        # Per requirement 6, if P  2, result is 0.0\n        if P  2:\n            case_results = [0.0] * len(lags)\n            all_results.append(case_results)\n            continue\n            \n        # Generate all P streams\n        streams = [generate_stream(i, N, M, s) for i in range(P)]\n        \n        for lag in lags:\n            max_abs_cov = 0.0\n            \n            # Iterate over all distinct ordered pairs (i, j)\n            for i in range(P):\n                for j in range(P):\n                    if i == j:\n                        continue\n                    \n                    cov = calculate_cross_covariance(streams[i], streams[j], lag)\n                    max_abs_cov = max(max_abs_cov, abs(cov))\n            \n            case_results.append(max_abs_cov)\n            \n        all_results.append(case_results)\n\n    # Format the final output string as specified\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n\n```", "id": "3484374"}]}