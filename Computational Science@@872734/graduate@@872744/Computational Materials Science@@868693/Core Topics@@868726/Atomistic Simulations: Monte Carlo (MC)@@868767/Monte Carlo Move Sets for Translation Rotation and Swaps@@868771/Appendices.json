{"hands_on_practices": [{"introduction": "A robust Monte Carlo simulation often benefits from a \"mixed\" move set, combining different types of trial moves like translations, rotations, and particle swaps to explore the configuration space efficiently. However, the mechanism for choosing which move to attempt can subtly affect the algorithm's validity. This exercise delves into the heart of the Metropolis-Hastings algorithm by examining the detailed balance condition, which ensures that the simulation correctly samples the Boltzmann distribution. You will analyze how a state-independent (\"balanced\") move selection scheme differs from a state-dependent (\"biased\") one, and in doing so, discover how the latter can inadvertently break detailed balance if the acceptance probability is not correctly formulated [@problem_id:3467384].", "problem": "You must implement a complete, runnable program that evaluates whether a mixed-move Markov Chain Monte Carlo step that selects between translation, rotation, and swap moves satisfies the detailed balance condition under two different move-type selection schemes. The program must compute, for each specified test case, the ratio that certifies detailed balance and output the ratios as floats.\n\nBegin from the fundamental base that for a Markov chain to converge to the Boltzmann distribution, the detailed balance condition must hold. Let a system have state $s$ with energy $E(s)$ and Boltzmann equilibrium probability $P_{\\mathrm{eq}}(s) \\propto \\exp(-\\beta E(s))$, where $\\beta$ is the inverse temperature. Let the transition probability from $s$ to $s'$ be $T(s \\to s') = q(s \\to s') \\, a(s \\to s')$, where $q(s \\to s')$ is the proposal distribution and $a(s \\to s')$ is the acceptance probability. The classical Metropolis acceptance is $a(s \\to s') = \\min\\!\\left(1, \\exp\\!\\left(-\\beta (E(s') - E(s))\\right)\\right)$ when the proposal is symmetric. Detailed balance requires\n$$\nP_{\\mathrm{eq}}(s)\\,T(s \\to s') \\;=\\; P_{\\mathrm{eq}}(s')\\,T(s' \\to s).\n$$\nTo test detailed balance numerically for a single proposed move $s \\to s'$, define the ratio\n$$\nR(s,s') \\;=\\; \\frac{P_{\\mathrm{eq}}(s)\\,q(s \\to s')\\,a(s \\to s')}{P_{\\mathrm{eq}}(s')\\,q(s' \\to s)\\,a(s' \\to s)}.\n$$\nIf detailed balance holds exactly, then $R(s,s') = 1$.\n\nSystem model. Consider a one-dimensional ring of $N$ lattice sites with periodic boundary conditions. Each site $i$ has a type $t_i \\in \\{\\text{A}, \\text{B}, \\text{E}\\}$ (A and B are occupied by type-A and type-B molecules, E denotes empty). Orientation angles are defined for type-A molecules only; let $\\theta_i$ be the orientation at site $i$ if $t_i=\\text{A}$ and undefined otherwise. Angles must be treated in radians.\n\nEnergy model. Use a nearest-neighbor interaction and a one-body orientation field:\n- Define $s_i = +1$ if $t_i=\\text{A}$, $s_i = -1$ if $t_i=\\text{B}$, and $s_i = 0$ if $t_i=\\text{E}$.\n- The nearest-neighbor energy is\n$$\nE_{\\mathrm{nn}}(s) \\;=\\; J \\sum_{i=0}^{N-1} s_i\\,s_{(i+1)\\bmod N}.\n$$\n- The rotational energy for type-A molecules is\n$$\nE_{\\mathrm{rot}}(s) \\;=\\; k \\sum_{i: t_i=\\text{A}} \\left(1 - \\cos(\\theta_i)\\right).\n$$\n- The total energy is $E(s) = E_{\\mathrm{nn}}(s) + E_{\\mathrm{rot}}(s)$.\n\nMonte Carlo move set. Implement three move types:\n1. Translation: choose an occupied site $i$ uniformly among all occupied sites. Choose a direction (left or right) uniformly. Propose moving the particle at $i$ into the neighboring site if it is empty, carrying its orientation $\\theta_i$ with it. If the neighbor is not empty, the proposal leaves the state unchanged (this latter case is not used in the test suite; only moves that change the state are tested).\n2. Rotation: choose a site $i$ with $t_i=\\text{A}$ uniformly among all type-A sites. Propose $\\theta_i' = \\theta_i + \\delta$ with $\\delta \\sim \\mathcal{N}(0,\\sigma^2)$; $\\sigma$ is the standard deviation, and the proposal density is $q_{\\mathrm{rot}}(\\delta) = \\frac{1}{\\sigma\\sqrt{2\\pi}}\\exp\\!\\left(-\\frac{\\delta^2}{2\\sigma^2}\\right)$.\n3. Local swap: choose a nearest-neighbor bond $(i,i+1)$ uniformly among the $N$ bonds. If both sites are occupied and the types are different (one A and one B), propose swapping the types across the bond; if the types are the same or one site is empty, the proposal leaves the state unchanged (the test suite uses only swaps that change the state).\n\nSelection schemes for mixed moves:\n- Balanced selection: choose translation, rotation, and swap with fixed probabilities $c_{\\mathrm{T}} = c_{\\mathrm{R}} = c_{\\mathrm{S}} = 1/3$, independent of the current state. Within each move type, select targets uniformly as specified above. The resulting proposals are symmetric in the sense required by the classical Metropolis acceptance.\n- Biased (state-dependent) selection: compute the count of eligible proposals in the current state $s$ for each move type:\n    - Let $m_{\\mathrm{T}}(s)$ be the number of ordered translation proposals that would change the state (each occupied site contributes one count for each empty neighbor direction).\n    - Let $m_{\\mathrm{R}}(s)$ be the number of type-A sites.\n    - Let $m_{\\mathrm{S}}(s)$ be the number of nearest-neighbor bonds that are occupied by unlike types (A–B or B–A).\n  Define the move-type selection probabilities $p_{\\mathrm{T}}(s) = \\frac{m_{\\mathrm{T}}(s)}{m_{\\Sigma}(s)}$, $p_{\\mathrm{R}}(s) = \\frac{m_{\\mathrm{R}}(s)}{m_{\\Sigma}(s)}$, $p_{\\mathrm{S}}(s) = \\frac{m_{\\mathrm{S}}(s)}{m_{\\Sigma}(s)}$, where $m_{\\Sigma}(s) = m_{\\mathrm{T}}(s) + m_{\\mathrm{R}}(s) + m_{\\mathrm{S}}(s)$. Within the chosen move type, select uniformly among the eligible proposals. For rotation, the continuous proposal density $q_{\\mathrm{rot}}(\\delta)$ multiplies the discrete selection factor. Note that this scheme makes $q(s \\to s')$ proportional to $1/m_{\\Sigma}(s)$ times any move-type-specific continuous density, and $m_{\\Sigma}$ can change between $s$ and $s'$.\n\nAcceptance. Use the classical Metropolis acceptance $a(s \\to s') = \\min\\!\\left(1, \\exp\\!\\left(-\\beta (E(s') - E(s))\\right)\\right)$ in all cases. Angles must be handled in radians.\n\nTask. For each test case below, compute the ratio $R(s,s')$ defined above using the specified selection scheme and move. Your program must produce a single line of output containing the ratios for all test cases as a comma-separated list in square brackets.\n\nConstants for all tests: $N=4$, $\\beta=1.0$, $J=0.5$, $k=0.3$, $\\sigma=0.1$ (radians). Angles must be interpreted in radians.\n\nTest suite:\n- Test 1 (balanced translation):\n    - Initial types: $[\\text{A}, \\text{B}, \\text{E}, \\text{A}]$.\n    - Initial angles: $[\\theta_0=0.0, \\text{None}, \\text{None}, \\theta_3=1.0]$.\n    - Move: translation of site $i=1$ to the right (into site $2$).\n    - Selection scheme: balanced with $c_{\\mathrm{T}} = c_{\\mathrm{R}} = c_{\\mathrm{S}} = 1/3$.\n- Test 2 (biased local swap that changes move counts):\n    - Initial types: $[\\text{A}, \\text{B}, \\text{A}, \\text{E}]$.\n    - Initial angles: $[\\theta_0=0.0, \\text{None}, \\theta_2=0.0, \\text{None}]$.\n    - Move: swap across bond $(0,1)$.\n    - Selection scheme: biased with $p_{\\mathrm{T}}(s)$, $p_{\\mathrm{R}}(s)$, $p_{\\mathrm{S}}(s)$ as defined.\n- Test 3 (biased rotation that preserves move counts):\n    - Initial types: $[\\text{A}, \\text{B}, \\text{A}, \\text{B}]$.\n    - Initial angles: $[\\theta_0=0.0, \\text{None}, \\theta_2=0.0, \\text{None}]$.\n    - Move: rotation at site $i=0$ with $\\delta = 0.5$ radians.\n    - Selection scheme: biased with $p_{\\mathrm{T}}(s)$, $p_{\\mathrm{R}}(s)$, $p_{\\mathrm{S}}(s)$ as defined.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"), where each result is the float value of $R(s,s')$ for the corresponding test case, computed exactly from the definitions above. The angle unit is radians; no other physical units are required. Ensure numerical computations are precise and self-consistent. The program must be self-contained and produce the output without any user input.", "solution": "The problem requires the computation of the detailed balance certification ratio, $R(s,s')$, for a mixed-move Monte Carlo simulation under two different move selection schemes. The ratio is defined as:\n$$\nR(s,s') = \\frac{P_{\\mathrm{eq}}(s)\\,T(s \\to s')}{P_{\\mathrm{eq}}(s')\\,T(s' \\to s)}\n$$\nwhere $s$ and $s'$ are the initial and final states, $P_{\\mathrm{eq}}(x) \\propto \\exp(-\\beta E(x))$ is the equilibrium probability, and $T(x \\to y) = q(x \\to y)\\,a(x \\to y)$ is the transition probability. The proposal probability is $q(x \\to y)$ and the acceptance probability is $a(x \\to y)$.\n\nThe problem specifies the use of the classical Metropolis acceptance rule for all cases:\n$$\na(s \\to s') = \\min\\left(1, \\exp\\left(-\\beta (E(s') - E(s))\\right)\\right)\n$$\nLet's analyze the ratio $R(s,s')$. Substituting the definitions, we have:\n$$\nR(s,s') = \\frac{\\exp(-\\beta E(s))}{\\exp(-\\beta E(s'))} \\cdot \\frac{q(s \\to s')}{q(s' \\to s)} \\cdot \\frac{a(s \\to s')}{a(s' \\to s)}\n$$\nLet $\\Delta E = E(s') - E(s)$. The ratio of equilibrium probabilities is $\\exp(-\\beta(E(s)-E(s'))) = \\exp(\\beta\\Delta E)$.\nThe ratio of acceptance probabilities is:\n$$\n\\frac{a(s \\to s')}{a(s' \\to s)} = \\frac{\\min(1, \\exp(-\\beta\\Delta E))}{\\min(1, \\exp(-(-\\beta\\Delta E)))} = \\frac{\\min(1, \\exp(-\\beta\\Delta E))}{\\min(1, \\exp(\\beta\\Delta E))}\n$$\nLet $X = \\exp(-\\beta\\Delta E)$. The acceptance ratio becomes $\\frac{\\min(1, X)}{\\min(1, 1/X)}$. It can be shown that this expression is identically equal to $X$ for any $X > 0$. Therefore, the acceptance ratio simplifies to $\\exp(-\\beta\\Delta E)$.\n\nSubstituting these simplified terms back into the expression for $R(s,s')$ yields:\n$$\nR(s,s') = \\exp(\\beta\\Delta E) \\cdot \\frac{q(s \\to s')}{q(s' \\to s)} \\cdot \\exp(-\\beta\\Delta E) = \\frac{q(s \\to s')}{q(s' \\to s)}\n$$\nThis is a significant simplification. The certification ratio $R(s,s')$ collapses to the ratio of the forward and reverse proposal probabilities. Consequently, the energies of the states, the temperature $\\beta$, and the specific energy parameters $J$ and $k$ are not needed for the calculation, even though they are provided in the problem statement. The task reduces to correctly calculating $q(s \\to s')$ and $q(s' \\to s)$ for each test case.\n\nThe total proposal probability $q(s \\to s')$ is the product of the probability of selecting a move type and the probability of selecting the specific elementary move within that type.\n\nHere are the step-by-step calculations for each test case with constants $N=4, \\beta=1, J=0.5, k=0.3, \\sigma=0.1$.\n\n**Test 1: Balanced Translation**\n- Initial state $s$: types $[\\text{A}, \\text{B}, \\text{E}, \\text{A}]$. There are $3$ occupied sites.\n- Final state $s'$: types $[\\text{A}, \\text{E}, \\text{B}, \\text{A}]$. There are $3$ occupied sites.\n- Move: Translate particle at site $i=1$ to site $i=2$.\n- Selection scheme: Balanced, with $c_{\\mathrm{T}} = c_{\\mathrm{R}} = c_{\\mathrm{S}} = 1/3$.\n\nThe forward proposal probability $q(s \\to s')$ is:\n$q(s \\to s') = P(\\text{select Translation}) \\times P(\\text{select particle at } i=1) \\times P(\\text{select direction right})$\nThe number of occupied sites in state $s$ is $3$.\n$$\nq(s \\to s') = c_{\\mathrm{T}} \\times \\frac{1}{\\text{num occupied}} \\times \\frac{1}{2} = \\frac{1}{3} \\times \\frac{1}{3} \\times \\frac{1}{2} = \\frac{1}{18}\n$$\nThe reverse move is translating the particle at site $i=2$ in state $s'$ back to site $i=1$.\nThe number of occupied sites in state $s'$ is $3$.\n$$\nq(s' \\to s) = c_{\\mathrm{T}} \\times \\frac{1}{\\text{num occupied}} \\times \\frac{1}{2} = \\frac{1}{3} \\times \\frac{1}{3} \\times \\frac{1}{2} = \\frac{1}{18}\n$$\nThe ratio is $R(s,s') = \\frac{1/18}{1/18} = 1.0$.\n\n**Test 2: Biased Local Swap**\n- Initial state $s$: types $[\\text{A}, \\text{B}, \\text{A}, \\text{E}]$ at sites $[0, 1, 2, 3]$.\n- Final state $s'$: types $[\\text{B}, \\text{A}, \\text{A}, \\text{E}]$.\n- Move: Swap types across bond $(0,1)$.\n- Selection scheme: Biased, with probabilities depending on counts $m_{\\mathrm{T}}(s)$, $m_{\\mathrm{R}}(s)$, and $m_{\\mathrm{S}}(s)$.\n\nFor the initial state $s = [\\text{A}, \\text{B}, \\text{A}, \\text{E}]$:\n- $m_{\\mathrm{T}}(s)$: translations into empty sites. Site $0$ can move left to $3(\\text{E})$; site $2$ can move right to $3(\\text{E})$. So, $m_{\\mathrm{T}}(s)=2$.\n- $m_{\\mathrm{R}}(s)$: number of A-sites. Sites $0$ and $2$ are A. So, $m_{\\mathrm{R}}(s)=2$.\n- $m_{\\mathrm{S}}(s)$: number of A-B bonds. Bonds $(0,1)$ and $(1,2)$ are A-B/B-A. So, $m_{\\mathrm{S}}(s)=2$.\n- Total proposals: $m_{\\Sigma}(s) = m_{\\mathrm{T}}(s)+m_{\\mathrm{R}}(s)+m_{\\mathrm{S}}(s) = 2+2+2=6$.\n\nThe forward proposal probability $q(s \\to s')$ is:\n$q(s \\to s') = P(\\text{select Swap}) \\times P(\\text{select bond } (0,1) \\text{ | Swap})$\n$$\nq(s \\to s') = \\frac{m_{\\mathrm{S}}(s)}{m_{\\Sigma}(s)} \\times \\frac{1}{m_{\\mathrm{S}}(s)} = \\frac{2}{6} \\times \\frac{1}{2} = \\frac{1}{6}\n$$\nFor the final state $s' = [\\text{B}, \\text{A}, \\text{A}, \\text{E}]$:\n- $m_{\\mathrm{T}}(s')$: Site $0$ can move left to $3(\\text{E})$; site $2$ can move right to $3(\\text{E})$. So, $m_{\\mathrm{T}}(s')=2$.\n- $m_{\\mathrm{R}}(s')$: Sites $1$ and $2$ are A. So, $m_{\\mathrm{R}}(s')=2$.\n- $m_{\\mathrm{S}}(s')$: Only bond $(0,1)$ is B-A. So, $m_{\\mathrm{S}}(s')=1$.\n- Total proposals: $m_{\\Sigma}(s') = 2+2+1=5$.\n\nThe reverse proposal probability $q(s' \\to s)$ corresponds to swapping bond $(0,1)$ in state $s'$:\n$$\nq(s' \\to s) = \\frac{m_{\\mathrm{S}}(s')}{m_{\\Sigma}(s')} \\times \\frac{1}{m_{\\mathrm{S}}(s')} = \\frac{1}{5} \\times \\frac{1}{1} = \\frac{1}{5}\n$$\nThe ratio is $R(s,s') = \\frac{1/6}{1/5} = \\frac{5}{6}$.\n\n**Test 3: Biased Rotation**\n- Initial state $s$: types $[\\text{A}, \\text{B}, \\text{A}, \\text{B}]$.\n- Final state $s'$: types $[\\text{A}, \\text{B}, \\text{A}, \\text{B}]$.\n- Move: Rotate site $i=0$ by $\\delta = 0.5$ radians.\n- Selection scheme: Biased.\n\nFor state $s = [\\text{A}, \\text{B}, \\text{A}, \\text{B}]$ (and $s'$, since types don't change):\n- $m_{\\mathrm{T}}(s)$: No empty sites. So, $m_{\\mathrm{T}}(s)=0$.\n- $m_{\\mathrm{R}}(s)$: Sites $0$ and $2$ are A. So, $m_{\\mathrm{R}}(s)=2$.\n- $m_{\\mathrm{S}}(s)$: All four bonds are A-B or B-A. So, $m_{\\mathrm{S}}(s)=4$.\n- Total proposals: $m_{\\Sigma}(s) = 0+2+4=6$.\n\nThe forward proposal is a rotation of site $0$ by $\\delta=0.5$. It is a continuous move, so we use probability densities.\n$q(s \\to s') = P(\\text{select Rotation}) \\times P(\\text{select site } 0 \\text{ | Rotation}) \\times q_{\\mathrm{rot}}(\\delta)$\n$$\nq(s \\to s') = \\frac{m_{\\mathrm{R}}(s)}{m_{\\Sigma}(s)} \\times \\frac{1}{m_{\\mathrm{R}}(s)} \\times q_{\\mathrm{rot}}(0.5) = \\frac{2}{6} \\times \\frac{1}{2} \\times q_{\\mathrm{rot}}(0.5) = \\frac{1}{6} q_{\\mathrm{rot}}(0.5)\n$$\nwhere $q_{\\mathrm{rot}}(\\delta) = \\frac{1}{\\sigma\\sqrt{2\\pi}}\\exp(-\\frac{\\delta^2}{2\\sigma^2})$.\nThe reverse move is a rotation of site $0$ by $-\\delta=-0.5$. Since the type configuration is the same for $s'$, the discrete selection probabilities are identical.\n$$\nq(s' \\to s) = \\frac{m_{\\mathrm{R}}(s')}{m_{\\Sigma}(s')} \\times \\frac{1}{m_{\\mathrm{R}}(s')} \\times q_{\\mathrm{rot}}(-\\delta) = \\frac{2}{6} \\times \\frac{1}{2} \\times q_{\\mathrm{rot}}(-0.5) = \\frac{1}{6} q_{\\mathrm{rot}}(-0.5)\n$$\nThe Gaussian proposal density is symmetric, $q_{\\mathrm{rot}}(\\delta) = q_{\\mathrm{rot}}(-\\delta)$. Therefore, the densities cancel.\nThe ratio is $R(s,s') = \\frac{(1/6) q_{\\mathrm{rot}}(0.5)}{(1/6) q_{\\mathrm{rot}}(-0.5)} = 1.0$.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the detailed balance certification ratio R(s, s') for three\n    Monte Carlo move test cases.\n\n    As derived in the solution, the ratio R simplifies to q(s->s') / q(s'->s),\n    where q is the proposal probability. This calculation does not require\n    the energy, temperature, or related physical constants.\n    \"\"\"\n    N = 4\n\n    def get_m_counts(types):\n        \"\"\"\n        Calculates the number of eligible proposals for each move type.\n        m_T: Translation moves (occupied site next to empty site).\n        m_R: Rotation moves (number of 'A' type molecules).\n        m_S: Swap moves (number of A-B or B-A nearest-neighbor bonds).\n        \"\"\"\n        # m_T: Count valid translation moves\n        m_T = 0\n        occupied_indices = [i for i, site_type in enumerate(types) if site_type != 'E']\n        for i in occupied_indices:\n            left_neighbor_idx = (i - 1 + N) % N\n            right_neighbor_idx = (i + 1) % N\n            if types[left_neighbor_idx] == 'E':\n                m_T += 1\n            if types[right_neighbor_idx] == 'E':\n                m_T += 1\n\n        # m_R: Count type-A sites\n        m_R = types.count('A')\n\n        # m_S: Count A-B/B-A bonds\n        m_S = 0\n        for i in range(N):\n            neighbor_idx = (i + 1) % N\n            type_i = types[i]\n            type_j = types[neighbor_idx]\n            if type_i != 'E' and type_j != 'E' and type_i != type_j:\n                m_S += 1\n        \n        return m_T, m_R, m_S\n\n    results = []\n\n    # Test 1: Balanced translation\n    # Initial state s: ['A', 'B', 'E', 'A']. Final state s': ['A', 'E', 'B', 'A']\n    num_occupied_s = 3\n    num_occupied_sp = 3\n    c_T = 1.0 / 3.0\n    \n    q_fwd_1 = c_T * (1.0 / num_occupied_s) * (1.0 / 2.0)\n    q_rev_1 = c_T * (1.0 / num_occupied_sp) * (1.0 / 2.0)\n    ratio_1 = q_fwd_1 / q_rev_1\n    results.append(ratio_1)\n\n    # Test 2: Biased local swap\n    s_types_2 = ['A', 'B', 'A', 'E']\n    sp_types_2 = ['B', 'A', 'A', 'E']\n\n    # Forward move from s to s'\n    mt_s, mr_s, ms_s = get_m_counts(s_types_2)\n    msum_s = mt_s + mr_s + ms_s\n    q_fwd_2 = (ms_s / msum_s) * (1.0 / ms_s)\n\n    # Reverse move from s' to s\n    mt_sp, mr_sp, ms_sp = get_m_counts(sp_types_2)\n    msum_sp = mt_sp + mr_sp + ms_sp\n    q_rev_2 = (ms_sp / msum_sp) * (1.0 / ms_sp)\n\n    ratio_2 = q_fwd_2 / q_rev_2\n    results.append(ratio_2)\n\n    # Test 3: Biased rotation\n    # For a rotation move, the type configuration does not change.\n    # The proposal probability for the angle change, q_rot(delta), is\n    # symmetric for delta and -delta, so it cancels out in the ratio.\n    s_types_3 = ['A', 'B', 'A', 'B']\n\n    # Forward move\n    mt_s3, mr_s3, ms_s3 = get_m_counts(s_types_3)\n    msum_s3 = mt_s3 + mr_s3 + ms_s3\n    # The term for q_rot(delta) is omitted as it will be 1.0 after cancellation.\n    q_fwd_3 = (mr_s3 / msum_s3) * (1.0 / mr_s3)\n\n    # Reverse move (state types are the same)\n    q_rev_3 = q_fwd_3 # Since m_counts are the same and q_rot(-delta) = q_rot(delta)\n    \n    ratio_3 = q_fwd_3 / q_rev_3\n    results.append(ratio_3)\n\n    print(f\"[{','.join(f'{r:.15f}'.rstrip('0').rstrip('.') for r in results)}]\")\n\nsolve()\n```", "id": "3467384"}, {"introduction": "Moving from lattice models to continuous systems, we encounter the challenge of simulating particles with complex shapes and interactions. For systems with hard-core interactions, such as dense packings of colloids or liquid crystals, the Monte Carlo acceptance rule simplifies to a binary decision: a move is accepted only if it does not create a geometric overlap. This practice provides hands-on experience with this crucial case by focusing on spherocylinders, a common model for anisotropic particles. You will implement a rotational move and the corresponding overlap detection algorithm, which relies on solving the geometric problem of finding the minimum distance between the particles' axial line segments [@problem_id:3467426].", "problem": "Consider a canonical ensemble of identical spherocylinders with hard-core interactions. Each spherocylinder is parameterized by a center position vector $\\mathbf{c} \\in \\mathbb{R}^3$, a unit orientation vector $\\mathbf{u} \\in \\mathbb{R}^3$ with $\\lVert \\mathbf{u} \\rVert = 1$, a cylinder radius $r > 0$ (expressed in $\\mathrm{nm}$), and a total end-to-end axial length $L > 0$ (expressed in $\\mathrm{nm}$). The axial line segment associated with a spherocylinder is defined as the finite set $\\mathcal{S} = \\{ \\mathbf{c} + s \\mathbf{u} \\mid s \\in [-L/2, L/2] \\}$.\n\nThe hard-core potential $U$ between any pair of spherocylinders is $U = +\\infty$ if the spherocylinders geometrically overlap, and $U = 0$ otherwise. In the Metropolis Monte Carlo (MMC) framework for a canonical ensemble at inverse temperature $\\beta$, the acceptance probability for a proposed move from state $X$ to state $Y$ is given by $A(X \\to Y) = \\min(1, \\exp(-\\beta [U(Y) - U(X)]))$, which reduces to a binary acceptance for hard-core interactions.\n\nA spherocylinder can be viewed as the Minkowski sum of its axial line segment and a solid ball of radius $r$. Two such spherocylinders overlap if and only if the minimal Euclidean distance $\\delta$ between their finite axial line segments is strictly less than the sum of their radii. In the identical-radius case, the overlap condition is $\\delta < 2 r$, and the non-overlap condition is $\\delta \\ge 2 r$.\n\nDesign a rotational move around a specified axis that acts on the orientation $\\mathbf{u}$ of a single spherocylinder while holding its center $\\mathbf{c}$ fixed. The axis of rotation is a unit vector $\\mathbf{k} \\in \\mathbb{R}^3$ and the rotation angle is $\\theta$ (expressed in radians). The rotated orientation $\\mathbf{u}'$ must be obtained by a proper three-dimensional rotation about $\\mathbf{k}$ by angle $\\theta$. The acceptance for the proposed rotational move is binary: it is $1$ if, after rotation, the moved spherocylinder does not overlap with any other spherocylinder in the system, and it is $0$ otherwise.\n\nYou must express overlap detection solely in terms of the minimal distance between the two finite axial line segments of the spherocylinders, i.e., by solving for the closest approach between two finite line segments in $\\mathbb{R}^3$. Formally, given two segments $\\mathcal{S}_1 = \\{ \\mathbf{a}_0 + s \\mathbf{u}_1 \\mid s \\in [0,1] \\}$ and $\\mathcal{S}_2 = \\{ \\mathbf{b}_0 + t \\mathbf{v}_2 \\mid t \\in [0,1] \\}$ constructed by reparameterizing endpoints, compute the minimal distance $\\delta$ between points on these segments by minimizing the squared distance subject to the box constraints on the parameters, and then decide overlap using the threshold $2r$.\n\nImplement a complete program that:\n- Constructs a single spherocylinder to be rotated with parameters $(\\mathbf{c}_\\mathrm{A}, \\mathbf{u}_\\mathrm{A}, L, r)$.\n- Constructs one other spherocylinder in the environment for each test case with parameters $(\\mathbf{c}_\\mathrm{B}, \\mathbf{u}_\\mathrm{B}, L, r)$.\n- Applies the specified rotational move to the first spherocylinder’s orientation $\\mathbf{u}_\\mathrm{A}$ around axis $\\mathbf{k}$ by angle $\\theta$ (in radians).\n- Computes the minimal distance $\\delta$ between the finite axial line segments of the rotated spherocylinder and the other spherocylinder, in $\\mathrm{nm}$.\n- Returns a boolean acceptance, where $1$ is represented as $\\mathrm{True}$ and $0$ as $\\mathrm{False}$, according to the rule: accept if and only if $\\delta \\ge 2 r$.\n\nUse the following fixed parameters for all test cases in the test suite:\n- Radius $r = 0.5$ $\\mathrm{nm}$.\n- Length $L = 4.0$ $\\mathrm{nm}$.\n- The spherocylinder to be rotated has center $\\mathbf{c}_\\mathrm{A} = (0.0, 0.0, 0.0)$ $\\mathrm{nm}$ and initial orientation $\\mathbf{u}_\\mathrm{A} = (1.0, 0.0, 0.0)$.\n\nAngles must be interpreted in radians. Distances must be computed in $\\mathrm{nm}$. The final program must produce a single line of output containing a comma-separated list of $\\mathrm{True}/\\mathrm{False}$ values enclosed in square brackets, with no spaces.\n\nTest suite:\n- Case $1$ (happy path, far separation after rotation): rotation axis $\\mathbf{k} = (0.0, 0.0, 1.0)$, angle $\\theta = \\pi/2$, other spherocylinder center $\\mathbf{c}_\\mathrm{B} = (0.0, 10.0, 0.0)$, orientation $\\mathbf{u}_\\mathrm{B} = (0.0, 1.0, 0.0)$. Expected acceptance is $\\mathrm{True}$.\n- Case $2$ (overlap after rotation, collinear segments with interior overlap): rotation axis $\\mathbf{k} = (0.0, 0.0, 1.0)$, angle $\\theta = \\pi/2$, other spherocylinder center $\\mathbf{c}_\\mathrm{B} = (0.0, 1.2, 0.0)$, orientation $\\mathbf{u}_\\mathrm{B} = (0.0, 1.0, 0.0)$. Expected acceptance is $\\mathrm{False}$.\n- Case $3$ (boundary tangency, minimal distance equals threshold): rotation axis $\\mathbf{k} = (0.0, 0.0, 1.0)$, angle $\\theta = \\pi/2$, other spherocylinder center $\\mathbf{c}_\\mathrm{B} = (0.0, 5.0, 0.0)$, orientation $\\mathbf{u}_\\mathrm{B} = (0.0, 1.0, 0.0)$. Expected acceptance is $\\mathrm{True}$.\n- Case $4$ (skew segments, interior closest points): rotation axis $\\mathbf{k} = (0.0, 1.0, 0.0)$, angle $\\theta = \\pi/4$, other spherocylinder center $\\mathbf{c}_\\mathrm{B} = (0.0, 0.0, 1.0)$, orientation $\\mathbf{u}_\\mathrm{B} = (1.0, 0.0, 0.0)$. Expected acceptance is $\\mathrm{False}$.\n- Case $5$ (parallel segments, lateral separation equals threshold): rotation axis $\\mathbf{k} = (0.0, 0.0, 1.0)$, angle $\\theta = 0.0$, other spherocylinder center $\\mathbf{c}_\\mathrm{B} = (0.0, 1.0, 0.0)$, orientation $\\mathbf{u}_\\mathrm{B} = (1.0, 0.0, 0.0)$. Expected acceptance is $\\mathrm{True}$.\n- Case $6$ (parallel segments, lateral separation below threshold): rotation axis $\\mathbf{k} = (0.0, 0.0, 1.0)$, angle $\\theta = 0.0$, other spherocylinder center $\\mathbf{c}_\\mathrm{B} = (0.0, 0.6, 0.0)$, orientation $\\mathbf{u}_\\mathrm{B} = (1.0, 0.0, 0.0)$. Expected acceptance is $\\mathrm{False}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[\\mathrm{True},\\mathrm{False}]$, but with the six test case results in order and no spaces.", "solution": "For systems with hard-core interactions, the potential energy $U$ is either zero (no overlap) or infinite (overlap). The Metropolis acceptance probability for a move from state $X$ to $Y$, $A(X \\to Y) = \\min(1, \\exp(-\\beta [U(Y) - U(X)]))$, therefore simplifies to a binary decision. If a move creates an overlap, $\\Delta U = +\\infty$ and the move is always rejected ($A=0$). If no new overlap is created, $\\Delta U=0$ and the move is always accepted ($A=1$).\n\nThe core of the problem is to determine the geometric overlap condition for two spherocylinders. A spherocylinder with radius $r$ and axial length $L$ is the set of all points within a distance $r$ of its central line segment. Consequently, two identical spherocylinders overlap if and only if the minimum Euclidean distance, $\\delta$, between their central axial line segments is less than the sum of their radii, $2r$. The acceptance condition for a rotational move is thus $\\delta \\ge 2r$.\n\nThe computational task reduces to finding the minimal distance between two finite line segments in $\\mathbb{R}^3$. Let the two segments be parameterized as $\\mathbf{p}(s) = \\mathbf{a}_0 + s(\\mathbf{a}_1 - \\mathbf{a}_0)$ and $\\mathbf{q}(t) = \\mathbf{b}_0 + t(\\mathbf{b}_1 - \\mathbf{b}_0)$, for $s, t \\in [0, 1]$. We need to minimize the squared distance function $f(s,t) = \\lVert \\mathbf{p}(s) - \\mathbf{q}(t) \\rVert^2$ subject to the constraints on $s$ and $t$.\n\nThe unconstrained minimum is found by setting the partial derivatives $\\partial f/\\partial s$ and $\\partial f/\\partial t$ to zero, which yields a 2x2 linear system for the optimal $(s^*, t^*)$:\n$$\n\\begin{pmatrix} (\\mathbf{u}\\cdot\\mathbf{u}) & -(\\mathbf{u}\\cdot\\mathbf{v}) \\\\ -(\\mathbf{u}\\cdot\\mathbf{v}) & (\\mathbf{v}\\cdot\\mathbf{v}) \\end{pmatrix}\n\\begin{pmatrix} s^* \\\\ t^* \\end{pmatrix}\n=\n\\begin{pmatrix} -(\\mathbf{u}\\cdot\\mathbf{w}_0) \\\\ (\\mathbf{v}\\cdot\\mathbf{w}_0) \\end{pmatrix}\n$$\nwhere $\\mathbf{u} = \\mathbf{a}_1-\\mathbf{a}_0$, $\\mathbf{v} = \\mathbf{b}_1-\\mathbf{b}_0$, and $\\mathbf{w}_0 = \\mathbf{a}_0-\\mathbf{b}_0$.\n\nThe solution $(s^*, t^*)$ must then be clamped to the valid range $[0, 1] \\times [0, 1]$. If $s^*$ or $t^*$ falls outside this box, the true minimum lies on the boundary of the domain. A robust algorithm checks the interior solution and then evaluates the distance at the boundary regions (endpoints and edges of the parameter space) to find the global minimum for the constrained problem. Once the correct $(s,t)$ are found, the minimal distance $\\delta$ is computed, and the move is accepted if $\\delta \\ge 2r$. The rotational move itself is applied to the spherocylinder's orientation vector using a standard method such as the Rodrigues rotation formula.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef rodrigues_rotate(v: np.ndarray, k: np.ndarray, theta: float) -> np.ndarray:\n    \"\"\"\n    Rotate vector v about axis k (unit vector) by angle theta (radians)\n    using the Rodrigues rotation formula.\n    \"\"\"\n    k = np.asarray(k, dtype=float)\n    v = np.asarray(v, dtype=float)\n    knorm = np.linalg.norm(k)\n    if knorm == 0.0:\n        # No rotation if axis is zero; return original vector\n        return v.copy()\n    k = k / knorm\n    ct = np.cos(theta)\n    st = np.sin(theta)\n    return v * ct + np.cross(k, v) * st + k * np.dot(k, v) * (1.0 - ct)\n\ndef segment_distance(a0: np.ndarray, a1: np.ndarray, b0: np.ndarray, b1: np.ndarray) -> float:\n    \"\"\"\n    Compute the minimal distance between two segments [a0,a1] and [b0,b1] in R^3.\n    Robust handling of parallel and degenerate (zero-length) segments.\n    Implementation follows case distinctions similar to those in\n    \"Real-Time Collision Detection\" by Christer Ericson.\n    \"\"\"\n    a0 = np.asarray(a0, dtype=float)\n    a1 = np.asarray(a1, dtype=float)\n    b0 = np.asarray(b0, dtype=float)\n    b1 = np.asarray(b1, dtype=float)\n\n    u = a1 - a0\n    v = b1 - b0\n    w0 = a0 - b0\n\n    A = np.dot(u, u)\n    B = np.dot(u, v)\n    C = np.dot(v, v)\n    D = np.dot(u, w0)\n    E = np.dot(v, w0)\n    SMALL = 1e-12\n\n    sN = 0.0\n    tN = 0.0\n    sD = A\n    tD = C\n    denom = A * C - B * B\n\n    # Handle degenerate segments\n    if A <= SMALL and C <= SMALL:\n        # Both segments are points\n        return float(np.linalg.norm(a0 - b0))\n    if A <= SMALL:\n        # First segment is a point; project onto second\n        sN = 0.0\n        sD = 1.0\n        tN = E\n        tD = C\n    elif C <= SMALL:\n        # Second segment is a point; project onto first\n        tN = 0.0\n        tD = 1.0\n        sN = -D\n        sD = A\n    else:\n        # General case\n        if denom != 0.0:\n            sN = (B * E - C * D)\n            tN = (A * E - B * D)\n            sD = denom\n            tD = denom\n        else:\n            # Parallel segments: choose s to minimize distance to b0\n            sN = 0.0  # arbitrary\n            sD = 1.0\n            tN = E\n            tD = C\n\n    # Clamp s to [0,1]\n    s = sN / sD if sD > SMALL else 0.0\n    if s < 0.0:\n        s = 0.0\n        tN = E\n        tD = C\n    elif s > 1.0:\n        s = 1.0\n        tN = E + B\n        tD = C\n\n    # Clamp t to [0,1]\n    t = tN / tD if tD > SMALL else 0.0\n    if t < 0.0:\n        t = 0.0\n        # Recompute s for t=0\n        sN = -D\n        sD = A\n        s = sN / sD if sD > SMALL else 0.0\n        s = min(max(s, 0.0), 1.0)\n    elif t > 1.0:\n        t = 1.0\n        # Recompute s for t=1\n        sN = B - D\n        sD = A\n        s = sN / sD if sD > SMALL else 0.0\n        s = min(max(s, 0.0), 1.0)\n\n    # Compute closest points\n    pa = a0 + s * u\n    pb = b0 + t * v\n    return float(np.linalg.norm(pa - pb))\n\ndef spherocylinder_endpoints(center: np.ndarray, orientation: np.ndarray, length: float):\n    \"\"\"\n    Given center, unit orientation, and axial length, return segment endpoints.\n    \"\"\"\n    u = np.asarray(orientation, dtype=float)\n    nu = np.linalg.norm(u)\n    if nu == 0.0:\n        raise ValueError(\"Orientation vector must be non-zero.\")\n    u = u / nu\n    half = 0.5 * float(length)\n    a0 = np.asarray(center, dtype=float) - half * u\n    a1 = np.asarray(center, dtype=float) + half * u\n    return a0, a1\n\ndef rotational_move_acceptance(cA, uA, L, r, axis, angle, others):\n    \"\"\"\n    Perform rotational move on spherocylinder A and test overlap against others.\n    cA: center of A (3,)\n    uA: initial orientation of A (3,)\n    L: length\n    r: radius\n    axis: rotation axis (3,)\n    angle: rotation angle in radians\n    others: list of tuples [(cB, uB), ...]\n    Return: True if accepted (no overlaps), False otherwise.\n    \"\"\"\n    uA_rot = rodrigues_rotate(np.asarray(uA, dtype=float), np.asarray(axis, dtype=float), float(angle))\n    a0, a1 = spherocylinder_endpoints(cA, uA_rot, L)\n    threshold = 2.0 * float(r)\n    eps = 1e-12\n    for (cB, uB) in others:\n        b0, b1 = spherocylinder_endpoints(cB, uB, L)\n        d = segment_distance(a0, a1, b0, b1)\n        if d + eps < threshold:\n            return False\n    return True\n\ndef solve():\n    # Fixed parameters\n    L = 4.0  # nm\n    r = 0.5  # nm\n    cA = np.array([0.0, 0.0, 0.0], dtype=float)\n    uA = np.array([1.0, 0.0, 0.0], dtype=float)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Far separation after rotation (should accept)\n        {\n            \"axis\": (0.0, 0.0, 1.0),\n            \"angle\": np.pi / 2.0,\n            \"others\": [ (np.array([0.0, 10.0, 0.0], dtype=float), np.array([0.0, 1.0, 0.0], dtype=float)) ]\n        },\n        # Case 2: Overlap after rotation (should reject)\n        {\n            \"axis\": (0.0, 0.0, 1.0),\n            \"angle\": np.pi / 2.0,\n            \"others\": [ (np.array([0.0, 1.2, 0.0], dtype=float), np.array([0.0, 1.0, 0.0], dtype=float)) ]\n        },\n        # Case 3: Boundary tangency equals threshold (should accept)\n        {\n            \"axis\": (0.0, 0.0, 1.0),\n            \"angle\": np.pi / 2.0,\n            \"others\": [ (np.array([0.0, 5.0, 0.0], dtype=float), np.array([0.0, 1.0, 0.0], dtype=float)) ]\n        },\n        # Case 4: Skew segments interior closest points (should reject)\n        {\n            \"axis\": (0.0, 1.0, 0.0),\n            \"angle\": np.pi / 4.0,\n            \"others\": [ (np.array([0.0, 0.0, 1.0], dtype=float), np.array([1.0, 0.0, 0.0], dtype=float)) ]\n        },\n        # Case 5: Parallel segments, separation equals threshold (should accept)\n        {\n            \"axis\": (0.0, 0.0, 1.0),\n            \"angle\": 0.0,\n            \"others\": [ (np.array([0.0, 1.0, 0.0], dtype=float), np.array([1.0, 0.0, 0.0], dtype=float)) ]\n        },\n        # Case 6: Parallel segments, separation below threshold (should reject)\n        {\n            \"axis\": (0.0, 0.0, 1.0),\n            \"angle\": 0.0,\n            \"others\": [ (np.array([0.0, 0.6, 0.0], dtype=float), np.array([1.0, 0.0, 0.0], dtype=float)) ]\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        axis = case[\"axis\"]\n        angle = case[\"angle\"]\n        others = case[\"others\"]\n        result = rotational_move_acceptance(cA, uA, L, r, axis, angle, others)\n        results.append(result)\n\n    # Final print statement in the exact required format: no spaces.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3467426"}, {"introduction": "To simulate the properties of bulk materials, we almost universally employ periodic boundary conditions (PBC) to minimize finite-size effects. While PBC is straightforward for point particles, it introduces significant subtleties when simulating extended or rigid bodies that can span the boundaries of the simulation cell. This exercise tackles a critical, and often misunderstood, aspect of implementing rigid-body moves in periodic systems. By comparing a naive implementation with one that correctly uses the minimum-image convention (MIC), you will quantify the severe errors in energy and acceptance probability that arise from improperly calculating the orientation of a boundary-crossing dimer, solidifying your understanding of how to correctly handle molecular topology in periodic space [@problem_id:3467366].", "problem": "You are asked to implement a self-contained program that performs Monte Carlo (MC) move proposals for rigid bodies in a three-dimensional periodic simulation box, with attention to minimum-image aware rotation and wrapping, and to quantify how periodicity alters orientation-dependent energies and acceptance probabilities. The system consists of one or more rigid dimers (two-site rigid bodies) constrained by Periodic Boundary Conditions (PBC) in a cubic box of side length $L$. The move set includes translation, rotation, and species swap moves. Energies are orientation dependent and couple linearly to a spatially periodic external field, making the minimum-image convention critical near boundaries.\n\nThe fundamental base for this problem starts from the canonical ensemble. In the canonical ensemble, a microstate with energy $E$ has probability density proportional to $\\exp(-\\beta E)$, where $\\beta$ is the inverse thermal energy $1/(k_{\\mathrm{B}} T)$. The Metropolis acceptance rule for a proposed move that changes the energy from $E_{\\mathrm{old}}$ to $E_{\\mathrm{new}}$ is $p_{\\mathrm{acc}} = \\min \\{ 1, \\exp(-\\beta (E_{\\mathrm{new}} - E_{\\mathrm{old}})) \\}$. For rigid body rotations, the body-fixed displacements are rotated by a special orthogonal matrix derived from an axis-angle parameterization and then positions are wrapped back to the box using PBC. Under PBC, the minimum-image convention is used to compute orientation vectors: for a displacement $\\Delta \\mathbf{r} = \\mathbf{r}_2 - \\mathbf{r}_1$, the minimum-image displacement is $\\Delta \\mathbf{r}_{\\mathrm{MI}} = \\Delta \\mathbf{r} - L \\,\\mathrm{round}(\\Delta \\mathbf{r} / L)$ computed componentwise, and the orientation vector is $\\mathbf{n} = \\Delta \\mathbf{r}_{\\mathrm{MI}} / \\|\\Delta \\mathbf{r}_{\\mathrm{MI}}\\|$. Wrapping a position is performed as $\\mathbf{r} \\mapsto \\mathbf{r} \\bmod L$ applied componentwise.\n\nDefine the energy of a single dimer with species coupling strength $\\varepsilon$ as $E = - \\varepsilon \\sum_{i=1}^{2} \\mathbf{n} \\cdot \\hat{\\mathbf{e}}(\\mathbf{r}_i)$, where $\\mathbf{r}_1$ and $\\mathbf{r}_2$ are the site positions, $\\mathbf{n}$ is the dimer orientation computed using the minimum-image convention, and $\\hat{\\mathbf{e}}(\\mathbf{r})$ is the unit vector of a spatially periodic external field defined by $\\mathbf{e}(\\mathbf{r}) = [\\cos(2 \\pi x / L), \\cos(2 \\pi y / L), \\cos(2 \\pi z / L)]$ and $\\hat{\\mathbf{e}}(\\mathbf{r}) = \\mathbf{e}(\\mathbf{r}) / \\|\\mathbf{e}(\\mathbf{r})\\|$ if $\\|\\mathbf{e}(\\mathbf{r})\\| \\neq 0$, otherwise $\\hat{\\mathbf{e}}(\\mathbf{r}) = \\mathbf{0}$. This energy breaks head-tail symmetry (linear in $\\mathbf{n}$), making correct orientation calculation essential near boundaries. For a system of multiple dimers, the total energy is the sum over all dimers. For a species swap move, the positions remain fixed while the species coupling parameters $\\varepsilon$ are exchanged between two dimers.\n\nImplement two energy and acceptance evaluations: the correct one using the minimum-image orientation and a naive one that erroneously uses the difference of wrapped positions directly, $\\Delta \\mathbf{r}_{\\mathrm{naive}} = (\\mathbf{r}_2 \\bmod L) - (\\mathbf{r}_1 \\bmod L)$, normalized. Compute both $p_{\\mathrm{acc}}^{\\mathrm{correct}}$ and $p_{\\mathrm{acc}}^{\\mathrm{naive}} = \\min \\{ 1, \\exp(-\\beta (E_{\\mathrm{new,naive}} - E_{\\mathrm{old,naive}})) \\}$ to demonstrate how periodicity impacts orientation-dependent energies and acceptance probabilities.\n\nAngle units must be in radians. All energies are dimensionless and measured in arbitrary consistent units. The program must implement:\n- Translation move: $\\mathbf{r}_i \\mapsto \\mathbf{r}_i + \\Delta \\mathbf{t}$ for both sites $i=1,2$ of a selected dimer, followed by wrapping.\n- Rotation move: compute the dimer center as $\\mathbf{r}_{\\mathrm{c}} = \\mathbf{r}_1 + \\tfrac{1}{2} \\Delta \\mathbf{r}_{\\mathrm{MI}}$, compute body-frame displacements $\\mathbf{d}_1 = -\\tfrac{1}{2} \\mathbf{n} a$, $\\mathbf{d}_2 = +\\tfrac{1}{2} \\mathbf{n} a$ where $a = \\|\\Delta \\mathbf{r}_{\\mathrm{MI}}\\|$ is the bond length, rotate $\\mathbf{d}_1, \\mathbf{d}_2$ by the axis-angle rotation matrix, place the sites at $\\mathbf{r}_{\\mathrm{c}} + \\mathbf{d}_1^{\\prime}$ and $\\mathbf{r}_{\\mathrm{c}} + \\mathbf{d}_2^{\\prime}$, and wrap.\n- Swap move: exchange $\\varepsilon$ values between two dimers without changing positions.\n\nTest Suite and Final Output Specification:\nImplement the following four test cases. For each, compute and return a list containing $p_{\\mathrm{acc}}^{\\mathrm{correct}}$ and $p_{\\mathrm{acc}}^{\\mathrm{naive}}$ as floats.\n\n1. Rotation near boundary (boundary-sensitive case): One dimer in a box with $L = 10.0$, bond length $a = 4.0$, inverse temperature $\\beta = 2.0$, species coupling $\\varepsilon = 1.0$, initial center at $(9.2, 5.0, 5.0)$, initial orientation along $+\\hat{\\mathbf{x}}$ (so site positions are $(7.2, 5.0, 5.0)$ and $(11.2, 5.0, 5.0)$ which wraps to $(1.2, 5.0, 5.0)$), proposed rotation about axis $(0, 0, 1)$ by angle $0.9$ radians.\n\n2. Rotation away from boundary (happy path case): One dimer with $L = 10.0$, $a = 4.0$, $\\beta = 2.0$, $\\varepsilon = 1.0$, initial center at $(5.0, 5.0, 5.0)$, initial orientation along $+\\hat{\\mathbf{x}}$ (sites $(3.0, 5.0, 5.0)$ and $(7.0, 5.0, 5.0)$), rotation about axis $(0, 0, 1)$ by angle $0.9$ radians.\n\n3. Translation near boundary (wrapping-induced orientation ambiguity): One dimer with $L = 10.0$, $a = 4.0$, $\\beta = 2.0$, $\\varepsilon = 1.0$, initial center at $(9.8, 5.0, 5.0)$, initial orientation along $+\\hat{\\mathbf{x}}$ (sites $(7.8, 5.0, 5.0)$ and $(11.8, 5.0, 5.0)$ which wraps to $(1.8, 5.0, 5.0)$), proposed translation vector $(0.6, 0.0, 0.0)$.\n\n4. Species swap (swap move involving two dimers, one near boundary): Two dimers in a box with $L = 10.0$, $a = 4.0$, $\\beta = 1.5$, initial species couplings $\\varepsilon_{\\mathrm{A}} = 1.2$ and $\\varepsilon_{\\mathrm{B}} = 0.6$. Dimer A: center at $(9.2, 5.0, 5.0)$, orientation along $+\\hat{\\mathbf{x}}$ (sites $(7.2, 5.0, 5.0)$ and $(11.2, 5.0, 5.0)$ which wraps to $(1.2, 5.0, 5.0)$). Dimer B: center at $(2.0, 5.0, 5.0)$, orientation along $+\\hat{\\mathbf{y}}$ (sites $(2.0, 3.0, 5.0)$ and $(2.0, 7.0, 5.0)$). The proposed move swaps the species couplings between the two dimers.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element of this list corresponds to one test case and must itself be a two-element list containing $p_{\\mathrm{acc}}^{\\mathrm{correct}}$ and $p_{\\mathrm{acc}}^{\\mathrm{naive}}$. For example, the final format must be exactly like: [[p1_correct,p1_naive],[p2_correct,p2_naive],[p3_correct,p3_naive],[p4_correct,p4_naive]].", "solution": "The solution requires a careful implementation of rigid body dynamics under Periodic Boundary Conditions (PBC). The core of the problem is to compare the physical consequences of a correct, Minimum Image Convention (MIC) aware simulation versus a naive one that mishandles boundary-crossing molecules.\n\n**1. Coordinate Handling under PBC**\n\nIn a periodic box of side length $L$, particle positions are conceptually \"unwrapped\" (tracking their true path) but are \"wrapped\" for interaction calculations with periodic fields or for storage. Wrapping is done via the modulo operator: $\\mathbf{r}_{\\text{wrapped}} = \\mathbf{r} \\pmod L$.\n\nThe interaction between two particles (or the displacement between two sites of a rigid body) must use the shortest distance across the periodic lattice. This is calculated using the MIC. For a raw displacement $\\Delta\\mathbf{r} = \\mathbf{r}_2 - \\mathbf{r}_1$ based on unwrapped coordinates, the MIC vector is:\n$$ \\Delta \\mathbf{r}_{\\mathrm{MI}} = \\Delta \\mathbf{r} - L \\cdot \\mathrm{round}(\\Delta \\mathbf{r} / L) $$\n\n**2. Orientation Vector Calculation: Correct vs. Naive**\n\nThis distinction is the central point of the exercise.\n- **Correct Method**: The physical orientation vector $\\mathbf{n}$ of the dimer is derived from the MIC displacement between its two sites: $\\mathbf{n}_{\\mathrm{correct}} = \\Delta \\mathbf{r}_{\\mathrm{MI}} / \\|\\Delta \\mathbf{r}_{\\mathrm{MI}}\\|$.\n- **Naive Method**: A common error is to calculate the displacement from the *wrapped* coordinates: $\\Delta \\mathbf{r}_{\\mathrm{naive}} = (\\mathbf{r}_2 \\pmod L) - (\\mathbf{r}_1 \\pmod L)$. If the dimer crosses a boundary, this vector points across the box, not along the physical bond, leading to a completely incorrect orientation vector $\\mathbf{n}_{\\mathrm{naive}}$.\n\n**3. Energy Calculation**\n\nThe energy of a dimer, $E = - \\varepsilon \\sum_{i=1}^{2} \\mathbf{n} \\cdot \\hat{\\mathbf{e}}(\\mathbf{r}_i)$, depends on the orientation $\\mathbf{n}$ and the external field $\\hat{\\mathbf{e}}$ at the *wrapped* site positions $\\mathbf{r}_i^{\\mathrm{w}}$. The two methods will yield different energies whenever $\\mathbf{n}_{\\mathrm{correct}} \\neq \\mathbf{n}_{\\mathrm{naive}}$, which occurs for boundary-crossing dimers.\n\n**4. Monte Carlo Moves**\n\nAll transformations are applied to the unwrapped coordinates to preserve the dimer's rigid structure.\n- **Translation**: Both sites are displaced: $\\mathbf{r}_i' = \\mathbf{r}_i + \\Delta \\mathbf{t}$. The orientation does not change, but the energy does as the sites move to new field locations.\n- **Rotation**: To correctly rotate a boundary-spanning dimer, its center must be calculated using the MIC: $\\mathbf{r}_{\\mathrm{c}} = \\mathbf{r}_1 + \\frac{1}{2} \\Delta \\mathbf{r}_{\\mathrm{MI}}$. The new site positions are then found by rotating their position vectors relative to this center, $\\mathbf{r}_i' = \\mathbf{r}_{\\mathrm{c}} + \\mathbf{R}(\\mathbf{r}_i - \\mathbf{r}_{\\mathrm{c}})$.\n- **Swap**: Only the $\\varepsilon$ parameters are exchanged; coordinates are unchanged. The energy change comes from applying different $\\varepsilon$ values to the existing configurations.\n\n**5. Acceptance Probability**\n\nFor each move, the old and new energies are calculated using both the correct and naive methods. The corresponding acceptance probabilities are then found using the Metropolis rule, $p_{\\mathrm{acc}} = \\min \\{ 1, \\exp(-\\beta [E_{\\mathrm{new}} - E_{\\mathrm{old}}]) \\}$. The results will demonstrate a significant discrepancy between the two methods for moves involving boundary-crossing dimers.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial.transform import Rotation\n\ndef solve():\n    \"\"\"\n    Solves the Monte Carlo move set problem for all test cases.\n    \"\"\"\n\n    def wrap_positions(positions, box_length):\n        \"\"\"Wraps a single or multiple position vectors into the periodic box.\"\"\"\n        return positions % box_length\n\n    def minimum_image_displacement(r1, r2, box_length):\n        \"\"\"Computes the minimum image displacement vector from r1 to r2.\"\"\"\n        # Assumes r1 and r2 are unwrapped coordinates\n        delta_r = r2 - r1\n        return delta_r - box_length * np.around(delta_r / box_length)\n\n    def field_vector(r_wrapped, box_length):\n        \"\"\"Computes the unit vector of the external field at a wrapped position.\"\"\"\n        if box_length == 0: return np.zeros(3)\n        e = np.cos(2 * np.pi * r_wrapped / box_length)\n        norm_e = np.linalg.norm(e)\n        if norm_e == 0:\n            return np.zeros(3)\n        return e / norm_e\n\n    def calculate_dimer_energy(r1, r2, eps, box_length, method):\n        \"\"\"\n        Calculates the energy of a single dimer.\n        r1, r2 are unwrapped positions.\n        method can be 'correct' or 'naive'.\n        \"\"\"\n        r1_w = wrap_positions(r1, box_length)\n        r2_w = wrap_positions(r2, box_length)\n\n        if method == 'correct':\n            delta_r_mic = minimum_image_displacement(r1, r2, box_length)\n            norm_delta_r = np.linalg.norm(delta_r_mic)\n            n_hat = delta_r_mic / norm_delta_r if norm_delta_r > 0 else np.zeros(3)\n        elif method == 'naive':\n            delta_r_naive = r2_w - r1_w\n            norm_delta_r = np.linalg.norm(delta_r_naive)\n            n_hat = delta_r_naive / norm_delta_r if norm_delta_r > 0 else np.zeros(3)\n        else:\n            raise ValueError(\"Method must be 'correct' or 'naive'\")\n\n        e_field1 = field_vector(r1_w, box_length)\n        e_field2 = field_vector(r2_w, box_length)\n        \n        energy = -eps * (np.dot(n_hat, e_field1) + np.dot(n_hat, e_field2))\n        return energy\n        \n    def calculate_total_energy(dimers, box_length, method):\n        \"\"\"Calculates total energy for a list of dimers.\"\"\"\n        total_e = 0.0\n        for dimer in dimers:\n            r1, r2, eps = dimer\n            total_e += calculate_dimer_energy(r1, r2, eps, box_length, method)\n        return total_e\n\n    def get_acc_prob(delta_e, beta):\n        \"\"\"Computes Metropolis acceptance probability.\"\"\"\n        if delta_e <= 0:\n            return 1.0\n        return np.exp(-beta * delta_e)\n\n    # --- Test Cases ---\n\n    results = []\n\n    # Case 1: Rotation near boundary\n    def run_case_1():\n        L, a, beta, eps = 10.0, 4.0, 2.0, 1.0\n        r_c_init = np.array([9.2, 5.0, 5.0])\n        n_init = np.array([1.0, 0.0, 0.0])\n        r1_old = r_c_init - n_init * a / 2.0\n        r2_old = r_c_init + n_init * a / 2.0\n\n        dimers_old = [(r1_old, r2_old, eps)]\n        e_old_correct = calculate_total_energy(dimers_old, L, 'correct')\n        e_old_naive = calculate_total_energy(dimers_old, L, 'naive')\n\n        # Rotation move\n        rot_axis = np.array([0.0, 0.0, 1.0])\n        rot_angle = 0.9\n        rot_vec = rot_axis * rot_angle\n        rot = Rotation.from_rotvec(rot_vec)\n        \n        delta_r_mic = minimum_image_displacement(r1_old, r2_old, L)\n        r_c = r1_old + 0.5 * delta_r_mic\n        d1 = r1_old - r_c\n        d2 = r2_old - r_c\n        \n        r1_new = r_c + rot.apply(d1)\n        r2_new = r_c + rot.apply(d2)\n        \n        dimers_new = [(r1_new, r2_new, eps)]\n        e_new_correct = calculate_total_energy(dimers_new, L, 'correct')\n        e_new_naive = calculate_total_energy(dimers_new, L, 'naive')\n\n        p_acc_correct = get_acc_prob(e_new_correct - e_old_correct, beta)\n        p_acc_naive = get_acc_prob(e_new_naive - e_old_naive, beta)\n        \n        return [p_acc_correct, p_acc_naive]\n\n    results.append(run_case_1())\n\n    # Case 2: Rotation away from boundary\n    def run_case_2():\n        L, a, beta, eps = 10.0, 4.0, 2.0, 1.0\n        r_c_init = np.array([5.0, 5.0, 5.0])\n        n_init = np.array([1.0, 0.0, 0.0])\n        r1_old = r_c_init - n_init * a / 2.0\n        r2_old = r_c_init + n_init * a / 2.0\n\n        dimers_old = [(r1_old, r2_old, eps)]\n        e_old_correct = calculate_total_energy(dimers_old, L, 'correct')\n        e_old_naive = calculate_total_energy(dimers_old, L, 'naive')\n\n        rot_axis = np.array([0.0, 0.0, 1.0])\n        rot_angle = 0.9\n        rot = Rotation.from_rotvec(rot_axis * rot_angle)\n        \n        delta_r_mic = minimum_image_displacement(r1_old, r2_old, L)\n        r_c = r1_old + 0.5 * delta_r_mic\n        d1 = r1_old - r_c\n        d2 = r2_old - r_c\n        \n        r1_new = r_c + rot.apply(d1)\n        r2_new = r_c + rot.apply(d2)\n\n        dimers_new = [(r1_new, r2_new, eps)]\n        e_new_correct = calculate_total_energy(dimers_new, L, 'correct')\n        e_new_naive = calculate_total_energy(dimers_new, L, 'naive')\n\n        p_acc_correct = get_acc_prob(e_new_correct - e_old_correct, beta)\n        p_acc_naive = get_acc_prob(e_new_naive - e_old_naive, beta)\n        \n        return [p_acc_correct, p_acc_naive]\n\n    results.append(run_case_2())\n\n    # Case 3: Translation near boundary\n    def run_case_3():\n        L, a, beta, eps = 10.0, 4.0, 2.0, 1.0\n        r_c_init = np.array([9.8, 5.0, 5.0])\n        n_init = np.array([1.0, 0.0, 0.0])\n        r1_old = r_c_init - n_init * a / 2.0\n        r2_old = r_c_init + n_init * a / 2.0\n\n        dimers_old = [(r1_old, r2_old, eps)]\n        e_old_correct = calculate_total_energy(dimers_old, L, 'correct')\n        e_old_naive = calculate_total_energy(dimers_old, L, 'naive')\n        \n        # Translation move\n        trans_vec = np.array([0.6, 0.0, 0.0])\n        r1_new = r1_old + trans_vec\n        r2_new = r2_old + trans_vec\n\n        dimers_new = [(r1_new, r2_new, eps)]\n        e_new_correct = calculate_total_energy(dimers_new, L, 'correct')\n        e_new_naive = calculate_total_energy(dimers_new, L, 'naive')\n        \n        p_acc_correct = get_acc_prob(e_new_correct - e_old_correct, beta)\n        p_acc_naive = get_acc_prob(e_new_naive - e_old_naive, beta)\n        \n        return [p_acc_correct, p_acc_naive]\n\n    results.append(run_case_3())\n\n    # Case 4: Species swap\n    def run_case_4():\n        L, a, beta = 10.0, 4.0, 1.5\n        eps_A, eps_B = 1.2, 0.6\n        \n        # Dimer A\n        r_c_A = np.array([9.2, 5.0, 5.0])\n        n_A = np.array([1.0, 0.0, 0.0])\n        r1_A = r_c_A - n_A * a / 2.0\n        r2_A = r_c_A + n_A * a / 2.0\n        \n        # Dimer B\n        r_c_B = np.array([2.0, 5.0, 5.0])\n        n_B = np.array([0.0, 1.0, 0.0])\n        r1_B = r_c_B - n_B * a / 2.0\n        r2_B = r_c_B + n_B * a / 2.0\n\n        dimers_old = [(r1_A, r2_A, eps_A), (r1_B, r2_B, eps_B)]\n        e_old_correct = calculate_total_energy(dimers_old, L, 'correct')\n        e_old_naive = calculate_total_energy(dimers_old, L, 'naive')\n\n        # Swap move\n        dimers_new = [(r1_A, r2_A, eps_B), (r1_B, r2_B, eps_A)] # eps swapped\n        e_new_correct = calculate_total_energy(dimers_new, L, 'correct')\n        e_new_naive = calculate_total_energy(dimers_new, L, 'naive')\n        \n        p_acc_correct = get_acc_prob(e_new_correct - e_old_correct, beta)\n        p_acc_naive = get_acc_prob(e_new_naive - e_old_naive, beta)\n\n        return [p_acc_correct, p_acc_naive]\n        \n    results.append(run_case_4())\n    \n    # Format the final output string\n    result_str = \",\".join([str(res) for res in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```", "id": "3467366"}]}