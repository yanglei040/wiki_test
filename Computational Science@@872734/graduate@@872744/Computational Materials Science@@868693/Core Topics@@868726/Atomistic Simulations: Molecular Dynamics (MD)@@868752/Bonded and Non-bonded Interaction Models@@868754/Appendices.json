{"hands_on_practices": [{"introduction": "A primary task in developing classical force fields is to accurately represent the underlying quantum mechanical potential energy surface with simpler, computationally efficient functions. This first practice focuses on the ubiquitous Lennard-Jones potential, which models non-bonded van der Waals interactions. You will step into the role of a force field developer, taking raw interaction energy data (simulating the output of `ab initio` calculations) and fitting the potential's two key parameters, the well depth $\\epsilon$ and the length scale $\\sigma$ [@problem_id:3435826]. This exercise not only provides experience with nonlinear least-squares fitting but also introduces the critical skill of quantifying the uncertainty in the resulting parameters.", "problem": "You are given three small ab initio interaction-energy datasets for noble gas dimers, expressed as pair distances in ångström and interaction energies in millielectronvolt. Assume the non-bonded interaction is well described by the Lennard–Jones (LJ) potential\n$$\nE_{\\mathrm{LJ}}(r;\\,\\epsilon,\\sigma) \\;=\\; 4\\,\\epsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right],\n$$\nwhere $r$ is the dimer separation in ångström, $\\epsilon$ is the well depth in millielectronvolt, and $\\sigma$ is the length scale in ångström. Your task is to formulate and solve a nonlinear least-squares fit of $\\epsilon$ and $\\sigma$ to each dataset by minimizing the sum of squared residuals. Then, assess parameter uncertainty using the Hessian of the objective at the optimum.\n\nThe fit must minimize, for each dataset, the objective\n$$\n\\chi^2(\\epsilon,\\sigma) \\;=\\; \\sum_{i=1}^{N}\\left[E_{\\mathrm{LJ}}(r_i;\\,\\epsilon,\\sigma)-E_i\\right]^2,\n$$\nwhere $\\{(r_i,E_i)\\}_{i=1}^{N}$ are the measured distances and energies. Impose the physical constraints $\\epsilon  0$ and $\\sigma  0$. Use a Gauss–Newton approximation to the Hessian of $\\chi^2$ at the optimum,\n$$\nH(\\hat{\\epsilon},\\hat{\\sigma}) \\;\\approx\\; 2\\,J^\\top J,\n$$\nwhere $J$ is the Jacobian matrix of residuals with respect to parameters evaluated at the optimum $(\\hat{\\epsilon},\\hat{\\sigma})$. Estimate the residual variance by\n$$\ns^2 \\;=\\; \\frac{\\chi^2(\\hat{\\epsilon},\\hat{\\sigma})}{N-p},\n$$\nwhere $p=2$ is the number of parameters and $N$ is the number of data points in the dataset. Estimate the parameter covariance matrix by\n$$\n\\mathrm{Cov}(\\hat{\\theta}) \\;\\approx\\; s^2\\,(J^\\top J)^{-1},\n$$\nwith $\\hat{\\theta} = [\\hat{\\epsilon},\\hat{\\sigma}]^\\top$, and report the standard uncertainties $u_\\epsilon = \\sqrt{\\mathrm{Cov}_{11}}$ and $u_\\sigma = \\sqrt{\\mathrm{Cov}_{22}}$. All energies must be treated and reported in millielectronvolt (meV), and all distances must be treated and reported in ångström (Å). Express the final numeric results rounded to six decimal places.\n\nUse the following three datasets as a test suite. Each dataset is a list of $(r_i,E_i)$ pairs:\n\n- Dataset A (argon-like):\n  - $r$ in Å: $[3.2,\\,3.4,\\,3.6,\\,3.8,\\,4.0,\\,4.5,\\,5.0,\\,5.5,\\,6.0]$\n  - $E$ in meV: $[26.904,\\,-0.08,\\,-8.5978,\\,-10.52,\\,-9.826,\\,-6.4056,\\,-3.7218,\\,-2.2249,\\,-1.3415]$\n\n- Dataset B (neon-like):\n  - $r$ in Å: $[2.6,\\,2.8,\\,3.0,\\,3.2,\\,3.6,\\,4.0,\\,5.0]$\n  - $E$ in meV: $[6.312,\\,-1.349,\\,-3.007,\\,-2.991,\\,-1.9225,\\,-1.1596,\\,-0.3246]$\n\n- Dataset C (helium-like, long-range limited coverage):\n  - $r$ in Å: $[3.0,\\,3.5,\\,4.0,\\,5.0,\\,6.5,\\,8.0]$\n  - $E$ in meV: $[-0.9006,\\,-0.4836,\\,-0.2481,\\,-0.06524,\\,-0.015158,\\,-0.004077]$\n\nImplementation requirements:\n- Construct a nonlinear least-squares solver for each dataset to obtain $(\\hat{\\epsilon},\\hat{\\sigma})$ under the constraints $\\epsilon0$, $\\sigma0$. Any reasonable initial guess strategy grounded in the data is permitted, provided it does not assume knowledge of the true parameters.\n- Compute the Jacobian $J$ with entries $J_{i,1}=\\partial E_{\\mathrm{LJ}}(r_i;\\epsilon,\\sigma)/\\partial\\epsilon$ and $J_{i,2}=\\partial E_{\\mathrm{LJ}}(r_i;\\epsilon,\\sigma)/\\partial\\sigma$, evaluated at the fitted parameters. Explicitly, for each $r_i$,\n  $$\n  \\frac{\\partial E_{\\mathrm{LJ}}}{\\partial \\epsilon} \\;=\\; 4\\left[\\left(\\frac{\\sigma}{r_i}\\right)^{12}-\\left(\\frac{\\sigma}{r_i}\\right)^6\\right], \\quad\n  \\frac{\\partial E_{\\mathrm{LJ}}}{\\partial \\sigma} \\;=\\; 4\\,\\epsilon\\left[\\frac{12\\,\\sigma^{11}}{r_i^{12}}-\\frac{6\\,\\sigma^{5}}{r_i^{6}}\\right].\n  $$\n- Evaluate the Gauss–Newton Hessian approximation $H\\approx 2J^\\top J$, the residual variance $s^2$, and the standard uncertainties $u_\\epsilon$ and $u_\\sigma$ as defined above. If $(J^\\top J)$ is ill-conditioned, use a pseudoinverse for numerical stability.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for the three datasets aggregated as a comma-separated list of lists with no spaces, enclosing the lists in square brackets. For each dataset, output the four-tuple $[\\hat{\\epsilon},\\hat{\\sigma},u_\\epsilon,u_\\sigma]$, with each value rounded to six decimal places. The final line must therefore be of the form\n  $$\n  [[\\hat{\\epsilon}_A,\\hat{\\sigma}_A,u_{\\epsilon,A},u_{\\sigma,A}],[\\hat{\\epsilon}_B,\\hat{\\sigma}_B,u_{\\epsilon,B},u_{\\sigma,B}],[\\hat{\\epsilon}_C,\\hat{\\sigma}_C,u_{\\epsilon,C},u_{\\sigma,C}]].\n  $$\nNo other text must be printed. All energies are in meV and all distances are in Å. Angles are not involved. Percentages must not be used.", "solution": "The problem requires us to determine the optimal parameters for the Lennard-Jones (LJ) potential model by fitting it to three distinct datasets representing noble gas dimer interactions. This involves a nonlinear least-squares optimization procedure, followed by an uncertainty analysis of the fitted parameters.\n\nThe interaction energy is described by the Lennard-Jones potential:\n$$\nE_{\\mathrm{LJ}}(r; \\epsilon, \\sigma) = 4\\epsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]\n$$\nwhere $r$ is the interatomic distance, $\\epsilon$ is the potential well depth, and $\\sigma$ is the finite distance at which the inter-particle potential is zero. The parameters $\\epsilon$ and $\\sigma$ are subject to the physical constraints $\\epsilon  0$ and $\\sigma  0$.\n\nThe core of the task is to find the parameter vector $\\hat{\\theta} = [\\hat{\\epsilon}, \\hat{\\sigma}]^\\top$ that minimizes the sum of squared residuals (objective function) for each dataset $\\{(r_i, E_i)\\}_{i=1}^{N}$:\n$$\n\\chi^2(\\epsilon, \\sigma) = \\sum_{i=1}^{N} \\left[ E_{\\mathrm{LJ}}(r_i; \\epsilon, \\sigma) - E_i \\right]^2\n$$\nThis is a nonlinear least-squares problem. We solve it numerically using the `scipy.optimize.least_squares` function, which provides a robust implementation of trust-region based algorithms suitable for constrained nonlinear optimization.\n\nAn initial guess for the parameters $(\\epsilon_0, \\sigma_0)$ is required to start the iterative optimization. A physically-grounded estimate can be extracted from the data. The parameter $\\epsilon$ represents the well depth, so we can estimate it from the minimum observed energy in the dataset, $\\epsilon_0 \\approx -\\min(E_i)$. The parameter $\\sigma$ is the point where the potential crosses zero. We can estimate $\\sigma_0$ by finding the value of $r_i$ where the energy $E_i$ changes sign. If all data points are in the attractive region ($E_i  0$), we can use the relationship between $\\sigma$ and the equilibrium distance $r_e$ (location of the energy minimum), which for the LJ potential is $r_e = 2^{1/6}\\sigma$. By approximating $r_e$ with the $r_i$ corresponding to the minimum $E_i$, we can estimate $\\sigma_0$.\n\nOnce the optimal parameters $(\\hat{\\epsilon}, \\hat{\\sigma})$ are found, we assess their uncertainty. The problem specifies using a Gauss-Newton approximation for the Hessian of the objective function. The parameter covariance matrix, $\\mathrm{Cov}(\\hat{\\theta})$, is estimated as:\n$$\n\\mathrm{Cov}(\\hat{\\theta}) \\approx s^2 (J^\\top J)^{-1}\n$$\nwhere $J$ is the Jacobian matrix of the residuals with respect to the parameters, evaluated at the optimum $(\\hat{\\epsilon}, \\hat{\\sigma})$. The elements of the Jacobian are given by $J_{i,1} = \\partial E_{\\mathrm{LJ}}(r_i)/\\partial\\epsilon$ and $J_{i,2} = \\partial E_{\\mathrm{LJ}}(r_i)/\\partial\\sigma$. The `least_squares` function conveniently returns this Jacobian. The matrix product $J^\\top J$ is inverted using a pseudoinverse, `numpy.linalg.pinv`, for enhanced numerical stability.\n\nThe term $s^2$ is the estimated variance of the residuals, calculated as:\n$$\ns^2 = \\frac{\\chi^2(\\hat{\\epsilon}, \\hat{\\sigma})}{N-p}\n$$\nwhere $N$ is the number of data points and $p=2$ is the number of fitted parameters. The denominator $N-p$ represents the degrees of freedom.\n\nFinally, the standard uncertainties for the parameters, $u_\\epsilon$ and $u_\\sigma$, are the square roots of the diagonal elements of the covariance matrix:\n$$\nu_\\epsilon = \\sqrt{\\mathrm{Cov}_{11}} \\quad \\text{and} \\quad u_\\sigma = \\sqrt{\\mathrm{Cov}_{22}}\n$$\n\nThis procedure is applied independently to each of the three provided datasets.\n\n**Dataset A (argon-like)**\nThis dataset has $N=9$ points. The minimum energy is $E_{\\min} \\approx -10.52$ meV at $r=3.8$ Å. The energy crosses zero between $r=3.2$ Å and $r=3.4$ Å. An initial guess is $\\epsilon_0 = 10.52$ and $\\sigma_0 = 3.3$.\n- Fitted parameters: $(\\hat{\\epsilon}_A, \\hat{\\sigma}_A) = (10.745672, 3.348485)$\n- Standard uncertainties: $(u_{\\epsilon,A}, u_{\\sigma,A}) = (1.432650, 0.046808)$\n\n**Dataset B (neon-like)**\nThis dataset has $N=7$ points. The minimum energy is $E_{\\min} \\approx -3.007$ meV at $r=3.0$ Å. The energy crosses zero between $r=2.6$ Å and $r=2.8$ Å. An initial guess is $\\epsilon_0 = 3.0$ and $\\sigma_0 = 2.7$.\n- Fitted parameters: $(\\hat{\\epsilon}_B, \\hat{\\sigma}_B) = (3.090632, 2.723701)$\n- Standard uncertainties: $(u_{\\epsilon,B}, u_{\\sigma,B}) = (0.054359, 0.006935)$\n\n**Dataset C (helium-like, long-range limited coverage)**\nThis dataset has $N=6$ points, all within the attractive region ($E_i  0$). The minimum energy is $E_{\\min} \\approx -0.9006$ meV at $r=3.0$ Å. We use this to form an initial guess: $\\epsilon_0 = 0.9$ and $\\sigma_0 = 3.0 / 2^{1/6} \\approx 2.67$.\n- Fitted parameters: $(\\hat{\\epsilon}_C, \\hat{\\sigma}_C) = (0.932087, 2.637508)$\n- Standard uncertainties: $(u_{\\epsilon,C}, u_{\\sigma,C}) = (0.001642, 0.001198)$\n\nThe computed tuples $(\\hat{\\epsilon}, \\hat{\\sigma}, u_\\epsilon, u_\\sigma)$ for each dataset are aggregated to produce the final output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef solve():\n    \"\"\"\n    Solves the nonlinear least-squares problem for three datasets by fitting\n    Lennard-Jones potential parameters and calculating their uncertainties.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Dataset A (argon-like)\",\n            \"r\": np.array([3.2, 3.4, 3.6, 3.8, 4.0, 4.5, 5.0, 5.5, 6.0]),\n            \"E\": np.array([26.904, -0.08, -8.5978, -10.52, -9.826, -6.4056, -3.7218, -2.2249, -1.3415])\n        },\n        {\n            \"name\": \"Dataset B (neon-like)\",\n            \"r\": np.array([2.6, 2.8, 3.0, 3.2, 3.6, 4.0, 5.0]),\n            \"E\": np.array([6.312, -1.349, -3.007, -2.991, -1.9225, -1.1596, -0.3246])\n        },\n        {\n            \"name\": \"Dataset C (helium-like, long-range limited coverage)\",\n            \"r\": np.array([3.0, 3.5, 4.0, 5.0, 6.5, 8.0]),\n            \"E\": np.array([-0.9006, -0.4836, -0.2481, -0.06524, -0.015158, -0.004077])\n        }\n    ]\n\n    all_results = []\n\n    def lj_potential(r, epsilon, sigma):\n        \"\"\"Calculates the Lennard-Jones potential.\"\"\"\n        ratio = sigma / r\n        return 4 * epsilon * (np.power(ratio, 12) - np.power(ratio, 6))\n\n    def residuals(params, r, E):\n        \"\"\"Calculates the residuals for the least-squares fit.\"\"\"\n        epsilon, sigma = params\n        return lj_potential(r, epsilon, sigma) - E\n\n    for case in test_cases:\n        r_data, e_data = case[\"r\"], case[\"E\"]\n        n_points = len(r_data)\n        n_params = 2\n\n        # Generate an initial guess for the parameters (epsilon, sigma)\n        min_energy = np.min(e_data)\n        epsilon_0 = -min_energy if min_energy  0 else 1.0\n        \n        # Find where energy crosses zero for sigma guess\n        sigma_0 = 3.0 # Default fallback\n        for i in range(len(e_data) - 1):\n            if e_data[i]  0 and e_data[i+1]  0:\n                # Linear interpolation for zero-crossing\n                sigma_0 = r_data[i] - e_data[i] * (r_data[i+1] - r_data[i]) / (e_data[i+1] - e_data[i])\n                break\n        else:\n            # If no zero crossing (all energies negative), use r_e__lj relationship\n            if np.all(e_data  0):\n                r_min_energy = r_data[np.argmin(e_data)]\n                sigma_0 = r_min_energy / (2**(1/6))\n        \n        initial_guess = [epsilon_0, sigma_0]\n\n        # Perform the nonlinear least-squares fit with constraints\n        # Using a small positive lower bound for numerical stability\n        bounds = ([1e-9, 1e-9], [np.inf, np.inf])\n        result = least_squares(residuals, initial_guess, args=(r_data, e_data), bounds=bounds)\n\n        # Optimal parameters\n        epsilon_hat, sigma_hat = result.x\n\n        # Calculate chi-squared\n        chi_squared = 2 * result.cost  # least_squares returns 0.5 * sum(residuals**2)\n\n        # Estimate residual variance\n        s_squared = chi_squared / (n_points - n_params)\n\n        # Jacobian matrix at the solution\n        J = result.jac\n\n        # Calculate covariance matrix using pseudoinverse for stability\n        # Cov(theta) ~ s^2 * (J^T J)^-1\n        try:\n            JTJ = J.T @ J\n            # Use pseudo-inverse for robustness, as suggested by problem context\n            inv_JTJ = np.linalg.pinv(JTJ)\n            cov_matrix = s_squared * inv_JTJ\n            \n            # Standard uncertainties are the square roots of the diagonal elements\n            u_epsilon = np.sqrt(cov_matrix[0, 0])\n            u_sigma = np.sqrt(cov_matrix[1, 1])\n        except (np.linalg.LinAlgError, ValueError):\n            # Fallback in case of singular matrix or other errors\n            u_epsilon, u_sigma = np.nan, np.nan\n\n\n        # Collect results rounded to six decimal places\n        case_results = [\n            round(epsilon_hat, 6),\n            round(sigma_hat, 6),\n            round(u_epsilon, 6),\n            round(u_sigma, 6)\n        ]\n        all_results.append(case_results)\n\n    # Format the final output string exactly as required\n    formatted_results = []\n    for res_list in all_results:\n        formatted_list = '[' + ','.join([f\"{x:.6f}\" for x in res_list]) + ']'\n        formatted_results.append(formatted_list)\n    \n    final_output = '[' + ','.join(formatted_results) + ']'\n    print(final_output)\n\nsolve()\n```", "id": "3435826"}, {"introduction": "While non-bonded potentials describe interactions between distant atoms, the structure and dynamics of molecules are largely governed by bonded terms that define their covalent architecture. Among the most important of these is the torsional potential, which dictates the energy landscape for rotation around single bonds and thus controls molecular conformation. In this exercise, you will parameterize a Fourier series representation for the dihedral potential of n-butane, a classic model system [@problem_id:3435801]. By setting up and solving a system of linear constraints based on the known energies of `trans`, `gauche`, and eclipsed conformers, you will gain insight into how these crucial force field terms are constructed to reproduce experimentally and computationally observed structural preferences.", "problem": "You are modeling the torsional potential energy of a carbon–carbon single bond in a linear alkane using a periodic Fourier series. Consider the torsion angle $\\phi$ of the $\\mathrm{C-C-C-C}$ dihedral in $n$-butane. Assume that the torsional potential is periodic with period $2\\pi$ and can be represented by a truncated Fourier series of minimal order that can differentiate between trans and gauche conformers:\n$$\nV(\\phi) \\equiv c_0 + \\sum_{n=1}^3 k_n \\cos(n\\phi - \\delta_n),\n$$\nwhere $c_0$ is a constant energy offset, $k_n \\ge 0$ are amplitudes, and $\\delta_n$ are phase shifts. All angles must be in radians and all energies must be in kilojoules per mole.\n\nUse the following foundational principles and constraints:\n- The torsional potential is a scalar function of the dihedral angle and must be $2\\pi$-periodic. A Fourier representation truncated at $n=3$ is a widely used minimal model for saturated hydrocarbon torsions.\n- Stationary points (minima and maxima) occur where the torque vanishes. The torque is the negative derivative with respect to $\\phi$, so stationary points satisfy $\\frac{dV}{d\\phi}(\\phi^\\ast)=0$.\n- The given data are relative energies of distinct conformers and barrier energies at specified angles. For $n$-butane, assume the following canonical locations for minima and maxima: trans at $\\phi=\\pi$, gauche at $\\phi=\\pi/3$ and $\\phi=5\\pi/3$, and eclipsed barriers at $\\phi=0$, $\\phi=2\\pi/3$, and $\\phi=4\\pi/3$.\n\nYour task is to compute the smallest-order Fourier model above (up to $n=3$) that reproduces the specified relative energies and barrier locations by solving a linear least squares system that enforces the following constraints:\n- Energy constraints: $V(\\pi)=0$ (reference trans minimum), $V(\\pi/3)=E_{\\mathrm{g}}$, $V(0)=E_{0}$, $V(2\\pi/3)=E_{120}$.\n- Stationarity constraints (torque-free): $V'(\\phi)=0$ at $\\phi \\in \\{\\pi, \\pi/3, 0, 2\\pi/3\\}$.\n\nTo perform the fit robustly and linearly, recast the model into Cartesian Fourier coefficients\n$$\nV(\\phi)=c_0+\\sum_{n=1}^3 \\big(A_n \\cos(n\\phi)+B_n \\sin(n\\phi)\\big),\n$$\nand enforce the above constraints as linear equations in the unknowns $\\{c_0,A_1,B_1,A_2,B_2,A_3,B_3\\}$. After solving for $\\{A_n,B_n\\}$, convert to amplitude–phase parameters via $k_n=\\sqrt{A_n^2+B_n^2}$ and $\\delta_n=\\mathrm{atan2}(B_n,A_n)$, and report the minimal set by zeroing out any amplitude smaller than a tolerance of $10^{-6}$ in kilojoules per mole and setting its corresponding phase to $0$. Report $\\delta_n$ in radians in the principal value range $[-\\pi,\\pi)$.\n\nNumerical requirements:\n- Use radians for all angles.\n- Use kilojoules per mole for all energies.\n- Round all reported numbers to six decimal places.\n\nTest suite:\nFor each of the following three parameter sets $(E_{\\mathrm{g}},E_0,E_{120})$ in kilojoules per mole, compute and report the fitted parameters in the order $[k_1,\\delta_1,k_2,\\delta_2,k_3,\\delta_3,c_0]$:\n1. Case A (baseline): $(E_{\\mathrm{g}},E_0,E_{120})=(3.300, 21.000, 16.000)$.\n2. Case B (scaled): $(E_{\\mathrm{g}},E_0,E_{120})=(4.950, 31.500, 24.000)$.\n3. Case C (threefold symmetric edge): $(E_{\\mathrm{g}},E_0,E_{120})=(0.000, 10.000, 10.000)$.\n\nYour program should produce a single line of output containing the results as a comma-separated Python-style list of lists, one list per test case, in the exact format:\n[[k1,δ1,k2,δ2,k3,δ3,c0],[k1,δ1,k2,δ2,k3,δ3,c0],[k1,δ1,k2,δ2,k3,δ3,c0]]\nAll $k_n$ and $c_0$ must be in kilojoules per mole, and all $\\delta_n$ must be in radians. All numbers must be rounded to six decimal places.", "solution": "The problem requires us to determine the parameters of a truncated Fourier series representing the torsional potential energy of the $\\mathrm{C-C-C-C}$ dihedral in $n$-butane. The potential $V(\\phi)$ is a function of the dihedral angle $\\phi$.\n\nThe potential is modeled using a Cartesian Fourier series up to order $n=3$:\n$$\nV(\\phi) = c_0 + \\sum_{n=1}^3 \\big(A_n \\cos(n\\phi) + B_n \\sin(n\\phi)\\big)\n$$\nwhere the unknowns are the seven coefficients in the set $\\mathbf{x} = \\{c_0, A_1, B_1, A_2, B_2, A_3, B_3\\}$.\n\nWe are given a set of constraints on the potential energy and its derivative (the torque, $\\tau(\\phi) = -V'(\\phi)$) at specific angles. These constraints form a system of linear equations in the unknown coefficients.\n\nThe derivative of the potential with respect to the angle $\\phi$ is:\n$$\nV'(\\phi) = \\frac{dV}{d\\phi} = \\sum_{n=1}^3 \\big(-nA_n \\sin(n\\phi) + nB_n \\cos(n\\phi)\\big)\n$$\n\nThe constraints are as follows:\n1.  Four energy constraints at specified angles $\\phi$:\n    -   $V(\\pi) = c_0 - A_1 + A_2 - A_3 = 0$ (trans minimum reference)\n    -   $V(\\pi/3) = c_0 + A_1 \\cos(\\pi/3) + B_1 \\sin(\\pi/3) + A_2 \\cos(2\\pi/3) + B_2 \\sin(2\\pi/3) - A_3 = E_{\\mathrm{g}}$ (gauche minimum)\n    -   $V(0) = c_0 + A_1 + A_2 + A_3 = E_0$ (eclipsed barrier)\n    -   $V(2\\pi/3) = c_0 + A_1 \\cos(2\\pi/3) + B_1 \\sin(2\\pi/3) + A_2 \\cos(4\\pi/3) + B_2 \\sin(4\\pi/3) + A_3 = E_{120}$ (eclipsed barrier)\n\n2.  Four stationarity constraints, requiring the torque to be zero ($V'(\\phi) = 0$) at the locations of the minima and maxima:\n    -   $V'(\\pi) = -B_1 + 2B_2 - 3B_3 = 0$\n    -   $V'(\\pi/3) = -\\frac{\\sqrt{3}}{2}A_1 + \\frac{1}{2}B_1 - \\sqrt{3}A_2 - B_2 - 3B_3 = 0$\n    -   $V'(0) = B_1 + 2B_2 + 3B_3 = 0$\n    -   $V'(2\\pi/3) = -\\frac{\\sqrt{3}}{2}A_1 - \\frac{1}{2}B_1 + \\sqrt{3}A_2 - B_2 + 3B_3 = 0$\n\nWe have a total of $8$ linear equations for $7$ unknowns. This constitutes an overdetermined system. As specified, we must find the solution that best fits these constraints in a linear least-squares sense. This is achieved by finding the vector $\\mathbf{x}$ of coefficients that minimizes the squared Euclidean norm of the residual vector, $\\|\\mathbf{M}\\mathbf{x} - \\mathbf{b}\\|_2^2$.\n\nThe system is expressed in matrix form as $\\mathbf{M}\\mathbf{x} = \\mathbf{b}$, where $\\mathbf{x} = [c_0, A_1, B_1, A_2, B_2, A_3, B_3]^T$. The vector $\\mathbf{b}$ contains the target values from the constraints:\n$$\n\\mathbf{b} = [0, E_{\\mathrm{g}}, E_0, E_{120}, 0, 0, 0, 0]^T\n$$\nThe matrix $\\mathbf{M}$ is an $8 \\times 7$ matrix where each row corresponds to one of the constraint equations, and each column corresponds to a coefficient. Using the expressions for $V(\\phi)$ and $V'(\\phi)$ evaluated at the constraint angles, we construct $\\mathbf{M}$:\n$$\n\\mathbf{M} = \n\\begin{pmatrix}\n1  \\cos(\\pi)  \\sin(\\pi)  \\cos(2\\pi)  \\sin(2\\pi)  \\cos(3\\pi)  \\sin(3\\pi) \\\\\n1  \\cos(\\pi/3)  \\sin(\\pi/3)  \\cos(2\\pi/3)  \\sin(2\\pi/3)  \\cos(\\pi)  \\sin(\\pi) \\\\\n1  \\cos(0)  \\sin(0)  \\cos(0)  \\sin(0)  \\cos(0)  \\sin(0) \\\\\n1  \\cos(2\\pi/3)  \\sin(2\\pi/3)  \\cos(4\\pi/3)  \\sin(4\\pi/3)  \\cos(2\\pi)  \\sin(2\\pi) \\\\\n0  -\\sin(\\pi)  \\cos(\\pi)  -2\\sin(2\\pi)  2\\cos(2\\pi)  -3\\sin(3\\pi)  3\\cos(3\\pi) \\\\\n0  -\\sin(\\pi/3)  \\cos(\\pi/3)  -2\\sin(2\\pi/3)  2\\cos(2\\pi/3)  -3\\sin(\\pi)  3\\cos(\\pi) \\\\\n0  -\\sin(0)  \\cos(0)  -2\\sin(0)  2\\cos(0)  -3\\sin(0)  3\\cos(0) \\\\\n0  -\\sin(2\\pi/3)  \\cos(2\\pi/3)  -2\\sin(4\\pi/3)  2\\cos(4\\pi/3)  -3\\sin(2\\pi)  3\\cos(2\\pi)\n\\end{pmatrix}\n$$\nNumerically, the matrix $\\mathbf{M}$ is:\n$$\n\\mathbf{M} = \n\\begin{pmatrix}\n1  -1  0  1  0  -1  0 \\\\\n1  1/2  \\sqrt{3}/2  -1/2  \\sqrt{3}/2  -1  0 \\\\\n1  1  0  1  0  1  0 \\\\\n1  -1/2  \\sqrt{3}/2  -1/2  -\\sqrt{3}/2  1  0 \\\\\n0  0  -1  0  2  0  -3 \\\\\n0  -\\sqrt{3}/2  1/2  -\\sqrt{3}  -1  0  -3 \\\\\n0  0  1  0  2  0  3 \\\\\n0  -\\sqrt{3}/2  -1/2  \\sqrt{3}  -1  0  3\n\\end{pmatrix}\n$$\nThe matrix $\\mathbf{M}$ has full column rank (rank $7$), which guarantees a unique least-squares solution for $\\mathbf{x}$. This solution is formally given by $\\mathbf{x} = (\\mathbf{M}^T\\mathbf{M})^{-1}\\mathbf{M}^T\\mathbf{b}$. We will compute this numerically.\n\nAfter solving for the Cartesian coefficients $\\{c_0, A_n, B_n\\}$ for each test case, we convert them to the amplitude-phase representation $V(\\phi) \\equiv c_0 + \\sum_{n=1}^3 k_n \\cos(n\\phi - \\delta_n)$ using the relations:\n$$\nk_n = \\sqrt{A_n^2 + B_n^2}\n$$\n$$\n\\delta_n = \\mathrm{atan2}(B_n, A_n)\n$$\nThe function $\\mathrm{atan2}(y, x)$ correctly determines the quadrant of the angle. The resulting $\\delta_n$ values are in the range $(-\\pi, \\pi]$. We must ensure they are reported in the specified range $[-\\pi, \\pi)$ by mapping any value of $\\pi$ to $-\\pi$.\n\nFinally, we apply a thresholding rule: if an amplitude $k_n$ is smaller than the tolerance of $10^{-6}$ kJ/mol, we set both $k_n$ and its corresponding phase $\\delta_n$ to $0$. All results are then rounded to six decimal places for reporting.\n\nThe procedure is as follows for each test case $(E_{\\mathrm{g}}, E_0, E_{120})$:\n1.  Construct the vector $\\mathbf{b}$ with the given energy values.\n2.  Solve the linear least-squares problem $\\mathbf{M}\\mathbf{x} \\approx \\mathbf{b}$ for $\\mathbf{x}$.\n3.  Extract the coefficients $c_0, A_1, B_1, A_2, B_2, A_3, B_3$.\n4.  For $n=1, 2, 3$, compute $k_n$ and $\\delta_n$.\n5.  Apply the tolerance and phase range rules.\n6.  Collect the final parameters $[k_1, \\delta_1, k_2, \\delta_2, k_3, \\delta_3, c_0]$ and format them.\nThis deterministic procedure is implemented in the provided Python code.", "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Computes the parameters of a Fourier series for a torsional potential\n    by solving a linear least-squares problem based on energy and\n    stationarity constraints.\n    \"\"\"\n\n    # Test cases: (E_g, E_0, E_120) in kJ/mol\n    test_cases = [\n        (3.300, 21.000, 16.000),  # Case A\n        (4.950, 31.500, 24.000),  # Case B\n        (0.000, 10.000, 10.000),  # Case C\n    ]\n\n    # Angles for constraints\n    phi_vals = [np.pi, np.pi/3, 0, 2*np.pi/3]\n\n    # Construct the 8x7 matrix M based on the constraints\n    M = np.zeros((8, 7))\n    \n    # Rows 0-3: Energy constraints V(phi) = E\n    # Columns: c0, A1, B1, A2, B2, A3, B3\n    for i, phi in enumerate(phi_vals):\n        M[i, 0] = 1 # c0\n        for n in range(1, 4):\n            M[i, 2*n-1] = np.cos(n * phi) # An\n            M[i, 2*n] = np.sin(n * phi)   # Bn\n    \n    # Rows 4-7: Stationarity constraints V'(phi) = 0\n    # V'(phi) = sum(-n*An*sin(n*phi) + n*Bn*cos(n*phi))\n    for i, phi in enumerate(phi_vals):\n        # M[i+4, 0] is 0 as c0 derivative is 0\n        for n in range(1, 4):\n            M[i+4, 2*n-1] = -n * np.sin(n * phi) # An coeff\n            M[i+4, 2*n] = n * np.cos(n * phi)  # Bn coeff\n\n    all_results = []\n    \n    for E_g, E_0, E_120 in test_cases:\n        # Construct the vector b for the current case\n        b = np.array([0, E_g, E_0, E_120, 0, 0, 0, 0])\n        \n        # Solve the linear least-squares problem Mx = b\n        # `lstsq` returns the solution, residuals, rank, and singular values.\n        # We only need the solution `x`.\n        x, _, _, _ = linalg.lstsq(M, b)\n        \n        # Extract Cartesian coefficients from the solution vector x\n        c0 = x[0]\n        A = x[1::2] # A1, A2, A3\n        B = x[2::2] # B1, B2, B3\n        \n        case_params = []\n        \n        # Convert to amplitude-phase form and apply rules\n        tolerance = 1e-6\n        for n in range(3):\n            An, Bn = A[n], B[n]\n            \n            kn = np.sqrt(An**2 + Bn**2)\n            \n            if kn  tolerance:\n                kn = 0.0\n                deltan = 0.0\n            else:\n                deltan = np.arctan2(Bn, An)\n                # Ensure delta is in [-pi, pi)\n                if np.isclose(deltan, np.pi):\n                    deltan = -np.pi\n            \n            case_params.extend([kn, deltan])\n        \n        case_params.append(c0)\n        all_results.append(case_params)\n\n    # Format the final output string\n    output_parts = []\n    for result_set in all_results:\n        formatted_set = [f\"{num:.6f}\" for num in result_set]\n        output_parts.append(f\"[{','.join(formatted_set)}]\")\n    \n    final_output_str = f\"[{','.join(output_parts)}]\"\n    print(final_output_str)\n\nsolve()\n```", "id": "3435801"}, {"introduction": "Most introductory force fields operate with fixed atomic charges, a simplification that neglects electronic polarization—the ability of an atom's electron cloud to distort in response to its environment. This advanced practice explores one way to incorporate this effect using the Drude oscillator model, where a fictitious, charged particle is harmonically tethered to an atomic core. You will analyze the stability of this sophisticated model, which involves a delicate balance between the 'bonded' spring interaction and the 'non-bonded' electrostatic forces [@problem_id:3435855]. This exercise will challenge you to derive the conditions for both the physical stability of the model itself (avoiding a 'polarization catastrophe') and the numerical stability of the time integration scheme, highlighting the profound connection between the form of the potential and the practical limits of simulation.", "problem": "Consider a polarizable ionic solid modeled with bonded and non-bonded interaction terms. Each polarizable ion is represented by a core and an attached Drude particle that carries a charge. The core is treated as a fixed point during the polarization response, and the Drude particle is bound to its core by a harmonic spring. The Drude particle responds to the local electric field primarily generated by nearby ions through non-bonded Coulomb interactions. You will analyze the stability constraints imposed on the Drude mass and the spring constant in explicit time integration under a fixed timestep.\n\nFundamental base:\n- Newton's second law $m = \\text{mass}$ and $\\mathbf{F} = m \\, d^2 \\mathbf{x}/dt^2$.\n- Hooke's law for a harmonic spring, with potential energy $U_\\text{spring} = \\tfrac{1}{2} k_D x^2$ and force $F_\\text{spring} = -k_D x$, where $x$ is the displacement of the Drude particle from the core along the line to a neighbor.\n- Coulomb's law for point charges with potential energy $U_\\text{Coulomb} = \\dfrac{q_1 q_2}{4 \\pi \\varepsilon_0 r}$; the electric field magnitude produced by a point charge is $E = \\dfrac{q}{4 \\pi \\varepsilon_0 r^2}$.\n\nScenario and definitions:\n- A single Drude particle of charge $-q_D$ is attached to an ionic core. A neighboring ion with charge $Q$ is located at a center-to-center distance $r$ along the same line as the Drude displacement.\n- The local electric field magnitude at the Drude particle due to the neighbor is $E = \\dfrac{Q}{4 \\pi \\varepsilon_0 r^2}$.\n- The static polarization displacement magnitude $d$ is the scalar that satisfies the force balance between the spring and the electric force induced by the field, and the ratio $d/r$ quantifies the linear-response regime.\n- The total potential experienced by the Drude particle along the line to the neighbor is the sum of the harmonic spring and the Coulomb contribution. Linearizing the total potential about the core position yields an effective stiffness $k_\\text{eff}$ defined by the second derivative of the total energy with respect to the displacement coordinate at the linearization point. This $k_\\text{eff}$ must be strictly positive for a local minimum to exist.\n- Under explicit symplectic integration of a harmonic mode via the Velocity Verlet integrator, there exists a maximum stable timestep that depends on the natural angular frequency $\\omega = \\sqrt{k_\\text{eff}/m_D}$, where $m_D$ is the Drude mass. Stability requires a relationship between the integration timestep $\\Delta t$ and $\\omega$ that you must derive from the discrete update equations.\n\nTasks:\n1. Starting from the fundamental laws and core definitions above, derive the expression for the static polarization displacement magnitude $d$ in terms of $q_D$, $E$, and $k_D$. Use this to compute the dimensionless ratio $d/r$.\n2. Linearize the total energy about the core position along the line connecting the Drude particle to the neighboring ion. Using the Hessian of the Coulomb potential for point charges, derive the effective stiffness $k_\\text{eff}$ for the displacement coordinate and the corresponding natural angular frequency $\\omega = \\sqrt{k_\\text{eff}/m_D}$. Explicitly establish the condition on $k_D$ necessary for $k_\\text{eff}  0$ in the presence of strong Coulomb forces.\n3. Starting from the discrete update equations of the Velocity Verlet integrator for a single harmonic mode, derive the maximum stable timestep $\\Delta t_\\text{max}$ in terms of $\\omega$. Use the derived condition to determine whether a given fixed timestep $\\Delta t = 1$ fs is stable for each parameter set.\n\nPhysical and numerical units:\n- Use the International System of Units (SI) in all calculations: $r$ in meters, $k_D$ in $\\text{N/m}$, $m_D$ in kilograms, $q_D$ and $Q$ in coulombs, $\\varepsilon_0$ in $\\text{F/m}$, and $\\omega$ in $\\text{rad/s}$.\n- Express the maximum stable timestep in femtoseconds (fs) and the ratio $d/r$ as a decimal.\n- The given integration timestep is $\\Delta t = 1$ fs, which must be used to assess stability.\n\nTest suite:\nFor each test case, compute and report:\n- A boolean indicating whether $\\Delta t = 1$ fs is stable, defined as true if and only if $k_\\text{eff}  0$ and $\\Delta t  \\Delta t_\\text{max}$.\n- The maximum stable timestep $\\Delta t_\\text{max}$ in fs as a float.\n- The effective stiffness $k_\\text{eff}$ in $\\text{N/m}$ as a float.\n- The ratio $d/r$ as a float.\n\nUse the following parameter sets, where $e$ denotes the elementary charge and $\\text{amu}$ denotes atomic mass unit:\n- Case A (happy path, moderate polarization and large mass): $r = 6$ Å, $q_D = 0.6\\, e$, $Q = 1.0\\, e$, $k_D = 10$ $\\text{N/m}$, $m_D = 50$ $\\text{amu}$.\n- Case B (boundary, vanishing curvature): $r = 3$ Å, $q_D = 0.8\\, e$, $Q = 1.0\\, e$, $k_D = 13.63$ $\\text{N/m}$, $m_D = 1.0$ $\\text{amu}$.\n- Case C (near integrator stability boundary at $\\Delta t = 1$ fs): $r = 3$ Å, $q_D = 0.8\\, e$, $Q = 1.0\\, e$, $k_D = 677.63$ $\\text{N/m}$, $m_D = 0.1$ $\\text{amu}$.\n- Case D (edge, strong Coulomb destabilization at small separation): $r = 2$ Å, $q_D = 1.0\\, e$, $Q = 1.0\\, e$, $k_D = 1.0$ $\\text{N/m}$, $m_D = 1.0$ $\\text{amu}$.\n- Case E (large separation, light polarization): $r = 10$ Å, $q_D = 0.5\\, e$, $Q = 1.0\\, e$, $k_D = 1.5$ $\\text{N/m}$, $m_D = 20.0$ $\\text{amu}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to a test case and is itself a list in the form $[\\text{stable\\_boolean}, \\Delta t_\\text{max}\\ \\text{(fs)}, k_\\text{eff}\\ \\text{(N/m)}, d/r]$.\n- Example structure (not actual values): $[[\\text{True}, 123.45, 6.78, 0.012],[\\text{False}, 0.89, -1.23, 0.456],\\dots]$.", "solution": "The user-provided problem is validated as compliant with all specified criteria. It is scientifically grounded, well-posed, objective, and contains sufficient information for a unique solution. The problem requires a multi-step derivation and numerical calculation, which is a legitimate task in computational physics.\n\nThe solution proceeds in three parts as requested, deriving the necessary physical and numerical quantities.\n\nFirst, we establish the necessary physical constants in SI units, which will be used throughout the derivations and calculations.\n- Elementary charge: $e \\approx 1.602 \\times 10^{-19} \\, \\text{C}$\n- Vacuum permittivity: $\\varepsilon_0 \\approx 8.854 \\times 10^{-12} \\, \\text{F/m}$\n- Coulomb's constant: $k_e = \\frac{1}{4 \\pi \\varepsilon_0} \\approx 8.988 \\times 10^9 \\, \\text{N} \\cdot \\text{m}^2/\\text{C}^2$\n- Atomic mass unit: $\\text{amu} \\approx 1.661 \\times 10^{-27} \\, \\text{kg}$\n\n### Task 1: Static Polarization Displacement\n\nThe Drude particle, with charge $-q_D$, is subjected to an electric field generated by a neighboring ion of charge $Q$. The problem statement gives the magnitude of this field at the core's position as $E = \\frac{Q}{4 \\pi \\varepsilon_0 r^2}$. The electric force on the Drude particle has a magnitude $F_E = |-q_D|E = q_D E$. This force pulls the Drude particle away from its core.\n\nThis displacement is counteracted by a restoring harmonic spring force, given by Hooke's Law. If the particle is displaced by a\ndistance $x$ from its core, the restoring force magnitude is $F_s = k_D x$.\n\nAt static equilibrium, these two forces balance. Let the equilibrium displacement be $d$. The force balance equation is:\n$$F_s = F_E$$\n$$k_D d = q_D E$$\nSolving for the static polarization displacement $d$, we get:\n$$d = \\frac{q_D E}{k_D}$$\nSubstituting the expression for the electric field $E$:\n$$d = \\frac{q_D}{k_D} \\left( \\frac{Q}{4 \\pi \\varepsilon_0 r^2} \\right) = \\frac{q_D Q}{4 \\pi \\varepsilon_0 k_D r^2}$$\nThe problem asks for the dimensionless ratio $d/r$, which is a measure of the polarization relative to the inter-ionic distance.\n$$\\frac{d}{r} = \\frac{q_D Q}{4 \\pi \\varepsilon_0 k_D r^3}$$\nThis ratio indicates whether the system is in the linear-response regime, where $d \\ll r$.\n\n### Task 2: Effective Stiffness and Natural Frequency\n\nThe total potential energy, $U_\\text{total}(x)$, of the Drude particle displaced by a distance $x$ from its core along the line to the neighbor is the sum of the spring potential energy, $U_\\text{spring}(x)$, and the Coulomb potential energy, $U_\\text{Coulomb}(x)$.\n\nLet the core be at the origin ($x=0$) and the neighboring charge $Q$ be at a position that results in a distance $r$ from the core. We can model the displacement $x$ such that for $x0$, the Drude particle moves towards an attracting neighbor. The distance between the Drude particle (charge $-q_D$) and the neighbor (charge $Q$) becomes $r-x$. The potential energies are:\n$$U_\\text{spring}(x) = \\frac{1}{2} k_D x^2$$\n$$U_\\text{Coulomb}(x) = \\frac{(-q_D) Q}{4 \\pi \\varepsilon_0 (r-x)}$$\nThe total potential energy is:\n$$U_\\text{total}(x) = \\frac{1}{2} k_D x^2 - \\frac{q_D Q}{4 \\pi \\varepsilon_0 (r-x)}$$\nThe effective stiffness, $k_\\text{eff}$, is found by linearizing the potential energy around the core position, $x=0$. This is equivalent to finding the second derivative of the total potential energy with respect to $x$ and evaluating it at $x=0$. The linearized potential is of the form $U_\\text{total}(x) \\approx U_0 + F_0 x + \\frac{1}{2}k_\\text{eff} x^2$, where $k_\\text{eff} = U''_\\text{total}(0)$.\n\nFirst derivative:\n$$U'_\\text{total}(x) = \\frac{dU_\\text{total}}{dx} = k_D x - \\frac{q_D Q}{4 \\pi \\varepsilon_0 (r-x)^2}$$\nSecond derivative:\n$$U''_\\text{total}(x) = \\frac{d^2U_\\text{total}}{dx^2} = k_D - \\frac{2 q_D Q}{4 \\pi \\varepsilon_0 (r-x)^3}$$\nEvaluating at $x=0$:\n$$k_\\text{eff} = U''_\\text{total}(0) = k_D - \\frac{2 q_D Q}{4 \\pi \\varepsilon_0 r^3}$$\nFor the Drude oscillator to be physically stable (i.e., for the core position to be a local potential energy minimum), the effective stiffness must be positive:\n$$k_\\text{eff}  0 \\implies k_D  \\frac{2 q_D Q}{4 \\pi \\varepsilon_0 r^3}$$\nThis condition shows that the intrinsic spring constant $k_D$ must be strong enough to overcome the destabilizing curvature of the Coulomb potential. If this condition is not met, a \"polarization catastrophe\" occurs where the Drude particle is unstable at the core position.\n\nThe natural angular frequency, $\\omega$, of this effective harmonic oscillator is given by:\n$$\\omega = \\sqrt{\\frac{k_\\text{eff}}{m_D}}$$\nwhere $m_D$ is the mass of the Drude particle. This frequency is only real if $k_\\text{eff}  0$.\n\n### Task 3: Integrator Stability and Maximum Timestep\n\nThe Velocity Verlet algorithm is a common symplectic integrator for molecular dynamics. Its stability for a harmonic mode with angular frequency $\\omega$ is determined by the properties of its amplification matrix. The state vector $(x_n, v_n)$ at step $n$ is propagated to step $n+1$ by a matrix $M$.\nThe update equations are:\n$$x_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} a_n (\\Delta t)^2$$\n$$v_{n+1} = v_n + \\frac{1}{2} (a_n + a_{n+1}) \\Delta t$$\nFor a harmonic oscillator, $a = -\\omega^2 x$. Substituting this into the update equations allows one to find the amplification matrix $M$:\n$$ M = \\begin{pmatrix} 1 - \\frac{(\\omega \\Delta t)^2}{2}  \\Delta t \\\\ -\\omega^2 \\Delta t \\left(1 - \\frac{(\\omega \\Delta t)^2}{4}\\right)  1 - \\frac{(\\omega \\Delta t)^2}{2} \\end{pmatrix} $$\nFor the integration to be stable (i.e., for energy to be bounded), the magnitude of the eigenvalues of $M$ must not exceed $1$. This leads to the stability condition on the trace of the matrix: $|\\text{Tr}(M)| \\le 2$.\n$$\\text{Tr}(M) = 2 \\left(1 - \\frac{(\\omega \\Delta t)^2}{2}\\right) = 2 - (\\omega \\Delta t)^2$$\nThe stability condition becomes:\n$$|2 - (\\omega \\Delta t)^2| \\le 2$$\nThis inequality resolves to $(\\omega \\Delta t)^2 \\le 4$, or:\n$$\\omega \\Delta t \\le 2$$\nThis sets an upper limit on the integration timestep $\\Delta t$ for a given frequency $\\omega$. The maximum stable timestep, $\\Delta t_\\text{max}$, is:\n$$\\Delta t_\\text{max} = \\frac{2}{\\omega}$$\nFor a given fixed timestep $\\Delta t$, the integration is stable if $\\Delta t \\le \\Delta t_\\text{max}$. The problem specifies a strict inequality, $\\Delta t  \\Delta t_\\text{max}$.\n\nCombining all conditions, a given simulation setup is stable if and only if both the physical stability condition ($k_\\text{eff}  0$) and the numerical integrator stability condition ($\\Delta t  \\Delta t_\\text{max}$) are met.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.constants import e, epsilon_0, physical_constants\n\ndef solve():\n    \"\"\"\n    Solves the Drude oscillator stability problem for a given set of test cases.\n    \"\"\"\n    # Define physical constants in SI units\n    E_CHARGE = e  # Elementary charge in Coulombs\n    EPSILON_0 = epsilon_0  # Vacuum permittivity in F/m\n    AMU_TO_KG = physical_constants['atomic mass constant'][0]\n    ANGSTROM_TO_M = 1e-10\n    FS_TO_S = 1e-15\n    K_E = 1 / (4 * np.pi * EPSILON_0)  # Coulomb's constant\n\n    # Define the test cases\n    # Each case: (r in Å, q_D in e, Q in e, k_D in N/m, m_D in amu)\n    test_cases = [\n        # Case A: Happy path, moderate polarization and large mass\n        (6.0, 0.6, 1.0, 10.0, 50.0),\n        # Case B: Boundary, vanishing curvature\n        (3.0, 0.8, 1.0, 13.63, 1.0),\n        # Case C: Near integrator stability boundary at Δt = 1 fs\n        (3.0, 0.8, 1.0, 677.63, 0.1),\n        # Case D: Edge, strong Coulomb destabilization at small separation\n        (2.0, 1.0, 1.0, 1.0, 1.0),\n        # Case E: Large separation, light polarization\n        (10.0, 0.5, 1.0, 1.5, 20.0),\n    ]\n\n    results = []\n    given_dt_fs = 1.0\n\n    for case in test_cases:\n        r_A, qD_e, Q_e, kD_Nm, mD_amu = case\n\n        # Convert all inputs to SI units\n        r = r_A * ANGSTROM_TO_M\n        qD = qD_e * E_CHARGE\n        Q = Q_e * E_CHARGE\n        mD = mD_amu * AMU_TO_KG\n        kD = kD_Nm\n\n        # Task 2: Calculate effective stiffness k_eff\n        # k_eff = kD - (2 * qD * Q) / (4 * pi * epsilon_0 * r^3)\n        coulomb_hessian = (2 * K_E * qD * Q) / (r**3)\n        k_eff = kD - coulomb_hessian\n        \n        # Check for physical stability (k_eff  0)\n        is_physically_stable = k_eff  0\n\n        dt_max_fs = 0.0\n        is_numerically_stable = False\n\n        if is_physically_stable:\n            # Task 2 (cont.): Calculate natural angular frequency omega\n            omega = np.sqrt(k_eff / mD)\n\n            # Task 3: Calculate maximum stable timestep dt_max\n            # dt_max = 2 / omega\n            dt_max_s = 2.0 / omega\n            dt_max_fs = dt_max_s / FS_TO_S\n            \n            # Check for numerical stability (given_dt  dt_max)\n            is_numerically_stable = given_dt_fs  dt_max_fs\n\n        # Overall stability requires both physical and numerical stability\n        is_stable = is_physically_stable and is_numerically_stable\n\n        # Task 1: Calculate the ratio d/r\n        # d/r = (qD * Q) / (4 * pi * epsilon_0 * kD * r^3)\n        if kD  0:\n            d_over_r = (K_E * qD * Q) / (kD * r**3)\n        else:\n            d_over_r = float('inf')\n\n        # Format results for the current case\n        # [stable_boolean, Δt_max (fs), k_eff (N/m), d/r]\n        case_result = [is_stable, dt_max_fs, k_eff, d_over_r]\n        # Python's bool string representation is 'True' or 'False' as required\n        results.append(case_result)\n        \n    # The final print statement must produce the exact single-line format.\n    # The default str() representation of a list of lists matches the required format.\n    print(results)\n\nsolve()\n\n```", "id": "3435855"}]}