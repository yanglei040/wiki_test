{"hands_on_practices": [{"introduction": "In computational materials design, we often generate dozens of potential crystal structures for a given chemical system. The fundamental question is then: which of these are thermodynamically stable? This exercise introduces the convex hull construction, the cornerstone method for determining ground-state ($T=0 \\, \\mathrm{K}$) phase stability from a discrete set of formation energies. By implementing this geometric approach, you will gain hands-on experience in identifying stable phases and predicting the decomposition pathways of metastable ones, a crucial skill for constructing binary phase diagrams from first-principles data. [@problem_id:3464640]", "problem": "You are given two independent binary composition–energy datasets for an A–B system. Each dataset lists phases at composition $x \\in [0,1]$ with Density Functional Theory (DFT) formation energies $E$ (in $\\mathrm{eV/atom}$) referenced to the pure elements. The goal is to construct the equilibrium zero-temperature free energy envelope by convexification, compute the energy above the convex hull for every phase, and determine the decomposition products for all metastable phases.\n\nFundamental base to use:\n- At zero temperature, the relevant thermodynamic potential for phase stability at fixed composition is the internal energy (for solids, the Helmholtz free energy reduces to the internal energy), and in practice one uses DFT formation energies $E(x)$ as a proxy for the free energy.\n- The equilibrium envelope at fixed composition results from allowing mechanical mixtures of phases. For a mixture of phases at compositions $x_1, x_2, \\dots, x_n$ with nonnegative fractions $\\lambda_1, \\lambda_2, \\dots, \\lambda_n$ that sum to $1$, the accessible composition and energy satisfy $x = \\sum_{i=1}^n \\lambda_i x_i$ and $E_{\\mathrm{mix}}(x) = \\sum_{i=1}^n \\lambda_i E(x_i)$. The stable energy function is the lower convex envelope of the discrete $E(x)$ data.\n- In a binary system at zero temperature, the equilibrium mixture at a general composition $x$ involves at most two phases (Carathéodory’s theorem in one dimension), except for degenerate flat facets where three or more collinear vertices share an identical common tangent. In such degenerate cases, multiple equivalent mixtures exist.\n\nDefinitions and requirements:\n- The lower convex hull is the piecewise-linear function obtained by convexifying the set of points $\\{(x_i,E_i)\\}$; it lies at or below all points and is convex. A phase lies on the hull if its point is on the lower convex envelope; otherwise, it is metastable.\n- The energy above hull for phase $i$ is $\\Delta E_i = E_i - E_{\\mathrm{hull}}(x_i)$ in $\\mathrm{eV/atom}$.\n- For a metastable phase at composition $x_i$ strictly between two adjacent hull vertices at $x_L$ and $x_R$, the two-phase decomposition is determined by the lever rule with fractions $f_L = \\dfrac{x_R - x_i}{x_R - x_L}$ and $f_R = \\dfrac{x_i - x_L}{x_R - x_L}$.\n- Special canonical three-phase rule for degenerate flat facets: If a metastable phase has composition $x_M$ equal to a hull vertex that is an interior vertex of a flat facet consisting of three consecutive collinear hull vertices at $(x_L,E_L)$, $(x_M,E_M)$, $(x_R,E_R)$ with identical slope on both sides, then report the canonical three-phase decomposition using those three vertices with fractions\n$$\nt = \\frac{1}{2\\,(x_R - x_L)},\\quad\nc_L = t\\,(x_R - x_M),\\quad\nc_M = 1 - t\\,(x_R - x_L),\\quad\nc_R = t\\,(x_M - x_L),\n$$\nwhich yields strictly positive $c_L, c_M$, and $c_R$ that sum to $1$. In all other cases where $x_i$ equals a hull vertex, report a two-phase decomposition using the adjacent hull segment with one fraction equal to zero.\n\nAlgorithmic mandates:\n- Deduplicate identical compositions by keeping only the lowest energy per $x$ when constructing the hull; however, energies above hull and decompositions must be reported for every input phase in the original order.\n- Use a numerical tolerance for collinearity and equality checks of $\\varepsilon = 10^{-8}$ in composition and slope comparisons, and $\\tau = 10^{-12}$ for energy-above-hull stability checks.\n- All energies must be reported in $\\mathrm{eV/atom}$ rounded to six decimal places. Angles are not involved. Percentages are not involved; all fractions must be decimal numbers.\n\nTest suite:\n- Test Case $1$ (index mapping shown as the order listed, indices start at $0$):\n  - Phases:\n    - Index $0$: $x=0$, $E=0$ (pure A).\n    - Index $1$: $x=1$, $E=0$ (pure B).\n    - Index $2$: $x=0.25$, $E=-0.05$ (A$_3$B).\n    - Index $3$: $x=\\dfrac{1}{3} \\approx 0.3333333333$, $E=-0.06$ (A$_2$B).\n    - Index $4$: $x=0.5$, $E=-0.08$ (AB).\n    - Index $5$: $x=\\dfrac{2}{3} \\approx 0.6666666667$, $E=-0.07$ (AB$_2$).\n    - Index $6$: $x=0.75$, $E=-0.02$ (AB$_3$).\n    - Index $7$: $x=\\dfrac{1}{3} \\approx 0.3333333333$, $E=-0.055$ (metastable duplicate at $x=\\dfrac{1}{3}$).\n    - Index $8$: $x=0.2$, $E=0.01$ (metastable A-rich).\n- Test Case $2$ (indices start at $0$ for this case):\n  - Phases:\n    - Index $0$: $x=0$, $E=0$ (pure A).\n    - Index $1$: $x=1$, $E=0$ (pure B).\n    - Index $2$: $x=0.5$, $E=0$ (stable intermediate).\n    - Index $3$: $x=0.25$, $E=0.02$ (metastable).\n    - Index $4$: $x=0.75$, $E=0.01$ (metastable).\n    - Index $5$: $x=0.5$, $E=0.0001$ (metastable duplicate at $x=0.5$).\n\nRequired outputs for each test case:\n- For each test case, produce a pair of lists $[L_{\\Delta E}, L_{\\mathrm{dec}}]$.\n  - $L_{\\Delta E}$ is the list of energies above hull for all phases in the input order, each rounded to six decimal places in $\\mathrm{eV/atom}$.\n  - $L_{\\mathrm{dec}}$ is the list of decomposition products for all phases in the input order, where each entry is:\n    - An empty list $[\\,]$ if the phase lies on the convex hull (stable) within tolerance.\n    - A two-phase list $[i_L, f_L, i_R, f_R]$ of integers and floats for metastable phases that decompose into two hull vertices at indices $i_L$ and $i_R$ with fractions $f_L$ and $f_R$, respectively.\n    - A three-phase list $[i_L, f_L, i_M, f_M, i_R, f_R]$ for the special canonical three-phase case described above, with indices $i_L$, $i_M$, and $i_R$ of the three collinear hull vertices and fractions $f_L$, $f_M$, and $f_R$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets with no spaces. Concretely, the two test case results must be aggregated into one top-level list in the form\n$[ \\text{result\\_case\\_1}, \\text{result\\_case\\_2} ]$\nwhere each $\\text{result\\_case\\_k}$ is itself the pair $[L_{\\Delta E}, L_{\\mathrm{dec}}]$ as specified. All numbers must be printed as plain decimals; indexing is by integer positions defined above. For example, the printed structure must look like $[[\\dots],[\\dots]]$ with no spaces anywhere.", "solution": "The user has provided a computational materials science problem that requires determining phase stability at zero temperature for a binary system. This involves constructing the lower convex hull of a set of formation energy data points, calculating the energy above the hull for each phase, and identifying the decomposition products for any metastable phases.\n\n### Step 1: Problem Validation\n\nI will first validate the problem statement against the required criteria.\n\n**Givens Extraction:**\n-   **System**: A binary A-B system at $T=0\\,K$.\n-   **Data**: Two sets of phases, each defined by a composition $x \\in [0,1]$ and a DFT formation energy $E$ in $\\mathrm{eV/atom}$.\n-   **Thermodynamic Principle**: At $T=0\\,K$, the stable energy as a function of composition, $E_{\\mathrm{hull}}(x)$, is the lower convex envelope of the discrete set of formation energies $\\{(x_i, E_i)\\}$.\n-   **Energy Above Hull**: For a given phase $i$ with energy $E_i$ at composition $x_i$, the energy above hull is $\\Delta E_i = E_i - E_{\\mathrm{hull}}(x_i)$.\n-   **Two-Phase Decomposition**: A metastable phase at $(x_i, E_i)$ where $x_L  x_i  x_R$ for adjacent hull vertices $L$ and $R$, decomposes into those two phases. The fractions are given by the lever rule: $f_L = \\frac{x_R - x_i}{x_R - x_L}$ and $f_R = \\frac{x_i - x_L}{x_R - x_L}$.\n-   **Canonical Three-Phase Decomposition**: A special rule applies if a metastable phase's composition $x_M$ matches that of an interior hull vertex of a three-vertex collinear facet defined by $(x_L,E_L), (x_M,E_M), (x_R,E_R)$. The decomposition products are these three hull vertices with fractions given by the provided formulas: $t = \\frac{1}{2\\,(x_R - x_L)}$, $c_L = t\\,(x_R - x_M)$, $c_M = 1 - t\\,(x_R - x_L)$, $c_R = t\\,(x_M - x_L)$.\n-   **Other Decomposition Cases**: If a phase's composition matches a hull vertex but the three-phase rule does not apply, a two-phase decomposition is reported, which naturally results from the lever rule with one fraction being zero or one.\n-   **Algorithmic Rules**:\n    1.  When building the convex hull, use only the lowest-energy phase for any given composition.\n    2.  Report results ($\\Delta E_i$ and decomposition) for all input phases in their original order.\n    3.  Use a numerical tolerance $\\varepsilon = 10^{-8}$ for composition and slope equality checks.\n    4.  Use a numerical tolerance $\\tau = 10^{-12}$ for determining stability (i.e., a phase is stable if $\\Delta E_i  \\tau$).\n    5.  Report energies rounded to six decimal places.\n\n**Validation Assessment:**\n-   **Scientific Grounding**: The problem is fundamentally sound. The use of the convex hull construction on formation energies is a cornerstone of computational thermodynamics for predicting ground-state phase stability in materials. All principles cited are standard in the field.\n-   **Well-Posedness**: The problem is well-posed. The inputs, required outputs, and the algorithm constraints are specified with high precision. Ambiguities are resolved by explicit rules, such as the handling of duplicate compositions, the specific canonical three-phase decomposition, and numerical tolerances. This detailed specification ensures a unique solution can be algorithmically determined.\n-   **Objectivity**: The problem statement is objective, using formal and quantitative language devoid of subjectivity or opinion.\n\nThe problem does not exhibit any of the listed invalidity flaws (e.g., scientific unsoundness, incompleteness, contradiction, or vagueness).\n\n**Verdict**: The problem is valid.\n\n### Step 2: Solution Algorithm Design\n\nI will design an algorithm based on the validated problem statement. The overall process for each test case is as follows:\n\n1.  **Preprocessing**:\n    -   Store the input phases along with their original indices, for instance, as a list of tuples `(x, E, original_index)`.\n    -   To prepare for hull construction, create a working set of points. Iterate through the input phases and, for each unique composition $x$, retain only the phase with the minimum energy $E$. This can be efficiently done using a dictionary. This working set will also store the original index of the lowest-energy phase at each composition.\n\n2.  **Convex Hull Construction**:\n    -   Sort the deduplicated working set of points by composition $x$ in ascending order.\n    -   Construct the lower convex hull of these points. A standard method like the Monotone Chain algorithm (or Andrew's algorithm) is suitable. It processes the sorted points and maintains a list of vertices for the lower hull, ensuring that each new point added maintains the convexity property (a \"left turn\" or collinear extension).\n    -   The convexity check for three points $p_1(x_1, E_1)$, $p_2(x_2, E_2)$, and $p_3(x_3, E_3)$ sorted by $x$ involves comparing the slope of segment $(p_1, p_2)$ to that of $(p_2, p_3)$. For a lower convex hull, the slope must be non-decreasing. To avoid floating-point division issues, a cross-product-based check is more robust: $(x_2 - x_1)(E_3 - E_2) - (E_2 - E_1)(x_3 - x_2) \\ge -tol$, where $tol$ is a scaled tolerance derived from $\\varepsilon$. Points that violate this condition (create a \"right turn\") are removed from the hull. The resulting list of points constitutes the vertices of the lower convex hull.\n\n3.  **Calculation of $\\Delta E$ and Decompositions**:\n    -   Iterate through all original input phases, in their initial order.\n    -   For each phase $i$ at $(x_i, E_i)$:\n        a.  **Find Hull Energy**: Determine the energy on the convex hull at composition $x_i$, denoted $E_{\\mathrm{hull}}(x_i)$. This requires finding the two adjacent hull vertices, $(x_L, E_L)$ and $(x_R, E_R)$, that bracket $x_i$ (i.e., $x_L \\le x_i \\le x_R$). This can be done efficiently using `numpy.searchsorted` on the x-coordinates of the hull vertices. $E_{\\mathrm{hull}}(x_i)$ is then found by linear interpolation between these two vertices.\n        b.  **Calculate $\\Delta E_i$**: Compute the energy above the hull as $\\Delta E_i = E_i - E_{\\mathrm{hull}}(x_i)$.\n        c.  **Determine Stability and Decomposition**:\n            -   If $\\Delta E_i  \\tau$ (with $\\tau=10^{-12}$), the phase is stable. Its decomposition product is an empty list.\n            -   If $\\Delta E_i \\geq \\tau$, the phase is metastable. Its decomposition must be determined:\n                i.  **Check for Special 3-Phase Case**: This case applies if the phase's composition $x_i$ matches the composition $x_M$ of a hull vertex (within tolerance $\\varepsilon$), and this hull vertex is an interior point of a three-vertex collinear segment on the hull. This is checked by finding the hull vertex $H_M$ at $x_M \\approx x_i$ and checking if its neighbors $H_L$ and $H_R$ are collinear with it (i.e., $|slope(H_L, H_M) - slope(H_M, H_R)|  \\varepsilon$). If so, the decomposition is into these three phases ($H_L, H_M, H_R$) with fractions calculated using the special formulas provided.\n                ii. **Default 2-Phase Case**: If the special 3-phase condition is not met, the decomposition is into the two hull vertices $(x_L, E_L)$ and $(x_R, E_R)$ that define the hull segment below $(x_i, E_i)$. The fractions are calculated using the lever rule. This case naturally handles phases whose compositions coincide with a hull vertex but do not meet the collinearity criterion; the lever rule will yield one fraction as $1.0$ and the other as $0.0$.\n\n4.  **Output Formatting**:\n    -   Collect the calculated $\\Delta E_i$ values for all phases, rounding each to six decimal places.\n    -   Collect the decomposition information for all phases.\n    -   Format these two lists into the specified pair format `[L_delta_E, L_dec]`.\n    -   Aggregate the results from all test cases into a single list and print as a compact JSON-like string with no whitespace, as per the problem's strict formatting requirements.", "answer": "```python\nimport numpy as np\nimport sys\nfrom typing import List, Tuple, Dict, Any\n\n# Define global constants from the problem statement\nEPS_COMP_SLOPE = 1e-8\nTAU_ENERGY = 1e-12\n\ndef process_case(phases_data: List[Tuple[float, float]]) - List[Any]:\n    \"\"\"\n    Processes a single test case to find energies above hull and decompositions.\n    \"\"\"\n    # Augment phases with their original index\n    phases_with_indices = [(x, E, i) for i, (x, E) in enumerate(phases_data)]\n\n    # 1. Preprocessing: Deduplicate by composition, keeping the lowest energy phase\n    lowest_energy_at_x: Dict[float, Tuple[float, float, int]] = {}\n    for x, E, i in phases_with_indices:\n        # Use a tolerance for composition keying\n        rounded_x = round(x / EPS_COMP_SLOPE) * EPS_COMP_SLOPE\n        if rounded_x not in lowest_energy_at_x or E  lowest_energy_at_x[rounded_x][1]:\n            lowest_energy_at_x[rounded_x] = (x, E, i)\n\n    points_for_hull = sorted(lowest_energy_at_x.values(), key=lambda p: p[0])\n\n    # 2. Convex Hull Construction (Andrew's monotone chain for lower hull)\n    hull: List[Tuple[float, float, int]] = []\n    for p in points_for_hull:\n        while len(hull) = 2:\n            p1, p2 = hull[-2], hull[-1]\n            # Cross-product check for right turn (pop if so)\n            # (x2-x1)*(y3-y2) - (y2-y1)*(x3-x1)  tolerance\n            # Using scaled tolerance for cross-product\n            # Check if slope(p1,p2)  slope(p2,p)\n            x1, E1, _ = p1\n            x2, E2, _ = p2\n            x3, E3, _ = p\n            # Avoid division by zero if compositions are identical (should not happen after dedupe)\n            if abs(x2-x1)  EPS_COMP_SLOPE or abs(x3-x2)  EPS_COMP_SLOPE:\n                break # Cannot determine slope, keep point\n            if (E2 - E1) * (x3 - x2)  (E3 - E2) * (x2 - x1) + EPS_COMP_SLOPE * (x2 - x1) * (x3 - x2):\n                hull.pop()\n            else:\n                break\n        hull.append(p)\n        \n    hull_x = np.array([p[0] for p in hull])\n    hull_E = np.array([p[1] for p in hull])\n    hull_indices = [p[2] for p in hull]\n\n    # 3. Calculate Delta_E and Decompositions for all original phases\n    L_delta_E: List[float] = []\n    L_dec: List[List] = []\n\n    for i, (xi, Ei) in enumerate(phases_data):\n        # Find hull segment [L, R] that brackets xi\n        idx_R = np.searchsorted(hull_x, xi, side='right')\n        # Handle edge cases where xi is an endpoint\n        if idx_R == len(hull_x):\n            idx_R = len(hull_x) - 1\n        if idx_R == 0:\n            idx_R = 1\n        \n        idx_L = idx_R - 1\n        \n        x_L, E_L, i_L = hull[idx_L]\n        x_R, E_R, i_R = hull[idx_R]\n\n        # Calculate E_hull(xi) by linear interpolation\n        if abs(x_R - x_L)  EPS_COMP_SLOPE: # Vertical segment or point\n            E_hull_i = E_L if xi = x_L else E_R\n        else:\n            E_hull_i = E_L + (E_R - E_L) * (xi - x_L) / (x_R - x_L)\n        \n        delta_E = Ei - E_hull_i\n        L_delta_E.append(delta_E)\n\n        # Determine stability and decomposition\n        if delta_E  TAU_ENERGY:\n            L_dec.append([])\n            continue\n\n        # Metastable phase: check for 3-phase rule\n        is_3_phase = False\n        try:\n            # Find if xi matches a hull vertex composition\n            match_idx = np.where(np.abs(hull_x - xi)  EPS_COMP_SLOPE)[0]\n            if len(match_idx)  0:\n                j = match_idx[0]\n                if 0  j  len(hull) - 1:\n                    # Check for collinearity of H[j-1], H[j], H[j+1]\n                    x_prev, E_prev, _ = hull[j-1]\n                    x_mid, E_mid, _ = hull[j]\n                    x_next, E_next, _ = hull[j+1]\n\n                    s1 = (E_mid - E_prev) / (x_mid - x_prev)\n                    s2 = (E_next - E_mid) / (x_next - x_mid)\n                    \n                    if abs(s1 - s2)  EPS_COMP_SLOPE:\n                        is_3_phase = True\n                        i_L3, i_M3, i_R3 = hull[j-1][2], hull[j][2], hull[j+1][2]\n                        t = 1.0 / (2.0 * (x_next - x_prev))\n                        c_L = t * (x_next - x_mid)\n                        c_M = 1.0 - t * (x_next - x_prev)\n                        c_R = t * (x_mid - x_prev)\n                        L_dec.append([i_L3, c_L, i_M3, c_M, i_R3, c_R])\n        except (ValueError, IndexError, ZeroDivisionError):\n            pass\n\n        if not is_3_phase:\n            # Standard 2-phase decomposition\n            if abs(x_R - x_L)  EPS_COMP_SLOPE: # Should not happen for metastable point\n                 f_L, f_R = (1.0, 0.0) if xi = x_L else (0.0, 1.0)\n            else:\n                f_R = (xi - x_L) / (x_R - x_L)\n                f_L = 1.0 - f_R\n            L_dec.append([i_L, f_L, i_R, f_R])\n\n    return [L_delta_E, L_dec]\n\ndef format_result(result_pair: List[Any]) - str:\n    \"\"\"Formats the result pair into the required string representation.\"\"\"\n    l_de = result_pair[0]\n    l_dec = result_pair[1]\n\n    # Format L_delta_E with 6 decimal places\n    de_strs = [f\"{x:.6f}\" for x in l_de]\n    de_str = f\"[{','.join(de_strs)}]\"\n\n    # Format L_dec\n    dec_item_strs = []\n    for item in l_dec:\n        if not item:\n            dec_item_strs.append(\"[]\")\n        else:\n            sub_items = []\n            for sub_item in item:\n                if isinstance(sub_item, int):\n                    sub_items.append(str(sub_item))\n                else: # float\n                    sub_items.append(repr(sub_item))\n            dec_item_strs.append(f\"[{','.join(sub_items)}]\")\n    dec_str = f\"[{','.join(dec_item_strs)}]\"\n\n    return f\"[{de_str},{dec_str}]\"\n    \ndef solve():\n    \"\"\"\n    Main function to run test cases and print output.\n    \"\"\"\n    # Define test cases from the problem statement\n    test_cases = [\n        [\n            (0.0, 0.0), (1.0, 0.0), (0.25, -0.05), (1/3, -0.06), \n            (0.5, -0.08), (2/3, -0.07), (0.75, -0.02), (1/3, -0.055),\n            (0.2, 0.01)\n        ],\n        [\n            (0.0, 0.0), (1.0, 0.0), (0.5, 0.0), (0.25, 0.02),\n            (0.75, 0.01), (0.5, 0.0001)\n        ]\n    ]\n\n    results_as_strings = []\n    for case_data in test_cases:\n        result = process_case(case_data)\n        results_as_strings.append(format_result(result))\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n\n```", "id": "3464640"}, {"introduction": "While ground-state analysis is foundational, real-world materials exist at finite temperatures where entropy becomes critical. This practice moves beyond static energies to the modeling of the temperature-dependent Helmholtz free energy, $F(T) = E - TS$. You will learn to construct $F(T)$ by incorporating quantum harmonic vibrational contributions and, for disordered systems, the configurational entropy arising from an enumeration of distinct \"inherent structures.\" This exercise offers a deep dive into the statistical mechanical origins of stability, culminating in the prediction of a temperature-driven crossover between a crystalline and an amorphous phase. [@problem_id:3464555]", "problem": "You are asked to programmatically construct the temperature-dependent Helmholtz free energy $F(T)$ of an amorphous phase using an inherent-structure enumeration model that includes both harmonic vibrational and configurational contributions, and to compare it with a crystalline phase free energy to predict the glass–crystal crossover. Work within the canonical ensemble and the harmonic approximation. The derivation must start from the canonical partition function, harmonic oscillator energy levels, and standard definitions of thermodynamic potentials. All quantities must be handled per atom and expressed in precise physical units.\n\nFundamental base to use:\n- The canonical partition function $Z$ for a system with discrete microstates.\n- The definition of Helmholtz free energy $F(T)$ as $F(T) = -k_{\\mathrm{B}} T \\ln Z$, where $k_{\\mathrm{B}}$ is the Boltzmann constant.\n- The energy levels of a quantum harmonic oscillator with angular frequency $\\omega$: $\\epsilon_n = \\hbar \\omega \\left(n + \\tfrac{1}{2}\\right)$, where $\\hbar$ is the reduced Planck constant.\n- The vibrational partition function of independent harmonic modes and its relation to thermodynamic potentials.\n\nModeling assumptions to implement:\n- The crystalline phase is represented by a single inherent structure with energy per atom $E_{\\mathrm{c}}$ and a set of per-atom harmonic vibrational mode frequencies $\\{f_{\\mathrm{c},j}\\}$ in terahertz (THz). The crystalline free energy per atom is the sum of the inherent structure energy and the harmonic vibrational free energy.\n- The amorphous phase is represented by a finite enumeration of distinct inherent structures indexed by $i$, each with energy per atom $E_i$, an integer degeneracy $g_i$ (dimensionless, accounting for configurational multiplicity), and a set of per-atom harmonic vibrational mode frequencies $\\{f_{i,j}\\}$ in THz. The total partition function is a weighted sum over inherent structures, and the amorphous free energy per atom is given by the canonical definition using that partition function.\n- Harmonic vibrational contributions must be treated quantum mechanically for each mode, including the zero-point energy.\n\nRequired units:\n- Temperature $T$ in kelvins (K).\n- Energies in electronvolts per atom (eV/atom).\n- Frequencies in terahertz (THz). Convert to angular frequency in radians per second using $\\omega = 2\\pi f$ with $f$ in hertz.\n\nComputational tasks:\n- Implement a function that computes the per-atom harmonic vibrational free energy for a given set of modes $\\{\\omega_j\\}$ at temperature $T$, including zero-point energy.\n- Implement the crystalline free energy per atom $F_{\\mathrm{cryst}}(T)$ as inherent structure energy plus vibrational free energy.\n- Implement the amorphous free energy per atom $F_{\\mathrm{amorph}}(T)$ using inherent structure enumeration with degeneracy weights in the partition sum.\n- For each test case, compute the crossover temperature $T_{\\times}$ in kelvins at which $F_{\\mathrm{amorph}}(T) - F_{\\mathrm{cryst}}(T) = 0$ within a specified temperature interval $[T_{\\min}, T_{\\max}]$. If no sign change occurs on $[T_{\\min}, T_{\\max}]$, report $T_{\\times} = -1.0$.\n- For each test case, compute the free energy difference $\\Delta F(300\\,\\mathrm{K}) = F_{\\mathrm{amorph}}(300\\,\\mathrm{K}) - F_{\\mathrm{cryst}}(300\\,\\mathrm{K})$ in eV/atom.\n- For each test case, compute stability flags $S_{\\mathrm{low}}$ and $S_{\\mathrm{high}}$, where $S_{\\mathrm{low}} = 1$ if $F_{\\mathrm{amorph}}(T_{\\min})  F_{\\mathrm{cryst}}(T_{\\min})$ and $S_{\\mathrm{high}} = 1$ if $F_{\\mathrm{amorph}}(T_{\\max})  F_{\\mathrm{cryst}}(T_{\\max})$; otherwise set the corresponding flag to $0$.\n\nNumerical and algorithmic requirements:\n- Use a robust root-finding approach to locate $T_{\\times}$ when a sign change is detected, with a bracketing method followed by a one-dimensional solver.\n- Treat vibrational free energies with care at low temperatures to avoid numerical issues; include zero-point energy explicitly.\n- Round $T_{\\times}$ to one decimal place (in K) and $\\Delta F(300\\,\\mathrm{K})$ to six decimal places (in eV/atom). The stability flags are integers.\n- Physical constants must be used in electronvolt units: $k_{\\mathrm{B}} = 8.617333262\\times 10^{-5}\\ \\mathrm{eV/K}$ and $\\hbar = 6.582119569\\times 10^{-16}\\ \\mathrm{eV\\cdot s}$.\n\nTest suite:\n- Case 1 (happy path, expected crossover in range):\n  - $T_{\\min} = 1.0\\ \\mathrm{K}$, $T_{\\max} = 1500.0\\ \\mathrm{K}$.\n  - Crystalline: $E_{\\mathrm{c}} = -3.200\\ \\mathrm{eV/atom}$, $f_{\\mathrm{c}} = [8.0, 6.0, 4.0]\\ \\mathrm{THz}$.\n  - Amorphous structures:\n    - $E_1 = -3.180\\ \\mathrm{eV/atom}$, $g_1 = 50$, $f_1 = [7.5, 5.5, 3.8]\\ \\mathrm{THz}$.\n    - $E_2 = -3.150\\ \\mathrm{eV/atom}$, $g_2 = 200$, $f_2 = [6.2, 4.5, 2.8]\\ \\mathrm{THz}$.\n    - $E_3 = -3.140\\ \\mathrm{eV/atom}$, $g_3 = 500$, $f_3 = [5.8, 4.0, 2.5]\\ \\mathrm{THz}$.\n- Case 2 (no crossover expected in range):\n  - $T_{\\min} = 1.0\\ \\mathrm{K}$, $T_{\\max} = 1500.0\\ \\mathrm{K}$.\n  - Crystalline: $E_{\\mathrm{c}} = -3.220\\ \\mathrm{eV/atom}$, $f_{\\mathrm{c}} = [8.5, 6.5, 4.5]\\ \\mathrm{THz}$.\n  - Amorphous structures:\n    - $E_1 = -3.100\\ \\mathrm{eV/atom}$, $g_1 = 10$, $f_1 = [7.0, 5.0, 3.0]\\ \\mathrm{THz}$.\n    - $E_2 = -3.080\\ \\mathrm{eV/atom}$, $g_2 = 20$, $f_2 = [6.5, 4.7, 2.9]\\ \\mathrm{THz}$.\n- Case 3 (boundary case, crossover near upper end of range):\n  - $T_{\\min} = 1.0\\ \\mathrm{K}$, $T_{\\max} = 1200.0\\ \\mathrm{K}$.\n  - Crystalline: $E_{\\mathrm{c}} = -3.205\\ \\mathrm{eV/atom}$, $f_{\\mathrm{c}} = [7.2, 5.2, 3.6]\\ \\mathrm{THz}$.\n  - Amorphous structures:\n    - $E_1 = -3.190\\ \\mathrm{eV/atom}$, $g_1 = 20$, $f_1 = [6.8, 5.0, 3.5]\\ \\mathrm{THz}$.\n    - $E_2 = -3.180\\ \\mathrm{eV/atom}$, $g_2 = 120$, $f_2 = [6.1, 4.6, 3.1]\\ \\mathrm{THz}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case contributes a list of four values $[T_{\\times}, \\Delta F(300\\,\\mathrm{K}), S_{\\mathrm{low}}, S_{\\mathrm{high}}]$, so the final output must be a list of these lists, for example: \"[[T1,DF1,S1_low,S1_high],[T2,DF2,S2_low,S2_high],[T3,DF3,S3_low,S3_high]]\". Ensure $T_{\\times}$ is rounded to one decimal place and $\\Delta F(300\\,\\mathrm{K})$ is rounded to six decimals, with the flags as integers.", "solution": "The problem statement has been critically validated and is deemed valid. It is scientifically grounded in statistical mechanics, well-posed with sufficient data and clear objectives, and formalizable into a solvable computational problem. All provided information is consistent and unambiguous.\n\nThe task is to compute and compare the Helmholtz free energy $F(T)$ for crystalline and amorphous phases of a material to find their crossover temperature $T_{\\times}$. The model is based on the inherent structure formalism, using the harmonic approximation for vibrational contributions.\n\nThe derivation begins with fundamental principles of canonical ensemble statistical mechanics. The Helmholtz free energy $F$ is defined through the canonical partition function $Z$ as $F = -k_{\\mathrm{B}} T \\ln Z$, where $k_{\\mathrm{B}}$ is the Boltzmann constant and $T$ is the temperature.\n\n**1. Vibrational Free Energy from a Quantum Harmonic Oscillator**\n\nThe energy levels of a single quantum harmonic oscillator with angular frequency $\\omega$ are given by:\n$$ \\epsilon_n = \\hbar \\omega \\left(n + \\frac{1}{2}\\right), \\quad n = 0, 1, 2, \\dots $$\nwhere $\\hbar$ is the reduced Planck constant. The partition function $z_{\\text{vib}}$ for this single mode is the sum over its energy states:\n$$ z_{\\text{vib}}(\\omega, T) = \\sum_{n=0}^{\\infty} e^{-\\epsilon_n / (k_{\\mathrm{B}} T)} = \\sum_{n=0}^{\\infty} e^{-\\frac{\\hbar \\omega}{k_{\\mathrm{B}} T}\\left(n + \\frac{1}{2}\\right)} $$\nFactoring out the zero-point energy term and recognizing the geometric series, we get:\n$$ z_{\\text{vib}}(\\omega, T) = e^{-\\frac{\\hbar \\omega}{2 k_{\\mathrm{B}} T}} \\sum_{n=0}^{\\infty} \\left(e^{-\\frac{\\hbar \\omega}{k_{\\mathrm{B}} T}}\\right)^n = \\frac{e^{-\\frac{\\hbar \\omega}{2 k_{\\mathrm{B}} T}}}{1 - e^{-\\frac{\\hbar \\omega}{k_{\\mathrm{B}} T}}} $$\nThe free energy contribution from this single mode is then:\n$$ F_{\\text{vib}}(\\omega, T) = -k_{\\mathrm{B}} T \\ln z_{\\text{vib}}(\\omega, T) = -k_{\\mathrm{B}} T \\left( -\\frac{\\hbar \\omega}{2 k_{\\mathrm{B}} T} - \\ln\\left(1 - e^{-\\frac{\\hbar \\omega}{k_{\\mathrm{B}} T}}\\right) \\right) $$\n$$ F_{\\text{vib}}(\\omega, T) = \\frac{\\hbar \\omega}{2} + k_{\\mathrm{B}} T \\ln\\left(1 - e^{-\\frac{\\hbar \\omega}{k_{\\mathrm{B}} T}}\\right) $$\nThe first term, $\\frac{\\hbar \\omega}{2}$, is the temperature-independent zero-point energy (ZPE). The second is the thermal contribution. For a set of independent modes $\\{\\omega_j\\}$ associated with one atom, the per-atom vibrational free energy $F_{\\text{vib}}^{\\text{atom}}$ is the sum of individual contributions:\n$$ F_{\\text{vib}}^{\\text{atom}}(\\{\\omega_j\\}, T) = \\sum_j F_{\\text{vib}}(\\omega_j, T) = \\sum_j \\left( \\frac{\\hbar \\omega_j}{2} + k_{\\mathrm{B}} T \\ln\\left(1 - e^{-\\frac{\\hbar \\omega_j}{k_{\\mathrm{B}} T}}\\right) \\right) $$\nThe input frequencies $f_j$ in terahertz ($1\\ \\text{THz} = 10^{12}\\ \\text{Hz}$) are converted to angular frequencies via $\\omega_j = 2\\pi f_j \\times 10^{12}\\ \\text{rad/s}$.\n\n**2. Crystalline Phase Free Energy**\n\nThe crystalline phase is modeled as a single inherent structure with a potential energy per atom of $E_{\\mathrm{c}}$. Its total free energy per atom is the sum of this static lattice energy and the vibrational free energy of its modes $\\{\\omega_{\\mathrm{c},j}\\}$:\n$$ F_{\\mathrm{cryst}}^{\\text{atom}}(T) = E_{\\mathrm{c}} + F_{\\text{vib}}^{\\text{atom}}(\\{\\omega_{\\mathrm{c},j}\\}, T) $$\nThis expression follows from the partition function $Z_{\\mathrm{cryst}} = e^{-E_{\\mathrm{c}}/(k_{\\mathrm{B}}T)} \\times Z_{\\text{vib,cryst}}$, where $Z_{\\text{vib,cryst}} = \\prod_j z_{\\text{vib}}(\\omega_{\\mathrm{c},j}, T)$.\n\n**3. Amorphous Phase Free Energy**\n\nThe amorphous phase is described as a collection of distinct inherent structures, indexed by $i$. Each structure has a potential energy per atom $E_i$, a degeneracy $g_i$, and a unique set of vibrational modes $\\{\\omega_{i,j}\\}$. The total canonical partition function for the amorphous phase is the sum over all structures:\n$$ Z_{\\mathrm{amorph}} = \\sum_i g_i Z_i $$\nwhere $Z_i$ is the partition function for the subsystem of states associated with inherent structure $i$. This is given by:\n$$ Z_i = e^{-E_i / (k_{\\mathrm{B}} T)} Z_{\\text{vib},i} = e^{-E_i / (k_{\\mathrm{B}} T)} \\prod_j z_{\\text{vib}}(\\omega_{i,j}, T) $$\nThe free energy of structure $i$ is $F_i(T) = -k_{\\mathrm{B}} T \\ln Z_i = E_i + F_{\\text{vib}}^{\\text{atom}}(\\{\\omega_{i,j}\\}, T)$. We can rewrite $Z_i$ as $Z_i = e^{-F_i(T) / (k_{\\mathrm{B}} T)}$. The total partition function becomes:\n$$ Z_{\\mathrm{amorph}} = \\sum_i g_i e^{-F_i(T) / (k_{\\mathrm{B}} T)} $$\nThe total free energy per atom of the amorphous phase is then:\n$$ F_{\\mathrm{amorph}}^{\\text{atom}}(T) = -k_{\\mathrm{B}} T \\ln Z_{\\mathrm{amorph}} = -k_{\\mathrm{B}} T \\ln \\left( \\sum_i g_i e^{-F_i(T) / (k_{\\mathrm{B}} T)} \\right) $$\nFor numerical stability, especially when arguments of the exponential function are large and negative, the log-sum-exp trick is employed. Let $x_i(T) = \\ln(g_i) - F_i(T) / (k_{\\mathrm{B}} T)$. Then:\n$$ \\ln(Z_{\\mathrm{amorph}}) = \\ln \\left( \\sum_i e^{x_i(T)} \\right) = x_{\\text{max}}(T) + \\ln \\left( \\sum_i e^{x_i(T) - x_{\\text{max}}(T)} \\right) $$\nwhere $x_{\\text{max}}(T) = \\max_i \\{x_i(T)\\}$. This avoids floating-point overflow and minimizes precision loss from underflow.\n\n**4. Computational Algorithm**\n\nThe solution is implemented as a series of functions to compute the required quantities for each test case.\n- A function `harmonic_vibrational_free_energy` takes a set of frequencies (in THz) and a temperature $T$ to compute $F_{\\text{vib}}^{\\text{atom}}$. It uses the physical constants $k_{\\mathrm{B}}$ and $\\hbar$ in the specified eV-based units.\n- Functions `F_cryst` and `F_amorph` are constructed for each test case. They take temperature $T$ as input and compute the respective free energies per atom using the `harmonic_vibrational_free_energy` function and the model parameters for the specific case. The `F_amorph` function implements the numerically stable log-sum-exp method.\n- The free energy difference function is defined as $\\Delta F(T) = F_{\\mathrm{amorph}}^{\\text{atom}}(T) - F_{\\mathrm{cryst}}^{\\text{atom}}(T)$.\n- To find the crossover temperature $T_{\\times}$, we seek the root of $\\Delta F(T) = 0$. The signs of $\\Delta F(T_{\\min})$ and $\\Delta F(T_{\\max})$ are first checked. If they are different, a root is guaranteed to exist in the interval $[T_{\\min}, T_{\\max}]$. The `scipy.optimize.brentq` solver, a robust bracketing root-finding algorithm, is used to find $T_{\\times}$. If the signs are the same, no crossover is detected in the interval, and $T_{\\times}$ is set to $-1.0$.\n- The free energy difference at $T=300\\ \\text{K}$, $\\Delta F(300\\ \\text{K})$, is calculated by direct evaluation.\n- The stability flags, $S_{\\mathrm{low}}$ and $S_{\\mathrm{high}}$, are determined by the sign of $\\Delta F(T)$ at $T_{\\min}$ and $T_{\\max}$, respectively. $S=1$ if the amorphous phase is more stable (i.e., $\\Delta F  0$), and $S=0$ otherwise.\n- The final results for each test case—$T_{\\times}$, $\\Delta F(300\\ \\text{K})$, $S_{\\mathrm{low}}$, and $S_{\\mathrm{high}}$—are collected and formatted into a single output string as per the problem specification.", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves the materials thermodynamics problem for the given test cases.\n    \"\"\"\n    \n    # Physical constants in specified units\n    KB_EV_K = 8.617333262e-5  # Boltzmann constant in eV/K\n    HBAR_EV_S = 6.582119569e-16 # Reduced Planck constant in eV*s\n\n    test_cases = [\n        {\n            \"T_min\": 1.0, \"T_max\": 1500.0,\n            \"cryst\": {\"E_c\": -3.200, \"freqs\": np.array([8.0, 6.0, 4.0])},\n            \"amorph\": [\n                {\"E_i\": -3.180, \"g_i\": 50, \"freqs\": np.array([7.5, 5.5, 3.8])},\n                {\"E_i\": -3.150, \"g_i\": 200, \"freqs\": np.array([6.2, 4.5, 2.8])},\n                {\"E_i\": -3.140, \"g_i\": 500, \"freqs\": np.array([5.8, 4.0, 2.5])},\n            ]\n        },\n        {\n            \"T_min\": 1.0, \"T_max\": 1500.0,\n            \"cryst\": {\"E_c\": -3.220, \"freqs\": np.array([8.5, 6.5, 4.5])},\n            \"amorph\": [\n                {\"E_i\": -3.100, \"g_i\": 10, \"freqs\": np.array([7.0, 5.0, 3.0])},\n                {\"E_i\": -3.080, \"g_i\": 20, \"freqs\": np.array([6.5, 4.7, 2.9])},\n            ]\n        },\n        {\n            \"T_min\": 1.0, \"T_max\": 1200.0,\n            \"cryst\": {\"E_c\": -3.205, \"freqs\": np.array([7.2, 5.2, 3.6])},\n            \"amorph\": [\n                {\"E_i\": -3.190, \"g_i\": 20, \"freqs\": np.array([6.8, 5.0, 3.5])},\n                {\"E_i\": -3.180, \"g_i\": 120, \"freqs\": np.array([6.1, 4.6, 3.1])},\n            ]\n        },\n    ]\n\n    results = []\n\n    def harmonic_vibrational_free_energy(freqs_thz, T):\n        \"\"\"\n        Computes the per-atom harmonic vibrational free energy.\n        freqs_thz are in THz, T is in K.\n        Returns energy in eV/atom.\n        \"\"\"\n        if T = 0:\n            # At T=0, F_vib is just the ZPE\n            omegas = 2 * np.pi * freqs_thz * 1e12\n            hbar_omegas = HBAR_EV_S * omegas\n            return np.sum(hbar_omegas / 2.0)\n\n        omegas = 2 * np.pi * freqs_thz * 1e12  # rad/s\n        hbar_omegas = HBAR_EV_S * omegas  # eV\n        \n        # Zero-point energy contribution\n        zpe = np.sum(hbar_omegas / 2.0)\n        \n        # Thermal contribution\n        arg = hbar_omegas / (KB_EV_K * T)\n        # np.exp(-large_number) safely underflows to 0.\n        thermal_term = KB_EV_K * T * np.sum(np.log(1.0 - np.exp(-arg)))\n\n        return zpe + thermal_term\n\n    for case in test_cases:\n        \n        # Crystalline Free Energy Function\n        def F_cryst(T):\n            E_c = case[\"cryst\"][\"E_c\"]\n            freqs_c = case[\"cryst\"][\"freqs\"]\n            F_vib_c = harmonic_vibrational_free_energy(freqs_c, T)\n            return E_c + F_vib_c\n\n        # Amorphous Free Energy Function\n        def F_amorph(T):\n            if T = 0: # Handle T=0 case by calculating sum of lowest energy states\n                min_energy_struct = min(case[\"amorph\"], key=lambda s: s[\"E_i\"])\n                F_vib_min = harmonic_vibrational_free_energy(min_energy_struct[\"freqs\"], T)\n                return min_energy_struct[\"E_i\"] + F_vib_min\n            \n            F_i_list = []\n            for struct in case[\"amorph\"]:\n                E_i = struct[\"E_i\"]\n                freqs_i = struct[\"freqs\"]\n                F_vib_i = harmonic_vibrational_free_energy(freqs_i, T)\n                F_i_list.append(E_i + F_vib_i)\n\n            g_i_list = np.array([s[\"g_i\"] for s in case[\"amorph\"]])\n            F_i_array = np.array(F_i_list)\n\n            # Log-Sum-Exp for numerical stability\n            x_i = np.log(g_i_list) - F_i_array / (KB_EV_K * T)\n            x_max = np.max(x_i)\n            log_sum = x_max + np.log(np.sum(np.exp(x_i - x_max)))\n\n            return -KB_EV_K * T * log_sum\n\n        # Free Energy Difference Function\n        def delta_F(T):\n            return F_amorph(T) - F_cryst(T)\n\n        T_min, T_max = case[\"T_min\"], case[\"T_max\"]\n\n        # Calculate values at boundaries\n        delta_F_min = delta_F(T_min)\n        delta_F_max = delta_F(T_max)\n\n        # Determine stability flags\n        S_low = 1 if delta_F_min  0 else 0\n        S_high = 1 if delta_F_max  0 else 0\n\n        # Find crossover temperature\n        T_cross = -1.0\n        if delta_F_min * delta_F_max = 0: # Sign change or root at boundary\n            try:\n                T_cross = brentq(delta_F, T_min, T_max)\n            except ValueError:\n                # Should not happen due to the check, but as a safeguard.\n                T_cross = -1.0\n        \n        # Calculate free energy difference at 300 K\n        delta_F_300K = delta_F(300.0)\n        \n        # Collect results for this case\n        results.append([T_cross, delta_F_300K, S_low, S_high])\n\n    # Format the final output string\n    final_str_parts = []\n    for res in results:\n        part = f\"[{res[0]:.1f},{res[1]:.6f},{res[2]},{res[3]}]\"\n        final_str_parts.append(part)\n    \n    final_output = f\"[{','.join(final_str_parts)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3464555"}, {"introduction": "The previous practices focused on analyzing pre-computed energies. But how do we sample the vast configuration space of a material to generate its thermodynamic properties in the first place? This exercise guides you through the implementation of a semi-grand canonical Monte Carlo simulation, a powerful technique for exploring phase behavior by controlling temperature and chemical potential. You will build a simulation for a binary alloy from the ground up, use it to probe composition changes, and validate a fundamental thermodynamic identity, bridging the gap between a microscopic model Hamiltonian and macroscopic thermodynamic observables. [@problem_id:3464579]", "problem": "Consider a binary substitutional alloy on a two-dimensional square lattice of fixed size, where each lattice site is occupied by either species $A$ or species $B$. Let $s_i \\in \\{-1,+1\\}$ denote the occupancy variable of site $i$, with $s_i=-1$ representing species $A$ and $s_i=+1$ representing species $B$. The configurational energy is modeled using a nearest-neighbor interaction parameter $J$ according to the pair energy function\n$$\nE(\\{s_i\\}) = -J \\sum_{\\langle i,j\\rangle} s_i s_j,\n$$\nwhere $\\langle i,j\\rangle$ indicates nearest-neighbor pairs on the square lattice with periodic boundary conditions. Introduce the semi-grand canonical ensemble for this alloy by controlling the difference in chemical potentials $\\Delta \\mu = \\mu_B - \\mu_A$ at fixed temperature $T$ and fixed number of lattice sites $N$. The number of $B$ atoms in a configuration is given by $N_B(\\{s_i\\}) = \\frac{N + \\sum_i s_i}{2}$.\n\nYour tasks are:\n- Starting from the canonical partition function and the Helmholtz free energy definition, derive the expression for the grand canonical potential via a proper Legendre transform and show the corresponding derivative identity with respect to the chemical potential. Then adapt the derivation to the semi-grand canonical ensemble for the binary alloy, formulating the appropriate thermodynamic potential and its derivative identity with respect to $\\Delta \\mu$.\n- Implement a semi-grand Metropolis Monte Carlo (Monte Carlo (MC)) algorithm to sample configurations at fixed $T$ and $\\Delta \\mu$ with Boltzmann weight $\\exp\\left[-\\beta \\left(E(\\{s_i\\}) - \\Delta \\mu \\, N_B(\\{s_i\\})\\right)\\right]$, where $\\beta = 1/(k_B T)$ and $k_B$ is the Boltzmann constant. Use a two-dimensional square lattice with periodic boundaries and propose single-site flips $s_i \\to -s_i$; accept or reject based on the Metropolis criterion.\n- Numerically construct the semi-grand potential as a function of $\\Delta \\mu$ at fixed $T$ by integrating the ensemble average of $-\\langle N_B \\rangle$ with respect to $\\Delta \\mu$ using the trapezoid rule along a small grid in $\\Delta \\mu$, choosing the reference $\\Phi(T,\\Delta \\mu=0)=0$. Validate the derivative identity by comparing a finite-difference estimate of $\\partial \\Phi/\\partial (\\Delta \\mu)$ at $\\Delta \\mu=0$ to $-\\langle N_B \\rangle$ obtained directly from the MC simulation at $\\Delta \\mu=0$.\n\nFundamental bases you must use include:\n- The canonical partition function $Z_c(N,T,V)$ and the Helmholtz free energy definition $F(T,V,N) = -k_B T \\ln Z_c(N,T,V)$.\n- The definition of the grand canonical partition function as a sum over particle numbers, and the Legendre transform structure relating thermodynamic potentials.\n- The semi-grand canonical ensemble for a binary alloy at fixed total number of lattice sites $N$, allowing composition fluctuations controlled by $\\Delta \\mu$.\n\nImplement the program under the following scientifically realistic and self-consistent specifications:\n- Use a square lattice of linear size $L=16$ so that $N=L^2=256$ sites.\n- Use nearest-neighbor coupling $J=0.005$ electronvolts (eV). The Boltzmann constant is $k_B=8.617333262\\times 10^{-5}$ eV/K. Temperature $T$ must be in Kelvin (K) and $\\Delta \\mu$ must be in electronvolts (eV).\n- Use a Metropolis MC with periodic boundary conditions, random initial spins, and a fixed random seed for reproducibility. For each state point, perform $1200$ sweeps (one sweep attempts $N$ spin flips), discarding the first $400$ sweeps as burn-in and averaging $N_B$ over the remaining sweeps.\n- For each temperature in the test suite, evaluate the ensemble average $\\langle N_B \\rangle$ on a grid of $\\Delta \\mu$ values $\\{-0.02,-0.01,0.00,0.01,0.02\\}$ eV. Construct the semi-grand potential $\\Phi(T,\\Delta \\mu)$ along this grid with $\\Phi(T,0)=0$ by trapezoidal integration of $- \\langle N_B \\rangle$ with respect to $\\Delta \\mu$. Estimate the derivative at $\\Delta \\mu=0$ using the centered finite difference\n$$\n\\left.\\frac{\\partial \\Phi}{\\partial (\\Delta \\mu)}\\right|_{\\Delta \\mu=0} \\approx \\frac{\\Phi(T,\\Delta \\mu=+0.01\\,\\text{eV}) - \\Phi(T,\\Delta \\mu=-0.01\\,\\text{eV})}{2\\times 0.01\\,\\text{eV}}.\n$$\n- Validate the derivative identity by checking whether the absolute difference between this finite-difference derivative and $-\\langle N_B \\rangle$ at $\\Delta \\mu=0$ is less than or equal to $0.1 N$, that is, $0.1 \\times 256 = 25.6$.\n\nTest suite:\n- Temperatures $T$ in Kelvin: $[50.0,130.0,300.0]$.\n- Chemical potential difference grid $\\Delta \\mu$ in electronvolts: $\\{-0.02,-0.01,0.00,0.01,0.02\\}$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results of the three validation checks for the temperatures in the test suite as a comma-separated list enclosed in square brackets (e.g., \"[True,False,True]\"). Each entry must be a boolean corresponding to whether the validation passes at the given temperature.\n\nAll physical quantities must be in their specified units: temperature in Kelvin (K) and energies and chemical potentials in electronvolts (eV). Angles do not appear in this problem. No percentages are to be used; express any fractional quantities as decimals if needed. The final outputs are booleans as specified.", "solution": "The problem is assessed to be valid as it is scientifically grounded, well-posed, and objective. It consists of a standard theoretical derivation in statistical mechanics coupled with a numerical validation using a well-established simulation technique, the Metropolis Monte Carlo algorithm. All required parameters and conditions are specified, allowing for a unique and verifiable solution.\n\nThe solution proceeds in three stages as delineated by the problem statement:\n1.  A formal derivation of the semi-grand potential and its associated derivative identity.\n2.  An outline of the semi-grand canonical Metropolis Monte Carlo algorithm.\n3.  A description of the numerical procedure to validate the derivative identity using simulation data.\n\n**1. Theoretical Derivation of the Semi-Grand Potential**\n\nWe begin from the fundamentals of statistical mechanics, starting with the canonical ensemble for a system of two components, $A$ and $B$, with particle numbers $N_A$ and $N_B$ respectively, at a constant temperature $T$ and volume $V$. The Helmholtz free energy $F(T, V, N_A, N_B)$ is defined in terms of the canonical partition function $Z_c(T, V, N_A, N_B)$ as:\n$$\nF(T, V, N_A, N_B) = -k_B T \\ln Z_c(T, V, N_A, N_B)\n$$\nwhere $k_B$ is the Boltzmann constant. The differential of the Helmholtz free energy is given by:\n$$\ndF = -S dT - P dV + \\mu_A dN_A + \\mu_B dN_B\n$$\nwhere $S$ is entropy, $P$ is pressure, and $\\mu_k = (\\partial F / \\partial N_k)_{T,V,N_{j \\neq k}}$ is the chemical potential of species $k$.\n\nTo illustrate the Legendre transform, we first derive the grand potential $\\Omega$. We switch from controlling particle number $N$ to controlling chemical potential $\\mu$. The grand potential $\\Omega(T,V,\\mu)$ is the Legendre transform of $F(T,V,N)$ with respect to the conjugate pair $(\\mu, N)$:\n$$\n\\Omega(T,V,\\mu) = F - \\mu N\n$$\nThe differential is $d\\Omega = dF - d(\\mu N) = dF - \\mu dN - N d\\mu$. Substituting the expression for $dF$ (for a single component system), we get:\n$$\nd\\Omega = (-S dT - P dV + \\mu dN) - \\mu dN - N d\\mu = -S dT - P dV - N d\\mu\n$$\nFrom this, we obtain the derivative identity $(\\partial \\Omega / \\partial \\mu)_{T,V} = -N$.\n\nWe now adapt this procedure to the binary alloy in the problem. The total number of lattice sites $N=N_A+N_B$ is fixed, and the volume (or lattice area) is also fixed. The independent variables for the Helmholtz free energy can be chosen as $(T, N, N_B)$, since $N_A=N-N_B$. The differential of $F(T, N, N_B)$ becomes:\n$$\ndF = -S dT + \\mu_A dN_A + \\mu_B dN_B = -S dT + \\mu_A (-dN_B) + \\mu_B dN_B = -S dT + (\\mu_B - \\mu_A) dN_B\n$$\nLet us define the difference in chemical potentials as $\\Delta\\mu = \\mu_B - \\mu_A$. Then, the natural variables for $F$ are $(T, N, N_B)$ and we have the relation $(\\partial F / \\partial N_B)_{T,N} = \\Delta\\mu$.\n\nThe semi-grand canonical ensemble involves controlling $\\Delta\\mu$ instead of $N_B$. We therefore perform a Legendre transform on $F$ with respect to the conjugate pair $(\\Delta\\mu, N_B)$. The resulting thermodynamic potential is the semi-grand potential, $\\Phi(T, N, \\Delta\\mu)$:\n$$\n\\Phi(T, N, \\Delta\\mu) = F(T, N, N_B) - \\Delta\\mu \\, N_B\n$$\nIts differential is:\n$$\nd\\Phi = dF - d(\\Delta\\mu \\, N_B) = dF - N_B d(\\Delta\\mu) - \\Delta\\mu dN_B\n$$\nSubstituting the expression for $dF$:\n$$\nd\\Phi = (-S dT + \\Delta\\mu dN_B) - N_B d(\\Delta\\mu) - \\Delta\\mu dN_B = -S dT - N_B d(\\Delta\\mu)\n$$\nFrom the total differential of $\\Phi(T, N, \\Delta\\mu)$, we can identify its partial derivatives. The derivative with respect to the chemical potential difference $\\Delta\\mu$ at constant $T$ and $N$ is:\n$$\n\\left(\\frac{\\partial \\Phi}{\\partial (\\Delta\\mu)}\\right)_{T,N} = -N_B\n$$\nIn a statistical ensemble at fixed $(T, N, \\Delta\\mu)$, the macroscopic thermodynamic observables correspond to ensemble averages. Thus, the derivative of the thermodynamic potential $\\Phi$ is equal to the ensemble average of $-N_B$:\n$$\n\\left(\\frac{\\partial \\Phi}{\\partial (\\Delta\\mu)}\\right)_{T,N} = -\\langle N_B \\rangle\n$$\nThis is the central identity to be validated numerically. The semi-grand potential is related to the semi-grand canonical partition function $\\mathcal{Z}_{sgc}$ by $\\Phi = -k_B T \\ln \\mathcal{Z}_{sgc}$, where\n$$\n\\mathcal{Z}_{sgc}(T, N, \\Delta\\mu) = \\sum_{\\{s_i\\}} \\exp\\left[-\\beta \\left(E(\\{s_i\\}) - \\Delta \\mu \\, N_B(\\{s_i\\})\\right)\\right]\n$$\nsumming over all possible configurations $\\{s_i\\}$ on the fixed lattice.\n\n**2. Metropolis Monte Carlo Algorithm**\n\nThe simulation samples configurations $\\{s_i\\}$ from the semi-grand canonical ensemble using the Metropolis algorithm. The state of the system is described by an $L \\times L$ grid of spins $s_i \\in \\{-1, +1\\}$.\nThe simulation proceeds as follows:\n1.  Initialize the $L \\times L$ lattice with random values of $-1$ and $+1$.\n2.  Perform a number of Monte Carlo sweeps. A single sweep consists of $N=L^2$ Monte Carlo steps.\n3.  A single Monte Carlo step consists of:\n    a. Select a lattice site $i$ at random.\n    b. Propose a trial move, which is a spin flip: $s_i \\to s'_i = -s_i$.\n    c. Calculate the change in the effective Hamiltonian $\\mathcal{H}' = E - \\Delta\\mu N_B$. The energy is $E = -J \\sum_{\\langle k,j\\rangle} s_k s_j$ and the number of $B$ atoms is $N_B = (N + \\sum_k s_k)/2$. For a flip at site $i$, the change $\\Delta N_B = -s_i$. The change in energy is $\\Delta E = 2J s_i \\sum_{j \\in \\text{nn}(i)} s_j$, where $\\text{nn}(i)$ denotes the nearest neighbors of site $i$. The change in the effective Hamiltonian is therefore:\n    $$\n    \\Delta \\mathcal{H}' = \\Delta E - \\Delta\\mu \\Delta N_B = 2J s_i \\sum_{j \\in \\text{nn}(i)} s_j - \\Delta\\mu (-s_i) = s_i \\left(2J \\sum_{j \\in \\text{nn}(i)} s_j + \\Delta\\mu\\right)\n    $$\n    d. Accept the move with probability $p = \\min(1, \\exp(-\\beta \\Delta \\mathcal{H}'))$, where $\\beta = 1/(k_B T)$. This is done by comparing $\\exp(-\\beta \\Delta \\mathcal{H}')$ to a uniform random number in $[0,1)$. If the move is accepted, the spin $s_i$ is flipped.\n4.  The system is first equilibrated for a specified number of burn-in sweeps. After equilibration, properties such as $N_B$ are measured and averaged over a subsequent number of production sweeps to obtain the ensemble average $\\langle N_B \\rangle$.\n\n**3. Numerical Validation**\n\nThe validation task requires us to check the identity $(\\partial \\Phi / \\partial (\\Delta\\mu))_{T,N} = -\\langle N_B \\rangle$ at $\\Delta\\mu=0$.\nFirst, we numerically determine the semi-grand potential $\\Phi(T, \\Delta\\mu)$ by integrating its derivative:\n$$\n\\Phi(T, \\Delta\\mu) - \\Phi(T, \\Delta\\mu_{\\text{ref}}) = \\int_{\\Delta\\mu_{\\text{ref}}}^{\\Delta\\mu} \\left(\\frac{\\partial \\Phi}{\\partial (\\Delta\\mu')}\\right) d(\\Delta\\mu') = \\int_{\\Delta\\mu_{\\text{ref}}}^{\\Delta\\mu} (-\\langle N_B \\rangle) d(\\Delta\\mu')\n$$\nUsing the specified reference $\\Phi(T, \\Delta\\mu=0) = 0$, we have:\n$$\n\\Phi(T, \\Delta\\mu) = \\int_{0}^{\\Delta\\mu} (-\\langle N_B \\rangle_{\\Delta\\mu'}) d(\\Delta\\mu')\n$$\nThe procedure is:\n1.  For a given temperature $T$, run the Monte Carlo simulation for each $\\Delta\\mu$ in the grid $\\{-0.02, -0.01, 0.00, 0.01, 0.02\\}$ eV to obtain the corresponding values of $\\langle N_B \\rangle$.\n2.  Use the trapezoid rule to numerically evaluate the integral and find $\\Phi(T, \\Delta\\mu)$ for $\\Delta\\mu = -0.01$ eV and $\\Delta\\mu = +0.01$ eV.\n    $$\n    \\Phi(T, \\Delta\\mu=+0.01) \\approx \\frac{-\\langle N_B \\rangle_{\\Delta\\mu=0} - \\langle N_B \\rangle_{\\Delta\\mu=+0.01}}{2} \\times 0.01\n    $$\n    $$\n    \\Phi(T, \\Delta\\mu=-0.01) = -\\int_{-0.01}^{0} (-\\langle N_B \\rangle) d(\\Delta\\mu') \\approx -\\frac{-\\langle N_B \\rangle_{\\Delta\\mu=-0.01} - \\langle N_B \\rangle_{\\Delta\\mu=0}}{2} \\times 0.01\n    $$\n3.  Estimate the derivative of $\\Phi$ at $\\Delta\\mu=0$ using the provided centered finite-difference formula:\n    $$\n    \\left.\\frac{\\partial \\Phi}{\\partial (\\Delta\\mu)}\\right|_{\\Delta \\mu=0} \\approx \\frac{\\Phi(T, \\Delta \\mu=+0.01\\,\\text{eV}) - \\Phi(T, \\Delta \\mu=-0.01\\,\\text{eV})}{2\\times 0.01\\,\\text{eV}}\n    $$\n4.  Compare this finite-difference derivative (`FD_derivative`) with the right-hand side of the identity, which is $-\\langle N_B \\rangle$ evaluated directly from the simulation at $\\Delta\\mu=0$.\n5.  The validation passes if the absolute difference is within the given tolerance:\n    $$\n    \\left| \\text{FD\\_derivative} - (-\\langle N_B \\rangle_{\\Delta\\mu=0}) \\right| \\le 0.1 \\times N = 25.6\n    $$\nThis procedure is repeated for each temperature in the test suite. The result is a boolean value indicating success or failure of the validation for each temperature.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational materials science problem by:\n    1. Implementing a semi-grand canonical Metropolis Monte Carlo simulation for a binary alloy.\n    2. Simulating the system at specified temperatures and chemical potential differences.\n    3. Numerically constructing the semi-grand potential by integrating simulation results.\n    4. Validating the thermodynamic derivative identity d(Phi)/d(dmu) = -N_B.\n    \"\"\"\n    \n    # Set a fixed random seed for reproducibility\n    np.random.seed(42)\n\n    # --- System and Simulation Parameters ---\n    L = 16  # Linear size of the square lattice\n    N = L * L  # Total number of lattice sites\n    J = 0.005  # Interaction parameter in eV\n    k_B = 8.617333262e-5  # Boltzmann constant in eV/K\n\n    # Monte Carlo simulation parameters\n    total_sweeps = 1200\n    burn_in_sweeps = 400\n    production_sweeps = total_sweeps - burn_in_sweeps\n\n    # --- Test Suite Parameters ---\n    test_temperatures = [50.0, 130.0, 300.0]  # in Kelvin\n    delta_mu_grid = np.array([-0.02, -0.01, 0.00, 0.01, 0.02])  # in eV\n\n    def run_mc_simulation(T, delta_mu):\n        \"\"\"\n        Performs a single Metropolis MC simulation for a given T and delta_mu.\n        Returns the ensemble average of the number of B atoms, N_B.\n        \"\"\"\n        beta = 1.0 / (k_B * T)\n        \n        # Initialize lattice with random spins (+1 for B, -1 for A)\n        spins = np.random.choice([-1, 1], size=(L, L))\n        \n        nb_measurements = []\n\n        for sweep in range(total_sweeps):\n            for _ in range(N):\n                # 1. Pick a random site\n                ix, iy = np.random.randint(0, L, size=2)\n                \n                # 2. Calculate energy change for a spin flip\n                # Sum of nearest neighbors using periodic boundary conditions\n                s_i = spins[ix, iy]\n                nn_sum = (\n                    spins[(ix - 1) % L, iy] +\n                    spins[(ix + 1) % L, iy] +\n                    spins[ix, (iy - 1) % L] +\n                    spins[ix, (iy + 1) % L]\n                )\n                \n                # Change in the effective Hamiltonian H' = E - delta_mu * N_B\n                # delta_H_prime = s_i * (2*J*nn_sum + delta_mu)\n                delta_H_prime = s_i * (2.0 * J * nn_sum + delta_mu)\n\n                # 3. Metropolis acceptance criterion\n                if delta_H_prime  0 or np.random.rand()  np.exp(-beta * delta_H_prime):\n                    spins[ix, iy] *= -1  # Accept flip\n            \n            # 4. Collect data after burn-in\n            if sweep = burn_in_sweeps:\n                # N_B = (N + sum(s_i)) / 2\n                current_nb = (N + np.sum(spins)) / 2.0\n                nb_measurements.append(current_nb)\n\n        return np.mean(nb_measurements)\n\n    validation_results = []\n    \n    # --- Main Loop over Test Cases ---\n    for T in test_temperatures:\n        # Calculate N_B for each delta_mu in the grid\n        avg_nb_values = np.array([run_mc_simulation(T, d_mu) for d_mu in delta_mu_grid])\n        \n        # --- Numerical Validation of the Derivative Identity ---\n        \n        # We need to evaluate the identity d(Phi)/d(delta_mu) = -N_B at delta_mu = 0.\n        # LHS is estimated by finite difference. RHS is from simulation.\n\n        # Values of N_B at the central three points of the grid\n        nb_at_minus_0_01 = avg_nb_values[1]\n        nb_at_0 = avg_nb_values[2]\n        nb_at_plus_0_01 = avg_nb_values[3]\n        \n        delta_mu_step = 0.01  # Spacing of the grid\n\n        # Integrate -N_B to find Phi relative to Phi(0)=0\n        # Phi(delta_mu) = integral from 0 to delta_mu of (-N_B)\n        \n        # Phi(T, delta_mu=+0.01)\n        # Trapezoidal rule for integral from 0 to +0.01\n        integrand_p = -np.array([nb_at_0, nb_at_plus_0_01])\n        phi_at_plus_0_01 = np.trapz(integrand_p, dx=delta_mu_step)\n\n        # Phi(T, delta_mu=-0.01)\n        # Trapezoidal rule for integral from -0.01 to 0, then negate\n        integrand_m = -np.array([nb_at_minus_0_01, nb_at_0])\n        integral_m_to_0 = np.trapz(integrand_m, dx=delta_mu_step)\n        phi_at_minus_0_01 = -integral_m_to_0\n\n        # Centered finite-difference approximation for the derivative of Phi at delta_mu=0\n        fd_derivative = (phi_at_plus_0_01 - phi_at_minus_0_01) / (2.0 * delta_mu_step)\n        \n        # The value to compare against is -N_B at delta_mu=0\n        sim_derivative = -nb_at_0\n        \n        # Check if the absolute difference is within the tolerance\n        abs_diff = abs(fd_derivative - sim_derivative)\n        is_valid = abs_diff = 0.1 * N\n        \n        validation_results.append(is_valid)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, validation_results))}]\")\n\nsolve()\n```", "id": "3464579"}]}