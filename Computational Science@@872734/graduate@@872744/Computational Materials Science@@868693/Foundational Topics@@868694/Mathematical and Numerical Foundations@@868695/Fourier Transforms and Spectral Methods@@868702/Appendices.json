{"hands_on_practices": [{"introduction": "The primary advantage of Fourier spectral methods lies in their ability to transform differential operators into simple algebraic multiplications. This first practice exercise provides a direct, hands-on demonstration of this core principle by tasking you with computing the derivative of a simple periodic function [@problem_id:3387455]. By implementing the process of forward transforming, multiplying by the appropriate wavenumbers, and inverse transforming, you will verify the remarkable accuracy of spectral differentiation and build the foundational skill for all subsequent applications.", "problem": "Consider a periodic grid on the interval $[0,2\\pi)$ defined by $x_j = \\frac{2\\pi j}{N}$ for $j \\in \\{0,1,\\dots,N-1\\}$, where $N \\in \\mathbb{N}$ and angles are measured in radians. Let $u_j = \\sin(5 x_j)$ for all grid points. The goal is to compute the discrete derivative $v = D u$ using the Fast Fourier Transform (FFT), where $D$ denotes the Fourier differentiation matrix acting on grid values of a $2\\pi$-periodic function. The derivation and computation must be based on first principles: start from the definition of the discrete Fourier transform of a $2\\pi$-periodic trigonometric interpolant on the equispaced grid, and use only foundational properties of Fourier series and linear operators. No pre-derived differentiation formulas are permitted in the problem statement.\n\nYour task is to write a complete, runnable program that:\n- Constructs the grid $x_j = \\frac{2\\pi j}{N}$ and the data $u_j = \\sin(5 x_j)$.\n- Computes the action of the Fourier differentiation matrix $D$ on $u$ by transforming $u$ to Fourier space, applying the differentiation operator in that basis consistent with the periodic setting, and transforming back to physical space.\n- Verifies numerically that the computed discrete derivative $v_j$ equals the analytical derivative $5 \\cos(5 x_j)$ to machine precision, and reports the maximum absolute error $\\max_j |v_j - 5\\cos(5 x_j)|$ for each test case.\n\nUse angles in radians. No physical units are involved. The answers must be expressed as real-valued floating-point numbers.\n\nTest Suite:\n- Use the set of grid sizes $N \\in \\{11, 12, 64, 128, 1001\\}$ to exercise different regimes, including the smallest allowed grid ($N=11$), even grids with a Nyquist mode ($N=12$), and larger grids where resolution is high ($N=64$, $N=128$, $N=1001$).\n\nFinal Output Format:\n- Your program should produce a single line of output containing the maximum absolute errors for the test suite as a comma-separated list enclosed in square brackets. For example, the output must be of the form $[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_5]$, where each $\\text{result}_i$ is the maximum absolute error for the corresponding $N$ in the order $[11,12,64,128,1001]$.", "solution": "The problem is evaluated as valid. It is scientifically grounded in the principles of Fourier analysis and spectral methods, is well-posed with all necessary information provided, and is formulated objectively. The solution proceeds as follows.\n\nThe core of the problem is to compute the derivative of a function $u(x)$ on a periodic grid using Fourier spectral methods. This method relies on representing the function by a trigonometric polynomial and then performing differentiation in the frequency domain, where it simplifies to a multiplication operation. The process involves three main steps: transforming the function from the physical domain to the frequency domain, applying the differentiation operator in the frequency domain, and transforming the result back to the physical domain.\n\nLet the domain be the interval $[0, 2\\pi)$, discretized by $N$ equispaced points $x_j = \\frac{2\\pi j}{N}$ for $j \\in \\{0, 1, \\dots, N-1\\}$. The function values on this grid are given by $u_j = u(x_j)$. For this problem, $u(x) = \\sin(5x)$, so $u_j = \\sin(5x_j)$.\n\n**Principle 1: Trigonometric Interpolation**\n\nThe set of $N$ data points $(x_j, u_j)$ uniquely defines a trigonometric polynomial interpolant, $p(x)$, of degree at most $\\lfloor N/2 \\rfloor$, such that $p(x_j) = u_j$ for all $j$. This interpolant can be expressed as a finite complex Fourier series:\n$$\np(x) = \\sum_{k \\in \\mathbb{K}_N} \\hat{u}_k e^{ikx}\n$$\nwhere $\\mathbb{K}_N$ is the set of integer wavenumbers appropriate for a grid of size $N$.\nFor $N$ odd, $\\mathbb{K}_N = \\{-(N-1)/2, \\dots, (N-1)/2\\}$.\nFor $N$ even, $\\mathbb{K}_N = \\{-N/2+1, \\dots, N/2\\}$. The mode $k=-N/2$ is aliased with $k=N/2$ on the grid, and they are typically combined into a single cosine term.\n\nThe complex Fourier coefficients $\\hat{u}_k$ are related to the grid values $u_j$ by the Discrete Fourier Transform (DFT). The standard definition is:\n$$\n\\hat{u}_k = \\frac{1}{N} \\sum_{j=0}^{N-1} u_j e^{-ikx_j} = \\frac{1}{N} \\sum_{j=0}^{N-1} u_j e^{-i k \\frac{2\\pi j}{N}}\n$$\n\n**Principle 2: Differentiation in the Fourier Domain**\n\nThe key advantage of the Fourier representation is that differentiation of the function in physical space corresponds to a simple multiplication of its Fourier coefficients by $ik$ in the frequency domain. Differentiating the interpolant $p(x)$ with respect to $x$ yields:\n$$\nv(x) = p'(x) = \\frac{d}{dx} \\left( \\sum_{k \\in \\mathbb{K}_N} \\hat{u}_k e^{ikx} \\right)\n$$\nBy linearity, we can interchange differentiation and summation:\n$$\nv(x) = \\sum_{k \\in \\mathbb{K}_N} \\hat{u}_k \\frac{d}{dx} (e^{ikx}) = \\sum_{k \\in \\mathbb{K}_N} (ik) \\hat{u}_k e^{ikx}\n$$\nThis demonstrates that the Fourier coefficients of the derivative, denoted $\\hat{v}_k$, are given by:\n$$\n\\hat{v}_k = ik \\hat{u}_k\n$$\nThe values of the derivative on the grid, $v_j = v(x_j)$, are then found by evaluating this new series, which is equivalent to performing an Inverse Discrete Fourier Transform (IDFT) on the coefficients $\\hat{v}_k$.\n\n**Algorithmic Implementation using the Fast Fourier Transform (FFT)**\n\nThe DFT and IDFT can be computed efficiently using the FFT algorithm. The procedure is as follows:\n\n1.  **Forward Transform**: Given the vector of function values $u = [u_0, u_1, \\dots, u_{N-1}]$, compute its DFT using an FFT algorithm. Let the result be $\\hat{U} = \\text{fft}(u)$. Standard numerical libraries like NumPy compute $\\hat{U}_m = \\sum_{j=0}^{N-1} u_j e^{-i 2\\pi mj / N}$ for $m \\in \\{0, \\dots, N-1\\}$. The relationship to our physical coefficients is $\\hat{u}_k = \\frac{1}{N}\\hat{U}_k$, where the FFT index $m$ is mapped to the physical wavenumber $k$.\n\n2.  **Wavenumber Vector**: It is necessary to construct the vector of physical wavenumbers $k$ that corresponds to the ordering of the FFT output. For an $N$-point FFT, the wavenumbers are $k \\in \\{0, 1, \\dots, N/2-1, -N/2, \\dots, -1\\}$ for even $N$, and $k \\in \\{0, 1, \\dots, (N-1)/2, -(N-1)/2, \\dots, -1\\}$ for odd $N$. This vector can be readily generated using library functions such as `numpy.fft.fftfreq(N) * N`.\n\n3.  **Applying the Differentiator**: The Fourier coefficients of the derivative, $\\hat{v}_k$, are computed by element-wise multiplication: $\\hat{v}_k = ik \\hat{u}_k$. In terms of the un-normalized coefficients from the FFT, this is $\\hat{V}_k = ik \\hat{U}_k$.\n    A special case arises for even $N$ at the Nyquist frequency, which corresponds to the wavenumber $k=N/2$ (or $k=-N/2$ depending on convention). A real-valued signal's interpolant on the grid contains only the $\\cos((N/2)x)$ component for this mode. The derivative of this cosine, $-(N/2)\\sin((N/2)x)$, is zero at all grid points $x_j$. Therefore, for a robust differentiation algorithm, the multiplier for the Nyquist frequency coefficient must be set to $0$.\n\n4.  **Inverse Transform**: The derivative values on the grid, $v = [v_0, v_1, \\dots, v_{N-1}]$, are obtained by applying the inverse FFT to the modified coefficients $\\hat{V}$: $v = \\text{ifft}(\\hat{V})$. Since the derivative of a real function is real, any residual imaginary part in the result is due to floating-point error and should be discarded.\n\n**Verification**\nThe computed discrete derivative $v_j$ is compared to the analytical derivative of $u(x) = \\sin(5x)$, which is $u'(x) = 5\\cos(5x)$. The maximum absolute error, $\\max_j |v_j - 5\\cos(5x_j)|$, is calculated. Since the function $\\sin(5x)$ is band-limited with wavenumber $k=5$, and all test cases use $N > 2k = 10$, the trigonometric interpolant is identical to the function itself. Consequently, the Fourier differentiation should be exact up to machine precision.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the derivative of u(x) = sin(5x) on a periodic grid\n    using the Fourier spectral method for a suite of grid sizes N,\n    and reports the maximum absolute error against the analytical derivative.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [11, 12, 64, 128, 1001]\n\n    results = []\n    \n    for N in test_cases:\n        # Step 1: Construct the grid and the function data.\n        # Grid points on [0, 2*pi).\n        x = 2 * np.pi * np.arange(N) / N\n        \n        # Function values on the grid for u(x) = sin(5x).\n        u = np.sin(5 * x)\n        \n        # Analytical derivative u'(x) = 5*cos(5x) on the grid for verification.\n        u_analytic_deriv = 5 * np.cos(5 * x)\n        \n        # Step 2: Transform to Fourier space using FFT.\n        # This gives the un-normalized Fourier coefficients.\n        u_hat = np.fft.fft(u)\n        \n        # Step 3: Apply the differentiation operator in Fourier space.\n        \n        # Generate the vector of physical wavenumbers corresponding to the FFT output array.\n        # np.fft.fftfreq(N) returns frequencies f_k = k/N.\n        # Multiplying by N gives the integer wavenumbers k.\n        wavenumbers = np.fft.fftfreq(N) * N\n        \n        # The differentiation operator in Fourier space is multiplication by ik.\n        d_hat = 1j * wavenumbers\n        \n        # For even N, the Nyquist frequency component requires special handling.\n        # The derivative of the cos(N/2 * x) basis function is zero on the grid points.\n        # Therefore, the corresponding multiplier must be set to 0.\n        # In numpy's fftfreq, the Nyquist frequency corresponds to index N//2.\n        if N % 2 == 0:\n            d_hat[N // 2] = 0.0\n            \n        # Apply the differentiation operator.\n        v_hat = d_hat * u_hat\n        \n        # Step 4: Transform back to physical space using inverse FFT.\n        v = np.fft.ifft(v_hat)\n        \n        # The result should be real. We take the real part to discard\n        # any small imaginary noise from floating-point inaccuracies.\n        v_real = v.real\n        \n        # Step 5: Verify the result by comparing with the analytical derivative.\n        # Calculate the maximum absolute error across all grid points.\n        max_error = np.max(np.abs(v_real - u_analytic_deriv))\n        \n        results.append(max_error)\n\n    # Final print statement in the exact required format.\n    # The map function converts each float error into a string for joining.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3387455"}, {"introduction": "While linear operators like derivatives are straightforward to handle in Fourier space, most physical models in materials science involve nonlinear terms, which are typically evaluated in real space. This pseudo-spectral approach introduces a significant numerical artifact known as aliasing, where high-frequency components generated by the nonlinearity masquerade as lower frequencies. This exercise guides you through diagnosing aliasing in the computation of a cubic term and implementing the standard de-aliasing technique of zero-padding, a critical skill for developing stable and accurate simulation codes [@problem_id:3453340].", "problem": "Consider a one-dimensional periodic domain of length $2\\pi$ with a real-valued field $\\phi(x)$ represented by a finite Fourier series. In a pseudo-spectral discretization, nonlinear terms are evaluated pointwise in real space and transformed back to Fourier space using the Fast Fourier Transform (FFT), which is an efficient algorithm to compute the Discrete Fourier Transform (DFT). When the product involves nonlinear powers, such as the cubic term $N(x) = \\phi(x)^3$, discrete convolution of the Fourier modes can produce new modes whose wavenumbers exceed the Nyquist limit of the chosen grid. This results in aliasing, where contributions from unresolvable high-frequency modes fold back into lower frequencies and corrupt the represented spectrum. \n\nYour task is to implement and compare three computational strategies for evaluating the cubic nonlinear term $N(x) = \\phi(x)^3$:\n- A naive pseudo-spectral method that computes $\\phi(x)^3$ on the coarse grid of $N$ points and transforms the result back to Fourier space using the DFT.\n- A zero-padding method with a padding factor of $3/2$, where the Fourier coefficients of $\\phi$ on the coarse grid are padded symmetrically to length $N_{\\mathrm{pad}} = \\frac{3}{2}N$, transformed to real space, multiplied in real space, and then transformed back to Fourier space and truncated to the original $N$ modes.\n- A zero-padding method with a padding factor of $2$, with the same procedure but using $N_{\\mathrm{pad}} = 2N$.\n\nThe foundational base for this problem is the convolution theorem for the DFT: the DFT of a product in real space is a discrete convolution of DFT coefficients in Fourier space. For a cubic nonlinearity, a finite-band field with maximum wavenumber $K_{\\max}$ generates spectral content up to $3K_{\\max}$. On a grid of $N$ points, the Nyquist wavenumber is $N/2$ (in integer mode counts for a $2\\pi$-periodic domain), so if $3K_{\\max} > N/2$, aliasing will occur in the naive computation.\n\nDefine the discrete spatial points by $x_j = \\frac{2\\pi j}{N}$ for $j = 0,1,\\dots,N-1$. Let the field $\\phi(x)$ be constructed as a finite sum of sines and cosines with integer wavenumbers:\n$$\n\\phi(x) = \\sum_{m} a_m \\cos(k_m x) + \\sum_{n} b_n \\sin(q_n x),\n$$\nwhere $k_m$ and $q_n$ are nonnegative integers. For each test case, construct $\\phi(x)$ directly in real space from its modal specification. \n\nTo assess aliasing and de-aliasing accuracy, define a reference spectrum for $N(x) = \\phi(x)^3$ by sampling $\\phi(x)$ on a sufficiently fine grid of $N_{\\mathrm{ref}}$ points with $N_{\\mathrm{ref}}$ chosen so that the highest expected wavenumber in $\\phi(x)^3$ is strictly below the Nyquist frequency of the reference grid. A sufficient condition is $N_{\\mathrm{ref}} \\ge 2 \\cdot 3K_{\\max} + 2$. Compute the DFT of $\\phi(x)^3$ on this fine grid, normalize by $N_{\\mathrm{ref}}$, and then project onto the coarse-grid resolvable Fourier wavenumbers (the central $N$ modes corresponding to integer wavenumbers from $-N/2$ to $N/2-1$). Treat this projected spectrum as the alias-free reference for the coarse grid.\n\nFor each of the three methods (naive, $3/2$-padded, and $2$-padded), compute the normalized DFT coefficients (divide the FFT by the grid length used in that method) for $N(x) = \\phi(x)^3$, reorder as a centered spectrum, and extract the central $N$ coefficients. Denote the reference coefficients by $\\hat{N}_{\\mathrm{ref}}$ and the method coefficients by $\\hat{N}_{\\mathrm{method}}$. For each method and test case, compute the relative error\n$$\n\\varepsilon = \\frac{\\left\\|\\hat{N}_{\\mathrm{method}} - \\hat{N}_{\\mathrm{ref}}\\right\\|_2}{\\left\\|\\hat{N}_{\\mathrm{ref}}\\right\\|_2},\n$$\nwhere $\\|\\cdot\\|_2$ denotes the Euclidean norm over the complex coefficient vector.\n\nImplement the above in a single program and apply it to the following test suite, where each case specifies the coarse grid size $N$ and the modes of $\\phi(x)$:\n- Case 1 (alias-prone mixed modes): $N = 64$, $\\phi(x) = 1.0\\cos(21x) + 0.5\\cos(7x) + 0.3\\sin(5x)$.\n- Case 2 (alias-free low modes): $N = 64$, $\\phi(x) = 1.0\\cos(5x) + 0.3\\sin(3x)$.\n- Case 3 (small grid, severe aliasing): $N = 32$, $\\phi(x) = 0.8\\cos(10x) + 0.6\\sin(9x)$.\n- Case 4 (near-Nyquist mixed modes): $N = 96$, $\\phi(x) = 1.0\\cos(31x) + 0.4\\cos(30x)$.\n\nFor each case, compute three floats: the relative error for the naive method, the relative error for the $3/2$-padded method, and the relative error for the $2$-padded method. Your program should produce a single line of output containing all results for the four cases, flattened into one list in the order of cases and methods, as a comma-separated list enclosed in square brackets. Round each float to six decimal places. For example, the output format must be exactly like\n$[$$e_{1,\\mathrm{naive}}$$,$$e_{1,3/2}$$,$$e_{1,2}$$,$$e_{2,\\mathrm{naive}}$$,$$e_{2,3/2}$$,$$e_{2,2}$$,$$e_{3,\\mathrm{naive}}$$,$$e_{3,3/2}$$,$$e_{3,2}$$,$$e_{4,\\mathrm{naive}}$$,$$e_{4,3/2}$$,$$e_{4,2}$$$]$ with numerical values replacing the symbols.\n\nNo physical units are involved in this problem; all quantities are dimensionless. Angles are in radians. The program must be self-contained and must not read input; it should print the single specified output line when run.", "solution": "The present problem requires a comparative analysis of three pseudo-spectral methods for computing the Fourier transform of a cubic nonlinearity, $N(x) = \\phi(x)^3$, on a one-dimensional periodic domain of length $2\\pi$. The core of the problem is to quantify the aliasing error that arises from the nonlinear term and to assess the effectiveness of de-aliasing techniques based on zero-padding.\n\nThe theoretical foundation of pseudo-spectral methods rests on the Discrete Fourier Transform (DFT) and the convolution theorem. A function $\\phi(x)$ discretized on a uniform grid of $N$ points, $x_j = 2\\pi j/N$ for $j=0, 1, \\dots, N-1$, can be represented by its DFT coefficients, $\\hat{\\phi}_k$, which correspond to a finite set of integer wavenumbers. For an even number of grid points $N$, these wavenumbers are typically taken as $k \\in \\{-N/2, \\dots, N/2 - 1\\}$.\n\nThe product of functions in real space corresponds to a convolution of their coefficients in Fourier space. Specifically, the DFT of the product $\\phi(x)^3$ is equivalent to the triple discrete convolution of the spectrum $\\hat{\\phi}_k$ with itself:\n$$\n\\widehat{\\phi^3}_k = (\\hat{\\phi} \\star \\hat{\\phi} \\star \\hat{\\phi})_k = \\sum_{p+q+r=k \\pmod N} \\hat{\\phi}_p \\hat{\\phi}_q \\hat{\\phi}_r\n$$\nIf the field $\\phi(x)$ contains wavenumbers up to a maximum of $K_{\\max}$, the cubic product $\\phi(x)^3$ will generate new wavenumbers up to $3K_{\\max}$. If $3K_{\\max}$ exceeds the Nyquist wavenumber of the grid, $k_{\\mathrm{Nyq}} = N/2$, the energy from these unresolvable high wavenumbers is erroneously \"folded back\" onto the lower, resolvable wavenumbers. This phenomenon is termed aliasing and it contaminates the computed spectrum.\n\nThe solution proceeds by implementing and comparing the three specified methods against a high-fidelity reference solution for four distinct test cases.\n\n**1. Reference Spectrum ($\\hat{N}_{\\mathrm{ref}}$)**\nTo establish a ground truth uncontaminated by aliasing, the function $\\phi(x)^3$ is evaluated on a significantly finer grid. A reference grid of size $N_{\\mathrm{ref}}$ is chosen such that its Nyquist frequency is greater than the highest possible wavenumber generated by the nonlinearity, i.e., $N_{\\mathrm{ref}}/2 \\ge 3K_{\\max}$. The problem provides the sufficient condition $N_{\\mathrm{ref}} \\ge 6K_{\\max} + 2$. A value of $N_{\\mathrm{ref}}=512$ is selected, which is adequate for all test cases. The procedure is as follows:\n- Construct the field $\\phi(x)$ on the fine grid of $N_{\\mathrm{ref}}$ points.\n- Compute the cubic term $\\phi(x)^3$ pointwise on this fine grid.\n- Compute its DFT and normalize by the grid size $N_{\\mathrm{ref}}$ to obtain the fine-grained spectrum, $\\hat{N}_{\\mathrm{fine}}$.\n- The alias-free reference spectrum for the coarse grid, $\\hat{N}_{\\mathrm{ref}}$, is obtained by extracting the $N$ coefficients from $\\hat{N}_{\\mathrm{fine}}$ that correspond to the wavenumbers resolvable by the coarse grid, i.e., $k \\in \\{-N/2, \\dots, N/2 - 1\\}$.\n\n**2. Naive Pseudo-Spectral Method**\nThis is the most direct but potentially inaccurate method.\n- Construct the field $\\phi(x)$ on the coarse grid of $N$ points.\n- Compute the cubic term $\\phi(x)^3$ pointwise.\n- The resulting aliased spectrum, $\\hat{N}_{\\mathrm{naive}}$, is the DFT of this product, normalized by $N$.\nThis method will suffer from aliasing whenever $3K_{\\max} > N/2$.\n\n**3. Zero-Padding (De-aliasing) Method**\nThis method mitigates aliasing by performing the multiplication in a larger, \"padded\" real space grid, which corresponds to inserting zeros for high-frequency modes in Fourier space.\n- First, the DFT of $\\phi(x)$ on the coarse grid, $\\hat{\\phi}$, is computed.\n- A new, larger array of Fourier coefficients of length $N_{\\mathrm{pad}}$ is created, where $N_{\\mathrm{pad}} = \\text{int}(f \\cdot N)$ and $f$ is the padding factor ($1.5$ or $2$). The original coefficients from $\\hat{\\phi}$ are copied to the corresponding low-wavenumber locations in the new array, and the remaining high-wavenumber slots are filled with zeros.\n- An inverse DFT is performed on this padded spectrum. To preserve the amplitude of the field, the result is scaled by the ratio of grid sizes, $N_{\\mathrm{pad}}/N$. This yields an interpolated version of $\\phi(x)$ on a finer grid of $N_{\\mathrm{pad}}$ points.\n- The cubic term $\\phi(x)^3$ is computed pointwise on this padded grid.\n- The DFT of this product is computed and normalized by $N_{\\mathrm{pad}}$.\n- Finally, the resulting spectrum is truncated back to the original $N$ modes to yield the de-aliased spectrum, $\\hat{N}_{\\mathrm{method}}$.\n\nFor a cubic nonlinearity, spectral theory indicates that a padding factor of $f=2$ (i.e., doubling the grid points to $2N$) is sufficient to completely eliminate aliasing, provided the input field $\\phi(x)$ was fully resolved on the original grid. A factor of $f=3/2$, while standard for quadratic nonlinearities, is generally insufficient for cubic terms and is expected to show residual aliasing error in cases where $3K_{\\max} > (3/2)N/2 = 3N/4$.\n\n**4. Error Metric**\nFor each method, the accuracy is quantified by the relative error $\\varepsilon$ in the $L_2$ (Euclidean) norm between the method's computed spectrum ($\\hat{N}_{\\mathrm{method}}$) and the reference spectrum ($\\hat{N}_{\\mathrm{ref}}$):\n$$\n\\varepsilon = \\frac{\\left\\| \\hat{N}_{\\mathrm{method}} - \\hat{N}_{\\mathrm{ref}} \\right\\|_2}{\\left\\| \\hat{N}_{\\mathrm{ref}} \\right\\|_2}\n$$\nThis metric provides a single value representing the overall deviation of the computed spectrum from the alias-free ideal. The implementation will calculate this error for the naive, $3/2$-padded, and $2$-padded methods for each of the four test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import fft\n\ndef solve():\n    \"\"\"\n    Implements and compares three pseudo-spectral methods for evaluating the cubic\n    nonlinearity phi^3, calculating the relative error of each against a\n    high-resolution reference to assess aliasing and de-aliasing effectiveness.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (64, [(1.0, 'cos', 21), (0.5, 'cos', 7), (0.3, 'sin', 5)]),\n        (64, [(1.0, 'cos', 5), (0.3, 'sin', 3)]),\n        (32, [(0.8, 'cos', 10), (0.6, 'sin', 9)]),\n        (96, [(1.0, 'cos', 31), (0.4, 'cos', 30)])\n    ]\n\n    all_results = []\n\n    def build_phi(x_grid, modes):\n        \"\"\"Constructs the real-valued field phi(x) on a given grid.\"\"\"\n        phi = np.zeros_like(x_grid, dtype=float)\n        for amp, func_type, k in modes:\n            if func_type == 'cos':\n                phi += amp * np.cos(k * x_grid)\n            elif func_type == 'sin':\n                phi += amp * np.sin(k * x_grid)\n        return phi\n\n    for N, modes in test_cases:\n        # ---- 1. Determine Parameters and Grids ----\n        K_max = max(k for _, _, k in modes) if modes else 0\n        \n        # Reference grid must resolve wavenumbers up to 3*K_max.\n        # Required: N_ref >= 6*K_max + 2.\n        # Max K_max is 31 (case 4), so N_ref must be >= 6*31 + 2 = 188.\n        # Let's choose a safe, large power of 2 sufficient for all cases.\n        N_ref = 512\n        x_ref = (2 * np.pi / N_ref) * np.arange(N_ref)\n        \n        x_coarse = (2 * np.pi / N) * np.arange(N)\n        half_N = N // 2\n        \n        # ---- 2. Compute Reference Spectrum ----\n        phi_ref = build_phi(x_ref, modes)\n        N_ref_real = phi_ref**3\n        N_hat_ref_full = fft.fft(N_ref_real) / N_ref\n        \n        # Project onto the coarse grid's wavenumbers by truncation\n        N_hat_ref = np.zeros(N, dtype=complex)\n        N_hat_ref[0:half_N] = N_hat_ref_full[0:half_N]\n        N_hat_ref[half_N:] = N_hat_ref_full[N_ref - half_N:]\n\n        # ---- 3. Naive Method ----\n        phi_coarse = build_phi(x_coarse, modes)\n        N_naive_real = phi_coarse**3\n        N_hat_naive = fft.fft(N_naive_real) / N\n        \n        norm_ref = np.linalg.norm(N_hat_ref)\n        if norm_ref == 0: # Avoid division by zero for null fields\n            norm_ref = 1.0\n\n        err_naive = np.linalg.norm(N_hat_naive - N_hat_ref) / norm_ref\n        all_results.append(f\"{err_naive:.6f}\")\n\n        # ---- 4. Padded Methods ----\n        phi_hat_coarse = fft.fft(phi_coarse)\n\n        for pad_factor in [1.5, 2.0]:\n            N_pad = int(N * pad_factor)\n            \n            # Pad Fourier coefficients with zeros for high frequencies\n            phi_hat_padded = np.zeros(N_pad, dtype=complex)\n            phi_hat_padded[0:half_N] = phi_hat_coarse[0:half_N]\n            phi_hat_padded[N_pad - half_N:] = phi_hat_coarse[half_N:]\n\n            # Transform to padded real space, compute cube, transform back\n            # The scaling factor restores the amplitude of the interpolated signal.\n            phi_padded = fft.ifft(phi_hat_padded) * (N_pad / N)\n            \n            # The signal phi is real, so its IFFT should be real.\n            # We take np.real to discard small imaginary parts from numerical error.\n            N_padded_real = np.real(phi_padded)**3\n            \n            N_hat_padded_full = fft.fft(N_padded_real) / N_pad\n            \n            # Truncate back to the coarse grid size\n            N_hat_padded = np.zeros(N, dtype=complex)\n            N_hat_padded[0:half_N] = N_hat_padded_full[0:half_N]\n            N_hat_padded[half_N:] = N_hat_padded_full[N_pad - half_N:]\n\n            err_padded = np.linalg.norm(N_hat_padded - N_hat_ref) / norm_ref\n            all_results.append(f\"{err_padded:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "3453340"}, {"introduction": "Having mastered the spectral representation of linear and nonlinear operators, we now apply these tools to a practical research problem: the linear stability analysis of a phase-field crystal (PFC) model [@problem_id:3453329]. This exercise bridges the gap between numerical method theory and computational materials science by analyzing how different modes of the system are expected to grow or decay. You will derive both the physical growth rate from the governing equation and the effective numerical growth rate from a time-stepping scheme, learning to identify potential discrepancies like numerical suppression that are critical for ensuring the fidelity of a simulation.", "problem": "Consider the one-dimensional Phase-Field Crystal (PFC) equation linearized about a spatially uniform state, on a periodic domain of length $L$, with scalar order parameter $ \\psi(x,t) $. Neglecting nonlinear terms after linearization and using a spectral representation on a uniform grid, the governing linear partial differential equation is\n$$\n\\frac{\\partial \\psi}{\\partial t} = \\nabla^2 \\left[ r \\, \\psi + \\left( 1 + \\nabla^2 \\right)^2 \\psi \\right],\n$$\nwhere $ r $ is a real control parameter. Using the Fourier transform and the fact that spatial derivatives correspond to multiplication by powers of $ i k $ in Fourier space, a plane-wave ansatz $ \\psi(x,t) = \\hat{\\psi}_0 \\, e^{i k x + \\sigma t} $ yields a physical growth rate $ \\sigma(k) $ as a function of wavenumber magnitude $ k $. A spectral semi-implicit time discretization in Fourier space using the first-order Backward Euler scheme updates each Fourier mode $ \\hat{\\psi}(k,t) $ by\n$$\n\\frac{\\hat{\\psi}^{n+1}(k) - \\hat{\\psi}^n(k)}{\\Delta t} = \\sigma(k) \\, \\hat{\\psi}^{n+1}(k),\n$$\nwhere $ \\Delta t $ is the time step. This induces a numerical amplification factor $ G(k) $ per time step and an effective numerical growth rate $ \\sigma_{\\text{num}}(k) $ defined via the relation $ |G(k)| = e^{\\sigma_{\\text{num}}(k)\\,\\Delta t} $. A spurious unstable mode is defined as a wavenumber for which $ \\sigma(k) \\le 0 $ but $ |G(k)| > 1 $, and a suppressed unstable mode is defined as a wavenumber for which $ \\sigma(k) > 0 $ but $ |G(k)| \\le 1 $. All quantities are dimensionless.\n\nTasks:\n- Starting from the definitions of the Fourier transform on a periodic domain and the spectral action of $ \\nabla^2 $, derive the physical growth rate $ \\sigma(k) $ for the linearized PFC equation, expressed solely in terms of $ k $ and $ r $.\n- Derive the numerical amplification factor $ G(k) $ and the corresponding effective numerical growth rate $ \\sigma_{\\text{num}}(k) $ for the Backward Euler time discretization.\n- Implement a program that, for a periodic domain of length $ L = 2\\pi $ with $ N $ equispaced grid points and discrete nonnegative wavenumbers $ k \\in \\{ 0, 1, \\dots, N/2 \\} $, computes the following for each test case:\n  1. The maximum absolute discrepancy $ \\max_{k \\in \\mathcal{A}} \\left| \\sigma_{\\text{num}}(k) - \\sigma(k) \\right| $ restricted to the alignment set $ \\mathcal{A} = \\{ k : |\\sigma(k)| \\le S_{\\text{cut}} \\} $, where $ S_{\\text{cut}} $ is a specified scalar threshold.\n  2. The count of spurious unstable modes over all $ k \\in \\{ 0, 1, \\dots, N/2 \\} $.\n  3. The count of suppressed unstable modes over all $ k \\in \\{ 0, 1, \\dots, N/2 \\} $.\n\nUse the definitions:\n- Physical growth rate $ \\sigma(k) $ derived from the linear operator.\n- Backward Euler numerical amplification factor $ G(k) $ and effective numerical growth rate $ \\sigma_{\\text{num}}(k) $ defined by $ \\sigma_{\\text{num}}(k) = \\frac{1}{\\Delta t} \\ln |G(k)| $.\n\nAssume a discrete Fourier grid consistent with the Fast Fourier Transform (FFT), but compute using analytical expressions for $ k $ and do not perform an actual FFT.\n\nTest Suite:\n- Case $ \\mathrm{A} $: $ N = 128 $, $ r = -0.25 $, $ \\Delta t = 0.01 $, $ S_{\\text{cut}} = 1.0 $.\n- Case $ \\mathrm{B} $: $ N = 128 $, $ r = -0.25 $, $ \\Delta t = 16.0 $, $ S_{\\text{cut}} = 10.0 $.\n- Case $ \\mathrm{C} $: $ N = 64 $, $ r = 0.0 $, $ \\Delta t = 1.0 $, $ S_{\\text{cut}} = 1.0 $.\n\nFinal Output Format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each case in the order $ \\mathrm{A}, \\mathrm{B}, \\mathrm{C} $, output the triple $ [\\text{max\\_abs\\_error}, \\text{spurious\\_count}, \\text{suppressed\\_count}] $ in flattened order. Hence the full output must be a list of $ 9 $ values in the order $ [\\text{A\\_error}, \\text{A\\_spurious}, \\text{A\\_suppressed}, \\text{B\\_error}, \\text{B\\_spurious}, \\text{B\\_suppressed}, \\text{C\\_error}, \\text{C\\_spurious}, \\text{C\\_suppressed}] $. All reported values are dimensionless real numbers or integers. No additional text should be printed.", "solution": "The problem requires the analysis of a linearized Phase-Field Crystal (PFC) equation using spectral methods and a semi-implicit time integration scheme. The core tasks are to derive the physical and numerical growth rates for Fourier modes, and then to compute stability and accuracy metrics for a given set of parameters.\n\n### Derivation of the Physical Growth Rate $\\sigma(k)$\n\nThe governing linearized one-dimensional PFC equation is given by:\n$$\n\\frac{\\partial \\psi}{\\partial t} = \\nabla^2 \\left[ r \\, \\psi + \\left( 1 + \\nabla^2 \\right)^2 \\psi \\right]\n$$\nHere, $\\psi(x,t)$ is the scalar order parameter, $x$ is the spatial coordinate, $t$ is time, and $r$ is a real control parameter.\n\nWe employ a spectral method based on the Fourier transform. The action of the spatial derivative operator $\\nabla$ in real space corresponds to multiplication by $ik$ in Fourier space, where $k$ is the wavenumber. Consequently, the Laplacian operator $\\nabla^2$ corresponds to multiplication by $(ik)^2 = -k^2$. Let $\\hat{\\psi}(k,t)$ be the Fourier transform of $\\psi(x,t)$. Applying the Fourier transform to the governing partial differential equation (PDE) converts it into a set of independent ordinary differential equations (ODEs) for each wavenumber $k$:\n$$\n\\frac{d \\hat{\\psi}(k,t)}{dt} = (-k^2) \\left[ r \\, \\hat{\\psi}(k,t) + (1 + (-k^2))^2 \\hat{\\psi}(k,t) \\right]\n$$\nSimplifying the expression within the brackets:\n$$\n\\frac{d \\hat{\\psi}(k,t)}{dt} = -k^2 \\left[ r + (1 - k^2)^2 \\right] \\hat{\\psi}(k,t)\n$$\nThis ODE is of the form $\\frac{d\\hat{\\psi}}{dt} = \\lambda \\hat{\\psi}$, where the eigenvalue $\\lambda$ depends on $k$. The solution is of the form $\\hat{\\psi}(k,t) = \\hat{\\psi}(k,0) e^{\\lambda t}$. The problem defines the physical growth rate as $\\sigma(k)$, which is precisely this eigenvalue $\\lambda$.\nBy inspection, we identify the physical growth rate $\\sigma(k)$ as:\n$$\n\\sigma(k) = -k^2 \\left[ r + (1 - k^2)^2 \\right]\n$$\nThis expression provides the growth or decay rate of a plane-wave mode with wavenumber $k$ as dictated by the physical model.\n\n### Derivation of the Numerical Amplification Factor $G(k)$ and Growth Rate $\\sigma_{\\text{num}}(k)$\n\nThe problem specifies a semi-implicit time discretization using the first-order Backward Euler scheme. The update rule for each Fourier mode $\\hat{\\psi}(k)$ from time step $n$ to $n+1$ is:\n$$\n\\frac{\\hat{\\psi}^{n+1}(k) - \\hat{\\psi}^n(k)}{\\Delta t} = \\sigma(k) \\, \\hat{\\psi}^{n+1}(k)\n$$\nwhere $\\Delta t$ is the time step. The numerical amplification factor, $G(k)$, is defined by the relation $\\hat{\\psi}^{n+1}(k) = G(k) \\hat{\\psi}^n(k)$. To find $G(k)$, we rearrange the discretized equation to solve for $\\hat{\\psi}^{n+1}(k)$:\n$$\n\\hat{\\psi}^{n+1}(k) (1 - \\Delta t \\, \\sigma(k)) = \\hat{\\psi}^n(k)\n$$\n$$\n\\hat{\\psi}^{n+1}(k) = \\frac{1}{1 - \\Delta t \\, \\sigma(k)} \\hat{\\psi}^n(k)\n$$\nComparing this with the definition of $G(k)$, we obtain:\n$$\nG(k) = \\frac{1}{1 - \\Delta t \\, \\sigma(k)}\n$$\nThe effective numerical growth rate, $\\sigma_{\\text{num}}(k)$, is defined via the relation $|G(k)| = e^{\\sigma_{\\text{num}}(k) \\, \\Delta t}$. Taking the natural logarithm of both sides and solving for $\\sigma_{\\text{num}}(k)$ yields:\n$$\n\\sigma_{\\text{num}}(k) = \\frac{1}{\\Delta t} \\ln |G(k)|\n$$\nSince both $r$ and $k$ are real, $\\sigma(k)$ is real. Thus, $G(k)$ is also real. Substituting the expression for $G(k)$:\n$$\n\\sigma_{\\text{num}}(k) = \\frac{1}{\\Delta t} \\ln \\left| \\frac{1}{1 - \\Delta t \\, \\sigma(k)} \\right| = -\\frac{1}{\\Delta t} \\ln |1 - \\Delta t \\, \\sigma(k)|\n$$\nThis formula gives the growth rate of a mode as implemented by the numerical scheme.\n\n### Analysis of Stability and Error Metrics\n\nThe problem defines two types of numerical artifacts: spurious instabilities and suppressed instabilities.\n\n1.  **Spurious Unstable Modes**: A mode $k$ is a spurious unstable mode if its physical growth rate is non-positive, $\\sigma(k) \\le 0$, but its numerical amplification factor is greater than one in magnitude, $|G(k)| > 1$. Let us analyze the condition $|G(k)| > 1$:\n    $$\n    |G(k)| > 1 \\iff \\left| \\frac{1}{1 - \\Delta t \\, \\sigma(k)} \\right| > 1 \\iff |1 - \\Delta t \\, \\sigma(k)| < 1\n    $$\n    This inequality is equivalent to $-1 < 1 - \\Delta t \\, \\sigma(k) < 1$. Subtracting $1$ from all parts gives $-2 < - \\Delta t \\, \\sigma(k) < 0$. Since $\\Delta t > 0$, we can multiply by $-1/\\Delta t$ and reverse the inequalities: $2/\\Delta t > \\sigma(k) > 0$.\n    Thus, the condition $|G(k)| > 1$ is satisfied only if $0 < \\sigma(k) < 2/\\Delta t$. The definition of a spurious unstable mode requires $\\sigma(k) \\le 0$ AND $|G(k)| > 1$. These two conditions are mutually exclusive. Therefore, for the Backward Euler scheme applied to this linear operator with real eigenvalues, spurious unstable modes cannot exist. The count of such modes is analytically zero. This is a reflection of the L-stability of the Backward Euler method.\n\n2.  **Suppressed Unstable Modes**: A mode $k$ is a suppressed unstable mode if it is physically unstable, $\\sigma(k) > 0$, but the numerical scheme damps it or keeps it stable, $|G(k)| \\le 1$. Let us analyze the condition $|G(k)| \\le 1$:\n    $$\n    |G(k)| \\le 1 \\iff \\left| \\frac{1}{1 - \\Delta t \\, \\sigma(k)} \\right| \\le 1 \\iff |1 - \\Delta t \\, \\sigma(k)| \\ge 1\n    $$\n    This inequality is satisfied if $1 - \\Delta t \\, \\sigma(k) \\ge 1$ or if $1 - \\Delta t \\, \\sigma(k) \\le -1$.\n    -   Case 1: $1 - \\Delta t \\, \\sigma(k) \\ge 1 \\implies -\\Delta t \\, \\sigma(k) \\ge 0 \\implies \\sigma(k) \\le 0$.\n    -   Case 2: $1 - \\Delta t \\, \\sigma(k) \\le -1 \\implies 2 \\le \\Delta t \\, \\sigma(k) \\implies \\sigma(k) \\ge 2/\\Delta t$.\n    The condition for a suppressed unstable mode is $\\sigma(k) > 0$ AND ($|G(k)| \\le 1$, which is equivalent to $\\sigma(k) \\le 0$ or $\\sigma(k) \\ge 2/\\Delta t$). Combining these, the condition simplifies to $\\sigma(k) \\ge 2/\\Delta t$. This means that physically unstable modes with a sufficiently large growth rate are numerically suppressed by the scheme, a known feature of the overly diffusive nature of Backward Euler, especially at large time steps.\n\n### Computational Implementation\n\nThe algorithm to compute the required metrics for each test case is as follows:\n1.  For each test case with parameters $N$, $r$, $\\Delta t$, and $S_{\\text{cut}}$, create an array of discrete, non-negative integer wavenumbers $k \\in \\{0, 1, \\dots, N/2\\}$.\n2.  For each $k$ in this array, compute the physical growth rate $\\sigma(k) = -k^2 [r + (1 - k^2)^2]$.\n3.  Compute the effective numerical growth rate $\\sigma_{\\text{num}}(k) = -\\frac{1}{\\Delta t} \\ln |1 - \\Delta t \\, \\sigma(k)|$.\n4.  To find the maximum absolute discrepancy, identify the alignment set $\\mathcal{A} = \\{k : |\\sigma(k)| \\le S_{\\text{cut}}\\}$. Calculate the differences $|\\sigma_{\\text{num}}(k) - \\sigma(k)|$ for all $k \\in \\mathcal{A}$ and find the maximum value. If $\\mathcal{A}$ is empty, the discrepancy is $0$.\n5.  The count of spurious unstable modes is always $0$, as derived above.\n6.  To find the count of suppressed unstable modes, count the number of wavenumbers $k$ for which the condition $\\sigma(k) \\ge 2/\\Delta t$ is satisfied.\n7.  Collect the three computed metrics (max discrepancy, spurious count, suppressed count) for each test case and format them into a single flattened list for output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Phase-Field Crystal problem for the given test cases.\n\n    The solution involves:\n    1. Deriving and implementing the physical growth rate sigma(k).\n    2. Deriving and implementing the numerical amplification factor G(k) and\n       the effective numerical growth rate sigma_num(k) for the Backward Euler scheme.\n    3. Computing the requested metrics: max absolute discrepancy, count of spurious\n       unstable modes, and count of suppressed unstable modes.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, r, dt, S_cut)\n        (128, -0.25, 0.01, 1.0),  # Case A\n        (128, -0.25, 16.0, 10.0), # Case B\n        (64, 0.0, 1.0, 1.0),      # Case C\n    ]\n\n    # This list will store the flattened results: [A_err, A_spur, A_supp, B_err, ...]\n    final_results = []\n\n    for N, r, dt, S_cut in test_cases:\n        # 1. Define the discrete wavenumber space\n        # For a domain of length L=2*pi, the discrete integer wavenumbers are k = 0, 1, ...\n        # For an N-point FFT on real data, unique non-negative wavenumbers are k = 0, ..., N/2.\n        k = np.arange(N / 2 + 1)\n\n        # 2. Calculate the physical growth rate sigma(k)\n        # sigma(k) = -k^2 * [r + (1 - k^2)^2]\n        sigma_k = -k**2 * (r + (1 - k**2)**2)\n\n        # 3. Calculate the effective numerical growth rate sigma_num(k)\n        # sigma_num(k) = - (1/dt) * ln|1 - dt * sigma(k)|\n        # Use np.errstate to handle potential log(0) which results in inf.\n        with np.errstate(divide='ignore'):\n            sigma_num_k = -(1 / dt) * np.log(np.abs(1 - dt * sigma_k))\n\n        # 4. Compute the required metrics\n        \n        # Metric 1: Maximum absolute discrepancy\n        # Alignment set A = {k : |sigma(k)| <= S_cut}\n        alignment_mask = np.abs(sigma_k) <= S_cut\n        \n        if np.any(alignment_mask):\n            discrepancy = np.abs(sigma_num_k[alignment_mask] - sigma_k[alignment_mask])\n            max_abs_error = np.max(discrepancy)\n        else:\n            # If the alignment set is empty, the max discrepancy is 0.\n            max_abs_error = 0.0\n\n        # Metric 2: Count of spurious unstable modes\n        # Condition: sigma(k) <= 0 AND |G(k)| > 1\n        # As derived, |G(k)| > 1 implies 0 < sigma(k) < 2/dt.\n        # The two conditions are contradictory, so the count is always 0.\n        spurious_count = 0\n        \n        # Metric 3: Count of suppressed unstable modes\n        # Condition: sigma(k) > 0 AND |G(k)| <= 1\n        # As derived, this simplifies to sigma(k) >= 2.0 / dt.\n        suppressed_mask = sigma_k >= (2.0 / dt)\n        suppressed_count = np.sum(suppressed_mask)\n\n        # Append the results for the current case to the flattened list\n        final_results.extend([max_abs_error, spurious_count, suppressed_count])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n\n```", "id": "3453329"}]}