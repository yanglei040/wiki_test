{"hands_on_practices": [{"introduction": "A core challenge in the classical theory of dislocations is the unphysical stress singularity predicted at the dislocation line. Discrete Dislocation Dynamics (DDD) simulations resolve this by introducing a \"regularized\" core with finite stresses. This first practice provides a foundational, analytical look at this concept by guiding you to derive and compare the classical singular stress field with a common non-singular model, allowing you to quantify the region where regularization is most significant [@problem_id:2878140].", "problem": "Consider an infinite, straight screw dislocation aligned with the $z$-axis in an isotropic, linear elastic medium of shear modulus $\\mu$, with Burgers vector of magnitude $b$ parallel to the $z$-axis. In the classical Volterra model, the antiplane displacement is multivalued and the resulting circumferential shear stress $\\tau_{\\theta z}(r)$ diverges as the radial distance $r \\to 0$. In discrete dislocation dynamics, a non-singular core regularization is introduced by replacing the singular two-dimensional Green’s function of the Laplacian with a radially smoothed version characterized by a core half-width $a>0$, which yields finite fields on the dislocation line.\n\nUsing isotropic antiplane elasticity and the Green’s function framework, derive the analytical expressions for the circumferential shear stress fields $\\tau_{\\theta z}^{\\mathrm{Volterra}}(r)$ and $\\tau_{\\theta z}^{\\mathrm{ns}}(r)$ corresponding to the classical Volterra and non-singular core models, respectively, and hence compute the ratio\n$$\n\\rho(r,a) \\equiv \\frac{\\tau_{\\theta z}^{\\mathrm{ns}}(r)}{\\tau_{\\theta z}^{\\mathrm{Volterra}}(r)}.\n$$\nTo quantify when regularization is significant, define the relative deviation\n$$\n\\delta(r,a) \\equiv \\left|1 - \\rho(r,a)\\right|,\n$$\nand adopt the following criterion: regularization is considered significant when $\\delta(r,a) \\ge \\delta_{0}$ with $\\delta_{0} = 0.1$. Introduce the dimensionless distance $x \\equiv r/a$ and determine the critical value $x^{\\star}$ such that $\\delta(r,a) = \\delta_{0}$ at $x = x^{\\star}$.\n\nProvide your final answer as a row vector whose first entry is the closed-form expression for $\\rho(r,a)$, and whose second entry is the exact value of $x^{\\star}$. No numerical rounding is required, and no units are to be reported inside the final answer box.", "solution": "The problem statement submitted for analysis is deemed valid. It is scientifically grounded in the theory of linear elasticity and dislocation mechanics, is well-posed with a clear objective and sufficient information, and uses objective, technical language. We may therefore proceed with the derivation and solution.\n\nThe problem asks for an analysis of a straight screw dislocation aligned with the $z$-axis in an isotropic, linear elastic medium. This scenario is one of antiplane shear, where the only non-zero component of the displacement vector $\\mathbf{u}$ is $u_z$, and it is a function of the in-plane coordinates $(x,y)$ only, i.e., $u_z = u_z(x,y)$.\n\nFirst, we derive the classical Volterra stress field. For a screw dislocation with Burgers vector $\\mathbf{b} = (0, 0, b)$, the displacement field is multivalued and given in cylindrical coordinates $(r, \\theta, z)$ by\n$$\nu_z(r,\\theta) = \\frac{b}{2\\pi} \\theta\n$$\nThe non-zero strain components in antiplane shear are $\\epsilon_{rz}$ and $\\epsilon_{\\theta z}$. Using the strain-displacement relations in cylindrical coordinates:\n$$\n\\epsilon_{rz} = \\frac{1}{2} \\frac{\\partial u_z}{\\partial r} = \\frac{1}{2} \\frac{\\partial}{\\partial r} \\left(\\frac{b}{2\\pi}\\theta\\right) = 0\n$$\n$$\n\\epsilon_{\\theta z} = \\frac{1}{2} \\frac{1}{r} \\frac{\\partial u_z}{\\partial \\theta} = \\frac{1}{2r} \\frac{\\partial}{\\partial \\theta} \\left(\\frac{b}{2\\pi}\\theta\\right) = \\frac{b}{4\\pi r}\n$$\nThe constitutive law for an isotropic, linear elastic material in shear is $\\tau_{ij} = 2\\mu\\epsilon_{ij}$, where $\\mu$ is the shear modulus. The only non-zero stress component is the circumferential shear stress $\\tau_{\\theta z}$:\n$$\n\\tau_{\\theta z}^{\\mathrm{Volterra}}(r) = 2\\mu \\epsilon_{\\theta z} = 2\\mu \\left(\\frac{b}{4\\pi r}\\right) = \\frac{\\mu b}{2\\pi r}\n$$\nThis is the classical singular stress field, which diverges as $r \\to 0$.\n\nNext, we consider the non-singular core model. The problem states that this is achieved by smoothing the two-dimensional Green's function of the Laplacian. In dislocation theory, this is often formulated using a stress function $\\phi(x,y)$ such that $\\tau_{xz} = \\partial \\phi / \\partial y$ and $\\tau_{yz} = -\\partial \\phi / \\partial x$. The stress function satisfies the Poisson equation $\\nabla^2 \\phi = -\\mu \\eta(x,y)$, where $\\eta(x,y)$ is the dislocation density.\nFor the singular Volterra case, $\\eta(x,y) = b \\delta(x)\\delta(y)$, and the stress function is $\\phi_{\\mathrm{Volterra}} = -\\mu b G_{2D}(r)$, where $G_{2D}(r) = \\frac{1}{2\\pi} \\ln(r)$ is the singular Green's function.\nThe regularization replaces this Green's function with a smoothed version. A canonical choice for such a regularized Green's function in this context, which is finite at the origin, is $G_{\\mathrm{ns}}(r) = \\frac{1}{4\\pi} \\ln(r^2 + a^2)$, where $a$ is the core half-width.\nThe corresponding non-singular stress function is:\n$$\n\\phi_{\\mathrm{ns}}(r) = -\\mu b G_{\\mathrm{ns}}(r) = -\\frac{\\mu b}{4\\pi} \\ln(r^2 + a^2)\n$$\nThe stress components in cylindrical coordinates are derived from the stress function as $\\tau_{rz} = \\frac{1}{r} \\frac{\\partial \\phi}{\\partial \\theta}$ and $\\tau_{\\theta z} = -\\frac{\\partial \\phi}{\\partial r}$. Since $\\phi_{\\mathrm{ns}}$ depends only on $r$, $\\tau_{rz}^{\\mathrm{ns}} = 0$. The circumferential shear stress is:\n$$\n\\tau_{\\theta z}^{\\mathrm{ns}}(r) = - \\frac{\\partial \\phi_{\\mathrm{ns}}}{\\partial r} = - \\frac{\\partial}{\\partial r} \\left(-\\frac{\\mu b}{4\\pi} \\ln(r^2+a^2)\\right) = \\frac{\\mu b}{4\\pi} \\frac{2r}{r^2+a^2} = \\frac{\\mu b}{2\\pi} \\frac{r}{r^2+a^2}\n$$\nThis stress field is finite at $r=0$, where $\\tau_{\\theta z}^{\\mathrm{ns}}(0) = 0$, and it converges to the Volterra field for $r \\gg a$.\n\nNow, we compute the ratio $\\rho(r,a)$:\n$$\n\\rho(r,a) \\equiv \\frac{\\tau_{\\theta z}^{\\mathrm{ns}}(r)}{\\tau_{\\theta z}^{\\mathrm{Volterra}}(r)} = \\frac{\\frac{\\mu b}{2\\pi} \\frac{r}{r^2+a^2}}{\\frac{\\mu b}{2\\pi r}} = \\frac{r}{r^2+a^2} \\cdot r = \\frac{r^2}{r^2+a^2}\n$$\nThis is the first required expression.\n\nFinally, we determine the critical value $x^{\\star}$. The relative deviation is defined as $\\delta(r,a) \\equiv |1 - \\rho(r,a)|$. Since $r^2 \\le r^2+a^2$ for $a>0$, the ratio $\\rho(r,a) \\le 1$. Thus, the absolute value is not necessary:\n$$\n\\delta(r,a) = 1 - \\rho(r,a) = 1 - \\frac{r^2}{r^2+a^2} = \\frac{(r^2+a^2)-r^2}{r^2+a^2} = \\frac{a^2}{r^2+a^2}\n$$\nRegularization is considered significant when $\\delta(r,a) \\ge \\delta_0$, with $\\delta_0 = 0.1$. The critical condition is at the boundary, $\\delta(r,a) = \\delta_0$.\nWe introduce the dimensionless distance $x \\equiv r/a$. Substituting $r = xa$ into the expression for $\\delta$:\n$$\n\\delta(x) = \\frac{a^2}{(xa)^2+a^2} = \\frac{a^2}{a^2(x^2+1)} = \\frac{1}{x^2+1}\n$$\nThe critical value $x^{\\star}$ is found by solving $\\delta(x^{\\star}) = \\delta_0$:\n$$\n\\frac{1}{(x^{\\star})^2+1} = \\delta_0\n$$\n$$\n(x^{\\star})^2+1 = \\frac{1}{\\delta_0}\n$$\n$$\n(x^{\\star})^2 = \\frac{1}{\\delta_0} - 1\n$$\nSince $x$ represents a ratio of distances, it must be non-negative, so we take the positive root:\n$$\nx^{\\star} = \\sqrt{\\frac{1}{\\delta_0} - 1}\n$$\nSubstituting the given value $\\delta_0 = 0.1 = \\frac{1}{10}$:\n$$\nx^{\\star} = \\sqrt{\\frac{1}{1/10} - 1} = \\sqrt{10 - 1} = \\sqrt{9} = 3\n$$\nThe critical dimensionless distance is $x^{\\star}=3$. This means that for distances from the dislocation line less than or equal to $3$ times the core half-width ($r \\le 3a$), the deviation from the classical Volterra model is at least $10\\%$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{r^2}{r^2+a^2}  3\n\\end{pmatrix}\n}\n$$", "id": "2878140"}, {"introduction": "In DDD, smoothly curved dislocation lines are approximated by a series of straight segments. This discretization, while computationally necessary, introduces geometric errors. This exercise explores how to quantify the error in local curvature—a key quantity driving dislocation motion via line tension—as a function of the segment length, providing crucial insight into the trade-offs between accuracy and computational cost [@problem_id:2878150]. By deriving a simple remeshing criterion, you will develop a practical understanding of how DDD simulations can maintain geometric fidelity.", "problem": "In Discrete Dislocation Dynamics (DDD), a closed dislocation loop is represented by a polyline with $N$ straight segments of equal length. The line-tension contribution to the Peach–Koehler force depends on the local curvature, which, for a smooth curve parameterized by arc length $s$ with tangent angle $\\phi(s)$, is defined as $ \\kappa = d\\phi/ds $. A commonly used discrete curvature estimator at a node $i$ joins two adjacent straight segments and takes $ \\kappa_{i}^{(d)} = \\theta_{i} / \\bar{\\ell}_{i} $, where $ \\theta_{i} $ is the turning angle between the two segments and $ \\bar{\\ell}_{i} $ is the average length of the adjacent segments. Assume uniform segmentation so that $ \\bar{\\ell}_{i} = \\ell $ for all $i$.\n  \nConsider a local region of the loop where the true curve is well-approximated by a circle of radius $R$ (so the true curvature is $ \\kappa = 1/R $). For an inscribed regular polygon approximation, the turning angle $ \\theta $ and the chord length $ \\ell $ satisfy the exact geometric relation $ \\ell = 2 R \\sin(\\theta/2) $. Starting from the fundamental definition $ \\kappa = d\\phi/ds $ and the stated discrete estimator $ \\kappa^{(d)} = \\theta/\\ell $, use small-angle expansions to derive the leading-order discretization error $ \\Delta \\kappa = \\kappa^{(d)} - \\kappa $ as a function of $ \\ell $ and $R$. Then, using this leading-order estimate, propose a remeshing criterion that guarantees the relative curvature error satisfies $ |\\Delta \\kappa|/\\kappa \\le \\varepsilon_{k} $, where $ \\varepsilon_{k} $ is a prescribed tolerance (dimensionless constant).\n  \nProvide your final answer as a single closed-form expression for the maximum allowable segment length $ \\ell_{\\max} $ in terms of $ \\kappa $ and $ \\varepsilon_{k} $. Do not include units in the final expression. If you derive intermediate expressions, you must present all mathematical entities in LaTeX. The final answer must be a single analytic expression.", "solution": "The problem statement is first subjected to validation.\n\nThe givens extracted from the statement are as follows:\n- The true curvature of a smooth curve is defined by $\\kappa = d\\phi/ds$, where $\\phi$ is the tangent angle and $s$ is the arc length.\n- A discrete curvature estimator at a node $i$ is given by $\\kappa_{i}^{(d)} = \\theta_{i} / \\bar{\\ell}_{i}$, where $\\theta_i$ is the turning angle and $\\bar{\\ell}_i$ is the average segment length.\n- For a uniform segmentation, $\\bar{\\ell}_{i} = \\ell$, so the estimator is $\\kappa^{(d)} = \\theta / \\ell$.\n- A local region of a dislocation loop is approximated by a circular arc of radius $R$, for which the true curvature is $\\kappa = 1/R$.\n- The discretization is an inscribed regular polygon, for which the chord length $\\ell$ and turning angle $\\theta$ are related by $\\ell = 2 R \\sin(\\theta/2)$.\n- The objective is to find the leading-order discretization error $\\Delta \\kappa = \\kappa^{(d)} - \\kappa$.\n- A further objective is to derive a remeshing criterion based on the relative error tolerance $|\\Delta \\kappa|/\\kappa \\le \\varepsilon_{k}$.\n- The final answer must be an expression for the maximum allowable segment length, $\\ell_{\\max}$, in terms of $\\kappa$ and $\\varepsilon_{k}$.\n\nThe problem is deemed valid. It is scientifically grounded within the field of Discrete Dislocation Dynamics and uses standard mathematical techniques for numerical error analysis. The problem is well-posed, self-contained, and all terms are objectively and precisely defined. There are no logical contradictions or factual inaccuracies.\n\nWe proceed to the solution. The task is to first derive the discretization error and then use it to establish a remeshing criterion.\n\nFirst, we must express the discrete curvature estimator $\\kappa^{(d)}$ in terms of the geometric parameters $R$ and $\\ell$. We are given the relations $\\kappa^{(d)} = \\theta/\\ell$ and $\\ell = 2 R \\sin(\\theta/2)$. From the second relation, we solve for the turning angle $\\theta$:\n$$\n\\frac{\\ell}{2R} = \\sin\\left(\\frac{\\theta}{2}\\right)\n$$\n$$\n\\theta = 2 \\arcsin\\left(\\frac{\\ell}{2R}\\right)\n$$\nThis is valid as the chord length $\\ell$ must be less than or equal to the diameter $2R$. Substituting this expression for $\\theta$ into the formula for $\\kappa^{(d)}$ yields:\n$$\n\\kappa^{(d)} = \\frac{2 \\arcsin\\left(\\frac{\\ell}{2R}\\right)}{\\ell}\n$$\nTo find the leading-order error, we assume the segment length $\\ell$ is small compared to the radius of curvature $R$. This corresponds to the limit $\\ell/R \\ll 1$, which is equivalent to a small turning angle $\\theta$. We use the Taylor series expansion for the inverse sine function, $\\arcsin(x)$, around $x=0$:\n$$\n\\arcsin(x) = x + \\frac{1}{6}x^3 + O(x^5)\n$$\nLetting $x = \\ell/(2R)$, the expansion becomes:\n$$\n\\arcsin\\left(\\frac{\\ell}{2R}\\right) = \\left(\\frac{\\ell}{2R}\\right) + \\frac{1}{6}\\left(\\frac{\\ell}{2R}\\right)^3 + O\\left(\\left(\\frac{\\ell}{R}\\right)^5\\right) = \\frac{\\ell}{2R} + \\frac{\\ell^3}{48R^3} + O(\\ell^5)\n$$\nNow, we substitute this series into our expression for $\\kappa^{(d)}$:\n$$\n\\kappa^{(d)} = \\frac{2}{\\ell} \\left[ \\frac{\\ell}{2R} + \\frac{\\ell^3}{48R^3} + O(\\ell^5) \\right]\n$$\nDistributing the $2/\\ell$ term, we obtain the expansion for the discrete curvature:\n$$\n\\kappa^{(d)} = \\frac{1}{R} + \\frac{\\ell^2}{24R^3} + O(\\ell^4)\n$$\nThe true curvature is given as $\\kappa = 1/R$. The discretization error $\\Delta \\kappa$ is defined as $\\kappa^{(d)} - \\kappa$. Therefore:\n$$\n\\Delta \\kappa = \\left( \\frac{1}{R} + \\frac{\\ell^2}{24R^3} + O(\\ell^4) \\right) - \\frac{1}{R} = \\frac{\\ell^2}{24R^3} + O(\\ell^4)\n$$\nThe leading-order discretization error is $\\Delta \\kappa \\approx \\frac{\\ell^2}{24R^3}$.\n\nNext, we establish the remeshing criterion based on the relative curvature error, $|\\Delta \\kappa|/\\kappa \\le \\varepsilon_{k}$. Since $\\ell$ and $R$ represent physical lengths, they are positive, which makes $\\Delta \\kappa$ positive. Thus, $|\\Delta \\kappa| = \\Delta \\kappa$. The relative error is:\n$$\n\\frac{\\Delta \\kappa}{\\kappa} \\approx \\frac{\\frac{\\ell^2}{24R^3}}{\\frac{1}{R}} = \\frac{\\ell^2}{24R^2}\n$$\nThe remeshing criterion is therefore:\n$$\n\\frac{\\ell^2}{24R^2} \\le \\varepsilon_{k}\n$$\nWe must now solve for the maximum allowable segment length, $\\ell_{\\max}$, and express it in terms of $\\kappa$ and $\\varepsilon_{k}$. We use the relation $R = 1/\\kappa$. The problem context implies a locally convex curve shape, so we take $R  0$ and $\\kappa  0$. Substituting $R=1/\\kappa$ into the inequality:\n$$\n\\frac{\\ell^2}{24(1/\\kappa)^2} \\le \\varepsilon_{k}\n$$\n$$\n\\frac{\\ell^2 \\kappa^2}{24} \\le \\varepsilon_{k}\n$$\nSolving for $\\ell^2$:\n$$\n\\ell^2 \\le \\frac{24\\varepsilon_{k}}{\\kappa^2}\n$$\nTaking the square root gives the upper bound for the segment length $\\ell$:\n$$\n\\ell \\le \\sqrt{\\frac{24\\varepsilon_{k}}{\\kappa^2}} = \\frac{\\sqrt{24\\varepsilon_{k}}}{\\kappa}\n$$\nSimplifying the radical term, $\\sqrt{24} = \\sqrt{4 \\cdot 6} = 2\\sqrt{6}$.\n$$\n\\ell \\le \\frac{2\\sqrt{6\\varepsilon_{k}}}{\\kappa}\n$$\nThe maximum allowable segment length, $\\ell_{\\max}$, corresponds to the equality:\n$$\n\\ell_{\\max} = \\frac{2\\sqrt{6\\varepsilon_{k}}}{\\kappa}\n$$\nThis expression provides the required remeshing criterion, relating the local mesh size to the local curvature and the prescribed error tolerance.", "answer": "$$\n\\boxed{\\frac{2\\sqrt{6\\varepsilon_{k}}}{\\kappa}}\n$$", "id": "2878150"}, {"introduction": "Building on the concept of discretization error, this advanced practice moves toward a more sophisticated, adaptive simulation strategy. Instead of using a uniform mesh, an efficient DDD code refines the discretization only where it is needed most—for instance, in regions of high curvature or rapidly changing forces. This exercise challenges you to design and implement such an adaptive remeshing algorithm based on local physical indicators, and to quantify its impact on the simulation's ability to accurately capture a critical physical phenomenon like cross-slip nucleation [@problem_id:3445395].", "problem": "You are given a stylized one-dimensional surrogate of a screw dislocation segment in the Discrete Dislocation Dynamics (DDD) framework, intended to isolate the numerical effects of adaptive segment remeshing based on local geometric and mechanical indicators. The dislocation is represented along a parameter coordinate $x \\in [0,L]$ with $L$ in meters, and is subjected to a spatially varying resolved shear stress field $\\tau(x)$ in Pascals. The Peach–Koehler force per unit length is $f(x)$ in Newtons per meter and satisfies $f(x) = \\tau(x)\\, b$, where $b$ in meters is the magnitude of the Burgers vector. In the small-slope, line-tension approximation, the static balance of an in-plane bowed dislocation segment with line tension $T$ in Newtons is captured by $T\\,\\kappa(x) \\approx f(x)$, where $\\kappa(x)$ in inverse meters is the local curvature. Cross-slip is assumed to be triggered if the resolved shear stress exceeds a critical value $\\tau_c$ over a contiguous spatial span of at least $l_c$ in meters along the segment; this is a surrogate condition to quantify how well the discretization resolves the stress landscape relevant for cross-slip nucleation.\n\nYour task is to propose and implement an adaptive segment remeshing criterion that refines the discretization based on two local indicators derived from the above fundamental relations:\n- A curvature indicator, constructed from the balance $T\\,\\kappa(x)\\approx f(x)$, that estimates the magnitude of curvature on a segment from endpoint data.\n- A force imbalance indicator, constructed from the Peach–Koehler force variation across a segment, that quantifies the local jump in $f(x)$ over the segment.\n\nStarting only from the fundamental relations $f(x) = \\tau(x)\\, b$ and $T\\,\\kappa(x) \\approx f(x)$, derive a segment-level criterion that triggers refinement when either the curvature magnitude indicator or the force imbalance indicator exceeds their respective thresholds. Then implement this criterion as an algorithm that starts from a coarse, uniform partition of $[0,L]$ and iteratively inserts midpoints of segments that violate the criterion, until no segment violates the thresholds or until a maximum number of nodes is reached or a minimum segment length constraint is met. The algorithm must be deterministic.\n\nUse the following physically plausible and self-consistent quantities, with the indicated units:\n- Domain length $L = 1.0\\times 10^{-6}$ meters.\n- Shear modulus $G = 7.6\\times 10^{10}$ Pascals.\n- Burgers vector magnitude $b = 2.55\\times 10^{-10}$ meters.\n- Line tension $T = \\alpha\\, G\\, b^2$ with $\\alpha = 0.5$ (dimensionless), hence $T$ is in Newtons.\n- Resolved shear stress field in Pascals given by\n$$\n\\tau(x) = \\tau_0 + A_1 \\sin\\left(\\frac{2\\pi x}{\\lambda}\\right) + A_2 \\exp\\!\\left(-\\frac{(x-x_0)^2}{2\\sigma^2}\\right),\n$$\nwith parameters $\\tau_0 = 1.10\\times 10^{8}$, $A_1 = 7.0\\times 10^{7}$, $\\lambda = 3.2\\times 10^{-7}$ meters, $A_2 = 8.0\\times 10^{7}$, $x_0 = 7.2\\times 10^{-7}$ meters, $\\sigma = 6.0\\times 10^{-8}$ meters.\n- Cross-slip criterion parameters: critical stress $\\tau_c = 1.60\\times 10^{8}$ Pascals, and critical contiguous length $l_c = 1.2\\times 10^{-7}$ meters.\n\nDefine the “ground-truth” cross-slip detection by sampling $\\tau(x)$ on a dense uniform grid of $N_{\\text{true}}$ points over $[0,L]$ with $N_{\\text{true}} = 20001$, thresholding at $\\tau_c$, and declaring a cross-slip event to be present if there exists at least one contiguous run of grid points above threshold whose physical length is at least $l_c$. Let $\\chi_{\\text{true}}(x)$ be the indicator function of points above threshold on this dense grid.\n\nDefine the “discretized” cross-slip detection as follows. Let $\\{x_i\\}$ denote the adaptively refined node positions, and let $\\tau_i = \\tau(x_i)$. Construct a piecewise-linear interpolant $\\tilde{\\tau}(x)$ from $\\{(x_i,\\tau_i)\\}$, sample $\\tilde{\\tau}(x)$ on the same dense grid, and repeat the above thresholding procedure to obtain $\\chi_{\\text{disc}}(x)$ and the discretized cross-slip event detection.\n\nQuantify the impact of the adaptive remeshing on cross-slip fidelity with two numbers per test case:\n- Existence agreement score $E$, defined as $E = 1.0$ if the presence/absence of a cross-slip event (according to the contiguous length condition with $l_c$) matches between the ground-truth and the discretized detection, and $E = 0.0$ otherwise. This score is dimensionless.\n- Jaccard similarity score $J$, defined on the dense grid as\n$$\nJ = \\frac{\\sum \\mathbf{1}\\{\\chi_{\\text{true}}(x) = 1 \\wedge \\chi_{\\text{disc}}(x) = 1\\}}{\\sum \\mathbf{1}\\{\\chi_{\\text{true}}(x) = 1 \\vee \\chi_{\\text{disc}}(x) = 1\\}},\n$$\nwith the convention that $J = 1.0$ if both sets are empty. This score is dimensionless.\n\nImplementation details and constraints:\n- Start the adaptive algorithm from a uniform grid of $n_0$ nodes, with $n_0 = 9$.\n- In each iteration, for each segment $[x_i,x_{i+1}]$, compute the curvature magnitude indicator from the segment endpoints using only the relations $f(x)=\\tau(x)\\, b$ and $T\\,\\kappa(x)\\approx f(x)$, and compute a force imbalance indicator from the jump of $f(x)$ across the segment. Refine by inserting the segment midpoint if either indicator exceeds its threshold.\n- Stop when no segment violates thresholds, or the number of nodes reaches $n_{\\max} = 4097$, or the minimum segment length would fall below $\\Delta x_{\\min} = 1.0\\times 10^{-9}$ meters.\n- Use the dense grid length $N_{\\text{true}} = 20001$ for both the ground-truth and discretized sampling.\n- All physical quantities used internally must be in SI units; the output $E$ and $J$ are dimensionless. The final results must be expressed as decimal numbers rounded to six digits after the decimal point.\n\nTest suite:\nProvide results for the following four threshold pairs, which are designed to exercise different aspects of the criterion. Units: curvature threshold $|\\kappa|_{\\text{th}}$ in inverse meters, force imbalance threshold $\\|\\Delta \\mathbf{F}\\|_{\\text{th}}$ in Newtons per meter.\n- Case A (tight, balanced): $|\\kappa|_{\\text{th}} = 1.5\\times 10^{8}$, $\\|\\Delta \\mathbf{F}\\|_{\\text{th}} = 1.0\\times 10^{-2}$.\n- Case B (loose, balanced): $|\\kappa|_{\\text{th}} = 6.0\\times 10^{8}$, $\\|\\Delta \\mathbf{F}\\|_{\\text{th}} = 6.0\\times 10^{-2}$.\n- Case C (curvature-dominated): $|\\kappa|_{\\text{th}} = 1.5\\times 10^{8}$, $\\|\\Delta \\mathbf{F}\\|_{\\text{th}} = 1.0$.\n- Case D (force-variation-dominated): $|\\kappa|_{\\text{th}} = 1.0\\times 10^{12}$, $\\|\\Delta \\mathbf{F}\\|_{\\text{th}} = 1.0\\times 10^{-2}$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list of four entries, each entry itself being a two-element list of the form $[E,J]$ rounded to six decimals. For example, the output format must be exactly like\n[[0.000000,0.123456],[1.000000,0.987654],[1.000000,1.000000],[0.000000,0.000000]]\nwith no additional text.", "solution": "The problem requires the development and implementation of an adaptive mesh refinement algorithm for a one-dimensional surrogate model of a screw dislocation segment. The refinement strategy is to be based on local physical indicators derived from the fundamental equations of dislocation mechanics. The effectiveness of the algorithm is then evaluated by its ability to accurately capture a surrogate condition for cross-slip nucleation, which depends on resolving high-stress regions.\n\nFirst, we establish the physical and mathematical framework. The dislocation segment is parametrized by $x \\in [0, L]$. The resolved shear stress is given by a function $\\tau(x)$, which exerts a Peach-Koehler force per unit length on the dislocation, $f(x) = \\tau(x) b$, where $b$ is the magnitude of the Burgers vector. In the line tension approximation for small curvatures, the static equilibrium of the dislocation shape is governed by the balance between the line tension $T$ and the Peach-Koehler force:\n$$\nT \\kappa(x) \\approx f(x)\n$$\nwhere $\\kappa(x)$ is the local curvature of the dislocation line. The line tension $T$ itself is approximated as $T=\\alpha G b^2$, where $G$ is the shear modulus and $\\alpha$ is a dimensionless factor of order unity.\n\nThe core of the task is to derive and implement local refinement indicators based on these relations. We consider a single discrete segment of the dislocation line, defined by the nodes at positions $x_i$ and $x_{i+1}$.\n\n1.  **Curvature Indicator ($I_\\kappa$)**: The relation $T\\kappa(x) \\approx f(x)$ links the local curvature to the local force. To create a segment-level indicator, we need to estimate a representative curvature for the segment $[x_i, x_{i+1}]$. A simple and robust estimate is to use the average force on the segment, which can be approximated by the arithmetic mean of the forces at its endpoints: $\\bar{f}_i = \\frac{f(x_i) + f(x_{i+1})}{2}$. This leads to an estimated average curvature magnitude for the segment:\n    $$\n    I_\\kappa = |\\bar{\\kappa}_i| \\approx \\left| \\frac{\\bar{f}_i}{T} \\right| = \\left| \\frac{f(x_i) + f(x_{i+1})}{2T} \\right|\n    $$\n    A segment is flagged for refinement if this estimated curvature magnitude exceeds a specified threshold, $I_\\kappa > |\\kappa|_{\\text{th}}$. This criterion ensures that regions of high bowing (high force) are adequately resolved.\n\n2.  **Force Imbalance Indicator ($I_f$)**: A coarse discretization may fail to capture rapid spatial variations in the stress field. A segment that spans a region of high stress gradient will have a large difference in the Peach-Koehler force between its endpoints. This \"force imbalance\" serves as an excellent indicator for refinement. We define it as the magnitude of the difference in the force per unit length at the segment's endpoints:\n    $$\n    I_f = |f(x_{i+1}) - f(x_i)|\n    $$\n    A segment is flagged for refinement if this force difference exceeds a threshold, $I_f > \\|\\Delta \\mathbf{F}\\|_{\\text{th}}$. The units of $I_f$ and $\\|\\Delta \\mathbf{F}\\|_{\\text{th}}$ are Newtons per meter (N/m), consistent with the problem statement. This criterion ensures that regions with large changes in the applied force are refined.\n\nThe adaptive remeshing algorithm proceeds as follows:\n-   Start with an initial uniform grid of $n_0 = 9$ nodes on the domain $[0, L]$.\n-   Enter an iterative loop. In each iteration:\n    -   A list of midpoints to be added is initialized.\n    -   For each segment $[x_i, x_{i+1}]$ in the current mesh, calculate the indicators $I_\\kappa$ and $I_f$.\n    -   If $I_\\kappa > |\\kappa|_{\\text{th}}$ or $I_f > \\|\\Delta \\mathbf{F}\\|_{\\text{th}}$, the midpoint of the segment, $(x_i + x_{i+1})/2$, is marked for addition.\n    -   The loop terminates if no segments are marked for refinement in an iteration, or if the total number of nodes reaches a maximum of $n_{\\max} = 4097$, or if adding a midpoint would create a segment smaller than $\\Delta x_{\\min} = 1.0\\times 10^{-9}$ m.\n    -   After checking all segments, the unique marked midpoints are added to the list of nodes, and the list is sorted to form the mesh for the next iteration. This batch-update procedure ensures the algorithm is deterministic.\n\nTo evaluate fidelity, we compare results from the adaptive mesh to a \"ground truth\". The ground truth is established by analyzing the analytical stress function $\\tau(x)$ on a very dense uniform grid of $N_{\\text{text}} = 20001$ points. On this grid, we identify all regions where $\\tau(x) > \\tau_c$. We then check if any of these contiguous super-critical regions have a physical length of at least $l_c$. This determines the ground-truth presence or absence of a cross-slip event. The set of points where $\\tau(x) > \\tau_c$ is denoted by the indicator function $\\chi_{\\text{true}}(x)$.\n\nFor the discretized case, we first obtain the final set of nodes $\\{x_i\\}$ from the adaptive algorithm. We evaluate the stress $\\tau_i = \\tau(x_i)$ at these nodes and construct a piecewise-linear interpolant $\\tilde{\\tau}(x)$. This interpolated stress field is then sampled on the same dense grid of $N_{\\text{true}}$ points, and the same cross-slip criterion (thresholding at $\\tau_c$ and checking for a contiguous length of $l_c$) is applied. This yields the discretized cross-slip event detection and the corresponding indicator function $\\chi_{\\text{disc}}(x)$.\n\nThe comparison is quantified by two metrics:\n-   **Existence Agreement ($E$)**: $E=1.0$ if the ground-truth and discretized cases agree on the existence of a cross-slip event, and $E=0.0$ otherwise.\n-   **Jaccard Similarity ($J$)**: Measures the overlap of the super-critical regions on the dense grid:\n    $$\n    J = \\frac{\\sum \\mathbf{1}\\{\\chi_{\\text{true}}(x) = 1 \\wedge \\chi_{\\text{disc}}(x) = 1\\}}{\\sum \\mathbf{1}\\{\\chi_{\\text{true}}(x) = 1 \\vee \\chi_{\\text{disc}}(x) = 1\\}}\n    $$\n    where $\\mathbf{1}\\{\\cdot\\}$ is the indicator function. By convention, $J=1.0$ if both the true and discretized super-critical sets are empty.\n\nThe implementation uses the provided physical constants in SI units: domain length $L = 1.0\\times 10^{-6}$ m, shear modulus $G = 7.6\\times 10^{10}$ Pa, Burgers vector $b = 2.55\\times 10^{-10}$ m, line tension coefficient $\\alpha = 0.5$, critical stress $\\tau_c = 1.60\\times 10^{8}$ Pa, and critical length $l_c = 1.2\\times 10^{-7}$ m. The stress field $\\tau(x)$ is computed with its given parameters: $\\tau_0 = 1.10\\times 10^{8}$, $A_1 = 7.0\\times 10^{7}$, $\\lambda = 3.2\\times 10^{-7}$, $A_2 = 8.0\\times 10^{7}$, $x_0 = 7.2\\times 10^{-7}$, and $\\sigma = 6.0\\times 10^{-8}$. The algorithm is run for four distinct pairs of thresholds $(|\\kappa|_{\\text{th}}, \\|\\Delta \\mathbf{F}\\|_{\\text{th}})$ to assess the performance of the refinement criteria under different conditions. The final scores $E$ and $J$ for each case are calculated and reported to six decimal places.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the adaptive remeshing problem for a 1D dislocation segment.\n    \"\"\"\n    # ----------------------------------------------------------------------\n    # 1. Define physical constants, functions, and problem parameters\n    # ----------------------------------------------------------------------\n    # All quantities are in base SI units (meters, Pascals, Newtons, etc.)\n\n    # Domain and material properties\n    L = 1.0e-6  # meters\n    G = 7.6e10  # Pascals (Shear modulus)\n    b = 2.55e-10  # meters (Burgers vector magnitude)\n    alpha = 0.5  # dimensionless\n    T = alpha * G * b**2  # Newtons (Line tension)\n\n    # Stress field parameters\n    tau_0 = 1.10e8\n    A_1 = 7.0e7\n    lambda_ = 3.2e-7\n    A_2 = 8.0e7\n    x_0 = 7.2e-7\n    sigma = 6.0e-8\n\n    # Cross-slip criterion parameters\n    tau_c = 1.60e8\n    l_c = 1.2e-7\n\n    # Numerical parameters\n    n0 = 9\n    n_max = 4097\n    dx_min = 1.0e-9\n    N_true = 20001\n\n    def tau_field(x):\n        \"\"\"Calculates the resolved shear stress at position(s) x.\"\"\"\n        term1 = A_1 * np.sin(2 * np.pi * x / lambda_)\n        term2 = A_2 * np.exp(-(x - x_0)**2 / (2 * sigma**2))\n        return tau_0 + term1 + term2\n\n    def force_field(x):\n        \"\"\"Calculates the Peach-Koehler force per unit length.\"\"\"\n        return tau_field(x) * b\n\n    def check_cross_slip(chi_mask, dx):\n        \"\"\"\n        Determines if a cross-slip event occurs based on a boolean mask.\n        An event occurs if a contiguous region of True values has a\n        physical length of at least l_c.\n        \"\"\"\n        if not np.any(chi_mask):\n            return False\n        \n        # Minimum number of consecutive points to meet the critical length l_c\n        min_len_pts = np.ceil(l_c / dx)\n        \n        # Find start and end points of contiguous True blocks\n        padded_mask = np.concatenate(([False], chi_mask, [False]))\n        diff = np.diff(padded_mask.astype(int))\n        starts = np.where(diff == 1)[0]\n        ends = np.where(diff == -1)[0]\n        \n        if starts.size == 0:\n            return False\n        \n        lengths = ends - starts\n        return np.any(lengths = min_len_pts)\n\n    # ----------------------------------------------------------------------\n    # 2. Calculate Ground Truth\n    # ----------------------------------------------------------------------\n    x_dense = np.linspace(0, L, N_true)\n    dx_dense = L / (N_true - 1)\n    \n    tau_true = tau_field(x_dense)\n    chi_true = tau_true  tau_c\n    ground_truth_event_exists = check_cross_slip(chi_true, dx_dense)\n\n    # ----------------------------------------------------------------------\n    # 3. Main loop over test cases\n    # ----------------------------------------------------------------------\n    test_cases = [\n        # Case A (tight, balanced)\n        {'kappa_th': 1.5e8, 'f_imbalance_th': 1.0e-2},\n        # Case B (loose, balanced)\n        {'kappa_th': 6.0e8, 'f_imbalance_th': 6.0e-2},\n        # Case C (curvature-dominated)\n        {'kappa_th': 1.5e8, 'f_imbalance_th': 1.0},\n        # Case D (force-variation-dominated)\n        {'kappa_th': 1.0e12, 'f_imbalance_th': 1.0e-2},\n    ]\n\n    results_list = []\n    for case in test_cases:\n        kappa_th = case['kappa_th']\n        f_imbalance_th = case['f_imbalance_th']\n        \n        # --- Adaptive Remeshing ---\n        nodes = np.linspace(0.0, L, n0)\n        \n        while True:\n            # Check for node count termination\n            if len(nodes) = n_max:\n                break\n                \n            midpoints_to_add = []\n            \n            # Identify all segments that need refinement\n            for i in range(len(nodes) - 1):\n                x_i, x_i_plus_1 = nodes[i], nodes[i+1]\n                \n                # Check min segment length constraint before proposing refinement\n                if (x_i_plus_1 - x_i) / 2.0  dx_min:\n                    continue\n                \n                f_i = force_field(x_i)\n                f_i_plus_1 = force_field(x_i_plus_1)\n                \n                # Curvature indicator\n                I_kappa = np.abs((f_i + f_i_plus_1) / (2.0 * T))\n                \n                # Force imbalance indicator\n                I_f = np.abs(f_i_plus_1 - f_i)\n                \n                # Check refinement condition\n                if I_kappa  kappa_th or I_f  f_imbalance_th:\n                    midpoints_to_add.append((x_i + x_i_plus_1) / 2.0)\n            \n            # If no segments were marked for refinement, the mesh has converged\n            if not midpoints_to_add:\n                break\n            \n            # Add unique midpoints to the mesh and sort\n            nodes = np.union1d(nodes, midpoints_to_add)\n\n        # --- Discretized Analysis ---\n        tau_at_nodes = tau_field(nodes)\n        tau_disc = np.interp(x_dense, nodes, tau_at_nodes)\n        chi_disc = tau_disc  tau_c\n        discretized_event_exists = check_cross_slip(chi_disc, dx_dense)\n\n        # --- Score Calculation ---\n        # Existence agreement score (E)\n        E = 1.0 if ground_truth_event_exists == discretized_event_exists else 0.0\n        \n        # Jaccard similarity score (J)\n        intersection = np.sum(np.logical_and(chi_true, chi_disc))\n        union = np.sum(np.logical_or(chi_true, chi_disc))\n        \n        J = 1.0 if union == 0 else float(intersection) / float(union)\n        \n        # Format and store result for this case\n        results_list.append(f\"[{E:.6f},{J:.6f}]\")\n\n    # ----------------------------------------------------------------------\n    # 4. Final Output Formatting\n    # ----------------------------------------------------------------------\n    final_output_string = f\"[{','.join(results_list)}]\"\n    print(final_output_string)\n\nsolve()\n```", "id": "3445395"}]}