{"hands_on_practices": [{"introduction": "The effectiveness of a Dissipative Particle Dynamics (DPD) simulation hinges on the choice of its parameters. This exercise [@problem_id:3446089] delves into a systematic \"bottom-up\" parameterization technique known as force-matching. You will learn how to reconstruct the conservative DPD force field from synthetic, atomistic-scale force data, providing a practical foundation for building models that quantitatively reproduce the structural and thermodynamic properties of a target system.", "problem": "You are given a physically motivated, self-consistent, synthetic coarse-graining task to reconstruct a Dissipative Particle Dynamics (DPD) conservative force from atomistic-like pairwise force data and to test transferability across temperature and density. Work in reduced DPD units with cutoff length $r_c = 1$, Boltzmann constant $k_B = 1$, and time units such that all quantities are dimensionless. The conservative pairwise force between coarse-grained beads is assumed radial and factorable as\n$$\n\\mathbf{F}^C(r) = f(r)\\,\\hat{\\mathbf{r}} = a(r)\\,w^C(r)\\,\\hat{\\mathbf{r}}, \\quad r \\le r_c, \\quad \\mathbf{F}^C(r) = \\mathbf{0} \\text{ for } r > r_c,\n$$\nwith a fixed weight function\n$$\nw^C(r) = \\max\\{0,\\,1 - r\\}.\n$$\nYour task is to reconstruct the radial scalar $a(r)$ from synthetic atomistic training samples by least-squares force-matching and then evaluate model consistency with both the radial distribution function and the pressure. You must use the following fundamental base and widely accepted relations:\n- Newton’s second law for pairwise central forces.\n- Definition of the radial distribution function $g(r)$ for an isotropic fluid.\n- Virial expression for the pressure of a pairwise interacting isotropic fluid:\n$$\np(\\rho, T) = \\rho\\,T + \\frac{2\\pi}{3}\\,\\rho^2 \\int_{0}^{r_c} r^3 f(r)\\,g(r)\\,dr.\n$$\n- Linear regression (least squares) for parameter estimation.\n- For a pairwise conservative force derivable from a potential $U(r)$ with $U(r_c) = 0$, $f(r) = -\\frac{dU}{dr}$ and the equilibrium radial distribution at temperature $T$ is\n$$\ng(r;T) = \\exp\\left(-\\frac{U(r)}{T}\\right), \\quad U(r) = \\int_{r}^{r_c} f(s)\\,ds.\n$$\nThese relations are the only permitted bases to derive your method.\n\nSynthetic atomistic-like training data are generated from a known ground-truth force family\n$$\nf_{\\mathrm{true}}(r) = A\\,\\bigl(1 - r\\bigr)^{m}, \\quad r \\le 1, \\quad f_{\\mathrm{true}}(r) = 0 \\text{ for } r>1,\n$$\nwith parameters $A > 0$ and exponent $m \\in \\{1,2\\}$. Under the assumed DPD factorization with the fixed $w^C(r)$ above, this corresponds to a ground-truth amplitude $a_{\\mathrm{true}}(r) = A\\,(1 - r)^{m-1}$ for $r \\le 1$.\n\nYou must:\n1. Represent the unknown amplitude as a polynomial of degree $P$,\n$$\na(r) \\approx \\sum_{n=0}^{P} c_n\\,r^n, \\quad r \\in [0,1],\n$$\nso that the model force is\n$$\nf_{\\mathrm{model}}(r) = w^C(r)\\,\\sum_{n=0}^{P} c_n\\,r^n, \\quad r \\in [0,1].\n$$\n2. Perform force-matching by minimizing the mean squared error between $f_{\\mathrm{model}}(r)$ and $f_{\\mathrm{true}}(r)$ over a dense set of $r$ values in $[0,1]$. Use a Tikhonov regularization term $\\lambda \\lVert \\mathbf{c} \\rVert_2^2$ with a small $\\lambda > 0$ for numerical stability. You must solve the regularized least squares problem exactly (no stochastic methods).\n3. From $f_{\\mathrm{model}}(r)$, reconstruct $U_{\\mathrm{model}}(r)$ and compute $g_{\\mathrm{model}}(r;T)$ for any specified $T$ using the relation above. Similarly, compute $U_{\\mathrm{true}}(r)$ and $g_{\\mathrm{true}}(r;T)$ from $f_{\\mathrm{true}}(r)$ for comparison.\n4. Evaluate the training-state and transfer-state pressures using the virial integral with $g_{\\mathrm{model}}(r;T)$ and $g_{\\mathrm{true}}(r;T)$ respectively, and report absolute pressure errors.\n5. Quantify the force reconstruction error by the root-mean-square error (RMSE) between $f_{\\mathrm{model}}(r)$ and $f_{\\mathrm{true}}(r)$ over a uniform grid on $[0,1]$.\n\nUnit conventions and output requirements:\n- All quantities are dimensionless in reduced DPD units with $r_c = 1$, $k_B = 1$, pressure in units of $k_B T / r_c^3$, density in $r_c^{-3}$, and temperature in $k_B T$.\n- Angles do not appear; no angle units are needed.\n- Your program must produce the requested outputs as floating-point numbers.\n\nTest suite:\nImplement your solver and evaluate the following three test cases, each defined by $(A, m, T_{\\mathrm{train}}, \\rho_{\\mathrm{train}}, T_{\\mathrm{test}}, \\rho_{\\mathrm{test}})$:\n- Case 1 (happy path): $(25.0,\\,1,\\,1.0,\\,3.0,\\,0.5,\\,5.0)$.\n- Case 2 (shape mismatch): $(8.0,\\,2,\\,1.0,\\,3.0,\\,2.0,\\,2.0)$.\n- Case 3 (boundary; zero conservative force): $(0.0,\\,1,\\,1.0,\\,4.0,\\,1.5,\\,6.0)$.\n\nFor each case, compute and return three floats:\n- The force RMSE on $[0,1]$ between $f_{\\mathrm{model}}$ and $f_{\\mathrm{true}}$.\n- The absolute error in the pressure at the training state $(T_{\\mathrm{train}}, \\rho_{\\mathrm{train}})$.\n- The absolute error in the pressure at the transfer state $(T_{\\mathrm{test}}, \\rho_{\\mathrm{test}})$.\n\nFinal output format:\nYour program should produce a single line of output containing the nine results for Cases 1–3, in order, as a comma-separated list enclosed in square brackets, with each float rounded to six decimal places, precisely:\n[rmse1,dp_train1,dp_test1,rmse2,dp_train2,dp_test2,rmse3,dp_train3,dp_test3]\n\nImportant constraints:\n- Use a deterministic, dense uniform grid for all integrals and fitting over $r \\in [0,1]$.\n- Use a polynomial degree $P \\ge 3$ and a small positive regularization parameter $\\lambda$ for numerical stability.\n- Do not use any external datasets; all necessary quantities must be computed from the synthetic definitions above.", "solution": "The problem requires the reconstruction of a Dissipative Particle Dynamics (DPD) conservative force from synthetic data, followed by an evaluation of the model's accuracy and transferability. The solution involves numerical methods for function approximation, integration, and the application of fundamental principles from statistical mechanics. The entire process is conducted in reduced DPD units where the cutoff radius is $r_c=1$ and the Boltzmann constant is $k_B=1$.\n\nThe solution methodology is as follows:\n\nFirst, we establish the mathematical framework for the force model and the fitting procedure. The ground-truth conservative force is given by $f_{\\mathrm{true}}(r) = A(1-r)^m$ for $r \\in [0,1]$. The DPD force model is parameterized as $f_{\\mathrm{model}}(r) = a(r)w^C(r)$, where $w^C(r) = 1-r$ is a fixed weight function. The amplitude function $a(r)$ is approximated by a polynomial of degree $P$:\n$$\na(r) \\approx a_{\\mathrm{model}}(r) = \\sum_{n=0}^{P} c_n r^n\n$$\nThus, the model for the conservative force is:\n$$\nf_{\\mathrm{model}}(r) = \\left( \\sum_{n=0}^{P} c_n r^n \\right) (1-r)\n$$\nThe unknown coefficients $\\mathbf{c} = [c_0, c_1, \\dots, c_P]^T$ are determined by minimizing the regularized sum of squared errors between the model force and the true force over a discrete set of points $\\{r_i\\}_{i=0}^{N-1}$ on the interval $[0,1]$. This is a Tikhonov-regularized least-squares problem. The objective function to minimize is:\n$$\nL(\\mathbf{c}) = \\sum_{i=0}^{N-1} \\left( f_{\\mathrm{model}}(r_i) - f_{\\mathrm{true}}(r_i) \\right)^2 + \\lambda \\sum_{n=0}^{P} c_n^2\n$$\nwhere $\\lambda > 0$ is a small regularization parameter for numerical stability. This problem can be cast into matrix form. Let $\\mathbf{y}$ be a vector with elements $y_i = f_{\\mathrm{true}}(r_i)$ and $\\mathbf{M}$ be an $N \\times (P+1)$ design matrix with elements $M_{in} = (1-r_i)r_i^n$. The objective function becomes $\\min_{\\mathbf{c}} \\lVert \\mathbf{M}\\mathbf{c} - \\mathbf{y} \\rVert_2^2 + \\lambda \\lVert \\mathbf{c} \\rVert_2^2$. The optimal coefficient vector $\\mathbf{c}$ is the solution to the normal equations:\n$$\n(\\mathbf{M}^T\\mathbf{M} + \\lambda\\mathbf{I})\\mathbf{c} = \\mathbf{M}^T\\mathbf{y}\n$$\nwhere $\\mathbf{I}$ is the identity matrix. This linear system is solved for $\\mathbf{c}$. For numerical implementation, we choose a polynomial degree $P=5$, a grid of $N=2001$ points for $r \\in [0,1]$, and a regularization parameter $\\lambda=10^{-12}$.\n\nSecond, once the model force $f_{\\mathrm{model}}(r)$ is determined, we compute the relevant physical properties. The pairwise potential $U(r)$ is obtained by integrating the force from $r$ to the cutoff $r_c=1$:\n$$\nU(r) = \\int_{r}^{1} f(s) ds\n$$\nThis integral is computed numerically for both $f_{\\mathrm{true}}$ and $f_{\\mathrm{model}}$ using a reverse cumulative trapezoidal rule on the discrete grid. From the potential, the radial distribution function $g(r;T)$ at a given temperature $T$ is given by the Boltzmann factor:\n$$\ng(r;T) = \\exp\\left(-\\frac{U(r)}{T}\\right)\n$$\nThis relationship allows us to compute $g_{\\mathrm{true}}(r;T)$ and $g_{\\mathrm{model}}(r;T)$.\n\nThird, we evaluate the system pressure using the virial expression for an isotropic fluid with pairwise interactions:\n$$\np(\\rho, T) = \\rho T + \\frac{2\\pi}{3}\\rho^2 \\int_{0}^{1} r^3 f(r)g(r;T)dr\n$$\nThe integral term, representing the contribution from interactions, is calculated numerically using the trapezoidal rule over the grid. This procedure is applied to both the true and model systems at the specified training $(\\rho_{\\mathrm{train}}, T_{\\mathrm{train}})$ and transfer $(\\rho_{\\mathrm{test}}, T_{\\mathrm{test}})$ state points.\n\nFinally, the quality of the model is quantified by three metrics for each test case:\n1.  The Root-Mean-Square Error (RMSE) of the force reconstruction, calculated as $\\sqrt{\\frac{1}{N}\\sum_{i=0}^{N-1} (f_{\\mathrm{model}}(r_i) - f_{\\mathrm{true}}(r_i))^2}$.\n2.  The absolute error in pressure at the training state, $|p_{\\mathrm{model}}(\\rho_{\\mathrm{train}}, T_{\\mathrm{train}}) - p_{\\mathrm{true}}(\\rho_{\\mathrm{train}}, T_{\\mathrm{train}})|$.\n3.  The absolute error in pressure at the transfer state, $|p_{\\mathrm{model}}(\\rho_{\\mathrm{test}}, T_{\\mathrm{test}}) - p_{\\mathrm{true}}(\\rho_{\\mathrm{test}}, T_{\\mathrm{test}})|$.\n\nThis comprehensive approach allows for a rigorous test of the DPD force field reconstruction, assessing not only the direct fit to the force but also the consistency with derived thermodynamic properties like the pressure under different conditions.", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import cumulative_trapezoid\n\ndef solve():\n    \"\"\"\n    Solves the DPD force-matching problem for the given test cases.\n    \"\"\"\n\n    # Numerical parameters\n    N_GRID = 2001  # Number of points for discretization of r in [0, 1]\n    P_DEGREE = 5   # Polynomial degree for a(r)\n    LAMBDA = 1e-12 # Tikhonov regularization parameter\n\n    # Define the radial grid\n    r_grid = np.linspace(0.0, 1.0, N_GRID)\n\n    def calculate_pressure(f_vals, r_vals, T, rho):\n        \"\"\"\n        Calculates pressure from force using the virial theorem.\n        \n        Args:\n            f_vals (np.ndarray): Array of force values on the grid.\n            r_vals (np.ndarray): Radial grid.\n            T (float): Temperature.\n            rho (float): Density.\n            \n        Returns:\n            float: The calculated pressure.\n        \"\"\"\n        # 1. Compute potential U(r) = integral_r^1 f(s) ds\n        # Use cumulative_trapezoid for integral from 0 to r, then subtract from total.\n        integral_0_to_r = cumulative_trapezoid(f_vals, r_vals, initial=0.0)\n        total_integral = integral_0_to_r[-1]\n        U_vals = total_integral - integral_0_to_r\n        \n        # 2. Compute radial distribution function g(r) = exp(-U(r)/T)\n        # Handle potential division by zero if T is very small, though not in test cases.\n        if T == 0:\n            # Physically, g(r) would be a step function, but for this problem T>0.\n            # This branch is for robustness and not expected to be hit.\n            g_vals = np.zeros_like(U_vals)\n        else:\n            g_vals = np.exp(-U_vals / T)\n        \n        # 3. Compute pressure via virial expression\n        # p = rho*T + (2*pi/3)*rho^2 * integral_0^1 r^3 * f(r) * g(r) dr\n        integrand = (r_vals**3) * f_vals * g_vals\n        pressure_integral = np.trapz(integrand, r_vals)\n        \n        p = rho * T + (2.0 * np.pi / 3.0) * (rho**2) * pressure_integral\n        return p\n\n    def process_case(A, m, T_train, rho_train, T_test, rho_test):\n        \"\"\"\n        Processes a single test case.\n        \n        Returns:\n            tuple: (force_rmse, pressure_error_train, pressure_error_test)\n        \"\"\"\n        # --- 1. Ground Truth and Model Setup ---\n        f_true = A * (1.0 - r_grid)**m\n        \n        # --- 2. Force Matching via Regularized Least Squares ---\n        # Construct the design matrix M where M_in = (1-r_i) * r_i^n\n        M = np.zeros((N_GRID, P_DEGREE + 1))\n        for n in range(P_DEGREE + 1):\n            M[:, n] = (1.0 - r_grid) * (r_grid**n)\n        \n        # Solve the normal equations: (M^T*M + lambda*I) * c = M^T * y\n        y = f_true\n        lhs = M.T @ M + LAMBDA * np.identity(P_DEGREE + 1)\n        rhs = M.T @ y\n        c = np.linalg.solve(lhs, rhs)\n        \n        # Reconstruct the model force\n        f_model = M @ c\n        \n        # --- 3. Calculate Error Metrics ---\n        # Force RMSE\n        force_rmse = np.sqrt(np.mean((f_model - f_true)**2))\n        \n        # Pressure at training state\n        p_true_train = calculate_pressure(f_true, r_grid, T_train, rho_train)\n        p_model_train = calculate_pressure(f_model, r_grid, T_train, rho_train)\n        pressure_error_train = abs(p_model_train - p_true_train)\n        \n        # Pressure at test state\n        p_true_test = calculate_pressure(f_true, r_grid, T_test, rho_test)\n        p_model_test = calculate_pressure(f_model, r_grid, T_test, rho_test)\n        pressure_error_test = abs(p_model_test - p_true_test)\n        \n        return force_rmse, pressure_error_train, pressure_error_test\n\n    # Define test cases from the problem statement\n    test_cases = [\n        # (A, m, T_train, rho_train, T_test, rho_test)\n        (25.0, 1, 1.0, 3.0, 0.5, 5.0), # Case 1\n        (8.0, 2, 1.0, 3.0, 2.0, 2.0),  # Case 2\n        (0.0, 1, 1.0, 4.0, 1.5, 6.0)   # Case 3\n    ]\n\n    all_results = []\n    for case in test_cases:\n        rmse, dp_train, dp_test = process_case(*case)\n        all_results.append(f\"{rmse:.6f}\")\n        all_results.append(f\"{dp_train:.6f}\")\n        all_results.append(f\"{dp_test:.6f}\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "3446089"}, {"introduction": "A correct simulation code must respect the fundamental symmetries of the underlying physics. This practice [@problem_id:3446073] focuses on validating one such symmetry—rotational invariance—by directly testing for the conservation of angular momentum. By contrasting a correct central-force implementation with a non-central one, you will quantify the emergence of spurious torques and gain a deeper appreciation for why central, pairwise forces are essential for physically realistic simulations.", "problem": "You are asked to validate rotational invariance in a pairwise mesoscale particle model by measuring angular momentum conservation and quantifying spurious torques. Work in reduced dissipative particle dynamics units where all quantities are dimensionless. Consider a system of $N$ point particles in three dimensions with positions $\\mathbf{r}_i \\in \\mathbb{R}^3$, velocities $\\mathbf{v}_i \\in \\mathbb{R}^3$, and equal masses $m$. The time variable is $t$. The goal is to compute the net internal torque $\\boldsymbol{\\tau}(t)$ about the origin and the change in total angular momentum $\\Delta \\mathbf{L} = \\mathbf{L}(t+\\Delta t) - \\mathbf{L}(t)$ across a single explicit Euler time step for two different pairwise interaction models: a rotationally invariant central model and a deliberately non-central model that violates rotational invariance.\n\nStart from the following fundamental base:\n- Newton’s second law for particle $i$: $$m \\frac{d \\mathbf{v}_i}{d t} = \\sum_{j \\neq i} \\mathbf{F}_{ij},$$ where $\\mathbf{F}_{ij}$ is the force on particle $i$ due to particle $j$.\n- Newton’s third law: $$\\mathbf{F}_{ij} = - \\mathbf{F}_{ji}.$$\n- Definition of total angular momentum about the origin: $$\\mathbf{L}(t) = \\sum_{i=1}^{N} m \\, \\mathbf{r}_i(t) \\times \\mathbf{v}_i(t).$$\n- Definition of net internal torque about the origin: $$\\boldsymbol{\\tau}(t) = \\sum_{i=1}^{N} \\mathbf{r}_i(t) \\times \\left( \\sum_{j \\neq i} \\mathbf{F}_{ij}(t) \\right).$$\n\nImplement the following deterministic pairwise force models with a cut-off radius $r_c$, without any stochastic forces:\n\n1. Rotationally invariant central model. For a pair separation vector $\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$, separation $r_{ij} = \\|\\mathbf{r}_{ij}\\|$, and unit vector $\\hat{\\mathbf{r}}_{ij} = \\mathbf{r}_{ij} / r_{ij}$, define the conservative weight $w_C(r_{ij}) = 1 - r_{ij}/r_c$ for $r_{ij} < r_c$ and $w_C(r_{ij}) = 0$ otherwise. Define $w_D(r_{ij}) = \\left[w_C(r_{ij})\\right]^2$. The conservative and dissipative forces are:\n$$\\mathbf{F}_{ij}^{C} = a \\, w_C(r_{ij}) \\, \\hat{\\mathbf{r}}_{ij}, \\quad \\mathbf{F}_{ij}^{D} = - \\gamma \\, w_D(r_{ij}) \\left( \\left( \\mathbf{v}_i - \\mathbf{v}_j \\right) \\cdot \\hat{\\mathbf{r}}_{ij} \\right) \\hat{\\mathbf{r}}_{ij},$$\nand the total pairwise force is $\\mathbf{F}_{ij} = \\mathbf{F}_{ij}^{C} + \\mathbf{F}_{ij}^{D}$ if $r_{ij} < r_c$, and $\\mathbf{F}_{ij} = \\mathbf{0}$ otherwise.\n\n2. Non-central (bug) model. Use the same $\\mathbf{F}_{ij}^{C}$ as above, but replace the dissipative force by a non-central form\n$$\\mathbf{F}_{ij}^{D,\\mathrm{bug}} = - \\gamma \\, w_D(r_{ij}) \\left( \\mathbf{v}_i - \\mathbf{v}_j \\right),$$\nso that the total pairwise force is $\\mathbf{F}_{ij} = \\mathbf{F}_{ij}^{C} + \\mathbf{F}_{ij}^{D,\\mathrm{bug}}$ if $r_{ij} < r_c$, and $\\mathbf{F}_{ij} = \\mathbf{0}$ otherwise. This model preserves linear momentum (by symmetry) but violates rotational invariance because the dissipative term is not central.\n\nNumerical procedure to be implemented for each test case:\n- Use $m = 1$ for all particles.\n- Compute all pairwise forces at time $t$ from the specified model.\n- Compute the net internal torque $\\boldsymbol{\\tau}(t)$ and its Euclidean norm $\\|\\boldsymbol{\\tau}(t)\\|$.\n- Compute the total angular momentum $\\mathbf{L}(t)$.\n- Advance one explicit Euler step of size $\\Delta t$: for each particle,\n$$\\mathbf{v}_i(t+\\Delta t) = \\mathbf{v}_i(t) + \\Delta t \\, \\frac{\\sum_{j \\neq i} \\mathbf{F}_{ij}(t)}{m}, \\quad \\mathbf{r}_i(t+\\Delta t) = \\mathbf{r}_i(t) + \\Delta t \\, \\mathbf{v}_i(t).$$\n- Compute $\\mathbf{L}(t+\\Delta t)$ and its change $\\Delta \\mathbf{L} = \\mathbf{L}(t+\\Delta t) - \\mathbf{L}(t)$, along with the Euclidean norm $\\|\\Delta \\mathbf{L}\\|$.\n- Report $\\|\\boldsymbol{\\tau}(t)\\|$ and $\\|\\Delta \\mathbf{L}\\|$ as dimensionless floats.\n\nTest suite. Use the following four test cases, all in reduced dissipative particle dynamics units (dimensionless):\n\n- Case $1$ (central model, pair): $N = 2$, $a = 25.0$, $\\gamma = 4.5$, $r_c = 1.0$, $\\Delta t = 0.01$, $\\mathbf{r}_1 = (0.0, 0.0, 0.0)$, $\\mathbf{r}_2 = (0.5, 0.0, 0.0)$, $\\mathbf{v}_1 = (0.0, 1.0, 0.0)$, $\\mathbf{v}_2 = (0.0, -1.0, 0.0)$; use the rotationally invariant central model.\n- Case $2$ (central model, asymmetric triplet): $N = 3$, $a = 25.0$, $\\gamma = 4.5$, $r_c = 1.0$, $\\Delta t = 0.01$, $\\mathbf{r}_1 = (0.0, 0.0, 0.0)$, $\\mathbf{r}_2 = (0.6, 0.2, 0.0)$, $\\mathbf{r}_3 = (0.2, 0.7, 0.0)$, $\\mathbf{v}_1 = (0.1, -0.2, 0.0)$, $\\mathbf{v}_2 = (-0.05, 0.03, 0.0)$, $\\mathbf{v}_3 = (0.02, -0.01, 0.0)$; use the rotationally invariant central model.\n- Case $3$ (non-central bug, same triplet): identical to Case $2$ but using the non-central model for the dissipative term.\n- Case $4$ (no interactions at cut-off): $N = 3$, $a = 25.0$, $\\gamma = 4.5$, $r_c = 1.0$, $\\Delta t = 0.01$, $\\mathbf{r}_1 = (0.0, 0.0, 0.0)$, $\\mathbf{r}_2 = (2.0, 0.0, 0.0)$, $\\mathbf{r}_3 = (0.0, 2.0, 0.0)$, $\\mathbf{v}_1 = (0.3, -0.1, 0.0)$, $\\mathbf{v}_2 = (-0.2, 0.2, 0.0)$, $\\mathbf{v}_3 = (0.0, -0.15, 0.0)$; use the rotationally invariant central model.\n\nYour program must compute, for each case, the two floats $\\|\\boldsymbol{\\tau}(t)\\|$ and $\\|\\Delta \\mathbf{L}\\|$, each rounded to eight decimal places. The final output format is a single line containing a comma-separated list of all these values flattened in the order of the cases, i.e., \n$$[\\|\\boldsymbol{\\tau}\\|_1, \\|\\Delta \\mathbf{L}\\|_1, \\|\\boldsymbol{\\tau}\\|_2, \\|\\Delta \\mathbf{L}\\|_2, \\|\\boldsymbol{\\tau}\\|_3, \\|\\Delta \\mathbf{L}\\|_3, \\|\\boldsymbol{\\tau}\\|_4, \\|\\Delta \\mathbf{L}\\|_4].$$\nNo other text should be printed. All outputs are dimensionless in reduced dissipative particle dynamics units.", "solution": "The problem is valid as it is scientifically grounded in classical mechanics, well-posed with all necessary data provided, and objective in its formulation. It presents a standard computational physics exercise to verify the consequences of rotational invariance in a particle-based model.\n\nThe core principle governing the dynamics of angular momentum is the rotational analogue of Newton's second law, which states that the time rate of change of the total angular momentum $\\mathbf{L}$ of a system of particles is equal to the net external torque acting on it. For an isolated system subject only to internal forces, this becomes:\n$$\n\\frac{d\\mathbf{L}}{dt} = \\boldsymbol{\\tau}_{\\text{int}}\n$$\nwhere $\\boldsymbol{\\tau}_{\\text{int}}$ is the net internal torque. The total angular momentum is defined as the sum of individual particle angular momenta about the origin:\n$$\n\\mathbf{L}(t) = \\sum_{i=1}^{N} \\mathbf{L}_i(t) = \\sum_{i=1}^{N} m_i \\left( \\mathbf{r}_i(t) \\times \\mathbf{v}_i(t) \\right)\n$$\nThe net internal torque is the sum of torques produced by all internal forces $\\mathbf{F}_{ij}$ (force on particle $i$ from particle $j$):\n$$\n\\boldsymbol{\\tau}_{\\text{int}}(t) = \\sum_{i=1}^{N} \\mathbf{r}_i(t) \\times \\mathbf{F}_i(t) = \\sum_{i=1}^{N} \\mathbf{r}_i(t) \\times \\left( \\sum_{j \\neq i} \\mathbf{F}_{ij}(t) \\right)\n$$\nAssuming Newton's third law holds ($\\mathbf{F}_{ij} = -\\mathbf{F}_{ji}$), the net internal torque can be expressed as a sum over pairs of particles:\n$$\n\\boldsymbol{\\tau}_{\\text{int}} = \\sum_{i<j} \\left( \\mathbf{r}_i \\times \\mathbf{F}_{ij} + \\mathbf{r}_j \\times \\mathbf{F}_{ji} \\right) = \\sum_{i<j} \\left( \\mathbf{r}_i - \\mathbf{r}_j \\right) \\times \\mathbf{F}_{ij} = \\sum_{i<j} \\mathbf{r}_{ij} \\times \\mathbf{F}_{ij}\n$$\nwhere $\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$ is the separation vector. This expression shows that the net internal torque is zero if and only if for every pair of interacting particles, the force vector $\\mathbf{F}_{ij}$ is parallel to the separation vector $\\mathbf{r}_{ij}$. Such forces are called **central forces**. A system with only central internal forces will have $\\boldsymbol{\\tau}_{\\text{int}} = \\mathbf{0}$, which implies that its total angular momentum is conserved ($d\\mathbf{L}/dt = \\mathbf{0}$).\n\nThe problem asks us to investigate two models:\n$1$. The **rotationally invariant central model** uses forces $\\mathbf{F}_{ij}^{C} = a \\, w_C(r_{ij}) \\, \\hat{\\mathbf{r}}_{ij}$ and $\\mathbf{F}_{ij}^{D} = - \\gamma \\, w_D(r_{ij}) ((\\mathbf{v}_i - \\mathbf{v}_j) \\cdot \\hat{\\mathbf{r}}_{ij}) \\hat{\\mathbf{r}}_{ij}$. Both components, and thus their sum $\\mathbf{F}_{ij}$, are directed along the unit separation vector $\\hat{\\mathbf{r}}_{ij}$. This is a central force. Therefore, for this model, we can predict that the analytical net internal torque $\\boldsymbol{\\tau}(t)$ will be exactly zero.\n\n$2$. The **non-central (bug) model** uses a modified dissipative force $\\mathbf{F}_{ij}^{D,\\mathrm{bug}} = - \\gamma \\, w_D(r_{ij}) (\\mathbf{v}_i - \\mathbf{v}_j)$. In general, the relative velocity vector $(\\mathbf{v}_i - \\mathbf{v}_j)$ is not parallel to the separation vector $\\mathbf{r}_{ij}$. Consequently, the pairwise force $\\mathbf{F}_{ij}$ is not central, leading to a non-zero torque contribution $\\mathbf{r}_{ij} \\times \\mathbf{F}_{ij} \\neq \\mathbf{0}$. This results in a non-zero net internal torque $\\boldsymbol{\\tau}(t) \\neq \\mathbf{0}$ and a violation of angular momentum conservation.\n\nThe numerical procedure uses a single **explicit Euler integration step**. The equations of motion are discretized as:\n$$\n\\mathbf{v}_i(t+\\Delta t) = \\mathbf{v}_i(t) + \\frac{\\Delta t}{m} \\mathbf{F}_i(t)\n$$\n$$\n\\mathbf{r}_i(t+\\Delta t) = \\mathbf{r}_i(t) + \\Delta t \\, \\mathbf{v}_i(t)\n$$\nThe change in angular momentum over this step is $\\Delta \\mathbf{L} = \\mathbf{L}(t+\\Delta t) - \\mathbf{L}(t)$. From the continuous time evolution, one might approximate $\\Delta \\mathbf{L} \\approx \\boldsymbol{\\tau}(t)\\Delta t$. This relationship is not exact for a finite time step due to numerical integration error.\nFor the central model, we expect $\\|\\boldsymbol{\\tau}(t)\\|$ to be zero (or within machine precision), while $\\|\\Delta \\mathbf{L}\\|$ will be a small, non-zero value representing the integration error of the explicit Euler method, which is not a symplectic integrator and does not perfectly conserve such quantities. For the non-central model, we expect a non-zero $\\|\\boldsymbol{\\tau}(t)\\|$, and $\\|\\Delta \\mathbf{L}\\|$ should be of the order $\\|\\boldsymbol{\\tau}(t)\\| \\Delta t$.\n\nThe computational algorithm for each test case is as follows:\n$1$. Given initial positions $\\mathbf{r}_i$, velocities $\\mathbf{v}_i$, and parameters $m$, $a$, $\\gamma$, $r_c$, and $\\Delta t$.\n$2$. Compute the total force $\\mathbf{F}_i = \\sum_{j \\neq i} \\mathbf{F}_{ij}$ on each particle $i$ at time $t$ by summing over all pairs $(j \\neq i)$, applying the given force law (central or non-central) only if the pair separation $r_{ij} < r_c$.\n$3$. Compute the net internal torque at time $t$ as $\\boldsymbol{\\tau}(t) = \\sum_i \\mathbf{r}_i(t) \\times \\mathbf{F}_i(t)$ and calculate its Euclidean norm $\\|\\boldsymbol{\\tau}(t)\\|$.\n$4$. Compute the total angular momentum at time $t$: $\\mathbf{L}(t) = \\sum_i m (\\mathbf{r}_i(t) \\times \\mathbf{v}_i(t))$.\n$5$. Update the particle positions and velocities to time $t+\\Delta t$ using the explicit Euler formulas specified. Note that the position update uses the velocity at time $t$.\n$6$. Compute the new total angular momentum at time $t+\\Delta t$: $\\mathbf{L}(t+\\Delta t) = \\sum_i m (\\mathbf{r}_i(t+\\Delta t) \\times \\mathbf{v}_i(t+\\Delta t))$.\n$7$. Calculate the change $\\Delta \\mathbf{L} = \\mathbf{L}(t+\\Delta t) - \\mathbf{L}(t)$ and its Euclidean norm $\\|\\Delta \\mathbf{L}\\|$.\n$8$. Report the computed values $\\|\\boldsymbol{\\tau}(t)\\|$ and $\\|\\Delta \\mathbf{L}\\|$, rounded as specified.\n\nCase $4$ provides a sanity check: all particles are initially separated by distances greater than the cutoff radius $r_c=1.0$. Thus, all pairwise forces are zero, so $\\mathbf{F}_i(t) = \\mathbf{0}$ for all $i$. This implies $\\boldsymbol{\\tau}(t) = \\mathbf{0}$. With zero forces, velocities remain constant, and the position update becomes $\\mathbf{r}_i(t+\\Delta t) = \\mathbf{r}_i(t) + \\Delta t \\mathbf{v}_i(t)$. The change in angular momentum is then $\\Delta\\mathbf{L} = \\sum_i m(\\mathbf{r}_i(t+\\Delta t) \\times \\mathbf{v}_i(t) - \\mathbf{r}_i(t) \\times \\mathbf{v}_i(t)) = \\sum_i m(\\Delta t \\mathbf{v}_i(t) \\times \\mathbf{v}_i(t)) = \\mathbf{0}$. Therefore, for Case $4$, both $\\|\\boldsymbol{\\tau}(t)\\|$ and $\\|\\Delta \\mathbf{L}\\|$ must be exactly $0$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates rotational invariance in a pairwise mesoscale particle model.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: Central model, pair\n        {\n            \"N\": 2, \"a\": 25.0, \"gamma\": 4.5, \"rc\": 1.0, \"dt\": 0.01, \"m\": 1.0,\n            \"r\": np.array([[0.0, 0.0, 0.0], [0.5, 0.0, 0.0]]),\n            \"v\": np.array([[0.0, 1.0, 0.0], [0.0, -1.0, 0.0]]),\n            \"model_type\": 'central'\n        },\n        # Case 2: Central model, asymmetric triplet\n        {\n            \"N\": 3, \"a\": 25.0, \"gamma\": 4.5, \"rc\": 1.0, \"dt\": 0.01, \"m\": 1.0,\n            \"r\": np.array([[0.0, 0.0, 0.0], [0.6, 0.2, 0.0], [0.2, 0.7, 0.0]]),\n            \"v\": np.array([[0.1, -0.2, 0.0], [-0.05, 0.03, 0.0], [0.02, -0.01, 0.0]]),\n            \"model_type\": 'central'\n        },\n        # Case 3: Non-central model, same triplet\n        {\n            \"N\": 3, \"a\": 25.0, \"gamma\": 4.5, \"rc\": 1.0, \"dt\": 0.01, \"m\": 1.0,\n            \"r\": np.array([[0.0, 0.0, 0.0], [0.6, 0.2, 0.0], [0.2, 0.7, 0.0]]),\n            \"v\": np.array([[0.1, -0.2, 0.0], [-0.05, 0.03, 0.0], [0.02, -0.01, 0.0]]),\n            \"model_type\": 'non-central'\n        },\n        # Case 4: No interactions at cut-off\n        {\n            \"N\": 3, \"a\": 25.0, \"gamma\": 4.5, \"rc\": 1.0, \"dt\": 0.01, \"m\": 1.0,\n            \"r\": np.array([[0.0, 0.0, 0.0], [2.0, 0.0, 0.0], [0.0, 2.0, 0.0]]),\n            \"v\": np.array([[0.3, -0.1, 0.0], [-0.2, 0.2, 0.0], [0.0, -0.15, 0.0]]),\n            \"model_type\": 'central'\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        norm_torque, norm_delta_L = run_simulation_step(\n            case[\"N\"], case[\"r\"], case[\"v\"], case[\"m\"],\n            case[\"a\"], case[\"gamma\"], case[\"rc\"], case[\"dt\"],\n            case[\"model_type\"]\n        )\n        results.append(f\"{norm_torque:.8f}\")\n        results.append(f\"{norm_delta_L:.8f}\")\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation_step(N, r, v, m, a, gamma, rc, dt, model_type):\n    \"\"\"\n    Computes net torque and change in angular momentum for one time step.\n    \n    Args:\n        N (int): Number of particles.\n        r (np.ndarray): (N, 3) array of particle positions.\n        v (np.ndarray): (N, 3) array of particle velocities.\n        m (float): Particle mass.\n        a (float): Conservative force parameter.\n        gamma (float): Dissipative force parameter.\n        rc (float): Cutoff radius.\n        dt (float): Time step size.\n        model_type (str): 'central' or 'non-central'.\n\n    Returns:\n        tuple: (norm_torque, norm_delta_L) as floats.\n    \"\"\"\n    # 1. Compute total angular momentum at time t\n    L_t = np.sum(np.cross(r, v) * m, axis=0)\n\n    # 2. Compute pairwise forces and total force on each particle\n    forces = np.zeros_like(r)\n    for i in range(N):\n        for j in range(i + 1, N):\n            r_ij = r[i] - r[j]\n            r_ij_norm = np.linalg.norm(r_ij)\n\n            # Interact only if within cutoff radius\n            if 0 < r_ij_norm < rc:\n                r_ij_hat = r_ij / r_ij_norm\n                v_ij = v[i] - v[j]\n\n                w_C = 1.0 - r_ij_norm / rc\n                w_D = w_C**2\n\n                F_ij_C = a * w_C * r_ij_hat\n\n                if model_type == 'central':\n                    F_ij_D = -gamma * w_D * np.dot(v_ij, r_ij_hat) * r_ij_hat\n                elif model_type == 'non-central':\n                    F_ij_D = -gamma * w_D * v_ij\n                else:\n                    raise ValueError(\"Unknown model type\")\n\n                F_ij = F_ij_C + F_ij_D\n                \n                forces[i] += F_ij\n                forces[j] -= F_ij\n\n    # 3. Compute net internal torque at time t\n    torque_t = np.sum(np.cross(r, forces), axis=0)\n    norm_torque_t = np.linalg.norm(torque_t)\n\n    # 4. Advance one Explicit Euler step\n    # Position update uses velocity at time t\n    r_new = r + dt * v\n    v_new = v + dt * forces / m\n\n    # 5. Compute total angular momentum at time t+dt\n    L_t_dt = np.sum(np.cross(r_new, v_new) * m, axis=0)\n\n    # 6. Compute change in angular momentum\n    delta_L = L_t_dt - L_t\n    norm_delta_L = np.linalg.norm(delta_L)\n    \n    return norm_torque_t, norm_delta_L\n\nsolve()\n```", "id": "3446073"}, {"introduction": "The power of DPD lies in its ability to capture emergent hydrodynamic behavior at the mesoscale. This hands-on problem [@problem_id:3446122] provides an opportunity to verify this capability by simulating the sedimentation of a colloidal particle. You will compute the particle's terminal velocity and validate it against the theoretical prediction from Stokes' law, critically including the essential corrections that arise from the use of periodic boundary conditions in finite simulation boxes.", "problem": "You are asked to write a complete, runnable program that emulates how Dissipative Particle Dynamics (DPD) recovers mesoscale hydrodynamics for the sedimentation of a spherical colloid in a viscous Newtonian solvent under gravity with cubic periodic boundary conditions. The aim is to compute the terminal settling velocity from first principles and verify the Stokesian prediction once periodic boundary effects are accounted for.\n\nBase your derivation and algorithm strictly on the following fundamental laws and well-tested formulas:\n- Newton’s Second Law states that the time rate of change of momentum equals the sum of forces. At terminal velocity, acceleration is zero and the net force on the particle is zero.\n- The gravitational-buoyant force on a spherical particle of radius $R$ and densities $\\rho_p$ (particle) and $\\rho$ (solvent) under gravitational acceleration $g$ is $F_g = \\frac{4}{3}\\pi R^3 (\\rho_p - \\rho) g$.\n- In the creeping-flow (low Reynolds number) limit with no-slip conditions at the particle surface, the Stokes drag on a sphere moving with speed $U$ in a Newtonian solvent of viscosity $\\eta$ is $F_d = 6\\pi \\eta R U$.\n- In a cubic, triply periodic domain of side length $L$, hydrodynamic long-range interactions modify the mobility. For a single sphere sedimenting under the conditions above, the leading-order periodic correction to the translational mobility is well described by the Hasimoto series. Denote $\\alpha = R/L$. Then the dimensionless mobility factor is $M(\\alpha) = 1 - c_1 \\alpha + c_3 \\alpha^3 + \\mathcal{O}(\\alpha^5)$, with $c_1 = 2.837297$ and $c_3 = 4.19$. This modifies the infinite-domain terminal velocity by the multiplicative factor $M(\\alpha)$.\n\nFrom these bases, derive the infinite-domain terminal velocity by force balance at steady state and then apply the periodic correction factor $M(\\alpha)$ to obtain the predicted terminal velocity in a periodic box. Use this to compare against a provided “measured” terminal velocity, which you should interpret as coming from a DPD simulation that has been time-averaged until steady state.\n\nYour program must:\n- For each test case, compute the infinite-domain terminal velocity in meters per second and then apply the periodic boundary correction described above to obtain the predicted terminal velocity in meters per second.\n- Compute the relative error $e = \\lvert U_{\\text{meas}} - U_{\\text{pred}}\\rvert / U_{\\text{pred}}$ as a decimal. If $U_{\\text{pred}} = 0$, use an absolute error criterion instead: declare the comparison valid if $\\lvert U_{\\text{meas}}\\rvert \\le \\tau_{\\text{abs}}$, where $\\tau_{\\text{abs}}$ is a small absolute threshold in meters per second.\n- Verify Stokes’ law with periodic corrections by checking if $e \\le \\tau_{\\text{rel}}$, where $\\tau_{\\text{rel}}$ is a relative tolerance expressed as a decimal. Use $\\tau_{\\text{rel}} = 0.03$ and $\\tau_{\\text{abs}} = 1\\times 10^{-12}$.\n\nPhysical units and numerical requirements:\n- All inputs must be interpreted in SI units. Radii and lengths are in meters, densities in kilograms per cubic meter, gravitational acceleration in meters per second squared, viscosity in pascal-seconds, and velocities in meters per second.\n- Express all internally computed velocities in meters per second. The relative error is unitless and must be computed as a decimal (for example, $0.02$ for two percent).\n\nTest suite:\nFor each test case below, you are given $(\\rho_p, \\rho, g, R, \\eta, L, U_{\\text{meas}})$.\n\n1. Happy path with moderate periodic correction:\n   - $\\rho_p = 2000\\,\\text{kg/m}^3$, $\\rho = 1000\\,\\text{kg/m}^3$, $g = 9.81\\,\\text{m/s}^2$, $R = 1.0\\times 10^{-6}\\,\\text{m}$, $\\eta = 1.0\\times 10^{-3}\\,\\text{Pa}\\cdot\\text{s}$, $L = 5.0\\times 10^{-5}\\,\\text{m}$, $U_{\\text{meas}} = 2.077930593644\\times 10^{-6}\\,\\text{m/s}$.\n\n2. Large box, negligible periodic correction:\n   - $\\rho_p = 2000\\,\\text{kg/m}^3$, $\\rho = 1000\\,\\text{kg/m}^3$, $g = 9.81\\,\\text{m/s}^2$, $R = 1.0\\times 10^{-6}\\,\\text{m}$, $\\eta = 1.0\\times 10^{-3}\\,\\text{Pa}\\cdot\\text{s}$, $L = 1.0\\times 10^{-3}\\,\\text{m}$, $U_{\\text{meas}} = 2.1629456277627886\\times 10^{-6}\\,\\text{m/s}$.\n\n3. Boundary condition (neutral buoyancy):\n   - $\\rho_p = 1000\\,\\text{kg/m}^3$, $\\rho = 1000\\,\\text{kg/m}^3$, $g = 9.81\\,\\text{m/s}^2$, $R = 1.0\\times 10^{-6}\\,\\text{m}$, $\\eta = 1.0\\times 10^{-3}\\,\\text{Pa}\\cdot\\text{s}$, $L = 1.0\\times 10^{-4}\\,\\text{m}$, $U_{\\text{meas}} = 0.0\\,\\text{m/s}$.\n\n4. Small box, strong periodic correction (edge case with an intentional slight mismatch):\n   - $\\rho_p = 2000\\,\\text{kg/m}^3$, $\\rho = 1000\\,\\text{kg/m}^3$, $g = 9.81\\,\\text{m/s}^2$, $R = 1.0\\times 10^{-6}\\,\\text{m}$, $\\eta = 1.0\\times 10^{-3}\\,\\text{Pa}\\cdot\\text{s}$, $L = 5.0\\times 10^{-6}\\,\\text{m}$, $U_{\\text{meas}} = 1.07697283448\\times 10^{-6}\\,\\text{m/s}$.\n\n5. Different solvent viscosity and particle size:\n   - $\\rho_p = 1500\\,\\text{kg/m}^3$, $\\rho = 1000\\,\\text{kg/m}^3$, $g = 9.81\\,\\text{m/s}^2$, $R = 5.0\\times 10^{-7}\\,\\text{m}$, $\\eta = 2.0\\times 10^{-3}\\,\\text{Pa}\\cdot\\text{s}$, $L = 2.0\\times 10^{-5}\\,\\text{m}$, $U_{\\text{meas}} = 1.2912626475515624\\times 10^{-7}\\,\\text{m/s}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the verification results as a comma-separated Python-style list of booleans in the order of the test cases, for example: $[{\\rm True},{\\rm False},{\\rm True},\\dots]$.", "solution": "The problem requires the validation of a mesoscale hydrodynamic prediction for the sedimentation of a single spherical colloid in a periodic domain against simulated \"measured\" data. The validation is performed by deriving the terminal settling velocity from first principles, incorporating corrections for periodic boundary conditions, and comparing this prediction to the provided data within a specified tolerance.\n\nThe analysis proceeds in three stages: first, the derivation of the terminal velocity for an isolated sphere in an infinite fluid ($U_{\\infty}$); second, the application of a correction factor for a cubic periodic domain to obtain the predicted velocity ($U_{\\text{pred}}$); and third, the establishment of a verification protocol to compare $U_{\\text{pred}}$ with the measured velocity ($U_{\\text{meas}}$).\n\nAccording to Newton's Second Law, a particle reaches a constant terminal velocity when the net force acting upon it is zero. In this sedimentation problem, two forces are considered: the gravitational-buoyant force, $F_g$, which drives the sedimentation, and the hydrodynamic drag force, $F_d$, which opposes the motion. At steady state, these forces balance:\n$$\n\\sum F = F_g - F_d = 0 \\implies F_g = F_d\n$$\nThe problem provides the expressions for these forces. The gravitational-buoyant force on a sphere of radius $R$, particle density $\\rho_p$, and solvent density $\\rho$, under gravitational acceleration $g$, is:\n$$\nF_g = \\frac{4}{3}\\pi R^3 (\\rho_p - \\rho) g\n$$\nIn the low Reynolds number (creeping flow) regime, the Stokes drag force on this sphere moving at a velocity $U$ through a solvent of dynamic viscosity $\\eta$ is:\n$$\nF_d = 6\\pi \\eta R U\n$$\nBy equating these two forces, we can solve for the terminal velocity in an infinite, unbounded domain, denoted as $U_{\\infty}$:\n$$\n6\\pi \\eta R U_{\\infty} = \\frac{4}{3}\\pi R^3 (\\rho_p - \\rho) g\n$$\nSolving for $U_{\\infty}$ yields the Stokes settling velocity:\n$$\nU_{\\infty} = \\frac{\\frac{4}{3}\\pi R^3 (\\rho_p - \\rho) g}{6\\pi \\eta R} = \\frac{4 R^2 (\\rho_p - \\rho) g}{18 \\eta} = \\frac{2}{9} \\frac{R^2 (\\rho_p - \\rho) g}{\\eta}\n$$\nThis expression provides the benchmark velocity in the absence of boundary effects. A special case arises when the particle is neutrally buoyant, i.e., $\\rho_p = \\rho$. In this case, $F_g = 0$ and consequently $U_{\\infty} = 0$.\n\nNext, we account for the influence of periodic boundary conditions. In a simulation employing a cubic periodic box of side length $L$, the particle interacts with its own periodic images, which modifies the hydrodynamic drag. This effect is captured by a dimensionless mobility factor, $M(\\alpha)$, which is a function of the ratio $\\alpha = R/L$. The problem specifies the Hasimoto series expansion for this factor, truncated at the $\\alpha^3$ term:\n$$\nM(\\alpha) = 1 - c_1 \\alpha + c_3 \\alpha^3 + \\mathcal{O}(\\alpha^5)\n$$\nThe provided constants are $c_1 = 2.837297$ and $c_3 = 4.19$. The predicted terminal velocity in the periodic system, $U_{\\text{pred}}$, is obtained by multiplying the infinite-domain velocity by this mobility factor:\n$$\nU_{\\text{pred}} = U_{\\infty} \\times M(\\alpha) = \\left( \\frac{2}{9} \\frac{R^2 (\\rho_p - \\rho) g}{\\eta} \\right) \\left( 1 - c_1 \\frac{R}{L} + c_3 \\left(\\frac{R}{L}\\right)^3 \\right)\n$$\nFinally, we must establish a clear criterion for verifying the DPD \"measurement\" $U_{\\text{meas}}$ against our theoretical prediction $U_{\\text{pred}}$. The verification depends on whether the predicted velocity is zero or non-zero.\n\nCase 1: $U_{\\text{pred}} \\ne 0$ (i.e., $\\rho_p \\ne \\rho$).\nThe relative error, $e$, is computed as:\n$$\ne = \\frac{\\lvert U_{\\text{meas}} - U_{\\text{pred}}\\rvert}{\\lvert U_{\\text{pred}}\\rvert}\n$$\nThe verification is successful if this error is within a specified relative tolerance, $\\tau_{\\text{rel}} = 0.03$. That is, the result is `True` if $e \\le 0.03$.\n\nCase 2: $U_{\\text{pred}} = 0$ (i.e., $\\rho_p = \\rho$).\nIn this case, a relative error is undefined. The verification is instead based on an absolute tolerance, $\\tau_{\\text{abs}} = 1 \\times 10^{-12}\\,\\text{m/s}$. The verification is successful if the magnitude of the measured velocity is negligible, i.e., if:\n$$\n\\lvert U_{\\text{meas}} \\rvert \\le \\tau_{\\text{abs}}\n$$\nThe algorithm to be implemented will iterate through each test case, apply these derived formulas to compute $U_{\\text{pred}}$, and then use the appropriate verification criterion to determine a boolean result.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the predicted terminal settling velocity of a spherical colloid in a\n    periodic box and verifies it against a \"measured\" value from a DPD simulation.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (rho_p, rho, g, R, eta, L, U_meas)\n    test_cases = [\n        # 1. Happy path with moderate periodic correction\n        (2000.0, 1000.0, 9.81, 1.0e-6, 1.0e-3, 5.0e-5, 2.077930593644e-6),\n        # 2. Large box, negligible periodic correction\n        (2000.0, 1000.0, 9.81, 1.0e-6, 1.0e-3, 1.0e-3, 2.1629456277627886e-6),\n        # 3. Boundary condition (neutral buoyancy)\n        (1000.0, 1000.0, 9.81, 1.0e-6, 1.0e-3, 1.0e-4, 0.0),\n        # 4. Small box, strong periodic correction\n        (2000.0, 1000.0, 9.81, 1.0e-6, 1.0e-3, 5.0e-6, 1.07697283448e-6),\n        # 5. Different solvent viscosity and particle size\n        (1500.0, 1000.0, 9.81, 5.0e-7, 2.0e-3, 2.0e-5, 1.2912626475515624e-7),\n    ]\n\n    # Constants and tolerances\n    c1 = 2.837297\n    c3 = 4.19\n    tau_rel = 0.03\n    tau_abs = 1.0e-12\n\n    results = []\n    for case in test_cases:\n        rho_p, rho, g, R, eta, L, u_meas = case\n        \n        # Check for the neutral buoyancy case first to avoid division by zero later\n        if rho_p == rho:\n            u_pred = 0.0\n            is_valid = abs(u_meas) <= tau_abs\n            results.append(is_valid)\n            continue\n            \n        # Step 1: Calculate the infinite-domain terminal velocity (U_infinity)\n        # U_infinity = (2 * R^2 * (rho_p - rho) * g) / (9 * eta)\n        u_infinity = (2.0 / 9.0) * (R**2 * (rho_p - rho) * g) / eta\n\n        # Step 2: Calculate the periodic correction factor M(alpha)\n        alpha = R / L\n        # M(alpha) = 1 - c1*alpha + c3*alpha^3\n        m_alpha = 1.0 - c1 * alpha + c3 * (alpha**3)\n        \n        # Step 3: Calculate the predicted terminal velocity in the periodic box\n        u_pred = u_infinity * m_alpha\n\n        # Step 4: Verify against the \"measured\" velocity using relative error\n        # e = |U_meas - U_pred| / |U_pred|\n        if u_pred != 0.0:\n            relative_error = abs(u_meas - u_pred) / abs(u_pred)\n            is_valid = relative_error <= tau_rel\n        else:\n            # This branch should not be reached due to the initial check for rho_p == rho,\n            # but is included for logical completeness.\n            is_valid = abs(u_meas) <= tau_abs\n            \n        results.append(is_valid)\n\n    # Final print statement in the exact required format.\n    # The problem asks for a python-style list of booleans, so map to str and join\n    # e.g., [True,False,True]\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nsolve()\n```", "id": "3446122"}]}