{"hands_on_practices": [{"introduction": "Before constructing complex simulations, it is essential to master the numerical foundations that ensure their stability and accuracy. This first exercise focuses on a critical aspect of implementing time-dependent phase-field models: numerical stability. You will perform a von Neumann stability analysis for the forward Euler time-stepping scheme applied to the linearized Cahn-Hilliard equation, a foundational model for spinodal decomposition and compositional evolution [@problem_id:3476642]. By deriving and implementing the stability criterion from first principles, you will gain hands-on experience with the direct link between the physical parameters, the grid discretization, and the maximum allowable time step, a crucial skill for developing robust simulation codes.", "problem": "Consider a one-dimensional periodic domain of length $L$ discretized by $N$ uniformly spaced nodes with grid spacing $h = L / N$. Let $c(x,t)$ denote a conserved order parameter (composition) that evolves according to the linearized Cahn–Hilliard (CH) equation arising from a free-energy density with positive curvature at a homogeneous reference state. Starting from the free-energy functional $F[c] = \\int \\left( f(c) + \\frac{\\kappa}{2} |\\nabla c|^2 \\right) \\, dx$ with $\\kappa \\ge 0$ and chemical potential $\\mu = \\frac{\\delta F}{\\delta c}$, the CH evolution law is $\\partial_t c = \\nabla \\cdot \\left( M \\nabla \\mu \\right)$, where $M \\ge 0$ is the mobility. Linearizing about a uniform composition with $f''(c_0) = A \\ge 0$ (constant) yields\n$$\n\\frac{\\partial c}{\\partial t} = M \\left( A \\nabla^2 c - \\kappa \\nabla^4 c \\right).\n$$\nDiscretize space using a second-order accurate centered finite difference for the Laplacian with periodic boundary conditions, and discretize time using a forward Euler (FE) scheme with time step $\\Delta t$. The discrete Laplacian on a periodic grid is diagonalizable by Fourier modes, and the von Neumann analysis reduces the fully discrete scheme to a scalar linear update for each discrete Fourier mode amplitude $C_m^n$:\n$$\nC_m^{n+1} = G_m(\\Delta t) \\, C_m^n, \\quad G_m(\\Delta t) = 1 + \\Delta t \\, \\lambda_m,\n$$\nwhere $\\lambda_m$ is the discrete eigenvalue of the linear operator $M \\left( A \\nabla_h^2 - \\kappa \\nabla_h^4 \\right)$ associated with mode index $m \\in \\{0,1,\\dots,N-1\\}$ and $\\nabla_h^2$ denotes the discrete Laplacian. The forward Euler scheme is stable for a given $\\Delta t$ if and only if $|G_m(\\Delta t)| \\le 1$ for every mode index $m$.\n\nYour tasks are:\n\n- Using fundamental definitions (free-energy functional, chemical potential, linearization, and von Neumann mode analysis), derive the stability condition that determines the maximum allowable time step $\\Delta t_{\\max}$ for which the forward Euler scheme is stable for all discrete Fourier modes on a periodic grid. Express $\\Delta t_{\\max}$ in terms of the discrete spectrum of the operator $M \\left( A \\nabla_h^2 - \\kappa \\nabla_h^4 \\right)$ and fundamental constants $M$, $A$, $\\kappa$, $L$, and $N$. Do not assume any continuum-limit shortcut formulas; start from the discrete operators on the periodic grid.\n\n- Design an algorithm that, given $L$, $N$, $M$, $A$, and $\\kappa$, computes $\\Delta t_{\\max}$ by scanning all discrete Fourier modes and enforcing the von Neumann criterion $|G_m(\\Delta t)| \\le 1$ for all $m$ with the understanding that $A \\ge 0$ and $\\kappa \\ge 0$. Your algorithm should use the exact discrete eigenvalues for the periodic second-difference operator and its square.\n\n- Implement a program that:\n  1) Computes $\\Delta t_{\\max}$ in seconds for each parameter set in the test suite below by scanning all discrete Fourier modes.\n  2) For a specified parameter set and three given multipliers $\\gamma$, evaluates whether the choices $\\Delta t = \\gamma \\, \\Delta t_{\\max}$ are stable (boolean results) by checking the von Neumann criterion across all modes.\n\nPhysical and numerical details:\n\n- Spatial units must be in meters, and time units must be in seconds. The mobility $M$ and coefficients $A$ and $\\kappa$ should be treated as given positive constants consistent with the linearized CH model; report every computed $\\Delta t_{\\max}$ in seconds. No angle quantities are involved.\n\nTest suite:\n\n- Compute $\\Delta t_{\\max}$ (in seconds) for each of the following parameter sets:\n  - Case T$1$: $L = 1.0\\times 10^{-6}$ m, $N = 64$, $M = 1.0\\times 10^{-14}$, $A = 1.0\\times 10^{9}$, $\\kappa = 1.0\\times 10^{-14}$.\n  - Case T$2$: $L = 1.0\\times 10^{-6}$ m, $N = 64$, $M = 1.0\\times 10^{-14}$, $A = 1.0\\times 10^{9}$, $\\kappa = 0.0$.\n  - Case T$3$: $L = 1.0\\times 10^{-6}$ m, $N = 63$, $M = 1.0\\times 10^{-14}$, $A = 1.0\\times 10^{9}$, $\\kappa = 1.0\\times 10^{-14}$.\n  - Case T$4$: $L = 1.0\\times 10^{-6}$ m, $N = 64$, $M = 1.0\\times 10^{-14}$, $A = 1.0$, $\\kappa = 1.0\\times 10^{-14}$.\n\n- For the stability checks, use the parameters of Case T$1$ and the multipliers\n  - $\\gamma_1 = 0.5$,\n  - $\\gamma_2 = 1.0$,\n  - $\\gamma_3 = 1.01$,\n  and determine whether the forward Euler method is stable for $\\Delta t = \\gamma_i \\, \\Delta t_{\\max}$, $i \\in \\{1,2,3\\}$, by checking the von Neumann condition for all discrete modes.\n\nFinal output format:\n\n- Your program should produce a single line of output containing a flat list with the values\n  $[\\Delta t_{\\max}(\\text{T}1), \\Delta t_{\\max}(\\text{T}2), \\Delta t_{\\max}(\\text{T}3), \\Delta t_{\\max}(\\text{T}4), \\text{stable}(\\gamma_1), \\text{stable}(\\gamma_2), \\text{stable}(\\gamma_3)]$,\n  where the first four entries are floating-point numbers (in seconds) and the last three entries are booleans, all separated by commas and enclosed in square brackets, for example, $[x_1, x_2, x_3, x_4, \\text{True}, \\text{True}, \\text{False}]$.", "solution": "We start from the free-energy functional $F[c] = \\int \\left( f(c) + \\frac{\\kappa}{2} |\\nabla c|^2 \\right) \\, dx$, with chemical potential $\\mu = \\frac{\\delta F}{\\delta c} = f'(c) - \\kappa \\nabla^2 c$. The Cahn–Hilliard (CH) equation is the conservation law\n$$\n\\frac{\\partial c}{\\partial t} = \\nabla \\cdot \\left( M \\nabla \\mu \\right).\n$$\nLinearizing about a homogeneous state $c_0$ with $A = f''(c_0) \\ge 0$ yields\n$$\n\\frac{\\partial c}{\\partial t} = M \\left( A \\nabla^2 c - \\kappa \\nabla^4 c \\right).\n$$\n\nWe consider a periodic one-dimensional domain $[0,L]$ with $N$ uniform points and spacing $h = L/N$. Let $c_j^n$ denote the discrete solution at grid index $j \\in \\{0,1,\\dots,N-1\\}$ and time level $n$. The standard second-order centered discrete Laplacian with periodic boundary conditions is\n$$\n(\\nabla_h^2 c)_j = \\frac{c_{j+1} - 2 c_j + c_{j-1}}{h^2},\n$$\nwith periodic indexing. The forward Euler (FE) discretization of the linearized CH equation is\n$$\nc^{n+1} = c^n + \\Delta t \\; M \\left( A \\nabla_h^2 c^n - \\kappa \\nabla_h^4 c^n \\right),\n$$\nwhere $\\nabla_h^4 = \\nabla_h^2 \\circ \\nabla_h^2$.\n\nTo analyze stability, we use von Neumann mode analysis by projecting onto the discrete Fourier basis. The discrete Laplacian on a periodic grid is diagonalized by discrete Fourier modes $e^{\\mathrm{i} k_m x}$ with wavenumbers $k_m = \\frac{2\\pi m}{L}$ for $m \\in \\{0,1,\\dots,N-1\\}$. Equivalently, in terms of grid index, modes are $\\varphi_m(j) = e^{\\mathrm{i} 2\\pi m j / N}$. The discrete Laplacian eigenvalues for mode index $m$ are\n$$\n\\lambda_{\\Delta}(m) = \\frac{e^{\\mathrm{i} 2\\pi m / N} - 2 + e^{-\\mathrm{i} 2\\pi m / N}}{h^2} = \\frac{-2 + 2 \\cos(2\\pi m / N)}{h^2} = - \\frac{4}{h^2} \\sin^2\\!\\left( \\frac{\\pi m}{N} \\right).\n$$\nTherefore, the discrete biharmonic eigenvalues are $\\lambda_{\\Delta^2}(m) = \\left( \\lambda_{\\Delta}(m) \\right)^2$. The linear operator $M \\left( A \\nabla_h^2 - \\kappa \\nabla_h^4 \\right)$ has eigenvalues\n$$\n\\lambda_m = M \\left( A \\lambda_{\\Delta}(m) - \\kappa \\left( \\lambda_{\\Delta}(m) \\right)^2 \\right).\n$$\nFor $A \\ge 0$, $\\kappa \\ge 0$, and $m \\ne 0$, we have $\\lambda_{\\Delta}(m) \\le 0$ and $\\left( \\lambda_{\\Delta}(m) \\right)^2 \\ge 0$, hence $\\lambda_m \\le 0$. The zero mode $m=0$ yields $\\lambda_{\\Delta}(0) = 0$ and thus $\\lambda_0 = 0$, reflecting conservation.\n\nThe FE update for the modal amplitude $C_m^n$ is\n$$\nC_m^{n+1} = \\left( 1 + \\Delta t \\, \\lambda_m \\right) C_m^n,\n$$\nwith amplification factor $G_m(\\Delta t) = 1 + \\Delta t \\lambda_m$. For stability of FE for real negative $\\lambda_m$, we require $-2 \\le \\Delta t \\lambda_m \\le 0$, or equivalently $0 \\le \\Delta t \\le \\frac{2}{|\\lambda_m|}$ for every $m$ with $\\lambda_m  0$. The tightest bound is controlled by the most negative (largest magnitude) $\\lambda_m$, i.e., the mode that maximizes the nonnegative quantity\n$$\ns_m \\equiv -\\lambda_{\\Delta}(m) = \\frac{4}{h^2} \\sin^2\\!\\left( \\frac{\\pi m}{N} \\right).\n$$\nWith $s_m \\in [0, s_{\\max}]$, where\n$$\ns_{\\max} = \\max_{m \\in \\{0,1,\\dots,N-1\\}} s_m = \\frac{4}{h^2} \\sin^2\\!\\left( \\frac{\\pi \\lfloor N/2 \\rfloor}{N} \\right),\n$$\nthe most negative eigenvalue magnitude is\n$$\n|\\lambda|_{\\max} = \\max_{m} \\left( -\\lambda_m \\right) = M \\left( A s_{\\max} + \\kappa s_{\\max}^2 \\right),\n$$\nand the maximum FE-stable time step is\n$$\n\\Delta t_{\\max} = \\frac{2}{|\\lambda|_{\\max}} = \\frac{2}{M \\left( A s_{\\max} + \\kappa s_{\\max}^2 \\right)}.\n$$\nThis result can also be obtained algorithmically by scanning all mode indices $m$ and computing the minimum over $m$ of $\\frac{2}{-\\lambda_m}$ for $\\lambda_m  0$.\n\nAlgorithmic design:\n\n- Input $L$, $N$, $M$, $A$, $\\kappa$. Compute $h = L / N$.\n- For each integer $m \\in \\{0,1,\\dots,N-1\\}$, compute the discrete Laplacian eigenvalue $\\lambda_{\\Delta}(m) = -\\frac{4}{h^2} \\sin^2\\!\\left( \\frac{\\pi m}{N} \\right)$.\n- Compute $\\lambda_m = M \\left( A \\lambda_{\\Delta}(m) - \\kappa \\left( \\lambda_{\\Delta}(m) \\right)^2 \\right)$.\n- For all modes with $\\lambda_m  0$ (i.e., $m \\ne 0$), compute the candidate bound $\\Delta t_m = \\frac{2}{-\\lambda_m}$ and take $\\Delta t_{\\max} = \\min_m \\Delta t_m$ over these modes. Report $\\Delta t_{\\max}$ in seconds.\n- To test stability for a given multiplier $\\gamma$, set $\\Delta t = \\gamma \\, \\Delta t_{\\max}$ and check the von Neumann condition $|1 + \\Delta t \\lambda_m| \\le 1$ for all $m$. Since all $\\lambda_m$ are real and nonpositive for $A \\ge 0$, $\\kappa \\ge 0$, this reduces to verifying that $\\Delta t \\le \\frac{2}{-\\lambda_m}$ for each mode with $\\lambda_m  0$. Equivalently, one may compute $\\max_m |1 + \\Delta t \\lambda_m|$ and compare to $1$ within a small numerical tolerance.\n\nTest suite coverage rationale:\n\n- Case T$1$ is a general setting where both the second-order and fourth-order terms contribute.\n- Case T$2$ sets $\\kappa = 0$ to recover a second-order operator; this reduces to a diffusion-like constraint and exercises the limit $\\Delta t_{\\max} \\sim h^2$.\n- Case T$3$ uses an odd $N$ to exercise the discrete spectrum’s slight shift in the highest mode relative to even $N$.\n- Case T$4$ uses a very small $A$ to make the fourth-order term dominant, exercising the limit $\\Delta t_{\\max} \\sim h^4$.\n- The multipliers $\\gamma_1 = 0.5$, $\\gamma_2 = 1.0$, and $\\gamma_3 = 1.01$ test, respectively, a strictly stable choice, the boundary of stability, and a slightly supercritical choice expected to be unstable for the most restrictive mode.\n\nThe implementation computes $\\Delta t_{\\max}$ by scanning all discrete modes using the exact discrete eigenvalues and reports the four $\\Delta t_{\\max}$ values (in seconds) followed by the three stability booleans for the specified multipliers, aggregated into a single flat list in the required output format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef discrete_laplacian_eigs_periodic(N, h):\n    \"\"\"\n    Compute the eigenvalues of the 1D periodic second-difference Laplacian\n    with grid spacing h and N points.\n    lambda_D(m) = -4/h^2 * sin^2(pi*m/N), for m=0,...,N-1\n    \"\"\"\n    m = np.arange(N, dtype=np.float64)\n    angles = np.pi * m / N\n    lam = -4.0 / (h * h) * (np.sin(angles) ** 2)\n    return lam\n\ndef max_stable_dt(L, N, M, A, kappa):\n    \"\"\"\n    Compute the maximum stable forward Euler time step for the linearized\n    Cahn-Hilliard operator M*(A*Δ - κ*Δ^2) on a periodic 1D grid.\n    Returns dt_max (float).\n    \"\"\"\n    h = L / N\n    lam_delta = discrete_laplacian_eigs_periodic(N, h)\n    # Operator eigenvalues: lambda_m = M*(A*lam_delta - kappa*lam_delta^2)\n    lam_op = M * (A * lam_delta - kappa * (lam_delta ** 2))\n    # Exclude modes with non-negative lambda (m=0 has lambda=0), consider only lambda  0\n    negative = lam_op  0.0\n    if not np.any(negative):\n        # No restrictive modes; dt can be arbitrarily large for FE (degenerate case).\n        return np.inf\n    # For each negative eigenvalue, FE stability requires dt = 2/(-lambda)\n    dt_candidates = 2.0 / (-lam_op[negative])\n    dt_max = np.min(dt_candidates)\n    return dt_max\n\ndef is_stable_dt(L, N, M, A, kappa, dt, tol=1e-12):\n    \"\"\"\n    Check von Neumann stability for a given dt by verifying |1 + dt*lambda_m| = 1\n    for all discrete modes (within a small tolerance to account for floating error).\n    \"\"\"\n    h = L / N\n    lam_delta = discrete_laplacian_eigs_periodic(N, h)\n    lam_op = M * (A * lam_delta - kappa * (lam_delta ** 2))\n    amp = 1.0 + dt * lam_op  # real quantities\n    # For modes with lambda=0 (m=0), amp=1 exactly; include tolerance.\n    return np.all(np.abs(amp) = 1.0 + tol)\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # dt_max test cases (T1..T4)\n    dt_cases = [\n        # (L, N, M, A, kappa) for T1\n        (1.0e-6, 64, 1.0e-14, 1.0e9, 1.0e-14),\n        # T2: kappa=0\n        (1.0e-6, 64, 1.0e-14, 1.0e9, 0.0),\n        # T3: odd N\n        (1.0e-6, 63, 1.0e-14, 1.0e9, 1.0e-14),\n        # T4: small A, fourth-order dominated\n        (1.0e-6, 64, 1.0e-14, 1.0, 1.0e-14),\n    ]\n\n    dt_max_values = []\n    for (L, N, M, A, kappa) in dt_cases:\n        dt_max = max_stable_dt(L, N, M, A, kappa)\n        dt_max_values.append(dt_max)\n\n    # Stability tests use parameters of T1 with gamma multipliers\n    L, N, M, A, kappa = dt_cases[0]\n    dt_max_T1 = dt_max_values[0]\n    gammas = [0.5, 1.0, 1.01]\n    stability_results = []\n    for g in gammas:\n        dt_test = g * dt_max_T1\n        stable = is_stable_dt(L, N, M, A, kappa, dt_test, tol=1e-12)\n        stability_results.append(stable)\n\n    # Aggregate final results: [dt_max_T1, dt_max_T2, dt_max_T3, dt_max_T4, stable(g1), stable(g2), stable(g3)]\n    results = dt_max_values + stability_results\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3476642"}, {"introduction": "The evolution of microstructures like dendrites is governed by the diffusion fields that surround them. This practice steps back from full numerical simulation to build intuition about these fields using a powerful analytical tool: the method of images. You will model the influence of a nearby planar boundary—representing either an insulating wall or an isothermal surface—on the growth trajectory of a single dendrite tip [@problem_id:3476682]. By calculating the \"image force\" exerted on the tip, you will predict whether it is attracted to or repelled from the boundary, providing a clear physical interpretation for how confinement can steer growth and introduce asymmetries in the final microstructure.", "problem": "You are to implement a small, self-contained program that computes the quasi-static steering and side-branching asymmetry of a dendrite tip growing near a planar boundary by modeling the diffusion field using the method of images. The goal is to compare a free surface versus a rigid wall and to interpret the results in terms of image-force analogs and contact-angle-based wetting predisposition.\n\nStarting point and modeling assumptions:\n- The scalar field $u(x,y)$ representing dimensionless temperature undercooling or solute supersaturation obeys the steady-state diffusion equation away from sources, namely $\\nabla^2 u = 0$, and near a point-like dendrite tip consumes or releases the field as an idealized point singularity of strength $s$ such that $\\nabla^2 u = s \\,\\delta(\\mathbf{r}-\\mathbf{r}_0)$ in two spatial dimensions.\n- Far from the tip, the imposed field has a uniform gradient in the $+x$ direction, i.e., $u(x,y) \\to -G_{\\infty}\\, x$ as $r \\to \\infty$, where $G_{\\infty}  0$ is a constant.\n- The dendrite tip is located at $\\mathbf{r}_0 = (0,h)$ above a planar boundary at $y=0$. The boundary is either a free surface modeled as isothermal (Dirichlet boundary condition $u=0$ at $y=0$) or a rigid wall modeled as adiabatic (Neumann boundary condition $\\partial u/\\partial y = 0$ at $y=0$).\n- For the Dirichlet or Neumann planar boundary, you must use the classical method of images for Laplace’s equation in two dimensions with the two-dimensional Green’s function $G(\\mathbf{r}) = \\frac{1}{2\\pi} \\ln \\lVert \\mathbf{r} \\rVert$ to obtain the additional contribution to the field from the boundary via an image singularity. The image of a point singularity placed at $(0,h)$ is located at $(0,-h)$ with the sign determined by the boundary type.\n- The instantaneous growth direction of the dendrite tip is defined to align with the local downhill direction of the field, i.e., along $-\\nabla u$ evaluated at the tip position $\\mathbf{r}_0$. Denote this local driving vector by $\\mathbf{g} = -\\nabla u \\big\\vert_{\\mathbf{r}_0} = (g_x,g_y)$.\n- Define the steering angle $\\alpha$ as the angle of $\\mathbf{g}$ measured from the $+x$ axis, i.e., $\\alpha = \\operatorname{atan2}(g_y, g_x)$, in radians. Also define a dimensionless side-branch asymmetry index $A = g_y/g_x$ that, for small $\\alpha$, approximates the bias in supply to branches above versus below the tip. Finally, define a boolean flag indicating whether the steering is toward the boundary as $\\text{toward} = (g_y  0)$, given that the boundary plane is at lower $y$.\n- Contact angle interpretation: for a specified microscopic contact angle $\\theta$ (in radians) at a rigid wall, the classical Young’s relation implies a wetting predisposition when $\\theta  \\pi/2$. Define a wetting boolean $W = \\text{True}$ if $\\theta  \\pi/2$ and $W = \\text{False}$ otherwise. For completeness of output format, compute $W$ for all listed test cases, even if it is only physically meaningful for rigid walls.\n\nYour program must:\n1. For each test case, superpose the far-field gradient and the image singularity contribution to compute $\\mathbf{g}$ at the tip. Then compute:\n   - the steering angle $\\alpha$ in radians,\n   - the asymmetry index $A$ as a dimensionless decimal,\n   - the boolean $\\text{toward}$ indicating steering toward the boundary,\n   - the boolean $W$ indicating the contact-angle-based wetting predisposition.\n2. Produce a single line of output containing the aggregated results of all test cases as a comma-separated list enclosed in square brackets, ordered per test as $[\\alpha, A, \\text{toward}, W]$ and concatenated in the order of the test suite.\n\nUnits and conventions:\n- All lengths are in arbitrary but consistent units. The only required unit is for angles: report $\\alpha$ in radians.\n- Treat $s$ and $G_{\\infty}$ as dimensionless positive constants and $h0$ as the tip-to-boundary distance.\n\nTest suite:\nProvide results for the following parameter sets:\n- Test $1$ (free surface): boundary type is Dirichlet, $s = 1.0$, $G_{\\infty} = 0.2$, $h = 5.0$, $\\theta = \\pi/2$.\n- Test $2$ (rigid wall): boundary type is Neumann, $s = 1.0$, $G_{\\infty} = 0.2$, $h = 5.0$, $\\theta = \\pi/3$.\n- Test $3$ (rigid wall, far): boundary type is Neumann, $s = 1.0$, $G_{\\infty} = 0.2$, $h = 50.0$, $\\theta = 2\\pi/3$.\n\nDeliverable:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $[\\alpha_1, A_1, \\text{toward}_1, W_1, \\alpha_2, A_2, \\text{toward}_2, W_2, \\alpha_3, A_3, \\text{toward}_3, W_3]$, where all $\\alpha$ are in radians.", "solution": "The problem statement has been validated and is deemed sound. It presents a well-posed, scientifically grounded problem in computational materials science that can be solved using established principles of potential theory.\n\nThe problem requires the calculation of the steering behavior of a dendrite tip growing near a planar boundary. The physical system is modeled by a scalar field $u(x,y)$, representing dimensionless undercooling or supersaturation, which obeys the steady-state diffusion equation. The dendrite tip at $\\mathbf{r}_0 = (0, h)$ is a point source of strength $s$, and a uniform far-field gradient, $u(x,y) \\to -G_{\\infty}x$, is imposed.\n\nThe total field $u(\\mathbf{r})$ is a superposition of three components:\n1. The far-field contribution, $u_{\\text{far}}(\\mathbf{r}) = -G_{\\infty}x$.\n2. The contribution from the physical source at $\\mathbf{r}_0$, $u_{\\text{source}}(\\mathbf{r})$.\n3. The contribution from an image source, $u_{\\text{image}}(\\mathbf{r})$, which enforces the boundary condition at $y=0$.\n\nThe growth direction is posited to be along the vector $\\mathbf{g} = -\\nabla u$, evaluated at the tip's location $\\mathbf{r}_0$. A crucial and standard step in such singular models is to regularize the calculation by recognizing that the tip does not steer itself. Therefore, the gradient contribution from the tip's own singular field, $\\nabla u_{\\text{source}}$, must be excluded. The effective gradient driving the steering is thus computed only from the far-field and the image field:\n$$ \\mathbf{g} = - \\nabla (u_{\\text{far}} + u_{\\text{image}}) \\big\\vert_{\\mathbf{r}_0} $$\n\nThe gradient of the far-field component is constant everywhere:\n$$ \\nabla u_{\\text{far}} = \\left( \\frac{\\partial}{\\partial x}(-G_{\\infty}x), \\frac{\\partial}{\\partial y}(-G_{\\infty}x) \\right) = (-G_{\\infty}, 0) $$\n\nThe problem specifies the use of the method of images. A point source of strength $S$ at position $\\mathbf{r}_s$ generates a field $u(\\mathbf{r}) = \\frac{S}{2\\pi} \\ln \\lVert \\mathbf{r} - \\mathbf{r}_s \\rVert$. The image source is located at the mirror position $\\mathbf{r}_{\\text{image}} = (0, -h)$. Its strength, $s_{\\text{image}}$, depends on the boundary condition at $y=0$. The field generated by the image source is:\n$$ u_{\\text{image}}(x,y) = \\frac{s_{\\text{image}}}{2\\pi} \\ln \\lVert \\mathbf{r} - \\mathbf{r}_{\\text{image}} \\rVert = \\frac{s_{\\text{image}}}{2\\pi} \\ln \\sqrt{x^2 + (y+h)^2} = \\frac{s_{\\text{image}}}{4\\pi} \\ln(x^2 + (y+h)^2) $$\n\nThe gradient of the image field is:\n$$ \\nabla u_{\\text{image}}(x,y) = \\left( \\frac{s_{\\text{image}}}{4\\pi} \\frac{2x}{x^2 + (y+h)^2}, \\frac{s_{\\text{image}}}{4\\pi} \\frac{2(y+h)}{x^2 + (y+h)^2} \\right) $$\n\nWe evaluate this gradient at the physical tip's location $\\mathbf{r}_0 = (0,h)$:\n$$ \\nabla u_{\\text{image}} \\big\\vert_{\\mathbf{r}_0} = \\left( \\frac{s_{\\text{image}}}{4\\pi} \\frac{2(0)}{0^2 + (h+h)^2}, \\frac{s_{\\text{image}}}{4\\pi} \\frac{2(h+h)}{0^2 + (h+h)^2} \\right) = \\left( 0, \\frac{s_{\\text{image}}}{4\\pi} \\frac{4h}{4h^2} \\right) = \\left( 0, \\frac{s_{\\text{image}}}{4\\pi h} \\right) $$\nThis result represents the \"image force\" acting on the tip.\n\nThe total effective gradient at the tip is the sum of the far-field and image gradients:\n$$ \\nabla u \\big\\vert_{\\mathbf{r}_0} = \\nabla u_{\\text{far}} + \\nabla u_{\\text{image}} \\big\\vert_{\\mathbf{r}_0} = (-G_{\\infty}, 0) + \\left(0, \\frac{s_{\\text{image}}}{4\\pi h}\\right) = \\left(-G_{\\infty}, \\frac{s_{\\text{image}}}{4\\pi h}\\right) $$\n\nThe driving vector $\\mathbf{g} = (g_x, g_y)$ is therefore:\n$$ \\mathbf{g} = -\\left(-G_{\\infty}, \\frac{s_{\\text{image}}}{4\\pi h}\\right) = \\left(G_{\\infty}, -\\frac{s_{\\text{image}}}{4\\pi h}\\right) $$\nSo, $g_x = G_{\\infty}$ and $g_y = -s_{\\text{image}} / (4\\pi h)$.\n\nWe now analyze the two boundary conditions:\n1.  **Dirichlet Condition (Free Surface)**: $u(x,0)=0$. This is satisfied by placing an image source of opposite strength, $s_{\\text{image}} = -s$, at $\\mathbf{r}_{\\text{image}} = (0,-h)$.\n    For this case, the $y$-component of the driving vector is:\n    $$ g_y = -\\frac{(-s)}{4\\pi h} = \\frac{s}{4\\pi h} $$\n    Since $s0$ and $h0$, $g_y  0$. The tip is steered in the $+y$ direction, i.e., *away* from the boundary. This is analogous to a repulsion from the isothermal surface.\n\n2.  **Neumann Condition (Rigid Wall)**: $\\partial u / \\partial y |_{y=0} = 0$. This is satisfied by placing an image source of equal strength, $s_{\\text{image}} = +s$, at $\\mathbf{r}_{\\text{image}} = (0,-h)$.\n    For this case, the $y$-component of the driving vector is:\n    $$ g_y = -\\frac{(+s)}{4\\pi h} = -\\frac{s}{4\\pi h} $$\n    Since $s0$ and $h0$, $g_y  0$. The tip is steered in the $-y$ direction, i.e., *toward* the boundary. This is analogous to an attraction to the adiabatic wall. This attraction is physically consistent with the wetting predisposition indicated by a small contact angle ($\\theta  \\pi / 2$).\n\nThe required outputs are calculated as follows:\n-   Steering angle: $\\alpha = \\operatorname{atan2}(g_y, g_x)$\n-   Asymmetry index: $A = g_y / g_x$\n-   Steering direction: $\\text{toward} = (g_y  0)$\n-   Wetting predisposition: $W = (\\theta  \\pi/2)$\n\nNow, we apply these formulas to the specific test cases.\n\n**Test 1:** Free surface (Dirichlet), $s = 1.0$, $G_{\\infty} = 0.2$, $h = 5.0$, $\\theta = \\pi/2$.\n-   $g_x = G_{\\infty} = 0.2$\n-   $g_y = \\frac{s}{4\\pi h} = \\frac{1.0}{4\\pi (5.0)} = \\frac{1}{20\\pi} \\approx 0.015915$\n-   $\\alpha_1 = \\operatorname{atan2}(1/(20\\pi), 0.2) \\approx 0.07936$ radians\n-   $A_1 = \\frac{1/(20\\pi)}{0.2} = \\frac{1}{4\\pi} \\approx 0.07958$\n-   $\\text{toward}_1 = (g_y  0) = (\\text{positive}  0) = \\text{False}$\n-   $W_1 = (\\pi/2  \\pi/2) = \\text{False}$\n\n**Test 2:** Rigid wall (Neumann), $s = 1.0$, $G_{\\infty} = 0.2$, $h = 5.0$, $\\theta = \\pi/3$.\n-   $g_x = G_{\\infty} = 0.2$\n-   $g_y = -\\frac{s}{4\\pi h} = -\\frac{1.0}{4\\pi (5.0)} = -\\frac{1}{20\\pi} \\approx -0.015915$\n-   $\\alpha_2 = \\operatorname{atan2}(-1/(20\\pi), 0.2) \\approx -0.07936$ radians\n-   $A_2 = \\frac{-1/(20\\pi)}{0.2} = -\\frac{1}{4\\pi} \\approx -0.07958$\n-   $\\text{toward}_2 = (g_y  0) = (\\text{negative}  0) = \\text{True}$\n-   $W_2 = (\\pi/3  \\pi/2) = \\text{True}$\n\n**Test 3:** Rigid wall (Neumann), $s = 1.0$, $G_{\\infty} = 0.2$, $h = 50.0$, $\\theta = 2\\pi/3$.\n-   $g_x = G_{\\infty} = 0.2$\n-   $g_y = -\\frac{s}{4\\pi h} = -\\frac{1.0}{4\\pi (50.0)} = -\\frac{1}{200\\pi} \\approx -0.0015915$\n-   $\\alpha_3 = \\operatorname{atan2}(-1/(200\\pi), 0.2) \\approx -0.007955$ radians\n-   $A_3 = \\frac{-1/(200\\pi)}{0.2} = -\\frac{1}{40\\pi} \\approx -0.007958$\n-   $\\text{toward}_3 = (g_y  0) = (\\text{negative}  0) = \\text{True}$\n-   $W_3 = (2\\pi/3  \\pi/2) = (0.666\\dots\\pi  0.5\\pi) = \\text{False}$\n\nThe implementation will follow these calculations directly.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes steering and asymmetry for a dendrite tip near a planar boundary.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (boundary_type, s, G_infinity, h, theta)\n    # boundary_type: 'dirichlet' for free surface, 'neumann' for rigid wall\n    test_cases = [\n        ('dirichlet', 1.0, 0.2, 5.0, np.pi/2),\n        ('neumann',   1.0, 0.2, 5.0, np.pi/3),\n        ('neumann',   1.0, 0.2, 50.0, 2*np.pi/3),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        boundary_type, s, g_inf, h, theta = case\n\n        # The x-component of the driving vector is determined by the far-field gradient.\n        # g_x = G_infinity\n        g_x = g_inf\n\n        # The y-component is determined by the image source.\n        # The image source strength s_image is -s for Dirichlet and +s for Neumann.\n        # g_y = -s_image / (4 * pi * h)\n        if boundary_type == 'dirichlet':\n            s_image = -s\n        elif boundary_type == 'neumann':\n            s_image = s\n        else:\n            raise ValueError(\"Unknown boundary type\")\n\n        g_y = -s_image / (4 * np.pi * h)\n\n        # 1. Steering angle alpha in radians\n        alpha = np.arctan2(g_y, g_x)\n\n        # 2. Asymmetry index A\n        A = g_y / g_x\n        \n        # 3. Boolean indicating steering toward the boundary\n        toward = g_y  0\n\n        # 4. Boolean indicating contact-angle-based wetting predisposition\n        W = theta  (np.pi / 2)\n        \n        # Append this case's results to the master list\n        all_results.extend([alpha, A, toward, W])\n\n    # Final print statement in the exact required format.\n    # The format is a single line, comma-separated list enclosed in square brackets.\n    # Booleans are represented as 'True' or 'False'.\n    output_str = f\"[{','.join(map(str, all_results))}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3476682"}, {"introduction": "This final practice serves as a capstone exercise, challenging you to build a complete, one-dimensional multi-phase-field model from the ground up to simulate a complex peritectic solidification process. You will implement a coupled system of equations describing the evolution of two solid phases and a conserved composition field under directional solidification conditions [@problem_id:3476675]. This hands-on simulation requires you to integrate concepts of phase-field thermodynamics, numerical discretization for coupled PDEs, and post-processing to analyze sophisticated phenomena like phase competition, solute pile-up, and the formation of transient peritectic islands.", "problem": "You are asked to design and implement a minimal, self-consistent one-dimensional multi-phase-field solver to study directional solidification in a peritectic system with the peritectic reaction $L+\\alpha\\to\\beta$. The formulation uses three order parameters for the phases: $\\phi_{\\alpha}$, $\\phi_{\\beta}$, and $\\phi_{L}$, constrained such that $\\phi_{\\alpha}+\\phi_{\\beta}+\\phi_{L}=1$, where each $\\phi$ lies in $[0,1]$. The composition field is $c(x,t)\\in[0,1]$. All quantities are nondimensional.\n\nStart from the following fundamental base and core definitions:\n- Variational dynamics for non-conserved (Allen–Cahn) order parameters: $\\partial \\phi_i/\\partial t = -L\\,\\delta \\mathcal{F}/\\delta \\phi_i$, where $L0$ is a mobility and $\\mathcal{F}$ is a free-energy functional.\n- Conservation law for a conserved composition field with diffusion and advection: $\\partial c/\\partial t = \\nabla\\cdot\\left(D(\\phi_L)\\nabla c\\right) - V_p \\,\\partial c/\\partial x + S$, where $D(\\phi_L)$ is a phase-dependent diffusivity, $V_p\\ge 0$ is a pulling velocity, and $S$ is a source term accounting for solute exchange during phase change.\n- Directional solidification thermal field with constant gradient: $T(x,t)=T_0+G\\,(x - V_p\\,t)$, where $T_0$ and $G0$ are constants.\n\nDefine a tractable free-energy density $\\psi$ per unit volume for the order parameters that includes double wells, a mixing penalty to discourage phase overlap, a gradient penalty for interfaces, and a tilt that encodes the local thermodynamic driving force for each phase:\n- Double-well for each solid order parameter: $W\\,\\phi_i^2(1-\\phi_i)^2$ with $W0$ and $i\\in\\{\\alpha,\\beta\\}$.\n- Multi-phase penalty expressed in terms of $\\phi_{\\alpha}$ and $\\phi_{\\beta}$ with $\\phi_{L}=1-\\phi_{\\alpha}-\\phi_{\\beta}$: $\\eta\\left(\\phi_{\\alpha}+\\phi_{\\beta}-\\phi_{\\alpha}^2-\\phi_{\\beta}^2-\\phi_{\\alpha}\\phi_{\\beta}\\right)$ with $\\eta0$.\n- Gradient penalty: $(\\varepsilon^2/2)\\left(|\\nabla \\phi_{\\alpha}|^2+|\\nabla \\phi_{\\beta}|^2\\right)$ with $\\varepsilon0$.\n- Thermodynamic tilts for each solid phase: $-\\lambda_i f_i(T,c)\\,h(\\phi_i)$ with $i\\in\\{\\alpha,\\beta\\}$, $\\lambda_i0$, $h(\\phi)=\\phi^2(3-2\\phi)$, and $f_i(T,c)=T_{\\ell,i}(c)-T$ the local driving force. Assume linearized liquidus relations $T_{\\ell,i}(c)=T_i^0+m_i\\,c$ with constants $T_i^0$ and $m_i$.\n\nUsing these, the phase-field equations in one dimension are:\n- For $i\\in\\{\\alpha,\\beta\\}$,\n$$\n\\frac{\\partial \\phi_i}{\\partial t} = -L\\left(\\frac{\\partial \\psi}{\\partial \\phi_i} - \\varepsilon^2 \\frac{\\partial^2 \\phi_i}{\\partial x^2}\\right),\n$$\nwith\n$$\n\\frac{\\partial \\psi}{\\partial \\phi_{\\alpha}} = 2W\\,\\phi_{\\alpha}(1-\\phi_{\\alpha})(1-2\\phi_{\\alpha}) + \\eta\\,(1-2\\phi_{\\alpha}-\\phi_{\\beta}) - \\lambda_{\\alpha} f_{\\alpha}(T,c)\\,h'(\\phi_{\\alpha}),\n$$\n$$\n\\frac{\\partial \\psi}{\\partial \\phi_{\\beta}} = 2W\\,\\phi_{\\beta}(1-\\phi_{\\beta})(1-2\\phi_{\\beta}) + \\eta\\,(1-2\\phi_{\\beta}-\\phi_{\\alpha}) - \\lambda_{\\beta} f_{\\beta}(T,c)\\,h'(\\phi_{\\beta}),\n$$\nand $h'(\\phi)=6\\phi(1-\\phi)$. Enforce $\\phi_L=1-\\phi_{\\alpha}-\\phi_{\\beta}$ and project $\\phi_{\\alpha},\\phi_{\\beta},\\phi_{L}$ into $[0,1]$ after each time step to maintain the constraint.\n\n- For the composition field,\n$$\n\\frac{\\partial c}{\\partial t} = \\frac{\\partial}{\\partial x}\\left(D(\\phi_L)\\frac{\\partial c}{\\partial x}\\right) - V_p \\frac{\\partial c}{\\partial x} + S,\n$$\nwith $D(\\phi_L)=D_L\\,\\phi_L + D_s\\,(1-\\phi_L)$ and small $D_s0$ for numerical regularization. Use a simplified partition-driven source term\n$$\nS = B_{\\alpha}\\,\\frac{\\partial \\phi_{\\alpha}}{\\partial t} + B_{\\beta}\\,\\frac{\\partial \\phi_{\\beta}}{\\partial t},\n$$\nwhere $B_i=(1-k_i)\\,c_{\\mathrm{ref}}$ with effective partition coefficients $k_i\\in(0,1)$ and a reference concentration $c_{\\mathrm{ref}}$.\n\nDiscretize in space on a uniform grid of length $L_x$ with $N_x$ points and no-flux (Neumann) boundary conditions for all fields. Use:\n- Central differences for spatial derivatives and the discrete Laplacian with Neumann boundary conditions.\n- Explicit time stepping (forward Euler) for $\\phi_{\\alpha}$ and $\\phi_{\\beta}$.\n- Explicit time stepping for $c$ with an upwind discretization for the advection term $-V_p\\,\\partial c/\\partial x$.\n\nInitial conditions at $t=0$:\n- $\\phi_{\\alpha}(x,0)\\approx 1$ for $x\\in[0,w_{\\alpha}]$ transitioning smoothly to $0$ over an interfacial width of order $\\varepsilon$, and $0$ elsewhere.\n- $\\phi_{\\beta}(x,0)=0$ except possibly for a small nucleus specified in selected test cases.\n- $c(x,0)=c_0$ uniform.\n\nParameter values are nondimensional. The numerical solver should run for a fixed final time $t_f$.\n\nYour program must implement the above model and, for each test case defined below, compute three diagnostic quantities:\n1. The front leader indicator $I_{\\mathrm{lead}}\\in\\{0,1\\}$ at final time $t_f$, where $0$ means the $\\alpha$ front leads and $1$ means the $\\beta$ front leads. Define the front position of phase $i$ as $x_i=\\max\\{x: \\phi_i(x,t_f)\\ge 0.5\\}$ (if no such $x$ exists, take $x_i=-\\infty$). The leading phase is the one with larger $x_i$.\n2. The maximum solute pile-up $\\Delta c_{\\max}=\\max_x c(x,t)-c_0$ observed over the entire simulation time window $[0,t_f]$, returned as a float rounded to three decimals.\n3. The transient peritectic island indicator $I_{\\mathrm{isl}}\\in\\{0,1\\}$, which equals $1$ if at any time $t\\in(0,t_f)$ the number of disjoint contiguous clusters where $\\phi_{\\beta}(x,t)0.6$ exceeds the final number of such clusters at $t=t_f$ and is at least $2$ at some time; otherwise $0$.\n\nSimulation and numerical details to implement:\n- Domain and grid: $L_x=1$, $N_x=128$, grid spacing $\\Delta x=L_x/N_x$.\n- Time step and duration: $\\Delta t=5\\times 10^{-4}$, $t_f=N_t\\,\\Delta t$ with $N_t=800$.\n- Boundary conditions: homogeneous Neumann at $x=0$ and $x=L_x$ for all fields.\n- Parameters common to all cases: $W=2$, $\\eta=2$, $\\varepsilon=0.02$, $L=1$, $D_s=10^{-4}$, $T_0=0.35$, $G=0.5$, $T_{\\alpha}^0=0.50$, $m_{\\alpha}=-0.30$, $T_{\\beta}^0=0.55$, $m_{\\beta}=-0.60$, $\\lambda_{\\alpha}=1.0$, $k_{\\alpha}=0.7$, $k_{\\beta}=0.6$, $c_{\\mathrm{ref}}=c_0$, $w_{\\alpha}=0.10$, initial $c_0=0.30$.\n- Initial $\\phi_{\\alpha}(x,0)$ profile: $\\phi_{\\alpha}(x,0)=\\frac{1}{2}\\left[1-\\tanh\\left(\\frac{x-w_{\\alpha}}{\\sqrt{2}\\,\\varepsilon}\\right)\\right]$ and truncated to $[0,1]$.\n- Initial $\\phi_{\\beta}(x,0)$: zero unless specified otherwise; a nucleus is a Gaussian $\\phi_{\\beta}(x,0)=A_{\\beta}\\exp\\left(-\\frac{(x-x_{\\beta})^2}{2\\sigma_{\\beta}^2}\\right)$ truncated to $[0,1]$ with width $\\sigma_{\\beta}=0.01$.\n\nTest suite of three cases (all nondimensional):\n- Case $1$: $(V_p,D_L,\\lambda_{\\beta},A_{\\beta})=(0.4,5\\times 10^{-4},0.8,0.0)$.\n- Case $2$: $(V_p,D_L,\\lambda_{\\beta},A_{\\beta})=(0.8,7.5\\times 10^{-4},1.2,0.0)$.\n- Case $3$: $(V_p,D_L,\\lambda_{\\beta},A_{\\beta})=(1.0,5\\times 10^{-4},1.1,0.20)$ with $x_{\\beta}=0.35$.\n\nAngle units are not applicable. All outputs are nondimensional. Your program should produce a single line of output containing the results for all three test cases as a comma-separated list of nine entries enclosed in square brackets in the order\n$[I_{\\mathrm{lead}}^{(1)},\\Delta c_{\\max}^{(1)},I_{\\mathrm{isl}}^{(1)},I_{\\mathrm{lead}}^{(2)},\\Delta c_{\\max}^{(2)},I_{\\mathrm{isl}}^{(2)},I_{\\mathrm{lead}}^{(3)},\\Delta c_{\\max}^{(3)},I_{\\mathrm{isl}}^{(3)}]$\nwith each $\\Delta c_{\\max}^{(i)}$ rounded to three decimals and the indicators as integers $0$ or $1$.", "solution": "The user-provided problem statement has been critically validated and is deemed **valid**. It is scientifically grounded in the principles of computational materials science, specifically using a multi-phase-field model for solidification. The problem is well-posed, providing a complete and consistent set of governing partial differential equations, parameters, initial/boundary conditions, and numerical discretization schemes. It is objective and formalizable, allowing for a unique numerical solution.\n\nThe problem requires the implementation of a one-dimensional, three-phase peritectic solidification solver. The model couples two non-conserved Allen-Cahn equations for the solid phase order parameters, $\\phi_{\\alpha}$ and $\\phi_{\\beta}$, with a Cahn-Hilliard-type advection-diffusion-reaction equation for the conserved composition field, $c$. The system evolves under a moving temperature gradient, simulating directional solidification.\n\nThe solution is implemented by discretizing the governing equations on a uniform spatial grid and integrating forward in time using an explicit Euler scheme, as specified. The numerical implementation consists of the following key steps:\n\n1.  **Grid and Field Initialization**: A one-dimensional grid of $N_x=128$ points is established for a domain of length $L_x=1$. The fields $\\phi_{\\alpha}$, $\\phi_{\\beta}$, and $c$ are initialized as NumPy arrays according to the problem's initial conditions. Specifically, $\\phi_{\\alpha}(x,0)$ is a smooth step-like profile, $c(x,0)$ is uniform at $c_0$, and $\\phi_{\\beta}(x,0)$ is zero, except in test case 3 where a Gaussian nucleus is introduced.\n\n2.  **Discretization of Spatial Operators**:\n    *   The Laplacian operator, $\\partial^2/\\partial x^2$, appearing in the Allen-Cahn equations for $\\phi_{\\alpha}$ and $\\phi_{\\beta}$, is discretized using a second-order central difference scheme. Homogeneous Neumann boundary conditions ($\\partial \\phi_i/\\partial x = 0$) are enforced at the domain boundaries $x=0$ and $x=L_x$.\n    *   The advection term, $-V_p \\partial c/\\partial x$, in the composition equation is discretized using a first-order upwind scheme, which is appropriate for transport-dominated phenomena and enhances numerical stability. The boundary condition is handled by assuming zero advective contribution at the upwind boundary.\n    *   The variable-coefficient diffusion term, $\\partial/\\partial x (D(\\phi_L) \\partial c/\\partial x)$, is discretized using a finite-volume-like approach on the staggered grid to ensure local conservation. The phase-dependent diffusivity $D(\\phi_L)$ is evaluated at cell interfaces. Homogeneous Neumann boundary conditions for the composition field, $\\partial c/\\partial x=0$, translate to a zero-flux condition for the diffusive part at the boundaries.\n\n3.  **Time Integration**: An explicit forward Euler method is used for time-stepping all three fields, as mandated. The time step is $\\Delta t = 5 \\times 10^{-4}$. Inside the main time loop, which runs for $N_t=800$ steps:\n    *   The moving temperature field $T(x,t)$ is updated at each step.\n    *   The right-hand side (RHS) of each governing PDE is calculated using the field values from the previous time step. This includes evaluating the chemical potential derivatives from the free-energy functional and the source term $S$ for the composition equation.\n    *   Field values are updated: $\\mathbf{u}^{n+1} = \\mathbf{u}^{n} + \\Delta t \\cdot \\text{RHS}(\\mathbf{u}^n)$, where $\\mathbf{u} = (\\phi_{\\alpha}, \\phi_{\\beta}, c)$.\n    *   After each update, a projection step enforces the physical constraints on the order parameters. The values of $\\phi_{\\alpha}$ and $\\phi_{\\beta}$ are first clipped to the interval $[0,1]$. Then, in grid cells where their sum exceeds $1$, they are normalized to ensure $\\phi_{\\alpha} + \\phi_{\\beta} \\le 1$, which guarantees $\\phi_L = 1 - \\phi_{\\alpha} - \\phi_{\\beta} \\ge 0$.\n\n4.  **Diagnostic Calculations**: Throughout the simulation and at its conclusion, the three specified diagnostic quantities are computed for each test case:\n    *   **Front Leader Indicator ($I_{\\mathrm{lead}}$)**: At the final time $t_f$, the positions of the $\\alpha$ and $\\beta$ solidification fronts are determined by finding the maximum coordinate $x$ where $\\phi_i(x,t_f) \\ge 0.5$. The leading phase is the one with the larger front position.\n    *   **Maximum Solute Pile-up ($\\Delta c_{\\max}$)**: The maximum value of $c(x,t) - c_0$ is tracked across all grid points and all time steps during the simulation. The final result is rounded to three decimal places.\n    *   **Transient Peritectic Island Indicator ($I_{\\mathrm{isl}}$)**: At each time step, the number of distinct spatial clusters where $\\phi_{\\beta}  0.6$ is counted using the `scipy.ndimage.label` function. The indicator is set to $1$ if the maximum number of clusters observed during the simulation (for $t \\in (0, t_f)$) is greater than the final number of clusters at $t=t_f$, and if at some point at least two clusters existed. Otherwise, it is $0$.\n\nThe following code implements this numerical solution for the three specified test cases and formats the output as required.", "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import label\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n\n    def run_simulation(case_params):\n        \"\"\"\n        Executes a single phase-field simulation run for a given set of parameters.\n        \"\"\"\n        # Unpack case-specific parameters\n        Vp, DL, lambda_beta, A_beta, x_beta = case_params\n\n        # --- Simulation and numerical parameters ---\n        Lx = 1.0\n        Nx = 128\n        dx = Lx / Nx\n        x = np.arange(Nx) * dx\n\n        Nt = 800\n        dt = 5.0e-4\n\n        # --- Common physical parameters ---\n        W = 2.0\n        eta = 2.0\n        epsilon = 0.02\n        L_mob = 1.0  # Mobility L from the problem statement\n        Ds = 1.0e-4\n        T0 = 0.35\n        G = 0.5\n        T_alpha_0 = 0.50\n        m_alpha = -0.30\n        T_beta_0 = 0.55\n        m_beta = -0.60\n        lambda_alpha = 1.0\n        k_alpha = 0.7\n        k_beta = 0.6\n        c0 = 0.30\n        c_ref = c0\n        w_alpha = 0.10\n        sigma_beta = 0.01\n\n        B_alpha = (1.0 - k_alpha) * c_ref\n        B_beta = (1.0 - k_beta) * c_ref\n\n        # --- Initial conditions ---\n        phi_a = 0.5 * (1.0 - np.tanh((x - w_alpha) / (np.sqrt(2.0) * epsilon)))\n        phi_a = np.clip(phi_a, 0.0, 1.0)\n\n        phi_b = np.zeros_like(x)\n        if A_beta  0.0 and x_beta is not None:\n            phi_b = A_beta * np.exp(-((x - x_beta)**2) / (2.0 * sigma_beta**2))\n            phi_b = np.clip(phi_b, 0.0, 1.0)\n        \n        c = np.full_like(x, c0)\n\n        # --- Diagnostics trackers ---\n        max_delta_c = 0.0\n        num_beta_clusters_history = []\n        \n        def count_clusters(phi_field, threshold):\n            binary_field = phi_field  threshold\n            if not np.any(binary_field):\n                return 0\n            _, num_features = label(binary_field)\n            return num_features\n\n        # --- Main time integration loop ---\n        for n in range(Nt):\n            t_current = (n + 1.0) * dt\n            T = T0 + G * (x - Vp * t_current)\n            \n            phi_L = 1.0 - phi_a - phi_b\n            phi_L = np.clip(phi_L, 0.0, 1.0)\n\n            # --- RHS for phi_a and phi_b ---\n            lap_phi_a = np.zeros(Nx)\n            lap_phi_a[1:-1] = (phi_a[2:] - 2.0*phi_a[1:-1] + phi_a[:-2]) / dx**2\n            lap_phi_a[0] = 2.0 * (phi_a[1] - phi_a[0]) / dx**2\n            lap_phi_a[-1] = 2.0 * (phi_a[-2] - phi_a[-1]) / dx**2\n\n            lap_phi_b = np.zeros(Nx)\n            lap_phi_b[1:-1] = (phi_b[2:] - 2.0*phi_b[1:-1] + phi_b[:-2]) / dx**2\n            lap_phi_b[0] = 2.0 * (phi_b[1] - phi_b[0]) / dx**2\n            lap_phi_b[-1] = 2.0 * (phi_b[-2] - phi_b[-1]) / dx**2\n\n            f_alpha = (T_alpha_0 + m_alpha * c) - T\n            f_beta = (T_beta_0 + m_beta * c) - T\n            \n            h_prime_a = 6.0 * phi_a * (1.0 - phi_a)\n            h_prime_b = 6.0 * phi_b * (1.0 - phi_b)\n\n            d_psi_d_phi_a = 2.0*W*phi_a*(1.0-phi_a)*(1.0-2.0*phi_a) + eta*(1.0 - 2.0*phi_a - phi_b) - lambda_alpha * f_alpha * h_prime_a\n            d_psi_d_phi_b = 2.0*W*phi_b*(1.0-phi_b)*(1.0-2.0*phi_b) + eta*(1.0 - 2.0*phi_b - phi_a) - lambda_beta * f_beta * h_prime_b\n\n            phi_a_rhs = -L_mob * (d_psi_d_phi_a - epsilon**2 * lap_phi_a)\n            phi_b_rhs = -L_mob * (d_psi_d_phi_b - epsilon**2 * lap_phi_b)\n\n            # --- RHS for c ---\n            S = B_alpha * phi_a_rhs + B_beta * phi_b_rhs\n\n            D = DL * phi_L + Ds * (1.0 - phi_L)\n            D_plus_half = (D[1:] + D[:-1]) / 2.0\n            flux = D_plus_half * (c[1:] - c[:-1]) / dx\n            \n            diff_c_term = np.zeros(Nx)\n            diff_c_term[1:-1] = (flux[1:] - flux[:-1]) / dx\n            diff_c_term[0] = flux[0] / dx\n            diff_c_term[-1] = -flux[-1] / dx\n\n            adv_c_term = np.zeros(Nx)\n            if Vp  0:\n                adv_c_term[1:] = -Vp * (c[1:] - c[:-1]) / dx\n                # adv_c_term[0] = 0 as per Neumann BC interpretation\n\n            c_rhs = diff_c_term + adv_c_term + S\n\n            # --- Explicit Euler update ---\n            phi_a_new = phi_a + dt * phi_a_rhs\n            phi_b_new = phi_b + dt * phi_b_rhs\n            c = c + dt * c_rhs\n\n            # --- Projection step for phi ---\n            phi_a = np.clip(phi_a_new, 0.0, 1.0)\n            phi_b = np.clip(phi_b_new, 0.0, 1.0)\n            \n            sum_ab = phi_a + phi_b\n            mask = sum_ab  1.0\n            sum_ab_masked = sum_ab[mask]\n            \n            # Guard against division by zero although mask  1 prevents it.\n            # Adding a small epsilon would be more robust but is not needed here.\n            phi_a[mask] /= sum_ab_masked\n            phi_b[mask] /= sum_ab_masked\n\n            # --- Update diagnostics ---\n            max_delta_c = max(max_delta_c, np.max(c) - c0)\n            num_clusters = count_clusters(phi_b, 0.6)\n            num_beta_clusters_history.append(num_clusters)\n\n        # --- Final diagnostics calculation ---\n        # 1. Front leader indicator I_lead\n        alpha_indices = np.where(phi_a = 0.5)[0]\n        x_alpha_front = x[alpha_indices.max()] if alpha_indices.size  0 else -np.inf\n        beta_indices = np.where(phi_b = 0.5)[0]\n        x_beta_front = x[beta_indices.max()] if beta_indices.size  0 else -np.inf\n        I_lead = 1 if x_beta_front  x_alpha_front else 0\n\n        # 2. Maximum solute pile-up Delta_c_max\n        delta_c_max_rounded = round(max_delta_c, 3)\n        \n        # 3. Transient peritectic island indicator I_isl\n        I_isl = 0\n        if num_beta_clusters_history:\n            max_overall_clusters = np.max(num_beta_clusters_history)\n            if len(num_beta_clusters_history)  1:\n                final_clusters = num_beta_clusters_history[-1]\n                max_interim_clusters = np.max(num_beta_clusters_history[:-1])\n                if max_interim_clusters  final_clusters and max_overall_clusters = 2:\n                    I_isl = 1\n        \n        return I_lead, delta_c_max_rounded, I_isl\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (V_p, D_L, lambda_beta, A_beta, x_beta)\n        (0.4, 5.0e-4, 0.8, 0.0, None),\n        (0.8, 7.5e-4, 1.2, 0.0, None),\n        (1.0, 5.0e-4, 1.1, 0.20, 0.35),\n    ]\n\n    results = []\n    for case in test_cases:\n        res = run_simulation(case)\n        results.extend(res)\n\n    # Format each float to three decimal places before joining.\n    formatted_results = [f\"{r:.3f}\" if isinstance(r, float) else str(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3476675"}]}