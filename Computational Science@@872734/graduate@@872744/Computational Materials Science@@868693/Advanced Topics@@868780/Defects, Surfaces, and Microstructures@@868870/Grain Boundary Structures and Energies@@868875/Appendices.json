{"hands_on_practices": [{"introduction": "A primary goal in computational materials science is to determine fundamental properties like grain boundary energy, $\\gamma_{gb}$. This exercise provides a comprehensive workflow for computing the energy of a specific interface—the coherent $\\Sigma 3$ twin boundary in Nickel—using multiple theoretical methods, including Density Functional Theory (DFT) and classical potentials. To ground these predictions, the results are then reconciled with data from a proxy experiment using a principled statistical model, yielding a single, robust estimate of the grain boundary energy with a credible uncertainty budget [@problem_id:3455409]. This practice emphasizes the importance of data fusion and meta-analysis in obtaining reliable materials properties.", "problem": "You are tasked with developing a complete, runnable program that estimates the grain boundary energy for a face-centered cubic (FCC) Nickel (Ni) $\\Sigma 3$ coherent twin boundary using two Density Functional Theory (DFT) functionals and two classical interatomic potentials, quantifies uncertainties from the underlying energetic inputs, and reconciles these calculations with thermal-grooving measurements via a principled model-averaging procedure. The program must start from fundamental definitions and well-tested physical relationships to derive the necessary expressions. The final outputs must be expressed in millijoules per square meter (mJ/m$^2$).\n\nThe computational scenario is as follows:\n- The grain boundary energy is defined as an interfacial excess free energy per unit area. In a periodic bicrystal supercell that contains two identical grain boundaries, the interface excess energy is obtained from the difference between the total energy of the bicrystal and the energy of the equivalent number of atoms in the bulk reference, divided by the total interfacial area and the number of identical interfaces.\n- The thermal grooving measurement at a free surface that intersects a grain boundary yields a geometric equilibrium condition that relates the grain boundary energy to the surface energy of Nickel and the dihedral angle at the groove root. The angle unit is specified in degrees.\n\nYour program must:\n- Derive the expressions needed to compute the grain boundary energy for each method and the propagation of uncertainties from the given energetic inputs.\n- Derive the relation needed to compute the grain boundary energy from thermal grooving data and propagate its uncertainties with respect to both the surface energy and the measured angle.\n- Reconcile all estimates using a statistically principled weighted average that accounts for both within-method uncertainty and potential between-method dispersion.\n\nAll inputs are provided as physically plausible, internally consistent values. For each test case, you are given the bicrystal area in square angstroms, the number of atoms in the bicrystal, and the energy data for two Density Functional Theory (DFT) functionals—Perdew–Burke–Ernzerhof (PBE) and Strongly Constrained and Appropriately Normed (SCAN)—and two classical potentials—Embedded Atom Method (EAM) and Modified Embedded Atom Method (MEAM). Each method includes total bicrystal energy, bulk per-atom energy (to define the bulk reference), and uncertainties for these energies. The thermal grooving dataset consists of the Nickel surface energy, its uncertainty, the measured dihedral angle at the groove intersection in degrees, and its uncertainty in degrees. The unit for the final grain boundary energies must be millijoules per square meter (mJ/m$^2$).\n\nAngle units must be treated in degrees. Your program must compute and output only the requested values in the specified format.\n\nUse the following test suite of three parameter sets:\n\n- Test case $1$:\n  - Bicrystal geometry: area $A = 800$ $\\text{\\AA}^2$, atoms $N = 480$.\n  - DFT (PBE): $E_{\\text{bulk,atom}} = -4.30$ $\\text{eV}$, $E_{\\text{cell}} = -2060.8064$ $\\text{eV}$, $\\sigma_{E_{\\text{cell}}} = 0.015$ $\\text{eV}$, $\\sigma_{E_{\\text{bulk}}} = 0.0001$ $\\text{eV}$.\n  - DFT (SCAN): $E_{\\text{bulk,atom}} = -4.45$ $\\text{eV}$, $E_{\\text{cell}} = -2132.5072$ $\\text{eV}$, $\\sigma_{E_{\\text{cell}}} = 0.020$ $\\text{eV}$, $\\sigma_{E_{\\text{bulk}}} = 0.0001$ $\\text{eV}$.\n  - EAM: $E_{\\text{bulk,atom}} = -4.44$ $\\text{eV}$, $E_{\\text{cell}} = -2128.4080$ $\\text{eV}$, $\\sigma_{E_{\\text{cell}}} = 0.050$ $\\text{eV}$, $\\sigma_{E_{\\text{bulk}}} = 0.0010$ $\\text{eV}$.\n  - MEAM: $E_{\\text{bulk,atom}} = -4.42$ $\\text{eV}$, $E_{\\text{cell}} = -2118.3072$ $\\text{eV}$, $\\sigma_{E_{\\text{cell}}} = 0.050$ $\\text{eV}$, $\\sigma_{E_{\\text{bulk}}} = 0.0010$ $\\text{eV}$.\n  - Thermal grooving: $\\gamma_s = 1800$ $\\text{mJ/m}^2$, $\\sigma_{\\gamma_s} = 50$ $\\text{mJ/m}^2$, $\\alpha = 178.9$ degrees, $\\sigma_{\\alpha} = 0.1$ degrees.\n\n- Test case $2$:\n  - Bicrystal geometry: area $A = 600$ $\\text{\\AA}^2$, atoms $N = 360$.\n  - DFT (PBE): $E_{\\text{bulk,atom}} = -4.30$ $\\text{eV}$, $E_{\\text{cell}} = -1546.6524$ $\\text{eV}$, $\\sigma_{E_{\\text{cell}}} = 0.015$ $\\text{eV}$, $\\sigma_{E_{\\text{bulk}}} = 0.0001$ $\\text{eV}$.\n  - DFT (SCAN): $E_{\\text{bulk,atom}} = -4.45$ $\\text{eV}$, $E_{\\text{cell}} = -1600.5024$ $\\text{eV}$, $\\sigma_{E_{\\text{cell}}} = 0.020$ $\\text{eV}$, $\\sigma_{E_{\\text{bulk}}} = 0.0001$ $\\text{eV}$.\n  - EAM: $E_{\\text{bulk,atom}} = -4.44$ $\\text{eV}$, $E_{\\text{cell}} = -1597.2768$ $\\text{eV}$, $\\sigma_{E_{\\text{cell}}} = 0.050$ $\\text{eV}$, $\\sigma_{E_{\\text{bulk}}} = 0.0010$ $\\text{eV}$.\n  - MEAM: $E_{\\text{bulk,atom}} = -4.42$ $\\text{eV}$, $E_{\\text{cell}} = -1589.5524$ $\\text{eV}$, $\\sigma_{E_{\\text{cell}}} = 0.050$ $\\text{eV}$, $\\sigma_{E_{\\text{bulk}}} = 0.0010$ $\\text{eV}$.\n  - Thermal grooving: $\\gamma_s = 1800$ $\\text{mJ/m}^2$, $\\sigma_{\\gamma_s} = 50$ $\\text{mJ/m}^2$, $\\alpha = 179.5$ degrees, $\\sigma_{\\alpha} = 0.2$ degrees.\n\n- Test case $3$:\n  - Bicrystal geometry: area $A = 900$ $\\text{\\AA}^2$, atoms $N = 520$.\n  - DFT (PBE): $E_{\\text{bulk,atom}} = -4.30$ $\\text{eV}$, $E_{\\text{cell}} = -2232.2956$ $\\text{eV}$, $\\sigma_{E_{\\text{cell}}} = 0.015$ $\\text{eV}$, $\\sigma_{E_{\\text{bulk}}} = 0.0001$ $\\text{eV}$.\n  - DFT (SCAN): $E_{\\text{bulk,atom}} = -4.45$ $\\text{eV}$, $E_{\\text{cell}} = -2309.9570$ $\\text{eV}$, $\\sigma_{E_{\\text{cell}}} = 0.020$ $\\text{eV}$, $\\sigma_{E_{\\text{bulk}}} = 0.0001$ $\\text{eV}$.\n  - EAM: $E_{\\text{bulk,atom}} = -4.44$ $\\text{eV}$, $E_{\\text{cell}} = -2305.5438$ $\\text{eV}$, $\\sigma_{E_{\\text{cell}}} = 0.050$ $\\text{eV}$, $\\sigma_{E_{\\text{bulk}}} = 0.0010$ $\\text{eV}$.\n  - MEAM: $E_{\\text{bulk,atom}} = -4.42$ $\\text{eV}$, $E_{\\text{cell}} = -2294.9188$ $\\text{eV}$, $\\sigma_{E_{\\text{cell}}} = 0.050$ $\\text{eV}$, $\\sigma_{E_{\\text{bulk}}} = 0.0010$ $\\text{eV}$.\n  - Thermal grooving: $\\gamma_s = 1800$ $\\text{mJ/m}^2$, $\\sigma_{\\gamma_s} = 50$ $\\text{mJ/m}^2$, $\\alpha = 178.0$ degrees, $\\sigma_{\\alpha} = 0.1$ degrees.\n\nYour program must implement the following computational steps for each test case:\n- Compute the grain boundary energy for each method from the bicrystal total energy and the bulk reference, acknowledging that the bicrystal cell contains two identical grain boundaries.\n- Propagate uncertainties from the provided energy uncertainties to the grain boundary energy uncertainty for each method.\n- Compute the grain boundary energy from thermal grooving and propagate its uncertainty with respect to both the surface energy and the angle (the angle must be treated in degrees).\n- Perform a random-effects model averaging across all five estimates (the two DFT functionals, the two classical potentials, and thermal grooving) to yield a reconciled mean and uncertainty that account for both within-method variance and between-method dispersion.\n- Express all grain boundary energies and uncertainties in mJ/m$^2$.\n\nFinal output format specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a sublist of three floats in mJ/m$^2$, ordered as $[$consolidated mean$, $consolidated standard deviation$, $thermal grooving energy$]$.\n- Use degree units for all angles.\n- Round each float in the final output to one decimal place.\n- Example of the required output format with three test cases: $[[x_1,y_1,z_1],[x_2,y_2,z_2],[x_3,y_3,z_3]]$ where all $x_i$, $y_i$, $z_i$ are floats in mJ/m$^2$.\n\nAll computations must be performed without reading external files and without any user input. The program must be deterministic and self-contained.", "solution": "The problem requires the calculation of the grain boundary energy for a $\\Sigma 3$ coherent twin boundary in Nickel (Ni) using multiple theoretical and experimental methods, and then reconciling these estimates using a statistically principled model. The solution is presented in four parts: derivation of the grain boundary energy from atomistic simulations, derivation from thermal grooving experiments, the statistical model for data reconciliation, and the necessary unit conversions.\n\nThe following physical constants and conversion factors will be used:\n- Elementary charge, $e = 1.602176634 \\times 10^{-19}$ C.\n- $1$ eV $= 1.602176634 \\times 10^{-19}$ J.\n- $1$ Angstrom ($\\text{\\AA}$) = $10^{-10}$ m.\n\n### 1. Grain Boundary Energy from Atomistic Simulations\n\nThe grain boundary energy, $\\gamma_{gb}$, is defined as the excess free energy per unit area of the interface. For a periodic bicrystal supercell of cross-sectional area $A$ containing $N$ atoms and two identical grain boundaries, $\\gamma_{gb}$ is computed by subtracting the energy of an equivalent number of atoms in a perfect bulk crystal ($N E_{\\text{bulk,atom}}$) from the total energy of the supercell ($E_{\\text{cell}}$), and dividing by the total area of the two interfaces ($2A$).\n\n$$ \\gamma_{gb} = \\frac{E_{\\text{cell}} - N E_{\\text{bulk,atom}}}{2A} $$\n\nHere, $E_{\\text{bulk,atom}}$ is the energy per atom in the bulk reference state.\n\nThe uncertainty in $\\gamma_{gb}$ is determined by propagating the uncertainties of the input energies, $\\sigma_{E_{\\text{cell}}}$ and $\\sigma_{E_{\\text{bulk,atom}}}$. Assuming these uncertainties are independent, the variance of $\\gamma_{gb}$ is given by the standard error propagation formula:\n\n$$ \\sigma_{\\gamma_{gb}}^2 = \\left(\\frac{\\partial \\gamma_{gb}}{\\partial E_{\\text{cell}}}\\right)^2 \\sigma_{E_{\\text{cell}}}^2 + \\left(\\frac{\\partial \\gamma_{gb}}{\\partial E_{\\text{bulk,atom}}}\\right)^2 \\sigma_{E_{\\text{bulk,atom}}}^2 $$\n\nThe partial derivatives are:\n$$ \\frac{\\partial \\gamma_{gb}}{\\partial E_{\\text{cell}}} = \\frac{1}{2A} $$\n$$ \\frac{\\partial \\gamma_{gb}}{\\partial (N E_{\\text{bulk,atom}})} = -\\frac{1}{2A} \\implies \\frac{\\partial \\gamma_{gb}}{\\partial E_{\\text{bulk,atom}}} = -\\frac{N}{2A} $$\n\nSubstituting these into the variance equation:\n$$ \\sigma_{\\gamma_{gb}}^2 = \\left(\\frac{1}{2A}\\right)^2 \\sigma_{E_{\\text{cell}}}^2 + \\left(-\\frac{N}{2A}\\right)^2 \\sigma_{E_{\\text{bulk,atom}}}^2 $$\n$$ \\sigma_{\\gamma_{gb}}^2 = \\frac{\\sigma_{E_{\\text{cell}}}^2 + N^2 \\sigma_{E_{\\text{bulk,atom}}}^2}{4A^2} $$\n\nThe standard deviation is the square root of the variance:\n$$ \\sigma_{\\gamma_{gb}} = \\frac{\\sqrt{\\sigma_{E_{\\text{cell}}}^2 + N^2 \\sigma_{E_{\\text{bulk,atom}}}^2}}{2A} $$\n\nThese formulas are applied to the data from the two Density Functional Theory (DFT) functionals (PBE, SCAN) and the two classical interatomic potentials (EAM, MEAM).\n\n### 2. Grain Boundary Energy from Thermal Grooving\n\nThe thermal grooving method relates the grain boundary energy $\\gamma_{gb}$ to the surface energy $\\gamma_s$ and the equilibrium dihedral angle $\\alpha$ at the root of the groove where the grain boundary intersects the free surface. The relationship is derived from the balance of interfacial tension forces at the triple line, known as the Young-Dupré equation for a symmetric boundary:\n\n$$ \\gamma_{gb} = 2 \\gamma_s \\cos\\left(\\frac{\\alpha}{2}\\right) $$\n\nThe angle $\\alpha$ is given in degrees and must be converted to radians for use in trigonometric functions.\n\nThe uncertainty in $\\gamma_{gb}$ from this method is found by propagating the uncertainties in $\\gamma_s$ and $\\alpha$, $\\sigma_{\\gamma_s}$ and $\\sigma_{\\alpha}$, respectively. Assuming these are independent, the variance $\\sigma_{\\gamma_{gb}}^2$ is:\n\n$$ \\sigma_{\\gamma_{gb}}^2 = \\left(\\frac{\\partial \\gamma_{gb}}{\\partial \\gamma_s}\\right)^2 \\sigma_{\\gamma_s}^2 + \\left(\\frac{\\partial \\gamma_{gb}}{\\partial \\alpha}\\right)^2 \\sigma_{\\alpha}^2 $$\n\nThe partial derivatives are:\n$$ \\frac{\\partial \\gamma_{gb}}{\\partial \\gamma_s} = 2 \\cos\\left(\\frac{\\alpha}{2}\\right) $$\n$$ \\frac{\\partial \\gamma_{gb}}{\\partial \\alpha} = 2 \\gamma_s \\left(-\\sin\\left(\\frac{\\alpha}{2}\\right) \\cdot \\frac{1}{2}\\right) = -\\gamma_s \\sin\\left(\\frac{\\alpha}{2}\\right) $$\n\nFor the derivative with respect to $\\alpha$, the angle and its uncertainty must be in radians. Let $\\alpha_{rad}$ and $\\sigma_{\\alpha,rad}$ be the angle and its uncertainty in radians. The conversion is $\\sigma_{\\alpha,rad} = \\sigma_{\\alpha,deg} \\cdot \\frac{\\pi}{180}$. The variance is thus:\n\n$$ \\sigma_{\\gamma_{gb}}^2 = \\left[2 \\cos\\left(\\frac{\\alpha_{rad}}{2}\\right)\\right]^2 \\sigma_{\\gamma_s}^2 + \\left[-\\gamma_s \\sin\\left(\\frac{\\alpha_{rad}}{2}\\right)\\right]^2 \\sigma_{\\alpha,rad}^2 $$\n\n### 3. Statistical Reconciliation via Random-Effects Model\n\nWe have $k=5$ estimates of $\\gamma_{gb}$, denoted $y_i$, each with a corresponding variance $v_i = \\sigma_i^2$, for $i=1, \\dots, k$. These estimates are derived from different physical models and an experiment, so systematic differences between them (heterogeneity) are expected in addition to the statistical uncertainty within each estimate. A random-effects meta-analysis model is appropriate for combining these results. This model assumes that each study estimates a slightly different true value $\\mu_i$, where the $\\mu_i$ are drawn from a common distribution with mean $\\mu$ and variance $\\tau^2$. The parameter $\\tau^2$ represents the between-method variance (or dispersion).\n\nThe procedure is as follows:\n1.  **Estimate Between-Method Variance ($\\tau^2$)**: The DerSimonian-Laird method is used. First, we compute Cochran's $Q$ statistic, which measures the total weighted variation:\n    $$ Q = \\sum_{i=1}^{k} w_i^{FE}(y_i - \\hat{\\mu}_{FE})^2 $$\n    where $w_i^{FE} = 1/v_i$ are the fixed-effect weights and $\\hat{\\mu}_{FE} = \\frac{\\sum w_i^{FE}y_i}{\\sum w_i^{FE}}$ is the fixed-effect mean.\n    The estimator for $\\tau^2$ is:\n    $$ \\hat{\\tau}^2 = \\max\\left(0, \\frac{Q - (k-1)}{C}\\right) \\quad \\text{where} \\quad C = \\sum w_i^{FE} - \\frac{\\sum (w_i^{FE})^2}{\\sum w_i^{FE}} $$\n\n2.  **Compute Consolidated Mean and Uncertainty**: New weights (random-effects weights) are calculated that incorporate both within-method variance ($v_i$) and between-method variance ($\\hat{\\tau}^2$):\n    $$ w_i^{RE} = \\frac{1}{v_i + \\hat{\\tau}^2} $$\n    The consolidated mean (random-effects mean) is the weighted average using these new weights:\n    $$ \\hat{\\mu}_{RE} = \\frac{\\sum_{i=1}^{k} w_i^{RE} y_i}{\\sum_{i=1}^{k} w_i^{RE}} $$\n    The variance of this consolidated mean is:\n    $$ v_{\\hat{\\mu}_{RE}} = \\frac{1}{\\sum_{i=1}^{k} w_i^{RE}} $$\n    The consolidated standard deviation is $\\sigma_{\\hat{\\mu}_{RE}} = \\sqrt{v_{\\hat{\\mu}_{RE}}}$. The values $\\hat{\\mu}_{RE}$ and $\\sigma_{\\hat{\\mu}_{RE}}$ are the final reconciled estimate and its uncertainty.\n\n### 4. Unit Conversion\n\nThe atomistic calculations yield $\\gamma_{gb}$ in units of eV/$\\text{\\AA}^2$. The final results must be in millijoules per square meter (mJ/m$^2$). The conversion factor is derived as follows:\n$$ 1 \\frac{\\text{eV}}{\\text{\\AA}^2} = \\frac{1.602176634 \\times 10^{-19} \\text{ J}}{(10^{-10} \\text{ m})^2} = \\frac{1.602176634 \\times 10^{-19} \\text{ J}}{10^{-20} \\text{ m}^2} = 16.02176634 \\frac{\\text{J}}{\\text{m}^2} $$\nTo convert J/m$^2$ to mJ/m$^2$, we multiply by $1000$:\n$$ 1 \\frac{\\text{eV}}{\\text{\\AA}^2} = 16021.76634 \\frac{\\text{mJ}}{\\text{m}^2} $$\nThis conversion factor is applied to both the grain boundary energy values and their standard deviations obtained from the atomistic simulations. The thermal grooving calculation is performed using $\\gamma_s$ in mJ/m$^2$, so its results are already in the correct final unit. All five estimates are in mJ/m$^2$ before being passed to the random-effects model.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the grain boundary energy problem for all test cases.\n    \"\"\"\n    \n    # Fundamental constants and conversion factors\n    EV_PER_A2_TO_MJ_PER_M2 = 16021.76634\n\n    # Test cases as provided in the problem description\n    test_cases = [\n        # Test case 1\n        {\n            \"geometry\": {\"A\": 800.0, \"N\": 480},\n            \"methods\": {\n                \"PBE\": {\"E_bulk_atom\": -4.30, \"E_cell\": -2060.8064, \"sigma_E_cell\": 0.015, \"sigma_E_bulk\": 0.0001},\n                \"SCAN\": {\"E_bulk_atom\": -4.45, \"E_cell\": -2132.5072, \"sigma_E_cell\": 0.020, \"sigma_E_bulk\": 0.0001},\n                \"EAM\": {\"E_bulk_atom\": -4.44, \"E_cell\": -2128.4080, \"sigma_E_cell\": 0.050, \"sigma_E_bulk\": 0.0010},\n                \"MEAM\": {\"E_bulk_atom\": -4.42, \"E_cell\": -2118.3072, \"sigma_E_cell\": 0.050, \"sigma_E_bulk\": 0.0010},\n            },\n            \"grooving\": {\"gamma_s\": 1800.0, \"sigma_gamma_s\": 50.0, \"alpha_deg\": 178.9, \"sigma_alpha_deg\": 0.1},\n        },\n        # Test case 2\n        {\n            \"geometry\": {\"A\": 600.0, \"N\": 360},\n            \"methods\": {\n                \"PBE\": {\"E_bulk_atom\": -4.30, \"E_cell\": -1546.6524, \"sigma_E_cell\": 0.015, \"sigma_E_bulk\": 0.0001},\n                \"SCAN\": {\"E_bulk_atom\": -4.45, \"E_cell\": -1600.5024, \"sigma_E_cell\": 0.020, \"sigma_E_bulk\": 0.0001},\n                \"EAM\": {\"E_bulk_atom\": -4.44, \"E_cell\": -1597.2768, \"sigma_E_cell\": 0.050, \"sigma_E_bulk\": 0.0010},\n                \"MEAM\": {\"E_bulk_atom\": -4.42, \"E_cell\": -1589.5524, \"sigma_E_cell\": 0.050, \"sigma_E_bulk\": 0.0010},\n            },\n            \"grooving\": {\"gamma_s\": 1800.0, \"sigma_gamma_s\": 50.0, \"alpha_deg\": 179.5, \"sigma_alpha_deg\": 0.2},\n        },\n        # Test case 3\n        {\n            \"geometry\": {\"A\": 900.0, \"N\": 520},\n            \"methods\": {\n                \"PBE\": {\"E_bulk_atom\": -4.30, \"E_cell\": -2232.2956, \"sigma_E_cell\": 0.015, \"sigma_E_bulk\": 0.0001},\n                \"SCAN\": {\"E_bulk_atom\": -4.45, \"E_cell\": -2309.9570, \"sigma_E_cell\": 0.020, \"sigma_E_bulk\": 0.0001},\n                \"EAM\": {\"E_bulk_atom\": -4.44, \"E_cell\": -2305.5438, \"sigma_E_cell\": 0.050, \"sigma_E_bulk\": 0.0010},\n                \"MEAM\": {\"E_bulk_atom\": -4.42, \"E_cell\": -2294.9188, \"sigma_E_cell\": 0.050, \"sigma_E_bulk\": 0.0010},\n            },\n            \"grooving\": {\"gamma_s\": 1800.0, \"sigma_gamma_s\": 50.0, \"alpha_deg\": 178.0, \"sigma_alpha_deg\": 0.1},\n        },\n    ]\n    \n    all_results = []\n\n    for case in test_cases:\n        estimates = []\n        uncertainties = []\n\n        # Part 1: Atomistic calculations\n        A = case[\"geometry\"][\"A\"]\n        N = case[\"geometry\"][\"N\"]\n        \n        for method_name, params in case[\"methods\"].items():\n            E_cell = params[\"E_cell\"]\n            E_bulk_atom = params[\"E_bulk_atom\"]\n            sigma_E_cell = params[\"sigma_E_cell\"]\n            sigma_E_bulk = params[\"sigma_E_bulk\"]\n\n            # Calculate gamma_gb in eV/A^2\n            gamma_gb_raw = (E_cell - N * E_bulk_atom) / (2 * A)\n            \n            # Propagate uncertainty for gamma_gb in eV/A^2\n            sigma_gamma_gb_raw = np.sqrt(sigma_E_cell**2 + (N * sigma_E_bulk)**2) / (2 * A)\n            \n            # Convert to mJ/m^2\n            estimates.append(gamma_gb_raw * EV_PER_A2_TO_MJ_PER_M2)\n            uncertainties.append(sigma_gamma_gb_raw * EV_PER_A2_TO_MJ_PER_M2)\n\n        # Part 2: Thermal grooving calculation\n        g = case[\"grooving\"]\n        gamma_s, sigma_gamma_s = g[\"gamma_s\"], g[\"sigma_gamma_s\"]\n        alpha_deg, sigma_alpha_deg = g[\"alpha_deg\"], g[\"sigma_alpha_deg\"]\n        \n        alpha_rad = np.deg2rad(alpha_deg)\n        sigma_alpha_rad = np.deg2rad(sigma_alpha_deg)\n        \n        # Calculate gamma_gb\n        gamma_gb_tg = 2 * gamma_s * np.cos(alpha_rad / 2)\n        \n        # Propagate uncertainty\n        d_gamma_s = 2 * np.cos(alpha_rad / 2)\n        d_alpha = -gamma_s * np.sin(alpha_rad / 2)\n        sigma_gamma_gb_tg = np.sqrt((d_gamma_s * sigma_gamma_s)**2 + (d_alpha * sigma_alpha_rad)**2)\n        \n        estimates.append(gamma_gb_tg)\n        uncertainties.append(sigma_gamma_gb_tg)\n        \n        # Part 3: Random-effects model averaging\n        y = np.array(estimates)\n        sigma = np.array(uncertainties)\n        v = sigma**2\n        k = len(y)\n        \n        # Fixed-effect calculations\n        w_fe = 1 / v\n        mu_fe = np.sum(w_fe * y) / np.sum(w_fe)\n        \n        # Cochran's Q and tau^2\n        q_stat = np.sum(w_fe * (y - mu_fe)**2)\n        \n        c_denom = np.sum(w_fe)\n        c_val = c_denom - (np.sum(w_fe**2) / c_denom)\n\n        if c_val > 0:\n            tau2 = max(0, (q_stat - (k - 1)) / c_val)\n        else:\n            tau2 = 0\n\n        # Random-effects calculations\n        w_re = 1 / (v + tau2)\n        mu_re = np.sum(w_re * y) / np.sum(w_re)\n        v_mu_re = 1 / np.sum(w_re)\n        sigma_mu_re = np.sqrt(v_mu_re)\n        \n        all_results.append([mu_re, sigma_mu_re, gamma_gb_tg])\n\n    # Final print statement in the exact required format.\n    output_str = \",\".join(f\"[{v[0]:.1f},{v[1]:.1f},{v[2]:.1f}]\" for v in all_results)\n    print(f\"[{output_str}]\")\n\nsolve()\n```", "id": "3455409"}, {"introduction": "Atomistic simulations are powerful but are subject to systematic artifacts arising from their idealized setup, such as the use of periodic boundary conditions. This practice addresses the finite-size effect, where the simulation cell's finite dimension, $L$, introduces artificial elastic interactions that contaminate the computed grain boundary energy. By modeling the grain boundary as an elastic dipole layer, you will derive the leading-order correction and use it to extrapolate a series of finite-size calculations to the infinite-system limit, $L \\to \\infty$ [@problem_id:3455328]. Mastering this technique is essential for removing simulation artifacts and achieving high-fidelity predictions of defect energies.", "problem": "Consider a bicrystal with two identical planar grain boundaries simulated under Periodic Boundary Conditions (PBC). The bicrystal length normal to the grain boundary plane is denoted by $L$. In computational materials science, the finite-size effect in the computed grain boundary energy per unit area, denoted $\\gamma(L)$, arises from elastic image interactions between the two boundaries and their periodic replicas. The objective is to compute $\\gamma(L)$ for several values of $L$ and extrapolate to the infinite-size limit $L \\to \\infty$ to obtain $\\gamma(\\infty)$.\n\nUse a continuum, isotropic, linear elastic representation of the grain boundary. Model the boundary as a planar elastic dipole layer with an effective dipole density $p$ per unit area. Work in the plane-strain limit for a bicrystal slab, and let the material be characterized by Young’s modulus $E$ and Poisson’s ratio $\\nu$. Begin from the fundamentals of isotropic linear elasticity: Hooke’s law $\\sigma_{ij} = \\lambda \\delta_{ij} \\epsilon_{kk} + 2 \\mu \\epsilon_{ij}$, with Lamé parameters $\\lambda$ and $\\mu$, and the strain energy density $u = \\tfrac{1}{2} \\sigma_{ij} \\epsilon_{ij}$ (Einstein summation implied). In plane strain, define the effective modulus $E^\\star$ via $E^\\star = \\frac{E}{1-\\nu^2}$. Derive, from the elastic Green’s function framework for the interaction of two identical planar dipole layers separated by distance $L$ in an isotropic medium under PBC, the leading-order asymptotic dependence of the elastic image interaction correction $\\Delta \\gamma(L)$ to the grain boundary energy per area for large $L$. Combine this with an intrinsic (core) contribution $\\gamma_{\\mathrm{core}}$ to form $\\gamma(L) = \\gamma_{\\mathrm{core}} + \\Delta \\gamma(L)$, expressed in joules per square meter.\n\nImplement the derived leading-order correction and compute $\\gamma(L)$ for the specified test cases, then perform a regression-based extrapolation of $\\gamma(L)$ versus the appropriate predictor implied by your derived leading-order law to estimate $\\gamma(\\infty)$ as the intercept at the infinite-length limit. Clearly state and use consistent physical units. Treat $L$ in nanometers converted to meters, $E$ in gigapascals converted to pascals, $p$ in newtons per meter, and report energies in joules per square meter. Angles are not used in this problem. Express your final answers in joules per square meter, rounded to six decimal digits.\n\nUse the following test suite of three physically plausible scenarios, designed to probe general, edge, and sensitivity cases. For each case, compute $\\gamma(L)$ for all listed $L$ and perform the extrapolation to obtain a single $\\gamma(\\infty)$ value:\n\n- Case $1$: $E = 200$ gigapascals, $\\nu = 0.30$, $p = 50$ newtons per meter, $\\gamma_{\\mathrm{core}} = 0.7$ joules per square meter, $L \\in \\{10, 15, 30, 60\\}$ nanometers.\n- Case $2$: $E = 70$ gigapascals, $\\nu = 0.33$, $p = 40$ newtons per meter, $\\gamma_{\\mathrm{core}} = 0.5$ joules per square meter, $L \\in \\{5, 10, 20\\}$ nanometers.\n- Case $3$: $E = 120$ gigapascals, $\\nu = 0.25$, $p = 0$ newtons per meter, $\\gamma_{\\mathrm{core}} = 0.4$ joules per square meter, $L \\in \\{10, 20, 40\\}$ nanometers.\n\nYour program should produce a single line of output containing the three extrapolated $\\gamma(\\infty)$ values, as a comma-separated list enclosed in square brackets, each rounded to six decimal digits (for example, $[\\gamma_\\infty^{(1)},\\gamma_\\infty^{(2)},\\gamma_\\infty^{(3)}]$). No other text should be printed.", "solution": "The problem requires the derivation and application of a model for the finite-size effect on grain boundary energy in computational simulations, followed by a regression-based extrapolation to determine the energy in the infinite-system limit, $\\gamma(\\infty)$.\n\n### Step 1: Theoretical Derivation\n\nThe problem is approached within the framework of continuum isotropic linear elasticity. A grain boundary is modeled as a planar elastic dipole layer. In a simulation employing Periodic Boundary Conditions (PBC) along the direction normal to the boundary plane (let's call it the $z$-direction), a bicrystal of length $L$ contains two grain boundaries. The finite size of the simulation cell, $L$, leads to an artificial elastic interaction between a grain boundary and its periodic images. This interaction energy, $\\Delta \\gamma_{el}(L)$, contributes to the total computed grain boundary energy per unit area, $\\gamma(L)$.\n\nThe total energy is expressed as the sum of an intrinsic core energy, $\\gamma_{\\mathrm{core}}$, which is independent of system size, and the size-dependent elastic interaction energy:\n$$ \\gamma(L) = \\gamma_{\\mathrm{core}} + \\Delta \\gamma_{el}(L) $$\nOur goal is to derive the leading-order functional form of $\\Delta \\gamma_{el}(L)$ for large $L$.\n\nThe elastic interaction energy arises from the work done by the stress field of one boundary on the strain field of the other. In a periodic system, this involves summing the interactions over all periodic images. For large $L$, the dominant contribution comes from the nearest image boundary, which is located at a distance $L$. The problem can thus be reduced to finding the interaction energy between two identical parallel dipole layers separated by a distance $L$.\n\nThe derivation starts from the elastic Green's function, which gives the displacement field due to a point force in an elastic medium. By integrating the Green's function and its derivatives, one can find the stress and strain fields from any distribution of force densities. A grain boundary, being a region of severe lattice distortion, can be represented by a distribution of force dipoles. The problem specifies a planar dipole layer with an effective dipole density (moment per unit area) of magnitude $p$.\n\nThe interaction energy per unit area, $\\Delta\\gamma_{el}(L)$, between two such layers is found by calculating the work done to introduce the second layer into the stress field of the first. This involves integrating the product of the stress tensor of the first boundary with the strain tensor of the second boundary over the volume. Using Fourier-space methods, which are particularly well-suited for periodic systems, this interaction energy can be calculated.\n\nFor the specified case of plane-strain conditions in an isotropic material, the leading-order result for large separation $L$ is:\n$$ \\Delta \\gamma_{el}(L) = \\frac{p^2}{2 \\pi E^\\star L} $$\nHere, $p$ is the effective dipole density, and $E^\\star$ is the plane-strain elastic modulus, defined as:\n$$ E^\\star = \\frac{E}{1 - \\nu^2} $$\nwhere $E$ is Young's modulus and $\\nu$ is Poisson's ratio. This $1/L$ dependence is a well-established result for the elastic interaction of defects like grain boundaries and dislocations under PBC.\n\n### Step 2: Extrapolation Procedure\n\nCombining the derived terms, the total grain boundary energy as a function of system size $L$ is:\n$$ \\gamma(L) = \\gamma_{\\mathrm{core}} + \\frac{p^2}{2 \\pi E^\\star L} $$\nThe objective is to estimate $\\gamma(\\infty)$. From the equation, it is evident that as $L \\to \\infty$, the interaction term vanishes, and $\\gamma(L) \\to \\gamma_{\\mathrm{core}}$. Therefore, $\\gamma(\\infty) = \\gamma_{\\mathrm{core}}$.\n\nHowever, the problem instructs us to perform a regression-based extrapolation. This mimics a real-world scenario where one has a set of computed data points $(\\gamma(L_i))$ and seeks to find the infinite-size limit. The model equation shows a linear relationship between $\\gamma(L)$ and the predictor variable $x = 1/L$:\n$$ \\gamma(L) = \\gamma(\\infty) + C \\cdot \\frac{1}{L} $$\nwhere the constant $C = p^2 / (2 \\pi E^\\star)$ is the slope and $\\gamma(\\infty)$ is the intercept.\n\nThe specified procedure is thus:\n1.  For each test case and for each given length $L_i$, calculate the \"simulated\" grain boundary energy $\\gamma(L_i)$ using the formula derived above with the provided $\\gamma_{\\mathrm{core}}$.\n2.  Create a set of data pairs $(x_i, y_i)$, where $x_i = 1/L_i$ and $y_i = \\gamma(L_i)$.\n3.  Perform a linear regression on these data points to fit the model $y = mx + b$.\n4.  The determined intercept, $b$, is the extrapolated estimate for $\\gamma(\\infty)$.\n\nGiven that the data points are generated from a perfect linear model, the linear regression will produce an intercept that is, within numerical precision, identical to the $\\gamma_{\\mathrm{core}}$ value used to generate the data. For the special case where $p=0$, the interaction term is zero, $\\gamma(L)$ is constant for all $L$, and the regression will trivially return this constant value as the intercept.\n\n### Step 3: Computational Implementation\n\nThe algorithm for each test case is as follows:\n1.  Assign the input parameters: $E$, $\\nu$, $p$, $\\gamma_{\\mathrm{core}}$, and the list of lengths $\\{L_i\\}$.\n2.  Convert units to a consistent SI base: $E$ from GPa to Pa ($1 \\text{ GPa} = 10^9 \\text{ Pa}$) and $L$ from nm to m ($1 \\text{ nm} = 10^{-9} \\text{ m}$).\n3.  Calculate the plane-strain modulus: $E^\\star = E / (1 - \\nu^2)$.\n4.  Calculate the slope coefficient: $C = p^2 / (2 \\pi E^\\star)$.\n5.  Generate the predictor variables $x_i = 1/L_i$ and the response variables $y_i = \\gamma_{\\mathrm{core}} + C / L_i$.\n6.  Use a numerical linear regression tool (e.g., `numpy.polyfit`) to find the intercept of the best-fit line through the points $(x_i, y_i)$.\n7.  The resulting intercept is the value of $\\gamma(\\infty)$ for the case. The final result for each case is rounded to six decimal digits as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Note: scipy is listed as available but numpy.polyfit is sufficient for this task.\n# from scipy import stats\n\ndef solve():\n    \"\"\"\n    Solves the grain boundary energy extrapolation problem for the given test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a dictionary containing all necessary parameters.\n    test_cases = [\n        {\n            \"E_GPa\": 200, \"nu\": 0.30, \"p_Nm\": 50, \"gamma_core_Jm2\": 0.7,\n            \"L_nm\": [10, 15, 30, 60]\n        },\n        {\n            \"E_GPa\": 70, \"nu\": 0.33, \"p_Nm\": 40, \"gamma_core_Jm2\": 0.5,\n            \"L_nm\": [5, 10, 20]\n        },\n        {\n            \"E_GPa\": 120, \"nu\": 0.25, \"p_Nm\": 0, \"gamma_core_Jm2\": 0.4,\n            \"L_nm\": [10, 20, 40]\n        },\n    ]\n\n    extrapolated_gammas = []\n\n    for case in test_cases:\n        # Step 1: Extract parameters and convert to base SI units.\n        E = case[\"E_GPa\"] * 1e9  # GPa to Pa\n        nu = case[\"nu\"]\n        p = case[\"p_Nm\"]  # Already in N/m\n        gamma_core = case[\"gamma_core_Jm2\"]  # Already in J/m^2\n        L_values = np.array(case[\"L_nm\"]) * 1e-9  # nm to m\n\n        # Step 2: Calculate the plane-strain modulus E*\n        # E_star = E / (1 - nu^2)\n        E_star = E / (1 - nu**2)\n\n        # Step 3: Calculate the coefficient C for the 1/L term.\n        # This coefficient is the slope of the gamma vs. 1/L line.\n        # C = p^2 / (2 * pi * E_star)\n        # Handle the p=0 case to avoid division by zero if E_star were zero.\n        if E_star == 0:\n            C = 0.0\n        else:\n            C = p**2 / (2 * np.pi * E_star)\n\n        # Step 4: Generate the \"simulated\" data points (x, y) for regression.\n        # x is the predictor variable, 1/L.\n        # y is the response variable, gamma(L).\n        x_data = 1 / L_values\n        y_data = gamma_core + C / L_values\n\n        # Step 5: Perform a linear regression (polynomial fit of degree 1).\n        # np.polyfit returns coefficients [slope, intercept].\n        # We need the intercept, which corresponds to gamma(infinity).\n        # Since the data is generated from a perfect line, the regression will\n        # perfectly recover the intercept, which is gamma_core.\n        # The procedure is followed as per the problem statement.\n        if len(x_data)  2:\n            # A regression is not possible with fewer than 2 points.\n            # In this problem, all cases have at least 3 points.\n            # If a single point (L) were given, the only \"estimate\" would be gamma(L) itself.\n            # For a single point, intercept is just the y-value if slope is assumed 0.\n            # Here, we can just use the y-value.\n            gamma_infinity = y_data[0]\n        else:\n            slope, intercept = np.polyfit(x_data, y_data, 1)\n            gamma_infinity = intercept\n        \n        # Step 6: Store the result, rounded to six decimal places.\n        extrapolated_gammas.append(round(gamma_infinity, 6))\n\n    # Final print statement in the exact required format.\n    # The format is a list of comma-separated values in square brackets.\n    # The map(str, ...) converts each float to a string.\n    # The round() has already taken care of the precision. We need to ensure\n    # that trailing zeros are printed correctly for a fixed format.\n    formatted_results = [f\"{val:.6f}\" for val in extrapolated_gammas]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3455328"}, {"introduction": "Ultimately, the properties we compute at the atomic scale serve as inputs for higher-level models that predict macroscopic material behavior. This final practice demonstrates how to bridge these scales while rigorously accounting for uncertainty. You will first model the convergence errors in a DFT calculation of grain boundary energy, $\\gamma$, to produce a posterior probability distribution for its true value. This uncertainty is then propagated through the classic Mullins relation for curvature-driven grain boundary motion, $v = M \\gamma \\kappa$, to predict a full probability distribution for the boundary's velocity, $v$ [@problem_id:3455319]. This advanced exercise showcases a modern uncertainty quantification workflow, moving beyond single-value predictions to probabilistic forecasts of kinetic phenomena.", "problem": "You are given a computational materials science task that requires propagating uncertainties from Density Functional Theory (DFT) convergence parameters to a posterior distribution over grain boundary energy and then quantifying how this uncertainty affects predicted migration velocity distributions in mesoscale models. The goal is to derive and implement the calculation from first principles and produce numerical results for a specified test suite.\n\nConsider a grain boundary with energy per unit area denoted by $\\gamma$ (in $\\mathrm{J/m^2}$). In DFT calculations, finite $ k $-point sampling and finite plane-wave cutoff induce systematic convergence errors. Model DFT observations $ y_i $ of the grain boundary energy at $ k $-point resolution $ m_i $ (total number of $ k $-points used) and plane-wave cutoff $ c_i $ (in $\\mathrm{eV}$) by\n$$\ny_i = \\gamma + \\beta_k \\, m_i^{-p_k} + \\beta_c \\, c_i^{-p_c} + \\varepsilon_i,\n$$\nwhere $ \\beta_k $ and $ \\beta_c $ are unknown bias coefficients, $ p_k $ and $ p_c $ are known positive exponents reflecting convergence rates, and $ \\varepsilon_i $ are independent observation errors modeled as zero-mean Gaussian random variables with variance $\\sigma^2$.\n\nAdopt a Gaussian prior over the parameter vector $ \\theta = (\\gamma, \\beta_k, \\beta_c)^\\top $ given by $ \\theta \\sim \\mathcal{N}(\\mu_0, \\Sigma_0) $, where $ \\mu_0 \\in \\mathbb{R}^3 $ and $ \\Sigma_0 \\in \\mathbb{R}^{3 \\times 3} $ is symmetric positive definite.\n\nIn mesoscale curvature-driven grain boundary migration, the normal velocity $ v $ (in $ \\mathrm{m/s} $) obeys the Mullins relation\n$$\nv = M \\, \\gamma \\, \\kappa,\n$$\nwhere $ M $ is the grain boundary mobility (in $ \\mathrm{m^4/(J\\,s)} $) and $ \\kappa $ is the mean curvature (in $ \\mathrm{m^{-1}} $). Assume an Arrhenius form for the mobility,\n$$\nM(T) = M_0 \\exp\\!\\left(-\\frac{Q}{k_{\\mathrm{B}} T}\\right),\n$$\nwhere $ T $ is the absolute temperature (in $ \\mathrm{K} $), $ Q $ is the activation energy (in $ \\mathrm{eV} $), $ M_0 $ is a pre-exponential factor (in $ \\mathrm{m^4/(J\\,s)} $), and $ k_{\\mathrm{B}} $ is the Boltzmann constant (in $ \\mathrm{eV/K} $).\n\nYour task is as follows:\n- Use the specified DFT datasets and prior to compute the Gaussian posterior over $ \\theta $ and extract the marginal posterior distribution for $ \\gamma $.\n- Propagate the posterior uncertainty in $ \\gamma $ through the mesoscale velocity relation to obtain the induced distribution for $ v $ at given $ \\kappa $ and $ T $.\n- For each test case, compute three quantities: the mean of $ v $ (in $ \\mathrm{m/s} $), the standard deviation of $ v $ (in $ \\mathrm{m/s} $), and the probability that $ v $ exceeds a specified threshold $ v_{\\mathrm{th}} $ (dimensionless probability expressed as a decimal, not a percentage).\n- All answers involving physical quantities must be expressed in the units stated above.\n\nFundamental base to use:\n- Definition of grain boundary energy $ \\gamma $ as energy per unit area.\n- Convergence behavior of DFT observables with respect to $ k $-point sampling and plane-wave cutoff summarized by inverse power scalings in $ m_i $ and $ c_i $.\n- Gaussian prior and Gaussian likelihood leading to a Gaussian posterior for linear models.\n- Mullins relation $ v = M \\gamma \\kappa $ for curvature-driven migration, and the Arrhenius form for $ M(T) $.\n\nParameters common to all test cases:\n- Prior mean $ \\mu_0 = (1.0, 0.0, 0.0)^\\top $.\n- Prior covariance $ \\Sigma_0 = \\operatorname{diag}(0.2^2, 0.5^2, 0.5^2) $.\n- Convergence exponents $ p_k = 2 $ and $ p_c = 1 $.\n- Arrhenius parameters $ M_0 = 1.0 \\times 10^{-8} \\, \\mathrm{m^4/(J\\,s)} $, $ Q = 1.0 \\, \\mathrm{eV} $, and $ k_{\\mathrm{B}} = 8.617333262 \\times 10^{-5} \\, \\mathrm{eV/K} $.\n\nDFT datasets (each observation is a triple $ (m_i, c_i, y_i) $):\n- Dataset A (moderate convergence): six observations with\n  1. $ (4, 300, 1.0490) $\n  2. $ (4, 400, 1.028125) $\n  3. $ (9, 300, 1.03641975308642) $\n  4. $ (9, 500, 1.0030864197530864) $\n  5. $ (16, 400, 1.0134765625) $\n  6. $ (16, 600, 0.9926432291666667) $\n- Dataset B (near-converged): six observations with\n  1. $ (20, 800, 0.981875) $\n  2. $ (30, 1000, 0.9752777777777778) $\n  3. $ (40, 1200, 0.9709895833333334) $\n  4. $ (20, 1200, 0.9714583333333334) $\n  5. $ (30, 800, 0.9815277777777777) $\n  6. $ (40, 1000, 0.97515625) $\n\nTest suite:\n- Case $ 1 $: Use Dataset A with observation noise standard deviation $ \\sigma = 0.01 \\, \\mathrm{J/m^2} $, curvature $ \\kappa = 1.0 \\times 10^{4} \\, \\mathrm{m^{-1}} $, temperature $ T = 1200 \\, \\mathrm{K} $, and threshold $ v_{\\mathrm{th}} = 1.0 \\times 10^{-8} \\, \\mathrm{m/s} $.\n- Case $ 2 $: Use Dataset A with $ \\sigma = 0.01 \\, \\mathrm{J/m^2} $, curvature $ \\kappa = 0 \\, \\mathrm{m^{-1}} $ (boundary condition), $ T = 1200 \\, \\mathrm{K} $, and $ v_{\\mathrm{th}} = 1.0 \\times 10^{-8} \\, \\mathrm{m/s} $.\n- Case $ 3 $: Use Dataset B with $ \\sigma = 0.005 \\, \\mathrm{J/m^2} $, curvature $ \\kappa = 1.0 \\times 10^{4} \\, \\mathrm{m^{-1}} $, $ T = 1200 \\, \\mathrm{K} $, and $ v_{\\mathrm{th}} = 1.0 \\times 10^{-8} \\, \\mathrm{m/s} $.\n- Case $ 4 $: Use Dataset A with $ \\sigma = 0.01 \\, \\mathrm{J/m^2} $, curvature $ \\kappa = 1.0 \\times 10^{4} \\, \\mathrm{m^{-1}} $, low-temperature $ T = 800 \\, \\mathrm{K} $, and $ v_{\\mathrm{th}} = 1.0 \\times 10^{-10} \\, \\mathrm{m/s} $.\n\nComputation requirements:\n- Derive the Gaussian posterior for $ \\theta $ given the Gaussian prior and the linear observation model above. Extract the marginal posterior for $ \\gamma $ (a univariate Gaussian with some mean and variance).\n- Treat $ v $ as a linear transformation of $ \\gamma $ at fixed $ \\kappa $ and $ T $ and obtain the mean and standard deviation of $ v $ accordingly.\n- Compute the exceedance probability $ \\mathbb{P}(v > v_{\\mathrm{th}}) $ under the induced Gaussian distribution for $ v $.\n- Express $ v $ in $ \\mathrm{m/s} $ and probabilities as decimals.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for the four test cases as a comma-separated list of lists, where each inner list is $ [p, \\mu_v, \\sigma_v] $ with $ p = \\mathbb{P}(v > v_{\\mathrm{th}}) $ (decimal), $ \\mu_v $ the mean velocity (in $ \\mathrm{m/s} $), and $ \\sigma_v $ the standard deviation of velocity (in $ \\mathrm{m/s} $). For example, it should look like $ [[p_1,\\mu_1,\\sigma_1],[p_2,\\mu_2,\\sigma_2],[p_3,\\mu_3,\\sigma_3],[p_4,\\mu_4,\\sigma_4]] $.", "solution": "We begin by formalizing the DFT observation model and its Bayesian inference, followed by uncertainty propagation to mesoscale velocity predictions.\n\nThe observation model is linear in the parameters $ \\theta = (\\gamma, \\beta_k, \\beta_c)^\\top $. For each observation indexed by $ i $ with $ k $-point resolution $ m_i $ and plane-wave cutoff $ c_i $, the observation $ y_i $ satisfies\n$$\ny_i = \\gamma + \\beta_k m_i^{-p_k} + \\beta_c c_i^{-p_c} + \\varepsilon_i,\n$$\nwith $ \\varepsilon_i \\sim \\mathcal{N}(0, \\sigma^2) $ independently. Stack $ n $ observations into a vector $ y \\in \\mathbb{R}^n $ and define the design matrix $ X \\in \\mathbb{R}^{n \\times 3} $ by\n$$\nX = \\begin{bmatrix}\n1  m_1^{-p_k}  c_1^{-p_c} \\\\\n\\vdots  \\vdots  \\vdots \\\\\n1  m_n^{-p_k}  c_n^{-p_c}\n\\end{bmatrix}.\n$$\nThen the compact form is\n$$\ny = X \\theta + \\varepsilon, \\quad \\varepsilon \\sim \\mathcal{N}(0, \\sigma^2 I_n).\n$$\n\nThe prior is $ \\theta \\sim \\mathcal{N}(\\mu_0, \\Sigma_0) $. For a linear Gaussian model, the posterior $ p(\\theta \\mid y) $ is also Gaussian, given by\n$$\n\\Sigma_n = \\left( \\Sigma_0^{-1} + \\frac{1}{\\sigma^2} X^\\top X \\right)^{-1}, \\quad\n\\mu_n = \\Sigma_n \\left( \\Sigma_0^{-1} \\mu_0 + \\frac{1}{\\sigma^2} X^\\top y \\right),\n$$\nwhere $ \\Sigma_n \\in \\mathbb{R}^{3 \\times 3} $ is symmetric positive definite and $ \\mu_n \\in \\mathbb{R}^3 $. The marginal posterior for $ \\gamma $ is the first component of this multivariate Gaussian:\n$$\n\\gamma \\mid y \\sim \\mathcal{N}(\\mu_{\\gamma}, \\sigma_{\\gamma}^2), \\quad \\mu_{\\gamma} = [\\mu_n]_1, \\quad \\sigma_{\\gamma}^2 = [\\Sigma_n]_{11},\n$$\nwhere $ [\\cdot]_1 $ denotes the first component and $ [\\cdot]_{11} $ denotes the upper-left entry of the covariance matrix.\n\nTo connect to mesoscale dynamics, we use the Mullins relation $ v = M \\, \\gamma \\, \\kappa $ for curvature-driven grain boundary migration. The mobility obeys an Arrhenius law\n$$\nM(T) = M_0 \\exp\\!\\left(-\\frac{Q}{k_{\\mathrm{B}} T}\\right),\n$$\nwith $ M_0 $ in $ \\mathrm{m^4/(J\\,s)} $, $ Q $ in $ \\mathrm{eV} $, $ k_{\\mathrm{B}} $ in $ \\mathrm{eV/K} $, and $ T $ in $ \\mathrm{K} $. For any fixed curvature $ \\kappa $ and temperature $ T $, the mapping from $ \\gamma $ to $ v $ is linear:\n$$\nv = a \\, \\gamma, \\quad a = M(T) \\, \\kappa.\n$$\nA linear transformation of a Gaussian remains Gaussian. Hence,\n$$\nv \\mid y \\sim \\mathcal{N}\\big( \\mu_v, \\sigma_v^2 \\big), \\quad \\mu_v = a \\, \\mu_{\\gamma}, \\quad \\sigma_v^2 = a^2 \\, \\sigma_{\\gamma}^2.\n$$\nThis preserves physical units: $ \\gamma $ has units $ \\mathrm{J/m^2} $, $ \\kappa $ has units $ \\mathrm{m^{-1}} $, and $ M $ has units $ \\mathrm{m^4/(J\\,s)} $, so $ v $ has units $ \\mathrm{m/s} $.\n\nTo quantify uncertainty effects on predicted migration velocity distributions, we compute the exceedance probability for a specified threshold $ v_{\\mathrm{th}} $:\n$$\n\\mathbb{P}(v > v_{\\mathrm{th}}) = 1 - \\Phi\\!\\left( \\frac{v_{\\mathrm{th}} - \\mu_v}{\\sigma_v} \\right),\n$$\nwhere $ \\Phi $ is the cumulative distribution function of the standard normal. Using the complementary error function $ \\operatorname{erfc} $, we may write\n$$\n\\mathbb{P}(v > v_{\\mathrm{th}}) = \\frac{1}{2} \\operatorname{erfc}\\!\\left( \\frac{v_{\\mathrm{th}} - \\mu_v}{\\sqrt{2} \\, \\sigma_v} \\right),\n$$\nwith the convention that if $\\sigma_v = 0$ then the distribution collapses to a point mass and $\\mathbb{P}(v > v_{\\mathrm{th}})$ is either 0 or 1 depending on whether $ \\mu_v $ exceeds $ v_{\\mathrm{th}} $. The special boundary condition case $ \\kappa = 0 $ yields $ a = 0 $, so $ v \\equiv 0 $ deterministically, implying $\\mu_v = 0$, $\\sigma_v = 0$, and $\\mathbb{P}(v > v_{\\mathrm{th}}) = 0$ for any positive $v_{\\mathrm{th}}$.\n\nAlgorithmic steps for each test case:\n1. Assemble $ X $ from the specified $ (m_i, c_i) $ pairs using $ p_k = 2 $ and $ p_c = 1 $.\n2. Form $ y $ from the given $ y_i $ observations.\n3. Compute $ \\Sigma_0^{-1} $ and then $ \\Sigma_n $ and $ \\mu_n $ using the formulas above.\n4. Extract $ \\mu_{\\gamma} $ and $ \\sigma_{\\gamma}^2 $ from $ \\mu_n $ and $ \\Sigma_n $.\n5. Compute $ M(T) $ via the Arrhenius relation with the provided $ M_0 $, $ Q $, and $ k_{\\mathrm{B}} $.\n6. Compute $ a = M(T) \\kappa $, and then $ \\mu_v = a \\mu_{\\gamma} $ and $ \\sigma_v = |a| \\sqrt{\\sigma_{\\gamma}^2} $.\n7. Compute $ \\mathbb{P}(v > v_{\\mathrm{th}}) $ using the complementary error function expression. If $ \\sigma_v = 0 $, return $ 0 $ or $ 1 $ appropriately.\n8. Report $ [p, \\mu_v, \\sigma_v] $ for each case, with $ \\mu_v $ and $ \\sigma_v $ in $ \\mathrm{m/s} $ and $ p $ as a decimal.\n\nThe test suite covers:\n- A general case with moderate DFT uncertainty and physically plausible curvature and temperature.\n- A boundary condition case with zero curvature verifying deterministic zero velocity.\n- A near-converged DFT case showing a narrower posterior over $ \\gamma $ and correspondingly narrower $ v $ distribution.\n- A low-temperature case illustrating how reduced mobility strongly suppresses velocities and changes exceedance probabilities.\n\nThe program will compute these quantities and print a single line containing the list of results for all four cases in the format `[[p_1,mu_1,sigma_1],[p_2,mu_2,sigma_2],[p_3,mu_3,sigma_3],[p_4,mu_4,sigma_4]]`.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom math import erfc, sqrt, exp\n\ndef bayes_posterior_gamma(dataset, sigma_obs, mu0, Sigma0, p_k, p_c):\n    \"\"\"\n    Compute posterior mean and variance for gamma under Gaussian prior and linear-Gaussian model.\n    dataset: list of tuples (m_i, c_i, y_i)\n    sigma_obs: observation noise standard deviation\n    mu0: prior mean vector shape (3,)\n    Sigma0: prior covariance matrix shape (3,3)\n    p_k, p_c: positive exponents\n    Returns: (mu_gamma, var_gamma)\n    \"\"\"\n    # Build design matrix X and observation vector y\n    X_rows = []\n    y_vals = []\n    for (m_i, c_i, y_i) in dataset:\n        X_rows.append([1.0, m_i ** (-p_k), c_i ** (-p_c)])\n        y_vals.append(y_i)\n    X = np.array(X_rows, dtype=float)  # shape (n,3)\n    y = np.array(y_vals, dtype=float)  # shape (n,)\n    # Posterior covariance and mean\n    Sigma0_inv = np.linalg.inv(Sigma0)\n    XtX = X.T @ X\n    Sigma_n = np.linalg.inv(Sigma0_inv + XtX / (sigma_obs**2))\n    mu_n = Sigma_n @ (Sigma0_inv @ mu0 + (X.T @ y) / (sigma_obs**2))\n    mu_gamma = float(mu_n[0])\n    var_gamma = float(Sigma_n[0, 0])\n    return mu_gamma, var_gamma\n\ndef mobility_arrhenius(T, M0, Q_eV, kB_eV_per_K):\n    \"\"\"\n    Compute mobility M(T) = M0 * exp(-Q / (kB * T)).\n    All inputs in their specified units; output in m^4/(J s).\n    \"\"\"\n    return M0 * exp(-Q_eV / (kB_eV_per_K * T))\n\ndef gaussian_exceedance_prob(mu, sigma, threshold):\n    \"\"\"\n    Compute P(X > threshold) for X ~ N(mu, sigma^2).\n    Handles sigma == 0 as a degenerate case.\n    \"\"\"\n    if sigma = 0.0:\n        return float(1.0 if mu > threshold else 0.0)\n    z = (threshold - mu) / (sqrt(2.0) * sigma)\n    return 0.5 * erfc(z)\n\ndef solve():\n    # Prior parameters\n    mu0 = np.array([1.0, 0.0, 0.0], dtype=float)\n    Sigma0 = np.diag([0.2**2, 0.5**2, 0.5**2])\n\n    # Convergence exponents\n    p_k = 2\n    p_c = 1\n\n    # Arrhenius parameters\n    M0 = 1.0e-8  # m^4/(J s)\n    Q = 1.0      # eV\n    kB = 8.617333262e-5  # eV/K\n\n    # Datasets\n    dataset_A = [\n        (4, 300, 1.0490),\n        (4, 400, 1.028125),\n        (9, 300, 1.03641975308642),\n        (9, 500, 1.0030864197530864),\n        (16, 400, 1.0134765625),\n        (16, 600, 0.9926432291666667),\n    ]\n    dataset_B = [\n        (20, 800, 0.981875),\n        (30, 1000, 0.9752777777777778),\n        (40, 1200, 0.9709895833333334),\n        (20, 1200, 0.9714583333333334),\n        (30, 800, 0.9815277777777777),\n        (40, 1000, 0.97515625),\n    ]\n\n    # Test cases: (dataset_id, sigma_obs, kappa, T, v_th)\n    test_cases = [\n        (\"A\", 0.01, 1.0e4, 1200.0, 1.0e-8),    # Case 1\n        (\"A\", 0.01, 0.0,    1200.0, 1.0e-8),    # Case 2\n        (\"B\", 0.005, 1.0e4, 1200.0, 1.0e-8),    # Case 3\n        (\"A\", 0.01, 1.0e4,  800.0,  1.0e-10),   # Case 4\n    ]\n\n    results = []\n    for ds_id, sigma_obs, kappa, T, v_th in test_cases:\n        dataset = dataset_A if ds_id == \"A\" else dataset_B\n        mu_gamma, var_gamma = bayes_posterior_gamma(dataset, sigma_obs, mu0, Sigma0, p_k, p_c)\n        M_T = mobility_arrhenius(T, M0, Q, kB)\n        a = M_T * kappa\n        mu_v = a * mu_gamma\n        sigma_v = abs(a) * sqrt(var_gamma)\n        p_exceed = gaussian_exceedance_prob(mu_v, sigma_v, v_th)\n        results.append([p_exceed, mu_v, sigma_v])\n\n    # Final print statement in the exact required format.\n    # Convert inner lists to string without extra spaces for consistency.\n    def list_to_str(lst):\n        return \"[\" + \",\".join(f\"{x}\" for x in lst) + \"]\"\n    print(\"[\" + \",\".join(list_to_str(r) for r in results) + \"]\")\n\nsolve()\n```", "id": "3455319"}]}