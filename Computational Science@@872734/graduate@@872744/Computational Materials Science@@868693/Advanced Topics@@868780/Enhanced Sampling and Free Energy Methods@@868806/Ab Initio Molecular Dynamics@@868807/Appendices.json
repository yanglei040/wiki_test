{"hands_on_practices": [{"introduction": "The foundation of any reliable *ab initio* molecular dynamics simulation is the ability to compute accurate forces on the atoms. In plane-wave based methods, the primary parameter controlling the trade-off between accuracy and computational cost is the kinetic energy cutoff, $E_{\\mathrm{cut}}$, which determines the size of the basis set. This exercise guides you through a practical, data-driven workflow to determine an appropriate $E_{\\mathrm{cut}}$ for a desired force accuracy and subsequently estimate the computational cost of the simulation, a critical planning step for any study [@problem_id:3431500].", "problem": "You are tasked with designing a program that, in the context of Born-Oppenheimer Molecular Dynamics (BOMD), determines the minimum plane-wave kinetic energy cutoff $E_{\\mathrm{cut}}$ required to achieve a specified force convergence target and estimates computational cost scaling with system size. In BOMD, the ionic forces are obtained by solving the electronic ground state at each time step. Plane-wave basis sets are truncated by a kinetic energy cutoff $E_{\\mathrm{cut}}$; the discretization error in the forces decreases with increasing $E_{\\mathrm{cut}}$. Your program must use a simple, physically motivated model to predict the required $E_{\\mathrm{cut}}$, then use a cost model to estimate total floating-point operations (FLOPs) for several system sizes.\n\nAssume the following foundations:\n- Born-Oppenheimer Molecular Dynamics (BOMD): at each time step, the electronic ground state is solved self-consistently and forces are computed from the ground-state electron density.\n- For a plane-wave basis, the number of plane waves scales as $N_{\\mathrm{pw}} \\propto E_{\\mathrm{cut}}^{3/2}$ for fixed cell volume per atom.\n- The force discretization error for silicon with a given pseudopotential can be modeled as a power law, $\\epsilon(E_{\\mathrm{cut}}) = A\\,E_{\\mathrm{cut}}^{-\\beta}$, where $A$ and $\\beta$ are positive, material- and pseudopotential-dependent constants to be determined by fitting to measured data.\n\nProcedure to implement:\n1. Given measured pairs $\\{(E_{\\mathrm{cut},i}, \\epsilon_i)\\}$, fit the model $\\epsilon(E_{\\mathrm{cut}}) = A\\,E_{\\mathrm{cut}}^{-\\beta}$ by performing a least-squares regression in logarithmic space. Specifically, fit $y = \\ln \\epsilon$ versus $x = \\ln E_{\\mathrm{cut}}$ to obtain $y = \\ln A - \\beta x$, and recover $A = e^{\\ln A}$ and $\\beta = -(\\text{slope})$.\n2. For a target force tolerance $\\epsilon_{\\mathrm{target}}$, compute the predicted minimum cutoff\n$$\nE_{\\mathrm{cut,min}} = \\left(\\frac{A}{\\epsilon_{\\mathrm{target}}}\\right)^{1/\\beta}.\n$$\n3. To avoid extrapolation outside the measured range, clip the predicted $E_{\\mathrm{cut,min}}$ to the closed interval $[E_{\\min}, E_{\\max}]$ where $E_{\\min} = \\min_i E_{\\mathrm{cut},i}$ and $E_{\\max} = \\max_i E_{\\mathrm{cut},i}$. Define a boolean $b$ that is $\\mathrm{True}$ if the predicted error at the clipped $E_{\\mathrm{cut,min}}$ satisfies $\\epsilon(E_{\\mathrm{cut,min}}) \\le \\epsilon_{\\mathrm{target}}$, and $\\mathrm{False}$ otherwise.\n4. Estimate the total computational cost over $M$ time steps using the following model:\n   - Number of plane waves:\n   $$\n   N_{\\mathrm{pw}}(E_{\\mathrm{cut}}, N) = K\\,N\\,E_{\\mathrm{cut}}^{3/2},\n   $$\n   where $N$ is the number of atoms and $K$ is determined from a baseline reference.\n   - Number of occupied Kohn-Sham states for silicon (with spin degeneracy and $4$ valence electrons per atom):\n   $$\n   N_{\\mathrm{states}}(N) = 2 N.\n   $$\n   - Per-step cost in floating-point operations (FLOPs), assuming a mixture of Fast Fourier Transform (FFT) and linear algebra operations:\n   $$\n   C_{\\mathrm{step}}(E_{\\mathrm{cut}}, N) = c_{\\mathrm{fft}}\\,N_{\\mathrm{pw}}\\,\\ln N_{\\mathrm{pw}} + c_{\\mathrm{ops}}\\,N_{\\mathrm{states}}\\,N_{\\mathrm{pw}}.\n   $$\n   - Total cost over $M$ steps:\n   $$\n   C_{\\mathrm{total}}(E_{\\mathrm{cut}}, N, M) = M \\times C_{\\mathrm{step}}(E_{\\mathrm{cut}}, N).\n   $$\n   Use the following baseline calibration constants:\n   - $E_0 = 400\\,\\mathrm{eV}$, $N_0 = 8$, $N_{\\mathrm{pw},0} = 20000$, so that\n   $$\n   K = \\frac{N_{\\mathrm{pw},0}}{N_0\\,E_0^{3/2}}.\n   $$\n   - $c_{\\mathrm{fft}} = 5\\times 10^{2}$, $c_{\\mathrm{ops}} = 1\\times 10^{2}$.\n   Report $C_{\\mathrm{total}}$ in FLOPs, rounded to the nearest integer.\n\nImplement the above for the following test suite. In all cases, energies must be expressed in $\\mathrm{eV}$ and force errors in $\\mathrm{eV/\\AA}$:\n- Test Case $1$ (norm-conserving pseudopotential, silicon):\n  - Measured data: $E_{\\mathrm{cut}} = [200,\\,300,\\,400,\\,600]\\,\\mathrm{eV}$, $\\epsilon = [5.0\\times 10^{-3},\\,2.5\\times 10^{-3},\\,1.6\\times 10^{-3},\\,0.9\\times 10^{-3}]\\,\\mathrm{eV/\\AA}$.\n  - Target: $\\epsilon_{\\mathrm{target}} = 1.0\\times 10^{-3}\\,\\mathrm{eV/\\AA}$.\n  - Sizes and steps: $N = [8,\\,64,\\,512]$, $M = 100$.\n- Test Case $2$ (projector augmented-wave-like behavior, silicon):\n  - Measured data: $E_{\\mathrm{cut}} = [150,\\,250,\\,350,\\,450]\\,\\mathrm{eV}$, $\\epsilon = [3.0\\times 10^{-3},\\,1.5\\times 10^{-3},\\,1.0\\times 10^{-3},\\,0.7\\times 10^{-3}]\\,\\mathrm{eV/\\AA}$.\n  - Target: $\\epsilon_{\\mathrm{target}} = 1.0\\times 10^{-3}\\,\\mathrm{eV/\\AA}$.\n  - Sizes and steps: $N = [8,\\,216]$, $M = 50$.\n- Test Case $3$ (boundary case, silicon):\n  - Measured data: $E_{\\mathrm{cut}} = [300,\\,400,\\,500]\\,\\mathrm{eV}$, $\\epsilon = [2.2\\times 10^{-3},\\,1.6\\times 10^{-3},\\,1.3\\times 10^{-3}]\\,\\mathrm{eV/\\AA}$.\n  - Target: $\\epsilon_{\\mathrm{target}} = 2.0\\times 10^{-3}\\,\\mathrm{eV/\\AA}$.\n  - Sizes and steps: $N = [8]$, $M = 10$.\n\nYour program must perform, for each test case, the following outputs in order:\n- The clipped $E_{\\mathrm{cut,min}}$ in $\\mathrm{eV}$ as a floating-point number.\n- The boolean $b$ indicating whether the target is satisfied at the clipped $E_{\\mathrm{cut,min}}$.\n- The total costs $C_{\\mathrm{total}}$ for each specified $N$ as integers, in the order the sizes are listed.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For example, for three test cases, the output should be of the form $[\\text{E1},\\text{b1},\\text{C1}_1,\\dots,\\text{E2},\\text{b2},\\text{C2}_1,\\dots,\\text{E3},\\text{b3},\\text{C3}_1,\\dots]$, where $\\text{E}$ are floating-point numbers in $\\mathrm{eV}$, $\\text{b}$ are boolean values, and $\\text{C}$ are integers in FLOPs.", "solution": "The problem requires the design of a computational procedure to determine an adequate plane-wave kinetic energy cutoff ($E_{\\mathrm{cut}}$) for a Born-Oppenheimer Molecular Dynamics (BOMD) simulation and to estimate the resulting computational cost. This task is a standard component of computational resource planning in materials simulations. The solution proceeds in three stages: first, fitting an empirical model for force convergence; second, using the model to predict the required $E_{\\mathrm{cut}}$ and validating it; and third, applying a scaling model to estimate the total computational cost in floating-point operations (FLOPs).\n\n### 1. Force Error Model and Parameter Fitting\n\nIn plane-wave based electronic structure calculations, the basis set is truncated by including only plane waves with a kinetic energy below a specified cutoff, $E_{\\mathrm{cut}}$. This introduces a discretization error that systematically decreases as $E_{\\mathrm{cut}}$ increases. For the forces on the ions, this convergence behavior can be effectively modeled by a power law:\n$$\n\\epsilon(E_{\\mathrm{cut}}) = A\\,E_{\\mathrm{cut}}^{-\\beta}\n$$\nHere, $\\epsilon$ represents the error in the forces (e.g., the root-mean-square difference from the converged value), while $A$ and $\\beta$ are positive constants that depend on the element (silicon in this case) and the specifics of the pseudopotential used.\n\nTo determine the parameters $A$ and $\\beta$ from a set of measured data points $\\{(E_{\\mathrm{cut},i}, \\epsilon_i)\\}$, we linearize the model by taking the natural logarithm of both sides:\n$$\n\\ln(\\epsilon) = \\ln(A\\,E_{\\mathrm{cut}}^{-\\beta}) = \\ln(A) + \\ln(E_{\\mathrm{cut}}^{-\\beta}) = \\ln(A) - \\beta \\ln(E_{\\mathrm{cut}})\n$$\nThis equation has the form of a straight line, $y = c + mx$, where $y = \\ln(\\epsilon)$, $x = \\ln(E_{\\mathrm{cut}})$, the intercept is $c = \\ln(A)$, and the slope is $m = -\\beta$. We can therefore perform a linear least-squares regression on the log-transformed data $(\\ln E_{\\mathrm{cut},i}, \\ln \\epsilon_i)$ to find the best-fit values for the slope and intercept. The model parameters are then recovered as $\\beta = -m$ and $A = e^c$.\n\n### 2. Determination and Validation of Energy Cutoff\n\nOnce the error model is parameterized, it can be used to predict the minimum energy cutoff required to achieve a desired force tolerance, $\\epsilon_{\\mathrm{target}}$. By rearranging the model equation, we solve for $E_{\\mathrm{cut}}$:\n$$\nE_{\\mathrm{cut,min}} = \\left(\\frac{A}{\\epsilon_{\\mathrm{target}}}\\right)^{1/\\beta}\n$$\nA critical aspect of using empirical models is avoiding extrapolation far beyond the domain of the data used for fitting. Therefore, the predicted cutoff, $E_{\\mathrm{cut,pred}}$, is clipped to the range of the measured cutoffs, $[E_{\\min}, E_{\\max}]$, where $E_{\\min} = \\min_i(E_{\\mathrm{cut},i})$ and $E_{\\max} = \\max_i(E_{\\mathrm{cut},i})$. The final, operational cutoff is thus $E_{\\mathrm{cut,min}} = \\mathrm{clip}(E_{\\mathrm{cut,pred}}, E_{\\min}, E_{\\max})$.\n\nThis clipping necessitates a verification step. It is possible that the target tolerance $\\epsilon_{\\mathrm{target}}$ is too stringent and cannot be achieved even at the highest measured cutoff, $E_{\\max}$. In this scenario, the clipped cutoff would be $E_{\\max}$, but the error at this cutoff, $\\epsilon(E_{\\max})$, would still be greater than $\\epsilon_{\\mathrm{target}}$. We must therefore compute the error at the clipped cutoff, $\\epsilon(E_{\\mathrm{cut,min}})$, and explicitly check if it satisfies the condition $\\epsilon(E_{\\mathrm{cut,min}}) \\le \\epsilon_{\\mathrm{target}}$. The outcome of this check is stored in a boolean variable, $b$.\n\n### 3. Computational Cost Estimation\n\nThe total computational cost of a BOMD simulation is estimated based on the cost per time step and the total number of steps. The per-step cost is a function of the system size (number of atoms, $N$) and the basis set size (number of plane waves, $N_{\\mathrm{pw}}$).\n\nThe number of plane waves, $N_{\\mathrm{pw}}$, scales with the volume of the sphere in reciprocal space defined by $E_{\\mathrm{cut}}$, and also with the number of atoms, $N$, for a fixed-density system. This is modeled as:\n$$\nN_{\\mathrm{pw}}(E_{\\mathrm{cut}}, N) = K\\,N\\,E_{\\mathrm{cut}}^{3/2}\n$$\nThe proportionality constant $K$ is calibrated from a single reference calculation with known $N_0$, $E_0$, and $N_{\\mathrm{pw},0}$, yielding $K = N_{\\mathrm{pw},0} / (N_0\\,E_0^{3/2})$.\n\nFor silicon, which has $4$ valence electrons per atom, the number of occupied Kohn-Sham states (or bands) is half the number of valence electrons, assuming spin-degeneracy. Thus, $N_{\\mathrm{states}}(N) = 4N/2 = 2N$.\n\nThe computational cost per time step, $C_{\\mathrm{step}}$, is modeled as a sum of two dominant contributions:\n$$\nC_{\\mathrm{step}}(E_{\\mathrm{cut}}, N) = c_{\\mathrm{fft}}\\,N_{\\mathrm{pw}}\\,\\ln N_{\\mathrm{pw}} + c_{\\mathrm{ops}}\\,N_{\\mathrm{states}}\\,N_{\\mathrm{pw}}\n$$\nThe first term, scaling as $O(N_{\\mathrm{pw}} \\log N_{\\mathrm{pw}})$, represents the cost of Fast Fourier Transforms (FFTs) used to switch between real and reciprocal space representations of wavefunctions and densities. The second term, scaling as $O(N_{\\mathrm{states}} N_{\\mathrm{pw}})$, represents the cost of linear algebra operations such as the orthogonalization of the electronic wavefunctions. The coefficients $c_{\\mathrm{fft}}$ and $c_{\\mathrm{ops}}$ are empirically determined constants.\n\nThe total cost over a simulation of $M$ steps for a system of $N$ atoms using the determined cutoff $E_{\\mathrm{cut,min}}$ is then:\n$$\nC_{\\mathrm{total}} = M \\times C_{\\mathrm{step}}(E_{\\mathrm{cut,min}}, N)\n$$\nThis value is reported as the nearest integer. This entire procedure is applied to each test case provided.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print the final output.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"E_cut_data\": [200., 300., 400., 600.],\n            \"epsilon_data\": [5.0e-3, 2.5e-3, 1.6e-3, 0.9e-3],\n            \"epsilon_target\": 1.0e-3,\n            \"N_values\": [8, 64, 512],\n            \"M\": 100\n        },\n        {\n            \"E_cut_data\": [150., 250., 350., 450.],\n            \"epsilon_data\": [3.0e-3, 1.5e-3, 1.0e-3, 0.7e-3],\n            \"epsilon_target\": 1.0e-3,\n            \"N_values\": [8, 216],\n            \"M\": 50\n        },\n        {\n            \"E_cut_data\": [300., 400., 500.],\n            \"epsilon_data\": [2.2e-3, 1.6e-3, 1.3e-3],\n            \"epsilon_target\": 2.0e-3,\n            \"N_values\": [8],\n            \"M\": 10\n        }\n    ]\n\n    # Baseline calibration constants\n    E0 = 400.0\n    N0 = 8\n    N_pw0 = 20000\n    \n    # Cost model coefficients\n    c_fft = 5e2\n    c_ops = 1e2\n\n    # Calculate the plane-wave scaling constant K\n    K = N_pw0 / (N0 * E0**(1.5))\n\n    results = []\n\n    for case in test_cases:\n        # Step 1: Fit the error model epsilon = A * E_cut^(-beta)\n        # We fit ln(epsilon) = ln(A) - beta * ln(E_cut)\n        log_E = np.log(case[\"E_cut_data\"])\n        log_eps = np.log(case[\"epsilon_data\"])\n        \n        # polyfit(x, y, 1) returns [slope, intercept] for y = slope*x + intercept\n        slope, intercept = np.polyfit(log_E, log_eps, 1)\n        \n        beta = -slope\n        A = np.exp(intercept)\n\n        # Step 2: For a target, compute the predicted minimum cutoff\n        E_cut_pred = (A / case[\"epsilon_target\"])**(1.0 / beta)\n        \n        # Step 3: Clip the predicted E_cut_min and validate\n        E_min_data = min(case[\"E_cut_data\"])\n        E_max_data = max(case[\"E_cut_data\"])\n        E_cut_clipped = np.clip(E_cut_pred, E_min_data, E_max_data)\n        \n        # Calculate the error at the clipped cutoff to validate\n        epsilon_at_clipped = A * E_cut_clipped**(-beta)\n        b = epsilon_at_clipped = case[\"epsilon_target\"]\n        \n        results.append(E_cut_clipped)\n        results.append(b)\n\n        # Step 4: Estimate the total computational cost\n        M = case[\"M\"]\n        for N in case[\"N_values\"]:\n            # Number of plane waves, using the clipped E_cut\n            N_pw = K * N * E_cut_clipped**(1.5)\n            \n            # Number of occupied Kohn-Sham states for silicon\n            N_states = 2 * N\n            \n            # Per-step cost in FLOPs\n            C_step = c_fft * N_pw * np.log(N_pw) + c_ops * N_states * N_pw\n            \n            # Total cost over M steps\n            C_total = M * C_step\n            \n            # Append the cost, rounded to the nearest integer\n            results.append(round(C_total))\n\n    # Final print statement in the exact required format.\n    # Convert booleans to their string representation \"True\" or \"False\"\n    # Convert numbers to their standard string representation\n    str_results = [str(r) for r in results]\n    print(f\"[{','.join(str_results)}]\")\n\nsolve()\n```", "id": "3431500"}, {"introduction": "Once accurate forces can be computed, the next step in performing a molecular dynamics simulation is to integrate Newton's equations of motion. This involves choosing a discrete time step, $\\Delta t$, that must be small enough to accurately describe the fastest atomic motions, typically high-frequency bond vibrations. This practice delves into the stability and accuracy of the velocity Verlet algorithm, a workhorse for molecular simulation, to derive a rigorous upper bound on $\\Delta t$ based on the system's highest vibrational frequency [@problem_id:3393482].", "problem": "In Born–Oppenheimer molecular dynamics (BOMD), the nuclei evolve on the instantaneous ground-state electronic potential energy surface and are integrated with a symplectic second-order scheme such as the velocity Verlet algorithm. Near a local minimum, each nuclear normal mode is well approximated as an independent harmonic oscillator of angular frequency $\\omega$. For numerical stability and accuracy, the time step $\\Delta t$ must be chosen with respect to the highest normal-mode angular frequency $\\omega_{\\max}$.\n\nAssume the following:\n- The nuclei are integrated with velocity Verlet.\n- The highest angular frequency is $\\omega_{\\max} = 7.5 \\times 10^{14}\\ \\mathrm{s}^{-1}$.\n- You define the “relative integration error” for the stiffest mode as the relative error in the angular frequency induced by time discretization, that is, $|\\tilde{\\omega} - \\omega|/\\omega$, where $\\tilde{\\omega}$ is the numerical angular frequency produced by the integrator for a harmonic oscillator.\n- You require that, for the stiffest mode, the relative integration error satisfy $|\\tilde{\\omega} - \\omega|/\\omega \\le \\varepsilon$ with $\\varepsilon = 2.0 \\times 10^{-3}$.\n\nStarting from Newton’s second law for a harmonic oscillator and the position–velocity form of the velocity Verlet scheme, derive a bound on $\\Delta t$ that simultaneously ensures linear stability of the scheme and enforces the above relative integration error requirement for the mode with frequency $\\omega_{\\max}$. Then, taking the more restrictive bound, choose a single time step.\n\nRound your final time step to $3$ significant figures. Express the final time step in femtoseconds (fs).", "solution": "We begin from Newton’s second law applied to a single harmonic normal mode,\n$$\nm \\ddot{q}(t) = - m \\omega^{2} q(t),\n$$\nwhich can be written as\n$$\n\\ddot{q}(t) + \\omega^{2} q(t) = 0.\n$$\nThe velocity Verlet algorithm advances the position $q$ and velocity $v$ via\n$$\nq_{n+1} = q_{n} + \\Delta t\\, v_{n} + \\tfrac{1}{2} \\Delta t^{2} a_{n}, \\quad a_{n} = -\\omega^{2} q_{n},\n$$\n$$\nv_{n+1} = v_{n} + \\tfrac{1}{2} \\Delta t \\left(a_{n} + a_{n+1}\\right).\n$$\nEliminating velocities yields a position-only recurrence. Using $a_{n} = -\\omega^{2} q_{n}$ and the same for $n+1$, subtract the update for $q_{n}$ from that for $q_{n+1}$ shifted by one step to obtain\n$$\nq_{n+1} - 2 q_{n} + q_{n-1} = - \\omega^{2} \\Delta t^{2} q_{n}.\n$$\nSeeking harmonic solutions $q_{n} = A \\exp(i n \\theta)$ gives the dispersion relation\n$$\n\\exp(i\\theta) - 2 + \\exp(-i\\theta) + \\omega^{2} \\Delta t^{2} = 0 \\;\\;\\Longrightarrow\\;\\; 2(\\cos \\theta - 1) + \\omega^{2} \\Delta t^{2} = 0,\n$$\nor\n$$\n\\cos \\theta = 1 - \\tfrac{1}{2} \\omega^{2} \\Delta t^{2}.\n$$\nIdentifying $\\theta = \\tilde{\\omega} \\Delta t$ defines the numerical angular frequency $\\tilde{\\omega}$ through\n$$\n\\cos(\\tilde{\\omega} \\Delta t) = 1 - \\tfrac{1}{2} \\omega^{2} \\Delta t^{2}.\n$$\nFor small $\\Delta t$, expand $\\cos(\\tilde{\\omega} \\Delta t)$ and solve perturbatively. Write $\\tilde{\\omega} \\Delta t = \\theta$ and expand $\\cos \\theta = 1 - \\theta^{2}/2 + \\theta^{4}/24 + \\mathcal{O}(\\theta^{6})$. Equating to $1 - \\tfrac{1}{2} \\omega^{2} \\Delta t^{2}$ yields\n$$\n1 - \\frac{\\theta^{2}}{2} + \\frac{\\theta^{4}}{24} + \\cdots = 1 - \\frac{\\omega^{2} \\Delta t^{2}}{2}.\n$$\nCanceling $1$ and multiplying by $-2$,\n$$\n\\theta^{2} - \\frac{\\theta^{4}}{12} + \\cdots = \\omega^{2} \\Delta t^{2}.\n$$\nSolving for $\\theta$ to leading nontrivial order via a perturbation ansatz $\\theta = \\omega \\Delta t \\left(1 + c\\, \\omega^{2} \\Delta t^{2} + \\cdots \\right)$ gives\n$$\n\\theta^{2} = \\omega^{2} \\Delta t^{2} \\left(1 + 2 c\\, \\omega^{2} \\Delta t^{2} + \\cdots \\right), \\quad\n\\theta^{4} = \\omega^{4} \\Delta t^{4} \\left(1 + \\cdots \\right).\n$$\nSubstituting into the previous relation,\n$$\n\\omega^{2} \\Delta t^{2} \\left(1 + 2 c\\, \\omega^{2} \\Delta t^{2}\\right) - \\frac{1}{12} \\omega^{4} \\Delta t^{4} = \\omega^{2} \\Delta t^{2} + \\mathcal{O}(\\Delta t^{6}),\n$$\nwhich implies\n$$\n2 c\\, \\omega^{4} \\Delta t^{4} - \\frac{1}{12} \\omega^{4} \\Delta t^{4} = 0 \\;\\;\\Longrightarrow\\;\\; c = \\frac{1}{24}.\n$$\nHence\n$$\n\\tilde{\\omega} \\Delta t = \\theta = \\omega \\Delta t \\left(1 + \\frac{(\\omega \\Delta t)^{2}}{24} + \\mathcal{O}(\\Delta t^{4}) \\right),\n$$\nor, dividing by $\\Delta t$,\n$$\n\\tilde{\\omega} = \\omega \\left(1 + \\frac{(\\omega \\Delta t)^{2}}{24} + \\mathcal{O}(\\Delta t^{4}) \\right).\n$$\nTherefore, the relative integration error in angular frequency is, to leading order,\n$$\n\\frac{|\\tilde{\\omega} - \\omega|}{\\omega} \\approx \\frac{(\\omega \\Delta t)^{2}}{24}.\n$$\nImposing the requirement for the stiffest mode with $\\omega = \\omega_{\\max}$,\n$$\n\\frac{(\\omega_{\\max} \\Delta t)^{2}}{24} \\le \\varepsilon \\;\\;\\Longrightarrow\\;\\; \\Delta t \\le \\frac{\\sqrt{24\\, \\varepsilon}}{\\omega_{\\max}}.\n$$\nIn addition to accuracy, linear stability requires that the amplification factor remain bounded. From $\\cos(\\tilde{\\omega} \\Delta t) = 1 - \\tfrac{1}{2} \\omega^{2} \\Delta t^{2}$, a necessary and sufficient condition for real $\\tilde{\\omega}$ (and thus non-growing oscillations) is $|1 - \\tfrac{1}{2} \\omega^{2} \\Delta t^{2}| \\le 1$, which yields\n$$\n0 \\le \\omega^{2} \\Delta t^{2} \\le 4 \\;\\;\\Longrightarrow\\;\\; \\Delta t \\le \\frac{2}{\\omega}.\n$$\nApplying this to the stiffest mode gives the stability bound $\\Delta t \\le 2 / \\omega_{\\max}$.\n\nThe admissible time step is thus\n$$\n\\Delta t \\le \\min\\!\\left(\\frac{\\sqrt{24\\, \\varepsilon}}{\\omega_{\\max}},\\ \\frac{2}{\\omega_{\\max}}\\right).\n$$\nNumerically, with $\\omega_{\\max} = 7.5 \\times 10^{14}\\ \\mathrm{s}^{-1}$ and $\\varepsilon = 2.0 \\times 10^{-3}$,\n$$\n\\sqrt{24\\, \\varepsilon} = \\sqrt{24 \\times 2.0 \\times 10^{-3}} = \\sqrt{4.8 \\times 10^{-2}} \\approx 2.19089 \\times 10^{-1},\n$$\nso the accuracy-limited step is\n$$\n\\Delta t_{\\mathrm{acc}} = \\frac{2.19089 \\times 10^{-1}}{7.5 \\times 10^{14}}\\ \\mathrm{s} \\approx 2.92119 \\times 10^{-16}\\ \\mathrm{s}.\n$$\nThe stability-limited step is\n$$\n\\Delta t_{\\mathrm{stab}} = \\frac{2}{7.5 \\times 10^{14}}\\ \\mathrm{s} \\approx 2.66667 \\times 10^{-15}\\ \\mathrm{s}.\n$$\nThe more restrictive constraint is the accuracy requirement, so the chosen time step is $\\Delta t \\approx 2.92119 \\times 10^{-16}\\ \\mathrm{s}$.\n\nConverting to femtoseconds using $1\\ \\mathrm{fs} = 10^{-15}\\ \\mathrm{s}$,\n$$\n\\Delta t \\approx 0.292119\\ \\mathrm{fs}.\n$$\nRounded to $3$ significant figures,\n$$\n\\Delta t \\approx 0.292\\ \\mathrm{fs}.\n$$", "answer": "$$\\boxed{0.292}$$", "id": "3393482"}, {"introduction": "A key hallmark of a correctly performed microcanonical (NVE) ensemble simulation is the conservation of total energy. In practice, perfect energy conservation in Born-Oppenheimer molecular dynamics is prevented by two main sources of error: the finite time step of the integrator and the incomplete convergence of the electronic ground state at each step. This advanced exercise introduces the powerful concept of a \"shadow Hamiltonian\" and a model for force noise to dissect and quantify these two contributions to energy drift, providing deep insight into diagnosing the quality and reliability of a simulation [@problem_id:3431499].", "problem": "You are tasked with writing a complete, runnable program that estimates the energy drift per picosecond in a microcanonical ensemble (NVE) Born-Oppenheimer molecular dynamics (BOMD) simulation, as a function of the time step $\\Delta t$ and the self-consistent field (SCF) tolerance $\\epsilon$, using a shadow Hamiltonian argument and a simple model for SCF-induced force errors.\n\nStarting from first principles and well-tested formulas, derive a quantitative estimate for the energy drift rate per degree of freedom in electronvolts per picosecond ($\\mathrm{eV/ps}$) by combining two contributions:\n\n1. A finite time step contribution motivated by the shadow Hamiltonian of a time-reversible, symplectic integrator (for example, the velocity-Verlet scheme). Consider a single effective harmonic mode with mass $m$, angular frequency $\\omega$ (in radians per picosecond), potential $V(x) = \\tfrac{1}{2} k x^2$ with $k = m \\omega^2$, and kinetic energy $T(p) = \\tfrac{p^2}{2m}$. Use the fact that for symmetric second-order splitting methods the shadow Hamiltonian admits an expansion\n$$\n\\tilde{H} = H + \\frac{\\Delta t^2}{12}\\{V,\\{T,V\\}\\} - \\frac{\\Delta t^2}{24}\\{T,\\{T,V\\}\\} + \\mathcal{O}(\\Delta t^4),\n$$\nwhere $\\{A,B\\}$ denotes the Poisson bracket. Evaluate this for the harmonic oscillator and use equipartition at temperature $T$ to obtain a characteristic amplitude for the energy oscillation in the true Hamiltonian $H$ relative to the conserved shadow Hamiltonian $\\tilde{H}$. Then, estimate a worst-case instantaneous apparent drift rate from this oscillatory error by multiplying the amplitude by a characteristic angular frequency. This must produce a contribution that scales as $\\Delta t^2$ and depends on $T$ and $\\omega$ with physically consistent units.\n\n2. An SCF incompleteness contribution derived from non-variational force errors. Model the force error per degree of freedom as having magnitude $\\sigma_F \\approx C_F \\epsilon$ (with $C_F$ a constant with units $\\mathrm{eV/\\AA}$) and assume a nonzero correlation coefficient $c_c \\in [0,1]$ between the force error and the velocity, so that the average power input per degree of freedom is estimated as $\\langle \\dot{E} \\rangle \\approx c_c \\,\\sigma_F \\, v_{\\mathrm{rms}}$, where $v_{\\mathrm{rms}}$ is the root-mean-square velocity at temperature $T$. Use the classical relation $\\tfrac{1}{2} m v_{\\mathrm{rms}}^2 = \\tfrac{1}{2} k_B T$ to express $v_{\\mathrm{rms}}$ in terms of $T$ and $m$, ensuring consistent unit conversion so that the power is expressed in $\\mathrm{eV/ps}$. Treat $\\epsilon$ as dimensionless.\n\nAssume the system has $n_{\\mathrm{dof}}$ independent harmonic degrees of freedom with identical effective angular frequency $\\omega$ and identical mass $m$. The total energy drift rate should be taken as the sum over all degrees of freedom:\n$$\nR_{\\mathrm{total}}(\\Delta t, \\epsilon) = n_{\\mathrm{dof}}\\left(R_{\\Delta t,\\mathrm{dof}}(\\Delta t) + R_{\\epsilon,\\mathrm{dof}}(\\epsilon)\\right),\n$$\nwhere $R_{\\Delta t,\\mathrm{dof}}$ is the time-step-induced contribution derived via the shadow Hamiltonian argument and $R_{\\epsilon,\\mathrm{dof}}$ is the SCF-induced contribution.\n\nUse the following constant values and units in your derivation and implementation:\n- Boltzmann constant in electronvolts per kelvin: $k_B = 8.617333262145 \\times 10^{-5}\\ \\mathrm{eV/K}$.\n- Boltzmann constant in joules per kelvin: $k_B^{(J)} = 1.380649 \\times 10^{-23}\\ \\mathrm{J/K}$.\n- Atomic mass unit (amu) in kilograms: $1\\ \\mathrm{amu} = 1.66053906660 \\times 10^{-27}\\ \\mathrm{kg}$.\n- Temperature $T = 300\\ \\mathrm{K}$.\n- Effective angular frequency $\\omega = 2\\pi \\times 5\\ \\mathrm{rad/ps}$ (note: angles are in radians).\n- Effective mass $m = 28.0855\\ \\mathrm{amu}$.\n- Degrees of freedom $n_{\\mathrm{dof}} = 24$.\n- Force error coefficient $C_F = 10\\ \\mathrm{eV/\\AA}$.\n- Correlation coefficient $c_c = 0.1$ (dimensionless).\n\nRequirements for unit consistency:\n- Time step input $\\Delta t$ is provided in femtoseconds and must be converted to picoseconds inside the program via $\\Delta t_{\\mathrm{ps}} = \\Delta t_{\\mathrm{fs}} / 1000$.\n- For the SCF-induced term, express velocity in $\\mathrm{\\AA/ps}$ and force in $\\mathrm{eV/\\AA}$ so that power is in $\\mathrm{eV/ps}$. Use $v_{\\mathrm{rms}} = \\sqrt{k_B^{(J)} T / m_{\\mathrm{kg}}}$ in $\\mathrm{m/s}$, then convert to $\\mathrm{\\AA/ps}$ using $1\\ \\mathrm{m/s} = 10^{-2}\\ \\mathrm{\\AA/ps}$.\n- For the time-step-induced term, ensure that the final contribution has units of $\\mathrm{eV/ps}$ by using $\\omega$ in $\\mathrm{rad/ps}$, $\\Delta t$ in $\\mathrm{ps}$, and $k_B T$ in $\\mathrm{eV}$.\n\nTest suite:\nYour program must compute $R_{\\mathrm{total}}$ in $\\mathrm{eV/ps}$ for each of the following test cases, where each case is a pair $(\\Delta t_{\\mathrm{fs}}, \\epsilon)$:\n- Case 1: $(1.0,\\ 1.0 \\times 10^{-5})$\n- Case 2: $(0.5,\\ 1.0 \\times 10^{-5})$\n- Case 3: $(1.0,\\ 0.0)$\n- Case 4: $(0.0,\\ 2.0 \\times 10^{-5})$\n- Case 5: $(2.0,\\ 1.0 \\times 10^{-6})$\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, \"[result1,result2,...]\".\n- Each result must be a floating-point number in $\\mathrm{eV/ps}$ with exactly six digits after the decimal point.", "solution": "The problem requires the derivation of a quantitative estimate for the total energy drift rate, $R_{\\mathrm{total}}$, in a Born-Oppenheimer molecular dynamics simulation under a microcanonical ensemble. The total drift rate is the sum of contributions from the finite integration time step, $\\Delta t$, and the incomplete convergence of the self-consistent field (SCF) calculation, parameterized by the tolerance $\\epsilon$. The derivation will proceed by first analyzing each contribution per degree of freedom and then summing over all degrees of freedom.\n\nThe total drift rate is given by the expression:\n$$\nR_{\\mathrm{total}}(\\Delta t, \\epsilon) = n_{\\mathrm{dof}}\\left(R_{\\Delta t,\\mathrm{dof}}(\\Delta t) + R_{\\epsilon,\\mathrm{dof}}(\\epsilon)\\right)\n$$\nwhere $n_{\\mathrm{dof}}$ is the number of degrees of freedom. We will now derive the expressions for the two contributions per degree of freedom, $R_{\\Delta t,\\mathrm{dof}}$ and $R_{\\epsilon,\\mathrm{dof}}$.\n\n**1. Time Step Contribution ($R_{\\Delta t,\\mathrm{dof}}$)**\n\nThis contribution arises from the numerical integration error of a symplectic algorithm like velocity-Verlet. The integrator does not conserve the true Hamiltonian, $H$, but a nearby \"shadow\" Hamiltonian, $\\tilde{H}$. The problem provides the expansion for $\\tilde{H}$ for a second-order symmetric splitting method:\n$$\n\\tilde{H} = H + \\frac{\\Delta t^2}{12}\\{V,\\{T,V\\}\\} - \\frac{\\Delta t^2}{24}\\{T,\\{T,V\\}\\} + \\mathcal{O}(\\Delta t^4)\n$$\nWe model a single degree of freedom as a one-dimensional harmonic oscillator with Hamiltonian $H(x,p) = T(p) + V(x)$, where the kinetic energy is $T(p) = \\frac{p^2}{2m}$ and the potential energy is $V(x) = \\frac{1}{2} k x^2 = \\frac{1}{2} m \\omega^2 x^2$. The Poisson bracket is defined as $\\{A,B\\} = \\frac{\\partial A}{\\partial x} \\frac{\\partial B}{\\partial p} - \\frac{\\partial A}{\\partial p} \\frac{\\partial B}{\\partial x}$.\n\nFirst, we calculate the inner Poisson bracket $\\{T,V\\}$:\n$$\n\\{T,V\\} = \\frac{\\partial}{\\partial x}\\left(\\frac{p^2}{2m}\\right) \\frac{\\partial}{\\partial p}\\left(\\frac{1}{2} m \\omega^2 x^2\\right) - \\frac{\\partial}{\\partial p}\\left(\\frac{p^2}{2m}\\right) \\frac{\\partial}{\\partial x}\\left(\\frac{1}{2} m \\omega^2 x^2\\right) = (0)(0) - \\left(\\frac{p}{m}\\right)(m \\omega^2 x) = -p \\omega^2 x\n$$\nNext, we compute the two outer brackets:\n$$\n\\{V,\\{T,V\\}\\} = \\left\\{ \\frac{1}{2} m \\omega^2 x^2, -p \\omega^2 x \\right\\} = (m \\omega^2 x)(-\\omega^2 x) - (0)(-p \\omega^2) = -m \\omega^4 x^2\n$$\n$$\n\\{T,\\{T,V\\}\\} = \\left\\{ \\frac{p^2}{2m}, -p \\omega^2 x \\right\\} = (0)(-\\omega^2 x) - \\left(\\frac{p}{m}\\right)(-p \\omega^2) = \\frac{p^2 \\omega^2}{m}\n$$\nThe correction term, $\\Delta H = \\tilde{H} - H$, to order $\\Delta t^2$ is then:\n$$\n\\Delta H = \\frac{\\Delta t^2}{12}(-m \\omega^4 x^2) - \\frac{\\Delta t^2}{24}\\left(\\frac{p^2 \\omega^2}{m}\\right) = -\\frac{\\Delta t^2 \\omega^2}{6}\\left(\\frac{1}{2}m\\omega^2 x^2\\right) - \\frac{\\Delta t^2 \\omega^2}{12}\\left(\\frac{p^2}{2m}\\right)\n$$\nExpressing this in terms of $V$ and $T$:\n$$\n\\Delta H = -\\frac{\\Delta t^2 \\omega^2}{6}V - \\frac{\\Delta t^2 \\omega^2}{12}T\n$$\nThe true energy $H(t) = \\tilde{H} - \\Delta H(t)$ is not constant. The amplitude of its oscillation, $\\delta E_{\\Delta t, \\mathrm{dof}}$, can be estimated from the range of $\\Delta H$ over one period of the oscillator. For a harmonic oscillator with energy $E = T+V$, the energy varies between purely kinetic ($T=E, V=0$) and purely potential ($V=E, T=0$). The value of $\\Delta H$ thus oscillates between $-\\frac{\\Delta t^2 \\omega^2}{12}E$ and $-\\frac{\\Delta t^2 \\omega^2}{6}E$. The total amplitude of oscillation is the magnitude of the difference:\n$$\n\\delta E_{\\Delta t, \\mathrm{dof}} = \\left| \\left(-\\frac{\\Delta t^2 \\omega^2}{12}E\\right) - \\left(-\\frac{\\Delta t^2 \\omega^2}{6}E\\right) \\right| = \\frac{\\Delta t^2 \\omega^2}{12}E\n$$\nFrom the equipartition theorem, the average energy of a one-dimensional harmonic oscillator at temperature $T$ is $\\langle E \\rangle = k_B T$. Substituting this for $E$:\n$$\n\\delta E_{\\Delta t, \\mathrm{dof}} \\approx \\frac{\\Delta t^2 \\omega^2}{12} k_B T\n$$\nThe problem instructs us to estimate the worst-case instantaneous drift rate by multiplying this amplitude by a characteristic angular frequency, for which we use the oscillator's own frequency $\\omega$.\n$$\nR_{\\Delta t, \\mathrm{dof}}(\\Delta t) = \\delta E_{\\Delta t, \\mathrm{dof}} \\cdot \\omega = \\frac{(k_B T) \\omega^3 \\Delta t^2}{12}\n$$\nThis contribution scales as $\\Delta t^2$ as expected. The units must be consistent: $k_B T$ in electronvolts ($\\mathrm{eV}$), $\\omega$ in radians per picosecond ($\\mathrm{rad/ps}$), and $\\Delta t$ in picoseconds ($\\mathrm{ps}$), yielding a rate in $\\mathrm{eV/ps}$.\n\n**2. SCF Incompleteness Contribution ($R_{\\epsilon, \\mathrm{dof}}$)**\n\nThis contribution stems from systematic errors in the forces when the SCF cycle is not fully converged. The average rate of energy change per degree of freedom (power) is modeled as:\n$$\nR_{\\epsilon, \\mathrm{dof}} = \\langle \\dot{E} \\rangle \\approx c_c \\, \\sigma_F \\, v_{\\mathrm{rms}}\n$$\nwhere $\\sigma_F$ is the magnitude of the force error, $v_{\\mathrm{rms}}$ is the root-mean-square velocity, and $c_c$ is a correlation coefficient. The force error is modeled as $\\sigma_F \\approx C_F \\epsilon$, where $C_F$ is a constant and $\\epsilon$ is the dimensionless SCF tolerance.\n$$\nR_{\\epsilon, \\mathrm{dof}}(\\epsilon) = c_c (C_F \\epsilon) v_{\\mathrm{rms}}\n$$\nThe root-mean-square velocity is obtained from the equipartition theorem for kinetic energy, $\\frac{1}{2} m \\langle v^2 \\rangle = \\frac{1}{2} k_B T$, which gives $v_{\\mathrm{rms}} = \\sqrt{k_B T / m}$. To ensure correct units, we must use fundamental constants in SI units and then convert. Specifically, $k_B$ must be in $\\mathrm{J/K}$ and mass $m$ in $\\mathrm{kg}$.\n$$\nv_{\\mathrm{rms}} [\\mathrm{m/s}] = \\sqrt{\\frac{k_B^{(J)} T}{m_{\\mathrm{kg}}}}\n$$\nThe problem requires the velocity in units of angstroms per picosecond ($\\mathrm{\\AA/ps}$). The conversion is $1\\ \\mathrm{m/s} = \\frac{10^{10}\\ \\mathrm{\\AA}}{10^{12}\\ \\mathrm{ps}} = 10^{-2}\\ \\mathrm{\\AA/ps}$.\n$$\nv_{\\mathrm{rms}} [\\mathrm{\\AA/ps}] = \\sqrt{\\frac{k_B^{(J)} T}{m_{\\mathrm{kg}}}} \\times 10^{-2}\n$$\nThe mass $m_{\\mathrm{kg}}$ is obtained by converting the given mass in atomic mass units ($m_{\\mathrm{amu}}$). With $C_F$ in $\\mathrm{eV/\\AA}$ and $v_{\\mathrm{rms}}$ in $\\mathrm{\\AA/ps}$, the resulting rate $R_{\\epsilon, \\mathrm{dof}}$ is in $\\mathrm{eV/ps}$.\n\n**3. Total Drift Rate and Final Calculation**\n\nCombining the expressions, the total drift rate is:\n$$\nR_{\\mathrm{total}}(\\Delta t, \\epsilon) = n_{\\mathrm{dof}} \\left( \\frac{(k_B T)_{\\mathrm{eV}} \\omega^3 (\\Delta t_{\\mathrm{ps}})^2}{12} + c_c C_F \\epsilon \\, v_{\\mathrm{rms}, \\mathrm{\\AA/ps}} \\right)\n$$\nWe use the provided constants:\n- $k_B = 8.617333262145 \\times 10^{-5}\\ \\mathrm{eV/K}$ (for the $\\Delta t$ term)\n- $k_B^{(J)} = 1.380649 \\times 10^{-23}\\ \\mathrm{J/K}$ (for the $\\epsilon$ term)\n- $1\\ \\mathrm{amu} = 1.66053906660 \\times 10^{-27}\\ \\mathrm{kg}$\n- $T = 300\\ \\mathrm{K}$\n- $\\omega = 2\\pi \\times 5\\ \\mathrm{rad/ps}$\n- $m = 28.0855\\ \\mathrm{amu}$\n- $n_{\\mathrm{dof}} = 24$\n- $C_F = 10\\ \\mathrm{eV/\\AA}$\n- $c_c = 0.1$\n\nThe input time step $\\Delta t_{\\mathrm{fs}}$ is in femtoseconds and must be converted to picoseconds: $\\Delta t_{\\mathrm{ps}} = \\Delta t_{\\mathrm{fs}} / 1000$. The program below implements this derived formula to compute the drift rate for the given test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the energy drift rate in a BOMD simulation based on a\n    model combining time-step and SCF-incompleteness errors.\n    \"\"\"\n    # Define the constants and parameters from the problem statement.\n    # Boltzmann constant in eV/K\n    KB_EV = 8.617333262145e-5\n    # Boltzmann constant in J/K\n    KB_J = 1.380649e-23\n    # Conversion from atomic mass unit to kilograms\n    AMU_TO_KG = 1.66053906660e-27\n    # System temperature in Kelvin\n    T_K = 300.0\n    # Effective angular frequency in rad/ps\n    OMEGA_RAD_PER_PS = 2.0 * np.pi * 5.0\n    # Effective mass in amu\n    M_AMU = 28.0855\n    # Number of degrees of freedom\n    N_DOF = 24\n    # Force error coefficient in eV/Angstrom\n    C_F_EV_PER_A = 10.0\n    # Correlation coefficient (dimensionless)\n    C_C = 0.1\n\n    # --- Pre-calculate coefficients for the two drift rate contributions ---\n\n    # 1. SCF incompleteness contribution coefficient\n    # Convert mass from amu to kg\n    m_kg = M_AMU * AMU_TO_KG\n    # Calculate rms velocity in m/s using the equipartition theorem in SI units\n    v_rms_m_s = np.sqrt(KB_J * T_K / m_kg)\n    # Convert velocity from m/s to Angstrom/ps\n    # 1 m/s = 1e10 A / 1e12 ps = 1e-2 A/ps\n    v_rms_a_ps = v_rms_m_s * 1e-2\n    # The rate per DOF is R_eps_dof = (c_c * C_F * epsilon) * v_rms\n    # This coefficient is multiplied by epsilon.\n    r_eps_coeff = C_C * C_F_EV_PER_A * v_rms_a_ps\n\n    # 2. Time-step contribution coefficient\n    # Thermal energy in eV\n    kbt_ev = KB_EV * T_K\n    # The rate per DOF is R_dt_dof = (kbt_ev * omega^3 * dt_ps^2) / 12\n    # We are given dt in fs, so dt_ps = dt_fs / 1000.\n    # The coefficient is to be multiplied by dt_fs^2.\n    r_dt_coeff_fs_sq = (kbt_ev * OMEGA_RAD_PER_PS**3) / 12.0 * (1.0 / 1000.0)**2\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (time_step_fs, scf_tolerance_epsilon)\n    test_cases = [\n        (1.0, 1.0e-5),\n        (0.5, 1.0e-5),\n        (1.0, 0.0),\n        (0.0, 2.0e-5),\n        (2.0, 1.0e-6),\n    ]\n\n    results = []\n    # Loop over test cases and calculate the total drift rate\n    for dt_fs, epsilon in test_cases:\n        # Calculate the contribution from the finite time step\n        rate_dt_dof = r_dt_coeff_fs_sq * dt_fs**2\n        \n        # Calculate the contribution from SCF incompleteness\n        rate_eps_dof = r_eps_coeff * epsilon\n        \n        # Calculate the total rate by summing contributions and multiplying by n_dof\n        total_rate = N_DOF * (rate_dt_dof + rate_eps_dof)\n        \n        # Format the result to six decimal places and append to the list\n        results.append(f\"{total_rate:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3431499"}]}