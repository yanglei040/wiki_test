{"hands_on_practices": [{"introduction": "Thermodynamic integration provides a powerful numerical route to free energies, but how can we trust the results? This first exercise builds confidence in the method by applying it to a system where the exact answer is known: the one-dimensional Ising model. By comparing the free energy calculated via thermodynamic integration against the exact solution from the transfer matrix method, you will directly verify the accuracy and conceptual soundness of the TI framework [@problem_id:3495938].", "problem": "Consider a one-dimensional binary-spin lattice (Ising-type) with periodic boundary conditions and nearest-neighbor interactions in reduced units where the Boltzmann constant $k_{\\mathrm{B}}$ equals $1$. Let the lattice have $N$ sites with spins $s_i \\in \\{-1, +1\\}$ and define a parameterized potential energy $U(\\lambda)$ by scaling the interaction strength through a coupling parameter $\\lambda \\in [0,1]$:\n$$\nU(\\lambda) = -\\lambda J \\sum_{i=1}^{N} s_i s_{i+1},\n$$\nwith $s_{N+1} \\equiv s_1$, interaction energy scale $J \\in \\mathbb{R}$, and temperature $T > 0$. The canonical partition function is\n$$\nZ(\\lambda) = \\sum_{\\{s_i\\}} \\exp\\left(-\\beta U(\\lambda)\\right),\n$$\nwhere $\\beta = 1/T$, and the Helmholtz free energy is\n$$\nF(\\lambda) = -T \\ln Z(\\lambda).\n$$\nThermodynamic integration relates the free energy difference between $\\lambda = 0$ and $\\lambda = 1$ to the ensemble average of the derivative of the potential with respect to $\\lambda$:\n$$\nF(1) - F(0) = \\int_{0}^{1} \\left\\langle \\frac{\\partial U(\\lambda)}{\\partial \\lambda} \\right\\rangle_{\\lambda} \\, d\\lambda.\n$$\nAt $\\lambda = 0$, the sites are non-interacting; thus, the partition function factorizes and the free energy per site $f(0) \\equiv F(0)/N$ can be obtained directly from the definition of $Z(\\lambda)$.\n\nSeparately, the transfer-matrix method gives the exact free energy per site in the thermodynamic limit by constructing a $2 \\times 2$ transfer matrix from the Boltzmann weights of nearest-neighbor spin pairs and taking the largest eigenvalue $\\Lambda_{\\max}$ of that matrix. The exact free energy per site in the $N \\to \\infty$ limit is\n$$\nf_{\\mathrm{TM}} = -\\frac{T}{N} \\lim_{N \\to \\infty} \\ln \\operatorname{Tr}\\left(\\mathbf{T}^N\\right) = -T \\ln \\Lambda_{\\max}.\n$$\nYour tasks are:\n- Starting from the canonical ensemble definition and the derivative $\\partial U/\\partial \\lambda$, derive a closed-form expression for the thermodynamic integration integrand per site, that is, the ensemble average $\\left\\langle \\partial U(\\lambda)/\\partial \\lambda \\right\\rangle_{\\lambda}$ divided by $N$, as a function of $\\lambda$, $J$, and $T$. Then express the thermodynamic integration result for the free energy per site at $\\lambda = 1$, denoted $f_{\\mathrm{TI}}$, in terms of the integral of this integrand plus the analytically known $f(0)$.\n- Independently, construct the transfer matrix for the one-dimensional nearest-neighbor interaction with zero external field and compute the exact free energy per site $f_{\\mathrm{TM}}$ from its largest eigenvalue at $\\lambda = 1$.\n- Implement both evaluations numerically in a program: evaluate $f_{\\mathrm{TI}}$ via numerical quadrature of the integrand over $\\lambda \\in [0,1]$, and evaluate $f_{\\mathrm{TM}}$ from the transfer matrix largest eigenvalue. Demonstrate numerical agreement by reporting the absolute difference $|f_{\\mathrm{TI}} - f_{\\mathrm{TM}}|$.\n\nUse reduced units where $k_{\\mathrm{B}} = 1$, and report free energies per site in units of energy. Angles are not used. All outputs must be floats. Your program must compute and print, on a single line, a comma-separated list enclosed in square brackets containing the absolute differences $|f_{\\mathrm{TI}} - f_{\\mathrm{TM}}|$ for the following test suite of $(J, T)$ values:\n- Case $1$: $J = 1.2$, $T = 2.5$.\n- Case $2$: $J = 0.0$, $T = 1.0$.\n- Case $3$: $J = 3.0$, $T = 0.5$.\n- Case $4$: $J = -1.5$, $T = 1.3$.\n- Case $5$: $J = 0.7$, $T = 100.0$.\n\nFinal Output Format requirement:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4,r_5]$), where each $r_i$ is the absolute difference rounded to $12$ decimal places (i.e., to within an absolute tolerance of $10^{-12}$).", "solution": "The problem statement is assessed to be valid. It is scientifically grounded in the principles of statistical mechanics, specifically the one-dimensional Ising model. It is well-posed, objective, and internally consistent, providing all necessary information for deriving and numerically comparing two methods for calculating the Helmholtz free energy.\n\nThe solution is derived in three parts: first, the expression for the free energy per site from thermodynamic integration, $f_{\\mathrm{TI}}$; second, the expression from the transfer matrix method, $f_{\\mathrm{TM}}$; and third, the strategy for numerical implementation and comparison.\n\n### 1. Thermodynamic Integration Free Energy ($f_{\\mathrm{TI}}$)\n\nThe free energy difference per site, $f(\\lambda) = F(\\lambda)/N$, between the states described by $\\lambda=1$ and $\\lambda=0$ is given by the thermodynamic integration formula:\n$$\nf(1) - f(0) = \\frac{1}{N} \\int_{0}^{1} \\left\\langle \\frac{\\partial U(\\lambda)}{\\partial \\lambda} \\right\\rangle_{\\lambda} \\, d\\lambda\n$$\nThe parameterized potential energy is $U(\\lambda) = -\\lambda J \\sum_{i=1}^{N} s_i s_{i+1}$. Its derivative with respect to the coupling parameter $\\lambda$ is:\n$$\n\\frac{\\partial U(\\lambda)}{\\partial \\lambda} = -J \\sum_{i=1}^{N} s_i s_{i+1}\n$$\nThe integrand per site is the ensemble average of this derivative divided by the number of sites $N$:\n$$\n\\frac{1}{N} \\left\\langle \\frac{\\partial U(\\lambda)}{\\partial \\lambda} \\right\\rangle_{\\lambda} = \\frac{1}{N} \\left\\langle -J \\sum_{i=1}^{N} s_i s_{i+1} \\right\\rangle_{\\lambda}\n$$\nDue to the translational invariance of the system with periodic boundary conditions, the nearest-neighbor spin correlation $\\langle s_i s_{i+1} \\rangle_{\\lambda}$ is the same for all sites $i$. Thus, the expression simplifies to:\n$$\n\\frac{1}{N} \\left\\langle \\frac{\\partial U(\\lambda)}{\\partial \\lambda} \\right\\rangle_{\\lambda} = -J \\langle s_1 s_2 \\rangle_{\\lambda}\n$$\nFor the one-dimensional Ising model, the nearest-neighbor correlation function in the thermodynamic limit ($N \\to \\infty$) is a standard result given by:\n$$\n\\langle s_1 s_2 \\rangle_{\\lambda} = \\tanh(\\beta \\lambda J) = \\tanh\\left(\\frac{\\lambda J}{T}\\right)\n$$\nwhere $\\beta = 1/T$ and $k_B=1$. Therefore, the closed-form expression for the integrand per site is:\n$$\n\\frac{1}{N} \\left\\langle \\frac{\\partial U(\\lambda)}{\\partial \\lambda} \\right\\rangle_{\\lambda} = -J \\tanh\\left(\\frac{\\lambda J}{T}\\right)\n$$\nNext, we determine the initial free energy per site, $f(0)$. At $\\lambda=0$, the potential energy is $U(0)=0$. The spins are non-interacting. The partition function $Z(0)$ is the sum over all possible $2^N$ spin configurations:\n$$\nZ(0) = \\sum_{\\{s_i\\}} \\exp(-\\beta U(0)) = \\sum_{\\{s_i\\}} e^0 = 2^N\n$$\nThe corresponding free energy is $F(0) = -T \\ln Z(0) = -T \\ln(2^N) = -NT \\ln(2)$. The free energy per site is:\n$$\nf(0) = \\frac{F(0)}{N} = -T \\ln(2)\n$$\nCombining these results, the free energy per site at $\\lambda=1$, denoted $f_{\\mathrm{TI}}$, is expressed as:\n$$\nf_{\\mathrm{TI}} = f(1) = f(0) + \\int_{0}^{1} \\left(-J \\tanh\\left(\\frac{\\lambda J}{T}\\right)\\right) \\, d\\lambda = -T \\ln(2) - J \\int_{0}^{1} \\tanh\\left(\\frac{\\lambda J}{T}\\right) \\, d\\lambda\n$$\nThis expression is to be evaluated by computing the integral numerically.\n\n### 2. Transfer Matrix Free Energy ($f_{\\mathrm{TM}}$)\n\nThe transfer matrix method provides an exact solution for the free energy of the one-dimensional Ising model in the thermodynamic limit. The transfer matrix $\\mathbf{T}$ connects adjacent spins, and its elements are the Boltzmann weights of the interaction energy. For spins $s_i, s_{i+1} \\in \\{-1, +1\\}$ and $\\lambda=1$, the elements are given by $T_{s_i, s_{i+1}} = \\exp(-\\beta(-J s_i s_{i+1})) = \\exp(\\beta J s_i s_{i+1})$. This results in the $2 \\times 2$ matrix:\n$$\n\\mathbf{T} = \\begin{pmatrix} T_{1,1} & T_{1,-1} \\\\ T_{-1,1} & T_{-1,-1} \\end{pmatrix} = \\begin{pmatrix} e^{\\beta J} & e^{-\\beta J} \\\\ e^{-\\beta J} & e^{\\beta J} \\end{pmatrix}\n$$\nThe eigenvalues $\\Lambda$ are found by solving the characteristic equation $\\det(\\mathbf{T} - \\Lambda \\mathbf{I}) = 0$:\n$$\n(e^{\\beta J} - \\Lambda)^2 - (e^{-\\beta J})^2 = 0 \\implies \\Lambda = e^{\\beta J} \\pm e^{-\\beta J}\n$$\nThe two eigenvalues are $\\Lambda_1 = e^{\\beta J} + e^{-\\beta J} = 2 \\cosh(\\beta J)$ and $\\Lambda_2 = e^{\\beta J} - e^{-\\beta J} = 2 \\sinh(\\beta J)$. The largest eigenvalue is $\\Lambda_{\\max} = \\Lambda_1 = 2 \\cosh(\\beta J)$, since $\\cosh(x) \\ge |\\sinh(x)|$ for all real $x$.\n\nThe free energy per site in the thermodynamic limit $N \\to \\infty$ is related to the largest eigenvalue of the transfer matrix by:\n$$\nf_{\\mathrm{TM}} = -T \\ln(\\Lambda_{\\max})\n$$\nSubstituting the expression for $\\Lambda_{\\max}$ gives the exact analytical result:\n$$\nf_{\\mathrm{TM}} = -T \\ln\\left(2 \\cosh\\left(\\frac{J}{T}\\right)\\right)\n$$\n\n### 3. Numerical Evaluation Strategy\n\nThe problem requires a numerical comparison of the two methods.\n_For $f_{\\mathrm{TI}}$_: The integral in the expression for $f_{\\mathrm{TI}}$ will be computed using numerical quadrature, specifically the `quad` function from the `scipy.integrate` library. The initial free energy $f(0) = -T \\ln(2)$ is added to the numerical result of the integral. To ensure high accuracy, the tolerance for the quadrature routine is set to a value smaller than the desired output precision (e.g., $10^{-15}$).\n_For $f_{\\mathrm{TM}}$_: The transfer matrix $\\mathbf{T}$ is constructed numerically for the given $J$ and $T$. Its eigenvalues are computed using `numpy.linalg.eigvalsh`, which is optimized for real symmetric matrices. The largest eigenvalue, $\\Lambda_{\\max}$, is identified, and $f_{\\mathrm{TM}}$ is calculated using the formula $f_{\\mathrm{TM}} = -T \\ln(\\Lambda_{\\max})$.\nFinally, the absolute difference $|f_{\\mathrm{TI}} - f_{\\mathrm{TM}}|$ is computed for each test case. This difference should be close to zero, representing the error of the numerical quadrature.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Computes and prints the absolute difference between the free energy per site\n    of a 1D Ising model calculated via thermodynamic integration (TI) and the transfer\n    matrix (TM) method for a suite of test cases.\n    \"\"\"\n\n    def solve_case(J, T):\n        \"\"\"\n        Computes the absolute difference |f_TI - f_TM| for a given pair (J, T).\n\n        Args:\n            J (float): The interaction energy scale.\n            T (float): The temperature.\n\n        Returns:\n            float: The absolute difference |f_TI - f_TM|.\n        \"\"\"\n        # Common parameter beta = 1/(k_B * T) with k_B = 1\n        beta = 1.0 / T\n\n        # --- Thermodynamic Integration (TI) Calculation ---\n        \n        # The free energy per site at lambda=0 (non-interacting system)\n        f0 = -T * np.log(2.0)\n\n        # The integrand for TI is the ensemble average of dU/d(lambda) per site,\n        # which evaluates to -J * tanh(lambda * J / T).\n        # We integrate this from lambda = 0 to 1.\n        if J == 0.0:\n            # If J is 0, the integrand is always 0.\n            integral_val = 0.0\n        else:\n            K = beta * J\n            integrand = lambda lam: -J * np.tanh(lam * K)\n            # Use high precision for quadrature for an accurate comparison.\n            integral_val, _ = quad(integrand, 0, 1, epsabs=1e-15, epsrel=1e-15)\n\n        # The TI free energy at lambda=1\n        f_TI = f0 + integral_val\n\n        # --- Transfer Matrix (TM) Calculation ---\n\n        # The transfer matrix connects states of adjacent spins. For lambda=1:\n        # T_ij = exp(beta * J * s_i * s_j)\n        # T = [[exp(beta*J), exp(-beta*J)], [exp(-beta*J), exp(beta*J)]]\n        K_full = beta * J\n        \n        T_matrix = np.array([\n            [np.exp(K_full), np.exp(-K_full)],\n            [np.exp(-K_full), np.exp(K_full)]\n        ])\n\n        # The matrix is real and symmetric, so eigvalsh is efficient and stable.\n        eigenvalues = np.linalg.eigvalsh(T_matrix)\n        \n        # The largest eigenvalue determines the free energy in the thermodynamic limit.\n        lambda_max = np.max(eigenvalues)\n\n        # The TM free energy per site is f_TM = -T * ln(Lambda_max).\n        f_TM = -T * np.log(lambda_max)\n        \n        # Calculate the absolute difference between the two methods.\n        abs_diff = np.abs(f_TI - f_TM)\n        \n        return abs_diff\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.2, 2.5),   # Case 1\n        (0.0, 1.0),   # Case 2\n        (3.0, 0.5),   # Case 3\n        (-1.5, 1.3),  # Case 4\n        (0.7, 100.0)  # Case 5\n    ]\n\n    results = []\n    for J, T in test_cases:\n        difference = solve_case(J, T)\n        results.append(difference)\n\n    # Format the results as strings rounded to 12 decimal places.\n    results_str = [f\"{r:.12f}\" for r in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "3495938"}, {"introduction": "Having validated the core principles of thermodynamic integration, we now explore its application in a more complex, multi-parameter landscape. Many materials properties depend not only on internal interactions but also on external fields like strain or electric fields. This practice demonstrates how to compute free energy changes along a path that simultaneously varies both an alchemical coupling parameter, $\\lambda$, and an external field, $h$, showcasing the method's power to predict field-dependent thermodynamics [@problem_id:3495969].", "problem": "You are to formalize and compute field-dependent Helmholtz free-energy differences using Thermodynamic Integration (TI), starting only from the canonical-ensemble definition of the partition function and the Boltzmann probability. Your task is to (i) derive, from first principles, how coupling to an external field modifies the parameter-dependent potential energy and the resulting TI integrand, (ii) propose a simultaneous-parameter TI along a prescribed path in parameter space, and (iii) implement a program that evaluates the free-energy change for a specified surrogate model in a fully self-contained manner.\n\nFundamental base you must use and build upon:\n- Canonical ensemble at inverse temperature $\\beta$, with partition function $Z(\\alpha) = \\int \\exp\\!\\left[-\\beta \\, U(\\boldsymbol{r};\\alpha)\\right] \\, d\\boldsymbol{r}$ and Helmholtz free energy $F(\\alpha) = -\\beta^{-1} \\ln Z(\\alpha)$.\n- Boltzmann probability density proportional to $\\exp\\!\\left[-\\beta \\, U(\\boldsymbol{r};\\alpha)\\right]$.\n- Differentiation under the integral sign for $Z(\\alpha)$, and the definition of ensemble averages $\\langle \\cdot \\rangle_{\\alpha}$ with respect to the Boltzmann weight at fixed $\\alpha$.\n- Linear-response style coupling of an external field to its conjugate generalized coordinate in the Hamiltonian (no explicit formula is provided; you must derive the consequences).\n\nModel system to analyze and compute:\n- Consider a one-dimensional surrogate degree of freedom $x \\in \\mathbb{R}$ representing a coarse-grained mode in a material. The potential energy is\n$$\nU(x;\\lambda,h) \\;=\\; \\tfrac{1}{2}\\,\\big(k_0 + \\lambda\\,\\Delta k\\big)\\,x^2 \\;-\\; h\\,c\\,x,\n$$\nwhere $k_0>0$ and $\\Delta k$ are stiffness parameters, $c>0$ is a coupling amplitude, $\\lambda \\in [0,1]$ is an alchemical parameter that modifies the stiffness, and $h$ is an external scalar field that can represent either an electric field or a homogeneous strain-like field in a scalarized setting. The state point is specified by $(\\lambda,h,\\beta)$, with $\\beta = 1/(k_{\\mathrm{B}}T)$.\n\nDerivation goals you must accomplish before implementing:\n1. From the canonical definitions, derive rigorously that the free energy $F(\\lambda,h)$ is a state function of $(\\lambda,h)$ and that its total differential $dF$ can be expressed in terms of ensemble averages of partial derivatives of $U$ with respect to $\\lambda$ and $h$ at fixed $(\\lambda,h)$. Do not assume any form of the TI formula; deduce it from $Z$ and $F$.\n2. Specialize the general expressions to the given quadratic model, obtaining closed-form expressions for the necessary ensemble averages in terms of $k(\\lambda) \\equiv k_0 + \\lambda \\Delta k$, $c$, $h$, and $\\beta$. Use only Gaussian integral identities derivable from the Boltzmann weight.\n\nSimultaneous-parameter TI to implement:\n- Let the target state be $(\\lambda_\\star,h_\\star)$ and the reference be $(0,0)$. Parameterize a straight path in the $(\\lambda,h)$-plane by a single scalar $\\zeta \\in [0,1]$:\n$$\n\\lambda(\\zeta) = \\lambda_\\star\\,\\zeta, \\qquad h(\\zeta) = h_\\star\\,\\zeta.\n$$\n- Express the free-energy change $\\Delta F = F(\\lambda_\\star,h_\\star) - F(0,0)$ as a one-dimensional integral over $\\zeta$ involving the ensemble averages evaluated at $(\\lambda(\\zeta),h(\\zeta))$ and the path derivatives $d\\lambda/d\\zeta$ and $dh/d\\zeta$.\n- For numerical evaluation, approximate the $\\zeta$-integral using a high-accuracy composite Simpson rule. Your program must compute and report $\\Delta F$ in units of $k_{\\mathrm{B}}T$, i.e., report $\\beta\\,\\Delta F$ as a dimensionless number.\n\nAnalytical benchmark for verification:\n- For this specific quadratic model, compute the exact $\\Delta F$ by evaluating the partition function in closed form for $(\\lambda_\\star,h_\\star)$ and $(0,0)$ and taking the difference. Then divide by $k_{\\mathrm{B}}T$ to obtain $\\beta\\,\\Delta F$. You must not use this closed form in the TI step; use it only as a benchmark.\n\nRequired program behavior:\n- Implement the simultaneous-parameter TI as described, using the derived closed-form ensemble averages appropriate to the given quadratic model.\n- Independently compute the analytical benchmark for $\\beta\\,\\Delta F$ and the absolute error between the TI estimate and the benchmark.\n- Your program must process the following test suite, where each case is a tuple $(k_0,\\Delta k,c,\\beta,\\lambda_\\star,h_\\star)$:\n  - Case A (happy path): $(2.0,\\,1.0,\\,0.8,\\,1.0,\\,1.0,\\,0.5)$\n  - Case B (boundary, zero field): $(5.0,\\,3.0,\\,1.2,\\,1.0,\\,1.0,\\,0.0)$\n  - Case C (boundary, no stiffness change): $(3.0,\\,0.0,\\,0.9,\\,1.0,\\,1.0,\\,0.8)$\n  - Case D (edge, softening but stable): $(3.0,\\,-1.5,\\,1.0,\\,1.0,\\,1.0,\\,1.1)$\n  - Case E (temperature variation): $(2.5,\\,1.0,\\,0.6,\\,2.0,\\,0.75,\\,0.9)$\n- All energies must be reported in units of $k_{\\mathrm{B}}T$ as dimensionless floats. Angles do not appear. No percentages are used.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each case, output the following three floats in order: the TI estimate of $\\beta\\,\\Delta F$, the analytical benchmark for $\\beta\\,\\Delta F$, and the absolute error. Therefore, the final output must be a flat list with $3\\times 5 = 15$ floats in the following order:\n$$\n[\\;(\\beta\\Delta F)_{\\mathrm{TI}}^{(A)},\\;(\\beta\\Delta F)_{\\mathrm{exact}}^{(A)},\\;|\\cdot|^{(A)},\\;(\\beta\\Delta F)_{\\mathrm{TI}}^{(B)},\\;(\\beta\\Delta F)_{\\mathrm{exact}}^{(B)},\\;|\\cdot|^{(B)},\\;\\ldots,\\;(\\beta\\Delta F)_{\\mathrm{TI}}^{(E)},\\;(\\beta\\Delta F)_{\\mathrm{exact}}^{(E)},\\;|\\cdot|^{(E)}\\;].\n$$", "solution": "The user-provided problem is assessed to be **valid**. It is a scientifically grounded, well-posed, and objective problem in statistical mechanics and computational physics. It requests a standard derivation of thermodynamic integration from first principles and its application to a simple, analytically solvable model, followed by a numerical implementation.\n\n**Step 1: Extract Givens**\n-   Canonical ensemble partition function: $Z(\\alpha) = \\int \\exp\\!\\left[-\\beta \\, U(\\boldsymbol{r};\\alpha)\\right] \\, d\\boldsymbol{r}$\n-   Helmholtz free energy: $F(\\alpha) = -\\beta^{-1} \\ln Z(\\alpha)$\n-   Model potential energy for a 1D degree of freedom $x$: $U(x;\\lambda,h) \\;=\\; \\tfrac{1}{2}\\,\\big(k_0 + \\lambda\\,\\Delta k\\big)\\,x^2 \\;-\\; h\\,c\\,x$, with parameters $k_0>0$, $\\Delta k$, $c>0$, $\\lambda \\in [0,1]$, and external field $h$. The inverse temperature is $\\beta$.\n-   Integration path: A straight line from $(\\lambda,h) = (0,0)$ to $(\\lambda_\\star,h_\\star)$, parameterized by $\\zeta \\in [0,1]$ as $\\lambda(\\zeta) = \\lambda_\\star\\,\\zeta$ and $h(\\zeta) = h_\\star\\,\\zeta$.\n-   Numerical task: Compute $\\beta\\,\\Delta F = \\beta(F(\\lambda_\\star,h_\\star) - F(0,0))$ using a composite Simpson rule for the thermodynamic integration.\n-   Analytical task: Derive the exact closed-form expression for $\\beta\\,\\Delta F$ as a benchmark.\n-   Test cases:\n    -   A: $(k_0, \\Delta k, c, \\beta, \\lambda_\\star, h_\\star) = (2.0,\\,1.0,\\,0.8,\\,1.0,\\,1.0,\\,0.5)$\n    -   B: $(5.0,\\,3.0,\\,1.2,\\,1.0,\\,1.0,\\,0.0)$\n    -   C: $(3.0,\\,0.0,\\,0.9,\\,1.0,\\,1.0,\\,0.8)$\n    -   D: $(3.0,\\,-1.5,\\,1.0,\\,1.0,\\,1.0,\\,1.1)$\n    -   E: $(2.5,\\,1.0,\\,0.6,\\,2.0,\\,0.75,\\,0.9)$\n-   Output: A list containing three floats per test case: the TI estimate of $\\beta\\,\\Delta F$, the analytical benchmark for $\\beta\\,\\Delta F$, and the absolute error.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded in the principles of statistical mechanics. It is well-posed, with a clear objective and sufficient information to derive a unique solution. The language is objective and formal. The model system, while simple, is physically plausible and serves as an excellent pedagogical example for the method of thermodynamic integration. The tasks are specific and verifiable. The problem satisfies all criteria for validity.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A complete solution will be provided.\n\n**Derivation of the Thermodynamic Integration Formula**\n\nThe Helmholtz free energy $F$ is a state function of the parameters $\\lambda$ and $h$, i.e., $F(\\lambda, h)$. Its total differential is given by:\n$$\ndF = \\frac{\\partial F}{\\partial \\lambda} d\\lambda + \\frac{\\partial F}{\\partial h} dh\n$$\nTo find the partial derivatives, we start from the definition $F(\\lambda,h) = -\\beta^{-1} \\ln Z(\\lambda,h)$. Using the chain rule:\n$$\n\\frac{\\partial F}{\\partial \\lambda} = -\\frac{1}{\\beta Z} \\frac{\\partial Z}{\\partial \\lambda}\n$$\nThe derivative of the partition function $Z(\\lambda,h) = \\int \\exp(-\\beta U(x;\\lambda,h)) dx$ with respect to $\\lambda$ is found by differentiating under the integral sign:\n$$\n\\frac{\\partial Z}{\\partial \\lambda} = \\int \\frac{\\partial}{\\partial \\lambda} e^{-\\beta U(x;\\lambda,h)} dx = \\int \\left(-\\beta \\frac{\\partial U}{\\partial \\lambda}\\right) e^{-\\beta U(x;\\lambda,h)} dx\n$$\nSubstituting this into the expression for $\\partial F/\\partial \\lambda$:\n$$\n\\frac{\\partial F}{\\partial \\lambda} = -\\frac{1}{\\beta Z} \\int \\left(-\\beta \\frac{\\partial U}{\\partial \\lambda}\\right) e^{-\\beta U(x;\\lambda,h)} dx = \\frac{\\int \\frac{\\partial U}{\\partial \\lambda} e^{-\\beta U(x;\\lambda,h)} dx}{\\int e^{-\\beta U(x;\\lambda,h)} dx}\n$$\nThe right-hand side is, by definition, the canonical ensemble average of $\\partial U/\\partial \\lambda$. Thus, we have the fundamental relationship:\n$$\n\\frac{\\partial F}{\\partial \\lambda} = \\left\\langle \\frac{\\partial U}{\\partial \\lambda} \\right\\rangle_{\\lambda,h}\n$$\nAn identical derivation for the parameter $h$ yields:\n$$\n\\frac{\\partial F}{\\partial h} = \\left\\langle \\frac{\\partial U}{\\partial h} \\right\\rangle_{\\lambda,h}\n$$\nTherefore, the total differential of the free energy is:\n$$\ndF = \\left\\langle \\frac{\\partial U}{\\partial \\lambda} \\right\\rangle_{\\lambda,h} d\\lambda + \\left\\langle \\frac{\\partial U}{\\partial h} \\right\\rangle_{\\lambda,h} dh\n$$\nThe change in free energy $\\Delta F$ between two states $(\\lambda_0, h_0)$ and $(\\lambda_1, h_1)$ is obtained by integrating $dF$ along any path connecting these two points in the $(\\lambda, h)$ parameter space:\n$$\n\\Delta F = F(\\lambda_1,h_1) - F(\\lambda_0,h_0) = \\int_{(\\lambda_0,h_0)}^{(\\lambda_1,h_1)} \\left\\langle \\frac{\\partial U}{\\partial \\lambda} \\right\\rangle d\\lambda + \\left\\langle \\frac{\\partial U}{\\partial h} \\right\\rangle dh\n$$\nThis is the general formula for thermodynamic integration.\n\n**Specialization to the Quadratic Model**\n\nThe model potential is $U(x;\\lambda,h) = \\frac{1}{2}k(\\lambda)x^2 - hcx$, where $k(\\lambda) = k_0 + \\lambda\\Delta k$. We first compute the partial derivatives of $U$:\n$$\n\\frac{\\partial U}{\\partial \\lambda} = \\frac{1}{2} \\frac{d k(\\lambda)}{d\\lambda} x^2 = \\frac{1}{2}\\Delta k\\,x^2 \\quad\\quad \\text{and} \\quad\\quad \\frac{\\partial U}{\\partial h} = -cx\n$$\nThe required ensemble averages are $\\langle \\frac{1}{2}\\Delta k\\,x^2 \\rangle = \\frac{1}{2}\\Delta k \\langle x^2 \\rangle_{\\lambda,h}$ and $\\langle -cx \\rangle = -c \\langle x \\rangle_{\\lambda,h}$. To evaluate $\\langle x \\rangle$ and $\\langle x^2 \\rangle$, we analyze the Boltzmann probability density $p(x) \\propto \\exp(-\\beta U(x))$. The potential is quadratic in $x$, so we complete the square:\n$$\nU(x;\\lambda,h) = \\frac{1}{2}k(\\lambda)\\left(x^2 - \\frac{2hc}{k(\\lambda)}x\\right) = \\frac{1}{2}k(\\lambda)\\left(x - \\frac{hc}{k(\\lambda)}\\right)^2 - \\frac{(hc)^2}{2k(\\lambda)}\n$$\nThe probability distribution is a Gaussian, $p(x) \\propto \\exp\\left[-\\frac{\\beta k(\\lambda)}{2}\\left(x - \\frac{hc}{k(\\lambda)}\\right)^2\\right]$. This is a normal distribution with mean $\\mu$ and variance $\\sigma^2$:\n$$\n\\mu = \\frac{hc}{k(\\lambda)} \\quad\\quad \\text{and} \\quad\\quad \\sigma^2 = \\frac{1}{\\beta k(\\lambda)}\n$$\nThe required moments are therefore:\n$$\n\\langle x \\rangle_{\\lambda,h} = \\mu = \\frac{hc}{k(\\lambda)}\n$$\n$$\n\\langle x^2 \\rangle_{\\lambda,h} = \\sigma^2 + \\mu^2 = \\frac{1}{\\beta k(\\lambda)} + \\left(\\frac{hc}{k(\\lambda)}\\right)^2\n$$\nSubstituting these into the expressions for the partial derivatives of $F$:\n$$\n\\frac{\\partial F}{\\partial \\lambda} = \\frac{1}{2}\\Delta k \\left[ \\frac{1}{\\beta k(\\lambda)} + \\frac{(hc)^2}{k(\\lambda)^2} \\right]\n$$\n$$\n\\frac{\\partial F}{\\partial h} = -c \\left[ \\frac{hc}{k(\\lambda)} \\right] = - \\frac{h c^2}{k(\\lambda)}\n$$\n\n**Formulation of the Simultaneous-Parameter TI**\n\nWe integrate from the reference state $(0,0)$ to the target state $(\\lambda_\\star, h_\\star)$ along the path $\\lambda(\\zeta) = \\lambda_\\star\\zeta$ and $h(\\zeta) = h_\\star\\zeta$ for $\\zeta \\in [0,1]$. The path derivatives are $d\\lambda/d\\zeta = \\lambda_\\star$ and $dh/d\\zeta = h_\\star$. The free energy change is the line integral:\n$$\n\\Delta F = \\int_0^1 \\left( \\frac{\\partial F}{\\partial \\lambda}\\bigg|_{\\zeta} \\frac{d\\lambda}{d\\zeta} + \\frac{\\partial F}{\\partial h}\\bigg|_{\\zeta} \\frac{dh}{d\\zeta} \\right) d\\zeta\n$$\nWe compute the dimensionless quantity $\\beta \\Delta F$:\n$$\n\\beta \\Delta F = \\int_0^1 \\left( \\beta\\frac{\\partial F}{\\partial \\lambda}\\bigg|_{\\zeta} \\lambda_\\star + \\beta\\frac{\\partial F}{\\partial h}\\bigg|_{\\zeta} h_\\star \\right) d\\zeta\n$$\nThe integrand, let's call it $f(\\zeta)$, is obtained by substituting the derived expressions evaluated along the path:\n$$\nk(\\zeta) = k_0 + \\lambda(\\zeta)\\Delta k = k_0 + \\lambda_\\star\\zeta\\Delta k\n$$\n$$\nh(\\zeta) = h_\\star\\zeta\n$$\n$$\nf(\\zeta) = \\beta \\left( \\frac{1}{2}\\Delta k \\left[ \\frac{1}{\\beta k(\\zeta)} + \\frac{(h(\\zeta)c)^2}{k(\\zeta)^2} \\right] \\right) \\lambda_\\star + \\beta \\left( - \\frac{h(\\zeta) c^2}{k(\\zeta)} \\right) h_\\star\n$$\n$$\nf(\\zeta) = \\frac{\\Delta k \\lambda_\\star}{2 k(\\zeta)} + \\frac{\\beta \\Delta k \\lambda_\\star (h_\\star\\zeta c)^2}{2 k(\\zeta)^2} - \\frac{\\beta c^2 (h_\\star\\zeta) h_\\star}{k(\\zeta)}\n$$\n$$\nf(\\zeta) = \\frac{\\Delta k \\lambda_\\star}{2 k(\\zeta)} + \\frac{\\beta c^2 h_\\star^2 \\zeta}{k(\\zeta)^2} \\left[ \\frac{1}{2}\\Delta k \\lambda_\\star \\zeta - k(\\zeta) \\right]\n$$\nSubstituting $k(\\zeta) = k_0 + \\lambda_\\star\\zeta\\Delta k$ into the bracketed term gives:\n$$\n\\frac{1}{2}\\Delta k \\lambda_\\star \\zeta - (k_0 + \\lambda_\\star\\zeta\\Delta k) = -k_0 - \\frac{1}{2}\\Delta k \\lambda_\\star \\zeta\n$$\nSo, the final integrand for numerical evaluation is:\n$$\nf(\\zeta) = \\frac{\\Delta k \\lambda_\\star}{2(k_0 + \\lambda_\\star\\zeta\\Delta k)} - \\frac{\\beta c^2 h_\\star^2 \\zeta(k_0 + \\frac{1}{2}\\Delta k \\lambda_\\star \\zeta)}{(k_0 + \\lambda_\\star\\zeta\\Delta k)^2}\n$$\nThe integral $\\beta \\Delta F = \\int_0^1 f(\\zeta) d\\zeta$ will be computed numerically.\n\n**Derivation of the Analytical Benchmark**\n\nThe partition function $Z$ is found by evaluating the integral over the Gaussian probability density:\n$$\nZ(\\lambda,h) = \\int_{-\\infty}^{\\infty} \\exp\\left(-\\beta U(x;\\lambda,h)\\right) dx = \\int_{-\\infty}^{\\infty} \\exp\\left[-\\beta\\left( \\frac{k(\\lambda)}{2}\\left(x - \\frac{hc}{k(\\lambda)}\\right)^2 - \\frac{(hc)^2}{2k(\\lambda)} \\right)\\right] dx\n$$\n$$\nZ(\\lambda,h) = \\exp\\left(\\frac{\\beta(hc)^2}{2k(\\lambda)}\\right) \\int_{-\\infty}^{\\infty} \\exp\\left[-\\frac{\\beta k(\\lambda)}{2}\\left(x - \\frac{hc}{k(\\lambda)}\\right)^2\\right] dx\n$$\nUsing the standard Gaussian integral result $\\int_{-\\infty}^{\\infty} e^{-ax^2}dx = \\sqrt{\\pi/a}$, the integral evaluates to $\\sqrt{2\\pi/(\\beta k(\\lambda))}$.\n$$\nZ(\\lambda,h) = \\sqrt{\\frac{2\\pi}{\\beta k(\\lambda)}} \\exp\\left(\\frac{\\beta(hc)^2}{2k(\\lambda)}\\right)\n$$\nThe free energy is $F = -\\beta^{-1}\\ln Z$:\n$$\nF(\\lambda,h) = -\\frac{1}{\\beta} \\left[ \\frac{1}{2}\\ln\\left(\\frac{2\\pi}{\\beta k(\\lambda)}\\right) + \\frac{\\beta(hc)^2}{2k(\\lambda)} \\right] = -\\frac{1}{2\\beta}\\ln\\left(\\frac{2\\pi}{\\beta k(\\lambda)}\\right) - \\frac{(hc)^2}{2k(\\lambda)}\n$$\nWe need $\\Delta F = F(\\lambda_\\star,h_\\star) - F(0,0)$.\nAt $(\\lambda,h) = (0,0)$, we have $k(0)=k_0$ and $h=0$:\n$$\nF(0,0) = -\\frac{1}{2\\beta}\\ln\\left(\\frac{2\\pi}{\\beta k_0}\\right)\n$$\nAt $(\\lambda,h) = (\\lambda_\\star,h_\\star)$, we have $k(\\lambda_\\star)=k_0+\\lambda_\\star\\Delta k$:\n$$\nF(\\lambda_\\star,h_\\star) = -\\frac{1}{2\\beta}\\ln\\left(\\frac{2\\pi}{\\beta(k_0+\\lambda_\\star\\Delta k)}\\right) - \\frac{(h_\\star c)^2}{2(k_0+\\lambda_\\star\\Delta k)}\n$$\nThe difference is:\n$$\n\\Delta F = F(\\lambda_\\star,h_\\star) - F(0,0) = -\\frac{(h_\\star c)^2}{2(k_0+\\lambda_\\star\\Delta k)} - \\frac{1}{2\\beta}\\left[ \\ln\\left(\\frac{2\\pi}{\\beta(k_0+\\lambda_\\star\\Delta k)}\\right) - \\ln\\left(\\frac{2\\pi}{\\beta k_0}\\right) \\right]\n$$\n$$\n\\Delta F = -\\frac{(h_\\star c)^2}{2(k_0+\\lambda_\\star\\Delta k)} + \\frac{1}{2\\beta}\\ln\\left(\\frac{k_0+\\lambda_\\star\\Delta k}{k_0}\\right)\n$$\nThe required dimensionless quantity is $\\beta \\Delta F$:\n$$\n\\beta\\Delta F_{\\text{exact}} = \\frac{1}{2}\\ln\\left(1 + \\frac{\\lambda_\\star \\Delta k}{k_0}\\right) - \\frac{\\beta (h_\\star c)^2}{2(k_0 + \\lambda_\\star\\Delta k)}\n$$\nThis is the analytical benchmark for comparison.\n\n**Numerical Implementation Strategy**\n\nThe code will implement a function that computes the integrand $f(\\zeta)$ derived above. The integral $\\int_0^1 f(\\zeta)d\\zeta$ will be evaluated using the composite Simpson's rule from the `scipy.integrate.simpson` function, which is a robust and accurate implementation. A large number of integration points ($N+1 = 10001$) will be used to ensure high accuracy. The code will also implement the derived analytical benchmark formula for $\\beta\\Delta F$. For each test case, both values will be computed and the absolute difference reported, as per the specified output format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import simpson\n\ndef solve():\n    \"\"\"\n    Computes field-dependent Helmholtz free-energy differences using\n    Thermodynamic Integration (TI) and compares with an analytical benchmark.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple (k0, delta_k, c, beta, lambda_star, h_star)\n    test_cases = [\n        (2.0, 1.0, 0.8, 1.0, 1.0, 0.5),      # Case A\n        (5.0, 3.0, 1.2, 1.0, 1.0, 0.0),      # Case B\n        (3.0, 0.0, 0.9, 1.0, 1.0, 0.8),      # Case C\n        (3.0, -1.5, 1.0, 1.0, 1.0, 1.1),     # Case D\n        (2.5, 1.0, 0.6, 2.0, 0.75, 0.9),      # Case E\n    ]\n\n    results = []\n    \n    # Number of points for numerical integration (N intervals, N+1 points)\n    # Using an even number of intervals for Simpson's rule.\n    num_points = 10001\n    zeta_points = np.linspace(0.0, 1.0, num_points)\n\n    for case in test_cases:\n        k0, delta_k, c, beta, lambda_star, h_star = case\n\n        # 1. Thermodynamic Integration (TI) Calculation\n        \n        # Define the integrand for beta * dF along the path\n        def ti_integrand(zeta, k0, delta_k, c, beta, lambda_star, h_star):\n            \"\"\"\n            Calculates the value of the TI integrand f(zeta) for beta * dF.\n            f(zeta) = beta * <dU/d_lambda> * d_lambda/d_zeta + beta * <dU/dh> * dh/d_zeta\n            \"\"\"\n            k_zeta = k0 + lambda_star * zeta * delta_k\n            \n            # Handle the case where k_zeta could be zero, though not expected in tests\n            if np.any(k_zeta == 0):\n                # Return NaN or raise error for ill-defined cases\n                # For vector input, must return array of same shape\n                return np.full_like(zeta, np.nan)\n            \n            # Term 1: from stiffness change\n            term1 = (delta_k * lambda_star) / (2.0 * k_zeta)\n            \n            # Term 2: from field coupling\n            # Term2 = -beta * c^2 * h_star^2 * zeta * (k0 + 0.5 * delta_k * lambda_star * zeta) / k_zeta^2\n            numerator_term2 = beta * (c * h_star)**2 * zeta * (k0 + 0.5 * delta_k * lambda_star * zeta)\n            denominator_term2 = k_zeta**2\n            term2 = -numerator_term2 / denominator_term2\n            \n            return term1 + term2\n\n        # Evaluate the integrand at all zeta points\n        integrand_values = ti_integrand(zeta_points, k0, delta_k, c, beta, lambda_star, h_star)\n        \n        # Perform numerical integration using composite Simpson's rule\n        # scipy.integrate.simpson is a modern replacement for scipy.integrate.simps\n        beta_df_ti = simpson(integrand_values, zeta_points)\n\n        # 2. Analytical Benchmark Calculation\n\n        k_final = k0 + lambda_star * delta_k\n        \n        # The potential must be confining, so k_final must be > 0.\n        # k0 is given as > 0.\n        if k0 <= 0 or k_final <= 0:\n            # This case corresponds to an invalid physical system (unstable potential)\n            beta_df_exact = np.nan\n        else:\n            # Term 1: from stiffness change (logarithmic term)\n            log_term = 0.5 * np.log(k_final / k0)\n            \n            # Term 2: from field coupling (quadratic term)\n            # This term is zero if h_star is zero.\n            field_term = - (beta * (h_star * c)**2) / (2.0 * k_final)\n            \n            beta_df_exact = log_term + field_term\n\n        # 3. Absolute Error Calculation\n        error = abs(beta_df_ti - beta_df_exact)\n\n        # Append results for this case\n        results.extend([beta_df_ti, beta_df_exact, error])\n\n    # Final print statement in the exact required format.\n    # Example: [0.1760658,0.1760658,0.0,....]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3495969"}, {"introduction": "This final practice bridges the gap between pedagogical models and the complex calculations required in modern materials research. Calculating the absolute free energy of a realistic system like a molecular crystal is a formidable challenge, often tackled by constructing a multi-stage thermodynamic path from a known reference state. This exercise guides you through a sophisticated, composite TI procedure involving the temporary application of artificial restraints, highlighting the critical role of analytical corrections—such as Jacobian and anchor removal terms—in recovering a physically meaningful absolute free energy [@problem_id:3496016].", "problem": "You are tasked with constructing a complete, composite thermodynamic integration (TI) procedure to compute the absolute Helmholtz free energy of a molecular crystal comprised of flexible molecules. The calculation must use two separate coupling-parameter legs: one leg that turns on intramolecular harmonic restraints on selected internal coordinates, and a second leg that turns on intermolecular interactions between molecules. The calculation must incorporate appropriate Jacobian corrections for generalized internal coordinates and analytic removal of both intramolecular restraints and external anchoring fields to produce the absolute free energy of the physical crystal at the specified temperature. All quantities must be expressed per mole of molecules in kilojoules per mole, and angles must be treated in radians internally. The final answer produced by your program must be a single line with a comma-separated list of the free energy results for the provided test suite, enclosed in square brackets, with each value rounded to six decimal places.\n\nFundamental base to use:\n- The Helmholtz free energy $F$ is defined by $F = -k_B T \\ln Z$, where $Z$ is the canonical partition function, $k_B$ is the Boltzmann constant, and $T$ is the absolute temperature.\n- The thermodynamic integration formula for a coupling parameter $\\lambda$ connecting two states is $\\Delta F = \\int_{0}^{1} \\left\\langle \\frac{\\partial U(\\lambda)}{\\partial \\lambda} \\right\\rangle_{\\lambda} \\, d\\lambda$, where $U(\\lambda)$ is a differentiable potential energy function and $\\langle \\cdot \\rangle_{\\lambda}$ denotes the canonical ensemble average at fixed $\\lambda$.\n- For a one-dimensional harmonic restraint $U(q) = \\frac{1}{2} k (q - q_0)^2$ applied to a generalized coordinate $q$ with coordinate-space measure factor $M(q)$, the corresponding partition function contribution in the narrow-restraint limit is $Z_{\\text{harm}} \\approx M(q_0) \\sqrt{\\frac{2\\pi}{\\beta k}}$ with $\\beta = 1/(k_B T)$. The measure factor $M(q)$ accounts for the Jacobian of the transformation from Cartesian coordinates to the generalized coordinate. For standard internal coordinates in three dimensions, use $M(r) = r^2$ for a bond length $r$, $M(\\theta) = \\sin\\theta$ for a bond angle $\\theta$, and $M(\\phi) = 1$ for a dihedral angle $\\phi$.\n- The removal of a harmonic restraint contributes $+\\Delta F_{\\text{remove}} = +k_B T \\ln Z_{\\text{harm}}$ to the free energy when eliminating the restraint from the Hamiltonian.\n- Translational and rotational anchoring fields modeled as independent, isotropic harmonic potentials in three dimensions contribute analytic removal terms, per molecule: $+\\Delta F_{\\text{remove,trans}} = \\frac{3}{2} k_B T \\ln\\left(\\frac{2\\pi k_B T}{\\kappa_t}\\right)$ and $+\\Delta F_{\\text{remove,rot}} = \\frac{3}{2} k_B T \\ln\\left(\\frac{2\\pi k_B T}{\\kappa_r}\\right)$, where $\\kappa_t$ and $\\kappa_r$ are the translational and rotational harmonic spring constants, respectively.\n\nDesign specification:\n- Leg $1$ (intramolecular restraints): Scale up harmonic restraints on specified internal coordinates from $\\lambda = 0$ to $\\lambda = 1$. The ensemble averages $\\left\\langle \\frac{\\partial U_{\\text{rest}}(\\lambda)}{\\partial \\lambda} \\right\\rangle_{\\lambda}$ are provided at discrete values of $\\lambda$ as input data. Compute $\\Delta F_1$ via numerical integration over $\\lambda \\in [0,1]$.\n- Leg $2$ (intermolecular interactions): Scale up intermolecular interactions from $\\lambda = 0$ to $\\lambda = 1$. The ensemble averages $\\left\\langle \\frac{\\partial U_{\\text{inter}}(\\lambda)}{\\partial \\lambda} \\right\\rangle_{\\lambda}$ are provided at discrete values of $\\lambda$ as input data. Compute $\\Delta F_2$ via numerical integration over $\\lambda \\in [0,1]$.\n- Jacobian corrections: Use $M(r) = r^2$ and $M(\\theta) = \\sin\\theta$ evaluated at the target values $r_0$ and $\\theta_0$ to construct the correct removal terms for restrained generalized coordinates. To ensure dimensionless arguments inside logarithms, normalize each bond length by a specified length scale $\\ell_{\\text{ref}}$ (use $\\ell_{\\text{ref}}$ explicitly provided below), i.e., treat $M(r_0)$ as $(r_0/\\ell_{\\text{ref}})^2$.\n- Restraint removal: After the two TI legs, add analytic removal contributions for all intramolecular harmonic restraints that were turned on in leg $1$, using the narrow-restraint limit with the appropriate measure factors. For a set of $b$ bond lengths $\\{ r_{0,i} \\}$ with spring constant $k_{\\text{bond}}$, $a$ bond angles $\\{ \\theta_{0,j} \\}$ with spring constant $k_{\\text{angle}}$, and $d$ dihedrals with spring constant $k_{\\text{dihedral}}$, the total restraint removal per mole is\n$$\n\\Delta F_{\\text{remove,rest}} = R T \\left[ \\sum_{i=1}^{b} \\left( 2 \\ln\\frac{r_{0,i}}{\\ell_{\\text{ref}}} + \\frac{1}{2} \\ln\\frac{2\\pi R T}{k_{\\text{bond}}} \\right) + \\sum_{j=1}^{a} \\left( \\ln\\sin\\theta_{0,j} + \\frac{1}{2} \\ln\\frac{2\\pi R T}{k_{\\text{angle}}} \\right) + \\sum_{k=1}^{d} \\left( \\frac{1}{2} \\ln\\frac{2\\pi R T}{k_{\\text{dihedral}}} \\right) \\right],\n$$\nwhere $R$ is the universal gas constant and $R T = N_A k_B T$ is used to express energies per mole.\n- Anchor removal: Add analytic removal contributions for isotropic three-dimensional translational and rotational anchors per molecule:\n$$\n\\Delta F_{\\text{remove,anchor}} = R T \\left[ \\frac{3}{2} \\ln\\left(\\frac{2\\pi R T}{\\kappa_t}\\right) + \\frac{3}{2} \\ln\\left(\\frac{2\\pi R T}{\\kappa_r}\\right) \\right].\n$$\n- Total free energy: The absolute Helmholtz free energy of the crystal per mole is\n$$\nF_{\\text{abs}} = \\Delta F_1 + \\Delta F_2 + \\Delta F_{\\text{remove,rest}} + \\Delta F_{\\text{remove,anchor}}.\n$$\n\nComputational requirements:\n- Perform numerical integration for each leg using composite Simpson’s rule over the provided discrete grids of $\\lambda$ and corresponding ensemble averages. If the grid cannot be treated as uniformly spaced, or the number of intervals is not even, fallback to a composite trapezoidal rule for correctness.\n- Convert all angles from degrees to radians before computing trigonometric functions.\n- Use $R = 0.008314462618$ kilojoules per mole per kelvin.\n- All outputs must be in kilojoules per mole, rounded to six decimal places.\n\nTest suite:\nYour program must compute $F_{\\text{abs}}$ for the following three parameter sets. Each average derivative array is given per mole in kilojoules per mole.\n\n- Case $1$ (general flexible molecule, typical conditions):\n    - Temperature $T = 300$ kelvin.\n    - Reference length $\\ell_{\\text{ref}} = 1.0$ angstrom.\n    - Intramolecular restraints per molecule:\n        - Bonds $b = 3$ with $r_{0} = [1.09, 1.41, 1.52]$ angstrom.\n        - Angles $a = 2$ with $\\theta_{0} = [109.5, 120.0]$ degrees.\n        - Dihedrals $d = 2$.\n        - Spring constants: $k_{\\text{bond}} = 5000$ kilojoules per mole per square angstrom, $k_{\\text{angle}} = 1000$ kilojoules per mole per radian squared, $k_{\\text{dihedral}} = 200$ kilojoules per mole per radian squared.\n    - Anchor constants: $\\kappa_t = 1000$ kilojoules per mole per square angstrom, $\\kappa_r = 500$ kilojoules per mole per radian squared.\n    - Leg $1$ grid: $\\lambda = [0.0, 0.25, 0.5, 0.75, 1.0]$, ensemble averages $\\left\\langle \\frac{\\partial U_{\\text{rest}}}{\\partial \\lambda} \\right\\rangle_{\\lambda} = [0.0, 1.6, 3.0, 4.1, 4.3]$ kilojoules per mole.\n    - Leg $2$ grid: $\\lambda = [0.0, 0.25, 0.5, 0.75, 1.0]$, ensemble averages $\\left\\langle \\frac{\\partial U_{\\text{inter}}}{\\partial \\lambda} \\right\\rangle_{\\lambda} = [0.0, -25.0, -55.0, -80.0, -95.0]$ kilojoules per mole.\n\n- Case $2$ (no intramolecular restraints, interaction-only leg, moderate anchors):\n    - Temperature $T = 300$ kelvin.\n    - Reference length $\\ell_{\\text{ref}} = 1.0$ angstrom.\n    - Intramolecular restraints per molecule: $b = 0$, $a = 0$, $d = 0$; spring constants can be ignored.\n    - Anchor constants: $\\kappa_t = 500$ kilojoules per mole per square angstrom, $\\kappa_r = 200$ kilojoules per mole per radian squared.\n    - Leg $1$ grid: $\\lambda = [0.0, 0.25, 0.5, 0.75, 1.0]$, ensemble averages $\\left\\langle \\frac{\\partial U_{\\text{rest}}}{\\partial \\lambda} \\right\\rangle_{\\lambda} = [0.0, 0.0, 0.0, 0.0, 0.0]$ kilojoules per mole.\n    - Leg $2$ grid: $\\lambda = [0.0, 0.25, 0.5, 0.75, 1.0]$, ensemble averages $\\left\\langle \\frac{\\partial U_{\\text{inter}}}{\\partial \\lambda} \\right\\rangle_{\\lambda} = [0.0, -10.0, -30.0, -40.0, -50.0]$ kilojoules per mole.\n\n- Case $3$ (low temperature, strong restraints, stiffer anchors):\n    - Temperature $T = 100$ kelvin.\n    - Reference length $\\ell_{\\text{ref}} = 1.0$ angstrom.\n    - Intramolecular restraints per molecule:\n        - Bonds $b = 1$ with $r_{0} = [0.95]$ angstrom.\n        - Angles $a = 1$ with $\\theta_{0} = [90.0]$ degrees.\n        - Dihedrals $d = 0$.\n        - Spring constants: $k_{\\text{bond}} = 10000$ kilojoules per mole per square angstrom, $k_{\\text{angle}} = 2000$ kilojoules per mole per radian squared, $k_{\\text{dihedral}}$ not used.\n    - Anchor constants: $\\kappa_t = 2000$ kilojoules per mole per square angstrom, $\\kappa_r = 1000$ kilojoules per mole per radian squared.\n    - Leg $1$ grid: $\\lambda = [0.0, 0.25, 0.5, 0.75, 1.0]$, ensemble averages $\\left\\langle \\frac{\\partial U_{\\text{rest}}}{\\partial \\lambda} \\right\\rangle_{\\lambda} = [0.0, 0.8, 1.5, 2.2, 2.5]$ kilojoules per mole.\n    - Leg $2$ grid: $\\lambda = [0.0, 0.25, 0.5, 0.75, 1.0]$, ensemble averages $\\left\\langle \\frac{\\partial U_{\\text{inter}}}{\\partial \\lambda} \\right\\rangle_{\\lambda} = [0.0, -5.0, -20.0, -35.0, -50.0]$ kilojoules per mole.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, e.g., $[f_1,f_2,f_3]$, where $f_i$ is the computed absolute Helmholtz free energy for case $i$ in kilojoules per mole, rounded to six decimal places.", "solution": "We begin from the definition of the Helmholtz free energy $F = -k_B T \\ln Z$, where $Z$ is the canonical partition function. To compute absolute free energies for solids, we construct a reversible path via coupling-parameter thermodynamic integration (TI) connecting a tractable reference to the physical system. In the present composite TI method for a molecular crystal with flexible molecules, we use two legs parameterized by $\\lambda$: leg $1$ turns on intramolecular harmonic restraints on selected internal coordinates, and leg $2$ turns on intermolecular interactions between molecules.\n\nBy the thermodynamic integration identity, for a differentiable potential energy $U(\\lambda)$ and canonical ensemble averages, the free energy change between $\\lambda=0$ and $\\lambda=1$ is\n$$\n\\Delta F = \\int_{0}^{1} \\left\\langle \\frac{\\partial U(\\lambda)}{\\partial \\lambda} \\right\\rangle_{\\lambda} \\, d\\lambda.\n$$\nWe apply this separately for two legs:\n- Leg $1$, intramolecular restraint scaling: The potential energy is of the form $U(\\lambda) = U_{\\text{base}} + \\lambda U_{\\text{rest}}$, where $U_{\\text{base}}$ contains all other interactions. The derivative is $\\partial U / \\partial \\lambda = U_{\\text{rest}}$. However, the problem provides the ensemble average of the derivative of the full potential $\\left\\langle \\frac{\\partial U_{\\text{rest}}(\\lambda)}{\\partial \\lambda} \\right\\rangle_{\\lambda}$. We integrate this directly. The leg 1 free energy is\n$$\n\\Delta F_1 = \\int_0^1 \\left\\langle \\frac{\\partial U_{\\text{rest}}(\\lambda)}{\\partial \\lambda} \\right\\rangle_{\\lambda} d\\lambda.\n$$\n- Leg $2$, intermolecular interaction scaling: Similarly, the leg 2 free energy is\n$$\n\\Delta F_2 = \\int_0^1 \\left\\langle \\frac{\\partial U_{\\text{inter}}(\\lambda)}{\\partial \\lambda} \\right\\rangle_{\\lambda} d\\lambda.\n$$\n\nAfter completing these two legs, the current endpoint of the path is a system with both full-strength intermolecular interactions and full-strength intramolecular restraints, still subject to external anchoring fields. To obtain the absolute free energy of the physical crystal (without artificial intramolecular restraints and without anchoring fields), we must analytically remove these additions.\n\nFor a generalized coordinate $q$ restrained by a harmonic potential $U(q) = \\frac{1}{2} k (q - q_0)^2$, the canonical partition function contribution in the narrow-restraint limit (valid for stiff restraints) is\n$$\nZ_{\\text{harm}} \\approx M(q_0) \\sqrt{\\frac{2\\pi}{\\beta k}},\n$$\nwhere $M(q)$ is the Jacobian factor arising from the transformation from Cartesian coordinates to the generalized coordinate $q$. For internal coordinates in three dimensions we use well-established measures:\n- For a bond length $r$, $M(r) = r^2$.\n- For a bond angle $\\theta$, $M(\\theta) = \\sin\\theta$.\n- For a dihedral angle $\\phi$, $M(\\phi) = 1$.\n\nTo ensure dimensionless arguments inside logarithms, one must normalize quantities with appropriate reference scales. For bond lengths, we normalize $r_0$ by a reference length $\\ell_{\\text{ref}}$, yielding a dimensionless $(r_0/\\ell_{\\text{ref}})^2$. Using $R T = N_A k_B T$ in kilojoules per mole, the free energy increase upon removing a harmonic restraint is\n$$\n\\Delta F_{\\text{remove}} = +k_B T \\ln Z_{\\text{harm}} = RT \\left[ \\ln M(q_0) + \\frac{1}{2} \\ln \\left(\\frac{2\\pi R T}{\\kappa} \\right) \\right],\n$$\nwhere $\\kappa$ is the molar spring constant. Summing over all restrained coordinates gives the total intramolecular restraint removal for bonds, angles, and dihedrals:\n$$\n\\Delta F_{\\text{remove,rest}} = R T \\left[ \\sum_{i=1}^{b} \\left( 2 \\ln\\frac{r_{0,i}}{\\ell_{\\text{ref}}} + \\frac{1}{2} \\ln\\frac{2\\pi R T}{k_{\\text{bond}}} \\right) + \\sum_{j=1}^{a} \\left( \\ln\\sin\\theta_{0,j} + \\frac{1}{2} \\ln\\frac{2\\pi R T}{k_{\\text{angle}}} \\right) + \\sum_{k=1}^{d} \\left( \\frac{1}{2} \\ln\\frac{2\\pi R T}{k_{\\text{dihedral}}} \\right) \\right].\n$$\nThis removal formula inherently incorporates the appropriate Jacobian corrections through $M(r_0)$ and $M(\\theta_0)$.\n\nExternal anchors must be removed to obtain absolute free energies of the real crystal. For isotropic three-dimensional harmonic anchors on center-of-mass positions with molar spring constant $\\kappa_t$, the molecular spring constant is $k_t = \\kappa_t/N_A$. The single-molecule partition function is $Z_{\\text{trans}} = (2\\pi k_B T / k_t)^{3/2}$. The free energy removal term per mole is therefore $\\Delta F_{\\text{remove,trans}} = N_A (+k_B T \\ln Z_{\\text{trans}}) = \\frac{3}{2} RT \\ln(2\\pi k_B T / k_t) = \\frac{3}{2} RT \\ln(2\\pi RT / \\kappa_t)$. Similarly, for rotational anchors with molar spring constant $\\kappa_r$, the removal term is $\\Delta F_{\\text{remove,rot}} = \\frac{3}{2} RT \\ln\\left(\\frac{2\\pi RT}{\\kappa_r}\\right)$. Combining yields the total anchor removal:\n$$\n\\Delta F_{\\text{remove,anchor}} = R T \\left[ \\frac{3}{2} \\ln\\left(\\frac{2\\pi R T}{\\kappa_t}\\right) + \\frac{3}{2} \\ln\\left(\\frac{2\\pi R T}{\\kappa_r}\\right) \\right].\n$$\n\nTherefore, the absolute Helmholtz free energy per mole at the specified temperature for each case is\n$$\nF_{\\text{abs}} = \\Delta F_1 + \\Delta F_2 + \\Delta F_{\\text{remove,rest}} + \\Delta F_{\\text{remove,anchor}}.\n$$\n\nAlgorithmic steps implemented by the program:\n1. For each case, read the temperature $T$ and compute $R T$ with $R = 0.008314462618$ kilojoules per mole per kelvin.\n2. Convert all provided bond angles $\\theta_0$ from degrees to radians before evaluating $\\sin \\theta_0$.\n3. Numerically integrate the provided discrete $\\lambda$ grids and ensemble averages for leg $1$ and leg $2$ using composite Simpson’s rule if the grid is uniformly spaced and has an even number of intervals; otherwise, fallback to the composite trapezoidal rule. This yields $\\Delta F_1$ and $\\Delta F_2$.\n4. Compute $\\Delta F_{\\text{remove,rest}}$ using the narrow-restraint formula with Jacobian measures $M(r_0) = (r_0/\\ell_{\\text{ref}})^2$, $M(\\theta_0) = \\sin\\theta_0$, and $M(\\phi) = 1$.\n5. Compute $\\Delta F_{\\text{remove,anchor}}$ using the analytic isotropic three-dimensional formulas for translational and rotational anchors.\n6. Sum the four contributions to get $F_{\\text{abs}}$ for each case.\n7. Output a single line with the three results in a comma-separated list enclosed in square brackets, each rounded to six decimal places.\n\nThis method is grounded in first principles via the partition function definition of free energy, the thermodynamic integration formula for coupling parameters, and canonical analytic expressions for harmonic partition functions and their coordinate-space Jacobian measures. The discrete integrals over $\\lambda$ correspond to typical practice wherein one uses measured or simulated ensemble averages at a set of coupling parameter values; the analytic removal terms ensure the absolute free energy pertains to the physical crystal without artificial restraints and anchors. All outputs are computed in kilojoules per mole, consistent with the use of $R T$ in the formulas.", "answer": "```python\n# Thermodynamic integration for absolute free energy of a molecular crystal\n# Python 3.12, numpy 1.23.5, scipy not used.\nimport numpy as np\n\nR_kJ_per_mol_K = 0.008314462618  # Gas constant in kJ/(mol*K)\n\ndef to_radians(degrees_array):\n    return np.deg2rad(np.array(degrees_array, dtype=float))\n\ndef is_uniform_grid(x, tol=1e-12):\n    x = np.array(x, dtype=float)\n    if len(x) < 2:\n        return True\n    diffs = np.diff(x)\n    return np.all(np.abs(diffs - diffs[0]) < tol)\n\ndef simpson_integral(x, y):\n    # Composite Simpson over uniform grid with even number of intervals.\n    x = np.array(x, dtype=float)\n    y = np.array(y, dtype=float)\n    n = len(x) - 1\n    if n < 1:\n        return 0.0\n    if is_uniform_grid(x) and n % 2 == 0 and n >= 2:\n        h = (x[-1] - x[0]) / n\n        s = y[0] + y[-1] + 4.0 * np.sum(y[1:-1:2]) + 2.0 * np.sum(y[2:-2:2])\n        return (h / 3.0) * s\n    else:\n        # Fallback: composite trapezoidal rule\n        return np.trapz(y, x)\n\ndef restraint_removal_RT(T, l_ref, r0_list, theta0_deg_list, k_bond, k_angle, k_dihedral, num_dihedrals):\n    # Compute RT * sum over restraints removal contributions.\n    RT = R_kJ_per_mol_K * T\n    total = 0.0\n    # Bonds: M(r0) = (r0 / l_ref)^2\n    for r0 in r0_list:\n        M_term = 2.0 * np.log(r0 / l_ref)\n        thermo_term = 0.5 * np.log((2.0 * np.pi * RT) / k_bond)\n        total += (M_term + thermo_term)\n    # Angles: M(theta0) = sin(theta0)\n    if len(theta0_deg_list) > 0:\n        theta0_rad_list = to_radians(theta0_deg_list)\n        for th in theta0_rad_list:\n            sin_th = np.sin(th)\n            # Protect against numerically invalid sin due to rounding\n            if sin_th <= 0.0:\n                # Extremely unlikely if inputs are physically reasonable; clamp to tiny positive to avoid -inf\n                sin_th = 1e-300\n            M_term = np.log(sin_th)\n            thermo_term = 0.5 * np.log((2.0 * np.pi * RT) / k_angle)\n            total += (M_term + thermo_term)\n    # Dihedrals: M(phi) = 1\n    for _ in range(num_dihedrals):\n        thermo_term = 0.5 * np.log((2.0 * np.pi * RT) / k_dihedral)\n        total += thermo_term\n    return RT * total\n\ndef anchor_removal_RT(T, kappa_t, kappa_r):\n    RT = R_kJ_per_mol_K * T\n    term_t = 1.5 * np.log((2.0 * np.pi * RT) / kappa_t)\n    term_r = 1.5 * np.log((2.0 * np.pi * RT) / kappa_r)\n    return RT * (term_t + term_r)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"T\": 300.0,\n            \"l_ref\": 1.0,  # Angstrom\n            \"bonds_r0\": [1.09, 1.41, 1.52],  # Angstrom\n            \"angles_theta0_deg\": [109.5, 120.0],  # degrees\n            \"num_dihedrals\": 2,\n            \"k_bond\": 5000.0,          # kJ/(mol*Angstrom^2)\n            \"k_angle\": 1000.0,         # kJ/(mol*rad^2)\n            \"k_dihedral\": 200.0,       # kJ/(mol*rad^2)\n            \"kappa_t\": 1000.0,         # kJ/(mol*Angstrom^2)\n            \"kappa_r\": 500.0,          # kJ/(mol*rad^2)\n            \"lambda_leg1\": [0.0, 0.25, 0.5, 0.75, 1.0],\n            \"avg_dUdl_leg1\": [0.0, 1.6, 3.0, 4.1, 4.3],  # kJ/mol\n            \"lambda_leg2\": [0.0, 0.25, 0.5, 0.75, 1.0],\n            \"avg_dUdl_leg2\": [0.0, -25.0, -55.0, -80.0, -95.0],  # kJ/mol\n        },\n        # Case 2\n        {\n            \"T\": 300.0,\n            \"l_ref\": 1.0,  # Angstrom\n            \"bonds_r0\": [],  # none\n            \"angles_theta0_deg\": [],  # none\n            \"num_dihedrals\": 0,\n            \"k_bond\": 1.0,            # ignored\n            \"k_angle\": 1.0,           # ignored\n            \"k_dihedral\": 1.0,        # ignored\n            \"kappa_t\": 500.0,         # kJ/(mol*Angstrom^2)\n            \"kappa_r\": 200.0,         # kJ/(mol*rad^2)\n            \"lambda_leg1\": [0.0, 0.25, 0.5, 0.75, 1.0],\n            \"avg_dUdl_leg1\": [0.0, 0.0, 0.0, 0.0, 0.0],  # kJ/mol\n            \"lambda_leg2\": [0.0, 0.25, 0.5, 0.75, 1.0],\n            \"avg_dUdl_leg2\": [0.0, -10.0, -30.0, -40.0, -50.0],  # kJ/mol\n        },\n        # Case 3\n        {\n            \"T\": 100.0,\n            \"l_ref\": 1.0,  # Angstrom\n            \"bonds_r0\": [0.95],  # Angstrom\n            \"angles_theta0_deg\": [90.0],  # degrees\n            \"num_dihedrals\": 0,\n            \"k_bond\": 10000.0,       # kJ/(mol*Angstrom^2)\n            \"k_angle\": 2000.0,       # kJ/(mol*rad^2)\n            \"k_dihedral\": 1.0,       # not used\n            \"kappa_t\": 2000.0,       # kJ/(mol*Angstrom^2)\n            \"kappa_r\": 1000.0,       # kJ/(mol*rad^2)\n            \"lambda_leg1\": [0.0, 0.25, 0.5, 0.75, 1.0],\n            \"avg_dUdl_leg1\": [0.0, 0.8, 1.5, 2.2, 2.5],  # kJ/mol\n            \"lambda_leg2\": [0.0, 0.25, 0.5, 0.75, 1.0],\n            \"avg_dUdl_leg2\": [0.0, -5.0, -20.0, -35.0, -50.0],  # kJ/mol\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        # Integrate the two legs\n        dF1 = simpson_integral(case[\"lambda_leg1\"], case[\"avg_dUdl_leg1\"])\n        dF2 = simpson_integral(case[\"lambda_leg2\"], case[\"avg_dUdl_leg2\"])\n\n        # Restraint removal\n        # If no restraints, contribution is zero.\n        if len(case[\"bonds_r0\"]) == 0 and len(case[\"angles_theta0_deg\"]) == 0 and case[\"num_dihedrals\"] == 0:\n            dF_remove_rest = 0.0\n        else:\n            dF_remove_rest = restraint_removal_RT(\n                T=case[\"T\"],\n                l_ref=case[\"l_ref\"],\n                r0_list=case[\"bonds_r0\"],\n                theta0_deg_list=case[\"angles_theta0_deg\"],\n                k_bond=case[\"k_bond\"],\n                k_angle=case[\"k_angle\"],\n                k_dihedral=case[\"k_dihedral\"],\n                num_dihedrals=case[\"num_dihedrals\"]\n            )\n\n        # Anchor removal\n        dF_remove_anchor = anchor_removal_RT(\n            T=case[\"T\"],\n            kappa_t=case[\"kappa_t\"],\n            kappa_r=case[\"kappa_r\"]\n        )\n\n        F_abs = dF1 + dF2 + dF_remove_rest + dF_remove_anchor\n        results.append(F_abs)\n\n    # Final print statement in the exact required format, rounded to six decimals.\n    print(f\"[{','.join(f'{x:.6f}' for x in results)}]\")\n\nsolve()\n```", "id": "3496016"}]}