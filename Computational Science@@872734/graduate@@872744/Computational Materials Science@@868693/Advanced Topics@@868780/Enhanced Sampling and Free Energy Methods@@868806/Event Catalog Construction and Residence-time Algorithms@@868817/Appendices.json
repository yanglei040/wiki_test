{"hands_on_practices": [{"introduction": "For systems governed by local interactions, such as many lattice models, a full rescan of all possible events after each step is computationally prohibitive. The key to efficiency lies in exploiting the principle of locality, where a single event only alters the transition rates within a small, constant-sized neighborhood. This practice [@problem_id:3450027] guides you through implementing a classic and powerful algorithm that maintains the event catalog by only updating the affected neighborhood, achieving a remarkable $O(1)$ amortized time complexity per event.", "problem": "Consider a one-dimensional periodic lattice (a ring) of $N$ sites, indexed by $i \\in \\{0,1,\\dots,N-1\\}$, with binary occupation variables $s_i \\in \\{0,1\\}$. Interactions are local with range $r=1$, so each site has coordination number $z=2$ (left and right neighbors). The system evolves as a continuous-time Markov jump process with single-site events that flip $s_i$ between $0$ and $1$. The instantaneous rate for a flip at site $i$ depends only on the local environment through the number of occupied neighbors $n_i \\in \\{0,1,2\\}$. Define adsorption as the event $0 \\rightarrow 1$ and desorption as the event $1 \\rightarrow 0$. Assume Arrhenius-type transition-state rates:\n- For adsorption, $k_{\\mathrm{ads}}(n) = \\nu \\exp\\!\\left(-\\dfrac{E_{\\mathrm{ads}} - n \\,\\epsilon}{k_{\\mathrm{B}} T}\\right)$.\n- For desorption, $k_{\\mathrm{des}}(n) = \\nu \\exp\\!\\left(-\\dfrac{E_{\\mathrm{des}} + n \\,\\epsilon}{k_{\\mathrm{B}} T}\\right)$.\n\nHere $T$ is the absolute temperature in Kelvin, $k_{\\mathrm{B}}$ is the Boltzmann constant in electronvolt per Kelvin, $\\nu$ is an attempt frequency in per second, $E_{\\mathrm{ads}}$ and $E_{\\mathrm{des}}$ are base activation energies in electronvolt, and $\\epsilon$ is a nearest-neighbor interaction energy in electronvolt. The total rate is $R = \\sum_{i} r_i$, where $r_i = k_{\\mathrm{ads}}(n_i)$ if $s_i=0$ and $r_i = k_{\\mathrm{des}}(n_i)$ if $s_i=1$.\n\nA residence-time algorithm (also called the $n$-fold way) selects and executes events as follows:\n- The waiting time $\\Delta t$ to the next event is an exponential random variable with parameter $R$, so $\\Delta t = -\\ln(u)/R$ for a uniform random number $u \\in (0,1)$.\n- The next event is chosen with probability proportional to its rate among all possible events.\n\nEvent catalog construction groups sites into classes by their local environments. Here, define $K=2(z+1)=6$ classes indexed by the pair $(s,n)$, with $s \\in \\{0,1\\}$ and $n \\in \\{0,1,2\\}$. Each class $k$ has a per-site rate $r_k$ that depends only on $(s,n)$ and a population $N_k$ equal to the number of sites currently in that local configuration. The total rate can be written $R=\\sum_{k=0}^{K-1} N_k r_k$. For event selection, one chooses a class $k$ proportionally to $N_k r_k$, and then chooses uniformly one of the $N_k$ sites within that class. After executing a single-site flip at site $i$, only the class membership of the site $i$ itself and its $z=2$ nearest neighbors can change, because the rates depend only on the local configuration within range $r=1$.\n\nTask. Using only the fundamental definition of a continuous-time Markov process with local interactions and the Arrhenius rates above, explain why a single flip event affects only a neighborhood of sites of bounded size, independent of $N$. Then, design an algorithm that maintains the event catalog and supports $O(1)$ amortized time per affected site when updating after an event. Your algorithm should:\n- Maintain for each class $k$ both the current population $N_k$ and a dynamic list of the members (site indices) to allow uniform selection within a class.\n- Maintain for each site $i$ its current class index so that updates can be performed in $O(1)$ per site using constant-time removal and insertion by swapping with the last element in the class list.\n- Select the next class by scanning over the $K$ classes. Since $K$ depends only on $z$ and is constant for fixed local interaction range, this step must be $O(1)$ per event.\n- Update the total rate $R$ incrementally when class memberships change.\n\nImplementation. Implement the residence-time algorithm with the above event catalog maintenance for the following fixed parameter values:\n- Temperature $T = 500$ Kelvin.\n- Boltzmann constant $k_{\\mathrm{B}} = 8.617333262145 \\times 10^{-5}$ electronvolt per Kelvin.\n- Attempt frequency $\\nu = 10^{13}$ per second.\n- Energies $E_{\\mathrm{ads}} = 0.35$ electronvolt, $E_{\\mathrm{des}} = 0.45$ electronvolt, and $\\epsilon = 0.05$ electronvolt.\n\nUse periodic boundary conditions. For each simulation step, use three independent uniform random numbers in $(0,1)$: one for class selection, one for site selection within the chosen class, and one for the residence time. Provided below is a test suite with three test cases. For each case, simulate a fixed number of events and record the total simulation time. Additionally, verify the locality property at every step by recomputing class labels for all sites after each event and checking that the set of sites whose class changed is contained within the set consisting of the flipped site and its two nearest neighbors.\n\nTest suite. For each case, the initial configuration is a string of digits of length $N$ encoding $s_0 s_1 \\dots s_{N-1}$, the number of events to simulate is $M$, and the random numbers are given as a flat list of length $3M$ in the order $(u_{\\mathrm{class}}, u_{\\mathrm{site}}, u_{\\mathrm{time}})$ for each step.\n\n- Case $1$: $N=10$, initial configuration $0101101001$, $M=8$, random numbers\n  $\\{0.13, 0.77, 0.42, 0.91, 0.05, 0.33, 0.68, 0.27, 0.88, 0.12, 0.56, 0.74, 0.21, 0.93, 0.49, 0.36, 0.59, 0.18, 0.81, 0.07, 0.66, 0.25, 0.97, 0.44\\}$.\n\n- Case $2$: $N=6$, initial configuration $000000$, $M=6$, random numbers\n  $\\{0.11, 0.62, 0.58, 0.47, 0.29, 0.83, 0.14, 0.71, 0.39, 0.52, 0.26, 0.64, 0.19, 0.86, 0.41, 0.73, 0.32, 0.57\\}$.\n\n- Case $3$: $N=4$, initial configuration $1111$, $M=5$, random numbers\n  $\\{0.24, 0.68, 0.35, 0.79, 0.22, 0.61, 0.48, 0.84, 0.17, 0.69, 0.53, 0.91, 0.28, 0.75, 0.46\\}$.\n\nOutput specification. Your program must:\n- Implement the algorithm and perform the simulations exactly as specified for the three cases.\n- For each case, output two values in order: the total simulated time after $M$ events expressed in nanoseconds (that is, seconds multiplied by $10^{9}$) rounded to three decimal places, and a boolean indicating whether the locality verification passed at every step.\n- Produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of cases $1$, $2$, and $3$. The final output format must be exactly: $[t_1,\\mathrm{local}_1,t_2,\\mathrm{local}_2,t_3,\\mathrm{local}_3]$, where each $t_j$ is a decimal number in nanoseconds rounded to three decimal places and each $\\mathrm{local}_j$ is either $\\mathrm{True}$ or $\\mathrm{False}$.", "solution": "The problem is valid. It presents a clear, scientifically grounded, and well-posed task in computational materials science, specifically the implementation of a Kinetic Monte Carlo (KMC) simulation using a residence-time algorithm with an efficient event catalog.\n\n### Theoretical Justification of Locality\n\nThe assertion that a single-site flip event affects only a neighborhood of bounded size is a direct consequence of the local nature of the interactions defined in the model. The evolution of the system is governed by a set of transition rates, where the rate of a flip at a specific site $i$ depends only on the state of that site and its immediate environment.\n\nLet the state of the system be the configuration of all occupation variables, $S = \\{s_0, s_1, \\dots, s_{N-1}\\}$. The rate of a potential event (a flip) at site $i$ is denoted by $r_i$ and is a function of the local configuration. Specifically, the problem defines the rate at site $i$ to be dependent on its own state $s_i$ and the number of occupied nearest neighbors, $n_i$. For a one-dimensional lattice with interaction range $r=1$, the neighbors of site $i$ are at indices $(i-1) \\pmod N$ and $(i+1) \\pmod N$. The number of occupied neighbors is therefore $n_i = s_{(i-1) \\pmod N} + s_{(i+1) \\pmod N}$. The rate $r_i$ is thus a function $f(s_i, s_{(i-1) \\pmod N}, s_{(i+1) \\pmod N})$.\n\nAn event catalog groups sites into classes based on their local configuration. The class of site $i$ is defined by the pair $(s_i, n_i)$. Consequently, the class of site $i$ is determined by the states of the sites in the set $\\mathcal{N}_i = \\{i, (i-1) \\pmod N, (i+1) \\pmod N\\}$.\n\nNow, consider an event: a flip at a chosen site $j$. This means the state variable $s_j$ changes, $s_j \\rightarrow 1-s_j$. We examine which sites can experience a change in their class as a result of this single flip.\n\n1.  **Site $j$ (the flipped site):** Its state $s_j$ changes by definition. Its neighbor count $n_j = s_{(j-1) \\pmod N} + s_{(j+1) \\pmod N}$ depends on its neighbors, whose states have not changed. Thus, the pair $(s_j, n_j)$ changes, and site $j$ must change its class.\n\n2.  **Neighbor of $j$, site $k=(j-1) \\pmod N$:** Its state $s_k$ remains unchanged. Its neighbor count is $n_k = s_{(k-1) \\pmod N} + s_{(k+1) \\pmod N} = s_{(j-2) \\pmod N} + s_j$. Since $s_j$ has changed, $n_k$ may also change. Therefore, the class of site $k=(j-1) \\pmod N$ may change.\n\n3.  **Neighbor of $j$, site $l=(j+1) \\pmod N$:** Its state $s_l$ remains unchanged. Its neighbor count is $n_l = s_{(l-1) \\pmod N} + s_{(l+1) \\pmod N} = s_j + s_{(j+2) \\pmod N}$. Since $s_j$ has changed, $n_l$ may also change. Therefore, the class of site $l=(j+1) \\pmod N$ may change.\n\n4.  **Any other site $m \\notin \\{j, (j-1)\\pmod N, (j+1)\\pmod N\\}$:** Its state $s_m$ is unchanged. Its neighbor count is $n_m = s_{(m-1) \\pmod N} + s_{(m+1) \\pmod N}$. Since site $m$ and its neighbors are all distinct from site $j$, the states $s_m$, $s_{(m-1) \\pmod N}$, and $s_{(m+1) \\pmod N}$ are all unaffected by the flip at $j$. Thus, neither $s_m$ nor $n_m$ changes, and the class of site $m$ remains the same.\n\nIn summary, the only sites whose class membership can possibly change are the flipped site itself ($j$) and its nearest neighbors ($(j-1)\\pmod N$ and $(j+1)\\pmod N$). This set of potentially affected sites has a size of $1+z = 1+2 = 3$, where $z=2$ is the coordination number. This size is a small constant, independent of the total number of sites $N$. This locality principle is fundamental to the efficiency of KMC algorithms for systems with short-range interactions.\n\n### Algorithm Design for $O(1)$ Update\n\nTo achieve an amortized time complexity of $O(1)$ per event for a system with a constant number of classes $K$, we must design data structures that support event selection and state updates in constant time.\n\n**1. Data Structures**\n\nThe core of the algorithm involves maintaining a real-time catalog of all possible events.\n- **`state[i]`**: An array of size $N$ storing the binary occupation variable $s_i$ for each site $i$.\n- **`class_rates[k]`**: An array of size $K=6$ storing the pre-calculated per-site rate $r_k$ for each class $k$. The class index $k$ can be mapped from $(s,n)$ via $k = s \\cdot (z+1) + n = 3s+n$. These rates are constant throughout the simulation.\n- **`class_pops[k]`**: An array of size $K$ storing the current population $N_k$ of each class.\n- **`total_rate`**: A scalar variable storing the total rate $R = \\sum_{k=0}^{K-1} N_k r_k$.\n- **`class_members[k]`**: An array of lists (or dynamic arrays), where `class_members[k]` contains the indices of all sites currently belonging to class $k$. This allows for uniform random selection of a site within a class.\n- **`site_to_class[i]`**: An array of size $N$ where `site_to_class[i]` stores the current class index $k$ of site $i$.\n- **`site_to_pos_in_class[i]`**: An array of size $N$. This is the crucial structure for $O(1)$ updates. `site_to_pos_in_class[i]` stores the index (position) of site $i$ within the list `class_members[site_to_class[i]]`. That is, `class_members[site_to_class[i]][site_to_pos_in_class[i]] == i`.\n\n**2. Initialization**\n\n1.  Initialize the `state` array from the given initial configuration.\n2.  Calculate the $K=6$ per-site rates $r_k$ using the given Arrhenius expressions and store them in `class_rates`.\n3.  Initialize `class_pops` to zeros and `class_members` to $K$ empty lists.\n4.  Iterate through each site $i \\in \\{0, \\dots, N-1\\}$:\n    a. Determine its initial class $k$ by calculating $n_i$ and using $k=3s_i+n_i$.\n    b. Add the site to its class: append $i$ to `class_members[k]`, set `site_to_class[i]=k`, set `site_to_pos_in_class[i]` to the new last index in `class_members[k]`, and increment `class_pops[k]`.\n5.  Calculate the initial `total_rate` $R = \\sum_{k} \\text{class\\_pops}[k] \\cdot \\text{class\\_rates}[k]$.\n\n**3. Simulation Step (Single Event)**\n\n1.  **Event Selection**:\n    a. Generate a uniform random number $u_{\\mathrm{class}} \\in (0,1)$.\n    b. Select a class $k_{sel}$ with probability proportional to the total rate of that class, $N_k r_k$. This is done by finding the smallest $k_{sel}$ such that $\\sum_{j=0}^{k_{sel}} N_j r_j > u_{\\mathrm{class}} \\cdot R$. Since $K$ is a small constant, this linear scan takes $O(K) = O(1)$ time.\n    c. Generate a uniform random number $u_{\\mathrm{site}} \\in (0,1)$.\n    d. Select a site to flip, $i_{flip}$, by choosing a random element from the list `class_members[k_{sel}]`. The index is $\\lfloor u_{\\mathrm{site}} \\cdot N_{k_{sel}} \\rfloor$. This is an $O(1)$ operation.\n\n2.  **Time Advancement**:\n    a. Generate a uniform random number $u_{\\mathrm{time}} \\in (0,1)$.\n    b. Advance simulation time by $\\Delta t = -\\ln(u_{\\mathrm{time}}) / R$.\n\n3.  **State and Catalog Update**:\n    a. Flip the state of the chosen site: $s_{i_{flip}} \\rightarrow 1 - s_{i_{flip}}$.\n    b. Identify the set of affected sites: $\\mathcal{A} = \\{ (i_{flip}-1)\\pmod N, i_{flip}, (i_{flip}+1)\\pmod N \\}$.\n    c. For each site $j \\in \\mathcal{A}$:\n        i.  Retrieve its old class, $k_{old} = \\text{site\\_to\\_class}[j]$.\n        ii. Recalculate its local environment to find its new class, $k_{new}$.\n        iii. If $k_{new} \\neq k_{old}$:\n            - **Update Total Rate**: $R \\leftarrow R - r_{k_{old}} + r_{k_{new}}$.\n            - **Remove from old class**: This must be an $O(1)$ operation.\n                - Get the site's current position in its class list: $p_j = \\text{site\\_to\\_pos\\_in\\_class}[j]$.\n                - Let $i_{last}$ be the last site in `class_members[k_{old}]`.\n                - Move $i_{last}$ to position $p_j$: `class_members[k_{old}][p_j] = i_{last}`.\n                - Update the position of the moved site: `site_to_pos_in_class[i_{last}] = p_j`.\n                - Remove the last element from `class_members[k_{old}]`.\n                - Decrement `class_pops[k_{old}]`.\n            - **Add to new class**: This is an $O(1)$ operation.\n                - Append $j$ to `class_members[k_{new}]`.\n                - Update `site_to_class[j] = k_{new}`.\n                - Update `site_to_pos_in_class[j]` to the new last index.\n                - Increment `class_pops[k_{new}]`.\n\nSince the size of the affected set $\\mathcal{A}$ is constant ($3$), and each site update takes $O(1)$ time due to the direct addressing provided by `site_to_pos_in_class`, the total update time per event is $O(1)$. The entire simulation step is therefore $O(1)$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulations for all test cases and print the results.\n    \"\"\"\n\n    class KMCSimulator:\n        \"\"\"\n        Implements the residence-time algorithm with an efficient event catalog.\n        \"\"\"\n        def __init__(self, N, initial_config_str, params):\n            self.N = N\n            self.state = np.array([int(c) for c in initial_config_str], dtype=np.int8)\n            self.params = params\n            \n            # Constants\n            self.K = 6  # Number of classes\n            self.z = 2  # Coordination number\n            \n            # Data structures for catalog\n            self.class_rates = np.zeros(self.K, dtype=np.float64)\n            self.class_pops = np.zeros(self.K, dtype=np.int32)\n            self.class_members = [[] for _ in range(self.K)]\n            self.site_to_class = np.full(self.N, -1, dtype=np.int32)\n            self.site_to_pos_in_class = np.full(self.N, -1, dtype=np.int32)\n            self.total_rate = 0.0\n\n            self._precompute_rates()\n            self._initialize_catalog()\n\n        def _precompute_rates(self):\n            nu = self.params['nu']\n            E_ads = self.params['E_ads']\n            E_des = self.params['E_des']\n            epsilon = self.params['epsilon']\n            kBT = self.params['k_B'] * self.params['T']\n            \n            # Classes s=0 (adsorption)\n            for n in range(3):\n                k = 3 * 0 + n\n                E_A = E_ads - n * epsilon\n                self.class_rates[k] = nu * np.exp(-E_A / kBT)\n            \n            # Classes s=1 (desorption)\n            for n in range(3):\n                k = 3 * 1 + n\n                E_A = E_des + n * epsilon\n                self.class_rates[k] = nu * np.exp(-E_A / kBT)\n\n        def _get_class_of_site(self, i):\n            s_i = self.state[i]\n            n_i = self.state[(i - 1) % self.N] + self.state[(i + 1) % self.N]\n            return 3 * s_i + n_i\n\n        def _add_site_to_class(self, site_idx, class_idx):\n            self.class_members[class_idx].append(site_idx)\n            pos = len(self.class_members[class_idx]) - 1\n            self.site_to_class[site_idx] = class_idx\n            self.site_to_pos_in_class[site_idx] = pos\n            self.class_pops[class_idx] += 1\n        \n        def _remove_site_from_class(self, site_idx, class_idx):\n            pos = self.site_to_pos_in_class[site_idx]\n            last_site_in_class = self.class_members[class_idx][-1]\n            \n            # Swap with last element for O(1) removal\n            self.class_members[class_idx][pos] = last_site_in_class\n            self.site_to_pos_in_class[last_site_in_class] = pos\n            \n            self.class_members[class_idx].pop()\n            self.class_pops[class_idx] -= 1\n\n        def _initialize_catalog(self):\n            for i in range(self.N):\n                k = self._get_class_of_site(i)\n                self._add_site_to_class(i, k)\n            \n            self.total_rate = np.dot(self.class_pops, self.class_rates)\n\n        def _update_site_and_neighbors(self, site_idx):\n            affected_sites = {(site_idx - 1) % self.N, site_idx, (site_idx + 1) % self.N}\n            \n            for i in sorted(list(affected_sites)): # Sorting for determinism, though not strictly required by logic\n                old_class = self.site_to_class[i]\n                new_class = self._get_class_of_site(i)\n\n                if old_class != new_class:\n                    # Update total rate\n                    self.total_rate -= self.class_rates[old_class]\n                    self.total_rate += self.class_rates[new_class]\n                    \n                    # Move site between classes\n                    self._remove_site_from_class(i, old_class)\n                    self._add_site_to_class(i, new_class)\n\n        def run_simulation(self, M, random_numbers):\n            total_time = 0.0\n            locality_verification_passed = True\n            rng_iterator = iter(random_numbers)\n\n            for step in range(M):\n                if self.total_rate == 0.0:\n                    break\n                \n                # --- Locality Verification (pre-flip) ---\n                if locality_verification_passed:\n                    old_classes_full = np.array([self._get_class_of_site(i) for i in range(self.N)])\n                \n                # --- Step 1: Select class ---\n                u_class = next(rng_iterator)\n                rand_val = u_class * self.total_rate\n                \n                partial_rate_sum = 0.0\n                selected_class = -1\n                for k in range(self.K):\n                    partial_rate_sum += self.class_pops[k] * self.class_rates[k]\n                    if rand_val = partial_rate_sum:\n                        selected_class = k\n                        break\n                \n                # --- Step 2: Select site ---\n                u_site = next(rng_iterator)\n                num_sites_in_class = self.class_pops[selected_class]\n                selected_pos = int(u_site * num_sites_in_class)\n                site_to_flip = self.class_members[selected_class][selected_pos]\n                \n                # --- Step 3: Advance time ---\n                u_time = next(rng_iterator)\n                dt = -np.log(u_time) / self.total_rate\n                total_time += dt\n\n                # --- Step 4: Execute event and update ---\n                self.state[site_to_flip] = 1 - self.state[site_to_flip]\n                self._update_site_and_neighbors(site_to_flip)\n\n                # --- Locality Verification (post-flip) ---\n                if locality_verification_passed:\n                    new_classes_full = np.array([self._get_class_of_site(i) for i in range(self.N)])\n                    changed_sites = {i for i, (old, new) in enumerate(zip(old_classes_full, new_classes_full)) if old != new}\n                    expected_affected = {(site_to_flip - 1) % self.N, site_to_flip, (site_to_flip + 1) % self.N}\n                    if not changed_sites.issubset(expected_affected):\n                        locality_verification_passed = False\n\n            return total_time, locality_verification_passed\n\n    # Fixed parameters for all simulations\n    params = {\n        'T': 500.0,\n        'k_B': 8.617333262145e-5,\n        'nu': 1e13,\n        'E_ads': 0.35,\n        'E_des': 0.45,\n        'epsilon': 0.05,\n    }\n\n    # Test suite\n    test_cases = [\n        {\n            \"N\": 10,\n            \"initial_config\": \"0101101001\",\n            \"M\": 8,\n            \"random_numbers\": [0.13, 0.77, 0.42, 0.91, 0.05, 0.33, 0.68, 0.27, 0.88, 0.12, 0.56, 0.74, 0.21, 0.93, 0.49, 0.36, 0.59, 0.18, 0.81, 0.07, 0.66, 0.25, 0.97, 0.44]\n        },\n        {\n            \"N\": 6,\n            \"initial_config\": \"000000\",\n            \"M\": 6,\n            \"random_numbers\": [0.11, 0.62, 0.58, 0.47, 0.29, 0.83, 0.14, 0.71, 0.39, 0.52, 0.26, 0.64, 0.19, 0.86, 0.41, 0.73, 0.32, 0.57]\n        },\n        {\n            \"N\": 4,\n            \"initial_config\": \"1111\",\n            \"M\": 5,\n            \"random_numbers\": [0.24, 0.68, 0.35, 0.79, 0.22, 0.61, 0.48, 0.84, 0.17, 0.69, 0.53, 0.91, 0.28, 0.75, 0.46]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        sim = KMCSimulator(case[\"N\"], case[\"initial_config\"], params)\n        total_time_s, locality_ok = sim.run_simulation(case[\"M\"], case[\"random_numbers\"])\n        total_time_ns = total_time_s * 1e9\n        results.append((total_time_ns, locality_ok))\n    \n    # Format and print the final output string\n    output_parts = []\n    for t, loc in results:\n        output_parts.append(f\"{t:.3f}\")\n        output_parts.append(str(loc))\n        \n    print(f\"[{','.join(output_parts)}]\")\n\nsolve()\n```", "id": "3450027"}, {"introduction": "The predictive power of a residence-time algorithm depends critically on the accuracy of its event catalog. However, the rates in this catalog are often computed from separate, finite-size simulations, which can introduce systematic biases due to artificial boundary effects. This exercise [@problem_id:3449946] demonstrates how to model, quantify, and correct for these finite-size artifacts, allowing you to extrapolate measured rates $k_i(L)$ to their true bulk values $k_i(\\infty)$ and ensuring your simulation accurately reflects macroscopic kinetics.", "problem": "Consider a one-dimensional slab of length $L$ used to construct an event catalog for Kinetic Monte Carlo (KMC) simulations in computational materials science. Each elementary event type $i$ has a position-dependent local propensity $r_i(x)$ due to boundary effects. The event catalog uses finite-size measurements to estimate event rates, which induces a bias for events whose activation environments are perturbed near boundaries. Let the boundary layer width for event $i$ be $\\ell_i$ (with $\\ell_i \\ll L$), and suppose the local propensity is spatially uniform in the interior and altered within the boundary layers. Define the finite-size measured rate $k_i(L)$ for event $i$ as the spatial average of $r_i(x)$ over the slab:\n$$\nk_i(L) = \\frac{1}{L} \\int_0^L r_i(x)\\, dx.\n$$\nAssume a two-region model with a small curvature correction:\n- In the interior region $x \\in [\\ell_i, L - \\ell_i]$, the local propensity equals its bulk value $k_i(\\infty)$, which is independent of $L$.\n- In the boundary layers $x \\in [0, \\ell_i] \\cup [L - \\ell_i, L]$, the local propensity equals $k_i^{\\text{edge}}$.\n- The finite-size measurement includes a weak second-order correction $b_i/L^2$ due to catalog construction artifacts.\n\nUnder these assumptions, the finite-size rate for event $i$ is modeled as\n$$\nk_i(L) = \\left(1 - \\frac{2\\ell_i}{L}\\right) k_i(\\infty) + \\frac{2\\ell_i}{L} k_i^{\\text{edge}} + \\frac{b_i}{L^2},\n$$\nwith $\\ell_i  L/2$ so the interior exists. Your task is to:\n1. Starting from the above definitions and model, derive the leading-order finite-size bias scaling for boundary-affected events:\n$$\n\\left|k_i(L) - k_i(\\infty)\\right| \\sim \\frac{c_i}{L},\n$$\nand identify $c_i$ in terms of $\\ell_i$, $k_i(\\infty)$, and $k_i^{\\text{edge}}$.\n2. Propose and justify a corrective transformation for the residence-time algorithm that restores bulk kinetics. The residence-time algorithm samples the waiting time as\n$$\n\\Delta t = -\\frac{\\ln u}{\\sum_j k_j(L)},\n$$\nwhere $u \\in (0,1)$ is a uniform random number and the sum runs over all event types $j$ in the catalog. Provide a corrected expression that replaces $\\sum_j k_j(L)$ by a bulk-consistent rate sum, using only quantities accessible from the finite-size model (i.e., $k_j(L)$, $k_j^{\\text{edge}}$, $\\ell_j$, and $b_j$), under the constraint that $k_j(\\infty)$ is not directly measured but must be estimated from the model. The corrected expression must have the form\n$$\n\\Delta t_{\\text{corr}} = -\\frac{\\ln u}{\\sum_j \\widehat{k}_j(\\infty)},\n$$\nand must be explicitly computable from the given parameters.\n\nImplement a program that, for each specified test case, computes:\n- The scaled finite-size bias vector $\\left[L\\cdot\\left|k_i(L) - k_i(\\infty)\\right|\\right]_i$ for all events $i$ in the case.\n- The uncorrected residence time $\\Delta t$ in seconds.\n- The corrected residence time $\\Delta t_{\\text{corr}}$ in seconds using your proposed correction.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a nested list of the form\n$$\n\\left[\\left[L\\cdot\\left|k_i(L) - k_i(\\infty)\\right|\\right]_i,\\ \\Delta t,\\ \\Delta t_{\\text{corr}}\\right].\n$$\n\nUse the following test suite (all rates are in $\\text{s}^{-1}$, lengths are in arbitrary units consistent across parameters, and times must be expressed in seconds as plain floating-point numbers without unit symbols):\n\n- Test case 1 (general happy path):\n  - $L = 100$, $u =  \\exp(-1)$,\n  - Events $i = 1,2,3$ with parameters:\n    - $k_1(\\infty) = 1.0$, $k_1^{\\text{edge}} = 0.8$, $\\ell_1 = 2.0$, $b_1 = 0.0$,\n    - $k_2(\\infty) = 0.5$, $k_2^{\\text{edge}} = 0.6$, $\\ell_2 = 1.0$, $b_2 = 0.0$,\n    - $k_3(\\infty) = 2.0$, $k_3^{\\text{edge}} = 1.7$, $\\ell_3 = 3.0$, $b_3 = 0.0$.\n\n- Test case 2 (strong boundary influence, small system):\n  - $L = 10$, $u = 0.5$,\n  - Events $i = 1,2$ with parameters:\n    - $k_1(\\infty) = 3.0$, $k_1^{\\text{edge}} = 2.0$, $\\ell_1 = 2.0$, $b_1 = 0.1$,\n    - $k_2(\\infty) = 1.5$, $k_2^{\\text{edge}} = 2.5$, $\\ell_2 = 3.0$, $b_2 = -0.2$.\n\n- Test case 3 (near-bulk limit, very large system):\n  - $L = 10000$, $u = 0.9$,\n  - Events $i = 1,2$ with parameters:\n    - $k_1(\\infty) = 0.1$, $k_1^{\\text{edge}} = 0.1$, $\\ell_1 = 1.0$, $b_1 = 10^{-4}$,\n    - $k_2(\\infty) = 10.0$, $k_2^{\\text{edge}} = 9.5$, $\\ell_2 = 5.0$, $b_2 = -5\\times 10^{-4}$.\n\nFor each test case:\n- Compute $k_i(L)$ using the specified model.\n- Compute $c_i$ and the vector $\\left[L\\cdot\\left|k_i(L) - k_i(\\infty)\\right|\\right]_i$.\n- Compute $\\Delta t$ using $\\sum_j k_j(L)$.\n- Compute $\\widehat{k}_j(\\infty)$ from the model by algebraically eliminating $k_j(\\infty)$:\n$$\n\\widehat{k}_j(\\infty) = \\frac{k_j(L) - \\left(\\frac{2\\ell_j}{L}\\right) k_j^{\\text{edge}} - \\frac{b_j}{L^2}}{1 - \\frac{2\\ell_j}{L}},\n$$\nand then compute $\\Delta t_{\\text{corr}}$ using $\\sum_j \\widehat{k}_j(\\infty)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with one nested list per test case, each nested list containing:\n- a list of floats for the scaled biases in the order of events,\n- the uncorrected $\\Delta t$ as a float in seconds,\n- the corrected $\\Delta t_{\\text{corr}}$ as a float in seconds.\n\nFor example, the output should look like\n$[\\,[\\,[s_{1}, s_{2}, \\dots], \\Delta t_1, \\Delta t_{\\text{corr},1}], \\,[\\,[\\dots], \\Delta t_2, \\Delta t_{\\text{corr},2}], \\,[\\,[\\dots], \\Delta t_3, \\Delta t_{\\text{corr},3}]\\,]$,\nwhere each $s_i$ is $L\\cdot\\left|k_i(L) - k_i(\\infty)\\right|$ for the corresponding event. The final printed numbers must be plain floats without units, aggregated into exactly one line as specified.", "solution": "The problem statement is evaluated for validity prior to attempting a solution.\n\n### Step 1: Extract Givens\n- **Slab geometry**: One-dimensional slab of length $L$.\n- **Event type $i$**: Characterized by a position-dependent local propensity $r_i(x)$.\n- **Boundary layer width**: $\\ell_i$, with $\\ell_i \\ll L$ and specifically $\\ell_i  L/2$.\n- **Finite-size measured rate $k_i(L)$**:\n$$k_i(L) = \\frac{1}{L} \\int_0^L r_i(x)\\, dx.$$\n- **Two-region propensity model**:\n  - Interior ($x \\in [\\ell_i, L - \\ell_i]$): $r_i(x) = k_i(\\infty)$ (bulk rate).\n  - Boundary layers ($x \\in [0, \\ell_i] \\cup [L - \\ell_i, L]$): $r_i(x) = k_i^{\\text{edge}}$ (edge rate).\n- **Model for finite-size rate $k_i(L)$**:\n$$k_i(L) = \\left(1 - \\frac{2\\ell_i}{L}\\right) k_i(\\infty) + \\frac{2\\ell_i}{L} k_i^{\\text{edge}} + \\frac{b_i}{L^2}.$$\n- **Task 1**: Derive the leading-order finite-size bias scaling $|k_i(L) - k_i(\\infty)| \\sim \\frac{c_i}{L}$ and identify $c_i$.\n- **Task 2**: Propose a corrective transformation for the residence-time algorithm.\n- **Residence-time algorithm (uncorrected)**:\n$$\n\\Delta t = -\\frac{\\ln u}{\\sum_j k_j(L)},\n$$\nwhere $u \\in (0,1)$ is a uniform random number.\n- **Corrected residence-time form**:\n$$\\Delta t_{\\text{corr}} = -\\frac{\\ln u}{\\sum_j \\widehat{k}_j(\\infty)}.$$\n- **Estimator for bulk rate**:\n$$\\widehat{k}_j(\\infty) = \\frac{k_j(L) - \\left(\\frac{2\\ell_j}{L}\\right) k_j^{\\text{edge}} - \\frac{b_j}{L^2}}{1 - \\frac{2\\ell_j}{L}}.$$\n- **Test Cases**: Three specific sets of parameters ($L$, $u$, and event data $\\{k_i(\\infty), k_i^{\\text{edge}}, \\ell_i, b_i\\}$) are provided for implementation.\n- **Output Requirements**: For each test case, compute and output a nested list containing:\n  1. A vector of scaled finite-size biases, $[L \\cdot |k_i(L) - k_i(\\infty)|]_i$.\n  2. The uncorrected residence time, $\\Delta t$.\n  3. The corrected residence time, $\\Delta t_{\\text{corr}}$.\nThe final output must be a single line, formatted as a list of these nested lists.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is rooted in standard practices and known challenges in computational materials science, specifically Kinetic Monte Carlo (KMC) simulations. The concept of finite-size effects, boundary-perturbed rates, and their $1/L$ scaling is a fundamental topic in the field. The residence-time algorithm is the standard method for advancing time in KMC. The model provided is a well-established first-order approximation for such systems.\n- **Well-Posed**: The problem is clearly defined. It asks for a specific derivation and a computational implementation based on explicit formulas and parameters. The derivation is straightforward algebraic manipulation. The computational task is supplied with all necessary data in the test cases, and the expected output format is unambiguously specified. The constraint $\\ell_i  L/2$ is satisfied for all test cases, ensuring the model's physical interpretation holds.\n- **Objective**: The problem is stated in precise, formal, and objective language, free of ambiguity or subjective content.\n- **Other Flaws**: The problem does not exhibit any of the enumerated flaws. It is scientifically sound, formalizable, complete, and computationally feasible. The solution is unique and meaningful within the context of the provided model.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be provided.\n\n### Solution\nThe solution is presented in two parts as requested: a theoretical derivation followed by the justification for the corrective algorithm.\n\n**Part 1: Derivation of Finite-Size Bias Scaling**\n\nThe finite-size bias for event type $i$ is the difference between the finite-size measured rate $k_i(L)$ and the true bulk rate $k_i(\\infty)$. We start with the given model for $k_i(L)$:\n$$k_i(L) = \\left(1 - \\frac{2\\ell_i}{L}\\right) k_i(\\infty) + \\frac{2\\ell_i}{L} k_i^{\\text{edge}} + \\frac{b_i}{L^2}$$\nTo find the bias, we subtract $k_i(\\infty)$ from both sides:\n$$k_i(L) - k_i(\\infty) = \\left(1 - \\frac{2\\ell_i}{L}\\right) k_i(\\infty) - k_i(\\infty) + \\frac{2\\ell_i}{L} k_i^{\\text{edge}} + \\frac{b_i}{L^2}$$\nExpanding the first term on the right-hand side gives:\n$$k_i(L) - k_i(\\infty) = k_i(\\infty) - \\frac{2\\ell_i}{L} k_i(\\infty) - k_i(\\infty) + \\frac{2\\ell_i}{L} k_i^{\\text{edge}} + \\frac{b_i}{L^2}$$\nThe $k_i(\\infty)$ terms cancel, leaving:\n$$k_i(L) - k_i(\\infty) = -\\frac{2\\ell_i}{L} k_i(\\infty) + \\frac{2\\ell_i}{L} k_i^{\\text{edge}} + \\frac{b_i}{L^2}$$\nFactoring out the $1/L$ term:\n$$k_i(L) - k_i(\\infty) = \\frac{2\\ell_i}{L} \\left( k_i^{\\text{edge}} - k_i(\\infty) \\right) + \\frac{b_i}{L^2}$$\nThe leading-order behavior is the term that decays most slowly as $L \\to \\infty$. In this expression, the first term is of order $\\mathcal{O}(1/L)$ and the second is of order $\\mathcal{O}(1/L^2)$. For large $L$, the $\\mathcal{O}(1/L)$ term dominates. Thus, the leading-order scaling is:\n$$k_i(L) - k_i(\\infty) \\approx \\frac{2\\ell_i \\left( k_i^{\\text{edge}} - k_i(\\infty) \\right)}{L}$$\nThe problem asks for the scaling of the absolute difference, $|k_i(L) - k_i(\\infty)| \\sim c_i/L$. From the above approximation, we can identify $c_i$:\n$$|k_i(L) - k_i(\\infty)| \\approx \\left| \\frac{2\\ell_i \\left( k_i^{\\text{edge}} - k_i(\\infty) \\right)}{L} \\right| = \\frac{1}{L} \\cdot 2\\ell_i |k_i^{\\text{edge}} - k_i(\\infty)|$$\nTherefore, the scaling constant $c_i$ is:\n$$c_i = 2\\ell_i \\left| k_i^{\\text{edge}} - k_i(\\infty) \\right|$$\n\n**Part 2: Corrective Transformation for the Residence-Time Algorithm**\n\nThe standard KMC residence-time (or waiting time) $\\Delta t$ is calculated from the total rate of all possible events, $K_{\\text{total}} = \\sum_j k_j$. In a finite system with boundary effects, using the finite-size rates $k_j(L)$ leads to a biased total rate, $K_{\\text{total}}(L) = \\sum_j k_j(L)$, and consequently a biased time step $\\Delta t = -(\\ln u) / K_{\\text{total}}(L)$.\n\nTo restore bulk kinetics, we must replace the biased total rate $K_{\\text{total}}(L)$ with the true bulk total rate, $K_{\\text{total}}(\\infty) = \\sum_j k_j(\\infty)$. However, the problem specifies that the bulk rates $k_j(\\infty)$ are unknown and must be estimated from the model using measurable quantities. The proposed corrective transformation is to compute an estimator, $\\widehat{k}_j(\\infty)$, for each event rate $k_j(\\infty)$.\n\nThe problem provides the formula for this estimator. We can justify it by algebraically inverting the model for $k_j(L)$ to solve for $k_j(\\infty)$:\n$$k_j(L) = \\left(1 - \\frac{2\\ell_j}{L}\\right) k_j(\\infty) + \\frac{2\\ell_j}{L} k_j^{\\text{edge}} + \\frac{b_j}{L^2}$$\nIsolating the term containing $k_j(\\infty)$:\n$$k_j(L) - \\frac{2\\ell_j}{L} k_j^{\\text{edge}} - \\frac{b_j}{L^2} = \\left(1 - \\frac{2\\ell_j}{L}\\right) k_j(\\infty)$$\nDividing by the coefficient of $k_j(\\infty)$ yields the expression for $k_j(\\infty)$ in terms of the other parameters. This expression is precisely the proposed estimator $\\widehat{k}_j(\\infty)$:\n$$\\widehat{k}_j(\\infty) = \\frac{k_j(L) - \\left(\\frac{2\\ell_j}{L}\\right) k_j^{\\text{edge}} - \\frac{b_j}{L^2}}{1 - \\frac{2\\ell_j}{L}}$$\nThis calculation demonstrates that $\\widehat{k}_j(\\infty)$ is the value for the bulk rate that is perfectly consistent with the finite-size model and the measured rate $k_j(L)$. Assuming the model is an exact description of the system, this procedure perfectly recovers the true bulk rate, i.e., $\\widehat{k}_j(\\infty) = k_j(\\infty)$.\n\nThe corrected total rate is the sum of these estimators, $\\sum_j \\widehat{k}_j(\\infty)$. The corrected residence time, which restores bulk kinetics, is therefore given by:\n$$\\Delta t_{\\text{corr}} = -\\frac{\\ln u}{\\sum_j \\widehat{k}_j(\\infty)}$$\nThis approach systematically removes the finite-size biases from the KMC time step calculation. The implementation will involve first calculating $k_j(L)$ from the given bulk parameters, and then using that result to calculate $\\widehat{k}_j(\\infty)$ as a procedural verification of the correction scheme.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational materials science problem for all test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"L\": 100.0,\n            \"u\": np.exp(-1),\n            \"events\": [\n                {\"k_inf\": 1.0, \"k_edge\": 0.8, \"ell\": 2.0, \"b\": 0.0},\n                {\"k_inf\": 0.5, \"k_edge\": 0.6, \"ell\": 1.0, \"b\": 0.0},\n                {\"k_inf\": 2.0, \"k_edge\": 1.7, \"ell\": 3.0, \"b\": 0.0},\n            ]\n        },\n        {\n            \"L\": 10.0,\n            \"u\": 0.5,\n            \"events\": [\n                {\"k_inf\": 3.0, \"k_edge\": 2.0, \"ell\": 2.0, \"b\": 0.1},\n                {\"k_inf\": 1.5, \"k_edge\": 2.5, \"ell\": 3.0, \"b\": -0.2},\n            ]\n        },\n        {\n            \"L\": 10000.0,\n            \"u\": 0.9,\n            \"events\": [\n                {\"k_inf\": 0.1, \"k_edge\": 0.1, \"ell\": 1.0, \"b\": 1e-4},\n                {\"k_inf\": 10.0, \"k_edge\": 9.5, \"ell\": 5.0, \"b\": -5e-4},\n            ]\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        L = case[\"L\"]\n        u = case[\"u\"]\n        events = case[\"events\"]\n        \n        scaled_biases = []\n        k_L_values = []\n        k_hat_inf_values = []\n        k_inf_values = []\n\n        for event in events:\n            k_inf = event[\"k_inf\"]\n            k_edge = event[\"k_edge\"]\n            ell = event[\"ell\"]\n            b = event[\"b\"]\n            \n            # Compute k_i(L) using the specified model.\n            k_L = (1 - 2 * ell / L) * k_inf + (2 * ell / L) * k_edge + b / L**2\n            k_L_values.append(k_L)\n            \n            # Compute the scaled finite-size bias vector.\n            scaled_bias = L * abs(k_L - k_inf)\n            scaled_biases.append(scaled_bias)\n\n            # Compute the estimated bulk rate k_hat_inf.\n            # This demonstrates the inversion of the model.\n            numerator = k_L - (2 * ell / L) * k_edge - b / L**2\n            denominator = 1 - 2 * ell / L\n            k_hat_inf = numerator / denominator if denominator != 0 else 0\n            k_hat_inf_values.append(k_hat_inf)\n            \n            # Store original k_inf for comparison and for the corrected sum.\n            k_inf_values.append(k_inf)\n\n        # Calculate total rates\n        sum_k_L = sum(k_L_values)\n        sum_k_hat_inf = sum(k_hat_inf_values)\n        \n        # Calculate uncorrected and corrected residence times\n        log_u = np.log(u)\n        delta_t = -log_u / sum_k_L if sum_k_L != 0 else float('inf')\n        delta_t_corr = -log_u / sum_k_hat_inf if sum_k_hat_inf != 0 else float('inf')\n\n        # Since k_hat_inf must equal k_inf if the model is exact, we can verify this.\n        # For calculation, using sum(k_inf_values) is numerically equivalent and\n        # more direct, but we follow the explicit instruction to sum the computed k_hat_inf.\n        # assert np.isclose(sum_k_hat_inf, sum(k_inf_values))\n\n        case_results = [scaled_biases, delta_t, delta_t_corr]\n        all_results.append(case_results)\n\n    def format_nested_list_to_string(lst):\n        \"\"\"Recursively formats a nested list into a string without spaces.\"\"\"\n        if isinstance(lst, list):\n            return f\"[{','.join(map(format_nested_list_to_string, lst))}]\"\n        else:\n            return repr(lst)\n\n    # Final print statement in the exact required format.\n    print(format_nested_list_to_string(all_results))\n\nsolve()\n```", "id": "3449946"}, {"introduction": "While lattice models offer a structured way to classify local environments, off-lattice systems like amorphous materials or complex molecular structures require a more general approach. The fundamental challenge is to create a unique identifier—a canonical key—for a local atomic configuration that is invariant to arbitrary translations, rotations, and particle relabeling. This advanced practice [@problem_id:3450014] tasks you with constructing such a key from fundamental geometric invariants, a crucial technique for extending event-catalog-based methods beyond the confines of a regular grid.", "problem": "You are given sets of three-dimensional atomic positions and asked to implement a canonicalization algorithm for off-lattice Kinetic Monte Carlo (KMC) event catalog construction. The algorithm must produce a local graph key that is invariant under any rigid motion (translation, rotation, or reflection) and then use that key to compute a residence time via the Residence-Time Algorithm (RTA). You must derive the algorithm from first principles of Euclidean geometry and stochastic process fundamentals, and implement it as a complete, runnable program.\n\nStart from the following foundational bases:\n- Euclidean isometries preserve pairwise distances and inner products, specifically, if $\\mathbf{R}$ is an orthogonal matrix with $\\mathbf{R}^{\\top}\\mathbf{R} = \\mathbf{I}$ and $\\mathbf{t}$ is a translation vector, then for any positions $\\mathbf{x}_i$ and $\\mathbf{x}_j$, the transformed positions $\\mathbf{x}_i' = \\mathbf{R}\\mathbf{x}_i + \\mathbf{t}$ satisfy $\\|\\mathbf{x}_i' - \\mathbf{x}_j'\\|_2 = \\|\\mathbf{x}_i - \\mathbf{x}_j\\|_2$ and $(\\mathbf{x}_i' - \\mathbf{x}_0') \\cdot (\\mathbf{x}_j' - \\mathbf{x}_0') = (\\mathbf{x}_i - \\mathbf{x}_0) \\cdot (\\mathbf{x}_j - \\mathbf{x}_0)$ for a chosen reference atom $\\mathbf{x}_0$.\n- In continuous-time Markov processes with independent exponential clocks for events, the waiting time to the next event is exponential with rate parameter equal to the sum of individual event rates. If event $i$ has rate $k_i$, the residence time $\\tau$ satisfies $\\tau = 1/\\sum_i k_i$.\n\nAlgorithm requirements:\n- Construct a canonical local graph key from a set of positions that is invariant under any rigid motion. Use only quantities preserved by rigid motions, namely pairwise distances and angle cosines derived from inner products.\n- The canonical key must be a deterministic function of the local environment that does not depend on the original ordering of the atoms. For this, you must use sorted multisets of invariants.\n- To ensure numerical stability and reproducibility, round all pairwise distances to a tolerance of $10^{-6}$ in $\\mathrm{\\AA}$ and all angle cosines to a tolerance of $10^{-6}$ (dimensionless) before sorting.\n\nKey construction specification:\n- Given $N$ atomic positions $\\{\\mathbf{x}_i\\}_{i=1}^{N}$ in $\\mathbb{R}^3$ and a designated central atom index $c$, define the set $S$ as all atoms in the provided positions (assume the provided sets are already the local neighborhoods). Construct:\n    1. The sorted multiset of all pairwise distances $\\{d_{ij}\\}_{1 \\le i  j \\le N}$ where $d_{ij} = \\|\\mathbf{x}_i - \\mathbf{x}_j\\|_2$ in $\\mathrm{\\AA}$, rounded to $10^{-6}$ and sorted ascending.\n    2. The sorted multiset of all angle cosines at the central atom $c$, defined for all unordered neighbor pairs $(j,k)$ with $j \\ne c$, $k \\ne c$, $j  k$, as $\\cos\\theta_{c;jk} = \\dfrac{(\\mathbf{x}_j - \\mathbf{x}_c) \\cdot (\\mathbf{x}_k - \\mathbf{x}_c)}{\\|\\mathbf{x}_j - \\mathbf{x}_c\\|_2 \\, \\|\\mathbf{x}_k - \\mathbf{x}_c\\|_2}$, rounded to $10^{-6}$ and sorted ascending. If there are fewer than two neighbors of $c$, this multiset is empty.\n- The canonical key is the ordered pair consisting of these two sorted lists. This construction is invariant under translations, rotations, and reflections and independent of input ordering.\n\nResidence-Time Algorithm (RTA) specification:\n- Let the event catalog map canonical keys to a list of events, each event parameterized by an attempt frequency $\\nu_i$ in $\\mathrm{s}^{-1}$ and an energy barrier $E_i$ in $\\mathrm{eV}$. For a given temperature $T$ in $\\mathrm{K}$, define the rate $k_i$ by the Arrhenius relation $k_i = \\nu_i \\exp\\!\\left(-\\dfrac{E_i}{k_{\\mathrm{B}} T}\\right)$ where $k_{\\mathrm{B}}$ is the Boltzmann constant in $\\mathrm{eV}/\\mathrm{K}$. The residence time is $\\tau = \\dfrac{1}{\\sum_i k_i}$ in seconds. If the catalog has no events for the key, define $\\tau = +\\infty$.\n\nUnits and numerical requirements:\n- All positions are provided in $\\mathrm{\\AA}$.\n- Distances must be computed in $\\mathrm{\\AA}$ and rounded to $10^{-6}$ before use.\n- Angle cosines are dimensionless and must be rounded to $10^{-6}$ before use.\n- Temperature must be in $\\mathrm{K}$.\n- Attempt frequencies must be in $\\mathrm{s}^{-1}$ and barriers in $\\mathrm{eV}$.\n- Express the final residence times in seconds as floating-point numbers without unit strings.\n\nTest suite:\nImplement your program to process the following four test cases. For each test case, compute the canonical key and then the residence time using the provided event catalog. The program must produce the final residence times for all test cases in a single output line as specified below.\n\nEvent catalog entries (keys defined by the algorithm applied to the prototype geometries below):\n- For the canonical key corresponding to the square planar neighborhood around the central atom (prototype described below), use the following events:\n    - Event $1$: $\\nu_1 = 1.00 \\times 10^{13} \\, \\mathrm{s}^{-1}$, $E_1 = 0.55 \\, \\mathrm{eV}$.\n    - Event $2$: $\\nu_2 = 8.00 \\times 10^{12} \\, \\mathrm{s}^{-1}$, $E_2 = 0.60 \\, \\mathrm{eV}$.\n    - Event $3$: $\\nu_3 = 2.50 \\times 10^{13} \\, \\mathrm{s}^{-1}$, $E_3 = 0.85 \\, \\mathrm{eV}$.\n- For the canonical key corresponding to the equilateral-triangle neighborhood around the central atom (prototype described below), use the following events:\n    - Event $1$: $\\nu_1 = 1.20 \\times 10^{13} \\, \\mathrm{s}^{-1}$, $E_1 = 0.50 \\, \\mathrm{eV}$.\n    - Event $2$: $\\nu_2 = 9.00 \\times 10^{12} \\, \\mathrm{s}^{-1}$, $E_2 = 0.70 \\, \\mathrm{eV}$.\n\nBoltzmann constant:\n- Use $k_{\\mathrm{B}} = 8.617333262145 \\times 10^{-5} \\, \\mathrm{eV}/\\mathrm{K}$.\n\nTemperature:\n- Use $T = 300 \\, \\mathrm{K}$ for all test cases.\n\nPrototype geometries to define catalog keys:\n- Square planar neighborhood (central atom at the origin): positions in $\\mathrm{\\AA}$ are\n  $\\mathbf{x}_c = (0, 0, 0)$, $\\mathbf{x}_1 = (1, 0, 0)$, $\\mathbf{x}_2 = (0, 1, 0)$, $\\mathbf{x}_3 = (-1, 0, 0)$, $\\mathbf{x}_4 = (0, -1, 0)$ with central index $c = 0$.\n- Equilateral-triangle neighborhood (central atom at the origin): positions in $\\mathrm{\\AA}$ are\n  $\\mathbf{x}_c = (0, 0, 0)$, $\\mathbf{x}_1 = (1, 0, 0)$, $\\mathbf{x}_2 = \\left(-\\dfrac{1}{2}, \\dfrac{\\sqrt{3}}{2}, 0\\right)$, $\\mathbf{x}_3 = \\left(-\\dfrac{1}{2}, -\\dfrac{\\sqrt{3}}{2}, 0\\right)$ with central index $c = 0$.\n\nTest cases to process:\n- Test case $1$ (happy path): Use the square planar neighborhood described above with central index $c = 0$ and $T = 300 \\, \\mathrm{K}$.\n- Test case $2$ (rigid-motion invariance): Apply a rotation by angle $\\theta = \\dfrac{\\pi}{6}$ radians about the $z$-axis and then a translation by vector $\\mathbf{t} = (2.5, -1.7, 0.3)$ in $\\mathrm{\\AA}$ to the square planar neighborhood of test case $1$. Use central index $c = 0$ and $T = 300 \\, \\mathrm{K}$.\n- Test case $3$ (distinct environment): Use the equilateral-triangle neighborhood described above with central index $c = 0$ and $T = 300 \\, \\mathrm{K}$.\n- Test case $4$ (edge case with no events): A single isolated atom with position $\\mathbf{x}_c = (2, 2, 2)$ in $\\mathrm{\\AA}$ and central index $c = 0$; there are no neighbors. Use $T = 300 \\, \\mathrm{K}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the residence times for test cases $1$, $2$, $3$, and $4$, in that order, as a comma-separated list enclosed in square brackets. For example, the output should look like $[t_1, t_2, t_3, t_4]$ where each $t_i$ is a floating-point number in seconds (without unit strings). If a residence time is infinite, print it as a floating-point infinity.", "solution": "The task is to construct a canonical representation of a local atomic environment that is invariant to rigid motions and atomic permutations, and then to use this representation to calculate the residence time of the system in that state according to the Residence-Time Algorithm (RTA) for Kinetic Monte Carlo (KMC). The solution is derived from first principles of Euclidean geometry and stochastic processes.\n\nThe problem is determined to be valid. It is scientifically grounded in the principles of computational materials science, mathematically well-posed, objective, and provides all necessary information for a unique, verifiable solution.\n\nThe core of the problem lies in two parts: first, the design of a canonical key, and second, the application of this key in the Residence-Time Algorithm.\n\n**Canonical Key Construction from First Principles**\n\nA canonical representation, or key, of a local atomic configuration $\\{\\mathbf{x}_i\\}_{i=1}^{N}$ must satisfy three critical properties: invariance under translation, invariance under rotation and reflection (together, rigid motions or isometries), and invariance under the permutation of atom labels.\n\n1.  **Invariance under Rigid Motion**: The fundamental quantities preserved under Euclidean isometries are the distances between points. Given any two atomic positions $\\mathbf{x}_i$ and $\\mathbf{x}_j$, a rigid motion transforms them to $\\mathbf{x}_i' = \\mathbf{R}\\mathbf{x}_i + \\mathbf{t}$ and $\\mathbf{x}_j' = \\mathbf{R}\\mathbf{x}_j + \\mathbf{t}$, where $\\mathbf{R}$ is an orthogonal matrix ($\\mathbf{R}^{\\top}\\mathbf{R} = \\mathbf{I}$) and $\\mathbf{t}$ is a translation vector. The distance between the transformed points is $\\|\\mathbf{x}_i' - \\mathbf{x}_j'\\|_2 = \\|(\\mathbf{R}\\mathbf{x}_i + \\mathbf{t}) - (\\mathbf{R}\\mathbf{x}_j + \\mathbf{t})\\|_2 = \\|\\mathbf{R}(\\mathbf{x}_i - \\mathbf{x}_j)\\|_2$. Since orthogonal matrices preserve the norm, this is equal to $\\|\\mathbf{x}_i - \\mathbf{x}_j\\|_2$. Thus, the set of all pairwise distances $\\{d_{ij} = \\|\\mathbf{x}_i - \\mathbf{x}_j\\|_2\\}$ for $1 \\le i  j \\le N$ is invariant under any rigid motion. This forms the first component of our key.\n\n2.  **Invariance and Local Structure**: While the set of all pairwise distances forms a robust invariant, it is often desirable to include angular information relative to a specific atom, designated as the central atom $\\mathbf{x}_c$. The angle $\\theta_{c;jk}$ between two neighbors $\\mathbf{x}_j$ and $\\mathbf{x}_k$ as seen from the center $\\mathbf{x}_c$ is determined by the inner product of the displacement vectors $\\mathbf{v}_j = \\mathbf{x}_j - \\mathbf{x}_c$ and $\\mathbf{v}_k = \\mathbf{x}_k - \\mathbf{x}_c$. The cosine of this angle is given by $\\cos\\theta_{c;jk} = \\frac{\\mathbf{v}_j \\cdot \\mathbf{v}_k}{\\|\\mathbf{v}_j\\|_2 \\|\\mathbf{v}_k\\|_2}$. The displacement vectors are themselves translationally invariant. Under a rotation/reflection, they transform as $\\mathbf{v}_j' = \\mathbf{R}\\mathbf{v}_j$. The inner product is preserved: $\\mathbf{v}_j' \\cdot \\mathbf{v}_k' = (\\mathbf{R}\\mathbf{v}_j)^{\\top}(\\mathbf{R}\\mathbf{v}_k) = \\mathbf{v}_j^{\\top}\\mathbf{R}^{\\top}\\mathbf{R}\\mathbf{v}_k = \\mathbf{v}_j^{\\top}\\mathbf{I}\\mathbf{v}_k = \\mathbf{v}_j \\cdot \\mathbf{v}_k$. The norms are also preserved, making the angle cosine an isometry-invariant quantity. The set of all such cosines $\\{\\cos\\theta_{c;jk}\\}$ for all unique pairs of neighbors $(j,k)$ where $j,k \\ne c$ and we can take $jk$ to avoid duplicates, provides a rich description of the angular geometry around the central atom. This forms the second component of our key.\n\n3.  **Invariance under Permutation**: The key must not depend on the arbitrary indices assigned to the atoms. If we relabel atoms $\\mathbf{x}_i$ and $\\mathbf{x}_j$, the set of distances and angles remains the same, but their order in a simple list would change. To create a representation that is independent of this labeling, we treat the collections of distances and angle cosines as multisets and canonicalize them by sorting. A sorted list (or tuple) of these values is a unique representation of the multiset, invariant to the original ordering of the atoms used to compute them.\n\nTherefore, the canonical key is defined as the ordered pair of two sorted lists: $(\\text{sorted}\\{d_{ij}\\}, \\text{sorted}\\{\\cos\\theta_{c;jk}\\})$. For numerical robustness, all floating-point values are rounded to a fixed precision ($10^{-6}$ as specified) before sorting and comparison. This prevents minuscule floating-point discrepancies from causing configurations that are physically identical to generate different keys.\n\n**Residence-Time Algorithm (RTA) from First Principles**\n\nThe evolution of the atomic system is modeled as a continuous-time Markov process. The system resides in a particular state, defined by our canonical key, for a random duration before transitioning to a new state.\n\n1.  **Independent Exponential Clocks**: Each possible transition (event) $i$ from the current state is assumed to be an independent random event occurring with a constant rate $k_i$. This corresponds to a Poisson process for each event. The waiting time until a specific event $i$ occurs is an exponential random variable with probability density function $f_i(t) = k_i e^{-k_i t}$.\n\n2.  **Total Rate and Residence Time**: The system will transition out of the current state as soon as *any* of the possible events occurs. For independent processes, the time to the first event is also an exponential random variable. Its rate parameter, $k_{total}$, is the sum of the individual event rates: $k_{total} = \\sum_i k_i$.\n\n3.  **Expected Waiting Time**: The expected value, or mean, of an exponential distribution with rate $\\lambda$ is $1/\\lambda$. This mean waiting time until the next transition is defined as the residence time, $\\tau$, of the current state. Therefore, $\\tau = \\frac{1}{k_{total}} = \\frac{1}{\\sum_i k_i}$.\n\n4.  **Physical Model for Rates**: The individual event rates $k_i$ are physically modeled by the Arrhenius equation: $k_i = \\nu_i \\exp\\left(-\\frac{E_i}{k_{\\mathrm{B}} T}\\right)$. Here, $\\nu_i$ is the attempt frequency, representing the vibrational frequency with which the system attempts to overcome the energy barrier $E_i$. The exponential term is the Boltzmann factor, giving the probability of having sufficient thermal energy to surmount the barrier at temperature $T$. $k_{\\mathrm{B}}$ is the Boltzmann constant.\n\n5.  **Trapped States**: If for a given state (canonical key), there are no possible events in the catalog, the sum of rates is $\\sum_i k_i = 0$. This implies a residence time of $\\tau = 1/0 = +\\infty$. Physically, this means the system is trapped in this configuration and will never escape, according to the defined event catalog.\n\n**Algorithmic Implementation**\n\nThe implementation proceeds by first defining a function `generate_key` that takes a set of atomic positions and a central atom index, and returns the canonical key as a hashable tuple of tuples. This involves computing all pairwise distances and all central angle cosines, rounding them to a precision of $10^{-6}$, sorting the resulting lists, and packaging them.\n\nNext, an event catalog is constructed as a dictionary. The keys of this dictionary are the canonical keys generated from the provided prototype geometries (square planar and equilateral triangle). The values are lists of event parameters $(\\nu_i, E_i)$.\n\nFinally, each test case is processed. The canonical key is generated for the given geometry. This key is used to look up events in the catalog. The total rate is calculated by summing the Arrhenius rates for all found events. The residence time $\\tau$ is then computed as the reciprocal of the total rate. If no events are found for a key, the total rate is $0$ and the residence time is infinite. The results for all four test cases are collected and printed in the specified format. The use of `numpy` facilitates efficient vector and matrix operations, and `scipy.spatial.distance.pdist` efficiently calculates the pairwise distances.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial.distance import pdist\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Implements the canonicalization and residence-time algorithm for off-lattice KMC.\n    \"\"\"\n    \n    # Define constants and parameters from the problem statement.\n    KB_EV_K = 8.617333262145e-5  # Boltzmann constant in eV/K\n    TEMPERATURE = 300.0          # Temperature in K\n    PRECISION = 6                # Decimal places for rounding\n\n    def generate_key(positions: np.ndarray, central_idx: int) - tuple:\n        \"\"\"\n        Generates a canonical key for a local atomic environment.\n\n        The key is invariant under translation, rotation, reflection, and\n        permutation of atom indices.\n\n        Args:\n            positions (np.ndarray): Array of atomic positions, shape (N, 3).\n            central_idx (int): Index of the central atom.\n\n        Returns:\n            tuple: A hashable canonical key (tuple of sorted distances, \n                   tuple of sorted angle cosines).\n        \"\"\"\n        num_atoms = positions.shape[0]\n\n        # 1. Compute the sorted multiset of all pairwise distances.\n        if num_atoms  2:\n            distances = []\n        else:\n            # pdist computes distances for i  j, which matches the problem spec.\n            distances = pdist(positions)\n        \n        rounded_distances = np.round(distances, PRECISION)\n        sorted_distances = tuple(np.sort(rounded_distances))\n\n        # 2. Compute the sorted multiset of all central angle cosines.\n        neighbor_indices = [i for i in range(num_atoms) if i != central_idx]\n        \n        cosines = []\n        if len(neighbor_indices) = 2:\n            central_pos = positions[central_idx]\n            # Iterate through all unique pairs of neighbors.\n            for j, k in combinations(neighbor_indices, 2):\n                vec_j = positions[j] - central_pos\n                vec_k = positions[k] - central_pos\n                \n                norm_j = np.linalg.norm(vec_j)\n                norm_k = np.linalg.norm(vec_k)\n\n                # The problem guarantees environments where neighbors are distinct from the center,\n                # so norms will not be zero.\n                cos_theta = np.dot(vec_j, vec_k) / (norm_j * norm_k)\n                cosines.append(cos_theta)\n\n        rounded_cosines = np.round(cosines, PRECISION)\n        sorted_cosines = tuple(np.sort(rounded_cosines))\n\n        return (sorted_distances, sorted_cosines)\n\n    # --- Build Event Catalog ---\n    # Define prototype geometries to generate catalog keys.\n    square_planar_positions = np.array([\n        [0.0, 0.0, 0.0],  # central atom c=0\n        [1.0, 0.0, 0.0],\n        [0.0, 1.0, 0.0],\n        [-1.0, 0.0, 0.0],\n        [0.0, -1.0, 0.0]\n    ])\n\n    equilateral_triangle_positions = np.array([\n        [0.0, 0.0, 0.0],  # central atom c=0\n        [1.0, 0.0, 0.0],\n        [-0.5, np.sqrt(3)/2, 0.0],\n        [-0.5, -np.sqrt(3)/2, 0.0]\n    ])\n\n    # Generate the keys for the prototypes.\n    square_key = generate_key(square_planar_positions, central_idx=0)\n    triangle_key = generate_key(equilateral_triangle_positions, central_idx=0)\n\n    # Define the event catalog.\n    event_catalog = {\n        square_key: [\n            (1.00e13, 0.55),  # (nu_i in s^-1, E_i in eV)\n            (8.00e12, 0.60),\n            (2.50e13, 0.85)\n        ],\n        triangle_key: [\n            (1.20e13, 0.50),\n            (9.00e12, 0.70)\n        ]\n    }\n\n    # --- Define Test Cases ---\n    \n    # Test Case 1: Square planar neighborhood\n    case1_positions = square_planar_positions\n    \n    # Test Case 2: Rotated and translated square planar neighborhood\n    theta = np.pi / 6\n    rotation_matrix = np.array([\n        [np.cos(theta), -np.sin(theta), 0.0],\n        [np.sin(theta),  np.cos(theta), 0.0],\n        [0.0,            0.0,           1.0]\n    ])\n    translation_vector = np.array([2.5, -1.7, 0.3])\n    case2_positions = (rotation_matrix @ square_planar_positions.T).T + translation_vector\n\n    # Test Case 3: Equilateral triangle neighborhood\n    case3_positions = equilateral_triangle_positions\n\n    # Test Case 4: Single isolated atom\n    case4_positions = np.array([[2.0, 2.0, 2.0]])\n\n    test_cases = [\n        # (positions, central_idx)\n        (case1_positions, 0),\n        (case2_positions, 0),\n        (case3_positions, 0),\n        (case4_positions, 0)\n    ]\n\n    results = []\n    kbt = KB_EV_K * TEMPERATURE\n\n    # --- Process Test Cases ---\n    for positions, central_idx in test_cases:\n        # Generate the key for the current configuration.\n        key = generate_key(positions, central_idx)\n        \n        # Look up events in the catalog.\n        events = event_catalog.get(key, [])\n        \n        # Calculate total rate.\n        total_rate = 0.0\n        for nu, E in events:\n            rate = nu * np.exp(-E / kbt)\n            total_rate += rate\n            \n        # Calculate residence time.\n        if total_rate == 0.0:\n            tau = float('inf')\n        else:\n            tau = 1.0 / total_rate\n        \n        results.append(tau)\n\n    # Print results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3450014"}]}