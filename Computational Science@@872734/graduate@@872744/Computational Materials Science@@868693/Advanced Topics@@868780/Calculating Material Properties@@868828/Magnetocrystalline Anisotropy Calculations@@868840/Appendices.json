{"hands_on_practices": [{"introduction": "Before we can calculate magnetocrystalline anisotropy, it is crucial to understand its physical origin. This practice uses a simplified tight-binding model to demonstrate that in the absence of spin-orbit coupling (SOC), the total energy is independent of the global spin orientation. By verifying this rotational invariance numerically, you will build a foundational understanding that MAE arises specifically from relativistic effects that couple the spin system to the crystal lattice.", "problem": "You are tasked with constructing and analyzing a minimal, physically plausible tight-binding model that captures the rotational properties of the spin degrees of freedom in the context of Density Functional Theory (DFT) with noncollinear magnetism. The purpose is to demonstrate that, in the absence of Spin-Orbit Coupling (SOC), the total electronic energy as a function of the spin quantization axis orientation $E(\\theta)$ is invariant with respect to rotations in spin space, up to numerical tolerance, thereby ensuring that no spurious magnetocrystalline anisotropy is introduced by the computational setup.\n\nStart from fundamental principles: in the absence of spin-orbit coupling, the Pauli Hamiltonian with an exchange field is rotationally invariant in spin space. As a minimal computational model, consider a two-orbital ($p_x$, $p_y$) tight-binding system on a two-dimensional square lattice. Let the orbital dispersions be\n$$\n\\varepsilon_x(\\mathbf{k}) = \\varepsilon_0 + 2 t_1 \\cos k_x + 2 t_2 \\cos k_y,\n$$\n$$\n\\varepsilon_y(\\mathbf{k}) = \\varepsilon_0 + 2 t_2 \\cos k_x + 2 t_1 \\cos k_y,\n$$\nwith lattice constant set to unity and $\\mathbf{k}$ sampled uniformly in the first Brillouin zone with $k_x, k_y \\in [-\\pi, \\pi)$; angle variables must always be expressed in radians. Define the orbital Hamiltonian\n$$\nH_{\\text{orb}}(\\mathbf{k}) = \\begin{pmatrix} \\varepsilon_x(\\mathbf{k}) & 0 \\\\ 0 & \\varepsilon_y(\\mathbf{k}) \\end{pmatrix}.\n$$\nLet the orbital angular momentum operator along the crystalline $z$ axis in the $(p_x, p_y)$ basis be\n$$\nL_z = \\begin{pmatrix} 0 & i \\\\ -i & 0 \\end{pmatrix},\n$$\nin units where $\\hbar = 1$. Let the Pauli matrices be $\\sigma_x, \\sigma_y, \\sigma_z$ and $I_2$ be the $2 \\times 2$ identity matrix. Model a collinear mean-field exchange interaction of magnitude $\\Delta$ along a unit vector $\\mathbf{n}(\\theta) = (\\sin \\theta, 0, \\cos \\theta)$, which represents the spin quantization axis. Introduce a spin-orbit coupling as a local on-site term $\\lambda L_z \\otimes \\sigma_z$ that ties the spin to the lattice axes. The full Bloch Hamiltonian is\n$$\nH(\\mathbf{k}, \\theta) = H_{\\text{orb}}(\\mathbf{k}) \\otimes I_2 + \\Delta \\, I_2 \\otimes \\left(\\mathbf{n}(\\theta) \\cdot \\boldsymbol{\\sigma}\\right) + \\lambda \\, L_z \\otimes \\sigma_z.\n$$\n\nAt zero temperature, for a given electron number per unit cell $n_e$, approximate the total energy per unit cell $E(\\theta)$ by uniformly sampling a rectangular $\\mathbf{k}$-point mesh of size $N_x \\times N_y$, diagonalizing $H(\\mathbf{k}, \\theta)$ at each $\\mathbf{k}$, collecting all $4$ band energies for each $\\mathbf{k}$, sorting them globally across the Brillouin zone, and summing the lowest $n_e N_k$ energies, where $N_k = N_x N_y$. The energy per unit cell is then\n$$\nE(\\theta) = \\frac{1}{N_k} \\sum_{m=1}^{n_e N_k} \\epsilon_m(\\theta),\n$$\nwhere $\\epsilon_m(\\theta)$ are the globally sorted single-particle eigenvalues of $H(\\mathbf{k}, \\theta)$ over all $\\mathbf{k}$-points. All energies must be handled and reported in electronvolts (eV).\n\nYour program must implement this model and, for each test case specified below, compute $E(\\theta)$ for a list of angles and then evaluate the maximum absolute deviation from a reference orientation:\n$$\n\\Delta E_{\\max} = \\max_{\\theta} \\left| E(\\theta) - E(\\theta_{\\text{ref}}) \\right|.\n$$\nA test case passes (boolean output is `True`) if $\\Delta E_{\\max} \\le \\tau$ for the specified numerical tolerance $\\tau$ (expressed in eV), and fails (boolean output is `False`) otherwise.\n\nAngle variables must be in radians. Energies must be in electronvolts (eV). The final output must be a single line containing the boolean results for all test cases as a comma-separated list enclosed in square brackets, for example, \"[True,False,True]\".\n\nUse the following test suite, designed to probe different facets of the invariance:\n\n- Test Case A (general noncollinear, no SOC, anisotropic orbitals, happy path):\n  - $\\varepsilon_0 = 0.0$ eV, $t_1 = 1.0$ eV, $t_2 = 0.2$ eV, $\\Delta = 0.4$ eV, $\\lambda = 0.0$ eV.\n  - $n_e = 2.0$ electrons per unit cell.\n  - $N_x = 10$, $N_y = 10$ ($N_k = 100$).\n  - Angles: $\\theta \\in \\{ 0.0, \\pi/7, \\pi/4, \\pi/2 \\}$.\n  - Tolerance: $\\tau = 1\\times 10^{-9}$ eV.\n  - Expected behavior: rotational invariance, boolean should be `True`.\n\n- Test Case B (boundary condition: no magnetization, no SOC):\n  - $\\varepsilon_0 = 0.0$ eV, $t_1 = 0.8$ eV, $t_2 = 0.6$ eV, $\\Delta = 0.0$ eV, $\\lambda = 0.0$ eV.\n  - $n_e = 1.0$ electrons per unit cell.\n  - $N_x = 8$, $N_y = 8$ ($N_k = 64$).\n  - Angles: $\\theta \\in \\{ 0.0, \\pi/3, \\pi \\}$.\n  - Tolerance: $\\tau = 1\\times 10^{-9}$ eV.\n  - Expected behavior: rotational invariance, boolean should be `True`.\n\n- Test Case C (edge case: SOC present, anisotropy should be observable):\n  - $\\varepsilon_0 = 0.0$ eV, $t_1 = 1.0$ eV, $t_2 = 0.2$ eV, $\\Delta = 0.4$ eV, $\\lambda = 0.2$ eV.\n  - $n_e = 2.0$ electrons per unit cell.\n  - $N_x = 20$, $N_y = 20$ ($N_k = 400$).\n  - Angles: $\\theta \\in \\{ 0.0, \\pi/7, \\pi/4, \\pi/2 \\}$.\n  - Tolerance: $\\tau = 1\\times 10^{-9}$ eV.\n  - Expected behavior: broken rotational invariance due to SOC, boolean should be `False`.\n\n- Test Case D (boundary condition: coarse grid, no SOC):\n  - $\\varepsilon_0 = 0.0$ eV, $t_1 = 1.2$ eV, $t_2 = 0.7$ eV, $\\Delta = 0.5$ eV, $\\lambda = 0.0$ eV.\n  - $n_e = 2.0$ electrons per unit cell.\n  - $N_x = 4$, $N_y = 4$ ($N_k = 16$).\n  - Angles: $\\theta \\in \\{ 0.0, \\pi/4, \\pi/2 \\}$.\n  - Tolerance: $\\tau = 1\\times 10^{-9}$ eV.\n  - Expected behavior: rotational invariance, boolean should be `True`.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the exact order of Test Cases A, B, C, and D.", "solution": "The problem statement is evaluated as valid. It is scientifically grounded in the principles of condensed matter physics, specifically tight-binding models and the theory of magnetism. It is well-posed, providing a complete set of equations, parameters, and a clear computational procedure. The language is objective and unambiguous. We may therefore proceed with the solution.\n\nThe core task is to numerically verify a fundamental principle of magnetism: in the absence of spin-orbit coupling (SOC), the total energy of a system is invariant under a global rotation of all electron spins. Any dependence of the total energy on the spin orientation, known as magnetocrystalline anisotropy, must arise from an interaction that couples the spin degrees of freedom to the crystal lattice. In our model, this coupling is provided by the SOC term.\n\nThe solution is implemented by following these steps for each test case:\n\n1.  **Model Definition**: We first define the matrix representations of the operators involved. The Hilbert space for a single atomic site is the tensor product of a $2$-dimensional orbital space spanned by $\\{ |p_x\\rangle, |p_y\\rangle \\}$ and a $2$-dimensional spin space spanned by $\\{ |\\uparrow\\rangle, |\\downarrow\\rangle \\}$. The total basis is $4$-dimensional. The Pauli matrices are:\n    $$\n    \\sigma_x = \\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix}, \\quad \\sigma_y = \\begin{pmatrix} 0 & -i \\\\ i & 0 \\end{pmatrix}, \\quad \\sigma_z = \\begin{pmatrix} 1 & 0 \\\\ 0 & -1 \\end{pmatrix}\n    $$\n    The identity matrix in spin space is $I_2$. The orbital angular momentum operator $L_z$ is given in the problem statement.\n\n2.  **Hamiltonian Construction**: For each point $\\mathbf{k} = (k_x, k_y)$ in the Brillouin zone and for each spin orientation angle $\\theta$, we construct the $4 \\times 4$ Bloch Hamiltonian matrix $H(\\mathbf{k}, \\theta)$. The Hamiltonian is the sum of three terms:\n    $$\n    H(\\mathbf{k}, \\theta) = H_{\\text{orb}}(\\mathbf{k}) \\otimes I_2 + H_{\\text{exch}}(\\theta) + H_{\\text{soc}}\n    $$\n    -   The orbital term, $H_{\\text{orb}}(\\mathbf{k}) \\otimes I_2$, describes the kinetic energy of electrons and their interaction with the periodic potential of the lattice, independent of spin. The orbital dispersions are $\\varepsilon_x(\\mathbf{k}) = \\varepsilon_0 + 2 t_1 \\cos k_x + 2 t_2 \\cos k_y$ and $\\varepsilon_y(\\mathbf{k}) = \\varepsilon_0 + 2 t_2 \\cos k_x + 2 t_1 \\cos k_y$.\n    -   The exchange term, $H_{\\text{exch}}(\\theta) = \\Delta \\, I_2 \\otimes \\left(\\mathbf{n}(\\theta) \\cdot \\boldsymbol{\\sigma}\\right)$, represents the effective magnetic field from electron-electron interactions (exchange-correlation). It aligns the spins along the general direction $\\mathbf{n}(\\theta) = (\\sin \\theta, 0, \\cos \\theta)$. This term is explicitly:\n        $$\n        H_{\\text{exch}}(\\theta) = \\Delta \\, I_2 \\otimes \\begin{pmatrix} \\cos\\theta & \\sin\\theta \\\\ \\sin\\theta & -\\cos\\theta \\end{pmatrix}\n        $$\n    -   The spin-orbit coupling (SOC) term, $H_{\\text{soc}} = \\lambda \\, L_z \\otimes \\sigma_z$, links the spin orientation to the orbital degrees of freedom, which are fixed to the crystal lattice. This is the term that can break the rotational invariance in spin space.\n\n    Combining these terms results in the full Hamiltonian matrix, which is Hermitian:\n    $$\n    H(\\mathbf{k}, \\theta) = \\begin{pmatrix}\n    \\varepsilon_x(\\mathbf{k}) + \\Delta\\cos\\theta & \\Delta\\sin\\theta & i\\lambda & 0 \\\\\n    \\Delta\\sin\\theta & \\varepsilon_x(\\mathbf{k}) - \\Delta\\cos\\theta & 0 & -i\\lambda \\\\\n    -i\\lambda & 0 & \\varepsilon_y(\\mathbf{k}) + \\Delta\\cos\\theta & \\Delta\\sin\\theta \\\\\n    0 & i\\lambda & \\Delta\\sin\\theta & \\varepsilon_y(\\mathbf{k}) - \\Delta\\cos\\theta\n    \\end{pmatrix}\n    $$\n    This matrix is implemented using `numpy.kron` for clarity and correctness, and is of complex data type due to the terms $i\\lambda$.\n\n3.  **Brillouin Zone Integration**: The total energy per unit cell, $E(\\theta)$, is an integral over the first Brillouin zone. We approximate this integral by summing over a discrete, uniform mesh of $\\mathbf{k}$-points. A mesh of size $N_x \\times N_y$ is generated, with $k_x$ and $k_y$ spanning the interval $[-\\pi, \\pi)$. For each of the $N_k = N_x N_y$ points in this mesh, we construct and diagonalize the Hamiltonian $H(\\mathbf{k}, \\theta)$. Since the Hamiltonian is Hermitian, its eigenvalues are real, and `numpy.linalg.eigvalsh` is an efficient and numerically stable choice for this task. This process yields $4 \\times N_k$ single-particle energy eigenvalues for each angle $\\theta$.\n\n4.  **Total Energy Calculation**: At zero temperature ($T=0$), the electrons occupy the lowest available energy states up to the Fermi level. Given an electron number per unit cell $n_e$, the total number of occupied states across the simulated Brillouin zone is $n_e N_k$. To find the total electronic energy per unit cell for a given angle $\\theta$, we perform the following steps:\n    a. Collect all $4 \\times N_k$ eigenvalues from the diagonalizations at all $\\mathbf{k}$-points.\n    b. Sort these eigenvalues in ascending order.\n    c. Sum the lowest $n_e N_k$ eigenvalues.\n    d. Normalize this sum by dividing by the number of $\\mathbf{k}$-points, $N_k$.\n    $$\n    E(\\theta) = \\frac{1}{N_k} \\sum_{m=1}^{n_e N_k} \\epsilon_m(\\theta)\n    $$\n    This procedure is repeated for every angle $\\theta$ specified in the test case.\n\n5.  **Anisotropy Evaluation**: To quantify the rotational invariance, we calculate the maximum energy deviation, $\\Delta E_{\\max}$, across the calculated angles. We select the energy at the first angle, $\\theta_{\\text{ref}}$, as the reference energy $E(\\theta_{\\text{ref}})$.\n    $$\n    \\Delta E_{\\max} = \\max_{\\theta} \\left| E(\\theta) - E(\\theta_{\\text{ref}}) \\right|\n    $$\n    A test case is considered passed if this deviation is within a given numerical tolerance $\\tau$, i.e., $\\Delta E_{\\max} \\le \\tau$. This boolean result is computed for each test case.\n\nThis complete procedure is encapsulated in a Python script. For cases where the SOC constant $\\lambda$ is zero, we expect $\\Delta E_{\\max}$ to be zero (or on the order of machine precision, much smaller than the tolerance $\\tau=1 \\times 10^{-9}$ eV), as the Hamiltonian $H(\\mathbf{k}, \\theta)$ is unitarily equivalent to $H(\\mathbf{k}, 0)$ for all $\\theta$, resulting in an identical set of eigenvalues. When $\\lambda$ is non-zero, this unitary equivalence is broken, and $E(\\theta)$ is expected to vary with $\\theta$, leading to a $\\Delta E_{\\max}$ that exceeds the tolerance. The program systematically applies this methodology to each of the four test cases and aggregates their boolean outcomes.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes magnetocrystalline anisotropy for a tight-binding model\n    to verify rotational invariance in the absence of spin-orbit coupling.\n    \"\"\"\n\n    # Define test cases as specified in the problem statement.\n    test_cases = [\n        # Test Case A\n        {\n            \"params\": {\"eps0\": 0.0, \"t1\": 1.0, \"t2\": 0.2, \"Delta\": 0.4, \"lambda_\": 0.0},\n            \"ne\": 2.0, \"Nk_dims\": (10, 10),\n            \"angles\": [0.0, np.pi/7, np.pi/4, np.pi/2],\n            \"tolerance\": 1e-9,\n        },\n        # Test Case B\n        {\n            \"params\": {\"eps0\": 0.0, \"t1\": 0.8, \"t2\": 0.6, \"Delta\": 0.0, \"lambda_\": 0.0},\n            \"ne\": 1.0, \"Nk_dims\": (8, 8),\n            \"angles\": [0.0, np.pi/3, np.pi],\n            \"tolerance\": 1e-9,\n        },\n        # Test Case C\n        {\n            \"params\": {\"eps0\": 0.0, \"t1\": 1.0, \"t2\": 0.2, \"Delta\": 0.4, \"lambda_\": 0.2},\n            \"ne\": 2.0, \"Nk_dims\": (20, 20),\n            \"angles\": [0.0, np.pi/7, np.pi/4, np.pi/2],\n            \"tolerance\": 1e-9,\n        },\n        # Test Case D\n        {\n            \"params\": {\"eps0\": 0.0, \"t1\": 1.2, \"t2\": 0.7, \"Delta\": 0.5, \"lambda_\": 0.0},\n            \"ne\": 2.0, \"Nk_dims\": (4, 4),\n            \"angles\": [0.0, np.pi/4, np.pi/2],\n            \"tolerance\": 1e-9,\n        },\n    ]\n\n    # Pre-define constant matrices\n    I2 = np.identity(2, dtype=float)\n    SIGMA_X = np.array([[0, 1], [1, 0]], dtype=float)\n    SIGMA_Z = np.array([[1, 0], [0, -1]], dtype=float)\n    L_Z = np.array([[0, 1j], [-1j, 0]], dtype=complex)\n\n    def calculate_total_energy(params, ne, Nk_dims, theta):\n        \"\"\"\n        Calculates the total energy per unit cell for a given spin orientation theta.\n        \"\"\"\n        eps0, t1, t2, Delta, lambda_ = params.values()\n        Nx, Ny = Nk_dims\n        Nk = Nx * Ny\n\n        # Generate k-point mesh\n        kx_vals = np.linspace(-np.pi, np.pi, Nx, endpoint=False)\n        ky_vals = np.linspace(-np.pi, np.pi, Ny, endpoint=False)\n        \n        all_eigenvalues = []\n\n        # Construct constant parts of the Hamiltonian\n        n_vec_sigma = np.cos(theta) * SIGMA_Z + np.sin(theta) * SIGMA_X\n        h_exch = Delta * np.kron(I2, n_vec_sigma)\n        h_soc = lambda_ * np.kron(L_Z, SIGMA_Z)\n\n        for kx in kx_vals:\n            for ky in ky_vals:\n                # Orbital dispersions\n                eps_x_k = eps0 + 2 * t1 * np.cos(kx) + 2 * t2 * np.cos(ky)\n                eps_y_k = eps0 + 2 * t2 * np.cos(kx) + 2 * t1 * np.cos(ky)\n                \n                h_orb_diag = np.array([[eps_x_k, 0], [0, eps_y_k]])\n                h_orb = np.kron(h_orb_diag, I2)\n\n                # Full Hamiltonian\n                H_k = h_orb + h_exch + h_soc\n                \n                # Diagonalize and collect eigenvalues\n                eigenvalues = np.linalg.eigvalsh(H_k)\n                all_eigenvalues.extend(eigenvalues)\n        \n        # Sort all eigenvalues globally\n        all_eigenvalues.sort()\n\n        # Sum occupied states\n        num_occupied = int(ne * Nk)\n        total_energy_sum = np.sum(all_eigenvalues[0:num_occupied])\n\n        # Return energy per unit cell\n        return total_energy_sum / Nk\n\n    results = []\n    for case in test_cases:\n        energies_for_case = []\n        for theta in case[\"angles\"]:\n            energy = calculate_total_energy(case[\"params\"], case[\"ne\"], case[\"Nk_dims\"], theta)\n            energies_for_case.append(energy)\n        \n        # Calculate max deviation from reference energy\n        e_ref = energies_for_case[0]\n        delta_e_max = np.max(np.abs(np.array(energies_for_case) - e_ref))\n        \n        # Check against tolerance\n        passed = delta_e_max <= case[\"tolerance\"]\n        results.append(passed)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3462882"}, {"introduction": "A powerful method for quantifying magnetocrystalline anisotropy involves calculating the torque on the magnetic moment as it is rotated away from an easy axis. This exercise challenges you to extract the anisotropy constants $K_1$ and $K_2$ by fitting a model to torque data, directly applying the fundamental relationship $T(\\theta) = -\\frac{\\partial E}{\\partial \\theta}$. This approach is not only practical but also provides a vital opportunity to cross-validate results against direct energy differences, a key skill in robust computational science.", "problem": "You are given a uniaxial magnetocrystalline anisotropy model for hexagonal close-packed cobalt, where the magnetocrystalline anisotropy energy as a function of polar angle is represented by the series expansion $E(\\theta) \\approx K_1 \\sin^2 \\theta + K_2 \\sin^4 \\theta$. The fundamental base you must use is the mathematical definition of torque $T(\\theta)$ as the negative angular derivative of energy, i.e., $T(\\theta) = -\\frac{\\partial E}{\\partial \\theta}$, together with the assumption that the series expansion above is the leading-order symmetry-allowed form for uniaxial systems. Using these foundations, you must derive and implement an algorithm that extracts the coefficients $K_1$ and $K_2$ from discrete torque data sampled at several angles, and then assess numerical consistency by comparing the predicted hard-minus-easy axis energy difference from the fitted coefficients against a direct total energy difference supplied independently.\n\nYour implementation must adhere to the following scientifically realistic and self-consistent scenario and constraints:\n\n- Use angles in radians.\n- Use $\\mu\\mathrm{eV}$ per formula unit as the energy unit.\n- Use $\\mu\\mathrm{eV}$ per formula unit per radian as the torque unit.\n- Do not assume any shortcut formulas beyond the given definitions. Your derivation should start from $E(\\theta) \\approx K_1 \\sin^2 \\theta + K_2 \\sin^4 \\theta$ and $T(\\theta) = -\\frac{\\partial E}{\\partial \\theta}$, and proceed by demonstrating how to estimate $K_1$ and $K_2$ from a finite set of measured torques using a mathematically justified procedure.\n\nYour program must perform the following, using the four test cases below:\n\n- For each test case, you are given a set of angles $\\{\\theta_i\\}$, a corresponding set of measured torques $\\{T_i\\}$, and two energy values $E(\\theta=0)$ and $E(\\theta=\\pi/2)$.\n- Using the torque data only, compute the least-squares estimates $\\hat{K}_1$ and $\\hat{K}_2$.\n- Compute $\\Delta E_{\\text{fit}} = \\hat{K}_1 + \\hat{K}_2$.\n- Compute the direct energy difference $\\Delta E_{\\text{direct}} = E(\\theta=\\pi/2) - E(\\theta=0)$.\n- Compute the absolute difference $d = |\\Delta E_{\\text{fit}} - \\Delta E_{\\text{direct}}|$.\n- With a consistency tolerance $\\tau = 1.0$ $\\mu \\mathrm{eV}$, define a boolean consistency flag $c$ that is $c = \\text{True}$ if $d \\le \\tau$, else $c = \\text{False}$.\n\nTest suite parameter values:\n\n- Case $1$ (noiseless, moderate anisotropy):\n  - Angles: $\\left[\\frac{\\pi}{12}, \\frac{\\pi}{6}, \\frac{\\pi}{4}, \\frac{\\pi}{3}, \\frac{5\\pi}{12}\\right]$.\n  - Torques (in $\\mu \\mathrm{eV}$ per formula unit per radian): $\\left[-30.3349364905389, -54.1265877354711, -65.0, -58.45671475438329, -34.6650635094611\\right]$.\n  - Energies (in $\\mu \\mathrm{eV}$ per formula unit): $E(\\theta=0) = 0.0$, $E(\\theta=\\pi/2) = 65.0$.\n- Case $2$ (noisy torque and energy data, same underlying scale):\n  - Angles: $\\left[\\frac{\\pi}{12}, \\frac{\\pi}{6}, \\frac{\\pi}{4}, \\frac{\\pi}{3}, \\frac{5\\pi}{12}\\right]$.\n  - Torques (in $\\mu \\mathrm{eV}$ per formula unit per radian): $\\left[-30.1349364905389, -54.2265877354711, -64.95, -58.45671475438329, -34.8150635094611\\right]$.\n  - Energies (in $\\mu \\mathrm{eV}$ per formula unit): $E(\\theta=0) = 0.0$, $E(\\theta=\\pi/2) = 65.3$.\n- Case $3$ (vanishing fourth-order term):\n  - Angles: $\\left[\\frac{\\pi}{12}, \\frac{\\pi}{6}, \\frac{\\pi}{4}, \\frac{\\pi}{3}, \\frac{5\\pi}{12}\\right]$.\n  - Torques (in $\\mu \\mathrm{eV}$ per formula unit per radian): $\\left[-15.0, -25.98076211353316, -30.0, -25.98076211353316, -15.0\\right]$.\n  - Energies (in $\\mu \\mathrm{eV}$ per formula unit): $E(\\theta=0) = 0.0$, $E(\\theta=\\pi/2) = 30.0$.\n- Case $4$ (very small anisotropy):\n  - Angles: $\\left[\\frac{\\pi}{12}, \\frac{\\pi}{6}, \\frac{\\pi}{4}, \\frac{\\pi}{3}, \\frac{5\\pi}{12}\\right]$.\n  - Torques (in $\\mu \\mathrm{eV}$ per formula unit per radian): $\\left[-0.5334936490538904, -1.0825317547305483, -1.5, -1.5155444566227678, -0.9665063509461097\\right]$.\n  - Energies (in $\\mu \\mathrm{eV}$ per formula unit): $E(\\theta=0) = 0.0$, $E(\\theta=\\pi/2) = 1.5$.\n\nAngle unit is radians. Energy unit is $\\mu \\mathrm{eV}$ per formula unit. Torque unit is $\\mu \\mathrm{eV}$ per formula unit per radian. All computations and outputs must respect these units.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a sublist of the form $[\\hat{K}_1,\\hat{K}_2,\\Delta E_{\\text{direct}},\\Delta E_{\\text{fit}},d,c]$. For example, a valid output format is $[[a_1,b_1,x_1,y_1,z_1,t_1],[a_2,b_2,x_2,y_2,z_2,t_2],[a_3,b_3,x_3,y_3,z_3,t_3],[a_4,b_4,x_4,y_4,z_4,t_4]]$ where $a_i$, $b_i$, $x_i$, $y_i$, and $z_i$ are floats and $t_i$ is a boolean. Your program must exactly print this single line and nothing else.", "solution": "The problem presented is valid. It is scientifically grounded in the principles of magnetism, specifically the phenomenological model of uniaxial magnetocrystalline anisotropy. It is well-posed, providing a complete and consistent set of data and definitions to allow for a unique and meaningful solution via a standard numerical method. The objectives are stated with clarity and precision, free of subjective or ambiguous language.\n\nThe core of the problem is to determine the magnetocrystalline anisotropy coefficients, $K_1$ and $K_2$, from a set of discrete torque measurements. The physical model provided for the anisotropy energy $E$ as a function of the polar angle $\\theta$ (the angle between the magnetization vector and the crystallographic $c$-axis) is the truncated series expansion for a uniaxial system:\n$$E(\\theta) = K_1 \\sin^2 \\theta + K_2 \\sin^4 \\theta$$\nHere, $\\theta=0$ corresponds to the easy magnetization axis (minimum energy) and $\\theta=\\pi/2$ corresponds to the hard magnetization axis (maximum energy), assuming $K_1+K_2 > 0$.\n\nThe torque, $T(\\theta)$, exerted on the magnetic moment by the crystal lattice is defined as the negative derivative of the anisotropy energy with respect to the angle:\n$$T(\\theta) = -\\frac{\\partial E}{\\partial \\theta}$$\nWe derive the theoretical expression for the torque by differentiating the energy expression with respect to $\\theta$:\n$$T(\\theta) = -\\frac{\\partial}{\\partial \\theta} \\left( K_1 \\sin^2 \\theta + K_2 \\sin^4 \\theta \\right)$$\nUsing the chain rule, $\\frac{d}{d\\theta}\\sin^n\\theta = n\\sin^{n-1}\\theta\\cos\\theta$, we obtain:\n$$T(\\theta) = - \\left( K_1 \\cdot 2\\sin\\theta\\cos\\theta + K_2 \\cdot 4\\sin^3\\theta\\cos\\theta \\right)$$\nThis equation expresses the torque $T(\\theta)$ as a linear combination of the unknown coefficients $K_1$ and $K_2$:\n$$T(\\theta) = (-2\\sin\\theta\\cos\\theta) K_1 + (-4\\sin^3\\theta\\cos\\theta) K_2$$\n\nGiven a set of $N$ experimental or computational measurements of torque $\\{T_i\\}$ at corresponding angles $\\{\\theta_i\\}$, we can formulate a system of linear equations. For each measurement $i \\in \\{1, ..., N\\}$:\n$$T_i = (-2\\sin\\theta_i\\cos\\theta_i) K_1 + (-4\\sin^3\\theta_i\\cos\\theta_i) K_2 + \\epsilon_i$$\nwhere $\\epsilon_i$ represents measurement noise or model error. This system can be written in matrix form as $\\mathbf{y} = \\mathbf{X}\\mathbf{k} + \\mathbf{\\epsilon}$, where:\n$$\n\\mathbf{y} = \\begin{pmatrix} T_1 \\\\ T_2 \\\\ \\vdots \\\\ T_N \\end{pmatrix}, \\quad\n\\mathbf{k} = \\begin{pmatrix} K_1 \\\\ K_2 \\end{pmatrix}, \\quad\n\\mathbf{X} = \\begin{pmatrix}\n-2\\sin\\theta_1\\cos\\theta_1 & -4\\sin^3\\theta_1\\cos\\theta_1 \\\\\n-2\\sin\\theta_2\\cos\\theta_2 & -4\\sin^3\\theta_2\\cos\\theta_2 \\\\\n\\vdots & \\vdots \\\\\n-2\\sin\\theta_N\\cos\\theta_N & -4\\sin^3\\theta_N\\cos\\theta_N\n\\end{pmatrix}\n$$\nThe goal is to find the coefficient vector $\\hat{\\mathbf{k}}$ that best fits the data. The method of ordinary least squares (OLS) provides such an estimate by minimizing the sum of the squares of the residuals, $||\\mathbf{y} - \\mathbf{X}\\mathbf{k}||^2$. The OLS solution is given by the normal equations:\n$$\\hat{\\mathbf{k}} = (\\mathbf{X}^T \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{y}$$\nThis computation will yield the estimated coefficients, $\\hat{K}_1$ and $\\hat{K}_2$.\n\nThe second part of the task is to perform a consistency check. The energy difference between the hard axis ($\\theta=\\pi/2$) and the easy axis ($\\theta=0$) can be calculated from the fitted model. Let this be $\\Delta E_{\\text{fit}}$.\n$$E(\\pi/2) = K_1 \\sin^2(\\pi/2) + K_2 \\sin^4(\\pi/2) = K_1(1)^2 + K_2(1)^4 = K_1 + K_2$$\n$$E(0) = K_1 \\sin^2(0) + K_2 \\sin^4(0) = 0$$\nThus, the predicted energy difference is:\n$$\\Delta E_{\\text{fit}} = E(\\pi/2) - E(0) = \\hat{K}_1 + \\hat{K}_2$$\nThis value is to be compared with the directly provided energy difference, $\\Delta E_{\\text{direct}} = E(\\theta=\\pi/2) - E(\\theta=0)$, where the energy values are supplied independently of the torque data. The absolute difference $d = |\\Delta E_{\\text{fit}} - \\Delta E_{\\text{direct}}|$ is calculated and compared against a given tolerance $\\tau = 1.0$ $\\mu \\mathrm{eV}$ per formula unit. A consistency flag $c$ is set to $\\text{True}$ if $d \\le \\tau$, and $\\text{False}$ otherwise. This procedure validates the consistency between the differential (torque) and integral (total energy) data within the framework of the chosen model.\n\nThe implementation will construct the matrix $\\mathbf{X}$ and vector $\\mathbf{y}$ for each test case, solve for $\\hat{\\mathbf{k}}$ using `numpy.linalg.lstsq`, and then compute the required quantities for the consistency check.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for magnetocrystalline anisotropy coefficients and performs a consistency check\n    for a set of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (noiseless, moderate anisotropy)\n        {\n            \"angles\": np.array([np.pi/12, np.pi/6, np.pi/4, np.pi/3, 5*np.pi/12]),\n            \"torques\": np.array([-30.3349364905389, -54.1265877354711, -65.0, -58.45671475438329, -34.6650635094611]),\n            \"E0\": 0.0,\n            \"Epi_2\": 65.0\n        },\n        # Case 2 (noisy torque and energy data, same underlying scale)\n        {\n            \"angles\": np.array([np.pi/12, np.pi/6, np.pi/4, np.pi/3, 5*np.pi/12]),\n            \"torques\": np.array([-30.1349364905389, -54.2265877354711, -64.95, -58.45671475438329, -34.8150635094611]),\n            \"E0\": 0.0,\n            \"Epi_2\": 65.3\n        },\n        # Case 3 (vanishing fourth-order term)\n        {\n            \"angles\": np.array([np.pi/12, np.pi/6, np.pi/4, np.pi/3, 5*np.pi/12]),\n            \"torques\": np.array([-15.0, -25.98076211353316, -30.0, -25.98076211353316, -15.0]),\n            \"E0\": 0.0,\n            \"Epi_2\": 30.0\n        },\n        # Case 4 (very small anisotropy)\n        {\n            \"angles\": np.array([np.pi/12, np.pi/6, np.pi/4, np.pi/3, 5*np.pi/12]),\n            \"torques\": np.array([-0.5334936490538904, -1.0825317547305483, -1.5, -1.5155444566227678, -0.9665063509461097]),\n            \"E0\": 0.0,\n            \"Epi_2\": 1.5\n        }\n    ]\n\n    results = []\n    \n    # Consistency tolerance in micro-eV per formula unit\n    tolerance = 1.0\n\n    for case in test_cases:\n        angles = case[\"angles\"]\n        torques = case[\"torques\"]\n        E0 = case[\"E0\"]\n        Epi_2 = case[\"Epi_2\"]\n\n        # Construct the design matrix X and the observation vector y\n        # T(theta) = (-2*sin(theta)*cos(theta)) * K1 + (-4*sin^3(theta)*cos(theta)) * K2\n        \n        s = np.sin(angles)\n        c = np.cos(angles)\n        \n        # Column for K1 coefficient\n        col1 = -2 * s * c\n        \n        # Column for K2 coefficient\n        col2 = -4 * (s**3) * c\n        \n        # Design matrix X\n        X = np.vstack((col1, col2)).T\n        \n        # Observation vector y\n        y = torques\n        \n        # Solve the linear least-squares problem Xk = y for k = [K1, K2]\n        # np.linalg.lstsq returns the solution vector as the first element of a tuple.\n        k_hat, _, _, _ = np.linalg.lstsq(X, y, rcond=None)\n        K1_hat = k_hat[0]\n        K2_hat = k_hat[1]\n        \n        # Compute the energy difference from the fitted coefficients\n        # Delta_E_fit = E(pi/2) - E(0) = (K1_hat + K2_hat) - 0\n        delta_E_fit = K1_hat + K2_hat\n        \n        # Compute the direct energy difference from provided values\n        delta_E_direct = Epi_2 - E0\n        \n        # Compute the absolute difference\n        abs_diff = np.abs(delta_E_fit - delta_E_direct)\n        \n        # Check for consistency against the tolerance\n        is_consistent = abs_diff <= tolerance\n        \n        # Store results for this case\n        results.append([K1_hat, K2_hat, delta_E_direct, delta_E_fit, abs_diff, is_consistent])\n\n    # Format the final output string according to the problem specification.\n    # Each sublist is converted to a string, with spaces removed.\n    # These strings are then joined by commas and enclosed in brackets.\n    formatted_results = [str(r).replace(\" \", \"\") for r in results]\n    final_output = f\"[{','.join(formatted_results)}]\"\n    \n    # The final print statement must match the specified format exactly.\n    print(final_output)\n\nsolve()\n```", "id": "3462916"}, {"introduction": "High-fidelity computational results require a keen awareness of potential numerical artifacts. This practice addresses the \"egg-box effect,\" a spurious energy variation that arises from the discrete nature of simulation grids, which can break continuous rotational symmetry. By building a surrogate model, you will learn to distinguish true magnetocrystalline anisotropy from these grid-induced errors, an essential skill for validating the accuracy of first-principles calculations.", "problem": "You are tasked with constructing and analyzing a mathematically well-posed surrogate for magnetocrystalline anisotropy energy in a discrete real-space simulation, in order to validate numerical rotational invariance and quantify residual orientation-dependent integration errors (commonly known as the egg-box effect). The surrogate mimics the decomposition of total energy into a spin-independent scalar contribution and a spin-orientation-dependent contribution due to Spin-Orbit Coupling (SOC). All quantities in this problem are dimensionless. All angles must be expressed in radians.\n\nThe scientific starting points you must use are:\n\n- A scalar integral of a bounded function over a domain is invariant under uniform rotation of coordinates in the continuum limit, while discrete uniform-grid quadratures can break this invariance by orientation-dependent sampling. This artificial angular dependence is an egg-box error.\n- Magnetocrystalline anisotropy arises from Spin-Orbit Coupling (SOC), which depends only on the relative orientation between the magnetization direction and crystallographic axes. Under co-rotation of both spin and lattice frames, the SOC contribution remains unchanged because the relative orientation is fixed.\n\nConstruct the following surrogate model.\n\n1. Geometry and lattice rotation. Consider a square periodic cell of side length $L$ with periodic boundary conditions. Let $L=10.0$. Let the cell center be $\\mathbf{C}=(L/2,L/2)$. Place $N_a=3$ atomic sites with reference displacement vectors about the center:\n   - $\\mathbf{r}_1'=(a,0)$,\n   - $\\mathbf{r}_2'=(-a/2,b)$,\n   - $\\mathbf{r}_3'=(-a/2,-b)$,\n   with $a=1.75$ and $b=1.10$. For a lattice rotation angle $\\theta_{\\mathrm{lat}}$, define the physical atomic positions as $\\mathbf{R}_i(\\theta_{\\mathrm{lat}})=\\mathbf{C}+\\mathbf{R}(\\theta_{\\mathrm{lat}})\\,\\mathbf{r}_i'$, where $\\mathbf{R}(\\theta)$ is the $2\\times 2$ rotation matrix.\n\n2. Electron density surrogate. Define the continuous electron density $\\rho(\\mathbf{r};\\theta_{\\mathrm{lat}})$ as a sum of Gaussians centered at the rotated atomic positions:\n   $$\\rho(\\mathbf{r};\\theta_{\\mathrm{lat}})=\\sum_{i=1}^{3}\\exp\\!\\left(-\\frac{\\|\\mathbf{r}-\\mathbf{R}_i(\\theta_{\\mathrm{lat}})\\|_{\\mathrm{pbc}}^2}{2\\sigma^2}\\right),$$\n   where $\\sigma > 0$ is a width parameter and $\\|\\cdot\\|_{\\mathrm{pbc}}$ denotes the minimum-image norm under periodic boundary conditions on the square of side $L$.\n\n3. Spin-orbit coupling surrogate. Let the spin direction be a unit vector in the plane, $\\mathbf{s}(\\theta_{\\mathrm{spin}})=(\\cos\\theta_{\\mathrm{spin}},\\sin\\theta_{\\mathrm{spin}})$. Assume a lowest-order uniaxial anisotropy that depends only on the relative angle $\\Delta=\\theta_{\\mathrm{spin}}-\\theta_{\\mathrm{lat}}$, with a constant $K_u > 0$:\n   $$E_{\\mathrm{SOC}}(\\Delta)=K_u\\,\\sin^2(\\Delta).$$\n   Use $K_u=0.015$.\n\n4. Total energy surrogate and two rotation protocols. The total energy at angle pair $(\\theta_{\\mathrm{lat}},\\theta_{\\mathrm{spin}})$ is\n   $$E_{\\mathrm{tot}}(\\theta_{\\mathrm{lat}},\\theta_{\\mathrm{spin}})=\\left(\\int_{\\Omega} \\rho(\\mathbf{r};\\theta_{\\mathrm{lat}})^2\\,\\mathrm{d}^2 r\\right)+E_{\\mathrm{SOC}}(\\theta_{\\mathrm{spin}}-\\theta_{\\mathrm{lat}}),$$\n   where $\\Omega$ is the periodic cell. In the continuum, the scalar integral is strictly invariant under rotation of $\\theta_{\\mathrm{lat}}$, but a discrete uniform grid quadrature can introduce an artificial angular dependence. To expose and quantify this, approximate the integral with a uniform $N\\times N$ grid using the trapezoidal rule on the periodic domain:\n   $$\\int_{\\Omega} f(\\mathbf{r})\\,\\mathrm{d}^2 r \\approx \\frac{L^2}{N^2}\\sum_{j=0}^{N-1}\\sum_{k=0}^{N-1} f(x_j,y_k),\\quad x_j=\\frac{jL}{N},\\;y_k=\\frac{kL}{N}.$$\n   Consider two rotation protocols:\n   - Co-rotation protocol: $\\theta_{\\mathrm{spin}}=\\theta_{\\mathrm{lat}}=\\theta$. Then $E_{\\mathrm{SOC}}$ is constant in $\\theta$, and any angular variation of $E_{\\mathrm{tot}}$ arises from egg-box error only.\n   - Spin-only protocol: $\\theta_{\\mathrm{lat}}=0$ is fixed, and $\\theta_{\\mathrm{spin}}=\\theta$ varies. Then the discrete scalar integral is constant in $\\theta$, and the angular variation of $E_{\\mathrm{tot}}$ is due solely to $E_{\\mathrm{SOC}}$.\n\n5. Angle sampling. For any protocol, sample $\\theta$ uniformly over $[0,2\\pi)$ at $M$ points, with $M=72$. That is, $\\theta_m=\\frac{2\\pi m}{M}$ for $m=0,1,\\dots,M-1$.\n\nYour program must implement the above surrogate and perform the following test suite. All angles are in radians. All reported outputs must be single real numbers (floats).\n\n- Test case A (happy path, moderate grid): Co-rotation protocol with $N=64$ and $\\sigma=0.25$. Compute the root-mean-square egg-box amplitude\n  $$A_{\\mathrm{rms}}=\\sqrt{\\frac{1}{M}\\sum_{m=0}^{M-1}\\left(E_{\\mathrm{tot}}(\\theta_m,\\theta_m)-\\overline{E}\\right)^2},\\quad \\overline{E}=\\frac{1}{M}\\sum_{m=0}^{M-1}E_{\\mathrm{tot}}(\\theta_m,\\theta_m).$$\n  Output this as the first number.\n- Test case B (refinement, fine grid): Co-rotation protocol with $N=192$ and $\\sigma=0.25$. Compute $A_{\\mathrm{rms}}$ as above. Output this as the second number.\n- Test case C (anisotropy identification): Spin-only protocol with $N=96$, $\\sigma=0.25$, $\\theta_{\\mathrm{lat}}=0$. Compute $E_m=E_{\\mathrm{tot}}(0,\\theta_m)$ for the $M$ angles, then perform a least-squares fit of the model $E_m\\approx A\\sin^2(\\theta_m)+B$ over all $M$ samples. Output the fitted coefficient $A$ as the third number (this estimates $K_u$).\n- Test case D (edge case, smoother density): Co-rotation protocol with $N=64$ and $\\sigma=0.70$. Compute $A_{\\mathrm{rms}}$ as above. Output this as the fourth number.\n\nFinal output format. Your program should produce a single line of output containing the four numerical results in order, as a comma-separated list enclosed in square brackets (e.g., \"[r1,r2,r3,r4]\"). There must be no additional text.\n\nScientific realism and derivation requirements. You must:\n- Start from the definitions given above, using the invariance of scalar integrals under rotation, the presence of SOC-induced anisotropy dependent only on relative angles, and the effect of discrete sampling breaking rotational invariance.\n- Implement periodic boundary conditions via the minimum-image convention to evaluate $\\rho(\\mathbf{r};\\theta_{\\mathrm{lat}})$.\n- Use only the stated parameters: $L=10.0$, $a=1.75$, $b=1.10$, $K_u=0.015$, $M=72$, and the $N,\\sigma$ values specified per test case.\n- Ensure all computations are deterministic and purely numerical, with no random elements.", "solution": "The problem presents a valid, well-posed computational task. All parameters and functions are clearly defined, and the premises are scientifically sound for constructing a surrogate model to investigate numerical artifacts in materials simulations. The objective is to implement a surrogate model for magnetocrystalline anisotropy energy to quantify the \"egg-box effect,\" a numerical error arising from discrete grid-based integration that breaks continuous rotational symmetry.\n\nThe solution proceeds by first constructing the components of the surrogate model as defined, then implementing the two specified rotation protocols to calculate the required physical quantities for each test case.\n\n**1. Surrogate Model Construction**\n\nThe total energy $E_{\\mathrm{tot}}$ is composed of a scalar field integral and a spin-orbit coupling (SOC) term:\n$$E_{\\mathrm{tot}}(\\theta_{\\mathrm{lat}},\\theta_{\\mathrm{spin}})=\\left(\\int_{\\Omega} \\rho(\\mathbf{r};\\theta_{\\mathrm{lat}})^2\\,\\mathrm{d}^2 r\\right)+E_{\\mathrm{SOC}}(\\theta_{\\mathrm{spin}}-\\theta_{\\mathrm{lat}})$$\nwhere $\\theta_{\\mathrm{lat}}$ is the lattice rotation angle and $\\theta_{\\mathrm{spin}}$ is the spin (magnetization) angle.\n\n**1.1. Geometry and Electron Density**\n\nThe model is defined on a two-dimensional square periodic cell $\\Omega$ of side length $L=10.0$. The electron density $\\rho$ is represented by a sum of three Gaussian functions centered on atomic sites. The reference positions of these sites are $\\mathbf{r}_1'=(a,0)$, $\\mathbf{r}_2'=(-a/2,b)$, and $\\mathbf{r}_3'=(-a/2,-b)$, with $a=1.75$ and $b=1.10$.\n\nFor a given lattice rotation angle $\\theta_{\\mathrm{lat}}$, the physical atomic positions $\\mathbf{R}_i$ are found by rotating the reference vectors $\\mathbf{r}_i'$ around the cell center $\\mathbf{C}=(L/2, L/2)$:\n$$\\mathbf{R}_i(\\theta_{\\mathrm{lat}}) = \\mathbf{C} + \\mathbf{R}(\\theta_{\\mathrm{lat}})\\mathbf{r}_i'$$\nwhere $\\mathbf{R}(\\theta_{\\mathrm{lat}})$ is the standard $2\\times 2$ rotation matrix:\n$$\\mathbf{R}(\\theta_{\\mathrm{lat}}) = \\begin{pmatrix} \\cos\\theta_{\\mathrm{lat}} & -\\sin\\theta_{\\mathrm{lat}} \\\\ \\sin\\theta_{\\mathrm{lat}} & \\cos\\theta_{\\mathrm{lat}} \\end{pmatrix}$$\n\nThe continuous electron density at a point $\\mathbf{r}=(x,y)$ is given by:\n$$\\rho(\\mathbf{r};\\theta_{\\mathrm{lat}})=\\sum_{i=1}^{3}\\exp\\!\\left(-\\frac{\\|\\mathbf{r}-\\mathbf{R}_i(\\theta_{\\mathrm{lat}})\\|_{\\mathrm{pbc}}^2}{2\\sigma^2}\\right)$$\nThe term $\\|\\mathbf{v}\\|_{\\mathrm{pbc}}$ denotes the L2-norm of the vector $\\mathbf{v}$ under the minimum-image convention (MIC) for periodic boundary conditions. For a vector component $v_k$, its MIC counterpart $v_{k, \\text{mic}}$ is calculated as $v_{k, \\text{mic}} = v_k - L \\cdot \\text{round}(v_k/L)$.\n\n**1.2. Numerical Integration**\n\nThe integral term of the total energy is approximated using a summation over a uniform $N \\times N$ grid. The grid points are $(x_j, y_k)$ where $x_j=jL/N$ and $y_k=kL/N$ for $j,k \\in \\{0, 1, \\dots, N-1\\}$. The trapezoidal rule on a periodic domain simplifies to a simple sum:\n$$\\int_{\\Omega} \\rho(\\mathbf{r};\\theta_{\\mathrm{lat}})^2\\,\\mathrm{d}^2 r \\approx \\frac{L^2}{N^2}\\sum_{j=0}^{N-1}\\sum_{k=0}^{N-1} \\rho(x_j, y_k; \\theta_{\\mathrm{lat}})^2$$\nThe term $\\Delta A = L^2/N^2$ is the area element of each grid cell.\n\n**1.3. Spin-Orbit Coupling (SOC) Term**\n\nThe SOC energy surrogate depends only on the relative angle $\\Delta = \\theta_{\\mathrm{spin}} - \\theta_{\\mathrm{lat}}$:\n$$E_{\\mathrm{SOC}}(\\Delta)=K_u\\,\\sin^2(\\Delta)$$\nwith the anisotropy constant given as $K_u = 0.015$.\n\n**2. Rotation Protocols and Analysis**\n\nThe problem specifies two protocols to disentangle the numerical error from the physical anisotropy. The angles are sampled at $M=72$ points, $\\theta_m = 2\\pi m/M$ for $m=0, \\dots, M-1$.\n\n**2.1. Co-rotation Protocol (Test Cases A, B, D)**\n\nIn this protocol, $\\theta_{\\mathrm{spin}} = \\theta_{\\mathrm{lat}} = \\theta_m$. The relative angle $\\Delta$ is always zero, so $E_{\\mathrm{SOC}} = K_u\\sin^2(0) = 0$. The total energy becomes:\n$$E_{\\mathrm{tot}}(\\theta_m, \\theta_m) = \\int_{\\Omega} \\rho(\\mathbf{r};\\theta_m)^2\\,\\mathrm{d}^2 r$$\nIn the continuum limit, this integral is independent of $\\theta_m$. However, the discrete numerical integration introduces an artificial dependence on $\\theta_m$, which is the egg-box error. We quantify this error by its root-mean-square (RMS) amplitude:\n$$A_{\\mathrm{rms}}=\\sqrt{\\frac{1}{M}\\sum_{m=0}^{M-1}\\left(E_{\\mathrm{tot}}(\\theta_m,\\theta_m)-\\overline{E}\\right)^2}, \\quad \\text{where} \\quad \\overline{E}=\\frac{1}{M}\\sum_{m=0}^{M-1}E_{\\mathrm{tot}}(\\theta_m,\\theta_m)$$\nThis calculation is performed for three different sets of parameters $(N, \\sigma)$.\n\n**2.2. Spin-only Protocol (Test Case C)**\n\nHere, the lattice is fixed at $\\theta_{\\mathrm{lat}} = 0$, while the spin angle varies, $\\theta_{\\mathrm{spin}} = \\theta_m$. The integral term becomes a constant, $C = \\int_{\\Omega} \\rho(\\mathbf{r};0)^2\\,\\mathrm{d}^2 r$, independent of $\\theta_m$. The total energy varies only due to the SOC term:\n$$E_{\\mathrm{tot}}(0, \\theta_m) = C + E_{\\mathrm{SOC}}(\\theta_m) = C + K_u \\sin^2(\\theta_m)$$\nWe compute the energy $E_m = E_{\\mathrm{tot}}(0, \\theta_m)$ for all $M$ angles. To recover the anisotropy constant from these computed energies, we perform a linear least-squares fit to the model $E_m \\approx A\\sin^2(\\theta_m)+B$. The fitted parameter $A$ should be an estimate of the true value $K_u$. This is a standard linear regression problem where the vector of observed energies $\\mathbf{E} = [E_0, \\dots, E_{M-1}]^T$ is fit against a design matrix $\\mathbf{X}$ whose columns are the basis functions $[\\sin^2(\\theta_0), \\dots, \\sin^2(\\theta_{M-1})]^T$ and $[1, \\dots, 1]^T$. The parameters $\\mathbf{p} = [A, B]^T$ are found by solving the normal equations $(\\mathbf{X}^T\\mathbf{X})\\mathbf{p} = \\mathbf{X}^T\\mathbf{E}$.\n\nThe implementation will consist of a primary function to calculate $E_{\\mathrm{tot}}$ for any given set of parameters $(\\theta_{\\mathrm{lat}}, \\theta_{\\mathrm{spin}}, N, \\sigma)$, which is then called within loops that execute the logic for each of the four test cases.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the surrogate model for magnetocrystalline anisotropy,\n    runs the specified test suite, and prints the results.\n    \"\"\"\n    # Global constants defined in the problem statement\n    L = 10.0\n    A_PARAM = 1.75\n    B_PARAM = 1.10\n    KU = 0.015\n    M = 72\n\n    def calculate_total_energy(theta_lat, theta_spin, N, sigma):\n        \"\"\"\n        Calculates the total energy for a given configuration.\n\n        Args:\n            theta_lat (float): Lattice rotation angle in radians.\n            theta_spin (float): Spin direction angle in radians.\n            N (int): Grid dimension (N x N).\n            sigma (float): Width of the Gaussian functions.\n\n        Returns:\n            float: The total energy E_tot.\n        \"\"\"\n        # 1. Generate the uniform grid\n        # The grid points are x_j = jL/N, y_k = kL/N\n        grid_coords = np.linspace(0, L, N, endpoint=False)\n        x_grid, y_grid = np.meshgrid(grid_coords, grid_coords)\n\n        # 2. Calculate rotated atomic positions\n        center = L / 2.0\n        rot_matrix = np.array([\n            [np.cos(theta_lat), -np.sin(theta_lat)],\n            [np.sin(theta_lat), np.cos(theta_lat)]\n        ])\n        \n        # Reference displacement vectors\n        r_primes = np.array([\n            [A_PARAM, 0.0],\n            [-A_PARAM / 2.0, B_PARAM],\n            [-A_PARAM / 2.0, -B_PARAM]\n        ])\n\n        # Apply rotation and shift from center\n        # r_primes (3, 2) @ rot_matrix.T (2, 2) -> (3, 2)\n        atom_positions = center + r_primes @ rot_matrix.T\n\n        # 3. Calculate electron density on the grid\n        rho_total = np.zeros_like(x_grid)\n        for pos in atom_positions:\n            dx = x_grid - pos[0]\n            dy = y_grid - pos[1]\n            \n            # Apply minimum image convention for periodic boundary conditions\n            dx = (dx + L / 2.0) % L - L / 2.0\n            dy = (dy + L / 2.0) % L - L / 2.0\n            \n            dist_sq = dx**2 + dy**2\n            rho_total += np.exp(-dist_sq / (2.0 * sigma**2))\n\n        # 4. Calculate the integral term of the energy\n        # The integral is approximated by a sum over the grid\n        integral_term = (L**2 / N**2) * np.sum(rho_total**2)\n\n        # 5. Calculate the spin-orbit coupling (SOC) term\n        soc_term = KU * np.sin(theta_spin - theta_lat)**2\n        \n        return integral_term + soc_term\n\n    results = []\n    thetas = np.linspace(0, 2 * np.pi, M, endpoint=False)\n\n    # Test case A: Co-rotation, N=64, sigma=0.25\n    N_A, sigma_A = 64, 0.25\n    energies_A = np.array([calculate_total_energy(th, th, N_A, sigma_A) for th in thetas])\n    rms_A = np.sqrt(np.mean((energies_A - np.mean(energies_A))**2))\n    results.append(rms_A)\n\n    # Test case B: Co-rotation, N=192, sigma=0.25\n    N_B, sigma_B = 192, 0.25\n    energies_B = np.array([calculate_total_energy(th, th, N_B, sigma_B) for th in thetas])\n    rms_B = np.sqrt(np.mean((energies_B - np.mean(energies_B))**2))\n    results.append(rms_B)\n\n    # Test case C: Spin-only, N=96, sigma=0.25, theta_lat=0\n    N_C, sigma_C = 96, 0.25\n    theta_lat_C = 0.0\n    energies_C = np.array([calculate_total_energy(theta_lat_C, th, N_C, sigma_C) for th in thetas])\n    \n    # Perform least-squares fit for E = A*sin^2(theta) + B\n    design_matrix = np.vstack([np.sin(thetas)**2, np.ones(M)]).T\n    fit_params, _, _, _ = np.linalg.lstsq(design_matrix, energies_C, rcond=None)\n    A_fit = fit_params[0]\n    results.append(A_fit)\n\n    # Test case D: Co-rotation, N=64, sigma=0.70\n    N_D, sigma_D = 64, 0.70\n    energies_D = np.array([calculate_total_energy(th, th, N_D, sigma_D) for th in thetas])\n    rms_D = np.sqrt(np.mean((energies_D - np.mean(energies_D))**2))\n    results.append(rms_D)\n    \n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.12e}' for r in results)}]\")\n\nsolve()\n```", "id": "3462825"}]}