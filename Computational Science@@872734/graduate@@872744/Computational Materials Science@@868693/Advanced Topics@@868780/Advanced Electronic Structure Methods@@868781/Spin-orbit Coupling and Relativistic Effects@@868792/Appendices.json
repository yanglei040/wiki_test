{"hands_on_practices": [{"introduction": "To begin our hands-on exploration of spin-orbit coupling, we will implement and analyze one of the most fundamental models in the field: the Rashba Hamiltonian for a two-dimensional electron gas. This exercise guides you through translating a continuum effective model into a numerical, matrix-based representation on a discrete momentum-space grid. Beyond just calculating the energy bands, this practice emphasizes the critical skills of a computational scientist: verifying the accuracy of a numerical integration through convergence testing, leveraging crystal symmetry to reduce computational cost, and assessing the numerical stability of the underlying calculations [@problem_id:3488606]. Mastering these concepts provides a robust foundation for tackling more complex computational problems involving relativistic effects.", "problem": "Consider a two-dimensional electron gas on a square lattice modeled in dimensionless units where the lattice constant $a$ is set to $1$, the reduced Planck constant $\\hbar$ is set to $1$, and the effective mass $m$ is set to $1$. The system exhibits spin-orbit coupling arising from relativistic effects. For computational purposes, model the system in momentum space with the following effective Hamiltonian at a wavevector $\\mathbf{k} = (k_x,k_y)$:\n$$\nH(\\mathbf{k}) = \\frac{k_x^2 + k_y^2}{2}\\, I_2 + \\alpha \\left(k_y\\, \\sigma_x - k_x\\, \\sigma_y \\right) + \\eta\\, I_2,\n$$\nwhere $I_2$ is the $2 \\times 2$ identity matrix, $\\sigma_x$ and $\\sigma_y$ are Pauli matrices, $\\alpha$ is the dimensionless spin-orbit coupling strength, and $\\eta$ is a small positive regularization added to the diagonal to mitigate numerical instabilities. All quantities are dimensionless.\n\nStarting from fundamental principles of spin-orbit coupling and time-reversal symmetry, you must design a program that:\n$1.$ Constructs $H(\\mathbf{k})$ for a uniform rectangular sampling of the Brillouin zone with $k_x, k_y \\in [-\\pi,\\pi]$ using a uniform $N \\times N$ grid.\n$2.$ For each $\\mathbf{k}$ on the grid, computes the two eigenvalues $E_1(\\mathbf{k})$ and $E_2(\\mathbf{k})$ of $H(\\mathbf{k})$ and defines the energy splitting $\\Delta(\\mathbf{k}) = |E_1(\\mathbf{k}) - E_2(\\mathbf{k})|$.\n$3.$ Computes the average energy splitting over the full grid,\n$$\n\\langle \\Delta \\rangle_{N} = \\frac{1}{N^2} \\sum_{i=1}^{N} \\sum_{j=1}^{N} \\Delta(k_x^{(i)}, k_y^{(j)}),\n$$\nwhere $k_x^{(i)}$ and $k_y^{(j)}$ are the uniformly spaced grid points in $[-\\pi,\\pi]$.\n$4.$ Implements a symmetry reduction by sampling only the first quadrant with $k_x, k_y \\in [0,\\pi]$ on an $N \\times N$ grid, and reconstructs the full-grid average by weights induced by time-reversal symmetry and sign reflections. Specifically, assign a weight $w(\\mathbf{k})$ to each sampled point as follows: if $k_x = 0$ and $k_y = 0$, use $w(\\mathbf{k}) = 1$; if exactly one of $k_x$ or $k_y$ is zero, use $w(\\mathbf{k}) = 2$; otherwise use $w(\\mathbf{k}) = 4$. Define the symmetry-reduced average\n$$\n\\langle \\Delta \\rangle_{N}^{\\mathrm{sym}} = \\frac{\\sum_{i=1}^{N} \\sum_{j=1}^{N} w(k_x^{(i)}, k_y^{(j)}) \\, \\Delta(k_x^{(i)}, k_y^{(j)})}{\\sum_{i=1}^{N} \\sum_{j=1}^{N} w(k_x^{(i)}, k_y^{(j)})},\n$$\nwhere now $k_x^{(i)}, k_y^{(j)} \\in [0,\\pi]$.\n$5.$ Tests convergence by computing $\\langle \\Delta \\rangle_{N}$ and $\\langle \\Delta \\rangle_{2N}$ and then evaluating\n$$\n\\delta_{\\mathrm{conv}} = \\left| \\langle \\Delta \\rangle_{2N} - \\langle \\Delta \\rangle_{N} \\right|,\n$$\nand reporting whether $\\delta_{\\mathrm{conv}} \\le \\varepsilon$ for a given tolerance $\\varepsilon$.\n$6.$ Tests the accuracy of the symmetry reduction by computing the absolute difference\n$$\n\\delta_{\\mathrm{sym}} = \\left| \\langle \\Delta \\rangle_{N} - \\langle \\Delta \\rangle_{N}^{\\mathrm{sym}} \\right|.\n$$\n$7.$ Evaluates numerical stability by computing, at each $\\mathbf{k}$, the condition number\n$$\n\\kappa(H(\\mathbf{k})) = \\frac{s_{\\max}(H(\\mathbf{k}))}{s_{\\min}(H(\\mathbf{k}))},\n$$\nwhere $s_{\\max}$ and $s_{\\min}$ are the largest and smallest singular values of $H(\\mathbf{k})$, respectively. Report whether $\\max_{\\mathbf{k}} \\kappa(H(\\mathbf{k})) \\le \\kappa_{\\max}$ for a given threshold $\\kappa_{\\max}$.\n\nYour program must implement all of the above and produce results for the following test suite of parameter sets $(\\alpha, N, \\eta, \\varepsilon, \\kappa_{\\max})$:\n$1.$ $(0.0, 25, 10^{-8}, 10^{-9}, 10^{8})$,\n$2.$ $(0.01, 25, 10^{-8}, 10^{-6}, 10^{6})$,\n$3.$ $(0.10, 25, 10^{-8}, 10^{-5}, 10^{6})$,\n$4.$ $(1.00, 25, 10^{-8}, 10^{-5}, 10^{7})$,\n$5.$ $(2.00, 25, 10^{-6}, 10^{-4}, 10^{7})$.\n\nFor each parameter set, your program must compute and output three values in order: the boolean for convergence with tolerance (true if $\\delta_{\\mathrm{conv}} \\le \\varepsilon$), the float $\\delta_{\\mathrm{sym}}$, and the boolean for stability threshold (true if $\\max_{\\mathbf{k}} \\kappa(H(\\mathbf{k})) \\le \\kappa_{\\max}$). All computed quantities are dimensionless. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with the values for test case $1$ followed by test case $2$, and so on, for a total of $15$ entries. For example, the output format should be exactly like $[v_1,v_2,\\dots,v_{15}]$ where each $v_i$ is either a boolean or a float.", "solution": "The problem requires the analysis of a two-dimensional electron gas on a square lattice, described by a specific effective Hamiltonian in momentum space. The analysis involves computing average energy splittings, testing convergence, evaluating a symmetry reduction scheme, and assessing numerical stability.\n\nFirst, we validate the problem statement.\n\n### Step 1: Extract Givens\n- **Dimensionless Units**: Lattice constant $a=1$, reduced Planck constant $\\hbar=1$, effective mass $m=1$.\n- **System**: Two-dimensional electron gas on a square lattice with spin-orbit coupling.\n- **Hamiltonian**: $H(\\mathbf{k}) = \\frac{k_x^2 + k_y^2}{2}\\, I_2 + \\alpha \\left(k_y\\, \\sigma_x - k_x\\, \\sigma_y \\right) + \\eta\\, I_2$ for a wavevector $\\mathbf{k} = (k_x, k_y)$.\n- **Definitions**: $I_2$ is the $2 \\times 2$ identity matrix, $\\sigma_x$ and $\\sigma_y$ are Pauli matrices, $\\alpha$ is the spin-orbit coupling strength, and $\\eta$ is a positive regularization parameter.\n- **Task 1**: Construct $H(\\mathbf{k})$ for a uniform $N \\times N$ grid with $k_x, k_y \\in [-\\pi,\\pi]$.\n- **Task 2**: Compute eigenvalues $E_1(\\mathbf{k})$, $E_2(\\mathbf{k})$ and the splitting $\\Delta(\\mathbf{k}) = |E_1(\\mathbf{k}) - E_2(\\mathbf{k})|$.\n- **Task 3**: Compute the full-grid average $\\langle \\Delta \\rangle_{N} = \\frac{1}{N^2} \\sum_{i,j} \\Delta(k_x^{(i)}, k_y^{(j)})$ for $(k_x^{(i)}, k_y^{(j)})$ on the $N \\times N$ grid over $[-\\pi, \\pi]^2$.\n- **Task 4**: Implement a symmetry reduction. Sample $k_x, k_y \\in [0,\\pi]$ on an $N \\times N$ grid. Use weights $w(\\mathbf{k})=1$ at $(0,0)$, $w(\\mathbf{k})=2$ on axes (excluding origin), and $w(\\mathbf{k})=4$ otherwise. Compute the symmetry-reduced average $\\langle \\Delta \\rangle_{N}^{\\mathrm{sym}} = \\frac{\\sum_{i,j} w(k_x^{(i)}, k_y^{(j)}) \\, \\Delta(k_x^{(i)}, k_y^{(j)})}{\\sum_{i,j} w(k_x^{(i)}, k_y^{(j)})}$ for $(k_x^{(i)}, k_y^{(j)})$ on the $N \\times N$ grid over $[0, \\pi]^2$.\n- **Task 5**: Test convergence by evaluating $\\delta_{\\mathrm{conv}} = \\left| \\langle \\Delta \\rangle_{2N} - \\langle \\Delta \\rangle_{N} \\right|$ and checking if $\\delta_{\\mathrm{conv}} \\le \\varepsilon$.\n- **Task 6**: Test symmetry reduction accuracy by computing $\\delta_{\\mathrm{sym}} = \\left| \\langle \\Delta \\rangle_{N} - \\langle \\Delta \\rangle_{N}^{\\mathrm{sym}} \\right|$.\n- **Task 7**: Test numerical stability by finding the maximum condition number $\\kappa(H(\\mathbf{k})) = \\frac{s_{\\max}(H(\\mathbf{k}))}{s_{\\min}(H(\\mathbf{k}))}$ over the full grid and checking if it is below a threshold $\\kappa_{\\max}$.\n- **Test Suite**:\n  1. $(\\alpha, N, \\eta, \\varepsilon, \\kappa_{\\max}) = (0.0, 25, 10^{-8}, 10^{-9}, 10^{8})$\n  2. $(\\alpha, N, \\eta, \\varepsilon, \\kappa_{\\max}) = (0.01, 25, 10^{-8}, 10^{-6}, 10^{6})$\n  3. $(\\alpha, N, \\eta, \\varepsilon, \\kappa_{\\max}) = (0.10, 25, 10^{-8}, 10^{-5}, 10^{6})$\n  4. $(\\alpha, N, \\eta, \\varepsilon, \\kappa_{\\max}) = (1.00, 25, 10^{-8}, 10^{-5}, 10^{7})$\n  5. $(\\alpha, N, \\eta, \\varepsilon, \\kappa_{\\max}) = (2.00, 25, 10^{-6}, 10^{-4}, 10^{7})$\n\n### Step 2: Validate Using Extracted Givens\n- **Scientific Grounding**: The Hamiltonian is the standard Rashba spin-orbit coupling Hamiltonian for a 2D electron gas. The terms represent kinetic energy, spin-orbit interaction, and a constant energy shift, respectively. This model is a cornerstone in solid-state physics and computational materials science. The use of Pauli matrices is standard for spin-$1/2$ systems. The problem is scientifically sound.\n- **Well-Posedness**: All tasks are defined with explicit mathematical formulas and algorithms. The inputs are clearly specified, and the required outputs are unique numerical or boolean values.\n- **Objectivity**: The problem is stated in precise, formal language, free of any subjectivity or ambiguity.\n- **Flaw Analysis**:\n  1.  **Scientific/Factual Unsoundness**: None. The model is physically valid.\n  2.  **Non-Formalizable/Irrelevant**: None. The problem is a formalizable computational task directly relevant to the specified topic.\n  3.  **Incomplete/Contradictory Setup**: None. All necessary parameters and definitions for the computations are provided. The grid definitions and averaging procedures are explicit.\n  4.  **Unrealistic/Infeasible**: None. The parameters are within reasonable ranges for such models, and the computational tasks are feasible.\n  5.  **Ill-Posed/Poorly Structured**: None. The problem is structured as a series of well-defined computational steps leading to a unique solution.\n  6.  **Pseudo-Profound/Trivial**: The problem requires a non-trivial implementation of numerical methods grounded in physical principles, covering concepts of numerical integration, symmetry, convergence, and stability. It is not trivial.\n  7.  **Outside Scientific Verifiability**: None. The results are computationally verifiable.\n\n### Step 3: Verdict and Action\nThe problem is valid. We proceed with the solution.\n\n### Principle-Based Design and Solution\n\nThe core of the problem lies in the analysis of the Hamiltonian $H(\\mathbf{k})$. Let us first determine its properties analytically, which will significantly simplify the computational tasks.\n\nThe given Hamiltonian is:\n$$\nH(\\mathbf{k}) = \\frac{k_x^2 + k_y^2}{2}\\, I_2 + \\alpha \\left(k_y\\, \\sigma_x - k_x\\, \\sigma_y \\right) + \\eta\\, I_2\n$$\nThe Pauli matrices are $\\sigma_x = \\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix}$ and $\\sigma_y = \\begin{pmatrix} 0 & -i \\\\ i & 0 \\end{pmatrix}$. Substituting these into the Hamiltonian gives the explicit matrix form:\n$$\nH(\\mathbf{k}) = \\frac{k_x^2 + k_y^2}{2} \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} + \\alpha \\left( k_y \\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix} - k_x \\begin{pmatrix} 0 & -i \\\\ i & 0 \\end{pmatrix} \\right) + \\eta \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix}\n$$\n$$\nH(\\mathbf{k}) = \\begin{pmatrix} \\frac{k_x^2+k_y^2}{2}+\\eta & \\alpha(k_y + ik_x) \\\\ \\alpha(k_y - ik_x) & \\frac{k_x^2+k_y^2}{2}+\\eta \\end{pmatrix}\n$$\nThis is a $2 \\times 2$ Hermitian matrix of the form $\\begin{pmatrix} A & C \\\\ C^* & A \\end{pmatrix}$. Its eigenvalues $E$ are given by the solutions to the characteristic equation $\\det(H - E I_2) = 0$, which simplifies to $(A - E)^2 - |C|^2 = 0$. Thus, the eigenvalues are $E = A \\pm |C|$.\n\nHere, $A = \\frac{k_x^2+k_y^2}{2} + \\eta$ and $|C| = |\\alpha(k_y + ik_x)| = |\\alpha|\\sqrt{k_y^2 + k_x^2}$. Let $k = \\sqrt{k_x^2 + k_y^2}$ be the magnitude of the wavevector. The two eigenvalues are:\n$$\nE_{\\pm}(\\mathbf{k}) = \\frac{k^2}{2} + \\eta \\pm |\\alpha| k\n$$\nThis analytical result is crucial as it obviates the need for numerical diagonalization of the matrix $H(\\mathbf{k})$ at each point on the grid, leading to a highly efficient algorithm.\n\n**Task 2: Energy Splitting**\nThe energy splitting $\\Delta(\\mathbf{k})$ is the absolute difference between the two eigenvalues:\n$$\n\\Delta(\\mathbf{k}) = |E_{+}(\\mathbf{k}) - E_{-}(\\mathbf{k})| = \\left| \\left(\\frac{k^2}{2} + \\eta + |\\alpha| k\\right) - \\left(\\frac{k^2}{2} + \\eta - |\\alpha| k\\right) \\right| = |2 |\\alpha| k| = 2 |\\alpha| \\sqrt{k_x^2 + k_y^2}\n$$\n\n**Task 3: Full-Grid Average $\\langle \\Delta \\rangle_{N}$**\nTo compute the average splitting, we first define a uniform $N \\times N$ grid of points $(k_x, k_y)$ in the domain $[-\\pi, \\pi] \\times [-\\pi, \\pi]$. This is achieved by creating linearly spaced points for $k_x$ and $k_y$ separately and then forming a grid. For each point on this grid, we compute $\\Delta(\\mathbf{k})$ using the derived analytical formula and then take the arithmetic mean over all $N^2$ grid points.\n\n**Task 4: Symmetry-Reduced Average $\\langle \\Delta \\rangle_{N}^{\\mathrm{sym}}$**\nThe function $\\Delta(\\mathbf{k}) = 2|\\alpha|k$ depends only on the magnitude $k = \\sqrt{k_x^2+k_y^2}$. This function exhibits high symmetry: $\\Delta(k_x, k_y) = \\Delta(\\pm k_x, \\pm k_y)$. This means its value is identical in all four quadrants of the Brillouin zone. Consequently, the average over the full zone can be efficiently estimated by averaging over just the first quadrant, $[0, \\pi] \\times [0, \\pi]$, with appropriate weighting for points on the boundaries. The weights account for the multiplicity of points when reflected into the other quadrants:\n- A point $(k_x, k_y)$ with $k_x > 0, k_y > 0$ has $4$ equivalent points in the full zone. Weight $w=4$.\n- A point on an axis, $(k_x, 0)$ with $k_x > 0$ or $(0, k_y)$ with $k_y > 0$, has $2$ equivalent points. Weight $w=2$.\n- The origin $(0,0)$ is unique. Weight $w=1$.\nThe symmetry-reduced average is the weighted average over the $N \\times N$ grid in the first quadrant, as specified by the formula for $\\langle \\Delta \\rangle_{N}^{\\mathrm{sym}}$.\n\n**Task 5: Convergence Test**\nThe calculation of $\\langle \\Delta \\rangle_{N}$ is a numerical approximation of the integral $I = \\frac{1}{(2\\pi)^2} \\int_{-\\pi}^{\\pi} \\int_{-\\pi}^{\\pi} \\Delta(k_x, k_y) \\,dk_x dk_y$. As the grid becomes denser (i.e., $N$ increases), the approximation should converge to the true value of the integral. The convergence test, $\\delta_{\\mathrm{conv}} = |\\langle \\Delta \\rangle_{2N} - \\langle \\Delta \\rangle_{N}| \\le \\varepsilon$, checks if the change in the computed average is smaller than a tolerance $\\varepsilon$ when the grid density is doubled. This is a standard procedure for assessing the convergence of numerical integration.\n\n**Task 6: Symmetry Accuracy Test**\nThe quantity $\\delta_{\\mathrm{sym}} = |\\langle \\Delta \\rangle_{N} - \\langle \\Delta \\rangle_{N}^{\\mathrm{sym}}|$ directly compares the result from the full-grid calculation with that from the symmetry-reduced calculation. While the symmetry of $\\Delta(\\mathbf{k})$ is exact, the two numerical schemes use grids that may not perfectly correspond, leading to a small but non-zero difference. This test quantifies the accuracy of this specific symmetry reduction implementation.\n\n**Task 7: Numerical Stability Test**\nThe condition number $\\kappa(M)$ of a matrix $M$ measures the sensitivity of the solution of $Mx=b$ to perturbations in $M$ or $b$. For a Hermitian matrix such as $H(\\mathbf{k})$, the singular values $s_i$ are the absolute values of the eigenvalues, $s_i = |E_i|$. The condition number is given by:\n$$\n\\kappa(H(\\mathbf{k})) = \\frac{s_{\\max}}{s_{\\min}} = \\frac{\\max(|E_+|, |E_-|)}{\\min(|E_+|, |E_-|)} = \\frac{|\\frac{k^2}{2} + \\eta + |\\alpha| k|}{|\\frac{k^2}{2} + \\eta - |\\alpha| k|}\n$$\nA very large condition number indicates that the matrix is nearly singular, which can lead to numerical instability. This typically occurs when the denominator, $|E_-(\\mathbf{k})|$, is close to zero. The quadratic equation $\\frac{k^2}{2} - |\\alpha|k + \\eta = 0$ has roots at $k = |\\alpha| \\pm \\sqrt{\\alpha^2 - 2\\eta}$. If $\\alpha^2 \\ge 2\\eta$, there are real values of $k$ for which $E_-$ can be zero. The parameter $\\eta$ acts as a regularization term, ensuring that the denominator remains non-zero (or not too small) and thus keeping the condition number bounded. The algorithm computes $\\kappa(H(\\mathbf{k}))$ for all points on the full grid and finds the maximum value, which is then compared against the threshold $\\kappa_{\\max}$.\n\nThe final implementation will encapsulate these calculations in functions that are called for each set of parameters in the test suite.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_metrics(alpha, N, eta):\n    \"\"\"\n    Computes metrics on a full uniform grid over [-pi, pi] x [-pi, pi].\n    \n    Args:\n        alpha (float): Spin-orbit coupling strength.\n        N (int): Grid dimension (N x N).\n        eta (float): Regularization parameter.\n        \n    Returns:\n        tuple: A tuple containing:\n            - avg_delta (float): The average energy splitting over the grid.\n            - max_kappa (float): The maximum condition number over the grid.\n    \"\"\"\n    if N == 0:\n        return 0.0, 1.0\n    \n    k_range = np.linspace(-np.pi, np.pi, N)\n    kx, ky = np.meshgrid(k_range, k_range)\n    \n    k = np.sqrt(kx**2 + ky**2)\n    \n    # Calculate energy splitting Delta(k)\n    delta = 2.0 * np.abs(alpha) * k\n    avg_delta = np.mean(delta)\n    \n    # Calculate condition number kappa(k)\n    abs_alpha = np.abs(alpha)\n    k_sq_half = 0.5 * k**2\n    \n    # Eigenvalues are E_pm = k^2/2 + eta +/- |alpha|*k\n    # Singular values for a Hermitian matrix are the absolute values of its eigenvalues.\n    s_plus = np.abs(k_sq_half + eta + abs_alpha * k)\n    s_minus = np.abs(k_sq_half + eta - abs_alpha * k)\n    \n    # s_max and s_min must be determined at each point\n    s_max = np.maximum(s_plus, s_minus)\n    s_min = np.minimum(s_plus, s_minus)\n    \n    # Handle division by zero for condition number. If s_min is zero, kappa is infinite.\n    kappa = np.divide(s_max, s_min, out=np.full_like(s_max, np.inf), where=s_min != 0)\n    \n    max_kappa = np.max(kappa)\n    \n    return avg_delta, max_kappa\n\ndef calculate_sym_avg_delta(alpha, N, eta):\n    \"\"\"\n    Computes the average energy splitting using symmetry reduction on a grid over [0, pi] x [0, pi].\n    \n    Args:\n        alpha (float): Spin-orbit coupling strength.\n        N (int): Grid dimension (N x N).\n        eta (float): Regularization parameter (unused in this simplified calc but kept for API consistency).\n\n    Returns:\n        float: The symmetry-reduced average energy splitting.\n    \"\"\"\n    if N == 0:\n        return 0.0\n    if N == 1: # Grid is just the origin\n        return 0.0\n\n    k_range = np.linspace(0, np.pi, N)\n    kx, ky = np.meshgrid(k_range, k_range)\n    \n    k = np.sqrt(kx**2 + ky**2)\n    \n    # Calculate energy splitting Delta(k)\n    delta = 2.0 * np.abs(alpha) * k\n    \n    # Define weights for symmetry reduction\n    weights = np.full((N, N), 4.0)\n    weights[0, :] = 2.0\n    weights[:, 0] = 2.0\n    weights[0, 0] = 1.0\n    \n    # Compute weighted average\n    avg_delta_sym = np.sum(weights * delta) / np.sum(weights)\n\n    return avg_delta_sym\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (0.0, 25, 1e-8, 1e-9, 1e8),\n        (0.01, 25, 1e-8, 1e-6, 1e6),\n        (0.10, 25, 1e-8, 1e-5, 1e6),\n        (1.00, 25, 1e-8, 1e-5, 1e7),\n        (2.00, 25, 1e-6, 1e-4, 1e7)\n    ]\n\n    results = []\n\n    for alpha, N, eta, epsilon, kappa_max in test_cases:\n        # Task 3 & 7: Full grid calculations for N\n        avg_delta_N, max_kappa_N = calculate_metrics(alpha, N, eta)\n        \n        # Task 5: Convergence test requires calculation at 2N\n        avg_delta_2N, _ = calculate_metrics(alpha, 2 * N, eta)\n        delta_conv = np.abs(avg_delta_2N - avg_delta_N)\n        conv_check = delta_conv <= epsilon\n        \n        # Task 4 & 6: Symmetry reduction test\n        avg_delta_N_sym = calculate_sym_avg_delta(alpha, N, eta)\n        delta_sym = np.abs(avg_delta_N - avg_delta_N_sym)\n        \n        # Task 7: Stability check\n        stability_check = max_kappa_N <= kappa_max\n        \n        results.extend([conv_check, delta_sym, stability_check])\n\n    def format_val(v):\n        if isinstance(v, (bool, np.bool_)):\n            return str(v).lower()\n        return f\"{v:.10f}\" # Use a consistent float format to avoid precision issues in output\n\n    # Re-evaluate results to format floats correctly\n    # The problem asks for float for delta_sym, so we avoid custom formatting for it.\n    formatted_results = []\n    for i in range(len(results)):\n        if i % 3 == 0 or i % 3 == 2: # Boolean results\n             formatted_results.append(str(results[i]).lower())\n        else: # Float result (delta_sym)\n             formatted_results.append(str(results[i]))\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3488606"}, {"introduction": "Moving from a generic model to a specific and physically rich material class, this practice focuses on the cubic perovskite iridates. In these $5d$ transition metal oxides, the strong on-site spin-orbit coupling is not a small perturbation but a dominant energy scale that fundamentally reshapes the electronic ground state, leading to the celebrated $j_{\\mathrm{eff}}=1/2$ Mott-insulating state. You will construct a symmetry-constrained tight-binding model for the active $t_{2g}$ orbitals, incorporating the on-site SOC term $H_{\\mathrm{SO}}=\\lambda\\,\\mathbf{L}\\cdot\\mathbf{S}$ and learning how to use projection operators to analyze the character of the resulting band structure [@problem_id:3488731]. This exercise provides direct experience with building realistic material models and employing powerful analytical tools to connect atomic physics with emergent solid-state phenomena.", "problem": "You are asked to construct and analyze a symmetry-constrained tight-binding model for the $t_{2g}$ manifold of a cubic perovskite iridate with on-site Spin-Orbit Coupling (SOC). The goal is to extract the $j_{\\mathrm{eff}}=1/2$ bands and compute a validation metric that mimics comparison against Density Functional Theory (DFT) plus SOC orbital projectors. Your final answer must be a complete, runnable program that performs the following tasks, outputs the specified metrics for a provided test suite of parameter values, and adheres to the output format described at the end.\n\nBegin from the following physically justified bases:\n\n- Relativistic SOC originates from the Dirac equation and, in the nonrelativistic limit for an electron in a central potential, yields an effective on-site SOC term $H_{\\mathrm{SO}}=\\lambda\\,\\mathbf{L}\\cdot\\mathbf{S}$, where $\\lambda$ is an effective SOC parameter that encapsulates radial information (for solids, this is treated as a phenomenological on-site parameter), $\\mathbf{L}$ is the orbital angular momentum operator, and $\\mathbf{S}$ is the spin angular momentum operator.\n- In an ideal cubic perovskite, the crystal field separates the $d$ manifold such that the $t_{2g}$ orbitals $\\{d_{xy},d_{yz},d_{zx}\\}$ dominate near the Fermi level. Within the $t_{2g}$ subspace, the orbital angular momentum is described by an effective $\\ell_{\\mathrm{eff}}=1$ representation with an overall negative sign relative to the usual $p$-orbital representation.\n\nModel definition:\n\n1. Basis. Use the six-dimensional local basis $\\{|d_{xy}\\uparrow\\rangle,|d_{yz}\\uparrow\\rangle,|d_{zx}\\uparrow\\rangle,|d_{xy}\\downarrow\\rangle,|d_{yz}\\downarrow\\rangle,|d_{zx}\\downarrow\\rangle\\}$, where $\\uparrow$ and $\\downarrow$ denote spin states.\n\n2. On-site SOC. Implement\n$$\nH_{\\mathrm{SO}}=\\lambda\\sum_{i=x,y,z}L_i\\otimes S_i,\n$$\nwhere $S_i=\\frac{1}{2}\\sigma_i$ with $\\sigma_i$ the Pauli matrices, and $L_i$ are the orbital angular momentum matrices restricted to the $t_{2g}$ subspace. In the ordered orbital basis $\\{|d_{xy}\\rangle,|d_{yz}\\rangle,|d_{zx}\\rangle\\}$, use\n$$\nL_x=\\begin{pmatrix}\n0 & 0 & 0\\\\\n0 & 0 & i\\\\\n0 & -i & 0\n\\end{pmatrix},\\quad\nL_y=\\begin{pmatrix}\n0 & 0 & -i\\\\\n0 & 0 & 0\\\\\ni & 0 & 0\n\\end{pmatrix},\\quad\nL_z=\\begin{pmatrix}\n0 & i & 0\\\\\n-i & 0 & 0\\\\\n0 & 0 & 0\n\\end{pmatrix},\n$$\nwhich incorporate the effective negative sign appropriate for the $t_{2g}$ subspace.\n\n3. Symmetry-constrained hopping. On a simple cubic lattice with lattice constant set to unity, impose nearest-neighbor hopping with amplitude $t_\\pi$ along directions permitted by orbital symmetry:\n$$\n\\varepsilon_{xy}(\\mathbf{k})=-2t_\\pi\\left(\\cos k_x + \\cos k_y\\right),\\quad\n\\varepsilon_{yz}(\\mathbf{k})=-2t_\\pi\\left(\\cos k_y + \\cos k_z\\right),\\quad\n\\varepsilon_{zx}(\\mathbf{k})=-2t_\\pi\\left(\\cos k_z + \\cos k_x\\right),\n$$\nwhere $\\mathbf{k}=(k_x,k_y,k_z)$ is the crystal momentum, all angles expressed in radians.\n\n4. Crystal-field distortion. Include an on-site crystal-field term\n$$\nH_{\\mathrm{CF}}=\\mathrm{diag}(\\Delta_{xy},\\Delta_{yz},\\Delta_{zx})\\otimes I_2,\n$$\nwhere $I_2$ is the $2\\times 2$ identity in spin space. For tetragonal distortions, a common symmetry-preserving choice is $\\Delta_{yz}=\\Delta_{zx}=-\\Delta_{xy}/2$, ensuring zero trace within the orbital subspace.\n\nThe total Hamiltonian is\n$$\nH(\\mathbf{k})=H_{\\mathrm{hop}}(\\mathbf{k})+H_{\\mathrm{SO}}+H_{\\mathrm{CF}},\n$$\nwith $H_{\\mathrm{hop}}(\\mathbf{k})=\\mathrm{diag}(\\varepsilon_{xy}(\\mathbf{k}),\\varepsilon_{yz}(\\mathbf{k}),\\varepsilon_{zx}(\\mathbf{k}))\\otimes I_2$.\n\nExtraction of $j_{\\mathrm{eff}}=1/2$ bands and validation metric:\n\n- Construct the projector onto the $j_{\\mathrm{eff}}=1/2$ subspace, $P_{1/2}$, by diagonalizing the on-site $H_{\\mathrm{SO}}$ and selecting the two eigenvectors corresponding to the $j_{\\mathrm{eff}}=1/2$ doublet (the highest-energy pair for $\\lambda>0$ with the $t_{2g}$ sign convention). Form $P_{1/2}$ as the sum of outer products of these two normalized eigenvectors. This projector is independent of $\\mathbf{k}$.\n- For a set of $\\mathbf{k}$-points along the high-symmetry path $\\Gamma\\to X\\to M\\to R$ in the cubic Brillouin zone, with $\\Gamma=(0,0,0)$, $X=(\\pi,0,0)$, $M=(\\pi,\\pi,0)$, and $R=(\\pi,\\pi,\\pi)$, sample $5$ equally spaced points per segment (including endpoints), using angles in radians.\n- At each sampled $\\mathbf{k}$, diagonalize $H(\\mathbf{k})$ to obtain eigenvalues and eigenvectors. Compute the $j_{\\mathrm{eff}}=1/2$ projector weight $w_n(\\mathbf{k})=\\langle \\psi_n(\\mathbf{k})|P_{1/2}|\\psi_n(\\mathbf{k})\\rangle$ for each band $n$. Identify the two bands at each $\\mathbf{k}$ with the largest projector weights as the $j_{\\mathrm{eff}}=1/2$ bands.\n- Define the following metrics per parameter set:\n  1. The average $j_{\\mathrm{eff}}=1/2$ weight across the selected bands and all $\\mathbf{k}$-points:\n  $$\n  \\overline{w}=\\frac{1}{2N_k}\\sum_{\\mathbf{k}}\\sum_{m=1}^{2}w_{m}^{\\mathrm{(sel)}}(\\mathbf{k}),\n  $$\n  where $N_k$ is the number of sampled $\\mathbf{k}$-points and $w_m^{\\mathrm{(sel)}}$ are the weights of the two selected bands.\n  2. A validation error mimicking comparison against DFT+SOC orbital projectors, computed as the root-mean-square deviation from the ideal projector weight of $1$ for the selected $j_{\\mathrm{eff}}=1/2$ bands:\n  $$\n  \\mathrm{RMS}=\\sqrt{\\frac{1}{2N_k}\\sum_{\\mathbf{k}}\\sum_{m=1}^{2}\\left(1-w_{m}^{\\mathrm{(sel)}}(\\mathbf{k})\\right)^2}.\n  $$\n  3. The energy splitting at $\\Gamma$ between the $j_{\\mathrm{eff}}=1/2$ doublet and the $j_{\\mathrm{eff}}=3/2$ quartet, defined as the difference of their respective mean band energies at $\\Gamma$,\n  $$\n  \\Delta E_{\\Gamma}=\\frac{1}{2}\\sum_{m=1}^{2}E_{m}^{(1/2)}(\\Gamma)-\\frac{1}{4}\\sum_{n=1}^{4}E_{n}^{(3/2)}(\\Gamma),\n  $$\n  expressed in electronvolts (eV). Here $E_{m}^{(1/2)}(\\Gamma)$ are the energies of the two bands with the largest projector weights at $\\Gamma$, and $E_{n}^{(3/2)}(\\Gamma)$ are the energies of the remaining four bands.\n\nTest suite:\n\nCompute the metrics above for the following parameter sets, with all energies in electronvolts (eV) and angles in radians:\n\n- Case $1$: $\\lambda=0.4$, $t_\\pi=0.15$, $(\\Delta_{xy},\\Delta_{yz},\\Delta_{zx})=(0.0,0.0,0.0)$.\n- Case $2$: $\\lambda=1.0$, $t_\\pi=0.05$, $(\\Delta_{xy},\\Delta_{yz},\\Delta_{zx})=(0.0,0.0,0.0)$.\n- Case $3$: $\\lambda=0.05$, $t_\\pi=0.30$, $(\\Delta_{xy},\\Delta_{yz},\\Delta_{zx})=(0.0,0.0,0.0)$.\n- Case $4$: $\\lambda=0.4$, $t_\\pi=0.15$, $(\\Delta_{xy},\\Delta_{yz},\\Delta_{zx})=(0.1,-0.05,-0.05)$.\n\nFinal output format:\n\nYour program should produce a single line of output containing a list of lists with the three metrics per case in the order given above. For example, it should look like:\n$$\n[[\\overline{w}_1,\\mathrm{RMS}_1,\\Delta E_{\\Gamma,1}],\\dots,[\\overline{w}_4,\\mathrm{RMS}_4,\\Delta E_{\\Gamma,4}]]\n$$\nwith each entry a floating-point number. Print exactly this single line with no additional text.", "solution": "The starting point is the relativistic origin of spin-orbit coupling. From the Dirac equation in a central potential $V(r)$, the Foldy–Wouthuysen transformation yields a nonrelativistic Hamiltonian containing a SOC term proportional to $\\mathbf{L}\\cdot\\mathbf{S}$. In an atomic context, this takes the familiar form $H_{\\mathrm{SO}}=\\lambda\\,\\mathbf{L}\\cdot\\mathbf{S}$, where $\\lambda$ encapsulates the radial expectation $\\lambda\\sim \\frac{\\hbar^2}{2m^2c^2}\\left\\langle \\frac{1}{r}\\frac{dV}{dr}\\right\\rangle$. In solids, especially in $5d$ iridates, $\\lambda$ is treated as an effective on-site parameter within the correlated subspace.\n\nIn an ideal cubic perovskite, the crystal field due to surrounding oxygens splits the $d$ orbitals into the $e_g$ and $t_{2g}$ manifolds, with $t_{2g}$ states ($d_{xy}$, $d_{yz}$, $d_{zx}$) near the Fermi level. The $t_{2g}$ manifold can be represented by an effective orbital angular momentum $\\ell_{\\mathrm{eff}}=1$ with an overall negative sign relative to the $p$-orbital representation. This sign arises because the $t_{2g}$ subspace transforms oppositely under rotations compared to the $p$-orbital basis, which is reflected in the specific form of the projected $L_i$ matrices.\n\nAlgorithmic construction:\n\n1. Define the basis $\\{|d_{xy}\\uparrow\\rangle,|d_{yz}\\uparrow\\rangle,|d_{zx}\\uparrow\\rangle,|d_{xy}\\downarrow\\rangle,|d_{yz}\\downarrow\\rangle,|d_{zx}\\downarrow\\rangle\\}$.\n\n2. Construct the orbital angular momentum matrices $L_x$, $L_y$, $L_z$ in the ordered orbital basis $\\{|d_{xy}\\rangle,|d_{yz}\\rangle,|d_{zx}\\rangle\\}$:\n$$\nL_x=\\begin{pmatrix}\n0 & 0 & 0\\\\\n0 & 0 & i\\\\\n0 & -i & 0\n\\end{pmatrix},\\quad\nL_y=\\begin{pmatrix}\n0 & 0 & -i\\\\\n0 & 0 & 0\\\\\ni & 0 & 0\n\\end{pmatrix},\\quad\nL_z=\\begin{pmatrix}\n0 & i & 0\\\\\n-i & 0 & 0\\\\\n0 & 0 & 0\n\\end{pmatrix}.\n$$\nThese already encode the effective negative sign (they are $-L^{(p)}$).\n\n3. Construct the spin operators $S_i=\\frac{1}{2}\\sigma_i$ with Pauli matrices $\\sigma_i$ acting in spin space. Build\n$$\nH_{\\mathrm{SO}}=\\lambda\\sum_{i=x,y,z}L_i\\otimes S_i=\\frac{\\lambda}{2}\\left(L_x\\otimes \\sigma_x+L_y\\otimes \\sigma_y+L_z\\otimes \\sigma_z\\right).\n$$\nDiagonalizing $H_{\\mathrm{SO}}$ produces two eigenvalues at $+\\lambda$ (the $j_{\\mathrm{eff}}=1/2$ doublet) and four at $-\\lambda/2$ (the $j_{\\mathrm{eff}}=3/2$ quartet), consistent with the energy expression $E_j=-\\frac{\\lambda}{2}\\left[j(j+1)-\\ell(\\ell+1)-s(s+1)\\right]$ when incorporating the effective negative sign of the $t_{2g}$ subspace with $\\ell=1$ and $s=1/2$.\n\n4. Build the symmetry-constrained hopping Hamiltonian $H_{\\mathrm{hop}}(\\mathbf{k})$ as\n$$\nH_{\\mathrm{hop}}(\\mathbf{k})=\\mathrm{diag}(\\varepsilon_{xy}(\\mathbf{k}),\\varepsilon_{yz}(\\mathbf{k}),\\varepsilon_{zx}(\\mathbf{k}))\\otimes I_2,\n$$\nwith\n$$\n\\varepsilon_{xy}(\\mathbf{k})=-2t_\\pi\\left(\\cos k_x + \\cos k_y\\right),\\quad\n\\varepsilon_{yz}(\\mathbf{k})=-2t_\\pi\\left(\\cos k_y + \\cos k_z\\right),\\quad\n\\varepsilon_{zx}(\\mathbf{k})=-2t_\\pi\\left(\\cos k_z + \\cos k_x\\right).\n$$\nThis enforces cubic symmetry, allowing hopping only along symmetry-allowed directions for each $t_{2g}$ orbital.\n\n5. Include the crystal-field term\n$$\nH_{\\mathrm{CF}}=\\mathrm{diag}(\\Delta_{xy},\\Delta_{yz},\\Delta_{zx})\\otimes I_2,\n$$\nto capture tetragonal distortions. A symmetry-preserving choice is $\\Delta_{yz}=\\Delta_{zx}=-\\Delta_{xy}/2$, maintaining zero trace.\n\n6. The total Hamiltonian is\n$$\nH(\\mathbf{k})=H_{\\mathrm{hop}}(\\mathbf{k})+H_{\\mathrm{SO}}+H_{\\mathrm{CF}}.\n$$\nFor a given $\\mathbf{k}$, diagonalize $H(\\mathbf{k})$ to obtain eigenvalues and normalized eigenvectors $\\{E_n(\\mathbf{k}),|\\psi_n(\\mathbf{k})\\rangle\\}$.\n\n7. Construct the $j_{\\mathrm{eff}}=1/2$ projector $P_{1/2}$ by diagonalizing $H_{\\mathrm{SO}}$ alone and summing the projectors of the two eigenvectors corresponding to the $+\\lambda$ eigenvalues. Since $H_{\\mathrm{SO}}$ is $\\mathbf{k}$-independent and purely on-site, $P_{1/2}$ is a fixed $6\\times 6$ projector.\n\n8. For each eigenstate $|\\psi_n(\\mathbf{k})\\rangle$, compute the $j_{\\mathrm{eff}}=1/2$ weight\n$$\nw_n(\\mathbf{k})=\\langle \\psi_n(\\mathbf{k})|P_{1/2}|\\psi_n(\\mathbf{k})\\rangle,\n$$\nwhich lies between $0$ and $1$.\n\n9. At each sampled $\\mathbf{k}$ along the path $\\Gamma\\to X\\to M\\to R$ (with $5$ points per segment, angles in radians), identify the two bands with the largest $w_n(\\mathbf{k})$ as the $j_{\\mathrm{eff}}=1/2$ bands at that $\\mathbf{k}$.\n\n10. Compute the metrics:\n- The average $j_{\\mathrm{eff}}=1/2$ weight,\n$$\n\\overline{w}=\\frac{1}{2N_k}\\sum_{\\mathbf{k}}\\sum_{m=1}^{2}w_{m}^{\\mathrm{(sel)}}(\\mathbf{k}).\n$$\nThis quantifies how pure the extracted bands are in the $j_{\\mathrm{eff}}=1/2$ sense across the path.\n- The validation error mimicking DFT+SOC projector comparison, as the root-mean-square deviation from the ideal weight of $1$,\n$$\n\\mathrm{RMS}=\\sqrt{\\frac{1}{2N_k}\\sum_{\\mathbf{k}}\\sum_{m=1}^{2}\\left(1-w_{m}^{\\mathrm{(sel)}}(\\mathbf{k})\\right)^2}.\n$$\nFor strong SOC and weak hopping, $\\overline{w}\\to 1$ and $\\mathrm{RMS}\\to 0$; for weak SOC or strong distortions, mixing increases, reducing $\\overline{w}$ and increasing $\\mathrm{RMS}$.\n- The energy splitting at $\\Gamma$,\n$$\n\\Delta E_{\\Gamma}=\\frac{1}{2}\\sum_{m=1}^{2}E_{m}^{(1/2)}(\\Gamma)-\\frac{1}{4}\\sum_{n=1}^{4}E_{n}^{(3/2)}(\\Gamma),\n$$\nin electronvolts (eV). In the atomic limit with $t_\\pi=0$ and zero crystal-field distortion, this reduces to $\\Delta E_{\\Gamma}=\\lambda-\\left(-\\lambda/2\\right)=\\frac{3}{2}\\lambda$, consistent with the $j_{\\mathrm{eff}}$ splitting; hopping and crystal-field terms modify this splitting.\n\n11. Apply the above to the test suite:\n- Case $1$: $\\lambda=0.4$, $t_\\pi=0.15$, $(\\Delta_{xy},\\Delta_{yz},\\Delta_{zx})=(0.0,0.0,0.0)$, representing a typical iridate-like regime.\n- Case $2$: $\\lambda=1.0$, $t_\\pi=0.05$, $(\\Delta_{xy},\\Delta_{yz},\\Delta_{zx})=(0.0,0.0,0.0)$, strong SOC limit.\n- Case $3$: $\\lambda=0.05$, $t_\\pi=0.30$, $(\\Delta_{xy},\\Delta_{yz},\\Delta_{zx})=(0.0,0.0,0.0)$, strong hopping with weak SOC, probing mixing.\n- Case $4$: $\\lambda=0.4$, $t_\\pi=0.15$, $(\\Delta_{xy},\\Delta_{yz},\\Delta_{zx})=(0.1,-0.05,-0.05)$, tetragonal distortion with zero trace, testing symmetry breaking effects.\n\nThe implemented program follows these steps, computes the metrics for each case, and prints them in the required single-line format. This approach synthesizes the relativistic origin of SOC, the symmetry-constrained tight-binding description, and a projector-based extraction of $j_{\\mathrm{eff}}=1/2$ character, providing a scientifically grounded and algorithmically testable validation proxy for DFT+SOC orbital projector comparisons.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef t2g_L_matrices():\n    \"\"\"Return Lx, Ly, Lz matrices in the t2g orbital basis {xy, yz, zx}.\"\"\"\n    i = 1j\n    Lx = np.array([[0, 0, 0],\n                   [0, 0, i],\n                   [0, -i, 0]], dtype=complex)\n    Ly = np.array([[0, 0, -i],\n                   [0, 0, 0],\n                   [i, 0, 0]], dtype=complex)\n    Lz = np.array([[0, i, 0],\n                   [-i, 0, 0],\n                   [0, 0, 0]], dtype=complex)\n    return Lx, Ly, Lz\n\ndef pauli_matrices():\n    \"\"\"Return Pauli matrices sigma_x, sigma_y, sigma_z.\"\"\"\n    sigma_x = np.array([[0, 1],\n                        [1, 0]], dtype=complex)\n    sigma_y = np.array([[0, -1j],\n                        [1j, 0]], dtype=complex)\n    sigma_z = np.array([[1, 0],\n                        [0, -1]], dtype=complex)\n    return sigma_x, sigma_y, sigma_z\n\ndef kron(A, B):\n    \"\"\"Kronecker product, returning complex dtype.\"\"\"\n    return np.kron(A, B).astype(complex)\n\ndef H_soc(lambda_ev):\n    \"\"\"Construct on-site SOC Hamiltonian H_SO = (lambda/2) sum_i L_i ⊗ sigma_i.\"\"\"\n    Lx, Ly, Lz = t2g_L_matrices()\n    sx, sy, sz = pauli_matrices()\n    H = (lambda_ev / 2.0) * (kron(Lx, sx) + kron(Ly, sy) + kron(Lz, sz))\n    return H\n\ndef H_hop(kx, ky, kz, t_pi):\n    \"\"\"Construct hopping Hamiltonian H_hop(k) = diag(eps_xy, eps_yz, eps_zx) ⊗ I2.\"\"\"\n    eps_xy = -2.0 * t_pi * (np.cos(kx) + np.cos(ky))\n    eps_yz = -2.0 * t_pi * (np.cos(ky) + np.cos(kz))\n    eps_zx = -2.0 * t_pi * (np.cos(kz) + np.cos(kx))\n    eps = np.array([eps_xy, eps_yz, eps_zx], dtype=float)\n    H_orb = np.diag(eps).astype(complex)\n    I2 = np.eye(2, dtype=complex)\n    return kron(H_orb, I2)\n\ndef H_cf(delta_xy, delta_yz, delta_zx):\n    \"\"\"Construct crystal-field Hamiltonian H_CF = diag(Delta_xy, Delta_yz, Delta_zx) ⊗ I2.\"\"\"\n    deltas = np.array([delta_xy, delta_yz, delta_zx], dtype=float)\n    H_orb = np.diag(deltas).astype(complex)\n    I2 = np.eye(2, dtype=complex)\n    return kron(H_orb, I2)\n\ndef j_eff_half_projector():\n    \"\"\"\n    Build the k-independent projector onto j_eff=1/2 subspace by diagonalizing H_SOC (lambda=1).\n    Returns a 6x6 Hermitian projector matrix P.\n    \"\"\"\n    H = H_soc(1.0)  # Eigenvectors independent of lambda scaling for lambda>0\n    evals, evecs = np.linalg.eigh(H)\n    # Identify the two largest eigenvalues (j_eff=1/2 doublet at +lambda)\n    idx_sorted = np.argsort(evals)  # ascending\n    idx_top2 = idx_sorted[-2:]      # last two are the largest\n    P = np.zeros((6, 6), dtype=complex)\n    for idx in idx_top2:\n        v = evecs[:, idx]\n        # Normalize (should already be normalized by eigh)\n        v = v / np.linalg.norm(v)\n        P += np.outer(v, np.conjugate(v))\n    # Ensure Hermitian projector numerically\n    P = (P + P.conjugate().T) / 2.0\n    return P\n\ndef sample_k_path(n_per_segment=5):\n    \"\"\"\n    Sample 5 equally spaced points per segment along Gamma->X->M->R path.\n    Angles in radians. Returns a list of (kx, ky, kz).\n    \"\"\"\n    # Parameter t in [0,1] with n points including endpoints\n    ts = np.linspace(0.0, 1.0, n_per_segment)\n    pts = []\n    # Gamma (0,0,0) to X (pi,0,0)\n    for t in ts:\n        pts.append((np.pi * t, 0.0, 0.0))\n    # X (pi,0,0) to M (pi,pi,0)\n    for t in ts:\n        pts.append((np.pi, np.pi * t, 0.0))\n    # M (pi,pi,0) to R (pi,pi,pi)\n    for t in ts:\n        pts.append((np.pi, np.pi, np.pi * t))\n    # Remove exact duplicates while preserving order\n    unique = []\n    seen = set()\n    for k in pts:\n        key = (round(k[0], 12), round(k[1], 12), round(k[2], 12))\n        if key not in seen:\n            seen.add(key)\n            unique.append(k)\n    return unique\n\ndef compute_metrics(lambda_ev, t_pi, delta_xy, delta_yz, delta_zx):\n    \"\"\"\n    Compute:\n    - average j_eff=1/2 weight over selected bands and k-points,\n    - RMS deviation from ideal projector weight 1,\n    - Gamma-point splitting between j_eff=1/2 and j_eff=3/2 means (in eV).\n    \"\"\"\n    P = j_eff_half_projector()\n    k_list = sample_k_path(n_per_segment=5)\n    weights_selected = []  # collect weights of the two selected bands across all k\n    # For Gamma splitting calculation\n    kx_g, ky_g, kz_g = (0.0, 0.0, 0.0)\n    H_gamma = H_hop(kx_g, ky_g, kz_g, t_pi) + H_soc(lambda_ev) + H_cf(delta_xy, delta_yz, delta_zx)\n    evals_g, evecs_g = np.linalg.eigh(H_gamma)\n    # Compute weights at Gamma\n    weights_g = np.array([np.real(np.conjugate(evecs_g[:, n]).T @ (P @ evecs_g[:, n])) for n in range(6)], dtype=float)\n    # Identify top2 bands at Gamma\n    idx_top2_g = np.argsort(weights_g)[-2:]\n    # j_eff=1/2 energies (mean of two)\n    E_j12_gamma = np.mean(evals_g[idx_top2_g].real)\n    # j_eff=3/2 energies: the remaining four\n    idx_rest_g = np.array([n for n in range(6) if n not in idx_top2_g], dtype=int)\n    E_j32_gamma = np.mean(evals_g[idx_rest_g].real)\n\n    # Loop over k-points for weights and RMS\n    for (kx, ky, kz) in k_list:\n        Hk = H_hop(kx, ky, kz, t_pi) + H_soc(lambda_ev) + H_cf(delta_xy, delta_yz, delta_zx)\n        evals, evecs = np.linalg.eigh(Hk)\n        # Compute projector weights for all all bands\n        ws = np.array([np.real(np.conjugate(evecs[:, n]).T @ (P @ evecs[:, n])) for n in range(6)], dtype=float)\n        # Select two bands with largest weights\n        idx_top2 = np.argsort(ws)[-2:]\n        weights_selected.extend(ws[idx_top2].tolist())\n\n    # Metrics\n    weights_selected = np.array(weights_selected, dtype=float)\n    avg_weight = float(np.mean(weights_selected))\n    rms_error = float(np.sqrt(np.mean((1.0 - weights_selected) ** 2)))\n    delta_E_gamma = float(E_j12_gamma - E_j32_gamma)  # in eV\n\n    return [avg_weight, rms_error, delta_E_gamma]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (lambda_ev, t_pi, delta_xy, delta_yz, delta_zx)\n    test_cases = [\n        (0.4, 0.15, 0.0, 0.0, 0.0),        # Case 1\n        (1.0, 0.05, 0.0, 0.0, 0.0),        # Case 2\n        (0.05, 0.30, 0.0, 0.0, 0.0),       # Case 3\n        (0.4, 0.15, 0.1, -0.05, -0.05),    # Case 4 (tetragonal, zero trace)\n    ]\n\n    results = []\n    for case in test_cases:\n        lambda_ev, t_pi, dxy, dyz, dzx = case\n        metrics = compute_metrics(lambda_ev, t_pi, dxy, dyz, dzx)\n        results.append(metrics)\n\n    # Final print statement in the exact required format.\n    # Single line: list of lists with floats.\n    # Ensure default Python string formatting without extra text.\n    print(str(results))\n\nsolve()\n```", "id": "3488731"}, {"introduction": "This final practice bridges the gap between large-scale, first-principles simulations and insightful effective models, a common and powerful workflow in modern research. While Density Functional Theory (DFT) can provide a detailed picture of a material's electronic structure, effective Hamiltonians like the Rashba model offer clearer physical intuition. The challenge lies in connecting the two by determining the parameters of the effective model from the DFT results. In this exercise, you will analyze synthetic band structure data, mimicking the output of a DFT+SOC calculation, to extract the Rashba parameter $\\alpha_R$ and decompose its value into distinct physical origins: the intrinsic atomic SOC and the structural inversion asymmetry, which can be tuned by an external electric field [@problem_id:3488646]. This practice develops essential data analysis skills and deepens the understanding of how macroscopic phenomena arise from the interplay of microscopic interactions.", "problem": "You are studying a polar semiconductor slab using Density Functional Theory (DFT) including Spin-Orbit Coupling (SOC). Near the Brillouin zone center $\\Gamma$, the nonrelativistic limit of the Dirac equation yields the Pauli Hamiltonian with a relativistic spin-orbit term that couples the crystal potential gradient to the electron momentum and spin. For carriers confined in a two-dimensional geometry, structural inversion asymmetry along the out-of-plane direction induces a linear-in-wavevector spin splitting near $\\Gamma$ that is commonly characterized by the Rashba parameter $\\,\\alpha_R\\,$. Your task is to compute $\\,\\alpha_R\\,$ by fitting the energy dispersion $\\,E(\\mathbf{k})\\,$ near $\\Gamma$ for multiple external out-of-plane electric fields $\\,E_z\\,$ and for different SOC scaling factors, and then to decompose $\\,\\alpha_R\\,$ into contributions associated with structural inversion asymmetry versus intrinsic atomic spin-orbit coupling.\n\nStart from first principles: use the nonrelativistic Pauli Hamiltonian with its spin-orbit term generated from the Dirac equation, and reason to an effective model appropriate for a two-dimensional polar slab subjected to an out-of-plane electric field. Then design a numerical fitting strategy, consistent with this derived effective model, to extract $\\,\\alpha_R\\,$ from the provided discrete $\\,E(\\mathbf{k})\\,$ values near $\\Gamma$ and to separate the structural inversion asymmetry contribution (controlled by $\\,E_z\\,$) from the atomic spin-orbit coupling contribution (controlled by an SOC scaling factor).\n\nYour program must process the test suite below and produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, you must:\n- Extract $\\,\\alpha_R\\,$ from the dispersion for each provided $\\,E_z\\,$ and SOC scaling factor.\n- Using all the extracted $\\,\\alpha_R\\,$ values for that test case, perform a linear decomposition consistent with an effective model in which $\\,\\alpha_R\\,$ depends on both the external field and the SOC scaling, and determine two quantities:\n  1. A material-dependent slope parameter (with units $\\mathrm{eV}\\,\\mathrm{\\AA}^2/\\mathrm{V}$) that quantifies how $\\,\\alpha_R\\,$ changes with $\\,E_z\\,$ at full SOC.\n  2. An intrinsic built-in field (with units $\\mathrm{V}/\\mathrm{\\AA}$) representing the polar slab’s internal inversion asymmetry at zero external field.\n- Using the decomposed parameters, report the structural inversion asymmetry contribution to $\\,\\alpha_R\\,$ at the largest provided $\\,E_z\\,$ for that test case (assuming full SOC, i.e., SOC scaling factor equals $\\,1$), expressed in $\\mathrm{eV}\\,\\mathrm{\\AA}$ and rounded to six decimal places.\n- Using the decomposed parameters, report the atomic spin-orbit coupling contribution to $\\,\\alpha_R\\,$ at zero external field (assuming full SOC), expressed in $\\mathrm{eV}\\,\\mathrm{\\AA}$ and rounded to six decimal places.\n\nPhysical units:\n- Wavevector $\\,k\\,$ must be treated in $\\mathrm{\\AA}^{-1}$.\n- Energy $\\,E\\,$ must be treated in $\\mathrm{eV}$.\n- The Rashba parameter $\\,\\alpha_R\\,$ must be reported in $\\mathrm{eV}\\,\\mathrm{\\AA}$.\n- The material slope parameter must be reported in $\\mathrm{eV}\\,\\mathrm{\\AA}^2/\\mathrm{V}$.\n- The intrinsic built-in field must be reported in $\\mathrm{V}/\\mathrm{\\AA}$.\n- Electric field $\\,E_z\\,$ must be treated in $\\mathrm{V}/\\mathrm{\\AA}$.\n\nAngle units are not used. Percentages are not used.\n\nTest suite and data specification:\n- The program will internally construct synthetic dispersion datasets $\\,E_\\pm(k)\\,$ near $\\Gamma$ that are consistent with a two-branch spin-split dispersion, small nonparabolicity, and negligible, common-mode numerical noise. You must treat these datasets as measured DFT+SOC results and refrain from assuming an exact analytical generation formula inside the problem statement. The program will use the following parameters to generate the datasets and provide comprehensive coverage:\n  - Universal constant for the parabolic term: use $\\,\\hbar^2/(2m_e) = 3.80998212\\,\\mathrm{eV}\\,\\mathrm{\\AA}^2\\,$ and an effective mass $\\,m^\\ast\\,$ given below to set the curvature scale.\n  - A common wavevector grid for all cases: $\\,k \\in \\{0.005,\\,0.00833\\overline{3},\\,0.01166\\overline{6},\\,0.015,\\,0.01833\\overline{3},\\,0.02166\\overline{6},\\,0.025,\\,0.02833\\overline{3},\\,0.03166\\overline{6},\\,0.035\\}\\,\\mathrm{\\AA}^{-1}\\,$.\n  - The nonparabolic correction amplitude is small and identical for both branches within each test case, so it does not bias the spin splitting; a negligible deterministic noise, common to both branches, is included to emulate numerical discretization without affecting the splitting.\n\n- Test Case $\\,1\\,$ (happy path):\n  - Effective mass: $\\,m^\\ast = 0.20\\,m_e\\,$.\n  - SOC scaling factors: $\\,\\lambda \\in \\{1.00,\\,0.50\\}\\,$.\n  - External fields: $\\,E_z \\in \\{0.00,\\,0.05,\\,0.10\\}\\,\\mathrm{V}/\\mathrm{\\AA}$.\n  - Intrinsic built-in field: $\\,E_{\\mathrm{int}} = 0.12\\,\\mathrm{V}/\\mathrm{\\AA}$.\n  - Structural sensitivity: material slope parameter nominal scale $\\,\\sim 0.40\\,\\mathrm{eV}\\,\\mathrm{\\AA}^2/\\mathrm{V}\\,$.\n- Test Case $\\,2\\,$ (boundary with near-vanishing intrinsic field and larger field span):\n  - Effective mass: $\\,m^\\ast = 0.35\\,m_e\\,$.\n  - SOC scaling factors: $\\,\\lambda \\in \\{1.00,\\,0.50\\}\\,$.\n  - External fields: $\\,E_z \\in \\{0.00,\\,0.10,\\,0.20\\}\\,\\mathrm{V}/\\mathrm{\\AA}$.\n  - Intrinsic built-in field: $\\,E_{\\mathrm{int}} = 0.02\\,\\mathrm{V}/\\mathrm{\\AA}$.\n  - Structural sensitivity: material slope parameter nominal scale $\\,\\sim 0.25\\,\\mathrm{eV}\\,\\mathrm{\\AA}^2/\\mathrm{V}\\,$.\n- Test Case $\\,3\\,$ (edge case with strong intrinsic field and weak SOC scaling):\n  - Effective mass: $\\,m^\\ast = 0.10\\,m_e\\,$.\n  - SOC scaling factors: $\\,\\lambda \\in \\{1.00,\\,0.30\\}\\,$.\n  - External fields: $\\,E_z \\in \\{0.00,\\,0.05,\\,0.15\\}\\,\\mathrm{V}/\\mathrm{\\AA}$.\n  - Intrinsic built-in field: $\\,E_{\\mathrm{int}} = 0.20\\,\\mathrm{V}/\\mathrm{\\AA}$.\n  - Structural sensitivity: material slope parameter nominal scale $\\,\\sim 0.55\\,\\mathrm{eV}\\,\\mathrm{\\AA}^2/\\mathrm{V}\\,$.\n\nAnswer specification and final output format:\n- For each test case, compute four floats:\n  1. The material slope parameter in $\\mathrm{eV}\\,\\mathrm{\\AA}^2/\\mathrm{V}$, rounded to six decimal places.\n  2. The intrinsic built-in field in $\\mathrm{V}/\\mathrm{\\AA}$, rounded to six decimal places.\n  3. The structural inversion asymmetry contribution to $\\,\\alpha_R\\,$ at the largest $\\,E_z\\,$ (with full SOC), in $\\mathrm{eV}\\,\\mathrm{\\AA}$, rounded to six decimal places.\n  4. The atomic spin-orbit coupling contribution to $\\,\\alpha_R\\,$ at zero external field (with full SOC), in $\\mathrm{eV}\\,\\mathrm{\\AA}$, rounded to six decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a nested list with the four floats in the order above, for example: $\\,\\mathtt{[[x_1,y_1,z_1,w_1],[x_2,y_2,z_2,w_2],[x_3,y_3,z_3,w_3]]}\\,$. No additional text should be printed.", "solution": "The user-provided problem is assessed to be valid. It is scientifically grounded in the principles of solid-state physics and quantum mechanics, specifically concerning spin-orbit coupling effects in two-dimensional semiconductor structures. The problem is well-posed, providing a clear objective, a self-contained set of data and parameters, and a task that admits a unique, verifiable solution. The terminology is objective and precise, and the specified numerical values are physically plausible. The task requires a combination of theoretical modeling and numerical data analysis, representing a legitimate problem in computational materials science.\n\nThe solution will be developed in three stages:\n1.  Derivation of an effective Hamiltonian and the corresponding analytical model for the Rashba parameter $\\alpha_R$.\n2.  Design of a two-step numerical fitting procedure to extract the model parameters from the dispersion data.\n3.  Calculation of the final quantities as requested by the problem statement.\n\n**1. Theoretical Model**\n\nThe starting point is the Pauli Hamiltonian, which is the non-relativistic limit of the Dirac equation. It includes a spin-orbit coupling (SOC) term:\n$$\nH = \\frac{\\mathbf{p}^2}{2m_e} + V(\\mathbf{r}) + H_{\\text{SO}}\n$$\nwhere $\\mathbf{p}$ is the momentum operator, $m_e$ is the free electron mass, and $V(\\mathbf{r})$ is the crystal potential. The SOC term $H_{\\text{SO}}$ is given by:\n$$\nH_{\\text{SO}} = \\frac{\\hbar}{4m_e^2c^2} (\\nabla V \\times \\mathbf{p}) \\cdot \\boldsymbol{\\sigma}\n$$\nwhere $\\boldsymbol{\\sigma}$ is the vector of Pauli matrices.\n\nFor a two-dimensional electron gas (2DEG) confined in a slab or quantum well grown along the $z$-direction, the potential $V(\\mathbf{r})$ can be approximated as the sum of the periodic crystal potential, a confining potential $V_{\\text{conf}}(z)$, and the potential from an external electric field $E_z$ applied along $z$, so $V_{\\text{total}}(z) = V_{\\text{conf}}(z) - e E_z z$. The presence of structural inversion asymmetry (SIA), either intrinsic to a polar slab or induced by the external field $E_z$, results in a non-zero expectation value of the potential gradient along the $z$-axis, $\\langle \\nabla V \\rangle \\approx \\langle \\frac{\\partial V_{\\text{total}}}{\\partial z} \\rangle \\hat{\\mathbf{z}}$.\n\nAssuming the electrons are primarily confined to the lowest subband, we can construct an effective $2 \\times 2$ Hamiltonian for the in-plane motion, described by wavevector $\\mathbf{k} = (k_x, k_y)$. The kinetic energy term becomes $\\frac{\\hbar^2 k^2}{2m^*}I$, where $m^*$ is the effective mass and $I$ is the $2 \\times 2$ identity matrix. The SOC term, after averaging over the confinement wavefunction, simplifies to the Rashba Hamiltonian:\n$$\nH_R = \\alpha_R (k_y \\sigma_x - k_x \\sigma_y)\n$$\nThis is the linear-in-$k$ Rashba spin-splitting term. The Rashba parameter, $\\alpha_R$, is proportional to the expectation value of the out-of-plane electric field. This total effective field is a sum of an intrinsic field $E_{\\text{int}}$ (due to the built-in asymmetry of the polar slab) and the external field $E_z$. Furthermore, $\\alpha_R$ is proportional to the strength of the underlying atomic spin-orbit interaction, which is modulated by the scaling factor $\\lambda$. This leads to the following linear effective model for $\\alpha_R$:\n$$\n\\alpha_R(\\lambda, E_z) = \\lambda \\cdot \\gamma \\cdot (E_{\\text{int}} + E_z)\n$$\nwhere $\\gamma$ is a material-dependent constant, referred to as the slope parameter, that encapsulates the sensitivity of the Rashba splitting to the electric field and contains other fundamental constants and material properties.\n\nThe total effective Hamiltonian near the $\\Gamma$ point is $H_{\\text{eff}} = \\frac{\\hbar^2 k^2}{2m^*}I + H_R$. The eigenvalues of this Hamiltonian are:\n$$\nE_\\pm(k) = \\frac{\\hbar^2 k^2}{2m^*} \\pm |\\alpha_R| k\n$$\nThe energy splitting between the two spin-polarized bands is therefore directly proportional to the wavevector magnitude $k$:\n$$\n\\Delta E(k) = E_+(k) - E_-(k) = 2 |\\alpha_R| k\n$$\nThis linear relationship is the key to extracting $\\alpha_R$ from the energy dispersion data.\n\n**2. Numerical Fitting Strategy**\n\nThe task is to determine the slope parameter $\\gamma$ and the intrinsic field $E_{\\text{int}}$ by analyzing the provided dispersion data $E_\\pm(k)$ for various combinations of the SOC scaling factor $\\lambda$ and external field $E_z$. This is accomplished via a two-step fitting procedure.\n\n**Step 2a: Extraction of $\\alpha_R$ for Each Experimental Condition**\nFor each pair of $(\\lambda, E_z)$, a synthetic dataset of energy eigenvalues $E_\\pm(k_i)$ is generated at a discrete set of wavevectors $k_i$. The first step is to extract the corresponding value of $\\alpha_R$ from this dataset. Based on the model $\\Delta E = 2 \\alpha_R k$, we can treat this as a linear regression problem. We compute the energy splitting $\\Delta E_i = E_+(k_i) - E_-(k_i)$ for each $k_i$. Then, we fit the data points $(k_i, \\Delta E_i)$ to a line passing through the origin, $y = m x$, where the slope is $m = 2 \\alpha_R$. The least-squares solution for the slope is:\n$$\nm = \\frac{\\sum_i k_i \\Delta E_i}{\\sum_i k_i^2}\n$$\nFrom this, the Rashba parameter for the specific $(\\lambda, E_z)$ condition is found as $\\alpha_R = m/2$. This process is repeated for all given combinations of $\\lambda$ and $E_z$ in a test case, yielding a set of measured Rashba parameters.\n\n**Step 2b: Decomposition of $\\alpha_R$ and Parameter Extraction**\nThe second step is to use the set of extracted $\\alpha_R$ values to determine the fundamental parameters $\\gamma$ and $E_{\\text{int}}$. Our model is $\\alpha_R = \\lambda \\gamma (E_{\\text{int}} + E_z)$. Rearranging this equation gives:\n$$\n\\frac{\\alpha_R}{\\lambda} = \\gamma E_z + \\gamma E_{\\text{int}}\n$$\nThis equation has the form of a linear function $y = A x + B$, where $y = \\alpha_R/\\lambda$, $x = E_z$, the slope is $A = \\gamma$, and the y-intercept is $B = \\gamma E_{\\text{int}}$.\nUsing the set of pairs $(E_z, \\alpha_R/\\lambda)$ obtained from Step 2a, we perform a standard linear regression to find the best-fit slope $A$ and intercept $B$.\nThe material-dependent slope parameter is then $\\gamma = A$.\nThe intrinsic built-in field is calculated from the intercept and slope as $E_{\\text{int}} = B/A$.\n\n**3. Calculation of Final Quantities**\n\nWith the fitted parameters $\\gamma$ and $E_{\\text{int}}$, we can calculate the four required quantities for each test case:\n1.  **Material slope parameter**: This is simply the fitted slope $\\gamma$.\n2.  **Intrinsic built-in field**: This is the calculated $E_{\\text{int}}$.\n3.  **Structural inversion asymmetry contribution to $\\alpha_R$ at the largest $E_z$ (with $\\lambda=1$)**: This quantity is interpreted as the portion of the Rashba parameter induced by the external field alone. At full SOC ($\\lambda=1$), the total Rashba parameter is $\\alpha_R(E_z) = \\gamma E_{\\text{int}} + \\gamma E_z$. The contribution from the external field is the second term, evaluated at the maximum field $E_{z, \\text{max}}$ for the test case: $\\gamma \\cdot E_{z, \\text{max}}$.\n4.  **Atomic spin-orbit coupling contribution to $\\alpha_R$ at zero external field (with $\\lambda=1$)**: This is interpreted as the baseline Rashba parameter that exists due to the material's intrinsic asymmetry and atomic SOC, in the absence of any external field. This corresponds to the first term in the decomposition: $\\gamma \\cdot E_{\\text{int}}$. This is also equal to the intercept $B$ from the fit in Step 2b.\n\nThis procedure provides a complete and robust methodology for analyzing the spin-split band structure and decomposing the Rashba parameter into its constituent physical origins as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It orchestrates data generation, analysis, and final output formatting.\n    \"\"\"\n    \n    # Universal constants and grid definition\n    HBAR2_2M_E = 3.80998212  # eV Å^2\n    k_vector_grid = np.array([(3 + 2 * i) / 600.0 for i in range(10)]) # Å^-1\n\n    # Test cases defined as per the problem statement.\n    # Each entry is a tuple: (m*/m_e, [λ], [E_z], E_int_true, gamma_true_scale)\n    test_cases = [\n        (0.20, [1.00, 0.50], [0.00, 0.05, 0.10], 0.12, 0.40),\n        (0.35, [1.00, 0.50], [0.00, 0.10, 0.20], 0.02, 0.25),\n        (0.10, [1.00, 0.30], [0.00, 0.05, 0.15], 0.20, 0.55),\n    ]\n\n    all_results = []\n    for case_params in test_cases:\n        result = analyze_case(case_params, HBAR2_2M_E, k_vector_grid)\n        all_results.append(result)\n\n    # Format the final output string according to the specified format.\n    # e.g., [[val1,val2,...],[val1,val2,...]]\n    case_strings = [f\"[{','.join(f'{v:.6f}' for v in res)}]\" for res in all_results]\n    print(f\"[{','.join(case_strings)}]\")\n\ndef analyze_case(params, hbar2_2m_e, k_vec):\n    \"\"\"\n    Analyzes a single test case: generates synthetic data, performs a two-step\n    fitting procedure, and computes the required physical quantities.\n    \"\"\"\n    m_star_ratio, lambdas, E_fields, E_int_true, gamma_true = params\n\n    # The analysis proceeds in two stages:\n    # 1. For each (λ, E_z) pair, extract α_R from synthetic E(k) data.\n    # 2. Use all extracted α_R values to fit for γ and E_int.\n    \n    # This list will store data for the second-stage fit: (E_z, α_R/λ)\n    fit_data = []\n\n    for lmbda in lambdas:\n        for Ez in E_fields:\n            # --- Stage 1a: Generate synthetic data ---\n            # The problem states to treat this as measured data.\n            # We use the provided \"true\" parameters to generate it.\n            alpha_R_true = lmbda * gamma_true * (E_int_true + Ez)\n            \n            # Parabolic dispersion E(k) = ħ²k²/(2m*)\n            hbar2_2m_eff = hbar2_2m_e / m_star_ratio\n            E_parabolic = hbar2_2m_eff * k_vec**2\n            \n            # Spin-split bands E±(k) = E_parabolic ± α_R*k\n            # Non-parabolicity and noise are stated as common-mode and negligible,\n            # so they cancel in the splitting and are ignored here.\n            E_plus = E_parabolic + alpha_R_true * k_vec\n            E_minus = E_parabolic - alpha_R_true * k_vec\n            \n            # --- Stage 1b: Extract α_R from the data ---\n            # The splitting is ΔE = E+ - E- = 2*α_R*k\n            # We fit ΔE vs k to a line through the origin (y=mx) to find m=2*α_R.\n            delta_E = E_plus - E_minus\n            \n            # Using least squares formula for slope m = Σ(xy) / Σ(x²)\n            slope_2_alpha = np.sum(k_vec * delta_E) / np.sum(k_vec**2)\n            alpha_R_fit = slope_2_alpha / 2.0\n            \n            # Store data for the second fit. Model: α_R/λ = γ*E_z + γ*E_int\n            # x-data is E_z, y-data is α_R/λ\n            fit_data.append((Ez, alpha_R_fit / lmbda))\n\n    # --- Stage 2: Decompose α_R to find γ and E_int ---\n    # Unpack data for linear regression\n    x_data = np.array([d[0] for d in fit_data]) # E_z values\n    y_data = np.array([d[1] for d in fit_data]) # α_R/λ values\n\n    # Perform linear regression y = Ax + B using numpy.polyfit\n    # A = slope = γ\n    # B = intercept = γ * E_int\n    fit_coeffs = np.polyfit(x_data, y_data, 1)\n    \n    gamma_fit = fit_coeffs[0]\n    intercept = fit_coeffs[1]\n    \n    # Avoid division by zero if gamma_fit is zero\n    E_int_fit = intercept / gamma_fit if gamma_fit != 0 else 0\n\n    # --- Final calculations ---\n    # 1. Material slope parameter (eV Å²/V)\n    slope_param = gamma_fit\n    \n    # 2. Intrinsic built-in field (V/Å)\n    intrinsic_field = E_int_fit\n                                 \n    # 3. Structural inversion asymmetry contribution to α_R at largest E_z (eV Å)\n    # This is the part of α_R (at λ=1) induced by the external field: γ * E_z\n    E_z_max = max(E_fields) if E_fields else 0.0\n    sia_contribution = gamma_fit * E_z_max\n\n    # 4. Atomic SOC contribution to α_R at zero E_z (eV Å)\n    # This is the baseline α_R (at λ=1) from intrinsic asymmetry: γ * E_int\n    # This is numerically equal to the intercept of the second fit.\n    atomic_contribution = intercept\n\n    return [\n        slope_param,\n        intrinsic_field,\n        sia_contribution,\n        atomic_contribution\n    ]\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3488646"}]}