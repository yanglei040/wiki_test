{"hands_on_practices": [{"introduction": "This first exercise provides a comprehensive dive into the numerical construction of atomic environment descriptors. By implementing both the Smooth Overlap of Atomic Positions (SOAP) and Atom-Centered Symmetry Functions (ACSF) from their mathematical definitions [@problem_id:3443939], you will gain a practical understanding of how a set of neighbor coordinates is transformed into a fixed-size, invariant feature vector. This practice is essential for demystifying these powerful tools and verifying fundamental properties like rotational invariance.", "problem": "You are asked to implement and numerically verify descriptors for local atomic environments, focusing on the Smooth Overlap of Atomic Positions (SOAP) and Atom-Centered Symmetry Functions (ACSF), starting from foundational definitions of atom-centered densities and rotational invariance. The implementation must strictly follow the instructions below and produce a single-line output aggregating numerical results for the specified test suite.\n\nThe fundamental base is as follows. Consider a central atom at the origin and a finite set of neighbor atoms with positions given in Cartesian coordinates. Distances are measured in Angstroms. Angles must be computed in radians. An isotropic cutoff function is defined to ensure locality. The density of the environment is represented by point contributions, and descriptors must be invariant under global rotation and translation. Your program shall implement:\n\n- A smooth radial cutoff function $f_c(r)$ satisfying $f_c(r) = \\frac{1}{2}\\left[\\cos\\left(\\frac{\\pi r}{r_c}\\right) + 1\\right]$ for $r \\le r_c$ and $f_c(r) = 0$ for $r > r_c$, with $r_c$ in Angstroms.\n- An approximate SOAP descriptor constructed from a projection of a point-density onto an orthonormal radial basis and spherical harmonics, followed by forming the rotationally invariant power spectrum and normalizing by its Euclidean norm. The point-density approximation corresponds to the $\\sigma \\to 0$ limit of a Gaussian-smoothed density, and is acceptable for the purposes of this numerical exercise.\n- ACSF radial and angular functions designed to be invariant under translation, rotation, and permutation of identical neighbors.\n\nAll angles must be computed in radians, and all distances must be in Angstroms. The descriptors shall be defined as follows:\n\n- For the cutoff, use $r_c = 3.0$ Angstroms, and define $f_c(r)$ as above.\n- For SOAP, construct an orthonormal radial basis $\\{\\phi_n(r)\\}_{n=0}^{N_n-1}$ by orthonormalizing Gaussian radial probes $g_k(r) = \\exp\\left( -\\frac{(r - R_k)^2}{2\\sigma_r^2} \\right)$ using Gram-Schmidt with respect to the weighted inner product $\\langle u, v \\rangle = \\int_{0}^{r_c} u(r)\\,v(r)\\,r^2 \\,\\mathrm{d}r$ discretized on a uniform radial grid. Use $N_n = 3$ radial functions, $\\sigma_r = 0.3$ Angstroms, and centers $R_k = r_c \\cdot \\frac{k+1}{N_n+1}$ for $k \\in \\{0,1,2\\}$. Use a uniform radial grid with $N_r = 400$ points over $[0,r_c]$. Let the angular basis be the complex spherical harmonics $Y_{\\ell m}(\\theta,\\phi)$ up to $\\ell_{\\max} = 2$. For a neighbor at position vector $\\mathbf{r}_j$ relative to the central atom, define $r_j = \\|\\mathbf{r}_j\\|$, $\\theta_j$ as the colatitude, and $\\phi_j$ as the azimuth. The approximate expansion coefficients are\n$$\nc_{n \\ell m} = \\sum_{j} \\phi_n(r_j)\\, Y_{\\ell m}(\\theta_j,\\phi_j)\\, f_c(r_j),\n$$\nwhere the sum runs over neighbors within the cutoff. The rotationally invariant power spectrum components are\n$$\np_{n n' \\ell} = \\sum_{m=-\\ell}^{\\ell} c_{n \\ell m}\\, c_{n' \\ell m}^*,\n$$\nand the descriptor is the concatenation of $p_{n n' \\ell}$ over $\\ell \\in \\{0,1,2\\}$ and $0 \\le n \\le n' \\le N_n-1$, normalized by its Euclidean norm if the norm is nonzero.\n- For ACSF radial functions $G^{(2)}$ for a central atom with neighbors indexed by $j$, use the family\n$$\nG^{(2)}(\\eta, R_s) = \\sum_{j} \\exp\\left( -\\eta\\, (r_{j} - R_s)^2 \\right)\\, f_c(r_{j}),\n$$\nwith parameters $\\eta = 1.0$ and $R_s \\in \\{0.5, 1.0, 1.5, 2.0, 2.5\\}$ in Angstroms; report the sum of this $5$-component vector.\n- For ACSF angular functions $G^{(4)}$ over distinct neighbor pairs $(j,k)$ with $j < k$, use\n$$\nG^{(4)}(\\eta, \\zeta, \\lambda) = 2^{1-\\zeta} \\sum_{j<k} \\left( 1 + \\lambda \\cos\\theta_{jk} \\right)^{\\zeta}\n\\exp\\left( -\\eta \\left( r_j^2 + r_k^2 + r_{jk}^2 \\right) \\right)\\,\nf_c(r_{j})\\, f_c(r_{k})\\, f_c(r_{jk}),\n$$\nwhere $\\theta_{jk}$ is the angle at the central atom between neighbors $j$ and $k$, $r_j = \\|\\mathbf{r}_j\\|$, $r_k = \\|\\mathbf{r}_k\\|$, and $r_{jk} = \\|\\mathbf{r}_j - \\mathbf{r}_k\\|$. Use parameters $\\eta = 0.5$, $\\zeta = 4$, and $\\lambda = -1$.\n\nTest suite and required outputs:\n\nDefine the following five test cases, each specified as a list of neighbor positions relative to the central atom at the origin, in Angstroms:\n\n- Case $1$ (general environment): neighbors at $(1.0, 0.0, 0.0)$, $(0.0, 1.5, 0.0)$, $(0.0, 0.0, 2.0)$.\n- Case $2$ (rotated environment): rotate Case $1$ by a rotation of $90$ degrees about the $z$-axis, i.e., apply the mapping $(x,y,z) \\mapsto (-y, x, z)$ to each neighbor.\n- Case $3$ (boundary): a single neighbor at $(3.0, 0.0, 0.0)$, which lies at exactly the cutoff radius $r_c$.\n- Case $4$ (empty environment): no neighbors.\n- Case $5$ (colinear environment): two neighbors at $(1.0, 0.0, 0.0)$ and $(-1.0, 0.0, 0.0)$.\n\nYour program must compute and output the following five results, in order, as a single line containing a comma-separated list enclosed in square brackets:\n\n- The maximum absolute difference between the normalized SOAP power spectrum vectors of Case $1$ and Case $2$ as a float.\n- The value of $f_c(r)$ at $r = r_c$ from Case $3$ as a float.\n- The Euclidean norm of the normalized SOAP power spectrum vector for Case $4$ as a float.\n- The sum of the $5$-component ACSF $G^{(2)}$ vector for Case $1$ as a float.\n- The ACSF $G^{(4)}$ value for Case $5$ as a float.\n\nAll angles must be in radians. Distances must be in Angstroms. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[$result_1,$result_2,$result_3,$result_4,$result_5]\").", "solution": "The problem statement has been meticulously reviewed and is determined to be valid. It is scientifically grounded in the principles of computational materials science, self-contained with all necessary parameters and definitions, and well-posed, admitting a unique, verifiable numerical solution. We may therefore proceed with a formal solution.\n\nThe objective is to implement and numerically evaluate two types of descriptors for local atomic environments: the Smooth Overlap of Atomic Positions (SOAP) and Atom-Centered Symmetry Functions (ACSF). These descriptors are designed to provide a numerical fingerprint of an atom's local environment that is invariant to translation, rotation, and permutation of identical neighboring atoms.\n\n### 1. Fundamental Definitions\n\nWe begin with the foundational elements common to both descriptor types. The local environment is defined for a central atom, which we place at the origin $\\mathbf{0}$, and a set of neighboring atoms at positions $\\{\\mathbf{r}_j\\}$.\n\nAn essential component is the smooth cutoff function, $f_c(r)$, which ensures that only atoms within a certain radius $r_c$ contribute to the descriptor. This locality is crucial for computational efficiency and physical relevance. The specified cutoff function is:\n$$\nf_c(r) = \\begin{cases} \\frac{1}{2}\\left[\\cos\\left(\\frac{\\pi r}{r_c}\\right) + 1\\right] & \\text{if } r \\le r_c \\\\ 0 & \\text{if } r > r_c \\end{cases}\n$$\nwith a cutoff radius $r_c = 3.0$ Angstroms. Here, $r = \\|\\mathbf{r}\\|$ is the radial distance.\n\n### 2. Smooth Overlap of Atomic Positions (SOAP) Descriptor\n\nThe SOAP descriptor is constructed by expanding the local atomic density in a basis of functions and then forming a rotationally invariant power spectrum. The problem specifies an approximate form where the atomic density is a sum of Dirac delta functions, $\\rho(\\mathbf{r}) = \\sum_j \\delta(\\mathbf{r} - \\mathbf{r}_j)$.\n\n**Step 2.1: Orthonormal Radial Basis $\\{\\phi_n(r)\\}$**\nThe first step is to construct an orthonormal basis for the radial part of the expansion. We start with a set of non-orthogonal Gaussian functions:\n$$\ng_k(r) = \\exp\\left( -\\frac{(r - R_k)^2}{2\\sigma_r^2} \\right)\n$$\nfor $k \\in \\{0, 1, ..., N_n-1\\}$. The problem specifies $N_n = 3$ radial functions, $\\sigma_r = 0.3$ Angstroms, and centers $R_k = r_c \\cdot \\frac{k+1}{N_n+1}$.\n\nThese functions are orthogonalized using the Gram-Schmidt procedure with respect to a weighted inner product, $\\langle u, v \\rangle = \\int_{0}^{r_c} u(r)\\,v(r)\\,r^2 \\,\\mathrm{d}r$. Numerically, this integral is discretized on a uniform radial grid of $N_r = 400$ points from $r=0$ to $r=r_c$. Let the grid points be $\\{r_i\\}$ with spacing $\\Delta r$. The inner product is approximated by the sum:\n$$\n\\langle u, v \\rangle \\approx \\sum_{i=0}^{N_r-1} u(r_i)v(r_i)r_i^2 \\Delta r\n$$\nThe Gram-Schmidt process is then applied to the set $\\{g_k(r)\\}$ to obtain the orthonormal basis $\\{\\phi_n(r)\\}$.\n\n**Step 2.2: Expansion Coefficients $c_{n \\ell m}$**\nThe atomic environment is projected onto a basis formed by the product of our radial basis functions $\\phi_n(r)$ and the complex spherical harmonics $Y_{\\ell m}(\\theta, \\phi)$, where $\\theta$ is the colatitude and $\\phi$ is the azimuth. The expansion coefficients are given by summing the contributions from each neighbor $j$ within the cutoff radius:\n$$\nc_{n \\ell m} = \\sum_{j} \\phi_n(r_j)\\, Y_{\\ell m}(\\theta_j,\\phi_j)\\, f_c(r_j)\n$$\nwhere $(r_j, \\theta_j, \\phi_j)$ are the spherical coordinates of the neighbor at position $\\mathbf{r}_j$. The values of $\\phi_n(r_j)$ are obtained by evaluating the numerically defined basis functions at the distance $r_j$, for which linear interpolation on the radial grid is a suitable method. The angular resolution is limited by $\\ell_{\\max} = 2$.\n\n**Step 2.3: Power Spectrum $p_{n n' \\ell}$ and Final Descriptor**\nTo achieve rotational invariance, we construct the power spectrum by summing over the magnetic quantum number $m$:\n$$\np_{n n' \\ell} = \\sum_{m=-\\ell}^{\\ell} c_{n \\ell m}\\, c_{n' \\ell m}^*\n$$\nwhere $c^*$ denotes the complex conjugate. The components $p_{n n' \\ell}$ are invariant under rotations of the coordinate system. The final SOAP descriptor is a vector formed by concatenating the real-valued components $p_{n n' \\ell}$ for all $\\ell \\in \\{0, 1, 2\\}$ and all unique pairs $0 \\le n \\le n' \\le N_n-1$. This vector is then normalized to unit length by dividing by its Euclidean norm, provided the norm is non-zero.\n\n### 3. Atom-Centered Symmetry Functions (ACSF)\n\nACSFs are another class of descriptors built directly from geometric quantities (distances and angles) to ensure invariance by construction.\n\n**Step 3.1: Radial Function $G^{(2)}$**\nThe radial symmetry function $G^{(2)}$ probes the radial distribution of neighbors. It is defined as a sum over all neighbors $j$:\n$$\nG^{(2)}(\\eta, R_s) = \\sum_{j} \\exp\\left( -\\eta\\, (r_{j} - R_s)^2 \\right)\\, f_c(r_{j})\n$$\nwhere $\\eta$ controls the width of the Gaussian and $R_s$ is a variable center. The problem requires computing a vector of $G^{(2)}$ values for parameters $\\eta = 1.0$ and $R_s \\in \\{0.5, 1.0, 1.5, 2.0, 2.5\\}$ and reporting the sum of these five components.\n\n**Step 3.2: Angular Function $G^{(4)}$**\nThe angular symmetry function $G^{(4)}$ probes the angular distribution of neighbors, considering triplets of atoms (the central atom and two neighbors, $j$ and $k$). It is defined as:\n$$\nG^{(4)}(\\eta, \\zeta, \\lambda) = 2^{1-\\zeta} \\sum_{j<k} \\left( 1 + \\lambda \\cos\\theta_{jk} \\right)^{\\zeta}\n\\exp\\left( -\\eta \\left( r_j^2 + r_k^2 + r_{jk}^2 \\right) \\right)\\,\nf_c(r_{j})\\, f_c(r_{k})\\, f_c(r_{jk})\n$$\nwhere the sum is over unique pairs of neighbors $(j, k)$. $\\theta_{jk}$ is the angle between vectors $\\mathbf{r}_j$ and $\\mathbf{r}_k$. A crucial detail is that the cutoff function is applied not only to the neighbor distances $r_j$ and $r_k$ but also to the inter-neighbor distance $r_{jk} = \\|\\mathbf{r}_j - \\mathbf{r}_k\\|$. The parameters are given as $\\eta = 0.5$, $\\zeta = 4$, and $\\lambda = -1$.\n\n### 4. Computation for Test Cases\n\nThe implementation will proceed by first defining functions for $f_c(r)$, SOAP, $G^{(2)}$, and $G^{(4)}$ according to the specifications above. These functions will then be applied to the five test cases to generate the required outputs.\n\n1.  **SOAP Invariance**: Compute the normalized SOAP vector for Case 1 and Case 2 (a rotated version of Case 1). The maximum absolute difference between the two vectors will be calculated. Due to the rotational invariance of the power spectrum, this difference is expected to be numerically close to zero.\n2.  **Cutoff Value**: Evaluate $f_c(r)$ at $r = r_c = 3.0$ Angstroms. By its definition, this must be exactly $0$.\n3.  **SOAP for Empty Environment**: For Case 4 with no neighbors, the sum over neighbors in the expression for $c_{n \\ell m}$ is an empty sum, resulting in $c_{n \\ell m} = 0$ for all indices. Consequently, the power spectrum vector is a zero vector, and its Euclidean norm is $0$.\n4.  **ACSF $G^{(2)}$ Sum**: For Case 1, compute the five $G^{(2)}$ values corresponding to the five different $R_s$ values and sum them.\n5.  **ACSF $G^{(4)}$ Value**: For Case 5 (colinear neighbors), compute the single $G^{(4)}$ value using the specified formula and parameters. This involves summing over the single unique pair of neighbors.\n\nThe implementation will be carried out in Python using the `numpy` and `scipy` libraries, adhering to the specified environment.", "answer": "```python\nimport numpy as np\nfrom scipy.special import sph_harm\n\ndef solve():\n    \"\"\"\n    Main function to compute and print the required results for the five test cases.\n    \"\"\"\n    \n    # --- Problem Parameters ---\n    RC = 3.0  # Cutoff radius in Angstroms\n\n    # SOAP parameters\n    N_N = 3  # Number of radial basis functions\n    L_MAX = 2  # Maximum angular momentum\n    SIGMA_R = 0.3  # Width of Gaussian radial probes\n    N_R = 400  # Number of points in the radial grid\n\n    # ACSF G2 parameters\n    G2_ETA = 1.0\n    G2_RS_VALUES = np.array([0.5, 1.0, 1.5, 2.0, 2.5])\n\n    # ACSF G4 parameters\n    G4_ETA = 0.5\n    G4_ZETA = 4.0\n    G4_LAMBDA = -1.0\n\n    # --- Helper Functions ---\n\n    def cartesian_to_spherical(xyz):\n        \"\"\"Converts Cartesian coordinates to spherical coordinates (r, theta, phi).\"\"\"\n        if xyz.ndim == 1:\n            xyz = xyz.reshape(1, -1)\n        r = np.sqrt(np.sum(xyz**2, axis=1))\n        # np.arccos is sensitive to values slightly > 1.0 due to precision\n        safe_z_over_r = np.clip(xyz[:, 2] / r, -1.0, 1.0)\n        theta = np.arccos(safe_z_over_r)  # Colatitude\n        phi = np.arctan2(xyz[:, 1], xyz[:, 0])  # Azimuth\n        return r, theta, phi\n\n    def cutoff_function(r, rc):\n        \"\"\"Smooth cosine cutoff function.\"\"\"\n        r = np.asarray(r)\n        fc = np.zeros_like(r, dtype=float)\n        mask = r <= rc\n        fc[mask] = 0.5 * (np.cos(np.pi * r[mask] / rc) + 1.0)\n        return fc\n\n    # --- SOAP Implementation ---\n\n    # Pre-calculate the orthonormal radial basis to be reused.\n    def create_soap_radial_basis(n_n, rc, sigma_r, n_r):\n        \"\"\"Constructs the orthonormal radial basis via Gram-Schmidt.\"\"\"\n        r_grid = np.linspace(0, rc, n_r)\n        dr = r_grid[1] - r_grid[0]\n\n        # Initial Gaussian basis functions\n        g_basis = []\n        r_k_centers = rc * (np.arange(n_n) + 1) / (n_n + 1)\n        for r_k in r_k_centers:\n            g_k = np.exp(-((r_grid - r_k) ** 2) / (2 * sigma_r ** 2))\n            g_basis.append(g_k)\n        \n        # Inner product for functions on the grid\n        def inner_product(f1, f2):\n            integrand = f1 * f2 * r_grid**2\n            return np.sum(integrand) * dr\n\n        # Gram-Schmidt orthonormalization\n        ortho_basis = []\n        for g_n in g_basis:\n            phi_n = g_n\n            for phi_j in ortho_basis:\n                phi_n = phi_n - inner_product(g_n, phi_j) * phi_j\n            \n            norm = np.sqrt(inner_product(phi_n, phi_n))\n            if norm > 1e-15:\n                phi_n /= norm\n            else: # Handle case of linearly dependent vector\n                phi_n *= 0.0\n            ortho_basis.append(phi_n)\n            \n        return r_grid, ortho_basis\n\n    R_GRID, PHI_BASIS = create_soap_radial_basis(N_N, RC, SIGMA_R, N_R)\n\n    def compute_soap_descriptor(neighbors, rc, n_n, l_max, r_grid, phi_basis):\n        \"\"\"Computes the normalized SOAP power spectrum vector.\"\"\"\n        if len(neighbors) == 0:\n            n_components = sum((n_n * (n_n + 1) // 2 for l in range(l_max + 1)))\n            return np.zeros(n_components)\n\n        r_j, theta_j, phi_j = cartesian_to_spherical(neighbors)\n        fc_j = cutoff_function(r_j, rc)\n        \n        valid_indices = np.where(r_j <= rc)[0]\n        if len(valid_indices) == 0:\n            n_components = sum((n_n * (n_n + 1) // 2 for l in range(l_max + 1)))\n            return np.zeros(n_components)\n\n        # Interpolate radial basis functions at neighbor distances\n        phi_n_r_j = np.array([np.interp(r_j[valid_indices], r_grid, phi_n) for phi_n in phi_basis])\n\n        # Compute expansion coefficients c_nlm\n        c_nlm = np.zeros((n_n, l_max + 1, 2 * l_max + 1), dtype=complex)\n        for n in range(n_n):\n            for l in range(l_max + 1):\n                for m in range(-l, l + 1):\n                    # scipy.special.sph_harm takes (m, l, azimuth, polar)\n                    ylm = sph_harm(m, l, phi_j[valid_indices], theta_j[valid_indices])\n                    # Sum over valid neighbors\n                    c_nlm[n, l, m + l_max] = np.sum(phi_n_r_j[n] * ylm * fc_j[valid_indices])\n\n        # Compute power spectrum p_nn'l\n        power_spectrum_list = []\n        for l in range(l_max + 1):\n            for n1 in range(n_n):\n                for n2 in range(n1, n_n):\n                    # sum over m\n                    c1 = c_nlm[n1, l, l_max-l : l_max+l+1]\n                    c2_conj = np.conj(c_nlm[n2, l, l_max-l : l_max+l+1])\n                    p_val = np.sum(c1 * c2_conj)\n                    power_spectrum_list.append(p_val.real) # Should be real anyway\n\n        p_vec = np.array(power_spectrum_list)\n        norm = np.linalg.norm(p_vec)\n\n        if norm > 1e-15:\n            return p_vec / norm\n        return p_vec\n\n    # --- ACSF Implementation ---\n\n    def compute_g2_sum(neighbors, rc, eta, rs_values):\n        \"\"\"Computes the sum of the G2 ACSF vector components.\"\"\"\n        if len(neighbors) == 0:\n            return 0.0\n        \n        r_j = np.linalg.norm(neighbors, axis=1)\n        fc_j = cutoff_function(r_j, rc)\n        \n        g2_vector = []\n        for rs in rs_values:\n            g2_val = np.sum(np.exp(-eta * (r_j - rs)**2) * fc_j)\n            g2_vector.append(g2_val)\n            \n        return np.sum(g2_vector)\n\n    def compute_g4(neighbors, rc, eta, zeta, lam):\n        \"\"\"Computes the G4 angular ACSF value.\"\"\"\n        num_neighbors = len(neighbors)\n        if num_neighbors < 2:\n            return 0.0\n            \n        total_g4 = 0.0\n        \n        for j in range(num_neighbors):\n            for k in range(j + 1, num_neighbors):\n                r_j_vec = neighbors[j]\n                r_k_vec = neighbors[k]\n                \n                r_j = np.linalg.norm(r_j_vec)\n                r_k = np.linalg.norm(r_k_vec)\n                \n                r_jk_vec = r_k_vec - r_j_vec\n                r_jk = np.linalg.norm(r_jk_vec)\n                \n                fc_j = cutoff_function(r_j, rc)\n                fc_k = cutoff_function(r_k, rc)\n                fc_jk = cutoff_function(r_jk, rc)\n                \n                if fc_j == 0 or fc_k == 0 or fc_jk == 0:\n                    continue\n\n                # cos(theta_jk) = (r_j . r_k) / (|r_j| |r_k|)\n                cos_theta_jk = np.dot(r_j_vec, r_k_vec) / (r_j * r_k)\n                \n                term = (1 + lam * cos_theta_jk)**zeta\n                exp_term = np.exp(-eta * (r_j**2 + r_k**2 + r_jk**2))\n                \n                total_g4 += term * exp_term * fc_j * fc_k * fc_jk\n                \n        return (2**(1 - zeta)) * total_g4\n\n    # --- Test Cases ---\n    \n    test_cases = {\n        1: np.array([[1.0, 0.0, 0.0], [0.0, 1.5, 0.0], [0.0, 0.0, 2.0]]),\n        2: np.array([[0.0, 1.0, 0.0], [-1.5, 0.0, 0.0], [0.0, 0.0, 2.0]]), # Case 1 rotated\n        3: np.array([[3.0, 0.0, 0.0]]),\n        4: np.empty((0, 3)),\n        5: np.array([[1.0, 0.0, 0.0], [-1.0, 0.0, 0.0]])\n    }\n\n    # --- Calculate Required Outputs ---\n    \n    results = []\n\n    # Result 1: Max absolute difference between SOAP for Case 1 and Case 2\n    soap1 = compute_soap_descriptor(test_cases[1], RC, N_N, L_MAX, R_GRID, PHI_BASIS)\n    soap2 = compute_soap_descriptor(test_cases[2], RC, N_N, L_MAX, R_GRID, PHI_BASIS)\n    result1 = np.max(np.abs(soap1 - soap2))\n    results.append(result1)\n\n    # Result 2: Value of f_c(r) at r = r_c for Case 3\n    result2 = cutoff_function(test_cases[3][0, 0], RC)\n    results.append(result2)\n\n    # Result 3: Euclidean norm of normalized SOAP for Case 4\n    soap4 = compute_soap_descriptor(test_cases[4], RC, N_N, L_MAX, R_GRID, PHI_BASIS)\n    # The problem asks for the norm of the *final* vector.\n    # If the initial norm is 0, the vector is not normalized and remains 0.\n    # So the norm of the final vector is also 0.\n    result3 = np.linalg.norm(soap4)\n    results.append(result3)\n\n    # Result 4: Sum of 5-component ACSF G2 vector for Case 1\n    result4 = compute_g2_sum(test_cases[1], RC, G2_ETA, G2_RS_VALUES)\n    results.append(result4)\n\n    # Result 5: ACSF G4 value for Case 5\n    result5 = compute_g4(test_cases[5], RC, G4_ETA, G4_ZETA, G4_LAMBDA)\n    results.append(result5)\n\n    # Final print statement\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```", "id": "3443939"}, {"introduction": "While pair correlation functions are useful, they cannot distinguish all physically distinct atomic arrangements. This exercise [@problem_id:3443973] challenges you to construct non-superimposable local environments that share an identical pair distribution, demonstrating the limitations of purely radial information. By determining the minimal angular resolution $l_{\\max}$ required for a SOAP-like descriptor to tell them apart, you will gain a deep, intuitive appreciation for the resolving power of angular basis functions.", "problem": "You are tasked with constructing and analyzing two three-dimensional local atomic environments that have identical pair distributions but are not superimposable by any rigid rotation or reflection. The goal is to determine the minimal angular resolution, expressed as the smallest nonnegative integer $l_{\\max}$, required by a rotationally invariant descriptor based on the Smooth Overlap of Atomic Positions (SOAP) to distinguish the environments. The target descriptor must be built directly from the angular decomposition of the neighbor distribution and must be rotationally invariant at each angular order $l$.\n\nThe fundamental base for this task is the following:\n- The pair distribution around a central atom, denoted by $g(r)$, depends only on the multiset of neighbor distances to the central atom and discards all angular information.\n- The spherical harmonics form an orthonormal basis on the unit sphere, indexed by $(l,m)$ with $l \\in \\{0,1,2,\\dots\\}$ and $m \\in \\{-l,-l+1,\\dots,l\\}$.\n- Rotational invariance is obtained by aggregating the angular mode magnitudes in a way that does not depend on orientation; specifically, summing across $m$ at fixed $l$ yields rotationally invariant quantities.\n\nYou must implement a program that, for each test case provided below, performs the following steps:\n- Construct two local environments around a central atom as finite sets of neighbor vectors. Each neighbor vector is a three-dimensional Cartesian vector indicating the neighbor position relative to the central atom. All angles must be handled in radians.\n- Ensure both environments in the pair have the same pair distribution $g(r)$ by using identical multisets of neighbor radii in each environment, so that only angular information differs.\n- Adopt the zero-width limit of the standard SOAP atomic density (so that each neighbor contributes as a direction point on the unit sphere) and use an orthonormal radial channeling scheme consistent with partitioning the radius into shells. Use piecewise-constant, mutually orthogonal radial channels over the specified shells to separate contributions from different radii; in the single-shell cases, there is exactly one shell. For multi-shell cases, define two shells by a splitting radius as specified.\n- For a chosen nonnegative search limit $L_{\\text{search}}$, compute a rotationally invariant descriptor at each angular order $l \\in \\{0,1,\\dots,L_{\\text{search}}\\}$ by projecting the neighbor directions within each radial shell onto spherical harmonics and aggregating magnitudes across $m$ to form rotationally invariant quantities for each $l$. For multi-shell cases, include cross-channel correlations between shells to form the descriptor at each $l$.\n- Determine the minimal $l_{\\max} \\in \\{0,1,\\dots,L_{\\text{search}}\\}$ at which the two environmentsâ€™ descriptors differ beyond a fixed numerical tolerance, or return $-1$ if no difference is detected for any $l \\le L_{\\text{search}}$.\n\nYour program must implement the above using:\n- Spherical harmonics evaluated with arguments in radians.\n- A numerical tolerance of $10^{-12}$ to decide equality between descriptors.\n- The search limit $L_{\\text{search}} = 12$.\n\nDesign the environments in the following test suite. In all cases, neighbor radii carry no physical units and are pure numbers, and all angular quantities are in radians.\n\n- Test case $1$ (single shell): Environment $\\mathcal{A}_1$ has $4$ neighbors at radius $1$, positioned at the vertices of a regular tetrahedron inscribed in the unit sphere (use the four directions $(\\pm 1,\\pm 1,\\pm 1)/\\sqrt{3}$ with an even number of minus signs). Environment $\\mathcal{B}_1$ has $4$ neighbors at radius $1$, positioned in the equatorial plane at directions $(1,0,0)$, $(-1,0,0)$, $(0,1,0)$, $(0,-1,0)$. Both have the same $g(r)$ since all neighbor radii are $1$.\n- Test case $2$ (single shell): Environment $\\mathcal{A}_2$ has $6$ neighbors at radius $1$ at directions $(\\pm 1,0,0)$, $(0,\\pm 1,0)$, $(0,0,\\pm 1)$ (an octahedral arrangement). Environment $\\mathcal{B}_2$ has $6$ neighbors at radius $1$ arranged uniformly on the equatorial circle with azimuthal angles $0$, $\\pi/3$, $2\\pi/3$, $\\pi$, $4\\pi/3$, $5\\pi/3$ and polar angle $\\pi/2$. Both have the same $g(r)$ since all neighbor radii are $1$.\n- Test case $3$ (single shell): Environment $\\mathcal{A}_3$ is identical to $\\mathcal{A}_1$. Environment $\\mathcal{B}_3$ is obtained by rotating $\\mathcal{A}_1$ by an angle $0.37$ around the $z$-axis. These two are isomorphic by rotation, so their rotationally invariant descriptors should coincide for all $l$.\n- Test case $4$ (two shells): Environment $\\mathcal{A}_4$ has $5$ neighbors with radii $\\{1,1,1.5,1.5,1.5\\}$. Place the two neighbors at radius $1$ along $(0,0,1)$ and $(0,0,-1)$. Place the three neighbors at radius $1.5$ in the equatorial plane at azimuths $0$, $2\\pi/3$, $4\\pi/3$ with polar angle $\\pi/2$. Environment $\\mathcal{B}_4$ has the same multiset of radii $\\{1,1,1.5,1.5,1.5\\}$, with the two neighbors at radius $1$ also along $(0,0,1)$ and $(0,0,-1)$, but the three neighbors at radius $1.5$ arranged off the equatorial plane at a common polar angle $1.0$ and azimuths $0$, $2\\pi/3$, $4\\pi/3$. Use a two-shell radial scheme with splitting radius $1.25$ so that radius $1$ belongs to the inner shell and radius $1.5$ belongs to the outer shell.\n\nFor each test case, search $l$ from $0$ to $L_{\\text{search}}$ and report the minimal $l_{\\max}$ at which the rotationally invariant descriptor of the two environments differs beyond the tolerance, or $-1$ if no difference is detected within the search. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[\\text{result1},\\text{result2},\\text{result3},\\text{result4}]$), where each entry is an integer in $\\{-1,0,1,\\dots,12\\}$.", "solution": "The problem requires the determination of the minimal angular resolution, denoted by the integer $l_{\\max}$, for a rotationally invariant descriptor to distinguish between pairs of three-dimensional local atomic environments. These environments are constructed to have identical pair distributions but differing higher-order (angular) correlations. The descriptor is based on the Smooth Overlap of Atomic Positions (SOAP) formalism, simplified to the zero-width limit for atomic neighbors.\n\n### Mathematical Framework\nA local atomic environment is defined by a set of neighbor position vectors $\\{\\vec{r}_i\\}$ relative to a central atom. The atomic neighbor density $\\rho(\\vec{r})$ is a sum of Dirac delta functions centered at each neighbor's position:\n$$\n\\rho(\\vec{r}) = \\sum_i \\delta(\\vec{r} - \\vec{r}_i)\n$$\nThis density is expanded in a basis of spherical harmonics $Y_{lm}(\\hat{r})$ for the angular part and a radial basis $g_n(r)$ for the radial part. The problem specifies a simplified radial scheme where neighbors are partitioned into disjoint shells. The expansion coefficients for the density within a specific shell $n$ are given by:\n$$\nc_{nlm} = \\int \\rho(\\vec{r}) g_n(r) Y_{lm}^*(\\hat{r}) d\\vec{r}\n$$\nWith the delta-function density and a partitioning scheme where $g_n(r)$ is effectively an indicator function for shell $n$, this integral simplifies to a sum over the neighbors $\\{i\\}$ belonging to that shell, which we denote by the set $I_n$:\n$$\nc_{nlm} = \\sum_{i \\in I_n} Y_{lm}^*(\\theta_i, \\phi_i)\n$$\nwhere $(\\theta_i, \\phi_i)$ are the polar and azimuthal angles of the neighbor vector $\\vec{r}_i$. The spherical harmonics $Y_{lm}(\\theta, \\phi)$ are evaluated using the standard physics convention, with $\\theta \\in [0, \\pi]$ and $\\phi \\in [0, 2\\pi)$.\n\n### Rotationally Invariant Descriptor\nTo achieve rotational invariance, we construct the power spectrum from the expansion coefficients. For a given angular momentum channel $l$, the power spectrum components are formed by coupling coefficients from two radial shells, $n_1$ and $n_2$, and summing over the magnetic quantum number $m$:\n$$\np_{n_1 n_2 l} = \\sum_{m=-l}^{l} c_{n_1 l m}^* c_{n_2 l m}\n$$\nThese quantities are invariant under rigid rotation of the atomic environment. The collection of these values for a given $l$ constitutes the descriptor at that angular order.\n\n-   **Single-Shell Case**: We have only one shell ($n_1=n_2=1$). The descriptor at order $l$ is the scalar value $p_{11l} = \\sum_{m=-l}^{l} |c_{1lm}|^2$.\n-   **Two-Shell Case**: For two shells ($n \\in \\{1, 2\\}$), the descriptor at order $l$ must include all auto-correlations ($p_{11l}, p_{22l}$) and cross-correlations ($p_{12l}, p_{21l}$). Since $p_{21l} = p_{12l}^*$, the distinct information for a given $l$ is captured by the vector of real numbers $(p_{11l}, p_{22l}, \\text{Re}(p_{12l}), \\text{Im}(p_{12l}))$.\n\n### Algorithm for Finding $l_{\\max}$\nFor each pair of environments, $\\mathcal{A}$ and $\\mathcal{B}$, we search for the smallest non-negative integer $l_{\\max}$ at which their descriptors differ.\n\n1.  For each angular order $l$ from $0$ to $L_{\\text{search}} = 12$:\n    a.  Compute the descriptor vector for environment $\\mathcal{A}$, denoted $D_l^{(\\mathcal{A})}$.\n    b.  Compute the descriptor vector for environment $\\mathcal{B}$, denoted $D_l^{(\\mathcal{B})}$.\n    c.  If the Euclidean distance $\\|D_l^{(\\mathcal{A})} - D_l^{(\\mathcal{B})}\\| > 10^{-12}$, then $l$ is the minimal distinguishing angular order. We set $l_{\\max} = l$ and terminate the search for this pair.\n2.  If the loop completes without finding any difference, the environments are indistinguishable up to $L_{\\text{search}}$. In this case, we set $l_{\\max} = -1$.\n\n### Analysis of Test Cases\n\n-   **Test Case 1**: A regular tetrahedron ($\\mathcal{A}_1$, symmetry group $T_d$) versus a square planar arrangement ($\\mathcal{B}_1$, symmetry $D_{4h}$). Due to its high symmetry, the tetrahedral environment's multipole moments for $l=1$ (dipole) and $l=2$ (quadrupole) are zero. The square planar structure, being less symmetric, possesses a non-zero quadrupole moment. Thus, their power spectra will be $p_{11,2}^{(\\mathcal{A}_1)} = 0$ but $p_{11,2}^{(\\mathcal{B}_1)} \\neq 0$. The expected result is $l_{\\max}=2$.\n\n-   **Test Case 2**: An octahedron ($\\mathcal{A}_2$, symmetry $O_h$) versus a planar regular hexagon ($\\mathcal{B}_2$, symmetry $D_{6h}$). Both structures have inversion symmetry, causing all odd-$l$ components of the power spectrum to vanish. The octahedral geometry is highly symmetric, and its first non-zero multipole moment occurs at $l=4$. The planar hexagon has a non-zero quadrupole moment ($l=2$). Therefore, we expect $p_{11,2}^{(\\mathcal{A}_2)} = 0$ and $p_{11,2}^{(\\mathcal{B}_2)} \\neq 0$, leading to $l_{\\max}=2$.\n\n-   **Test Case 3**: A regular tetrahedron ($\\mathcal{A}_3$) versus the same tetrahedron rotated by $0.37$ radians ($\\mathcal{B}_3$). The descriptor is designed to be rotationally invariant. Thus, the descriptors for $\\mathcal{A}_3$ and $\\mathcal{B}_3$ should be identical for all $l$ within numerical precision. The expected result is $l_{\\max}=-1$.\n\n-   **Test Case 4**: A two-shell environment with $D_{3h}$ symmetry ($\\mathcal{A}_4$) versus one with $C_{3v}$ symmetry ($\\mathcal{B}_4$). The inner shell is identical in both environments. The outer shell of $\\mathcal{A}_4$ consists of three atoms in the equatorial plane, whose vector sum is zero, leading to a zero dipole moment ($c_{2,1,m}^{(\\mathcal{A}_4)}=0$). The outer shell of $\\mathcal{B}_4$ has its three atoms at a polar angle of $1.0$ radian, resulting in a net non-zero vector sum along the $z$-axis. This implies a non-zero dipole moment ($c_{2,1,0}^{(\\mathcal{B}_4)} \\neq 0$). Consequently, the power spectrum term $p_{22,1}$ will be zero for $\\mathcal{A}_4$ but non-zero for $\\mathcal{B}_4$. The environments are expected to be distinguished at $l=1$.", "answer": "```python\n# The complete and runnable Python 3 code.\n# Execution environment: python 3.12, numpy 1.23.5, scipy 1.11.4\nimport numpy as np\nfrom scipy.special import sph_harm\n\ndef cart_to_sph(vecs):\n    \"\"\"Converts Cartesian coordinates to spherical coordinates (r, theta, phi).\"\"\"\n    r = np.linalg.norm(vecs, axis=1)\n    # Handle the case of the origin to avoid division by zero\n    theta = np.zeros_like(r)\n    phi = np.zeros_like(r)\n    non_zero_r_mask = r > 1e-15\n    \n    # Polar angle theta from z-axis\n    theta[non_zero_r_mask] = np.arccos(vecs[non_zero_r_mask, 2] / r[non_zero_r_mask])\n    \n    # Azimuthal angle phi from x-axis in xy-plane\n    phi[non_zero_r_mask] = np.arctan2(vecs[non_zero_r_mask, 1], vecs[non_zero_r_mask, 0])\n    return r, theta, phi\n\ndef compute_descriptors_for_l(env_points_by_shell, l_val, n_shells):\n    \"\"\"\n    Computes the descriptor vector for a single l value.\n    'env_points_by_shell' is a list of (thetas, phis) tuples, one for each shell.\n    \"\"\"\n    # Compute c_nlm coefficients for each shell\n    c_lms_per_shell = []\n    for thetas, phis in env_points_by_shell:\n        c_lm = np.zeros(2 * l_val + 1, dtype=np.complex128)\n        if thetas.size > 0:\n            for m_idx, m_val in enumerate(range(-l_val, l_val + 1)):\n                # scipy.special.sph_harm(m, l, phi, theta)\n                ylm_vals = sph_harm(m_val, l_val, phis, thetas)\n                c_lm[m_idx] = np.sum(np.conj(ylm_vals))\n        c_lms_per_shell.append(c_lm)\n\n    # Compute power spectrum components p_n1n2l\n    if n_shells == 1:\n        c1 = c_lms_per_shell[0]\n        p11l = np.sum(np.conj(c1) * c1).real\n        return np.array([p11l])\n    elif n_shells == 2:\n        c1 = c_lms_per_shell[0]\n        c2 = c_lms_per_shell[1]\n        p11l = np.sum(np.conj(c1) * c1).real\n        p22l = np.sum(np.conj(c2) * c2).real\n        p12l = np.sum(np.conj(c1) * c2)\n        return np.array([p11l, p22l, p12l.real, p12l.imag])\n    return np.array([])\n\ndef find_lmax(env_a_pts, env_b_pts, l_search, n_shells=1, split_radius=None, tol=1e-12):\n    \"\"\"\n    Finds the minimal l_max at which two environments' descriptors differ.\n    \"\"\"\n    \n    # Partition neighbors into shells and get spherical coords\n    def get_spherical_coords_by_shell(points):\n        coords_by_shell = []\n        if n_shells == 1:\n            if points.shape[0] > 0:\n                _, thetas, phis = cart_to_sph(points)\n                coords_by_shell.append((thetas, phis))\n            else:\n                 coords_by_shell.append((np.array([]), np.array([])))\n        elif n_shells == 2:\n            radii = np.linalg.norm(points, axis=1)\n            shell1_pts = points[radii < split_radius]\n            shell2_pts = points[radii >= split_radius]\n            for shell_pts in [shell1_pts, shell2_pts]:\n                if shell_pts.shape[0] > 0:\n                    _, thetas, phis = cart_to_sph(shell_pts)\n                    coords_by_shell.append((thetas, phis))\n                else:\n                    coords_by_shell.append((np.array([]), np.array([])))\n        return coords_by_shell\n\n    sph_coords_a = get_spherical_coords_by_shell(env_a_pts)\n    sph_coords_b = get_spherical_coords_by_shell(env_b_pts)\n\n    for l_val in range(l_search + 1):\n        desc_a = compute_descriptors_for_l(sph_coords_a, l_val, n_shells)\n        desc_b = compute_descriptors_for_l(sph_coords_b, l_val, n_shells)\n        \n        diff = np.linalg.norm(desc_a - desc_b)\n        \n        if diff > tol:\n            return l_val\n    \n    return -1\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the analysis, and print results.\n    \"\"\"\n    L_SEARCH = 12\n\n    # Test Case 1: Tetrahedron vs. Square Planar\n    a1_pts = np.array([[1, 1, 1], [1, -1, -1], [-1, 1, -1], [-1, -1, 1]]) / np.sqrt(3)\n    b1_pts = np.array([[1, 0, 0], [-1, 0, 0], [0, 1, 0], [0, -1, 0]], dtype=float)\n\n    # Test Case 2: Octahedron vs. Planar Hexagon\n    a2_pts = np.array([[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]], dtype=float)\n    b2_phis = np.arange(6) * np.pi / 3\n    b2_pts = np.array([[np.cos(phi), np.sin(phi), 0] for phi in b2_phis])\n\n    # Test Case 3: Tetrahedron vs. Rotated Tetrahedron\n    a3_pts = a1_pts.copy()\n    angle = 0.37\n    rot_matrix = np.array([\n        [np.cos(angle), -np.sin(angle), 0],\n        [np.sin(angle),  np.cos(angle), 0],\n        [0, 0, 1]\n    ])\n    b3_pts = a3_pts @ rot_matrix.T\n\n    # Test Case 4: Two-shell D3h vs. C3v-like\n    a4_shell1 = np.array([[0, 0, 1.0], [0, 0, -1.0]]) * 1.0\n    a4_phis = np.arange(3) * 2 * np.pi / 3\n    a4_shell2 = np.array([[np.cos(phi), np.sin(phi), 0] for phi in a4_phis]) * 1.5\n    a4_pts = np.vstack([a4_shell1, a4_shell2])\n    \n    b4_shell1 = np.array([[0, 0, 1.0], [0, 0, -1.0]]) * 1.0\n    b4_theta = 1.0\n    b4_phis = np.arange(3) * 2 * np.pi / 3\n    b4_shell2 = np.array([\n        [np.sin(b4_theta) * np.cos(phi), np.sin(b4_theta) * np.sin(phi), np.cos(b4_theta)]\n        for phi in b4_phis\n    ]) * 1.5\n    b4_pts = np.vstack([b4_shell1, b4_shell2])\n\n    test_cases = [\n        (a1_pts, b1_pts, 1, None),\n        (a2_pts, b2_pts, 1, None),\n        (a3_pts, b3_pts, 1, None),\n        (a4_pts, b4_pts, 2, 1.25)\n    ]\n    \n    results = []\n    for a_pts, b_pts, n_shells, split_radius in test_cases:\n        lmax = find_lmax(a_pts, b_pts, L_SEARCH, n_shells=n_shells, split_radius=split_radius)\n        results.append(lmax)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3443973"}, {"introduction": "A primary application of atomic descriptors is in building machine-learned interatomic potentials for molecular dynamics (MD) simulations. A critical requirement for stable MD is a potential energy surface that yields continuous forces, meaning the energy function must be at least $C^1$-smooth. This exercise [@problem_id:3443993] investigates how the mathematical choice of the cutoff function $f_c(r)$ impacts the smoothness of the resulting descriptor and, by extension, the forces, revealing a crucial consideration for developing robust potentials.", "problem": "Consider an atom-centered radial descriptor used in machine-learned interatomic potentials, defined as $G(r) = \\phi(r)\\,f_c(r)$, where $r$ is the scalar interatomic distance between a central atom and a neighbor, $\\phi(r)$ is a smooth radial basis, and $f_c(r)$ is a cutoff function that enforces locality by tapering contributions to zero at a finite cutoff distance $r_c$. This construction is standard in Atom-Centered Symmetry Functions (ACSF) and is also analogous to localized kernels used in Smooth Overlap of Atomic Positions (SOAP).\n\nAssume the radial basis is the Gaussian $\\phi(r) = \\exp\\!\\left(-\\eta\\,(r - R_s)^2\\right)$, with parameters $\\eta > 0$ and $R_s \\ge 0$. The cutoff function $f_c(r)$ is chosen from three classes, each of different smoothness at the cutoff $r = r_c$:\n\n1. $C^0$-continuous linear taper:\n   $$ f_c^{(0)}(r) = \\begin{cases} 1 - \\dfrac{r}{r_c}, & 0 \\le r < r_c, \\\\ 0, & r \\ge r_c. \\end{cases} $$\n   This function is continuous with $f_c^{(0)}(r_c)=0$, but its first derivative is discontinuous at $r_c$.\n\n2. $C^1$-continuous cosine taper:\n   $$ f_c^{(1)}(r) = \\begin{cases} \\dfrac{1}{2}\\left[1 + \\cos\\!\\left(\\dfrac{\\pi\\,r}{r_c}\\right)\\right], & 0 \\le r \\le r_c, \\\\ 0, & r \\ge r_c. \\end{cases} $$\n   This function and its first derivative are continuous at $r_c$, with $f_c^{(1)}(r_c)=0$ and $\\dfrac{d}{dr}f_c^{(1)}(r_c)=0$.\n\n3. $C^\\infty$-smooth compactly supported bump:\n   $$ f_c^{(\\infty)}(r) = \\begin{cases} \\exp\\!\\left(-\\dfrac{r^2}{r_c^2 - r^2}\\right), & 0 \\le r < r_c, \\\\ 0, & r \\ge r_c. \\end{cases} $$\n   This function is infinitely differentiable, with $f_c^{(\\infty)}(r_c)=0$ and all derivatives at the cutoff equal to zero from the left; from the right it is identically zero.\n\nStarting from the basic rules of single-variable calculus (including the product rule and chain rule), derive analytic expressions for the left and right limits of the radial derivative $\\dfrac{\\partial G}{\\partial r}$ at $r=r_c$ for each choice of $f_c(r) \\in \\{f_c^{(0)}, f_c^{(1)}, f_c^{(\\infty)}\\}$. Explicitly quantify the discontinuity in the derivative by the jump magnitude\n$$ \\Delta\\left(\\dfrac{\\partial G}{\\partial r}\\right)\\Big|_{r_c} \\equiv \\left|\\lim_{r \\to r_c^-} \\dfrac{\\partial G}{\\partial r} - \\lim_{r \\to r_c^+} \\dfrac{\\partial G}{\\partial r}\\right|. $$\n\nTo connect the derivative discontinuity to Molecular Dynamics (MD) stability, consider a simple energy mapping $E(G) = a\\,G$ with a constant coefficient $a$ (set $a=1$ for normalization). The radial force projection is $F_r = -\\dfrac{\\partial E}{\\partial r} = -\\dfrac{\\partial G}{\\partial r}$. Use the jump magnitude in $\\dfrac{\\partial G}{\\partial r}$ as a force-noise proxy at $r_c$, and define a stability criterion: the MD is deemed stable for a given cutoff choice if $\\Delta\\!\\left(\\dfrac{\\partial G}{\\partial r}\\right)\\big|_{r_c} \\le T$, where $T$ is a prescribed threshold provided per test case.\n\nYour program must implement these derivations and compute, for each provided test case, the jump magnitudes for all three cutoff classes and the corresponding stability booleans under the given threshold. All quantities are dimensionless in this problem.\n\nTest suite parameters are tuples $(\\eta, R_s, r_c, T)$:\n\n- Case 1 (general, nontrivial overlap near cutoff): $(\\eta=2.0, R_s=4.5, r_c=5.0, T=0.05)$.\n- Case 2 (basis center far from cutoff, strong decay): $(\\eta=10.0, R_s=0.0, r_c=5.0, T=10^{-8})$.\n- Case 3 (basis centered at cutoff, small $r_c$): $(\\eta=0.5, R_s=1.0, r_c=1.0, T=0.5)$.\n- Case 4 (basis centered at cutoff, larger $r_c$): $(\\eta=1.0, R_s=8.0, r_c=8.0, T=0.2)$.\n\nFinal output format requirement: Your program should produce a single line of output containing a list of lists, where each inner list corresponds to one test case and is ordered as\n$$[\\Delta_0,\\ \\Delta_1,\\ \\Delta_\\infty,\\ \\text{stable}_0,\\ \\text{stable}_1,\\ \\text{stable}_\\infty],$$\nwith $\\Delta_0$, $\\Delta_1$, $\\Delta_\\infty$ being the jump magnitudes for $f_c^{(0)}$, $f_c^{(1)}$, $f_c^{(\\infty)}$, respectively, and $\\text{stable}_\\ast$ being boolean values satisfying the criterion with the given $T$. The printed single line must have the exact Python list formatting, for example:\n$$[[0.1,0.0,0.0,False,True,True],[\\dots]].$$", "solution": "The problem requires the derivation and calculation of the discontinuity in the first derivative of a radial descriptor function, $G(r)$, at a cutoff radius $r_c$. This discontinuity is used to assess the numerical stability of a corresponding simplified force model in a molecular dynamics simulation.\n\nThe radial descriptor is given by the product $G(r) = \\phi(r) f_c(r)$, where the radial basis is a Gaussian function $\\phi(r) = \\exp(-\\eta(r - R_s)^2)$ and $f_c(r)$ is one of three specified cutoff functions.\n\nFirst, we derive the general expression for the derivative of $G(r)$ with respect to the interatomic distance $r$. Using the product rule for differentiation, we have:\n$$ \\frac{\\partial G}{\\partial r} = \\frac{\\partial}{\\partial r} \\left[ \\phi(r) f_c(r) \\right] = \\frac{\\partial \\phi}{\\partial r} f_c(r) + \\phi(r) \\frac{\\partial f_c}{\\partial r} $$\nThe derivative of the Gaussian basis function $\\phi(r)$ is found using the chain rule:\n$$ \\frac{\\partial \\phi}{\\partial r} = \\frac{d}{dr} \\left( -\\eta(r-R_s)^2 \\right) \\cdot \\exp\\!\\left(-\\eta(r - R_s)^2\\right) = -2\\eta(r-R_s) \\exp\\!\\left(-\\eta(r - R_s)^2\\right) $$\nLet's denote $\\phi'(r) \\equiv \\frac{\\partial \\phi}{\\partial r}$ and $f_c'(r) \\equiv \\frac{\\partial f_c}{\\partial r}$. The derivative of the descriptor is then:\n$$ \\frac{\\partial G}{\\partial r} = \\phi'(r) f_c(r) + \\phi(r) f_c'(r) $$\nThe discontinuity, or jump magnitude, in this derivative at $r=r_c$ is defined as:\n$$ \\Delta\\left(\\dfrac{\\partial G}{\\partial r}\\right)\\Big|_{r_c} = \\left|\\lim_{r \\to r_c^-} \\dfrac{\\partial G}{\\partial r} - \\lim_{r \\to r_c^+} \\dfrac{\\partial G}{\\partial r}\\right| $$\nWe must evaluate the left and right-hand limits for each case.\n\nFor all three cutoff functions, $f_c(r) = 0$ for $r \\ge r_c$. This implies that for $r > r_c$, $f_c(r)$ is a constant function, and its derivative $f_c'(r)$ is also $0$. Consequently, for $r > r_c$, the descriptor $G(r) = \\phi(r) \\cdot 0 = 0$, and its derivative $\\frac{\\partial G}{\\partial r}$ is also $0$. Therefore, the right-hand limit is universally zero:\n$$ \\lim_{r \\to r_c^+} \\dfrac{\\partial G}{\\partial r} = \\lim_{r \\to r_c^+} 0 = 0 $$\nThe jump magnitude simplifies to the absolute value of the left-hand limit:\n$$ \\Delta\\left(\\dfrac{\\partial G}{\\partial r}\\right)\\Big|_{r_c} = \\left|\\lim_{r \\to r_c^-} \\dfrac{\\partial G}{\\partial r}\\right| $$\nWe now proceed to compute this limit for each of the three cutoff functions.\n\n1.  **$C^0$-continuous linear taper, $f_c^{(0)}(r)$**:\n    For $0 \\le r < r_c$, we have $f_c^{(0)}(r) = 1 - \\frac{r}{r_c}$ and its derivative is $f_c^{(0)'}(r) = -\\frac{1}{r_c}$.\n    The derivative of the descriptor for $r < r_c$ is:\n    $$ \\frac{\\partial G^{(0)}}{\\partial r} = \\phi'(r) \\left(1 - \\frac{r}{r_c}\\right) + \\phi(r) \\left(-\\frac{1}{r_c}\\right) $$\n    We take the limit as $r \\to r_c^-$. Since $\\phi(r)$ and $\\phi'(r)$ are continuous functions, we can substitute $r=r_c$:\n    $$ \\lim_{r \\to r_c^-} \\frac{\\partial G^{(0)}}{\\partial r} = \\phi'(r_c) \\left(1 - \\frac{r_c}{r_c}\\right) - \\frac{\\phi(r_c)}{r_c} = \\phi'(r_c) \\cdot 0 - \\frac{\\phi(r_c)}{r_c} = -\\frac{\\phi(r_c)}{r_c} $$\n    The jump magnitude, $\\Delta_0$, is:\n    $$ \\Delta_0 = \\left|-\\frac{\\phi(r_c)}{r_c}\\right| = \\frac{\\phi(r_c)}{r_c} = \\frac{\\exp(-\\eta(r_c-R_s)^2)}{r_c} $$\n    The derivative is discontinuous because although $\\lim_{r \\to r_c^-} f_c^{(0)}(r) = 0$, its derivative $\\lim_{r \\to r_c^-} f_c^{(0)'}(r) = -1/r_c$ is non-zero, creating a discontinuity in the second term of the product rule expansion.\n\n2.  **$C^1$-continuous cosine taper, $f_c^{(1)}(r)$**:\n    For $0 \\le r \\le r_c$, we have $f_c^{(1)}(r) = \\frac{1}{2}\\left[1 + \\cos\\left(\\frac{\\pi r}{r_c}\\right)\\right]$. Its derivative is $f_c^{(1)'}(r) = -\\frac{\\pi}{2r_c}\\sin\\left(\\frac{\\pi r}{r_c}\\right)$.\n    The derivative of the descriptor for $r \\le r_c$ is:\n    $$ \\frac{\\partial G^{(1)}}{\\partial r} = \\phi'(r) \\cdot \\frac{1}{2}\\left[1 + \\cos\\left(\\frac{\\pi r}{r_c}\\right)\\right] - \\phi(r) \\cdot \\frac{\\pi}{2r_c}\\sin\\left(\\frac{\\pi r}{r_c}\\right) $$\n    Taking the limit as $r \\to r_c^-$:\n    $$ \\lim_{r \\to r_c^-} \\frac{\\partial G^{(1)}}{\\partial r} = \\phi'(r_c) \\cdot \\frac{1}{2}\\left[1 + \\cos(\\pi)\\right] - \\phi(r_c) \\cdot \\frac{\\pi}{2r_c}\\sin(\\pi) $$\n    $$ = \\phi'(r_c) \\cdot \\frac{1}{2}\\left[1 - 1\\right] - \\phi(r_c) \\cdot \\frac{\\pi}{2r_c} \\cdot 0 = \\phi'(r_c) \\cdot 0 - \\phi(r_c) \\cdot 0 = 0 $$\n    The jump magnitude, $\\Delta_1$, is:\n    $$ \\Delta_1 = |0 - 0| = 0 $$\n    The derivative is continuous, as expected for a product of a smooth function $\\phi(r)$ and a $C^1$-continuous function $f_c^{(1)}(r)$ where both the function and its first derivative vanish at $r_c$.\n\n3.  **$C^\\infty$-smooth compactly supported bump, $f_c^{(\\infty)}(r)$**:\n    For $0 \\le r < r_c$, $f_c^{(\\infty)}(r) = \\exp\\left(-\\frac{r^2}{r_c^2 - r^2}\\right)$. This function is constructed to be infinitely differentiable on its domain and to have all derivatives equal to zero at $r=r_c$ from the left.\n    Let's confirm this for the first derivative. For $r < r_c$, $f_c^{(\\infty)'}(r) =  f_c^{(\\infty)}(r) \\left( -\\frac{2rr_c^2}{(r_c^2 - r^2)^2} \\right)$.\n    The limit of this expression as $r \\to r_c^-$ is dominated by the exponential term, which goes to zero faster than any polynomial term diverges. Thus, $\\lim_{r \\to r_c^-} f_c^{(\\infty)}(r) = 0$ and $\\lim_{r \\to r_c^-} f_c^{(\\infty)'}(r) = 0$.\n    The derivative of the descriptor for $r < r_c$ is:\n    $$ \\frac{\\partial G^{(\\infty)}}{\\partial r} = \\phi'(r) f_c^{(\\infty)}(r) + \\phi(r) f_c^{(\\infty)'}(r) $$\n    Taking the limit as $r \\to r_c^-$:\n    $$ \\lim_{r \\to r_c^-} \\frac{\\partial G^{(\\infty)}}{\\partial r} = \\phi'(r_c) \\cdot \\lim_{r \\to r_c^-} f_c^{(\\infty)}(r) + \\phi(r_c) \\cdot \\lim_{r \\to r_c^-} f_c^{(\\infty)'}(r) $$\n    $$ = \\phi'(r_c) \\cdot 0 + \\phi(r_c) \\cdot 0 = 0 $$\n    The jump magnitude, $\\Delta_\\infty$, is:\n    $$ \\Delta_\\infty = |0 - 0| = 0 $$\n    The derivative is continuous, as expected for a product involving a $C^\\infty$ function.\n\nIn summary, the formulas for the jump magnitudes are:\n-   $\\Delta_0 = \\frac{1}{r_c} \\exp(-\\eta(r_c-R_s)^2)$\n-   $\\Delta_1 = 0$\n-   $\\Delta_\\infty = 0$\n\nThe stability criterion for each cutoff choice is determined by comparing its jump magnitude to the threshold $T$. The simulation is stable if $\\Delta \\le T$. For the $C^1$ and $C^\\infty$ cutoffs, the jump is always zero, so they will always satisfy the stability criterion for any non-negative threshold $T$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the derivative discontinuity for different cutoff functions\n    and assesses the stability for several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (eta, Rs, rc, T)\n    test_cases = [\n        (2.0, 4.5, 5.0, 0.05),\n        (10.0, 0.0, 5.0, 1e-8),\n        (0.5, 1.0, 1.0, 0.5),\n        (1.0, 8.0, 8.0, 0.2),\n    ]\n\n    results = []\n    for case in test_cases:\n        eta, Rs, rc, T = case\n\n        # --- Calculate jump magnitudes ---\n\n        # Case 0: C^0-continuous linear taper\n        # Formula: Delta_0 = exp(-eta * (rc - Rs)^2) / rc\n        phi_rc = np.exp(-eta * (rc - Rs)**2)\n        delta_0 = phi_rc / rc\n        \n        # Case 1: C^1-continuous cosine taper\n        # Formula: Delta_1 = 0\n        delta_1 = 0.0\n        \n        # Case 2: C^infinity-smooth bump function\n        # Formula: Delta_inf = 0\n        delta_inf = 0.0\n\n        # --- Apply stability criterion ---\n        # Stability is True if Delta <= T\n        stable_0 = delta_0 <= T\n        stable_1 = delta_1 <= T\n        stable_inf = delta_inf <= T\n\n        # Append the list of results for this case\n        case_result = [delta_0, delta_1, delta_inf, stable_0, stable_1, stable_inf]\n        results.append(case_result)\n\n    # --- Format the final output string ---\n    # The output format must exactly match \"[[val,val,...],[val,val,...]]\"\n    # with no spaces after commas. Python's default str() on lists adds spaces,\n    so we manually construct the string to meet the requirement.\n    \n    # Collect string representations of each inner list\n    output_parts = []\n    for res_list in results:\n        # res_list contains: [float, float, float, bool, bool, bool]\n        # Convert each element to its string representation\n        # Note: str(True) is \"True\", str(False) is \"False\"\n        list_items_as_strings = [\n            f\"{res_list[0]}\",\n            f\"{res_list[1]}\",\n            f\"{res_list[2]}\",\n            str(res_list[3]),\n            str(res_list[4]),\n            str(res_list[5]),\n        ]\n        \n        # Join items with comma and wrap in brackets for this case\n        inner_list_str = f\"[{','.join(list_items_as_strings)}]\"\n        output_parts.append(inner_list_str)\n\n    # Join the string representations of all cases with a comma\n    # and wrap in outer brackets to form the final string\n    final_output_string = f\"[{','.join(output_parts)}]\"\n\n    print(final_output_string)\n\nsolve()\n```", "id": "3443993"}]}