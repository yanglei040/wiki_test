{"hands_on_practices": [{"introduction": "The heart of any evolutionary algorithm is the fitness function, which quantifies the quality of a candidate solution and guides the search toward promising regions of the configuration space. While minimizing formation energy $E$ is the primary goal in crystal structure prediction, a purely energy-based fitness landscape can be rugged and difficult to navigate. This practice introduces a powerful technique for sculpting a more effective search landscape by augmenting the fitness function with chemical knowledge, implementing a penalty term based on electronegativity differences to discourage unrealistic atomic arrangements [@problem_id:3450416]. This exercise hones the crucial skill of encoding physical and chemical principles into the objective function to accelerate convergence towards meaningful solutions.", "problem": "You are designing a fitness function for an Evolutionary Algorithm (EA) applied to crystal structure prediction in computational materials science. The foundational principle is that low-energy structures should be favored, and local chemical environments with large electronegativity differences should be penalized to promote physically realistic ordering in alloys. Use the following fundamental base to derive a mathematically consistent penalized fitness energy for a candidate structure and implement it:\n\n- The baseline quantity to be minimized is the formation energy $E$ expressed in electronvolts (eV).\n- Pauling electronegativity $\\chi$ is a well-tested descriptor of atomic tendency to attract electrons.\n- Local mismatch should be additive over unique first-neighbor pairs $\\langle i,j\\rangle$ in the structure.\n- The penalty for a pair should increase with the magnitude of the electronegativity difference and be proportional to a tunable coefficient $\\alpha$ that has energy units, ensuring dimensional consistency.\n- Only unique first-neighbor pairs are to be included; do not double-count or include self-pairs.\n\nFrom these principles, derive an explicit expression for the penalized fitness energy, and implement a program that computes this value for each test case below. Express all final energies in eV, rounded to six decimal places.\n\nAtomic species are labeled by symbols with the following Pauling electronegativities:\n- Species $A$: $\\chi_A = $ $1.60$\n- Species $B$: $\\chi_B = $ $3.00$\n- Species $C$: $\\chi_C = $ $2.50$\n\nEach test case provides:\n- A baseline energy $E$ in eV.\n- A coefficient $\\alpha$ in eV.\n- A list of species assigned to lattice sites, indexed from $0$ upward.\n- An adjacency list of unique undirected first-neighbor pairs $(i,j)$ given by site indices with $i \\neq j$ and each unordered pair appearing exactly once.\n\nTest suite:\n- Case $1$ (happy path, binary ordering on a square motif):\n  - $E = $ $-0.25$\n  - $\\alpha = $ $0.05$\n  - Species at sites $\\{0,1,2,3\\}$: $[A,B,B,A]$\n  - First-neighbor pairs: $\\{(0,1),(0,2),(1,3),(2,3)\\}$\n- Case $2$ (boundary, uniform composition with no mismatch):\n  - $E = $ $-0.10$\n  - $\\alpha = $ $0.20$\n  - Species at sites $\\{0,1,2,3\\}$: $[A,A,A,A]$\n  - First-neighbor pairs: $\\{(0,1),(0,2),(1,3),(2,3)\\}$\n- Case $3$ (boundary, no penalty applied):\n  - $E = $ $-0.25$\n  - $\\alpha = $ $0.00$\n  - Species at sites $\\{0,1,2,3\\}$: $[A,B,B,A]$\n  - First-neighbor pairs: $\\{(0,1),(0,2),(1,3),(2,3)\\}$\n- Case $4$ (ternary chain with varied mismatches):\n  - $E = $ $0.15$\n  - $\\alpha = $ $0.10$\n  - Species at sites $\\{0,1,2,3\\}$: $[A,C,B,A]$\n  - First-neighbor pairs: $\\{(0,1),(1,2),(2,3)\\}$\n- Case $5$ (edge case, empty neighbor list):\n  - $E = $ $-1.00$\n  - $\\alpha = $ $0.50$\n  - Species at sites $\\{0,1\\}$: $[B,C]$\n  - First-neighbor pairs: $\\{\\}$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[x_1,x_2,x_3,x_4,x_5]$, where each $x_k$ is the penalized fitness energy for case $k$ in eV, rounded to six decimal places.", "solution": "The user has provided a problem that requires the derivation and implementation of a fitness function for an evolutionary algorithm used in crystal structure prediction. The process begins with a mandatory validation of the problem statement.\n\n### Step 1: Extract Givens\n\nThe problem provides the following definitions, constants, and data:\n\n*   **Objective**: Derive and implement a penalized fitness energy function.\n*   **Baseline Quantity**: Formation energy $E$, expressed in electronvolts (eV).\n*   **Penalty Principle**: Local chemical environments with large electronegativity differences, quantified by Pauling electronegativity $\\chi$, should be penalized.\n*   **Penalty Structure**:\n    *   The penalty is additive over unique first-neighbor pairs $\\langle i,j\\rangle$.\n    *   The penalty for a single pair is proportional to a tunable coefficient $\\alpha$ (in units of eV).\n    *   The penalty for a single pair increases with the magnitude of the electronegativity difference.\n    *   Only unique, undirected first-neighbor pairs $(i,j)$ with $i \\neq j$ are considered.\n*   **Pauling Electronegativities ($\\chi$)**:\n    *   Species $A$: $\\chi_A = 1.60$\n    *   Species $B$: $\\chi_B = 3.00$\n    *   Species $C$: $\\chi_C = 2.50$\n*   **Test Cases**:\n    *   **Case 1**: $E = -0.25$ eV, $\\alpha = 0.05$ eV, Species = $[A,B,B,A]$ at sites $\\{0,1,2,3\\}$, Neighbors = $\\{(0,1),(0,2),(1,3),(2,3)\\}$.\n    *   **Case 2**: $E = -0.10$ eV, $\\alpha = 0.20$ eV, Species = $[A,A,A,A]$ at sites $\\{0,1,2,3\\}$, Neighbors = $\\{(0,1),(0,2),(1,3),(2,3)\\}$.\n    *   **Case 3**: $E = -0.25$ eV, $\\alpha = 0.00$ eV, Species = $[A,B,B,A]$ at sites $\\{0,1,2,3\\}$, Neighbors = $\\{(0,1),(0,2),(1,3),(2,3)\\}$.\n    *   **Case 4**: $E = 0.15$ eV, $\\alpha = 0.10$ eV, Species = $[A,C,B,A]$ at sites $\\{0,1,2,3\\}$, Neighbors = $\\{(0,1),(1,2),(2,3)\\}$.\n    *   **Case 5**: $E = -1.00$ eV, $\\alpha = 0.50$ eV, Species = $[B,C]$ at sites $\\{0,1\\}$, Neighbors = $\\{\\}$.\n*   **Output Format**: A single-line list of comma-separated values, `[x_1,x_2,x_3,x_4,x_5]`, with each result rounded to six decimal places.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem is evaluated against the specified validation criteria.\n\n*   **Scientifically Grounded**: The problem is well-grounded in computational materials science. Minimizing formation energy is the primary goal of crystal structure prediction. The use of electronegativity to penalize unfavorable local bonding environments is a standard and physically meaningful heuristic in alloy theory and materials modeling.\n*   **Well-Posed**: The problem is well-posed. The principles provided are sufficient to derive a unique mathematical expression for the fitness function. The term \"increases with\" in the context of a physical model and in the absence of other specifications implies the simplest linear relationship, which is direct proportionality. This interpretation leads to a single, unambiguous formula. All necessary data are provided for each test case.\n*   **Objective**: The language is precise, quantitative, and free of subjective or ambiguous terminology.\n*   **Completeness and Consistency**: The problem is self-contained and internally consistent. No essential information is missing, and no constraints are contradictory.\n*   **Realism and Feasibility**: The provided numerical values for energies and electronegativities are realistic. The structural motifs are simple but valid representations of local atomic arrangements.\n\n**Verdict**: The problem is **valid**. It is scientifically sound, well-posed, objective, and complete.\n\n### Step 3: Derivation and Solution\n\nBased on the provided principles, a mathematical expression for the penalized fitness energy, $E_{penalized}$, is derived.\n\nThe total fitness energy is the sum of the baseline formation energy, $E$, and a total penalty term, $P_{total}$.\n$$ E_{penalized} = E + P_{total} $$\n\nThe total penalty is an additive sum of penalties for each unique first-neighbor pair $\\langle i,j \\rangle$ in the set of neighbors, $\\mathcal{N}$.\n$$ P_{total} = \\sum_{\\langle i,j \\rangle \\in \\mathcal{N}} P_{ij} $$\n\nThe penalty for a single pair, $P_{ij}$, is proportional to both the coefficient $\\alpha$ and the magnitude of the electronegativity difference between the species $S_i$ and $S_j$ at sites $i$ and $j$. The most direct mathematical representation of this is:\n$$ P_{ij} = \\alpha \\cdot |\\chi(S_i) - \\chi(S_j)| $$\nwhere $\\chi(S_k)$ is the electronegativity of the species at site $k$.\n\nCombining these components yields the final expression for the penalized fitness energy:\n$$ E_{penalized} = E + \\alpha \\sum_{\\langle i,j \\rangle \\in \\mathcal{N}} |\\chi(S_i) - \\chi(S_j)| $$\n\nThis formula is now applied to each test case. The electronegativity values are $\\chi_A = 1.60$, $\\chi_B = 3.00$, and $\\chi_C = 2.50$.\n\n**Case 1**:\n$E = -0.25$, $\\alpha = 0.05$, Species = $[A,B,B,A]$, Neighbors = $\\{(0,1),(0,2),(1,3),(2,3)\\}$.\nThe pairs are $(A,B)$, $(A,B)$, $(B,A)$, $(B,A)$.\nThe electronegativity difference for an $A-B$ pair is $|\\chi_A - \\chi_B| = |1.60 - 3.00| = 1.40$.\nThe sum of differences is $\\sum |\\Delta\\chi| = 1.40 + 1.40 + 1.40 + 1.40 = 4 \\times 1.40 = 5.60$.\n$E_{penalized} = -0.25 + 0.05 \\times 5.60 = -0.25 + 0.28 = 0.03$.\n\n**Case 2**:\n$E = -0.10$, $\\alpha = 0.20$, Species = $[A,A,A,A]$, Neighbors = $\\{(0,1),(0,2),(1,3),(2,3)\\}$.\nAll pairs are $(A,A)$. The electronegativity difference is $|\\chi_A - \\chi_A| = |1.60 - 1.60| = 0.00$.\nThe sum of differences is $\\sum |\\Delta\\chi| = 0$.\n$E_{penalized} = -0.10 + 0.20 \\times 0.00 = -0.10 + 0.00 = -0.10$.\n\n**Case 3**:\n$E = -0.25$, $\\alpha = 0.00$, Species = $[A,B,B,A]$, Neighbors = $\\{(0,1),(0,2),(1,3),(2,3)\\}$.\nThe species and neighbors are identical to Case 1, so $\\sum |\\Delta\\chi| = 5.60$.\nThe penalty coefficient is $\\alpha = 0.00$.\n$E_{penalized} = -0.25 + 0.00 \\times 5.60 = -0.25 + 0.00 = -0.25$.\n\n**Case 4**:\n$E = 0.15$, $\\alpha = 0.10$, Species = $[A,C,B,A]$, Neighbors = $\\{(0,1),(1,2),(2,3)\\}$.\nThe pairs are $(A,C)$, $(C,B)$, $(B,A)$.\n- Pair $(A,C)$: $|\\chi_A - \\chi_C| = |1.60 - 2.50| = 0.90$.\n- Pair $(C,B)$: $|\\chi_C - \\chi_B| = |2.50 - 3.00| = 0.50$.\n- Pair $(B,A)$: $|\\chi_B - \\chi_A| = |3.00 - 1.60| = 1.40$.\nThe sum of differences is $\\sum |\\Delta\\chi| = 0.90 + 0.50 + 1.40 = 2.80$.\n$E_{penalized} = 0.15 + 0.10 \\times 2.80 = 0.15 + 0.28 = 0.43$.\n\n**Case 5**:\n$E = -1.00$, $\\alpha = 0.50$, Species = $[B,C]$, Neighbors = $\\{\\}$.\nThe set of neighbors $\\mathcal{N}$ is empty. The sum over an empty set is $0$.\n$\\sum |\\Delta\\chi| = 0$.\n$E_{penalized} = -1.00 + 0.50 \\times 0.00 = -1.00 + 0.00 = -1.00$.\n\nThe final results, rounded to six decimal places, are:\n$0.030000$, $-0.100000$, $-0.250000$, $0.430000$, $-1.000000$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and computes a penalized fitness energy for crystal structures\n    based on formation energy and electronegativity mismatch of nearest neighbors.\n    \"\"\"\n\n    # Define the Pauling electronegativity values for each atomic species.\n    # These are dimensionless quantities.\n    CHI_VALS = {\n        'A': 1.60,\n        'B': 3.00,\n        'C': 2.50\n    }\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (E, alpha, species_list, neighbor_list)\n    # E: baseline formation energy in eV\n    # alpha: tunable penalty coefficient in eV\n    # species_list: list of species symbols at indexed lattice sites\n    # neighbor_list: list of unique, undirected first-neighbor pairs (i, j)\n    test_cases = [\n        # Case 1: happy path, binary ordering on a square motif\n        (-0.25, 0.05, ['A', 'B', 'B', 'A'], [(0, 1), (0, 2), (1, 3), (2, 3)]),\n        # Case 2: boundary, uniform composition with no mismatch\n        (-0.10, 0.20, ['A', 'A', 'A', 'A'], [(0, 1), (0, 2), (1, 3), (2, 3)]),\n        # Case 3: boundary, no penalty applied (alpha = 0)\n        (-0.25, 0.00, ['A', 'B', 'B', 'A'], [(0, 1), (0, 2), (1, 3), (2, 3)]),\n        # Case 4: ternary chain with varied mismatches\n        (0.15, 0.10, ['A', 'C', 'B', 'A'], [(0, 1), (1, 2), (2, 3)]),\n        # Case 5: edge case, empty neighbor list\n        (-1.00, 0.50, ['B', 'C'], [])\n    ]\n\n    results = []\n    for E, alpha, species, neighbors in test_cases:\n        # The penalty term is the sum of electronegativity differences\n        # over all first-neighbor pairs.\n        delta_chi_sum = 0.0\n        for i, j in neighbors:\n            # Retrieve the species at each site of the pair.\n            species_i = species[i]\n            species_j = species[j]\n\n            # Retrieve the corresponding electronegativity values.\n            chi_i = CHI_VALS[species_i]\n            chi_j = CHI_VALS[species_j]\n\n            # The penalty increases with the magnitude of the difference.\n            delta_chi_sum += abs(chi_i - chi_j)\n\n        # The total penalty is the sum of differences scaled by the coefficient alpha.\n        # This ensures dimensional consistency as alpha is in eV.\n        total_penalty = alpha * delta_chi_sum\n\n        # The final penalized energy is the baseline energy plus the total penalty.\n        penalized_energy = E + total_penalty\n\n        # Format the result to six decimal places as required.\n        results.append(f\"{penalized_energy:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3450416"}, {"introduction": "An efficient evolutionary search relies on maintaining a diverse population of candidate structures, preventing the algorithm from wasting resources by repeatedly evaluating the same solutions. In crystal structure prediction, this challenge is compounded by symmetry, as a single physical structure can be represented in countless ways that are equivalent under translation, rotation, and atom permutation. This practice addresses the critical task of duplicate detection by first establishing why these symmetry-equivalent structures are guaranteed to have degenerate fitness values, $F(E, V)$. You will then implement a robust method using a symmetry-invariant structural fingerprint to identify and eliminate these redundancies, thereby preserving population diversity and maximizing the efficiency of the search [@problem_id:3450460].", "problem": "Consider a population-based Evolutionary Algorithm (EA) for crystal structure prediction in computational materials science. Each candidate structure is specified by a Bravais cell with lattice vectors and a set of atomic positions within that cell under periodic boundary conditions. Assume the following two facts as the fundamental base: (i) a structure's energy $E(\\{\\mathbf{r}_i\\}, \\{\\mathrm{s}_i\\})$ for fixed composition depends only on the set of interatomic separations and chemical identities, and is invariant under rigid translations, lattice point-group symmetries, and permutations of indistinguishable atoms; (ii) the fitness $F$ used by the EA depends only on $E$ and the cell volume $V$. From these bases, derive why any two symmetry-equivalent structures must have degenerate fitness values in the sense that identical symmetries preserve all pairwise distances, leaving $E$ and $V$ invariant and therefore $F$ invariant. Then, to avoid redundant duplicates in the evolving population, propose a principled strategy based on symmetry-invariant fingerprints and tolerances that collapses structures with indistinguishable geometry (up to symmetry and numerical noise) into a single representative.\n\nTo make this derivation computationally testable, implement the following in a complete program:\n\n1) Use a toy but well-defined energy functional to instantiate $E$ while respecting the fundamental base that $E$ is a function only of interatomic separations and chemical identities. Let the energy be\n$$\nE(\\{\\mathbf{r}_i\\}, \\{\\mathrm{s}_i\\}) \\;=\\; \\sum_{1 \\le i  j \\le N} \\varepsilon_{\\mathrm{s}_i,\\mathrm{s}_j} \\, \\exp\\!\\big(-\\alpha\\, d_{ij}\\big),\n$$\nwhere $d_{ij}$ is the minimum-image distance between atoms $i$ and $j$ in a periodic orthorhombic cell, $\\alpha$ is a positive constant, and $\\varepsilon_{\\mathrm{s}_i,\\mathrm{s}_j}$ are species-pair interaction coefficients with $\\varepsilon_{\\mathrm{s}_i,\\mathrm{s}_j} = \\varepsilon_{\\mathrm{s}_j,\\mathrm{s}_i}$. The fitness is defined by\n$$\nF \\;=\\; E \\;+\\; \\lambda\\, V,\n$$\nwhere $V$ is the cell volume. Use the parameter values $\\alpha = 1.0$ (in $\\mathrm{\\AA^{-1}}$), $\\lambda = 0.01$ (in units consistent with $E$ and $V$), and the interaction coefficients\n$\\varepsilon_{\\mathrm{A},\\mathrm{A}} = -1.0$, $\\varepsilon_{\\mathrm{B},\\mathrm{B}} = -1.0$, $\\varepsilon_{\\mathrm{A},\\mathrm{B}} = -1.5$ (and by symmetry $\\varepsilon_{\\mathrm{B},\\mathrm{A}} = \\varepsilon_{\\mathrm{A},\\mathrm{B}}$). For a single-species system $\\mathrm{X}$, use $\\varepsilon_{\\mathrm{X},\\mathrm{X}} = -1.0$. Distances $d_{ij}$ must be computed using the minimum-image convention in an orthorhombic cell with side lengths $a$, $b$, $c$ (in $\\mathrm{\\AA}$). The volume is $V = a b c$ (in $\\mathrm{\\AA^3}$).\n\n2) Implement a symmetry-invariant structural fingerprint $g$ that depends only on interatomic geometry and is invariant under rigid translations and permutations of indistinguishable atoms. Define $g$ as the sorted list of all pairwise minimum-image distances $\\{d_{ij}\\}_{ij}$ (in $\\mathrm{\\AA}$). Two structures are considered duplicates if either their fitness values are numerically indistinguishable within a tolerance $\\tau_F$ or their fingerprints are numerically indistinguishable within a tolerance $\\tau_g$ measured by the Euclidean norm of the difference of the sorted distance lists. Use $\\tau_F = 10^{-8}$ (in the units of $F$) and $\\tau_g = 2\\times 10^{-2}$ (in $\\mathrm{\\AA}$).\n\n3) For each test case below, the program must output a boolean indicating whether the pair of structures are duplicates under the proposed strategy in item $2)$ (that is, output $\\mathrm{True}$ if and only if $|F_1 - F_2| \\le \\tau_F$ or $\\| g_1 - g_2\\|_2 \\le \\tau_g$). All coordinates are fractional (unitless) within the cell. All cell lengths are in $\\mathrm{\\AA}$. The minimum-image convention should wrap fractional coordinate differences to the interval $[-\\tfrac{1}{2}, \\tfrac{1}{2})$ along each orthorhombic axis before converting to Cartesian distances.\n\nTest suite (four cases):\n\n- Case $1$ (happy path, global translation invariance): Structure $A$: single-species $\\mathrm{X}$, cell with $a=b=c=3.0$, atoms at $(0.0,0.0,0.0)$ and $(0.5,0.5,0.5)$. Structure $B$: translate all atoms of Structure $A$ by $(0.37, 0.41, 0.13)$ and reduce modulo $1$ componentwise. Expected behavior: duplicate.\n\n- Case $2$ (boundary condition, uniform scaling changes volume and distances): Structure $C$: single-species $\\mathrm{X}$, same fractional positions as Structure $A$, but with $a=b=c=6.0$. Compared against Structure $A$. Expected behavior: not duplicate.\n\n- Case $3$ (edge case, small numerical noise): Structure $D$: start from Structure $B$ in Case $1$, then add small fractional perturbations $\\delta\\mathbf{f}_1=(0.001, -0.001, 0.0005)$ to the first atom and $\\delta\\mathbf{f}_2=(-0.001, 0.001, -0.0005)$ to the second atom, then reduce modulo $1$. Compared against Structure $B$. Expected behavior: duplicate by fingerprint within $\\tau_g$ even if $|F_1 - F_2| > \\tau_F$.\n\n- Case $4$ (multi-species, permutation and translation): Structure $E$: species $\\{\\mathrm{A}, \\mathrm{A}, \\mathrm{B}, \\mathrm{B}\\}$ in a cubic cell with $a=b=c=5.0$, fractional positions $(0.0,0.0,0.0)$, $(0.0,0.5,0.5)$, $(0.5,0.0,0.5)$, $(0.5,0.5,0.0)$. Structure $F$: translate all atoms of $E$ by $(0.25, 0.25, 0.25)$ modulo $1$, and reorder atoms arbitrarily. Expected behavior: duplicate.\n\nYour program must implement the definitions above, evaluate the four test cases, and produce a single line of output containing the results as a comma-separated list of booleans enclosed in square brackets, with the order corresponding to Cases $1$ through $4$ (for example, [True,False,True,True]). No user input is required, and no external files may be read. All computations must be self-contained. No units need to be printed in the output since the outputs are booleans.", "solution": "The problem requires a two-part response: first, a theoretical derivation of fitness degeneracy for symmetry-equivalent crystal structures, and second, the implementation of a computational strategy to identify such duplicate structures.\n\n### Theoretical Derivation: Fitness Degeneracy of Symmetry-Equivalent Structures\n\nThe analysis begins from the two fundamental bases provided:\n(i) The energy of a structure, $E(\\{\\mathbf{r}_i\\}, \\{\\mathrm{s}_i\\})$, for a fixed composition, is a function solely of the set of all interatomic separations $\\{d_{ij}\\}$ and the chemical identities of the atom pairs $\\{(\\mathrm{s}_i, \\mathrm{s}_j)\\}$.\n(ii) The fitness $F$ is a function only of the energy $E$ and the cell volume $V$, denoted $F(E, V)$.\n\nA symmetry operation on a crystal is defined as an affine transformation $(\\mathbf{W}, \\mathbf{w})$ that maps the crystal lattice onto itself and preserves the identities of the atomic species at each site. This transformation acts on an atomic position vector $\\mathbf{r}_i$ to produce a new position $\\mathbf{r}'_k = \\mathbf{W}\\mathbf{r}_i + \\mathbf{w}$. The matrix $\\mathbf{W}$ is a member of the lattice's point group, and $\\mathbf{w}$ is a translation vector. Such transformations are, by definition, isometries, meaning they preserve distances.\n\nLet us consider two structures, Structure $1$ and Structure $2$, where Structure $2$ is obtained by applying a symmetry operation to Structure $1$.\n\n1.  **Invariance of Interatomic Distances**: An isometry preserves all dot products and thus all Euclidean distances. When applied to a crystal structure under periodic boundary conditions, a symmetry operation maps the set of all atomic positions $\\{\\mathbf{r}_i\\}$ to a new set $\\{\\mathbf{r}'_k\\}$. The crucial consequence is that the set of all minimum-image pairwise distances $\\{d_{ij}\\}$ in Structure $1$ is identical to the set of pairwise distances $\\{d'_{kl}\\}$ in Structure $2$. The set of distances, as a whole, is an invariant of the transformation.\n\n2.  **Invariance of Species Pairings**: A symmetry operation of a decorated lattice (a lattice with atoms) also requires that an atom of species $\\mathrm{s}_i$ is mapped to a position that was previously occupied by an atom of the same species. Consequently, the set of species pairings $\\{(\\mathrm{s}_i, \\mathrm{s}_j)\\}$ associated with each distance $d_{ij}$ is also preserved under the symmetry operation. Permutations of indistinguishable atoms are a specific case of this principle.\n\n3.  **Invariance of Energy ($E$)**: Based on premise (i), the energy $E$ is a function exclusively of the sets $\\{d_{ij}\\}$ and $\\{(\\mathrm{s}_i, \\mathrm{s}_j)\\}$. Since both of these sets are invariant under a symmetry operation, the energy of the system must also be invariant. If $E_1$ and $E_2$ are the energies of Structure $1$ and Structure $2$, respectively, then $E_1 = E_2$. The specific energy functional provided, $E = \\sum_{ij} \\varepsilon_{\\mathrm{s}_i,\\mathrm{s}_j} \\exp(-\\alpha d_{ij})$, respects this principle, as it is constructed directly from these invariants.\n\n4.  **Invariance of Volume ($V$)**: A symmetry operation of the lattice maps the lattice onto itself. This means the unit cell defined by the lattice vectors is transformed into another valid unit cell of the same lattice, preserving the cell volume $V$. Thus, $V_1 = V_2$.\n\n5.  **Invariance of Fitness ($F$)**: From premise (ii), fitness $F$ depends only on $E$ and $V$. Since a symmetry operation leaves both $E$ and $V$ unchanged ($E_1 = E_2$ and $V_1 = V_2$), it directly follows that the fitness must also be invariant: $F(E_1, V_1) = F(E_2, V_2)$. This proves that any two symmetry-equivalent structures must have degenerate fitness values.\n\n### Principled Strategy for Duplicate Detection\n\nThe degeneracy of symmetry-equivalent structures necessitates a strategy to prevent an evolutionary algorithm from redundantly exploring them. A robust method must identify structures that are identical up to symmetry operations and minor numerical noise.\n\nThe proposed strategy employs a two-pronged test based on fitness and a geometric fingerprint. The fingerprint, $g$, is defined as the sorted list of all pairwise minimum-image distances $\\{d_{ij}\\}_{ij}$.\n\n*   **Invariance of the Fingerprint ($g$)**: The fingerprint $g$ is invariant under the same symmetries as the energy $E$.\n    *   **Translation/Point-Group Symmetries**: These are isometries, which preserve the set of distances $\\{d_{ij}\\}$. Sorting this set into a list makes the fingerprint $g$ a canonical representation of the geometry.\n    *   **Permutation of Indistinguishable Atoms**: Swapping identical atoms merely permutes the indices of the distances in the set $\\{d_{ij}\\}$, but the set of distance values itself remains unchanged. Sorting ensures the fingerprint $g$ is invariant to this permutation.\n\n*   **The Combined Criterion**: Two structures, $1$ and $2$, are considered duplicates if they satisfy the condition:\n    $$\n    |F_1 - F_2| \\le \\tau_F \\quad \\lor \\quad \\| g_1 - g_2\\|_2 \\le \\tau_g\n    $$\n    where $\\tau_F=10^{-8}$ and $\\tau_g=2\\times 10^{-2}$ are numerical tolerances.\n\n*   **Justification**:\n    *   The fitness comparison, $|\\Delta F| \\le \\tau_F$, correctly identifies structures that are computationally exact or near-exact symmetry equivalents, where $\\tau_F$ accounts for floating-point imprecision.\n    *   The fingerprint comparison, $\\|\\Delta g\\|_2 \\le \\tau_g$, provides a crucial fallback. It robustly identifies structures that are geometrically almost identical but may exhibit a fitness difference slightly exceeding $\\tau_F$ due to small, physically insignificant perturbations (e.g., numerical noise or the initial stages of a structural relaxation). As demonstrated in Case $3$, a small atomic displacement can produce $|\\Delta F| > \\tau_F$, but the change in the overall geometry, as measured by the norm of the fingerprint difference, remains small and within $\\tau_g$. The `OR` condition correctly classifies such a pair as duplicates, preventing the algorithm from treating a trivially perturbed structure as a novel individual. This combined approach is therefore superior to relying on either fitness or fingerprints alone.\n\nThe implementation will construct functions to calculate the minimum-image distance, the energy and fitness, and the structural fingerprint. These will then be integrated into a single function that evaluates the duplication criterion for each test case.", "answer": "```python\nimport numpy as np\n\n# A class to represent a crystal structure, simplifying data management.\nclass Structure:\n    \"\"\"Encapsulates the properties of a crystal structure.\"\"\"\n    def __init__(self, cell_dims, frac_coords, species):\n        # Cell dimensions [a, b, c] in Angstroms.\n        self.cell_dims = np.array(cell_dims, dtype=float)\n        # Fractional coordinates of atoms, shape (N, 3).\n        self.frac_coords = np.array(frac_coords, dtype=float)\n        # List of atomic species symbols (e.g., 'A', 'X').\n        self.species = species\n        # Number of atoms in the cell.\n        self.natoms = len(species)\n        # Volume of the orthorhombic cell.\n        self.volume = np.prod(self.cell_dims)\n\ndef min_image_dist(p1_frac, p2_frac, cell_dims):\n    \"\"\"\n    Calculates the minimum image distance between two atoms in a periodic\n    orthorhombic cell.\n    \"\"\"\n    # Calculate the difference in fractional coordinates.\n    delta_frac = p1_frac - p2_frac\n    # Apply the minimum image convention by wrapping the difference vector\n    # to the interval [-0.5, 0.5).\n    # The expression (x + 0.5) % 1.0 - 0.5 correctly maps to this interval.\n    delta_frac = (delta_frac + 0.5) % 1.0 - 0.5\n    # Convert the fractional difference vector to a Cartesian vector.\n    delta_cart = delta_frac * cell_dims\n    # Calculate and return the Euclidean norm (length) of the Cartesian vector.\n    return np.linalg.norm(delta_cart)\n\ndef calculate_fingerprint(structure):\n    \"\"\"\n    Calculates the symmetry-invariant structural fingerprint, defined as the\n    sorted list of all unique pairwise interatomic distances.\n    \"\"\"\n    distances = []\n    # Iterate over all unique pairs of atoms (i  j).\n    for i in range(structure.natoms):\n        for j in range(i + 1, structure.natoms):\n            d = min_image_dist(structure.frac_coords[i],\n                               structure.frac_coords[j],\n                               structure.cell_dims)\n            distances.append(d)\n    # Sort the distances to ensure invariance under atom permutation.\n    return np.array(sorted(distances))\n\ndef calculate_fitness(structure, alpha, lambda_val, eps_map):\n    \"\"\"\n    Calculates the fitness of a structure based on its energy and volume.\n    Energy is a sum of pairwise exponential potentials.\n    \"\"\"\n    energy = 0.0\n    # Iterate over all unique pairs of atoms to calculate total potential energy.\n    for i in range(structure.natoms):\n        for j in range(i + 1, structure.natoms):\n            d = min_image_dist(structure.frac_coords[i],\n                               structure.frac_coords[j],\n                               structure.cell_dims)\n            # Create a canonical key for the species pair (e.g., ('A', 'B')).\n            # This handles both ('A', 'B') and ('B', 'A') with one map entry.\n            s_pair = tuple(sorted((structure.species[i], structure.species[j])))\n            eps = eps_map[s_pair]\n            energy += eps * np.exp(-alpha * d)\n    \n    # Fitness is defined as the total energy plus a volume-dependent term.\n    fitness = energy + lambda_val * structure.volume\n    return fitness\n\ndef get_species_map():\n    \"\"\"Returns the dictionary of species-pair interaction coefficients.\"\"\"\n    return {\n        ('X', 'X'): -1.0,\n        ('A', 'A'): -1.0,\n        ('B', 'B'): -1.0,\n        ('A', 'B'): -1.5,\n    }\n\ndef are_duplicates(struct1, struct2, alpha, lambda_val, eps_map, tau_F, tau_g):\n    \"\"\"\n    Determines if two structures are duplicates based on fitness and fingerprint\n    comparison with given tolerances.\n    \"\"\"\n    # Calculate fitness for both structures.\n    f1 = calculate_fitness(struct1, alpha, lambda_val, eps_map)\n    f2 = calculate_fitness(struct2, alpha, lambda_val, eps_map)\n\n    # Calculate fingerprints for both structures.\n    g1 = calculate_fingerprint(struct1)\n    g2 = calculate_fingerprint(struct2)\n    \n    # Check the fitness condition.\n    fitness_match = abs(f1 - f2) = tau_F\n    \n    # Check the fingerprint condition. Fingerprints must have the same length.\n    if g1.shape != g2.shape:\n        geom_match = False\n    else:\n        # The norm of an empty vector difference is 0. Handle this edge case\n        # for single-atom systems, though not present in test cases.\n        if g1.size == 0:\n            geom_match = True\n        else:\n            geom_match = np.linalg.norm(g1 - g2) = tau_g\n\n    return fitness_match or geom_match\n\ndef solve():\n    \"\"\"Main function to define, run, and report test cases.\"\"\"\n    # Define constants from the problem statement\n    ALPHA = 1.0\n    LAMBDA = 0.01\n    TAU_F = 1e-8\n    TAU_G = 2e-2\n    EPS_MAP = get_species_map()\n\n    # --- Test Case 1: Translation invariance ---\n    cell_A = [3.0, 3.0, 3.0]\n    pos_A = [[0.0, 0.0, 0.0], [0.5, 0.5, 0.5]]\n    species_A = ['X', 'X']\n    struct_A = Structure(cell_A, pos_A, species_A)\n\n    translation = np.array([0.37, 0.41, 0.13])\n    pos_B = (np.array(pos_A) + translation) % 1.0\n    struct_B = Structure(cell_A, pos_B.tolist(), species_A)\n    \n    case1_result = are_duplicates(struct_A, struct_B, ALPHA, LAMBDA, EPS_MAP, TAU_F, TAU_G)\n\n    # --- Test Case 2: Scaling ---\n    cell_C = [6.0, 6.0, 6.0]\n    struct_C = Structure(cell_C, pos_A, species_A)\n    \n    case2_result = are_duplicates(struct_A, struct_C, ALPHA, LAMBDA, EPS_MAP, TAU_F, TAU_G)\n\n    # --- Test Case 3: Small numerical noise ---\n    perturb_1 = np.array([0.001, -0.001, 0.0005])\n    perturb_2 = np.array([-0.001, 0.001, -0.0005])\n    pos_D = np.array([pos_B[0] + perturb_1, pos_B[1] + perturb_2]) % 1.0\n    struct_D = Structure(cell_A, pos_D.tolist(), species_A)\n\n    case3_result = are_duplicates(struct_B, struct_D, ALPHA, LAMBDA, EPS_MAP, TAU_F, TAU_G)\n\n    # --- Test Case 4: Multi-species, permutation, and translation ---\n    cell_E = [5.0, 5.0, 5.0]\n    pos_E = [[0.0, 0.0, 0.0], [0.0, 0.5, 0.5], [0.5, 0.0, 0.5], [0.5, 0.5, 0.0]]\n    species_E = ['A', 'A', 'B', 'B']\n    struct_E = Structure(cell_E, pos_E, species_E)\n\n    translation_F = np.array([0.25, 0.25, 0.25])\n    pos_F_translated = (np.array(pos_E) + translation_F) % 1.0\n    # Arbitrarily reorder positions and species\n    permuted_indices = [3, 0, 2, 1] # e.g., B, A, B, A\n    pos_F = [pos_F_translated[i] for i in permuted_indices]\n    species_F = [species_E[i] for i in permuted_indices]\n    struct_F = Structure(cell_E, pos_F, species_F)\n    \n    case4_result = are_duplicates(struct_E, struct_F, ALPHA, LAMBDA, EPS_MAP, TAU_F, TAU_G)\n    \n    # Collect results and format output\n    results = [case1_result, case2_result, case3_result, case4_result]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3450460"}, {"introduction": "Standard evolutionary algorithms excel at global exploration but can become trapped in deep, suboptimal energy funnels, separated from better solutions by high energy barriers. This practice explores an advanced 'memetic' strategy that integrates local refinement techniques into the evolutionary cycle, specifically using the Nudged Elastic Band (NEB) method, to facilitate barrier crossings on the potential energy surface. By implementing a short NEB calculation and performing a quantitative cost-benefit analysis, you will learn how to design and evaluate sophisticated operators that enhance the algorithm's ability to escape local minima and discover globally optimal structures [@problem_id:3450406].", "problem": "You are to design and evaluate a memetic operator for an Evolutionary Algorithm (EA) in crystal structure prediction that uses a short Nudged Elastic Band (NEB) refinement to facilitate crossing nearby energy barriers. The system is simplified to a two-dimensional configuration space, and the objective is to quantify the cost-benefit of this operator in escaping a deep energetic funnel.\n\nFundamental base and model:\n- The crystal candidate is represented by a position vector $\\mathbf{r} = (x,y) \\in \\mathbb{R}^2$.\n- The enthalpy per candidate is modeled by a continuous potential energy function\n$$\nE(x,y) = a\\,(x^2 - b^2)^2 + c\\,y^2 + d\\,x,\n$$\nwith positive parameters $a  0$, $b  0$, $c  0$, and a small tilt $d  0$ such that the left basin near $x \\approx -b$ is the deep funnel, and the right basin near $x \\approx +b$ is a shallower funnel. The barrier between basins is centered near $x \\approx 0$ and has height $a\\,b^4$ in the absence of tilt.\n- The force is defined as the negative gradient, $\\mathbf{F}(\\mathbf{r}) = - \\nabla E(\\mathbf{r})$. You must use this definition to compute both the gradient and the force consistently.\n- Local relaxation (“quench”) is modeled by steepest descent with fixed step size toward decreasing $E$.\n\nMemetic operator design:\n- The memetic operator takes a parent state $\\mathbf{r}_\\text{p}$ and a mutated child $\\mathbf{r}_\\text{c}$ and performs a short NEB before committing to a state for local quench.\n- The NEB is a chain-of-states method that approximates a minimum-energy path between two endpoints using discrete “images” connected by Hookean springs.\n- Starting from first principles and core definitions, derive the NEB update that:\n  1. Uses a chain of $M$ interior images $\\{\\mathbf{R}_i\\}_{i=1}^M$ between fixed endpoints $\\mathbf{R}_0 = \\mathbf{r}_\\text{p}$ and $\\mathbf{R}_{M+1} = \\mathbf{r}_\\text{c}$, initialized by linear interpolation in $\\mathbb{R}^2$.\n  2. Decomposes the physical force $-\\nabla E$ at each image into components parallel and perpendicular to the local path tangent.\n  3. Employs Hooke’s law springs along the tangent direction to maintain an even parameterization of the path.\n  4. Advances each interior image by a small explicit step using the sum of perpendicular physical force and parallel spring force, for a fixed number of iterations $K$.\n- After $K$ NEB iterations, identify the lowest-energy point along the discrete path (including endpoints). From this point, perform a local quench to the nearest local minimum.\n\nBaseline operator:\n- The baseline operator does not use NEB. It directly quenches the mutated child $\\mathbf{r}_\\text{c}$ to a local minimum.\n\nEscape criterion and cost model:\n- Define “deep funnel” as the basin of attraction that contains the local minimum with $x  0$, and “escape” as a trial that ends in a local minimum with $x  0$.\n- Each gradient evaluation $\\nabla E(\\mathbf{r})$ counts as one unit of computational cost. Counting must include all gradient evaluations performed during NEB and during quenching. Energy evaluations that do not compute gradients do not count toward cost.\n- For each trial, record whether the operator escapes and the total gradient-evaluation cost.\n\nExperimental protocol:\n- For each test case, proceed as follows:\n  1. Compute the parent $\\mathbf{r}_\\text{p}$ by quenching from the initial point $\\mathbf{r}_0 = (-b, 0)$.\n  2. For $N$ independent trials with a fixed random seed, draw a mutated child as $\\mathbf{r}_\\text{c} = \\mathbf{r}_\\text{p} + \\sigma\\,\\boldsymbol{\\xi}$, where $\\boldsymbol{\\xi} \\sim \\mathcal{N}(\\mathbf{0}, \\mathbf{I}_2)$.\n  3. Baseline: Quench from $\\mathbf{r}_\\text{c}$, determine escape outcome, and record cost.\n  4. Memetic: Run the short NEB between $\\mathbf{r}_\\text{p}$ and $\\mathbf{r}_\\text{c}$ with the given $M$, $K$, spring constant $k_\\text{s}$, and NEB step size $\\alpha$; then quench from the lowest-energy image, determine escape outcome, and record cost.\n  5. Compute the average escape probability for baseline $P_\\text{B}$ and memetic $P_\\text{M}$ as the fraction of escapes over $N$, and the average gradient-evaluation cost per trial for baseline $C_\\text{B}$ and memetic $C_\\text{M}$.\n  6. Define the benefit metric as\n  $$\n  B = \\frac{P_\\text{M} - P_\\text{B}}{C_\\text{M} - C_\\text{B}},\n  $$\n  interpreted as escape-probability improvement per additional gradient evaluation. If $C_\\text{M} = C_\\text{B}$, define $B = 0$.\n\nImplementation details and constraints:\n- Use the above definitions to derive and implement:\n  - The gradient $\\nabla E(x,y)$.\n  - The steepest-descent quench with step size $\\eta$, stopping when $\\|\\nabla E\\|_2 \\le \\varepsilon$ or after a maximum of $S_\\text{max}$ steps.\n  - The short NEB update that uses a consistent tangent and spring model as required by the principles above, for $K$ iterations and $M$ interior images, with spring constant $k_\\text{s}$ and step size $\\alpha$.\n- Angles are not directly required. No physical units are needed, as this is a dimensionless toy model. All floating-point outputs must be formatted to exactly six decimal places.\n\nTest suite:\n- Use the following parameter sets. Each test case is a tuple $(a,b,c,d,\\sigma,M,K,k_\\text{s},\\alpha,\\eta,\\varepsilon,S_\\text{max},N,\\text{seed})$.\n\n  - Test case $1$ (happy path, low barrier):\n    - $(a,b,c,d) = (0.2, 1.0, 0.5, 0.3)$,\n    - $\\sigma = 0.6$,\n    - $M = 7$, $K = 20$, $k_\\text{s} = 1.0$, $\\alpha = 0.05$,\n    - $\\eta = 0.1$, $\\varepsilon = 10^{-5}$, $S_\\text{max} = 500$,\n    - $N = 200$, $\\text{seed} = 42$.\n\n  - Test case $2$ (moderate barrier):\n    - $(a,b,c,d) = (1.0, 1.0, 0.5, 0.3)$,\n    - $\\sigma = 0.6$,\n    - $M = 7$, $K = 30$, $k_\\text{s} = 1.0$, $\\alpha = 0.05$,\n    - $\\eta = 0.1$, $\\varepsilon = 10^{-5}$, $S_\\text{max} = 500$,\n    - $N = 200$, $\\text{seed} = 7$.\n\n  - Test case $3$ (high barrier):\n    - $(a,b,c,d) = (3.0, 1.0, 0.5, 0.3)$,\n    - $\\sigma = 0.6$,\n    - $M = 7$, $K = 30$, $k_\\text{s} = 1.0$, $\\alpha = 0.05$,\n    - $\\eta = 0.1$, $\\varepsilon = 10^{-5}$, $S_\\text{max} = 500$,\n    - $N = 200$, $\\text{seed} = 123$.\n\n  - Test case $4$ (minimal NEB budget):\n    - $(a,b,c,d) = (1.0, 1.0, 0.5, 0.3)$,\n    - $\\sigma = 0.6$,\n    - $M = 3$, $K = 10$, $k_\\text{s} = 1.0$, $\\alpha = 0.05$,\n    - $\\eta = 0.1$, $\\varepsilon = 10^{-5}$, $S_\\text{max} = 500$,\n    - $N = 200$, $\\text{seed} = 2024$.\n\n  - Test case $5$ (larger mutation scale):\n    - $(a,b,c,d) = (1.0, 1.0, 0.5, 0.3)$,\n    - $\\sigma = 1.2$,\n    - $M = 7$, $K = 20$, $k_\\text{s} = 1.0$, $\\alpha = 0.05$,\n    - $\\eta = 0.1$, $\\varepsilon = 10^{-5}$, $S_\\text{max} = 500$,\n    - $N = 200$, $\\text{seed} = 99$.\n\nRequired program output:\n- Your program must compute the benefit metric $B$ for each of the five test cases in the order listed and produce a single line containing a Python-style list of five floating-point numbers formatted to exactly six decimal places, for example:\n- Output format: $[\\text{B}_1,\\text{B}_2,\\text{B}_3,\\text{B}_4,\\text{B}_5]$ where each $\\text{B}_i$ has six digits after the decimal point and no additional text is printed.", "solution": "The validity of the problem statement has been confirmed. The problem is scientifically grounded in the principles of computational materials science, using a well-defined toy model to investigate the cost-benefit of a memetic operator. The potential energy surface, force definitions, and algorithmic descriptions (steepest descent, Nudged Elastic Band) are standard and well-posed. All parameters are specified, and the evaluation protocol is quantitative and reproducible. No scientific fallacies, contradictions, or critical ambiguities were found.\n\nThe problem requires the design and evaluation of a memetic operator for an evolutionary algorithm. This operator uses a short Nudged Elastic Band (NEB) calculation to refine the transition path between a parent structure and a mutated child structure, aiming to improve the probability of escaping a local energy minimum. The solution involves deriving and implementing the necessary mathematical and algorithmic components from first principles.\n\n**1. Mathematical Model: Potential Energy and Force**\n\nThe system is defined by a two-dimensional potential energy surface (PES), $E(x,y)$, which models the enthalpy of a crystal configuration $\\mathbf{r} = (x,y)$.\n$$\nE(x,y) = a\\,(x^2 - b^2)^2 + c\\,y^2 + d\\,x\n$$\nThe parameters $a, b, c$ are positive, defining a double-well potential along the $x$-axis centered at $x=0$ and a harmonic well along the $y$-axis. The term $d\\,x$ with $d  0$ introduces a small linear tilt, making the well at $x  0$ deeper than the well at $x  0$.\n\nThe force $\\mathbf{F}(\\mathbf{r})$ on the system at position $\\mathbf{r}$ is the negative gradient of the potential energy, $\\mathbf{F}(\\mathbf{r}) = -\\nabla E(\\mathbf{r})$. The gradient $\\nabla E(\\mathbf{r})$ is calculated as:\n$$\n\\nabla E(\\mathbf{r}) = \\begin{pmatrix} \\frac{\\partial E}{\\partial x} \\\\ \\frac{\\partial E}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} 4ax(x^2 - b^2) + d \\\\ 2cy \\end{pmatrix}\n$$\nEach evaluation of this gradient vector counts as one unit of computational cost.\n\n**2. Algorithmic Components**\n\n**Local Relaxation (Quench):**\nLocal energy minimization is performed using a steepest-descent algorithm. Starting from an initial point $\\mathbf{r}_0$, the position is iteratively updated in the direction of the negative gradient (i.e., in the direction of the force) until a convergence criterion is met. The update rule is:\n$$\n\\mathbf{r}_{k+1} = \\mathbf{r}_k - \\eta \\nabla E(\\mathbf{r}_k)\n$$\nwhere $\\eta$ is the fixed step size. The process terminates when the magnitude of the gradient, $\\|\\nabla E(\\mathbf{r}_k)\\|_2$, falls below a threshold $\\varepsilon$ or a maximum number of steps, $S_\\text{max}$, is reached. The cost is the total number of gradient evaluations.\n\n**Memetic Operator (Nudged Elastic Band):**\nThe memetic operator employs a short NEB calculation. NEB is a method to find the minimum energy path (MEP) between two given endpoints, here the parent $\\mathbf{r}_\\text{p}$ and child $\\mathbf{r}_\\text{c}$. The path is discretized into a series of $M+2$ states, or \"images,\" $\\{\\mathbf{R}_i\\}_{i=0}^{M+1}$, where the endpoints $\\mathbf{R}_0 = \\mathbf{r}_\\text{p}$ and $\\mathbf{R}_{M+1} = \\mathbf{r}_\\text{c}$ are fixed. The $M$ interior images, $\\{\\mathbf{R}_i\\}_{i=1}^{M}$, are relaxed.\n\nThe force on each interior image $\\mathbf{R}_i$ is constructed to drive the image towards the MEP while maintaining even spacing along the path. This total NEB force, $\\mathbf{F}_{\\text{NEB}, i}$, is the sum of two components: the perpendicular component of the true physical force and a parallel spring force.\n\n1.  **Tangent Vector:** The local tangent of the path at image $\\mathbf{R}_i$, denoted $\\hat{\\boldsymbol{\\tau}}_i$, is essential. A robust choice, which is implemented here, uses a central difference scheme based on the neighboring images:\n    $$\n    \\hat{\\boldsymbol{\\tau}}_i = \\frac{\\mathbf{R}_{i+1} - \\mathbf{R}_{i-1}}{\\|\\mathbf{R}_{i+1} - \\mathbf{R}_{i-1}\\|}\n    $$\n\n2.  **Force Components:** The true physical force is $\\mathbf{F}_{\\text{phys}, i} = -\\nabla E(\\mathbf{R}_i)$. This force is decomposed into components perpendicular and parallel to the path tangent:\n    $$\n    \\mathbf{F}_{\\perp, i} = \\mathbf{F}_{\\text{phys}, i} - (\\mathbf{F}_{\\text{phys}, i} \\cdot \\hat{\\boldsymbol{\\tau}}_i) \\hat{\\boldsymbol{\\tau}}_i\n    $$\n    The perpendicular component moves the image towards the MEP. A spring force is added along the parallel direction to ensure the images do not slide down the path and bunch up at the minima:\n    $$\n    \\mathbf{F}_{\\parallel, i} = k_\\text{s} (\\|\\mathbf{R}_{i+1} - \\mathbf{R}_i\\| - \\|\\mathbf{R}_i - \\mathbf{R}_{i-1}\\|) \\hat{\\boldsymbol{\\tau}}_i\n    $$\n    Here, $k_s$ is the spring constant. This force component acts to equalize the lengths of the path segments adjacent to image $\\mathbf{R}_i$.\n\n3.  **Image Update:** The total NEB force on image $\\mathbf{R}_i$ is $\\mathbf{F}_{\\text{NEB}, i} = \\mathbf{F}_{\\perp, i} + \\mathbf{F}_{\\parallel, i}$. The positions of the interior images are updated for $K$ steps using an explicit Euler scheme with step size $\\alpha$:\n    $$\n    \\mathbf{R}_i(t+1) = \\mathbf{R}_i(t) + \\alpha \\mathbf{F}_{\\text{NEB}, i}\n    $$\n    The computational cost of the NEB phase is $M \\times K$ gradient evaluations.\n\n**3. Simulation Protocol and Evaluation**\n\nFor each test case, a parent structure $\\mathbf{r}_\\text{p}$ is first found by quenching from $\\mathbf{r}_0=(-b, 0)$, which lies in the deep basin ($x0$). Then, $N$ independent trials are run. In each trial, a mutated child $\\mathbf{r}_\\text{c}$ is generated by adding Gaussian noise to the parent. Two procedures are then compared:\n\n-   **Baseline:** The child structure $\\mathbf{r}_\\text{c}$ is quenched directly to its nearest local minimum. The outcome (escape or not) and the quenching cost are recorded.\n-   **Memetic:** A short NEB calculation is run between $\\mathbf{r}_\\text{p}$ and $\\mathbf{r}_\\text{c}$. The lowest-energy image along the resulting path (including endpoints) is identified. This image, $\\mathbf{r}_\\text{best}$, is then quenched to its local minimum. The total cost is the sum of the NEB cost and the quenching cost.\n\nAn \"escape\" is recorded if the final quenched structure has an $x$-coordinate greater than $0$. After $N$ trials, the average escape probabilities ($P_\\text{B}, P_\\text{M}$) and average costs ($C_\\text{B}, C_\\text{M}$) are calculated. The cost-benefit is quantified by the metric $B$:\n$$\nB = \\frac{P_\\text{M} - P_\\text{B}}{C_\\text{M} - C_\\text{B}}\n$$\nThis measures the improvement in escape probability per unit of additional computational cost. If $C_\\text{M} = C_\\text{B}$, $B$ is defined as $0$. The following implementation computes this metric for the specified test cases.", "answer": "```python\nimport numpy as np\n\n# This global variable tracks gradient evaluation counts for a single run\n# of quench or NEB. It is reset at the start of each such run.\n_gradient_eval_cost = 0\n\ndef potential_e(r: np.ndarray, a: float, b: float, c: float, d: float) - float:\n    \"\"\"Calculates the potential energy E(x, y). Cost is not tracked.\"\"\"\n    x, y = r\n    # E(x,y) = a*(x^2 - b^2)^2 + c*y^2 + d*x\n    return a * (x**2 - b**2)**2 + c * y**2 + d * x\n\ndef gradient_e(r: np.ndarray, a: float, b: float, c: float, d: float) - np.ndarray:\n    \"\"\"Calculates the gradient of the potential energy, dE/dr, and increments cost.\"\"\"\n    global _gradient_eval_cost\n    _gradient_eval_cost += 1\n    x, y = r\n    dx = 4.0 * a * x * (x**2 - b**2) + d\n    dy = 2.0 * c * y\n    return np.array([dx, dy])\n\ndef quench(r_init: np.ndarray, a: float, b: float, c: float, d: float, \n           eta: float, epsilon: float, S_max: int) - tuple[np.ndarray, int]:\n    \"\"\"\n    Performs local relaxation (quench) using steepest descent.\n    Returns the final position and the number of gradient evaluations.\n    \"\"\"\n    global _gradient_eval_cost\n    _gradient_eval_cost = 0\n    \n    r = r_init.copy()\n    for _ in range(S_max):\n        grad = gradient_e(r, a, b, c, d)\n        if np.linalg.norm(grad) = epsilon:\n            break\n        r -= eta * grad\n        \n    return r, _gradient_eval_cost\n\ndef run_neb(r_p: np.ndarray, r_c: np.ndarray, a: float, b: float, c: float, d: float, \n            M: int, K: int, k_s: float, alpha: float) - tuple[np.ndarray, int]:\n    \"\"\"\n    Runs the short Nudged Elastic Band (NEB) refinement.\n    Returns the final path and the number of gradient evaluations.\n    \"\"\"\n    global _gradient_eval_cost\n    _gradient_eval_cost = 0\n\n    path = np.zeros((M + 2, 2))\n    path[0] = r_p\n    path[M + 1] = r_c\n    for i in range(1, M + 1):\n        path[i] = r_p + i / (M + 1.0) * (r_c - r_p)\n\n    for _ in range(K):\n        # Gradients are first calculated for all interior images for this K-step\n        grads = np.array([gradient_e(path[i], a, b, c, d) for i in range(1, M + 1)])\n        \n        forces_neb = np.zeros((M, 2))\n        for i in range(1, M + 1):\n            tangent = path[i + 1] - path[i - 1]\n            norm_tangent = np.linalg.norm(tangent)\n            if norm_tangent  1e-12:\n                tangent = path[i + 1] - path[i]\n                norm_tangent = np.linalg.norm(tangent)\n                if norm_tangent  1e-12:\n                    continue\n            \n            tangent_hat = tangent / norm_tangent\n\n            F_phys = -grads[i - 1]\n            F_perp = F_phys - np.dot(F_phys, tangent_hat) * tangent_hat\n            \n            len1 = np.linalg.norm(path[i] - path[i - 1])\n            len2 = np.linalg.norm(path[i + 1] - path[i])\n            F_para = k_s * (len2 - len1) * tangent_hat\n            \n            forces_neb[i - 1] = F_perp + F_para\n\n        path[1:M + 1] += alpha * forces_neb\n\n    return path, _gradient_eval_cost\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    test_cases = [\n        (0.2, 1.0, 0.5, 0.3, 0.6, 7, 20, 1.0, 0.05, 0.1, 1e-5, 500, 200, 42),\n        (1.0, 1.0, 0.5, 0.3, 0.6, 7, 30, 1.0, 0.05, 0.1, 1e-5, 500, 200, 7),\n        (3.0, 1.0, 0.5, 0.3, 0.6, 7, 30, 1.0, 0.05, 0.1, 1e-5, 500, 200, 123),\n        (1.0, 1.0, 0.5, 0.3, 0.6, 3, 10, 1.0, 0.05, 0.1, 1e-5, 500, 200, 2024),\n        (1.0, 1.0, 0.5, 0.3, 1.2, 7, 20, 1.0, 0.05, 0.1, 1e-5, 500, 200, 99),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        a, b, c, d, sigma, M, K, k_s, alpha, eta, epsilon, S_max, N, seed = case\n        \n        rng = np.random.default_rng(seed)\n        r_0 = np.array([-b, 0.0])\n        r_p, _ = quench(r_0, a, b, c, d, eta, epsilon, S_max)\n\n        escapes_baseline, total_cost_baseline = 0, 0\n        escapes_memetic, total_cost_memetic = 0, 0\n\n        for _ in range(N):\n            xi = rng.normal(size=2)\n            r_c = r_p + sigma * xi\n\n            # Baseline operator\n            r_final_b, cost_b = quench(r_c, a, b, c, d, eta, epsilon, S_max)\n            total_cost_baseline += cost_b\n            if r_final_b[0]  0:\n                escapes_baseline += 1\n\n            # Memetic operator\n            path, cost_neb = run_neb(r_p, r_c, a, b, c, d, M, K, k_s, alpha)\n            \n            energies = [potential_e(r, a, b, c, d) for r in path]\n            r_best = path[np.argmin(energies)]\n            \n            r_final_m, cost_quench_m = quench(r_best, a, b, c, d, eta, epsilon, S_max)\n            total_cost_memetic += cost_neb + cost_quench_m\n            if r_final_m[0]  0:\n                escapes_memetic += 1\n        \n        P_B = escapes_baseline / N\n        P_M = escapes_memetic / N\n        C_B = total_cost_baseline / N\n        C_M = total_cost_memetic / N\n\n        delta_C = C_M - C_B\n        if abs(delta_C)  1e-9: # Handles the C_M = C_B case\n            B = 0.0\n        else:\n            delta_P = P_M - P_B\n            B = delta_P / delta_C\n            \n        results.append(B)\n\n    formatted_results = ','.join([f\"{res:.6f}\" for res in results])\n    print(f\"[{formatted_results}]\")\n\nsolve()\n```", "id": "3450406"}]}