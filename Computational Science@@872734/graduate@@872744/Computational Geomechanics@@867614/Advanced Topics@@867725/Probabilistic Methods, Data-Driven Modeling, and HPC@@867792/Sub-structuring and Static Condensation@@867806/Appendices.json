{"hands_on_practices": [{"introduction": "The power of static condensation often lies not in explicitly forming the global Schur complement matrix, but in applying its action on a vector. This practice is fundamental for using substructuring within iterative solvers, which is crucial for large-scale problems where forming and storing the dense Schur complement is prohibitive. You will implement the essential \"gather-solve-scatter\" algorithm that defines the matrix-free application of the substructure operator. [@problem_id:3565877]", "problem": "You are asked to implement the application of an interface operator arising from sub-structuring and static condensation without explicitly assembling the global Schur complement. The objective is to design data structures and assembly maps that enable the action of the operator on a global interface vector by using only local subdomain solves on interior degrees of freedom (DOFs) and gather-scatter operations on interface vectors.\n\nConsider a set of subdomains indexed by $s$, each with a stiffness matrix block-partitioned into interior and interface DOFs. The fundamental base is that the governing linear system is symmetric positive definite and arises from a well-posed variational formulation, and that performing block Gaussian elimination on interior DOFs yields an operator acting only on interface DOFs. You must not explicitly assemble the global operator; instead, you must implement its action on a given interface vector by doing local linear solves on interior DOFs and summing contributions via an assembly map.\n\nProgram requirements:\n- Design a data structure for each subdomain $s$ storing matrices $K_{ii}^{(s)}$, $K_{ib}^{(s)}$, $K_{bi}^{(s)}$, $K_{bb}^{(s)}$ and a map $\\phi^{(s)}$ taking each local interface DOF index $j$ to a global interface index $\\phi^{(s)}(j)$.\n- Implement a function that, given a global interface vector $x_b \\in \\mathbb{R}^{N_b}$, computes $y_b = S x_b$ without assembling $S$ by:\n  - Gathering the local slice $x_b^{(s)}$ using $\\phi^{(s)}$,\n  - Solving a local interior system per subdomain on its interior DOFs,\n  - Forming the local interface contribution,\n  - Scattering and summing these contributions back to the global interface vector using $\\phi^{(s)}$.\n- Your program must apply this operation for a set of test cases given below and print the resulting vectors.\n\nDefinitions and constraints:\n- All matrices and vectors are real-valued.\n- If a subdomain has zero interior DOFs, treat its interior blocks as empty and skip interior solves; its contribution then depends only on its interface block.\n- All interface maps are many-to-one from local to global indices, and overlapping contributions must be summed.\n- Angles are not involved. No physical units are required.\n\nTest suite:\nProvide results for the following three test cases. For each subdomain $s$, you are given $K_{ii}^{(s)} \\in \\mathbb{R}^{n_i^{(s)} \\times n_i^{(s)}}$, $K_{ib}^{(s)} \\in \\mathbb{R}^{n_i^{(s)} \\times n_b^{(s)}}$, $K_{bi}^{(s)} \\in \\mathbb{R}^{n_b^{(s)} \\times n_i^{(s)}}$, $K_{bb}^{(s)} \\in \\mathbb{R}^{n_b^{(s)} \\times n_b^{(s)}}$, and a local-to-global interface map $\\phi^{(s)}: \\{0,\\ldots,n_b^{(s)}-1\\} \\to \\{0,\\ldots,N_b-1\\}$. The global interface vector $x_b$ has length $N_b$.\n\n- Test Case A:\n  - Global interface size $N_b = 1$.\n  - Subdomains: a single subdomain $s$ with\n    $$\n    K_{ii}^{(s)} =\n    \\begin{bmatrix}\n    4 & 1 \\\\\n    1 & 3\n    \\end{bmatrix},\\quad\n    K_{ib}^{(s)} =\n    \\begin{bmatrix}\n    1 \\\\\n    2\n    \\end{bmatrix},\\quad\n    K_{bi}^{(s)} =\n    \\begin{bmatrix}\n    1 & 2\n    \\end{bmatrix},\\quad\n    K_{bb}^{(s)} =\n    \\begin{bmatrix}\n    5\n    \\end{bmatrix}.\n    $$\n    The local-to-global map is $\\phi^{(s)} = [0]$.\n  - Use $x_b = [1.5]$.\n- Test Case B:\n  - Global interface size $N_b = 3$.\n  - Subdomains: two subdomains $s \\in \\{1,2\\}$ specified as follows.\n    - Subdomain $s=1$:\n      $$\n      K_{ii}^{(1)} =\n      \\begin{bmatrix}\n      3\n      \\end{bmatrix},\\quad\n      K_{ib}^{(1)} =\n      \\begin{bmatrix}\n      1 & -1\n      \\end{bmatrix},\\quad\n      K_{bi}^{(1)} =\n      \\begin{bmatrix}\n      1 \\\\\n      -1\n      \\end{bmatrix},\\quad\n      K_{bb}^{(1)} =\n      \\begin{bmatrix}\n      4 & 0.5 \\\\\n      0.5 & 2\n      \\end{bmatrix}.\n      $$\n      The local-to-global map is $\\phi^{(1)} = [0, 1]$.\n    - Subdomain $s=2$:\n      $$\n      K_{ii}^{(2)} =\n      \\begin{bmatrix}\n      6 & 1 \\\\\n      1 & 4\n      \\end{bmatrix},\\quad\n      K_{ib}^{(2)} =\n      \\begin{bmatrix}\n      2 & 0 \\\\\n      -1 & 3\n      \\end{bmatrix},\\quad\n      K_{bi}^{(2)} =\n      \\begin{bmatrix}\n      2 & -1 \\\\\n      0 & 3\n      \\end{bmatrix},\\quad\n      K_{bb}^{(2)} =\n      \\begin{bmatrix}\n      3 & -0.2 \\\\\n      -0.2 & 5\n      \\end{bmatrix}.\n      $$\n      The local-to-global map is $\\phi^{(2)} = [1, 2]$.\n  - Use $x_b = [1.0,\\,-0.5,\\,2.0]$.\n- Test Case C:\n  - Global interface size $N_b = 3$.\n  - Subdomains: three subdomains $s \\in \\{1,2,3\\}$ specified as follows.\n    - Subdomain $s=1$ (no interior DOFs):\n      $$\n      K_{ii}^{(1)} \\in \\mathbb{R}^{0 \\times 0},\\quad\n      K_{ib}^{(1)} \\in \\mathbb{R}^{0 \\times 2},\\quad\n      K_{bi}^{(1)} \\in \\mathbb{R}^{2 \\times 0},\\quad\n      K_{bb}^{(1)} =\n      \\begin{bmatrix}\n      2 & 0.3 \\\\\n      0.3 & 1.5\n      \\end{bmatrix}.\n      $$\n      The local-to-global map is $\\phi^{(1)} = [0, 1]$.\n    - Subdomain $s=2$:\n      $$\n      K_{ii}^{(2)} =\n      \\begin{bmatrix}\n      2\n      \\end{bmatrix},\\quad\n      K_{ib}^{(2)} =\n      \\begin{bmatrix}\n      -1 & 0.5\n      \\end{bmatrix},\\quad\n      K_{bi}^{(2)} =\n      \\begin{bmatrix}\n      -1 \\\\\n      0.5\n      \\end{bmatrix},\\quad\n      K_{bb}^{(2)} =\n      \\begin{bmatrix}\n      1 & 0.1 \\\\\n      0.1 & 2\n      \\end{bmatrix}.\n      $$\n      The local-to-global map is $\\phi^{(2)} = [1, 2]$.\n    - Subdomain $s=3$:\n      $$\n      K_{ii}^{(3)} =\n      \\begin{bmatrix}\n      7 & 0 \\\\\n      0 & 8\n      \\end{bmatrix},\\quad\n      K_{ib}^{(3)} =\n      \\begin{bmatrix}\n      1 \\\\\n      2\n      \\end{bmatrix},\\quad\n      K_{bi}^{(3)} =\n      \\begin{bmatrix}\n      1 & 2\n      \\end{bmatrix},\\quad\n      K_{bb}^{(3)} =\n      \\begin{bmatrix}\n      4\n      \\end{bmatrix}.\n      $$\n      The local-to-global map is $\\phi^{(3)} = [2]$.\n  - Use $x_b = [0.2,\\,-1.2,\\,0.7]$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element of this list corresponds to one test case and must itself be a list representing the resulting global interface vector $y_b$ for that test case. For example, the printed structure must look like $[\\,[\\cdot,\\cdot],\\,[\\cdot,\\cdot,\\cdot],\\,\\ldots\\,]$.\n- Express all floating-point numbers with $6$ digits after the decimal point using standard rounding.", "solution": "The problem describes a standard numerical procedure in computational mechanics known as static condensation, which is a key component of certain domain decomposition methods like the Finite Element Tearing and Interconnecting (FETI) methods or general substructuring. The problem asks for an implementation of the matrix-vector product with the global Schur complement operator without explicitly forming this operator.\n\nThe governing principle is based on the block partitioning of a global linear system of equations, typically arising from a Finite Element Method (FEM) discretization. For a system partitioned into interior degrees of freedom (DOFs), indexed by $i$, and interface (or boundary) DOFs, indexed by $b$, the linear system for a single subdomain $s$ can be written as:\n$$\n\\begin{bmatrix} K_{ii}^{(s)} & K_{ib}^{(s)} \\\\ K_{bi}^{(s)} & K_{bb}^{(s)} \\end{bmatrix}\n\\begin{bmatrix} x_i^{(s)} \\\\ x_b^{(s)} \\end{bmatrix}\n=\n\\begin{bmatrix} f_i^{(s)} \\\\ f_b^{(s)} \\end{bmatrix}\n$$\nHere, $K^{(s)}$ is the stiffness matrix of subdomain $s$, $x^{(s)}$ is the vector of unknown displacements, and $f^{(s)}$ is the vector of applied nodal forces. The indices $i$ and $b$ refer to local interior and local interface DOFs, respectively.\n\nStatic condensation is the process of eliminating the interior DOFs $x_i^{(s)}$. Assuming no external forces are applied to the interior DOFs (i.e., $f_i^{(s)} = 0$), the first row of the block system gives:\n$$\nK_{ii}^{(s)} x_i^{(s)} + K_{ib}^{(s)} x_b^{(s)} = 0\n$$\nSince the problem states that the system arises from a well-posed formulation, the matrix $K_{ii}^{(s)}$ (the stiffness of the subdomain with its boundary 'clamped') is symmetric positive definite and thus invertible. We can express the interior displacements $x_i^{(s)}$ in terms of the interface displacements $x_b^{(s)}$:\n$$\nx_i^{(s)} = -(K_{ii}^{(s)})^{-1} K_{ib}^{(s)} x_b^{(s)}\n$$\nSubstituting this into the second row of the block system, which describes the forces on the interface DOFs, we get:\n$$\nf_b^{(s)} = K_{bi}^{(s)} x_i^{(s)} + K_{bb}^{(s)} x_b^{(s)} = K_{bi}^{(s)} \\left( -(K_{ii}^{(s)})^{-1} K_{ib}^{(s)} x_b^{(s)} \\right) + K_{bb}^{(s)} x_b^{(s)}\n$$\nThis simplifies to:\n$$\nf_b^{(s)} = \\left( K_{bb}^{(s)} - K_{bi}^{(s)} (K_{ii}^{(s)})^{-1} K_{ib}^{(s)} \\right) x_b^{(s)}\n$$\nThe term in the parentheses is the local Schur complement matrix, $S^{(s)}$:\n$$\nS^{(s)} = K_{bb}^{(s)} - K_{bi}^{(s)} (K_{ii}^{(s)})^{-1} K_{ib}^{(s)}\n$$\n$S^{(s)}$ relates the displacements of the local interface DOFs to the forces on them, after the effect of the interior has been \"condensed out\".\n\nThe global interface system is formed by assembling the contributions from all subdomains. The global Schur complement, $S$, is the sum of the local Schur complements projected onto the global interface DOFs. If $A^{(s)}$ represents the mapping (or gathering) from the global interface vector to the local interface vector for subdomain $s$, then its transpose $A^{(s)T}$ represents the scattering (and summation) from local to global. The global operator is $S = \\sum_s A^{(s)T} S^{(s)} A^{(s)}$.\n\nThe problem requires computing the action of this global operator on a given global interface vector $x_b$, i.e., computing $y_b = S x_b$, without explicitly forming either $S$ or the local $S^{(s)}$ matrices. The computation proceeds as follows:\n$$\ny_b = \\left( \\sum_s A^{(s)T} S^{(s)} A^{(s)} \\right) x_b = \\sum_s A^{(s)T} \\left( S^{(s)} (A^{(s)} x_b) \\right)\n$$\nLet $x_b^{(s)} = A^{(s)} x_b$ be the local vector gathered from $x_b$. The core task is to compute the local product $y_b^{(s)} = S^{(s)} x_b^{(s)}$ for each subdomain and then scatter-add the results: $y_b = \\sum_s A^{(s)T} y_b^{(s)}$.\n\nThe local product $y_b^{(s)} = S^{(s)} x_b^{(s)}$ is evaluated efficiently as:\n$$\ny_b^{(s)} = \\left( K_{bb}^{(s)} - K_{bi}^{(s)} (K_{ii}^{(s)})^{-1} K_{ib}^{(s)} \\right) x_b^{(s)} = K_{bb}^{(s)} x_b^{(s)} - K_{bi}^{(s)} \\left( (K_{ii}^{(s)})^{-1} (K_{ib}^{(s)} x_b^{(s)}) \\right)\n$$\nThis is computed in steps to avoid forming the matrix inverse $(K_{ii}^{(s)})^{-1}$:\n1.  Compute the right-hand side for the interior problem: $v^{(s)} = K_{ib}^{(s)} x_b^{(s)}$.\n2.  Solve the local interior system for an auxiliary vector $u_i^{(s)}$: $K_{ii}^{(s)} u_i^{(s)} = v^{(s)}$. This is the \"local solve on interior DOFs\".\n3.  Compute the final local contribution: $y_b^{(s)} = K_{bb}^{(s)} x_b^{(s)} - K_{bi}^{(s)} u_i^{(s)}$.\n\nIf a subdomain $s$ has no interior DOFs ($n_i^{(s)} = 0$), the matrices $K_{ii}^{(s)}$, $K_{ib}^{(s)}$, and $K_{bi}^{(s)}$ are empty. The Schur complement term involving the inverse vanishes, and the local contribution simplifies to $y_b^{(s)} = K_{bb}^{(s)} x_b^{(s)}$.\n\nThe overall algorithm is as follows:\n1.  Initialize the global result vector $y_b$ to zeros, with length $N_b$.\n2.  For each subdomain $s$:\n    a.  **Gather**: Use the map $\\phi^{(s)}$ to extract the local interface vector $x_b^{(s)}$ from the global vector $x_b$.\n    b.  **Compute Local Contribution**:\n        i. If $n_i^{(s)} > 0$, compute $y_b^{(s)} = K_{bb}^{(s)} x_b^{(s)} - K_{bi}^{(s)} (K_{ii}^{(s)})^{-1} (K_{ib}^{(s)} x_b^{(s)})$ by performing the local solve as described above.\n        ii. If $n_i^{(s)} = 0$, compute $y_b^{(s)} = K_{bb}^{(s)} x_b^{(s)}$.\n    c.  **Scatter**: Use the map $\\phi^{(s)}$ to add the elements of the local result $y_b^{(s)}$ to the corresponding positions in the global vector $y_b$.\n3.  The final vector $y_b$ is the result of the operation $S x_b$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef apply_schur_operator(Nb, subdomains, xb):\n    \"\"\"\n    Computes the action of the Schur complement operator S on a vector xb.\n\n    This function computes yb = S @ xb without explicitly assembling S.\n    The computation is done subdomain by subdomain using gather-solve-scatter ops.\n\n    Args:\n        Nb (int): The total number of global interface DOFs.\n        subdomains (list): A list of dictionaries, each representing a subdomain's data.\n        xb (np.ndarray): The global interface vector.\n\n    Returns:\n        np.ndarray: The resulting global interface vector yb.\n    \"\"\"\n    yb = np.zeros(Nb, dtype=float)\n\n    for s_data in subdomains:\n        Kii = s_data['Kii']\n        Kib = s_data['Kib']\n        Kbi = s_data['Kbi']\n        Kbb = s_data['Kbb']\n        phi = s_data['phi']\n        ni_s = Kii.shape[0]\n\n        # 1. Gather operation: extract local interface vector from global vector\n        xb_s = xb[phi]\n\n        # 2. Compute local contribution yb_s = S_s * xb_s\n        if ni_s > 0:\n            # S_s = Kbb_s - Kbi_s * inv(Kii_s) * Kib_s\n            # We compute the product yb_s = S_s @ xb_s in steps:\n            # a. Compute intermediate vector v_s = Kib_s @ xb_s\n            v_s = Kib @ xb_s\n            # b. Solve the local interior system: Kii_s * u_i_s = v_s\n            u_i_s = np.linalg.solve(Kii, v_s)\n            # c. Compute local contribution: yb_s = Kbb_s @ xb_s - Kbi_s @ u_i_s\n            yb_s = Kbb @ xb_s - Kbi @ u_i_s\n        else:\n            # If no interior DOFs, S_s = Kbb_s\n            yb_s = Kbb @ xb_s\n        \n        # 3. Scatter operation: add local contribution back to global vector\n        # np.add.at is a vectorized way to perform this scatter-add operation.\n        np.add.at(yb, phi, yb_s)\n\n    return yb\n\ndef solve():\n    \"\"\"\n    Defines and runs the test cases specified in the problem statement.\n    \"\"\"\n    test_cases = [\n        # Test Case A\n        {\n            \"Nb\": 1,\n            \"subdomains\": [\n                {\n                    \"Kii\": np.array([[4, 1], [1, 3]]),\n                    \"Kib\": np.array([[1], [2]]),\n                    \"Kbi\": np.array([[1, 2]]),\n                    \"Kbb\": np.array([[5]]),\n                    \"phi\": np.array([0]),\n                }\n            ],\n            \"xb\": np.array([1.5]),\n        },\n        # Test Case B\n        {\n            \"Nb\": 3,\n            \"subdomains\": [\n                {\n                    \"Kii\": np.array([[3]]),\n                    \"Kib\": np.array([[1, -1]]),\n                    \"Kbi\": np.array([[1], [-1]]),\n                    \"Kbb\": np.array([[4, 0.5], [0.5, 2]]),\n                    \"phi\": np.array([0, 1]),\n                },\n                {\n                    \"Kii\": np.array([[6, 1], [1, 4]]),\n                    \"Kib\": np.array([[2, 0], [-1, 3]]),\n                    \"Kbi\": np.array([[2, -1], [0, 3]]),\n                    \"Kbb\": np.array([[3, -0.2], [-0.2, 5]]),\n                    \"phi\": np.array([1, 2]),\n                },\n            ],\n            \"xb\": np.array([1.0, -0.5, 2.0]),\n        },\n        # Test Case C\n        {\n            \"Nb\": 3,\n            \"subdomains\": [\n                { # Subdomain with no interior DOFs\n                    \"Kii\": np.empty((0, 0)),\n                    \"Kib\": np.empty((0, 2)),\n                    \"Kbi\": np.empty((2, 0)),\n                    \"Kbb\": np.array([[2, 0.3], [0.3, 1.5]]),\n                    \"phi\": np.array([0, 1]),\n                },\n                {\n                    \"Kii\": np.array([[2]]),\n                    \"Kib\": np.array([[-1, 0.5]]),\n                    \"Kbi\": np.array([[-1], [0.5]]),\n                    \"Kbb\": np.array([[1, 0.1], [0.1, 2]]),\n                    \"phi\": np.array([1, 2]),\n                },\n                {\n                    \"Kii\": np.array([[7, 0], [0, 8]]),\n                    \"Kib\": np.array([[1], [2]]),\n                    \"Kbi\": np.array([[1, 2]]),\n                    \"Kbb\": np.array([[4]]),\n                    \"phi\": np.array([2]),\n                },\n            ],\n            \"xb\": np.array([0.2, -1.2, 0.7]),\n        },\n    ]\n\n    results_str = []\n    for case in test_cases:\n        Nb = case[\"Nb\"]\n        subdomains = case[\"subdomains\"]\n        xb = case[\"xb\"]\n        \n        yb = apply_schur_operator(Nb, subdomains, xb)\n        \n        # Format the result vector as a string list with 6 decimal places\n        formatted_yb = [f\"{val:.6f}\" for val in yb]\n        results_str.append(f\"[{','.join(formatted_yb)}]\")\n\n    # Print the final output in the required format: [[...],[...],...]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "3565877"}, {"introduction": "In engineering design and analysis, we often need to perform rapid \"what-if\" studies by exploring how small changes in a system's parameters affect its response. This exercise demonstrates how to combine static condensation with the Sherman-Morrison-Woodbury identity to efficiently update a condensed model in response to low-rank changes in the internal stiffness. This powerful technique avoids costly re-inversions and enables fast parametric analysis, a vital skill in computational geomechanics. [@problem_id:3565864]", "problem": "Consider a finite element soil–structure interaction sub-structure where the global stiffness matrix is partitioned into boundary degrees of freedom and internal soil degrees of freedom. Let the equilibrium in the absence of inertia be governed by the linear system $K u = f$, where $K$ is the symmetric positive definite (SPD) stiffness matrix, $u$ is the displacement vector, and $f$ is the force vector. Using sub-structuring, partition the variables as $u = \\begin{bmatrix} u_b \\\\ u_i \\end{bmatrix}$ and $f = \\begin{bmatrix} f_b \\\\ f_i \\end{bmatrix}$, and the stiffness matrix as\n$$\nK = \\begin{bmatrix}\nK_{bb} & K_{bi} \\\\\nK_{ib} & K_{ii}\n\\end{bmatrix}.\n$$\nStatic condensation eliminates the internal soil degrees of freedom to yield a reduced system in the boundary degrees of freedom. You are to derive this reduction from first principles and then implement a program that performs rapid \"what-if\" analyses in the boundary displacement vector $u_b$ when the internal soil stiffness $K_{ii}$ is perturbed by low-rank changes $\\delta K_{ii}$.\n\nBase your derivation on the following foundational facts:\n- Equilibrium of linear elasticity in the finite element method: $K u = f$.\n- Properties of the block-partitioned linear system and elimination of internal variables.\n- The Sherman–Morrison–Woodbury identity (SMW), defined as follows on first appearance: the Sherman–Morrison–Woodbury identity (SMW) states that for invertible $A$ and appropriately sized matrices $U$, $C$, and $V$, one has $(A + U C V)^{-1} = A^{-1} - A^{-1} U \\left(C^{-1} + V A^{-1} U \\right)^{-1} V A^{-1}$.\n\nYou must not use or quote the target condensed formula directly; start from $K u = f$ and reason to the condensed system. Then, use SMW to update the inverse of the internal stiffness block $K_{ii}$ efficiently under low-rank changes, and consequently update the condensed stiffness and the condensed right-hand-side without recomputing any full inverse from scratch.\n\nAssume the following specific matrices (units: stiffness entries in kilonewtons per meter ($\\mathrm{kN/m}$)):\n$$\nK_{bb} = \\begin{bmatrix}\n1000 & -200 \\\\\n-200 & 800\n\\end{bmatrix},\\quad\nK_{bi} = \\begin{bmatrix}\n-150 & 100 & 0 \\\\\n50 & -120 & 80\n\\end{bmatrix},\\quad\nK_{ib} = K_{bi}^\\top,\n$$\n$$\nK_{ii} = \\begin{bmatrix}\n3000 & -500 & 0 \\\\\n-500 & 2000 & -400 \\\\\n0 & -400 & 1500\n\\end{bmatrix}.\n$$\n\nYou will analyze four \"what-if\" cases, each characterized by a low-rank update to the internal stiffness $\\delta K_{ii} = U C U^\\top$ and specified boundary and internal forces. In each case, compute the boundary displacement vector $u_b$ produced by the condensed system. Express each displacement component in meters ($\\mathrm{m}$), rounded to six decimal places.\n\nThe test suite is given by:\n- Case $1$ (baseline, happy path): $\\delta K_{ii} = 0$, $f_b = \\begin{bmatrix} 10 \\\\ -5 \\end{bmatrix}$ in $\\mathrm{kN}$, $f_i = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix}$ in $\\mathrm{kN}$.\n- Case $2$ (rank-$1$ positive update): $U = \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\end{bmatrix}$, $C = \\begin{bmatrix} 200 \\end{bmatrix}$ (units $\\mathrm{kN/m}$), thus $\\delta K_{ii} = 200 \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\end{bmatrix} \\begin{bmatrix} 1 & 0 & 0 \\end{bmatrix}$, $f_b = \\begin{bmatrix} 10 \\\\ -5 \\end{bmatrix}$ in $\\mathrm{kN}$, $f_i = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix}$ in $\\mathrm{kN}$.\n- Case $3$ (rank-$2$ mixed update with internal loads): $U = \\begin{bmatrix} 0 & 0 \\\\ 1 & 0 \\\\ 0 & 1 \\end{bmatrix}$, $C = \\begin{bmatrix} 100 & 0 \\\\ 0 & -50 \\end{bmatrix}$ (units $\\mathrm{kN/m}$), $f_b = \\begin{bmatrix} 12 \\\\ 8 \\end{bmatrix}$ in $\\mathrm{kN}$, $f_i = \\begin{bmatrix} 5 \\\\ -10 \\\\ 15 \\end{bmatrix}$ in $\\mathrm{kN}$.\n- Case $4$ (edge case: zero boundary loads, rank-$1$ isotropic direction): $U = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}$, $C = \\begin{bmatrix} 300 \\end{bmatrix}$ (units $\\mathrm{kN/m}$), $f_b = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$ in $\\mathrm{kN}$, $f_i = \\begin{bmatrix} 20 \\\\ -5 \\\\ 10 \\end{bmatrix}$ in $\\mathrm{kN}$.\n\nImplementation requirements:\n- Compute the baseline inverse $K_{ii}^{-1}$ once.\n- For each case, use the Sherman–Morrison–Woodbury identity to obtain $(K_{ii} + \\delta K_{ii})^{-1}$ without recomputing a full inverse from scratch.\n- Form the condensed stiffness $S = K_{bb} - K_{bi} K_{ii}^{-1} K_{ib}$ and, under updates, $S' = K_{bb} - K_{bi} (K_{ii} + \\delta K_{ii})^{-1} K_{ib}$.\n- Form the condensed force $g = f_b - K_{bi} K_{ii}^{-1} f_i$ and, under updates, $g' = f_b - K_{bi} (K_{ii} + \\delta K_{ii})^{-1} f_i$.\n- Solve $S' u_b = g'$ for $u_b$ in each case.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with the components ordered by case and then by boundary degree of freedom. Specifically, output $[u_{b,1}^{(1)},u_{b,2}^{(1)},u_{b,1}^{(2)},u_{b,2}^{(2)},u_{b,1}^{(3)},u_{b,2}^{(3)},u_{b,1}^{(4)},u_{b,2}^{(4)}]$, where each $u_{b,j}^{(c)}$ is in meters and rounded to six decimal places.", "solution": "The problem requires deriving the static condensation procedure from first principles and then using the Sherman-Morrison-Woodbury (SMW) identity to efficiently compute the effect of low-rank changes on a condensed system.\n\nThe starting point is the linear system of equations governing static equilibrium in a finite element model:\n$$\nK u = f\n$$\nwhere $K$ is the global stiffness matrix, $u$ is the vector of nodal displacements, and $f$ is the vector of nodal forces. The matrix $K$ is symmetric and positive definite (SPD).\n\nWe partition the degrees of freedom (DOFs) into boundary DOFs, denoted by subscript $b$, and internal DOFs, denoted by subscript $i$. This induces a block structure in the matrix $K$ and vectors $u$ and $f$:\n$$\n\\begin{bmatrix}\nK_{bb} & K_{bi} \\\\\nK_{ib} & K_{ii}\n\\end{bmatrix}\n\\begin{bmatrix}\nu_b \\\\\nu_i\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nf_b \\\\\nf_i\n\\end{bmatrix}\n$$\nHere, $K_{bb}$ represents the stiffness coupling between boundary DOFs, $K_{ii}$ represents the stiffness coupling between internal DOFs, and $K_{bi}$ (with its transpose $K_{ib} = K_{bi}^\\top$ due to symmetry) represents the coupling between boundary and internal DOFs.\n\nThis block matrix equation can be expanded into two coupled vector equations:\n$$\n(1) \\quad K_{bb} u_b + K_{bi} u_i = f_b\n$$\n$$\n(2) \\quad K_{ib} u_b + K_{ii} u_i = f_i\n$$\nThe procedure of static condensation aims to eliminate the internal DOFs $u_i$ to obtain a smaller system solely in terms of the boundary DOFs $u_b$. We achieve this by first solving Equation (2) for $u_i$. Since $K$ is SPD, its principal submatrix $K_{ii}$ is also SPD and thus invertible.\n$$\nK_{ii} u_i = f_i - K_{ib} u_b\n$$\n$$\nu_i = K_{ii}^{-1} (f_i - K_{ib} u_b)\n$$\nThis expression gives the internal displacements $u_i$ in terms of the boundary displacements $u_b$ and the applied forces.\n\nNext, we substitute this expression for $u_i$ back into Equation (1):\n$$\nK_{bb} u_b + K_{bi} \\left( K_{ii}^{-1} (f_i - K_{ib} u_b) \\right) = f_b\n$$\nWe distribute $K_{bi}$ and group the terms involving $u_b$ on the left-hand side and all other terms (the effective forces) on the right-hand side:\n$$\nK_{bb} u_b - K_{bi} K_{ii}^{-1} K_{ib} u_b = f_b - K_{bi} K_{ii}^{-1} f_i\n$$\nFactoring out $u_b$ leads to the condensed system of equations:\n$$\n\\left( K_{bb} - K_{bi} K_{ii}^{-1} K_{ib} \\right) u_b = f_b - K_{bi} K_{ii}^{-1} f_i\n$$\nThis is the desired reduced system, which can be written as $S u_b = g$, where:\n- The condensed stiffness matrix, or Schur complement of $K_{ii}$ in $K$, is $S = K_{bb} - K_{bi} K_{ii}^{-1} K_{ib}$.\n- The condensed force vector is $g = f_b - K_{bi} K_{ii}^{-1} f_i$.\n\nNow, we consider a \"what-if\" scenario where the internal stiffness matrix $K_{ii}$ is perturbed by a low-rank update, $\\delta K_{ii} = U C U^\\top$, where $U$ has dimensions $n_i \\times r$, $C$ is an $r \\times r$ invertible matrix, and $r$ is small. The new internal stiffness is $K'_{ii} = K_{ii} + \\delta K_{ii} = K_{ii} + U C U^\\top$.\n\nThe new condensed system becomes $S' u_b = g'$, where:\n$$\nS' = K_{bb} - K_{bi} (K'_{ii})^{-1} K_{ib}\n$$\n$$\ng' = f_b - K_{bi} (K'_{ii})^{-1} f_i\n$$\nDirectly inverting $K'_{ii}$ for each what-if scenario would be computationally expensive. Instead, we use the Sherman–Morrison–Woodbury identity (SMW), which states that for an invertible matrix $A$ and appropriately sized matrices $U$, $C$, and $V$: $(A + U C V)^{-1} = A^{-1} - A^{-1} U (C^{-1} + V A^{-1} U)^{-1} V A^{-1}$.\n\nWe apply this identity to compute $(K'_{ii})^{-1} = (K_{ii} + U C U^\\top)^{-1}$ with $A=K_{ii}$ and $V=U^\\top$:\n$$\n(K'_{ii})^{-1} = K_{ii}^{-1} - K_{ii}^{-1} U \\left(C^{-1} + U^\\top K_{ii}^{-1} U \\right)^{-1} U^\\top K_{ii}^{-1}\n$$\nThe key advantage is that the matrix to be inverted, $M = C^{-1} + U^\\top K_{ii}^{-1} U$, is of size $r \\times r$, which is much smaller than the size of $K_{ii}$. This allows for a rapid update of the inverse.\n\nThe algorithm for each what-if analysis is as follows:\n1.  Compute the inverse of the baseline internal stiffness matrix, $K_{ii}^{-1}$, once.\n2.  For each case, define the update matrices $U$ and $C$, and force vectors $f_b$ and $f_i$.\n3.  If there is a non-zero update ($\\delta K_{ii} \\neq 0$), calculate the perturbed inverse $(K'_{ii})^{-1}$ using the SMW formula. This involves:\n    a. Computing the small matrix $M = C^{-1} + U^\\top K_{ii}^{-1} U$.\n    b. Inverting $M$ to get $M^{-1}$.\n    c. Assembling the updated inverse $(K'_{ii})^{-1} = K_{ii}^{-1} - (K_{ii}^{-1} U) M^{-1} (U^\\top K_{ii}^{-1})$.\n4.  If there is no update, set $(K'_{ii})^{-1} = K_{ii}^{-1}$.\n5.  Form the perturbed condensed stiffness matrix $S' = K_{bb} - K_{bi} (K'_{ii})^{-1} K_{ib}$.\n6.  Form the perturbed condensed force vector $g' = f_b - K_{bi} (K'_{ii})^{-1} f_i$.\n7.  Solve the small $2 \\times 2$ linear system $S' u_b = g'$ for the boundary displacement vector $u_b$.\n8.  The resulting displacements are in meters, as stiffness is in $\\mathrm{kN/m}$ and force is in $\\mathrm{kN}$. These will be rounded to six decimal places for the final output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the sub-structuring and static condensation problem for four \"what-if\" cases.\n    The solution involves deriving the condensed system, updating it with the\n    Sherman-Morrison-Woodbury identity for low-rank perturbations, and solving for\n    boundary displacements.\n    \"\"\"\n\n    # --- Step 1: Define baseline matrices from the problem statement ---\n    # Units: stiffness entries in kN/m\n    K_bb = np.array([\n        [1000, -200],\n        [-200, 800]\n    ])\n    K_bi = np.array([\n        [-150, 100, 0],\n        [50, -120, 80]\n    ])\n    K_ib = K_bi.T\n    K_ii = np.array([\n        [3000, -500, 0],\n        [-500, 2000, -400],\n        [0, -400, 1500]\n    ])\n\n    # --- Step 2: Define the test suite for the four cases ---\n    # Units: forces in kN, stiffness update in kN/m\n    test_cases = [\n        # Case 1: baseline, happy path\n        {\n            \"U\": None,\n            \"C\": None,\n            \"f_b\": np.array([10, -5]),\n            \"f_i\": np.array([0, 0, 0])\n        },\n        # Case 2: rank-1 positive update\n        {\n            \"U\": np.array([[1], [0], [0]]),\n            \"C\": np.array([[200]]),\n            \"f_b\": np.array([10, -5]),\n            \"f_i\": np.array([0, 0, 0])\n        },\n        # Case 3: rank-2 mixed update with internal loads\n        {\n            \"U\": np.array([[0, 0], [1, 0], [0, 1]]),\n            \"C\": np.array([[100, 0], [0, -50]]),\n            \"f_b\": np.array([12, 8]),\n            \"f_i\": np.array([5, -10, 15])\n        },\n        # Case 4: zero boundary loads, rank-1 isotropic direction\n        {\n            \"U\": np.array([[1], [1], [1]]),\n            \"C\": np.array([[300]]),\n            \"f_b\": np.array([0, 0]),\n            \"f_i\": np.array([20, -5, 10])\n        }\n    ]\n\n    # --- Step 3: Perform calculations ---\n\n    # Compute the baseline inverse of K_ii once.\n    K_ii_inv = np.linalg.inv(K_ii)\n\n    results = []\n    for case in test_cases:\n        U = case[\"U\"]\n        C = case[\"C\"]\n        f_b = case[\"f_b\"]\n        f_i = case[\"f_i\"]\n\n        K_ii_p_inv = None # Perturbed inverse\n        \n        # Check if there is an update\n        if U is None or C is None:\n            # Case 1: No update, use baseline inverse\n            K_ii_p_inv = K_ii_inv\n        else:\n            # Cases 2, 3, 4: Update K_ii_inv using Sherman-Morrison-Woodbury\n            # (K_ii + UCU^T)^-1 = K_ii^-1 - K_ii^-1 U (C^-1 + U^T K_ii^-1 U)^-1 U^T K_ii^-1\n            C_inv = np.linalg.inv(C)\n            M = C_inv + U.T @ K_ii_inv @ U\n            M_inv = np.linalg.inv(M)\n            \n            # Efficiently calculate update term\n            Kii_inv_U = K_ii_inv @ U\n            update_term = Kii_inv_U @ M_inv @ Kii_inv_U.T\n            \n            K_ii_p_inv = K_ii_inv - update_term\n\n        # Form the condensed stiffness matrix S'\n        S_prime = K_bb - K_bi @ K_ii_p_inv @ K_ib\n\n        # Form the condensed force vector g'\n        g_prime = f_b - K_bi @ K_ii_p_inv @ f_i\n\n        # Solve the condensed system S' * u_b = g' for boundary displacements u_b\n        u_b = np.linalg.solve(S_prime, g_prime)\n\n        # Append results, rounded to six decimal places, to the list\n        results.extend(u_b)\n\n    # Format the final output string as required\n    formatted_results = [f\"{val:.6f}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3565864"}, {"introduction": "When applying static condensation to nonlinear problems like elastoplasticity, a key challenge is that the optimal partitioning of degrees of freedom can change during the analysis. This exercise guides you through implementing an adaptive condensation scheme where the decision to condense a region is based on its plastic activity. You will explore the numerical consistency of such a scheme, gaining insight into the sophisticated challenges and solutions at the forefront of computational mechanics. [@problem_id:3565876]", "problem": "Consider a quasi-static small-strain one-dimensional bar discretized by the Finite Element Method (FEM) with linear two-node elements. Let the bar have $N_{\\text{node}} = 4$ nodes and $N_{\\text{elem}} = 3$ elements with node connectivity $\\{(0,1),(1,2),(2,3)\\}$. The global equilibrium equation for the incremental Newton step in nonlinear elastoplasticity is obtained from the principle of virtual work as $R(u) = f_{\\text{int}}(u) - f_{\\text{ext}} = 0$, where the linearization at an iterate produces the tangent system $K(u)\\,\\Delta u = -R(u)$. The consistent tangent stiffness $K(u)$ is assembled from element tangents. For each element $e$, use a scalar tangent modulus defined by a smooth proxy function of the plastic multiplier increment $\\Delta \\lambda_e$:\n$$\nk_e(\\Delta \\lambda_e) = \\frac{k_0}{1 + \\alpha\\,\\Delta \\lambda_e},\n$$\nwhere $k_0 > 0$ and $\\alpha > 0$ are constants. The corresponding element stiffness matrix is $k_e(\\Delta \\lambda_e)\\begin{bmatrix}1 & -1\\\\ -1 & 1\\end{bmatrix}$, and the global stiffness $K$ is assembled in the standard way from all elements.\n\nNow, partition the global degrees of freedom into a retained set $b$ and an internal set $i$, and apply static condensation to eliminate the internal degrees of freedom. Given the block partition of the tangent matrix\n$$\nK = \\begin{bmatrix} K_{bb} & K_{bi} \\\\ K_{ib} & K_{ii} \\end{bmatrix},\n$$\nthe condensed tangent for the retained set is defined by the Schur complement\n$$\nK_{bb}^{\\text{cond}} = K_{bb} - K_{bi}\\,K_{ii}^{-1}\\,K_{ib}.\n$$\nIn an adaptive scheme for elastoplasticity, suppose that the retained set $b$ is chosen based on the plastic multiplier increments as follows. Let the baseline retained set include the two boundary nodes $\\{0, N_{\\text{node}}-1\\}$. Then, for a given threshold $\\tau \\ge 0$, adaptively augment $b$ by including any node that is adjacent to an element $e$ whose $\\Delta \\lambda_e \\ge \\tau$. The internal set $i$ is the complement of $b$ in the set of all nodes.\n\nDefine a notion of local consistency for the condensed tangent under this adaptive rule at a given state $\\Delta \\lambda = (\\Delta \\lambda_1,\\dots,\\Delta \\lambda_{N_{\\text{elem}}})$ by comparing the condensed tangent built from $\\Delta \\lambda$ to the condensed tangent built from a perturbed state $\\Delta \\lambda^{+}$. We say the condensed tangent is consistent at the state if the adaptive retained set is unchanged by the perturbation, that is $b(\\Delta \\lambda) = b(\\Delta \\lambda^{+})$, and if the condensed tangent changes only smoothly under the perturbation, measured by the relative Frobenius norm\n$$\n\\eta = \\frac{\\left\\|K_{bb}^{\\text{cond}}(\\Delta \\lambda^{+}) - K_{bb}^{\\text{cond}}(\\Delta \\lambda)\\right\\|_F}{\\left\\|K_{bb}^{\\text{cond}}(\\Delta \\lambda)\\right\\|_F + \\varepsilon},\n$$\nwhere $\\varepsilon = 10^{-15}$ is a small positive number to avoid division by zero. Declare the condensed tangent consistent if $b(\\Delta \\lambda) = b(\\Delta \\lambda^{+})$ and $\\eta \\le \\text{tol}$, with $\\text{tol} = 10^{-6}$.\n\nImplement the following in a program:\n\n- Assemble the global tangent matrix $K(\\Delta \\lambda)$ using $k_0 = 1$ and $\\alpha = 10$ for the bar described above.\n- Construct the adaptive retained set $b(\\Delta \\lambda,\\tau)$ with the baseline $\\{0, 3\\}$ and the augmentation rule described above.\n- Compute $K_{bb}^{\\text{cond}}$ via static condensation using the Schur complement for the partition induced by $b$ and its complement $i$.\n- For each test case below, compute the boolean flag indicating whether the condensed tangent is consistent at the given state and perturbation, according to the rule: return true if $b(\\Delta \\lambda) = b(\\Delta \\lambda^{+})$ and $\\eta \\le 10^{-6}$, and false otherwise.\n\nUse the following test suite, where each test case is specified by the pair $(\\Delta \\lambda, \\Delta \\lambda^{+}, \\tau)$:\n\n- Test $1$ (happy path, stable set): $\\Delta \\lambda = [0.1, 0.5, 0.2]$, $\\Delta \\lambda^{+} = [0.1 + 10^{-9}, 0.5 + 10^{-9}, 0.2 + 10^{-9}]$, $\\tau = 0.4$.\n- Test $2$ (set switching near threshold): $\\Delta \\lambda = [0.29, 0.001, 0.29]$, $\\Delta \\lambda^{+} = [0.31, 0.001, 0.29]$, $\\tau = 0.3$.\n- Test $3$ (all retained, stable): $\\Delta \\lambda = [0.9, 0.8, 0.7]$, $\\Delta \\lambda^{+} = [0.900000001, 0.800000001, 0.700000001]$, $\\tau = 0.1$.\n- Test $4$ (only endpoints retained, stable): $\\Delta \\lambda = [0.0, 0.0, 0.0]$, $\\Delta \\lambda^{+} = [10^{-12}, 10^{-12}, 10^{-12}]$, $\\tau = 1.0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list of booleans enclosed in square brackets (for example, \"[True,False,True,True]\").\n\nNo physical units are required in the output. Angles are not involved. All numerical values in this problem are non-dimensional and should be treated as pure numbers.", "solution": "The problem requires implementing an adaptive static condensation scheme for a nonlinear one-dimensional bar problem and checking its numerical consistency. The solution involves several steps:\n\n1.  **Model Setup**: Implement functions to construct the element and global tangent stiffness matrices based on the provided nonlinear constitutive law $k_e(\\Delta \\lambda_e)$. The global tangent matrix $K$ is assembled by summing the contributions of the three element matrices according to the specified node connectivity.\n\n2.  **Adaptive Partitioning**: Create a function that determines the set of retained degrees of freedom, $b$, based on a threshold $\\tau$. The set starts with the boundary nodes $\\{0, 3\\}$ and is augmented by adding the nodes of any element $e$ where the plastic multiplier increment $\\Delta \\lambda_e$ exceeds or equals the threshold. The internal set, $i$, is the complement of $b$.\n\n3.  **Static Condensation**: For a given global tangent matrix $K$ and a retained set $b$, partition $K$ into blocks ($K_{bb}, K_{bi}, K_{ib}, K_{ii}$) and compute the condensed stiffness matrix (Schur complement) $K_{bb}^{\\text{cond}} = K_{bb} - K_{bi} K_{ii}^{-1} K_{ib}$. If the internal set $i$ is empty, no condensation is performed, and the condensed matrix is simply the full global matrix $K$.\n\n4.  **Consistency Check**: The core of the problem is to evaluate consistency for a given state $\\Delta \\lambda$ and a perturbed state $\\Delta \\lambda^{+}$. This involves two conditions:\n    a.  **Set Stability**: The retained sets computed for $\\Delta \\lambda$ and for $\\Delta \\lambda^{+}$ must be identical. If they differ, the scheme is inconsistent for that perturbation. A small change in state should not cause a discrete jump in the model's partitioning. This is a critical issue in numerical methods, as it can destroy the convergence of iterative solvers like Newton's method.\n    b.  **Smoothness**: If the retained sets are stable, we then check that the condensed operator changes smoothly. This is done by computing the condensed matrices for both states and measuring their difference using a relative Frobenius norm, $\\eta$. The change is considered smooth (and thus consistent) if $\\eta$ is below a small tolerance, $\\text{tol} = 10^{-6}$.\n\nThe provided Python code implements this logic. For each test case, it determines the retained sets for the original and perturbed states, checks for stability, and if stable, proceeds to compute and compare the condensed matrices to return a final boolean consistency flag.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    N_NODE = 4\n    N_ELEM = 3\n    CONNECTIVITY = [(0, 1), (1, 2), (2, 3)]\n    K0 = 1.0\n    ALPHA = 10.0\n    TOL = 1e-6\n    EPSILON = 1e-15\n\n    # --- Helper Functions ---\n\n    def assemble_global_K(delta_lambda):\n        \"\"\"Assembles the global tangent stiffness matrix K.\"\"\"\n        K = np.zeros((N_NODE, N_NODE))\n        k_elem_mat = np.array([[1.0, -1.0], [-1.0, 1.0]])\n\n        for e in range(N_ELEM):\n            k_e = K0 / (1.0 + ALPHA * delta_lambda[e])\n            nodes = CONNECTIVITY[e]\n            n1, n2 = nodes\n            \n            # Using np.ix_ for elegant assembly\n            ix = np.ix_(nodes, nodes)\n            K[ix] += k_e * k_elem_mat\n        \n        return K\n\n    def get_retained_set(delta_lambda, tau):\n        \"\"\"Constructs the adaptive retained set b.\"\"\"\n        # Baseline set includes boundary nodes\n        b = {0, N_NODE - 1}\n        \n        # Augment set based on the adaptive rule\n        for e in range(N_ELEM):\n            if delta_lambda[e] >= tau:\n                nodes = CONNECTIVITY[e]\n                b.add(nodes[0])\n                b.add(nodes[1])\n        \n        return sorted(list(b))\n\n    def compute_condensed_K(delta_lambda, b):\n        \"\"\"Computes the condensed tangent matrix K_bb_cond.\"\"\"\n        K = assemble_global_K(delta_lambda)\n        \n        all_nodes = list(range(N_NODE))\n        i = sorted(list(set(all_nodes) - set(b)))\n        \n        # If there are no internal nodes, the condensed matrix is the global matrix.\n        if not i:\n            return K\n        \n        # Partition the global matrix K\n        # np.ix_ is used for advanced indexing to extract submatrices\n        K_bb = K[np.ix_(b, b)]\n        K_bi = K[np.ix_(b, i)]\n        K_ib = K[np.ix_(i, b)]\n        K_ii = K[np.ix_(i, i)]\n\n        # Check for singularity in K_ii before inverting\n        if np.linalg.det(K_ii) == 0:\n            # In a general context, one might use a pseudo-inverse, \n            # but for this problem, K_ii is expected to be invertible.\n            # Returning a matrix of NaNs to signal an issue.\n            return np.full_like(K_bb, np.nan)\n\n        # Compute Schur complement\n        K_ii_inv = np.linalg.inv(K_ii)\n        K_bb_cond = K_bb - K_bi @ K_ii_inv @ K_ib\n        \n        return K_bb_cond\n\n    def check_consistency(delta_lambda, delta_lambda_plus, tau):\n        \"\"\"\n        Checks the consistency of the condensed tangent based on the problem's criteria.\n        Returns True for consistent, False otherwise.\n        \"\"\"\n        # 1. Check for stability of the retained set\n        b = get_retained_set(delta_lambda, tau)\n        b_plus = get_retained_set(delta_lambda_plus, tau)\n\n        if b != b_plus:\n            return False\n\n        # 2. If the set is stable, check for smooth change in the condensed matrix\n        K_bb_cond = compute_condensed_K(np.array(delta_lambda), b)\n        K_bb_cond_plus = compute_condensed_K(np.array(delta_lambda_plus), b)\n\n        # 3. Calculate the relative Frobenius norm\n        norm_diff = np.linalg.norm(K_bb_cond_plus - K_bb_cond, 'fro')\n        norm_orig = np.linalg.norm(K_bb_cond, 'fro')\n        \n        eta = norm_diff / (norm_orig + EPSILON)\n\n        # 4. Check against the tolerance\n        return eta <= TOL\n\n    # --- Test Suite ---\n    test_cases = [\n        # Test 1 (happy path, stable set)\n        ([0.1, 0.5, 0.2], [0.1 + 1e-9, 0.5 + 1e-9, 0.2 + 1e-9], 0.4),\n        # Test 2 (set switching near threshold)\n        ([0.29, 0.001, 0.29], [0.31, 0.001, 0.29], 0.3),\n        # Test 3 (all retained, stable)\n        ([0.9, 0.8, 0.7], [0.900000001, 0.800000001, 0.700000001], 0.1),\n        # Test 4 (only endpoints retained, stable)\n        ([0.0, 0.0, 0.0], [1e-12, 1e-12, 1e-12], 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        dl, dl_plus, t = case\n        is_consistent = check_consistency(dl, dl_plus, t)\n        results.append(is_consistent)\n\n    # Final print statement in the exact required format.\n    # The map(str,...) converts boolean True/False to \"True\"/\"False\" strings.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3565876"}]}