{"hands_on_practices": [{"introduction": "The relationship between the stress intensity factor, $K$, and the energy release rate, $G$, is fundamental to fracture mechanics. However, this relationship is not universal; it is modulated by the out-of-plane stress state of the body. This first exercise provides a direct, hands-on calculation to explore the crucial difference between plane stress and plane strain conditions, demonstrating how structural constraint affects the energy available for fracture for a given level of stress intensity at the crack tip [@problem_id:3526160].", "problem": "A family of geometrically similar single-edge-notched prismatic specimens of a saturated sandstone are tested in tension under drained conditions at quasi-static loading. The crack is through-thickness and centrally located relative to the ligament, with straight crack fronts. The material follows linear elasticity up to fracture and the inelastic (process) zone is small compared to specimen dimensions. Consider two members of this family that are identical in all in-plane dimensions and loading but differ in thickness: a thin specimen with thickness $B_{1} = 8\\,\\mathrm{mm}$ and a thick specimen with thickness $B_{2} = 200\\,\\mathrm{mm}$. The drained Young’s modulus is $E = 25\\,\\mathrm{GPa}$ and the drained Poisson’s ratio is $\\nu = 0.25$. At a given load level for which the Mode I stress intensity factor is $K_{I} = 2.5\\,\\mathrm{MPa}\\sqrt{\\mathrm{m}}$ for both specimens, assume that the thin specimen is governed by a plane stress state at the crack mid-plane and the thick specimen is governed by a plane strain state at the crack mid-plane due to out-of-plane constraint.\n\nStarting from the definition of the energy release rate $G$ as the negative derivative of the total potential energy with respect to crack area, and the path-independence of the $J$-integral in linear elastic fracture mechanics, use the near-tip asymptotic fields in isotropic linear elasticity to relate $G$ to the stress intensity factor $K_{I}$ via an effective modulus $E'$ that depends on the out-of-plane constraint. Identify $E'$ appropriate to plane stress and to plane strain, and then compute the numerical change in energy release rate\n$$\\Delta G = G_{\\text{plane stress}} - G_{\\text{plane strain}}$$\nat the prescribed $K_{I}$ as the thickness increases from $B_{1}$ to $B_{2}$.\n\nExpress the final answer as a single number in $\\mathrm{J/m^{2}}$ and round your answer to four significant figures.", "solution": "The problem statement is evaluated and found to be valid. It is scientifically grounded in the principles of linear elastic fracture mechanics (LEFM), well-posed with all necessary information provided, and objective in its formulation. The assumptions, such as linear elasticity, small-scale yielding, and the application of plane stress and plane strain conditions to specimens of differing thickness, are standard and appropriate for this context. The provided material properties and stress intensity factor are physically realistic for a geomaterial like sandstone.\n\nThe core of the problem is to determine the relationship between the energy release rate, $G$, and the Mode I stress intensity factor, $K_I$, under plane stress and plane strain conditions, and then to calculate the difference in $G$ for a given $K_I$.\n\nThe energy release rate, $G$, is defined as the rate of change of potential energy, $\\Pi$, with respect to the crack area, $A$. For a crack of length $a$ in a body of thickness $B$, the crack area is $A = aB$. The energy release rate is thus given by:\n$$G = -\\frac{d\\Pi}{dA} = -\\frac{1}{B}\\frac{d\\Pi}{da}$$\nIn linear elastic fracture mechanics, the energy release rate $G$ is equivalent to the $J$-integral, a path-independent integral evaluated on a contour $\\Gamma$ that encloses the crack tip. The $J$-integral is defined as:\n$$J = \\int_{\\Gamma} \\left( W n_1 - T_i \\frac{\\partial u_i}{\\partial x_1} \\right) d\\Gamma$$\nwhere $W$ is the strain energy density, $n_1$ is the component of the unit outward normal to the contour $\\Gamma$ in the direction of crack propagation ($x_1$-direction), $T_i = \\sigma_{ij}n_j$ are the components of the traction vector on the contour, and $u_i$ are the displacement vector components.\n\nThe path-independence of the $J$-integral allows its evaluation using the near-tip asymptotic fields for stress and displacement. For a Mode I crack in an isotropic, linear elastic material, these fields are given in a polar coordinate system $(r, \\theta)$ centered at the crack tip:\n$$\\sigma_{ij}(r, \\theta) = \\frac{K_I}{\\sqrt{2\\pi r}} f_{ij}(\\theta) + \\text{higher order terms}$$\n$$u_i(r, \\theta) = \\frac{K_I}{2\\mu} \\sqrt{\\frac{r}{2\\pi}} g_i(\\theta) + \\text{higher order terms}$$\nwhere $\\mu = \\frac{E}{2(1+\\nu)}$ is the shear modulus and $f_{ij}$ and $g_i$ are dimensionless functions of $\\theta$. The strain energy density $W = \\frac{1}{2}\\sigma_{ij}\\varepsilon_{ij}$ will have a leading term proportional to $r^{-1}$. Evaluating the $J$-integral on an infinitesimal circular path of radius $r$ around the crack tip leads to a result that is independent of $r$ and relates $J$ (and thus $G$) to $K_I$. The result of this well-established derivation is of the form:\n$$G = J = \\frac{K_I^2}{E'}$$\nwhere $E'$ is an effective Young's modulus that depends on the out-of-plane constraint, i.e., whether the state is plane stress or plane strain.\n\nFor the thin specimen ($B_1 = 8\\,\\mathrm{mm}$), a state of plane stress is assumed to prevail at the mid-plane. The defining condition for plane stress is $\\sigma_{zz} = \\sigma_{xz} = \\sigma_{yz} = 0$. The in-plane stress-strain relations are not modified from their standard three-dimensional form when written in terms of $E$ and $\\nu$. The energy release rate is directly related to the Young's modulus $E$.\nFor plane stress:\n$$G_{\\text{plane stress}} = \\frac{K_I^2}{E}$$\nThus, the effective modulus for plane stress is $E'_{\\text{pl. stress}} = E$.\n\nFor the thick specimen ($B_2 = 200\\,\\mathrm{mm}$), a state of plane strain is assumed at the mid-plane due to the high out-of-plane constraint. The defining condition for plane strain is $\\varepsilon_{zz} = \\varepsilon_{xz} = \\varepsilon_{yz} = 0$. The constraint $\\varepsilon_{zz} = 0$ implies a non-zero stress in the thickness direction, $\\sigma_{zz} = \\nu(\\sigma_{xx} + \\sigma_{yy})$. This stiffens the material's response in the $xy$-plane. The in-plane stress-strain relations are modified, and the resulting energy release rate is:\nFor plane strain:\n$$G_{\\text{plane strain}} = \\frac{(1-\\nu^2)K_I^2}{E}$$\nThus, the effective modulus for plane strain is $E'_{\\text{pl. strain}} = \\frac{E}{1-\\nu^2}$.\n\nThe problem requires the computation of the change in energy release rate, $\\Delta G$, as the condition changes from plane stress (thin specimen) to plane strain (thick specimen), at the same level of stress intensity factor $K_I = 2.5\\,\\mathrm{MPa}\\sqrt{\\mathrm{m}}$.\n$$\\Delta G = G_{\\text{plane stress}} - G_{\\text{plane strain}}$$\nSubstituting the expressions for $G$ in terms of $K_I$:\n$$\\Delta G = \\frac{K_I^2}{E} - \\frac{(1-\\nu^2)K_I^2}{E}$$\nFactoring out common terms:\n$$\\Delta G = \\frac{K_I^2}{E} \\left( 1 - (1-\\nu^2) \\right) = \\frac{K_I^2}{E} (1 - 1 + \\nu^2) = \\frac{\\nu^2 K_I^2}{E}$$\nNow, we substitute the given numerical values into this expression. It is crucial to use a consistent set of units (SI units: Pascals, meters).\nThe given values are:\n$K_I = 2.5\\,\\mathrm{MPa}\\sqrt{\\mathrm{m}} = 2.5 \\times 10^6\\,\\mathrm{Pa}\\sqrt{\\mathrm{m}}$\n$E = 25\\,\\mathrm{GPa} = 25 \\times 10^9\\,\\mathrm{Pa}$\n$\\nu = 0.25$\n\nSubstituting these values into the equation for $\\Delta G$:\n$$\\Delta G = \\frac{(0.25)^2 \\times (2.5 \\times 10^6\\,\\mathrm{Pa}\\sqrt{\\mathrm{m}})^2}{25 \\times 10^9\\,\\mathrm{Pa}}$$\n$$\\Delta G = \\frac{0.0625 \\times 6.25 \\times 10^{12}\\,\\mathrm{Pa}^2\\cdot\\mathrm{m}}{25 \\times 10^9\\,\\mathrm{Pa}}$$\n$$\\Delta G = \\frac{0.390625 \\times 10^{12}}{25 \\times 10^9}\\,\\mathrm{Pa}\\cdot\\mathrm{m}$$\n$$\\Delta G = 0.015625 \\times 10^3\\,\\mathrm{Pa}\\cdot\\mathrm{m}$$\n$$\\Delta G = 15.625\\,\\mathrm{Pa}\\cdot\\mathrm{m}$$\nSince $1\\,\\mathrm{Pa} = 1\\,\\mathrm{N/m^2}$, the units are $(\\mathrm{N/m^2})\\cdot\\mathrm{m} = \\mathrm{N/m}$. Furthermore, since $1\\,\\mathrm{J} = 1\\,\\mathrm{N}\\cdot\\mathrm{m}$, we can write $\\mathrm{N/m} = (\\mathrm{N}\\cdot\\mathrm{m})/\\mathrm{m}^2 = \\mathrm{J/m^2}$, which are the correct units for energy release rate.\nSo, $\\Delta G = 15.625\\,\\mathrm{J/m^2}$.\n\nThe problem requests the answer to be rounded to four significant figures.\n$$\\Delta G \\approx 15.63\\,\\mathrm{J/m^2}$$\nThis positive value indicates that for a given stress intensity factor $K_I$, more energy per unit crack extension is released under plane stress conditions than under plane strain conditions. This is physically consistent, as the plane strain state is stiffer.", "answer": "$$ \\boxed{15.63} $$", "id": "3526160"}, {"introduction": "While analytical formulas for fracture parameters are invaluable, a computational geomechanist must be able to verify numerical methods from first principles. This practice guides you through the process of implementing a numerical evaluation of the path-independent $J$-integral, using the known asymptotic crack-tip fields. By coding the contour integration yourself, you will gain a deeper appreciation for the path-independence property and the link between the $J$-integral and the stress intensity factor, which are foundational to Finite Element Method (FEM) and eXtended Finite Element Method (XFEM) implementations [@problem_id:3526090].", "problem": "You are to design, analyze, and implement a computational benchmark for a center-cracked plate in uniform tension to validate numerical evaluation of the Mode I stress intensity factor and the path-independent $J$-integral used in the Finite Element Method (FEM) and the eXtended Finite Element Method (XFEM). The benchmark must be grounded in linear elastic fracture mechanics under small-strain assumptions for an isotropic, homogeneous material. The fundamental base you may use includes the laws of linear elasticity, definitions of strain energy density, and the definition of the path-independent $J$-integral as a line integral of energetic terms around the crack tip. No further shortcut formulas should be assumed in advance. All angles must be treated in radians. All physical quantities must be in the International System of Units (SI): stress in Pascal ($\\text{Pa}$), elastic modulus in Pascal ($\\text{Pa}$), crack lengths in meters ($\\text{m}$), and the $J$-integral in Newton per meter ($\\text{N/m}$).\n\nThe configuration is a center-cracked infinite plate of half-crack length $a$ subjected to a uniform remote tensile stress $\\sigma$ normal to the crack plane. The exact Mode I stress intensity factor for this geometry is given by $K_I = \\sigma \\sqrt{\\pi a}$. You must verify that a contour integration based on the path-independent definition of $J$ around the crack tip, applied to the leading-order near-tip displacement field for Mode I loading, reproduces the energy release rate and is path independent. Then, using appropriate constitutive relations, transform the numerically obtained $J$ to a numerical estimate of $K$ and compare it to the exact $K_I$ above.\n\nYour program must implement the following steps and checks:\n1. Starting from the definitions of strain, stress, and strain energy density, and the path-independent integral for $J$ around a closed contour encircling the crack tip, assemble a numerical contour integral for $J$ over a circular path of radius $R$ centered at the crack tip. The integral must be expressed in terms of the strain energy density $W$, the Cauchy stress tensor $\\boldsymbol{\\sigma}$, the displacement gradient $\\partial u_i / \\partial x_1$, and the outward unit normal $\\boldsymbol{n}$ along the contour.\n2. Use the leading-order asymptotic displacement field for a Mode I crack tip in an isotropic linear elastic solid under small strain to provide the required displacement gradients and, by linear elasticity, the stresses and strain energy density. Explicitly implement the required plane stress and plane strain constitutive relationships.\n3. Numerically approximate the line integral for $J$ using uniform angular sampling over $\\theta \\in [0, 2\\pi)$ on the circular path. Demonstrate path independence by using two distinct radii $R_1$ and $R_2$ with $R_1 \\neq R_2$.\n4. For each configuration, transform the computed $J$ to a numerical estimate of $K$ using standard linear elastic relationships between $J$ and $K$ that you must derive from the fundamentals you are allowed to use. Then compare the numerically obtained $K$ to the exact $K_I$ given above.\n5. Prescribe and enforce convergence criteria with respect to angular sampling resolution and path independence. Specifically, for $N \\in \\{64, 128, 256, 512\\}$ angular points, require:\n   - The relative error in $J$ with respect to the exact $J$ decreases monotonically as $N$ increases.\n   - The final relative error at $N=512$ satisfies a tolerance $|J_{\\text{num}} - J_{\\text{exact}}|/J_{\\text{exact}} \\leq 10^{-3}$.\n   - The reconstructed $K$ from $J$ at $N=512$ satisfies $|K_{\\text{num}} - K_I|/K_I \\leq 10^{-3}$.\n   - The path independence at $N=512$ measured by $|J(R_1) - J(R_2)|/J_{\\text{exact}} \\leq 10^{-3}$ for $R_1 = 0.01 a$ and $R_2 = 0.03 a$.\n\nImplement the benchmark as a single program that evaluates the following test suite of independent cases, each specified by $(\\sigma, a, E, \\nu, \\text{plane})$ with $\\text{plane} \\in \\{\\text{plane\\_strain}, \\text{plane\\_stress}\\}$:\n- Case 1 (happy path, stiff material, moderate crack): $(\\sigma = 50 \\times 10^{6}\\ \\text{Pa},\\ a = 0.05\\ \\text{m},\\ E = 210 \\times 10^{9}\\ \\text{Pa},\\ \\nu = 0.30,\\ \\text{plane\\_strain})$.\n- Case 2 (softer material, larger crack, plane stress): $(\\sigma = 12 \\times 10^{6}\\ \\text{Pa},\\ a = 0.5\\ \\text{m},\\ E = 30 \\times 10^{9}\\ \\text{Pa},\\ \\nu = 0.25,\\ \\text{plane\\_stress})$.\n- Case 3 (small crack, high $E$): $(\\sigma = 3 \\times 10^{6}\\ \\text{Pa},\\ a = 0.005\\ \\text{m},\\ E = 70 \\times 10^{9}\\ \\text{Pa},\\ \\nu = 0.33,\\ \\text{plane\\_strain})$.\n- Case 4 (higher stress, larger crack, plane stress): $(\\sigma = 80 \\times 10^{6}\\ \\text{Pa},\\ a = 0.2\\ \\text{m},\\ E = 100 \\times 10^{9}\\ \\text{Pa},\\ \\nu = 0.20,\\ \\text{plane\\_stress})$.\n\nFor each case, compute the exact $K_I = \\sigma \\sqrt{\\pi a}$ and the exact $J$ based on linear elasticity, and then run the numerical contour integration for $J$ with $R_1 = 0.01 a$ and $R_2 = 0.03 a$ and $N \\in \\{64, 128, 256, 512\\}$. For each case, report a boolean indicating whether all four criteria listed above are satisfied.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, \"[True,False,True,True]\". Each entry corresponds to one test case in the same order as listed above. Angles must be in radians. All physical inputs must be in SI units as specified, and any intermediate or final energetic quantities must be in $\\text{N/m}$.", "solution": "We start from linear elasticity and the definition of the path-independent $J$-integral. Let $\\boldsymbol{u}$ denote the displacement vector, $\\boldsymbol{\\varepsilon}$ the small-strain tensor with components $\\varepsilon_{ij} = \\tfrac{1}{2}(\\partial u_i/\\partial x_j + \\partial u_j/\\partial x_i)$, and $\\boldsymbol{\\sigma}$ the Cauchy stress tensor related to $\\boldsymbol{\\varepsilon}$ via linear isotropic constitutive laws. The strain energy density is defined as $W = \\tfrac{1}{2} \\sigma_{ij} \\varepsilon_{ij}$. For a crack lying along the $x$-axis with the tip at the origin and crack extension direction along $x_1 \\equiv x$, the path-independent integral is\n$$\nJ = \\int_{\\Gamma} \\left( W n_1 - \\sigma_{ij} n_j \\frac{\\partial u_i}{\\partial x_1} \\right) \\,\\mathrm{d}s,\n$$\nwhere $\\Gamma$ is any counterclockwise contour around the crack tip, $\\boldsymbol{n}$ is the outward unit normal, and $\\mathrm{d}s$ is the line element along $\\Gamma$.\n\nFor a circular contour of radius $R$ centered at the crack tip, parameterized by the polar angle $\\theta \\in [0,2\\pi)$, the outward normal is $\\boldsymbol{n} = \\boldsymbol{e}_r = (\\cos\\theta,\\sin\\theta)$, and $\\mathrm{d}s = R\\,\\mathrm{d}\\theta$. The integrand is evaluated from local near-tip fields.\n\nFor the leading-order asymptotic Mode I crack-tip field in an isotropic linear elastic material under small strain, the displacements in polar coordinates $(r,\\theta)$ are well known from the Williams expansion. Introducing the shear modulus $ \\mu = E/(2(1+\\nu))$ and the parameter $\\kappa$ defined by\n$$\n\\kappa = \n\\begin{cases}\n3 - 4\\nu, & \\text{plane strain},\\\\\n\\dfrac{3 - \\nu}{1 + \\nu}, & \\text{plane stress},\n\\end{cases}\n$$\nthe radial and circumferential displacements are given by\n$$\nu_r(r,\\theta) = \\frac{K}{2\\mu}\\sqrt{\\frac{r}{2\\pi}} \\cos\\left(\\frac{\\theta}{2}\\right) \\left( \\kappa - \\cos\\theta \\right),\n\\qquad\nu_\\theta(r,\\theta) = \\frac{K}{2\\mu}\\sqrt{\\frac{r}{2\\pi}} \\sin\\left(\\frac{\\theta}{2}\\right) \\left( \\kappa - 2 + \\cos\\theta \\right).\n$$\nThese provide the near-tip field up to $O\\!\\left(r^{3/2}\\right)$ corrections. The Cartesian displacements are obtained by the rotation\n$$\nu_x = u_r \\cos\\theta - u_\\theta \\sin\\theta, \\qquad u_y = u_r \\sin\\theta + u_\\theta \\cos\\theta.\n$$\nTo evaluate the $J$-integral, we need the displacement gradients $\\partial u_i/\\partial x_j$, which we obtain by the chain rule in polar coordinates. For any scalar field $f(r,\\theta)$,\n$$\n\\frac{\\partial f}{\\partial x} = \\cos\\theta \\frac{\\partial f}{\\partial r} - \\frac{\\sin\\theta}{r}\\frac{\\partial f}{\\partial \\theta}, \n\\qquad\n\\frac{\\partial f}{\\partial y} = \\sin\\theta \\frac{\\partial f}{\\partial r} + \\frac{\\cos\\theta}{r}\\frac{\\partial f}{\\partial \\theta}.\n$$\nWe first compute $\\partial u_r/\\partial r$, $\\partial u_r/\\partial \\theta$, $\\partial u_\\theta/\\partial r$, and $\\partial u_\\theta/\\partial \\theta$. Introducing $A(r) = \\dfrac{K}{2\\mu}\\sqrt{\\dfrac{r}{2\\pi}}$, we have $\\dfrac{\\mathrm{d}A}{\\mathrm{d}r} = \\dfrac{A}{2r}$. Thus,\n$$\n\\frac{\\partial u_r}{\\partial r} = \\frac{A}{2r} \\cos\\left(\\frac{\\theta}{2}\\right)\\left(\\kappa - \\cos\\theta\\right),\n$$\n$$\n\\frac{\\partial u_r}{\\partial \\theta} = A\\left[ -\\frac{1}{2}\\sin\\left(\\frac{\\theta}{2}\\right)\\left(\\kappa - \\cos\\theta\\right) + \\cos\\left(\\frac{\\theta}{2}\\right)\\sin\\theta \\right],\n$$\n$$\n\\frac{\\partial u_\\theta}{\\partial r} = \\frac{A}{2r} \\sin\\left(\\frac{\\theta}{2}\\right)\\left(\\kappa - 2 + \\cos\\theta\\right),\n$$\n$$\n\\frac{\\partial u_\\theta}{\\partial \\theta} = A\\left[ \\frac{1}{2}\\cos\\left(\\frac{\\theta}{2}\\right)\\left(\\kappa - 2 + \\cos\\theta\\right) - \\sin\\left(\\frac{\\theta}{2}\\right)\\sin\\theta \\right].\n$$\nWe then obtain $\\dfrac{\\partial u_x}{\\partial r}$, $\\dfrac{\\partial u_x}{\\partial \\theta}$, $\\dfrac{\\partial u_y}{\\partial r}$, and $\\dfrac{\\partial u_y}{\\partial \\theta}$ by direct differentiation of $u_x$ and $u_y$:\n$$\n\\frac{\\partial u_x}{\\partial r} = \\frac{\\partial u_r}{\\partial r}\\cos\\theta - \\frac{\\partial u_\\theta}{\\partial r}\\sin\\theta,\n$$\n$$\n\\frac{\\partial u_x}{\\partial \\theta} = \\frac{\\partial u_r}{\\partial \\theta}\\cos\\theta - u_r \\sin\\theta - \\frac{\\partial u_\\theta}{\\partial \\theta}\\sin\\theta - u_\\theta \\cos\\theta,\n$$\n$$\n\\frac{\\partial u_y}{\\partial r} = \\frac{\\partial u_r}{\\partial r}\\sin\\theta + \\frac{\\partial u_\\theta}{\\partial r}\\cos\\theta,\n$$\n$$\n\\frac{\\partial u_y}{\\partial \\theta} = \\frac{\\partial u_r}{\\partial \\theta}\\sin\\theta + u_r \\cos\\theta + \\frac{\\partial u_\\theta}{\\partial \\theta}\\cos\\theta - u_\\theta \\sin\\theta.\n$$\nWith these, the Cartesian gradients follow from the chain rule:\n$$\n\\frac{\\partial u_x}{\\partial x} = \\cos\\theta \\frac{\\partial u_x}{\\partial r} - \\frac{\\sin\\theta}{r}\\frac{\\partial u_x}{\\partial \\theta}, \\qquad\n\\frac{\\partial u_x}{\\partial y} = \\sin\\theta \\frac{\\partial u_x}{\\partial r} + \\frac{\\cos\\theta}{r}\\frac{\\partial u_x}{\\partial \\theta},\n$$\n$$\n\\frac{\\partial u_y}{\\partial x} = \\cos\\theta \\frac{\\partial u_y}{\\partial r} - \\frac{\\sin\\theta}{r}\\frac{\\partial u_y}{\\partial \\theta}, \\qquad\n\\frac{\\partial u_y}{\\partial y} = \\sin\\theta \\frac{\\partial u_y}{\\partial r} + \\frac{\\cos\\theta}{r}\\frac{\\partial u_y}{\\partial \\theta}.\n$$\nThe small strains are then\n$$\n\\varepsilon_{xx} = \\frac{\\partial u_x}{\\partial x}, \\qquad \\varepsilon_{yy} = \\frac{\\partial u_y}{\\partial y}, \\qquad \\varepsilon_{xy} = \\frac{1}{2}\\left( \\frac{\\partial u_x}{\\partial y} + \\frac{\\partial u_y}{\\partial x} \\right).\n$$\nThe stresses depend on the plane condition. For plane stress,\n$$\n\\sigma_{xx} = \\frac{E}{1-\\nu^2}\\left(\\varepsilon_{xx} + \\nu \\varepsilon_{yy}\\right), \\quad\n\\sigma_{yy} = \\frac{E}{1-\\nu^2}\\left(\\varepsilon_{yy} + \\nu \\varepsilon_{xx}\\right), \\quad\n\\sigma_{xy} = 2\\mu \\varepsilon_{xy}.\n$$\nFor plane strain, defining $\\lambda = \\dfrac{E\\nu}{(1+\\nu)(1-2\\nu)}$ and $\\mu = \\dfrac{E}{2(1+\\nu)}$,\n$$\n\\sigma_{xx} = 2\\mu \\varepsilon_{xx} + \\lambda (\\varepsilon_{xx} + \\varepsilon_{yy}), \\quad\n\\sigma_{yy} = 2\\mu \\varepsilon_{yy} + \\lambda (\\varepsilon_{xx} + \\varepsilon_{yy}), \\quad\n\\sigma_{xy} = 2\\mu \\varepsilon_{xy}.\n$$\nThe strain energy density is $W = \\tfrac{1}{2}(\\sigma_{xx}\\varepsilon_{xx} + \\sigma_{yy}\\varepsilon_{yy} + 2\\sigma_{xy}\\varepsilon_{xy})$. Along the circular contour, the outward unit normal is $\\boldsymbol{n} = (\\cos\\theta, \\sin\\theta)$. The line integral for $J$ reduces to\n$$\nJ = \\int_{0}^{2\\pi} \\left[ W n_x - \\sigma_{xj} n_j \\frac{\\partial u_x}{\\partial x} - \\sigma_{yj} n_j \\frac{\\partial u_y}{\\partial x} \\right] R \\,\\mathrm{d}\\theta,\n$$\nwith $n_x = \\cos\\theta$, $n_y = \\sin\\theta$, and $j \\in \\{x,y\\}$. The tensor contractions are $\\sigma_{xj} n_j = \\sigma_{xx} n_x + \\sigma_{xy} n_y$ and $\\sigma_{yj} n_j = \\sigma_{xy} n_x + \\sigma_{yy} n_y$. This integral is evaluated numerically using uniform angular sampling, with the composite rectangle or trapezoidal rule over $\\theta \\in [0,2\\pi)$.\n\nTo compare to the exact benchmark for a center-cracked plate in uniform tension, the exact Mode I stress intensity factor is\n$$\nK_I = \\sigma \\sqrt{\\pi a}.\n$$\nIn linear elasticity, the energy release rate equals the $J$-integral, and for isotropic materials there is a classical equivalence between $J$ and $K$ derived from the asymptotic fields and constitutive relations:\n$$\nJ = \\frac{K^2}{E'},\n$$\nwhere\n$$\nE' = \n\\begin{cases}\nE, & \\text{plane stress},\\\\\n\\dfrac{E}{1-\\nu^2}, & \\text{plane strain}.\n\\end{cases}\n$$\nThis relation follows from equating the elastic energy flow through a contour encircling the crack tip, obtained from the asymptotic displacement and stress fields, with the surface traction and displacement gradient work terms in the $J$-integral, and then using the constitutive law to express the energy density in terms of $K$. Therefore, the exact $J$ for the benchmark is\n$$\nJ_{\\text{exact}} = \\frac{K_I^2}{E'} = \\frac{\\sigma^2 \\pi a}{E'}.\n$$\nThe numerical algorithm is as follows. For each test case:\n1. Compute $K_I = \\sigma \\sqrt{\\pi a}$ and $E'$ based on the plane condition. Set $J_{\\text{exact}} = K_I^2 / E'$.\n2. For $N \\in \\{64, 128, 256, 512\\}$ and $R \\in \\{0.01 a, 0.03 a\\}$, evaluate the near-tip displacements $(u_r, u_\\theta)$ at radius $R$ for $K = K_I$ and the given $(E,\\nu,\\text{plane})$. Compute the displacement gradients, strains, stresses, and $W$, then assemble the integrand and approximate the integral for $J$ over $\\theta \\in [0,2\\pi)$.\n3. For each $N$, compute the relative error $|J_{\\text{num}}(R_1,N) - J_{\\text{exact}}| / J_{\\text{exact}}$, and check that it is monotonically non-increasing with increasing $N$.\n4. At $N=512$, verify that the absolute relative error in $J$ at $R_1$ is at most $10^{-3}$ and that the path independence criterion $|J(R_1) - J(R_2)|/J_{\\text{exact}} \\le 10^{-3}$ holds. Also compute $K_{\\text{num}} = \\sqrt{E' J_{\\text{num}}(R_1)}$ and verify $|K_{\\text{num}} - K_I| / K_I \\le 10^{-3}$.\n5. The case passes if and only if all criteria are met.\n\nTest suite and output. The program must evaluate:\n- Case 1: $(\\sigma = 50 \\times 10^{6}\\ \\text{Pa},\\ a = 0.05\\ \\text{m},\\ E = 210 \\times 10^{9}\\ \\text{Pa},\\ \\nu = 0.30,\\ \\text{plane\\_strain})$.\n- Case 2: $(\\sigma = 12 \\times 10^{6}\\ \\text{Pa},\\ a = 0.5\\ \\text{m},\\ E = 30 \\times 10^{9}\\ \\text{Pa},\\ \\nu = 0.25,\\ \\text{plane\\_stress})$.\n- Case 3: $(\\sigma = 3 \\times 10^{6}\\ \\text{Pa},\\ a = 0.005\\ \\text{m},\\ E = 70 \\times 10^{9}\\ \\text{Pa},\\ \\nu = 0.33,\\ \\text{plane\\_strain})$.\n- Case 4: $(\\sigma = 80 \\times 10^{6}\\ \\text{Pa},\\ a = 0.2\\ \\text{m},\\ E = 100 \\times 10^{9}\\ \\text{Pa},\\ \\nu = 0.20,\\ \\text{plane\\_stress})$.\n\nFor each case, output a boolean indicating whether all criteria are satisfied. The final program output must be a single line containing these booleans in a list, e.g., \"[True,False,True,True]\".", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef j_integral_mode_I(K, E, nu, plane, R, N):\n    \"\"\"\n    Compute the J-integral for Mode I using near-tip asymptotic fields\n    along a circular contour of radius R with N angular points.\n\n    Inputs:\n        K: Mode I stress intensity factor (Pa * sqrt(m))\n        E: Young's modulus (Pa)\n        nu: Poisson's ratio (-)\n        plane: 'plane_strain' or 'plane_stress'\n        R: contour radius (m)\n        N: number of angular points\n\n    Returns:\n        J: computed J-integral (N/m)\n    \"\"\"\n    # Material parameters\n    mu = E / (2.0 * (1.0 + nu))\n    if plane == 'plane_strain':\n        kappa = 3.0 - 4.0 * nu\n        lam = E * nu / ((1.0 + nu) * (1.0 - 2.0 * nu))\n        Eprime = E / (1.0 - nu**2)\n    elif plane == 'plane_stress':\n        kappa = (3.0 - nu) / (1.0 + nu)\n        lam = 0.0  # Not used in plane stress stiffness directly\n        Eprime = E\n    else:\n        raise ValueError(\"Unknown plane condition\")\n\n    # Angular sampling\n    theta = 2.0 * np.pi * np.arange(N) / N\n    c = np.cos(theta)\n    s = np.sin(theta)\n    c2 = np.cos(theta / 2.0)\n    s2 = np.sin(theta / 2.0)\n\n    # Near-tip displacement amplitude\n    A = (K / (2.0 * mu)) * np.sqrt(R / (2.0 * np.pi))  # scalar\n\n    # u_r and u_theta\n    ur = A * c2 * (kappa - np.cos(theta))\n    ut = A * s2 * (kappa - 2.0 + np.cos(theta))\n\n    # Derivatives wrt r\n    ur_r = (A / (2.0 * R)) * c2 * (kappa - np.cos(theta))\n    ut_r = (A / (2.0 * R)) * s2 * (kappa - 2.0 + np.cos(theta))\n\n    # Derivatives wrt theta\n    ur_t = A * (-0.5 * s2 * (kappa - np.cos(theta)) + c2 * np.sin(theta))\n    ut_t = A * (0.5 * c2 * (kappa - 2.0 + np.cos(theta)) - s2 * np.sin(theta))\n\n    # Convert to Cartesian components u_x, u_y\n    ux = ur * c - ut * s\n    uy = ur * s + ut * c\n\n    # Derivatives of u_x and u_y wrt r\n    ux_r = ur_r * c - ut_r * s\n    uy_r = ur_r * s + ut_r * c\n\n    # Derivatives wrt theta\n    ux_t = ur_t * c - ur * s - ut_t * s - ut * c\n    uy_t = ur_t * s + ur * c + ut_t * c - ut * s\n\n    # Chain rule to get Cartesian gradients\n    # du/dx = cos(theta)*du/dr - (sin(theta)/r)*du/dtheta\n    # du/dy = sin(theta)*du/dr + (cos(theta)/r)*du/dtheta\n    invR = 1.0 / R\n    ux_x = c * ux_r - s * invR * ux_t\n    ux_y = s * ux_r + c * invR * ux_t\n    uy_x = c * uy_r - s * invR * uy_t\n    uy_y = s * uy_r + c * invR * uy_t\n\n    # Small strains\n    exx = ux_x\n    eyy = uy_y\n    exy = 0.5 * (ux_y + uy_x)\n\n    # Stresses\n    if plane == 'plane_stress':\n        cE = E / (1.0 - nu**2)\n        sxx = cE * (exx + nu * eyy)\n        syy = cE * (eyy + nu * exx)\n        sxy = 2.0 * mu * exy\n    else:  # plane strain\n        tr = exx + eyy\n        sxx = 2.0 * mu * exx + lam * tr\n        syy = 2.0 * mu * eyy + lam * tr\n        sxy = 2.0 * mu * exy\n\n    # Strain energy density\n    W = 0.5 * (sxx * exx + syy * eyy + 2.0 * sxy * exy)\n\n    # Normal vector on the circle\n    nx = c\n    ny = s\n\n    # Contractions with normal\n    sig_xn = sxx * nx + sxy * ny\n    sig_yn = sxy * nx + syy * ny\n\n    # J-integrand: f(theta) = W * n_x - sigma_ij n_j * du_i/dx\n    # where i in {x,y} and du_i/dx = {ux_x, uy_x}\n    integrand = W * nx - (sig_xn * ux_x + sig_yn * uy_x)\n\n    # Numerical integration over theta\n    dtheta = 2.0 * np.pi / N\n    J = np.sum(integrand) * R * dtheta\n    return J\n\ndef run_case(sigma, a, E, nu, plane):\n    # Exact K_I and J_exact\n    KI = sigma * np.sqrt(np.pi * a)\n    Eprime = E / (1.0 - nu**2) if plane == 'plane_strain' else E\n    J_exact = KI**2 / Eprime\n\n    # Radii and angular resolutions\n    R1 = 0.01 * a\n    R2 = 0.03 * a\n    N_list = [64, 128, 256, 512]\n\n    # Compute J over N_list at R1 and path independence at final N\n    J_errors = []\n    prev_err = None\n    monotonic = True\n    for N in N_list:\n        JN = j_integral_mode_I(KI, E, nu, plane, R1, N)\n        err = abs(JN - J_exact) / J_exact\n        J_errors.append(err)\n        if prev_err is not None and err > prev_err + 1e-14:\n            monotonic = False\n        prev_err = err\n\n    # Final resolution checks at N=512\n    N_final = N_list[-1]\n    J_R1 = j_integral_mode_I(KI, E, nu, plane, R1, N_final)\n    J_R2 = j_integral_mode_I(KI, E, nu, plane, R2, N_final)\n    rel_err_J_final = abs(J_R1 - J_exact) / J_exact\n    path_rel = abs(J_R1 - J_R2) / J_exact\n\n    # Recovered K from J\n    K_num = np.sqrt(Eprime * J_R1)\n    rel_err_K = abs(K_num - KI) / KI\n\n    # Tolerances\n    tol_J = 1e-3\n    tol_path = 1e-3\n    tol_K = 1e-3\n\n    all_good = (monotonic and (rel_err_J_final = tol_J) and (path_rel = tol_path) and (rel_err_K = tol_K))\n    return all_good\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (sigma [Pa], a [m], E [Pa], nu [-], plane)\n    test_cases = [\n        (50e6, 0.05, 210e9, 0.30, 'plane_strain'),\n        (12e6, 0.5, 30e9, 0.25, 'plane_stress'),\n        (3e6, 0.005, 70e9, 0.33, 'plane_strain'),\n        (80e6, 0.2, 100e9, 0.20, 'plane_stress'),\n    ]\n\n    results = []\n    for case in test_cases:\n        sigma, a, E, nu, plane = case\n        result = run_case(sigma, a, E, nu, plane)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Convert booleans to 'True'/'False' strings automatically by map(str, ...)\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3526090"}, {"introduction": "Numerical models are approximations of reality, and understanding their sources of error is paramount for reliable analysis. This final practice delves into the heart of numerical error in fracture mechanics: the challenge of approximating a singular field with smooth polynomials. Through a controlled numerical experiment, you will investigate how finite element interpolation order affects the accuracy of the stress intensity factor and learn to implement practical error estimators to assess the quality of your computational results [@problem_id:3526101].", "problem": "You are asked to investigate, in a mathematically controlled setting, how the interpolation order of a finite element method affects the accuracy of a Stress Intensity Factor (SIF) estimate computed by displacement extrapolation at a crack tip. Work within the framework of Linear Elastic Fracture Mechanics (LEFM) and use the near-tip asymptotics as the fundamental base. In order to isolate the interpolation effect, use the following dimensionless surrogate for the near-tip displacement along the crack line direction (angle equal to zero): a scalar field defined by $$u(r) = K \\sqrt{r},$$ where $$r \\ge 0$$ is the radial distance from the crack tip and $$K  0$$ is the true dimensionless Stress Intensity Factor (SIF). This surrogate captures the square-root singular scaling that underlies LEFM asymptotics near a crack tip and permits controlled numerical experiments.\n\nTo emulate the near-tip finite element interpolation over the first element adjacent to the crack tip (element length $$h  0$$), approximate $$u(r)$$ on the interval $$[0,h]$$ using an isoparametric polynomial interpolation of degree $$p \\in \\{1,2,3,\\dots\\}$$ with $$p+1$$ equidistant nodes at locations $$r_i = i \\, h/p$$ for $$i = 0,1,\\dots,p$$, and standard Lagrange basis polynomials. Denote the resulting interpolant by $$u_h^{(p)}(r)$$. Your program must construct $$u_h^{(p)}(r)$$ by performing Lagrange interpolation of the exact nodal values $$u(r_i)$$.\n\nDefine two displacement-extrapolation SIF estimators that use only $$u_h^{(p)}(r)$$:\n\n- Single-point estimator: for a fixed fraction $$\\beta \\in (0,1)$$, define $$\\widehat{K}_{\\mathrm{sp}}^{(p)}(h) := \\dfrac{u_h^{(p)}(\\beta h)}{\\sqrt{\\beta h}}.$$\n\n- Least-squares estimator: for a fixed number $$m \\ge 3$$ of interior sampling points $$r_j \\in (0,h)$$, find $$a \\in \\mathbb{R}$$ that minimizes $$\\sum_{j=1}^{m} \\left(u_h^{(p)}(r_j) - a \\sqrt{r_j}\\right)^2,$$ and set $$\\widehat{K}_{\\mathrm{ls}}^{(p)}(h) := a.$$\n\nFor the least-squares estimator, note that because the fitting function is linear in $$a$$, the minimizer is explicitly $$a = \\dfrac{\\sum_{j=1}^{m} \\sqrt{r_j} \\, u_h^{(p)}(r_j)}{\\sum_{j=1}^{m} r_j}.$$\n\nYou must also propose and implement practical error estimators to assess convergence toward the true $$K$$ as $$h \\to 0$$ and/or as $$p$$ increases:\n\n1. Order-difference estimator (p-difference): for $$p \\ge 2$$ at fixed $$h$$, define $$\\eta_p(h) := \\left|\\widehat{K}_{\\mathrm{ls}}^{(p)}(h) - \\widehat{K}_{\\mathrm{ls}}^{(p-1)}(h)\\right|.$$ For $$p = 1$$, this estimator is undefined; in that case, return $$-1.0$$.\n\n2. Richardson-based estimator with observed order: assume the asymptotic form $$\\widehat{K}_{\\mathrm{ls}}^{(p)}(h) = K + C h^{q} + o(h^{q})$$ for some unknown constants $$C \\neq 0$$ and $$q  0$$ depending on $$p$$ and the regularity of the target function. For a fixed $$p$$, compute $$\\widehat{K}_{\\mathrm{ls}}^{(p)}(h), \\widehat{K}_{\\mathrm{ls}}^{(p)}(h/2), \\widehat{K}_{\\mathrm{ls}}^{(p)}(h/4)$$ and estimate the observed order $$q_{\\mathrm{obs}} := \\dfrac{\\log\\left(\\left|\\widehat{K}(h) - \\widehat{K}(h/2)\\right| / \\left|\\widehat{K}(h/2) - \\widehat{K}(h/4)\\right|\\right)}{\\log(2)}.$$ Then define the Richardson error estimate at mesh size $$h$$ as $$\\varepsilon_R(h) := \\dfrac{\\left|\\widehat{K}(h) - \\widehat{K}(h/2)\\right|}{2^{q_{\\mathrm{obs}}} - 1}.$$ If the computation of $$q_{\\mathrm{obs}}$$ is ill-conditioned (e.g., denominators are too small), set $$\\varepsilon_R(h) := 0.0.$$\n\n3. Shape-residual indicator: using the least-squares fit for $$\\widehat{K}_{\\mathrm{ls}}^{(p)}(h)$$ over the chosen $$m$$ interior points, define the normalized residual $$\\rho(h) := \\dfrac{\\sqrt{\\sum_{j=1}^{m} \\left(u_h^{(p)}(r_j) - \\widehat{K}_{\\mathrm{ls}}^{(p)}(h)\\sqrt{r_j}\\right)^2}}{\\sqrt{\\sum_{j=1}^{m} \\left(\\widehat{K}_{\\mathrm{ls}}^{(p)}(h)\\sqrt{r_j}\\right)^2}}.$$ Treat $$\\rho(h)$$ as a dimensionless indicator of deviation from the expected square-root profile.\n\nAll quantities in this problem are dimensionless, so no physical units are to be reported.\n\nYour task is to implement a program that, for each test case listed in the test suite below, constructs $$u_h^{(p)}(r)$$, computes the two SIF estimators $$\\widehat{K}_{\\mathrm{sp}}^{(p)}(h)$$ and $$\\widehat{K}_{\\mathrm{ls}}^{(p)}(h)$$, computes the three error indicators above, and returns a single line containing all results aggregated into a single list.\n\nUse the following fixed parameters for all computations:\n- True SIF: $$K = 1.8.$$\n- Single-point fraction: $$\\beta = 0.35.$$\n- Least-squares sampling: use $$m = 5$$ interior points $$r_j$$ equally spaced over $$(\\varepsilon h, (1-\\varepsilon) h)$$ with $$\\varepsilon = 0.13$$.\n\nFor each test case, output a list with the following five floats in this order:\n- The relative error of the single-point estimator $$\\left|\\widehat{K}_{\\mathrm{sp}}^{(p)}(h) - K\\right|/K.$$\n- The relative error of the least-squares estimator $$\\left|\\widehat{K}_{\\mathrm{ls}}^{(p)}(h) - K\\right|/K.$$\n- The relative p-difference estimator normalized by $$\\left|\\widehat{K}_{\\mathrm{ls}}^{(p)}(h)\\right|$$, i.e., $$\\eta_p(h) / \\left|\\widehat{K}_{\\mathrm{ls}}^{(p)}(h)\\right|,$$ or $$-1.0$$ if $$p=1$$.\n- The Richardson-based relative error estimate at $$h$$, i.e., $$\\varepsilon_R(h) / \\left|\\widehat{K}_{\\mathrm{ls}}^{(p)}(h)\\right|.$$\n- The shape-residual indicator $$\\rho(h).$$\n\nTest suite:\n- Case $$1$$: $$p = 1, \\, h = 1.0.$$\n- Case $$2$$: $$p = 2, \\, h = 1.0.$$\n- Case $$3$$: $$p = 3, \\, h = 0.5.$$\n- Case $$4$$: $$p = 3, \\, h = 0.125.$$\n- Case $$5$$: $$p = 2, \\, h = 0.05.$$\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the list of five floats for one test case in the given order. For example, the output must look like $$\\left[[a_1,a_2,a_3,a_4,a_5],[b_1,b_2,b_3,b_4,b_5],\\dots\\right]$$ with no additional text or lines.", "solution": "The user has provided a computational problem in the domain of linear elastic fracture mechanics (LEFM). I will first validate the problem statement and then provide a detailed solution.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n-   **Surrogate Field**: $$u(r) = K \\sqrt{r}$$, for $$r \\ge 0$$.\n-   **True SIF**: $$K = 1.8$$ (dimensionless).\n-   **FEM Approximation**: Lagrange interpolating polynomial $$u_h^{(p)}(r)$$ of degree $$p$$ on $$[0, h]$$ using $$p+1$$ equidistant nodes $$r_i = i h/p$$.\n-   **Single-Point SIF Estimator**: $$\\widehat{K}_{\\mathrm{sp}}^{(p)}(h) = u_h^{(p)}(\\beta h) / \\sqrt{\\beta h}$$, with $$\\beta = 0.35$$.\n-   **Least-Squares SIF Estimator**: $$\\widehat{K}_{\\mathrm{ls}}^{(p)}(h) = a$$, where $$a$$ minimizes $$\\sum_{j=1}^{m} (u_h^{(p)}(r_j) - a \\sqrt{r_j})^2$$. The sampling points $$r_j$$ ($$m=5$$) are equally spaced over $$(\\varepsilon h, (1-\\varepsilon) h)$$ with $$\\varepsilon = 0.13$$. The explicit solution for $$a$$ is given: $$a = (\\sum_{j=1}^{m} \\sqrt{r_j} u_h^{(p)}(r_j)) / (\\sum_{j=1}^{m} r_j)$$.\n-   **p-Difference Estimator**: $$\\eta_p(h) = |\\widehat{K}_{\\mathrm{ls}}^{(p)}(h) - \\widehat{K}_{\\mathrm{ls}}^{(p-1)}(h)|$$ for $$p \\ge 2$$. For $$p=1$$, the output is $$-1.0$$.\n-   **Richardson-Based Error Estimator**:\n    -   Requires computation of $$\\widehat{K}_{\\mathrm{ls}}^{(p)}$$ at $$h$$, $$h/2$$, and $$h/4$$.\n    -   Observed order: $$q_{\\mathrm{obs}} = \\log(|\\widehat{K}(h) - \\widehat{K}(h/2)| / |\\widehat{K}(h/2) - \\widehat{K}(h/4)|) / \\log(2)$$.\n    -   Error estimate: $$\\varepsilon_R(h) = |\\widehat{K}(h) - \\widehat{K}(h/2)| / (2^{q_{\\mathrm{obs}}} - 1)$$.\n    -   A fallback value of $$\\varepsilon_R(h) = 0.0$$ is specified for ill-conditioned cases.\n-   **Shape-Residual Indicator**: $$\\rho(h) = \\sqrt{\\sum_{j=1}^{m} (u_h^{(p)}(r_j) - \\widehat{K}_{\\mathrm{ls}}^{(p)}(h)\\sqrt{r_j})^2} / \\sqrt{\\sum_{j=1}^{m} (\\widehat{K}_{\\mathrm{ls}}^{(p)}(h)\\sqrt{r_j})^2}$$.\n-   **Test Cases**: $$(p,h)$$ pairs: $$(1, 1.0), (2, 1.0), (3, 0.5), (3, 0.125), (2, 0.05)$$.\n-   **Output Format**: For each case, a list of 5 floats: $$[|\\widehat{K}_{\\mathrm{sp}}/K-1|, |\\widehat{K}_{\\mathrm{ls}}/K-1|, \\eta_p/|\\widehat{K}_{\\mathrm{ls}}|, \\varepsilon_R/|\\widehat{K}_{\\mathrm{ls}}|, \\rho]$$.\n\n**Step 2: Validate Using Extracted Givens**\n\n-   **Scientifically Grounded**: The problem is a well-conceived numerical experiment in computational fracture mechanics. It correctly uses the $$\\sqrt{r}$$ singularity from LEFM, standard FEM interpolation concepts (Lagrange polynomials), and established techniques for SIF extraction (displacement extrapolation) and error estimation (p-difference, Richardson extrapolation, residuals). The problem is scientifically sound.\n-   **Well-Posed**: All parameters and functions are explicitly defined. The methods for calculating the estimators are unambiguous. The existence and uniqueness of the Lagrange interpolant and the least-squares minimizer are guaranteed under the given conditions. Potential divisions by zero are either naturally avoided (e.g., denominators in least-squares and single-point formulas are positive for $$h0$$) or have prescribed handling (e.g., ill-conditioning in Richardson estimator).\n-   **Objective**: The problem is stated in precise mathematical terms, free from subjectivity or ambiguity.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. It is self-contained, scientifically grounded, and well-posed. I will proceed with formulating and implementing the solution.\n\n### Solution Design\n\nThe solution involves implementing a series of numerical calculations for each specified test case. The overall design will be a Python script that iterates through the test cases and, for each, computes the five required quantities.\n\n**1. Lagrange Interpolation**\nFor a given polynomial degree $$p$$ and element size $$h$$, the interpolant $$u_h^{(p)}(r)$$ is constructed. This requires:\n-   Defining the $$p+1$$ equidistant interpolation nodes $$r_i = i \\cdot h/p$$ for $$i = 0, \\dots, p$$.\n-   Calculating the exact displacement values at these nodes: $$y_i = u(r_i) = K \\sqrt{r_i}$$.\n-   Using these nodes and values to build an interpolating function. The `scipy.interpolate.BarycentricInterpolator` is an efficient and numerically stable choice for this task. It will be used to evaluate $$u_h^{(p)}(r)$$ at any point $$r \\in [0, h]$$.\n\n**2. SIF Estimators**\n-   **Single-Point Estimator** $$\\widehat{K}_{\\mathrm{sp}}^{(p)}(h)$$: This is calculated by evaluating the interpolant $$u_h^{(p)}(r)$$ at $$r = \\beta h$$ and applying the formula $$\\widehat{K}_{\\mathrm{sp}}^{(p)}(h) = u_h^{(p)}(\\beta h) / \\sqrt{\\beta h}$$.\n-   **Least-Squares Estimator** $$\\widehat{K}_{\\mathrm{ls}}^{(p)}(h)$$: This requires defining the $$m=5$$ sampling points $$r_j$$ equally spaced in $$[\\varepsilon h, (1-\\varepsilon)h]$$. The interpolant $$u_h^{(p)}(r)$$ is evaluated at these points. The estimator $$\\widehat{K}_{\\mathrm{ls}}^{(p)}(h)$$ is then computed using the provided explicit formula derived from the least-squares principle.\n\n**3. Error and Residual Indicators**\nThe computation of these indicators involves dependencies on calculations for other $$(p, h)$$ pairs. To manage this efficiently, a caching mechanism (a dictionary or memoization) will be used to store and retrieve previously computed values of $$\\widehat{K}_{\\mathrm{ls}}^{(p)}(h)$$, avoiding redundant work.\n\n-   **p-Difference Estimator** $$\\eta_p(h)$$: For a test case with $$p  1$$, this requires both $$\\widehat{K}_{\\mathrm{ls}}^{(p)}(h)$$ and $$\\widehat{K}_{\\mathrm{ls}}^{(p-1)}(h)$$. The latter will be computed on demand (if not already cached). For $$p=1$$, the specified value of $$-1.0$$ is returned. The result is then normalized by $$|\\widehat{K}_{\\mathrm{ls}}^{(p)}(h)|$$.\n-   **Richardson-Based Estimator** $$\\varepsilon_R(h)$$: For a test case $$(p, h)$$, this requires $$\\widehat{K}_{\\mathrm{ls}}^{(p)}$$ computed at three mesh sizes: $$h, h/2, h/4$$. These values will be obtained via the cached computation function. The observed order $$q_{\\mathrm{obs}}$$ and the error estimate $$\\varepsilon_R(h)$$ are then calculated per the given formulas. A tolerance check is implemented to detect ill-conditioned denominators (near-zero values), in which case $$\\varepsilon_R(h)$$ is set to $$0.0$$ as specified. The result is normalized by $$|\\widehat{K}_{\\mathrm{ls}}^{(p)}(h)|$$.\n-   **Shape-Residual Indicator** $$\\rho(h)$$: This indicator quantifies the deviation of the interpolated displacement profile from the ideal $$\\sqrt{r}$$ shape. It is calculated using the $$u_h^{(p)}(r_j)$$ values at the sampling points and the computed $$\\widehat{K}_{\\mathrm{ls}}^{(p)}(h)$$, following the provided formula for the normalized root-mean-square residual.\n\n**4. Program Structure**\nThe main program will define the global constants ($$K, \\beta, m, \\varepsilon$$) and the test suite. It will iterate through each test case, orchestrating the calls to the computational routines described above. A central, cached function `get_k_ls(p, h)` will serve as the single point of access for all required least-squares SIF values. The final results for each test case are collected and formatted into a single string as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import BarycentricInterpolator\n\ndef solve():\n    \"\"\"\n    Solves the computational geomechanics problem by calculating SIF estimators\n    and error indicators for a set of test cases.\n    \"\"\"\n    # Define the fixed parameters from the problem statement.\n    K_TRUE = 1.8\n    BETA = 0.35\n    M_LS = 5\n    EPSILON_LS = 0.13\n    TOL = 1e-14  # Tolerance for floating point comparisons\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1, 1.0),\n        (2, 1.0),\n        (3, 0.5),\n        (3, 0.125),\n        (2, 0.05),\n    ]\n\n    # Cache to store computed K_ls values to avoid redundant calculations.\n    k_ls_cache = {}\n\n    def get_k_ls(p, h):\n        \"\"\"\n        Computes the least-squares SIF estimator K_ls for a given (p, h) pair.\n        Uses a cache to store and retrieve results.\n        \"\"\"\n        if (p, h) in k_ls_cache:\n            return k_ls_cache[(p, h)]\n\n        # 1. Construct the Lagrange interpolant u_h_p(r)\n        nodes_r = np.linspace(0, h, p + 1)\n        nodes_u = K_TRUE * np.sqrt(nodes_r)\n        \n        # BarycentricInterpolator is efficient for evaluation\n        # but needs at least one point. p=0 is not in the problem but is handled.\n        if p == 0:\n            interpolator = lambda r: np.full_like(np.asarray(r), nodes_u[0])\n        else:\n            interpolator = BarycentricInterpolator(nodes_r, nodes_u)\n        \n        # 2. Define least-squares sampling points\n        r_j = np.linspace(EPSILON_LS * h, (1 - EPSILON_LS) * h, M_LS)\n        \n        # 3. Evaluate interpolant at sampling points\n        u_vals_at_r_j = interpolator(r_j)\n        \n        # 4. Compute K_ls using the explicit formula\n        numerator = np.sum(np.sqrt(r_j) * u_vals_at_r_j)\n        denominator = np.sum(r_j)\n        \n        k_ls = numerator / denominator if denominator > TOL else 0.0\n        \n        # 5. Cache the result and return\n        k_ls_cache[(p, h)] = k_ls\n        return k_ls\n\n    results = []\n    for p, h in test_cases:\n        # A. Construct the Lagrange interpolant for the current main test case (p, h)\n        main_nodes_r = np.linspace(0, h, p + 1)\n        main_nodes_u = K_TRUE * np.sqrt(main_nodes_r)\n        if p == 0:\n            main_interpolator = lambda r: np.full_like(np.asarray(r), main_nodes_u[0])\n        else:\n            main_interpolator = BarycentricInterpolator(main_nodes_r, main_nodes_u)\n\n        # 1. Relative error of the single-point estimator\n        k_sp = 0.0\n        if BETA * h > 0:\n            u_at_beta_h = main_interpolator(BETA * h)\n            k_sp = u_at_beta_h / np.sqrt(BETA * h)\n        rel_err_k_sp = abs(k_sp - K_TRUE) / K_TRUE\n        \n        # 2. Relative error of the least-squares estimator\n        k_ls_h = get_k_ls(p, h)\n        rel_err_k_ls = abs(k_ls_h - K_TRUE) / K_TRUE\n        \n        # 3. Relative p-difference estimator, normalized\n        if p == 1:\n            eta_p_rel = -1.0\n        else:\n            k_ls_p_minus_1 = get_k_ls(p - 1, h)\n            eta_p = abs(k_ls_h - k_ls_p_minus_1)\n            eta_p_rel = eta_p / abs(k_ls_h) if abs(k_ls_h) > TOL else 0.0\n\n        # 4. Richardson-based relative error estimate, normalized\n        k_ls_h2 = get_k_ls(p, h / 2.0)\n        k_ls_h4 = get_k_ls(p, h / 4.0)\n\n        diff1 = abs(k_ls_h - k_ls_h2)\n        diff2 = abs(k_ls_h2 - k_ls_h4)\n\n        epsilon_R_rel = 0.0\n        # If denominator for q_obs is too small, Richardson is ill-conditioned\n        if diff2 > TOL:\n            ratio = diff1 / diff2\n            if ratio > 0: # log requires positive argument\n                q_obs = np.log(ratio) / np.log(2.0)\n                denom_richardson = 2**q_obs - 1\n                if abs(denom_richardson) > TOL:\n                    epsilon_R = diff1 / denom_richardson\n                    epsilon_R_rel = abs(epsilon_R) / abs(k_ls_h) if abs(k_ls_h) > TOL else 0.0\n        \n        # 5. Shape-residual indicator\n        main_r_j = np.linspace(EPSILON_LS * h, (1 - EPSILON_LS) * h, M_LS)\n        main_u_vals = main_interpolator(main_r_j)\n        \n        residuals_sq = (main_u_vals - k_ls_h * np.sqrt(main_r_j))**2\n        num_rho = np.sqrt(np.sum(residuals_sq))\n        \n        fit_vals_sq = (k_ls_h * np.sqrt(main_r_j))**2\n        den_rho = np.sqrt(np.sum(fit_vals_sq))\n        \n        rho = num_rho / den_rho if den_rho > TOL else 0.0\n        \n        results.append([rel_err_k_sp, rel_err_k_ls, eta_p_rel, epsilon_R_rel, rho])\n\n    # Final print statement in the exact required format.\n    formatted_results = []\n    for res_list in results:\n        part = f\"[{','.join(f'{val:.7g}' for val in res_list)}]\"\n        formatted_results.append(part)\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3526101"}]}