{"hands_on_practices": [{"introduction": "The core of the Extended Finite Element Method (XFEM) lies in modifying the standard element stiffness matrix to account for the kinematics of a discontinuity. This exercise provides hands-on practice with this fundamental concept by guiding you through the derivation and implementation of stiffness contributions from Heaviside-enriched degrees of freedom. Mastering this is crucial as it forms the essential building block for any XFEM simulation involving displacement jumps across cracks or interfaces. [@problem_id:3523124]", "problem": "Consider a single linear triangular finite element in two-dimensional small-strain, isotropic, linear elasticity under plane strain conditions, intersected by a straight crack represented implicitly by a level set field. Use the Heaviside enrichment with a shifted enrichment function to capture a displacement jump across the crack within the element. The crack is represented by the zero level set of a piecewise-linear scalar field that is specified by nodal values. Assume the crack is traction-free and that the Heaviside function is constant within each integration subdomain defined by the sign of the level set.\n\nYou must compute, for each test case, the element-level stiffness contributions associated solely with the enriched degrees of freedom, using subcell quadrature with two integration subdomains corresponding to the positive and negative level set regions. The result for each test case is the enriched-enriched stiffness submatrix flattened in row-major order.\n\nBase the derivation and implementation on first principles:\n- Use the Principle of Virtual Work, where the bilinear form involves the product of strain-displacement and constitutive operators integrated over the domain. Assume plane strain elasticity with thickness $t$.\n- Use standard linear triangular shape functions whose spatial gradients are constant over the element.\n- Represent the crack via a level set function $\\phi(\\mathbf{x})$ that varies linearly over the element from its nodal values. Define the Heaviside function as $H(\\phi) = +1$ for $\\phi \\ge 0$ and $H(\\phi) = -1$ for $\\phi < 0$. Adopt the convention $H(0)=+1$.\n- Use the shifted Heaviside enrichment at node $i$ given by $H(\\phi(\\mathbf{x})) - H(\\phi_i)$, where $\\phi_i$ is the nodal level set value at node $i$.\n\nIntegration requirement:\n- Partition the triangle into two integration subdomains by clipping the triangle by the straight line $\\phi(\\mathbf{x})=0$, obtained by linear interpolation of $\\phi$ along each edge. The positive subdomain is $\\{\\mathbf{x} \\mid \\phi(\\mathbf{x}) \\ge 0\\}$ and the negative subdomain is $\\{\\mathbf{x} \\mid \\phi(\\mathbf{x}) \\le 0\\}$. Perform integration over these two subdomains separately, assuming the Heaviside function is constant within each.\n- Use exact polygonal clipping based on linear interpolation along edges to find subdomain polygons and their areas. The final stiffness contributions may be expressed in terms of subdomain areas and constant strain-displacement matrices due to the linear triangle.\n\nMaterial and kinematic data:\n- Young’s modulus $E$ and Poisson’s ratio $\\nu$ define the plane strain constitutive matrix.\n- Element thickness $t$ multiplies the stiffness.\n- The element has three nodes with coordinates $(x_i,y_i)$ and nodal level set values $\\phi_i$.\n\nEnrichment and output:\n- Enrich all three element nodes with two displacement components each (horizontal and vertical) using the shifted Heaviside enrichment described above.\n- Assemble the enriched-enriched stiffness submatrix of size $6 \\times 6$ corresponding to the enriched degrees of freedom at the three nodes in the order $[u_{1x}^{\\mathrm{enr}}, u_{1y}^{\\mathrm{enr}}, u_{2x}^{\\mathrm{enr}}, u_{2y}^{\\mathrm{enr}}, u_{3x}^{\\mathrm{enr}}, u_{3y}^{\\mathrm{enr}}]$.\n\nPhysical units:\n- Use the International System of Units (SI). Input lengths are in meters, $E$ in pascals, and thickness $t$ in meters.\n- Express the stiffness entries in newtons per meter, $[\\mathrm{N/m}]$.\n\nTest suite:\nImplement your program to compute the enriched-enriched stiffness submatrix for the following three cases. In each case, use the specified nodal coordinates $(x_i,y_i)$ and level set values $\\phi_i$, with material parameters and thickness identical across the three cases.\n\n- Case 1 (happy path):\n  - Nodes: $(x_1,y_1) = (0,0)$, $(x_2,y_2) = (2,0)$, $(x_3,y_3) = (0,1)$.\n  - Level set values: $\\phi_1 = -0.2$, $\\phi_2 = +0.3$, $\\phi_3 = +0.4$.\n- Case 2 (boundary condition with a vertex on the crack):\n  - Nodes: $(x_1,y_1) = (0,0)$, $(x_2,y_2) = (1.5,0)$, $(x_3,y_3) = (0.5,1.0)$.\n  - Level set values: $\\phi_1 = 0.0$, $\\phi_2 = +0.5$, $\\phi_3 = -0.5$.\n- Case 3 (edge case with a very small cut area):\n  - Nodes: $(x_1,y_1) = (0,0)$, $(x_2,y_2) = (2,0)$, $(x_3,y_3) = (0,1)$.\n  - Level set values: $\\phi_1 = -0.001$, $\\phi_2 = +0.001$, $\\phi_3 = +0.001$.\n\nMaterial parameters and thickness for all cases:\n- Young’s modulus: $E = 30 \\times 10^{9}\\ \\mathrm{Pa}$.\n- Poisson’s ratio: $\\nu = 0.25$.\n- Thickness: $t = 1.0\\ \\mathrm{m}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of lists, where each inner list is the flattened enriched-enriched stiffness submatrix in row-major order for the corresponding test case. For example, the output format must be exactly:\n  - $[ [k_{11}, k_{12}, \\ldots, k_{16}, \\ldots, k_{66}], [\\ldots], [\\ldots] ]$\n- The entries must be floating-point numbers representing stiffness in $[\\mathrm{N/m}]$.", "solution": "The problem requires the computation of the enriched-enriched stiffness submatrix, denoted $\\mathbf{K}^{\\mathrm{bb}}$, for a single linear triangular finite element under plane strain conditions, which is intersected by a straight crack. The formulation is based on the eXtended Finite Element Method (XFEM) using a shifted Heaviside enrichment.\n\nThe stiffness matrix is derived from the Principle of Virtual Work, which states that the variation of internal work equals the variation of external work. For a linear elastic body, the internal virtual work is expressed through a bilinear form involving strains $\\boldsymbol{\\epsilon}$ and stresses $\\boldsymbol{\\sigma}$:\n$$ a(\\delta \\mathbf{u}, \\mathbf{u}) = \\int_{\\Omega^e} \\boldsymbol{\\epsilon}(\\delta \\mathbf{u})^T \\boldsymbol{\\sigma}(\\mathbf{u}) \\, d\\Omega = \\int_{\\Omega^e} \\boldsymbol{\\epsilon}(\\delta \\mathbf{u})^T \\mathbf{D} \\, \\boldsymbol{\\epsilon}(\\mathbf{u}) \\, d\\Omega $$\nwhere $\\delta \\mathbf{u}$ is the virtual displacement field, $\\mathbf{u}$ is the displacement field, $\\boldsymbol{\\epsilon}$ is the strain vector (in Voigt notation), $\\mathbf{D}$ is the material constitutive matrix, and $\\Omega^e$ is the element domain. For this problem, we must also multiply by the element thickness $t$.\n\nThe displacement field $\\mathbf{u}(\\mathbf{x})$ within the element is approximated using the XFEM framework. It comprises a standard part and an enriched part:\n$$ \\mathbf{u}(\\mathbf{x}) = \\sum_{i=1}^{3} N_i(\\mathbf{x})\\mathbf{u}_i + \\sum_{j=1}^{3} N_j(\\mathbf{x}) F_j(\\mathbf{x}) \\mathbf{b}_j $$\nHere, $N_i(\\mathbf{x})$ are the standard linear triangular shape functions, $\\mathbf{u}_i$ are the standard nodal displacement vectors, and $\\mathbf{b}_j$ are the enriched nodal displacement vectors. The enrichment function for node $j$ is the shifted Heaviside function, defined as $F_j(\\mathbf{x}) = H(\\phi(\\mathbf{x})) - H(\\phi_j)$, where $\\phi_j$ is the level set value at node $j$. The Heaviside function is given by $H(\\phi)=+1$ for $\\phi \\ge 0$ and $H(\\phi)=-1$ for $\\phi < 0$.\n\nWe are concerned only with the stiffness contributions from the enriched degrees of freedom, $\\mathbf{b}_j$. The strain field corresponding to the enriched part of the displacement, $\\mathbf{u}^{\\mathrm{b}}(\\mathbf{x}) = \\sum_{j=1}^{3} N_j(\\mathbf{x}) F_j(\\mathbf{x}) \\mathbf{b}_j$, is given by applying the differential strain-displacement operator, which in matrix form is $\\boldsymbol{\\epsilon}^{\\mathrm{b}} = \\sum_{j=1}^{3} \\mathbf{B}_j^{\\mathrm{b}} \\mathbf{b}_j$.\n\nThe problem states that integration is performed over two subdomains, $\\Omega^+ = \\{\\mathbf{x} \\in \\Omega^e \\mid \\phi(\\mathbf{x}) \\ge 0\\}$ and $\\Omega^- = \\{\\mathbf{x} \\in \\Omega^e \\mid \\phi(\\mathbf{x}) < 0\\}$, and within each subdomain, the Heaviside function $H(\\phi(\\mathbf{x}))$ is assumed to be constant. In $\\Omega^+$, $H(\\phi(\\mathbf{x}))=+1$, and in $\\Omega^-$, $H(\\phi(\\mathbf{x}))=-1$. This implies that the gradient of the enrichment function, $\\nabla F_j(\\mathbf{x})$, is zero within each subdomain. The strain-displacement matrix for the enriched part, $\\mathbf{B}_j^{\\mathrm{b}}$, is then simplified:\n$$ \\mathbf{B}_j^{\\mathrm{b}}(\\mathbf{x}) = \\nabla_s (N_j(\\mathbf{x}) F_j(\\mathbf{x})) = (\\nabla N_j) F_j(\\mathbf{x}) + N_j (\\nabla F_j) \\approx (\\nabla N_j) F_j(\\mathbf{x}) $$\nFor a linear triangle, the gradient of the shape function $\\nabla N_j$ is constant. The standard strain-displacement matrix for node $j$, $\\mathbf{B}_j$, is also constant. Therefore, $\\mathbf{B}_j^{\\mathrm{b}}(\\mathbf{x}) = \\mathbf{B}_j F_j(\\mathbf{x})$.\n\nThe $2 \\times 2$ sub-block of the enriched-enriched stiffness matrix, $\\mathbf{K}_{ij}^{\\mathrm{bb}}$, which couples the enriched DOFs of nodes $i$ and $j$, is given by:\n$$ \\mathbf{K}_{ij}^{\\mathrm{bb}} = t \\int_{\\Omega^e} (\\mathbf{B}_i^{\\mathrm{b}})^T \\mathbf{D} \\, \\mathbf{B}_j^{\\mathrm{b}} \\, d\\Omega = t \\int_{\\Omega^e} (\\mathbf{B}_i F_i(\\mathbf{x}))^T \\mathbf{D} \\, (\\mathbf{B}_j F_j(\\mathbf{x})) \\, d\\Omega $$\nSince $\\mathbf{B}_i$, $\\mathbf{B}_j$, and $\\mathbf{D}$ are constant matrices, they can be taken out of the integral:\n$$ \\mathbf{K}_{ij}^{\\mathrm{bb}} = t \\, (\\mathbf{B}_i)^T \\mathbf{D} \\, \\mathbf{B}_j \\int_{\\Omega^e} F_i(\\mathbf{x}) F_j(\\mathbf{x}) \\, d\\Omega $$\nThe integral term is evaluated by splitting the domain:\n$$ I_{ij} = \\int_{\\Omega^e} F_i(\\mathbf{x}) F_j(\\mathbf{x}) \\, d\\Omega = \\int_{\\Omega^+} F_i(\\mathbf{x})F_j(\\mathbf{x}) \\, d\\Omega + \\int_{\\Omega^-} F_i(\\mathbf{x})F_j(\\mathbf{x}) \\, d\\Omega $$\nWithin each subdomain, the enrichment functions are constant. Let $H_k = H(\\phi_k)$.\nIn $\\Omega^+$, $F_k(\\mathbf{x}) = +1 - H_k$.\nIn $\\Omega^-$, $F_k(\\mathbf{x}) = -1 - H_k$.\nLet us define coefficients $s_k^+$ and $s_k^-$:\nIf $\\phi_k \\ge 0$, then $H_k = +1$. This implies $F_k(\\mathbf{x}) = 1-1=0$ in $\\Omega^+$ and $F_k(\\mathbf{x}) = -1-1=-2$ in $\\Omega^-$. So, $s_k^+=0$ and $s_k^-=-2$.\nIf $\\phi_k < 0$, then $H_k = -1$. This implies $F_k(\\mathbf{x}) = 1-(-1)=2$ in $\\Omega^+$ and $F_k(\\mathbf{x}) = -1-(-1)=0$ in $\\Omega^-$. So, $s_k^+=2$ and $s_k^-=0$.\nThe integral becomes:\n$$ I_{ij} = s_i^+ s_j^+ \\int_{\\Omega^+} d\\Omega + s_i^- s_j^- \\int_{\\Omega^-} d\\Omega = (s_i^+ s_j^+) A^+ + (s_i^- s_j^-) A^- $$\nwhere $A^+$ and $A^-$ are the areas of the positive and negative subdomains, respectively.\n\nThe computational procedure is as follows:\n1.  For the given triangular element with nodes $(\\mathbf{x}_1, \\mathbf{x}_2, \\mathbf{x}_3)$, calculate its total area $A$ and the constant strain-displacement matrices $\\mathbf{B}_i$ for $i=1,2,3$:\n    $$ A = \\frac{1}{2} |x_1(y_2-y_3) + x_2(y_3-y_1) + x_3(y_1-y_2)| $$\n    $$ \\mathbf{B}_i = \\frac{1}{2A} \\begin{bmatrix} y_j-y_k & 0 \\\\ 0 & x_k-x_j \\\\ x_k-x_j & y_j-y_k \\end{bmatrix} \\quad \\text{for cyclic } (i,j,k) $$\n2.  Compute the plane strain constitutive matrix $\\mathbf{D}$:\n    $$ \\mathbf{D} = \\frac{E(1-\\nu)}{(1+\\nu)(1-2\\nu)} \\begin{bmatrix} 1 & \\frac{\\nu}{1-\\nu} & 0 \\\\ \\frac{\\nu}{1-\\nu} & 1 & 0 \\\\ 0 & 0 & \\frac{1-2\\nu}{2(1-\\nu)} \\end{bmatrix} $$\n3.  Determine the subdomains $\\Omega^+$ and $\\Omega^-$ by clipping the triangle with the line $\\phi(\\mathbf{x})=0$. This line is found by linear interpolation of nodal $\\phi_i$ values. The areas $A^+$ and $A^-$ are computed. If the element is not cut by the crack (i.e., all $\\phi_i$ have the same sign status), one area is $A$ and the other is $0$. If the element is cut, the line $\\phi(\\mathbf{x})=0$ intersects two edges, partitioning the triangle into a smaller triangle and a quadrilateral. The areas of these polygons are calculated.\n4.  For each node $i=1,2,3$, determine the coefficients $s_i^+$ and $s_i^-$ based on the sign of $\\phi_i$.\n5.  Assemble the full $6 \\times 6$ matrix $\\mathbf{K}^{\\mathrm{bb}}$ from its $2 \\times 2$ blocks $\\mathbf{K}_{ij}^{\\mathrm{bb}}$ for $i,j \\in \\{1,2,3\\}$:\n    $$ \\mathbf{K}_{ij}^{\\mathrm{bb}} = t \\, \\left( (s_i^+ s_j^+) A^+ + (s_i^- s_j^-) A^- \\right) \\, (\\mathbf{B}_i)^T \\mathbf{D} \\, \\mathbf{B}_j $$\n    The blocks are placed in the matrix corresponding to the DOF ordering $[u_{1x}^{\\mathrm{enr}}, u_{1y}^{\\mathrm{enr}}, u_{2x}^{\\mathrm{enr}}, u_{2y}^{\\mathrm{enr}}, u_{3x}^{\\mathrm{enr}}, u_{3y}^{\\mathrm{enr}}]$.\n6.  The final result is the $6 \\times 6$ matrix $\\mathbf{K}^{\\mathrm{bb}}$ flattened into a vector in row-major order.\nThis procedure will be applied to each test case.", "answer": "```python\nimport numpy as np\n\ndef compute_stiffness_submatrix(nodes, phis, E, nu, t):\n    \"\"\"\n    Computes the enriched-enriched stiffness submatrix for a cracked linear triangle.\n\n    Args:\n        nodes (list of tuples): Coordinates of the 3 element nodes [(x1,y1), (x2,y2), (x3,y3)].\n        phis (tuple): Nodal level set values (phi1, phi2, phi3).\n        E (float): Young's modulus.\n        nu (float): Poisson's ratio.\n        t (float): Element thickness.\n\n    Returns:\n        list: The 6x6 enriched-enriched stiffness matrix, flattened in row-major order.\n    \"\"\"\n    node_coords = np.array(nodes, dtype=float)\n    x = node_coords[:, 0]\n    y = node_coords[:, 1]\n\n    # 1. Compute element geometric properties (Area A, B matrices)\n    A_total = 0.5 * np.abs(x[0]*(y[1]-y[2]) + x[1]*(y[2]-y[0]) + x[2]*(y[0]-y[1]))\n    if A_total == 0:\n        return [0.0] * 36\n\n    # Gradients of shape functions\n    dN_dx = np.array([y[1]-y[2], y[2]-y[0], y[0]-y[1]]) / (2 * A_total)\n    dN_dy = np.array([x[2]-x[1], x[0]-x[2], x[1]-x[0]]) / (2 * A_total)\n\n    # B matrices\n    B_matrices = []\n    for i in range(3):\n        B_i = np.array([\n            [dN_dx[i], 0],\n            [0, dN_dy[i]],\n            [dN_dy[i], dN_dx[i]]\n        ])\n        B_matrices.append(B_i)\n\n    # 2. Compute plane strain constitutive matrix D\n    d_const = E * (1 - nu) / ((1 + nu) * (1 - 2 * nu))\n    D = d_const * np.array([\n        [1, nu / (1 - nu), 0],\n        [nu / (1 - nu), 1, 0],\n        [0, 0, (1 - 2 * nu) / (2 * (1 - nu))]\n    ])\n\n    # 3. Determine subdomain areas A+ and A-\n    pos_nodes_idx = [i for i, phi in enumerate(phis) if phi >= 0]\n    neg_nodes_idx = [i for i, phi in enumerate(phis) if phi < 0]\n\n    A_pos, A_neg = 0.0, 0.0\n\n    if len(pos_nodes_idx) == 3:\n        A_pos = A_total\n    elif len(neg_nodes_idx) == 3:\n        A_neg = A_total\n    else:  # Element is cut\n        # This function interpolates to find the point on an edge where phi=0\n        def get_intersection(p1_idx, p2_idx):\n            phi1, phi2 = phis[p1_idx], phis[p2_idx]\n            pt1, pt2 = node_coords[p1_idx], node_coords[p2_idx]\n            # using formula p = (phi2*p1 - phi1*p2) / (phi2-phi1) for robustness even if one is 0\n            return (phi2 * pt1 - phi1 * pt2) / (phi2 - phi1)\n\n        def polygon_area(verts):\n            if len(verts) < 3:\n                return 0.0\n            # Shoelace formula\n            area = 0.0\n            for i in range(len(verts)):\n                p1 = verts[i]\n                p2 = verts[(i + 1) % len(verts)]\n                area += p1[0] * p2[1] - p2[0] * p1[1]\n            return 0.5 * np.abs(area)\n        \n        # Identify the single node and the two other nodes\n        if len(neg_nodes_idx) == 1:\n            single_node_idx = neg_nodes_idx[0]\n            other_nodes_idx = pos_nodes_idx\n            is_single_node_neg = True\n        else: # len(pos_nodes_idx) == 1\n            single_node_idx = pos_nodes_idx[0]\n            other_nodes_idx = neg_nodes_idx\n            is_single_node_neg = False\n            \n        p_s = node_coords[single_node_idx]\n        \n        p_int1 = get_intersection(single_node_idx, other_nodes_idx[0])\n        p_int2 = get_intersection(single_node_idx, other_nodes_idx[1])\n        \n        small_poly_verts = [p_s, p_int1, p_int2]\n        small_area = polygon_area(small_poly_verts)\n\n        if is_single_node_neg:\n            A_neg = small_area\n            A_pos = A_total - A_neg\n        else:\n            A_pos = small_area\n            A_neg = A_total - A_pos\n\n    # 4. Determine s factors\n    s_pos, s_neg = [], []\n    for phi in phis:\n        if phi >= 0: # Node on positive side or on crack\n            s_pos.append(0)\n            s_neg.append(-2)\n        else: # Node on negative side\n            s_pos.append(2)\n            s_neg.append(0)\n\n    # 5. Assemble K_bb\n    K_bb = np.zeros((6, 6))\n    M_ij_cache = {} # Cache for (Bi^T * D * Bj)\n\n    for i in range(3):\n        for j in range(3):\n            # Calculate integral term I_ij\n            I_ij = (s_pos[i] * s_pos[j]) * A_pos + (s_neg[i] * s_neg[j]) * A_neg\n            \n            if I_ij == 0:\n                continue\n\n            # Calculate matrix product part (Bi^T * D * Bj)\n            # Use symmetry to reduce calculations\n            if (i, j) in M_ij_cache:\n                M_ij = M_ij_cache[(i,j)]\n            elif (j,i) in M_ij_cache:\n                M_ij = M_ij_cache[(j,i)].T\n            else:\n                M_ij = B_matrices[i].T @ D @ B_matrices[j]\n                M_ij_cache[(i,j)] = M_ij\n\n            K_ij_block = t * I_ij * M_ij\n\n            # Place block in the 6x6 matrix\n            row_start, col_start = 2 * i, 2 * j\n            K_bb[row_start:row_start+2, col_start:col_start+2] = K_ij_block\n\n    # 6. Flatten and return\n    return K_bb.flatten().tolist()\n\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # Material and geometry parameters\n    E = 30.0e9  # Pa\n    nu = 0.25\n    t = 1.0     # m\n\n    # Test suite\n    test_cases = [\n        {\n            \"nodes\": ((0.0, 0.0), (2.0, 0.0), (0.0, 1.0)),\n            \"phis\": (-0.2, 0.3, 0.4)\n        },\n        {\n            \"nodes\": ((0.0, 0.0), (1.5, 0.0), (0.5, 1.0)),\n            \"phis\": (0.0, 0.5, -0.5)\n        },\n        {\n            \"nodes\": ((0.0, 0.0), (2.0, 0.0), (0.0, 1.0)),\n            \"phis\": (-0.001, 0.001, 0.001)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        stiffness_flat = compute_stiffness_submatrix(case[\"nodes\"], case[\"phis\"], E, nu, t)\n        results.append(stiffness_flat)\n\n    # Format output as specified\n    formatted_results = \"[\" + \",\".join([str(res) for res in results]) + \"]\"\n    print(formatted_results)\n\nsolve()\n\n```", "id": "3523124"}, {"introduction": "While enrichment functions are powerful tools for modeling discontinuities, their naive application can interfere with the crucial partition of unity property of finite element shape functions, leading to significant approximation errors. This exercise uses a simplified one-dimensional bar to clearly demonstrate this \"pollution error\" that arises when blending corrections are omitted. By comparing the numerical solution to an exact analytical solution, you will directly observe and quantify the importance of specialized techniques for handling enrichment in elements adjacent to the discontinuity. [@problem_id:3523133]", "problem": "A one-dimensional, small-strain, linear-elastic bar of length $L$ and constant cross-section area $A$ is considered. The material has Young’s modulus $E$. The bar occupies the interval $x \\in [0,L]$. An internal traction-free crack is modeled as a strong discontinuity of displacement at $x = x_c$, represented by the zero level set of a signed-distance function $\\phi(x) = x - x_c$. The boundary conditions are essential: $u(0) = 0$ and $u(L) = \\bar{u}$. There are no body forces or external tractions. Units must be used consistently in the International System of Units (SI): $L$ in meters, $A$ in square meters, $E$ in pascals, and $\\bar{u}$ in meters. The final answer must report displacements in meters.\n\nThe discretization uses the Extended Finite Element Method (XFEM) with a Heaviside enrichment to represent the jump in displacement across the crack. The discrete approximation is\n$$\nu_h(x) = \\sum_{i=0}^{N} N_i(x) \\, u_i + \\sum_{i \\in \\mathcal{E}} N_i(x) \\left( H(x) - H(x_i) \\right) a_i,\n$$\nwhere $N_i(x)$ are the standard linear shape functions on a uniform mesh of $N$ elements and $N+1$ nodes, $u_i$ are the standard nodal displacements, $a_i$ are enriched degrees of freedom associated with the Heaviside enrichment, $\\mathcal{E}$ is the set of nodes whose supports are cut by the crack, and $H(x)$ is the Heaviside function defined by $H(x) = +1$ for $x \\ge x_c$ and $H(x) = -1$ for $x < x_c$. In this problem, blending corrections (also called ramp or correction functions used to restore the partition of unity in blending elements) are intentionally ignored. This means the enrichment is used exactly as written, with no additional correction in elements adjacent to the cut element.\n\nThe governing weak form stems from the principle of virtual work for one-dimensional small-strain elasticity: find $u \\in \\mathcal{U}$ such that\n$$\n\\int_{0}^{L} E A \\, u'(x) \\, v'(x) \\, dx = 0 \\quad \\text{for all } v \\in \\mathcal{V},\n$$\nwhere $u(0) = 0$ and $u(L) = \\bar{u}$, and $\\mathcal{V}$ is the space of admissible variations vanishing at $0$ and $L$. The internal crack surfaces are traction-free. The enrichment allows $u$ to be discontinuous at $x_c$ while the volume integral is computed by splitting only the cut element into subdomains on which $H(x)$ is constant. All integrals are performed piecewise on subdomains where $H(x)$ is constant; no blending correction is used.\n\nThe exact solution for this boundary value problem with a traction-free internal crack is the minimizer of the elastic energy under the given boundary conditions, and therefore is piecewise constant:\n$$\nu_{\\text{exact}}(x) = \\begin{cases}\n0, & x < x_c, \\\\\n\\bar{u}, & x \\ge x_c.\n\\end{cases}\n$$\nConsequently, the exact midspan displacement at $x_m = L/2$ is\n$$\nu_{\\text{exact}}(L/2) = \\begin{cases}\n0, & L/2 < x_c, \\\\\n\\bar{u}, & L/2 \\ge x_c.\n\\end{cases}\n$$\n\nTask: Implement a program that assembles the XFEM stiffness matrix for the described one-dimensional bar, using the Heaviside enrichment without any blending corrections. Use uniform linear finite elements and split only the cut element into two subdomains for integration. Enforce the essential boundary conditions $u(0) = 0$ and $u(L) = \\bar{u}$. Solve for the discrete unknowns and evaluate the displacement at the midspan $x_m = L/2$. For each test case below, compute the absolute error at midspan,\n$$\ne = \\left| u_h(L/2) - u_{\\text{exact}}(L/2) \\right|,\n$$\nand report $e$ in meters as a floating-point number.\n\nTake the following constants for all test cases: $E = 30 \\times 10^{9}\\ \\text{Pa}$, $A = 1.0 \\times 10^{-2}\\ \\text{m}^2$, $L = 1.0\\ \\text{m}$, and $\\bar{u} = 1.0 \\times 10^{-3}\\ \\text{m}$.\n\nImplement the following test suite, which varies the mesh resolution and the crack location:\n- Test 1 (happy path): $N = 10$, $x_c = 0.33\\ \\text{m}$.\n- Test 2 (crack to the right of midspan): $N = 11$, $x_c = 0.52\\ \\text{m}$.\n- Test 3 (crack at midspan, edge case definition $H(L/2) = +1$): $N = 4$, $x_c = 0.50\\ \\text{m}$.\n- Test 4 (coarse mesh, crack near the left): $N = 3$, $x_c = 0.12\\ \\text{m}$.\n\nOutput specification: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the tests above, for example, \"[result1,result2,result3,result4]\". Each result must be the absolute error $e$ in meters as a floating-point number.\n\nAll angles, if any, must be in radians. Percentages, if any, must be expressed as decimals or fractions, not using the percent sign. No other text should be printed.", "solution": "The user has provided a problem in computational geomechanics requiring the implementation of the Extended Finite Element Method (XFEM) for a one-dimensional bar with an internal crack.\n\n### Step 1: Extract Givens\n- **Problem Type**: 1D small-strain linear-elastic bar with an internal, traction-free crack.\n- **Governing Equation (Weak Form)**: $\\int_{0}^{L} E A \\, u'(x) \\, v'(x) \\, dx = 0$.\n- **Domain**: $x \\in [0,L]$.\n- **Boundary Conditions**: $u(0) = 0$, $u(L) = \\bar{u}$.\n- **Material & Geometry**: Young's modulus $E$, cross-section area $A$, length $L$.\n- **Crack Model**: Strong discontinuity at $x=x_c$, represented by zero level set of $\\phi(x) = x-x_c$.\n- **Discretization**: Uniform mesh of $N$ linear finite elements ($N+1$ nodes).\n- **XFEM Approximation**: $u_h(x) = \\sum_{i=0}^{N} N_i(x) \\, u_i + \\sum_{i \\in \\mathcal{E}} N_i(x) \\left( H(x) - H(x_i) \\right) a_i$.\n- **Heaviside Function**: $H(x) = +1$ for $x \\ge x_c$ and $H(x) = -1$ for $x < x_c$.\n- **Enriched Nodes**: $\\mathcal{E}$ is the set of nodes whose supports are cut by the crack.\n- **Simplification**: Blending corrections are ignored. Integration is performed by splitting the cut element.\n- **Exact Solution**: $u_{\\text{exact}}(x) = 0$ for $x < x_c$ and $u_{\\text{exact}}(x) = \\bar{u}$ for $x \\ge x_c$.\n- **Task**: Compute the absolute error $e = \\left| u_h(L/2) - u_{\\text{exact}}(L/2) \\right|$ for several test cases.\n- **Constants**: $E = 30 \\times 10^{9}\\ \\text{Pa}$, $A = 1.0 \\times 10^{-2}\\ \\text{m}^2$, $L = 1.0\\ \\text{m}$, $\\bar{u} = 1.0 \\times 10^{-3}\\ \\text{m}$.\n- **Test Cases**:\n    1. $N = 10$, $x_c = 0.33\\ \\text{m}$.\n    2. $N = 11$, $x_c = 0.52\\ \\text{m}$.\n    3. $N = 4$, $x_c = 0.50\\ \\text{m}$.\n    4. $N = 3$, $x_c = 0.12\\ \\text{m}$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is based on linear elasticity and the Finite Element Method, both of which are fundamental and well-established scientific principles. The XFEM is a standard advanced numerical technique. The problem is scientifically sound.\n- **Well-Posed**: The problem provides a well-defined boundary value problem with sufficient data and clear boundary conditions. The presence of a traction-free crack turns it into a problem with a unique, stable solution (the piecewise constant displacement field). The numerical scheme is specified.\n- **Objective**: The problem is stated using precise mathematical and engineering terminology. There are no subjective or opinion-based statements.\n- **Completeness and Consistency**: The problem provides all necessary parameters ($E, A, L, \\bar{u}$), discretization details ($N$, linear elements), and specific test cases ($x_c$). The specified XFEM formulation, although simplified by ignoring blending elements, is a consistent and formalizable approach. The edge case where the crack coincides with a node ($N=4, x_c=0.5$) requires careful interpretation of the phrase \"nodes whose supports are cut\", but this is a standard challenge in XFEM implementations and does not render the problem invalid. The interpretation that only the node at the crack location is enriched is consistent with the provided definition.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. A reasoned solution will be provided.\n\n### Principle-Based Solution\n\nThe solution requires the assembly and solution of a linear system of equations arising from the XFEM discretization of the 1D elasticity problem.\n\n**1. Discretization and Degrees of Freedom (DOFs)**\nThe domain $[0, L]$ is discretized into $N$ uniform linear elements of size $h=L/N$. The nodes are located at $x_i = i \\cdot h$ for $i=0, \\dots, N$.\nThe total degrees of freedom consist of standard nodal displacements $u_i$ and enriched DOFs $a_j$. The set of enriched nodes, $\\mathcal{E}$, are those whose supports are cut by the crack at $x_c$.\nFor a 1D linear element, the support of node $j$ is the interval $[x_{j-1}, x_{j+1}]$.\n- If the crack is located strictly within an element $(I, I+1)$, i.e., $x_I < x_c < x_{I+1}$, the supports of nodes $I$ and $I+1$ are cut. Thus, $\\mathcal{E} = \\{I, I+1\\}$. The total number of DOFs is $(N+1) + 2$.\n- If the crack is located exactly at a node $I$, i.e., $x_c = x_I$, only the support of node $I$ is cut. Thus, $\\mathcal{E} = \\{I\\}$. The total number of DOFs is $(N+1) + 1$.\n\n**2. Stiffness Matrix Derivation**\nThe global stiffness matrix $\\mathbf{K}$ is assembled from element stiffness matrices $\\mathbf{k}^e$. The entries are given by $K_{ij} = \\int_0^L EA\\, \\psi_i'(x) \\psi_j'(x) dx$, where $\\psi_i(x)$ are the global basis functions. These are either standard shape functions $N_k(x)$ or enriched basis functions $N_j(x)(H(x)-H(x_j))$.\n\n**Standard Element:** For an element not affected by the enrichment, the standard $2 \\times 2$ stiffness matrix for a 1D bar element is used:\n$$\n\\mathbf{k}^e_{std} = \\frac{EA}{h}\n\\begin{bmatrix}\n1 & -1 \\\\\n-1 & 1\n\\end{bmatrix}\n$$\n\n**Crack within an Element:** If the crack $x_c$ lies within element $e_c$ with nodes $I$ and $I+1$, this element is a \"cut element\". The enriched nodes are $\\mathcal{E}=\\{I,I+1\\}$. The local DOFs are $(u_I, u_{I+1}, a_I, a_{I+1})$. The derivative of the enriched basis functions is required. Let $\\psi_j^a(x) = N_j(x)(H(x)-H(x_j))$ be the enriched basis.\n- For node $I$, $x_I < x_c \\implies H(x_I)=-1$. For $x \\in (x_c, x_{I+1})$, $H(x)=+1$, so $(\\psi_I^a)' = (2N_I)' = 2N_I' = -2/h$. For $x \\in (x_I, x_c)$, $H(x)=-1$, so $(\\psi_I^a)' = (0 \\cdot N_I)'=0$.\n- For node $I+1$, $x_{I+1} > x_c \\implies H(x_{I+1})=+1$. For $x \\in (x_I, x_c)$, $H(x)=-1$, so $(\\psi_{I+1}^a)' = (-2N_{I+1})' = -2N_{I+1}' = -2/h$. For $x \\in (x_c, x_{I+1})$, $H(x)=+1$, so $(\\psi_{I+1}^a)'=0$.\n\nThe element stiffness matrix is computed by splitting the integral at $x_c$: $\\mathbf{k}^{e_c} = \\int_{x_I}^{x_{I+1}} EA \\mathbf{B}^T\\mathbf{B} dx = \\int_{x_I}^{x_c} \\dots + \\int_{x_c}^{x_{I+1}} \\dots$. Let $\\alpha = (x_c - x_I)/h$ and $\\beta = (x_{I+1} - x_c)/h$. This yields:\n$$\n\\mathbf{k}^{e_c} = \\frac{EA}{h}\n\\begin{bmatrix}\n1 & -1 & 2\\beta & 2\\alpha \\\\\n-1 & 1 & -2\\beta & -2\\alpha \\\\\n2\\beta & -2\\beta & 4\\beta & 0 \\\\\n2\\alpha & -2\\alpha & 0 & 4\\alpha\n\\end{bmatrix}\n$$\n\n**Crack on a Node:** If the crack is at node $I$, $x_c=x_I$, then $\\mathcal{E}=\\{I\\}$. The enrichment function is $\\psi_I^a(x) = N_I(x)(H(x)-H(x_I)) = N_I(x)(H(x)-1)$.\n- For $x > x_I$, $H(x)=1$, so $\\psi_I^a(x)=0$. The enrichment has no effect for elements to the right of the crack ($e \\ge I$). They are standard elements.\n- For $x < x_I$, $H(x)=-1$, so $\\psi_I^a(x) = -2N_I(x)$. This affects element $I-1$ (with nodes $I-1, I$). The derivative is $(\\psi_I^a)' = -2N_I'(x) = -2(-1/h) = 2/h$ within this element.\nThe DOFs for element $I-1$ are $(u_{I-1}, u_I, a_I)$. The $3 \\times 3$ element stiffness matrix is:\n$$\n\\mathbf{k}^{e_{I-1}} = \\frac{EA}{h}\n\\begin{bmatrix}\n1 & -1 & 2 \\\\\n-1 & 1 & -2 \\\\\n2 & -2 & 4\n\\end{bmatrix}\n$$\n\n**3. System Assembly and Solution**\nThe global stiffness matrix $\\mathbf{K}$ and force vector $\\mathbf{F}$ (which is zero) are assembled. The system is $\\mathbf{K}\\mathbf{d}=\\mathbf{F}$. The essential boundary conditions $u_0 = 0$ and $u_N = \\bar{u}$ are enforced by partitioning the system. The set of all DOFs $\\mathbf{d}$ is split into unknown (free) DOFs $\\mathbf{d}_f$ and prescribed DOFs $\\mathbf{d}_p = [u_0, u_N]^T = [0, \\bar{u}]^T$.\nThe system becomes:\n$$\n\\begin{bmatrix}\n\\mathbf{K}_{ff} & \\mathbf{K}_{fp} \\\\\n\\mathbf{K}_{pf} & \\mathbf{K}_{pp}\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{d}_f \\\\\n\\mathbf{d}_p\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{0} \\\\\n\\mathbf{F}_p\n\\end{bmatrix}\n$$\nThe free DOFs are found by solving the sub-system $\\mathbf{K}_{ff}\\mathbf{d}_f = -\\mathbf{K}_{fp}\\mathbf{d}_p$.\n\n**4. Post-Processing**\nOnce the full DOF vector $\\mathbf{d}$ is known, the displacement at the midpoint $x_m = L/2$ is evaluated using the XFEM approximation:\n$$\nu_h(x_m) = \\sum_{i=0}^{N} N_i(x_m) u_i + \\sum_{j \\in \\mathcal{E}} N_j(x_m) \\left( H(x_m) - H(x_j) \\right) a_j\n$$\nThe first term involves an interpolation using the standard shape functions of the element containing $x_m$. The second term adds the contribution from any enriched node whose support contains $x_m$. The absolute error $e = |u_h(L/2) - u_{exact}(L/2)|$ is then computed. The exact solution $u_{exact}(L/2)$ is $0$ if $x_m < x_c$ and $\\bar{u}$ if $x_m \\ge x_c$.", "answer": "```python\nimport numpy as np\n# from scipy import linalg # Not required for this implementation\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the 1D XFEM bar problem.\n    \"\"\"\n    \n    # Constants from the problem statement (SI units)\n    E = 30e9  # Pa\n    A = 1.0e-2 # m^2\n    L = 1.0   # m\n    u_bar = 1.0e-3 # m\n\n    # Test suite\n    test_cases = [\n        {'N': 10, 'xc': 0.33},\n        {'N': 11, 'xc': 0.52},\n        {'N': 4,  'xc': 0.50},\n        {'N': 3,  'xc': 0.12},\n    ]\n\n    results = []\n    for case in test_cases:\n        error = compute_xfem_error(case['N'], case['xc'], L, E, A, u_bar)\n        results.append(error)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_xfem_error(N, xc, L, E, A, u_bar):\n    \"\"\"\n    Computes the absolute error at midspan for a single XFEM test case.\n    \"\"\"\n    h = L / N\n    nodes = np.linspace(0, L, N + 1)\n\n    # 1. Identify enriched nodes and case type\n    enriched_nodes_indices = []\n    cut_element_idx = -1\n    crack_on_node_idx = -1\n    \n    node_at_crack = np.where(np.isclose(nodes, xc))[0]\n    if node_at_crack.size > 0:\n        crack_on_node_idx = node_at_crack[0]\n        enriched_nodes_indices = [crack_on_node_idx]\n    else:\n        cut_element_idx = int(np.floor(xc / h))\n        enriched_nodes_indices = [cut_element_idx, cut_element_idx + 1]\n    \n    num_enriched_dofs = len(enriched_nodes_indices)\n    total_dofs = N + 1 + num_enriched_dofs\n    enriched_node_to_a_idx = {node_idx: N + 1 + i for i, node_idx in enumerate(enriched_nodes_indices)}\n\n    # 2. Assemble global stiffness matrix K\n    K = np.zeros((total_dofs, total_dofs))\n    \n    for i in range(N):\n        n1, n2 = i, i+1\n        \n        is_cut_element = (cut_element_idx == i)\n        is_pre_crack_enriched = (crack_on_node_idx > 0 and i == crack_on_node_idx - 1)\n\n        if is_cut_element:\n            alpha = (xc - nodes[i]) / h\n            beta = (nodes[i+1] - xc) / h\n            k_e = (E * A / h) * np.array([\n                [1, -1, 2 * beta, 2 * alpha],\n                [-1, 1, -2 * beta, -2 * alpha],\n                [2 * beta, -2 * beta, 4 * beta, 0],\n                [2 * alpha, -2 * alpha, 0, 4 * alpha]\n            ])\n            \n            u1_idx, u2_idx = n1, n2\n            a1_idx = enriched_node_to_a_idx[n1]\n            a2_idx = enriched_node_to_a_idx[n2]\n            dof_map = [u1_idx, u2_idx, a1_idx, a2_idx]\n            K[np.ix_(dof_map, dof_map)] += k_e\n            \n        elif is_pre_crack_enriched:\n            k_e = (E * A / h) * np.array([\n                [1, -1, 2],\n                [-1, 1, -2],\n                [2, -2, 4]\n            ])\n            \n            u1_idx, u2_idx = n1, n2\n            a_idx = enriched_node_to_a_idx[crack_on_node_idx]\n            dof_map = [u1_idx, u2_idx, a_idx]\n            K[np.ix_(dof_map, dof_map)] += k_e\n            \n        else: # Standard element\n            k_std = (E * A / h) * np.array([[1, -1], [-1, 1]])\n            dof_map = [n1, n2]\n            K[np.ix_(dof_map, dof_map)] += k_std\n\n    # 3. Apply BCs and solve linear system\n    prescribed_dofs = {0, N}\n    free_dofs = sorted(list(set(range(total_dofs)) - prescribed_dofs))\n    \n    d_p = np.array([0., u_bar])\n    \n    K_ff = K[np.ix_(free_dofs, free_dofs)]\n    K_fp = K[np.ix_(free_dofs, list(prescribed_dofs))]\n    \n    rhs = -K_fp @ d_p\n    d_f = np.linalg.solve(K_ff, rhs)\n    \n    d = np.zeros(total_dofs)\n    d[list(prescribed_dofs)] = d_p\n    d[free_dofs] = d_f\n\n    # 4. Evaluate displacement u_h at midspan L/2\n    x_m = L / 2\n    \n    # Find element containing x_m\n    elem_mid_idx = int(np.floor(x_m / h))\n    if np.isclose(x_m, L): elem_mid_idx = N - 1\n        \n    # Standard interpolation part\n    j1, j2 = elem_mid_idx, elem_mid_idx + 1\n    xi_mid = (x_m - nodes[j1]) / h\n    N1_mid, N2_mid = 1 - xi_mid, xi_mid\n    u_h = N1_mid * d[j1] + N2_mid * d[j2]\n    \n    # Enrichment part\n    H = lambda x: 1.0 if x >= xc else -1.0\n    \n    for enriched_node in enriched_nodes_indices:\n        x_j_minus_1 = nodes[enriched_node - 1] if enriched_node > 0 else -np.inf\n        x_j         = nodes[enriched_node]\n        x_j_plus_1  = nodes[enriched_node + 1] if enriched_node < N else np.inf\n\n        N_j_mid = 0.0\n        if x_j_minus_1 <= x_m <= x_j:\n            N_j_mid = (x_m - x_j_minus_1) / h\n        elif x_j < x_m <= x_j_plus_1:\n            N_j_mid = (x_j_plus_1 - x_m) / h\n        \n        if N_j_mid > 0:\n            a_j = d[enriched_node_to_a_idx[enriched_node]]\n            u_h += N_j_mid * (H(x_m) - H(x_j)) * a_j\n            \n    # 5. Compute absolute error\n    u_exact_mid = u_bar if x_m >= xc else 0.0\n    error = np.abs(u_h - u_exact_mid)\n    \n    return error\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "3523133"}, {"introduction": "This advanced practice moves beyond modeling a simple jump to capturing the singular stress and strain fields that characterize a crack tip, a cornerstone of fracture mechanics. You will implement the asymptotic near-tip enrichment functions and rigorously test the effectiveness of ramp-based blending corrections using a formal $L^2$-projection experiment. This exercise provides critical insight into analyzing the convergence properties of an XFEM implementation and validating its accuracy, a vital skill for conducting research in computational geomechanics. [@problem_id:3523114]", "problem": "You are to design and implement a minimal-enrichment projection experiment that isolates and quantifies blending element pollution in the extended finite element method (XFEM) for a mixed-mode crack in a two-dimensional scalar surrogate of linear elastic fracture mechanics. The objective is to test whether ramp-based blending corrections eliminate partition-of-unity pollution when a crack tip passes near element corners, and to assess their impact on convergence rates under mixed-mode loading.\n\nStart from the following accepted bases and definitions.\n\n- The finite element method uses the partition of unity property: if $\\{N_i(\\boldsymbol{x})\\}$ are nodal shape functions on a mesh, then $\\sum_i N_i(\\boldsymbol{x}) = 1$ for all $\\boldsymbol{x}$ in the domain. In the extended finite element method (XFEM), an enriched trial space augments the standard space by products of $N_i(\\boldsymbol{x})$ with discontinuous or singular functions $F_k(\\boldsymbol{x})$ associated with a crack represented by a level set.\n- A straight crack issuing from a tip point $\\boldsymbol{x}_t$ with orientation angle $\\varphi$ (in radians) is represented by level sets through a local polar frame $(r,\\theta)$ defined by rotating global coordinates by $-\\varphi$ about $\\boldsymbol{x}_t$. The near-tip mixed-mode asymptotic enrichment basis in a scalar surrogate may be taken as $F_1(\\boldsymbol{x}) = \\sqrt{r(\\boldsymbol{x})}\\cos\\left(\\theta(\\boldsymbol{x})/2\\right)$ and $F_2(\\boldsymbol{x}) = \\sqrt{r(\\boldsymbol{x})}\\sin\\left(\\theta(\\boldsymbol{x})/2\\right)$, which are bounded but discontinuous across the crack line due to the branch of $\\theta$ in $(-\\pi,\\pi]$.\n- In blending elements that neighbor enriched regions, failure of the partition of unity to factor out enrichment can pollute approximation quality. Two common corrections are:\n  1. Shifted enrichment: use $N_i(\\boldsymbol{x}) \\left(F_k(\\boldsymbol{x}) - F_k(\\boldsymbol{x}_i)\\right)$ for each enriched node $i$ with coordinates $\\boldsymbol{x}_i$.\n  2. Ramp correction: multiply the shifted enrichment by a ramp $R(\\boldsymbol{x}) = \\sum_{j \\in \\mathcal{E}_e} N_j(\\boldsymbol{x})$, where $\\mathcal{E}_e$ is the set of enriched nodes of the current element, giving $N_i(\\boldsymbol{x}) R(\\boldsymbol{x}) \\left(F_k(\\boldsymbol{x}) - F_k(\\boldsymbol{x}_i)\\right)$. The ramp vanishes on the boundary of the enriched patch, eliminating partition-of-unity pollution in blending elements.\n\nYour task is to implement an $L^2$-projection experiment on the unit square domain $\\Omega = [0,1]^2$ that compares the convergence of two enrichment strategies:\n\n- Strategy A (shifted only): standard bilinear basis plus shifted tip enrichments without ramp.\n- Strategy B (ramp-corrected): standard bilinear basis plus shifted tip enrichments multiplied by the ramp.\n\nYou will not solve a boundary value problem. Instead, you will project a known mixed-mode “target” field $u^\\star(\\boldsymbol{x})$ onto each discrete space by minimizing the $L^2$ error and then measure the convergence rate under mesh refinement and varying crack tip proximity to a mesh corner.\n\nDefinitions for the experiment:\n\n- Mesh: a uniform tensor-product mesh of bilinear quadrilateral elements of size $h = 1/N$, with $N \\in \\mathbb{N}$ the number of elements along each axis. Use standard bilinear shape functions $N_1,\\dots,N_4$ on each element.\n- Enriched nodes: nodes within a radius $r_e = \\alpha h$ of the crack tip $\\boldsymbol{x}_t$, with $\\alpha = 2$. Enriched nodes carry two enriched degrees of freedom per node, associated with $F_1$ and $F_2$.\n- Target field: for coefficients $a_{\\mathrm{I}}$ and $a_{\\mathrm{II}}$, define\n  $$u^\\star(\\boldsymbol{x}) = a_{\\mathrm{I}} F_1(\\boldsymbol{x}) + a_{\\mathrm{II}} F_2(\\boldsymbol{x}).$$\n  Angles must be computed in radians. The local polar coordinates are defined by\n  $$\\begin{pmatrix} x' \\\\ y' \\end{pmatrix} = \\begin{pmatrix} \\cos\\varphi & \\sin\\varphi \\\\ -\\sin\\varphi & \\cos\\varphi \\end{pmatrix} \\left(\\begin{pmatrix} x \\\\ y \\end{pmatrix} - \\begin{pmatrix} x_t \\\\ y_t \\end{pmatrix}\\right), \\quad r = \\sqrt{(x')^2 + (y')^2}, \\quad \\theta = \\operatorname{atan2}(y',x').$$\n- Discrete spaces:\n  - Let $\\mathcal{S}_h$ denote the standard bilinear space spanned by all mesh node shape functions.\n  - Let $\\mathcal{S}_h^{\\mathrm{A}}$ be $\\mathcal{S}_h$ augmented by functions $N_i(\\boldsymbol{x})\\left(F_k(\\boldsymbol{x}) - F_k(\\boldsymbol{x}_i)\\right)$ for each enriched node $i$ and each $k \\in \\{1,2\\}$.\n  - Let $\\mathcal{S}_h^{\\mathrm{B}}$ be $\\mathcal{S}_h$ augmented by functions $N_i(\\boldsymbol{x}) R(\\boldsymbol{x})\\left(F_k(\\boldsymbol{x}) - F_k(\\boldsymbol{x}_i)\\right)$, where $R(\\boldsymbol{x}) = \\sum_{j \\in \\mathcal{E}_e} N_j(\\boldsymbol{x})$ at the element level.\n- Projection problem: find $u_h$ in the chosen discrete space that minimizes\n  $$J(u_h) = \\int_{\\Omega} \\left(u_h(\\boldsymbol{x}) - u^\\star(\\boldsymbol{x})\\right)^2 \\, \\mathrm{d}\\boldsymbol{x}.$$\n  This is equivalent to solving the normal equations $M \\boldsymbol{c} = \\boldsymbol{b}$ with\n  $$M_{pq} = \\int_{\\Omega} \\Phi_p(\\boldsymbol{x}) \\, \\Phi_q(\\boldsymbol{x}) \\, \\mathrm{d}\\boldsymbol{x}, \\quad b_p = \\int_{\\Omega} \\Phi_p(\\boldsymbol{x}) \\, u^\\star(\\boldsymbol{x}) \\, \\mathrm{d}\\boldsymbol{x},$$\n  where $\\{\\Phi_p\\}$ are the global basis functions of the chosen discrete space. Use Gaussian quadrature with at least $4 \\times 4$ points per element for numerical integration. If needed for numerical stability, you may add a Tikhonov regularization term $\\epsilon I$ with $\\epsilon = 10^{-12}$ to $M$.\n- Error and convergence rate: compute the $L^2$ error\n  $$E(h) = \\left(\\int_{\\Omega} \\left(u_h(\\boldsymbol{x}) - u^\\star(\\boldsymbol{x})\\right)^2 \\, \\mathrm{d}\\boldsymbol{x}\\right)^{1/2}.$$\n  For a refinement sequence with mesh sizes $h_1,h_2,h_3$, compute the empirical convergence rate $p$ by linear regression on $\\left(\\log h_j, \\log E(h_j)\\right)$.\n\nYour program must implement both strategies A and B and evaluate the empirical convergence rates for each of the following three test cases. In all cases, the domain is $\\Omega = [0,1]^2$, and the crack tip is located at $\\boldsymbol{x}_t = \\left(0.5 + \\delta,\\, 0.5 + \\delta\\right)$, passing near the mesh node at $\\left(0.5,\\, 0.5\\right)$. Use the refinement sequence $N \\in \\{8,16,24\\}$ (so $h \\in \\{1/8,1/16,1/24\\}$). Angles must be in radians.\n\n- Test case $1$ (happy path, balanced mixed-mode, moderate proximity):\n  - $\\delta = 0.02$\n  - $\\varphi = \\pi/6$\n  - $a_{\\mathrm{I}} = 1.0$\n  - $a_{\\mathrm{II}} = 1.0$\n- Test case $2$ (edge proximity, mode mix skewed):\n  - $\\delta = 0.005$\n  - $\\varphi = \\pi/3$\n  - $a_{\\mathrm{I}} = 1.0$\n  - $a_{\\mathrm{II}} = 0.3$\n- Test case $3$ (different orientation, reversed mix, moderate proximity):\n  - $\\delta = 0.03$\n  - $\\varphi = -\\pi/4$\n  - $a_{\\mathrm{I}} = 0.7$\n  - $a_{\\mathrm{II}} = 1.3$\n\nFinal required output format:\n\n- For each test case, compute the empirical convergence rates $p_{\\mathrm{A}}$ and $p_{\\mathrm{B}}$ for strategies A and B respectively, and the improvement $\\Delta p = p_{\\mathrm{B}} - p_{\\mathrm{A}}$.\n- Your program should produce a single line of output containing the results as a list of lists of floats, one inner list per test case, in the order of the test cases above, where each inner list is $[p_{\\mathrm{A}}, p_{\\mathrm{B}}, \\Delta p]$. For example, a valid output with placeholders is $[[0.9,1.3,0.4],[\\dots],[\\dots]]$.\n\nAll quantities are nondimensional. Angles must be in radians. There are no physical units. Ensure numerical integration and assembly are scientifically sound and self-consistent. The program must be complete and runnable as specified. Do not read any input; just compute and print the final list. Round nothing; print raw floating-point numbers as produced by your computations.", "solution": "The user has requested the design and implementation of a numerical experiment to study blending element pollution in the extended finite element method (XFEM). The problem is self-contained, scientifically well-grounded in the principles of computational mechanics and numerical analysis, and provides a complete and unambiguous set of specifications. All required parameters, mathematical definitions, and procedures are clearly stated, rendering the problem valid and solvable.\n\nThe core of the problem is to perform an $L^2$-projection of a known analytical field, $u^\\star(\\boldsymbol{x})$, onto two different XFEM discrete spaces. This allows for the assessment of the approximation quality of these spaces, isolated from other aspects of solving a partial differential equation. The two spaces, denoted $\\mathcal{S}_h^{\\mathrm{A}}$ and $\\mathcal{S}_h^{\\mathrm{B}}$, represent two common strategies for constructing enriched basis functions in blending elements—elements that are adjacent to the region of crack-tip enrichment.\n\n- **Strategy A** uses a \"shifted\" enrichment, where the basis functions are of the form $N_i(\\boldsymbol{x}) \\left(F_k(\\boldsymbol{x}) - F_k(\\boldsymbol{x}_i)\\right)$. Here, $N_i$ is a standard finite element shape function for node $i$, and $F_k$ is an asymptotic crack-tip function. The subtraction of the function value at the node, $F_k(\\boldsymbol{x}_i)$, ensures that the enrichment is zero at node $i$, which is a desirable property. However, this construction does not guarantee that the partition of unity property, $\\sum_i N_i(\\boldsymbol{x}) = 1$, can be factored out, leading to so-called \"pollution\" or a loss of approximation power.\n\n- **Strategy B** introduces a \"ramp\" function, $R(\\boldsymbol{x})$, which multiplies the shifted enrichment. The basis functions are $N_i(\\boldsymbol{x}) R(\\boldsymbol{x})\\left(F_k(\\boldsymbol{x}) - F_k(\\boldsymbol{x}_i)\\right)$. The ramp function $R(\\boldsymbol{x}) = \\sum_{j \\in \\mathcal{E}_e} N_j(\\boldsymbol{x})$ is defined on each element as the sum of shape functions corresponding only to the element's enriched nodes, $\\mathcal{E}_e$. This ramp is equal to $1$ at enriched nodes and smoothly goes to $0$ on the boundary of the enriched patch of elements. This property effectively eliminates the partition-of-unity pollution in the blending elements.\n\nThe experiment aims to quantify the improvement offered by Strategy B over Strategy A by examining the empirical convergence rate of the $L^2$ error as the mesh is refined.\n\nThe implementation will proceed as follows:\n\n1.  **Mesh and Discretization**: A uniform $N \\times N$ grid of bilinear quadrilateral elements is defined on the unit square $\\Omega = [0,1]^2$. Nodes are identified as \"enriched\" if they fall within a specified radius $r_e = \\alpha h$ of the crack tip $\\boldsymbol{x}_t$.\n\n2.  **Basis Functions**: The global set of basis functions, $\\{\\Phi_p\\}$, is constructed. It comprises:\n    a. Standard bilinear shape functions $N_i(\\boldsymbol{x})$ for all nodes $i$ in the mesh.\n    b. Enriched functions for each enriched node, corresponding to the two crack-tip asymptotics $F_1(\\boldsymbol{x}) = \\sqrt{r}\\cos(\\theta/2)$ and $F_2(\\boldsymbol{x}) = \\sqrt{r}\\sin(\\theta/2)$. The specific form depends on the chosen strategy (A or B).\n\n3.  **$L^2$-Projection**: To find the best approximation $u_h$ of $u^\\star$ in the discrete space, we must solve the normal equations $M \\boldsymbol{c} = \\boldsymbol{b}$.\n    - The mass matrix $M_{pq} = \\int_{\\Omega} \\Phi_p(\\boldsymbol{x}) \\Phi_q(\\boldsymbol{x}) \\, \\mathrm{d}\\boldsymbol{x}$ and the right-hand-side vector $b_p = \\int_{\\Omega} \\Phi_p(\\boldsymbol{x}) u^\\star(\\boldsymbol{x}) \\, \\mathrm{d}\\boldsymbol{x}$ are assembled.\n    - This involves iterating over each element in the mesh and, for each element, numerically integrating the products of basis functions using Gaussian quadrature ($4 \\times 4$ points per element as specified). The element-level matrices and vectors are then assembled into the global system.\n\n4.  **Error and Convergence**: After solving for the coefficient vector $\\boldsymbol{c}$, the squared $L^2$ error is efficiently computed using the relation $E^2 = \\int_{\\Omega} (u^\\star)^2 \\mathrm{d}\\boldsymbol{x} - \\boldsymbol{c}^T \\boldsymbol{b}$. This process is repeated for a sequence of mesh refinements ($N = 8, 16, 24$). The empirical convergence rate $p$ is then determined by a linear regression on the log-log plot of error versus mesh size, i.e., $(\\log h_j, \\log E(h_j))$.\n\n5.  **Test Cases**: The entire procedure is carried out for three distinct test cases, each with different crack tip positions, orientations, and mixed-mode coefficients for the target field $u^\\star$. This tests the robustness of the methods under varying conditions, particularly the proximity of the crack tip to element boundaries, where pollution effects are most pronounced.\n\nThe final output will be a list containing the computed convergence rates ($p_{\\mathrm{A}}$, $p_{\\mathrm{B}}$) and their difference ($\\Delta p = p_{\\mathrm{B}} - p_{\\mathrm{A}}$) for each test case, precisely following the specified format.", "answer": "```python\nimport numpy as np\n\ndef get_polar_coords(x, y, x_t, y_t, phi):\n    \"\"\"Computes local polar coordinates (r, theta) for a point (x, y).\"\"\"\n    dx = x - x_t\n    dy = y - y_t\n    c, s = np.cos(phi), np.sin(phi)\n    \n    x_prime = dx * c + dy * s\n    y_prime = -dx * s + dy * c\n    \n    r = np.sqrt(x_prime**2 + y_prime**2)\n    theta = np.arctan2(y_prime, x_prime)\n    return r, theta\n\ndef F1_func(r, theta):\n    \"\"\"Enrichment function F1.\"\"\"\n    return np.sqrt(r) * np.cos(theta / 2.0)\n\ndef F2_func(r, theta):\n    \"\"\"Enrichment function F2.\"\"\"\n    return np.sqrt(r) * np.sin(theta / 2.0)\n\ndef u_star_func(x, y, x_t, y_t, phi, a_I, a_II):\n    \"\"\"Target field u*.\"\"\"\n    if (x == x_t and y == y_t): # Avoid singularity at the tip\n        return 0.0\n    r, theta = get_polar_coords(x, y, x_t, y_t, phi)\n    return a_I * F1_func(r, theta) + a_II * F2_func(r, theta)\n\ndef calculate_convergence_rate(hs, errors):\n    \"\"\"Computes empirical convergence rate p from log(h) vs log(E).\"\"\"\n    log_h = np.log(np.array(hs))\n    log_E = np.log(np.array(errors))\n    \n    # Linear regression for p (slope)\n    n = len(log_h)\n    sum_x = np.sum(log_h)\n    sum_y = np.sum(log_E)\n    sum_xy = np.sum(log_h * log_E)\n    sum_x2 = np.sum(log_h**2)\n    \n    denominator = n * sum_x2 - sum_x**2\n    if denominator == 0:\n        return np.nan\n    \n    p = (n * sum_xy - sum_x * sum_y) / denominator\n    return p\n\ndef run_projection(N, delta, phi, a_I, a_II, strategy):\n    \"\"\"\n    Performs the L2-projection for a given mesh and strategy.\n    Returns the L2 norm of the error.\n    \"\"\"\n    h = 1.0 / N\n    x_t, y_t = 0.5 + delta, 0.5 + delta\n    alpha = 2.0\n    r_e = alpha * h\n    epsilon = 1.0e-12\n    \n    # Quadrature setup (4x4 points)\n    num_quad_pts_1d = 4\n    quad_pts_1d, quad_wts_1d = np.polynomial.legendre.leggauss(num_quad_pts_1d)\n\n    # Node and DOF Management\n    num_nodes = (N + 1)**2\n    nodes = np.array([(i * h, j * h) for j in range(N + 1) for i in range(N + 1)])\n    \n    distances_to_tip = np.sqrt((nodes[:, 0] - x_t)**2 + (nodes[:, 1] - y_t)**2)\n    enriched_node_indices = np.where(distances_to_tip <= r_e)[0]\n    \n    num_enriched = len(enriched_node_indices)\n    enriched_idx_map = {node_idx: i for i, node_idx in enumerate(enriched_node_indices)}\n    \n    num_dofs = num_nodes + 2 * num_enriched\n\n    M = np.zeros((num_dofs, num_dofs))\n    b = np.zeros(num_dofs)\n    u_star_sq_integral = 0.0\n\n    F_at_nodes = {}\n    for node_idx in enriched_node_indices:\n        nx, ny = nodes[node_idx]\n        r_n, theta_n = get_polar_coords(nx, ny, x_t, y_t, phi)\n        F_at_nodes[node_idx] = (F1_func(r_n, theta_n), F2_func(r_n, theta_n))\n\n    # Element assembly loop\n    for j_el in range(N):\n        for i_el in range(N):\n            n0_idx = j_el * (N + 1) + i_el\n            n1_idx = n0_idx + 1\n            n2_idx = (j_el + 1) * (N + 1) + i_el + 1\n            n3_idx = (j_el + 1) * (N + 1) + i_el\n            elem_nodes = [n0_idx, n1_idx, n2_idx, n3_idx]\n            \n            elem_enriched_nodes_indices = [idx for idx in elem_nodes if idx in enriched_idx_map]\n\n            local_to_global_dof = []\n            local_to_global_dof.extend(elem_nodes)\n            for node_idx in elem_nodes:\n                if node_idx in enriched_idx_map:\n                    enriched_local_idx = enriched_idx_map[node_idx]\n                    local_to_global_dof.append(num_nodes + enriched_local_idx)\n                    local_to_global_dof.append(num_nodes + num_enriched + enriched_local_idx)\n            \n            num_elem_dofs = len(local_to_global_dof)\n            Me = np.zeros((num_elem_dofs, num_elem_dofs))\n            be = np.zeros(num_elem_dofs)\n\n            x_min, y_min = i_el * h, j_el * h\n            \n            for j_q in range(num_quad_pts_1d):\n                for i_q in range(num_quad_pts_1d):\n                    xi, eta = quad_pts_1d[i_q], quad_pts_1d[j_q]\n                    weight = quad_wts_1d[i_q] * quad_wts_1d[j_q]\n                    \n                    x_q = x_min + (1 + xi) / 2.0 * h\n                    y_q = y_min + (1 + eta) / 2.0 * h\n                    dArea = (h / 2.0)**2 * weight\n                    \n                    u_star_val = u_star_func(x_q, y_q, x_t, y_t, phi, a_I, a_II)\n                    u_star_sq_integral += u_star_val**2 * dArea\n                    \n                    N_vals = np.array([\n                        0.25 * (1 - xi) * (1 - eta), 0.25 * (1 + xi) * (1 - eta),\n                        0.25 * (1 + xi) * (1 + eta), 0.25 * (1 - xi) * (1 + eta)\n                    ])\n                    \n                    r_q, theta_q = get_polar_coords(x_q, y_q, x_t, y_t, phi)\n                    F1_q, F2_q = F1_func(r_q, theta_q), F2_func(r_q, theta_q)\n                    \n                    ramp_val = 1.0\n                    if strategy == 'B':\n                        ramp_val = 0.0\n                        for i_node, node_idx in enumerate(elem_nodes):\n                            if node_idx in elem_enriched_nodes_indices:\n                                ramp_val += N_vals[i_node]\n                    \n                    phi_vals = np.zeros(num_elem_dofs)\n                    dof_counter = 0\n\n                    phi_vals[:4] = N_vals\n                    dof_counter = 4\n\n                    for i_node, node_idx in enumerate(elem_nodes):\n                        if node_idx in enriched_idx_map:\n                            F1_n, F2_n = F_at_nodes[node_idx]\n                            phi_vals[dof_counter] = N_vals[i_node] * ramp_val * (F1_q - F1_n)\n                            dof_counter += 1\n                            phi_vals[dof_counter] = N_vals[i_node] * ramp_val * (F2_q - F2_n)\n                            dof_counter += 1\n                    \n                    Me += np.outer(phi_vals, phi_vals) * dArea\n                    be += phi_vals * u_star_val * dArea\n            \n            ix = np.ix_(local_to_global_dof, local_to_global_dof)\n            M[ix] += Me\n            b[local_to_global_dof] += be\n\n    # Solve and Compute Error\n    M += epsilon * np.eye(num_dofs)\n    \n    try:\n        c = np.linalg.solve(M, b)\n        error_sq = u_star_sq_integral - np.dot(c, b)\n        error = np.sqrt(max(0, error_sq))\n    except np.linalg.LinAlgError:\n        error = np.nan\n\n    return error\n\ndef solve():\n    \"\"\"\n    Main orchestrator for the XFEM projection experiment.\n    Defines test cases, computes convergence rates for each strategy, and prints the results.\n    \"\"\"\n    test_cases = [\n        (0.02, np.pi/6, 1.0, 1.0),\n        (0.005, np.pi/3, 1.0, 0.3),\n        (0.03, -np.pi/4, 0.7, 1.3)\n    ]\n    N_values = [8, 16, 24]\n    all_results = []\n\n    for case_params in test_cases:\n        delta, phi, a_I, a_II = case_params\n        \n        hs = [1.0 / N for N in N_values]\n        \n        errors_A = [run_projection(N, delta, phi, a_I, a_II, 'A') for N in N_values]\n        p_A = calculate_convergence_rate(hs, errors_A)\n\n        errors_B = [run_projection(N, delta, phi, a_I, a_II, 'B') for N in N_values]\n        p_B = calculate_convergence_rate(hs, errors_B)\n\n        delta_p = p_B - p_A\n        all_results.append([p_A, p_B, delta_p])\n\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3523114"}]}