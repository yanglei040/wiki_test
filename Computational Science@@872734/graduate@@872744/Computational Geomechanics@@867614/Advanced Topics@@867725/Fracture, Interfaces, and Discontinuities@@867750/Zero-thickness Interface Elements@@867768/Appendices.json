{"hands_on_practices": [{"introduction": "Our journey into the practical application of zero-thickness interface elements begins with the fundamental building block: a linear elastic element. In this foundational exercise [@problem_id:3571998], you will derive the element's residual vector and tangent stiffness matrix from the principle of virtual work, a cornerstone of the Finite Element Method. By implementing and running a comprehensive suite of verification tests, you will not only translate theory into code but also learn the essential quality assurance checks that ensure a numerical model is objective, symmetric, and physically meaningful.", "problem": "Consider a zero-thickness interface element in two spatial dimensions that connects two coincident line segments. The interface element has two geometrical nodes, with each geometrical node duplicated to represent the kinematics on the minus and plus sides. Thus the element has four nodes in total and eight displacement degrees of freedom, ordered as node $1$ (minus side), node $2$ (minus side), node $3$ (plus side), and node $4$ (plus side), each with global displacement vector components in the $x$ and $y$ directions. The element is straight, of length $L$, with a constant unit tangent vector $\\mathbf{t}$ aligned with the element and a unit normal vector $\\mathbf{n}$ pointing from the minus side to the plus side. The orientation is defined by an angle $\\theta$ (in radians) such that the global tangent vector is $\\mathbf{t} = [\\cos \\theta,\\ \\sin \\theta]^{\\top}$ and the global normal vector is $\\mathbf{n} = [-\\sin \\theta,\\ \\cos \\theta]^{\\top}$. The local-to-global rotation matrix is the $2 \\times 2$ matrix $\\mathbf{R} = [\\mathbf{n}\\ \\mathbf{t}]$ whose columns are $\\mathbf{n}$ and $\\mathbf{t}$. The mapping from global to local coordinates is given by $\\mathbf{R}^{\\top}$. Assume small displacements.\n\nThe interface traction-separation law is linear elastic and uncoupled in the local normal and tangential directions. Let the local displacement jump vector be $\\mathbf{g} = [g_{n},\\ g_{t}]^{\\top}$, with $g_{n}$ the opening (positive in tension along $\\mathbf{n}$) and $g_{t}$ the sliding (positive along $\\mathbf{t}$). The local traction vector is $\\mathbf{t}^{\\text{loc}} = [t_{n},\\ t_{t}]^{\\top}$. The constitutive relation is\n$$\n\\mathbf{t}^{\\text{loc}} = \\mathbf{C}\\ \\mathbf{g}, \\quad \\mathbf{C} = \\begin{bmatrix} k_{n} & 0 \\\\ 0 & k_{t} \\end{bmatrix},\n$$\nwhere $k_{n} \\ge 0$ and $k_{t} \\ge 0$ are the normal and tangential stiffness parameters (nondimensional for this problem).\n\nLet $\\xi \\in [-1, 1]$ denote the isoparametric coordinate along the interface. Use linear shape functions $N_{1}(\\xi) = \\frac{1 - \\xi}{2}$ and $N_{2}(\\xi) = \\frac{1 + \\xi}{2}$. At any point $\\xi$, the local displacement jump is obtained from the nodal global displacements by\n$$\n\\mathbf{g}(\\xi) = \\mathbf{R}^{\\top} \\sum_{i=1}^{2} N_{i}(\\xi) \\left( \\mathbf{u}^{+}_{i} - \\mathbf{u}^{-}_{i} \\right),\n$$\nwhere $\\mathbf{u}^{-}_{i}$ and $\\mathbf{u}^{+}_{i}$ are the global displacement vectors at the minus and plus side duplicates of geometrical node $i$.\n\nStarting from the principle of virtual work for interfaces and basic finite element interpolation,\n$$\n\\delta W_{\\text{int}} = \\int_{\\Gamma} \\delta \\mathbf{g}^{\\top} \\mathbf{t}^{\\text{loc}}\\ \\mathrm{d}\\Gamma, \\quad \\mathbf{t}^{\\text{loc}} = \\mathbf{C}\\ \\mathbf{g},\n$$\nderive the algebraic expressions for the element residual vector $\\mathbf{r}_{e}$ and the consistent tangent stiffness matrix $\\mathbf{K}_{e}$ using one-point Gauss quadrature at $\\xi = 0$ with weight $w = 2$ and the exact Jacobian $J = L/2$. Specifically, use the mapping\n$$\n\\mathbf{g}(0) = \\mathbf{B}\\ \\mathbf{u}_{e}, \\quad \\mathbf{B} = \\begin{bmatrix} -\\tfrac{1}{2}\\mathbf{R}^{\\top} & -\\tfrac{1}{2}\\mathbf{R}^{\\top} & \\tfrac{1}{2}\\mathbf{R}^{\\top} & \\tfrac{1}{2}\\mathbf{R}^{\\top} \\end{bmatrix},\n$$\nwhere $\\mathbf{u}_{e} \\in \\mathbb{R}^{8}$ stacks the global displacements of the four nodes in the order $\\{1x, 1y, 2x, 2y, 3x, 3y, 4x, 4y\\}$. From first principles, express $\\mathbf{r}_{e}$ and $\\mathbf{K}_{e}$ in terms of $L$, $\\mathbf{B}$, and $\\mathbf{C}$, and explain why the element stiffness is positive semidefinite.\n\nThen, implement a program that computes $\\mathbf{r}_{e}$ and $\\mathbf{K}_{e}$ for a given set of parameters and nodal displacements and uses them to verify and benchmark the element through the following test suite. Use nondimensional quantities; no physical units are required. All angles must be in radians.\n\nTest suite parameter sets:\n\n- Test $1$ (analytical force distribution under uniform local gap):\n  - $L = 2$, $\\theta = 0$, $k_{n} = 1000$, $k_{t} = 500$.\n  - Prescribe a uniform local gap by setting $\\mathbf{u}^{-}_{1} = \\mathbf{u}^{-}_{2} = \\mathbf{0}$ and $\\mathbf{u}^{+}_{1} = \\mathbf{u}^{+}_{2} = \\mathbf{R}\\ [g_{n},\\ g_{t}]^{\\top}$ with $g_{n} = 0.01$ and $g_{t} = -0.02$.\n  - Compute the element internal force vector $\\mathbf{r}_{e}$ and compare it to the exact nodal force pattern implied by the balance of linear momentum and the constitutive law for a uniform local traction. Report the relative error as a float.\n\n- Test $2$ (stiffness symmetry check):\n  - $L = 1.3$, $\\theta = 0.37$, $k_{n} = 800$, $k_{t} = 1200$.\n  - Use $\\mathbf{u}^{-}_{1} = \\mathbf{u}^{-}_{2} = \\mathbf{0}$ and $\\mathbf{u}^{+}_{1} = \\mathbf{u}^{+}_{2} = \\mathbf{R}\\ [0.013,\\ -0.007]^{\\top}$.\n  - Compute $\\mathbf{K}_{e}$ and report the relative symmetry defect $\\|\\mathbf{K}_{e} - \\mathbf{K}_{e}^{\\top}\\|_{F} / \\|\\mathbf{K}_{e}\\|_{F}$ as a float.\n\n- Test $3$ (frame invariance under rotation):\n  - $L = 2$, $\\theta_{0} = 0$, $\\theta_{1} = \\pi/3$, $k_{n} = 900$, $k_{t} = 300$.\n  - Use the same uniform local gap vector $[g_{n},\\ g_{t}]^{\\top} = [0.02,\\ 0.01]^{\\top}$ for both orientations by setting $\\mathbf{u}^{-}_{i} = \\mathbf{0}$ and $\\mathbf{u}^{+}_{i} = \\mathbf{R}(\\theta)\\ [g_{n},\\ g_{t}]^{\\top}$ for each $\\theta \\in \\{\\theta_{0}, \\theta_{1}\\}$.\n  - Compute $\\mathbf{r}_{e}(\\theta_{0})$ and $\\mathbf{r}_{e}(\\theta_{1})$. Let $\\mathbf{T} = \\mathbf{R}(\\theta_{1})\\ \\mathbf{R}(\\theta_{0})^{\\top}$ and $\\mathbf{Q} = \\mathrm{diag}(\\mathbf{T}, \\mathbf{T}, \\mathbf{T}, \\mathbf{T})$. Report the relative difference $\\|\\mathbf{r}_{e}(\\theta_{1}) - \\mathbf{Q}\\ \\mathbf{r}_{e}(\\theta_{0})\\|_{2} / \\|\\mathbf{r}_{e}(\\theta_{1})\\|_{2}$ as a float.\n\n- Test $4$ (edge case with zero tangential stiffness):\n  - $L = 3$, $\\theta = 0.5$, $k_{n} = 700$, $k_{t} = 0$.\n  - Use a pure sliding gap with $g_{n} = 0$ and $g_{t} = 0.05$, by setting $\\mathbf{u}^{-}_{i} = \\mathbf{0}$ and $\\mathbf{u}^{+}_{i} = \\mathbf{R}\\ [0,\\ 0.05]^{\\top}$.\n  - Compute $\\mathbf{r}_{e}$ and report its Euclidean norm $\\|\\mathbf{r}_{e}\\|_{2}$ as a float.\n\n- Test $5$ (positive semidefiniteness benchmark):\n  - $L = 1$, $\\theta = 0.2$, $k_{n} = 1000$, $k_{t} = 500$.\n  - Compute the eigenvalues of $\\mathbf{K}_{e}$ and report the minimum eigenvalue as a float.\n\nFinal output format specification: Your program should produce a single line of output containing the results of the five tests as a comma-separated list enclosed in square brackets (e.g., $[r_{1}, r_{2}, r_{3}, r_{4}, r_{5}]$), where each $r_{i}$ is the requested float for test $i$ in the order above. No other output should be produced. Angles must be in radians. Use nondimensional numbers throughout. All computations must be carried out using the definitions and derivations above starting from the principle of virtual work and linear momentum balance. Your implementation must be entirely self-contained, require no input, and must use the one-point Gauss quadrature with the exact Jacobian as specified.", "solution": "The problem requires the derivation and implementation of a four-node, two-dimensional, zero-thickness interface element. The solution proceeds in two stages: first, a theoretical derivation of the element's residual vector $\\mathbf{r}_e$ and tangent stiffness matrix $\\mathbf{K}_e$ from first principles; second, the implementation of these formulas in a program to perform a series of verification tests.\n\n### Derivation of Element Formulation\n\nThe formulation is based on the principle of virtual work for interfaces:\n$$\n\\delta W_{\\text{int}} = \\int_{\\Gamma} \\delta \\mathbf{g}^{\\top} \\mathbf{t}^{\\text{loc}}\\ \\mathrm{d}\\Gamma = \\delta \\mathbf{u}_e^{\\top} \\mathbf{r}_e\n$$\nwhere $\\delta W_{\\text{int}}$ is the internal virtual work, $\\Gamma$ is the interface surface, $\\mathbf{g}$ is the local displacement jump vector, $\\mathbf{t}^{\\text{loc}}$ is the local traction vector, $\\delta \\mathbf{u}_e$ is the vector of virtual nodal displacements, and $\\mathbf{r}_e$ is the element residual (internal force) vector.\n\nThe problem specifies a linear constitutive law, $\\mathbf{t}^{\\text{loc}} = \\mathbf{C} \\mathbf{g}$, and provides a specific mapping from the element's global nodal displacements $\\mathbf{u}_e \\in \\mathbb{R}^8$ to the local displacement jump $\\mathbf{g} \\in \\mathbb{R}^2$ at the element's center (isoparametric coordinate $\\xi=0$):\n$$\n\\mathbf{g}(0) = \\mathbf{B}\\ \\mathbf{u}_{e}\n$$\nwhere $\\mathbf{B}$ is the $2 \\times 8$ strain-displacement matrix:\n$$\n\\mathbf{B} = \\begin{bmatrix} -\\tfrac{1}{2}\\mathbf{R}^{\\top} & -\\tfrac{1}{2}\\mathbf{R}^{\\top} & \\tfrac{1}{2}\\mathbf{R}^{\\top} & \\tfrac{1}{2}\\mathbf{R}^{\\top} \\end{bmatrix}\n$$\nHere, $\\mathbf{R}$ is the $2 \\times 2$ local-to-global coordinate transformation matrix. The variation of the displacement jump is likewise $\\delta\\mathbf{g}(0) = \\mathbf{B}\\ \\delta\\mathbf{u}_{e}$.\n\nThe integral over the element length $L$ is evaluated using one-point Gauss quadrature. The integration point is at $\\xi=0$, the weight is $w=2$, and the Jacobian of the mapping from the isoparametric domain $[-1, 1]$ to the physical domain $[0, L]$ is $J = L/2$. The differential element of length is $\\mathrm{d}\\Gamma = J \\mathrm{d}\\xi$.\n$$\n\\int_{\\Gamma} (\\cdot)\\ \\mathrm{d}\\Gamma = \\int_{-1}^{1} (\\cdot) J \\mathrm{d}\\xi \\approx (\\cdot)|_{\\xi=0} \\cdot J \\cdot w = (\\cdot)|_{\\xi=0} \\cdot (L/2) \\cdot 2 = (\\cdot)|_{\\xi=0} \\cdot L\n$$\nSubstituting the discretized quantities into the virtual work principle:\n$$\n\\delta W_{\\text{int}} \\approx \\left[ \\delta \\mathbf{g}(0)^{\\top} \\mathbf{t}^{\\text{loc}}(0) \\right] L\n$$\n$$\n\\delta \\mathbf{u}_e^{\\top} \\mathbf{r}_e = \\left[ (\\mathbf{B} \\delta \\mathbf{u}_e)^{\\top} (\\mathbf{C} \\mathbf{B} \\mathbf{u}_e) \\right] L\n$$\n$$\n\\delta \\mathbf{u}_e^{\\top} \\mathbf{r}_e = \\left[ \\delta \\mathbf{u}_e^{\\top} \\mathbf{B}^{\\top} \\mathbf{C} \\mathbf{B} \\mathbf{u}_e \\right] L = \\delta \\mathbf{u}_e^{\\top} \\left( L \\mathbf{B}^{\\top} \\mathbf{C} \\mathbf{B} \\mathbf{u}_e \\right)\n$$\nSince this equality must hold for any arbitrary virtual displacement $\\delta \\mathbf{u}_e$, we can identify the residual vector $\\mathbf{r}_e$:\n$$\n\\mathbf{r}_e = L \\mathbf{B}^{\\top} \\mathbf{C} \\mathbf{B} \\mathbf{u}_e\n$$\nThe consistent tangent stiffness matrix $\\mathbf{K}_e$ is defined as the derivative of the residual vector with respect to the nodal displacements $\\mathbf{u}_e$:\n$$\n\\mathbf{K}_e = \\frac{\\partial \\mathbf{r}_e}{\\partial \\mathbf{u}_e} = \\frac{\\partial}{\\partial \\mathbf{u}_e} \\left( L \\mathbf{B}^{\\top} \\mathbf{C} \\mathbf{B} \\mathbf{u}_e \\right)\n$$\nFor this linear problem, the derivative is simply:\n$$\n\\mathbf{K}_e = L \\mathbf{B}^{\\top} \\mathbf{C} \\mathbf{B}\n$$\nNotably, this implies $\\mathbf{r}_e = \\mathbf{K}_e \\mathbf{u}_e$, which is characteristic of a linear system.\n\n### Positive Semidefiniteness of $\\mathbf{K}_e$\nThe stiffness matrix $\\mathbf{K}_e$ must be positive semidefinite, which corresponds to the physical requirement that straining the element requires non-negative energy. To demonstrate this, we examine the quadratic form $\\mathbf{v}^{\\top} \\mathbf{K}_e \\mathbf{v}$ for an arbitrary displacement vector $\\mathbf{v} \\in \\mathbb{R}^8$.\n$$\n\\mathbf{v}^{\\top} \\mathbf{K}_e \\mathbf{v} = \\mathbf{v}^{\\top} (L \\mathbf{B}^{\\top} \\mathbf{C} \\mathbf{B}) \\mathbf{v} = L (\\mathbf{Bv})^{\\top} \\mathbf{C} (\\mathbf{Bv})\n$$\nLet $\\mathbf{w} = \\mathbf{Bv}$. This $2 \\times 1$ vector $\\mathbf{w} = [w_n, w_t]^\\top$ represents the local displacement jump corresponding to the nodal displacements $\\mathbf{v}$. The quadratic form becomes:\n$$\n\\mathbf{v}^{\\top} \\mathbf{K}_e \\mathbf{v} = L \\mathbf{w}^{\\top} \\mathbf{C} \\mathbf{w} = L \\begin{bmatrix} w_n & w_t \\end{bmatrix} \\begin{bmatrix} k_n & 0 \\\\ 0 & k_t \\end{bmatrix} \\begin{bmatrix} w_n \\\\ w_t \\end{bmatrix} = L (k_n w_n^2 + k_t w_t^2)\n$$\nGiven that element length $L > 0$ and the stiffness parameters $k_n, k_t \\ge 0$, the term $L (k_n w_n^2 + k_t w_t^2)$ is always non-negative. Thus, $\\mathbf{v}^{\\top} \\mathbf{K}_e \\mathbf{v} \\ge 0$, proving that $\\mathbf{K}_e$ is positive semidefinite. The matrix is not positive definite because non-zero displacement vectors $\\mathbf{v}$ corresponding to rigid-body motions result in zero jump ($\\mathbf{w}=\\mathbf{0}$) and thus zero strain energy. These vectors form the null space of $\\mathbf{K}_e$, leading to zero eigenvalues.\n\n### Implementation and Verification\nThe derived formulas for $\\mathbf{r}_e$ and $\\mathbf{K}_e$ are implemented in Python. The program constructs the necessary matrices ($\\mathbf{R}, \\mathbf{C}, \\mathbf{B}$) and then computes $\\mathbf{K}_e$ and $\\mathbf{r}_e$. This core computation is then applied to the five test cases specified in the problem statement.\n\n- **Test 1 (Analytical Force Distribution):** A uniform gap is applied. The computed internal force vector $\\mathbf{r}_e$ is compared to an analytically derived force vector based on static equilibrium. The one-point quadrature is exact for this case, so the relative error is expected to be near machine precision.\n- **Test 2 (Stiffness Symmetry Check):** The stiffness matrix $\\mathbf{K}_e = L \\mathbf{B}^\\top \\mathbf{C} \\mathbf{B}$ is symmetric by construction because the constitutive matrix $\\mathbf{C}$ is symmetric. The test numerically confirms this by computing the relative symmetry defect, which should be close to zero.\n- **Test 3 (Frame Invariance):** This test verifies objectivity. The internal force vector is computed for two different element orientations but the same physical deformation. The force vector in the second orientation, $\\mathbf{r}_e(\\theta_1)$, must be equivalent to the rotated force vector from the first orientation, $\\mathbf{Q} \\mathbf{r}_e(\\theta_0)$. The relative difference is computed and is expected to be near zero.\n- **Test 4 (Zero Tangential Stiffness):** A pure sliding deformation is applied with $k_t=0$. In this case, the constitutive law yields zero traction ($\\mathbf{t}^{\\text{loc}}=\\mathbf{0}$), since the normal opening $g_n$ is zero. Consequently, the internal force vector $\\mathbf{r}_e$ must be zero. The test confirms this by computing the norm of $\\mathbf{r}_e$.\n- **Test 5 (Positive Semidefiniteness):** The eigenvalues of $\\mathbf{K}_e$ are computed. As proven earlier, the matrix is positive semidefinite, meaning all eigenvalues must be non-negative. Due to the existence of rigid-body modes, the matrix has a null space. The rank of $\\mathbf{K}_e$ is at most $2$, so for an $8 \\times 8$ matrix, at least $6$ eigenvalues must be zero. The test reports the minimum eigenvalue, which is expected to be zero (within floating-point tolerance).", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_element_properties(L, theta, kn, kt):\n    \"\"\"\n    Computes matrices required for the interface element.\n    :param L: Length of the element\n    :param theta: Orientation angle in radians\n    :param kn: Normal stiffness\n    :param kt: Tangential stiffness\n    :return: R, C, B, Ke matrices\n    \"\"\"\n    c, s = np.cos(theta), np.sin(theta)\n    # Local-to-global rotation matrix\n    R = np.array([[-s, c], [c, s]])\n    \n    # Constitutive matrix\n    C = np.array([[kn, 0], [0, kt]])\n    \n    # B matrix for one-point quadrature, relates global u_e to local g\n    # B has shape (2, 8)\n    B_block = 0.5 * R.T\n    B = np.hstack([-B_block, -B_block, B_block, B_block])\n    \n    # Stiffness matrix Ke = L * B.T @ C @ B\n    Ke = L * (B.T @ C @ B)\n    \n    return R, C, B, Ke\n\ndef test1():\n    \"\"\"Analytical force distribution under uniform local gap.\"\"\"\n    L, theta, kn, kt = 2.0, 0.0, 1000.0, 500.0\n    g_local = np.array([0.01, -0.02])\n    \n    R, C, B, Ke = compute_element_properties(L, theta, kn, kt)\n    \n    # Define prescribed nodal displacements\n    u_plus_global = R @ g_local\n    u_e = np.zeros(8)\n    u_e[4:6] = u_plus_global  # Node 3 (+ side)\n    u_e[6:8] = u_plus_global  # Node 4 (+ side)\n    \n    # Compute residual vector from implementation\n    r_e_computed = Ke @ u_e\n    \n    # Analytical verification\n    t_loc = C @ g_local\n    # Formula r_e = L * B.T @ t_loc\n    r_e_exact = L * (B.T @ t_loc)\n\n    norm_exact = np.linalg.norm(r_e_exact)\n    if norm_exact == 0:\n        return 0.0 if np.linalg.norm(r_e_computed) == 0 else 1.0\n    \n    relative_error = np.linalg.norm(r_e_computed - r_e_exact) / norm_exact\n    return relative_error\n\ndef test2():\n    \"\"\"Stiffness symmetry check.\"\"\"\n    L, theta, kn, kt = 1.3, 0.37, 800.0, 1200.0\n    g_local = np.array([0.013, -0.007])\n    \n    R, C, B, Ke = compute_element_properties(L, theta, kn, kt)\n    \n    norm_Ke = np.linalg.norm(Ke, 'fro')\n    if norm_Ke == 0:\n        return 0.0\n        \n    symmetry_defect = np.linalg.norm(Ke - Ke.T, 'fro') / norm_Ke\n    return symmetry_defect\n\ndef test3():\n    \"\"\"Frame invariance under rotation.\"\"\"\n    L, kn, kt = 2.0, 900.0, 300.0\n    theta0, theta1 = 0.0, np.pi/3.0\n    g_local = np.array([0.02, 0.01])\n\n    # Case 0: theta = theta0\n    R0, C0, B0, Ke0 = compute_element_properties(L, theta0, kn, kt)\n    u_plus0 = R0 @ g_local\n    u_e0 = np.zeros(8)\n    u_e0[4:6], u_e0[6:8] = u_plus0, u_plus0\n    r_e0 = Ke0 @ u_e0\n\n    # Case 1: theta = theta1\n    R1, C1, B1, Ke1 = compute_element_properties(L, theta1, kn, kt)\n    u_plus1 = R1 @ g_local\n    u_e1 = np.zeros(8)\n    u_e1[4:6], u_e1[6:8] = u_plus1, u_plus1\n    r_e1 = Ke1 @ u_e1\n\n    # Transformation matrices\n    T = R1 @ R0.T\n    Q = np.kron(np.eye(4), T)\n    \n    r_e0_rotated = Q @ r_e0\n    \n    norm_r1 = np.linalg.norm(r_e1)\n    if norm_r1 == 0:\n        return 0.0 if np.linalg.norm(r_e0_rotated) == 0 else 1.0\n        \n    relative_diff = np.linalg.norm(r_e1 - r_e0_rotated) / norm_r1\n    return relative_diff\n\ndef test4():\n    \"\"\"Edge case with zero tangential stiffness.\"\"\"\n    L, theta, kn, kt = 3.0, 0.5, 700.0, 0.0\n    g_local = np.array([0.0, 0.05])\n\n    R, C, B, Ke = compute_element_properties(L, theta, kn, kt)\n    \n    u_plus = R @ g_local\n    u_e = np.zeros(8)\n    u_e[4:6], u_e[6:8] = u_plus, u_plus\n    \n    r_e = Ke @ u_e\n    return np.linalg.norm(r_e)\n\ndef test5():\n    \"\"\"Positive semidefiniteness benchmark.\"\"\"\n    L, theta, kn, kt = 1.0, 0.2, 1000.0, 500.0\n    \n    R, C, B, Ke = compute_element_properties(L, theta, kn, kt)\n    \n    eigenvalues = np.linalg.eigvalsh(Ke)\n    return np.min(eigenvalues)\n\ndef solve():\n    \"\"\"\n    Executes the test suite for the zero-thickness interface element.\n    \"\"\"\n    test_cases = [\n        test1,\n        test2,\n        test3,\n        test4,\n        test5\n    ]\n\n    results = []\n    for test_func in test_cases:\n        result = test_func()\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # High precision is used to show values are close to zero.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3571998"}, {"introduction": "While zero-thickness elements are a powerful abstraction, their parameters must be grounded in physical reality to yield meaningful results. This practice [@problem_id:3572014] builds a crucial bridge between the discrete interface model and its continuum counterpart—a thin, deformable layer. You will derive the exact equivalence between the interface stiffnesses, $K_n$ and $K_s$, and the bulk material properties ($E$, $\\nu$) and layer thickness ($h$), providing a rigorous method for calibrating your models from measurable physical data.", "problem": "A developer must implement a rigorous comparison between a zero-thickness interface model and two continuum idealizations (a finite-thickness elastic layer and a smeared band model) within the setting of small-strain, linear elastic, isotropic materials. The target is to verify, by derivation and computation, the conditions under which the zero-thickness interface model reproduces the traction and the energy response of the finite-thickness layer, and to quantify the deviation introduced by a smeared band model. The comparison must be carried out for mixed-mode (normal and shear) kinematics and tractions. The context is computational geomechanics, and the focus is on the constitutive equivalence and discrepancy of zero-thickness interface elements when measured against continuum representations.\n\nStarting point for the derivation must be: the balance of power and the principle of virtual work for interfaces and continua, the small-strain kinematic relations, and Hooke’s law for isotropic linear elasticity. The interface kinematics are defined by the displacement jump vector $\\boldsymbol{\\Delta} = [\\Delta_n,\\Delta_s]^T$, whose work-conjugate traction vector is $\\boldsymbol{t} = [t_n,t_s]^T$. The finite-thickness layer is a continuum of thickness $h$ and unit interfacial area, with normal strain $\\varepsilon_n$ and shear strain $\\gamma_s$ defined by through-thickness gradients of displacement. The smeared band model represents a damage or localization band of thickness $h_{\\mathrm{sm}}$ with elastic moduli $E_{\\mathrm{sm}}$ and $G_{\\mathrm{sm}}$ (with $G_{\\mathrm{sm}}$ obtained from Young’s modulus and Poisson’s ratio via isotropic elasticity), uniformly distributing the displacement jump $\\boldsymbol{\\Delta}$ over $h_{\\mathrm{sm}}$.\n\nYour tasks are:\n- Derive, from first principles, the exact conditions under which the traction and energy per unit area of a zero-thickness interface with a symmetric, mode-diagonal stiffness matrix $\\boldsymbol{K}=\\mathrm{diag}(K_n,K_s)$ are identical to those of a finite-thickness elastic layer. Then, formalize the smeared band expressions for traction and energy per unit area, and explain how they differ when $h_{\\mathrm{sm}}\\neq h$ or when the smeared moduli deviate from the values implied by equivalence.\n- Implement a program that, for a given test suite of material and geometric parameters, computes:\n    1. The shear modulus $G$ from Young’s modulus $E$ and Poisson’s ratio $\\nu$ using isotropic linear elasticity.\n    2. The zero-thickness interface tractions $\\boldsymbol{t}^{\\mathrm{zt}}$ and energy per unit area $w^{\\mathrm{zt}}$ from $\\boldsymbol{\\Delta}$ and $\\boldsymbol{K}$.\n    3. The finite-thickness layer tractions $\\boldsymbol{t}^{\\mathrm{ft}}$ and energy per unit area $w^{\\mathrm{ft}}$ from $E$, $G$, $h$, and $\\boldsymbol{\\Delta}$.\n    4. The smeared band tractions $\\boldsymbol{t}^{\\mathrm{sm}}$ and energy per unit area $w^{\\mathrm{sm}}$ from $E_{\\mathrm{sm}}$, $G_{\\mathrm{sm}}$, $h_{\\mathrm{sm}}$, and $\\boldsymbol{\\Delta}$.\n    5. The relative error in traction magnitude and the relative error in energy per unit area between the smeared band model and the zero-thickness interface model, defined as\n       $$e_t=\\frac{\\left\\|\\boldsymbol{t}^{\\mathrm{sm}}\\right\\|_2-\\left\\|\\boldsymbol{t}^{\\mathrm{zt}}\\right\\|_2}{\\max\\left(\\left\\|\\boldsymbol{t}^{\\mathrm{zt}}\\right\\|_2,\\varepsilon\\right)},\\quad e_w=\\frac{w^{\\mathrm{sm}}-w^{\\mathrm{zt}}}{\\max\\left(w^{\\mathrm{zt}},\\varepsilon\\right)},$$\n       where $\\varepsilon$ is a small positive number used only to avoid division by zero, and $\\|\\cdot\\|_2$ denotes the Euclidean norm.\n\nUnits and numerical specifications:\n- Young’s modulus $E$ must be given in pascals ($\\mathrm{Pa}$).\n- Poisson’s ratio $\\nu$ is dimensionless.\n- Thicknesses $h$ and $h_{\\mathrm{sm}}$ must be given in meters ($\\mathrm{m}$).\n- Displacement jumps $\\Delta_n$ and $\\Delta_s$ must be given in meters ($\\mathrm{m}$).\n- Tractions are in pascals ($\\mathrm{Pa}$), and energy per unit area is in joules per square meter ($\\mathrm{J}/\\mathrm{m}^2$).\n- Angles are not involved in this problem.\n\nTest suite:\n- Case $1$: $E=30\\times 10^9\\,\\mathrm{Pa}$, $\\nu=0.25$, $h=1.0\\times 10^{-2}\\,\\mathrm{m}$, $\\Delta_n=1.0\\times 10^{-4}\\,\\mathrm{m}$, $\\Delta_s=2.0\\times 10^{-4}\\,\\mathrm{m}$, $h_{\\mathrm{sm}}=2.0\\times 10^{-2}\\,\\mathrm{m}$, $E_{\\mathrm{sm}}=E$, $\\nu_{\\mathrm{sm}}=\\nu$.\n- Case $2$: $E=35\\times 10^9\\,\\mathrm{Pa}$, $\\nu=0.30$, $h=5.0\\times 10^{-3}\\,\\mathrm{m}$, $\\Delta_n=0.0\\,\\mathrm{m}$, $\\Delta_s=3.0\\times 10^{-4}\\,\\mathrm{m}$, $h_{\\mathrm{sm}}=1.0\\times 10^{-2}\\,\\mathrm{m}$, $E_{\\mathrm{sm}}=E\\cdot h_{\\mathrm{sm}}/h$, $\\nu_{\\mathrm{sm}}=\\nu$.\n- Case $3$: $E=20\\times 10^9\\,\\mathrm{Pa}$, $\\nu=0.20$, $h=1.0\\times 10^{-6}\\,\\mathrm{m}$, $\\Delta_n=1.0\\times 10^{-5}\\,\\mathrm{m}$, $\\Delta_s=0.0\\,\\mathrm{m}$, $h_{\\mathrm{sm}}=1.0\\times 10^{-3}\\,\\mathrm{m}$, $E_{\\mathrm{sm}}=E$, $\\nu_{\\mathrm{sm}}=\\nu$.\n- Case $4$: $E=50\\times 10^9\\,\\mathrm{Pa}$, $\\nu=0.33$, $h=2.5\\times 10^{-2}\\,\\mathrm{m}$, $\\Delta_n=-2.0\\times 10^{-4}\\,\\mathrm{m}$, $\\Delta_s=1.0\\times 10^{-4}\\,\\mathrm{m}$, $h_{\\mathrm{sm}}=2.5\\times 10^{-2}\\,\\mathrm{m}$, $E_{\\mathrm{sm}}=0.5\\,E$, $\\nu_{\\mathrm{sm}}=\\nu$.\n\nFinal output specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $[e_t^{(1)},e_w^{(1)},e_t^{(2)},e_w^{(2)},e_t^{(3)},e_w^{(3)},e_t^{(4)},e_w^{(4)}]$, where superscripts denote the test case index. Each $e_t^{(i)}$ and $e_w^{(i)}$ must be a floating-point number.", "solution": "The problem requires a derivation of the equivalence conditions between a zero-thickness interface model and a finite-thickness elastic layer model, and a subsequent comparison with a smeared band model. This will be followed by a computational implementation to quantify the discrepancies for a given set of parameters.\n\nThe analysis is grounded in the principles of continuum mechanics for small-strain, linear elastic, isotropic materials. We consider a local coordinate system with the $n$-axis normal to the interface/layer and the $s$-axis tangential to it in the direction of shear.\n\n**1. Finite-Thickness Layer Model (ft)**\n\nWe consider a thin, continuous layer of material with thickness $h$, Young's modulus $E$, and Poisson's ratio $\\nu$. The layer has a unit area. A relative displacement, or jump, $\\boldsymbol{\\Delta} = [\\Delta_n, \\Delta_s]^T$ is imposed across its thickness. Assuming this jump is distributed uniformly through the thickness, we can define the average engineering strains within the layer as:\n$$ \\varepsilon_n = \\frac{\\Delta_n}{h} \\quad \\text{and} \\quad \\gamma_s = \\frac{\\Delta_s}{h} $$\nTo relate these strains to tractions, we must assume a stress state. For a thin layer embedded within a larger continuum, it is standard practice in geomechanics to assume a state of uniaxial strain, where the layer is constrained from deforming parallel to its plane. That is, the strains in the directions parallel to the interface are zero.\n\nFor an isotropic linear elastic material, the shear stress $\\tau_s$ is related to the shear strain $\\gamma_s$ via the shear modulus $G$:\n$$ t_s^{\\mathrm{ft}} = \\tau_s = G \\gamma_s = G \\frac{\\Delta_s}{h} $$\nwhere the shear modulus $G$ is given by\n$$ G = \\frac{E}{2(1+\\nu)} $$\nThe normal stress $\\sigma_n$ under uniaxial strain conditions (i.e., $\\varepsilon_s = \\varepsilon_t = 0$ in a 3D context) is related to the normal strain $\\varepsilon_n$ via the P-wave modulus (or constrained modulus) $M$:\n$$ t_n^{\\mathrm{ft}} = \\sigma_n = M \\varepsilon_n = M \\frac{\\Delta_n}{h} $$\nwhere the P-wave modulus $M$ is given by:\n$$ M = \\frac{E(1-\\nu)}{(1+\\nu)(1-2\\nu)} $$\nCombining these, the traction vector for the finite-thickness layer is:\n$$ \\boldsymbol{t}^{\\mathrm{ft}} = \\begin{bmatrix} t_n^{\\mathrm{ft}} \\\\ t_s^{\\mathrm{ft}} \\end{bmatrix} = \\begin{bmatrix} (M/h) \\Delta_n \\\\ (G/h) \\Delta_s \\end{bmatrix} $$\nThe elastic strain energy stored per unit area, $w^{\\mathrm{ft}}$, is the work done by the tractions. For a linear system, this is given by $w = \\frac{1}{2} \\boldsymbol{t}^T \\boldsymbol{\\Delta}$. The energy can also be found by integrating the strain energy density $U = \\frac{1}{2}(\\sigma_n \\varepsilon_n + \\tau_s \\gamma_s)$ over the thickness $h$:\n$$ w^{\\mathrm{ft}} = \\int_0^h U \\,dz = \\frac{1}{2} (\\sigma_n \\varepsilon_n + \\tau_s \\gamma_s) h = \\frac{1}{2} \\left( \\left(M \\frac{\\Delta_n}{h}\\right) \\frac{\\Delta_n}{h} + \\left(G \\frac{\\Delta_s}{h}\\right) \\frac{\\Delta_s}{h} \\right) h $$\n$$ w^{\\mathrm{ft}} = \\frac{1}{2} \\left( \\frac{M}{h} \\Delta_n^2 + \\frac{G}{h} \\Delta_s^2 \\right) $$\n\n**2. Zero-Thickness Interface Model (zt)**\n\nThis model relates the traction vector $\\boldsymbol{t}^{\\mathrm{zt}}$ directly to the displacement jump vector $\\boldsymbol{\\Delta}$ through a constitutive stiffness matrix $\\boldsymbol{K}$.\n$$ \\boldsymbol{t}^{\\mathrm{zt}} = \\boldsymbol{K} \\boldsymbol{\\Delta} $$\nGiven that the stiffness matrix is symmetric and diagonal, $\\boldsymbol{K} = \\mathrm{diag}(K_n, K_s)$, the tractions are:\n$$ t_n^{\\mathrm{zt}} = K_n \\Delta_n \\quad \\text{and} \\quad t_s^{\\mathrm{zt}} = K_s \\Delta_s $$\nThe elastic energy stored per unit area, $w^{\\mathrm{zt}}$, is:\n$$ w^{\\mathrm{zt}} = \\frac{1}{2} \\boldsymbol{t}^{\\mathrm{zt} T} \\boldsymbol{\\Delta} = \\frac{1}{2} (\\boldsymbol{K} \\boldsymbol{\\Delta})^T \\boldsymbol{\\Delta} = \\frac{1}{2} (K_n \\Delta_n^2 + K_s \\Delta_s^2) $$\n\n**3. Equivalence Conditions (zt vs. ft)**\n\nFor the zero-thickness interface model to be equivalent to the finite-thickness layer model, their responses must be identical for any given displacement jump $\\boldsymbol{\\Delta}$. This requires equating their respective tractions and stored energies.\n\nEquating the traction vectors, $\\boldsymbol{t}^{\\mathrm{zt}} = \\boldsymbol{t}^{\\mathrm{ft}}$:\n$$ K_n \\Delta_n = \\frac{M}{h} \\Delta_n \\implies K_n = \\frac{M}{h} = \\frac{E(1-\\nu)}{h(1+\\nu)(1-2\\nu)} $$\n$$ K_s \\Delta_s = \\frac{G}{h} \\Delta_s \\implies K_s = \\frac{G}{h} = \\frac{E}{2h(1+\\nu)} $$\nThese are the exact conditions for the interface stiffnesses $K_n$ and $K_s$ to reproduce the mechanical behavior of a finite-thickness elastic layer of thickness $h$, modulus $E$, and Poisson's ratio $\\nu$, under the assumption of uniaxial strain. Substituting these stiffness values into the energy expression for $w^{\\mathrm{zt}}$ demonstrates that the energy $w^{\\mathrm{ft}}$ is also matched. For the remainder of this analysis, the zero-thickness model will use these stiffness values, establishing it as the benchmark.\n\n**4. Smeared Band Model (sm)**\n\nThe smeared band model is mathematically identical in form to the finite-thickness layer model, but it is applied over a conceptual \"smeared\" thickness $h_{\\mathrm{sm}}$ with potentially different material properties $E_{\\mathrm{sm}}$ and $\\nu_{\\mathrm{sm}}$. The purpose is often to regularize localization phenomena in numerical simulations.\n\nThe strains are defined over the smeared thickness:\n$$ \\varepsilon_n^{\\mathrm{sm}} = \\frac{\\Delta_n}{h_{\\mathrm{sm}}} \\quad \\text{and} \\quad \\gamma_s^{\\mathrm{sm}} = \\frac{\\Delta_s}{h_{\\mathrm{sm}}} $$\nThe tractions are derived similarly, using the smeared material properties $G_{\\mathrm{sm}}$ and $M_{\\mathrm{sm}}$:\n$$ G_{\\mathrm{sm}} = \\frac{E_{\\mathrm{sm}}}{2(1+\\nu_{\\mathrm{sm}})} \\quad \\text{and} \\quad M_{\\mathrm{sm}} = \\frac{E_{\\mathrm{sm}}(1-\\nu_{\\mathrm{sm}})}{(1+\\nu_{\\mathrm{sm}})(1-2\\nu_{\\mathrm{sm}})} $$\n$$ t_n^{\\mathrm{sm}} = \\frac{M_{\\mathrm{sm}}}{h_{\\mathrm{sm}}} \\Delta_n \\quad \\text{and} \\quad t_s^{\\mathrm{sm}} = \\frac{G_{\\mathrm{sm}}}{h_{\\mathrm{sm}}} \\Delta_s $$\nThe traction vector is $\\boldsymbol{t}^{\\mathrm{sm}} = [t_n^{\\mathrm{sm}}, t_s^{\\mathrm{sm}}]^T$.\nThe energy per unit area is:\n$$ w^{\\mathrm{sm}} = \\frac{1}{2} \\left( \\frac{M_{\\mathrm{sm}}}{h_{\\mathrm{sm}}} \\Delta_n^2 + \\frac{G_{\\mathrm{sm}}}{h_{\\mathrm{sm}}} \\Delta_s^2 \\right) $$\n\n**5. Discrepancy Analysis (sm vs. zt)**\n\nThe smeared model's response deviates from the benchmark zero-thickness (or finite-thickness) model whenever its effective stiffnesses differ. The effective stiffnesses for the smeared model are $K_n^{\\mathrm{sm}} = M_{\\mathrm{sm}}/h_{\\mathrm{sm}}$ and $K_s^{\\mathrm{sm}} = G_{\\mathrm{sm}}/h_{\\mathrm{sm}}$.\n\nDiscrepancy arises if $K_n^{\\mathrm{sm}} \\neq K_n$ or $K_s^{\\mathrm{sm}} \\neq K_s$. This occurs if the parameters $(h_{\\mathrm{sm}}, E_{\\mathrm{sm}}, \\nu_{\\mathrm{sm}})$ are not chosen to match the reference stiffnesses $(K_n, K_s) = (M/h, G/h)$. For instance, if $E_{\\mathrm{sm}} = E$ and $\\nu_{\\mathrm{sm}} = \\nu$, but $h_{\\mathrm{sm}} \\neq h$, the effective stiffnesses will be scaled by a factor of $h/h_{\\mathrm{sm}}$. This will lead to an incorrect prediction of tractions and energy.\n\nA special case arises when the smeared parameters are chosen to preserve the stiffness of the original physical layer. This is known as stiffness-equivalent smearing. If we set $\\nu_{\\mathrm{sm}}=\\nu$ and scale the Young's modulus as $E_{\\mathrm{sm}} = E (h_{\\mathrm{sm}}/h)$, we find:\n$$ K_s^{\\mathrm{sm}} = \\frac{G_{\\mathrm{sm}}}{h_{\\mathrm{sm}}} = \\frac{E_{\\mathrm{sm}}}{2(1+\\nu_{\\mathrm{sm}})h_{\\mathrm{sm}}} = \\frac{E(h_{\\mathrm{sm}}/h)}{2(1+\\nu)h_{\\mathrm{sm}}} = \\frac{G}{h} = K_s $$\n$$ K_n^{\\mathrm{sm}} = \\frac{M_{\\mathrm{sm}}}{h_{\\mathrm{sm}}} = \\frac{E_{\\mathrm{sm}}(1-\\nu_{\\mathrm{sm}})}{h_{\\mathrm{sm}}(1+\\nu_{\\mathrm{sm}})(1-2\\nu_{\\mathrm{sm}})} = \\frac{E(h_{\\mathrm{sm}}/h)(1-\\nu)}{h_{\\mathrm{sm}}(1+\\nu)(1-2\\nu)} = \\frac{M}{h} = K_n $$\nIn this specific case, the smeared band model exactly reproduces the response of the reference models, and the errors $e_t$ and $e_w$ will be zero. Any other choice for the smeared parameters will introduce a quantifiable modeling error.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the relative errors in traction and energy for a smeared band model\n    compared to a benchmark zero-thickness interface model.\n    \"\"\"\n    # Small number to prevent division by zero in error calculations\n    epsilon = 1e-12\n\n    # Test suite with material and geometric parameters for 4 cases.\n    test_cases = [\n        {\n            \"E\": 30e9, \"nu\": 0.25, \"h\": 1.0e-2, \n            \"Delta_n\": 1.0e-4, \"Delta_s\": 2.0e-4,\n            \"h_sm\": 2.0e-2, \"E_sm_def\": \"E\", \"nu_sm\": 0.25\n        },\n        {\n            \"E\": 35e9, \"nu\": 0.30, \"h\": 5.0e-3, \n            \"Delta_n\": 0.0, \"Delta_s\": 3.0e-4,\n            \"h_sm\": 1.0e-2, \"E_sm_def\": \"E*h_sm/h\", \"nu_sm\": 0.30\n        },\n        {\n            \"E\": 20e9, \"nu\": 0.20, \"h\": 1.0e-6, \n            \"Delta_n\": 1.0e-5, \"Delta_s\": 0.0,\n            \"h_sm\": 1.0e-3, \"E_sm_def\": \"E\", \"nu_sm\": 0.20\n        },\n        {\n            \"E\": 50e9, \"nu\": 0.33, \"h\": 2.5e-2, \n            \"Delta_n\": -2.0e-4, \"Delta_s\": 1.0e-4,\n            \"h_sm\": 2.5e-2, \"E_sm_def\": \"0.5*E\", \"nu_sm\": 0.33\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Extract parameters for the current case\n        E, nu, h = case[\"E\"], case[\"nu\"], case[\"h\"]\n        Delta_n, Delta_s = case[\"Delta_n\"], case[\"Delta_s\"]\n        h_sm, nu_sm = case[\"h_sm\"], case[\"nu_sm\"]\n\n        # 1. Calculations for the reference zero-thickness model (zt)\n        # This model is equivalent to the finite-thickness layer model.\n        \n        # Calculate material properties for the reference layer\n        G = E / (2 * (1 + nu))\n        # Handle potential singularity for nu=0.5, though not in test cases\n        if abs(1 - 2 * nu)  epsilon:\n            # For incompressible material, M is infinite.\n            # In a real scenario, this would need special handling.\n            # For this problem, test cases avoid this.\n            M = float('inf')\n        else:\n            M = E * (1 - nu) / ((1 + nu) * (1 - 2 * nu))\n            \n        # Calculate reference interface stiffnesses\n        K_n = M / h\n        K_s = G / h\n\n        # Calculate tractions for the zero-thickness model\n        t_n_zt = K_n * Delta_n\n        t_s_zt = K_s * Delta_s\n        t_zt = np.array([t_n_zt, t_s_zt])\n\n        # Calculate energy per unit area for the zero-thickness model\n        w_zt = 0.5 * (K_n * Delta_n**2 + K_s * Delta_s**2)\n\n        # 2. Calculations for the smeared band model (sm)\n\n        # Determine E_sm based on its definition for the case\n        if case[\"E_sm_def\"] == \"E\":\n            E_sm = E\n        elif case[\"E_sm_def\"] == \"E*h_sm/h\":\n            E_sm = E * h_sm / h\n        elif case[\"E_sm_def\"] == \"0.5*E\":\n            E_sm = 0.5 * E\n        else:\n            raise ValueError(f\"Unknown E_sm definition: {case['E_sm_def']}\")\n\n        # Calculate material properties for the smeared band\n        G_sm = E_sm / (2 * (1 + nu_sm))\n        if abs(1 - 2 * nu_sm)  epsilon:\n             M_sm = float('inf')\n        else:\n             M_sm = E_sm * (1 - nu_sm) / ((1 + nu_sm) * (1 - 2 * nu_sm))\n\n        # Calculate tractions for the smeared band model\n        t_n_sm = (M_sm / h_sm) * Delta_n\n        t_s_sm = (G_sm / h_sm) * Delta_s\n        t_sm = np.array([t_n_sm, t_s_sm])\n\n        # Calculate energy per unit area for the smeared band model\n        w_sm = 0.5 * ((M_sm / h_sm) * Delta_n**2 + (G_sm / h_sm) * Delta_s**2)\n\n        # 3. Calculate relative errors\n        \n        # Traction error\n        norm_t_zt = np.linalg.norm(t_zt)\n        norm_t_sm = np.linalg.norm(t_sm)\n        e_t = (norm_t_sm - norm_t_zt) / max(norm_t_zt, epsilon)\n        \n        # Energy error\n        e_w = (w_sm - w_zt) / max(w_zt, epsilon)\n\n        results.extend([e_t, e_w])\n\n    # Format the final output string as specified\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```", "id": "3572014"}, {"introduction": "Geological interfaces are rarely perfectly elastic; they slip, stick, and dissipate energy. This advanced practice [@problem_id:3571923] moves beyond linear behavior to tackle the non-linear and non-smooth nature of Coulomb friction. You will derive the generalized Jacobian for a semi-smooth Newton method, enabling you to build a robust solver that can capture the abrupt transitions between stick and slip states. Mastering this technique is a critical step towards realistically modeling complex phenomena like fault activation and frictional contact.", "problem": "Consider a single zero-thickness interface element in computational geomechanics subjected to tangential loading under compressive normal contact. The interface has two nodes that coincide geometrically, and the relative tangential displacement across the interface is represented by the vector $\\,\\mathbf{u}_t \\in \\mathbb{R}^2\\,$. The normal contact is assumed to be perfectly closed, with a prescribed compressive normal traction $\\,t_n  0\\,$. The tangential behavior follows the classical Coulomb friction law: the magnitude of the tangential traction $\\,\\|\\mathbf{t}_t\\|\\,$ is bounded by $\\,\\mu\\, t_n\\,$ where $\\,\\mu  0\\,$ is the friction coefficient, and the direction of $\\,\\mathbf{t}_t\\,$ aligns with the trial tangential traction when sliding occurs.\n\nThe interface is attached to a linear elastic bulk represented by an effective shear stiffness $\\,k_b  0\\,$ such that the far-field imposed shear displacement $\\,\\mathbf{w} \\in \\mathbb{R}^2\\,$ is equilibrated by the interface response. The tangential elastic stiffness of the interface in the stick regime is $\\,k_t  0\\,$. The governing equilibrium equation for the interface in terms of the unknown $\\,\\mathbf{u}_t\\,$ is\n$$\n\\mathbf{R}(\\mathbf{u}_t) \\equiv \\mathbf{K}_b \\left(\\mathbf{w} - \\mathbf{u}_t\\right) - \\mathbf{t}_t(\\mathbf{u}_t) = \\mathbf{0},\n$$\nwhere $\\,\\mathbf{K}_b = k_b \\mathbf{I}\\,$ and $\\,\\mathbf{I}\\,$ is the $\\,2\\times2\\,$ identity. The tangential traction mapping $\\,\\mathbf{t}_t(\\mathbf{u}_t)\\,$ is defined by an elastic predictor followed by Coulomb projection:\n1. Compute the elastic trial traction $\\,\\mathbf{t}_t^{\\text{trial}} = k_t\\,\\mathbf{u}_t\\,$.\n2. If $\\,\\left\\|\\mathbf{t}_t^{\\text{trial}}\\right\\| \\le \\mu t_n\\,$ (stick), then $\\,\\mathbf{t}_t = \\mathbf{t}_t^{\\text{trial}}\\,$.\n3. If $\\,\\left\\|\\mathbf{t}_t^{\\text{trial}}\\right\\|  \\mu t_n\\,$ (slip), then $\\,\\mathbf{t}_t = \\mu t_n \\,\\dfrac{\\mathbf{t}_t^{\\text{trial}}}{\\left\\|\\mathbf{t}_t^{\\text{trial}}\\right\\|}\\,$.\n\nStarting from fundamental balance principles and the Coulomb law, derive the consistent tangent needed to apply a Semi-Smooth Newton (SSN) method, that is, derive the generalized Jacobian $\\,\\mathbf{J}(\\mathbf{u}_t)\\,$ of $\\,\\mathbf{R}(\\mathbf{u}_t)\\,$ suitable for stick–slip transitions. Implement a SSN algorithm that:\n- Assembles $\\,\\mathbf{R}(\\mathbf{u}_t)\\,$ and a consistent generalized derivative $\\,\\mathbf{J}(\\mathbf{u}_t)\\,$ at each iteration.\n- Uses a robust linear solver with a fallback strategy when $\\,\\mathbf{J}\\,$ is ill-conditioned.\n- Optionally applies a simple backtracking line search to ensure residual decrease if needed.\n- Terminates when the Euclidean norm $\\,\\|\\mathbf{R}(\\mathbf{u}_t)\\|\\,$ is below a tolerance.\n\nQuantify the convergence behavior by reporting for each test case:\n- The number of SSN iterations until convergence (integer).\n- An observed $\\,q$-linear rate computed as the ratio $\\,\\|\\mathbf{R}_{k+1}\\| / \\|\\mathbf{R}_k\\|\\,$ based on the last two available iterations (float; use $\\,0.0\\,$ if fewer than two iterations occurred).\n- A boolean indicating whether convergence was achieved within the maximum allowed iterations.\n- The final regime code for the converged solution: $\\,0\\,$ for stick and $\\,1\\,$ for slip.\n\nYou must answer in nondimensional units; all parameters and outputs are unitless. Use radians for any directional computation implicitly required by vector normalization.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a list $\\,[$iterations, rate, converged, regime$]$. For example, the output format must be like $\\,\\left[ [i_1,r_1,c_1,s_1],[i_2,r_2,c_2,s_2],\\dots \\right]\\,$.\n\nTest Suite. Implement and run your solver for the following parameter sets to exercise different regimes, including happy-path, boundary, and edge cases with large frictional jumps:\n\n- Case A (stick-dominated): $\\,k_b=500\\,$, $\\,k_t=1000\\,$, $\\,\\mu=0.3\\,$, $\\,t_n=100\\,$, $\\,\\mathbf{w}=(0.05,\\,0.02)\\,$.\n- Case B (slip with large jump): $\\,k_b=500\\,$, $\\,k_t=1000\\,$, $\\,\\mu=0.3\\,$, $\\,t_n=100\\,$, $\\,\\mathbf{w}=(0.5,\\,0.3)\\,$.\n- Case C (near-boundary, high friction capacity): $\\,k_b=500\\,$, $\\,k_t=1000\\,$, $\\,\\mu=2.0\\,$, $\\,t_n=100\\,$, $\\,\\mathbf{w}=(0.5,\\,0.3)\\,$.\n- Case D (direction flip, slip): $\\,k_b=500\\,$, $\\,k_t=1000\\,$, $\\,\\mu=0.3\\,$, $\\,t_n=100\\,$, $\\,\\mathbf{w}=(-0.6,\\,0.0)\\,$.\n- Case E (exact-boundary magnitude in one direction): $\\,k_b=500\\,$, $\\,k_t=1000\\,$, $\\,\\mu=0.3\\,$, $\\,t_n=100\\,$, $\\,\\mathbf{w}=(0.09,\\,0.0)\\,$.\n\nYour implementation must be a complete, runnable program that computes the requested outputs for all test cases and prints a single line in the specified format.", "solution": "We start from balance of linear momentum reduced to a discrete interface equilibrium. The zero-thickness interface element has coincident nodes and bears only traction across the interface. The tangential displacement jump is $\\,\\mathbf{u}_t \\in \\mathbb{R}^2\\,$, the compressive normal traction is $\\,t_n > 0\\,$, and friction follows the Coulomb law: $\\,\\|\\mathbf{t}_t\\| \\le \\mu t_n\\,$, where $\\,\\mu > 0\\,$ is the friction coefficient. The bulk shear response is represented by a linear relation $\\,\\mathbf{K}_b(\\mathbf{w}-\\mathbf{u}_t)\\,$ with $\\,\\mathbf{K}_b = k_b \\mathbf{I}\\,$ and imposed displacement $\\,\\mathbf{w}\\,$. The interface tangential stiffness in the stick regime is $\\,k_t > 0\\,$.\n\nFundamental laws and core definitions. The discrete equilibrium across the interface comes from enforcing the traction balance between the bulk and the interface:\n$$\n\\mathbf{R}(\\mathbf{u}_t) \\equiv \\mathbf{K}_b \\left(\\mathbf{w} - \\mathbf{u}_t\\right) - \\mathbf{t}_t(\\mathbf{u}_t) = \\mathbf{0}.\n$$\nThe frictional traction mapping $\\,\\mathbf{t}_t(\\mathbf{u}_t)\\,$ is defined by the Coulomb law with an elastic predictor $\\,\\mathbf{t}_t^{\\text{trial}} = k_t \\mathbf{u}_t\\,$ and a projection onto the friction disc of radius $\\,\\mu t_n\\,$:\n- Stick: if $\\,\\left\\|\\mathbf{t}_t^{\\text{trial}}\\right\\| \\le \\mu t_n\\,$, then $\\,\\mathbf{t}_t = \\mathbf{t}_t^{\\text{trial}} = k_t \\mathbf{u}_t\\,$.\n- Slip: if $\\,\\left\\|\\mathbf{t}_t^{\\text{trial}}\\right\\| > \\mu t_n\\,$, then $\\,\\mathbf{t}_t = \\mu t_n \\,\\dfrac{\\mathbf{t}_t^{\\text{trial}}}{\\left\\|\\mathbf{t}_t^{\\text{trial}}\\right\\|}\\,$.\n\nSemi-smooth formulation. The residual $\\,\\mathbf{R}(\\mathbf{u}_t)\\,$ is non-smooth due to the projection operator at the stick–slip boundary. A Semi-Smooth Newton (SSN) method uses elements of the generalized Jacobian (in the sense of Clarke) to construct search directions. We derive a consistent generalized derivative $\\,\\mathbf{J}(\\mathbf{u}_t) = \\dfrac{\\partial \\mathbf{R}}{\\partial \\mathbf{u}_t}\\,$ piecewise.\n\nConsistent tangent in stick. In the stick regime, we have $\\,\\mathbf{t}_t(\\mathbf{u}_t) = k_t \\mathbf{u}_t\\,$. Therefore,\n$$\n\\frac{\\partial \\mathbf{t}_t}{\\partial \\mathbf{u}_t} = k_t \\mathbf{I},\n\\qquad\n\\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{u}_t} = -\\mathbf{K}_b - k_t \\mathbf{I} = -(k_b + k_t)\\mathbf{I}.\n$$\nThis derivative is symmetric and negative definite since $\\,k_b > 0\\,$ and $\\,k_t > 0\\,$.\n\nConsistent tangent in slip. In the slip regime, define the trial traction $\\,\\mathbf{q} \\equiv \\mathbf{t}_t^{\\text{trial}} = k_t \\mathbf{u}_t\\,$, its magnitude $\\,q \\equiv \\|\\mathbf{q}\\|\\,$, and the unit direction $\\,\\mathbf{n} \\equiv \\dfrac{\\mathbf{q}}{q}\\,$. The projected traction is $\\,\\mathbf{t}_t = \\mu t_n \\mathbf{n}\\,$. The variation of $\\,\\mathbf{n}\\,$ with respect to $\\,\\mathbf{q}\\,$ is\n$$\nd\\mathbf{n} = \\frac{1}{q} \\left( \\mathbf{I} - \\mathbf{n}\\mathbf{n}^\\top \\right) d\\mathbf{q}.\n$$\nWith $\\,\\mathbf{q} = k_t \\mathbf{u}_t\\,$, we have $\\,d\\mathbf{q} = k_t\\, d\\mathbf{u}_t\\,$, and thus\n$$\nd\\mathbf{t}_t = \\mu t_n\\, d\\mathbf{n} = \\mu t_n \\frac{1}{q} \\left( \\mathbf{I} - \\mathbf{n}\\mathbf{n}^\\top \\right) k_t\\, d\\mathbf{u}_t.\n$$\nTherefore, a consistent generalized derivative in the slip regime is\n$$\n\\frac{\\partial \\mathbf{t}_t}{\\partial \\mathbf{u}_t} = \\frac{\\mu t_n\\, k_t}{\\|\\mathbf{t}_t^{\\text{trial}}\\|} \\left( \\mathbf{I} - \\mathbf{n}\\mathbf{n}^\\top \\right),\n\\qquad\n\\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{u}_t} = -\\mathbf{K}_b - \\frac{\\mu t_n\\, k_t}{\\|\\mathbf{t}_t^{\\text{trial}}\\|} \\left( \\mathbf{I} - \\mathbf{n}\\mathbf{n}^\\top \\right).\n$$\nNote that the derivative along $\\,\\mathbf{n}\\,$ is zero in slip, which reflects that the traction magnitude is fixed to $\\,\\mu t_n\\,$ and only its direction changes with $\\,\\mathbf{u}_t\\,$. The matrix $\\,\\left( \\mathbf{I} - \\mathbf{n}\\mathbf{n}^\\top \\right)\\,$ is a projector onto the subspace orthogonal to $\\,\\mathbf{n}\\,$.\n\nAlgorithmic design of the Semi-Smooth Newton (SSN). At iteration $\\,k\\,$ with current estimate $\\,\\mathbf{u}_t^{(k)}\\,$:\n1. Compute $\\,\\mathbf{q}^{(k)} = k_t \\mathbf{u}_t^{(k)}\\,$, $\\,q^{(k)} = \\|\\mathbf{q}^{(k)}\\|\\,$, and $\\,\\mathbf{n}^{(k)} = \\dfrac{\\mathbf{q}^{(k)}}{q^{(k)}}\\,$ if $\\,q^{(k)} > 0\\,$.\n2. Evaluate the traction $\\,\\mathbf{t}_t^{(k)}\\,$ by stick–slip decision against $\\,\\mu t_n\\,$.\n3. Assemble the residual $\\,\\mathbf{R}^{(k)} = \\mathbf{K}_b\\left(\\mathbf{w} - \\mathbf{u}_t^{(k)}\\right) - \\mathbf{t}_t^{(k)}\\,$.\n4. Assemble the generalized Jacobian $\\,\\mathbf{J}^{(k)} = \\dfrac{\\partial \\mathbf{R}}{\\partial \\mathbf{u}_t}\\,$ using the stick or slip formula derived above. If $\\,q^{(k)} \\approx 0\\,$ in slip, regularize by using a small $\\,\\epsilon > 0\\,$ in the denominator.\n5. Solve the linear system $\\,\\mathbf{J}^{(k)} \\Delta \\mathbf{u}_t^{(k)} = -\\mathbf{R}^{(k)}\\,$. If $\\,\\mathbf{J}^{(k)}\\,$ is ill-conditioned, use a fallback such as a steepest-descent step $\\,\\Delta \\mathbf{u}_t^{(k)} = -\\mathbf{R}^{(k)}\\,$.\n6. Optionally perform backtracking line search to ensure residual decrease: pick $\\,\\alpha \\in (0,1]\\,$ and update $\\,\\mathbf{u}_t^{(k+1)} = \\mathbf{u}_t^{(k)} + \\alpha \\Delta \\mathbf{u}_t^{(k)}\\,$, reducing $\\,\\alpha\\,$ if $\\,\\|\\mathbf{R}^{(k+1)}\\|\\,$ increases.\n7. Stop when $\\,\\|\\mathbf{R}^{(k)}\\| \\le \\text{tol}\\,$, otherwise continue up to a maximum number of iterations.\n\nConvergence quantification. The $\\,q$-linear rate is observed as the ratio $\\,\\rho_k = \\|\\mathbf{R}^{(k+1)}\\| / \\|\\mathbf{R}^{(k)}\\|\\,$ taken from the last two available iterations. In smooth stick, the derivative is constant and Newton should be one-step convergent for a linear system; in slip, the generalized derivative induces linear convergence near the non-smooth boundary but often superlinear behavior when away from kinks due to the projector structure. Large frictional jumps (for instance, when $\\,\\|\\mathbf{t}_t^{\\text{trial}}\\|\\,$ and $\\,\\mu t_n\\,$ differ by orders of magnitude) challenge robustness, which we assess by reporting convergence success within the iteration cap.\n\nImplementation details. We use $\\,\\mathbf{K}_b = k_b \\mathbf{I}\\,$ and $\\,\\mathbf{K}_t = k_t \\mathbf{I}\\,$, start from $\\,\\mathbf{u}_t^{(0)} = \\mathbf{0}\\,$, employ a small regularization $\\,\\epsilon = 10^{-14}\\,$ in slip to avoid division by zero in $\\,q\\,$, and cap iterations at $\\,50\\,$. The residual norm threshold is set to $\\,10^{-12}\\,$. We return per test case: the iteration count, the final $\\,q$-linear rate, the convergence boolean, and the final regime code ($\\,0\\,$ stick, $\\,1\\,$ slip), determined by evaluating $\\,\\left\\|k_t \\mathbf{u}_t^{\\star}\\right\\| \\le \\mu t_n\\,$ at the converged solution $\\,\\mathbf{u}_t^{\\star}\\,$.\n\nApplying the algorithm to the provided test suite yields outputs in a single-line list format $\\,\\left[ [i_1,r_1,c_1,s_1],[i_2,r_2,c_2,s_2],\\dots \\right]\\,$, fulfilling the required specification. All quantities are nondimensional.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef friction_traction_and_tangent(u, k_t, mu, p_n, eps=1e-14):\n    \"\"\"\n    Compute tangential traction and consistent generalized tangent for a Coulomb interface.\n    u: 2-vector of tangential displacement jump.\n    Returns (t, D, regime) where:\n      t: 2-vector traction,\n      D: 2x2 consistent generalized derivative dt/du,\n      regime: 0 for stick, 1 for slip.\n    \"\"\"\n    # Elastic trial traction\n    q = k_t * u\n    qnorm = np.linalg.norm(q)\n    limit = mu * p_n\n\n    if qnorm = limit + 0.0:  # stick\n        t = q.copy()\n        D = k_t * np.eye(2)\n        regime = 0\n    else:  # slip\n        # Project onto friction disc\n        n = q / (qnorm + eps)\n        t = limit * n\n        # Consistent generalized derivative in slip:\n        # D = (limit * k_t / qnorm) * (I - n n^T)\n        # Regularize denominator\n        denom = max(qnorm, eps)\n        projector = np.eye(2) - np.outer(n, n)\n        D = (limit * k_t / denom) * projector\n        regime = 1\n    return t, D, regime\n\ndef semi_smooth_newton(w, k_b, k_t, mu, p_n, tol=1e-12, max_iter=50):\n    \"\"\"\n    Solve K_b (w - u) - t(u) = 0 for u using Semi-Smooth Newton with consistent tangent.\n    Returns dict with iteration count, final rate, converged, regime, and solution u.\n    \"\"\"\n    Kb = k_b * np.eye(2)\n    u = np.zeros(2)\n    residual_norms = []\n\n    converged = False\n    regime_final = None\n\n    for it in range(max_iter):\n        t, Dt, regime = friction_traction_and_tangent(u, k_t, mu, p_n)\n        R = Kb @ (w - u) - t\n        rn = float(np.linalg.norm(R))\n        residual_norms.append(rn)\n        if rn = tol:\n            converged = True\n            regime_final = regime\n            break\n\n        # Generalized Jacobian of residual: J = -Kb - Dt\n        J = -Kb - Dt\n\n        # Check conditioning; if ill-conditioned, fallback to steepest-descent step\n        try:\n            condJ = np.linalg.cond(J)\n        except Exception:\n            condJ = np.inf\n\n        if not np.isfinite(condJ) or condJ > 1e12:\n            delta = -R\n        else:\n            try:\n                delta = np.linalg.solve(J, -R)\n            except np.linalg.LinAlgError:\n                delta = -R\n\n        # Backtracking line search to ensure residual decrease\n        alpha = 1.0\n        Rnorm_old = rn\n        # Limit backtracking attempts to avoid infinite loop\n        for _ in range(12):\n            u_trial = u + alpha * delta\n            t_trial, Dt_trial, _ = friction_traction_and_tangent(u_trial, k_t, mu, p_n)\n            R_trial = Kb @ (w - u_trial) - t_trial\n            Rnorm_trial = float(np.linalg.norm(R_trial))\n            if Rnorm_trial = Rnorm_old:\n                u = u_trial\n                break\n            alpha *= 0.5\n        else:\n            # If no decrease found, take the last trial step anyway to progress\n            u = u_trial\n\n    # Determine final regime based on converged or last state\n    if regime_final is None:\n        # Evaluate regime at last iterate\n        _, _, regime_final = friction_traction_and_tangent(u, k_t, mu, p_n)\n\n    # q-linear rate from last two iterations\n    if len(residual_norms) >= 2 and residual_norms[-2] > 0:\n        rate = residual_norms[-1] / residual_norms[-2]\n    else:\n        rate = 0.0\n\n    return {\n        \"iterations\": (len(residual_norms) - 1) if converged else max_iter,\n        \"rate\": rate,\n        \"converged\": converged,\n        \"regime\": regime_final,\n        \"u\": u,\n        \"residual_norms\": residual_norms,\n    }\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (stick-dominated)\n        {\"w\": np.array([0.05, 0.02]), \"k_b\": 500.0, \"k_t\": 1000.0, \"mu\": 0.3, \"p_n\": 100.0},\n        # Case B (slip with large jump)\n        {\"w\": np.array([0.5, 0.3]), \"k_b\": 500.0, \"k_t\": 1000.0, \"mu\": 0.3, \"p_n\": 100.0},\n        # Case C (near-boundary, high friction capacity)\n        {\"w\": np.array([0.5, 0.3]), \"k_b\": 500.0, \"k_t\": 1000.0, \"mu\": 2.0, \"p_n\": 100.0},\n        # Case D (direction flip, slip)\n        {\"w\": np.array([-0.6, 0.0]), \"k_b\": 500.0, \"k_t\": 1000.0, \"mu\": 0.3, \"p_n\": 100.0},\n        # Case E (exact-boundary magnitude in one direction)\n        {\"w\": np.array([0.09, 0.0]), \"k_b\": 500.0, \"k_t\": 1000.0, \"mu\": 0.3, \"p_n\": 100.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        out = semi_smooth_newton(case[\"w\"], case[\"k_b\"], case[\"k_t\"], case[\"mu\"], case[\"p_n\"])\n        # Prepare per-case result: [iterations, rate, converged, regime]\n        # Round rate for compact output\n        rate_rounded = float(np.round(out[\"rate\"], 6))\n        results.append([out[\"iterations\"], rate_rounded, out[\"converged\"], out[\"regime\"]])\n\n    # Final print statement in the exact required format.\n    # Ensure booleans and numbers are printed in a clean list-of-lists representation.\n    def format_item(item):\n        if isinstance(item, bool):\n            return \"True\" if item else \"False\"\n        elif isinstance(item, (int, float)):\n            # Represent floats with up to 6 decimal places without trailing zeros\n            if isinstance(item, float):\n                return str(item)\n            return str(item)\n        else:\n            return str(item)\n\n    formatted = []\n    for res in results:\n        formatted.append(\"[\" + \",\".join(format_item(x) for x in res) + \"]\")\n    print(f\"[{','.join(formatted)}]\")\n\nsolve()\n```", "id": "3571923"}]}