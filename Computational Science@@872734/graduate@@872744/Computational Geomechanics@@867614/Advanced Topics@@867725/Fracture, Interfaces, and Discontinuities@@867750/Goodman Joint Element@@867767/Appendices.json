{"hands_on_practices": [{"introduction": "Before a constitutive model can be trusted within a larger simulation, its fundamental behavior must be rigorously verified. This first exercise guides you through a \"patch test,\" a standard procedure in computational mechanics for validating a material model's implementation. You will implement the elastic-perfectly plastic response of a Goodman joint element governed by the Coulomb friction criterion and test it against known analytical solutions, ensuring your code correctly captures the transition from elastic sticking to plastic sliding [@problem_id:3528461].", "problem": "A rigid block slides along a planar rock joint modeled by a Goodman joint element in the context of the Finite Element Method (FEM). The Goodman joint element is a zero-thickness interface that transmits tractions proportional to the relative displacement between the two sides of the joint in the elastic range. The joint has normal and shear stiffnesses denoted by $k_n$ and $k_s$, respectively. The block is constrained such that only tangential sliding occurs along the joint, and the normal stress is held constant at a prescribed value $\\sigma_n$. The sliding is governed by elastic-perfectly plastic behavior in shear, with Coulomb friction characterized by a friction coefficient $\\mu$ and cohesion $c$. Degrees of Freedom (DOF) are restricted to the shear direction, and the joint is assumed planar, homogeneous, and perfectly bonded within the elastic range.\n\nFrom equilibrium of tractions on an interface and the definition of a linear elastic spring law for a Goodman joint element, the traction-displacement relation in the elastic range is defined component-wise by\n$$\nt_n = k_n \\,\\delta_n, \\quad t_s = k_s \\,\\delta_s,\n$$\nwhere $t_n$ is the normal traction, $t_s$ is the shear traction, $\\delta_n$ is the relative normal displacement, and $\\delta_s$ is the relative shear displacement along the joint. In the presence of Coulomb friction in shear, the elastic range is limited by the yield bound\n$$\n|t_s| \\le \\tau_{\\max}, \\quad \\tau_{\\max} = c + \\mu \\,\\sigma_n,\n$$\nwhere $c$ is the cohesion in pascals and $\\mu$ is a dimensionless friction coefficient. When $|k_s \\,\\delta_s|  \\tau_{\\max}$, the joint yields in shear and the traction saturates at the Coulomb limit with sign consistent with the direction of sliding:\n$$\nt_s = \\operatorname{sign}(\\delta_s) \\,\\tau_{\\max}.\n$$\n\nConstruct a patch test where a rigid block slides along a joint under constant $\\sigma_n$ and verify that the computed shear traction $t_s$ equals the analytical solution $t_s = k_s \\,\\delta_s$ in the elastic range (including the onset of yield where equality still holds). The computational model shall implement the following constitutive rule for the Goodman joint element in shear:\n$$\nt_s(\\delta_s;\\sigma_n,k_s,\\mu,c) = \\operatorname{sign}(\\delta_s)\\,\\min\\!\\left(k_s\\,|\\delta_s|,\\;c+\\mu\\,\\sigma_n\\right).\n$$\n\nYour task is to write a program that, for each test case, computes $t_s$ using the constitutive rule above and returns a boolean indicating whether $t_s$ equals the analytical elastic expression $k_s\\,\\delta_s$ within a specified numerical tolerance when the state is in the elastic range, and returns a boolean indicating inequality otherwise. The comparison should use a relative tolerance of $10^{-12}$ and an absolute tolerance of $10^{-9}$ pascals. All physical quantities must use the following units: displacement in meters (m), stiffness in pascals per meter (Pa/m), traction and stress in pascals (Pa), and friction coefficient in a dimensionless unit.\n\nImplement the following test suite of parameters $(\\sigma_n, k_s, \\mu, c, \\delta_s)$, expressed in the units prescribed above:\n\n- Case 1 (strictly elastic, positive sliding): $(\\sigma_n, k_s, \\mu, c, \\delta_s) = (10^6,\\,5\\times10^9,\\,0.6,\\,0,\\,10^{-4})$.\n- Case 2 (onset of yield, equality holds): $(\\sigma_n, k_s, \\mu, c, \\delta_s) = (10^6,\\,5\\times10^9,\\,0.6,\\,0,\\,1.2\\times10^{-4})$.\n- Case 3 (post-yield, positive sliding): $(\\sigma_n, k_s, \\mu, c, \\delta_s) = (10^6,\\,5\\times10^9,\\,0.6,\\,0,\\,3\\times10^{-4})$.\n- Case 4 (strictly elastic, zero normal stress, cohesive joint): $(\\sigma_n, k_s, \\mu, c, \\delta_s) = (0,\\,10^9,\\,0.5,\\,5\\times10^4,\\,10^{-5})$.\n- Case 5 (post-yield, zero normal stress, cohesive joint): $(\\sigma_n, k_s, \\mu, c, \\delta_s) = (0,\\,10^9,\\,0.5,\\,5\\times10^4,\\,10^{-3})$.\n- Case 6 (degenerate stiffness, zero shear resistance from elasticity): $(\\sigma_n, k_s, \\mu, c, \\delta_s) = (2\\times10^6,\\,0,\\,0.5,\\,0,\\,1)$.\n- Case 7 (strictly elastic, negative sliding): $(\\sigma_n, k_s, \\mu, c, \\delta_s) = (10^6,\\,5\\times10^9,\\,0.6,\\,0,\\,-10^{-4})$.\n\nFor each case, compute $t_s$ using the constitutive rule, compute the analytical elastic expression $k_s\\,\\delta_s$, determine whether the state is elastic using the criterion $|k_s\\,\\delta_s| \\le c + \\mu\\,\\sigma_n$ (with equality admitted as elastic), and return a boolean:\n- Return true if the state is elastic and $t_s$ equals $k_s \\,\\delta_s$ within the specified tolerance.\n- Return false otherwise.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[result_1,result_2,\\dots]$). The outputs for each case must be booleans. No user input is required, and no external files shall be used. The final answer shall be implemented in the Python language and must be a complete, runnable program.", "solution": "The problem is scientifically and mathematically sound, well-posed, and provides all necessary information for a unique solution. The concepts of Goodman joint elements, Coulomb friction, and elastic-perfectly plastic constitutive models are fundamental in computational geomechanics. The problem constitutes a standard verification test, often termed a patch test, for a numerical implementation of a constitutive law. All parameters and test cases are clearly defined. Therefore, the problem is valid.\n\nThe solution requires implementing a given constitutive rule for the shear traction $t_s$ on a joint and testing its behavior against an analytical elastic solution under specified conditions. The key steps are to determine the state of the joint (elastic or plastic) and then compute the traction accordingly.\n\nFirst, we analyze the provided constitutive relationship:\n$$\nt_s(\\delta_s;\\sigma_n,k_s,\\mu,c) = \\operatorname{sign}(\\delta_s)\\,\\min\\!\\left(k_s\\,|\\delta_s|,\\;c+\\mu\\,\\sigma_n\\right)\n$$\nThis equation describes an elastic-perfectly plastic material response with a Coulomb friction-based yield criterion. Let us dissect this expression.\n\nThe maximum shear traction, or shear strength, $\\tau_{\\max}$, that the joint can sustain is defined by the Coulomb failure criterion:\n$$\n\\tau_{\\max} = c + \\mu\\,\\sigma_n\n$$\nwhere $c$ is the cohesion, $\\mu$ is the friction coefficient, and $\\sigma_n$ is the constant normal stress. Since stress is defined a a positive quantity in compression for many geomechanics conventions, and the block is likely pressing on the joint, we will assume $\\sigma_n \\ge 0$.\n\nThe term $k_s\\,\\delta_s$ represents the purely elastic response of the joint, where $k_s$ is the shear stiffness and $\\delta_s$ is the relative shear displacement. This is the \"trial\" elastic shear traction. The magnitude of this trial traction is $|k_s\\,\\delta_s|$. Since shear stiffness $k_s$ is a non-negative physical property ($k_s \\ge 0$), this can be written as $k_s\\,|\\delta_s|$.\n\nThe state of the joint is determined by comparing the magnitude of the trial elastic traction to the shear strength:\n1.  **Elastic State**: If $k_s\\,|\\delta_s| \\le \\tau_{\\max}$, the joint behaves elastically. The shear traction is not large enough to cause slip. In this case, the `min` function in the constitutive rule evaluates to $k_s\\,|\\delta_s|$:\n    $$\n    t_s = \\operatorname{sign}(\\delta_s) \\cdot (k_s\\,|\\delta_s|)\n    $$\n    Since $\\operatorname{sign}(\\delta_s)\\,|\\delta_s| = \\delta_s$, this simplifies to:\n    $$\n    t_s = k_s\\,\\delta_s\n    $$\n    This confirms that in the elastic range, the computed traction equals the analytical elastic expression. This also holds for the onset of yield, where $k_s\\,|\\delta_s| = \\tau_{\\max}$.\n\n2.  **Plastic (Yielded) State**: If $k_s\\,|\\delta_s|  \\tau_{\\max}$, the joint yields and undergoes plastic slip. The shear traction is limited by the joint's strength. In this case, the `min` function evaluates to $\\tau_{\\max}$:\n    $$\n    t_s = \\operatorname{sign}(\\delta_s)\\,\\tau_{\\max}\n    $$\n    The shear traction saturates at the maximum possible value, with its sign determined by the direction of relative displacement $\\delta_s$.\n\nThe problem requires a specific boolean test for each set of parameters. The test must return `True` if and only if two conditions are met:\n1.  The state is elastic, as defined by the criterion $|k_s\\,\\delta_s| \\le c + \\mu\\,\\sigma_n$. Note that the absolute value is used to correctly handle negative shear displacement $\\delta_s$.\n2.  The shear traction $t_s$ computed using the full constitutive rule is numerically equal to the analytical elastic expression $k_s\\,\\delta_s$. This comparison must use a relative tolerance of $10^{-12}$ and an absolute tolerance of $10^{-9}$.\n\nThe algorithm for each test case is as follows:\n1.  Given the input parameters $(\\sigma_n, k_s, \\mu, c, \\delta_s)$.\n2.  Calculate the shear strength: $\\tau_{\\max} = c + \\mu\\,\\sigma_n$.\n3.  Calculate the analytical elastic traction: $t_{s, \\text{elastic}} = k_s\\,\\delta_s$.\n4.  Check the elasticity condition: Evaluate the boolean expression `is_elastic` = ($|t_{s, \\text{elastic}}| \\le \\tau_{\\max}$).\n5.  Calculate the shear traction using the full constitutive model: $t_{s, \\text{computed}} = \\operatorname{sign}(\\delta_s)\\,\\min(|t_{s, \\text{elastic}}|, \\tau_{\\max})$.\n6.  Check for numerical equality: Evaluate the boolean expression `are_equal` by comparing $t_{s, \\text{computed}}$ and $t_{s, \\text{elastic}}$ with the specified tolerances.\n7.  The final result for the test case is the logical AND of these two booleans: `result = is_elastic AND are_equal`.\n\nThis procedure will be applied to each of the seven test cases to generate the final list of boolean results. For example, in Case 3: $(\\sigma_n, k_s, \\mu, c, \\delta_s) = (10^6,\\,5\\times10^9,\\,0.6,\\,0,\\,3\\times10^{-4})$, we have:\n-   $\\tau_{\\max} = 0 + 0.6 \\times 10^6 = 6 \\times 10^5$ Pa.\n-   $t_{s, \\text{elastic}} = (5\\times10^9) \\times (3\\times10^{-4}) = 1.5 \\times 10^6$ Pa.\n-   Elasticity check: $|1.5 \\times 10^6| \\le 6 \\times 10^5$ is `False`.\n-   The final result for this case is `False`, as the first condition is not met.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Goodman joint element patch test problem for a series of cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (sigma_n, k_s, mu, c, delta_s)\n    # sigma_n: Normal stress in Pa\n    # k_s: Shear stiffness in Pa/m\n    # mu: Friction coefficient (dimensionless)\n    # c: Cohesion in Pa\n    # delta_s: Relative shear displacement in m\n    test_cases = [\n        # Case 1 (strictly elastic, positive sliding)\n        (1e6, 5e9, 0.6, 0, 1e-4),\n        # Case 2 (onset of yield, equality holds)\n        (1e6, 5e9, 0.6, 0, 1.2e-4),\n        # Case 3 (post-yield, positive sliding)\n        (1e6, 5e9, 0.6, 0, 3e-4),\n        # Case 4 (strictly elastic, zero normal stress, cohesive joint)\n        (0, 1e9, 0.5, 5e4, 1e-5),\n        # Case 5 (post-yield, zero normal stress, cohesive joint)\n        (0, 1e9, 0.5, 5e4, 1e-3),\n        # Case 6 (degenerate stiffness, zero shear resistance from elasticity)\n        (2e6, 0, 0.5, 0, 1),\n        # Case 7 (strictly elastic, negative sliding)\n        (1e6, 5e9, 0.6, 0, -1e-4),\n    ]\n\n    results = []\n    # Define numerical tolerances for equality check\n    rtol = 1e-12\n    atol = 1e-9\n\n    for case in test_cases:\n        sigma_n, k_s, mu, c, delta_s = case\n\n        # Calculate shear strength (yield limit) based on Coulomb friction\n        tau_max = c + mu * sigma_n\n\n        # Calculate the analytical elastic shear traction\n        ts_elastic = k_s * delta_s\n\n        # Determine if the state is elastic based on the yield criterion.\n        # The problem statement specifies that equality (onset of yield)\n        # is considered an elastic state for this test.\n        is_elastic = np.abs(ts_elastic) = tau_max\n\n        # Calculate the shear traction using the full elastic-perfectly plastic constitutive rule.\n        # t_s = sign(delta_s) * min(k_s * |delta_s|, tau_max)\n        # This is equivalent to sign(delta_s) * min(|ts_elastic|, tau_max)\n        # We must handle the case delta_s = 0, where np.sign(0) = 0.\n        ts_magnitude = min(np.abs(ts_elastic), tau_max)\n        ts_computed = np.sign(delta_s) * ts_magnitude\n        \n        # Check if the computed traction equals the analytical elastic expression\n        # within the specified tolerance. This is the second part of the patch test condition.\n        are_equal = np.isclose(ts_computed, ts_elastic, rtol=rtol, atol=atol)\n\n        # The final result is True only if the state is elastic AND the computed traction\n        # matches the elastic one. Otherwise, it is False.\n        result = is_elastic and are_equal\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Convert boolean values to lowercase 'true' or 'false' for direct printing.\n    print(f\"[{','.join(map(str, results))}]\".lower())\n\nsolve()\n```", "id": "3528461"}, {"introduction": "With a verified constitutive update rule, the next step is to integrate the Goodman element into an implicit finite element solver, which typically relies on the Newton-Raphson method. To achieve the method's characteristic quadratic convergence rate, it is essential to compute not only the residual force vector but also the consistent tangent stiffness matrix. This practice focuses on deriving and implementing these components for a frictional, unilateral contact model, highlighting the non-symmetric nature of the tangent matrix that arises from the non-associative Coulomb friction law [@problem_id:3528471].", "problem": "Consider a two-dimensional Goodman joint element that connects two continuum finite element meshes across a potential discontinuity. The joint element is modeled by linear elastic interface springs in the normal and shear directions, coupled with a rate-independent Coulomb friction law. Let the displacement jump vector at the joint be $u = [u_n, u_s]^\\top$, where $u_n$ is the relative normal displacement (positive in opening) and $u_s$ is the relative shear displacement. The traction vector is $t = [\\sigma_n, \\tau]^\\top$, where $\\sigma_n$ is the normal traction taken positive in compression and $\\tau$ is the shear traction. The mechanical behavior is characterized by the following physically standard ingredients:\n\n1. Linear interface springs in compression and sticking:\n   - Normal traction is linear in compression with stiffness $k_n$ and vanishes in opening: $\\sigma_n$ depends on $u_n$ and is zero for $u_n \\ge 0$.\n   - Shear traction is linear with stiffness $k_s$ in sticking: $\\tau$ depends on $u_s$ and has no direct coupling to $u_n$ in the sticking regime.\n\n2. Unilateral contact in the normal direction:\n   - The element supports compression but not tension, consistent with non-penetration: the contact is active only when $u_n  0$.\n\n3. Coulomb friction law for shear:\n   - When contact is active ($u_n  0$), the friction bound is $|\\tau| \\le \\mu\\,\\sigma_n$, where $\\mu$ is the friction coefficient and $\\sigma_n$ is the compressive normal traction.\n   - Monotonic shear loading is assumed, but the algorithm must correctly detect and handle sticking and sliding.\n\nUnder Newton–Raphson (NR) iterations, ensuring quadratic convergence requires using the consistent tangent, defined as the exact derivative of the residual with respect to the displacement jump. Your task is to derive, implement, and evaluate the residual traction vector $r(u) = t(u)$ and the consistent tangent matrix $K(u) = \\partial t / \\partial u$ for the Goodman joint element with the above behavior. Use the following base laws and principles only:\n\n- Principle of virtual work for an interface element relating traction and displacement jump.\n- Linear elastic spring behavior in the normal and shear directions under sticking and compression.\n- Rate-independent Coulomb friction law with a return-mapping update to enforce the friction constraint.\n- Unilateral contact (no tension) in the normal direction.\n\nUnits and conventions:\n\n- Use $u_n$ and $u_s$ in millimeters (mm).\n- Use $\\sigma_n$ and $\\tau$ in megapascals (MPa).\n- Use $k_n$ and $k_s$ in MPa/mm.\n- Use $\\mu$ dimensionless.\n- The final residual components must be expressed in MPa, and the tangent matrix entries must be expressed in MPa/mm. Express all numerical outputs rounded to six decimal places.\n\nAlgorithmic requirements:\n\n- Construct a residual based on zero external traction so that $r(u) = t(u)$.\n- Implement a return-mapping update for shear traction to enforce the Coulomb friction law when contact is active and the trial shear traction magnitude exceeds the friction bound.\n- Compute the consistent tangent matrix $K(u)$ piecewise for the sticking, sliding, and open-contact regimes, ensuring it is the exact derivative of $t$ with respect to $u$ in each regime.\n\nTest suite:\n\nUse the following parameter values and displacement jumps:\n\n- Material and interface parameters:\n  - $k_n = 10000$ MPa/mm\n  - $k_s = 5000$ MPa/mm\n  - $\\mu = 0.6$\n\n- Test cases, each given as $(u_n, u_s)$ in mm:\n  1. $(-0.001, 0.0005)$: Active compression, sticking is expected.\n  2. $(-0.001, 0.002)$: Active compression, sliding is expected in the positive shear direction.\n  3. $(+0.0002, 0.005)$: Opening (no contact), both tractions should be zero.\n  4. $(-0.001, 0.0012)$: On the friction boundary under compression, sliding is expected in the positive shear direction.\n  5. $(-0.002, -0.004)$: Active compression, sliding is expected in the negative shear direction.\n\nFor each test case, compute:\n\n- The residual traction vector components $[\\sigma_n, \\tau]$ in MPa.\n- The consistent tangent matrix entries $\\left[K_{11}, K_{12}, K_{21}, K_{22}\\right]$ in MPa/mm, where $K_{ij} = \\partial t_i / \\partial u_j$ and $t_1 = \\sigma_n$, $t_2 = \\tau$, $u_1 = u_n$, $u_2 = u_s$.\n- A sliding indicator defined as an integer: $1$ if sliding occurs, $0$ otherwise.\n\nFinal output format:\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a sublist of seven values $[\\sigma_n, \\tau, K_{11}, K_{12}, K_{21}, K_{22}, \\mathrm{sliding}]$. All values must be rounded to six decimal places for the floats and be in the units specified above, for example:\n\"[[\\dots],[\\dots],[\\dots],[\\dots],[\\dots]]\".", "solution": "The problem requires the derivation and implementation of the constitutive relations for a two-dimensional Goodman joint element. This involves determining the traction vector $t(u)$ and the consistent tangent matrix $K(u)$ as functions of the relative displacement jump vector $u = [u_n, u_s]^\\top$. The element's behavior is governed by linear elasticity coupled with unilateral contact and a rate-independent Coulomb friction law. The provided sign conventions are: $u_n  0$ for opening, and $\\sigma_n  0$ for compression.\n\nThe derivation is partitioned into three distinct mechanical regimes: open contact, sticking contact, and sliding contact.\n\n**1. Open Contact Regime ($u_n \\ge 0$)**\n\nWhen the normal displacement jump $u_n$ is non-negative, the joint is considered open. In this state, the surfaces are not in contact, and no tractions can be transmitted across the interface.\n\n*   **Traction Vector ($t$)**: Both normal and shear tractions are zero.\n    $$\n    t(u) = \\begin{bmatrix} \\sigma_n \\\\ \\tau \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}\n    $$\n\n*   **Consistent Tangent Matrix ($K$)**: The tangent matrix is the derivative of the traction vector with respect to the displacement jump vector. As the tractions are constant (zero) in this regime, all derivative components are zero.\n    $$\n    K(u) = \\frac{\\partial t}{\\partial u} = \\begin{bmatrix} \\frac{\\partial \\sigma_n}{\\partial u_n}  \\frac{\\partial \\sigma_n}{\\partial u_s} \\\\ \\frac{\\partial \\tau}{\\partial u_n}  \\frac{\\partial \\tau}{\\partial u_s} \\end{bmatrix} = \\begin{bmatrix} 0  0 \\\\ 0  0 \\end{bmatrix}\n    $$\n\n**2. Contact Regime ($u_n  0$)**\n\nWhen $u_n  0$, the surfaces are in contact, allowing for the transmission of normal and shear tractions. The response is determined using a standard elastic-predictor, plastic-corrector (return-mapping) scheme.\n\n*   **Normal Response**: The normal traction $\\sigma_n$ is linearly proportional to the compressive normal displacement. Given the sign conventions, this relationship is:\n    $$\n    \\sigma_n = -k_n u_n\n    $$\n    This ensures that for a compressive displacement ($u_n  0$), a compressive traction ($\\sigma_n  0$) is generated. This relation is independent of the shear behavior.\n\n*   **Shear Response (Return Mapping)**:\n    1.  **Elastic Predictor (Trial State)**: First, we assume the shear response is purely elastic (sticking). The trial shear traction $\\tau^{\\text{trial}}$ is computed as:\n        $$\n        \\tau^{\\text{trial}} = k_s u_s\n        $$\n    2.  **Yield Condition Check**: The Coulomb friction criterion defines the limit of admissible shear traction, establishing the yield function $\\Phi$. Sliding occurs if the magnitude of the trial shear traction exceeds the friction capacity, which is proportional to the normal compression. The friction capacity is $\\tau_{\\text{crit}} = \\mu \\sigma_n$. The yield function is:\n        $$\n        \\Phi(u) = |\\tau^{\\text{trial}}| - \\mu \\sigma_n = |k_s u_s| - \\mu(-k_n u_n) = |k_s u_s| + \\mu k_n u_n\n        $$\n        Based on the problem description for test case 4, the condition for sliding is taken as $\\Phi \\ge 0$, which corresponds to $|\\tau^{\\text{trial}}| \\ge \\mu \\sigma_n$.\n\n**2.1. Sticking Contact Sub-Regime ($u_n  0$ and $|\\tau^{\\text{trial}}|  \\mu \\sigma_n$)**\n\nIf the trial shear traction is within the friction cone, the elastic assumption holds.\n\n*   **Traction Vector ($t$)**: The final tractions are the elastically computed ones.\n    $$\n    t(u) = \\begin{bmatrix} \\sigma_n \\\\ \\tau \\end{bmatrix} = \\begin{bmatrix} -k_n u_n \\\\ k_s u_s \\end{bmatrix}\n    $$\n\n*   **Consistent Tangent Matrix ($K$)**: The tangent is obtained by differentiating the traction vector.\n    $$\n    K^{\\text{stick}} = \\frac{\\partial t}{\\partial u} = \\begin{bmatrix} \\frac{\\partial(-k_n u_n)}{\\partial u_n}  \\frac{\\partial(-k_n u_n)}{\\partial u_s} \\\\ \\frac{\\partial(k_s u_s)}{\\partial u_n}  \\frac{\\partial(k_s u_s)}{\\partial u_s} \\end{bmatrix} = \\begin{bmatrix} -k_n  0 \\\\ 0  k_s \\end{bmatrix}\n    $$\n    The tangent matrix is diagonal and constant in this regime. The negative sign in $K_{11}$ is a direct consequence of the specified sign conventions for $\\sigma_n$ and $u_n$.\n\n**2.2. Sliding Contact Sub-Regime ($u_n  0$ and $|\\tau^{\\text{trial}}| \\ge \\mu \\sigma_n$)**\n\nIf the trial shear traction violates the friction criterion, a plastic correction (return mapping) is applied. The shear traction is returned to the boundary of the friction cone.\n\n*   **Traction Vector ($t$)**: The normal traction is unaffected. The shear traction is scaled back to the friction limit, maintaining its direction.\n    $$\n    \\tau = (\\mu \\sigma_n) \\cdot \\text{sign}(\\tau^{\\text{trial}}) = (\\mu (-k_n u_n)) \\cdot \\text{sign}(k_s u_s) = -\\mu k_n u_n \\cdot \\text{sign}(u_s)\n    $$\n    The full traction vector is:\n    $$\n    t(u) = \\begin{bmatrix} \\sigma_n \\\\ \\tau \\end{bmatrix} = \\begin{bmatrix} -k_n u_n \\\\ -\\mu k_n u_n \\cdot \\text{sign}(u_s) \\end{bmatrix}\n    $$\n\n*   **Consistent Tangent Matrix ($K$)**: The tangent is the derivative of this updated traction vector. The term $\\text{sign}(u_s)$ has a derivative of zero for $u_s \\neq 0$. The sliding condition implies $\\tau^{\\text{trial}} \\neq 0$, hence $u_s \\neq 0$.\n    $$\n    K^{\\text{slide}} = \\frac{\\partial t}{\\partial u} = \\begin{bmatrix} \\frac{\\partial(-k_n u_n)}{\\partial u_n}  \\frac{\\partial(-k_n u_n)}{\\partial u_s} \\\\ \\frac{\\partial(-\\mu k_n u_n \\cdot \\text{sign}(u_s))}{\\partial u_n}  \\frac{\\partial(-\\mu k_n u_n \\cdot \\text{sign}(u_s))}{\\partial u_s} \\end{bmatrix}\n    $$\n    $$\n    K^{\\text{slide}} = \\begin{bmatrix} -k_n  0 \\\\ -\\mu k_n \\cdot \\text{sign}(u_s)  0 \\end{bmatrix}\n    $$\n    This matrix is non-symmetric ($K_{21} \\neq K_{12}$), which is a key feature of the consistent tangent for non-associative plasticity models like Coulomb friction. The off-diagonal term $K_{21}$ represents the coupling where a change in normal displacement $u_n$ directly alters the shear traction $\\tau$ by changing the normal stress and thus the friction limit.\n\n**Summary of the Algorithm**\nFor a given displacement jump $u = [u_n, u_s]^\\top$ and parameters $k_n, k_s, \\mu$:\n1.  If $u_n \\ge 0$: Set $\\sigma_n=0$, $\\tau=0$, $K=[[0,0],[0,0]]$, and sliding=0.\n2.  If $u_n  0$:\n    a. Calculate $\\sigma_n = -k_n u_n$.\n    b. Calculate $\\tau^{\\text{trial}} = k_s u_s$.\n    c. Calculate $\\tau_{\\text{crit}} = \\mu \\sigma_n$.\n    d. If $|\\tau^{\\text{trial}}| \\ge \\tau_{\\text{crit}}$ (Sliding):\n        i. $\\tau = \\tau_{\\text{crit}} \\cdot \\text{sign}(u_s)$.\n        ii. $K_{11} = -k_n$, $K_{12}=0$, $K_{21} = -\\mu k_n \\cdot \\text{sign}(u_s)$, $K_{22}=0$.\n        iii. sliding=1.\n    e. Else (Sticking):\n        i. $\\tau = \\tau^{\\text{trial}}$.\n        ii. $K_{11} = -k_n$, $K_{12}=0$, $K_{21}=0$, $K_{22}=k_s$.\n        iii. sliding=0.\nThis algorithm provides the basis for the implementation.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the residual traction and consistent tangent matrix for a Goodman joint element\n    under various displacement jumps, based on a Coulomb friction model.\n    \"\"\"\n    # Material and interface parameters\n    k_n = 10000.0  # Normal stiffness in MPa/mm\n    k_s = 5000.0   # Shear stiffness in MPa/mm\n    mu = 0.6       # Friction coefficient (dimensionless)\n\n    # Test cases defined as (u_n, u_s) tuples in mm\n    test_cases = [\n        (-0.001, 0.0005),  # Active compression, sticking\n        (-0.001, 0.002),   # Active compression, sliding (+)\n        (0.0002, 0.005),   # Opening, no contact\n        (-0.001, 0.0012),  # Active compression, on friction boundary (sliding)\n        (-0.002, -0.004),  # Active compression, sliding (-)\n    ]\n\n    results = []\n\n    for u_n, u_s in test_cases:\n        # Initialize outputs for the open-contact case\n        sigma_n, tau = 0.0, 0.0\n        K11, K12, K21, K22 = 0.0, 0.0, 0.0, 0.0\n        sliding_indicator = 0\n\n        # Regime 1: Open Contact (u_n >= 0)\n        # In this case, tractions and stiffnesses are zero, so initial values are correct.\n\n        # Regime 2: Active Contact (u_n  0)\n        if u_n  0:\n            # Normal traction (positive in compression)\n            sigma_n = -k_n * u_n\n\n            # Elastic predictor step: compute trial shear traction\n            tau_trial = k_s * u_s\n\n            # Friction capacity (critical shear traction)\n            tau_crit = mu * sigma_n\n\n            # Check yield condition to determine sticking or sliding\n            # Based on the problem statement's expectation for case 4,\n            # the boundary |tau_trial| == tau_crit is treated as sliding.\n            if np.abs(tau_trial) >= tau_crit:\n                # Sliding state\n                sliding_indicator = 1\n                \n                # Return-mapping: project shear traction onto the yield surface\n                # Ensure sign of tau matches sign of shear displacement u_s\n                tau = tau_crit * np.sign(u_s)\n                \n                # Consistent tangent matrix for the sliding regime\n                K11 = -k_n\n                K12 = 0.0\n                K21 = -mu * k_n * np.sign(u_s)\n                K22 = 0.0\n            else:\n                # Sticking state\n                sliding_indicator = 0\n                \n                # Shear traction is the elastic trial value\n                tau = tau_trial\n                \n                # Consistent tangent matrix for the sticking regime\n                K11 = -k_n\n                K12 = 0.0\n                K21 = 0.0\n                K22 = k_s\n        \n        # Format the results for the current test case, rounding to 6 decimal places.\n        case_result = [\n            round(sigma_n, 6),\n            round(tau, 6),\n            round(K11, 6),\n            round(K12, 6),\n            round(K21, 6),\n            round(K22, 6),\n            sliding_indicator\n        ]\n        \n        # Convert list to string format '[v1,v2,...]' without spaces\n        results.append(str(case_result).replace(\" \", \"\"))\n\n    # Print the final output as a single-line string\n    # in the format \"[[...],[...],...]\"\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3528471"}, {"introduction": "The Goodman joint element is a penalty-based formulation, meaning its stiffness parameters, $k_n$ and $k_s$, are not just physical properties but also numerical tuning parameters that are critical for a simulation's success. If these values are too low, the joint is too compliant and the results are inaccurate; if they are too high, the global stiffness matrix becomes ill-conditioned, leading to numerical instability. This final exercise explores the theoretical basis for selecting appropriate values for $k_n$ and $k_s$ by establishing bounds based on the bulk material's properties ($E$, $\\nu$) and the finite element mesh size ($h$), ensuring both accuracy and numerical robustness [@problem_id:3528504].", "problem": "Consider two identical, homogeneous, isotropic, linear elastic rectangular blocks in plane strain, perfectly aligned and connected along a straight, zero-thickness interface by Goodman joint elements. Let the blocks have Young’s modulus $E$ (in $\\mathrm{Pa}$) and Poisson’s ratio $\\nu$ (dimensionless). Let the interface be modeled by linear traction–separation laws with a normal stiffness $k_n$ and a shear stiffness $k_s$, both defined per unit area, so that the traction components across the interface satisfy $t_n = k_n \\,\\llbracket u \\rrbracket_n$ and $t_s = k_s \\,\\llbracket u \\rrbracket_s$, where $\\llbracket u \\rrbracket_n$ and $\\llbracket u \\rrbracket_s$ are the relative displacement jumps in the normal and tangential directions, respectively, measured in $\\mathrm{m}$, and $t_n$, $t_s$ are tractions in $\\mathrm{Pa}$. The stiffness parameters $k_n$ and $k_s$ thus have units $\\mathrm{Pa}/\\mathrm{m}$. Let the characteristic element size in the bulk adjacent to the interface be $h$ (in $\\mathrm{m}$). The shear modulus is $G = \\dfrac{E}{2(1+\\nu)}$ (in $\\mathrm{Pa}$).\n\nThe canonical patch test for a bonded interface requires that, under boundary conditions inducing a uniform strain field in the connected body, the finite element discretization reproduces the exact linear displacement field, with zero displacement jump across the interface. In this setting, parasitic modes are spurious displacement jumps or oscillations localized at the interface that appear even under uniform far-field loading. To avoid such modes while passing the patch test, the interface stiffnesses must be scaled relative to the bulk stiffness and mesh size.\n\nStarting from the principles of linear elasticity and energy consistency, derive constraints on $k_n$ and $k_s$ that are sufficient to pass the patch test without parasitic modes. The constraints must be expressed as lower and upper bounds in terms of $E$, $G$, and $h$:\n- A coercivity lower bound that suppresses displacement jumps under uniform strain, parameterized by a user-chosen dimensionless constant $\\beta_{\\min}  0$.\n- A conditioning upper bound that avoids ill-conditioning and locking, parameterized by a user-chosen maximum allowable global stiffness matrix condition number $\\kappa_{\\max}  1$.\n\nYou must present the constraints in the form of explicit inequalities involving $k_n$, $k_s$, $E$, $G$, $h$, $\\beta_{\\min}$, and $\\kappa_{\\max}$, and design an algorithm that, given $(E,\\nu,h,\\beta_{\\min},\\kappa_{\\max},k_n,k_s)$, decides whether the patch test is passed without parasitic modes. The decision must be a boolean value.\n\nAll physical quantities in your derivation must be expressed in consistent International System of Units (SI). In particular, $E$ and $G$ must be in $\\mathrm{Pa}$, $h$ in $\\mathrm{m}$, $k_n$ and $k_s$ in $\\mathrm{Pa}/\\mathrm{m}$. Angles are not involved in this problem. There are no percentages; any fractional requirements must be expressed as decimal numbers.\n\nDefine the following well-chosen test suite of parameter sets, intended to probe different facets of the constraints:\n- Test case $1$ (happy path): $E = 3.0\\times 10^{10}\\ \\mathrm{Pa}$, $\\nu = 0.25$, $h = 2.5\\times 10^{-1}\\ \\mathrm{m}$, $\\beta_{\\min} = 1.0$, $\\kappa_{\\max} = 200.0$, $k_n = 1.0\\times 10^{12}\\ \\mathrm{Pa}/\\mathrm{m}$, $k_s = 5.0\\times 10^{11}\\ \\mathrm{Pa}/\\mathrm{m}$.\n- Test case $2$ (under-penalized normal): $E = 3.0\\times 10^{10}\\ \\mathrm{Pa}$, $\\nu = 0.25$, $h = 2.5\\times 10^{-1}\\ \\mathrm{m}$, $\\beta_{\\min} = 1.0$, $\\kappa_{\\max} = 200.0$, $k_n = 1.0\\times 10^{10}\\ \\mathrm{Pa}/\\mathrm{m}$, $k_s = 5.0\\times 10^{11}\\ \\mathrm{Pa}/\\mathrm{m}$.\n- Test case $3$ (under-penalized shear): $E = 3.0\\times 10^{10}\\ \\mathrm{Pa}$, $\\nu = 0.25$, $h = 2.5\\times 10^{-1}\\ \\mathrm{m}$, $\\beta_{\\min} = 1.0$, $\\kappa_{\\max} = 200.0$, $k_n = 1.0\\times 10^{12}\\ \\mathrm{Pa}/\\mathrm{m}$, $k_s = 1.0\\times 10^{9}\\ \\mathrm{Pa}/\\mathrm{m}$.\n- Test case $4$ (over-penalized causing ill-conditioning): $E = 3.0\\times 10^{10}\\ \\mathrm{Pa}$, $\\nu = 0.25$, $h = 2.5\\times 10^{-1}\\ \\mathrm{m}$, $\\beta_{\\min} = 1.0$, $\\kappa_{\\max} = 100.0$, $k_n = 3.0\\times 10^{13}\\ \\mathrm{Pa}/\\mathrm{m}$, $k_s = 3.0\\times 10^{13}\\ \\mathrm{Pa}/\\mathrm{m}$.\n- Test case $5$ (boundary case at lower bounds): $E = 3.0\\times 10^{10}\\ \\mathrm{Pa}$, $\\nu = 0.25$, $h = 2.5\\times 10^{-1}\\ \\mathrm{m}$, $\\beta_{\\min} = 1.0$, $\\kappa_{\\max} = 500.0$, $k_n = \\dfrac{E}{h}\\ \\mathrm{Pa}/\\mathrm{m}$, $k_s = \\dfrac{E}{2(1+\\nu)h}\\ \\mathrm{Pa}/\\mathrm{m}$.\n\nYour program must implement the derived constraints and, for each test case, output a boolean indicating whether the constraints are satisfied simultaneously for $k_n$ and $k_s$. The final output format must be a single line containing the results as a comma-separated list enclosed in square brackets, for example, $\\left[\\mathrm{result}_1,\\mathrm{result}_2,\\mathrm{result}_3,\\mathrm{result}_4,\\mathrm{result}_5\\right]$, where each $\\mathrm{result}_i$ is either $\\mathrm{True}$ or $\\mathrm{False}$.", "solution": "The problem presented is a valid exercise in computational mechanics, specifically concerning the selection of penalty parameters for interface elements in the context of the finite element method. The provided parameters and context are scientifically sound, well-posed, and free of ambiguity. We may, therefore, proceed with the derivation of the required constraints.\n\nThe objective is to establish necessary and sufficient conditions on the normal stiffness, $k_n$, and shear stiffness, $k_s$, of a linear Goodman joint element to ensure the successful passage of the patch test without engendering numerical pathologies such as parasitic modes or matrix ill-conditioning. These conditions will manifest as lower and upper bounds on $k_n$ and $k_s$.\n\n**1. Lower Bound for Coercivity and Accuracy**\n\nThe patch test requires that a finite element model subjected to boundary conditions that would produce a uniform strain field in the exact solution must reproduce that field exactly. For an assembly of two bodies bonded by an interface, this implies that the displacement field must be linear and continuous across the interface, resulting in a zero displacement jump, i.e., $\\llbracket u \\rrbracket_n = 0$ and $\\llbracket u \\rrbracket_s = 0$.\n\nThe interface model, $t_n = k_n \\llbracket u \\rrbracket_n$ and $t_s = k_s \\llbracket u \\rrbracket_s$, is a penalty formulation. The penalty parameters, $k_n$ and $k_s$, must be sufficiently large to enforce the zero-jump constraint to an acceptable tolerance. If they are too small, the interface becomes overly compliant, leading to spurious, non-physical displacement jumps that constitute a failure of the patch test.\n\nTo derive a quantitative lower bound, we compare the compliance of the interface to the compliance of the adjacent bulk material. Consider a layer of bulk material of characteristic thickness $h$ adjacent to the interface. The effective stiffness of this layer against deformation is proportional to its elastic modulus divided by its thickness.\nFor deformation normal to the interface, the relevant bulk stiffness is proportional to a normal elastic modulus, for which Young's modulus $E$ is the canonical choice, giving an effective material stiffness of order $E/h$. For shear deformation parallel to the interface, the relevant modulus is the shear modulus $G$, yielding an effective material stiffness of order $G/h$.\n\nTo ensure the interface is significantly stiffer than the adjacent bulk material, preventing it from contributing appreciable deformation, the interface stiffness must be substantially greater than the effective stiffness of the adjacent material layer. We introduce a dimensionless user-defined parameter, $\\beta_{\\min}  0$, to quantify this requirement. This parameter acts as a safety factor, ensuring the interface's contribution to the total deformation is negligible. This leads to the following lower-bound constraints for accuracy:\n\n$$k_n \\ge \\beta_{\\min} \\frac{E}{h}$$\n$$k_s \\ge \\beta_{\\min} \\frac{G}{h}$$\n\nSatisfying these inequalities ensures that the penalty is sufficient to suppress parasitic displacement jumps under uniform strain fields, thus passing the patch test.\n\n**2. Upper Bound for Numerical Conditioning**\n\nWhile the interface stiffnesses $k_n$ and $k_s$ must be large for accuracy, an excessively large value will lead to ill-conditioning of the global finite element stiffness matrix, $\\mathbf{K}$. The condition number of a matrix, $\\kappa(\\mathbf{K})$, defined as the ratio of its largest to its smallest eigenvalue, dictates the numerical stability of the solution process and the propagation of round-off errors. A very large condition number can lead to inaccurate or unstable solutions.\n\nThe global stiffness matrix is formed by assembling contributions from the bulk elements and the interface elements. The magnitudes of the entries in the stiffness matrix for bulk elements are on the order of the material's elastic moduli, $E$ and $G$. The stiffness contributions from the interface elements, which have dimensions of stiffness per unit area per unit length, are proportional to $k_n$ and $k_s$ multiplied by a characteristic length, in this case, the element size $h$. Thus, the interface contributes terms of order $k_n h$ and $k_s h$ to the global stiffness matrix.\n\nThe condition number, $\\kappa(\\mathbf{K})$, can be approximated by the ratio of the largest to the smallest stiffness terms present in the system. The largest stiffness terms are those introduced by the penalty, i.e., of order $\\max(k_n h, k_s h)$. The smallest (non-zero) stiffness is associated with the most compliant deformation mode of the bulk material, which is typically shear, governed by the shear modulus $G$.\n\nTo maintain a well-conditioned system, it is prudent to compare like-with-like stiffness contributions. The normal stiffness of the interface, $k_n$, contributes to matrix entries corresponding to normal displacements, which should be compared with the bulk's natural stiffness for such displacements, governed by $E$. Similarly, the interface shear stiffness, $k_s$, should be compared with the bulk's shear stiffness, $G$. The ratios of the stiffness matrix entries are approximately $(k_n h)/E$ and $(k_s h)/G$.\n\nTo prevent ill-conditioning, we must limit these ratios to be no larger than a user-specified maximum allowable condition number, $\\kappa_{\\max}  1$. This yields the following upper-bound constraints:\n\n$$\\frac{k_n h}{E} \\le \\kappa_{\\max} \\implies k_n \\le \\kappa_{\\max} \\frac{E}{h}$$\n$$\\frac{k_s h}{G} \\le \\kappa_{\\max} \\implies k_s \\le \\kappa_{\\max} \\frac{G}{h}$$\n\nThese constraints prevent the interface stiffness from becoming so large relative to the bulk stiffness that the global matrix becomes numerically intractable.\n\n**3. Summary of Constraints and Algorithm**\n\nCombining the lower and upper bounds, we arrive at the complete set of constraints for the interface stiffness parameters to pass the patch test without parasitic modes or ill-conditioning:\n\n$$ \\beta_{\\min} \\frac{E}{h} \\le k_n \\le \\kappa_{\\max} \\frac{E}{h} $$\n$$ \\beta_{\\min} \\frac{G}{h} \\le k_s \\le \\kappa_{\\max} \\frac{G}{h} $$\n\nwhere $G = \\dfrac{E}{2(1+\\nu)}$. The algorithm to validate a given set of parameters $(E, \\nu, h, \\beta_{\\min}, \\kappa_{\\max}, k_n, k_s)$ is a direct implementation of these two inequalities. The patch test is considered passed if and only if both conditions are met simultaneously. The decision is therefore the result of the logical expression:\n\n$$ \\left( \\beta_{\\min} \\frac{E}{h} \\le k_n \\le \\kappa_{\\max} \\frac{E}{h} \\right) \\land \\left( \\beta_{\\min} \\frac{G}{h} \\le k_s \\le \\kappa_{\\max} \\frac{G}{h} \\right) $$\n\nThis provides a complete and systematic method for selecting and validating interface stiffness parameters in a finite element simulation.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and applies constraints for Goodman joint element stiffnesses\n    to determine if they pass the patch test without numerical issues.\n    \"\"\"\n    \n    # Test cases are defined as tuples:\n    # (E, nu, h, beta_min, kappa_max, kn, ks)\n    # For case 5, kn and ks are set to None to indicate they should be\n    # calculated based on the boundary condition definitions.\n    test_cases = [\n        # Test case 1 (happy path)\n        (3.0e10, 0.25, 0.25, 1.0, 200.0, 1.0e12, 5.0e11),\n        # Test case 2 (under-penalized normal)\n        (3.0e10, 0.25, 0.25, 1.0, 200.0, 1.0e10, 5.0e11),\n        # Test case 3 (under-penalized shear)\n        (3.0e10, 0.25, 0.25, 1.0, 200.0, 1.0e12, 1.0e9),\n        # Test case 4 (over-penalized causing ill-conditioning)\n        (3.0e10, 0.25, 0.25, 1.0, 100.0, 3.0e13, 3.0e13),\n        # Test case 5 (boundary case at lower bounds)\n        (3.0e10, 0.25, 0.25, 1.0, 500.0, None, None),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        E, nu, h, beta_min, kappa_max, kn_val, ks_val = case\n        \n        # Calculate shear modulus G\n        G = E / (2.0 * (1.0 + nu))\n        \n        # Calculate kn and ks for the boundary case (Test Case 5)\n        kn = kn_val if kn_val is not None else E / h\n        ks = ks_val if ks_val is not None else G / h\n\n        # Lower bound constraints for coercivity and accuracy\n        kn_min = beta_min * E / h\n        ks_min = beta_min * G / h\n        \n        # Upper bound constraints for numerical conditioning\n        kn_max = kappa_max * E / h\n        ks_max = kappa_max * G / h\n        \n        # Check if both normal and shear stiffnesses are within their bounds\n        is_kn_valid = (kn >= kn_min) and (kn = kn_max)\n        is_ks_valid = (ks >= ks_min) and (ks = ks_max)\n        \n        # The overall test passes only if both conditions are met\n        is_valid = is_kn_valid and is_ks_valid\n        \n        results.append(is_valid)\n\n    # Format the output as a single line: a list of boolean values\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3528504"}]}