{"hands_on_practices": [{"introduction": "Robust numerical simulations of bifurcation and post-buckling behavior hinge on the performance of the underlying nonlinear solver. This practice explores the cornerstone of that solver: the tangent stiffness matrix. You will derive the one-dimensional consistent algorithmic tangent, $\\mathbb{C}^{\\text{alg}}$, directly from the discrete return-mapping algorithm, providing a rigorous link between the constitutive update and the global Newton-Raphson method [@problem_id:3503188]. Understanding this derivation is key to appreciating why this specific tangent formulation is essential for achieving the quadratic convergence necessary to efficiently and accurately navigate the complex equilibrium paths near critical points.", "problem": "Consider a one-dimensional small-strain elastoplastic constitutive model intended to be embedded in a Finite Element Method (FEM) analysis of a geomechanical column that may experience bifurcation and post-buckling under axial compression. The elastic response is linear with Youngâ€™s modulus $E$, and the plasticity model is associative with a one-dimensional von Mises-type yield function with linear isotropic hardening modulus $H \\geq 0$. Let $\\sigma$ denote the Cauchy stress, $\\varepsilon$ the total strain, and $\\varepsilon^{p}$ the plastic strain. The constitutive relations are\n$$\n\\sigma = E \\left( \\varepsilon - \\varepsilon^{p} \\right), \\quad f(\\sigma, \\alpha) = |\\sigma| - \\left( \\sigma_{y0} + H \\alpha \\right) \\leq 0,\n$$\nwhere $\\alpha$ is the scalar hardening variable with $\\alpha = \\varepsilon^{p}$ in one dimension, and $\\sigma_{y0}  0$ is the initial yield stress. The evolution equations are given by the associative flow rule and hardening law\n$$\n\\dot{\\varepsilon}^{p} = \\dot{\\lambda} \\, \\text{sign}(\\sigma), \\quad \\dot{\\alpha} = \\dot{\\lambda}, \\quad \\dot{\\lambda} \\ge 0,\n$$\nwith the Karush-Kuhn-Tucker conditions\n$$\nf \\le 0, \\quad \\dot{\\lambda} \\ge 0, \\quad \\dot{\\lambda} f = 0.\n$$\nConsider a standard backward-Euler return-mapping algorithm over a time increment from step $n$ to step $n+1$. Given $\\varepsilon_{n+1}$ and known $(\\varepsilon^{p}_{n}, \\alpha_{n})$, form the elastic trial stress\n$$\n\\sigma^{\\text{tr}} = E \\left( \\varepsilon_{n+1} - \\varepsilon^{p}_{n} \\right),\n$$\nand evaluate $f^{\\text{tr}} = |\\sigma^{\\text{tr}}| - \\left( \\sigma_{y0} + H \\alpha_{n} \\right)$. If $f^{\\text{tr}} \\le 0$, the step is elastic and $\\sigma_{n+1} = \\sigma^{\\text{tr}}$; otherwise, plastic correction occurs with an increment $\\Delta \\lambda  0$ enforcing the discrete consistency $f_{n+1} = 0$ and the update\n$$\n\\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n} + \\Delta \\lambda \\, \\text{sign}(\\sigma^{\\text{tr}}), \\quad \\alpha_{n+1} = \\alpha_{n} + \\Delta \\lambda, \\quad \\sigma_{n+1} = E \\left( \\varepsilon_{n+1} - \\varepsilon^{p}_{n+1} \\right).\n$$\nAssume monotonically increasing compression such that $\\sigma^{\\text{tr}}  0$ and $\\text{sign}(\\sigma^{\\text{tr}}) = +1$ in the plastic regime. Starting from this return-mapping algorithm, derive the consistent algorithmic tangent $\\mathbb{C}^{\\text{alg}}$ in one dimension, defined as the derivative $d \\sigma_{n+1} / d \\varepsilon_{n+1}$ under active plasticity ($f_{n+1} = 0$). Then, explain why the consistent algorithmic tangent is required to achieve quadratic convergence of the Newton-Raphson method (NRM) when solving the global equilibrium equations near a bifurcation point in post-buckling analysis, and what convergence degradation occurs if a non-consistent tangent (e.g., a secant or elastic approximation) is used.\n\nExpress the final answer for the one-dimensional consistent algorithmic tangent as a closed-form analytic expression in terms of $E$ and $H$. No numerical evaluation is required, and no units should be provided in the final expression.", "solution": "The problem is first subjected to a rigorous validation process.\n\n### Step 1: Extract Givens\n- **Constitutive Model**: One-dimensional small-strain elastoplasticity.\n- **Young's Modulus**: $E$.\n- **Plasticity Model**: Associative, von Mises-type yield function with linear isotropic hardening.\n- **Hardening Modulus**: $H \\geq 0$.\n- **Variables**: Stress $\\sigma$, total strain $\\varepsilon$, plastic strain $\\varepsilon^{p}$, scalar hardening variable $\\alpha$.\n- **Stress-Strain Law**: $\\sigma = E ( \\varepsilon - \\varepsilon^{p} )$.\n- **Yield Function**: $f(\\sigma, \\alpha) = |\\sigma| - ( \\sigma_{y0} + H \\alpha ) \\leq 0$.\n- **Initial Yield Stress**: $\\sigma_{y0}  0$.\n- **Hardening Variable Relation**: $\\alpha = \\varepsilon^{p}$.\n- **Flow Rule**: $\\dot{\\varepsilon}^{p} = \\dot{\\lambda} \\, \\text{sign}(\\sigma)$.\n- **Hardening Law**: $\\dot{\\alpha} = \\dot{\\lambda}$.\n- **Kuhn-Tucker Conditions**: $\\dot{\\lambda} \\ge 0$, $f \\le 0$, $\\dot{\\lambda} f = 0$.\n- **Numerical Algorithm**: Backward-Euler return-mapping for an increment from step $n$ to $n+1$.\n- **Trial Stress**: $\\sigma^{\\text{tr}} = E ( \\varepsilon_{n+1} - \\varepsilon^{p}_{n} )$.\n- **Trial Yield Check**: $f^{\\text{tr}} = |\\sigma^{\\text{tr}}| - ( \\sigma_{y0} + H \\alpha_{n} )$.\n- **Plastic Update Rules**: For $f^{\\text{tr}}  0$,\n  - $\\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n} + \\Delta \\lambda \\, \\text{sign}(\\sigma^{\\text{tr}})$.\n  - $\\alpha_{n+1} = \\alpha_{n} + \\Delta \\lambda$.\n  - $\\sigma_{n+1} = E ( \\varepsilon_{n+1} - \\varepsilon^{p}_{n+1} )$.\n  - Discrete consistency: $f_{n+1} = 0$.\n- **Assumption**: Monotonically increasing compression, such that $\\sigma^{\\text{tr}}  0$ and $\\text{sign}(\\sigma^{\\text{tr}}) = +1$.\n- **Task 1**: Derive the consistent algorithmic tangent $\\mathbb{C}^{\\text{alg}} = d \\sigma_{n+1} / d \\varepsilon_{n+1}$ under active plasticity.\n- **Task 2**: Explain the role of the consistent tangent in the convergence of the Newton-Raphson method (NRM) for post-buckling analysis.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem describes a standard, textbook model of one-dimensional J2-type plasticity with linear hardening. The anachronistically named \"von Mises\" criterion in 1D is simply a condition on the magnitude of the stress. The backward-Euler return mapping and the concept of a consistent algorithmic tangent are fundamental and well-established topics in computational plasticity. The context of bifurcation analysis in geomechanics is appropriate and realistic. The problem is scientifically sound.\n- **Well-Posed**: The problem is clearly stated and provides all necessary constitutive equations, algorithmic steps, and assumptions to perform the required derivation. The question asks for a specific analytical result and a conceptual explanation, both of which are uniquely determined by the provided information.\n- **Objective**: The problem is expressed in precise, formal mathematical and engineering language, free of any subjectivity or ambiguity.\n- **Conclusion**: The problem does not violate any of the invalidity criteria. It is a valid, well-posed, and standard problem in computational mechanics.\n\n### Step 3: Verdict and Action\nThe problem is valid. A full solution will be provided.\n\n### Solution Derivation and Explanation\n\nThe solution consists of two parts: first, the derivation of the consistent algorithmic tangent modulus, and second, an explanation of its importance for the convergence of the Newton-Raphson Method (NRM) in nonlinear finite element analysis.\n\n#### Part 1: Derivation of the Consistent Algorithmic Tangent\n\nThe consistent algorithmic tangent, denoted here as $\\mathbb{C}^{\\text{alg}}$, is defined as the derivative of the stress at the end of the increment, $\\sigma_{n+1}$, with respect to the total strain at the end of the increment, $\\varepsilon_{n+1}$.\n$$\n\\mathbb{C}^{\\text{alg}} = \\frac{d\\sigma_{n+1}}{d\\varepsilon_{n+1}}\n$$\nThis derivative must be computed from the system of algebraic equations that define the final state $(\\sigma_{n+1}, \\varepsilon^{p}_{n+1}, \\alpha_{n+1})$ for a given $\\varepsilon_{n+1}$ and known history $(\\varepsilon^{p}_{n}, \\alpha_{n})$. We consider the case of active plasticity, where a plastic correction is performed.\n\nThe governing equations for the state at step $n+1$ are:\n1.  The stress update: $\\sigma_{n+1} = E (\\varepsilon_{n+1} - \\varepsilon^{p}_{n+1})$\n2.  The plastic strain update: $\\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n} + \\Delta\\lambda \\, \\text{sign}(\\sigma^{\\text{tr}})$\n3.  The hardening variable update: $\\alpha_{n+1} = \\alpha_{n} + \\Delta\\lambda$\n4.  The discrete yield condition (consistency): $f_{n+1} = |\\sigma_{n+1}| - (\\sigma_{y0} + H \\alpha_{n+1}) = 0$\n\nThe problem assumes monotonically increasing compression, so we can state $\\sigma^{\\text{tr}}  0$. Consequently, the updated stress $\\sigma_{n+1}$ will also be positive. This simplifies the equations: $\\text{sign}(\\sigma^{\\text{tr}}) = 1$ and $|\\sigma_{n+1}| = \\sigma_{n+1}$. The system becomes:\n1.  $\\sigma_{n+1} = E (\\varepsilon_{n+1} - \\varepsilon^{p}_{n+1})$\n2.  $\\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n} + \\Delta\\lambda$\n3.  $\\sigma_{n+1} - (\\sigma_{y0} + H \\alpha_{n+1}) = 0$\n4.  $\\alpha_{n+1} = \\alpha_{n} + \\Delta\\lambda$\n\nTo find $\\mathbb{C}^{\\text{alg}}$, we differentiate this system of equations with respect to $\\varepsilon_{n+1}$, treating $(\\varepsilon^{p}_{n}, \\alpha_{n})$ as constants from the previous step. The term $\\Delta\\lambda$ is a function of $\\varepsilon_{n+1}$ and must be differentiated.\n\nTaking the total differential of each equation:\n1.  $d\\sigma_{n+1} = E (d\\varepsilon_{n+1} - d\\varepsilon^{p}_{n+1})$\n2.  $d\\varepsilon^{p}_{n+1} = d(\\Delta\\lambda)$ (since $d\\varepsilon^{p}_{n} = 0$)\n3.  $d\\sigma_{n+1} - H d\\alpha_{n+1} = 0$\n4.  $d\\alpha_{n+1} = d(\\Delta\\lambda)$ (since $d\\alpha_{n} = 0$)\n\nFrom equations (3) and (4), we find a relationship between the differential of stress and the differential of the plastic multiplier:\n$$\nd\\sigma_{n+1} = H d\\alpha_{n+1} = H d(\\Delta\\lambda)\n$$\nFrom equation (2), we have $d\\varepsilon^{p}_{n+1} = d(\\Delta\\lambda)$. We can combine these to relate the increment of plastic strain to the increment of stress:\n$$\nd\\varepsilon^{p}_{n+1} = \\frac{1}{H} d\\sigma_{n+1}\n$$\nThis expression is valid for $H  0$. If $H=0$ (perfect plasticity), $d\\sigma_{n+1}=0$, implying the tangent is zero. The derived formula will reflect this. Now substitute this into the differential of the stress update equation (1):\n$$\nd\\sigma_{n+1} = E \\left( d\\varepsilon_{n+1} - \\frac{1}{H} d\\sigma_{n+1} \\right)\n$$\nRearranging to solve for the ratio $d\\sigma_{n+1} / d\\varepsilon_{n+1}$:\n$$\nd\\sigma_{n+1} = E d\\varepsilon_{n+1} - \\frac{E}{H} d\\sigma_{n+1}\n$$\n$$\nd\\sigma_{n+1} \\left( 1 + \\frac{E}{H} \\right) = E d\\varepsilon_{n+1}\n$$\n$$\nd\\sigma_{n+1} \\left( \\frac{H+E}{H} \\right) = E d\\varepsilon_{n+1}\n$$\nFinally, we obtain the expression for the consistent algorithmic tangent:\n$$\n\\mathbb{C}^{\\text{alg}} = \\frac{d\\sigma_{n+1}}{d\\varepsilon_{n+1}} = E \\frac{H}{E+H} = \\frac{EH}{E+H}\n$$\nThis modulus represents the tangent to the discrete stress-strain response produced by the backward-Euler algorithm. It is equivalent to the harmonic mean of the elastic modulus $E$ and the plastic hardening modulus $H$.\n\n#### Part 2: Role of the Consistent Tangent in NRM Convergence\n\nIn a nonlinear Finite Element Method (FEM) analysis, the primary goal is to solve the global system of equilibrium equations, which are generally nonlinear:\n$$\n\\mathbf{R}(\\mathbf{u}) = \\mathbf{F}^{\\text{ext}} - \\mathbf{F}^{\\text{int}}(\\mathbf{u}) = \\mathbf{0}\n$$\nwhere $\\mathbf{u}$ is the vector of global nodal displacements, $\\mathbf{R}(\\mathbf{u})$ is the residual vector, $\\mathbf{F}^{\\text{ext}}$ is the external nodal force vector, and $\\mathbf{F}^{\\text{int}}(\\mathbf{u})$ is the internal nodal force vector. The internal force vector is computed by integrating the stress field over the domain: $\\mathbf{F}^{\\text{int}} = \\int_V \\mathbf{B}^T \\boldsymbol{\\sigma} \\, dV$, where $\\mathbf{B}$ is the strain-displacement matrix.\n\nThe Newton-Raphson method is an iterative procedure for solving this nonlinear system. Starting from an estimate $\\mathbf{u}_i$, a better estimate $\\mathbf{u}_{i+1}$ is found by linearizing the system:\n$$\n\\mathbf{R}(\\mathbf{u}_i) + \\frac{d\\mathbf{R}}{d\\mathbf{u}}\\bigg|_{\\mathbf{u}_i} (\\mathbf{u}_{i+1} - \\mathbf{u}_i) = \\mathbf{0}\n$$\nThis leads to the iterative update scheme:\n$$\n\\mathbf{K}_T(\\mathbf{u}_i) \\Delta\\mathbf{u}_{i+1} = \\mathbf{R}(\\mathbf{u}_i)\n$$\nwhere $\\Delta\\mathbf{u}_{i+1} = \\mathbf{u}_{i+1} - \\mathbf{u}_i$ and $\\mathbf{K}_T$ is the global tangent stiffness matrix, defined as the exact Jacobian of the residual:\n$$\n\\mathbf{K}_T = -\\frac{d\\mathbf{R}}{d\\mathbf{u}} = \\frac{d\\mathbf{F}^{\\text{int}}}{d\\mathbf{u}}\n$$\nThe assembly of $\\mathbf{K}_T$ involves integrating contributions from each element, which requires the material tangent modulus $\\frac{d\\boldsymbol{\\sigma}}{d\\boldsymbol{\\varepsilon}}$:\n$$\n\\mathbf{K}_T = \\int_V \\mathbf{B}^T \\frac{d\\boldsymbol{\\sigma}}{d\\boldsymbol{\\varepsilon}} \\mathbf{B} \\, dV\n$$\nA fundamental theorem of numerical analysis states that the Newton-Raphson method exhibits an asymptotic quadratic rate of convergence provided that the tangent matrix used in the iteration ($\\mathbf{K}_T$) is the exact Jacobian of the function whose roots are being sought (the residual $\\mathbf{R}$).\n\nIn an implicit, time-discretized context as considered here, the stress $\\boldsymbol{\\sigma}_{n+1}$ at a material point is not a simple, explicit function of the current strain $\\boldsymbol{\\varepsilon}_{n+1}$. Instead, it is the result of the algorithmic procedure (the return-mapping). Therefore, the derivative $\\frac{d\\boldsymbol{\\sigma}}{d\\boldsymbol{\\varepsilon}}$ required for the exact Jacobian is precisely the consistent algorithmic tangent, $\\mathbb{C}^{\\text{alg}} = d\\boldsymbol{\\sigma}_{n+1}/d\\boldsymbol{\\varepsilon}_{n+1}$.\n\nUsing the consistent algorithmic tangent ensures that the global tangent stiffness matrix $\\mathbf{K}_T$ is the true Jacobian of the discretized equilibrium equations. This guarantees the quadratic convergence of the global NRM iterations, meaning the number of correct digits in the solution approximately doubles with each iteration close to the solution.\n\nIf a non-consistent tangent is used, the method becomes a quasi-Newton or modified Newton method. For example:\n- **Using the elastic tangent ($E$)**: This is a common simplification. The stiffness matrix is easier to compute and may only need to be factorized once. However, the matrix used is no longer the true Jacobian. The convergence rate degrades from quadratic to, at best, linear.\n- **Using the continuum elastoplastic tangent**: In this specific 1D case, the continuum tangent happens to be identical to the consistent tangent. However, for more complex multidimensional models (e.g., with non-associative plasticity or more intricate hardening laws), the continuum and consistent tangents differ. Using the continuum tangent where it differs from the consistent one would also result in the loss of quadratic convergence.\n\nThe consequences of using a non-consistent tangent are particularly severe near bifurcation or limit points, which characterize post-buckling behavior. At these critical points, the true tangent stiffness matrix $\\mathbf{K}_T$ becomes singular or nearly singular.\n- **Degraded Convergence**: The quadratic convergence of NRM is most needed in these highly nonlinear regimes. Linear convergence may be unacceptably slow or may fail entirely.\n- **Failure to Predict Instability**: The condition for bifurcation is $\\det(\\mathbf{K}_T) = 0$. If an approximate tangent (e.g., the elastic tangent) is used, the resulting matrix may never become singular under conditions that would cause plastic buckling, and the analysis would fail to correctly predict the instability.\n- **Lack of Robustness**: Using the consistent tangent dramatically improves the robustness of the numerical solution, allowing it to trace complex equilibrium paths, including snap-backs and snap-throughs common in post-buckling, which would be nearly impossible with a non-consistent tangent.\n\nIn summary, the consistent algorithmic tangent is the exact linearization of the discretized constitutive law, and its use is a necessary condition for maintaining the quadratic convergence rate of the Newton-Raphson method, ensuring both efficiency and robustness in complex nonlinear simulations.", "answer": "$$\n\\boxed{\\frac{EH}{E+H}}\n$$", "id": "3503188"}, {"introduction": "While standard load-controlled solvers fail near limit points, the arc-length method provides a robust framework for tracing the full post-buckling equilibrium path, including snap-through and snap-back phenomena. In this exercise, you will implement a spherical arc-length solver to navigate the classic snap-through response of a von Mises truss [@problem_id:3503289]. This hands-on implementation will solidify your understanding of path-following algorithms and the importance of validating numerical results against exact analytical solutions.", "problem": "Consider the symmetric two-bar von Mises truss: two identical straight bars of initial length $l_0$ connect a top joint at $(0,h)$ to two fixed pin supports at $(-a,0)$ and $(a,0)$. The top joint undergoes a vertical displacement $u$ that is positive downward. Each bar has axial rigidity $EA$ (Young's modulus times area), measured in Newtons ($\\mathrm{N}$). Assume axial response is linear elastic with engineering strain, and kinematics are geometrically exact for large displacements but small strains, so that the internal axial force in each bar is $N = EA \\, e$, where $e = (l - l_0)/l_0$ is the engineering strain and $l = \\sqrt{a^2 + (h - u)^2}$ is the current bar length. Let the external load $P$ be a vertical point load applied at the top joint, taken as positive upward, measured in Newtons ($\\mathrm{N}$). The vertical component of the internal forces from the two bars must balance the applied load at equilibrium.\n\nFrom first principles, starting from the definitions of engineering strain and force equilibrium, derive the exact load-displacement relation $P(u)$ and its tangent stiffness $K_t(u) = dP/du$ in terms of $a$, $h$, and $EA$. Use these expressions to define the residual $r(u,\\lambda) = f_{\\text{int}}(u) - \\lambda$, where $f_{\\text{int}}(u)$ is the exact internal load function and $\\lambda$ is a scalar load parameter such that the actual load is $P = \\lambda$. The governing equation is $r(u,\\lambda) = 0$.\n\nImplement a spherical arc-length method (Crisfield-Riks type) for the one-degree-of-freedom system to robustly trace the equilibrium path $P(u)$ through the limit point. Use the linearization of $r(u,\\lambda)$ with the tangent $K_t(u)$ and enforce the spherical constraint\n$$\n(\\Delta u)^2 + \\alpha \\, (\\Delta \\lambda)^2 = s^2,\n$$\nwhere $\\Delta u$ and $\\Delta \\lambda$ denote the accumulated increments within the current arc-length step, $s  0$ is a prescribed arc-length radius, and $\\alpha  0$ is a scaling factor chosen from the initial tangent to nondimensionalize the constraint. Start from the trivial equilibrium at $u=0$, $\\lambda=0$, and proceed until the current height $y = h - u$ reaches a lower bound $y_{\\min}$, beyond which the model is not to be advanced. Express displacements in meters ($\\mathrm{m}$) and loads in Newtons ($\\mathrm{N}$). Angles are not used; no angle unit is required.\n\nValidation requirement: At each converged equilibrium state $(u_i, \\lambda_i)$ produced by the arc-length solver, evaluate the exact internal function $f_{\\text{int}}(u_i)$. Compute the relative equilibrium error\n$$\n\\varepsilon_i = \\frac{| \\lambda_i - f_{\\text{int}}(u_i) |}{\\max\\{1, |f_{\\text{int}}(u_i)|\\}}.\n$$\nFor each test case, report the maximum of $\\varepsilon_i$ across all converged states up to the stopping point $y \\ge y_{\\min}$.\n\nFundamental base that you must use in your derivation and implementation:\n- Balance of forces at the top joint.\n- Engineering strain definition $e = (l - l_0)/l_0$ and axial force $N = EA \\, e$.\n- Exact geometry $l = \\sqrt{a^2 + (h - u)^2}$ for the current bar length.\n- Arc-length constraint and Newton linearization for solving $r(u,\\lambda)=0$ with the spherical constraint.\n\nYou must implement the following in a complete, runnable program:\n- Exact functions $f_{\\text{int}}(u)$ and $K_t(u)$ derived from the above principles.\n- A robust one-degree-of-freedom spherical arc-length solver with Newton iterations per step that enforces both $r(u,\\lambda)=0$ and the spherical constraint.\n- A validation routine that accumulates the maximum $\\varepsilon_i$ over the traced path.\n\nTest suite and parameters:\n- Use the following three parameter sets, expressed in meters ($\\mathrm{m}$) and Newtons ($\\mathrm{N}$), with the arc-length radius $s$ dimensionless as defined by your scaling choice for $\\alpha$:\n    - Case $1$: $(a,h,EA,s,n_{\\text{steps}},y_{\\min}/h) = (1.0, 1.0, 1.0\\times 10^5, 0.08, 60, 0.02)$.\n    - Case $2$: $(a,h,EA,s,n_{\\text{steps}},y_{\\min}/h) = (1.0, 0.3, 2.0\\times 10^5, 0.06, 80, 0.02)$.\n    - Case $3$: $(a,h,EA,s,n_{\\text{steps}},y_{\\min}/h) = (0.6, 1.2, 5.0\\times 10^6, 0.07, 60, 0.02)$.\n\nNumerical details to enforce:\n- Choose $\\alpha = 1/c^2$ with $c = |K_t(0)|$, i.e., scale by the magnitude of the initial tangent stiffness so that the arc-length constraint is nondimensional.\n- Use a Newton tolerance of $10^{-12}$ on the residual $|r(u,\\lambda)|$ scaled by $\\max\\{1, |\\lambda|, |f_{\\text{int}}(u)|\\}$.\n- Use a maximum of $30$ Newton iterations per arc-length step.\n- Stop the continuation when $y = h - u$ first satisfies $y \\le y_{\\min}$ or after the specified $n_{\\text{steps}}$ is reached.\n\nRequired final output format:\n- Your program should produce a single line of output containing the maximum relative equilibrium errors for the three cases as a comma-separated list enclosed in square brackets (e.g., \"[x1,x2,x3]\"), where each $x_i$ is a floating-point number. There must be no additional text in the output line.\n\nAll numerical values must be expressed in the units specified above, and the final reported quantities are unitless relative errors (dimensionless floats).", "solution": "The user wants to analyze the post-buckling behavior of a symmetric two-bar von Mises truss using a spherical arc-length numerical method.\n\n### Problem Validation\n\nI will first validate the problem statement according to the specified protocol.\n\n**Step 1: Extract Givens**\n\n*   **Geometry:** A symmetric two-bar truss with a top joint initially at $(0, h)$ and two fixed pin supports at $(-a, 0)$ and $(a, 0)$. The top joint undergoes a vertical displacement $u$, positive downward.\n*   **Bar Properties:** Each bar has an initial length $l_0$ and an axial rigidity $EA$.\n*   **Kinematics:** The initial bar length is $l_0 = \\sqrt{a^2 + h^2}$. The current bar length after displacement $u$ is $l = \\sqrt{a^2 + (h - u)^2}$.\n*   **Constitutive Law:** The axial response is linear elastic with engineering strain. The axial force in each bar is $N = EA \\cdot e$, where the engineering strain is $e = (l - l_0) / l_0$.\n*   **Equilibrium:** The external vertical load $P$ (positive upward) applied at the top joint is balanced by the vertical components of the internal bar forces.\n*   **Governing Equation:** The system is governed by the residual equation $r(u, \\lambda) = f_{\\text{int}}(u) - \\lambda = 0$, where $f_{\\text{int}}(u)$ is the exact internal load function (the total vertical force from the bars on the joint), and $\\lambda$ is a scalar load parameter such that the applied load is $P = \\lambda$.\n*   **Numerical Method:** A spherical arc-length method is to be used, governed by the constraint $(\\Delta u)^2 + \\alpha (\\Delta \\lambda)^2 = s^2$. Here, $\\Delta u$ and $\\Delta \\lambda$ are the total increments within a step, $s$ is the arc-length radius, and $\\alpha$ is a scaling factor.\n*   **Scaling Factor:** $\\alpha = 1/c^2$, where $c = |K_t(0)|$ and $K_t(u) = dP/du = df_{\\text{int}}/du$ is the tangent stiffness.\n*   **Solver Parameters:** Newton tolerance for convergence is $10^{-12}$ on the scaled residual. A maximum of $30$ Newton iterations per step is allowed.\n*   **Stopping Conditions:** The analysis stops when the current height $y = h - u$ reaches a lower bound $y_{\\min}$ or after a specified number of steps, $n_{\\text{steps}}$, is completed.\n*   **Validation Metric:** At each converged step $i$, the relative equilibrium error $\\varepsilon_i = \\frac{| \\lambda_i - f_{\\text{int}}(u_i) |}{\\max\\{1, |f_{\\text{int}}(u_i)|\\}}$ must be computed. The maximum of these errors is to be reported.\n*   **Test Cases:** Three sets of parameters $(a, h, EA, s, n_{\\text{steps}}, y_{\\min}/h)$ are provided.\n\n**Step 2: Validate Using Extracted Givens**\n\n*   **Scientifically Grounded:** The problem is a classic and fundamental example in nonlinear structural mechanics, used to illustrate concepts like limit points, snap-through phenomena, and path-following algorithms. The principles of mechanics (kinematics, constitutive law, equilibrium) are correctly applied. The model is sound.\n*   **Well-Posed:** The problem is well-posed. It describes a one-degree-of-freedom system and asks for the tracing of its equilibrium path. The use of an arc-length method is appropriate for navigating the limit points expected in this system's response. All necessary parameters and conditions for a unique solution trace are provided.\n*   **Objective:** The problem is stated in precise, objective mathematical and physical terms, free of any subjectivity or ambiguity.\n*   **Consistency and Completeness:** The problem is self-contained. All variables, constants, and functions are clearly defined. The conditions are internally consistent. For example, the definition of the residual $r(u, \\lambda)$ is consistent with the equilibrium condition $P = f_{\\text{int}}(u)$ when $P=\\lambda$.\n\n**Step 3: Verdict and Action**\n\nThe problem is deemed **valid**. It is a well-defined problem in computational mechanics that is scientifically sound and objective. I will now proceed with the solution.\n\n### Derivation of Governing Functions\n\nFirst, we derive the exact expressions for the internal force function $f_{\\text{int}}(u)$ and the tangent stiffness $K_t(u)$.\n\n**1. Internal Force, $f_{\\text{int}}(u)$**\n\nThe top joint is located at coordinates $(0, h-u)$. The force vector from one bar (e.g., the right one) on the joint is directed along the bar's axis. The vector from the support at $(a, 0)$ to the joint at $(0, h-u)$ is $\\vec{v} = (-a, h-u)$. The length of this vector is the current bar length, $l(u) = \\sqrt{(-a)^2 + (h-u)^2} = \\sqrt{a^2 + (h-u)^2}$.\n\nThe axial force in each bar, with tension defined as positive, is given by:\n$$N(u) = EA \\cdot e = EA \\frac{l(u) - l_0}{l_0}$$\nwhere $l_0 = \\sqrt{a^2 + h^2}$ is the initial, unstressed length of the bars.\n\nThe force vector from the right bar on the joint is $\\vec{F}_{\\text{right}} = N \\frac{\\vec{v}}{l(u)} = N \\frac{1}{l(u)}(-a, h-u)$.\nSimilarly, the force vector from the left bar (support at $(-a,0)$) on the joint is $\\vec{F}_{\\text{left}} = N \\frac{1}{l(u)}(a, h-u)$.\n\nThe total internal force vector exerted by the truss on the joint is the sum:\n$$\\vec{F}_{\\text{int}} = \\vec{F}_{\\text{left}} + \\vec{F}_{\\text{right}} = \\frac{N}{l(u)}(-a+a, h-u+h-u) = \\frac{N}{l(u)}(0, 2(h-u))$$\nThe vertical component of this force, which we define as $f_{\\text{int}}(u)$ (positive upward), is:\n$$f_{\\text{int}}(u) = \\frac{2N(u)(h-u)}{l(u)}$$\nSubstituting the expressions for $N(u)$ and $l(u)$:\n$$f_{\\text{int}}(u) = 2 \\left(EA \\frac{l(u) - l_0}{l_0}\\right) \\frac{h-u}{l(u)} = 2\\frac{EA}{l_0} (h-u) \\left(1 - \\frac{l_0}{l(u)}\\right)$$\nExplicitly, this is:\n$$f_{\\text{int}}(u) = 2\\frac{EA}{l_0} (h-u) \\left(1 - \\frac{l_0}{\\sqrt{a^2 + (h-u)^2}}\\right)$$\nAt equilibrium, this internal force balances the applied load $P=\\lambda$, so $f_{\\text{int}}(u) = \\lambda$.\n\n**2. Tangent Stiffness, $K_t(u)$**\n\nThe tangent stiffness is the derivative of the internal force with respect to the displacement: $K_t(u) = \\frac{df_{\\text{int}}}{du}$.\nLet's rewrite $f_{\\text{int}}(u) = 2\\frac{EA}{l_0} \\left( (h-u) - l_0 \\frac{h-u}{l(u)} \\right)$.\nWe use the chain rule and the quotient rule. The derivative of the first term, $(h-u)$, is $-1$. For the second term, we need the derivative of $\\frac{h-u}{l(u)}$:\n$$ \\frac{d}{du}\\left(\\frac{h-u}{\\sqrt{a^2 + (h-u)^2}}\\right) = \\frac{(-1)\\sqrt{a^2+(h-u)^2} - (h-u) \\frac{-2(h-u)}{2\\sqrt{a^2+(h-u)^2}}}{a^2+(h-u)^2} $$\n$$ = \\frac{-l(u) + \\frac{(h-u)^2}{l(u)}}{l(u)^2} = \\frac{-l(u)^2 + (h-u)^2}{l(u)^3} = \\frac{-(a^2+(h-u)^2) + (h-u)^2}{l(u)^3} = \\frac{-a^2}{l(u)^3} $$\nSubstituting this back into the derivative for $K_t(u)$:\n$$ K_t(u) = \\frac{df_{\\text{int}}}{du} = 2\\frac{EA}{l_0} \\left( -1 - l_0 \\left(\\frac{-a^2}{l(u)^3}\\right) \\right) = 2\\frac{EA}{l_0} \\left( \\frac{l_0 a^2}{l(u)^3} - 1 \\right) $$\n$$ K_t(u) = 2EA \\left( \\frac{a^2}{l(u)^3} - \\frac{1}{l_0} \\right) $$\nwhere $l(u) = \\sqrt{a^2 + (h-u)^2}$ and $l_0 = \\sqrt{a^2 + h^2}$.\n\n### Arc-Length Method Implementation\n\nThe numerical solution traces the equilibrium path $(u, \\lambda)$ by solving the system comprising the residual equation $r(u, \\lambda) = 0$ and the arc-length constraint.\n\n**Algorithm Outline:**\nStarting from a converged state $(u_i, \\lambda_i)$:\n1.  **Predictor:** A tangent predictor estimates the next point. An initial step $(\\delta u, \\delta \\lambda)$ is calculated that is tangent to the equilibrium path and has a length $s$.\n    $$ \\delta u = \\sigma \\frac{s}{\\sqrt{1+\\alpha K_{t,i}^2}}, \\quad \\delta \\lambda = K_{t,i} \\delta u $$\n    The sign $\\sigma$ is chosen to ensure the path continues in the same general direction. For the first step, $\\sigma=1$ is chosen to initiate downward displacement. The predictor state is $(u_{i+1}^{(0)}, \\lambda_{i+1}^{(0)}) = (u_i + \\delta u, \\lambda_i + \\delta \\lambda)$.\n\n2.  **Corrector:** A Newton-Raphson scheme iteratively corrects the predictor state to satisfy both the equilibrium and constraint equations. In each corrector iteration $j$, we solve for corrections $(du, d\\lambda)$ to the current state $(u^{(j)}, \\lambda^{(j)})$.\n    The linearization of the equilibrium equation is $r^{(j)} + K_t^{(j)} du - d\\lambda = 0$.\n    The spherical constraint is $(\\Delta u^{(j)}+du)^2 + \\alpha(\\Delta \\lambda^{(j)}+d\\lambda)^2 = s^2$, where $\\Delta u^{(j)}$ and $\\Delta\\lambda^{(j)}$ are the total increments from the start of the step, $(u_i, \\lambda_i)$.\n\n    Substituting $d\\lambda = r^{(j)} + K_t^{(j)} du$ into the constraint equation leads to a quadratic equation for $du$:\n    $$ A(du)^2 + B(du) + C = 0 $$\n    with coefficients:\n    $$ A = 1 + \\alpha (K_t^{(j)})^2 $$\n    $$ B = 2\\left(\\Delta u^{(j)} + \\alpha K_t^{(j)} (\\Delta \\lambda^{(j)} + r^{(j)})\\right) $$\n    $$ C = (\\Delta u^{(j)})^2 + \\alpha (\\Delta \\lambda^{(j)} + r^{(j)})^2 - s^2 $$\n    This quadratic equation yields two possible solutions for $du$. The correct root is chosen by selecting the one that minimizes the change in direction of the total step increment vector. That is, we choose the solution that maximizes the dot product between the new total increment vector and the previous one within the current Newton iteration.\n\n3.  **Convergence:** The corrector iterations continue until the scaled residual $|r^{(j)}| / \\max(1, |\\lambda^{(j)}|, |f_{\\text{int}}(u^{(j)})|)$ falls below the specified tolerance of $10^{-12}$.\n\n4.  **Validation and Termination:** After each step converges to a new equilibrium state $(u_{i+1}, \\lambda_{i+1})$, the relative equilibrium error $\\varepsilon_{i+1}$ is computed and the maximum error seen so far is updated. The process terminates if $h - u_{i+1} \\le y_{\\min}$ or the maximum number of steps is reached.\n\nThe Python implementation will encapsulate this logic, with helper functions for $f_{\\text{int}}(u)$ and $K_t(u)$, and a main solver function that iterates through the test cases.", "answer": "```python\nimport numpy as np\nimport math\n\n# Meticulous and exacting professor's implementation\n\ndef get_fint(u, a, h, EA, l0):\n    \"\"\"\n    Calculates the exact internal force f_int(u).\n    f_int is the upward vertical force from the truss on the joint.\n    \"\"\"\n    # Defensive check for u  h + a small epsilon to avoid sqrt of negative\n    # though with the problem constraints, this is unlikely.\n    # Current bar length\n    val_in_sqrt = a**2 + (h - u)**2\n    if val_in_sqrt  0:\n        return np.nan  # Should not happen in this problem\n    l = np.sqrt(val_in_sqrt)\n\n    if abs(l)  1e-12: # Bars are vertical and joint at support level\n        return 0.0\n\n    # f_int(u) = 2 * (EA/l0) * (h-u) * (1 - l0/l)\n    term1 = 2.0 * EA / l0\n    term2 = h - u\n    term3 = 1.0 - l0 / l\n    return term1 * term2 * term3\n\ndef get_kt(u, a, h, EA, l0):\n    \"\"\"\n    Calculates the exact tangent stiffness K_t(u) = d(f_int)/du.\n    \"\"\"\n    val_in_sqrt = a**2 + (h - u)**2\n    if val_in_sqrt  1e-12:\n        return np.nan # Division by zero if l=0\n    l = np.sqrt(val_in_sqrt)\n    l_cubed = l**3\n\n    if abs(l_cubed)  1e-12:\n        return np.nan\n        \n    # K_t(u) = 2 * EA * (a^2 / l^3 - 1/l0)\n    return 2.0 * EA * (a**2 / l_cubed - 1.0 / l0)\n\ndef solve_case(params):\n    \"\"\"\n    Solves a single test case using the spherical arc-length method.\n    \"\"\"\n    a, h, EA, s, n_steps, y_min_ratio = params\n    \n    l0 = np.sqrt(a**2 + h**2)\n    y_stop = y_min_ratio * h\n    \n    # Numerical parameters\n    tol = 1e-12\n    max_newton_iter = 30\n    \n    # Path history\n    u_path = [0.0]\n    lambda_path = [0.0]\n    max_rel_error = 0.0\n    \n    # Initial state (Step 0)\n    u_i, lambda_i = 0.0, 0.0\n    \n    # Calculate scaling factor alpha\n    k_t0 = get_kt(u_i, a, h, EA, l0)\n    if abs(k_t0)  1e-12:\n        # Should not happen for given test cases\n        raise ValueError(\"Initial stiffness is zero, cannot define alpha.\")\n    c = np.abs(k_t0)\n    alpha = 1.0 / (c**2)\n\n    # Arc-length continuation loop\n    for i in range(n_steps):\n        # --- PREDICTOR ---\n        k_t_i = get_kt(u_i, a, h, EA, l0)\n        \n        # Predictor increment based on tangent\n        # du^2 + alpha * (Kt*du)^2 = s^2 = du = s / sqrt(1 + alpha*Kt^2)\n        denom = np.sqrt(1.0 + alpha * k_t_i**2)\n        du_pred = s / denom\n        dlambda_pred = k_t_i * du_pred\n\n        # Determine direction of step\n        if i  0:\n            # Check dot product with previous step vector\n            du_prev_step = u_path[-1] - u_path[-2]\n            dlambda_prev_step = lambda_path[-1] - lambda_path[-2]\n            dot_prod = du_pred * du_prev_step + dlambda_pred * dlambda_prev_step\n            if dot_prod  0:\n                du_pred = -du_pred\n                dlambda_pred = -dlambda_pred\n        \n        # Initial guess for the next point (iterator j=0)\n        u_j = u_i + du_pred\n        lambda_j = lambda_i + dlambda_pred\n\n        # --- CORRECTOR (Newton-Raphson loop) ---\n        converged = False\n        for j in range(max_newton_iter):\n            # Evaluate state at current iterate\n            fint_j = get_fint(u_j, a, h, EA, l0)\n            kt_j = get_kt(u_j, a, h, EA, l0)\n            \n            if math.isnan(fint_j) or math.isnan(kt_j):\n                break # Should not happen\n\n            r_j = fint_j - lambda_j\n            \n            # Check for convergence\n            norm = max(1.0, abs(lambda_j), abs(fint_j))\n            if abs(r_j) / norm  tol:\n                converged = True\n                break\n\n            # Solve for corrections (du, dlambda) via quadratic equation for du\n            # A*(du)^2 + B*(du) + C = 0\n            delta_u_j = u_j - u_i\n            delta_lambda_j = lambda_j - lambda_i\n\n            # Coefficients\n            A = 1.0 + alpha * kt_j**2\n            B = 2.0 * (delta_u_j + alpha * kt_j * (delta_lambda_j + r_j))\n            C = delta_u_j**2 + alpha * (delta_lambda_j + r_j)**2 - s**2\n\n            # Solve quadratic for du\n            discriminant = B**2 - 4.0 * A * C\n            if discriminant  0:\n                # Should not happen with a reasonable step size\n                break\n            \n            sqrt_D = np.sqrt(discriminant)\n            du1 = (-B + sqrt_D) / (2.0 * A)\n            du2 = (-B - sqrt_D) / (2.0 * A)\n\n            # Corresponding dlambda corrections\n            dlambda1 = r_j + kt_j * du1\n            dlambda2 = r_j + kt_j * du2\n\n            # Choose the correct root by maximizing dot product with previous increment vector\n            vec_prev_total = np.array([delta_u_j, delta_lambda_j])\n            \n            vec_new_total1 = np.array([delta_u_j + du1, delta_lambda_j + dlambda1])\n            vec_new_total2 = np.array([delta_u_j + du2, delta_lambda_j + dlambda2])\n\n            dot1 = np.dot(vec_prev_total, vec_new_total1)\n            dot2 = np.dot(vec_prev_total, vec_new_total2)\n\n            if j == 0 and i == 0: # First iteration of first step has no previous vector\n                # Choose smaller correction norm\n                if np.linalg.norm([du1, dlambda1])  np.linalg.norm([du2, dlambda2]):\n                    du_corr, dlambda_corr = du1, dlambda1\n                else:\n                    du_corr, dlambda_corr = du2, dlambda2\n            else: # Standard case\n                if dot1  dot2:\n                    du_corr, dlambda_corr = du1, dlambda1\n                else:\n                    du_corr, dlambda_corr = du2, dlambda2\n            \n            # Update state\n            u_j += du_corr\n            lambda_j += dlambda_corr\n\n        if not converged:\n            # If Newton loop failed, we cannot continue\n            # For this problem, we assume it will converge.\n            break\n\n        # --- POST-STEP ---\n        # Store converged point\n        u_i, lambda_i = u_j, lambda_j\n        u_path.append(u_i)\n        lambda_path.append(lambda_i)\n        \n        # Calculate and update max relative error\n        f_int_final = get_fint(u_i, a, h, EA, l0)\n        rel_error = abs(lambda_i - f_int_final) / max(1.0, abs(f_int_final))\n        if rel_error  max_rel_error:\n            max_rel_error = rel_error\n            \n        # Check stopping condition\n        if (h - u_i) = y_stop:\n            break\n            \n    return max_rel_error\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Test cases: (a, h, EA, s, n_steps, y_min/h)\n    test_cases = [\n        (1.0, 1.0, 1.0e5, 0.08, 60, 0.02),\n        (1.0, 0.3, 2.0e5, 0.06, 80, 0.02),\n        (0.6, 1.2, 5.0e6, 0.07, 60, 0.02),\n    ]\n\n    results = []\n    for case in test_cases:\n        max_error = solve_case(case)\n        results.append(max_error)\n\n    # Format output as a list of floats\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3503289"}, {"introduction": "Strain localization in softening geomaterials, such as the formation of shear bands, poses a significant challenge for numerical modeling, often leading to results that are pathologically dependent on the mesh discretization. This practice provides a direct numerical experiment to investigate this mesh bias and explore a powerful remedy through regularization [@problem_id:3503193]. By implementing and comparing local and nonlocal integral models, you will quantify how mesh orientation can pollute simulation results and see firsthand how a nonlocal approach, which introduces an internal length scale, restores objectivity to the post-bifurcation analysis.", "problem": "Consider a two-dimensional plane-strain body occupying a square domain with side length $L$ (in meters), discretized by a uniform grid of square elements (cells) with spacing $h$ (in meters). The fundamental basis is the balance of linear momentum in quasi-static conditions, the small-strain kinematics, and the existence of a strain-softening post-bifurcation regime that yields a localized shear band. In computational geomechanics, orientation bias of shear bands may arise from the discretization grid (mesh bias). A regularization strategy is to replace the local plastic shear strain $\\gamma_p(\\boldsymbol{x})$ by a nonlocal integral average $\\overline{\\gamma}_p(\\boldsymbol{x})$ with a characteristic internal length $l$ (in meters), which aims to produce mesh-objective post-bifurcation solutions.\n\nAssume an idealized post-bifurcation plastic shear strain field representing a single straight shear band with true orientation $\\theta^\\star$ (in radians) passing through the domain center. The field is taken as a narrow profile concentrated along a line, described by a Gaussian function of the signed perpendicular distance to the band. Denote by $\\boldsymbol{t}(\\theta^\\star)$ the unit tangent vector of the band and $\\boldsymbol{n}(\\theta^\\star)$ the unit normal vector to the band, where $\\boldsymbol{t}(\\theta^\\star)=\\left[\\cos(\\theta^\\star),\\sin(\\theta^\\star)\\right]$ and $\\boldsymbol{n}(\\theta^\\star)=\\left[-\\sin(\\theta^\\star),\\cos(\\theta^\\star)\\right]$. Let the domain center be at the origin. The local field is defined by\n$$\n\\gamma_p(\\boldsymbol{x}) = \\exp\\!\\left(-\\frac{\\left(\\boldsymbol{x}\\cdot \\boldsymbol{n}(\\theta^\\star)\\right)^2}{2 w^2}\\right),\n$$\nwhere $w$ (in meters) is the band half-thickness parameter. The nonlocal integral plastic shear strain with internal length $l$ is defined by\n$$\n\\overline{\\gamma}_p(\\boldsymbol{x}) = \\frac{\\displaystyle \\int_{\\Omega} \\omega\\!\\left(\\frac{\\|\\boldsymbol{x}-\\boldsymbol{\\xi}\\|}{l}\\right)\\,\\gamma_p(\\boldsymbol{\\xi})\\,\\mathrm{d}\\boldsymbol{\\xi}}{\\displaystyle \\int_{\\Omega} \\omega\\!\\left(\\frac{\\|\\boldsymbol{x}-\\boldsymbol{\\xi}\\|}{l}\\right)\\,\\mathrm{d}\\boldsymbol{\\xi}},\n$$\nwhere $\\omega(r) = \\exp\\!\\left(-r^2\\right)$ is a radially symmetric kernel and $\\Omega$ is the domain. A zero internal length $l=0$ recovers the local field, whereas $l0$ introduces objective regularization.\n\nTo quantify mesh bias, consider the computational mesh rotated by an angle $\\alpha$ (in radians) with respect to the global axes. The grid points $(x_g,y_g)$ in the mesh coordinates map to global coordinates $(x,y)$ via the rotation matrix\n$$\n\\boldsymbol{R}(\\alpha)=\\begin{bmatrix}\\cos(\\alpha)  -\\sin(\\alpha)\\\\ \\sin(\\alpha)  \\cos(\\alpha)\\end{bmatrix},\\quad\n\\begin{bmatrix}x\\\\y\\end{bmatrix}=\\boldsymbol{R}(\\alpha)\\begin{bmatrix}x_g\\\\y_g\\end{bmatrix}.\n$$\nThe discretized field is sampled at the rotated global coordinates and processed on the mesh grid. The band orientation is estimated from the discretized field by the structure tensor constructed from finite-difference gradients. Define the discrete gradients $\\partial_x \\phi$ and $\\partial_y \\phi$ by periodic-centered differences on the rotated grid for a field $\\phi$. The global structure tensor is\n$$\n\\boldsymbol{J}=\\begin{bmatrix}\n\\langle(\\partial_x \\phi)^2\\rangle  \\langle(\\partial_x \\phi)(\\partial_y \\phi)\\rangle\\\\\n\\langle(\\partial_x \\phi)(\\partial_y \\phi)\\rangle  \\langle(\\partial_y \\phi)^2\\rangle\n\\end{bmatrix},\n$$\nwhere $\\langle\\cdot\\rangle$ denotes the spatial average over all grid points. The eigenvector associated with the smallest eigenvalue of $\\boldsymbol{J}$ is an estimate of the band tangent direction, because gradients concentrate along the band normal. Denote the estimated tangent direction by $\\hat{\\boldsymbol{t}}$ with orientation angle $\\hat{\\theta}$ (in radians), computed by $\\hat{\\theta}=\\mathrm{atan2}(\\hat{t}_y,\\hat{t}_x)$ and reduced modulo $\\pi$ to account for orientation equivalence. Quantify the mesh-induced orientation error by\n$$\ne(\\alpha,l)=\\min\\!\\left(|\\hat{\\theta}-\\theta^\\star|,\\ \\pi-|\\hat{\\theta}-\\theta^\\star|\\right),\n$$\nin radians.\n\nYour task is to write a complete program that:\n- Constructs the local post-bifurcation field $\\gamma_p(\\boldsymbol{x})$ on a uniform grid of $N\\times N$ points with spacing $h$, with the domain centered at the origin and grid nodes placed at cell centers.\n- Applies the rotation $\\alpha$ to the grid and samples the field at the rotated global coordinates.\n- For each test case, computes the nonlocal field $\\overline{\\gamma}_p$ using the Gaussian kernel with internal length $l$ by discrete convolution on the grid with periodic boundary conditions. For $l=0$, use the local field without convolution.\n- Computes the discrete gradients of the chosen field (local or nonlocal) using periodic-centered differences and forms the structure tensor $\\boldsymbol{J}$ by spatial averaging.\n- Extracts $\\hat{\\theta}$ from the eigenvector of $\\boldsymbol{J}$ corresponding to its smallest eigenvalue and evaluates the orientation error $e(\\alpha,l)$.\n\nUse the following physically and numerically sound parameters:\n- Grid size $N=\\;256$ (dimensionless), spacing $h=\\;0.01$ (in meters), domain side $L=N\\,h$ (in meters).\n- True band orientation $\\theta^\\star=\\;\\pi/6$ (in radians), band half-thickness $w=\\;0.02$ (in meters).\n- Periodic boundary conditions for differences and convolution.\n\nYour program must evaluate the following test suite, which together probes the general case, rotation-induced bias, and nonlocal regularization effectiveness:\n- Test $\\#1$: $\\alpha=\\;0$, $l=\\;0$.\n- Test $\\#2$: $\\alpha=\\;\\pi/8$, $l=\\;0$.\n- Test $\\#3$: $\\alpha=\\;\\pi/4$, $l=\\;0$.\n- Test $\\#4$: $\\alpha=\\;\\pi/8$, $l=\\;0.05$ (in meters).\n- Test $\\#5$: $\\alpha=\\;\\pi/4$, $l=\\;\\;0.05$ (in meters).\n\nAngle quantities must be in radians. Length quantities must be in meters. For each test, your program must compute a single floating-point value $e(\\alpha,l)$ in radians. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[e_1,e_2,e_3,e_4,e_5]$), in this exact format, where $e_k$ is the value of $e(\\alpha,l)$ for test $k$.", "solution": "The problem statement has been validated and is deemed sound. It is scientifically grounded in computational geomechanics, well-posed, objective, and provides a complete and consistent set of definitions and parameters for a solvable numerical experiment. The task is to quantify orientation bias in a discretized model of a shear band and assess the effectiveness of a nonlocal regularization technique.\n\nThe solution will be constructed following these primary steps:\n1.  Discretize the square domain and generate the computational grid coordinates.\n2.  For each test case, apply the specified rotation $\\alpha$ to the grid coordinates.\n3.  Evaluate the idealized local plastic shear strain field $\\gamma_p(\\boldsymbol{x})$ at the rotated grid points.\n4.  If the internal length $l  0$, compute the regularized nonlocal field $\\overline{\\gamma}_p(\\boldsymbol{x})$ via a normalized convolution performed in the Fourier domain for computational efficiency and to correctly handle periodic boundary conditions.\n5.  Compute the discrete gradients of the field (local for $l=0$, nonlocal for $l0$) using periodic-centered differences.\n6.  Construct the structure tensor $\\boldsymbol{J}$ by spatially averaging the outer products of the gradient field.\n7.  Determine the estimated band orientation $\\hat{\\theta}$ from the eigenvector corresponding to the smallest eigenvalue of $\\boldsymbol{J}$.\n8.  Calculate the orientation error $e(\\alpha, l)$ as the shortest angular distance between the estimated orientation $\\hat{\\theta}$ and the true orientation $\\theta^\\star$.\n\nThe parameters are given as: grid size $N=256$, grid spacing $h=0.01$ m, domain side length $L = N h = 2.56$ m, true band orientation $\\theta^\\star = \\pi/6$ rad, and band half-thickness $w=0.02$ m.\n\n**Step 1: Grid Generation and Coordinate Transformation**\nThe domain $\\Omega$ is a square of side length $L=2.56$ m centered at the origin. We discretize it into an $N \\times N$ grid with $N=256$. The grid nodes are placed at cell centers. The coordinates for the unrotated mesh grid, denoted $(x_g, y_g)$, are thus generated over the range $[-L/2 + h/2, L/2 - h/2]$.\nLet $\\boldsymbol{x}_g = [x_g, y_g]^T$ be a point on the mesh grid. For a given mesh rotation angle $\\alpha$, the corresponding global coordinates $\\boldsymbol{x} = [x, y]^T$ are found by the rotation:\n$$\n\\boldsymbol{x} = \\boldsymbol{R}(\\alpha) \\boldsymbol{x}_g = \\begin{bmatrix}\\cos(\\alpha)  -\\sin(\\alpha)\\\\ \\sin(\\alpha)  \\cos(\\alpha)\\end{bmatrix} \\begin{bmatrix}x_g\\\\y_g\\end{bmatrix}\n$$\nThis gives us a set of sampling points in the global coordinate system, but arranged on a rotated grid structure.\n\n**Step 2: Local Plastic Strain Field**\nThe local plastic shear strain field $\\gamma_p$ is a Gaussian profile centered on a line passing through the origin with true orientation $\\theta^\\star$. The normal to this line is $\\boldsymbol{n}(\\theta^\\star) = [-\\sin(\\theta^\\star), \\cos(\\theta^\\star)]^T$. At each rotated global grid point $\\boldsymbol{x}$, the field is evaluated as:\n$$\n\\gamma_p(\\boldsymbol{x}) = \\exp\\!\\left(-\\frac{\\left(\\boldsymbol{x}\\cdot \\boldsymbol{n}(\\theta^\\star)\\right)^2}{2 w^2}\\right)\n$$\nSubstituting the components of $\\boldsymbol{x}$ and $\\boldsymbol{n}(\\theta^\\star)$:\n$$\n\\boldsymbol{x}\\cdot \\boldsymbol{n}(\\theta^\\star) = -x\\sin(\\theta^\\star) + y\\cos(\\theta^\\star)\n$$\nThis expression is computed for all points on the $N \\times N$ grid, yielding the discrete representation of the local field, denoted as a matrix $\\boldsymbol{\\Gamma}_p$.\n\n**Step 3: Nonlocal Regularization**\nFor test cases with a non-zero internal length $l  0$, the local field $\\boldsymbol{\\Gamma}_p$ is regularized by convolution. The nonlocal field is defined as:\n$$\n\\overline{\\gamma}_p(\\boldsymbol{x}) = \\frac{\\mathcal{N}(\\boldsymbol{x})}{\\mathcal{D}(\\boldsymbol{x})} = \\frac{\\displaystyle \\int_{\\Omega} \\omega\\!\\left(\\frac{\\|\\boldsymbol{x}-\\boldsymbol{\\xi}\\|}{l}\\right)\\,\\gamma_p(\\boldsymbol{\\xi})\\,\\mathrm{d}\\boldsymbol{\\xi}}{\\displaystyle \\int_{\\Omega} \\omega\\!\\left(\\frac{\\|\\boldsymbol{x}-\\boldsymbol{\\xi}\\|}{l}\\right)\\,\\mathrm{d}\\boldsymbol{\\xi}}\n$$\nwhere the kernel is $\\omega(r)=\\exp(-r^2)$. Both numerator $\\mathcal{N}$ and denominator $\\mathcal{D}$ are convolutions. $\\mathcal{N} = (\\omega_l * \\gamma_p)(\\boldsymbol{x})$ and $\\mathcal{D} = (\\omega_l * \\mathbf{1})(\\boldsymbol{x})$, where $\\omega_l$ is the kernel scaled by $l$ and $\\mathbf{1}$ is a field of ones.\nFor a discrete, periodic domain, convolution is most efficiently computed using the Fast Fourier Transform (FFT) via the convolution theorem: $\\mathcal{F}\\{f*g\\} = \\mathcal{F}\\{f\\} \\cdot \\mathcal{F}\\{g\\}$, where $\\mathcal{F}$ is the Fourier transform operator.\nThe algorithm is as follows:\n1.  Construct the discrete convolution kernel $\\boldsymbol{W}$ on the grid. The value at grid point $(i,j)$ with coordinates $(x_{g,i}, y_{g,j})$ is $W_{ij} = \\exp(-(x_{g,i}^2 + y_{g,j}^2)/l^2)$. To prepare for the FFT, which assumes the $(0,0)$ frequency is at index $(0,0)$, the kernel must be shifted so its center (the origin) is at index $(0,0)$. This is done with `fftshift`.\n2.  Compute the 2D FFT of the local field $\\boldsymbol{\\Gamma}_p$, the kernel $\\boldsymbol{W}$ (after shifting), and a field of ones $\\boldsymbol{1}$.\n3.  Compute the products in Fourier space: $\\mathcal{F}\\{\\mathcal{N}\\} = \\mathcal{F}\\{\\boldsymbol{\\Gamma}_p\\} \\cdot \\mathcal{F}\\{\\boldsymbol{W}\\}$ and $\\mathcal{F}\\{\\mathcal{D}\\} = \\mathcal{F}\\{\\boldsymbol{1}\\} \\cdot \\mathcal{F}\\{\\boldsymbol{W}\\}$.\n4.  Compute the inverse FFT of these products to obtain the numerator and denominator in real space.\n5.  The nonlocal field is the element-wise division of the resulting real parts: $\\overline{\\boldsymbol{\\Gamma}}_p = \\text{Re}\\{\\mathcal{N}\\} / \\text{Re}\\{\\mathcal{D}\\}$.\nFor test cases with $l=0$, this step is skipped, and the field to be analyzed is simply the local field $\\boldsymbol{\\Gamma}_p$. Let us denote the field to be analyzed (either local or nonlocal) by $\\boldsymbol{\\Phi}$.\n\n**Step 4: Structure Tensor and Orientation Estimation**\nThe orientation of the dominant linear feature in the field $\\boldsymbol{\\Phi}$ is estimated using the structure tensor. First, we compute the discrete gradients on the mesh grid, $\\partial_x \\phi \\equiv \\partial\\phi/\\partial x_g$ and $\\partial_y \\phi \\equiv \\partial\\phi/\\partial y_g$. Using periodic-centered differences, for a grid point at index $(i,j)$:\n$$\n(\\partial_x \\phi)_{ij} = \\frac{\\phi_{i,j+1} - \\phi_{i,j-1}}{2h}, \\quad (\\partial_y \\phi)_{ij} = \\frac{\\phi_{i+1,j} - \\phi_{i-1,j}}{2h}\n$$\nIndices are handled periodically (e.g., wrap-around using `numpy.roll`).\nThe structure tensor $\\boldsymbol{J}$ is the spatial average of the outer product of the gradients:\n$$\n\\boldsymbol{J} = \\left\\langle \\nabla \\phi (\\nabla \\phi)^T \\right\\rangle = \\begin{bmatrix}\n\\langle(\\partial_x \\phi)^2\\rangle  \\langle(\\partial_x \\phi)(\\partial_y \\phi)\\rangle\\\\\n\\langle(\\partial_x \\phi)(\\partial_y \\phi)\\rangle  \\langle(\\partial_y \\phi)^2\\rangle\n\\end{bmatrix}\n$$\nwhere $\\langle \\cdot \\rangle$ denotes the mean over all grid points.\nThe eigenvector of $\\boldsymbol{J}$ corresponding to its smallest eigenvalue points in the direction of least variation of the field, which is tangent to the shear band. We solve the eigenvalue problem $\\boldsymbol{J}\\boldsymbol{v} = \\lambda\\boldsymbol{v}$. The eigenvector $\\hat{\\boldsymbol{t}}$ associated with $\\lambda_{\\min}$ is the estimated tangent vector. The estimated orientation angle $\\hat{\\theta}$ is then calculated as:\n$$\n\\hat{\\theta} = \\mathrm{atan2}(\\hat{t}_y, \\hat{t}_x) \\pmod \\pi\n$$\nThe modulo $\\pi$ operation maps the angle to the interval $[0, \\pi)$, resolving the ambiguity that $\\hat{\\boldsymbol{t}}$ and $-\\hat{\\boldsymbol{t}}$ represent the same orientation.\n\n**Step 5: Error Quantification**\nThe mesh-induced orientation error is the shortest angular distance between the estimated angle $\\hat{\\theta}$ and the true angle $\\theta^\\star$ on a circle of circumference $\\pi$:\n$$\ne(\\alpha, l) = \\min(|\\hat{\\theta} - \\theta^\\star|, \\pi - |\\hat{\\theta} - \\theta^\\star|)\n$$\nThis procedure is repeated for each of the five test cases specified in the problem statement to determine the error as a function of mesh rotation $\\alpha$ and internal length $l$.", "answer": "```python\nimport numpy as np\n# The problem allows for scipy, but numpy's FFT capabilities are sufficient\n# and used here for computing the nonlocal average via convolution.\n\ndef solve():\n    \"\"\"\n    Solves the computational geomechanics problem of quantifying mesh-induced\n    orientation error for a shear band and the effect of nonlocal regularization.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    N = 256  # Grid size (dimensionless)\n    h = 0.01  # Grid spacing (meters)\n    L = N * h  # Domain side length (meters)\n    theta_star = np.pi / 6  # True band orientation (radians)\n    w = 0.02  # Band half-thickness parameter (meters)\n\n    # --- Test Cases ---\n    test_cases = [\n        # (alpha, l)\n        (0.0, 0.0),        # Test #1: Aligned grid, local model\n        (np.pi / 8, 0.0),  # Test #2: Rotated grid, local model\n        (np.pi / 4, 0.0),  # Test #3: Rotated grid (45 deg), local model\n        (np.pi / 8, 0.05), # Test #4: Rotated grid, nonlocal model\n        (np.pi / 4, 0.05)  # Test #5: Rotated grid (45 deg), nonlocal model\n    ]\n\n    results = []\n\n    # --- Grid Generation (unrotated mesh grid) ---\n    # Coordinates for cell centers\n    coord_1d = np.linspace(-L / 2 + h / 2, L / 2 - h / 2, N)\n    xg, yg = np.meshgrid(coord_1d, coord_1d)\n\n    # --- Pre-calculate constant vectors and matrices ---\n    n_star = np.array([-np.sin(theta_star), np.cos(theta_star)])\n\n    for alpha, l in test_cases:\n        # --- Step 1: Apply Grid Rotation ---\n        # Rotation matrix R(alpha)\n        cos_a, sin_a = np.cos(alpha), np.sin(alpha)\n        # Global coordinates (x, y) for sampling the continuous field\n        x = xg * cos_a - yg * sin_a\n        y = xg * sin_a + yg * cos_a\n\n        # --- Step 2: Construct the Local Field ---\n        # Project global coordinates onto the band normal\n        dist_from_band = x * n_star[0] + y * n_star[1]\n        gamma_p = np.exp(-(dist_from_band**2) / (2 * w**2))\n\n        # --- Step 3: Apply Nonlocal Regularization (if l  0) ---\n        if l == 0.0:\n            field_to_analyze = gamma_p\n        else:\n            # Using FFT for periodic convolution\n            # 1. Create the Gaussian kernel in real space\n            kernel = np.exp(-(xg**2 + yg**2) / l**2)\n            \n            # 2. Shift the kernel so its center (0,0) is at index (0,0) for FFT\n            kernel_shifted = np.fft.ifftshift(kernel)\n\n            # 3. Perform convolution in Fourier space\n            F_gamma_p = np.fft.fft2(gamma_p)\n            F_kernel = np.fft.fft2(kernel_shifted)\n            F_ones = np.fft.fft2(np.ones_like(gamma_p))\n\n            # 4. Numerator and Denominator of the nonlocal average formula\n            numerator_F = F_gamma_p * F_kernel\n            denominator_F = F_ones * F_kernel\n\n            # 5. Inverse FFT to get results in real space\n            numerator = np.fft.ifft2(numerator_F)\n            denominator = np.fft.ifft2(denominator_F)\n\n            # 6. Compute the nonlocal field (element-wise division)\n            # The results should be real; take np.real to discard negligible imag parts.\n            field_to_analyze = np.real(numerator) / np.real(denominator)\n\n        # --- Step 4: Compute Gradients and Structure Tensor ---\n        # Gradients on the mesh grid (xg, yg) using periodic-centered differences\n        grad_y = (np.roll(field_to_analyze, -1, axis=0) - np.roll(field_to_analyze, 1, axis=0)) / (2 * h)\n        grad_x = (np.roll(field_to_analyze, -1, axis=1) - np.roll(field_to_analyze, 1, axis=1)) / (2 * h)\n\n        # Spatially average to get components of the structure tensor J\n        J00 = np.mean(grad_x**2)\n        J11 = np.mean(grad_y**2)\n        J01 = np.mean(grad_x * grad_y)\n        J = np.array([[J00, J01], [J01, J11]])\n\n        # --- Step 5: Extract Estimated Orientation ---\n        # Eigen decomposition of the symmetric matrix J\n        eigenvalues, eigenvectors = np.linalg.eigh(J)\n        \n        # The tangent vector corresponds to the smallest eigenvalue\n        min_eig_idx = np.argmin(eigenvalues)\n        t_hat = eigenvectors[:, min_eig_idx]\n\n        # Estimated angle from the tangent vector\n        theta_hat_raw = np.arctan2(t_hat[1], t_hat[0])\n        \n        # Reduce to [0, pi) to account for orientation equivalence\n        theta_hat = np.mod(theta_hat_raw, np.pi)\n\n        # --- Step 6: Quantify Orientation Error ---\n        diff = np.abs(theta_hat - theta_star)\n        error = np.min([diff, np.pi - diff])\n        results.append(f\"{error:.6f}\")\n\n    # --- Final Output Formatting ---\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3503193"}]}