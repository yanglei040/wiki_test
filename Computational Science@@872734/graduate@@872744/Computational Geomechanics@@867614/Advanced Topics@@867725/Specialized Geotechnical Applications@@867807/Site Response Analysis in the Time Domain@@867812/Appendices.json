{"hands_on_practices": [{"introduction": "A cornerstone of any time-domain site response analysis is the constitutive model that describes how soil deforms and dissipates energy. While laboratory tests often provide these properties as a function of frequency (e.g., storage and loss moduli), time-domain simulations require a time-dependent representation. This practice guides you through the fundamental process of translating frequency-domain data into a time-domain linear viscoelastic model by calibrating a generalized Maxwell model (or Prony series), a technique essential for realistic simulations [@problem_id:3559337].", "problem": "You are tasked with constructing a generalized Maxwell representation (also called a Prony series) for linear viscoelastic soil behavior suitable for time-domain site response analysis. Starting from the principles of linear viscoelasticity, formulate and implement a program that calibrates the parameters of the relaxation modulus to match target dynamic properties measured in the frequency domain. The relaxation modulus is of the form $G(t) = G_{\\infty} + \\sum_{i=1}^{N} G_i e^{-t/\\tau_i}$, where $G_{\\infty}$ and $G_i$ are moduli in megapascals (MPa), and $\\tau_i$ are relaxation times in seconds (s). The targets are specified as complex shear modulus values as functions of frequency, from which the program must determine the nonnegative coefficients $G_{\\infty}$ and $\\{G_i\\}_{i=1}^{N}$ for a prescribed set of relaxation times $\\{\\tau_i\\}_{i=1}^{N}$. All frequencies are specified in hertz (Hz), so angular frequency is $\\omega = 2\\pi f$ with $f$ in Hz and $\\omega$ in radians per second.\n\nYour program must be designed from the following fundamental base:\n- The Boltzmann superposition principle for linear viscoelasticity: for shear stress $\\sigma(t)$ and shear strain $\\gamma(t)$, $\\sigma(t) = \\int_{0}^{t} G(t-s) \\, \\frac{d\\gamma(s)}{ds} \\, ds$.\n- For a harmonic strain $\\gamma(t) = \\gamma_0 e^{i \\omega t}$, the stress and strain are related via a complex shear modulus $G^*(\\omega)$ such that $\\sigma(t) = \\Re\\{G^*(\\omega)\\gamma_0 e^{i \\omega t}\\}$.\n- The complex shear modulus is connected to the relaxation modulus via the Fourier-Laplace relation, yielding for the generalized Maxwell model\n$$\nG^*(\\omega) = G_{\\infty} + \\sum_{i=1}^{N} G_i \\frac{i \\omega \\tau_i}{1 + i \\omega \\tau_i}.\n$$\n- The storage and loss moduli are $G'(\\omega) = \\Re\\{G^*(\\omega)\\}$ and $G''(\\omega) = \\Im\\{G^*(\\omega)\\}$, respectively. The coefficients appearing in the real and imaginary parts are\n$$\n\\Re\\left\\{\\frac{i \\omega \\tau_i}{1 + i \\omega \\tau_i}\\right\\} = \\frac{\\omega^2 \\tau_i^2}{1 + \\omega^2 \\tau_i^2}, \\quad\n\\Im\\left\\{\\frac{i \\omega \\tau_i}{1 + i \\omega \\tau_i}\\right\\} = \\frac{\\omega \\tau_i}{1 + \\omega^2 \\tau_i^2}.\n$$\n\nYour task is to implement a solver that, for a given set of frequencies $\\{f_k\\}_{k=1}^{M}$, targets $\\{G'_k\\}_{k=1}^{M}$ and $\\{G''_k\\}_{k=1}^{M}$ (with $G'_k$ and $G''_k$ in MPa), and prescribed relaxation times $\\{\\tau_i\\}_{i=1}^{N}$ (in s), computes the nonnegative parameters $G_{\\infty}$ and $\\{G_i\\}_{i=1}^{N}$ by minimizing the squared misfit across both storage and loss equations in a single linear, nonnegative least-squares problem. Specifically, formulate the overdetermined real system $A \\mathbf{x} \\approx \\mathbf{b}$ with unknown vector $\\mathbf{x} = [G_{\\infty}, G_1, \\dots, G_N]^{\\mathsf{T}}$ subject to $x_j \\ge 0$ for all components, where for each frequency $f_k$ with $\\omega_k = 2 \\pi f_k$:\n- The storage row is\n$$\n\\left[1, \\frac{\\omega_k^2 \\tau_1^2}{1 + \\omega_k^2 \\tau_1^2}, \\dots, \\frac{\\omega_k^2 \\tau_N^2}{1 + \\omega_k^2 \\tau_N^2}\\right] \\cdot \\mathbf{x} \\approx G'_k.\n$$\n- The loss row is\n$$\n\\left[0, \\frac{\\omega_k \\tau_1}{1 + \\omega_k^2 \\tau_1^2}, \\dots, \\frac{\\omega_k \\tau_N}{1 + \\omega_k^2 \\tau_N^2}\\right] \\cdot \\mathbf{x} \\approx G''_k.\n$$\n\nAfter solving for $\\mathbf{x}$, compute the modeled complex shear modulus at each frequency,\n$$\n\\widehat{G}^*_k = \\widehat{G}_{\\infty} + \\sum_{i=1}^{N} \\widehat{G}_i \\frac{i \\omega_k \\tau_i}{1 + i \\omega_k \\tau_i},\n$$\nand report the relative root-mean-square error across all frequencies,\n$$\n\\varepsilon = \\sqrt{\\frac{\\sum_{k=1}^{M} \\left| \\widehat{G}^*_k - G^*_k \\right|^2}{\\sum_{k=1}^{M} \\left| G^*_k \\right|^2}},\n$$\nwhere $G^*_k = G'_k + i G''_k$ and $\\left|\\cdot\\right|$ denotes the complex modulus.\n\nPhysical units to be used internally are megapascal for moduli (MPa), hertz for frequency (Hz), and seconds for time (s). The output error $\\varepsilon$ is nondimensional.\n\nImplement your program to solve the following test suite. In each test, the “lab-derived” targets are synthesized noise-free from known parameters; your solver must recover the parameters and compute the relative root-mean-square error $\\varepsilon$ for that test case.\n\n- Test $1$ (happy path, multiple separated relaxation times):\n    - Relaxation times: $\\tau = [\\,0.05,\\,0.5,\\,5.0\\,]$ s.\n    - True parameters: $G_{\\infty} = 80$ MPa, $G = [\\,20,\\,30,\\,50\\,]$ MPa.\n    - Frequencies: $f = [\\,0.1,\\,0.5,\\,1.0,\\,5.0,\\,10.0\\,]$ Hz.\n\n- Test $2$ (boundary case, purely elastic behavior):\n    - Relaxation times: $\\tau = [\\,0.1,\\,1.0,\\,10.0\\,]$ s.\n    - True parameters: $G_{\\infty} = 120$ MPa, $G = [\\,0,\\,0,\\,0\\,]$ MPa.\n    - Frequencies: $f = [\\,0.1,\\,1.0,\\,10.0\\,]$ Hz.\n\n- Test $3$ (edge case, closely spaced relaxation times):\n    - Relaxation times: $\\tau = [\\,0.5,\\,0.6,\\,5.0\\,]$ s.\n    - True parameters: $G_{\\infty} = 60$ MPa, $G = [\\,15,\\,10,\\,25\\,]$ MPa.\n    - Frequencies: $f = [\\,0.1,\\,0.2,\\,0.5,\\,1.0,\\,2.0,\\,5.0,\\,10.0,\\,20.0\\,]$ Hz.\n\nYour program should compute the relative root-mean-square error $\\varepsilon$ for each test case and produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of Tests $1$, $2$, and $3$. For example, the output format must be exactly like $[ \\varepsilon_1, \\varepsilon_2, \\varepsilon_3 ]$ but without spaces. The three entries must be floating-point numbers representing $\\varepsilon$ for each test, respectively.", "solution": "The problem is valid. It is scientifically grounded in the principles of linear viscoelasticity, is well-posed as a nonnegative least-squares parameter identification problem, and is specified with sufficient, consistent, and objective detail.\n\nThe task is to calibrate the parameters of a generalized Maxwell model for a linear viscoelastic material. The relaxation modulus, $G(t)$, is given by a Prony series:\n$$\nG(t) = G_{\\infty} + \\sum_{i=1}^{N} G_i e^{-t/\\tau_i}\n$$\nwhere $G_{\\infty}$ is the long-term or equilibrium shear modulus, $\\{G_i\\}_{i=1}^{N}$ are the strengths of the Maxwell elements, and $\\{\\tau_i\\}_{i=1}^{N}$ are the corresponding relaxation times. The parameters to be determined are $G_{\\infty}$ and $\\{G_i\\}_{i=1}^{N}$, which must be nonnegative to be physically meaningful. The relaxation times $\\{\\tau_i\\}_{i=1}^{N}$ are prescribed.\n\nFor time-harmonic loading, the relationship between shear stress $\\sigma(t)$ and shear strain $\\gamma(t)$ is described by the complex shear modulus, $G^*(\\omega)$. This is related to the relaxation modulus $G(t)$ via a Fourier-Laplace transform. For the given Prony series, the complex modulus is:\n$$\nG^*(\\omega) = G_{\\infty} + \\sum_{i=1}^{N} G_i \\frac{i \\omega \\tau_i}{1 + i \\omega \\tau_i}\n$$\nwhere $\\omega = 2 \\pi f$ is the angular frequency in radians per second, with $f$ being the frequency in hertz.\n\nThe complex modulus can be separated into its real and imaginary parts, known as the storage modulus $G'(\\omega)$ and the loss modulus $G''(\\omega)$, respectively:\n$$\nG^*(\\omega) = G'(\\omega) + i G''(\\omega)\n$$\nBy separating the real and imaginary components of the expression for $G^*(\\omega)$, we obtain:\n$$\nG'(\\omega) = \\Re\\{G^*(\\omega)\\} = G_{\\infty} + \\sum_{i=1}^{N} G_i \\frac{\\omega^2 \\tau_i^2}{1 + \\omega^2 \\tau_i^2}\n$$\n$$\nG''(\\omega) = \\Im\\{G^*(\\omega)\\} = \\sum_{i=1}^{N} G_i \\frac{\\omega \\tau_i}{1 + \\omega^2 \\tau_i^2}\n$$\nThe problem is to find the coefficients $\\mathbf{x} = [G_{\\infty}, G_1, \\dots, G_N]^{\\mathsf{T}}$ that best fit the target data $\\{G'_k\\}_{k=1}^{M}$ and $\\{G''_k\\}_{k=1}^{M}$ provided at a set of $M$ frequencies $\\{f_k\\}_{k=1}^{M}$. These equations are linear with respect to the unknown coefficients $\\mathbf{x}$. We can formulate this as a single overdetermined linear system $A \\mathbf{x} \\approx \\mathbf{b}$.\n\nFor each of the $M$ frequencies $f_k$ (with $\\omega_k = 2 \\pi f_k$), we have two linear equations, one for the storage modulus and one for the loss modulus. This results in a total of $2M$ equations for the $N+1$ unknowns. The system can be constructed by stacking these equations. The matrix $A$ will have dimensions $(2M) \\times (N+1)$ and the vector $\\mathbf{b}$ will have length $2M$.\n\nFor a given frequency $f_k$, the row of $A$ corresponding to the storage modulus $G'_k$ is:\n$$\nA_{k, \\cdot} = \\left[1, \\frac{\\omega_k^2 \\tau_1^2}{1 + \\omega_k^2 \\tau_1^2}, \\frac{\\omega_k^2 \\tau_2^2}{1 + \\omega_k^2 \\tau_2^2}, \\dots, \\frac{\\omega_k^2 \\tau_N^2}{1 + \\omega_k^2 \\tau_N^2}\\right]\n$$\nand the corresponding entry in $\\mathbf{b}$ is $b_k = G'_k$.\n\nThe row of $A$ corresponding to the loss modulus $G''_k$ (placed at index $M+k$) is:\n$$\nA_{M+k, \\cdot} = \\left[0, \\frac{\\omega_k \\tau_1}{1 + \\omega_k^2 \\tau_1^2}, \\frac{\\omega_k \\tau_2}{1 + \\omega_k^2 \\tau_2^2}, \\dots, \\frac{\\omega_k \\tau_N}{1 + \\omega_k^2 \\tau_N^2}\\right]\n$$\nand the corresponding entry in $\\mathbf{b}$ is $b_{M+k} = G''_k$.\n\nThe problem is solved by finding the vector $\\hat{\\mathbf{x}}$ that minimizes the squared Euclidean norm $\\| A \\mathbf{x} - \\mathbf{b} \\|_2^2$, subject to the constraint that all components of $\\mathbf{x}$ are nonnegative, i.e., $x_j \\ge 0$. This is a classical nonnegative least-squares (NNLS) problem.\n\nThe solution proceeds in the following steps for each test case:\n1.  **Synthesize Target Data:** Using the provided \"true\" parameters ($G_{\\infty}$, $\\{G_i\\}$) and relaxation times $\\{\\tau_i\\}$, generate the noise-free target complex moduli $G^*_k = G'_k + i G''_k$ at each specified frequency $f_k$.\n2.  **Construct Linear System:** Build the matrix $A$ and vector $\\mathbf{b}$ as described above, using the synthesized $G'_k$ and $G''_k$ as targets.\n3.  **Solve with NNLS:** Employ a standard NNLS solver, such as `scipy.optimize.nnls`, to find the estimated parameter vector $\\hat{\\mathbf{x}} = [\\widehat{G}_{\\infty}, \\widehat{G}_1, \\dots, \\widehat{G}_N]^{\\mathsf{T}}$.\n4.  **Evaluate Model Fit:** Using the calibrated parameters $\\hat{\\mathbf{x}}$, calculate the modeled complex modulus $\\widehat{G}^*_k$ at each frequency.\n5.  **Compute Error:** Calculate the relative root-mean-square error $\\varepsilon$ between the modeled values $\\widehat{G}^*_k$ and the original target values $G^*_k$ using the formula:\n$$\n\\varepsilon = \\sqrt{\\frac{\\sum_{k=1}^{M} \\left| \\widehat{G}^*_k - G^*_k \\right|^2}{\\sum_{k=1}^{M} \\left| G^*_k \\right|^2}}\n$$\nSince the target data is generated from a model of the same form being fitted, and is noise-free, the expected error $\\varepsilon$ should be very close to zero, reflecting only the limits of numerical precision. This serves as a verification of the algorithm's implementation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import nnls\n\ndef solve():\n    \"\"\"\n    Calibrates a generalized Maxwell model to target complex shear modulus data\n    and computes the relative root-mean-square error for several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"tau\": np.array([0.05, 0.5, 5.0]),  # s\n            \"G_inf_true\": 80.0,  # MPa\n            \"G_true\": np.array([20.0, 30.0, 50.0]),  # MPa\n            \"f\": np.array([0.1, 0.5, 1.0, 5.0, 10.0]),  # Hz\n        },\n        {\n            \"tau\": np.array([0.1, 1.0, 10.0]),  # s\n            \"G_inf_true\": 120.0,  # MPa\n            \"G_true\": np.array([0.0, 0.0, 0.0]),  # MPa\n            \"f\": np.array([0.1, 1.0, 10.0]),  # Hz\n        },\n        {\n            \"tau\": np.array([0.5, 0.6, 5.0]),  # s\n            \"G_inf_true\": 60.0,  # MPa\n            \"G_true\": np.array([15.0, 10.0, 25.0]),  # MPa\n            \"f\": np.array([0.1, 0.2, 0.5, 1.0, 2.0, 5.0, 10.0, 20.0]),  # Hz\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        tau = case[\"tau\"]\n        G_inf_true = case[\"G_inf_true\"]\n        G_true = case[\"G_true\"]\n        f = case[\"f\"]\n        \n        N = len(tau)\n        M = len(f)\n        omega = 2.0 * np.pi * f\n\n        # Step 1: Synthesize target data (_k denotes per-frequency)\n        G_star_k_target = np.zeros(M, dtype=complex)\n        for k in range(M):\n            w_k = omega[k]\n            # iωτ / (1 + iωτ)\n            complex_term = (1j * w_k * tau) / (1 + 1j * w_k * tau)\n            G_star_k_target[k] = G_inf_true + np.sum(G_true * complex_term)\n        \n        G_prime_k_target = G_star_k_target.real\n        G_double_prime_k_target = G_star_k_target.imag\n\n        # Step 2: Construct the linear system A*x = b for NNLS\n        A = np.zeros((2 * M, N + 1))\n        b = np.zeros(2 * M)\n\n        for k in range(M):\n            w_k = omega[k]\n            w_tau = w_k * tau\n            w_tau_sq = w_tau**2\n            \n            # Storage modulus row (G')\n            A[k, 0] = 1.0\n            A[k, 1:] = w_tau_sq / (1.0 + w_tau_sq)\n            b[k] = G_prime_k_target[k]\n\n            # Loss modulus row (G'')\n            A[M + k, 0] = 0.0\n            A[M + k, 1:] = w_tau / (1.0 + w_tau_sq)\n            b[M + k] = G_double_prime_k_target[k]\n\n        # Step 3: Solve the NNLS problem\n        x_hat, _ = nnls(A, b)\n        \n        G_inf_hat = x_hat[0]\n        G_hat = x_hat[1:]\n\n        # Step 4: Evaluate the model fit and compute modeled G*\n        G_star_k_model = np.zeros(M, dtype=complex)\n        for k in range(M):\n            w_k = omega[k]\n            complex_term = (1j * w_k * tau) / (1 + 1j * w_k * tau)\n            G_star_k_model[k] = G_inf_hat + np.sum(G_hat * complex_term)\n\n        # Step 5: Compute the relative root-mean-square error\n        numerator = np.sum(np.abs(G_star_k_model - G_star_k_target)**2)\n        denominator = np.sum(np.abs(G_star_k_target)**2)\n        \n        epsilon = 0.0\n        if denominator > 0:\n            epsilon = np.sqrt(numerator / denominator)\n        \n        results.append(epsilon)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3559337"}, {"introduction": "The quality of a site response analysis is heavily dependent on the quality of the input ground motion. Raw accelerometer records often contain low-frequency instrument drift, a non-physical artifact that can lead to unrealistic, unbounded displacements in a simulation. This exercise demonstrates the critical pre-processing step of designing a digital high-pass filter to remove this drift, forcing you to balance the need for cleaning the signal with the imperative to preserve the long-period ground motion components that are crucial for accurately capturing the response of soft soil sites [@problem_id:3559408].", "problem": "You are tasked with designing a digital high-pass filter for preprocessing acceleration time histories in site response analysis in the time domain. The goal is to remove instrument drift without attenuating long-period components that are critical to soft sites. The design must be justified by ensuring that the chosen cutoff frequency preserves the site’s fundamental mode.\n\nStart from first principles consistent with the one-dimensional vertically propagating shear wave model. In a vertically heterogeneous soil column of total thickness $H$, composed of $N$ horizontal layers with thicknesses $h_i$ and shear-wave velocities $V_{s,i}$ for $i \\in \\{1,\\dots,N\\}$, the travel-time-averaged shear-wave velocity is\n$$\nV_{s,\\mathrm{avg}} = \\frac{H}{\\sum_{i=1}^{N} \\frac{h_i}{V_{s,i}}}.\n$$\nUsing the quarter-wavelength approximation for the fundamental mode of vertical shear-wave resonance, the site’s fundamental frequency is\n$$\nf_0 = \\frac{V_{s,\\mathrm{avg}}}{4 H}.\n$$\nYou must design a digital Infinite Impulse Response (IIR) Butterworth high-pass filter of order $n$ and sampling frequency $f_s$ with cutoff frequency $f_c$ (in $\\mathrm{Hz}$). Let the filter’s discrete-time frequency response be $H(\\mathrm{e}^{\\mathrm{j}\\omega})$ with $\\omega = 2\\pi f/f_s$. Your design must satisfy the following constraints at two specific frequencies:\n- Passband preservation: the magnitude at the site’s fundamental frequency must satisfy\n$$\n\\left|H\\left(\\mathrm{e}^{\\mathrm{j} 2\\pi f_0 / f_s}\\right)\\right| \\ge A_{\\mathrm{pass}},\n$$\n- Stopband drift removal: the magnitude at the drift frequency $f_d$ must satisfy\n$$\n\\left|H\\left(\\mathrm{e}^{\\mathrm{j} 2\\pi f_d / f_s}\\right)\\right| \\le A_{\\mathrm{stop}}.\n$$\nTo prioritize preservation of long-period site response, choose $f_c$ as the largest cutoff frequency that still satisfies the passband preservation constraint at $f_0$. Then evaluate whether the drift removal constraint at $f_d$ is satisfied by this chosen $f_c$. If the drift removal constraint is not satisfied, declare the design infeasible for that case but still report the chosen $f_c$ that protects the site’s fundamental mode.\n\nYour program must:\n- Compute $f_0$ from the layered profile using the travel-time average.\n- Design a Butterworth high-pass filter of order $n$ and sampling frequency $f_s$.\n- Determine the maximal $f_c$ that satisfies the passband preservation threshold $A_{\\mathrm{pass}}$ at $f_0$.\n- Compute the magnitudes $\\left|H\\left(\\mathrm{e}^{\\mathrm{j} 2\\pi f_0 / f_s}\\right)\\right|$ and $\\left|H\\left(\\mathrm{e}^{\\mathrm{j} 2\\pi f_d / f_s}\\right)\\right|$ for the chosen $f_c$.\n- Report, for each test case, the tuple $[f_c, \\mathrm{feasible}, A_{f_0}, A_{f_d}]$, where $f_c$ is in $\\mathrm{Hz}$, $\\mathrm{feasible}$ is $1$ if the drift removal constraint is satisfied and $0$ otherwise, $A_{f_0} = \\left|H\\left(\\mathrm{e}^{\\mathrm{j} 2\\pi f_0 / f_s}\\right)\\right|$, and $A_{f_d} = \\left|H\\left(\\mathrm{e}^{\\mathrm{j} 2\\pi f_d / f_s}\\right)\\right|$.\n\nAll final numerical outputs must be expressed in the specified units: frequency in $\\mathrm{Hz}$, rounded to three decimals. The magnitudes $A_{f_0}$ and $A_{f_d}$ must be rounded to three decimals. The feasibility indicator must be an integer in $\\{0,1\\}$.\n\nUse the following global thresholds across all cases:\n- $A_{\\mathrm{pass}} = 0.95$,\n- $A_{\\mathrm{stop}} = 0.10$.\n\nTest suite. Your program must run the following three test cases, compute the fundamental frequency $f_0$, design the filter as described, and then produce the required outputs:\n- Case $1$ (soft site, two layers):\n  - Layers: $(h_1, V_{s,1}) = (30 \\ \\mathrm{m}, 150 \\ \\mathrm{m/s})$, $(h_2, V_{s,2}) = (20 \\ \\mathrm{m}, 250 \\ \\mathrm{m/s})$.\n  - Sampling frequency: $f_s = 100 \\ \\mathrm{Hz}$.\n  - Butterworth order: $n = 4$.\n  - Drift frequency: $f_d = 0.02 \\ \\mathrm{Hz}$.\n- Case $2$ (soft site, single layer):\n  - Layers: $(h_1, V_{s,1}) = (80 \\ \\mathrm{m}, 160 \\ \\mathrm{m/s})$.\n  - Sampling frequency: $f_s = 50 \\ \\mathrm{Hz}$.\n  - Butterworth order: $n = 2$.\n  - Drift frequency: $f_d = 0.05 \\ \\mathrm{Hz}$.\n- Case $3$ (very soft site near drift band, two layers):\n  - Layers: $(h_1, V_{s,1}) = (70 \\ \\mathrm{m}, 120 \\ \\mathrm{m/s})$, $(h_2, V_{s,2}) = (30 \\ \\mathrm{m}, 180 \\ \\mathrm{m/s})$.\n  - Sampling frequency: $f_s = 40 \\ \\mathrm{Hz}$.\n  - Butterworth order: $n = 4$.\n  - Drift frequency: $f_d = 0.20 \\ \\mathrm{Hz}$.\n\nFinal output format. Your program should produce a single line of output containing a list of the results for the three cases, with each case reported as a list in the order $[f_c,\\mathrm{feasible},A_{f_0},A_{f_d}]$. The outer list must contain the three inner lists in the order of the cases above. The line must be printed as a comma-separated list enclosed in square brackets, for example:\n\"[ [f_c^{(1)},\\mathrm{feasible}^{(1)},A_{f_0}^{(1)},A_{f_d}^{(1)} ], [f_c^{(2)},\\mathrm{feasible}^{(2)},A_{f_0}^{(2)},A_{f_d}^{(2)}], [f_c^{(3)},\\mathrm{feasible}^{(3)},A_{f_0}^{(3)},A_{f_d}^{(3)}] ]\"\nwith each $f_c$ in $\\mathrm{Hz}$ rounded to three decimals, each $A_{f_0}$ and $A_{f_d}$ rounded to three decimals, and each feasibility indicator as an integer $0$ or $1$.", "solution": "The problem is subjected to validation before proceeding to a solution.\n\n### Step 1: Extract Givens\n- **Model**: One-dimensional vertically propagating shear wave model in a soil column of total thickness $H$, composed of $N$ layers with thickness $h_i$ and shear-wave velocity $V_{s,i}$.\n- **Travel-time-averaged shear-wave velocity**: $V_{s,\\mathrm{avg}} = \\frac{H}{\\sum_{i=1}^{N} \\frac{h_i}{V_{s,i}}}$.\n- **Site fundamental frequency**: $f_0 = \\frac{V_{s,\\mathrm{avg}}}{4 H}$, using the quarter-wavelength approximation.\n- **Filter**: Digital Infinite Impulse Response (IIR) Butterworth high-pass filter of order $n$.\n- **Filter parameters**: Sampling frequency $f_s$, cutoff frequency $f_c$.\n- **Filter constraints**:\n  - Passband preservation: $\\left|H\\left(\\mathrm{e}^{\\mathrm{j} 2\\pi f_0 / f_s}\\right)\\right| \\ge A_{\\mathrm{pass}}$.\n  - Stopband drift removal: $\\left|H\\left(\\mathrm{e}^{\\mathrm{j} 2\\pi f_d / f_s}\\right)\\right| \\le A_{\\mathrm{stop}}$.\n- **Design Objective**: Choose $f_c$ as the largest value that satisfies the passband preservation constraint. Then, check if this $f_c$ satisfies the stopband drift removal constraint.\n- **Global Thresholds**: $A_{\\mathrm{pass}} = 0.95$, $A_{\\mathrm{stop}} = 0.10$.\n- **Output vector**: For each case, report $[f_c, \\mathrm{feasible}, A_{f_0}, A_{f_d}]$, where $\\mathrm{feasible}$ is $1$ if the stopband constraint is met, $0$ otherwise. $A_{f_0}$ and $A_{f_d}$ are the filter magnitudes at $f_0$ and $f_d$ respectively. Numerical values are to be rounded to three decimals.\n- **Test Cases**:\n  - **Case 1**: Layers: $(h_1, V_{s,1}) = (30 \\ \\mathrm{m}, 150 \\ \\mathrm{m/s})$, $(h_2, V_{s,2}) = (20 \\ \\mathrm{m}, 250 \\ \\mathrm{m/s})$. $f_s = 100 \\ \\mathrm{Hz}$, $n = 4$, $f_d = 0.02 \\ \\mathrm{Hz}$.\n  - **Case 2**: Layers: $(h_1, V_{s,1}) = (80 \\ \\mathrm{m}, 160 \\ \\mathrm{m/s})$. $f_s = 50 \\ \\mathrm{Hz}$, $n = 2$, $f_d = 0.05 \\ \\mathrm{Hz}$.\n  - **Case 3**: Layers: $(h_1, V_{s,1}) = (70 \\ \\mathrm{m}, 120 \\ \\mathrm{m/s})$, $(h_2, V_{s,2}) = (30 \\ \\mathrm{m}, 180 \\ \\mathrm{m/s})$. $f_s = 40 \\ \\mathrm{Hz}$, $n = 4$, $f_d = 0.20 \\ \\mathrm{Hz}$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is evaluated against the validation criteria:\n- **Scientifically Grounded**: The problem is based on standard, established principles in earthquake engineering and digital signal processing. The formulas for $V_{s,\\mathrm{avg}}$, $f_0$, and the Butterworth filter are correct and widely used.\n- **Well-Posed**: The problem is clearly defined. The objective to maximize $f_c$ subject to a constraint, followed by a check of another constraint, is an unambiguous mathematical procedure. As will be shown, the monotonic nature of the filter's gain with respect to $f_c$ ensures a unique solution exists.\n- **Objective**: The problem is stated with precise, quantitative parameters and requirements, free from subjective language.\n- **Completeness**: All necessary information (layer properties, filter specifications, evaluation criteria) is provided for each test case.\n- **Consistency**: There are no internal contradictions in the problem statement.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. It is self-contained, scientifically sound, and well-posed. A complete solution will be provided.\n\n---\n\n### Solution Derivation\nThe solution involves four main steps: calculating the site's fundamental frequency, deriving an expression for the filter cutoff frequency, evaluating the filter's performance, and applying this process to the specified test cases.\n\n**Step A: Site Fundamental Frequency ($f_0$)**\nThe fundamental frequency $f_0$ of the soil profile is given by the quarter-wavelength approximation:\n$$ f_0 = \\frac{V_{s,\\mathrm{avg}}}{4 H} $$\nwhere $H = \\sum_{i=1}^{N} h_i$ is the total thickness and $V_{s,\\mathrm{avg}}$ is the travel-time-averaged shear-wave velocity. Substituting the definition of $V_{s,\\mathrm{avg}}$:\n$$ f_0 = \\frac{1}{4 H} \\left( \\frac{H}{\\sum_{i=1}^{N} \\frac{h_i}{V_{s,i}}} \\right) = \\frac{1}{4 \\sum_{i=1}^{N} \\frac{h_i}{V_{s,i}}} $$\nThis expression allows for the direct computation of $f_0$ from the layer properties. The term $\\sum (h_i / V_{s,i})$ represents the total one-way travel time of a shear wave from the base to the surface.\n\n**Step B: Digital Butterworth High-Pass Filter Response**\nThe magnitude-squared response of an $n$-th order analog high-pass Butterworth filter is given by:\n$$ |H_{HP}(j\\Omega)|^2 = \\frac{(\\Omega/\\Omega_c)^{2n}}{1 + (\\Omega/\\Omega_c)^{2n}} $$\nwhere $\\Omega$ is the analog frequency and $\\Omega_c$ is the analog cutoff frequency. To obtain the response of the corresponding digital filter, we use the bilinear transform, which maps the analog frequency domain to the digital frequency domain. Frequencies are warped according to the relation $\\Omega = \\tan(\\omega/2)$, assuming a sampling period-normalized mapping constant. Here, $\\omega = 2\\pi f / f_s$ is the normalized digital frequency, with $f$ being the frequency in $\\mathrm{Hz}$ and $f_s$ the sampling frequency.\n\nThe magnitude-squared response of the digital high-pass filter at a frequency $f$ is therefore:\n$$ \\left|H\\left(\\mathrm{e}^{\\mathrm{j} 2\\pi f / f_s}\\right)\\right|^2 = \\frac{\\left(\\frac{\\tan(\\pi f / f_s)}{\\tan(\\pi f_c / f_s)}\\right)^{2n}}{1 + \\left(\\frac{\\tan(\\pi f / f_s)}{\\tan(\\pi f_c / f_s)}\\right)^{2n}} $$\nwhere $f_c$ is the digital cutoff frequency.\n\n**Step C: Determination of Maximum Cutoff Frequency ($f_c$)**\nThe design problem requires finding the largest cutoff frequency $f_c$ that satisfies the passband preservation constraint:\n$$ \\left|H\\left(\\mathrm{e}^{\\mathrm{j} 2\\pi f_0 / f_s}\\right)\\right| \\ge A_{\\mathrm{pass}} $$\nLet us analyze the dependence of the filter's magnitude at a fixed frequency $f=f_0$ on the cutoff frequency $f_c$. As $f_c$ increases, $\\tan(\\pi f_c/f_s)$ increases. This causes the ratio $\\frac{\\tan(\\pi f_0/f_s)}{\\tan(\\pi f_c/f_s)}$ to decrease. Since the function $g(x) = \\sqrt{x^{2n}/(1+x^{2n})}$ is monotonically increasing for $x0$, the magnitude $\\left|H\\left(\\mathrm{e}^{\\mathrm{j} 2\\pi f_0 / f_s}\\right)\\right|$ is a monotonically *decreasing* function of $f_c$.\n\nTo find the maximum permissible $f_c$, we set the magnitude at $f_0$ to be exactly the minimum allowed value, $A_{\\mathrm{pass}}$:\n$$ \\left|H\\left(\\mathrm{e}^{\\mathrm{j} 2\\pi f_0 / f_s}\\right)\\right| = A_{\\mathrm{pass}} $$\nSquaring both sides and substituting into the response formula gives:\n$$ A_{\\mathrm{pass}}^2 = \\frac{\\left(\\frac{\\tan(\\pi f_0 / f_s)}{\\tan(\\pi f_c / f_s)}\\right)^{2n}}{1 + \\left(\\frac{\\tan(\\pi f_0 / f_s)}{\\tan(\\pi f_c / f_s)}\\right)^{2n}} $$\nLet $X = \\left(\\frac{\\tan(\\pi f_0 / f_s)}{\\tan(\\pi f_c / f_s)}\\right)^{2n}$. Solving for $X$ yields $X = \\frac{A_{\\mathrm{pass}}^2}{1 - A_{\\mathrm{pass}}^2}$. Substituting back and solving for $\\tan(\\pi f_c/f_s)$:\n$$ \\frac{\\tan(\\pi f_0 / f_s)}{\\tan(\\pi f_c / f_s)} = \\left(\\frac{A_{\\mathrm{pass}}^2}{1 - A_{\\mathrm{pass}}^2}\\right)^{\\frac{1}{2n}} $$\n$$ \\tan\\left(\\frac{\\pi f_c}{f_s}\\right) = \\tan\\left(\\frac{\\pi f_0}{f_s}\\right) \\left(\\frac{1 - A_{\\mathrm{pass}}^2}{A_{\\mathrm{pass}}^2}\\right)^{\\frac{1}{2n}} $$\nFinally, we can solve for $f_c$:\n$$ f_c = \\frac{f_s}{\\pi} \\arctan\\left[ \\tan\\left(\\frac{\\pi f_0}{f_s}\\right) \\left(\\frac{1 - A_{\\mathrm{pass}}^2}{A_{\\mathrm{pass}}^2}\\right)^{\\frac{1}{2n}} \\right] $$\nThis expression yields the maximum cutoff frequency that preserves the signal at $f_0$ with a magnitude of at least $A_{\\mathrm{pass}}$.\n\n**Step D: Feasibility Assessment**\nWith the uniquely determined $f_c$, the magnitude response at the site's fundamental frequency is, by design, $A_{f_0} = A_{\\mathrm{pass}}$. We must now evaluate the stopband constraint at the drift frequency, $f_d$:\n$$ A_{f_d} = \\left|H\\left(\\mathrm{e}^{\\mathrm{j} 2\\pi f_d / f_s}\\right)\\right| = \\sqrt{\\frac{\\left(\\frac{\\tan(\\pi f_d / f_s)}{\\tan(\\pi f_c / f_s)}\\right)^{2n}}{1 + \\left(\\frac{\\tan(\\pi f_d / f_s)}{\\tan(\\pi f_c / f_s)}\\right)^{2n}}} $$\nThe design is deemed feasible if $A_{f_d} \\le A_{\\mathrm{stop}}$. The feasibility indicator is set to $1$ if this condition holds, and $0$ otherwise. The required output for each case is the tuple $[f_c, \\mathrm{feasible}, A_{f_0}, A_{f_d}]$. Note that due to floating-point arithmetic, the calculated $A_{f_0}$ will be extremely close to, but not necessarily exactly, $A_{\\mathrm{pass}}$. For reporting, we can assign it the design value of $A_{\\mathrm{pass}}$.\n\nThis completes the theoretical framework for solving the problem. The procedure is now applied to the three test cases.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the digital filter design problem for site response analysis.\n    \"\"\"\n    \n    # Global filter design thresholds\n    A_pass = 0.95\n    A_stop = 0.10\n\n    # Test cases from the problem statement\n    # Each case is a tuple: (layers, fs, n, fd)\n    # layers is a list of tuples (h_i, Vs_i)\n    test_cases = [\n        # Case 1\n        ([ (30, 150), (20, 250) ], 100, 4, 0.02),\n        # Case 2\n        ([ (80, 160) ], 50, 2, 0.05),\n        # Case 3\n        ([ (70, 120), (30, 180) ], 40, 4, 0.20),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        layers, fs, n, fd = case\n        \n        # Step A: Compute Site Fundamental Frequency (f0)\n        # f0 = 1 / (4 * sum(h_i / Vs_i))\n        travel_time_sum = sum(h / vs for h, vs in layers)\n        f0 = 1.0 / (4.0 * travel_time_sum)\n\n        # Step C: Determine the Maximum Cutoff Frequency (fc)\n        # This is derived from setting the gain at f0 to exactly A_pass.\n        # tan(pi*fc/fs) = tan(pi*f0/fs) * ( (1 - A_pass^2) / A_pass^2 )^(1/(2n))\n        \n        # The equation can be rearranged to avoid division by a small number in some contexts\n        # tan(pi*fc/fs) = tan(pi*f0/fs) / ( (A_pass^2) / (1 - A_pass^2) )^(1/(2n))\n        \n        term_A = (A_pass**2) / (1 - A_pass**2)\n        C = np.power(term_A, 1.0 / (2.0 * n))\n        \n        tan_f0 = np.tan(np.pi * f0 / fs)\n        tan_fc = tan_f0 / C\n        \n        fc = (fs / np.pi) * np.arctan(tan_fc)\n\n        # By design, the magnitude at f0 is A_pass\n        A_f0 = A_pass\n\n        # Step D: Feasibility Assessment\n        # Calculate the filter magnitude at the drift frequency fd\n        # |H|^2 = ratio^(2n) / (1 + ratio^(2n)), where ratio = tan(pi*fd/fs) / tan(pi*fc/fs)\n        \n        tan_fd = np.tan(np.pi * fd / fs)\n        \n        # Using the tan_fc value calculated earlier\n        ratio_fd = tan_fd / tan_fc\n        \n        ratio_fd_pow_2n = np.power(ratio_fd, 2.0 * n)\n        \n        A_fd_sq = ratio_fd_pow_2n / (1.0 + ratio_fd_pow_2n)\n        A_fd = np.sqrt(A_fd_sq)\n\n        # Check if the drift removal constraint is satisfied\n        feasible = 1 if A_fd = A_stop else 0\n\n        # Store the results with required rounding\n        results.append([\n            round(fc, 3),\n            feasible,\n            round(A_f0, 3),\n            round(A_fd, 3)\n        ])\n    \n    # Format the final output string as a list of lists\n    # e.g., \"[[fc1, feas1, A_f0_1, A_fd_1], [fc2, ...]]\"\n    result_strings = []\n    for res in results:\n        # Format numbers to ensure 3 decimal places are shown\n        f_c_str = f\"{res[0]:.3f}\"\n        a_f0_str = f\"{res[2]:.3f}\"\n        a_fd_str = f\"{res[3]:.3f}\"\n        result_strings.append(f\"[{f_c_str}, {res[1]}, {a_f0_str}, {a_fd_str}]\")\n\n    final_output = f\"[{', '.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3559408"}, {"introduction": "At the heart of time-domain analysis is the numerical solution of the wave equation. This practice takes you into the core of a site response simulation engine, tasking you with implementing an explicit Finite Difference Method (FDM) solver. You will confront a classic challenge in computational mechanics: the spurious Gibbs oscillations that arise when simulating the propagation of sharp wave fronts. By calibrating an artificial viscosity parameter, you will learn how to implement a \"shock capturing\" scheme that ensures a stable and physically meaningful solution, a vital skill for developing robust numerical models [@problem_id:3559403].", "problem": "You are asked to implement a complete and runnable program that calibrates an artificial viscosity parameter for shock capturing in explicit Finite Difference Method (FDM) site response analysis in the time domain. The program must simulate one-dimensional vertical shear-wave propagation through a uniform soil column using the conservation of linear momentum and a Kelvin–Voigt-like artificial viscosity model, then select the smallest amount of artificial viscosity that minimizes Gibbs oscillations while respecting a bound on peak shear strain attenuation.\n\nStart from the following fundamental base:\n- Conservation of linear momentum for antiplane shear in one spatial dimension: $\\rho \\, \\partial^2 u / \\partial t^2 = \\partial \\tau / \\partial z$, where $u(z,t)$ is the horizontal displacement, $\\rho$ is the mass density, $z$ is the vertical coordinate, $t$ is time, and $\\tau$ is the shear stress.\n- Linear elastic constitutive relationship with an artificial viscosity term of the Kelvin–Voigt type: $\\tau = G \\, \\partial u / \\partial z + \\mu_a \\, \\partial (\\partial u / \\partial z) / \\partial t$, where $G$ is the shear modulus and $\\mu_a$ is the artificial viscosity coefficient to be calibrated.\n- Kinematic definitions: $\\gamma = \\partial u / \\partial z$ is the engineering shear strain, and $v = \\partial u / \\partial t$ is the particle velocity.\n\nSimulate a vertically propagating shear wave in a soil layer of thickness $H$ with a stress-free surface at $z=0$ and a prescribed horizontal base motion at $z=H$. Use a uniform spatial mesh of spacing $\\Delta z$ and an explicit central-difference time integration scheme with time step $\\Delta t$ that satisfies a physically justified stability constraint. The wave speed is $c = \\sqrt{G/\\rho}$. The top boundary condition is zero shear traction $\\tau(z=0,t)=0$. The base boundary at $z=H$ is a prescribed displacement $u_\\text{base}(t)$ obtained by integrating a specified trapezoidal base velocity $v_\\text{base}(t)$.\n\nBase velocity time history:\n- Magnitude $V_0 = 0.5 \\, \\mathrm{m/s}$.\n- Start time $t_0 = 0.05 \\, \\mathrm{s}$.\n- Linear rise time $t_r$ (varies per test case).\n- Hold time $T_\\mathrm{hold} = 0.1 \\, \\mathrm{s}$.\n- Linear fall time of duration $t_r$.\n\nLet the material and geometric parameters be:\n- $\\rho = 1800 \\, \\mathrm{kg/m^3}$,\n- $G = 80 \\times 10^6 \\, \\mathrm{Pa}$,\n- $H = 30 \\, \\mathrm{m}$,\n- total simulation time $T_\\mathrm{end} = 1.2 \\, \\mathrm{s}$.\n\nDefine a quantitative oscillation metric for the free-surface shear strain $\\gamma(t)$:\n- Let $\\gamma_\\max = \\max_t |\\gamma(t)|$ and let $t^\\star$ be the time at which this maximum is first attained.\n- Define the post-peak oscillation index $O = \\max_{t  t^\\star} |\\gamma(t)| / \\gamma_\\max$, with the convention $O=0$ if the set $\\{tt^\\star\\}$ is empty.\n\nDefine the admissibility constraint for the artificial viscosity $\\mu_a$ by comparing against a baseline simulation with $\\mu_a = 0$:\n- Let $\\gamma_\\max^{(0)}$ denote the baseline peak.\n- Given a target attenuation fraction $\\delta \\in [0,1)$, a candidate $\\mu_a$ is admissible if $\\max_t |\\gamma_{\\mu_a}(t)| \\ge (1 - \\delta) \\, \\gamma_\\max^{(0)}$.\n\nCalibration objective:\n- Among a finite set of candidates $\\{\\mu_a^{(k)}\\}$ uniformly spanning the interval $[0, \\mu_\\text{max}]$ with $\\mu_\\text{max} = 3 \\times 10^5 \\, \\mathrm{Pa \\cdot s}$ and $25$ samples (inclusive), select the $\\mu_a$ that minimizes $O$ subject to the admissibility constraint above. In case of ties in $O$, select the smallest $\\mu_a$.\n\nNumerical discretization requirements:\n- Use explicit central differences in time for $u_{tt}$ and second-order central differences in space for $u_{zz}$ and $v_{zz}$.\n- Enforce the free-surface boundary condition by a zero-gradient (mirror) condition that enforces $\\tau(z=0,t)=0$ consistently.\n- Enforce the base boundary condition by directly prescribing $u(z=H,t) = u_\\text{base}(t)$, where $u_\\text{base}(t)$ is the time integral of $v_\\text{base}(t)$ obtained by the trapezoidal rule over the discrete time grid.\n- Ensure stability by enforcing a time step $\\Delta t$ that respects both wave-propagation and viscous constraints derived from dimensional analysis of the discrete scheme. Explain your choice and derivation in the solution. All times must be expressed in seconds; all distances in meters; stiffness in pascals; density in $\\mathrm{kg/m^3}$; viscosity in $\\mathrm{Pa \\cdot s}$.\n\nCalibration and testing protocol:\n- For each test case below, compute the baseline $\\gamma_\\max^{(0)}$ with $\\mu_a=0$, then evaluate the $25$ candidates in $[0, \\mu_\\text{max}]$ and select the calibrated $\\mu_a$ using the rule above.\n- Report the calibrated $\\mu_a$ values in $\\mathrm{Pa \\cdot s}$, rounded to the nearest $1000 \\, \\mathrm{Pa \\cdot s}$.\n\nTest suite:\n- Case A: $\\delta = 0.15$, $\\Delta z = 0.5 \\, \\mathrm{m}$, $t_r = 0.01 \\, \\mathrm{s}$.\n- Case B: $\\delta = 0.05$, $\\Delta z = 0.5 \\, \\mathrm{m}$, $t_r = 0.005 \\, \\mathrm{s}$.\n- Case C: $\\delta = 0.30$, $\\Delta z = 0.5 \\, \\mathrm{m}$, $t_r = 0.005 \\, \\mathrm{s}$.\n- Case D: $\\delta = 0.15$, $\\Delta z = 1.0 \\, \\mathrm{m}$, $t_r = 0.005 \\, \\mathrm{s}$.\n\nYour program should produce a single line of output containing the calibrated viscosities as a comma-separated list enclosed in square brackets. Express each calibrated $\\mu_a$ in $\\mathrm{Pa \\cdot s}$, rounded to the nearest $1000 \\, \\mathrm{Pa \\cdot s}$. For example, the format must be exactly like $[\\mu_{A},\\mu_{B},\\mu_{C},\\mu_{D}]$ with no extra spaces or text, where each $\\mu_{\\bullet}$ is a number in $\\mathrm{Pa \\cdot s}$ rounded as specified.", "solution": "The user requests the implementation and execution of a program to calibrate an artificial viscosity parameter for a one-dimensional shear wave propagation simulation. The process involves validating the problem statement, deriving the numerical method, and implementing the calibration algorithm according to specified criteria.\n\n### Problem Validation\n\n**Step 1: Extracted Givens**\n- **Governing Equations**:\n  - Momentum Conservation: $\\rho \\, \\partial^2 u / \\partial t^2 = \\partial \\tau / \\partial z$\n  - Constitutive Law (Kelvin-Voigt): $\\tau = G \\, \\partial u / \\partial z + \\mu_a \\, \\partial (\\partial u / \\partial z) / \\partial t$\n- **Definitions**: $\\gamma = \\partial u / \\partial z$ (shear strain), $v = \\partial u / \\partial t$ (particle velocity).\n- **Physical Model**: 1D soil layer, thickness $H = 30 \\, \\mathrm{m}$, density $\\rho = 1800 \\, \\mathrm{kg/m^3}$, shear modulus $G = 80 \\times 10^6 \\, \\mathrm{Pa}$.\n- **Boundary Conditions**: Stress-free at surface ($z=0, \\tau=0$), prescribed displacement $u_\\text{base}(t)$ at base ($z=H$).\n- **Input Motion**: Trapezoidal base velocity $v_\\text{base}(t)$ with amplitude $V_0 = 0.5 \\, \\mathrm{m/s}$, start time $t_0 = 0.05 \\, \\mathrm{s}$, hold time $T_\\mathrm{hold} = 0.1 \\, \\mathrm{s}$, and variable rise/fall time $t_r$.\n- **Simulation Parameters**: Total duration $T_\\mathrm{end} = 1.2 \\, \\mathrm{s}$, variable mesh spacing $\\Delta z$.\n- **Calibration Objective**: Minimize post-peak oscillation index $O = (\\max_{t  t^\\star} |\\gamma(t)|) / \\gamma_\\max$ for the free-surface shear strain, where $t^\\star$ is the time of first peak $|\\gamma(t)|=\\gamma_\\max$.\n- **Admissibility Constraint**: A candidate viscosity $\\mu_a$ is admissible if its peak strain $\\max_t |\\gamma_{\\mu_a}(t)|$ is at least $(1 - \\delta) \\, \\gamma_\\max^{(0)}$, where $\\gamma_\\max^{(0)}$ is the peak strain for the baseline case $\\mu_a = 0$. $\\delta$ is a given attenuation fraction.\n- **Candidate Viscosities**: $25$ uniformly distributed samples over $[0, \\mu_\\text{max}]$, where $\\mu_\\text{max} = 3 \\times 10^5 \\, \\mathrm{Pa \\cdot s}$.\n- **Numerical Scheme**: Explicit central differences in time, second-order central differences in space, mirror condition at free surface, prescribed displacement at base.\n- **Test Cases**:\n    - A: $\\delta = 0.15$, $\\Delta z = 0.5 \\, \\mathrm{m}$, $t_r = 0.01 \\, \\mathrm{s}$.\n    - B: $\\delta = 0.05$, $\\Delta z = 0.5 \\, \\mathrm{m}$, $t_r = 0.005 \\, \\mathrm{s}$.\n    - C: $\\delta = 0.30$, $\\Delta z = 0.5 \\, \\mathrm{m}$, $t_r = 0.005 \\, \\mathrm{s}$.\n    - D: $\\delta = 0.15$, $\\Delta z = 1.0 \\, \\mathrm{m}$, $t_r = 0.005 \\, \\mathrm{s}$.\n- **Output**: Calibrated $\\mu_a$ values in $\\mathrm{Pa \\cdot s}$, rounded to the nearest $1000$, in the format $[\\mu_A,\\mu_B,\\mu_C,\\mu_D]$.\n\n**Step 2: Validation of Givens**\nThe problem is scientifically grounded, well-posed, and objective. It describes a standard problem in computational geomechanics (1D site response analysis) based on fundamental physical principles (wave equation with damping). The parameters are physically realistic, dimensionally consistent, and sufficient for defining a unique solution. The calibration objective and constraints are formally specified. There are no contradictions, ambiguities, or unsound premises.\n\n**Step 3: Verdict**\nThe problem is **valid**. A full solution will be provided.\n\n### Principle-Based Solution Design\n\nThe solution involves numerically solving the governing partial differential equation (PDE) using the Finite Difference Method (FDM) and then implementing the specified calibration procedure.\n\n**1. Governing Equation for Numerical Analysis**\nCombining the momentum conservation and constitutive equations, and assuming constant material properties $\\rho$, $G$, and $\\mu_a$, we obtain the one-dimensional viscously-damped wave equation:\n$$\n\\rho \\frac{\\partial^2 u}{\\partial t^2} = G \\frac{\\partial^2 u}{\\partial z^2} + \\mu_a \\frac{\\partial^3 u}{\\partial t \\partial z^2}\n$$\nwhere $u(z,t)$ is the horizontal displacement.\n\n**2. Finite Difference Discretization**\nWe discretize the domain with a uniform grid: $z_j = j \\Delta z$ for $j \\in \\{0, 1, ..., N_z\\}$ where $N_z \\Delta z = H$, and in time: $t_n = n \\Delta t$. Let $u_j^n \\approx u(z_j, t_n)$.\n\nThe PDE is discretized using second-order central differences for spatial derivatives and an explicit central difference scheme for the second time derivative. The mixed derivative term is handled using a backward difference in time to maintain an explicit scheme:\n$$\n\\frac{u_j^{n+1} - 2u_j^n + u_j^{n-1}}{(\\Delta t)^2} = \\frac{G}{\\rho} \\left( \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta z)^2} \\right) + \\frac{\\mu_a}{\\rho \\Delta t} \\left( \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta z)^2} - \\frac{u_{j+1}^{n-1} - 2u_j^{n-1} + u_{j-1}^{n-1}}{(\\Delta z)^2} \\right)\n$$\nSolving for $u_j^{n+1}$ gives the explicit update rule for interior nodes ($j \\in \\{1, ..., N_z-1\\}$):\n$$\nu_j^{n+1} = 2u_j^n - u_j^{n-1} + \\left( \\frac{G (\\Delta t)^2}{\\rho (\\Delta z)^2} + \\frac{\\mu_a \\Delta t}{\\rho (\\Delta z)^2} \\right)(u_{j+1}^n - 2u_j^n + u_{j-1}^n) - \\frac{\\mu_a \\Delta t}{\\rho (\\Delta z)^2}(u_{j+1}^{n-1} - 2u_j^{n-1} + u_{j-1}^{n-1})\n$$\n\n**3. Boundary Conditions**\n- **Base ($z=H$, $j=N_z$):** A prescribed displacement is enforced directly: $u_{N_z}^n = u_\\text{base}(t_n)$. The function $u_\\text{base}(t)$ is obtained by numerically integrating the specified velocity pulse $v_\\text{base}(t)$ using the trapezoidal rule.\n- **Free Surface ($z=0$, $j=0$):** The zero-stress condition $\\tau(0,t)=0$ is enforced using a \"mirror\" or \"ghost node\" method. A ghost node is introduced at $j=-1$. The condition $\\tau=0$ is approximately satisfied by enforcing $\\partial u/\\partial z = 0$ and $\\partial v/\\partial z = 0$ at the surface. Using a central difference, this implies $u_{-1}^n = u_1^n$ for all time steps $n$. Substituting this into the general update rule for $j=0$ yields the specific update equation for the surface node:\n$$\nu_0^{n+1} = 2u_0^n - u_0^{n-1} + \\left( \\frac{G (\\Delta t)^2}{\\rho (\\Delta z)^2} + \\frac{\\mu_a \\Delta t}{\\rho (\\Delta z)^2} \\right)(2u_1^n - 2u_0^n) - \\frac{\\mu_a \\Delta t}{\\rho (\\Delta z)^2}(2u_1^{n-1} - 2u_0^{n-1})\n$$\n\n**4. Initial Conditions**\nThe system is initially at rest, so $u(z,0) = 0$ and $v(z,0) = \\partial u/\\partial t |_{t=0} = 0$. This implies $u_j^0 = 0$ for all $j$. The central difference scheme requires values at $t_0$ and $t_{-1}$. The condition $v_j^0=0$ is used to establish $u_j^{-1}$. Approximating $v_j^0 \\approx (u_j^1 - u_j^{-1})/(2\\Delta t) = 0$ gives $u_j^1 = u_j^{-1}$. Applying the general update rule for the first step ($n=0$) and substituting $u_j^0=0$ and $u_j^{-1}=u_j^1$ simplifies to $u_j^1 = 0$ for all internal nodes. Thus, the simulation starts with $u_j^0=0$ and $u_j^1$ being zero everywhere except for the prescribed base motion, $u_{N_z}^1 = u_\\text{base}(\\Delta t)$.\n\n**5. Stability Criterion**\nFor an explicit scheme, the time step $\\Delta t$ must be small enough to ensure numerical stability. A von Neumann stability analysis of the FDM scheme yields the following condition:\n$$\n\\left(\\frac{c \\Delta t}{\\Delta z}\\right)^2 + \\frac{2 \\mu_a \\Delta t}{\\rho(\\Delta z)^2} \\le 1\n$$\nwhere $c = \\sqrt{G/\\rho}$ is the elastic shear wave velocity. This is a quadratic inequality for $\\Delta t$. The critical time step $\\Delta t_\\text{crit}$ is its positive root. For a given $\\Delta z$, this criterion becomes more restrictive as $\\mu_a$ increases. To ensure all simulations in a test set are stable and use a consistent time step for fair comparison, $\\Delta t$ is calculated using the maximum possible viscosity, $\\mu_a = \\mu_\\text{max}$, and a safety factor of $0.9$ is applied.\n\n**6. Calibration Algorithm**\nThe program systematically finds the optimal artificial viscosity $\\mu_a$ for each test case.\n- **Surface Shear Strain**: The shear strain at the free surface, $\\gamma(0,t) = \\partial u/\\partial z|_{z=0}$, is computed at each time step using a second-order accurate one-sided finite difference formula: $\\gamma_0^n = (-3u_0^n + 4u_1^n - u_2^n)/(2\\Delta z)$.\n- **Analysis Loop**:\n  1. For a given test case ($\\delta$, $\\Delta z$, $t_r$), the stable time step $\\Delta t$ is computed.\n  2. The candidate viscosities $\\{\\mu_a^{(k)}\\}$ from $[0, \\mu_\\text{max}]$ are generated.\n  3. A baseline simulation with $\\mu_a = 0$ is run to determine the reference peak strain $\\gamma_\\max^{(0)}$. The admissibility threshold is then $(1 - \\delta)\\gamma_\\max^{(0)}$.\n  4. The program iterates through the candidate viscosities $\\mu_a^{(k)}$ in increasing order.\n  5. For each $\\mu_a^{(k)}$, a simulation is run to obtain its peak strain $\\gamma_\\max^{(\\mu_a)}$ and oscillation index $O$.\n  6. If $\\gamma_\\max^{(\\mu_a)}$ meets the admissibility threshold, the corresponding $O$ is compared to the current minimum.\n  7. The first admissible $\\mu_a^{(k)}$ that produces the minimum $O$ is selected as the optimal value. The tie-breaking rule (smallest $\\mu_a$) is automatically satisfied by iterating in ascending order and only updating the optimal value on strict improvement ($O  O_\\text{min}$).\n- **Final Output**: The calibrated $\\mu_a$ for each of the four test cases is rounded to the nearest $1000 \\, \\mathrm{Pa \\cdot s}$ and formatted as specified.", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import cumulative_trapezoid\n\ndef get_stable_dt(delta_z, rho, G, mu_a_max):\n    \"\"\"\n    Calculates the maximum stable time step based on the FDM scheme's\n    stability condition, considering both elastic and viscous terms.\n    A safety factor of 0.9 is applied.\n    \"\"\"\n    c = np.sqrt(G / rho)\n    a_term = c**2 / delta_z**2\n    b_term = 2 * mu_a_max / (rho * delta_z**2)\n    \n    # Solve a_term * dt^2 + b_term * dt - 1 = 0 for the positive root dt_crit\n    if a_term = 0: # Should not happen for physical parameters\n        return float('inf')\n    \n    discriminant = b_term**2 + 4 * a_term\n    dt_crit = (-b_term + np.sqrt(discriminant)) / (2 * a_term)\n    \n    return 0.9 * dt_crit\n\ndef generate_base_motion(dt, t_end, V0, t0, tr, Thold):\n    \"\"\"\n    Generates the trapezoidal base velocity pulse and integrates it\n    to get the prescribed base displacement time history.\n    \"\"\"\n    time_pts = np.arange(0, t_end + dt, dt)\n    v_base = np.zeros_like(time_pts)\n    \n    t1 = t0\n    t2 = t1 + tr\n    t3 = t2 + Thold\n    t4 = t3 + tr\n    \n    # Linear rise\n    mask1 = (time_pts >= t1)  (time_pts  t2)\n    v_base[mask1] = V0 * (time_pts[mask1] - t1) / tr\n    \n    # Hold\n    mask2 = (time_pts >= t2)  (time_pts  t3)\n    v_base[mask2] = V0\n    \n    # Linear fall\n    mask3 = (time_pts >= t3)  (time_pts  t4)\n    v_base[mask3] = V0 * (1.0 - (time_pts[mask3] - t3) / tr)\n\n    # Integrate velocity using trapezoidal rule\n    u_base = cumulative_trapezoid(v_base, x=time_pts, initial=0.0)\n    \n    return time_pts, u_base\n\ndef run_simulation(params):\n    \"\"\"\n    Runs a single 1D site response simulation for a given set of parameters.\n    \"\"\"\n    mu_a, delta_z, tr, H, rho, G, t_end, V0, t0, Thold, mu_a_max = params\n\n    # Spatial and temporal discretization\n    Nz = int(H / delta_z)\n    dt = get_stable_dt(delta_z, rho, G, mu_a_max)\n    Nt = int(t_end / dt)\n    \n    time_pts, u_base = generate_base_motion(dt, t_end, V0, t0, tr, Thold)\n    \n    # FDM coefficients\n    dz_sq = delta_z**2\n    C1_factor = (G * dt**2 / (rho * dz_sq)) + (mu_a * dt / (rho * dz_sq))\n    C2_factor = - (mu_a * dt / (rho * dz_sq))\n    \n    # Displacement arrays for u^{n-1}, u^n, and u^{n+1}\n    u_prev = np.zeros(Nz + 1)\n    u_curr = np.zeros(Nz + 1)\n    u_next = np.zeros(Nz + 1)\n    \n    # Initial conditions: u(z,0)=0, du/dt(z,0)=0 implies u^0=0 and u^1=0 (for internal nodes)\n    # Apply base motion for the first full time step\n    u_curr[Nz] = u_base[1] if 1  len(u_base) else u_base[-1]\n    \n    gamma_surface_history = np.zeros(Nt + 1)\n    \n    # Main time-stepping loop from n=1 to Nt\n    for n in range(1, Nt):\n        # Vectorized update for interior nodes j=1,...,Nz-1\n        d2u_curr_interior = u_curr[2:Nz+1] - 2 * u_curr[1:Nz] + u_curr[0:Nz-1]\n        d2u_prev_interior = u_prev[2:Nz+1] - 2 * u_prev[1:Nz] + u_prev[0:Nz-1]\n        \n        u_next[1:Nz] = (2 * u_curr[1:Nz] - u_prev[1:Nz] + \n                        C1_factor * d2u_curr_interior + \n                        C2_factor * d2u_prev_interior)\n        \n        # Free surface boundary condition (j=0) using mirror node (u_{-1} = u_1)\n        d2u_curr_surf = 2 * u_curr[1] - 2 * u_curr[0]\n        d2u_prev_surf = 2 * u_prev[1] - 2 * u_prev[0]\n        u_next[0] = (2 * u_curr[0] - u_prev[0] + \n                     C1_factor * d2u_curr_surf + \n                     C2_factor * d2u_prev_surf)\n\n        # Base boundary condition (j=Nz)\n        u_next[Nz] = u_base[n + 1] if n + 1  len(u_base) else u_base[-1]\n        \n        # Calculate surface strain (gamma = du/dz at z=0) using 2nd-order one-sided difference\n        if Nz >= 2:\n            gamma_surface = (-3 * u_next[0] + 4 * u_next[1] - u_next[2]) / (2 * delta_z)\n        else: # Fallback for very coarse meshes\n            gamma_surface = (u_next[1] - u_next[0]) / delta_z\n        gamma_surface_history[n] = gamma_surface\n        \n        # Advance time step\n        u_prev[:] = u_curr\n        u_curr[:] = u_next\n\n    # Post-process to calculate metrics\n    gamma_abs = np.abs(gamma_surface_history)\n    gamma_max = np.max(gamma_abs)\n    \n    if gamma_max  1e-12: # Effectively zero motion\n        return 0.0, 0.0\n    \n    t_star_idx = np.argmax(gamma_abs)\n    post_peak_slice = gamma_abs[t_star_idx + 1:]\n    \n    if post_peak_slice.size == 0:\n        oscillation_index = 0.0\n    else:\n        oscillation_index = np.max(post_peak_slice) / gamma_max\n        \n    return gamma_max, oscillation_index\n\ndef solve():\n    # Test case definitions: (delta, delta_z, t_r)\n    test_cases = [\n        (0.15, 0.5, 0.01),\n        (0.05, 0.5, 0.005),\n        (0.30, 0.5, 0.005),\n        (0.15, 1.0, 0.005),\n    ]\n\n    # Shared physical and simulation parameters\n    rho = 1800.0\n    G = 80e6\n    H = 30.0\n    t_end = 1.2\n    V0 = 0.5\n    t0 = 0.05\n    Thold = 0.1\n    mu_a_max = 3e5\n    num_mu_samples = 25\n    \n    calibrated_mus = []\n\n    for delta, delta_z, tr in test_cases:\n        mu_a_candidates = np.linspace(0, mu_a_max, num_mu_samples)\n        \n        # Run baseline simulation (mu_a = 0) to get reference peak strain\n        params_base = (0.0, delta_z, tr, H, rho, G, t_end, V0, t0, Thold, mu_a_max)\n        gamma_max_0, _ = run_simulation(params_base)\n        \n        admissibility_threshold = (1.0 - delta) * gamma_max_0\n        \n        best_mu_a = -1.0\n        min_oscillation = float('inf')\n        \n        # Iterate through viscosity candidates to find the optimal one\n        for mu_a in mu_a_candidates:\n            params = (mu_a, delta_z, tr, H, rho, G, t_end, V0, t0, Thold, mu_a_max)\n            gamma_max_mu, oscillation_index = run_simulation(params)\n            \n            # Check for admissibility\n            if gamma_max_mu >= admissibility_threshold:\n                # If admissible, check if it has a lower oscillation index\n                if oscillation_index  min_oscillation:\n                    min_oscillation = oscillation_index\n                    best_mu_a = mu_a\n                # The tie-breaking rule (smallest mu_a) is automatically handled\n                # as we iterate through mu_a in increasing order.\n        \n        # Round result to the nearest 1000 Pa.s\n        if best_mu_a != -1.0:\n            calibrated_mus.append(int(round(best_mu_a / 1000) * 1000))\n        else: # Should not be reached if mu_a=0 is always admissible\n            calibrated_mus.append(0)\n\n    # Print results in the specified format\n    print(f\"[{','.join(map(str, calibrated_mus))}]\")\n\nsolve()\n```", "id": "3559403"}]}