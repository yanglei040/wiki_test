{"hands_on_practices": [{"introduction": "To truly understand nonlocal models, we must first learn how to translate the continuous integral operator into a discrete form suitable for computation. This foundational exercise guides you through the numerical implementation of a one-dimensional nonlocal averaging operator using a straightforward trapezoidal rule [@problem_id:3546153]. By working through a series of test cases, you will gain direct, hands-on intuition for the key behaviors of the nonlocal operator, such as its ability to smooth sharp gradients and its response to different length scales and boundary conditions.", "problem": "Consider a one-dimensional continuum model used in computational geomechanics to regularize strain localization via a nonlocal integral average. In strain-softening materials, purely local constitutive laws can lead to ill-posed boundary value problems, where infinitesimal perturbations yield unbounded localization in vanishingly small zones. A common remedy is nonlocal integral regularization: the local driving variable (for example, the equivalent strain) is replaced by an integral average over a finite neighborhood weighted by a kernel. Starting from the conservation of linear momentum and standard small-strain kinematics, the constitutive law is augmented by a nonlocal equivalent strain that enters the softening law. The nonlocal equivalent strain field $\\bar{\\varepsilon}_{\\mathrm{eq}}(x)$ is defined by\n$$\n\\bar{\\varepsilon}_{\\mathrm{eq}}(x) \\;=\\; \\dfrac{\\displaystyle \\int_{\\Omega} \\alpha\\!\\left(\\lVert x-\\xi\\rVert\\right)\\, \\varepsilon_{\\mathrm{eq}}(\\xi)\\, \\mathrm{d}\\xi}{\\displaystyle \\int_{\\Omega} \\alpha\\!\\left(\\lVert x-\\xi\\rVert\\right)\\, \\mathrm{d}\\xi},\n$$\nwhere $\\Omega$ is the domain, $\\varepsilon_{\\mathrm{eq}}(\\xi)$ is the local equivalent strain, and $\\alpha(r)$ is a positive, decaying kernel that introduces an internal length scale and is used to regularize the problem. You will implement a numerical discretization of this nonlocal operator for a one-dimensional bar.\n\nAssume a one-dimensional bar occupying the interval $[0,L]$ with length $L$ measured in meters. Let the domain be discretized into $N$ equally spaced nodes $\\{x_i\\}_{i=1}^N$ with spacing $h = L/(N-1)$. Let the kernel be the exponential function\n$$\n\\alpha(r) \\;=\\; \\exp\\!\\left(-\\dfrac{r}{\\ell}\\right),\n$$\nwhere $\\ell$ is the internal length scale measured in meters. Approximate the integrals with the composite trapezoidal rule, i.e., use quadrature weights $w_1 = w_N = h/2$ and $w_i = h$ for $i=2,\\dots,N-1$. The discrete nonlocal average at node $x_j$ is\n$$\n\\bar{\\varepsilon}_{\\mathrm{eq}}(x_j) \\;\\approx\\; \\dfrac{\\displaystyle \\sum_{i=1}^N \\alpha\\!\\left(\\lvert x_j - x_i\\rvert\\right)\\, \\varepsilon_{\\mathrm{eq}}(x_i)\\, w_i}{\\displaystyle \\sum_{i=1}^N \\alpha\\!\\left(\\lvert x_j - x_i\\rvert\\right)\\, w_i}.\n$$\n\nImplement a complete, runnable program that:\n- Constructs the nodes $\\{x_i\\}$ and trapezoidal weights $\\{w_i\\}$ for given $L$ (in meters) and $N$.\n- Given a specified local equivalent strain field $\\varepsilon_{\\mathrm{eq}}(x)$, computes the discrete nonlocal average $\\bar{\\varepsilon}_{\\mathrm{eq}}(x_j)$ at all nodes for a given internal length $\\ell$ (in meters).\n- Uses the exponential kernel as specified.\n- Produces results for the following test suite of cases. All strains are dimensionless. All lengths and the internal length $\\ell$ are in meters.\n\nTest Case A (uniform invariance):\n- Parameters: $L = 1$, $N = 101$, $\\ell = 0.05$.\n- Local field: $\\varepsilon_{\\mathrm{eq}}(x) = 0.01$ for all $x \\in [0,1]$.\n- Required output: the maximum absolute deviation $\\max_j \\lvert \\bar{\\varepsilon}_{\\mathrm{eq}}(x_j) - 0.01 \\rvert$ as a float.\n\nTest Case B (localized top-hat, center value):\n- Parameters: $L = 1$, $N = 1001$, $\\ell = 0.1$.\n- Local field: $\\varepsilon_{\\mathrm{eq}}(x) = 0.02$ for $x \\in [0.4, 0.6]$ and $\\varepsilon_{\\mathrm{eq}}(x) = 0$ otherwise.\n- Required output: the value of $\\bar{\\varepsilon}_{\\mathrm{eq}}(x_c)$ at $x_c = 0.5$ as a float.\n\nTest Case C (large internal length, approach to mean):\n- Parameters: $L = 1$, $N = 1001$, $\\ell = 1.0$.\n- Local field: same as Test Case B.\n- Theoretical mean value for large $\\ell$: $\\varepsilon_{\\mathrm{mean}} = 0.02 \\times \\dfrac{0.6 - 0.4}{1} = 0.004$.\n- Required output: the absolute difference $\\lvert \\bar{\\varepsilon}_{\\mathrm{eq}}(0.5) - 0.004 \\rvert$ as a float.\n\nTest Case D (near-local limit at center):\n- Parameters: $L = 1$, $N = 1001$, $\\ell = h = L/(N-1)$.\n- Local field: same as Test Case B.\n- Required output: the absolute difference $\\lvert \\bar{\\varepsilon}_{\\mathrm{eq}}(0.5) - 0.02 \\rvert$ as a float.\n\nTest Case E (boundary effect for a gradient):\n- Parameters: $L = 1$, $N = 201$, $\\ell = 0.1$.\n- Local field: $\\varepsilon_{\\mathrm{eq}}(x) = x/L$ for all $x \\in [0,1]$.\n- Required output: the value $\\bar{\\varepsilon}_{\\mathrm{eq}}(0)$ at the left boundary as a float.\n\nYour program should produce a single line of output containing the results for Test Cases A through E, in order, as a comma-separated list enclosed in square brackets (for example, $[r_A,r_B,r_C,r_D,r_E]$). No units are attached to the printed numbers because all outputs are dimensionless. The program must not read any external input.\n\nThe implementation must be scientifically consistent and numerically robust. The discretization must follow the stated trapezoidal quadrature, and the nonlocal average must use the exponential kernel with the internal length scale. Carefully manage boundary normalization via the denominator in the discrete formula to avoid artificial bias near the domain boundaries.", "solution": "The problem requires the implementation of a numerical algorithm to compute a nonlocal integral average, a technique used in computational geomechanics to regularize mathematical models of strain localization in materials. The solution will be constructed by discretizing the governing integral equation and applying it to a series of well-defined test cases.\n\nThe continuous one-dimensional nonlocal equivalent strain $\\bar{\\varepsilon}_{\\mathrm{eq}}(x)$ is defined as a weighted average of the local equivalent strain field $\\varepsilon_{\\mathrm{eq}}(\\xi)$ over the domain $\\Omega = [0, L]$:\n$$\n\\bar{\\varepsilon}_{\\mathrm{eq}}(x) \\;=\\; \\dfrac{\\displaystyle \\int_{0}^{L} \\alpha\\!\\left(\\lvert x-\\xi\\rvert\\right)\\, \\varepsilon_{\\mathrm{eq}}(\\xi)\\, \\mathrm{d}\\xi}{\\displaystyle \\int_{0}^{L} \\alpha\\!\\left(\\lvert x-\\xi\\rvert\\right)\\, \\mathrm{d}\\xi}\n$$\nThe kernel function $\\alpha(r)$ is given by the exponential decay model:\n$$\n\\alpha(r) \\;=\\; \\exp\\!\\left(-\\dfrac{r}{\\ell}\\right)\n$$\nwhere $r = \\lvert x-\\xi\\rvert$ is the distance and $\\ell$ is the characteristic internal length scale. The denominator in the definition of $\\bar{\\varepsilon}_{\\mathrm{eq}}(x)$ ensures that the weights sum to unity, which is particularly important near the boundaries of the domain where the integral is truncated.\n\nTo solve this problem numerically, we first discretize the domain $\\Omega = [0, L]$ into a set of $N$ equally spaced nodes, $\\{x_i\\}_{i=1}^N$. The nodes are located at $x_i = (i-1)h$ for $i = 1, \\dots, N$, where $h = L/(N-1)$ is the constant grid spacing.\n\nWe approximate the integrals in the definition of $\\bar{\\varepsilon}_{\\mathrm{eq}}(x)$ using the composite trapezoidal rule. The integral of a function $f(\\xi)$ over $[0, L]$ is approximated as:\n$$\n\\int_0^L f(\\xi) \\, \\mathrm{d}\\xi \\approx \\sum_{i=1}^N f(x_i) w_i\n$$\nThe quadrature weights $\\{w_i\\}$ for the trapezoidal rule are $w_1 = w_N = h/2$ and $w_i = h$ for all interior nodes $i=2, \\dots, N-1$.\n\nApplying this numerical quadrature to the nonlocal averaging formula at a specific node $x_j$ yields the discrete approximation:\n$$\n\\bar{\\varepsilon}_{\\mathrm{eq}}(x_j) \\;\\approx\\; \\dfrac{\\displaystyle \\sum_{i=1}^N \\alpha\\!\\left(\\lvert x_j - x_i\\rvert\\right)\\, \\varepsilon_{\\mathrm{eq}}(x_i)\\, w_i}{\\displaystyle \\sum_{i=1}^N \\alpha\\!\\left(\\lvert x_j - x_i\\rvert\\right)\\, w_i}\n$$\nThis expression must be computed for each node $j=1, \\dots, N$.\n\nThe implementation will be vectorized for computational efficiency. Let $\\mathbf{x}$ be the column vector of node coordinates, $\\mathbf{w}$ be the vector of trapezoidal weights, and $\\boldsymbol{\\varepsilon}_{\\mathrm{eq}}$ be the vector of local strain values at the nodes. The core of the calculation involves constructing a kernel matrix $\\mathbf{A}$ of size $N \\times N$, where each element $A_{ji}$ is given by:\n$$\nA_{ji} = \\alpha(\\lvert x_j - x_i \\rvert) = \\exp\\left(-\\frac{\\lvert x_j - x_i \\rvert}{\\ell}\\right)\n$$\nThe vector of nonlocal equivalent strains, $\\bar{\\boldsymbol{\\varepsilon}}_{\\mathrm{eq}}$, is then computed as follows:\n1.  Define the node vector $\\mathbf{x} = [x_1, \\dots, x_N]^T$.\n2.  Define the weight vector $\\mathbf{w} = [w_1, \\dots, w_N]^T$.\n3.  Evaluate the local strain field at the nodes to get $\\boldsymbol{\\varepsilon}_{\\mathrm{eq}} = [\\varepsilon_{\\mathrm{eq}}(x_1), \\dots, \\varepsilon_{\\mathrm{eq}}(x_N)]^T$.\n4.  Construct the matrix of distances $\\mathbf{D}$ with elements $D_{ji} = \\lvert x_j - x_i \\rvert$.\n5.  Construct the kernel matrix $\\mathbf{A} = \\exp(-\\mathbf{D}/\\ell)$.\n6.  Compute the numerator vector $\\mathbf{n} = \\mathbf{A} (\\boldsymbol{\\varepsilon}_{\\mathrm{eq}} \\odot \\mathbf{w})$, where $\\odot$ denotes the element-wise (Hadamard) product. This corresponds to the sum in the numerator for each $j$.\n7.  Compute the denominator vector $\\mathbf{d} = \\mathbf{A} \\mathbf{w}$. This corresponds to the sum in the denominator for each $j$.\n8.  The final result is obtained by element-wise division: $\\bar{\\boldsymbol{\\varepsilon}}_{\\mathrm{eq}} = \\mathbf{n} \\oslash \\mathbf{d}$.\n\nThis procedure is applied to each of the specified test cases.\n-   **Test Case A** verifies the fundamental property that a nonlocal operator should preserve a constant field. The deviation from the constant value should be on the order of machine precision.\n-   **Test Case B** demonstrates the primary function of the nonlocal operator: smoothing a sharp discontinuity (a top-hat function). The value at the center of the hat will be less than the local peak value due to averaging with the surrounding zero-strain regions.\n-   **Test Case C** examines the limit where the internal length $\\ell$ is large compared to the domain size $L$. In this limit, the exponential kernel $\\alpha(r)$ becomes nearly constant over the domain, and the nonlocal average should converge to the simple spatial mean of the local field, calculated as $\\varepsilon_{\\mathrm{mean}} = \\frac{1}{L}\\int_0^L \\varepsilon_{\\mathrm{eq}}(x) \\mathrm{d}x$.\n-   **Test Case D** examines the opposite limit where the internal length $\\ell$ is small, on the order of the grid spacing $h$. The kernel becomes highly peaked, approximating a Dirac delta function, and the nonlocal value should converge to the local value.\n-   **Test Case E** is designed to probe boundary effects. For a point $x_j$ near a boundary (e.g., $x_1=0$), the integral is truncated. For a non-constant field like the linear gradient $\\varepsilon_{\\mathrm{eq}}(x) = x/L$, this truncation will cause the nonlocal average to differ significantly from the local value. Specifically at $x=0$, the average only includes contributions from $\\xi \\ge 0$, resulting in a positive value even though the local strain is $\\varepsilon_{\\mathrm{eq}}(0)=0$.\n\nThe algorithm is implemented in a Python script using the NumPy library for efficient array operations, following the vectorized strategy outlined above. Each test case is executed sequentially, and the results are collected and formatted as specified.", "answer": "```python\nimport numpy as np\n\ndef compute_nonlocal_average(L, N, ell, local_eps_func):\n    \"\"\"\n    Computes the discrete nonlocal average for a 1D bar.\n\n    Args:\n        L (float): Length of the bar.\n        N (int): Number of discretization nodes.\n        ell (float): Internal length scale.\n        local_eps_func (callable): A function that takes a numpy array of node\n                                   positions `x` and returns the local strain field.\n\n    Returns:\n        tuple: A tuple containing:\n            - x_nodes (np.ndarray): The positions of the domain nodes.\n            - eps_nonlocal (np.ndarray): The computed nonlocal equivalent strain at each node.\n    \"\"\"\n    # 1. Discretize the domain and define grid spacing\n    x_nodes = np.linspace(0, L, N)\n    if N > 1:\n        h = L / (N - 1)\n    else:\n        h = 0.0 # Handle case N=1\n\n    # 2. Define trapezoidal integration weights\n    w_weights = np.full(N, h)\n    if N > 1:\n        w_weights[0] = h / 2.0\n        w_weights[-1] = h / 2.0\n\n    # 3. Evaluate the local strain field at the nodes\n    eps_local = local_eps_func(x_nodes)\n\n    # 4. Construct the kernel matrix from distances\n    # Use broadcasting to create the distance matrix |x_j - x_i| for all j, i\n    dist_matrix = np.abs(x_nodes[:, np.newaxis] - x_nodes)\n    alpha_matrix = np.exp(-dist_matrix / ell)\n\n    # 5. Compute the nonlocal average using vectorized operations\n    # Numerator: sum_i(alpha_ji * eps_i * w_i) for each j\n    numerator = alpha_matrix @ (eps_local * w_weights)\n    \n    # Denominator: sum_i(alpha_ji * w_i) for each j\n    denominator = alpha_matrix @ w_weights\n\n    # Element-wise division to get the nonlocal strain at each node\n    # Add a small epsilon to the denominator to prevent division by zero in pathological cases,\n    # though not strictly necessary for an exponential kernel over a non-zero domain.\n    eps_nonlocal = numerator / (denominator + 1e-18)\n    \n    return x_nodes, eps_nonlocal\n\ndef solve():\n    \"\"\"\n    Runs all test cases and prints the results in the required format.\n    \"\"\"\n    results = []\n\n    # Test Case A: Uniform invariance\n    L_A, N_A, ell_A = 1.0, 101, 0.05\n    local_eps_A = lambda x: np.full_like(x, 0.01)\n    _, eps_nonlocal_A = compute_nonlocal_average(L_A, N_A, ell_A, local_eps_A)\n    result_A = np.max(np.abs(eps_nonlocal_A - 0.01))\n    results.append(result_A)\n\n    # Test Case B: Localized top-hat, center value\n    L_B, N_B, ell_B = 1.0, 1001, 0.1\n    # Use a small tolerance for floating point comparisons at boundaries\n    local_eps_B = lambda x: 0.02 * ((x >= 0.4 - 1e-9)  (x = 0.6 + 1e-9))\n    x_nodes_B, eps_nonlocal_B = compute_nonlocal_average(L_B, N_B, ell_B, local_eps_B)\n    center_index_B = (N_B - 1) // 2 # N is odd, index corresponds to x=0.5\n    result_B = eps_nonlocal_B[center_index_B]\n    results.append(result_B)\n\n    # Test Case C: Large internal length, approach to mean\n    L_C, N_C, ell_C = 1.0, 1001, 1.0\n    local_eps_C = local_eps_B  # Same local field as B\n    x_nodes_C, eps_nonlocal_C = compute_nonlocal_average(L_C, N_C, ell_C, local_eps_C)\n    center_index_C = (N_C - 1) // 2\n    theoretical_mean = 0.004\n    result_C = np.abs(eps_nonlocal_C[center_index_C] - theoretical_mean)\n    results.append(result_C)\n\n    # Test Case D: Near-local limit at center\n    L_D, N_D = 1.0, 1001\n    h_D = L_D / (N_D - 1)\n    ell_D = h_D\n    local_eps_D = local_eps_B  # Same local field as B\n    x_nodes_D, eps_nonlocal_D = compute_nonlocal_average(L_D, N_D, ell_D, local_eps_D)\n    center_index_D = (N_D - 1) // 2\n    local_center_value_D = 0.02\n    result_D = np.abs(eps_nonlocal_D[center_index_D] - local_center_value_D)\n    results.append(result_D)\n\n    # Test Case E: Boundary effect for a gradient\n    L_E, N_E, ell_E = 1.0, 201, 0.1\n    local_eps_E = lambda x: x / L_E\n    x_nodes_E, eps_nonlocal_E = compute_nonlocal_average(L_E, N_E, ell_E, local_eps_E)\n    result_E = eps_nonlocal_E[0]  # Value at the left boundary, x=0\n    results.append(result_E)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.15g}' for r in results)}]\")\n\nsolve()\n```", "id": "3546153"}, {"introduction": "Having established how to implement a nonlocal operator, we now explore the theoretical reasons for its regularizing effect. Nonlocal averaging functions as a low-pass filter, selectively damping the high-frequency spatial modes that lead to pathological strain localization. This analytical practice delves into the frequency domain to compare the filtering characteristics of three commonly used kernels, revealing how their mathematical form dictates their effectiveness at regularization [@problem_id:3546113].", "problem": "Consider a one-dimensional nonlocal integral regularization of a scalar field, where the nonlocal field $\\bar{u}(x)$ is defined by convolution with a symmetric, nonnegative, normalized weight function $w(x)$ via $\\bar{u}(x) = \\int_{-\\infty}^{\\infty} w(x-\\xi)\\,u(\\xi)\\,\\mathrm{d}\\xi$. Let the Fourier transform be defined by $\\hat{f}(k) = \\int_{-\\infty}^{\\infty} f(x)\\,\\mathrm{e}^{- \\mathrm{i} k x}\\,\\mathrm{d}x$. By the convolution theorem, the ratio of spectral amplitudes of $\\bar{u}(x)$ to $u(x)$ is precisely $\\hat{w}(k)$. In regularization for strain localization, attenuation of high-frequency modes is governed by the decay of $\\hat{w}(k)$ as $k \\to \\infty$.\n\nThree kernels are considered, each scaled so that its second moment equals the same nonlocal characteristic length squared $\\ell^2$, that is $\\int_{-\\infty}^{\\infty} x^2 w(x)\\,\\mathrm{d}x = \\ell^2$:\n\n1) Gaussian kernel: $w_{\\mathrm{G}}(x) = \\dfrac{1}{\\sqrt{2\\pi}\\,\\ell}\\,\\exp\\!\\left(-\\dfrac{x^2}{2\\ell^2}\\right)$.\n\n2) Exponential kernel: $w_{\\mathrm{E}}(x) = \\dfrac{1}{2a}\\,\\exp\\!\\left(-\\dfrac{|x|}{a}\\right)$ with $a$ chosen such that $\\int_{-\\infty}^{\\infty} x^2 w_{\\mathrm{E}}(x)\\,\\mathrm{d}x = \\ell^2$.\n\n3) Quartic compact-support kernel: $w_{\\mathrm{Q}}(x) = \\dfrac{15}{16R}\\left(1 - \\dfrac{x^2}{R^2}\\right)^2$ for $|x|\\le R$ and $w_{\\mathrm{Q}}(x)=0$ for $|x|R$, with $R$ chosen such that $\\int_{-\\infty}^{\\infty} x^2 w_{\\mathrm{Q}}(x)\\,\\mathrm{d}x = \\ell^2$.\n\nStarting only from the above definitions and the definition of the Fourier transform, analyze the decay of $\\hat{w}(k)$ as $k$ increases and the qualitative features of $\\hat{w}(k)$ for each kernel. Then answer the following, selecting all statements that are correct:\n\nA) When all three kernels are scaled to have the same second moment $\\ell^2$, the high-wavenumber ordering of attenuation is: Gaussian decays fastest (super-exponentially in $k$), quartic compact-support decays next (algebraically as $k^{-3}$ with oscillations), and exponential decays slowest (algebraically as $k^{-2}$).\n\nB) For all three kernels scaled to satisfy $\\int x^2 w(x)\\,\\mathrm{d}x = \\ell^2$, the small-wavenumber expansion of the transform satisfies $\\hat{w}(k) = 1 - \\dfrac{1}{2} \\ell^2 k^2 + o(k^2)$ as $k \\to 0$.\n\nC) The exponential kernel’s Fourier transform decays as $\\mathrm{e}^{-\\ell|k|}$ and therefore attenuates high-frequency modes faster than the Gaussian kernel.\n\nD) The quartic compact-support kernel’s Fourier transform $\\hat{w}_{\\mathrm{Q}}(k)$ is strictly positive and strictly monotone decreasing for $k0$.\n\nE) An exact closed-form expression for the quartic compact-support kernel’s Fourier transform is $\\hat{w}_{\\mathrm{Q}}(k) = - \\dfrac{15 \\sin(kR)}{k^3 R^3} - \\dfrac{45 \\cos(kR)}{k^4 R^4} + \\dfrac{45 \\sin(kR)}{k^5 R^5}$, using the same $R$ as in the kernel definition.", "solution": "The problem statement is first validated to ensure it is scientifically sound, well-posed, and objective.\n\n**Step 1: Extract Givens**\n- The nonlocal field $\\bar{u}(x)$ is defined by the convolution $\\bar{u}(x) = \\int_{-\\infty}^{\\infty} w(x-\\xi)\\,u(\\xi)\\,\\mathrm{d}\\xi$.\n- The weight function $w(x)$ is symmetric, nonnegative, and normalized ($\\int_{-\\infty}^{\\infty} w(x)\\,\\mathrm{d}x=1$).\n- The Fourier transform is defined as $\\hat{f}(k) = \\int_{-\\infty}^{\\infty} f(x)\\,\\mathrm{e}^{- \\mathrm{i} k x}\\,\\mathrm{d}x$.\n- The ratio of spectral amplitudes is $\\hat{w}(k)$.\n- All kernels are scaled such that their second moment is $\\ell^2$: $\\int_{-\\infty}^{\\infty} x^2 w(x)\\,\\mathrm{d}x = \\ell^2$.\n- The three kernels are:\n    1.  Gaussian: $w_{\\mathrm{G}}(x) = \\dfrac{1}{\\sqrt{2\\pi}\\,\\ell}\\,\\exp\\!\\left(-\\dfrac{x^2}{2\\ell^2}\\right)$.\n    2.  Exponential: $w_{\\mathrm{E}}(x) = \\dfrac{1}{2a}\\,\\exp\\!\\left(-\\dfrac{|x|}{a}\\right)$ with $a$ to be determined.\n    3.  Quartic compact-support: $w_{\\mathrm{Q}}(x) = \\dfrac{15}{16R}\\left(1 - \\dfrac{x^2}{R^2}\\right)^2$ for $|x|\\le R$ and $w_{\\mathrm{Q}}(x)=0$ for $|x|R$, with $R$ to be determined.\n\n**Step 2: Validate Using Extracted Givens**\n- The problem is **scientifically grounded**. Nonlocal integral models are a standard technique in continuum mechanics for regularization, especially in the context of strain localization. The use of Fourier analysis to study the filtering properties of the kernel is also standard. The chosen kernels are common in the literature.\n- The problem is **well-posed**. The definitions of the kernels and the tasks are mathematically precise. The calculations of the second moments and Fourier transforms lead to unique results.\n- The problem is **objective**. It uses formal mathematical language and poses a question that can be answered through derivation without ambiguity.\n- The problem is **self-contained and consistent**. All necessary definitions are provided. We can verify that the provided kernels are normalized:\n    - $\\int_{-\\infty}^{\\infty} w_{\\mathrm{G}}(x)\\,\\mathrm{d}x = \\int_{-\\infty}^{\\infty} \\frac{1}{\\sqrt{2\\pi}\\,\\ell}\\,\\exp(-\\frac{x^2}{2\\ell^2})\\,\\mathrm{d}x = 1$.\n    - $\\int_{-\\infty}^{\\infty} w_{\\mathrm{E}}(x)\\,\\mathrm{d}x = \\int_{-\\infty}^{\\infty} \\frac{1}{2a} e^{-|x|/a}\\,\\mathrm{d}x = 2 \\int_{0}^{\\infty} \\frac{1}{2a} e^{-x/a}\\,\\mathrm{d}x = 1$.\n    - $\\int_{-\\infty}^{\\infty} w_{\\mathrm{Q}}(x)\\,\\mathrm{d}x = \\int_{-R}^{R} \\frac{15}{16R} (1 - \\frac{x^2}{R^2})^2\\,\\mathrm{d}x = \\frac{15}{16} \\int_{-1}^{1} (1-y^2)^2\\,\\mathrm{d}y = \\frac{15}{16} \\cdot \\frac{16}{15} = 1$.\n\n**Step 3: Verdict and Action**\nThe problem is valid. We proceed with the solution.\n\n**Derivation**\n\nFirst, we determine the scaling parameters $a$ and $R$ for the exponential and quartic kernels using the second moment condition $\\int_{-\\infty}^{\\infty} x^2 w(x)\\,\\mathrm{d}x = \\ell^2$.\n\nFor the Gaussian kernel, $w_{\\mathrm{G}}(x)$ is a probability density function with mean $0$ and standard deviation $\\ell$. Its variance (and second moment) is already $\\ell^2$, so no scaling parameter adjustment is needed.\n\nFor the Exponential kernel, $w_{\\mathrm{E}}(x)$:\n$$\\ell^2 = \\int_{-\\infty}^{\\infty} x^2 w_{\\mathrm{E}}(x)\\,\\mathrm{d}x = \\int_{-\\infty}^{\\infty} x^2 \\frac{1}{2a} \\mathrm{e}^{-|x|/a}\\,\\mathrm{d}x = \\frac{1}{a} \\int_0^{\\infty} x^2 \\mathrm{e}^{-x/a}\\,\\mathrm{d}x$$\nUsing the identity $\\int_0^{\\infty} t^n \\mathrm{e}^{-ct}\\,\\mathrm{d}t = n!/c^{n+1}$ with $n=2$ and $c=1/a$, we get:\n$$\\ell^2 = \\frac{1}{a} \\frac{2!}{(1/a)^3} = \\frac{2a^3}{a} = 2a^2$$\nThus, $a^2 = \\ell^2/2$, which implies $a=\\ell/\\sqrt{2}$.\n\nFor the Quartic kernel, $w_{\\mathrm{Q}}(x)$:\n$$\\ell^2 = \\int_{-R}^{R} x^2 \\frac{15}{16R} \\left(1 - \\frac{x^2}{R^2}\\right)^2\\,\\mathrm{d}x = \\frac{15}{16R} \\int_{-R}^{R} \\left(x^2 - \\frac{2x^4}{R^2} + \\frac{x^6}{R^4}\\right)\\,\\mathrm{d}x$$\nThe integrand is even, so we can integrate from $0$ to $R$ and multiply by $2$:\n$$\\ell^2 = \\frac{15}{8R} \\left[ \\frac{x^3}{3} - \\frac{2x^5}{5R^2} + \\frac{x^7}{7R^4} \\right]_0^R = \\frac{15R^2}{8} \\left( \\frac{1}{3} - \\frac{2}{5} + \\frac{1}{7} \\right) = \\frac{15R^2}{8} \\left( \\frac{35-42+15}{105} \\right) = \\frac{15R^2}{8} \\frac{8}{105} = \\frac{R^2}{7}$$\nThus, $R^2 = 7\\ell^2$, which implies $R = \\sqrt{7}\\ell$.\n\nNext, we find the Fourier transform $\\hat{w}(k)$ for each kernel.\n\n1.  **Gaussian kernel:** The Fourier transform of a Gaussian function $N(0, \\sigma^2)$ is $\\mathrm{e}^{-\\frac{1}{2}\\sigma^2 k^2}$. Here, $\\sigma^2 = \\ell^2$.\n    $$\\hat{w}_{\\mathrm{G}}(k) = \\mathrm{e}^{-\\ell^2 k^2/2}$$\n    For large $k$, this decays super-exponentially.\n\n2.  **Exponential kernel:** We use $a=\\ell/\\sqrt{2}$.\n    $$\\hat{w}_{\\mathrm{E}}(k) = \\int_{-\\infty}^{\\infty} \\frac{1}{2a} \\mathrm{e}^{-|x|/a} \\mathrm{e}^{-ikx}\\,\\mathrm{d}x = \\frac{1}{2a} \\left( \\frac{2/a}{(1/a)^2 + k^2} \\right) = \\frac{1}{1+a^2k^2}$$\n    Substituting $a^2=\\ell^2/2$:\n    $$\\hat{w}_{\\mathrm{E}}(k) = \\frac{1}{1+\\ell^2k^2/2}$$\n    For large $k$, $\\hat{w}_{\\mathrm{E}}(k) \\sim 2/(\\ell^2k^2)$, which is an algebraic decay of order $k^{-2}$.\n\n3.  **Quartic kernel:**\n    $$\\hat{w}_{\\mathrm{Q}}(k) = \\int_{-R}^{R} \\frac{15}{16R}\\left(1 - \\frac{x^2}{R^2}\\right)^2 \\mathrm{e}^{-ikx}\\,\\mathrm{d}x$$\n    Since $w_Q(x)$ is real and even, its transform is real. Let $z=kR$.\n    $$\\hat{w}_{\\mathrm{Q}}(k) = \\frac{15}{16} \\int_{-1}^{1} (1-y^2)^2 \\cos(zy)\\,\\mathrm{d}y$$\n    Integrating by parts repeatedly shows that for a function which is $C^{n-1}$ with a jump in the $n$-th derivative, the Fourier transform decays as $k^{-(n+1)}$. Here, $w_{\\mathrm{Q}}(x)$ is $C^1$ at $x=\\pm R$ but its second derivative $w_{\\mathrm{Q}}''(x) = \\frac{15}{16R} (-\\frac{4}{R^2} + \\frac{12x^2}{R^4})$ has a jump discontinuity at $x=\\pm R$ (it is non-zero at the boundary of its support). Thus, $n=2$, and the decay rate is $k^{-(2+1)} = k^{-3}$. Direct calculation of the integral, for instance by successive integration by parts, yields:\n    $$\\hat{w}_{\\mathrm{Q}}(k) = -\\frac{15\\sin(kR)}{(kR)^3} - \\frac{45\\cos(kR)}{(kR)^4} + \\frac{45\\sin(kR)}{(kR)^5}$$\n    For large $k$, the dominant term is proportional to $(kR)^{-3}$, confirming the $k^{-3}$ algebraic decay. The trigonometric functions cause oscillations.\n\n**Option-by-Option Analysis**\n\n**A) When all three kernels are scaled to have the same second moment $\\ell^2$, the high-wavenumber ordering of attenuation is: Gaussian decays fastest (super-exponentially in $k$), quartic compact-support decays next (algebraically as $k^{-3}$ with oscillations), and exponential decays slowest (algebraically as $k^{-2}$).**\n- Gaussian decay: $\\mathrm{e}^{-\\ell^2k^2/2}$, super-exponential. This is the fastest.\n- Quartic decay: $\\sim k^{-3}$.\n- Exponential decay: $\\sim k^{-2}$.\nSince $k^{-2}$ decays slower than $k^{-3}$, which in turn decays much slower than $\\mathrm{e}^{-\\ell^2k^2/2}$, the ordering of decay speed (attenuation) is Gaussian  Quartic  Exponential. The statement correctly identifies the functional forms of the decay and the ordering.\n**Verdict: Correct.**\n\n**B) For all three kernels scaled to satisfy $\\int x^2 w(x)\\,\\mathrm{d}x = \\ell^2$, the small-wavenumber expansion of the transform satisfies $\\hat{w}(k) = 1 - \\dfrac{1}{2} \\ell^2 k^2 + o(k^2)$ as $k \\to 0$.**\nThe Fourier transform $\\hat{w}(k)$ can be expanded in a Maclaurin series in $k$, with coefficients related to the moments of $w(x)$:\n$$\\hat{w}(k) = \\sum_{n=0}^{\\infty} \\frac{(-ik)^n}{n!} \\int_{-\\infty}^{\\infty} x^n w(x)\\,\\mathrm{d}x = \\sum_{n=0}^{\\infty} \\frac{(-ik)^n}{n!} M_n$$\nwhere $M_n$ is the $n$-th moment.\n- $M_0 = \\int w(x)\\,\\mathrm{d}x = 1$ (normalization).\n- $M_1 = \\int x w(x)\\,\\mathrm{d}x = 0$ (symmetry).\n- $M_2 = \\int x^2 w(x)\\,\\mathrm{d}x = \\ell^2$ (given scaling).\n- All odd moments $M_{2n+1}$ are zero due to symmetry.\nSubstituting these into the expansion:\n$$\\hat{w}(k) = M_0 - ikM_1 - \\frac{k^2}{2}M_2 -i\\frac{k^3}{6}M_3 + O(k^4) = 1 - 0 - \\frac{k^2}{2}\\ell^2 - 0 + O(k^4)$$\nThus, $\\hat{w}(k) = 1 - \\frac{1}{2}\\ell^2k^2 + O(k^4)$. Since $O(k^4)$ is a term that goes to zero faster than $k^2$, it can be written as $o(k^2)$. The statement is therefore true for any normalized, symmetric kernel with second moment $\\ell^2$, which includes all three kernels considered.\n**Verdict: Correct.**\n\n**C) The exponential kernel’s Fourier transform decays as $\\mathrm{e}^{-\\ell|k|}$ and therefore attenuates high-frequency modes faster than the Gaussian kernel.**\nThe Fourier transform of the exponential kernel is $\\hat{w}_{\\mathrm{E}}(k) = \\frac{1}{1+\\ell^2k^2/2}$, which is a Lorentzian function. Its decay is algebraic ($k^{-2}$), not exponential ($\\mathrm{e}^{-\\ell|k|}$). Furthermore, the Gaussian kernel's transform decays as $\\mathrm{e}^{-\\ell^2k^2/2}$, which is super-exponential and much faster than any simple exponential decay $\\mathrm{e}^{-c|k|}$. The statement is incorrect on both counts.\n**Verdict: Incorrect.**\n\n**D) The quartic compact-support kernel’s Fourier transform $\\hat{w}_{\\mathrm{Q}}(k)$ is strictly positive and strictly monotone decreasing for $k0$.**\nThe expression for $\\hat{w}_{\\mathrm{Q}}(k)$ contains $\\sin(kR)$ and $\\cos(kR)$ terms. These cause the transform to oscillate and take on negative values for certain ranges of $k$. For example, at $kR=2\\pi$, we have $\\sin(2\\pi)=0$ and $\\cos(2\\pi)=1$, so $\\hat{w}_{\\mathrm{Q}}(k=2\\pi/R) = -45/(2\\pi)^4  0$. Therefore, the transform is not strictly positive, nor is it monotone decreasing.\n**Verdict: Incorrect.**\n\n**E) An exact closed-form expression for the quartic compact-support kernel’s Fourier transform is $\\hat{w}_{\\mathrm{Q}}(k) = - \\dfrac{15 \\sin(kR)}{k^3 R^3} - \\dfrac{45 \\cos(kR)}{k^4 R^4} + \\dfrac{45 \\sin(kR)}{k^5 R^5}$, using the same $R$ as in the kernel definition.**\nAs derived earlier, the integral for the transform is $\\hat{w}_{\\mathrm{Q}}(k) = \\frac{15}{16} \\int_{-1}^{1} (1-y^2)^2 \\cos(zy)\\,\\mathrm{d}y$ with $z=kR$. A careful evaluation of this integral (e.g., via integration by parts) gives\n$$\\int_{-1}^{1} (1-y^2)^2 \\cos(zy)\\,\\mathrm{d}y = -\\frac{16\\sin z}{z^3} - \\frac{48\\cos z}{z^4} + \\frac{48\\sin z}{z^5}$$\nMultiplying by the normalization constant $\\frac{15}{16}$:\n$$\\hat{w}_{\\mathrm{Q}}(k) = \\frac{15}{16} \\left( -\\frac{16\\sin(kR)}{(kR)^3} - \\frac{48\\cos(kR)}{(kR)^4} + \\frac{48\\sin(kR)}{(kR)^5} \\right)$$\n$$= -\\frac{15\\sin(kR)}{(kR)^3} - \\frac{45\\cos(kR)}{(kR)^4} + \\frac{45\\sin(kR)}{(kR)^5}$$\nThis expression matches the statement exactly. Note $(kR)^n = k^n R^n$.\n**Verdict: Correct.**", "answer": "$$\\boxed{ABE}$$", "id": "3546113"}, {"introduction": "This final practice applies our understanding of nonlocal regularization to a quintessential problem in geomechanics: predicting the width of shear bands observed in laboratory tests. You will use the results of a linear stability analysis to compare the predictions of the integral nonlocal model against a closely related gradient damage model [@problem_id:3546155]. This exercise provides a powerful demonstration of how theoretical models are validated and selected by their ability to connect material parameters like the internal length $\\ell$ and fracture energy $G_f$ to physically measurable quantities.", "problem": "Consider a one-dimensional representation of a plane strain direct shear test along a spatial coordinate $x \\in \\mathbb{R}$, where the shear strain field is denoted by $\\gamma(x)$. A scalar damage-type constitutive model is used in which the stress response softens with a negative tangent (softening) slope $H0$ governed by a nonlocal equivalent strain $\\bar{\\gamma}(x)$, while the undamaged shear modulus is $G0$. Two regularization approaches are considered: an integral nonlocal model and a gradient damage model. The objective is to determine, for given material and loading parameters, which regularization more accurately reproduces an observed shear band width, while controlling for the fracture energy per unit area, the internal length, and the softening slope.\n\nFundamental base and definitions:\n- In the integral nonlocal model, the nonlocal equivalent strain is defined by a normalized convolution\n$$\n\\bar{\\gamma}(x) = \\int_{-\\infty}^{\\infty} w_n(|x-y|)\\,\\gamma(y)\\,\\mathrm{d}y,\n$$\nwhere the normalized Gaussian weight function is\n$$\nw_n(r) = \\frac{\\exp\\!\\left[-(r/\\ell)^2\\right]}{\\int_{-\\infty}^{\\infty}\\exp\\!\\left[-(s/\\ell)^2\\right]\\mathrm{d}s} = \\frac{1}{\\sqrt{\\pi}\\,\\ell}\\,\\exp\\!\\left[-(r/\\ell)^2\\right],\n$$\nand $\\ell0$ is the internal length scale. The Fourier transform of $w_n(r)$ is\n$$\n\\widehat{w_n}(k) = \\int_{-\\infty}^{\\infty} w_n(r)\\,e^{-i k r}\\,\\mathrm{d}r = \\exp\\!\\left[-\\left(\\frac{k\\,\\ell}{2}\\right)^2\\right],\n$$\nwhere $k \\ge 0$ is the wavenumber of a harmonic perturbation $\\delta\\gamma(x)=A\\,e^{i k x}$.\n\n- In the gradient damage model, the Helmholtz-type nonlocality is given in Fourier space by the relation\n$$\n\\widehat{\\bar{\\gamma}}(k) = \\frac{\\widehat{\\gamma}(k)}{1 + \\ell^2 k^2},\n$$\nwhich is the Fourier symbol of the differential operator $(1 - \\ell^2 \\partial_{xx})^{-1}$ applied to $\\gamma(x)$ under vanishing gradients at infinity.\n\nLinear stability analysis of localization:\n- Consider an infinitesimal harmonic perturbation $\\delta\\gamma(x)=A e^{i k x}$ to a homogeneous base state. The effective incremental shear modulus in softening depends on the nonlocal filtering of $\\delta\\gamma$:\n    - For the integral nonlocal model, the filtered perturbation is $\\delta\\bar{\\gamma} = \\widehat{w_n}(k)\\,\\delta\\gamma$, giving an effective tangent\n    $$\n    G_{\\text{eff,int}}(k) = G + H\\,\\widehat{w_n}(k).\n    $$\n    - For the gradient damage model, the filtered perturbation is $\\delta\\bar{\\gamma} = \\delta\\gamma/(1+\\ell^2 k^2)$, giving an effective tangent\n    $$\n    G_{\\text{eff,grad}}(k) = G + \\frac{H}{1 + \\ell^2 k^2}.\n    $$\n- The onset of localization (loss of ellipticity) is identified when the effective tangent first reaches zero for some $k \\ge 0$.\n    - Integral nonlocal: solve $G + H \\exp\\!\\left[-(k \\ell/2)^2\\right] = 0$ for $k$, which yields, provided $|H| \\ge G$,\n    $$\n    \\exp\\!\\left[-\\left(\\frac{k\\,\\ell}{2}\\right)^2\\right] = \\frac{G}{|H|} \\quad \\Rightarrow \\quad k_{\\text{int}} = \\frac{2}{\\ell}\\,\\sqrt{-\\ln\\!\\left(\\frac{G}{|H|}\\right)}.\n    $$\n    If $|H|G$, no real solution exists and localization is not predicted. If $|H|=G$, then $k_{\\text{int}}=0$ and the predicted width is infinite.\n    - Gradient damage: solve $G + H/(1+\\ell^2 k^2) = 0$ for $k$, which yields, provided $|H| \\ge G$,\n    $$\n    1 + \\ell^2 k^2 = \\frac{|H|}{G} \\quad \\Rightarrow \\quad k_{\\text{grad}} = \\frac{1}{\\ell}\\,\\sqrt{\\frac{|H|}{G}-1}.\n    $$\n    If $|H|G$, no real solution exists; if $|H|=G$, then $k_{\\text{grad}}=0$ and the predicted width is infinite.\n\nDefinition of shear band width:\n- For a dominant sinusoidal localization mode of wavenumber $k$, define the shear band width as the half-wavelength\n$$\nw = \\frac{\\pi}{k}.\n$$\nThus $w_{\\text{int}} = \\pi/k_{\\text{int}}$ and $w_{\\text{grad}} = \\pi/k_{\\text{grad}}$, with $w=\\infty$ when $k=0$ and $w$ not defined when no real $k$ exists.\n\nFracture energy consistency:\n- For linear softening of shear stress from peak shear strength $\\tau_p0$ to zero with constant negative slope $H0$ as a function of the nonlocal equivalent strain, the local energy dissipated per unit volume is\n$$\ng_{\\text{loc}} = \\frac{1}{2}\\,\\tau_p\\,\\Delta\\gamma = \\frac{1}{2}\\,\\frac{\\tau_p^2}{|H|},\n$$\nwhere $\\Delta\\gamma = \\tau_p/|H|$. Assuming a unit thickness in the out-of-plane direction, the fracture energy per unit area implied by a band of width $w$ is\n$$\nG_{f,\\text{pred}} = g_{\\text{loc}}\\,w = \\frac{1}{2}\\,\\frac{\\tau_p^2}{|H|}\\,w.\n$$\nGiven an observed fracture energy $G_f0$, one may assess the consistency of a predicted width $w$ via the relative error in $G_{f,\\text{pred}}$.\n\nTask:\n- For each test case, given the parameters $(G, H, \\ell, \\tau_p, G_f, w_{\\text{obs}})$, compute $w_{\\text{int}}$ and $w_{\\text{grad}}$ using the formulas above. If $|H|G$, treat the corresponding width as not-a-number. If $|H|=G$, set the width to infinity.\n- For each model, compute the relative width error $e_w = \\left| \\frac{w_{\\text{model}}}{w_{\\text{obs}}} - 1 \\right|$ and the fracture energy relative error $e_g = \\left| \\frac{G_{f,\\text{pred}}}{G_f} - 1 \\right|$, where $G_{f,\\text{pred}} = \\frac{1}{2}\\,\\frac{\\tau_p^2}{|H|}\\,w_{\\text{model}}$.\n- Define the combined error $E = e_w + e_g$.\n- Decision rule per test case:\n    - If both models predict no localization or infinite width, return $-1$.\n    - If only one model yields a finite width, select that model.\n    - Otherwise, select the model with the smaller combined error $E$. Return $0$ for the integral nonlocal model and $1$ for the gradient damage model.\n\nPhysical units:\n- Use Pascals for stresses ($\\tau_p$ and $G$, in $\\mathrm{Pa}$), meters for lengths ($\\ell$ and $w_{\\text{obs}}$, in $\\mathrm{m}$), and Joules per square meter for fracture energy ($G_f$, in $\\mathrm{J}/\\mathrm{m}^2$).\n\nTest suite:\n- Case $1$: $G=1.0\\times 10^{10}\\,\\mathrm{Pa}$, $H=-2.0\\times 10^{10}\\,\\mathrm{Pa}$, $\\ell=0.01\\,\\mathrm{m}$, $\\tau_p=5.0\\times 10^{7}\\,\\mathrm{Pa}$, $G_f=5000\\,\\mathrm{J}/\\mathrm{m}^2$, $w_{\\text{obs}}=0.025\\,\\mathrm{m}$.\n- Case $2$ (threshold): $G=1.0\\times 10^{10}\\,\\mathrm{Pa}$, $H=-1.0\\times 10^{10}\\,\\mathrm{Pa}$, $\\ell=0.02\\,\\mathrm{m}$, $\\tau_p=6.0\\times 10^{7}\\,\\mathrm{Pa}$, $G_f=4000\\,\\mathrm{J}/\\mathrm{m}^2$, $w_{\\text{obs}}=0.03\\,\\mathrm{m}$.\n- Case $3$ (no localization): $G=1.5\\times 10^{10}\\,\\mathrm{Pa}$, $H=-7.5\\times 10^{9}\\,\\mathrm{Pa}$, $\\ell=0.015\\,\\mathrm{m}$, $\\tau_p=4.0\\times 10^{7}\\,\\mathrm{Pa}$, $G_f=3000\\,\\mathrm{J}/\\mathrm{m}^2$, $w_{\\text{obs}}=0.02\\,\\mathrm{m}$.\n- Case $4$ (strong softening, small width): $G=1.0\\times 10^{10}\\,\\mathrm{Pa}$, $H=-5.0\\times 10^{10}\\,\\mathrm{Pa}$, $\\ell=0.005\\,\\mathrm{m}$, $\\tau_p=8.0\\times 10^{7}\\,\\mathrm{Pa}$, $G_f=8000\\,\\mathrm{J}/\\mathrm{m}^2$, $w_{\\text{obs}}=0.01\\,\\mathrm{m}$.\n- Case $5$ (small internal length): $G=1.0\\times 10^{10}\\,\\mathrm{Pa}$, $H=-3.0\\times 10^{10}\\,\\mathrm{Pa}$, $\\ell=0.002\\,\\mathrm{m}$, $\\tau_p=7.0\\times 10^{7}\\,\\mathrm{Pa}$, $G_f=6000\\,\\mathrm{J}/\\mathrm{m}^2$, $w_{\\text{obs}}=0.006\\,\\mathrm{m}$.\n- Case $6$ (consistency favoring integral): $G=1.0\\times 10^{10}\\,\\mathrm{Pa}$, $H=-2.0\\times 10^{10}\\,\\mathrm{Pa}$, $\\ell=0.01\\,\\mathrm{m}$, $\\tau_p=5.0\\times 10^{7}\\,\\mathrm{Pa}$, $G_f=1200\\,\\mathrm{J}/\\mathrm{m}^2$, $w_{\\text{obs}}=0.0189\\,\\mathrm{m}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of integers enclosed in square brackets, in the same order as the test suite (for example, $[0,1,-1,1,0,1]$).", "solution": "The user-provided problem is assessed as valid. It is scientifically grounded in the principles of continuum damage mechanics and strain localization, specifically using nonlocal regularization techniques. All definitions, models, and parameters are provided, rendering the problem self-contained and well-posed. The task is an objective, quantitative comparison between two standard models based on clear, mathematical criteria. The provided physical parameters are realistic for applications in geomechanics.\n\nThe solution proceeds by implementing the specified calculation for each test case. The overall procedure for a single test case with parameters $(G, H, \\ell, \\tau_p, G_f, w_{\\text{obs}})$ is as follows:\n\n1.  **Check for Localization**: The first step is to evaluate the condition for the onset of localization, which is $|H| \\ge G$. The parameters $G$ and $H$ are the elastic shear modulus and the softening modulus, respectively.\n    *   If $|H|  G$, strain localization does not occur in either model. The characteristic wavenumber $k$ is not a real number, and thus the shear band width $w$ is undefined. In the implementation, this is represented by not-a-number ($NaN$).\n    *   If $|H| = G$, this is the bifurcation threshold. The analysis yields a characteristic wavenumber $k=0$ for both models, corresponding to an infinite shear band width, $w = \\infty$.\n    *   If $|H|  G$, localization occurs with a finite, non-zero wavenumber $k  0$, resulting in a finite shear band width $w$.\n\n2.  **Calculate Predicted Shear Band Widths**: If localization with a finite width is predicted ($|H|  G$), the shear band widths for the integral nonlocal model ($w_{\\text{int}}$) and the gradient damage model ($w_{\\text{grad}}$) are computed.\n    *   The wavenumber for the integral model is given by\n        $$\n        k_{\\text{int}} = \\frac{2}{\\ell}\\,\\sqrt{-\\ln\\!\\left(\\frac{G}{|H|}\\right)}\n        $$\n        And the corresponding width is $w_{\\textint} = \\pi/k_{\\text{int}}$.\n    *   The wavenumber for the gradient model is given by\n        $$\n        k_{\\text{grad}} = \\frac{1}{\\ell}\\,\\sqrt{\\frac{|H|}{G}-1}\n        $$\n        And the corresponding width is $w_{\\text{grad}} = \\pi/k_{\\text{grad}}$.\n\n3.  **Evaluate Model Performance**: For each model that yields a finite, positive width, two error metrics are computed: the relative width error ($e_w$) and the relative fracture energy error ($e_g$).\n    *   The relative width error measures the deviation of the predicted width $w_{\\text{model}}$ from the observed width $w_{\\text{obs}}$:\n        $$\n        e_w = \\left| \\frac{w_{\\text{model}}}{w_{\\text{obs}}} - 1 \\right|\n        $$\n    *   The fracture energy error compares the model-predicted fracture energy $G_{f,\\text{pred}}$ to the observed fracture energy $G_f$. The predicted fracture energy is calculated by integrating the local energy dissipated per unit volume, $g_{\\text{loc}}$, over the band width $w_{\\text{model}}$:\n        $$\n        G_{f,\\text{pred}} = g_{\\text{loc}} \\cdot w_{\\text{model}} = \\left(\\frac{1}{2}\\,\\frac{\\tau_p^2}{|H|}\\right) w_{\\text{model}}\n        $$\n        The relative error is then:\n        $$\n        e_g = \\left| \\frac{G_{f,\\text{pred}}}{G_f} - 1 \\right|\n        $$\n    *   A combined error metric, $E$, is defined as the sum of these two errors:\n        $$\n        E = e_w + e_g\n        $$\n\n4.  **Apply Decision Rule**: A final decision is made based on the computed widths and errors for each test case.\n    *   If both models predict an undefined ($NaN$) or infinite width, the result is $-1$.\n    *   If only one model predicts a finite, positive width, that model is chosen. A result of $0$ indicates the integral model, and $1$ indicates the gradient model.\n    *   If both models predict finite, positive widths, the model with the lower combined error $E$ is selected. The return value is again $0$ for the integral model or $1$ for the gradient model.\n\nThis procedure is applied to each of the six test cases provided, and the results are compiled into a final list.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_case(G, H, l, tau_p, G_f, w_obs):\n    \"\"\"\n    Solves a single test case for the nonlocal regularization problem.\n\n    Args:\n        G (float): Shear modulus (Pa).\n        H (float): Softening slope (Pa).\n        l (float): Internal length (m).\n        tau_p (float): Peak shear strength (Pa).\n        G_f (float): Observed fracture energy (J/m^2).\n        w_obs (float): Observed shear band width (m).\n\n    Returns:\n        int: -1 for no unique finite solution, 0 for integral model, 1 for gradient model.\n    \"\"\"\n    abs_H = np.abs(H)\n\n    # Initialize widths to NaN (Not a Number)\n    w_int = np.nan\n    w_grad = np.nan\n\n    # Check localization condition: |H| must be >= G\n    if abs_H  G:\n        # No localization predicted by either model\n        w_int = np.nan\n        w_grad = np.nan\n    elif abs_H == G:\n        # Bifurcation threshold, infinite wavelength/width\n        w_int = np.inf\n        w_grad = np.inf\n    else: # abs_H > G, finite width localization\n        # Integral model\n        ratio_int = G / abs_H\n        k_int = (2 / l) * np.sqrt(-np.log(ratio_int))\n        if k_int > 0:\n            w_int = np.pi / k_int\n        else: # Should not happen if abs_H > G\n            w_int = np.inf\n\n        # Gradient model\n        ratio_grad = abs_H / G\n        k_grad = (1 / l) * np.sqrt(ratio_grad - 1)\n        if k_grad > 0:\n            w_grad = np.pi / k_grad\n        else: # Should not happen if abs_H > G\n            w_grad = np.inf\n\n    # Check validity of predicted widths\n    is_int_valid = np.isfinite(w_int) and w_int > 0\n    is_grad_valid = np.isfinite(w_grad) and w_grad > 0\n\n    # Apply decision rules\n    if not is_int_valid and not is_grad_valid:\n        return -1\n    elif is_int_valid and not is_grad_valid:\n        return 0\n    elif not is_int_valid and is_grad_valid:\n        return 1\n    else: # Both are valid, compare combined error E\n        # Local energy dissipation per unit volume\n        g_loc = 0.5 * (tau_p**2) / abs_H\n\n        # Errors for integral model\n        G_f_pred_int = g_loc * w_int\n        e_w_int = np.abs(w_int / w_obs - 1)\n        e_g_int = np.abs(G_f_pred_int / G_f - 1)\n        E_int = e_w_int + e_g_int\n\n        # Errors for gradient model\n        G_f_pred_grad = g_loc * w_grad\n        e_w_grad = np.abs(w_grad / w_obs - 1)\n        e_g_grad = np.abs(G_f_pred_grad / G_f - 1)\n        E_grad = e_w_grad + e_g_grad\n        \n        return 0 if E_int  E_grad else 1\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # (G, H, l, tau_p, G_f, w_obs)\n    test_cases = [\n        (1.0e10, -2.0e10, 0.01, 5.0e7, 5000, 0.025),\n        (1.0e10, -1.0e10, 0.02, 6.0e7, 4000, 0.03),\n        (1.5e10, -7.5e9, 0.015, 4.0e7, 3000, 0.02),\n        (1.0e10, -5.0e10, 0.005, 8.0e7, 8000, 0.01),\n        (1.0e10, -3.0e10, 0.002, 7.0e7, 6000, 0.006),\n        (1.0e10, -2.0e10, 0.01, 5.0e7, 1200, 0.0189),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3546155"}]}