{"hands_on_practices": [{"introduction": "The accuracy of any meshfree method begins with its ability to reliably interpolate field data. This first exercise provides a fundamental benchmark, comparing the classical Smoothed Particle Hydrodynamics (SPH) interpolant against the more accurate Reproducing Kernel Particle Method (RKPM) [@problem_id:3543176]. By implementing both from first principles to approximate a known stress field, you will directly observe and quantify the concepts of boundary deficiency and polynomial reproduction, which are crucial for building robust meshfree models.", "problem": "Consider a one-dimensional elastic soil bar occupying the domain $x \\in [0,1]$ with a non-homogeneous true normal stress field given by $\\sigma_{xx}(x) = \\sigma_0 \\exp\\!\\left(-x/L\\right)$, where $\\sigma_0$ is a constant stress amplitude and $L$ is a characteristic decay length. You will benchmark the interpolation accuracy of the classical Smoothed Particle Hydrodynamics (SPH) approximation against the Reproducing Kernel Particle Method (RKPM) with linear polynomial reproduction for this field. The task is purely interpolation: no governing equations of motion or equilibrium are to be solved. Treat $\\sigma_0$ in $\\mathrm{kPa}$ and $L$ in $\\mathrm{m}$; the required outputs are dimensionless relative errors with no unit.\n\nYour derivations and implementation must start from the following fundamental bases, without using pre-derived shortcut formulas:\n\n- The kernel approximation of a scalar field $f(x)$ as a mollified convolution with a radially symmetric, compactly supported kernel $W(r,h)$ that satisfies normalization and positivity, where $r = |x - \\xi|$ and $h$ is a smoothing length.\n- The discrete particle approximation of integrals over the domain using particle volumes $V_j$ at particle locations $x_j$.\n- The polynomial reproduction (moment) conditions that define the RKPM correction for a chosen polynomial basis, ensuring exact reproduction of that basis.\n\nUsing only these bases, perform the following:\n\n- Derive the classical SPH particle interpolant $\\tilde{f}_{\\mathrm{SPH}}(x)$ from the continuous kernel approximation and the discrete quadrature using uniform particle spacing. Do not assume any boundary correction or renormalization beyond the kernel normalization itself.\n- Derive the RKPM particle interpolant $\\tilde{f}_{\\mathrm{RKPM}}(x)$ using a linear polynomial basis $p(x) = [1, x]^\\top$ and a compactly supported kernel, enforcing the linear reproduction conditions via a local moment matrix at each evaluation point.\n- For both methods, use the same one-dimensional cubic spline kernel with compact support radius $2h$ and implement it consistently. Ensure numerical stability of any matrix inversions that arise by adding a vanishingly small diagonal stabilization, and justify your choice.\n- Compute the discretization using a uniform nodal discretization of $N$ particles on $[0,1]$, with nodal volumes $V_j$ equal to the nodal spacing $\\Delta x = 1/(N-1)$.\n\nFor accuracy assessment:\n\n- For each test case, evaluate both interpolants at $M$ uniformly spaced sample points in $[0,1]$ and compute the relative $L^2$ error \n$$\n\\varepsilon = \\sqrt{\\dfrac{\\sum_{k=1}^{M}\\left(\\tilde{\\sigma}(x_k)-\\sigma_{xx}(x_k)\\right)^2}{\\sum_{k=1}^{M}\\left(\\sigma_{xx}(x_k)\\right)^2}},\n$$\nfor each method separately. This error is dimensionless; report it as a real number with no unit.\n\nTest suite:\n\nImplement and run your program for the following $3$ test cases. In each case, the domain is $[0,1]$ in $\\mathrm{m}$, $\\sigma_0$ is in $\\mathrm{kPa}$, and the smoothing length is $h = \\alpha \\Delta x$, where $\\alpha$ is the specified smoothing-to-spacing ratio. The outputs are the relative $L^2$ errors, which are dimensionless.\n\n- Case $1$ (happy path, moderate decay, well-resolved kernel support):\n  - $\\sigma_0 = 100$,\n  - $L = 0.3$,\n  - $N = 51$,\n  - $\\alpha = 2.5$,\n  - $M = 401$.\n\n- Case $2$ (boundary-challenging, minimal support, steeper decay):\n  - $\\sigma_0 = 100$,\n  - $L = 0.1$,\n  - $N = 51$,\n  - $\\alpha = 1.01$,\n  - $M = 401$.\n\n- Case $3$ (fine resolution, moderate support, very steep decay):\n  - $\\sigma_0 = 100$,\n  - $L = 0.05$,\n  - $N = 201$,\n  - $\\alpha = 2.0$,\n  - $M = 1001$.\n\nFinal output format:\n\n- Your program should produce a single line of output containing a flat list of $6$ floating-point numbers enclosed in square brackets. The list must contain, in order, the classical SPH relative $L^2$ error followed by the RKPM relative $L^2$ error for each of the $3$ cases. That is, the output must be of the form \n$[\\varepsilon_{\\mathrm{SPH}}^{(1)},\\varepsilon_{\\mathrm{RKPM}}^{(1)},\\varepsilon_{\\mathrm{SPH}}^{(2)},\\varepsilon_{\\mathrm{RKPM}}^{(2)},\\varepsilon_{\\mathrm{SPH}}^{(3)},\\varepsilon_{\\mathrm{RKPM}}^{(3)}]$,\nwith each $\\varepsilon$ reported as a floating-point number and no units.", "solution": "The problem requires a comparative analysis of the interpolation accuracy of classical Smoothed Particle Hydrodynamics (SPH) and the Reproducing Kernel Particle Method (RKPM) for a one-dimensional, non-homogeneous stress field. The derivations must originate from fundamental principles.\n\nThe continuous representation of a scalar field $f(x)$ via kernel approximation is given by the convolution integral:\n$$\n\\langle f(x) \\rangle = \\int_{\\Omega} f(\\xi) W(x - \\xi, h) d\\xi\n$$\nwhere $W$ is a kernel function with smoothing length $h$, and $\\Omega$ is the problem domain. The kernel is a symmetric, positive function with compact support, satisfying the normalization condition $\\int_{\\Omega} W(x - \\xi, h) d\\xi = 1$ for points $x$ sufficiently far from the boundary.\n\nThis integral is discretized using a set of $N$ particles at positions $x_j$ with associated volumes $V_j$. The discrete approximation of the integral yields the general particle approximation formula:\n$$\n\\tilde{f}(x) = \\sum_{j=1}^{N} f(x_j) W(x - x_j, h) V_j\n$$\nwhere $f(x_j)$ is the field value at particle $j$. The problem specifies a uniform particle distribution on the domain $x \\in [0, 1]$, such that particle positions are $x_j = (j-1)\\Delta x$ for $j=1, \\dots, N$, with spacing $\\Delta x = 1/(N-1)$ and particle volumes $V_j = \\Delta x$.\n\nThe specified kernel is the one-dimensional cubic spline kernel with compact support radius $2h$. Let $r = |x - \\xi|$ and $q = r/h$. The kernel is defined as:\n$$\nW(r, h) = \\frac{1}{h} \\phi(q) \\quad \\text{where} \\quad \\phi(q) = \\begin{cases} \\frac{2}{3} - q^2 + \\frac{1}{2}q^3 & 0 \\le q < 1 \\\\ \\frac{1}{6}(2-q)^3 & 1 \\le q < 2 \\\\ 0 & q \\ge 2 \\end{cases}\n$$\nThe factor of $1/h$ ensures the kernel is normalized in an infinite domain.\n\nThe field to be interpolated is the normal stress $\\sigma_{xx}(x) = \\sigma_0 \\exp(-x/L)$.\n\n**Classical SPH Interpolation**\n\nThe classical SPH interpolant, denoted $\\tilde{\\sigma}_{\\mathrm{SPH}}(x)$, is derived directly from the particle approximation formula without any modifications for boundary effects. Substituting the given stress field and discretization:\n$$\n\\tilde{\\sigma}_{\\mathrm{SPH}}(x) = \\sum_{j=1}^{N} \\sigma_{xx}(x_j) W(x - x_j, h) V_j\n$$\nThis formulation suffers from a lack of accuracy near the boundaries of the domain. Because the kernel is truncated by the boundary, the discrete sum $\\sum_j W(x - x_j, h) V_j$ no longer equals $1$, leading to an error in reproducing even a constant function. This is known as the boundary deficiency or zeroth-order consistency error.\n\n**Reproducing Kernel Particle Method (RKPM) Interpolation**\n\nRKPM corrects this deficiency by modifying the kernel to enforce the exact reproduction of a polynomial basis. For this problem, a linear basis $\\mathbf{p}(x) = [1, x]^\\top$ is required. The RKPM interpolant is constructed as:\n$$\n\\tilde{\\sigma}_{\\mathrm{RKPM}}(x) = \\sum_{j=1}^{N} \\Psi_j(x) \\sigma_{xx}(x_j) V_j\n$$\nwhere $\\Psi_j(x)$ is the corrected shape function for particle $j$, defined as:\n$$\n\\Psi_j(x) = C(x, x-x_j) W(x-x_j, h)\n$$\nThe correction function $C(x, x-x_j)$ is a polynomial in $x_j$ whose coefficients depend on the evaluation point $x$:\n$$\nC(x, x-x_j) = \\mathbf{b}(x)^\\top \\mathbf{p}(x_j) = b_0(x) \\cdot 1 + b_1(x) \\cdot x_j\n$$\nThe vector of coefficients $\\mathbf{b}(x) = [b_0(x), b_1(x)]^\\top$ is determined by enforcing the reproduction conditions. These conditions demand that any polynomial $P(x)$ in the span of the basis $\\mathbf{p}(x)$ is reproduced exactly by the interpolation scheme. This is equivalent to satisfying the following moment conditions:\n$$\n\\sum_{j=1}^{N} \\Psi_j(x) \\mathbf{p}(x_j)^\\top = \\mathbf{p}(x)^\\top\n$$\nSubstituting the definition of $\\Psi_j(x)$ and $C(x, x-x_j)$:\n$$\n\\sum_{j=1}^{N} \\mathbf{b}(x)^\\top \\mathbf{p}(x_j) \\mathbf{p}(x_j)^\\top W(x-x_j, h) V_j = \\mathbf{p}(x)^\\top\n$$\nLet us define the moment matrix $\\mathbf{M}(x)$ as:\n$$\n\\mathbf{M}(x) = \\sum_{j=1}^{N} \\mathbf{p}(x_j) \\mathbf{p}(x_j)^\\top W(x-x_j, h) V_j\n$$\nThe system of equations for $\\mathbf{b}(x)$ becomes:\n$$\n\\mathbf{b}(x)^\\top \\mathbf{M}(x) = \\mathbf{p}(x)^\\top \\implies \\mathbf{M}(x) \\mathbf{b}(x) = \\mathbf{p}(x)\n$$\nSolving for $\\mathbf{b}(x)$ yields $\\mathbf{b}(x) = \\mathbf{M}(x)^{-1} \\mathbf{p}(x)$. The corrected shape function is therefore:\n$$\n\\Psi_j(x) = \\mathbf{p}(x)^\\top \\mathbf{M}(x)^{-1} \\mathbf{p}(x_j) W(x-x_j, h)\n$$\nAnd the final RKPM interpolant is:\n$$\n\\tilde{\\sigma}_{\\mathrm{RKPM}}(x) = \\mathbf{p}(x)^\\top \\mathbf{M}(x)^{-1} \\sum_{j=1}^{N} \\mathbf{p}(x_j) \\sigma_{xx}(x_j) W(x-x_j, h) V_j\n$$\nFor the basis $\\mathbf{p}(x) = [1, x]^\\top$, the moment matrix $\\mathbf{M}(x)$ is a $2 \\times 2$ matrix:\n$$\n\\mathbf{M}(x) = \\sum_{j=1}^{N} \\begin{bmatrix} 1 & x_j \\\\ x_j & x_j^2 \\end{bmatrix} W(x - x_j, h) V_j\n$$\nNear the boundaries, if the number of particles within the kernel support diminishes, $\\mathbf{M}(x)$ can become ill-conditioned or singular. To ensure numerical stability, we regularize the matrix by adding a small positive value to its diagonal elements, i.e., we invert $\\mathbf{M}_{\\text{stab}}(x) = \\mathbf{M}(x) + \\epsilon \\mathbf{I}$, where $\\mathbf{I}$ is the identity matrix and $\\epsilon$ is a small number (e.g., $10^{-15}$). This regularization guarantees invertibility without significantly affecting the result for well-conditioned systems.\n\n**Accuracy Assessment**\n\nThe accuracy of each method is quantified by the relative $L^2$ error, $\\varepsilon$. The interpolants $\\tilde{\\sigma}_{\\mathrm{SPH}}(x)$ and $\\tilde{\\sigma}_{\\mathrm{RKPM}}(x)$ are evaluated at $M$ uniformly spaced sample points $x_k$ in $[0,1]$. The error is then calculated as:\n$$\n\\varepsilon = \\sqrt{\\dfrac{\\sum_{k=1}^{M}\\left(\\tilde{\\sigma}(x_k)-\\sigma_{xx}(x_k)\\right)^2}{\\sum_{k=1}^{M}\\left(\\sigma_{xx}(x_k)\\right)^2}}\n$$\nThis dimensionless metric provides a normalized measure of the interpolation error over the entire domain. The procedure is repeated for each test case specified in the problem statement.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the benchmark for SPH and RKPM interpolation.\n    \"\"\"\n    test_cases = [\n        # Case 1: (sigma0, L, N, alpha, M)\n        (100.0, 0.3, 51, 2.5, 401),\n        # Case 2:\n        (100.0, 0.1, 51, 1.01, 401),\n        # Case 3:\n        (100.0, 0.05, 201, 2.0, 1001),\n    ]\n\n    results = []\n    for sigma0, L, N, alpha, M in test_cases:\n        err_sph, err_rkpm = compute_errors(sigma0, L, N, alpha, M)\n        results.extend([err_sph, err_rkpm])\n\n    # Final print statement in the exact required format.\n    # The format string ensures standard float representation.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef cubic_spline_kernel(r, h):\n    \"\"\"\n    Computes the 1D cubic spline kernel value.\n    compact support radius is 2h.\n    \n    Args:\n        r (float or np.ndarray): Absolute distance |x - xi|.\n        h (float): Smoothing length.\n        \n    Returns:\n        float or np.ndarray: Kernel value W(r, h).\n    \"\"\"\n    if h <= 0:\n        return 0.0\n    \n    # The kernel function works on a single value or a numpy array\n    q = np.abs(r) / h\n    \n    # Create masks for the two parts of the spline\n    mask1 = (q >= 0) & (q < 1)\n    mask2 = (q >= 1) & (q < 2)\n    \n    # Initialize result array of the same shape and type as q\n    val = np.zeros_like(q)\n    \n    # Apply formulas based on masks\n    if val.ndim > 0:\n        q1 = q[mask1]\n        val[mask1] = (2.0/3.0) - q1**2 + 0.5 * q1**3\n        q2 = q[mask2]\n        val[mask2] = (1.0/6.0) * (2.0 - q2)**3\n    else: # Scalar case\n        if mask1:\n            val = (2.0/3.0) - q**2 + 0.5 * q**3\n        elif mask2:\n            val = (1.0/6.0) * (2.0 - q)**3\n            \n    return val / h\n\ndef compute_errors(sigma0, L, N, alpha, M):\n    \"\"\"\n    Computes SPH and RKPM interpolated fields and their relative L2 errors.\n\n    Args:\n        sigma0 (float): Stress amplitude.\n        L (float): Characteristic decay length.\n        N (int): Number of particles.\n        alpha (float): Smoothing length to a particle spacing ratio.\n        M (int): Number of sample points for error evaluation.\n\n    Returns:\n        tuple: A tuple containing (error_sph, error_rkpm).\n    \"\"\"\n    # 1. Discretization setup\n    domain_start, domain_end = 0.0, 1.0\n    particle_pos = np.linspace(domain_start, domain_end, N)\n    delta_x = (domain_end - domain_start) / (N - 1)\n    particle_vol = delta_x\n    h = alpha * delta_x\n    \n    # 2. Field definition\n    true_stress_func = lambda x: sigma0 * np.exp(-x / L)\n    \n    particle_stress_vals = true_stress_func(particle_pos)\n    \n    sample_pos = np.linspace(domain_start, domain_end, M)\n    \n    # 3. Interpolation\n    sph_interpolated = np.zeros(M)\n    rkpm_interpolated = np.zeros(M)\n    \n    for k, x_eval in enumerate(sample_pos):\n        # Find neighboring particles (within kernel support 2h)\n        # For simplicity and given N, we iterate through all particles and check support\n        \n        sum_sph = 0.0\n        moment_matrix = np.zeros((2, 2))\n        moment_vector = np.zeros(2)\n\n        p_eval = np.array([1.0, x_eval]) # Basis vector at evaluation point\n\n        for j in range(N):\n            x_j = particle_pos[j]\n            r = np.abs(x_eval - x_j)\n            \n            if r < 2.0 * h:\n                w_ij = cubic_spline_kernel(r, h)\n                sigma_j = particle_stress_vals[j]\n                \n                # SPH calculation\n                sum_sph += sigma_j * w_ij * particle_vol\n                \n                # RKPM calculation\n                p_j = np.array([1.0, x_j]) # Basis vector at particle j\n                p_j_outer_p_j = np.outer(p_j, p_j)\n                \n                moment_matrix += p_j_outer_p_j * w_ij * particle_vol\n                moment_vector += p_j * sigma_j * w_ij * particle_vol\n\n        sph_interpolated[k] = sum_sph\n        \n        # Finalize RKPM for point k\n        # Add stabilization to prevent singularity, as justified in the solution\n        stabilization = 1e-15 * np.eye(2)\n        moment_matrix += stabilization\n        \n        try:\n            M_inv = np.linalg.inv(moment_matrix)\n            rkpm_interpolated[k] = p_eval @ M_inv @ moment_vector\n        except np.linalg.LinAlgError:\n            # Fallback if matrix is singular despite stabilization\n            # This should ideally not be reached\n            rkpm_interpolated[k] = 0.0\n\n    # 4. Error calculation\n    true_stress_at_samples = true_stress_func(sample_pos)\n    \n    # SPH error\n    num_sph = np.sum((sph_interpolated - true_stress_at_samples)**2)\n    den_sph = np.sum(true_stress_at_samples**2)\n    error_sph = np.sqrt(num_sph / den_sph) if den_sph > 0 else 0.0\n    \n    # RKPM error\n    num_rkpm = np.sum((rkpm_interpolated - true_stress_at_samples)**2)\n    den_rkpm = np.sum(true_stress_at_samples**2)\n    error_rkpm = np.sqrt(num_rkpm / den_rkpm) if den_rkpm > 0 else 0.0\n    \n    return error_sph, error_rkpm\n\n# Execute the main function\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3543176"}, {"introduction": "Moving from pure interpolation to mechanics, this practice bridges the gap between SPH kinematics and realistic material behavior. You will simulate a drained triaxial compression test, a cornerstone of soil mechanics, by coupling an SPH-based strain approximation with a Drucker–Prager elastoplastic model [@problem_id:3543179]. This exercise challenges you to implement a full return-mapping algorithm and a servo-control loop, providing direct insight into how kinematic approximation errors influence the predicted stress-strain response of a geomaterial.", "problem": "Consider a drained axisymmetric triaxial compression test modeled at small strain using a meshfree Smoothed Particle Hydrodynamics (SPH) kinematic approximation coupled with an elastoplastic Drucker–Prager constitutive model with associated flow. Adopt a soil mechanics compression-positive sign convention for stresses and strains. The goal is to compute the stress path in the mean stress–deviatoric stress plane for a prescribed axial strain history and a servo-controlled constant radial (confining) stress, and to compare an SPH-based numerical path against a reference path obtained from a direct continuum update using the exact homogeneous strain rate. Quantify the discrepancy by an $L^2$-type error in stress space.\n\nStart from the following fundamental base and core definitions:\n\n- Linear isotropic elasticity at small strain with Young’s modulus $E$ and Poisson’s ratio $\\nu$, bulk modulus $K = \\dfrac{E}{3(1-2\\nu)}$, and shear modulus $G = \\dfrac{E}{2(1+\\nu)}$.\n- Cauchy stress tensor $\\boldsymbol{\\sigma}$ and small strain tensor $\\boldsymbol{\\varepsilon}$ with the elastic relation $\\Delta \\boldsymbol{\\sigma} = 3 K \\Delta \\varepsilon_{\\mathrm{m}} \\dfrac{\\mathbf{I}}{3} + 2 G \\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{dev}}$, where $\\Delta \\varepsilon_{\\mathrm{m}} = \\mathrm{tr}(\\Delta \\boldsymbol{\\varepsilon})$ and $\\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{dev}} = \\Delta \\boldsymbol{\\varepsilon} - \\dfrac{\\Delta \\varepsilon_{\\mathrm{m}}}{3} \\mathbf{I}$.\n- Mean stress $p = \\dfrac{1}{3} \\mathrm{tr}(\\boldsymbol{\\sigma})$ and von Mises-type deviatoric stress invariant $q = \\sqrt{3 J_2}$, with $J_2$ the second invariant of the stress deviator. Under axisymmetry with axial stress $\\sigma_{\\mathrm{a}}$ and equal radial stresses $\\sigma_{\\mathrm{r}}$, one has $p = \\dfrac{\\sigma_{\\mathrm{a}} + 2 \\sigma_{\\mathrm{r}}}{3}$ and $q = |\\sigma_{\\mathrm{a}} - \\sigma_{\\mathrm{r}}|$.\n- Drucker–Prager yield function in $(p,q)$ form $f = q + \\alpha p - k$, with associated plastic flow. The material parameters $\\alpha$ and $k$ are functions of friction angle $\\varphi$ and cohesion $c$ via the standard inscribed Drucker–Prager mapping, $\\alpha = \\dfrac{2 \\sin \\varphi}{\\sqrt{3} (3 - \\sin \\varphi)}$ and $k = \\dfrac{6 c \\cos \\varphi}{\\sqrt{3} (3 - \\sin \\varphi)}$.\n- Drained condition: pore pressure changes are negligible; stresses are effective stresses.\n- Axisymmetric kinematics for each strain increment $\\Delta \\boldsymbol{\\varepsilon} = \\mathrm{diag}(\\Delta \\varepsilon_{\\mathrm{r}}, \\Delta \\varepsilon_{\\mathrm{r}}, \\Delta \\varepsilon_{\\mathrm{a}})$, with servo-control enforcing $\\sigma_{\\mathrm{r}}$ equal to the constant confining pressure $p_{\\mathrm{c}}$ at the end of each increment.\n\nUse the SPH framework only to approximate the homogeneous axial velocity gradient that defines the axial strain increment per time step. Specifically, consider a one-dimensional domain $x \\in [0,L]$ discretized by $N$ equally spaced particles of spacing $\\Delta x = L/(N-1)$ and mass density $\\rho$ (use any positive constant, noting that the ratio $m/\\rho$ reduces to the particle volume in one dimension). Adopt the standard one-dimensional cubic B-spline kernel with smoothing length $h$ and its spatial derivative $\\partial W/\\partial x_i$. For a linear velocity field $v(x) = \\dot{\\varepsilon}_{\\mathrm{a}} x$, approximate the axial velocity gradient at particle $i$ by\n$$\n\\left(\\frac{\\partial v}{\\partial x}\\right)_i \\approx \\sum_{j} \\frac{m_j}{\\rho_j} \\left(v_j - v_i\\right) \\frac{\\partial W(x_i - x_j, h)}{\\partial x_i},\n$$\nand define the SPH-estimated homogeneous axial strain rate as the arithmetic mean of these pointwise gradients. This estimate differs from the exact gradient due to kernel truncation near the boundaries for finite $N$ and $h$.\n\nAlgorithmic task:\n\n1. Set up the axisymmetric elastoplastic return mapping for the Drucker–Prager model with associated flow to update stress from step $n$ to $n+1$ for a given strain increment. The update must start from the fundamental decomposition of strains and stresses into volumetric and deviatoric parts and enforce the yield condition at the end of the step by computing a plastic multiplier based on consistency. Reconstruct $\\sigma_{\\mathrm{a}}^{n+1}$ and $\\sigma_{\\mathrm{r}}^{n+1}$ from the updated $(p^{n+1}, q^{n+1})$ along the axisymmetric direction.\n2. Enforce the drained triaxial servo condition $\\sigma_{\\mathrm{r}}^{n+1} = p_{\\mathrm{c}}$ by solving for the unknown radial strain increment $\\Delta \\varepsilon_{\\mathrm{r}}$ given the axial strain increment $\\Delta \\varepsilon_{\\mathrm{a}}$. Use a robust root-finding strategy grounded in basic calculus (e.g., Newton’s method with finite-difference derivative) applied to the residual $R(\\Delta \\varepsilon_{\\mathrm{r}}) = \\sigma_{\\mathrm{r}}^{n+1}(\\Delta \\varepsilon_{\\mathrm{r}}) - p_{\\mathrm{c}}$.\n3. Compute two stress paths over $n_{\\mathrm{steps}}$ equal increments to a prescribed final axial strain $\\varepsilon_{\\mathrm{a,final}}$ starting from isotropic stress $(\\sigma_{\\mathrm{a}}^0,\\sigma_{\\mathrm{r}}^0) = (p_{\\mathrm{c}}, p_{\\mathrm{c}})$:\n   - A reference path using the exact homogeneous axial strain increment $\\Delta \\varepsilon_{\\mathrm{a}} = \\varepsilon_{\\mathrm{a,final}} / n_{\\mathrm{steps}}$ at each step.\n   - An SPH-based path using the SPH-estimated homogeneous axial strain increment $\\Delta \\varepsilon_{\\mathrm{a}}^{\\mathrm{SPH}} = \\gamma \\, \\Delta \\varepsilon_{\\mathrm{a}}$, where $\\gamma$ is the ratio of the SPH-estimated gradient to the exact gradient for the linear velocity field $v(x) = x$ computed once on the fixed particle set.\n4. In both paths, at each step enforce $\\sigma_{\\mathrm{r}}^{n+1} = p_{\\mathrm{c}}$ through the servo procedure in item $2$, update $(\\sigma_{\\mathrm{a}}, \\sigma_{\\mathrm{r}})$, and record $(p,q)$.\n5. Quantify the discrepancy between the two paths by the root-mean-square $L^2$-type error in stress space over the recorded steps,\n$$\n\\mathcal{E} = \\sqrt{\\frac{1}{M} \\sum_{k=0}^{M-1} \\left[ \\left(p_k^{\\mathrm{SPH}} - p_k^{\\mathrm{ref}}\\right)^2 + \\left(q_k^{\\mathrm{SPH}} - q_k^{\\mathrm{ref}}\\right)^2 \\right]},\n$$\nwhere $M = n_{\\mathrm{steps}} + 1$. Report $\\mathcal{E}$ in kilopascals, i.e., divide Pascals by $1000$.\n\nAngle units must be in degrees where specified. Stresses must be in Pascals internally; the final errors must be expressed in kilopascals. The final output must be a single line containing a list of floating-point numbers, one per test case, in the exact format specified below.\n\nUse the following test suite of three cases to assess different regimes and resolutions:\n\n- Case A (moderate friction–cohesion, moderate resolution):\n  - $E = 100 \\times 10^6$ $\\mathrm{Pa}$, $\\nu = 0.3$, $\\varphi = 30$ $\\mathrm{deg}$, $c = 30 \\times 10^3$ $\\mathrm{Pa}$, $p_{\\mathrm{c}} = 100 \\times 10^3$ $\\mathrm{Pa}$.\n  - Domain $L = 1.0$ $\\mathrm{m}$, $N = 21$, smoothing length factor $\\eta = 1.2$ so that $h = \\eta \\Delta x$.\n  - Final axial strain $\\varepsilon_{\\mathrm{a,final}} = 0.02$, number of steps $n_{\\mathrm{steps}} = 200$.\n\n- Case B (high cohesion, essentially elastic, finer resolution):\n  - $E = 50 \\times 10^6$ $\\mathrm{Pa}$, $\\nu = 0.2$, $\\varphi = 0$ $\\mathrm{deg}$, $c = 500 \\times 10^3$ $\\mathrm{Pa}$, $p_{\\mathrm{c}} = 150 \\times 10^3$ $\\mathrm{Pa}$.\n  - Domain $L = 1.0$ $\\mathrm{m}$, $N = 51$, smoothing length factor $\\eta = 1.2$.\n  - Final axial strain $\\varepsilon_{\\mathrm{a,final}} = 0.01$, number of steps $n_{\\mathrm{steps}} = 100$.\n\n- Case C (low friction, zero cohesion, coarse resolution):\n  - $E = 80 \\times 10^6$ $\\mathrm{Pa}$, $\\nu = 0.33$, $\\varphi = 10$ $\\mathrm{deg}$, $c = 0$ $\\mathrm{Pa}$, $p_{\\mathrm{c}} = 50 \\times 10^3$ $\\mathrm{Pa}$.\n  - Domain $L = 1.0$ $\\mathrm{m}$, $N = 11$, smoothing length factor $\\eta = 1.0$.\n  - Final axial strain $\\varepsilon_{\\mathrm{a,final}} = 0.015$, number of steps $n_{\\mathrm{steps}} = 150$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[e_A,e_B,e_C]$), where $e_A$, $e_B$, and $e_C$ are the computed $L^2$-type errors $\\mathcal{E}$ in $\\mathrm{kPa}$ for Cases A, B, and C, respectively. No other output is allowed.", "solution": "The problem requires the computation and comparison of two stress paths for a drained axisymmetric triaxial compression test on an elastoplastic material. The material is described by a Drucker–Prager model with associated flow, and the kinematics are defined by small strains. One path, the reference, is computed using an exact, homogeneous axial strain increment. The second path is computed using an axial strain increment that has been perturbed by a factor $\\gamma$, which represents the discretization error of a one-dimensional Smoothed Particle Hydrodynamics (SPH) gradient approximation. The discrepancy between these two paths in the mean stress ($p$) versus deviatoric stress ($q$) plane is quantified by a root-mean-square error metric.\n\nThe solution is implemented via the following sequence of physically-grounded numerical procedures.\n\nFirst, we determine the SPH discretization error factor, $\\gamma$. The problem models this error by considering a one-dimensional bar of length $L$ discretized by $N$ particles. A linear velocity field $v(x) = \\dot{\\varepsilon}_{\\mathrm{a}} x$ is imposed, for which the exact velocity gradient is constant, $\\partial v / \\partial x = \\dot{\\varepsilon}_{\\mathrm{a}}$. The SPH method approximates this gradient at each particle $i$ using a weighted sum over its neighbors $j$:\n$$\n\\left(\\frac{\\partial v}{\\partial x}\\right)_i \\approx \\sum_{j} V_j \\left(v_j - v_i\\right) \\frac{\\partial W(x_i - x_j, h)}{\\partial x_i}\n$$\nHere, $V_j = m_j/\\rho_j$ is the volume of particle $j$, which for a uniform 1D discretization is the particle spacing $\\Delta x = L/(N-1)$. $W$ is the one-dimensional cubic B-spline kernel with smoothing length $h$. The term $\\partial W(x_i-x_j, h)/\\partial x_i$ is the analytical gradient of the kernel. Due to the truncation of the kernel's support near the domain boundaries, the SPH-approximated gradient is not exact. We compute the arithmetic mean of these pointwise gradients over all $N$ particles and define $\\gamma$ as the ratio of this mean SPH gradient to the exact gradient. For simplicity, we set $\\dot{\\varepsilon}_{\\mathrm{a}}=1$, making the exact gradient unity, so $\\gamma$ is simply the mean SPH gradient. This factor $\\gamma$ is computed once for each specific discretization ($N, h$).\n\nSecond, we construct the core constitutive update algorithm. This algorithm must update the stress state from step $n$ to $n+1$ given a prescribed axial strain increment, $\\Delta\\varepsilon_{\\mathrm{a}}$, while maintaining the radial stress, $\\sigma_{\\mathrm{r}}$, at a constant confining pressure, $p_{\\mathrm{c}}$. This is a classic servo-controlled problem in computational geomechanics, which we solve using a nested approach.\n\nThe inner layer is the elastoplastic stress update, or return mapping algorithm, for a given full strain increment tensor $\\Delta \\boldsymbol{\\varepsilon} = \\mathrm{diag}(\\Delta \\varepsilon_{\\mathrm{r}}, \\Delta \\varepsilon_{\\mathrm{r}}, \\Delta \\varepsilon_{\\mathrm{a}})$. This procedure is as follows:\n1.  Compute the elastic trial stress state. The strain increment is decomposed into volumetric, $\\Delta\\varepsilon_{\\mathrm{m}} = \\Delta\\varepsilon_{\\mathrm{a}} + 2\\Delta\\varepsilon_{\\mathrm{r}}$, and deviatoric, $\\Delta\\boldsymbol{\\varepsilon}_{\\mathrm{dev}}$, parts. The trial stress increments are computed using the isotropic elastic laws: $\\Delta p_{\\mathrm{trial}} = K \\Delta\\varepsilon_{\\mathrm{m}}$ and $\\Delta \\boldsymbol{s}_{\\mathrm{trial}} = 2G \\Delta\\boldsymbol{\\varepsilon}_{\\mathrm{dev}}$. The trial stress state in $(p,q)$ space is then $(p_{\\mathrm{trial}}, q_{\\mathrm{trial}}) = (p^n + \\Delta p_{\\mathrm{trial}}, q^n + \\Delta q_{\\mathrm{trial}})$. For axisymmetry, $\\Delta q_{\\mathrm{trial}} = 2G(\\Delta \\varepsilon_{\\mathrm{a}} - \\Delta \\varepsilon_{\\mathrm{r}})$.\n2.  Check for plastic yielding. The trial state is inserted into the Drucker–Prager yield function: $f_{\\mathrm{trial}} = q_{\\mathrm{trial}} + \\alpha p_{\\mathrm{trial}} - k$. If $f_{\\mathrm{trial}} \\le 0$, the step is purely elastic, and the final stress state is the trial state: $(p^{n+1}, q^{n+1}) = (p_{\\mathrm{trial}}, q_{\\mathrm{trial}})$.\n3.  If $f_{\\mathrm{trial}} > 0$, plastic deformation occurs. The stress state must be \"returned\" to the yield surface. For the associated flow rule, the plastic multiplier increment, $\\Delta\\lambda$, is found by enforcing the consistency condition $f(p^{n+1}, q^{n+1}) = 0$. This yields:\n    $$\n    \\Delta\\lambda = \\frac{f_{\\mathrm{trial}}}{3G + \\alpha^2 K}\n    $$\n    where $K$ and $G$ are the bulk and shear moduli. The final, corrected stress invariants are then updated as:\n    $$\n    p^{n+1} = p_{\\mathrm{trial}} - \\alpha K \\Delta\\lambda\n    $$\n    $$\n    q^{n+1} = q_{\\mathrm{trial}} - 3G \\Delta\\lambda\n    $$\n4.  Finally, the updated axial and radial stress components, $\\sigma_{\\mathrm{a}}^{n+1}$ and $\\sigma_{\\mathrm{r}}^{n+1}$, are reconstructed from the invariants $p^{n+1}$ and $q^{n+1}$ using the axisymmetric relations: $\\sigma_{\\mathrm{a}} = p + 2q/3$ and $\\sigma_{\\mathrm{r}} = p - q/3$.\n\nThe outer layer is the servo-control mechanism. The radial strain increment $\\Delta\\varepsilon_{\\mathrm{r}}$ is unknown. It must be determined such that the final radial stress $\\sigma_{\\mathrm{r}}^{n+1}$ equals the target confining pressure $p_{\\mathrm{c}}$. This defines a root-finding problem for the residual function $R(\\Delta\\varepsilon_{\\mathrm{r}}) = \\sigma_{\\mathrm{r}}^{n+1}(\\Delta\\varepsilon_{\\mathrm{r}}) - p_{\\mathrm{c}}$, where $\\sigma_{\\mathrm{r}}^{n+1}(\\Delta\\varepsilon_{\\mathrm{r}})$ is computed using the full elastoplastic update described above. We solve $R(\\Delta\\varepsilon_{\\mathrm{r}}) = 0$ using Newton's method:\n$$\n\\Delta\\varepsilon_{\\mathrm{r}}^{(k+1)} = \\Delta\\varepsilon_{\\mathrm{r}}^{(k)} - \\frac{R(\\Delta\\varepsilon_{\\mathrm{r}}^{(k)})}{R'(\\Delta\\varepsilon_{\\mathrm{r}}^{(k)})}\n$$\nThe derivative $R'(\\Delta\\varepsilon_{\\mathrm{r}})$ is robustly approximated using a central finite difference scheme. An initial guess for $\\Delta\\varepsilon_{\\mathrm{r}}$ is derived from the purely elastic solution to the constraint.\n\nThird, the main simulation loop is executed for $n_{\\mathrm{steps}}$. Starting from an isotropic stress state $(\\sigma_{\\mathrm{a}}^0, \\sigma_{\\mathrm{r}}^0) = (p_{\\mathrm{c}}, p_{\\mathrm{c}})$, two parallel simulations are run:\n-   **Reference Path:** At each step, the exact axial strain increment $\\Delta\\varepsilon_{\\mathrm{a}} = \\varepsilon_{\\mathrm{a,final}}/n_{\\mathrm{steps}}$ is applied. The servo-control algorithm is called to find the corresponding $\\Delta\\varepsilon_{\\mathrm{r}}$ and update the stresses. The resulting $(p,q)$ point is stored.\n-   **SPH-based Path:** The same procedure is followed, but using the perturbed axial strain increment $\\Delta\\varepsilon_{\\mathrm{a}}^{\\mathrm{SPH}} = \\gamma \\Delta\\varepsilon_{\\mathrm{a}}$.\n\nFinally, after completing all $M = n_{\\mathrm{steps}} + 1$ points for both paths (including the initial state), the discrepancy is calculated using the specified $L^2$-type error formula, which measures the root-mean-square of the Euclidean distances between corresponding points of the two paths in the $(p,q)$ plane:\n$$\n\\mathcal{E} = \\sqrt{\\frac{1}{M} \\sum_{k=0}^{M-1} \\left[ \\left(p_k^{\\mathrm{SPH}} - p_k^{\\mathrm{ref}}\\right)^2 + \\left(q_k^{\\mathrm{SPH}} - q_k^{\\mathrm{ref}}\\right)^2 \\right]}\n$$\nThe final result is reported in kilopascals (kPa). This entire process is repeated for each of the three test cases provided.", "answer": "```python\nimport numpy as np\n\ndef cubic_spline_derivative(r, h):\n    \"\"\"\n    Computes the derivative of the 1D cubic B-spline kernel with respect to\n    the spatial coordinate difference r.\n    This corresponds to dW/dx_i for W(x_i - x_j, h).\n    \"\"\"\n    s = np.abs(r) / h\n    val = 0.0\n    alpha_d = 2.0 / 3.0  # Normalization constant for 1D cubic spline\n\n    # Kernel has support up to 2h\n    if 0 <= s < 1:\n        # Derivative of (1 - 1.5*s^2 + 0.75*s^3) w.r.t s is (-3*s + 2.25*s^2)\n        # However, the problem statement relies on a standard formulation which\n        # often uses powers of 2 in denominators for coefficients.\n        # d/ds (1 - 3/2 s^2 + 3/4 s^3) -> -3s + 9/4 s^2\n        val = -3.0 * s + (9.0 / 4.0) * s**2\n    elif 1 <= s < 2:\n        # d/ds (1/4 * (2-s)^3) -> -3/4 * (2-s)^2\n        val = - (3.0 / 4.0) * (2.0 - s)**2\n    \n    # dW/dx = (dW/ds) * (ds/dx) = (dW/ds) * sgn(r)/h\n    # The term we need is dW/dr, which is used in dW/dx_i = (dW/dr_ij) * (dr_ij/dx_i) = dW/dr_ij\n    # So we want dW/dr = (1/h^2) * (dW/ds) * sgn(r)\n    return alpha_d / h**2 * val * np.sign(r)\n\ndef calculate_sph_gamma(L, N, h):\n    \"\"\"\n    Calculates the SPH error factor gamma by comparing the SPH-estimated gradient\n    of a linear velocity field to its exact value (1.0).\n    \"\"\"\n    dx = L / (N - 1)\n    positions = np.linspace(0, L, N)\n    velocities = positions  # Corresponds to a linear field v(x)=x with unit gradient\n\n    grad_v_sph = np.zeros(N)\n    for i in range(N):\n        sum_grad = 0.0\n        for j in range(N):\n            r_ij = positions[i] - positions[j]\n            # Kernel support is 2h\n            if np.abs(r_ij) < 2 * h:\n                # Volume of particle j is dx\n                v_ij = velocities[j] - velocities[i]\n                # The formula uses dW(xi - xj, h)/dx, interpreted as dW/dx_i\n                dW_dx = cubic_spline_derivative(r_ij, h)\n                sum_grad += dx * v_ij * dW_dx\n        # The SPH formula has a negative sign in some texts.\n        # dv/dx_i = sum_j V_j (v_j - v_i) dW_ij/dx_i is a standard form. Let's use it.\n        # This form is often used for pressure gradients, which has a negative sign.\n        # Let's check the result. For v=x, v_j-v_i = x_j-x_i = -r_ij.\n        # dW/dx is an odd function. The integrand is (x_j-x_i)*dW/dx which is positive.\n        # So we get positive gradient. Correct.\n        grad_v_sph[i] = sum_grad\n\n    gamma = np.mean(grad_v_sph)\n    return gamma\n\ndef update_stress(sigma_a_n, sigma_r_n, delta_eps_a, delta_eps_r, K, G, alpha, k):\n    \"\"\"\n    Performs an elastoplastic stress update for a single step using the\n    Drucker-Prager model with associated flow.\n    \"\"\"\n    delta_eps_m = delta_eps_a + 2 * delta_eps_r\n\n    p_n = (sigma_a_n + 2 * sigma_r_n) / 3.0\n    # In compression, sigma_a > sigma_r, so q is non-negative\n    q_n = sigma_a_n - sigma_r_n\n\n    # Elastic trial step\n    p_trial = p_n + K * delta_eps_m\n    q_trial = q_n + 2 * G * (delta_eps_a - delta_eps_r)\n\n    f_trial = q_trial + alpha * p_trial - k\n\n    if f_trial <= 0:  # Elastic step\n        p_np1 = p_trial\n        q_np1 = q_trial\n    else:  # Plastic step (return mapping)\n        denominator = 3 * G + alpha**2 * K\n        delta_lambda = f_trial / denominator if denominator > 1e-12 else 0.0\n        \n        p_np1 = p_trial - alpha * K * delta_lambda\n        q_np1 = q_trial - 3 * G * delta_lambda\n        \n        # Ensure q is not negative due to numerical precision\n        q_np1 = max(0.0, q_np1)\n    \n    # Reconstruct stress components\n    sigma_a_np1 = p_np1 + (2.0/3.0) * q_np1\n    sigma_r_np1 = p_np1 - (1.0/3.0) * q_np1\n    \n    return sigma_a_np1, sigma_r_np1\n\ndef newton_solver(f, x0, jac_f, tol=1e-9, max_iter=20):\n    \"\"\"A simple Newton-Raphson solver.\"\"\"\n    x = x0\n    for _ in range(max_iter):\n        fx = f(x)\n        if abs(fx) < tol:\n            return x\n        jfx = jac_f(x)\n        if abs(jfx) < 1e-12:\n            return x  # Jacobian is zero, may not converge further\n        x = x - fx / jfx\n    return x\n\ndef solve_for_case(params):\n    \"\"\"\n    Main solver for a single test case.\n    \"\"\"\n    E, nu, phi_deg, c, pc, L, N, eta, eps_a_final, n_steps = params\n\n    phi_rad = np.radians(phi_deg)\n    K = E / (3.0 * (1.0 - 2.0 * nu))\n    G = E / (2.0 * (1.0 + nu))\n\n    sin_phi = np.sin(phi_rad)\n    cos_phi = np.cos(phi_rad)\n    denom_dp = np.sqrt(3.0) * (3.0 - sin_phi)\n    alpha = (2.0 * sin_phi) / denom_dp\n    k = (6.0 * c * cos_phi) / denom_dp\n\n    dx = L / (N - 1)\n    h = eta * dx\n    gamma = calculate_sph_gamma(L, N, h)\n\n    delta_eps_a_ref = eps_a_final / n_steps\n    delta_eps_a_sph = gamma * delta_eps_a_ref\n\n    path_ref = np.zeros((n_steps + 1, 2))\n    path_sph = np.zeros((n_steps + 1, 2))\n\n    sigma_a_ref, sigma_r_ref = pc, pc\n    sigma_a_sph, sigma_r_sph = pc, pc\n    path_ref[0] = [pc, 0.0]\n    path_sph[0] = [pc, 0.0]\n    \n    for i in range(n_steps):\n        # Reference Path Calculation\n        sigma_a_n_ref, sigma_r_n_ref = sigma_a_ref, sigma_r_ref\n        \n        def R_ref(delta_eps_r):\n            _, updated_sigma_r = update_stress(sigma_a_n_ref, sigma_r_n_ref, delta_eps_a_ref, delta_eps_r, K, G, alpha, k)\n            return updated_sigma_r - pc\n\n        def jac_R_ref(delta_eps_r):\n            pert = 1e-8 * (abs(delta_eps_r) + 1.0)\n            return (R_ref(delta_eps_r + pert) - R_ref(delta_eps_r)) / pert\n\n        num_guess = pc - sigma_r_n_ref - (K - 2*G/3)*delta_eps_a_ref\n        den_guess = 2*K + 2*G/3\n        delta_eps_r_guess_ref = num_guess / den_guess if abs(den_guess) > 1e-9 else 0.0\n        \n        delta_eps_r_sol_ref = newton_solver(R_ref, delta_eps_r_guess_ref, jac_R_ref, tol=1e-8)\n        sigma_a_ref, sigma_r_ref = update_stress(sigma_a_n_ref, sigma_r_n_ref, delta_eps_a_ref, delta_eps_r_sol_ref, K, G, alpha, k)\n        \n        p_ref = (sigma_a_ref + 2 * sigma_r_ref) / 3.0\n        q_ref = sigma_a_ref - sigma_r_ref\n        path_ref[i+1] = [p_ref, q_ref]\n\n        # SPH Path Calculation\n        sigma_a_n_sph, sigma_r_n_sph = sigma_a_sph, sigma_r_sph\n        \n        def R_sph(delta_eps_r):\n            _, updated_sigma_r = update_stress(sigma_a_n_sph, sigma_r_n_sph, delta_eps_a_sph, delta_eps_r, K, G, alpha, k)\n            return updated_sigma_r - pc\n            \n        def jac_R_sph(delta_eps_r):\n            pert = 1e-8 * (abs(delta_eps_r) + 1.0)\n            return (R_sph(delta_eps_r + pert) - R_sph(delta_eps_r)) / pert\n\n        num_guess = pc - sigma_r_n_sph - (K - 2*G/3)*delta_eps_a_sph\n        den_guess = 2*K + 2*G/3\n        delta_eps_r_guess_sph = num_guess / den_guess if abs(den_guess) > 1e-9 else 0.0\n\n        delta_eps_r_sol_sph = newton_solver(R_sph, delta_eps_r_guess_sph, jac_R_sph, tol=1e-8)\n        sigma_a_sph, sigma_r_sph = update_stress(sigma_a_n_sph, sigma_r_n_sph, delta_eps_a_sph, delta_eps_r_sol_sph, K, G, alpha, k)\n\n        p_sph = (sigma_a_sph + 2 * sigma_r_sph) / 3.0\n        q_sph = sigma_a_sph - sigma_r_sph\n        path_sph[i+1] = [p_sph, q_sph]\n\n    diff = path_sph - path_ref\n    squared_errors = np.sum(diff**2, axis=1)\n    mean_squared_error = np.mean(squared_errors)\n    rms_error = np.sqrt(mean_squared_error)\n    \n    return rms_error / 1000.0\n\ndef solve():\n    test_cases = [\n        # Case A: E, nu, phi, c, pc, L, N, eta, eps_a_final, n_steps\n        (100e6, 0.3, 30.0, 30e3, 100e3, 1.0, 21, 1.2, 0.02, 200),\n        # Case B\n        (50e6, 0.2, 0.0, 500e3, 150e3, 1.0, 51, 1.2, 0.01, 100),\n        # Case C\n        (80e6, 0.33, 10.0, 0.0, 50e3, 1.0, 11, 1.0, 0.015, 150),\n    ]\n\n    results = []\n    for case in test_cases:\n        error = solve_for_case(case)\n        results.append(error)\n\n    print(f\"[{','.join(f'{r:.7f}' for r in results)}]\")\n\nsolve()\n```", "id": "3543179"}, {"introduction": "A key advantage of meshfree methods is their suitability for adaptive analysis, where resolution can be dynamically adjusted to capture localized phenomena. This final exercise guides you through the design of an adaptive particle refinement algorithm for SPH, driven by the local magnitude of the strain gradient [@problem_id:3543233]. By implementing both particle splitting and merging routines, you will not only create a more efficient simulation tool but also learn the critical importance of ensuring that fundamental physical laws, like the conservation of mass and momentum, are strictly upheld across refinement events.", "problem": "Consider a one-dimensional Smoothed Particle Hydrodynamics (SPH) discretization of a bar of length $L$ with uniform mass density $\\rho$ and cross-sectional area $A$. Let the particle positions be $x_i$ in meters, masses $m_i$ in kilograms, velocities $v_i$ in meters per second, smoothing lengths $h_i$ in meters, and displacements $u_i$ in meters. Under small-strain kinematics, the axial strain is defined as $\\epsilon = \\partial u / \\partial x$ and the strain gradient magnitude is $\\|\\nabla \\epsilon\\| = |\\partial^2 u / \\partial x^2|$, measured in inverse meters.\n\nYou must design and implement an adaptive particle refinement algorithm that inserts and deletes particles based on the strain gradient magnitude $\\|\\nabla \\epsilon\\|$. The algorithm must obey the following requirements:\n\n- Use the one-dimensional cubic spline kernel for SPH. Define $q = |r|/h$ for separation $r = x_i - x_j$ and smoothing length $h$, and let\n$$\nW(r,h) = \\frac{\\sigma}{h}\n\\begin{cases}\n1 - \\frac{3}{2}q^2 + \\frac{3}{4}q^3, & 0 \\le q < 1, \\\\\n\\frac{1}{4}(2 - q)^3, & 1 \\le q < 2, \\\\\n0, & q \\ge 2,\n\\end{cases}\n$$\nwith $\\sigma = \\frac{2}{3}$ in one dimension. Its spatial derivative with respect to $x_i$ is\n$$\n\\frac{\\partial W(r,h)}{\\partial x_i} = \\frac{\\sigma}{h^2}\\,\\text{sign}(r)\\,\n\\begin{cases}\n-3q + \\frac{9}{4}q^2, & 0 \\le q < 1, \\\\\n-\\frac{3}{4}(2 - q)^2, & 1 \\le q < 2, \\\\\n0, & q \\ge 2,\n\\end{cases}\n$$\nwhere $\\text{sign}(r)$ is $+1$ if $r > 0$, $-1$ if $r < 0$, and $0$ if $r = 0$.\n\n- Approximate gradients via the SPH difference formulation. For a scalar field $A(x)$ with particle values $A_i$, use\n$$\n\\left.\\frac{\\partial A}{\\partial x}\\right|_{i} \\approx \\sum_{j=1}^{N} \\frac{m_j}{\\rho_j}\\left(A_j - A_i\\right)\\,\\frac{\\partial W(r_{ij},h_{ij})}{\\partial x_i},\n$$\nwhere $r_{ij} = x_i - x_j$ and $h_{ij} = \\frac{1}{2}(h_i + h_j)$. Assume uniform density $\\rho_j = \\rho$ for all $j$.\n\n- Define the strain at particle $i$ as $\\epsilon_i \\approx \\left.\\frac{\\partial u}{\\partial x}\\right|_i$ and the strain gradient magnitude as $g_i = \\left|\\left.\\frac{\\partial \\epsilon}{\\partial x}\\right|_i\\right|$.\n\n- Define the local spacing $s_i$ at particle $i$ as the minimum distance to its nearest neighbor in meters.\n\n- Adaptive refinement rules:\n  1. Insertion (splitting): If $g_i > g_{\\text{insert}}$ and $s_i > s_{\\min}$, replace particle $i$ by two children located at $x_i \\pm \\delta$ with $\\delta = s_i/4$, each having mass $m_i/2$, velocity $v_i$, displacement $u_i$, and smoothing length $h_i/2$.\n  2. Deletion (merging): For consecutive particles $i$ and $i+1$, if both satisfy $g_i  g_{\\text{delete}}$ and $g_{i+1}  g_{\\text{delete}}$ and their spacing $s_{i,i+1} = |x_{i+1} - x_i|$ satisfies $s_{i,i+1}  s_{\\max}$, merge them into one particle with mass $m_i + m_{i+1}$, position $x = \\frac{m_i x_i + m_{i+1} x_{i+1}}{m_i + m_{i+1}}$, velocity $v = \\frac{m_i v_i + m_{i+1} v_{i+1}}{m_i + m_{i+1}}$, displacement $u = \\frac{m_i u_i + m_{i+1} u_{i+1}}{m_i + m_{i+1}}$, and smoothing length $h = \\frac{1}{2}(h_i + h_{i+1})$.\n\n- Conservation evaluation: Compute the total mass $M = \\sum_i m_i$ in kilograms and the total linear momentum $P = \\sum_i m_i v_i$ in kilogram-meter per second immediately before and immediately after refinement. Report the absolute differences $\\Delta M = |M_{\\text{after}} - M_{\\text{before}}|$ in kilograms and $\\Delta P = |P_{\\text{after}} - P_{\\text{before}}|$ in kilogram-meter per second.\n\nYour program must implement the above using the following test suite, where all lengths are in meters, density in kilograms per cubic meter, area in square meters, velocities in meters per second, and strain gradients in inverse meters:\n\n- Test case 1 (happy path):\n  - Domain length $L = 1.0$.\n  - Initial particle count $N_0 = 41$ with uniform spacing.\n  - Density $\\rho = 2000$.\n  - Cross-sectional area $A = 0.01$.\n  - Smoothing length factor $\\kappa = 1.2$ so that $h_i = \\kappa \\Delta x$ initially.\n  - Displacement field $u(x) = 0.01 \\sin(\\pi x)$.\n  - Velocity field $v(x) = 0.1 x$.\n  - Insertion threshold $g_{\\text{insert}} = 0.05$.\n  - Deletion threshold $g_{\\text{delete}} = 0.01$.\n  - Minimum spacing for insertion $s_{\\min} = 0.020$.\n  - Maximum spacing for deletion $s_{\\max} = 0.030$.\n\n- Test case 2 (no refinement boundary):\n  - Same $L$, $N_0$, $\\rho$, $A$, $\\kappa$, $u(x)$, and $v(x)$ as Test case 1.\n  - Insertion threshold $g_{\\text{insert}} = 1.0$ (too high to trigger).\n  - Deletion threshold $g_{\\text{delete}} = 0.0$ (no particle satisfies strictly less).\n  - $s_{\\min} = 0.020$.\n  - $s_{\\max} = 0.030$.\n\n- Test case 3 (aggressive insertion edge case):\n  - Domain length $L = 1.0$.\n  - Initial particle count $N_0 = 21$ with uniform spacing.\n  - Density $\\rho = 2000$.\n  - Cross-sectional area $A = 0.01$.\n  - Smoothing length factor $\\kappa = 1.2$ so that $h_i = \\kappa \\Delta x$ initially.\n  - Displacement field $u(x) = 0.05 \\sin(\\pi x)$.\n  - Velocity field $v(x) = 0.2 x$.\n  - Insertion threshold $g_{\\text{insert}} = 0.20$.\n  - Deletion threshold $g_{\\text{delete}} = 0.02$.\n  - Minimum spacing for insertion $s_{\\min} = 0.040$.\n  - Maximum spacing for deletion $s_{\\max} = 0.060$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must be the flattened sequence of the conservation errors for all test cases in the order $\\left[\\Delta M_1,\\Delta P_1,\\Delta M_2,\\Delta P_2,\\Delta M_3,\\Delta P_3\\right]$, with each value a floating-point number in SI units (kilograms for mass and kilogram-meter per second for momentum).", "solution": "The problem requires the design and implementation of a one-dimensional adaptive particle refinement algorithm for Smoothed Particle Hydrodynamics (SPH). The solution is developed by following a structured, principle-based approach. The core of the solution is an algorithm that modifies a set of SPH particles through insertion (splitting) and deletion (merging) based on local strain gradient magnitudes.\n\nFirst, an initial state is established for each test case. A set of $N_0$ particles is uniformly distributed along a one-dimensional domain of length $L$. The initial particle spacing is $\\Delta x = L / (N_0 - 1)$. Each particle $i$ is assigned properties:\n-   Position: $x_i = i \\cdot \\Delta x$, for $i = 0, 1, \\dots, N_0-1$.\n-   Mass: $m_i = (\\rho A L) / N_0$, where $\\rho$ is density and $A$ is the cross-sectional area.\n-   Velocity: $v_i = v(x_i)$, from the given velocity field.\n-   Displacement: $u_i = u(x_i)$, from the given displacement field.\n-   Smoothing length: $h_i = \\kappa \\Delta x$, where $\\kappa$ is a given factor.\n\nThe total mass $M_{\\text{before}} = \\sum_i m_i$ and total linear momentum $P_{\\text{before}} = \\sum_i m_i v_i$ are calculated for this initial configuration to serve as a baseline for conservation checks.\n\nThe refinement process hinges on SPH approximations of spatial derivatives. The specified SPH difference formula is used to compute two successive gradients. First, the axial strain $\\epsilon_i$ at each particle is calculated by applying the gradient operator to the displacement field $u$:\n$$\n\\epsilon_i = \\left.\\frac{\\partial u}{\\partial x}\\right|_{i} \\approx \\sum_{j} \\frac{m_j}{\\rho}\\left(u_j - u_i\\right)\\,\\frac{\\partial W(r_{ij},h_{ij})}{\\partial x_i}\n$$\nwhere the sum is over all other particles $j$, $r_{ij} = x_i - x_j$, and $h_{ij} = \\frac{1}{2}(h_i + h_j)$. The kernel derivative $\\frac{\\partial W}{\\partial x_i}$ is implemented precisely as defined, using the provided cubic spline function and its derivative.\n\nSecond, the same gradient operator is applied to the computed strain field $\\epsilon$ to find the strain gradient at each particle. The strain gradient magnitude $g_i$ is then the absolute value:\n$$\ng_i = \\left| \\left.\\frac{\\partial \\epsilon}{\\partial x}\\right|_{i} \\right| \\approx \\left| \\sum_{j} \\frac{m_j}{\\rho}\\left(\\epsilon_j - \\epsilon_i\\right)\\,\\frac{\\partial W(r_{ij},h_{ij})}{\\partial x_i} \\right|\n$$\nAdditionally, the local spacing $s_i$ for each particle is determined as the minimum distance to its nearest neighbor. For a 1D particle set sorted by position, this is $\\min(|x_i - x_{i-1}|, |x_{i+1} - x_i|)$.\n\nThe adaptive refinement algorithm proceeds in two sequential stages:\n\n1.  **Insertion (Splitting)**: The algorithm iterates through all particles. A particle $i$ is flagged for insertion if its strain gradient magnitude $g_i$ exceeds a threshold $g_{\\text{insert}}$ and its local spacing $s_i$ is greater than a minimum $s_{\\min}$. Each flagged particle is replaced by two new \"child\" particles. Following the problem's rules, a parent particle at position $x_i$ with properties $(m_i, v_i, u_i, h_i)$ is replaced by two children located at $x_i \\pm s_i/4$, each with properties $(m_i/2, v_i, u_i, h_i/2)$. This process conserves mass and linear momentum.\n\n2.  **Deletion (Merging)**: After the insertion pass, the set of particles is updated and must be re-sorted by position. Since the particle distribution has changed, the SPH quantities ($\\epsilon_i$, $g_i$) are recomputed for this new configuration. The algorithm then iterates through consecutive pairs of particles $(i, i+1)$. A pair is merged if both particles satisfy $g_i  g_{\\text{delete}}$ and $g_{i+1}  g_{\\text{delete}}$, and their mutual spacing $|x_{i+1} - x_i|$ is less than a maximum $s_{\\max}$. The two particles are replaced by a single new particle whose properties (mass, position, velocity, displacement) are determined by formulas that conserve total mass and linear momentum. The new smoothing length is the average of the two original smoothing lengths. A `while` loop is used to process the sorted particles to correctly handle consecutive merges.\n\nFinally, after both stages are complete, the total mass $M_{\\text{after}}$ and total linear momentum $P_{\\text{after}}$ of the final particle set are calculated. The absolute differences, $\\Delta M = |M_{\\text{after}} - M_{\\text{before}}|$ and $\\Delta P = |P_{\\text{after}} - P_{\\text{before}}|$, are computed. Due to the conservative nature of the splitting and merging rules, these differences are expected to be zero, or a very small number attributable to floating-point precision errors. This serves as a validation of the implementation. The algorithm is applied to each of the three specified test cases, and the resulting values of $\\Delta M$ and $\\Delta P$ are collected for the final output.", "answer": "```python\nimport numpy as np\n\ndef W(r, h):\n    \"\"\"\n    Computes the 1D cubic spline SPH kernel value.\n    \"\"\"\n    sigma = 2.0 / 3.0\n    if h = 0:\n        return 0.0\n    q = abs(r) / h\n    if q = 2.0:\n        return 0.0\n    \n    val = 0.0\n    if q  1.0:\n        val = 1.0 - 1.5 * q**2 + 0.75 * q**3\n    elif q  2.0:\n        val = 0.25 * (2.0 - q)**3\n    \n    return (sigma / h) * val\n\ndef dW_dx(r, h):\n    \"\"\"\n    Computes the derivative of the 1D cubic spline SPH kernel.\n    \"\"\"\n    sigma = 2.0 / 3.0\n    if h = 0:\n        return 0.0\n    q = abs(r) / h\n    sign_r = np.sign(r)\n    \n    if q = 2.0:\n        return 0.0\n\n    derivative_q = 0.0\n    if q  1.0:\n        derivative_q = -3.0 * q + 2.25 * q**2\n    elif q  2.0:\n        derivative_q = -0.75 * (2.0 - q)**2\n    \n    return (sigma / h**2) * sign_r * derivative_q\n\ndef compute_sph_properties(particles, rho):\n    \"\"\"\n    Computes strains, strain gradients, and local spacings for a particle set.\n    \"\"\"\n    n = len(particles)\n    if n == 0:\n        return [], [], []\n\n    strains = np.zeros(n)\n    grads = np.zeros(n)\n    spacings = np.zeros(n)\n    \n    # Store particle properties in arrays for faster access\n    pos = np.array([p['x'] for p in particles])\n    mass = np.array([p['m'] for p in particles])\n    disp = np.array([p['u'] for p in particles])\n    smooth = np.array([p['h'] for p in particles])\n\n    # Compute strains\n    for i in range(n):\n        sum_val = 0.0\n        for j in range(n):\n            if i == j:\n                continue\n            r_ij = pos[i] - pos[j]\n            h_ij = 0.5 * (smooth[i] + smooth[j])\n            grad_W = dW_dx(r_ij, h_ij)\n            sum_val += (mass[j] / rho) * (disp[j] - disp[i]) * grad_W\n        strains[i] = sum_val\n\n    # Compute strain gradients\n    for i in range(n):\n        sum_val = 0.0\n        for j in range(n):\n            if i == j:\n                continue\n            r_ij = pos[i] - pos[j]\n            h_ij = 0.5 * (smooth[i] + smooth[j])\n            grad_W = dW_dx(r_ij, h_ij)\n            sum_val += (mass[j] / rho) * (strains[j] - strains[i]) * grad_W\n        grads[i] = abs(sum_val)\n\n    # Compute spacings (assumes particles are sorted by position)\n    if n  1:\n        spacings[0] = abs(pos[1] - pos[0])\n        spacings[n-1] = abs(pos[n-1] - pos[n-2])\n        for i in range(1, n - 1):\n            spacings[i] = min(abs(pos[i] - pos[i-1]), abs(pos[i+1] - pos[i]))\n    \n    return strains, grads, spacings\n\ndef run_refinement_cycle(initial_particles, params, rho):\n    \"\"\"\n    Performs one full cycle of insertion and deletion.\n    \"\"\"\n    # --- INSERTION ---\n    if not initial_particles:\n        return []\n\n    strains, grads, spacings = compute_sph_properties(initial_particles, rho)\n    \n    particles_to_split = []\n    for i in range(len(initial_particles)):\n        if grads[i]  params['g_insert'] and spacings[i]  params['s_min']:\n            particles_to_split.append(i)\n\n    particles_after_split = []\n    split_indices = set(particles_to_split)\n    for i, p in enumerate(initial_particles):\n        if i in split_indices:\n            delta = spacings[i] / 4.0\n            \n            child1 = {\n                'x': p['x'] - delta, 'm': p['m'] / 2.0, 'v': p['v'], \n                'u': p['u'], 'h': p['h'] / 2.0\n            }\n            child2 = {\n                'x': p['x'] + delta, 'm': p['m'] / 2.0, 'v': p['v'],\n                'u': p['u'], 'h': p['h'] / 2.0\n            }\n            particles_after_split.extend([child1, child2])\n        else:\n            particles_after_split.append(p)\n\n    particles_after_split.sort(key=lambda p: p['x'])\n    \n    # --- DELETION ---\n    if len(particles_after_split)  2:\n        return particles_after_split\n\n    strains, grads, spacings = compute_sph_properties(particles_after_split, rho)\n\n    final_particles = []\n    i = 0\n    n = len(particles_after_split)\n    while i  n:\n        can_merge = False\n        if i  n - 1:\n            g_i = grads[i]\n            g_j = grads[i+1]\n            s_ij = abs(particles_after_split[i+1]['x'] - particles_after_split[i]['x'])\n            if g_i  params['g_delete'] and g_j  params['g_delete'] and s_ij  params['s_max']:\n                can_merge = True\n\n        if can_merge:\n            p_i = particles_after_split[i]\n            p_j = particles_after_split[i+1]\n            m_total = p_i['m'] + p_j['m']\n            \n            merged_particle = {\n                'm': m_total,\n                'x': (p_i['m'] * p_i['x'] + p_j['m'] * p_j['x']) / m_total,\n                'v': (p_i['m'] * p_i['v'] + p_j['m'] * p_j['v']) / m_total,\n                'u': (p_i['m'] * p_i['u'] + p_j['m'] * p_j['u']) / m_total,\n                'h': 0.5 * (p_i['h'] + p_j['h'])\n            }\n            final_particles.append(merged_particle)\n            i += 2\n        else:\n            final_particles.append(particles_after_split[i])\n            i += 1\n            \n    return final_particles\n\n\ndef solve():\n    test_cases = [\n        { # Test Case 1\n            'L': 1.0, 'N0': 41, 'rho': 2000, 'A': 0.01, 'kappa': 1.2,\n            'u_func': lambda x: 0.01 * np.sin(np.pi * x),\n            'v_func': lambda x: 0.1 * x,\n            'g_insert': 0.05, 'g_delete': 0.01,\n            's_min': 0.020, 's_max': 0.030,\n        },\n        { # Test Case 2\n            'L': 1.0, 'N0': 41, 'rho': 2000, 'A': 0.01, 'kappa': 1.2,\n            'u_func': lambda x: 0.01 * np.sin(np.pi * x),\n            'v_func': lambda x: 0.1 * x,\n            'g_insert': 1.0, 'g_delete': 0.0,\n            's_min': 0.020, 's_max': 0.030,\n        },\n        { # Test Case 3\n            'L': 1.0, 'N0': 21, 'rho': 2000, 'A': 0.01, 'kappa': 1.2,\n            'u_func': lambda x: 0.05 * np.sin(np.pi * x),\n            'v_func': lambda x: 0.2 * x,\n            'g_insert': 0.20, 'g_delete': 0.02,\n            's_min': 0.040, 's_max': 0.060,\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Initial particle setup\n        L, N0, rho, A = case['L'], case['N0'], case['rho'], case['A']\n        delta_x = L / (N0 - 1)\n        total_mass = rho * A * L\n        particle_mass = total_mass / N0\n        h0 = case['kappa'] * delta_x\n\n        initial_particles = []\n        for i in range(N0):\n            x_i = i * delta_x\n            initial_particles.append({\n                'x': x_i,\n                'm': particle_mass,\n                'v': case['v_func'](x_i),\n                'u': case['u_func'](x_i),\n                'h': h0,\n            })\n            \n        m_before = sum(p['m'] for p in initial_particles)\n        p_before = sum(p['m'] * p['v'] for p in initial_particles)\n\n        # Run refinement\n        final_particles = run_refinement_cycle(initial_particles, case, rho)\n        \n        m_after = sum(p['m'] for p in final_particles)\n        p_after = sum(p['m'] * p['v'] for p in final_particles)\n        \n        delta_m = abs(m_after - m_before)\n        delta_p = abs(p_after - p_before)\n        \n        results.extend([delta_m, delta_p])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3543233"}]}