{"hands_on_practices": [{"introduction": "To effectively apply numerical methods, we must first understand their fundamental properties, chief among them being accuracy. This practice guides you through a foundational analysis of two workhorse schemes in computational dynamics: the explicit Central Difference method and the implicit Newmark average acceleration scheme. By deriving the local truncation error for each, you will uncover the mathematical reason they are both considered second-order accurate methods, a crucial first step in evaluating their suitability for a given problem [@problem_id:3566460].", "problem": "Consider the undamped single-degree-of-freedom linear oscillator that models, for example, the fundamental mode of a lumped soil mass-spring idealization in computational geomechanics. The governing equation derived from Newton’s second law is\n$$\nm\\,\\ddot{u}(t) + k\\,u(t) = 0,\\quad m>0,\\ k>0,\n$$\nwhere $u(t)$ is the generalized displacement. Define the circular natural frequency by $\\omega^{2} = k/m$ and write the equation in the normalized form\n$$\n\\ddot{u}(t) + \\omega^{2}\\,u(t) = 0.\n$$\nLet $t_{n} = t_{0} + n\\,\\Delta t$ with constant time step $\\Delta t>0$, and set $u_{n} = u(t_{n})$, $v_{n} = \\dot{u}(t_{n})$, $a_{n} = \\ddot{u}(t_{n})$.\n\nTask A (Central Difference (CD) method, explicit). The CD method for the oscillator can be written as\n$$\n\\frac{u_{n+1} - 2\\,u_{n} + u_{n-1}}{\\Delta t^{2}} + \\omega^{2}\\,u_{n} = 0.\n$$\nDefine the local truncation error at $t_{n}$ as the defect\n$$\n\\tau^{\\mathrm{CD}}_{n} := \\frac{u(t_{n+1}) - 2\\,u(t_{n}) + u(t_{n-1})}{\\Delta t^{2}} + \\omega^{2}\\,u(t_{n}),\n$$\nobtained by inserting the exact solution $u(t)$ into the scheme. Using only fundamental Taylor expansions about $t_{n}$ and the governing differential equation, derive the leading nonzero term of $\\tau^{\\mathrm{CD}}_{n}$ in powers of $\\Delta t$.\n\nTask B (Newmark’s average acceleration (AA) scheme, implicit). Newmark’s AA scheme is defined by the pair of update formulas with average acceleration parameters $\\beta = 1/4$ and $\\gamma = 1/2$:\n$$\nu_{n+1} = u_{n} + \\Delta t\\,v_{n} + \\frac{\\Delta t^{2}}{4}\\,\\big(a_{n} + a_{n+1}\\big),\\qquad\nv_{n+1} = v_{n} + \\frac{\\Delta t}{2}\\,\\big(a_{n} + a_{n+1}\\big),\n$$\ntogether with the linear oscillator relation $a_{n} = -\\omega^{2}\\,u_{n}$ and $a_{n+1} = -\\omega^{2}\\,u_{n+1}$. Define the local truncation error at $t_{n}$ as the pair of defects obtained by inserting the exact solution values into these updates:\n$$\n\\tau^{\\mathrm{N}}_{u,n} := u(t_{n+1}) - u(t_{n}) - \\Delta t\\,v(t_{n}) - \\frac{\\Delta t^{2}}{4}\\,\\big(a(t_{n}) + a(t_{n+1})\\big),\n$$\n$$\n\\tau^{\\mathrm{N}}_{v,n} := v(t_{n+1}) - v(t_{n}) - \\frac{\\Delta t}{2}\\,\\big(a(t_{n}) + a(t_{n+1})\\big).\n$$\nUsing only fundamental Taylor expansions about $t_{n}$ and the governing differential equation, derive the leading nonzero terms of $\\tau^{\\mathrm{N}}_{u,n}$ and $\\tau^{\\mathrm{N}}_{v,n}$ in powers of $\\Delta t$.\n\nTask C (Global orders of accuracy). Using the consistency orders revealed by the local truncation errors and the known zero-stability of both schemes for the linear oscillator, conclude the global orders of accuracy in $u(t)$ for the CD method and for Newmark’s AA scheme. Express the final answer as a row matrix containing the two global orders of accuracy for displacement, in the order [CD, Newmark AA]. No units are required for the final answer. If you need to state any numerical constants during derivations, keep them in exact rational form. The final answer must be a single row matrix of two integers.", "solution": "The problem is subjected to validation prior to any attempt at a solution.\n\n### Step 1: Extract Givens\n-   **Governing Equation**: $m\\,\\ddot{u}(t) + k\\,u(t) = 0$, with mass $m>0$ and stiffness $k>0$.\n-   **Normalized Form**: $\\ddot{u}(t) + \\omega^{2}\\,u(t) = 0$, where the circular natural frequency is $\\omega = \\sqrt{k/m}$.\n-   **Time Discretization**: $t_{n} = t_{0} + n\\,\\Delta t$ with a constant time step $\\Delta t>0$.\n-   **Discrete Variables**: $u_{n} = u(t_{n})$, $v_{n} = \\dot{u}(t_{n})$, $a_{n} = \\ddot{u}(t_{n})$.\n-   **Task A: Central Difference (CD) Method**:\n    -   Scheme: $\\frac{u_{n+1} - 2\\,u_{n} + u_{n-1}}{\\Delta t^{2}} + \\omega^{2}\\,u_{n} = 0$.\n    -   Local Truncation Error (LTE): $\\tau^{\\mathrm{CD}}_{n} := \\frac{u(t_{n+1}) - 2\\,u(t_{n}) + u(t_{n-1})}{\\Delta t^{2}} + \\omega^{2}\\,u(t_{n})$.\n    -   Objective: Derive the leading nonzero term of $\\tau^{\\mathrm{CD}}_{n}$.\n-   **Task B: Newmark’s Average Acceleration (AA) Scheme**:\n    -   Parameters: $\\beta = 1/4$, $\\gamma = 1/2$.\n    -   Update formulas:\n        $u_{n+1} = u_{n} + \\Delta t\\,v_{n} + \\frac{\\Delta t^{2}}{4}\\,\\big(a_{n} + a_{n+1}\\big)$\n        $v_{n+1} = v_{n} + \\frac{\\Delta t}{2}\\,\\big(a_{n} + a_{n+1}\\big)$\n    -   Enforcement of governing equation: $a_{n} = -\\omega^{2}\\,u_{n}$ and $a_{n+1} = -\\omega^{2}\\,u_{n+1}$.\n    -   Local Truncation Errors (LTEs):\n        $\\tau^{\\mathrm{N}}_{u,n} := u(t_{n+1}) - u(t_{n}) - \\Delta t\\,v(t_{n}) - \\frac{\\Delta t^{2}}{4}\\,\\big(a(t_{n}) + a(t_{n+1})\\big)$\n        $\\tau^{\\mathrm{N}}_{v,n} := v(t_{n+1}) - v(t_{n}) - \\frac{\\Delta t}{2}\\,\\big(a(t_{n}) + a(t_{n+1})\\big)$\n    -   Objective: Derive the leading nonzero terms of $\\tau^{\\mathrm{N}}_{u,n}$ and $\\tau^{\\mathrm{N}}_{v,n}$.\n-   **Task C: Global Orders of Accuracy**:\n    -   Premise: Both schemes are known to be zero-stable.\n    -   Objective: Using the consistency orders from Tasks A and B, determine the global orders of accuracy for the displacement $u(t)$ for both the CD method and the Newmark AA scheme.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is well-defined and scientifically sound.\n-   **Scientifically Grounded**: The problem addresses the analysis of standard, widely used time integration schemes (Central Difference and Newmark) for the linear oscillator, a fundamental model in physics and engineering. The methods and concepts are cornerstones of computational dynamics.\n-   **Well-Posed**: The tasks are specific and mathematical, requiring derivations based on Taylor series expansions and interpretation of standard numerical analysis theory. The problem has a unique and meaningful solution.\n-   **Objective**: The problem is stated in precise mathematical language, free from ambiguity or subjective content.\n-   **Complete and Consistent**: All necessary equations, definitions, and conditions are provided. There are no internal contradictions.\n\n### Step 3: Verdict and Action\nThe problem is valid. A full solution will be provided.\n\n### Solution Derivations\n\nThe solution requires evaluating the local truncation errors (LTEs) by substituting the exact solution $u(t)$ of the governing differential equation, $\\ddot{u}(t) + \\omega^2 u(t) = 0$, into the numerical schemes. The derivatives of the exact solution are related by: $\\ddot{u}(t) = -\\omega^2 u(t)$, $\\dddot{u}(t) = -\\omega^2 \\dot{u}(t)$, $u^{(4)}(t) = -\\omega^2 \\ddot{u}(t) = \\omega^4 u(t)$, and so on.\n\n**Task A: Local Truncation Error of the Central Difference (CD) Method**\n\nThe LTE for the CD method is given by:\n$$\n\\tau^{\\mathrm{CD}}_{n} = \\frac{u(t_{n+1}) - 2\\,u(t_{n}) + u(t_{n-1})}{\\Delta t^{2}} + \\omega^{2}\\,u(t_{n})\n$$\nWe perform Taylor series expansions of $u(t_{n+1})$ and $u(t_{n-1})$ about the time $t_{n}$. For brevity, let $u_{n} = u(t_{n})$, $\\dot{u}_{n} = \\dot{u}(t_{n})$, etc.\n$$\nu(t_{n+1}) = u_{n} + \\Delta t\\,\\dot{u}_{n} + \\frac{\\Delta t^2}{2!}\\,\\ddot{u}_{n} + \\frac{\\Delta t^3}{3!}\\,\\dddot{u}_{n} + \\frac{\\Delta t^4}{4!}\\,u^{(4)}_{n} + O(\\Delta t^5)\n$$\n$$\nu(t_{n-1}) = u_{n} - \\Delta t\\,\\dot{u}_{n} + \\frac{\\Delta t^2}{2!}\\,\\ddot{u}_{n} - \\frac{\\Delta t^3}{3!}\\,\\dddot{u}_{n} + \\frac{\\Delta t^4}{4!}\\,u^{(4)}_{n} - O(\\Delta t^5)\n$$\nSubstituting these into the numerator of the first term of $\\tau^{\\mathrm{CD}}_{n}$:\n$$\nu(t_{n+1}) - 2\\,u_{n} + u(t_{n-1}) = \\left(2\\,\\frac{\\Delta t^2}{2!}\\,\\ddot{u}_{n}\\right) + \\left(2\\,\\frac{\\Delta t^4}{4!}\\,u^{(4)}_{n}\\right) + O(\\Delta t^6)\n$$\n$$\nu(t_{n+1}) - 2\\,u_{n} + u(t_{n-1}) = \\Delta t^2\\,\\ddot{u}_{n} + \\frac{\\Delta t^4}{12}\\,u^{(4)}_{n} + O(\\Delta t^6)\n$$\nNow, substitute this back into the expression for $\\tau^{\\mathrm{CD}}_{n}$:\n$$\n\\tau^{\\mathrm{CD}}_{n} = \\frac{\\Delta t^2\\,\\ddot{u}_{n} + \\frac{\\Delta t^4}{12}\\,u^{(4)}_{n} + O(\\Delta t^6)}{\\Delta t^2} + \\omega^{2}\\,u_{n}\n$$\n$$\n\\tau^{\\mathrm{CD}}_{n} = \\left(\\ddot{u}_{n} + \\frac{\\Delta t^2}{12}\\,u^{(4)}_{n} + O(\\Delta t^4)\\right) + \\omega^{2}\\,u_{n}\n$$\nRearranging the terms to group the governing equation:\n$$\n\\tau^{\\mathrm{CD}}_{n} = \\big(\\ddot{u}_{n} + \\omega^{2}\\,u_{n}\\big) + \\frac{\\Delta t^2}{12}\\,u^{(4)}_{n} + O(\\Delta t^4)\n$$\nSince $u(t)$ is the exact solution, $\\ddot{u}_{n} + \\omega^2 u_{n} = 0$. Thus, the expression simplifies to:\n$$\n\\tau^{\\mathrm{CD}}_{n} = \\frac{\\Delta t^2}{12}\\,u^{(4)}_{n} + O(\\Delta t^4)\n$$\nThe leading nonzero term of the local truncation error is $\\frac{\\Delta t^2}{12}\\,u^{(4)}(t_{n})$.\n\n**Task B: Local Truncation Errors of the Newmark AA Scheme**\n\nWe derive the LTEs for the displacement and velocity updates separately.\n\nFor the displacement update, the LTE is:\n$$\n\\tau^{\\mathrm{N}}_{u,n} = u(t_{n+1}) - u(t_{n}) - \\Delta t\\,v(t_{n}) - \\frac{\\Delta t^{2}}{4}\\,\\big(a(t_{n}) + a(t_{n+1})\\big)\n$$\nWe use Taylor expansions for $u(t_{n+1})$ and $a(t_{n+1})$ about $t_{n}$. We recall that $v_n=\\dot{u}_n$, $a_n=\\ddot{u}_n$, $\\dot{a}_n=\\dddot{u}_n$.\n$$\nu(t_{n+1}) = u_{n} + \\Delta t\\,\\dot{u}_{n} + \\frac{\\Delta t^2}{2}\\,\\ddot{u}_{n} + \\frac{\\Delta t^3}{6}\\,\\dddot{u}_{n} + O(\\Delta t^4)\n$$\n$$\na(t_{n+1}) = a_{n} + \\Delta t\\,\\dot{a}_{n} + O(\\Delta t^2)\n$$\nSubstituting these into the expression for $\\tau^{\\mathrm{N}}_{u,n}$:\n$$\n\\tau^{\\mathrm{N}}_{u,n} = \\left(u_{n} + \\Delta t\\,\\dot{u}_{n} + \\frac{\\Delta t^2}{2}\\,\\ddot{u}_{n} + \\frac{\\Delta t^3}{6}\\,\\dddot{u}_{n} + \\dots\\right) - u_{n} - \\Delta t\\,\\dot{u}_{n} - \\frac{\\Delta t^2}{4}\\,\\big(a_{n} + (a_{n} + \\Delta t\\,\\dot{a}_{n} + \\dots)\\big)\n$$\nRecognizing that $\\dot{u}_n=v_n$ and $\\ddot{u}_n=a_n$, we simplify:\n$$\n\\tau^{\\mathrm{N}}_{u,n} = \\left(\\frac{\\Delta t^2}{2}\\,a_{n} + \\frac{\\Delta t^3}{6}\\,\\dot{a}_{n} + \\dots\\right) - \\frac{\\Delta t^2}{4}\\,\\big(2\\,a_{n} + \\Delta t\\,\\dot{a}_{n} + \\dots\\big)\n$$\n$$\n\\tau^{\\mathrm{N}}_{u,n} = \\left(\\frac{\\Delta t^2}{2}\\,a_{n} + \\frac{\\Delta t^3}{6}\\,\\dot{a}_{n}\\right) - \\left(\\frac{\\Delta t^2}{2}\\,a_{n} + \\frac{\\Delta t^3}{4}\\,\\dot{a}_{n}\\right) + O(\\Delta t^4)\n$$\n$$\n\\tau^{\\mathrm{N}}_{u,n} = \\left(\\frac{1}{6} - \\frac{1}{4}\\right)\\Delta t^3\\,\\dot{a}_{n} + O(\\Delta t^4) = -\\frac{1}{12}\\,\\dot{a}_{n}\\,\\Delta t^3 + O(\\Delta t^4)\n$$\nThe leading term is $-\\frac{1}{12}\\,\\dddot{u}(t_{n})\\,\\Delta t^3$.\n\nFor the velocity update, the LTE is:\n$$\n\\tau^{\\mathrm{N}}_{v,n} = v(t_{n+1}) - v(t_{n}) - \\frac{\\Delta t}{2}\\,\\big(a(t_{n}) + a(t_{n+1})\\big)\n$$\nWe use Taylor expansions for $v(t_{n+1})$ and $a(t_{n+1})$ about $t_n$. We recall $\\dot{v}_n=a_n$, $\\ddot{v}_n=\\dot{a}_n$, $\\dddot{v}_n=\\ddot{a}_n$.\n$$\nv(t_{n+1}) = v_{n} + \\Delta t\\,\\dot{v}_{n} + \\frac{\\Delta t^2}{2}\\,\\ddot{v}_{n} + \\frac{\\Delta t^3}{6}\\,\\dddot{v}_{n} + O(\\Delta t^4)\n$$\n$$\na(t_{n+1}) = a_{n} + \\Delta t\\,\\dot{a}_{n} + \\frac{\\Delta t^2}{2}\\,\\ddot{a}_{n} + O(\\Delta t^3)\n$$\nSubstituting these into the expression for $\\tau^{\\mathrm{N}}_{v,n}$:\n$$\n\\tau^{\\mathrm{N}}_{v,n} = \\left(v_{n} + \\Delta t a_{n} + \\frac{\\Delta t^2}{2}\\,\\dot{a}_{n} + \\frac{\\Delta t^3}{6}\\,\\ddot{a}_{n} + \\dots\\right) - v_{n} - \\frac{\\Delta t}{2}\\,\\big(a_{n} + (a_{n} + \\Delta t\\,\\dot{a}_{n} + \\frac{\\Delta t^2}{2}\\,\\ddot{a}_{n} + \\dots)\\big)\n$$\n$$\n\\tau^{\\mathrm{N}}_{v,n} = \\left(\\Delta t a_{n} + \\frac{\\Delta t^2}{2}\\,\\dot{a}_{n} + \\frac{\\Delta t^3}{6}\\,\\ddot{a}_{n}\\right) - \\frac{\\Delta t}{2}\\,\\big(2\\,a_{n} + \\Delta t\\,\\dot{a}_{n} + \\frac{\\Delta t^2}{2}\\,\\ddot{a}_{n}\\big) + O(\\Delta t^4)\n$$\n$$\n\\tau^{\\mathrm{N}}_{v,n} = \\left(\\Delta t a_{n} + \\frac{\\Delta t^2}{2}\\,\\dot{a}_{n} + \\frac{\\Delta t^3}{6}\\,\\ddot{a}_{n}\\right) - \\left(\\Delta t a_{n} + \\frac{\\Delta t^2}{2}\\,\\dot{a}_{n} + \\frac{\\Delta t^3}{4}\\,\\ddot{a}_{n}\\right) + O(\\Delta t^4)\n$$\n$$\n\\tau^{\\mathrm{N}}_{v,n} = \\left(\\frac{1}{6} - \\frac{1}{4}\\right)\\Delta t^3\\,\\ddot{a}_{n} + O(\\Delta t^4) = -\\frac{1}{12}\\,\\ddot{a}_{n}\\,\\Delta t^3 + O(\\Delta t^4)\n$$\nThe leading term is $-\\frac{1}{12}\\,u^{(4)}(t_{n})\\,\\Delta t^3$.\n\n**Task C: Global Orders of Accuracy**\n\nThe global order of accuracy of a numerical method is its order of convergence. For a zero-stable method, the order of convergence is equal to its order of consistency. The problem states both schemes are zero-stable.\n\nFor the Central Difference method, the LTE is defined as the residual when the exact solution is substituted into the discretized differential equation: $\\tau^{\\mathrm{CD}}_n = O(\\Delta t^p)$ implies a consistency order of $p$. From Task A, we found $\\tau^{\\mathrm{CD}}_n = O(\\Delta t^2)$. Thus, the consistency order is $p=2$. The global order of accuracy for the CD method is therefore $2$.\n\nFor the Newmark AA method, a one-step scheme for the state vector $[u, v]^T$, the LTEs $\\tau^{\\mathrm{N}}_{u,n}$ and $\\tau^{\\mathrm{N}}_{v,n}$ represent the error accumulated in a single step (the one-step error). A one-step method is said to be consistent of order $p$ if its one-step error is of order $O(\\Delta t^{p+1})$. From Task B, the LTEs for both displacement and velocity are $O(\\Delta t^3)$. This means $p+1=3$, which implies a consistency order of $p=2$. The global order of accuracy for the Newmark AA scheme is therefore $2$.\n\nBoth methods exhibit a global order of accuracy of $2$ for the displacement $u(t)$. The final answer is a row matrix containing these two orders.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2 & 2\n\\end{pmatrix}\n}\n$$", "id": "3566460"}, {"introduction": "Theoretical accuracy has tangible consequences. This exercise transitions from pure analysis to the practical implications of numerical error in wave propagation problems, a cornerstone of dynamic geomechanics. You will investigate how the local truncation errors derived previously manifest as numerical dispersion (phase error) and dissipation (amplitude error), altering the speed and intensity of traveling waves in a simulated elastic bar [@problem_id:3566418]. This hands-on coding task illuminates the direct link between the choice of a time-stepping scheme and the physical fidelity of the simulation results.", "problem": "A uniform, prismatic, one-dimensional linear elastic bar of cross-sectional area $A$ is governed by the linear momentum balance and Hooke’s law in one dimension, which together yield the scalar wave equation $\\rho \\frac{\\partial^2 u}{\\partial t^2} = E \\frac{\\partial^2 u}{\\partial x^2}$ for displacement $u(x,t)$, where $\\rho$ is the mass density and $E$ is the Young’s modulus. Consider a periodic domain of length $L$ discretized by a uniform mesh of $N$ linear finite elements of size $h=L/N$ with a consistent mass matrix. Let the semi-discrete equations be written as $M\\,\\ddot{\\mathbf{u}}(t) + K\\,\\mathbf{u}(t) = \\mathbf{0}$. Under a short-duration impact, the response may be represented as a superposition of spatial Fourier modes; focus on a single monochromatic mode with integer index $m$ whose wavenumber is $k = 2\\pi m/L$. Assume a mode-ansatz at the nodes, $U_j \\propto e^{i j q}$ with $q = k h = 2 \\pi m / N$, to reduce the semi-discrete system along that mode to a scalar modal oscillator of the form $\\ddot{u}_m(t) + \\omega_h^2\\,u_m(t)=0$, where $\\omega_h$ is the semi-discrete angular frequency induced by the spatial discretization. Use the following fundamental bases: the wave equation, the standard consistent mass and stiffness matrices for a two-node linear element, and the periodicity ansatz. For time integration, consider the Central Difference scheme (explicit) and the Newmark Average Acceleration scheme (implicit) applied to the modal equation. Without appealing to any pre-quoted dispersion or amplification formulas, derive from first principles, for each time-integration scheme, the numerical angular frequency and the per-step amplification factor for the undamped modal oscillator. From these, define the temporal phase speed relative error and the amplitude error for the chosen mode as follows:\n- The temporal phase speed relative error is $(\\omega_{\\text{num}}/\\omega_h)-1$, where $\\omega_{\\text{num}}$ is the numerical angular frequency produced by the time-integration scheme for the modal oscillator with exact semi-discrete angular frequency $\\omega_h$.\n- The amplitude error is the magnitude of the one-step amplification factor minus $1$, i.e., $|g|-1$, where $g$ is the one-step amplification factor for the scheme applied to the modal oscillator.\n\nThroughout, all trigonometric function arguments must be in radians. Express all physical parameters in International System of Units (SI). The final numerical answers for the errors are dimensionless and must be returned as floating-point numbers.\n\nTest suite and required output:\nFor each of the following three test cases, treat the spatial mesh and time step as fixed for the comparison across the two time-integration schemes. For each case, compute the semi-discrete angular frequency $\\omega_h$ of the selected mode from the spatial discretization, then compute the temporal phase speed relative error and the amplitude error for both the Central Difference and Newmark Average Acceleration schemes. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as\n[phase_error_central_difference_case1, amplitude_error_central_difference_case1, phase_error_newmark_average_acceleration_case1, amplitude_error_newmark_average_acceleration_case1, phase_error_central_difference_case2, amplitude_error_central_difference_case2, phase_error_newmark_average_acceleration_case2, amplitude_error_newmark_average_acceleration_case2, phase_error_central_difference_case3, amplitude_error_central_difference_case3, phase_error_newmark_average_acceleration_case3, amplitude_error_newmark_average_acceleration_case3]\nEach entry must be a float in decimal form.\n\nUse the following data for each test case:\n- Case 1 (happy path): $E = 70\\times 10^9\\,\\mathrm{Pa}$, $\\rho = 2700\\,\\mathrm{kg/m^3}$, $N=100$, $h = 0.02\\,\\mathrm{m}$, $m=3$, $\\Delta t = 8.0\\times 10^{-6}\\,\\mathrm{s}$.\n- Case 2 (near explicit stability boundary): $E = 70\\times 10^9\\,\\mathrm{Pa}$, $\\rho = 2700\\,\\mathrm{kg/m^3}$, $N=100$, $h = 0.02\\,\\mathrm{m}$, $m=20$, $\\Delta t = 5.8336\\times 10^{-6}\\,\\mathrm{s}$.\n- Case 3 (small time step edge case): $E = 30\\times 10^9\\,\\mathrm{Pa}$, $\\rho = 2000\\,\\mathrm{kg/m^3}$, $N=100$, $h = 0.02\\,\\mathrm{m}$, $m=1$, $\\Delta t = 1.0\\times 10^{-7}\\,\\mathrm{s}$.\n\nNotes and requirements:\n- Take the wave speed as $c = \\sqrt{E/\\rho}$.\n- Use the consistent mass linear finite element dispersion obtained by modal reduction on the uniform mesh to compute $\\omega_h$ for the mode with wavenumber $k=2\\pi m/L$, where $L = N h$. Do not assume any lumped-mass simplification.\n- Angles for trigonometric and inverse trigonometric functions must be in radians.\n- The final program must not require any user input and must print only the single-line result in the exact format described above.", "solution": "The problem is valid. It is scientifically grounded, well-posed, and objective. It provides a complete set of data and definitions to derive a unique solution based on established principles of computational mechanics, specifically the finite element method and temporal discretization schemes.\n\nThe objective is to derive, from first principles, the numerical angular frequency and amplification factor for two time integration schemes (Central Difference and Newmark Average Acceleration) applied to a semi-discretized one-dimensional wave equation. These will be used to calculate temporal phase speed and amplitude errors for specific test cases.\n\n### 1. Semi-Discrete Modal Equation and Angular Frequency ($\\omega_h$)\n\nThe governing partial differential equation for the one-dimensional elastic bar is the wave equation:\n$$\n\\rho \\frac{\\partial^2 u}{\\partial t^2} = E \\frac{\\partial^2 u}{\\partial x^2}\n$$\nwhere $\\rho$ is the mass density, $E$ is Young's modulus, and $u(x,t)$ is the axial displacement.\n\nWe discretize a periodic domain of length $L$ with $N$ linear finite elements of size $h = L/N$. For a single two-node element, the stiffness matrix $K_e$ and consistent mass matrix $M_e$ are:\n$$\nK_e = \\frac{AE}{h} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}, \\quad M_e = \\frac{\\rho A h}{6} \\begin{pmatrix} 2 & 1 \\\\ 1 & 2 \\end{pmatrix}\n$$\nwhere $A$ is the cross-sectional area.\n\nThe semi-discrete system of equations is $M\\ddot{\\mathbf{u}} + K\\mathbf{u} = \\mathbf{0}$. For a generic interior node $j$ on a uniform periodic mesh, assembling contributions from adjacent elements $(j-1, j)$ and $(j, j+1)$ yields the equation:\n$$\n\\frac{\\rho A h}{6}(\\ddot{U}_{j-1} + 4\\ddot{U}_j + \\ddot{U}_{j+1}) + \\frac{AE}{h}(-U_{j-1} + 2U_j - U_{j+1}) = 0\n$$\nwhere $U_j(t)$ is the displacement of node $j$.\n\nWe substitute the modal ansatz for a single Fourier mode with integer index $m$, $U_j(t) = u_m(t)e^{ijq}$, where $u_m(t)$ is the time-dependent modal amplitude and $q = kh = (2\\pi m/L)h = 2\\pi m/N$ is the dimensionless wavenumber. This gives $\\ddot{U}_j(t) = \\ddot{u}_m(t)e^{ijq}$. Substituting into the nodal equation and dividing by the common factor $Ae^{ijq}$ gives:\n$$\n\\frac{\\rho h}{6}\\ddot{u}_m(t)(e^{-iq} + 4 + e^{iq}) + \\frac{E}{h}u_m(t)(-e^{-iq} + 2 - e^{iq}) = 0\n$$\nUsing Euler's identity $e^{i\\theta} + e^{-i\\theta} = 2\\cos\\theta$:\n$$\n\\frac{\\rho h}{6}\\ddot{u}_m(t)(2\\cos q + 4) + \\frac{E}{h}u_m(t)(-2\\cos q + 2) = 0\n$$\nRearranging gives the scalar modal oscillator equation $\\ddot{u}_m(t) + \\omega_h^2 u_m(t) = 0$, where $\\omega_h^2$ is the squared semi-discrete angular frequency:\n$$\n\\omega_h^2 = \\frac{2E/h(1 - \\cos q)}{\\rho h/3(2 + \\cos q)} = \\frac{6E}{\\rho h^2} \\frac{1 - \\cos q}{2 + \\cos q}\n$$\nDefining the wave speed $c = \\sqrt{E/\\rho}$, the semi-discrete angular frequency $\\omega_h$ is:\n$$\n\\omega_h = \\frac{c}{h} \\sqrt{6 \\frac{1 - \\cos(2\\pi m/N)}{2 + \\cos(2\\pi m/N)}}\n$$\n\n### 2. Analysis of the Central Difference Scheme\n\nThe Central Difference scheme applied to the modal equation $\\ddot{u} + \\omega_h^2 u = 0$ is:\n$$\n\\frac{u^{n+1} - 2u^n + u^{n-1}}{\\Delta t^2} + \\omega_h^2 u^n = 0\n$$\nwhere $u^n = u_m(n\\Delta t)$. We seek a solution of the form $u^n = g^n u^0$, where $g$ is the one-step amplification factor. Substituting this yields the characteristic equation for $g$:\n$$\ng^2 - (2 - \\omega_h^2 \\Delta t^2)g + 1 = 0\n$$\nLet $\\Omega = \\omega_h \\Delta t$. The equation is $g^2 - (2-\\Omega^2)g + 1 = 0$. The roots are:\n$$\ng = \\frac{(2-\\Omega^2) \\pm \\sqrt{(2-\\Omega^2)^2 - 4}}{2} = 1 - \\frac{\\Omega^2}{2} \\pm \\sqrt{\\left(1-\\frac{\\Omega^2}{2}\\right)^2 - 1}\n$$\nFor a stable, oscillatory response, the roots must be complex conjugates on the unit circle. This occurs when the discriminant is non-positive, i.e., $(2-\\Omega^2)^2 - 4 \\le 0$, which simplifies to the Courant-Friedrichs-Lewy (CFL) stability condition $\\Omega \\le 2$.\n\n**Amplitude Error:** For $\\Omega \\le 2$, the roots are complex conjugates and their product is $1$, so $|g|=1$. The amplitude error, defined as $|g|-1$, is therefore $0$. All test cases satisfy this condition.\n\n**Temporal Phase Speed Relative Error:** For a stable response, we can write $g = e^{i\\omega_{\\text{num}}\\Delta t} = \\cos(\\omega_{\\text{num}}\\Delta t) + i\\sin(\\omega_{\\text{num}}\\Delta t)$. The sum of the roots is $g+\\bar{g} = 2\\Re(g) = 2\\cos(\\omega_{\\text{num}}\\Delta t)$. From Vieta's formulas on the characteristic equation, the sum of roots is $2-\\Omega^2$. Thus:\n$$\n2\\cos(\\omega_{\\text{num}}\\Delta t) = 2 - \\Omega^2 \\implies \\cos(\\omega_{\\text{num}}\\Delta t) = 1 - \\frac{\\Omega^2}{2}\n$$\nThe numerical angular frequency is $\\omega_{\\text{num}} = \\frac{1}{\\Delta t}\\arccos\\left(1 - \\frac{(\\omega_h\\Delta t)^2}{2}\\right)$. The phase error is:\n$$\n\\left(\\frac{\\omega_{\\text{num}}}{\\omega_h}\\right) - 1 = \\frac{1}{\\omega_h\\Delta t}\\arccos\\left(1 - \\frac{(\\omega_h\\Delta t)^2}{2}\\right) - 1\n$$\n\n### 3. Analysis of the Newmark Average Acceleration Scheme\n\nThis implicit scheme ($\\beta=1/4, \\gamma=1/2$) applied to $\\ddot{u} + \\omega_h^2 u = 0$ is unconditionally stable. The one-step amplification factor $g$ can be found by analyzing the amplification matrix of the system. A more direct approach yields the complex amplification factor:\n$$\ng = \\frac{1 - (\\omega_h\\Delta t)^2/4}{1 + (\\omega_h\\Delta t)^2/4} + i \\frac{\\omega_h\\Delta t}{1 + (\\omega_h\\Delta t)^2/4}\n$$\n\n**Amplitude Error:** The magnitude of $g$ is:\n$$\n|g|^2 = \\frac{(1-\\Omega^2/4)^2 + \\Omega^2}{(1+\\Omega^2/4)^2} = \\frac{1 - \\Omega^2/2 + \\Omega^4/16 + \\Omega^2}{1 + \\Omega^2/2 + \\Omega^4/16} = \\frac{1 + \\Omega^2/2 + \\Omega^4/16}{1 + \\Omega^2/2 + \\Omega^4/16} = 1\n$$\nThus, $|g|=1$ for all values of $\\Omega$, confirming unconditional stability. The amplitude error is $|g|-1 = 0$.\n\n**Temporal Phase Speed Relative Error:** We relate $g$ to $\\omega_{\\text{num}}$ via $g = e^{i\\omega_{\\text{num}}\\Delta t}$. A convenient relation involves the half-angle tangent:\n$$\n\\tan\\left(\\frac{\\omega_{\\text{num}}\\Delta t}{2}\\right) = \\frac{\\sin(\\omega_{\\text{num}}\\Delta t)}{1+\\cos(\\omega_{\\text{num}}\\Delta t)} = \\frac{\\Im(g)}{1+\\Re(g)}\n$$\nSubstituting the real and imaginary parts of $g$:\n$$\n\\tan\\left(\\frac{\\omega_{\\text{num}}\\Delta t}{2}\\right) = \\frac{\\Omega/(1+\\Omega^2/4)}{1 + (1-\\Omega^2/4)/(1+\\Omega^2/4)} = \\frac{\\Omega}{1+\\Omega^2/4 + 1-\\Omega^2/4} = \\frac{\\Omega}{2}\n$$\nThe numerical angular frequency is $\\omega_{\\text{num}} = \\frac{2}{\\Delta t}\\arctan\\left(\\frac{\\omega_h\\Delta t}{2}\\right)$. The phase error is:\n$$\n\\left(\\frac{\\omega_{\\text{num}}}{\\omega_h}\\right) - 1 = \\frac{2}{\\omega_h\\Delta t}\\arctan\\left(\\frac{\\omega_h\\Delta t}{2}\\right) - 1\n$$\n\n### 4. Summary of Calculations for Test Cases\nFor each test case $(E, \\rho, N, h, m, \\Delta t)$:\n1. Calculate $c = \\sqrt{E/\\rho}$.\n2. Calculate $\\omega_h = \\frac{c}{h} \\sqrt{6 \\frac{1 - \\cos(2\\pi m/N)}{2 + \\cos(2\\pi m/N)}}$.\n3. Calculate $\\Omega = \\omega_h \\Delta t$.\n4. Central Difference Errors:\n   - Amplitude Error: $0.0$\n   - Phase Error: $\\frac{1}{\\Omega}\\arccos(1 - \\Omega^2/2) - 1$\n5. Newmark Average Acceleration Errors:\n   - Amplitude Error: $0.0$\n   - Phase Error: $\\frac{2}{\\Omega}\\arctan(\\Omega/2) - 1$", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the phase and amplitude errors for Central Difference and\n    Newmark Average Acceleration schemes for given test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (happy path)\n        {'E': 70e9, 'rho': 2700, 'N': 100, 'h': 0.02, 'm': 3, 'dt': 8.0e-6},\n        # Case 2 (near explicit stability boundary)\n        {'E': 70e9, 'rho': 2700, 'N': 100, 'h': 0.02, 'm': 20, 'dt': 5.8336e-6},\n        # Case 3 (small time step edge case)\n        {'E': 30e9, 'rho': 2000, 'N': 100, 'h': 0.02, 'm': 1, 'dt': 1.0e-7},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        E = case['E']\n        rho = case['rho']\n        N = case['N']\n        h = case['h']\n        m = case['m']\n        dt = case['dt']\n\n        # 1. Calculate semi-discrete angular frequency (omega_h)\n        c = np.sqrt(E / rho)\n        q = 2 * np.pi * m / N\n        \n        # This is the derived formula for omega_h squared\n        omega_h_sq = (6 * c**2 / h**2) * (1 - np.cos(q)) / (2 + np.cos(q))\n        omega_h = np.sqrt(omega_h_sq)\n\n        # Dimensionless time step\n        Omega = omega_h * dt\n\n        # 2. Central Difference (Explicit) Scheme Analysis\n        # Amplitude error is 0 for stable cases (Omega <= 2)\n        # All test cases are designed to be stable.\n        amp_err_cd = 0.0\n        \n        # Phase speed relative error\n        # Formula: (arccos(1 - Omega^2/2) / Omega) - 1\n        # np.arccos expects argument in [-1, 1]. All cases satisfy this.\n        phase_err_cd = np.arccos(1 - Omega**2 / 2) / Omega - 1\n\n        # 3. Newmark Average Acceleration (Implicit) Scheme Analysis\n        # Amplitude error is 0 unconditionally\n        amp_err_naa = 0.0\n\n        # Phase speed relative error\n        # Formula: (2 * arctan(Omega/2) / Omega) - 1\n        phase_err_naa = (2 / Omega) * np.arctan(Omega / 2) - 1\n        \n        results.extend([phase_err_cd, amp_err_cd, phase_err_naa, amp_err_naa])\n\n    # Format the output as a single comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3566418"}, {"introduction": "The true power of implicit methods is realized when tackling the nonlinear problems that dominate real-world geomechanics. This final practice moves into this advanced domain, addressing the implementation of an implicit Newmark scheme for a system with a nonlinear material response. You will formulate and implement the Newton-Raphson iterative procedure, deriving the essential consistent Jacobian matrix that ensures rapid and robust convergence [@problem_id:3566474]. Mastering this process is fundamental to developing or using modern nonlinear finite element software.", "problem": "Consider a single-degree-of-freedom dynamic system representative of a lumped geomechanical discretization, governed by the strong form of linear momentum balance,\n$$\nm\\,\\ddot{u}(t) + c\\,\\dot{u}(t) + f_{\\mathrm{int}}(u(t)) = f_{\\mathrm{ext}}(t),\n$$\nwhere $m$ is the mass, $c$ is the viscous damping coefficient, $u(t)$ is the displacement, $f_{\\mathrm{int}}(u)$ is the nonlinear internal force due to the material response, and $f_{\\mathrm{ext}}(t)$ is the prescribed external force. Assume a nonlinear material response characterized by a scalar potential leading to an internal force\n$$\nf_{\\mathrm{int}}(u) = k\\,u + \\alpha\\,u^3,\n$$\nwith $k > 0$ and $\\alpha \\ge 0$.\n\nDiscretize time using the implicit Newmark family with time step $\\Delta t$, parameters $\\beta$ and $\\gamma$. The kinematic updates are\n$$\nu_{n+1} = u_n + \\Delta t\\,v_n + \\Delta t^2\\left(\\frac{1}{2} - \\beta\\right)a_n + \\beta\\,\\Delta t^2\\,a_{n+1},\n$$\n$$\nv_{n+1} = v_n + \\Delta t\\,(1 - \\gamma)\\,a_n + \\gamma\\,\\Delta t\\,a_{n+1},\n$$\nand the dynamic equilibrium at $t_{n+1}$ is\n$$\nm\\,a_{n+1} + c\\,v_{n+1} + f_{\\mathrm{int}}(u_{n+1}) = f_{\\mathrm{ext}}(t_{n+1}).\n$$\n\nTask 1 (derivation): Starting from linear momentum balance and the implicit Newmark updates, formulate the Newton–Raphson iteration for the unknown vector $\\left[u_{n+1},\\,v_{n+1},\\,a_{n+1}\\right]^\\top$ by writing the residuals\n$$\nR_m(u_{n+1}, v_{n+1}, a_{n+1}) = m\\,a_{n+1} + c\\,v_{n+1} + f_{\\mathrm{int}}(u_{n+1}) - f_{\\mathrm{ext}}(t_{n+1}),\n$$\n$$\nR_v(u_{n+1}, v_{n+1}, a_{n+1}) = v_{n+1} - v_n - \\Delta t\\,(1 - \\gamma)\\,a_n - \\gamma\\,\\Delta t\\,a_{n+1},\n$$\n$$\nR_u(u_{n+1}, v_{n+1}, a_{n+1}) = u_{n+1} - u_n - \\Delta t\\,v_n - \\Delta t^2\\left(\\frac{1}{2} - \\beta\\right)a_n - \\beta\\,\\Delta t^2\\,a_{n+1},\n$$\nand deriving the $3\\times 3$ Jacobian matrix of partial derivatives with respect to $\\left[u_{n+1},\\,v_{n+1},\\,a_{n+1}\\right]^\\top$. Explicitly identify each Jacobian block and show how a consistent linearization yields quadratic convergence.\n\nTask 2 (condensation): Show how to eliminate $v_{n+1}$ and $a_{n+1}$ via the Newmark constraints to obtain a scalar Newton update in $u_{n+1}$ with the effective tangent\n$$\nK_{\\mathrm{eff}}(u_{n+1}) = K_t(u_{n+1}) + a_0\\,m + a_1\\,c,\n$$\nwhere $K_t(u) = \\dfrac{df_{\\mathrm{int}}}{du}(u)$ and $a_0 = \\dfrac{1}{\\beta\\,\\Delta t^2}$, $a_1 = \\dfrac{\\gamma}{\\beta\\,\\Delta t}$. Derive this result directly from the $3\\times 3$ Jacobian via the appropriate Schur complement.\n\nTask 3 (implementation): Implement a Newton–Raphson solver for a single implicit Newmark step that uses the condensed scalar update for $u_{n+1}$, with\n$$\na_{n+1} = \\frac{1}{\\beta\\,\\Delta t^2}\\left(u_{n+1} - u_n - \\Delta t\\,v_n - \\Delta t^2\\left(\\frac{1}{2} - \\beta\\right)a_n\\right),\n$$\n$$\nv_{n+1} = v_n + \\Delta t\\,(1 - \\gamma)\\,a_n + \\gamma\\,\\Delta t\\,a_{n+1},\n$$\nand residual\n$$\nr(u_{n+1}) = m\\,a_{n+1} + c\\,v_{n+1} + f_{\\mathrm{int}}(u_{n+1}) - f_{\\mathrm{ext}}(t_{n+1}),\n$$\nwith update\n$$\n\\Delta u = -\\frac{r(u_{n+1})}{K_{\\mathrm{eff}}(u_{n+1})},\\quad u_{n+1}^{(k+1)} = u_{n+1}^{(k)} + \\Delta u.\n$$\nUse a stopping criterion $\\lvert r(u_{n+1})\\rvert \\le \\varepsilon$ with $\\varepsilon = 10^{-12}$.\n\nAdditionally, construct the full $3\\times 3$ Jacobian and verify numerically that its Schur complement with respect to $u_{n+1}$ matches $K_{\\mathrm{eff}}(u_{n+1})$ to within a specified tolerance. Report this verification as a boolean.\n\nInitialization: Compute $a_n$ from the equilibrium at $t_n$,\n$$\na_n = \\frac{f_{\\mathrm{ext}}(t_n) - c\\,v_n - f_{\\mathrm{int}}(u_n)}{m}.\n$$\n\nTest suite: For each case below, compute $u_{n+1}$ and the Jacobian consistency boolean. Express $u_{n+1}$ in meters as a float.\n\n- Case A (general nonlinear, damped): $m = 1.0\\,\\mathrm{kg}$, $c = 0.05\\,\\mathrm{N\\,s/m}$, $k = 100.0\\,\\mathrm{N/m}$, $\\alpha = 500.0\\,\\mathrm{N/m^3}$, $\\Delta t = 0.01\\,\\mathrm{s}$, $\\beta = 0.25$, $\\gamma = 0.5$, $u_n = 0.01\\,\\mathrm{m}$, $v_n = 0.0\\,\\mathrm{m/s}$, $f_{\\mathrm{ext}}(t_n) = 0.0\\,\\mathrm{N}$, $f_{\\mathrm{ext}}(t_{n+1}) = 1.0\\,\\mathrm{N}$.\n- Case B (undamped): $m = 2.0\\,\\mathrm{kg}$, $c = 0.0\\,\\mathrm{N\\,s/m}$, $k = 200.0\\,\\mathrm{N/m}$, $\\alpha = 1000.0\\,\\mathrm{N/m^3}$, $\\Delta t = 0.01\\,\\mathrm{s}$, $\\beta = 0.25$, $\\gamma = 0.5$, $u_n = 0.0\\,\\mathrm{m}$, $v_n = 0.0\\,\\mathrm{m/s}$, $f_{\\mathrm{ext}}(t_n) = 0.0\\,\\mathrm{N}$, $f_{\\mathrm{ext}}(t_{n+1}) = 0.5\\,\\mathrm{N}$.\n- Case C (small time step): $m = 1.0\\,\\mathrm{kg}$, $c = 0.05\\,\\mathrm{N\\,s/m}$, $k = 100.0\\,\\mathrm{N/m}$, $\\alpha = 500.0\\,\\mathrm{N/m^3}$, $\\Delta t = 0.001\\,\\mathrm{s}$, $\\beta = 0.25$, $\\gamma = 0.5$, $u_n = 0.01\\,\\mathrm{m}$, $v_n = 0.0\\,\\mathrm{m/s}$, $f_{\\mathrm{ext}}(t_n) = 0.0\\,\\mathrm{N}$, $f_{\\mathrm{ext}}(t_{n+1}) = 1.0\\,\\mathrm{N}$.\n- Case D (stiff nonlinear, moderate damping): $m = 0.5\\,\\mathrm{kg}$, $c = 0.2\\,\\mathrm{N\\,s/m}$, $k = 1000.0\\,\\mathrm{N/m}$, $\\alpha = 100000.0\\,\\mathrm{N/m^3}$, $\\Delta t = 0.01\\,\\mathrm{s}$, $\\beta = 0.25$, $\\gamma = 0.5$, $u_n = 0.002\\,\\mathrm{m}$, $v_n = 0.0\\,\\mathrm{m/s}$, $f_{\\mathrm{ext}}(t_n) = 0.0\\,\\mathrm{N}$, $f_{\\mathrm{ext}}(t_{n+1}) = 2.0\\,\\mathrm{N}$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, output two entries: first the converged displacement $u_{n+1}$ in meters as a float, then a boolean indicating whether the condensed effective tangent $K_{\\mathrm{eff}}$ matches the Schur complement of the full Jacobian to within tolerance. For example, an output with four cases should look like\n$$\n[ u_A, \\mathrm{bool}_A, u_B, \\mathrm{bool}_B, u_C, \\mathrm{bool}_C, u_D, \\mathrm{bool}_D ].\n$$", "solution": "The problem requires the formulation and implementation of a numerical solution for a single-degree-of-freedom (SDOF) nonlinear dynamic system. The system's behavior is described by the equation of motion, a second-order nonlinear ordinary differential equation:\n$$\nm\\,\\ddot{u}(t) + c\\,\\dot{u}(t) + f_{\\mathrm{int}}(u(t)) = f_{\\mathrm{ext}}(t)\n$$\nThe nonlinearity stems from the internal force, which is given by a cubic relationship: $f_{\\mathrm{int}}(u) = k\\,u + \\alpha\\,u^3$, characteristic of a Duffing oscillator. The parameters $m$, $c$, $k$, and $\\alpha$ are the mass, damping coefficient, linear stiffness, and nonlinear stiffness, respectively, with $k > 0$ and $\\alpha \\ge 0$.\n\nThe time domain is discretized using the implicit Newmark family of methods. The state of the system at time $t_{n+1} = t_n + \\Delta t$ is determined from the state at $t_n$ using the kinematic update rules for displacement $u_{n+1}$ and velocity $v_{n+1}$:\n$$\nu_{n+1} = u_n + \\Delta t\\,v_n + \\Delta t^2\\left(\\frac{1}{2} - \\beta\\right)a_n + \\beta\\,\\Delta t^2\\,a_{n+1}\n$$\n$$\nv_{n+1} = v_n + \\Delta t\\,(1 - \\gamma)\\,a_n + \\gamma\\,\\Delta t\\,a_{n+1}\n$$\nand the enforcement of dynamic equilibrium at time $t_{n+1}$:\n$$\nm\\,a_{n+1} + c\\,v_{n+1} + f_{\\mathrm{int}}(u_{n+1}) = f_{\\mathrm{ext}}(t_{n+1})\n$$\nSince these equations are implicit and nonlinear in the unknowns $u_{n+1}$, $v_{n+1}$, and $a_{n+1}$, an iterative numerical scheme such as the Newton-Raphson method is required to find the solution at each time step.\n\n### Task 1: Full System Newton-Raphson Formulation\n\nThe Newton-Raphson method solves a system of nonlinear equations $\\mathbf{R}(\\mathbf{x}) = \\mathbf{0}$ by iteratively finding corrections $\\Delta \\mathbf{x}$ to a guess $\\mathbf{x}^{(k)}$ from the linear system $\\mathbf{J}(\\mathbf{x}^{(k)}) \\Delta \\mathbf{x} = -\\mathbf{R}(\\mathbf{x}^{(k)})$, where $\\mathbf{J}$ is the Jacobian matrix of $\\mathbf{R}$.\n\nFor our problem, the vector of unknowns at time $t_{n+1}$ is $\\mathbf{x}_{n+1} = \\left[u_{n+1}, v_{n+1}, a_{n+1}\\right]^\\top$. The system of equations is formed by the three residual functions provided:\n$$\nR_m(u_{n+1}, v_{n+1}, a_{n+1}) = m\\,a_{n+1} + c\\,v_{n+1} + f_{\\mathrm{int}}(u_{n+1}) - f_{\\mathrm{ext}}(t_{n+1}) = 0\n$$\n$$\nR_v(u_{n+1}, v_{n+1}, a_{n+1}) = v_{n+1} - v_n - \\Delta t\\,(1 - \\gamma)\\,a_n - \\gamma\\,\\Delta t\\,a_{n+1} = 0\n$$\n$$\nR_u(u_{n+1}, v_{n+1}, a_{n+1}) = u_{n+1} - u_n - \\Delta t\\,v_n - \\Delta t^2\\left(\\frac{1}{2} - \\beta\\right)a_n - \\beta\\,\\Delta t^2\\,a_{n+1} = 0\n$$\nThe Jacobian matrix $\\mathbf{J}$ is the matrix of partial derivatives of the residual vector $\\mathbf{R} = [R_m, R_v, R_u]^\\top$ with respect to the unknown vector $\\mathbf{x}_{n+1}$. The components $J_{ij}$ are given by $J_{ij} = \\partial R_i / \\partial x_j$.\n\nThe required partial derivatives are:\n- For $R_m$:\n  - $\\frac{\\partial R_m}{\\partial u_{n+1}} = \\frac{d}{du_{n+1}}f_{\\mathrm{int}}(u_{n+1}) = K_t(u_{n+1}) = k + 3\\alpha u_{n+1}^2$\n  - $\\frac{\\partial R_m}{\\partial v_{n+1}} = c$\n  - $\\frac{\\partial R_m}{\\partial a_{n+1}} = m$\n- For $R_v$:\n  - $\\frac{\\partial R_v}{\\partial u_{n+1}} = 0$\n  - $\\frac{\\partial R_v}{\\partial v_{n+1}} = 1$\n  - $\\frac{\\partial R_v}{\\partial a_{n+1}} = -\\gamma\\,\\Delta t$\n- For $R_u$:\n  - $\\frac{\\partial R_u}{\\partial u_{n+1}} = 1$\n  - $\\frac{\\partial R_u}{\\partial v_{n+1}} = 0$\n  - $\\frac{\\partial R_u}{\\partial a_{n+1}} = -\\beta\\,\\Delta t^2$\n\nAssembling these components yields the $3 \\times 3$ Jacobian matrix:\n$$\n\\mathbf{J}(u_{n+1}) = \\frac{\\partial(R_m, R_v, R_u)}{\\partial(u_{n+1}, v_{n+1}, a_{n+1})} = \n\\begin{bmatrix}\nK_t(u_{n+1}) & c & m \\\\\n0 & 1 & -\\gamma\\,\\Delta t \\\\\n1 & 0 & -\\beta\\,\\Delta t^2\n\\end{bmatrix}\n$$\nThis Jacobian is the exact derivative of the residual vector, a property known as consistent linearization. Using this matrix in the Newton-Raphson update ensures that the method achieves its characteristic quadratic rate of convergence near the solution.\n\n### Task 2: Static Condensation and the Effective Tangent Stiffness\n\nThe $3 \\times 3$ system can be reduced to a single scalar equation for the primary unknown, $u_{n+1}$. This process, known as static condensation, results in a more efficient solver. The derivation relies on the Schur complement of the Jacobian matrix. We partition the linear system $\\mathbf{J} \\Delta \\mathbf{x} = -\\mathbf{R}$ corresponding to the primary unknown $\\Delta u$ and the secondary unknowns $\\left[\\Delta v, \\Delta a\\right]^\\top$:\n$$\n\\begin{bmatrix}\n\\mathbf{J}_{11} & \\mathbf{J}_{12} \\\\\n\\mathbf{J}_{21} & \\mathbf{J}_{22}\n\\end{bmatrix}\n\\begin{Bmatrix}\n\\Delta u \\\\\n\\Delta \\mathbf{x}_2\n\\end{Bmatrix}\n= -\n\\begin{Bmatrix}\nR_1 \\\\\n\\mathbf{R}_2\n\\end{Bmatrix}\n$$\nwhere $\\Delta \\mathbf{x}_2 = \\left[\\Delta v, \\Delta a\\right]^\\top$, and the partitions of $\\mathbf{J}$ are:\n$$\n\\mathbf{J}_{11} = K_t(u_{n+1}), \\quad \\mathbf{J}_{12} = \\begin{bmatrix} c & m \\end{bmatrix}, \\quad \\mathbf{J}_{21} = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}, \\quad \\mathbf{J}_{22} = \\begin{bmatrix} 1 & -\\gamma\\,\\Delta t \\\\ 0 & -\\beta\\,\\Delta t^2 \\end{bmatrix}\n$$\nFrom the second row of the partitioned system, we solve for $\\Delta \\mathbf{x}_2$: $\\mathbf{J}_{21} \\Delta u + \\mathbf{J}_{22} \\Delta \\mathbf{x}_2 = -\\mathbf{R}_2 \\implies \\Delta \\mathbf{x}_2 = -\\mathbf{J}_{22}^{-1}(\\mathbf{R}_2 + \\mathbf{J}_{21} \\Delta u)$.\nSubstituting this into the first row gives:\n$$\n\\left(\\mathbf{J}_{11} - \\mathbf{J}_{12} \\mathbf{J}_{22}^{-1} \\mathbf{J}_{21}\\right) \\Delta u = -R_1 + \\mathbf{J}_{12}\\mathbf{J}_{22}^{-1}\\mathbf{R}_2\n$$\nThe term multiplying $\\Delta u$ is the Schur complement of $\\mathbf{J}_{11}$, which is the effective tangent stiffness $K_{\\mathrm{eff}}$. Let's compute it. First, we find the inverse of $\\mathbf{J}_{22}$:\n$$\n\\mathbf{J}_{22}^{-1} = \\frac{1}{\\det(\\mathbf{J}_{22})} \\begin{bmatrix} -\\beta\\,\\Delta t^2 & \\gamma\\,\\Delta t \\\\ 0 & 1 \\end{bmatrix} = \\frac{1}{-\\beta\\,\\Delta t^2} \\begin{bmatrix} -\\beta\\,\\Delta t^2 & \\gamma\\,\\Delta t \\\\ 0 & 1 \\end{bmatrix} = \\begin{bmatrix} 1 & -\\frac{\\gamma}{\\beta\\,\\Delta t} \\\\ 0 & -\\frac{1}{\\beta\\,\\Delta t^2} \\end{bmatrix}\n$$\nNow, we compute the triple product $\\mathbf{J}_{12} \\mathbf{J}_{22}^{-1} \\mathbf{J}_{21}$:\n$$\n\\mathbf{J}_{12} \\mathbf{J}_{22}^{-1} = \\begin{bmatrix} c & m \\end{bmatrix} \\begin{bmatrix} 1 & -\\frac{\\gamma}{\\beta\\,\\Delta t} \\\\ 0 & -\\frac{1}{\\beta\\,\\Delta t^2} \\end{bmatrix} = \\begin{bmatrix} c & -c\\frac{\\gamma}{\\beta\\,\\Delta t} - \\frac{m}{\\beta\\,\\Delta t^2} \\end{bmatrix}\n$$\n$$\n(\\mathbf{J}_{12} \\mathbf{J}_{22}^{-1}) \\mathbf{J}_{21} = \\begin{bmatrix} c & -c\\frac{\\gamma}{\\beta\\,\\Delta t} - \\frac{m}{\\beta\\,\\Delta t^2} \\end{bmatrix} \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} = -c\\frac{\\gamma}{\\beta\\,\\Delta t} - \\frac{m}{\\beta\\,\\Delta t^2}\n$$\nFinally, the effective tangent stiffness is:\n$$\nK_{\\mathrm{eff}} = \\mathbf{J}_{11} - \\mathbf{J}_{12} \\mathbf{J}_{22}^{-1} \\mathbf{J}_{21} = K_t(u_{n+1}) - \\left( -c\\frac{\\gamma}{\\beta\\,\\Delta t} - \\frac{m}{\\beta\\,\\Delta t^2} \\right)\n$$\n$$\nK_{\\mathrm{eff}}(u_{n+1}) = K_t(u_{n+1}) + \\frac{1}{\\beta\\,\\Delta t^2} m + \\frac{\\gamma}{\\beta\\,\\Delta t} c\n$$\nThis matches the provided expression $K_{\\mathrm{eff}} = K_t + a_0 m + a_1 c$ with constants $a_0 = \\frac{1}{\\beta\\,\\Delta t^2}$ and $a_1 = \\frac{\\gamma}{\\beta\\,\\Delta t}$.\n\n### Task 3: Algorithmic Design and Implementation Principles\n\nThe condensed formulation allows us to solve for $u_{n+1}$ using a scalar Newton-Raphson iteration. The core of the algorithm is to solve the scalar residual equation $r(u_{n+1})=0$, where:\n$$\nr(u_{n+1}) = m\\,a_{n+1} + c\\,v_{n+1} + f_{\\mathrm{int}}(u_{n+1}) - f_{\\mathrm{ext}}(t_{n+1})\n$$\nIn this equation, $a_{n+1}$ and $v_{n+1}$ are not independent unknowns but are functions of $u_{n+1}$ through the Newmark kinematic relations:\n$$\na_{n+1}(u_{n+1}) = \\frac{1}{\\beta\\,\\Delta t^2}\\left(u_{n+1} - u_n - \\Delta t\\,v_n - \\Delta t^2\\left(\\frac{1}{2} - \\beta\\right)a_n\\right)\n$$\n$$\nv_{n+1}(u_{n+1}) = v_n + \\Delta t\\,(1 - \\gamma)\\,a_n + \\gamma\\,\\Delta t\\,a_{n+1}(u_{n+1})\n$$\nNote that before starting the time step, $a_n$ must be computed to satisfy equilibrium at time $t_n$: $a_n = (f_{\\mathrm{ext}}(t_n) - c v_n - f_{\\mathrm{int}}(u_n)) / m$.\n\nThe Newton-Raphson iteration for $u_{n+1}$ proceeds as follows:\n1.  Initialize iteration counter $k=0$ and the guess $u_{n+1}^{(0)} = u_n$.\n2.  Loop for $k=0, 1, 2, \\dots$ until convergence:\n    a. Let the current guess be $u_{\\text{curr}} = u_{n+1}^{(k)}$.\n    b. Calculate $a_{n+1}$ and $v_{n+1}$ using $u_{\\text{curr}}$ and the kinematic expressions above.\n    c. Evaluate the residual $r(u_{\\text{curr}})$.\n    d. Check for convergence: if $\\lvert r(u_{\\text{curr}}) \\rvert \\le \\varepsilon$ (with $\\varepsilon=10^{-12}$), the loop terminates.\n    e. Evaluate the effective tangent stiffness $K_{\\mathrm{eff}}(u_{\\text{curr}}) = \\frac{dr}{du_{n+1}}|_{u_{n+1}=u_{\\text{curr}}} = K_t(u_{\\text{curr}}) + a_0 m + a_1 c$.\n    f. Compute the update: $\\Delta u = -r(u_{\\text{curr}}) / K_{\\mathrm{eff}}(u_{\\text{curr}})$.\n    g. Update the guess: $u_{n+1}^{(k+1)} = u_{\\text{curr}} + \\Delta u$.\n3. The converged solution is the final value of $u_{n+1}$.\n\nFinally, the implementation requires a numerical verification that the analytical expression for $K_{\\mathrm{eff}}$ is equivalent to the Schur complement of the full $3 \\times 3$ Jacobian. This is achieved by:\n1.  Constructing the numerical Jacobian matrix $\\mathbf{J}$ at the converged solution $u_{n+1}$.\n2.  Partitioning $\\mathbf{J}$ into its $\\mathbf{J}_{11}$, $\\mathbf{J}_{12}$, $\\mathbf{J}_{21}$, and $\\mathbf{J}_{22}$ blocks.\n3.  Numerically computing the Schur complement $S = \\mathbf{J}_{11} - \\mathbf{J}_{12} (\\mathbf{J}_{22})^{-1} \\mathbf{J}_{21}$.\n4.  Comparing this numerical value $S$ to the value of $K_{\\mathrm{eff}}(u_{n+1})$ calculated from the analytical formula. The comparison is done within a small numerical tolerance, yielding a boolean result.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_newmark_step(params):\n    \"\"\"\n    Solves for the state at time t_{n+1} for a single time step using the\n    implicit Newmark method with a condensed Newton-Raphson scheme.\n\n    Args:\n        params (tuple): A tuple containing all problem parameters:\n                        (m, c, k, alpha, dt, beta, gamma, u_n, v_n, \n                         f_ext_n, f_ext_n1)\n\n    Returns:\n        tuple: A tuple containing the converged displacement u_{n+1} (float)\n               and a boolean indicating if the Jacobian verification passed.\n    \"\"\"\n    m, c, k, alpha, dt, beta, gamma, u_n, v_n, f_ext_n, f_ext_n1 = params\n\n    # --- Helper Functions ---\n    def f_int(u):\n        \"\"\"Internal force.\"\"\"\n        return k * u + alpha * u**3\n\n    def K_t(u):\n        \"\"\"Tangent stiffness from the internal force.\"\"\"\n        return k + 3 * alpha * u**2\n\n    # --- Initialization ---\n    # Compute acceleration at step n, assuming equilibrium.\n    a_n = (f_ext_n - c * v_n - f_int(u_n)) / m\n\n    # Newmark constants for the condensed system.\n    a0 = 1.0 / (beta * dt**2)\n    a1 = gamma / (beta * dt)\n\n    # --- Newton-Raphson Iteration for the Condensed System ---\n    u_n1 = u_n  # Initial guess for the displacement at t_{n+1}.\n    \n    epsilon = 1e-12\n    max_iter = 20\n\n    for _ in range(max_iter):\n        # Calculate kinematics (a_{n+1}, v_{n+1}) based on the current guess for u_{n+1}.\n        # The equation for a_{n+1} is derived from the Newmark displacement update:\n        # u_{n+1} = u_n + dt*v_n + dt^2*(1/2 - beta)*a_n + beta*dt^2*a_{n+1}\n        # Rearranging gives:\n        a_n1 = a0 * (u_n1 - u_n - dt * v_n) - (1/(2*beta) - 1) * a_n\n        \n        # The velocity v_{n+1} is updated using the computed a_{n+1}.\n        v_n1 = v_n + dt * (1 - gamma) * a_n + gamma * dt * a_n1\n\n        # Calculate the residual of the dynamic equilibrium equation at t_{n+1}.\n        residual = m * a_n1 + c * v_n1 + f_int(u_n1) - f_ext_n1\n\n        # Check for convergence.\n        if np.abs(residual) <= epsilon:\n            break\n\n        # Calculate the effective tangent stiffness K_eff.\n        K_eff = K_t(u_n1) + a0 * m + a1 * c\n\n        # Compute the update to the displacement.\n        delta_u = -residual / K_eff\n        u_n1 += delta_u\n    else:\n        # This block executes if the loop completes without converging.\n        # In a real application, an error should be raised.\n        # For this problem, convergence is expected.\n        pass\n    \n    final_u_n1 = u_n1\n\n    # --- Jacobian Verification ---\n    # 1. Calculate K_eff using the analytical condensed formula at the converged solution.\n    K_eff_condensed = K_t(final_u_n1) + a0 * m + a1 * c\n\n    # 2. Build the full 3x3 Jacobian matrix at the converged solution.\n    # The order of residuals is (R_m, R_v, R_u) and variables is (u, v, a).\n    J = np.array([\n        [K_t(final_u_n1), c, m],\n        [0.0, 1.0, -gamma * dt],\n        [1.0, 0.0, -beta * dt**2]\n    ])\n    \n    # 3. Partition the Jacobian matrix.\n    J11 = J[0, 0]\n    J12 = J[0, 1:].reshape(1, 2)\n    J21 = J[1:, 0].reshape(2, 1)\n    J22 = J[1:, 1:]\n\n    # 4. Calculate the Schur complement: S = J11 - J12 @ inv(J22) @ J21\n    try:\n        J22_inv = np.linalg.inv(J22)\n        schur_complement = (J11 - J12 @ J22_inv @ J21).item()\n    except np.linalg.LinAlgError:\n        schur_complement = np.nan # In case of singular J22\n\n    # 5. Compare the analytical K_eff with the numerical Schur complement.\n    is_consistent = np.isclose(schur_complement, K_eff_condensed)\n\n    return final_u_n1, is_consistent\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (general nonlinear, damped)\n        (1.0, 0.05, 100.0, 500.0, 0.01, 0.25, 0.5, 0.01, 0.0, 0.0, 1.0),\n        # Case B (undamped)\n        (2.0, 0.0, 200.0, 1000.0, 0.01, 0.25, 0.5, 0.0, 0.0, 0.0, 0.5),\n        # Case C (small time step)\n        (1.0, 0.05, 100.0, 500.0, 0.001, 0.25, 0.5, 0.01, 0.0, 0.0, 1.0),\n        # Case D (stiff nonlinear, moderate damping)\n        (0.5, 0.2, 1000.0, 100000.0, 0.01, 0.25, 0.5, 0.002, 0.0, 0.0, 2.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        u_final, is_consistent_bool = solve_newmark_step(case)\n        results.append(u_final)\n        results.append(str(is_consistent_bool))\n\n    # The problem asks for the boolean to be represented as a string like 'bool_A'.\n    # Python's str(True) is 'True', which fits this representation.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3566474"}]}