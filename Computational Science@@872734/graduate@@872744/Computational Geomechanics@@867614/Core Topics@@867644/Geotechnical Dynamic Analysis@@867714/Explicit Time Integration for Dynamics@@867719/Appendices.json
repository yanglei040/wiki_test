{"hands_on_practices": [{"introduction": "To truly grasp the mechanics of an explicit time integration scheme, it is invaluable to perform a calculation by hand. This exercise walks you through a single time step of the central difference method for a simple two-degree-of-freedom system, which is a common idealization for problems in geomechanics. By manually applying the update formulas [@problem_id:3523947], you will build a concrete understanding of how the algorithm uses information from the current and previous time steps to explicitly solve for the system's future state, without needing to solve a system of equations.", "problem": "A horizontally layered soil stratum is idealized by a two-degree-of-freedom lumped-mass model with translational motion at two nodes. The semi-discrete equation of motion for small-amplitude, linear elastic dynamics without damping is given by Newton’s second law in the form $\\,\\mathbf{M}\\,\\ddot{\\mathbf{u}}(t) + \\mathbf{K}\\,\\mathbf{u}(t) = \\mathbf{f}(t)\\,$, where $\\,\\mathbf{M}\\,$ is the diagonal (lumped) mass matrix, $\\,\\mathbf{K}\\,$ is the linear stiffness matrix, and $\\,\\mathbf{f}(t)\\,$ is the external load vector. At the discrete time $\\,t^{n}\\,$, you are provided with the following data:\n- Mass matrix $\\,\\mathbf{M} = \\mathrm{diag}(2000,\\,1000)\\,$ in $\\mathrm{kg}$.\n- Stiffness matrix $\\,\\mathbf{K} = \\begin{pmatrix} 5 \\times 10^{6}  0 \\\\ 0  5 \\times 10^{6} \\end{pmatrix}\\,$ in $\\mathrm{N/m}$.\n- Time step $\\,\\Delta t = 0.01\\,$ in $\\mathrm{s}$.\n- Displacement at the current and previous time steps: $\\,\\mathbf{u}^{n} = \\begin{pmatrix} 0.02 \\\\ -0.01 \\end{pmatrix}\\,$ in $\\mathrm{m}$ and $\\,\\mathbf{u}^{n-1} = \\begin{pmatrix} 0.015 \\\\ -0.012 \\end{pmatrix}\\,$ in $\\mathrm{m}$.\n- External load vector at $\\,t^{n}\\,$: $\\,\\mathbf{f}^{n} = \\begin{pmatrix} 3 \\times 10^{5} \\\\ 0 \\end{pmatrix}\\,$ in $\\mathrm{N}$.\n\nStarting from $\\,\\mathbf{M}\\,\\ddot{\\mathbf{u}}(t) + \\mathbf{K}\\,\\mathbf{u}(t) = \\mathbf{f}(t)\\,$ and the central difference finite-difference definitions for time derivatives, derive and implement one explicit central difference step to compute the next-step displacement $\\,\\mathbf{u}^{n+1}\\,$ and the mid-step velocity $\\,\\dot{\\mathbf{u}}^{\\,n+1/2}\\,$.\n\nExpress your final numerical answer as a single row matrix containing four entries in the order $\\,u_{1}^{n+1}\\,$, $\\,u_{2}^{n+1}\\,$, $\\,\\dot{u}_{1}^{\\,n+1/2}\\,$, $\\,\\dot{u}_{2}^{\\,n+1/2}\\,$. Use meters ($\\mathrm{m}$) for displacements and meters per second ($\\mathrm{m/s}$) for velocities. No rounding is required. Do not include units inside the final boxed answer.", "solution": "The problem statement has been validated and is deemed valid. It is a well-posed problem in computational dynamics with all necessary data provided and no internal contradictions or scientific inaccuracies.\n\nThe governing semi-discrete equation of motion for the two-degree-of-freedom system is given as:\n$$\n\\mathbf{M}\\,\\ddot{\\mathbf{u}}(t) + \\mathbf{K}\\,\\mathbf{u}(t) = \\mathbf{f}(t)\n$$\nThis equation is evaluated at the discrete time step $t^n$, yielding:\n$$\n\\mathbf{M}\\,\\ddot{\\mathbf{u}}^{n} + \\mathbf{K}\\,\\mathbf{u}^{n} = \\mathbf{f}^{n}\n$$\nwhere $\\ddot{\\mathbf{u}}^{n} = \\ddot{\\mathbf{u}}(t^n)$, $\\mathbf{u}^{n} = \\mathbf{u}(t^n)$, and $\\mathbf{f}^{n} = \\mathbf{f}(t^n)$.\n\nThe central difference method utilizes a second-order finite difference approximation for the acceleration vector at time $t^n$, centered around the time step $n$:\n$$\n\\ddot{\\mathbf{u}}^{n} \\approx \\frac{\\mathbf{u}^{n+1} - 2\\mathbf{u}^{n} + \\mathbf{u}^{n-1}}{(\\Delta t)^2}\n$$\nwhere $\\mathbf{u}^{n+1}$ and $\\mathbf{u}^{n-1}$ are the displacement vectors at times $t^{n+1} = t^n + \\Delta t$ and $t^{n-1} = t^n - \\Delta t$, respectively.\n\nSubstituting this approximation into the equation of motion gives the fully discrete update equation:\n$$\n\\mathbf{M} \\left( \\frac{\\mathbf{u}^{n+1} - 2\\mathbf{u}^{n} + \\mathbf{u}^{n-1}}{(\\Delta t)^2} \\right) + \\mathbf{K}\\mathbf{u}^{n} = \\mathbf{f}^{n}\n$$\nOur objective is to solve for the displacement at the next time step, $\\mathbf{u}^{n+1}$. We rearrange the equation to isolate $\\mathbf{u}^{n+1}$:\n$$\n\\mathbf{M} (\\mathbf{u}^{n+1} - 2\\mathbf{u}^{n} + \\mathbf{u}^{n-1}) = (\\Delta t)^2 (\\mathbf{f}^{n} - \\mathbf{K}\\mathbf{u}^{n})\n$$\n$$\n\\mathbf{M}\\mathbf{u}^{n+1} = \\mathbf{M}(2\\mathbf{u}^{n} - \\mathbf{u}^{n-1}) + (\\Delta t)^2 (\\mathbf{f}^{n} - \\mathbf{K}\\mathbf{u}^{n})\n$$\nSince the mass matrix $\\mathbf{M}$ is a diagonal (lumped) matrix, it is easily invertible. Pre-multiplying by $\\mathbf{M}^{-1}$ yields the explicit update formula for the displacements:\n$$\n\\mathbf{u}^{n+1} = \\mathbf{M}^{-1} \\left[ \\mathbf{M}(2\\mathbf{u}^{n} - \\mathbf{u}^{n-1}) + (\\Delta t)^2 (\\mathbf{f}^{n} - \\mathbf{K}\\mathbf{u}^{n}) \\right]\n$$\nAlternatively, this can be written as:\n$$\n\\mathbf{u}^{n+1} = (2\\mathbf{u}^{n} - \\mathbf{u}^{n-1}) + (\\Delta t)^2 \\mathbf{M}^{-1} (\\mathbf{f}^{n} - \\mathbf{K}\\mathbf{u}^{n})\n$$\nWe are given the following data:\n- $\\mathbf{M} = \\begin{pmatrix} 2000  0 \\\\ 0  1000 \\end{pmatrix}\\,\\mathrm{kg}$\n- $\\mathbf{K} = \\begin{pmatrix} 5 \\times 10^{6}  0 \\\\ 0  5 \\times 10^{6} \\end{pmatrix}\\,\\mathrm{N/m}$\n- $\\Delta t = 0.01\\,\\mathrm{s}$\n- $\\mathbf{u}^{n} = \\begin{pmatrix} 0.02 \\\\ -0.01 \\end{pmatrix}\\,\\mathrm{m}$\n- $\\mathbf{u}^{n-1} = \\begin{pmatrix} 0.015 \\\\ -0.012 \\end{pmatrix}\\,\\mathrm{m}$\n- $\\mathbf{f}^{n} = \\begin{pmatrix} 3 \\times 10^{5} \\\\ 0 \\end{pmatrix}\\,\\mathrm{N}$\n\nFirst, we compute the term representing the internal forces, $\\mathbf{f}_{\\text{int}}^{n} = \\mathbf{K}\\mathbf{u}^{n}$:\n$$\n\\mathbf{K}\\mathbf{u}^{n} = \\begin{pmatrix} 5 \\times 10^{6}  0 \\\\ 0  5 \\times 10^{6} \\end{pmatrix} \\begin{pmatrix} 0.02 \\\\ -0.01 \\end{pmatrix} = \\begin{pmatrix} (5 \\times 10^{6})(0.02) \\\\ (5 \\times 10^{6})(-0.01) \\end{pmatrix} = \\begin{pmatrix} 1 \\times 10^{5} \\\\ -5 \\times 10^{4} \\end{pmatrix}\\,\\mathrm{N}\n$$\nNext, we compute the effective force vector, $\\mathbf{f}^{n} - \\mathbf{K}\\mathbf{u}^{n}$:\n$$\n\\mathbf{f}^{n} - \\mathbf{K}\\mathbf{u}^{n} = \\begin{pmatrix} 3 \\times 10^{5} \\\\ 0 \\end{pmatrix} - \\begin{pmatrix} 1 \\times 10^{5} \\\\ -5 \\times 10^{4} \\end{pmatrix} = \\begin{pmatrix} 2 \\times 10^{5} \\\\ 5 \\times 10^{4} \\end{pmatrix}\\,\\mathrm{N}\n$$\nNow, we calculate the term $2\\mathbf{u}^{n} - \\mathbf{u}^{n-1}$:\n$$\n2\\mathbf{u}^{n} - \\mathbf{u}^{n-1} = 2 \\begin{pmatrix} 0.02 \\\\ -0.01 \\end{pmatrix} - \\begin{pmatrix} 0.015 \\\\ -0.012 \\end{pmatrix} = \\begin{pmatrix} 0.04 \\\\ -0.02 \\end{pmatrix} - \\begin{pmatrix} 0.015 \\\\ -0.012 \\end{pmatrix} = \\begin{pmatrix} 0.025 \\\\ -0.008 \\end{pmatrix}\\,\\mathrm{m}\n$$\nThe inverse mass matrix is:\n$$\n\\mathbf{M}^{-1} = \\begin{pmatrix} 1/2000  0 \\\\ 0  1/1000 \\end{pmatrix} = \\begin{pmatrix} 0.0005  0 \\\\ 0  0.001 \\end{pmatrix}\\,\\mathrm{kg^{-1}}\n$$\nWe now compute the acceleration-like term, premultiplied by $(\\Delta t)^2$:\n$$\n(\\Delta t)^2 \\mathbf{M}^{-1} (\\mathbf{f}^{n} - \\mathbf{K}\\mathbf{u}^{n}) = (0.01)^2 \\begin{pmatrix} 0.0005  0 \\\\ 0  0.001 \\end{pmatrix} \\begin{pmatrix} 2 \\times 10^{5} \\\\ 5 \\times 10^{4} \\end{pmatrix}\n$$\n$$\n= 10^{-4} \\begin{pmatrix} 0.0005 \\times (2 \\times 10^{5}) \\\\ 0.001 \\times (5 \\times 10^{4}) \\end{pmatrix} = 10^{-4} \\begin{pmatrix} 100 \\\\ 50 \\end{pmatrix} = \\begin{pmatrix} 0.01 \\\\ 0.005 \\end{pmatrix}\\,\\mathrm{m}\n$$\nFinally, we substitute these results into the update formula for $\\mathbf{u}^{n+1}$:\n$$\n\\mathbf{u}^{n+1} = (2\\mathbf{u}^{n} - \\mathbf{u}^{n-1}) + (\\Delta t)^2 \\mathbf{M}^{-1} (\\mathbf{f}^{n} - \\mathbf{K}\\mathbf{u}^{n})\n$$\n$$\n\\mathbf{u}^{n+1} = \\begin{pmatrix} 0.025 \\\\ -0.008 \\end{pmatrix} + \\begin{pmatrix} 0.01 \\\\ 0.005 \\end{pmatrix} = \\begin{pmatrix} 0.035 \\\\ -0.003 \\end{pmatrix}\\,\\mathrm{m}\n$$\nThus, the components of the displacement vector at time $t^{n+1}$ are $u_1^{n+1} = 0.035\\,\\mathrm{m}$ and $u_2^{n+1} = -0.003\\,\\mathrm{m}$.\n\nNext, we compute the mid-step velocity vector $\\dot{\\mathbf{u}}^{\\,n+1/2}$, which is defined by the central difference approximation centered at $t^{n+1/2}$:\n$$\n\\dot{\\mathbf{u}}^{\\,n+1/2} = \\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^{n}}{\\Delta t}\n$$\nSubstituting the known and calculated values:\n$$\n\\dot{\\mathbf{u}}^{\\,n+1/2} = \\frac{1}{0.01} \\left( \\begin{pmatrix} 0.035 \\\\ -0.003 \\end{pmatrix} - \\begin{pmatrix} 0.02 \\\\ -0.01 \\end{pmatrix} \\right)\n$$\n$$\n\\dot{\\mathbf{u}}^{\\,n+1/2} = 100 \\begin{pmatrix} 0.015 \\\\ 0.007 \\end{pmatrix} = \\begin{pmatrix} 1.5 \\\\ 0.7 \\end{pmatrix}\\,\\mathrm{m/s}\n$$\nThe components of the velocity vector at time $t^{n+1/2}$ are $\\dot{u}_1^{\\,n+1/2} = 1.5\\,\\mathrm{m/s}$ and $\\dot{u}_2^{\\,n+1/2} = 0.7\\,\\mathrm{m/s}$.\n\nThe final requested quantities are the four scalars: $u_{1}^{n+1}$, $u_{2}^{n+1}$, $\\dot{u}_{1}^{\\,n+1/2}$, and $\\dot{u}_{2}^{\\,n+1/2}$.\nThe values are $u_1^{n+1} = 0.035$, $u_2^{n+1} = -0.003$, $\\dot{u}_1^{\\,n+1/2} = 1.5$, and $\\dot{u}_2^{\\,n+1/2} = 0.7$.", "answer": "$$\n\\boxed{\\begin{pmatrix} 0.035  -0.003  1.5  0.7 \\end{pmatrix}}\n$$", "id": "3523947"}, {"introduction": "From a single calculation, we move to a full dynamic simulation. This practice requires you to implement a complete one-dimensional finite element solver for a soil bar subjected to a transient load. You will assemble the system matrices, apply boundary conditions, and implement the central difference time-stepping loop to track the bar's motion. A critical component of this exercise is the calculation of the system's kinetic and strain energies, which provides a powerful method for verifying the correctness of your code, as the total energy in an undamped, unforced system should be conserved [@problem_id:3523936].", "problem": "Consider a one-dimensional linear elastic soil block modeled as a bar of length $L$ and cross-sectional area $A$, with mass density $\\rho$ and Young's modulus $E$. The left end is fixed and the right end is subjected to a prescribed transient normal traction $T(t)$ over a finite duration. Using a standard linear finite element semi-discretization with $N_{\\mathrm{e}}$ equal-length elements, lumped mass, and no damping, the semidiscrete equation of motion is\n$$\n\\mathbf{M}\\,\\ddot{\\mathbf{u}}(t) + \\mathbf{K}\\,\\mathbf{u}(t) = \\mathbf{f}(t),\n$$\nwhere $\\mathbf{u}(t)$ is the vector of nodal displacements for the free degrees of freedom, $\\mathbf{M}$ is the diagonal lumped mass matrix, $\\mathbf{K}$ is the stiffness matrix, and $\\mathbf{f}(t)$ is the external nodal force vector induced by the traction at the right boundary. Let the traction be defined as a sinusoid $T(t) = T_{0}\\,\\sin(2\\pi f\\,t)$ for $0 \\le t \\le t_{\\mathrm{load}}$ with $t_{\\mathrm{load}} = n_{\\mathrm{cycles}}/f$, and $T(t) = 0$ for $t  t_{\\mathrm{load}}$. The corresponding nodal force acts only at the rightmost free degree of freedom and has magnitude $F(t) = A\\,T(t)$ at that node. Adopt the central difference explicit time integration, initialized from rest, to integrate the motion until a final time $t_{\\mathrm{end}} = t_{\\mathrm{load}} + t_{\\mathrm{free}}$.\n\nStarting from Newton’s second law, a consistent finite element semi-discretization, and the central difference scheme, do the following:\n- Derive, from first principles, the explicit update formulas for the nodal displacement $\\mathbf{u}^{n+1}$ in terms of $\\mathbf{u}^{n}$, $\\mathbf{u}^{n-1}$, the time step $\\Delta t$, and the semidiscrete operators, assuming lumped mass and zero damping.\n- Specify a stable time step using a Courant-Friedrichs-Lewy (CFL) type estimate based on the elastic wave speed $c = \\sqrt{E/\\rho}$ and the minimum element length $h = L/N_{\\mathrm{e}}$, taking $\\Delta t = \\alpha \\, h / c$ with a given safety factor $\\alpha \\in (0,1]$.\n- Define the discrete kinetic energy and strain energy at integer time $t^{n} = n\\,\\Delta t$ as\n$$\n\\mathcal{T}^{n} = \\tfrac{1}{2}\\,\\dot{\\mathbf{u}}^{n\\top}\\mathbf{M}\\,\\dot{\\mathbf{u}}^{n},\\qquad\n\\mathcal{U}^{n} = \\tfrac{1}{2}\\,\\mathbf{u}^{n\\top}\\mathbf{K}\\,\\mathbf{u}^{n},\n$$\nwhere the nodal velocity at integer time is approximated by the central difference $\\dot{\\mathbf{u}}^{n} \\approx \\left(\\mathbf{u}^{n+1} - \\mathbf{u}^{n-1}\\right)/(2\\,\\Delta t)$.\n- For the no-load phase $t \\ge t_{\\mathrm{load}}$, quantify the numerical energy error due to time integration as the maximum relative drift of the total discrete mechanical energy $\\mathcal{E}^{n} = \\mathcal{T}^{n} + \\mathcal{U}^{n}$ with respect to its value at the load shutoff time. Specifically, let $n_{0} = \\lceil t_{\\mathrm{load}}/\\Delta t \\rceil$ and define\n$$\n\\varepsilon_{\\max} = \\max_{n \\ge n_{0}} \\frac{\\left|\\mathcal{E}^{n} - \\mathcal{E}^{n_{0}}\\right|}{\\mathcal{E}^{n_{0}}}.\n$$\n\nImplement a complete, runnable program that assembles the one-dimensional finite element model, advances the solution using the central difference scheme, computes the time histories $\\{\\mathcal{T}^{n}\\}$ and $\\{\\mathcal{U}^{n}\\}$, and reports the numerical energy error $\\varepsilon_{\\max}$ as defined above.\n\nUse the following test suite of parameter sets. All parameters are in the International System of Units (SI): length in meters, area in square meters, mass density in kilograms per cubic meter, Young’s modulus in pascals, traction in pascals, time in seconds, and frequency in hertz. For each test, compute the time step using $\\Delta t = \\alpha \\, h / c$ with $h = L/N_{\\mathrm{e}}$ and $c = \\sqrt{E/\\rho}$, and set $t_{\\mathrm{end}} = t_{\\mathrm{load}} + t_{\\mathrm{free}}$.\n\n- Test A (happy path):\n  - $N_{\\mathrm{e}} = 50$, $L = 10.0$, $A = 1.0$, $\\rho = 2000.0$, $E = 1.0\\times 10^{8}$,\n  - $T_{0} = 1.0\\times 10^{5}$, $f = 10.0$, $n_{\\mathrm{cycles}} = 5$,\n  - $\\alpha = 0.8$, $t_{\\mathrm{free}} = 1.0$.\n\n- Test B (near stability boundary):\n  - $N_{\\mathrm{e}} = 50$, $L = 10.0$, $A = 1.0$, $\\rho = 2000.0$, $E = 1.0\\times 10^{8}$,\n  - $T_{0} = 1.0\\times 10^{5}$, $f = 15.0$, $n_{\\mathrm{cycles}} = 8$,\n  - $\\alpha = 0.99$, $t_{\\mathrm{free}} = 1.0$.\n\n- Test C (coarser mesh and different material):\n  - $N_{\\mathrm{e}} = 20$, $L = 10.0$, $A = 1.0$, $\\rho = 1800.0$, $E = 8.0\\times 10^{7}$,\n  - $T_{0} = 5.0\\times 10^{4}$, $f = 5.0$, $n_{\\mathrm{cycles}} = 4$,\n  - $\\alpha = 0.6$, $t_{\\mathrm{free}} = 1.5$.\n\nYour program must:\n- Assemble the lumped mass and stiffness matrices for a uniform mesh of linear elements,\n- Enforce the fixed boundary at the left end by eliminating the corresponding degree of freedom,\n- Apply the right-end traction $T(t)$ as a nodal force $F(t) = A\\,T(t)$ on the rightmost free degree of freedom,\n- Initialize from rest with $\\mathbf{u}^{0} = \\mathbf{0}$ and $\\dot{\\mathbf{u}}^{0} = \\mathbf{0}$,\n- Use the central difference method to integrate to $t_{\\mathrm{end}}$,\n- Compute and store $\\mathcal{T}^{n}$ and $\\mathcal{U}^{n}$ at each integer time $t^{n}$,\n- Compute $\\varepsilon_{\\max}$ over $t \\in [t_{\\mathrm{load}}, t_{\\mathrm{end}}]$.\n\nFinal output format:\n- The program should produce a single line of output containing the numerical energy error results as a comma-separated list enclosed in square brackets, in the order of the tests above. Each entry must be a floating-point decimal number corresponding to $\\varepsilon_{\\max}$ for that test case. For example, the output should look like $[\\varepsilon_{\\max}^{(A)},\\varepsilon_{\\max}^{(B)},\\varepsilon_{\\max}^{(C)}]$ with no other text.", "solution": "The problem statement has been meticulously reviewed and is determined to be valid. It is scientifically grounded, well-posed, objective, and contains all necessary information to derive a unique and meaningful solution. The problem provides a standard and substantive exercise in computational solid mechanics.\n\n### 1. Theoretical Formulation\n\nThe problem requires the dynamic analysis of a one-dimensional linear elastic bar using the Finite Element Method (FEM) for spatial discretization and the central difference method for temporal integration.\n\n#### 1.1. Finite Element Semi-Discretization\n\nThe continuous system is discretized into $N_{\\mathrm{e}}$ linear finite elements, each of length $h = L/N_{\\mathrm{e}}$. This leads to a system of $N_{\\mathrm{e}}+1$ nodes. For a single element spanning two nodes, the element stiffness matrix $\\mathbf{k}^{(e)}$ and lumped mass matrix $\\mathbf{m}_{\\text{lumped}}^{(e)}$ are given by:\n$$\n\\mathbf{k}^{(e)} = \\frac{EA}{h}\n\\begin{pmatrix}\n1  -1 \\\\\n-1  1\n\\end{pmatrix},\n\\qquad\n\\mathbf{m}_{\\text{lumped}}^{(e)} = \\frac{\\rho A h}{2}\n\\begin{pmatrix}\n1  0 \\\\\n0  1\n\\end{pmatrix}\n$$\nThe global stiffness matrix $\\mathbf{K}_{\\text{global}}$ and mass matrix $\\mathbf{M}_{\\text{global}}$ are assembled by summing the contributions from all $N_{\\mathrm{e}}$ elements. The fixed boundary condition at the left end ($x=0$) implies the displacement of node $0$ is zero. This degree of freedom is eliminated, reducing the system to the $N_{\\mathrm{e}}$ free degrees of freedom corresponding to nodes $1, \\dots, N_{\\mathrm{e}}$. The resulting reduced matrices, $\\mathbf{K}$ and $\\mathbf{M}$ (of size $N_{\\mathrm{e}} \\times N_{\\mathrm{e}}$), are:\n\nThe stiffness matrix $\\mathbf{K}$ is a tridiagonal matrix defined by:\n$$\nK_{ij} = \\frac{EA}{h} \\begin{cases}\n2  \\text{if } i=j, \\quad i \\in \\{0, \\dots, N_{\\mathrm{e}}-2\\} \\\\\n1  \\text{if } i=j=N_{\\mathrm{e}}-1 \\\\\n-1  \\text{if } |i-j|=1 \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\nThe lumped mass matrix $\\mathbf{M}$ is a diagonal matrix with entries:\n$$\nM_{ii} = \\begin{cases}\n\\rho A h  \\text{if } i \\in \\{0, \\dots, N_{\\mathrm{e}}-2\\} \\\\\n\\frac{\\rho A h}{2}  \\text{if } i=N_{\\mathrm{e}}-1\n\\end{cases}\n$$\nThese indices $i, j$ range from $0$ to $N_{\\mathrm{e}}-1$, corresponding to physical nodes $1$ to $N_{\\mathrm{e}}$. The semi-discrete equation of motion for the vector of free nodal displacements $\\mathbf{u}(t)$ is $\\mathbf{M}\\,\\ddot{\\mathbf{u}}(t) + \\mathbf{K}\\,\\mathbf{u}(t) = \\mathbf{f}(t)$.\n\n#### 1.2. Central Difference Time Integration\n\nWe discretize time with a constant step $\\Delta t$, such that $t^n = n\\,\\Delta t$. The central difference method approximates the second time derivative of the displacement (acceleration) at time $t^n$ as:\n$$\n\\ddot{\\mathbf{u}}^n \\approx \\frac{\\mathbf{u}^{n+1} - 2\\mathbf{u}^n + \\mathbf{u}^{n-1}}{(\\Delta t)^2}\n$$\nSubstituting this approximation into the semi-discrete equation of motion, $\\mathbf{M}\\,\\ddot{\\mathbf{u}}^n + \\mathbf{K}\\,\\mathbf{u}^n = \\mathbf{f}^n$, yields:\n$$\n\\mathbf{M}\\left(\\frac{\\mathbf{u}^{n+1} - 2\\mathbf{u}^n + \\mathbf{u}^{n-1}}{(\\Delta t)^2}\\right) + \\mathbf{K}\\,\\mathbf{u}^n = \\mathbf{f}^n\n$$\nTo find the displacement at the next time step, $\\mathbf{u}^{n+1}$, we rearrange the equation. This is an explicit scheme because $\\mathbf{u}^{n+1}$ can be solved for directly from known quantities at times $t^n$ and $t^{n-1}$.\n$$\n\\mathbf{M}\\,\\mathbf{u}^{n+1} = (\\Delta t)^2 \\left( \\mathbf{f}^n - \\mathbf{K}\\,\\mathbf{u}^n \\right) + 2\\mathbf{M}\\,\\mathbf{u}^n - \\mathbf{M}\\,\\mathbf{u}^{n-1}\n$$\nSince $\\mathbf{M}$ is a diagonal (lumped) matrix, its inverse $\\mathbf{M}^{-1}$ is also diagonal and trivial to compute. Multiplying by $\\mathbf{M}^{-1}$ gives the explicit update formula:\n$$\n\\mathbf{u}^{n+1} = (\\Delta t)^2 \\mathbf{M}^{-1} \\left( \\mathbf{f}^n - \\mathbf{K}\\,\\mathbf{u}^n \\right) + 2\\mathbf{u}^n - \\mathbf{u}^{n-1}\n$$\nThe external force vector $\\mathbf{f}^n$ has a single non-zero entry at the component corresponding to the rightmost node, with magnitude $F(t^n) = A\\,T(t^n)$.\n\n#### 1.3. Initialization\n\nThe scheme is initialized from rest, meaning $\\mathbf{u}(0) = \\mathbf{u}^0 = \\mathbf{0}$ and $\\dot{\\mathbf{u}}(0) = \\dot{\\mathbf{u}}^0 = \\mathbf{0}$. The update formula requires a \"fictitious\" displacement $\\mathbf{u}^{-1}$ at time $t^{-1}=-\\Delta t$. We obtain this by Taylor-expanding $\\mathbf{u}^{-1}$ about $t^0=0$:\n$$\n\\mathbf{u}^{-1} = \\mathbf{u}^0 - \\Delta t\\,\\dot{\\mathbf{u}}^0 + \\frac{(\\Delta t)^2}{2}\\ddot{\\mathbf{u}}^0\n$$\nWith the given initial conditions $\\mathbf{u}^0=\\mathbf{0}$ and $\\dot{\\mathbf{u}}^0=\\mathbf{0}$, this simplifies to $\\mathbf{u}^{-1} = \\frac{(\\Delta t)^2}{2}\\ddot{\\mathbf{u}}^0$. The initial acceleration $\\ddot{\\mathbf{u}}^0$ is found from the equation of motion at $t=0$: $\\ddot{\\mathbf{u}}^0 = \\mathbf{M}^{-1}(\\mathbf{f}^0 - \\mathbf{K}\\mathbf{u}^0)$. The forcing function is $T(t) = T_0 \\sin(2\\pi f t)$, so at $t=0$, $T(0)=0$ and thus $\\mathbf{f}^0=\\mathbf{0}$. With $\\mathbf{u}^0=\\mathbf{0}$, this gives $\\ddot{\\mathbf{u}}^0=\\mathbf{0}$. Consequently, the required starting displacement is $\\mathbf{u}^{-1} = \\mathbf{0}$. The integration starts with $\\mathbf{u}^{-1} = \\mathbf{0}$ and $\\mathbf{u}^{0} = \\mathbf{0}$.\n\n#### 1.4. Stability and Time Step Selection\n\nThe central difference method is conditionally stable. For the 1D wave equation discretized with linear elements and a lumped mass matrix, the stability is governed by the Courant-Friedrichs-Lewy (CFL) condition. The critical time step is related to the time it takes for a wave to travel across the smallest element. The P-wave speed in the material is $c = \\sqrt{E/\\rho}$, and the element length is $h = L/N_{\\mathrm{e}}$. The stability limit is $\\Delta t \\le h/c$. The problem specifies a time step based on this limit with a safety factor $\\alpha \\in (0, 1]$:\n$$\n\\Delta t = \\alpha \\frac{h}{c} = \\alpha \\frac{L/N_{\\mathrm{e}}}{\\sqrt{E/\\rho}}\n$$\nThis choice ensures numerical stability of the integration.\n\n#### 1.5. Energy and Error Calculation\n\nThe discrete kinetic energy $\\mathcal{T}^n$ and strain energy $\\mathcal{U}^n$ at time $t^n$ are defined as:\n$$\n\\mathcal{T}^{n} = \\tfrac{1}{2}\\,\\dot{\\mathbf{u}}^{n\\top}\\mathbf{M}\\,\\dot{\\mathbf{u}}^{n} \\quad \\text{with} \\quad \\dot{\\mathbf{u}}^{n} = \\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^{n-1}}{2\\,\\Delta t}\n$$\n$$\n\\mathcal{U}^{n} = \\tfrac{1}{2}\\,\\mathbf{u}^{n\\top}\\mathbf{K}\\,\\mathbf{u}^{n}\n$$\nThe total discrete mechanical energy is $\\mathcal{E}^n = \\mathcal{T}^n + \\mathcal{U}^n$. The external force is applied until $t_{\\mathrm{load}}$. For $t \\ge t_{\\mathrm{load}}$, the system is undamped and unforced, and its total energy should ideally be conserved. Numerical integration introduces errors, causing the computed total energy to drift. This numerical error is quantified by comparing the total energy at any step $n \\ge n_0$ to a reference energy $\\mathcal{E}^{n_0}$, where $n_0 = \\lceil t_{\\mathrm{load}}/\\Delta t \\rceil$ is the first time step after the load is removed. The maximum relative energy error is:\n$$\n\\varepsilon_{\\max} = \\max_{n \\ge n_{0}} \\frac{\\left|\\mathcal{E}^{n} - \\mathcal{E}^{n_{0}}\\right|}{\\mathcal{E}^{n_{0}}}\n$$\nThe calculation of $\\mathcal{T}^n$ at a given step $n$ requires the displacement $\\mathbf{u}^{n+1}$ from the next step, which is available within the time-stepping loop after the update.\n\n### 2. Algorithmic Procedure\n\nThe numerical solution is implemented by following these steps for each given test case:\n1.  **Setup**: Calculate derived parameters such as element length $h$, wave speed $c$, and time step $\\Delta t$. Determine the total number of steps $N_{\\text{steps}}$ required to reach $t_{\\text{end}}$.\n2.  **Matrix Assembly**: Construct the $N_{\\mathrm{e}} \\times N_{\\mathrm{e}}$ reduced stiffness matrix $\\mathbf{K}$ and the diagonal of the reduced lumped mass matrix $\\mathbf{M}$.\n3.  **Initialization**: Initialize displacement vectors $\\mathbf{u}^{\\text{prev}}$ (representing $\\mathbf{u}^{n-1}$) and $\\mathbf{u}^{\\text{curr}}$ (representing $\\mathbf{u}^{n}$) to zero vectors of size $N_{\\mathrm{e}}$.\n4.  **Time Integration**: Loop for $n$ from $0$ to $N_{\\text{steps}}-1$:\n    a. Determine the current time $t^n = n\\,\\Delta t$.\n    b. Assemble the force vector $\\mathbf{f}^n$. It is zero everywhere except for the last component, which is $A T(t^n)$ if $t^n \\le t_{\\mathrm{load}}$ and $0$ otherwise.\n    c. Compute the next displacement $\\mathbf{u}^{\\text{next}}$ (representing $\\mathbf{u}^{n+1}$) using the central difference update formula.\n    d. Compute and store the strain energy $\\mathcal{U}^n$ using $\\mathbf{u}^{\\text{curr}}$.\n    e. Compute and store the kinetic energy $\\mathcal{T}^n$ using the velocity $\\dot{\\mathbf{u}}^n = (\\mathbf{u}^{\\text{next}} - \\mathbf{u}^{\\text{prev}})/(2\\Delta t)$.\n    f. Update the displacement vectors for the next iteration: $\\mathbf{u}^{\\text{prev}} \\leftarrow \\mathbf{u}^{\\text{curr}}$ and $\\mathbf{u}^{\\text{curr}} \\leftarrow \\mathbf{u}^{\\text{next}}$.\n5.  **Error Calculation**: After the loop concludes, determine the index $n_0 = \\lceil t_{\\mathrm{load}}/\\Delta t \\rceil$. Extract the reference energy $\\mathcal{E}^{n_0}$. Compute the maximum relative energy error $\\varepsilon_{\\max}$ for all time steps $n \\ge n_0$.\n6.  **Output**: Store the calculated $\\varepsilon_{\\max}$ for the test case. Repeat for all test cases and format the results as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_case(params):\n    \"\"\"\n    Solves the 1D wave equation for a single test case.\n    \"\"\"\n    # 1. Unpack parameters and calculate derived quantities\n    Ne, L, A, rho, E, T0, f, n_cycles, alpha, t_free = params\n\n    h = L / Ne  # Element length\n    c = np.sqrt(E / rho)  # Elastic wave speed\n    dt = alpha * h / c  # Time step\n\n    t_load = n_cycles / f\n    t_end = t_load + t_free\n    n_steps = int(np.ceil(t_end / dt))\n    \n    # 2. Assemble stiffness and mass matrices for free DOFs\n    \n    # Stiffness matrix K (Ne x Ne)\n    k_elem_stiff = E * A / h\n    K = np.zeros((Ne, Ne))\n    diag_val = 2 * k_elem_stiff\n    off_diag_val = -k_elem_stiff\n    \n    diag = np.full(Ne, diag_val)\n    diag[-1] = k_elem_stiff  # Last node is connected to only one element\n    \n    off_diag = np.full(Ne - 1, off_diag_val)\n    \n    K = np.diag(diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1)\n    \n    # Mass matrix M (lumped, diagonal)\n    m_diag = np.full(Ne, rho * A * h)\n    m_diag[-1] = 0.5 * rho * A * h  # End node has half the mass of an internal node\n    m_inv_diag = 1.0 / m_diag\n    \n    # 3. Initialization\n    u_prev = np.zeros(Ne) # Displacement at n-1\n    u_curr = np.zeros(Ne) # Displacement at n\n    \n    # Arrays to store energy history\n    kinetic_energy_hist = np.zeros(n_steps)\n    strain_energy_hist = np.zeros(n_steps)\n    \n    # Pre-compute constant for update rule\n    dt_sq = dt**2\n\n    # 4. Time integration loop\n    for n in range(n_steps):\n        t = n * dt\n        \n        # Assemble force vector f\n        f_vec = np.zeros(Ne)\n        if t = t_load:\n            # Sinusoidal traction applied at the rightmost free node\n            traction = T0 * np.sin(2 * np.pi * f * t)\n            f_vec[-1] = A * traction\n        \n        # Central difference update rule\n        # u_next = dt^2 * M_inv @ (f - K @ u_curr) + 2*u_curr - u_prev\n        # Since M_inv is diagonal, we use element-wise product.\n        internal_force = K @ u_curr\n        accel_term = m_inv_diag * (f_vec - internal_force)\n        u_next = dt_sq * accel_term + 2 * u_curr - u_prev\n\n        # Calculate energies at step n\n        # Strain energy: U^n = 1/2 * u_n^T * K * u_n\n        strain_energy_hist[n] = 0.5 * np.dot(u_curr, K @ u_curr)\n        \n        # Kinetic energy: T^n = 1/2 * v_n^T * M * v_n\n        v_n = (u_next - u_prev) / (2 * dt)\n        kinetic_energy_hist[n] = 0.5 * np.sum(m_diag * v_n**2)\n        \n        # Update displacements for the next step\n        u_prev = u_curr\n        u_curr = u_next\n        \n    # 5. Compute numerical energy error\n    total_energy_hist = kinetic_energy_hist + strain_energy_hist\n    \n    n0 = int(np.ceil(t_load / dt))\n    \n    # Ensure n0 is a valid index\n    if n0 = n_steps:\n      # This can happen if t_load is very close to t_end\n      # In this case, there are no steps after the load is removed to measure error.\n      return 0.0\n\n    energy_ref = total_energy_hist[n0]\n    \n    if energy_ref == 0.0:\n        # If reference energy is zero, drift is considered zero.\n        return 0.0\n        \n    energy_free_phase = total_energy_hist[n0:]\n    \n    relative_error = np.abs(energy_free_phase - energy_ref) / energy_ref\n    \n    eps_max = np.max(relative_error)\n    \n    return eps_max\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test A: Happy path\n        (50, 10.0, 1.0, 2000.0, 1.0e8, 1.0e5, 10.0, 5, 0.8, 1.0),\n        # Test B: Near stability boundary\n        (50, 10.0, 1.0, 2000.0, 1.0e8, 1.0e5, 15.0, 8, 0.99, 1.0),\n        # Test C: Coarser mesh and different material\n        (20, 10.0, 1.0, 1800.0, 8.0e7, 5.0e4, 5.0, 4, 0.6, 1.5),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n\n```", "id": "3523936"}, {"introduction": "In many real-world geomechanical simulations, the stability requirement of the explicit central difference method can lead to prohibitively small time steps, making simulations computationally expensive. One common technique to overcome this is \"mass scaling,\" where the material density is artificially increased to enlarge the stable time step. This advanced practice guides you through an evaluation of this technique [@problem_id:3523973]. You will implement metrics to assess how mass scaling distorts the system's dynamic response, learning to balance the practical need for computational efficiency against the essential requirement of physical fidelity.", "problem": "Consider a linear, undamped, small-strain, two-degree-of-freedom (DOF) soil column idealization used in computational geomechanics. Let the lumped mass matrix be $M\\in\\mathbb{R}^{2\\times 2}$, the symmetric positive-definite stiffness matrix be $K\\in\\mathbb{R}^{2\\times 2}$, and the external nodal force vector be $f(t)\\in\\mathbb{R}^{2}$. The dynamics follow Newton's second law $M\\,\\ddot{u}(t)+K\\,u(t)=f(t)$ with displacement $u(t)\\in\\mathbb{R}^{2}$, velocity $\\dot{u}(t)\\in\\mathbb{R}^{2}$, and acceleration $\\ddot{u}(t)\\in\\mathbb{R}^{2}$. Explicit time integration is to be performed using a second-order accurate central-difference scheme derived from finite difference approximations of $\\dot{u}(t)$ and $\\ddot{u}(t)$; do not assume any damping. From the generalized eigenproblem $K\\phi_i=\\omega_i^2 M\\phi_i$ (with angular frequencies $\\omega_i0$ and normalized modes $\\phi_i$), the maximum admissible explicit time step is bounded by the highest angular frequency. For computational stability in the explicit scheme, use a fraction of the critical time step inferred from this bound. Angles must be treated in radians.\n\nTo increase the stable explicit time step $\\Delta t$, mass scaling is sometimes applied: $M\\rightarrow \\gamma M$ for $\\gamma\\geq 1$. This uniformly reduces all angular frequencies and thus increases the critical time step. However, excessive scaling can distort the dynamic response. Your task is to evaluate candidate scaling factors $\\gamma$ using a principled metric that ensures acceptable fidelity of the dominant response.\n\nDefine the following quantities:\n\n- The kinetic energy at discrete time $t_n$ is $E_k(t_n)=\\frac{1}{2}\\,\\dot{u}(t_n)^{\\top} M\\,\\dot{u}(t_n)$ and the strain energy is $E_s(t_n)=\\frac{1}{2}\\,u(t_n)^{\\top} K\\,u(t_n)$.\n- The modal participation factor of mode $i$ under a static load direction $r\\in\\mathbb{R}^{2}$ is $\\nu_i=|\\phi_i^{\\top} M\\,r|$, and the normalized participation weight is $w_i=\\nu_i/\\sum_j \\nu_j$. Identify the dominant mode index $i^\\star$ as the mode with the largest $w_i$.\n- Let the frequency distortion measure be $d_f(\\gamma)=\\left|\\frac{\\omega_{i^\\star}(\\gamma)}{\\omega_{i^\\star}(1)}-1\\right|$, where $\\omega_{i^\\star}(\\gamma)$ is the dominant mode frequency after mass scaling $M\\rightarrow \\gamma M$.\n- Let the energy ratio metric be $R_{\\max}(\\gamma)=\\max_{n} \\frac{E_k(t_n)}{E_s(t_n)}$ over the simulated time window, computed using explicit central differences with the scaled mass and a stable time step fraction of the critical bound.\n\nBased on these, adopt the following acceptance criteria for a candidate $\\gamma$:\n- Frequency fidelity: $d_f(\\gamma)\\leq \\varepsilon_f$.\n- Energy balance: $R_{\\max}(\\gamma)\\leq \\beta_{\\max}$.\n- Modal participation retention: the change in the normalized participation weights between the unscaled and scaled systems, $\\max_i |w_i(\\gamma)-w_i(1)|$, does not exceed a small tolerance $\\tau_p$.\n\nImplement the explicit central-difference integration using the following physically grounded configuration and units, ensuring scientific realism:\n\n- Mass matrix $M=\\mathrm{diag}(m_1,m_2)$ with $m_1=20000\\,\\mathrm{kg}$ and $m_2=15000\\,\\mathrm{kg}$.\n- Stiffness parameters $k_1=1.0\\times 10^{8}\\,\\mathrm{N/m}$, $k_2=0.5\\times 10^{8}\\,\\mathrm{N/m}$, and\n  $$K=\\begin{bmatrix}k_1+k_2  -k_2 \\\\ -k_2  k_2\\end{bmatrix}.$$\n- Load direction $r=\\begin{bmatrix}0\\\\ 1\\end{bmatrix}$ and force time history $f(t)=q(t)\\,r$, where\n  $$q(t)=\\begin{cases}A\\,\\sin\\!\\left(\\frac{\\pi\\,t}{T_p}\\right),  0\\le t\\le T_p,\\\\ 0,  tT_p,\\end{cases}$$\n  with amplitude $A=1.0\\times 10^{5}\\,\\mathrm{N}$ and pulse duration $T_p=0.05\\,\\mathrm{s}$. Angles are in radians.\n- Initial conditions: $u(0)=\\begin{bmatrix}0\\\\0\\end{bmatrix}$ and $\\dot{u}(0)=\\begin{bmatrix}0\\\\0\\end{bmatrix}$.\n- Total simulation time $T_{\\mathrm{end}}=0.20\\,\\mathrm{s}$.\n\nAdopt the explicit time step $\\Delta t(\\gamma)=\\eta\\,\\Delta t_{\\mathrm{cr}}(\\gamma)$, where $\\Delta t_{\\mathrm{cr}}(\\gamma)$ is the critical time step bound computed from the maximum angular frequency of the system with scaled mass $\\gamma M$, and the fraction is $\\eta=0.95$.\n\nUse tolerances $\\varepsilon_f=0.10$ (dimensionless), $\\beta_{\\max}=0.60$ (dimensionless), and $\\tau_p=1.0\\times 10^{-12}$ (dimensionless). For each candidate $\\gamma$, perform the following steps:\n- Compute the generalized eigenpairs of $(K,\\gamma M)$ and $(K,M)$ needed for the metrics.\n- Determine $i^\\star$ using $w_i(1)$.\n- Compute $d_f(\\gamma)$.\n- Perform the explicit central-difference simulation with $\\gamma M$ and $\\Delta t(\\gamma)$ to obtain $R_{\\max}(\\gamma)$ over $[0,T_{\\mathrm{end}}]$.\n- Compute the participation change $\\max_i |w_i(\\gamma)-w_i(1)|$.\n\nReturn a boolean indicating whether $\\gamma$ is acceptable if and only if all three criteria are satisfied.\n\nTest Suite:\nEvaluate the acceptance for the following $\\gamma$ values:\n- $\\gamma_1=1.00$ (baseline, happy path),\n- $\\gamma_2=1.01$ (near-baseline, small scaling),\n- $\\gamma_3=1.21$ (moderate scaling, below the frequency tolerance bound),\n- $\\gamma_4=1.23456790$ (boundary case near the frequency tolerance limit),\n- $\\gamma_5=2.25$ (larger scaling),\n- $\\gamma_6=4.00$ (strong scaling, edge case).\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[\\text{result}_1,\\text{result}_2,\\text{result}_3]$). Each $\\text{result}_i$ must be a boolean corresponding to whether $\\gamma_i$ is acceptable under the specified metrics and tolerances. No additional text is permitted in the output. Physical units are specified above but the final outputs are dimensionless booleans.", "solution": "The provided problem requires a comprehensive validation of different mass scaling factors, $\\gamma$, for an explicit dynamic simulation of a two-degree-of-freedom (2-DOF) system. The validation is based on three criteria: modal participation retention, frequency fidelity of the dominant mode, and a dynamic energy balance. The system is governed by the second-order ordinary differential equation $M\\,\\ddot{u}(t)+K\\,u(t)=f(t)$, where $M$ is the mass matrix, $K$ is the stiffness matrix, $u(t)$ is the displacement vector, and $f(t)$ is the external force vector. We will methodically implement the checks for each given $\\gamma$.\n\nFirst, we establish the system's matrices based on the provided parameters. The mass matrix $M$ is a diagonal (lumped) matrix, and the stiffness matrix $K$ represents the coupling between the two degrees of freedom.\nThe unscaled mass matrix, for $\\gamma=1$, is $M_{\\mathrm{base}} = \\mathrm{diag}(m_1, m_2)$, where $m_1=20000\\,\\mathrm{kg}$ and $m_2=15000\\,\\mathrm{kg}$.\n$$ M_{\\mathrm{base}} = \\begin{bmatrix} 20000  0 \\\\ 0  15000 \\end{bmatrix} \\, \\mathrm{kg} $$\nThe stiffness matrix is constructed from $k_1=1.0\\times 10^{8}\\,\\mathrm{N/m}$ and $k_2=0.5\\times 10^{8}\\,\\mathrm{N/m}$ as:\n$$ K = \\begin{bmatrix} k_1+k_2  -k_2 \\\\ -k_2  k_2 \\end{bmatrix} = \\begin{bmatrix} 1.5\\times 10^8  -0.5\\times 10^8 \\\\ -0.5\\times 10^8  0.5\\times 10^8 \\end{bmatrix} \\, \\mathrm{N/m} $$\nMass scaling is applied as $M(\\gamma) = \\gamma M_{\\mathrm{base}}$.\n\nThe validation involves two main parts: a quasi-static analysis based on the system's eigenproperties and a full dynamic simulation using an explicit central-difference scheme.\n\nThe first step is to analyze the eigenstructure of both the unscaled ($\\gamma=1$) and scaled ($\\gamma$) systems. This is achieved by solving the generalized eigenproblem $K\\phi_i=\\omega_i^2 M\\phi_i$ for the angular frequencies $\\omega_i$ and eigenvectors (mode shapes) $\\phi_i$. The solution of this problem for $M=M(\\gamma)$ yields $\\omega_i(\\gamma)$ and $\\phi_i(\\gamma)$. The eigenvectors are normalized such that $\\phi_i^\\top M \\phi_j = \\delta_{ij}$, a standard mass-orthonormalization.\n\nThe first acceptance criterion is on modal participation retention. The modal participation factor $\\nu_i$ for a static load direction $r$ is $\\nu_i = |\\phi_i^{\\top} M\\,r|$, and the normalized weight is $w_i = \\nu_i/\\sum_j \\nu_j$. For the specific form of mass scaling $M \\to \\gamma M$, the eigenvectors $\\phi_i$ of the pencil $(K, M)$ are unchanged. The new eigenvectors $\\phi_i(\\gamma)$ are related to the unscaled ones $\\phi_i(1)$ by $\\phi_i(\\gamma) = \\phi_i(1)/\\sqrt{\\gamma}$ due to the mass-normalization convention. Consequently, the normalized participation weights are invariant: $w_i(\\gamma) = w_i(1)$. The check $\\max_i |w_i(\\gamma)-w_i(1)| \\le \\tau_p$ will thus be satisfied up to numerical precision, given $\\tau_p=1.0\\times 10^{-12}$.\n\nThe second criterion is frequency fidelity. The dominant mode, indexed by $i^\\star$, is the one with the highest participation weight $w_{i^\\star}(1)$. The mass scaling $\\gamma$ reduces all angular frequencies by a factor of $1/\\sqrt{\\gamma}$, i.e., $\\omega_i(\\gamma) = \\omega_i(1)/\\sqrt{\\gamma}$. The frequency distortion metric is $d_f(\\gamma)=\\left|\\frac{\\omega_{i^\\star}(\\gamma)}{\\omega_{i^\\star}(1)}-1\\right| = |1/\\sqrt{\\gamma}-1|$. A candidate $\\gamma$ is acceptable only if $d_f(\\gamma) \\leq \\varepsilon_f$, where $\\varepsilon_f=0.10$. This imposes an upper bound on $\\gamma$: $\\gamma \\le (1/(1-\\varepsilon_f))^2 \\approx 1.2345679$.\n\nThe third criterion involves the energy balance, assessed via dynamic simulation. The system's response is computed using the explicit second-order central-difference method. The update rule for the displacement vector $u$ at time step $n+1$ is derived from finite difference approximations to the equation of motion:\n$$ u_{n+1} = (\\Delta t)^2 M(\\gamma)^{-1} (f_n - K u_n) + 2u_n - u_{n-1} $$\nwhere $u_n = u(t_n)$, $f_n = f(t_n)$, and $\\Delta t$ is the time step. The scheme is initiated using the initial conditions $u(0)=0$ and $\\dot{u}(0)=0$. This leads to an initial acceleration $\\ddot{u}(0)=0$ and a virtual displacement $u_{-1}=u_0=0$. The simulation proceeds for a total time of $T_{\\mathrm{end}}=0.20\\,\\mathrm{s}$. The time step $\\Delta t(\\gamma)$ must be chosen to ensure numerical stability. The critical time step for this scheme is $\\Delta t_{\\mathrm{cr}}(\\gamma) = 2/\\omega_{\\max}(\\gamma)$, where $\\omega_{\\max}(\\gamma)$ is the highest natural frequency of the scaled system. We use a stable time step $\\Delta t(\\gamma) = \\eta\\,\\Delta t_{\\mathrm{cr}}(\\gamma)$ with $\\eta=0.95$.\n\nThroughout the simulation, we monitor the kinetic and strain energies at each time step $t_n$:\n$$ E_k(t_n)=\\frac{1}{2}\\,\\dot{u}(t_n)^{\\top} M(\\gamma)\\,\\dot{u}(t_n) \\quad \\text{and} \\quad E_s(t_n)=\\frac{1}{2}\\,u(t_n)^{\\top} K\\,u(t_n) $$\nThe velocity $\\dot{u}(t_n)$ is computed using a central difference: $\\dot{u}_n = (u_{n+1} - u_{n-1})/(2\\Delta t)$. The energy ratio metric is the maximum ratio of kinetic to strain energy observed during the simulation, $R_{\\max}(\\gamma)=\\max_{n} \\{E_k(t_n)/E_s(t_n)\\}$. This ratio is computed only when $E_s(t_n)$ is non-negligible to avoid division by zero. The acceptance criterion is $R_{\\max}(\\gamma) \\leq \\beta_{\\max}$, with $\\beta_{\\max}=0.60$.\n\nA scaling factor $\\gamma$ is deemed acceptable if and only if all three criteria are met. The implementation will evaluate these criteria sequentially for each test case $\\gamma_i$, returning `False` as soon as a criterion is violated for computational efficiency.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Main function to evaluate mass scaling factors and print results.\n    \"\"\"\n    \n    # Define physical configuration and simulation parameters\n    m1 = 20000.0\n    m2 = 15000.0\n    k1 = 1.0e8\n    k2 = 0.5e8\n    \n    M_base = np.diag([m1, m2])\n    K = np.array([[k1 + k2, -k2], [-k2, k2]])\n    \n    r = np.array([0., 1.])\n    A = 1.0e5\n    T_p = 0.05\n    T_end = 0.20\n    \n    # Define time integration and acceptance criteria parameters\n    eta = 0.95\n    eps_f = 0.10\n    beta_max = 0.60\n    tau_p = 1.0e-12\n\n    test_cases = [1.00, 1.01, 1.21, 1.23456790, 2.25, 4.00]\n\n    def q_force(t, A_amp, T_pulse):\n        \"\"\"Calculates the time-dependent part of the force.\"\"\"\n        if 0 = t = T_pulse:\n            return A_amp * np.sin(np.pi * t / T_pulse)\n        return 0.0\n\n    def get_eigenpairs(K_mat, M_mat):\n        \"\"\"\n        Solves the generalized eigenvalue problem K*phi = omega^2*M*phi.\n        Returns angular frequencies (omega) and mass-normalized eigenvectors (phi).\n        \"\"\"\n        eigvals, eigvecs = eigh(K_mat, M_mat)\n        omegas = np.sqrt(eigvals)\n        return omegas, eigvecs\n\n    def is_acceptable(gamma, M_base_mat, K_mat, r_vec, A_amp, T_pulse, T_sim_end, \n                      eta_frac, eps_f_tol, beta_max_tol, tau_p_tol):\n        \"\"\"\n        Checks if a given mass scaling factor gamma is acceptable based on three criteria.\n        \"\"\"\n        # --- 1. Eigen-analysis and Fidelity Checks ---\n        \n        # Unscaled system (gamma=1)\n        omegas_1, phis_1 = get_eigenpairs(K_mat, M_base_mat)\n        nu_1 = np.array([np.abs(phi.T @ M_base_mat @ r_vec) for phi in phis_1.T])\n        w_1 = nu_1 / np.sum(nu_1)\n        \n        # Scaled system\n        M_scaled = gamma * M_base_mat\n        omegas_g, phis_g = get_eigenpairs(K_mat, M_scaled)\n\n        # Criterion 3: Modal participation retention\n        nu_g = np.array([np.abs(phi.T @ M_scaled @ r_vec) for phi in phis_g.T])\n        w_g = nu_g / np.sum(nu_g)\n        participation_change = np.max(np.abs(w_g - w_1))\n        if participation_change  tau_p_tol:\n            return False\n            \n        # Criterion 1: Frequency fidelity\n        i_star = np.argmax(w_1)\n        omega_star_1 = omegas_1[i_star]\n        omega_star_g = omegas_g[i_star]\n        d_f = np.abs(omega_star_g / omega_star_1 - 1.0)\n        if d_f  eps_f_tol:\n            return False\n\n        # --- 2. Dynamic Simulation for Energy Check ---\n        omega_max_g = np.max(omegas_g)\n        dt_crit = 2.0 / omega_max_g\n        dt = eta_frac * dt_crit\n        num_steps = int(np.ceil(T_sim_end / dt))\n        \n        M_inv = np.linalg.inv(M_scaled)\n        \n        # Initial conditions: u(0)=0, u_dot(0)=0 = uddot(0)=0.\n        # Startup u(-1) = u(0) - dt*udot(0) + dt^2/2*uddot(0) = 0.\n        u_curr = np.zeros(2)\n        u_prev = np.zeros(2)\n        \n        R_max = 0.0\n        \n        for n in range(num_steps + 1):\n            t = n * dt\n            \n            # Force at current time step\n            f_n = q_force(t, A_amp, T_pulse) * r_vec\n            \n            # Central Difference displacement update\n            u_next = dt**2 * M_inv @ (f_n - K_mat @ u_curr) + 2 * u_curr - u_prev\n            \n            # Velocity at current step n\n            u_dot_curr = (u_next - u_prev) / (2.0 * dt)\n            \n            # Energies at current step n\n            E_s = 0.5 * u_curr.T @ K_mat @ u_curr\n            E_k = 0.5 * u_dot_curr.T @ M_scaled @ u_dot_curr\n            \n            # Update max energy ratio, avoiding division by zero\n            if E_s  1e-15:\n                R_n = E_k / E_s\n                if R_n  R_max:\n                    R_max = R_n\n\n            # Advance time step\n            u_prev, u_curr = u_curr, u_next\n        \n        # Criterion 2: Energy balance\n        if R_max  beta_max_tol:\n            return False\n            \n        # All criteria passed\n        return True\n\n    results = []\n    for gamma in test_cases:\n        is_acc = is_acceptable(gamma, M_base, K, r, A, T_p, T_end, eta, eps_f, beta_max, tau_p)\n        results.append(is_acc)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda b: str(b).lower(), results))}]\")\n\nsolve()\n```", "id": "3523973"}]}