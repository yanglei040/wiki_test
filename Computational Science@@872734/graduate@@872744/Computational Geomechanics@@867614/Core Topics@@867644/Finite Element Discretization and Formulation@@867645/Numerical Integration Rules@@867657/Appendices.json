{"hands_on_practices": [{"introduction": "To truly master numerical integration, we must move beyond simply applying pre-defined formulas. This first practice takes you behind the curtain to derive the nodes and weights of a three-point Gauss-Legendre quadrature rule from scratch [@problem_id:3546652]. By enforcing exactness for a basis of polynomials, you will construct one of the most efficient and powerful tools in numerical analysis, gaining a deep appreciation for why it achieves such a high degree of precision.", "problem": "In computational geomechanics, integrals over the parent (or natural) coordinate domain are routinely evaluated to assemble element matrices in the Finite Element Method (FEM). Consider the task of evaluating integrals on the standard parent interval $[-1,1]$ with weight function $w(\\xi)=1$, such as those arising from isoparametric mapping in a one-dimensional element. A fundamental approach is Gaussian quadrature, which seeks nodes $\\{\\xi_{i}\\}$ and positive weights $\\{W_{i}\\}$ such that the quadrature $\\sum_{i=1}^{n} W_{i} f(\\xi_{i})$ is exact for polynomials up to a target degree.\n\nStarting from the definition of Gaussian quadrature on the interval $[-1,1]$ with unit weight and the requirement that an $n$-point rule be exact for all polynomials of degree up to $2n-1$, construct explicitly the $n=3$ Gauss–Legendre nodes and weights by enforcing exactness on a suitable basis of even-power polynomials. You must not use any tabulated formulas; derive the nodes and weights directly by symmetry and moment matching.\n\nThen, using your constructed nodes and weights, verify by direct substitution that the resulting quadrature integrates $p(\\xi)=\\xi^{5}$ exactly over $[-1,1]$.\n\nProvide as your final answer the single real number obtained when applying your $n=3$ Gauss–Legendre quadrature rule to $\\int_{-1}^{1} \\xi^{5} \\, d\\xi$. No rounding is required. No units are needed.", "solution": "The foundational base for Gaussian quadrature on $[-1,1]$ with unit weight is as follows: an $n$-point rule seeks nodes $\\{\\xi_{i}\\}_{i=1}^{n}$ and weights $\\{W_{i}\\}_{i=1}^{n}$ for which\n$$\n\\int_{-1}^{1} f(\\xi)\\, \\mathrm{d}\\xi \\approx \\sum_{i=1}^{n} W_{i} f(\\xi_{i}),\n$$\nand the rule is exact for all polynomials $f$ with $\\deg(f) \\leq 2n-1$. For $n=3$, exactness up to degree $5$ is required.\n\nBecause the weight is symmetric and the interval is symmetric, the optimal nodes and weights are symmetric. We therefore assume the structure\n$$\n\\xi_{1}=-a,\\quad \\xi_{2}=0,\\quad \\xi_{3}=a,\\qquad W_{1}=W_{3}=w,\\quad W_{2}=w_{0},\n$$\nwith $a>0$, $w>0$, and $w_{0}>0$. Exactness for all polynomials up to degree $5$ can be enforced by matching the moments for the even powers $\\xi^{0}$, $\\xi^{2}$, and $\\xi^{4}$, since the odd-power moments over $[-1,1]$ vanish and yield no additional information.\n\nThe exact even moments over $[-1,1]$ are\n$$\n\\int_{-1}^{1} \\xi^{0} \\, \\mathrm{d}\\xi = 2,\\qquad \\int_{-1}^{1} \\xi^{2} \\, \\mathrm{d}\\xi = \\frac{2}{3},\\qquad \\int_{-1}^{1} \\xi^{4} \\, \\mathrm{d}\\xi = \\frac{2}{5}.\n$$\nImposing quadrature exactness on $\\xi^{0}$, $\\xi^{2}$, and $\\xi^{4}$ yields the system\n$$\n\\text{(i)}\\quad w_{0}+2w=2,\n$$\n$$\n\\text{(ii)}\\quad w_{0}\\cdot 0^{2}+w\\cdot (-a)^{2}+w\\cdot a^{2}=\\frac{2}{3}\\;\\;\\Longrightarrow\\;\\;2wa^{2}=\\frac{2}{3},\n$$\n$$\n\\text{(iii)}\\quad w_{0}\\cdot 0^{4}+w\\cdot (-a)^{4}+w\\cdot a^{4}=\\frac{2}{5}\\;\\;\\Longrightarrow\\;\\;2wa^{4}=\\frac{2}{5}.\n$$\nFrom equation (ii) we obtain\n$$\nw=\\frac{1}{3a^{2}}.\n$$\nSubstitute this into equation (iii):\n$$\n2\\left(\\frac{1}{3a^{2}}\\right)a^{4}=\\frac{2}{5}\\;\\;\\Longrightarrow\\;\\;\\frac{2}{3}a^{2}=\\frac{2}{5}\\;\\;\\Longrightarrow\\;\\;a^{2}=\\frac{3}{5}.\n$$\nThus $a=\\sqrt{\\frac{3}{5}}$. Then\n$$\nw=\\frac{1}{3a^{2}}=\\frac{1}{3\\cdot \\frac{3}{5}}=\\frac{5}{9}.\n$$\nFinally, use equation (i) to obtain $w_{0}$:\n$$\nw_{0}=2-2w=2-\\frac{10}{9}=\\frac{8}{9}.\n$$\nTherefore, the $n=3$ Gauss–Legendre nodes and weights on $[-1,1]$ are\n$$\n\\xi_{1}=-\\sqrt{\\frac{3}{5}},\\quad \\xi_{2}=0,\\quad \\xi_{3}=\\sqrt{\\frac{3}{5}},\\qquad W_{1}=W_{3}=\\frac{5}{9},\\quad W_{2}=\\frac{8}{9}.\n$$\n\nWe now verify exact integration for $p(\\xi)=\\xi^{5}$. The exact integral is\n$$\n\\int_{-1}^{1} \\xi^{5} \\, \\mathrm{d}\\xi=0,\n$$\nbecause $\\xi^{5}$ is an odd function on the symmetric interval $[-1,1]$. The quadrature evaluation with the derived nodes and weights is\n$$\n\\sum_{i=1}^{3} W_{i} p(\\xi_{i})=w\\left[(-a)^{5}+a^{5}\\right]+w_{0}\\cdot 0^{5}=w\\left[-a^{5}+a^{5}\\right]+0=0,\n$$\nwhich coincides with the exact integral. Hence, the $n=3$ Gauss–Legendre rule integrates $p(\\xi)=\\xi^{5}$ exactly, consistent with the degree of exactness $2n-1=5$.\n\nThe final requested quantity is the single real number obtained by applying the constructed $n=3$ Gauss–Legendre rule to $\\int_{-1}^{1} \\xi^{5}\\, \\mathrm{d}\\xi$, which is $0$.", "answer": "$$\\boxed{0}$$", "id": "3546652"}, {"introduction": "While Gaussian quadrature is optimal, rules based on equally spaced points, known as Newton-Cotes rules, are often more practical for integrating experimental data. This exercise [@problem_id:3546656] grounds the theory in a tangible geomechanics scenario: calculating plastic work from a stress-strain curve. You will not only apply the simplest of these rules but also derive its error term, a crucial skill for understanding the reliability of any numerical approximation.", "problem": "A uniaxial monotonic plastic loading test on a geomaterial produces a measured plastic Cauchy stress–plastic strain curve $f(\\epsilon)$ over the strain interval $\\left[\\epsilon_{a},\\epsilon_{b}\\right]$. The plastic work per unit volume accumulated over this interval is defined by the integral of stress with respect to plastic strain,\n$$\nW_{p} \\;=\\; \\int_{\\epsilon_{a}}^{\\epsilon_{b}} f(\\epsilon)\\,\\mathrm{d}\\epsilon.\n$$\nYou are given two measurements of the plastic stress at the endpoints:\n$$\n\\epsilon_{a} \\;=\\; 0.012,\\qquad f(\\epsilon_{a}) \\;=\\; 210\\ \\text{MPa},\\qquad \\epsilon_{b} \\;=\\; 0.028,\\qquad f(\\epsilon_{b}) \\;=\\; 365\\ \\text{MPa}.\n$$\nAssume that $f$ is twice continuously differentiable on $\\left[\\epsilon_{a},\\epsilon_{b}\\right]$ and that an a priori bound on the curvature is available from a calibrated constitutive model,\n$$\n\\max_{\\epsilon\\in[\\epsilon_{a},\\epsilon_{b}]} \\left| f''(\\epsilon) \\right| \\;\\le\\; M,\\qquad M \\;=\\; 6.00\\times 10^{4}\\ \\text{MPa}.\n$$\nUsing only the definition of plastic work and the concept of polynomial interpolation with its remainder (do not quote any pre-stated quadrature formulas), proceed as follows:\n- Construct a one-panel Newton–Cotes rule by integrating the unique linear interpolant of $f$ through $\\left(\\epsilon_{a},f(\\epsilon_{a})\\right)$ and $\\left(\\epsilon_{b},f(\\epsilon_{b})\\right)$ to obtain an approximation to $W_{p}$.\n- Starting from the second-derivative remainder of the linear interpolation and suitable integral mean-value arguments, derive the corresponding error expression involving $f''(\\xi)$ for some $\\xi\\in(\\epsilon_{a},\\epsilon_{b})$, and then produce an upper bound on the magnitude of the error in terms of $M$.\n- Evaluate numerically the quadrature estimate of $W_{p}$ and the bound on the absolute error using the given data.\n\nExpress both the quadrature estimate and the absolute error bound in $\\text{kJ}/\\text{m}^{3}$. Round both numbers to four significant figures. Report your final answer as two numbers in the order: first the quadrature estimate of $W_{p}$, then the absolute error bound.", "solution": "The problem requires the approximation of the plastic work per unit volume, $W_p$, defined by the integral $W_{p} = \\int_{\\epsilon_{a}}^{\\epsilon_{b}} f(\\epsilon)\\,\\mathrm{d}\\epsilon$, and a corresponding error bound. This will be accomplished by deriving a one-panel Newton-Cotes quadrature rule from first principles of polynomial interpolation.\n\nThe given data are:\n- Strain interval endpoints: $\\epsilon_{a} = 0.012$ and $\\epsilon_{b} = 0.028$.\n- Stress values at the endpoints: $f(\\epsilon_{a}) = 210 \\text{ MPa}$ and $f(\\epsilon_{b}) = 365 \\text{ MPa}$.\n- A bound on the second derivative of the stress-strain function $f(\\epsilon)$: $\\max_{\\epsilon\\in[\\epsilon_{a},\\epsilon_{b}]} | f''(\\epsilon) | \\le M$, where $M = 6.00 \\times 10^{4} \\text{ MPa}$.\n\nThe requested results are the numerical value of the integral approximation and its absolute error bound, both expressed in units of $\\text{kJ}/\\text{m}^{3}$ and rounded to four significant figures.\n\n**Part 1: Construction of the Quadrature Rule**\n\nWe construct a linear polynomial, $p_1(\\epsilon)$, that interpolates the function $f(\\epsilon)$ at the points $(\\epsilon_{a}, f(\\epsilon_{a}))$ and $(\\epsilon_{b}, f(\\epsilon_{b}))$. Using the Lagrange basis polynomials, this interpolant is unique and is given by:\n$$\np_1(\\epsilon) = f(\\epsilon_{a}) \\frac{\\epsilon - \\epsilon_{b}}{\\epsilon_{a} - \\epsilon_{b}} + f(\\epsilon_{b}) \\frac{\\epsilon - \\epsilon_{a}}{\\epsilon_b - \\epsilon_a}\n$$\nThe Newton-Cotes rule is obtained by integrating this interpolating polynomial over the interval $[\\epsilon_{a}, \\epsilon_{b}]$ to approximate the integral of $f(\\epsilon)$. Let this approximation be $W_{p,h}$.\n$$\nW_{p,h} = \\int_{\\epsilon_{a}}^{\\epsilon_{b}} p_1(\\epsilon) \\,\\mathrm{d}\\epsilon = f(\\epsilon_{a}) \\int_{\\epsilon_{a}}^{\\epsilon_{b}} \\frac{\\epsilon - \\epsilon_{b}}{\\epsilon_{a} - \\epsilon_{b}} \\,\\mathrm{d}\\epsilon + f(\\epsilon_{b}) \\int_{\\epsilon_{a}}^{\\epsilon_{b}} \\frac{\\epsilon - \\epsilon_{a}}{\\epsilon_b - \\epsilon_a} \\,\\mathrm{d}\\epsilon\n$$\nLet $h = \\epsilon_b - \\epsilon_a$. The first integral is:\n$$\n\\int_{\\epsilon_{a}}^{\\epsilon_{b}} \\frac{\\epsilon - \\epsilon_{b}}{-h} \\,\\mathrm{d}\\epsilon = -\\frac{1}{h} \\left[ \\frac{(\\epsilon - \\epsilon_{b})^2}{2} \\right]_{\\epsilon_{a}}^{\\epsilon_{b}} = -\\frac{1}{h} \\left( 0 - \\frac{(\\epsilon_{a} - \\epsilon_{b})^2}{2} \\right) = \\frac{1}{h} \\frac{(-h)^2}{2} = \\frac{h}{2}\n$$\nThe second integral is:\n$$\n\\int_{\\epsilon_{a}}^{\\epsilon_{b}} \\frac{\\epsilon - \\epsilon_{a}}{h} \\,\\mathrm{d}\\epsilon = \\frac{1}{h} \\left[ \\frac{(\\epsilon - \\epsilon_{a})^2}{2} \\right]_{\\epsilon_{a}}^{\\epsilon_{b}} = \\frac{1}{h} \\left( \\frac{(\\epsilon_{b} - \\epsilon_{a})^2}{2} - 0 \\right) = \\frac{1}{h} \\frac{h^2}{2} = \\frac{h}{2}\n$$\nSubstituting these results back, we obtain the quadrature formula:\n$$\nW_{p,h} = f(\\epsilon_{a}) \\frac{h}{2} + f(\\epsilon_{b}) \\frac{h}{2} = \\frac{\\epsilon_b - \\epsilon_a}{2} [f(\\epsilon_a) + f(\\epsilon_b)]\n$$\nThis is the one-panel Newton-Cotes rule, more commonly known as the trapezoidal rule.\n\n**Part 2: Derivation of the Error Expression and Bound**\n\nThe problem requires deriving the error term from the remainder of the linear interpolation. For a function $f$ that is twice continuously differentiable, the error of linear interpolation is given by:\n$$\nE_{1}(\\epsilon) = f(\\epsilon) - p_1(\\epsilon) = \\frac{f''(\\xi_{\\epsilon})}{2!} (\\epsilon - \\epsilon_{a})(\\epsilon - \\epsilon_{b})\n$$\nfor some $\\xi_{\\epsilon} \\in (\\epsilon_{a}, \\epsilon_{b})$. The error in the integral, $E_{W_p}$, is the integral of this interpolation error:\n$$\nE_{W_p} = W_p - W_{p,h} = \\int_{\\epsilon_{a}}^{\\epsilon_{b}} (f(\\epsilon) - p_1(\\epsilon)) \\,\\mathrm{d}\\epsilon = \\int_{\\epsilon_{a}}^{\\epsilon_{b}} \\frac{f''(\\xi_{\\epsilon})}{2} (\\epsilon - \\epsilon_{a})(\\epsilon - \\epsilon_{b}) \\,\\mathrm{d}\\epsilon\n$$\nThe quadratic term $(\\epsilon - \\epsilon_{a})(\\epsilon - \\epsilon_{b})$ is non-positive for all $\\epsilon \\in [\\epsilon_{a}, \\epsilon_{b}]$. Since $f''$ is continuous on $[\\epsilon_{a}, \\epsilon_{b}]$, by the generalized Mean Value Theorem for integrals, there exists a value $\\zeta \\in (\\epsilon_{a}, \\epsilon_{b})$ such that:\n$$\nE_{W_p} = \\frac{f''(\\zeta)}{2} \\int_{\\epsilon_{a}}^{\\epsilon_{b}} (\\epsilon - \\epsilon_{a})(\\epsilon - \\epsilon_{b}) \\,\\mathrm{d}\\epsilon\n$$\nWe evaluate the integral part. Let $\\epsilon = \\epsilon_a + u$, so $\\mathrm{d}\\epsilon = \\mathrm{d}u$. The integration limits change from $\\epsilon \\in [\\epsilon_a, \\epsilon_b]$ to $u \\in [0, h]$, where $h = \\epsilon_b - \\epsilon_a$.\n$$\n\\int_{\\epsilon_{a}}^{\\epsilon_{b}} (\\epsilon - \\epsilon_{a})(\\epsilon - \\epsilon_{b}) \\,\\mathrm{d}\\epsilon = \\int_{0}^{h} u(u-h) \\,\\mathrm{d}u = \\int_{0}^{h} (u^2 - hu) \\,\\mathrm{d}u = \\left[ \\frac{u^3}{3} - \\frac{hu^2}{2} \\right]_{0}^{h} = \\frac{h^3}{3} - \\frac{h^3}{2} = -\\frac{h^3}{6}\n$$\nSubstituting this back into the expression for $E_{W_p}$:\n$$\nE_{W_p} = \\frac{f''(\\zeta)}{2} \\left( -\\frac{h^3}{6} \\right) = -\\frac{h^3}{12} f''(\\zeta) = -\\frac{(\\epsilon_b - \\epsilon_a)^3}{12} f''(\\zeta)\n$$\nTo find an upper bound on the magnitude of the error, we take the absolute value:\n$$\n|E_{W_p}| = \\left| -\\frac{(\\epsilon_b - \\epsilon_a)^3}{12} f''(\\zeta) \\right| = \\frac{(\\epsilon_b - \\epsilon_a)^3}{12} |f''(\\zeta)|\n$$\nUsing the given a priori bound $|f''(\\epsilon)| \\le M$ for all $\\epsilon \\in [\\epsilon_a, \\epsilon_b]$, we have $|f''(\\zeta)| \\le M$. The absolute error bound, denoted $E_{abs\\_max}$, is therefore:\n$$\nE_{abs\\_max} = \\frac{(\\epsilon_b - \\epsilon_a)^3}{12} M\n$$\n\n**Part 3: Numerical Evaluation**\n\nWe now substitute the given numerical values. First, we determine the interval width:\n$$\nh = \\epsilon_b - \\epsilon_a = 0.028 - 0.012 = 0.016\n$$\nThe quadrature estimate for the plastic work is:\n$$\nW_{p,h} = \\frac{h}{2} [f(\\epsilon_a) + f(\\epsilon_b)] = \\frac{0.016}{2} (210 \\text{ MPa} + 365 \\text{ MPa}) = 0.008 \\times 575 \\text{ MPa} = 4.6 \\text{ MPa}\n$$\nThe unit of stress (MPa) multiplied by dimensionless strain gives a result in MPa. We must convert this to the requested units of $\\text{kJ}/\\text{m}^{3}$.\n$$\n1 \\text{ MPa} = 10^6 \\text{ Pa} = 10^6 \\frac{\\text{N}}{\\text{m}^2} = 10^6 \\frac{\\text{J}}{\\text{m}^3} = 10^3 \\frac{\\text{kJ}}{\\text{m}^3}\n$$\nSo, $W_{p,h} = 4.6 \\times 10^3 \\text{ kJ}/\\text{m}^3 = 4600 \\text{ kJ}/\\text{m}^3$. Rounding to four significant figures gives $4600$.\n\nNext, we evaluate the absolute error bound:\n$$\nE_{abs\\_max} = \\frac{h^3}{12} M = \\frac{(0.016)^3}{12} \\times (6.00 \\times 10^4 \\text{ MPa})\n$$\n$$\nE_{abs\\_max} = \\frac{4.096 \\times 10^{-6}}{12} \\times (6.00 \\times 10^4) \\text{ MPa} = (4.096 \\times 10^{-6}) \\times (5.00 \\times 10^3) \\text{ MPa}\n$$\n$$\nE_{abs\\_max} = 20.48 \\times 10^{-3} \\text{ MPa} = 0.02048 \\text{ MPa}\n$$\nConverting to the requested units:\n$$\nE_{abs\\_max} = 0.02048 \\times 10^3 \\text{ kJ}/\\text{m}^3 = 20.48 \\text{ kJ}/\\text{m}^3\n$$\nThis value is already given to four significant figures.\n\nThe final numerical results are an estimated plastic work of $W_{p,h} = 4600 \\text{ kJ}/\\text{m}^3$ and an absolute error bound of $E_{abs\\_max} = 20.48 \\text{ kJ}/\\text{m}^3$.", "answer": "$$\n\\boxed{\\begin{pmatrix} 4600 & 20.48 \\end{pmatrix}}\n$$", "id": "3546656"}, {"introduction": "Real-world computational geomechanics problems are rarely uniform; they often feature localized regions of high strain or stress gradients where accuracy is critical. This final practice challenges you to bridge theory and application by developing a computational experiment to compare the efficiency and accuracy of different quadrature schemes in two dimensions [@problem_id:3546638]. By implementing a hybrid strategy that adapts the integration rule based on local behavior, you will tackle the core engineering trade-off between computational cost and numerical precision.", "problem": "You are to design and implement a hybrid numerical integration scheme for a synthetic finite element integration task inspired by a strip footing bearing capacity problem in computational geomechanics. The goal is to approximate a two-dimensional integral of a scalar integrand that depends on a prescribed \"strain-like\" field with a steep gradient near the footing region and to compare three quadrature strategies: a pure Gauss quadrature, a pure Newton–Cotes quadrature, and a hybrid rule that switches based on a gradient magnitude criterion. The problem must be implemented as a complete, runnable program.\n\nConsider the rectangular domain $\\mathcal{D} = \\{(x,y) \\mid x \\in [-B/2,B/2], y \\in [0,H]\\}$, discretized into a uniform grid of $N_x \\times N_y$ axis-aligned rectangular elements. Define the synthetic \"strain-like\" scalar field $\\varepsilon(x,y)$ and the scalar integrand $f(x,y)$ as\n$$\n\\varepsilon(x,y) = A \\tanh\\!\\big(\\kappa\\, r(x,y)\\big), \\quad r(x,y) = \\exp\\!\\Big(-\\big(\\tfrac{x}{\\sigma_x}\\big)^2\\Big)\\,\\exp\\!\\Big(-\\tfrac{y}{\\sigma_y}\\Big), \\quad f(x,y) = \\big(1+\\beta y\\big)\\,\\varepsilon(x,y)^2,\n$$\nwhere $A>0$, $\\kappa>0$, $\\sigma_x>0$, $\\sigma_y>0$, and $\\beta \\ge 0$ are given parameters. This choice produces a localized, steep \"failure-like\" gradient beneath the footing line $x=0$, with decay in the $x$-direction and the $y$-direction.\n\nLet the target integral be\n$$\nI = \\iint_{\\mathcal{D}} f(x,y)\\, \\mathrm{d}x\\, \\mathrm{d}y.\n$$\n\nApproximate $I$ by summing element-wise contributions computed via three quadrature strategies on the reference square $[-1,1]\\times[-1,1]$ mapped affinely to each physical element:\n- Pure Gauss quadrature: tensor-product Gauss–Legendre with $2 \\times 2$ points. In one dimension, nodes $\\xi \\in \\{-1/\\sqrt{3}, +1/\\sqrt{3}\\}$ with weights $w=1$.\n- Pure Newton–Cotes quadrature: tensor-product closed Newton–Cotes Simpson with $3 \\times 3$ points. In one dimension on $[-1,1]$, nodes $\\xi \\in \\{-1,0,+1\\}$ with weights $w \\in \\{\\tfrac{1}{3},\\tfrac{4}{3},\\tfrac{1}{3}\\}$.\n- Hybrid rule: on each element, evaluate the \"switching criterion\" based on the magnitude of the gradient of $\\varepsilon(x,y)$ and use Gauss quadrature on \"high-gradient\" elements, Newton–Cotes otherwise. Specifically, define\n$$\n\\nabla \\varepsilon(x,y) = A \\kappa\\, \\operatorname{sech}^2\\!\\big(\\kappa r(x,y)\\big)\\, \\nabla r(x,y), \\quad \\nabla r(x,y) = r(x,y)\\,\\Big(-\\tfrac{2x}{\\sigma_x^2},\\; -\\tfrac{1}{\\sigma_y}\\Big),\n$$\nand denote $g(x,y)=\\|\\nabla\\varepsilon(x,y)\\|_2$. For a given threshold $T>0$, declare an element \"high-gradient\" if $\\max g(x,y) > T$ over the $3 \\times 3$ tensor grid of points $\\xi,\\eta \\in \\{-1,0,+1\\}$ mapped to that element; otherwise, declare it \"low-gradient\". Use Gauss $2\\times 2$ quadrature on high-gradient elements and Newton–Cotes Simpson $3\\times 3$ on low-gradient elements.\n\nUse an affine mapping from the reference coordinates $(\\xi,\\eta)\\in[-1,1]^2$ to the physical coordinates $(x,y)$ of each element, with Jacobian determinant $J = \\frac{\\Delta x}{2}\\frac{\\Delta y}{2}$, where $\\Delta x$ and $\\Delta y$ are the element sizes in the $x$ and $y$ directions. For each element, the quadrature approximation takes the form\n$$\nI_e \\approx J \\sum_{i} \\sum_{j} w_i w_j \\, f\\big(x(\\xi_i), y(\\eta_j)\\big),\n$$\nwhere $(\\xi_i,w_i)$ and $(\\eta_j,w_j)$ are the one-dimensional nodes and weights of the chosen rule.\n\nFor a high-accuracy reference integral $I_{\\mathrm{ref}}$, use tensor-product Gauss–Legendre with $5 \\times 5$ points per element, then sum over all elements.\n\nDefine the following cost model to compare efficiency:\n- Let $n_f$ be the total number of evaluations of $f(x,y)$ used by a quadrature across all elements.\n- Let $n_g$ be the total number of evaluations of $g(x,y)$ used for the switching criterion across all elements (count each evaluation of $g$ at a point as one unit).\n- Given a nonnegative cost weight $c_{\\mathrm{grad}}$, define the total cost as $C = n_f + c_{\\mathrm{grad}}\\, n_g$.\n\nTasks:\n1. Implement the above in a single program that computes $I_{\\mathrm{ref}}$ and, for each of the three methods (pure Gauss, pure Newton–Cotes, hybrid), computes the approximate integral $I_{\\mathrm{M}}$, the absolute error $E_{\\mathrm{M}} = |I_{\\mathrm{M}} - I_{\\mathrm{ref}}|$, and the total cost $C_{\\mathrm{M}}$.\n2. Use the following test suite of parameter sets. Each test case is a tuple $\\big(B,H,N_x,N_y,A,\\kappa,\\sigma_x,\\sigma_y,\\beta,T,c_{\\mathrm{grad}}\\big)$:\n   - Case $1$: $\\big(2.0,\\,1.0,\\,20,\\,10,\\,0.05,\\,6.0,\\,0.4,\\,0.3,\\,0.2,\\,0.05,\\,1.0\\big)$.\n   - Case $2$: $\\big(2.0,\\,1.0,\\,40,\\,20,\\,0.5,\\,20.0,\\,0.25,\\,0.2,\\,0.4,\\,0.2,\\,1.0\\big)$.\n   - Case $3$ (threshold forcing all elements to Gauss): $\\big(2.0,\\,1.0,\\,30,\\,15,\\,0.5,\\,20.0,\\,0.25,\\,0.2,\\,0.4,\\,0.0,\\,1.0\\big)$.\n   - Case $4$ (threshold forcing all elements to Newton–Cotes): $\\big(2.0,\\,1.0,\\,30,\\,15,\\,0.5,\\,20.0,\\,0.25,\\,0.2,\\,0.4,\\,10^9,\\,1.0\\big)$.\n3. For each case, report the pair $(E_{\\mathrm{M}}, C_{\\mathrm{M}})$ for the three methods: pure Gauss, pure Newton–Cotes, and hybrid.\n4. Final output format: Your program should produce a single line of output containing a list of four items (one per test case). Each item must itself be a list of six numbers in the order $\\big[E_{\\mathrm{Gauss}}, C_{\\mathrm{Gauss}}, E_{\\mathrm{NC}}, C_{\\mathrm{NC}}, E_{\\mathrm{Hybrid}}, C_{\\mathrm{Hybrid}}\\big]$. Errors must be reported as floating-point numbers rounded to six decimal places, and costs must be reported as integers. For example, a valid shape is $\\big[\\,[e_{11},c_{11},e_{12},c_{12},e_{13},c_{13}],\\,[e_{21},c_{21},e_{22},c_{22},e_{23},c_{23}],\\,[e_{31},c_{31},e_{32},c_{32},e_{33},c_{33}],\\,[e_{41},c_{41},e_{42},c_{42},e_{43},c_{43}]\\,\\big]$.\n\nNote: Angles do not appear in this problem. There are no physical units required; all quantities are dimensionless. Ensure all computations are deterministic. The program must be self-contained, must not require any input, and must follow the specified output format.", "solution": "The problem is valid. It presents a well-defined numerical analysis task grounded in standard computational methods. All parameters, functions, and procedures are specified without ambiguity, forming a self-contained and solvable problem.\n\nThe objective is to approximate the two-dimensional integral $I = \\iint_{\\mathcal{D}} f(x,y)\\, \\mathrm{d}x\\, \\mathrm{d}y$ over a rectangular domain $\\mathcal{D} = \\{(x,y) \\mid x \\in [-B/2,B/2], y \\in [0,H]\\}$. The integrand is given by $f(x,y) = \\big(1+\\beta y\\big)\\,\\varepsilon(x,y)^2$, where the \"strain-like\" field $\\varepsilon(x,y)$ is defined as $\\varepsilon(x,y) = A \\tanh\\!\\big(\\kappa\\, r(x,y)\\big)$, with $r(x,y) = \\exp\\!\\Big(-\\big(\\tfrac{x}{\\sigma_x}\\big)^2\\Big)\\,\\exp\\!\\Big(-\\tfrac{y}{\\sigma_y}\\Big)$. This formulation creates a function with steep gradients localized near the line $x=0$, mimicking stress or strain concentrations in a geomechanical context.\n\nThe approximation of the integral $I$ is performed by discretizing the domain $\\mathcal{D}$ into a grid of $N_x \\times N_y$ rectangular elements and summing the contributions from each element. The integral over each element is computed numerically using quadrature rules defined on a reference square $[-1,1] \\times [-1,1]$.\n\nAn affine mapping transforms points $(\\xi, \\eta)$ from the reference square to physical coordinates $(x,y)$ within a specific element. For an element of size $\\Delta x \\times \\Delta y$ centered at $(x_c, y_c)$, the mapping is:\n$$\nx(\\xi) = x_c + \\xi \\frac{\\Delta x}{2}, \\quad y(\\eta) = y_c + \\eta \\frac{\\Delta y}{2}\n$$\nThe differential area element transforms as $\\mathrm{d}x\\,\\mathrm{d}y = J\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta$, where the Jacobian determinant is constant for all elements: $J = \\frac{\\Delta x}{2}\\frac{\\Delta y}{2} = \\frac{BH}{4 N_x N_y}$. The integral over a single element $I_e$ is thus approximated as:\n$$\nI_e = \\iint_{\\text{element}} f(x,y)\\,\\mathrm{d}x\\,\\mathrm{d}y \\approx J \\sum_i \\sum_j w_i w_j f\\big(x(\\xi_i), y(\\eta_j)\\big)\n$$\nwhere $(\\xi_i, w_i)$ and $(\\eta_j, w_j)$ are the one-dimensional quadrature nodes and weights for the chosen rule.\n\nWe will implement and compare three distinct quadrature strategies:\n1.  **Pure Gauss Quadrature**: A $2 \\times 2$ tensor-product Gauss-Legendre rule is applied to every element. For one dimension, the nodes are $\\xi \\in \\{-1/\\sqrt{3}, +1/\\sqrt{3}\\}$ and the weights are $w=1$. This rule uses $4$ function evaluations per element. It is highly efficient for smooth, polynomial-like integrands.\n\n2.  **Pure Newton-Cotes Quadrature**: A $3 \\times 3$ tensor-product closed Newton-Cotes rule (Simpson's rule) is applied to every element. For one dimension, the nodes are $\\xi \\in \\{-1, 0, +1\\}$ and the weights are $w \\in \\{\\frac{1}{3}, \\frac{4}{3}, \\frac{1}{3}\\}$. This rule uses $9$ function evaluations per element. As a higher-order rule, it can be more accurate for well-behaved functions, but it is also more computationally expensive.\n\n3.  **Hybrid Quadrature**: This adaptive strategy selects the quadrature rule on an element-by-element basis. The selection is governed by a \"switching criterion\" based on the magnitude of the gradient of the strain-like field, $g(x,y) = \\|\\nabla \\varepsilon(x,y)\\|_2$. The gradient is given by:\n    $$\n    \\nabla \\varepsilon(x,y) = A \\kappa\\, \\operatorname{sech}^2\\!\\big(\\kappa r(x,y)\\big)\\, \\nabla r(x,y) \\quad \\text{with} \\quad \\nabla r(x,y) = r(x,y)\\,\\Big(-\\tfrac{2x}{\\sigma_x^2},\\; -\\tfrac{1}{\\sigma_y}\\Big)\n    $$\n    This leads to the magnitude function:\n    $$\n    g(x,y) = A \\kappa\\, \\operatorname{sech}^2\\big(\\kappa r(x,y)\\big) r(x,y) \\sqrt{\\frac{4x^2}{\\sigma_x^4} + \\frac{1}{\\sigma_y^2}}\n    $$\n    For each element, we evaluate $g(x,y)$ on a grid of $3 \\times 3$ points corresponding to the nodes of Simpson's rule. If the maximum value of $g(x,y)$ on this grid exceeds a given threshold $T$, the element is classified as \"high-gradient\" and integrated using the computationally cheaper $2 \\times 2$ Gauss rule. Otherwise, it is classified as \"low-gradient\" and integrated with the more accurate $3 \\times 3$ Newton-Cotes rule. The rationale is to allocate more computational effort (more quadrature points) to regions where the integrand is smooth and the higher-order rule is most effective.\n\nTo assess the performance of these methods, we first compute a high-accuracy reference integral, $I_{\\mathrm{ref}}$, by applying a $5 \\times 5$ tensor-product Gauss-Legendre quadrature rule to every element. The accuracy of each method $M$ is then measured by the absolute error $E_M = |I_M - I_{\\mathrm{ref}}|$.\n\nThe computational efficiency is evaluated using a cost model, $C = n_f + c_{\\mathrm{grad}}\\, n_g$, which accounts for the total number of integrand evaluations, $n_f$, and the total number of gradient magnitude evaluations, $n_g$, required for the hybrid switching criterion.\n-   For pure Gauss: $C_{\\mathrm{Gauss}} = (N_x N_y) \\times (2 \\times 2)$. No gradient evaluations are needed, so $n_g=0$.\n-   For pure Newton-Cotes: $C_{\\mathrm{NC}} = (N_x N_y) \\times (3 \\times 3)$. No gradient evaluations are needed, so $n_g=0$.\n-   For the hybrid method: $C_{\\mathrm{Hybrid}} = n_{f, \\text{hybrid}} + c_{\\mathrm{grad}} \\times n_{g, \\text{hybrid}}$. Here, $n_{f, \\text{hybrid}}$ is the sum of function evaluations over all elements ($4$ for high-gradient, $9$ for low-gradient), and $n_{g, \\text{hybrid}} = (N_x N_y) \\times (3 \\times 3)$.\n\nThe algorithm proceeds by first defining the necessary mathematical functions and quadrature rules. Then, for each test case, it iterates through all $N_x \\times N_y$ elements of the discretized domain. In each element, it computes the integral contribution for the reference solution and each of the three methods, updating the total integrals and cost counters accordingly. Finally, it calculates the absolute errors and total costs and formats the results as specified.", "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # B, H, Nx, Ny, A, kappa, sigma_x, sigma_y, beta, T, c_grad\n        (2.0, 1.0, 20, 10, 0.05, 6.0, 0.4, 0.3, 0.2, 0.05, 1.0),\n        (2.0, 1.0, 40, 20, 0.5, 20.0, 0.25, 0.2, 0.4, 0.2, 1.0),\n        (2.0, 1.0, 30, 15, 0.5, 20.0, 0.25, 0.2, 0.4, 0.0, 1.0),\n        (2.0, 1.0, 30, 15, 0.5, 20.0, 0.25, 0.2, 0.4, 10**9, 1.0)\n    ]\n\n    # Pre-calculate quadrature rules\n    nodes_g2, weights_g2 = roots_legendre(2)\n    nodes_nc3 = np.array([-1.0, 0.0, 1.0])\n    weights_nc3 = np.array([1/3, 4/3, 1/3])\n    nodes_g5, weights_g5 = roots_legendre(5)\n\n    quad_rules = {\n        'gauss2': (nodes_g2, weights_g2, 2*2),\n        'nc3': (nodes_nc3, weights_nc3, 3*3),\n        'gauss5': (nodes_g5, weights_g5, 5*5)\n    }\n\n    all_results = []\n    for case in test_cases:\n        all_results.append(run_case(case, quad_rules))\n\n    # Format the final output string\n    formatted_results = []\n    for res_tuple in all_results:\n        e_g, c_g, e_nc, c_nc, e_h, c_h = res_tuple\n        formatted_results.append(\n            f\"[{e_g:.6f},{c_g},{e_nc:.6f},{c_nc},{e_h:.6f},{c_h}]\"\n        )\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef run_case(params, quad_rules):\n    \"\"\"\n    Runs a single test case.\n    \"\"\"\n    B, H, Nx, Ny, A, kappa, sx, sy, beta, T, c_grad = params\n    dx, dy = B / Nx, H / Ny\n    J = (dx / 2.0) * (dy / 2.0)\n\n    # Define the core functions using closures to capture parameters\n    def r_func(x, y):\n        return np.exp(-(x/sx)**2) * np.exp(-y/sy)\n\n    def eps_func(x, y):\n        return A * np.tanh(kappa * r_func(x, y))\n\n    def f_func(x, y):\n        return (1.0 + beta * y) * eps_func(x, y)**2\n\n    def g_func(x, y):\n        r_val = r_func(x, y)\n        # sech(u) = 1 / cosh(u)\n        sech_val = 1.0 / np.cosh(kappa * r_val)\n        grad_r_norm = np.sqrt(4.0 * x**2 / sx**4 + 1.0 / sy**2)\n        return A * kappa * sech_val**2 * r_val * grad_r_norm\n\n    # Initialize integrals and costs\n    I_ref, I_gauss, I_nc, I_hybrid = 0.0, 0.0, 0.0, 0.0\n    \n    # Costs for pure methods are deterministic\n    C_gauss = Nx * Ny * quad_rules['gauss2'][2]\n    C_nc = Nx * Ny * quad_rules['nc3'][2]\n    \n    # Hybrid costs are accumulated\n    nf_hybrid = 0\n    ng_hybrid = (Nx * Ny) * quad_rules['nc3'][2]\n\n    # Unpack quadrature rules for convenience\n    nodes_g2, weights_g2, n_g2 = quad_rules['gauss2']\n    nodes_nc3, weights_nc3, n_nc3 = quad_rules['nc3']\n    nodes_g5, weights_g5, _ = quad_rules['gauss5']\n    \n    # Create meshgrids for quadrature points\n    xi_g2, eta_g2 = np.meshgrid(nodes_g2, nodes_g2)\n    w_g2 = np.outer(weights_g2, weights_g2)\n\n    xi_nc3, eta_nc3 = np.meshgrid(nodes_nc3, nodes_nc3)\n    w_nc3 = np.outer(weights_nc3, weights_nc3)\n    \n    xi_g5, eta_g5 = np.meshgrid(nodes_g5, nodes_g5)\n    w_g5 = np.outer(weights_g5, weights_g5)\n\n    # Loop over all elements\n    for i in range(Nx):\n        for j in range(Ny):\n            xc = -B/2.0 + (i + 0.5) * dx\n            yc = 0.0 + (j + 0.5) * dy\n\n            # Reference integral (Gauss 5x5)\n            x_pts_g5 = xc + xi_g5 * dx / 2.0\n            y_pts_g5 = yc + eta_g5 * dy / 2.0\n            I_ref += J * np.sum(w_g5 * f_func(x_pts_g5, y_pts_g5))\n\n            # Pure Gauss integral (Gauss 2x2)\n            x_pts_g2 = xc + xi_g2 * dx / 2.0\n            y_pts_g2 = yc + eta_g2 * dy / 2.0\n            I_gauss_elem = J * np.sum(w_g2 * f_func(x_pts_g2, y_pts_g2))\n            I_gauss += I_gauss_elem\n\n            # Pure Newton-Cotes integral (NC 3x3)\n            x_pts_nc3 = xc + xi_nc3 * dx / 2.0\n            y_pts_nc3 = yc + eta_nc3 * dy / 2.0\n            I_nc_elem = J * np.sum(w_nc3 * f_func(x_pts_nc3, y_pts_nc3))\n            I_nc += I_nc_elem\n\n            # Hybrid method\n            # 1. Switching criterion on the 3x3 grid\n            g_vals = g_func(x_pts_nc3, y_pts_nc3)\n            max_g = np.max(g_vals)\n\n            # 2. Select rule and compute integral\n            if max_g > T:  # High-gradient -> use Gauss 2x2\n                I_hybrid += I_gauss_elem\n                nf_hybrid += n_g2\n            else:  # Low-gradient -> use Newton-Cotes 3x3\n                I_hybrid += I_nc_elem\n                nf_hybrid += n_nc3\n\n    # Finalize calculations for the case\n    C_hybrid = nf_hybrid + int(c_grad * ng_hybrid)\n\n    E_gauss = abs(I_gauss - I_ref)\n    E_nc = abs(I_nc - I_ref)\n    E_hybrid = abs(I_hybrid - I_ref)\n\n    return (E_gauss, int(C_gauss), E_nc, int(C_nc), E_hybrid, int(C_hybrid))\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3546638"}]}