{"hands_on_practices": [{"introduction": "The heart of any computational plasticity code is the constitutive driver, or \"return mapping\" algorithm, which integrates the elastoplastic rate equations. This exercise guides you through the implementation of a backward Euler return map for a sophisticated model featuring nonlinear kinematic hardening, a common feature in cyclic soil models. A key focus is the derivation and implementation of the consistent algorithmic tangent $C_{\\text{alg}}$, which is crucial for achieving the rapid, quadratic convergence of the global Newton-Raphson solver [@problem_id:3529165].", "problem": "Consider a single material point undergoing small-strain simple shear under undrained conditions in a soil modeled by von Mises (J2) elastoplasticity with nonlinear kinematic hardening of Armstrong–Frederick type, within a bounding surface framework in which the kinematic hardening saturates through dynamic recovery. The undrained condition implies zero volumetric strain increment, so only the shear response evolves during loading. The objective is to derive, implement, and test the consistent algorithmic tangent for a backward Euler integration of the constitutive equations.\n\nThe fundamental base consists of the following well-tested definitions and laws:\n- Small-strain additivity: $d\\boldsymbol{\\varepsilon} = d\\boldsymbol{\\varepsilon}^{e} + d\\boldsymbol{\\varepsilon}^{p}$.\n- Linear isotropic elasticity for deviatoric response: $\\boldsymbol{s} = 2 G \\boldsymbol{\\varepsilon}^{e}_{\\text{dev}}$, where $G$ is the shear modulus.\n- Von Mises (J2) yield function with kinematic shift: $f = \\sqrt{\\dfrac{3}{2}} \\left\\| \\boldsymbol{s} - \\boldsymbol{\\alpha} \\right\\| - \\sigma_{y}$, where $\\sigma_{y}$ is the current yield stress (taken as constant for this problem), $\\boldsymbol{s}$ is the deviatoric stress tensor, and $\\boldsymbol{\\alpha}$ is the backstress tensor.\n- Associated flow: $d\\boldsymbol{\\varepsilon}^{p}_{\\text{dev}} = dp \\, \\dfrac{\\partial f}{\\partial \\boldsymbol{\\sigma}} = dp \\, \\sqrt{\\dfrac{3}{2}} \\, \\dfrac{\\boldsymbol{s} - \\boldsymbol{\\alpha}}{\\left\\| \\boldsymbol{s} - \\boldsymbol{\\alpha} \\right\\|}$, with plastic multiplier $dp \\ge 0$.\n- Armstrong–Frederick nonlinear kinematic hardening: $d\\boldsymbol{\\alpha} = c \\, d\\boldsymbol{\\varepsilon}^{p}_{\\text{dev}} - \\gamma \\, \\boldsymbol{\\alpha} \\, dp$, with $c$ a kinematic hardening modulus and $\\gamma$ a dynamic recovery parameter controlling saturation (these parameters are constants).\n- Bounding surface interpretation here is through the saturation of $\\boldsymbol{\\alpha}$ under the dynamic recovery term, which bounds the translation of the yield surface.\n\nRestrict the response to simple shear with only the $\\boldsymbol{12}$ component nonzero, and assume all quantities remain colinear in this one-dimensional deviatoric subspace. Let the engineering shear strain be $\\gamma$ and the shear stress be $\\tau$, so $\\tau = G \\gamma^{e}$ with $\\gamma^{e} = \\gamma - \\gamma^{p}$. Let the backstress component be $a = \\alpha_{12}$. The J2 equivalent norm in simple shear gives $\\sqrt{\\dfrac{3}{2}} \\left\\| \\boldsymbol{s} - \\boldsymbol{\\alpha} \\right\\| = \\sqrt{3} \\, \\left| \\tau - a \\right|$.\n\nUse a backward Euler (implicit) corrector at each strain increment $d\\gamma$:\n- Trial stress: $\\tau_{\\text{tr}} = \\tau_{\\text{prev}} + G \\, d\\gamma$.\n- Plastic flow under backward Euler and associated flow in simple shear produces $d \\gamma^{p} = \\sqrt{3} \\, dp \\, \\operatorname{sign}(\\tau - a)$ at the end of the increment.\n- Armstrong–Frederick update in simple shear with backward Euler: $a_{\\text{new}} = \\dfrac{a_{\\text{prev}} + c \\, \\sqrt{3/4} \\, dp \\, \\operatorname{sign}(\\tau_{\\text{new}} - a_{\\text{new}})}{1 + \\gamma \\, dp}$.\n- Stress corrector: $\\tau_{\\text{new}} = \\tau_{\\text{tr}} - G \\, \\sqrt{3} \\, dp \\, \\operatorname{sign}(\\tau_{\\text{new}} - a_{\\text{new}})$.\n- Consistency: $\\sqrt{3} \\, \\left| \\tau_{\\text{new}} - a_{\\text{new}} \\right| = \\sigma_{y}$.\n\nTask 1. Starting from the above fundamental base and using the backward Euler discretization in the one-dimensional simple shear subspace, derive a scalar nonlinear residual equation for the plastic multiplier increment $dp$ that enforces the consistency condition, expressed only in terms of known quantities at the start of the increment ($\\tau_{\\text{prev}}$, $a_{\\text{prev}}$), the trial stress $\\tau_{\\text{tr}}$, and material parameters ($G$, $\\sigma_{y}$, $c$, $\\gamma$). Then, derive the Newton update formula for $dp$ by computing the derivative of the residual with respect to $dp$.\n\nTask 2. From the same backward Euler integration, derive the consistent algorithmic shear tangent $C_{\\text{alg}} = \\dfrac{d \\tau_{\\text{new}}}{d \\gamma}$ that linearizes the stress response with respect to the strain increment within the chosen integration scheme. Express $C_{\\text{alg}}$ in terms of $G$, $c$, $\\gamma$, $a_{\\text{prev}}$, and the converged $dp$ of the increment.\n\nTask 3. Implement a program that performs the following for a set of strain increments:\n- Applies each shear strain increment $d\\gamma$ in sequence.\n- At each increment, computes $\\tau_{\\text{tr}}$, tests for elasticity using the trial yield function $f_{\\text{tr}} = \\sqrt{3} \\, \\left| \\tau_{\\text{tr}} - a_{\\text{prev}} \\right| - \\sigma_{y}$. If $f_{\\text{tr}} \\le 0$, the step is elastic and no Newton iteration is needed; set $dp = 0$, $\\tau_{\\text{new}} = \\tau_{\\text{tr}}$, $a_{\\text{new}} = a_{\\text{prev}}$, and $C_{\\text{alg}} = G$.\n- If $f_{\\text{tr}} > 0$, solve for $dp$ using Newton’s method on the derived residual. Use a numerically reasonable initial guess derived from the linear kinematic hardening case (with $\\gamma = 0$), clamp $dp \\ge 0$, and employ a tolerance $\\epsilon = 10^{-10}$ for the residual norm with a maximum of $50$ iterations. Update $\\tau_{\\text{new}}$, $a_{\\text{new}}$, and compute $C_{\\text{alg}}$ from Task $2$.\n- Track the number of Newton iterations required at each increment.\n\nYour program should assess Newton convergence under severe undrained softening cycles by reporting, for each test case, the maximum number of Newton iterations observed over all increments as an integer. All stresses must be in kilopascals (kPa), strains are dimensionless, and angles do not appear. No physical quantity is requested in the final output; only iteration counts are required.\n\nTest Suite. Use the following four test cases, each defined by a tuple $(G, \\sigma_{y}, c, \\gamma, \\text{increments})$ with $G$ in $\\text{kPa}$, $\\sigma_{y}$ in $\\text{kPa}$, $c$ in $\\text{kPa}$, $\\gamma$ in $\\text{(strain)}^{-1}$, and strain increments dimensionless:\n- Case $1$ (general cyclic loading): $(G = 50000, \\sigma_{y} = 100, c = 15000, \\gamma = 80, \\text{increments} = [0.002, 0.002, -0.004, 0.004, -0.004, 0.004])$.\n- Case $2$ (severe softening due to strong dynamic recovery): $(G = 30000, \\sigma_{y} = 60, c = 5000, \\gamma = 600, \\text{increments} = [0.004, -0.008, 0.008, -0.008, 0.008])$.\n- Case $3$ (near-elastic regime with very small increments): $(G = 40000, \\sigma_{y} = 200, c = 10000, \\gamma = 50, \\text{increments} = [0.0005, -0.0005, 0.0005, -0.0005])$.\n- Case $4$ (boundary case near yield with reversal): $(G = 35000, \\sigma_{y} = 80, c = 8000, \\gamma = 200, \\text{increments} = [0.0012, 0.0012, -0.0024])$.\n\nFinal Output Format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the cases listed above. For example, if the maximum Newton iteration counts over the increments are $n_{1}$, $n_{2}$, $n_{3}$, and $n_{4}$, your program must output exactly: $[n_{1},n_{2},n_{3},n_{4}]$.", "solution": "The user-provided problem requires the derivation and implementation of a backward Euler return mapping algorithm for a one-dimensional simple shear von Mises elastoplastic model with nonlinear Armstrong–Frederick kinematic hardening. The solution is presented in three parts, corresponding to the tasks specified in the problem statement.\n\n### Task 1: Derivation of the Residual Equation and Newton Update\n\nThe objective is to find the plastic multiplier increment, denoted as $dp$, that ensures the state at the end of an increment (the 'new' state) satisfies the yield condition, also known as the consistency condition. This is achieved by formulating a residual equation $R(dp) = 0$ which is solved numerically, typically using Newton's method.\n\nLet the state variables at the beginning of the increment be the shear stress $\\tau_{\\text{prev}}$ and the backstress $a_{\\text{prev}}$. The increment is driven by a total shear strain increment $d\\gamma$.\n\n**1. Trial State:**\nFirst, an elastic trial state is computed assuming the entire strain increment $d\\gamma$ is elastic.\nThe trial stress $\\tau_{\\text{tr}}$ is:\n$$ \\tau_{\\text{tr}} = \\tau_{\\text{prev}} + G \\, d\\gamma $$\nThe backstress remains unchanged in the trial step: $a_{\\text{tr}} = a_{\\text{prev}}$.\n\n**2. Yield Check:**\nPlasticity occurs if the trial state lies outside the yield surface. The yield function in simple shear is $f = \\sqrt{3} |\\tau - a| - \\sigma_y$. The trial yield function is:\n$$ f_{\\text{tr}} = \\sqrt{3} |\\tau_{\\text{tr}} - a_{\\text{prev}}| - \\sigma_y $$\nIf $f_{\\text{tr}} \\le 0$, the step is elastic. The final state is the trial state, and $dp=0$. If $f_{\\text{tr}} > 0$, a plastic correction is required.\n\n**3. Plastic Corrector (Return Mapping):**\nThe plastic corrector step involves updating the stress and backstress based on the final, unknown state at the end of the increment. Using the backward Euler update rules provided in the problem:\n$$ \\tau_{\\text{new}} = \\tau_{\\text{tr}} - G \\sqrt{3} \\, dp \\, S $$\n$$ a_{\\text{new}} = \\frac{a_{\\text{prev}} + c (\\sqrt{3}/2) \\, dp \\, S}{1 + \\gamma \\, dp} $$\nwhere the flow direction $S = \\operatorname{sign}(\\tau_{\\text{new}} - a_{\\text{new}})$ is assumed to be constant throughout the correction and is determined from the trial state: $S = \\operatorname{sign}(\\tau_{\\text{tr}} - a_{\\text{prev}})$.\n\nThe consistency condition at the end of the step requires:\n$$ \\sqrt{3} |\\tau_{\\text{new}} - a_{\\text{new}}| = \\sigma_y $$\nAssuming the sign $S$ is preserved, this becomes:\n$$ \\tau_{\\text{new}} - a_{\\text{new}} = S \\frac{\\sigma_y}{\\sqrt{3}} $$\nNow, substitute the expressions for $\\tau_{\\text{new}}$ and $a_{\\text{new}}$ into the consistency condition:\n$$ \\left( \\tau_{\\text{tr}} - G \\sqrt{3} \\, dp \\, S \\right) - \\left( \\frac{a_{\\text{prev}} + c (\\sqrt{3}/2) \\, dp \\, S}{1 + \\gamma \\, dp} \\right) = S \\frac{\\sigma_y}{\\sqrt{3}} $$\nTo form the residual equation $R(dp) = 0$, we group all terms on one side. Let's define the relative stress at the trial state as $\\xi_{\\text{tr}} = \\tau_{\\text{tr}} - a_{\\text{prev}}$. We can multiply the equation by $S$ (since $S^2=1$ and $S\\xi_{\\text{tr}} = |\\xi_{\\text{tr}}|$):\n$$ |\\tau_{\\text{tr}} - a_{\\text{prev}}| - G \\sqrt{3} \\, dp - \\frac{S a_{\\text{prev}} + c (\\sqrt{3}/2) \\, dp}{1 + \\gamma \\, dp} = \\frac{\\sigma_y}{\\sqrt{3}} $$\nRearranging to form the residual equation $R(dp)=0$:\n$$ R(dp) = |\\tau_{\\text{tr}} - a_{\\text{prev}}| - \\frac{\\sigma_y}{\\sqrt{3}} - G\\sqrt{3} dp - \\frac{S a_{\\text{prev}} + c \\sqrt{3}/2 \\, dp}{1+\\gamma dp} + a_{\\text{prev}} S $$\nA more direct path is to recognize that $|\\tau_{\\text{tr}} - a_{\\text{prev}}| - \\frac{\\sigma_y}{\\sqrt{3}} = \\frac{f_{\\text{tr}}}{\\sqrt{3}}$. Let's define the residual by setting the updated relative stress equal to the yield stress.\nLet $\\xi_{\\text{new}} = \\tau_{\\text{new}} - a_{\\text{new}}$. The residual is $S\\xi_{\\text{new}} - \\sigma_y/\\sqrt{3} = 0$.\n$$ S\\xi_{\\text{new}} = S\\left( \\tau_{\\text{tr}} - G\\sqrt{3}S dp - \\frac{a_{\\text{prev}} + c(\\sqrt{3}/2)S dp}{1+\\gamma dp} \\right) = |\\tau_{\\text{tr}}-a_{\\text{prev}}| - G\\sqrt{3}dp - \\frac{Sa_{\\text{prev}} + c(\\sqrt{3}/2)dp}{1+\\gamma dp} $$\nThe final residual equation $R(dp) = 0$ is therefore:\n$$ R(dp) = |\\tau_{\\text{tr}} - a_{\\text{prev}}| - \\frac{\\sigma_y}{\\sqrt{3}} - G\\sqrt{3} dp - \\frac{(c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma) dp}{1+\\gamma dp} = 0 $$\n\n**4. Newton Update Formula:**\nTo solve $R(dp)=0$ using Newton's method, we need the derivative of $R$ with respect to $dp$, denoted $R'(dp)$.\nLet the term $K = c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma$.\n$$ R(dp) = \\left( |\\tau_{\\text{tr}} - a_{\\text{prev}}| - \\frac{\\sigma_y}{\\sqrt{3}} \\right) - G\\sqrt{3} dp - K \\frac{dp}{1+\\gamma dp} $$\n$$ R'(dp) = \\frac{d R}{d(dp)} = -G\\sqrt{3} - K \\frac{d}{d(dp)}\\left( \\frac{dp}{1+\\gamma dp} \\right) $$\nUsing the quotient rule, $\\frac{d}{dx}(\\frac{u}{v}) = \\frac{u'v-uv'}{v^2}$:\n$$ \\frac{d}{d(dp)}\\left( \\frac{dp}{1+\\gamma dp} \\right) = \\frac{1(1+\\gamma dp) - dp(\\gamma)}{(1+\\gamma dp)^2} = \\frac{1}{(1+\\gamma dp)^2} $$\nSo, the derivative of the residual is:\n$$ R'(dp) = -G\\sqrt{3} - \\frac{K}{(1+\\gamma dp)^2} = - \\left( G\\sqrt{3} + \\frac{c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma}{(1+\\gamma dp)^2} \\right) $$\nThe Newton-Raphson update for $dp$ at iteration $k$ is:\n$$ dp_{k+1} = dp_k - \\frac{R(dp_k)}{R'(dp_k)} $$\n\n### Task 2: Derivation of the Consistent Algorithmic Tangent\n\nThe consistent algorithmic tangent $C_{\\text{alg}}$ is the derivative of the updated stress $\\tau_{\\text{new}}$ with respect to the total strain increment $d\\gamma$.\n$$ C_{\\text{alg}} = \\frac{d\\tau_{\\text{new}}}{d(d\\gamma)} $$\nWe have $\\tau_{\\text{new}} = \\tau_{\\text{prev}} + G d\\gamma - G\\sqrt{3}S\\,dp$. Differentiating with respect to $d\\gamma$:\n$$ C_{\\text{alg}} = G - G\\sqrt{3}S \\frac{d(dp)}{d(d\\gamma)} $$\nHere, $S = \\operatorname{sign}(\\tau_{\\text{prev}} + G d\\gamma - a_{\\text{prev}})$ is treated as constant within the increment after the trial step determines the loading direction. The plastic multiplier $dp$ is an implicit function of $d\\gamma$ through the residual equation $R(dp, d\\gamma) = 0$. We use implicit differentiation on $R=0$:\n$$ dR = \\frac{\\partial R}{\\partial(dp)} d(dp) + \\frac{\\partial R}{\\partial(d\\gamma)} d(d\\gamma) = 0 $$\nThis gives $\\frac{d(dp)}{d(d\\gamma)} = - \\left( \\frac{\\partial R}{\\partial(dp)} \\right)^{-1} \\frac{\\partial R}{\\partial(d\\gamma)}$.\nWe already found $\\frac{\\partial R}{\\partial(dp)} = R'(dp)$. Now we find $\\frac{\\partial R}{\\partial(d\\gamma)}$:\n$$ \\frac{\\partial R}{\\partial(d\\gamma)} = \\frac{\\partial}{\\partial(d\\gamma)}\\left( |\\tau_{\\text{prev}} + G d\\gamma - a_{\\text{prev}}| - \\frac{\\sigma_y}{\\sqrt{3}} - \\dots \\right) = \\frac{\\partial}{\\partial(d\\gamma)}\\left( S(\\tau_{\\text{prev}} + G d\\gamma - a_{\\text{prev}}) \\right) = SG $$\nTherefore:\n$$ \\frac{d(dp)}{d(d\\gamma)} = - \\frac{SG}{R'(dp)} = \\frac{SG}{G\\sqrt{3} + \\frac{c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma}{(1+\\gamma dp)^2}} $$\nSubstituting this back into the expression for $C_{\\text{alg}}$:\n$$ C_{\\text{alg}} = G - G\\sqrt{3}S \\left( \\frac{SG}{G\\sqrt{3} + \\frac{c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma}{(1+\\gamma dp)^2}} \\right) $$\nSince $S^2=1$:\n$$ C_{\\text{alg}} = G - \\frac{G^2\\sqrt{3}}{G\\sqrt{3} + \\frac{c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma}{(1+\\gamma dp)^2}} $$\nThis can be rearranged into a more compact form:\n$$ C_{\\text{alg}} = G \\left( 1 - \\frac{G\\sqrt{3}}{G\\sqrt{3} + \\frac{c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma}{(1+\\gamma dp)^2}} \\right) = G \\frac{\\frac{c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma}{(1+\\gamma dp)^2}}{G\\sqrt{3} + \\frac{c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma}{(1+\\gamma dp)^2}} $$\n$$ C_{\\text{alg}} = \\frac{G (c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma)}{G\\sqrt{3}(1+\\gamma dp)^2 + c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma} $$\nThis expression for $C_{\\text{alg}}$ uses the converged value of $dp$ for the increment. For an elastic step ($dp=0$), the tangent is simply $G$.\n\n### Task 3: Implementation\nThe derived equations are implemented in a Python program. The main logic follows the steps detailed in the problem statement for each strain increment: compute the trial state, check for yielding, and if plastic, solve for the plastic multiplier `dp` using the Newton-Raphson method with the derived residual and Jacobian. The state variables are then updated, and the maximum number of Newton iterations is tracked for each test case. The final list of maximum iteration counts is reported.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test cases defined as (G, sigma_y, c, gamma, increments)\n    # G in kPa, sigma_y in kPa, c in kPa, gamma dimensionless, increments dimensionless\n    test_cases = [\n        # Case 1: general cyclic loading\n        (50000.0, 100.0, 15000.0, 80.0, [0.002, 0.002, -0.004, 0.004, -0.004, 0.004]),\n        # Case 2: severe softening due to strong dynamic recovery\n        (30000.0, 60.0, 5000.0, 600.0, [0.004, -0.008, 0.008, -0.008, 0.008]),\n        # Case 3: near-elastic regime with very small increments\n        (40000.0, 200.0, 10000.0, 50.0, [0.0005, -0.0005, 0.0005, -0.0005]),\n        # Case 4: boundary case near yield with reversal\n        (35000.0, 80.0, 8000.0, 200.0, [0.0012, 0.0012, -0.0024]),\n    ]\n\n    results = []\n    for params in test_cases:\n        max_iters = run_simulation(*params)\n        results.append(max_iters)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation(G, sigma_y, c, gamma, increments):\n    \"\"\"\n    Performs the elastoplastic simulation for a single test case.\n\n    Args:\n        G (float): Shear modulus.\n        sigma_y (float): Yield stress.\n        c (float): Kinematic hardening modulus.\n        gamma (float): Dynamic recovery parameter.\n        increments (list of float): Sequence of shear strain increments.\n\n    Returns:\n        int: The maximum number of Newton iterations over all increments.\n    \"\"\"\n    tau_prev = 0.0\n    a_prev = 0.0\n    max_newton_iterations = 0\n    sqrt3 = np.sqrt(3.0)\n\n    for d_gamma in increments:\n        # --- ELASTIC PREDICTOR ---\n        tau_tr = tau_prev + G * d_gamma\n        xi_tr = tau_tr - a_prev\n\n        # Trial yield function\n        # A small tolerance is used for the elastic check to handle floating point inaccuracies\n        f_tr = sqrt3 * np.abs(xi_tr) - sigma_y\n\n        if f_tr <= 1e-12:\n            # Elastic step\n            tau_new = tau_tr\n            a_new = a_prev\n            current_iterations = 0\n        else:\n            # --- PLASTIC CORRECTOR ---\n            S = np.sign(xi_tr)\n            \n            # Initial guess for dp from the linear hardening case (gamma = 0)\n            dp0_denom = 3.0 * G + 1.5 * c\n            dp = f_tr / dp0_denom if dp0_denom > 1e-12 else 0.0\n            \n            # Clamp initial guess to be non-negative\n            dp = max(0.0, dp)\n\n            # Newton-Raphson iteration for plastic multiplier dp\n            tol = 1e-10\n            max_iter_newton = 50\n            current_iterations = 0\n\n            for i in range(max_iter_newton):\n                current_iterations += 1\n                \n                # Pre-calculate hardening-recovery term for residual and derivative\n                K = c * sqrt3 / 2.0 - S * a_prev * gamma\n                \n                # Check for unstable denominator, though dp should be non-negative\n                denom = 1.0 + gamma * dp\n                if denom < 1e-9: # Avoid division by zero/small number\n                    dp = 0.0 # Revert to a safe value\n                    denom = 1.0\n\n                # Residual function R(dp)\n                # R(dp) = f_tr/sqrt(3) - [G*sqrt(3) + K/(1+gamma*dp)]*dp\n                residual = f_tr / sqrt3 - sqrt3 * G * dp - K * dp / denom\n                \n                if np.abs(residual) < tol:\n                    break\n\n                # Derivative of the residual R'(dp)\n                residual_prime = -sqrt3 * G - K / (denom**2)\n\n                if np.abs(residual_prime) < 1e-12:\n                    # Jacobian is singular, break to avoid division by zero\n                    # This may indicate convergence issues, but the algorithm will proceed with the last dp.\n                    break\n                \n                # Newton update\n                dp_update = -residual / residual_prime\n                dp += dp_update\n                \n                # Clamp dp to be non-negative. This handles cases of elastic unloading\n                # detected during the iterative correction.\n                dp = max(0.0, dp)\n            \n            # --- Update state variables ---\n            tau_new = tau_tr - G * sqrt3 * dp * S\n            a_new = (a_prev + c * sqrt3 / 2.0 * dp * S) / (1.0 + gamma * dp)\n\n        if current_iterations > max_newton_iterations:\n            max_newton_iterations = current_iterations\n        \n        # update for next increment\n        tau_prev = tau_new\n        a_prev = a_new\n        \n    return max_newton_iterations\n\n# Execute the simulation and print the results.\nsolve()\n```", "id": "3529165"}, {"introduction": "A notorious challenge in modeling material failure is that naive strain-softening models exhibit a pathological dependence on the finite element mesh size, rendering results physically meaningless. This practice introduces the crack-band model, a widely used regularization technique that restores objectivity by ensuring the dissipated energy during fracture is a true material property, the fracture energy $G_f$. You will calibrate both linear and exponential softening laws and analytically verify that the global energy dissipation becomes independent of the element size $h$, a property known as mesh objectivity [@problem_id:3529154].", "problem": "You are given a uniaxial tension model of a notched specimen represented by a one-dimensional series system: an elastic bar segment in series with a crack-band finite element that undergoes softening. The elastic segment has Young’s modulus $E$, cross-sectional area $A$, and length $L_r = L_{\\text{tot}} - h$, where $L_{\\text{tot}}$ is the total specimen length and $h$ is the characteristic element length of the crack-band. The crack-band element follows a softening law $\\sigma(\\varepsilon_p)$ as a function of the equivalent plastic strain $\\varepsilon_p$, and the corresponding cohesive traction-separation law $T(w)$ is linked by $w = h \\, \\varepsilon_p$ and $T(w) = \\sigma(\\varepsilon_p)$. The tensile strength is $f_t$ and the target mode-I fracture energy is $G_f$.\n\nFundamental base:\n- The crack-band energy equivalence states that the energy dissipated per unit area is equal to the material fracture energy. In a continuum element of characteristic length $h$, the requirement is\n$$\n\\int_{0}^{\\varepsilon_{p,\\text{end}}} \\sigma(\\varepsilon_p) \\, d\\varepsilon_p = \\frac{G_f}{h}.\n$$\n- The traction-separation law $T(w)$ of the crack-band element must satisfy\n$$\n\\int_{0}^{w_{\\text{end}}} T(w) \\, dw = G_f,\n$$\nwith $w = h \\, \\varepsilon_p$ and $T(w) = \\sigma(\\varepsilon_p)$.\n- For an elastic segment of length $L_r$ in series with a cohesive element, under an applied end displacement $\\Delta$, the equilibrium relations are\n$$\nF = A \\, T(w), \\quad \\Delta = \\frac{L_r}{E A} \\, F + w,\n$$\nwith elastic loading up to yielding at $\\Delta_y = \\frac{f_t L_r}{E}$ and $F_y = f_t A$.\n\nYour tasks:\n1. Calibrate the softening law $\\sigma(\\varepsilon_p)$ for two forms so that the crack-band energy equivalence holds:\n   - Linear softening: $\\sigma(\\varepsilon_p) = f_t \\, \\max\\!\\left(1 - \\frac{\\varepsilon_p}{\\varepsilon_f}, 0\\right)$ for $0 \\le \\varepsilon_p \\le \\varepsilon_f$.\n   - Exponential softening: $\\sigma(\\varepsilon_p) = f_t \\, \\exp\\!\\left(-\\frac{\\varepsilon_p}{\\varepsilon_c}\\right)$ for $0 \\le \\varepsilon_p < \\infty$.\n   Derive the calibration parameters $\\varepsilon_f$ and $\\varepsilon_c$ from the fundamental base without using shortcut formulas.\n\n2. Using the calibrated $T(w)$, verify mesh objectivity in the notched specimen model by comparing the total external work to complete failure for two different crack-band element sizes $h$ in each test case. The total external work should equal the fracture energy dissipated across the crack area, which is $A \\, G_f$ in Joules. Compute the total work by combining elastic loading to $\\Delta_y$ and post-yield softening. The elastic segment unloading and the cohesive softening may exhibit snap-back; therefore, your computation must be robust to non-monotonic force–displacement behavior and must not rely on inverting $\\Delta(w)$.\n\n3. Numerically verify the calibration by computing $\\int \\sigma(\\varepsilon_p) \\, d\\varepsilon_p$ for each $h$ and comparing it against $\\frac{G_f}{h}$. Also compute the total external work to failure and compare it against $A \\, G_f$ for each $h$.\n\nUnits and numerical requirements:\n- Use International System of Units (SI): $E$ in Pascal (Pa), $A$ in square meters ($\\mathrm{m}^2$), $L_{\\text{tot}}$, $L_r$, and $h$ in meters ($\\mathrm{m}$), $f_t$ in Pascal (Pa), $G_f$ in Joules per square meter ($\\mathrm{J/m^2}$), $w$ in meters ($\\mathrm{m}$), $\\varepsilon_p$ dimensionless, $\\Delta$ in meters ($\\mathrm{m}$), $F$ in Newtons (N), and total external work in Joules (J).\n- When reporting discrepancies, express them as decimal fractions (unitless), not with a percentage sign. For example, report $0.001$ to mean a discrepancy of $0.1\\%$.\n- Your program should compute, for each test case, the maximum of the four relative errors: two from the softening-law area checks (one for each $h$) and two from the mesh-objectivity work checks (one for each $h$).\n\nTest suite:\n- Test case $1$ (linear softening, happy path):\n  - $E = 30 \\times 10^9$ Pa, $f_t = 3 \\times 10^6$ Pa, $G_f = 120$ $\\mathrm{J/m^2}$, $A = 5 \\times 10^{-3}$ $\\mathrm{m^2}$, $L_{\\text{tot}} = 1$ $\\mathrm{m}$, $h_1 = 0.02$ $\\mathrm{m}$, $h_2 = 0.10$ $\\mathrm{m}$.\n- Test case $2$ (exponential softening, happy path):\n  - $E = 30 \\times 10^9$ Pa, $f_t = 3 \\times 10^6$ Pa, $G_f = 120$ $\\mathrm{J/m^2}$, $A = 5 \\times 10^{-3}$ $\\mathrm{m^2}$, $L_{\\text{tot}} = 1$ $\\mathrm{m}$, $h_1 = 0.02$ $\\mathrm{m}$, $h_2 = 0.10$ $\\mathrm{m}$.\n- Test case $3$ (linear softening, boundary element sizes):\n  - $E = 20 \\times 10^9$ Pa, $f_t = 2 \\times 10^6$ Pa, $G_f = 80$ $\\mathrm{J/m^2}$, $A = 1 \\times 10^{-3}$ $\\mathrm{m^2}$, $L_{\\text{tot}} = 0.2$ $\\mathrm{m}$, $h_1 = 0.001$ $\\mathrm{m}$, $h_2 = 0.05$ $\\mathrm{m}$.\n\nAlgorithmic guidance:\n- For linear softening, the cohesive law is $T(w) = f_t \\left(1 - \\frac{w}{w_f}\\right)$ for $0 \\le w \\le w_f$ with $w_f = h \\, \\varepsilon_f$. For exponential softening, $T(w) = f_t \\exp\\!\\left(-\\frac{w}{w_c}\\right)$ for $w \\ge 0$ with $w_c = h \\, \\varepsilon_c$.\n- Compute pre-yield elastic work as $W_{\\text{el}} = \\frac{1}{2} \\frac{F_y^2}{k_r}$ with $F_y = f_t A$ and $k_r = \\frac{E A}{L_r}$.\n- Compute post-yield work by parameterizing with $w$ and integrating $F(w) \\, \\frac{d\\Delta}{dw}$ over $w$, where $F(w) = A \\, T(w)$ and $\\frac{d\\Delta}{dw} = 1 + \\frac{L_r}{E} \\frac{dT}{dw}$. For linear softening, integrate over $w \\in [0, w_f]$. For exponential softening, integrate over $w \\in [0, w_{\\text{end}}]$ with $w_{\\text{end}}$ sufficiently large (for example $w_{\\text{end}} = 12 \\, w_c$) and verify that the tail contribution is negligible.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, \"[result1,result2,result3]\"), where each result is the maximum relative error for the corresponding test case computed as described above.", "solution": "The problem statement is valid. It is scientifically grounded in the principles of computational fracture mechanics, specifically the crack-band model. All parameters, definitions, and constraints are provided, forming a well-posed and self-contained problem. The numerical values are physically realistic for quasi-brittle materials like concrete. The tasks are clearly defined and computationally feasible. We will proceed with a full solution.\n\nThe solution involves three main parts: first, the analytical calibration of the parameters for the linear and exponential softening laws based on the fracture energy criterion. Second, the formulation of the total external work required for failure, including an analytical proof of mesh objectivity. Third, a description of the numerical procedure to verify these findings.\n\n### 1. Calibration of Softening Laws\n\nThe fundamental principle for calibration is the crack-band energy equivalence, which states that the energy dissipated per unit volume within the element, integrated over the plastic strain history, must equal the fracture energy $G_f$ normalized by the characteristic element length $h$:\n$$\n\\int_{0}^{\\varepsilon_{p,\\text{end}}} \\sigma(\\varepsilon_p) \\, d\\varepsilon_p = \\frac{G_f}{h}\n$$\nHere, $\\sigma(\\varepsilon_p)$ is the softening stress as a function of the equivalent plastic strain $\\varepsilon_p$.\n\n#### 1.1. Linear Softening Law\nThe linear softening law is given by:\n$$\n\\sigma(\\varepsilon_p) = f_t \\, \\left(1 - \\frac{\\varepsilon_p}{\\varepsilon_f}\\right), \\quad \\text{for} \\quad 0 \\le \\varepsilon_p \\le \\varepsilon_f\n$$\nwhere $f_t$ is the tensile strength and $\\varepsilon_f$ is the ultimate plastic strain at which stress reduces to zero. We substitute this into the energy equivalence integral:\n$$\n\\int_{0}^{\\varepsilon_f} f_t \\left(1 - \\frac{\\varepsilon_p}{\\varepsilon_f}\\right) \\, d\\varepsilon_p = f_t \\left[\\varepsilon_p - \\frac{\\varepsilon_p^2}{2\\varepsilon_f}\\right]_{0}^{\\varepsilon_f} = f_t \\left(\\varepsilon_f - \\frac{\\varepsilon_f^2}{2\\varepsilon_f}\\right) = \\frac{1}{2} f_t \\varepsilon_f\n$$\nEquating this to the required dissipated energy density:\n$$\n\\frac{1}{2} f_t \\varepsilon_f = \\frac{G_f}{h}\n$$\nSolving for the calibration parameter $\\varepsilon_f$ yields:\n$$\n\\varepsilon_f = \\frac{2 G_f}{h f_t}\n$$\n\n#### 1.2. Exponential Softening Law\nThe exponential softening law is given by:\n$$\n\\sigma(\\varepsilon_p) = f_t \\, \\exp\\!\\left(-\\frac{\\varepsilon_p}{\\varepsilon_c}\\right), \\quad \\text{for} \\quad \\varepsilon_p \\ge 0\n$$\nwhere $\\varepsilon_c$ is a characteristic plastic strain. The plastic strain theoretically extends to infinity, so $\\varepsilon_{p,\\text{end}} = \\infty$. The energy equivalence integral is:\n$$\n\\int_{0}^{\\infty} f_t \\exp\\!\\left(-\\frac{\\varepsilon_p}{\\varepsilon_c}\\right) \\, d\\varepsilon_p = f_t \\left[-\\varepsilon_c \\exp\\!\\left(-\\frac{\\varepsilon_p}{\\varepsilon_c}\\right)\\right]_{0}^{\\infty} = f_t \\left(0 - (-\\varepsilon_c)\\right) = f_t \\varepsilon_c\n$$\nEquating this to the target energy density:\n$$\nf_t \\varepsilon_c = \\frac{G_f}{h}\n$$\nSolving for the calibration parameter $\\varepsilon_c$ gives:\n$$\n\\varepsilon_c = \\frac{G_f}{h f_t}\n$$\n\nA crucial consequence of this energy-based calibration is that the characteristic crack opening, $w = h \\varepsilon_p$, becomes independent of the mesh size $h$. For linear softening, the final crack opening is $w_f = h \\varepsilon_f = h \\frac{2G_f}{h f_t} = \\frac{2G_f}{f_t}$. For exponential softening, the characteristic crack opening is $w_c = h \\varepsilon_c = h \\frac{G_f}{h f_t} = \\frac{G_f}{f_t}$. This materializes the fracture energy $G_f$ as a property of a cohesive crack, independent of the numerical discretization $h$.\n\n### 2. Mesh Objectivity and Total Work Calculation\n\nMesh-objectivity requires that the total energy dissipated to cause failure of the structure is a constant material property, independent of the mesh size $h$. For this uniaxial specimen, the total consumed energy must equal the fracture energy $G_f$ multiplied by the crack area $A$, i.e., $A G_f$. We verify this by calculating the total external work $W_{\\text{total}}$ done on the system from initial loading to complete failure.\n\nThe total work is the sum of the work done during the initial elastic loading phase, $W_{\\text{el}}$, and the work done during the post-yield softening phase, $W_{\\text{post-yield}}$.\n$$\nW_{\\text{total}} = W_{\\text{el}} + W_{\\text{post-yield}}\n$$\n\n#### 2.1. Elastic Work ($W_{\\text{el}}$)\nThe system loads elastically until the force reaches the yield force $F_y = f_t A$. During this phase, the crack opening $w$ is zero, and the total displacement $\\Delta$ is due solely to the elastic deformation of the bar of length $L_r$.\n$$\n\\Delta = \\frac{L_r}{E A} F\n$$\nAt yield, the displacement is $\\Delta_y = \\frac{L_r}{E A} F_y = \\frac{L_r f_t}{E}$. The work done is the area of the force-displacement triangle:\n$$\nW_{\\text{el}} = \\frac{1}{2} F_y \\Delta_y = \\frac{1}{2} (f_t A) \\left( \\frac{L_r f_t}{E} \\right) = \\frac{A L_r f_t^2}{2E}\n$$\n\n#### 2.2. Post-Yield Work ($W_{\\text{post-yield}}$)\nAfter yielding, the crack opening $w$ increases from $0$ while the force $F$ decreases according to the softening law. The total displacement is given by $\\Delta(w) = \\frac{L_r}{EA}F(w) + w$. The force is $F(w) = A T(w)$, where $T(w) = \\sigma(w/h)$ is the cohesive traction. The external work is given by the integral $\\int F d\\Delta$. To handle potential snap-back (non-monotonic $\\Delta$), we parameterize the integral with respect to the crack opening $w$:\n$$\nd\\Delta = \\frac{d\\Delta}{dw} dw = \\left(1 + \\frac{L_r}{EA} \\frac{dF}{dw}\\right) dw = \\left(1 + \\frac{L_r}{E} \\frac{dT}{dw}\\right) dw\n$$\nThe post-yield work is then:\n$$\nW_{\\text{post-yield}} = \\int_{w=0}^{w=w_{\\text{end}}} F(w) \\, d\\Delta = \\int_{0}^{w_{\\text{end}}} A T(w) \\left(1 + \\frac{L_r}{E} \\frac{dT}{dw}\\right) dw\n$$\n$$\nW_{\\text{post-yield}} = A \\int_{0}^{w_{\\text{end}}} T(w) dw + \\frac{A L_r}{E} \\int_{0}^{w_{\\text{end}}} T(w) \\frac{dT}{dw} dw\n$$\nThe first term, $A \\int T(w) dw$, is by definition the total fracture energy $A G_f$. The second integral can be solved by recognizing that $T(w) dT = \\frac{1}{2} d(T^2)$:\n$$\n\\int_{w=0}^{w=w_{\\text{end}}} T(w) \\frac{dT}{dw} dw = \\int_{T(0)}^{T(w_{\\text{end}})} T dT = \\frac{1}{2} [T^2]_{T=f_t}^{T=0} = -\\frac{1}{2} f_t^2\n$$\nThis holds for any softening law where $T(0)=f_t$ and $T(w_{\\text{end}})=0$. Substituting back:\n$$\nW_{\\text{post-yield}} = A G_f + \\frac{A L_r}{E} \\left(-\\frac{1}{2} f_t^2\\right) = A G_f - \\frac{A L_r f_t^2}{2E}\n$$\n\n#### 2.3. Total Work and Mesh Objectivity\nCombining the elastic and post-yield work components provides the total work:\n$$\nW_{\\text{total}} = W_{\\text{el}} + W_{\\text{post-yield}} = \\left(\\frac{A L_r f_t^2}{2E}\\right) + \\left(A G_f - \\frac{A L_r f_t^2}{2E}\\right) = A G_f\n$$\nThis analytical result proves that the total external work required to fail the specimen is exactly $A G_f$, regardless of the element size $h$ (which is embedded in $L_r = L_{\\text{tot}}-h$), the elastic modulus $E$, or the specific form of the energy-calibrated softening law. This confirms that the crack-band model formulation is mesh-objective.\n\n### 3. Numerical Verification Procedure\n\nThe numerical implementation will verify the analytical findings. For each test case and for each value of $h \\in \\{h_1, h_2\\}$, the following quantities will be computed.\n\n1.  **Softening Law Area Check**:\n    - The calibration parameter ($\\varepsilon_f$ or $\\varepsilon_c$) is computed.\n    - The integral $\\int \\sigma(\\varepsilon_p) d\\varepsilon_p$ is numerically evaluated using `scipy.integrate.quad`. For the exponential case, the integration is performed up to $\\varepsilon_{p,\\text{end}} = 12 \\varepsilon_c$.\n    - The numerical result is compared to the theoretical target $G_f/h$, and the relative error is calculated as $| \\text{numerical} - \\text{target} | / \\text{target}$.\n\n2.  **Total Work Check**:\n    - The elastic work $W_{\\text{el}}$ is calculated using the analytical formula.\n    - The post-yield work integrand, $F(w)(d\\Delta/dw)$, is defined.\n    - $W_{\\text{post-yield}}$ is computed by numerically integrating this function with respect to $w$ from $0$ to $w_{\\text{end}}$ ($w_f$ for linear, $12w_c$ for exponential).\n    - The total numerical work $W_{\\text{total,num}} = W_{\\text{el}} + W_{\\text{post-yield,num}}$ is computed.\n    - This result is compared to the theoretical target $A G_f$, and the relative error is calculated.\n\nFinally, for each test case, the maximum of the four computed relative errors (area check for $h_1, h_2$ and work check for $h_1, h_2$) is reported. Due to the exactness of the analytical solution, these errors are expected to be very small, arising only from numerical quadrature precision and floating-point arithmetic.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Solves the computational geomechanics problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1: linear softening, happy path\n        {\n            'type': 'linear',\n            'E': 30e9, 'ft': 3e6, 'Gf': 120.0, 'A': 5e-3, 'L_tot': 1.0, \n            'h_values': [0.02, 0.10]\n        },\n        # Test case 2: exponential softening, happy path\n        {\n            'type': 'exponential',\n            'E': 30e9, 'ft': 3e6, 'Gf': 120.0, 'A': 5e-3, 'L_tot': 1.0, \n            'h_values': [0.02, 0.10]\n        },\n        # Test case 3: linear softening, boundary element sizes\n        {\n            'type': 'linear',\n            'E': 20e9, 'ft': 2e6, 'Gf': 80.0, 'A': 1e-3, 'L_tot': 0.2, \n            'h_values': [0.001, 0.05]\n        }\n    ]\n\n    results = []\n\n    for case_params in test_cases:\n        case_errors = []\n        softening_type = case_params['type']\n        E = case_params['E']\n        ft = case_params['ft']\n        Gf = case_params['Gf']\n        A = case_params['A']\n        L_tot = case_params['L_tot']\n        h_values = case_params['h_values']\n\n        for h in h_values:\n            L_r = L_tot - h\n\n            # 1. Calibrate and perform area check\n            if softening_type == 'linear':\n                # Calibration\n                eps_f = (2 * Gf) / (h * ft)\n                w_f = h * eps_f\n\n                # Area check\n                sigma_func = lambda eps_p: ft * (1 - eps_p / eps_f)\n                area_num, _ = integrate.quad(sigma_func, 0, eps_f)\n                \n                # Post-yield work calculation\n                T_func = lambda w: ft * (1 - w / w_f)\n                dTdw_func = lambda w: -ft / w_f\n                w_end = w_f\n            \n            elif softening_type == 'exponential':\n                # Calibration\n                eps_c = Gf / (h * ft)\n                w_c = h * eps_c\n\n                # Area check (truncated)\n                eps_end_factor = 12.0\n                eps_end = eps_end_factor * eps_c\n                sigma_func = lambda eps_p: ft * np.exp(-eps_p / eps_c)\n                area_num, _ = integrate.quad(sigma_func, 0, eps_end)\n\n                # Post-yield work calculation\n                T_func = lambda w: ft * np.exp(-w / w_c)\n                dTdw_func = lambda w: (-ft / w_c) * np.exp(-w / w_c)\n                w_end = eps_end_factor * w_c\n\n            area_target = Gf / h\n            rel_err_area = abs(area_num - area_target) / area_target\n            case_errors.append(rel_err_area)\n            \n            # 2. Compute total work and perform check\n            # Elastic work\n            W_el = (A * L_r * ft**2) / (2 * E)\n\n            # Post-yield work integrand: F(w) * d(Delta)/dw\n            work_integrand = lambda w: (A * T_func(w)) * (1 + (L_r / E) * dTdw_func(w))\n            \n            # Integrate to get post-yield work\n            W_post_yield_num, _ = integrate.quad(work_integrand, 0, w_end)\n            \n            W_total_num = W_el + W_post_yield_num\n            \n            # Target total work\n            W_target = A * Gf\n            \n            rel_err_work = abs(W_total_num - W_target) / W_target\n            case_errors.append(rel_err_work)\n\n        results.append(max(case_errors))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3529154"}, {"introduction": "Advanced geomechanical models often contain parameters that cannot be measured directly, such as internal length scales $l$ in gradient plasticity theories. This exercise tackles the essential task of parameter identification through inverse analysis, where model parameters are inferred by fitting predictions to experimental observations. You will implement a Gauss-Newton optimization scheme to determine the parameters of a gradient-enhanced softening model from synthetic data on shear band characteristics, bridging the gap between theoretical models and measurable reality [@problem_id:3529148].", "problem": "You are asked to implement and solve a deterministic inverse problem in computational geomechanics to infer the cohesion softening law and an internal gradient length from banding observables in a simplified gradient-enhanced elasto-plastic surrogate model. Your program must implement a forward model for the shear band angle and thickness as functions of material parameters and state variables, derive the Jacobian sensitivities analytically, and solve a regularized inverse problem using a Gauss–Newton scheme with line search. The task is to estimate the parameters of the cohesion softening function and the gradient length for a small test suite. All angles must be handled in degrees, all stresses in Pascals, all lengths in meters, and plastic strains are dimensionless.\n\nThe forward model is defined as follows. Consider a plane strain, pressure-sensitive, frictional–cohesive material with nonassociated plastic flow. Let the friction angle be $\\phi$ (in degrees) and the dilatancy angle be $\\psi$ (in degrees). Let the plastic strain scalar be $\\bar{\\epsilon}_p$. The cohesion softening is parameterized by a linear law\n$$\nc(\\bar{\\epsilon}_p) = c_0 - h_p \\, \\bar{\\epsilon}_p,\n$$\nwhere $c_0$ (in Pascals) and $h_p$ (in Pascals) are unknown parameters to be inferred. Let the shear modulus be $G$ (in Pascals), the constant normal stress be $\\sigma_n$ (in Pascals), and the internal gradient length be $l$ (in meters). Define the dimensionless softening ratio $S = h_p/G$. The shear band orientation (in degrees) relative to the major principal stress direction is modeled by a Roscoe-type base plus a softening-dependent correction\n$$\n\\theta(\\bar{\\epsilon}_p) = \\left(45 + \\frac{\\phi - \\psi}{2}\\right) + \\frac{180}{\\pi}\\cdot \\frac{1}{2}\\arctan\\!\\Big( \\underbrace{(\\sin\\phi_r - \\sin\\psi_r)}_{d} \\cdot \\underbrace{\\frac{c(\\bar{\\epsilon}_p)}{\\sigma_n}}_{\\text{cohesion-to-pressure}} \\cdot \\underbrace{\\frac{h_p}{G}}_{S} \\Big),\n$$\nwhere $\\phi_r = \\phi \\cdot \\pi/180$ and $\\psi_r = \\psi \\cdot \\pi/180$ are angles in radians. The shear band thickness (in meters) is modeled by a gradient-plasticity scaling relation\n$$\nw(\\bar{\\epsilon}_p) = \\pi \\, l \\, \\sqrt{\\frac{G + k_c \\, c(\\bar{\\epsilon}_p)}{h_p}},\n$$\nwith a fixed, dimensionless pressure-sensitivity blending factor $k_c = 0.5$. These relations are to be treated as a simplified, scientifically plausible surrogate consistent with acoustic-tensor localization ideas and internal length scaling, but not as exact derivations for any specific yield surface.\n\nYou will solve an inverse problem for the parameter vector $\\mathbf{p} = [c_0,\\, h_p,\\, l]^T$ using observations $\\{\\theta^{\\mathrm{obs}}_s, w^{\\mathrm{obs}}_s\\}$ at several plastic strain levels $\\bar{\\epsilon}_{p,s}$. The misfit residuals must be normalized by the measurement standard deviations $\\sigma_\\theta$ (in degrees) and $\\sigma_w$ (in meters). Use Tikhonov regularization with a Gaussian prior $\\mathbf{p}_{\\mathrm{prior}}$ and diagonal prior standard deviations $\\boldsymbol{\\sigma}_{\\mathrm{prior}}$. Specifically, let the residual vector be\n$$\n\\mathbf{r}(\\mathbf{p}) = \\begin{bmatrix}\n\\frac{\\theta(\\bar{\\epsilon}_{p,1};\\mathbf{p}) - \\theta^{\\mathrm{obs}}_1}{\\sigma_\\theta} \\\\\n\\frac{w(\\bar{\\epsilon}_{p,1};\\mathbf{p}) - w^{\\mathrm{obs}}_1}{\\sigma_w} \\\\\n\\vdots \\\\\n\\frac{\\theta(\\bar{\\epsilon}_{p,S};\\mathbf{p}) - \\theta^{\\mathrm{obs}}_S}{\\sigma_\\theta} \\\\\n\\frac{w(\\bar{\\epsilon}_{p,S};\\mathbf{p}) - w^{\\mathrm{obs}}_S}{\\sigma_w} \\\\\n\\sqrt{\\lambda}\\,\\frac{c_0 - c_{0,\\mathrm{prior}}}{\\sigma_{c_0}} \\\\\n\\sqrt{\\lambda}\\,\\frac{h_p - h_{p,\\mathrm{prior}}}{\\sigma_{h_p}} \\\\\n\\sqrt{\\lambda}\\,\\frac{l - l_{\\mathrm{prior}}}{\\sigma_{l}}\n\\end{bmatrix},\n$$\nwhere $\\lambda$ is the Tikhonov regularization weight, and $S$ is the number of observation stages. Use a Gauss–Newton update with an analytically derived Jacobian $\\mathbf{J} = \\partial \\mathbf{r}/\\partial \\mathbf{p}$ and a backtracking line search to ensure descent. Enforce positivity by simple projection after each update: $h_p \\geq 10^3$, $l \\geq 10^{-6}$, and $c_0 \\geq 10^3$.\n\nAnalytical sensitivities for one stage at $\\bar{\\epsilon}_p$ are to be derived from the forward model using the chain rule. Let $c = c(\\bar{\\epsilon}_p) = c_0 - h_p \\bar{\\epsilon}_p$, $d = \\sin\\phi_r - \\sin\\psi_r$, $z = d \\cdot \\frac{c}{\\sigma_n} \\cdot \\frac{h_p}{G}$, and $A = G + k_c c$. Then\n$$\n\\theta = \\theta_0 + \\frac{180}{\\pi}\\cdot \\frac{1}{2}\\arctan(z), \\quad \\theta_0 = 45 + \\frac{\\phi - \\psi}{2},\n$$\nand\n$$\nw = \\pi\\, l \\sqrt{\\frac{A}{h_p}}.\n$$\nThe needed partial derivatives are\n$$\n\\frac{\\partial \\theta}{\\partial c_0} = \\frac{180}{\\pi}\\cdot \\frac{1}{2}\\cdot \\frac{1}{1+z^2}\\cdot \\frac{d}{\\sigma_n}\\cdot \\frac{h_p}{G}, \\quad\n\\frac{\\partial \\theta}{\\partial h_p} = \\frac{180}{\\pi}\\cdot \\frac{1}{2}\\cdot \\frac{1}{1+z^2}\\cdot \\frac{d}{\\sigma_n G}\\left(c - h_p \\bar{\\epsilon}_p\\right), \\quad\n\\frac{\\partial \\theta}{\\partial l} = 0,\n$$\nand\n$$\n\\frac{\\partial w}{\\partial l} = \\pi \\sqrt{\\frac{A}{h_p}}, \\quad\n\\frac{\\partial w}{\\partial c_0} = \\pi l \\cdot \\frac{k_c}{2\\sqrt{A h_p}}, \\quad\n\\frac{\\partial w}{\\partial h_p} = \\pi l \\cdot \\frac{1}{2}\\cdot \\frac{-\\left(A + k_c h_p \\bar{\\epsilon}_p\\right)}{h_p^{2}\\sqrt{A/h_p}}.\n$$\nNormalize the rows of $\\mathbf{J}$ by dividing the $\\theta$-row by $\\sigma_\\theta$ and the $w$-row by $\\sigma_w$. Append the regularization rows $\\sqrt{\\lambda}\\,\\mathrm{diag}(1/\\sigma_{c_0},\\,1/\\sigma_{h_p},\\,1/\\sigma_{l})$.\n\nImplement the solver with parameter scaling to improve conditioning. Use $\\mathbf{s} = [10^5,\\,10^6,\\,10^{-3}]^T$ as scaling, and optimize with respect to $\\mathbf{x} = \\mathbf{p} \\oslash \\mathbf{s}$, where $\\oslash$ is element-wise division.\n\nMeasurement uncertainties are fixed at $\\sigma_\\theta = 0.25$ (in degrees) and $\\sigma_w = 2.0\\times 10^{-4}$ (in meters). The constant $k_c = 0.5$.\n\nTest suite. Solve the inverse problem for the following three cases. Each case has two observation stages $S=2$ at plastic strain levels $\\bar{\\epsilon}_{p,1}$ and $\\bar{\\epsilon}_{p,2}$, with given observed shear band angles $\\theta^{\\mathrm{obs}}_1$, $\\theta^{\\mathrm{obs}}_2$ (in degrees) and thicknesses $w^{\\mathrm{obs}}_1$, $w^{\\mathrm{obs}}_2$ (in meters), and known $(\\phi,\\psi,G,\\sigma_n)$. Use the provided prior $\\mathbf{p}_{\\mathrm{prior}}$ and prior standard deviations $\\boldsymbol{\\sigma}_{\\mathrm{prior}}$, and set $\\lambda = 1$.\n\n- Case A:\n  - $\\phi = 30$, $\\psi = 10$, $G = 3.0\\times 10^{7}$, $\\sigma_n = 2.0\\times 10^{5}$.\n  - Stages: $\\bar{\\epsilon}_{p,1} = 0.02$, $\\bar{\\epsilon}_{p,2} = 0.06$.\n  - Observations: $\\theta^{\\mathrm{obs}} = [55.4990,\\,55.2495]$, $w^{\\mathrm{obs}} = [0.006091716,\\,0.006086935]$.\n  - Prior: $\\mathbf{p}_{\\mathrm{prior}} = [1.8\\times 10^{5},\\,1.5\\times 10^{6},\\,7.0\\times 10^{-4}]$.\n  - Prior standard deviations: $\\boldsymbol{\\sigma}_{\\mathrm{prior}} = [1.0\\times 10^{5},\\,1.0\\times 10^{6},\\,5.0\\times 10^{-4}]$.\n\n- Case B:\n  - $\\phi = 35$, $\\psi = 5$, $G = 2.0\\times 10^{7}$, $\\sigma_n = 1.5\\times 10^{5}$.\n  - Stages: $\\bar{\\epsilon}_{p,1} = 0.01$, $\\bar{\\epsilon}_{p,2} = 0.05$.\n  - Observations: $\\theta^{\\mathrm{obs}} = [60.7690,\\,60.5020]$, $w^{\\mathrm{obs}} = [0.010278286,\\,0.010272254]$.\n  - Prior: $\\mathbf{p}_{\\mathrm{prior}} = [1.2\\times 10^{5},\\,1.0\\times 10^{6},\\,1.0\\times 10^{-3}]$.\n  - Prior standard deviations: $\\boldsymbol{\\sigma}_{\\mathrm{prior}} = [1.0\\times 10^{5},\\,8.0\\times 10^{5},\\,6.0\\times 10^{-4}]$.\n\n- Case C:\n  - $\\phi = 25$, $\\psi = 20$, $G = 4.0\\times 10^{7}$, $\\sigma_n = 1.0\\times 10^{5}$.\n  - Stages: $\\bar{\\epsilon}_{p,1} = 0.015$, $\\barepsilon}_{p,2} = 0.045$.\n  - Observations: $\\theta^{\\mathrm{obs}} = [47.5499,\\,47.5388]$, $w^{\\mathrm{obs}} = [0.006668973,\\,0.006667842]$.\n  - Prior: $\\mathbf{p}_{\\mathrm{prior}} = [1.0\\times 10^{5},\\,5.0\\times 10^{5},\\,5.0\\times 10^{-4}]$.\n  - Prior standard deviations: $\\boldsymbol{\\sigma}_{\\mathrm{prior}} = [8.0\\times 10^{4},\\,4.0\\times 10^{5},\\,4.0\\times 10^{-4}]$.\n\nAlgorithmic requirements:\n- Implement Gauss–Newton with line search. At iteration $k$, solve the normal equations\n$$\n(\\mathbf{J}_k^T \\mathbf{J}_k)\\,\\Delta\\mathbf{x}_k = - \\mathbf{J}_k^T \\mathbf{r}_k,\n$$\nwhere $\\mathbf{x} = \\mathbf{p}\\oslash \\mathbf{s}$. Use backtracking on a step length $t \\in \\{1,\\,1/2,\\,1/4,\\,\\dots\\}$ until the cost decreases. Map the update back to $\\mathbf{p}$ via $\\Delta \\mathbf{p}_k = \\mathbf{s} \\odot \\Delta \\mathbf{x}_k$, where $\\odot$ is element-wise multiplication. After updating $\\mathbf{p}$, project to enforce $c_0 \\ge 10^3$, $h_p \\ge 10^3$, $l \\ge 10^{-6}$. Stop if $\\|\\Delta \\mathbf{p}_k\\|_2 / \\|\\mathbf{p}_k\\|_2 < 10^{-8}$ or after $50$ iterations.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of three sublists, each sublist corresponding to one case in the order A, B, C. Each sublist must contain three numbers in the order $[c_0, h_p, l]$. Report $c_0$ (in Pascals) and $h_p$ (in Pascals) rounded to the nearest integer and $l$ (in meters) rounded to six decimal places. For example: \"[[c0_A,hp_A,l_A],[c0_B,hp_B,l_B],[c0_C,hp_C,l_C]]\".", "solution": "The problem presented is a deterministic inverse problem to infer material parameters from observable physical quantities within the framework of computational geomechanics. Specifically, we are asked to estimate three parameters of a gradient-enhanced elasto-plastic model—the initial cohesion $c_0$, the cohesion softening modulus $h_p$, and an internal length scale $l$—from measurements of shear band orientation $\\theta$ and thickness $w$ at different stages of plastic deformation $\\bar{\\epsilon}_p$.\n\nThe problem is valid as it is scientifically grounded, well-posed, and contains all necessary information for a unique numerical solution. The physical model is a plausible surrogate for shear banding, and the inverse problem is formulated using a standard, robust numerical technique. The provided analytical derivatives are correct, and the numerical values are physically reasonable.\n\nThe solution is found by minimizing a Tikhonov-regularized, non-linear least-squares objective function using a Gauss-Newton algorithm. The process involves several key components: the forward model, the objective function, and the optimization scheme.\n\n**1. Forward Model and Objective Function**\n\nThe parameters to be identified are $\\mathbf{p} = [c_0, h_p, l]^T$. The forward model predicts the observable quantities, shear band angle $\\theta$ and thickness $w$, as functions of these parameters and the accumulated plastic strain $\\bar{\\epsilon}_p$. The cohesion $c$ is defined by a linear softening law, $c(\\bar{\\epsilon}_p) = c_0 - h_p \\bar{\\epsilon}_p$.\n\nThe shear band angle $\\theta$ (in degrees) is given by:\n$$\n\\theta(\\bar{\\epsilon}_p; \\mathbf{p}) = \\left(45 + \\frac{\\phi - \\psi}{2}\\right) + \\frac{90}{\\pi}\\arctan\\!\\left( (\\sin\\phi_r - \\sin\\psi_r) \\frac{c(\\bar{\\epsilon}_p)}{\\sigma_n} \\frac{h_p}{G} \\right)\n$$\nThe shear band thickness $w$ (in meters) is given by:\n$$\nw(\\bar{\\epsilon}_p; \\mathbf{p}) = \\pi l \\sqrt{\\frac{G + k_c c(\\bar{\\epsilon}_p)}{h_p}}\n$$\nwhere $\\phi$, $\\psi$, $G$, $\\sigma_n$, and $k_c$ are known material constants and state variables.\n\nThe inverse problem is formulated by minimizing an objective function $\\mathcal{F}(\\mathbf{p})$ representing the total squared error. This function comprises two parts: a data misfit term and a regularization term. The total residual vector $\\mathbf{r}(\\mathbf{p})$ for a set of $S$ observation stages is:\n$$\n\\mathbf{r}(\\mathbf{p}) = \\begin{bmatrix} \\mathbf{r}_{\\text{data}}(\\mathbf{p}) \\\\ \\mathbf{r}_{\\text{reg}}(\\mathbf{p}) \\end{bmatrix}\n$$\nThe data misfit residual $\\mathbf{r}_{\\text{data}}$ measures the discrepancy between model predictions and observations, with each entry normalized by its respective measurement standard deviation ($\\sigma_\\theta$ or $\\sigma_w$). This normalization ensures that all measurements contribute appropriately to the objective function, irrespective of their units or magnitudes.\n$$\n\\mathbf{r}_{\\text{data}}(\\mathbf{p}) = \\begin{bmatrix}\n(\\theta(\\bar{\\epsilon}_{p,1};\\mathbf{p}) - \\theta^{\\mathrm{obs}}_1)/\\sigma_\\theta \\\\\n(w(\\bar{\\epsilon}_{p,1};\\mathbf{p}) - w^{\\mathrm{obs}}_1)/\\sigma_w \\\\\n\\vdots \\\\\n(\\theta(\\bar{\\epsilon}_{p,S};\\mathbf{p}) - \\theta^{\\mathrm{obs}}_S)/\\sigma_\\theta \\\\\n(w(\\bar{\\epsilon}_{p,S};\\mathbf{p}) - w^{\\mathrm{obs}}_S)/\\sigma_w\n\\end{bmatrix}\n$$\nThe regularization residual $\\mathbf{r}_{\\text{reg}}$ incorporates prior knowledge about the parameters. This is a form of Tikhonov regularization, which can be interpreted from a Bayesian perspective as assuming a Gaussian prior distribution for the parameters $\\mathbf{p} \\sim \\mathcal{N}(\\mathbf{p}_{\\mathrm{prior}}, \\boldsymbol{\\Sigma}_{\\mathrm{prior}})$, where $\\boldsymbol{\\Sigma}_{\\mathrm{prior}} = \\text{diag}(\\sigma_{c_0}^2, \\sigma_{h_p}^2, \\sigma_{l}^2)$. This term is crucial for stabilizing the solution of what is often an ill-posed or ill-conditioned inverse problem, preventing non-physical parameter estimates.\n$$\n\\mathbf{r}_{\\text{reg}}(\\mathbf{p}) = \\sqrt{\\lambda}\\begin{bmatrix}\n(c_0 - c_{0,\\mathrm{prior}})/\\sigma_{c_0} \\\\\n(h_p - h_{p,\\mathrm{prior}})/\\sigma_{h_p} \\\\\n(l - l_{\\mathrm{prior}})/\\sigma_{l}\n\\end{bmatrix}\n$$\nThe objective is to find $\\mathbf{p}^* = \\arg\\min_{\\mathbf{p}} \\mathcal{F}(\\mathbf{p})$, where $\\mathcal{F}(\\mathbf{p}) = \\frac{1}{2} \\mathbf{r}(\\mathbf{p})^T \\mathbf{r}(\\mathbf{p})$.\n\n**2. Gauss-Newton Optimization**\n\nThe Gauss-Newton method is an iterative algorithm for solving non-linear least squares problems. At each iteration $k$, the residual vector $\\mathbf{r}(\\mathbf{p})$ is approximated by its first-order Taylor expansion around the current estimate $\\mathbf{p}_k$:\n$$\n\\mathbf{r}(\\mathbf{p}_k + \\Delta\\mathbf{p}) \\approx \\mathbf{r}(\\mathbf{p}_k) + \\mathbf{J}_k \\Delta\\mathbf{p}\n$$\nwhere $\\mathbf{J}_k = \\partial\\mathbf{r}/\\partial\\mathbf{p}|_{\\mathbf{p}_k}$ is the Jacobian matrix of the residual vector. Minimizing the squared norm of this linearized residual with respect to the parameter update $\\Delta\\mathbf{p}$ leads to the normal equations:\n$$\n(\\mathbf{J}_k^T \\mathbf{J}_k) \\Delta\\mathbf{p}_k = -\\mathbf{J}_k^T \\mathbf{r}_k\n$$\nThe parameters often span several orders of magnitude, which can lead to a poorly conditioned Jacobian matrix $\\mathbf{J}_k$. To mitigate this, we introduce a non-dimensional, scaled parameter vector $\\mathbf{x} = \\mathbf{p} \\oslash \\mathbf{s}$, where $\\mathbf{s}$ is a vector of scaling factors and $\\oslash$ denotes element-wise division. The optimization is performed with respect to $\\mathbf{x}$. The chain rule gives the relationship between the Jacobians: $\\mathbf{J}_{\\mathbf{x}} = \\mathbf{J}_{\\mathbf{p}} \\text{diag}(\\mathbf{s})$. The normal equations are then reformulated in terms of the scaled update $\\Delta\\mathbf{x}_k$:\n$$\n(\\mathbf{J}_{\\mathbf{x},k}^T \\mathbf{J}_{\\mathbf{x},k}) \\Delta\\mathbf{x}_k = -\\mathbf{J}_{\\mathbf{x},k}^T \\mathbf{r}_k\n$$\nAfter solving this linear system for $\\Delta\\mathbf{x}_k$, the update is mapped back to the original parameter space: $\\Delta\\mathbf{p}_k = \\mathbf{s} \\odot \\Delta\\mathbf{x}_k$.\n\nTo ensure robust convergence, the full update step $\\Delta\\mathbf{p}_k$ is scaled by a step length $t \\in (0,1]$, i.e., $\\mathbf{p}_{k+1} = \\mathbf{p}_k + t \\Delta\\mathbf{p}_k$. The step length $t$ is determined using a backtracking line search, which reduces $t$ (e.g., by factors of $2$) until the objective function value decreases: $\\mathcal{F}(\\mathbf{p}_{k+1}) < \\mathcal{F}(\\mathbf{p}_k)$.\n\nFinally, to ensure the physical admissibility of the parameters, a projection step is applied after each update: $c_0$ and $h_p$ are enforced to be greater than or equal to $10^3\\,$Pa, and $l$ is enforced to be greater than or equal to $10^{-6}\\,$m.\n\nThe iterative process starts with the prior estimate, $\\mathbf{p}_0 = \\mathbf{p}_{\\mathrm{prior}}$, and continues until the relative norm of the parameter update falls below a specified tolerance of $10^{-8}$ or a maximum number of iterations is reached. The analytical derivatives provided in the problem statement are used to construct the Jacobian matrix $\\mathbf{J}_{\\mathbf{p}}$.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the inverse problem for the given test suite.\n    \"\"\"\n\n    # --- Global Constants ---\n    SIGMA_THETA = 0.25  # degrees\n    SIGMA_W = 2.0e-4   # meters\n    KC = 0.5\n    LAMBDA_REG = 1.0\n    PARAM_SCALES = np.array([1e5, 1e6, 1e-3])\n    \n    # --- Test Suite ---\n    test_cases = [\n        {   # Case A\n            \"phi\": 30.0, \"psi\": 10.0, \"G\": 3.0e7, \"sigma_n\": 2.0e5,\n            \"eps_p_stages\": np.array([0.02, 0.06]),\n            \"obs_theta\": np.array([55.4990, 55.2495]),\n            \"obs_w\": np.array([0.006091716, 0.006086935]),\n            \"p_prior\": np.array([1.8e5, 1.5e6, 7.0e-4]),\n            \"sigma_prior\": np.array([1.0e5, 1.0e6, 5.0e-4]),\n        },\n        {   # Case B\n            \"phi\": 35.0, \"psi\": 5.0, \"G\": 2.0e7, \"sigma_n\": 1.5e5,\n            \"eps_p_stages\": np.array([0.01, 0.05]),\n            \"obs_theta\": np.array([60.7690, 60.5020]),\n            \"obs_w\": np.array([0.010278286, 0.010272254]),\n            \"p_prior\": np.array([1.2e5, 1.0e6, 1.0e-3]),\n            \"sigma_prior\": np.array([1.0e5, 8.0e5, 6.0e-4]),\n        },\n        {   # Case C\n            \"phi\": 25.0, \"psi\": 20.0, \"G\": 4.0e7, \"sigma_n\": 1.0e5,\n            \"eps_p_stages\": np.array([0.015, 0.045]),\n            \"obs_theta\": np.array([47.5499, 47.5388]),\n            \"obs_w\": np.array([0.006668973, 0.006667842]),\n            \"p_prior\": np.array([1.0e5, 5.0e5, 5.0e-4]),\n            \"sigma_prior\": np.array([8.0e4, 4.0e5, 4.0e-4]),\n        }\n    ]\n\n    def _project_params(p):\n        \"\"\"Enforces positivity constraints on parameters.\"\"\"\n        p_proj = np.copy(p)\n        p_proj[0] = max(p_proj[0], 1e3)  # c0\n        p_proj[1] = max(p_proj[1], 1e3)  # hp\n        p_proj[2] = max(p_proj[2], 1e-6) # l\n        return p_proj\n\n    def _compute_residuals_and_jacobian(p, case):\n        \"\"\"\n        Computes the full residual vector and the Jacobian matrix w.r.t. scaled parameters.\n        \"\"\"\n        c0, hp, l = p\n        phi, psi, G, sigma_n = case[\"phi\"], case[\"psi\"], case[\"G\"], case[\"sigma_n\"]\n        eps_p_stages = case[\"eps_p_stages\"]\n        \n        num_stages = len(eps_p_stages)\n        num_data_rows = 2 * num_stages\n        num_params = 3\n\n        r_data = np.zeros(num_data_rows)\n        Jp_data = np.zeros((num_data_rows, num_params))\n\n        phi_r = np.deg2rad(phi)\n        psi_r = np.deg2rad(psi)\n        d = np.sin(phi_r) - np.sin(psi_r)\n        theta0 = 45.0 + (phi - psi) / 2.0\n\n        for i, eps_p in enumerate(eps_p_stages):\n            c = c0 - hp * eps_p\n            if hp <= 0: return None, None # Invalid parameter\n            \n            # --- Forward Model ---\n            # Angle theta\n            z = d * (c / sigma_n) * (hp / G)\n            theta_pred = theta0 + (90.0 / np.pi) * np.arctan(z)\n            \n            # Thickness w\n            A = G + KC * c\n            if A <= 0: return None, None # Invalid parameter\n            w_pred = np.pi * l * np.sqrt(A / hp)\n\n            # --- Residuals (data part) ---\n            r_data[2*i] = (theta_pred - case[\"obs_theta\"][i])\n            r_data[2*i+1] = (w_pred - case[\"obs_w\"][i])\n\n            # --- Jacobian w.r.t. p (data part) ---\n            # Derivatives for theta\n            d_theta_common = (90.0 / np.pi) / (1.0 + z**2)\n            d_theta_dc0 = d_theta_common * (d / sigma_n) * (hp / G)\n            d_theta_dhp = d_theta_common * (d / (sigma_n * G)) * (c0 - 2 * hp * eps_p)\n            d_theta_dl = 0.0\n            \n            # Derivatives for w\n            sqrt_A_hp = np.sqrt(A * hp)\n            sqrt_A_over_hp = np.sqrt(A / hp)\n            d_w_dc0 = np.pi * l * KC / (2.0 * sqrt_A_hp)\n            d_w_dhp = np.pi * l * 0.5 * (-(A + KC * hp * eps_p)) / (hp**2 * sqrt_A_over_hp)\n            d_w_dl = np.pi * sqrt_A_over_hp\n\n            Jp_data[2*i, :] = [d_theta_dc0, d_theta_dhp, d_theta_dl]\n            Jp_data[2*i+1, :] = [d_w_dc0, d_w_dhp, d_w_dl]\n\n        # Normalize data residuals and data Jacobian rows\n        r_data[::2] /= SIGMA_THETA\n        r_data[1::2] /= SIGMA_W\n        Jp_data[::2, :] /= SIGMA_THETA\n        Jp_data[1::2, :] /= SIGMA_W\n\n        # --- Regularization part ---\n        p_prior, sigma_prior = case[\"p_prior\"], case[\"sigma_prior\"]\n        r_reg = np.sqrt(LAMBDA_REG) * (p - p_prior) / sigma_prior\n        Jp_reg = np.sqrt(LAMBDA_REG) * np.diag(1.0 / sigma_prior)\n\n        # --- Combine and scale Jacobian ---\n        r_full = np.concatenate([r_data, r_reg])\n        Jp_full = np.vstack([Jp_data, Jp_reg])\n        Jx_full = Jp_full * PARAM_SCALES  # Column-wise scaling\n\n        return r_full, Jx_full\n\n    def _run_gauss_newton(case):\n        \"\"\"Solves the inverse problem for a single case.\"\"\"\n        p = np.copy(case[\"p_rior\"])\n        p = _project_params(p)\n\n        max_iter = 50\n        tol = 1e-8\n\n        for k in range(max_iter):\n            r, Jx = _compute_residuals_and_jacobian(p, case)\n            if r is None: # Invalid parameter set encountered\n                break \n\n            cost = np.dot(r, r)\n\n            # Solve normal equations for scaled parameters\n            JtJ = Jx.T @ Jx\n            Jtr = Jx.T @ r\n            try:\n                delta_x = np.linalg.solve(JtJ, -Jtr)\n            except np.linalg.LinAlgError:\n                break # Singular matrix\n                \n            delta_p_full = delta_x * PARAM_SCALES\n\n            # Backtracking line search\n            t = 1.0\n            p_new = p\n            found_descent = False\n            for _ in range(10): # Max 10 backtracking steps\n                p_trial = p + t * delta_p_full\n                p_trial = _project_params(p_trial)\n                \n                r_trial, _ = _compute_residuals_and_jacobian(p_trial, case)\n                if r_trial is None:\n                    t /= 2.0\n                    continue\n\n                cost_trial = np.dot(r_trial, r_trial)\n                \n                if cost_trial < cost:\n                    p_new = p_trial\n                    found_descent = True\n                    break\n                t /= 2.0\n            \n            if not found_descent:\n                break # Line search failed\n            \n            actual_delta_p = p_new - p\n            p = p_new\n            \n            # Check for convergence\n            if np.linalg.norm(actual_delta_p) / np.linalg.norm(p) < tol:\n                break\n        \n        return p\n\n    results_list = []\n    for case in test_cases:\n        p_final = _run_gauss_newton(case)\n        c0, hp, l = p_final\n        results_list.append(f\"[{round(c0)},{round(hp)},{l:.6f}]\")\n\n    print(f\"[{','.join(results_list)}]\")\n\nsolve()\n\n```", "id": "3529148"}]}