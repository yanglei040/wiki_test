{"hands_on_practices": [{"introduction": "The cornerstone of any explicit stress integration scheme is the elastic predictor. This initial step assumes a purely elastic response to a given strain increment, generating a 'trial' stress state that is then checked against the material's yield criterion. This foundational exercise ([@problem_id:3523455]) challenges you to construct this elastic mapping for the common and important case of plane strain, helping you master the application of Hooke's Law in a constrained setting and understand how stresses develop even in directions with zero strain.", "problem": "Consider an isotropic, linear elastic geomaterial under small strains in a plane strain setting, where the kinematic constraint enforces zero out-of-plane strain. In an explicit stress integration scheme, the elastic predictor step maps a given strain increment to a trial Cauchy stress state prior to any plastic correction. Starting from the three-dimensional small-strain, isotropic linear elasticity constitutive law, construct the elastic predictor mapping that takes the in-plane strain increment vector $\\Delta\\varepsilon = (\\Delta\\varepsilon_{xx},\\,\\Delta\\varepsilon_{yy},\\,0,\\,\\Delta\\gamma_{xy})$ to the trial stress vector $\\sigma^{tr} = (\\sigma^{tr}_{xx},\\,\\sigma^{tr}_{yy},\\,\\sigma^{tr}_{zz},\\,\\tau^{tr}_{xy})$ in plane strain. Explicitly identify how the constrained out-of-plane strain contributes to $\\sigma^{tr}_{zz}$ in the elastic predictor.\n\nAssume the material has Young’s modulus $E = 1200\\,\\text{MPa}$ and Poisson’s ratio $\\nu = 0.30$. The incremental strain state is\n$$\n\\Delta\\varepsilon_{xx} = 1.5\\times 10^{-3},\\quad \\Delta\\varepsilon_{yy} = -5.0\\times 10^{-4},\\quad \\Delta\\gamma_{xy} = 2.0\\times 10^{-3}.\n$$\nAssume the previous stress state is zero, so that the elastic predictor trial stress equals the stress increment. Using the constructed mapping, compute the numerical values of $\\sigma^{tr}_{xx}$, $\\sigma^{tr}_{yy}$, $\\sigma^{tr}_{zz}$, and $\\tau^{tr}_{xy}$. Express the final stress components in megapascals (MPa) and round each to four significant figures.", "solution": "The problem is valid as it is scientifically grounded in linear elasticity theory, well-posed with sufficient data, and objectively formulated. We shall proceed with the solution.\n\nThe starting point is the three-dimensional, isotropic, linear elastic constitutive law (Hooke's Law) for small strains, which relates the Cauchy stress tensor $\\sigma_{ij}$ to the strain tensor $\\varepsilon_{ij}$:\n$$\n\\sigma_{ij} = \\lambda \\delta_{ij} \\varepsilon_{kk} + 2G \\varepsilon_{ij}\n$$\nHere, $\\delta_{ij}$ is the Kronecker delta, $\\varepsilon_{kk} = \\varepsilon_{xx} + \\varepsilon_{yy} + \\varepsilon_{zz}$ is the trace of the strain tensor (volumetric strain), and $\\lambda$ and $G$ are the Lamé parameters. These are related to Young's modulus $E$ and Poisson's ratio $\\nu$ by:\n$$\nG = \\frac{E}{2(1+\\nu)} \\quad \\text{and} \\quad \\lambda = \\frac{E\\nu}{(1+\\nu)(1-2\\nu)}\n$$\nThe elastic predictor step in an explicit integration scheme calculates a trial stress increment $\\Delta\\sigma^{tr}$ assuming a fully elastic response to a given strain increment $\\Delta\\varepsilon$. When the previous stress state is zero, the trial stress $\\sigma^{tr}$ is equal to the stress increment $\\Delta\\sigma$. The incremental form of the constitutive law is:\n$$\n\\Delta\\sigma_{ij} = \\lambda \\delta_{ij} \\Delta\\varepsilon_{kk} + 2G \\Delta\\varepsilon_{ij}\n$$\nThe problem specifies a plane strain condition, which imposes the kinematic constraint that there is no strain in the out-of-plane direction ($z$-direction). This means $\\Delta\\varepsilon_{zz} = 0$. Additionally, the out-of-plane shear strains are zero, $\\Delta\\gamma_{xz} = 2\\Delta\\varepsilon_{xz} = 0$ and $\\Delta\\gamma_{yz} = 2\\Delta\\varepsilon_{yz} = 0$.\n\nApplying these constraints, the incremental volumetric strain becomes $\\Delta\\varepsilon_{kk} = \\Delta\\varepsilon_{xx} + \\Delta\\varepsilon_{yy}$. We can now write the components of the trial stress increment:\nFor the in-plane normal stresses:\n$$\n\\sigma^{tr}_{xx} = \\Delta\\sigma_{xx} = \\lambda(\\Delta\\varepsilon_{xx} + \\Delta\\varepsilon_{yy}) + 2G \\Delta\\varepsilon_{xx} = (\\lambda + 2G)\\Delta\\varepsilon_{xx} + \\lambda\\Delta\\varepsilon_{yy}\n$$\n$$\n\\sigma^{tr}_{yy} = \\Delta\\sigma_{yy} = \\lambda(\\Delta\\varepsilon_{xx} + \\Delta\\varepsilon_{yy}) + 2G \\Delta\\varepsilon_{yy} = \\lambda\\Delta\\varepsilon_{xx} + (\\lambda + 2G)\\Delta\\varepsilon_{yy}\n$$\nFor the in-plane shear stress (using engineering shear strain $\\Delta\\gamma_{xy} = 2\\Delta\\varepsilon_{xy}$):\n$$\n\\tau^{tr}_{xy} = \\Delta\\sigma_{xy} = 2G\\Delta\\varepsilon_{xy} = G\\Delta\\gamma_{xy}\n$$\nFor the out-of-plane normal stress:\n$$\n\\sigma^{tr}_{zz} = \\Delta\\sigma_{zz} = \\lambda(\\Delta\\varepsilon_{xx} + \\Delta\\varepsilon_{yy}) + 2G \\Delta\\varepsilon_{zz} = \\lambda(\\Delta\\varepsilon_{xx} + \\Delta\\varepsilon_{yy})\n$$\nThe out-of-plane shear stresses are zero since the corresponding shear strains are zero:\n$$\n\\tau^{tr}_{xz} = 0, \\quad \\tau^{tr}_{yz} = 0\n$$\nThis set of equations constitutes the elastic predictor mapping for plane strain.\n\nThe contribution of the constrained out-of-plane strain to $\\sigma^{tr}_{zz}$ is explained by the equation $\\sigma^{tr}_{zz} = \\lambda(\\Delta\\varepsilon_{xx} + \\Delta\\varepsilon_{yy})$. Physically, the in-plane strains $\\Delta\\varepsilon_{xx}$ and $\\Delta\\varepsilon_{yy}$ would induce an out-of-plane strain $\\Delta\\varepsilon_{zz}'$ through the Poisson effect. To enforce the kinematic constraint $\\Delta\\varepsilon_{zz} = 0$, a normal stress $\\sigma_{zz}^{tr}$ must develop to counteract this tendency. An alternative expression for $\\sigma_{zz}^{tr}$ is $\\sigma_{zz}^{tr} = \\nu(\\sigma_{xx}^{tr} + \\sigma_{yy}^{tr})$. The equivalence of these two expressions is a hallmark of the plane strain formulation and can be verified by substituting the expressions for $\\sigma_{xx}^{tr}$ and $\\sigma_{yy}^{tr}$ into the second form and using the definitions of $\\lambda$ and $G$.\n\nNow, we compute the numerical values. The given material properties are $E = 1200\\,\\text{MPa}$ and $\\nu = 0.30$.\nFirst, calculate the Lamé parameters:\n$$\nG = \\frac{1200\\,\\text{MPa}}{2(1+0.30)} = \\frac{1200}{2.6}\\,\\text{MPa} = \\frac{6000}{13}\\,\\text{MPa} \\approx 461.538\\,\\text{MPa}\n$$\n$$\n\\lambda = \\frac{1200\\,\\text{MPa} \\times 0.30}{(1+0.30)(1 - 2 \\times 0.30)} = \\frac{360}{1.3 \\times 0.4}\\,\\text{MPa} = \\frac{360}{0.52}\\,\\text{MPa} = \\frac{9000}{13}\\,\\text{MPa} \\approx 692.308\\,\\text{MPa}\n$$\nThe plane strain modulus is:\n$$\n\\lambda + 2G = \\frac{9000}{13}\\,\\text{MPa} + 2\\left(\\frac{6000}{13}\\right)\\,\\text{MPa} = \\frac{21000}{13}\\,\\text{MPa} \\approx 1615.385\\,\\text{MPa}\n$$\nThe incremental strain components are given as:\n$\\Delta\\varepsilon_{xx} = 1.5\\times 10^{-3}$\n$\\Delta\\varepsilon_{yy} = -5.0\\times 10^{-4} = -0.5\\times 10^{-3}$\n$\\Delta\\gamma_{xy} = 2.0\\times 10^{-3}$\n\nUsing the derived mapping, we compute the trial stress components:\n$$\n\\sigma^{tr}_{xx} = \\left(\\frac{21000}{13}\\right)(1.5 \\times 10^{-3}) + \\left(\\frac{9000}{13}\\right)(-0.5 \\times 10^{-3}) = \\frac{10^{-3}}{13}(31500 - 4500) = \\frac{27000}{13} \\times 10^{-3} = \\frac{27}{13}\\,\\text{MPa}\n$$\n$$\n\\sigma^{tr}_{xx} \\approx 2.076923\\,\\text{MPa}\n$$\nRounding to four significant figures gives $\\sigma^{tr}_{xx} = 2.077\\,\\text{MPa}$.\n\n$$\n\\sigma^{tr}_{yy} = \\left(\\frac{9000}{13}\\right)(1.5 \\times 10^{-3}) + \\left(\\frac{21000}{13}\\right)(-0.5 \\times 10^{-3}) = \\frac{10^{-3}}{13}(13500 - 10500) = \\frac{3000}{13} \\times 10^{-3} = \\frac{3}{13}\\,\\text{MPa}\n$$\n$$\n\\sigma^{tr}_{yy} \\approx 0.230769\\,\\text{MPa}\n$$\nRounding to four significant figures gives $\\sigma^{tr}_{yy} = 0.2308\\,\\text{MPa}$.\n\n$$\n\\sigma^{tr}_{zz} = \\left(\\frac{9000}{13}\\right)(\\Delta\\varepsilon_{xx} + \\Delta\\varepsilon_{yy}) = \\left(\\frac{9000}{13}\\right)(1.5 \\times 10^{-3} - 0.5 \\times 10^{-3}) = \\left(\\frac{9000}{13}\\right)(1.0 \\times 10^{-3}) = \\frac{9}{13}\\,\\text{MPa}\n$$\n$$\n\\sigma^{tr}_{zz} \\approx 0.692307\\,\\text{MPa}\n$$\nRounding to four significant figures gives $\\sigma^{tr}_{zz} = 0.6923\\,\\text{MPa}$.\n\n$$\n\\tau^{tr}_{xy} = G\\Delta\\gamma_{xy} = \\left(\\frac{6000}{13}\\right)(2.0 \\times 10^{-3}) = \\frac{12000}{13} \\times 10^{-3} = \\frac{12}{13}\\,\\text{MPa}\n$$\n$$\n\\tau^{tr}_{xy} \\approx 0.923076\\,\\text{MPa}\n$$\nRounding to four significant figures gives $\\tau^{tr}_{xy} = 0.9231\\,\\text{MPa}$.\n\nThe computed trial stress components, rounded to four significant figures, are: $\\sigma^{tr}_{xx} = 2.077\\,\\text{MPa}$, $\\sigma^{tr}_{yy} = 0.2308\\,\\text{MPa}$, $\\sigma^{tr}_{zz} = 0.6923\\,\\text{MPa}$, and $\\tau^{tr}_{xy} = 0.9231\\,\\text{MPa}$.", "answer": "$$\n\\boxed{\\begin{pmatrix} 2.077  0.2308  0.6923  0.9231 \\end{pmatrix}}\n$$", "id": "3523455"}, {"introduction": "While the forward-Euler method is straightforward to implement, its accuracy is only conditional and can degrade significantly with large strain increments, causing the stress state to 'drift' far from the true yield surface. This practice ([@problem_id:3523495]) introduces a powerful solution: adaptive substepping. By implementing a scheme that automatically refines the increment size to keep the trial stress error within a defined tolerance, you will learn a critical technique for building robust and accurate explicit solvers for complex material models like Drucker-Prager.", "problem": "You are tasked with implementing an adaptive explicit stress integration algorithm for a Drucker–Prager elastoplastic material under small strain. The algorithm must use an elastic predictor followed by an explicit plastic corrector, and it must adaptively subdivide the total strain increment until the trial yield function value falls within a specified target range to guarantee the accuracy of the explicit corrector.\n\nThe material is modeled as linear isotropic elasticity with an associated Drucker–Prager yield function and linear isotropic hardening. All quantities must be computed in the tension-positive sign convention. Stress is a second-order symmetric tensor, strain is a second-order symmetric tensor, and the small strain assumption holds. The required units are explicitly specified: express stress in kilopascals (kPa) and strain as dimensionless. The angle unit does not appear in this problem. All numerical outputs must be rounded to three decimal places.\n\nFundamental base and definitions, which you must use to derive the algorithm:\n- The small strain kinematics: the total strain increment is decomposed as $\\Delta\\varepsilon = \\Delta\\varepsilon^{e} + \\Delta\\varepsilon^{p}$, where $\\varepsilon$ denotes the strain tensor, and superscripts $e$ and $p$ indicate elastic and plastic parts, respectively.\n- Linear isotropic elasticity with Lamé constants $\\lambda$ and $\\mu$: the elastic constitutive relation is $\\sigma = \\mathbb{C} : \\varepsilon^{e}$ with $\\mathbb{C}$ given by $\\mathbb{C} : A = \\lambda \\,\\mathrm{tr}(A)\\,\\mathbf{I} + 2\\mu\\,A$ for any symmetric second-order tensor $A$. The bulk modulus $K$ and shear modulus $G$ satisfy $\\lambda = K - \\tfrac{2}{3}G$ and $\\mu = G$.\n- The stress invariants for a second-order stress tensor $\\sigma$: the first invariant $I_{1} = \\mathrm{tr}(\\sigma)$ and the second deviatoric invariant $J_{2} = \\tfrac{1}{2} s : s$, where $s = \\sigma - \\tfrac{1}{3}I_{1}\\mathbf{I}$ is the deviatoric stress and $:$ denotes the double contraction.\n- Drucker–Prager yield function with linear isotropic hardening: $f(\\sigma,\\kappa) = \\alpha I_{1} + \\sqrt{J_{2}} - k(\\kappa)$, where $k(\\kappa) = k_{0} + H \\kappa$, $\\alpha  0$ is a material parameter, $k_{0}$ is the initial cohesion-like parameter, $H \\ge 0$ is the hardening modulus, and $\\kappa$ is a scalar internal variable. The associated flow rule uses the plastic potential $g(\\sigma,\\kappa) = f(\\sigma,\\kappa)$, so $\\Delta\\varepsilon^{p} = \\Delta\\lambda\\,\\partial g/\\partial \\sigma$, where $\\Delta\\lambda \\ge 0$ is the plastic multiplier increment.\n- The elastic predictor forms the trial stress for a given strain subincrement $\\delta\\varepsilon$: $\\sigma^{tr} = \\sigma^{n} + \\mathbb{C} : \\delta\\varepsilon$, with $\\sigma^{n}$ the stress at the beginning of the substep. The trial yield function is $f^{tr} = f(\\sigma^{tr},\\kappa^{n})$.\n- The explicit plastic corrector is based on linearizing the yield function and freezing moduli and flow directions within a substep. Let $n = \\partial f/\\partial \\sigma$, evaluated at the start of the substep. Then the explicit update satisfies $\\sigma^{n+1} = \\sigma^{tr} - \\left(\\mathbb{C} : n\\right)\\Delta\\lambda$, $\\kappa^{n+1} = \\kappa^{n} + \\Delta\\lambda$, and the plastic multiplier increment is obtained from a first-order consistency approximation $\\Delta\\lambda = \\dfrac{f^{tr}}{n : \\mathbb{C} : n + H}$. All contractions are over tensor indices. Use a regularization for the derivative of $\\sqrt{J_{2}}$ near $J_{2} = 0$ to avoid division by zero.\n\nAlgorithmic requirements:\n- Implement an adaptive substepping strategy that subdivides the total strain increment $\\Delta\\varepsilon$ into $N$ equal substeps $\\delta\\varepsilon = \\Delta\\varepsilon/N$, starting with $N = 1$, and doubling $N$ as needed.\n- For each substep, compute the elastic predictor $\\sigma^{tr}$ and the trial yield $f^{tr}$. If $f^{tr} \\le 0$, accept the step elastically: set $\\sigma^{n+1} = \\sigma^{tr}$ and $\\kappa^{n+1} = \\kappa^{n}$ for that substep. If $f^{tr}  0$, enforce the target range condition $0 \\le f^{tr} \\le \\tau$ with a given threshold $\\tau  0$; if $f^{tr}  \\tau$ for any substep at the current $N$, increase $N$ by a factor of $2$ and restart the sequence of substeps from the beginning. Continue until all substeps satisfy the condition.\n- When $f^{tr}  0$ and satisfies $f^{tr} \\le \\tau$, perform the explicit plastic corrector for that substep using the definitions above. Then proceed to the next substep.\n- Stop when all substeps have been processed and return the final stress and the number of substeps $N$ used. Use a maximum cap $N_{\\max}$ to prevent infinite loops; if reached, return the current result as is.\n\nImplementation conventions:\n- Use the tension-positive sign convention. Stress must be expressed in kilopascals (kPa), rounded to three decimal places. Strain is dimensionless.\n- Represent stresses and strains as symmetric $3 \\times 3$ tensors internally. Input total strain increments are specified in Voigt form as $[\\Delta\\varepsilon_{11}, \\Delta\\varepsilon_{22}, \\Delta\\varepsilon_{33}, \\Delta\\gamma_{23}, \\Delta\\gamma_{13}, \\Delta\\gamma_{12}]$, where $\\Delta\\gamma_{ij} = 2 \\Delta\\varepsilon_{ij}$ are engineering shear strains. Convert to the tensor form before applying $\\mathbb{C}$ and convert back when reporting stress components.\n- For the derivative $\\partial f/\\partial \\sigma$, use $n = \\alpha \\mathbf{I} + \\dfrac{s}{2\\sqrt{J_{2}}}$ with regularization $\\sqrt{J_{2}} \\leftarrow \\max(\\sqrt{J_{2}}, \\epsilon)$ for a small $\\epsilon  0$.\n\nTest suite:\nFor all test cases, the initial stress tensor is zero and the initial hardening variable is $\\kappa^{0} = 0$. Provide the following four test cases, each specified as a tuple of parameters $(K, G, \\alpha, H, k_{0}, \\Delta\\varepsilon, \\tau)$, with $K$ and $G$ in kPa, $H$ and $k_{0}$ in kPa, strain increment dimensionless, and $\\tau$ in kPa:\n1. $(20000, 10000, 0.12, 800, 100, [2\\times10^{-4}, 0, 0, 0, 0, 1\\times10^{-4}], 5)$\n2. $(20000, 10000, 0.12, 800, 100, [1\\times10^{-7}, 1\\times10^{-7}, 1\\times10^{-7}, 0, 0, 0], 5)$\n3. $(15000, 7000, 0.18, 500, 80, [0, 0, 0, 8\\times10^{-4}, 0, 0], 2)$\n4. $(25000, 12000, 0.10, 1200, 50, [4\\times10^{-4}, 4\\times10^{-4}, 4\\times10^{-4}, 0, 0, 0], 3)$\n\nYour program must compute, for each test case, the final stress components in Voigt order $[\\sigma_{11}, \\sigma_{22}, \\sigma_{33}, \\sigma_{23}, \\sigma_{13}, \\sigma_{12}]$ in kPa (rounded to three decimal places) and the number of substeps $N$ used. The final output format must be a single line containing a Python-style list of four results, one per test case, where each result is a list of seven values: the six stress components followed by the integer $N$. For example: \"[[s11,s22,s33,s23,s13,s12,N], [...], [...], [...]]\".", "solution": "The user has provided a well-defined problem in computational geomechanics. It is scientifically grounded, self-contained, and objective. The task is to implement an adaptive explicit stress integration scheme for an elastoplastic material following the Drucker-Prager model with linear isotropic hardening. The provided equations and algorithmic structure are standard in the field and logically consistent. The problem is therefore deemed valid.\n\nThe solution is developed by first formalizing the provided tensor equations and then structuring the adaptive algorithm as specified. All mathematical entities adhere to the mandatory LaTeX formatting.\n\n### 1. Preliminaries: Tensors and Constitutive Relations\n\nThe material response is governed by linear isotropic elasticity and a Drucker-Prager yield criterion.\n\n- **Elasticity**: The stress tensor $\\sigma$ is related to the elastic strain tensor $\\varepsilon^e$ by Hooke's law, $\\sigma = \\mathbb{C} : \\varepsilon^e$, where $\\mathbb{C}$ is the fourth-order elasticity tensor. For an isotropic material, this is given by:\n$$\n\\mathbb{C} : A = \\lambda \\,\\mathrm{tr}(A)\\,\\mathbf{I} + 2\\mu\\,A\n$$\nfor any symmetric second-order tensor $A$. The Lamé parameters $\\lambda$ and $\\mu$ are related to the bulk modulus $K$ and shear modulus $G$ by $\\lambda = K - \\frac{2}{3}G$ and $\\mu = G$.\n\n- **Voigt Notation**: Strains are provided in Voigt vector form, $\\Delta\\varepsilon_v = [\\Delta\\varepsilon_{11}, \\Delta\\varepsilon_{22}, \\Delta\\varepsilon_{33}, \\Delta\\gamma_{23}, \\Delta\\gamma_{13}, \\Delta\\gamma_{12}]$. These must be converted to the $3 \\times 3$ symmetric tensor form $\\Delta\\varepsilon$, recognizing that engineering shear strains are used, i.e., $\\Delta\\gamma_{ij} = 2\\Delta\\varepsilon_{ij}$ for $i \\neq j$.\n$$\n\\Delta\\varepsilon =\n\\begin{pmatrix}\n\\Delta\\varepsilon_{11}  \\frac{1}{2}\\Delta\\gamma_{12}  \\frac{1}{2}\\Delta\\gamma_{13} \\\\\n\\frac{1}{2}\\Delta\\gamma_{12}  \\Delta\\varepsilon_{22}  \\frac{1}{2}\\Delta\\gamma_{23} \\\\\n\\frac{1}{2}\\Delta\\gamma_{13}  \\frac{1}{2}\\Delta\\gamma_{23}  \\Delta\\varepsilon_{33}\n\\end{pmatrix}\n$$\nThe final computed stress tensor $\\sigma$ is converted back to Voigt form $[\\sigma_{11}, \\sigma_{22}, \\sigma_{33}, \\sigma_{23}, \\sigma_{13}, \\sigma_{12}]$ for output.\n\n- **Drucker-Prager Model**: The yield function $f$ defines the boundary of the elastic domain:\n$$\nf(\\sigma, \\kappa) = \\alpha I_1 + \\sqrt{J_2} - k(\\kappa)\n$$\nwhere $I_1 = \\mathrm{tr}(\\sigma)$ is the first invariant of stress, $J_2 = \\frac{1}{2}s:s$ is the second invariant of the deviatoric stress $s = \\sigma - \\frac{1}{3}I_1\\mathbf{I}$, and $\\alpha  0$ is a material parameter. The hardening is linear and isotropic, defined by $k(\\kappa) = k_0 + H\\kappa$, where $k_0$ is the initial cohesion-like parameter, $H \\ge 0$ is the hardening modulus, and $\\kappa$ is the internal hardening variable. The evolution of $\\kappa$ is given by $\\dot{\\kappa} = \\dot{\\lambda}$, where $\\dot{\\lambda}$ is the rate of the plastic multiplier.\n\n### 2. Adaptive Explicit Integration Algorithm\n\nThe total strain increment $\\Delta\\varepsilon_{total}$ is applied over a series of substeps. The algorithm adaptively refines the number of substeps $N$ to ensure the accuracy of the explicit plastic corrector.\n\nThe overall procedure for a single total strain increment is as follows:\n1. Initialize stress $\\sigma = \\sigma_0$ and hardening variable $\\kappa = \\kappa_0$. For this problem, $\\sigma_0 = \\mathbf{0}$ and $\\kappa_0 = 0$.\n2. Start with $N=1$ substeps. Set a maximum $N_{max}$ (e.g., $2048$) to prevent infinite loops.\n3. Enter a loop that continues as long as $N \\le N_{max}$:\n    a. Reset the state to the beginning of the total increment: $\\sigma_{current} = \\sigma_0$, $\\kappa_{current} = \\kappa_0$.\n    b. Calculate the strain increment for each substep: $\\delta\\varepsilon = \\Delta\\varepsilon_{total} / N$.\n    c. Set a flag `restart_needed = false`.\n    d. Iterate through each substep from $i=1$ to $N$:\n        i.   Perform one integration step with the current state $(\\sigma_{current}, \\kappa_{current})$ and strain increment $\\delta\\varepsilon$. This step, detailed below, returns the updated state $(\\sigma_{new}, \\kappa_{new})$ and a status (`'ok'` or `'failure'`).\n        ii.  If the status is `'failure'`, set `restart_needed = true` and break the inner substep loop.\n        iii. If the status is `'ok'`, update the state for the next substep: $\\sigma_{current} = \\sigma_{new}$, $\\kappa_{current} = \\kappa_{new}$.\n    e. After the substep loop, if `restart_needed` is true, double the number of substeps ($N \\leftarrow 2N$) and continue to the next iteration of the main loop.\n    f. If the substep loop completes successfully, the integration is complete. The final state is $(\\sigma_{current}, \\kappa_{current})$. Break the main loop.\n4. The final stress tensor and the number of substeps $N$ are reported.\n\n### 3. Single Substep Integration\n\nFor each substep, from state $(\\sigma^n, \\kappa^n)$, an elastic predictor-plastic corrector scheme is used.\n\n1.  **Elastic Predictor**: A trial stress $\\sigma^{tr}$ is computed by assuming the entire substep strain increment $\\delta\\varepsilon$ is elastic:\n    $$\n    \\sigma^{tr} = \\sigma^n + \\mathbb{C} : \\delta\\varepsilon = \\sigma^n + \\lambda\\,\\mathrm{tr}(\\delta\\varepsilon)\\mathbf{I} + 2\\mu\\,\\delta\\varepsilon\n    $$\n\n2.  **Yield Check**: Evaluate the yield function at the trial state, using the hardening from the beginning of the substep:\n    $$\n    f^{tr} = f(\\sigma^{tr}, \\kappa^n) = \\alpha I_1^{tr} + \\sqrt{J_2^{tr}} - (k_0 + H\\kappa^n)\n    $$\n    where $I_1^{tr} = \\mathrm{tr}(\\sigma^{tr})$ and $J_2^{tr}$ is the second deviatoric invariant of $\\sigma^{tr}$.\n\n3.  **State Update Logic**:\n    a. **Elastic Step**: If $f^{tr} \\le 0$, the state is elastic or on the yield surface. The trial state is accepted:\n       $$\n       \\sigma^{n+1} = \\sigma^{tr} \\quad , \\quad \\kappa^{n+1} = \\kappa^n\n       $$\n       The substep is successful.\n    b. **Plastic Step Check**: If $f^{tr}  0$, plastic deformation occurs. The magnitude of $f^{tr}$ is an indicator of the error in the explicit scheme.\n       - If $f^{tr}  \\tau$, where $\\tau$ is a specified tolerance, the error is too large. The substep size is too coarse. The substep calculation fails, triggering a restart of the entire process with a smaller substep size (larger $N$).\n       - If $0  f^{tr} \\le \\tau$, the error is acceptable. Proceed with the plastic corrector.\n\n4.  **Explicit Plastic Corrector**: When $0  f^{tr} \\le \\tau$, the state is returned to the yield surface.\n    a. The plastic multiplier increment $\\Delta\\lambda$ is calculated using a first-order approximation:\n       $$\n       \\Delta\\lambda = \\frac{f^{tr}}{n^{tr} : \\mathbb{C} : n^{tr} + H}\n       $$\n       where $n^{tr} = \\frac{\\partial f}{\\partial \\sigma}\\big|_{\\sigma^{tr}}$ is the flow direction evaluated at the trial stress.\n    b. For the Drucker-Prager model, $n^{tr} = \\alpha\\mathbf{I} + \\frac{s^{tr}}{2\\sqrt{J_2^{tr}}}$. The denominator term simplifies to a material constant expression, provided $J_2^{tr} \\neq 0$:\n       $$\n       n^{tr}:\\mathbb{C}:n^{tr} + H = 9K\\alpha^2 + G + H\n       $$\n       To handle the apex singularity where $J_2^{tr} \\to 0$, a regularized expression is used: $A = 9K\\alpha^2 + G \\frac{J_2^{tr}}{\\max(J_2^{tr}, \\epsilon^2)} + H$, for a small tolerance $\\epsilon$. The plastic multiplier is then $\\Delta\\lambda = f^{tr}/A$.\n    c. The stress and hardening variables are updated:\n       $$\n       \\sigma^{n+1} = \\sigma^{tr} - \\Delta\\lambda (\\mathbb{C}:n^{tr})\n       $$\n       $$\n       \\kappa^{n+1} = \\kappa^n + \\Delta\\lambda\n       $$\n       The term $\\mathbb{C}:n^{tr}$ is expanded as $\\mathbb{C}:n^{tr} = 3K\\alpha\\mathbf{I} + 2G n_{dev}^{tr}$, where $n_{dev}^{tr}$ is the deviatoric part of $n^{tr}$. The derivative of $\\sqrt{J_2}$ is regularized by using $\\sqrt{J_2^{tr}} \\leftarrow \\max(\\sqrt{J_2^{tr}}, \\epsilon)$ to avoid division by zero when computing $n_{dev}^{tr}$. The substep is then successful.\n\nThis completes the detailed description of the algorithm's design based on the provided principles.", "answer": "```python\nimport numpy as np\n\ndef voigt_to_tensor(v_strain):\n    \"\"\"Converts a 6x1 Voigt strain vector to a 3x3 strain tensor.\"\"\"\n    eps = np.zeros((3, 3))\n    eps[0, 0] = v_strain[0]\n    eps[1, 1] = v_strain[1]\n    eps[2, 2] = v_strain[2]\n    # Engineering shear strain to tensor shear strain conversion\n    eps[1, 2] = eps[2, 1] = v_strain[3] / 2.0\n    eps[0, 2] = eps[2, 0] = v_strain[4] / 2.0\n    eps[0, 1] = eps[1, 0] = v_strain[5] / 2.0\n    return eps\n\ndef tensor_to_voigt(t_stress):\n    \"\"\"Converts a 3x3 stress tensor to a 6x1 Voigt stress vector.\"\"\"\n    return np.array([\n        t_stress[0, 0],\n        t_stress[1, 1],\n        t_stress[2, 2],\n        t_stress[1, 2],\n        t_stress[0, 2],\n        t_stress[0, 1]\n    ])\n\ndef run_stress_integration(params):\n    \"\"\"\n    Performs adaptive explicit stress integration for a single test case.\n    \"\"\"\n    K, G, alpha, H, k0, delta_eps_voigt, tau = params\n    \n    delta_eps_total_tensor = voigt_to_tensor(delta_eps_voigt)\n    \n    # Lame parameters\n    lambda_lame = K - (2.0 / 3.0) * G\n    mu_lame = G\n\n    # Regularization epsilon\n    epsilon = 1e-12\n\n    # Adaptive substepping loop\n    N = 1\n    N_max = 2048\n    \n    while N = N_max:\n        # State variables at the start of the total increment\n        sigma_current = np.zeros((3, 3))\n        kappa_current = 0.0\n        \n        delta_eps_sub = delta_eps_total_tensor / N\n        \n        restart_needed = False\n        for _ in range(N):\n            # Elastic Predictor\n            tr_delta_eps_sub = np.trace(delta_eps_sub)\n            sigma_tr = sigma_current + lambda_lame * tr_delta_eps_sub * np.eye(3) + 2.0 * mu_lame * delta_eps_sub\n\n            # Yield Check\n            I1_tr = np.trace(sigma_tr)\n            s_tr = sigma_tr - (I1_tr / 3.0) * np.eye(3)\n            J2_tr = 0.5 * np.sum(s_tr * s_tr)\n            \n            # Avoid sqrt of negative J2 from machine precision errors\n            if J2_tr  0: J2_tr = 0\n            sqrt_J2_tr = np.sqrt(J2_tr)\n            \n            k_n = k0 + H * kappa_current\n            f_tr = alpha * I1_tr + sqrt_J2_tr - k_n\n\n            if f_tr = 0:\n                # Elastic step\n                sigma_current = sigma_tr\n                # kappa_current remains unchanged\n            else:\n                if f_tr > tau:\n                    restart_needed = True\n                    break\n                else:\n                    # Explicit Plastic Corrector\n                    denom_A = 9.0 * K * alpha**2 + G * J2_tr / max(J2_tr, epsilon**2) + H\n                    delta_lambda = f_tr / denom_A\n\n                    sqrt_J2_tr_reg = max(sqrt_J2_tr, epsilon)\n                    n_dev_tr = s_tr / (2.0 * sqrt_J2_tr_reg)\n\n                    correction_term = delta_lambda * (3.0 * K * alpha * np.eye(3) + 2.0 * G * n_dev_tr)\n                    \n                    sigma_current = sigma_tr - correction_term\n                    kappa_current = kappa_current + delta_lambda\n\n        if restart_needed:\n            N *= 2\n            continue\n        else:\n            # All substeps successful\n            final_sigma = sigma_current\n            break\n    \n    if N > N_max:\n        # Loop terminated due to N_max, return current result\n        final_sigma = sigma_current\n\n    final_stress_voigt = tensor_to_voigt(final_sigma)\n    rounded_stress = [round(s, 3) for s in final_stress_voigt]\n    \n    return rounded_stress + [N]\n\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the stress integration for each.\n    \"\"\"\n    test_cases = [\n        (20000, 10000, 0.12, 800, 100, np.array([2e-4, 0, 0, 0, 0, 1e-4]), 5),\n        (20000, 10000, 0.12, 800, 100, np.array([1e-7, 1e-7, 1e-7, 0, 0, 0]), 5),\n        (15000, 7000, 0.18, 500, 80, np.array([0, 0, 0, 8e-4, 0, 0]), 2),\n        (25000, 12000, 0.10, 1200, 50, np.array([4e-4, 4e-4, 4e-4, 0, 0, 0]), 3)\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_stress_integration(case)\n        results.append(result)\n\n    print(f\"{results}\")\n\nsolve()\n```", "id": "3523495"}, {"introduction": "A numerical simulation that runs without crashing is not necessarily physically correct. A crucial aspect of developing reliable computational models is verification against fundamental physical laws. This exercise ([@problem_id:3523470]) guides you to implement a check based on the second law of thermodynamics, which mandates that plastic dissipation must be non-negative. By learning to monitor plastic work and flag nonphysical energy generation, you will develop an essential skill for validating your constitutive drivers and ensuring their results are trustworthy.", "problem": "You are tasked with implementing and verifying a plastic work accumulation check for an explicit stress integration scheme composed of an elastic predictor and plastic corrector in small-strain computational geomechanics. The verification step must detect nonphysical energy gain due to integration errors by examining the plastic dissipation per step and the accumulated plastic work.\n\nStart from the following fundamental base. In the small-strain setting, the rate of stress power is given by $P = \\boldsymbol{\\sigma} : \\dot{\\boldsymbol{\\varepsilon}}$, where $\\boldsymbol{\\sigma}$ is the Cauchy stress tensor and $\\dot{\\boldsymbol{\\varepsilon}}$ is the strain-rate tensor. Decompose the strain-rate into elastic and plastic parts as $\\dot{\\boldsymbol{\\varepsilon}} = \\dot{\\boldsymbol{\\varepsilon}}^e + \\dot{\\boldsymbol{\\varepsilon}}^p$. The plastic dissipation rate is defined by $D = \\boldsymbol{\\sigma} : \\dot{\\boldsymbol{\\varepsilon}}^p$. For associative, rate-independent plasticity with a convex yield function, the flow rule is $\\dot{\\boldsymbol{\\varepsilon}}^p = \\dot{\\lambda}\\,\\partial f/\\partial \\boldsymbol{\\sigma}$ with $\\dot{\\lambda} \\ge 0$, and the Karush–Kuhn–Tucker conditions enforce $D \\ge 0$ under physically admissible evolution.\n\nYour verification step must implement the following logic:\n- For each time increment $k$, given the corrected stress $\\boldsymbol{\\sigma}_{n+1}^{(k)}$ and the plastic strain increment $\\Delta \\boldsymbol{\\varepsilon}^p{}^{(k)}$, compute the plastic work increment\n$$\n\\Delta W_p^{(k)} = \\boldsymbol{\\sigma}_{n+1}^{(k)} : \\Delta \\boldsymbol{\\varepsilon}^p{}^{(k)} = \\sum_{i=1}^3 \\sum_{j=1}^3 \\sigma_{n+1,ij}^{(k)} \\,\\Delta \\varepsilon^p{}_{ij}^{(k)}.\n$$\n- Accumulate the total plastic work\n$$\nW_p = \\sum_{k=1}^{N} \\Delta W_p^{(k)}.\n$$\n- To account for finite precision, use a per-step relative tolerance\n$$\n\\mathrm{tol}^{(k)} = r_{\\text{tol}}\\;\\|\\boldsymbol{\\sigma}_{n+1}^{(k)}\\|_F\\;\\|\\Delta \\boldsymbol{\\varepsilon}^p{}^{(k)}\\|_F,\n$$\nwhere $\\|\\cdot\\|_F$ denotes the Frobenius norm and $r_{\\text{tol}}$ is a given small scalar. In this task, set $r_{\\text{tol}} = 10^{-12}$.\n- Flag nonphysical energy gain if either:\n    1. There exists a step $k$ such that $\\Delta W_p^{(k)}  -\\mathrm{tol}^{(k)}$, or\n    2. The final accumulated $W_p  -\\sum_{k=1}^{N} \\mathrm{tol}^{(k)}$.\n\nAll stresses $\\boldsymbol{\\sigma}$ are specified in Pascals (SI unit $\\mathrm{Pa}$) and all strains are dimensionless. The plastic work and tolerances are energy densities in joules per cubic meter ($\\mathrm{J/m^3}$). These units do not need to be printed; the program output will be booleans only.\n\nImplement a program that evaluates the following test suite. Each test case consists of a sequence of steps; each step provides a symmetric $3\\times 3$ stress tensor $\\boldsymbol{\\sigma}_{n+1}^{(k)}$ and a symmetric $3\\times 3$ plastic strain increment $\\Delta \\boldsymbol{\\varepsilon}^p{}^{(k)}$.\n\nTest Case $1$ (happy path: strictly nonnegative dissipation each step):\n- Step $1$:\n$$\n\\boldsymbol{\\sigma}_{n+1}^{(1)} =\n\\begin{bmatrix}\n150\\times 10^6  5\\times 10^6  0 \\\\\n5\\times 10^6  120\\times 10^6  0 \\\\\n0  0  90\\times 10^6\n\\end{bmatrix},\\quad\n\\Delta \\boldsymbol{\\varepsilon}^p{}^{(1)} =\n\\begin{bmatrix}\n1.0\\times 10^{-5}  2.0\\times 10^{-6}  0 \\\\\n2.0\\times 10^{-6}  -5.0\\times 10^{-6}  0 \\\\\n0  0  -5.0\\times 10^{-6}\n\\end{bmatrix}.\n$$\n- Step $2$:\n$$\n\\boldsymbol{\\sigma}_{n+1}^{(2)} =\n\\begin{bmatrix}\n160\\times 10^6  4\\times 10^6  1\\times 10^6 \\\\\n4\\times 10^6  115\\times 10^6  0.5\\times 10^6 \\\\\n1\\times 10^6  0.5\\times 10^6  85\\times 10^6\n\\end{bmatrix},\\quad\n\\Delta \\boldsymbol{\\varepsilon}^p{}^{(2)} =\n\\begin{bmatrix}\n0.8\\times 10^{-5}  1.0\\times 10^{-6}  0.2\\times 10^{-6} \\\\\n1.0\\times 10^{-6}  -4.0\\times 10^{-6}  0.1\\times 10^{-6} \\\\\n0.2\\times 10^{-6}  0.1\\times 10^{-6}  -4.0\\times 10^{-6}\n\\end{bmatrix}.\n$$\n- Step $3$:\n$$\n\\boldsymbol{\\sigma}_{n+1}^{(3)} =\n\\begin{bmatrix}\n165\\times 10^6  3\\times 10^6  2\\times 10^6 \\\\\n3\\times 10^6  110\\times 10^6  1\\times 10^6 \\\\\n2\\times 10^6  1\\times 10^6  80\\times 10^6\n\\end{bmatrix},\\quad\n\\Delta \\boldsymbol{\\varepsilon}^p{}^{(3)} =\n\\begin{bmatrix}\n0.7\\times 10^{-5}  1.5\\times 10^{-6}  0.3\\times 10^{-6} \\\\\n1.5\\times 10^{-6}  -3.5\\times 10^{-6}  0.2\\times 10^{-6} \\\\\n0.3\\times 10^{-6}  0.2\\times 10^{-6}  -3.5\\times 10^{-6}\n\\end{bmatrix}.\n$$\n\nTest Case $2$ (boundary case: isotropic stress with trace-free plastic strain increments, yielding zero dissipation):\n- Step $1$:\n$$\n\\boldsymbol{\\sigma}_{n+1}^{(1)} =\n\\begin{bmatrix}\n50\\times 10^6  0  0 \\\\\n0  50\\times 10^6  0 \\\\\n0  0  50\\times 10^6\n\\end{bmatrix},\\quad\n\\Delta \\boldsymbol{\\varepsilon}^p{}^{(1)} =\n\\begin{bmatrix}\n1.0\\times 10^{-6}  0  0 \\\\\n0  -0.5\\times 10^{-6}  0 \\\\\n0  0  -0.5\\times 10^{-6}\n\\end{bmatrix}.\n$$\n- Step $2$:\n$$\n\\boldsymbol{\\sigma}_{n+1}^{(2)} =\n\\begin{bmatrix}\n50\\times 10^6  0  0 \\\\\n0  50\\times 10^6  0 \\\\\n0  0  50\\times 10^6\n\\end{bmatrix},\\quad\n\\Delta \\boldsymbol{\\varepsilon}^p{}^{(2)} =\n\\begin{bmatrix}\n2.0\\times 10^{-6}  0  0 \\\\\n0  -1.0\\times 10^{-6}  0 \\\\\n0  0  -1.0\\times 10^{-6}\n\\end{bmatrix}.\n$$\n\nTest Case $3$ (error case: negative dissipation due to misaligned increments, should be flagged):\n- Step $1$:\n$$\n\\boldsymbol{\\sigma}_{n+1}^{(1)} =\n\\begin{bmatrix}\n100\\times 10^6  40\\times 10^6  0 \\\\\n40\\times 10^6  100\\times 10^6  0 \\\\\n0  0  100\\times 10^6\n\\end{bmatrix},\\quad\n\\Delta \\boldsymbol{\\varepsilon}^p{}^{(1)} =\n\\begin{bmatrix}\n-1.0\\times 10^{-5}  4.0\\times 10^{-6}  0 \\\\\n4.0\\times 10^{-6}  -1.0\\times 10^{-5}  0 \\\\\n0  0  -1.0\\times 10^{-5}\n\\end{bmatrix}.\n$$\n\nTest Case $4$ (edge cases: zero stress or zero plastic strain increments, yielding zero dissipation):\n- Step $1$:\n$$\n\\boldsymbol{\\sigma}_{n+1}^{(1)} =\n\\begin{bmatrix}\n0  0  0 \\\\\n0  0  0 \\\\\n0  0  0\n\\end{bmatrix},\\quad\n\\Delta \\boldsymbol{\\varepsilon}^p{}^{(1)} =\n\\begin{bmatrix}\n1.0\\times 10^{-6}  -0.5\\times 10^{-6}  0 \\\\\n-0.5\\times 10^{-6}  0  0 \\\\\n0  0  -0.5\\times 10^{-6}\n\\end{bmatrix}.\n$$\n- Step $2$:\n$$\n\\boldsymbol{\\sigma}_{n+1}^{(2)} =\n\\begin{bmatrix}\n80\\times 10^6  0  0 \\\\\n0  80\\times 10^6  0 \\\\\n0  0  80\\times 10^6\n\\end{bmatrix},\\quad\n\\Delta \\boldsymbol{\\varepsilon}^p{}^{(2)} =\n\\begin{bmatrix}\n0  0  0 \\\\\n0  0  0 \\\\\n0  0  0\n\\end{bmatrix}.\n$$\n\nYour program must implement the verification logic described above, evaluate each test case, and produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases, where each entry is a boolean indicating whether a nonphysical energy gain was flagged for that test case (e.g., $[\\text{result1},\\text{result2},\\text{result3},\\text{result4}]$).", "solution": "The objective is to design a verification step to ensure that the plastic dissipation computed within an explicit stress integration scheme (elastic predictor and plastic corrector) is physically admissible. The fundamental principle is the Second Law of Thermodynamics specialized to plasticity, which requires nonnegative plastic dissipation $D = \\boldsymbol{\\sigma} : \\dot{\\boldsymbol{\\varepsilon}}^p \\ge 0$ for admissible evolutions under associative flow. For rate-independent associative plasticity, the normality flow rule states $\\dot{\\boldsymbol{\\varepsilon}}^p = \\dot{\\lambda}\\,\\partial f/\\partial \\boldsymbol{\\sigma}$ with $\\dot{\\lambda} \\ge 0$. For classical isotropic $J_2$ (von Mises) plasticity, the flow direction is the normalized deviatoric stress, $\\partial f/\\partial \\boldsymbol{\\sigma} = \\boldsymbol{n} = \\mathrm{dev}(\\boldsymbol{\\sigma})/\\|\\mathrm{dev}(\\boldsymbol{\\sigma})\\|$, which yields\n$$\nD = \\boldsymbol{\\sigma} : \\dot{\\boldsymbol{\\varepsilon}}^p = \\dot{\\lambda}\\,\\boldsymbol{\\sigma} : \\boldsymbol{n} = \\dot{\\lambda}\\,\\|\\mathrm{dev}(\\boldsymbol{\\sigma})\\| \\ge 0,\n$$\nsince $\\dot{\\lambda} \\ge 0$ and the norm is nonnegative. Thus, any strictly negative plastic dissipation computed after a plastic corrector is nonphysical and indicates an integration error (for example, due to an inaccurate explicit step or an inconsistent return mapping).\n\nAlgorithmic design:\n1. For each increment $k$, we use the corrected stress $\\boldsymbol{\\sigma}_{n+1}^{(k)}$ (post plastic corrector) and the plastic strain increment $\\Delta \\boldsymbol{\\varepsilon}^p{}^{(k)}$ produced by the algorithm. The plastic work increment is\n$$\n\\Delta W_p^{(k)} = \\boldsymbol{\\sigma}_{n+1}^{(k)} : \\Delta \\boldsymbol{\\varepsilon}^p{}^{(k)} = \\sum_{i=1}^3 \\sum_{j=1}^3 \\sigma_{n+1,ij}^{(k)} \\,\\Delta \\varepsilon^p{}_{ij}^{(k)}.\n$$\nFor symmetric tensors, this equals the Frobenius inner product with off-diagonal terms counted twice in the full index sum, which is correctly captured by the elementwise product followed by summation.\n\n2. Accumulate the total plastic work\n$$\nW_p = \\sum_{k=1}^N \\Delta W_p^{(k)}.\n$$\n\n3. Floating-point finite precision can produce tiny negative values that are not physically meaningful. To guard against false positives, define a per-step relative tolerance\n$$\n\\mathrm{tol}^{(k)} = r_{\\text{tol}}\\;\\|\\boldsymbol{\\sigma}_{n+1}^{(k)}\\|_F\\;\\|\\Delta \\boldsymbol{\\varepsilon}^p{}^{(k)}\\|_F,\n$$\nwith $r_{\\text{tol}} = 10^{-12}$. This tolerance scales with the maximum possible magnitude of $\\Delta W_p^{(k)}$ (bounded by the Cauchy–Schwarz inequality, $|\\Delta W_p^{(k)}|\\le \\|\\boldsymbol{\\sigma}_{n+1}^{(k)}\\|_F \\|\\Delta \\boldsymbol{\\varepsilon}^p{}^{(k)}\\|_F$), thereby making the check scale-aware.\n\n4. Flag a nonphysical energy gain if either of the following occurs:\n- There exists a step $k$ such that $\\Delta W_p^{(k)}  -\\mathrm{tol}^{(k)}$.\n- The final sum $W_p$ is negative beyond the accumulated tolerance, i.e.,\n$$\nW_p  -\\sum_{k=1}^N \\mathrm{tol}^{(k)}.\n$$\nThe second condition captures the situation where individual tiny negative values might not individually exceed tolerance but collectively produce a net negative accumulation beyond the combined tolerance.\n\nApplication to the provided test suite:\n- Test Case $1$: Each step has a stress tensor with moderate deviatoric components and deviatoric plastic strain increments. Computing\n$$\n\\Delta W_p^{(1)} \\approx 470\\;\\mathrm{J/m^3},\\quad\n\\Delta W_p^{(2)} \\approx 488.5\\;\\mathrm{J/m^3},\\quad\n\\Delta W_p^{(3)} \\approx 500.6\\;\\mathrm{J/m^3},\n$$\nall strictly positive. The tolerance per step is many orders of magnitude smaller than these values (on the order of $10^{-3}\\;\\mathrm{J/m^3}$ or less given $r_{\\text{tol}} = 10^{-12}$ and typical norms). No flag is raised, expected boolean: $\\text{False}$.\n\n- Test Case $2$: Isotropic stress with trace-free plastic strain increments. For a spherical stress $\\boldsymbol{\\sigma} = p\\,\\boldsymbol{I}$, the contraction reduces to\n$$\n\\Delta W_p^{(k)} = p\\,\\mathrm{tr}\\left(\\Delta \\boldsymbol{\\varepsilon}^p{}^{(k)}\\right),\n$$\nand with $\\mathrm{tr}(\\Delta \\boldsymbol{\\varepsilon}^p{}^{(k)}) = 0$, we obtain $\\Delta W_p^{(1)} = 0$ and $\\Delta W_p^{(2)} = 0$. Accumulated $W_p = 0$. No flag, expected boolean: $\\text{False}$.\n\n- Test Case $3$: The chosen tensors produce a large negative contraction due to misaligned signs, yielding\n$$\n\\Delta W_p^{(1)} \\approx -2680\\;\\mathrm{J/m^3},\n$$\nwhich greatly exceeds the tolerance in magnitude. This must be flagged. Expected boolean: $\\text{True}$.\n\n- Test Case $4$: One step has zero stress, the other has zero plastic strain increment; both produce $\\Delta W_p^{(k)} = 0$ exactly. No flag. Expected boolean: $\\text{False}$.\n\nThus, the program should output the boolean list $[\\text{False},\\text{False},\\text{True},\\text{False}]$ for the four test cases, in the specified single-line comma-separated format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef frobenius_norm(mat: np.ndarray) - float:\n    \"\"\"Compute Frobenius norm of a 3x3 matrix.\"\"\"\n    return float(np.linalg.norm(mat, 'fro'))\n\ndef double_contraction(a: np.ndarray, b: np.ndarray) - float:\n    \"\"\"Compute the double contraction a:b for 3x3 matrices.\"\"\"\n    return float(np.sum(a * b))\n\ndef evaluate_case(steps, rtol=1e-12) - bool:\n    \"\"\"\n    Evaluate one test case (sequence of steps), returning True if a nonphysical\n    energy gain is flagged, else False.\n\n    Steps: list of tuples (sigma, deps_p), each 3x3 symmetric arrays.\n    \"\"\"\n    total_wp = 0.0\n    tol_sum = 0.0\n    for sigma, deps_p in steps:\n        ns = frobenius_norm(sigma)\n        ne = frobenius_norm(deps_p)\n        tol = rtol * ns * ne\n        tol_sum += tol\n        dwp = double_contraction(sigma, deps_p)\n        # Step-level check\n        if dwp  -tol:\n            return True\n        total_wp += dwp\n    # Final accumulation check\n    if total_wp  -tol_sum:\n        return True\n    return False\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a list of (sigma, deps_p) steps, with 3x3 numpy arrays.\n    test_cases = []\n\n    # Test Case 1: happy path (positive dissipation per step)\n    tc1 = [\n        (\n            np.array([[150e6, 5e6, 0.0],\n                      [5e6, 120e6, 0.0],\n                      [0.0, 0.0, 90e6]]),\n            np.array([[1.0e-5, 2.0e-6, 0.0],\n                      [2.0e-6, -5.0e-6, 0.0],\n                      [0.0, 0.0, -5.0e-6]])\n        ),\n        (\n            np.array([[160e6, 4e6, 1e6],\n                      [4e6, 115e6, 0.5e6],\n                      [1e6, 0.5e6, 85e6]]),\n            np.array([[0.8e-5, 1.0e-6, 0.2e-6],\n                      [1.0e-6, -4.0e-6, 0.1e-6],\n                      [0.2e-6, 0.1e-6, -4.0e-6]])\n        ),\n        (\n            np.array([[165e6, 3e6, 2e6],\n                      [3e6, 110e6, 1e6],\n                      [2e6, 1e6, 80e6]]),\n            np.array([[0.7e-5, 1.5e-6, 0.3e-6],\n                      [1.5e-6, -3.5e-6, 0.2e-6],\n                      [0.3e-6, 0.2e-6, -3.5e-6]])\n        ),\n    ]\n    test_cases.append(tc1)\n\n    # Test Case 2: boundary case (isotropic stress, trace-free plastic strain increments)\n    tc2 = [\n        (\n            np.array([[50e6, 0.0, 0.0],\n                      [0.0, 50e6, 0.0],\n                      [0.0, 0.0, 50e6]]),\n            np.array([[1.0e-6, 0.0, 0.0],\n                      [0.0, -0.5e-6, 0.0],\n                      [0.0, 0.0, -0.5e-6]])\n        ),\n        (\n            np.array([[50e6, 0.0, 0.0],\n                      [0.0, 50e6, 0.0],\n                      [0.0, 0.0, 50e6]]),\n            np.array([[2.0e-6, 0.0, 0.0],\n                      [0.0, -1.0e-6, 0.0],\n                      [0.0, 0.0, -1.0e-6]])\n        ),\n    ]\n    test_cases.append(tc2)\n\n    # Test Case 3: error case (negative dissipation)\n    tc3 = [\n        (\n            np.array([[100e6, 40e6, 0.0],\n                      [40e6, 100e6, 0.0],\n                      [0.0, 0.0, 100e6]]),\n            np.array([[-1.0e-5, 4.0e-6, 0.0],\n                      [4.0e-6, -1.0e-5, 0.0],\n                      [0.0, 0.0, -1.0e-5]])\n        ),\n    ]\n    test_cases.append(tc3)\n\n    # Test Case 4: edge cases (zero stress or zero plastic strain increments)\n    tc4 = [\n        (\n            np.zeros((3, 3)),\n            np.array([[1.0e-6, -0.5e-6, 0.0],\n                      [-0.5e-6, 0.0, 0.0],\n                      [0.0, 0.0, -0.5e-6]])\n        ),\n        (\n            np.array([[80e6, 0.0, 0.0],\n                      [0.0, 80e6, 0.0],\n                      [0.0, 0.0, 80e6]]),\n            np.zeros((3, 3))\n        ),\n    ]\n    test_cases.append(tc4)\n\n    results = []\n    for case in test_cases:\n        flag = evaluate_case(case, rtol=1e-12)\n        results.append(str(flag).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3523470"}]}