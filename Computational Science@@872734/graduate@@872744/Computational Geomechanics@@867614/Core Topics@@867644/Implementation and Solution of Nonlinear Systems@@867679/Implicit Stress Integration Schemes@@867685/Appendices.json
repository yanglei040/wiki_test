{"hands_on_practices": [{"introduction": "This first exercise lays the groundwork by focusing on the fundamental radial return algorithm for the von Mises ($J_2$) yield criterion. You will derive the update rule from first principles, demonstrating how a trial elastic stress that violates the yield condition is \"returned\" to the yield surface. This practice is essential for understanding the geometric and algebraic basis of implicit stress integration for smooth yield surfaces. [@problem_id:3532232]", "problem": "Consider a small-strain, isotropically hardening, associative von Mises plasticity model based on the second invariant of the deviatoric stress tensor, commonly denoted $J_2$. Let the elastic domain be defined by the yield function $f(\\boldsymbol{\\sigma}, \\bar{\\varepsilon}^{p}) = \\sigma_{\\mathrm{eq}} - \\sigma_{y}(\\bar{\\varepsilon}^{p})$, where the equivalent stress is $\\sigma_{\\mathrm{eq}} = \\sqrt{\\frac{3}{2}}\\,\\|\\boldsymbol{s}\\|$, $\\boldsymbol{s} = \\boldsymbol{\\sigma} - \\frac{1}{3}\\mathrm{tr}(\\boldsymbol{\\sigma})\\,\\boldsymbol{I}$ is the deviatoric stress, and the isotropic hardening follows $\\sigma_{y}(\\bar{\\varepsilon}^{p}) = \\sigma_{y0} + H\\,\\bar{\\varepsilon}^{p}$ with $\\sigma_{y0}  0$ and $H \\ge 0$. The elastic response is linear with shear modulus $G0$. The plastic flow is associative, $d\\boldsymbol{\\varepsilon}^{p} = d\\gamma\\,\\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}}$, and the equivalent plastic strain increment satisfies $d\\bar{\\varepsilon}^{p} = d\\gamma$.\n\nStarting from these fundamental definitions and the backward Euler stress update, derive the principal-space form of the implicit radial return for $J_2$ plasticity, showing that the updated principal deviatoric stresses are colinear with the trial principal deviatoric stresses and can be expressed via a single scalar factor that you must derive from first principles. Then apply your result to the following trial state and material parameters to compute the updated principal deviatoric stresses.\n\nGiven trial principal deviatoric stresses $s_{1}^{\\mathrm{tr}} = 100~\\mathrm{MPa}$, $s_{2}^{\\mathrm{tr}} = -50~\\mathrm{MPa}$, $s_{3}^{\\mathrm{tr}} = -50~\\mathrm{MPa}$, shear modulus $G = 300~\\mathrm{MPa}$, initial yield stress $\\sigma_{y0} = 80~\\mathrm{MPa}$, isotropic hardening modulus $H = 100~\\mathrm{MPa}$, and previous equivalent plastic strain $\\bar{\\varepsilon}^{p}_{n} = 0.2$, compute the updated principal deviatoric stresses $s_{1,n+1}$, $s_{2,n+1}$, $s_{3,n+1}$ using the implicit radial return in principal space. Express the final stresses in $\\mathrm{MPa}$. If a numerical approximation is required, round your answer to four significant figures. Provide your final answer as a single row matrix of the three components.", "solution": "The problem statement is evaluated as valid. It is a well-posed, scientifically grounded, and objective problem in the field of computational solid mechanics, specifically concerning the implementation of elastoplastic constitutive models. All necessary material parameters and initial conditions are provided, and the requested derivation and calculation are standard procedures for the $J_2$ plasticity model.\n\nThe solution proceeds in two parts. First, the general form of the implicit radial return algorithm for $J_2$ plasticity is derived in principal stress space. Second, this algorithm is applied to the given numerical data to find the updated stress state.\n\n**Part 1: Derivation of the Implicit Radial Return Algorithm**\n\nThe core of the implicit update is the stress relation $\\boldsymbol{\\sigma}_{n+1} = \\boldsymbol{\\sigma}^{\\mathrm{tr}} - \\boldsymbol{C}:\\Delta\\boldsymbol{\\varepsilon}^{p}$, where $\\boldsymbol{\\sigma}^{\\mathrm{tr}}$ is the trial elastic stress. For a linear isotropic elastic material, this relation can be decomposed into volumetric and deviatoric parts. The deviatoric stress update is:\n$$\n\\boldsymbol{s}_{n+1} = \\boldsymbol{s}^{\\mathrm{tr}} - 2G\\,\\Delta\\boldsymbol{\\varepsilon}_{\\mathrm{dev}}^{p}\n$$\nwhere $\\boldsymbol{s}$ is the deviatoric stress, $G$ is the shear modulus, and $\\Delta\\boldsymbol{\\varepsilon}_{\\mathrm{dev}}^{p}$ is the deviatoric part of the plastic strain increment. The plastic strain increment is determined by the backward Euler integration of the associative flow rule:\n$$\n\\Delta\\boldsymbol{\\varepsilon}^{p} = \\Delta\\gamma\\,\\left(\\frac{\\partial f}{\\partial\\boldsymbol{\\sigma}}\\right)_{\\boldsymbol{\\sigma}=\\boldsymbol{\\sigma}_{n+1}}\n$$\nwhere $\\Delta\\gamma \\ge 0$ is the plastic multiplier increment. The yield function $f = \\sigma_{\\mathrm{eq}} - \\sigma_{y}$ is a function of the deviatoric stress only, so its gradient is purely deviatoric. The gradient is:\n$$\n\\frac{\\partial f}{\\partial\\boldsymbol{\\sigma}} = \\frac{\\partial \\sigma_{\\mathrm{eq}}}{\\partial\\boldsymbol{\\sigma}} = \\frac{\\partial}{\\partial\\boldsymbol{\\sigma}}\\left(\\sqrt{\\frac{3}{2}\\boldsymbol{s}:\\boldsymbol{s}}\\right) = \\sqrt{\\frac{3}{2}}\\frac{\\boldsymbol{s}}{\\|\\boldsymbol{s}\\|}\n$$\nLet $\\boldsymbol{N}_{n+1} = \\frac{\\boldsymbol{s}_{n+1}}{\\|\\boldsymbol{s}_{n+1}\\|}$ be the unit normal to the yield surface in deviatoric stress space. The plastic strain increment is purely deviatoric:\n$$\n\\Delta\\boldsymbol{\\varepsilon}^{p} = \\Delta\\boldsymbol{\\varepsilon}_{\\mathrm{dev}}^{p} = \\Delta\\gamma \\sqrt{\\frac{3}{2}}\\boldsymbol{N}_{n+1}\n$$\nSubstituting this into the deviatoric stress update equation:\n$$\n\\boldsymbol{s}_{n+1} = \\boldsymbol{s}^{\\mathrm{tr}} - 2G\\,\\left(\\Delta\\gamma \\sqrt{\\frac{3}{2}}\\boldsymbol{N}_{n+1}\\right)\n$$\nThis equation shows that $\\boldsymbol{s}_{n+1}$ must be a linear combination of $\\boldsymbol{s}^{\\mathrm{tr}}$ and $\\boldsymbol{N}_{n+1}$. By definition, $\\boldsymbol{s}_{n+1}$ is parallel to $\\boldsymbol{N}_{n+1}$. This implies that $\\boldsymbol{s}_{n+1}$ must be collinear with $\\boldsymbol{s}^{\\mathrm{tr}}$. This is the \"radial return\" property. It follows that the unit normals are the same:\n$$\n\\boldsymbol{N}_{n+1} = \\frac{\\boldsymbol{s}_{n+1}}{\\|\\boldsymbol{s}_{n+1}\\|} = \\frac{\\boldsymbol{s}^{\\mathrm{tr}}}{\\|\\boldsymbol{s}^{\\mathrm{tr}}\\|} \\equiv \\boldsymbol{N}^{\\mathrm{tr}}\n$$\nTaking the norm of the stress update equation (noting that $\\boldsymbol{s}^{\\mathrm{tr}}$ and $\\boldsymbol{N}^{\\mathrm{tr}}$ are parallel):\n$$\n\\|\\boldsymbol{s}_{n+1}\\| = \\|\\boldsymbol{s}^{\\mathrm{tr}}\\| - 2G\\Delta\\gamma\\sqrt{\\frac{3}{2}}\n$$\nMultiplying by $\\sqrt{3/2}$ gives the relation in terms of equivalent stresses:\n$$\n\\sigma_{\\mathrm{eq},n+1} = \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - 3G\\Delta\\gamma\n$$\nTo find the unknown plastic multiplier $\\Delta\\gamma$, we enforce the consistency condition, which states that for a plastic step ($\\Delta\\gamma > 0$), the final stress state must lie on the updated yield surface: $f(\\boldsymbol{\\sigma}_{n+1}, \\bar{\\varepsilon}^{p}_{n+1}) = 0$. This means:\n$$\n\\sigma_{\\mathrm{eq},n+1} = \\sigma_{y}(\\bar{\\varepsilon}^{p}_{n+1})\n$$\nThe yield stress is updated by the hardening law: $\\sigma_{y,n+1} = \\sigma_{y,n} + H\\,\\Delta\\bar{\\varepsilon}^{p}$. Since $d\\bar{\\varepsilon}^p = d\\gamma$, we have $\\Delta\\bar{\\varepsilon}^p = \\Delta\\gamma$. Thus:\n$$\n\\sigma_{y,n+1} = \\sigma_{y,n} + H\\,\\Delta\\gamma\n$$\nEquating the expressions for $\\sigma_{\\mathrm{eq},n+1}$ and $\\sigma_{y,n+1}$:\n$$\n\\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - 3G\\,\\Delta\\gamma = \\sigma_{y,n} + H\\,\\Delta\\gamma\n$$\nSolving for $\\Delta\\gamma$:\n$$\n\\Delta\\gamma = \\frac{\\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - \\sigma_{y,n}}{3G + H}\n$$\nThis is valid only if plasticity occurs, i.e., $f^{\\mathrm{tr}} = \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - \\sigma_{y,n}  0$. If $f^{\\mathrm{tr}} \\le 0$, the step is elastic and $\\Delta\\gamma=0$. So, more generally:\n$$\n\\Delta\\gamma = \\frac{\\max(0, \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - \\sigma_{y,n})}{3G + H}\n$$\nThe updated deviatoric stress is then obtained by scaling the trial deviatoric stress. From the collinearity $\\boldsymbol{s}_{n+1} = \\alpha\\,\\boldsymbol{s}^{\\mathrm{tr}}$, we have $\\|\\boldsymbol{s}_{n+1}\\| = \\alpha \\|\\boldsymbol{s}^{\\mathrm{tr}}\\|$, which implies $\\sigma_{\\mathrm{eq},n+1} = \\alpha \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}}$. The scaling factor $\\alpha$ is thus:\n$$\n\\alpha = \\frac{\\sigma_{\\mathrm{eq},n+1}}{\\sigma_{\\mathrm{eq}}^{\\mathrm{tr}}} = \\frac{\\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - 3G\\Delta\\gamma}{\\sigma_{\\mathrm{eq}}^{\\mathrm{tr}}} = 1 - \\frac{3G\\Delta\\gamma}{\\sigma_{\\mathrm{eq}}^{\\mathrm{tr}}}\n$$\nSo, the final deviatoric stress is $\\boldsymbol{s}_{n+1} = \\left(1 - \\frac{3G\\Delta\\gamma}{\\sigma_{\\mathrm{eq}}^{\\mathrm{tr}}}\\right)\\boldsymbol{s}^{\\mathrm{tr}}$. Since this is a scalar multiplication, the updated principal deviatoric stresses are simply the scaled trial principal deviatoric stresses.\n\n**Part 2: Application to Numerical Data**\n\n**Given:**\n- Trial principal deviatoric stresses: $s_{1}^{\\mathrm{tr}} = 100~\\mathrm{MPa}$, $s_{2}^{\\mathrm{tr}} = -50~\\mathrm{MPa}$, $s_{3}^{\\mathrm{tr}} = -50~\\mathrm{MPa}$.\n- Material parameters: $G = 300~\\mathrm{MPa}$, $\\sigma_{y0} = 80~\\mathrm{MPa}$, $H = 100~\\mathrm{MPa}$.\n- Previous state: $\\bar{\\varepsilon}^{p}_{n} = 0.2$.\n\n**1. Check for Plasticity**\nFirst, compute the trial equivalent stress $\\sigma_{\\mathrm{eq}}^{\\mathrm{tr}}$:\n$$\n\\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} = \\sqrt{\\frac{3}{2}\\left((s_{1}^{\\mathrm{tr}})^2 + (s_{2}^{\\mathrm{tr}})^2 + (s_{3}^{\\mathrm{tr}})^2\\right)}\n$$\n$$\n\\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} = \\sqrt{\\frac{3}{2}\\left((100)^2 + (-50)^2 + (-50)^2\\right)} = \\sqrt{\\frac{3}{2}\\left(10000 + 2500 + 2500\\right)}\n$$\n$$\n\\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} = \\sqrt{\\frac{3}{2}(15000)} = \\sqrt{22500} = 150~\\mathrm{MPa}\n$$\nNext, compute the yield stress at the beginning of the step, $\\sigma_{y,n}$:\n$$\n\\sigma_{y,n} = \\sigma_{y0} + H\\,\\bar{\\varepsilon}^{p}_{n} = 80 + 100 \\times 0.2 = 80 + 20 = 100~\\mathrm{MPa}\n$$\nThe trial yield condition is $f^{\\mathrm{tr}} = \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - \\sigma_{y,n} = 150 - 100 = 50~\\mathrm{MPa}$. Since $f^{\\mathrm{tr}}  0$, the state is outside the elastic domain, and plastic deformation occurs.\n\n**2. Calculate the Plastic Multiplier Increment**\nUsing the derived formula:\n$$\n\\Delta\\gamma = \\frac{\\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - \\sigma_{y,n}}{3G + H} = \\frac{150 - 100}{3(300) + 100} = \\frac{50}{900 + 100} = \\frac{50}{1000} = 0.05\n$$\n\n**3. Compute the Updated Principal Deviatoric Stresses**\nThe updated deviatoric stresses are given by $\\boldsymbol{s}_{n+1} = \\boldsymbol{s}^{\\mathrm{tr}} \\left(1 - \\frac{3G\\,\\Delta\\gamma}{\\sigma_{\\mathrm{eq}}^{\\mathrm{tr}}} \\right)$. Let's calculate the scalar factor:\n$$\n\\text{Factor} = 1 - \\frac{3(300)(0.05)}{150} = 1 - \\frac{900 \\times 0.05}{150} = 1 - \\frac{45}{150} = 1 - 0.3 = 0.7\n$$\nNow, apply this factor to the trial principal deviatoric stresses:\n$$\ns_{1,n+1} = 0.7 \\times s_{1}^{\\mathrm{tr}} = 0.7 \\times 100 = 70~\\mathrm{MPa}\n$$\n$$\ns_{2,n+1} = 0.7 \\times s_{2}^{\\mathrm{tr}} = 0.7 \\times (-50) = -35~\\mathrm{MPa}\n$$\n$$\ns_{3,n+1} = 0.7 \\times s_{3}^{\\mathrm{tr}} = 0.7 \\times (-50) = -35~\\mathrm{MPa}\n$$\nThese results are exact and do not require rounding. The final updated principal deviatoric stresses are $(70, -35, -35)~\\mathrm{MPa}$.", "answer": "$$\n\\boxed{\\begin{pmatrix} 70  -35  -35 \\end{pmatrix}}\n$$", "id": "3532232"}, {"introduction": "Real-world geomaterials are often described by yield surfaces with corners and edges, such as the Mohr-Coulomb model. This practice moves beyond smooth surfaces to address the challenge of non-smooth plasticity, where the return direction is not uniquely defined. You will develop an active-plane detection strategy for a hexagonal yield surface, learning how to handle corner and face return cases by applying the principles of constrained optimization. [@problem_id:3532160]", "problem": "Consider small-strain elasto-plasticity with a convex yield surface in stress space. The return mapping algorithm seeks the updated stress by enforcing that the final stress lies on or within the yield surface and is the closest to the elastic trial stress, in the sense of minimizing a Euclidean norm in stress space. The Mohr–Coulomb yield surface is non-smooth and features corners on its deviatoric section, which complicates the closest-point projection. In Haigh–Westergaard coordinates, the deviatoric section (the so-called $\\pi$-plane) of the Mohr–Coulomb surface at fixed mean stress $p$ is a regular hexagon.\n\nFundamental basis: In convex elasto-plasticity, the admissible stress set $\\mathcal{K}$ is defined by a yield function $f(\\boldsymbol{\\sigma}) \\le 0$, with yield condition $f(\\boldsymbol{\\sigma}) = 0$ on the boundary. The implicit stress integration via closest-point projection solves the variational problem of finding the stress $\\boldsymbol{\\sigma}^{\\star}$ that minimizes the squared distance to the elastic trial stress $\\boldsymbol{\\sigma}^{\\mathrm{tr}}$ subject to $\\boldsymbol{\\sigma}^{\\star} \\in \\mathcal{K}$. The Kuhn–Tucker conditions ensure that, at the optimum, only the active yield constraints contribute via Lagrange multipliers. For a non-smooth surface like Mohr–Coulomb, multiple planes can be simultaneously active at corners.\n\nIn this problem, you will work in the deviatoric $\\pi$-plane and model the Mohr–Coulomb deviatoric section at a fixed mean stress $p$ as the convex set\n$$\n\\mathcal{H}_R = \\bigcap_{i=0}^{5} \\left\\{ \\mathbf{x} \\in \\mathbb{R}^2 \\;\\middle|\\; \\mathbf{n}_i^{\\top} \\mathbf{x} \\le R \\right\\},\n$$\nwhere $R0$ is the inradius (a given constant determined by material parameters such as friction angle and cohesion at the specified mean stress), and $\\{\\mathbf{n}_i\\}_{i=0}^{5}$ are outward unit normals of the six faces of a regular hexagon, defined as\n$$\n\\mathbf{n}_0 = \\begin{bmatrix}1 \\\\ 0\\end{bmatrix},\\quad\n\\mathbf{n}_1 = \\begin{bmatrix}\\tfrac{1}{2} \\\\ \\tfrac{\\sqrt{3}}{2}\\end{bmatrix},\\quad\n\\mathbf{n}_2 = \\begin{bmatrix}-\\tfrac{1}{2} \\\\ \\tfrac{\\sqrt{3}}{2}\\end{bmatrix},\\quad\n\\mathbf{n}_3 = \\begin{bmatrix}-1 \\\\ 0\\end{bmatrix},\\quad\n\\mathbf{n}_4 = \\begin{bmatrix}-\\tfrac{1}{2} \\\\ -\\tfrac{\\sqrt{3}}{2}\\end{bmatrix},\\quad\n\\mathbf{n}_5 = \\begin{bmatrix}\\tfrac{1}{2} \\\\ -\\tfrac{\\sqrt{3}}{2}\\end{bmatrix}.\n$$\nYou are given trial deviatoric stress points $\\mathbf{t} \\in \\mathbb{R}^2$. The implicit closest-point projection seeks\n$$\n\\mathbf{x}^{\\star} = \\arg\\min_{\\mathbf{x} \\in \\mathcal{H}_R} \\frac{1}{2} \\left\\| \\mathbf{x} - \\mathbf{t} \\right\\|_2^2.\n$$\nThe presence of corners allows the optimal solution $\\mathbf{x}^{\\star}$ to lie on a single face interior (one active plane) or at a vertex (intersection of two adjacent active planes). Your task is to derive, from first principles, an active-plane detection strategy that identifies whether the closest-point projection lies on a face interior or at a vertex, and then computes the projected point.\n\nRequirements:\n1. Derive the conditions under which the closest-point projection onto $\\mathcal{H}_R$ lies on a single face interior, and the conditions under which it lies at a vertex formed by the intersection of two adjacent faces. Use the variational characterization of the closest-point projection and the Kuhn–Tucker conditions as the fundamental basis for your derivation.\n2. Implement a program that, given $R$ and a set of trial points $\\mathbf{t}$, performs the following for each trial point:\n   - If $\\mathbf{t} \\in \\mathcal{H}_R$, classify the case as elastic and return the classification integer $0$, the empty active set, and the distance $0$.\n   - If $\\mathbf{t} \\notin \\mathcal{H}_R$, compute $\\mathbf{x}^{\\star}$ and detect the active set as follows:\n     - If the projection lies on a single face interior, classify as plastic-face with classification integer $1$ and return the active plane index $i$.\n     - If the projection lies at a vertex, classify as plastic-corner with classification integer $2$ and return the two adjacent active plane indices $\\{i,j\\}$ with $j \\in \\{(i-1) \\bmod 6, (i+1) \\bmod 6\\}$.\n   - Report the Euclidean distance $\\left\\|\\mathbf{x}^{\\star} - \\mathbf{t}\\right\\|_2$ rounded to six decimals.\n3. Numerical robustness: Treat equality checks with a tolerance $\\varepsilon = 10^{-9}$ when deciding feasibility and activity.\n4. Use the provided normals $\\mathbf{n}_i$ and the given $R$; assume that $R$ is already computed from material parameters at the specified mean stress and is provided to you. No physical units are required for the outputs.\n5. Test suite: Use $R=1$ and the following five trial points in the $\\pi$-plane:\n   - Case A (outside, face-dominated): $\\mathbf{t}_A = (1.5, 0.0)$.\n   - Case B (outside, corner-dominated): $\\mathbf{t}_B = (1.2, 0.8)$.\n   - Case C (inside): $\\mathbf{t}_C = (0.2, 0.1)$.\n   - Case D (on a face interior): $\\mathbf{t}_D = (1.0, 0.0)$.\n   - Case E (on a vertex): $\\mathbf{t}_E = \\left(1.0, \\tfrac{1}{\\sqrt{3}}\\right)$.\n6. Final output format: Your program should produce a single line of output containing a list of five entries, one per test case, preserving the order A, B, C, D, E. Each entry must be a list of the form $[\\text{class}, [\\text{active\\_indices}], \\text{distance}]$, where $\\text{class}$ is an integer, $[\\text{active\\_indices}]$ is a list of integers, and $\\text{distance}$ is a float rounded to six decimals. The entire output must be a single comma-separated list enclosed in square brackets. For example: $[[1,[0],0.123456],[2,[1,2],0.654321],\\ldots]$.\n\nYour program must be complete and runnable and must not require any user input.", "solution": "The problem requires the derivation and implementation of a closest-point projection algorithm for a trial deviatoric stress point onto a regular hexagonal domain, which models the Mohr–Coulomb yield surface in the $\\pi$-plane. The derivation must be based on the variational principles of plasticity and the Karush–Kuhn–Tucker (KKT) conditions for constrained optimization.\n\nThe optimization problem is to find the point $\\mathbf{x}^{\\star}$ in the convex set $\\mathcal{H}_R$ that minimizes the squared Euclidean distance to a given trial point $\\mathbf{t} \\in \\mathbb{R}^2$. The feasible set $\\mathcal{H}_R$ is defined by six linear inequality constraints:\n$$\n\\mathcal{H}_R = \\left\\{ \\mathbf{x} \\in \\mathbb{R}^2 \\;\\middle|\\; g_i(\\mathbf{x}) = \\mathbf{n}_i^{\\top} \\mathbf{x} - R \\le 0, \\quad i = 0, \\dots, 5 \\right\\}\n$$\nThe minimization problem is thus stated as:\n$$\n\\text{minimize} \\quad L(\\mathbf{x}) = \\frac{1}{2} \\left\\| \\mathbf{x} - \\mathbf{t} \\right\\|_2^2 \\quad \\text{subject to} \\quad \\mathbf{x} \\in \\mathcal{H}_R\n$$\nThe Lagrangian for this problem is:\n$$\n\\mathcal{L}(\\mathbf{x}, \\boldsymbol{\\lambda}) = \\frac{1}{2} \\left( \\mathbf{x} - \\mathbf{t} \\right)^{\\top} \\left( \\mathbf{x} - \\mathbf{t} \\right) + \\sum_{i=0}^{5} \\lambda_i \\left( \\mathbf{n}_i^{\\top} \\mathbf{x} - R \\right)\n$$\nwhere $\\lambda_i$ are the Lagrange multipliers. At the optimal solution $(\\mathbf{x}^{\\star}, \\boldsymbol{\\lambda}^{\\star})$, the KKT conditions must be satisfied:\n$1$. **Stationarity**: The gradient of the Lagrangian with respect to $\\mathbf{x}$ vanishes:\n$$\n\\nabla_{\\mathbf{x}} \\mathcal{L}(\\mathbf{x}^{\\star}, \\boldsymbol{\\lambda}^{\\star}) = \\mathbf{x}^{\\star} - \\mathbf{t} + \\sum_{i=0}^{5} \\lambda_i^{\\star} \\mathbf{n}_i = \\mathbf{0} \\quad \\implies \\quad \\mathbf{t} - \\mathbf{x}^{\\star} = \\sum_{i=0}^{5} \\lambda_i^{\\star} \\mathbf{n}_i\n$$\n$2$. **Primal Feasibility**: The solution must be in the feasible set:\n$$\n\\mathbf{n}_i^{\\top} \\mathbf{x}^{\\star} - R \\le 0 \\quad \\text{for all } i \\in \\{0, \\dots, 5\\}\n$$\n$3$. **Dual Feasibility**: The Lagrange multipliers must be non-negative:\n$$\n\\lambda_i^{\\star} \\ge 0 \\quad \\text{for all } i \\in \\{0, \\dots, 5\\}\n$$\n$4$. **Complementary Slackness**: For each constraint, either the multiplier is zero or the constraint is active:\n$$\n\\lambda_i^{\\star} \\left( \\mathbf{n}_i^{\\top} \\mathbf{x}^{\\star} - R \\right) = 0 \\quad \\text{for all } i \\in \\{0, \\dots, 5\\}\n$$\nThe stationarity condition states that the vector from the projected point $\\mathbf{x}^{\\star}$ to the trial point $\\mathbf{t}$ must be expressible as a non-negative linear combination of the outward normals of the active constraints (where $\\mathbf{n}_i^{\\top} \\mathbf{x}^{\\star} - R = 0$).\n\nWe analyze the possible cases based on the location of the trial point $\\mathbf{t}$.\n\n**Case 0: Elastic (if $\\mathbf{t} \\in \\mathcal{H}_R$)**\nIf the trial point $\\mathbf{t}$ is already inside or on the boundary of the feasible set $\\mathcal{H}_R$, it is its own closest point. The minimum of $L(\\mathbf{x})$ is at $\\mathbf{x}^{\\star} = \\mathbf{t}$, with a value of $0$.\nThe stationarity condition becomes $\\mathbf{t} - \\mathbf{t} = \\sum \\lambda_i^{\\star} \\mathbf{n}_i = \\mathbf{0}$, which implies all $\\lambda_i^{\\star} = 0$.\nThe complementary slackness condition $\\lambda_i^{\\star}(\\mathbf{n}_i^{\\top}\\mathbf{t} - R) = 0$ is satisfied because $\\lambda_i^\\star = 0$.\nPrimal feasibility requires $\\mathbf{n}_i^{\\top}\\mathbf{t} - R \\le 0$ for all $i$, which is the definition of $\\mathbf{t} \\in \\mathcal{H}_R$.\nThus, if $\\mathbf{n}_i^{\\top}\\mathbf{t} - R \\le \\varepsilon$ for all $i$ (using the given numerical tolerance), the case is elastic, the active set is empty, and the distance is $0$.\n\n**Case 1: Plastic Return to a Face (one active constraint)**\nSuppose the trial point $\\mathbf{t}$ is outside $\\mathcal{H}_R$, and its projection $\\mathbf{x}^{\\star}$ lies on the interior of a single face $k$.\nFrom complementary slackness, only $\\lambda_k^{\\star}$ can be non-zero, so $\\lambda_i^{\\star}=0$ for $i \\ne k$.\nThe stationarity equation simplifies to $\\mathbf{t} - \\mathbf{x}^{\\star} = \\lambda_k^{\\star} \\mathbf{n}_k$.\nThe constraint for face $k$ is active: $\\mathbf{n}_k^{\\top}\\mathbf{x}^{\\star} = R$.\nSolving for $\\mathbf{x}^{\\star}$ from stationarity gives $\\mathbf{x}^{\\star} = \\mathbf{t} - \\lambda_k^{\\star} \\mathbf{n}_k$. Substituting this into the active constraint:\n$\\mathbf{n}_k^{\\top}(\\mathbf{t} - \\lambda_k^{\\star} \\mathbf{n}_k) = R \\implies \\mathbf{n}_k^{\\top}\\mathbf{t} - \\lambda_k^{\\star} \\|\\mathbf{n}_k\\|_2^2 = R$.\nSince $\\mathbf{n}_k$ is a unit normal, $\\|\\mathbf{n}_k\\|_2^2 = 1$, we find the multiplier: $\\lambda_k^{\\star} = \\mathbf{n}_k^{\\top}\\mathbf{t} - R$.\nDual feasibility requires $\\lambda_k^{\\star}  0$, which means $\\mathbf{n}_k^{\\top}\\mathbf{t}  R$, confirming that $\\mathbf{t}$ is outside the half-space defined by face $k$.\nThe projected point is therefore $\\mathbf{x}^{\\star} = \\mathbf{t} - (\\mathbf{n}_k^{\\top}\\mathbf{t} - R)\\mathbf{n}_k$.\nFor this solution to be valid, $\\mathbf{x}^\\star$ must not violate any other constraint, i.e., $\\mathbf{n}_i^{\\top}\\mathbf{x}^\\star - R \\le 0$ for all $i \\ne k$. This means the projection falls within the line segment corresponding to face $k$ of the hexagon.\n\n**Case 2: Plastic Return to a Corner (two active constraints)**\nIf the projection $\\mathbf{x}^{\\star}$ is a vertex, it is the intersection of two adjacent faces, say $j$ and $k=(j+1)\\pmod 6$.\nThe position of the vertex $\\mathbf{x}^{\\star}$ is found by solving the linear system:\n$$\n\\begin{bmatrix} \\mathbf{n}_j^{\\top} \\\\ \\mathbf{n}_k^{\\top} \\end{bmatrix} \\mathbf{x}^{\\star} = \\begin{bmatrix} R \\\\ R \\end{bmatrix}\n$$\nFrom complementary slackness, only $\\lambda_j^{\\star}$ and $\\lambda_k^{\\star}$ can be non-zero. The stationarity condition is $\\mathbf{t} - \\mathbf{x}^{\\star} = \\lambda_j^{\\star} \\mathbf{n}_j + \\lambda_k^{\\star} \\mathbf{n}_k$.\nThis is a linear system for the multipliers:\n$$\n\\begin{bmatrix} \\mathbf{n}_j  \\mathbf{n}_k \\end{bmatrix} \\begin{bmatrix} \\lambda_j^{\\star} \\\\ \\lambda_k^{\\star} \\end{bmatrix} = \\mathbf{t} - \\mathbf{x}^{\\star}\n$$\nThe solution is valid if dual feasibility is met: $\\lambda_j^{\\star} \\ge 0$ and $\\lambda_k^{\\star} \\ge 0$. This condition geometrically means that the vector $\\mathbf{t} - \\mathbf{x}^{\\star}$ must lie within the cone spanned by the normals $\\mathbf{n}_j$ and $\\mathbf{n}_k$.\n\n**Active-Plane Detection Strategy**\nBased on this analysis, the following algorithm determines the active set and computes the projection $\\mathbf{x}^{\\star}$ for a given trial point $\\mathbf{t}$:\n$1$. **Elasticity Check**: For each face $i=0, \\dots, 5$, compute the signed distance $d_i = \\mathbf{n}_i^{\\top}\\mathbf{t} - R$. If $\\max_i(d_i) \\le \\varepsilon$, the point is inside or on the boundary of $\\mathcal{H}_R$. The case is elastic, $\\mathbf{x}^{\\star}=\\mathbf{t}$, the active set is empty, and the distance is $0$.\n$2$. **Face-Return Hypothesis**: If the point is outside, find the most violated constraint, $k = \\arg\\max_i(d_i)$. Hypothesize that the projection is onto the interior of face $k$. Compute the candidate projection point $\\mathbf{x}_{\\text{face}} = \\mathbf{t} - d_k \\mathbf{n}_k$. Check if this point lies on the face segment by verifying that the constraints of the two adjacent faces are satisfied: $\\mathbf{n}_{(k-1)\\pmod 6}^{\\top} \\mathbf{x}_{\\text{face}} \\le R+\\varepsilon$ and $\\mathbf{n}_{(k+1)\\pmod 6}^{\\top} \\mathbf{x}_{\\text{face}} \\le R+\\varepsilon$. If both conditions hold, the hypothesis is correct. The case is a plastic-face return, the active set is $\\{k\\}$, and $\\mathbf{x}^{\\star} = \\mathbf{x}_{\\text{face}}$.\n$3$. **Corner-Return Case**: If the face-return hypothesis fails, the trial point must lie in a region where the projection is a vertex. By convexity, the closest point in $\\mathcal{H}_R$ must be one of the two vertices of the most violated face $k$. Let these vertices be $v_k$ (intersection of faces $k-1$ and $k$) and $v_{k+1}$ (intersection of faces $k$ and $k+1$). Compute the distances $\\|\\mathbf{t}-v_k\\|_2$ and $\\|\\mathbf{t}-v_{k+1}\\|_2$. The closer vertex is the solution $\\mathbf{x}^{\\star}$. If $v_k$ is closer, the active planes are $\\{(k-1)\\pmod 6, k\\}$. If $v_{k+1}$ is closer, the active planes are $\\{k, (k+1)\\pmod 6\\}$. This is a plastic-corner return.\n\nThis strategy systematically and correctly identifies the active set and the closest point $\\mathbf{x}^{\\star}$ for any trial point $\\mathbf{t} \\in \\mathbb{R}^2$.", "answer": "```python\nimport numpy as np\n\ndef setup_geometry(R):\n    \"\"\"\n    Sets up the normals and vertices for the regular hexagon with inradius R.\n\n    Args:\n        R (float): The inradius of the hexagon.\n\n    Returns:\n        tuple: A tuple containing:\n            - np.ndarray: An array of the six outward unit normals.\n            - np.ndarray: An array of the six vertices of the hexagon. \n                          vertex[i] is the intersection of faces (i-1)%6 and i.\n    \"\"\"\n    s3_2 = np.sqrt(3) / 2.0\n    normals = np.array([\n        [1.0, 0.0],\n        [0.5, s3_2],\n        [-0.5, s3_2],\n        [-1.0, 0.0],\n        [-0.5, -s3_2],\n        [0.5, -s3_2]\n    ])\n    \n    vertices = np.zeros((6, 2))\n    for i in range(6):\n        im1 = (i - 1) % 6\n        # The vertex is the solution to a 2x2 linear system\n        # [n_{i-1}^T] * x = [R]\n        # [n_i^T    ]     [R]\n        A = np.array([normals[im1], normals[i]])\n        b = np.array([R, R])\n        vertices[i] = np.linalg.solve(A, b)\n        \n    return normals, vertices\n\ndef project_to_hexagon(t, R, normals, vertices, tolerance):\n    \"\"\"\n    Projects a trial point t onto the hexagon H_R.\n\n    Args:\n        t (np.ndarray): The 2D trial point.\n        R (float): The inradius of the hexagon.\n        normals (np.ndarray): The normals of the hexagon's faces.\n        vertices (np.ndarray): The vertices of the hexagon.\n        tolerance (float): Numerical tolerance for equality checks.\n\n    Returns:\n        list: A list containing [class, [active_indices], distance].\n    \"\"\"\n    # 1. Elastic Check: Check if the point is inside or on the boundary.\n    # Calculate violations d_i = n_i^T * t - R\n    violations = normals @ t - R\n    max_violation = np.max(violations)\n    \n    if max_violation = tolerance:\n        # Point is inside or on the boundary (elastic case).\n        # Per problem statement, active set is empty and distance is 0.\n        return [0, [], 0.0]\n\n    # 2. Plastic Check: The point is outside.\n    # Identify the most violated plane (largest positive violation).\n    k = np.argmax(violations)\n    \n    # 3. Face Return Hypothesis\n    # Project t onto the infinite line containing face k.\n    d_k = violations[k]\n    n_k = normals[k]\n    x_face_proj = t - d_k * n_k\n    \n    # Check if the projection lies on the face segment by testing against adjacent planes.\n    km1 = (k - 1) % 6\n    kp1 = (k + 1) % 6\n    \n    # Check if the point is feasible with respect to adjacent constraints.\n    if (normals[km1] @ x_face_proj - R = tolerance) and \\\n       (normals[kp1] @ x_face_proj - R = tolerance):\n        # Projection is on the face interior.\n        distance = np.linalg.norm(t - x_face_proj)\n        return [1, [k], round(distance, 6)]\n        \n    # 4. Corner Return\n    # If face return fails, the projection must be to a corner.\n    # The candidate vertices are the two vertices of face k.\n    v_k = vertices[k]       # Intersection of faces (k-1, k)\n    v_kp1 = vertices[kp1]   # Intersection of faces (k, k+1)\n    \n    dist_vk = np.linalg.norm(t - v_k)\n    dist_vkp1 = np.linalg.norm(t - v_kp1)\n    \n    if dist_vk  dist_vkp1:\n        # Projection is to vertex v_k. Active planes are (k-1) and k.\n        active_indices = sorted([km1, k])\n        distance = dist_vk\n        return [2, active_indices, round(distance, 6)]\n    else:\n        # Projection is to vertex v_{k+1}. Active planes are k and (k+1).\n        active_indices = sorted([k, kp1])\n        distance = dist_vkp1\n        return [2, active_indices, round(distance, 6)]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    R = 1.0\n    TOLERANCE = 1e-9\n    \n    test_cases = [\n        np.array([1.5, 0.0]),                            # Case A\n        np.array([1.2, 0.8]),                            # Case B\n        np.array([0.2, 0.1]),                            # Case C\n        np.array([1.0, 0.0]),                            # Case D\n        np.array([1.0, 1.0/np.sqrt(3)])                  # Case E\n    ]\n    \n    normals, vertices = setup_geometry(R)\n    \n    results = []\n    for t_point in test_cases:\n        result = project_to_hexagon(t_point, R, normals, vertices, TOLERANCE)\n        results.append(result)\n        \n    # Format the results into the exact string format specified.\n    # Using str(list).replace(\" \", \"\") achieves the required no-space format,\n    # e.g., '[1,[0],0.5]' instead of '[1, [0], 0.5]'.\n    formatted_results = [str(res).replace(\" \", \"\") for res in results]\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3532160"}, {"introduction": "The final step in mastering implicit integration is understanding its role within a larger finite element framework, which requires the consistent algorithmic tangent. This advanced exercise guides you through deriving this tangent for a non-associative Mohr-Coulomb model and implementing it to solve a global boundary value problem. By comparing its performance to a simpler elastic tangent, you will witness firsthand its critical importance for achieving quadratic convergence in Newton-Raphson solvers. [@problem_id:3532237]", "problem": "Consider an isotropic, small-strain, rate-independent elastoplastic soil model under plane strain with an implicit stress integration scheme using the backward Euler method. The elastic part follows Hooke’s law with bulk modulus $K$ and shear modulus $G$, and the plastic part follows a nonassociative Mohr–Coulomb model defined on the triaxial compression meridian with a rounded apex. All definitions, steps, and derivations must use physically consistent sign conventions typical in geomechanics, namely compression is positive for stress and strain.\n\nYou will derive the consistent algorithmic tangent $\\partial \\boldsymbol{\\sigma}_{n+1}/\\partial \\boldsymbol{\\varepsilon}_{n+1}$ suitable for an implicit return mapping under a nonassociative Mohr–Coulomb model with a rounded apex, and then test its effect on the convergence of a global Newton–Raphson method in a simplified rigid footing problem modeled as a one-degree-of-freedom vertical compression of a soil column.\n\nFundamental basis and model ingredients to be used:\n- Linear isotropic elasticity: the Cauchy stress tensor $\\boldsymbol{\\sigma}$ relates to the elastic strain tensor $\\boldsymbol{\\varepsilon}^{e}$ via $\\boldsymbol{\\sigma} = \\mathbb{C} : \\boldsymbol{\\varepsilon}^{e}$, where $\\mathbb{C}$ is the fourth-order elastic stiffness tensor defined by bulk modulus $K$ and shear modulus $G$.\n- The mean stress $p$ is $p = \\frac{1}{3} \\mathrm{tr}(\\boldsymbol{\\sigma})$, and the deviatoric stress invariant $q$ is $q = \\sqrt{3 J_{2}}$ with $J_{2} = \\frac{1}{2} \\boldsymbol{s}:\\boldsymbol{s}$ and $\\boldsymbol{s} = \\boldsymbol{\\sigma} - p \\boldsymbol{I}$.\n- For plane strain compression with only the axial strain component nonzero, namely $\\varepsilon_{11} = \\varepsilon$ and $\\varepsilon_{22} = \\varepsilon_{33} = 0$, the elastic trial invariants for a single backward Euler step from zero stress are $p^{\\mathrm{tr}} = K \\varepsilon$ and $q^{\\mathrm{tr}} = 2 G \\varepsilon$.\n- The Mohr–Coulomb yield function on the triaxial compression meridian is $f(p,q) = q - M_{c} \\,\\Phi(p) - k_{c}$, where $M_{c} = \\frac{6 \\sin \\varphi}{3 - \\sin \\varphi}$ and $k_{c} = \\frac{6 c \\cos \\varphi}{3 - \\sin \\varphi}$, with friction angle $\\varphi$ and cohesion $c$. The rounded apex is introduced by $\\Phi(p) = \\sqrt{p^{2} + p_{0}^{2}}$ with small rounding parameter $p_{0}  0$.\n- The nonassociative plastic potential is $g(p,q) = q - M_{g} p$, where $M_{g} = \\frac{6 \\sin \\psi}{3 - \\sin \\psi}$ with dilation angle $\\psi$.\n- Plastic flow rule: $\\Delta \\boldsymbol{\\varepsilon}^{p} = \\Delta \\lambda \\,\\frac{\\partial g}{\\partial \\boldsymbol{\\sigma}}$, where $\\Delta \\lambda \\ge 0$ is the plastic multiplier. Under the meridian representation, the plastic volumetric strain increment is $\\Delta \\varepsilon_{v}^{p} = - M_{g} \\Delta \\lambda$ and the equivalent deviatoric plastic strain increment is $\\Delta \\gamma^{p} = \\Delta \\lambda$.\n\nTask A (Derivation): Starting from the fundamental bases above, derive the implicit return mapping for the single backward Euler step and obtain the scalar nonlinear equation for the plastic multiplier at step $n+1$,\n$$\ng(\\Delta \\lambda,\\varepsilon) \\equiv q^{\\mathrm{tr}}(\\varepsilon) - 3 G \\Delta \\lambda - M_{c} \\,\\Phi\\Big(p^{\\mathrm{tr}}(\\varepsilon) + K M_{g} \\Delta \\lambda\\Big) - k_{c} = 0,\n$$\nand derive the consistent algorithmic tangent $E_{\\mathrm{cons}} = \\frac{\\partial \\sigma_{11}}{\\partial \\varepsilon}$ for the final stress update $\\boldsymbol{\\sigma}_{n+1}(\\varepsilon)$ under this implicit scheme. Use the principal stress reconstruction for axisymmetric meridian states,\n$$\n\\sigma_{1} = p + \\frac{2}{3} q,\\quad \\sigma_{2} = \\sigma_{3} = p - \\frac{1}{3} q,\n$$\nand the implicit function theorem. The derivative of the rounded apex function is $\\Phi'(p) = \\frac{p}{\\sqrt{p^{2} + p_{0}^{2}}}$. Express $E_{\\mathrm{cons}}$ in closed form in terms of $K$, $G$, $M_{c}$, $M_{g}$, $p^{\\mathrm{tr}}$, $q^{\\mathrm{tr}}$, $p_{0}$, and the converged $\\Delta \\lambda$.\n\nTask B (Algorithmic experiment): Implement a program that, for a soil column of height $H$ compressed by a rigid footing of area $A$ under a prescribed vertical load $P$, solves the scalar equilibrium\n$$\nR(w) = P - A \\,\\sigma_{11}\\Big(\\varepsilon=\\frac{w}{H}\\Big) = 0,\n$$\nby a global Newton–Raphson (NR) method for the unknown footing displacement $w$. Compare two global schemes:\n- Scheme $1$: use the consistent algorithmic tangent $E_{\\mathrm{cons}}$ in the global Newton update, i.e., $\\mathrm{d}R/\\mathrm{d}w = - A \\, E_{\\mathrm{cons}}/H$.\n- Scheme $2$: use a nominal elastic tangent $E_{\\mathrm{el}} = K + \\frac{4}{3} G$ regardless of plasticity, i.e., $\\mathrm{d}R/\\mathrm{d}w = - A \\, E_{\\mathrm{el}}/H$.\n\nReport, for each load case in the test suite below, the number of global Newton iterations required to reach $|R(w)|  \\tau$ with tolerance $\\tau = 10^{-3}\\,\\mathrm{N}$, starting from the elastic predictor $w_{0} = \\frac{P H}{A E_{\\mathrm{el}}}$ and limiting the maximum number of iterations to $N_{\\max} = 50$ with a simple backtracking factor of $1/2$ applied when $|R|$ increases.\n\nUse the following scientifically plausible parameters and units:\n- Elastic modulus $E = 100 \\times 10^{6}\\,\\mathrm{Pa}$ and Poisson’s ratio $\\nu = 0.3$, giving $K = \\frac{E}{3(1 - 2 \\nu)}$ and $G = \\frac{E}{2(1 + \\nu)}$.\n- Friction angle $\\varphi = 20\\,\\mathrm{degrees}$, dilation angle $\\psi = 5\\,\\mathrm{degrees}$.\n- Cohesion $c = 25 \\times 10^{3}\\,\\mathrm{Pa}$.\n- Apex rounding parameter $p_{0} = 1 \\times 10^{3}\\,\\mathrm{Pa}$.\n- Footing area $A = 1\\,\\mathrm{m}^{2}$, soil column height $H = 1\\,\\mathrm{m}$.\n- Angle unit: use degrees for $\\varphi$ and $\\psi$ and convert to radians internally.\n- Loads (expressed as forces in $\\mathrm{N}$): $P_{1} = 5 \\times 10^{3}$, $P_{2} = 200 \\times 10^{3}$, $P_{3} = 600 \\times 10^{3}$, $P_{4} = 1{,}200 \\times 10^{3}$.\n\nTest suite and final output specification:\n- For each $P_{i}$, compute the iteration counts $(n_{i}^{\\mathrm{cons}}, n_{i}^{\\mathrm{nom}})$ for Scheme $1$ and Scheme $2$, respectively.\n- Your program should produce a single line of output containing the results as a comma-separated list of eight integers in the order $[n_{1}^{\\mathrm{cons}}, n_{1}^{\\mathrm{nom}}, n_{2}^{\\mathrm{cons}}, n_{2}^{\\mathrm{nom}}, n_{3}^{\\mathrm{cons}}, n_{3}^{\\mathrm{nom}}, n_{4}^{\\mathrm{cons}}, n_{4}^{\\mathrm{nom}}]$.\n- All answers are pure integers (no units in the output). Internally, use International System of Units (SI units) consistently, and the specified angle unit conversion.\n\nEnsure scientific realism by adhering to the implicit integration framework, and avoid shortcut formulas not derived from the specified bases. Provide complete derivations and then implement the algorithm accordingly.", "solution": "This problem requires a full derivation of the consistent tangent modulus for a non-trivial soil model and its implementation in a global Newton-Raphson solver to test convergence. The solution consists of two parts: a theoretical derivation (Task A) followed by an algorithmic experiment (Task B).\n\n### Task A: Derivation of the Return Mapping and Consistent Tangent\n\nThis task requires deriving the stress update rule and the consistent algorithmic tangent for a nonassociative, rounded-apex Mohr–Coulomb model under an implicit backward Euler scheme. The analysis is specialized for a plane strain compression case where the total strain tensor is determined by a single scalar, $\\varepsilon = \\varepsilon_{11}$.\n\n**1. Preliminaries and Constitutive Update**\n\nWe begin with the additive decomposition of strain, which for a backward Euler scheme is discretized as:\n$$\n\\Delta \\boldsymbol{\\varepsilon} = \\Delta \\boldsymbol{\\varepsilon}^{e} + \\Delta \\boldsymbol{\\varepsilon}^{p}\n$$\nThe stress at the end of the step, $\\boldsymbol{\\sigma}_{n+1}$, is given by Hooke's law on the final elastic strain:\n$$\n\\boldsymbol{\\sigma}_{n+1} = \\mathbb{C} : \\boldsymbol{\\varepsilon}^{e}_{n+1} = \\mathbb{C} : (\\boldsymbol{\\varepsilon}_{n+1} - \\boldsymbol{\\varepsilon}^{p}_{n+1})\n$$\nAssuming the process starts from a zero-strain, zero-stress state, we have $\\boldsymbol{\\varepsilon}_{n+1}=\\Delta\\boldsymbol{\\varepsilon}$ and $\\boldsymbol{\\varepsilon}^{p}_{n+1}=\\Delta\\boldsymbol{\\varepsilon}^p$. The elastic trial stress is defined as $\\boldsymbol{\\sigma}^{\\mathrm{tr}} = \\mathbb{C} : \\boldsymbol{\\varepsilon}_{n+1}$. The stress update is then expressed as:\n$$\n\\boldsymbol{\\sigma}_{n+1} = \\boldsymbol{\\sigma}^{\\mathrm{tr}} - \\mathbb{C} : \\Delta\\boldsymbol{\\varepsilon}^{p}\n$$\nThe plastic strain increment is given by the nonassociative flow rule, evaluated at the end of the step (implicit scheme):\n$$\n\\Delta \\boldsymbol{\\varepsilon}^{p} = \\Delta \\lambda \\left. \\frac{\\partial g}{\\partial \\boldsymbol{\\sigma}} \\right|_{\\boldsymbol{\\sigma}_{n+1}}\n$$\nwhere $\\Delta \\lambda \\ge 0$ is the plastic multiplier and $g(p, q) = q - M_g p$ is the plastic potential function.\n\n**2. Decomposition into Volumetric and Deviatoric Components**\n\nUsing the standard decomposition of the elastic tensor $\\mathbb{C}$ in terms of bulk modulus $K$ and shear modulus $G$, the stress update can be split into volumetric (mean stress $p$) and deviatoric (stress deviator $\\boldsymbol{s}$) parts:\n$$\np_{n+1} = p^{\\mathrm{tr}} - K \\Delta \\varepsilon_{v}^{p}\n$$\n$$\n\\boldsymbol{s}_{n+1} = \\boldsymbol{s}^{\\mathrm{tr}} - 2G \\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{dev}}^{p}\n$$\nwhere $\\Delta \\varepsilon_{v}^{p} = \\mathrm{tr}(\\Delta \\boldsymbol{\\varepsilon}^{p})$ and $\\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{dev}}^{p} = \\mathrm{dev}(\\Delta \\boldsymbol{\\varepsilon}^{p})$. From the problem statement, the flow rule implies $\\Delta \\varepsilon_{v}^{p} = -\\Delta \\lambda M_g$ and the equivalent plastic deviatoric strain increment $\\Delta \\gamma^p = \\Delta \\lambda$. The deviatoric stress update using equivalent invariants is $q_{n+1} = q^\\mathrm{tr} - 3G\\Delta\\gamma^p$. Substituting these into the update equations yields the return mapping in terms of stress invariants:\n$$\np_{n+1} = p^{\\mathrm{tr}} - K(-\\Delta\\lambda M_g) = p^{\\mathrm{tr}} + K M_g \\Delta\\lambda\n$$\n$$\nq_{n+1} = q^{\\mathrm{tr}} - 3G \\Delta\\gamma^p = q^{\\mathrm{tr}} - 3G \\Delta\\lambda\n$$\n\n**3. Scalar Equation for the Plastic Multiplier**\n\nIf plastic loading occurs, the final stress state $(\\boldsymbol{\\sigma}_{n+1})$ must lie on the yield surface. This is the plastic consistency condition, $f(p_{n+1}, q_{n+1}) = 0$. The yield function is $f(p, q) = q - M_c \\Phi(p) - k_c$. Substituting the expressions for $p_{n+1}$ and $q_{n+1}$ gives a single scalar nonlinear equation for the unknown plastic multiplier $\\Delta\\lambda$:\n$$\n(q^{\\mathrm{tr}} - 3G \\Delta\\lambda) - M_c \\Phi(p^{\\mathrm{tr}} + K M_g \\Delta\\lambda) - k_c = 0\n$$\nAs per the problem statement, we define this residual function for $\\Delta\\lambda$, which depends implicitly on the total strain $\\varepsilon$ through the trial state ($p^{\\mathrm{tr}}=K\\varepsilon$, $q^{\\mathrm{tr}}=2G\\varepsilon$):\n$$\nR_{\\lambda}(\\Delta\\lambda, \\varepsilon) \\equiv q^{\\mathrm{tr}}(\\varepsilon) - 3G \\Delta\\lambda - M_{c} \\,\\Phi\\Big(p^{\\mathrm{tr}}(\\varepsilon) + K M_{g} \\Delta \\lambda\\Big) - k_{c} = 0\n$$\nThis equation is solved for $\\Delta\\lambda \\ge 0$ if the trial state is outside the yield surface, i.e., if $f(p^{\\mathrm{tr}}, q^{\\mathrm{tr}})  0$. If $f(p^{\\mathrm{tr}}, q^{\\mathrm{tr}}) \\le 0$, the step is elastic and $\\Delta\\lambda = 0$.\n\n**4. Derivation of the Consistent Algorithmic Tangent**\n\nThe consistent algorithmic tangent modulus $E_{\\mathrm{cons}}$ for this one-dimensional problem is defined as the derivative of the final axial stress $\\sigma_{11}$ with respect to the axial strain $\\varepsilon$:\n$$\nE_{\\mathrm{cons}} = \\frac{d\\sigma_{11, n+1}}{d\\varepsilon}\n$$\nWe use the principal stress reconstruction for the specified axisymmetric loading path: $\\sigma_{11} = p_{n+1} + \\frac{2}{3}q_{n+1}$. Differentiating with respect to $\\varepsilon$:\n$$\nE_{\\mathrm{cons}} = \\frac{d p_{n+1}}{d\\varepsilon} + \\frac{2}{3}\\frac{d q_{n+1}}{d\\varepsilon}\n$$\nThe derivatives of the final stress invariants $p_{n+1}$ and $q_{n+1}$ are found by differentiating their respective return mapping equations:\n$$\n\\frac{d p_{n+1}}{d\\varepsilon} = \\frac{d p^{\\mathrm{tr}}}{d\\varepsilon} + K M_g \\frac{d(\\Delta\\lambda)}{d\\varepsilon}\n$$\n$$\n\\frac{d q_{n+1}}{d\\varepsilon} = \\frac{d q^{\\mathrm{tr}}}{d\\varepsilon} - 3G \\frac{d(\\Delta\\lambda)}{d\\varepsilon}\n$$\nSince $p^{\\mathrm{tr}} = K\\varepsilon$ and $q^{\\mathrm{tr}} = 2G\\varepsilon$, we have $\\frac{d p^{\\mathrm{tr}}}{d\\varepsilon} = K$ and $\\frac{d q^{\\mathrm{tr}}}{d\\varepsilon} = 2G$. The crucial term is $\\frac{d(\\Delta\\lambda)}{d\\varepsilon}$, which is obtained by applying the implicit function theorem to the consistency equation $R_{\\lambda}(\\Delta\\lambda(\\varepsilon), \\varepsilon) = 0$. The total derivative must be zero:\n$$\n\\frac{d R_{\\lambda}}{d\\varepsilon} = \\frac{\\partial R_{\\lambda}}{\\partial \\varepsilon} + \\frac{\\partial R_{\\lambda}}{\\partial (\\Delta\\lambda)} \\frac{d(\\Delta\\lambda)}{d\\varepsilon} = 0\n$$\nThis gives:\n$$\n\\frac{d(\\Delta\\lambda)}{d\\varepsilon} = - \\left( \\frac{\\partial R_{\\lambda}}{\\partial (\\Delta\\lambda)} \\right)^{-1} \\frac{\\partial R_{\\lambda}}{\\partial \\varepsilon}\n$$\nWe compute the partial derivatives of $R_{\\lambda}$. Let $p_{f} = p^{\\mathrm{tr}} + K M_g \\Delta\\lambda$.\n$$\n\\frac{\\partial R_{\\lambda}}{\\partial (\\Delta\\lambda)} = -3G - M_c \\Phi'(p_f) \\frac{\\partial p_f}{\\partial (\\Delta\\lambda)} = -3G - M_c \\Phi'(p_f) (K M_g)\n$$\n$$\n\\frac{\\partial R_{\\lambda}}{\\partial \\varepsilon} = \\frac{\\partial q^{\\mathrm{tr}}}{\\partial \\varepsilon} - M_c \\Phi'(p_f) \\frac{\\partial p_f}{\\partial \\varepsilon} = 2G - M_c \\Phi'(p_f) \\frac{\\partial p^{\\mathrm{tr}}}{\\partial \\varepsilon} = 2G - M_c \\Phi'(p_f) K\n$$\nwhere $\\Phi'(p_f) = \\frac{p_f}{\\sqrt{p_f^2 + p_0^2}}$.\nLet's define a scalar modulus $H_{\\lambda} = -\\frac{\\partial R_{\\lambda}}{\\partial (\\Delta\\lambda)} = 3G + K M_c M_g \\Phi'(p_f)$. Then:\n$$\n\\frac{d(\\Delta\\lambda)}{d\\varepsilon} = \\frac{2G - K M_c \\Phi'(p_f)}{3G + K M_c M_g \\Phi'(p_f)} = \\frac{2G - K M_c \\Phi'(p_f)}{H_{\\lambda}}\n$$\nSubstituting this back into the expressions for $\\frac{dp_{n+1}}{d\\varepsilon}$ and $\\frac{dq_{n+1}}{d\\varepsilon}$:\n$$\n\\frac{d p_{n+1}}{d\\varepsilon} = K + K M_g \\frac{d(\\Delta\\lambda)}{d\\varepsilon}\n$$\n$$\n\\frac{d q_{n+1}}{d\\varepsilon} = 2G - 3G \\frac{d(\\Delta\\lambda)}{d\\varepsilon}\n$$\nFinally, we assemble the expression for $E_{\\mathrm{cons}}$:\n$$\nE_{\\mathrm{cons}} = \\left(K + K M_g \\frac{d(\\Delta\\lambda)}{d\\varepsilon}\\right) + \\frac{2}{3}\\left(2G - 3G \\frac{d(\\Delta\\lambda)}{d\\varepsilon}\\right)\n$$\n$$\nE_{\\mathrm{cons}} = K + \\frac{4}{3}G + K M_g \\frac{d(\\Delta\\lambda)}{d\\varepsilon} - 2G \\frac{d(\\Delta\\lambda)}{d\\varepsilon} = \\left(K + \\frac{4}{3}G\\right) + (K M_g - 2G) \\frac{d(\\Delta\\lambda)}{d\\varepsilon}\n$$\nThe first term is the uniaxial elastic modulus $E_{\\mathrm{el}}$. Substituting the full expression for $\\frac{d(\\Delta\\lambda)}{d\\varepsilon}$ yields the final form of the consistent algorithmic tangent for the plastic case:\n$$\nE_{\\mathrm{cons}} = \\left(K + \\frac{4}{3}G\\right) + (K M_g - 2G) \\frac{2G - K M_c \\Phi'(p_{f})}{3G + K M_c M_g \\Phi'(p_{f})}\n$$\nThis expression is evaluated using the converged values of $\\Delta\\lambda$ and $p_f = p_{n+1}$ from the return mapping procedure for the current strain level $\\varepsilon$. For an elastic step ($\\Delta\\lambda=0$), this derivation is not used, and the tangent is simply $E_{\\mathrm{cons}} = E_{\\mathrm{el}} = K + \\frac{4}{3}G$.\n\nThis completes the derivation for Task A. Task B implements this result in a Newton-Raphson framework.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import ...\n# No other non-standard libraries are used.\n\ndef solve():\n    \"\"\"\n    Main function to perform the algorithmic experiment as per the problem statement.\n    \"\"\"\n\n    # --- 1. Define model parameters and constants ---\n    E = 100e6  # Pa\n    nu = 0.3\n    phi_deg = 20.0  # degrees\n    psi_deg = 5.0  # degrees\n    c = 25e3  # Pa\n    p0 = 1e3  # Pa\n    A = 1.0  # m^2\n    H = 1.0  # m\n    res_tol = 1e-3  # N\n    max_iter = 50\n    loads = [5e3, 200e3, 600e3, 1200e3]  # N\n\n    # --- 2. Calculate derived material parameters ---\n    K = E / (3 * (1 - 2 * nu))\n    G = E / (2 * (1 + nu))\n    E_el = K + 4/3 * G\n\n    phi_rad = np.deg2rad(phi_deg)\n    psi_rad = np.deg2rad(psi_deg)\n\n    sin_phi = np.sin(phi_rad)\n    cos_phi = np.cos(phi_rad)\n    sin_psi = np.sin(psi_rad)\n\n    Mc = (6 * sin_phi) / (3 - sin_phi)\n    kc = (6 * c * cos_phi) / (3 - sin_phi)\n    Mg = (6 * sin_psi) / (3 - sin_psi)\n    \n    params = {\n        'K': K, 'G': G, 'Mc': Mc, 'kc': kc, 'Mg': Mg, 'p0': p0, 'E_el': E_el\n    }\n\n    # --- 3. Core stress integration function ---\n    def get_stress_and_tangent(strain, scheme, params):\n        \"\"\"\n        Performs stress integration for a given strain and returns the axial stress\n        and the appropriate tangent modulus for the global NR scheme.\n        \"\"\"\n        K, G, Mc, kc, Mg, p0, E_el = params.values()\n\n        # Trial state\n        p_tr = K * strain\n        q_tr = 2 * G * strain\n\n        # Yield check\n        f_tr = q_tr - Mc * np.sqrt(p_tr**2 + p0**2) - kc\n\n        if f_tr = 1e-9:  # Elastic step (with a small tolerance)\n            sigma_11 = E_el * strain\n            tangent = E_el\n            return sigma_11, tangent\n\n        else:  # Plastic step: perform return mapping\n            delta_lambda = 0.0  # Initial guess for plastic multiplier\n            \n            # Local Newton-Raphson to find delta_lambda\n            for _ in range(20):\n                p_final_guess = p_tr + K * Mg * delta_lambda\n                \n                phi_p = np.sqrt(p_final_guess**2 + p0**2)\n                \n                # Residual for delta_lambda\n                R_lambda = (q_tr - 3 * G * delta_lambda) - Mc * phi_p - kc\n                \n                if abs(R_lambda)  1e-9:\n                    break\n                \n                # Derivative of residual w.r.t. delta_lambda\n                phi_prime_p = p_final_guess / phi_p\n                R_prime_lambda = -3 * G - Mc * phi_prime_p * (K * Mg)\n                \n                delta_lambda -= R_lambda / R_prime_lambda\n            \n            # Update stress invariants with converged delta_lambda\n            p_final = p_tr + K * Mg * delta_lambda\n            q_final = q_tr - 3 * G * delta_lambda\n            sigma_11 = p_final + 2/3 * q_final\n\n            # Calculate tangent modulus\n            if scheme == 'nominal':\n                tangent = E_el\n            else:  # scheme == 'consistent'\n                phi_p_final = np.sqrt(p_final**2 + p0**2)\n                phi_prime_final = p_final / phi_p_final\n                \n                num = 2*G - K*Mc*phi_prime_final\n                den = 3*G + K*Mc*Mg*phi_prime_final\n                \n                d_lambda_d_eps = num / den\n                \n                tangent = E_el + (K * Mg - 2*G) * d_lambda_d_eps\n            \n            return sigma_11, tangent\n\n    # --- 4. Main loop for algorithmic experiment ---\n    results = []\n    \n    for P in loads:\n        for scheme in ['consistent', 'nominal']:\n            # Initial guess for displacement\n            w = (P * H) / (A * E_el)\n            \n            n_iter = 0\n            while n_iter  max_iter:\n                strain = w / H\n                sigma_11, E_t = get_stress_and_tangent(strain, scheme, params)\n\n                # Global residual\n                R = P - A * sigma_11\n                if abs(R)  res_tol:\n                    break\n\n                n_iter += 1 # An iteration is one update step\n                \n                # Global tangent stiffness and displacement update\n                K_glob = -A * E_t / H\n                delta_w = -R / K_glob\n                \n                # Simple backtracking line search\n                alpha = 1.0\n                w_prev = w\n                R_prev_abs = abs(R)\n\n                while True:\n                    w = w_prev + alpha * delta_w\n                    strain_new = w / H\n                    \n                    # We only need stress for residual check, not the tangent\n                    sigma_11_new, _ = get_stress_and_tangent(strain_new, scheme, params)\n                    R_new = P - A * sigma_11_new\n\n                    if abs(R_new)  R_prev_abs:\n                        break # Step accepted\n                    \n                    alpha /= 2.0\n                    \n                    if alpha  1e-5: # Safeguard against tiny steps\n                        # If backtracking fails, accept the step and hope for the best\n                        # This may happen if the tangent is very inaccurate.\n                        break\n            \n            results.append(n_iter)\n            \n    # --- 5. Print final results ---\n    print(f\"[{','.join(map(str, results))}]\")\n\n\n# Execute the simulation\nsolve()\n```", "id": "3532237"}]}