{"hands_on_practices": [{"introduction": "The most fundamental challenge in numerical plasticity is accurately capturing the transition from elastic to plastic behavior within a single load increment. This exercise uses a simple one-dimensional model to demonstrate the \"artificial elastic gap\"—an error that arises when a coarse integration step overlooks an elastic-plastic transition. By deriving and implementing a substepping strategy with event detection, you will gain a foundational understanding of why substepping is crucial for accuracy and how it prevents the accumulation of non-physical results. [@problem_id:3566116]", "problem": "Consider small-strain, rate-independent, one-dimensional elastoplasticity for a geomaterial with linear isotropic elasticity and linear isotropic hardening. The Cauchy stress is denoted by $\\sigma$, the total strain by $\\varepsilon$, the plastic strain by $\\varepsilon^{p}$, and the scalar accumulated plastic strain by $\\kappa$. The elastic law is $\\sigma = E \\, (\\varepsilon - \\varepsilon^{p})$, where $E$ is the elastic modulus. The yield function is taken to be $f(\\sigma,\\kappa) = \\lvert \\sigma \\rvert - (\\sigma_{y0} + H \\kappa)$, where $\\sigma_{y0}$ is the initial yield stress and $H \\ge 0$ is the linear isotropic hardening modulus. The Kuhn-Tucker conditions are assumed to hold: $f \\le 0$, $\\dot{\\gamma} \\ge 0$, $f \\, \\dot{\\gamma} = 0$, with $\\dot{\\gamma}$ the plastic multiplier, and $\\dot{\\kappa} = \\lvert \\dot{\\varepsilon}^{p} \\rvert$.\n\nYou must numerically integrate the constitutive equations over a single strain increment from a known previous state $\\left( \\sigma_n, \\kappa_n \\right)$ and an imposed strain increment $\\Delta \\varepsilon = \\varepsilon_{n+1} - \\varepsilon_n$. Two time-integration strategies are considered:\n\n- Strategy $\\mathcal{U}$ (unsplit single-step explicit classification): Classify the entire increment based on the previous state. If $f(\\sigma_n,\\kappa_n) \\le 0$, treat the whole step as elastic, i.e., set $\\Delta \\varepsilon^{p} = 0$ for the entire increment. If $f(\\sigma_n,\\kappa_n)  0$, treat the whole step as plastic in the same sense. This strategy does not detect transitions into or out of the plastic regime that occur strictly inside the increment.\n\n- Strategy $\\mathcal{S}$ (substepping with $f=0$ event detection): Detect the earliest crossing of the yield surface inside the increment and split the increment at the parameter $\\lambda^\\star \\in [0,1]$ for which $f$ equals $0$. On the interval $\\lambda \\in [0,\\lambda^\\star]$ integrate elastically with $\\Delta \\varepsilon^{p} = 0$, then on $\\lambda \\in (\\lambda^\\star,1]$ integrate plastically (consistent with the elastoplastic constitutive law) if and only if $f  0$ beyond the crossing. Within the single increment, the elastic trial stress evolves as $\\sigma(\\lambda) = \\sigma_n + E \\, \\Delta \\varepsilon \\, \\lambda$ while $\\kappa$ remains $\\kappa_n$ until plasticity activates.\n\nDefine the artificial elastic gap for an increment as the strain length (in $\\varepsilon$-units) of the subset of the increment over which the true response is plastic (as determined by the $\\mathcal{S}$ strategy) but the $\\mathcal{U}$ strategy incorrectly keeps the response elastic; equivalently, it is the measure (in $\\varepsilon$) of the set $\\{ \\lambda \\in [0,1] \\mid f(\\sigma(\\lambda),\\kappa_n)  0\\}$ that goes undetected by $\\mathcal{U}$ when $f(\\sigma_n,\\kappa_n) \\le 0$. The reduction in artificial elastic gap achieved by $\\mathcal{S}$ relative to $\\mathcal{U}$ is then the difference between the gap under $\\mathcal{U}$ and the gap under $\\mathcal{S}$ (the latter is zero by construction).\n\nStarting from the fundamental definitions above and without invoking any pre-derived plasticity integration formulas, derive the event-detection condition for the earliest yield-surface crossing inside an increment by solving for the smallest $\\lambda^\\star \\in [0,1]$ that satisfies $f(\\sigma(\\lambda^\\star),\\kappa_n) = 0$, where $\\sigma(\\lambda) = \\sigma_n + E \\, \\Delta \\varepsilon \\, \\lambda$. Use this to compute the plastic sub-interval length in $\\lambda$ as $\\max(0,1 - \\lambda^\\star)$ when $f(\\sigma_n,\\kappa_n) \\le 0$ and $f(\\sigma_n + E \\, \\Delta \\varepsilon,\\kappa_n)  0$, and set it to zero otherwise. The artificial elastic gap of $\\mathcal{U}$ is then the plastic sub-interval length multiplied by $\\lvert \\Delta \\varepsilon \\rvert$; the artificial elastic gap of $\\mathcal{S}$ is zero. The required output for each test case is the reduction in artificial elastic gap, expressed in units of strain (dimensionless), as a floating-point number.\n\nImplement a complete, runnable program that, for each test case, computes and returns the gap reduction as defined above. Use the following test suite, where each test case is a tuple $\\left( E, \\sigma_{y0}, H, \\sigma_n, \\kappa_n, \\Delta \\varepsilon \\right)$:\n\n- Test A (happy path, enters plastic near the end): $\\left( E = 10000, \\, \\sigma_{y0} = 100, \\, H = 0, \\, \\sigma_n = 0, \\, \\kappa_n = 0, \\, \\Delta \\varepsilon = 0.015 \\right)$.\n- Test B (boundary, just touches yield at the end): $\\left( E = 10000, \\, \\sigma_{y0} = 100, \\, H = 0, \\, \\sigma_n = 0, \\, \\kappa_n = 0, \\, \\Delta \\varepsilon = 0.010 \\right)$.\n- Test C (deeply plastic at the end): $\\left( E = 10000, \\, \\sigma_{y0} = 100, \\, H = 0, \\, \\sigma_n = 0, \\, \\kappa_n = 0, \\, \\Delta \\varepsilon = 0.030 \\right)$.\n- Test D (nonzero initial stress within elastic domain): $\\left( E = 10000, \\, \\sigma_{y0} = 100, \\, H = 0, \\, \\sigma_n = 50, \\, \\kappa_n = 0, \\, \\Delta \\varepsilon = 0.010 \\right)$.\n- Test E (reverse loading into compression): $\\left( E = 10000, \\, \\sigma_{y0} = 100, \\, H = 0, \\, \\sigma_n = 0, \\, \\kappa_n = 0, \\, \\Delta \\varepsilon = -0.025 \\right)$.\n- Test F (with hardening and prior plastic history): $\\left( E = 10000, \\, \\sigma_{y0} = 100, \\, H = 1000, \\, \\sigma_n = 120, \\, \\kappa_n = 0.05, \\, \\Delta \\varepsilon = 0.050 \\right)$.\n- Test G (no crossing, remains elastic throughout): $\\left( E = 10000, \\, \\sigma_{y0} = 100, \\, H = 1000, \\, \\sigma_n = 120, \\, \\kappa_n = 0.05, \\, \\Delta \\varepsilon = 0.002 \\right)$.\n- Test H (zero increment edge case): $\\left( E = 10000, \\, \\sigma_{y0} = 100, \\, H = 0, \\, \\sigma_n = 0, \\, \\kappa_n = 0, \\, \\Delta \\varepsilon = 0.000 \\right)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\left[ \\text{result}_1, \\text{result}_2, \\dots \\right]$). Each result must be a floating-point number representing the reduction in artificial elastic gap in strain units, rounded in the default string conversion of the language.", "solution": "The problem requires the derivation and implementation of a formula for the reduction in artificial elastic gap when moving from a single-step explicit integration scheme (Strategy $\\mathcal{U}$) to a substepping scheme with event detection (Strategy $\\mathcal{S}$). As defined, the artificial elastic gap of Strategy $\\mathcal{S}$ is zero by construction. Therefore, the required reduction is simply the artificial elastic gap of Strategy $\\mathcal{U}$.\n\nAn artificial elastic gap arises under Strategy $\\mathcal{U}$ only when it incorrectly treats a portion of the strain increment as elastic when it should be plastic. This occurs under a specific set of conditions:\n1.  The state at the beginning of the increment, time $t_n$, must be elastic or on the yield surface, i.e., $f(\\sigma_n, \\kappa_n) \\le 0$. If the state were already plastic ($f(\\sigma_n, \\kappa_n)  0$), Strategy $\\mathcal{U}$ would correctly treat the increment as plastic, and no artificial *elastic* gap would be generated.\n2.  The purely elastic trial state at the end of the increment, time $t_{n+1}$, must lie outside the yield surface. If the trial state were to remain elastic, then the entire increment is indeed elastic, and Strategy $\\mathcal{U}$'s classification would be correct.\n\nThe analysis proceeds by formalizing these conditions and deriving the size of the erroneously elastic segment.\n\nFirst, we define the relevant quantities. The yield stress at the beginning of the increment is a function of the prior accumulated plastic strain $\\kappa_n$:\n$$\n\\sigma_{y,n} = \\sigma_{y0} + H \\kappa_n\n$$\nThe elastic domain for stress is therefore the interval $[-\\sigma_{y,n}, \\sigma_{y,n}]$. The initial state is elastic if $|\\sigma_n| \\le \\sigma_{y,n}$.\n\nDuring an elastic trial step, the stress evolves linearly with a parameter $\\lambda \\in [0, 1]$ that spans the strain increment $\\Delta\\varepsilon$:\n$$\n\\sigma(\\lambda) = \\sigma_n + E \\Delta\\varepsilon \\lambda\n$$\nThe trial stress at the end of the increment corresponds to $\\lambda=1$:\n$$\n\\sigma_{n+1}^{\\mathrm{trial}} = \\sigma(\\lambda=1) = \\sigma_n + E \\Delta\\varepsilon\n$$\nAn artificial elastic gap exists if, and only if, $|\\sigma_n| \\le \\sigma_{y,n}$ and $|\\sigma_{n+1}^{\\mathrm{trial}}|  \\sigma_{y,n}$. If these conditions are not met, the gap is zero.\n\nAssuming the conditions for a gap are met, we must find the point of first yielding. This is the smallest value $\\lambda^\\star \\in [0, 1]$ for which the stress path $\\sigma(\\lambda)$ intersects the yield surface. The yield condition is $f(\\sigma(\\lambda), \\kappa_n) = 0$, which is equivalent to $|\\sigma(\\lambda)| = \\sigma_{y,n}$. Substituting the expression for $\\sigma(\\lambda)$:\n$$\n|\\sigma_n + E \\Delta\\varepsilon \\lambda^\\star| = \\sigma_{y,n}\n$$\nThis absolute value equation yields two linear equations for $\\lambda^\\star$:\n1.  $\\sigma_n + E \\Delta\\varepsilon \\lambda^\\star = \\sigma_{y,n} \\quad \\implies \\quad \\lambda_1^\\star = \\frac{\\sigma_{y,n} - \\sigma_n}{E \\Delta\\varepsilon}$\n2.  $\\sigma_n + E \\Delta\\varepsilon \\lambda^\\star = -\\sigma_{y,n} \\quad \\implies \\quad \\lambda_2^\\star = \\frac{-\\sigma_{y,n} - \\sigma_n}{E \\Delta\\varepsilon}$\n\nWe require the smallest non-negative solution for $\\lambda^\\star$. The initial state is elastic, so $-\\sigma_{y,n} \\le \\sigma_n \\le \\sigma_{y,n}$. This implies $\\sigma_{y,n} - \\sigma_n \\ge 0$ and $-\\sigma_{y,n} - \\sigma_n \\le 0$.\nIf $E \\Delta\\varepsilon  0$, then $\\lambda_1^\\star \\ge 0$ and $\\lambda_2^\\star \\le 0$. The only valid crossing point in forward \"time\" ($\\lambda  0$) is $\\lambda_1^\\star$.\nIf $E \\Delta\\varepsilon  0$, then $\\lambda_1^\\star \\le 0$ and $\\lambda_2^\\star \\ge 0$. The only valid crossing point is $\\lambda_2^\\star$.\nThe case $\\Delta\\varepsilon = 0$ results in $\\sigma_{n+1}^{\\mathrm{trial}} = \\sigma_n$, so $|\\sigma_{n+1}^{\\mathrm{trial}}| \\le \\sigma_{y,n}$ and the gap is zero. We henceforth assume $\\Delta\\varepsilon \\neq 0$.\n\nThe value of $\\lambda^\\star$ must lie in $[0,1]$. Since yielding occurs by the end of the step ($|\\sigma_{n+1}^{\\mathrm{trial}}|  \\sigma_{y,n}$), it is guaranteed that $\\lambda^\\star \\in [0,1)$.\n\nThe increment is elastic for $\\lambda \\in [0, \\lambda^\\star]$ and becomes plastic for $\\lambda \\in (\\lambda^\\star, 1]$. Strategy $\\mathcal{U}$, by assuming the entire increment is elastic, creates an error over this second sub-interval. The length of this plastic sub-interval in terms of the parameter $\\lambda$ is:\n$$\nL_\\lambda = 1 - \\lambda^\\star\n$$\nThe problem defines the artificial elastic gap, $G$, as this length multiplied by the magnitude of the strain increment, $|\\Delta\\varepsilon|$:\n$$\nG = (1 - \\lambda^\\star) |\\Delta\\varepsilon|\n$$\n\nWe now substitute the expressions for $\\lambda^\\star$:\n\nCase 1: Yield in tension ($\\sigma_{n+1}^{\\mathrm{trial}}  \\sigma_{y,n}$). This implies $E \\Delta\\varepsilon  0$, so $|\\Delta\\varepsilon| = \\Delta\\varepsilon$ if $E0$.\n$$\n\\lambda^\\star = \\lambda_1^\\star = \\frac{\\sigma_{y,n} - \\sigma_n}{E \\Delta\\varepsilon}\n$$\n$$\nG = \\left(1 - \\frac{\\sigma_{y,n} - \\sigma_n}{E \\Delta\\varepsilon}\\right) \\Delta\\varepsilon = \\frac{E \\Delta\\varepsilon - (\\sigma_{y,n} - \\sigma_n)}{E \\Delta\\varepsilon} \\Delta\\varepsilon = \\frac{\\sigma_n + E \\Delta\\varepsilon - \\sigma_{y,n}}{E} = \\frac{\\sigma_{n+1}^{\\mathrm{trial}} - \\sigma_{y,n}}{E}\n$$\n\nCase 2: Yield in compression ($\\sigma_{n+1}^{\\mathrm{trial}}  -\\sigma_{y,n}$). This implies $E \\Delta\\varepsilon  0$, so $|\\Delta\\varepsilon| = -\\Delta\\varepsilon$ if $E0$.\n$$\n\\lambda^\\star = \\lambda_2^\\star = \\frac{-\\sigma_{y,n} - \\sigma_n}{E \\Delta\\varepsilon}\n$$\n$$\nG = \\left(1 - \\frac{-\\sigma_{y,n} - \\sigma_n}{E \\Delta\\varepsilon}\\right) (-\\Delta\\varepsilon) = \\frac{E \\Delta\\varepsilon - (-\\sigma_{y,n} - \\sigma_n)}{E \\Delta\\varepsilon} (-\\Delta\\varepsilon) = -\\frac{\\sigma_n + E \\Delta\\varepsilon + \\sigma_{y,n}}{E} = \\frac{-(\\sigma_{n+1}^{\\mathrm{trial}} + \\sigma_{y,n})}{E}\n$$\nSince $\\sigma_{n+1}^{\\mathrm{trial}}  -\\sigma_{y,n}$, the numerator is positive.\n\nBoth cases can be expressed by a single, compact formula using the absolute value:\n$$\nG = \\frac{|\\sigma_{n+1}^{\\mathrm{trial}}| - \\sigma_{y,n}}{E}\n$$\nThis elegantly represents the strain corresponding to the portion of the trial stress that \"overshoots\" the yield surface.\n\nThe final algorithm for computing the reduction in artificial elastic gap for each test case is as follows:\n1.  Read the parameters $(E, \\sigma_{y0}, H, \\sigma_n, \\kappa_n, \\Delta\\varepsilon)$.\n2.  Calculate the yield stress for the current state: $\\sigma_{y,n} = \\sigma_{y0} + H \\kappa_n$.\n3.  Check if the initial state is plastic: If $|\\sigma_n|  \\sigma_{y,n}$, the gap is $0$.\n4.  If the initial state is elastic or on the yield surface, calculate the elastic trial stress at the end of the increment: $\\sigma_{n+1}^{\\mathrm{trial}} = \\sigma_n + E \\Delta\\varepsilon$.\n5.  Check if the trial stress state remains elastic: If $|\\sigma_{n+1}^{\\mathrm{trial}}| \\le \\sigma_{y,n}$, the gap is $0$.\n6.  If the trial stress state is plastic ($|\\sigma_{n+1}^{\\mathrm{trial}}|  \\sigma_{y,n}$), calculate the gap using the derived formula: $G = (|\\sigma_{n+1}^{\\mathrm{trial}}| - \\sigma_{y,n}) / E$.\n7.  The result for the test case is $G$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the reduction in artificial elastic gap for a series of\n    elastoplasticity test cases.\n    \"\"\"\n    # Test cases are tuples of (E, sigma_y0, H, sigma_n, kappa_n, delta_eps)\n    test_cases = [\n        # Test A: happy path, enters plastic near the end\n        (10000.0, 100.0, 0.0, 0.0, 0.0, 0.015),\n        # Test B: boundary, just touches yield at the end\n        (10000.0, 100.0, 0.0, 0.0, 0.0, 0.010),\n        # Test C: deeply plastic at the end\n        (10000.0, 100.0, 0.0, 0.0, 0.0, 0.030),\n        # Test D: nonzero initial stress within elastic domain\n        (10000.0, 100.0, 0.0, 50.0, 0.0, 0.010),\n        # Test E: reverse loading into compression\n        (10000.0, 100.0, 0.0, 0.0, 0.0, -0.025),\n        # Test F: with hardening and prior plastic history\n        (10000.0, 100.0, 1000.0, 120.0, 0.05, 0.050),\n        # Test G: no crossing, remains elastic throughout\n        (10000.0, 100.0, 1000.0, 120.0, 0.05, 0.002),\n        # Test H: zero increment edge case\n        (10000.0, 100.0, 0.0, 0.0, 0.0, 0.000),\n    ]\n\n    results = []\n    for case in test_cases:\n        E, sigma_y0, H, sigma_n, kappa_n, delta_eps = case\n\n        # 1. Calculate the yield stress for the current state n.\n        sigma_y_n = sigma_y0 + H * kappa_n\n\n        # 2. Check if the initial state is plastic. If so, strategy U is correct,\n        #    so the artificial elastic gap is zero.\n        if np.abs(sigma_n) > sigma_y_n:\n            gap = 0.0\n        else:\n            # 3. Calculate the elastic trial stress at the end of the increment.\n            sigma_trial_n_plus_1 = sigma_n + E * delta_eps\n\n            # 4. The artificial elastic gap exists only if the trial state is plastic.\n            #    The magnitude of the gap is the strain corresponding to the stress \"overshoot\".\n            #    f_trial represents the value of the yield function for the trial stress.\n            f_trial = np.abs(sigma_trial_n_plus_1) - sigma_y_n\n\n            if f_trial > 0:\n                gap = f_trial / E\n            else:\n                # If f_trial = 0, the entire step is elastic, so no gap.\n                gap = 0.0\n        \n        results.append(gap)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3566116"}, {"introduction": "Moving from conceptual models to practical geomechanical analysis requires robust substepping algorithms for complex, three-dimensional constitutive laws. This practice challenges you to implement an adaptive substepping scheme for the widely used Drucker–Prager yield criterion, comparing two distinct strategies for controlling substep size: one based on the stability of the plastic flow direction and another on the magnitude of the yield function residual. This exercise provides direct experience in coding a full return-mapping algorithm and evaluating the trade-offs between different error control measures, a core skill in computational geomechanics. [@problem_id:3566154]", "problem": "You are tasked with designing and implementing two adaptive substepping termination criteria for integrating an associated Drucker–Prager elastoplastic model under small strains. The two criteria are: stationarity of the plastic flow direction and residual yield function magnitude. Your program must simulate the stress update over a single prescribed total strain increment using each criterion and report the number of accepted substeps and the difference in the final stress states. All quantities must be expressed in megapascal units for stress and dimensionless units for strain.\n\nUse the following context and base definitions, which are fundamental in computational geomechanics and small-strain elastoplasticity.\n\n1. The constitutive behavior is linear elastic with isotropy up to yield. For small strains, the stress increment is given by\n$$\n\\Delta \\boldsymbol{\\sigma} = \\lambda \\, \\mathrm{tr}(\\Delta \\boldsymbol{\\varepsilon}) \\, \\boldsymbol{I} + 2 \\mu \\, \\mathrm{dev}(\\Delta \\boldsymbol{\\varepsilon}),\n$$\nwhere $\\lambda$ and $\\mu$ are the Lamé constants, $\\boldsymbol{I}$ is the identity tensor, $\\mathrm{tr}(\\cdot)$ denotes the trace, and $\\mathrm{dev}(\\cdot)$ denotes the deviatoric projection. The Lamé constants are related to Young’s modulus $E$ and Poisson’s ratio $\\nu$ by\n$$\n\\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)}, \\quad \\mu = \\frac{E}{2(1+\\nu)}.\n$$\n\n2. The associated Drucker–Prager yield function with isotropic hardening is\n$$\nf(\\boldsymbol{\\sigma}, \\kappa) = \\alpha \\, I_1 + \\sqrt{J_2} - \\left(\\sigma_{y0} + H \\kappa \\right),\n$$\nwhere $I_1 = \\mathrm{tr}(\\boldsymbol{\\sigma})$, $J_2 = \\tfrac{1}{2} \\, \\mathrm{dev}(\\boldsymbol{\\sigma}) : \\mathrm{dev}(\\boldsymbol{\\sigma})$, $\\alpha$ is a given friction parameter, $\\sigma_{y0}$ is the initial yield stress, $H$ is the isotropic hardening modulus, and $\\kappa$ is the internal hardening variable that accumulates as plastic flow proceeds. The plastic flow direction for associated flow is defined by the gradient of the yield function with respect to stress,\n$$\n\\boldsymbol{m}(\\boldsymbol{\\sigma}) = \\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}} = \\alpha \\boldsymbol{I} + \\frac{\\mathrm{dev}(\\boldsymbol{\\sigma})}{2 \\sqrt{J_2}},\n$$\nand its normalized form\n$$\n\\boldsymbol{n}(\\boldsymbol{\\sigma}) = \\frac{\\boldsymbol{m}(\\boldsymbol{\\sigma})}{\\|\\boldsymbol{m}(\\boldsymbol{\\sigma})\\|_F},\n$$\nwhere $\\|\\cdot\\|_F$ is the Frobenius norm. When $J_2$ is sufficiently small, regularize $\\sqrt{J_2}$ with a small positive threshold to avoid division by zero.\n\n3. Consider the substepping framework in which the total strain increment $\\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{tot}}$ is partitioned into substeps of size $\\Delta \\boldsymbol{\\varepsilon}_i = \\xi_i \\, \\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{tot}}$ with $0  \\xi_i \\leq 1$ and $\\sum_i \\xi_i = 1$. Within each substep, adopt a constant-direction approximation for the plastic flow: freeze the gradient $\\boldsymbol{m}$ at the beginning of the substep. With $\\boldsymbol{m}_i = \\boldsymbol{m}(\\boldsymbol{\\sigma}_i)$ fixed over substep $i$, the stress update is\n$$\n\\boldsymbol{\\sigma}_{i+1} = \\boldsymbol{\\sigma}_{i} + \\lambda \\, \\mathrm{tr}(\\Delta \\boldsymbol{\\varepsilon}_i) \\, \\boldsymbol{I} + 2 \\mu \\, \\mathrm{dev}(\\Delta \\boldsymbol{\\varepsilon}_i) - d\\lambda_i \\left[\\lambda \\, \\mathrm{tr}(\\boldsymbol{m}_i) \\, \\boldsymbol{I} + 2 \\mu \\, \\mathrm{dev}(\\boldsymbol{m}_i)\\right],\n$$\nwhere $d\\lambda_i \\geq 0$ is the plastic multiplier increment for the substep and the hardening update is $\\kappa_{i+1} = \\kappa_i + d\\lambda_i$. The consistency condition $f(\\boldsymbol{\\sigma}_{i+1}, \\kappa_{i+1}) = 0$ for plastic loading in substep $i$ defines a scalar nonlinear equation for $d\\lambda_i$; use a Newton method to solve it. If the trial elastic predictor at the end of the substep satisfies $f \\leq 0$, then $d\\lambda_i = 0$ and the substep is purely elastic.\n\n4. Implement the two acceptance criteria for substeps:\n   - Stationarity of flow direction: accept the substep when the change in the normalized flow direction between the beginning and end of the substep satisfies\n     $$\n     \\left\\|\\boldsymbol{n}_{i+1} - \\boldsymbol{n}_{i} \\right\\|_F  \\varepsilon_n,\n     $$\n     where $\\varepsilon_n$ is a specified tolerance. The first substep is accepted unconditionally. If the condition fails, reduce the substep size (e.g., halve $\\xi_i$) and retry from the same state.\n   - Yield-residual based: accept the substep when the evaluated yield function magnitude at the end satisfies\n     $$\n     f(\\boldsymbol{\\sigma}_{i+1}, \\kappa_{i+1}) \\leq 0 \\quad \\text{or} \\quad \\left| f(\\boldsymbol{\\sigma}_{i+1}, \\kappa_{i+1}) \\right|  \\varepsilon_f,\n     $$\n     where $\\varepsilon_f$ is a specified tolerance. If the condition fails, reduce the substep size and retry. Use the same Newton method for $d\\lambda_i$ in plastic substeps.\n\n5. Start from $\\boldsymbol{\\sigma}_0 = \\boldsymbol{0}$ and $\\kappa_0 = 0$ in each simulation. Use the material parameters in megapascal units: $E$ in $\\mathrm{MPa}$, $\\nu$ dimensionless, $\\alpha$ dimensionless, $\\sigma_{y0}$ in $\\mathrm{MPa}$, and $H$ in $\\mathrm{MPa}$. Use the following tolerances: $\\varepsilon_n = 10^{-3}$ for the stationarity criterion and $\\varepsilon_f = 10^{-6} \\,\\mathrm{MPa}$ for the yield-residual criterion. Use a Newton solver tolerance of $10^{-8} \\,\\mathrm{MPa}$ for solving the consistency equation in each plastic substep, with a maximum of $50$ iterations and step damping if needed. In substepping adaptation, if the substep size becomes smaller than a minimum fraction of $10^{-6}$ of the total increment, force accept to avoid infinite loops.\n\nTest Suite. For each case, the strain increment $\\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{tot}}$ is a symmetric $3 \\times 3$ tensor (dimensionless). Material parameters are as listed for each case. All stresses computed and reported must be in $\\mathrm{MPa}$.\n\n- Case A (general deviatoric loading, expected plastic): $E = 10000 \\,\\mathrm{MPa}$, $\\nu = 0.3$, $\\alpha = 0.2$, $\\sigma_{y0} = 50 \\,\\mathrm{MPa}$, $H = 200 \\,\\mathrm{MPa}$, and\n  $$\n  \\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{tot}} = \\begin{bmatrix}\n  0  0.01  0 \\\\\n  0.01  0  0 \\\\\n  0  0  0\n  \\end{bmatrix}.\n  $$\n\n- Case B (hydrostatic tension, expected plastic): $E = 10000 \\,\\mathrm{MPa}$, $\\nu = 0.3$, $\\alpha = 0.2$, $\\sigma_{y0} = 50 \\,\\mathrm{MPa}$, $H = 200 \\,\\mathrm{MPa}$, and\n  $$\n  \\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{tot}} = \\begin{bmatrix}\n  0.004  0  0 \\\\\n  0  0.004  0 \\\\\n  0  0  0.004\n  \\end{bmatrix}.\n  $$\n\n- Case C (mixed loading, large path): $E = 10000 \\,\\mathrm{MPa}$, $\\nu = 0.3$, $\\alpha = 0.2$, $\\sigma_{y0} = 50 \\,\\mathrm{MPa}$, $H = 200 \\,\\mathrm{MPa}$, and\n  $$\n  \\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{tot}} = \\begin{bmatrix}\n  0.006  0.004  0 \\\\\n  0.004  -0.002  0 \\\\\n  0  0  -0.001\n  \\end{bmatrix}.\n  $$\n\n- Case D (small shear, expected elastic): $E = 10000 \\,\\mathrm{MPa}$, $\\nu = 0.3$, $\\alpha = 0.2$, $\\sigma_{y0} = 50 \\,\\mathrm{MPa}$, $H = 200 \\,\\mathrm{MPa}$, and\n  $$\n  \\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{tot}} = \\begin{bmatrix}\n  0  0.0002  0 \\\\\n  0.0002  0  0 \\\\\n  0  0  0\n  \\end{bmatrix}.\n  $$\n\nRequired outputs. For each case, run the full increment integration twice: once with the stationarity criterion and once with the yield-residual criterion. Record: the number of accepted substeps for stationarity ($N_n$), the number for yield-residual ($N_f$), and the Frobenius norm of the difference between the two final stress tensors in $\\mathrm{MPa}$, $\\|\\boldsymbol{\\sigma}^{(n)} - \\boldsymbol{\\sigma}^{(f)}\\|_F$. Your program should produce a single line of output containing the $12$ values for Cases A–D, in the order\n$$\n\\left[ N_n^{A}, N_f^{A}, \\|\\boldsymbol{\\sigma}^{(n)} - \\boldsymbol{\\sigma}^{(f)}\\|_F^{A}, N_n^{B}, N_f^{B}, \\|\\boldsymbol{\\sigma}^{(n)} - \\boldsymbol{\\sigma}^{(f)}\\|_F^{B}, N_n^{C}, N_f^{C}, \\|\\boldsymbol{\\sigma}^{(n)} - \\boldsymbol{\\sigma}^{(f)}\\|_F^{C}, N_n^{D}, N_f^{D}, \\|\\boldsymbol{\\sigma}^{(n)} - \\boldsymbol{\\sigma}^{(f)}\\|_F^{D} \\right],\n$$\nprinted exactly as a Python list literal with commas separating values. The counts must be integers and the norms must be floating-point numbers in $\\mathrm{MPa}$.", "solution": "The problem is assessed as valid. It is scientifically grounded in the theory of computational plasticity, is well-posed with all necessary parameters and conditions provided, and is expressed in objective, formal language. The problem requires the implementation and comparison of two adaptive substepping strategies for integrating the constitutive response of a Drucker-Prager elastoplastic material. We will proceed with a detailed solution.\n\n### 1. Theoretical Framework\n\nThe problem describes a material model combining linear elasticity with Drucker-Prager plasticity under the assumption of small strains.\n\n**Elastic Behavior**: The relationship between the stress increment tensor $\\Delta\\boldsymbol{\\sigma}$ and the strain increment tensor $\\Delta\\boldsymbol{\\varepsilon}$ is given by a specific, albeit non-standard, isotropic linear elastic law:\n$$\n\\Delta \\boldsymbol{\\sigma} = \\lambda \\, \\mathrm{tr}(\\Delta \\boldsymbol{\\varepsilon}) \\, \\boldsymbol{I} + 2 \\mu \\, \\mathrm{dev}(\\Delta \\boldsymbol{\\varepsilon})\n$$\nwhere $\\boldsymbol{I}$ is the second-order identity tensor, $\\mathrm{tr}(\\cdot)$ is the trace operator, and $\\mathrm{dev}(\\cdot)$ is the deviatoric projection operator. The Lamé parameters $\\lambda$ and $\\mu$ are defined in terms of Young's modulus $E$ and Poisson's ratio $\\nu$ as:\n$$\n\\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)}, \\quad \\mu = \\frac{E}{2(1+\\nu)}\n$$\nThis structure implies that for any second-order tensor $\\boldsymbol{X}$, the fourth-order elasticity tensor $\\mathbf{C}$ acts as $\\mathbf{C}:\\boldsymbol{X} = \\lambda \\, \\mathrm{tr}(\\boldsymbol{X}) \\, \\boldsymbol{I} + 2 \\mu \\, \\mathrm{dev}(\\boldsymbol{X})$.\n\n**Plastic Behavior**: Plastic yielding and flow are governed by the associated Drucker-Prager model with isotropic hardening.\nThe yield function $f$ defines the boundary of the elastic domain:\n$$\nf(\\boldsymbol{\\sigma}, \\kappa) = \\alpha \\, I_1 + \\sqrt{J_2} - \\left(\\sigma_{y0} + H \\kappa \\right)\n$$\nwhere $I_1 = \\mathrm{tr}(\\boldsymbol{\\sigma})$ is the first invariant of the stress tensor, $J_2 = \\frac{1}{2} \\mathrm{dev}(\\boldsymbol{\\sigma}) : \\mathrm{dev}(\\boldsymbol{\\sigma})$ is the second invariant of the deviatoric stress, $\\alpha$ is a material friction parameter, $\\sigma_{y0}$ is the initial yield stress, $H$ is the hardening modulus, and $\\kappa$ is the accumulated plastic strain (internal hardening variable).\n\nFor associated plasticity, the plastic flow direction $\\boldsymbol{m}$ is given by the gradient of the yield function with respect to stress:\n$$\n\\boldsymbol{m}(\\boldsymbol{\\sigma}) = \\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}} = \\alpha \\boldsymbol{I} + \\frac{\\mathrm{dev}(\\boldsymbol{\\sigma})}{2 \\sqrt{J_2}}\n$$\nTo handle the case where $J_2 \\to 0$ (i.e., states on the hydrostatic axis), the term involving $\\sqrt{J_2}$ is regularized by setting the deviatoric component of $\\boldsymbol{m}$ to zero if $J_2$ is below a small numerical threshold. The normalized flow direction is $\\boldsymbol{n}(\\boldsymbol{\\sigma}) = \\boldsymbol{m}(\\boldsymbol{\\sigma}) / \\|\\boldsymbol{m}(\\boldsymbol{\\sigma})\\|_F$, where $\\|\\cdot\\|_F$ is the Frobenius norm.\n\n### 2. Numerical Integration Scheme\n\nThe total strain increment $\\Delta\\boldsymbol{\\varepsilon}_{\\mathrm{tot}}$ is applied over a single load step, which is divided into multiple smaller substeps. The integration within each substep is performed using an explicit-type, constant-direction approximation.\n\n**Substepping**: The total strain increment is partitioned as $\\Delta\\boldsymbol{\\varepsilon}_{\\mathrm{tot}} = \\sum_i \\Delta\\boldsymbol{\\varepsilon}_i$, where $\\Delta\\boldsymbol{\\varepsilon}_i = \\xi_i \\Delta\\boldsymbol{\\varepsilon}_{\\mathrm{tot}}$ and $\\xi_i$ is the size of substep $i$. The state $(\\boldsymbol{\\sigma}_i, \\kappa_i)$ is updated to $(\\boldsymbol{\\sigma}_{i+1}, \\kappa_{i+1})$.\n\n**Stress Update**: For each substep, a trial elastic stress is first computed:\n$$\n\\boldsymbol{\\sigma}^{\\text{trial}}_{i+1} = \\boldsymbol{\\sigma}_i + \\Delta\\boldsymbol{\\sigma}^{\\text{e}}_i = \\boldsymbol{\\sigma}_i + \\lambda \\, \\mathrm{tr}(\\Delta \\boldsymbol{\\varepsilon}_i) \\, \\boldsymbol{I} + 2 \\mu \\, \\mathrm{dev}(\\Delta \\boldsymbol{\\varepsilon}_i)\n$$\nIf $f(\\boldsymbol{\\sigma}^{\\text{trial}}_{i+1}, \\kappa_i) \\leq 0$, the substep is elastic, and $\\boldsymbol{\\sigma}_{i+1} = \\boldsymbol{\\sigma}^{\\text{trial}}_{i+1}$, $\\kappa_{i+1} = \\kappa_i$.\n\nIf $f(\\boldsymbol{\\sigma}^{\\text{trial}}_{i+1}, \\kappa_i)  0$, the substep is plastic. A plastic correction is required. The constant-direction approximation freezes the flow direction $\\boldsymbol{m}_i = \\boldsymbol{m}(\\boldsymbol{\\sigma}_i)$ at the beginning of the substep. The final stress is given by:\n$$\n\\boldsymbol{\\sigma}_{i+1} = \\boldsymbol{\\sigma}^{\\text{trial}}_{i+1} - d\\lambda_i \\left( \\mathbf{C} : \\boldsymbol{m}_i \\right)\n$$\nwhere $d\\lambda_i$ is the plastic multiplier increment for the substep, and the term $\\mathbf{C} : \\boldsymbol{m}_i$ is specified as:\n$$\n\\mathbf{C} : \\boldsymbol{m}_i = \\lambda \\, \\mathrm{tr}(\\boldsymbol{m}_i) \\, \\boldsymbol{I} + 2 \\mu \\, \\mathrm{dev}(\\boldsymbol{m}_i)\n$$\nThe hardening variable is updated as $\\kappa_{i+1} = \\kappa_i + d\\lambda_i$. The unknown $d\\lambda_i$ is found by enforcing the consistency condition $f(\\boldsymbol{\\sigma}_{i+1}, \\kappa_{i+1}) = 0$. This forms a scalar nonlinear equation for $d\\lambda_i$, which we solve using a Newton-Raphson method. The iterative update for $d\\lambda_i$ is:\n$$\nd\\lambda_i^{(k+1)} = d\\lambda_i^{(k)} - \\frac{g(d\\lambda_i^{(k)})}{g'(d\\lambda_i^{(k)})}\n$$\nwhere $g(d\\lambda_i) = f(\\boldsymbol{\\sigma}_{i+1}(d\\lambda_i), \\kappa_{i+1}(d\\lambda_i))$ and $g'(d\\lambda_i) = \\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}}\\Big|_{\\boldsymbol{\\sigma}_{i+1}} : \\frac{d\\boldsymbol{\\sigma}_{i+1}}{d(d\\lambda_i)} + \\frac{\\partial f}{\\partial \\kappa}\\frac{d\\kappa_{i+1}}{d(d\\lambda_i)} = -\\boldsymbol{m}(\\boldsymbol{\\sigma}_{i+1}) : (\\mathbf{C}:\\boldsymbol{m}_i) - H$.\n\n### 3. Adaptive Substep Control\n\nTwo criteria for accepting a completed substep are implemented and compared. If a substep is rejected, its size $\\xi_i$ is halved, and the calculation is retried from state $(\\boldsymbol{\\sigma}_i, \\kappa_i)$. A substep is forcibly accepted if its size falls below a minimum threshold ($10^{-6}$ of the total increment) to prevent infinite loops.\n\n**1. Stationarity of Flow Direction**: A substep is accepted if the plastic flow direction does not change significantly. This is measured by the Frobenius norm of the difference in the normalized flow direction at the beginning and end of the substep.\n$$\n\\left\\|\\boldsymbol{n}_{i+1} - \\boldsymbol{n}_{i} \\right\\|_F  \\varepsilon_n\n$$\nwhere $\\boldsymbol{n}_i = \\boldsymbol{n}(\\boldsymbol{\\sigma}_i)$, $\\boldsymbol{n}_{i+1} = \\boldsymbol{n}(\\boldsymbol{\\sigma}_{i+1})$, and the tolerance is $\\varepsilon_n = 10^{-3}$. The very first substep of the simulation is accepted unconditionally.\n\n**2. Yield-Residual Based**: A substep is accepted if the final state is elastic or if the final stress state lies sufficiently close to the yield surface.\n$$\nf(\\boldsymbol{\\sigma}_{i+1}, \\kappa_{i+1}) \\leq 0 \\quad \\text{or} \\quad \\left| f(\\boldsymbol{\\sigma}_{i+1}, \\kappa_{i+1}) \\right|  \\varepsilon_f\n$$\nThe tolerance is $\\varepsilon_f = 10^{-6} \\, \\mathrm{MPa}$.\n\n### 4. Simulation Execution\n\nFor each test case, the material and numerical parameters specified in the problem are initialized. The simulation starts from a zero-stress, zero-hardening state ($\\boldsymbol{\\sigma}_0 = \\boldsymbol{0}$, $\\kappa_0=0$). The integration process is executed twice: once using the stationarity criterion and a second time using the yield-residual criterion. The number of accepted substeps ($N_n$, $N_f$) and the Frobenius norm of the difference between the final stress tensors, $\\|\\boldsymbol{\\sigma}^{(n)} - \\boldsymbol{\\sigma}^{(f)}\\|_F$, are recorded for each case. The results from all cases are then aggregated into a single list for the final output.", "answer": "```python\nimport numpy as np\n\n# A small value for J2 regularization to prevent division by zero\nJ2_REG = 1e-20  # MPa^2\n\n# ---------- Tensor and Constitutive Utilities ----------\n\ndef dev(tensor):\n    \"\"\"Computes the deviatoric part of a 3x3 tensor.\"\"\"\n    return tensor - (1/3) * np.trace(tensor) * np.eye(3)\n\ndef lame_lambda(E, nu):\n    \"\"\"Calculates Lamé's first parameter.\"\"\"\n    return (E * nu) / ((1 + nu) * (1 - 2 * nu))\n\ndef lame_mu(E, nu):\n    \"\"\"Calculates Lamé's second parameter (shear modulus).\"\"\"\n    return E / (2 * (1 + nu))\n\ndef elastic_stress_inc(deps, lam, mu):\n    \"\"\"\n    Calculates the elastic stress increment based on the problem's specific formula.\n    Δσ = λ tr(Δε) I + 2μ dev(Δε)\n    \"\"\"\n    tr_deps = np.trace(deps)\n    dev_deps = dev(deps)\n    return lam * tr_deps * np.eye(3) + 2 * mu * dev_deps\n\ndef C_colon_tensor(tensor, lam, mu):\n    \"\"\"\n    Applies the constitutive operator to a second-order tensor, following the problem's definition.\n    C:T = λ tr(T) I + 2μ dev(T)\n    \"\"\"\n    return lam * np.trace(tensor) * np.eye(3) + 2 * mu * dev(tensor)\n\n# ---------- Drucker-Prager Model Functions ----------\n\ndef get_invariants(sigma):\n    \"\"\"Computes stress invariants I1 and J2.\"\"\"\n    I1 = np.trace(sigma)\n    s = dev(sigma)\n    J2 = 0.5 * np.sum(s * s)\n    return I1, J2\n\ndef yield_function(sigma, kappa, alpha, sig_y0, H):\n    \"\"\"Computes the Drucker-Prager yield function value.\"\"\"\n    I1, J2 = get_invariants(sigma)\n    sqrt_J2 = np.sqrt(J2)\n    return alpha * I1 + sqrt_J2 - (sig_y0 + H * kappa)\n\ndef flow_direction_m(sigma, alpha):\n    \"\"\"Computes the plastic flow direction m = ∂f/∂σ with regularization.\"\"\"\n    s = dev(sigma)\n    J2 = 0.5 * np.sum(s * s)\n    if J2  J2_REG:\n        # For states on/near hydrostatic axis, deviatoric part of flow is zero\n        dev_m_term = np.zeros((3, 3))\n    else:\n        dev_m_term = s / (2 * np.sqrt(J2))\n    return alpha * np.eye(3) + dev_m_term\n\ndef normalized_flow_direction_n(sigma, alpha):\n    \"\"\"Computes the normalized plastic flow direction n.\"\"\"\n    m = flow_direction_m(sigma, alpha)\n    norm_m = np.linalg.norm(m, 'fro')\n    if norm_m  1e-12: # Avoid division by zero if m is effectively zero\n        return np.zeros((3,3))\n    return m / norm_m\n\n# ---------- Newton Solver for Plastic Multiplier ----------\n\ndef solve_d_lambda(sigma_trial, kappa_i, m_i, params):\n    \"\"\"\n    Solves for the plastic multiplier increment d_lambda using Newton's method.\n    \"\"\"\n    lam, mu, alpha, sig_y0, H = params['lam'], params['mu'], params['alpha'], params['sig_y0'], params['H']\n    newton_tol = params['newton_tol']\n    max_iter = params['newton_max_iter']\n\n    C_m = C_colon_tensor(m_i, lam, mu)\n    d_lambda = 0.0\n\n    for _ in range(max_iter):\n        sigma_k = sigma_trial - d_lambda * C_m\n        kappa_k = kappa_i + d_lambda\n\n        # Calculate residual g(d_lambda)\n        g = yield_function(sigma_k, kappa_k, alpha, sig_y0, H)\n\n        if abs(g)  newton_tol:\n            return d_lambda if d_lambda > 0 else 0.0\n\n        # Calculate derivative g'(d_lambda)\n        m_k = flow_direction_m(sigma_k, alpha)\n        g_prime = -np.sum(m_k * C_m) - H\n\n        if abs(g_prime)  1e-12:\n            return d_lambda if d_lambda > 0 else 0.0\n\n        # Newton update with simple line search/damping\n        delta_d_lambda = -g / g_prime\n        damp = 1.0\n        for _ in range(5):\n            d_lambda_new = d_lambda + damp * delta_d_lambda\n            if d_lambda_new  0: # Multiplier must be non-negative\n                damp /= 2.0\n                continue\n            \n            sigma_new = sigma_trial - d_lambda_new * C_m\n            kappa_new = kappa_i + d_lambda_new\n            g_new = yield_function(sigma_new, kappa_new, alpha, sig_y0, H)\n            \n            if abs(g_new)  abs(g) * (1 - 1e-4 * damp): # Armijo-like condition\n                d_lambda = d_lambda_new\n                break\n            damp /= 2.0\n        else: # Damping failed, so no update this iteration\n            return d_lambda if d_lambda > 0 else 0.0\n\n    return d_lambda if d_lambda > 0 else 0.0\n\n# ---------- Main Substepping Algorithm ----------\n\ndef run_simulation(params, criterion):\n    \"\"\"\n    Runs a single simulation for a total strain increment with adaptive substepping.\n    \"\"\"\n    sigma = np.zeros((3, 3))\n    kappa = 0.0\n    \n    total_strain_inc = params['deps_tot']\n    lam, mu, alpha, sig_y0, H = params['lam'], params['mu'], params['alpha'], params['sig_y0'], params['H']\n    eps_n, eps_f, min_xi_frac = params['eps_n'], params['eps_f'], params['min_xi_frac']\n    \n    accumulated_xi = 0.0\n    substep_count = 0\n\n    while accumulated_xi  1.0 - 1e-9: # Loop until full strain increment is applied\n        xi = 1.0 - accumulated_xi\n        is_first_substep = (substep_count == 0)\n\n        while True: # Substep reduction loop\n            deps_substep = xi * total_strain_inc\n            sigma_trial = sigma + elastic_stress_inc(deps_substep, lam, mu)\n            f_trial = yield_function(sigma_trial, kappa, alpha, sig_y0, H)\n            \n            is_plastic_substep = f_trial > 0\n\n            if is_plastic_substep:\n                m_i = flow_direction_m(sigma, alpha)\n                d_lambda = solve_d_lambda(sigma_trial, kappa, m_i, params)\n                \n                if d_lambda > 0:\n                    C_m = C_colon_tensor(m_i, lam, mu)\n                    sigma_next = sigma_trial - d_lambda * C_m\n                    kappa_next = kappa + d_lambda\n                else: # Newton found no plastic strain, so step is effectively elastic\n                    sigma_next = sigma_trial\n                    kappa_next = kappa\n                    is_plastic_substep = False\n            else: # Elastic substep\n                sigma_next = sigma_trial\n                kappa_next = kappa\n\n            # Substep acceptance check\n            accepted = False\n            if criterion == 'stationarity':\n                if is_first_substep:\n                    accepted = True\n                else:\n                    n_i = normalized_flow_direction_n(sigma, alpha)\n                    n_next = normalized_flow_direction_n(sigma_next, alpha)\n                    norm_diff = np.linalg.norm(n_next - n_i, 'fro')\n                    if norm_diff  eps_n:\n                        accepted = True\n            elif criterion == 'yield_residual':\n                if not is_plastic_substep:\n                    accepted = True\n                else:\n                    f_end = yield_function(sigma_next, kappa_next, alpha, sig_y0, H)\n                    if abs(f_end)  eps_f:\n                        accepted = True\n            \n            if not accepted and xi  min_xi_frac:\n                accepted = True\n                \n            if accepted:\n                sigma = sigma_next\n                kappa = kappa_next\n                accumulated_xi += xi\n                substep_count += 1\n                break\n            else:\n                xi /= 2.0\n                \n    return sigma, substep_count\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    test_cases_spec = {\n        'A': {'deps_tot': np.array([[0.0, 0.01, 0.0], [0.01, 0.0, 0.0], [0.0, 0.0, 0.0]])},\n        'B': {'deps_tot': np.array([[0.004, 0.0, 0.0], [0.0, 0.004, 0.0], [0.0, 0.0, 0.004]])},\n        'C': {'deps_tot': np.array([[0.006, 0.004, 0.0], [0.004, -0.002, 0.0], [0.0, 0.0, -0.001]])},\n        'D': {'deps_tot': np.array([[0.0, 0.0002, 0.0], [0.0002, 0.0, 0.0], [0.0, 0.0, 0.0]])}\n    }\n    \n    base_material_params = {'E': 10000.0, 'nu': 0.3, 'alpha': 0.2, 'sig_y0': 50.0, 'H': 200.0}\n    common_numerical_params = {\n        'eps_n': 1e-3, 'eps_f': 1e-6, 'newton_tol': 1e-8,\n        'newton_max_iter': 50, 'min_xi_frac': 1e-6\n    }\n\n    results = []\n    case_order = ['A', 'B', 'C', 'D']\n\n    for case_id in case_order:\n        params = base_material_params.copy()\n        params.update(test_cases_spec[case_id])\n        params.update(common_numerical_params)\n        \n        params['lam'] = lame_lambda(params['E'], params['nu'])\n        params['mu'] = lame_mu(params['E'], params['nu'])\n\n        sigma_n, N_n = run_simulation(params, 'stationarity')\n        sigma_f, N_f = run_simulation(params, 'yield_residual')\n\n        stress_diff_norm = np.linalg.norm(sigma_n - sigma_f, 'fro')\n\n        results.extend([N_n, N_f, stress_diff_norm])\n        \n    print(f\"[{','.join(f'{v:.6f}' if isinstance(v, float) else str(v) for v in results)}]\")\n\nsolve()\n```", "id": "3566154"}, {"introduction": "Beyond simply ensuring each substep is accurate, advanced strategies aim to distribute computational effort intelligently over the entire load path. Using the Modified Cam-Clay model, this problem explores a path-aware partitioning scheme where substep density is increased in regions of high plastic \"activity,\" measured by the norm of the yield function's gradient. By comparing the accuracy of this adaptive scheme against a simple uniform partition, you will appreciate how non-uniform stepping can lead to more efficient and accurate predictions of path-dependent quantities like the final plastic strain tensor. [@problem_id:3566113]", "problem": "Consider small-strain elastoplastic integration with an associated flow rule for a soil described by the Modified Cam-Clay (MCC) yield function. Let the Cauchy stress tensor be denoted by $\\boldsymbol{\\sigma} \\in \\mathbb{R}^{3 \\times 3}$, with the mean stress $p = \\tfrac{1}{3} I_1 = \\tfrac{1}{3} \\operatorname{tr}(\\boldsymbol{\\sigma})$ and the second invariant of the deviatoric stress $J_2 = \\tfrac{1}{2} \\boldsymbol{s}:\\boldsymbol{s}$, where $\\boldsymbol{s} = \\boldsymbol{\\sigma} - p \\boldsymbol{I}$ and $\\boldsymbol{I}$ is the identity tensor. Define the invariant $q = \\sqrt{3 J_2}$, and consider the Modified Cam-Clay (MCC) yield function $f(p,q,p_c) = \\dfrac{q^2}{M^2} + p(p - p_c)$, where $M  0$ is the slope of the critical state line in $p$-$q$ space and $p_c  0$ is the preconsolidation pressure. Assume an associated flow rule with plastic potential equal to the yield function, which implies $\\Delta \\boldsymbol{\\varepsilon}^p \\propto \\nabla_{\\boldsymbol{\\sigma}} f(\\boldsymbol{\\sigma})$, and the plastic strain increment direction is given by $\\dfrac{\\Delta \\boldsymbol{\\varepsilon}^p}{\\|\\Delta \\boldsymbol{\\varepsilon}^p\\|}$.\n\nYou will study a prescribed stress-path constrained to remain exactly on the yield surface, parameterized by $t \\in [0,1]$:\n- The mean stress is $p(t) = p_c \\sin^2\\left(\\dfrac{\\pi t}{2}\\right)$.\n- The deviatoric invariant is $q(t) = M \\sqrt{-p(t) \\left(p(t) - p_c\\right)}$.\n- The deviatoric direction rotates as $\\boldsymbol{s}_{\\mathrm{dir}}(t) = \\cos\\left(\\theta(t)\\right) \\, \\boldsymbol{E}_1 + \\sin\\left(\\theta(t)\\right) \\, \\boldsymbol{E}_2$, where $\\boldsymbol{E}_1 = \\dfrac{1}{\\sqrt{3}} \\operatorname{diag}(2,-1,-1)$ and $\\boldsymbol{E}_2$ is the symmetric shear tensor with components $(\\boldsymbol{E}_2)_{12} = (\\boldsymbol{E}_2)_{21} = 1$ and zeros elsewhere. Choose $\\theta(t)$ according to the specific test case. Construct the deviatoric stress as $\\boldsymbol{s}(t) = \\sqrt{J_2(t)} \\, \\boldsymbol{s}_{\\mathrm{dir}}(t)$, where $J_2(t) = \\dfrac{q(t)^2}{3}$, and the full stress $\\boldsymbol{\\sigma}(t) = p(t) \\boldsymbol{I} + \\boldsymbol{s}(t)$.\n\nStarting from the core definitions of invariants, the MCC yield function, and the associated flow rule, derive the gradient $\\nabla_{\\boldsymbol{\\sigma}} f(\\boldsymbol{\\sigma}(t))$ and its Frobenius norm $\\left\\|\\nabla_{\\boldsymbol{\\sigma}} f(\\boldsymbol{\\sigma}(t))\\right\\|_F$ along the path. Then, propose and implement a substep partitioning of the parameter $t \\in [0,1]$ that aligns with the path of maximal gradient norm, in the following sense:\n- Let $w(t) = \\left\\|\\nabla_{\\boldsymbol{\\sigma}} f(\\boldsymbol{\\sigma}(t))\\right\\|_F$ be a nonnegative weight function over $[0,1]$.\n- Given a fixed number of substeps $N$, define substep boundaries $0 = t_0  t_1  \\dots  t_N = 1$ such that each subinterval carries equal measure of the cumulative weight $\\int_0^{t_k} w(\\tau) \\, d\\tau$, i.e., $\\int_0^{t_k} w(\\tau) \\, d\\tau = \\dfrac{k}{N} \\int_0^1 w(\\tau) \\, d\\tau$ for $k = 0,1,\\dots,N$.\n\nFor each partition (uniform and the proposed gradient-norm-aligned partition), approximate the net plastic strain direction over the path by midpoint quadrature:\n- On each subinterval $[t_{k-1}, t_k]$, evaluate $\\nabla_{\\boldsymbol{\\sigma}} f$ at $t_{k-1/2} = \\dfrac{t_{k-1} + t_k}{2}$, form the incremental contribution $\\boldsymbol{d}_k = \\nabla_{\\boldsymbol{\\sigma}} f\\left(\\boldsymbol{\\sigma}(t_{k-1/2})\\right) \\, \\Delta t_k$ with $\\Delta t_k = t_k - t_{k-1}$, then sum $\\boldsymbol{D} = \\sum_{k=1}^N \\boldsymbol{d}_k$. The approximated direction is $\\widehat{\\boldsymbol{D}} = \\dfrac{\\boldsymbol{D}}{\\|\\boldsymbol{D}\\|_F}$, where $\\|\\cdot\\|_F$ is the Frobenius norm on $\\mathbb{R}^{3 \\times 3}$.\n- Compute a high-fidelity reference direction $\\widehat{\\boldsymbol{D}}_{\\mathrm{ref}}$ using a fine partition of $[0,1]$ into $N_{\\mathrm{ref}}$ uniform subintervals with midpoint quadrature (take $N_{\\mathrm{ref}} = 5000$).\n\nDefine the direction error for an approximation $\\widehat{\\boldsymbol{D}}$ as $e = \\left\\|\\widehat{\\boldsymbol{D}} - \\widehat{\\boldsymbol{D}}_{\\mathrm{ref}}\\right\\|_F$.\n\nTest Suite:\n- Case $1$: $M = 1.2$, $p_c = 250$, $N = 12$, $\\theta(t) = \\dfrac{\\pi}{2} t$ (deviatoric direction rotates). Angles must be in radians.\n- Case $2$: $M = 1.2$, $p_c = 250$, $N = 4$, $\\theta(t) = \\dfrac{\\pi}{2} t$ (coarser stepping). Angles must be in radians.\n- Case $3$: $M = 0.9$, $p_c = 250$, $N = 12$, $\\theta(t) = \\dfrac{\\pi}{4}$ (constant deviatoric direction). Angles must be in radians.\n\nFor each case, compute two errors: $e_{\\mathrm{unif}}$ for uniform substeps $t_k = \\dfrac{k}{N}$, and $e_{\\mathrm{grad}}$ for the gradient-norm-aligned substeps defined by equal cumulative weight. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets of the form $[e_{\\mathrm{unif,1}}, e_{\\mathrm{grad,1}}, e_{\\mathrm{unif,2}}, e_{\\mathrm{grad,2}}, e_{\\mathrm{unif,3}}, e_{\\mathrm{grad,3}}]$, where each entry is a floating-point number. No physical units are required in the output; angles must be in radians.", "solution": "The problem requires the comparison of two numerical integration schemes for determining the net plastic strain direction in a Modified Cam-Clay (MCC) material subjected to a prescribed stress path. The first scheme uses uniform subintervals, while the second employs a physically-motivated partitioning strategy that aligns subintervals with the magnitude of the yield surface gradient. The core of the task involves deriving the gradient, defining the partitioning schemes, performing the numerical integration, and quantifying the accuracy of each scheme against a high-fidelity reference solution.\n\nThe solution proceeds in four principal steps:\n1.  Analytical derivation of the gradient of the MCC yield function, $\\nabla_{\\boldsymbol{\\sigma}} f$, which is proportional to the plastic strain increment direction.\n2.  Analytical derivation of the Frobenius norm of this gradient, $\\left\\|\\nabla_{\\boldsymbol{\\sigma}} f\\right\\|_F$, which serves as a weight function $w(t)$ for the adaptive partitioning.\n3.  Specification of the two partitioning schemes: a uniform partition and a gradient-norm-aligned partition. The latter is constructed by ensuring each subinterval contributes equally to the total cumulative weight, $\\int w(t) dt$.\n4.  Implementation of a numerical quadrature (midpoint rule) to approximate the integrated plastic strain direction vector for each scheme and calculation of the approximation error relative to a reference solution.\n\nLet us begin with the necessary derivations.\n\n**1. Derivation of the Plastic Flow Direction Vector**\n\nThe plastic flow is governed by an associated flow rule, meaning the increment of plastic strain, $\\Delta\\boldsymbol{\\varepsilon}^p$, is normal to the yield surface $f(\\boldsymbol{\\sigma}) = 0$. The direction of plastic flow is therefore given by the gradient of the yield function with respect to stress, $\\nabla_{\\boldsymbol{\\sigma}} f$. The yield function is given as $f(p,q,p_c) = \\dfrac{q^2}{M^2} + p(p - p_c)$. Since $f$ is expressed in terms of stress invariants $p$ and $q$, we use the chain rule:\n$$\n\\nabla_{\\boldsymbol{\\sigma}} f = \\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}} = \\frac{\\partial f}{\\partial p} \\frac{\\partial p}{\\partial \\boldsymbol{\\sigma}} + \\frac{\\partial f}{\\partial q} \\frac{\\partial q}{\\partial \\boldsymbol{\\sigma}}\n$$\nThe partial derivatives of $f$ with respect to the invariants are:\n$$\n\\frac{\\partial f}{\\partial p} = 2p - p_c \\quad \\text{and} \\quad \\frac{\\partial f}{\\partial q} = \\frac{2q}{M^2}\n$$\nThe derivatives of the invariants with respect to the stress tensor $\\boldsymbol{\\sigma}$ are standard results in continuum mechanics. For the mean stress $p = \\frac{1}{3}\\operatorname{tr}(\\boldsymbol{\\sigma}) = \\frac{1}{3}\\boldsymbol{I}:\\boldsymbol{\\sigma}$, we have:\n$$\n\\frac{\\partial p}{\\partial \\boldsymbol{\\sigma}} = \\frac{1}{3}\\boldsymbol{I}\n$$\nFor the deviatoric invariant $q = \\sqrt{3J_2}$, where $J_2 = \\frac{1}{2}\\boldsymbol{s}:\\boldsymbol{s}$ and $\\boldsymbol{s} = \\boldsymbol{\\sigma} - p\\boldsymbol{I}$ is the deviatoric stress, we find:\n$$\n\\frac{\\partial q}{\\partial \\boldsymbol{\\sigma}} = \\frac{\\partial q}{\\partial J_2} \\frac{\\partial J_2}{\\partial \\boldsymbol{s}} : \\frac{\\partial \\boldsymbol{s}}{\\partial \\boldsymbol{\\sigma}} = \\left(\\frac{\\sqrt{3}}{2\\sqrt{J_2}}\\right) (\\boldsymbol{s}) : \\left(\\mathbb{I} - \\frac{1}{3}\\boldsymbol{I} \\otimes \\boldsymbol{I}\\right) = \\frac{3}{2q} \\boldsymbol{s}\n$$\nwhere $\\mathbb{I}$ is the fourth-order symmetric identity tensor and we used $\\operatorname{tr}(\\boldsymbol{s}) = 0$. This result is valid for $q \\neq 0$.\n\nSubstituting these components back into the chain rule expression yields the gradient:\n$$\n\\nabla_{\\boldsymbol{\\sigma}} f = (2p - p_c)\\left(\\frac{1}{3}\\boldsymbol{I}\\right) + \\left(\\frac{2q}{M^2}\\right)\\left(\\frac{3}{2q}\\boldsymbol{s}\\right) = \\frac{2p - p_c}{3}\\boldsymbol{I} + \\frac{3}{M^2}\\boldsymbol{s}\n$$\nThis tensor, $\\nabla_{\\boldsymbol{\\sigma}} f$, represents the direction of the plastic strain increment at a given stress state $\\boldsymbol{\\sigma}$.\n\n**2. Derivation of the Gradient Norm (Weight Function)**\n\nThe proposed substepping strategy uses the magnitude of the gradient vector, quantified by its Frobenius norm, as a weight function $w(t) = \\left\\|\\nabla_{\\boldsymbol{\\sigma}} f(\\boldsymbol{\\sigma}(t))\\right\\|_F$. The gradient is a sum of two orthogonal tensors: a volumetric part proportional to the identity tensor $\\boldsymbol{I}$ and a deviatoric part proportional to $\\boldsymbol{s}$. Their orthogonality is confirmed by the Frobenius inner product: $\\boldsymbol{I}:\\boldsymbol{s} = \\operatorname{tr}(\\boldsymbol{s}) = 0$.\nThe squared Frobenius norm is therefore the sum of the squared norms of the two parts:\n$$\n\\left\\|\\nabla_{\\boldsymbol{\\sigma}} f\\right\\|_F^2 = \\left\\|\\frac{2p - p_c}{3}\\boldsymbol{I}\\right\\|_F^2 + \\left\\|\\frac{3}{M^2}\\boldsymbol{s}\\right\\|_F^2 = \\left(\\frac{2p - p_c}{3}\\right)^2 \\|\\boldsymbol{I}\\|_F^2 + \\left(\\frac{3}{M^2}\\right)^2 \\|\\boldsymbol{s}\\|_F^2\n$$\nThe norms of the basis tensors are $\\|\\boldsymbol{I}\\|_F^2 = 3$ and $\\|\\boldsymbol{s}\\|_F^2 = \\boldsymbol{s}:\\boldsymbol{s} = 2J_2 = \\frac{2}{3}q^2$. Substituting these gives:\n$$\n\\left\\|\\nabla_{\\boldsymbol{\\sigma}} f\\right\\|_F^2 = \\frac{(2p - p_c)^2}{9} \\cdot 3 + \\frac{9}{M^4} \\cdot \\frac{2}{3}q^2 = \\frac{(2p - p_c)^2}{3} + \\frac{6q^2}{M^4}\n$$\nNow, we express this norm as a function of the parameter $t$ by substituting the prescribed stress path definitions:\n$p(t) = p_c \\sin^2\\left(\\frac{\\pi t}{2}\\right)$\n$q(t) = M \\sqrt{p(t)(p_c - p(t))} = M p_c \\sin\\left(\\frac{\\pi t}{2}\\right)\\cos\\left(\\frac{\\pi t}{2}\\right) = \\frac{M p_c}{2}\\sin(\\pi t)$\nThe terms in the norm expression become:\n$2p(t) - p_c = 2 p_c \\sin^2\\left(\\frac{\\pi t}{2}\\right) - p_c = -p_c\\left(1 - 2\\sin^2\\left(\\frac{\\pi t}{2}\\right)\\right) = -p_c \\cos(\\pi t)$\n$q(t)^2 = \\frac{M^2 p_c^2}{4}\\sin^2(\\pi t)$\nSubstituting these into the norm equation provides the final expression for the weight function squared:\n$$\nw(t)^2 = \\left\\|\\nabla_{\\boldsymbol{\\sigma}} f(t)\\right\\|_F^2 = \\frac{(-p_c \\cos(\\pi t))^2}{3} + \\frac{6}{M^4}\\left(\\frac{M^2 p_c^2}{4}\\sin^2(\\pi t)\\right) = \\frac{p_c^2 \\cos^2(\\pi t)}{3} + \\frac{3 p_c^2}{2M^2}\\sin^2(\\pi t)\n$$\nThus, the weight function is $w(t) = p_c \\sqrt{\\frac{1}{3}\\cos^2(\\pi t) + \\frac{3}{2M^2}\\sin^2(\\pi t)}$.\n\n**3. Substep Partitioning Schemes**\n\nGiven $N$ substeps, we define a partition $0 = t_0  t_1  \\dots  t_N = 1$.\n\n- **Uniform Partition**: This is the simplest scheme, where each subinterval has equal width in the parameter $t$. The nodes are given by $t_k = \\frac{k}{N}$ for $k = 0, 1, \\dots, N$.\n\n- **Gradient-Norm-Aligned Partition**: This scheme aims to distribute the numerical effort according to the \"activity\" of the plastic flow, measured by $w(t)$. The partition nodes $t_k$ are chosen such that each subinterval $[t_{k-1}, t_k]$ contains an equal amount of the total integrated weight. Let $H(t) = \\int_0^t w(\\tau) d\\tau$ be the cumulative weight function. The condition is:\n$$\nH(t_k) = \\frac{k}{N} H(1) \\quad \\text{for } k = 1, \\dots, N\n$$\nSince $H(t)$ does not have a simple closed-form antiderivative, we must solve for each $t_k$ numerically. For a given $k$, we find the root of the equation $g(t) = H(t) - \\frac{k}{N}H(1) = 0$. This is achieved by first computing the total integral $H(1) = \\int_0^1 w(\\tau) d\\tau$ using numerical quadrature (e.g., `scipy.integrate.quad`) and then using a root-finding algorithm (e.g., `scipy.optimize.brentq`) to find each $t_k$ in the interval $(t_{k-1}, 1]$.\n\n**4. Numerical Approximation and Error Metric**\n\nThe net plastic strain direction over the path is proportional to the integral $\\int_0^1 \\nabla_{\\boldsymbol{\\sigma}} f(\\boldsymbol{\\sigma}(t)) dt$. We approximate this integral, denoted by the tensor $\\boldsymbol{D}$, using a midpoint quadrature rule over a given partition $\\{t_k\\}_{k=0}^N$:\n$$\n\\boldsymbol{D} = \\sum_{k=1}^N \\nabla_{\\boldsymbol{\\sigma}} f\\left(\\boldsymbol{\\sigma}(t_{k-1/2})\\right) \\Delta t_k\n$$\nwhere $\\Delta t_k = t_k - t_{k-1}$ and $t_{k-1/2} = \\frac{t_{k-1} + t_k}{2}$. The final approximated direction is the normalized tensor $\\widehat{\\boldsymbol{D}} = \\frac{\\boldsymbol{D}}{\\|\\boldsymbol{D}\\|_F}$.\n\nTo assess accuracy, a high-fidelity reference direction, $\\widehat{\\boldsymbol{D}}_{\\mathrm{ref}}$, is computed using the same midpoint rule but on a very fine uniform partition of $N_{\\mathrm{ref}} = 5000$ subintervals. The error of an approximation $\\widehat{\\boldsymbol{D}}$ is then calculated as the Frobenius norm of the difference:\n$$\ne = \\left\\|\\widehat{\\boldsymbol{D}} - \\widehat{\\boldsymbol{D}}_{\\mathrm{ref}}\\right\\|_F\n$$\nThis procedure is applied to both the uniform and gradient-norm-aligned partitions for each test case, yielding the errors $e_{\\mathrm{unif}}$ and $e_{\\mathrm{grad}}$ respectively. The expectation is that $e_{\\mathrm{grad}}  e_{\\mathrm{unif}}$, demonstrating the superiority of the adaptive scheme.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate, optimize\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing substepping strategies for plasticity\n    integration with the Modified Cam-Clay model.\n    \"\"\"\n\n    # --- Constants and Basis Tensors ---\n    E1 = (1 / np.sqrt(3)) * np.diag([2.0, -1.0, -1.0])\n    E2 = np.array([[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 0.0]])\n    ID_TENSOR = np.eye(3)\n    N_REF = 5000\n\n    # --- Path-dependent Helper Functions ---\n    def p_func(t, pc):\n        \"\"\"Mean stress p as a function of t.\"\"\"\n        return pc * np.sin(0.5 * np.pi * t)**2\n\n    def q_func(t, M, pc):\n        \"\"\"Deviatoric invariant q as a function of t.\"\"\"\n        return (M * pc / 2.0) * np.sin(np.pi * t)\n\n    def theta_func(t, theta_type):\n        \"\"\"Deviatoric rotation angle theta as a function of t.\"\"\"\n        if theta_type == 'pi/2*t':\n            return 0.5 * np.pi * t\n        elif theta_type == 'pi/4':\n            # This is a constant function of t\n            return 0.25 * np.pi\n        else:\n            raise ValueError(f\"Unknown theta function type: {theta_type}\")\n\n    def get_stress_and_gradient(t, M, pc, theta_type):\n        \"\"\"\n        Computes stress tensor and gradient of yield function at a given t.\n        \"\"\"\n        p_val = p_func(t, pc)\n        q_val = q_func(t, M, pc)\n        \n        # Deviatoric stress s\n        theta_val = theta_func(t, theta_type)\n        s_dir_val = np.cos(theta_val) * E1 + np.sin(theta_val) * E2\n        s_val = (q_val / np.sqrt(3.0)) * s_dir_val\n        \n        # Gradient of yield function\n        grad_f = ((2.0 * p_val - pc) / 3.0) * ID_TENSOR + (3.0 / M**2) * s_val\n        \n        return grad_f\n\n    def w_func(t, M, pc):\n        \"\"\"\n        Weight function: Frobenius norm of the yield function gradient.\n        This is the analytical simplified form.\n        \"\"\"\n        if -1e-9  t  1e-9 or 1-1e-9  t  1+1e-9:\n             return pc / np.sqrt(3.0)\n\n        cos_pit = np.cos(np.pi * t)\n        sin_pit = np.sin(np.pi * t)\n        \n        term1 = cos_pit**2 / 3.0\n        term2 = (3.0 / (2.0 * M**2)) * sin_pit**2\n        \n        return pc * np.sqrt(term1 + term2)\n\n    def compute_D_hat(partition, M, pc, theta_type):\n        \"\"\"\n        Approximates the integrated plastic strain direction tensor using\n        midpoint quadrature over a given partition.\n        \"\"\"\n        D_sum = np.zeros((3, 3))\n        for k in range(1, len(partition)):\n            t_k_minus_1 = partition[k-1]\n            t_k = partition[k]\n            dt_k = t_k - t_k_minus_1\n            t_mid = 0.5 * (t_k_minus_1 + t_k)\n            \n            grad_mid = get_stress_and_gradient(t_mid, M, pc, theta_type)\n            D_sum += grad_mid * dt_k\n            \n        D_norm = np.linalg.norm(D_sum, 'fro')\n        if D_norm  1e-15:\n            # This case should not be reached with the given paths\n            return D_sum\n        return D_sum / D_norm\n\n    # --- Test Suite ---\n    test_cases = [\n        {'M': 1.2, 'pc': 250.0, 'N': 12, 'theta_type': 'pi/2*t'},\n        {'M': 1.2, 'pc': 250.0, 'N': 4,  'theta_type': 'pi/2*t'},\n        {'M': 0.9, 'pc': 250.0, 'N': 12, 'theta_type': 'pi/4'}\n    ]\n    \n    results = []\n    \n    for case_params in test_cases:\n        M = case_params['M']\n        pc = case_params['pc']\n        N = case_params['N']\n        theta_type = case_params['theta_type']\n\n        # 1. Compute Reference Solution\n        t_ref_partition = np.linspace(0.0, 1.0, N_REF + 1)\n        D_hat_ref = compute_D_hat(t_ref_partition, M, pc, theta_type)\n\n        # 2. Uniform Partition Calculation\n        t_unif_partition = np.linspace(0.0, 1.0, N + 1)\n        D_hat_unif = compute_D_hat(t_unif_partition, M, pc, theta_type)\n        error_unif = np.linalg.norm(D_hat_unif - D_hat_ref, 'fro')\n        results.append(error_unif)\n        \n        # 3. Gradient-Norm-Aligned Partition Calculation\n        integrand = lambda t: w_func(t, M, pc)\n        total_weight, _ = integrate.quad(integrand, 0, 1)\n\n        t_grad_partition = [0.0]\n        \n        def root_func(t, target_weight):\n            res, _ = integrate.quad(integrand, 0.0, t)\n            return res - target_weight\n        \n        for k in range(1, N):\n            target_weight_k = (k / N) * total_weight\n            # The root must be between the last point and 1\n            t_k = optimize.brentq(root_func, t_grad_partition[-1], 1.0, args=(target_weight_k,))\n            t_grad_partition.append(t_k)\n            \n        t_grad_partition.append(1.0)\n        t_grad_partition = np.array(t_grad_partition)\n\n        D_hat_grad = compute_D_hat(t_grad_partition, M, pc, theta_type)\n        error_grad = np.linalg.norm(D_hat_grad - D_hat_ref, 'fro')\n        results.append(error_grad)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```", "id": "3566113"}]}