{"hands_on_practices": [{"introduction": "This first exercise grounds our understanding in the most direct measure of equilibrium: the force residual. By calculating the vector difference between the external applied forces and the internal resisting forces for a given displacement state, you will quantify the system's imbalance. This practice [@problem_id:3511080] solidifies the fundamental concept of force-based convergence and is the first step in diagnosing the performance of any iterative solver.", "problem": "Consider a small-strain, quasi-static, two degrees of freedom (DOF) discrete system arising from a finite element discretization in computational geomechanics. Let the nodal displacement vector be $u \\in \\mathbb{R}^{2}$ with components measured in meters, the external nodal force vector be $f_{\\mathrm{ext}} \\in \\mathbb{R}^{2}$ with components measured in Newtons, and the internal nodal force vector be $f_{\\mathrm{int}}(u) \\in \\mathbb{R}^{2}$. Assume linear elastic behavior so that the consistent tangent (stiffness) matrix $K \\in \\mathbb{R}^{2 \\times 2}$ is constant, symmetric, and positive definite, and $f_{\\mathrm{int}}(u) = K u$, with $K$ having entries measured in Newtons per meter. The residual vector associated with Newton’s method in the force-based convergence criterion is defined by $r(u) = f_{\\mathrm{ext}} - f_{\\mathrm{int}}(u)$. The force-based absolute convergence criterion requires that the Euclidean norm $\\|r(u)\\|_{2}$ be less than or equal to a prescribed absolute tolerance $\\tau$ (in Newtons) to consider the iteration converged.\n\nGiven\n$$\nf_{\\mathrm{ext}} = \\begin{bmatrix} 10 \\\\ -5 \\end{bmatrix}, \\quad\nK = \\begin{bmatrix} 100 & 20 \\\\ 20 & 50 \\end{bmatrix}, \\quad\nf_{\\mathrm{int}}(u) = K u, \\quad\nu = \\begin{bmatrix} 0.1 \\\\ -0.2 \\end{bmatrix},\n$$\ncompute $\\|r(u)\\|_{2}$ and assess convergence under the absolute tolerance $\\tau = 10^{-2}$. Express the residual norm in Newtons. In addition, report a binary indicator $c$ defined by $c = 1$ if $\\|r(u)\\|_{2} \\le \\tau$ and $c = 0$ otherwise. Provide your final answer as a row matrix containing the residual norm and the binary indicator, in that order.", "solution": "The problem statement is first subjected to a rigorous validation process.\n\n**Problem Validation**\n\n**Step 1: Extract Givens**\nThe problem provides the following data and definitions:\n- Nodal displacement vector: $u \\in \\mathbb{R}^{2}$, with $u = \\begin{bmatrix} 0.1 \\\\ -0.2 \\end{bmatrix}$ (in meters).\n- External nodal force vector: $f_{\\mathrm{ext}} \\in \\mathbb{R}^{2}$, with $f_{\\mathrm{ext}} = \\begin{bmatrix} 10 \\\\ -5 \\end{bmatrix}$ (in Newtons).\n- Internal nodal force vector: $f_{\\mathrm{int}}(u) \\in \\mathbb{R}^{2}$.\n- Stiffness matrix: $K \\in \\mathbb{R}^{2 \\times 2}$, with $K = \\begin{bmatrix} 100 & 20 \\\\ 20 & 50 \\end{bmatrix}$ (in Newtons per meter).\n- Constitutive relation: $f_{\\mathrm{int}}(u) = K u$.\n- Residual vector: $r(u) = f_{\\mathrm{ext}} - f_{\\mathrm{int}}(u)$.\n- Absolute convergence criterion: $\\|r(u)\\|_{2} \\le \\tau$.\n- Absolute tolerance: $\\tau = 10^{-2}$ (in Newtons).\n- Binary convergence indicator: $c=1$ if $\\|r(u)\\|_{2} \\le \\tau$, and $c=0$ otherwise.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientifically Grounded**: The problem is grounded in the principles of solid mechanics and numerical analysis, specifically the Finite Element Method for a linear elastic system. The definitions of internal force, residual force, and force-based convergence criteria are standard in computational mechanics.\n- **Well-Posed**: The problem is well-posed. All necessary data ($f_{\\mathrm{ext}}$, $K$, $u$, $\\tau$) are provided. The definitions are clear and unambiguous, leading to a unique and computable solution. The units are consistent: $[K][u] = (\\text{N}/\\text{m}) \\cdot \\text{m} = \\text{N}$, which matches the units of $f_{\\mathrm{ext}}$ and $\\tau$. The stiffness matrix $K$ is symmetric. Its leading principal minors are $\\det([100]) = 100 > 0$ and $\\det(K) = (100)(50) - (20)(20) = 5000 - 400 = 4600 > 0$, confirming it is positive definite as stated.\n- **Objective**: The problem is stated in precise, objective mathematical language, free of any subjectivity or ambiguity.\n\n**Step 3: Verdict and Action**\nThe problem is valid as it is scientifically sound, well-posed, and objective. A solution will be derived.\n\n**Solution Derivation**\n\nThe primary objective is to compute the Euclidean norm of the residual vector, $\\|r(u)\\|_{2}$, and subsequently determine the value of the binary convergence indicator, $c$.\n\nFirst, we calculate the internal force vector, $f_{\\mathrm{int}}(u)$, using the given stiffness matrix $K$ and displacement vector $u$.\n$$\nf_{\\mathrm{int}}(u) = K u = \\begin{bmatrix} 100 & 20 \\\\ 20 & 50 \\end{bmatrix} \\begin{bmatrix} 0.1 \\\\ -0.2 \\end{bmatrix}\n$$\nThe matrix-vector multiplication yields:\n$$\nf_{\\mathrm{int}}(u) = \\begin{bmatrix} (100)(0.1) + (20)(-0.2) \\\\ (20)(0.1) + (50)(-0.2) \\end{bmatrix} = \\begin{bmatrix} 10 - 4 \\\\ 2 - 10 \\end{bmatrix} = \\begin{bmatrix} 6 \\\\ -8 \\end{bmatrix}\n$$\nThe units of $f_{\\mathrm{int}}(u)$ are Newtons.\n\nNext, we compute the residual vector, $r(u)$, which is the difference between the external and internal force vectors.\n$$\nr(u) = f_{\\mathrm{ext}} - f_{\\mathrm{int}}(u) = \\begin{bmatrix} 10 \\\\ -5 \\end{bmatrix} - \\begin{bmatrix} 6 \\\\ -8 \\end{bmatrix} = \\begin{bmatrix} 10 - 6 \\\\ -5 - (-8) \\end{bmatrix} = \\begin{bmatrix} 4 \\\\ 3 \\end{bmatrix}\n$$\nThe units of $r(u)$ are Newtons.\n\nNow, we compute the Euclidean norm (or $L_2$-norm) of the residual vector, $\\|r(u)\\|_{2}$. For a vector $v = \\begin{bmatrix} v_1 \\\\ v_2 \\end{bmatrix}$, its Euclidean norm is $\\|v\\|_2 = \\sqrt{v_1^2 + v_2^2}$.\n$$\n\\|r(u)\\|_{2} = \\left\\|\\begin{bmatrix} 4 \\\\ 3 \\end{bmatrix}\\right\\|_{2} = \\sqrt{4^2 + 3^2} = \\sqrt{16 + 9} = \\sqrt{25} = 5\n$$\nThe residual norm is $5$ N.\n\nFinally, we assess convergence by comparing the computed residual norm to the prescribed absolute tolerance $\\tau$. The convergence criterion is $\\|r(u)\\|_{2} \\le \\tau$.\nWe have $\\|r(u)\\|_{2} = 5$ and $\\tau = 10^{-2} = 0.01$. The inequality is:\n$$\n5 \\le 0.01\n$$\nThis inequality is false. Therefore, the system has not converged.\n\nThe binary indicator $c$ is defined as $c=1$ if convergence is achieved and $c=0$ otherwise. Since the condition is not met, the value of the indicator is:\n$$\nc = 0\n$$\nThe problem requires the final answer to be a row matrix containing the residual norm and the binary indicator, in that order. The required quantities are $\\|r(u)\\|_{2} = 5$ and $c=0$.", "answer": "$$\n\\boxed{\\begin{pmatrix} 5 & 0 \\end{pmatrix}}\n$$", "id": "3511080"}, {"introduction": "Now that we've established the basics of force-based checks, this next practice explores a more subtle but critical issue in convergence assessment. This exercise [@problem_id:3511130] challenges you to construct and analyze a counterexample where a very small displacement update, $\\|\\Delta u\\|$, misleadingly suggests convergence while a large force residual, $\\|r\\|$, still exists. This phenomenon, often caused by ill-conditioned stiffness matrices common in geomechanics, highlights the potential danger of relying solely on displacement-based criteria and reinforces the robustness of force-based checks.", "problem": "Consider a quasi-static, small-strain geomechanics model discretized by the Finite Element Method (FEM). The discrete equilibrium at an iteration is described by the linear system $K u = f$, where $K$ is the symmetric positive-definite global stiffness matrix, $u$ is the nodal displacement vector, and $f$ is the external force vector. In a Newton–Raphson (NR) iteration, the residual force vector is defined by $r = f - K u$, and the update solves $K \\Delta u = r$. Convergence is often assessed by norms of the displacement increment $\\|\\Delta u\\|$, the residual force $\\|r\\|$, and an energy measure. Using these core definitions, construct a concrete counterexample showing that small $\\|\\Delta u\\|$ can coexist with large $\\|r\\|$ due to ill conditioning or poor scaling.\n\nModel a two-degree-of-freedom node representing a rigid footing pressed against a rigid boundary via a penalty enforcement of non-penetration, together with a soft lateral shear spring representing the surrounding soil. The penalty stiffness produces severe conditioning of the algebraic system. Let the global stiffness matrix be\n$$\nK = \\begin{pmatrix}\n10^{12} & 0 \\\\\n0 & 10^{3}\n\\end{pmatrix},\n$$\nthe current iterate be $u_{k} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$, and the applied external force be\n$$\nf = \\begin{pmatrix}\n10^{3} \\\\\n0\n\\end{pmatrix}.\n$$\nInterpret $u_{1}$ as the normal contact degree of freedom enforced by penalty and $u_{2}$ as a lateral shear degree of freedom with realistic soil stiffness.\n\nUsing the fundamental definitions above, compute the Newton–Raphson update $\\Delta u$ from $K \\Delta u = r$ with $r = f - K u_{k}$, then evaluate the Euclidean vector norms $\\|\\Delta u\\|_{2}$ and $\\|r\\|_{2}$, and finally form the dimensionless ratio\n$$\n\\rho = \\frac{\\|r\\|_{2}}{\\|\\Delta u\\|_{2}}.\n$$\nExpress the final ratio as a pure number (unitless) and round your answer to four significant figures. Additionally, explain, based on the computed quantities and the structure of $K$, why a displacement-based criterion can misleadingly indicate convergence for this system, whereas a force-based criterion would not.", "solution": "The problem statement is a valid exercise in computational mechanics and numerical analysis. It is scientifically grounded, well-posed, and objective. It presents a standard, albeit simplified, scenario encountered in the Finite Element Method (FEM) analysis of geotechnical problems involving contact, where penalty methods lead to ill-conditioned stiffness matrices. All data required for the calculation and subsequent analysis are provided, and there are no internal contradictions or ambiguities. We may therefore proceed with the solution.\n\nThe problem asks us to analyze a Newton-Raphson iteration for a two-degree-of-freedom system. The governing equation for the displacement increment $\\Delta u$ is given by $K \\Delta u = r$, where $K$ is the stiffness matrix, and $r$ is the residual force vector.\n\nFirst, we are given the necessary quantities:\nThe global stiffness matrix is:\n$$\nK = \\begin{pmatrix}\n10^{12} & 0 \\\\\n0 & 10^{3}\n\\end{pmatrix}\n$$\nThe external force vector is:\n$$\nf = \\begin{pmatrix}\n10^{3} \\\\\n0\n\\end{pmatrix}\n$$\nThe displacement vector at the current iterate, $k$, is:\n$$\nu_{k} = \\begin{pmatrix}\n0 \\\\\n0\n\\end{pmatrix}\n$$\n\nThe first step is to compute the residual force vector, $r$, at the current iterate. The residual is defined as the out-of-balance force, $r = f - f_{\\text{internal}}$, where the internal forces are given by $f_{\\text{internal}} = K u_{k}$.\n$$\nr = f - K u_{k} = \\begin{pmatrix} 10^{3} \\\\ 0 \\end{pmatrix} - \\begin{pmatrix} 10^{12} & 0 \\\\ 0 & 10^{3} \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}\n$$\n$$\nr = \\begin{pmatrix} 10^{3} \\\\ 0 \\end{pmatrix} - \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 10^{3} \\\\ 0 \\end{pmatrix}\n$$\nThe residual force vector is $r = \\begin{pmatrix} 10^{3} \\\\ 0 \\end{pmatrix}$.\n\nNext, we solve for the displacement increment vector, $\\Delta u = \\begin{pmatrix} \\Delta u_1 \\\\ \\Delta u_2 \\end{pmatrix}$, using the Newton-Raphson update equation, $K \\Delta u = r$.\n$$\n\\begin{pmatrix} 10^{12} & 0 \\\\ 0 & 10^{3} \\end{pmatrix} \\begin{pmatrix} \\Delta u_1 \\\\ \\Delta u_2 \\end{pmatrix} = \\begin{pmatrix} 10^{3} \\\\ 0 \\end{pmatrix}\n$$\nSince the stiffness matrix $K$ is diagonal, this system of linear equations is uncoupled and can be solved component-wise:\n$$\n10^{12} \\Delta u_1 = 10^{3} \\implies \\Delta u_1 = \\frac{10^{3}}{10^{12}} = 10^{-9}\n$$\n$$\n10^{3} \\Delta u_2 = 0 \\implies \\Delta u_2 = 0\n$$\nThus, the displacement increment vector is:\n$$\n\\Delta u = \\begin{pmatrix}\n10^{-9} \\\\\n0\n\\end{pmatrix}\n$$\n\nNow, we evaluate the Euclidean norms ($\\ell_2$-norms) of the residual force vector, $\\|r\\|_{2}$, and the displacement increment vector, $\\|\\Delta u\\|_{2}$.\nThe norm of the residual force vector is:\n$$\n\\|r\\|_{2} = \\sqrt{(10^{3})^{2} + 0^{2}} = \\sqrt{10^{6}} = 10^{3}\n$$\nThe norm of the displacement increment vector is:\n$$\n\\|\\Delta u\\|_{2} = \\sqrt{(10^{-9})^{2} + 0^{2}} = \\sqrt{10^{-18}} = 10^{-9}\n$$\n\nFinally, we compute the dimensionless ratio $\\rho$:\n$$\n\\rho = \\frac{\\|r\\|_{2}}{\\|\\Delta u\\|_{2}} = \\frac{10^{3}}{10^{-9}} = 10^{12}\n$$\nThe problem asks for this value rounded to four significant figures. We express this in scientific notation:\n$$\n\\rho = 1.000 \\times 10^{12}\n$$\n\nThe explanation for why a displacement-based criterion can be misleading is founded on the results we have just computed and the structure of the stiffness matrix $K$.\nThe norm of the displacement increment, $\\|\\Delta u\\|_{2} = 10^{-9}$, is an extremely small value. If a typical convergence tolerance for displacement is, for instance, $\\epsilon_u = 10^{-6}$, then the criterion $\\|\\Delta u\\|_{2} < \\epsilon_u$ would be satisfied, and the iterative solver would terminate, declaring convergence.\n\nHowever, the norm of the residual force, $\\|r\\|_{2} = 10^{3}$, is a very large value. The residual force represents the extent to which the equilibrium equations are violated at the current iterate. A large residual norm indicates that the system is far from equilibrium. A force-based convergence criterion, such as $\\|r\\|_{2} < \\epsilon_f$, where $\\epsilon_f$ is a small force tolerance, would correctly identify that the solution has not converged.\n\nThe root cause of this discrepancy is the severe ill-conditioning of the stiffness matrix $K$. The condition number of a symmetric matrix is the ratio of its largest to its smallest eigenvalue. For our diagonal matrix $K$, the eigenvalues are the diagonal entries, $\\lambda_{1} = 10^{12}$ and $\\lambda_{2} = 10^{3}$. The condition number is:\n$$\n\\text{cond}(K) = \\frac{\\lambda_{\\max}}{\\lambda_{\\min}} = \\frac{10^{12}}{10^{3}} = 10^{9}\n$$\nA large condition number signifies that the matrix is sensitive to perturbations and that it maps vectors in different directions with vastly different scaling factors. In this problem, the stiffness in the first degree of freedom ($k_{11} = 10^{12}$), representing a stiff penalty contact, is $9$ orders of magnitude larger than the stiffness in the second degree of freedom ($k_{22} = 10^3$), representing softer soil.\n\nThe relationship $r = K \\Delta u$ shows that a small displacement increment $\\Delta u$ can correspond to a large residual force $r$ if $K$ has large entries. Specifically, the residual force is entirely concentrated in the very stiff first degree of freedom ($r_1 = 10^3$). To balance this substantial out-of-balance force, a displacement correction of only $\\Delta u_1 = r_1/k_{11} = 10^3 / 10^{12} = 10^{-9}$ is required. Because the displacement correction is so minuscule, a check on $\\|\\Delta u\\|_2$ provides a misleading signal of convergence. It mistakes a tiny step in a very stiff direction for being close to the final solution. The force-based criterion, on the other hand, directly measures the disequilibrium and is not deceived by the scaling effect of the ill-conditioned stiffness matrix. Therefore, in systems with high stiffness contrasts, such as this one, a force-based or an energy-based convergence criterion is generally more robust and reliable than one based purely on displacement.", "answer": "$$\n\\boxed{1.000 \\times 10^{12}}\n$$", "id": "3511130"}, {"introduction": "This final practice serves as a capstone, moving from targeted calculations to a complete numerical simulation. You are tasked with implementing a Newton-Raphson solver for a material exhibiting plasticity, a ubiquitous feature in geomechanical problems, to systematically compare force, displacement, and energy convergence criteria in action [@problem_id:3511083]. This exercise provides invaluable hands-on experience, revealing how each criterion behaves when confronted with the abrupt stiffness changes characteristic of nonlinear material response, and which is most reliable for capturing complex physical phenomena like yielding.", "problem": "Consider a one-dimensional surrogate of an axisymmetric triaxial compression Finite Element (FE) simulation in small strain, designed to isolate the deviatoric response of a pressure-insensitive von Mises ($J_2$) plasticity model with linear isotropic hardening. Although the physical test is triaxial with a constant radial confining pressure, the $J_2$ yield condition depends only on the deviatoric stress; therefore, in this surrogate, confining pressure is a background field that does not directly enter the yield function. The single global unknown is the axial displacement $u$, producing the axial strain $\\varepsilon = u/L$ in a specimen of length $L$ and cross-sectional area $A$. The internal axial force is $f_{\\text{int}} = A \\sigma$, where $\\sigma$ is the axial stress computed from the elastoplastic constitutive update. The external axial force is prescribed as $f_{\\text{ext}}(t)$, piecewise linearly increasing with discrete load steps. Static equilibrium enforces $f_{\\text{int}} = f_{\\text{ext}}$.\n\nThe material is linear elastic with Young’s modulus $E$ before yielding, and obeys the $J_2$ yield condition with linear isotropic hardening, parameterized by initial yield stress $\\sigma_{y0}$ and hardening modulus $H$. In uniaxial states, the von Mises equivalent stress equals $|\\sigma|$, and radial return produces a corrected stress on the yield surface when plastic loading occurs. The internal variables are the plastic strain $\\varepsilon^p$ and the accumulated plastic strain $\\alpha$, both initialized at zero. The return-mapping update at each trial strain enforces $|\\sigma| - (\\sigma_{y0} + H \\alpha) \\le 0$, with equality in plastic loading. The consistent tangent modulus in plastic loading is $E_t = E H / (E + H)$, and in elastic loading $E_t = E$.\n\nThe global residual for equilibrium is $r_f(u) = f_{\\text{int}}(u) - f_{\\text{ext}}$, and its Newton–Raphson (NR) update in one degree of freedom is $\\Delta u = - r_f / K_t$, with $K_t = A E_t / L$ the consistent tangent stiffness. The incremental change in total potential energy at the current iterate $\\Pi(u)$ is approximated by the first-order variation $\\Delta \\Pi \\approx r_f \\Delta u$. The reference energy scale is the elastic strain energy at initial yield, $E_{\\text{ref}} = (A L) \\, \\sigma_{y0}^2 / (2 E)$.\n\nImplement a program that performs the following tasks:\n\n1. For each load step $n$, apply $f_{\\text{ext}}^{(n)}$ and solve the equilibrium equation $r_f(u^{(n)}) = 0$ using Newton–Raphson with the consistent elastoplastic tangent. Use the previous converged state $(u^{(n-1)}, \\varepsilon^{p, (n-1)}, \\alpha^{(n-1)})$ as the initial guess for the current step. At each Newton–Raphson iteration:\n   - Compute the strain $\\varepsilon = u/L$, perform the uniaxial elastoplastic return-mapping update to obtain $(\\sigma, \\varepsilon^p, \\alpha, E_t)$, and then update $r_f = A \\sigma - f_{\\text{ext}}$ and $K_t = A E_t / L$.\n   - Update the displacement by $\\Delta u = - r_f / K_t$.\n   - Define the energy increment $\\Delta \\Pi = r_f \\Delta u$.\n   - Stop the iteration when one of the following convergence criteria is satisfied:\n     - Force residual criterion: $\\|r_f\\| / \\max(\\|f_{\\text{ext}}\\|, f_{\\text{ref}}) < \\epsilon_f$, with $f_{\\text{ref}} = A \\sigma_{y0}$.\n     - Displacement increment criterion: $\\|\\Delta u\\| / \\max(\\|u\\|, u_{\\text{ref}}) < \\epsilon_u$, with $u_{\\text{ref}} > 0$ a small regularization length.\n     - Energy decrement criterion: $|\\Delta \\Pi| / E_{\\text{ref}} < \\epsilon_E$.\n   - If a maximum number of iterations is exceeded without satisfying the chosen criterion, terminate the current step and accept the last iterate for that step.\n\n2. For each test case, compute a high-accuracy reference solution by solving the same load path with the energy decrement criterion using an extremely tight tolerance $\\epsilon_E^{\\text{ref}}$. From this reference, identify the first load step where plasticity occurs and store the converged displacement and internal variables for that step.\n\n3. For each convergence criterion in Task 1, solve the same test case with the specified tolerances and compute, at the first plastic load step identified by the reference solution:\n   - The energy-norm of the last Newton–Raphson update, defined as $|\\Delta \\Pi|$, and use this as a proxy for how closely the iteration approaches the stationary point of the potential energy at yield. Smaller values indicate better capture of yield surface approach.\n   - Break ties by choosing the criterion with the smallest number of Newton–Raphson iterations at that step.\n\n4. For each test case, select the “best” criterion as the one with the smallest $|\\Delta \\Pi|$ at the first plastic load step, with the tie-breaker rule above. Encode the criteria as integers: $0$ for force residual, $1$ for displacement increment, and $2$ for energy decrement.\n\nFundamental base to use in the derivation and implementation:\n- Balance of linear momentum in static one-dimensional form: $f_{\\text{int}} = f_{\\text{ext}}$.\n- Kinematics: $\\varepsilon = u/L$ and $\\varepsilon^p$ as an internal variable.\n- Linear elasticity in small strain: $\\sigma = E(\\varepsilon - \\varepsilon^p)$ prior to yielding.\n- Von Mises ($J_2$) yield with linear isotropic hardening: $|\\sigma| - (\\sigma_{y0} + H \\alpha) \\le 0$.\n- Newton–Raphson method: $\\Delta u = -r_f / K_t$ with consistent tangent.\n- Energetics: first-order potential energy decrement $\\Delta \\Pi \\approx r_f \\Delta u$.\n\nUnits:\n- Use the International System of Units (SI). Length in meters ($\\mathrm{m}$), area in square meters ($\\mathrm{m}^2$), force in Newtons ($\\mathrm{N}$), stress in Pascals ($\\mathrm{Pa}$), energy in Joules ($\\mathrm{J}$).\n- Express the final output as dimensionless integers encoding the best criterion per test case.\n\nTest suite and parameters:\n- Three test cases, each defined by $(E, H, \\sigma_{y0}, A, L, f_{\\text{ext,max}}, N_{\\text{steps}}, \\epsilon_f, \\epsilon_u, \\epsilon_E, u_{\\text{ref}})$:\n  1. Case A (general): $(E = 1.0 \\times 10^8\\,\\mathrm{Pa}, H = 2.0 \\times 10^7\\,\\mathrm{Pa}, \\sigma_{y0} = 5.0 \\times 10^6\\,\\mathrm{Pa}, A = 1.0 \\times 10^{-2}\\,\\mathrm{m}^2, L = 1.0\\,\\mathrm{m}, f_{\\text{ext,max}} = 8.0 \\times 10^4\\,\\mathrm{N}, N_{\\text{steps}} = 12, \\epsilon_f = 1.0 \\times 10^{-6}, \\epsilon_u = 1.0 \\times 10^{-6}, \\epsilon_E = 1.0 \\times 10^{-12}, u_{\\text{ref}} = 1.0 \\times 10^{-12}\\,\\mathrm{m})$.\n  2. Case B (near-perfect plasticity): $(E = 1.0 \\times 10^8\\,\\mathrm{Pa}, H = 1.0 \\times 10^5\\,\\mathrm{Pa}, \\sigma_{y0} = 4.0 \\times 10^6\\,\\mathrm{Pa}, A = 1.0 \\times 10^{-2}\\,\\mathrm{m}^2, L = 1.0\\,\\mathrm{m}, f_{\\text{ext,max}} = 6.0 \\times 10^4\\,\\mathrm{N}, N_{\\text{steps}} = 12, \\epsilon_f = 1.0 \\times 10^{-6}, \\epsilon_u = 1.0 \\times 10^{-6}, \\epsilon_E = 1.0 \\times 10^{-12}, u_{\\text{ref}} = 1.0 \\times 10^{-12}\\,\\mathrm{m})$.\n  3. Case C (very stiff and strongly hardening): $(E = 1.0 \\times 10^9\\,\\mathrm{Pa}, H = 5.0 \\times 10^8\\,\\mathrm{Pa}, \\sigma_{y0} = 6.0 \\times 10^6\\,\\mathrm{Pa}, A = 5.0 \\times 10^{-3}\\,\\mathrm{m}^2, L = 1.0\\,\\mathrm{m}, f_{\\text{ext,max}} = 5.0 \\times 10^4\\,\\mathrm{N}, N_{\\text{steps}} = 12, \\epsilon_f = 1.0 \\times 10^{-6}, \\epsilon_u = 1.0 \\times 10^{-6}, \\epsilon_E = 1.0 \\times 10^{-12}, u_{\\text{ref}} = 1.0 \\times 10^{-12}\\,\\mathrm{m})$.\n\nAnswer specification:\n- Your program should produce a single line of output containing a list of three integers $[i_A, i_B, i_C]$ indicating the selected best criterion for Cases A, B, and C, respectively, using the encoding above.\n- The output must be formatted exactly as a comma-separated list enclosed in square brackets, for example $[0,1,2]$.", "solution": "The computational task is to solve a one-degree-of-freedom surrogate of an axisymmetric triaxial test, sufficient to study convergence criteria based on force, displacement, and energy for a von Mises ($J_2$) plasticity model under small strain. The derivation and algorithm design start from fundamental principles.\n\nThe static equilibrium in one dimension imposes $f_{\\text{int}} = f_{\\text{ext}}$. With one global displacement $u$, the axial strain is $\\varepsilon = u/L$. The material is linear elastic prior to yielding, so the trial stress is $\\sigma_{\\text{tr}} = E (\\varepsilon - \\varepsilon^p)$. The $J_2$ yield function for uniaxial states is $f = |\\sigma| - (\\sigma_{y0} + H \\alpha)$, which encodes linear isotropic hardening. The internal variables are the plastic strain $\\varepsilon^p$ and the accumulated plastic strain $\\alpha$, both initialized at zero.\n\nThe return-mapping algorithm derives from enforcing the Karush–Kuhn–Tucker conditions and normality for associated plasticity. For one-dimensional $J_2$ plasticity, the algorithm simplifies to a projection of $\\sigma_{\\text{tr}}$ back onto the yield surface when $f(\\sigma_{\\text{tr}}, \\alpha) > 0$:\n1. Compute $\\sigma_{\\text{tr}} = E (\\varepsilon - \\varepsilon^p)$ and the yield radius $\\sigma_{\\text{y}}(\\alpha) = \\sigma_{y0} + H \\alpha$.\n2. If $|\\sigma_{\\text{tr}}| \\le \\sigma_{\\text{y}}(\\alpha)$, the state is elastic and $(\\sigma, \\varepsilon^p, \\alpha) = (\\sigma_{\\text{tr}}, \\varepsilon^p, \\alpha)$ with tangent $E_t = E$.\n3. Otherwise, plastic correction occurs with plastic multiplier increment\n$$\n\\Delta \\gamma = \\frac{|\\sigma_{\\text{tr}}| - \\sigma_{\\text{y}}(\\alpha)}{E + H},\n$$\nthe stress updates to the yield surface\n$$\n\\sigma = \\operatorname{sign}(\\sigma_{\\text{tr}}) \\, \\big(\\sigma_{y0} + H (\\alpha + |\\Delta \\gamma|)\\big),\n$$\nand the internal variables update as\n$$\n\\varepsilon^p \\leftarrow \\varepsilon^p + \\operatorname{sign}(\\sigma_{\\text{tr}}) \\, \\Delta \\gamma, \\quad \\alpha \\leftarrow \\alpha + |\\Delta \\gamma|,\n$$\nwith consistent tangent modulus\n$$\nE_t = \\frac{E H}{E + H}.\n$$\nThese expressions follow by enforcing $\\sigma - \\sigma_{\\text{tr}} = - E \\Delta \\varepsilon^p$ and the hardening law $\\sigma_{y0} + H \\alpha$ combined with the consistency condition $f = 0$ in plastic loading and linear isotropic hardening.\n\nThe global Newton–Raphson method in one dimension solves $r_f(u) = f_{\\text{int}}(u) - f_{\\text{ext}} = 0$. Using the consistent tangent stiffness $K_t = \\partial f_{\\text{int}} / \\partial u = A E_t / L$, the update is\n$$\n\\Delta u = - \\frac{r_f}{K_t}.\n$$\nThe potential energy functional is $\\Pi(u) = U(u) - f_{\\text{ext}} \\, u$, where $U$ is the stored strain energy. The first-order variation about the current iterate $u$ gives\n$$\n\\Delta \\Pi \\approx \\frac{\\partial \\Pi}{\\partial u} \\, \\Delta u = r_f \\, \\Delta u.\n$$\nThis energy decrement is central to the energy-based convergence criterion because the stationary point of $\\Pi$ corresponds to equilibrium.\n\nConvergence criteria are defined as follows:\n- Force residual criterion normalizes by a physically meaningful force scale to avoid division by zero:\n$$\n\\frac{\\| r_f \\|}{\\max(\\| f_{\\text{ext}} \\|, f_{\\text{ref}})} < \\epsilon_f, \\quad f_{\\text{ref}} = A \\sigma_{y0}.\n$$\n- Displacement increment criterion normalizes by a displacement scale to avoid division by zero:\n$$\n\\frac{\\| \\Delta u \\|}{\\max(\\| u \\|, u_{\\text{ref}})} < \\epsilon_u, \\quad u_{\\text{ref}} > 0.\n$$\n- Energy decrement criterion normalizes by the elastic strain energy at initial yield:\n$$\n\\frac{|\\Delta \\Pi|}{E_{\\text{ref}}} < \\epsilon_E, \\quad E_{\\text{ref}} = \\frac{A L}{2} \\frac{\\sigma_{y0}^2}{E}.\n$$\n\nAlgorithmic design:\n1. Initialize $(u, \\varepsilon^p, \\alpha) = (0, 0, 0)$ and loop load steps $n = 1, \\ldots, N_{\\text{steps}}$ with $f_{\\text{ext}}^{(n)} = (n/N_{\\text{steps}}) f_{\\text{ext,max}}$.\n2. At each step, perform Newton–Raphson iterations:\n   - Compute $\\varepsilon = u/L$, perform return-mapping to obtain $(\\sigma, \\varepsilon^p, \\alpha, E_t)$, and then $r_f = A \\sigma - f_{\\text{ext}}^{(n)}$ and $K_t = A E_t / L$.\n   - Update $\\Delta u = - r_f / K_t$ and $u \\leftarrow u + \\Delta u$, and store $\\Delta \\Pi = r_f \\Delta u$.\n   - Check convergence for the chosen criterion; if satisfied or a maximum iteration count is reached, accept the current iterate.\n3. Build a high-accuracy reference using the energy criterion with a very tight tolerance $\\epsilon_E^{\\text{ref}}$. Identify the first plastic step in the reference (the first step where the return mapping executes a plastic correction).\n4. For the three criteria with their specified tolerances, recompute the solution and, at the first plastic step identified by the reference, evaluate $|\\Delta \\Pi|$ at the final Newton–Raphson update for that step. Smaller $|\\Delta \\Pi|$ indicates a closer approach to the stationary point of $\\Pi$ and better fidelity when approaching the yield surface. Break ties using the number of iterations performed in that step.\n\nScientific reasoning for expected outcomes:\n- Near the yield surface, the internal force-displacement response changes slope due to the consistent tangent $E_t$ transitioning from $E$ to $E H /(E + H)$. The energy decrement $|\\Delta \\Pi| = |r_f \\Delta u|$ measures the first-order change in the potential energy, aggregating both the residual and the update. This captures how well the iteration moves toward equilibrium in a physically meaningful, load-path-agnostic manner.\n- The force residual criterion alone can be misleading if the external force is small or large relative to internal scales; normalizing by $f_{\\text{ref}}$ mitigates this but does not fully account for stiffness changes near yield.\n- The displacement criterion is ill-posed near $u = 0$ without regularization and can be insensitive to stiffness changes because it measures step size rather than energy proximity.\n- Therefore, the energy decrement criterion often better reflects convergence quality near yield due to its work-conjugate nature: it measures the product of residual and update, aligning with the minimization of $\\Pi$.\n\nThe code implements these principles, computes $|\\Delta \\Pi|$ at the first plastic step for each criterion, and selects the best criterion per test case as an integer $0$, $1$, or $2$ corresponding to the force residual, displacement increment, or energy decrement criterion, respectively. The final output aggregates the three selections as a single list $[i_A, i_B, i_C]$ in the specified format.\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef return_mapping_uniaxial(epsilon, ep_old, alpha_old, E, H, sigma_y0):\n    \"\"\"\n    Uniaxial J2 plasticity with linear isotropic hardening.\n    Radial return mapped to yield surface if trial stress exceeds yield.\n    Returns: sigma, ep_new, alpha_new, Et (consistent tangent)\n    \"\"\"\n    sigma_tr = E * (epsilon - ep_old)\n    yield_radius = sigma_y0 + H * alpha_old\n    if abs(sigma_tr) = yield_radius + 0.0:  # small tolerance not necessary here\n        # Elastic step\n        sigma = sigma_tr\n        ep_new = ep_old\n        alpha_new = alpha_old\n        Et = E\n    else:\n        # Plastic correction\n        dgamma = (abs(sigma_tr) - yield_radius) / (E + H)\n        sign = 1.0 if sigma_tr >= 0.0 else -1.0\n        ep_new = ep_old + sign * dgamma\n        alpha_new = alpha_old + abs(dgamma)\n        sigma = sign * (sigma_y0 + H * alpha_new)\n        Et = (E * H) / (E + H)\n    return sigma, ep_new, alpha_new, Et\n\ndef newton_solve_step(fext, u0, ep0, alpha0, E, H, sigma_y0, A, L,\n                      criterion, eps_f, eps_u, eps_E, u_ref, max_iter=100):\n    \"\"\"\n    Solve one load step with Newton-Raphson under a specified convergence criterion.\n    criterion: 'force', 'disp', or 'energy'\n    Returns converged (u, ep, alpha, sigma, iters, last_energy_increment)\n    \"\"\"\n    u = u0\n    ep = ep0\n    alpha = alpha0\n    last_energy_inc = None\n    iters = 0\n\n    # Reference scales\n    f_ref = A * sigma_y0\n    E_ref = (A * L) * (sigma_y0 ** 2) / (2.0 * E)\n\n    for k in range(max_iter):\n        # Current strain and material update\n        epsilon = u / L\n        sigma, ep_new, alpha_new, Et = return_mapping_uniaxial(epsilon, ep, alpha, E, H, sigma_y0)\n        # Internal force and tangent\n        fint = A * sigma\n        rf = fint - fext\n        Kt = A * Et / L\n\n        # Newton update\n        # Guard against zero tangent (shouldn't occur for H>=0 with E>0, but be safe)\n        if Kt == 0.0:\n            # If tangent is zero, cannot update; break\n            du = 0.0\n        else:\n            du = - rf / Kt\n\n        # Energy decrement approximation\n        dPi = rf * du\n        last_energy_inc = abs(dPi)\n\n        # Convergence checks\n        if criterion == 'force':\n            denom = max(abs(fext), f_ref)\n            conv = (abs(rf) / denom)  eps_f\n        elif criterion == 'disp':\n            denom = max(abs(u), u_ref)\n            conv = (abs(du) / denom)  eps_u\n        elif criterion == 'energy':\n            conv = (abs(dPi) / E_ref)  eps_E\n        else:\n            raise ValueError(\"Unknown criterion\")\n\n        # Update state\n        u = u + du\n        ep = ep_new\n        alpha = alpha_new\n        iters = k + 1\n\n        if conv:\n            # Recompute stress at updated u for reporting\n            epsilon = u / L\n            sigma, ep, alpha, Et = return_mapping_uniaxial(epsilon, ep, alpha, E, H, sigma_y0)\n            break\n\n    return u, ep, alpha, sigma, iters, last_energy_inc\n\ndef simulate_case(params, criterion, eps_f, eps_u, eps_E, u_ref, ref_energy_tol=None):\n    \"\"\"\n    Simulate full load path for a given case and criterion.\n    If ref_energy_tol is provided, a reference solution is computed with energy criterion and that tolerance.\n    Returns:\n      - results for chosen criterion across steps\n      - reference data (first plastic step index), computed with tight energy tolerance if ref_energy_tol is not None;\n        otherwise uses the chosen criterion's solution.\n    \"\"\"\n    E, H, sigma_y0, A, L, fext_max, n_steps = params\n    # Prepare load steps\n    fext_steps = [(i + 1) / n_steps * fext_max for i in range(n_steps)]\n\n    # First, compute reference (tight energy) to locate first plastic step\n    u_ref_sol = 0.0\n    ep_ref_sol = 0.0\n    alpha_ref_sol = 0.0\n    first_plastic_step = None\n    if ref_energy_tol is None:\n        # Use the chosen criterion itself to locate plasticity (less accurate)\n        ref_tol = eps_E\n    else:\n        ref_tol = ref_energy_tol\n\n    for i, fext in enumerate(fext_steps):\n        u_ref_sol, ep_ref_sol, alpha_ref_sol, sigma_ref, it_ref, dPi_ref = newton_solve_step(\n            fext, u_ref_sol, ep_ref_sol, alpha_ref_sol, E, H, sigma_y0, A, L,\n            'energy', eps_f, eps_u, ref_tol, u_ref, max_iter=200\n        )\n        # Plastic if the return mapping performed plastic correction:\n        # This can be inferred when |sigma_ref| equals current yield stress\n        yield_radius = sigma_y0 + H * alpha_ref_sol\n        if first_plastic_step is None and abs(abs(sigma_ref) - yield_radius)  1e-9:\n            first_plastic_step = i\n\n    if first_plastic_step is None:\n        # If no plasticity occurred, set to last step\n        first_plastic_step = n_steps - 1\n\n    # Now simulate with the chosen criterion, capturing the energy-norm at the first plastic step\n    u_sol = 0.0\n    ep_sol = 0.0\n    alpha_sol = 0.0\n    energy_inc_at_first_plastic = None\n    iters_at_first_plastic = None\n\n    for i, fext in enumerate(fext_steps):\n        u_sol, ep_sol, alpha_sol, sigma_sol, iters, dPi = newton_solve_step(\n            fext, u_sol, ep_sol, alpha_sol, E, H, sigma_y0, A, L,\n            criterion, eps_f, eps_u, eps_E, u_ref, max_iter=200\n        )\n        if i == first_plastic_step:\n            energy_inc_at_first_plastic = dPi\n            iters_at_first_plastic = iters\n\n    return energy_inc_at_first_plastic, iters_at_first_plastic, first_plastic_step\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Each case: (E, H, sigma_y0, A, L, fext_max, n_steps, eps_f, eps_u, eps_E, u_ref)\n        (1.0e8, 2.0e7, 5.0e6, 1.0e-2, 1.0, 8.0e4, 12, 1.0e-6, 1.0e-6, 1.0e-12, 1.0e-12),\n        (1.0e8, 1.0e5, 4.0e6, 1.0e-2, 1.0, 6.0e4, 12, 1.0e-6, 1.0e-6, 1.0e-12, 1.0e-12),\n        (1.0e9, 5.0e8, 6.0e6, 5.0e-3, 1.0, 5.0e4, 12, 1.0e-6, 1.0e-6, 1.0e-12, 1.0e-12),\n    ]\n\n    # We will compute a high-accuracy reference using energy criterion with very tight tolerance\n    ref_energy_tol = 1.0e-14\n\n    results = []\n    for case in test_cases:\n        E, H, sigma_y0, A, L, fext_max, n_steps, eps_f, eps_u, eps_E, u_ref = case\n\n        params = (E, H, sigma_y0, A, L, fext_max, n_steps)\n\n        # Evaluate each criterion at the first plastic step determined by reference solution\n        energy_force, it_force, fp_idx = simulate_case(params, 'force', eps_f, eps_u, eps_E, u_ref,\n                                                       ref_energy_tol=ref_energy_tol)\n        energy_disp, it_disp, _ = simulate_case(params, 'disp', eps_f, eps_u, eps_E, u_ref,\n                                                ref_energy_tol=ref_energy_tol)\n        energy_energy, it_energy, _ = simulate_case(params, 'energy', eps_f, eps_u, eps_E, u_ref,\n                                                    ref_energy_tol=ref_energy_tol)\n\n        # Collect energies and iterations\n        energies = [energy_force, energy_disp, energy_energy]\n        iters = [it_force, it_disp, it_energy]\n\n        # Choose best criterion: smallest energy-norm |ΔΠ| at first plastic step; tie-breaker = fewer iterations\n        # Note: ensure robust handling of None (should not occur)\n        best_idx = 0\n        best_energy = energies[0]\n        best_iters = iters[0]\n        for idx in range(1, 3):\n            e = energies[idx]\n            it = iters[idx]\n            if e is None:\n                continue\n            if (e  best_energy) or (abs(e - best_energy)  1e-20 and it  best_iters):\n                best_idx = idx\n                best_energy = e\n                best_iters = it\n\n        results.append(best_idx)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# The following line is commented out to prevent execution in this context,\n# but it's what generates the answer.\n# solve()\n# The output is [2,2,2]\n```", "answer": "$$\n\\boxed{[2,2,2]}\n$$", "id": "3511083"}]}