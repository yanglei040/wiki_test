{"hands_on_practices": [{"introduction": "The most direct method for visualizing pseudospectra is to compute the function $f(z) = \\sigma_{\\min}(A - zI)$ across a grid in the complex plane and then visualize the resulting surface or its level curves. This foundational exercise guides you through the implementation of this core \"grid algorithm,\" which involves systematically performing a Singular Value Decomposition (SVD) at each grid point. By completing this practice [@problem_id:3568796], you will build the fundamental tool for pseudospectral analysis and gain a concrete understanding of its computational complexity and opportunities for parallelization.", "problem": "Let $A \\in \\mathbb{C}^{n \\times n}$ be a square matrix, $I$ the identity matrix, and $z \\in \\mathbb{C}$ a complex variable. The smallest singular value of $A - zI$, denoted $\\sigma_{\\min}(A - zI)$, is a central quantity in the study of pseudospectra. The $\\varepsilon$-pseudospectrum of $A$ is defined as the set of points $z \\in \\mathbb{C}$ for which $\\sigma_{\\min}(A - zI) \\le \\varepsilon$. Singular values arise from the Singular Value Decomposition (SVD), which for a matrix $B \\in \\mathbb{C}^{n \\times n}$ factors $B$ as $B = U \\Sigma V^*$, where $U, V$ are unitary matrices and $\\Sigma$ is diagonal with nonnegative entries $\\sigma_1(B) \\ge \\sigma_2(B) \\ge \\cdots \\ge \\sigma_n(B) \\ge 0$.\n\nStarting from these definitions, design and implement an algorithm that:\n- constructs a rectangular grid in the complex plane defined by real bounds $x_{\\min}, x_{\\max}, y_{\\min}, y_{\\max}$ and integer resolutions $N_x, N_y$;\n- for each grid point $z = x + \\mathrm{i} y$, computes $\\sigma_{\\min}(A - zI)$ using Singular Value Decomposition (SVD);\n- assembles the values $\\sigma_{\\min}(A - zI)$ into a two-dimensional array corresponding to the grid; and\n- provides a clear analysis of the computational complexity in terms of $n$ and the total number of grid points $G := N_x N_y$, together with a discussion of opportunities for parallelization that respect the independence of computations across distinct $z$.\n\nYour program must compute and return specific quantifiable results on the following test suite. For avoidance of ambiguity, every matrix, bound, and grid resolution is explicitly specified, and all required numeric outputs are stated. No physical units or angles are involved in this problem.\n\nTest Suite:\n1. Happy-path non-normal case. Let $A_1 \\in \\mathbb{C}^{5 \\times 5}$ be the nilpotent Jordan block,\n$$\nA_1 = \\begin{bmatrix}\n0  1  0  0  0 \\\\\n0  0  1  0  0 \\\\\n0  0  0  1  0 \\\\\n0  0  0  0  1 \\\\\n0  0  0  0  0\n\\end{bmatrix}.\n$$\nUse a rectangular grid with $x_{\\min} = -0.1$, $x_{\\max} = 0.1$, $y_{\\min} = -0.1$, $y_{\\max} = 0.1$, $N_x = 11$, $N_y = 11$. Compute the minimal value of $\\sigma_{\\min}(A_1 - zI)$ over the grid and return it as a floating-point number.\n\n2. Normal matrix consistency check. Let $A_2 \\in \\mathbb{C}^{4 \\times 4}$ be diagonal,\n$$\nA_2 = \\mathrm{diag}(1,\\,2,\\,3,\\,4).\n$$\nConsider the single-point grid $x_{\\min} = x_{\\max} = 2.5$, $y_{\\min} = y_{\\max} = 0$, $N_x = 1$, $N_y = 1$ so $z = 2.5$. Using SVD, compute $\\sigma_{\\min}(A_2 - zI)$ as a floating-point number. Independently, compute the quantity $d := \\min_{i} |\\lambda_i(A_2) - z|$ using the eigenvalues of $A_2$. Return the absolute difference $|\\sigma_{\\min}(A_2 - zI) - d|$ as a floating-point number.\n\n3. Complexity accounting (SVD call count). Let\n$$\nA_3 = \\begin{bmatrix}\n5  1  0 \\\\\n0  -1  1 \\\\\n0  0  2\n\\end{bmatrix} \\in \\mathbb{C}^{3 \\times 3}.\n$$\nUse a rectangular grid with $x_{\\min} = -2$, $x_{\\max} = 2$, $y_{\\min} = -1$, $y_{\\max} = 1$, $N_x = 17$, $N_y = 19$. Return the integer number of SVD computations your algorithm performs to evaluate $\\sigma_{\\min}(A_3 - zI)$ on the entire grid. This must equal the total number of grid points $G = N_x N_y$.\n\n4. Ideal parallelization speedup. For the grid in test case $3$, assume a parallel execution model with $p = 8$ identical processors and negligible overhead, where each evaluation of $\\sigma_{\\min}(A - zI)$ at a grid point is an independent task. Under perfect load balancing, the ideal speedup is defined as $S = \\min(G, p)$ relative to serial execution. Return $S$ as an integer.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results of the four test cases, as a comma-separated list enclosed in square brackets, in the order given above. For example, it should print\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4].\n$$\nAll four entries must be of types as specified: the first two as floating-point numbers, the third as an integer, and the fourth as an integer.", "solution": "The problem has been validated and is deemed well-posed, scientifically grounded, and self-contained. It presents a standard task in numerical linear algebra—the computation of the smallest singular value over a grid in the complex plane to map the pseudospectrum of a matrix. All definitions, matrices, and parameters are stated explicitly and unambiguously. We may therefore proceed with a formal solution.\n\nThe objective is to design and implement an algorithm that computes $\\sigma_{\\min}(A - zI)$ for a given matrix $A \\in \\mathbb{C}^{n \\times n}$ at each point $z$ of a specified rectangular grid in the complex plane $\\mathbb{C}$. This grid is defined by real bounds $x_{\\min}$, $x_{\\max}$, $y_{\\min}$, $y_{\\max}$ and integer resolutions $N_x$, $N_y$.\n\n**Algorithm Design**\n\nThe core of the algorithm involves a systematic evaluation over a discrete set of complex numbers.\n\n1.  **Grid Construction**: A rectangular grid of points in the complex plane is constructed. The real components of the grid points, $x_j$, are generated as an arithmetic progression of $N_x$ points from $x_{\\min}$ to $x_{\\max}$. Similarly, the imaginary components, $y_k$, are $N_y$ points from $y_{\\min}$ to $y_{\\max}$. This is achieved using linearly spaced arrays. A grid point $z_{jk}$ is given by $z_{jk} = x_j + \\mathrm{i} y_k$, where $j \\in \\{1, \\dots, N_x\\}$ and $k \\in \\{1, \\dots, N_y\\}$. The total number of points in the grid is $G = N_x N_y$.\n\n2.  **Iterative Computation**: The algorithm iterates through each of the $G$ grid points. For each $z = z_{jk}$, the following steps are performed:\n    a. Form the matrix $B(z) = A - zI$, where $I$ is the $n \\times n$ identity matrix. This is a simple matrix subtraction operation.\n    b. Compute the Singular Value Decomposition (SVD) of $B(z)$. The SVD provides the factorization $B(z) = U \\Sigma V^*$, where $U$ and $V$ are unitary matrices and $\\Sigma$ is a diagonal matrix containing the singular values $\\sigma_i$ on its diagonal, conventionally sorted in non-increasing order: $\\sigma_1 \\ge \\sigma_2 \\ge \\cdots \\ge \\sigma_n \\ge 0$.\n    c. The smallest singular value, $\\sigma_{\\min}(B(z)) = \\sigma_n(B(z))$, is extracted. Computationally, this is typically the last element of the array of singular values returned by a standard SVD library function. For efficiency, one should use a variant of the SVD algorithm that computes only the singular values and not the unitary matrices $U$ and $V$, as the latter are not required for this problem.\n\n3.  **Data Assembly**: The computed values of $\\sigma_{\\min}(A - z_{jk}I)$ are stored in a two-dimensional array, say $\\mathcal{S}$, of size $N_y \\times N_x$. The element $\\mathcal{S}_{k,j}$ corresponds to the value computed at $z_{jk} = x_j + \\mathrm{i} y_k$. This matrix $\\mathcal{S}$ represents the landscape of the function $f(z) = \\sigma_{\\min}(A - zI)$ over the specified domain.\n\n**Computational Complexity Analysis**\n\nThe dominant computational cost of this algorithm is the repeated calculation of the SVD.\n- The complexity of computing the SVD of a general $n \\times n$ matrix is $O(n^3)$.\n- This computation is performed once for each of the $G = N_x N_y$ points in the grid.\n- Therefore, the total computational complexity of the algorithm is $O(G \\cdot n^3) = O(N_x N_y n^3)$. The costs of grid generation and matrix subtraction ($O(n^2)$ per point) are negligible compared to the SVD cost for non-trivial $n$.\n\n**Parallelization Opportunities**\n\nA crucial observation is that the computation of $\\sigma_{\\min}(A - z_1 I)$ for a grid point $z_1$ is entirely independent of the computation of $\\sigma_{\\min}(A - z_2 I)$ for any other grid point $z_2$. This property renders the problem \"embarrassingly parallel\".\n\nIn an ideal parallel execution model with $p$ identical processors and zero communication overhead, the $G$ independent tasks (one SVD per grid point) can be distributed among the processors.\n- The total amount of work is proportional to $G$.\n- With $p$ processors, the time required for completion would be proportional to $\\lceil G/p \\rceil$ under perfect load balancing.\n- The ideal speedup $S$ is the ratio of the serial execution time to the parallel execution time. If $p \\le G$, the speedup is approximately $p$. If $p > G$, we cannot utilize more processors than there are tasks, so the speedup is limited by $G$. This leads to the simplified formula for ideal speedup given in the problem: $S = \\min(G, p)$.\n\n**Application to Test Suite**\n\n1.  **Test Case 1**: For matrix $A_1$, a $5 \\times 5$ nilpotent Jordan block, on an $11 \\times 11$ grid over $[-0.1, 0.1] \\times [-0.1, 0.1]$, we must find the minimal $\\sigma_{\\min}$ value. The grid generation includes the point $z=0 + 0\\mathrm{i}$. At this point, we compute $\\sigma_{\\min}(A_1 - 0 \\cdot I) = \\sigma_{\\min}(A_1)$. Matrix $A_1$ is singular (e.g., its last row is all zeros), and a matrix is singular if and only if its smallest singular value is zero. Thus, $\\sigma_{\\min}(A_1) = 0$. Since singular values are always non-negative, the minimum value over the entire grid must be $0.0$.\n\n2.  **Test Case 2**: Matrix $A_2=\\mathrm{diag}(1,2,3,4)$ is a normal matrix. A fundamental property of normal matrices is that for any $z \\in \\mathbb{C}$, $\\sigma_{\\min}(A_2 - zI) = \\min_i |\\lambda_i(A_2) - z|$, where $\\lambda_i(A_2)$ are the eigenvalues of $A_2$.\n    - The eigenvalues of $A_2$ are $\\lambda \\in \\{1, 2, 3, 4\\}$.\n    - The grid is a single point $z = 2.5$.\n    - We compute $d = \\min(|1-2.5|, |2-2.5|, |3-2.5|, |4-2.5|) = \\min(1.5, 0.5, 0.5, 1.5) = 0.5$.\n    - We also compute $\\sigma_{\\min}(A_2 - 2.5I)$. The matrix is $A_2 - 2.5I = \\mathrm{diag}(-1.5, -0.5, 0.5, 1.5)$. Its singular values are the absolute values of its diagonal entries, $\\{1.5, 0.5, 0.5, 1.5\\}$. The smallest is $0.5$.\n    - The absolute difference is $|\\sigma_{\\min}(A_2 - 2.5I) - d| = |0.5 - 0.5| = 0.0$.\n\n3.  **Test Case 3**: The number of SVD computations is identical to the number of grid points, $G$. For a grid with $N_x=17$ and $N_y=19$, the total number of points is $G = 17 \\times 19 = 323$.\n\n4.  **Test Case 4**: Given $G=323$ tasks from test case 3 and $p=8$ processors, the ideal speedup is defined as $S = \\min(G, p)$. Thus, $S = \\min(323, 8) = 8$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_sigma_min_on_grid(A, x_min, x_max, y_min, y_max, Nx, Ny):\n    \"\"\"\n    Computes the smallest singular value of (A - zI) for each z on a grid.\n\n    Args:\n        A (np.ndarray): The input square matrix.\n        x_min, x_max (float): Bounds for the real part of z.\n        y_min, y_max (float): Bounds for the imaginary part of z.\n        Nx, Ny (int): Number of grid points along real and imaginary axes.\n\n    Returns:\n        np.ndarray: A 2D array of sigma_min values.\n    \"\"\"\n    n = A.shape[0]\n    I = np.eye(n, dtype=complex)\n    \n    # Ensure matrix A is complex for subsequent operations\n    A_complex = A.astype(complex)\n\n    x_vals = np.linspace(x_min, x_max, Nx)\n    y_vals = np.linspace(y_min, y_max, Ny)\n    \n    sigma_min_matrix = np.zeros((Ny, Nx))\n\n    for i, y in enumerate(y_vals):\n        for j, x in enumerate(x_vals):\n            z = x + 1j * y\n            B = A_complex - z * I\n            \n            # compute_uv=False is more efficient as we only need singular values.\n            # Singular values are returned in descending order.\n            s = np.linalg.svd(B, compute_uv=False)\n            sigma_min_matrix[i, j] = s[-1]\n            \n    return sigma_min_matrix\n\ndef solve():\n    \"\"\"\n    Solves the four test cases specified in the problem statement.\n    \"\"\"\n    \n    # --- Test Case 1: Happy-path non-normal case ---\n    # Define the 5x5 nilpotent Jordan block A1\n    A1 = np.diag(np.ones(4), k=1)\n    \n    # Grid parameters\n    x_min1, x_max1, y_min1, y_max1 = -0.1, 0.1, -0.1, 0.1\n    Nx1, Ny1 = 11, 11\n    \n    # The grid contains z=0. At z=0, sigma_min(A1-0*I) = sigma_min(A1) = 0\n    # since A1 is singular. As sigma_min is always non-negative, the minimum\n    # value over the grid must be 0. We compute it for rigor.\n    sigma_matrix1 = compute_sigma_min_on_grid(A1, x_min1, x_max1, y_min1, y_max1, Nx1, Ny1)\n    result1 = float(np.min(sigma_matrix1))\n\n    # --- Test Case 2: Normal matrix consistency check ---\n    A2 = np.diag([1, 2, 3, 4])\n    z2 = 2.5 + 0j\n    \n    # Compute sigma_min(A2 - zI) using SVD\n    B2 = A2.astype(complex) - z2 * np.eye(4, dtype=complex)\n    s2 = np.linalg.svd(B2, compute_uv=False)\n    sigma_min_from_svd = s2[-1]\n    \n    # Compute d = min_i |lambda_i(A2) - z|\n    eigenvalues_A2 = np.linalg.eigvals(A2)\n    d = np.min(np.abs(eigenvalues_A2 - z2))\n    \n    result2 = float(np.abs(sigma_min_from_svd - d))\n\n    # --- Test Case 3: Complexity accounting (SVD call count) ---\n    Nx3, Ny3 = 17, 19\n    # The number of SVD calls is the total number of grid points, G = Nx * Ny.\n    result3 = int(Nx3 * Ny3)\n\n    # --- Test Case 4: Ideal parallelization speedup ---\n    # G is the number of tasks from case 3. p is the number of processors.\n    G4 = result3\n    p4 = 8\n    # Ideal speedup S = min(G, p).\n    result4 = int(min(G4, p4))\n\n    # Assemble the final list of results\n    final_results = [result1, result2, result3, result4]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```", "id": "3568796"}, {"introduction": "With a method to compute pseudospectra, we can now investigate systems where eigenvalues alone provide a misleading picture of stability. This practice applies the grid algorithm to the companion matrix of the Wilkinson polynomial, a classic example of a highly non-normal matrix whose well-separated integer eigenvalues are notoriously sensitive to perturbations. This exercise [@problem_id:3568831] demonstrates how pseudospectra expose this instability, revealing that very small perturbations can cause the pseudospectral regions around distant eigenvalues to merge, a critical insight that the spectrum itself does not offer.", "problem": "Let $A \\in \\mathbb{C}^{n \\times n}$ be the Frobenius companion matrix of the monic Wilkinson polynomial of degree $n=20$, that is, the polynomial $W_{20}(x) = \\prod_{j=1}^{20} (x - j)$ with real roots at the integers $1,2,\\dots,20$. Consider the minimum singular value function $z \\mapsto \\sigma_{\\min}(A - z I)$, where $I$ is the identity matrix and $z \\in \\mathbb{C}$. The $\\varepsilon$-pseudospectrum of $A$ in the matrix $2$-norm is defined as the set $\\Lambda_{\\varepsilon}(A) = \\{ z \\in \\mathbb{C} : \\sigma_{\\min}(A - z I) \\le \\varepsilon \\}$. This set coincides with the set of $z$ that are eigenvalues of $A + E$ for some perturbation $E$ with $\\|E\\|_2 \\le \\varepsilon$.\n\nStarting from the foundational definitions of singular values, the resolvent norm $\\|(A - zI)^{-1}\\|_2$ when $A - zI$ is invertible, and the definition of $\\varepsilon$-pseudospectra, derive an algorithm to compute discrete approximations to contours of the function $\\sigma_{\\min}(A - zI)$ on rectangular grids in the complex plane. Use these contours to reason about and quantify the extreme sensitivity of the eigenvalues of the Wilkinson companion matrix and its non-normality via the geometry of its pseudospectra. Your algorithm must:\n\n- Construct the Frobenius companion matrix $A$ for the monic polynomial with roots at $1,2,\\dots,20$.\n- For each rectangular grid window, evaluate $\\sigma_{\\min}(A - zI)$ at each grid point $z$.\n- For a given threshold $\\varepsilon$ in each test case, compute:\n  1. The minimum value of $\\sigma_{\\min}(A - zI)$ attained on the grid.\n  2. The fraction of grid points (expressed as a decimal, not a percentage) belonging to $\\Lambda_{\\varepsilon}(A)$, that is, those for which $\\sigma_{\\min}(A - zI) \\le \\varepsilon$.\n  3. The number of connected components (using $4$-neighbor connectivity on the grid graph) of the set of grid points where $\\sigma_{\\min}(A - zI) \\le \\varepsilon$, which serves as a discrete proxy for the connectivity of pseudospectral level sets. Two grid points are considered adjacent if their indices differ by exactly one in either the real or imaginary axis direction.\n\nYour program must implement this algorithm for the following test suite (each window is specified by real and imaginary bounds, grid resolution, and $\\varepsilon$):\n\n- Test case $1$ (cluster of roots near $8,9,10,11,12$):\n  - Real axis bounds: $[7, 12]$.\n  - Imaginary axis bounds: $[-\\tfrac{3}{2}, \\tfrac{3}{2}]$.\n  - Grid resolution: $41 \\times 41$ points.\n  - Threshold: $\\varepsilon = 10^{-6}$.\n\n- Test case $2$ (cluster near the smallest roots $1,2,3$):\n  - Real axis bounds: $[\\tfrac{1}{2}, \\tfrac{7}{2}]$.\n  - Imaginary axis bounds: $[-1, 1]$.\n  - Grid resolution: $41 \\times 41$ points.\n  - Threshold: $\\varepsilon = 10^{-8}$.\n\n- Test case $3$ (tight window around two consecutive roots $10,11$):\n  - Real axis bounds: $[\\tfrac{39}{4}, \\tfrac{45}{4}]$.\n  - Imaginary axis bounds: $[-\\tfrac{3}{4}, \\tfrac{3}{4}]$.\n  - Grid resolution: $41 \\times 41$ points.\n  - Threshold: $\\varepsilon = 10^{-7}$.\n\nScientific realism constraints:\n\n- All quantities are purely mathematical; no physical units apply.\n- Angles, if any arise, are to be in radians, but no angular quantities are required in this problem.\n\nFinal output specification:\n\n- Your program should produce a single line of output containing the results aggregated in the order of the test suite. For each test case, output the three values in the order described above: the minimum $\\sigma_{\\min}$ on the grid for that case, the fraction of points with $\\sigma_{\\min} \\le \\varepsilon$, and the number of connected components. The final output should be a comma-separated list enclosed in square brackets. For example, it should have the form $[\\text{min}_1,\\text{frac}_1,\\text{comp}_1,\\text{min}_2,\\text{frac}_2,\\text{comp}_2,\\text{min}_3,\\text{frac}_3,\\text{comp}_3]$, where each $\\text{min}_k$ is a floating-point number, each $\\text{frac}_k$ is a decimal, and each $\\text{comp}_k$ is an integer.", "solution": "The problem requires an analysis of the pseudospectra of the Frobenius companion matrix associated with the Wilkinson polynomial of degree $20$. This analysis serves to computationally demonstrate the extreme sensitivity of the eigenvalues of this highly non-normal matrix. A valid numerical algorithm will be derived and subsequently implemented.\n\nThe fundamental object of study is the $\\varepsilon$-pseudospectrum of a matrix $A \\in \\mathbb{C}^{n \\times n}$, defined for a given $\\varepsilon > 0$ as the set\n$$ \\Lambda_{\\varepsilon}(A) = \\{ z \\in \\mathbb{C} : \\|(A - zI)^{-1}\\|_2 \\ge \\varepsilon^{-1} \\}. $$\nHere, $\\| \\cdot \\|_2$ denotes the matrix $2$-norm (spectral norm). The resolvent norm $\\|(A - zI)^{-1}\\|_2$ is defined for all $z$ not in the spectrum of $A$, $\\Lambda(A)$. A key property connecting the resolvent norm to singular values is that for any square matrix $M$, $\\|M^{-1}\\|_2 = 1/\\sigma_{\\min}(M)$, where $\\sigma_{\\min}(M)$ is the smallest singular value of $M$. This allows for an equivalent and more computationally stable definition of the pseudospectrum, which is valid for all $z \\in \\mathbb{C}$:\n$$ \\Lambda_{\\varepsilon}(A) = \\{ z \\in \\mathbb{C} : \\sigma_{\\min}(A - zI) \\le \\varepsilon \\}. $$\nThis definition includes the eigenvalues themselves, where $\\sigma_{\\min}(A - \\lambda I) = 0$ for any $\\lambda \\in \\Lambda(A)$. The values of the function $z \\mapsto \\sigma_{\\min}(A - zI)$ form a surface over the complex plane, and the $\\varepsilon$-pseudospectrum consists of the regions where this surface dips below the height $\\varepsilon$.\n\nThe algorithmic procedure to solve the problem is as follows:\n\n**1. Construct the Wilkinson Companion Matrix $A$**\n\nThe problem specifies the monic Wilkinson polynomial of degree $n=20$, whose roots are the integers $1, 2, \\dots, 20$:\n$$ W_{20}(x) = \\prod_{j=1}^{20} (x - j). $$\nLet's expand this polynomial into the power basis: $W_{20}(x) = x^{20} + c_{19} x^{19} + \\dots + c_1 x + c_0$. The Frobenius companion matrix $A$ for this polynomial has the form:\n$$ A = \\begin{pmatrix}\n0  0  \\dots  0  -c_0 \\\\\n1  0  \\dots  0  -c_1 \\\\\n0  1  \\dots  0  -c_2 \\\\\n\\vdots  \\vdots  \\ddots  \\vdots  \\vdots \\\\\n0  0  \\dots  1  -c_{19}\n\\end{pmatrix} \\in \\mathbb{C}^{20 \\times 20}. $$\nThe characteristic polynomial of this matrix $A$ is precisely $W_{20}(x)$, so its eigenvalues are $\\lambda_j = j$ for $j=1, 2, \\dots, 20$. The coefficients $c_k$ can be computed numerically from the roots.\n\n**2. Evaluate $\\sigma_{\\min}(A-zI)$ on a Grid**\n\nFor each test case, we define a rectangular window in the complex plane with specified real bounds $[x_{\\min}, x_{\\max}]$ and imaginary bounds $[y_{\\min}, y_{\\max}]$. This window is discretized into a grid of $N_x \\times N_y$ points. In this problem, all grids have a resolution of $41 \\times 41$.\nThe grid points are given by $z_{jk} = x_j + \\mathrm{i}y_k$, where\n- $x_j = x_{\\min} + j \\frac{x_{\\max} - x_{\\min}}{N_x - 1}$ for $j=0, 1, \\dots, N_x-1$.\n- $y_k = y_{\\min} + k \\frac{y_{\\max} - y_{\\min}}{N_y - 1}$ for $k=0, 1, \\dots, N_y-1$.\n\nAt each grid point $z_{jk}$, we perform the following steps:\n- Form the shifted matrix $M_{jk} = A - z_{jk}I$.\n- Compute the singular values of $M_{jk}$. The smallest of these is $\\sigma_{\\min}(A - z_{jk}I)$.\n- Store this value in a $N_y \\times N_x$ matrix, $S$, where $S_{kj} = \\sigma_{\\min}(A - z_{jk}I)$.\n\n**3. Analyze the Computed Pseudospectral Data**\n\nThe matrix $S$ of $\\sigma_{\\min}$ values contains all the necessary information to compute the required quantities for each test case.\n\n**a. Minimum $\\sigma_{\\min}$ on the grid:**\nThis is found by taking the minimum value in the entire matrix $S$:\n$$ \\sigma_{\\min}^{\\text{grid}} = \\min_{j,k} S_{kj}. $$\n\n**b. Fraction of points in $\\Lambda_{\\varepsilon}(A)$:**\nFor a given threshold $\\varepsilon$, we identify the grid points belonging to the discrete approximation of the $\\varepsilon$-pseudospectrum. We create a binary mask $B$ where $B_{kj}=1$ if $S_{kj} \\le \\varepsilon$ and $B_{kj}=0$ otherwise. The fraction is the ratio of the number of such points to the total number of grid points:\n$$ f_{\\varepsilon} = \\frac{1}{N_x N_y} \\sum_{k=0}^{N_y-1} \\sum_{j=0}^{N_x-1} B_{kj}. $$\n\n**c. Number of Connected Components:**\nThis requires treating the binary mask $B$ as a grid graph. The vertices of the graph are the grid indices $(k, j)$ for which $B_{kj}=1$. An edge exists between two vertices $(k, j)$ and $(k', j')$ if they are adjacent on the grid, based on $4$-neighbor connectivity, i.e., $|k-k'| + |j-j'|=1$. The task is to count the number of connected components in this graph.\n\nAn effective algorithm for this is to iterate through each cell of the grid. If a cell $(k,j)$ with $B_{kj}=1$ is found that has not yet been visited as part of a component, we increment a component counter. Then, we initiate a graph traversal algorithm, such as Breadth-First Search (BFS) or Depth-First Search (DFS), starting from $(k,j)$ to find and mark all cells belonging to the same component. The process is repeated until all cells have been checked.\n\n- Initialize `count = 0` and a boolean `visited` grid of size $N_y \\times N_x$ to all `false`.\n- For $k$ from $0$ to $N_y-1$:\n    - For $j$ from $0$ to $N_x-1$:\n        - If $B_{kj}=1$ and `visited[k,j]` is `false`:\n            - Increment `count`.\n            - Start a BFS traversal from $(k,j)$:\n                - Create a queue and add $(k,j)$. Mark `visited[k,j]` as `true`.\n                - While the queue is not empty:\n                    - Dequeue a cell $(r,c)$.\n                    - For each of its $4$ neighbors $(r',c')$:\n                        - If the neighbor is within bounds, $B_{r'c'}=1$, and `visited[r',c']` is `false`:\n                            - Mark `visited[r',c']` as `true` and enqueue $(r',c')$.\n\nAfter iterating through all cells, `count` will hold the total number of connected components. This entire procedure is applied to each of the three test cases specified in the problem statement.", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import svdvals\nimport collections\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for pseudospectra analysis.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (cluster of roots near 8,9,10,11,12)\n        {\n            \"real_bounds\": [7.0, 12.0],\n            \"imag_bounds\": [-1.5, 1.5],\n            \"resolution\": (41, 41),\n            \"epsilon\": 1e-6,\n        },\n        # Test case 2 (cluster near smallest roots 1,2,3)\n        {\n            \"real_bounds\": [0.5, 3.5],\n            \"imag_bounds\": [-1.0, 1.0],\n            \"resolution\": (41, 41),\n            \"epsilon\": 1e-8,\n        },\n        # Test case 3 (tight window around two consecutive roots 10,11)\n        {\n            \"real_bounds\": [9.75, 11.25],\n            \"imag_bounds\": [-0.75, 0.75],\n            \"resolution\": (41, 41),\n            \"epsilon\": 1e-7,\n        },\n    ]\n\n    # Pre-compute the companion matrix as it's the same for all cases.\n    n = 20\n    roots = np.arange(1, n + 1, dtype=float)\n    # np.poly gives coefficients of (x-r1)(x-r2)...\n    # For a monic polynomial x^n + c_{n-1}x^{n-1} + ... + c_0,\n    # the coeffs are [1, c_{n-1}, ..., c_0]\n    coeffs = np.poly(roots)\n    # The last column of the companion matrix is [-c_0, -c_1, ..., -c_{n-1}]^T.\n    neg_coeffs = -coeffs[1:][::-1]\n    \n    A = np.diag(np.ones(n - 1), k=-1)\n    A[:, -1] = neg_coeffs\n\n    results = []\n    \n    for case in test_cases:\n        min_sigma, fraction, components = analyze_pseudospectrum(\n            A,\n            case[\"real_bounds\"],\n            case[\"imag_bounds\"],\n            case[\"resolution\"],\n            case[\"epsilon\"],\n        )\n        results.extend([min_sigma, fraction, components])\n\n    # Format the final output string.\n    output_str = f\"[{','.join(f'{val:.8g}' if isinstance(val, float) else str(val) for val in results)}]\"\n    print(output_str)\n\ndef analyze_pseudospectrum(A, real_bounds, imag_bounds, resolution, epsilon):\n    \"\"\"\n    Computes pseudospectral properties for a given matrix A on a specified grid.\n    \"\"\"\n    # 1. Setup grid and evaluate sigma_min\n    nx, ny = resolution\n    x_space = np.linspace(real_bounds[0], real_bounds[1], nx)\n    y_space = np.linspace(imag_bounds[0], imag_bounds[1], ny)\n    \n    sigma_min_grid = np.zeros((ny, nx))\n    identity = np.eye(A.shape[0])\n    \n    for i in range(ny):\n        for j in range(nx):\n            z = x_space[j] + 1j * y_space[i]\n            M = A - z * identity\n            # svdvals returns singular values in descending order. The min is the last.\n            s = svdvals(M)\n            sigma_min_grid[i, j] = s[-1]\n            \n    # 2. Analyze grid data\n    # 2.a. Minimum sigma_min on the grid\n    min_sigma_on_grid = np.min(sigma_min_grid)\n    \n    # 2.b. Fraction of points inside the epsilon-pseudospectrum\n    threshold_mask = sigma_min_grid = epsilon\n    fraction_inside = np.sum(threshold_mask) / (nx * ny)\n    \n    # 2.c. Number of connected components\n    num_components = count_connected_components(threshold_mask)\n    \n    return min_sigma_on_grid, fraction_inside, num_components\n\ndef count_connected_components(mask):\n    \"\"\"\n    Counts connected components in a boolean mask using 4-neighbor connectivity.\n    \"\"\"\n    rows, cols = mask.shape\n    visited = np.zeros_like(mask, dtype=bool)\n    count = 0\n    \n    for r in range(rows):\n        for c in range(cols):\n            if mask[r, c] and not visited[r, c]:\n                count += 1\n                q = collections.deque([(r, c)])\n                visited[r, c] = True\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        next_r, next_c = curr_r + dr, curr_c + dc\n                        if (0 = next_r  rows and \n                            0 = next_c  cols and \n                            mask[next_r, next_c] and not visited[next_r, next_c]):\n                            visited[next_r, next_c] = True\n                            q.append((next_r, next_c))\n    return count\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3568831"}, {"introduction": "While powerful, the brute-force grid algorithm can be computationally expensive and may fail to resolve the thin, filament-like \"fingers\" characteristic of highly non-normal pseudospectra if the grid is too coarse. This practice introduces a more sophisticated adaptive mesh refinement strategy that leverages a deep mathematical property: the function $u(z) = \\log \\|(zI - A)^{-1}\\|_{2}$ is subharmonic. By using the maximum principle associated with subharmonic functions, you will design and implement a \"smarter\" algorithm [@problem_id:3568841] that can certify that no pseudospectral features have been missed, leading to more reliable and efficient computations.", "problem": "Let $A \\in \\mathbb{C}^{n \\times n}$ be a given matrix. The $\\varepsilon$-pseudospectrum $\\Lambda_{\\varepsilon}(A)$ is defined by\n$$\n\\Lambda_{\\varepsilon}(A) = \\left\\{ z \\in \\mathbb{C} \\;:\\; \\sigma_{\\min}(zI - A) \\le \\varepsilon \\right\\},\n$$\nwhere $\\sigma_{\\min}(zI - A)$ denotes the smallest singular value of the matrix $zI - A$ and $I$ is the identity matrix. Equivalently, because the induced matrix $2$-norm satisfies $\\left\\|(zI - A)^{-1}\\right\\|_{2} = 1 / \\sigma_{\\min}(zI - A)$ when $zI - A$ is invertible, we have\n$$\nz \\in \\Lambda_{\\varepsilon}(A) \\iff \\left\\|(zI - A)^{-1}\\right\\|_{2} \\ge \\frac{1}{\\varepsilon}.\n$$\nDefine the function\n$$\nu(z) = \\log \\left\\|(zI - A)^{-1}\\right\\|_{2}.\n$$\nIt is a known and widely used fact in numerical linear algebra and complex analysis that $u(z)$ is subharmonic on the set of $z \\in \\mathbb{C}$ where $zI - A$ is invertible. Subharmonicity means that the Laplacian $\\Delta u(z) \\ge 0$ in the sense of distributions, and in particular $u$ obeys the maximum principle: the maximum of a subharmonic function on a closed bounded domain is attained on the boundary.\n\nYou are asked to design, implement, and test an adaptive mesh refinement strategy for sampling $u(z)$ over a rectangular domain in the complex plane to robustly approximate the level set $\\{z : u(z) = \\log(1/\\varepsilon)\\}$ that delimits $\\Lambda_{\\varepsilon}(A)$. The goal is to use subharmonicity to certify that the mesh has not missed thin protrusions (“fingers”) of the pseudospectrum.\n\nYour program must implement the following components:\n\n- A routine to compute $u(z)$ numerically using the relation $\\left\\|(zI - A)^{-1}\\right\\|_{2} = 1 / \\sigma_{\\min}(zI - A)$, where $\\sigma_{\\min}$ is obtained via the Singular Value Decomposition (SVD).\n- A uniform initial grid over a rectangle $[x_{\\min}, x_{\\max}] \\times [y_{\\min}, y_{\\max}] \\subset \\mathbb{R}^{2}$ of size $N_x \\times N_y$ in $(x,y)$ coordinates with $z = x + \\mathrm{i} y$.\n- A discrete maximum principle check based on the five-point finite difference Laplacian. Let $h_x = (x_{\\max} - x_{\\min})/(N_x - 1)$ and $h_y = (y_{\\max} - y_{\\min})/(N_y - 1)$. For interior grid indices $(i,j)$, define the discrete Laplacian\n$$\n\\Delta_h u_{i,j} = \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h_y^2}.\n$$\nYou must verify that $\\Delta_h u_{i,j} \\ge -\\tau$ for a specified tolerance $\\tau  0$ at all interior nodes; this discretized nonnegativity is used as a certificate that the discrete maximum principle holds to within numerical error.\n- An adaptive edge refinement scheme for each grid cell: With threshold $T = \\log(1/\\varepsilon)$, if all four corner values of $u$ are strictly below $T$, recursively sample midpoints on each of the four edges to certify that $u(z)  T$ along the entire boundary of the cell. Use a maximum recursion depth $L$; if at any sampled point on an edge $u(z) \\ge T$, the edge test fails. If all four edges pass, then, by the maximum principle for subharmonic functions, the interior of the cell cannot contain points with $u(z) \\ge T$, so no thin pseudospectral “finger” crosses the cell unseen. Cache previously computed values of $u(z)$ to avoid redundant SVDs.\n- A global certification rule per test case: return a boolean that is true if both conditions hold:\n  1. The discrete maximum principle check passes at all interior nodes (i.e., $\\Delta_h u_{i,j} \\ge -\\tau$).\n  2. For every cell whose four corners satisfy $u(z)  T$, all four edges have been certified below $T$ by the recursive edge refinement up to depth $L$.\n\nTest Suite:\nImplement three test cases that exercise different behaviors:\n\n- Test Case $1$ (normal, well-behaved): $A = \\mathrm{diag}(-2, -0.5, 1.5, 3.0)$ of size $n = 4$, domain $[x_{\\min}, x_{\\max}] = [-4, 4]$, $[y_{\\min}, y_{\\max}] = [-4, 4]$, grid $N_x = N_y = 33$, $\\varepsilon = 0.3$, recursion depth $L = 3$, tolerance $\\tau = 10^{-6}$. Expectation: the certification should succeed because $\\Lambda_{\\varepsilon}(A)$ is composed of approximately circular regions around the eigenvalues with no thin fingers.\n- Test Case $2$ (highly non-normal with fingers): $A$ is the Grcar matrix of size $n = 8$ (ones on the main diagonal and the first three superdiagonals, and minus ones on the subdiagonal), domain $[x_{\\min}, x_{\\max}] = [-2.5, 2.5]$, $[y_{\\min}, y_{\\max}] = [-2.5, 2.5]$, grid $N_x = N_y = 31$, $\\varepsilon = 0.05$, recursion depth $L = 2$, tolerance $\\tau = 10^{-6}$. Expectation: thin fingers are likely; the certification may fail if edges reveal boundary crossings above threshold that corners miss or if the discrete Laplacian check is violated.\n- Test Case $3$ (nearly normal): $A = \\mathrm{diag}(-1, 0, 1, 2) + 0.01 U$, where $U$ is strictly upper triangular with ones above the diagonal, size $n = 4$, domain $[x_{\\min}, x_{\\max}] = [-3, 3]$, $[y_{\\min}, y_{\\max}] = [-3, 3]$, grid $N_x = N_y = 33$, $\\varepsilon = 0.2$, recursion depth $L = 3$, tolerance $\\tau = 10^{-6}$. Expectation: certification should succeed due to mild non-normality.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,result_3]$), where each $result_k$ is a boolean indicating whether the certification succeeded for Test Case $k$.", "solution": "The problem requires the design and implementation of a certification algorithm for approximations of the $\\varepsilon$-pseudospectrum, $\\Lambda_{\\varepsilon}(A)$, of a square matrix $A \\in \\mathbb{C}^{n \\times n}$. The algorithm leverages the subharmonicity of the function $u(z) = \\log \\left\\|(zI - A)^{-1}\\right\\|_{2}$ to provide a guarantee that no \"fingers\" of the pseudospectrum are missed by a discrete grid sampling within a specified domain.\n\nThe principle of the solution is to construct a procedure that returns a boolean certificate. This certificate is `True` if and only if two conditions are met on a computational grid over a rectangular domain in the complex plane. First, a discrete version of the subharmonicity property must hold across the grid. Second, for every grid cell whose corners lie outside the target pseudospectrum region, the entire boundary of that cell must also be verified to lie outside. The maximum principle for subharmonic functions then ensures the interior of such a cell is also outside the region.\n\nThe solution is broken down into the following logical components.\n\nFirst, we define a function to compute $u(z)$. The $\\varepsilon$-pseudospectrum is defined as $\\Lambda_{\\varepsilon}(A) = \\left\\{ z \\in \\mathbb{C} \\;:\\; \\sigma_{\\min}(zI - A) \\le \\varepsilon \\right\\}$, where $\\sigma_{\\min}(\\cdot)$ is the smallest singular value. The resolvent norm is related by $\\left\\|(zI - A)^{-1}\\right\\|_{2} = 1 / \\sigma_{\\min}(zI - A)$ for $z$ not in the spectrum of $A$. The function $u(z)$ is thus given by $u(z) = \\log(1/\\sigma_{\\min}(zI - A)) = -\\log(\\sigma_{\\min}(zI - A))$. This is computed numerically by forming the matrix $M = zI - A$ for a given $z \\in \\mathbb{C}$ and finding its smallest singular value using a standard Singular Value Decomposition (SVD) algorithm. To avoid redundant, computationally expensive SVD calculations for the same $z$ value (which can occur during recursive edge checks), all computed values of $u(z)$ are stored in a cache.\n\nSecond, a uniform grid is established over the specified rectangular domain $[x_{\\min}, x_{\\max}] \\times [y_{\\min}, y_{\\max}]$. The grid has $N_x \\times N_y$ points, with spacings $h_x = (x_{\\max} - x_{\\min})/(N_x - 1)$ and $h_y = (y_{\\max} - y_{\\min})/(N_y - 1)$. The function $u(z)$ is evaluated at each of the $N_x \\times N_y$ grid points $z_{i,j} = (x_{\\min} + i h_x) + \\mathrm{i} (y_{\\min} + j h_y)$ for $i \\in \\{0, \\dots, N_x-1\\}$ and $j \\in \\{0, \\dots, N_y-1\\}$.\n\nThird, the first certification condition is checked. The theoretical subharmonicity of $u(z)$ implies its Laplacian $\\Delta u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} \\ge 0$. We verify a discrete analogue of this property using a five-point finite difference stencil for the Laplacian at each interior grid node $(i,j)$, where $i \\in \\{1,\\dots,N_x-2\\}$ and $j \\in \\{1,\\dots,N_y-2\\}$. The discrete Laplacian is:\n$$\n\\Delta_h u_{i,j} = \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h_y^2}\n$$\nwhere $u_{i,j}$ denotes the computed value at $z_{i,j}$. The certification requires that $\\Delta_h u_{i,j} \\ge -\\tau$ for all interior nodes, where $\\tau$ is a small positive tolerance to account for numerical floating-point errors. A failure of this check suggests that the grid is too coarse to accurately capture the curvature of the function $u(z)$.\n\nFourth, the second certification condition is checked. This involves an adaptive refinement on the boundaries of certain grid cells. A cell is a small rectangle defined by four adjacent grid points: $(z_{i,j}, z_{i+1,j}, z_{i,j+1}, z_{i+1,j+1})$. The boundary of the $\\varepsilon$-pseudospectrum corresponds to the level set where $\\left\\|(zI-A)^{-1}\\right\\|_2 = 1/\\varepsilon$, or equivalently, $u(z) = \\log(1/\\varepsilon)$. Let this threshold be $T = \\log(1/\\varepsilon)$.\nFor each cell, we first check the values of $u(z)$ at its four corners. If all four values are strictly less than $T$, the cell is a candidate for being entirely outside the pseudospectrum. By the maximum principle for subharmonic functions, if $u(z)  T$ for all $z$ on the boundary of the cell, then $u(z)  T$ for all $z$ in its interior. This would certify that no part of $\\Lambda_\\varepsilon(A)$ passes through the cell.\nTo verify that $u(z)  T$ on the boundary, we check each of the four edges. A recursive bisection method is used for this edge check. For an edge connecting points $z_1$ and $z_2$, we compute $u(z_m)$ at the midpoint $z_m = (z_1+z_2)/2$. If $u(z_m) \\ge T$, the edge check fails. Otherwise, we recursively check the two sub-edges $(z_1, z_m)$ and $(z_m, z_2)$. This recursion proceeds up to a specified maximum depth $L$. If the recursion completes to its maximum depth on all segments of an edge without finding any point $z$ where $u(z) \\ge T$, that edge is certified. If all four edges of a candidate cell are certified, the cell is certified.\n\nFinally, the global certification for a given test case is `True` if and only if both the discrete Laplacian check passes for all interior grid points and the edge refinement check passes for all relevant cells (i.e., those with corner values below $T$). If either check fails at any point, the global certification is `False`. This composite procedure provides a robust method for validating a computed pseudospectrum boundary, guarding against the possibility of a coarse grid missing fine, finger-like extensions characteristic of highly non-normal matrices. The provided test cases are designed to exercise the algorithm on matrices with varying degrees of non-normality.", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import svdvals\n\ndef compute_u(z, A, cache):\n    \"\"\"\n    Computes u(z) = log(||(zI - A)^-1||_2), caching the results.\n    \"\"\"\n    if z in cache:\n        return cache[z]\n    \n    n = A.shape[0]\n    M = z * np.identity(n) - A\n    \n    # Use scipy.linalg.svdvals for efficiency as we only need singular values.\n    # The smallest singular value is the last one if they are sorted.\n    # svdvals does not guarantee sorting, so we must take the minimum.\n    try:\n        singular_values = svdvals(M)\n        sigma_min = np.min(singular_values)\n    except np.linalg.LinAlgError:\n        # This can happen if the matrix contains inf or NaN, which is not expected\n        # here but good practice to handle.\n        sigma_min = 0.0\n\n    # If sigma_min is zero, u(z) is infinite.\n    if sigma_min  np.finfo(float).tiny: # Effectively zero\n        result = np.inf\n    else:\n        # u(z) = log(1/sigma_min) = -log(sigma_min)\n        result = -np.log(sigma_min)\n        \n    cache[z] = result\n    return result\n\ndef certify_edge(z1, z2, L, T, A, cache):\n    \"\"\"\n    Recursively checks if the edge between z1 and z2 is below threshold T.\n    L is the remaining recursion depth.\n    \"\"\"\n    if L == 0:\n        return True # Max depth reached without failure, certify this segment.\n    \n    zm = (z1 + z2) / 2.0\n    u_mid = compute_u(zm, A, cache)\n    \n    if u_mid = T:\n        return False # Midpoint is above threshold, edge test fails.\n        \n    # Recursively check the two halves of the segment.\n    left_half_ok = certify_edge(z1, zm, L - 1, T, A, cache)\n    if not left_half_ok:\n        return False\n        \n    right_half_ok = certify_edge(zm, z2, L - 1, T, A, cache)\n    return right_half_ok\n\ndef run_certification_test(A, x_range, y_range, N_xy, epsilon, L, tau):\n    \"\"\"\n    Performs the full certification test for a given matrix and parameters.\n    \"\"\"\n    Nx, Ny = N_xy\n    xmin, xmax = x_range\n    ymin, ymax = y_range\n    \n    T = np.log(1.0 / epsilon)\n    hx = (xmax - xmin) / (Nx - 1)\n    hy = (ymax - ymin) / (Ny - 1)\n    \n    # Cache for memoizing u(z) computations\n    cache = {}\n    \n    # 1. Compute u(z) on the initial grid\n    u_grid = np.zeros((Ny, Nx))\n    x_coords = np.linspace(xmin, xmax, Nx)\n    y_coords = np.linspace(ymin, ymax, Ny)\n    \n    for j in range(Ny):\n        for i in range(Nx):\n            z = x_coords[i] + 1j * y_coords[j]\n            u_grid[j, i] = compute_u(z, A, cache)\n            \n    # 2. Perform discrete maximum principle check (Laplacian)\n    laplacian_check_passed = True\n    if Nx  2 and Ny  2:\n        hx2, hy2 = hx**2, hy**2\n        for j in range(1, Ny - 1):\n            for i in range(1, Nx - 1):\n                u_center = u_grid[j, i]\n                u_east = u_grid[j, i+1]\n                u_west = u_grid[j, i-1]\n                u_north = u_grid[j+1, i]\n                u_south = u_grid[j-1, i]\n                \n                laplacian_u = (u_east - 2*u_center + u_west)/hx2 + \\\n                              (u_north - 2*u_center + u_south)/hy2\n                \n                if laplacian_u  -tau:\n                    laplacian_check_passed = False\n                    break\n            if not laplacian_check_passed:\n                break\n    \n    # 3. Perform adaptive edge refinement check\n    edge_check_passed = True\n    for j in range(Ny - 1):\n        for i in range(Nx - 1):\n            u00 = u_grid[j, i]\n            u01 = u_grid[j+1, i]\n            u10 = u_grid[j, i+1]\n            u11 = u_grid[j+1, i+1]\n            \n            # If all four corners are below the threshold, certify the cell's boundary\n            if u00  T and u01  T and u10  T and u11  T:\n                z00 = x_coords[i] + 1j * y_coords[j]\n                z10 = x_coords[i+1] + 1j * y_coords[j]\n                z01 = x_coords[i] + 1j * y_coords[j+1]\n                z11 = x_coords[i+1] + 1j * y_coords[j+1]\n                \n                # Check bottom edge\n                if not certify_edge(z00, z10, L, T, A, cache):\n                    edge_check_passed = False\n                    break\n                # Check top edge\n                if not certify_edge(z01, z11, L, T, A, cache):\n                    edge_check_passed = False\n                    break\n                # Check left edge\n                if not certify_edge(z00, z01, L, T, A, cache):\n                    edge_check_passed = False\n                    break\n                # Check right edge\n                if not certify_edge(z10, z11, L, T, A, cache):\n                    edge_check_passed = False\n                    break\n        if not edge_check_passed:\n            break\n            \n    return laplacian_check_passed and edge_check_passed\n\ndef solve():\n    # Test Case 1: Normal matrix\n    A1 = np.diag(np.array([-2.0, -0.5, 1.5, 3.0]))\n    \n    # Test Case 2: Grcar matrix (highly non-normal)\n    n2 = 8\n    A2 = (np.diag(np.ones(n2)) +\n          np.diag(np.ones(n2 - 1), 1) +\n          np.diag(np.ones(n2 - 2), 2) +\n          np.diag(np.ones(n2 - 3), 3) +\n          np.diag(-np.ones(n2 - 1), -1))\n\n    # Test Case 3: Nearly normal matrix\n    n3 = 4\n    D3 = np.diag(np.array([-1.0, 0.0, 1.0, 2.0]))\n    U3 = np.triu(np.ones((n3, n3)), k=1)\n    A3 = D3 + 0.01 * U3\n    \n    test_cases = [\n        {\n            \"A\": A1,\n            \"x_range\": (-4.0, 4.0), \"y_range\": (-4.0, 4.0), \"N_xy\": (33, 33),\n            \"epsilon\": 0.3, \"L\": 3, \"tau\": 1e-6\n        },\n        {\n            \"A\": A2,\n            \"x_range\": (-2.5, 2.5), \"y_range\": (-2.5, 2.5), \"N_xy\": (31, 31),\n            \"epsilon\": 0.05, \"L\": 2, \"tau\": 1e-6\n        },\n        {\n            \"A\": A3,\n            \"x_range\": (-3.0, 3.0), \"y_range\": (-3.0, 3.0), \"N_xy\": (33, 33),\n            \"epsilon\": 0.2, \"L\": 3, \"tau\": 1e-6\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_certification_test(**params)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3568841"}]}