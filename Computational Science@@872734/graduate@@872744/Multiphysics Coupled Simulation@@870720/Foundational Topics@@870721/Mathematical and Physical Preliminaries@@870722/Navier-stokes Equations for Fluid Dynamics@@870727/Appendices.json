{"hands_on_practices": [{"introduction": "A foundational challenge in the numerical solution of the incompressible Navier-Stokes equations is the stable coupling of pressure and velocity fields. When using a co-located grid, where all variables are stored at the same cell-center locations, a naive discretization of the pressure gradient can become blind to certain high-frequency pressure oscillations, a phenomenon known as checkerboarding. This analytical exercise [@problem_id:3354187] guides you through the use of discrete Fourier analysis to precisely diagnose this numerical pathology and to design a modified gradient operator that remedies the issue, providing crucial insight into the design of robust finite volume methods.", "problem": "Consider two-dimensional incompressible flow discretized by a co-located Finite Volume (FV) method on an infinite, uniform Cartesian grid with spacing $\\Delta$ in both directions. Let cell-centered pressure be denoted by $p_{i,j}$ at integer indices $(i,j) \\in \\mathbb{Z}^{2}$. In the standard co-located FV practice, the cell-centered discrete pressure gradient enters the momentum equations via face-normal differences of face-centered pressures formed from arithmetic averages of neighboring cell-centered values. Specifically, define face-centered pressures by\n$$\np_{i+\\frac{1}{2},j} \\equiv \\frac{1}{2}\\left(p_{i+1,j} + p_{i,j}\\right), \\qquad\np_{i,j+\\frac{1}{2}} \\equiv \\frac{1}{2}\\left(p_{i,j+1} + p_{i,j}\\right),\n$$\nand the cell-centered pressure gradient by\n$$\n\\left(\\frac{\\partial p}{\\partial x}\\right)_{i,j} \\equiv \\frac{p_{i+\\frac{1}{2},j} - p_{i-\\frac{1}{2},j}}{\\Delta}, \\qquad\n\\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j} \\equiv \\frac{p_{i,j+\\frac{1}{2}} - p_{i,j-\\frac{1}{2}}}{\\Delta}.\n$$\nYou will analyze the action of this discrete operator on Fourier modes and then design an alternative discrete gradient that breaks the pathological cancellation associated with pressure–velocity decoupling (checkerboarding), while avoiding excessive dissipation in the long-wave limit.\n\n1. Using discrete Fourier analysis, consider a pressure mode\n$$\np_{i,j} = \\hat{p} \\exp\\!\\left(i k_{x} i \\Delta + i k_{y} j \\Delta\\right),\n$$\nwhere $\\hat{p} \\in \\mathbb{C}$ and $(k_{x},k_{y}) \\in \\mathbb{R}^{2}$ are the wavenumbers. Derive the Fourier symbol (amplification factor) of the discrete $x$-gradient operator above, and show that for the Nyquist checkerboard mode $k_{x} = \\pi/\\Delta$ and $k_{y} = \\pi/\\Delta$, the face-normal pressure gradients vanish identically.\n\n2. To break this cancellation without resorting to a staggered arrangement, propose a modified discrete $x$-gradient operator that blends the centered difference and the forward difference with a small, dimensionless weight $\\alpha \\in \\mathbb{R}$,\n$$\n\\left(\\frac{\\partial p}{\\partial x}\\right)^{(\\alpha)}_{i,j} \\equiv (1-\\alpha)\\,\\frac{p_{i+1,j} - p_{i-1,j}}{2\\,\\Delta} \\;+\\; \\alpha\\,\\frac{p_{i+1,j} - p_{i,j}}{\\Delta}.\n$$\nDerive the corresponding Fourier symbol as a closed-form function of $k_{x}$, $\\Delta$, and $\\alpha$. Demonstrate analytically that this symbol is nonzero at $(k_{x},k_{y})=(\\pi/\\Delta,\\pi/\\Delta)$ and that, for small $k_{x}\\Delta$, the leading dissipative error scales like $\\alpha\\,k_{x}^{2}\\,\\Delta/2$, so it can be made small by taking $\\alpha$ sufficiently small. Conclude by providing the final closed-form expression for the Fourier symbol of your proposed blended $x$-gradient operator as your answer.\n\nYour final answer must be a single analytical expression. No rounding is required, and no units should be included in the final answer box.", "solution": "**Part 1: Analysis of the Standard Discrete Gradient**\n\nFirst, we establish the explicit form of the discrete $x$-gradient operator by substituting the definitions for face-centered pressures:\n$$\n\\left(\\frac{\\partial p}{\\partial x}\\right)_{i,j} = \\frac{p_{i+\\frac{1}{2},j} - p_{i-\\frac{1}{2},j}}{\\Delta} = \\frac{1}{\\Delta} \\left[ \\frac{1}{2}(p_{i+1,j} + p_{i,j}) - \\frac{1}{2}(p_{i,j} + p_{i-1,j}) \\right] = \\frac{p_{i+1,j} - p_{i-1,j}}{2\\Delta}\n$$\nThis reveals that the standard co-located scheme's pressure gradient is equivalent to a simple centered difference on the cell centers.\n\nTo find the Fourier symbol, we apply this operator to the given pressure mode $p_{i,j} = \\hat{p} \\exp(i k_{x} i \\Delta + i k_{y} j \\Delta)$. The action of a linear, shift-invariant discrete operator on a Fourier mode is to multiply the mode by a complex number, the Fourier symbol, which depends on the wavenumber(s). Let the discrete operator be denoted by $\\mathcal{D}_x$, so that $(\\frac{\\partial p}{\\partial x})_{i,j} = \\mathcal{D}_x[p_{i,j}]$. We have:\n$$\n\\mathcal{D}_x[p_{i,j}] = \\frac{1}{2\\Delta} \\left[ \\hat{p} \\exp(i k_{x} (i+1) \\Delta + i k_{y} j \\Delta) - \\hat{p} \\exp(i k_{x} (i-1) \\Delta + i k_{y} j \\Delta) \\right]\n$$\nFactoring out the original mode $p_{i,j}$ gives:\n$$\n\\mathcal{D}_x[p_{i,j}] = \\frac{1}{2\\Delta} \\left[ \\exp(i k_{x} \\Delta) - \\exp(-i k_{x} \\Delta) \\right] \\left( \\hat{p} \\exp(i k_{x} i \\Delta + i k_{y} j \\Delta) \\right)\n$$\n$$\n\\mathcal{D}_x[p_{i,j}] = \\frac{\\exp(i k_{x} \\Delta) - \\exp(-i k_{x} \\Delta)}{2\\Delta} p_{i,j}\n$$\nUsing Euler's formula, $\\sin(\\theta) = (\\exp(i\\theta) - \\exp(-i\\theta))/(2i)$, the expression simplifies to:\n$$\n\\mathcal{D}_x[p_{i,j}] = \\frac{2i\\sin(k_{x}\\Delta)}{2\\Delta} p_{i,j} = \\frac{i\\sin(k_{x}\\Delta)}{\\Delta} p_{i,j}\n$$\nThe Fourier symbol of the discrete $x$-gradient operator, which we denote as $G_x(k_x)$, is the multiplicative factor:\n$$\nG_x(k_x) = \\frac{i\\sin(k_{x}\\Delta)}{\\Delta}\n$$\nNow, we evaluate this symbol at the Nyquist wavenumber $k_{x} = \\pi/\\Delta$:\n$$\nG_x(\\pi/\\Delta) = \\frac{i\\sin((\\pi/\\Delta)\\Delta)}{\\Delta} = \\frac{i\\sin(\\pi)}{\\Delta} = 0\n$$\nBy symmetry, the symbol for the $y$-gradient is $G_y(k_y) = i\\sin(k_{y}\\Delta)/\\Delta$, which is also zero at $k_y = \\pi/\\Delta$. A pressure field with $k_x = \\pi/\\Delta$ and $k_y=\\pi/\\Delta$ has the form $p_{i,j} \\propto \\exp(i\\pi i + i\\pi j) = (-1)^{i+j}$, which is a high-frequency checkerboard pattern. Since the discrete gradient operator yields zero when applied to this mode, it is \"blind\" to such pressure fields. This means a checkerboard pressure field can exist in the discrete system without contributing to the momentum equations, which is the essence of pressure-velocity decoupling.\n\n**Part 2: Analysis of the Modified Discrete Gradient**\n\nThe proposed modified operator is:\n$$\n\\left(\\frac{\\partial p}{\\partial x}\\right)^{(\\alpha)}_{i,j} = (1-\\alpha)\\,\\frac{p_{i+1,j} - p_{i-1,j}}{2\\,\\Delta} \\;+\\; \\alpha\\,\\frac{p_{i+1,j} - p_{i,j}}{\\Delta}\n$$\nThis is a linear combination of the centered difference operator and a forward difference operator. The Fourier symbol of the combined operator is the same linear combination of the individual symbols. We already have the symbol for the centered part. For the forward difference part, $\\mathcal{D}_x^{FD}[p_{i,j}] = (p_{i+1,j} - p_{i,j})/\\Delta$, we have:\n$$\n\\mathcal{D}_x^{FD}[p_{i,j}] = \\frac{\\exp(i k_{x} \\Delta) - 1}{\\Delta} p_{i,j}\n$$\nSo its symbol is $(\\exp(i k_{x} \\Delta) - 1)/\\Delta$.\n\nThe Fourier symbol of the modified operator, $G_x^{(\\alpha)}(k_x)$, is therefore:\n$$\nG_x^{(\\alpha)}(k_x) = (1-\\alpha) \\left( \\frac{i\\sin(k_x\\Delta)}{\\Delta} \\right) + \\alpha \\left( \\frac{\\exp(i k_x \\Delta) - 1}{\\Delta} \\right)\n$$\nTo obtain a closed-form expression, we use $\\exp(i k_x \\Delta) = \\cos(k_x \\Delta) + i\\sin(k_x \\Delta)$:\n$$\nG_x^{(\\alpha)}(k_x) = \\frac{1}{\\Delta} \\left[ (1-\\alpha)i\\sin(k_x\\Delta) + \\alpha(\\cos(k_x\\Delta) + i\\sin(k_x\\Delta) - 1) \\right]\n$$\n$$\nG_x^{(\\alpha)}(k_x) = \\frac{1}{\\Delta} \\left[ i\\sin(k_x\\Delta) - i\\alpha\\sin(k_x\\Delta) + \\alpha\\cos(k_x\\Delta) + i\\alpha\\sin(k_x\\Delta) - \\alpha \\right]\n$$\n$$\nG_x^{(\\alpha)}(k_x) = \\frac{1}{\\Delta} \\left[ \\alpha(\\cos(k_x\\Delta) - 1) + i\\sin(k_x\\Delta) \\right]\n$$\nThis is the final closed-form expression for the Fourier symbol.\n\nNext, we demonstrate that this symbol is nonzero at the Nyquist mode $k_x = \\pi/\\Delta$.\n$$\nG_x^{(\\alpha)}(\\pi/\\Delta) = \\frac{1}{\\Delta} \\left[ \\alpha(\\cos(\\pi) - 1) + i\\sin(\\pi) \\right] = \\frac{1}{\\Delta} \\left[ \\alpha(-1 - 1) + i(0) \\right] = -\\frac{2\\alpha}{\\Delta}\n$$\nThis is nonzero for any $\\alpha \\neq 0$, which confirms that the modified scheme successfully senses the checkerboard mode and breaks the decoupling.\n\nFinally, we analyze the behavior for small $k_x\\Delta$. The symbol for the exact operator $\\partial/\\partial x$ is $i k_x$. We examine the Taylor series expansion of $G_x^{(\\alpha)}(k_x)$ for small $\\theta = k_x\\Delta$:\n$\\cos(\\theta) = 1 - \\frac{\\theta^2}{2!} + O(\\theta^4)$\n$\\sin(\\theta) = \\theta - \\frac{\\theta^3}{3!} + O(\\theta^5)$\nSubstituting these into the symbol expression:\n$$\nG_x^{(\\alpha)}(k_x) = \\frac{1}{\\Delta} \\left[ \\alpha\\left(\\left(1-\\frac{(k_x\\Delta)^2}{2}\\right) - 1\\right) + i\\left(k_x\\Delta - \\frac{(k_x\\Delta)^3}{6}\\right) + O((k_x\\Delta)^4) \\right]\n$$\n$$\nG_x^{(\\alpha)}(k_x) = \\frac{1}{\\Delta} \\left[ -\\frac{\\alpha(k_x\\Delta)^2}{2} + i k_x\\Delta - i\\frac{(k_x\\Delta)^3}{6} + O((k_x\\Delta)^4) \\right]\n$$\n$$\nG_x^{(\\alpha)}(k_x) = -\\frac{\\alpha k_x^2 \\Delta}{2} + i k_x - i\\frac{k_x^3 \\Delta^2}{6} + O(k_x^4\\Delta^3)\n$$\nThe error is $E(k_x) = G_x^{(\\alpha)}(k_x) - i k_x = -\\frac{\\alpha k_x^2 \\Delta}{2} - i\\frac{k_x^3 \\Delta^2}{6} + \\dots$.\nThe real part of the leading error term, $\\Re(E(k_x)) \\approx -\\frac{\\alpha k_x^2 \\Delta}{2}$, corresponds to numerical dissipation. Its magnitude scales as $\\alpha k_x^2 \\Delta/2$, as required. This dissipation is analogous to adding a term proportional to $\\alpha \\frac{\\partial^2 p}{\\partial x^2}$ to the operator, which damps high-frequency oscillations and stabilizes the scheme, but at the cost of introducing a second-order error. The parameter $\\alpha$ allows for control over the amount of this added dissipation.\n\nThe final answer requested is the closed-form expression for the Fourier symbol of the proposed blended operator.", "answer": "$$\n\\boxed{\\frac{1}{\\Delta} \\left[ \\alpha(\\cos(k_x\\Delta) - 1) + i\\sin(k_x\\Delta) \\right]}\n$$", "id": "3354187"}, {"introduction": "Theoretical analysis of a numerical scheme is necessary, but not sufficient; rigorous verification of its software implementation is an equally critical step in computational science. This practice [@problem_id:3517703] introduces the Method of Manufactured Solutions (MMS), a powerful technique for code verification. You will define a smooth, analytical solution for the Stokes equations and derive the corresponding body force term, creating a benchmark problem with a known solution to test against your numerical implementation and quantitatively assess its accuracy.", "problem": "Consider the incompressible, steady Stokes equations for a Newtonian fluid in two spatial dimensions on the unit square domain $\\Omega = (0,1)\\times(0,1)$, with position vector $\\mathbf{x} = (x,y)$, velocity field $\\mathbf{u}(\\mathbf{x}) = (u(\\mathbf{x}), v(\\mathbf{x}))$, pressure field $p(\\mathbf{x})$, dynamic viscosity $\\mu > 0$, body force $\\mathbf{f}(\\mathbf{x}) = (f_1(\\mathbf{x}), f_2(\\mathbf{x}))$, and boundary velocity data $\\mathbf{g}$:\n$$\n-\\mu \\nabla^2 \\mathbf{u} + \\nabla p = \\mathbf{f} \\quad \\text{in } \\Omega,\\qquad \\nabla \\cdot \\mathbf{u} = 0 \\quad \\text{in } \\Omega,\\qquad \\mathbf{u} = \\mathbf{g} \\quad \\text{on } \\partial\\Omega.\n$$\nThe problem is framed in nondimensional variables; no physical units are required. Angles in all trigonometric functions must be in radians.\n\nDesign a manufactured-analytic benchmark for Stokes flow in a square cavity that is strictly divergence-free and satisfies homogeneous Dirichlet (no-slip) boundary conditions by prescribing\n$$\nu(x,y) = \\sin^2(\\pi x)\\,\\sin(2\\pi y),\\qquad v(x,y) = -\\sin(2\\pi x)\\,\\sin^2(\\pi y),\\qquad p(x,y) = \\cos(\\pi x)\\,\\cos(\\pi y),\n$$\non $\\Omega$. Define $\\mathbf{g} = \\mathbf{u}\\vert_{\\partial\\Omega}$ and compute the forcing $\\mathbf{f}$ by substituting $\\mathbf{u}$ and $p$ into the Stokes momentum balance. Your manufactured solution must be used to numerically verify discrete incompressibility and momentum balance on a collocated, structured grid.\n\nStarting from the standard conservation laws of mass and momentum for incompressible flow, construct the body force $\\mathbf{f}$ implied by your manufactured fields. Then, given a uniform grid with $N_x$ points in the $x$-direction and $N_y$ points in the $y$-direction, with spacings $h_x = 1/(N_x-1)$ and $h_y = 1/(N_y-1)$, perform the following verifications using second-order, centered finite differences on interior points:\n- Compute the discrete divergence\n$$\n(\\nabla_h\\cdot \\mathbf{u})_{i,j} = \\frac{u_{i+1,j} - u_{i-1,j}}{2 h_x} + \\frac{v_{i,j+1} - v_{i,j-1}}{2 h_y},\n$$\nand report the maximum absolute value over all interior indices $(i,j)$, which quantifies the discrete divergence-free property.\n- Compute the discrete momentum residual\n$$\n\\mathbf{r}_{i,j} = \\begin{pmatrix}\n-\\mu \\left(\\frac{u_{i+1,j} - 2 u_{i,j} + u_{i-1,j}}{h_x^2} + \\frac{u_{i,j+1} - 2 u_{i,j} + u_{i,j-1}}{h_y^2}\\right) + \\frac{p_{i+1,j} - p_{i-1,j}}{2 h_x} - f_{1;i,j} \\\\\n-\\mu \\left(\\frac{v_{i+1,j} - 2 v_{i,j} + v_{i-1,j}}{h_x^2} + \\frac{v_{i,j+1} - 2 v_{i,j} + v_{i,j-1}}{h_y^2}\\right) + \\frac{p_{i,j+1} - p_{i,j-1}}{2 h_y} - f_{2;i,j}\n\\end{pmatrix},\n$$\nusing the manufactured $\\mathbf{f}$ and $p$. Report the maximum of the Euclidean norm $\\|\\mathbf{r}_{i,j}\\|_2$ over all interior indices, which quantifies discrete momentum balance accuracy.\n\nYou must implement a program that:\n- Evaluates the analytic fields $u(x,y)$, $v(x,y)$, and $p(x,y)$ at grid nodes $(x_i, y_j)$ and computes the analytic forcing $\\mathbf{f}(x,y)$ by differentiating the manufactured solution according to the Stokes momentum balance.\n- Computes the above two verification metrics on interior nodes for each test case in the test suite.\n- Produces a single line of output that aggregates the results of all provided test cases into a comma-separated list of floating-point numbers enclosed in square brackets. The numbers must be ordered in pairs for each test case: first the maximum absolute discrete divergence, then the maximum Euclidean norm of the discrete momentum residual. The final output format must therefore be\n$$\n[\\text{div}_{1},\\text{res}_{1},\\text{div}_{2},\\text{res}_{2},\\ldots,\\text{div}_{T},\\text{res}_{T}],\n$$\nwhere $T$ is the number of test cases.\n\nUse the following test suite that probes different aspects of the discretization:\n- Case $1$: $N_x = 16$, $N_y = 16$, $\\mu = 1$ (general case).\n- Case $2$: $N_x = 32$, $N_y = 32$, $\\mu = 1$ (refined grid to test error decay).\n- Case $3$: $N_x = 8$, $N_y = 8$, $\\mu = 0.1$ (coarse grid with smaller viscosity).\n- Case $4$: $N_x = 64$, $N_y = 16$, $\\mu = 10$ (anisotropic grid and large viscosity).\n- Case $5$: $N_x = 4$, $N_y = 4$, $\\mu = 1$ (very coarse boundary-limited interior).\n\nAll computations are nondimensional. Angles must be in radians. For each test case, your program must output two floating-point values as specified. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[\\text{result}_1,\\text{result}_2,\\text{result}_3]$).", "solution": "The Method of Manufactured Solutions (MMS) involves defining an analytic solution for the primary fields, $\\mathbf{u}(\\mathbf{x})$ and $p(\\mathbf{x})$, and substituting them into the governing partial differential equations to compute a corresponding source or forcing term, $\\mathbf{f}(\\mathbf{x})$. This creates a benchmark problem where the exact solution is known a priori.\n\nThe manufactured solution fields are given by:\n$$u(x,y) = \\sin^2(\\pi x)\\,\\sin(2\\pi y)$$\n$$v(x,y) = -\\sin(2\\pi x)\\,\\sin^2(\\pi y)$$\n$$p(x,y) = \\cos(\\pi x)\\,\\cos(\\pi y)$$\non the domain $\\Omega = (0,1)\\times(0,1)$.\n\nFirst, we verify that the manufactured velocity field $\\mathbf{u} = (u, v)$ is consistent with the problem's physical constraints.\nThe incompressibility constraint, $\\nabla \\cdot \\mathbf{u} = 0$, is satisfied analytically:\n$$\\frac{\\partial u}{\\partial x} = \\frac{\\partial}{\\partial x} \\left( \\sin^2(\\pi x)\\,\\sin(2\\pi y) \\right) = 2\\pi\\sin(\\pi x)\\cos(\\pi x)\\sin(2\\pi y) = \\pi\\sin(2\\pi x)\\sin(2\\pi y)$$\n$$\\frac{\\partial v}{\\partial y} = \\frac{\\partial}{\\partial y} \\left( -\\sin(2\\pi x)\\,\\sin^2(\\pi y) \\right) = -2\\pi\\sin(2\\pi x)\\sin(\\pi y)\\cos(\\pi y) = -\\pi\\sin(2\\pi x)\\sin(2\\pi y)$$\n$$\\nabla \\cdot \\mathbf{u} = \\frac{\\partial u}{\\partial x} + \\frac{\\partial v}{\\partial y} = \\pi\\sin(2\\pi x)\\sin(2\\pi y) - \\pi\\sin(2\\pi x)\\sin(2\\pi y) = 0$$\nThe homogeneous Dirichlet (no-slip) boundary condition, $\\mathbf{u} = \\mathbf{0}$ on $\\partial\\Omega$, is also satisfied. For any point on the boundary $\\partial\\Omega$, either $x \\in \\{0, 1\\}$ or $y \\in \\{0, 1\\}$.\nFor $u(x,y) = \\sin^2(\\pi x)\\sin(2\\pi y)$, if $x=0$ or $x=1$, $\\sin^2(\\pi x)=0$. If $y=0$ or $y=1$, $\\sin(2\\pi y)=0$. Thus, $u=0$ on $\\partial\\Omega$.\nFor $v(x,y) = -\\sin(2\\pi x)\\sin^2(\\pi y)$, if $x=0$ or $x=1$, $\\sin(2\\pi x)=0$. If $y=0$ or $y=1$, $\\sin^2(\\pi y)=0$. Thus, $v=0$ on $\\partial\\Omega$.\n\nNext, we derive the analytic body force $\\mathbf{f} = (f_1, f_2)$ by substituting the manufactured fields into the Stokes momentum equation, $\\mathbf{f} = -\\mu \\nabla^2 \\mathbf{u} + \\nabla p$. This requires computing the Laplacian of the velocity components, $\\nabla^2 u$ and $\\nabla^2 v$, and the gradient of the pressure, $\\nabla p$.\n\nFor the $u$-component of velocity:\n$$\\frac{\\partial^2 u}{\\partial x^2} = \\frac{\\partial}{\\partial x} \\left( \\pi\\sin(2\\pi x)\\sin(2\\pi y) \\right) = 2\\pi^2\\cos(2\\pi x)\\sin(2\\pi y)$$\n$$\\frac{\\partial^2 u}{\\partial y^2} = \\frac{\\partial}{\\partial y} \\left( 2\\pi\\sin^2(\\pi x)\\cos(2\\pi y) \\right) = -4\\pi^2\\sin^2(\\pi x)\\sin(2\\pi y)$$\n$$\\nabla^2 u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} = 2\\pi^2\\cos(2\\pi x)\\sin(2\\pi y) - 4\\pi^2\\sin^2(\\pi x)\\sin(2\\pi y)$$\n\nFor the $v$-component of velocity:\n$$\\frac{\\partial^2 v}{\\partial x^2} = \\frac{\\partial}{\\partial x} \\left( -2\\pi\\cos(2\\pi x)\\sin^2(\\pi y) \\right) = 4\\pi^2\\sin(2\\pi x)\\sin^2(\\pi y)$$\n$$\\frac{\\partial^2 v}{\\partial y^2} = \\frac{\\partial}{\\partial y} \\left( -\\pi\\sin(2\\pi x)\\sin(2\\pi y) \\right) = -2\\pi^2\\sin(2\\pi x)\\cos(2\\pi y)$$\n$$\\nabla^2 v = \\frac{\\partial^2 v}{\\partial x^2} + \\frac{\\partial^2 v}{\\partial y^2} = 4\\pi^2\\sin(2\\pi x)\\sin^2(\\pi y) - 2\\pi^2\\sin(2\\pi x)\\cos(2\\pi y)$$\n\nFor the pressure field:\n$$\\frac{\\partial p}{\\partial x} = -\\pi\\sin(\\pi x)\\cos(\\pi y)$$\n$$\\frac{\\partial p}{\\partial y} = -\\pi\\cos(\\pi x)\\sin(\\pi y)$$\n\nCombining these terms gives the components of the forcing vector $\\mathbf{f}$:\n$$f_1(x,y) = -\\mu \\nabla^2 u + \\frac{\\partial p}{\\partial x} = -\\mu\\left(2\\pi^2\\cos(2\\pi x)\\sin(2\\pi y) - 4\\pi^2\\sin^2(\\pi x)\\sin(2\\pi y)\\right) - \\pi\\sin(\\pi x)\\cos(\\pi y)$$\n$$f_2(x,y) = -\\mu \\nabla^2 v + \\frac{\\partial p}{\\partial y} = -\\mu\\left(4\\pi^2\\sin(2\\pi x)\\sin^2(\\pi y) - 2\\pi^2\\sin(2\\pi x)\\cos(2\\pi y)\\right) - \\pi\\cos(\\pi x)\\sin(\\pi y)$$\n\nThe numerical verification proceeds as follows:\nFor each test case, defined by $(N_x, N_y, \\mu)$, a uniform grid is constructed. The grid has nodal coordinates $(x_i, y_j) = (i h_x, j h_y)$ for $i \\in \\{0, \\dots, N_x-1\\}$ and $j \\in \\{0, \\dots, N_y-1\\}$, with grid spacings $h_x = 1/(N_x-1)$ and $h_y = 1/(N_y-1)$.\nThe analytic fields $u$, $v$, $p$, and the derived forcing components $f_1$, $f_2$ are evaluated at all grid nodes $(x_i, y_j)$ to obtain discrete fields $u_{i,j}$, $v_{i,j}$, $p_{i,j}$, $f_{1;i,j}$, and $f_{2;i,j}$.\n\nThe two verification metrics are computed on the set of interior grid nodes, where $i \\in \\{1, \\dots, N_x-2\\}$ and $j \\in \\{1, \\dots, N_y-2\\}$.\n$1$. The discrete divergence, $(\\nabla_h\\cdot \\mathbf{u})_{i,j}$, is computed using the provided second-order centered difference formula. The maximum absolute value of this quantity over all interior nodes is calculated. This metric quantifies how well the discrete velocity field satisfies the incompressibility constraint. The error is expected to be small, approaching zero as $h_x, h_y \\to 0$.\n$2$. The discrete momentum residual, $\\mathbf{r}_{i,j}$, is computed using second-order centered stencils for the Laplacian and gradient operators. This residual represents the truncation error of the discretization since the analytic solution, by construction, makes the continuous equation equal to zero. The maximum of the Euclidean norm $\\|\\mathbf{r}_{i,j}\\|_2$ over all interior nodes is calculated. This metric measures the accuracy of the momentum balance discretization. Since the stencils are second-order, this error is expected to decay as $O(h_x^2 + h_y^2)$.\n\nThe implementation performs these calculations for each test case specified in the problem statement, utilizing vectorized array operations for efficiency. The final output is a list containing pairs of the two metrics for each case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Stokes manufactured solution problem for a given set of test cases.\n    \"\"\"\n\n    def u_analytic(X, Y):\n        \"\"\"Analytic solution for u-velocity.\"\"\"\n        return np.sin(np.pi * X)**2 * np.sin(2 * np.pi * Y)\n\n    def v_analytic(X, Y):\n        \"\"\"Analytic solution for v-velocity.\"\"\"\n        return -np.sin(2 * np.pi * X) * np.sin(np.pi * Y)**2\n    \n    def p_analytic(X, Y):\n        \"\"\"Analytic solution for pressure.\"\"\"\n        return np.cos(np.pi * X) * np.cos(np.pi * Y)\n\n    def f1_analytic(X, Y, mu):\n        \"\"\"Analytic forcing term f1 from the momentum equation.\"\"\"\n        pi = np.pi\n        term1 = -mu * (2*pi**2 * np.cos(2*pi*X) * np.sin(2*pi*Y) - 4*pi**2 * np.sin(pi*X)**2 * np.sin(2*pi*Y))\n        term2 = -pi * np.sin(pi*X) * np.cos(pi*Y)\n        return term1 + term2\n\n    def f2_analytic(X, Y, mu):\n        \"\"\"Analytic forcing term f2 from the momentum equation.\"\"\"\n        pi = np.pi\n        term1 = -mu * (4*pi**2 * np.sin(2*pi*X) * np.sin(pi*Y)**2 - 2*pi**2 * np.sin(2*pi*X) * np.cos(2*pi*Y))\n        term2 = -pi * np.cos(pi*X) * np.sin(pi*Y)\n        return term1 + term2\n\n    def compute_metrics(Nx, Ny, mu):\n        \"\"\"\n        Computes the discrete divergence and momentum residual metrics for a given grid and viscosity.\n        \"\"\"\n        if Nx  4 or Ny  4:\n            # The problem definition implies interior points exist. The smallest case is 4x4.\n            # An interior grid of (Nx-2)x(Ny-2) requires Nx,Ny>=3. The stencils need Nx,Ny>=3.\n            # For this problem, min(Nx,Ny)=4 guarantees an interior.\n            # A 2x2 interior grid for the 4x4 case.\n            # Slicing like u[2:, 1:-1] works as long as Nx>=3, Ny>=3.\n            pass\n\n        # Grid setup\n        hx = 1.0 / (Nx - 1)\n        hy = 1.0 / (Ny - 1)\n        x = np.linspace(0, 1, Nx)\n        y = np.linspace(0, 1, Ny)\n        X, Y = np.meshgrid(x, y, indexing='ij')\n\n        # Evaluate analytic fields on the grid\n        u = u_analytic(X, Y)\n        v = v_analytic(X, Y)\n        p = p_analytic(X, Y)\n        f1 = f1_analytic(X, Y, mu)\n        f2 = f2_analytic(X, Y, mu)\n        \n        # --- Metric 1: Discrete Divergence ---\n        # Slices correspond to interior points (i in 1..Nx-2, j in 1..Ny-2)\n        # and their neighbors needed for the stencils.\n        du_dx = (u[2:, 1:-1] - u[:-2, 1:-1]) / (2 * hx)\n        dv_dy = (v[1:-1, 2:] - v[1:-1, :-2]) / (2 * hy)\n        \n        div_h = du_dx + dv_dy\n        max_abs_div = np.max(np.abs(div_h))\n\n        # --- Metric 2: Discrete Momentum Residual ---\n        u_int = u[1:-1, 1:-1]\n        v_int = v[1:-1, 1:-1]\n        \n        # Laplacian calculation\n        lap_u = ((u[2:, 1:-1] - 2*u_int + u[:-2, 1:-1]) / hx**2 +\n                 (u[1:-1, 2:] - 2*u_int + u[1:-1, :-2]) / hy**2)\n        \n        lap_v = ((v[2:, 1:-1] - 2*v_int + v[:-2, 1:-1]) / hx**2 +\n                 (v[1:-1, 2:] - 2*v_int + v[1:-1, :-2]) / hy**2)\n\n        # Gradient of pressure calculation\n        grad_p_x = (p[2:, 1:-1] - p[:-2, 1:-1]) / (2 * hx)\n        grad_p_y = (p[1:-1, 2:] - p[1:-1, :-2]) / (2 * hy)\n\n        # Forcing on interior\n        f1_int = f1[1:-1, 1:-1]\n        f2_int = f2[1:-1, 1:-1]\n        \n        # Residual components\n        res_x = -mu * lap_u + grad_p_x - f1_int\n        res_y = -mu * lap_v + grad_p_y - f2_int\n        \n        # Euclidean norm of the residual\n        res_norm = np.sqrt(res_x**2 + res_y**2)\n        max_res_norm = np.max(res_norm)\n        \n        return max_abs_div, max_res_norm\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (16, 16, 1.0),\n        (32, 32, 1.0),\n        (8, 8, 0.1),\n        (64, 16, 10.0),\n        (4, 4, 1.0)\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, Ny, mu = case\n        div_val, res_val = compute_metrics(Nx, Ny, mu)\n        results.append(div_val)\n        results.append(res_val)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3517703"}, {"introduction": "Real-world engineering problems often involve the interaction of multiple physical domains, such as the coupling between a fluid and a deformable solid. Solving such fluid-structure interaction (FSI) problems monolithically leads to large, block-structured linear systems that are notoriously ill-conditioned. This advanced exercise [@problem_id:3517726] challenges you to confront this issue by designing and numerically validating a block-diagonal preconditioner. By approximating the Schur complement, you will develop a computationally scalable strategy, a skill essential for developing efficient solvers for complex multiphysics simulations.", "problem": "You are asked to design, analyze, and numerically validate a scalable preconditioner for the monolithic Jacobian of an incompressible fluid coupled to a linear elastic solid. Your starting point must be the conservation of linear momentum and the incompressibility constraint for the fluid, and the balance of linear momentum for the solid in the small-strain regime. You must express the coupled discrete Jacobian in a block form and use a block factorization argument to motivate a preconditioner that replaces exact Schur complements with spectrally equivalent approximations. Then you must implement a program that assembles a model discrete operator and computes extremal generalized eigenvalues of the preconditioned system over a small test suite to demonstrate spectral equivalence that is robust with respect to mesh refinement and parameter variations.\n\nThe task is purely mathematical and algorithmic. No physical units are required in the final answer since the operators are nondimensionalized. Angles are not used. The output must be numerical and finite.\n\nThe problem consists of the following steps.\n\n- Governing principles and block form:\n  1. Begin from the conservation of linear momentum and incompressibility for a Newtonian fluid with velocity vector $u$ and pressure $p$, linearized about a steady state with negligible convective term so that the fluid momentum operator is a diffusion operator with viscosity $\\mu$. State the incompressibility constraint as $\\nabla \\cdot u = 0$. For the solid, begin from the balance of linear momentum for small strains with Lamé parameters $\\lambda_{s}$ and $\\mu_{s}$, and displacement vector $d$.\n  2. Consider a symmetric linear coupling between fluid velocity and solid displacement modeling a kinematic/Robin-type interface condition. Represent this coupling in the Jacobian as a symmetric block $C$ of strength $\\gamma$.\n  3. Assemble the coupled monolithic Jacobian in block form as a $3 \\times 3$ block matrix operating on the concatenated vector of unknowns $[u; p; d]$:\n     $$\n     J \\;=\\;\n     \\begin{bmatrix}\n     A  B^{\\top}  C^{\\top} \\\\\n     B  0  0 \\\\\n     C  0  K\n     \\end{bmatrix},\n     $$\n     where $A$ is the discrete fluid momentum operator, $B$ is the discrete divergence operator, and $K$ is the discrete linear elasticity operator.\n\n- Discretization model to implement:\n  1. Let the domain be the unit square with homogeneous Dirichlet boundary conditions. Discretize all fields on the same Cartesian grid of $N \\times N$ interior points with mesh size $h = 1/(N+1)$.\n  2. Build the scalar $2$-dimensional Laplacian $L \\in \\mathbb{R}^{n \\times n}$ with $n = N^{2}$ using the standard $5$-point stencil with Dirichlet boundaries. Build centered discrete first-derivative operators $D_{x}, D_{y} \\in \\mathbb{R}^{n \\times n}$ with stencil coefficients $\\pm 1/(2h)$ on the super- and sub-diagonals in each coordinate direction, imposing homogeneous Dirichlet values outside the grid so that $D_{x}$ and $D_{y}$ are sparse with appropriate boundary treatment.\n  3. Form the fluid momentum block $A \\in \\mathbb{R}^{2n \\times 2n}$ as a vector Laplacian $A = \\mu \\,\\mathrm{blkdiag}(L, L)$ acting on the two components of the velocity.\n  4. Form the discrete divergence $B \\in \\mathbb{R}^{n \\times 2n}$ as $B = [\\, D_{x} \\;\\; D_{y} \\,]$. To remove the pressure nullspace, eliminate one pressure degree of freedom (for example, drop the last row of $B$ and the corresponding entry of the pressure mass) so that the reduced $B \\in \\mathbb{R}^{(n-1) \\times 2n}$ is full row rank.\n  5. Form the linear elasticity block $K \\in \\mathbb{R}^{2n \\times 2n}$ for small-strain isotropic elasticity as\n     $$\n     K \\;=\\; \\mu_{s} \\,\\mathrm{blkdiag}(L, L) \\;+\\; (\\lambda_{s}+\\mu_{s})\n     \\begin{bmatrix}\n     D_{x}^{\\top} D_{x}  D_{x}^{\\top} D_{y} \\\\\n     D_{y}^{\\top} D_{x}  D_{y}^{\\top} D_{y}\n     \\end{bmatrix}.\n     $$\n  6. Form the coupling block $C \\in \\mathbb{R}^{2n \\times 2n}$ as $C = \\gamma \\, I_{2n}$, where $I_{2n}$ is the $2n \\times 2n$ identity matrix.\n\n- Preconditioner design via block factorization with Schur complement approximations:\n  1. Using block Gaussian elimination on $J$, the exact pressure Schur complement is $S_{p} = B A^{-1} B^{\\top}$. A common and scalable approximation is a scaled pressure mass matrix $S_{p} \\approx \\widehat{S}_{p} = \\mu^{-1} M_{p}$, where $M_{p} \\in \\mathbb{R}^{(n-1) \\times (n-1)}$ is the reduced pressure mass matrix. For the uniform grid, take $M_{p} = h^{2} I_{n-1}$.\n  2. Define the block diagonal preconditioner\n     $$\n     P \\;=\\; \\mathrm{blkdiag}\\!\\left(\\, \\widehat{A},\\; \\widehat{S}_{p},\\; \\widehat{K} \\,\\right),\n     $$\n     with $\\widehat{A} = A$ and $\\widehat{K} = K$, and $\\widehat{S}_{p} = \\mu^{-1} M_{p}$.\n  3. The preconditioned operator is the generalized symmetric eigenproblem $J x = \\lambda P x$, which is similar to the symmetric matrix $P^{-1/2} J P^{-1/2}$. Spectral equivalence means the spectrum of $P^{-1/2} J P^{-1/2}$ is contained in a union of intervals $[-\\beta_{2}, -\\beta_{1}] \\cup [\\alpha_{1}, \\alpha_{2}]$ with constants independent of $N$, $h$, and the parameters in the test suite, provided the Schur complement approximation is spectrally equivalent to $S_{p}$ and $A$, $K$ are well-conditioned with respect to their approximations.\n\n- What you must compute and report:\n  1. For each test case, compute two scalars:\n     - The smallest magnitude generalized eigenvalue $\\min_{\\ell} |\\lambda_{\\ell}|$ of $J x = \\lambda P x$, estimated by computing $k$ eigenvalues closest to zero using shift-invert with $\\sigma = 0$ and taking the minimum absolute value among them, where $k = 6$.\n     - The largest magnitude generalized eigenvalue $\\max_{\\ell} |\\lambda_{\\ell}|$, estimated by computing $k$ eigenvalues from both spectrum ends (largest algebraic positive and most negative) and taking the maximum absolute value among them, where $k = 6$.\n  2. Round each scalar to three decimal places.\n  3. Your program must assemble all sparse matrices exactly as specified and use a generalized symmetric eigenvalue solver to compute the requested quantities.\n\n- Test suite:\n  1. Case $1$ (happy path): $N = 8$, $\\mu = 1.0$, $\\mu_{s} = 1.0$, $\\lambda_{s} = 1.0$, $\\gamma = 1.0$.\n  2. Case $2$ (mesh scalability): $N = 12$, $\\mu = 1.0$, $\\mu_{s} = 1.0$, $\\lambda_{s} = 1.0$, $\\gamma = 1.0$.\n  3. Case $3$ (nearly incompressible solid): $N = 8$, $\\mu = 1.0$, $\\mu_{s} = 1.0$, $\\lambda_{s} = 1000.0$, $\\gamma = 1.0$.\n  4. Case $4$ (strong coupling): $N = 8$, $\\mu = 1.0$, $\\mu_{s} = 1.0$, $\\lambda_{s} = 1.0$, $\\gamma = 50.0$.\n\n- Final output format:\n  1. Your program must produce a single line of output containing a list of results for all four test cases, in order, where each result is the $2$-entry list $[\\min |\\lambda|, \\max |\\lambda|]$ for that case.\n  2. The exact required output format is a single line with a comma-separated list of bracketed pairs enclosed in square brackets, for example: \n     $[$ $[a_{1},b_{1}], [a_{2},b_{2}], [a_{3},b_{3}], [a_{4},b_{4}]$ $]$, \n     where each $a_{i}$ and $b_{i}$ are decimal numbers rounded to three decimal places.\n\nYour program must be a complete, runnable script that requires no input and prints exactly one line in the specified format. Use only the libraries and versions specified in the execution environment.", "solution": "The problem requires the design and numerical validation of a block diagonal preconditioner for a monolithic fluid-structure interaction system. The process involves discretizing the governing partial differential equations, assembling the coupled Jacobian matrix, constructing the preconditioner based on a block factorization argument, and numerically testing its efficacy by computing the spectral bounds of the preconditioned system.\n\n### Governing Principles and Block Operator Form\n\nThe coupled system combines an incompressible fluid with a linear elastic solid.\n\n1.  **Fluid Dynamics**: The fluid is governed by the conservation of linear momentum and mass. For a Newtonian fluid, after linearization and assuming negligible convection, these are:\n    $$\n    -\\mu \\nabla^2 \\mathbf{u} + \\nabla p = \\mathbf{f}_f \\quad (\\text{Momentum})\n    $$\n    $$\n    \\nabla \\cdot \\mathbf{u} = 0 \\quad (\\text{Incompressibility})\n    $$\n    Here, $\\mathbf{u}$ is the fluid velocity vector, $p$ is the pressure, and $\\mu$ is the dynamic viscosity.\n\n2.  **Solid Mechanics**: The solid is described by the balance of linear momentum in the small-strain regime:\n    $$\n    -\\nabla \\cdot \\boldsymbol{\\sigma}_s(\\mathbf{d}) = \\mathbf{f}_s \\quad (\\text{Momentum})\n    $$\n    where $\\mathbf{d}$ is the displacement vector. The Cauchy stress tensor $\\boldsymbol{\\sigma}_s$ for an isotropic linear elastic material is given by $\\boldsymbol{\\sigma}_s(\\mathbf{d}) = \\lambda_s (\\nabla \\cdot \\mathbf{d})I + 2\\mu_s \\boldsymbol{\\varepsilon}(\\mathbf{d})$, with $\\boldsymbol{\\varepsilon}(\\mathbf{d}) = \\frac{1}{2}(\\nabla \\mathbf{d} + (\\nabla \\mathbf{d})^\\top)$ being the small-strain tensor, and $\\lambda_s, \\mu_s$ being the Lamé parameters.\n\nUpon discretization (e.g., with finite elements or finite differences), this coupled system of PDEs yields a linear system of equations. The system's Jacobian matrix, operating on a vector of discrete unknowns partitioned as $[\\mathbf{u}; p; \\mathbf{d}]$, can be written in a symmetric $3 \\times 3$ block form:\n$$\nJ \\;=\\;\n\\begin{bmatrix}\nA  B^{\\top}  C^{\\top} \\\\\nB  0  0 \\\\\nC  0  K\n\\end{bmatrix}\n$$\n-   $A$ is the discrete fluid momentum operator, representing the vector Laplacian term $-\\mu \\nabla^2(\\cdot)$.\n-   $B$ is the discrete divergence operator $\\nabla \\cdot (\\cdot)$, and its transpose $B^\\top$ represents the negative of the pressure gradient $-\\nabla(\\cdot)$.\n-   $K$ is the discrete linear elasticity operator, representing $-\\nabla \\cdot \\boldsymbol{\\sigma}_s(\\cdot)$.\n-   $C$ and $C^\\top$ represent the coupling between the fluid and solid domains. The problem specifies a simple symmetric Robin-type coupling.\n\nThis structure is a saddle-point system, which is notoriously ill-conditioned, especially as the mesh is refined.\n\n### Discretization Model\n\nThe implementation uses a finite difference method on a uniform $N \\times N$ Cartesian grid of interior points in the unit square. The mesh size is $h = 1/(N+1)$. All fields are discretized on this grid. Let $n = N^2$ be the number of interior grid points.\n\n-   **Discrete Laplacian ($L$)**: The negative Laplacian operator $-\\nabla^2$ is discretized using a standard 5-point stencil, resulting in a sparse matrix $L \\in \\mathbb{R}^{n \\times n}$. The matrix is scaled by $1/h^2$, with diagonal entries of $4/h^2$ and off-diagonal entries of $-1/h^2$ for neighboring points.\n-   **Discrete Derivatives ($D_x, D_y$)**: First-order spatial derivatives $\\partial_x$ and $\\partial_y$ are discretized using centered differences with a stencil of $\\pm 1/(2h)$. This yields sparse matrices $D_x, D_y \\in \\mathbb{R}^{n \\times n}$.\n-   **Block Operators**:\n    -   Fluid momentum: $A = \\mu \\, \\mathrm{blkdiag}(L, L) \\in \\mathbb{R}^{2n \\times 2n}$.\n    -   Divergence: $B = [D_x, D_y] \\in \\mathbb{R}^{n \\times 2n}$. To ensure $B$ has full row rank (and thus the LBB condition can be satisfied), the pressure constant null-space is removed by eliminating one pressure degree of freedom. This is implemented by removing the last row of $B$, resulting in $B \\in \\mathbb{R}^{(n-1) \\times 2n}$.\n    -   Elasticity: $K = \\mu_{s} \\,\\mathrm{blkdiag}(L, L) + (\\lambda_{s}+\\mu_{s}) \\begin{bmatrix} D_{x}^{\\top} D_{x}  D_{x}^{\\top} D_{y} \\\\ D_{y}^{\\top} D_{x}  D_{y}^{\\top} D_{y} \\end{bmatrix} \\in \\mathbb{R}^{2n \\times 2n}$. This form arises from discretizing the operator $-\\nabla \\cdot \\boldsymbol{\\sigma}_s(\\cdot)$.\n    -   Coupling: $C = \\gamma \\, I_{2n} \\in \\mathbb{R}^{2n \\times 2n}$, where $I_{2n}$ is the identity matrix.\n\n### Preconditioner Design via Block Factorization\n\nThe conditioning of $J$ can be improved by preconditioning. A common strategy for saddle-point systems is to use a block factorization of $J$. A block-LU decomposition of $J$ is:\n$$\nJ = \\begin{bmatrix} I  0  0 \\\\ B A^{-1}  I  0 \\\\ C A^{-1}  0  I \\end{bmatrix}\n\\begin{bmatrix} A  B^\\top  C^\\top \\\\ 0  -S_p  -S_{pd} \\\\ 0  -S_{dp}  S_d \\end{bmatrix}\n$$\nwhere $S_p = B A^{-1} B^\\top$ is the pressure Schur complement, and the other terms involve $A^{-1}$ as well. Inverting $J$ requires inverting the diagonal blocks of the U-factor, which involves inverting the Schur complement $S_p$. Since $A^{-1}$ is dense and expensive to compute, $S_p$ is typically approximated.\n\nThe theory of preconditioning for Stokes problems shows that $S_p$ is spectrally equivalent to the pressure mass matrix, $M_p$. For our uniform grid, $M_p = h^2 I_{n-1}$. This leads to the approximation $\\widehat{S}_p = \\mu^{-1} M_p = \\mu^{-1} h^2 I_{n-1}$. The factor $\\mu^{-1}$ arises from the scaling of $A$.\n\nThis motivates a simple block-diagonal preconditioner $P$:\n$$\nP \\;=\\; \\mathrm{blkdiag}\\!\\left(\\, \\widehat{A},\\; \\widehat{S}_{p},\\; \\widehat{K} \\,\\right)\n$$\nThe problem specifies using the exact blocks for the momentum and elasticity operators, so $\\widehat{A}=A$ and $\\widehat{K}=K$. The full preconditioner is:\n$$\nP \\;=\\; \\mathrm{blkdiag}\\!\\left(\\, A,\\; \\mu^{-1} h^2 I_{n-1},\\; K \\,\\right)\n$$\n\n### Numerical Validation\n\nTo validate the preconditioner, we examine the spectrum of the preconditioned operator $P^{-1}J$. If $P$ is a good preconditioner, the eigenvalues of $P^{-1}J$ should be clustered in a few small intervals, bounded away from zero, and these bounds should be independent of mesh size $h$ and problem parameters. This property is known as spectral equivalence.\n\nWe solve the generalized symmetric eigenvalue problem $J\\mathbf{x} = \\lambda P\\mathbf{x}$. The eigenvalues $\\lambda$ of this problem are the same as those of the preconditioned matrix $P^{-1/2}JP^{-1/2}$ (a symmetric form of $P^{-1}J$). We compute the minimum and maximum magnitude of these eigenvalues, $\\min|\\lambda|$ and $\\max|\\lambda|$, for a set of test cases. Robustness is indicated if these values remain within a narrow range across the test suite.\n\nThe eigenvalues are computed using the Lanczos algorithm as implemented in `scipy.sparse.linalg.eigsh`. To find the minimum magnitude eigenvalue, we use shift-invert mode with a shift $\\sigma=0$. To find the maximum magnitude eigenvalue, we compute the algebraically largest and smallest (most negative) eigenvalues and take the maximum of their absolute values.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import kron, identity, diags, bmat, block_diag, csc_matrix\nfrom scipy.sparse.linalg import eigsh\n\ndef make_laplacian(N):\n    \"\"\"\n    Constructs the 2D discrete negative Laplacian operator (-nabla^2) on an N x N\n    grid with homogeneous Dirichlet boundary conditions.\n    \"\"\"\n    n = N * N\n    h = 1.0 / (N + 1)\n    \n    # 1D Laplacian\n    L1D = diags([-1, 2, -1], [-1, 0, 1], shape=(N, N))\n    \n    # 2D Laplacian using Kronecker products\n    I_N = identity(N)\n    L2D = kron(I_N, L1D) + kron(L1D, I_N)\n    \n    return L2D / (h**2)\n\ndef make_derivatives(N):\n    \"\"\"\n    Constructs the 2D discrete first-derivative operators (Dx, Dy) on an N x N\n    grid using centered differences.\n    \"\"\"\n    n = N * N\n    h = 1.0 / (N + 1)\n    \n    # 1D derivative operator\n    D1D = diags([-1, 1], [-1, 1], shape=(N, N)) / (2 * h)\n    \n    I_N = identity(N)\n    Dx = kron(D1D, I_N, format='csc')\n    Dy = kron(I_N, D1D, format='csc')\n    \n    return Dx, Dy\n\ndef assemble_system(N, mu, mu_s, lambda_s, gamma):\n    \"\"\"\n    Assembles the Jacobian matrix J and the preconditioner P.\n    \"\"\"\n    n = N * N\n    h = 1.0 / (N + 1)\n    \n    # Discrete operators\n    L = make_laplacian(N)\n    Dx, Dy = make_derivatives(N)\n    \n    # Block A (fluid momentum)\n    A = mu * block_diag([L, L], format='csc')\n    \n    # Block B (divergence)\n    B_full = bmat([[Dx, Dy]], format='csc')\n    B = B_full[:-1, :] # Remove last row to fix pressure null space\n    \n    # Block K (elasticity)\n    K11 = mu_s * L + (lambda_s + mu_s) * (Dx.T @ Dx)\n    K12 = (lambda_s + mu_s) * (Dx.T @ Dy)\n    K21 = (lambda_s + mu_s) * (Dy.T @ Dx)\n    K22 = mu_s * L + (lambda_s + mu_s) * (Dy.T @ Dy)\n    K = bmat([[K11, K12], [K21, K22]], format='csc')\n    \n    # Block C (coupling)\n    C = gamma * identity(2 * n, format='csc')\n    \n    # Assemble Jacobian J\n    n_u, n_d = 2 * n, 2 * n\n    n_p = n - 1\n    \n    Z_pp = csc_matrix((n_p, n_p))\n    Z_pd = csc_matrix((n_p, n_d))\n    Z_dp = csc_matrix((n_d, n_p))\n    \n    J = bmat([\n        [A, B.T, C.T],\n        [B, Z_pp, Z_pd],\n        [C, Z_dp, K]\n    ], format='csc')\n    \n    # Assemble Preconditioner P\n    A_hat = A\n    K_hat = K\n    Sp_hat = (1.0 / mu) * (h**2) * identity(n_p, format='csc')\n    \n    P = block_diag([A_hat, Sp_hat, K_hat], format='csc')\n    \n    return J, P\n\ndef compute_eigenvalues(J, P, k=6):\n    \"\"\"\n    Computes the extremal generalized eigenvalues of (J, P).\n    \"\"\"\n    # Smallest magnitude eigenvalues (shift-and-invert)\n    # sigma=0 may cause issues if J is singular, but we follow the prompt.\n    # eigsh uses a sparse LU factorization in this mode which is robust.\n    try:\n        # ArpackNoConvergence can happen, so we might need more iterations.\n        # tol=0 means machine precision. maxiter is a safeguard.\n        vals_small_mag = eigsh(J, k=k, M=P, sigma=0, which='LM', tol=0, maxiter=J.shape[0]*2)[0]\n        min_abs_lambda = np.min(np.abs(vals_small_mag))\n    except Exception as e:\n        print(f\"Warning: Smallest eigenvalue computation failed: {e}\")\n        min_abs_lambda = np.nan\n\n    # Largest magnitude eigenvalues\n    try:\n        vals_large_pos = eigsh(J, k=k, M=P, which='LA', tol=0, maxiter=J.shape[0]*2)[0]\n        vals_large_neg = eigsh(J, k=k, M=P, which='SA', tol=0, maxiter=J.shape[0]*2)[0]\n        max_abs_lambda = np.max([np.max(np.abs(vals_large_pos)), np.max(np.abs(vals_large_neg))])\n    except Exception as e:\n        print(f\"Warning: Largest eigenvalue computation failed: {e}\")\n        max_abs_lambda = np.nan\n        \n    return min_abs_lambda, max_abs_lambda\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (N, mu, mu_s, lambda_s, gamma)\n        (8, 1.0, 1.0, 1.0, 1.0),       # Case 1: happy path\n        (12, 1.0, 1.0, 1.0, 1.0),      # Case 2: mesh scalability\n        (8, 1.0, 1.0, 1000.0, 1.0),    # Case 3: nearly incompressible solid\n        (8, 1.0, 1.0, 1.0, 50.0),      # Case 4: strong coupling\n    ]\n\n    all_results = []\n    for case in test_cases:\n        N, mu, mu_s, lambda_s, gamma = case\n        J, P = assemble_system(N, mu, mu_s, lambda_s, gamma)\n        min_lambda, max_lambda = compute_eigenvalues(J, P, k=6)\n        all_results.append(f\"[{min_lambda:.3f},{max_lambda:.3f}]\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "3517726"}]}