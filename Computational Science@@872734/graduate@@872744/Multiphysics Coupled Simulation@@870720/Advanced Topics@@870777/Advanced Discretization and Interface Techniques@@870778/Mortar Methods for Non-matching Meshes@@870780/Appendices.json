{"hands_on_practices": [{"introduction": "The core of any mortar method is the \"mortar matrix\" that mathematically transfers information between the non-matching meshes. This practice involves computing the matrix entries, which are defined as the $L^2$ inner products of basis functions from the two different interface discretizations. This exercise will build your foundational skills by having you implement a robust algorithm for detecting element overlaps and performing exact analytical integration, a crucial first step in any mortar-based simulation [@problem_id:3515676].", "problem": "Consider a one-dimensional interface coupling problem arising in a multiphysics coupled simulation, where non-matching meshes are used on the two sides of the interface to enforce weak continuity by a mortar method with Lagrange multipliers. The interface is the closed interval $[0,L]$ on the real line, with $L>0$. Each side of the interface is discretized independently using the Finite Element Method (FEM) with continuous, piecewise linear (hat) basis functions built on a strictly increasing node vector. One side is labeled \"slave\" and the other \"master.\" Let the slave nodes be $x^{S}_0,\\dots,x^{S}_{n_S}$ with $x^{S}_0=0$ and $x^{S}_{n_S}=L$, and the master nodes be $x^{M}_0,\\dots,x^{M}_{n_M}$ with $x^{M}_0=0$ and $x^{M}_{n_M}=L$. On each side, the basis functions $\\{N^{S}_i\\}_{i=0}^{n_S}$ and $\\{N^{M}_j\\}_{j=0}^{n_M}$ form a partition of unity on $[0,L]$ and are linear on each element (subinterval between consecutive nodes).\n\nStarting from the standard weak continuity requirement on the interface that is enforced via an $L^2$ pairing of traces, the algebraic mortar coupling matrix $M\\in\\mathbb{R}^{(n_S+1)\\times(n_M+1)}$ has entries defined by the $L^2$ inner products\n$$\nM_{ij}=\\int_{0}^{L} N^{S}_i(x)\\,N^{M}_j(x)\\,\\mathrm{d}x,\\quad 0\\le i\\le n_S,\\;0\\le j\\le n_M.\n$$\nYour task is to implement, in a numerically robust and exact manner for piecewise linear bases, the following two components:\n- An intersection detection algorithm that, given the two partitions of $[0,L]$ into elements $[x^{S}_k,x^{S}_{k+1}]$ and $[x^{M}_\\ell,x^{M}_{\\ell+1}]$, enumerates all nonempty overlaps between pairs of slave and master elements and their overlap intervals.\n- A mapping and integration routine that uses these overlaps to assemble the matrix $M$ exactly by evaluating the integrals of products of linear basis functions on each overlap. Do not use numerical quadrature; you must use exact analytical integration of polynomials of degree at most $2$ resulting from the product of two linear functions over each overlap.\n\nUse only the following fundamental bases to guide your derivation and implementation:\n- The definition of the $L^2$ inner product and basic properties such as linearity.\n- The definition of the piecewise linear hat functions on a one-dimensional mesh and the partition-of-unity property.\n- Basic polynomial integration identities for monomials $x^p$ with integer $p\\ge 0$.\n\nThe program must then verify, for a set of provided test cases, the following two identities that stem from the partition-of-unity property and must hold for a correct assembly of $M$:\n- For each slave node index $i$, the row-sum identity\n$$\n\\sum_{j=0}^{n_M} M_{ij}=\\int_0^L N^{S}_i(x)\\,\\mathrm{d}x,\n$$\nand for each master node index $j$, the column-sum identity\n$$\n\\sum_{i=0}^{n_S} M_{ij}=\\int_0^L N^{M}_j(x)\\,\\mathrm{d}x.\n$$\nFor a mesh with nodes $x_0<\\cdots<x_n$ and associated piecewise linear hat functions $\\{N_i\\}_{i=0}^{n}$, the exact integral of a hat function is given by the sum of one-half of the lengths of its adjacent elements:\n$$\n\\int_0^L N_i(x)\\,\\mathrm{d}x=\\frac{1}{2}\\,\\mathbf{1}_{i>0}\\,(x_i-x_{i-1})+\\frac{1}{2}\\,\\mathbf{1}_{i<n}\\,(x_{i+1}-x_i),\n$$\nwhere $\\mathbf{1}_{\\cdot}$ denotes the indicator function of a logical condition.\n\nAssume all node locations are real numbers sorted in strictly increasing order and that both meshes share the same endpoints $0$ and $L$. The integration must be exact up to floating-point arithmetic; a test is considered passed if the maximum absolute discrepancy in each of the two identities is at most a tolerance $\\varepsilon=10^{-12}$.\n\nTest suite:\n- Case $1$: $L=1.0$, slave nodes $\\{0.0,\\,0.2,\\,0.5,\\,1.0\\}$, master nodes $\\{0.0,\\,0.3,\\,0.7,\\,1.0\\}$.\n- Case $2$: $L=1.0$, slave nodes $\\{0.0,\\,0.5,\\,1.0\\}$, master nodes $\\{0.0,\\,0.5,\\,1.0\\}$.\n- Case $3$: $L=1.0$, slave nodes $\\{0.0,\\,0.0001,\\,0.4,\\,1.0\\}$, master nodes $\\{0.0,\\,0.6,\\,0.9,\\,1.0\\}$.\n- Case $4$: $L=1.0$, slave nodes $\\{0.0,\\,0.25,\\,0.5,\\,0.75,\\,1.0\\}$, master nodes $\\{0.0,\\,0.1,\\,0.2,\\,0.6,\\,1.0\\}$.\n- Case $5$: $L=1.0$, slave nodes $\\{0.0,\\,0.4,\\,1.0\\}$, master nodes $\\{0.0,\\,0.4,\\,0.6,\\,1.0\\}$.\n\nFor each case, your program must:\n- Construct and assemble the matrix $M$ exactly by summing contributions from overlaps.\n- Compute row sums and column sums of $M$ and compare them, respectively, to the exact hat-function integrals on the slave and master meshes.\n- Output a boolean indicating whether both the row-sum and column-sum identities are satisfied within the tolerance $\\varepsilon$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[{\\rm result}_1,{\\rm result}_2,{\\rm result}_3,{\\rm result}_4,{\\rm result}_5]$), where each ${\\rm result}_k$ is the boolean outcome for Case $k$ in the order listed above. No additional text should be printed.", "solution": "The user-provided problem is a well-defined task in the field of numerical methods for partial differential equations, specifically concerning the implementation of mortar methods for coupling subdomains with non-matching meshes. All provided definitions, formulas, and test cases are scientifically sound, complete, and consistent. The problem is therefore deemed **valid**. We proceed with a full solution.\n\nThe primary objective is to compute the mortar coupling matrix $M \\in \\mathbb{R}^{(n_S+1)\\times(n_M+1)}$ for a one-dimensional interface problem on the domain $[0,L]$. The entries of this matrix are defined by the $L^2$ inner product of slave and master basis functions:\n$$\nM_{ij} = \\int_{0}^{L} N^{S}_i(x)\\,N^{M}_j(x)\\,\\mathrm{d}x\n$$\nwhere $\\{N^{S}_i(x)\\}$ and $\\{N^{M}_j(x)\\}$ are the sets of continuous, piecewise linear (hat) basis functions defined on the slave and master meshes, respectively.\n\nThe core of the task is to evaluate these integrals exactly—up to floating-point precision—without resorting to numerical quadrature rules like Gauss-Legendre. This is achievable because the product of two linear polynomials is a quadratic polynomial, which can be integrated analytically.\n\nThe solution is developed in three stages:\n1.  An algorithm to identify all overlapping regions between slave and master mesh elements.\n2.  A method for exact symbolic integration of the product of basis functions over each overlap region.\n3.  The aggregation of these local integrals to assemble the global matrix $M$, followed by a verification step.\n\n### 1. Intersection of Meshes\nThe integral over the entire domain $[0,L]$ can be decomposed into a sum of integrals over smaller intervals. A natural choice for these intervals is the set of non-empty intersections of slave elements with master elements. Let the slave mesh have nodes $x^{S}_0, \\dots, x^{S}_{n_S}$ defining elements $E_k^S = [x_k^S, x_{k+1}^S]$ for $k = 0, \\dots, n_S-1$. Similarly, the master mesh has nodes $x^{M}_0, \\dots, x^{M}_{n_M}$ defining elements $E_\\ell^M = [x_\\ell^M, x_{\\ell+1}^M]$ for $\\ell = 0, \\dots, n_M-1$. The integral for $M_{ij}$ can be written as:\n$$\nM_{ij} = \\sum_{k=0}^{n_S-1} \\sum_{\\ell=0}^{n_M-1} \\int_{E_k^S \\cap E_\\ell^M} N^{S}_i(x)\\,N^{M}_j(x)\\,\\mathrm{d}x\n$$\nThis is because the union of all intersections $E_k^S \\cap E_\\ell^M$ partitions the domain $[0,L]$.\n\nTo find all non-empty intersections efficiently, we employ a \"zipper\" or \"merge\" algorithm. Since the nodes for both meshes are sorted, we can iterate through the slave and master elements simultaneously using two pointers, $k$ for the slave element index and $\\ell$ for the master element index.\n\nThe algorithm proceeds as follows:\n- Initialize pointers $k=0$ and $\\ell=0$.\n- While $k < n_S$ and $\\ell < n_M$:\n    1.  Consider the current slave element $E_k^S = [x_k^S, x_{k+1}^S]$ and master element $E_\\ell^M = [x_\\ell^M, x_{\\ell+1}^M]$.\n    2.  Calculate the intersection interval $[a,b]$ where $a = \\max(x_k^S, x_\\ell^M)$ and $b = \\min(x_{k+1}^S, x_{\\ell+1}^M)$.\n    3.  If $a<b$, the intersection is non-empty. This overlap interval contributes to the matrix $M$. The integration process over $[a,b]$ is described in the next section.\n    4.  Advance the pointers. If $x_{k+1}^S < x_{\\ell+1}^M$, the slave element ends first, so we are done with $E_k^S$ and increment $k$. If $x_{\\ell+1}^M < x_{k+1}^S$, the master element ends first, so we increment $\\ell$. If $x_{k+1}^S = x_{\\ell+1}^M$, both elements end together, so we increment both $k$ and $\\ell$.\nThis procedure has a linear time complexity of $O(n_S + n_M)$.\n\n### 2. Exact Local Integration\nFor each non-empty overlap interval $[a,b]$ found, we must compute the integral of products of basis functions. The key insight is that on any given slave element $E_k^S$, only two basis functions, $N_k^S$ and $N_{k+1}^S$, are non-zero. Similarly, on master element $E_\\ell^M$, only $N_\\ell^M$ and $N_{\\ell+1}^M$ are non-zero. Consequently, for an overlap $E_k^S \\cap E_\\ell^M$, we only need to consider the integrals for the four matrix entries $M_{ij}$ where $i \\in \\{k, k+1\\}$ and $j \\in \\{\\ell, \\ell+1\\}$.\n\nOn the interval $[a,b]$, both basis functions $f(x) = N_i^S(x)$ and $g(x) = N_j^M(x)$ are linear polynomials. The integral of their product, a quadratic, can be computed exactly. A robust and elegant formula for the integral of a product of two linear functions $f(x)$ and $g(x)$ over an interval $[a,b]$ is given by:\n$$\n\\int_a^b f(x)g(x)\\,\\mathrm{d}x = \\frac{b-a}{6} \\left[ (2f(a)+f(b))g(a) + (f(a)+2f(b))g(b) \\right]\n$$\nThis formula only requires the values of the functions at the endpoints of the integration interval.\n\nThe values of the relevant basis functions at a point $x \\in [a,b] \\subseteq E_k^S \\cap E_\\ell^M$ are:\n- $N_k^S(x) = \\frac{x_{k+1}^S - x}{x_{k+1}^S - x_k^S}$\n- $N_{k+1}^S(x) = \\frac{x - x_k^S}{x_{k+1}^S - x_k^S}$\n- $N_\\ell^M(x) = \\frac{x_{\\ell+1}^M - x}{x_{\\ell+1}^M - x_\\ell^M}$\n- $N_{\\ell+1}^M(x) = \\frac{x - x_\\ell^M}{x_{\\ell+1}^M - x_\\ell^M}$\n\nFor each overlap $[a,b]$, we first compute the values of these four functions at $x=a$ and $x=b$. Then, we apply the integration formula for each of the four pairs $(N_k^S, N_\\ell^M)$, $(N_k^S, N_{\\ell+1}^M)$, $(N_{k+1}^S, N_\\ell^M)$, and $(N_{k+1}^S, N_{\\ell+1}^M)$. The resulting value for each integral is then added to the corresponding entry in the global matrix $M$.\n\n### 3. Matrix Assembly and Verification\nThe complete mortar matrix $M$ is constructed by initializing a zero matrix of size $(n_S+1) \\times (n_M+1)$ and then accumulating the contributions from all local integrals computed over all overlap intervals.\n\nOnce $M$ is assembled, we verify its correctness using the partition-of-unity property of the basis functions, i.e., $\\sum_j N_j^M(x) = 1$ and $\\sum_i N_i^S(x) = 1$ for all $x \\in [0,L]$.\nThe row-sum identity is derived as follows:\n$$\n\\sum_{j=0}^{n_M} M_{ij} = \\sum_{j=0}^{n_M} \\int_0^L N_i^S(x) N_j^M(x) \\,\\mathrm{d}x = \\int_0^L N_i^S(x) \\left( \\sum_{j=0}^{n_M} N_j^M(x) \\right) \\,\\mathrm{d}x = \\int_0^L N_i^S(x) \\cdot 1 \\,\\mathrm{d}x\n$$\nA similar derivation yields the column-sum identity:\n$$\n\\sum_{i=0}^{n_S} M_{ij} = \\int_0^L N_j^M(x) \\,\\mathrm{d}x\n$$\nThe right-hand side integrals, representing the area under each hat function, are calculated analytically using the provided formula:\n$$\n\\int_0^L N_i(x)\\,\\mathrm{d}x=\\frac{1}{2}\\,\\mathbf{1}_{i>0}\\,(x_i-x_{i-1})+\\frac{1}{2}\\,\\mathbf{1}_{i<n}\\,(x_{i+1}-x_i)\n$$\nThe verification consists of computing the row and column sums of the assembled matrix $M$ and comparing them against these analytical integrals. The test is passed if the maximum absolute difference for both row and column identities is within the specified tolerance $\\varepsilon = 10^{-12}$.", "answer": "```python\nimport numpy as np\n\ndef assemble_mortar_matrix(slave_nodes, master_nodes, L):\n    \"\"\"\n    Assembles the 1D mortar coupling matrix M for non-matching meshes.\n\n    M_ij = integral(N_i^S * N_j^M) over [0, L].\n    \"\"\"\n    n_S = len(slave_nodes) - 1\n    n_M = len(master_nodes) - 1\n    M = np.zeros((n_S + 1, n_M + 1))\n\n    k = 0  # Slave element index\n    l = 0  # Master element index\n\n    while k < n_S and l < n_M:\n        xS_k, xS_k1 = slave_nodes[k], slave_nodes[k+1]\n        xM_l, xM_l1 = master_nodes[l], master_nodes[l+1]\n\n        # Find intersection of slave element k and master element l\n        a = max(xS_k, xM_l)\n        b = min(xS_k1, xM_l1)\n\n        if a < b:\n            # Non-empty overlap [a, b]\n            # Element lengths\n            h_S = xS_k1 - xS_k\n            h_M = xM_l1 - xM_l\n\n            # Evaluate basis functions at endpoints of the overlap interval\n            # Slave basis functions related to element k\n            NS_k_a = (xS_k1 - a) / h_S\n            NS_k_b = (xS_k1 - b) / h_S\n            NS_k1_a = (a - xS_k) / h_S\n            NS_k1_b = (b - xS_k) / h_S\n\n            # Master basis functions related to element l\n            NM_l_a = (xM_l1 - a) / h_M\n            NM_l_b = (xM_l1 - b) / h_M\n            NM_l1_a = (a - xM_l) / h_M\n            NM_l1_b = (b - xM_l) / h_M\n\n            delta = b - a\n\n            # Define a helper for the exact integral formula\n            # integral(f*g) on [a,b] = (b-a)/6 * [ (2f(a)+f(b))g(a) + (f(a)+2f(b))g(b) ]\n            def exact_integral(fa, fb, ga, gb):\n                return (delta / 6.0) * ((2.0 * fa + fb) * ga + (fa + 2.0 * fb) * gb)\n\n            # Add contributions to the four relevant matrix entries\n            # (i, j) = (k, l)\n            M[k, l] += exact_integral(NS_k_a, NS_k_b, NM_l_a, NM_l_b)\n            # (i, j) = (k, l+1)\n            M[k, l + 1] += exact_integral(NS_k_a, NS_k_b, NM_l1_a, NM_l1_b)\n            # (i, j) = (k+1, l)\n            M[k + 1, l] += exact_integral(NS_k1_a, NS_k1_b, NM_l_a, NM_l_b)\n            # (i, j) = (k+1, l+1)\n            M[k + 1, l + 1] += exact_integral(NS_k1_a, NS_k1_b, NM_l1_a, NM_l1_b)\n\n        # Advance pointers in the zipper-like traversal\n        if xS_k1 < xM_l1:\n            k += 1\n        elif xM_l1 < xS_k1:\n            l += 1\n        else: # xS_k1 == xM_l1\n            k += 1\n            l += 1\n    \n    return M\n\ndef verify_identities(M, slave_nodes, master_nodes, L, tol):\n    \"\"\"\n    Verifies the row-sum and column-sum identities for the mortar matrix.\n    \"\"\"\n    n_S = len(slave_nodes) - 1\n    n_M = len(master_nodes) - 1\n\n    # --- Verify Row Sums ---\n    computed_row_sums = np.sum(M, axis=1)\n    analytical_slave_integrals = np.zeros(n_S + 1)\n    for i in range(n_S + 1):\n        integral = 0.0\n        if i > 0:\n            integral += 0.5 * (slave_nodes[i] - slave_nodes[i-1])\n        if i < n_S:\n            integral += 0.5 * (slave_nodes[i+1] - slave_nodes[i])\n        analytical_slave_integrals[i] = integral\n    \n    max_row_discrepancy = np.max(np.abs(computed_row_sums - analytical_slave_integrals))\n    row_sum_ok = max_row_discrepancy <= tol\n\n    # --- Verify Column Sums ---\n    computed_col_sums = np.sum(M, axis=0)\n    analytical_master_integrals = np.zeros(n_M + 1)\n    for j in range(n_M + 1):\n        integral = 0.0\n        if j > 0:\n            integral += 0.5 * (master_nodes[j] - master_nodes[j-1])\n        if j < n_M:\n            integral += 0.5 * (master_nodes[j+1] - master_nodes[j])\n        analytical_master_integrals[j] = integral\n        \n    max_col_discrepancy = np.max(np.abs(computed_col_sums - analytical_master_integrals))\n    col_sum_ok = max_col_discrepancy <= tol\n    \n    return row_sum_ok and col_sum_ok\n\n\ndef solve():\n    \"\"\"\n    Main solver function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        (1.0, np.array([0.0, 0.2, 0.5, 1.0]), np.array([0.0, 0.3, 0.7, 1.0])),\n        (1.0, np.array([0.0, 0.5, 1.0]), np.array([0.0, 0.5, 1.0])),\n        (1.0, np.array([0.0, 0.0001, 0.4, 1.0]), np.array([0.0, 0.6, 0.9, 1.0])),\n        (1.0, np.array([0.0, 0.25, 0.5, 0.75, 1.0]), np.array([0.0, 0.1, 0.2, 0.6, 1.0])),\n        (1.0, np.array([0.0, 0.4, 1.0]), np.array([0.0, 0.4, 0.6, 1.0])),\n    ]\n\n    tolerance = 1e-12\n    results = []\n\n    for L, slave_nodes, master_nodes in test_cases:\n        mortar_matrix = assemble_mortar_matrix(slave_nodes, master_nodes, L)\n        is_valid = verify_identities(mortar_matrix, slave_nodes, master_nodes, L, tolerance)\n        results.append(is_valid)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3515676"}, {"introduction": "Once a numerical operator like the mortar projection is implemented, we must rigorously verify its correctness. This practice introduces the \"patch test,\" a fundamental verification tool in computational mechanics that confirms whether the method can exactly reproduce simple polynomial solutions it is theoretically designed to represent. By implementing constant and linear patch tests, you will not only gain confidence in your mortar projection code but also learn a critical skill for debugging and validating finite element methods in general [@problem_id:3515713].", "problem": "Construct a program that verifies polynomial patch tests for the mortar projection between two non-matching one-dimensional meshes that discretize the same interface. The physical interface is the closed interval $\\left[0,1\\right]$ endowed with the standard Lebesgue measure. Let the master mesh be defined by nodes $\\left\\{x_i^{\\mathrm{M}}\\right\\}_{i=0}^{n_{\\mathrm{M}}}$ with $0 = x_0^{\\mathrm{M}} < x_1^{\\mathrm{M}} < \\cdots < x_{n_{\\mathrm{M}}}^{\\mathrm{M}} = 1$, and the slave mesh be defined by nodes $\\left\\{x_j^{\\mathrm{S}}\\right\\}_{j=0}^{n_{\\mathrm{S}}}$ with $0 = x_0^{\\mathrm{S}} < x_1^{\\mathrm{S}} < \\cdots < x_{n_{\\mathrm{S}}}^{\\mathrm{S}} = 1$. On each mesh, consider the standard continuous, piecewise-linear finite element trace space spanned by hat functions, denoted $V_{\\mathrm{M}}$ on the master and $V_{\\mathrm{S}}$ on the slave. \n\nThe mortar projection is defined as follows: for a given function $u_{\\mathrm{S}} \\in V_{\\mathrm{S}}$, find $u_{\\mathrm{M}} \\in V_{\\mathrm{M}}$ such that\n$$\n\\int_{0}^{1} \\mu\\left(x\\right)\\,\\left(u_{\\mathrm{M}}\\left(x\\right) - u_{\\mathrm{S}}\\left(x\\right)\\right)\\,\\mathrm{d}x = 0 \\quad \\text{for all } \\mu \\in V_{\\mathrm{M}}.\n$$\nThis is the $L^2$-orthogonality condition with test space $V_{\\mathrm{M}}$. Let $\\left\\{\\phi_i\\right\\}_{i=0}^{n_{\\mathrm{M}}}$ denote the nodal basis of $V_{\\mathrm{M}}$ and $\\left\\{\\psi_j\\right\\}_{j=0}^{n_{\\mathrm{S}}}$ denote the nodal basis of $V_{\\mathrm{S}}$. If $u_{\\mathrm{M}} = \\sum_{i=0}^{n_{\\mathrm{M}}} U^{\\mathrm{M}}_i \\,\\phi_i$ and $u_{\\mathrm{S}} = \\sum_{j=0}^{n_{\\mathrm{S}}} U^{\\mathrm{S}}_j \\,\\psi_j$, then the coefficients satisfy\n$$\n\\sum_{i=0}^{n_{\\mathrm{M}}} \\left(\\int_{0}^{1} \\phi_\\ell\\left(x\\right)\\,\\phi_i\\left(x\\right)\\,\\mathrm{d}x\\right) U^{\\mathrm{M}}_i\n=\n\\sum_{j=0}^{n_{\\mathrm{S}}} \\left(\\int_{0}^{1} \\phi_\\ell\\left(x\\right)\\,\\psi_j\\left(x\\right)\\,\\mathrm{d}x\\right) U^{\\mathrm{S}}_j\n\\quad \\text{for } \\ell = 0,\\ldots,n_{\\mathrm{M}}.\n$$\nDefine the master mass matrix $B \\in \\mathbb{R}^{\\left(n_{\\mathrm{M}}+1\\right)\\times\\left(n_{\\mathrm{M}}+1\\right)}$ with entries\n$$\nB_{\\ell i} = \\int_{0}^{1} \\phi_\\ell\\left(x\\right)\\,\\phi_i\\left(x\\right)\\,\\mathrm{d}x,\n$$\nand the mixed coupling matrix $C \\in \\mathbb{R}^{\\left(n_{\\mathrm{M}}+1\\right)\\times\\left(n_{\\mathrm{S}}+1\\right)}$ with entries\n$$\nC_{\\ell j} = \\int_{0}^{1} \\phi_\\ell\\left(x\\right)\\,\\psi_j\\left(x\\right)\\,\\mathrm{d}x.\n$$\nThen the projected master coefficients satisfy\n$$\nB\\,U^{\\mathrm{M}} = C\\,U^{\\mathrm{S}}.\n$$\n\nStarting from fundamental definitions of $L^2$-orthogonality and standard finite element basis functions, implement the mortar projection $U^{\\mathrm{M}} = B^{-1} C \\, U^{\\mathrm{S}}$ for non-matching meshes. All integrals must be evaluated by exact polynomial quadrature over the union partition formed by the combined element boundaries of both meshes; for robustness, use Gaussian quadrature of order $\\geq 3$ on each subinterval of this union partition.\n\nVerification via patch tests:\n- The constant patch test requires that if $u\\left(x\\right) = \\alpha$ for some constant $\\alpha \\in \\mathbb{R}$, then the projected $u_{\\mathrm{M}}$ exactly reproduces $u$.\n- The linear patch test requires that if $u\\left(x\\right) = \\alpha + \\beta x$ with $\\alpha,\\beta \\in \\mathbb{R}$, then the projected $u_{\\mathrm{M}}$ exactly reproduces $u$.\n- A higher-order verification with $u\\left(x\\right)=x^2$ demonstrates the expected nonzero error because the spaces are piecewise linear.\n\nYour program must:\n1. Assemble $B$ and $C$ for arbitrary master and slave meshes as described.\n2. For a given exact function $u\\left(x\\right)$, set $U^{\\mathrm{S}}_j = u\\!\\left(x_j^{\\mathrm{S}}\\right)$, compute $U^{\\mathrm{M}}$, and evaluate:\n   - The $L^2$ error $e_{2} = \\left(\\int_{0}^{1}\\left(u_{\\mathrm{M}}\\left(x\\right) - u\\left(x\\right)\\right)^2 \\mathrm{d}x\\right)^{1/2}$ using the same union partition and Gaussian quadrature.\n   - The nodal infinity error $e_{\\infty} = \\max_{0 \\le i \\le n_{\\mathrm{M}}} \\left|U^{\\mathrm{M}}_i - u\\!\\left(x_i^{\\mathrm{M}}\\right)\\right|$.\n3. For constant and linear patch tests, return a boolean indicating pass if both $e_{2} \\le \\varepsilon$ and $e_{\\infty} \\le \\varepsilon$, with $\\varepsilon = 10^{-10}$; for the quadratic case, return the $L^2$ error $e_{2}$ as a floating-point number.\n\nTest suite:\n- Case $1$ (linear patch test, general nonmatching meshes):\n  - Master nodes: $\\left[0.0,\\,0.2,\\,0.5,\\,1.0\\right]$.\n  - Slave nodes: $\\left[0.0,\\,0.33,\\,0.66,\\,1.0\\right]$.\n  - Function: $u\\left(x\\right) = 1.0 + 0.5\\,x$.\n  - Expected output type: boolean.\n- Case $2$ (constant patch test with extreme coarsening on slave):\n  - Master nodes: $\\left[0.0,\\,0.4,\\,0.7,\\,1.0\\right]$.\n  - Slave nodes: $\\left[0.0,\\,1.0\\right]$.\n  - Function: $u\\left(x\\right) = 2.3$.\n  - Expected output type: boolean.\n- Case $3$ (quadratic verification):\n  - Master nodes: $\\left[0.0,\\,0.2,\\,0.4,\\,0.7,\\,1.0\\right]$.\n  - Slave nodes: $\\left[0.0,\\,0.6,\\,1.0\\right]$.\n  - Function: $u\\left(x\\right) = x^2$.\n  - Expected output type: floating-point $L^2$ error.\n- Case $4$ (linear patch test with highly nonmatching meshes):\n  - Master nodes: $\\left[0.0,\\,0.1,\\,0.15,\\,0.5,\\,0.9,\\,1.0\\right]$.\n  - Slave nodes: $\\left[0.0,\\,1.0\\right]$.\n  - Function: $u\\left(x\\right) = -0.2 + 3.0\\,x$.\n  - Expected output type: boolean.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the cases $1$ to $4$. For example, the output must look like $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\right]$. No units are involved; all numbers are dimensionless. Booleans must appear as either $\\text{True}$ or $\\text{False}$, and the floating-point value must be printed in standard decimal notation.", "solution": "The task is to construct a program that implements and verifies a one-dimensional mortar projection for non-matching finite element meshes. The verification is performed using polynomial patch tests. The solution is developed based on fundamental principles of the finite element method and numerical integration.\n\n### 1. Mathematical Formulation\nThe problem is set on the domain $\\Omega = [0, 1]$. This domain is discretized by two separate, non-matching meshes: a master mesh with nodes $\\{x_i^{\\mathrm{M}}\\}_{i=0}^{n_{\\mathrm{M}}}$ and a slave mesh with nodes $\\{x_j^{\\mathrm{S}}\\}_{j=0}^{n_{\\mathrm{S}}}$. On each mesh, we consider the standard continuous, piecewise-linear (P1) finite element space. The master space, $V_{\\mathrm{M}}$, is spanned by the basis of nodal hat functions $\\{\\phi_i\\}_{i=0}^{n_{\\mathrm{M}}}$, where $\\phi_i(x_k^{\\mathrm{M}}) = \\delta_{ik}$ ($\\delta_{ik}$ being the Kronecker delta). Similarly, the slave space, $V_{\\mathrm{S}}$, is spanned by the basis $\\{\\psi_j\\}_{j=0}^{n_{\\mathrm{S}}}$.\n\nThe core of the problem is the mortar projection, which is a specific type of $L^2$-projection. Given a function $u_{\\mathrm{S}} \\in V_{\\mathrm{S}}$, we seek its projection $u_{\\mathrm{M}} \\in V_{\\mathrm{M}}$ such that the residual $(u_{\\mathrm{M}} - u_{\\mathrm{S}})$ is orthogonal to the master space $V_{\\mathrm{M}}$. This is expressed by the weak form, a cornerstone of the Galerkin method:\n$$\n\\int_{0}^{1} \\mu(x) \\left(u_{\\mathrm{M}}(x) - u_{\\mathrm{S}}(x)\\right) \\,\\mathrm{d}x = 0 \\quad \\text{for all } \\mu \\in V_{\\mathrm{M}}.\n$$\n\n### 2. Discretization and The Linear System\nTo solve this problem computationally, we expand the functions $u_{\\mathrm{M}}$ and $u_{\\mathrm{S}}$ in terms of their respective basis functions and unknown/known nodal coefficients, $U^{\\mathrm{M}}$ and $U^{\\mathrm{S}}$:\n$$\nu_{\\mathrm{M}}(x) = \\sum_{i=0}^{n_{\\mathrm{M}}} U^{\\mathrm{M}}_i \\,\\phi_i(x) \\quad \\text{and} \\quad u_{\\mathrm{S}}(x) = \\sum_{j=0}^{n_{\\mathrm{S}}} U^{\\mathrm{S}}_j \\,\\psi_j(x).\n$$\nBy substituting these expansions into the weak form and testing against each master basis function $\\mu = \\phi_\\ell$ for $\\ell = 0, \\ldots, n_{\\mathrm{M}}$, we transform the integral equation into a system of linear algebraic equations:\n$$\n\\sum_{i=0}^{n_{\\mathrm{M}}} \\left(\\int_{0}^{1} \\phi_\\ell(x)\\,\\phi_i(x)\\,\\mathrm{d}x\\right) U^{\\mathrm{M}}_i\n=\n\\sum_{j=0}^{n_{\\mathrm{S}}} \\left(\\int_{0}^{1} \\phi_\\ell(x)\\,\\psi_j(x)\\,\\mathrm{d}x\\right) U^{\\mathrm{S}}_j.\n$$\nThis is the matrix system $B\\,U^{\\mathrm{M}} = C\\,U^{\\mathrm{S}}$, where the matrices are defined by:\n- **Master Mass Matrix**: $B \\in \\mathbb{R}^{(n_{\\mathrm{M}}+1)\\times(n_{\\mathrm{M}}+1)}$ with entries $B_{\\ell i} = \\int_{0}^{1} \\phi_\\ell(x)\\,\\phi_i(x)\\,\\mathrm{d}x$. This matrix is symmetric and positive-definite, ensuring a unique solution exists.\n- **Coupling (Mixed) Matrix**: $C \\in \\mathbb{R}^{(n_{\\mathrm{M}}+1)\\times(n_{\\mathrm{S}}+1)}$ with entries $C_{\\ell j} = \\int_{0}^{1} \\phi_\\ell(x)\\,\\psi_j(x)\\,\\mathrm{d}x$. This matrix couples the degrees of freedom from the slave mesh to the master mesh.\n\n### 3. Numerical Integration Scheme\nA critical implementation detail is the accurate evaluation of the integrals defining the matrices $B$ and $C$. The integrands involve products of basis functions from two potentially non-matching meshes. To handle this robustly, a **union partition** is formed by taking the set of all unique nodal coordinates from both master and slave meshes, sorted in ascending order, $\\{z_k\\}$. This partition divides the domain $[0, 1]$ into a series of subintervals $[z_k, z_{k+1}]$.\n\nOver any such subinterval, each basis function ($\\phi_i$ or $\\psi_j$) is a simple linear polynomial. Therefore, the integrand for any entry of $B$ or $C$ is a single polynomial of at most degree $2$. The total integral is the sum of the integrals over these subintervals. Each sub-integral is evaluated using **Gaussian quadrature**. The problem specifies a quadrature order of $p \\ge 3$. A rule with $p=3$ points is exact for polynomials of degree up to $2p-1=5$, which is more than sufficient for the quadratic integrands here, guaranteeing an exact computation up to machine precision.\n\n### 4. Verification via Patch Tests\nThe correctness of the implementation is verified using **patch tests**. A patch test assesses if the numerical method can exactly reproduce solutions that it should theoretically be able to represent. For our P1 finite element basis, the spaces $V_{\\mathrm{M}}$ and $V_{\\mathrm{S}}$ contain all linear polynomials on their respective meshes.\n\nThe verification process is as follows:\n1. An exact analytical function $u(x)$ is chosen (e.g., constant $u(x)=\\alpha$ or linear $u(x)=\\alpha + \\beta x$).\n2. The slave coefficient vector $U^{\\mathrm{S}}$ is determined by interpolating the exact function at the slave nodes: $U^{\\mathrm{S}}_j = u(x_j^{\\mathrm{S}})$.\n3. The matrices $B$ and $C$ are assembled using the numerical integration scheme.\n4. The linear system $B\\,U^{\\mathrm{M}} = C\\,U^{\\mathrm{S}}$ is solved to obtain the projected master nodal coefficients $U^{\\mathrm{M}}$.\n5. The computed solution $u_{\\mathrm{M}}(x) = \\sum_i U^{\\mathrm{M}}_i \\phi_i(x)$ is compared to the original exact function $u(x)$ using two error norms:\n   - **Nodal Infinity Error**: $e_{\\infty} = \\max_{0 \\le i \\le n_{\\mathrm{M}}} |U^{\\mathrm{M}}_i - u(x_i^{\\mathrm{M}})|$.\n   - **$L^2$ Error**: $e_{2} = \\left(\\int_{0}^{1}(u_{\\mathrm{M}}(x) - u(x))^2 \\mathrm{d}x\\right)^{1/2}$. The integral for $e_2^2$ is also computed via Gaussian quadrature on the union partition.\n\nA patch test is considered \"passed\" if both $e_{\\infty}$ and $e_{2}$ are below a small tolerance, $\\varepsilon = 10^{-10}$. For a test with a quadratic function $u(x)=x^2$, which cannot be exactly represented by P1 elements, a non-zero error is expected, and its $L^2$ magnitude $e_2$ is reported as a measure of the projection error.", "answer": "```python\nimport numpy as np\n\n# Set up Gaussian quadrature rule. Order >= 3 is specified.\nQUAD_ORDER = 3\nQUAD_POINTS, QUAD_WEIGHTS = np.polynomial.legendre.leggauss(QUAD_ORDER)\nTOLERANCE = 1e-10\n\ndef hat_function(node_index, x, nodes):\n    \"\"\"\n    Evaluates the value of the 1D linear \"hat\" basis function.\n    The function is non-zero only on the elements adjacent to the node_index.\n    \"\"\"\n    num_nodes = len(nodes)\n    \n    # The hat function is 1 at nodes[node_index] and 0 at other nodes.\n    # It is piecewise linear between them.\n    \n    # Check left segment of the hat\n    if node_index > 0:\n        x_prev = nodes[node_index - 1]\n        x_curr = nodes[node_index]\n        if x_prev <= x <= x_curr:\n            h = x_curr - x_prev\n            # Avoid division by zero for coincident nodes, though problem implies they aren't.\n            return (x - x_prev) / h if h > 0 else 0.0\n    \n    # Check right segment of the hat\n    if node_index < num_nodes - 1:\n        x_curr = nodes[node_index]\n        x_next = nodes[node_index + 1]\n        if x_curr <= x <= x_next:\n            h = x_next - x_curr\n            return (x_next - x) / h if h > 0 else 0.0\n            \n    return 0.0\n\nclass MortarVerifier:\n    \"\"\"\n    Handles the assembly, solution, and verification for a single mortar projection case.\n    \"\"\"\n    def __init__(self, master_nodes, slave_nodes, u_exact_func, test_type):\n        self.master_nodes = np.array(master_nodes, dtype=float)\n        self.slave_nodes = np.array(slave_nodes, dtype=float)\n        self.nm = len(self.master_nodes)\n        self.ns = len(self.slave_nodes)\n        self.u_exact_func = u_exact_func\n        self.test_type = test_type\n\n        # Create the union partition for integration\n        union_nodes = np.unique(np.concatenate((self.master_nodes, self.slave_nodes)))\n        self.union_intervals = list(zip(union_nodes[:-1], union_nodes[1:]))\n\n    def _integrate(self, func):\n        \"\"\"\n        Numerically integrates a given function over the union partition\n        using Gaussian quadrature.\n        \"\"\"\n        total = 0.0\n        for a, b in self.union_intervals:\n            if a == b:\n                continue\n            \n            # Map quadrature points from [-1, 1] to [a, b]\n            mapped_points = 0.5 * (b - a) * QUAD_POINTS + 0.5 * (a + b)\n            jacobian = 0.5 * (b - a)\n            \n            func_values = np.array([func(p) for p in mapped_points])\n            total += jacobian * np.sum(QUAD_WEIGHTS * func_values)\n        \n        return total\n\n    def run_test(self):\n        \"\"\"\n        Executes the full pipeline: assemble, solve, and compute errors.\n        \"\"\"\n        # Assemble master mass matrix B\n        B = np.zeros((self.nm, self.nm))\n        for l in range(self.nm):\n            for i in range(self.nm):\n                # Optimization: B is tridiagonal\n                if abs(l - i) > 1:\n                    continue\n                integrand = lambda x: hat_function(l, x, self.master_nodes) * \\\n                                      hat_function(i, x, self.master_nodes)\n                B[l, i] = self._integrate(integrand)\n\n        # Assemble coupling matrix C\n        C = np.zeros((self.nm, self.ns))\n        for l in range(self.nm):\n            for j in range(self.ns):\n                integrand = lambda x: hat_function(l, x, self.master_nodes) * \\\n                                      hat_function(j, x, self.slave_nodes)\n                C[l, j] = self._integrate(integrand)\n\n        # Get slave coefficient vector U_S by interpolating exact function\n        U_S = np.array([self.u_exact_func(x) for x in self.slave_nodes])\n        \n        # Solve for projected master coefficients U_M\n        rhs = C @ U_S\n        U_M = np.linalg.solve(B, rhs)\n\n        # --- Error Calculation ---\n\n        # 1. Nodal infinity error\n        u_exact_at_master_nodes = np.array([self.u_exact_func(x) for x in self.master_nodes])\n        e_inf = np.max(np.abs(U_M - u_exact_at_master_nodes))\n\n        # 2. L2 error\n        def u_M_eval(x):\n            val = 0.0\n            for i in range(self.nm):\n                val += U_M[i] * hat_function(i, x, self.master_nodes)\n            return val\n        \n        error_integrand = lambda x: (u_M_eval(x) - self.u_exact_func(x))**2\n        e2_squared = self._integrate(error_integrand)\n        e2 = np.sqrt(e2_squared)\n\n        # --- Return result based on test type ---\n        if self.test_type == 'boolean':\n            return e2 <= TOLERANCE and e_inf <= TOLERANCE\n        elif self.test_type == 'float':\n            return e2\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"master_nodes\": [0.0, 0.2, 0.5, 1.0],\n            \"slave_nodes\": [0.0, 0.33, 0.66, 1.0],\n            \"u_func\": lambda x: 1.0 + 0.5 * x,\n            \"type\": \"boolean\"\n        },\n        {\n            \"master_nodes\": [0.0, 0.4, 0.7, 1.0],\n            \"slave_nodes\": [0.0, 1.0],\n            \"u_func\": lambda x: 2.3,\n            \"type\": \"boolean\"\n        },\n        {\n            \"master_nodes\": [0.0, 0.2, 0.4, 0.7, 1.0],\n            \"slave_nodes\": [0.0, 0.6, 1.0],\n            \"u_func\": lambda x: x**2,\n            \"type\": \"float\"\n        },\n        {\n            \"master_nodes\": [0.0, 0.1, 0.15, 0.5, 0.9, 1.0],\n            \"slave_nodes\": [0.0, 1.0],\n            \"u_func\": lambda x: -0.2 + 3.0 * x,\n            \"type\": \"boolean\"\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        verifier = MortarVerifier(\n            master_nodes=case[\"master_nodes\"],\n            slave_nodes=case[\"slave_nodes\"],\n            u_exact_func=case[\"u_func\"],\n            test_type=case[\"type\"]\n        )\n        result = verifier.run_test()\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3515713"}, {"introduction": "Mortar methods find their true power when used to couple different physical subdomains within a larger multiphysics simulation. This practice moves beyond pure projection to the assembly and solution of a full saddle-point system for a coupled elasticity problem, where mortar constraints are enforced using Lagrange multipliers. You will learn to integrate mortar coupling into a complete finite element framework, combining stiffness matrices, force vectors, and constraint equations to solve a practical problem, revealing the physical meaning of Lagrange multipliers as the contact forces that ensure interface compatibility [@problem_id:3588891].", "problem": "You are to implement, from first principles, the assembly of a mortar-coupled augmented system for two linear elastic subdomains sharing a straight interface with nonmatching discretizations. The task focuses on element stiffness and load vector formation on the interface, mortar coupling with Lagrange multipliers, and the inclusion of interface traction loads in the global right-hand side. The computational setting is one-dimensional along the interface parameterized by a coordinate $y \\in [0,H]$ with $H>0$. Each subdomain is an elastic strip of thickness $L$ in the direction normal to the interface and behaves, after static condensation, like a continuous distribution of linear springs (per unit interface length) attached to ground. The interface traction field is transmitted between the two sides via Lagrange multipliers. You must assemble and solve the saddle-point system and report the interface-averaged Lagrange multiplier for several test cases.\n\nStart from the following fundamental base:\n\n- Principle of virtual work for linear elasticity and the strain energy of a uniaxial bar: the elastic energy stored in a bar of Young’s modulus $E$, cross-sectional area $A$, and length $L$ under an end displacement $u$ is $U = \\dfrac{1}{2}\\dfrac{EA}{L}u^2$. The corresponding end force is $F = \\dfrac{\\partial U}{\\partial u} = \\dfrac{EA}{L}u$.\n- For a strip of unit thickness and unit width per unit interface length, the condensed normal response per unit interface length is a linear spring with stiffness $k = \\dfrac{E}{L}$ such that the traction per unit length is $t(y) = k\\,u(y)$, where $u(y)$ is the normal displacement at the interface.\n\nDiscretization and weak forms:\n\n- Discretize each side of the interface independently using two-node linear elements along $y \\in [0,H]$. Let the slave side have nodes at coordinates $y_s^i$ ($i=0,\\dots,n_s-1$) and the master side at $y_m^j$ ($j=0,\\dots,n_m-1$), both covering the full interval $[0,H]$ but with potentially different partitions. Let $N_s(y)$ and $N_m(y)$ denote the corresponding piecewise linear shape functions.\n- The interface energy on one side is $\\displaystyle \\Pi_{\\text{side}}[u] = \\int_{0}^{H} \\dfrac{1}{2} k \\, u(y)^2 \\, \\mathrm{d}y$, whose first variation yields the side stiffness bilinear form $\\displaystyle a_{\\text{side}}(u,v) = \\int_{0}^{H} k \\, u(y) v(y) \\, \\mathrm{d}y$. For an element of length $\\ell$, the local contribution in the finite element method (FEM) with two-node linear shape functions is $\\displaystyle K_e = k \\int_{e} N^\\top N \\, \\mathrm{d}y = k \\,\\dfrac{\\ell}{6} \\begin{bmatrix} 2 & 1 \\\\ 1 & 2 \\end{bmatrix}$.\n- An external interface traction (per unit length) $p_{\\text{ext}}(y)$ acting on the slave side enters the right-hand side as $\\displaystyle f_s = \\int_{0}^{H} N_s^\\top(y) \\, p_{\\text{ext}}(y) \\, \\mathrm{d}y$. For action-reaction, the master side receives $\\displaystyle f_m = \\int_{0}^{H} N_m^\\top(y) \\, \\big(-p_{\\text{ext}}(y)\\big) \\, \\mathrm{d}y$.\n- Enforce weak continuity of displacement across the nonmatching interface using the mortar method with Lagrange multipliers (LM). Choose the LM space equal to the slave side space and denote its shape functions by $N_\\lambda(y)$, taken equal to $N_s(y)$. The discrete constraint is $\\displaystyle \\int_{0}^{H} N_\\lambda(y)\\,\\big(u_s(y) - u_m(y)\\big)\\,\\mathrm{d}y = 0$. This yields the coupling matrix blocks $\\displaystyle D_s = \\int_{0}^{H} N_\\lambda(y)\\,N_s^\\top(y)\\,\\mathrm{d}y$ and $\\displaystyle D_m = \\int_{0}^{H} N_\\lambda(y)\\,N_m^\\top(y)\\,\\mathrm{d}y$. Define $\\displaystyle B = \\big[D_s\\; -D_m\\big]$ so that the constraint is $\\displaystyle B \\, \\begin{bmatrix} \\mathbf{u}_s \\\\ \\mathbf{u}_m \\end{bmatrix} = \\mathbf{0}$.\n- Assemble the block-diagonal primal stiffness $\\displaystyle K = \\mathrm{diag}(K_s, K_m)$ with $K_s$ and $K_m$ constructed as above from the respective $k_s = \\dfrac{E_s}{L_s}$ and $k_m = \\dfrac{E_m}{L_m}$. The global right-hand side is $\\displaystyle \\mathbf{f} = \\begin{bmatrix} \\mathbf{f}_s \\\\ \\mathbf{f}_m \\end{bmatrix}$ with interface traction loads included as indicated. The saddle-point system to solve is\n$$\n\\begin{bmatrix}\nK & B^\\top \\\\\nB & 0\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{u} \\\\\n\\boldsymbol{\\lambda}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{f} \\\\\n\\mathbf{0}\n\\end{bmatrix},\n\\quad\n\\mathbf{u} = \\begin{bmatrix} \\mathbf{u}_s \\\\ \\mathbf{u}_m \\end{bmatrix}.\n$$\n\nNumerical integration:\n\n- Evaluate all interface integrals using Gaussian quadrature exact for polynomials up to degree three. In particular, you may use two-point Gauss quadrature on each element. For mortar terms involving $D_m$, at each quadrature point on a slave element, locate the containing master element and evaluate the master shape functions at that coordinate via affine mapping.\n\nQuantity to report:\n\n- For each test case, compute the interface-averaged Lagrange multiplier $\\displaystyle \\bar{\\lambda} = \\dfrac{1}{H}\\int_{0}^{H} \\lambda(y) \\,\\mathrm{d}y$. In the finite element discretization with the LM space equal to the slave space, this can be computed as $\\displaystyle \\bar{\\lambda} = \\dfrac{1}{H} \\,\\mathbf{w}^\\top \\boldsymbol{\\lambda}$, where $\\displaystyle \\mathbf{w}$ has components $\\displaystyle w_i = \\int_{0}^{H} N_{\\lambda,i}(y) \\,\\mathrm{d}y$, which assemble from element contributions $\\displaystyle \\dfrac{\\ell}{2}$ to each of the two end nodes of each element of length $\\ell$.\n- Express the final results as plain real numbers (floats). No angles or percentage values are involved. Physical units are: $E$ in pascal (newton per square meter), $L$ and $H$ in meters, $p_{\\text{ext}}$ in newton per meter, and $\\bar{\\lambda}$ in newton per meter. You do not need to print units; only print the numeric values.\n\nTest suite:\n\nImplement your program to run the following four test cases and output the four values $\\bar{\\lambda}$ in a single list as specified below.\n\n- Case $1$ (happy path, uniform load, moderately nonmatching meshes):\n  - $H = 1$.\n  - Slave nodes: $[0, 0.5, 1.0]$.\n  - Master nodes: $[0, 0.25, 0.75, 1.0]$.\n  - $E_s = 10^{10}$, $L_s = 1.0$, $E_m = 5\\times 10^{9}$, $L_m = 0.5$.\n  - $p_{\\text{ext}}(y) = 10^{6}$ (constant).\n- Case $2$ (zero external traction, same meshes as Case $1$):\n  - $H = 1$.\n  - Slave nodes: $[0, 0.5, 1.0]$.\n  - Master nodes: $[0, 0.25, 0.75, 1.0]$.\n  - $E_s = 10^{10}$, $L_s = 1.0$, $E_m = 5\\times 10^{9}$, $L_m = 0.5$.\n  - $p_{\\text{ext}}(y) = 0$.\n- Case $3$ (large stiffness contrast, uniform load):\n  - $H = 1$.\n  - Slave nodes: $[0, 0.5, 1.0]$.\n  - Master nodes: $[0, 0.5, 1.0]$.\n  - $E_s = 10^{12}$, $L_s = 1.0$, $E_m = 10^{9}$, $L_m = 1.0$.\n  - $p_{\\text{ext}}(y) = 2\\times 10^{6}$ (constant).\n- Case $4$ (highly nonmatching meshes, linearly varying traction):\n  - $H = 1$.\n  - Slave nodes: $[0, 0.2, 0.4, 0.8, 1.0]$.\n  - Master nodes: $[0, 1.0]$.\n  - $E_s = 5\\times 10^{9}$, $L_s = 1.0$, $E_m = 5\\times 10^{9}$, $L_m = 1.0$.\n  - $p_{\\text{ext}}(y) = 10^{6}\\,(1 + 0.5\\,y)$.\n\nFinal output specification:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of Cases $1$ through $4$, that is, $[\\bar{\\lambda}_1,\\bar{\\lambda}_2,\\bar{\\lambda}_3,\\bar{\\lambda}_4]$.", "solution": "The user's request is a well-posed problem in computational solid mechanics, specifically concerning the application of the finite element method (FEM) with mortar techniques for contact between two elastic bodies. The problem is scientifically sound, mathematically consistent, and provides all necessary information for a unique solution.\n\n### Step 1: Extract Givens\n- **Problem Domain**: 1D interface parameterized by $y \\in [0,H]$.\n- **Physical Model**: Two elastic subdomains are modeled as continuous distributions of linear springs attached to a fixed ground. The stiffness per unit interface length for each side is $k_s = E_s/L_s$ and $k_m = E_m/L_m$.\n- **Governing Energy Functional**: The energy for one side is $\\Pi_{\\text{side}}[u] = \\int_{0}^{H} \\frac{1}{2} k \\, u(y)^2 \\, \\mathrm{d}y$.\n- **Weak Form (Stiffness)**: The associated bilinear form is $a_{\\text{side}}(u,v) = \\int_{0}^{H} k \\, u(y) v(y) \\, \\mathrm{d}y$.\n- **FEM Discretization**: Two-node linear elements.\n- **Element Stiffness Matrix**: For an element of length $\\ell$, $K_e = k \\frac{\\ell}{6} \\begin{bmatrix} 2 & 1 \\\\ 1 & 2 \\end{bmatrix}$.\n- **External Load Vector (Slave)**: $\\mathbf{f}_s = \\int_{0}^{H} N_s^\\top(y) \\, p_{\\text{ext}}(y) \\, \\mathrm{d}y$.\n- **External Load Vector (Master)**: $\\mathbf{f}_m = \\int_{0}^{H} N_m^\\top(y) \\, \\big(-p_{\\text{ext}}(y)\\big) \\, \\mathrm{d}y$.\n- **Mortar Constraint**: Weak continuity is enforced via Lagrange multipliers ($\\lambda$). The discrete form of the constraint $\\int_{0}^{H} (u_s - u_m) \\lambda \\, \\mathrm{d}y = 0$ is $B \\mathbf{u} = \\mathbf{0}$, where $\\mathbf{u} = [\\mathbf{u}_s^\\top, \\mathbf{u}_m^\\top]^\\top$.\n- **Coupling Matrices**: $B = [D_s \\;\\; -D_m]$, with $D_s = \\int_{0}^{H} N_\\lambda(y) N_s^\\top(y) \\, \\mathrm{d}y$ and $D_m = \\int_{0}^{H} N_\\lambda(y) N_m^\\top(y) \\, \\mathrm{d}y$. The Lagrange multiplier space is chosen to be the slave space, so $N_\\lambda = N_s$.\n- **Augmented System**: The problem is to solve the saddle-point system:\n$$\n\\begin{bmatrix}\nK & B^\\top \\\\\nB & 0\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{u} \\\\\n\\boldsymbol{\\lambda}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{f} \\\\\n\\mathbf{0}\n\\end{bmatrix}\n$$\nwhere $K = \\mathrm{diag}(K_s, K_m)$ and $\\mathbf{f} = [\\mathbf{f}_s^\\top, \\mathbf{f}_m^\\top]^\\top$.\n- **Numerical Integration**: All integrals are to be evaluated using two-point Gaussian quadrature, which is exact for polynomials up to degree three.\n- **Quantity to Report**: The interface-averaged Lagrange multiplier, $\\bar{\\lambda} = \\frac{1}{H} \\int_{0}^{H} \\lambda(y) \\,\\mathrm{d}y = \\frac{1}{H} \\mathbf{w}^\\top \\boldsymbol{\\lambda}$, where $w_i = \\int_{0}^{H} N_{\\lambda,i}(y) \\,\\mathrm{d}y$.\n- **Test Cases**: Four specific cases with defined geometries ($H$, node locations), material properties ($E, L$), and external traction profiles ($p_{\\text{ext}}(y)$) are provided.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The model simplifies 3D elasticity to a 1D Winkler-type foundation model, a standard and valid approach in many engineering contexts. The finite element formulation, including the use of mortar methods with Lagrange multipliers to handle non-matching meshes, is a cornerstone of modern computational mechanics. The provided stiffness matrix and load vector formulations are standard for 1D linear elements.\n- **Well-Posed**: The stiffness matrix $K$ is positive definite as it is assembled from positive definite element matrices (the underlying physical model is stable). The choice of the slave space for the Lagrange multipliers is known to satisfy the inf-sup (LBB) stability condition for this class of problems, which guarantees that the augmented system matrix is invertible and the problem has a unique, stable solution.\n- **Objective**: The problem is stated in precise mathematical and engineering terms, free of ambiguity or subjective language.\n- **Completeness and Consistency**: The problem is self-contained. All necessary equations, parameters, and numerical procedures are defined. There are no contradictions. The dimensional consistency of the term $k=E/L$ (units of N/m$^3$) with the energy functional $\\int \\frac{1}{2} k u^2 dy$ (integrand units of (N/m$^3$)m$^2$ = N/m, integrated over m to give N$\\cdot$m or Joules) is correct under the interpretation of $k$ as a stiffness density.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete solution will be provided.\n\n### Principle-Based Design of the Solution\n\nThe solution involves implementing a finite element procedure to construct and solve the specified augmented linear system for each test case. The core steps are as follows:\n\n1.  **System Assembly per Side**: For each subdomain (slave and master), we assemble its stiffness matrix ($K_s$, $K_m$) and external load vector ($\\mathbf{f}_s$, $\\mathbf{f}_m$).\n    -   The element stiffness matrix $K_e$ is assembled into the global side-specific matrix by iterating through the elements of the mesh. The formula $K_e = k \\frac{\\ell}{6} \\begin{bmatrix} 2 & 1 \\\\ 1 & 2 \\end{bmatrix}$ is directly applied.\n    -   The element load vector $\\mathbf{f}_e = \\int_e N^\\top p(y) \\, \\mathrm{d}y$ is computed using two-point Gaussian quadrature over each element to accurately integrate the product of the linear shape functions and the (potentially non-constant) traction profile. Remember that $p(y) = -p_{\\text{ext}}(y)$ for the master side.\n\n2.  **Mortar Coupling Matrix Assembly**: The coupling matrices $D_s$ and $D_m$ are assembled. These matrices enforce the displacement continuity in a weak sense.\n    -   $D_s = \\int N_s N_s^\\top \\, \\mathrm{d}y$ is simply the mass matrix on the slave mesh. Its assembly is analogous to the stiffness matrix assembly, using the element mass matrix $M_e = \\frac{\\ell}{6} \\begin{bmatrix} 2 & 1 \\\\ 1 & 2 \\end{bmatrix}$.\n    -   $D_m = \\int N_s N_m^\\top \\, \\mathrm{d}y$ is the crucial cross-term. Its computation requires integrating over the slave mesh elements. For each quadrature point on a slave element, we must:\n        a. Determine its global coordinate $y_q$.\n        b. Find which master element contains $y_q$.\n        c. Evaluate the master side's shape functions $N_m$ at $y_q$.\n        d. The integrand at the quadrature point is the outer product of the slave shape functions and the master shape functions, which is then weighted and summed.\n\n3.  **Construction of the Global Augmented System**: The full saddle-point system is constructed from the assembled blocks:\n    -   The primal stiffness matrix $K$ is a block-diagonal matrix of $K_s$ and $K_m$.\n    -   The constraint matrix is $B = [D_s, -D_m]$.\n    -   The global matrix $A$, right-hand side vector $RHS$, and unknown vector `sol` are formed as:\n        $$ A = \\begin{bmatrix} K & B^\\top \\\\ B & 0 \\end{bmatrix}, \\quad RHS = \\begin{bmatrix} \\mathbf{f} \\\\ \\mathbf{0} \\end{bmatrix}, \\quad \\text{sol} = \\begin{bmatrix} \\mathbf{u} \\\\ \\boldsymbol{\\lambda} \\end{bmatrix} $$\n\n4.  **Solution and Post-Processing**:\n    -   The linear system $A \\cdot \\text{sol} = RHS$ is solved using a standard direct solver.\n    -   The Lagrange multiplier coefficient vector $\\boldsymbol{\\lambda}$ is extracted from the solution vector.\n    -   The interface-averaged Lagrange multiplier $\\bar{\\lambda}$ is computed via the weighted sum $\\bar{\\lambda} = \\frac{1}{H} \\mathbf{w}^\\top \\boldsymbol{\\lambda}$. The weight vector $\\mathbf{w}$ is computed by summing the contributions from each slave element, where an element of length $\\ell$ contributes $\\ell/2$ to each of its two nodes' weights.\n\nAn important analytical property of this specific physical model is that the interface-averaged Lagrange multiplier must equal the interface-averaged external traction, i.e., $\\bar{\\lambda} = \\bar{p}_{\\text{ext}}$. This is because the equivalent spring stiffness of the combined system, $(k_s^{-1} + k_m^{-1})^{-1}$, is constant across the interface. This provides a robust method for verifying the numerical results.", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import block_diag\n\ndef solve():\n    \"\"\"\n    Main function to solve the mortar-coupled problem for the given test cases.\n    \"\"\"\n\n    # Constants for 2-point Gaussian Quadrature on the reference interval [0, 1]\n    gauss_pts = np.array([0.5 - 0.5 / np.sqrt(3), 0.5 + 0.5 / np.sqrt(3)])\n    gauss_wts = np.array([0.5, 0.5])\n\n    def assemble_side(nodes, k, p_ext_func):\n        \"\"\"Assembles the stiffness matrix K and load vector f for a single side.\"\"\"\n        n = len(nodes)\n        K_side = np.zeros((n, n))\n        f_side = np.zeros(n)\n\n        for e in range(n - 1):\n            i, j = e, e + 1\n            y_i, y_j = nodes[i], nodes[j]\n            ell = y_j - y_i\n\n            # Element stiffness matrix (derived from int(k * N^T * N * dy))\n            K_e = (k * ell / 6.0) * np.array([[2, 1], [1, 2]])\n            K_side[np.ix_([i, j], [i, j])] += K_e\n\n            # Element load vector using Gaussian quadrature\n            f_e = np.zeros(2)\n            for q_idx, xi in enumerate(gauss_pts):\n                w_q = gauss_wts[q_idx]\n                y_q = y_i + ell * xi\n                p_val = p_ext_func(y_q)\n                N_vals = np.array([1 - xi, xi])\n                f_e += N_vals * p_val * w_q * ell\n            f_side[[i, j]] += f_e\n\n        return K_side, f_side\n\n    def assemble_coupling(slave_nodes, master_nodes):\n        \"\"\"Assembles the mortar coupling matrices D_s and D_m.\"\"\"\n        n_s = len(slave_nodes)\n        n_m = len(master_nodes)\n        \n        # D_s is the mass matrix on the slave mesh\n        D_s = np.zeros((n_s, n_s))\n        for e in range(n_s - 1):\n            i, j = e, e + 1\n            ell = slave_nodes[j] - slave_nodes[i]\n            m_e = (ell / 6.0) * np.array([[2, 1], [1, 2]])\n            D_s[np.ix_([i, j], [i, j])] += m_e\n\n        # D_m is the cross-term matrix (slave-master mass matrix)\n        D_m = np.zeros((n_s, n_m))\n        master_elems = list(zip(master_nodes[:-1], master_nodes[1:]))\n\n        # Integration is performed over each slave element\n        for e_s in range(n_s - 1):\n            s_node_i, s_node_j = e_s, e_s + 1\n            y_i_s, y_j_s = slave_nodes[s_node_i], slave_nodes[s_node_j]\n            ell_s = y_j_s - y_i_s\n\n            for q_idx, xi_s in enumerate(gauss_pts):\n                w_q = gauss_wts[q_idx]\n                y_q = y_i_s + ell_s * xi_s\n                \n                N_s_vals = np.array([1 - xi_s, xi_s])\n\n                # Find the master element containing the quadrature point y_q\n                for e_m, (y_i_m, y_j_m) in enumerate(master_elems):\n                    if y_i_m - 1e-12 <= y_q <= y_j_m + 1e-12:\n                        m_node_i, m_node_j = e_m, e_m + 1\n                        ell_m = y_j_m - y_i_m\n                        \n                        xi_m = (y_q - y_i_m) / ell_m if not np.isclose(ell_m, 0) else \\\n                               (0.0 if np.isclose(y_q, y_i_m) else 1.0)\n                        \n                        N_m_vals_local = np.array([1 - xi_m, xi_m])\n                        \n                        contrib = np.outer(N_s_vals, N_m_vals_local) * w_q * ell_s\n                        D_m[np.ix_([s_node_i, s_node_j], [m_node_i, m_node_j])] += contrib\n                        break\n\n        return D_s, D_m\n\n    def compute_avg_lambda(lm_coeffs, slave_nodes, H):\n        \"\"\"Computes the interface-averaged Lagrange multiplier.\"\"\"\n        n_s = len(slave_nodes)\n        w = np.zeros(n_s)\n        for e in range(n_s - 1):\n            i, j = e, e + 1\n            ell = slave_nodes[j] - slave_nodes[i]\n            w[i] += ell / 2.0\n            w[j] += ell / 2.0\n        \n        integral_lambda = w.T @ lm_coeffs\n        return integral_lambda / H\n\n    def run_case(case_params):\n        \"\"\"Executes the full FEM procedure for a single test case.\"\"\"\n        H, slave_nodes, master_nodes, E_s, L_s, E_m, L_m, p_ext_func = case_params\n        slave_nodes = np.array(slave_nodes, dtype=float)\n        master_nodes = np.array(master_nodes, dtype=float)\n        \n        k_s = E_s / L_s\n        k_m = E_m / L_m\n        n_s = len(slave_nodes)\n        n_m = len(master_nodes)\n\n        K_s, f_s = assemble_side(slave_nodes, k_s, p_ext_func)\n        K_m, f_m = assemble_side(master_nodes, k_m, lambda y: -p_ext_func(y))\n        \n        D_s, D_m = assemble_coupling(slave_nodes, master_nodes)\n\n        K = block_diag(K_s, K_m)\n        f = np.concatenate([f_s, f_m])\n        B = np.hstack([D_s, -D_m])\n        \n        n_dof = n_s + n_m\n        n_lm = n_s\n        N = n_dof + n_lm\n        \n        A = np.zeros((N, N))\n        A[:n_dof, :n_dof] = K\n        A[:n_dof, n_dof:] = B.T\n        A[n_dof:, :n_dof] = B\n\n        RHS = np.zeros(N)\n        RHS[:n_dof] = f\n\n        sol = np.linalg.solve(A, RHS)\n        \n        lm_coeffs = sol[n_dof:]\n        avg_lambda = compute_avg_lambda(lm_coeffs, slave_nodes, H)\n        \n        return avg_lambda\n\n    test_cases = [\n        (1.0, [0.0, 0.5, 1.0], [0.0, 0.25, 0.75, 1.0], 1e10, 1.0, 5e9, 0.5, lambda y: 1e6),\n        (1.0, [0.0, 0.5, 1.0], [0.0, 0.25, 0.75, 1.0], 1e10, 1.0, 5e9, 0.5, lambda y: 0.0),\n        (1.0, [0.0, 0.5, 1.0], [0.0, 0.5, 1.0], 1e12, 1.0, 1e9, 1.0, lambda y: 2e6),\n        (1.0, [0.0, 0.2, 0.4, 0.8, 1.0], [0.0, 1.0], 5e9, 1.0, 5e9, 1.0, lambda y: 1e6 * (1 + 0.5 * y))\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_case(case)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3588891"}]}