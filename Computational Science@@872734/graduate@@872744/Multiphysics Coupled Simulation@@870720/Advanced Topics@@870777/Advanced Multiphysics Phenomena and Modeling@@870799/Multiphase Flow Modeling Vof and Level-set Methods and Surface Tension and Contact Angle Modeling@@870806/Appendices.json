{"hands_on_practices": [{"introduction": "The accuracy of the Volume of Fluid (VOF) method hinges on how the interface is reconstructed within each computational cell, a process that must also respect physical constraints like the static contact angle at solid boundaries. This practice explores the core of the Piecewise Linear Interface Calculation (PLIC) method, a cornerstone of modern VOF solvers. By working through this problem, you will gain first-hand experience with the geometric algorithms that enforce both mass conservation and physical boundary conditions at the most fundamental level of the simulation [@problem_id:3516372].", "problem": "Consider a two-dimensional geometric reconstruction of a liquid-gas interface in the Volume of Fluid (VOF) method, specifically the Piecewise Linear Interface Calculation (PLIC) representation, in a single Cartesian square cell of side length $L$ (in meters). The fluid region inside the cell is approximated by a half-plane defined by a unit interface normal vector $\\mathbf{m} \\in \\mathbb{R}^2$ and a scalar intercept $d$ (in meters), such that the fluid occupies the set $\\{\\mathbf{x} \\in [0,L]^2 \\mid \\mathbf{m}\\cdot \\mathbf{x} \\le d\\}$. The volume fraction (area fraction in two dimensions) of the fluid inside the cell is $C \\in [0,1]$, and it must be exactly enforced via the geometric reconstruction (mass conservation). In a boundary cell adjacent to a solid wall, the static contact angle must be enforced in the reconstructed interface orientation.\n\nUse the following context-appropriate fundamental base: the Young-Dupré relation for equilibrium wetting, $\\sigma_{sg} - \\sigma_{sl} = \\sigma_{lg} \\cos \\theta$, implies an equilibrium contact angle $\\theta$ at the triple line that constrains the orientation of the liquid-gas interface relative to the wall. In a two-dimensional geometric representation, this is modeled by enforcing that the angle between the interface normal $\\mathbf{m}$ and the wall unit normal $\\mathbf{n}_w$ equals $\\theta$ (measured in radians), i.e., $\\arccos(\\mathbf{m}\\cdot \\mathbf{n}_w) = \\theta$. Additionally, consistency with advection requires that the reconstructed normal be as close as possible to the interface orientation inferred from the volume fraction field, represented by a given nonzero vector $\\mathbf{n}_0 \\in \\mathbb{R}^2$ (not necessarily unit), which is typically the local gradient of the volume fraction in VOF.\n\nYour task is to implement the following steps for each test case:\n- Enforce the static contact angle constraint by choosing the unit interface normal $\\mathbf{m}$ that satisfies $\\|\\mathbf{m}\\|=1$ and $\\arccos(\\mathbf{m}\\cdot \\mathbf{n}_w) = \\theta$, and among all such unit vectors, minimizes the Euclidean deviation from the given $\\mathbf{n}_0$ in the least-squares sense. You must express the construction in purely geometric terms and ensure it is consistent with the wall orientation. All angles must be in radians.\n- Given $\\mathbf{m}$, compute the unique intercept $d$ (in meters) such that the area of the polygon $\\{\\mathbf{x} \\in [0,L]^2 \\mid \\mathbf{m}\\cdot \\mathbf{x} \\le d\\}$ equals $C L^2$. Treat the fluid as the set where $\\mathbf{m}\\cdot \\mathbf{x} \\le d$. The computation must be exact up to numerical tolerance and must be robust for all admissible $C \\in [0,1]$.\n- For each test case, produce two outputs: the dimensionless normalized intercept $d/L$ and the absolute contact-angle residual $\\Delta = |\\arccos(\\mathbf{m}\\cdot \\mathbf{n}_w) - \\theta|$ in radians.\n\nAngle unit requirement: all angles are to be treated in radians. Physical unit requirement: $L$ and $d$ are in meters; however, the required output will be the normalized intercept $d/L$ (dimensionless) and the residual $\\Delta$ (in radians).\n\nDesign constraints:\n- You must start from the fundamental laws and core definitions described above (Young-Dupré equilibrium and geometric constraint of angles and normals), without using pre-derived shortcut formulas for PLIC area fractions. The area must be computed from first principles by clipping the square with the half-plane and integrating the area of the resulting polygon.\n- The algorithm must be general and scientifically realistic for multiphase flow modeling, robust to boundary and edge cases, and should respect mass conservation by construction.\n\nTest Suite:\nImplement your program to process the following set of parameter values, each as a tuple $(L, C, \\mathbf{n}_0, \\mathbf{n}_w, \\theta)$, where vectors are given by their Cartesian components:\n1. $(L, C, \\mathbf{n}_0, \\mathbf{n}_w, \\theta) = (\\,1.0,\\, 0.3,\\, (1.0,\\, 0.2),\\, (0.0,\\, 1.0),\\, \\pi/3\\,)$\n2. $(L, C, \\mathbf{n}_0, \\mathbf{n}_w, \\theta) = (\\,1.0,\\, 0.01,\\, (0.0,\\, 1.0),\\, (1.0,\\, 0.0),\\, 2\\pi/3\\,)$\n3. $(L, C, \\mathbf{n}_0, \\mathbf{n}_w, \\theta) = (\\,0.8,\\, 0.5,\\, (-1.0,\\, 2.0),\\, (1/\\sqrt{2},\\, 1/\\sqrt{2}),\\, \\pi/2\\,)$\n4. $(L, C, \\mathbf{n}_0, \\mathbf{n}_w, \\theta) = (\\,1.0,\\, 0.95,\\, (0.1,\\, -1.0),\\, (0.0,\\, -1.0),\\, \\pi - 0.05\\,)$\n\nRequired final output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where the entries are ordered as $[d_1/L,\\Delta_1,d_2/L,\\Delta_2,d_3/L,\\Delta_3,d_4/L,\\Delta_4]$. For example, a syntactically correct output would look like $[0.12345,0.00000,0.23456,0.00001,0.34567,0.00000,0.45678,0.00002]$.", "solution": "The user has provided a well-defined problem in the domain of computational fluid dynamics, specifically concerning the geometric reconstruction of a fluid interface in a boundary cell using the Volume of Fluid (VOF) method. The task is to determine the interface orientation and position based on physical and numerical constraints. The problem is scientifically grounded, well-posed, and all necessary parameters are provided.\n\nThe solution proceeds in two primary stages as delineated by the problem statement:\n1.  Determination of the unit interface normal vector, $\\mathbf{m}$.\n2.  Calculation of the line intercept, $d$, that enforces the given volume fraction, $C$.\n\nI will address each stage methodically, building upon fundamental geometric and physical principles.\n\n### Part 1: Determination of the Interface Normal Vector $\\mathbf{m}$\n\nThe interface normal vector $\\mathbf{m}$ must satisfy two conditions: it must be a unit vector ($\\|\\mathbf{m}\\| = 1$) that respects the static contact angle $\\theta$ with the wall normal $\\mathbf{n}_w$, and it must be the closest possible such vector to a given orientation $\\mathbf{n}_0$.\n\nThe contact angle constraint is given by $\\arccos(\\mathbf{m} \\cdot \\mathbf{n}_w) = \\theta$, which is equivalent to the linear constraint $\\mathbf{m} \\cdot \\mathbf{n}_w = \\cos\\theta$.\n\nThe second condition is to minimize the Euclidean deviation from $\\mathbf{n}_0$, which means minimizing $\\|\\mathbf{m} - \\mathbf{n}_0\\|^2$. Expanding this expression, we get:\n$$\n\\|\\mathbf{m} - \\mathbf{n}_0\\|^2 = \\mathbf{m} \\cdot \\mathbf{m} - 2\\mathbf{m} \\cdot \\mathbf{n}_0 + \\mathbf{n}_0 \\cdot \\mathbf{n}_0 = \\|\\mathbf{m}\\|^2 - 2\\mathbf{m} \\cdot \\mathbf{n}_0 + \\|\\mathbf{n}_0\\|^2\n$$\nSince $\\|\\mathbf{m}\\|=1$ and $\\|\\mathbf{n}_0\\|$ is a fixed value for a given test case, minimizing this quantity is equivalent to maximizing the dot product $\\mathbf{m} \\cdot \\mathbf{n}_0$. Furthermore, maximizing $\\mathbf{m} \\cdot \\mathbf{n}_0$ is equivalent to maximizing $\\mathbf{m} \\cdot \\hat{\\mathbf{n}}_0$, where $\\hat{\\mathbf{n}}_0 = \\mathbf{n}_0 / \\|\\mathbf{n}_0\\|$ is the unit vector in the direction of $\\mathbf{n}_0$.\n\nTo solve this constrained optimization problem, we work in a 2D coordinate system defined by the wall normal $\\mathbf{n}_w$ and its orthogonal tangent vector $\\mathbf{t}_w$. Since $\\mathbf{n}_w$ is a unit vector, we can construct a unit tangent vector $\\mathbf{t}_w$ by rotating $\\mathbf{n}_w$ by $\\pi/2$ radians. If $\\mathbf{n}_w = (n_{wx}, n_{wy})$, then $\\mathbf{t}_w = (-n_{wy}, n_{wx})$. The set $\\{\\mathbf{n}_w, \\mathbf{t}_w\\}$ forms an orthonormal basis.\n\nAny 2D unit vector $\\mathbf{m}$ can be expressed in this basis as:\n$$\n\\mathbf{m} = \\alpha \\mathbf{n}_w + \\beta \\mathbf{t}_w, \\quad \\text{with} \\quad \\alpha^2 + \\beta^2 = 1\n$$\nApplying the contact angle constraint:\n$$\n\\mathbf{m} \\cdot \\mathbf{n}_w = (\\alpha \\mathbf{n}_w + \\beta \\mathbf{t}_w) \\cdot \\mathbf{n}_w = \\alpha \\|\\mathbf{n}_w\\|^2 + \\beta (\\mathbf{t}_w \\cdot \\mathbf{n}_w) = \\alpha(1) + \\beta(0) = \\alpha\n$$\nThus, the constraint $\\mathbf{m} \\cdot \\mathbf{n}_w = \\cos\\theta$ directly determines $\\alpha = \\cos\\theta$.\n\nSubstituting this into the unit vector condition $\\alpha^2 + \\beta^2 = 1$:\n$$\n\\cos^2\\theta + \\beta^2 = 1 \\implies \\beta^2 = 1 - \\cos^2\\theta = \\sin^2\\theta\n$$\nThis gives two possible values for $\\beta$: $\\beta = \\sin\\theta$ or $\\beta = -\\sin\\theta$ (since $\\theta \\in [0, \\pi]$, $\\sin\\theta \\ge 0$). This yields two candidate normal vectors:\n$$\n\\mathbf{m}_1 = (\\cos\\theta)\\mathbf{n}_w + (\\sin\\theta)\\mathbf{t}_w \\\\\n\\mathbf{m}_2 = (\\cos\\theta)\\mathbf{n}_w - (\\sin\\theta)\\mathbf{t}_w\n$$\nTo choose between these two candidates, we select the one that maximizes the dot product with $\\hat{\\mathbf{n}}_0$:\n$$\n\\mathbf{m}_1 \\cdot \\hat{\\mathbf{n}}_0 = (\\cos\\theta)(\\mathbf{n}_w \\cdot \\hat{\\mathbf{n}}_0) + (\\sin\\theta)(\\mathbf{t}_w \\cdot \\hat{\\mathbf{n}}_0) \\\\\n\\mathbf{m}_2 \\cdot \\hat{\\mathbf{n}}_0 = (\\cos\\theta)(\\mathbf{n}_w \\cdot \\hat{\\mathbf{n}}_0) - (\\sin\\theta)(\\mathbf{t}_w \\cdot \\hat{\\mathbf{n}}_0)\n$$\nComparing these, we see that $\\mathbf{m}_1$ is chosen if $(\\mathbf{t}_w \\cdot \\hat{\\mathbf{n}}_0) \\ge 0$, and $\\mathbf{m}_2$ is chosen if $(\\mathbf{t}_w \\cdot \\hat{\\mathbf{n}}_0)  0$. This can be captured by setting the sign of the $\\beta$ coefficient to match the sign of the projection of $\\hat{\\mathbf{n}}_0$ onto $\\mathbf{t}_w$.\nIn the degenerate case where $\\mathbf{t}_w \\cdot \\hat{\\mathbf{n}}_0 = 0$ (or $\\sin\\theta=0$), both choices are equivalent, and we can adopt a convention (e.g., choosing the positive sign).\n\nThe final expression for $\\mathbf{m}$ is:\n$$\n\\mathbf{m} = (\\cos\\theta)\\mathbf{n}_w + \\text{sign}(\\hat{\\mathbf{n}}_0 \\cdot \\mathbf{t}_w) (\\sin\\theta)\\mathbf{t}_w\n$$\nwhere we define $\\text{sign}(0)$ as $1$.\n\nThe contact angle residual $\\Delta = |\\arccos(\\mathbf{m} \\cdot \\mathbf{n}_w) - \\theta|$ is then computed. By construction, $\\mathbf{m} \\cdot \\mathbf{n}_w = \\cos\\theta$, so this residual should be zero up to floating-point precision, serving as a verification of the method.\n\n### Part 2: Calculation of the Intercept $d$\n\nGiven the normal vector $\\mathbf{m}$, we must find the intercept $d$ such that the area of the fluid region within the cell equals $C L^2$. The fluid region is defined as $S = \\{\\mathbf{x} \\in [0,L]^2 \\mid \\mathbf{m}\\cdot \\mathbf{x} \\le d\\}$. This is a mass conservation constraint.\n\nThe problem can be non-dimensionalized. Let $\\mathbf{x}' = \\mathbf{x}/L$ and $d' = d/L$. The cell becomes the unit square $[0,1]^2$, and the fluid region is defined by $\\mathbf{m} \\cdot \\mathbf{x}' \\le d'$. The area of this dimensionless region, $A(d')$, must equal the volume fraction $C$. The function $A(d')$ is a monotonically increasing function of $d'$, so a unique solution for $d'$ exists for any given $C \\in [0,1]$. We can find this $d'$ by solving the equation $A(d') - C = 0$ using a numerical root-finding algorithm.\n\nThe core of this part is the function $A(d')$ that computes the area of the unit square clipped by the half-plane $\\mathbf{m} \\cdot \\mathbf{x}' \\le d'$. As per the problem constraints, this area is not to be computed from a pre-derived formula but from first principles. A robust algorithm for this is to perform geometric clipping of the square polygon against the line and then compute the area of the resulting polygon.\n\nThe clipping can be implemented using a variant of the Sutherland-Hodgman algorithm. The unit square, with vertices $(0,0), (1,0), (1,1), (0,1)$, is clipped against the half-space defined by $\\mathbf{m} \\cdot \\mathbf{x}' - d' \\le 0$. The algorithm iterates through the edges of the square, generating a new list of vertices that form the boundary of the fluid polygon.\n\nOnce the vertices of the clipped polygon are found in order, its area can be calculated using the shoelace (or surveyor's) formula:\n$$\n\\text{Area} = \\frac{1}{2} \\left| \\sum_{i=1}^{N} (x_i y_{i+1} - x_{i+1} y_i) \\right|\n$$\nwhere $(x_{N+1}, y_{N+1}) = (x_1, y_1)$ and $N$ is the number of vertices.\n\nTo find the value of $d'$ that yields the target area $C$, we can use a bisection or Brent's method. We need to define an interval $[d'_{min}, d'_{max}]$ that is guaranteed to contain the root. The value of $\\mathbf{m} \\cdot \\mathbf{x}'$ is bounded within the unit square. The minimum and maximum are:\n$$\nd'_{min} = \\min_{\\mathbf{x}' \\in [0,1]^2} (\\mathbf{m} \\cdot \\mathbf{x}') = \\min(m_x, 0) + \\min(m_y, 0) \\\\\nd'_{max} = \\max_{\\mathbf{x}' \\in [0,1]^2} (\\mathbf{m} \\cdot \\mathbf{x}') = \\max(m_x, 0) + \\max(m_y, 0)\n$$\nWith the function $g(d') = A(d') - C$ and the bracketing interval $[d'_{min}, d'_{max}]$, a root-finding algorithm like `scipy.optimize.brentq` can efficiently find the unique $d'$ that satisfies the area constraint. This $d'$ is the final required output $d/L$.\n\nThe implementation will process each test case through these two stages to compute the required pair of outputs: the dimensionless intercept $d/L$ and the contact angle residual $\\Delta$.", "answer": "```python\nimport numpy as np\nfrom scipy import optimize\n\ndef solve():\n    \"\"\"\n    Solves the PLIC-VOF reconstruction problem for a set of test cases.\n\n    For each case, it first computes the interface normal vector 'm' that satisfies\n    the contact angle constraint and is closest to a given normal 'n0'.\n    Then, it calculates the interface intercept 'd' such that the fluid area\n    matches the given volume fraction 'C'.\n\n    Outputs are the dimensionless intercept d/L and the contact angle residual.\n    \"\"\"\n\n    test_cases = [\n        # (L, C, n0, nw, theta)\n        (1.0, 0.3, (1.0, 0.2), (0.0, 1.0), np.pi / 3),\n        (1.0, 0.01, (0.0, 1.0), (1.0, 0.0), 2 * np.pi / 3),\n        (0.8, 0.5, (-1.0, 2.0), (1.0 / np.sqrt(2), 1.0 / np.sqrt(2)), np.pi / 2),\n        (1.0, 0.95, (0.1, -1.0), (0.0, -1.0), np.pi - 0.05),\n    ]\n\n    results = []\n    TOL = 1e-12 # A small tolerance for floating point comparisons\n\n    for L, C, n0_tuple, nw_tuple, theta in test_cases:\n        n0 = np.array(n0_tuple, dtype=float)\n        nw = np.array(nw_tuple, dtype=float)\n\n        # Part 1: Determine the interface normal vector 'm'\n        \n        # Normalize n0, which is given as non-zero.\n        n0_hat = n0 / np.linalg.norm(n0)\n        \n        # Construct the orthonormal tangent vector to nw\n        tw = np.array([-nw[1], nw[0]])\n        \n        cos_theta = np.cos(theta)\n        sin_theta = np.sin(theta)\n        \n        # Determine the sign of the tangent component to maximize dot product with n0_hat\n        # sign(0) is handled by defaulting to 1.\n        sign_beta = np.sign(np.dot(n0_hat, tw))\n        if abs(sign_beta)  TOL:\n            sign_beta = 1.0\n            \n        m = cos_theta * nw + sign_beta * sin_theta * tw\n\n        # Compute the contact angle residual\n        dot_product = np.dot(m, nw)\n        # Clip to handle potential floating point inaccuracies outside [-1, 1]\n        dot_product = np.clip(dot_product, -1.0, 1.0)\n        delta = np.abs(np.arccos(dot_product) - theta)\n\n        # Part 2: Calculate the intercept 'd'\n        \n        def shoelace_area(vertices):\n            \"\"\"Computes the area of a polygon using the shoelace formula.\"\"\"\n            if len(vertices)  3:\n                return 0.0\n            \n            x = vertices[:, 0]\n            y = vertices[:, 1]\n            return 0.5 * np.abs(np.dot(x, np.roll(y, -1)) - np.dot(y, np.roll(x, -1)))\n\n        def calculate_area_in_unit_square(d_norm, m_vec):\n            \"\"\"\n            Calculates the fluid area in a unit square [0,1]x[0,1] for a given\n            interface normal 'm_vec' and normalized intercept 'd_norm'.\n            The fluid is the region where m.x = d_norm.\n            \"\"\"\n            square_vertices = np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]])\n            \n            output_vertices = []\n            for i in range(4):\n                p1 = square_vertices[i]\n                p2 = square_vertices[(i + 1) % 4]\n                \n                val_p1 = np.dot(m_vec, p1) - d_norm\n                val_p2 = np.dot(m_vec, p2) - d_norm\n                \n                p1_inside = val_p1 = TOL\n                p2_inside = val_p2 = TOL\n                \n                if p2_inside:\n                    if not p1_inside: # Crossing from out to in\n                        # The denominator should not be zero unless the line is parallel to the edge\n                        # and not crossing, which this logic branch won't enter.\n                        # However, for robustness:\n                        denom = val_p2 - val_p1\n                        if abs(denom)  TOL: continue # Edge is parallel to line, no intersection.\n                        t = -val_p1 / denom\n                        intersection = p1 + t * (p2 - p1)\n                        output_vertices.append(intersection)\n                    output_vertices.append(p2)\n                elif p1_inside: # Crossing from in to out\n                    denom = val_p2 - val_p1\n                    if abs(denom)  TOL: continue\n                    t = -val_p1 / denom\n                    intersection = p1 + t * (p2 - p1)\n                    output_vertices.append(intersection)\n\n            if not output_vertices:\n                # This occurs if the whole square is inside or outside\n                # Check value at a test point, e.g., the center\n                if np.dot(m_vec, [0.5, 0.5]) - d_norm = TOL:\n                    return 1.0 # Whole square is fluid\n                else:\n                    return 0.0 # No fluid in square\n            \n            return shoelace_area(np.array(output_vertices))\n\n        # Root finding for d_norm = d/L\n        \n        # Bounding interval for the root search\n        mx_pos = max(m[0], 0.0)\n        mx_neg = min(m[0], 0.0)\n        my_pos = max(m[1], 0.0)\n        my_neg = min(m[1], 0.0)\n        d_norm_min = mx_neg + my_neg\n        d_norm_max = mx_pos + my_pos\n\n        # Define the function whose root we want to find: Area(d_norm) - C = 0\n        def objective_func(d_norm):\n            return calculate_area_in_unit_square(d_norm, m) - C\n\n        # Handle trivial cases C=0 or C=1 to avoid root-finder issues at boundaries\n        if C  TOL:\n            d_norm_final = d_norm_min\n        elif C  1.0 - TOL:\n            d_norm_final = d_norm_max\n        else:\n            # Use a robust root-finding algorithm\n            d_norm_final = optimize.brentq(objective_func, d_norm_min - TOL, d_norm_max + TOL)\n        \n        results.extend([d_norm_final, delta])\n\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "3516372"}, {"introduction": "Once an interface is defined, it must be accurately advected with the flow while correctly interacting with the domain's boundaries, a critical task in simulations involving fluid entering or leaving the computational domain. This exercise focuses on simulating the advection of an interface using the level-set method, emphasizing the practical implementation of diverse boundary conditions such as Dirichlet inflow, non-reflecting outflow, and static contact angle walls. This practice involves building a miniature advection solver, providing crucial insights into how boundary data is managed and how interface dynamics are coupled to the larger domain in a time-dependent simulation [@problem_id:3516353].", "problem": "Consider two immiscible, incompressible fluids modeled by the incompressible Navier–Stokes equations and an interface-capturing method. Let the interface be represented by a level-set function $\\phi(\\mathbf{x},t)$ equal to the signed distance to the interface, positive in one phase and negative in the other. The advection of the interface in a prescribed velocity field $\\mathbf{u}$ is governed by the transport equation $ \\partial \\phi / \\partial t + \\mathbf{u} \\cdot \\nabla \\phi = 0 $. The capillary force due to surface tension is modeled using the Continuum Surface Force (CSF) approach, where the volumetric capillary force density is $\\mathbf{f}_{\\mathrm{st}} = \\sigma \\kappa \\delta_\\epsilon(\\phi) \\nabla \\phi$ with constant surface tension coefficient $\\sigma$, curvature $\\kappa = \\nabla \\cdot \\left( \\nabla \\phi / \\|\\nabla \\phi\\| \\right)$, and a regularized delta function $\\delta_\\epsilon(\\phi)$ constructed from the regularized Heaviside function $H_\\epsilon(\\phi)$. \n\nAt solid walls with unit normal $\\mathbf{n}_w$, a static contact angle boundary condition is enforced for the level-set normal $\\mathbf{n} = \\nabla \\phi / \\|\\nabla \\phi\\|$ via $\\mathbf{n}\\cdot \\mathbf{n}_w = \\cos \\theta$, where $\\theta$ is the prescribed static contact angle (in radians). On planar horizontal walls at $y=0$ and $y=L_y$, this implies a boundary relation for normal and tangential derivatives of $\\phi$ of the form $\\partial \\phi / \\partial y = \\cot \\theta \\, \\partial \\phi / \\partial x$ when evaluated at the wall. At an inflow boundary, the level-set field $\\phi$ is prescribed by the known incoming interface shape and velocity. At an outflow (open) boundary with outward normal in the $+x$ direction and $\\mathbf{u}=(U,0)$ with $U0$, a non-reflecting open boundary condition for $\\phi$ consistent with the outgoing characteristic is implemented by a zero normal gradient $\\partial \\phi / \\partial x = 0$ in the ghost region, while the interior update uses an upwind scheme.\n\nYou are to implement a two-dimensional finite-volume-like advection of $\\phi$ on a uniform Cartesian grid for three test cases. The velocity field is uniform, $\\mathbf{u} = (U,0)$ with constant $U$ for each case. The time discretization is explicit with a first-order upwind scheme in $x$ consistent with the sign of $U$. For $U0$, the update is\n$$\n\\phi_{i,j}^{n+1} = \\phi_{i,j}^{n} - \\Delta t \\, U \\, \\frac{\\phi_{i,j}^{n} - \\phi_{i-1,j}^{n}}{\\Delta x},\n$$\nfor interior indices $i \\ge 1$, while the $i=0$ boundary is set by a Dirichlet inflow value $\\phi_{\\mathrm{in}}(0,y,t^{n+1})$. For $U=0$, there is no change to $\\phi$ over time due to advection. The wall contact angle boundary condition is enforced weakly for gradient and curvature computations by constructing ghost values in the wall-normal direction $y$ to satisfy the discrete relation\n$$\n\\left.\\frac{\\partial \\phi}{\\partial y}\\right|_{y=0} = \\cot \\theta \\left.\\frac{\\partial \\phi}{\\partial x}\\right|_{y=0}, \\quad\n\\left.\\frac{\\partial \\phi}{\\partial y}\\right|_{y=L_y} = \\cot \\theta_{\\mathrm{top}} \\left.\\frac{\\partial \\phi}{\\partial x}\\right|_{y=L_y},\n$$\nwith $\\theta_{\\mathrm{top}} = \\pi - \\theta$.\n\nFor curvature, compute $\\kappa = \\nabla \\cdot \\left( \\nabla \\phi / \\|\\nabla \\phi\\| \\right)$ using centered differences with appropriate ghost values on $y$-boundaries as above and zero-gradient ghosting on $x$-boundaries. Use the smoothed Heaviside and delta functions\n$$\nH_\\epsilon(\\phi) = \n\\begin{cases}\n0,  \\phi \\le -\\epsilon,\\\\\n\\frac{1}{2}\\left[1 + \\frac{\\phi}{\\epsilon} + \\frac{1}{\\pi}\\sin\\left(\\frac{\\pi \\phi}{\\epsilon}\\right)\\right],  |\\phi|  \\epsilon,\\\\\n1,  \\phi \\ge \\epsilon,\n\\end{cases}\n\\quad\n\\delta_\\epsilon(\\phi) = H_\\epsilon'(\\phi) = \n\\begin{cases}\n\\frac{1}{2\\epsilon}\\left[1 + \\cos\\left(\\frac{\\pi \\phi}{\\epsilon}\\right)\\right],  |\\phi|  \\epsilon,\\\\\n0,  \\text{otherwise.}\n\\end{cases}\n$$\nDefine the volume fraction $C = H_\\epsilon(\\phi)$.\n\nYour tasks for each test case are:\n1. Evolve $\\phi$ from $t=0$ to $t=T$ using the described scheme and boundary conditions.\n2. Compute the root-mean-square error of the level-set field against the exact advected shape at time $t=T$:\n$$\nE_\\phi = \\left( \\frac{1}{N_x N_y} \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\left[\\phi_{i,j}^{\\mathrm{num}}(T) - \\phi_{i,j}^{\\mathrm{exact}}(T)\\right]^2 \\right)^{1/2}.\n$$\nExpress $E_\\phi$ in meters.\n3. Compute the integrated capillary traction contribution in the open boundary normal direction at the right boundary $x=L_x$ using the CSF representation:\n$$\nF_{\\mathrm{cap}} = \\int_0^{L_y} f_{\\mathrm{st},x}(x=L_x^{-},y) \\, \\mathrm{d}y \\approx \\sum_{j=0}^{N_y-1} \\left[ \\sigma \\, \\kappa \\, \\delta_\\epsilon(\\phi)\\, \\frac{\\partial \\phi}{\\partial x} \\right]_{i=N_x-1,j} \\Delta y,\n$$\nwhere the bracketed term is evaluated on the last interior column $i=N_x-1$. Express $F_{\\mathrm{cap}}$ in $\\mathrm{N/m}$.\n\nAngles must be provided and interpreted in radians. All lengths must be in meters, time in seconds, and velocity in meters per second. Surface tension $\\sigma$ must be in Newtons per meter. Use the Courant–Friedrichs–Lewy (CFL) condition to select a stable time step with $\\Delta t = \\mathrm{CFL} \\, \\Delta x / \\max(|U|,10^{-8})$ with $\\mathrm{CFL} = 0.4$, and use the minimum number of uniform steps to reach $T$ exactly by setting the final step size to match $T$.\n\nInterface definitions for exact and inflow conditions:\n- Straight interface (planar contact-angle-consistent inflow): define a line with normal angle $\\alpha = \\theta + \\pi/2$ and a point on the line $\\mathbf{r}_0(t) = (x_c + U t, y_c)$. The exact and inflow level-set is the signed distance to this line,\n$$\n\\phi_{\\mathrm{line}}(x,y,t) = \\cos\\alpha \\, (x - x_c - U t) + \\sin\\alpha \\, (y - y_c).\n$$\n- Circular interface (capillary-dominated shape at rest): choose radius $R$ and center $(x_{\\mathrm{ctr}}, y_{\\mathrm{ctr}})$; the exact level-set is\n$$\n\\phi_{\\mathrm{circ}}(x,y,t) = \\sqrt{(x - x_{\\mathrm{ctr}})^2 + (y - y_{\\mathrm{ctr}})^2} - R.\n$$\n\nTest suite:\n- Case 1 (planar inflow/outflow, moderate velocity, oblique contact): $L_x = 1.0$, $L_y = 0.5$, $N_x = 120$, $N_y = 60$, $U = 0.6$, $\\theta = \\pi/3$, $\\sigma = 0.072$, $\\epsilon = 2 \\Delta x$, $T = 0.4$, $x_c = 0.25 L_x$, $y_c = 0.5 L_y$.\n- Case 2 (open boundary with curved interface at rest): $L_x = 0.6$, $L_y = 0.4$, $N_x = 80$, $N_y = 60$, $U = 0.0$, $\\theta = \\pi/2$, $\\sigma = 0.072$, $\\epsilon = 2 \\Delta x$, $T = 0.01$, circular interface parameters $R = 0.08$, $x_{\\mathrm{ctr}} = 0.45$, $y_{\\mathrm{ctr}} = 0.20$.\n- Case 3 (planar inflow/outflow, higher velocity, different angle): $L_x = 0.5$, $L_y = 0.3$, $N_x = 80$, $N_y = 48$, $U = 1.2$, $\\theta = \\pi/4$, $\\sigma = 0.072$, $\\epsilon = 2 \\Delta x$, $T = 0.15$, $x_c = 0.20 L_x$, $y_c = 0.5 L_y$.\n\nRequired outputs:\n- For each case, compute the pair $\\left(E_\\phi, F_{\\mathrm{cap}}\\right)$ where $E_\\phi$ is in meters and $F_{\\mathrm{cap}}$ is in Newtons per meter. Your program should produce a single line of output containing all results as a comma-separated list enclosed in square brackets, ordered by cases and flattened as $[E_{\\phi,1}, F_{\\mathrm{cap},1}, E_{\\phi,2}, F_{\\mathrm{cap},2}, E_{\\phi,3}, F_{\\mathrm{cap},3}]$ with each number as a plain decimal.", "solution": "The problem is assessed to be valid. It is a well-posed, scientifically grounded problem in computational fluid dynamics, specifically focusing on the numerical advection of a level-set field and the computation of surface tension effects. All necessary parameters, equations, and boundary conditions are provided, and there are no internal contradictions.\n\nThe solution proceeds by implementing a numerical simulation for each of the three specified test cases. The core of the simulation involves evolving a level-set function, $\\phi(\\mathbf{x}, t)$, on a two-dimensional uniform Cartesian grid. The evolution is governed by the advection equation, discretized in time using an explicit forward Euler method and in space using a first-order upwind scheme.\n\nHere is a step-by-step breakdown of the methodology:\n\n**1. Grid and Initialization**\nFor each test case, a uniform Cartesian grid is defined with dimensions $L_x \\times L_y$ and resolution $N_x \\times N_y$. The grid spacings are $\\Delta x = L_x / N_x$ and $\\Delta y = L_y / N_y$. The level-set field, $\\phi$, is initialized at time $t=0$ on this grid. The initial shape of the interface is either a straight line (Cases 1 and 3) or a circle (Case 2), and $\\phi$ is defined as the signed distance to this initial interface.\n- For a straight interface, the exact level-set function is $\\phi_{\\mathrm{line}}(x,y,t) = \\cos\\alpha \\, (x - x_c - U t) + \\sin\\alpha \\, (y - y_c)$, where $\\alpha = \\theta + \\pi/2$.\n- For a circular interface, $\\phi_{\\mathrm{circ}}(x,y,t) = \\sqrt{(x - x_{\\mathrm{ctr}})^2 + (y - y_{\\mathrm{ctr}})^2} - R$.\n\n**2. Time Integration**\nThe advection equation $\\partial \\phi / \\partial t + U \\partial \\phi / \\partial x = 0$ is solved numerically from $t=0$ to $t=T$. The time step, $\\Delta t$, is determined by the Courant–Friedrichs–Lewy (CFL) condition: $\\Delta t = \\mathrm{CFL} \\cdot \\Delta x / \\max(|U|, 10^{-8})$, with $\\mathrm{CFL}=0.4$. To reach the final time $T$ precisely, the simulation takes a series of uniform steps of size $\\Delta t$, followed by a final, smaller time step to cover the remaining time. For Case 2, where $U=0$, the field $\\phi$ does not evolve.\n\n**3. Spatial Discretization and Boundary Conditions**\n- **Advection:** A first-order upwind scheme is used for the spatial derivative $\\partial \\phi / \\partial x$. For $U  0$, the update rule is:\n$$\n\\phi_{i,j}^{n+1} = \\phi_{i,j}^{n} - \\Delta t \\, U \\, \\frac{\\phi_{i,j}^{n} - \\phi_{i-1,j}^{n}}{\\Delta x}\n$$\n- **Inflow Boundary ($x=0$):** A Dirichlet boundary condition is applied. The value of $\\phi$ at the inflow column ($i=0$) is set at each time step using the known exact solution for the incoming interface, $\\phi_{\\mathrm{in}}(0,y,t^{n+1})$.\n- **Outflow Boundary ($x=L_x$):** The upwind scheme does not require an explicit boundary condition at the outflow for $U0$, as information propagates from the interior.\n- **Wall Boundaries ($y=0, L_y$):** The static contact angle condition, $\\mathbf{n}\\cdot \\mathbf{n}_w = \\cos \\theta$, is enforced for gradient and curvature calculations. This condition is translated into a relation between the partial derivatives of $\\phi$ at the wall, e.g., $\\partial \\phi / \\partial y = \\cot \\theta \\, \\partial \\phi / \\partial x$ at $y=0$. This is implemented by constructing ghost cell values for $\\phi$ outside the physical domain. For a grid point $(i,0)$ at the bottom wall, the ghost value $\\phi_{i,-1}$ is set to satisfy a discrete version of this boundary condition. A first-order accurate discretization at the wall yields:\n$$\n\\frac{\\phi_{i,0} - \\phi_{i,-1}}{\\Delta y} = \\cot\\theta \\left. \\frac{\\partial \\phi}{\\partial x} \\right|_{i,0}\n$$\nThis allows us to solve for $\\phi_{i,-1}$. A similar procedure is applied at the top wall ($y=L_y$) with contact angle $\\theta_{\\mathrm{top}} = \\pi - \\theta$. The term $\\partial\\phi/\\partial x$ at the wall boundary is computed using centered differences for interior wall points and one-sided differences at the corners.\n\n**4. Curvature and Force Calculation**\nThe curvature $\\kappa$ is computed from the level-set field using the standard formula involving second partial derivatives:\n$$\n\\kappa = \\frac{\\phi_{xx} \\phi_y^2 - 2 \\phi_x \\phi_y \\phi_{xy} + \\phi_{yy} \\phi_x^2}{(\\phi_x^2 + \\phi_y^2)^{3/2}}\n$$\nAll partial derivatives ($\\phi_x, \\phi_y, \\phi_{xx}, \\phi_{yy}, \\phi_{xy}$) are calculated using second-order centered difference schemes. This requires the `phi` field to be padded with a layer of ghost cells, which are populated according to the boundary conditions described above. For the $x$-boundaries, a zero-gradient condition ($\\partial\\phi/\\partial x = 0$) is used for the ghost cells needed for curvature calculation.\n\n**5. Final Output Computation**\nAfter evolving the solution to $t=T$, two quantities are computed for each case:\n- **RMS Error ($E_\\phi$):** The root-mean-square error between the final numerical solution $\\phi^{\\mathrm{num}}(T)$ and the exact analytical solution $\\phi^{\\mathrm{exact}}(T)$ is calculated over the entire grid.\n$$\nE_\\phi = \\left( \\frac{1}{N_x N_y} \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\left[\\phi_{i,j}^{\\mathrm{num}}(T) - \\phi_{i,j}^{\\mathrm{exact}}(T)\\right]^2 \\right)^{1/2}\n$$\n- **Integrated Capillary Traction ($F_{\\mathrm{cap}}$):** The capillary force contribution normal to the outflow boundary is calculated by integrating the $x$-component of the Continuum Surface Force (CSF) density, $f_{\\mathrm{st},x}$, over the boundary. This is approximated by a sum over the last interior column of grid cells ($i=N_x-1$):\n$$\nF_{\\mathrm{cap}} \\approx \\sum_{j=0}^{N_y-1} \\left[ \\sigma \\, \\kappa \\, \\delta_\\epsilon(\\phi)\\, \\frac{\\partial \\phi}{\\partial x} \\right]_{i=N_x-1,j} \\Delta y\n$$\nThe regularized delta function $\\delta_\\epsilon(\\phi)$ localizes the force to a thin band around the interface $|\\phi|\\epsilon$. As the interface in all test cases does not intersect or come close to the outflow boundary column, this force is expected to be zero.\nThe entire process is encapsulated in a Python script using the `numpy` library for numerical computations.", "answer": "```python\nimport numpy as np\n\ndef delta_eps(phi, epsilon):\n    \"\"\"\n    Computes the regularized Dirac delta function based on a smoothed Heaviside function.\n\n    Args:\n        phi (np.ndarray): The level-set field.\n        epsilon (float): The thickness parameter for regularization.\n\n    Returns:\n        np.ndarray: The value of the regularized delta function.\n    \"\"\"\n    res = np.zeros_like(phi)\n    mask = np.abs(phi)  epsilon\n    phi_masked = phi[mask]\n    res[mask] = (1.0 / (2.0 * epsilon)) * (1.0 + np.cos(np.pi * phi_masked / epsilon))\n    return res\n\ndef get_phi_line(x_grid, y_grid, t, xc, yc, U, theta):\n    \"\"\"\n    Computes the signed distance function for a straight line interface.\n\n    Args:\n        x_grid (np.ndarray): X-coordinates of the grid.\n        y_grid (np.ndarray): Y-coordinates of the grid.\n        t (float): Current time.\n        xc (float): Initial x-position of a point on the line.\n        yc (float): Initial y-position of a point on the line.\n        U (float): Advection velocity in x-direction.\n        theta (float): Contact angle in radians.\n\n    Returns:\n        np.ndarray: The level-set field for the line.\n    \"\"\"\n    alpha = theta + np.pi / 2.0\n    cos_alpha = np.cos(alpha)\n    sin_alpha = np.sin(alpha)\n    return cos_alpha * (x_grid - xc - U * t) + sin_alpha * (y_grid - yc)\n\ndef get_phi_circ(x_grid, y_grid, t, x_ctr, y_ctr, R):\n    \"\"\"\n    Computes the signed distance function for a circular interface.\n\n    Args:\n        x_grid (np.ndarray): X-coordinates of the grid.\n        y_grid (np.ndarray): Y-coordinates of the grid.\n        t (float): Current time (unused for static case).\n        x_ctr (float): X-coordinate of the circle's center.\n        y_ctr (float): Y-coordinate of the circle's center.\n        R (float): Radius of the circle.\n\n    Returns:\n        np.ndarray: The level-set field for the circle.\n    \"\"\"\n    return np.sqrt((x_grid - x_ctr)**2 + (y_grid - y_ctr)**2) - R\n\ndef compute_kappa_and_dphidx(phi, dx, dy, theta):\n    \"\"\"\n    Computes curvature and the x-gradient of the level-set field.\n\n    Args:\n        phi (np.ndarray): The level-set field.\n        dx (float): Grid spacing in x.\n        dy (float): Grid spacing in y.\n        theta (float): Contact angle in radians.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple containing the curvature field and the d(phi)/dx field.\n    \"\"\"\n    Nx, Ny = phi.shape\n    theta_top = np.pi - theta\n\n    phi_pad = np.pad(phi, 1, 'constant')\n\n    # X-boundary ghost cells (zero-gradient for curvature calculation)\n    phi_pad[0, 1:-1] = phi[0, :]\n    phi_pad[-1, 1:-1] = phi[-1, :]\n\n    # Y-boundary ghost cells (contact angle)\n    cot_theta = 1.0 / np.tan(theta) if abs(np.sin(theta))  1e-12 else 0.0\n    cot_theta_top = 1.0 / np.tan(theta_top) if abs(np.sin(theta_top))  1e-12 else 0.0\n\n    for i in range(Nx):\n        ip = i + 1\n        # Bottom wall\n        if i == 0:\n            dphidx_wall_bot = (phi[i + 1, 0] - phi[i, 0]) / dx\n        elif i == Nx - 1:\n            dphidx_wall_bot = (phi[i, 0] - phi[i - 1, 0]) / dx\n        else:\n            dphidx_wall_bot = (phi[i + 1, 0] - phi[i - 1, 0]) / (2.0 * dx)\n        phi_pad[ip, 0] = phi[i, 0] - dy * cot_theta * dphidx_wall_bot\n\n        # Top wall\n        if i == 0:\n            dphidx_wall_top = (phi[i + 1, -1] - phi[i, -1]) / dx\n        elif i == Nx - 1:\n            dphidx_wall_top = (phi[i, -1] - phi[i - 1, -1]) / dx\n        else:\n            dphidx_wall_top = (phi[i + 1, -1] - phi[i - 1, -1]) / (2.0 * dx)\n        phi_pad[ip, -1] = phi[i, -1] + dy * cot_theta_top * dphidx_wall_top\n\n    # Corner ghost cells\n    phi_pad[0,0] = (phi_pad[1,0] + phi_pad[0,1])/2.0\n    phi_pad[-1,0] = (phi_pad[-2,0] + phi_pad[-1,1])/2.0\n    phi_pad[0,-1] = (phi_pad[1,-1] + phi_pad[0,-2])/2.0\n    phi_pad[-1,-1] = (phi_pad[-2,-1] + phi_pad[-1,-2])/2.0\n\n    # Derivatives using central differences on the padded grid\n    dphidx = (phi_pad[2:, 1:-1] - phi_pad[:-2, 1:-1]) / (2.0 * dx)\n    dphidy = (phi_pad[1:-1, 2:] - phi_pad[1:-1, :-2]) / (2.0 * dy)\n    d2phidx2 = (phi_pad[2:, 1:-1] - 2.0 * phi[... , :] + phi_pad[:-2, 1:-1]) / (dx**2)\n    d2phidy2 = (phi_pad[1:-1, 2:] - 2.0 * phi[... , :] + phi_pad[1:-1, :-2]) / (dy**2)\n    d2phidxy = (phi_pad[2:, 2:] - phi_pad[:-2, 2:] - phi_pad[2:, :-2] + phi_pad[:-2, :-2]) / (4.0 * dx * dy)\n\n    mag_grad_sq = dphidx**2 + dphidy**2\n    mag_grad_sq[mag_grad_sq  1e-24] = 1e-24\n    \n    numerator = d2phidx2 * dphidy**2 - 2.0 * dphidx * dphidy * d2phidxy + d2phidy2 * dphidx**2\n    kappa = numerator / (mag_grad_sq**1.5)\n    \n    return kappa, dphidx\n\ndef solve_case(Lx, Ly, Nx, Ny, U, theta, sigma, T, interface_type, **kwargs):\n    \"\"\"\n    Solves a single test case for level-set advection and force calculation.\n    \"\"\"\n    dx = Lx / Nx\n    dy = Ly / Ny\n    \n    x = (np.arange(Nx) + 0.5) * dx\n    y = (np.arange(Ny) + 0.5) * dy\n    x_grid, y_grid = np.meshgrid(x, y, indexing='ij')\n\n    epsilon = 2.0 * dx\n\n    if interface_type == 'line':\n        phi = get_phi_line(x_grid, y_grid, 0, U=U, theta=theta, **kwargs)\n    else: # circ\n        phi = get_phi_circ(x_grid, y_grid, 0, **kwargs)\n\n    t = 0.0\n    if abs(U)  1e-12:\n        cfl = 0.4\n        dt_base = cfl * dx / abs(U)\n        \n        num_steps = int(np.floor(T / dt_base))\n        dt_last = T - num_steps * dt_base\n\n        dts = [dt_base] * num_steps\n        if dt_last  1e-12:\n            dts.append(dt_last)\n\n        for dt in dts:\n            phi_n = phi.copy()\n            if U  0:\n                phi_inflow = get_phi_line(0, y, t + dt, U=U, theta=theta, **kwargs)\n                phi[0, :] = phi_inflow\n                phi[1:, :] = phi_n[1:, :] - U * dt / dx * (phi_n[1:, :] - phi_n[:-1, :])\n            t += dt\n\n    phi_num = phi\n    \n    if interface_type == 'line':\n        phi_exact = get_phi_line(x_grid, y_grid, T, U=U, theta=theta, **kwargs)\n    else: # circ\n        phi_exact = get_phi_circ(x_grid, y_grid, T, **kwargs)\n        \n    e_phi = np.sqrt(np.mean((phi_num - phi_exact)**2))\n    \n    kappa, dphidx = compute_kappa_and_dphidx(phi_num, dx, dy, theta)\n    \n    phi_out = phi_num[-1, :]\n    kappa_out = kappa[-1, :]\n    dphidx_out = dphidx[-1, :]\n    \n    delta_out = delta_eps(phi_out, epsilon)\n    \n    integrand = sigma * kappa_out * delta_out * dphidx_out\n    f_cap = np.sum(integrand) * dy\n    \n    return e_phi, f_cap\n\ndef solve():\n    test_cases = [\n        # Case 1\n        {'Lx': 1.0, 'Ly': 0.5, 'Nx': 120, 'Ny': 60, 'U': 0.6, 'theta': np.pi/3, \n         'sigma': 0.072, 'T': 0.4, 'interface_type': 'line', \n         'xc': 0.25 * 1.0, 'yc': 0.5 * 0.5},\n        # Case 2\n        {'Lx': 0.6, 'Ly': 0.4, 'Nx': 80, 'Ny': 60, 'U': 0.0, 'theta': np.pi/2, \n         'sigma': 0.072, 'T': 0.01, 'interface_type': 'circ', \n         'x_ctr': 0.45, 'y_ctr': 0.20, 'R': 0.08},\n        # Case 3\n        {'Lx': 0.5, 'Ly': 0.3, 'Nx': 80, 'Ny': 48, 'U': 1.2, 'theta': np.pi/4, \n         'sigma': 0.072, 'T': 0.15, 'interface_type': 'line', \n         'xc': 0.20 * 0.5, 'yc': 0.5 * 0.3}\n    ]\n\n    results = []\n    for params in test_cases:\n        # Unpack kwargs not used by solve_case directly\n        kwargs_for_phi = {k: v for k, v in params.items() if k in ['xc', 'yc', 'x_ctr', 'y_ctr', 'R']}\n        \n        e_phi, f_cap = solve_case(\n            Lx=params['Lx'], Ly=params['Ly'], Nx=params['Nx'], Ny=params['Ny'],\n            U=params['U'], theta=params['theta'], sigma=params['sigma'], T=params['T'],\n            interface_type=params['interface_type'], **kwargs_for_phi\n        )\n        results.extend([e_phi, f_cap])\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3516353"}, {"introduction": "A significant challenge in simulating multiphase flows is the emergence of non-physical \"spurious currents\" near interfaces, which arise from the imperfect discretization of the surface tension force. Understanding, quantifying, and mitigating these numerical artifacts is essential for the development and validation of any multiphase solver. This practice guides you through a theoretical and computational analysis of spurious currents, where you will derive a scaling law for their magnitude based on fundamental fluid dynamics and numerical error models, and then apply it to compare different computational strategies [@problem_id:3516350].", "problem": "Consider a two-dimensional, incompressible, viscous, Newtonian, immiscible, two-phase system in which a circular droplet of radius $R$ is at rest at the center of a rectangular domain. The true physical solution has zero velocity everywhere and a hydrostatic pressure jump across the interface equal to the product of surface tension and curvature. In numerical multiphase methods, however, discretization of surface tension and curvature introduces a residual imbalance that drives non-physical flows known as spurious currents (also called parasitic currents). Your task is to quantify the peak magnitude of these spurious currents and its scaling with grid resolution and anisotropy by comparing the Continuum Surface Force (CSF) model and the Ghost Fluid Method (GFM) for two curvature estimators: the height-function estimator (HF) and the level-set estimator (LS).\n\nYou must reason from first principles of low-Reynolds-number flow and surface tension representations, using only the base laws and well-tested, method-order facts listed below, to derive a closed-form prediction for the peak spurious velocity. Then implement that prediction in a program that evaluates specific test cases and prints the results.\n\nFundamental base and accepted facts to use:\n- The incompressible Navier–Stokes equations for a Newtonian fluid in the steady, inertia-less (Stokes) limit reduce to $\\mu \\nabla^2 \\mathbf{u} = \\nabla p + \\mathbf{f}$ and $\\nabla \\cdot \\mathbf{u} = 0$, where $\\mu$ is dynamic viscosity, $\\mathbf{u}$ is velocity, $p$ is pressure, and $\\mathbf{f}$ is a volumetric force density.\n- The exact surface tension traction at an interface produces a pressure jump $[p] = \\sigma \\kappa$ across the interface, where $\\sigma$ is surface tension and $\\kappa$ is curvature.\n- In a CSF-like discretization, the surface tension is regularized into a volumetric force $\\mathbf{f}_{\\text{st}} \\approx \\sigma \\kappa \\nabla C$, where $C$ is an indicator field smeared over a thickness proportional to the grid spacing. A curvature error $\\delta \\kappa$ leaves a residual force density whose magnitude scales with the gradient magnitude of the indicator.\n- In a GFM-like sharp-jump discretization, the surface tension appears as a jump condition enforced at the interface; a curvature error $\\delta \\kappa$ yields a jump error $\\delta p = \\sigma \\delta \\kappa$ that drives a localized Stokes response near the interface.\n- The height-function curvature estimator (HF) is second-order accurate for smooth interfaces, while a standard level-set curvature estimator (LS) based on first-order accurate normals and central differences is effectively first-order accurate for curvature on general grids. Denote these orders by $q_{\\text{HF}} = 2$ and $q_{\\text{LS}} = 1$.\n- For an anisotropic Cartesian grid with spacings $\\Delta x$ and $\\Delta y$, an effective grid length for LS-based discretizations that blends anisotropy is $h_{\\text{eff,LS}} = \\sqrt{(\\Delta x^2 + \\Delta y^2)/2}$, while HF-type column reconstructions are limited by the coarser direction and hence $h_{\\text{eff,HF}} = \\max(\\Delta x, \\Delta y)$.\n- Curvature has units of inverse length. For a smooth circular interface, the truncation error in curvature may be modeled dimensionally as\n  $\\delta \\kappa_{\\text{geom}} \\sim C_k \\frac{1}{R} \\left( \\frac{h_{\\text{eff}}}{R} \\right)^q$,\n  where $C_k$ is a dimensionless method-dependent constant and $q$ is the order of accuracy of the curvature estimator.\n- Contact angle modeling at a solid wall introduces an additional curvature defect near the three-phase contact line that scales linearly with grid size and with the cosine of the equilibrium contact angle magnitude. Model this as\n  $\\delta \\kappa_{\\text{CA}} \\sim C_{\\text{CA}} \\frac{1}{R} \\left( \\frac{h_{\\text{wall}}}{R} \\right) \\left| \\cos \\theta_e \\right|$,\n  where $\\theta_e$ is the prescribed equilibrium contact angle, $h_{\\text{wall}}$ is the grid spacing normal to the wall, and $C_{\\text{CA}}$ is a dimensionless constant.\n\nObjectives:\n1. Starting from the steady Stokes momentum balance and the models above, derive a scaling expression for the peak spurious speed $U_{\\max}$ generated by a curvature error $\\delta \\kappa$ for both CSF and GFM. Your derivation must state how the characteristic length of the viscous response enters and must be dimensionally consistent. Express the result in meters per second.\n2. Incorporate grid anisotropy through the effective length $h_{\\text{eff}}$ for each curvature estimator. Use $h_{\\text{eff,HF}} = \\max(\\Delta x, \\Delta y)$ for HF and $h_{\\text{eff,LS}} = \\sqrt{(\\Delta x^2 + \\Delta y^2)/2}$ for LS.\n3. Use the following dimensionless constants for numerical evaluation: $C_{\\text{HF}} = 0.25$, $C_{\\text{LS}} = 0.05$, $C_{\\text{CSF}} = 1.0$, $C_{\\text{GFM}} = 0.25$, $C_{\\text{CA}} = 0.75$. Here $C_{\\text{HF}}$ and $C_{\\text{LS}}$ correspond to $C_k$ for HF and LS respectively, and $C_{\\text{CSF}}$, $C_{\\text{GFM}}$ are prefactors that model the relative strength of the near-interface viscous response for CSF and GFM.\n4. When a wall-contact case is specified, include the contact-angle curvature error contribution using $h_{\\text{wall}} = \\Delta x$ and the equilibrium contact angle $\\theta_e$ in degrees. Convert angles to radians when taking the cosine.\n\nParameters and units:\n- Radius $R$ in meters.\n- Surface tension $\\sigma$ in newtons per meter.\n- Viscosity $\\mu$ in pascal-seconds.\n- Grid spacings $\\Delta x$ and $\\Delta y$ in meters.\n- Equilibrium contact angle $\\theta_e$ in degrees when applicable.\n- Output velocity in meters per second.\n\nTest suite:\nUse $R = 1.0 \\times 10^{-3}$, $\\sigma = 0.072$, and $\\mu = 1.0 \\times 10^{-3}$. Evaluate the peak spurious speed for the five cases below. For each case, specify method (CSF or GFM), curvature estimator (HF or LS), $\\Delta x$, $\\Delta y$, and wall/contact angle if applicable.\n\n- Case 1 (happy path): CSF with HF on isotropic grid.\n  - $\\Delta x = \\Delta y = R/32$.\n  - No wall, no contact angle term.\n\n- Case 2 (method sensitivity): CSF with LS on isotropic grid.\n  - $\\Delta x = \\Delta y = R/32$.\n  - No wall, no contact angle term.\n\n- Case 3 (anisotropy effect): CSF with HF on anisotropic grid.\n  - $\\Delta x = R/64$, $\\Delta y = R/16$.\n  - No wall, no contact angle term.\n\n- Case 4 (model comparison under anisotropy): GFM with LS on anisotropic grid.\n  - $\\Delta x = R/64$, $\\Delta y = R/16$.\n  - No wall, no contact angle term.\n\n- Case 5 (contact angle at wall): GFM with HF on isotropic grid with a wall-contact curvature defect.\n  - $\\Delta x = \\Delta y = R/32$.\n  - Prescribed equilibrium contact angle $\\theta_e = 60$ degrees.\n\nRequired final output format:\n- Your program must compute the peak spurious speed $U_{\\max}$ for each case in meters per second and print a single line containing a comma-separated list of the five floating-point results enclosed in square brackets, for example, \"[v1,v2,v3,v4,v5]\".\n- Express each value to six significant figures.\n- The program must not read any input and must embed the test suite internally.", "solution": "The task is to derive a closed-form expression for the peak spurious velocity, $U_{\\max}$, in a numerical two-phase flow simulation and then use it to evaluate five specific test cases. The derivation will be based on the provided physical principles and scaling laws.\n\nWe begin with the governing equation for the fluid motion, which is the steady, inertia-less, incompressible Navier-Stokes (Stokes) equation:\n$$\n\\mu \\nabla^2 \\mathbf{u} = \\nabla p + \\mathbf{f}\n$$\nwhere $\\mu$ is the dynamic viscosity, $\\mathbf{u}$ is the velocity field, $p$ is the pressure, and $\\mathbf{f}$ is a volumetric body force. Spurious currents are non-physical flows generated by an imbalance between the discretized viscous, pressure, and surface tension terms.\n\nA dimensional analysis of the Stokes equation provides insight into the scaling of the velocity. Let $U$ be the characteristic velocity magnitude and $L$ be the characteristic length scale over which the flow varies. The viscous term scales as $\\mu |\\nabla^2 \\mathbf{u}| \\sim \\mu U/L^2$. This term must balance either a pressure gradient, $|\\nabla p| \\sim \\delta P/L$, or a body force, $|\\mathbf{f}| \\sim F$. This leads to two potential scalings for the velocity:\n1. Pressure-driven flow: $\\mu U/L^2 \\sim \\delta P/L \\implies U \\sim \\frac{\\delta P \\cdot L}{\\mu}$\n2. Force-driven flow: $\\mu U/L^2 \\sim F \\implies U \\sim \\frac{F \\cdot L^2}{\\mu}$\n\nThe spurious currents are driven by numerical errors that occur at the scale of the computational grid. Therefore, the characteristic length scale, $L$, of the resulting flow pattern is proportional to the effective grid spacing, $h_{\\text{eff}}$. We thus set $L \\sim h_{\\text{eff}}$.\n\nWe now analyze the two surface tension models provided: the Continuum Surface Force (CSF) model and the Ghost Fluid Method (GFM).\n\nFor the CSF model, surface tension is regularized as a volumetric force $\\mathbf{f}_{\\text{st}} \\approx \\sigma \\kappa \\nabla C$, where $C$ is an indicator function (e.g., volume fraction) smeared over the interface. An error in curvature, $\\delta \\kappa$, results in a residual force density, $\\delta \\mathbf{f}_{\\text{st}}$, with magnitude $F = |\\delta \\mathbf{f}_{\\text{st}}| \\sim \\sigma (\\delta \\kappa) |\\nabla C|$. The gradient of the indicator function, which transitions from $0$ to $1$ across a few grid cells, scales as $|\\nabla C| \\sim 1/h_{\\text{eff}}$. The residual force density is thus $F \\sim \\sigma (\\delta \\kappa)/h_{\\text{eff}}$. Using the force-driven velocity scaling, we find:\n$$\nU_{\\max} \\sim \\frac{F \\cdot L^2}{\\mu} \\sim \\frac{(\\sigma (\\delta \\kappa) / h_{\\text{eff}}) \\cdot h_{\\text{eff}}^2}{\\mu} = \\frac{\\sigma (\\delta \\kappa) h_{\\text{eff}}}{\\mu}\n$$\nIntroducing the given dimensionless prefactor $C_{\\text{CSF}}$ for this model, we get:\n$$\nU_{\\max, \\text{CSF}} = C_{\\text{CSF}} \\frac{\\sigma (\\delta \\kappa) h_{\\text{eff}}}{\\mu}\n$$\n\nFor the GFM, the surface tension is enforced as a sharp pressure jump across the interface. A curvature error $\\delta \\kappa$ leads to an error in this pressure jump, $\\delta P \\sim \\delta p = \\sigma \\delta \\kappa$. This pressure imbalance drives the flow. Using the pressure-driven velocity scaling with $L \\sim h_{\\text{eff}}$, we get:\n$$\nU_{\\max} \\sim \\frac{\\delta P \\cdot L}{\\mu} \\sim \\frac{(\\sigma \\delta \\kappa) \\cdot h_{\\text{eff}}}{\\mu}\n$$\nIntroducing the prefactor $C_{\\text{GFM}}$ for this model gives:\n$$\nU_{\\max, \\text{GFM}} = C_{\\text{GFM}} \\frac{\\sigma (\\delta \\kappa) h_{\\text{eff}}}{\\mu}\n$$\nBoth models yield a similar scaling structure. We can write a general expression:\n$$\nU_{\\max} = C_{\\text{method}} \\frac{\\sigma (\\delta \\kappa) h_{\\text{eff}}}{\\mu}\n$$\nwhere $C_{\\text{method}}$ is either $C_{\\text{CSF}}$ or $C_{\\text{GFM}}$.\n\nThe next step is to substitute the model for the total curvature error, $\\delta \\kappa$. The problem states that this error has contributions from geometric discretization and, if applicable, from contact angle treatment at a wall. We assume these contributions add:\n$$\n\\delta \\kappa = \\delta \\kappa_{\\text{geom}} + \\delta \\kappa_{\\text{CA}}\n$$\nThe explicit models provided are:\n$$\n\\delta \\kappa_{\\text{geom}} = C_k \\frac{1}{R} \\left( \\frac{h_{\\text{eff}}}{R} \\right)^q\n$$\n$$\n\\delta \\kappa_{\\text{CA}} = C_{\\text{CA}} \\frac{1}{R} \\left( \\frac{h_{\\text{wall}}}{R} \\right) \\left| \\cos \\theta_e \\right|\n$$\nwhere $C_k$ and $q$ depend on the chosen curvature estimator (HF or LS), $R$ is the droplet radius, $C_{\\text{CA}}$ is a constant for contact angle error, $h_{\\text{wall}}$ is the grid spacing normal to the wall, and $\\theta_e$ is the equilibrium contact angle.\n\nSubstituting the full expression for $\\delta \\kappa$ into our velocity scaling gives the final predictive formula for the peak spurious velocity:\n$$\nU_{\\max} = C_{\\text{method}} \\frac{\\sigma h_{\\text{eff}}}{\\mu} \\left[ C_k \\frac{1}{R} \\left( \\frac{h_{\\text{eff}}}{R} \\right)^q + C_{\\text{CA}} \\frac{1}{R} \\left( \\frac{h_{\\text{wall}}}{R} \\right) \\left| \\cos \\theta_e \\right| \\right]\n$$\nThis can be rearranged for clarity by factoring out $1/R$ and identifying the capillary velocity scale $V_{cap} = \\sigma/\\mu$:\n$$\nU_{\\max} = C_{\\text{method}} \\frac{\\sigma}{\\mu} \\frac{h_{\\text{eff}}}{R} \\left[ C_k \\left( \\frac{h_{\\text{eff}}}{R} \\right)^q + C_{\\text{CA}} \\left( \\frac{h_{\\text{wall}}}{R} \\right) \\left| \\cos \\theta_e \\right| \\right]\n$$\nThis formula incorporates the surface tension model ($C_{\\text{method}}$), the curvature estimator ($C_k, q, h_{\\text{eff}}$), grid anisotropy (via $h_{\\text{eff}}$), and contact angle effects. The contact angle term is set to zero for cases without a wall. This expression will be implemented to evaluate the specified test cases. The definitions for $h_{\\text{eff}}$ depend on the estimator: $h_{\\text{eff,HF}} = \\max(\\Delta x, \\Delta y)$ and $h_{\\text{eff,LS}} = \\sqrt{(\\Delta x^2 + \\Delta y^2)/2}$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and evaluates the peak spurious velocity for several test cases\n    in multiphase flow simulation.\n    \"\"\"\n    # Define physical parameters and dimensionless constants from the problem.\n    R = 1.0e-3  # meters\n    sigma = 0.072  # N/m\n    mu = 1.0e-3  # Pa.s\n\n    C_CSF = 1.0\n    C_GFM = 0.25\n    C_HF = 0.25\n    C_LS = 0.05\n    C_CA = 0.75\n\n    # Orders of accuracy for curvature estimators.\n    q_HF = 2\n    q_LS = 1\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'id': 1, 'method': 'CSF', 'estimator': 'HF', 'dx_div': 32, 'dy_div': 32, 'theta_e_deg': None},\n        {'id': 2, 'method': 'CSF', 'estimator': 'LS', 'dx_div': 32, 'dy_div': 32, 'theta_e_deg': None},\n        {'id': 3, 'method': 'CSF', 'estimator': 'HF', 'dx_div': 64, 'dy_div': 16, 'theta_e_deg': None},\n        {'id': 4, 'method': 'GFM', 'estimator': 'LS', 'dx_div': 64, 'dy_div': 16, 'theta_e_deg': None},\n        {'id': 5, 'method': 'GFM', 'estimator': 'HF', 'dx_div': 32, 'dy_div': 32, 'theta_e_deg': 60},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Determine case-specific parameters\n        if case['method'] == 'CSF':\n            C_method = C_CSF\n        else: # GFM\n            C_method = C_GFM\n\n        dx = R / case['dx_div']\n        dy = R / case['dy_div']\n\n        if case['estimator'] == 'HF':\n            C_k = C_HF\n            q = q_HF\n            h_eff = np.max([dx, dy])\n        else: # LS\n            C_k = C_LS\n            q = q_LS\n            h_eff = np.sqrt((dx**2 + dy**2) / 2)\n\n        # Calculate geometric error contribution\n        # U_max_geom = C_method * C_k * (sigma / mu) * (h_eff / R)**(q + 1)\n        geom_err_factor = C_k * (h_eff / R)**q\n\n        # Calculate contact angle error contribution\n        ca_err_factor = 0.0\n        if case['theta_e_deg'] is not None:\n            theta_e = np.radians(case['theta_e_deg'])\n            h_wall = dx\n            ca_err_factor = C_CA * (h_wall / R) * np.abs(np.cos(theta_e))\n        \n        # Combine terms using the derived formula:\n        # U_max = C_method * (sigma/mu) * (h_eff/R) * [geom_err_factor + ca_err_factor]\n        total_err_term = geom_err_factor + ca_err_factor\n        U_max = C_method * (sigma / mu) * (h_eff / R) * total_err_term\n\n        results.append(U_max)\n\n    # Format output to six significant figures and join into a single string.\n    formatted_results = [f'{val:.6g}' for val in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3516350"}]}