{"hands_on_practices": [{"introduction": "Understanding a new numerical technique often begins with applying it to a simple, well-understood problem. This first practice exercise [@problem_id:3525095] uses the one-dimensional Poisson equation to provide a clear, hands-on comparison between two common methods for enforcing constraints: the Lagrange multiplier approach, which leads to a saddle-point system, and the penalty method. By implementing both and comparing them against a known analytical solution, you will gain direct insight into the trade-offs regarding constraint satisfaction, accuracy, and formulation complexity.", "problem": "Consider the one-dimensional scalar Poisson problem on the interval $[0,1]$ with constant body force where the primary field $u(x)$ satisfies the strong form $-u''(x)=1$ for $x \\in (0,1)$, together with a zero-Neumann boundary condition at the right end $u'(1)=0$ and the boundary constraint at the left end $u(0)=0$. Treat $u(0)=0$ as a constraint to be enforced either by a Lagrange multiplier (saddle-point formulation) or by a penalty term. Starting from the standard variational statement for $-u''=1$ with a natural (Neumann) boundary at $x=1$, formulate the constrained weak problem with the Lagrange multiplier using the Principle of Virtual Work and, separately, the penalized weak problem by adding a quadratic penalty term for the constraint. Then discretize both formulations using uniform linear finite elements on $[0,1]$ with $N$ elements and mesh size $h=1/N$, and implement the following:\n\n- For the multiplier approach, introduce an additional scalar unknown (the multiplier) to enforce $u(0)=0$ in the weak sense, producing a saddle-point linear system coupling the finite element stiffness with the constraint.\n- For the penalty approach, add a symmetric penalty bilinear form proportional to a scalar penalty parameter $\\gamma$ that weakly enforces $u(0) \\approx 0$.\n\nUse the exact analytical solution consistent with the strong form and the constraint, selected within the same physics and mathematics, as a reference to quantify numerical error. Compute, for each approach and each test case, the following metrics:\n- The $L^2$ error norm $\\left(\\int_{0}^{1}\\left(u_{\\text{exact}}(x)-u_h(x)\\right)^2\\,dx\\right)^{1/2}$.\n- The $H^1$ seminorm of the error $\\left(\\int_{0}^{1}\\left(u'_{\\text{exact}}(x)-u'_h(x)\\right)^2\\,dx\\right)^{1/2}$.\n- The constraint residual at the boundary $\\left|u_h(0)\\right|$.\n\nYour implementation must use Gaussian quadrature with sufficient order to exactly integrate the polynomials that arise in these norms for linear elements in one dimension. All integrations must be performed over $x \\in [0,1]$.\n\nBase your derivation on:\n- The strong form $-u''(x)=1$ for $x \\in (0,1)$ with $u'(1)=0$ and the equality constraint $u(0)=0$.\n- The corresponding unconstrained weak form $\\int_{0}^{1}u'(x)v'(x)\\,dx=\\int_{0}^{1}1\\cdot v(x)\\,dx$ for all admissible $v(x)$, before adding the constraint.\n\nDefine the discrete formulations precisely and then implement them. Assume a uniform mesh and linear basis functions. The exact solution to compare against must be derived from the strong form and the boundary conditions specified. The test suite is defined by the set of parameter pairs $(N,\\gamma)$ with $N$ the number of elements and $\\gamma$ the penalty parameter:\n- $(N,\\gamma)=(4,10)$ as a general case,\n- $(N,\\gamma)=(16,10)$ to probe mesh refinement at small $\\gamma$,\n- $(N,\\gamma)=(16,1000)$ to probe increased $\\gamma$ at fixed $h$,\n- $(N,\\gamma)=(64,1000)$ as a refined mesh at moderate $\\gamma$,\n- $(N,\\gamma)=(64,10^6)$ to probe very large $\\gamma$,\n- $(N,\\gamma)=(2,1000)$ as a coarse mesh edge case.\n\nFor each test case, compute the three metrics for the penalty approach and for the multiplier approach (the multiplier approach does not depend on $\\gamma$, but must be evaluated at the same $N$ for comparability). Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list of six floating-point numbers ordered as $[E_{L^2}^{\\text{pen}},E_{H^1}^{\\text{pen}},r^{\\text{pen}},E_{L^2}^{\\text{mult}},E_{H^1}^{\\text{mult}},r^{\\text{mult}}]$ with $E_{L^2}$ the $L^2$ error norm, $E_{H^1}$ the $H^1$ seminorm of error, and $r$ the constraint residual $\\left|u_h(0)\\right|$.\n\nAll mathematical symbols, variables, functions, operators, and numbers must be written in LaTeX enclosed in dollar signs, including $u$, $v$, $x$, $N$, $h$, $\\gamma$, $1$, $0$, and all integrals and norms. No physical units are involved in this problem; angles and percentages are not used. The output must be in the format described above, and all answers for the test cases must be floating-point numbers.", "solution": "The problem requires the solution of a one-dimensional Poisson equation, $-u''(x) = 1$ on the interval $x \\in (0,1)$, with boundary conditions $u'(1)=0$ and $u(0)=0$. The condition $u(0)=0$ is to be treated as a constraint enforced by two different methods: a penalty method and a Lagrange multiplier method. The solutions are to be obtained using the finite element method with linear basis functions.\n\n### 1. Analytical Solution\nFirst, we establish the exact analytical solution to serve as a benchmark for numerical error analysis. The strong form of the differential equation is:\n$$ -u''(x) = 1 $$\nIntegrating with respect to $x$ yields:\n$$ -u'(x) = x + C_1 $$\nThe Neumann boundary condition $u'(1)=0$ is applied to determine the constant $C_1$:\n$$ -u'(1) = 1 + C_1 = 0 \\implies C_1 = -1 $$\nThus, the derivative of the solution is:\n$$ u'(x) = 1 - x $$\nIntegrating a second time gives the general solution for $u(x)$:\n$$ u(x) = x - \\frac{1}{2}x^2 + C_2 $$\nThe constraint $u(0)=0$ is used to find $C_2$:\n$$ u(0) = 0 - 0 + C_2 = 0 \\implies C_2 = 0 $$\nTherefore, the exact solution is:\n$$ u_{\\text{exact}}(x) = x - \\frac{1}{2}x^2 $$\nAnd its derivative is $u'_{\\text{exact}}(x) = 1 - x$.\n\n### 2. Variational Formulations\nWe start from the given unconstrained weak form, which corresponds to the bilinear form $a(u,v) = \\int_{0}^{1} u'(x)v'(x) \\,dx$ and the linear functional $L(v) = \\int_{0}^{1} 1 \\cdot v(x) \\,dx$. The problem is to find a function $u(x)$ in an appropriate space $V$ (here $H^1(0,1)$) satisfying the variational equation and the constraint $u(0)=0$.\n\n#### 2.1. Penalty Method Formulation\nIn the penalty method, the constraint $u(0)=0$ is enforced weakly by adding a penalty term to the total potential energy functional. The modified functional to be minimized is:\n$$ J(u) = \\frac{1}{2} a(u,u) - L(u) + \\frac{1}{2}\\gamma (u(0))^2 $$\nwhere $\\gamma > 0$ is a large penalty parameter. The solution $u_\\gamma$ is found by requiring the first variation of $J(u)$ with respect to an arbitrary test function $v \\in V$ to be zero. This yields the penalized weak formulation:\nFind $u_\\gamma \\in V$ such that for all $v \\in V$:\n$$ a(u_\\gamma, v) + \\gamma u_\\gamma(0)v(0) = L(v) $$\nSubstituting the definitions for $a(\\cdot,\\cdot)$ and $L(\\cdot)$:\n$$ \\int_{0}^{1} u_\\gamma'(x)v'(x) \\,dx + \\gamma u_\\gamma(0)v(0) = \\int_{0}^{1} v(x) \\,dx $$\n\n#### 2.2. Lagrange Multiplier Formulation\nThis method introduces a Lagrange multiplier, $\\lambda$, to enforce the constraint exactly. We seek a pair $(u, \\lambda) \\in V \\times \\mathbb{R}$. The augmented functional (Lagrangian) is:\n$$ \\mathcal{L}(u, \\lambda) = \\frac{1}{2} a(u,u) - L(u) + \\lambda u(0) $$\nThe solution is a stationary point of $\\mathcal{L}$. Taking variations with respect to $u$ (in direction $v$) and $\\lambda$ (in direction $\\mu$) and setting them to zero gives the following system of equations:\n1.  $\\delta_u \\mathcal{L}(v) = a(u,v) - L(v) + \\lambda v(0) = 0$ for all $v \\in V$.\n2.  $\\delta_\\lambda \\mathcal{L}(\\mu) = \\mu u(0) = 0$ for all $\\mu \\in \\mathbb{R}$, which implies $u(0)=0$.\n\nThis leads to the saddle-point weak formulation: Find $(u, \\lambda) \\in V \\times \\mathbb{R}$ such that:\n$$ \\int_{0}^{1} u'(x)v'(x) \\,dx + \\lambda v(0) = \\int_{0}^{1} v(x) \\,dx \\quad \\forall v \\in V $$\n$$ u(0) = 0 $$\nPhysically, the multiplier $\\lambda$ can be identified with the reaction flux needed to enforce the constraint. Comparing with the boundary terms from integration by parts, $\\lambda = -u'(0)$. For the exact solution, $\\lambda = -(1-0) = -1$.\n\n### 3. Finite Element Discretization\nWe discretize the interval $[0,1]$ into $N$ uniform elements of length $h=1/N$. The nodes are located at $x_i = i h$ for $i=0, 1, \\dots, N$. We use linear basis functions (hat functions) $\\phi_i(x)$ where $\\phi_i(x_j) = \\delta_{ij}$. The finite element solution is approximated as $u_h(x) = \\sum_{j=0}^{N} u_j \\phi_j(x)$, where $\\mathbf{u} = (u_0, u_1, \\dots, u_N)^T$ is the vector of nodal unknown values.\n\nThe standard stiffness matrix $K$ and force vector $F$ are assembled with entries:\n$$ K_{ij} = a(\\phi_j, \\phi_i) = \\int_0^1 \\phi_j'(x) \\phi_i'(x) \\,dx $$\n$$ F_i = L(\\phi_i) = \\int_0^1 \\phi_i(x) \\,dx $$\nFor a uniform mesh with linear elements, this results in the $(N+1) \\times (N+1)$ symmetric tridiagonal stiffness matrix $K$ and load vector $F$:\n$$ K = \\frac{1}{h} \\begin{pmatrix} 1 & -1 & & \\\\ -1 & 2 & -1 & \\\\ & \\ddots & \\ddots & \\ddots \\\\ & & -1 & 2 & -1 \\\\ & & & -1 & 1 \\end{pmatrix}, \\quad F = h \\begin{pmatrix} 1/2 \\\\ 1 \\\\ \\vdots \\\\ 1 \\\\ 1/2 \\end{pmatrix} $$\n\n#### 3.1. Discrete Penalty System\nDiscretizing the penalty weak form by setting $u_h = \\sum_j u_j \\phi_j$ and $v = \\phi_i$ gives:\n$$ \\sum_{j=0}^{N} u_j K_{ij} + \\gamma \\left(\\sum_{j=0}^{N} u_j \\phi_j(0)\\right) \\phi_i(0) = F_i \\quad \\text{for } i=0, \\dots, N $$\nSince $\\phi_j(0) = \\delta_{j0}$ and $u_h(0) = u_0$, this simplifies. The penalty term only affects the first equation ($i=0$), adding $\\gamma u_0$ to the left-hand side. This is equivalent to adding $\\gamma$ to the $(0,0)$ entry of the stiffness matrix. The resulting linear system is:\n$$ (K + K_p) \\mathbf{u} = F \\quad \\text{where} \\quad K_p = \\begin{pmatrix} \\gamma & 0 & \\dots \\\\ 0 & 0 & \\dots \\\\ \\vdots & \\vdots & \\ddots \\end{pmatrix} $$\n\n#### 3.2. Discrete Lagrange Multiplier System\nDiscretizing the saddle-point formulation yields a larger, block-structured linear system for the unknowns $(\\mathbf{u}, \\lambda)$. The equations become:\n$$ \\sum_{j=0}^{N} u_j K_{ij} + \\lambda \\phi_i(0) = F_i \\quad \\text{for } i=0, \\dots, N $$\n$$ u_0 = 0 $$\nLet $B$ be the constraint vector such that $B_i = \\phi_i(0) = \\delta_{i0}$. The discrete system can be written in block matrix form:\n$$ \\begin{pmatrix} K & B \\\\ B^T & 0 \\end{pmatrix} \\begin{pmatrix} \\mathbf{u} \\\\ \\lambda \\end{pmatrix} = \\begin{pmatrix} F \\\\ 0 \\end{pmatrix} $$\nThis is an $(N+2) \\times (N+2)$ symmetric indefinite system.\n\n### 4. Error Metrics\nThe numerical solutions are compared to the exact solution using three metrics:\n1.  **$L^2$ error norm:** $E_{L^2} = \\left(\\int_{0}^{1}\\left(u_{\\text{exact}}(x)-u_h(x)\\right)^2\\,dx\\right)^{1/2}$\n2.  **$H^1$ seminorm of the error:** $E_{H^1} = \\left(\\int_{0}^{1}\\left(u'_{\\text{exact}}(x)-u'_h(x)\\right)^2\\,dx\\right)^{1/2}$\n3.  **Constraint residual:** $r = \\left|u_h(0)\\right| = |u_0|$\n\nThe integrals for the error norms are computed numerically using Gaussian quadrature. On each element, $u_h(x)$ is linear and $u_h'(x)$ is constant, while $u_{\\text{exact}}(x)$ is quadratic and $u'_{\\text{exact}}(x)$ is linear. Therefore, the integrand for the $L^2$ error is a polynomial of degree $4$, requiring a $3$-point Gauss rule for exact integration. The integrand for the $H^1$ seminorm of the error is a polynomial of degree $2$, requiring a $2$-point Gauss rule. For simplicity and consistency, a $3$-point rule is sufficient for both. The integration over $[0,1]$ is performed by summing the contributions from each element, applying the quadrature rule on a reference element and mapping to the physical element coordinates.", "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Solves the 1D Poisson problem with two different constraint enforcement methods\n    and computes error metrics against the exact solution.\n    \"\"\"\n\n    test_cases = [\n        (4, 10.0),\n        (16, 10.0),\n        (16, 1000.0),\n        (64, 1000.0),\n        (64, 1.0e6),\n        (2, 1000.0),\n    ]\n\n    all_results = []\n\n    for N, gamma in test_cases:\n        h = 1.0 / N\n        num_nodes = N + 1\n\n        # Assemble stiffness matrix K and force vector F\n        K = np.zeros((num_nodes, num_nodes))\n        F = np.zeros(num_nodes)\n\n        # Diagonals\n        K.flat[::num_nodes+1] = 2.0 / h\n        K[0, 0] = 1.0 / h\n        K[N, N] = 1.0 / h\n        # Off-diagonals\n        off_diag = -1.0 / h\n        K.flat[1::num_nodes+1] = off_diag\n        K.flat[num_nodes::num_nodes+1] = off_diag\n\n        # Force vector\n        F[:] = h\n        F[0] = h / 2.0\n        F[N] = h / 2.0\n\n        # --- Penalty Method ---\n        K_pen = np.copy(K)\n        K_pen[0, 0] += gamma\n        u_pen = linalg.solve(K_pen, F)\n        \n        l2_pen, h1_pen = calculate_error_norms(u_pen, N)\n        r_pen = np.abs(u_pen[0])\n\n        # --- Lagrange Multiplier Method ---\n        # Form the saddle-point system matrix A_mult\n        A_mult = np.zeros((num_nodes + 1, num_nodes + 1))\n        A_mult[:num_nodes, :num_nodes] = K\n        B = np.zeros(num_nodes)\n        B[0] = 1.0\n        A_mult[:num_nodes, num_nodes] = B\n        A_mult[num_nodes, :num_nodes] = B.T\n\n        # Form the right-hand side vector\n        rhs_mult = np.zeros(num_nodes + 1)\n        rhs_mult[:num_nodes] = F\n\n        # Solve the system\n        sol_mult = linalg.solve(A_mult, rhs_mult)\n        u_mult = sol_mult[:num_nodes]\n        # _lambda = sol_mult[num_nodes] # The multiplier is not used further\n        \n        l2_mult, h1_mult = calculate_error_norms(u_mult, N)\n        r_mult = np.abs(u_mult[0])\n\n        case_results = [l2_pen, h1_pen, r_pen, l2_mult, h1_mult, r_mult]\n        all_results.append(case_results)\n\n    # Format output string\n    # Replace Python's default representation to remove spaces for cleaner output\n    output_str = str(all_results).replace(\" \", \"\")\n    print(output_str)\n\n\ndef calculate_error_norms(u_h_coeffs, N):\n    \"\"\"\n    Computes L2 and H1 error norms using Gaussian quadrature.\n    \"\"\"\n    h = 1.0 / N\n    \n    # 3-point Gauss quadrature on [-1, 1]\n    z_pts = [-np.sqrt(3.0/5.0), 0.0, np.sqrt(3.0/5.0)]\n    w_pts = [5.0/9.0, 8.0/9.0, 5.0/9.0]\n    \n    l2_err_sq = 0.0\n    h1_err_sq = 0.0\n\n    # Exact solution and its derivative\n    u_exact_func = lambda x: x - 0.5 * x**2\n    u_exact_prime_func = lambda x: 1.0 - x\n\n    for e in range(N):\n        # Nodal coordinates and values for element e\n        x_e = e * h\n        u_e = u_h_coeffs[e]\n        u_e1 = u_h_coeffs[e+1]\n        \n        # Derivative of FE solution on element e (constant)\n        u_h_prime_val = (u_e1 - u_e) / h\n\n        # Loop over Gauss points\n        for z_k, w_k in zip(z_pts, w_pts):\n            # Map reference point to physical coordinate\n            x_q = x_e + h * (z_k + 1.0) / 2.0\n            \n            # Evaluate exact solution and its derivative\n            u_exact_val = u_exact_func(x_q)\n            u_exact_prime_val = u_exact_prime_func(x_q)\n            \n            # Evaluate FE solution at x_q\n            # Local coordinate xi is (z_k+1)/2\n            xi_q = (z_k + 1.0) / 2.0\n            u_h_val = u_e * (1.0 - xi_q) + u_e1 * xi_q\n            \n            # Accumulate squared errors\n            l2_err_sq += w_k * (u_exact_val - u_h_val)**2\n            h1_err_sq += w_k * (u_exact_prime_val - u_h_prime_val)**2\n    \n    # Apply Jacobian determinant and take square root\n    # The Jacobian factor is h/2\n    l2_err = np.sqrt(l2_err_sq * h / 2.0)\n    h1_err = np.sqrt(h1_err_sq * h / 2.0)\n    \n    return l2_err, h1_err\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3525095"}, {"introduction": "A correctly formulated saddle-point system is not guaranteed to produce a physically meaningful solution; the discrete spaces for the primary variable and the multiplier must be compatible. This compatibility is governed by the celebrated inf-sup (or LBB) stability condition. In this exercise [@problem_id:3525102], you will move from implementation to a foundational theoretical analysis by constructing an explicit spurious pressure mode for an unstable discretization of the Stokes equations. This hands-on theoretical work reveals precisely why certain popular element choices fail, providing deep insight into the stability requirements of mixed formulations.", "problem": "Consider the stationary incompressible Stokes equations on the unit square domain $\\Omega = [0,1]^{2}$, with homogeneous Dirichlet boundary conditions for the velocity. Let the weak formulation be given by the saddle-point system: find velocity $u \\in V$ and pressure $p \\in Q$ such that\n$$\na(u,v) + b(v,p) = f(v) \\quad \\text{for all } v \\in V, \\qquad b(u,q) = 0 \\quad \\text{for all } q \\in Q,\n$$\nwhere $V$ is the Sobolev space of square-integrable vector fields with square-integrable gradients and vanishing trace on $\\partial \\Omega$, $Q$ is the space of square-integrable functions with zero mean over $\\Omega$, $a(u,v) = \\int_{\\Omega} 2\\mu \\, \\epsilon(u) : \\epsilon(v) \\, dx$ with $\\epsilon(u)$ the symmetric gradient, and $b(v,p) = -\\int_{\\Omega} p \\, \\nabla \\cdot v \\, dx$. In the Finite Element Method (FEM), consider the equal-order discrete spaces\n$$\nV_{h} = \\{ v_{h} \\in V : v_{h} \\text{ is continuous and piecewise linear ($P_{1}$) on a triangulation of } \\Omega \\}^{2},\n$$\n$$\nQ_{h} = \\{ q_{h} \\in Q : q_{h} \\text{ is continuous and piecewise linear ($P_{1}$) on the same triangulation} \\}.\n$$\n\nUse the following conforming triangulation $\\mathcal{T}_{h}$ of $\\Omega$: the vertex set consists of the four corners $(0,0)$, $(1,0)$, $(1,1)$, $(0,1)$ and the interior point $C = (1/2,1/2)$. The mesh is made of four triangles sharing the interior vertex $C$:\n- $T_{1}$ with vertices $C$, $(0,0)$, $(1,0)$,\n- $T_{2}$ with vertices $C$, $(1,0)$, $(1,1)$,\n- $T_{3}$ with vertices $C$, $(1,1)$, $(0,1)$,\n- $T_{4}$ with vertices $C$, $(0,1)$, $(0,0)$.\n\nAssume the discrete velocity space $V_{h}$ enforces homogeneous Dirichlet boundary conditions strongly, so only the interior node $C$ carries velocity degrees of freedom. Let $\\{N_{i}\\}$ denote the scalar $P_{1}$ nodal shape functions associated with the nodes $i \\in \\{(0,0), (1,0), (1,1), (0,1), C\\}$, and let velocity basis functions be $\\phi_{C}^{x} = (N_{C}, 0)$ and $\\phi_{C}^{y} = (0, N_{C})$. The discrete coupling bilinear form is\n$$\nb(v_{h},q_{h}) = -\\int_{\\Omega} q_{h} \\, \\nabla \\cdot v_{h} \\, dx.\n$$\n\nStarting from the above fundamental definitions and properties of piecewise linear functions on triangles, construct an explicit nonzero $q_{h} \\in Q_{h}$ whose nodal values $\\{p_{(0,0)}, p_{(1,0)}, p_{(1,1)}, p_{(0,1)}, p_{C}\\}$ satisfy\n$$\nb(v_{h}, q_{h}) = 0 \\quad \\text{for all } v_{h} \\in V_{h}.\n$$\n\nYour task:\n- Derive the necessary and sufficient conditions on $\\{p_{(0,0)}, p_{(1,0)}, p_{(1,1)}, p_{(0,1)}, p_{C}\\}$ implied by the structure of $\\mathcal{T}_{h}$ for $b(v_{h}, q_{h})$ to vanish for all $v_{h} \\in V_{h}$.\n- Use these conditions to construct a concrete nonzero spurious pressure mode $q_{h}$ represented by its nodal values.\n- Provide the final answer as the row vector of nodal values\n$$\n\\left(p_{(0,0)} \\ \\ p_{(1,0)} \\ \\ p_{(1,1)} \\ \\ p_{(0,1)} \\ \\ p_{C}\\right),\n$$\nin exact form. No rounding is required, and no physical units are involved.", "solution": "The objective is to find a nonzero discrete pressure field $q_{h} \\in Q_{h}$ such that it is orthogonal to the image of the discrete divergence operator, i.e., $b(v_{h}, q_{h}) = 0$ for all discrete velocity fields $v_{h} \\in V_{h}$. A pressure field $q_h$ with this property is known as a spurious pressure mode, and its existence indicates the instability of the chosen velocity-pressure finite element pair ($P_1-P_1$ in this case).\n\nThe condition to be satisfied is:\n$$b(v_{h}, q_{h}) = -\\int_{\\Omega} q_{h} \\, \\nabla \\cdot v_{h} \\, dx = 0 \\quad \\text{for all } v_{h} \\in V_{h}.$$\nSince this must hold for any $v_{h} \\in V_{h}$, it must hold for the basis functions that span $V_{h}$. From the problem description, the homogeneous Dirichlet boundary conditions are enforced strongly. The only node with non-zero velocity degrees of freedom is the interior node $C = (1/2, 1/2)$. Thus, the discrete velocity space $V_{h}$ is a $2$-dimensional space spanned by the basis functions $\\phi_{C}^{x} = (N_{C}, 0)$ and $\\phi_{C}^{y} = (0, N_{C})$, where $N_{C}$ is the continuous, piecewise linear nodal basis function associated with node $C$.\n\nThe pressure field $q_{h}$ is an element of $Q_{h}$ and can be expressed as a linear combination of the nodal basis functions $\\{N_i\\}$ for all five nodes: the corners $V_{(0,0)}=(0,0)$, $V_{(1,0)}=(1,0)$, $V_{(1,1)}=(1,1)$, $V_{(0,1)}=(0,1)$, and the center $C$. Let the nodal values of $q_{h}$ be $\\{p_{(0,0)}, p_{(1,0)}, p_{(1,1)}, p_{(0,1)}, p_{C}\\}$. Then,\n$$q_{h}(x,y) = p_{(0,0)}N_{(0,0)}(x,y) + p_{(1,0)}N_{(1,0)}(x,y) + p_{(1,1)}N_{(1,1)}(x,y) + p_{(0,1)}N_{(0,1)}(x,y) + p_{C}N_{C}(x,y).$$\n\nThe condition $b(v_{h}, q_{h}) = 0$ for all $v_h \\in V_h$ reduces to two scalar equations:\n$1.$ $b(\\phi_{C}^{x}, q_{h}) = -\\int_{\\Omega} q_{h} \\nabla \\cdot \\phi_{C}^{x} \\, dx = -\\int_{\\Omega} q_{h} \\frac{\\partial N_{C}}{\\partial x} \\, dx = 0$.\n$2.$ $b(\\phi_{C}^{y}, q_{h}) = -\\int_{\\Omega} q_{h} \\nabla \\cdot \\phi_{C}^{y} \\, dx = -\\int_{\\Omega} q_{h} \\frac{\\partial N_{C}}{\\partial y} \\, dx = 0$.\n\nLet's analyze the gradient of the basis function $N_C$. On each triangle $T_k$, $N_C$ is a linear function, so its gradient is a constant vector. The basis function $N_C$ has value $1$ at node $C$ and $0$ at all other nodes. The gradients on the four triangles are:\n- On $T_{1}$ (vertices $C, (0,0), (1,0)$): $\\nabla N_{C}|_{T_1} = (0, 2)$.\n- On $T_{2}$ (vertices $C, (1,0), (1,1)$): $\\nabla N_{C}|_{T_2} = (-2, 0)$.\n- On $T_{3}$ (vertices $C, (1,1), (0,1)$): $\\nabla N_{C}|_{T_3} = (0, -2)$.\n- On $T_{4}$ (vertices $C, (0,1), (0,0)$): $\\nabla N_{C}|_{T_4} = (2, 0)$.\n\nThus, $\\frac{\\partial N_C}{\\partial x}$ is non-zero only on $T_2$ and $T_4$, and $\\frac{\\partial N_C}{\\partial y}$ is non-zero only on $T_1$ and $T_3$.\n\nNow we evaluate the first equation:\n$$-\\int_{\\Omega} q_{h} \\frac{\\partial N_{C}}{\\partial x} \\, dx = -\\left( \\int_{T_2} q_{h} (-2) \\, dx + \\int_{T_4} q_{h} (2) \\, dx \\right) = 0.$$\nThis simplifies to $\\int_{T_2} q_{h} \\, dx = \\int_{T_4} q_{h} \\, dx$.\nThe integral of a linear function over a triangle is its area multiplied by the average of its nodal values at the vertices. The area of each triangle is $\\frac{1}{4}$.\nThe vertices of $T_2$ are $C, (1,0), (1,1)$. So, $\\int_{T_2} q_{h} dx = \\frac{\\text{Area}(T_2)}{3}(p_C + p_{(1,0)} + p_{(1,1)}) = \\frac{1}{12}(p_C + p_{(1,0)} + p_{(1,1)})$.\nThe vertices of $T_4$ are $C, (0,1), (0,0)$. So, $\\int_{T_4} q_{h} dx = \\frac{\\text{Area}(T_4)}{3}(p_C + p_{(0,1)} + p_{(0,0)}) = \\frac{1}{12}(p_C + p_{(0,1)} + p_{(0,0)})$.\nEquating these gives $p_C + p_{(1,0)} + p_{(1,1)} = p_C + p_{(0,1)} + p_{(0,0)}$, which yields our first condition on the nodal pressures:\n$$(1) \\quad p_{(0,0)} - p_{(1,0)} - p_{(1,1)} + p_{(0,1)} = 0.$$\n\nNext, we evaluate the second equation:\n$$-\\int_{\\Omega} q_{h} \\frac{\\partial N_{C}}{\\partial y} \\, dx = -\\left( \\int_{T_1} q_{h} (2) \\, dx + \\int_{T_3} q_{h} (-2) \\, dx \\right) = 0.$$\nThis simplifies to $\\int_{T_1} q_{h} \\, dx = \\int_{T_3} q_{h} \\, dx$.\nThe vertices of $T_1$ are $C, (0,0), (1,0)$. So, $\\int_{T_1} q_h dx = \\frac{1}{12}(p_C + p_{(0,0)} + p_{(1,0)})$.\nThe vertices of $T_3$ are $C, (1,1), (0,1)$. So, $\\int_{T_3} q_h dx = \\frac{1}{12}(p_C + p_{(1,1)} + p_{(0,1)})$.\nEquating these gives $p_C + p_{(0,0)} + p_{(1,0)} = p_C + p_{(1,1)} + p_{(0,1)}$, which yields our second condition:\n$$(2) \\quad p_{(0,0)} + p_{(1,0)} - p_{(1,1)} - p_{(0,1)} = 0.$$\n\nFinally, the space $Q_h$ is a subspace of $L^2_0(\\Omega)$, meaning the pressure field must have a zero mean over $\\Omega$:\n$$\\int_{\\Omega} q_{h} \\, dx = \\sum_{k=1}^4 \\int_{T_k} q_h \\, dx = 0.$$\nSumming the integrals over the four triangles:\n$$\\frac{1}{12} \\left[ (p_C+p_{(0,0)}+p_{(1,0)}) + (p_C+p_{(1,0)}+p_{(1,1)}) + (p_C+p_{(1,1)}+p_{(0,1)}) + (p_C+p_{(0,1)}+p_{(0,0)}) \\right] = 0.$$\nThis simplifies to $\\frac{1}{12} (4p_C + 2p_{(0,0)} + 2p_{(1,0)} + 2p_{(1,1)} + 2p_{(0,1)}) = 0$.\nSo, the third condition is:\n$$(3) \\quad p_{(0,0)} + p_{(1,0)} + p_{(1,1)} + p_{(0,1)} + 2p_C = 0.$$\n\nWe have a system of three linear equations for five unknowns. Let's find the relations between them.\nAdding equations $(1)$ and $(2)$:\n$(p_{(0,0)} - p_{(1,0)} - p_{(1,1)} + p_{(0,1)}) + (p_{(0,0)} + p_{(1,0)} - p_{(1,1)} - p_{(0,1)}) = 0 \\implies 2p_{(0,0)} - 2p_{(1,1)} = 0 \\implies p_{(1,1)} = p_{(0,0)}$.\nSubtracting equation $(1)$ from $(2)$:\n$(p_{(0,0)} + p_{(1,0)} - p_{(1,1)} - p_{(0,1)}) - (p_{(0,0)} - p_{(1,0)} - p_{(1,1)} + p_{(0,1)}) = 0 \\implies 2p_{(1,0)} - 2p_{(0,1)} = 0 \\implies p_{(0,1)} = p_{(1,0)}$.\nThese are necessary conditions: the nodal pressures at diagonally opposite corners must be equal.\n\nSubstituting these into equation (3):\n$p_{(0,0)} + p_{(1,0)} + p_{(0,0)} + p_{(1,0)} + 2p_C = 0 \\implies 2p_{(0,0)} + 2p_{(1,0)} + 2p_C = 0$.\nThis gives the final condition: $p_C = -p_{(0,0)} - p_{(1,0)}$.\n\nThe necessary and sufficient conditions on the nodal values for $q_h$ to be a spurious pressure mode are:\n- $p_{(1,1)} = p_{(0,0)}$\n- $p_{(0,1)} = p_{(1,0)}$\n- $p_C = -(p_{(0,0)} + p_{(1,0)})$\n\nThis defines a two-dimensional space of spurious modes. Any choice of $p_{(0,0)}$ and $p_{(1,0)}$ (not both zero) will generate a valid nonzero mode. A canonical choice for illustrating this phenomenon is the \"checkerboard\" mode. Let's set $p_{(0,0)} = 1$ and $p_{(1,0)} = -1$.\nUsing the derived conditions:\n- $p_{(1,1)} = p_{(0,0)} = 1$.\n- $p_{(0,1)} = p_{(1,0)} = -1$.\n- $p_C = -(1 + (-1)) = 0$.\n\nThis gives the nodal pressure vector $(p_{(0,0)}, p_{(1,0)}, p_{(1,1)}, p_{(0,1)}, p_C) = (1, -1, 1, -1, 0)$. This is a concrete, nonzero spurious pressure mode.\nThe final answer is the row vector of these nodal values in the specified order.", "answer": "$$\\boxed{\\begin{pmatrix} 1 & -1 & 1 & -1 & 0 \\end{pmatrix}}$$", "id": "3525102"}, {"introduction": "Saddle-point formulations are particularly powerful for enforcing divergence-free constraints on vector fields, a common requirement in fluid dynamics and electromagnetism. This practice [@problem_id:3525101] extends our scope to magnetostatics, where you will implement a system to enforce the physical law $\\nabla \\cdot B = 0$ on a simple 3D mesh. You will also employ the Schur complement method to solve the resulting algebraic system, a standard and efficient technique for decoupling the unknowns in saddle-point problems and a key tool in large-scale simulations.", "problem": "Consider the magnetostatic subset of Maxwellâ€™s equations in a heterogeneous medium, where the magnetic flux density $B$ and the magnetic field $H$ satisfy $B=\\mu H$ with $\\mu>0$ and the divergence-free constraint $\\nabla\\cdot B=0$ (no magnetic monopoles). A mixed formulation introduces a Lagrange multiplier to enforce $\\nabla\\cdot(\\mu H)=0$, yielding a saddle-point system. Your task is to construct a discrete finite-volume saddle-point system on a simple tetrahedral mesh, assemble its matrices, and solve a small example that illustrates the enforcement of $\\nabla\\cdot(\\mu H)=0$ by the multiplier.\n\nStart from the following fundamental base:\n- Magnetostatics: $\\nabla\\times H=J$, $B=\\mu H$, $\\nabla\\cdot B=0$.\n- The divergence-free constraint $\\nabla\\cdot B=0$ is enforced via a Lagrange multiplier $p$ in a mixed variational form.\n- Energy principle: minimizing $\\int \\nu \\lvert B\\rvert^2/2 \\, \\mathrm{d}V - \\int \\phi\\cdot B \\, \\mathrm{d}V$ subject to $\\nabla\\cdot B=0$, with reluctivity $\\nu=1/\\mu$ and a generic source coupling $\\phi$, leads to a saddle-point linear system.\n\nDiscretization setup:\n- Use a tetrahedral mesh consisting of $2$ tetrahedra sharing one face. The vertices (in dimensionless units) are:\n  - $v_0=(0,0,0)$,\n  - $v_1=(1,0,0)$,\n  - $v_2=(0,1,0)$,\n  - $v_3=(0,0,1)$,\n  - $v_4=(1,1,1)$.\n- The two tetrahedra are:\n  - $T_0=(v_0,v_1,v_2,v_3)$,\n  - $T_1=(v_1,v_2,v_3,v_4)$.\n- Construct the set of unique triangular faces as unordered triples of vertex indices; for each face, fix a global orientation by ordering its vertex indices increasingly, and compute its geometric quantities:\n  - Face centroid $c_f$ as the arithmetic mean of its $3$ vertices.\n  - Unnormalized face normal $n_f$ from the cross product of two edge vectors consistent with the chosen orientation.\n  - Face area $A_f=\\frac{1}{2}\\lVert n_f\\rVert$.\n\nAssembly of the discrete divergence operator:\n- Compute cell centroids $c_{T}$ for each tetrahedron $T$.\n- Determine face-to-cell adjacency: a boundary face belongs to one tetrahedron, an interior face belongs to two.\n- Define the discrete divergence matrix $D\\in\\mathbb{R}^{N_c\\times N_f}$, where $N_c=2$ is the number of cells and $N_f$ is the number of faces. Its entries are given by\n  $$\n  D_{T,f}=\\operatorname{sign}(n_f\\cdot(c_f-c_T)),\n  $$\n  i.e., $+1$ if the chosen face normal points outward from cell $T$, and $-1$ if it points inward. This choice ensures that for faces shared by two cells, the signs are opposite, so interior fluxes cancel in the cell-wise divergence sum.\n\nUnknowns and matrices:\n- Discrete unknown $b\\in\\mathbb{R}^{N_f}$ represents the face-integrated normal magnetic flux $B\\cdot n$ across each face (i.e., a face flux cochain). The divergence-free constraint is $D b=0$.\n- Define a diagonal, symmetric positive-definite matrix $K\\in\\mathbb{R}^{N_f\\times N_f}$ that weights the flux components using reluctivity on faces:\n  $$\n  K_{f,f}=\\nu_f A_f,\\quad \\nu_f=\\frac{1}{\\mu_f},\n  $$\n  where face reluctivity $\\nu_f$ is built from cell-wise $\\mu$ as follows:\n  - If face $f$ is a boundary face adjacent to a single cell $T$, set $\\mu_f=\\mu_T$.\n  - If face $f$ is interior and shared by cells $T_a$ and $T_b$, set $\\mu_f$ to the harmonic mean of $\\mu_{T_a}$ and $\\mu_{T_b}$, i.e.,\n    $$\n    \\mu_f=\\frac{2}{\\frac{1}{\\mu_{T_a}}+\\frac{1}{\\mu_{T_b}}},\\quad \\nu_f=\\frac{1}{\\mu_f}.\n    $$\n- Let $f\\in\\mathbb{R}^{N_f}$ be a given face source vector (dimensionless). Without the constraint, the unconstrained minimizer is $b_0=K^{-1}f$, which generally has nonzero discrete divergence $D b_0\\neq 0$.\n- The constrained saddle-point system is\n  $$\n  \\begin{pmatrix}\n  K & D^\\top \\\\\n  D & 0\n  \\end{pmatrix}\n  \\begin{pmatrix}\n  b \\\\\n  p\n  \\end{pmatrix}\n  =\n  \\begin{pmatrix}\n  f \\\\\n  0\n  \\end{pmatrix},\n  $$\n  where $p\\in\\mathbb{R}^{N_c}$ is the Lagrange multiplier enforcing $D b=0$.\n\nAlgorithmic requirements:\n- Assemble $D$, $K$, and compute $b_0$ and its divergence $D b_0$.\n- Solve the saddle-point system using the Schur complement:\n  $$\n  S p = D K^{-1} f,\\quad S=D K^{-1} D^\\top,\\quad b=K^{-1}(f-D^\\top p),\n  $$\n  where $K^{-1}$ is the diagonal inverse of $K$. Verify that $D b$ is (up to numerical roundoff) the zero vector.\n\nTest suite:\n- Use the mesh above and define three parameter sets:\n  $1.$ Homogeneous case: $\\mu=[1,1]$ for cells $T_0,T_1$ and source vector defined by $f_f=1$ for boundary faces and $f_f=0$ for interior faces.\n  $2.$ Heterogeneous case: $\\mu=[1,4]$ with the same source vector rule $f_f=1$ for boundary faces and $f_f=0$ for interior faces.\n  $3.$ Null source case: $\\mu=[1,1]$ and $f_f=0$ for all faces.\n- For each case, compute two quantities:\n  - The maximum absolute unconstrained discrete divergence $\\max\\lvert D b_0\\rvert$ across the two cells.\n  - The maximum absolute constrained discrete divergence $\\max\\lvert D b\\rvert$ across the two cells.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with entries ordered per case as\n  $$\n  [\\max\\lvert D b_0\\rvert, \\max\\lvert D b\\rvert]_{\\text{case }1}, [\\max\\lvert D b_0\\rvert, \\max\\lvert D b\\rvert]_{\\text{case }2}, [\\max\\lvert D b_0\\rvert, \\max\\lvert D b\\rvert]_{\\text{case }3}.\n  $$\nThat is, the final output should be a single list of $6$ floats: $[\\text{before}_1,\\text{after}_1,\\text{before}_2,\\text{after}_2,\\text{before}_3,\\text{after}_3]$.\n\nAll quantities in this problem are dimensionless, so no physical unit conversion is required. Ensure scientific realism by using the geometry and assembly described, and do not introduce any artificial or unphysical coefficients beyond the definitions given above.", "solution": "The problem requires the construction and solution of a discrete saddle-point system for a magnetostatics problem on a simple tetrahedral mesh. The approach involves a finite volume discretization where magnetic flux is associated with mesh faces and a Lagrange multiplier, associated with mesh cells (tetrahedra), is used to enforce the divergence-free constraint on the magnetic flux density. The solution will be implemented by following the precise geometric and algebraic steps outlined in the problem statement.\n\nFirst, we define the mesh geometry. The mesh consists of $N_c=2$ tetrahedra, $T_0$ and $T_1$, built from $5$ vertices, $v_0$ through $v_4$. From the definition of the tetrahedra, $T_0=(v_0,v_1,v_2,v_3)$ and $T_1=(v_1,v_2,v_3,v_4)$, we can identify the set of unique triangular faces. A tetrahedron has $4$ faces. Listing the faces for both tetrahedra reveals that they share a common face, $(v_1,v_2,v_3)$. The complete mesh, therefore, has $N_f=7$ unique faces. We establish a canonical representation for each face by storing its vertex indices in increasing order. This gives the set of faces: $f_0=(0,1,2)$, $f_1=(0,1,3)$, $f_2=(0,2,3)$, $f_3=(1,2,3)$, $f_4=(1,2,4)$, $f_5=(1,3,4)$, and $f_6=(2,3,4)$. Face $f_3$ is the interior face, while the other $6$ are boundary faces.\n\nNext, we compute the necessary geometric quantities for each face and cell. For each face $f$, we calculate its centroid $c_f$ as the arithmetic mean of its three vertices. A globally oriented, unnormalized normal vector $n_f$ is computed for each face by taking the cross product of two edge vectors derived from its vertices, ordered by their indices. For a face with vertices $(v_i, v_j, v_k)$ with $i<j<k$, we use $n_f = (v_j - v_i) \\times (v_k - v_i)$. The face area is then $A_f = \\frac{1}{2}\\lVert n_f\\rVert$. For each tetrahedron $T$, the cell centroid $c_T$ is the arithmetic mean of its four vertices.\n\nThe core of the discretization is the assembly of the discrete divergence operator $D \\in \\mathbb{R}^{N_c \\times N_f}$. This matrix maps face-based flux unknowns to cell-based divergence values. The entry $D_{T,f}$ is defined as the sign of the projection of the vector connecting the cell centroid $c_T$ to the face centroid $c_f$ onto the face's global normal vector $n_f$. That is, $D_{T,f}=\\operatorname{sign}\\big(n_f\\cdot(c_f-c_T)\\big)$ if face $f$ is part of cell $T$'s boundary, and $0$ otherwise. This definition ensures that $D_{T,f}$ is $+1$ if the global normal $n_f$ points out of cell $T$ and $-1$ if it points in. For the interior face $f_3$ shared by $T_0$ and $T_1$, this construction correctly yields $D_{T_0,f_3} = -D_{T_1,f_3}$.\n\nThe physical properties of the medium are captured in the matrix $K \\in \\mathbb{R}^{N_f \\times N_f}$. This matrix is diagonal and symmetric positive-definite, with diagonal entries $K_{f,f} = \\nu_f A_f$, where $\\nu_f = 1/\\mu_f$ is the magnetic reluctivity on face $f$. The face permeability $\\mu_f$ is determined based on face-to-cell adjacency. If face $f$ is on the boundary and belongs to a single cell $T$, $\\mu_f = \\mu_T$. If face $f$ is interior, shared by cells $T_a$ and $T_b$, its permeability is the harmonic mean of the cell permeabilities, $\\mu_f = 2 / (1/\\mu_{T_a} + 1/\\mu_{T_b})$.\n\nWith these matrices, the problem of finding the face fluxes $b \\in \\mathbb{R}^{N_f}$ and the Lagrange multipliers $p \\in \\mathbb{R}^{N_c}$ is expressed as the saddle-point linear system:\n$$\n\\begin{pmatrix}\nK & D^\\top \\\\\nD & 0\n\\end{pmatrix}\n\\begin{pmatrix}\nb \\\\\np\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nf \\\\\n0\n\\end{pmatrix}\n$$\nwhere $f \\in \\mathbb{R}^{N_f}$ is a source vector. The second row of this system, $D b = 0$, explicitly enforces the discrete divergence-free constraint.\n\nWe solve this system using the Schur complement method, which is efficient for such structures. First, we solve for the Lagrange multiplier $p$. From the first block row, $b = K^{-1}(f - D^\\top p)$. Substituting this into the second block row gives $D(K^{-1}(f - D^\\top p)) = 0$, which leads to the Schur complement system for $p$:\n$$\n(D K^{-1} D^\\top) p = D K^{-1} f\n$$\nThe Schur complement matrix $S = D K^{-1} D^\\top$ is a small $N_c \\times N_c$ (i.e., $2 \\times 2$) matrix. Since $K$ is diagonal, its inverse $K^{-1}$ is trivially computed. We solve $S p = D K^{-1} f$ for $p$ using a standard linear solver. Once $p$ is known, the constrained flux vector $b$ is recovered via back-substitution: $b = K^{-1}(f - D^\\top p)$.\n\nFor comparison, the unconstrained solution, which does not enforce the divergence-free condition, is simply $b_0 = K^{-1}f$. We compute the discrete divergence for both the unconstrained solution, $D b_0$, and the constrained solution, $D b$. The problem asks for the maximum absolute value of the divergence components for each solution, $\\max\\lvert D b_0 \\rvert$ and $\\max\\lvert D b \\rvert$. For a valid implementation, the latter should be close to machine precision zero, demonstrating the successful enforcement of the constraint. This procedure is repeated for the three test cases specified, varying the material property $\\mu$ and the source vector $f$. The final output is an aggregation of the computed maximum divergence values for all cases. For the null source case ($f=0$), the solution is trivially $b_0=b=p=0$, resulting in zero divergence for both unconstrained and constrained scenarios.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and solves a magnetostatic saddle-point problem on a fixed\n    tetrahedral mesh for three different test cases.\n    \"\"\"\n\n    def setup_geometry():\n        \"\"\"\n        Defines the mesh vertices, tetrahedra, and faces.\n        Returns canonical lists and mappings for geometric entities.\n        \"\"\"\n        vertices = np.array([\n            [0, 0, 0],  # v0\n            [1, 0, 0],  # v1\n            [0, 1, 0],  # v2\n            [0, 0, 1],  # v3\n            [1, 1, 1],  # v4\n        ], dtype=float)\n\n        tets = np.array([[0, 1, 2, 3], [1, 2, 3, 4]], dtype=int)\n\n        tet_faces = [\n            [(0, 1, 2), (0, 1, 3), (0, 2, 3), (1, 2, 3)],  # Faces of T0\n            [(1, 2, 4), (1, 3, 4), (2, 3, 4), (1, 2, 3)],  # Faces of T1\n        ]\n        \n        unique_faces_set = set()\n        for i_tet, tet in enumerate(tet_faces):\n            for face_verts in tet:\n                unique_faces_set.add(tuple(sorted(face_verts)))\n        \n        # Create a canonical ordering of faces\n        faces = sorted(list(unique_faces_set))\n        face_map = {face: i for i, face in enumerate(faces)}\n\n        face_to_cell_map = [[] for _ in range(len(faces))]\n        for i_tet, tet_face_list in enumerate(tet_faces):\n            for face_verts in tet_face_list:\n                face_id = face_map[tuple(sorted(face_verts))]\n                if i_tet not in face_to_cell_map[face_id]:\n                    face_to_cell_map[face_id].append(i_tet)\n\n        return vertices, tets, faces, face_to_cell_map\n\n    def compute_geometric_quantities(vertices, faces, tets):\n        \"\"\"\n        Computes face centroids, normals, areas, and cell centroids.\n        \"\"\"\n        num_faces = len(faces)\n        num_cells = len(tets)\n\n        face_centroids = np.zeros((num_faces, 3))\n        face_normals = np.zeros((num_faces, 3))\n        face_areas = np.zeros(num_faces)\n        for i, face_indices in enumerate(faces):\n            v = vertices[list(face_indices)]\n            face_centroids[i] = np.mean(v, axis=0)\n            \n            # Normal from cross product of edges based on sorted vertex indices\n            e1 = v[1] - v[0]\n            e2 = v[2] - v[0]\n            normal = np.cross(e1, e2)\n            face_normals[i] = normal\n            face_areas[i] = 0.5 * np.linalg.norm(normal)\n\n        cell_centroids = np.zeros((num_cells, 3))\n        for i, tet_indices in enumerate(tets):\n            cell_centroids[i] = np.mean(vertices[tet_indices], axis=0)\n\n        return face_centroids, face_normals, face_areas, cell_centroids\n\n    def assemble_divergence_matrix(num_cells, num_faces, faces, tets, face_to_cell_map, face_normals, face_centroids, cell_centroids):\n        \"\"\"\n        Assembles the discrete divergence matrix D.\n        \"\"\"\n        D = np.zeros((num_cells, num_faces))\n        for i_face in range(num_faces):\n            for i_cell in face_to_cell_map[i_face]:\n                # D_T,f = sign(n_f . (c_f - c_T))\n                vec_cf_ct = face_centroids[i_face] - cell_centroids[i_cell]\n                D[i_cell, i_face] = np.sign(np.dot(face_normals[i_face], vec_cf_ct))\n        return D\n\n    def run_simulation(case_params, D, face_areas, face_to_cell_map):\n        \"\"\"\n        Runs one simulation case: assembles K, f, solves, and returns results.\n        \"\"\"\n        num_faces = D.shape[1]\n        mu_cells = case_params['mu']\n        \n        # Assemble diagonal K matrix\n        K_diag = np.zeros(num_faces)\n        for i_face in range(num_faces):\n            adj_cells = face_to_cell_map[i_face]\n            if len(adj_cells) == 1: # Boundary face\n                mu_face = mu_cells[adj_cells[0]]\n            else: # Interior face\n                mu_face = 2.0 / (1.0/mu_cells[adj_cells[0]] + 1.0/mu_cells[adj_cells[1]])\n            \n            nu_face = 1.0 / mu_face\n            K_diag[i_face] = nu_face * face_areas[i_face]\n        \n        # Assemble source vector f\n        f_vec = np.zeros(num_faces)\n        if case_params['source'] == 'boundary':\n            for i_face in range(num_faces):\n                if len(face_to_cell_map[i_face]) == 1:\n                    f_vec[i_face] = 1.0\n        # For 'zero' source, f_vec remains zero.\n\n        # Unconstrained solution and its divergence\n        # Handle cases where K might have zero diagonals (if area is zero)\n        K_inv_diag = np.zeros_like(K_diag)\n        non_zero_mask = K_diag != 0\n        K_inv_diag[non_zero_mask] = 1.0 / K_diag[non_zero_mask]\n\n        b0 = K_inv_diag * f_vec\n        div_b0 = D @ b0\n        max_abs_div_b0 = np.max(np.abs(div_b0))\n\n        # Solve saddle-point system using Schur complement\n        # S p = D K^-1 f\n        # S = D K^-1 D^T\n        S = D @ np.diag(K_inv_diag) @ D.T\n        rhs_p = D @ b0\n\n        # Handle trivial case f=0\n        if np.all(rhs_p == 0):\n            p = np.zeros(D.shape[0])\n        else:\n            p = np.linalg.solve(S, rhs_p)\n\n        # Back-substitute for b\n        # b = K^-1 (f - D^T p)\n        b = K_inv_diag * (f_vec - D.T @ p)\n        div_b = D @ b\n        max_abs_div_b = np.max(np.abs(div_b))\n        \n        return max_abs_div_b0, max_abs_div_b\n\n    # --- Main execution logic ---\n    \n    # 1. Setup mesh and geometry\n    vertices, tets, faces, face_to_cell_map = setup_geometry()\n    face_centroids, face_normals, face_areas, cell_centroids = compute_geometric_quantities(vertices, faces, tets)\n    \n    num_cells = len(tets)\n    num_faces = len(faces)\n    \n    # 2. Assemble divergence matrix D\n    D = assemble_divergence_matrix(num_cells, num_faces, faces, tets, face_to_cell_map, face_normals, face_centroids, cell_centroids)\n\n    # 3. Define and run test cases\n    test_cases = [\n        {'mu': [1.0, 1.0], 'source': 'boundary'},  # Case 1\n        {'mu': [1.0, 4.0], 'source': 'boundary'},  # Case 2\n        {'mu': [1.0, 1.0], 'source': 'zero'},      # Case 3\n    ]\n\n    results = []\n    for case in test_cases:\n        b0_div, b_div = run_simulation(case, D, face_areas, face_to_cell_map)\n        results.extend([b0_div, b_div])\n\n    # 4. Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3525101"}]}