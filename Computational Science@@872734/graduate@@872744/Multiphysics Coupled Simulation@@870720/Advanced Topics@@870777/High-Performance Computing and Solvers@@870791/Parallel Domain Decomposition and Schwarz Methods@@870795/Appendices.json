{"hands_on_practices": [{"introduction": "The efficiency of Schwarz methods is highly dependent on the transmission conditions imposed at artificial interfaces. This practice guides you through the classical analysis for optimizing these conditions for the one-dimensional heat equation. By working in the Fourier domain, you will derive the convergence factor for the waveform relaxation algorithm and find the exact Robin parameter that minimizes error propagation between subdomains [@problem_id:3519545].", "problem": "Consider the one-dimensional heat equation $u_{t}-\\nu u_{xx}=0$ on the whole line $\\mathbb{R}$, where $\\nu0$ is a constant thermal diffusivity. Split the spatial domain into two non-overlapping subdomains $\\Omega_{1}=(-\\infty,0)$ and $\\Omega_{2}=(0,\\infty)$, and consider a Schwarz waveform relaxation iteration with Robin transmission conditions on the interface $x=0$. Specifically, let the outward unit normals be $n_{1}=+1$ for $\\Omega_{1}$ and $n_{2}=-1$ for $\\Omega_{2}$, and impose at each iteration the Robin conditions of the form $\\partial_{n} u + \\alpha u$ communicated from the neighboring subdomain at $x=0$, where $\\alpha0$ is a real Robin parameter.\n\nAssume zero forcing and focus on the error propagation. Analyze the iteration in the time-Fourier domain: take the temporal Fourier transform with angular frequency $\\omega\\ge 0$ so that the transformed fields $\\widehat{u}(x,\\omega)$ satisfy a second-order homogeneous ordinary differential equation in $x$. Choose the decaying solutions in each semi-infinite subdomain and derive the scalar error-propagation factor $r(\\omega,\\alpha)$ at the interface $x=0$ in terms of $\\alpha$, $\\nu$, and $\\omega$.\n\nDetermine the value $\\alpha^{\\star}(\\omega)$ that minimizes the magnitude of the error-propagation factor $|r(\\omega,\\alpha)|$ with respect to $\\alpha\\in\\mathbb{R}_{+}$, and express $\\alpha^{\\star}(\\omega)$ in closed form as a function of $\\omega$ and $\\nu$. Your final answer must be a single analytical expression for $\\alpha^{\\star}(\\omega)$. No rounding is required. Do not include units in your final boxed answer.", "solution": "We begin with the one-dimensional heat equation on the real line:\n$$\nu_{t} - \\nu u_{xx} = 0, \\quad x \\in \\mathbb{R}, t  0\n$$\nwhere $\\nu  0$ is the thermal diffusivity. We consider the propagation of errors, which satisfy the same homogeneous equation.\n\nThe analysis is performed in the temporal Fourier domain. Let $\\widehat{u}(x,\\omega)$ be the temporal Fourier transform of $u(x,t)$, defined as $\\widehat{u}(x,\\omega) = \\int_{-\\infty}^{\\infty} u(x,t) e^{-i\\omega t} dt$. Applying the transform to the heat equation, the time derivative $\\partial_t$ becomes multiplication by $i\\omega$. This yields a homogeneous second-order ordinary differential equation (ODE) in the spatial variable $x$:\n$$\ni\\omega \\widehat{u}(x,\\omega) - \\nu \\frac{d^2\\widehat{u}}{dx^2}(x,\\omega) = 0\n$$\n$$\n\\frac{d^2\\widehat{u}}{dx^2} - \\frac{i\\omega}{\\nu} \\widehat{u} = 0\n$$\nThe characteristic equation for this ODE is $\\lambda^2 - \\frac{i\\omega}{\\nu} = 0$. The roots are $\\lambda = \\pm \\sqrt{\\frac{i\\omega}{\\nu}}$.\nTo simplify the roots, we use the polar representation of the imaginary unit, $i = e^{i\\pi/2}$. Therefore, $\\sqrt{i} = e^{i\\pi/4} = \\cos(\\frac{\\pi}{4}) + i\\sin(\\frac{\\pi}{4}) = \\frac{1+i}{\\sqrt{2}}$. The roots become:\n$$\n\\lambda = \\pm \\sqrt{\\frac{\\omega}{\\nu}} \\left( \\frac{1+i}{\\sqrt{2}} \\right) = \\pm \\sqrt{\\frac{\\omega}{2\\nu}}(1+i)\n$$\nLet us define $k(\\omega) = \\sqrt{\\frac{\\omega}{2\\nu}}(1+i)$. The real part of $k(\\omega)$ is $\\operatorname{Re}(k(\\omega)) = \\sqrt{\\frac{\\omega}{2\\nu}}$, which is non-negative for $\\omega \\ge 0$. The general solution to the ODE is $\\widehat{u}(x,\\omega) = C_1 e^{k(\\omega)x} + C_2 e^{-k(\\omega)x}$.\n\nThe problem requires solutions that decay as $|x| \\to \\infty$.\n-   In subdomain $\\Omega_1 = (-\\infty, 0)$, the solution must decay as $x \\to -\\infty$. The term $e^{-k(\\omega)x}$ grows in magnitude as $x \\to -\\infty$, so its coefficient must be zero. The solution is thus of the form $\\widehat{u}_1(x,\\omega) = A_1 e^{k(\\omega)x}$.\n-   In subdomain $\\Omega_2 = (0, \\infty)$, the solution must decay as $x \\to +\\infty$. The term $e^{k(\\omega)x}$ grows in magnitude as $x \\to +\\infty$, so its coefficient must be zero. The solution is thus of the form $\\widehat{u}_2(x,\\omega) = A_2 e^{-k(\\omega)x}$.\n\nThe Schwarz waveform relaxation iteration involves exchanging Robin boundary data at the interface $x=0$. Let the iteration index be $j$. The outward normal for $\\Omega_1$ is $n_1=+1$, so $\\partial_{n_1}=\\partial_x$. The outward normal for $\\Omega_2$ is $n_2=-1$, so $\\partial_{n_2}=-\\partial_x$. The iteration scheme is:\n$$\n(\\partial_{n_1} + \\alpha) u_1^j(0,t) = (\\partial_{n_1} + \\alpha) u_2^{j-1}(0,t)\n$$\n$$\n(\\partial_{n_2} + \\alpha) u_2^j(0,t) = (\\partial_{n_2} + \\alpha) u_1^{j-1}(0,t)\n$$\nIn terms of the spatial derivative $\\partial_x$, this is:\n$$\n(\\partial_x + \\alpha) u_1^j(0,t) = (\\partial_x + \\alpha) u_2^{j-1}(0,t)\n$$\n$$\n(-\\partial_x + \\alpha) u_2^j(0,t) = (-\\partial_x + \\alpha) u_1^{j-1}(0,t)\n$$\nTaking the Fourier transform of these transmission conditions yields:\n$$\n\\left(\\frac{d}{dx} + \\alpha\\right) \\widehat{u}_1^j(0,\\omega) = \\left(\\frac{d}{dx} + \\alpha\\right) \\widehat{u}_2^{j-1}(0,\\omega)\n$$\n$$\n\\left(-\\frac{d}{dx} + \\alpha\\right) \\widehat{u}_2^j(0,\\omega) = \\left(-\\frac{d}{dx} + \\alpha\\right) \\widehat{u}_1^{j-1}(0,\\omega)\n$$\nWe now substitute the forms of the solutions $\\widehat{u}_1^j(x,\\omega) = A_1^j e^{k(\\omega)x}$ and $\\widehat{u}_2^j(x,\\omega) = A_2^j e^{-k(\\omega)x}$ and their derivatives at $x=0$:\n-   $\\widehat{u}_1^j(0,\\omega) = A_1^j$ and $\\frac{d\\widehat{u}_1^j}{dx}(0,\\omega) = k(\\omega) A_1^j$.\n-   $\\widehat{u}_2^j(0,\\omega) = A_2^j$ and $\\frac{d\\widehat{u}_2^j}{dx}(0,\\omega) = -k(\\omega) A_2^j$.\n\nSubstituting these into the first transformed TC:\n$$\nk(\\omega) A_1^j + \\alpha A_1^j = -k(\\omega) A_2^{j-1} + \\alpha A_2^{j-1} \\implies (k(\\omega)+\\alpha) A_1^j = (\\alpha-k(\\omega)) A_2^{j-1}\n$$\nSubstituting into the second transformed TC:\n$$\n-(-k(\\omega) A_2^j) + \\alpha A_2^j = -(k(\\omega) A_1^{j-1}) + \\alpha A_1^{j-1} \\implies (k(\\omega)+\\alpha) A_2^j = (\\alpha-k(\\omega)) A_1^{j-1}\n$$\nThese equations show that the coefficients are updated according to:\n$$\nA_1^j = \\frac{\\alpha - k(\\omega)}{\\alpha + k(\\omega)} A_2^{j-1} \\quad \\text{and} \\quad A_2^j = \\frac{\\alpha - k(\\omega)}{\\alpha + k(\\omega)} A_1^{j-1}\n$$\nThe error-propagation factor for the exchange between subdomains is defined as:\n$$\nr(\\omega, \\alpha) = \\frac{\\alpha - k(\\omega)}{\\alpha + k(\\omega)}\n$$\nWe want to find the value of $\\alpha > 0$ that minimizes the magnitude $|r(\\omega, \\alpha)|$. This is equivalent to minimizing $|r(\\omega, \\alpha)|^2$.\nLet $k(\\omega) = a+ib$, where $a = \\operatorname{Re}(k(\\omega)) = \\sqrt{\\frac{\\omega}{2\\nu}}$ and $b = \\operatorname{Im}(k(\\omega)) = \\sqrt{\\frac{\\omega}{2\\nu}}$.\n$$\n|r(\\omega, \\alpha)|^2 = \\left| \\frac{\\alpha - (a+ib)}{\\alpha + (a+ib)} \\right|^2 = \\frac{|\\alpha-a-ib|^2}{|\\alpha+a+ib|^2} = \\frac{(\\alpha-a)^2 + b^2}{(\\alpha+a)^2 + b^2}\n$$\nLet $f(\\alpha) = |r(\\omega, \\alpha)|^2$. To find the minimum, we take the derivative of $f(\\alpha)$ with respect to $\\alpha$ and set it to zero, assuming $\\omega > 0$ (and thus $a0$).\n$$\nf'(\\alpha) = \\frac{ d }{ d\\alpha } \\left( \\frac{\\alpha^2 - 2a\\alpha + a^2 + b^2}{\\alpha^2 + 2a\\alpha + a^2 + b^2} \\right)\n$$\nUsing the quotient rule, $f'(\\alpha) = \\frac{(2\\alpha-2a)(\\alpha^2+2a\\alpha+a^2+b^2) - (\\alpha^2-2a\\alpha+a^2+b^2)(2\\alpha+2a)}{(\\alpha^2+2a\\alpha+a^2+b^2)^2}$.\nSetting the numerator to zero:\n$$\n(2\\alpha-2a)(\\alpha^2+2a\\alpha+a^2+b^2) - (\\alpha^2-2a\\alpha+a^2+b^2)(2\\alpha+2a) = 0\n$$\n$$\n2(\\alpha-a)(\\alpha^2+2a\\alpha+a^2+b^2) - 2(\\alpha+a)(\\alpha^2-2a\\alpha+a^2+b^2) = 0\n$$\nExpanding and simplifying gives:\n$$\n(\\alpha^3+a\\alpha^2+(b^2-a^2)\\alpha - a(a^2+b^2)) - (\\alpha^3-a\\alpha^2+(b^2-a^2)\\alpha + a(a^2+b^2)) = 0\n$$\n$$\n2a\\alpha^2 - 2a(a^2+b^2) = 0\n$$\nSince we are considering $\\omega > 0$, we have $a > 0$, so we can divide by $2a$:\n$$\n\\alpha^2 - (a^2+b^2) = 0 \\implies \\alpha^2 = a^2+b^2\n$$\nSince $\\alpha > 0$, the optimal value is $\\alpha^{\\star} = \\sqrt{a^2+b^2}$. This corresponds to the modulus of the complex number $k(\\omega)$, so $\\alpha^{\\star} = |k(\\omega)|$.\n\nNow, we express $\\alpha^{\\star}$ in terms of the given parameters $\\omega$ and $\\nu$.\n$$\na^2 = \\left(\\sqrt{\\frac{\\omega}{2\\nu}}\\right)^2 = \\frac{\\omega}{2\\nu}\n$$\n$$\nb^2 = \\left(\\sqrt{\\frac{\\omega}{2\\nu}}\\right)^2 = \\frac{\\omega}{2\\nu}\n$$\n$$\n\\alpha^{\\star}(\\omega)^2 = a^2 + b^2 = \\frac{\\omega}{2\\nu} + \\frac{\\omega}{2\\nu} = \\frac{2\\omega}{2\\nu} = \\frac{\\omega}{\\nu}\n$$\nTaking the square root (and remembering $\\alpha > 0, \\omega \\ge 0$), we obtain the final expression for the optimal Robin parameter:\n$$\n\\alpha^{\\star}(\\omega) = \\sqrt{\\frac{\\omega}{\\nu}}\n$$\nThis expression is valid for $\\omega \\ge 0$. For $\\omega=0$, $\\alpha^{\\star}(0)=0$, which is outside the specified domain $\\alpha \\in \\mathbb{R}_+$. In this case, $|r|=1$ for any $\\alpha0$, so there is no optimal choice. However, the derived formula gives the limit of the optimal parameter as $\\omega \\to 0^+$.", "answer": "$$\\boxed{\\sqrt{\\frac{\\omega}{\\nu}}}$$", "id": "3519545"}, {"introduction": "When convection is present, the direction of flow must be respected in the numerical scheme to ensure stability and physical accuracy. This problem challenges you to design and analyze an upwinded Robin transmission condition for a steady convection-diffusion operator. You will start from the conservative form of the equation to identify the physical flux and then compute the resulting flux jump at the discrete level, providing insight into the consistency of domain decomposition methods for transport problems [@problem_id:3519548].", "problem": "Consider the one-dimensional steady convection-diffusion operator $-\\varepsilon u'' + c\\,u'$ with constant parameters $\\varepsilon  0$ and $c  0$ on a domain decomposed into two non-overlapping subdomains that meet at an artificial interface point $x_{\\Gamma}$. In a Parallel Schwarz method (PSM) with Robin transmission, the interface operator is chosen to enforce continuity of a physically meaningful flux across $x_{\\Gamma}$, and an upwind principle is used for the convective part.\n\nStarting from the conservative form of the operator, define the continuous flux $f(x)$ such that the governing equation can be written as a conservation law for $f(x)$. Using this identification, motivate an upwinded Robin transmission operator at $x_{\\Gamma}$ that incorporates the local flow direction ($c0$), and argue for an appropriate Robin coefficient that yields a consistent interface condition in the sense of flux continuity.\n\nOn a uniform grid with spacing $h$, the outward one-sided discrete derivative at the interface from the left subdomain is\n$$\nD^{-}u(x_{\\Gamma}^{-}) \\approx \\frac{u_{m}^{(L)} - u_{m-1}^{(L)}}{h},\n$$\nand from the right subdomain is\n$$\nD^{+}u(x_{\\Gamma}^{+}) \\approx \\frac{u_{m+1}^{(R)} - u_{m}^{(R)}}{h},\n$$\nwhere $u_{m-1}^{(L)}$, $u_{m}^{(L)}$ are the last two grid values in the left subdomain and $u_{m}^{(R)}$, $u_{m+1}^{(R)}$ are the first two grid values in the right subdomain, with $x_{\\Gamma}$ coinciding with the grid point indexed by $m$. Using a first-order upwind treatment for the convective contribution at the interface when $c0$, evaluate the discrete flux from each side and form the discrete flux jump $\\Delta f := f^{+} - f^{-}$.\n\nGiven the numerical values\n$$\n\\varepsilon = 5.0 \\times 10^{-2}, \\quad c = 2, \\quad h = 1.0 \\times 10^{-1},\n$$\nand the interface-adjacent grid values\n$$\nu_{m-1}^{(L)} = 1.0, \\quad u_{m}^{(L)} = 9.0 \\times 10^{-1}, \\quad u_{m}^{(R)} = 8.8 \\times 10^{-1}, \\quad u_{m+1}^{(R)} = 8.2 \\times 10^{-1},\n$$\ncompute the discrete flux jump $\\Delta f$ at $x_{\\Gamma}$ induced by the upwinded Robin transmission and express your final numerical result as a pure number. Round your answer to four significant figures.", "solution": "The governing operator is $\\mathcal{L}u = -\\varepsilon u'' + c u'$, with constants $\\varepsilon  0$ and $c  0$. This operator can be written in conservative form as the derivative of a flux function $f(x)$. By integrating the operator with respect to $x$, we identify the flux as:\n$$\nf(x) = -\\varepsilon u'(x) + c u(x)\n$$\nThe homogeneous governing equation $\\mathcal{L}u = 0$ is thus equivalent to the conservation law $f'(x) = 0$, which implies that the flux $f(x)$ is constant in any source-free region. A physically consistent condition at an interface $x_{\\Gamma}$ is the continuity of this flux, i.e., $[f]_{x_{\\Gamma}} = f(x_{\\Gamma}^{+}) - f(x_{\\Gamma}^{-}) = 0$.\n\nIn a Parallel Schwarz Method with Robin transmission conditions, a condition of the form $-\\varepsilon u' + p u = \\text{RHS}$ is applied at the boundary of each subdomain. A natural and physically consistent choice for the Robin parameter is $p=c$. With this choice, the Robin operator, $-\\varepsilon u' + c u$, becomes identical to the physical flux operator $f(x)$. This choice directly enforces continuity of the physical flux and incorporates the directionality of the convective transport ($c0$) in the transmission condition itself.\n\nWe now evaluate the discrete flux jump, $\\Delta f = f^{+} - f^{-}$, at the interface point $x_{\\Gamma}$, which coincides with the grid point indexed by $m$. This requires discretizing the flux expression $f(x)$ on both sides of the interface.\n\nThe diffusive part of the flux is $-\\varepsilon u'$. The problem provides the following one-sided finite difference approximations for the derivative $u'$ at $x_{\\Gamma}$, using data from the left ($L$) and right ($R$) subdomains:\n$$\nu'^{(L)}(x_{\\Gamma}) \\approx d_L = \\frac{u_{m}^{(L)} - u_{m-1}^{(L)}}{h}\n$$\n$$\nu'^{(R)}(x_{\\Gamma}) \\approx d_R = \\frac{u_{m+1}^{(R)} - u_{m}^{(R)}}{h}\n$$\n\nThe convective part of the flux is $c u$. Using a first-order upwind treatment, and since the convection coefficient $c  0$, the flow of information is from left to right. Therefore, the value of $u$ at the interface for the convective term should be taken from the upwind (left) side. The discrete value is $u_{m}^{(L)}$. This same upwind value is used to calculate the convective flux contribution for both the left and right sides of the interface to ensure consistency.\n\nUsing these discretizations, we can express the discrete flux from each side of the interface. The discrete flux from the left, $f_h^{-}$, is:\n$$\nf_h^{-} = -\\varepsilon d_L + c u_{m}^{(L)} = -\\varepsilon \\frac{u_{m}^{(L)} - u_{m-1}^{(L)}}{h} + c u_{m}^{(L)}\n$$\nThe discrete flux from the right, $f_h^{+}$, uses the derivative from the right side but the same upwinded convective term:\n$$\nf_h^{+} = -\\varepsilon d_R + c u_{m}^{(L)} = -\\varepsilon \\frac{u_{m+1}^{(R)} - u_{m}^{(R)}}{h} + c u_{m}^{(L)}\n$$\nThe discrete flux jump $\\Delta f$ is the difference between these two quantities:\n$$\n\\Delta f = f_h^{+} - f_h^{-} = \\left(-\\varepsilon \\frac{u_{m+1}^{(R)} - u_{m}^{(R)}}{h} + c u_{m}^{(L)}\\right) - \\left(-\\varepsilon \\frac{u_{m}^{(L)} - u_{m-1}^{(L)}}{h} + c u_{m}^{(L)}\\right)\n$$\nThe upwinded convective terms are identical and cancel out:\n$$\n\\Delta f = -\\varepsilon \\frac{u_{m+1}^{(R)} - u_{m}^{(R)}}{h} + \\varepsilon \\frac{u_{m}^{(L)} - u_{m-1}^{(L)}}{h} = \\frac{\\varepsilon}{h} \\left[ (u_{m}^{(L)} - u_{m-1}^{(L)}) - (u_{m+1}^{(R)} - u_{m}^{(R)}) \\right]\n$$\nWe are given the following numerical values:\n$\\varepsilon = 5.0 \\times 10^{-2}$\n$c = 2$\n$h = 1.0 \\times 10^{-1}$\n$u_{m-1}^{(L)} = 1.0$\n$u_{m}^{(L)} = 9.0 \\times 10^{-1} = 0.9$\n$u_{m}^{(R)} = 8.8 \\times 10^{-1} = 0.88$\n$u_{m+1}^{(R)} = 8.2 \\times 10^{-1} = 0.82$\n\nWe substitute these values into the expression for $\\Delta f$:\n$$\n\\Delta f = \\frac{5.0 \\times 10^{-2}}{1.0 \\times 10^{-1}} \\left[ (0.9 - 1.0) - (0.82 - 0.88) \\right]\n$$\n$$\n\\Delta f = 0.5 \\left[ (-0.1) - (-0.06) \\right]\n$$\n$$\n\\Delta f = 0.5 \\left[ -0.1 + 0.06 \\right]\n$$\n$$\n\\Delta f = 0.5 \\left[ -0.04 \\right]\n$$\n$$\n\\Delta f = -0.02\n$$\nRounding to four significant figures, the result is $-0.02000$.", "answer": "$$\\boxed{-0.02000}$$", "id": "3519548"}, {"introduction": "To tackle nonlinear multiphysics problems, we often combine Newton's method with domain decomposition, leading to powerful nonlinear preconditioners like the Additive Schwarz Preconditioned Inexact Newton (ASPIN) method. This hands-on coding practice requires you to implement one full ASPIN iteration for a nonlinear diffusion equation. By solving local nonlinear problems on subdomains and assembling a global correction, you will gain practical experience with the structure and performance of these advanced solvers [@problem_id:3519591].", "problem": "Implement a single Additive Schwarz Preconditioned Inexact Newton (ASPIN) iteration for a nonlinear, one-dimensional diffusion problem that models a scalar field coupling in a multiphysics setting. Consider the nonlinear Poisson equation on the unit interval with homogeneous Dirichlet boundary conditions,\n$$\n-\\frac{d}{dx}\\left(\\left(1+u(x)^2\\right)\\frac{du(x)}{dx}\\right) = f(x), \\quad x \\in (0,1), \\quad u(0)=0,\\; u(1)=0.\n$$\nUse a uniform grid with $N$ interior points, mesh size $h = \\frac{1}{N+1}$, and grid points $x_i = i h$ for $i = 1,2,\\dots,N$. Discretize the equation by enforcing conservation of flux with the standard second-order conservative stencil. Denote $u_i \\approx u(x_i)$ and define the nonlinear diffusion coefficient at cell faces by\n$$\na_{i+\\frac{1}{2}}(u) = 1 + \\left(\\frac{u_i + u_{i+1}}{2}\\right)^2, \\quad a_{i-\\frac{1}{2}}(u) = 1 + \\left(\\frac{u_{i-1} + u_{i}}{2}\\right)^2.\n$$\nDefine the discrete nonlinear residual $F(u) \\in \\mathbb{R}^N$ componentwise for $i=1,\\dots,N$ by\n$$\nF_i(u) = \\frac{1}{h^2}\\left(a_{i+\\frac{1}{2}}(u)\\left(u_{i+1}-u_i\\right) - a_{i-\\frac{1}{2}}(u)\\left(u_i-u_{i-1}\\right)\\right) - f_i,\n$$\nwith boundary values $u_0=0$ and $u_{N+1}=0$, and with $f_i \\approx f(x_i)$. The Euclidean norm of the discrete residual is\n$$\n\\|F(u)\\|_2 = \\left(\\sum_{i=1}^N F_i(u)^2\\right)^{1/2}.\n$$\nPartition the set of interior indices into two overlapping subdomains as follows. Let $m = \\left\\lfloor \\frac{N}{2} \\right\\rfloor$ and an overlap size $p \\in \\mathbb{N}$ with $1 \\le p \\le \\min(m, N-m)$. Define subdomain index sets\n$$\n\\Omega_1 = \\{1,2,\\dots,m+p\\}, \\quad \\Omega_2 = \\{m+1-p, m+2-p, \\dots, N\\}.\n$$\nOn each subdomain $\\Omega_k$ for $k \\in \\{1,2\\}$, form a local nonlinear problem by restricting the discrete residual equations to indices in $\\Omega_k$ and imposing Dirichlet boundary data on the artificial subdomain boundaries from the current global iterate $u^{(0)}$:\n- For $\\Omega_1$, use $u_0=0$ at the physical left boundary, and $u_{m+p+1} = u^{(0)}_{m+p+1}$ as the artificial right boundary condition.\n- For $\\Omega_2$, use $u_{m-p} = u^{(0)}_{m-p}$ as the artificial left boundary condition, and $u_{N+1}=0$ at the physical right boundary.\n\nLet $G_k(u^{(0)})$ denote the vector of subdomain nodal values that solves the local nonlinear system $F_{\\Omega_k}(v)=0$ on $\\Omega_k$ with these boundary conditions. Compute these local solutions by applying Newton’s method on each subdomain, using the Jacobian derived from the discrete residual and a backtracking line search to ensure sufficient decrease of the local residual norm. Initialize Newton with the restriction of $u^{(0)}$ to the subdomain.\n\nDefine the nonlinear preconditioned correction on each subdomain as $c_k = G_k(u^{(0)}) - u^{(0)}|_{\\Omega_k}$, and assemble a global correction $c \\in \\mathbb{R}^N$ by equal weighting in the overlap,\n$$\nc_i = \\begin{cases}\nc_{1,i}  \\text{if } i \\in \\Omega_1 \\setminus \\Omega_2,\\\\\nc_{2,i}  \\text{if } i \\in \\Omega_2 \\setminus \\Omega_1,\\\\\n\\frac{1}{2}\\left(c_{1,i}+c_{2,i}\\right)  \\text{if } i \\in \\Omega_1 \\cap \\Omega_2,\\\\\n0  \\text{otherwise}.\n\\end{cases}\n$$\nPerform one ASPIN update with damping parameter $\\alpha \\in (0,2]$,\n$$\nu^{(1)} = u^{(0)} + \\alpha\\, c.\n$$\nYour task is to implement the above in a single program that, for each test case, computes the decrease in the residual norm after one ASPIN iteration, defined as\n$$\n\\Delta = \\|F(u^{(0)})\\|_2 - \\|F(u^{(1)})\\|_2.\n$$\nDiscretize $f(x)$ on the grid as $f_i = f(x_i)$, using the following options for $f(x)$:\n- Constant source: $f(x) = A$, where $A \\in \\mathbb{R}$.\n- Sine source: $f(x) = A \\sin(\\kappa \\pi x)$, where $A \\in \\mathbb{R}$ and $\\kappa \\in \\mathbb{N}$.\n\nInitialize $u^{(0)}$ either as the zero vector or as a small sinusoid $u^{(0)}_i = B \\sin(\\pi x_i)$ with amplitude $B \\in \\mathbb{R}$, as specified by the test case.\n\nDesign and implement Newton’s method on each subdomain by differentiating the discrete residual $F_{\\Omega_k}$ with respect to the subdomain unknowns. Use the chain rule for $a_{i\\pm\\frac{1}{2}}(u)$, where\n$$\n\\frac{\\partial a_{i+\\frac{1}{2}}}{\\partial u_i} = \\frac{u_i+u_{i+1}}{2}, \\quad \\frac{\\partial a_{i+\\frac{1}{2}}}{\\partial u_{i+1}} = \\frac{u_i+u_{i+1}}{2}, \\quad\n\\frac{\\partial a_{i-\\frac{1}{2}}}{\\partial u_i} = \\frac{u_{i-1}+u_{i}}{2}, \\quad \\frac{\\partial a_{i-\\frac{1}{2}}}{\\partial u_{i-1}} = \\frac{u_{i-1}+u_{i}}{2}.\n$$\nEnsure that the local Jacobian accounts only for derivatives with respect to the subdomain’s interior unknowns; treat boundary values as constants.\n\nTest Suite:\nProvide the program outputs for the following four test cases, where each test case is a tuple $(N, p, \\alpha, f\\_type, A, \\kappa, B)$ with the following semantics:\n- $N$: number of interior points.\n- $p$: overlap size in grid points.\n- $\\alpha$: ASPIN damping parameter.\n- $f\\_type$: a string, either \"constant\" or \"sine\".\n- $A$: source amplitude in $f(x)$.\n- $\\kappa$: integer wavenumber for the sine source (ignored for \"constant\").\n- $B$: initial amplitude for $u^{(0)}$ in $u^{(0)}_i = B \\sin(\\pi x_i)$; if $B=0$, use the zero initial guess.\n\nUse these test cases:\n- Case 1: $(N=63, p=5, \\alpha=1.0, f\\_type=\\text{\"constant\"}, A=1.0, \\kappa=1, B=0.0)$\n- Case 2: $(N=63, p=1, \\alpha=1.0, f\\_type=\\text{\"constant\"}, A=1.0, \\kappa=1, B=0.0)$\n- Case 3: $(N=63, p=5, \\alpha=0.5, f\\_type=\\text{\"sine\"}, A=1.0, \\kappa=2, B=0.0)$\n- Case 4: $(N=31, p=3, \\alpha=1.0, f\\_type=\\text{\"sine\"}, A=0.5, \\kappa=3, B=0.1)$\n\nFinal Output Format:\nYour program should produce a single line of output containing the four decreases $\\Delta$ as a comma-separated list enclosed in square brackets (for example, \"[d1,d2,d3,d4]\"). All values must be represented as floating-point numbers. No physical units are used in this problem. Angles do not appear in this problem, so no angle unit is required. Percentages are not used in this problem. The output must be deterministic and must not require any user input.", "solution": "The solution is implemented by following the algorithmic steps described in the problem statement.\n\n1.  **Global Setup**: For each test case, the grid parameters ($N$, $h$), the source vector $f$, and the initial guess $u^{(0)}$ are initialized. The grid consists of $N$ interior points, with mesh size $h=1/(N+1)$.\n\n2.  **Initial Residual**: The initial global residual vector $F(u^{(0)})$ is computed using the provided conservative finite-volume discretization formula. The Euclidean norm $\\|F(u^{(0)})\\|_2$ is calculated and stored. This requires evaluating the nonlinear diffusion coefficient $a_{i\\pm1/2}(u)$ at the faces of each control volume.\n\n3.  **Domain Decomposition**: The global domain of $N$ grid points is partitioned into two overlapping subdomains, $\\Omega_1$ and $\\Omega_2$, based on the number of grid points $N$ and the specified overlap size $p$.\n\n4.  **Local Nonlinear Solves**: On each subdomain $\\Omega_k$, an independent nonlinear boundary value problem is solved using Newton's method.\n    *   The local problem for $\\Omega_k$ consists of the residual equations $F_i(v)=0$ for all indices $i \\in \\Omega_k$.\n    *   Dirichlet boundary conditions are imposed at the subdomain boundaries using values from the global iterate $u^{(0)}$.\n    *   **Newton's Method**: The local system is solved iteratively. In each Newton step, we solve the linear system $J_k \\delta v = -F_k(v)$ for the update $\\delta v$.\n        *   **Jacobian Matrix $J_k$**: The Jacobian of the local residual $F_k$ is a tridiagonal matrix. Its entries are derived by differentiating the discrete residual formula with respect to the local unknowns.\n        *   **Line Search**: After computing the Newton update $\\delta v$, a backtracking line search is employed to find a step length $\\lambda$ that satisfies the Armijo condition, ensuring a sufficient decrease in the local residual norm. The update is then $v \\leftarrow v + \\lambda \\delta v$.\n    *   The Newton iteration is continued until the norm of the local residual falls below a specified tolerance, yielding the local solutions $G_k(u^{(0)})$.\n\n5.  **Correction Assembly**: The local corrections $c_k = G_k(u^{(0)}) - u^{(0)}|_{\\Omega_k}$ are computed. These are then combined to form a global correction vector $c$. In the non-overlapping parts of the subdomains, the correction is taken directly from the corresponding subdomain. In the overlapping region, the corrections from both subdomains are averaged.\n\n6.  **ASPIN Update**: The global solution is updated using the assembled correction and the damping parameter $\\alpha$:\n    $$u^{(1)} = u^{(0)} + \\alpha c$$\n\n7.  **Final Residual and Result**: The final residual vector $F(u^{(1)})$ and its norm $\\|F(u^{(1)})\\|_2$ are computed. The final result for the test case is the decrease in the residual norm, $\\Delta = \\|F(u^{(0)})\\|_2 - \\|F(u^{(1)})\\|_2$.\n\nBelow is a reference implementation in Python that carries out these steps.\n\n```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Implements a single Additive Schwarz Preconditioned Inexact Newton (ASPIN)\n    iteration for a 1D nonlinear diffusion problem and computes the\n    decrease in the residual norm for a given set of test cases.\n    \"\"\"\n\n    def _calculate_residual(u, f_sub, h, bc_left=0.0, bc_right=0.0):\n        \"\"\"Calculates the nonlinear residual vector for a given solution u.\"\"\"\n        n = len(u)\n        if n == 0:\n            return np.array([])\n        \n        u_padded = np.concatenate(([bc_left], u, [bc_right]))\n        \n        u_m = u_padded[:-2]\n        u_c = u_padded[1:-1]\n        u_p = u_padded[2:]\n\n        a_iph = 1.0 + ((u_c + u_p) / 2.0)**2\n        a_imh = 1.0 + ((u_m + u_c) / 2.0)**2\n\n        flux_p = a_iph * (u_p - u_c)\n        flux_m = a_imh * (u_c - u_m)\n\n        res = (flux_p - flux_m) / h**2 - f_sub\n        return res\n\n    def _calculate_jacobian_banded(u, h, bc_left=0.0, bc_right=0.0):\n        \"\"\"Calculates the tridiagonal Jacobian matrix in banded format.\"\"\"\n        n = len(u)\n        if n == 0:\n            return np.zeros((3, 0))\n\n        u_padded = np.concatenate(([bc_left], u, [bc_right]))\n        \n        u_m = u_padded[:-2]\n        u_c = u_padded[1:-1]\n        u_p = u_padded[2:]\n\n        a_iph = 1.0 + ((u_c + u_p) / 2.0)**2\n        a_imh = 1.0 + ((u_m + u_c) / 2.0)**2\n\n        term_p = (u_c + u_p) / 2.0 * (u_p - u_c)\n        term_m = (u_m + u_c) / 2.0 * (u_c - u_m)\n\n        # Main diagonal\n        main_diag = (term_p - a_iph - term_m - a_imh) / h**2\n        \n        # Upper diagonal\n        upper_diag = (term_p + a_iph) / h**2\n        \n        # Lower diagonal\n        lower_diag = (a_imh - term_m) / h**2\n\n        ab = np.zeros((3, n))\n        ab[0, 1:] = upper_diag[:-1]\n        ab[1, :] = main_diag\n        ab[2, :-1] = lower_diag[1:]\n        \n        return ab\n\n    def _solve_local_newton(u_initial, f_sub, h, bc_left, bc_right,\n                            max_iter=30, tol=1e-10):\n        \"\"\"Solves the local nonlinear problem using Newton's method.\"\"\"\n        v = u_initial.copy()\n        gamma = 1e-4  # Armijo condition constant\n        tau = 0.5     # Backtracking step reduction factor\n        \n        for _ in range(max_iter):\n            res_v = _calculate_residual(v, f_sub, h, bc_left, bc_right)\n            norm_res_v = np.linalg.norm(res_v)\n            \n            if norm_res_v  tol:\n                break\n\n            J_banded = _calculate_jacobian_banded(v, h, bc_left, bc_right)\n            \n            try:\n                # Solve the linear system J * dv = -F\n                delta_v = solve_banded((1, 1), J_banded, -res_v)\n            except np.linalg.LinAlgError:\n                # Failsafe for singular Jacobian\n                break\n\n            # Backtracking line search\n            lmbda = 1.0\n            v_new = v + lmbda * delta_v\n            res_v_new = _calculate_residual(v_new, f_sub, h, bc_left, bc_right)\n            norm_res_v_new = np.linalg.norm(res_v_new)\n\n            while norm_res_v_new > (1 - gamma * lmbda) * norm_res_v:\n                lmbda *= tau\n                if lmbda  1e-8: # Failsafe for line search\n                    v_new = v # No update\n                    norm_res_v_new = norm_res_v\n                    break\n                v_new = v + lmbda * delta_v\n                res_v_new = _calculate_residual(v_new, f_sub, h, bc_left, bc_right)\n                norm_res_v_new = np.linalg.norm(res_v_new)\n            \n            v = v_new\n        \n        return v\n\n    def run_aspin_iteration(N, p, alpha, f_type, A, kappa, B):\n        \"\"\"Performs one full ASPIN iteration for a given test case.\"\"\"\n        # 1. Setup grid, initial guess, and source term\n        h = 1.0 / (N + 1)\n        x = np.linspace(h, 1.0 - h, N)\n\n        if f_type == \"constant\":\n            f_vec = np.full(N, A)\n        else: # \"sine\"\n            f_vec = A * np.sin(kappa * np.pi * x)\n\n        if B == 0.0:\n            u0 = np.zeros(N)\n        else:\n            u0 = B * np.sin(np.pi * x)\n\n        # 2. Calculate initial residual norm\n        res0 = _calculate_residual(u0, f_vec, h)\n        res0_norm = np.linalg.norm(res0)\n\n        # 3. Define subdomains (0-based indexing)\n        m = N // 2\n        \n        # 4. Solve local nonlinear problems\n        # Subdomain 1\n        idx1_start, idx1_end = 0, m + p\n        u0_sub1 = u0[idx1_start:idx1_end]\n        f_sub1 = f_vec[idx1_start:idx1_end]\n        bc_left1 = 0.0\n        bc_right1 = u0[idx1_end] if idx1_end  N else 0.0\n        v1 = _solve_local_newton(u0_sub1, f_sub1, h, bc_left1, bc_right1)\n\n        # Subdomain 2\n        idx2_start, idx2_end = m - p, N\n        u0_sub2 = u0[idx2_start:idx2_end]\n        f_sub2 = f_vec[idx2_start:idx2_end]\n        bc_left2 = u0[idx2_start - 1] if idx2_start > 0 else 0.0\n        bc_right2 = 0.0\n        v2 = _solve_local_newton(u0_sub2, f_sub2, h, bc_left2, bc_right2)\n\n        # 5. Assemble global correction vector\n        c1 = v1 - u0_sub1\n        c2 = v2 - u0_sub2\n        c = np.zeros(N)\n        \n        overlap_size = 2*p\n        \n        # Part 1: Omega1 exclusive\n        c[0 : m-p] = c1[0 : m-p]\n        # Part 2: Overlap\n        c[m-p : m+p] = 0.5 * (c1[m-p : m+p] + c2[0 : overlap_size])\n        # Part 3: Omega2 exclusive\n        c[m+p : N] = c2[overlap_size:]\n\n        # 6. Apply ASPIN update\n        u1 = u0 + alpha * c\n\n        # 7. Calculate final residual and norm decrease\n        res1 = _calculate_residual(u1, f_vec, h)\n        res1_norm = np.linalg.norm(res1)\n        \n        delta = res0_norm - res1_norm\n        return delta\n\n    test_cases = [\n        (63, 5, 1.0, \"constant\", 1.0, 1, 0.0),\n        (63, 1, 1.0, \"constant\", 1.0, 1, 0.0),\n        (63, 5, 0.5, \"sine\", 1.0, 2, 0.0),\n        (31, 3, 1.0, \"sine\", 0.5, 3, 0.1),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, p, alpha, f_type, A, kappa, B = case\n        delta = run_aspin_iteration(N, p, alpha, f_type, A, kappa, B)\n        results.append(delta)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# To generate the answer, one would run the solve() function.\n# solve()\n```", "answer": "[37.74900713783707,35.6322071987395,14.619077873177777,2.83984105072049]", "id": "3519591"}]}