{"hands_on_practices": [{"introduction": "The accuracy of spectral methods hinges on the precise correspondence between continuous integrals, such as those defining energy norms, and their discrete quadrature approximations. This practice solidifies this fundamental concept by guiding you through an analytical calculation of the energy of a Chebyshev polynomial, $T_m(x)$, and the conditions under which its discrete counterpart is exact. Mastering this relationship is essential for understanding how spectral methods achieve their characteristic high-order accuracy [@problem_id:3300679].", "problem": "In computational fluid dynamics (CFD) on bounded domains, Chebyshev-spectral methods often represent fields in terms of Chebyshev polynomials and measure solution energy by the square of the standard $L^{2}$ norm. Consider the one-dimensional bounded domain $[-1,1]$, and define the continuous energy of a scalar field $u$ by\n$$\nE \\equiv \\|u\\|^{2} = \\int_{-1}^{1} |u(x)|^{2} \\, dx.\n$$\nIn practical spectral collocation, a quadrature-based discrete energy is used. Let the Chebyshev-Gauss-Lobatto (CGL) nodes be $x_{j} = \\cos\\!\\left(\\frac{j\\pi}{N}\\right)$ for $j=0,1,\\dots,N$, and let $\\{w_{j}\\}_{j=0}^{N}$ be the Clenshaw-Curtis (CC) quadrature weights for approximating the unweighted integral $\\int_{-1}^{1} f(x)\\,dx$ via\n$$\nQ_{N}(f) \\equiv \\sum_{j=0}^{N} w_{j}\\, f(x_{j}).\n$$\nDefine the quadrature-based discrete energy by\n$$\nE_{N} \\equiv \\sum_{j=0}^{N} w_{j}\\, |u(x_{j})|^{2}.\n$$\n\nStarting from the definitions of the Chebyshev polynomials of the first kind $T_{m}(x) = \\cos\\!\\left(m\\arccos x\\right)$, the change of variables $x=\\cos\\theta$ that maps $[-1,1]$ to $[0,\\pi]$ with $dx=-\\sin\\theta\\, d\\theta$, and the fundamental orthogonality of trigonometric functions on $[0,\\pi]$, do the following:\n\n1. For $u(x) = T_{m}(x)$ with a fixed integer $m \\ge 1$, compute the exact continuous energy $E$.\n\n2. Using only the structure of Chebyshev expansions and the fact that the Clenshaw-Curtis quadrature with $N+1$ CGL nodes is exact for any algebraic polynomial of degree at most $N$, determine a condition on $N$ (in terms of $m$) under which $E_{N} = E$ for this $u$.\n\n3. Under the condition you found in part 2, provide the common value of $E_{N}$ and $E$ as a single closed-form expression in $m$.\n\nYour final answer must be the closed-form expression from part 3. No units are required. Do not round; provide an exact expression.", "solution": "The problem is valid as it is scientifically grounded in the well-established theory of spectral methods and numerical quadrature, is well-posed with all necessary information provided, and is stated objectively. We can proceed with a formal solution.\n\nThe problem asks for three components: the exact continuous energy $E$ for a specific field $u(x)$, the condition on the number of quadrature points $N+1$ for the discrete energy $E_N$ to equal $E$, and the resulting common value.\n\nFirst, we compute the exact continuous energy $E$ for the scalar field $u(x) = T_{m}(x)$, where $T_m(x)$ is the Chebyshev polynomial of the first kind of degree $m$, and $m$ is a fixed integer with $m \\ge 1$. The continuous energy is defined as:\n$$\nE = \\int_{-1}^{1} |u(x)|^{2} \\, dx = \\int_{-1}^{1} (T_{m}(x))^{2} \\, dx\n$$\nSince $x \\in [-1,1]$, $T_m(x)$ is real-valued, and thus $|T_m(x)|^2 = (T_m(x))^2$.\n\nTo evaluate this integral, we can express the integrand, $(T_m(x))^2$, as a linear combination of Chebyshev polynomials. Using the definition $T_m(x) = \\cos(m\\arccos x)$, we can make the substitution $x = \\cos\\theta$. This gives $T_m(\\cos\\theta) = \\cos(m\\theta)$. The integrand becomes:\n$$\n(T_m(x))^2 \\to (\\cos(m\\theta))^2\n$$\nUsing the trigonometric identity $\\cos^2\\alpha = \\frac{1}{2}(1 + \\cos(2\\alpha))$, we have:\n$$\n(\\cos(m\\theta))^2 = \\frac{1}{2} (1 + \\cos(2m\\theta))\n$$\nRecognizing that $1 = T_0(x)$ and $\\cos(2m\\theta) = T_{2m}(\\cos\\theta) = T_{2m}(x)$, we can write the expansion for $(T_m(x))^2$ in the Chebyshev basis:\n$$\n(T_m(x))^2 = \\frac{1}{2} T_0(x) + \\frac{1}{2} T_{2m}(x)\n$$\nNow we can substitute this back into the integral for $E$:\n$$\nE = \\int_{-1}^{1} \\left( \\frac{1}{2} T_0(x) + \\frac{1}{2} T_{2m}(x) \\right) dx = \\frac{1}{2} \\int_{-1}^{1} T_0(x) \\, dx + \\frac{1}{2} \\int_{-1}^{1} T_{2m}(x) \\, dx\n$$\nWe evaluate each integral separately. For the first integral:\n$$\n\\int_{-1}^{1} T_0(x) \\, dx = \\int_{-1}^{1} 1 \\, dx = [x]_{-1}^{1} = 1 - (-1) = 2\n$$\nFor the second integral, we evaluate the general case $\\int_{-1}^{1} T_k(x) \\, dx$ for an integer $k > 0$. Using the substitution $x = \\cos\\theta$, for which $dx = -\\sin\\theta \\, d\\theta$:\n$$\n\\int_{-1}^{1} T_k(x) \\, dx = \\int_{\\pi}^{0} T_k(\\cos\\theta) (-\\sin\\theta) \\, d\\theta = \\int_{0}^{\\pi} \\cos(k\\theta) \\sin\\theta \\, d\\theta\n$$\nUsing the product-to-sum identity $\\cos A \\sin B = \\frac{1}{2}(\\sin(A+B) - \\sin(A-B))$:\n$$\n\\int_{0}^{\\pi} \\cos(k\\theta) \\sin\\theta \\, d\\theta = \\frac{1}{2} \\int_{0}^{\\pi} \\left( \\sin((k+1)\\theta) - \\sin((k-1)\\theta) \\right) d\\theta\n$$\nFor an integer $n \\neq 0$, $\\int_0^\\pi \\sin(n\\theta) d\\theta = \\left[-\\frac{\\cos(n\\theta)}{n}\\right]_0^\\pi = \\frac{1 - \\cos(n\\pi)}{n} = \\frac{1 - (-1)^n}{n}$.\nIf $k$ is an odd integer greater than $1$, both $k+1$ and $k-1$ are non-zero even integers. In this case, $1 - (-1)^{k+1} = 0$ and $1 - (-1)^{k-1} = 0$, so the integral is $0$. If $k=1$, the integral is $\\frac{1}{2}\\int_0^\\pi \\sin(2\\theta) d\\theta = 0$. So for any odd $k \\ge 1$, the integral is $0$.\nIf $k$ is an even integer ($k \\ge 2$), both $k+1$ and $k-1$ are odd. Thus $1 - (-1)^{k+1} = 2$ and $1 - (-1)^{k-1} = 2$. The integral becomes:\n$$\n\\frac{1}{2} \\left( \\frac{2}{k+1} - \\frac{2}{k-1} \\right) = \\frac{1}{k+1} - \\frac{1}{k-1} = \\frac{(k-1) - (k+1)}{(k+1)(k-1)} = \\frac{-2}{k^2-1}\n$$\nIn our case, we need to evaluate the integral for $k = 2m$. Since $m \\ge 1$, $k=2m$ is an even integer greater than or equal to $2$. Therefore:\n$$\n\\int_{-1}^{1} T_{2m}(x) \\, dx = \\frac{-2}{(2m)^2 - 1} = \\frac{-2}{4m^2 - 1}\n$$\nSubstituting the values of the integrals back into the expression for $E$:\n$$\nE = \\frac{1}{2}(2) + \\frac{1}{2} \\left( \\frac{-2}{4m^2 - 1} \\right) = 1 - \\frac{1}{4m^2 - 1} = \\frac{(4m^2 - 1) - 1}{4m^2 - 1} = \\frac{4m^2 - 2}{4m^2 - 1}\n$$\nThis completes the first part of the problem.\n\nSecond, we determine the condition on $N$ under which the discrete energy $E_N$ equals the continuous energy $E$. The discrete energy $E_N$ is defined by the Clenshaw-Curtis quadrature rule applied to the function $|u(x)|^2$:\n$$\nE_{N} \\equiv \\sum_{j=0}^{N} w_{j}\\, |u(x_{j})|^{2} = Q_N(|u|^2)\n$$\nThe equality $E_N = E$ is equivalent to the statement that the quadrature rule is exact for the integrand, i.e.,\n$$\nQ_N(|u|^2) = \\int_{-1}^{1} |u(x)|^{2} \\, dx\n$$\nThe integrand is $f(x) = |u(x)|^2 = (T_m(x))^2$. As shown earlier, $(T_m(x))^2 = \\frac{1}{2}T_0(x) + \\frac{1}{2}T_{2m}(x)$. Since $T_k(x)$ is an algebraic polynomial of degree $k$, the integrand is an algebraic polynomial of degree $2m$. The problem states that the Clenshaw-Curtis quadrature with $N+1$ nodes is exact for any algebraic polynomial of degree at most $N$. For the quadrature to be exact for our integrand, the degree of the integrand must be less than or equal to the maximum degree for which the rule is exact. This gives the condition:\n$$\n\\text{degree}((T_m(x))^2) \\le N\n$$\nSince $\\text{degree}((T_m(x))^2) = 2m$, the condition on $N$ is:\n$$\n2m \\le N\n$$\n\nThird, under the condition $N \\ge 2m$, we have $E_N = E$. The question asks for this common value. This is precisely the value of $E$ we computed in the first part. The closed-form expression for this energy, valid for any integer $m \\ge 1$, is:\n$$\nE = E_N = \\frac{4m^2 - 2}{4m^2 - 1}\n$$\nThis is the final required expression.", "answer": "$$\\boxed{\\frac{4m^{2}-2}{4m^{2}-1}}$$", "id": "3300679"}, {"introduction": "A crucial step in applying spectral methods is translating a continuous boundary value problem into a well-posed discrete linear system. This exercise tackles the classic Poisson equation with Neumann boundary conditions, whose solution is only unique up to a constant, leading to a singular discrete operator [@problem_id:3300690]. You will implement and compare two standard techniques for resolving this rank deficiency, gaining hands-on experience in building robust solvers for problems with inherent compatibility constraints.", "problem": "Consider the one-dimensional Poisson equation with homogeneous Neumann boundary conditions on the bounded domain $[-1,1]$,\n$$\n\\frac{d^2 u}{dx^2} = f(x), \\quad x \\in [-1,1], \\quad \\text{with} \\quad \\frac{du}{dx}(-1) = 0, \\quad \\frac{du}{dx}(1) = 0.\n$$\nIn Chebyshev-spectral collocation, use the Chebyshev–Gauss–Lobatto nodes $x_j = \\cos\\left(\\frac{\\pi j}{N}\\right)$ for $j=0,1,\\dots,N$ and the standard Chebyshev first and second differentiation matrices built on these nodes. Construct the collocation linear system as follows: enforce the second derivative relation at the interior points $j=1,\\dots,N-1$ and enforce the Neumann boundary conditions at the endpoints by replacing the first and last rows of the operator with the first-derivative rows evaluated at the endpoints. This yields a square linear system\n$$\nA \\, u = b,\n$$\nwhere $A \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ is formed from the first and second Chebyshev differentiation matrices and $b \\in \\mathbb{R}^{N+1}$ contains the samples $f(x_j)$ at the interior points and zeros at the boundaries corresponding to the homogeneous Neumann boundary conditions. Because of the Neumann boundary conditions, the operator $A$ is rank-deficient with a one-dimensional nullspace spanned by the constant vector; thus, the system is solvable only if $b$ belongs to the range of $A$ and the solution is unique only up to an additive constant.\n\nYour task is to implement two solvers for this system and compare their outputs:\n- A low-rank augmented solver that resolves the rank deficiency by adding a single linear constraint to fix the additive constant. Specifically, augment the system with the constraint $\\sum_{j=0}^{N} u_j = 0$ using a Lagrange multiplier, forming the block system\n$$\n\\begin{pmatrix}\nA & w \\\\\nw^\\top & 0\n\\end{pmatrix}\n\\begin{pmatrix}\nu \\\\\n\\lambda\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nb \\\\\n0\n\\end{pmatrix},\n$$\nwhere $w \\in \\mathbb{R}^{N+1}$ is the vector of all ones and $\\lambda \\in \\mathbb{R}$ is the Lagrange multiplier.\n- A Singular Value Decomposition (SVD) based solver. Compute the singular value decomposition $A = U \\Sigma V^\\top$, project $b$ onto the range of $A$ by removing its component along the left-nullspace vector associated with the smallest singular value, and then compute the minimum-norm solution using the Moore–Penrose pseudoinverse:\n$$\nb_{\\text{proj}} = b - u_0 \\left(u_0^\\top b\\right), \\quad u_{\\text{svd}} = \\sum_{i:\\sigma_i > \\varepsilon} \\frac{U_{\\cdot i}^\\top b_{\\text{proj}}}{\\sigma_i} V_{\\cdot i},\n$$\nwhere $u_0$ is the left singular vector corresponding to the smallest singular value $\\sigma_{\\min}$, $\\varepsilon$ is a small threshold, and $U_{\\cdot i}$, $V_{\\cdot i}$ denote the $i$-th columns of $U$ and $V$.\n\nStart from well-tested definitions in Chebyshev-spectral methods: Chebyshev–Gauss–Lobatto nodes, and the known formulas for first and second differentiation matrices on these nodes. Do not use shortcut formulas for the final solutions; derive the collocation system and explain the reasoning for handling rank deficiency. Before solving, ensure solvability by projecting $b$ onto the range of $A$ with respect to the discrete left-nullspace vector obtained from SVD, as in the formula above.\n\nImplement both solvers and compute the following quantities for each test case:\n- The infinity norm of the difference between the two computed solutions, namely $\\|u_{\\text{aug}} - u_{\\text{svd}}\\|_{\\infty}$.\n- The infinity norm of the collocation residual for the SVD-based solution, namely $\\|A u_{\\text{svd}} - b_{\\text{proj}}\\|_{\\infty}$.\n- The maximum absolute boundary derivative residual for the SVD-based solution, namely $\\max\\left\\{\\left|\\left(D^{(1)}_{\\text{row }0}\\right) u_{\\text{svd}}\\right|, \\left|\\left(D^{(1)}_{\\text{row }N}\\right) u_{\\text{svd}}\\right|\\right\\}$, where $D^{(1)}$ is the first Chebyshev differentiation matrix and $D^{(1)}_{\\text{row }0}$ and $D^{(1)}_{\\text{row }N}$ denote its first and last rows.\n\nUse the following test suite, specifying $N$ and $f(x)$ for each case. All trigonometric functions must use radians.\n- Case 1: $N = 32$, $f(x) = \\cos(\\pi x)$.\n- Case 2: $N = 33$, $f(x) = x$.\n- Case 3: $N = 40$, $f(x) = 1$.\n- Case 4: $N = 8$, $f(x) = e^{x}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain the three floats for each test case in order, rounded to eight significant digits: $[\\|u_{\\text{aug}} - u_{\\text{svd}}\\|_{\\infty}^{(1)}, \\|A u_{\\text{svd}} - b_{\\text{proj}}\\|_{\\infty}^{(1)}, \\text{BC}^{(1)}, \\|u_{\\text{aug}} - u_{\\text{svd}}\\|_{\\infty}^{(2)}, \\|A u_{\\text{svd}} - b_{\\text{proj}}\\|_{\\infty}^{(2)}, \\text{BC}^{(2)}, \\|u_{\\text{aug}} - u_{\\text{svd}}\\|_{\\infty}^{(3)}, \\|A u_{\\text{svd}} - b_{\\text{proj}}\\|_{\\infty}^{(3)}, \\text{BC}^{(3)}, \\|u_{\\text{aug}} - u_{\\text{svd}}\\|_{\\infty}^{(4)}, \\|A u_{\\text{svd}} - b_{\\text{proj}}\\|_{\\infty}^{(4)}, \\text{BC}^{(4)}]$, where the superscript denotes the test case index and $\\text{BC}^{(k)}$ is the boundary derivative residual for case $k$.", "solution": "The user wants to solve a singular boundary value problem and compare two numerical methods for handling the rank-deficient linear system that arises from spectral collocation.\n\n### Step 1: Problem Validation\n\n#### Givens Extraction\n- **Equation**: One-dimensional Poisson equation $\\frac{d^2 u}{dx^2} = f(x)$ on the domain $x \\in [-1,1]$.\n- **Boundary Conditions**: Homogeneous Neumann conditions: $\\frac{du}{dx}(-1) = 0$ and $\\frac{du}{dx}(1) = 0$.\n- **Discretization**: Chebyshev-spectral collocation method.\n- **Nodes**: Chebyshev–Gauss–Lobatto nodes $x_j = \\cos\\left(\\frac{\\pi j}{N}\\right)$ for $j=0,1,\\dots,N$.\n- **Linear System Construction**:\n    - The linear operator matrix $A \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ is assembled by:\n        1. Using the second Chebyshev differentiation matrix rows for interior points $j=1,\\dots,N-1$.\n        2. Using the first Chebyshev differentiation matrix rows for the endpoints $j=0$ (at $x=1$) and $j=N$ (at $x=-1$) to enforce the Neumann conditions.\n    - The right-hand side vector $b \\in \\mathbb{R}^{(N+1)}$ is assembled by:\n        1. Setting $b_j = f(x_j)$ for interior points $j=1,\\dots,N-1$.\n        2. Setting $b_0=0$ and $b_N=0$ for the homogeneous boundary conditions.\n- **Rank Deficiency**: The resulting matrix $A$ is rank-deficient with a nullspace spanned by the constant vector. A solution exists only if $b$ is in the range of $A$. The solution is unique only up to an additive constant.\n- **Solvability Enforcement**: Before solving, $b$ must be projected onto the range of $A$: $b_{\\text{proj}} = b - u_0 \\left(u_0^\\top b\\right)$, where $u_0$ is the left singular vector of $A$ corresponding to the smallest singular value.\n- **Solver 1 (Augmented System)**: The rank deficiency is resolved by augmenting the system with the constraint $\\sum_{j=0}^{N} u_j = 0$ via a Lagrange multiplier $\\lambda$, forming the block system:\n$$\n\\begin{pmatrix} A & w \\\\ w^\\top & 0 \\end{pmatrix} \\begin{pmatrix} u \\\\ \\lambda \\end{pmatrix} = \\begin{pmatrix} b \\\\ 0 \\end{pmatrix}\n$$\nwhere $w$ is a vector of all ones.\n- **Solver 2 (SVD)**: The minimum-norm solution is computed using the Moore-Penrose pseudoinverse, constructed via SVD:\n$$\nu_{\\text{svd}} = \\sum_{i:\\sigma_i > \\varepsilon} \\frac{U_{\\cdot i}^\\top b_{\\text{proj}}}{\\sigma_i} V_{\\cdot i}\n$$\nwhere $A = U \\Sigma V^\\top$ is the SVD of $A$, and $\\varepsilon$ is a small threshold.\n- **Metrics to Compute**: For each test case, calculate:\n    1.  $\\|u_{\\text{aug}} - u_{\\text{svd}}\\|_{\\infty}$\n    2.  $\\|A u_{\\text{svd}} - b_{\\text{proj}}\\|_{\\infty}$\n    3.  $\\max\\left\\{\\left|\\left(D^{(1)}_{\\text{row }0}\\right) u_{\\text{svd}}\\right|, \\left|\\left(D^{(1)}_{\\text{row }N}\\right) u_{\\text{svd}}\\right|\\right\\}$\n- **Test Cases**:\n    - Case 1: $N = 32$, $f(x) = \\cos(\\pi x)$.\n    - Case 2: $N = 33$, $f(x) = x$.\n    - Case 3: $N = 40$, $f(x) = 1$.\n    - Case 4: $N = 8$, $f(x) = e^x$.\n\n#### Validation using Extracted Givens\n\n1.  **Scientific or Factual Unsoundness**: The problem is scientifically sound. It describes a standard formulation of the Poisson equation with Neumann boundary conditions, a fundamental problem in physics and engineering. The numerical method proposed, Chebyshev spectral collocation, is a well-established and powerful technique for solving differential equations. The discussion of rank deficiency and solvability conditions is mathematically correct.\n2.  **Non-Formalizable or Irrelevant**: The problem is directly related to the topic of Chebyshev-spectral methods and is presented in a formal, mathematical language that is readily translatable into an algorithm.\n3.  **Incomplete or Contradictory Setup**: The problem is self-contained. It specifies the differential equation, boundary conditions, domain, discretization nodes, and the precise construction of the linear system, including how to handle the boundary conditions and the inherent rank deficiency. While the problem statement could be interpreted as applying the projection of $b$ only to the SVD solver, a more consistent interpretation, which we adopt, is that the system must be made solvable before *any* solution attempt. Thus, we use the projected right-hand side, $b_{\\text{proj}}$, for both solvers.\n4.  **Unrealistic or Infeasible**: The problem is entirely realistic. The parameters and functions are standard for testing numerical methods.\n5.  **Ill-Posed or Poorly Structured**: The original boundary value problem is ill-posed (solution is not unique). However, the problem explicitly acknowledges this and provides two standard, well-defined methods for obtaining a unique solution (fixing the average value or finding the minimum norm solution). The problem is therefore well-structured.\n6.  **Pseudo-Profound, Trivial, or Tautological**: The problem is non-trivial. It requires an understanding of spectral methods, linear algebra (specifically SVD and rank-deficient systems), and numerical implementation. It tests deep concepts in numerical analysis.\n7.  **Outside Scientific Verifiability**: The results are numerically verifiable. An implementation following the specifications will produce results that can be checked for correctness.\n\n#### Verdict and Action\nThe problem is **valid**. It is a well-defined exercise in numerical analysis and scientific computing. I will now proceed to provide a complete, reasoned solution.\n\n### Solution\n\nThe problem requires solving the one-dimensional Poisson equation with homogeneous Neumann boundary conditions, $\\frac{d^2 u}{d x^2} = f(x)$ with $u'(\\pm 1) = 0$, using a Chebyshev spectral collocation method. This boundary value problem is singular: if $u(x)$ is a solution, so is $u(x) + C$ for any constant $C$. Furthermore, a solution exists only if the forcing term $f(x)$ satisfies the compatibility condition $\\int_{-1}^1 f(x) dx = u'(1) - u'(-1) = 0$.\n\n#### 1. Chebyshev Spectral Discretization\nWe discretize the domain $[-1,1]$ using the $N+1$ Chebyshev-Gauss-Lobatto (CGL) nodes, $x_j = \\cos(\\frac{\\pi j}{N})$ for $j=0, 1, \\dots, N$. The values of the unknown function $u(x)$ are approximated at these nodes, $u_j \\approx u(x_j)$. Derivatives are approximated by matrix-vector products, $u' \\approx D^{(1)}u$ and $u'' \\approx D^{(2)}u$, where $D^{(1)}$ and $D^{(2)}$ are the Chebyshev first and second differentiation matrices. $D^{(2)}$ can be computed as $(D^{(1)})^2$. The entries of the first differentiation matrix $D^{(1)}$ are given by well-known formulas:\n$$\n(D^{(1)})_{ij} = \\begin{cases}\n\\frac{c_i}{c_j} \\frac{(-1)^{i+j}}{x_i - x_j}, & i \\neq j \\\\\n\\frac{-x_j}{2(1-x_j^2)}, & j = 1, \\dots, N-1 \\\\\n\\frac{2N^2+1}{6}, & j=0 \\\\\n-\\frac{2N^2+1}{6}, & j=N\n\\end{cases}\n$$\nwhere $c_j=2$ for $j=0,N$ and $c_j=1$ otherwise.\n\n#### 2. Construction of the Linear System\nThe collocation method enforces the governing equations at the grid points. This leads to a linear system $Au=b$.\n- For the interior points ($j=1, \\dots, N-1$), we enforce the Poisson equation: $(D^{(2)}u)_j = f(x_j)$. These equations form rows $1$ through $N-1$ of the system.\n- For the boundary points, we enforce the Neumann conditions. At $x_0=1$, we enforce $u'(1)=0$, which discretizes to $(D^{(1)}u)_0 = 0$. At $x_N=-1$, we enforce $u'(-1)=0$, which discretizes to $(D^{(1)}u)_N = 0$. These equations form the first ($j=0$) and last ($j=N$) rows of the system.\n\nThe resulting matrix $A$ and vector $b$ are constructed as:\n- $A_{j,\\cdot} = D^{(2)}_{j,\\cdot}$ for $j=1, \\dots, N-1$.\n- $A_{0,\\cdot} = D^{(1)}_{0,\\cdot}$.\n- $A_{N,\\cdot} = D^{(1)}_{N,\\cdot}$.\n- $b_j = f(x_j)$ for $j=1, \\dots, N-1$.\n- $b_0 = 0$ and $b_N = 0$.\n\n#### 3. Handling Rank Deficiency\nThe operator $A$ is singular. The constant vector $w=[1, 1, \\dots, 1]^\\top$ lies in its nullspace, since both $D^{(1)}$ and $D^{(2)}$ map constant functions to zero. This means $Aw=0$, and $A$ has rank $N$ at most. For the system $Au=b$ to have a solution, $b$ must be in the range of $A$, which means $b$ must be orthogonal to the left nullspace of $A$. We find the basis for the left nullspace by finding the left singular vector $u_0$ of $A$ corresponding to the singular value $\\sigma_{\\min} \\approx 0$.\nWe enforce the solvability condition by projecting $b$ onto the range of $A$:\n$$\nb_{\\text{proj}} = b - u_0 (u_0^\\top b)\n$$\nThis projected vector $b_{\\text{proj}}$ is orthogonal to $u_0$ and will be used as the right-hand side for both solvers to ensure a consistent and solvable system is being addressed.\n\n#### 4. Augmented System Solver\nTo obtain a unique solution, we add an extra constraint. The problem specifies the constraint $\\sum_{j=0}^N u_j=0$. We incorporate this into the system using a Lagrange multiplier $\\lambda$, which leads to the $(N+2) \\times (N+2)$ invertible block system:\n$$\n\\begin{pmatrix} A & w \\\\ w^\\top & 0 \\end{pmatrix} \\begin{pmatrix} u \\\\ \\lambda \\end{pmatrix} = \\begin{pmatrix} b_{\\text{proj}} \\\\ 0 \\end{pmatrix}\n$$\nSolving this system yields the unique solution $u_{\\text{aug}}$ that satisfies both the modified Poisson equation and the zero-sum constraint.\n\n#### 5. SVD-based Solver\nThis method computes the unique solution that has the minimum Euclidean norm $\\|u\\|_2$. This minimum-norm solution is orthogonal to the nullspace of $A$. Since $\\mathcal{N}(A) = \\text{span}(w)$, this means $w^\\top u = \\sum u_j = 0$. Thus, the SVD solver seeks a solution satisfying the same uniqueness constraint as the augmented solver.\nThe solution is computed via the Moore-Penrose pseudoinverse $A^+$ as $u_{\\text{svd}} = A^+ b_{\\text{proj}}$. Using the Singular Value Decomposition $A = U \\Sigma V^\\top$, the pseudoinverse solution is given by:\n$$\nu_{\\text{svd}} = V \\Sigma^+ U^\\top b_{\\text{proj}} = \\sum_{i:\\sigma_i > \\varepsilon} \\frac{U_{\\cdot i}^\\top b_{\\text{proj}}}{\\sigma_i} V_{\\cdot i}\n$$\nwhere $\\Sigma^+$ is the pseudoinverse of the diagonal matrix of singular values $\\Sigma$ (reciprocals are taken for non-zero singular values, and zero otherwise), and $\\varepsilon$ is a small threshold to numerically identify the zero singular value. Since both methods find the unique solution satisfying $\\sum u_j=0$, we expect $u_{\\text{aug}}$ and $u_{\\text{svd}}$ to be identical up to floating-point precision.\n\n#### 6. Calculation of Metrics\nThe implementation will carry out these steps for each test case and compute the three required metrics:\n1.  $\\|u_{\\text{aug}} - u_{\\text{svd}}\\|_{\\infty}$: The infinity norm of the difference between the solutions from the two methods. This should be close to machine precision.\n2.  $\\|A u_{\\text{svd}} - b_{\\text{proj}}\\|_{\\infty}$: The residual of the SVD solution. This measures how well the SVD solution satisfies the projected linear system.\n3.  $\\max(|\\langle D^{(1)}_{0,\\cdot}, u_{\\text{svd}} \\rangle|, |\\langle D^{(1)}_{N,\\cdot}, u_{\\text{svd}} \\rangle|)$: The maximum absolute value of the boundary derivatives for the computed SVD solution. This checks how well the Neumann boundary conditions are satisfied.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef chebyshev_diff_matrices(N):\n    \"\"\"\n    Computes Chebyshev-Gauss-Lobatto nodes and differentiation matrices D1, D2.\n    \n    Args:\n        N (int): The number of intervals, resulting in N+1 nodes.\n        \n    Returns:\n        tuple: A tuple (x, D1, D2) containing:\n            - x (ndarray): The N+1 Chebyshev-Gauss-Lobatto nodes.\n            - D1 (ndarray): The (N+1)x(N+1) first differentiation matrix.\n            - D2 (ndarray): The (N+1)x(N+1) second differentiation matrix.\n    \"\"\"\n    if N == 0:\n        return np.array([0.0]), np.array([[0.0]]), np.array([[0.0]])\n\n    j = np.arange(N + 1)\n    x = np.cos(np.pi * j / N)\n\n    # c_bar vector\n    c = np.ones(N + 1)\n    c[0] = 2.0\n    c[-1] = 2.0\n    \n    # Off-diagonal elements of D1\n    c_i = c.reshape(-1, 1)\n    c_j = c.reshape(1, -1)\n    \n    x_i = x.reshape(-1, 1)\n    x_j = x.reshape(1, -1)\n    \n    dX = x_i - x_j\n    np.fill_diagonal(dX, 1e-9) # Avoid division by zero on diagonal\n\n    # Sign matrix for (-1)^(i+j)\n    i_plus_j = np.add.outer(j, j)\n    sign_matrix = np.power(-1.0, i_plus_j)\n\n    D1 = (c_i / c_j) * sign_matrix / dX\n    \n    # Diagonal elements of D1\n    diag = np.zeros(N + 1)\n    diag[1:N] = -x[1:N] / (2.0 * (1.0 - x[1:N]**2))\n    diag[0] = (2.0 * N**2 + 1.0) / 6.0\n    diag[N] = -(2.0 * N**2 + 1.0) / 6.0\n    np.fill_diagonal(D1, diag)\n    \n    # Second derivative matrix\n    D2 = D1 @ D1\n    \n    return x, D1, D2\n\ndef solve_poisson_neumann(N, f_func):\n    \"\"\"\n    Solves the 1D Poisson equation with Neumann BCs using two methods.\n\n    Args:\n        N (int): Number of intervals for Chebyshev discretization.\n        f_func (callable): The forcing function f(x).\n\n    Returns:\n        tuple: A tuple containing the three requested metrics:\n               (diff_norm, resid_norm, bc_resid)\n    \"\"\"\n    # 1. Discretization and System Construction\n    x, D1, D2 = chebyshev_diff_matrices(N)\n    \n    A = D2.copy()\n    A[0, :] = D1[0, :]\n    A[N, :] = D1[N, :]\n    \n    b = np.zeros(N + 1)\n    fx = f_func(x)\n    b[1:N] = fx[1:N]\n\n    # 2. Handle Rank Deficiency: Project b\n    U, S, Vt = np.linalg.svd(A)\n    # The left null vector is the last column of U\n    u0 = U[:, -1]\n    b_proj = b - u0 * np.dot(u0, b)\n\n    # 3. Solver 1: Augmented System\n    M_size = N + 2\n    M = np.zeros((M_size, M_size))\n    w = np.ones(N + 1)\n    M[:N+1, :N+1] = A\n    M[:N+1, -1] = w\n    M[-1, :N+1] = w\n    \n    rhs_aug = np.zeros(M_size)\n    rhs_aug[:N+1] = b_proj\n    \n    sol_aug = np.linalg.solve(M, rhs_aug)\n    u_aug = sol_aug[:-1]\n\n    # 4. Solver 2: SVD-based (Moore-Penrose Pseudoinverse)\n    epsilon = 1e-14\n    \n    # Calculate u_svd = V @ Sigma_pinv @ U.T @ b_proj\n    c = U.T @ b_proj\n    c_mod = c / S\n    c_mod[S  epsilon] = 0.0 # Apply pseudoinverse\n    u_svd = Vt.T @ c_mod\n\n    # 5. Compute Metrics\n    # Metric 1: Infinity norm of the difference between solutions\n    diff_norm = np.linalg.norm(u_aug - u_svd, np.inf)\n\n    # Metric 2: Infinity norm of the collocation residual for SVD\n    resid_norm = np.linalg.norm(A @ u_svd - b_proj, np.inf)\n\n    # Metric 3: Maximum absolute boundary derivative residual for SVD\n    # Note: D1[0,:] is derivative at x=1 and D1[N,:] is at x=-1\n    bc_resid = np.max([np.abs(D1[0, :] @ u_svd), np.abs(D1[N, :] @ u_svd)])\n\n    return diff_norm, resid_norm, bc_resid\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        (32, lambda x: np.cos(np.pi * x)),\n        (33, lambda x: x),\n        (40, lambda x: np.ones_like(x)),\n        (8, lambda x: np.exp(x))\n    ]\n\n    results = []\n    for N, f_func in test_cases:\n        diff, resid, bc_res = solve_poisson_neumann(N, f_func)\n        results.extend([diff, resid, bc_res])\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.8g}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3300690"}, {"introduction": "For long-time simulations in computational fluid dynamics, a numerical scheme must not only be accurate but also respect the underlying conservation laws of the physics. This practice delves into this critical issue by examining the nonlinear advection term in the inviscid Burgers' equation, a valuable model for the Navier-Stokes equations [@problem_id:3300721]. By comparing the impact of different quadrature rules on a skew-symmetric discretization, you will discover how subtle algorithmic choices determine the stability and physical fidelity of a simulation.", "problem": "Consider the inviscid scalar conservation law on the bounded interval $[-1,1]$ with flux $f(u)=\\tfrac{1}{2}u^2$ (one-dimensional inviscid Burgers' equation in conservative form),\n$$\nu_t + \\partial_x \\left(\\tfrac{1}{2}u^2\\right)=0,\n$$\ntogether with homogeneous Dirichlet boundary data $u(-1,t)=0$ and $u(1,t)=0$. For a smooth solution $u(x,t)$, the kinetic energy $\\tfrac{1}{2}\\int_{-1}^{1} u(x,t)^2\\,dx$ obeys\n$$\n\\frac{d}{dt} \\left( \\frac{1}{2}\\int_{-1}^{1} u(x,t)^2\\,dx \\right) \\;=\\; \\int_{-1}^{1} u\\,u_t\\,dx \\;=\\; -\\int_{-1}^{1} u\\,\\partial_x\\left(\\tfrac{1}{2}u^2\\right)\\,dx \\;=\\; \\left.\\frac{1}{3}u^3\\right|_{x=-1}^{x=1}.\n$$\nThus, when $u(-1,t)=u(1,t)=0$, the continuous energy rate $\\tfrac{d}{dt}\\int_{-1}^{1} \\tfrac{1}{2}u^2\\,dx$ equals $0$.\n\nIn a Chebyshev-spectral collocation discretization on $[-1,1]$, two standard quadratures on bounded intervals are frequently invoked to approximate inner products and integrals:\n- Clenshaw–Curtis quadrature (CC), naturally associated with Chebyshev–Gauss–Lobatto points.\n- Legendre–Gauss–Lobatto quadrature (LGL), naturally associated with Legendre–Gauss–Lobatto points.\n\nIn this problem you will implement and compare the discrete kinetic energy rate produced by a skew-symmetric evaluation of the nonlinear term using each quadrature. The discrete setting is as follows.\n\n1) Nodes and differentiation:\n- For Clenshaw–Curtis, use the $N+1$ Chebyshev–Gauss–Lobatto nodes $x_j=\\cos\\left(\\frac{\\pi j}{N}\\right)$ for $j=0,\\dots,N$. Construct the first-derivative differentiation matrix $D\\in\\mathbb{R}^{(N+1)\\times(N+1)}$ at these nodes using the barycentric differentiation formula.\n- For Legendre–Gauss–Lobatto, use the $N+1$ Legendre–Gauss–Lobatto nodes consisting of the endpoints $x=\\pm 1$ and the $N-1$ interior roots of $\\partial_x P_N(x)$, where $P_N(x)$ is the Legendre polynomial of degree $N$. Construct the first-derivative differentiation matrix $D$ at these nodes using the barycentric differentiation formula.\n\n2) Quadrature weights:\n- For Clenshaw–Curtis, compute the weights $w_j$ as the unique interpolatory quadrature weights at the Chebyshev–Gauss–Lobatto nodes, i.e., the weights that satisfy\n$$\n\\sum_{j=0}^{N} w_j x_j^k \\;=\\; \\int_{-1}^{1} x^k\\,dx, \\quad \\text{for all } k=0,1,\\dots,N.\n$$\n- For Legendre–Gauss–Lobatto, compute the weights $w_j$ using the standard formula\n$$\nw_j \\;=\\; \\frac{2}{N(N+1)\\left[P_N(x_j)\\right]^2}, \\quad j=0,\\dots,N,\n$$\nwhere $P_N(x)$ is the Legendre polynomial of degree $N$.\n\n3) Skew-symmetric nonlinear term:\nGiven a nodal vector $u\\in\\mathbb{R}^{N+1}$ and its derivative $Du$, define the skew-symmetric discrete nonlinear term that approximates $u\\,\\partial_x u$ by the symmetric split of the advective and conservative forms:\n$$\n\\mathcal{N}(u) \\;=\\; \\frac{1}{2}\\,\\big(u \\circ (Du)\\big)\\;+\\;\\frac{1}{2}\\,D\\!\\left(\\frac{1}{2}u^2\\right),\n$$\nwhere $u\\circ v$ denotes the elementwise (Hadamard) product. Note that in the continuous calculus, both terms equal $u\\,\\partial_x u$, and hence the split is exact; in the discrete calculus, the split mitigates aliasing errors.\n\n4) Discrete energy rate and energy defect:\nFor a given quadrature with diagonal weight matrix $W=\\mathrm{diag}(w_0,\\dots,w_N)$ and differentiation matrix $D$, define the discrete energy rate\n$$\n\\dot{E}_{\\mathrm{disc}} \\;=\\; \\sum_{j=0}^{N} w_j\\,u_j\\,\\mathcal{N}(u)_j.\n$$\nThe analytic boundary flux for the energy rate at $t=0$ is\n$$\n\\dot{E}_{\\mathrm{flux}} \\;=\\; \\frac{1}{3}\\,\\big(u(1)^3 - u(-1)^3\\big).\n$$\nDefine the discrete energy defect as\n$$\n\\varepsilon \\;=\\; \\left|\\,\\dot{E}_{\\mathrm{disc}} - \\dot{E}_{\\mathrm{flux}}\\,\\right|.\n$$\nFor the Dirichlet-compatible initial data prescribed below, $\\dot{E}_{\\mathrm{flux}}=0$, so $\\varepsilon=|\\dot{E}_{\\mathrm{disc}}|$ measures the failure (if any) of the discrete skew-symmetric form to conserve energy under the chosen quadrature.\n\nYour program must:\n- Implement both node sets and their corresponding differentiation matrices via the barycentric differentiation formula.\n- Implement both quadrature weight constructions as described.\n- Evaluate the skew-symmetric nonlinear term and compute the discrete energy defect $\\varepsilon$ for each quadrature and each test case.\n\nUse the following test suite of four cases. In every case, ensure that the initial data $u(x)$ satisfies $u(-1)=u(1)=0$:\n- Case $1$: $N=16$, $u(x)=(1-x^2)$.\n- Case $2$: $N=24$, $u(x)=(1-x^2)\\,e^x$.\n- Case $3$: $N=12$, $u(x)=x\\,(1-x^2)^2$.\n- Case $4$: $N=8$, $u(x)=(1-x^2)\\,T_5(x)$, where $T_5(x)=\\cos\\!\\big(5\\arccos(x)\\big)$ is the Chebyshev polynomial of degree $5$ expressed as a polynomial in $x$.\n\nFor each case, compute two floating-point results:\n- The discrete energy defect $\\varepsilon_{\\mathrm{CC}}$ using Clenshaw–Curtis nodes, differentiation matrix, and quadrature.\n- The discrete energy defect $\\varepsilon_{\\mathrm{LGL}}$ using Legendre–Gauss–Lobatto nodes, differentiation matrix, and quadrature.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order\n$$\n[\\varepsilon_{\\mathrm{CC}}^{(1)},\\varepsilon_{\\mathrm{LGL}}^{(1)},\\varepsilon_{\\mathrm{CC}}^{(2)},\\varepsilon_{\\mathrm{LGL}}^{(2)},\\varepsilon_{\\mathrm{CC}}^{(3)},\\varepsilon_{\\mathrm{LGL}}^{(3)},\\varepsilon_{\\mathrm{CC}}^{(4)},\\varepsilon_{\\mathrm{LGL}}^{(4)}].\n$$\nNo external input is required. All computations are nondimensional and require no physical units. Use radian measure implicitly in any trigonometric evaluation of $T_5(x)$ if you choose to evaluate it via its trigonometric definition; alternatively, use the exact polynomial identity $T_5(x)=16x^5-20x^3+5x$ to avoid trigonometric functions. The numerical answers must be floating-point numbers.", "solution": "The present problem requires the calculation of the discrete energy defect for a Chebyshev-spectral collocation discretization of the one-dimensional inviscid Burgers' equation, $u_t + \\partial_x (\\tfrac{1}{2}u^2) = 0$, on the domain $x \\in [-1, 1]$ with homogeneous Dirichlet boundary conditions $u(\\pm 1, t) = 0$. The analysis compares two standard quadrature methods on bounded intervals: Clenshaw-Curtis (CC) and Legendre-Gauss-Lobatto (LGL).\n\nThe continuous kinetic energy of a solution $u(x,t)$ is $E(t) = \\frac{1}{2}\\int_{-1}^{1} u(x,t)^2\\,dx$. Its rate of change is\n$$\n\\frac{dE}{dt} = \\int_{-1}^{1} u u_t \\,dx = -\\int_{-1}^{1} u \\partial_x(\\tfrac{1}{2}u^2) \\,dx.\n$$\nThe nonlinear term can be written as $u \\partial_x u$. Integrating $\\int_{-1}^1 u^2 u_x \\,dx$ gives\n$$\n\\int_{-1}^{1} u^2 u_x \\,dx = \\int_{-1}^{1} \\frac{\\partial}{\\partial x}\\left(\\frac{u^3}{3}\\right) \\,dx = \\left[\\frac{u^3}{3}\\right]_{-1}^{1} = \\frac{1}{3}\\left(u(1,t)^3 - u(-1,t)^3\\right).\n$$\nThus, the energy rate is $\\frac{dE}{dt} = -\\frac{1}{3}\\left(u(1,t)^3 - u(-1,t)^3\\right)$. The problem defines an `analytic boundary flux` for the energy rate as $\\dot{E}_{\\mathrm{flux}} = \\frac{1}{3}\\left(u(1)^3 - u(-1)^3\\right)$, so that $\\frac{dE}{dt} = -\\dot{E}_{\\mathrm{flux}}$. For the given boundary conditions, $\\dot{E}_{\\mathrm{flux}} = 0$, and the energy is conserved.\n\nIn a spectral collocation method, the solution $u(x,t)$ is represented by its values $u_j(t)$ at a set of $N+1$ nodes $\\{x_j\\}_{j=0}^N$. Derivatives are approximated by matrix-vector products, e.g., $\\partial_x u \\approx Du$, where $D$ is a differentiation matrix. Integrals are approximated by quadrature rules, $\\int_{-1}^1 g(x) dx \\approx \\sum_{j=0}^N w_j g(x_j)$, where $w_j$ are quadrature weights. This discrete inner product is denoted $\\langle g,h \\rangle_w = \\sum_j w_j g_j h_j$.\n\nThe problem specifies a skew-symmetric discretization of the nonlinear term $u u_x$:\n$$\n\\mathcal{N}(u) = \\frac{1}{2}\\,(u \\circ (Du)) + \\frac{1}{2}\\,D\\left(\\frac{1}{2}u^2\\right),\n$$\nwhere $\\circ$ is the elementwise product. The discrete energy rate is defined as $\\dot{E}_{\\mathrm{disc}} = \\sum_{j=0}^{N} w_j\\,u_j\\,\\mathcal{N}(u)_j = \\langle u, \\mathcal{N}(u) \\rangle_w$. The energy defect is then $\\varepsilon = |\\dot{E}_{\\mathrm{disc}} - \\dot{E}_{\\mathrm{flux}}|$. Since all initial data satisfy $u(\\pm 1)=0$, we have $\\dot{E}_{\\mathrm{flux}}=0$, and the defect is simply $\\varepsilon = |\\dot{E}_{\\mathrm{disc}}|$.\n\nThe solution requires implementing the following steps for both CC and LGL methods across four test cases.\n\n**1. Node Generation**\n- **Clenshaw-Curtis (CC):** The $N+1$ nodes are the Chebyshev-Gauss-Lobatto (CGL) points, $x_j = \\cos(\\frac{\\pi j}{N})$ for $j=0, \\dots, N$. These nodes are ordered from $1$ to $-1$.\n- **Legendre-Gauss-Lobatto (LGL):** The $N+1$ nodes are the endpoints $x = \\pm 1$ together with the $N-1$ roots of $P_N'(x)$, where $P_N(x)$ is the Legendre polynomial of degree $N$. For consistency, these nodes are also sorted in descending order from $1$ to $-1$.\n\n**2. Differentiation Matrix Construction**\nThe differentiation matrix $D$ for each node set is constructed using standard, stable formulas derived from the barycentric representation, as requested by the problem statement.\n- **For CGL nodes:** The entries of $D \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ are given by:\n$$\n\\begin{cases}\nD_{ij} = \\frac{c_i}{c_j} \\frac{(-1)^{i+j}}{x_i - x_j},  i \\neq j \\\\\nD_{ii} = \\frac{-x_i}{2(1-x_i^2)},  i=1, \\dots, N-1 \\\\\nD_{00} = \\frac{2N^2+1}{6},  D_{NN} = -\\frac{2N^2+1}{6}\n\\end{cases}\n$$\nwhere $c_0=c_N=2$ and $c_i=1$ for $i=1, \\dots, N-1$.\n- **For LGL nodes:** The entries of $D \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ are given by:\n$$\n\\begin{cases}\nD_{ij} = \\frac{P_N(x_i)}{P_N(x_j)} \\frac{1}{x_i - x_j},  i \\neq j \\\\\nD_{ii} = 0,  i=1, \\dots, N-1 \\\\\nD_{00} = \\frac{N(N+1)}{4},  D_{NN} = -\\frac{N(N+1)}{4}\n\\end{cases}\n$$\n\n**3. Quadrature Weight Calculation**\n- **For Clenshaw-Curtis (CC):** The weights $w_j$ are defined as the solution to the linear system $\\sum_{j=0}^{N} w_j x_j^k = \\int_{-1}^{1} x^k\\,dx$ for $k=0, \\dots, N$. Let $V$ be the Vandermonde matrix with entries $V_{jk} = x_j^k$, and $b$ be the vector with entries $b_k = \\int_{-1}^1 x^k dx = (1+(-1)^k)/(k+1)$. The weights are found by solving the system $V^T w = b$.\n- **For Legendre-Gauss-Lobatto (LGL):** The weights are given by the explicit formula:\n$$\nw_j = \\frac{2}{N(N+1) [P_N(x_j)]^2}, \\quad j=0, \\dots, N.\n$$\n\n**4. Energy Defect Calculation**\nFor each quadrature type and test case $(N, u(x))$, the defect $\\varepsilon$ is computed:\n1. Generate the nodes $x$, differentiation matrix $D$, and weights $w$.\n2. Evaluate the initial condition at the nodes to get the vector $u$, where $u_j = u(x_j)$.\n3. Compute the nonlinear term vector: $\\mathcal{N}(u) = \\frac{1}{2}(u \\circ (Du)) + \\frac{1}{4}D(u^2)$.\n4. Calculate the discrete energy rate: $\\dot{E}_{\\mathrm{disc}} = u^T W \\mathcal{N}(u)$, where $W=\\mathrm{diag}(w)$.\n5. Since $\\dot{E}_{\\mathrm{flux}}=0$, the defect is $\\varepsilon = |\\dot{E}_{\\mathrm{disc}}|$.\n\n**Theoretical Expectation**\nA key difference between the two schemes lies in the \"summation-by-parts\" (SBP) property. For LGL nodes and weights, the identity $D^T W + W D = B$ holds, where $B$ is a boundary matrix with $B_{00}=1$ and $B_{NN}=-1$ and zeros elsewhere (assuming nodes are ordered from $1$ to $-1$). This property allows the discrete energy rate to be simplified:\n$$\n\\dot{E}_{\\mathrm{disc, LGL}} = \\langle u, \\mathcal{N}(u) \\rangle_w = \\frac{1}{4}\\langle u^2, Du \\rangle_w + \\frac{1}{4}(u(1)^3 - u(-1)^3).\n$$\nFor the given boundary conditions, this reduces to $\\dot{E}_{\\mathrm{disc, LGL}} = \\frac{1}{4} \\sum_j w_j u_j^2 (Du)_j$. The CGL/CC scheme does not satisfy the SBP property, and no such simplification occurs.\n\nFor Case 1, $u(x)=1-x^2$ is an even polynomial. Thus, $u^2$ is even and $Du$ is odd. The integrand $u^2(Du)$ is an odd function. LGL quadrature is exact for polynomials up to degree $2N-1$ and integrates any odd function to zero due to its symmetric nodes and weights. The integrand $u^2(Du)$ is a polynomial of degree $5$, which is less than $2(16)-1=31$. Thus, $\\sum w_j u_j^2 (Du)_j = 0$ exactly, and we expect $\\varepsilon_{\\mathrm{LGL}}^{(1)} = 0$ (to machine precision). A similar argument holds for the CC scheme. Its symmetric nodes and weights ensure that it also integrates odd functions to zero. The integrands for both terms in $\\dot{E}_{\\mathrm{disc, CC}}$ are odd polynomials and are integrated exactly by the CC rule for $N=16$. Thus, we expect $\\varepsilon_{\\mathrm{CC}}^{(1)} = 0$ as well. For other cases involving non-polynomial or non-symmetric functions, non-zero defects are expected.", "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre, eval_legendre, legendre\n\ndef get_cgl_props(N):\n    \"\"\"\n    Computes Chebyshev-Gauss-Lobatto nodes, differentiation matrix, and\n    Clenshaw-Curtis quadrature weights.\n    \"\"\"\n    # Nodes\n    j = np.arange(N + 1)\n    nodes = np.cos(np.pi * j / N)\n\n    # Differentiation Matrix (using stable formulas from Trefethen, \"Spectral Methods in MATLAB\")\n    D = np.zeros((N + 1, N + 1))\n    c = np.ones(N + 1)\n    c[0] = 2.\n    c[-1] = 2.\n\n    x_diff = nodes[:, np.newaxis] - nodes[np.newaxis, :]\n    np.fill_diagonal(x_diff, 1e-12)  # Avoid division by zero, diagonal will be overwritten\n\n    D = (c[:, np.newaxis] * (-1)**np.add.outer(j, j)) / (c[np.newaxis, :] * x_diff)\n    \n    # Diagonal entries\n    D[0, 0] = (2 * N**2 + 1) / 6.\n    D[N, N] = -(2 * N**2 + 1) / 6.\n    for i in range(1, N):\n        D[i, i] = -nodes[i] / (2 * (1 - nodes[i]**2))\n\n    # Quadrature Weights via Vandermonde matrix\n    # Solve V.T @ w = b where V_jk = x_j^k and b_k = integral(x^k)\n    k = np.arange(N + 1)\n    V = np.power(nodes.reshape(-1, 1), k.reshape(1, -1))\n    b = (1 + (-1)**k) / (k + 1)\n    weights = np.linalg.solve(V.T, b)\n\n    return nodes, D, weights\n\ndef get_lgl_props(N):\n    \"\"\"\n    Computes Legendre-Gauss-Lobatto nodes, differentiation matrix, and\n    quadrature weights.\n    \"\"\"\n    if N == 0:\n        return np.array([0.]), np.array([[0.]]), np.array([2.])\n    if N == 1:\n        return np.array([1., -1.]), np.array([[0.5, -0.5], [0.5, -0.5]]), np.array([1., 1.])\n        \n    # Nodes: endpoints plus roots of P_N'(x)\n    # P_N'(x) has roots of P_{N-1} plus some other things. Simpler to use scipy directly.\n    # Roots of P_N'(x) are needed. P_N'(x) is a poly of degree N-1.\n    P_N_prime_roots = legendre(N).deriv(1).roots\n    nodes = np.concatenate(([-1.], P_N_prime_roots, [1.]))\n    nodes = np.sort(nodes)[::-1]  # Sort descending from 1 to -1\n\n    # Legendre polynomials at nodes\n    P_N_at_nodes = eval_legendre(N, nodes)\n\n    # Differentiation Matrix (using stable formula)\n    D = np.zeros((N + 1, N + 1))\n    x_diff = nodes[:, np.newaxis] - nodes[np.newaxis, :]\n    np.fill_diagonal(x_diff, 1e-12)\n\n    D = (P_N_at_nodes[:, np.newaxis] / P_N_at_nodes[np.newaxis, :]) / x_diff\n    \n    # Diagonal entries\n    D[0, 0] = N * (N + 1) / 4.\n    D[N, N] = -N * (N + 1) / 4.\n    for i in range(1, N):\n        D[i, i] = 0.\n\n    # Quadrature Weights\n    weights = 2 / (N * (N + 1) * P_N_at_nodes**2)\n    \n    return nodes, D, weights\n\n\ndef compute_energy_defect(N, u_func, method):\n    \"\"\"\n    Computes the discrete energy defect for a given method.\n    \"\"\"\n    if method == 'CC':\n        nodes, D, weights = get_cgl_props(N)\n    elif method == 'LGL':\n        nodes, D, weights = get_lgl_props(N)\n    else:\n        raise ValueError(\"Method must be 'CC' or 'LGL'\")\n\n    # Evaluate initial data at nodes\n    u = u_func(nodes)\n    \n    # Ensure boundary conditions are exactly zero at the nodes\n    if np.isclose(nodes[0], 1.0):\n        u[0] = 0.0\n    if np.isclose(nodes[-1], -1.0):\n        u[-1] = 0.0\n\n    # Compute terms for the skew-symmetric form\n    u_sq = u**2\n    Du = D @ u\n    D_u_sq = D @ u_sq\n\n    # Skew-symmetric nonlinear term\n    N_u = 0.5 * (u * Du) + 0.5 * 0.5 * D_u_sq\n\n    # Discrete energy rate\n    # Edot_disc = u.T @ np.diag(weights) @ N_u\n    Edot_disc = np.sum(weights * u * N_u)\n    \n    # Analytic flux term is zero for these boundary conditions\n    Edot_flux = 0.0\n    \n    # Energy defect\n    epsilon = np.abs(Edot_disc - Edot_flux)\n    \n    return epsilon\n\n\ndef solve():\n    \"\"\"\n    Runs all test cases and prints the results.\n    \"\"\"\n    \n    # Define test case functions\n    def u1(x): return 1 - x**2\n    def u2(x): return (1 - x**2) * np.exp(x)\n    def u3(x): return x * (1 - x**2)**2\n    def T5(x): return 16*x**5 - 20*x**3 + 5*x\n    def u4(x): return (1 - x**2) * T5(x)\n\n    test_cases = [\n        (16, u1),\n        (24, u2),\n        (12, u3),\n        (8, u4),\n    ]\n\n    results = []\n    for N, u_func in test_cases:\n        eps_cc = compute_energy_defect(N, u_func, method='CC')\n        eps_lgl = compute_energy_defect(N, u_func, method='LGL')\n        results.extend([eps_cc, eps_lgl])\n\n    # Format output as specified\n    print(f\"[{','.join(f'{r:.16e}' for r in results)}]\")\n\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3300721"}]}