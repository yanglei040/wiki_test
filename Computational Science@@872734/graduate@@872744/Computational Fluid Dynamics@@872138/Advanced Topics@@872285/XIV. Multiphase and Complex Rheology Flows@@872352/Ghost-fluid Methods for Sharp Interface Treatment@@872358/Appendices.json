{"hands_on_practices": [{"introduction": "Mastering any numerical technique begins with applying it to a controlled, verifiable problem. This exercise guides you through implementing the Ghost-Fluid Method (GFM) for a one-dimensional Poisson equation, a fundamental model for diffusion processes. By using the Method of Manufactured Solutions, you will not only verify the correctness of your code but also gain a deeper insight into how the local truncation error of the GFM is intimately linked to the mathematical structure of the interface jump conditions [@problem_id:3323634].", "problem": "Consider a one-dimensional steady diffusion model on the closed interval $[0,1]$ with a single sharp interface at a point $x=\\alpha\\in (0,1)$ separating two subdomains $[0,\\alpha)$ and $(\\alpha,1]$. The governing equation is the scalar Poisson equation derived from conservation of diffusive flux for a homogeneous medium, written as $u^{\\prime\\prime}(x)=q(x)$ for every $x\\neq \\alpha$, where the source term is $q(x)=-\\pi^{2}\\sin(\\pi x)$. The solution satisfies Dirichlet boundary conditions $u(0)=u_{\\mathrm{exact}}(0)$ and $u(1)=u_{\\mathrm{exact}}(1)$. Across the interface, the solution and its first derivative satisfy prescribed jumps $[u]_{\\alpha}=J$ and $[u_{x}]_{\\alpha}=K$, where $[g]_{\\alpha}=g(\\alpha^{+})-g(\\alpha^{-})$ denotes the jump of a function $g$ at $x=\\alpha$. An exact, piecewise-smooth solution consistent with these conditions is given by\n$$\nu_{\\mathrm{exact}}(x)=\\sin(\\pi x)+H(x-\\alpha)\\,\\big(J+K\\,(x-\\alpha)\\big),\n$$\nwhere $H$ is the Heaviside step function defined by $H(\\xi)=0$ for $\\xi<0$ and $H(\\xi)=1$ for $\\xi>0$, and any choice at $\\xi=0$ does not affect the problem since $\\alpha$ is not a grid point in the test configurations below.\n\nYour tasks are as follows.\n\n1) Starting from the conservation law basis and the central difference approximation for the second derivative, derive a sharp-interface finite-difference discretization on a uniform grid that is consistent with the interface jump conditions using the Ghost Fluid Method (GFM) (Ghost Fluid Method (GFM) is a technique that enforces interface conditions by constructing ghost values across the interface). Use a uniform grid $x_{i}=i\\,h$ for integers $i\\in\\{0,1,\\dots,N\\}$ with spacing $h=1/N$, and the classical second-order central difference for $u^{\\prime\\prime}(x)$ at nodes that do not straddle the interface. In the two control volumes adjacent to the interface cell containing $x=\\alpha$ (i.e., the unique cell $[x_{k},x_{k+1}]$ with $x_{k}\\le \\alpha<x_{k+1}$), enforce the jump conditions $[u]_{\\alpha}=J$ and $[u_{x}]_{\\alpha}=K$ to construct ghost values that lead to a modified right-hand side while preserving the standard tridiagonal stencil structure on the left-hand side. Your derivation must begin from the definitions of the jump conditions and Taylor expansions about $x=\\alpha$, and must not assume any pre-packaged interface formula.\n\n2) Provide a consistency analysis that quantifies the local truncation error away from and adjacent to the interface, and deduce the expected global convergence order of the resulting scheme in the discrete $L^{2}$ norm.\n\n3) Implement the resulting discretization and a grid-refinement study to estimate the experimental order of convergence (EOC). Use the discrete $L^{2}$ error norm\n$$\n\\|e\\|_{2,h}=\\left(h\\sum_{i=0}^{N}\\left(u_{i}-u_{\\mathrm{exact}}(x_{i})\\right)^{2}\\right)^{1/2},\n$$\nwhere $u_{i}$ is the numerical solution at $x_{i}$. For each test case below, compute errors on three successively refined grids with $N$, $2N$, and $4N$ points (grid spacings $h$, $h/2$, and $h/4$), and compute the experimental orders\n$$\np_{1}=\\log_{2}\\left(\\frac{\\|e\\|_{2,h}}{\\|e\\|_{2,h/2}}\\right),\\qquad p_{2}=\\log_{2}\\left(\\frac{\\|e\\|_{2,h/2}}{\\|e\\|_{2,h/4}}\\right),\n$$\nthen report the average $\\tfrac{1}{2}(p_{1}+p_{2})$ as the estimated order for that test case.\n\nImplementation requirements.\n\n- Use the classical second-order central difference stencil on all interior nodes except only modify the right-hand side of the two equations adjacent to the interface cell by appropriately constructed ghost values that enforce the two jump conditions. Preserve the symmetric tridiagonal coefficient matrix of the standard second-order discretization for the one-dimensional Poisson problem with Dirichlet boundary conditions.\n\n- Enforce the Dirichlet data by setting $u_{0}=u_{\\mathrm{exact}}(0)$ and $u_{N}=u_{\\mathrm{exact}}(1)$ and incorporating them into the right-hand side of the interior equations in the usual way.\n\n- The interface location $x=\\alpha$ is not equal to any grid point in the test cases.\n\nTest suite.\n\nFor each test case, set the exact solution as above, the source term $q(x)=-\\pi^{2}\\sin(\\pi x)$, and the boundary values from $u_{\\mathrm{exact}}$. Use base grid size $N_{0}=80$ for all cases. For each case, compute the average EOC across $(N_{0},2N_{0},4N_{0})$.\n\n- Case A (general position): $\\alpha=0.37$, $J=0.3$, $K=-0.8$.\n\n- Case B (interface near left boundary): $\\alpha=0.05$, $J=1.0$, $K=0.5$.\n\n- Case C (no jumps, consistency check): $\\alpha=0.42$, $J=0.0$, $K=0.0$.\n\n- Case D (interface near right boundary): $\\alpha=0.95$, $J=-0.2$, $K=1.5$.\n\nFinal output format.\n\nYour program should produce a single line of output containing the four average EOC values for Cases A–D as a comma-separated list enclosed in square brackets (for example, $[p_{A},p_{B},p_{C},p_{D}]$). Each entry must be a floating-point number. No other text should be printed.", "solution": "The problem is assessed to be valid. It is scientifically grounded in numerical analysis and computational fluid dynamics, specifically concerning the finite difference method for the Poisson equation and the Ghost Fluid Method (GFM) for sharp interfaces. The problem is well-posed, providing a clear governing equation, boundary conditions, interface jump conditions, and a manufactured exact solution for verification. The givens are complete, internally consistent, and free of ambiguity, allowing for a unique solution path. The tasks are objective and formalizable.\n\n### 1. Derivation of the Sharp-Interface Discretization\n\nWe are tasked with solving the one-dimensional Poisson equation $u^{\\prime\\prime}(x)=q(x)$ on the interval $[0,1]$, with a sharp interface at $x=\\alpha$. The solution $u(x)$ and its derivative $u_x(x)$ have prescribed jumps $[u]_{\\alpha}=J$ and $[u_x]_{\\alpha}=K$ at the interface, where $[g]_{\\alpha} = g(\\alpha^+) - g(\\alpha^-)$.\n\nWe use a uniform grid with $N+1$ points $x_i = i h$ for $i=0, 1, \\dots, N$, where the grid spacing is $h=1/N$. The interface at $x=\\alpha$ is located within a grid cell, such that $x_k \\le \\alpha < x_{k+1}$ for a unique integer $k$.\n\nFor any grid node $x_i$ where the standard three-point stencil $\\{x_{i-1}, x_i, x_{i+1}\\}$ does not cross the interface, we use the second-order central difference approximation for the second derivative:\n$$\n\\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2} = q(x_i) = q_i\n$$\nwhere $u_i$ is the numerical approximation of $u(x_i)$.\n\nThe stencils centered at nodes $x_k$ and $x_{k+1}$ cross the interface. We employ the Ghost Fluid Method (GFM) to modify the finite difference equations at these two nodes. The GFM preserves the standard left-hand side (LHS) matrix stencil by introducing correction terms on the right-hand side (RHS). These corrections are derived from ghost values constructed to enforce the jump conditions.\n\n**Modification at Node $x_k$:**\nThe stencil at $x_k$ involves $u_{k-1}$, $u_k$, and $u_{k+1}$. Since $x_k < \\alpha$ and $x_{k+1} > \\alpha$, the value $u_{k+1}$ lies on the \"right\" side of the interface relative to $x_k$. In the GFM, we replace $u_{k+1}$ with a ghost value, $u^G_{k+1}$, that represents a smooth extension of the \"left\" solution into the right domain. Let $u_L(x)$ be the solution for $x \\le \\alpha$ and $u_R(x)$ be the solution for $x \\ge \\alpha$. The ghost value $u^G_{k+1}$ should approximate $u_L(x_{k+1})$.\n\nThe jump conditions can be used to relate the a hypothetical smooth extension of $u_L$ into the region $x>\\alpha$ to the real solution $u_R(x)$. Based on a first-order Taylor expansion of the jump conditions around $x=\\alpha$, we can state:\n$u_L(x) \\approx u_R(x) - (J + K(x-\\alpha))$ for $x > \\alpha$.\nThis provides a way to define the ghost value at $x_{k+1}$ using the real value at that point:\n$$\nu^G_{k+1} = u_{k+1} - (J + K(x_{k+1}-\\alpha))\n$$\nSubstituting this ghost value into the central difference formula at $x_k$:\n$$\n\\frac{u_{k-1} - 2u_k + u^G_{k+1}}{h^2} = q_k\n$$\n$$\n\\frac{u_{k-1} - 2u_k + u_{k+1} - (J + K(x_{k+1}-\\alpha))}{h^2} = q_k\n$$\nRearranging to keep the standard stencil on the LHS, we obtain the modified equation for node $x_k$:\n$$\n\\frac{u_{k-1} - 2u_k + u_{k+1}}{h^2} = q_k + \\frac{J + K(x_{k+1}-\\alpha)}{h^2}\n$$\n\n**Modification at Node $x_{k+1}$:**\nSimilarly, the stencil at $x_{k+1}$ involves $u_k$, $u_{k+1}$, and $u_{k+2}$. The value $u_k$ is on the \"left\" side, so we replace it with a ghost value $u^G_k$ representing a smooth extension of the \"right\" solution $u_R(x)$ into the left domain. Symmetrically, we define this relationship as:\n$u_R(x) \\approx u_L(x) + (J + K(x-\\alpha))$ for $x < \\alpha$.\nThe ghost value at $x_k$ is thus defined using the real value $u_k$:\n$$\nu^G_k = u_k + (J + K(x_k-\\alpha))\n$$\nSubstituting this into the central difference formula at $x_{k+1}$:\n$$\n\\frac{u^G_k - 2u_{k+1} + u_{k+2}}{h^2} = q_{k+1}\n$$\n$$\n\\frac{u_k + (J + K(x_k-\\alpha)) - 2u_{k+1} + u_{k+2}}{h^2} = q_{k+1}\n$$\nThe modified equation for node $x_{k+1}$ is:\n$$\n\\frac{u_k - 2u_{k+1} + u_{k+2}}{h^2} = q_{k+1} - \\frac{J + K(x_k-\\alpha)}{h^2}\n$$\nThese modifications preserve the symmetric tridiagonal structure of the matrix operator, with all changes incorporated into the RHS vector.\n\n### 2. Consistency Analysis and Convergence Order\n\nThe local truncation error (LTE) at a grid node $x_i$ is defined as $\\tau_i = L_h(u_{\\mathrm{exact}})(x_i) - q(x_i)$, where $L_h$ is the finite difference operator.\n\n**Away from the interface:** For a node $x_i$ where the stencil does not cross $\\alpha$, the operator is the standard central difference. Taylor expansion of $u_{\\mathrm{exact}}(x_i \\pm h)$ about $x_i$ gives:\n$$\n\\tau_i = \\frac{u_{\\mathrm{exact}}(x_{i-1}) - 2u_{\\mathrm{exact}}(x_i) + u_{\\mathrm{exact}}(x_{i+1})}{h^2} - u_{\\mathrm{exact}}''(x_i) = \\frac{h^2}{12}u_{\\mathrm{exact}}^{(4)}(x_i) + O(h^4)\n$$\nThus, the LTE is second-order, $\\tau_i = O(h^2)$, away from the interface.\n\n**Adjacent to the interface:** The analysis is critically dependent on the specific form of the provided exact solution:\n$$\nu_{\\mathrm{exact}}(x)=\\sin(\\pi x)+H(x-\\alpha)\\,\\big(J+K\\,(x-\\alpha)\\big)\n$$\nLet $u_L(x) = \\sin(\\pi x)$ and $u_R(x) = \\sin(\\pi x) + J + K(x-\\alpha)$. The exact solution is $u_{\\mathrm{exact}}(x) = u_L(x)$ for $x<\\alpha$ and $u_{\\mathrm{exact}}(x) = u_R(x)$ for $x>\\alpha$. A crucial property is that the jump component is linear, meaning $u_R(x) = u_L(x) + J + K(x-\\alpha)$ for all $x$. Also, $u_L''(x) = u_R''(x) = -\\pi^2\\sin(\\pi x) = q(x)$.\n\n**LTE at Node $x_k$:** The LTE is given by:\n$$\n\\tau_k = \\left(\\frac{u_{\\mathrm{exact}}(x_{k-1}) - 2u_{\\mathrm{exact}}(x_k) + u_{\\mathrm{exact}}(x_{k+1})}{h^2}\\right) - \\left(q_k + \\frac{J + K(x_{k+1}-\\alpha)}{h^2}\\right)\n$$\nSubstituting $u_{\\mathrm{exact}}(x_{k-1})=u_L(x_{k-1})$, $u_{\\mathrm{exact}}(x_k)=u_L(x_k)$, and $u_{\\mathrm{exact}}(x_{k+1})=u_R(x_{k+1})=u_L(x_{k+1}) + J + K(x_{k+1}-\\alpha)$:\n\\begin{align*}\n\\tau_k &= \\frac{u_L(x_{k-1}) - 2u_L(x_k) + \\left(u_L(x_{k+1}) + J + K(x_{k+1}-\\alpha)\\right)}{h^2} - q_k - \\frac{J + K(x_{k+1}-\\alpha)}{h^2} \\\\\n&= \\frac{u_L(x_{k-1}) - 2u_L(x_k) + u_L(x_{k+1})}{h^2} - q_k\n\\end{align*}\nSince $q_k = q(x_k) = u_L''(x_k)$, this expression is the standard LTE for the smooth function $u_L(x)$ at $x_k$. Thus, $\\tau_k = O(h^2)$.\n\n**LTE at Node $x_{k+1}$:** The LTE is given by:\n$$\n\\tau_{k+1} = \\left(\\frac{u_{\\mathrm{exact}}(x_k) - 2u_{\\mathrm{exact}}(x_{k+1}) + u_{\\mathrm{exact}}(x_{k+2})}{h^2}\\right) - \\left(q_{k+1} - \\frac{J + K(x_k-\\alpha)}{h^2}\\right)\n$$\nSubstituting $u_{\\mathrm{exact}}(x_k)=u_L(x_k) = u_R(x_k) - (J + K(x_k-\\alpha))$, $u_{\\mathrm{exact}}(x_{k+1})=u_R(x_{k+1})$, and $u_{\\mathrm{exact}}(x_{k+2})=u_R(x_{k+2})$:\n\\begin{align*}\n\\tau_{k+1} &= \\frac{\\left(u_R(x_k) - (J+K(x_k-\\alpha))\\right) - 2u_R(x_{k+1}) + u_R(x_{k+2})}{h^2} - q_{k+1} + \\frac{J + K(x_k-\\alpha)}{h^2} \\\\\n&= \\frac{u_R(x_k) - 2u_R(x_{k+1}) + u_R(x_{k+2})}{h^2} - q_{k+1}\n\\end{align*}\nSince $q_{k+1} = q(x_{k+1}) = u_R''(x_{k+1})$, this is the standard LTE for the smooth function $u_R(x)$, which is also $O(h^2)$.\n\n**Global Convergence Order:**\nThe LTE is $O(h^2)$ at all interior grid nodes. The finite difference operator for the one-dimensional Poisson equation is stable. For a stable scheme, the order of the global error in a suitable norm (such as the discrete $L^2$ norm) is the same as the order of the local truncation error. Therefore, the expected global order of convergence for this specific problem and scheme is $2$. It is noteworthy that while the employed GFM is generally considered first-order, it achieves second-order accuracy here because its linear extrapolation of the jump conditions exactly matches the linear structure of the jump component in the manufactured solution.\n\n### 3. Implementation and Grid Refinement\n\nThe numerical implementation involves assembling and solving a linear system $A\\mathbf{u}_{\\text{int}} = \\mathbf{b}$ for the $N-1$ interior unknowns $\\mathbf{u}_{\\text{int}}=[u_1, \\dots, u_{N-1}]^T$.\n- The matrix $A$ is the standard $(N-1) \\times (N-1)$ symmetric tridiagonal matrix with $-2/h^2$ on the main diagonal and $1/h^2$ on the adjacent sub- and super-diagonals.\n- The RHS vector $\\mathbf{b}$ of size $N-1$ is constructed as follows:\n  1. Initialize $b_i = q(x_{i+1})$ for $i=0, \\dots, N-2$.\n  2. Incorporate Dirichlet boundary conditions: subtract $u_0/h^2$ from $b_0$ and $u_N/h^2$ from $b_{N-2}$.\n  3. Apply GFM corrections:\n     - Add $\\frac{J + K(x_{k+1}-\\alpha)}{h^2}$ to $b_{k-1}$ (for equation at $x_k$).\n     - Subtract $\\frac{J + K(x_k-\\alpha)}{h^2}$ from $b_k$ (for equation at $x_{k+1}$).\n- A sparse linear solver is used to efficiently solve the system.\n- The experimental order of convergence (EOC) is computed from the discrete $L^2$ errors obtained on a sequence of three refined grids.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags\nfrom scipy.sparse.linalg import spsolve\n\ndef u_exact(x, alpha, J, K):\n    \"\"\"\n    Computes the exact solution u_exact(x).\n    The Heaviside function is implemented using a boolean condition, as alpha\n    is never a grid point, so x - alpha is never zero.\n    \"\"\"\n    return np.sin(np.pi * x) + (x > alpha) * (J + K * (x - alpha))\n\ndef q_source(x):\n    \"\"\"\n    Computes the source term q(x).\n    \"\"\"\n    return -np.pi**2 * np.sin(np.pi * x)\n\ndef solve_poisson_gfm(N, alpha, J, K):\n    \"\"\"\n    Solves the 1D Poisson equation with a sharp interface using the Ghost Fluid Method.\n    \n    Args:\n        N (int): Number of intervals in the grid.\n        alpha (float): Interface location.\n        J (float): Jump in the solution u at the interface.\n        K (float): Jump in the derivative u_x at the interface.\n        \n    Returns:\n        float: The discrete L2 error norm of the numerical solution.\n    \"\"\"\n    h = 1.0 / N\n    x = np.linspace(0, 1, N + 1)\n    \n    # Find the index k such that x_k = alpha  x_{k+1}\n    k = int(np.floor(alpha / h))\n    \n    # Exact solution for error calculation\n    u_exact_vals = u_exact(x, alpha, J, K)\n    u0 = u_exact_vals[0]\n    uN = u_exact_vals[-1]\n    \n    # Set up the linear system A * u_interior = b\n    # A is the standard 1D Laplacian matrix (size N-1 x N-1)\n    diagonals = [np.ones(N - 2), -2 * np.ones(N - 1), np.ones(N - 2)]\n    A = diags(diagonals, [-1, 0, 1], shape=(N - 1, N - 1), format='csc')\n    A /= h**2\n    \n    # Construct the right-hand side vector b\n    b = q_source(x[1:-1])\n    \n    # Apply boundary conditions\n    b[0] -= u0 / h**2\n    b[-1] -= uN / h**2\n    \n    # Check if interface modifications are not at the boundaries (guaranteed by test cases)\n    # The GFM modifications apply to equations for nodes k and k+1.\n    # The unknown vector is u_1, ..., u_{N-1}, indexed 0 to N-2.\n    # Equation for u_k is at index k-1.\n    # Equation for u_{k+1} is at index k.\n    \n    if 0  k  N-1:\n        # Modify RHS for equation at node x_k\n        gfm_corr_k = (J + K * (x[k+1] - alpha)) / h**2\n        b[k-1] += gfm_corr_k\n        \n        # Modify RHS for equation at node x_{k+1}\n        gfm_corr_k1 = -(J + K * (x[k] - alpha)) / h**2\n        b[k] += gfm_corr_k1\n        \n    # Solve the sparse linear system\n    u_interior = spsolve(A, b)\n    \n    # Combine with boundary values to get the full numerical solution\n    u_numerical = np.concatenate(([u0], u_interior, [uN]))\n    \n    # Calculate the discrete L2 error norm\n    error_vector = u_numerical - u_exact_vals\n    l2_error = np.sqrt(h * np.sum(error_vector**2))\n    \n    return l2_error\n\ndef run_grid_refinement_study(case_params):\n    \"\"\"\n    Performs a grid refinement study for a given test case.\n    \n    Args:\n        case_params (tuple): A tuple containing (alpha, J, K, N0).\n\n    Returns:\n        float: The average Experimental Order of Convergence (EOC).\n    \"\"\"\n    alpha, J, K, N0 = case_params\n    \n    grid_sizes = [N0, 2 * N0, 4 * N0]\n    errors = []\n    \n    for N in grid_sizes:\n        error = solve_poisson_gfm(N, alpha, J, K)\n        errors.append(error)\n        \n    # Calculate EOC values\n    p1 = np.log2(errors[0] / errors[1])\n    p2 = np.log2(errors[1] / errors[2])\n    \n    avg_eoc = (p1 + p2) / 2.0\n    return avg_eoc\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (alpha, J, K, base_N)\n    test_cases = [\n        (0.37, 0.3, -0.8, 80),   # Case A\n        (0.05, 1.0, 0.5, 80),    # Case B\n        (0.42, 0.0, 0.0, 80),    # Case C\n        (0.95, -0.2, 1.5, 80),   # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        eoc = run_grid_refinement_study(case)\n        results.append(eoc)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3323634"}, {"introduction": "In multiphase flows, surface tension often creates the most significant pressure jump, and its accurate representation hinges on the calculation of interface curvature. This practice shifts our focus from the GFM framework itself to the numerical analysis of this critical input, which is notoriously sensitive to grid-level noise. Through a linearized Fourier analysis, you will derive how common numerical procedures, like Gaussian filtering and finite differencing, can alter the computed curvature, providing you with the analytical tools to diagnose and mitigate these numerical artifacts [@problem_id:3323621].", "problem": "A two-phase incompressible flow in two spatial dimensions has a material interface described by the graph $y = f(x)$, where $f(x) = A \\sin(k x)$ with $A k \\ll 1$. The interface is tracked using a level-set function $\\phi(x,y) = y - f(x)$ on a uniform Cartesian grid with spacing $h$ in both directions. The Ghost-Fluid Method (GFM) is used to impose the sharp jump in pressure across the interface due to surface tension. The surface tension coefficient is $\\gamma$ (units: $\\mathrm{N} \\cdot \\mathrm{m}^{-1}$), and the pressure jump across the interface is given by the Laplace–Young condition $[p] = \\gamma \\kappa$, where $\\kappa$ is the interface curvature.\n\nTo reduce grid-induced aliasing, the level-set field is regularized prior to curvature computation by convolution with an isotropic Gaussian kernel of standard deviation $\\sigma$ (units: $\\mathrm{m}$). Curvature is computed from the regularized field by the standard level-set formula $\\kappa = \\nabla \\cdot \\left( \\frac{\\nabla \\phi}{|\\nabla \\phi|} \\right)$, using second-order central differences for spatial derivatives on the grid.\n\nAssume the small-slope regime $A k \\ll 1$ so that, to leading order, the curvature reduces to the second derivative of the interface shape in $x$. Also assume the wavenumber $k$ satisfies $0  k  \\pi/h$. Under these assumptions, perform a linearized Fourier analysis to determine how the combination of Gaussian regularization and discrete second-order differentiation modifies the amplitude of the estimated curvature, relative to the true curvature amplitude. Specifically, derive the closed-form analytic expression for the ratio\n$$\nR(h,\\sigma,k) = \\frac{\\text{estimated curvature amplitude}}{\\text{true curvature amplitude}} \\, ,\n$$\nexpressed in terms of $h$, $\\sigma$, and $k$.\n\nYour final answer must be a single closed-form analytic expression for $R(h,\\sigma,k)$.", "solution": "The problem requires the derivation of the ratio $R(h,\\sigma,k)$ of the estimated curvature amplitude to the true curvature amplitude for a sinusoidal interface under specific numerical treatments. The analysis will proceed in three stages: first, determining the true curvature amplitude in the specified physical regime; second, determining the estimated curvature amplitude resulting from Gaussian regularization and discrete differentiation; and third, computing the ratio of these two amplitudes.\n\n**Step 1: True Curvature Amplitude**\n\nThe material interface is described by the function $y = f(x)$, where $f(x) = A \\sin(k x)$. The exact curvature $\\kappa$ of a curve defined by $y=f(x)$ is given by the formula:\n$$\n\\kappa_{true}(x) = \\frac{f''(x)}{\\left(1 + [f'(x)]^2\\right)^{3/2}}\n$$\nThis sign convention is consistent with the level-set formulation $\\phi(x,y)=f(x)-y$. However, the problem specifies $\\phi(x,y) = y-f(x)$. For this choice, the curvature is $\\kappa = \\nabla \\cdot (\\nabla \\phi / |\\nabla \\phi|)$, which evaluates to:\n$$\n\\kappa_{true}(x) = \\frac{-f''(x)}{\\left(1 + [f'(x)]^2\\right)^{3/2}}\n$$\nThe derivatives of $f(x)$ are:\n$$\nf'(x) = A k \\cos(k x)\n$$\n$$\nf''(x) = -A k^2 \\sin(k x)\n$$\nThe problem states that we operate in the small-slope regime, where $A k \\ll 1$. This implies that $[f'(x)]^2 = (A k \\cos(k x))^2 \\ll 1$. The denominator of the curvature expression can thus be approximated to leading order as $(1 + [f'(x)]^2)^{3/2} \\approx 1$.\nThe problem statement explicitly directs us to use this simplification: \"assume the small-slope regime ... so that, to leading order, the curvature reduces to the second derivative of the interface shape in $x$.\" Adopting the sign from the level-set formulation, the true curvature is approximated by:\n$$\n\\kappa_{true}(x) \\approx -f''(x) = -(-A k^2 \\sin(k x)) = A k^2 \\sin(k x)\n$$\nThe amplitude of the true curvature is the coefficient of the sinusoidal term, which is:\n$$\nK_{true} = A k^2\n$$\n\n**Step 2: Estimated Curvature Amplitude**\n\nThe estimated curvature is computed from the regularized level-set field, $\\phi_{reg}$, which is then differentiated using a discrete scheme.\n\nFirst, we analyze the effect of regularization. The level-set field $\\phi(x,y) = y - A \\sin(k x)$ is convolved with a $2$D isotropic Gaussian kernel $G(x,y)$ with standard deviation $\\sigma$:\n$$\n\\phi_{reg}(x,y) = (\\phi * G)(x,y)\n$$\nConvolution is a linear operation. The convolution of the term $y$ with the normalized Gaussian kernel yields $y$. The convolution acts on the interface shape function $f(x) = A \\sin(k x)$. As $f(x)$ is only a function of $x$, the convolution with the $2$D Gaussian $G(x,y) = \\frac{1}{2 \\pi \\sigma^2} \\exp(-\\frac{x^2+y^2}{2\\sigma^2})$ effectively reduces to a convolution with a $1$D Gaussian $G_{1D}(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma} \\exp(-\\frac{x^2}{2\\sigma^2})$.\nIn Fourier space, convolution becomes multiplication. The Fourier transform of a sinusoid $A \\sin(k x)$ consists of impulses at wavenumbers $+k$ and $-k$. The Fourier transform of the $1$D Gaussian kernel is $\\hat{G}_{1D}(k_x) = \\exp(-\\frac{\\sigma^2 k_x^2}{2})$. Applying this filter to the sinusoidal function scales its amplitude by the value of the transfer function at the specific wavenumber $k$.\nThe regularized interface shape, $f_{reg}(x)$, is therefore:\n$$\nf_{reg}(x) = A \\sin(k x) \\cdot \\exp\\left(-\\frac{\\sigma^2 k^2}{2}\\right)\n$$\nThe regularized level-set field is $\\phi_{reg}(x,y) = y - f_{reg}(x)$.\n\nNext, we analyze the effect of discrete differentiation. The problem states that curvature is computed using second-order central differences, and under the small-slope approximation, this reduces to computing the second derivative of the interface shape. Consistent with the true curvature approximation, the estimated curvature is $\\kappa_{est}(x) \\approx -\\delta_x^2[f_{reg}(x)]$, where $\\delta_x^2$ is the second-order central difference operator for the second derivative, defined as:\n$$\n\\delta_x^2[g(x)] = \\frac{g(x+h) - 2g(x) + g(x-h)}{h^2}\n$$\nWe apply this operator to $f_{reg}(x) = A \\exp(-\\frac{\\sigma^2 k^2}{2}) \\sin(k x)$. Let $A_{reg} = A \\exp(-\\frac{\\sigma^2 k^2}{2})$.\n$$\n\\delta_x^2[f_{reg}(x)] = A_{reg} \\left( \\frac{\\sin(k(x+h)) - 2\\sin(kx) + \\sin(k(x-h))}{h^2} \\right)\n$$\nUsing the trigonometric identity $\\sin(\\alpha+\\beta) + \\sin(\\alpha-\\beta) = 2\\sin(\\alpha)\\cos(\\beta)$, we get:\n$$\n\\delta_x^2[f_{reg}(x)] = A_{reg} \\left( \\frac{2\\sin(kx)\\cos(kh) - 2\\sin(kx)}{h^2} \\right) = A_{reg} \\sin(kx) \\left( \\frac{2(\\cos(kh)-1)}{h^2} \\right)\n$$\nUsing the half-angle identity $\\cos(\\theta) - 1 = -2\\sin^2(\\theta/2)$, the expression becomes:\n$$\n\\delta_x^2[f_{reg}(x)] = A_{reg} \\sin(kx) \\left( \\frac{2(-2\\sin^2(kh/2))}{h^2} \\right) = - A_{reg} \\sin(kx) \\left( \\frac{4\\sin^2(kh/2)}{h^2} \\right)\n$$\nThe estimated curvature is $\\kappa_{est}(x) \\approx -\\delta_x^2[f_{reg}(x)]$:\n$$\n\\kappa_{est}(x) \\approx - \\left( - A_{reg} \\sin(kx) \\left( \\frac{4\\sin^2(kh/2)}{h^2} \\right) \\right) = A_{reg} \\left( \\frac{4\\sin^2(kh/2)}{h^2} \\right) \\sin(kx)\n$$\nSubstituting back $A_{reg} = A \\exp(-\\frac{\\sigma^2 k^2}{2})$, we get:\n$$\n\\kappa_{est}(x) = A \\exp\\left(-\\frac{\\sigma^2 k^2}{2}\\right) \\left( \\frac{4\\sin^2(kh/2)}{h^2} \\right) \\sin(kx)\n$$\nThe amplitude of the estimated curvature is the coefficient of the sinusoidal term:\n$$\nK_{est} = A \\exp\\left(-\\frac{\\sigma^2 k^2}{2}\\right) \\frac{4\\sin^2(kh/2)}{h^2}\n$$\n\n**Step 3: Ratio of Amplitudes**\n\nFinally, we compute the ratio $R(h, \\sigma, k) = K_{est} / K_{true}$:\n$$\nR(h, \\sigma, k) = \\frac{A \\exp\\left(-\\frac{\\sigma^2 k^2}{2}\\right) \\frac{4\\sin^2(kh/2)}{h^2}}{A k^2}\n$$\nSimplifying the expression:\n$$\nR(h, \\sigma, k) = \\exp\\left(-\\frac{\\sigma^2 k^2}{2}\\right) \\frac{4\\sin^2(kh/2)}{k^2 h^2}\n$$\nThis can be rewritten in a more standard form by rearranging the denominator:\n$$\nR(h, \\sigma, k) = \\exp\\left(-\\frac{\\sigma^2 k^2}{2}\\right) \\left(\\frac{2\\sin(kh/2)}{kh}\\right)^2 = \\exp\\left(-\\frac{\\sigma^2 k^2}{2}\\right) \\left(\\frac{\\sin(kh/2)}{kh/2}\\right)^2\n$$\nThis expression, $R(h, \\sigma, k)$, represents the combined damping effect of the Gaussian regularization (the exponential term) and the second-order central difference scheme (the squared sinc-like term) on the amplitude of the computed curvature for a sinusoidal mode of wavenumber $k$.", "answer": "$$\\boxed{\\exp\\left(-\\frac{\\sigma^2 k^2}{2}\\right) \\left( \\frac{\\sin\\left(\\frac{kh}{2}\\right)}{\\frac{kh}{2}} \\right)^2}$$", "id": "3323621"}, {"introduction": "The ultimate test of a numerical method is its ability to accurately predict complex physical phenomena. This final practice challenges you to apply GFM principles to the incompressible Euler equations to model the Rayleigh–Taylor instability, a classic and crucial problem in fluid dynamics. You will derive the necessary ghost states from first principles and then analyze how numerical errors in the GFM scheme can directly impact the predicted physical growth rate of the instability, bridging the gap between numerical analysis and computational physics [@problem_id:3323627].", "problem": "You will design and verify a one-dimensional normal-direction Ghost Fluid Method (GFM) construction for a sharp interface between two incompressible, inviscid fluids of different densities, and then analyze how the Rayleigh–Taylor growth rate of a small-amplitude interfacial perturbation is affected by the order of extrapolation used to approximate curvature in the GFM. Your derivations and algorithm must start from first principles: the incompressible Euler equations and the classical jump conditions across a material interface with surface tension, without using any pre-derived ghost-fluid formulas.\n\nA single, planar computational stencil aligned with the interface normal is considered. The interface is locally curved with curvature $\\kappa$ and lies at normal coordinate $x = 0$. Fluid $1$ occupies $x \\lt 0$ with density $\\rho_1$, and Fluid $2$ occupies $x \\gt 0$ with density $\\rho_2$. The normal vector points from Fluid $1$ to Fluid $2$. Cell centers adjacent to the interface are located at $x=-h_1$ (in Fluid $1$) and $x=+h_2$ (in Fluid $2$), where $h_1 = \\theta \\, \\Delta$ and $h_2 = (1-\\theta)\\, \\Delta$ for grid spacing $\\Delta$ and $0 \\lt \\theta \\lt 1$. You may assume locally linear variation of pressure on each side over these distances.\n\nYour tasks are:\n\n1) Ghost-state design from first principles. Begin with the incompressible Euler equations and the interfacial jump conditions that follow from conservation of mass and momentum in the presence of surface tension. Use the dynamic condition that the pressure jump is equal to the product of surface tension and curvature, and the kinematic condition that the normal velocity is continuous. From these, derive appropriate local interface conditions for the pressure and its normal flux consistent with the variable-coefficient pressure Poisson equation arising in a projection method for incompressible flow. Using these interface conditions, derive explicit, closed-form expressions for the ghost pressure values $p_2(x=-h_1)$ and $p_1(x=+h_2)$ in terms of the known material parameters $\\rho_1$, $\\rho_2$, $\\sigma$, $\\kappa$, the distances $h_1$, $h_2$, and the known cell-centered pressures $p_1(x=-h_1)$ and $p_2(x=+h_2)$. Also, design a consistent ghost for the normal velocity that enforces the continuity of the normal velocity across the interface. You must derive these relations without using any shortcut formulas.\n\n2) Manufactured-solution verification. Consider a locally linear manufactured pressure field on each side of the interface, with an unknown interface pressure on side $1$, $p_{1,I}$, and normal gradients $g_1$ and $g_2$ such that $p_1(x) = p_{1,I} + g_1 x$ for $x \\le 0$ and $p_2(x) = p_{2,I} + g_2 x$ for $x \\ge 0$, where $p_{2,I} = p_{1,I} + \\sigma \\kappa$. Impose the flux continuity that is consistent with the variable-density projection operator, and show that your ghost-state formulas reproduce the exact manufactured ghost values at $x=-h_1$ and $x=+h_2$ when given $p_1(-h_1)$ and $p_2(+h_2)$ synthesized from the manufactured field. For the normal velocity, use a constant manufactured value near the interface and verify that your ghost construction is exact for this case.\n\n3) Rayleigh–Taylor (RT) linear growth with surface tension and sensitivity to curvature extrapolation order. Starting from the linearized, inviscid, incompressible two-phase formulation with a flat base state and a small sinusoidal perturbation of wavenumber $k$, derive the dispersion relation that connects the growth rate to the physical parameters. Then, propose a principled model for the effect of curvature-extrapolation error of order $m$ used in the Ghost Fluid Method. Assume the discrete curvature has a relative error of the form $\\varepsilon_\\kappa \\approx C (k \\Delta)^m$ with $C = 1$ (worst-case scaling), and show how this induces an effective surface tension $\\sigma_{\\text{eff}} = \\sigma \\left(1 + (k \\Delta)^m\\right)$ in the linear growth formula. Use this to compute the modified numerical growth rate, taking the physical acceleration due to gravity to be $g$ and the Atwood number to be $A = (\\rho_2 - \\rho_1)/(\\rho_2 + \\rho_1)$. Report the real growth rate $s$ in $\\text{s}^{-1}$ as $s = \\sqrt{\\max\\{0, g k A - (\\sigma_{\\text{eff}}/(\\rho_1+\\rho_2)) k^3\\}}$.\n\nUnits: Use the International System of Units (SI). Densities in $\\text{kg}/\\text{m}^3$, surface tension in $\\text{N}/\\text{m}$, curvature in $\\text{m}^{-1}$, pressure in $\\text{Pa}$, distances in $\\text{m}$, gravity $g$ in $\\text{m}/\\text{s}^2$, wavenumber $k$ in $\\text{m}^{-1}$, grid spacing in $\\text{m}$, velocity in $\\text{m}/\\text{s}$, and growth rates $s$ in $\\text{s}^{-1}$. Express growth rates rounded to six decimal places.\n\nTest suite: Your program must implement your derived ghost-state and RT-growth computations and evaluate the following four cases. For each case, the program must synthesize manufactured data, compute ghost states, check them against the manufactured truth, and compute the RT growth rate using the sensitivity model.\n\n- Case 1 (general): $\\rho_1 = 1.0$, $\\rho_2 = 2.0$, $\\sigma = 0.02$, $\\kappa = 100.0$, $p_{1,I} = 101325.0$, $g_1 = 1200.0$, $g_2 = (\\rho_2/\\rho_1) g_1$, $\\Delta = 0.005$, $\\theta = 0.3$ so $h_1 = \\theta \\Delta$ and $h_2 = (1-\\theta)\\Delta$, manufactured normal velocity $u_I = 0.5$ (constant near the interface), gravitational acceleration $g = 9.81$, wavenumber $k = 10.0$, extrapolation order $m = 1$.\n\n- Case 2 (zero Atwood, stabilized): $\\rho_1 = 1.0$, $\\rho_2 = 1.0$, $\\sigma = 0.02$, $\\kappa = 80.0$, $p_{1,I} = 100000.0$, $g_1 = 500.0$, $g_2 = (\\rho_2/\\rho_1) g_1$, $\\Delta = 0.004$, $\\theta = 0.45$, $u_I = 0.2$, $g = 9.81$, $k = 10.0$, $m = 2$.\n\n- Case 3 (marginal stability by design): $\\rho_1 = 1.0$, $\\rho_2 = 3.0$, $\\kappa = 50.0$, $p_{1,I} = 120000.0$, $g_1 = 1500.0$, $g_2 = (\\rho_2/\\rho_1) g_1$, $\\Delta = 0.005$, $\\theta = 0.2$, $u_I = 0.0$, $g = 9.81$, $k = 20.0$, $m = 2$, and surface tension chosen to make the growth rate exactly zero for the sensitivity model:\n$$\n\\sigma = \\frac{(\\rho_1+\\rho_2)\\, g \\, A}{k^2 \\left(1 + (k \\Delta)^m\\right)} \\quad \\text{with} \\quad A = \\frac{\\rho_2 - \\rho_1}{\\rho_1 + \\rho_2}.\n$$\n\n- Case 4 (higher-order extrapolation effect): Same as Case 1 except the extrapolation order is $m = 3$. To test ghost reconstruction under different local geometry, use the parameters $\\kappa = 120.0$, $p_{1,I} = 100800.0$, $g_1 = 1000.0$, $g_2 = (\\rho_2/\\rho_1) g_1$, $\\theta = 0.6$.\n\nManufactured data and checks: For each case, synthesize\n- $p_1(-h_1) = p_{1,I} - g_1 h_1$,\n- $p_2(+h_2) = p_{2,I} + g_2 h_2$ with $p_{2,I} = p_{1,I} + \\sigma \\kappa$,\n- exact ghost values $p_2(-h_1) = p_{2,I} - g_2 h_1$ and $p_1(+h_2) = p_{1,I} + g_1 h_2$,\n- normal velocities $u_1(-h_1) = u_2(+h_2) = u_I$.\nUse your derived ghost-state formulas to compute numerical ghost values and check them against the exact manufactured values with an absolute tolerance of $10^{-10}$. For the velocity, verify that your ghost construction yields exactly $u_I$ at both ghost locations for this constant manufactured field.\n\nRequired final output format: Your program should produce a single line of output containing a comma-separated Python list with twelve entries in the following strict order:\n[ghost_p_ok_case1, ghost_u_ok_case1, s_case1, ghost_p_ok_case2, ghost_u_ok_case2, s_case2, ghost_p_ok_case3, ghost_u_ok_case3, s_case3, ghost_p_ok_case4, ghost_u_ok_case4, s_case4]\nwhere each ghost flag is a boolean and each growth rate s is a float rounded to six decimal places in units of s^{-1}.", "solution": "The user has provided a comprehensive problem in computational fluid dynamics, focusing on the Ghost Fluid Method (GFM) for sharp interfaces. The problem requires derivations from first principles, verification using the method of manufactured solutions, and an analysis of numerical stability. The problem is well-posed, scientifically grounded, and contains all necessary information.\n\n### Part 1: Ghost-State Design from First Principles\n\nWe are tasked with deriving the ghost-fluid states for pressure and normal velocity at a sharp interface between two incompressible, inviscid fluids.\n\n**1.1. Pressure Ghost State**\n\nThe model is one-dimensional, with the interface at $x=0$. Fluid 1 (density $\\rho_1$) is in $x0$, and Fluid 2 (density $\\rho_2$) is in $x0$. We assume locally linear pressure profiles:\n$p_1(x) = p_{1,I} + g_1 x$ for $x \\le 0$\n$p_2(x) = p_{2,I} + g_2 x$ for $x \\ge 0$\nwhere $p_{1,I}$ and $p_{2,I}$ are the interface pressures on each side, and $g_1, g_2$ are the constant pressure gradients.\n\nThe derivation is based on three fundamental conditions at the interface ($x=0$):\n1.  **Dynamic Condition (Pressure Jump)**: The pressure jump is balanced by surface tension $\\sigma$ and curvature $\\kappa$. The normal vector points from Fluid 1 to Fluid 2. The standard convention is that pressure is higher on the concave side. For a bulge into Fluid 2 (positive curvature $\\kappa$ by some conventions), Fluid 1 is on the concave side, so $p_1  p_2$. This would imply $p_2 - p_1 = -\\sigma\\kappa$. However, the problem statement specifies $[p] = p_2 - p_1 = \\sigma\\kappa$. We proceed with this given condition, which, combined with the standard Rayleigh-Taylor dispersion relation provided later, implies a certain sign convention for $\\kappa$ that is internally consistent.\n    $p_2(0) - p_1(0) = p_{2,I} - p_{1,I} = \\sigma\\kappa$.\n\n2.  **Flux Continuity**: For a variable-density projection method, the pressure-gradient-over-density term in the momentum equation must be continuous in the normal direction to ensure mass conservation at the interface. This gives the condition on the normal pressure flux:\n    $[\\frac{1}{\\rho}\\frac{\\partial p}{\\partial n}] = 0 \\implies \\frac{1}{\\rho_2}\\frac{dp_2}{dx}\\bigg|_{x=0} = \\frac{1}{\\rho_1}\\frac{dp_1}{dx}\\bigg|_{x=0} \\implies \\frac{g_2}{\\rho_2} = \\frac{g_1}{\\rho_1}$.\n\n3.  **Consistency with Cell-Centered Values**: The linear profiles must match the known pressures $p_1(-h_1)$ and $p_2(h_2)$ at the adjacent cell centers.\n    $p_1(-h_1) = p_{1,I} - g_1 h_1 \\implies p_{1,I} = p_1(-h_1) + g_1 h_1$.\n    $p_2(h_2) = p_{2,I} + g_2 h_2 \\implies p_{2,I} = p_2(h_2) - g_2 h_2$.\n\nWe have a system of four linear equations for the four unknowns ($p_{1,I}, p_{2,I}, g_1, g_2$). We can solve for the gradients $g_1$ and $g_2$. First, substitute the expressions for $p_{1,I}$ and $p_{2,I}$ into the pressure jump condition:\n$(p_2(h_2) - g_2 h_2) - (p_1(-h_1) + g_1 h_1) = \\sigma\\kappa$.\nRearranging gives: $p_2(h_2) - p_1(-h_1) - \\sigma\\kappa = g_1 h_1 + g_2 h_2$.\nNow, use the flux continuity condition $g_2 = (\\rho_2/\\rho_1) g_1$ to eliminate $g_2$:\n$p_2(h_2) - p_1(-h_1) - \\sigma\\kappa = g_1 h_1 + (\\frac{\\rho_2}{\\rho_1}g_1) h_2 = g_1 \\left(h_1 + \\frac{\\rho_2}{\\rho_1} h_2\\right)$.\nSolving for $g_1$ yields:\n$$g_1 = \\frac{p_2(h_2) - p_1(-h_1) - \\sigma\\kappa}{h_1 + (\\rho_2/\\rho_1) h_2}$$\nAnd for $g_2$:\n$$g_2 = \\frac{\\rho_2}{\\rho_1} g_1 = \\frac{p_2(h_2) - p_1(-h_1) - \\sigma\\kappa}{(\\rho_1/\\rho_2) h_1 + h_2}$$\n\nThe ghost pressures are found by extrapolating the linear profiles into the opposite fluid domains.\nThe ghost pressure for Fluid 1 (at cell center $x=-h_1$) is the value of Fluid 2's pressure field at that location, $p_2(-h_1)$:\n$$p_{2,G} = p_2(-h_1) = p_{2,I} - g_2 h_1 = (p_2(h_2) - g_2 h_2) - g_2 h_1 = p_2(h_2) - g_2(h_1+h_2)$$\nThe ghost pressure for Fluid 2 (at cell center $x=h_2$) is the value of Fluid 1's pressure field at that location, $p_1(h_2)$:\n$$p_{1,G} = p_1(h_2) = p_{1,I} + g_1 h_2 = (p_1(-h_1) + g_1 h_1) + g_1 h_2 = p_1(-h_1) + g_1(h_1+h_2)$$\nThese derived expressions are complete and closed-form.\n\n**1.2. Velocity Ghost State**\n\nThe kinematic condition is the continuity of the normal velocity: $u_1(0) = u_2(0) = u_I$. A standard and robust GFM construction for a continuous variable is to first estimate the interface value $u_I$ and then use this value for the ghost states. We estimate $u_I$ by linear interpolation of the cell-centered values $u_1(-h_1)$ and $u_2(h_2)$:\n$$u_I = \\frac{h_2 \\, u_1(-h_1) + h_1 \\, u_2(h_2)}{h_1+h_2}$$\nThe ghost values are then defined by constant extrapolation from the interface, which simply means setting them to the interface value:\n$u_{2,G} = u_2(-h_1) = u_I$\n$u_{1,G} = u_1(h_2) = u_I$\nThis ensures that any subsequent interpolation across the interface will recover the continuous value $u_I$.\n\n### Part 2: Manufactured-Solution Verification\n\nWe verify the derived GFM formulas using a manufactured solution that satisfies the underlying continuous equations exactly.\nThe pressure fields are $p_1(x) = p_{1,I} + g_1 x$ and $p_2(x) = p_{2,I} + g_2 x$, with $p_{2,I} = p_{1,I} + \\sigma \\kappa$ and $g_2/\\rho_2 = g_1/\\rho_1$.\nThe inputs to our GFM formulas are the cell-centered data synthesized from this solution:\n$p_{1, \\text{in}} = p_1(-h_1) = p_{1,I} - g_1 h_1$\n$p_{2, \\text{in}} = p_2(h_2) = p_{2,I} + g_2 h_2$\nSubstituting these into our derived formula for $g_1$:\n$g_{1, \\text{GFM}} = \\frac{(p_{2,I} + g_2 h_2) - (p_{1,I} - g_1 h_1) - \\sigma\\kappa}{h_1 + (\\rho_2/\\rho_1) h_2} = \\frac{(p_{2,I}-p_{1,I}) + g_1 h_1 + g_2 h_2 - \\sigma\\kappa}{h_1 + (\\rho_2/\\rho_1) h_2}$\nUsing $p_{2,I}-p_{1,I} = \\sigma\\kappa$ and $g_2 = (\\rho_2/\\rho_1)g_1$:\n$g_{1, \\text{GFM}} = \\frac{\\sigma\\kappa + g_1 h_1 + (\\rho_2/\\rho_1)g_1 h_2 - \\sigma\\kappa}{h_1 + (\\rho_2/\\rho_1) h_2} = \\frac{g_1(h_1 + (\\rho_2/\\rho_1) h_2)}{h_1 + (\\rho_2/\\rho_1) h_2} = g_1$.\nThe GFM procedure exactly recovers the manufactured gradient. It follows that $g_{2, \\text{GFM}} = g_2$.\n\nNow we check the ghost pressures. For Fluid 1:\n$p_{2,G, \\text{GFM}} = p_{2, \\text{in}} - g_{2, \\text{GFM}}(h_1+h_2) = (p_{2,I} + g_2 h_2) - g_2(h_1+h_2) = p_{2,I} - g_2 h_1$.\nThe exact manufactured value is $p_2(-h_1) = p_{2,I} + g_2(-h_1) = p_{2,I} - g_2 h_1$. The result is exact.\nThe check for $p_{1,G}$ follows symmetrically and is also exact.\n\nFor velocity, the manufactured field is a constant, $u(x) = u_I$. The inputs are $u_1(-h_1) = u_I$ and $u_2(h_2) = u_I$.\nOur GFM construction gives the interface velocity:\n$u_{I, \\text{GFM}} = \\frac{h_2 \\, u_I + h_1 \\, u_I}{h_1+h_2} = u_I$.\nThe ghost values are then $u_{1,G} = u_{2,G} = u_I$. This matches the manufactured ghost values exactly.\n\n### Part 3: Rayleigh–Taylor Linear Growth Analysis\n\nThe classical dispersion relation for Rayleigh-Taylor instability of a planar interface separating two inviscid, incompressible fluids, including gravity $g$ and surface tension $\\sigma$, is:\n$$s^2 = \\frac{g k (\\rho_2 - \\rho_1) - \\sigma k^3}{\\rho_1 + \\rho_2}$$\nwhere $k$ is the wavenumber of the perturbation and $s$ is the growth rate. Unstable growth ($s^2  0$) occurs when the term $g(\\rho_2-\\rho_1)$ is positive (heavy fluid over light, $\\rho_2\\rho_1$) and large enough to overcome the stabilizing effect of surface tension. Using the Atwood number $A = (\\rho_2-\\rho_1)/(\\rho_2+\\rho_1)$, this becomes:\n$$s^2 = g k A - \\frac{\\sigma k^3}{\\rho_1+\\rho_2}$$\nThe problem posits that numerical error in computing curvature from the interface position introduces a relative error of order $m$, where $m$ is the order of the extrapolation scheme: $\\varepsilon_\\kappa = (k\\Delta)^m$. This error propagates into the pressure jump condition, which numerically behaves as if an effective surface tension $\\sigma_{\\text{eff}}$ is present:\n$[p]_{\\text{num}} = \\sigma\\kappa_{\\text{num}} = \\sigma\\kappa_{\\text{exact}}(1 + (k\\Delta)^m) \\implies \\sigma_{\\text{eff}} = \\sigma(1 + (k\\Delta)^m)$.\nSubstituting this into the dispersion relation gives the modeled numerical growth rate $s_{\\text{num}}$:\n$$s_{\\text{num}}^2 = g k A - \\frac{\\sigma_{\\text{eff}} k^3}{\\rho_1+\\rho_2} = g k A - \\frac{\\sigma(1+(k\\Delta)^m)k^3}{\\rho_1+\\rho_2}$$\nThe real growth rate is $s = \\sqrt{\\max(0, s_{\\text{num}}^2)}$. This provides a quantitative model to assess the impact of numerical discretization error on the physical stability of the system.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the execution for all test cases.\n    \"\"\"\n\n    # Test cases defined as dictionaries\n    test_cases = [\n        # Case 1 (general)\n        {\n            \"rho1\": 1.0, \"rho2\": 2.0, \"sigma\": 0.02, \"kappa\": 100.0,\n            \"p1_I\": 101325.0, \"g1\": 1200.0, \"Delta\": 0.005, \"theta\": 0.3,\n            \"u_I\": 0.5, \"g\": 9.81, \"k\": 10.0, \"m\": 1, \"case_id\": 1\n        },\n        # Case 2 (zero Atwood, stabilized)\n        {\n            \"rho1\": 1.0, \"rho2\": 1.0, \"sigma\": 0.02, \"kappa\": 80.0,\n            \"p1_I\": 100000.0, \"g1\": 500.0, \"Delta\": 0.004, \"theta\": 0.45,\n            \"u_I\": 0.2, \"g\": 9.81, \"k\": 10.0, \"m\": 2, \"case_id\": 2\n        },\n        # Case 3 (marginal stability by design)\n        {\n            \"rho1\": 1.0, \"rho2\": 3.0, \"sigma\": None, \"kappa\": 50.0,\n            \"p1_I\": 120000.0, \"g1\": 1500.0, \"Delta\": 0.005, \"theta\": 0.2,\n            \"u_I\": 0.0, \"g\": 9.81, \"k\": 20.0, \"m\": 2, \"case_id\": 3\n        },\n        # Case 4 (higher-order extrapolation effect)\n        {\n            \"rho1\": 1.0, \"rho2\": 2.0, \"sigma\": 0.02, \"kappa\": 120.0,\n            \"p1_I\": 100800.0, \"g1\": 1000.0, \"Delta\": 0.005, \"theta\": 0.6,\n            \"u_I\": 0.5, \"g\": 9.81, \"k\": 10.0, \"m\": 3, \"case_id\": 4\n        }\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result = process_case(params)\n        all_results.extend(result)\n    \n    print(f\"[{','.join(map(lambda x: str(x).lower() if isinstance(x, bool) else x, all_results))}]\")\n\n\ndef process_case(params):\n    \"\"\"\n    Processes a single test case, performs all calculations, and returns results.\n    \"\"\"\n    rho1, rho2 = params[\"rho1\"], params[\"rho2\"]\n    sigma, kappa = params[\"sigma\"], params[\"kappa\"]\n    p1_I = params[\"p1_I\"]\n    g1_manuf = params.get(\"g1\")\n    Delta, theta = params[\"Delta\"], params[\"theta\"]\n    u_I_manuf = params[\"u_I\"]\n    g_accel, k, m = params[\"g\"], params[\"k\"], params[\"m\"]\n    \n    # Calculate geometric and derived parameters\n    h1 = theta * Delta\n    h2 = (1 - theta) * Delta\n    g2_manuf = (rho2 / rho1) * g1_manuf\n    Atwood = (rho2 - rho1) / (rho2 + rho1)\n\n    # Handle Case 3: sigma is calculated for marginal stability\n    if sigma is None:\n        sigma_eff_target = (g_accel * Atwood * (rho1 + rho2)) / (k**2)\n        sigma = sigma_eff_target / (1 + (k * Delta)**m)\n    \n    # --- Part 1: Manufactured Solution Synthesis ---\n    \n    # Synthesize manufactured data at cell centers\n    p2_I = p1_I + sigma * kappa\n    p1_mh1_manuf = p1_I - g1_manuf * h1\n    p2_h2_manuf = p2_I + g2_manuf * h2\n    u1_mh1_manuf = u_I_manuf\n    u2_h2_manuf = u_I_manuf\n\n    # Synthesize exact ghost values\n    p2_ghost_exact = p2_I - g2_manuf * h1\n    p1_ghost_exact = p1_I + g1_manuf * h2\n    u_ghost_exact = u_I_manuf\n\n    # --- Part 2: Ghost State Computation using GFM formulas ---\n\n    # GFM for Pressure\n    g1_gfm = (p2_h2_manuf - p1_mh1_manuf - sigma * kappa) / (h1 + (rho2 / rho1) * h2)\n    g2_gfm = (rho2 / rho1) * g1_gfm\n    \n    p2_ghost_gfm = p2_h2_manuf - g2_gfm * (h1 + h2)\n    p1_ghost_gfm = p1_mh1_manuf + g1_gfm * (h1 + h2)\n\n    # GFM for Velocity\n    u_I_gfm = (h2 * u1_mh1_manuf + h1 * u2_h2_manuf) / (h1 + h2)\n    u_ghost_gfm = u_I_gfm\n\n    # --- Part 3: Verification ---\n    \n    tol = 1e-10\n    ghost_p_ok = np.allclose([p1_ghost_gfm, p2_ghost_gfm], [p1_ghost_exact, p2_ghost_exact], atol=tol)\n    ghost_u_ok = np.allclose(u_ghost_gfm, u_ghost_exact, atol=tol)\n    \n    # --- Part 4: Rayleigh-Taylor Growth Rate Calculation ---\n    \n    sigma_eff = sigma * (1 + (k * Delta)**m)\n    s_squared = g_accel * k * Atwood - (sigma_eff * k**3) / (rho1 + rho2)\n    s = np.sqrt(max(0, s_squared))\n    \n    # Format results for final output\n    return [ghost_p_ok, ghost_u_ok, f\"{s:.6f}\"]\n\nsolve()\n```", "id": "3323627"}]}