{"hands_on_practices": [{"introduction": "A central challenge in simulating multiphase flows is the numerical stiffness arising from strong interphase coupling. When momentum exchange is rapid, as in dense particle flows or bubbly liquids, explicit time-stepping schemes demand impractically small time steps for stability. This exercise guides you through the design and implementation of an Implicit-Explicit (IMEX) scheme, a powerful technique that treats the stiff drag term implicitly to ensure stability while keeping other terms explicit for efficiency [@problem_id:3336701]. By deriving the scheme and proving its key conservation and stability properties, you will gain hands-on experience with a foundational numerical method for robust two-fluid models.", "problem": "Consider a single-cell, one-dimensional, two-fluid model for interphase momentum exchange in Computational Fluid Dynamics (CFD). Two immiscible phases, a gas phase and a liquid phase, occupy volume fractions $\\alpha \\in (0,1)$ for gas and $1-\\alpha$ for liquid. The phase densities are constants $\\rho_{\\mathrm{g}}$ and $\\rho_{\\mathrm{l}}$ in $\\mathrm{kg/m^3}$, and the phase velocities are $u_{\\mathrm{g}}(t)$ and $u_{\\mathrm{l}}(t)$ in $\\mathrm{m/s}$. Interphase momentum exchange is modeled by a closure of the form $K(\\alpha)\\,(u_{\\mathrm{g}}-u_{\\mathrm{l}})$, where $K(\\alpha)$ has units $\\mathrm{kg/(m^3\\,s)}$ and is a nonnegative function of $\\alpha$. Neglect all other forces and sources. Let $m_{\\mathrm{g}}=\\alpha\\,\\rho_{\\mathrm{g}}$ and $m_{\\mathrm{l}}=(1-\\alpha)\\,\\rho_{\\mathrm{l}}$ denote the phase masses per unit volume.\n\nStarting from Newton’s second law for each phase and phase-wise momentum conservation, construct a first-order, time-advancement scheme over a time step $\\Delta t$ that treats the stiff interphase exchange term by an Implicit-Explicit (IMEX) strategy: all non-stiff or absent terms are explicit, and the interphase momentum exchange is handled semi-implicitly by evaluating the drag coefficient with a linearization that guarantees nonnegativity and treating the velocity difference implicitly. Use the following modeling choices as the fundamental base:\n- The phase momentum equations per unit volume are $m_{\\mathrm{g}}\\,\\dfrac{d u_{\\mathrm{g}}}{dt}=-K(\\alpha)\\,\\left(u_{\\mathrm{g}}-u_{\\mathrm{l}}\\right)$ and $m_{\\mathrm{l}}\\,\\dfrac{d u_{\\mathrm{l}}}{dt}=+K(\\alpha)\\,\\left(u_{\\mathrm{g}}-u_{\\mathrm{l}}\\right)$, which arise from Newton’s second law and the Newton’s third-law equal-and-opposite interphase action-reaction pair.\n- The semi-implicit linearization must evaluate $K(\\alpha)$ at known state to ensure $K^\\star \\ge 0$ so that the resulting discrete operator is positive definite and preserves positivity of the associated coefficients.\n- Two-fluid energy consistency means that the interphase work is internally exchanged and does not generate or destroy total mixture momentum, and the discrete kinetic energy per unit volume $E=\\dfrac{1}{2}\\left(m_{\\mathrm{g}}\\,u_{\\mathrm{g}}^2+m_{\\mathrm{l}}\\,u_{\\mathrm{l}}^2\\right)$ must be nonincreasing for any $\\Delta t > 0$ provided $K^\\star\\ge 0$.\n\nYour tasks:\n1. Derive, from the phase momentum balances and the IMEX design above, a coupled update for the velocities $u_{\\mathrm{g}}^{n+1}$ and $u_{\\mathrm{l}}^{n+1}$ over one time step from known $u_{\\mathrm{g}}^{n}$ and $u_{\\mathrm{l}}^{n}$, using $K^\\star=K(\\alpha^n)$ with $\\alpha^n=\\alpha$. Prove that the scheme conserves mixture momentum $m_{\\mathrm{g}}\\,u_{\\mathrm{g}}+m_{\\mathrm{l}}\\,u_{\\mathrm{l}}$ and that the discrete kinetic energy per unit volume does not increase, for any $\\Delta t > 0$ and any nonnegative $K^\\star$.\n2. Implement the derived update and compute $u_{\\mathrm{g}}^{n+1}$, $u_{\\mathrm{l}}^{n+1}$ in $\\mathrm{m/s}$ and $E^{n+1}$ in $\\mathrm{J/m^3}$ for each test case below. Use the closure $K(\\alpha)=K_0\\,\\alpha\\,(1-\\alpha)$ with $K_0$ in $\\mathrm{kg/(m^3\\,s)}$.\n3. Your program must produce a single line of output containing a list of results, one per test case, where each result is the triple $\\left[u_{\\mathrm{g}}^{n+1},u_{\\mathrm{l}}^{n+1},E^{n+1}\\right]$. The output must be a comma-separated list of these triples enclosed in square brackets, for example, $\\left[\\left[u_{\\mathrm{g}}^{(1)},u_{\\mathrm{l}}^{(1)},E^{(1)}\\right],\\left[u_{\\mathrm{g}}^{(2)},u_{\\mathrm{l}}^{(2)},E^{(2)}\\right],\\dots\\right]$.\n4. Express all velocities in $\\mathrm{m/s}$ and all energies in $\\mathrm{J/m^3}$ as plain decimal numbers without units in the output.\n\nTest suite (all quantities in coherent SI units):\n- Test A (moderate stiffness, asymmetric masses): $\\rho_{\\mathrm{g}}=5$, $\\rho_{\\mathrm{l}}=1000$, $\\alpha=0.2$, $u_{\\mathrm{g}}^{n}=2$, $u_{\\mathrm{l}}^{n}=0$, $K_0=1\\times 10^{5}$, $\\Delta t=1\\times 10^{-3}$.\n- Test B (stiff): same as Test A but $K_0=1\\times 10^{8}$.\n- Test C (no coupling): same as Test A but $K_0=0$.\n- Test D (near-pure gas fraction, balanced stiffness): $\\rho_{\\mathrm{g}}=1$, $\\rho_{\\mathrm{l}}=1000$, $\\alpha=0.999$, $u_{\\mathrm{g}}^{n}=10$, $u_{\\mathrm{l}}^{n}=-1$, $K_0=1\\times 10^{6}$, $\\Delta t=1\\times 10^{-3}$.\n- Test E (very large time step with strong coupling): $\\rho_{\\mathrm{g}}=5$, $\\rho_{\\mathrm{l}}=1000$, $\\alpha=0.2$, $u_{\\mathrm{g}}^{n}=2$, $u_{\\mathrm{l}}^{n}=0$, $K_0=1\\times 10^{6}$, $\\Delta t=5\\times 10^{-1}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of triples enclosed in square brackets, for example: $\\left[\\left[u_{\\mathrm{g}}^{(A)},u_{\\mathrm{l}}^{(A)},E^{(A)}\\right],\\left[u_{\\mathrm{g}}^{(B)},u_{\\mathrm{l}}^{(B)},E^{(B)}\\right],\\left[u_{\\mathrm{g}}^{(C)},u_{\\mathrm{l}}^{(C)},E^{(C)}\\right],\\left[u_{\\mathrm{g}}^{(D)},u_{\\mathrm{l}}^{(D)},E^{(D)}\\right],\\left[u_{\\mathrm{g}}^{(E)},u_{\\mathrm{l}}^{(E)},E^{(E)}\\right]\\right]$.", "solution": "The problem is validated as self-contained, scientifically grounded, and well-posed. All provided data are consistent and sufficient for deriving a unique solution.\n\n### Step 1: Extract Givens\n- **Phases:** Gas (g) and Liquid (l), immiscible.\n- **Volume fractions:** Gas $\\alpha \\in (0,1)$, Liquid $1-\\alpha$.\n- **Densities:** Constant phase densities $\\rho_{\\mathrm{g}}$ and $\\rho_{\\mathrm{l}}$ ($\\mathrm{kg/m^3}$).\n- **Velocities:** Phase velocities $u_{\\mathrm{g}}(t)$ and $u_{\\mathrm{l}}(t)$ ($\\mathrm{m/s}$).\n- **Phase masses per unit volume:** $m_{\\mathrm{g}}=\\alpha\\,\\rho_{\\mathrm{g}}$, $m_{\\mathrm{l}}=(1-\\alpha)\\,\\rho_{\\mathrm{l}}$.\n- **Interphase momentum exchange term:** $K(\\alpha)\\,(u_{\\mathrm{g}}-u_{\\mathrm{l}})$, where $K(\\alpha)$ has units $\\mathrm{kg/(m^3\\,s)}$ and is nonnegative.\n- **Phase momentum equations (per unit volume):**\n  - $m_{\\mathrm{g}}\\,\\dfrac{d u_{\\mathrm{g}}}{dt}=-K(\\alpha)\\,\\left(u_{\\mathrm{g}}-u_{\\mathrm{l}}\\right)$\n  - $m_{\\mathrm{l}}\\,\\dfrac{d u_{\\mathrm{l}}}{dt}=+K(\\alpha)\\,\\left(u_{\\mathrm{g}}-u_{\\mathrm{l}}\\right)$\n- **Numerical scheme:** First-order, time-advancement over $\\Delta t$. IMEX strategy where non-stiff terms are explicit (none present) and the stiff interphase term is semi-implicit.\n- **Semi-implicit treatment:** $K(\\alpha)$ is evaluated at the known state $n$, i.e., $K^\\star=K(\\alpha^n)$. The velocity difference $u_{\\mathrm{g}}-u_{\\mathrm{l}}$ is evaluated at the future state $n+1$.\n- **Kinetic energy per unit volume:** $E=\\dfrac{1}{2}\\left(m_{\\mathrm{g}}\\,u_{\\mathrm{g}}^2+m_{\\mathrm{l}}\\,u_{\\mathrm{l}}^2\\right)$.\n- **Drag closure:** $K(\\alpha)=K_0\\,\\alpha\\,(1-\\alpha)$.\n- **Tasks:**\n  1. Derive the update for $(u_{\\mathrm{g}}^{n+1}, u_{\\mathrm{l}}^{n+1})$ from $(u_{\\mathrm{g}}^{n}, u_{\\mathrm{l}}^{n})$.\n  2. Prove conservation of mixture momentum $m_{\\mathrm{g}}\\,u_{\\mathrm{g}}+m_{\\mathrm{l}}\\,u_{\\mathrm{l}}$.\n  3. Prove non-increasing kinetic energy $E$ for any $\\Delta t > 0$ and $K^\\star\\ge 0$.\n  4. Implement the scheme and compute $(u_{\\mathrm{g}}^{n+1}, u_{\\mathrm{l}}^{n+1}, E^{n+1})$ for the given test cases.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded:** The problem is based on Newton's second and third laws applied to a two-fluid model, a standard and fundamental approach in multiphase flow theory and CFD. The concepts of momentum a conservation, kinetic energy, and interphase drag are central to fluid dynamics. The IMEX scheme is a well-established numerical technique for stiff ordinary differential equations (ODEs). The problem is scientifically sound.\n- **Well-Posed:** The problem provides a complete set of ODEs, initial conditions, and a clear directive for the numerical discretization. This setup leads to a solvable linear system for the updated velocities, ensuring a unique solution exists. The proofs required are standard for analyzing the stability and conservation properties of numerical schemes. The problem is well-posed.\n- **Objective:** The problem is stated using precise mathematical and physical terminology, free from ambiguity or subjective claims. The tasks are specific and quantifiable.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete solution will be provided.\n\n### 1. Derivation of the IMEX Scheme\nWe begin with the provided system of ordinary differential equations for the phase velocities $u_{\\mathrm{g}}(t)$ and $u_{\\mathrm{l}}(t)$:\n$$m_{\\mathrm{g}}\\,\\dfrac{d u_{\\mathrm{g}}}{dt}=-K(\\alpha)\\,\\left(u_{\\mathrm{g}}-u_{\\mathrm{l}}\\right)$$\n$$m_{\\mathrm{l}}\\,\\dfrac{d u_{\\mathrm{l}}}{dt}=+K(\\alpha)\\,\\left(u_{\\mathrm{g}}-u_{\\mathrm{l}}\\right)$$\nWe discretize these equations in time using a first-order scheme over a time step $\\Delta t$. Let $u^n$ denote the value of a variable $u$ at time $t^n$ and $u^{n+1}$ at time $t^{n+1}=t^n+\\Delta t$. The time derivative is approximated by a forward difference, $\\frac{du}{dt} \\approx \\frac{u^{n+1}-u^n}{\\Delta t}$.\n\nFollowing the IMEX strategy, the non-stiff terms (in this case, absent) are treated explicitly, while the stiff interphase momentum exchange term is treated semi-implicitly. This means the drag coefficient $K(\\alpha)$ is evaluated at the known time level $n$, denoted as $K^\\star=K(\\alpha^n)$, and the velocity difference is evaluated at the unknown time level $n+1$. The discretized equations are:\n$$m_{\\mathrm{g}}\\,\\frac{u_{\\mathrm{g}}^{n+1}-u_{\\mathrm{g}}^{n}}{\\Delta t}=-K^\\star\\,\\left(u_{\\mathrm{g}}^{n+1}-u_{\\mathrm{l}}^{n+1}\\right)$$\n$$m_{\\mathrm{l}}\\,\\frac{u_{\\mathrm{l}}^{n+1}-u_{\\mathrm{l}}^{n}}{\\Delta t}=+K^\\star\\,\\left(u_{\\mathrm{g}}^{n+1}-u_{\\mathrm{l}}^{n+1}\\right)$$\nThese are two coupled linear equations for the unknown velocities $u_{\\mathrm{g}}^{n+1}$ and $u_{\\mathrm{l}}^{n+1}$. We rearrange them to group the unknowns on the left-hand side:\n$$m_{\\mathrm{g}}\\left(u_{\\mathrm{g}}^{n+1}-u_{\\mathrm{g}}^{n}\\right) + \\Delta t K^\\star\\left(u_{\\mathrm{g}}^{n+1}-u_{\\mathrm{l}}^{n+1}\\right) = 0$$\n$$m_{\\mathrm{l}}\\left(u_{\\mathrm{l}}^{n+1}-u_{\\mathrm{l}}^{n}\\right) - \\Delta t K^\\star\\left(u_{\\mathrm{g}}^{n+1}-u_{\\mathrm{l}}^{n+1}\\right) = 0$$\nThis can be written in matrix form as:\n$$\n\\begin{pmatrix}\nm_{\\mathrm{g}} + \\Delta t K^\\star  -\\Delta t K^\\star \\\\\n-\\Delta t K^\\star  m_{\\mathrm{l}} + \\Delta t K^\\star\n\\end{pmatrix}\n\\begin{pmatrix}\nu_{\\mathrm{g}}^{n+1} \\\\\nu_{\\mathrm{l}}^{n+1}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nm_{\\mathrm{g}} u_{\\mathrm{g}}^{n} \\\\\nm_{\\mathrm{l}} u_{\\mathrm{l}}^{n}\n\\end{pmatrix}\n$$\nTo solve this $2 \\times 2$ system, we can find the inverse of the matrix. The determinant of the coefficient matrix is:\n$$\\det(A) = (m_{\\mathrm{g}} + \\Delta t K^\\star)(m_{\\mathrm{l}} + \\Delta t K^\\star) - (-\\Delta t K^\\star)^2 = m_{\\mathrm{g}}m_{\\mathrm{l}} + m_{\\mathrm{g}}\\Delta t K^\\star + m_{\\mathrm{l}}\\Delta t K^\\star + (\\Delta t K^\\star)^2 - (\\Delta t K^\\star)^2$$\n$$\\det(A) = m_{\\mathrm{g}}m_{\\mathrm{l}} + \\Delta t K^\\star(m_{\\mathrm{g}} + m_{\\mathrm{l}})$$\nSince $m_{\\mathrm{g}}, m_{\\mathrm{l}}  0$, $\\Delta t > 0$, and $K^\\star \\ge 0$, the determinant is strictly positive, ensuring a unique solution exists. Applying the inverse matrix yields the explicit expressions for the updated velocities:\n$$\n\\begin{pmatrix}\nu_{\\mathrm{g}}^{n+1} \\\\\nu_{\\mathrm{l}}^{n+1}\n\\end{pmatrix}\n=\n\\frac{1}{m_{\\mathrm{g}}m_{\\mathrm{l}} + \\Delta t K^\\star(m_{\\mathrm{g}} + m_{\\mathrm{l}})}\n\\begin{pmatrix}\nm_{\\mathrm{l}} + \\Delta t K^\\star  \\Delta t K^\\star \\\\\n\\Delta t K^\\star  m_{\\mathrm{g}} + \\Delta t K^\\star\n\\end{pmatrix}\n\\begin{pmatrix}\nm_{\\mathrm{g}} u_{\\mathrm{g}}^{n} \\\\\nm_{\\mathrm{l}} u_{\\mathrm{l}}^{n}\n\\end{pmatrix}\n$$\nExpanding this gives the final update formulas:\n$$u_{\\mathrm{g}}^{n+1} = \\frac{(m_{\\mathrm{l}} + \\Delta t K^\\star)m_{\\mathrm{g}} u_{\\mathrm{g}}^{n} + (\\Delta t K^\\star)m_{\\mathrm{l}} u_{\\mathrm{l}}^{n}}{m_{\\mathrm{g}}m_{\\mathrm{l}} + \\Delta t K^\\star(m_{\\mathrm{g}} + m_{\\mathrm{l}})}$$\n$$u_{\\mathrm{l}}^{n+1} = \\frac{(\\Delta t K^\\star)m_{\\mathrm{g}} u_{\\mathrm{g}}^{n} + (m_{\\mathrm{g}} + \\Delta t K^\\star)m_{\\mathrm{l}} u_{\\mathrm{l}}^{n}}{m_{\\mathrm{g}}m_{\\mathrm{l}} + \\Delta t K^\\star(m_{\\mathrm{g}} + m_{\\mathrm{l}})}$$\n\n### 2. Proof of Momentum Conservation\nTo prove that the total mixture momentum is conserved, we sum the two discretized momentum equations:\n$$m_{\\mathrm{g}}\\,\\frac{u_{\\mathrm{g}}^{n+1}-u_{\\mathrm{g}}^{n}}{\\Delta t} + m_{\\mathrm{l}}\\,\\frac{u_{\\mathrm{l}}^{n+1}-u_{\\mathrm{l}}^{n}}{\\Delta t} = -K^\\star\\,\\left(u_{\\mathrm{g}}^{n+1}-u_{\\mathrm{l}}^{n+1}\\right) + K^\\star\\,\\left(u_{\\mathrm{g}}^{n+1}-u_{\\mathrm{l}}^{n+1}\\right) = 0$$\nMultiplying by $\\Delta t$ gives:\n$$m_{\\mathrm{g}}(u_{\\mathrm{g}}^{n+1}-u_{\\mathrm{g}}^{n}) + m_{\\mathrm{l}}(u_{\\mathrm{l}}^{n+1}-u_{\\mathrm{l}}^{n}) = 0$$\nRearranging the terms, we get:\n$$m_{\\mathrm{g}}u_{\\mathrm{g}}^{n+1} + m_{\\mathrm{l}}u_{\\mathrm{l}}^{n+1} = m_{\\mathrm{g}}u_{\\mathrm{g}}^{n} + m_{\\mathrm{l}}u_{\\mathrm{l}}^{n}$$\nThis equality shows that the mixture momentum per unit volume at time $t^{n+1}$ is identical to that at time $t^n$. Thus, the scheme is conservative with respect to mixture momentum.\n\n### 3. Proof of Energy Stability (Non-Increasing Kinetic Energy)\nThe total kinetic energy of the mixture per unit volume is given by $E = \\frac{1}{2}(m_{\\mathrm{g}}u_{\\mathrm{g}}^2 + m_{\\mathrm{l}}u_{\\mathrm{l}}^2)$. We can decompose this energy into two parts: the kinetic energy of the center-of-mass motion and the kinetic energy of the relative motion between the phases.\nLet $M_{tot} = m_{\\mathrm{g}}+m_{\\mathrm{l}}$ be the total mass per unit volume and $u_c = \\frac{m_{\\mathrm{g}}u_{\\mathrm{g}}+m_{\\mathrm{l}}u_{\\mathrm{l}}}{M_{tot}}$ be the center-of-mass velocity. The total momentum is $M_{tot}u_c$. As shown above, mixture momentum is conserved, so $u_c^{n+1}=u_c^{n}$.\nThe kinetic energy can be expressed as:\n$$E = \\frac{1}{2}M_{tot}u_c^2 + \\frac{1}{2}\\mu(\\Delta u)^2$$\nwhere $\\mu = \\frac{m_{\\mathrm{g}}m_{\\mathrm{l}}}{m_{\\mathrm{g}}+m_{\\mathrm{l}}}$ is the reduced mass per unit volume and $\\Delta u = u_{\\mathrm{g}}-u_{\\mathrm{l}}$ is the relative velocity.\nThe change in kinetic energy from $t^n$ to $t^{n+1}$ is:\n$$\\Delta E = E^{n+1} - E^n = \\left(\\frac{1}{2}M_{tot}(u_c^{n+1})^2 + \\frac{1}{2}\\mu(\\Delta u^{n+1})^2\\right) - \\left(\\frac{1}{2}M_{tot}(u_c^{n})^2 + \\frac{1}{2}\\mu(\\Delta u^{n})^2\\right)$$\nSince $u_c^{n+1}=u_c^{n}$, this simplifies to:\n$$\\Delta E = \\frac{1}{2}\\mu\\left((\\Delta u^{n+1})^2 - (\\Delta u^{n})^2\\right)$$\nTo evaluate this, we derive an update equation for the relative velocity $\\Delta u$. We divide the first discretized momentum equation by $m_{\\mathrm{g}}$ and the second by $m_{\\mathrm{l}}$, then subtract the second from the first:\n$$\\frac{u_{\\mathrm{g}}^{n+1}-u_{\\mathrm{g}}^{n}}{\\Delta t} - \\frac{u_{\\mathrm{l}}^{n+1}-u_{\\mathrm{l}}^{n}}{\\Delta t} = -\\frac{K^\\star}{m_{\\mathrm{g}}}(u_{\\mathrm{g}}^{n+1}-u_{\\mathrm{l}}^{n+1}) - \\frac{K^\\star}{m_{\\mathrm{l}}}(u_{\\mathrm{g}}^{n+1}-u_{\\mathrm{l}}^{n+1})$$\n$$\\frac{(u_{\\mathrm{g}}^{n+1}-u_{\\mathrm{l}}^{n+1})-(u_{\\mathrm{g}}^{n}-u_{\\mathrm{l}}^{n})}{\\Delta t} = -K^\\star\\left(\\frac{1}{m_{\\mathrm{g}}}+\\frac{1}{m_{\\mathrm{l}}}\\right)(u_{\\mathrm{g}}^{n+1}-u_{\\mathrm{l}}^{n+1})$$\nUsing $\\Delta u^k = u_{\\mathrm{g}}^{k}-u_{\\mathrm{l}}^{k}$:\n$$\\frac{\\Delta u^{n+1}-\\Delta u^{n}}{\\Delta t} = -K^\\star\\left(\\frac{m_{\\mathrm{g}}+m_{\\mathrm{l}}}{m_{\\mathrm{g}}m_{\\mathrm{l}}}\\right)\\Delta u^{n+1}$$\n$$\\Delta u^{n+1} \\left(1 + \\Delta t K^\\star \\frac{m_{\\mathrm{g}}+m_{\\mathrm{l}}}{m_{\\mathrm{g}}m_{\\mathrm{l}}}\\right) = \\Delta u^n$$\n$$\\Delta u^{n+1} = \\frac{\\Delta u^n}{1 + \\frac{\\Delta t K^\\star}{\\mu}}$$\nLet $\\gamma = \\left(1 + \\frac{\\Delta t K^\\star}{\\mu}\\right)^{-1}$. Since $\\Delta t > 0$, $K^\\star \\ge 0$, and $\\mu > 0$, we have $0  \\gamma \\le 1$. Specifically, $\\gamma=1$ if $K^\\star=0$, and $\\gamma \\to 0$ as $\\Delta t K^\\star \\to \\infty$.\nNow substitute $\\Delta u^{n+1} = \\gamma \\Delta u^n$ into the expression for $\\Delta E$:\n$$\\Delta E = \\frac{1}{2}\\mu\\left((\\gamma \\Delta u^{n})^2 - (\\Delta u^{n})^2\\right) = \\frac{1}{2}\\mu(\\Delta u^{n})^2(\\gamma^2-1)$$\nSince $0  \\gamma \\le 1$, we have $\\gamma^2-1 \\le 0$. Also, $\\mu > 0$ and $(\\Delta u^n)^2 \\ge 0$. Therefore, $\\Delta E \\le 0$ for any $\\Delta t > 0$ and $K^\\star \\ge 0$. This proves that the discrete kinetic energy is non-increasing, ensuring the numerical stability of the scheme. The energy is only dissipated by the interphase drag, which is physically correct.\n\n### 4. Implementation Details\nThe Python implementation will define a function that takes the physical parameters for a single test case as input. Inside this function:\n1.  It calculates the phase masses per unit volume, $m_{\\mathrm{g}}$ and $m_{\\mathrm{l}}$.\n2.  It calculates the semi-implicit drag coefficient $K^\\star = K_0 \\alpha (1-\\alpha)$.\n3.  It implements the derived explicit formulas for $u_{\\mathrm{g}}^{n+1}$ and $u_{\\mathrm{l}}^{n+1}$. A special case for $K_0=0$ (and thus $K^\\star=0$) can be handled, where the velocities remain unchanged, though the general formula is robust and handles this case correctly.\n4.  It calculates the new kinetic energy $E^{n+1} = \\frac{1}{2}(m_{\\mathrm{g}}(u_{\\mathrm{g}}^{n+1})^2 + m_{\\mathrm{l}}(u_{\\mathrm{l}}^{n+1})^2)$.\n5.  The main part of the script will iterate through the provided test suite, call the calculation function for each case, and collect the results.\n6.  Finally, it will format the collected results into the specified string format `[[...],[...],...]` and print it to standard output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the two-fluid model problem for all test cases.\n    \"\"\"\n\n    # Test suite (all quantities in coherent SI units):\n    # (rho_g, rho_l, alpha, u_g_n, u_l_n, K0, dt)\n    test_cases = [\n        # Test A: moderate stiffness, asymmetric masses\n        (5.0, 1000.0, 0.2, 2.0, 0.0, 1.0e5, 1.0e-3),\n        # Test B: stiff\n        (5.0, 1000.0, 0.2, 2.0, 0.0, 1.0e8, 1.0e-3),\n        # Test C: no coupling\n        (5.0, 1000.0, 0.2, 2.0, 0.0, 0.0, 1.0e-3),\n        # Test D: near-pure gas fraction, balanced stiffness\n        (1.0, 1000.0, 0.999, 10.0, -1.0, 1.0e6, 1.0e-3),\n        # Test E: very large time step with strong coupling\n        (5.0, 1000.0, 0.2, 2.0, 0.0, 1.0e6, 5.0e-1)\n    ]\n\n    results = []\n    for case in test_cases:\n        result_triple = calculate_update(*case)\n        results.append(list(result_triple))\n\n    # Format the final output as a comma-separated list of triples\n    # enclosed in square brackets. Example: [[a,b,c],[d,e,f]]\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\ndef calculate_update(rho_g, rho_l, alpha, u_g_n, u_l_n, K0, dt):\n    \"\"\"\n    Calculates the updated velocities and kinetic energy for a single time step.\n\n    Parameters:\n    rho_g (float): Gas density [kg/m^3]\n    rho_l (float): Liquid density [kg/m^3]\n    alpha (float): Gas volume fraction\n    u_g_n (float): Gas velocity at time n [m/s]\n    u_l_n (float): Liquid velocity at time n [m/s]\n    K0 (float): Drag coefficient constant [kg/(m^3 s)]\n    dt (float): Time step size [s]\n\n    Returns:\n    tuple: (u_g_n1, u_l_n1, E_n1)\n           u_g_n1: Gas velocity at time n+1 [m/s]\n           u_l_n1: Liquid velocity at time n+1 [m/s]\n           E_n1: Kinetic energy at time n+1 [J/m^3]\n    \"\"\"\n\n    # Calculate phase masses per unit volume\n    m_g = alpha * rho_g\n    m_l = (1.0 - alpha) * rho_l\n\n    # Calculate semi-implicit drag parameter\n    K_star = K0 * alpha * (1.0 - alpha)\n\n    # If there is no coupling, velocities do not change.\n    # This check avoids potential division by zero if m_g or m_l were zero,\n    # though the problem constraints ensure they are positive. The general\n    # formula below is also valid for K_star = 0.\n    if K_star == 0.0:\n        u_g_n1 = u_g_n\n        u_l_n1 = u_l_n\n    else:\n        # Denominator of the update formula\n        denominator = m_g * m_l + dt * K_star * (m_g + m_l)\n\n        # Numerator for u_g_n1\n        num_g = (m_l + dt * K_star) * m_g * u_g_n + (dt * K_star) * m_l * u_l_n\n\n        # Numerator for u_l_n1\n        num_l = (dt * K_star) * m_g * u_g_n + (m_g + dt * K_star) * m_l * u_l_n\n\n        # Updated velocities\n        u_g_n1 = num_g / denominator\n        u_l_n1 = num_l / denominator\n\n    # Calculate the new kinetic energy per unit volume\n    E_n1 = 0.5 * (m_g * u_g_n1**2 + m_l * u_l_n1**2)\n\n    return u_g_n1, u_l_n1, E_n1\n\n# Run the solver\nsolve()\n```", "id": "3336701"}, {"introduction": "Beyond simple drag, more sophisticated closures are needed to capture the complex physics of particle-fluid interaction. The Basset history force is a prime example, accounting for the fluid's \"memory\" of a particle's past acceleration due to the slow diffusion of vorticity. This practice demystifies this complex term by guiding you through its implementation, focusing on the numerical challenge of its mathematical form: a convolution integral with a weak singularity [@problem_id:3336752]. You will develop a robust quadrature method that analytically handles the singularity, a critical skill for accurately incorporating advanced physical models into simulations.", "problem": "Consider a single spherical particle immersed in a viscous, incompressible fluid. In Computational Fluid Dynamics (CFD), interphase momentum closures for particle-laden flows include a memory term that accounts for unsteady diffusion of vorticity in the fluid around the particle, often referred to as the Basset history force. Starting from the fundamental balance of linear momentum for the fluid and the classic Stokes flow solution for an impulsively started sphere, derive the memory convolution that links the particle–fluid slip acceleration to a retarded integral with a square-root singular kernel. Use the conservation of momentum for the fluid surrounding a sphere and the principle of superposition (linearity of Stokes flow) as your base. Explicitly define the slip velocity $\\mathbf{u}_s(t) = \\mathbf{u}_p(t) - \\mathbf{u}_f(t)$ and the slip acceleration $\\mathbf{a}_s(t) = \\mathrm{d}\\mathbf{u}_s/\\mathrm{d}t$.\n\nYour derivation should establish that the Basset history force can be written as a convolution with a weakly singular kernel in time that depends on the fluid kinematic viscosity, and that this convolution is structurally an Abel-type integral involving $\\mathbf{a}_s(t)$. Then, design a numerically stable and convergent algorithm to approximate this convolution without resorting to differentiation of noisy velocity data. The algorithm must:\n- Be based on a uniform time grid $t_j = j \\Delta t$.\n- Treat the slip acceleration $\\mathbf{a}_s(t)$ as piecewise constant over each interval $[t_{j-1}, t_j]$.\n- Integrate the singular kernel analytically over each interval to produce exact quadrature weights for the piecewise-constant approximation.\n- Produce the Basset history force at the final time $t_n = n \\Delta t$ as a finite sum with known weights.\n\nYou must implement the algorithm in a complete, runnable program that evaluates the Basset history force for the scalar slip motion aligned with a fixed axis. Assume a spherical particle of radius $r_p$ and a Newtonian fluid of density $\\rho_f$ and kinematic viscosity $\\nu$, with dynamic viscosity $\\mu_f = \\rho_f \\nu$. Express all forces in Newtons (N). Angles, if any appear, must be in radians. All percentages, if any appear, must be expressed as decimals.\n\nDefine the following three test cases (each is a separate parameter set) to evaluate and print the Basset history force at the specified final time. In each case, the particle acceleration $a_p(t)$ and the fluid acceleration $a_f(t)$ are given analytically, so the slip acceleration is $a_s(t) = a_p(t) - a_f(t)$ and the slip is colinear with a fixed axis. The program must compute and return the scalar magnitude of the Basset history force $F_B(t)$ at the specified final time.\n\n- Case 1 (Smooth, damped oscillation; \"happy path\"):\n  - Fluid parameters: $\\nu = 1.0 \\times 10^{-6} \\,\\mathrm{m^2/s}$, $\\rho_f = 1000 \\,\\mathrm{kg/m^3}$, $\\mu_f = \\rho_f \\nu$.\n  - Particle radius: $r_p = 5.0 \\times 10^{-5} \\,\\mathrm{m}$.\n  - Accelerations: $a_p(t) = A \\cos(\\omega t) \\exp(-\\beta t)$, $a_f(t) = 0$.\n  - Coefficients: $A = 2.0 \\,\\mathrm{m/s^2}$, $\\omega = 20.0 \\,\\mathrm{rad/s}$, $\\beta = 5.0 \\,\\mathrm{s^{-1}}$.\n  - Final time and grid: $t_{\\mathrm{final}} = 0.1 \\,\\mathrm{s}$, $\\Delta t = 5.0 \\times 10^{-5} \\,\\mathrm{s}$.\n\n- Case 2 (Finite ramp acceleration to rest; tests non-smooth change):\n  - Fluid parameters: $\\nu = 1.0 \\times 10^{-6} \\,\\mathrm{m^2/s}$, $\\rho_f = 1000 \\,\\mathrm{kg/m^3}$, $\\mu_f = \\rho_f \\nu$.\n  - Particle radius: $r_p = 5.0 \\times 10^{-5} \\,\\mathrm{m}$.\n  - Accelerations: $a_p(t) = a_0$ for $0 \\le t \\le t_r$ and $a_p(t) = 0$ for $t  t_r$, $a_f(t) = 0$.\n  - Coefficients: $a_0 = 1.0 \\,\\mathrm{m/s^2}$, $t_r = 0.01 \\,\\mathrm{s}$.\n  - Final time and grid: $t_{\\mathrm{final}} = 0.05 \\,\\mathrm{s}$, $\\Delta t = 1.0 \\times 10^{-4} \\,\\mathrm{s}$.\n\n- Case 3 (Near-initial-time behavior; tests handling of kernel singularity):\n  - Fluid parameters: $\\nu = 1.0 \\times 10^{-6} \\,\\mathrm{m^2/s}$, $\\rho_f = 1000 \\,\\mathrm{kg/m^3}$, $\\mu_f = \\rho_f \\nu$.\n  - Particle radius: $r_p = 5.0 \\times 10^{-5} \\,\\mathrm{m}$.\n  - Accelerations: $a_p(t) = A \\cos(\\omega t) \\exp(-\\beta t)$, $a_f(t) = 0$.\n  - Coefficients: $A = 2.0 \\,\\mathrm{m/s^2}$, $\\omega = 20.0 \\,\\mathrm{rad/s}$, $\\beta = 5.0 \\,\\mathrm{s^{-1}}$.\n  - Final time and grid: $t_{\\mathrm{final}} = 1.0 \\times 10^{-4} \\,\\mathrm{s}$, $\\Delta t = 1.0 \\times 10^{-6} \\,\\mathrm{s}$.\n\nIn all cases, compute $F_B(t_{\\mathrm{final}})$ in $\\mathrm{N}$ using your derived piecewise-constant-acceleration quadrature. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of Case 1, Case 2, Case 3, for example, $\\left[\\text{result1},\\text{result2},\\text{result3}\\right]$. Each entry must be a floating-point number representing Newtons.\n\nYour derivation and algorithmic design should also explain the numerical strategy for the weakly singular convolution, including why using slip acceleration avoids numerical differentiation of noisy velocities, how the analytical per-interval integration mitigates the end-point singularity at $\\tau \\to t$, and what considerations govern the choice of $\\Delta t$ for accuracy and stability.", "solution": "The problem statement is assessed to be valid. It is scientifically grounded in the well-established principles of low-Reynolds-number fluid dynamics, specifically the theory of unsteady Stokes flow around a sphere. The problem is well-posed, providing all necessary physical parameters, functional forms for motion, and numerical specifications to arrive at a unique, computable solution for each test case. It is an objective and formalizable problem directly relevant to the modeling of interphase momentum transfer in computational fluid dynamics. We may therefore proceed with the derivation and solution.\n\n### Theoretical Derivation of the Basset History Force\n\nThe Basset history force arises from the delayed response of the fluid to the acceleration of an immersed particle. This 'memory' effect is due to the slow, viscous diffusion of vorticity generated at the particle's surface into the surrounding fluid. The derivation of this force term relies on the linearity of the governing unsteady Stokes equations for the fluid, which permits the use of superposition through Duhamel's principle.\n\nWe begin with the fundamental solution for the force on a sphere following an impulsive start. If a sphere of radius $r_p$ is impulsively accelerated from rest to a constant slip velocity $\\mathbf{u}_s$ at time $t=0$ in a quiescent fluid of density $\\rho_f$ and dynamic viscosity $\\mu_f$, the resulting time-dependent force on the sphere includes a term that decays with time. This specific term, representing the unsteady viscous effects, is given by Basset's result:\n$$ \\mathbf{F}_{B, \\text{impulse}}(t) = \\frac{6 r_p^2 \\sqrt{\\pi \\rho_f \\mu_f}}{\\sqrt{t}} \\mathbf{u}_s $$\nThis expression gives the force response at time $t$ to an impulsive velocity change at time $t=0$.\n\nTo find the force for an arbitrary, continuous history of slip velocity $\\mathbf{u}_s(t)$, we consider the motion to be a continuum of infinitesimal impulsive velocity changes. At any time $\\tau$, the velocity changes by an amount $d\\mathbf{u}_s = \\frac{d\\mathbf{u}_s}{d\\tau}d\\tau = \\mathbf{a}_s(\\tau)d\\tau$, where $\\mathbf{a}_s(\\tau)$ is the slip acceleration at that instant.\n\nBy Duhamel's principle, the contribution of this infinitesimal impulse at time $\\tau$ to the total force at a later time $t  \\tau$ is found by applying the impulsive response kernel, shifted to the time of the impulse. The elapsed time is $t - \\tau$. Thus, the infinitesimal force contribution $d\\mathbf{F}_B(t)$ is:\n$$ d\\mathbf{F}_B(t) = \\frac{6 r_p^2 \\sqrt{\\pi \\rho_f \\mu_f}}{\\sqrt{t - \\tau}} d\\mathbf{u}_s(\\tau) = \\frac{6 r_p^2 \\sqrt{\\pi \\rho_f \\mu_f}}{\\sqrt{t - \\tau}} \\mathbf{a}_s(\\tau) d\\tau $$\n\nThe total Basset history force at time $t$ is the superposition (integral) of all such contributions from past accelerations, from $\\tau=0$ to $\\tau=t$:\n$$ \\mathbf{F}_B(t) = \\int_0^t \\frac{6 r_p^2 \\sqrt{\\pi \\rho_f \\mu_f}}{\\sqrt{t - \\tau}} \\mathbf{a}_s(\\tau) d\\tau $$\nUsing the definition of kinematic viscosity, $\\nu = \\mu_f / \\rho_f$, we can rewrite the coefficient:\n$$ \\mathbf{F}_B(t) = 6 \\rho_f r_p^2 \\sqrt{\\pi \\nu} \\int_0^t \\frac{\\mathbf{a}_s(\\tau)}{\\sqrt{t - \\tau}} d\\tau $$\nThis is the final form of the Basset history force. It is a convolution integral of the slip acceleration $\\mathbf{a}_s(t)$ with a kernel $K(t-\\tau) = (t-\\tau)^{-1/2}$. This type of integral, featuring a weakly singular kernel, is known as an Abel-type integral. The singularity at $\\tau = t$ is integrable.\n\n### Design of the Numerical Quadrature Scheme\n\nThe task is to numerically evaluate the Basset force for a scalar motion at a specific time $t_n = n \\Delta t$, where the time domain is discretized into a uniform grid $t_j = j \\Delta t$ for $j = 0, 1, ..., n$. The scalar force is:\n$$ F_B(t_n) = C \\int_0^{t_n} \\frac{a_s(\\tau)}{\\sqrt{t_n - \\tau}} d\\tau $$\nwhere the constant is $C = 6 \\rho_f r_p^2 \\sqrt{\\pi \\nu}$.\n\nWe discretize the integral by breaking the domain $[0, t_n]$ into $n$ subintervals $[t_{j-1}, t_j]$ for $j=1, \\dots, n$:\n$$ F_B(t_n) = C \\sum_{j=1}^{n} \\int_{t_{j-1}}^{t_j} \\frac{a_s(\\tau)}{\\sqrt{t_n - \\tau}} d\\tau $$\nAs stipulated, we assume the acceleration $a_s(\\tau)$ is piecewise constant over each interval. For higher accuracy, we approximate the constant value on the interval $[t_{j-1}, t_j]$ with the value at the interval's midpoint, $t_{j-1/2} = (j-0.5)\\Delta t$. This is a second-order accurate midpoint rule.\n$$ a_s(\\tau) \\approx a_s(t_{j-1/2}) \\quad \\text{for} \\quad \\tau \\in [t_{j-1}, t_j] $$\nWith this approximation, $a_s(t_{j-1/2})$ can be moved outside the integral for each term in the sum:\n$$ F_B(t_n) \\approx C \\sum_{j=1}^{n} a_s(t_{j-1/2}) \\int_{t_{j-1}}^{t_j} \\frac{d\\tau}{\\sqrt{t_n - \\tau}} $$\nThe integral can now be evaluated analytically. Let $I_j = \\int_{t_{j-1}}^{t_j} (t_n - \\tau)^{-1/2} d\\tau$.\n$$ I_j = \\left[ -2\\sqrt{t_n - \\tau} \\right]_{\\tau=t_{j-1}}^{\\tau=t_j} = -2\\sqrt{t_n - t_j} + 2\\sqrt{t_n - t_{j-1}} $$\nSubstituting $t_j = j\\Delta t$ and $t_n = n\\Delta t$:\n$$ I_j = 2\\left( \\sqrt{n\\Delta t - (j-1)\\Delta t} - \\sqrt{n\\Delta t - j\\Delta t} \\right) = 2\\sqrt{\\Delta t} \\left( \\sqrt{n - j + 1} - \\sqrt{n - j} \\right) $$\nThis expression defines the exact quadrature weight for the $j$-th interval. The complete numerical approximation for the Basset force is a finite sum with these known weights:\n$$ F_B(t_n) \\approx C \\sum_{j=1}^{n} a_s(t_{j-1/2}) \\left[ 2\\sqrt{\\Delta t} \\left( \\sqrt{n - j + 1} - \\sqrt{n - j} \\right) \\right] $$\nCombining the constants, we arrive at the final algorithm:\n$$ F_B(t_n) \\approx 12 \\rho_f r_p^2 \\sqrt{\\pi \\nu \\Delta t} \\sum_{j=1}^{n} a_s \\big( (j - 0.5)\\Delta t \\big) \\left( \\sqrt{n - j + 1} - \\sqrt{n - j} \\right) $$\n\n### Discussion of the Numerical Strategy\n\nThis algorithm is designed to be numerically robust and stable for several reasons.\n\nFirst, by formulating the history integral in terms of slip acceleration $a_s(t)$, it avoids the need for numerical differentiation of slip velocity $u_s(t)$. In practical CFD simulations or when processing experimental data, velocity signals are often noisy, and their differentiation drastically amplifies this noise, leading to large errors. Since $a_s(t)$ is often computed directly from the governing equation of motion for the particle (i.e., from the net force), this formulation is more direct and stable.\n\nSecond, the method explicitly handles the weak singularity in the kernel at $\\tau \\to t_n$. A naive quadrature rule that evaluates the integrand at grid points might fail or be very inaccurate near this singularity. By integrating the singular part of the kernel, $(t_n-\\tau)^{-1/2}$, analytically over each subinterval, we obtain finite, well-behaved quadrature weights. For the final interval $[t_{n-1}, t_n]$, the corresponding weight term for $j=n$ is $2\\sqrt{\\Delta t}(\\sqrt{1}-\\sqrt{0}) = 2\\sqrt{\\Delta t}$, which is finite and correctly captures the integrated effect of the singularity.\n\nFinally, the choice of the time step, $\\Delta t$, governs the accuracy of the method. The error in this quadrature is determined by how well the piecewise-constant (midpoint) approximation represents the true acceleration function $a_s(t)$. According to standard numerical analysis, the error of the midpoint rule scales with $(\\Delta t)^2$ and the second derivative of the function. Therefore, a smaller $\\Delta t$ is required to accurately resolve histories where the acceleration changes rapidly. As a direct quadrature method (not a time-marching scheme for a differential equation), it is inherently stable for any choice of $\\Delta t > 0$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the Basset history force for three test cases\n    based on a derived piecewise-constant acceleration quadrature.\n    \"\"\"\n\n    def calculate_basset_force(rho_f, nu, r_p, a_s_func, t_final, dt, func_params):\n        \"\"\"\n        Calculates the Basset history force F_B(t_final) using a numerical quadrature.\n\n        Args:\n            rho_f (float): Fluid density (kg/m^3).\n            nu (float): Fluid kinematic viscosity (m^2/s).\n            r_p (float): Particle radius (m).\n            a_s_func (callable): Function a_s(t, params) for slip acceleration.\n            t_final (float): The final time at which to compute the force (s).\n            dt (float): The time step size (s).\n            func_params (dict): Dictionary of parameters for a_s_func.\n\n        Returns:\n            float: The scalar Basset history force in Newtons (N).\n        \"\"\"\n        # Ensure n is an integer to avoid floating point issues in range\n        n = int(round(t_final / dt))\n        if not np.isclose(n * dt, t_final):\n            raise ValueError(\"t_final must be an integer multiple of dt.\")\n\n        # Pre-compute the constant coefficient for the summation\n        coeff = 12.0 * rho_f * r_p**2 * np.sqrt(np.pi * nu * dt)\n\n        # Vectorized calculation of the sum\n        j_vals = np.arange(1, n + 1)\n        \n        # Midpoint times for each interval\n        t_mid_vals = (j_vals - 0.5) * dt\n        \n        # Evaluate acceleration at all midpoint times\n        as_vals = a_s_func(t_mid_vals, **func_params)\n        \n        # Calculate kennel weights for each interval\n        weights = np.sqrt(n - j_vals + 1) - np.sqrt(n - j_vals)\n        \n        # Compute the sum\n        basset_sum = np.sum(as_vals * weights)\n\n        # Final force calculation\n        force = coeff * basset_sum\n        return force\n\n    # Define the acceleration functions for the test cases\n    def as_smooth_osc(t, A, omega, beta):\n        \"\"\"Case 1  3: Smooth, damped oscillation.\"\"\"\n        return A * np.cos(omega * t) * np.exp(-beta * t)\n\n    def as_finite_ramp(t, a0, tr):\n        \"\"\"Case 2: Finite ramp acceleration.\"\"\"\n        # This function works on numpy arrays\n        return np.where(t = tr, a0, 0.0)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"nu\": 1.0e-6, \"rho_f\": 1000.0, \"r_p\": 5.0e-5,\n            \"a_s_func\": as_smooth_osc,\n            \"func_params\": {\"A\": 2.0, \"omega\": 20.0, \"beta\": 5.0},\n            \"t_final\": 0.1, \"dt\": 5.0e-5\n        },\n        {\n            \"nu\": 1.0e-6, \"rho_f\": 1000.0, \"r_p\": 5.0e-5,\n            \"a_s_func\": as_finite_ramp,\n            \"func_params\": {\"a0\": 1.0, \"tr\": 0.01},\n            \"t_final\": 0.05, \"dt\": 1.0e-4\n        },\n        {\n            \"nu\": 1.0e-6, \"rho_f\": 1000.0, \"r_p\": 5.0e-5,\n            \"a_s_func\": as_smooth_osc,\n            \"func_params\": {\"A\": 2.0, \"omega\": 20.0, \"beta\": 5.0},\n            \"t_final\": 1.0e-4, \"dt\": 1.0e-6\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_basset_force(\n            case[\"rho_f\"],\n            case[\"nu\"],\n            case[\"r_p\"],\n            case[\"a_s_func\"],\n            case[\"t_final\"],\n            case[\"dt\"],\n            case[\"func_params\"]\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3336752"}, {"introduction": "Closure models, no matter how sophisticated, rely on empirical parameters that must be determined from experimental data. This final practice bridges the gap between simulation and reality by introducing a modern, data-driven approach to model calibration. Using Bayesian inference, you will not only estimate the parameters of momentum and mass transfer closures from sparse data but also quantify the uncertainty in those estimates [@problem_id:3336723]. This exercise provides a hands-on introduction to uncertainty quantification (UQ), a crucial skill for developing predictive simulations and assessing the confidence in their results.", "problem": "Consider a one-dimensional, steady, isothermal, two-fluid mixture where dispersed bubbles exchange momentum and species with the surrounding liquid. Use first principles to establish a simplified closure-based forward model, then perform Bayesian inference to calibrate interphase closures and quantify uncertainty given limited data, and finally propagate this uncertainty to two-fluid predictions for new operating conditions. All logarithms are the natural logarithm.\n\nStart from fundamental laws and core definitions:\n- Newton’s Second Law implies that the volumetric interphase momentum source density equals a drag-like coupling of phases; under a standard closure, write the scalar interphase momentum source as $S_m = K\\,\\lvert u_g - u_\\ell \\rvert$, with $K$ an unknown momentum exchange coefficient. The quantity $S_m$ has units $\\mathrm{N\\,m^{-3}}$ and $\\lvert u_g - u_\\ell \\rvert$ has units $\\mathrm{m\\,s^{-1}}$.\n- Species conservation with an interfacial transfer closure implies the volumetric interphase species transfer rate is $N = k_L\\,a_i\\,\\Delta C$, with $k_L$ the unknown liquid-side mass transfer coefficient, $a_i$ the unknown interfacial area density, and $\\Delta C$ the concentration driving force. The quantity $N$ has units $\\mathrm{kg\\,m^{-3}\\,s^{-1}}$, $k_L$ has units $\\mathrm{m\\,s^{-1}}$, $a_i$ has units $\\mathrm{m^{-1}}$, and $\\Delta C$ has units $\\mathrm{kg\\,m^{-3}}$.\n\nAssume that limited experimental measurements of $S_m$ and $N$ are available at known operating points. To enable linear-Gaussian Bayesian inference while preserving non-negativity and multiplicative structure, model measurement noise as additive Gaussian in log space. Specifically, define the parameter vector $\\boldsymbol{\\xi} = \\begin{bmatrix} \\log K \\\\ \\log k_L \\\\ \\log a_i \\end{bmatrix}$, and construct linear observation equations in $\\boldsymbol{\\xi}$ using the log-transformed forward closures:\n- For momentum data point $i$: $\\log S_{m,i} = \\log K + \\log \\lvert u_{\\mathrm{rel},i} \\rvert + \\varepsilon_i$, i.e., $\\underbrace{\\left(\\log S_{m,i} - \\log \\lvert u_{\\mathrm{rel},i} \\rvert\\right)}_{y_i} = \\begin{bmatrix}100\\end{bmatrix}\\boldsymbol{\\xi} + \\varepsilon_i$.\n- For mass transfer data point $j$: $\\log N_j = \\log k_L + \\log a_i + \\log \\Delta C_j + \\varepsilon_j$, i.e., $\\underbrace{\\left(\\log N_j - \\log \\Delta C_j\\right)}_{y_j} = \\begin{bmatrix}011\\end{bmatrix}\\boldsymbol{\\xi} + \\varepsilon_j$.\nAssume independent and identically distributed noise $\\varepsilon \\sim \\mathcal{N}(0,\\sigma^2)$ with known standard deviation $\\sigma$.\n\nAdopt a Gaussian prior for $\\boldsymbol{\\xi}$ with mean $\\boldsymbol{\\mu}_0$ and covariance $\\mathbf{\\Sigma}_0$, independent across components.\n\nFrom these foundations, perform Bayesian inference to compute the Gaussian posterior $\\mathcal{N}(\\boldsymbol{\\mu},\\mathbf{\\Sigma})$ for $\\boldsymbol{\\xi}$ given the experimental data. Then propagate the posterior uncertainty to predictive distributions for $S_m$ and $N$ at new operating conditions $(\\lvert u_{\\mathrm{rel}} \\rvert,\\Delta C)$ by noting that $S_m = \\lvert u_{\\mathrm{rel}} \\rvert \\exp(\\xi_1)$ and $N = \\Delta C \\exp(\\xi_2+\\xi_3)$, which are lognormal under the Gaussian posterior. Report predictive means and standard deviations.\n\nUse the following data and hyperparameters (all numbers are given explicitly; all logarithms are natural):\n- Prior mean and covariance in log-space:\n  - $\\boldsymbol{\\mu}_0 = \\begin{bmatrix} \\log(1000.0) \\\\ \\log(1.0\\times 10^{-4}) \\\\ \\log(150.0) \\end{bmatrix}$,\n  - $\\mathbf{\\Sigma}_0 = \\mathrm{diag}\\left([1.0^2,\\,1.0^2,\\,1.0^2]\\right)$.\n- Likelihood noise standard deviation in log-space: $\\sigma = 0.1$.\n- Momentum data (each pair is $\\lvert u_{\\mathrm{rel}} \\rvert$ in $\\mathrm{m\\,s^{-1}}$, $S_m$ in $\\mathrm{N\\,m^{-3}}$):\n  - $(0.05,\\,40.0)$,\n  - $(0.10,\\,80.0)$,\n  - $(0.20,\\,160.0)$.\n- Mass transfer data (each pair is $\\Delta C$ in $\\mathrm{kg\\,m^{-3}}$, $N$ in $\\mathrm{kg\\,m^{-3}\\,s^{-1}}$):\n  - $(0.5,\\,0.02)$,\n  - $(1.0,\\,0.04)$,\n  - $(0.2,\\,0.008)$.\n\nProduce posterior-predictive summaries for the following test suite of operating conditions (each pair is $(\\lvert u_{\\mathrm{rel}} \\rvert,\\Delta C)$):\n- Case $1$: $(0.12,\\,0.6)$,\n- Case $2$: $(0.0,\\,0.6)$,\n- Case $3$: $(0.08,\\,0.01)$.\n\nFor each case, compute and return:\n- The predictive mean of $S_m$ in $\\mathrm{N\\,m^{-3}}$,\n- The predictive standard deviation of $S_m$ in $\\mathrm{N\\,m^{-3}}$,\n- The predictive mean of $N$ in $\\mathrm{kg\\,m^{-3}\\,s^{-1}}$,\n- The predictive standard deviation of $N$ in $\\mathrm{kg\\,m^{-3}\\,s^{-1}}$.\n\nExpress all outputs in the specified physical units above. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[$result1,result2,result3$]$). Use the exact order:\n$[$$S_{m,\\mathrm{mean}}^{(1)}$, $S_{m,\\mathrm{std}}^{(1)}$, $N_{\\mathrm{mean}}^{(1)}$, $N_{\\mathrm{std}}^{(1)}$, $S_{m,\\mathrm{mean}}^{(2)}$, $S_{m,\\mathrm{std}}^{(2)}$, $N_{\\mathrm{mean}}^{(2)}$, $N_{\\mathrm{std}}^{(2)}$, $S_{m,\\mathrm{mean}}^{(3)}$, $S_{m,\\mathrm{std}}^{(3)}$, $N_{\\mathrm{mean}}^{(3)}$, $N_{\\mathrm{std}}^{(3)}$$]$.\n\nAll numerical answers must be returned as floating-point values in the units indicated above. No angles or percentages are involved in this problem.", "solution": "The user has provided a problem that requires Bayesian inference to calibrate parameters in computational fluid dynamics (CFD) closure models and then propagate the resulting uncertainty to new predictions. I will first validate the problem statement and then provide a complete solution.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n- **Parameter Vector**: $\\boldsymbol{\\xi} = \\begin{bmatrix} \\log K \\\\ \\log k_L \\\\ \\log a_i \\end{bmatrix}$\n- **Observation Model**: \n  - Momentum: $y_{m,i} = \\log S_{m,i} - \\log \\lvert u_{\\mathrm{rel},i} \\rvert = \\begin{bmatrix}100\\end{bmatrix}\\boldsymbol{\\xi} + \\varepsilon_i$\n  - Mass Transfer: $y_{N,j} = \\log N_j - \\log \\Delta C_j = \\begin{bmatrix}011\\end{bmatrix}\\boldsymbol{\\xi} + \\varepsilon_j$\n- **Noise Model**: $\\varepsilon \\sim \\mathcal{N}(0,\\sigma^2)$ with $\\sigma = 0.1$.\n- **Prior Distribution**: $\\boldsymbol{\\xi} \\sim \\mathcal{N}(\\boldsymbol{\\mu}_0, \\mathbf{\\Sigma}_0)$\n  - $\\boldsymbol{\\mu}_0 = \\begin{bmatrix} \\log(1000.0) \\\\ \\log(1.0\\times 10^{-4}) \\\\ \\log(150.0) \\end{bmatrix}$\n  - $\\mathbf{\\Sigma}_0 = \\mathrm{diag}\\left([1.0^2,\\,1.0^2,\\,1.0^2]\\right) = \\mathbf{I}_3$\n- **Momentum Data** $(\\lvert u_{\\mathrm{rel}} \\rvert, S_m)$: $(0.05, 40.0)$, $(0.10, 80.0)$, $(0.20, 160.0)$.\n- **Mass Transfer Data** $(\\Delta C, N)$: $(0.5, 0.02)$, $(1.0, 0.04)$, $(0.2, 0.008)$.\n- **Prediction Test Cases** $(\\lvert u_{\\mathrm{rel}} \\rvert, \\Delta C)$: $(0.12, 0.6)$, $(0.0, 0.6)$, $(0.08, 0.01)$.\n- **Required Outputs**: Predictive mean and standard deviation for $S_m$ and $N$ for each test case.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is scientifically grounded, using standard (albeit simplified) closure models for multiphase flow and a canonical Bayesian linear regression framework. The objective is clear and the language is precise. All necessary data and hyperparameters are provided, rendering the problem self-contained and well-posed. The special case of $\\lvert u_{\\mathrm{rel}} \\rvert = 0$ in the prediction phase does not invalidate the problem; it requires careful handling by reverting to the fundamental physical model $S_m = K \\lvert u_{\\mathrm{rel}} \\rvert$, which deterministically yields $S_m=0$. This is a feature of the physics, not a flaw in the problem description. The problem is relevant to the specified topic of interphase transfer closures. No flaws are identified.\n\n**Step 3: Verdict and Action**\n\nThe problem is valid. A full solution will be provided.\n\n### Solution Derivation\n\nThe problem is a standard Bayesian linear regression problem. The goal is to find the posterior distribution of the parameter vector $\\boldsymbol{\\xi}$ given a prior distribution and a set of observations.\n\n**1. Bayesian Linear Regression Framework**\n\nThe standard Bayesian linear model is defined as:\n- Prior: $\\boldsymbol{\\xi} \\sim \\mathcal{N}(\\boldsymbol{\\mu}_0, \\mathbf{\\Sigma}_0)$\n- Likelihood: $\\mathbf{y} = \\mathbf{H}\\boldsymbol{\\xi} + \\boldsymbol{\\varepsilon}$, where the noise $\\boldsymbol{\\varepsilon} \\sim \\mathcal{N}(\\mathbf{0}, \\mathbf{R})$.\n\nThe resulting posterior distribution for $\\boldsymbol{\\xi}$ given the observation vector $\\mathbf{y}$ is also Gaussian, $\\boldsymbol{\\xi}|\\mathbf{y} \\sim \\mathcal{N}(\\boldsymbol{\\mu}, \\mathbf{\\Sigma})$, with posterior covariance $\\mathbf{\\Sigma}$ and mean $\\boldsymbol{\\mu}$ given by:\n$$ \\mathbf{\\Sigma} = \\left(\\mathbf{\\Sigma}_0^{-1} + \\mathbf{H}^T \\mathbf{R}^{-1} \\mathbf{H}\\right)^{-1} $$\n$$ \\boldsymbol{\\mu} = \\mathbf{\\Sigma} \\left( \\mathbf{\\Sigma}_0^{-1} \\boldsymbol{\\mu}_0 + \\mathbf{H}^T \\mathbf{R}^{-1} \\mathbf{y} \\right) $$\n\n**2. Assembling the Model Components**\n\n- **Parameter Vector**: $\\boldsymbol{\\xi}$ is a $3 \\times 1$ vector.\n- **Prior**: $\\boldsymbol{\\mu}_0$ is given, and $\\mathbf{\\Sigma}_0 = \\mathbf{I}_3$, so $\\mathbf{\\Sigma}_0^{-1} = \\mathbf{I}_3$.\n- **Observations Vector $\\mathbf{y}$**: We have $3$ momentum and $3$ mass transfer data points, for a total of $M=6$ observations.\n  - From momentum data, $S_{m,i} / \\lvert u_{\\mathrm{rel},i} \\rvert = 40.0/0.05 = 80.0/0.10 = 160.0/0.20 = 800$.\n    The first three elements of $\\mathbf{y}$ are $y_i = \\log(800)$ for $i=1, 2, 3$.\n  - From mass transfer data, $N_j / \\Delta C_j = 0.02/0.5 = 0.04/1.0 = 0.008/0.2 = 0.04$.\n    The next three elements of $\\mathbf{y}$ are $y_j = \\log(0.04)$ for $j=4, 5, 6$.\n- **Observation Matrix $\\mathbf{H}$**: This is a $6 \\times 3$ matrix constructed by stacking the row vectors from the observation equations:\n  $$ \\mathbf{H} = \\begin{bmatrix} 1  0  0 \\\\ 1  0  0 \\\\ 1  0  0 \\\\ 0  1  1 \\\\ 0  1  1 \\\\ 0  1  1 \\end{bmatrix} $$\n- **Noise Covariance $\\mathbf{R}$**: The noise is i.i.d., so $\\mathbf{R} = \\sigma^2 \\mathbf{I}_6$ with $\\sigma=0.1$. Thus $\\mathbf{R}^{-1} = \\frac{1}{\\sigma^2} \\mathbf{I}_6 = 100 \\cdot \\mathbf{I}_6$.\n\n**3. Computing the Posterior Distribution $\\mathcal{N}(\\boldsymbol{\\mu}, \\mathbf{\\Sigma})$**\n\nFirst, compute the term $\\mathbf{H}^T \\mathbf{R}^{-1} \\mathbf{H}$:\n$$ \\mathbf{H}^T \\mathbf{R}^{-1} \\mathbf{H} = \\frac{1}{\\sigma^2} \\mathbf{H}^T \\mathbf{H} = 100 \\begin{bmatrix} 3  0  0 \\\\ 0  3  3 \\\\ 0  3  3 \\end{bmatrix} = \\begin{bmatrix} 300  0  0 \\\\ 0  300  300 \\\\ 0  300  300 \\end{bmatrix} $$\nNext, find the posterior precision matrix $\\mathbf{\\Sigma}^{-1}$:\n$$ \\mathbf{\\Sigma}^{-1} = \\mathbf{\\Sigma}_0^{-1} + \\mathbf{H}^T \\mathbf{R}^{-1} \\mathbf{H} = \\begin{bmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{bmatrix} + \\begin{bmatrix} 300  0  0 \\\\ 0  300  300 \\\\ 0  300  300 \\end{bmatrix} = \\begin{bmatrix} 301  0  0 \\\\ 0  301  300 \\\\ 0  300  301 \\end{bmatrix} $$\nInvert this matrix to find the posterior covariance $\\mathbf{\\Sigma}$:\n$$ \\mathbf{\\Sigma} = (\\mathbf{\\Sigma}^{-1})^{-1} = \\begin{bmatrix} 1/301  0  0 \\\\ 0  301/601  -300/601 \\\\ 0  -300/601  301/601 \\end{bmatrix} $$\nNow, compute the term $\\mathbf{H}^T \\mathbf{R}^{-1} \\mathbf{y}$:\n$$ \\mathbf{H}^T \\mathbf{R}^{-1} \\mathbf{y} = \\frac{1}{\\sigma^2} \\mathbf{H}^T \\mathbf{y} = 100 \\begin{bmatrix} 3\\log(800) \\\\ 3\\log(0.04) \\\\ 3\\log(0.04) \\end{bmatrix} = \\begin{bmatrix} 300\\log(800) \\\\ 300\\log(0.04) \\\\ 300\\log(0.04) \\end{bmatrix} $$\nFinally, compute the posterior mean $\\boldsymbol{\\mu}$:\n$$ \\boldsymbol{\\mu} = \\mathbf{\\Sigma} (\\mathbf{\\Sigma}_0^{-1} \\boldsymbol{\\mu}_0 + \\mathbf{H}^T \\mathbf{R}^{-1} \\mathbf{y}) = \\mathbf{\\Sigma} \\left( \\boldsymbol{\\mu}_0 + \\begin{bmatrix} 300\\log(800) \\\\ 300\\log(0.04) \\\\ 300\\log(0.04) \\end{bmatrix} \\right) $$\nSubstituting the numerical values for $\\boldsymbol{\\mu}_0$, $\\mathbf{\\Sigma}$, and the logs yields the posterior mean vector $\\boldsymbol{\\mu} = [\\mu_1, \\mu_2, \\mu_3]^T$.\n\n**4. Uncertainty Propagation to Predictions**\n\nThe quantities of interest, $S_m$ and $N$, are related to the exponentiated parameters. If a random variable $X \\sim \\mathcal{N}(\\mu_X, \\sigma_X^2)$, then $Y = C e^X$ follows a scaled log-normal distribution. Its mean and standard deviation are:\n$$ E[Y] = C \\exp(\\mu_X + \\sigma_X^2/2) $$\n$$ \\mathrm{StdDev}[Y] = C \\sqrt{\\exp(\\sigma_X^2) - 1} \\exp(\\mu_X + \\sigma_X^2/2) $$\n\n- **Momentum Prediction ($S_m$)**: For a new condition $u_{\\mathrm{rel}}^*$, the prediction is $S_m^* = u_{\\mathrm{rel}}^* \\exp(\\xi_1)$. Since $\\xi_1 \\sim \\mathcal{N}(\\mu_1, \\Sigma_{11})$, we can use the formulas above with $C=u_{\\mathrm{rel}}^*$, $\\mu_X=\\mu_1$, and $\\sigma_X^2=\\Sigma_{11}$.\nFor the special case $u_{\\mathrm{rel}}^*=0$, the physical model $S_m = K u_{\\mathrm{rel}}^*$ dictates that $S_m^*=0$ deterministically. The mean and standard deviation are both $0$.\n\n- **Mass Transfer Prediction ($N$)**: For a new condition $\\Delta C^*$, the prediction is $N^* = \\Delta C^* \\exp(\\xi_2 + \\xi_3)$. We define a new Gaussian variable $\\eta = \\xi_2 + \\xi_3 = \\mathbf{c}^T \\boldsymbol{\\xi}$ where $\\mathbf{c}=[0, 1, 1]^T$.\n  - The mean of $\\eta$ is $\\mu_\\eta = \\mathbf{c}^T \\boldsymbol{\\mu} = \\mu_2 + \\mu_3$.\n  - The variance of $\\eta$ is $\\sigma_\\eta^2 = \\mathbf{c}^T \\mathbf{\\Sigma} \\mathbf{c} = \\Sigma_{22} + \\Sigma_{33} + 2\\Sigma_{23}$.\nSubstituting the values from $\\mathbf{\\Sigma}$:\n$$ \\sigma_\\eta^2 = \\frac{301}{601} + \\frac{301}{601} + 2\\left(\\frac{-300}{601}\\right) = \\frac{602 - 600}{601} = \\frac{2}{601} $$\nWe can then use the log-normal formulas with $C=\\Delta C^*$, $\\mu_X=\\mu_\\eta$, and $\\sigma_X^2=\\sigma_\\eta^2$.\n\nThe final step is to implement these formulas numerically for the three specified test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs Bayesian inference to calibrate CFD closure models and propagates\n    uncertainty to new predictions.\n    \"\"\"\n\n    # 1. Define Givens from the problem statement\n    \n    # Prior distribution parameters for xi = [log(K), log(k_L), log(a_i)]\n    mu_0 = np.array([\n        np.log(1000.0),\n        np.log(1.0e-4),\n        np.log(150.0)\n    ])\n    Sigma_0 = np.diag([1.0**2, 1.0**2, 1.0**2])\n\n    # Likelihood noise standard deviation\n    sigma = 0.1\n    noise_var = sigma**2\n\n    # Experimental data\n    mom_data = [\n        (0.05, 40.0),\n        (0.10, 80.0),\n        (0.20, 160.0)\n    ]\n    mass_data = [\n        (0.5, 0.02),\n        (1.0, 0.04),\n        (0.2, 0.008)\n    ]\n\n    # Test cases for prediction\n    test_cases = [\n        (0.12, 0.6),  # Case 1\n        (0.0, 0.6),   # Case 2\n        (0.08, 0.01)  # Case 3\n    ]\n\n    # 2. Construct Bayesian Linear Regression Model Components\n\n    # Observation vector y\n    y_mom = [np.log(sm) - np.log(urel) for urel, sm in mom_data]\n    y_mass = [np.log(n) - np.log(dc) for dc, n in mass_data]\n    y = np.array(y_mom + y_mass)\n\n    # Observation matrix H\n    H = np.array([\n        [1, 0, 0], [1, 0, 0], [1, 0, 0],  # Momentum observations\n        [0, 1, 1], [0, 1, 1], [0, 1, 1]   # Mass transfer observations\n    ])\n\n    # Noise covariance R and its inverse\n    num_obs = len(y)\n    R_inv = np.identity(num_obs) / noise_var\n    \n    Sigma_0_inv = np.linalg.inv(Sigma_0)\n\n    # 3. Compute Posterior Distribution N(mu, Sigma)\n\n    # Posterior covariance Sigma\n    Sigma_inv = Sigma_0_inv + H.T @ R_inv @ H\n    Sigma = np.linalg.inv(Sigma_inv)\n\n    # Posterior mean mu\n    mu = Sigma @ (Sigma_0_inv @ mu_0 + H.T @ R_inv @ y)\n    \n    # 4. Propagate Uncertainty and Compute Predictive Statistics\n\n    results = []\n    \n    # Lognormal distribution properties\n    def lognormal_stats(C, mu_p, var_p):\n        \"\"\"Calculates mean and std dev for a scaled lognormal distribution.\"\"\"\n        if C == 0:\n            return 0.0, 0.0\n        \n        # Mean: C * exp(mu_p + var_p/2)\n        mean_val = C * np.exp(mu_p + var_p / 2.0)\n        \n        # Standard deviation: sqrt(exp(var_p) - 1) * Mean\n        # This is more numerically stable than the full formula for small var_p\n        # np.expm1(x) calculates exp(x) - 1\n        std_dev = np.sqrt(np.expm1(var_p)) * mean_val\n        \n        return mean_val, std_dev\n\n    for case in test_cases:\n        urel_star, delta_c_star = case\n\n        # --- Momentum Prediction (S_m) ---\n        # Special case: u_rel = 0 implies S_m = 0 deterministically\n        if urel_star == 0.0:\n            sm_mean, sm_std = 0.0, 0.0\n        else:\n            mu_p_sm = mu[0]\n            var_p_sm = Sigma[0, 0]\n            sm_mean, sm_std = lognormal_stats(urel_star, mu_p_sm, var_p_sm)\n        \n        # --- Mass Transfer Prediction (N) ---\n        # For N = dC * exp(xi_2 + xi_3), we need stats for eta = xi_2 + xi_3\n        # eta = c^T * xi, with c = [0, 1, 1]\n        c = np.array([0, 1, 1])\n        mu_p_n = c.T @ mu\n        var_p_n = c.T @ Sigma @ c\n        \n        n_mean, n_std = lognormal_stats(delta_c_star, mu_p_n, var_p_n)\n\n        results.extend([sm_mean, sm_std, n_mean, n_std])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3336723"}]}