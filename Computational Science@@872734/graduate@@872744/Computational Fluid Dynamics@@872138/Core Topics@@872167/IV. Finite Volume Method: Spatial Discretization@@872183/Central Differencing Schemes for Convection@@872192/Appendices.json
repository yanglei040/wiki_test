{"hands_on_practices": [{"introduction": "A powerful method for understanding the behavior of a numerical scheme is Fourier analysis, which decomposes a solution into its constituent wave components. This practice delves into the core properties of a finite difference scheme by deriving its modified wavenumber and numerical dissipation rate [@problem_id:3298191]. By analyzing how the scheme alters the phase (dispersion) and amplitude (dissipation) of each Fourier mode, we can gain deep insight into its performance, including the purely non-dissipative but dispersive nature of the central differencing scheme.", "problem": "Consider the one-dimensional linear advection equation, a canonical model in Computational Fluid Dynamics (CFD),\n$$\n\\frac{\\partial u}{\\partial t} + a\\,\\frac{\\partial u}{\\partial x} = 0,\n$$\nwith constant wave speed $a>0$ on a periodic domain. Discretize space on a uniform grid $x_j = j\\,\\Delta x$ with grid spacing $\\Delta x>0$, and consider the semi-discrete method-of-lines formulation\n$$\n\\frac{d u_j}{d t} = -\\,a\\,D_{\\alpha} u_j,\n$$\nwhere the spatial derivative operator $D_{\\alpha}$ is the convex blend of the second-order central difference and the first-order upwind (backward) difference,\n$$\nD_{\\alpha} u_j \\;=\\; (1-\\alpha)\\,\\frac{u_{j+1}-u_{j-1}}{2\\,\\Delta x} \\;+\\; \\alpha\\,\\frac{u_j-u_{j-1}}{\\Delta x},\n$$\nwith blending parameter $\\alpha \\in [0,1]$. Assume a Fourier mode (small-amplitude wave) ansatz with nondimensional wavenumber $\\theta \\in [-\\pi,\\pi]$,\n$$\nu_j(t) \\;=\\; \\widehat{u}(t)\\,\\exp\\!\\big(i\\,j\\,\\theta\\big),\n$$\nwhere $\\theta = k\\,\\Delta x$ and $k$ is the physical wavenumber. Define the modified wavenumber $k_{\\mathrm{mod}}(\\theta,\\alpha)$ and the damping rate $\\gamma(\\theta,\\alpha)$ as follows: when substituting the Fourier mode into the semi-discrete equation, the mode amplitude satisfies\n$$\n\\frac{d \\widehat{u}}{d t} \\;=\\; -\\,\\gamma(\\theta,\\alpha)\\,\\widehat{u} \\;-\\; i\\,a\\,k_{\\mathrm{mod}}(\\theta,\\alpha)\\,\\widehat{u},\n$$\nso that $k_{\\mathrm{mod}}(\\theta,\\alpha)$ encodes dispersion and $\\gamma(\\theta,\\alpha)$ encodes dissipation in the continuous-time semi-discrete evolution. Starting from these definitions and the given discretization, derive closed-form expressions for $k_{\\mathrm{mod}}(\\theta,\\alpha)$ and $\\gamma(\\theta,\\alpha)$ in terms of $\\theta$, $\\alpha$, $a$, and $\\Delta x$. Provide your final answer as a row matrix with the first entry equal to $k_{\\mathrm{mod}}(\\theta,\\alpha)$ and the second entry equal to $\\gamma(\\theta,\\alpha)$. No rounding is required; give exact expressions. No units are required in the final answer.", "solution": "The problem requires the derivation of the modified wavenumber $k_{\\mathrm{mod}}(\\theta,\\alpha)$ and the damping rate $\\gamma(\\theta,\\alpha)$ for a given semi-discretization of the one-dimensional linear advection equation.\n\nThe semi-discrete equation is given as:\n$$\n\\frac{d u_j}{d t} = -a D_{\\alpha} u_j\n$$\nwhere the spatial discretization operator $D_{\\alpha}$ is a convex blend of second-order central difference and first-order upwind difference:\n$$\nD_{\\alpha} u_j = (1-\\alpha)\\frac{u_{j+1}-u_{j-1}}{2\\Delta x} + \\alpha\\frac{u_j-u_{j-1}}{\\Delta x}\n$$\nWe analyze this scheme by substituting the Fourier mode ansatz $u_j(t) = \\widehat{u}(t)\\exp(ij\\theta)$, where $\\theta = k\\Delta x$ is the nondimensional wavenumber.\n\nFirst, let's evaluate the time derivative on the left-hand side (LHS) of the semi-discrete equation. The spatial part $\\exp(ij\\theta)$ is constant with respect to time $t$.\n$$\n\\text{LHS} = \\frac{d}{dt} \\left( \\widehat{u}(t)\\exp(ij\\theta) \\right) = \\frac{d\\widehat{u}}{dt}\\exp(ij\\theta)\n$$\n\nNext, we evaluate the action of the spatial operator $D_{\\alpha}$ on the ansatz for the right-hand side (RHS). To do this, we express the values at neighboring grid points, $u_{j+1}$ and $u_{j-1}$, in terms of $u_j$:\n$$\nu_{j+1}(t) = \\widehat{u}(t)\\exp(i(j+1)\\theta) = \\widehat{u}(t)\\exp(ij\\theta)\\exp(i\\theta) = u_j(t)\\exp(i\\theta)\n$$\n$$\nu_{j-1}(t) = \\widehat{u}(t)\\exp(i(j-1)\\theta) = \\widehat{u}(t)\\exp(ij\\theta)\\exp(-i\\theta) = u_j(t)\\exp(-i\\theta)\n$$\nSubstituting these expressions into the definition of $D_{\\alpha} u_j$:\n$$\nD_{\\alpha} u_j = (1-\\alpha)\\frac{u_j \\exp(i\\theta) - u_j \\exp(-i\\theta)}{2\\Delta x} + \\alpha\\frac{u_j - u_j \\exp(-i\\theta)}{\\Delta x}\n$$\nWe can factor out $u_j$ from the expression:\n$$\nD_{\\alpha} u_j = u_j \\left[ (1-\\alpha)\\frac{\\exp(i\\theta) - \\exp(-i\\theta)}{2\\Delta x} + \\alpha\\frac{1 - \\exp(-i\\theta)}{\\Delta x} \\right]\n$$\nUsing Euler's identities, $\\exp(i\\theta) - \\exp(-i\\theta) = 2i\\sin(\\theta)$ and $\\exp(-i\\theta) = \\cos(\\theta) - i\\sin(\\theta)$, we can simplify the terms in the brackets.\n$$\n\\frac{\\exp(i\\theta) - \\exp(-i\\theta)}{2\\Delta x} = \\frac{2i\\sin(\\theta)}{2\\Delta x} = \\frac{i\\sin(\\theta)}{\\Delta x}\n$$\n$$\n\\frac{1 - \\exp(-i\\theta)}{\\Delta x} = \\frac{1 - (\\cos(\\theta) - i\\sin(\\theta))}{\\Delta x} = \\frac{1-\\cos(\\theta) + i\\sin(\\theta)}{\\Delta x}\n$$\nSubstituting these back into the expression for $D_{\\alpha} u_j$:\n$$\nD_{\\alpha} u_j = u_j \\left[ (1-\\alpha)\\frac{i\\sin(\\theta)}{\\Delta x} + \\alpha\\frac{1-\\cos(\\theta) + i\\sin(\\theta)}{\\Delta x} \\right]\n$$\nNow, we collect the real and imaginary parts inside the bracket:\n$$\nD_{\\alpha} u_j = \\frac{u_j}{\\Delta x} \\left[ \\alpha(1-\\cos(\\theta)) + i(1-\\alpha)\\sin(\\theta) + i\\alpha\\sin(\\theta) \\right]\n$$\nThe imaginary terms combine:\n$$\nD_{\\alpha} u_j = \\frac{u_j}{\\Delta x} \\left[ \\alpha(1-\\cos(\\theta)) + i((1-\\alpha)+\\alpha)\\sin(\\theta) \\right]\n$$\n$$\nD_{\\alpha} u_j = \\frac{u_j}{\\Delta x} \\left[ \\alpha(1-\\cos(\\theta)) + i\\sin(\\theta) \\right]\n$$\nSubstitute back the ansatz $u_j = \\widehat{u}(t)\\exp(ij\\theta)$:\n$$\nD_{\\alpha} u_j = \\frac{\\widehat{u}(t)\\exp(ij\\theta)}{\\Delta x} \\left[ \\alpha(1-\\cos(\\theta)) + i\\sin(\\theta) \\right]\n$$\nNow we can write the full semi-discrete equation by equating the LHS and RHS:\n$$\n\\frac{d\\widehat{u}}{dt}\\exp(ij\\theta) = -a \\left( \\frac{\\widehat{u}(t)\\exp(ij\\theta)}{\\Delta x} \\left[ \\alpha(1-\\cos(\\theta)) + i\\sin(\\theta) \\right] \\right)\n$$\nThe common factor $\\exp(ij\\theta)$ cancels from both sides, yielding an ordinary differential equation for the mode amplitude $\\widehat{u}(t)$:\n$$\n\\frac{d\\widehat{u}}{dt} = -\\frac{a}{\\Delta x} \\left[ \\alpha(1-\\cos(\\theta)) + i\\sin(\\theta) \\right] \\widehat{u}(t)\n$$\nSeparating the terms in the bracket, we have:\n$$\n\\frac{d\\widehat{u}}{dt} = \\left[ -\\frac{a\\alpha(1-\\cos(\\theta))}{\\Delta x} - i\\frac{a\\sin(\\theta)}{\\Delta x} \\right] \\widehat{u}(t)\n$$\nThe problem defines the modified wavenumber $k_{\\mathrm{mod}}$ and damping rate $\\gamma$ via the relation:\n$$\n\\frac{d\\widehat{u}}{dt} = \\left[ -\\gamma(\\theta,\\alpha) - i a k_{\\mathrm{mod}}(\\theta,\\alpha) \\right] \\widehat{u}(t)\n$$\nBy comparing the derived equation for $\\frac{d\\widehat{u}}{dt}$ with this definitional form, we can identify $\\gamma(\\theta,\\alpha)$ and $k_{\\mathrm{mod}}(\\theta,\\alpha)$ by equating the real and imaginary parts of the coefficient of $\\widehat{u}(t)$.\n\nEquating the real parts:\n$$\n-\\gamma(\\theta,\\alpha) = -\\frac{a\\alpha(1-\\cos(\\theta))}{\\Delta x}\n$$\nSolving for $\\gamma(\\theta,\\alpha)$ gives the damping rate:\n$$\n\\gamma(\\theta,\\alpha) = \\frac{a\\alpha(1-\\cos(\\theta))}{\\Delta x}\n$$\n\nEquating the imaginary parts:\n$$\n-i a k_{\\mathrm{mod}}(\\theta,\\alpha) = -i\\frac{a\\sin(\\theta)}{\\Delta x}\n$$\nDividing by $-ia$ (since $a>0$) gives the modified wavenumber:\n$$\nk_{\\mathrm{mod}}(\\theta,\\alpha) = \\frac{\\sin(\\theta)}{\\Delta x}\n$$\nNote that the modified wavenumber $k_{\\mathrm{mod}}$ is independent of the blending parameter $\\alpha$, whereas the damping rate $\\gamma$ is directly proportional to $\\alpha$. For $\\alpha=0$ (pure central differencing), the damping is zero, as expected.\n\nThe final expressions are:\n$$\nk_{\\mathrm{mod}}(\\theta,\\alpha) = \\frac{\\sin(\\theta)}{\\Delta x}\n$$\n$$\n\\gamma(\\theta,\\alpha) = \\frac{a\\alpha(1-\\cos(\\theta))}{\\Delta x}\n$$", "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{\\sin(\\theta)}{\\Delta x} & \\frac{a\\alpha(1-\\cos(\\theta))}{\\Delta x} \\end{pmatrix}}\n$$", "id": "3298191"}, {"introduction": "Having theoretically established that central differencing is non-dissipative, we now turn to a practical verification of its high accuracy for smooth problems. This hands-on coding exercise employs the Method of Manufactured Solutions, a rigorous technique for verifying code and analyzing numerical error [@problem_id:3298150]. By simulating the advection of a simple sine wave and carefully separating the spatial error from the temporal error, you will numerically confirm the scheme's second-order convergence rate and observe how discretization errors accumulate in practice.", "problem": "Consider the linear advection equation with constant velocity on a periodic domain,\n$$\n\\frac{\\partial u}{\\partial t} + a \\,\\frac{\\partial u}{\\partial x} = 0,\\quad x \\in [0,2\\pi),\\ t \\ge 0,\n$$\nwith periodic boundary conditions. Let the manufactured exact solution be\n$$\nu(x,t) = \\sin(k x - a t),\n$$\nwhich is $2\\pi$-periodic in $x$ and uses radians for all angles. All variables are dimensionless. You will study the second-order central differencing scheme for convection on a uniform grid and quantify, at fixed Courant–Friedrichs–Lewy (CFL) number, the $L^2$ error versus the grid spacing $\\Delta x$, separating the spatial and temporal error contributions.\n\nStarting from the conservation law above and the definition of the second-order central difference operator on a uniform grid with spacing $\\Delta x$,\n$$\n(D_c u)_j \\equiv \\frac{u_{j+1} - u_{j-1}}{2\\,\\Delta x},\n$$\nthe method-of-lines semi-discrete system is\n$$\n\\frac{d \\mathbf{u}}{dt} = -a\\, D_c \\mathbf{u},\n$$\nwhere $\\mathbf{u}$ is the vector of nodal values on the periodic grid. For time integration, use the classical fourth-order Runge–Kutta method.\n\nYour program must, for each test case specified below, and for each grid size $N$ in a provided grid refinement set, compute the following quantities at a common final time $T$ while keeping the time step determined by a fixed Courant–Friedrichs–Lewy (CFL) number:\n- The spatial-only error, obtained by integrating the semi-discrete system exactly in time by diagonalizing the circulant central-difference operator in the discrete Fourier basis. This yields the exact-in-time semi-discrete solution $\\mathbf{u}_{\\text{space}}(T;\\Delta x)$, whose difference from the analytical solution sampled on the grid isolates spatial discretization error.\n- The temporal-only error, obtained by integrating in time with the classical fourth-order Runge–Kutta method while applying the exact spatial derivative operator at each stage via spectral differentiation on the periodic grid (i.e., using the discrete Fourier transform to compute the exact derivative $\\partial u/\\partial x$ for all Fourier modes representable on the grid). This yields $\\mathbf{u}_{\\text{time}}(T;\\Delta x)$, whose difference from the analytical solution sampled on the grid isolates temporal discretization error.\n- The total error, obtained by integrating in time with the classical fourth-order Runge–Kutta method while applying the second-order central difference operator at each stage. This yields $\\mathbf{u}_{\\text{total}}(T;\\Delta x)$, whose difference from the analytical solution sampled on the grid combines spatial and temporal errors.\n\nFor each numerical solution $\\mathbf{u}_{\\text{num}} \\in \\{\\mathbf{u}_{\\text{space}},\\mathbf{u}_{\\text{time}},\\mathbf{u}_{\\text{total}}\\}$, compute the discrete $L^2$ error with respect to the exact solution sampled on the grid,\n$$\nE_{L^2}(\\Delta x) \\equiv \\left(\\Delta x \\sum_{j=0}^{N-1} \\left[u_{\\text{num}}(x_j,T) - u(x_j,T)\\right]^2\\right)^{1/2},\n$$\nwhere $x_j = j\\,\\Delta x$ and $\\Delta x = \\frac{2\\pi}{N}$.\n\nTime stepping must use a time step $\\Delta t$ determined by the fixed Courant–Friedrichs–Lewy (CFL) number,\n$$\n\\Delta t = \\text{CFL}\\,\\frac{\\Delta x}{|a|},\n$$\nwith the final step shortened if necessary to land exactly at time $T$. Angles must be in radians.\n\nImplement the above in a complete, runnable program that, for each test case, returns for each grid size $N$ the tuple consisting of the grid spacing and the three $L^2$ errors:\n$$\n\\left[\\Delta x,\\ E^{\\text{space}}_{L^2}(\\Delta x),\\ E^{\\text{time}}_{L^2}(\\Delta x),\\ E^{\\text{total}}_{L^2}(\\Delta x)\\right].\n$$\n\nTest suite:\n- Case $1$: $a = 1.0$, $k = 4$, $\\text{CFL} = 0.5$, $T = 1.0$, $N \\in \\{64, 128, 256, 512\\}$.\n- Case $2$: $a = 1.0$, $k = 16$, $\\text{CFL} = 0.5$, $T = 1.0$, $N \\in \\{64, 128, 256, 512\\}$.\n- Case $3$: $a = 0.3$, $k = 3$, $\\text{CFL} = 0.9$, $T = 2.0$, $N \\in \\{64, 128, 256, 512\\}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a valid JSON array. The top level is a list over test cases in the order given above. Each test case contains a list over grid sizes $N$ in ascending order. Each element is the list $\\left[\\Delta x,E^{\\text{space}}_{L^2},E^{\\text{time}}_{L^2},E^{\\text{total}}_{L^2}\\right]$ for that $N$. For example, an output with two grid sizes would look like\n$$\n\\left[\\left[[\\Delta x_1,E^{\\text{space}}_{L^2}(\\Delta x_1),E^{\\text{time}}_{L^2}(\\Delta x_1),E^{\\text{total}}_{L^2}(\\Delta x_1)],\\ [\\Delta x_2,E^{\\text{space}}_{L^2}(\\Delta x_2),E^{\\text{time}}_{L^2}(\\Delta x_2),E^{\\text{total}}_{L^2}(\\Delta x_2)]\\right],\\ \\dots\\right]\n$$\nwith the actual numeric values filled in. All numbers must be printed as decimals in standard floating-point notation. Angles are in radians, and there are no physical units in this problem.", "solution": "The problem requires a numerical study of the error properties of a second-order central differencing scheme for the linear advection equation. The analysis involves separating the total numerical error into its spatial and temporal components. This is achieved by designing three distinct numerical experiments: one that is exact in time to isolate spatial error, one that is exact in space to isolate temporal error, and one that uses numerical approximations for both to capture the total error.\n\nThe governing partial differential equation (PDE) is the one-dimensional linear advection equation with constant velocity $a$:\n$$\n\\frac{\\partial u}{\\partial t} + a \\,\\frac{\\partial u}{\\partial x} = 0\n$$\nThe domain is periodic, $x \\in [0,2\\pi)$, and we consider time $t \\ge 0$. A manufactured solution is provided for verification and error analysis:\n$$\nu(x,t) = \\sin(k x - a t)\n$$\nwhere $k$ is the wavenumber. This solution is $2\\pi$-periodic in $x$ and satisfies the PDE.\n\nThe numerical solution is sought on a uniform grid of $N$ points, $x_j = j\\,\\Delta x$ for $j=0, 1, \\dots, N-1$, where the grid spacing is $\\Delta x = 2\\pi/N$. The method-of-lines (MOL) approach is employed, where the spatial derivatives are discretized first, resulting in a system of ordinary differential equations (ODEs) in time. The spatial discretization uses the second-order central difference operator, $D_c$:\n$$\n\\left(D_c u\\right)_j = \\frac{u_{j+1} - u_{j-1}}{2\\,\\Delta x}\n$$\nThis leads to the semi-discrete system:\n$$\n\\frac{d \\mathbf{u}}{dt} = -a\\, D_c \\mathbf{u}\n$$\nwhere $\\mathbf{u}(t)$ is the vector of nodal values $[u(x_0, t), u(x_1, t), \\dots, u(x_{N-1}, t)]^T$. For time integration, the classical fourth-order Runge–Kutta (RK4) method is specified. The time step, $\\Delta t$, is determined by a fixed Courant–Friedrichs–Lewy (CFL) number:\n$$\n\\Delta t = \\text{CFL}\\,\\frac{\\Delta x}{|a|}\n$$\nThe simulation runs until a final time $T$. The error is quantified using the discrete $L^2$ norm, defined as:\n$$\nE_{L^2}(\\Delta x) = \\left(\\Delta x \\sum_{j=0}^{N-1} \\left[u_{\\text{num}}(x_j,T) - u(x_j,T)\\right]^2\\right)^{1/2}\n$$\n\nThe core of the problem is to compute three types of error at the final time $T$.\n\n1.  **Spatial-Only Error ($E^{\\text{space}}_{L^2}$)**:\n    To isolate the error from spatial discretization, we solve the semi-discrete system $\\frac{d \\mathbf{u}}{dt} = -a D_c \\mathbf{u}$ exactly in time. This is a linear system of ODEs, $\\frac{d\\mathbf{u}}{dt} = \\mathbf{A} \\mathbf{u}$, where the matrix $\\mathbf{A}$ represents the operator $-a D_c$. The exact solution is $\\mathbf{u}(T) = e^{\\mathbf{A}T} \\mathbf{u}(0)$. The matrix exponential is computed efficiently by diagonalizing $\\mathbf{A}$ via the Discrete Fourier Transform (DFT), since $D_c$ is a circulant matrix on a periodic grid.\n    The eigenvalues of the operator $-a D_c$ are found by applying it to a Fourier mode $e^{imx}$, where $m$ is an integer wavenumber.\n    $$\n    -a D_c e^{imx} = -a \\frac{e^{im(x+\\Delta x)} - e^{im(x-\\Delta x)}}{2\\Delta x} = -a \\frac{i \\sin(m \\Delta x)}{\\Delta x} e^{imx}\n    $$\n    Thus, the eigenvalue $\\lambda_m$ corresponding to wavenumber $m$ is $\\lambda_m = -ia \\frac{\\sin(m \\Delta x)}{\\Delta x}$. This term is often called the symbol of the discrete operator. The exact evolution of each Fourier coefficient $\\hat{u}_m(t)$ is given by $\\frac{d\\hat{u}_m}{dt} = \\lambda_m \\hat{u}_m$, which yields $\\hat{u}_m(T) = \\hat{u}_m(0) e^{\\lambda_m T}$.\n    The algorithm is as follows:\n    a. Compute the initial condition vector $\\mathbf{u}(0)$ by sampling $u(x,0)=\\sin(kx)$ on the grid.\n    b. Compute its DFT to obtain the initial Fourier coefficients, $\\hat{\\mathbf{u}}(0)$.\n    c. For each wavenumber $m$ representable on the grid, multiply the corresponding coefficient $\\hat{u}_m(0)$ by the evolution factor $e^{\\lambda_m T}$.\n    d. Compute the Inverse DFT of the resulting coefficients to obtain the solution vector $\\mathbf{u}_{\\text{space}}(T)$.\n    e. Calculate the $L^2$ error $E^{\\text{space}}_{L^2}$ against the exact solution $u(x,T)$ sampled on the grid.\n\n2.  **Temporal-Only Error ($E^{\\text{time}}_{L^2}$)**:\n    To isolate the error from time integration, the spatial derivative in the PDE is computed exactly for all Fourier modes that the grid can represent. This is known as spectral differentiation. The semi-discrete system becomes $\\frac{d \\mathbf{u}}{dt} = -a \\frac{\\partial \\mathbf{u}}{\\partial x}_{\\text{exact}}$, which is then integrated using the RK4 method. The exact derivative of a band-limited function is computed in Fourier space. The derivative of $u(x) = \\sum_m \\hat{u}_m e^{imx}$ is $\\frac{\\partial u}{\\partial x} = \\sum_m (im) \\hat{u}_m e^{imx}$.\n    The algorithm for each RK4 stage is:\n    a. Given the state vector $\\mathbf{v}$, compute its DFT, $\\hat{\\mathbf{v}}$.\n    b. Multiply each coefficient $\\hat{v}_m$ by $im$.\n    c. Compute the IDFT to get the exact derivative vector $\\frac{\\partial \\mathbf{v}}{\\partial x}$.\n    d. The right-hand side for the ODE solver is then $-a \\frac{\\partial \\mathbf{v}}{\\partial x}$.\n    Starting from $\\mathbf{u}(0)$, this procedure is repeated for the required number of time steps to obtain $\\mathbf{u}_{\\text{time}}(T)$. The $L^2$ error $E^{\\text{time}}_{L^2}$ is then computed.\n\n3.  **Total Error ($E^{\\text{total}}_{L^2}$)**:\n    This is the standard numerical simulation, where both space and time are discretized. The semi-discrete system $\\frac{d \\mathbf{u}}{dt} = -a D_c \\mathbf{u}$ is integrated using the RK4 method. At each RK4 stage, the right-hand side is computed by applying the central difference operator $D_c$ to the current state vector. This yields the solution $\\mathbf{u}_{\\text{total}}(T)$, from which the total error $E^{\\text{total}}_{L^2}$ is calculated.\n\nBy computing these three error metrics over a sequence of refined grids (increasing $N$), we can analyze the convergence rates of the spatial, temporal, and combined schemes. The spatial scheme is second-order, so $E^{\\text{space}}_{L^2}$ should scale with $(\\Delta x)^2$. The RK4 integrator is fourth-order, so $E^{\\text{time}}_{L^2}$ should scale with $(\\Delta t)^4$, which is proportional to $(\\Delta x)^4$ for a fixed CFL number. The total error is typically dominated by the lower-order component, so $E^{\\text{total}}_{L^2}$ is expected to scale with $(\\Delta x)^2$.", "answer": "```python\nimport numpy as np\nimport json\nimport math\n\ndef calculate_spatial_solution(u0, a, T, N, dx):\n    \"\"\"\n    Computes the semi-discrete solution integrated exactly in time.\n    This isolates the spatial discretization error.\n    \"\"\"\n    # DFT of initial condition\n    u0_hat = np.fft.fft(u0)\n    \n    # Integer wavenumbers corresponding to FFT output\n    m = np.fft.fftfreq(N) * N\n    \n    # Symbol of the central difference operator (modified wavenumber)\n    # Handle m=0 case to avoid 0/0, though sin(0)/dx is 0 anyway.\n    # The term is i * sin(m*dx)/dx. The evolution is exp(-a * T * i * sin(m*dx)/dx)\n    m_modified = np.zeros_like(m, dtype=float)\n    non_zero_m = m != 0\n    m_modified[non_zero_m] = np.sin(m[non_zero_m] * dx) / dx\n    \n    # Evolve each Fourier mode exactly in time\n    evolution_operator = np.exp(-1j * a * m_modified * T)\n    uT_hat = u0_hat * evolution_operator\n    \n    # Inverse DFT to get the solution in physical space\n    uT = np.fft.ifft(uT_hat)\n    \n    return uT.real\n\ndef rk4_step(rhs_func, u, dt, *args):\n    \"\"\"A single step of the classical 4th-order Runge-Kutta method.\"\"\"\n    k1 = rhs_func(u, *args)\n    k2 = rhs_func(u + dt / 2.0 * k1, *args)\n    k3 = rhs_func(u + dt / 2.0 * k2, *args)\n    k4 = rhs_func(u + dt * k3, *args)\n    return u + dt / 6.0 * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n\ndef spectral_rhs(u, a, N):\n    \"\"\"RHS function using spectral differentiation for -a * du/dx.\"\"\"\n    u_hat = np.fft.fft(u)\n    m = np.fft.fftfreq(N) * N\n    du_dx_hat = 1j * m * u_hat\n    du_dx = np.fft.ifft(du_dx_hat)\n    return -a * du_dx\n\ndef calculate_temporal_solution(u0, a, T, N, dt):\n    \"\"\"\n    Computes the solution using RK4 in time and spectral differentiation in space.\n    This isolates the temporal discretization error.\n    \"\"\"\n    u = u0.copy().astype(np.complex128)\n    t = 0.0\n    num_steps = math.floor(T / dt)\n    \n    for _ in range(num_steps):\n        u = rk4_step(spectral_rhs, u, dt, a, N)\n        t += dt\n        \n    # Final shortened step to hit T exactly\n    if T - t > 1e-12:\n        dt_final = T - t\n        u = rk4_step(spectral_rhs, u, dt_final, a, N)\n        \n    return u.real\n\ndef central_diff_rhs(u, a, dx):\n    \"\"\"RHS function using 2nd-order central differences for -a * du/dx.\"\"\"\n    du_dx = (np.roll(u, -1) - np.roll(u, 1)) / (2.0 * dx)\n    return -a * du_dx\n\ndef calculate_total_solution(u0, a, T, dx, dt):\n    \"\"\"\n    Computes the solution using RK4 in time and central differences in space.\n    This captures the total numerical error.\n    \"\"\"\n    u = u0.copy()\n    t = 0.0\n    num_steps = math.floor(T / dt)\n    \n    for _ in range(num_steps):\n        u = rk4_step(central_diff_rhs, u, dt, a, dx)\n        t += dt\n\n    # Final shortened step to hit T exactly\n    if T - t > 1e-12:\n        dt_final = T - t\n        u = rk4_step(central_diff_rhs, u, dt_final, a, dx)\n        \n    return u.real\n\ndef compute_errors_for_case(a, k, CFL, T, N):\n    \"\"\"\n    Main computation for a single grid size N.\n    Sets up the problem and computes the three error types.\n    \"\"\"\n    # Grid and initial conditions\n    dx = 2.0 * np.pi / N\n    x = np.arange(N) * dx\n    u_initial = np.sin(k * x)\n    u_exact_final = np.sin(k * x - a * T)\n    dt = CFL * dx / np.abs(a)\n\n    # 1. Spatial-only error\n    u_space = calculate_spatial_solution(u_initial, a, T, N, dx)\n    error_space = np.sqrt(dx * np.sum((u_space - u_exact_final)**2))\n    \n    # 2. Temporal-only error\n    u_time = calculate_temporal_solution(u_initial, a, T, N, dt)\n    error_time = np.sqrt(dx * np.sum((u_time - u_exact_final)**2))\n\n    # 3. Total error\n    u_total = calculate_total_solution(u_initial, a, T, dx, dt)\n    error_total = np.sqrt(dx * np.sum((u_total - u_exact_final)**2))\n    \n    return [dx, error_space, error_time, error_total]\n\ndef solve():\n    \"\"\"\n    Main driver function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {'a': 1.0, 'k': 4,  'CFL': 0.5, 'T': 1.0, 'N_list': [64, 128, 256, 512]},\n        {'a': 1.0, 'k': 16, 'CFL': 0.5, 'T': 1.0, 'N_list': [64, 128, 256, 512]},\n        {'a': 0.3, 'k': 3,  'CFL': 0.9, 'T': 2.0, 'N_list': [64, 128, 256, 512]}\n    ]\n\n    all_results = []\n    for case in test_cases:\n        case_results = []\n        for N in case['N_list']:\n            result_tuple = compute_errors_for_case(\n                case['a'], case['k'], case['CFL'], case['T'], N\n            )\n            case_results.append(result_tuple)\n        all_results.append(case_results)\n\n    # Print the final result in the specified JSON format on a single line\n    print(json.dumps(all_results, separators=(',', ':')))\n\nsolve()\n```", "id": "3298150"}, {"introduction": "The lack of numerical dissipation in central differencing, while beneficial for accuracy in some cases, is also the source of its most notorious failure: the production of non-physical oscillations. This exercise explores this instability within the context of the steady-state convection-diffusion equation, where the cell Peclet number, $\\mathrm{Pe}$, quantifies the local balance between convective and diffusive transport [@problem_id:3298174]. You will implement a finite volume solver to discover firsthand that when convection dominates and $|\\mathrm{Pe}|$ exceeds the critical value of $2$, the central differencing scheme breaks down, generating spurious wiggles that render the solution physically meaningless.", "problem": "Consider the one-dimensional, steady, constant-coefficient convection–diffusion boundary-value problem for a transported scalar field $\\phi(x)$ over the unit interval $x \\in [0,1]$:\n$$\\frac{d}{dx}\\left(\\Gamma \\frac{d\\phi}{dx}\\right) - \\rho u \\frac{d\\phi}{dx} = 0,$$\nwith Dirichlet boundary data imposing a unit step across the domain endpoints,\n$$\\phi(0) = 1,\\quad \\phi(1) = 0.$$\nStarting from conservation of $\\phi$ over a control volume and the definition of diffusive and convective fluxes, use the Finite Volume Method (FVM) with a uniform mesh and Central Differencing Scheme (CDS) for face values to construct the discrete algebraic equations for the interior nodes. Let the cell Peclet number be defined by\n$$\\mathrm{Pe} \\equiv \\frac{\\rho u\\,\\Delta x}{\\Gamma},$$\nwhere $\\Delta x$ is the uniform cell width. Using this discretization, implement a solver that, for a given number of interior nodes $n$ and a specified $\\mathrm{Pe}$, computes the discrete solution vector $\\{\\phi_i\\}_{i=0}^{n+1}$, where $\\phi_0 = 1$ and $\\phi_{n+1} = 0$ are the boundary values and $\\{\\phi_i\\}_{i=1}^{n}$ are interior unknowns. From first principles, justify how the discrete coefficients arise from flux balances and central interpolation, and explain why the discrete solution may develop nonphysical oscillations (non-monotonicity and overshoot outside the interval $[0,1]$) when $|\\mathrm{Pe}|$ is sufficiently large.\n\nImplement a program that:\n- Builds and solves the tridiagonal linear system for the FVM–CDS discretization on a uniform grid for given $\\mathrm{Pe}$ and $n$.\n- Reports whether nonphysical oscillations are present based on two diagnostics:\n  1. Monotonicity: For the boundary data $\\phi(0)=1$ and $\\phi(1)=0$, the physically admissible solution is monotone decreasing. Let the discrete differences be $d_i = \\phi_i - \\phi_{i-1}$ for $i \\in \\{1,2,\\dots,n+1\\}$. Declare the solution non-monotone if there exists $i$ such that $d_i > \\varepsilon$, where $\\varepsilon$ is a small tolerance.\n  2. Boundedness: Declare an overshoot if $\\max_i \\phi_i > 1 + \\varepsilon$ or $\\min_i \\phi_i  0 - \\varepsilon$. Quantify the maximum overshoot magnitude as\n  $$\\max\\left(\\max_i \\phi_i - 1,\\; 0,\\; 0 - \\min_i \\phi_i\\right),$$\n  interpreted as a nonnegative real number.\n- Aggregates for each test case a result consisting of four items: \n  1. a boolean indicating whether oscillations are detected (true if either non-monotonicity or overshoot occurs),\n  2. a float equal to the maximum overshoot magnitude,\n  3. a float equal to the excess total variation, defined by $\\left(\\sum_{i=1}^{n+1} |d_i|\\right) - 1$,\n  4. the full discrete solution vector $[\\phi_0, \\phi_1, \\dots, \\phi_{n+1}]$.\n\nYour program should use a tolerance $\\varepsilon = 10^{-12}$ for the diagnostics, and it should round all reported floats (items $2$ and $3$, and all entries of the discrete solution vector) to $6$ decimal places in the final output.\n\nTest Suite:\nProvide results for the following five parameter sets $(\\mathrm{Pe}, n)$, with the same boundary values $\\phi(0)=1$ and $\\phi(1)=0$ in all tests:\n- Case A (happy path, diffusion-dominated): $(\\mathrm{Pe}, n) = (0, 8)$.\n- Case B (threshold): $(\\mathrm{Pe}, n) = (2, 8)$.\n- Case C (convection-dominated, forward flow): $(\\mathrm{Pe}, n) = (4, 8)$.\n- Case D (convection-dominated, reverse flow): $(\\mathrm{Pe}, n) = (-4, 8)$.\n- Case E (moderate convection): $(\\mathrm{Pe}, n) = (1.5, 8)$.\n\nFinal Output Format:\nYour program should produce a single line of output containing a list of results, one per test case, in the order A through E. Each result must itself be a list of the form \n$[\\text{oscillatory},\\ \\text{overshoot},\\ \\text{variation\\_excess},\\ \\text{solution}]$,\nwhere $\\text{oscillatory}$ is a boolean, $\\text{overshoot}$ and $\\text{variation\\_excess}$ are floats rounded to $6$ decimal places, and $\\text{solution}$ is a list of floats rounded to $6$ decimal places. For example, a syntactically valid output structure is\n$$\\big[\\ [\\text{True},\\ 0.123456,\\ 0.234567,\\ [1.000000, \\dots, 0.000000]],\\ \\dots\\ \\big].$$", "solution": "### Derivation of the Discrete Algebraic Equations\n\nWe begin with the one-dimensional, steady-state, constant-coefficient convection-diffusion equation for a scalar field $\\phi(x)$:\n$$\n\\frac{d}{dx}\\left(\\Gamma \\frac{d\\phi}{dx}\\right) - \\rho u \\frac{d\\phi}{dx} = 0\n$$\nwhere $\\Gamma$ is the diffusion coefficient, $\\rho$ is the density, and $u$ is the velocity. This equation can be written in a conservative form by defining the total flux $J(x)$ as the sum of the diffusive flux $J_D(x) = -\\Gamma \\frac{d\\phi}{dx}$ and the convective flux $J_C(x) = \\rho u \\phi$. The governing equation is then equivalent to stating that the divergence of the total flux is zero:\n$$\n\\frac{dJ}{dx} = 0 \\quad \\text{where} \\quad J(x) = J_C(x) + J_D(x) = \\rho u \\phi(x) - \\Gamma \\frac{d\\phi}{dx}\n$$\n\nThe Finite Volume Method (FVM) is based on enforcing the conservation law in its integral form over a set of control volumes (or cells) that tile the domain. We consider a uniform mesh over the domain $x \\in [0, 1]$. The domain is divided into $n$ interior cells, corresponding to $n$ interior nodes, indexed $i=1, 2, \\dots, n$. The nodes are located at the cell centers. The boundary nodes are at $x_0=0$ and $x_{n+1}=1$. The uniform cell width is $\\Delta x = 1/(n+1)$. The control volume for node $i$ extends from its west face $w$ at $x_{i-1/2}$ to its east face $e$ at $x_{i+1/2}$.\n\nIntegrating the conservation law $\\frac{dJ}{dx} = 0$ over the control volume for node $i$ yields:\n$$\n\\int_{w}^{e} \\frac{dJ}{dx} dx = 0\n$$\nBy the fundamental theorem of calculus, this becomes a simple balance of fluxes at the cell faces:\n$$\nJ_e - J_w = 0\n$$\nwhere $J_e = J(x_{i+1/2})$ and $J_w = J(x_{i-1/2})$ are the total fluxes at the east and west faces, respectively.\n\nThe next step is to approximate these face fluxes. The Central Differencing Scheme (CDS) approximates values at a cell face by linear interpolation between the adjacent cell-center nodes.\nThe flux at the east face $e$, located at $x_{i+1/2}$, is $J_e = (\\rho u \\phi)_e - (\\Gamma \\frac{d\\phi}{dx})_e$.\nUsing CDS:\n- The scalar value $\\phi_e$ is approximated by averaging the values at nodes $i$ and $i+1$: $\\phi_e \\approx \\frac{\\phi_i + \\phi_{i+1}}{2}$.\n- The gradient $(\\frac{d\\phi}{dx})_e$ is approximated using a central difference centered at the face: $(\\frac{d\\phi}{dx})_e \\approx \\frac{\\phi_{i+1} - \\phi_i}{\\Delta x}$.\n\nSubstituting these into the expression for $J_e$:\n$$\nJ_e \\approx \\rho u \\left(\\frac{\\phi_i + \\phi_{i+1}}{2}\\right) - \\Gamma \\left(\\frac{\\phi_{i+1} - \\phi_i}{\\Delta x}\\right)\n$$\nSimilarly, the flux at the west face $w$, located at $x_{i-1/2}$, is approximated using nodes $i-1$ and $i$:\n$$\nJ_w \\approx \\rho u \\left(\\frac{\\phi_{i-1} + \\phi_i}{2}\\right) - \\Gamma \\left(\\frac{\\phi_i - \\phi_{i-1}}{\\Delta x}\\right)\n$$\nSubstituting these flux approximations into the balance equation $J_e - J_w = 0$:\n$$\n\\left[ \\rho u \\frac{\\phi_i + \\phi_{i+1}}{2} - \\Gamma \\frac{\\phi_{i+1} - \\phi_i}{\\Delta x} \\right] - \\left[ \\rho u \\frac{\\phi_{i-1} + \\phi_i}{2} - \\Gamma \\frac{\\phi_i - \\phi_{i-1}}{\\Delta x} \\right] = 0\n$$\nWe now collect terms multiplying $\\phi_{i-1}$, $\\phi_i$, and $\\phi_{i+1}$:\n$$\n\\left(\\frac{\\Gamma}{\\Delta x} - \\frac{\\rho u}{2}\\right)\\phi_{i+1} + \\left(\\frac{\\Gamma}{\\Delta x} + \\frac{\\Gamma}{\\Delta x}\\right)\\phi_i - \\left(\\frac{\\Gamma}{\\Delta x} + \\frac{\\rho u}{2}\\right)\\phi_{i-1} = 0\n$$\nRearranging and multiplying by $-1$ to follow convention gives the standard three-point stencil form:\n$$\n\\left(\\frac{\\Gamma}{\\Delta x} + \\frac{\\rho u}{2}\\right)\\phi_{i-1} - \\left(\\frac{2\\Gamma}{\\Delta x}\\right)\\phi_i + \\left(\\frac{\\Gamma}{\\Delta x} - \\frac{\\rho u}{2}\\right)\\phi_{i+1} = 0\n$$\nTo simplify, we divide the entire equation by $\\Gamma/\\Delta x$ and introduce the dimensionless cell Peclet number, $\\mathrm{Pe} \\equiv \\frac{\\rho u \\Delta x}{\\Gamma}$, which represents the ratio of convective to diffusive transport strength at the cell level.\n$$\n\\left(1 + \\frac{\\rho u \\Delta x}{2\\Gamma}\\right)\\phi_{i-1} - 2\\phi_i + \\left(1 - \\frac{\\rho u \\Delta x}{2\\Gamma}\\right)\\phi_{i+1} = 0\n$$\nThis results in the final discrete algebraic equation for an interior node $i$:\n$$\n\\left(1 + \\frac{\\mathrm{Pe}}{2}\\right)\\phi_{i-1} - 2\\phi_i + \\left(1 - \\frac{\\mathrm{Pe}}{2}\\right)\\phi_{i+1} = 0\n$$\nThis equation is valid for each interior node $i=1, \\dots, n$. For $i=1$, $\\phi_{i-1}$ is the known boundary value $\\phi_0 = 1$. For $i=n$, $\\phi_{i+1}$ is the known boundary value $\\phi_{n+1}=0$. These substitutions result in a tridiagonal system of $n$ linear equations for the $n$ unknown interior values $\\{\\phi_i\\}_{i=1}^n$.\n\n### Origin of Nonphysical Oscillations\n\nThe discrete equation can be rearranged to express $\\phi_i$ as a function of its neighbors:\n$$\n\\phi_i = \\frac{1}{2}\\left(1 + \\frac{\\mathrm{Pe}}{2}\\right)\\phi_{i-1} + \\frac{1}{2}\\left(1 - \\frac{\\mathrm{Pe}}{2}\\right)\\phi_{i+1}\n$$\nFor the solution to be physically realistic (i.e., bounded and monotonic, consistent with the physics of a second-order differential equation with the given boundary conditions), the value at node $\\phi_i$ must be a weighted average of its neighbors $\\phi_{i-1}$ and $\\phi_{i+1}$. This requires the weighting coefficients to be non-negative.\n1. Coefficient of $\\phi_{i-1}$: $\\frac{1}{2}(1 + \\frac{\\mathrm{Pe}}{2}) \\ge 0 \\implies 1 + \\frac{\\mathrm{Pe}}{2} \\ge 0 \\implies \\mathrm{Pe} \\ge -2$.\n2. Coefficient of $\\phi_{i+1}$: $\\frac{1}{2}(1 - \\frac{\\mathrm{Pe}}{2}) \\ge 0 \\implies 1 - \\frac{\\mathrm{Pe}}{2} \\ge 0 \\implies \\mathrm{Pe} \\le 2$.\n\nCombining these conditions, all coefficients are non-negative only if $|\\mathrm{Pe}| \\le 2$. When this condition is satisfied, the scheme is guaranteed to produce a monotonic solution.\n\nWhen the flow is convection-dominated such that $|\\mathrm{Pe}| > 2$, one of the coefficients becomes negative. For example, if $\\mathrm{Pe} > 2$, the coefficient of $\\phi_{i+1}$ is negative. The equation for $\\phi_i$ then involves an extrapolation rather than an interpolation between its neighbors. This can lead to computed values for $\\phi_i$ that fall outside the range defined by its neighbors (e.g., $\\phi_i > \\max(\\phi_{i-1}, \\phi_{i+1})$ or $\\phi_i  \\min(\\phi_{i-1}, \\phi_{i+1})$). This mathematical property is the source of the nonphysical oscillations (wiggles), including overshoots and undershoots, which are characteristic failures of the Central Differencing Scheme in high-convection regimes. The solution is no longer guaranteed to be monotonic or bounded by the boundary values. This instability necessitates the use of alternative, more sophisticated schemes like upwind differencing for convection-dominated problems.", "answer": "```python\nimport numpy as np\nimport scipy.linalg\n\ndef solve():\n    \"\"\"\n    Main function to solve the convection-diffusion problem for a suite of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement: (Pe, n)\n    test_cases = [\n        (0.0, 8),   # Case A: Pure diffusion\n        (2.0, 8),   # Case B: Threshold\n        (4.0, 8),   # Case C: Convection-dominated, forward\n        (-4.0, 8),  # Case D: Convection-dominated, reverse\n        (1.5, 8),   # Case E: Moderate convection\n    ]\n\n    # Global parameters\n    phi_0 = 1.0\n    phi_L = 0.0\n    epsilon = 1e-12\n    \n    results = []\n    \n    for Pe, n_interior in test_cases:\n        # 1. Build and solve the linear system\n        \n        # Coefficients of the discrete equation: c_W*phi_{i-1} + c_P*phi_i + c_E*phi_{i+1} = 0\n        c_W = 1.0 + Pe / 2.0\n        c_P = -2.0\n        c_E = 1.0 - Pe / 2.0\n        \n        # Assemble the n x n tridiagonal matrix A in banded format for SciPy\n        # ab[0,:] = super-diagonal (c_E)\n        # ab[1,:] = main diagonal (c_P)\n        # ab[2,:] = sub-diagonal (c_W)\n        ab = np.zeros((3, n_interior))\n        ab[0, 1:] = c_E\n        ab[1, :] = c_P\n        ab[2, :-1] = c_W\n        \n        # Assemble the right-hand side vector b\n        b = np.zeros(n_interior)\n        # For i=1, the term c_W * phi_0 moves to the RHS\n        b[0] = -c_W * phi_0\n        # For i=n, the term c_E * phi_{n+1} is zero since phi_{n+1}=0\n        \n        # Solve the system A * phi_interior = b\n        phi_interior = scipy.linalg.solve_banded((1, 1), ab, b)\n        \n        # Construct the full solution vector including boundaries\n        phi_full = np.concatenate(([phi_0], phi_interior, [phi_L]))\n        \n        # 2. Perform diagnostics\n        \n        # Monotonicity check\n        # d_i = phi_i - phi_{i-1}. For monotonic decrease, all d_i should be = 0.\n        diffs = np.diff(phi_full)\n        is_non_monotone = np.any(diffs > epsilon)\n        \n        # Boundedness check (overshoot/undershoot)\n        max_phi = np.max(phi_full)\n        min_phi = np.min(phi_full)\n        is_overshoot = (max_phi > 1.0 + epsilon) or (min_phi  0.0 - epsilon)\n        \n        # Oscillation detection\n        oscillatory = is_non_monotone or is_overshoot\n        \n        # Maximum overshoot magnitude\n        overshoot_mag = np.max([max_phi - 1.0, 0.0, 0.0 - min_phi])\n        \n        # Excess total variation\n        # Total variation for monotonic solution from 1 to 0 is 1.\n        total_variation = np.sum(np.abs(diffs))\n        variation_excess = total_variation - 1.0\n        \n        # 3. Format and aggregate results\n        \n        # Round floats to 6 decimal places as required\n        rounded_overshoot = round(overshoot_mag, 6)\n        rounded_variation = round(variation_excess, 6)\n        rounded_solution = [round(x, 6) for x in phi_full]\n\n        case_result = [\n            oscillatory,\n            rounded_overshoot,\n            rounded_variation,\n            rounded_solution\n        ]\n        results.append(case_result)\n\n    # 4. Print the final output in the exact required format\n    # Manually construct the string to ensure exact formatting (spacing, decimals)\n    result_strings = []\n    for res in results:\n        osc_str = str(res[0])\n        ov_str = f\"{res[1]:.6f}\"\n        var_str = f\"{res[2]:.6f}\"\n        sol_str = '[' + ', '.join([f\"{x:.6f}\" for x in res[3]]) + ']'\n        result_strings.append(f\"[{osc_str}, {ov_str}, {var_str}, {sol_str}]\")\n        \n    final_output = '[' + ', '.join(result_strings) + ']'\n    print(final_output)\n\nsolve()\n```", "id": "3298174"}]}