{"hands_on_practices": [{"introduction": "A common challenge in CFD is that mesh data formats often provide only cell-to-node connectivity for efficiency. This exercise guides you through the fundamental process of reconstructing the complete face-based connectivity, which is essential for assembling fluxes and adjacencies. You will implement a core algorithm that identifies unique faces by creating a canonical key, a technique that is indispensable for building robust unstructured solvers. [@problem_id:3303794]", "problem": "An unstructured mesh used in Computational Fluid Dynamics (CFD) and stored in the Visualization Toolkit (VTK) format is often represented with only cell-to-node connectivity. From first principles, consider that a cell is a topological three-dimensional entity composed of faces, where a face is a two-dimensional boundary entity defined by a minimal subset of nodes forming a planar polygon. A unique face in a mesh is defined as an equivalence class of faces across all cells, where two faces are equivalent if they are composed of the same set of node indices, independent of ordering. Therefore, a face can be canonically represented by a sorted tuple of its node indices. The goal is to reconstruct the set of unique faces and identify boundary faces, which are faces incident to exactly one cell.\n\nStarting from the core definitions:\n- A mesh is a pair $(\\mathcal{N}, \\mathcal{C})$ where $\\mathcal{N}$ is the set of node indices and $\\mathcal{C}$ is a list of cells. Each cell $c \\in \\mathcal{C}$ is given by a type identifier and an ordered list of node indices.\n- For common VTK three-dimensional cell types, the face templates are defined by discrete topology: a tetrahedron has $4$ triangular faces, a hexahedron has $6$ quadrilateral faces, a wedge (triangular prism) has $5$ faces composed of $2$ triangles and $3$ quadrilaterals, and a pyramid has $5$ faces composed of $1$ quadrilateral and $4$ triangles.\n- A unique face key is the sorted tuple $\\mathrm{sort}([n_0,\\dots,n_{k-1}])$, canonically representing the node set of the face.\n\nYour task is to design and implement a complete program that:\n1. Reconstructs the set of unique faces from only cell-to-node connectivity for the following VTK cell types: VTK_TETRA (10), VTK_HEXAHEDRON (12), VTK_WEDGE (13), and VTK_PYRAMID (14).\n2. Counts the number of boundary faces, defined as those unique faces that are incident to exactly one cell.\n3. Validates the reconstruction against expected boundary-face counts for several test meshes.\n\nUse the following test suite, where each test case is a list of cells. Each cell is a pair $(t, \\mathbf{n})$ where $t$ is the VTK cell type integer and $\\mathbf{n}$ is the ordered list of node indices for that cell. The expected boundary-face counts are provided for each test case:\n\n- Test case $1$ (two tetrahedra sharing one triangular face with reversed orientation in one cell):\n  Cells: $[(10, [0,1,2,3]),\\ (10, [2,1,0,4])]$.\n  Expected boundary-face count: $6$.\n\n- Test case $2$ (one hexahedron):\n  Cells: $[(12, [0,1,2,3,4,5,6,7])]$.\n  Expected boundary-face count: $6$.\n\n- Test case $3$ (two wedges sharing one quadrilateral face across different cell instances):\n  Cells: $[(13, [0,1,2,3,4,5]),\\ (13, [0,1,9,3,4,10])]$.\n  Expected boundary-face count: $8$.\n\n- Test case $4$ (one pyramid and one tetrahedron sharing one triangular face):\n  Cells: $[(14, [0,1,2,3,4]),\\ (10, [1,2,4,5])]$.\n  Expected boundary-face count: $7$.\n\n- Test case $5$ (two tetrahedra sharing only an edge, not a face):\n  Cells: $[(10, [0,1,2,3]),\\ (10, [2,3,4,5])]$.\n  Expected boundary-face count: $8$.\n\nYour program must:\n- Implement face reconstruction using only the provided cell-to-node lists and the topological face templates for the given VTK cell types.\n- Canonicalize each face by sorting its node indices to ensure unique identification independent of orientation.\n- Count boundary faces by identifying unique faces that are incident to exactly one cell.\n- Compare the computed boundary-face count to the expected count for each test case and produce a boolean result for each test case: $true$ if the counts match, and $false$ otherwise.\n\nFinal output format:\nYour program should produce a single line of output containing the results for the five test cases as a comma-separated list enclosed in square brackets, for example, `[r_1,r_2,r_3,r_4,r_5]`, where each $r_i$ is a boolean.\n\nNo physical units are involved in this problem. Angles are not applicable. Percentages are not applicable. Ensure that the algorithm is derived from the provided core definitions and cell-face topology, not from any external shortcuts or precomputed adjacency structures.", "solution": "The problem of reconstructing face connectivity and identifying boundary faces from cell-to-node connectivity is a fundamental task in computational geometry, particularly in the preprocessing stage for numerical solvers in fields like Computational Fluid Dynamics (CFD). The provided problem is well-posed, scientifically sound, and internally consistent, thus admitting a formal solution.\n\nThe core principle underpinning the solution is the establishment of a canonical representation for each face. A face is a geometric entity defined by a set of nodes. While the ordering of these nodes may differ depending on the orientation of the face relative to its parent cell, the set of nodes itself is invariant. The problem statement correctly defines a unique face as an equivalence class based on this set of nodes. A robust canonical representation, or key, is therefore a sorted tuple of the global indices of the nodes that constitute the face. This key is unique regardless of the original node ordering.\n\nThe algorithm proceeds as follows:\n\nLet the computational mesh be represented by a pair $\\mathcal{M} = (\\mathcal{N}, \\mathcal{C})$, where $\\mathcal{N}$ is the set of node indices (e.g., $\\{0, 1, 2, \\dots\\}$) and $\\mathcal{C}$ is a list of cells. Each cell $c_i \\in \\mathcal{C}$ is defined by a pair $(t_i, \\mathbf{n}_i)$, where $t_i$ is an integer identifying the cell's topological type and $\\mathbf{n}_i$ is an ordered list of global node indices for that cell.\n\n$1$. **Topological Face Templates**: For each supported VTK cell type $t$, we must define a fixed set of face templates. Each template is a list of local indices that identify the nodes forming a single face of the cell, based on VTK's standard node ordering for that cell type. Let $F_t$ be the set of face templates for a cell of type $t$.\n- For `VTK_TETRA` (type t=10), there are $4$ triangular faces: $F_{10} = \\{ (0,1,2), (0,3,1), (1,3,2), (2,3,0) \\}$.\n- For `VTK_HEXAHEDRON` (type t=12), there are $6$ quadrilateral faces: $F_{12} = \\{ (0,1,2,3), (4,5,6,7), (0,1,5,4), (1,2,6,5), (2,3,7,6), (3,0,4,7) \\}$.\n- For `VTK_WEDGE` (type t=13), there are $2$ triangular and $3$ quadrilateral faces: $F_{13} = \\{ (0,1,2), (3,4,5), (0,1,4,3), (1,2,5,4), (2,0,3,5) \\}$.\n- For `VTK_PYRAMID` (type t=14), there is $1$ quadrilateral and $4$ triangular faces: $F_{14} = \\{ (0,1,2,3), (0,1,4), (1,2,4), (2,3,4), (3,0,4) \\}$.\n\n$2$. **Face Instance Generation and Counting**: We require a mapping data structure, which we will denote as $\\mathcal{A}$, to store the incidence count of each unique face. A hash map (or dictionary) is suitable, where keys are the canonical face representations and values are their corresponding counts. The algorithm iterates through every cell $c_i = (t_i, \\mathbf{n}_i)$ in the list $\\mathcal{C}$.\nFor each cell $c_i$:\n- Retrieve the set of face templates $F_{t_i}$ corresponding to its type $t_i$.\n- For each local face template $f_j = (l_0, l_1, \\dots, l_k) \\in F_{t_i}$:\n    - A specific face instance is formed by mapping these local indices to the global node indices provided in $\\mathbf{n}_i$. The global nodes for this face instance are $\\{ \\mathbf{n}_i[l_0], \\mathbf{n}_i[l_1], \\dots, \\mathbf{n}_i[l_k] \\}$.\n    - The canonical key, $K_f$, for this face instance is generated by sorting these global node indices: $K_f = \\mathrm{tuple}(\\mathrm{sorted}([\\mathbf{n}_i[l_0], \\mathbf{n}_i[l_1], \\dots, \\mathbf{n}_i[l_k]]))$.\n    - The incidence count in the map $\\mathcal{A}$ for this key $K_f$ is incremented. If the key does not exist in $\\mathcal{A}$, it is initialized with a count of $1$.\n\n$3$. **Boundary Face Identification**: After processing all cells, the map $\\mathcal{A}$ contains every unique face key present in the mesh, along with the number of cells it is incident to. According to the definition, a boundary face is one that is incident to exactly one cell. Therefore, the number of boundary faces, $N_{bf}$, is the number of entries in $\\mathcal{A}$ whose value is exactly $1$.\n$$N_{bf} = |\\{K_f \\mid \\mathcal{A}[K_f] = 1\\}|$$\n\nThis algorithm is deterministic and provides an exact reconstruction of face-based connectivity from cell-based connectivity. It correctly identifies boundary faces by leveraging the principle that internal faces are shared by two or more cells, resulting in an incidence count greater than $1$. The implementation of this algorithm will be used to validate the provided test cases.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the mesh face reconstruction problem for a suite of test cases.\n    \"\"\"\n\n    # Face templates are defined using local node indices for each VTK cell type.\n    # These orderings are based on the standard VTK library definitions.\n    FACE_TEMPLATES = {\n        10: [  # VTK_TETRA (4 nodes)\n            (0, 1, 2), (0, 3, 1), (1, 3, 2), (2, 3, 0)\n        ],\n        12: [  # VTK_HEXAHEDRON (8 nodes)\n            (0, 1, 2, 3), (4, 5, 6, 7), (0, 1, 5, 4), (1, 2, 6, 5),\n            (2, 3, 7, 6), (3, 0, 4, 7)\n        ],\n        13: [  # VTK_WEDGE (6 nodes)\n            (0, 1, 2), (3, 4, 5), (0, 1, 4, 3), (1, 2, 5, 4), (2, 0, 3, 5)\n        ],\n        14: [  # VTK_PYRAMID (5 nodes)\n            (0, 1, 2, 3), (0, 1, 4), (1, 2, 4), (2, 3, 4), (3, 0, 4)\n        ]\n    }\n\n    def count_boundary_faces(cells):\n        \"\"\"\n        Reconstructs unique faces and counts boundary faces from cell-to-node connectivity.\n\n        Args:\n            cells (list): A list of cells, where each cell is a tuple\n                          (cell_type_id, node_indices_list).\n\n        Returns:\n            int: The number of boundary faces.\n        \"\"\"\n        face_counts = {}\n\n        for cell_type, node_indices in cells:\n            if cell_type not in FACE_TEMPLATES:\n                raise ValueError(f\"Unknown cell type: {cell_type}\")\n\n            templates = FACE_TEMPLATES[cell_type]\n            for template in templates:\n                # Map local face template indices to global node indices\n                global_face_nodes = [node_indices[i] for i in template]\n                \n                # Create a canonical key by sorting the node indices.\n                # A tuple is used because it is hashable.\n                canonical_key = tuple(sorted(global_face_nodes))\n\n                # Increment the count for this unique face\n                face_counts[canonical_key] = face_counts.get(canonical_key, 0) + 1\n        \n        # A boundary face is a unique face that appears exactly once.\n        boundary_face_count = 0\n        for count in face_counts.values():\n            if count == 1:\n                boundary_face_count += 1\n        \n        return boundary_face_count\n\n    # Define the test suite from the problem statement.\n    test_cases = [\n        {\n            \"id\": 1,\n            \"cells\": [(10, [0, 1, 2, 3]), (10, [2, 1, 0, 4])],\n            \"expected\": 6\n        },\n        {\n            \"id\": 2,\n            \"cells\": [(12, [0, 1, 2, 3, 4, 5, 6, 7])],\n            \"expected\": 6\n        },\n        {\n            \"id\": 3,\n            \"cells\": [(13, [0, 1, 2, 3, 4, 5]), (13, [0, 1, 9, 3, 4, 10])],\n            \"expected\": 8\n        },\n        {\n            \"id\": 4,\n            \"cells\": [(14, [0, 1, 2, 3, 4]), (10, [1, 2, 4, 5])],\n            \"expected\": 7\n        },\n        {\n            \"id\": 5,\n            \"cells\": [(10, [0, 1, 2, 3]), (10, [2, 3, 4, 5])],\n            \"expected\": 8\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        computed_count = count_boundary_faces(case[\"cells\"])\n        # The result for the case is true if the computed count matches the expected one.\n        is_correct = (computed_count == case[\"expected\"])\n        results.append(str(is_correct).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3303794"}, {"introduction": "Beyond local consistency, we can perform global sanity checks on a mesh using profound results from mathematics. This exercise demonstrates how the Euler-PoincarÃ© formula, a classic result from topology, provides an invariant ($V - E + F$) that depends only on the global features of the domain, such as the number of interior holes. By applying this concept to a 2D triangulation, you will learn to perform a high-level sanity check on your mesh and diagnose its global properties, connecting deep theory to practical CFD model setup. [@problem_id:3303802]", "problem": "An unstructured two-dimensional triangular mesh is used by a Computational Fluid Dynamics (CFD) solver to discretize a bounded planar domain. The solver stores connectivity using per-cell lists of vertex indices and a separate list of boundary edges. Consider a mesh of a planar domain that may contain interior holes. The mesh has exactly $F = 100$ triangular cells (counting only the bounded triangles that tile the domain, not the unbounded exterior), $V = 68$ distinct vertices, and the boundary edge list contains $B = 40$ distinct edges. There are no hanging nodes, and each boundary edge belongs to exactly one triangle.\n\nStarting only from the foundational definitions of a two-dimensional cell complex, the Euler characteristic as an alternating count of $0$-cells, $1$-cells, and $2$-cells, the topological invariance of the Euler characteristic under homeomorphisms, and the double-counting principle for edge-to-face incidences in a triangulation, derive the topological invariant that links the alternated count of mesh entities to the number of boundary components. Use this invariant to compute the number of interior holes $h$ of the meshed domain under the convention that each hole contributes an additional boundary component beyond the outer boundary.\n\nProvide as your final answer the value of $h$ as a single number. No rounding is required, and no units are involved. Assume standard planar topology and that all mesh entities are correctly counted as described.", "solution": "The problem requires the derivation of a topological invariant relating the counts of mesh entities (vertices, edges, faces) to the number of holes in a planar domain and then using this invariant to compute the number of holes from given mesh data.\n\nThe derivation begins with the concept of the Euler characteristic, $\\chi$, a fundamental topological invariant. For any polyhedral decomposition (such as a triangulation) of a closed, orientable 2-manifold (a surface without boundary) into $V$ vertices, $E$ edges, and $F$ faces, the Euler characteristic is given by the alternating sum:\n$$ \\chi = V - E + F $$\nThe simplest such surface is the sphere, $S^2$, for which the Euler characteristic is $\\chi(S^2) = 2$. This can be confirmed with a simple polyhedron like a tetrahedron, where $V=4$, $E=6$, and $F=4$, giving $V-E+F=4-6+4=2$.\n\nThe meshed domain described in the problem is a bounded planar region, which may contain interior holes. Topologically, such a domain is homeomorphic to a sphere from which a number of disjoint open disks have been removed. Each removed disk creates a boundary component. Let the total number of boundary components be $k$. According to the problem's convention, there is one outer boundary and $h$ interior holes, so the total number of boundary components is $k = h+1$.\n\nTo find the Euler characteristic of this domain with boundaries, we can consider how $\\chi$ changes when we \"puncture\" a closed surface. Let us start with a triangulation of a sphere, for which $V_s - E_s + F_s = 2$. To create a surface homeomorphic to our domain, we remove $k$ disjoint faces from this triangulation. The vertices and edges that form the boundaries of these $k$ faces remain part of the complex, but the faces themselves are removed. The new number of faces in the complex is $F = F_s - k$. The number of vertices and edges remains unchanged, i.e., $V=V_s$ and $E=E_s$. The Euler characteristic of the resulting surface with boundary, $\\chi_{domain}$, is:\n$$ \\chi_{domain} = V - E + F = V_s - E_s + (F_s - k) = (V_s - E_s + F_s) - k $$\nSubstituting $\\chi(S^2) = 2$, we get:\n$$ \\chi_{domain} = 2 - k $$\nThe quantities $V$, $E$, and $F$ given in the problem statement correspond to the vertices, edges, and faces of the triangulation that discretizes the domain. Therefore, the value of the alternating sum for the mesh, $V-E+F$, must be equal to the Euler characteristic of the domain it represents. This provides the general invariant:\n$$ V - E + F = 2 - k $$\nNow, we relate this to the number of interior holes, $h$. With $k = h+1$ boundary components, the invariant becomes:\n$$ V - E + F = 2 - (h+1) = 1 - h $$\nThis is the specific topological invariant that connects the alternated count of mesh entities to the number of interior holes.\n\nNext, we must calculate the values of $V$, $E$, and $F$ for the given mesh. The problem provides:\n- Number of vertices (0-cells): $V = 68$.\n- Number of triangular faces (2-cells): $F = 100$.\n- Number of boundary edges: $B = 40$.\n\nThe total number of edges, $E$, is not explicitly provided. To find it, we employ the double-counting principle (a handshaking lemma for face-edge adjacencies). The sum of the number of edges for each face is computed. Since all cells are triangles, each has $3$ edges. Thus, summing the edges over all $F$ faces gives a total count of $3F$.\nIn this summation, every interior edge is shared by exactly two faces and is therefore counted twice. Every boundary edge, by definition and as stated in the problem (\"each boundary edge belongs to exactly one triangle\"), is part of only one face in the mesh and is counted once.\nLet $E_I$ be the number of interior edges and $E_B$ be the number of boundary edges. The total number of edges is $E = E_I + E_B$. The double-counting relationship is expressed as:\n$$ 3F = 2E_I + E_B $$\nWe are given $F=100$ and $E_B = B = 40$. Substituting these values into the equation:\n$$ 3(100) = 2E_I + 40 $$\n$$ 300 = 2E_I + 40 $$\n$$ 2E_I = 300 - 40 = 260 $$\nThis gives the number of interior edges as $E_I = 130$.\nThe total number of edges in the mesh is:\n$$ E = E_I + E_B = 130 + 40 = 170 $$\nNow we have all the necessary quantities for our derived invariant:\n- $V = 68$\n- $E = 170$\n- $F = 100$\n\nWe substitute these values into the formula $V - E + F = 1 - h$:\n$$ 68 - 170 + 100 = 1 - h $$\nCalculating the left-hand side:\n$$ 168 - 170 = -2 $$\nThe equation simplifies to:\n$$ -2 = 1 - h $$\nFinally, we solve for $h$, the number of interior holes:\n$$ h = 1 - (-2) = 1 + 2 = 3 $$\nThus, the meshed domain has $3$ interior holes.", "answer": "$$\n\\boxed{3}\n$$", "id": "3303845"}, {"introduction": "Verifying the integrity of mesh connectivity is as important as building it. This practice delves into a powerful validation principle, derived from a fundamental counting argument, that relates cell and face counts in any consistent polyhedral mesh using the identity $\\sum_{c \\in \\mathcal{C}} n_f(c) = 2N_{f,\\mathrm{int}} + N_{f,\\mathrm{bnd}}$. By implementing this check and designing connectivity arrays in the high-performance Compressed Sparse Row (CSR) format, you will gain experience with the data structures and validation techniques that ensure a solver's numerical stability and correctness. [@problem_id:3303845]", "problem": "You are given a topological specification of an unstructured polyhedral mesh as a pair of incidence relations between cells, faces, and nodes. The objective is to design a storage scheme suitable for high-performance unstructured solvers, and to prove a fundamental counting identity under a precise notion of mesh consistency.\n\nDefinitions. Let there be a finite set of cells $\\mathcal{C}$, faces $\\mathcal{F}$, and nodes $\\mathcal{V}$. Each cell $c \\in \\mathcal{C}$ is incident to a finite sequence of faces, and each face $f \\in \\mathcal{F}$ is incident to a finite sequence of nodes with at least three nodes. For a cell $c$, let $n_f(c)$ denote the number of faces incident to $c$. A face is called internal if it is incident to exactly two cells and boundary if it is incident to exactly one cell. Let $N_{f,\\mathrm{int}}$ denote the number of internal faces and $N_{f,\\mathrm{bnd}}$ denote the number of boundary faces. A mesh is consistent if every face is incident to either exactly two or exactly one cell.\n\nCompressed Sparse Row (CSR) design requirements. You must design:\n- A cell-to-face CSR representation, i.e., an array of offsets of length $|\\mathcal{C}|+1$ and a flat array of face indices such that the faces of a cell $c$ are stored contiguously between the two offsets corresponding to $c$ and the next cell.\n- A face-to-node CSR representation, i.e., an array of offsets of length $|\\mathcal{F}|+1$ and a flat array of node indices such that the nodes of a face $f$ are stored contiguously between the two offsets corresponding to $f$ and the next face.\n\nFundamental base. Use only the fundamental counting principle on finite sets, the definition of incidence, and the classification of faces by their number of incident cells.\n\nTheoretical task. Starting from the definitions and the counting principle, derive the identity\n$$\n\\sum_{c \\in \\mathcal{C}} n_f(c) \\;=\\; 2\\,N_{f,\\mathrm{int}} \\;+\\; N_{f,\\mathrm{bnd}}\n$$\nfor any consistent unstructured polyhedral mesh. Explain why the identity may fail if consistency is violated.\n\nAlgorithmic task. Implement a program that:\n- Given a mesh described by the list of faces (each face as a list of nodes) and the list of cells (each cell as a list of faces), builds the cell-to-face CSR and face-to-node CSR arrays.\n- From the cell-to-face CSR, computes $N_{f,\\mathrm{int}}$ and $N_{f,\\mathrm{bnd}}$ by counting, for each face, how many cells reference it.\n- Computes $S := \\sum_{c \\in \\mathcal{C}} n_f(c)$ directly from the cell-to-face CSR.\n- Returns a boolean indicating whether $S = 2\\,N_{f,\\mathrm{int}} + N_{f,\\mathrm{bnd}}$ holds.\n\nAngle unit and physical units are not applicable here. All inputs are integer indices.\n\nTest suite. Your program must embed and run the following test cases and aggregate their boolean results as the only line of output.\n\n- Case $\\mathrm{A}$ (single tetrahedron):\n  - Faces: $F_0=[0,1,2]$, $F_1=[0,1,3]$, $F_2=[1,2,3]$, $F_3=[2,0,3]$.\n  - Cells: $C_0=[0,1,2,3]$.\n- Case $\\mathrm{B}$ (two tetrahedra sharing one face):\n  - Faces: $F_0=[0,1,2]$ (shared), $F_1=[0,1,3]$, $F_2=[1,2,3]$, $F_3=[2,0,3]$, $F_4=[0,1,4]$, $F_5=[1,2,4]$, $F_6=[2,0,4]$.\n  - Cells: $C_0=[0,1,2,3]$, $C_1=[0,4,5,6]$.\n- Case $\\mathrm{C}$ (single cube):\n  - Faces: $F_0=[0,1,2,3]$, $F_1=[4,5,6,7]$, $F_2=[0,1,5,4]$, $F_3=[1,2,6,5]$, $F_4=[2,3,7,6]$, $F_5=[3,0,4,7]$.\n  - Cells: $C_0=[0,1,2,3,4,5]$.\n- Case $\\mathrm{D}$ (disconnected union of a tetrahedron and a cube):\n  - Faces: $F_0=[0,1,2]$, $F_1=[0,1,3]$, $F_2=[1,2,3]$, $F_3=[2,0,3]$, $F_4=[4,5,6,7]$, $F_5=[8,9,10,11]$, $F_6=[4,5,9,8]$, $F_7=[5,6,10,9]$, $F_8=[6,7,11,10]$, $F_9=[7,4,8,11]$.\n  - Cells: $C_0=[0,1,2,3]$, $C_1=[4,5,6,7,8,9]$.\n- Case $\\mathrm{E}$ (one triangular prism sharing one triangular face with a tetrahedron):\n  - Faces: $F_0=[0,1,2]$ (triangular, shared), $F_1=[3,4,5]$ (triangular), $F_2=[0,1,4,3]$ (quadrilateral), $F_3=[1,2,5,4]$ (quadrilateral), $F_4=[2,0,3,5]$ (quadrilateral), $F_5=[0,1,6]$ (triangular), $F_6=[1,2,6]$ (triangular), $F_7=[2,0,6]$ (triangular).\n  - Cells: $C_0=[0,1,2,3,4]$ (prism), $C_1=[0,5,6,7]$ (tetrahedron).\n- Case $\\mathrm{F}$ (inconsistent: three tetrahedra all sharing the same triangular face):\n  - Faces: $F_0=[0,1,2]$ (shared by all three), $F_1=[0,1,3]$, $F_2=[1,2,3]$, $F_3=[2,0,3]$, $F_4=[0,1,4]$, $F_5=[1,2,4]$, $F_6=[2,0,4]$, $F_7=[0,1,5]$, $F_8=[1,2,5]$, $F_9=[2,0,5]$.\n  - Cells: $C_0=[0,1,2,3]$, $C_1=[0,4,5,6]$, $C_2=[0,7,8,9]$.\n\nFinal output format. Your program should produce a single line of output containing the results for the cases $\\mathrm{A}$, $\\mathrm{B}$, $\\mathrm{C}$, $\\mathrm{D}$, $\\mathrm{E}$, $\\mathrm{F}$, as a comma-separated list enclosed in square brackets, for example, `[true,false,...]`, except using the native boolean literals of the programming language.", "solution": "We begin from fundamental definitions and counting principles. Let $\\mathcal{C}$ be the set of cells and $\\mathcal{F}$ be the set of faces. For each cell $c \\in \\mathcal{C}$, define $n_f(c)$ to be the count of faces incident to $c$. For each face $f \\in \\mathcal{F}$, define $m_c(f)$ to be the count of cells incident to $f$. We classify faces as internal if $m_c(f)=2$ and boundary if $m_c(f)=1$.\n\nCounting principle. Consider the set of cell-face incidences:\n$$\nI := \\{(c,f) \\in \\mathcal{C} \\times \\mathcal{F} \\,\\mid\\, f \\text{ is incident to } c\\}.\n$$\nBy the definition of $I$, counting by rows yields\n$$\n|I| \\;=\\; \\sum_{c \\in \\mathcal{C}} n_f(c).\n$$\nEquivalently, counting by columns yields\n$$\n|I| \\;=\\; \\sum_{f \\in \\mathcal{F}} m_c(f).\n$$\nIf the mesh is consistent, then each face is incident to either exactly two cells or exactly one cell. Therefore,\n$$\n\\sum_{f \\in \\mathcal{F}} m_c(f) \\;=\\; \\sum_{f \\in \\mathcal{F}_{\\mathrm{int}}} 2 \\;+\\; \\sum_{f \\in \\mathcal{F}_{\\mathrm{bnd}}} 1 \\;=\\; 2\\,N_{f,\\mathrm{int}} + N_{f,\\mathrm{bnd}},\n$$\nwhere $\\mathcal{F}_{\\mathrm{int}}$ is the subset of internal faces and $\\mathcal{F}_{\\mathrm{bnd}}$ is the subset of boundary faces. Combining the two expressions for $|I|$ yields the desired identity:\n$$\n\\sum_{c \\in \\mathcal{C}} n_f(c) \\;=\\; 2\\,N_{f,\\mathrm{int}} \\;+\\; N_{f,\\mathrm{bnd}}.\n$$\nIf consistency is violated, some face may have $m_c(f) \\notin \\{1,2\\}$, and the right-hand side $2\\,N_{f,\\mathrm{int}} + N_{f,\\mathrm{bnd}}$ does not count such incidences. In particular, if a face is incident to $k>2$ cells, its contribution of $k$ to $|I|$ is not represented on the right-hand side, and the identity fails.\n\nCompressed Sparse Row (CSR) design. To store the cell-to-face incidence compactly, form:\n- A flat integer array $\\mathrm{cell\\_faces}$ that concatenates the face indices of all cells, in order.\n- An offset array $\\mathrm{cell\\_face\\_offsets}$ of length $|\\mathcal{C}|+1$ such that, for cell index $c \\in \\{0,\\dots,|\\mathcal{C}|-1\\}$, the subarray $\\mathrm{cell\\_faces}[\\mathrm{cell\\_face\\_offsets}[c] : \\mathrm{cell\\_face\\_offsets}[c+1]]$ stores exactly the face indices of cell $c$.\nThis is constructed in linear time by prefix sums of the per-cell face counts.\n\nSimilarly, for face-to-node, form:\n- A flat integer array $\\mathrm{face\\_nodes}$ that concatenates the node indices of all faces, in order.\n- An offset array $\\mathrm{face\\_node\\_offsets}$ of length $|\\mathcal{F}|+1$ such that, for face index $f \\in \\{0,\\dots,|\\mathcal{F}|-1\\}$, the subarray $\\mathrm{face\\_nodes}[\\mathrm{face\\_node\\_offsets}[f] : \\mathrm{face\\_node\\_offsets}[f+1]]$ stores exactly the node indices of face $f$.\n\nBoth constructions are $O(M)$ where $M$ is the total number of stored incidences, i.e., $M = \\sum_{c \\in \\mathcal{C}} n_f(c)$ for the cell-to-face CSR and $M = \\sum_{f \\in \\mathcal{F}} n_v(f)$ for the face-to-node CSR, where $n_v(f)$ is the number of nodes of face $f$.\n\nAlgorithm to verify the identity. From the cell-to-face CSR, compute:\n- $S = \\sum_{c \\in \\mathcal{C}} n_f(c)$ as $\\mathrm{cell\\_face\\_offsets}[-1]$, the total length of $\\mathrm{cell\\_faces}$.\n- The number of incident cells per face by initializing an array $\\mathrm{face\\_cell\\_count}$ of length $|\\mathcal{F}|$ with zeros and incrementing $\\mathrm{face\\_cell\\_count}[f]$ for each face index $f$ encountered in $\\mathrm{cell\\_faces}$.\n- Then set $N_{f,\\mathrm{int}} = |\\{ f \\,\\mid\\, \\mathrm{face\\_cell\\_count}[f] = 2\\}|$ and $N_{f,\\mathrm{bnd}} = |\\{ f \\,\\mid\\, \\mathrm{face\\_cell\\_count}[f] = 1\\}|$.\nFinally check whether $S = 2\\,N_{f,\\mathrm{int}} + N_{f,\\mathrm{bnd}}$.\n\nApplication to the test suite.\n- Case $\\mathrm{A}$: One cell with $n_f(C_0)=4$, all faces boundary: $S=4$, $N_{f,\\mathrm{int}}=0$, $N_{f,\\mathrm{bnd}}=4$, identity gives $4=0+4$, true.\n- Case $\\mathrm{B}$: Two cells each with $4$ faces, one shared internal face, six boundary faces: $S=8$, $N_{f,\\mathrm{int}}=1$, $N_{f,\\mathrm{bnd}}=6$, identity gives $8=2\\cdot 1 + 6$, true.\n- Case $\\mathrm{C}$: One cube cell with $6$ faces, all boundary: $S=6$, $N_{f,\\mathrm{int}}=0$, $N_{f,\\mathrm{bnd}}=6$, identity gives $6=0+6$, true.\n- Case $\\mathrm{D}$: Disconnected tetrahedron and cube, no internal faces: $S=4+6=10$, $N_{f,\\mathrm{int}}=0$, $N_{f,\\mathrm{bnd}}=10$, identity gives $10=0+10$, true.\n- Case $\\mathrm{E}$: Prism with $5$ faces and tetrahedron with $4$ faces sharing one triangular face: $S=9$, $N_{f,\\mathrm{int}}=1$, $N_{f,\\mathrm{bnd}}=7$, identity gives $9=2\\cdot 1 + 7$, true.\n- Case $\\mathrm{F}$: Three tetrahedra sharing one triangular face (inconsistent): $S=12$, the shared face has $3$ incident cells and is counted neither as internal nor as boundary, while the other $9$ faces are boundary, so $N_{f,\\mathrm{int}}=0$, $N_{f,\\mathrm{bnd}}=9$, identity would read $12=0+9$, which is false; thus the check fails as expected.\n\nThus, the CSR design enables efficient counting, and the fundamental incidence counting principle proves the identity under consistency; violation of consistency breaks the hypothesis and the identity can fail.\n\nThe program implements the CSR construction and the verification for all six cases and outputs the six booleans in order as a single line.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_csr(list_of_lists):\n    \"\"\"\n    Build CSR (Compressed Sparse Row) arrays from a list-of-lists.\n    Returns (offsets, flat_values).\n    offsets has length n_lists + 1; flat_values is the concatenated data.\n    \"\"\"\n    offsets = [0]\n    flat = []\n    total = 0\n    for lst in list_of_lists:\n        flat.extend(lst)\n        total += len(lst)\n        offsets.append(total)\n    return np.array(offsets, dtype=int), np.array(flat, dtype=int)\n\ndef verify_sum_identity(cells_faces, num_faces):\n    \"\"\"\n    Given a list of cells (each as a list of face indices) and total number of faces,\n    compute:\n      S = sum_c n_f(c),\n      Nf_int = number of faces with exactly 2 incident cells,\n      Nf_bnd = number of faces with exactly 1 incident cell.\n    Return boolean indicating whether S == 2*Nf_int + Nf_bnd.\n    \"\"\"\n    # Build cell-to-face CSR\n    cell_face_offsets, cell_faces_flat = build_csr(cells_faces)\n\n    # Compute S\n    S = int(cell_face_offsets[-1])\n\n    # Count cell incidences per face\n    face_cell_count = np.zeros(num_faces, dtype=int)\n    for f in cell_faces_flat:\n        if f  0 or f >= num_faces:\n            # Invalid face index; break consistency and force failure\n            return False\n        face_cell_count[f] += 1\n\n    # Classify faces\n    Nf_int = int(np.count_nonzero(face_cell_count == 2))\n    Nf_bnd = int(np.count_nonzero(face_cell_count == 1))\n\n    # Check identity\n    return S == 2 * Nf_int + Nf_bnd\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Helper: construct face-to-node CSR too (for completeness, not directly used in check)\n    def faces_to_csr(faces):\n        return build_csr(faces)\n\n    results = []\n\n    # Case A: single tetrahedron\n    faces_A = [\n        [0, 1, 2],  # F0\n        [0, 1, 3],  # F1\n        [1, 2, 3],  # F2\n        [2, 0, 3],  # F3\n    ]\n    cells_A = [\n        [0, 1, 2, 3],  # C0\n    ]\n    # Build face-to-node CSR (design requirement)\n    _ = faces_to_csr(faces_A)\n    results.append(verify_sum_identity(cells_A, num_faces=len(faces_A)))\n\n    # Case B: two tetrahedra sharing one face\n    faces_B = [\n        [0, 1, 2],  # F0 shared\n        [0, 1, 3],  # F1\n        [1, 2, 3],  # F2\n        [2, 0, 3],  # F3\n        [0, 1, 4],  # F4\n        [1, 2, 4],  # F5\n        [2, 0, 4],  # F6\n    ]\n    cells_B = [\n        [0, 1, 2, 3],  # C0\n        [0, 4, 5, 6],  # C1\n    ]\n    _ = faces_to_csr(faces_B)\n    results.append(verify_sum_identity(cells_B, num_faces=len(faces_B)))\n\n    # Case C: single cube\n    faces_C = [\n        [0, 1, 2, 3],  # F0\n        [4, 5, 6, 7],  # F1\n        [0, 1, 5, 4],  # F2\n        [1, 2, 6, 5],  # F3\n        [2, 3, 7, 6],  # F4\n        [3, 0, 4, 7],  # F5\n    ]\n    cells_C = [\n        [0, 1, 2, 3, 4, 5],  # C0\n    ]\n    _ = faces_to_csr(faces_C)\n    results.append(verify_sum_identity(cells_C, num_faces=len(faces_C)))\n\n    # Case D: disconnected union of a tetrahedron and a cube\n    faces_D = [\n        [0, 1, 2],      # F0\n        [0, 1, 3],      # F1\n        [1, 2, 3],      # F2\n        [2, 0, 3],      # F3\n        [4, 5, 6, 7],   # F4\n        [8, 9, 10, 11], # F5\n        [4, 5, 9, 8],   # F6\n        [5, 6, 10, 9],  # F7\n        [6, 7, 11, 10], # F8\n        [7, 4, 8, 11],  # F9\n    ]\n    cells_D = [\n        [0, 1, 2, 3],              # C0 tetra\n        [4, 5, 6, 7, 8, 9],        # C1 cube\n    ]\n    _ = faces_to_csr(faces_D)\n    results.append(verify_sum_identity(cells_D, num_faces=len(faces_D)))\n\n    # Case E: triangular prism sharing one triangular face with a tetrahedron\n    faces_E = [\n        [0, 1, 2],      # F0 shared triangular\n        [3, 4, 5],      # F1 triangular\n        [0, 1, 4, 3],   # F2 quad\n        [1, 2, 5, 4],   # F3 quad\n        [2, 0, 3, 5],   # F4 quad\n        [0, 1, 6],      # F5 triangular\n        [1, 2, 6],      # F6 triangular\n        [2, 0, 6],      # F7 triangular\n    ]\n    cells_E = [\n        [0, 1, 2, 3, 4],  # prism\n        [0, 5, 6, 7],     # tetra\n    ]\n    _ = faces_to_csr(faces_E)\n    results.append(verify_sum_identity(cells_E, num_faces=len(faces_E)))\n\n    # Case F: inconsistent three tetrahedra sharing one triangular face\n    faces_F = [\n        [0, 1, 2],  # F0 shared by all three\n        [0, 1, 3],  # F1\n        [1, 2, 3],  # F2\n        [2, 0, 3],  # F3\n        [0, 1, 4],  # F4\n        [1, 2, 4],  # F5\n        [2, 0, 4],  # F6\n        [0, 1, 5],  # F7\n        [1, 2, 5],  # F8\n        [2, 0, 5],  # F9\n    ]\n    cells_F = [\n        [0, 1, 2, 3],  # tetra 1\n        [0, 4, 5, 6],  # tetra 2\n        [0, 7, 8, 9],  # tetra 3\n    ]\n    _ = faces_to_csr(faces_F)\n    results.append(verify_sum_identity(cells_F, num_faces=len(faces_F)))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nsolve()\n```", "id": "3303802"}]}