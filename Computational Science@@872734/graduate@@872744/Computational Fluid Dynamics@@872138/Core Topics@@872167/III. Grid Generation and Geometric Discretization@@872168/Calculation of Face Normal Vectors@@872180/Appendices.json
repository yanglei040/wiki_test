{"hands_on_practices": [{"introduction": "The calculation of face normal vectors is the cornerstone of the finite volume method, directly linking geometry to the physics of conservation laws. This first exercise grounds this principle by having you compute the net flux of a vector field through a simple rectangular control volume by hand. By explicitly calculating the contribution from each face, you will build a concrete understanding of how outward-pointing normals are used to enforce the divergence theorem in its discrete form, a fundamental operation in any CFD code.", "problem": "Consider a two-dimensional rectangular control volume $\\Omega$ in a Cartesian mesh used in Computational Fluid Dynamics (CFD), with geometric center at $(x_{c}, y_{c})$ and side lengths $\\Delta x$ and $\\Delta y$. The rectangle is axis-aligned, so that its boundary $\\partial \\Omega$ consists of four straight edges located at $x = x_{c} \\pm \\Delta x/2$ and $y = y_{c} \\pm \\Delta y/2$. A linear, spatially varying velocity field is prescribed as $\\mathbf{u}(x,y) = \\begin{pmatrix} a x + b y + c \\\\ d x + e y + f \\end{pmatrix}$, where $a$, $b$, $c$, $d$, $e$, and $f$ are constants. Assume all quantities are nondimensional.\n\nTasks:\n- Identify the outward unit normal vectors for each edge of $\\partial \\Omega$.\n- Using the fundamental definition of the outward normal flux, evaluate the contour integral $\\displaystyle \\oint_{\\partial \\Omega} \\mathbf{u} \\cdot \\hat{n} \\, d\\ell$ exactly, in closed form.\n\nExpress your final answer as a single, simplified analytic expression in terms of $a$, $b$, $c$, $d$, $e$, $f$, $\\Delta x$, and $\\Delta y$. Do not include units. No rounding is required.", "solution": "We begin from the fundamental definition of the flux of a vector field $\\mathbf{u}$ through a boundary $\\partial \\Omega$ with outward unit normal $\\hat{n}$, given by the line integral $\\displaystyle \\oint_{\\partial \\Omega} \\mathbf{u} \\cdot \\hat{n} \\, d\\ell$. For an axis-aligned rectangle, the four edges have constant outward unit normals.\n\nGeometry and normals:\n- Right (east) edge: $x = x_{c} + \\Delta x/2$, $y \\in [y_{c} - \\Delta y/2, \\, y_{c} + \\Delta y/2]$, outward unit normal $\\hat{n}_{E} = (1, 0)^{\\top}$.\n- Left (west) edge: $x = x_{c} - \\Delta x/2$, $y \\in [y_{c} - \\Delta y/2, \\, y_{c} + \\Delta y/2]$, outward unit normal $\\hat{n}_{W} = (-1, 0)^{\\top}$.\n- Top (north) edge: $y = y_{c} + \\Delta y/2$, $x \\in [x_{c} - \\Delta x/2, \\, x_{c} + \\Delta x/2]$, outward unit normal $\\hat{n}_{N} = (0, 1)^{\\top}$.\n- Bottom (south) edge: $y = y_{c} - \\Delta y/2$, $x \\in [x_{c} - \\Delta x/2, \\, x_{c} + \\Delta x/2]$, outward unit normal $\\hat{n}_{S} = (0, -1)^{\\top}$.\n\nWe evaluate the flux as the sum of four edge integrals, using the definition $\\displaystyle \\int_{\\text{edge}} \\mathbf{u} \\cdot \\hat{n} \\, d\\ell$ and parameterizing each straight edge by its coordinate variable.\n\nEast edge:\n- Parameterization: $x = x_{E} := x_{c} + \\Delta x/2$, $y \\in [y_{-}, y_{+}]$ with $y_{\\pm} := y_{c} \\pm \\Delta y/2$, and $d\\ell = dy$.\n- Integrand: $\\mathbf{u} \\cdot \\hat{n}_{E} = u_{x}(x,y) = a x + b y + c$ evaluated at $x = x_{E}$.\n- Integral:\n$$\n\\Phi_{E} = \\int_{y_{-}}^{y_{+}} \\left( a x_{E} + b y + c \\right) \\, dy = \\left( a x_{E} + c \\right) \\Delta y + b \\int_{y_{-}}^{y_{+}} y \\, dy.\n$$\nUsing $\\int_{y_{-}}^{y_{+}} y \\, dy = \\tfrac{1}{2} \\left( y_{+}^{2} - y_{-}^{2} \\right) = y_{c} \\Delta y$, we obtain\n$$\n\\Phi_{E} = \\Delta y \\left( a x_{E} + b y_{c} + c \\right).\n$$\n\nWest edge:\n- Parameterization: $x = x_{W} := x_{c} - \\Delta x/2$, $y \\in [y_{-}, y_{+}]$, $d\\ell = dy$.\n- Integrand: $\\mathbf{u} \\cdot \\hat{n}_{W} = - u_{x}(x,y) = - \\left( a x + b y + c \\right)$ at $x = x_{W}$.\n- Integral:\n$$\n\\Phi_{W} = \\int_{y_{-}}^{y_{+}} \\left( - a x_{W} - b y - c \\right) \\, dy = - \\Delta y \\left( a x_{W} + b y_{c} + c \\right).\n$$\n\nSumming east and west contributions:\n$$\n\\Phi_{E} + \\Phi_{W} = \\Delta y \\left[ a \\left( x_{E} - x_{W} \\right) + \\left( b y_{c} + c \\right) - \\left( b y_{c} + c \\right) \\right] = \\Delta y \\, a \\left( x_{E} - x_{W} \\right).\n$$\nSince $x_{E} - x_{W} = \\left( x_{c} + \\tfrac{\\Delta x}{2} \\right) - \\left( x_{c} - \\tfrac{\\Delta x}{2} \\right) = \\Delta x$, we get\n$$\n\\Phi_{E} + \\Phi_{W} = a \\, \\Delta x \\, \\Delta y.\n$$\n\nNorth edge:\n- Parameterization: $y = y_{N} := y_{c} + \\Delta y/2$, $x \\in [x_{-}, x_{+}]$ with $x_{\\pm} := x_{c} \\pm \\Delta x/2$, and $d\\ell = dx$.\n- Integrand: $\\mathbf{u} \\cdot \\hat{n}_{N} = u_{y}(x,y) = d x + e y + f$ at $y = y_{N}$.\n- Integral:\n$$\n\\Phi_{N} = \\int_{x_{-}}^{x_{+}} \\left( d x + e y_{N} + f \\right) \\, dx = d \\int_{x_{-}}^{x_{+}} x \\, dx + \\left( e y_{N} + f \\right) \\Delta x.\n$$\nUsing $\\int_{x_{-}}^{x_{+}} x \\, dx = \\tfrac{1}{2} \\left( x_{+}^{2} - x_{-}^{2} \\right) = x_{c} \\Delta x$, we obtain\n$$\n\\Phi_{N} = d \\, x_{c} \\, \\Delta x + \\left( e y_{N} + f \\right) \\Delta x.\n$$\n\nSouth edge:\n- Parameterization: $y = y_{S} := y_{c} - \\Delta y/2$, $x \\in [x_{-}, x_{+}]$, $d\\ell = dx$.\n- Integrand: $\\mathbf{u} \\cdot \\hat{n}_{S} = - u_{y}(x,y) = - \\left( d x + e y + f \\right)$ at $y = y_{S}$.\n- Integral:\n$$\n\\Phi_{S} = \\int_{x_{-}}^{x_{+}} \\left( - d x - e y_{S} - f \\right) \\, dx = - d \\int_{x_{-}}^{x_{+}} x \\, dx - \\left( e y_{S} + f \\right) \\Delta x.\n$$\nThus,\n$$\n\\Phi_{S} = - d \\, x_{c} \\, \\Delta x - \\left( e y_{S} + f \\right) \\Delta x.\n$$\n\nSumming north and south contributions:\n$$\n\\Phi_{N} + \\Phi_{S} = \\left[ d x_{c} \\Delta x + \\left( e y_{N} + f \\right) \\Delta x \\right] + \\left[ - d x_{c} \\Delta x - \\left( e y_{S} + f \\right) \\Delta x \\right] = \\Delta x \\, e \\left( y_{N} - y_{S} \\right).\n$$\nSince $y_{N} - y_{S} = \\Delta y$, we have\n$$\n\\Phi_{N} + \\Phi_{S} = e \\, \\Delta x \\, \\Delta y.\n$$\n\nTotal outward flux:\n$$\n\\oint_{\\partial \\Omega} \\mathbf{u} \\cdot \\hat{n} \\, d\\ell \\;=\\; \\left( \\Phi_{E} + \\Phi_{W} \\right) + \\left( \\Phi_{N} + \\Phi_{S} \\right) \\;=\\; a \\, \\Delta x \\, \\Delta y \\;+\\; e \\, \\Delta x \\, \\Delta y \\;=\\; \\left( a + e \\right) \\Delta x \\, \\Delta y.\n$$\n\nAs a consistency check using the divergence theorem (Gauss’s theorem), for a linear field $\\mathbf{u}(x,y)$ with constant divergence $\\nabla \\cdot \\mathbf{u} = \\partial u_{x}/\\partial x + \\partial u_{y}/\\partial y = a + e$, one has $\\displaystyle \\oint_{\\partial \\Omega} \\mathbf{u} \\cdot \\hat{n} \\, d\\ell = \\iint_{\\Omega} \\nabla \\cdot \\mathbf{u} \\, dA = \\left( a + e \\right) \\, \\text{area}(\\Omega) = \\left( a + e \\right) \\Delta x \\Delta y$, in agreement with the direct edge-by-edge evaluation above.\n\nTherefore, the exact closed-form expression for the contour integral is $\\left( a + e \\right) \\Delta x \\Delta y$.", "answer": "$$\\boxed{(a+e)\\,\\Delta x\\,\\Delta y}$$", "id": "3297266"}, {"introduction": "While simple geometries provide a clear starting point, real-world CFD meshes often contain complex, non-convex polygonal faces. This practice challenges you to think critically about the algorithms used to compute a face's area vector, a quantity defined by its normal and scalar area. You will analyze how different triangulation strategies behave on concave polygons, revealing the subtle geometric conditions required for an algorithm to be robust and correct, a crucial consideration for developing reliable CFD solvers.", "problem": "In the finite volume formulation of computational fluid dynamics, the vector area of a planar face is defined by the surface integral $\\mathbf{S} = \\int_{F} \\hat{\\mathbf{n}} \\, dA$, where $F$ is the polygonal face and $\\hat{\\mathbf{n}}$ is the outward unit normal. Consider a simple planar polygon in three-dimensional space with ordered vertices $\\{\\mathbf{r}_1,\\mathbf{r}_2,\\dots,\\mathbf{r}_N\\}$ listed counterclockwise when viewed from the outward side (consistent with $\\hat{\\mathbf{n}}$). Two widely used practical constructions approximate $\\mathbf{S}$ by summing triangle contributions formed by triangulating the face from a reference point:\n\n- A centroid-based triangulation that chooses a reference point $\\mathbf{r}_c$ (for concreteness, assume the arithmetic mean of the vertices $\\mathbf{r}_c = \\frac{1}{N}\\sum_{i=1}^N \\mathbf{r}_i$) and forms the triangles $(\\mathbf{r}_c,\\mathbf{r}_i,\\mathbf{r}_{i+1})$ for $i=1,\\dots,N$ with the convention $\\mathbf{r}_{N+1}=\\mathbf{r}_1$.\n\n- A vertex-based “fan” triangulation that chooses $\\mathbf{r}_1$ and forms the triangles $(\\mathbf{r}_1,\\mathbf{r}_i,\\mathbf{r}_{i+1})$ for $i=2,\\dots,N-1$.\n\nEach triangle contributes an area vector that can be accumulated in two distinct ways:\n\n- An oriented accumulation that uses the vector cross product of triangle edge vectors and keeps the sign determined by the right-hand rule consistent with the vertex ordering.\n\n- An unsigned accumulation that replaces each triangle’s vector contribution by its magnitude projected on a single prescribed unit normal $\\hat{\\mathbf{n}}$ (for example the known face normal), i.e., discarding any sign reversals that occur in the oriented accumulation.\n\nAssume the polygon is concave but simple (no self-intersections). A polygon is said to be star-shaped with respect to a point $\\mathbf{p}$ if every line segment joining $\\mathbf{p}$ to any point in the polygon lies entirely within the polygon; equivalently, $\\mathbf{p}$ lies in the polygon’s kernel. Identify which of the following statements about when these two triangulation strategies recover the correct $\\mathbf{S}$ are true.\n\nA. If the oriented accumulation is used, both the centroid-based and the vertex-based triangulation produce exactly the same vector $\\mathbf{S}$ for any simple planar polygon, whether convex or concave.\n\nB. If the unsigned accumulation is used, the centroid-based triangulation yields the correct vector $\\mathbf{S}$ if and only if the chosen centroid lies in the polygon’s kernel; this condition holds automatically for convex polygons but is not guaranteed for concave polygons.\n\nC. For any concave simple polygon with vertices in consistent order, the vertex-based fan triangulation using the unsigned accumulation still yields the correct vector $\\mathbf{S}$.\n\nD. If the unsigned accumulation is used, the vertex-based fan triangulation yields the correct vector $\\mathbf{S}$ if and only if the polygon is star-shaped with respect to the chosen vertex $\\mathbf{r}_1$.", "solution": "Let the exact vector area of the simple planar polygon with ordered vertices $\\{\\mathbf{r}_1, \\dots, \\mathbf{r}_N\\}$ be $\\mathbf{S}$. This can be calculated exactly using the formula $\\mathbf{S} = \\frac{1}{2} \\sum_{i=1}^{N} (\\mathbf{r}_i \\times \\mathbf{r}_{i+1})$, where $\\mathbf{r}_{N+1}=\\mathbf{r}_1$. This formula is derived from Stokes' theorem and is valid regardless of convexity. We analyze each statement against this ground truth.\n\n**A. Oriented Accumulation**\nWith oriented accumulation, we sum the vector areas of the triangles. For any reference point $\\mathbf{r}_{\\text{ref}}$, the sum of triangle vector areas is $\\sum \\frac{1}{2} (\\mathbf{r}_i - \\mathbf{r}_{\\text{ref}}) \\times (\\mathbf{r}_{i+1} - \\mathbf{r}_{\\text{ref}})$. Algebraic expansion shows that all terms involving $\\mathbf{r}_{\\text{ref}}$ form a telescoping sum that cancels to zero, leaving behind the exact formula $\\frac{1}{2} \\sum (\\mathbf{r}_i \\times \\mathbf{r}_{i+1})$. This mathematical identity holds true for *any* simple planar polygon (convex or concave) and for *any* choice of reference point, including the centroid or a vertex. Therefore, both the centroid-based and vertex-based methods with oriented accumulation produce the exact same, correct vector $\\mathbf{S}$. **This statement is true.**\n\n**B. Unsigned Accumulation, Centroid-Based**\nUnsigned accumulation sums the absolute magnitudes of the triangle areas. This only yields the correct total area if all triangles in the triangulation have a positive signed area (i.e., their vertices are all ordered counterclockwise with respect to the face normal). For the centroid-based method, this means that for every edge $(\\mathbf{r}_i, \\mathbf{r}_{i+1})$, the reference point $\\mathbf{r}_c$ must lie on the \"inside\" of the line defined by that edge. The set of all points that satisfy this condition for all edges is the polygon's *kernel*. Thus, the method is correct if and only if the chosen centroid $\\mathbf{r}_c$ lies within the polygon's kernel. For any convex polygon, the kernel is the polygon itself, and the centroid is always inside. For a concave polygon, the kernel can be small or even empty, and the arithmetic mean of vertices is not guaranteed to lie inside it. **This statement is true.**\n\n**C. Unsigned Accumulation, Vertex-Based**\nThis statement claims the vertex-based fan triangulation with unsigned accumulation is correct for *any* concave polygon. This is false. Consider a dart-shaped concave quadrilateral. If the fan triangulation originates from the vertex at the \"point\" of the dart, one of the triangles will lie partially or wholly outside the polygon, and its vertices will be ordered clockwise. The unsigned accumulation would add its area instead of subtracting it, leading to an incorrect result. Correctness depends on the polygon being star-shaped with respect to the chosen vertex, which is not true for all concave polygons. **This statement is false.**\n\n**D. Unsigned Accumulation, Vertex-Based**\nFollowing the logic from B and C, the vertex-based fan triangulation with unsigned accumulation is correct if and only if all triangles in the fan, $(\\mathbf{r}_1, \\mathbf{r}_i, \\mathbf{r}_{i+1})$, have a positive signed area. This geometric condition is equivalent to saying that every point in the polygon is \"visible\" from the reference vertex $\\mathbf{r}_1$ without crossing an edge. This is precisely the definition of the polygon being star-shaped with respect to $\\mathbf{r}_1$ (i.e., $\\mathbf{r}_1$ is in the polygon's kernel). **This statement is true.**", "answer": "$$\\boxed{ABD}$$", "id": "3297342"}, {"introduction": "Modern CFD simulations rely on parallel computing, where the computational domain is partitioned across many processors. This introduces a new challenge: ensuring global conservation across subdomain boundaries. This final practice explores how inconsistent face normal orientations at these internal boundaries can violate conservation by causing artificial \"double counting\" of fluxes. You will design a distributed algorithm to enforce a consistent orientation, illustrating a critical concept in the development of scalable, high-performance CFD codes.", "problem": "Consider a finite volume discretization of the conservation of linear momentum for a compressible fluid. The net convective momentum flux across a face is obtained by integrating the product of mass flux and velocity over that face. For a planar face, this reduces to computing a scalar mass flux and then associating a momentum flux vector to the face. Define the following quantities for any face $f$: the vector of fluid velocity at the face $\\mathbf{u}_f \\in \\mathbb{R}^3$ in $\\mathrm{m/s}$, the fluid density at the face $\\rho_f$ in $\\mathrm{kg/m^3}$, the face area $A_f$ in $\\mathrm{m^2}$, and the unit face normal vector $\\mathbf{n}_f$ pointing outward relative to the local control volume. The mass flux through the face is $\\dot{m}_f = \\rho_f \\, (\\mathbf{u}_f \\cdot \\mathbf{n}_f) \\, A_f$ in $\\mathrm{kg/s}$, and the associated convective momentum flux vector is $\\mathbf{F}_f = \\dot{m}_f \\, \\mathbf{u}_f$ in $\\mathrm{N}$.\n\nIn a parallel domain decomposition, internal faces are duplicated across subdomain boundaries: each subdomain possesses its copy of the shared face with its own outward unit normal, leading to $\\mathbf{n}_f^{(i)}$ and $\\mathbf{n}_f^{(j)}$ for adjacent subdomains $i$ and $j$, typically satisfying $\\mathbf{n}_f^{(j)} = - \\mathbf{n}_f^{(i)}$. A naive aggregation of global momentum flux that sums the magnitudes $\\|\\mathbf{F}_f\\|$ across all subdomain boundary faces can lead to double counting of internal faces if the orientation is not made globally consistent and duplicates are not suppressed. This violates the intended cancellation of internal contributions implied by the divergence theorem and conservation laws.\n\nYour tasks are:\n- Starting from the divergence theorem and the integral form of momentum conservation, explain why, when summing over subdomains, internal shared faces must not contribute to the net momentum flux across the global external boundary if face normals are oriented consistently and duplicates are reconciled. In particular, derive the condition on the orientation of face normals across internal faces necessary to ensure cancellation of internal convective momentum flux contributions in the global sum.\n- For triangular faces, derive how to compute a canonical unit normal vector $\\widehat{\\mathbf{n}}_f$ using the right-hand rule from the ordered vertex positions $\\mathbf{x}_0$, $\\mathbf{x}_1$, $\\mathbf{x}_2 \\in \\mathbb{R}^3$, and compute the face area $A_f$.\n- Show how inconsistent orientation and naive magnitude aggregation causes double counting of momentum flux across internal faces.\n- Design a distributed algorithm that guarantees global normal orientation consistency and suppresses duplicate counting with minimal communication between neighboring subdomains. Your algorithm must be based on canonical face identifiers constructed from globally unique vertex identifiers, a deterministic ownership rule for each shared face, and a local operation to flip the sign of $\\mathbf{n}_f$ to match the canonical orientation.\n\nThen implement a program that:\n- Emulates three test scenarios of subdomain decompositions with triangular faces specified by their vertex coordinates (in $\\mathrm{m}$), global vertex identifiers (integers), local outward normal orientations per subdomain side (signs $+1$ or $-1$ relative to the canonical), and uniform face-centered fluid states $(\\rho_f, \\mathbf{u}_f)$.\n- Computes, for each scenario, the naive global total momentum flux magnitude (in $\\mathrm{N}$) by summing $\\|\\mathbf{F}_f\\|$ over all subdomain boundary faces, including internal shared faces on both sides.\n- Computes the correct global total momentum flux magnitude (in $\\mathrm{N}$) by summing $\\|\\mathbf{F}_f\\|$ only over external boundary faces, excluding internal shared faces, under consistent orientation.\n- Applies your algorithm to eliminate double counting and align local normals to the canonical orientation, and recomputes the corrected naive global total momentum flux magnitude (in $\\mathrm{N}$), which should match the correct global total momentum flux magnitude.\n- Reports the number of double-counted internal faces before algorithm application, the naive global total momentum flux magnitude (in $\\mathrm{N}$), the correct global total momentum flux magnitude (in $\\mathrm{N}$), the absolute error (in $\\mathrm{N}$) between naive and correct totals, the number of double-counted internal faces after algorithm application, the corrected naive global total momentum flux magnitude (in $\\mathrm{N}$), and the corrected absolute error (in $\\mathrm{N}$). All flux magnitudes and errors must be reported in $\\mathrm{N}$, rounded to six decimal places.\n\nFundamental base and definitions to be used:\n- The divergence theorem for a vector field $\\mathbf{g}$ over a control volume $\\Omega$ with boundary $\\partial \\Omega$: $\\int_{\\Omega} \\nabla \\cdot \\mathbf{g} \\, dV = \\int_{\\partial \\Omega} \\mathbf{g} \\cdot \\mathbf{n} \\, dS$.\n- The integral form of momentum conservation that relates the net flux across the boundary to the change of momentum inside the volume and external forces.\n- For triangular faces with ordered vertices $\\mathbf{x}_0$, $\\mathbf{x}_1$, $\\mathbf{x}_2$, the canonical (right-hand rule) unit normal is $\\widehat{\\mathbf{n}}_f = \\dfrac{(\\mathbf{x}_1 - \\mathbf{x}_0) \\times (\\mathbf{x}_2 - \\mathbf{x}_0)}{\\left\\|(\\mathbf{x}_1 - \\mathbf{x}_0) \\times (\\mathbf{x}_2 - \\mathbf{x}_0)\\right\\|}$, and the area is $A_f = \\dfrac{1}{2} \\left\\|(\\mathbf{x}_1 - \\mathbf{x}_0) \\times (\\mathbf{x}_2 - \\mathbf{x}_0)\\right\\|$.\n\nTest suite specification:\n- Scenario $1$ (two subdomains with one internal face and one external face each):\n    - Shared internal face $f_{\\mathrm{int}}$: vertices $\\mathbf{x}_0 = (0,0,0)$, $\\mathbf{x}_1 = (1,0,0)$, $\\mathbf{x}_2 = (0,1,0)$, vertex identifiers $(0,1,2)$. Subdomain $0$ side: local sign $+1$, $\\rho_f = 1\\,\\mathrm{kg/m^3}$, $\\mathbf{u}_f = (0,0,2)\\,\\mathrm{m/s}$, internal. Subdomain $1$ side: local sign $-1$, $\\rho_f = 1\\,\\mathrm{kg/m^3}$, $\\mathbf{u}_f = (0,0,2)\\,\\mathrm{m/s}$, internal.\n    - External face of subdomain $0$: vertices $\\mathbf{x}_0 = (0,0,1)$, $\\mathbf{x}_1 = (1,0,1)$, $\\mathbf{x}_2 = (0,1,1)$, vertex identifiers $(3,4,5)$, local sign $+1$, $\\rho_f = 1\\,\\mathrm{kg/m^3}$, $\\mathbf{u}_f = (0,0,2)\\,\\mathrm{m/s}$, external.\n    - External face of subdomain $1$: vertices $\\mathbf{x}_0 = (0,0,2)$, $\\mathbf{x}_1 = (1,0,2)$, $\\mathbf{x}_2 = (0,1,2)$, vertex identifiers $(6,7,8)$, local sign $+1$, $\\rho_f = 1\\,\\mathrm{kg/m^3}$, $\\mathbf{u}_f = (0,0,2)\\,\\mathrm{m/s}$, external.\n- Scenario $2$ (two subdomains with one internal face orthogonal to flow and one external face each):\n    - Shared internal face $f_{\\mathrm{int}}$: vertices $\\mathbf{x}_0 = (0,0,0)$, $\\mathbf{x}_1 = (1,0,0)$, $\\mathbf{x}_2 = (0,1,0)$, vertex identifiers $(0,1,2)$. Subdomain $0$ side: local sign $+1$, $\\rho_f = 1\\,\\mathrm{kg/m^3}$, $\\mathbf{u}_f = (2,0,0)\\,\\mathrm{m/s}$, internal. Subdomain $1$ side: local sign $-1$, $\\rho_f = 1\\,\\mathrm{kg/m^3}$, $\\mathbf{u}_f = (2,0,0)\\,\\mathrm{m/s}$, internal.\n    - External face of subdomain $0$: vertices $\\mathbf{x}_0 = (0,0,0)$, $\\mathbf{x}_1 = (0,1,0)$, $\\mathbf{x}_2 = (0,0,1)$, vertex identifiers $(10,11,12)$, local sign $+1$, $\\rho_f = 1\\,\\mathrm{kg/m^3}$, $\\mathbf{u}_f = (2,0,0)\\,\\mathrm{m/s}$, external.\n    - External face of subdomain $1$: vertices $\\mathbf{x}_0 = (0,0,0)$, $\\mathbf{x}_1 = (0,1,0)$, $\\mathbf{x}_2 = (0,0,1)$, vertex identifiers $(13,14,15)$, local sign $+1$, $\\rho_f = 1\\,\\mathrm{kg/m^3}$, $\\mathbf{u}_f = (2,0,0)\\,\\mathrm{m/s}$, external.\n- Scenario $3$ (three subdomains in a chain with two internal faces and external faces):\n    - Shared internal face $f_{01}$ between subdomains $0$ and $1$: vertices $\\mathbf{x}_0 = (0,0,0)$, $\\mathbf{x}_1 = (0,0,1)$, $\\mathbf{x}_2 = (1,0,0)$, vertex identifiers $(20,21,22)$. Subdomain $0$ side: local sign $+1$, $\\rho_f = 1\\,\\mathrm{kg/m^3}$, $\\mathbf{u}_f = (0,3,0)\\,\\mathrm{m/s}$, internal. Subdomain $1$ side: local sign $-1$, $\\rho_f = 1\\,\\mathrm{kg/m^3}$, $\\mathbf{u}_f = (0,3,0)\\,\\mathrm{m/s}$, internal.\n    - Shared internal face $f_{12}$ between subdomains $1$ and $2$: vertices $\\mathbf{x}_0 = (0,0,0)$, $\\mathbf{x}_1 = (0,1,0)$, $\\mathbf{x}_2 = (0,0,1)$, vertex identifiers $(23,24,25)$. Subdomain $1$ side: local sign $+1$, $\\rho_f = 1\\,\\mathrm{kg/m^3}$, $\\mathbf{u}_f = (4,0,0)\\,\\mathrm{m/s}$, internal. Subdomain $2$ side: local sign $-1$, $\\rho_f = 1\\,\\mathrm{kg/m^3}$, $\\mathbf{u}_f = (4,0,0)\\,\\mathrm{m/s}$, internal.\n    - External face of subdomain $0$: vertices $\\mathbf{x}_0 = (0,0,0)$, $\\mathbf{x}_1 = (1,0,0)$, $\\mathbf{x}_2 = (0,1,0)$, vertex identifiers $(30,31,32)$, local sign $+1$, $\\rho_f = 1\\,\\mathrm{kg/m^3}$, $\\mathbf{u}_f = (0,0,2)\\,\\mathrm{m/s}$, external.\n    - External face of subdomain $1$: vertices $\\mathbf{x}_0 = (0,0,1)$, $\\mathbf{x}_1 = (1,0,1)$, $\\mathbf{x}_2 = (0,1,1)$, vertex identifiers $(33,34,35), local sign $+1$, $\\rho_f = 1\\,\\mathrm{kg/m^3}$, $\\mathbf{u}_f = (0,0,1)\\,\\mathrm{m/s}$, external.\n    - External face of subdomain $2$: vertices $\\mathbf{x}_0 = (0,0,0)$, $\\mathbf{x}_1 = (0,1,0)$, $\\mathbf{x}_2 = (0,0,1)$, vertex identifiers $(36,37,38), local sign $+1$, $\\rho_f = 1\\,\\mathrm{kg/m^3}$, $\\mathbf{u}_f = (2,0,0)\\,\\mathrm{m/s}$, external.\n\nYour program should produce a single line of output containing the results for the three scenarios as a comma-separated list enclosed in square brackets, where each scenario’s result is a list in the order:\n$[\\text{double\\_counted\\_before}, \\text{naive\\_total\\_flux\\_N}, \\text{correct\\_total\\_flux\\_N}, \\text{error\\_N}, \\text{double\\_counted\\_after}, \\text{corrected\\_total\\_flux\\_N}, \\text{corrected\\_error\\_N}]$.\nAll flux values must be in $\\mathrm{N}$ and rounded to six decimal places. For example, the output format should look like $[[a_1,b_1,c_1,d_1,e_1,f_1,g_1],[a_2,b_2,c_2,d_2,e_2,f_2,g_2],[a_3,b_3,c_3,d_3,e_3,f_3,g_3]]$ with $a_i$ integers and $b_i,c_i,d_i,f_i,g_i$ floats. No other text should be printed.", "solution": "The problem is valid as it is scientifically grounded in the principles of fluid dynamics and vector calculus, is well-posed, objective, and provides a complete and consistent setup for both the theoretical derivation and the computational implementation.\n\n### Theoretical Foundation and Algorithmic Design\n\n**1. Cancellation of Internal Fluxes from the Divergence Theorem**\n\nThe integral form of a conservation law for a quantity, derived from the Reynolds transport theorem, relates the rate of change of the quantity within a control volume $\\Omega$ to the net flux of that quantity across the boundary $\\partial \\Omega$. For the conservation of linear momentum, the convective momentum flux term is $\\int_{\\partial \\Omega} (\\rho \\mathbf{u} \\otimes \\mathbf{u}) \\cdot \\mathbf{n} \\, dS$.\n\nIn a domain decomposition, the global domain $\\Omega$ is partitioned into subdomains $\\Omega_i$. Applying the divergence theorem, the total flux across the global boundary $\\partial\\Omega$ is equivalent to the sum of fluxes over all subdomain boundaries:\n$$\n\\int_{\\partial \\Omega} (\\rho \\mathbf{u} \\otimes \\mathbf{u}) \\cdot \\mathbf{n} \\, dS = \\sum_i \\int_{\\partial \\Omega_i} (\\rho \\mathbf{u} \\otimes \\mathbf{u}) \\cdot \\mathbf{n}^{(i)} \\, dS\n$$\nwhere $\\mathbf{n}^{(i)}$ is the outward-pointing unit normal for subdomain $\\Omega_i$. An internal face $f_{ij}$ shared between subdomains $\\Omega_i$ and $\\Omega_j$ appears twice in the sum. For the internal contributions to cancel, the sum of fluxes must be zero:\n$$\n\\int_{f_{ij}} (\\rho \\mathbf{u} \\otimes \\mathbf{u}) \\cdot \\mathbf{n}^{(i)} \\, dS + \\int_{f_{ij}} (\\rho \\mathbf{u} \\otimes \\mathbf{u}) \\cdot \\mathbf{n}^{(j)} \\, dS = 0\n$$\nSince the fluid state is continuous across the face, this requires a purely geometric condition on the normals: $\\mathbf{n}^{(i)} = - \\mathbf{n}^{(j)}$. If this holds, the discrete momentum fluxes are opposite, $\\mathbf{F}_f^{(i)} = - \\mathbf{F}_f^{(j)}$, and their vector sum is zero.\n\n**2. Canonical Normal and Area of a Triangular Face**\n\nGiven ordered vertices $\\mathbf{x}_0, \\mathbf{x}_1, \\mathbf{x}_2$, edge vectors are $\\mathbf{v}_1 = \\mathbf{x}_1 - \\mathbf{x}_0$ and $\\mathbf{v}_2 = \\mathbf{x}_2 - \\mathbf{x}_0$. The area is half the magnitude of their cross product, $A_f = \\frac{1}{2} \\|\\mathbf{v}_1 \\times \\mathbf{v}_2\\|$, and the canonical unit normal is $\\widehat{\\mathbf{n}}_f = (\\mathbf{v}_1 \\times \\mathbf{v}_2) / \\|\\mathbf{v}_1 \\times \\mathbf{v}_2\\|$.\n\n**3. The Error of Naive Magnitude Aggregation**\n\nA naive aggregation sums the magnitudes $\\|\\mathbf{F}_f\\|$ over all faces of all subdomains. For an internal face, even if normals are consistent ($\\mathbf{F}_f^{(j)} = -\\mathbf{F}_f^{(i)}$), the magnitudes are equal: $\\|\\mathbf{F}_f^{(j)}\\| = \\|\\mathbf{F}_f^{(i)}\\|$. The naive sum incorrectly includes $2\\|\\mathbf{F}_f^{(i)}\\|$ instead of zero, violating conservation by \"double counting\" internal fluxes.\n\n**4. Distributed Algorithm for Consistent Aggregation**\n\nA distributed algorithm to correct this involves:\n1.  **Canonical Identification**: Each subdomain computes an orientation-independent, globally unique ID for each face from a sorted tuple of its global vertex IDs.\n2.  **Classification**: By exchanging face IDs with neighbors (emulated here by the 'internal'/'external' tags), each subdomain classifies its faces.\n3.  **Flux Suppression**: For a global boundary flux summation (which is a sum of magnitudes), each subdomain includes the contribution $\\|\\mathbf{F}_f\\|$ only for faces classified as 'external'. Contributions from 'internal' faces are set to zero. This correctly eliminates the double counting.\n\n### Implementation\n\nThe following Python code implements the flux calculations for each scenario and applies the flux suppression algorithm to report the required values.\n\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational fluid dynamics problem for three scenarios.\n    \"\"\"\n\n    class Face:\n        \"\"\"\n        Represents a triangular face in a subdomain.\n        \"\"\"\n        def __init__(self, subdomain_id, vertices, vertex_ids, local_sign, rho, u, face_type):\n            self.subdomain_id = int(subdomain_id)\n            self.vertices = np.array(vertices, dtype=float)\n            self.vertex_ids = tuple(vertex_ids)\n            self.local_sign = int(local_sign)\n            self.rho = float(rho)\n            self.u = np.array(u, dtype=float)\n            self.face_type = face_type\n            \n            self.canonical_id = tuple(sorted(self.vertex_ids))\n            \n            self.area = 0.0\n            self.n_hat_ordered = np.zeros(3)\n            self.n_local = np.zeros(3)\n            self.F = np.zeros(3)\n            self.F_mag = 0.0\n            \n            self._compute_geometry()\n            self._compute_flux()\n\n        def _compute_geometry(self):\n            \"\"\"Computes face area and normal vectors.\"\"\"\n            x0, x1, x2 = self.vertices\n            v1 = x1 - x0\n            v2 = x2 - x0\n            cross_prod = np.cross(v1, v2)\n            norm_cross_prod = np.linalg.norm(cross_prod)\n            \n            if norm_cross_prod > 1e-12:\n                self.area = 0.5 * norm_cross_prod\n                self.n_hat_ordered = cross_prod / norm_cross_prod\n            \n            self.n_local = self.local_sign * self.n_hat_ordered\n\n        def _compute_flux(self):\n            \"\"\"Computes the momentum flux vector and its magnitude.\"\"\"\n            if self.area > 1e-12:\n                m_dot = self.rho * np.dot(self.u, self.n_local) * self.area\n                self.F = m_dot * self.u\n                self.F_mag = np.linalg.norm(self.F)\n\n    test_cases = [\n        # Scenario 1 Data\n        [\n            (0, [(0,0,0), (1,0,0), (0,1,0)], (0,1,2), 1, 1.0, (0,0,2), 'internal'),\n            (1, [(0,0,0), (1,0,0), (0,1,0)], (0,1,2), -1, 1.0, (0,0,2), 'internal'),\n            (0, [(0,0,1), (1,0,1), (0,1,1)], (3,4,5), 1, 1.0, (0,0,2), 'external'),\n            (1, [(0,0,2), (1,0,2), (0,1,2)], (6,7,8), 1, 1.0, (0,0,2), 'external'),\n        ],\n        # Scenario 2 Data\n        [\n            (0, [(0,0,0), (1,0,0), (0,1,0)], (0,1,2), 1, 1.0, (2,0,0), 'internal'),\n            (1, [(0,0,0), (1,0,0), (0,1,0)], (0,1,2), -1, 1.0, (2,0,0), 'internal'),\n            (0, [(0,0,0), (0,1,0), (0,0,1)], (10,11,12), 1, 1.0, (2,0,0), 'external'),\n            (1, [(0,0,0), (0,1,0), (0,0,1)], (13,14,15), 1, 1.0, (2,0,0), 'external'),\n        ],\n        # Scenario 3 Data\n        [\n            (0, [(0,0,0), (0,0,1), (1,0,0)], (20,21,22), 1, 1.0, (0,3,0), 'internal'),\n            (1, [(0,0,0), (0,0,1), (1,0,0)], (20,21,22), -1, 1.0, (0,3,0), 'internal'),\n            (1, [(0,0,0), (0,1,0), (0,0,1)], (23,24,25), 1, 1.0, (4,0,0), 'internal'),\n            (2, [(0,0,0), (0,1,0), (0,0,1)], (23,24,25), -1, 1.0, (4,0,0), 'internal'),\n            (0, [(0,0,0), (1,0,0), (0,1,0)], (30,31,32), 1, 1.0, (0,0,2), 'external'),\n            (1, [(0,0,1), (1,0,1), (0,1,1)], (33,34,35), 1, 1.0, (0,0,1), 'external'),\n            (2, [(0,0,0), (0,1,0), (0,0,1)], (36,37,38), 1, 1.0, (2,0,0), 'external'),\n        ]\n    ]\n\n    results = []\n    for scenario_data in test_cases:\n        all_faces = [Face(*params) for params in scenario_data]\n\n        # --- Pre-algorithm calculations ---\n        num_internal_instances = sum(1 for face in all_faces if face.face_type == 'internal')\n        double_counted_before = num_internal_instances // 2\n        naive_total_flux_N = sum(face.F_mag for face in all_faces)\n        correct_total_flux_N = sum(face.F_mag for face in all_faces if face.face_type == 'external')\n        error_N = abs(naive_total_flux_N - correct_total_flux_N)\n\n        # --- Post-algorithm calculations ---\n        double_counted_after = 0\n        corrected_total_flux_N = sum(face.F_mag for face in all_faces if face.face_type == 'external')\n        corrected_error_N = abs(corrected_total_flux_N - correct_total_flux_N)\n\n        scenario_result = [\n            double_counted_before,\n            round(naive_total_flux_N, 6),\n            round(correct_total_flux_N, 6),\n            round(error_N, 6),\n            double_counted_after,\n            round(corrected_total_flux_N, 6),\n            round(corrected_error_N, 6)\n        ]\n        results.append(scenario_result)\n\n    # Final print statement in the exact required format.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "answer": "$$\\boxed{[[1,8.000000,4.000000,4.000000,0,4.000000,0.000000],[1,4.000000,4.000000,0.000000,0,4.000000,0.000000],[2,29.500000,4.500000,25.000000,0,4.500000,0.000000]]}$$", "id": "3297310"}]}