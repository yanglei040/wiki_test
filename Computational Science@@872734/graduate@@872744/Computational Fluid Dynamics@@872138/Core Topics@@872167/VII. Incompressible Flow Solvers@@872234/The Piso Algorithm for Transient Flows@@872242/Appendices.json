{"hands_on_practices": [{"introduction": "To truly understand the PISO algorithm, we must begin with its first and most crucial phase: the predictor step. This exercise provides a detailed, hands-on calculation of the tentative velocity for a single control volume by discretizing the momentum equation. By assembling the discrete coefficients yourself, you will gain a concrete understanding of how transient, convective, diffusive, and pressure terms are translated into a solvable algebraic equation [@problem_id:3377777].", "problem": "Consider a one-dimensional transient incompressible flow of a Newtonian fluid in a straight pipe of constant cross-sectional area. You will examine a single finite volume cell adjacent to a prescribed-velocity inlet boundary and carry out the predictor step of the Pressure-Implicit with Splitting of Operators (PISO) algorithm. Start from the one-dimensional momentum balance for the axial velocity field $u(x,t)$ derived from the Navier–Stokes equations,\n$$\n\\rho\\,\\frac{\\partial u}{\\partial t} + \\rho\\,u\\,\\frac{\\partial u}{\\partial x} \\;=\\; -\\,\\frac{\\partial p}{\\partial x} \\;+\\; \\mu\\,\\frac{\\partial^2 u}{\\partial x^2},\n$$\nand use a conservative Finite Volume Method (FVM) discretization over a control volume of width $\\Delta x$ and cross-sectional area $\\mathcal{A}$, with the following modeling choices for the predictor:\n- First-order implicit time discretization for the transient term.\n- First-order upwind discretization for the convective term, linearized using face mass fluxes computed from the known time level $n$.\n- Central differencing for the diffusive term, treated implicitly on the cell $P$ and lagged to time level $n$ for neighbor and boundary contributions in the predictor assembly.\n- The pressure gradient is evaluated at time level $n$ by a two-point difference at the cell center $P$, i.e., $(\\partial p^n/\\partial x)_P \\approx (p_E^n - p_W^n)/\\Delta x$.\n\nLet the control volume (cell $P$) have width $\\Delta x = 0.10\\,\\mathrm{m}$ and cross-sectional area $\\mathcal{A} = 0.010\\,\\mathrm{m}^2$, so that its volume is $V = \\mathcal{A}\\,\\Delta x$. The fluid properties and time step are $\\rho = 1000\\,\\mathrm{kg/m^3}$, $\\mu = 1.0\\times 10^{-3}\\,\\mathrm{Pa\\cdot s}$, and $\\Delta t = 0.010\\,\\mathrm{s}$. The known quantities at time level $n$ are:\n- Cell-center velocity in $P$: $u_P^n = 1.20\\,\\mathrm{m/s}$.\n- Cell-center velocity in the east neighbor $E$: $u_E^n = 1.15\\,\\mathrm{m/s}$.\n- Prescribed inlet (west boundary) velocity: $u_{\\text{inlet}}^n = 1.25\\,\\mathrm{m/s}$.\n- Inlet pressure (at the west boundary face): $p_W^n = 101000\\,\\mathrm{Pa}$.\n- East neighbor cell-center pressure: $p_E^n = 100000\\,\\mathrm{Pa}$.\n\nAssume the flow direction is positive from west to east (consistent with the given velocities at time level $n$), so that the upwind value at the east face is the cell-center value $u_P^n$, while the west face is the inlet boundary where the face velocity equals $u_{\\text{inlet}}^n$. Define the face mass fluxes by $F_W = \\rho\\,\\mathcal{A}\\,u_{W,f}^n$ and $F_E = \\rho\\,\\mathcal{A}\\,u_{E,f}^n$, and the diffusive conductances by $D_W = \\mu\\,\\mathcal{A}/\\Delta x$ and $D_E = \\mu\\,\\mathcal{A}/\\Delta x$.\n\nAssemble explicitly the diagonal momentum coefficient $A_u$ and the accumulated non-pressure contribution $\\boldsymbol{H}_u$ for cell $P$ in the PISO predictor equation\n$$\nA_u\\,u_P^{*} \\;=\\; \\boldsymbol{H}_u \\;-\\; V\\left(\\frac{\\partial p^n}{\\partial x}\\right)_P,\n$$\nmaking sure to include appropriate boundary contributions at the inlet. Then compute the tentative velocity $u_P^{*}$ for cell $P$. Express the final tentative velocity in meters per second and round your answer to five significant figures. Use radians only for any angle if any appears (none is expected here).", "solution": "The problem requires the calculation of the tentative velocity, $u_P^{*}$, in a single finite volume cell $P$ using the predictor step of the PISO algorithm for a one-dimensional transient incompressible flow. The starting point is the conservative form of the 1D momentum equation, integrated over the control volume $V = \\mathcal{A}\\Delta x$.\n\nThe governing equation in conservative form is:\n$$\n\\frac{\\partial (\\rho u)}{\\partial t} + \\frac{\\partial (\\rho u^2)}{\\partial x} = -\\frac{\\partial p}{\\partial x} + \\frac{\\partial}{\\partial x}\\left(\\mu \\frac{\\partial u}{\\partial x}\\right)\n$$\nIntegrating this equation over the control volume $V$ for cell $P$ yields:\n$$\n\\int_V \\frac{\\partial (\\rho u)}{\\partial t} dV + \\int_V \\frac{\\partial (\\rho u^2)}{\\partial x} dV = \\int_V \\left( -\\frac{\\partial p}{\\partial x} \\right) dV + \\int_V \\frac{\\partial}{\\partial x}\\left(\\mu \\frac{\\partial u}{\\partial x}\\right) dV\n$$\nApplying the divergence theorem to the spatial derivative terms transforms the volume integrals into surface integrals over the cell faces (west face $w$ and east face $e$):\n$$\nV \\frac{\\partial (\\rho u_P)}{\\partial t} + [(\\rho u^2)\\mathcal{A}]_e - [(\\rho u^2)\\mathcal{A}]_w = -V \\left(\\frac{\\partial p}{\\partial x}\\right)_P + \\left[\\mu\\mathcal{A}\\frac{\\partial u}{\\partial x}\\right]_e - \\left[\\mu\\mathcal{A}\\frac{\\partial u}{\\partial x}\\right]_w\n$$\nWe now discretize each term according to the problem statement to solve for the tentative velocity $u_P^*$.\n\n1.  **Transient Term:** A first-order implicit scheme is used.\n    $$ V \\frac{\\partial (\\rho u_P)}{\\partial t} \\approx V \\rho \\frac{u_P^* - u_P^n}{\\Delta t} = \\frac{\\rho V}{\\Delta t}(u_P^* - u_P^n) $$\n\n2.  **Convective Term:** A first-order upwind scheme is used, with face mass fluxes $F = \\rho u_f \\mathcal{A}$ evaluated at the known time level $n$. The flow is from west to east ($u^n > 0$).\n    *   At the east face ($e$), the upwind cell is $P$. The mass flux is $F_E = \\rho \\mathcal{A} u_{E,f}^n = \\rho \\mathcal{A} u_P^n$. The convected velocity is $u_P^*$. The flux is $F_E u_P^*$.\n    *   At the west face ($w$), which is the inlet, the upwind velocity is the prescribed inlet velocity, $u_{\\text{inlet}}^n$. The mass flux is $F_W = \\rho \\mathcal{A} u_{W,f}^n = \\rho \\mathcal{A} u_{\\text{inlet}}^n$. The convected velocity is $u_{\\text{inlet}}^n$. The flux is $F_W u_{\\text{inlet}}^n$.\n    *   The net convective flux is $[F u]_e - [F u]_w = F_E u_P^* - F_W u_{\\text{inlet}}^n$.\n\n3.  **Diffusive Term:** Central differencing is used. The term is treated implicitly for the cell $P$ contribution ($u_P^*$) and explicitly (lagged at time level $n$) for neighbor and boundary contributions ($u_E^n, u_{\\text{inlet}}^n$).\n    *   The flux at the east face is $\\mu\\mathcal{A}\\frac{u_E - u_P}{\\Delta x} = D_E(u_E - u_P)$. Applying the time-level rule, this becomes $D_E(u_E^n - u_P^*)$.\n    *   The flux at the west face is $\\mu\\mathcal{A}\\frac{u_P - u_{\\text{inlet}}}{\\Delta x} = D_W(u_P - u_{\\text{inlet}})$. Applying the rule, this is $D_W(u_P^* - u_{\\text{inlet}}^n)$.\n    *   The net diffusive contribution is $D_E(u_E^n - u_P^*) - D_W(u_P^* - u_{\\text{inlet}}^n)$.\n\n4.  **Pressure Gradient Term:** This term is evaluated explicitly at time level $n$ using the given formula:\n    $$ -V \\left(\\frac{\\partial p^n}{\\partial x}\\right)_P = -V \\frac{p_E^n - p_W^n}{\\Delta x} $$\n\nAssembling all discretized terms into a single equation:\n$$\n\\frac{\\rho V}{\\Delta t}(u_P^* - u_P^n) + (F_E u_P^* - F_W u_{\\text{inlet}}^n) = -V \\frac{p_E^n - p_W^n}{\\Delta x} + D_E(u_E^n - u_P^*) - D_W(u_P^* - u_{\\text{inlet}}^n)\n$$\nWe rearrange this equation to group all terms containing $u_P^*$ on the left-hand side (LHS) and all other terms on the right-hand side (RHS).\n$$\n\\frac{\\rho V}{\\Delta t}u_P^* + F_E u_P^* + D_E u_P^* + D_W u_P^* = \\frac{\\rho V}{\\Delta t}u_P^n + F_W u_{\\text{inlet}}^n + D_E u_E^n + D_W u_{\\text{inlet}}^n - V \\frac{p_E^n - p_W^n}{\\Delta x}\n$$\nThis equation matches the specified form $A_u u_P^* = \\boldsymbol{H}_u - V(\\partial p^n / \\partial x)_P$, where:\nThe diagonal momentum coefficient is:\n$$ A_u = \\frac{\\rho V}{\\Delta t} + F_E + D_E + D_W $$\nThe accumulated non-pressure contribution is:\n$$ \\boldsymbol{H}_u = \\frac{\\rho V}{\\Delta t}u_P^n + F_W u_{\\text{inlet}}^n + D_E u_E^n + D_W u_{\\text{inlet}}^n $$\nThe pressure term is:\n$$ -V\\left(\\frac{\\partial p^n}{\\partial x}\\right)_P = -V \\frac{p_E^n - p_W^n}{\\Delta x} $$\n\nNow, we substitute the given numerical values:\n*   $\\rho = 1000\\,\\mathrm{kg/m^3}$\n*   $\\mu = 1.0 \\times 10^{-3}\\,\\mathrm{Pa\\cdot s}$\n*   $\\Delta t = 0.010\\,\\mathrm{s}$\n*   $\\Delta x = 0.10\\,\\mathrm{m}$\n*   $\\mathcal{A} = 0.010\\,\\mathrm{m}^2$\n*   $V = \\mathcal{A}\\Delta x = (0.010\\,\\mathrm{m}^2)(0.10\\,\\mathrm{m}) = 0.0010\\,\\mathrm{m}^3$\n*   $u_P^n = 1.20\\,\\mathrm{m/s}$\n*   $u_E^n = 1.15\\,\\mathrm{m/s}$\n*   $u_{\\text{inlet}}^n = 1.25\\,\\mathrm{m/s}$\n*   $p_W^n = 101000\\,\\mathrm{Pa}$\n*   $p_E^n = 100000\\,\\mathrm{Pa}$\n\nFirst, we calculate the intermediate coefficients:\n*   Transient coefficient: $\\frac{\\rho V}{\\Delta t} = \\frac{1000 \\times 0.0010}{0.010} = 100\\,\\mathrm{kg/s}$\n*   Mass flux $F_W = \\rho\\mathcal{A}u_{\\text{inlet}}^n = 1000 \\times 0.010 \\times 1.25 = 12.5\\,\\mathrm{kg/s}$\n*   Mass flux $F_E = \\rho\\mathcal{A}u_P^n = 1000 \\times 0.010 \\times 1.20 = 12.0\\,\\mathrm{kg/s}$\n*   Diffusive conductance $D_W = D_E = \\frac{\\mu\\mathcal{A}}{\\Delta x} = \\frac{1.0\\times 10^{-3} \\times 0.010}{0.10} = 1.0 \\times 10^{-4}\\,\\mathrm{kg/s}$\n\nNext, we assemble $A_u$ and $\\boldsymbol{H}_u$:\n*   $A_u = 100 + 12.0 + 1.0 \\times 10^{-4} + 1.0 \\times 10^{-4} = 112.0002\\,\\mathrm{kg/s}$\n*   $\\boldsymbol{H}_u = (\\frac{\\rho V}{\\Delta t})u_P^n + F_W u_{\\text{inlet}}^n + D_E u_E^n + D_W u_{\\text{inlet}}^n$\n    $\\boldsymbol{H}_u = (100 \\times 1.20) + (12.5 \\times 1.25) + (1.0 \\times 10^{-4} \\times 1.15) + (1.0 \\times 10^{-4} \\times 1.25)$\n    $\\boldsymbol{H}_u = 120 + 15.625 + 0.000115 + 0.000125 = 135.62524\\,\\mathrm{N}$\n\nThen, we calculate the pressure source term:\n*   $-V\\left(\\frac{\\partial p^n}{\\partial x}\\right)_P = -0.0010 \\times \\frac{100000 - 101000}{0.10} = -0.0010 \\times \\frac{-1000}{0.10} = -0.0010 \\times (-10000) = 10\\,\\mathrm{N}$\n\nFinally, we solve for $u_P^*$:\n$$ A_u u_P^* = \\boldsymbol{H}_u - V\\left(\\frac{\\partial p^n}{\\partial x}\\right)_P $$\n$$ 112.0002 \\times u_P^* = 135.62524 + 10 = 145.62524 $$\n$$ u_P^* = \\frac{145.62524}{112.0002} \\approx 1.300223388\\,\\mathrm{m/s} $$\nRounding the result to five significant figures gives $u_P^* = 1.3002\\,\\mathrm{m/s}$.", "answer": "$$\\boxed{1.3002}$$", "id": "3377777"}, {"introduction": "While the predictor step provides a provisional velocity, its accuracy on collocated grids depends on carefully handling the coupling between pressure and velocity. This practice tackles the classic problem of pressure oscillations by demonstrating the application of Rhie-Chow interpolation. You will compare the mass flux computed with this essential stabilization technique against a simple linear interpolation, revealing its critical role in modern finite volume methods [@problem_id:3377782].", "problem": "Consider a one-dimensional, collocated finite volume discretization of the incompressible Navier–Stokes equations for a transient flow solved by the Pressure-Implicit with Splitting of Operators (PISO) algorithm. Two adjacent control volumes, labeled $P$ and $N$, share a common interior face whose area is $A = 1.0 \\times 10^{-2} \\ \\mathrm{m}^2$. The grid is uniform with cell-center spacing $\\Delta x = 2.0 \\times 10^{-2} \\ \\mathrm{m}$, and each cell has volume $V = A \\, \\Delta x$. The fluid density is constant, $\\rho = 1.2 \\ \\mathrm{kg} \\, \\mathrm{m}^{-3}$. During a corrector step, the cell-centered pressures are $p_P = 1.020 \\times 10^{5} \\ \\mathrm{Pa}$ and $p_N = 1.010 \\times 10^{5} \\ \\mathrm{Pa}$. The diagonal (implicit) momentum coefficients are $a_P(P) = 5.0 \\ \\mathrm{kg} \\, \\mathrm{s}^{-1}$ and $a_P(N) = 7.5 \\ \\mathrm{kg} \\, \\mathrm{s}^{-1}$. The predictor step yields provisional velocities $\\hat{u}_P = 5.0 \\times 10^{-1} \\ \\mathrm{m} \\, \\mathrm{s}^{-1}$ and $\\hat{u}_N = 3.0 \\times 10^{-1} \\ \\mathrm{m} \\, \\mathrm{s}^{-1}$ aligned with the line connecting $P$ to $N$.\n\nStarting from the finite volume momentum balance and the definition of the PISO predictor, derive the Rhie–Chow face velocity that is consistent with a linearly varying pressure field on a collocated grid and use it to compute the face mass flux at the common face. Also compute the face mass flux obtained by linearly interpolating the pressure-corrected cell-centered velocities without Rhie–Chow interpolation. Define the pressure gradient at the cells using the uniform-grid, one-dimensional consistent approximation $(\\partial p/\\partial x)_P = (\\partial p/\\partial x)_N = (p_N - p_P)/\\Delta x$, and define $d_P = V/a_P(P)$, $d_N = V/a_P(N)$, and the face interpolation $d_f = \\tfrac{1}{2}(d_P + d_N)$.\n\nLet $\\phi_{\\mathrm{RC}}$ denote the Rhie–Chow face mass flux and $\\phi_{\\mathrm{LI}}$ denote the face mass flux from linear interpolation of the pressure-corrected cell velocities without Rhie–Chow. Compute the difference $\\Delta \\phi = \\phi_{\\mathrm{RC}} - \\phi_{\\mathrm{LI}}$. Express your final answer in $\\mathrm{kg} \\, \\mathrm{s}^{-1}$ and round your final answer to four significant figures.", "solution": "The user wants to compute the difference between two methods of calculating the face mass flux in a one-dimensional finite volume simulation using the PISO algorithm. The first method uses the Rhie–Chow interpolation ($\\phi_{\\mathrm{RC}}$), and the second method uses linear interpolation of pressure-corrected cell-centered velocities ($\\phi_{\\mathrm{LI}}$).\n\nFirst, we establish the relationship between the predictor-step provisional velocity, $\\hat{u}$, and the corrector-step final velocity, $u$. In the PISO algorithm, the final velocity at a cell center $i$ is obtained by correcting the provisional velocity with a term related to the new pressure gradient:\n$$u_i = \\hat{u}_i - d_i \\left(\\frac{\\partial p}{\\partial x}\\right)_i$$\nwhere $d_i = V/a_P(i)$, with $V$ being the cell volume and $a_P(i)$ the diagonal momentum coefficient for cell $i$. The problem provides a specific definition for the cell-centered pressure gradients for cells $P$ and $N$:\n$$\\left(\\frac{\\partial p}{\\partial x}\\right)_P = \\left(\\frac{\\partial p}{\\partial x}\\right)_N = \\frac{p_N - p_P}{\\Delta x}$$\nThis specified gradient, which we denote as $\\nabla p_{\\text{spec}}$, is central to the calculation.\n\n### Calculation of the Linearly Interpolated Face Mass Flux, $\\phi_{\\mathrm{LI}}$\nThis method first calculates the pressure-corrected velocities at the cell centers, $u_P^{\\text{corr}}$ and $u_N^{\\text{corr}}$, and then linearly interpolates them to the face.\n\nUsing the relationship above and the specified pressure gradient:\n$$u_P^{\\text{corr}} = \\hat{u}_P - d_P \\left(\\frac{p_N - p_P}{\\Delta x}\\right)$$\n$$u_N^{\\text{corr}} = \\hat{u}_N - d_N \\left(\\frac{p_N - p_P}{\\Delta x}\\right)$$\nwhere $d_P = V/a_P(P)$ and $d_N = V/a_P(N)$.\n\nThe face velocity, $u_{f, \\mathrm{LI}}$, is the average of these corrected velocities:\n$$u_{f, \\mathrm{LI}} = \\frac{1}{2} (u_P^{\\text{corr}} + u_N^{\\text{corr}}) = \\frac{1}{2} \\left[ \\left(\\hat{u}_P - d_P \\frac{p_N - p_P}{\\Delta x}\\right) + \\left(\\hat{u}_N - d_N \\frac{p_N - p_P}{\\Delta x}\\right) \\right]$$\n$$u_{f, \\mathrm{LI}} = \\frac{1}{2}(\\hat{u}_P + \\hat{u}_N) - \\frac{1}{2}(d_P + d_N) \\left(\\frac{p_N - p_P}{\\Delta x}\\right)$$\nUsing the definition $d_f = \\frac{1}{2}(d_P + d_N)$, this simplifies to:\n$$u_{f, \\mathrm{LI}} = \\overline{\\hat{u}}_f - d_f \\left(\\frac{p_N - p_P}{\\Delta x}\\right)$$\nwhere $\\overline{\\hat{u}}_f = \\frac{1}{2}(\\hat{u}_P + \\hat{u}_N)$. The corresponding mass flux is $\\phi_{\\mathrm{LI}} = \\rho A u_{f, \\mathrm{LI}}$.\n\n### Calculation of the Rhie–Chow Face Mass Flux, $\\phi_{\\mathrm{RC}}$\nThe Rhie–Chow interpolation for the face velocity, $u_{f, \\mathrm{RC}}$, is designed to suppress pressure oscillations on collocated grids. Its general form is:\n$$u_{f, \\mathrm{RC}} = \\overline{\\hat{u}}_f - d_f \\left[ \\left(\\frac{\\partial p}{\\partial x}\\right)_f - \\overline{\\left(\\frac{\\partial p}{\\partial x}\\right)}_{\\text{cell}} \\right]$$\nHere, $(\\frac{\\partial p}{\\partial x})_f$ is the pressure gradient at the face, and $\\overline{(\\frac{\\partial p}{\\partial x})}_{\\text{cell}}$ is the interpolated cell-centered pressure gradient.\nFor a uniform grid, the face pressure gradient is consistently approximated as:\n$$\\left(\\frac{\\partial p}{\\partial x}\\right)_f = \\frac{p_N - p_P}{\\Delta x}$$\nThe interpolated cell-centered pressure gradient is:\n$$\\overline{\\left(\\frac{\\partial p}{\\partial x}\\right)}_{\\text{cell}} = \\frac{1}{2} \\left[ \\left(\\frac{\\partial p}{\\partial x}\\right)_P + \\left(\\frac{\\partial p}{\\partial x}\\right)_N \\right]$$\nNow, we apply the specific definition for the cell-centered gradients given in the problem:\n$$\\overline{\\left(\\frac{\\partial p}{\\partial x}\\right)}_{\\text{cell}} = \\frac{1}{2} \\left[ \\left(\\frac{p_N - p_P}{\\Delta x}\\right) + \\left(\\frac{p_N - p_P}{\\Delta x}\\right) \\right] = \\frac{p_N - p_P}{\\Delta x}$$\nWe observe that, for this specific problem, $\\overline{(\\frac{\\partial p}{\\partial x})}_{\\text{cell}} = (\\frac{\\partial p}{\\partial x})_f$. Substituting this into the Rhie–Chow formula, the correction term vanishes:\n$$u_{f, \\mathrm{RC}} = \\overline{\\hat{u}}_f - d_f \\left[ \\frac{p_N - p_P}{\\Delta x} - \\frac{p_N - p_P}{\\Delta x} \\right] = \\overline{\\hat{u}}_f - d_f \\cdot 0$$\n$$u_{f, \\mathrm{RC}} = \\overline{\\hat{u}}_f = \\frac{1}{2}(\\hat{u}_P + \\hat{u}_N)$$\nThe corresponding mass flux is $\\phi_{\\mathrm{RC}} = \\rho A u_{f, \\mathrm{RC}}$.\n\n### Calculation of the Difference, $\\Delta \\phi$\nThe difference between the two mass fluxes is $\\Delta \\phi = \\phi_{\\mathrm{RC}} - \\phi_{\\mathrm{LI}}$.\n$$\\Delta \\phi = \\rho A u_{f, \\mathrm{RC}} - \\rho A u_{f, \\mathrm{LI}}$$\n$$\\Delta \\phi = \\rho A \\left( \\overline{\\hat{u}}_f \\right) - \\rho A \\left( \\overline{\\hat{u}}_f - d_f \\frac{p_N - p_P}{\\Delta x} \\right)$$\n$$\\Delta \\phi = \\rho A d_f \\left( \\frac{p_N - p_P}{\\Delta x} \\right)$$\nNow, we substitute the expressions for $d_f$ and $V$:\n$$d_f = \\frac{1}{2}(d_P + d_N) = \\frac{1}{2} \\left( \\frac{V}{a_P(P)} + \\frac{V}{a_P(N)} \\right) = \\frac{V}{2} \\left( \\frac{1}{a_P(P)} + \\frac{1}{a_P(N)} \\right)$$\nWith $V = A \\Delta x$:\n$$\\Delta \\phi = \\rho A \\left[ \\frac{A \\Delta x}{2} \\left( \\frac{1}{a_P(P)} + \\frac{1}{a_P(N)} \\right) \\right] \\left( \\frac{p_N - p_P}{\\Delta x} \\right)$$\nThe grid spacing $\\Delta x$ cancels out, yielding the final analytical expression:\n$$\\Delta \\phi = \\frac{\\rho A^2}{2} (p_N - p_P) \\left( \\frac{1}{a_P(P)} + \\frac{1}{a_P(N)} \\right)$$\n\n### Numerical Computation\nWe substitute the given values into this expression:\n- $\\rho = 1.2 \\ \\mathrm{kg} \\, \\mathrm{m}^{-3}$\n- $A = 1.0 \\times 10^{-2} \\ \\mathrm{m}^2$\n- $p_P = 1.020 \\times 10^{5} \\ \\mathrm{Pa}$\n- $p_N = 1.010 \\times 10^{5} \\ \\mathrm{Pa}$\n- $a_P(P) = 5.0 \\ \\mathrm{kg} \\, \\mathrm{s}^{-1}$\n- $a_P(N) = 7.5 \\ \\mathrm{kg} \\, \\mathrm{s}^{-1}$\n\nFirst, we calculate the terms in the expression:\n$$p_N - p_P = (1.010 \\times 10^{5}) - (1.020 \\times 10^{5}) = -1000 \\ \\mathrm{Pa}$$\n$$\\frac{1}{a_P(P)} + \\frac{1}{a_P(N)} = \\frac{1}{5.0} + \\frac{1}{7.5} = 0.2 + \\frac{2}{15} = \\frac{3}{15} + \\frac{2}{15} = \\frac{5}{15} = \\frac{1}{3} \\ \\mathrm{s} \\, \\mathrm{kg}^{-1}$$\nNow, we compute $\\Delta \\phi$:\n$$\\Delta \\phi = \\frac{(1.2) \\cdot (1.0 \\times 10^{-2})^2}{2} (-1000) \\left( \\frac{1}{3} \\right)$$\n$$\\Delta \\phi = \\frac{1.2 \\times 1.0 \\times 10^{-4}}{2} (-1000) \\left( \\frac{1}{3} \\right)$$\n$$\\Delta \\phi = (0.6 \\times 10^{-4}) (-1000) \\left( \\frac{1}{3} \\right)$$\n$$\\Delta \\phi = (-0.6 \\times 10^{-1}) \\left( \\frac{1}{3} \\right) = -0.2 \\times 10^{-1} = -0.02 \\ \\mathrm{kg} \\, \\mathrm{s}^{-1}$$\nIn scientific notation and rounded to four significant figures, the final result is $-2.000 \\times 10^{-2} \\ \\mathrm{kg} \\, \\mathrm{s}^{-1}$.", "answer": "$$\\boxed{-2.000 \\times 10^{-2}}$$", "id": "3377782"}, {"introduction": "After mastering the individual components, the final step is to verify the behavior of the complete PISO algorithm. This advanced practice guides you through the Method of Manufactured Solutions (MMS), a rigorous technique for code verification. By implementing a PISO solver for a known analytical solution, you will empirically determine the number of corrector steps needed to achieve the designed temporal accuracy, a crucial skill for developing and validating robust CFD codes [@problem_id:3377833].", "problem": "Implement a Pressure-Implicit with Splitting of Operators (PISO) algorithm for transient incompressible flow and use the Method of Manufactured Solutions (MMS) to empirically determine the minimum number of pressure-correction loops, denoted by $N_c$, required to achieve second-order accuracy in time for both the velocity and the discrete divergence. Work in a two-dimensional periodic domain with dimensionless variables to isolate temporal accuracy.\n\nFundamental base and governing equations:\n- Start from the incompressible Navier–Stokes equations for velocity $u(x,y,t) = (u_1,u_2)$ and pressure $p(x,y,t)$ in a periodic square domain $[0,1]\\times[0,1]$:\n$$\n\\frac{\\partial u}{\\partial t} + (u\\cdot \\nabla)u = -\\nabla p + \\nu \\nabla^2 u + f(x,y,t), \\quad \\nabla\\cdot u = 0,\n$$\nwhere $\\nu$ is the kinematic viscosity and $f(x,y,t)$ is an external body force.\n- Use the Method of Manufactured Solutions: prescribe smooth, periodic fields $u(x,y,t)$ and $p(x,y,t)$, compute $f(x,y,t)$ so that the pair satisfies the above equations exactly for any $(x,y,t)$.\n\nManufactured transient vortex:\n- Let $m$ be a positive integer wave number and $\\omega$ be a positive frequency. Define the manufactured fields\n$$\nu_1(x,y,t) = \\sin(2\\pi m x)\\cos(2\\pi m y)\\cos(\\omega t), \\quad\nu_2(x,y,t) = -\\cos(2\\pi m x)\\sin(2\\pi m y)\\cos(\\omega t),\n$$\n$$\np(x,y,t) = \\cos(2\\pi m x)\\cos(2\\pi m y)\\sin(\\omega t).\n$$\n- These satisfy $\\nabla\\cdot u = 0$ analytically for all $t$.\n- Compute the body force $f(x,y,t)$ from the governing equations using the manufactured $u$ and $p$:\n$$\nf(x,y,t) = \\frac{\\partial u}{\\partial t} + (u\\cdot \\nabla)u + \\nabla p - \\nu \\nabla^2 u.\n$$\n\nNumerical algorithm requirements:\n- Use a uniform Cartesian grid with $N_x = N_y$ points and periodic boundary conditions in both directions. All computations are dimensionless.\n- Use a semi-implicit time discretization with Crank–Nicolson for diffusion and Adams–Bashforth of order $2$ for the explicit terms. Specifically, let $\\Delta t$ be the time step and define at time level $n$ the explicit term\n$$\n\\mathcal{E}^n = - (u^n \\cdot \\nabla) u^n + f(\\cdot,\\cdot,t^n).\n$$\nThen advance from $t^n$ to $t^{n+1} = t^n + \\Delta t$ by:\n1. Predictor (momentum) step:\n   solve for the intermediate velocity $u^\\star$ from\n   $$\n   \\left(I - \\frac{\\Delta t}{2}\\nu \\nabla^2\\right) u^\\star =\n   \\left(I + \\frac{\\Delta t}{2}\\nu \\nabla^2\\right) u^n + \\Delta t\\left(\\frac{3}{2}\\mathcal{E}^n - \\frac{1}{2}\\mathcal{E}^{n-1}\\right) - \\Delta t \\nabla p^n.\n   $$\n2. PISO pressure-correction loop with $N_c$ correctors:\n   for $j = 1,\\dots,N_c$ solve the pressure increment $\\phi$ from the pressure Poisson equation\n   $$\n   \\nabla^2 \\phi = \\frac{1}{\\Delta t}\\nabla\\cdot u^\\star,\n   $$\n   then update\n   $$\n   u^\\star \\leftarrow u^\\star - \\Delta t \\nabla \\phi,\\quad p^n \\leftarrow p^n + \\phi.\n   $$\n   After the last corrector, set $u^{n+1} = u^\\star$ and $p^{n+1} = p^n$.\n- Initialize $u^0$ and $p^0$ from the manufactured fields at $t=0$. Initialize $\\mathcal{E}^{-1} = \\mathcal{E}^{0}$ for the first Adams–Bashforth step.\n- For spatial operators (gradient, divergence, Laplacian, and Poisson solves) use spectrally exact differentiation on the periodic grid via Fourier transforms to reduce spatial discretization error far below temporal error for the parameter regimes below.\n\nError metrics and accuracy assessment:\n- For a given case, for a sequence of three time steps $\\Delta t_1, \\Delta t_2, \\Delta t_3$ with $\\Delta t_{k+1} = \\Delta t_k/2$, integrate to a fixed final time $T$ (exact multiple of each $\\Delta t_k$).\n- Compute the velocity error at $t=T$ as the discrete $L^2$ norm\n$$\n\\varepsilon_u(\\Delta t) = \\left( \\frac{1}{N_x N_y} \\sum_{i,j} \\|u_{i,j}^{\\text{num}}(T) - u_{i,j}^{\\text{exact}}(T)\\|^2 \\right)^{1/2}.\n$$\n- Compute the divergence error at $t=T$ as\n$$\n\\varepsilon_{\\nabla\\cdot u}(\\Delta t) = \\left( \\frac{1}{N_x N_y} \\sum_{i,j} \\left(\\nabla\\cdot u^{\\text{num}}(T)\\big|_{i,j}\\right)^2 \\right)^{1/2}.\n$$\n- Estimate empirical convergence orders between consecutive step sizes by\n$$\np_u^{(k)} = \\frac{\\log\\left(\\varepsilon_u(\\Delta t_k)/\\varepsilon_u(\\Delta t_{k+1})\\right)}{\\log\\left(\\Delta t_k/\\Delta t_{k+1}\\right)}, \\quad\np_{\\nabla\\cdot u}^{(k)} = \\frac{\\log\\left(\\varepsilon_{\\nabla\\cdot u}(\\Delta t_k)/\\varepsilon_{\\nabla\\cdot u}(\\Delta t_{k+1})\\right)}{\\log\\left(\\Delta t_k/\\Delta t_{k+1}\\right)},\n$$\nfor $k\\in\\{1,2\\}$.\n- Decision rule: declare that a given $N_c$ achieves second-order accuracy in both velocity and divergence if and only if both $p_u^{(1)}$ and $p_u^{(2)}$ are at least $1.8$, and both $p_{\\nabla\\cdot u}^{(1)}$ and $p_{\\nabla\\cdot u}^{(2)}$ are at least $1.8$. To avoid declaring failure due to machine-precision saturation of the divergence in a projection method, if $\\varepsilon_{\\nabla\\cdot u}(\\Delta t_k) \\le 10^{-10}$ for all three step sizes, then treat the divergence criterion as satisfied for that $N_c$.\n\nTest suite:\n- Use a uniform grid with $N_x = N_y = 48$ points. All quantities are nondimensional.\n- For each test case, use the following parameters and time step sequence:\n   - Case A (happy path): $m=1$, $\\omega=4.0$, $\\nu=0.01$, $T=0.08$, $\\Delta t \\in \\{0.01,\\,0.005,\\,0.0025\\}$.\n   - Case B (higher spatial frequency): $m=2$, $\\omega=6.0$, $\\nu=0.02$, $T=0.08$, $\\Delta t \\in \\{0.01,\\,0.005,\\,0.0025\\}$.\n   - Case C (more advection-dominated): $m=1$, $\\omega=3.0$, $\\nu=0.005$, $T=0.08$, $\\Delta t \\in \\{0.01,\\,0.005,\\,0.0025\\}$.\n\nRequired program behavior and final output:\n- Implement the above PISO algorithm with $N_c \\in \\{1,2,3\\}$, and for each test case determine the smallest $N_c$ that satisfies the second-order accuracy criterion in both velocity and divergence. If no $N_c \\in \\{1,2,3\\}$ satisfies the criterion, return $-1$ for that case.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases A, B, C. For example, a valid output looks like\n\"[$1$,$2$,$1$]\" but without dollar signs in the program output, i.e., the program must print \"[1,2,1]\".", "solution": "The user-provided problem is assessed to be valid. It is scientifically grounded in the principles of computational fluid dynamics, specifically concerning the Pressure-Implicit with Splitting of Operators (PISO) algorithm for the incompressible Navier-Stokes equations. The problem is well-posed, employing the Method of Manufactured Solutions (MMS) for a rigorous, objective verification of the algorithm's temporal accuracy. The definitions, parameters, and criteria are complete and unambiguous. We may therefore proceed with a complete solution.\n\nThe objective is to determine the minimum number of PISO pressure-corrector loops, $N_c$, required to achieve second-order temporal accuracy for a specific numerical scheme. This is accomplished by implementing the scheme and testing it against a manufactured analytical solution.\n\n### Governing Equations and Manufactured Solution\n\nThe simulation solves the dimensionless incompressible Navier-Stokes equations in a two-dimensional periodic domain $[0,1]\\times[0,1]$:\n$$\n\\frac{\\partial \\boldsymbol{u}}{\\partial t} + (\\boldsymbol{u}\\cdot \\nabla)\\boldsymbol{u} = -\\nabla p + \\nu \\nabla^2 \\boldsymbol{u} + \\boldsymbol{f}(x,y,t)\n$$\n$$\n\\nabla\\cdot \\boldsymbol{u} = 0\n$$\nwhere $\\boldsymbol{u}=(u_1, u_2)$ is the velocity field, $p$ is the pressure, $\\nu$ is the kinematic viscosity, and $\\boldsymbol{f}$ is a body force term.\n\nThe Method of Manufactured Solutions (MMS) is used for verification. We prescribe smooth, periodic analytical solutions for velocity and pressure:\n$$\nu_1(x,y,t) = \\sin(2\\pi m x)\\cos(2\\pi m y)\\cos(\\omega t)\n$$\n$$\nu_2(x,y,t) = -\\cos(2\\pi m x)\\sin(2\\pi m y)\\cos(\\omega t)\n$$\n$$\np(x,y,t) = \\cos(2\\pi m x)\\cos(2\\pi m y)\\sin(\\omega t)\n$$\nThe velocity field is analytically divergence-free: $\\nabla \\cdot \\boldsymbol{u} = 0$. The body force $\\boldsymbol{f} = (f_1, f_2)$ is then derived by substituting these manufactured fields into the momentum equation:\n$$\n\\boldsymbol{f} = \\frac{\\partial \\boldsymbol{u}}{\\partial t} + (\\boldsymbol{u}\\cdot \\nabla)\\boldsymbol{u} + \\nabla p - \\nu \\nabla^2 \\boldsymbol{u}\n$$\nThe individual components of $\\boldsymbol{f}$ are calculated as follows:\n$f_1(x,y,t) = -(\\omega+2\\pi m) \\sin(2\\pi m x)\\cos(2\\pi m y)\\sin(\\omega t) + \\pi m \\sin(4\\pi m x) \\cos^2(\\omega t) + 8\\pi^2 m^2 \\nu \\sin(2\\pi m x)\\cos(2\\pi m y)\\cos(\\omega t)$\n$f_2(x,y,t) = (\\omega-2\\pi m) \\cos(2\\pi m x)\\sin(2\\pi m y)\\sin(\\omega t) + \\pi m \\sin(4\\pi m y) \\cos^2(\\omega t) - 8\\pi^2 m^2 \\nu \\cos(2\\pi m x)\\sin(2\\pi m y)\\cos(\\omega t)$\n\n### Numerical Discretization and Algorithm\n\nA uniform Cartesian grid with $N_x = N_y = N$ points is used. The key feature of the method is the use of spectral differentiation via the Fast Fourier Transform (FFT), which provides high accuracy for spatial derivatives, effectively isolating temporal discretization errors.\n\n**Spatial Operators using FFT**\nFor a function $g(x_i, y_j)$ on the grid, its 2D Discrete Fourier Transform is $\\hat{g}(k_x, k_y)$. Spatial derivatives are computed in Fourier space:\n- Gradient: $\\widehat{\\nabla g} = (i 2\\pi k_x \\hat{g}, i 2\\pi k_y \\hat{g})$\n- Divergence: $\\widehat{\\nabla \\cdot \\boldsymbol{u}} = i 2\\pi k_x \\hat{u}_1 + i 2\\pi k_y \\hat{u}_2$\n- Laplacian: $\\widehat{\\nabla^2 g} = -( (2\\pi k_x)^2 + (2\\pi k_y)^2 ) \\hat{g} = -k^2 \\hat{g}$\nwhere $k_x, k_y$ are the discrete wavenumbers. Operations like solving the Poisson equation $\\nabla^2 \\phi = \\rho$ become an algebraic division in Fourier space: $\\hat{\\phi} = -\\hat{\\rho}/k^2$. The $k=0$ mode must be handled specially by ensuring the mean of $\\rho$ is zero and setting $\\hat{\\phi}(0,0)=0$.\n\n**Time-Stepping Scheme**\nA semi-implicit scheme advances the solution from time $t^n$ to $t^{n+1} = t^n + \\Delta t$. The viscous diffusion term is treated implicitly with the second-order Crank-Nicolson method, while explicit terms (convection and body force) are treated with the second-order Adams-Bashforth method.\nThe explicit part at time level $n$ is defined as $\\mathcal{E}^n = - (\\boldsymbol{u}^n \\cdot \\nabla) \\boldsymbol{u}^n + \\boldsymbol{f}(t^n)$.\n\nThe PISO algorithm proceeds in two main stages per time step:\n\n**1. Predictor Step:**\nAn intermediate velocity field $\\boldsymbol{u}^\\star$ is computed by solving the momentum equation, where the pressure term is taken from the previous time step $p^n$.\n$$\n\\left(\\boldsymbol{I} - \\frac{\\Delta t}{2}\\nu \\nabla^2\\right) \\boldsymbol{u}^\\star = \\left(\\boldsymbol{I} + \\frac{\\Delta t}{2}\\nu \\nabla^2\\right) \\boldsymbol{u}^n + \\Delta t\\left(\\frac{3}{2}\\mathcal{E}^n - \\frac{1}{2}\\mathcal{E}^{n-1}\\right) - \\Delta t \\nabla p^n\n$$\nThis is a set of Helmholtz equations for the components of $\\boldsymbol{u}^\\star$, solved efficiently in Fourier space:\n$$\n\\hat{\\boldsymbol{u}}^\\star = \\frac{\\widehat{\\text{RHS}}}{1 + \\frac{\\Delta t}{2}\\nu k^2}\n$$\n\n**2. Corrector Steps:**\nThe predicted velocity $\\boldsymbol{u}^\\star$ does not satisfy the divergence-free constraint for time $t^{n+1}$. The PISO algorithm applies $N_c$ correction steps to enforce this constraint while updating the pressure. For each corrector step $j=1, \\dots, N_c$:\na. Solve a pressure Poisson equation for a pressure increment $\\phi$:\n$$\n\\nabla^2 \\phi = \\frac{1}{\\Delta t} \\nabla \\cdot \\boldsymbol{u}^\\star\n$$\nwhere $\\boldsymbol{u}^\\star$ is the most recently updated velocity field. This is solved spectrally.\nb. Update the velocity and pressure fields using the correction $\\phi$:\n$$\n\\boldsymbol{u}^\\star \\leftarrow \\boldsymbol{u}^\\star - \\Delta t \\nabla \\phi\n$$\n$$\np \\leftarrow p + \\phi\n$$\n(Here, $p$ is a temporary variable initialized to $p^n$ at the start of the timestep).\n\nAfter the $N_c$ loops, the final corrected fields are assigned to the new time level: $\\boldsymbol{u}^{n+1} = \\boldsymbol{u}^\\star$ and $p^{n+1} = p$.\n\n### Verification and Accuracy Assessment\n\nTo assess temporal accuracy, the simulation is run for a sequence of three successively halved time steps, $\\Delta t_1, \\Delta t_2=\\Delta t_1/2, \\Delta t_3=\\Delta t_2/2$, to a fixed final time $T$. The errors are computed at $T$ using discrete $L^2$ norms:\n- Velocity error: $\\varepsilon_u(\\Delta t) = \\| \\boldsymbol{u}^{\\text{num}}(T) - \\boldsymbol{u}^{\\text{exact}}(T) \\|_{L^2}$\n- Divergence error: $\\varepsilon_{\\nabla\\cdot u}(\\Delta t) = \\| \\nabla\\cdot \\boldsymbol{u}^{\\text{num}}(T) \\|_{L^2}$\n\nThe empirical order of convergence $p$ is then estimated from pairs of simulations:\n$$\np^{(k)} = \\frac{\\log(\\varepsilon(\\Delta t_k)/\\varepsilon(\\Delta t_{k+1}))}{\\log(2)}\n$$\nA value of $N_c$ is deemed sufficient for second-order accuracy if the observed orders for both velocity and divergence are at least $1.8$. A special condition handles cases where the a divergence error reaches machine precision ($\\le 10^{-10}$), in which case the divergence accuracy criterion is automatically satisfied. For each test case, the smallest $N_c \\in \\{1, 2, 3\\}$ meeting this requirement is identified.\n\n### Implementation Strategy\n\nThe solution is implemented in Python using a class-based structure.\n- `SpectralOps`: A helper class to manage grid information and provide methods for all spectral differential operations (`grad`, `div`, `lap`, `solve_poisson`, `solve_helmholtz`).\n- `ManufacturedSolution`: A class to compute the exact fields $\\boldsymbol{u}$, $p$, and the forcing term $\\boldsymbol{f}$ at any point in space-time.\n- `PISOSolver`: The main class encapsulating the PISO algorithm logic. It holds the simulation state, parameters, calls the `SpectralOps` and `ManufacturedSolution` helpers, and executes the time-stepping loop.\n- `solve_case` and `solve`: Functions to orchestrate the numerical experiment, iterating through test cases, values of $N_c$, and time step refinements, ultimately calculating the required convergence orders and determining the final result for each case.\n\nThis structure modularizes the complex components of the problem, leading to a clear, maintainable, and verifiable implementation.", "answer": "```python\nimport numpy as np\nfrom numpy.fft import fft2, ifft2, fftfreq\n\nclass SpectralOps:\n    \"\"\"\n    Handles spectral operations on a 2D periodic grid.\n    \"\"\"\n    def __init__(self, N):\n        if N % 2 != 0:\n            raise ValueError(\"Grid size N must be even for this wavenumber setup.\")\n        self.N = N\n        # Wavenumbers (multiplied by 2*pi for convenience in derivative formulas)\n        k_freq = fftfreq(N, 1.0 / N)\n        self.kx_2pi = (2 * np.pi * k_freq)[:, np.newaxis]\n        self.ky_2pi = (2 * np.pi * k_freq)[np.newaxis, :]\n        \n        # Wavenumber squared\n        self.k_sq = self.kx_2pi**2 + self.ky_2pi**2\n        \n        # Inverse Laplacian operator (precomputed for Poisson solves)\n        self.k_sq_inv = np.zeros_like(self.k_sq)\n        non_zero_k = self.k_sq > 1e-12\n        self.k_sq_inv[non_zero_k] = 1.0 / self.k_sq[non_zero_k]\n\n    def grad(self, f):\n        \"\"\"Computes gradient of a scalar field f.\"\"\"\n        f_hat = fft2(f)\n        dfdx = np.real(ifft2(1j * self.kx_2pi * f_hat))\n        dfdy = np.real(ifft2(1j * self.ky_2pi * f_hat))\n        return dfdx, dfdy\n\n    def div(self, u):\n        \"\"\"Computes divergence of a vector field u = (u1, u2).\"\"\"\n        u1_hat = fft2(u[0])\n        u2_hat = fft2(u[1])\n        div_u_hat = 1j * self.kx_2pi * u1_hat + 1j * self.ky_2pi * u2_hat\n        return np.real(ifft2(div_u_hat))\n\n    def laplacian(self, f):\n        \"\"\"Computes Laplacian of a scalar field f.\"\"\"\n        f_hat = fft2(f)\n        lap_f_hat = -self.k_sq * f_hat\n        return np.real(ifft2(lap_f_hat))\n\n    def solve_poisson(self, rhs):\n        \"\"\"Solves Poisson equation: lap(phi) = rhs.\"\"\"\n        rhs_hat = fft2(rhs)\n        rhs_hat[0, 0] = 0.0  # Ensure compatibility condition (zero mean)\n        phi_hat = -self.k_sq_inv * rhs_hat\n        return np.real(ifft2(phi_hat))\n\n    def solve_helmholtz(self, rhs, alpha):\n        \"\"\"Solves Helmholtz equation: (I - alpha*lap) u = rhs.\"\"\"\n        rhs_hat = fft2(rhs)\n        helmholtz_op_hat = 1.0 + alpha * self.k_sq\n        u_hat = rhs_hat / helmholtz_op_hat\n        return np.real(ifft2(u_hat))\n\nclass ManufacturedSolution:\n    \"\"\"\n    Provides the exact manufactured solution and derived forcing term.\n    \"\"\"\n    def __init__(self, m, omega, nu, grid_x, grid_y):\n        self.m, self.omega, self.nu = m, omega, nu\n        self.xx, self.yy = np.meshgrid(grid_x, grid_y, indexing='ij')\n\n    def get_solution(self, t):\n        \"\"\"Returns exact u and p at time t.\"\"\"\n        k = 2 * np.pi * self.m\n        cos_wt = np.cos(self.omega * t)\n        sin_wt = np.sin(self.omega * t)\n        \n        sx, cx = np.sin(k * self.xx), np.cos(k * self.xx)\n        sy, cy = np.sin(k * self.yy), np.cos(k * self.yy)\n        \n        u1 = sx * cy * cos_wt\n        u2 = -cx * sy * cos_wt\n        p = cx * cy * sin_wt\n        return (u1, u2), p\n\n    def get_forcing(self, t):\n        \"\"\"Returns the source term f at time t.\"\"\"\n        m, omega, nu = self.m, self.omega, self.nu\n        k = 2 * np.pi * m\n        cos_wt = np.cos(omega * t)\n        sin_wt = np.sin(omega * t)\n        \n        sx, cx = np.sin(k * self.xx), np.cos(k * self.xx)\n        sy, cy = np.sin(k * self.yy), np.cos(k * self.yy)\n        \n        f1 = (-(omega + k) * sx * cy * sin_wt +\n              (np.pi * m * np.sin(2 * k * self.xx) * cos_wt**2) +\n              (2 * k**2 * nu * sx * cy * cos_wt))\n\n        f2 = ((omega - k) * cx * sy * sin_wt +\n              (np.pi * m * np.sin(2 * k * self.yy) * cos_wt**2) -\n              (2 * k**2 * nu * cx * sy * cos_wt))\n        \n        return (f1, f2)\n\nclass PISOSolver:\n    \"\"\"\n    Implements the PISO solver for the numerical experiment.\n    \"\"\"\n    def __init__(self, case_params, N, Nc, dt):\n        self.params = case_params\n        self.N, self.Nc, self.dt = N, Nc, dt\n        self.T = case_params['T']\n        \n        grid_pts = np.linspace(0, 1, N, endpoint=False)\n        self.ops = SpectralOps(N)\n        self.mms = ManufacturedSolution(case_params['m'], case_params['omega'], \n                                        case_params['nu'], grid_pts, grid_pts)\n\n    def _compute_E(self, u, t):\n        \"\"\"Computes the explicit term E.\"\"\"\n        u1, u2 = u\n        \n        u1_dx, u1_dy = self.ops.grad(u1)\n        u2_dx, u2_dy = self.ops.grad(u2)\n        \n        conv1 = u1 * u1_dx + u2 * u1_dy\n        conv2 = u1 * u2_dx + u2 * u2_dy\n        \n        f1, f2 = self.mms.get_forcing(t)\n        \n        E1 = -conv1 + f1\n        E2 = -conv2 + f2\n        return (E1, E2)\n\n    def run(self):\n        \"\"\"Runs the simulation until final time T.\"\"\"\n        u, p = self.mms.get_solution(0)\n        \n        E_n = self._compute_E(u, 0)\n        E_nm1 = E_n # Initialize for first step (AB2 -> FE)\n\n        num_steps = int(round(self.T / self.dt))\n        for n in range(num_steps):\n            t_n = n * self.dt\n            t_np1 = (n + 1) * self.dt\n            nu, dt = self.params['nu'], self.dt\n            \n            # Predictor step\n            # RHS of the Helmholtz equation\n            lap_u_n = (self.ops.laplacian(u[0]), self.ops.laplacian(u[1]))\n            grad_p_n = self.ops.grad(p)\n            \n            rhs1 = (u[0] + (dt / 2) * nu * lap_u_n[0] +\n                    dt * (1.5 * E_n[0] - 0.5 * E_nm1[0]) - dt * grad_p_n[0])\n            rhs2 = (u[1] + (dt / 2) * nu * lap_u_n[1] +\n                    dt * (1.5 * E_n[1] - 0.5 * E_nm1[1]) - dt * grad_p_n[1])\n            \n            u_star1 = self.ops.solve_helmholtz(rhs1, dt / 2 * nu)\n            u_star2 = self.ops.solve_helmholtz(rhs2, dt / 2 * nu)\n            u_star = (u_star1, u_star2)\n            \n            # PISO corrector loop\n            p_corr = np.copy(p)\n            for _ in range(self.Nc):\n                div_u_star = self.ops.div(u_star)\n                phi = self.ops.solve_poisson(div_u_star / dt)\n                grad_phi = self.ops.grad(phi)\n                \n                u_star = (u_star[0] - dt * grad_phi[0],\n                          u_star[1] - dt * grad_phi[1])\n                p_corr += phi\n            \n            u_np1 = u_star\n            p_np1 = p_corr\n            \n            # Update for next step\n            u, p = u_np1, p_np1\n            E_nm1 = E_n\n            E_n = self._compute_E(u, t_np1)\n\n        # Compute errors at final time T\n        u_exact, _ = self.mms.get_solution(self.T)\n        \n        error_u = np.sqrt(np.mean((u[0] - u_exact[0])**2 + (u[1] - u_exact[1])**2))\n        \n        div_u_num = self.ops.div(u)\n        error_div = np.sqrt(np.mean(div_u_num**2))\n        \n        return error_u, error_div\n\ndef solve_case(case_params, N):\n    \"\"\"\n    Finds the minimum Nc for a given test case.\n    \"\"\"\n    dts = case_params['dts']\n    for Nc in [1, 2, 3]:\n        errors_u = []\n        errors_div = []\n        for dt in dts:\n            solver = PISOSolver(case_params, N, Nc, dt)\n            err_u, err_div = solver.run()\n            errors_u.append(err_u)\n            errors_div.append(err_div)\n\n        # Check for divergence saturation\n        if all(e = 1e-10 for e in errors_div):\n            div_order_ok = True\n        else:\n            p_div1 = np.log(errors_div[0] / errors_div[1]) / np.log(2)\n            p_div2 = np.log(errors_div[1] / errors_div[2]) / np.log(2)\n            div_order_ok = p_div1 >= 1.8 and p_div2 >= 1.8\n        \n        p_u1 = np.log(errors_u[0] / errors_u[1]) / np.log(2)\n        p_u2 = np.log(errors_u[1] / errors_u[2]) / np.log(2)\n        u_order_ok = p_u1 >= 1.8 and p_u2 >= 1.8\n        \n        if u_order_ok and div_order_ok:\n            return Nc\n    \n    return -1\n\ndef solve():\n    \"\"\" Main function to run all test cases and print the final result. \"\"\"\n    N = 48\n    test_cases = [\n        {'m': 1, 'omega': 4.0, 'nu': 0.01, 'T': 0.08, 'dts': [0.01, 0.005, 0.0025]},  # Case A\n        {'m': 2, 'omega': 6.0, 'nu': 0.02, 'T': 0.08, 'dts': [0.01, 0.005, 0.0025]},  # Case B\n        {'m': 1, 'omega': 3.0, 'nu': 0.005, 'T': 0.08, 'dts': [0.01, 0.005, 0.0025]},# Case C\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case, N)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3377833"}]}