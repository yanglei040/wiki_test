{"hands_on_practices": [{"introduction": "The cornerstone of a numerical method's accuracy lies in its ability to exactly represent simple functions. Since smooth functions can be locally approximated by polynomials, a method's \"order of accuracy\" is formally defined by the highest degree of polynomial for which it is exact. This practice [@problem_id:3337418] challenges you to implement and verify this fundamental property for Finite Difference, Finite Volume, and Finite Element operators using a manufactured polynomial solution, a crucial first step in building confidence in any numerical code.", "problem": "You are given the domain $[0,1]$ and a family of manufactured solutions defined by $u_p(x) = \\sum_{n=0}^{p} x^n$. The derivative is $u_p^{\\prime}(x) = \\sum_{n=1}^{p} n x^{n-1}$. Consider three discrete differentiation operators for the first derivative $u^{\\prime}(x)$ on one-dimensional nonuniform meshes:\n- Finite Difference (FD): Construct pointwise first-derivative weights on a stencil that enforce exactness for monomials up to degree $p$ by solving linear moment-matching conditions on nonuniform nodes.\n- Finite Volume (FV): Treat each interval $[x_i,x_{i+1}]$ as a control volume. Reconstruct, in each control volume, a polynomial of degree $p$ by matching cell averages over $p+1$ neighboring cells exactly via moment conditions. Use this reconstruction to evaluate the derivative at the cell center.\n- Finite Element (FE): On each element $[x_i,x_{i+1}]$, perform an interpolation of $u_p$ with Lagrange basis of degree $p$ at $p+1$ reference points within the element, and evaluate the derivative of the interpolant at the element center.\n\nStart from the following fundamental base:\n- The derivative definition: for a smooth function $v(x)$, $v^{\\prime}(x_0)$ is the linear functional that satisfies exactness on monomials, namely for $v(x) = (x-x_0)^n$ one has $v^{\\prime}(x_0) = \\delta_{n1}$, where $\\delta_{ij}$ is the Kronecker delta.\n- The Fundamental Theorem of Calculus: $\\int_{a}^{b} v^{\\prime}(x)\\,dx = v(b)-v(a)$.\n- Galerkin interpolation principle: if a function $v$ lies in a polynomial space of degree at most $p$, then its Lagrange interpolant of degree $p$ equals $v$ exactly within that element, hence so does its derivative.\n\nFor the Finite Difference operator, at a target node $x_0$ with stencil nodes $\\{x_j\\}_{j=0}^{m}$, enforce exactness up to degree $m = p$ by solving for weights $\\{w_j\\}$ that satisfy\n$$\n\\sum_{j=0}^{m} w_j (x_j - x_0)^n = \\begin{cases} 1, & n=1, \\\\ 0, & n \\in \\{0,2,3,\\dots,m\\}. \\end{cases}\n$$\nApply these weights to the function values to approximate $u^{\\prime}(x_0)$. Use centered stencils in the interior and one-sided stencils near boundaries so that the stencil size is $m+1$ everywhere.\n\nFor the Finite Volume operator, define cell averages for each cell $C_k = [x_k, x_{k+1}]$ by\n$$\n\\bar{u}_k = \\frac{1}{\\Delta x_k} \\int_{x_k}^{x_{k+1}} u(x)\\,dx,\\quad \\Delta x_k = x_{k+1}-x_k.\n$$\nIn cell $C_j$, reconstruct a polynomial $p_j(x) = \\sum_{\\ell=0}^{p} a_{\\ell} x^{\\ell}$ by enforcing exactness of cell averages over $p+1$ neighboring cells $\\{C_{j+r}\\}_{r=0}^{p}$,\n$$\n\\frac{1}{\\Delta x_{j+r}} \\int_{x_{j+r}}^{x_{j+r+1}} p_j(x)\\,dx = \\bar{u}_{j+r}, \\quad r=0,\\dots,p.\n$$\nEvaluate $p_j^{\\prime}(x)$ at the cell center $x_{j+\\frac{1}{2}} = \\frac{1}{2}(x_j + x_{j+1})$ to approximate $u^{\\prime}(x_{j+\\frac{1}{2}})$.\n\nFor the Finite Element operator, in element $E_i=[x_i,x_{i+1}]$ use Lagrange basis functions $\\{\\ell_k(\\xi)\\}_{k=0}^{p}$ on the reference element $\\xi \\in [-1,1]$ at $p+1$ distinct reference nodes $\\{\\xi_k\\}_{k=0}^{p}$ (for example, equispaced points). The physical mapping is $x(\\xi) = \\frac{1}{2}\\big((1-\\xi) x_i + (1+\\xi) x_{i+1}\\big)$. Interpolate $u_p(x)$ at the mapped node locations $x_k = x(\\xi_k)$, compute the interpolant derivative at the element center $\\xi=0$, and map it to physical space by $u_x = u_{\\xi}\\,\\frac{2}{x_{i+1}-x_i}$.\n\nYour task is to implement a program that, for each specified test case, constructs a nonuniform mesh, builds the three operators with the polynomial degree parameter $p$, applies them to the manufactured solution $u_p(x)$, computes the maximum absolute error against the exact derivative $u_p^{\\prime}(x)$ at their respective evaluation points, and reports whether the method is polynomially exact (within a tolerance $\\varepsilon$) for degree $p$.\n\nUse the following test suite of meshes and degrees:\n- Test case $1$: $p=2$, number of elements $N=12$, nodes $x_i = \\phi_1(\\xi_i)$ with $\\xi_i = i/N$ for $i=0,\\dots,N$ and $\\phi_1(\\xi) = \\xi^2$.\n- Test case $2$: $p=1$, number of elements $N=11$, nodes $x_i = \\phi_2(\\xi_i)$ with $\\xi_i = i/N$ and $\\phi_2(\\xi) = \\xi + \\alpha \\frac{\\sin(2\\pi \\xi)}{2\\pi}$ where $\\alpha=0.05$. This mapping is strictly increasing on $[0,1]$.\n- Test case $3$: $p=3$, number of elements $N=16$, nodes $x_i = \\phi_3(\\xi_i)$ with $\\xi_i = i/N$ and $\\phi_3(\\xi) = \\xi + \\beta \\xi^2 (1-\\xi)$ where $\\beta=0.2$.\n\nFor each test case, do the following:\n- Construct the Finite Difference operator using stencils of size $p+1$ (one-sided near boundaries and centered otherwise) and evaluate at all nodes.\n- Construct the Finite Volume operator using reconstruction degree $p$ from $p+1$ neighboring cells as above and evaluate at cell centers.\n- Construct the Finite Element operator using degree $p$ Lagrange interpolation on each element and evaluate at element centers.\n\nDefine the tolerance as $\\varepsilon = 10^{-10}$. For each method and test case, output a boolean value that is true if and only if the maximum absolute error is less than or equal to $\\varepsilon$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry corresponds to one test case and is itself a three-entry list in the order [FD,FV,FE]. For example, the output must have the form\n$$\n[[b_{11},b_{12},b_{13}],[b_{21},b_{22},b_{23}],[b_{31},b_{32},b_{33}]]\n$$\nwhere each $b_{ij}$ is a boolean.", "solution": "The user has provided a computational problem to validate and solve. The task is to implement three numerical differentiation methods—Finite Difference (FD), Finite Volume (FV), and Finite Element (FE)—and verify their theoretical exactness on polynomials.\n\n### Step 1: Problem Validation\n\nThe problem statement has been analyzed according to the specified validation protocol.\n\n**Givens Extracted:**\n1.  **Domain:** The one-dimensional interval $[0,1]$.\n2.  **Test Function:** A manufactured solution, $u_p(x) = \\sum_{n=0}^{p} x^n$, which is a polynomial of degree $p$. The exact derivative is $u_p^{\\prime}(x) = \\sum_{n=1}^{p} n x^{n-1}$.\n3.  **Numerical Methods:**\n    *   **Finite Difference (FD):** A stencil-based method using $p+1$ nodes to construct weights that are exact for monomials up to degree $p$. The derivative is approximated at each mesh node.\n    *   **Finite Volume (FV):** A cell-based method where a polynomial of degree $p$ is reconstructed within each cell by matching cell-average values over a stencil of $p+1$ neighboring cells. The derivative is evaluated at cell centers.\n    *   **Finite Element (FE):** An element-based method where the function is interpolated on each element using a degree-$p$ Lagrange polynomial. The derivative of this interpolant is evaluated at the element center.\n4.  **Mesh Generation:** Nonuniform meshes are generated by mapping a uniform grid $\\xi_i = i/N$ through specified nonlinear functions $\\phi(\\xi)$.\n5.  **Test Cases:** Three specific combinations of polynomial degree $p$, number of elements $N$, and mesh mapping functions $\\phi(\\xi)$ are provided.\n6.  **Verification Criterion:** A method is considered \"polynomially exact\" if the maximum absolute error between the numerical and exact derivatives is less than or equal to a tolerance $\\varepsilon = 10^{-10}$.\n\n**Validation Verdict:**\nThe problem is **valid**.\n*   **Scientifically Grounded:** The problem is firmly rooted in the principles of numerical analysis and computational fluid dynamics. The methods described (FD, FV, FE) are standard, and the manufactured solution approach is a cornerstone of code verification.\n*   **Well-Posed:** The problem is mathematically well-defined. Each method is constructed based on principles (monomial exactness, cell-average matching, Lagrange interpolation) that guarantee a unique solution exists. The test function, $u_p(x)$, is a polynomial of degree $p$. All three methods, as described, are designed to be exact for polynomials of degree up to $p$. Therefore, the expected result is that the numerical derivative will match the exact derivative to within machine precision. The task is to numerically verify this theoretical property.\n*   **Objective and Complete:** The problem is stated with clear, objective language. All necessary parameters, functions, and criteria are explicitly provided. While the description of the FV stencil (\"$\\{C_{j+r}\\}_{r=0}^{p}$\") could be interpreted as strictly forward-biased, the context of the problem and the description for the FD method strongly imply that a standard shifting stencil (centered in the interior, biased at boundaries) should be used. This interpretation makes the problem fully consistent and solvable for all cells.\n\nBased on this validation, the solution proceeds with the implementation.\n\n### Step 2: Solution Design\n\nThe core of the solution is to implement three separate functions, one for each numerical method, which compute the maximum absolute error for a given test case. A main function will then iterate through the specified test cases, collect the results, and format the output as required.\n\n**Manufactured Solution:**\nThe functions for the manufactured solution $u_p(x)$ and its derivative $u_p'(x)$ are implemented to handle both scalar and vector inputs for $x$, using `NumPy` for efficiency.\n$u_p(x) = \\sum_{n=0}^{p} x^n$\n$u_p^{\\prime}(x) = \\sum_{n=1}^{p} n x^{n-1}$\n\n**Finite Difference (FD) Method:**\nFor each node $x_i$ ($i \\in \\{0, \\dots, N\\}$) on the nonuniform grid:\n1.  A stencil of $p+1$ nodes is selected. The stencil is centered around $x_i$ where possible and shifted towards the interior near the domain boundaries to remain within the grid.\n2.  A linear system is formed to find the weights $\\{w_j\\}$. The system enforces that the weighted sum of monomials $(x_j-x_i)^n$ evaluated at the stencil nodes equals the derivative of that monomial at $x_i$, which is $\\delta_{n1}$ for $n \\in \\{0, \\dots, p\\}$. This is a $(p+1) \\times (p+1)$ Vandermonde-type system: $\\sum_{j=0}^{p} w_j (s_j - x_i)^n = \\delta_{n1}$, where $\\{s_j\\}$ are the stencil nodes.\n3.  The system is solved for the weights $w_j$.\n4.  The derivative is approximated as $u_{approx}^{\\prime}(x_i) = \\sum_j w_j u_p(s_j)$.\n5.  The absolute error $|u_{approx}^{\\prime}(x_i) - u_p^{\\prime}(x_i)|$ is computed. The maximum error over all nodes is returned.\n\n**Finite Volume (FV) Method:**\nFor each cell $C_j = [x_j, x_{j+1}]$ ($j \\in \\{0, \\dots, N-1\\}$):\n1.  A stencil of $p+1$ cells is selected, centered around cell $C_j$ where possible and shifted near boundaries.\n2.  The exact cell averages of the manufactured solution, $\\bar{u}_k = \\frac{1}{\\Delta x_k} \\int_{x_k}^{x_{k+1}} u_p(x) dx$, are computed for each cell $C_k$ in the stencil. The integral of $u_p(x)$ is computed analytically.\n3.  A polynomial reconstruction $p_j(x) = \\sum_{\\ell=0}^{p} a_{\\ell} x^{\\ell}$ is sought. Its coefficients $\\{a_\\ell\\}$ are found by solving a linear system that matches the cell averages of $p_j(x)$ to the exact averages $\\bar{u}_k$ over the stencil cells. The matrix for this system has entries $M_{k\\ell} = \\frac{1}{\\Delta x_k} \\int_{x_k}^{x_{k+1}} x^\\ell dx$.\n4.  The derivative of the reconstruction, $p_j^{\\prime}(x)$, is evaluated at the center of the target cell $x_{j+1/2}$. This gives $u_{approx}^{\\prime}(x_{j+1/2})$.\n5.  The absolute error against the exact derivative $u_p^{\\prime}(x_{j+1/2})$ is computed. The maximum error over all cells is returned.\n\n**Finite Element (FE) Method:**\nFor each element $E_i = [x_i, x_{i+1}]$ ($i \\in \\{0, \\dots, N-1\\}$):\n1.  A set of $p+1$ distinct nodes (e.g., equispaced) is defined on the reference element $\\xi \\in [-1, 1]$.\n2.  These reference nodes are mapped to physical coordinates within $[x_i, x_{i+1}]$.\n3.  The values of the manufactured solution $u_p(x)$ are sampled at these physical nodes.\n4.  The coefficients of the degree-$p$ interpolating polynomial $U(\\xi)$ in the reference coordinate $\\xi$ are found by solving a Vandermonde system.\n5.  The derivative of the interpolant with respect to $\\xi$ at the element center ($\\xi=0$) is simply the second coefficient, $c_1$, of the polynomial $U(\\xi) = \\sum_{j=0}^p c_j \\xi^j$.\n6.  The chain rule is used to map this derivative back to the physical coordinate system: $u_{approx}^{\\prime}(x_{i+1/2}) = U'(\\xi=0) \\frac{d\\xi}{dx} = c_1 \\frac{2}{x_{i+1}-x_i}$.\n7.  The absolute error against the exact derivative $u_p^{\\prime}(x_{i+1/2})$ is calculated. The maximum error over all elements is returned.\n\nAll three methods are constructed to be exact for polynomials of degree $p$. Therefore, the expected outcome for all test cases is that the error will be on the order of machine precision, and thus less than the specified tolerance $\\varepsilon = 10^{-10}$.", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve as linalg_solve\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print results.\n    \"\"\"\n    EPSILON = 1e-10\n\n    # --- Test Case Definitions ---\n    def phi1(xi): return xi**2\n    def phi2(xi): return xi + 0.05 * np.sin(2 * np.pi * xi) / (2 * np.pi)\n    def phi3(xi): return xi + 0.2 * xi**2 * (1 - xi)\n    \n    test_cases = [\n        {'p': 2, 'N': 12, 'phi': phi1, 'name': 'Case 1'},\n        {'p': 1, 'N': 11, 'phi': phi2, 'name': 'Case 2'},\n        {'p': 3, 'N': 16, 'phi': phi3, 'name': 'Case 3'},\n    ]\n\n    # --- Manufactured Solution and its Derivative ---\n    def u_poly(x, p):\n        x = np.asarray(x)\n        original_shape = x.shape\n        x = x.flatten()\n        powers = np.arange(p + 1)\n        res = np.sum(x[:, np.newaxis] ** powers, axis=1)\n        return res.reshape(original_shape)\n\n    def u_poly_prime(x, p):\n        if p == 0: return np.zeros_like(x)\n        x = np.asarray(x)\n        original_shape = x.shape\n        x = x.flatten()\n        powers = np.arange(1, p + 1)\n        exponents = powers - 1\n        res = np.sum(powers * x[:, np.newaxis] ** exponents, axis=1)\n        return res.reshape(original_shape)\n\n    # --- Operator Implementations ---\n\n    def calculate_fd_error(p, N, phi_func):\n        nodes = phi_func(np.linspace(0.0, 1.0, N + 1))\n        errors = []\n        \n        for i in range(N + 1):\n            target_node = nodes[i]\n            \n            start_idx = i - p // 2\n            start_idx = max(0, start_idx)\n            start_idx = min(start_idx, N - p)\n            stencil_indices = np.arange(start_idx, start_idx + p + 1)\n            stencil_nodes = nodes[stencil_indices]\n            \n            # (V.T) w = b, where V_nk = (s_k - x_i)^n\n            matrix = np.array([(stencil_nodes - target_node)**n for n in range(p + 1)])\n            \n            rhs = np.zeros(p + 1)\n            rhs[1] = 1.0\n            \n            weights = linalg_solve(matrix.T, rhs, assume_a='gen')\n            \n            u_vals_stencil = u_poly(stencil_nodes, p)\n            u_prime_approx = np.dot(weights, u_vals_stencil)\n            u_prime_exact = u_poly_prime(target_node, p)\n            \n            errors.append(np.abs(u_prime_approx - u_prime_exact))\n            \n        return np.max(errors) if errors else 0.0\n\n    def calculate_fv_error(p, N, phi_func):\n        nodes = phi_func(np.linspace(0.0, 1.0, N + 1))\n        \n        def integral_u_poly(a, b, p_val):\n            n_plus_1 = np.arange(1, p_val + 2)\n            terms = (b**n_plus_1 - a**n_plus_1) / n_plus_1\n            return np.sum(terms)\n\n        errors = []\n        cell_centers = 0.5 * (nodes[:-1] + nodes[1:])\n\n        for j in range(N):\n            start_idx = j - p // 2\n            start_idx = max(0, start_idx)\n            start_idx = min(start_idx, N - 1 - p)\n            stencil_indices = np.arange(start_idx, start_idx + p + 1)\n            \n            M = np.zeros((p + 1, p + 1))\n            b = np.zeros(p + 1)\n            \n            for r, cell_idx in enumerate(stencil_indices):\n                x_k, x_k1 = nodes[cell_idx], nodes[cell_idx + 1]\n                delta_x = x_k1 - x_k\n                \n                b[r] = integral_u_poly(x_k, x_k1, p) / delta_x\n                \n                for l in range(p + 1):\n                    M[r, l] = (x_k1**(l + 1) - x_k**(l + 1)) / ((l + 1) * delta_x)\n            \n            coeffs = linalg_solve(M, b, assume_a='gen')\n            \n            target_center = cell_centers[j]\n            l_vals = np.arange(1, p + 1)\n            u_prime_approx = np.sum(l_vals * coeffs[1:] * target_center**(l_vals - 1))\n            u_prime_exact = u_poly_prime(target_center, p)\n            \n            errors.append(np.abs(u_prime_approx - u_prime_exact))\n            \n        return np.max(errors) if errors else 0.0\n\n    def calculate_fe_error(p, N, phi_func):\n        nodes = phi_func(np.linspace(0.0, 1.0, N + 1))\n        errors = []\n        \n        ref_nodes = np.linspace(-1.0, 1.0, p + 1)\n        V = np.vander(ref_nodes, increasing=True)\n        \n        for i in range(N):\n            x_i, x_i1 = nodes[i], nodes[i+1]\n            \n            phys_nodes = 0.5 * ((1 - ref_nodes) * x_i + (1 + ref_nodes) * x_i1)\n            u_vals = u_poly(phys_nodes, p)\n            \n            coeffs = linalg_solve(V, u_vals, assume_a='gen')\n            \n            u_prime_xi_at_center = coeffs[1] if p > 0 else 0.0\n            dx_dxi = (x_i1 - x_i) / 2.0\n            u_prime_approx = u_prime_xi_at_center / dx_dxi\n            \n            target_center = 0.5 * (x_i + x_i1)\n            u_prime_exact = u_poly_prime(target_center, p)\n            \n            errors.append(np.abs(u_prime_approx - u_prime_exact))\n            \n        return np.max(errors) if errors else 0.0\n\n    # --- Main Loop ---\n    all_results = []\n    for case in test_cases:\n        p, N, phi = case['p'], case['N'], case['phi']\n        \n        err_fd = calculate_fd_error(p, N, phi)\n        err_fv = calculate_fv_error(p, N, phi)\n        err_fe = calculate_fe_error(p, N, phi)\n        \n        results_case = [\n            err_fd = EPSILON,\n            err_fv = EPSILON,\n            err_fe = EPSILON\n        ]\n        all_results.append(results_case)\n\n    # --- Format Output ---\n    def bool_to_str(b): return \"true\" if b else \"false\"\n    \n    case_strs = [f\"[{','.join(map(bool_to_str, case))}]\" for case in all_results]\n    final_str = f\"[{','.join(case_strs)}]\"\n    \n    print(final_str)\n\nsolve()\n```", "id": "3337418"}, {"introduction": "Once a spatial discretization is chosen, solving a time-dependent problem requires a time-stepping scheme, which brings the critical issue of numerical stability. An unstable scheme will produce solutions that grow without bound, rendering the simulation useless. This exercise [@problem_id:3337490] guides you through the classic von Neumann stability analysis to derive the celebrated Courant-Friedrichs-Lewy (CFL) condition for an explicit upwind advection scheme, revealing the fundamental link between the time step $\\Delta t$, grid spacing $h$, and the physical wave speed $a$.", "problem": "Consider the one-dimensional linear advection equation $u_{t} + a\\,u_{x} = 0$ with constant wave speed $a \\in \\mathbb{R}$ on a periodic spatial domain $x \\in [0,L]$. Let the spatial grid be uniform with spacing $h  0$, and let the time step be $\\Delta t  0$. Define the explicit upwind finite difference scheme that is consistent with the sign of $a$ by\nfor $a  0$: $u_{j}^{n+1} = u_{j}^{n} - \\frac{a\\,\\Delta t}{h}\\left(u_{j}^{n} - u_{j-1}^{n}\\right)$,\nfor $a  0$: $u_{j}^{n+1} = u_{j}^{n} - \\frac{a\\,\\Delta t}{h}\\left(u_{j+1}^{n} - u_{j}^{n}\\right)$,\nwhere $u_{j}^{n}$ approximates $u(x_{j}, t^{n})$ with $x_{j} = j h$ and $t^{n} = n \\Delta t$. Starting from the governing equation $u_{t} + a\\,u_{x} = 0$ and the above discrete update, perform a von Neumann stability analysis (also called Fourier or von Neumann stability analysis) by assuming a discrete Fourier mode $u_{j}^{n} = \\hat{u}^{n}\\,\\exp(i\\,\\kappa\\,x_{j})$ with wavenumber $\\kappa \\in \\mathbb{R}$ and periodic boundary conditions. Derive the corresponding amplification factor $G(\\kappa)$ and enforce the stability requirement $|G(\\kappa)| \\leq 1$ for all admissible wavenumbers. Use this to determine the complete set of time steps $\\Delta t$ that ensure stability for each sign of $a$, and then consolidate these into a single stability restriction expressed via the Courant number, consistent with the Courant–Friedrichs–Lewy (CFL) condition. Finally, report the maximal stable time step $\\Delta t_{\\max}$ as a single closed-form symbolic expression in terms of $|a|$ and $h$. Express the final answer as one closed-form expression; do not state it as an inequality and do not include any physical units.", "solution": "The partial differential equation $u_{t} + a\\,u_{x} = 0$ models pure advection at constant speed $a$. For stability analysis of a linear constant-coefficient finite difference scheme on a periodic domain, the von Neumann stability analysis proceeds by substituting a discrete Fourier mode into the update and studying the resulting amplification factor.\n\nWe consider the uniform grid $x_{j} = j h$ and time levels $t^{n} = n \\Delta t$. The explicit upwind scheme is defined in a way that aligns the spatial differencing with the direction of propagation: for $a  0$, the upwind derivative uses the backward difference, and for $a  0$, it uses the forward difference. Introduce the Courant number $\\nu = \\frac{a\\,\\Delta t}{h}$.\n\nCase $a  0$. The scheme is\n$$\nu_{j}^{n+1} = u_{j}^{n} - \\nu\\left(u_{j}^{n} - u_{j-1}^{n}\\right).\n$$\nAssume a Fourier mode $u_{j}^{n} = \\hat{u}^{n}\\,\\exp(i\\,\\kappa\\,x_{j})$ with $x_{j} = j h$ and denote $\\theta = \\kappa h$. Then $u_{j-1}^{n} = \\hat{u}^{n}\\,\\exp(i\\,\\kappa\\,x_{j-1}) = \\hat{u}^{n}\\,\\exp(i\\,\\kappa\\,(x_{j} - h)) = \\hat{u}^{n}\\,\\exp(i\\,\\kappa\\,x_{j})\\,\\exp(-i\\,\\theta)$. Substituting into the update gives\n$$\n\\hat{u}^{n+1}\\,\\exp(i\\,\\kappa\\,x_{j}) = \\hat{u}^{n}\\,\\exp(i\\,\\kappa\\,x_{j}) - \\nu\\left[\\hat{u}^{n}\\,\\exp(i\\,\\kappa\\,x_{j}) - \\hat{u}^{n}\\,\\exp(i\\,\\kappa\\,x_{j})\\,\\exp(-i\\,\\theta)\\right].\n$$\nDivide both sides by $\\exp(i\\,\\kappa\\,x_{j})$ to obtain the amplification relation $\\hat{u}^{n+1} = G(\\theta)\\,\\hat{u}^{n}$ with\n$$\nG(\\theta) = 1 - \\nu\\left(1 - \\exp(-i\\,\\theta)\\right).\n$$\nWe compute the magnitude of $G(\\theta)$. Write $\\exp(-i\\,\\theta) = \\cos(\\theta) - i \\sin(\\theta)$, so\n$$\nG(\\theta) = 1 - \\nu + \\nu\\cos(\\theta) - i\\,\\nu\\sin(\\theta).\n$$\nThe squared magnitude is\n\\begin{align*}\n|G(\\theta)|^{2} = \\left(1 - \\nu + \\nu\\cos(\\theta)\\right)^{2} + \\left(\\nu\\sin(\\theta)\\right)^{2} \\\\\n= (1 - \\nu)^{2} + 2\\nu(1 - \\nu)\\cos(\\theta) + \\nu^{2}\\cos^{2}(\\theta) + \\nu^{2}\\sin^{2}(\\theta) \\\\\n= (1 - \\nu)^{2} + 2\\nu(1 - \\nu)\\cos(\\theta) + \\nu^{2} \\\\\n= 1 - 2\\nu + 2\\nu^{2} + 2\\nu(1 - \\nu)\\cos(\\theta).\n\\end{align*}\nFor fixed $\\nu \\in \\mathbb{R}$, the dependence on $\\theta$ enters only through $\\cos(\\theta) \\in [-1, 1]$. When $0 \\leq \\nu \\leq 1$, the coefficient $2\\nu(1 - \\nu)$ is nonnegative, so the maximum over $\\theta$ occurs at $\\cos(\\theta) = 1$, yielding $|G(\\theta)|^{2} = 1$. The minimum occurs at $\\cos(\\theta) = -1$, giving $|G(\\theta)|^{2} = 1 - 4\\nu + 4\\nu^{2} = (1 - 2\\nu)^{2} \\leq 1$. Thus for $a  0$, stability in the von Neumann sense ($|G(\\theta)| \\leq 1$ for all $\\theta$) holds precisely when $0 \\leq \\nu \\leq 1$, that is, $0 \\leq \\frac{a\\,\\Delta t}{h} \\leq 1$, equivalently $0 \\leq \\Delta t \\leq \\frac{h}{a}$.\n\nCase $a  0$. The scheme is\n$$\nu_{j}^{n+1} = u_{j}^{n} - \\nu\\left(u_{j+1}^{n} - u_{j}^{n}\\right),\n$$\nwith $\\nu = \\frac{a\\,\\Delta t}{h}  0$. Using the Fourier mode $u_{j+1}^{n} = \\hat{u}^{n}\\,\\exp(i\\,\\kappa\\,x_{j+1}) = \\hat{u}^{n}\\,\\exp(i\\,\\kappa\\,x_{j})\\,\\exp(i\\,\\theta)$, substitution gives\n$$\n\\hat{u}^{n+1}\\,\\exp(i\\,\\kappa\\,x_{j}) = \\hat{u}^{n}\\,\\exp(i\\,\\kappa\\,x_{j}) - \\nu\\left[\\hat{u}^{n}\\,\\exp(i\\,\\kappa\\,x_{j})\\,\\exp(i\\,\\theta) - \\hat{u}^{n}\\,\\exp(i\\,\\kappa\\,x_{j})\\right].\n$$\nDivide by $\\exp(i\\,\\kappa\\,x_{j})$ to obtain\n$$\n\\hat{u}^{n+1} = \\left(1 - \\nu\\left(\\exp(i\\,\\theta) - 1\\right)\\right)\\hat{u}^{n}, \\quad G(\\theta) = 1 - \\nu\\left(\\exp(i\\,\\theta) - 1\\right).\n$$\nWriting $\\exp(i\\,\\theta) = \\cos(\\theta) + i \\sin(\\theta)$, we have\n$$\nG(\\theta) = 1 + \\nu - \\nu\\cos(\\theta) - i\\,\\nu\\sin(\\theta),\n$$\nand\n\\begin{align*}\n|G(\\theta)|^{2} = \\left(1 + \\nu - \\nu\\cos(\\theta)\\right)^{2} + \\left(\\nu\\sin(\\theta)\\right)^{2} \\\\\n= (1 + \\nu)^{2} - 2\\nu(1 + \\nu)\\cos(\\theta) + \\nu^{2}\\cos^{2}(\\theta) + \\nu^{2}\\sin^{2}(\\theta) \\\\\n= (1 + \\nu)^{2} - 2\\nu(1 + \\nu)\\cos(\\theta) + \\nu^{2} \\\\\n= 1 + 2\\nu + 2\\nu^{2} - 2\\nu(1 + \\nu)\\cos(\\theta).\n\\end{align*}\nFor $\\nu \\in [-1, 0]$, the coefficient $-2\\nu(1 + \\nu)$ is nonnegative (because $\\nu \\leq 0$ and $1 + \\nu \\geq 0$), so the maximum over $\\theta$ occurs at $\\cos(\\theta) = 1$, yielding $|G(\\theta)|^{2} = 1$. The minimum occurs at $\\cos(\\theta) = -1$, giving $|G(\\theta)|^{2} = 1 + 4\\nu + 4\\nu^{2} = (1 + 2\\nu)^{2} \\leq 1$. Thus for $a  0$, stability holds precisely when $-1 \\leq \\nu \\leq 0$, that is, $0 \\leq \\Delta t \\leq \\frac{h}{|a|}$.\n\nConsolidating both cases, the von Neumann stability condition for the explicit upwind scheme is $|\\nu| \\leq 1$, equivalently $\\Delta t \\leq \\frac{h}{|a|}$. The maximal stable time step is therefore\n$$\n\\Delta t_{\\max} = \\frac{h}{|a|}.\n$$\nThis coincides with the Courant–Friedrichs–Lewy (CFL) restriction for monotone upwind advection: the numerical domain of dependence must include the physical domain of dependence, which here enforces that the ratio of the distance traversed by advection in one time step, $|a|\\,\\Delta t$, to the grid spacing $h$ not exceed $1$.\n\nTherefore, the requested single closed-form symbolic expression for the maximal stable time step is $\\Delta t_{\\max} = \\frac{h}{|a|}$.", "answer": "$$\\boxed{\\frac{h}{|a|}}$$", "id": "3337490"}, {"introduction": "A stable and formally accurate scheme does not always guarantee a physically meaningful solution. In advection-dominated problems, simple centered-difference schemes can produce non-physical oscillations, violating the maximum principle that governs the underlying physics. This practical exercise [@problem_id:3337479] demonstrates this failure and introduces a powerful remedy: a high-resolution finite volume scheme with a flux limiter, which is designed to capture sharp fronts without generating spurious over- and undershoots.", "problem": "Consider the one-dimensional advection–diffusion equation on a periodic domain derived from conservation of mass and Fick’s law, namely the scalar partial differential equation $u_t + a\\,u_x - \\nu\\,u_{xx} = 0$ on $x \\in [0,1]$ with period $1$. Here $u(x,t)$ is the conserved scalar, $a$ is a constant advection speed, and $\\nu$ is a constant diffusivity. The continuous equation satisfies a maximum principle in the sense that if $u(x,0)$ is bounded between a minimum and a maximum, then no new extrema appear for $t \\ge 0$.\n\nYou will study the conditions under which a discrete maximum principle holds for two semi-discretizations in space coupled with forward Euler in time, and you will empirically construct a counterexample at high cell Peclet number to demonstrate violation and a flux-limiter remedy that restores monotonicity.\n\nDefinitions to use in your derivation and implementation:\n- The uniform grid consists of $N$ points with spacing $\\Delta x = 1/N$, cell centers at $x_i = (i+1/2)\\Delta x$ for $i=0,\\dots,N-1$, and periodic indexing.\n- The discrete maximum principle (DMP) shall be tested numerically as follows: let $u^0$ be the initial discrete state and $u^n$ the solution after $n$ time steps. The DMP is declared to hold if for all time steps $n$ the inequalities $\\min_i u^n_i \\ge \\min_i u^0_i - \\tau$ and $\\max_i u^n_i \\le \\max_i u^0_i + \\tau$ with tolerance $\\tau = 10^{-8}$ are satisfied.\n- The cell Peclet number is defined as $Pe_h = |a|\\Delta x/\\nu$.\n\nSchemes to implement:\n- Finite difference central scheme (FD-central): discretize $u_x$ by the centered difference on the uniform grid and $u_{xx}$ by the standard second-order centered difference. The method-of-lines ordinary differential equation is integrated by forward Euler with time step $\\Delta t$.\n- Finite volume upwind scheme with a minmod slope limiter (FV-upwind-limited): compute the intercell convective flux using an upwinded, piecewise-linear reconstruction with the minmod slope limiter applied to the one-sided differences to retain total variation diminishing behavior for scalar advection. The diffusive flux is the centered gradient at faces. Update cell averages by the flux difference with forward Euler time stepping of size $\\Delta t$.\n\nInitial conditions to use:\n- Smooth case: $u(x,0) = \\tfrac{1}{2} + \\tfrac{1}{2}\\sin(2\\pi x)$.\n- Counterexample case (sharp front): $u(x,0) = 1$ for $x \\in [0.4,0.6)$ and $u(x,0) = 0$ elsewhere on $[0,1)$, interpreted periodically.\n\nTask:\n- Starting from the conservation law and definitions above as the fundamental base, derive the discrete coefficient conditions under which the FD-central forward Euler update is an M-matrix type convex combination that ensures a discrete maximum principle in one space dimension. Similarly, derive sufficient step-size and coefficient conditions for the FV-upwind-limited forward Euler update to be monotone. Use these to predict when violations can occur at high $Pe_h$ for centered differences, and explain why the upwind limited flux remedies the violation.\n- Implement both schemes and construct numerical evidence for violation and remedy by running the specified test suite below and checking the DMP condition with the tolerance $\\tau$ at every time step.\n\nTest suite:\n- Case $1$ (happy path, smooth and diffusive): $N=100$, $a=1.0$, $\\nu=0.1$, $\\Delta t=2.5\\times 10^{-4}$, $T=0.05$, scheme FD-central, smooth initial condition. Expected behavior: DMP holds.\n- Case $2$ (counterexample, high $Pe_h$ with centered differences): $N=100$, $a=5.0$, $\\nu=10^{-3}$, $\\Delta t=2.0\\times 10^{-4}$, $T=0.02$, scheme FD-central, sharp-front initial condition. Expected behavior: DMP violation due to dispersive oscillations.\n- Case $3$ (remedy with limiter at high $Pe_h$): $N=100$, $a=5.0$, $\\nu=10^{-3}$, $\\Delta t=10^{-3}$, $T=0.02$, scheme FV-upwind-limited, sharp-front initial condition. Expected behavior: DMP holds.\n- Case $4$ (borderline $Pe_h$ with centered differences): $N=100$, $a=1.0$, $\\nu=10^{-2}$, $\\Delta t=2.5\\times 10^{-3}$, $T=0.05$, scheme FD-central, sharp-front initial condition. Expected behavior: DMP holds provided the coefficient and step-size constraints are satisfied.\n\nComputational and output requirements:\n- Use double-precision arithmetic. The domain is dimensionless; no physical units are required.\n- For each case, advance the numerical solution from $t=0$ to $t=T$ using the specified scheme and parameters, enforcing periodic boundary conditions.\n- For each case, output a boolean indicating whether the DMP holds at all time steps for that case with tolerance $\\tau = 10^{-8}$.\n- Your program should produce a single line of output containing the results for the four cases as a comma-separated list enclosed in square brackets, for example $[true,false,true,true]$. Use the host language’s native boolean literals.\n\nNotes:\n- Angles do not appear; no angle unit is needed.\n- Ensure the implementation is self-contained and does not require external data.", "solution": "The user has provided a well-posed problem from the field of computational fluid dynamics, which requires both a theoretical derivation of conditions for a discrete maximum principle (DMP) and a numerical implementation to verify these conditions. The problem is scientifically grounded, internally consistent, and contains all necessary information. We proceed with the solution.\n\nThe governing equation is the one-dimensional advection–diffusion equation, a conservation law given by\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial}{\\partial x} \\left( a u - \\nu \\frac{\\partial u}{\\partial x} \\right) = 0\n$$\nwhere $u(x,t)$ is a scalar quantity, $a$ is the constant advection speed, and $\\nu$ is the constant diffusivity. For a constant $a$, this expands to $u_t + a u_x - \\nu u_{xx} = 0$. We will analyze two spatial discretizations on a uniform periodic grid with $N$ cells of width $\\Delta x = 1/N$ and cell centers $x_i = (i+1/2)\\Delta x$. Time integration is performed using the explicit forward Euler method with step size $\\Delta t$.\n\nA numerical scheme is said to satisfy a discrete maximum principle if, for an initial condition $u^0$, the solution $u^n$ at any time step $n$ remains bounded by the initial minimum and maximum values, i.e., $\\min_i u_i^n \\ge \\min_i u_i^0$ and $\\max_i u_i^n \\le \\max_i u_i^0$. A sufficient condition for this is that the update for each grid point $u_i^{n+1}$ is a convex combination of values from the previous time step, $u^n$. That is, if the scheme can be written as $u_i^{n+1} = \\sum_{j} C_j u_j^n$, the DMP is guaranteed if all coefficients $C_j \\ge 0$ and their sum $\\sum_j C_j = 1$.\n\n**Analysis of the Finite Difference Central (FD-central) Scheme**\n\nThe FD-central scheme discretizes the spatial derivatives as:\n$$\nu_x \\approx \\frac{u_{i+1}^n - u_{i-1}^n}{2\\Delta x} \\quad \\text{and} \\quad u_{xx} \\approx \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{\\Delta x^2}\n$$\nSubstituting these into the governing equation with forward Euler time stepping gives the update formula:\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + a \\left(\\frac{u_{i+1}^n - u_{i-1}^n}{2\\Delta x}\\right) - \\nu \\left(\\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{\\Delta x^2}\\right) = 0\n$$\nSolving for $u_i^{n+1}$ and grouping terms by their spatial index at time $n$:\n$$\nu_i^{n+1} = u_i^n - \\Delta t \\left[ a \\frac{u_{i+1}^n - u_{i-1}^n}{2\\Delta x} - \\nu \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{\\Delta x^2} \\right]\n$$\n$$\nu_i^{n+1} = \\left(\\frac{\\nu \\Delta t}{\\Delta x^2} - \\frac{a \\Delta t}{2\\Delta x}\\right) u_{i+1}^n + \\left(1 - \\frac{2\\nu \\Delta t}{\\Delta x^2}\\right) u_i^n + \\left(\\frac{\\nu \\Delta t}{\\Delta x^2} + \\frac{a \\Delta t}{2\\Delta x}\\right) u_{i-1}^n\n$$\nLet's denote the coefficients of $u_{i+1}^n$, $u_i^n$, and $u_{i-1}^n$ by $C_{i+1}$, $C_i$, and $C_{i-1}$ respectively. The sum of the coefficients is $C_{i+1} + C_i + C_{i-1} = (\\frac{\\nu \\Delta t}{\\Delta x^2} - \\frac{a \\Delta t}{2\\Delta x}) + (1 - \\frac{2\\nu \\Delta t}{\\Delta x^2}) + (\\frac{\\nu \\Delta t}{\\Delta x^2} + \\frac{a \\Delta t}{2\\Delta x}) = 1$. Thus, the scheme forms a convex combination if and only if all coefficients are non-negative.\n1.  $C_i \\ge 0 \\implies 1 - \\frac{2\\nu \\Delta t}{\\Delta x^2} \\ge 0 \\implies \\Delta t \\le \\frac{\\Delta x^2}{2\\nu}$. This is the standard CFL stability condition for diffusion.\n2.  $C_{i+1} \\ge 0 \\implies \\frac{\\nu \\Delta t}{\\Delta x^2} - \\frac{a \\Delta t}{2\\Delta x} \\ge 0$. Assuming $\\Delta t  0$, this simplifies to $\\frac{\\nu}{\\Delta x} \\ge \\frac{a}{2}$.\n3.  $C_{i-1} \\ge 0 \\implies \\frac{\\nu \\Delta t}{\\Delta x^2} + \\frac{a \\Delta t}{2\\Delta x} \\ge 0$. Assuming $\\Delta t  0$, this simplifies to $\\frac{\\nu}{\\Delta x} \\ge -\\frac{a}{2}$.\n\nCombining the conditions on $C_{i+1}$ and $C_{i-1}$ yields $|\\frac{a}{2}| \\le \\frac{\\nu}{\\Delta x}$, which is equivalent to $\\frac{|a|\\Delta x}{\\nu} \\le 2$. This introduces a restriction on the cell Peclet number, $Pe_h = \\frac{|a|\\Delta x}{\\nu}$.\nTherefore, the FD-central scheme with forward Euler satisfies the DMP if two conditions are met:\n$$\n\\Delta t \\le \\frac{\\Delta x^2}{2\\nu} \\quad \\text{(parabolic CFL condition)} \\quad \\text{and} \\quad Pe_h = \\frac{|a|\\Delta x}{\\nu} \\le 2 \\quad \\text{(cell Peclet condition)}\n$$\nWhen $Pe_h  2$, one of the off-diagonal coefficients becomes negative. This means $u_i^{n+1}$ is no longer a convex combination of its neighbors. A negative coefficient allows for the creation of new extrema (spurious oscillations or undershoots/overshoots), thus violating the DMP. This is particularly noticeable when advection dominates diffusion ($Pe_h \\gg 1$) and the solution has sharp gradients.\n\n**Analysis of the Finite Volume Upwind-Limited (FV-upwind-limited) Scheme**\n\nThe finite volume method updates the cell average $\\bar{u}_i$ based on the fluxes at the cell boundaries (interfaces):\n$$\n\\frac{d\\bar{u}_i}{dt} = -\\frac{1}{\\Delta x} (F_{i+1/2} - F_{i-1/2})\n$$\nThe numerical flux $F_{i+1/2}$ is composed of a convective and a diffusive part: $F_{i+1/2} = F_{i+1/2}^{conv} + F_{i+1/2}^{diff}$. The diffusive flux is approximated by a centered difference: $F_{i+1/2}^{diff} = -\\nu \\frac{\\bar{u}_{i+1} - \\bar{u}_i}{\\Delta x}$.\n\nFor the convective flux, this scheme uses a piecewise-linear reconstruction within each cell $i$, $u(x) = \\bar{u}_i + \\sigma_i (x - x_i)$, where $\\sigma_i$ is a limited slope. The specified minmod limiter on one-sided differences is:\n$$\n\\sigma_i = \\text{minmod}\\left(\\frac{\\bar{u}_i - \\bar{u}_{i-1}}{\\Delta x}, \\frac{\\bar{u}_{i+1} - \\bar{u}_i}{\\Delta x}\\right)\n$$\nwhere $\\text{minmod}(a,b) = \\frac{1}{2}(\\text{sgn}(a)+\\text{sgn}(b))\\min(|a|,|b|)$. The purpose of the limiter is to make the reconstruction non-oscillatory, meaning the reconstructed values at the cell edges, $\\bar{u}_i \\pm \\sigma_i \\frac{\\Delta x}{2}$, do not exceed the values of the neighboring cell averages. This property is crucial for satisfying the DMP.\n\nThe convective flux is then determined using an upwind choice based on the sign of $a$. At interface $i+1/2$:\n- If $a  0$, the flow is from left to right, so we use the reconstruction from cell $i$: $F_{i+1/2}^{conv} = a \\left(\\bar{u}_i + \\sigma_i \\frac{\\Delta x}{2}\\right)$.\n- If $a  0$, the flow is from right to left, so we use the reconstruction from cell $i+1$: $F_{i+1/2}^{conv} = a \\left(\\bar{u}_{i+1} - \\sigma_{i+1} \\frac{\\Delta x}{2}\\right)$.\n\nBy design, this upwind, limited scheme is total variation diminishing (TVD) for the pure advection case, which implies it is monotonicity-preserving and thus satisfies the DMP under a suitable CFL condition, typically $|a|\\Delta t/\\Delta x \\le 1/2$. To analyze the full advection-diffusion equation, consider the simpler first-order upwind scheme ($\\sigma_i=0$). For $a0$, the update is:\n$$\n\\bar{u}_i^{n+1} = \\bar{u}_i^n - \\frac{\\Delta t}{\\Delta x}\\left[ a\\bar{u}_i - \\nu\\frac{\\bar{u}_{i+1}-\\bar{u}_i}{\\Delta x} \\right] + \\frac{\\Delta t}{\\Delta x}\\left[ a\\bar{u}_{i-1} - \\nu\\frac{\\bar{u}_i-\\bar{u}_{i-1}}{\\Delta x} \\right]\n$$\n$$\n\\bar{u}_i^{n+1} = \\left(\\frac{\\nu\\Delta t}{\\Delta x^2}\\right)\\bar{u}_{i+1}^n + \\left(1 - \\frac{a\\Delta t}{\\Delta x} - \\frac{2\\nu\\Delta t}{\\Delta x^2}\\right)\\bar{u}_i^n + \\left(\\frac{a\\Delta t}{\\Delta x} + \\frac{\\nu\\Delta t}{\\Delta x^2}\\right)\\bar{u}_{i-1}^n\n$$\nFor this to be a convex combination, the coefficients must be non-negative. For $a0, \\nu0$, this reduces to a single condition on the coefficient of $\\bar{u}_i^n$:\n$$\n1 - \\frac{a\\Delta t}{\\Delta x} - \\frac{2\\nu\\Delta t}{\\Delta x^2} \\ge 0 \\implies \\Delta t \\left( \\frac{a}{\\Delta x} + \\frac{2\\nu}{\\Delta x^2} \\right) \\le 1\n$$\nThis condition ensures monotonicity for the first-order scheme without any restriction on the cell Peclet number $Pe_h$. The slope-limited second-order scheme behaves similarly; the limiter essentially reduces the scheme to first-order accuracy near sharp gradients or extrema to suppress oscillations, thereby preserving monotonicity, while providing higher accuracy in smooth regions. This is why the FV-upwind-limited scheme is expected to satisfy the DMP even at high $Pe_h$, remedying the failure of the FD-central scheme.", "answer": "```python\nimport numpy as np\n\ndef minmod(a, b):\n    \"\"\"Vectorized minmod function.\"\"\"\n    # Ensure inputs are numpy arrays for vectorized operations\n    a = np.asarray(a)\n    b = np.asarray(b)\n    # The sign check correctly handles the case where signs differ (result is 0)\n    # and where they are the same (result has the same sign).\n    return 0.5 * (np.sign(a) + np.sign(b)) * np.minimum(np.abs(a), np.abs(b))\n\ndef run_fd_central(N, a, nu, dt, T, ic_type, tau):\n    \"\"\"\n    Solves the 1D advection-diffusion equation using FD-central in space\n    and Forward Euler in time.\n    \"\"\"\n    dx = 1.0 / N\n    x = (np.arange(N) + 0.5) * dx\n\n    if ic_type == 'smooth':\n        u = 0.5 + 0.5 * np.sin(2 * np.pi * x)\n    elif ic_type == 'sharp':\n        u = np.zeros(N, dtype=np.float64)\n        mask = (x >= 0.4)  (x  0.6)\n        u[mask] = 1.0\n    else:\n        raise ValueError(\"Invalid initial condition type\")\n        \n    u = u.astype(np.float64)\n\n    u_min_0 = np.min(u)\n    u_max_0 = np.max(u)\n    \n    num_steps = int(round(T / dt))\n    \n    dmp_holds = True\n    for _ in range(num_steps):\n        u_plus_1 = np.roll(u, -1)\n        u_minus_1 = np.roll(u, 1)\n        \n        u_x = (u_plus_1 - u_minus_1) / (2.0 * dx)\n        u_xx = (u_plus_1 - 2.0 * u + u_minus_1) / (dx**2)\n        \n        u = u - dt * (a * u_x - nu * u_xx)\n        \n        if np.min(u)  u_min_0 - tau or np.max(u) > u_max_0 + tau:\n            dmp_holds = False\n            break\n            \n    return dmp_holds\n\ndef run_fv_upwind_limited(N, a, nu, dt, T, ic_type, tau):\n    \"\"\"\n    Solves the 1D advection-diffusion equation using a second-order TVD\n    finite volume scheme with a minmod limiter.\n    \"\"\"\n    dx = 1.0 / N\n    x = (np.arange(N) + 0.5) * dx\n\n    if ic_type == 'smooth':\n        u = 0.5 + 0.5 * np.sin(2 * np.pi * x)\n    elif ic_type == 'sharp':\n        u = np.zeros(N, dtype=np.float64)\n        mask = (x >= 0.4)  (x  0.6)\n        u[mask] = 1.0\n    else:\n        raise ValueError(\"Invalid initial condition type\")\n\n    u = u.astype(np.float64)\n\n    u_min_0 = np.min(u)\n    u_max_0 = np.max(u)\n\n    num_steps = int(round(T / dt))\n\n    dmp_holds = True\n    for _ in range(num_steps):\n        # Calculate slopes with minmod limiter\n        du_bwd = (u - np.roll(u, 1)) / dx\n        du_fwd = (np.roll(u, -1) - u) / dx\n        slopes = minmod(du_bwd, du_fwd)\n\n        # Reconstruct values at interfaces i+1/2\n        # u_L is the value from cell i at its right edge\n        u_L = u + slopes * dx / 2.0\n        # u_R is the value from cell i+1 at its left edge\n        u_R = np.roll(u, -1) - np.roll(slopes, -1) * dx / 2.0\n\n        # Convective flux (upwind)\n        # flux = a * u_upwind\n        # a>0: u_upwind = u_L. a0: u_upwind = u_R\n        flux_conv = (a + np.abs(a)) / 2.0 * u_L + (a - np.abs(a)) / 2.0 * u_R\n\n        # Diffusive flux (centered)\n        flux_diff = -nu * (np.roll(u, -1) - u) / dx\n        \n        # Total flux at interfaces i+1/2\n        total_flux = flux_conv + flux_diff\n        \n        # Update cell averages using flux differences\n        u = u - (dt / dx) * (total_flux - np.roll(total_flux, 1))\n\n        if np.min(u)  u_min_0 - tau or np.max(u) > u_max_0 + tau:\n            dmp_holds = False\n            break\n\n    return dmp_holds\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # DMP tolerance\n    tau = 1.0e-8\n\n    test_cases = [\n        # Case 1: happy path, smooth and diffusive\n        {'N': 100, 'a': 1.0, 'nu': 0.1, 'dt': 2.5e-4, 'T': 0.05, 'scheme': 'FD-central', 'ic_type': 'smooth'},\n        # Case 2: counterexample, high Pe_h with centered differences\n        {'N': 100, 'a': 5.0, 'nu': 1.0e-3, 'dt': 2.0e-4, 'T': 0.02, 'scheme': 'FD-central', 'ic_type': 'sharp'},\n        # Case 3: remedy with limiter at high Pe_h\n        {'N': 100, 'a': 5.0, 'nu': 1.0e-3, 'dt': 1.0e-3, 'T': 0.02, 'scheme': 'FV-upwind-limited', 'ic_type': 'sharp'},\n        # Case 4: borderline Pe_h with centered differences\n        {'N': 100, 'a': 1.0, 'nu': 1.0e-2, 'dt': 2.5e-3, 'T': 0.05, 'scheme': 'FD-central', 'ic_type': 'sharp'},\n    ]\n    \n    results = []\n    \n    for case in test_cases:\n        if case['scheme'] == 'FD-central':\n            result = run_fd_central(case['N'], case['a'], case['nu'], case['dt'], case['T'], case['ic_type'], tau)\n        elif case['scheme'] == 'FV-upwind-limited':\n            result = run_fv_upwind_limited(case['N'], case['a'], case['nu'], case['dt'], case['T'], case['ic_type'], tau)\n        else:\n            raise ValueError(f\"Unknown scheme: {case['scheme']}\")\n        results.append(str(result).lower())\n        \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3337479"}]}