{"hands_on_practices": [{"introduction": "The journey from physical laws to computational simulation begins with a robust mathematical formulation. This exercise focuses on deriving the weak (or variational) formulation of the Electrical Impedance Tomography (EIT) problem under the Complete Electrode Model (CEM) from first principles [@problem_id:3378174]. Mastering this derivation is crucial as it transforms the governing partial differential equations and complex boundary conditions into a single, elegant integral equation, which forms the direct basis for powerful numerical techniques like the Finite Element Method.", "problem": "Consider Electrical Impedance Tomography (EIT) with the Complete Electrode Model (CEM) on a bounded Lipschitz domain $\\Omega \\subset \\mathbb{R}^{d}$ with outer unit normal $\\boldsymbol{n}$ and $L \\geq 2$ disjoint electrodes $\\{E_{\\ell}\\}_{\\ell=1}^{L} \\subset \\partial \\Omega$. Let the conductivity be a symmetric, uniformly positive definite tensor field $\\sigma(\\boldsymbol{x}) \\in \\mathbb{R}^{d \\times d}$ that is bounded and measurable on $\\Omega$. The electric potential in the body is $u: \\Omega \\to \\mathbb{R}$ and the electrode potentials are $\\{U_{\\ell}\\}_{\\ell=1}^{L} \\subset \\mathbb{R}$, both unknown. The applied electrode currents are $\\{I_{\\ell}\\}_{\\ell=1}^{L} \\subset \\mathbb{R}$, which satisfy $\\sum_{\\ell=1}^{L} I_{\\ell} = 0$. Each electrode has a known contact impedance $z_{\\ell} > 0$. Assume the following fundamental laws and definitions:\n- Conservation of charge: $\\nabla \\cdot \\boldsymbol{J} = 0$ in $\\Omega$.\n- Ohm's law in the quasi-static regime: $\\boldsymbol{J} = -\\sigma \\nabla u$ in $\\Omega$.\n- On the insulating boundary $\\partial \\Omega \\setminus \\bigcup_{\\ell=1}^{L} E_{\\ell}$, no-flux condition: $\\boldsymbol{J} \\cdot \\boldsymbol{n} = 0$.\n- On each electrode $E_{\\ell}$, the contact impedance relation holds: $u + z_{\\ell} \\, \\boldsymbol{J} \\cdot \\boldsymbol{n} = U_{\\ell}$ pointwise almost everywhere on $E_{\\ell}$.\n- On each electrode $E_{\\ell}$, the net current constraint holds: $\\int_{E_{\\ell}} \\boldsymbol{J} \\cdot \\boldsymbol{n} \\, \\mathrm{d}s = I_{\\ell}$.\n- The electrode potentials are defined up to an additive constant; to fix the gauge, impose $\\sum_{\\ell=1}^{L} U_{\\ell} = 0$.\n\nStarting from these laws, derive the weak formulation by integrating by parts over $\\Omega$ and $\\partial \\Omega$, and by introducing test functions $v \\in H^{1}(\\Omega)$ and $V = (V_{1},\\dots,V_{L}) \\in \\mathbb{R}^{L}$ with $\\sum_{\\ell=1}^{L} V_{\\ell} = 0$ that enforce the current constraints. Clearly define the function spaces for the trial and test functions, and obtain a symmetric bilinear form and a linear functional that incorporate the contact impedance terms and electrode potentials. Then, specify a conforming mixed finite element discretization with:\n- A standard $H^{1}(\\Omega)$-conforming finite element space for $u$ spanned by nodal basis functions, and\n- A discrete electrode potential space of dimension $L$ subject to the zero-sum gauge constraint,\nso that the resulting linear system shows the block structure coupling the body potential degrees of freedom and the electrode potentials through boundary integral terms on the electrodes. Identify the entries of each block in terms of volume and electrode-boundary integrals involving $\\sigma$, $z_{\\ell}$, and the basis functions.\n\nFor grading, report only the final symmetric bilinear form $a\\big((u,U),(v,V)\\big)$ as a single closed-form expression. Do not include units. Do not round; provide the exact analytic form as your final answer.", "solution": "The problem statement describes the Complete Electrode Model (CEM) for Electrical Impedance Tomography (EIT) and asks for the derivation of its weak formulation, a description of its finite element discretization, and the resulting block structure of the linear system. The problem is scientifically sound, self-contained, and well-posed.\n\nWe begin with the strong form of the problem. The potential $u: \\Omega \\to \\mathbb{R}$ and the electrode potentials $U = (U_1, \\dots, U_L) \\in \\mathbb{R}^L$ satisfy:\n$$ \\nabla \\cdot (\\sigma \\nabla u) = 0 \\quad \\text{in } \\Omega $$\n$$ -\\sigma \\nabla u \\cdot \\boldsymbol{n} = 0 \\quad \\text{on } \\partial \\Omega \\setminus \\bigcup_{\\ell=1}^{L} E_{\\ell} $$\n$$ u - U_{\\ell} = -z_{\\ell} \\sigma \\nabla u \\cdot \\boldsymbol{n} \\quad \\text{on } E_{\\ell}, \\quad \\ell=1, \\dots, L $$\n$$ \\int_{E_{\\ell}} -\\sigma \\nabla u \\cdot \\boldsymbol{n} \\, \\mathrm{d}s = I_{\\ell}, \\quad \\ell=1, \\dots, L $$\n$$ \\sum_{\\ell=1}^{L} U_{\\ell} = 0 \\quad \\text{and} \\quad \\sum_{\\ell=1}^{L} I_{\\ell} = 0 $$\nwhere the current density is $\\boldsymbol{J} = -\\sigma \\nabla u$.\n\nTo derive the weak formulation, we first define the appropriate function spaces for the trial functions $(u, U)$ and test functions $(v, V)$. Both belong to the space $\\mathcal{X} = H^1(\\Omega) \\times \\mathbb{R}_0^L$, where $H^1(\\Omega)$ is the standard Sobolev space of functions with square-integrable first derivatives, and $\\mathbb{R}_0^L = \\{ W \\in \\mathbb{R}^L \\mid \\sum_{\\ell=1}^{L} W_{\\ell} = 0 \\}$ is the space of zero-sum vectors.\n\nThe weak formulation is to find $(u, U) \\in \\mathcal{X}$ a such that for all $(v, V) \\in \\mathcal{X}$:\n$$ a\\big((u,U),(v,V)\\big) = l(v,V) $$\nwhere $a(\\cdot, \\cdot)$ is a symmetric bilinear form and $l(\\cdot)$ is a linear functional. Based on the underlying physics of power dissipation, we propose the following forms:\nThe bilinear form is:\n$$ a\\big((u,U),(v,V)\\big) = \\int_{\\Omega} \\nabla v^T \\sigma \\nabla u \\, \\mathrm{d}x + \\sum_{\\ell=1}^L \\frac{1}{z_\\ell} \\int_{E_\\ell} (u-U_\\ell)(v-V_\\ell) \\, \\mathrm{d}s $$\nThe linear functional is:\n$$ l(v,V) = \\sum_{\\ell=1}^L V_\\ell I_\\ell $$\n\nWe must verify that this weak formulation is equivalent to the strong form. We do this by choosing two specific types of test functions.\n\nFirst, let the test potential vector be $V = \\mathbf{0}$. Then $v$ can be any function in $H^1(\\Omega)$. The variational equation becomes:\n$$ \\int_{\\Omega} \\nabla v^T \\sigma \\nabla u \\, \\mathrm{d}x + \\sum_{\\ell=1}^L \\frac{1}{z_\\ell} \\int_{E_\\ell} (u-U_\\ell)v \\, \\mathrm{d}s = 0 $$\nApplying Green's first identity to the first term gives:\n$$ -\\int_{\\Omega} v \\, \\nabla \\cdot (\\sigma \\nabla u) \\, \\mathrm{d}x + \\int_{\\partial \\Omega} v (\\sigma \\nabla u \\cdot \\boldsymbol{n}) \\, \\mathrm{d}s + \\sum_{\\ell=1}^L \\int_{E_\\ell} \\frac{v(u-U_\\ell)}{z_\\ell} \\, \\mathrm{d}s = 0 $$\nThis must hold for all $v \\in H^1(\\Omega)$. If we first choose $v \\in C_c^{\\infty}(\\Omega)$ (infinitely differentiable with compact support in $\\Omega$), the boundary integrals vanish, and we obtain $\\int_{\\Omega} v \\, \\nabla \\cdot (\\sigma \\nabla u) \\, \\mathrm{d}x = 0$, which implies $\\nabla \\cdot (\\sigma \\nabla u) = 0$ in $\\Omega$.\nWith this, the equation reduces to the boundary terms:\n$$ \\int_{\\partial \\Omega \\setminus \\cup E_\\ell} v (\\sigma \\nabla u \\cdot \\boldsymbol{n}) \\, \\mathrm{d}s + \\sum_{\\ell=1}^L \\int_{E_\\ell} v \\left(\\sigma \\nabla u \\cdot \\boldsymbol{n} + \\frac{u-U_\\ell}{z_\\ell}\\right) \\, \\mathrm{d}s = 0 $$\nFor arbitrary $v$, this implies that $\\sigma \\nabla u \\cdot \\boldsymbol{n} = 0$ on the insulating boundary $\\partial \\Omega \\setminus \\cup E_\\ell$, and $\\sigma \\nabla u \\cdot \\boldsymbol{n} + \\frac{u-U_\\ell}{z_\\ell} = 0$ on each electrode $E_\\ell$. The latter is equivalent to $u + z_\\ell(-\\sigma \\nabla u \\cdot \\boldsymbol{n}) = U_\\ell$.\n\nSecond, let the test function be $v=0$. Then $V$ can be any vector in $\\mathbb{R}_0^L$. The variational equation becomes:\n$$ \\sum_{\\ell=1}^L \\frac{1}{z_\\ell} \\int_{E_\\ell} (u-U_\\ell)(-V_\\ell) \\, \\mathrm{d}s = \\sum_{\\ell=1}^L V_\\ell I_\\ell $$\nRewriting this gives:\n$$ \\sum_{\\ell=1}^L V_\\ell \\left( \\int_{E_\\ell} \\frac{U_\\ell-u}{z_\\ell} \\, \\mathrm{d}s - I_\\ell \\right) = 0 $$\nThis must hold for all $V \\in \\mathbb{R}_0^L$. This implies that the vector with components $\\mathcal{L}_\\ell = \\int_{E_\\ell} \\frac{U_\\ell-u}{z_\\ell} \\, \\mathrm{d}s - I_\\ell$ is orthogonal to the subspace $\\mathbb{R}_0^L$. Therefore, this vector must be constant, i.e., $\\mathcal{L}_\\ell = C$ for all $\\ell=1, \\dots, L$. Summing over $\\ell$:\n$$ \\sum_{\\ell=1}^L C = \\sum_{\\ell=1}^L \\left( \\int_{E_\\ell} \\frac{U_\\ell-u}{z_\\ell} \\, \\mathrm{d}s - I_\\ell \\right) $$\n$$ LC = \\sum_{\\ell=1}^L \\int_{E_\\ell} (-\\sigma \\nabla u \\cdot \\boldsymbol{n}) \\, \\mathrm{d}s - \\sum_{\\ell=1}^L I_\\ell $$\nThe sum of currents $\\sum I_\\ell = 0$ is given. The total flux over the electrodes is $\\int_{\\cup E_\\ell} (-\\sigma \\nabla u \\cdot \\boldsymbol{n}) \\, \\mathrm{d}s = \\int_{\\partial \\Omega} (-\\sigma \\nabla u \\cdot \\boldsymbol{n}) \\, \\mathrm{d}s = \\int_\\Omega -\\nabla \\cdot(\\sigma \\nabla u)\\,dx = 0$. Thus, $LC=0$, and since $L \\geq 2$, we have $C=0$. This implies $\\mathcal{L}_\\ell=0$ for all $\\ell$, which is the net current constraint: $\\int_{E_\\ell} -\\sigma\\nabla u\\cdot\\boldsymbol{n} \\, \\mathrm{d}s=I_\\ell$.\nThe proposed weak formulation is therefore equivalent to the strong form.\n\nFor the finite element discretization, let $S_h \\subset H^1(\\Omega)$ be a standard continuous, piecewise polynomial (e.g., Lagrange) finite element space with nodal basis functions $\\{\\phi_i\\}_{i=1}^N$. The potential $u$ is approximated as $u_h(\\boldsymbol{x}) = \\sum_{j=1}^N u_j \\phi_j(\\boldsymbol{x})$. The electrode potentials $U$ are represented by a vector $\\boldsymbol{U} = (U_1, \\dots, U_L)^T \\in \\mathbb{R}^L$. The zero-sum constraint $\\sum_{\\ell=1}^L U_\\ell = 0$ is enforced by a Lagrange multiplier $\\lambda$. The discrete problem yields a linear system of equations for the coefficient vector $\\boldsymbol{u}=(u_1, ..., u_N)^T$, the potential vector $\\boldsymbol{U}$, and the multiplier $\\lambda$. The system has the following symmetric block structure:\n$$\n\\begin{pmatrix}\nA & B \\\\\nB^T & C\n\\end{pmatrix}\n\\begin{pmatrix}\n\\boldsymbol{u} \\\\\n\\boldsymbol{U}\n\\end{pmatrix}\n+\n\\begin{pmatrix}\n\\mathbf{0} \\\\\n\\mathbf{1}\n\\end{pmatrix}\n\\lambda\n=\n\\begin{pmatrix}\n\\mathbf{0} \\\\\n\\boldsymbol{I}\n\\end{pmatrix}\n$$\n$$ \\mathbf{1}^T \\boldsymbol{U} = 0 $$\nwhere $\\boldsymbol{I} = (I_1, \\dots, I_L)^T$ and $\\mathbf{1}=(1,\\dots,1)^T$. The entries of the matrices are defined by integrals involving the basis functions:\nThe block $A$ is an $N \\times N$ matrix:\n$$ A_{ij} = \\int_{\\Omega} \\nabla\\phi_i^T \\sigma \\nabla\\phi_j \\, \\mathrm{d}x + \\sum_{\\ell=1}^L \\frac{1}{z_\\ell}\\int_{E_\\ell}\\phi_i \\phi_j \\, \\mathrm{d}s $$\nThe block $B$ is an $N \\times L$ matrix coupling the body and electrode potentials:\n$$ B_{i\\ell} = -\\frac{1}{z_\\ell}\\int_{E_\\ell} \\phi_i \\, \\mathrm{d}s $$\nThe block $C$ is an $L \\times L$ diagonal matrix related to the electrode admittances:\n$$ C_{\\ell k} = \\delta_{\\ell k} \\frac{|E_\\ell|}{z_\\ell} $$\nwhere $|E_\\ell|$ is the measure (area or length) of electrode $E_\\ell$ and $\\delta_{\\ell k}$ is the Kronecker delta. This system can be solved for the unknowns $(\\boldsymbol{u}, \\boldsymbol{U}, \\lambda)$.", "answer": "$$\\boxed{\\int_{\\Omega} \\nabla v^T \\sigma \\nabla u \\, \\mathrm{d}x + \\sum_{\\ell=1}^{L} \\frac{1}{z_{\\ell}} \\int_{E_{\\ell}} (u - U_{\\ell})(v - V_{\\ell}) \\, \\mathrm{d}s}$$", "id": "3378174"}, {"introduction": "With the weak formulation established, the next step is to translate this continuous mathematical model into a discrete linear system that a computer can solve. This practice guides you through the process of assembling the global system matrix for the EIT forward problem using the Finite Element Method (FEM) [@problem_id:3378244]. By implementing the assembly of the stiffness matrix and the boundary terms related to the Complete Electrode Model (CEM), you will gain hands-on experience with the core computational engine behind any EIT imaging algorithm.", "problem": "You are asked to derive, implement, and test the assembly of the global stiffness matrix for the Complete Electrode Model (CEM) in Electrical Impedance Tomography (EIT), using piecewise-linear finite elements on a two-dimensional domain. Your derivation must begin from the variational form of the governing equations for the conductivity model and CEM boundary conditions, and proceed to explicit formulas for the element-level contributions. You must implement the algorithm in a runnable program that constructs the global matrix and verifies specific properties for selected test cases.\n\nThe physical model is as follows. Let $\\Omega \\subset \\mathbb{R}^2$ be a polygonal domain with boundary $\\partial \\Omega$. The electric potential is $u: \\Omega \\to \\mathbb{R}$, the conductivity is $\\sigma: \\Omega \\to \\mathbb{R}_+$ piecewise constant, and the system has $M$ electrodes $\\{E_m\\}_{m=1}^M$ on $\\partial \\Omega$, with electrode potentials $\\{U_m\\}_{m=1}^M$. The governing equation is the steady-state conduction equation\n$$\n\\nabla \\cdot (\\sigma \\nabla u) = 0 \\quad \\text{in } \\Omega,\n$$\nwith the Complete Electrode Model (CEM) boundary conditions on each electrode $E_m$,\n$$\nu + z_m \\, \\sigma \\, \\partial_n u = U_m \\quad \\text{on } E_m,\n$$\nand $\\sigma \\, \\partial_n u = 0$ on the remaining boundary $\\partial \\Omega \\setminus \\cup_m E_m$. Here, $z_m > 0$ denotes the contact impedance for $E_m$, and $\\partial_n u$ is the normal derivative. Conservation of current on electrodes implies the net current constraint\n$$\n\\int_{E_m} \\sigma \\, \\partial_n u \\, ds = I_m,\n$$\nwhich can be rewritten using the boundary condition as\n$$\n\\int_{E_m} z_m^{-1}\\,(U_m - u) \\, ds = I_m.\n$$\nIn the finite element method with piecewise-linear basis $\\{\\phi_i\\}_{i=1}^N$, the weak form leads to the block linear system for unknown nodal coefficients $u \\in \\mathbb{R}^N$ and electrode potentials $U \\in \\mathbb{R}^M$:\n$$\n\\begin{bmatrix}\nK + \\displaystyle\\sum_{m=1}^M M^{(m)} & -C \\\\\n-C^\\top & D\n\\end{bmatrix}\n\\begin{bmatrix}\nu \\\\\nU\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n0 \\\\\nI\n\\end{bmatrix},\n$$\nwhere\n$$\nK_{ij} = \\int_{\\Omega} \\sigma \\, \\nabla \\phi_i \\cdot \\nabla \\phi_j \\, d\\Omega,\n\\quad\nM^{(m)}_{ij} = \\int_{E_m} z_m^{-1}\\, \\phi_i \\phi_j \\, ds,\n\\quad\nC_{i m} = \\int_{E_m} z_m^{-1}\\, \\phi_i \\, ds,\n\\quad\nD_{m m} = \\int_{E_m} z_m^{-1} \\cdot 1 \\, ds = z_m^{-1} \\, |E_m|.\n$$\nThese formulas must be derived from first principles and implemented exactly. The global matrix is symmetric. Without a gauge fixing (for example, setting one electrode potential to a reference value), the block system has a one-dimensional nullspace corresponding to a uniform shift of the potentials, i.e., $u \\mapsto u + c$ and $U_m \\mapsto U_m + c$ for constant $c$.\n\nYour implementation must:\n- Build a uniform triangular mesh of the unit square $\\Omega = [0,1]\\times[0,1]$ using a structured grid with $n_x$ subdivisions in the $x$ direction and $n_y$ subdivisions in the $y$ direction, and split each rectangular cell into two triangles.\n- Assemble $K$ from triangle areas and gradients of basis functions by exact formulas for linear triangles.\n- Assemble the electrode boundary mass matrices $M^{(m)}$, the coupling matrix $C$, and the electrode diagonal $D$ from the boundary edge integrals using exact one-dimensional piecewise-linear quadrature on boundary segments.\n- Construct the global block matrix\n$$\nA = \\begin{bmatrix}\nK + \\sum_{m=1}^M M^{(m)} & -C \\\\\n-C^\\top & D\n\\end{bmatrix}.\n$$\n\nYou must test your implementation on the following set of parameter values (the test suite). Each test case specifies $(n_x,n_y)$, the number $M$ of electrodes, the electrode intervals along the bottom boundary $y=0$, and the piecewise constant conductivity $\\sigma(\\mathbf{x})$. The contact impedance $z_m$ has units of Ohm square-meter, written as $\\mathrm{\\Omega\\, m^2}$, while potentials $u$ and $U_m$ are in volts; however, all requested outputs below are dimensionless booleans or unitless floats.\n\n- Test case $1$ (general configuration):\n  - $n_x = 10$, $n_y = 8$.\n  - Conductivity $\\sigma(\\mathbf{x}) \\equiv 1$ (uniform).\n  - Electrodes on $y=0$: $E_1: x \\in [0.0, 0.3]$ with $z_1 = 0.05$ $\\mathrm{\\Omega\\, m^2}$; $E_2: x \\in [0.5, 0.9]$ with $z_2 = 0.1$ $\\mathrm{\\Omega\\, m^2}$.\n- Test case $2$ (heterogeneous conductivity and full-length electrode):\n  - $n_x = 6$, $n_y = 4$.\n  - Conductivity $\\sigma(\\mathbf{x}) = 1$ for $x < 0.5$, and $\\sigma(\\mathbf{x}) = 2$ for $x \\ge 0.5$.\n  - Single electrode on $y=0$: $E_1: x \\in [0.0, 1.0]$ with $z_1 = 0.2$ $\\mathrm{\\Omega\\, m^2}$.\n- Test case $3$ (edge case: short electrodes and contrasting impedances):\n  - $n_x = 5$, $n_y = 5$.\n  - Conductivity $\\sigma(\\mathbf{x}) \\equiv 1$ (uniform).\n  - Electrodes on $y=0$: $E_1: x \\in [0.0, 0.2]$ with $z_1 = 0.01$ $\\mathrm{\\Omega\\, m^2}$; $E_2: x \\in [0.8, 1.0]$ with $z_2 = 0.5$ $\\mathrm{\\Omega\\, m^2}$.\n\nFor each test case, your program must compute and report the following quantities:\n- A boolean indicating whether the assembled global matrix $A$ is symmetric (to numerical tolerance).\n- For each electrode $m$, the float ratio\n$$\nr_m = \\frac{D_{m m}}{z_m^{-1} \\, |E_m|},\n$$\nwhich should be close to $1$ if $D$ correctly encodes the $z_m^{-1}$ terms linking $u$ and $U_m$.\n- An integer giving the dimension of the numerically detected nullspace of $A$ (count of eigenvalues whose absolute value is below a relative threshold), expected to be $1$ in these configurations without gauge fixing.\n\nFinal output format:\n- Your program should produce a single line of output containing the concatenated results across the three test cases as a comma-separated list enclosed in square brackets. For example, for three test cases with outputs $[b_1, r^{(1)}_1, r^{(1)}_2, d_1]$, $[b_2, r^{(2)}_1, d_2]$, and $[b_3, r^{(3)}_1, r^{(3)}_2, d_3]$, your program should print\n$$\n[ b_1, r^{(1)}_1, r^{(1)}_2, d_1, b_2, r^{(2)}_1, d_2, b_3, r^{(3)}_1, r^{(3)}_2, d_3 ].\n$$\nAll booleans and floats must be standard Python primitives. All requested outputs are dimensionless.\n\nYour final answer must be a complete, runnable Python program that follows the Execution Environment specifications and produces the output in the exact format described above, with no additional text.", "solution": "The derivation of the block linear system begins with the weak formulation of the governing PDE and boundary conditions.\n\n**1. Weak Formulation**\nThe governing equation is $\\nabla \\cdot (\\sigma \\nabla u) = 0$. Multiplying by a test function $v \\in H^1(\\Omega)$ and integrating over the domain $\\Omega$, we apply Green's first identity:\n$$ \\int_{\\Omega} \\sigma \\nabla u \\cdot \\nabla v \\, d\\Omega = \\int_{\\partial \\Omega} v \\, (\\sigma \\, \\partial_n u) \\, ds $$\nThe boundary integral is split over the electrodes $\\{E_m\\}$ and the electrode-free gaps. On the gaps, $\\sigma \\, \\partial_n u = 0$. On each electrode $E_m$, the CEM boundary condition $u + z_m \\sigma \\partial_n u = U_m$ gives the normal current density as $\\sigma \\, \\partial_n u = z_m^{-1}(U_m - u)$. Substituting these into the boundary integral yields the weak form:\n$$ \\int_{\\Omega} \\sigma \\nabla u \\cdot \\nabla v \\, d\\Omega + \\sum_{m=1}^M \\int_{E_m} z_m^{-1} u v \\, ds = \\sum_{m=1}^M \\int_{E_m} z_m^{-1} U_m v \\, ds $$\nThis equation, along with the current conservation law for each electrode, forms the complete system.\n\n**2. Finite Element Discretization**\nWe approximate the potential $u$ using piecewise-linear basis functions $\\{\\phi_j\\}_{j=1}^N$: $u_h(x) = \\sum_{j=1}^N u_j \\phi_j(x)$. Using the Galerkin method, we set the test function $v$ to be each basis function $\\phi_i$ in turn. This leads to the first block row of the linear system:\n$$ (K + \\sum_{m=1}^M M^{(m)})\\mathbf{u} - C\\mathbf{U} = \\mathbf{0} $$\nwhere $\\mathbf{u}$ and $\\mathbf{U}$ are vectors of the nodal and electrode potentials, and the matrices are defined as in the problem statement.\n\nThe second block row comes from the current conservation law, $I_m = \\int_{E_m} z_m^{-1}(U_m - u) \\, ds$. Discretizing this gives, for each electrode $m$:\n$$ U_m \\left( \\int_{E_m} z_m^{-1} \\, ds \\right) - \\sum_{j=1}^N u_j \\left( \\int_{E_m} z_m^{-1} \\phi_j \\, ds \\right) = I_m $$\nThis corresponds to the second block row: $-C^\\top \\mathbf{u} + D\\mathbf{U} = \\mathbf{I}$. Combining these gives the full symmetric block system as described in the problem.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n\n    # Test case 1: general configuration\n    test1_electrodes = [\n        {'interval': (0.0, 0.3), 'z': 0.05},\n        {'interval': (0.5, 0.9), 'z': 0.1}\n    ]\n    def sigma1(x, y):\n        return 1.0\n\n    # Test case 2: heterogeneous conductivity and full-length electrode\n    test2_electrodes = [\n        {'interval': (0.0, 1.0), 'z': 0.2}\n    ]\n    def sigma2(x, y):\n        return 2.0 if x >= 0.5 else 1.0\n\n    # Test case 3: edge case: short electrodes and contrasting impedances\n    test3_electrodes = [\n        {'interval': (0.0, 0.2), 'z': 0.01},\n        {'interval': (0.8, 1.0), 'z': 0.5}\n    ]\n    def sigma3(x, y):\n        return 1.0\n        \n    test_cases = [\n        {'nx': 10, 'ny': 8, 'sigma_func': sigma1, 'electrodes': test1_electrodes},\n        {'nx': 6, 'ny': 4, 'sigma_func': sigma2, 'electrodes': test2_electrodes},\n        {'nx': 5, 'ny': 5, 'sigma_func': sigma3, 'electrodes': test3_electrodes},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        results = run_case(\n            case['nx'], case['ny'], case['sigma_func'], case['electrodes']\n        )\n        all_results.extend(results)\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, all_results))}]\")\n\n\ndef run_case(nx, ny, sigma_func, electrodes):\n    \"\"\"\n    Generates mesh, assembles matrices, and computes required validation quantities for a single test case.\n    \"\"\"\n    nodes, elements = generate_mesh(nx, ny)\n    num_nodes = len(nodes)\n    num_electrodes = len(electrodes)\n\n    K = np.zeros((num_nodes, num_nodes))\n    for elem_nodes_indices in elements:\n        p1_idx, p2_idx, p3_idx = elem_nodes_indices\n        p1, p2, p3 = nodes[p1_idx], nodes[p2_idx], nodes[p3_idx]\n        \n        # Element stiffness matrix K^e\n        area = 0.5 * abs(p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1]))\n        \n        # Gradients of basis functions\n        b = np.array([p2[1]-p3[1], p3[1]-p1[1], p1[1]-p2[1]]) / (2 * area)\n        c = np.array([p3[0]-p2[0], p1[0]-p3[0], p2[0]-p1[0]]) / (2 * area)\n\n        # Conductivity at element centroid\n        centroid = (p1 + p2 + p3) / 3.0\n        sigma = sigma_func(centroid[0], centroid[1])\n        \n        Ke = np.zeros((3, 3))\n        for i in range(3):\n            for j in range(3):\n                Ke[i, j] = sigma * (b[i]*b[j] + c[i]*c[j]) * area\n        \n        # Assemble into global K\n        for i in range(3):\n            for j in range(3):\n                K[elem_nodes_indices[i], elem_nodes_indices[j]] += Ke[i, j]\n\n    # Boundary matrix assembly\n    M_tot = np.zeros((num_nodes, num_nodes))\n    C = np.zeros((num_nodes, num_electrodes))\n    D = np.zeros((num_electrodes, num_electrodes))\n\n    for m, elec in enumerate(electrodes):\n        elec_start, elec_end = elec['interval']\n        z_inv = 1.0 / elec['z']\n        \n        # Iterate over boundary edges on y=0\n        for i in range(nx):\n            n1_idx, n2_idx = i, i + 1\n            x1, x2 = nodes[n1_idx][0], nodes[n2_idx][0]\n            \n            # Find intersection of edge [x1, x2] and electrode [elec_start, elec_end]\n            overlap_start = max(x1, elec_start)\n            overlap_end = min(x2, elec_end)\n\n            if overlap_start < overlap_end:\n                # Integrate basis functions over the overlap interval [a, b]\n                a, b = overlap_start, overlap_end\n                h = x2 - x1\n                \n                # Polynomials for basis functions and their products\n                # psi1(x) = (x2-x)/h\n                psi1_coeffs = [x2/h, -1/h]\n                # psi2(x) = (x-x1)/h\n                psi2_coeffs = [-x1/h, 1/h]\n                # psi1^2(x) = ((x2-x)/h)^2\n                psi1_sq_coeffs = [x2**2/h**2, -2*x2/h**2, 1/h**2]\n                # psi2^2(x) = ((x-x1)/h)^2\n                psi2_sq_coeffs = [x1**2/h**2, -2*x1/h**2, 1/h**2]\n                # psi1*psi2(x) = (x2-x)(x-x1)/h^2\n                psi12_coeffs = [-x1*x2/h**2, (x1+x2)/h**2, -1/h**2]\n                \n                I1 = poly_integrate_definite(psi1_coeffs, a, b)\n                I2 = poly_integrate_definite(psi2_coeffs, a, b)\n                I11 = poly_integrate_definite(psi1_sq_coeffs, a, b)\n                I22 = poly_integrate_definite(psi2_sq_coeffs, a, b)\n                I12 = poly_integrate_definite(psi12_coeffs, a, b)\n                \n                # Add to C\n                C[n1_idx, m] += z_inv * I1\n                C[n2_idx, m] += z_inv * I2\n\n                # Add to M_tot\n                M_tot[n1_idx, n1_idx] += z_inv * I11\n                M_tot[n2_idx, n2_idx] += z_inv * I22\n                M_tot[n1_idx, n2_idx] += z_inv * I12\n                M_tot[n2_idx, n1_idx] += z_inv * I12\n        \n        # Diagonal D matrix entry\n        D[m, m] = z_inv * (elec_end - elec_start)\n\n    # Construct global block matrix A\n    A = np.block([\n        [K + M_tot, -C],\n        [-C.T, D]\n    ])\n\n    # Perform analysis\n    # 1. Symmetry check\n    is_symmetric = bool(np.allclose(A, A.T, atol=1e-12))\n    \n    # 2. Ratio check for D\n    ratios = []\n    for m, elec in enumerate(electrodes):\n        elec_start, elec_end = elec['interval']\n        elec_len = elec_end - elec_start\n        z_inv = 1.0 / elec['z']\n        \n        Dmm_val = D[m,m]\n        ratio = Dmm_val / (z_inv * elec_len) if elec_len > 0 else 1.0\n        ratios.append(ratio)\n\n    # 3. Nullspace dimension\n    eigvals = np.linalg.eigvalsh(A)\n    max_abs_eig = np.max(np.abs(eigvals)) if eigvals.size > 0 else 0\n    if max_abs_eig < 1e-15:\n        null_dim = A.shape[0]\n    else:\n        # Relative tolerance as suggested\n        tol = 1e-10 * max_abs_eig\n        null_dim = int(np.sum(np.abs(eigvals) < tol))\n        \n    return [is_symmetric, *ratios, null_dim]\n\ndef generate_mesh(nx, ny):\n    \"\"\"\n    Generates a structured triangular mesh on the unit square [0,1]x[0,1].\n    \"\"\"\n    x = np.linspace(0, 1, nx + 1)\n    y = np.linspace(0, 1, ny + 1)\n    nodes = np.array([[xi, yi] for yi in y for xi in x])\n    \n    elements = []\n    for j in range(ny):\n        for i in range(nx):\n            p00 = j * (nx + 1) + i\n            p10 = j * (nx + 1) + (i + 1)\n            p01 = (j + 1) * (nx + 1) + i\n            p11 = (j + 1) * (nx + 1) + (i + 1)\n            # Split quad into two triangles\n            elements.append([p00, p10, p11])\n            elements.append([p00, p11, p01])\n            \n    return nodes, np.array(elements)\n\n\ndef poly_integrate_definite(coeffs, a, b):\n    \"\"\"\n    Computes the definite integral of a polynomial from a to b.\n    Polynomial is given by coeffs p(x) = c0 + c1*x + c2*x^2 + ...\n    \"\"\"\n    if not coeffs:\n        return 0.0\n    \n    # Indefinite integral coeffs = [0, c0, c1/2, c2/3, ...]\n    indef_coeffs = [0.0] * (len(coeffs) + 1)\n    for i, c in enumerate(coeffs):\n        indef_coeffs[i+1] = c / (i + 1)\n    \n    def poly_eval(p_coeffs, x):\n        res = 0.0\n        # Horner's method\n        for c in reversed(p_coeffs):\n            res = res * x + c\n        return res\n\n    return poly_eval(indef_coeffs, b) - poly_eval(indef_coeffs, a)\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3378244"}, {"introduction": "Effective image reconstruction in EIT and DOT relies on algorithms that iteratively update an estimate of the internal properties, guided by the sensitivity of the measurements to changes in those properties. This sensitivity is encapsulated in the Jacobian matrix. This exercise introduces the Taylor remainder test, a fundamental technique for verifying the correctness of your Jacobian implementation [@problem_id:3378201]. This practice is indispensable for developing reliable and convergent inversion algorithms, as an incorrect Jacobian is a common and difficult-to-diagnose source of error.", "problem": "Consider the steady-state Diffuse Optical Tomography (DOT) model in the diffusion approximation on the unit square domain with homogeneous Dirichlet boundary condition. The governing partial differential equation is the scalar elliptic diffusion problem\n$$\n- \\nabla \\cdot \\left( D \\nabla u \\right) + \\mu_a(\\mathbf{r}) \\, u(\\mathbf{r}) = q(\\mathbf{r}) \\quad \\text{in } \\Omega = (0,1)^2, \\quad u|_{\\partial \\Omega} = 0,\n$$\nwhere $D$ is a constant diffusion coefficient, $\\mu_a(\\mathbf{r})$ is the spatially varying absorption coefficient, $u$ is the photon fluence (dimensionless), and $q$ is a source term. All quantities are dimensionless.\n\nWe use a finite-difference discretization on a uniform Cartesian grid with $N$ nodes per side and homogeneous Dirichlet boundary enforced at the boundary nodes. Let the interior grid have $(N-2)^2$ nodes. Let $L \\in \\mathbb{R}^{n \\times n}$ denote the standard $5$-point finite-difference discrete Laplacian on the interior with grid spacing $h = 1/(N-1)$, so that $L$ is symmetric positive definite (for the Dirichlet case). Let $D = 1$ be the constant diffusion coefficient. Let $x \\in \\mathbb{R}^K$ be a low-dimensional parameter vector that parameterizes the absorption field by piecewise-constant patches:\n$$\n\\mu = B x \\in \\mathbb{R}^n,\n$$\nwhere $B \\in \\mathbb{R}^{n \\times K}$ is a binary assignment matrix that maps each interior node to exactly one of $K$ disjoint patches. In this problem, take $K=4$ corresponding to the four quadrants of the interior grid.\n\nFor any $x \\in \\mathbb{R}^4$, define the discrete forward operator\n$$\nA(x) = D L + \\mathrm{diag}(B x) \\in \\mathbb{R}^{n \\times n},\n$$\nand the discrete fluence $u(x) \\in \\mathbb{R}^n$ solves\n$$\nA(x) \\, u(x) = q,\n$$\nwhere $q \\in \\mathbb{R}^n$ is a fixed point source at the interior node closest to the center of the domain. Define a linear measurement operator $M \\in \\mathbb{R}^{m \\times n}$ that extracts the values of $u$ at a prescribed set of interior nodes near the boundary (representing boundary-adjacent detectors). The parameter-to-data map is then\n$$\nF(x) = M \\, u(x) = M \\, A(x)^{-1} \\, q \\in \\mathbb{R}^m.\n$$\n\nYou will verify the first-order Taylor remainder test for the computed Jacobian of $F$ at various base points $x$ and perturbation directions $h \\in \\mathbb{R}^4$. For small perturbations $h$, the Taylor remainder ratio\n$$\nR(h) \\equiv \\frac{\\|F(x+h) - F(x) - J(x) h\\|_2}{\\|h\\|_2}\n$$\nshould decay linearly with $\\|h\\|_2$, where $J(x) \\in \\mathbb{R}^{m \\times 4}$ is the Jacobian of $F$ at $x$. The Jacobian-vector product can be evaluated without forming $J(x)$ explicitly using the identity\n$$\nJ(x) h \\;=\\; - M \\, A(x)^{-1} \\left( \\mathrm{diag}(B h) \\, u(x) \\right),\n$$\nwhich follows from differentiating $F(x) = M A(x)^{-1} q$ and the identity $\\mathrm{d}A^{-1} = -A^{-1} (\\mathrm{d}A) A^{-1}$.\n\nImplement the following numerical experiment to validate the linear decay of $R(t h)$ as a function of $\\|t h\\|_2$, with $t > 0$:\n\n- Discretization and operators:\n  - Use $N = 20$ nodes per side, so $n = (N-2)^2 = 324$ interior nodes. Use the standard $5$-point stencil Laplacian $L$ with grid spacing $h = 1/(N-1)$ and Dirichlet boundary values set to zero outside the interior.\n  - Use $D = 1$.\n  - Define four patches (quadrants) over the interior grid to build $B \\in \\mathbb{R}^{n \\times 4}$. Each interior node belongs to exactly one quadrant according to whether its interior indices are in the lower-left, lower-right, upper-left, or upper-right half of the interior grid.\n  - Define the source $q \\in \\mathbb{R}^n$ as a unit point source at the interior node closest to the center of the domain.\n  - Define measurement operator $M$ as a row-selector that extracts values of $u$ at a set of interior nodes near the boundary:\n    - Sensor set $\\mathcal{S}_1$: choose the interior row adjacent to the top boundary and columns $\\{2,6,10,14,17\\}$ (in interior indexing).\n    - Sensor set $\\mathcal{S}_2$: choose the interior column adjacent to the left boundary and rows $\\{2,6,10,14,17\\}$ (in interior indexing).\n    - Sensor set $\\mathcal{S}_3$: choose the interior row adjacent to the bottom boundary and columns $\\{3,7,11,15\\}$ (in interior indexing).\n  In each case, $M$ picks those nodes from $u$.\n\n- For each test case below, estimate the empirical convergence rate $\\hat{p}$ by least-squares fitting a line to the points $\\{(\\log \\|t h\\|_2, \\log R(t h))\\}$ over a geometric sequence of step sizes. Use step sizes $t_k = 10^{-1} \\cdot 2^{-k}$ for $k \\in \\{0,1,2,3,4,5\\}$. Compute $R(t_k h)$ using the exact forward solve for $F(x+t_k h)$ and the Jacobian-vector product formula given above.\n\n- Acceptance criterion: For each test case, return a boolean indicating whether the estimated slope $\\hat{p}$ satisfies $|\\hat{p} - 1| \\le 0.1$.\n\nAll quantities are dimensionless. The test suite comprises three cases:\n\n- Case A (uniform background, top sensors):\n  - Base parameter $x_A = [\\,0.02,\\, 0.02,\\, 0.02,\\, 0.02\\,]^{\\top}$.\n  - Direction $h_A = [\\,0.01,\\,-0.015,\\,0.02,\\,-0.005\\,]^{\\top}$.\n  - Measurement set $\\mathcal{S}_1$.\n\n- Case B (nonuniform background, left sensors):\n  - Base parameter $x_B = [\\,0.04,\\, 0.02,\\, 0.03,\\, 0.01\\,]^{\\top}$.\n  - Direction $h_B = [\\,-0.008,\\,0.012,\\,-0.006,\\,0.004\\,]^{\\top}$.\n  - Measurement set $\\mathcal{S}_2$.\n\n- Case C (low absorption, bottom sensors):\n  - Base parameter $x_C = [\\,0.005,\\, 0.005,\\, 0.005,\\, 0.005\\,]^{\\top}$.\n  - Direction $h_C = [\\,-0.002,\\,0.001,\\,-0.001,\\,0.001\\,]^{\\top}$.\n  - Measurement set $\\mathcal{S}_3$.\n\nYour program must construct $L$, $B$, $q$, and the specified measurement operators $M$, implement $F(x)$, implement the Jacobian-vector product $J(x) h$ via a single linear solve with $A(x)$ for each $h$, and compute the ratios $R(t_k h)$ and the estimated slope $\\hat{p}$ for each case as specified.\n\nFinal output format requirement: Your program should produce a single line of output containing a list with three booleans corresponding to Cases A, B, and C, respectively, indicating whether each case passes the acceptance criterion. The line must be formatted exactly as a Python-style list with boolean literals, for example, \"[True,False,True]\".", "solution": "The problem asks for a verification of the Jacobian implementation for a parameter-to-observation map in a Diffuse Optical Tomography (DOT) model using a first-order Taylor remainder test.\n\n### 1. Discretization of the Governing Equation\n\nThe physical model is the steady-state diffusion equation on the unit square $\\Omega = (0,1)^2$:\n$$\n- \\nabla \\cdot \\left( D \\nabla u \\right) + \\mu_a(\\mathbf{r}) \\, u(\\mathbf{r}) = q(\\mathbf{r}) \\quad \\text{in } \\Omega,\n$$\nwith homogeneous Dirichlet boundary conditions $u|_{\\partial \\Omega} = 0$. The diffusion coefficient is constant, $D=1$.\n\nWe discretize this PDE using a finite-difference method on a uniform $N \\times N$ grid, with $N=20$. This results in an interior grid of $(N-2) \\times (N-2) = 18 \\times 18$ nodes, for a total of $n = 324$ interior degrees of freedom. The grid spacing is $h = 1/(N-1) = 1/19$.\n\nThe term $-D \\nabla^2 u$ is approximated using the standard 5-point stencil, leading to a discrete operator matrix $L \\in \\mathbb{R}^{n \\times n}$ corresponding to the negative Laplacian, scaled by $D/h^2$. The absorption term $\\mu_a(\\mathbf{r}) u(\\mathbf{r})$ is parameterized by a vector $x \\in \\mathbb{R}^4$, where the absorption field $\\mu_a$ is piecewise constant over four quadrants. This is expressed as $\\mu = Bx$, where $B \\in \\mathbb{R}^{n \\times 4}$ is a binary assignment matrix.\n\nThe discrete PDE becomes a linear system:\n$$\n(L + \\mathrm{diag}(Bx)) u = q \\quad \\implies \\quad A(x) u(x) = q,\n$$\nwhere $u \\in \\mathbb{R}^n$ is the vector of fluence values at interior nodes, $q \\in \\mathbb{R}^n$ is the discrete source vector, and $A(x) = L + \\mathrm{diag}(Bx)$ is the system matrix. Since $L$ is symmetric positive definite (SPD) and $\\mu_a \\ge 0$, $A(x)$ is also SPD and thus invertible.\n\n### 2. Forward Model and Jacobian-Vector Product\n\nThe parameter-to-observation map $F(x)$ gives the simulated measurements for a given parameter vector $x$:\n$$\nF(x) = M u(x) = M A(x)^{-1} q,\n$$\nwhere $M \\in \\mathbb{R}^{m \\times n}$ is a measurement operator that selects the fluence values at $m$ sensor locations.\n\nThe action of the Jacobian of $F(x)$ on a perturbation vector $h \\in \\mathbb{R}^4$, denoted $J(x)h$, is found by differentiating $F(x)$ with respect to $x$ in the direction $h$. Using the identity for the derivative of a matrix inverse, $\\mathrm{d}(A^{-1}) = -A^{-1}(\\mathrm{d}A)A^{-1}$, we get:\n$$\nJ(x)h = -M A(x)^{-1} \\left( \\mathrm{diag}(Bh) \\, u(x) \\right).\n$$\nThis formula avoids explicit formation of the Jacobian matrix and requires two linear solves with $A(x)$: one to find the forward field $u(x)$, and another to apply $A(x)^{-1}$ to the vector produced by the perturbation.\n\n### 3. The Taylor Remainder Test\n\nThe first-order Taylor expansion of $F(x)$ is $F(x+h) = F(x) + J(x)h + \\mathcal{O}(\\|h\\|^2)$. To verify the Jacobian, we test if the remainder term scales as expected. The remainder ratio is:\n$$\nR(h) = \\frac{\\| F(x+h) - F(x) - J(x)h \\|_2}{\\|h\\|_2}.\n$$\nTheoretically, $R(h)$ should converge linearly to zero as $\\|h\\|_2 \\to 0$, which implies that a plot of $\\log(R(h))$ versus $\\log(\\|h\\|_2)$ should be a straight line with a slope of 1. The numerical experiment estimates this slope $\\hat{p}$ from a series of computations with decreasing step sizes and verifies that it is close to 1.", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import diags, csc_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Solves the DOT Jacobian verification problem.\n    \"\"\"\n    \n    # 1. Discretization and operator setup\n    N = 20\n    N_int = N - 2\n    n = N_int**2\n    h_grid = 1 / (N - 1)\n    D = 1.0\n\n    # Create the discrete negative Laplacian L corresponding to -D*nabla^2\n    # with 5-point stencil (4 on diag, -1 on off-diags), scaled by D/h^2\n    main_diag = np.full(n, 4.0)\n    side_diag = np.full(n - 1, -1.0)\n    # Periodicity for side_diag (jumps at end of rows)\n    side_diag[N_int-1::N_int] = 0\n    up_down_diag = np.full(n - N_int, -1.0)\n    \n    diagonals = [up_down_diag, side_diag, main_diag, side_diag, up_down_diag]\n    offsets = [-N_int, -1, 0, 1, N_int]\n    \n    L = (D / h_grid**2) * diags(diagonals, offsets, shape=(n, n), format='csc')\n\n    # Create the patch assignment matrix B\n    K = 4\n    B = np.zeros((n, K))\n    half_grid = N_int // 2\n    for i in range(N_int):\n        for j in range(N_int):\n            k = i * N_int + j\n            if i < half_grid and j < half_grid: # Lower-left\n                B[k, 0] = 1\n            elif i < half_grid and j >= half_grid: # Lower-right\n                B[k, 1] = 1\n            elif i >= half_grid and j < half_grid: # Upper-left\n                B[k, 2] = 1\n            else: # Upper-right\n                B[k, 3] = 1\n\n    # Create the source vector q\n    # Tie-break for the central node by picking the one with smallest indices\n    center_idx_i = half_grid - 1\n    center_idx_j = half_grid - 1\n    q_idx = center_idx_i * N_int + center_idx_j\n    q = np.zeros(n)\n    q[q_idx] = 1.0\n    q = csc_matrix(q).T # Use sparse column vector for spsolve\n\n    # Define sensor sets (1D indices)\n    # Interior indices are 0-based\n    # S1: top row (i=17), cols {2,6,10,14,17}\n    M1_indices = [17 * N_int + c for c in [2, 6, 10, 14, 17]]\n    # S2: left col (j=0), rows {2,6,10,14,17}\n    M2_indices = [r * N_int + 0 for r in [2, 6, 10, 14, 17]]\n    # S3: bottom row (i=0), cols {3,7,11,15}\n    M3_indices = [0 * N_int + c for c in [3, 7, 11, 15]]\n\n    # 2. Test case execution logic\n    def run_test_case(x_base, h_dir, M_indices):\n        \"\"\"\n        Performs the Taylor remainder test for a single case.\n        \"\"\"\n        \n        # Helper to construct A(x)\n        def get_A(x):\n            mu_vec = B @ x\n            return L + diags(mu_vec, 0, shape=(n, n), format='csc')\n\n        # Compute base quantities\n        A_base = get_A(x_base)\n        u_base = spsolve(A_base, q)\n        F_base = u_base[M_indices]\n        \n        # Compute Jacobian-vector product J(x_base) @ h_dir\n        # J(x)h = -M A(x)^{-1} (diag(B h) u(x))\n        bh_dir = B @ h_dir\n        w = bh_dir * u_base\n        v = spsolve(A_base, w)\n        Jvh_base = -v[M_indices]\n\n        log_h_norms = []\n        log_R_values = []\n        \n        for k in range(6):\n            t_k = 1e-1 * (2.0**(-k))\n            h_k = t_k * h_dir\n\n            # Compute F(x + h)\n            A_pert = get_A(x_base + h_k)\n            u_pert = spsolve(A_pert, q)\n            F_pert = u_pert[M_indices]\n            \n            # Jacobian-vector product for h_k: J(x_base) @ h_k = t_k * (J(x_base) @ h_dir)\n            Jvh_k = t_k * Jvh_base\n\n            # Compute Taylor remainder ratio R(h_k)\n            num_norm = np.linalg.norm(F_pert - F_base - Jvh_k)\n            den_norm = np.linalg.norm(h_k)\n            \n            if den_norm > 0 and num_norm > 0:\n                R_k = num_norm / den_norm\n                log_h_norms.append(np.log(den_norm))\n                log_R_values.append(np.log(R_k))\n\n        # Perform linear regression to find the convergence rate p_hat\n        if len(log_h_norms) < 2:\n            return False\n\n        p_hat, _ = np.polyfit(log_h_norms, log_R_values, 1)\n\n        return abs(p_hat - 1.0) <= 0.1\n\n    # 3. Define and run test cases\n    test_cases = [\n        # Case A\n        {'x': np.array([0.02, 0.02, 0.02, 0.02]),\n         'h': np.array([0.01, -0.015, 0.02, -0.005]),\n         'M': M1_indices},\n        # Case B\n        {'x': np.array([0.04, 0.02, 0.03, 0.01]),\n         'h': np.array([-0.008, 0.012, -0.006, 0.004]),\n         'M': M2_indices},\n        # Case C\n        {'x': np.array([0.005, 0.005, 0.005, 0.005]),\n         'h': np.array([-0.002, 0.001, -0.001, 0.001]),\n         'M': M3_indices}\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_test_case(case['x'], case['h'], case['M'])\n        results.append(result)\n\n    # Final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3378201"}]}