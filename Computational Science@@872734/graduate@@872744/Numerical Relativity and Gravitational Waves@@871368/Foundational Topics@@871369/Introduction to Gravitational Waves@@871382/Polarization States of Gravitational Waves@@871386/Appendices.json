{"hands_on_practices": [{"introduction": "To analyze the rich information encoded in gravitational waves, we need a robust way to characterize their polarization state. The Stokes parameters, analogous to those in optics, provide a complete description. This first exercise [@problem_id:3483111] is a foundational practice in which you will implement the calculation of instantaneous Stokes parameters from the raw strain data, $h_{+}(t)$ and $h_{\\times}(t)$. By testing your implementation against basis rotations, you will gain hands-on experience with the spin-2 nature of gravity and verify the key polarization invariants that are crucial for any physical interpretation of the signal.", "problem": "A transversely propagating weak gravitational wave in the linearized, transverse-traceless gauge is described by two real strain components, the plus polarization $h_{+}(t)$ and the cross polarization $h_{\\times}(t)$. In the narrowband approximation, polarization can be characterized by a polarization coherency matrix constructed from complex analytic representations of $h_{+}(t)$ and $h_{\\times}(t)$. From this coherency matrix, one defines four real-valued polarization Stokes parameters $(I,Q,U,V)$ that quantify total intensity, linear polarization components, and circular polarization for the wave. A rotation of the polarization basis by a physical angle $\\psi(t)$ about the propagation axis induces a transformation of the real strain components by twice the angle due to the spin-$2$ character of gravitational waves. Robust polarization characterization requires that the invariants of this transformation are respected: the total intensity and circular polarization should be basis-invariant, while linear polarization components should rotate among themselves without changing their magnitude.\n\nStarting from these foundations:\n- $h_{+}(t)$ and $h_{\\times}(t)$ are real-valued strains measured at a single detector in the transverse-traceless gauge.\n- The complex analytic signal $a(t)$ associated with a real signal $x(t)$ is defined by $a(t) = x(t) + i\\,\\mathcal{H}\\{x(t)\\}$, where $\\mathcal{H}\\{\\cdot\\}$ denotes the Hilbert transform.\n- The polarization coherency matrix is constructed from the analytic signals associated with $h_{+}(t)$ and $h_{\\times}(t)$.\n- Under a rotation by angle $\\psi(t)$ (in radians), the physical polarization axes rotate by $2\\psi(t)$ affecting $(h_{+},h_{\\times})$ as a two-component field.\n\nImplement a program that performs the following tasks in a scientifically self-consistent way:\n\n1. For each provided test case, construct time series $h_{+}(t)$ and $h_{\\times}(t)$ sampled at a rate of $f_{\\mathrm{s}} = $ $4096$ samples per second over a duration $T = $ $1$ second, i.e., $t = 0, 1/f_{\\mathrm{s}}, 2/f_{\\mathrm{s}}, \\dots, T-1/f_{\\mathrm{s}}$. Angles must be treated in radians throughout.\n\n2. Compute the complex analytic signals $a_{+}(t)$ and $a_{\\times}(t)$ associated with $h_{+}(t)$ and $h_{\\times}(t)$, construct the polarization coherency matrix, and from it compute time series of Stokes parameters $(I(t), Q(t), U(t), V(t))$.\n\n3. Rotate the polarization basis by a specified time-dependent angle $\\psi(t)$ by transforming the real strains using a rotation by $2\\psi(t)$, recompute the analytic signals and the Stokes parameters $(I'(t), Q'(t), U'(t), V'(t))$ in the rotated basis.\n\n4. Quantify robustness under precession and mode-mixing by computing the following dimensionless error metrics for each test case:\n   - $e_{I} = \\displaystyle \\frac{\\max_{t} \\left| I(t) - I'(t) \\right|}{\\max_{t} \\left| I(t) \\right| + \\epsilon}$,\n   - $e_{V} = \\displaystyle \\frac{\\max_{t} \\left| V(t) - V'(t) \\right|}{\\max_{t} \\left| V(t) \\right| + \\epsilon}$,\n   - $e_{L} = \\displaystyle \\frac{\\max_{t} \\left| \\sqrt{Q(t)^{2} + U(t)^{2}} - \\sqrt{Q'(t)^{2} + U'(t)^{2}} \\right|}{\\max_{t} \\left( \\sqrt{Q(t)^{2} + U(t)^{2}} \\right) + \\epsilon}$,\n   where $\\epsilon = $ $10^{-30}$ is a small positive constant to avoid division by zero. These metrics are designed to test invariance of intensity and circular polarization under basis rotations and invariance of the magnitude of linear polarization under rotations that mix $Q$ and $U$. All outputs are dimensionless real numbers.\n\n5. Use the following scientifically plausible test suite, which is designed to probe a happy path case, a boundary case, and an edge case with mode mixing:\n   - Test case $1$ (happy path, slowly varying precession, near-circular polarization):\n     - Amplitude $A = $ $10^{-21}$,\n     - Frequency $f = $ $150$ Hertz,\n     - $h_{+}(t) = A \\cos(2\\pi f t)$,\n     - $h_{\\times}(t) = A \\sin(2\\pi f t)$,\n     - Precession angle $\\psi(t) = 0.5 \\sin(2\\pi \\cdot 1 \\cdot t)$ radians.\n   - Test case $2$ (boundary case, linear polarization):\n     - Amplitude $A = $ $10^{-21}$,\n     - Frequency $f = $ $100$ Hertz,\n     - $h_{+}(t) = A \\cos(2\\pi f t)$,\n     - $h_{\\times}(t) = 0$,\n     - Rotation angle $\\psi(t) = 0.25\\, t$ radians.\n   - Test case $3$ (edge case, mode-mixing and faster precession):\n     - Base amplitude $A = $ $10^{-21}$,\n     - Frequencies $f_{1} = $ $90$ Hertz and $f_{2} = $ $130$ Hertz,\n     - Amplitudes $A_{1} = A$, $A_{2} = 0.6 A$, $B_{1} = 0.8 A$,\n     - Phases $\\phi_{2} = $ $0.3$ radians and $\\phi_{\\times} = -0.2$ radians,\n     - $h_{+}(t) = A_{1} \\cos(2\\pi f_{1} t) + A_{2} \\cos(2\\pi f_{2} t + \\phi_{2})$,\n     - $h_{\\times}(t) = B_{1} \\sin(2\\pi f_{1} t + \\phi_{\\times})$,\n     - Precession angle $\\psi(t) = 0.8 \\sin(2\\pi \\cdot 3 \\cdot t)$ radians.\n\nYour program should produce a single line of output containing the results for the three test cases as a comma-separated list enclosed in square brackets, in the order $[e_{I}^{(1)}, e_{V}^{(1)}, e_{L}^{(1)}, e_{I}^{(2)}, e_{V}^{(2)}, e_{L}^{(2)}, e_{I}^{(3)}, e_{V}^{(3)}, e_{L}^{(3)}]$, where superscripts denote the test case number. All outputs must be expressed as dimensionless floats. Angles must be treated in radians and time in seconds. No external input is allowed; the test suite is fixed as above and must be embedded in the program.", "solution": "The problem statement has been evaluated and is determined to be valid. It is scientifically grounded in the principles of general relativity and gravitational wave data analysis, well-posed with a complete and consistent set of definitions and parameters, and objective in its formulation. We may therefore proceed with the solution.\n\nThe core of this problem is to verify the transformation properties of the gravitational wave Stokes parameters under a rotation of the polarization basis. The Stokes parameters $(I, Q, U, V)$ provide a complete description of the polarization state of a transverse wave. For a spin-$2$ field like a gravitational wave, certain quantities constructed from these parameters must be invariant under a physical rotation of the detector frame by an angle $\\psi(t)$. Specifically, the total intensity $I(t)$ and the net circular polarization $V(t)$ must be scalars and therefore invariant. The linear polarization components, $Q(t)$ and $U(t)$, form a vector in a conceptual \"polarization plane\" and are expected to rotate amongst themselves, but the magnitude of this linear polarization vector, $L(t) = \\sqrt{Q(t)^2 + U(t)^2}$, must be invariant.\n\nThe solution framework involves the following sequence of steps for each test case:\n1.  Discretize the continuous time variable $t$.\n2.  Generate the time series for the plus, $h_+(t)$, and cross, $h_\\times(t)$, polarizations.\n3.  Compute the associated complex analytic signals, $a_+(t)$ and $a_\\times(t)$.\n4.  Calculate the initial set of Stokes parameters $(I(t), Q(t), U(t), V(t))$.\n5.  Apply the specified time-dependent rotation to the strain components to obtain the rotated strains, $h'_+(t)$ and $h'_\\times(t)$.\n6.  Recompute the analytic signals and Stokes parameters $(I'(t), Q'(t), U'(t), V'(t))$ for the rotated system.\n7.  Compute the error metrics $e_I$, $e_V$, and $e_L$ to quantify the invariance of the theoretically-invariant quantities.\n\n**Step 1: Time Discretization**\nThe continuous time variable $t$ is sampled over a duration $T = 1$ second at a sampling frequency of $f_s = 4096$ Hertz. This yields $N = T \\cdot f_s = 4096$ discrete time points. The time vector is given by $t_k = k / f_s$ for $k = 0, 1, \\dots, N-1$.\n\n**Step 2: Waveform Generation**\nFor each test case, we generate the discrete time series $h_+(t_k)$ and $h_\\times(t_k)$ using the provided functional forms and parameters.\n\n**Step 3: Complex Analytic Signals**\nThe analytic signal $a(t)$ corresponding to a real signal $x(t)$ is a complex signal defined as $a(t) = x(t) + i\\mathcal{H}\\{x(t)\\}$, where $\\mathcal{H}\\{\\cdot\\}$ is the Hilbert transform. The Hilbert transform of a function can be computed efficiently using the Fast Fourier Transform (FFT). Specifically, if $X(f) = \\mathcal{F}\\{x(t)\\}$ is the Fourier transform of $x(t)$, then the Fourier transform of its Hilbert transform is $\\mathcal{F}\\{\\mathcal{H}\\{x(t)\\}\\}(f) = -i \\cdot \\text{sgn}(f) \\cdot X(f)$. The analytic signal is then constructed by taking the inverse Fourier transform of $2X(f)$ for $f>0$ and $X(f)$ for $f=0$ (and zero for $f<0$). Computationally, this is handled by the `scipy.signal.hilbert` function. We compute $a_+(t_k)$ and $a_\\times(t_k)$ from the real strain data $h_+(t_k)$ and $h_\\times(t_k)$.\n\n**Step 4: Calculation of Stokes Parameters**\nThe instantaneous Stokes parameters are defined in terms of the analytic signals $a_+(t)$ and $a_\\times(t)$. These definitions arise from the components of the instantaneous polarization coherency matrix.\n- Total Intensity: $I(t) = |a_+(t)|^2 + |a_\\times(t)|^2$\n- Linear Polarization (horizontal/vertical): $Q(t) = |a_+(t)|^2 - |a_\\times(t)|^2$\n- Linear Polarization (diagonal): $U(t) = 2 \\operatorname{Re}[a_+^*(t) a_\\times(t)]$\n- Circular Polarization: $V(t) = 2 \\operatorname{Im}[a_+^*(t) a_\\times(t)]$\n\nHere, $a_+^*(t)$ is the complex conjugate of $a_+(t)$. These formulas are applied to the time series $a_+(t_k)$ and $a_\\times(t_k)$ to obtain the discrete time series for $I(t_k)$, $Q(t_k)$, $U(t_k)$, and $V(t_k)$.\n\n**Step 5: Rotation of Polarization Basis**\nA physical rotation of the detector axes by an angle $\\psi(t)$ around the wave's propagation direction leads to a transformation of the strain components. Due to the spin-$2$ nature of the gravitational field, the components measured in the new basis, $(h'_+, h'_\\times)$, are related to the original components by a rotation matrix with an angle of $\\theta(t) = 2\\psi(t)$.\n$$\n\\begin{pmatrix} h'_+(t) \\\\ h'_\\times(t) \\end{pmatrix} = \\begin{pmatrix} \\cos(2\\psi(t)) & \\sin(2\\psi(t)) \\\\ -\\sin(2\\psi(t)) & \\cos(2\\psi(t)) \\end{pmatrix} \\begin{pmatrix} h_+(t) \\\\ h_\\times(t) \\end{pmatrix}\n$$\nWe apply this transformation to the original strain time series $h_+(t_k)$ and $h_\\times(t_k)$ to generate the rotated time series $h'_+(t_k)$ and $h'_\\times(t_k)$.\n\n**Step 6: Re-computation of Stokes Parameters**\nFollowing the same procedure as in Steps 3 and 4, we first compute the analytic signals $a'_+(t_k)$ and $a'_\\times(t_k)$ corresponding to the rotated real strains $h'_+(t_k)$ and $h'_\\times(t_k)$. Then, we compute the new Stokes parameters $(I'(t_k), Q'(t_k), U'(t_k), V'(t_k))$ using the identical formulas:\n- $I'(t) = |a'_+(t)|^2 + |a'_\\times(t)|^2$\n- $Q'(t) = |a'_+(t)|^2 - |a'_\\times(t)|^2$\n- $U'(t) = 2 \\operatorname{Re}[a'^*_+(t) a'_\\times(t)]$\n- $V'(t) = 2 \\operatorname{Im}[a'^*_+(t) a'_\\times(t)]$\n\n**Step 7: Computation of Error Metrics**\nThe final step is to quantify the numerical agreement with the theoretical invariants. We compute the three specified error metrics, which measure the relative deviation of the computed invariants.\n- $e_I = \\displaystyle \\frac{\\max_{t} | I(t) - I'(t) |}{\\max_{t} | I(t) | + \\epsilon}$\n- $e_V = \\displaystyle \\frac{\\max_{t} | V(t) - V'(t) |}{\\max_{t} | V(t) | + \\epsilon}$\n- $e_L = \\displaystyle \\frac{\\max_{t} \\left| \\sqrt{Q(t)^2 + U(t)^2} - \\sqrt{Q'(t)^2 + U'(t)^2} \\right|}{\\max_{t} (\\sqrt{Q(t)^2 + U(t)^2}) + \\epsilon}$\nThe constant $\\epsilon = 10^{-30}$ ensures numerical stability in cases where a quantity is theoretically zero (e.g., $V(t)$ for a purely linearly polarized wave). The expected result is that these errors will be on the order of machine precision, confirming the robustness of the Stokes parameter formulation under basis rotations.\n\nThis entire procedure is implemented for each of the three test cases, and the nine resulting error metrics are collected for the final output.", "answer": "```python\nimport numpy as np\nfrom scipy.signal import hilbert\n\ndef solve():\n    \"\"\"\n    Solves the gravitational wave polarization problem by generating waveforms,\n    computing Stokes parameters, applying basis rotations, and calculating\n    invariance error metrics for three test cases.\n    \"\"\"\n    \n    # Global parameters\n    f_s = 4096.0  # Sampling rate in Hz\n    T = 1.0       # Duration in seconds\n    epsilon = 1e-30 # Small constant for numerical stability\n\n    # Time vector\n    t = np.arange(0, T, 1 / f_s)\n    \n    # Test case definitions\n    A = 1e-21\n    \n    test_cases = [\n        {\n            \"name\": \"Case 1: Near-circular polarization, slow precession\",\n            \"h_plus_func\": lambda t: A * np.cos(2 * np.pi * 150 * t),\n            \"h_cross_func\": lambda t: A * np.sin(2 * np.pi * 150 * t),\n            \"psi_func\": lambda t: 0.5 * np.sin(2 * np.pi * 1 * t)\n        },\n        {\n            \"name\": \"Case 2: Linear polarization\",\n            \"h_plus_func\": lambda t: A * np.cos(2 * np.pi * 100 * t),\n            \"h_cross_func\": lambda t: np.zeros_like(t),\n            \"psi_func\": lambda t: 0.25 * t\n        },\n        {\n            \"name\": \"Case 3: Mode-mixing, fast precession\",\n            \"h_plus_func\": lambda t: (A * np.cos(2 * np.pi * 90 * t) + \n                                     0.6 * A * np.cos(2 * np.pi * 130 * t + 0.3)),\n            \"h_cross_func\": lambda t: 0.8 * A * np.sin(2 * np.pi * 90 * t - 0.2),\n            \"psi_func\": lambda t: 0.8 * np.sin(2 * np.pi * 3 * t)\n        }\n    ]\n\n    all_results = []\n\n    def compute_stokes(h_plus, h_cross):\n        \"\"\"Computes instantaneous Stokes parameters from real strain data.\"\"\"\n        a_plus = hilbert(h_plus)\n        a_cross = hilbert(h_cross)\n        \n        a_plus_conj = np.conj(a_plus)\n        \n        I = np.abs(a_plus)**2 + np.abs(a_cross)**2\n        Q = np.abs(a_plus)**2 - np.abs(a_cross)**2\n        U = 2 * np.real(a_plus_conj * a_cross)\n        V = 2 * np.imag(a_plus_conj * a_cross)\n        \n        return I, Q, U, V\n\n    for case in test_cases:\n        # 1. Generate original waveforms\n        h_plus = case[\"h_plus_func\"](t)\n        h_cross = case[\"h_cross_func\"](t)\n        \n        # 2. Compute original Stokes parameters\n        I, Q, U, V = compute_stokes(h_plus, h_cross)\n        \n        # 3. Generate rotated waveforms\n        psi = case[\"psi_func\"](t)\n        theta = 2 * psi\n        cos_theta = np.cos(theta)\n        sin_theta = np.sin(theta)\n        \n        h_plus_rot = h_plus * cos_theta + h_cross * sin_theta\n        h_cross_rot = -h_plus * sin_theta + h_cross * cos_theta\n        \n        # 4. Compute rotated Stokes parameters\n        I_rot, Q_rot, U_rot, V_rot = compute_stokes(h_plus_rot, h_cross_rot)\n        \n        # 5. Compute error metrics\n        # Error for I\n        numerator_I = np.max(np.abs(I - I_rot))\n        denominator_I = np.max(np.abs(I)) + epsilon\n        e_I = numerator_I / denominator_I\n        \n        # Error for V\n        numerator_V = np.max(np.abs(V - V_rot))\n        denominator_V = np.max(np.abs(V)) + epsilon\n        e_V = numerator_V / denominator_V\n        \n        # Error for L = sqrt(Q^2 + U^2)\n        L = np.sqrt(Q**2 + U**2)\n        L_rot = np.sqrt(Q_rot**2 + U_rot**2)\n        numerator_L = np.max(np.abs(L - L_rot))\n        denominator_L = np.max(L) + epsilon\n        e_L = numerator_L / denominator_L\n        \n        all_results.extend([e_I, e_V, e_L])\n        \n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n\n```", "id": "3483111"}, {"introduction": "While numerical relativity simulations are powerful, their results are only as reliable as the numerical methods they employ. A critical challenge is the treatment of artificial outer boundaries of the computational domain, which can cause spurious reflections of outgoing gravitational waves. This exercise [@problem_id:3483032] provides a simplified but physically insightful model to quantify these artifacts, allowing you to explore how imperfect boundary conditions can generate non-physical reflected waves and, more subtly, contaminate the signal's polarization by mixing the $+$ and $\\times$ modes. Understanding this mechanism is key to assessing the fidelity of numerical waveforms.", "problem": "You will implement and analyze a simplified, yet scientifically grounded, model of how outer boundary conditions in numerical relativity affect the polarization content of gravitational waves. Work in the framework of linearized vacuum gravity in the Transverse-Traceless (TT) gauge, where the two independent polarization amplitudes $h_+(z,t)$ and $h_\\times(z,t)$ obey decoupled one-dimensional wave equations. In geometric units where the speed of light is $c=1$, the governing equations for each polarization are\n$$\n\\partial_t^2 h(z,t) = c^2 \\,\\partial_z^2 h(z,t),\n$$\nwith dispersion relation for monochromatic plane waves given by $\\,\\omega = c\\,k\\,$, where $\\,\\omega\\,$ is angular frequency and $\\,k\\,$ is wavenumber. Consider a finite computational domain with an outer boundary at position $z=L$.\n\nBoundary conditions are enforced on the two-component field vector $\\,\\mathbf{h}(z,t) = \\begin{bmatrix}h_+(z,t) \\\\ h_\\times(z,t)\\end{bmatrix}\\,$ using a linear first-order (Sommerfeld-type) operator\n$$\n\\mathcal{B}[\\mathbf{h}](L,t) \\equiv \\partial_t \\mathbf{h}(L,t) + C_b\\,\\partial_z \\mathbf{h}(L,t) = \\mathbf{0},\n$$\nwhere $\\,C_b\\,$ is a constant $2\\times 2$ matrix characterizing the chosen boundary condition. Two families of boundary conditions are to be compared:\n\n- Sommerfeld boundary conditions: choose a rotated basis for polarization with rotation angle $\\,\\theta\\,$ (in radians), defined by the matrix\n$$\nR(\\theta) = \\begin{bmatrix}\n\\cos\\theta & -\\sin\\theta \\\\\n\\sin\\theta & \\cos\\theta\n\\end{bmatrix},\n$$\nand prescribe distinct characteristic boundary speeds $\\,c_{b1}\\,$ and $\\,c_{b2}\\,$ in that rotated basis. In the physical $+$/$\\times$ basis this yields\n$$\nC_b = R(\\theta)^\\top \\begin{bmatrix} c_{b1} & 0 \\\\ 0 & c_{b2} \\end{bmatrix} R(\\theta).\n$$\nThis models a realistic situation where a naive Sommerfeld condition is applied to a mixture of fields with different effective propagation speeds, potentially causing both reflection and polarization mixing.\n\n- Constraint-Preserving Boundary Conditions (CPBC): in this simplified TT model, ideal CPBC correspond to matching all outgoing gravitational-wave characteristic fields with the correct physical speed and preserving the constraints exactly, which here reduces to choosing\n$$\nC_b = c\\,I,\n$$\nwith $\\,I\\,$ the $2\\times 2$ identity matrix. This produces no reflection and preserves the TT character at the boundary for the plane-wave solution.\n\nAssume a monochromatic outgoing plane wave with amplitude vector $\\,\\mathbf{A}_{\\text{out}}\\,$ traveling toward the boundary:\n$$\n\\mathbf{h}_{\\text{out}}(z,t) = \\mathbf{A}_{\\text{out}}\\,e^{i(k z - \\omega t)}.\n$$\nThe reflected wave traveling back into the domain has amplitude vector $\\,\\mathbf{A}_{\\text{in}}\\,$:\n$$\n\\mathbf{h}_{\\text{in}}(z,t) = \\mathbf{A}_{\\text{in}}\\,e^{i(-k z - \\omega t)}.\n$$\nImposing $\\,\\mathcal{B}[\\mathbf{h}_{\\text{out}} + \\mathbf{h}_{\\text{in}}](L,t) = \\mathbf{0}\\,$ leads to a linear system for $\\,\\mathbf{A}_{\\text{in}}\\,$ in terms of $\\,\\mathbf{A}_{\\text{out}}\\,$, which can be derived from first principles. Define the reflection matrix\n$$\n\\mathsf{R} \\equiv \\left(-\\omega I - k\\,C_b\\right)^{-1}\\left(\\omega I - k\\,C_b\\right),\n$$\nand the boundary phase factor $\\,\\xi \\equiv e^{2 i k L}\\,$. Then the incoming amplitude is\n$$\n\\mathbf{A}_{\\text{in}} = \\xi\\,\\mathsf{R}\\,\\mathbf{A}_{\\text{out}}.\n$$\nThe quantity of interest is the spurious polarization reflected back into the computational domain. For an outgoing wave that is purely $+$-polarized, $\\,\\mathbf{A}_{\\text{out}} = \\begin{bmatrix}A_+ \\\\ 0\\end{bmatrix}\\,$ with $\\,A_+ \\neq 0\\,$, define the dimensionless reflection ratios\n$$\nr_+ \\equiv \\frac{\\left|(\\mathbf{A}_{\\text{in}})_+\\right|}{|A_+|}, \\qquad r_\\times \\equiv \\frac{\\left|(\\mathbf{A}_{\\text{in}})_\\times\\right|}{|A_+|},\n$$\nwhich measure, respectively, the magnitude of the reflected $+$ component and the magnitude of the spurious reflected $\\times$ component, both normalized by the outgoing $+$ amplitude. Since $\\,|\\xi|=1\\,$, these ratios depend only on $\\,\\mathsf{R}\\,$ and $\\,\\mathbf{A}_{\\text{out}}\\,$.\n\nYour task is to write a complete, runnable program that:\n- Implements the above model faithfully.\n- Computes $\\,r_+\\,$ and $\\,r_\\times\\,$ for each test case below.\n- Returns the results in the specified format.\n\nUse geometric units where $\\,c\\,$ and all speeds are dimensionless; wavenumber $\\,k\\,$ is in inverse-length units consistent with $\\,c=1\\,$; angle $\\,\\theta\\,$ is in radians. All outputs must be dimensionless. Express each ratio as a decimal number, rounded to ten decimal places.\n\nTest Suite:\n- Case $1$ (Sommerfeld, mild mismatch and mixing):\n  - $c=1$, $c_{b1}=0.9$, $c_{b2}=1.1$, $\\theta=\\pi/6$, $k=2\\pi$, $L=1$, $\\mathbf{A}_{\\text{out}}=\\begin{bmatrix}1 \\\\ 0\\end{bmatrix}$.\n- Case $2$ (CPBC, perfect match):\n  - $c=1$, $C_b=c\\,I$, $\\theta$ arbitrary (not used), $k=2\\pi$, $L=1$, $\\mathbf{A}_{\\text{out}}=\\begin{bmatrix}1 \\\\ 0\\end{bmatrix}$.\n- Case $3$ (Sommerfeld, correct speeds but rotated basis):\n  - $c=1$, $c_{b1}=1$, $c_{b2}=1$, $\\theta=\\pi/4$, $k=2\\pi$, $L=1$, $\\mathbf{A}_{\\text{out}}=\\begin{bmatrix}1 \\\\ 0\\end{bmatrix}$.\n- Case $4$ (Sommerfeld, strong mismatch and mixing):\n  - $c=1$, $c_{b1}=0.5$, $c_{b2}=1.5$, $\\theta=\\pi/3$, $k=\\pi$, $L=0.5$, $\\mathbf{A}_{\\text{out}}=\\begin{bmatrix}1 \\\\ 0\\end{bmatrix}$.\n- Case $5$ (Sommerfeld, no mixing in the physical basis):\n  - $c=1$, $c_{b1}=0.8$, $c_{b2}=1.2$, $\\theta=0$, $k=\\pi$, $L=1.25$, $\\mathbf{A}_{\\text{out}}=\\begin{bmatrix}1 \\\\ 0\\end{bmatrix}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case must contribute a list of two decimal numbers $[r_+,r_\\times]$ rounded to ten decimal places, so the final output must have the form\n$$\n\\left[\\,[r_+,r_\\times],\\,[r_+,r_\\times],\\,[r_+,r_\\times],\\,[r_+,r_\\times],\\,[r_+,r_\\times]\\,\\right],\n$$\nwith no additional text printed.", "solution": "The problem statement is validated as being scientifically grounded, mathematically consistent, and well-posed. It presents a simplified but physically meaningful model from numerical relativity concerning boundary condition effects on gravitational wave polarizations. All necessary components for a unique solution are clearly defined and provided.\n\nThe core of the problem is to determine the reflection of a monochromatic plane wave at a numerical boundary. The total wave field, $\\mathbf{h}(z,t)$, is a linear superposition of an outgoing wave, $\\mathbf{h}_{\\text{out}}(z,t)$, and a reflected (incoming) wave, $\\mathbf{h}_{\\text{in}}(z,t)$:\n$$\n\\mathbf{h}(z,t) = \\mathbf{h}_{\\text{out}}(z,t) + \\mathbf{h}_{\\text{in}}(z,t) = \\mathbf{A}_{\\text{out}}\\,e^{i(k z - \\omega t)} + \\mathbf{A}_{\\text{in}}\\,e^{i(-k z - \\omega t)}\n$$\nwhere $\\mathbf{A}_{\\text{out}}$ and $\\mathbf{A}_{\\text{in}}$ are the constant amplitude vectors for the outgoing and incoming waves, respectively. The boundary condition is specified by the first-order operator $\\mathcal{B}$ acting on the total field at the boundary $z=L$:\n$$\n\\mathcal{B}[\\mathbf{h}](L,t) \\equiv \\partial_t \\mathbf{h}(L,t) + C_b\\,\\partial_z \\mathbf{h}(L,t) = \\mathbf{0}\n$$\nTo apply this condition, we first compute the partial derivatives of $\\mathbf{h}(z,t)$:\n$$\n\\partial_t \\mathbf{h}(z,t) = -i\\omega \\left( \\mathbf{A}_{\\text{out}}\\,e^{i(k z - \\omega t)} + \\mathbf{A}_{\\text{in}}\\,e^{i(-k z - \\omega t)} \\right)\n$$\n$$\n\\partial_z \\mathbf{h}(z,t) = ik \\left( \\mathbf{A}_{\\text{out}}\\,e^{i(k z - \\omega t)} - \\mathbf{A}_{\\text{in}}\\,e^{i(-k z - \\omega t)} \\right)\n$$\nEvaluating these expressions at $z=L$ and substituting them into the boundary condition operator yields:\n$$\n-i\\omega \\left( \\mathbf{A}_{\\text{out}}e^{ikL} + \\mathbf{A}_{\\text{in}}e^{-ikL} \\right)e^{-i\\omega t} + C_b \\left( ik \\left( \\mathbf{A}_{\\text{out}}e^{ikL} - \\mathbf{A}_{\\text{in}}e^{-ikL} \\right) \\right)e^{-i\\omega t} = \\mathbf{0}\n$$\nWe can cancel the common non-zero factor $i e^{-i\\omega t}$, which gives:\n$$\n-\\omega \\left( \\mathbf{A}_{\\text{out}}e^{ikL} + \\mathbf{A}_{\\text{in}}e^{-ikL} \\right) + k C_b \\left( \\mathbf{A}_{\\text{out}}e^{ikL} - \\mathbf{A}_{\\text{in}}e^{-ikL} \\right) = \\mathbf{0}\n$$\nThis equation is a linear system for $\\mathbf{A}_{\\text{in}}$ in terms of $\\mathbf{A}_{\\text{out}}$. To solve it, we group terms multiplying $\\mathbf{A}_{\\text{in}}$ and $\\mathbf{A}_{\\text{out}}$:\n$$\n(-\\omega I - kC_b) \\mathbf{A}_{\\text{in}}e^{-ikL} = (-\\omega I + kC_b) \\mathbf{A}_{\\text{out}}e^{ikL}\n$$\nwhere $I$ is the $2 \\times 2$ identity matrix. Solving for $\\mathbf{A}_{\\text{in}}$, we find:\n$$\n\\mathbf{A}_{\\text{in}} = (-\\omega I - kC_b)^{-1} (-\\omega I + kC_b) e^{2ikL} \\mathbf{A}_{\\text{out}}\n$$\nThis relation matches the form given in the problem, $\\mathbf{A}_{\\text{in}} = \\xi\\,\\mathsf{R}\\,\\mathbf{A}_{\\text{out}}$, with the phase factor $\\xi \\equiv e^{2ikL}$ and the reflection matrix $\\mathsf{R}$ defined as $\\mathsf{R} \\equiv (-\\omega I - kC_b)^{-1} (-\\omega I + kC_b)$. This matrix can be equivalently written as $\\mathsf{R} = (\\omega I + kC_b)^{-1} (\\omega I - kC_b)$.\n\nGiven geometric units where $c=1$, the dispersion relation simplifies to $\\omega=k$. Substituting this into the expression for $\\mathsf{R}$ allows for a significant simplification:\n$$\n\\mathsf{R} = (kI + kC_b)^{-1}(kI - kC_b) = [k(I+C_b)]^{-1}[k(I-C_b)] = (I+C_b)^{-1}(I-C_b)\n$$\nThe problem asks for the reflection ratios $r_+$ and $r_\\times$, which are the magnitudes of the components of the reflected wave, normalized by the amplitude of the initial outgoing wave. For an outgoing wave that is purely $+$-polarized, we have $\\mathbf{A}_{\\text{out}} = \\begin{bmatrix}A_+ \\\\ 0\\end{bmatrix}$. The ratios are:\n$$\nr_+ \\equiv \\frac{\\left|(\\mathbf{A}_{\\text{in}})_+\\right|}{|A_+|}, \\qquad r_\\times \\equiv \\frac{\\left|(\\mathbf{A}_{\\text{in}})_\\times\\right|}{|A_+|}\n$$\nSince the phase factor $\\xi$ has unit modulus ($|\\xi|=|e^{2ikL}|=1$), it does not affect the magnitudes of the reflected components. We can therefore calculate the ratios from the vector $\\mathbf{A}'_{\\text{in}} = \\mathsf{R} \\mathbf{A}_{\\text{out}}$. Without loss of generality, we can set $A_+=1$, so $\\mathbf{A}_{\\text{out}} = \\begin{bmatrix}1 \\\\ 0\\end{bmatrix}$. The vector $\\mathbf{A}'_{\\text{in}}$ is then simply the first column of the matrix $\\mathsf{R}$. If $\\mathsf{R}$ has components $\\mathsf{R}_{ij}$, then $\\mathbf{A}'_{\\text{in}} = \\begin{bmatrix}\\mathsf{R}_{11}\\\\\\mathsf{R}_{21}\\end{bmatrix}$, and the ratios become $r_+ = |\\mathsf{R}_{11}|$ and $r_\\times = |\\mathsf{R}_{21}|$.\n\nThe computational algorithm proceeds as follows for each test case:\n1.  Construct the matrix $C_b$. For Sommerfeld conditions, $C_b = R(\\theta)^\\top \\text{diag}(c_{b1}, c_{b2}) R(\\theta)$, where $R(\\theta) = \\begin{bmatrix}\\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta\\end{bmatrix}$. For CPBC, $C_b=cI=I$.\n2.  Calculate the reflection matrix $\\mathsf{R} = (I+C_b)^{-1}(I-C_b)$. This involves standard matrix algebra: addition, inversion, and multiplication.\n3.  Extract the first column of $\\mathsf{R}$, which corresponds to $\\mathbf{A}'_{\\text{in}}$.\n4.  Compute the absolute values of the components of this column vector to find $r_+$ and $r_\\times$.\n\nThis procedure is applied to each test case.\n- For Case 2 (CPBC) and Case 3 (Sommerfeld with $c_{b1}=c_{b2}=1$), $C_b$ becomes the identity matrix $I$. This results in $I-C_b=\\mathbf{0}$, making $\\mathsf{R}$ the zero matrix. Consequently, both $r_+$ and $r_\\times$ are $0$, indicating perfect absorption.\n- For Case 5 (Sommerfeld with $\\theta=0$), $R(0)=I$, so $C_b$ is diagonal. This makes $\\mathsf{R}$ diagonal, and thus $r_\\times=0$ since there is no mixing between the polarization components.\n- For Cases 1 and 4, $C_b$ is a non-diagonal matrix, leading to both reflection ($r_+ > 0$) and spurious polarization mixing ($r_\\times > 0$).", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes spurious polarization reflection ratios for gravitational waves\n    at a numerical boundary.\n    \"\"\"\n\n    # Test cases defined in the problem statement.\n    test_cases = [\n        # Case 1 (Sommerfeld, mild mismatch and mixing)\n        {\n            \"type\": \"sommerfeld\",\n            \"c\": 1, \"k\": 2 * np.pi, \"L\": 1.0,\n            \"bc_params\": {\"cb1\": 0.9, \"cb2\": 1.1, \"theta\": np.pi / 6},\n            \"A_out\": np.array([1.0, 0.0])\n        },\n        # Case 2 (CPBC, perfect match)\n        {\n            \"type\": \"cpbc\",\n            \"c\": 1, \"k\": 2 * np.pi, \"L\": 1.0,\n            \"bc_params\": {\"c\": 1.0},\n            \"A_out\": np.array([1.0, 0.0])\n        },\n        # Case 3 (Sommerfeld, correct speeds but rotated basis)\n        {\n            \"type\": \"sommerfeld\",\n            \"c\": 1, \"k\": 2 * np.pi, \"L\": 1.0,\n            \"bc_params\": {\"cb1\": 1.0, \"cb2\": 1.0, \"theta\": np.pi / 4},\n            \"A_out\": np.array([1.0, 0.0])\n        },\n        # Case 4 (Sommerfeld, strong mismatch and mixing)\n        {\n            \"type\": \"sommerfeld\",\n            \"c\": 1, \"k\": np.pi, \"L\": 0.5,\n            \"bc_params\": {\"cb1\": 0.5, \"cb2\": 1.5, \"theta\": np.pi / 3},\n            \"A_out\": np.array([1.0, 0.0])\n        },\n        # Case 5 (Sommerfeld, no mixing in the physical basis)\n        {\n            \"type\": \"sommerfeld\",\n            \"c\": 1, \"k\": np.pi, \"L\": 1.25,\n            \"bc_params\": {\"cb1\": 0.8, \"cb2\": 1.2, \"theta\": 0.0},\n            \"A_out\": np.array([1.0, 0.0])\n        }\n    ]\n\n    all_results = []\n\n    for i, case in enumerate(test_cases):\n        # Identity matrix\n        I = np.identity(2)\n        \n        # Construct the boundary condition matrix C_b\n        if case[\"type\"] == \"sommerfeld\":\n            p = case[\"bc_params\"]\n            cb1, cb2, theta = p[\"cb1\"], p[\"cb2\"], p[\"theta\"]\n            \n            # Rotation matrix\n            cos_t, sin_t = np.cos(theta), np.sin(theta)\n            R_theta = np.array([[cos_t, -sin_t], [sin_t, cos_t]])\n            \n            # Diagonal matrix of boundary speeds\n            D = np.array([[cb1, 0], [0, cb2]])\n            \n            # C_b = R^T D R\n            C_b = R_theta.T @ D @ R_theta\n            \n        elif case[\"type\"] == \"cpbc\":\n            # C_b = c * I\n            C_b = case[\"bc_params\"][\"c\"] * I\n\n        # Simplified reflection matrix for c=1 (omega=k)\n        # R_mat = (I + C_b)^-1 * (I - C_b)\n        M_inv = np.linalg.inv(I + C_b)\n        R_mat = M_inv @ (I - C_b)\n        \n        # Reflected amplitude (without phase factor, as it doesn't affect magnitude)\n        A_out = case[\"A_out\"]\n        A_in_prime = R_mat @ A_out\n        \n        # Magnitude of the outgoing + polarization amplitude\n        A_plus_mag = np.abs(A_out[0])\n\n        # Calculate reflection ratios\n        # Note: A_plus_mag is 1 for all test cases, but we include it for generality.\n        # This handles cases where A_out could be complex or not normalized.\n        r_plus = np.abs(A_in_prime[0]) / A_plus_mag if A_plus_mag != 0 else 0\n        r_cross = np.abs(A_in_prime[1]) / A_plus_mag if A_plus_mag != 0 else 0\n        \n        all_results.append((r_plus, r_cross))\n\n    # Format the final output string exactly as specified.\n    output_parts = [f\"[{r_p:.10f},{r_x:.10f}]\" for r_p, r_x in all_results]\n    final_output_string = f\"[{','.join(output_parts)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```", "id": "3483032"}, {"introduction": "In numerical relativity, gravitational wave signals can be extracted in multiple ways, most commonly as the metric strain $h_{ij}$ or as the Newman-Penrose curvature scalar $\\Psi_4$. These two quantities are physically linked by the relation $\\Psi_{4} = \\ddot{h}$, providing a powerful consistency check on simulation results. This advanced practice [@problem_id:3483091] guides you through the process of reconciling these two data products, a task central to modern waveform generation. You will perform frequency-domain integration to recover the strain from $\\Psi_4$ and use a least-squares fit to resolve the resulting integration constants and drifts, mastering a technique essential for producing high-fidelity waveforms for gravitational wave astronomy.", "problem": "You are given a synthetic vacuum, plane-wave gravitational signal in the linearized regime of General Relativity (GR), propagating along the $z$-axis. In the Transverse-Traceless (TT) gauge, the two polarization states are represented by the strain components $h_{+}(t)$ and $h_{\\times}(t)$, with the complex strain defined as $h(t) = h_{+}(t) - i\\,h_{\\times}(t)$. In the Newman-Penrose (NP) formalism at future null infinity, the curvature scalar $\\Psi_{4}(t)$ equals the second time derivative of the complex strain, i.e., $\\Psi_{4}(t) = \\ddot{h}(t)$. Your task is to implement two independent pipelines to recover $h_{+}(t)$ and $h_{\\times}(t)$ from two data products and to reconcile integration constants and drift via phase alignment, then quantify the agreement.\n\nFundamental base:\n- Linearized GR in vacuum, plane-wave solution in TT gauge, where the spatial metric is $g_{ij}(t) = \\delta_{ij} + h_{ij}^{\\mathrm{TT}}(t)$ with $h_{ij}^{\\mathrm{TT}}$ traceless and transverse.\n- In TT gauge for propagation along the $z$-axis, $h_{ij}^{\\mathrm{TT}}(t)$ encodes the two polarizations $h_{+}(t)$ and $h_{\\times}(t)$.\n- The Newman-Penrose scalar $\\Psi_{4}(t)$ at future null infinity equals the second time derivative of the complex strain $h(t)$.\n- Discrete time series are to be handled with the Fast Fourier Transform (FFT) and its inverse (IFFT), using frequency-domain operations to perform time integrations and differentiations.\n\nGiven three test cases below, you must:\n- Synthesize a complex strain $h(t)$ with a specified amplitude envelope and phase evolution.\n- Construct the spatial metric components $g_{xx}(t)$, $g_{yy}(t)$, $g_{xy}(t)$ in TT gauge from the strain.\n- Construct $\\Psi_{4}(t)$ by applying a second time derivative to the complex strain in the frequency domain.\n- Recover $h(t)$ from $\\Psi_{4}(t)$ by double time integration in the frequency domain using a high-pass regularization: for Fourier angular frequencies $\\omega$ with $|\\omega| < \\omega_{\\mathrm{cut}}$, set the corresponding complex strain Fourier modes to zero, and for $|\\omega| \\ge \\omega_{\\mathrm{cut}}$, divide by $-\\omega^{2}$. Use a cutoff frequency of $f_{\\mathrm{cut}} = 5$ hertz, i.e., $\\omega_{\\mathrm{cut}} = 2\\pi f_{\\mathrm{cut}}$. Angles are in radians.\n- Recover $h(t)$ directly from the metric by identifying the TT components consistent with a plane wave along the $z$-axis, i.e., extract $h_{+}(t)$ and $h_{\\times}(t)$ from the spatial metric, and construct $h(t) = h_{+}(t) - i\\,h_{\\times}(t)$.\n- Reconcile integration constants and possible residual drift by aligning the curvature-based reconstruction $h_{\\mathrm{curv}}(t)$ to the metric-based reconstruction $h_{\\mathrm{metric}}(t)$ using complex least-squares to determine complex constants $c_{0}$ and $c_{1}$ that minimize the time-domain squared error\n$$\n\\sum_{k=0}^{N-1} \\left| \\left(h_{\\mathrm{curv}}(t_{k}) + c_{0} + c_{1}\\,t_{k}\\right) - h_{\\mathrm{metric}}(t_{k}) \\right|^{2},\n$$\nand define the aligned reconstruction as $h_{\\mathrm{aligned}}(t) = h_{\\mathrm{curv}}(t) + c_{0} + c_{1}\\,t$.\n- Report, for each test case, the maximum absolute difference\n$$\n\\Delta_{\\infty} = \\max_{k} \\left| h_{\\mathrm{aligned}}(t_{k}) - h_{\\mathrm{metric}}(t_{k}) \\right|.\n$$\n\nSynthetic signal specification (all amplitudes are dimensionless; time is in seconds; frequency is in hertz; angles are in radians):\n- The complex strain is given by\n$$\nh(t) = A(t)\\,\\exp\\!\\left( i\\,\\phi(t) \\right)\\,\\exp\\!\\left(-2i\\,\\psi\\right),\n$$\nwith polarization angle $\\psi$ and phase\n$$\n\\phi(t) = 2\\pi\\left(f_{0}\\,t + \\tfrac{1}{2}\\,\\dot{f}\\,t^{2}\\right) + \\phi_{0},\n$$\nand an amplitude envelope $A(t) = A_{0}\\,\\left(1 + \\alpha\\,t\\right)$.\n- Construct the TT spatial metric components from $h_{+}(t) = \\Re[h(t)]$ and $h_{\\times}(t) = -\\Im[h(t)]$ via\n$g_{xx}(t) = 1 + h_{+}(t)$, $g_{yy}(t) = 1 - h_{+}(t)$, and $g_{xy}(t) = h_{\\times}(t)$.\n- Construct $\\Psi_{4}(t)$ by applying a second time derivative to $h(t)$ in the frequency domain.\n\nPhase alignment and drift handling:\n- After reconstructing $h_{\\mathrm{curv}}(t)$ from $\\Psi_{4}(t)$, determine complex constants $c_{0}$ and $c_{1}$ by minimizing the above least-squares objective, and use them to define $h_{\\mathrm{aligned}}(t)$.\n- For Test Case $3$, simulate gauge-like drift by adding a complex affine trend $d_{0} + d_{1}\\,t$ to the metric-based strain before comparison; this drift must be absorbed by the alignment stage.\n\nTest suite:\n- Use the following three parameter sets to synthesize the data. Let the time samples be $t_{k} = k\\,\\Delta t$ for $k = 0,1,\\dots,N-1$ with $N = \\lfloor T/\\Delta t \\rfloor$.\n    1. Test Case $1$ (constant frequency, constant amplitude):\n       - $T = 0.5$, $\\Delta t = 1/4096$, $A_{0} = 1.0\\times 10^{-21}$, $\\alpha = 0.0$, $f_{0} = 100.0$, $\\dot{f} = 0.0$, $\\psi = 0.3$, $\\phi_{0} = 0.2$.\n    2. Test Case $2$ (linear chirp, rising amplitude):\n       - $T = 1.0$, $\\Delta t = 1/4096$, $A_{0} = 5.0\\times 10^{-22}$, $\\alpha = 0.8$, $f_{0} = 50.0$, $\\dot{f} = 120.0$, $\\psi = -0.5$, $\\phi_{0} = 0.1$.\n    3. Test Case $3$ (linear chirp, rising amplitude, metric drift):\n       - $T = 1.0$, $\\Delta t = 1/4096$, $A_{0} = 8.0\\times 10^{-22}$, $\\alpha = 0.5$, $f_{0} = 80.0$, $\\dot{f} = 80.0$, $\\psi = 0.8$, $\\phi_{0} = -0.3$.\n       - Metric drift: add $d_{0} + d_{1}\\,t$ to the metric-based complex strain, with $d_{0} = 3.0\\times 10^{-23}\\,\\exp(i\\,0.2)$ and $d_{1} = 1.0\\times 10^{-23}\\,\\exp(-i\\,0.5)$.\n\nNumerical method requirements:\n- Use the FFT/IFFT pair on the uniformly sampled time series to implement differentiation and integration in the frequency domain. Let angular frequencies be $\\omega_{k} = 2\\pi\\,k/T$ mapped according to the FFT frequency convention.\n- To construct $\\Psi_{4}(t)$ from $h(t)$, multiply the Fourier transform of $h(t)$ by $-\\omega^{2}$ and then apply the IFFT.\n- To reconstruct $h(t)$ from $\\Psi_{4}(t)$, divide the Fourier transform of $\\Psi_{4}(t)$ by $-\\omega^{2}$ wherever $|\\omega| \\ge \\omega_{\\mathrm{cut}}$, and set the modes to zero for $|\\omega| < \\omega_{\\mathrm{cut}}$, then apply the IFFT.\n- Perform the complex least-squares alignment by solving independently for the real and imaginary parts of $c_{0}$ and $c_{1}$ via linear regression over the full time interval.\n\nOutput specification:\n- For each of the three test cases, compute $\\Delta_{\\infty}$ as defined above. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of Test Case $1$, Test Case $2$, Test Case $3$, for example: \"[result1,result2,result3]\".\n- The outputs must be decimal floating-point numbers. No units are to be printed; all quantities are dimensionless in geometrized units with $G=c=1$, times are in seconds, and angles are in radians.", "solution": "The problem presented is valid. It is a well-posed, scientifically grounded exercise in numerical relativity and gravitational wave data analysis. The premises are based on established principles of linearized General Relativity, and the numerical tasks are clearly defined with all necessary parameters provided. We will proceed with a full solution.\n\nThe core task is to reconcile two independent reconstructions of a gravitational wave (GW) strain, $h(t) = h_{+}(t) - i h_{\\times}(t)$, from a synthetic dataset. The first reconstruction, $h_{\\mathrm{metric}}(t)$, is derived directly from the components of the spatial metric tensor. The second, $h_{\\mathrm{curv}}(t)$, is obtained by integrating the Newman-Penrose curvature scalar $\\Psi_{4}(t)$. The relationship $\\Psi_{4}(t) = \\ddot{h}(t)$ is fundamental for plane waves in vacuum at future null infinity. The discrepancies between the two reconstructions, arising from numerical methods and introduced drifts, are to be resolved via a least-squares alignment procedure. The final agreement is quantified by the maximum absolute difference between the aligned signal and the metric-based signal.\n\nThe procedure is executed for three distinct test cases, following these steps:\n\n1.  **Synthetic Signal Generation**\n    First, we synthesize the \"true\" complex GW strain, $h_{\\mathrm{true}}(t)$, for a plane wave propagating along the $z$-axis. The signal is defined by its amplitude envelope $A(t)$, temporal phase $\\phi(t)$, and a constant polarization angle $\\psi$:\n    $$\n    h_{\\mathrm{true}}(t) = A(t) \\exp(i\\phi(t)) \\exp(-2i\\psi)\n    $$\n    The amplitude envelope is linear in time, $A(t) = A_{0}(1 + \\alpha t)$, and the phase represents a signal with a linearly varying instantaneous frequency (\"chirp\"), $\\phi(t) = 2\\pi\\left(f_{0}t + \\frac{1}{2}\\dot{f}t^{2}\\right) + \\phi_{0}$.\n    The signal is sampled on a uniform time grid $t_k = k\\Delta t$ for $k = 0, \\dots, N-1$, where $N = \\lfloor T/\\Delta t \\rfloor$.\n\n2.  **Pipeline 1: Metric-Based Strain Reconstruction**\n    The first reconstruction pipeline uses the spatial metric components in the Transverse-Traceless (TT) gauge. From the true complex strain $h_{\\mathrm{true}}(t)$, we define the two real polarization components:\n    $$\n    h_{+}(t) = \\Re[h_{\\mathrm{true}}(t)]\n    $$\n    $$\n    h_{\\times}(t) = -\\Im[h_{\\mathrm{true}}(t)]\n    $$\n    The metric-based reconstruction, $h_{\\mathrm{metric}}(t)$, is then constructed by combining these polarizations, which is equivalent to the original true strain, $h_{\\mathrm{true}}(t)$.\n    $$\n    h_{\\mathrm{metric}}(t) = h_{+}(t) - i h_{\\times}(t) = h_{\\mathrm{true}}(t)\n    $$\n    For Test Case $3$, a synthetic complex affine drift, $d(t) = d_{0} + d_{1}t$, is added to this reconstruction to simulate gauge artifacts that might appear in a real numerical simulation.\n    $$\n    h_{\\mathrm{metric}}(t)|_{\\text{Case 3}} = h_{\\mathrm{true}}(t) + d_{0} + d_{1}t\n    $$\n    This $h_{\\mathrm{metric}}(t)$ serves as the \"ground truth\" or target for the alignment process.\n\n3.  **Pipeline 2: Curvature-Based Strain Reconstruction**\n    The second pipeline starts from the Newman-Penrose scalar $\\Psi_{4}(t)$. This scalar is constructed by taking the second time derivative of the true strain $h_{\\mathrm{true}}(t)$. This operation is most conveniently performed in the frequency domain using the Fast Fourier Transform (FFT). The Fourier transform of the second derivative of a function $f(t)$ is related to the Fourier transform of the function itself, $\\tilde{f}(\\omega)$, by:\n    $$\n    \\mathcal{F}[\\ddot{f}(t)](\\omega) = (i\\omega)^2 \\tilde{f}(\\omega) = -\\omega^2 \\tilde{f}(\\omega)\n    $$\n    Thus, we compute $\\Psi_{4}(t)$ by taking the FFT of $h_{\\mathrm{true}}(t)$, multiplying by $-\\omega^2$ for each angular frequency $\\omega_k$ in the discrete spectrum, and then applying the inverse FFT (IFFT).\n\n    Next, we recover the strain $h_{\\mathrm{curv}}(t)$ by reversing this process, i.e., performing a double integration on $\\Psi_{4}(t)$. In the frequency domain, this corresponds to dividing the Fourier transform of $\\Psi_{4}(t)$, denoted $\\tilde{\\Psi}_{4}(\\omega)$, by $-\\omega^2$. This division is ill-defined at $\\omega=0$ and amplifies low-frequency noise. To manage this, a high-pass regularization is applied:\n    $$\n    \\tilde{h}_{\\mathrm{curv}}(\\omega) =\n    \\begin{cases}\n    \\tilde{\\Psi}_{4}(\\omega) / (-\\omega^2) & \\text{if } |\\omega| \\ge \\omega_{\\mathrm{cut}} \\\\\n    0 & \\text{if } |\\omega| < \\omega_{\\mathrm{cut}}\n    \\end{cases}\n    $$\n    where the cutoff angular frequency is $\\omega_{\\mathrm{cut}} = 2\\pi f_{\\mathrm{cut}}$ with $f_{\\mathrm{cut}} = 5$ Hz. Applying the IFFT to $\\tilde{h}_{\\mathrm{curv}}(\\omega)$ yields the time-domain waveform $h_{\\mathrm{curv}}(t)$. The regularization effectively discards information about the constant and linear terms of the integrated signal, which are precisely the integration constants of a double indefinite integral.\n\n4.  **Reconciliation and Alignment**\n    The curvature-based reconstruction $h_{\\mathrm{curv}}(t)$ will differ from the metric-based one $h_{\\mathrm{metric}}(t)$ due to the low-frequency content removed by the regularization, and any additional low-frequency drift present in $h_{\\mathrm{metric}}(t)$ (as in Test Case 3). These discrepancies are expected to be well-approximated by a complex affine function $C(t) = c_{0} + c_{1}t$. We determine the complex coefficients $c_0$ and $c_1$ by minimizing the time-domain squared error:\n    $$\n    \\min_{c_0, c_1} \\sum_{k=0}^{N-1} \\left| h_{\\mathrm{metric}}(t_k) - (h_{\\mathrm{curv}}(t_k) + c_{0} + c_{1}t_k) \\right|^{2}\n    $$\n    This is equivalent to finding a best fit line $c_0 + c_1 t$ to the residual signal $\\Delta h(t) = h_{\\mathrm{metric}}(t) - h_{\\mathrm{curv}}(t)$. This complex linear least-squares problem decouples into two independent real linear least-squares problems for the real and imaginary parts of the coefficients:\n    $$\n    \\min_{c_{0r}, c_{1r}} \\sum_{k=0}^{N-1} \\left( \\Re[\\Delta h(t_k)] - (c_{0r} + c_{1r} t_k) \\right)^{2}\n    $$\n    $$\n    \\min_{c_{0i}, c_{1i}} \\sum_{k=0}^{N-1} \\left( \\Im[\\Delta h(t_k)] - (c_{0i} + c_{1i} t_k) \\right)^{2}\n    $$\n    These are solved using standard linear regression techniques. Once $c_0 = c_{0r} + i c_{0i}$ and $c_1 = c_{1r} + i c_{1i}$ are found, the aligned curvature-based strain is defined as $h_{\\mathrm{aligned}}(t) = h_{\\mathrm{curv}}(t) + c_0 + c_1 t$.\n\n5.  **Quantification of Agreement**\n    Finally, the agreement between the two pipelines after alignment is quantified by computing the maximum absolute difference over the time series:\n    $$\n    \\Delta_{\\infty} = \\max_{k} \\left| h_{\\mathrm{aligned}}(t_{k}) - h_{\\mathrm{metric}}(t_{k}) \\right|\n    $$\n    This value represents the magnitude of the largest residual error not captured by the affine fit, providing a measure of the intrinsic consistency between the two reconstruction methods.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the gravitational wave strain reconstruction and alignment problem\n    for three test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test Case 1 (constant frequency, constant amplitude)\n        {\n            \"T\": 0.5, \"dt\": 1/4096, \"A0\": 1.0e-21, \"alpha\": 0.0,\n            \"f0\": 100.0, \"f_dot\": 0.0, \"psi\": 0.3, \"phi0\": 0.2,\n            \"drift\": None\n        },\n        # Test Case 2 (linear chirp, rising amplitude)\n        {\n            \"T\": 1.0, \"dt\": 1/4096, \"A0\": 5.0e-22, \"alpha\": 0.8,\n            \"f0\": 50.0, \"f_dot\": 120.0, \"psi\": -0.5, \"phi0\": 0.1,\n            \"drift\": None\n        },\n        # Test Case 3 (linear chirp, rising amplitude, metric drift)\n        {\n            \"T\": 1.0, \"dt\": 1/4096, \"A0\": 8.0e-22, \"alpha\": 0.5,\n            \"f0\": 80.0, \"f_dot\": 80.0, \"psi\": 0.8, \"phi0\": -0.3,\n            \"drift\": {\n                \"d0\": 3.0e-23 * np.exp(1j * 0.2),\n                \"d1\": 1.0e-23 * np.exp(1j * -0.5)\n            }\n        },\n    ]\n\n    f_cut = 5.0  # Cutoff frequency in Hz for regularization\n\n    results = []\n    for params in test_cases:\n        # 1. Setup\n        T = params[\"T\"]\n        dt = params[\"dt\"]\n        N = int(T / dt)  # Per problem spec, floor is implicit with int cast\n        t = np.arange(N) * dt\n        \n        # 2. Synthesize Ground Truth Signal\n        A0, alpha = params[\"A0\"], params[\"alpha\"]\n        f0, f_dot = params[\"f0\"], params[\"f_dot\"]\n        psi, phi0 = params[\"psi\"], params[\"phi0\"]\n\n        amplitude = A0 * (1 + alpha * t)\n        phase = 2 * np.pi * (f0 * t + 0.5 * f_dot * t**2) + phi0\n        polarization_phase = -2 * psi\n\n        h_true = amplitude * np.exp(1j * phase) * np.exp(1j * polarization_phase)\n\n        # 3. Pipeline 1: Metric-based Reconstruction\n        h_metric = h_true.copy()\n        if params[\"drift\"]:\n            d0 = params[\"drift\"][\"d0\"]\n            d1 = params[\"drift\"][\"d1\"]\n            h_metric += d0 + d1 * t\n\n        # 4. Pipeline 2: Curvature-based Reconstruction\n        # 4a. Construct Psi4 from h_true\n        freq = np.fft.fftfreq(N, dt)\n        omega = 2 * np.pi * freq\n        \n        h_true_tilde = np.fft.fft(h_true)\n        psi4_tilde = -(omega**2) * h_true_tilde\n        psi4 = np.fft.ifft(psi4_tilde)\n\n        # 4b. Reconstruct h_curv from Psi4\n        psi4_tilde_recomp = np.fft.fft(psi4) # Recompute for clarity\n        omega_cut = 2 * np.pi * f_cut\n\n        # Create integration kernel with regularization\n        integration_kernel = np.zeros_like(omega, dtype=np.float64)\n        valid_indices = np.abs(omega) >= omega_cut\n        # Use np.divide to handle division by zero safely\n        integration_kernel[valid_indices] = np.divide(\n            -1.0, \n            omega[valid_indices]**2, \n            where=(omega[valid_indices] != 0)\n        )\n\n        h_curv_tilde = psi4_tilde_recomp * integration_kernel\n        h_curv = np.fft.ifft(h_curv_tilde)\n\n        # 5. Reconciliation and Alignment\n        delta_h = h_metric - h_curv\n        \n        # Design matrix for linear fit (constant and linear term)\n        X = np.vstack([np.ones(N), t]).T\n\n        # Solve for real and imaginary parts of coefficients c0, c1\n        c_real, _, _, _ = np.linalg.lstsq(X, np.real(delta_h), rcond=None)\n        c_imag, _, _, _ = np.linalg.lstsq(X, np.imag(delta_h), rcond=None)\n\n        c0 = c_real[0] + 1j * c_imag[0]\n        c1 = c_real[1] + 1j * c_imag[1]\n        \n        h_aligned = h_curv + c0 + c1 * t\n        \n        # 6. Quantify Agreement\n        delta_inf = np.max(np.abs(h_aligned - h_metric))\n        results.append(f\"{delta_inf:.10e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "3483091"}]}