{"hands_on_practices": [{"introduction": "The first step in applying the Gauss-Codazzi relations is to master the fundamental objects of the 3+1 decomposition. This practice provides a rigorous, hands-on calculation of the lapse, shift, induced metric, and extrinsic curvature for a hyperboloidal slicing of Minkowski spacetime [@problem_id:3491166]. By verifying the momentum constraint from first principles, you will solidify your understanding of how these geometric quantities are interconnected and build a crucial foundation for more complex problems.", "problem": "Consider four-dimensional Minkowski spacetime in spherical coordinates $(t,r,\\theta,\\phi)$ with line element $ds^{2} = - dt^{2} + dr^{2} + r^{2} d\\theta^{2} + r^{2} \\sin^{2}\\theta \\, d\\phi^{2}$. Define a hyperboloidal slicing by the time function $\\tau = t - \\sqrt{r^{2} + \\ell^{2}}$, where $\\ell > 0$ is a constant with dimensions of length. Work in the three-plus-one (3+1) decomposition adapted to the foliation by $\\tau = \\text{constant}$ slices.\n\nStarting from fundamental definitions, proceed as follows:\n- Compute the unit normal $n_{\\mu}$ to the $\\tau = \\text{constant}$ slices and determine the lapse $\\alpha$, the shift $\\beta^{i}$, and the induced spatial metric $h_{ij}$ on the slices in the coordinate basis $(r,\\theta,\\phi)$.\n- Using the definition $K_{ij} = - h_{i}{}^{\\mu} h_{j}{}^{\\nu} \\nabla_{\\mu} n_{\\nu}$, compute the extrinsic curvature $K_{ij}$ on the slices and its trace $K = h^{ij} K_{ij}$.\n- With $D_{j}$ denoting the spatial covariant derivative compatible with $h_{ij}$, evaluate the momentum constraint $D_{j} \\!\\left( K^{ij} - h^{ij} K \\right)$ explicitly in the coordinate basis $(r,\\theta,\\phi)$.\n\nExpress your final answer as the three components of $D_{j} \\!\\left( K^{ij} - h^{ij} K \\right)$ in the order $(r,\\theta,\\phi)$, formatted as a single row matrix using the $\\pmatrix$ environment. No rounding is required, and no units should appear in the final expression.", "solution": "The problem asks us to validate the momentum constraint for a specific hyperboloidal slicing of Minkowski spacetime. This is a standard exercise in the 3+1 (ADM) formalism of general relativity. The spacetime is a vacuum solution to Einstein's field equations, so the momentum constraint must be satisfied identically. The task is to show this by explicit calculation.\n\nThe four-dimensional spacetime metric in spherical coordinates $(t,r,\\theta,\\phi)$ is given by\n$$ds^2 = g_{\\mu\\nu} dx^\\mu dx^\\nu = -dt^2 + dr^2 + r^2 d\\theta^2 + r^2 \\sin^2\\theta d\\phi^2$$\nThe metric tensor is $g_{\\mu\\nu} = \\text{diag}(-1, 1, r^2, r^2\\sin^2\\theta)$. Its inverse is $g^{\\mu\\nu} = \\text{diag}(-1, 1, r^{-2}, (r\\sin\\theta)^{-2})$.\n\nThe foliation is defined by the level surfaces of the time function $\\tau = t - \\sqrt{r^2 + \\ell^2}$. Let $S(r) = \\sqrt{r^2+\\ell^2}$ for brevity. So $\\tau = t - S(r)$.\n\n**Part 1: Compute $n_{\\mu}$, $\\alpha$, $\\beta^{i}$, and $h_{ij}$**\n\nThe covector normal to the slices $\\tau = \\text{constant}$ is proportional to the gradient $\\partial_\\mu \\tau$.\n$$\\partial_\\mu \\tau = (\\partial_t \\tau, \\partial_r \\tau, \\partial_\\theta \\tau, \\partial_\\phi \\tau) = (1, -\\frac{r}{S(r)}, 0, 0)$$\nThe squared norm of this covector is $g^{\\mu\\nu}(\\partial_\\mu \\tau)(\\partial_\\nu \\tau) = (-1)(1)^2 + (1)(-\\frac{r}{S})^2 = -1 + \\frac{r^2}{r^2+\\ell^2} = -\\frac{\\ell^2}{r^2+\\ell^2}$.\nThe unit normal covector $n_\\mu$ must satisfy $n_\\mu n^\\mu = -1$. We choose the future-pointing normal. The standard convention yields:\n$$n_\\mu = -\\frac{\\partial_\\mu \\tau}{\\sqrt{-g^{\\alpha\\beta}\\partial_\\alpha\\tau \\partial_\\beta\\tau}} = -\\frac{(1, -r/S, 0, 0)}{\\ell/S} = \\left(-\\frac{S}{\\ell}, \\frac{r}{\\ell}, 0, 0\\right)$$\nThe corresponding contravariant unit normal vector is $n^\\mu = g^{\\mu\\nu}n_\\nu$:\n$$n^\\mu = \\left(\\frac{S}{\\ell}, \\frac{r}{\\ell}, 0, 0\\right)$$\n\nThe lapse function $\\alpha$ and shift vector $\\beta^\\mu$ are defined by the decomposition of the time-evolution vector field $t^\\mu = (\\partial/\\partial t)^\\mu = (1, 0, 0, 0)^\\mu$ as $t^\\mu = \\alpha n^\\mu + \\beta^\\mu$, where $\\beta^\\mu$ is tangent to the slices ($n_\\mu \\beta^\\mu=0$).\nThe lapse is $\\alpha = -n_\\mu t^\\mu = -n_t = S/\\ell = \\frac{\\sqrt{r^2+\\ell^2}}{\\ell}$.\nThe shift vector (in 4D components) is $\\beta^\\mu = t^\\mu - \\alpha n^\\mu$:\n$$\\beta^\\mu = (1, 0, 0, 0)^\\mu - \\frac{S}{\\ell} \\left(\\frac{S}{\\ell}, \\frac{r}{\\ell}, 0, 0\\right)^\\mu = \\left(1-\\frac{S^2}{\\ell^2}, -\\frac{rS}{\\ell^2}, 0, 0\\right)^\\mu = \\left(-\\frac{r^2}{\\ell^2}, -\\frac{r\\sqrt{r^2+\\ell^2}}{\\ell^2}, 0, 0\\right)^\\mu$$\nThe shift vector components $\\beta^i$ in the spatial coordinate basis $(r,\\theta,\\phi)$ must be projected from $\\beta^\\mu$. The tangent vectors to the slice are $X^\\mu_{,i} = \\partial X^\\mu/\\partial x^i$. The slice is a surface $t(r) = \\tau_0 + S(r)$, so $X^\\mu = (S(r), r, \\theta, \\phi)$.\n$X^\\mu_{,r} = (S'(r), 1, 0, 0) = (r/S, 1, 0, 0)$, $X^\\mu_{,\\theta}=(0,0,1,0)$, $X^\\mu_{,\\phi}=(0,0,0,1)$.\nThe spatial vector $\\beta^i$ is defined by $\\beta^\\mu = \\beta^i X^\\mu_{,i}$.\nFrom the $\\theta$ and $\\phi$ components of $\\beta^\\mu$, we see $\\beta^\\theta = 0$ and $\\beta^\\phi=0$.\nFrom the $r$ component: $\\beta^r = -\\frac{r\\sqrt{r^2+\\ell^2}}{\\ell^2}$. We verify this with the $t$ component: $\\beta^t = \\beta^r (r/S) = (-\\frac{rS}{\\ell^2})(\\frac{r}{S}) = -\\frac{r^2}{\\ell^2}$. This is consistent. So, $\\beta^i = (-\\frac{r\\sqrt{r^2+\\ell^2}}{\\ell^2}, 0, 0)$.\n\nThe induced spatial metric $h_{ij}$ on the slices is given by $h_{ij} = g_{\\mu\\nu} X^{\\mu}_{,i} X^{\\nu}_{,j}$.\n$$h_{rr} = g_{\\mu\\nu} X^\\mu_{,r} X^\\nu_{,r} = g_{tt}(r/S)^2 + g_{rr}(1)^2 = -1 \\cdot \\frac{r^2}{S^2} + 1 = \\frac{\\ell^2}{S^2} = \\frac{\\ell^2}{r^2+\\ell^2}$$\n$$h_{\\theta\\theta} = g_{\\mu\\nu} X^\\mu_{,\\theta} X^\\nu_{,\\theta} = g_{\\theta\\theta}(1)^2 = r^2$$\n$$h_{\\phi\\phi} = g_{\\mu\\nu} X^\\mu_{,\\phi} X^\\nu_{,\\phi} = g_{\\phi\\phi}(1)^2 = r^2\\sin^2\\theta$$\nAll off-diagonal components are zero. So, $h_{ij} = \\text{diag}(\\frac{\\ell^2}{r^2+\\ell^2}, r^2, r^2\\sin^2\\theta)$.\n\n**Part 2: Compute $K_{ij}$ and $K$**\n\nThe extrinsic curvature is $K_{ij} = -h_i{}^\\mu h_j{}^\\nu \\nabla_\\mu n_\\nu = -X^\\mu_{,i} X^\\nu_{,j} \\nabla_\\mu n_\\nu$. We need the covariant derivatives $\\nabla_\\mu n_\\nu = \\partial_\\mu n_\\nu - \\Gamma^\\lambda_{\\mu\\nu} n_\\lambda$ in Minkowski spacetime. The non-zero Christoffel symbols in spherical coordinates are $\\Gamma^r_{\\theta\\theta}=-r$, $\\Gamma^r_{\\phi\\phi}=-r\\sin^2\\theta$, $\\Gamma^\\theta_{r\\theta}=1/r$, $\\Gamma^\\theta_{\\phi\\phi}=-\\sin\\theta\\cos\\theta$, $\\Gamma^\\phi_{r\\phi}=1/r$, $\\Gamma^\\phi_{\\theta\\phi}=\\cot\\theta$.\nThe covector $n_\\mu$ has only $t$ and $r$ components, $n_t = -S/\\ell$ and $n_r=r/\\ell$.\n$$K_{rr} = -X^\\mu_{,r} X^\\nu_{,r} \\nabla_\\mu n_\\nu = - (X^t_{,r}X^r_{,r}\\nabla_t n_r + X^r_{,r}X^t_{,r}\\nabla_r n_t + X^r_{,r}X^r_{,r}\\nabla_r n_r + \\dots)$$\nSince $n_\\mu$ is independent of $t$, $\\partial_t n_\\nu=0$ and $\\Gamma^\\lambda_{t\\nu}=0$, so $\\nabla_t n_\\nu = 0$.\n$\\nabla_r n_t = \\partial_r n_t - \\Gamma^\\lambda_{rt}n_\\lambda = \\partial_r(-S/\\ell) = -r/(\\ell S)$.\n$\\nabla_r n_r = \\partial_r n_r - \\Gamma^\\lambda_{rr}n_\\lambda = \\partial_r(r/\\ell) = 1/\\ell$.\n$$K_{rr} = - \\left( (1)\\left(\\frac{r}{S}\\right)\\left(-\\frac{r}{\\ell S}\\right) + (1)(1)\\left(\\frac{1}{\\ell}\\right) \\right) = - \\left(-\\frac{r^2}{\\ell S^2} + \\frac{1}{\\ell}\\right) = - \\frac{-r^2+S^2}{\\ell S^2} = -\\frac{\\ell^2}{\\ell S^2} = -\\frac{\\ell}{r^2+\\ell^2}$$\nFor $K_{\\theta\\theta}$: $\\nabla_\\theta n_\\theta = \\partial_\\theta n_\\theta - \\Gamma^\\lambda_{\\theta\\theta}n_\\lambda = 0 - \\Gamma^r_{\\theta\\theta}n_r = -(-r)(r/\\ell) = r^2/\\ell$.\n$$K_{\\theta\\theta} = -X^\\theta_{,\\theta}X^\\theta_{,\\theta}\\nabla_\\theta n_\\theta = - (1)(1)(r^2/\\ell) = -r^2/\\ell$$\nFor $K_{\\phi\\phi}$: $\\nabla_\\phi n_\\phi = \\partial_\\phi n_\\phi - \\Gamma^\\lambda_{\\phi\\phi}n_\\lambda = 0 - \\Gamma^r_{\\phi\\phi}n_r = -(-r\\sin^2\\theta)(r/\\ell) = r^2\\sin^2\\theta/\\ell$.\n$$K_{\\phi\\phi} = -X^\\phi_{,\\phi}X^\\phi_{,\\phi}\\nabla_\\phi n_\\phi = -(1)(1)(r^2\\sin^2\\theta/\\ell) = -r^2\\sin^2\\theta/\\ell$$\nThe off-diagonal terms are zero. The extrinsic curvature tensor is $K_{ij} = \\text{diag}(-\\frac{\\ell}{r^2+\\ell^2}, -\\frac{r^2}{\\ell}, -\\frac{r^2\\sin^2\\theta}{\\ell})$.\n\nThe trace is $K=h^{ij}K_{ij}$. The inverse spatial metric is $h^{ij} = \\text{diag}(\\frac{r^2+\\ell^2}{\\ell^2}, \\frac{1}{r^2}, \\frac{1}{r^2\\sin^2\\theta})$.\n$$K = \\left(\\frac{r^2+\\ell^2}{\\ell^2}\\right)\\left(-\\frac{\\ell}{r^2+\\ell^2}\\right) + \\left(\\frac{1}{r^2}\\right)\\left(-\\frac{r^2}{\\ell}\\right) + \\left(\\frac{1}{r^2\\sin^2\\theta}\\right)\\left(-\\frac{r^2\\sin^2\\theta}{\\ell}\\right) = -\\frac{1}{\\ell} - \\frac{1}{\\ell} - \\frac{1}{\\ell} = -\\frac{3}{\\ell}$$\n\n**Part 3: Evaluate the momentum constraint $D_j(K^{ij} - h^{ij}K)$**\n\nLet $S^{ij} = K^{ij} - h^{ij}K$. First we compute its components.\n$K^{ij}=h^{ik}h^{jl}K_{kl}$, which for a diagonal metric is $K^{ii}=(h^{ii})^2 K_{ii}$.\n$$K^{rr} = \\left(\\frac{r^2+\\ell^2}{\\ell^2}\\right)^2 \\left(-\\frac{\\ell}{r^2+\\ell^2}\\right) = -\\frac{(r^2+\\ell^2)}{\\ell^3}$$\n$$K^{\\theta\\theta} = \\left(\\frac{1}{r^2}\\right)^2 \\left(-\\frac{r^2}{\\ell}\\right) = -\\frac{1}{r^2\\ell}$$\n$$K^{\\phi\\phi} = \\left(\\frac{1}{r^2\\sin^2\\theta}\\right)^2 \\left(-\\frac{r^2\\sin^2\\theta}{\\ell}\\right) = -\\frac{1}{r^2\\ell\\sin^2\\theta}$$\nNow we compute $S^{ij}$.\n$$S^{rr} = K^{rr} - h^{rr}K = -\\frac{r^2+\\ell^2}{\\ell^3} - \\frac{r^2+\\ell^2}{\\ell^2}\\left(-\\frac{3}{\\ell}\\right) = \\frac{2(r^2+\\ell^2)}{\\ell^3}$$\n$$S^{\\theta\\theta} = K^{\\theta\\theta} - h^{\\theta\\theta}K = -\\frac{1}{r^2\\ell} - \\frac{1}{r^2}\\left(-\\frac{3}{\\ell}\\right) = \\frac{2}{r^2\\ell}$$\n$$S^{\\phi\\phi} = K^{\\phi\\phi} - h^{\\phi\\phi}K = -\\frac{1}{r^2\\ell\\sin^2\\theta} - \\frac{1}{r^2\\sin^2\\theta}\\left(-\\frac{3}{\\ell}\\right) = \\frac{2}{r^2\\ell\\sin^2\\theta}$$\nThe momentum constraint in vacuum is $D_j S^{ij} = 0$. We verify this. The covariant divergence is $(D_j S^{ij})^i = \\frac{1}{\\sqrt{h}}\\partial_j(\\sqrt{h}S^{ij}) + \\Gamma^i_{jk}S^{jk}$, where $h = \\det(h_{ij}) = \\frac{\\ell^2 r^4\\sin^2\\theta}{r^2+\\ell^2}$, so $\\sqrt{h} = \\frac{\\ell r^2\\sin\\theta}{\\sqrt{r^2+\\ell^2}}$.\n\n$r$-component: $(D_j S^{ij})^r = \\frac{1}{\\sqrt{h}}\\partial_r(\\sqrt{h}S^{rr}) + \\Gamma^r_{rr}S^{rr} + \\Gamma^r_{\\theta\\theta}S^{\\theta\\theta} + \\Gamma^r_{\\phi\\phi}S^{\\phi\\phi}$.\nThe Christoffel symbols for the spatial metric $h_{ij}$ must be computed.\n$\\Gamma^r_{rr} = \\frac{1}{2}h^{rr}\\partial_r h_{rr} = -\\frac{r}{r^2+\\ell^2}$.\n$\\Gamma^r_{\\theta\\theta} = -\\frac{1}{2}h^{rr}\\partial_r h_{\\theta\\theta} = -\\frac{r(r^2+\\ell^2)}{\\ell^2}$.\n$\\Gamma^r_{\\phi\\phi} = -\\frac{1}{2}h^{rr}\\partial_r h_{\\phi\\phi} = -\\frac{r(r^2+\\ell^2)\\sin^2\\theta}{\\ell^2}$.\n$\\sqrt{h}S^{rr} = \\frac{\\ell r^2\\sin\\theta}{\\sqrt{r^2+\\ell^2}}\\frac{2(r^2+\\ell^2)}{\\ell^3} = \\frac{2r^2\\sin\\theta\\sqrt{r^2+\\ell^2}}{\\ell^2}$.\n$\\partial_r(\\sqrt{h}S^{rr}) = \\frac{2\\sin\\theta}{\\ell^2}\\frac{d}{dr}(r^2\\sqrt{r^2+\\ell^2}) = \\frac{2\\sin\\theta(3r^3+2r\\ell^2)}{\\ell^2\\sqrt{r^2+\\ell^2}}$.\n$\\frac{1}{\\sqrt{h}}\\partial_r(\\sqrt{h}S^{rr}) = \\frac{\\sqrt{r^2+\\ell^2}}{\\ell r^2\\sin\\theta} \\frac{2\\sin\\theta(3r^3+2r\\ell^2)}{\\ell^2\\sqrt{r^2+\\ell^2}} = \\frac{2(3r^2+2\\ell^2)}{r\\ell^3}$.\nSumming the terms for $(D_j S^{ij})^r$:\n$$\\frac{2(3r^2+2\\ell^2)}{r\\ell^3} + \\left(-\\frac{r}{r^2+\\ell^2}\\right)\\frac{2(r^2+\\ell^2)}{\\ell^3} + \\left(-\\frac{r(r^2+\\ell^2)}{\\ell^2}\\right)\\frac{2}{r^2\\ell} + \\left(-\\frac{r(r^2+\\ell^2)\\sin^2\\theta}{\\ell^2}\\right)\\frac{2}{r^2\\ell\\sin^2\\theta}$$\n$$= \\frac{6r^2+4\\ell^2}{r\\ell^3} - \\frac{2r^2}{r\\ell^3} - \\frac{2(r^2+\\ell^2)}{r\\ell^3} - \\frac{2(r^2+\\ell^2)}{r\\ell^3} = \\frac{1}{r\\ell^3}(6r^2+4\\ell^2 - 2r^2 - 2r^2-2\\ell^2 - 2r^2-2\\ell^2) = 0$$\n\n$\\theta$-component: $(D_j S^{ij})^\\theta$. Because of spherical symmetry, we expect this component to be related to derivatives wrt $\\theta$. A simpler expression for the divergence of a symmetric tensor is useful: $(D_j S^{ij})^\\theta = \\partial_j S^{\\theta j} + \\Gamma^\\theta_{jk}S^{jk} + \\Gamma^j_{j k} S^{\\theta k}$.\nDue to diagonal $S^{ij}$, this is $\\partial_\\theta S^{\\theta\\theta} + \\Gamma^\\theta_{\\phi\\phi}S^{\\phi\\phi} + \\Gamma^j_{j\\theta}S^{\\theta\\theta}$.\n$S^{\\theta\\theta}$ is independent of $\\theta$, so $\\partial_\\theta S^{\\theta\\theta}=0$.\n$\\Gamma^\\theta_{\\phi\\phi} = -\\frac{1}{2}h^{\\theta\\theta}\\partial_\\theta h_{\\phi\\phi} = -\\sin\\theta\\cos\\theta$.\n$\\Gamma^j_{j\\theta} = \\partial_\\theta(\\ln\\sqrt{h}) = \\cot\\theta$.\nSo, $(D_j S^{ij})^\\theta = 0 + (-\\sin\\theta\\cos\\theta)\\frac{2}{r^2\\ell\\sin^2\\theta} + (\\cot\\theta)\\frac{2}{r^2\\ell} = -\\frac{2\\cot\\theta}{r^2\\ell} + \\frac{2\\cot\\theta}{r^2\\ell} = 0$.\n\n$\\phi$-component: $(D_j S^{ij})^\\phi$. Due to axisymmetry, all quantities are independent of $\\phi$. Thus all partial derivatives $\\partial_\\phi$ vanish. A detailed calculation shows all terms in the divergence expression cancel or are individually zero, leading to $(D_j S^{ij})^\\phi=0$.\n\nThe evaluation of the momentum constraint $D_{j} \\!\\left( K^{ij} - h^{ij} K \\right)$ yields a zero vector. The three components in the $(r,\\theta,\\phi)$ basis are $(0, 0, 0)$.", "answer": "$$\\boxed{\\begin{pmatrix} 0 & 0 & 0 \\end{pmatrix}}$$", "id": "3491166"}, {"introduction": "One of the most powerful applications of the Gauss-Codazzi relations is in validating numerical codes against known analytic solutions. This exercise guides you through a direct computational verification of the Gauss equation for a static slice of the Schwarzschild spacetime [@problem_id:3491214]. By numerically computing both the intrinsic 3-curvature and the projected 4-curvature, you will gain practical experience with the tools used to ensure the accuracy of simulations in numerical relativity.", "problem": "You are asked to implement a numerical consistency check of the Gauss equation in the $3+1$ decomposition for a hypersurface of constant $t$ in a known analytic spacetime. Use the Schwarzschild spacetime in standard Schwarzschild coordinates $\\left(t,r,\\theta,\\phi\\right)$ with geometric units where the gravitational constant and the speed of light are set to $G=c=1$. Consider the $t=\\mathrm{const}$ hypersurfaces with vanishing shift vector and the natural normal one-form. In this static slicing, the extrinsic curvature is identically zero, so the Gauss equation reduces to the equality between the intrinsic three-dimensional Riemann tensor on the hypersurface and the fully spatial projection of the spacetime Riemann tensor.\n\nStart from the following fundamental base and core definitions only:\n- The Schwarzschild line element in standard coordinates, with mass parameter $M$, has metric tensor $g_{\\mu\\nu}$ that is diagonal with components $g_{tt}=-\\left(1-\\dfrac{2M}{r}\\right)$, $g_{rr}=\\left(1-\\dfrac{2M}{r}\\right)^{-1}$, $g_{\\theta\\theta}=r^{2}$, $g_{\\phi\\phi}=r^{2}\\sin^{2}\\theta$.\n- The induced three-metric on $t=\\mathrm{const}$ slices is $\\gamma_{ij}$ given by the spatial block of $g_{\\mu\\nu}$, i.e., $\\gamma_{rr}=\\left(1-\\dfrac{2M}{r}\\right)^{-1}$, $\\gamma_{\\theta\\theta}=r^{2}$, $\\gamma_{\\phi\\phi}=r^{2}\\sin^{2}\\theta$.\n- The Christoffel symbols of the Levi-Civita connection for a metric $g_{\\mu\\nu}$ are defined by $\\Gamma^{\\alpha}_{\\ \\beta\\gamma}=\\dfrac{1}{2}g^{\\alpha\\delta}\\left(\\partial_{\\beta}g_{\\gamma\\delta}+\\partial_{\\gamma}g_{\\beta\\delta}-\\partial_{\\delta}g_{\\beta\\gamma}\\right)$, and similarly for the three-metric $\\gamma_{ij}$.\n- The Riemann curvature tensor is defined by $R^{\\alpha}_{\\ \\beta\\gamma\\delta}=\\partial_{\\gamma}\\Gamma^{\\alpha}_{\\ \\beta\\delta}-\\partial_{\\delta}\\Gamma^{\\alpha}_{\\ \\beta\\gamma}+\\Gamma^{\\alpha}_{\\ \\gamma\\mu}\\Gamma^{\\mu}_{\\ \\beta\\delta}-\\Gamma^{\\alpha}_{\\ \\delta\\mu}\\Gamma^{\\mu}_{\\ \\beta\\gamma}$, and similarly in three dimensions with Latin indices.\n\nImplement the following purely mathematical and algorithmic tasks:\n1. Implement numerical central-difference estimators for partial derivatives of the metric components with respect to coordinates, using symmetric steps of size $h_{a}$ along each coordinate $x^{a}$. Treat the $4$-dimensional metric $g_{\\mu\\nu}(t,r,\\theta,\\phi)$ and the $3$-dimensional metric $\\gamma_{ij}(r,\\theta,\\phi)$ as functions of their coordinates and compute their Christoffel symbols from the numerically estimated metric derivatives.\n2. Using central differences applied to the Christoffel symbols, numerically estimate the derivatives that enter the definition of the Riemann tensor and assemble the full $4$-dimensional tensor $R_{\\mu\\nu\\rho\\sigma}$ and the $3$-dimensional tensor ${}^{(3)}\\!R_{ijkl}$ at a point. You must lower indices using the metric at the evaluation point.\n3. Construct the fully spatial projection of the $4$-dimensional Riemann tensor onto the $t=\\mathrm{const}$ hypersurface tangents by selecting its components with all indices in the spatial set $\\{r,\\theta,\\phi\\}$ (i.e., $\\mu,\\nu,\\rho,\\sigma \\in \\{r,\\theta,\\phi\\}$) to form an array $R^{\\mathrm{proj}}_{ijkl}$ with the index order aligned to $(r,\\theta,\\phi)$.\n4. Because the slicing is static and time-symmetric, use $K_{ij}=0$ and therefore check the equality between ${}^{(3)}\\!R_{ijkl}$ and $R^{\\mathrm{proj}}_{ijkl}$. Quantify the agreement by the dimensionless validation metric\n$$\n\\varepsilon = \\frac{\\left\\|\\,{}^{(3)}\\!R_{ijkl}-R^{\\mathrm{proj}}_{ijkl}\\right\\|_{F}}{\\left\\|\\,{}^{(3)}\\!R_{ijkl}\\right\\|_{F}+\\left\\|R^{\\mathrm{proj}}_{ijkl}\\right\\|_{F}+\\delta},\n$$\nwhere $\\left\\|\\cdot\\right\\|_{F}$ denotes the Frobenius norm and $\\delta$ is a small positive constant to avoid division by zero. Use $\\delta=10^{-30}$.\n\nNumerical details and constraints:\n- Use central differences with step sizes $h_{t}$, $h_{r}$, $h_{\\theta}$, $h_{\\phi}$ for the $4$-dimensional quantities and step sizes $h_{r}$, $h_{\\theta}$, $h_{\\phi}$ for the $3$-dimensional quantities. All angles must be treated in radians.\n- Choose evaluation points away from coordinate singularities. Specifically, avoid $r\\le 2M$ and $\\theta\\in\\{0,\\pi\\}$ in the test suite. Your program should implement the metric exactly using the analytic Schwarzschild formula but must estimate derivatives numerically as described above.\n- The final outputs are dimensionless floating-point numbers, so no physical unit specification is required for the answers.\n\nTest suite and required final output format:\n- Implement your program to evaluate the validation metric $\\varepsilon$ for the following five test cases. Each test case is a tuple $\\left(M,r,\\theta,\\phi,h_{t},h_{r},h_{\\theta},h_{\\phi}\\right)$, with angles in radians:\n  1. $\\left(1.0,\\,10.0,\\,\\frac{\\pi}{3},\\,0.7,\\,10^{-6},\\,10^{-5}\\cdot 10.0,\\,10^{-6},\\,10^{-6}\\right)$\n  2. $\\left(1.0,\\,2.1,\\,1.2,\\,2.0,\\,10^{-6},\\,10^{-5}\\cdot 2.1,\\,10^{-6},\\,10^{-6}\\right)$\n  3. $\\left(1.0,\\,6.0,\\,\\frac{\\pi}{2},\\,0.1,\\,10^{-6},\\,10^{-5}\\cdot 6.0,\\,10^{-6},\\,10^{-6}\\right)$\n  4. $\\left(1.0,\\,100.0,\\,2.0,\\,3.0,\\,10^{-6},\\,10^{-5}\\cdot 100.0,\\,10^{-6},\\,10^{-6}\\right)$\n  5. $\\left(1.0,\\,8.0,\\,0.05,\\,1.0,\\,10^{-6},\\,10^{-5}\\cdot 8.0,\\,10^{-6},\\,10^{-6}\\right)$\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $\\left[\\varepsilon_{1},\\varepsilon_{2},\\varepsilon_{3},\\varepsilon_{4},\\varepsilon_{5}\\right]$, where each $\\varepsilon_{k}$ is the validation metric for test case $k$.\n\nYour implementation must be self-contained and must not require any external input. Angles must be interpreted in radians throughout, and all computations should use double-precision floating-point arithmetic. Ensure your numerical steps do not cross the event horizon $r=2M$ in any central-difference stencil. If necessary, reduce step sizes internally to maintain $r-h_{r}>2M$ at all evaluation points.", "solution": "The problem requires a numerical verification of the Gauss-Codazzi equations for a specific scenario within the framework of General Relativity's $3+1$ decomposition. We are to consider a static, constant-time ($t=\\mathrm{const}$) hypersurface in the Schwarzschild spacetime. The solution involves numerically computing the intrinsic and extrinsic curvature tensors of this hypersurface and verifying that they satisfy the constraint equations.\n\n**1. Theoretical Framework: The Gauss-Codazzi Equations**\n\nThe $3+1$ formalism decomposes the four-dimensional spacetime into a stack of three-dimensional spatial hypersurfaces. The geometry of spacetime is then described in terms of the intrinsic geometry of these slices and how they are embedded in the larger spacetime. The fundamental equations relating the four-dimensional curvature to the three-dimensional geometry are the Gauss-Codazzi equations.\n\nThe Gauss equation relates the intrinsic three-dimensional Riemann tensor of the spatial slice, denoted ${}^{(3)}\\!R_{ijkl}$, to the projection of the four-dimensional spacetime Riemann tensor $R_{\\mu\\nu\\rho\\sigma}$ and the extrinsic curvature of the slice, $K_{ij}$:\n$$\n{}^{(3)}R_{ikjl} = R^{\\perp}_{ikjl} + K_{ik}K_{jl} - K_{il}K_{jk}\n$$\nHere, $R^{\\perp}_{ikjl}$ represents the projection of the $4$-dimensional Riemann tensor onto the spatial hypersurface, given by $R^{\\perp}_{\\alpha\\beta\\gamma\\delta} = \\gamma^i_\\alpha \\gamma^j_\\beta \\gamma^k_\\gamma \\gamma^l_\\delta R_{ijkl}$, where $\\gamma^i_\\alpha$ is the projection operator.\n\n**2. Simplification for the Schwarzschild Static Slice**\n\nThe problem specifies Schwarzschild spacetime in standard coordinates $(t,r,\\theta,\\phi)$ and examines the $t=\\mathrm{const}$ hypersurfaces. The metric is diagonal and time-independent. This slicing is static, meaning the geometry of the spatial slices does not change in time. A key property of such a slice is that its extrinsic curvature vanishes, i.e., $K_{ij}=0$. The extrinsic curvature measures how the normal vectors to the hypersurface change as one moves along the surface, and for a static slicing, they do not change.\n\nWith $K_{ij}=0$, the Gauss equation simplifies dramatically to:\n$$\n{}^{(3)}R_{ikjl} = R^{\\perp}_{ikjl}\n$$\nFurthermore, in the chosen coordinate system, the spatial coordinates $(r,\\theta,\\phi)$ are orthogonal to the time coordinate $t$. The projection of the 4D Riemann tensor simply amounts to selecting the components where all indices are spatial. If we let the Latin indices $i,j,k,l$ range over the spatial coordinates $\\{r,\\theta,\\phi\\}$, the equation to verify becomes a direct equality between the 3D Riemann tensor computed from the slice's intrinsic metric and the purely spatial components of the 4D Riemann tensor:\n$$\n{}^{(3)}R_{ijkl} = R_{ijkl}\n$$\nThis provides a clear, verifiable identity to test numerically.\n\n**3. Computational Strategy**\n\nThe core of the problem is to compute both sides of the simplified Gauss equation numerically and compare them. The fundamental definitions for the geometric objects are provided, and all derivatives must be computed numerically using central finite differences.\n\nThe steps are as follows:\na. **Define the Metrics**: Implement functions that provide the components of the $4$-dimensional spacetime metric $g_{\\mu\\nu}(t,r,\\theta,\\phi)$ and the $3$-dimensional induced spatial metric $\\gamma_{ij}(r,\\theta,\\phi)$ at any given coordinate point. The components are given by the problem statement.\n\nb. **Compute Christoffel Symbols**: The Christoffel symbols, which describe the effects of parallel transport, are computed from the first derivatives of the metric. The definition for the $4$-dimensional symbols is:\n$$\n\\Gamma^{\\alpha}_{\\ \\beta\\gamma} = \\frac{1}{2}g^{\\alpha\\delta}\\left(\\partial_{\\beta}g_{\\gamma\\delta} + \\partial_{\\gamma}g_{\\beta\\delta} - \\partial_{\\delta}g_{\\beta\\gamma}\\right)\n$$\nAn analogous formula holds for the $3$-dimensional symbols ${}^{(3)}\\!\\Gamma^{i}_{\\ jk}$ using the spatial metric $\\gamma_{ij}$. All partial derivatives $\\partial_{\\alpha}g_{\\mu\\nu}$ are calculated numerically using the central difference formula: $f'(x) \\approx \\frac{f(x+h) - f(x-h)}{2h}$.\n\nc. **Compute Riemann Curvature Tensors**: The Riemann tensor, capturing the curvature of the manifold, is defined in terms of the Christoffel symbols and their first derivatives. The definition for the $4$-dimensional tensor is:\n$$\nR^{\\alpha}_{\\ \\beta\\gamma\\delta} = \\partial_{\\gamma}\\Gamma^{\\alpha}_{\\ \\beta\\delta} - \\partial_{\\delta}\\Gamma^{\\alpha}_{\\ \\beta\\gamma} + \\Gamma^{\\alpha}_{\\ \\gamma\\mu}\\Gamma^{\\mu}_{\\ \\beta\\delta} - \\Gamma^{\\alpha}_{\\ \\delta\\mu}\\Gamma^{\\mu}_{\\ \\beta\\gamma}\n$$\nAgain, an analogous formula holds for ${}^{(3)}\\!R^{i}_{\\ jkl}$. The derivatives of the Christoffel symbols, such as $\\partial_{\\gamma}\\Gamma^{\\alpha}_{\\ \\beta\\delta}$, are also computed using central differences. This involves evaluating the Christoffel symbols at slightly displaced points, which is a computationally intensive but direct implementation of the definition. After computing the tensor with one upper index, we lower it using the metric: $R_{\\alpha\\beta\\gamma\\delta} = g_{\\alpha\\mu}R^{\\mu}_{\\ \\beta\\gamma\\delta}$.\n\nd. **Projection and Comparison**: Once both tensors, ${}^{(3)}\\!R_{ijkl}$ and $R_{\\mu\\nu\\rho\\sigma}$, are computed at the specified evaluation point, we extract the purely spatial components of $R_{\\mu\\nu\\rho\\sigma}$ to form the projected tensor $R^{\\mathrm{proj}}_{ijkl}$. In this case, this simply means taking the sub-tensor where all four indices correspond to $(r,\\theta,\\phi)$.\n\ne. **Validation Metric**: The agreement between the two computed tensors is quantified using the provided dimensionless metric $\\varepsilon$:\n$$\n\\varepsilon = \\frac{\\left\\|\\,{}^{(3)}\\!R_{ijkl}-R^{\\mathrm{proj}}_{ijkl}\\right\\|_{F}}{\\left\\|\\,{}^{(3)}\\!R_{ijkl}\\right\\|_{F}+\\left\\|R^{\\mathrm{proj}}_{ijkl}\\right\\|_{F}+\\delta}\n$$\nwhere $\\left\\|\\cdot\\right\\|_{F}$ is the Frobenius norm and $\\delta=10^{-30}$ is a regularization constant. This metric measures the relative error between the two tensors. A small value of $\\varepsilon$ indicates good agreement and serves as a successful consistency check of our numerical implementation against the known physics. The non-zero value of $\\varepsilon$ stems from the truncation error inherent in the finite difference approximations.\n\nThe implementation encapsulates these steps into a set of functions. A top-level function iterates through the test cases, calling a core calculation routine for each set of parameters. This routine orchestrates the computation of the two Riemann tensors and the final error metric $\\varepsilon$. Special care is taken in the implementation to handle function closures correctly when creating functions for numerical differentiation inside loops.", "answer": "```python\nimport numpy as np\n\ndef schwarzschild_metric_4d(coords, M):\n    \"\"\"\n    Computes the 4D Schwarzschild metric tensor g_mu_nu.\n    Indices: 0=t, 1=r, 2=theta, 3=phi.\n    \"\"\"\n    t, r, theta, phi = coords\n    if r <= 2 * M or theta == 0 or theta == np.pi:\n        return np.full((4, 4), np.nan) # Handle singularity\n    \n    f = 1 - 2 * M / r\n    g = np.zeros((4, 4))\n    g[0, 0] = -f\n    g[1, 1] = 1 / f\n    g[2, 2] = r**2\n    g[3, 3] = r**2 * np.sin(theta)**2\n    return g\n\ndef spatial_metric_3d(coords, M):\n    \"\"\"\n    Computes the 3D spatial metric tensor gamma_ij on a t=const slice.\n    Indices: 0=r, 1=theta, 2=phi.\n    \"\"\"\n    r, theta, phi = coords\n    if r <= 2 * M or theta == 0 or theta == np.pi:\n        return np.full((3, 3), np.nan) # Handle singularity\n\n    f = 1 - 2 * M / r\n    gamma = np.zeros((3, 3))\n    gamma[0, 0] = 1 / f\n    gamma[1, 1] = r**2\n    gamma[2, 2] = r**2 * np.sin(theta)**2\n    return gamma\n\ndef numerical_derivative(func, point, var_idx, h):\n    \"\"\"\n    Computes the central finite difference derivative of a function.\n    'func' takes one argument: a coordinate tuple/array.\n    \"\"\"\n    p_plus = np.array(point, dtype=float)\n    p_minus = np.array(point, dtype=float)\n    p_plus[var_idx] += h\n    p_minus[var_idx] -= h\n    return (func(p_plus) - func(p_minus)) / (2 * h)\n\ndef make_metric_component_func(metric_func, M, i, j):\n    \"\"\"Factory to create a function that returns a single metric component.\"\"\"\n    def metric_component_at_p(p):\n        return metric_func(p, M)[i, j]\n    return metric_component_at_p\n\ndef compute_christoffel(metric_func, dim, point, M, h_vec):\n    \"\"\"Computes Christoffel symbols Gamma^i_{jk} numerically.\"\"\"\n    g = metric_func(point, M)\n    g_inv = np.linalg.inv(g)\n\n    # dg[k, i, j] = partial_k g_ij\n    dg = np.zeros((dim, dim, dim))\n    for k in range(dim):\n        for i in range(dim):\n            for j in range(dim):\n                # Create a function of position for the specific metric component\n                f_ij = make_metric_component_func(metric_func, M, i, j)\n                dg[k, i, j] = numerical_derivative(f_ij, point, k, h_vec[k])\n\n    # Gamma^alpha_{beta,gamma}\n    gamma_tensor = np.zeros((dim, dim, dim))\n    for alpha in range(dim):\n        for beta in range(dim):\n            for iota in range(dim): # iota = gamma in formula\n                sum_val = 0\n                for delta in range(dim):\n                    term1 = dg[beta, iota, delta]   # partial_beta g_{gamma,delta}\n                    term2 = dg[iota, beta, delta]   # partial_gamma g_{beta,delta}\n                    term3 = -dg[delta, beta, iota]  # -partial_delta g_{beta,gamma}\n                    sum_val += g_inv[alpha, delta] * (term1 + term2 + term3)\n                gamma_tensor[alpha, beta, iota] = 0.5 * sum_val\n    return gamma_tensor\n\ndef make_gamma_func(metric_func, dim, M, h_vec, i, j, k):\n    \"\"\"Factory for a function returning a single Christoffel symbol component.\"\"\"\n    def gamma_component_at_p(p):\n        temp_gamma = compute_christoffel(metric_func, dim, p, M, h_vec)\n        return temp_gamma[i, j, k]\n    return gamma_component_at_p\n\ndef compute_riemann(metric_func, dim, point, M, h_vec):\n    \"\"\"Computes the Riemann tensor R_{ijkl} numerically.\"\"\"\n    christoffel_at_point = compute_christoffel(metric_func, dim, point, M, h_vec)\n\n    # dGamma[k, i, j, l] = partial_k Gamma^i_{jl}\n    dGamma = np.zeros((dim, dim, dim, dim))\n    for k in range(dim):\n        for i in range(dim):\n            for j in range(dim):\n                for l in range(dim):\n                    gamma_ijl_func = make_gamma_func(metric_func, dim, M, h_vec, i, j, l)\n                    dGamma[k, i, j, l] = numerical_derivative(gamma_ijl_func, point, k, h_vec[k])\n    \n    # R^i_{jkl}\n    R_upper = np.zeros((dim, dim, dim, dim))\n    for i in range(dim):\n        for j in range(dim):\n            for k in range(dim):\n                for l in range(dim):\n                    term1 = dGamma[k, i, j, l]      # partial_k Gamma^i_{jl}\n                    term2 = -dGamma[l, i, j, k]     # -partial_l Gamma^i_{jk}\n                    term3 = np.einsum('m,m->', christoffel_at_point[i, k, :], christoffel_at_point[:, j, l])\n                    term4 = -np.einsum('m,m->', christoffel_at_point[i, l, :], christoffel_at_point[:, j, k])\n                    R_upper[i, j, k, l] = term1 + term2 + term3 + term4\n\n    # Lower the first index: R_{ijkl} = g_{im} R^m_{jkl}\n    g_at_point = metric_func(point, M)\n    R_lower = np.einsum('im,mjkl->ijkl', g_at_point, R_upper)\n    return R_lower\n\ndef calculate_epsilon(M, r, theta, phi, ht, hr, htheta, hphi):\n    \"\"\"Main function to calculate the validation metric epsilon for a given case.\"\"\"\n    \n    # Check for stencil crossing the event horizon\n    current_hr = hr\n    if r - current_hr <= 2 * M:\n        # Reduce step size to stay outside the horizon. (Not needed for test cases)\n        current_hr = (r - 2 * M) / 2.0 \n    \n    t = 0.0 # Metric is static, t is arbitrary.\n    point_4d = np.array([t, r, theta, phi])\n    h_4d = np.array([ht, current_hr, htheta, hphi])\n    \n    point_3d = np.array([r, theta, phi])\n    h_3d = np.array([current_hr, htheta, hphi])\n\n    # 1. Compute 3D Riemann tensor\n    R_3d = compute_riemann(spatial_metric_3d, 3, point_3d, M, h_3d)\n\n    # 2. Compute 4D Riemann tensor\n    R_4d = compute_riemann(schwarzschild_metric_4d, 4, point_4d, M, h_4d)\n    \n    # 3. Project 4D Riemann tensor to the spatial slice\n    R_proj = R_4d[1:, 1:, 1:, 1:]\n\n    # 4. Calculate the validation metric\n    delta = 1e-30\n    diff_R = R_3d - R_proj\n    \n    norm_diff = np.linalg.norm(diff_R)\n    norm_3d = np.linalg.norm(R_3d)\n    norm_proj = np.linalg.norm(R_proj)\n    \n    epsilon = norm_diff / (norm_3d + norm_proj + delta)\n    return epsilon\n\ndef solve():\n    \"\"\"\n    Main solver function that runs the test suite and prints results.\n    \"\"\"\n    test_cases = [\n        (1.0, 10.0, np.pi/3, 0.7, 1e-6, 1e-5 * 10.0, 1e-6, 1e-6),\n        (1.0, 2.1, 1.2, 2.0, 1e-6, 1e-5 * 2.1, 1e-6, 1e-6),\n        (1.0, 6.0, np.pi/2, 0.1, 1e-6, 1e-5 * 6.0, 1e-6, 1e-6),\n        (1.0, 100.0, 2.0, 3.0, 1e-6, 1e-5 * 100.0, 1e-6, 1e-6),\n        (1.0, 8.0, 0.05, 1.0, 1e-6, 1e-5 * 8.0, 1e-6, 1e-6)\n    ]\n    \n    results = []\n    for params in test_cases:\n        M, r, theta, phi, ht, hr, htheta, hphi = params\n        epsilon = calculate_epsilon(M, r, theta, phi, ht, hr, htheta, hphi)\n        results.append(epsilon)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "3491214"}, {"introduction": "The Codazzi relation is not merely a geometric identity; it gives rise to the momentum constraint, which has profound implications for constructing numerical schemes. This practice explores how the momentum constraint can be recast into a flux-conservative form, a cornerstone of stable finite-volume methods [@problem_id:3491204]. Implementing and verifying this formulation provides direct insight into how the fundamental geometry of spacetime translates into practical, robust algorithms for numerical evolution.", "problem": "You are asked to use the Gauss-Codazzi relations in the three-plus-one ($3+1$) decomposition of General Relativity to derive, implement, and verify a flux form of the momentum constraint in a flat spatial metric. The task is purely mathematical and algorithmic: starting from geometric fundamentals, obtain a divergence-form suitable for a finite-volume method, implement it, and verify an integral identity numerically.\n\nGiven a spatial hypersurface with metric $\\,\\gamma_{ij}\\,$ and extrinsic curvature $\\,K_{ij}\\,$ the Codazzi equation connects spatial covariant derivatives of $\\,K_{ij}\\,$ to four-dimensional curvature. Starting only from:\n- the Codazzi equation (projected onto the hypersurface) and the Einstein field equations,\n- metric compatibility $\\,D_k \\gamma_{ij} = 0\\,$ for the Levi-Civita connection,\n- the definition of trace $\\,K = \\gamma^{ij} K_{ij}\\,$\nderive a flux-form of the momentum constraint in the flat-metric limit where $\\,\\gamma_{ij} = \\delta_{ij}\\,$ and Christoffel symbols vanish. Specifically, obtain a rank-$\\,(1,1)\\,$ flux whose divergence equals the left-hand side $\\,D_j K^{ij} - D^i K\\,$ in that limit.\n\nThen, embed this flux-form in a conservative finite-volume method on a rectangular domain in two spatial dimensions. Use a uniform Cartesian mesh with cell centers and define numerical face fluxes from cell-centered values by arithmetic averaging at interior faces and single-sided copy at boundaries. In this flat-metric setting, the finite-volume method yields an exact discrete divergence theorem by telescoping of interior face contributions.\n\nVerification target: For each test case listed below, compute\n- the domain-integrated quantity $\\,\\int_{\\Omega} \\left(D_j K^{ij} - D^i K\\right)\\, dA\\,$ using the finite-volume divergence of the derived flux, and\n- the boundary integral $\\,\\int_{\\partial \\Omega} n_j \\,\\mathcal{F}^{ij}\\, ds\\,$ of the same flux (with outward unit normal $\\,n_j\\,$),\nand verify that the two vectors (for $\\,i \\in \\{x,y\\}\\,$) agree to within roundoff. Report, for each test case, a single scalar equal to the maximum absolute componentwise difference between these two vectors. Angles in trigonometric functions are to be interpreted in radians. No physical units are required.\n\nImplementation details to use:\n- Work in two spatial dimensions with coordinates $\\,x\\,$ and $\\,y\\,$. Use the flat spatial metric $\\,\\gamma_{ij} = \\delta_{ij}\\,$ so that $\\,D_j\\,$ reduces to $\\,\\partial_j\\,$.\n- Let $\\,\\Omega = [0,L_x]\\times[0,L_y]\\,$ be the rectangular domain, with uniform grid spacings $\\,\\Delta x = L_x/N_x\\,$ and $\\,\\Delta y = L_y/N_y\\,$ for integers $\\,N_x\\,$ and $\\,N_y\\,$.\n- Use a cell-centered finite-volume layout. Define numerical face fluxes by averaging adjacent cell-centered fluxes on interior faces. On boundary faces, use the adjacent boundary cellâ€™s flux as the face value.\n- For evaluation, treat $\\,K_{ij}\\,$ as symmetric and provide the three independent components $\\,K_{xx}(x,y)\\,$, $\\,K_{xy}(x,y)=K_{yx}(x,y)\\,$, and $\\,K_{yy}(x,y)\\,$. The trace in two dimensions is $\\,K = K_{xx} + K_{yy}\\,$.\n\nTest suite:\n- Case $\\,1\\,$ (happy path, constant field): $\\,L_x = 1\\,$, $\\,L_y = 1\\,$, $\\,N_x = 16\\,$, $\\,N_y = 16\\,$, with\n  $\\,K_{xx}(x,y) = 0.3\\,$,\n  $\\,K_{xy}(x,y) = -0.2\\,$,\n  $\\,K_{yy}(x,y) = 0.5\\,$.\n- Case $\\,2\\,$ (linear field, tests boundary flux aggregation): $\\,L_x = 1\\,$, $\\,L_y = 1\\,$, $\\,N_x = 25\\,$, $\\,N_y = 25\\,$, with\n  $\\,K_{xx}(x,y) = 0.1\\,x + 0.2\\,y + 0.05\\,$,\n  $\\,K_{xy}(x,y) = -0.3\\,x + 0.1\\,y - 0.07\\,$,\n  $\\,K_{yy}(x,y) = 0.2\\,x - 0.4\\,y + 0.09\\,$.\n- Case $\\,3\\,$ (smooth oscillatory field, angles in radians): $\\,L_x = 2\\pi\\,$, $\\,L_y = 2\\pi\\,$, $\\,N_x = 64\\,$, $\\,N_y = 64\\,$, with\n  $\\,K_{xx}(x,y) = \\sin(x) + \\cos(y)\\,$,\n  $\\,K_{xy}(x,y) = \\sin(x+y)\\,$,\n  $\\,K_{yy}(x,y) = \\cos(x) - \\sin(y)\\,$.\n- Case $\\,4\\,$ (quadratic polynomial, edge-case gradients): $\\,L_x = 1\\,$, $\\,L_y = 1\\,$, $\\,N_x = 17\\,$, $\\,N_y = 17\\,$, with\n  $\\,K_{xx}(x,y) = x^2 + y\\,$,\n  $\\,K_{xy}(x,y) = x\\,y\\,$,\n  $\\,K_{yy}(x,y) = y^2 - x\\,$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with no spaces, in the order of the cases above. For example, a valid output looks like $[r_1,r_2,r_3,r_4]$ where each $\\,r_k\\,$ is a floating-point number giving the requested maximum absolute difference for case $\\,k\\,$.", "solution": "The user has provided a problem that requires the derivation and numerical verification of a flux-form for the momentum constraint equation from General Relativity in a simplified setting. The validation and solution are as follows.\n\n### Step 1: Extract Givens\n- **Governing Relations**: The derivation starts from the Codazzi equation (projected onto the hypersurface) and the Einstein field equations.\n- **Fundamental Principles**: Metric compatibility, $D_k \\gamma_{ij} = 0$, for the Levi-Civita connection is assumed.\n- **Definitions**: The trace of the extrinsic curvature is $K = \\gamma^{ij} K_{ij}$.\n- **Problem Context**: The setting is the three-plus-one ($3+1$) decomposition of General Relativity.\n- **Simplification**: The problem is to be solved in the flat-metric limit, where the spatial metric $\\gamma_{ij} = \\delta_{ij}$ and its associated Christoffel symbols vanish.\n- **Derivation Goal**: Derive a rank-$(1,1)$ tensor flux, $\\mathcal{F}^{ij}$, whose divergence equals the momentum constraint source term, $D_j K^{ij} - D^i K$, in the specified flat-metric limit.\n- **Numerical Domain**: A two-dimensional rectangular domain $\\Omega = [0,L_x]\\times[0,L_y]$ with a uniform Cartesian mesh of $N_x \\times N_y$ cells.\n- **Numerical Method**: A cell-centered finite-volume method.\n- **Numerical Flux Rule**: At interior faces, the flux is the arithmetic average of the values in the two adjacent cells. At boundary faces, the flux is a direct copy of the value from the adjacent boundary cell.\n- **Verification Task**: For each test case, compute two vectors:\n    1. The domain integral $\\int_{\\Omega} \\left(D_j K^{ij} - D^i K\\right)\\, dA$ evaluated using the sum of the finite-volume divergences in each cell.\n    2. The boundary integral $\\int_{\\partial \\Omega} n_j \\,\\mathcal{F}^{ij}\\, ds$ evaluated by summing the numerical fluxes over the boundary faces.\n- **Reporting Metric**: The maximum absolute componentwise difference between the two computed vectors.\n- **Test Cases**: Four specific cases are provided, defining the domain size ($L_x, L_y$), grid resolution ($N_x, N_y$), and the functional forms of the independent components of the symmetric extrinsic curvature tensor, $K_{xx}(x,y)$, $K_{xy}(x,y)$, and $K_{yy}(x,y)$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is subjected to a rigorous validation procedure.\n\n- **Scientific Grounding**: The problem is fundamentally sound. It is based on the ADM ($3+1$) formalism of General Relativity, a standard and well-established framework in theoretical physics and numerical relativity. The momentum constraint is one of the fundamental Einstein constraint equations, and its manipulation into a flux-conservative form is a standard technique in designing numerical schemes.\n- **Well-Posedness**: The problem is well-posed. The derivation task is a direct application of tensor calculus in a simplified (flat-space) limit, leading to a unique expression for the flux. The numerical verification task is also well-posed: the numerical method (finite-volume with specified fluxes) is unambiguously defined, the test functions are explicit, and the comparison metric is precise. This guarantees a unique, stable, and meaningful numerical result for each test case, subject to floating-point precision.\n- **Objectivity**: The problem is stated in precise, objective mathematical language, free from ambiguity or subjective interpretation.\n- **Flaw Checklist**: The problem does not violate any of the invalidity criteria. It is scientifically sound, formalizable, complete, and feasible. All terms are well-defined within the context of differential geometry and numerical analysis. The task is a non-trivial application of these principles, requiring both analytical derivation and careful numerical implementation.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A complete solution is provided below.\n\n### Derivation of the Flux-Form\n\nThe quantity of interest is $M^i = D_j K^{ij} - D^i K$, which represents the momentum constraint in vacuum. We work in a flat spatial geometry where the metric is the Kronecker delta, $\\gamma_{ij} = \\delta_{ij}$. This simplification has two key consequences:\n$1$. The Christoffel symbols of the spatial metric are zero, so the covariant derivative $D_j$ reduces to the partial derivative $\\partial_j$.\n$2$. Raising and lowering indices becomes trivial (e.g., $K^{ij} = K_{ij}$, $D^i = \\delta^{ij}D_j = \\partial_i$).\n\nThe expression for $M^i$ thus simplifies to:\n$$M^i = \\partial_j K_{ij} - \\partial_i K$$\nwhere $K$ is the trace, $K = \\delta^{ij}K_{ij} = K_{kk}$ (with summation over $k$). The goal is to write $M^i$ as the divergence of a flux tensor $\\mathcal{F}^{ij}$, i.e., $M^i = \\partial_j \\mathcal{F}^{ij}$.\n\nLet us propose a flux tensor of the form $\\mathcal{F}^{ij} = A K_{ij} + B \\delta_{ij} K$, where $A$ and $B$ are constants. Taking the divergence:\n$$\\partial_j \\mathcal{F}^{ij} = \\partial_j (A K_{ij} + B \\delta_{ij} K) = A \\partial_j K_{ij} + B \\partial_j(\\delta_{ij} K) = A \\partial_j K_{ij} + B \\delta_{ij} \\partial_j K$$\nUsing $\\delta_{ij} \\partial_j = \\partial_i$, we get:\n$$\\partial_j \\mathcal{F}^{ij} = A \\partial_j K_{ij} + B \\partial_i K$$\nComparing this with the target expression $M^i = \\partial_j K_{ij} - \\partial_i K$, we can match the coefficients, yielding $A=1$ and $B=-1$.\nTherefore, the desired flux tensor is:\n$$\\mathcal{F}^{ij} = K_{ij} - \\delta_{ij} K$$\nIn two spatial dimensions with coordinates $(x, y)$, the trace is $K = K_{xx} + K_{yy}$. The components of the flux tensor $\\mathcal{F}$ are:\n$$\n\\mathcal{F}^{xx} = K_{xx} - K = K_{xx} - (K_{xx} + K_{yy}) = -K_{yy} \\\\\n\\mathcal{F}^{xy} = K_{xy} - \\delta_{xy} K = K_{xy} \\\\\n\\mathcal{F}^{yx} = K_{yx} - \\delta_{yx} K = K_{yx} = K_{xy} \\\\\n\\mathcal{F}^{yy} = K_{yy} - K = K_{yy} - (K_{xx} + K_{yy}) = -K_{xx}\n$$\nSo, the flux tensor is given by the matrix $\\mathcal{F} = \\begin{pmatrix} -K_{yy} & K_{xy} \\\\ K_{xy} & -K_{xx} \\end{pmatrix}$.\n\n### Numerical Verification via Discrete Divergence Theorem\n\nThe problem requires a numerical verification of the divergence theorem, which states $\\int_\\Omega \\nabla \\cdot \\mathbf{F} \\, dA = \\oint_{\\partial\\Omega} \\mathbf{F} \\cdot \\mathbf{n} \\, ds$. In our context, for each momentum component $i \\in \\{x, y\\}$, this becomes:\n$$\\int_\\Omega (\\partial_j \\mathcal{F}^{ij}) \\, dA = \\oint_{\\partial\\Omega} \\mathcal{F}^{ij} n_j \\, ds$$\nWe compute the left-hand side (volume integral $V^i$) and the right-hand side (boundary integral $S^i$) using the specified finite-volume scheme and verify their equality.\n\n**1. Volume Integral ($V^i$):**\nThe domain is discretized into $N_x \\times N_y$ cells. The volume integral is the sum of integrals over each cell. For a cell $(k, l)$, the integral of the divergence is approximated by the net flux through its boundary, multiplied by the cell area $\\Delta x \\Delta y$. Summing over all cells:\n$$V^i = \\sum_{k=0}^{N_x-1} \\sum_{l=0}^{N_y-1} (\\text{div}_h \\mathcal{F}^i)_{k,l} \\, \\Delta x \\Delta y$$\nwhere $(\\text{div}_h \\mathcal{F}^i)_{k,l}$ is the discrete divergence for the cell $(k,l)$, calculated using the specified numerical fluxes on its four faces. Due to the telescoping nature of the sum over interior faces, this sum algebraically reduces to the total flux across the domain boundary.\n\n**2. Boundary Integral ($S^i$):**\nThis is computed by summing the numerical fluxes over the boundary faces of the domain. For a boundary face, the numerical flux is prescribed to be the cell-centered value of the adjacent cell. For example, the flux on the right boundary ($x=L_x$) is determined by the values in cells $(k=N_x-1, l)$. The total boundary integral is:\n$$S^i = \\sum_{l=0}^{N_y-1} (\\mathcal{F}^{ix}_{N_x-1,l} - \\mathcal{F}^{ix}_{0,l})\\Delta y + \\sum_{k=0}^{N_x-1} (\\mathcal{F}^{iy}_{k,N_y-1} - \\mathcal{F}^{iy}_{k,0})\\Delta x$$\nwhere $\\mathcal{F}^{ix}$ and $\\mathcal{F}^{iy}$ are the $x$ and $y$ components of the flux vector for the $i$-th momentum component.\n\nThe core of the task is to implement both computations $V^i$ and $S^i$ separately and compare them. Any difference arises purely from the order of floating-point operations.\n\n### Algorithmic Implementation\n\nFor each test case, the algorithm proceeds as follows:\n1.  Define the grid of $N_x \\times N_y$ cell centers $(x_k, y_l)$.\n2.  Evaluate the given functions $K_{xx}, K_{xy}, K_{yy}$ on this grid.\n3.  From these, compute the cell-centered values of the flux tensor components $\\mathcal{F}^{xx}, \\mathcal{F}^{xy}, \\mathcal{F}^{yx}, \\mathcal{F}^{yy}$.\n4.  To compute $V^i = [V^x, V^y]$:\n    a. For each cell, calculate the local discrete divergence using the specified face flux rules (average for interior, copy for boundary). This is done efficiently using NumPy array slicing.\n    b. Sum these local divergences over all cells and multiply by the cell area $\\Delta x \\Delta y$.\n5.  To compute $S^i = [S^x, S^y]$:\n    a. Sum the boundary flux contributions as per the derived formula for $S^i$. This involves summing flux components along the four boundaries of the domain.\n6.  Calculate the final result for the test case as $\\max(|V^x - S^x|, |V^y - S^y|)$.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    test_cases = [\n        {'Lx': 1.0, 'Ly': 1.0, 'Nx': 16, 'Ny': 16, 'Kxx_f': lambda x, y: 0.3, 'Kxy_f': lambda x, y: -0.2, 'Kyy_f': lambda x, y: 0.5},\n        {'Lx': 1.0, 'Ly': 1.0, 'Nx': 25, 'Ny': 25, 'Kxx_f': lambda x, y: 0.1*x + 0.2*y + 0.05, 'Kxy_f': lambda x, y: -0.3*x + 0.1*y - 0.07, 'Kyy_f': lambda x, y: 0.2*x - 0.4*y + 0.09},\n        {'Lx': 2 * np.pi, 'Ly': 2 * np.pi, 'Nx': 64, 'Ny': 64, 'Kxx_f': lambda x, y: np.sin(x) + np.cos(y), 'Kxy_f': lambda x, y: np.sin(x + y), 'Kyy_f': lambda x, y: np.cos(x) - np.sin(y)},\n        {'Lx': 1.0, 'Ly': 1.0, 'Nx': 17, 'Ny': 17, 'Kxx_f': lambda x, y: x**2 + y, 'Kxy_f': lambda x, y: x * y, 'Kyy_f': lambda x, y: y**2 - x}\n    ]\n    results = [solve_case(case) for case in test_cases]\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\ndef solve_case(case):\n    Lx, Ly, Nx, Ny = case['Lx'], case['Ly'], case['Nx'], case['Ny']\n    dx, dy = Lx / Nx, Ly / Ny\n    x = (np.arange(Nx) + 0.5) * dx\n    y = (np.arange(Ny) + 0.5) * dy\n    X, Y = np.meshgrid(x, y, indexing='xy')\n\n    K_xx, K_xy, K_yy = case['Kxx_f'](X, Y), case['Kxy_f'](X, Y), case['Kyy_f'](X, Y)\n    F_xx, F_xy, F_yx, F_yy = -K_yy, K_xy, K_xy, -K_xx\n\n    # --- 1. Compute Volume Integral V using sum of finite-volume divergences ---\n    flux_x_at_x_faces = np.zeros((Ny, Nx + 1))\n    flux_x_at_x_faces[:, 1:-1] = 0.5 * (F_xx[:, :-1] + F_xx[:, 1:])\n    flux_x_at_x_faces[:, 0], flux_x_at_x_faces[:, -1] = F_xx[:, 0], F_xx[:, -1]\n\n    flux_y_at_x_faces = np.zeros((Ny, Nx + 1))\n    flux_y_at_x_faces[:, 1:-1] = 0.5 * (F_yx[:, :-1] + F_yx[:, 1:])\n    flux_y_at_x_faces[:, 0], flux_y_at_x_faces[:, -1] = F_yx[:, 0], F_yx[:, -1]\n    \n    flux_x_at_y_faces = np.zeros((Ny + 1, Nx))\n    flux_x_at_y_faces[1:-1, :] = 0.5 * (F_xy[:-1, :] + F_xy[1:, :])\n    flux_x_at_y_faces[0, :], flux_x_at_y_faces[-1, :] = F_xy[0, :], F_xy[-1, :]\n    \n    flux_y_at_y_faces = np.zeros((Ny + 1, Nx))\n    flux_y_at_y_faces[1:-1, :] = 0.5 * (F_yy[:-1, :] + F_yy[1:, :])\n    flux_y_at_y_faces[0, :], flux_y_at_y_faces[-1, :] = F_yy[0, :], F_yy[-1, :]\n\n    div_Fx = (flux_x_at_x_faces[:, 1:] - flux_x_at_x_faces[:, :-1]) / dx + (flux_x_at_y_faces[1:, :] - flux_x_at_y_faces[:-1, :]) / dy\n    div_Fy = (flux_y_at_x_faces[:, 1:] - flux_y_at_x_faces[:, :-1]) / dx + (flux_y_at_y_faces[1:, :] - flux_y_at_y_faces[:-1, :]) / dy\n    V_vec = np.array([np.sum(div_Fx), np.sum(div_Fy)]) * dx * dy\n    \n    # --- 2. Compute Surface Integral S by summing fluxes on the boundary ---\n    Sx = (np.sum(flux_x_at_x_faces[:, -1]) - np.sum(flux_x_at_x_faces[:, 0])) * dy + \\\n         (np.sum(flux_x_at_y_faces[-1, :]) - np.sum(flux_x_at_y_faces[0, :])) * dx\n    Sy = (np.sum(flux_y_at_x_faces[:, -1]) - np.sum(flux_y_at_x_faces[:, 0])) * dy + \\\n         (np.sum(flux_y_at_y_faces[-1, :]) - np.sum(flux_y_at_y_faces[0, :])) * dx\n    S_vec = np.array([Sx, Sy])\n\n    return np.max(np.abs(V_vec - S_vec))\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3491204"}]}