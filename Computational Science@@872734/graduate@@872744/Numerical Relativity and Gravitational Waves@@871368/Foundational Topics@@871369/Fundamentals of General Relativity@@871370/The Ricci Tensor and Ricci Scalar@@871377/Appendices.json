{"hands_on_practices": [{"introduction": "The journey from theoretical understanding to practical application in numerical relativity begins with translating fundamental definitions into working code. This first exercise [@problem_id:3494931] tasks you with exactly that: building a numerical calculator for the Ricci scalar $R$ from the ground up, starting from the metric tensor $g_{\\mu\\nu}$. By applying this tool to well-understood spacetimes like Kasner and Friedmann–Lemaître–Robertson–Walker (FLRW), and performing a convergence test, you will not only verify your implementation but also gain a tangible understanding of how numerical errors behave in practice.", "problem": "You are tasked with designing and implementing a numerical validator for the Ricci scalar computation in spacetimes central to numerical relativity and gravitational-wave modeling. The program must compute the Ricci scalar $R$ at a specified event for two analytic spacetimes with known properties: the Kasner (vacuum) spacetime and the Friedmann–Lemaître–Robertson–Walker (FLRW) spacetime. The goal is to perform mixed time-space convergence tests by numerically approximating $R$ from first principles using finite differences, and then comparing against analytically known values for each spacetime to extract an empirical convergence rate.\n\nStart from the following foundational definitions and facts:\n- The spacetime is described by a metric tensor $g_{\\mu\\nu}$ with metric signature $(-,+,+,+)$, using natural units where $c=1$.\n- The Christoffel symbols of the second kind are defined by\n  $$\\Gamma^{\\alpha}{}_{\\beta\\gamma} = \\frac{1}{2} g^{\\alpha\\delta}\\Big(\\partial_{\\beta} g_{\\gamma\\delta} + \\partial_{\\gamma} g_{\\beta\\delta} - \\partial_{\\delta} g_{\\beta\\gamma}\\Big).$$\n- The Ricci tensor is defined in terms of Christoffel symbols by\n  $$R_{\\mu\\nu} = \\partial_{\\lambda} \\Gamma^{\\lambda}{}_{\\mu\\nu} - \\partial_{\\nu} \\Gamma^{\\lambda}{}_{\\mu\\lambda} + \\Gamma^{\\lambda}{}_{\\lambda\\sigma}\\Gamma^{\\sigma}{}_{\\mu\\nu} - \\Gamma^{\\lambda}{}_{\\nu\\sigma}\\Gamma^{\\sigma}{}_{\\mu\\lambda}.$$\n- The Ricci scalar is the contraction\n  $$R = g^{\\mu\\nu} R_{\\mu\\nu}.$$\n\nNumerical approach to be implemented:\n- Use a central finite difference method to approximate first partial derivatives $\\partial_{\\beta} g_{\\gamma\\delta}$ by sampling $g_{\\gamma\\delta}$ at neighboring points separated by small steps along each coordinate direction. Use central differences for $\\partial_{\\lambda}\\Gamma^{\\lambda}{}_{\\mu\\nu}$ and for $\\partial_{\\nu} \\Gamma^{\\lambda}{}_{\\mu\\lambda}$ similarly, by sampling $\\Gamma^{\\alpha}{}_{\\beta\\gamma}$ at neighboring points.\n- Compute $R$ at a single event $(t_{0},x_{0},y_{0},z_{0})$ using the definitions above and the numerical derivatives.\n\nSpacetimes and metrics to be used:\n- Kasner spacetime: a spatially homogeneous, anisotropic vacuum solution. In Cartesian-like coordinates $(t,x,y,z)$ the metric is diagonal with components\n  $$g_{\\mu\\nu} = \\mathrm{diag}\\big(-1,\\, t^{2p_{1}},\\, t^{2p_{2}},\\, t^{2p_{3}}\\big),$$\n  where $(p_{1},p_{2},p_{3})$ satisfy $p_{1}+p_{2}+p_{3}=1$ and $p_{1}^{2}+p_{2}^{2}+p_{3}^{2}=1$.\n- Friedmann–Lemaître–Robertson–Walker spacetime in isotropic Cartesian coordinates $(t,x,y,z)$ with constant spatial curvature parameter $k\\in\\{+1,-1\\}$ and scale factor $a(t)$, with spatial metric conformal to the Euclidean metric by a radial factor. Use the diagonal metric\n  $$g_{\\mu\\nu} = \\mathrm{diag}\\Big(-1,\\, a(t)^{2} \\, \\frac{4}{\\big(1 + k r^{2}\\big)^{2}},\\, a(t)^{2} \\, \\frac{4}{\\big(1 + k r^{2}\\big)^{2}},\\, a(t)^{2} \\, \\frac{4}{\\big(1 + k r^{2}\\big)^{2}}\\Big),$$\n  where $r^{2} = x^{2} + y^{2} + z^{2}$. Choose $a(t) = e^{H t}$ with constant $H0$ to ensure nontrivial time dependence.\n\nTest suite and evaluation:\n- For each test case, compute the numerical Ricci scalar $R_{\\mathrm{num}}$ at the specified event using the finite difference method. Compare to the analytically known Ricci scalar $R_{\\mathrm{exact}}$ for that spacetime. Compute the absolute error $E = |R_{\\mathrm{num}} - R_{\\mathrm{exact}}|$ for a coarse grid and a fine grid, where the fine grid halves both the time step and spatial steps. Report the observed convergence order $p$ estimated by\n  $$p \\approx \\frac{\\log\\big(E_{\\mathrm{coarse}}/E_{\\mathrm{fine}}\\big)}{\\log\\big(h_{\\mathrm{coarse}}/h_{\\mathrm{fine}}\\big)},$$\n  where $h$ is a representative grid spacing. You must refine both the time step and the spatial step simultaneously and use $h = \\max(\\Delta t, \\Delta x)$.\n- Use the following test suite:\n  1. Kasner spacetime with $(p_{1},p_{2},p_{3}) = \\big(\\tfrac{2}{3}, -\\tfrac{1}{3}, \\tfrac{2}{3}\\big)$ evaluated at $(t_{0},x_{0},y_{0},z_{0}) = (0.8, 0.1, 0.1, 0.1)$, coarse steps $(\\Delta t, \\Delta x) = (10^{-2}, 10^{-2})$, fine steps $(\\Delta t, \\Delta x) = (5\\times 10^{-3}, 5\\times 10^{-3})$.\n  2. FLRW spacetime with $k=+1$, $H=0.1$, evaluated at $(t_{0},x_{0},y_{0},z_{0}) = (0.5, 0.2, 0.1, -0.15)$, coarse steps $(\\Delta t, \\Delta x) = (10^{-2}, 10^{-2})$, fine steps $(\\Delta t, \\Delta x) = (5\\times 10^{-3}, 5\\times 10^{-3})$.\n  3. FLRW spacetime with $k=-1$, $H=0.1$, evaluated at $(t_{0},x_{0},y_{0},z_{0}) = (0.5, 0.3, 0.25, 0.1)$, coarse steps $(\\Delta t, \\Delta x) = (1.25\\times 10^{-2}, 1.25\\times 10^{-2})$, fine steps $(\\Delta t, \\Delta x) = (6.25\\times 10^{-3}, 6.25\\times 10^{-3})$.\n\nOutput specification:\n- Your program should produce a single line of output containing the observed convergence orders as a comma-separated list enclosed in square brackets. For example, the output format must be exactly\n  $$[p_{1},p_{2},p_{3}]$$\n  where each $p_{i}$ is a floating-point number. No other text should be printed.\n- This is a purely mathematical computation; there are no physical units in the final outputs. Angles are not present. Express all numerical outputs as floating-point numbers.\n\nScientific realism and constraints:\n- All formulas used in code must be derived from the fundamental definitions provided, without inserting pre-simplified curvature formulas directly into the numerical computation of $R_{\\mathrm{num}}$. The analytic values $R_{\\mathrm{exact}}$ used for error computation are allowed to come from independently known solutions for validation.\n- Ensure numerical stability by evaluating interior points, avoiding coordinate singularities. For the FLRW $k=-1$ case, restrict $r$ such that $1 + k r^{2}  0$.", "solution": "The problem is valid. It is scientifically grounded in the principles of general relativity, well-posed with a clear objective and sufficient data, and uses objective, formal language. All provided formulas and spacetime metrics are standard in the field. The test case for the Kasner metric uses parameters $(p_1, p_2, p_3) = (\\frac{2}{3}, -\\frac{1}{3}, \\frac{2}{3})$ which correctly satisfy the vacuum conditions $p_1+p_2+p_3=1$ and $p_1^2+p_2^2+p_3^2=1$. The evaluation points for the Friedmann–Lemaître–Robertson–Walker (FLRW) spacetime are chosen to avoid coordinate singularities. We may therefore proceed with a solution.\n\nThe core of the task is to numerically compute the Ricci scalar, $R$, at a specific spacetime event. The solution is built by hierarchically implementing the defining equations from first principles, using numerical differentiation.\n\n**1. Analytical Foundation for Validation**\n\nTo validate our numerical results, we require the exact analytical values of the Ricci scalar, $R_{\\mathrm{exact}}$, for the given spacetimes.\n- **Kasner Spacetime**: The Kasner metric is a solution to the vacuum Einstein field equations, meaning its Ricci tensor is identically zero, $R_{\\mu\\nu} = 0$. Consequently, the Ricci scalar, which is the trace of the Ricci tensor $R = g^{\\mu\\nu}R_{\\mu\\nu}$, is also zero. Thus, for the first test case, $R_{\\mathrm{exact}} = 0$.\n- **FLRW Spacetime**: For a general FLRW metric with scale factor $a(t)$ and spatial curvature $k$, the Ricci scalar is given by $R = 6 \\left( \\frac{\\ddot{a}}{a} + (\\frac{\\dot{a}}{a})^2 + \\frac{k}{a^2} \\right)$. The problem specifies $a(t) = e^{Ht}$, which describes a de Sitter universe. For this scale factor, we have $\\frac{\\dot{a}}{a} = H$ and $\\frac{\\ddot{a}}{a} = H^2$. Substituting these into the formula for $R$ yields $R = 6(H^2 + H^2 + k e^{-2Ht}) = 12H^2 + 6ke^{-2Ht}$. This analytical expression will be used to compute $R_{\\mathrm{exact}}$ for the second and third test cases at the specified evaluation time $t_0$.\n\n**2. Numerical Implementation Strategy**\n\nThe numerical computation of $R$ directly follows its definition, $R = g^{\\mu\\nu}R_{\\mu\\nu}$, which necessitates a multi-step, bottom-up calculation. This hierarchical structure is mirrored in the software design.\n\n- **Step 2a: Metric Tensors**: Functions are defined to represent the metric tensor $g_{\\mu\\nu}$ for both Kasner and FLRW spacetimes. These functions take a $4$-dimensional coordinate tuple $(t, x, y, z)$ and return the $4 \\times 4$ metric tensor matrix at that event. Since the calculations involve many evaluations of the metric at nearby points, the metric function is wrapped in a memoization decorator (`@functools.lru_cache`) to cache results and avoid redundant computations. A new cache is instantiated for each \"run\" (coarse vs. fine), ensuring computational independence.\n\n- **Step 2b: Christoffel Symbols, $\\Gamma^{\\alpha}{}_{\\beta\\gamma}$**: The Christoffel symbols are computed via their definition: $\\Gamma^{\\alpha}{}_{\\beta\\gamma} = \\frac{1}{2} g^{\\alpha\\delta}(\\partial_{\\beta} g_{\\gamma\\delta} + \\partial_{\\gamma} g_{\\beta\\delta} - \\partial_{\\delta} g_{\\beta\\gamma})$. This requires the inverse metric, $g^{\\alpha\\delta}$, and the first partial derivatives of the metric components, $\\partial_{\\beta} g_{\\gamma\\delta}$. The derivatives are approximated numerically using a second-order central finite difference scheme: $\\partial_{\\beta}f(P) \\approx \\frac{f(P+\\mathbf{h}_{\\beta}) - f(P-\\mathbf{h}_{\\beta})}{2h_{\\beta}}$, where $P$ is the evaluation point and $\\mathbf{h}_{\\beta}$ is a step vector in the $\\beta$-direction.\n\n- **Step 2c: Ricci Tensor, $R_{\\mu\\nu}$**: The Ricci tensor, $R_{\\mu\\nu} = \\partial_{\\lambda} \\Gamma^{\\lambda}{}_{\\mu\\nu} - \\partial_{\\nu} \\Gamma^{\\lambda}{}_{\\mu\\lambda} + \\Gamma^{\\lambda}{}_{\\lambda\\sigma}\\Gamma^{\\sigma}{}_{\\mu\\nu} - \\Gamma^{\\lambda}{}_{\\nu\\sigma}\\Gamma^{\\sigma}{}_{\\mu\\lambda}$, is the most complex component. Its computation involves two types of terms:\n    1.  *Quadratic terms*: Products of Christoffel symbols, such as $\\Gamma^{\\lambda}{}_{\\lambda\\sigma}\\Gamma^{\\sigma}{}_{\\mu\\nu}$, are computed using the Christoffel symbols evaluated at the central point $P_0$.\n    2.  *Derivative terms*: Terms like $\\partial_{\\lambda} \\Gamma^{\\lambda}{}_{\\mu\\nu}$ involve derivatives of the Christoffel symbols. These are also calculated using central differences. This means the Christoffel symbols themselves must be evaluated at neighboring points, $P_0 \\pm \\mathbf{h}_{\\lambda}$, which in turn requires evaluating the metric tensor at a wider stencil of points. This nested application of finite differences correctly approximates the second-order derivatives of the metric tensor inherent in the Ricci tensor definition.\n\n- **Step 2d: Ricci Scalar, $R$**: Finally, the Ricci scalar is computed by contracting the numerically obtained Ricci tensor $R_{\\mu\\nu}$ with the inverse metric $g^{\\mu\\nu}$ at the central point $P_0$: $R = g^{\\mu\\nu}R_{\\mu\\nu} = \\sum_{\\mu,\\nu} g^{\\mu\\nu}(P_0) R_{\\mu\\nu}(P_0)$.\n\n**3. Convergence Analysis**\n\nThe program executes the entire numerical calculation for each test case twice: once with a coarse grid spacing ($h_{\\mathrm{coarse}}$) and once with a fine grid spacing ($h_{\\mathrm{fine}} = h_{\\mathrm{coarse}}/2$). The absolute errors, $E_{\\mathrm{coarse}} = |R_{\\mathrm{num, coarse}} - R_{\\mathrm{exact}}|$ and $E_{\\mathrm{fine}} = |R_{\\mathrm{num, fine}} - R_{\\mathrm{exact}}|$, are calculated. The empirical order of convergence, $p$, is then estimated using the formula:\n$$p \\approx \\frac{\\log(E_{\\mathrm{coarse}}/E_{\\mathrm{fine}})}{\\log(h_{\\mathrm{coarse}}/h_{\\mathrm{fine}})}$$\nGiven that $h_{\\mathrm{coarse}}/h_{\\mathrm{fine}} = 2$ for all test cases, this simplifies to $p \\approx \\log_2(E_{\\mathrm{coarse}}/E_{\\mathrm{fine}})$. Since the numerical scheme is based on second-order central differences, the expected convergence order is $p \\approx 2$. The final output consists of the computed values of $p$ for each test case.", "answer": "```python\nimport numpy as np\nimport functools\n\ndef get_kasner_metric_factory(p1, p2, p3):\n    \"\"\"Returns a function that computes the Kasner metric tensor.\"\"\"\n    def metric_func(coords):\n        t, x, y, z = coords\n        if t = 0:\n            raise ValueError(\"Time coordinate t must be positive for Kasner metric.\")\n        return np.diag([-1.0, t**(2*p1), t**(2*p2), t**(2*p3)])\n    return metric_func\n\ndef get_flrw_metric_factory(k, H):\n    \"\"\"Returns a function that computes the FLRW metric tensor.\"\"\"\n    def metric_func(coords):\n        t, x, y, z = coords\n        r2 = x**2 + y**2 + z**2\n        a_t = np.exp(H * t)\n        \n        # Check for coordinate singularity\n        denom = 1.0 + k * r2\n        if np.isclose(denom, 0):\n            raise ValueError(\"Evaluation point is at a coordinate singularity.\")\n            \n        conformal_factor = 4.0 / (denom**2)\n        g_spatial = (a_t**2) * conformal_factor\n        return np.diag([-1.0, g_spatial, g_spatial, g_spatial])\n    return metric_func\n\ndef get_christoffel(metric_func, point, steps):\n    \"\"\"Computes Christoffel symbols of the second kind at a given point.\"\"\"\n    point_tuple = tuple(point)\n    g = metric_func(point_tuple)\n    g_inv = np.linalg.inv(g)\n\n    # Compute derivatives of the metric, d_g[deriv_idx, mu, nu]\n    d_g = np.zeros((4, 4, 4))\n    for deriv_idx in range(4):\n        h = steps[deriv_idx]\n        shift = np.zeros(4)\n        shift[deriv_idx] = h\n        \n        g_plus = metric_func(tuple(point + shift))\n        g_minus = metric_func(tuple(point - shift))\n        \n        d_g[deriv_idx, :, :] = (g_plus - g_minus) / (2.0 * h)\n\n    # Compute Christoffel symbols, gamma[alpha, beta, c]\n    gamma = np.zeros((4, 4, 4))\n    for alpha in range(4):\n        for beta in range(4):\n            for c in range(4): # 'c' for gamma to avoid name clash\n                term = 0.0\n                for delta in range(4):\n                    term += g_inv[alpha, delta] * 0.5 * (d_g[beta, c, delta] + d_g[c, beta, delta] - d_g[delta, beta, c])\n                gamma[alpha, beta, c] = term\n    return gamma\n\ndef get_ricci_tensor(metric_func, point, steps):\n    \"\"\"Computes the Ricci tensor at a given point.\"\"\"\n    ricci = np.zeros((4, 4))\n    \n    # Christoffel symbols at the center point\n    gamma_center = get_christoffel(metric_func, point, steps)\n\n    # Derivatives of Christoffel symbols, d_gamma[deriv_idx, alpha, beta, c]\n    d_gamma = np.zeros((4, 4, 4, 4))\n    for deriv_idx in range(4):\n        h = steps[deriv_idx]\n        shift = np.zeros(4)\n        shift[deriv_idx] = h\n        \n        gamma_plus = get_christoffel(metric_func, point + shift, steps)\n        gamma_minus = get_christoffel(metric_func, point - shift, steps)\n        \n        d_gamma[deriv_idx, :, :, :] = (gamma_plus - gamma_minus) / (2.0 * h)\n\n    for mu in range(4):\n        for nu in range(4):\n            # Term 1: partial_lambda Gamma^lambda_{mu nu}\n            term1 = np.trace(d_gamma[:, :, mu, nu])\n            \n            # Term 2: partial_nu Gamma^lambda_{mu lambda}\n            term2 = 0.0\n            for lam in range(4):\n                term2 += d_gamma[nu, lam, mu, lam]\n                \n            # Term 3: Gamma^lambda_{lambda sigma} Gamma^sigma_{mu nu}\n            term3 = 0.0\n            for lam in range(4):\n                for sig in range(4):\n                    term3 += gamma_center[lam, lam, sig] * gamma_center[sig, mu, nu]\n\n            # Term 4: Gamma^lambda_{nu sigma} Gamma^sigma_{mu lambda}\n            term4 = 0.0\n            for lam in range(4):\n                for sig in range(4):\n                    term4 += gamma_center[lam, nu, sig] * gamma_center[sig, mu, lam]\n\n            ricci[mu, nu] = term1 - term2 + term3 - term4\n            \n    return ricci\n\ndef get_ricci_scalar_numerical(metric_factory, point, steps):\n    \"\"\"Computes the Ricci scalar at a point for a given metric factory.\"\"\"\n    # Create a cached version of the metric function for this specific run\n    @functools.lru_cache(maxsize=None)\n    def metric_func(coords_tuple):\n        return metric_factory(coords_tuple)\n\n    g_inv = np.linalg.inv(metric_func(tuple(point)))\n    ricci_tensor = get_ricci_tensor(metric_func, point, steps)\n    \n    scalar = np.sum(g_inv * ricci_tensor)\n    return scalar\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute convergence orders.\n    \"\"\"\n    test_cases = [\n        {\n            \"name\": \"Kasner\",\n            \"metric_factory\": get_kasner_metric_factory(p1=2/3, p2=-1/3, p3=2/3),\n            \"point\": np.array([0.8, 0.1, 0.1, 0.1]),\n            \"steps_coarse\": np.array([1e-2, 1e-2, 1e-2, 1e-2]),\n            \"steps_fine\": np.array([5e-3, 5e-3, 5e-3, 5e-3]),\n            \"R_exact_func\": lambda p: 0.0\n        },\n        {\n            \"name\": \"FLRW k=+1\",\n            \"metric_factory\": get_flrw_metric_factory(k=1.0, H=0.1),\n            \"point\": np.array([0.5, 0.2, 0.1, -0.15]),\n            \"steps_coarse\": np.array([1e-2, 1e-2, 1e-2, 1e-2]),\n            \"steps_fine\": np.array([5e-3, 5e-3, 5e-3, 5e-3]),\n            \"R_exact_func\": lambda p: 12*(0.1)**2 + 6*1.0*np.exp(-2*0.1*p[0])\n        },\n        {\n            \"name\": \"FLRW k=-1\",\n            \"metric_factory\": get_flrw_metric_factory(k=-1.0, H=0.1),\n            \"point\": np.array([0.5, 0.3, 0.25, 0.1]),\n            \"steps_coarse\": np.array([1.25e-2, 1.25e-2, 1.25e-2, 1.25e-2]),\n            \"steps_fine\": np.array([6.25e-3, 6.25e-3, 6.25e-3, 6.25e-3]),\n            \"R_exact_func\": lambda p: 12*(0.1)**2 + 6*(-1.0)*np.exp(-2*0.1*p[0])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        point = case[\"point\"]\n        \n        # Coarse grid calculation\n        R_coarse = get_ricci_scalar_numerical(case[\"metric_factory\"], point, case[\"steps_coarse\"])\n        \n        # Fine grid calculation\n        R_fine = get_ricci_scalar_numerical(case[\"metric_factory\"], point, case[\"steps_fine\"])\n        \n        R_exact = case[\"R_exact_func\"](point)\n        \n        E_coarse = np.abs(R_coarse - R_exact)\n        E_fine = np.abs(R_fine - R_exact)\n\n        # Avoid division by zero if error is zero (perfect cancellation)\n        if E_coarse == 0 or E_fine == 0:\n            order = np.nan # Or a large number to indicate super-convergence\n        else:\n            h_coarse = np.max(case[\"steps_coarse\"])\n            h_fine = np.max(case[\"steps_fine\"])\n            order = np.log(E_coarse / E_fine) / np.log(h_coarse / h_fine)\n        \n        results.append(order)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3494931"}, {"introduction": "While the covariant, four-dimensional formalism is theoretically elegant, numerical simulations of spacetime almost universally employ a 3+1 decomposition, splitting spacetime into a series of evolving spatial slices. In this framework, the spatial Ricci scalar $R^{(3)}$ plays a crucial role in Einstein's constraint equations, which must be satisfied at all times. This practice [@problem_id:3494863] provides a vital check on numerical fidelity by asking you to compute $R^{(3)}$ through two independent routes: directly from the spatial geometry, and via the ADM Hamiltonian constraint, highlighting its role as a powerful tool for verifying the physical consistency of your numerical solution.", "problem": "You are given a spatially homogeneous and isotropic initial data set consistent with the Arnowitt–Deser–Misner (ADM) decomposition of General Relativity (GR) in geometrized units with $G=c=1$. Consider a single time slice $t=\\text{const}$ of the Friedmann–Lemaître–Robertson–Walker (FLRW) geometry written in spherical coordinates $(r,\\theta,\\phi)$, where angles are in radians. The spatial metric on the slice is\n$$\n\\gamma_{ij}\\,dx^i dx^j = a^2\\left(\\frac{dr^2}{1-k r^2} + r^2\\,d\\theta^2 + r^2 \\sin^2\\theta\\, d\\phi^2\\right),\n$$\nwith curvature parameter $k\\in\\{-1,0,+1\\}$ and scale factor $a0$. The extrinsic curvature for the comoving slicing is specified by\n$$\nK_{ij} = -H\\,\\gamma_{ij},\n$$\nwhere $H=\\dot a/a$ is the Hubble parameter on the slice. Assume vacuum cosmological constant and no explicit cosmological constant term.\n\nYour task is to compute the spatial Ricci scalar $R^{(3)}$ at a single point $(r_0,\\theta_0)$ on the slice by two independent routes and then report the absolute difference between the two results for each test case.\n\nRoute (i): Contracted Christoffel route.\n- Use the definition of the three-dimensional Ricci tensor,\n$$\nR_{ij}=\\partial_k \\Gamma^k_{\\;ij} - \\partial_j \\Gamma^k_{\\;ik} + \\Gamma^k_{\\;ij}\\Gamma^\\ell_{\\;k\\ell} - \\Gamma^k_{\\;i\\ell}\\Gamma^\\ell_{\\;jk},\n$$\nand $R^{(3)}=\\gamma^{ij}R_{ij}$, where $\\Gamma^i_{\\;jk}$ are the Christoffel symbols built from $\\gamma_{ij}$ and its first derivatives. All indices $i,j,k,\\ell$ range over the spatial coordinates $\\{r,\\theta,\\phi\\}$.\n- Implement the Christoffel symbols from their definition in terms of $\\gamma_{ij}$ and its first derivatives.\n- For $\\partial_k \\Gamma^k_{\\;ij}$, use central finite differences aligned with the matching coordinate direction of the raised index $k$. That is, compute $\\partial_r \\Gamma^r_{\\;ij}$ at $(r_0,\\theta_0)$ using a central difference in $r$, and $\\partial_\\theta \\Gamma^\\theta_{\\;ij}$ using a central difference in $\\theta$, while $\\partial_\\phi \\Gamma^\\phi_{\\;ij}=0$ because $\\gamma_{ij}$ has no $\\phi$ dependence. Similarly, compute $\\partial_j \\Gamma^k_{\\;ik}$ using central finite differences in the coordinate direction $x^j$; for $j=\\phi$ the derivative is zero.\n- Use the following central difference step sizes: $\\Delta r = 10^{-5}$ and $\\Delta \\theta = 10^{-5}$ (radians). All derivatives with respect to $\\phi$ vanish identically for this metric.\n\nRoute (ii): ADM Hamiltonian constraint route.\n- Use the Hamiltonian constraint in three-plus-one form,\n$$\nR^{(3)} = 16\\pi \\rho + K_{ij}K^{ij} - K^2,\n$$\nwhere $\\rho$ is the energy density measured by the normal observer, $K=\\gamma^{ij}K_{ij}$, and $K^{ij}=\\gamma^{ik}\\gamma^{j\\ell}K_{k\\ell}$.\n\nTest suite and inputs. For each test case, you are provided $(k,a,H,\\rho,r_0,\\theta_0)$ and must compute the absolute difference\n$$\n\\Delta \\equiv \\left|R^{(3)}_{\\text{Christoffel}} - R^{(3)}_{\\text{ADM}}\\right|\n$$\nat $(r_0,\\theta_0)$ using the two routes above.\n\n- Case A (happy path, closed slice): $(k,a,H,\\rho,r_0,\\theta_0)=(+1,\\,1.4,\\,0.8,\\,\\frac{3}{8\\pi}\\left(H^2+\\frac{k}{a^2}\\right),\\,0.2,\\,1.0)$.\n- Case B (flat slice, nonzero expansion): $(k,a,H,\\rho,r_0,\\theta_0)=(0,\\,2.0,\\,0.3,\\,\\frac{3}{8\\pi}H^2,\\,0.2,\\,0.3)$.\n- Case C (open slice): $(k,a,H,\\rho,r_0,\\theta_0)=(-1,\\,0.9,\\,1.3,\\,\\frac{3}{8\\pi}\\left(H^2+\\frac{k}{a^2}\\right),\\,0.7,\\,1.2)$.\n- Case D (Minkowski slice): $(k,a,H,\\rho,r_0,\\theta_0)=(0,\\,1.0,\\,0.0,\\,0.0,\\,0.33,\\,1.1)$.\n\nAll angles are in radians. All quantities use geometrized units with $G=c=1$.\n\nProgram requirements.\n- Your program must implement both routes precisely as specified and compute $\\Delta$ for each of the four cases.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the cases A, B, C, D, that is, the line must be of the form\n$$\n[\\Delta_A,\\Delta_B,\\Delta_C,\\Delta_D].\n$$\n- Each $\\Delta$ must be output as a floating-point number.", "solution": "The user has provided a problem in the domain of numerical relativity and gravitational waves, specifically concerning the computation of the Ricci scalar on a spatial slice of a Friedmann–Lemaître–Robertson–Walker (FLRW) spacetime. The problem is to be solved by two distinct methods, and the absolute difference in their results is to be reported.\n\n### Step 1: Problem Validation\n\nI will first validate the problem statement according to the specified criteria.\n\n**Extracted Givens:**\n1.  **Metric Tensor**: The spatial metric $\\gamma_{ij}$ on a constant-time slice is given by\n    $$ \\gamma_{ij}\\,dx^i dx^j = a^2\\left(\\frac{dr^2}{1-k r^2} + r^2\\,d\\theta^2 + r^2 \\sin^2\\theta\\, d\\phi^2\\right) $$\n    with curvature parameter $k\\in\\{-1,0,+1\\}$ and scale factor $a0$.\n2.  **Extrinsic Curvature**: The extrinsic curvature is $K_{ij} = -H\\,\\gamma_{ij}$, where $H=\\dot a/a$.\n3.  **Units and Constants**: Geometrized units are used, with $G=c=1$.\n4.  **Route (i) - Christoffel Method**: Compute the spatial Ricci scalar $R^{(3)}$ using the definition of the Ricci tensor in terms of Christoffel symbols and their derivatives, followed by contraction with the inverse metric $\\gamma^{ij}$.\n    $$ R_{ij}=\\partial_k \\Gamma^k_{\\;ij} - \\partial_j \\Gamma^k_{\\;ik} + \\Gamma^k_{\\;ij}\\Gamma^\\ell_{\\;k\\ell} - \\Gamma^k_{\\;i\\ell}\\Gamma^\\ell_{\\;jk} $$\n    $$ R^{(3)} = \\gamma^{ij}R_{ij} $$\n    The derivatives of Christoffel symbols $\\Gamma^i_{\\;jk}$ are to be computed numerically using central finite differences with step sizes $\\Delta r = 10^{-5}$ and $\\Delta \\theta = 10^{-5}$.\n5.  **Route (ii) - ADM Constraint Method**: Compute $R^{(3)}$ using the ADM Hamiltonian constraint:\n    $$ R^{(3)} = 16\\pi \\rho + K_{ij}K^{ij} - K^2 $$\n    where $K=\\gamma^{ij}K_{ij}$ and $K^{ij}=\\gamma^{ik}\\gamma^{j\\ell}K_{k\\ell}$.\n6.  **Test Cases**: Four sets of parameters $(k, a, H, \\rho, r_0, \\theta_0)$ are provided.\n    - Case A: $(+1, 1.4, 0.8, \\dots, 0.2, 1.0)$\n    - Case B: $(0, 2.0, 0.3, \\dots, 0.2, 0.3)$\n    - Case C: $(-1, 0.9, 1.3, \\dots, 0.7, 1.2)$\n    - Case D: $(0, 1.0, 0.0, \\dots, 0.33, 1.1)$\n    The energy density $\\rho$ is specified to be consistent with the Friedmann equation: $\\rho = \\frac{3}{8\\pi}(H^2 + k/a^2)$.\n7.  **Task**: Compute the absolute difference $\\Delta = \\left|R^{(3)}_{\\text{Christoffel}} - R^{(3)}_{\\text{ADM}}\\right|$ for each case.\n\n**Validation Verdict:**\n-   **Scientifically Grounded**: The problem is formulated within the standard Arnowitt–Deser–Misner (ADM) framework of General Relativity and uses the well-established FLRW metric. The equations for the Ricci tensor, Christoffel symbols, and the Hamiltonian constraint are fundamental and correctly stated. The initial data for the test cases are constructed to satisfy the Friedmann equation, ensuring self-consistency. The problem is scientifically sound.\n-   **Well-Posed**: The problem is well-posed. It requires a numerical calculation following a prescribed algorithm (finite differences) and a comparison with an analytical result. For the given inputs and specified numerical methods, a unique, stable, and meaningful result (the numerical error) exists.\n-   **Objective**: The problem is stated in precise, objective mathematical language, free of ambiguity or subjective claims.\n-   **Other Flaws**: The problem is not incomplete, contradictory, unrealistic, ill-posed, trivial, or unverifiable. The calculations are non-trivial and serve as a standard verification test in numerical relativity.\n\nThe problem is deemed **valid**.\n\n### Step 2: Solution Design\n\nThe solution will be implemented in two parts, corresponding to the two routes specified.\n\n**Route (ii): ADM Hamiltonian Constraint**\nThis route provides the-analytical `ground truth`. The Hamiltonian constraint is $R^{(3)} = 16\\pi\\rho + K_{ij}K^{ij} - K^2$.\nGiven $K_{ij} = -H\\gamma_{ij}$, we can compute the invariants:\n-   $K = \\gamma^{ij}K_{ij} = \\gamma^{ij}(-H\\gamma_{ij}) = -H\\delta^i_i = -3H$.\n-   $K_{ij}K^{ij} = (-H\\gamma_{ij})(-H\\gamma^{ij}) = H^2\\gamma_{ij}\\gamma^{ij} = H^2\\delta^i_i = 3H^2$.\nSubstituting these into the constraint equation yields:\n$R^{(3)} = 16\\pi\\rho + 3H^2 - (-3H)^2 = 16\\pi\\rho - 6H^2$.\nThe problem states that the initial data is consistent, meaning the Friedmann equation holds: $H^2 = \\frac{8\\pi G}{3}\\rho - \\frac{k c^2}{a^2}$. In geometrized units ($G=c=1$), this is $H^2 = \\frac{8\\pi}{3}\\rho - \\frac{k}{a^2}$.\nRearranging for $16\\pi\\rho$ gives $16\\pi\\rho = 6H^2 + \\frac{6k}{a^2}$.\nSubstituting this into the expression for $R^{(3)}$:\n$R^{(3)} = \\left(6H^2 + \\frac{6k}{a^2}\\right) - 6H^2 = \\frac{6k}{a^2}$.\nThis is the well-known result for the spatial Ricci scalar of an FLRW slice. It is constant everywhere on the slice. This analytical result, $R^{(3)}_{\\text{ADM}} = 6k/a^2$, will be used as the benchmark.\n\n**Route (i): Christoffel Symbol Method**\nThis route requires a numerical calculation. The Ricci scalar $R^{(3)} = \\gamma^{ij}R_{ij}$ is computed from the Ricci tensor $R_{ij}$, which in turn is computed from the Christoffel symbols $\\Gamma^i_{\\;jk}$ and their derivatives.\n\n1.  **Metric and its Inverse**: The non-zero components of $\\gamma_{ij}$ and $\\gamma^{ij}$ are:\n    $\\gamma_{rr} = \\frac{a^2}{1-kr^2}$, $\\gamma_{\\theta\\theta} = a^2r^2$, $\\gamma_{\\phi\\phi} = a^2r^2\\sin^2\\theta$.\n    $\\gamma^{rr} = \\frac{1-kr^2}{a^2}$, $\\gamma^{\\theta\\theta} = \\frac{1}{a^2r^2}$, $\\gamma^{\\phi\\phi} = \\frac{1}{a^2r^2\\sin^2\\theta}$.\n2.  **Christoffel Symbols**: The Christoffel symbols $\\Gamma^i_{\\;jk} = \\frac{1}{2}\\gamma^{im}(\\partial_j\\gamma_{mk} + \\partial_k\\gamma_{mj} - \\partial_m\\gamma_{jk})$ are calculated analytically. The non-zero components are:\n    - $\\Gamma^r_{rr} = \\frac{kr}{1-kr^2}$\n    - $\\Gamma^r_{\\theta\\theta} = -r(1-kr^2)$\n    - $\\Gamma^r_{\\phi\\phi} = -r(1-kr^2)\\sin^2\\theta$\n    - $\\Gamma^\\theta_{r\\theta} = \\Gamma^\\theta_{\\theta r} = \\frac{1}{r}$\n    - $\\Gamma^\\theta_{\\phi\\phi} = -\\sin\\theta\\cos\\theta$\n    - $\\Gamma^\\phi_{r\\phi} = \\Gamma^\\phi_{\\phi r} = \\frac{1}{r}$\n    - $\\Gamma^\\phi_{\\theta\\phi} = \\Gamma^\\phi_{\\phi\\theta} = \\cot\\theta$\n3.  **Ricci Tensor**: The components of $R_{ij}$ are computed using the formula:\n    $$ R_{ij}=\\partial_k \\Gamma^k_{\\;ij} - \\partial_j \\Gamma^k_{\\;ik} + \\Gamma^k_{\\;ij}\\Gamma^\\ell_{\\;k\\ell} - \\Gamma^k_{\\;i\\ell}\\Gamma^\\ell_{\\;jk} $$\n    The derivative terms will be computed numerically using second-order central finite differences with the specified step sizes $\\Delta r = 10^{-5}$ and $\\Delta \\theta = 10^{-5}$. For a function $f(r,\\theta)$:\n    - $\\partial_r f \\approx \\frac{f(r+\\Delta r, \\theta) - f(r-\\Delta r, \\theta)}{2\\Delta r}$\n    - $\\partial_\\theta f \\approx \\frac{f(r, \\theta+\\Delta\\theta) - f(r, \\theta-\\Delta\\theta)}{2\\Delta\\theta}$\n    The problem specifies that the derivative $\\partial_k$ in the first term and $\\partial_j$ in the second term are taken with respect to the coordinate corresponding to the index. Since the metric is independent of $\\phi$, derivatives with respect to $\\phi$ are zero.\n4.  **Ricci Scalar**: Since the metric is diagonal, the Ricci scalar is the sum $R^{(3)} = \\gamma^{rr}R_{rr} + \\gamma^{\\theta\\theta}R_{\\theta\\theta} + \\gamma^{\\phi\\phi}R_{\\phi\\phi}$. This means only the diagonal components of the Ricci tensor need to be computed.\n\nThe final program will implement these steps for each test case, calculate the absolute difference $\\Delta = |R^{(3)}_{\\text{Christoffel}} - R^{(3)}_{\\text{ADM}}|$, and print the results in the required format. The difference $\\Delta$ quantifies the numerical error of the finite difference approximation.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the spatial Ricci scalar R^(3) for an FLRW metric slice\n    by two routes: the ADM Hamiltonian constraint and a direct numerical\n    calculation from Christoffel symbols. It then reports the absolute\n    difference between the two results for a suite of test cases.\n    \"\"\"\n\n    # Define the step sizes for finite differences as per the problem statement.\n    h_r = 1e-5\n    h_theta = 1e-5\n\n    # Define test cases: (k, a, H, r0, theta0)\n    test_cases_params = [\n        (1.0, 1.4, 0.8, 0.2, 1.0),    # Case A\n        (0.0, 2.0, 0.3, 0.2, 0.3),    # Case B\n        (-1.0, 0.9, 1.3, 0.7, 1.2),   # Case C\n        (0.0, 1.0, 0.0, 0.33, 1.1)    # Case D\n    ]\n\n    results = []\n    \n    for k_curv, a, H, r0, theta0 in test_cases_params:\n        \n        # Route (ii): ADM Hamiltonian constraint route (Analytical)\n        # The combination of the Hamiltonian constraint and the Friedmann equation\n        # for an FLRW universe yields R_spatial = 6*k/a^2.\n        R_adm = 6.0 * k_curv / a**2\n\n        # Route (i): Christoffel symbol and Ricci tensor route (Numerical)\n        def get_inverse_metric(r, theta, k_curv_loc, a_loc):\n            g_inv = np.zeros((3, 3))\n            sin_t = np.sin(theta)\n            # Avoid division by zero, although test points are non-singular.\n            if abs(r)  1e-15 or abs(sin_t)  1e-15:\n                # Should not be reached with given test cases\n                return g_inv\n            \n            g_inv[0, 0] = (1.0 - k_curv_loc * r**2) / a_loc**2\n            g_inv[1, 1] = 1.0 / (a_loc**2 * r**2)\n            g_inv[2, 2] = 1.0 / (a_loc**2 * r**2 * sin_t**2)\n            return g_inv\n\n        def get_christoffels(r, theta, k_curv_loc, a_loc):\n            G = np.zeros((3, 3, 3))\n            \n            # Avoid coordinate singularities. Test points are safe.\n            if abs(r)  1e-15: return G\n            sin_t, cos_t = np.sin(theta), np.cos(theta)\n            if abs(sin_t)  1e-15: return G\n            \n            term_k = 1.0 - k_curv_loc * r**2\n            # Avoid metric singularity for k=1.\n            if abs(term_k)  1e-15: return G\n\n            # Pre-compute terms for efficiency\n            inv_r = 1.0 / r\n            cot_t = cos_t / sin_t\n\n            # Non-zero Christoffel symbols Gamma^i_{jk}\n            # i=0 (r), j,k are component indices\n            G[0, 0, 0] = k_curv_loc * r / term_k\n            G[0, 1, 1] = -r * term_k\n            G[0, 2, 2] = -r * term_k * sin_t**2\n\n            # i=1 (theta)\n            G[1, 0, 1] = inv_r\n            G[1, 1, 0] = inv_r\n            G[1, 2, 2] = -sin_t * cos_t\n\n            # i=2 (phi)\n            G[2, 0, 2] = inv_r\n            G[2, 2, 0] = inv_r\n            G[2, 1, 2] = cot_t\n            G[2, 2, 1] = cot_t\n            \n            return G\n\n        def ricci_component(i, j, r_eval, theta_eval, k_curv_loc, a_loc, dr, dtheta):\n            # R_ij = T1 + T2 + T3 + T4\n            # T1 = partial_k Gamma^k_ij\n            # T2 = - partial_j Gamma^k_ik\n            # T3 = Gamma^k_ij * Gamma^l_kl\n            # T4 = - Gamma^k_il * Gamma^l_jk\n\n            # Term 1: partial_k Gamma^k_ij (Numerical derivative)\n            gammas_r_plus = get_christoffels(r_eval + dr, theta_eval, k_curv_loc, a_loc)\n            gammas_r_minus = get_christoffels(r_eval - dr, theta_eval, k_curv_loc, a_loc)\n            dG_dr_k0 = (gammas_r_plus[0, i, j] - gammas_r_minus[0, i, j]) / (2 * dr)\n            \n            gammas_th_plus = get_christoffels(r_eval, theta_eval + dtheta, k_curv_loc, a_loc)\n            gammas_th_minus = get_christoffels(r_eval, theta_eval - dtheta, k_curv_loc, a_loc)\n            dG_dth_k1 = (gammas_th_plus[1, i, j] - gammas_th_minus[1, i, j]) / (2 * dtheta)\n            \n            term1 = dG_dr_k0 + dG_dth_k1\n\n            # Term 2: - partial_j Gamma^k_ik (Numerical derivative)\n            term2 = 0.0\n            if j == 0:  # j=r\n                sum_G_kik_plus = gammas_r_plus[0, i, 0] + gammas_r_plus[1, i, 1] + gammas_r_plus[2, i, 2]\n                sum_G_kik_minus = gammas_r_minus[0, i, 0] + gammas_r_minus[1, i, 1] + gammas_r_minus[2, i, 2]\n                term2 = -(sum_G_kik_plus - sum_G_kik_minus) / (2 * dr)\n            elif j == 1:  # j=theta\n                sum_G_kik_plus = gammas_th_plus[0, i, 0] + gammas_th_plus[1, i, 1] + gammas_th_plus[2, i, 2]\n                sum_G_kik_minus = gammas_th_minus[0, i, 0] + gammas_th_minus[1, i, 1] + gammas_th_minus[2, i, 2]\n                term2 = -(sum_G_kik_plus - sum_G_kik_minus) / (2 * dtheta)\n\n            # Terms 3 and 4 are algebraic, evaluated at the central point (r_eval, theta_eval)\n            G_center = get_christoffels(r_eval, theta_eval, k_curv_loc, a_loc)\n            \n            # Term 3: + Gamma^k_ij * Gamma^l_kl\n            term3 = 0.0\n            for k in range(3):\n                sum_G_lkl = G_center[0, k, 0] + G_center[1, k, 1] + G_center[2, k, 2]\n                term3 += G_center[k, i, j] * sum_G_lkl\n\n            # Term 4: - Gamma^k_il * Gamma^l_jk\n            term4 = 0.0\n            for k in range(3):\n                for l in range(3):\n                    term4 -= G_center[k, i, l] * G_center[l, j, k]\n            \n            return term1 + term2 + term3 + term4\n\n        # Because the metric is diagonal, R = g^ii * R_ii (sum over i)\n        R_diag_components = np.zeros(3)\n        for i in range(3):\n            R_diag_components[i] = ricci_component(i, i, r0, theta0, k_curv, a, h_r, h_theta)\n\n        g_inv_diag = np.diag(get_inverse_metric(r0, theta0, k_curv, a))\n        \n        R_christoffel = np.dot(g_inv_diag, R_diag_components)\n\n        diff = abs(R_christoffel - R_adm)\n        results.append(diff)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3494863"}, {"introduction": "The detection of gravitational waves requires simulations of extraordinary precision. To achieve this, numerical relativists often turn to methods more powerful than standard finite differences. This final exercise [@problem_id:3494925] delves into the world of linearized gravity and pseudo-spectral methods, where derivatives are calculated in Fourier space with remarkable accuracy. By computing the linearized Ricci tensor for a plane gravitational wave—a quantity that should analytically be zero—you will directly witness the concept of spectral accuracy and see how a well-resolved simulation can cancel errors to machine precision, a cornerstone of high-fidelity gravitational waveform modeling.", "problem": "Consider linearized gravity on a Minkowski background with metric signature $(-,+,+,+)$ and small perturbation $h_{\\mu\\nu}$ so that $g_{\\mu\\nu} = \\eta_{\\mu\\nu} + h_{\\mu\\nu}$ with $\\lVert h_{\\mu\\nu} \\rVert \\ll 1$. In the transverse-traceless (TT) gauge, the perturbation satisfies $h_{0\\mu} = 0$, $\\partial^\\mu h_{\\mu\\nu} = 0$, and $h \\equiv \\eta^{\\mu\\nu}h_{\\mu\\nu} = 0$. For a plane gravitational wave propagating in the $z$-direction, a standard plus-polarized choice is $h_{xx}(t,z) = h_0 \\cos(k z - \\omega t)$ and $h_{yy}(t,z) = -h_{xx}(t,z)$, with all other components zero, where $h_0$ is a constant amplitude, $k$ is the spatial wave number, and $\\omega$ is the angular frequency.\n\nStarting from the linearized Ricci tensor definition,\n$$\nR^{(1)}_{\\mu\\nu} = \\tfrac{1}{2}\\left(\\partial_\\rho \\partial_\\mu h^{\\rho}{}_{\\nu} + \\partial_\\rho \\partial_\\nu h^{\\rho}{}_{\\mu} - \\Box h_{\\mu\\nu} - \\partial_\\mu \\partial_\\nu h\\right),\n$$\nwith $\\Box \\equiv \\eta^{\\alpha\\beta} \\partial_\\alpha \\partial_\\beta = -\\partial_t^2 + \\partial_x^2 + \\partial_y^2 + \\partial_z^2$ and indices raised/lowered by $\\eta_{\\mu\\nu}$, derive the simplification in TT gauge and explain why, for a vacuum plane wave obeying the dispersion relation $\\omega = k$ (with units where the speed of light $c = 1$), one expects $R^{(1)}_{\\mu\\nu} = 0$ pointwise.\n\nYou will implement a pseudo-spectral computation of derivatives using the Fast Fourier Transform (FFT) on a periodic domain in both time and space to numerically evaluate the linearized Ricci tensor for the above plane wave and quantify the spurious numerical $R^{(1)}_{\\mu\\nu}$ that arises due to discretization and representation errors. In particular, you will:\n- Represent the wave on a uniform grid in time $t \\in [0,T)$ and space $z \\in [0,L)$, with $N_t$ and $N_z$ grid points, respectively, using the exact field values $h_{xx}(t,z) = h_0 \\cos(k z - \\omega t)$ and $h_{yy}(t,z) = -h_{xx}(t,z)$, and all other $h_{\\mu\\nu}$ equal to zero.\n- Compute the linearized Ricci tensor componentwise using the TT-gauge simplification implied by the above definition. For the present symmetry, the only nonzero second derivatives are in $t$ and $z$, and the linearized Ricci tensor reduces to the action of the d'Alembertian operator on the nonzero components.\n- Use spectral differentiation: for a field $f(x)$ sampled on a uniform periodic grid of length $L$, the $n$-th derivative is computed in Fourier space by multiplying the discrete Fourier transform by $(i 2\\pi \\xi)^n$, where $\\xi$ are the discrete frequencies returned by the Fourier grid, and transforming back. For time, use the analogous construction with period $T$.\n\nBecause the exact $R^{(1)}_{\\mu\\nu}$ vanishes for an exact periodic plane wave that is exactly representable on the discrete Fourier grid (i.e., when $k = 2\\pi m/L$ and $\\omega = 2\\pi m/T$ for integers $m$), one expects numerical cancellation to machine precision for such conforming modes in a spectral code. For nonconforming modes (e.g., $k$ or $\\omega$ not commensurate with the domain periods), representation error leads to nonzero spurious values that should decrease as the grid is refined.\n\nImplement a program that:\n- Uses $h_0 = 10^{-6}$, $L = 1$, and $T = 1$.\n- Sets $k = 2\\pi m / L$ and $\\omega = 2\\pi m / T$ from a parameter $m$ for each test case.\n- Computes the linearized Ricci tensor components $R^{(1)}_{\\mu\\nu}(t,z)$ via the TT-gauge simplification implied by the definition and returns the scalar diagnostic\n$$\nE(N_t, N_z, m) = \\max_{t,z,\\mu,\\nu} \\left| R^{(1)}_{\\mu\\nu}(t,z) \\right|,\n$$\nthe maximum absolute value across the grid and all components.\n\nTest Suite:\n- Use the following six test cases, each given as a tuple $(N_z,N_t,m)$ with $L=T=1$:\n  1. $(64, 64, 5.0)$, a conforming mode.\n  2. $(8, 8, 1.0)$, a coarse but conforming mode.\n  3. $(16, 16, \\sqrt{2})$, a nonconforming mode.\n  4. $(32, 32, \\sqrt{2})$, a refined nonconforming mode.\n  5. $(64, 64, \\sqrt{2})$, a further refined nonconforming mode.\n  6. $(64, 64, 16.0)$, a high-frequency conforming mode below the Nyquist limit.\n\nAnswer Specification:\n- For each test case, compute $E(N_t, N_z, m)$ as a floating-point number.\n- The final program output must be a single line containing a list of six floating-point numbers corresponding to the six test cases in the order listed above, formatted as a comma-separated list enclosed in square brackets, for example, $[e_1,e_2,e_3,e_4,e_5,e_6]$.\n- No physical units are required in the answers because all quantities are dimensionless in the chosen units.", "solution": "The problem requires a two-part response: a theoretical derivation of the simplified linearized Ricci tensor in the transverse-traceless (TT) gauge and its value for a vacuum plane wave, followed by a numerical implementation to compute this tensor for a specific gravitational wave and quantify the numerical error.\n\n### Theoretical Derivation\n\nWe begin with the provided expression for the linearized Ricci tensor, $R^{(1)}_{\\mu\\nu}$, for a small perturbation $h_{\\mu\\nu}$ about the Minkowski metric $\\eta_{\\mu\\nu}$:\n$$\nR^{(1)}_{\\mu\\nu} = \\tfrac{1}{2}\\left(\\partial_\\rho \\partial_\\mu h^{\\rho}{}_{\\nu} + \\partial_\\rho \\partial_\\nu h^{\\rho}{}_{\\mu} - \\Box h_{\\mu\\nu} - \\partial_\\mu \\partial_\\nu h\\right)\n$$\nHere, indices are raised and lowered with $\\eta_{\\mu\\nu}$, and $\\Box \\equiv \\eta^{\\alpha\\beta} \\partial_\\alpha \\partial_\\beta$ is the d'Alembertian operator. The metric signature is $(-,+,+,+)$, so $\\eta_{\\mu\\nu} = \\text{diag}(-1, 1, 1, 1)$.\n\nThe problem is specified in the transverse-traceless (TT) gauge, which imposes the following conditions on the perturbation $h_{\\mu\\nu}$:\n1.  **Traceless condition**: The trace of the perturbation must be zero, $h \\equiv \\eta^{\\mu\\nu}h_{\\mu\\nu} = 0$.\n2.  **Transverse condition**: The four-divergence of the perturbation must be zero, $\\partial^\\mu h_{\\mu\\nu} = 0$.\n\nApplying the traceless condition ($h=0$) to the expression for $R^{(1)}_{\\mu\\nu}$ immediately eliminates the last term:\n$$\nR^{(1)}_{\\mu\\nu} = \\tfrac{1}{2}\\left(\\partial_\\rho \\partial_\\mu h^{\\rho}{}_{\\nu} + \\partial_\\rho \\partial_\\nu h^{\\rho}{}_{\\mu} - \\Box h_{\\mu\\nu}\\right)\n$$\n\nNext, we apply the transverse condition. Let's examine the term $\\partial_\\rho \\partial_\\mu h^{\\rho}{}_{\\nu}$. Raising the first index of $h_{\\alpha\\nu}$ gives $h^{\\rho}{}_{\\nu} = \\eta^{\\rho\\alpha} h_{\\alpha\\nu}$. The term becomes:\n$$\n\\partial_\\rho \\partial_\\mu h^{\\rho}{}_{\\nu} = \\partial_\\rho \\partial_\\mu (\\eta^{\\rho\\alpha} h_{\\alpha\\nu}) = \\eta^{\\rho\\alpha} \\partial_\\rho \\partial_\\mu h_{\\alpha\\nu}\n$$\nSince the partial derivatives commute ($\\partial_\\rho\\partial_\\mu = \\partial_\\mu\\partial_\\rho$) and the metric tensor components are constant, we can write:\n$$\n\\eta^{\\rho\\alpha} \\partial_\\mu \\partial_\\rho h_{\\alpha\\nu} = \\partial_\\mu (\\eta^{\\rho\\alpha} \\partial_\\rho h_{\\alpha\\nu}) = \\partial_\\mu (\\partial^\\alpha h_{\\alpha\\nu})\n$$\nThe transverse condition $\\partial^\\mu h_{\\mu\\nu} = 0$ means that the term in the parenthesis is zero. Therefore, $\\partial_\\mu (\\partial^\\alpha h_{\\alpha\\nu}) = \\partial_\\mu(0) = 0$.\nLikewise, the second term $\\partial_\\rho \\partial_\\nu h^{\\rho}{}_{\\mu}$ also vanishes by a symmetric argument.\n\nThis leaves a greatly simplified expression for the linearized Ricci tensor in the TT gauge:\n$$\nR^{(1)}_{\\mu\\nu} = -\\frac{1}{2} \\Box h_{\\mu\\nu}\n$$\n\nNow, we evaluate this for the given plus-polarized plane gravitational wave propagating in the $z$-direction. The non-zero components are $h_{xx}(t,z) = h_0 \\cos(k z - \\omega t)$ and $h_{yy}(t,z) = -h_{xx}(t,z)$. These components depend only on time $t$ and the propagation direction $z$. The d'Alembertian operator acting on any such function $f(t,z)$ simplifies to $\\Box f = (-\\partial_t^2 + \\partial_z^2)f$.\n\nLet's compute the second partial derivatives of $h_{xx}$:\n$$\n\\partial_t h_{xx} = \\partial_t [h_0 \\cos(k z - \\omega t)] = h_0 (-\\sin(k z - \\omega t))(-\\omega) = \\omega h_0 \\sin(k z - \\omega t)\n$$\n$$\n\\partial_t^2 h_{xx} = \\partial_t [\\omega h_0 \\sin(k z - \\omega t)] = \\omega h_0 (\\cos(k z - \\omega t))(-\\omega) = -\\omega^2 h_0 \\cos(k z - \\omega t) = -\\omega^2 h_{xx}\n$$\nSimilarly, for the spatial derivative:\n$$\n\\partial_z h_{xx} = \\partial_z [h_0 \\cos(k z - \\omega t)] = h_0 (-\\sin(k z - \\omega t))(k) = -k h_0 \\sin(k z - \\omega t)\n$$\n$$\n\\partial_z^2 h_{xx} = \\partial_z [-k h_0 \\sin(k z - \\omega t)] = -k h_0 (\\cos(k z - \\omega t))(k) = -k^2 h_0 \\cos(k z - \\omega t) = -k^2 h_{xx}\n$$\nApplying the d'Alembertian to $h_{xx}$:\n$$\n\\Box h_{xx} = (-\\partial_t^2 + \\partial_z^2)h_{xx} = -(-\\omega^2 h_{xx}) + (-k^2 h_{xx}) = (\\omega^2 - k^2)h_{xx}\n$$\nFor a gravitational wave in a vacuum, the dispersion relation is $\\omega = k$ (in geometric units where $c=1$). Substituting this into the equation yields:\n$$\n\\Box h_{xx} = (k^2 - k^2)h_{xx} = 0\n$$\nSince $\\Box h_{xx}=0$, and all other $h_{\\mu\\nu}$ are either zero or proportional to $h_{xx}$, it follows that $\\Box h_{\\mu\\nu} = 0$ for all components. Consequently, the linearized Ricci tensor vanishes pointwise:\n$$\nR^{(1)}_{\\mu\\nu} = -\\frac{1}{2} \\Box h_{\\mu\\nu} = 0\n$$\nThis demonstrates that the given gravitational wave is a solution to the linearized vacuum Einstein equations.\n\n### Numerical Implementation\n\nThe numerical task is to compute $R^{(1)}_{\\mu\\nu}$ using spectral methods and find the maximum absolute value of its components, $E = \\max |R^{(1)}_{\\mu\\nu}|$. Based on the derivation above, we will compute $R^{(1)}_{\\mu\\nu} = -\\frac{1}{2}(-\\partial_t^2 + \\partial_z^2)h_{\\mu\\nu}$. Since the exact result is zero, any non-zero value for $E$ will be a measure of the numerical error.\n\nThe algorithm proceeds as follows for each test case $(N_z, N_t, m)$:\n1.  Define the physical and numerical parameters: $h_0 = 10^{-6}$, $L=T=1$, $k=2\\pi m/L$, $\\omega=2\\pi m/T$.\n2.  Discretize the domain: create uniform grids for time $t \\in [0,T)$ with $N_t$ points and space $z \\in [0,L)$ with $N_z$ points.\n3.  Evaluate the field $h_{xx}(t,z)$ on the two-dimensional grid. Note that $h_{yy} = -h_{xx}$ and all other components are zero.\n4.  Compute the second time derivative, $\\partial_t^2 h_{xx}$, using the FFT. This involves:\n    a. Performing a 1D FFT of $h_{xx}$ along the time-axis.\n    b. Multiplying the result in Fourier space by $-(\\omega_{\\text{freq}}^k)^2$, where $\\omega_{\\text{freq}}^k$ are the discrete angular frequencies.\n    c. Performing an inverse 1D FFT.\n5.  Similarly, compute the second spatial derivative, $\\partial_z^2 h_{xx}$, using the FFT along the space-axis and multiplying by $-(k_{\\text{freq}}^j)^2$.\n6.  Combine the derivatives to find $\\Box h_{xx} = -\\partial_t^2 h_{xx} + \\partial_z^2 h_{xx}$.\n7.  Compute $R^{(1)}_{xx} = -0.5 \\cdot \\Box h_{xx}$.\n8.  The other non-zero component is $R^{(1)}_{yy} = -R^{(1)}_{xx}$. All others are zero. Therefore, the diagnostic $E$ is simply the maximum absolute value of $R^{(1)}_{xx}$ over the grid: $E = \\max |R^{(1)}_{xx}(t,z)|$.\n\nThis process is repeated for all test cases. For \"conforming\" modes, where the parameter $m$ is an integer, the plane wave is exactly periodic on the computational domain. A spectral method should be able to represent the function and its derivatives to machine precision, leading to a numerical result for $E$ that is close to zero. For \"nonconforming\" modes, where $m$ is not an integer (like $\\sqrt{2}$), the wave is not periodic on the domain. The FFT's implicit assumption of periodicity introduces representation errors (spectral leakage), resulting in a larger, non-zero value for $E$. Increasing grid resolution for nonconforming modes should decrease this error, demonstrating the spectral convergence of the method.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_ricci_error(Nz, Nt, m):\n    \"\"\"\n    Computes the maximum numerical error in the linearized Ricci tensor\n    for a given grid size and wave mode.\n    \n    Args:\n        Nz (int): Number of grid points in the z-direction.\n        Nt (int): Number of grid points in the t-direction.\n        m (float): Mode number parameter for the plane wave.\n\n    Returns:\n        float: The diagnostic E(Nt, Nz, m).\n    \"\"\"\n    # Physical and domain parameters\n    h0 = 1.0e-6\n    L = 1.0\n    T = 1.0\n\n    # Wave parameters\n    # The dispersion relation omega = k is satisfied since L=T\n    k = 2.0 * np.pi * m / L\n    omega = 2.0 * np.pi * m / T\n\n    # Spatial and temporal grids\n    z = np.linspace(0, L, Nz, endpoint=False)\n    t = np.linspace(0, T, Nt, endpoint=False)\n    T_grid, Z_grid = np.meshgrid(t, z, indexing='ij')\n\n    # Gravitational wave perturbation h_xx(t, z)\n    # The other non-zero component is h_yy = -h_xx.\n    hxx = h0 * np.cos(k * Z_grid - omega * T_grid)\n\n    # Compute second time derivative using FFT\n    # Step 1: FFT along the time axis (axis=0)\n    hxx_tilde_t = np.fft.fft(hxx, axis=0)\n    # Step 2: Get angular frequencies and multiply by -(omega_freq)^2\n    dt = T / Nt\n    omega_freqs = 2.0 * np.pi * np.fft.fftfreq(Nt, d=dt)\n    # The frequency array must be broadcastable to the shape of hxx_tilde_t\n    # (Nt,) - (Nt, 1) to multiply with (Nt, Nz)\n    d2hxx_dt2_tilde = -(omega_freqs**2)[:, np.newaxis] * hxx_tilde_t\n    # Step 3: Inverse FFT\n    d2hxx_dt2 = np.fft.ifft(d2hxx_dt2_tilde, axis=0)\n\n    # Compute second spatial derivative using FFT\n    # Step 1: FFT along the space axis (axis=1)\n    hxx_tilde_z = np.fft.fft(hxx, axis=1)\n    # Step 2: Get spatial wavenumbers and multiply by -(k_freq)^2\n    dz = L / Nz\n    k_freqs = 2.0 * np.pi * np.fft.fftfreq(Nz, d=dz)\n    # The frequency array must be broadcastable to the shape of hxx_tilde_z\n    # (Nz,) - (1, Nz) to multiply with (Nt, Nz)\n    d2hxx_dz2_tilde = -(k_freqs**2)[np.newaxis, :] * hxx_tilde_z\n    # Step 3: Inverse FFT\n    d2hxx_dz2 = np.fft.ifft(d2hxx_dz2_tilde, axis=1)\n\n    # The real parts are taken to discard imaginary noise from FFT numerics\n    d2hxx_dt2_real = d2hxx_dt2.real\n    d2hxx_dz2_real = d2hxx_dz2.real\n\n    # Compute d'Alembertian: Box h_xx = -d2h/dt2 + d2h/dz2\n    box_hxx = -d2hxx_dt2_real + d2hxx_dz2_real\n\n    # Compute Ricci tensor component: R_xx = -0.5 * Box h_xx\n    R1_xx = -0.5 * box_hxx\n\n    # The diagnostic E is the maximum absolute value over all components and the grid.\n    # Since |R_yy| = |-R_xx| = |R_xx| and other components are zero,\n    # we just need the max absolute value of R_xx.\n    error = np.max(np.abs(R1_xx))\n    \n    return error\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (Nz, Nt, m).\n    test_cases = [\n        (64, 64, 5.0),\n        (8, 8, 1.0),\n        (16, 16, np.sqrt(2)),\n        (32, 32, np.sqrt(2)),\n        (64, 64, np.sqrt(2)),\n        (64, 64, 16.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        Nz, Nt, m = case\n        result = compute_ricci_error(Nz, Nt, m)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.16e}' for r in results)}]\")\n\nsolve()\n```", "id": "3494925"}]}