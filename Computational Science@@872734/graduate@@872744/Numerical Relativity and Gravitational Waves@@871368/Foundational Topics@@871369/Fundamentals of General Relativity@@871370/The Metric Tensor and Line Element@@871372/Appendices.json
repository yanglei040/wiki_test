{"hands_on_practices": [{"introduction": "This exercise is a cornerstone of any numerical relativity workflow: code verification. Before using a computational tool to explore unknown physics, it must be rigorously tested against known analytical solutions. This practice guides you through implementing the fundamental calculations of tensor calculus—from the metric tensor $g_{\\mu\\nu}$ to the Ricci tensor $R_{\\mu\\nu}$—and applying them to standard spacetimes like Minkowski, Schwarzschild, and a pp-wave. By confirming that your code correctly identifies these as vacuum solutions, you build confidence in your tool's ability to accurately represent spacetime geometry. [@problem_id:3493362]", "problem": "You are asked to implement a program that tests a tensor-calculus kernel using analytic metrics that are standard in numerical relativity. The core quantities are the metric tensor and line element. Work in geometrized units where $G=c=1$, and treat all quantities as dimensionless. All angles must be interpreted in radians. Your program must compute, for several analytic spacetimes and specified coordinate points and displacements, the squared line element and verify the vacuum Einstein equations via the Ricci tensor. Your output must aggregate all test results into a single line printed as a comma-separated list enclosed in square brackets.\n\nFundamental base to use:\n\n- The line element is defined by $ds^{2} = g_{\\mu\\nu} \\, dx^{\\mu} \\, dx^{\\nu}$, where $g_{\\mu\\nu}$ is the metric tensor and $dx^{\\mu}$ is an infinitesimal coordinate displacement.\n\n- The Levi-Civita connection (Christoffel symbols) for a metric-compatible, torsion-free connection is\n$$\n\\Gamma^{\\rho}{}_{\\mu\\nu} = \\frac{1}{2} g^{\\rho\\sigma} \\left( \\partial_{\\mu} g_{\\sigma\\nu} + \\partial_{\\nu} g_{\\sigma\\mu} - \\partial_{\\sigma} g_{\\mu\\nu} \\right),\n$$\nwhere $g^{\\mu\\nu}$ is the inverse of $g_{\\mu\\nu}$.\n\n- The derivative of the inverse metric follows from $g^{\\mu\\alpha} g_{\\alpha\\nu} = \\delta^{\\mu}{}_{\\nu}$:\n$$\n\\partial_{\\lambda} g^{\\mu\\nu} = - \\, g^{\\mu\\alpha} \\, (\\partial_{\\lambda} g_{\\alpha\\beta}) \\, g^{\\beta\\nu}.\n$$\n\n- The Ricci tensor is the contraction of the Riemann curvature tensor:\n$$\nR_{\\mu\\nu} = \\partial_{\\alpha} \\Gamma^{\\alpha}{}_{\\mu\\nu} - \\partial_{\\nu} \\Gamma^{\\alpha}{}_{\\mu\\alpha} + \\Gamma^{\\alpha}{}_{\\alpha\\beta} \\Gamma^{\\beta}{}_{\\mu\\nu} - \\Gamma^{\\alpha}{}_{\\mu\\beta} \\Gamma^{\\beta}{}_{\\alpha\\nu}.\n$$\n\nYour program must implement the following requirements:\n\n1. Implement generic routines that, given a metric $g_{\\mu\\nu}(x^{\\lambda})$ and its first and second partial derivatives $\\partial_{\\lambda} g_{\\mu\\nu}$ and $\\partial_{\\kappa}\\partial_{\\lambda} g_{\\mu\\nu}$ at a point, compute:\n   - The inverse metric $g^{\\mu\\nu}$ and its first derivatives $\\partial_{\\lambda} g^{\\mu\\nu}$.\n   - The Christoffel symbols $\\Gamma^{\\rho}{}_{\\mu\\nu}$ and their first derivatives $\\partial_{\\lambda}\\Gamma^{\\rho}{}_{\\mu\\nu}$.\n   - The Ricci tensor $R_{\\mu\\nu}$ from the above definition.\n\n2. Implement three analytic metrics by providing $g_{\\mu\\nu}$, $\\partial_{\\lambda} g_{\\mu\\nu}$, and $\\partial_{\\kappa}\\partial_{\\lambda} g_{\\mu\\nu}$ in closed form:\n   - Minkowski metric in Cartesian coordinates $(t,x,y,z)$ with signature $(-,+,+,+)$:\n     $$\n     g_{\\mu\\nu} = \\mathrm{diag}(-1,\\,1,\\,1,\\,1).\n     $$\n   - Schwarzschild metric in Schwarzschild coordinates $(t,r,\\theta,\\phi)$ with mass parameter $M$:\n     $$\n     g_{tt} = -(1 - 2M/r), \\quad g_{rr} = (1 - 2M/r)^{-1}, \\quad g_{\\theta\\theta} = r^{2}, \\quad g_{\\phi\\phi} = r^{2} \\sin^{2}\\theta,\n     $$\n     with all off-diagonal components equal to $0$.\n   - Plane-fronted gravitational wave with parallel rays (pp-wave) in Brinkmann coordinates $(u,v,x,y)$:\n     $$\n     ds^{2} = -2 \\, du \\, dv + H(u,x,y) \\, du^{2} + dx^{2} + dy^{2},\n     $$\n     with\n     $$\n     H(u,x,y) = \\sin u \\,(x^{2} - y^{2}).\n     $$\n     The nonzero components are $g_{uu} = H$, $g_{uv}=g_{vu}=-1$, $g_{xx}=1$, $g_{yy}=1$.\n\n3. For each specified test case, compute:\n   - The squared line element $ds^{2} = g_{\\mu\\nu} dx^{\\mu} dx^{\\nu}$ for the provided infinitesimal displacement $dx^{\\mu}$.\n   - A vacuum check boolean defined by\n     $$\n     \\mathrm{vacuum\\_ok} = \\left( \\max_{\\mu,\\nu} |R_{\\mu\\nu}|  \\varepsilon \\right),\n     $$\n     using the threshold $\\varepsilon = 10^{-9}$.\n\n4. Test suite. Use the following parameter values and displacements exactly:\n\n   - Test A (Minkowski):\n     - Coordinates $(t,x,y,z) = (0,\\,1,\\,2,\\,3)$.\n     - Displacement $dx^{\\mu} = (1,\\,0.5,\\,0,\\,0)$.\n     - Expected qualitative behavior: flat spacetime with $R_{\\mu\\nu} = 0$.\n\n   - Test B (Schwarzschild):\n     - Mass $M = 1$.\n     - Coordinates $(t,r,\\theta,\\phi) = (0,\\,10,\\,\\pi/2,\\,0)$.\n     - Displacement $dx^{\\mu} = (1,\\,0,\\,0,\\,0)$.\n     - Expected qualitative behavior: vacuum region with $R_{\\mu\\nu} = 0$.\n\n   - Test C (Schwarzschild, near horizon):\n     - Mass $M = 1$.\n     - Coordinates $(t,r,\\theta,\\phi) = (0,\\,2.1,\\,\\pi/2,\\,0)$.\n     - Displacement $dx^{\\mu} = (1,\\,0,\\,0,\\,0)$.\n     - Expected qualitative behavior: vacuum region with $R_{\\mu\\nu} = 0$; approach to horizon tests numerical stability.\n\n   - Test D (pp-wave, symmetric transverse coordinates):\n     - Coordinates $(u,v,x,y) = (0.3,\\,0,\\,1,\\,1)$.\n     - Displacement $dx^{\\mu} = (1,\\,0,\\,0.5,\\,-0.5)$.\n     - Expected qualitative behavior: $H=0$ at this point, so transverse contribution dominates $ds^{2}$; vacuum solution implies $R_{\\mu\\nu}=0$.\n\n   - Test E (pp-wave, nontrivial profile):\n     - Coordinates $(u,v,x,y) = (1.0,\\,0,\\,2,\\,1)$.\n     - Displacement $dx^{\\mu} = (1,\\,0,\\,0,\\,0)$.\n     - Expected qualitative behavior: $ds^{2} = H(u,x,y)$; vacuum solution implies $R_{\\mu\\nu}=0$.\n\n5. Output format. Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, append two items to the list in the following order:\n   - The computed $ds^{2}$ as a floating-point number (no rounding requirement beyond the language default).\n   - The vacuum check boolean $\\mathrm{vacuum\\_ok}$.\n\nThus, your program must print a single line with ten entries:\n$$\n[\\; ds^{2}_{A},\\ \\mathrm{vacuum\\_ok}_{A},\\ ds^{2}_{B},\\ \\mathrm{vacuum\\_ok}_{B},\\ ds^{2}_{C},\\ \\mathrm{vacuum\\_ok}_{C},\\ ds^{2}_{D},\\ \\mathrm{vacuum\\_ok}_{D},\\ ds^{2}_{E},\\ \\mathrm{vacuum\\_ok}_{E} \\;].\n$$", "solution": "The user problem is a well-posed computational task in the domain of numerical relativity and tensor calculus, requiring the implementation of core general relativistic quantities and their verification for known analytic solutions of Einstein's field equations. The problem is scientifically grounded, formally specified, and free of any invalidating flaws. A complete solution can be constructed by following a systematic, principle-based approach.\n\nThe solution is structured into two primary components:\n1. A set of classes representing the analytic spacetimes, which provide the metric tensor $g_{\\mu\\nu}$ and its first $\\partial_{\\lambda}g_{\\mu\\nu}$ and second $\\partial_{\\kappa}\\partial_{\\lambda}g_{\\mu\\nu}$ partial derivatives in closed form.\n2. A generic tensor computation engine that, given these derivatives at a point, calculates all derived quantities, including the squared line element $ds^2$ and the Ricci tensor $R_{\\mu\\nu}$.\n\nThe coordinates are consistently indexed from $0$ to $3$. For example, in Schwarzschild coordinates $(t,r,\\theta,\\phi)$, the indices are $\\mu=0$ for $t$, $\\mu=1$ for $r$, $\\mu=2$ for $\\theta$, and $\\mu=3$ for $\\phi$. All arrays follow this convention, e.g., a tensor $T_{\\lambda\\mu\\nu}$ is stored in a NumPy array `T` where the component is accessed as `T[l,m,n]`.\n\nThe core computational steps are as follows:\n\n1.  **Metric and its Derivatives**: For each test case, the appropriate metric class is instantiated. This class provides numerical values for the metric tensor $g_{\\mu\\nu}$, its first derivatives $\\partial_{\\lambda} g_{\\mu\\nu}$, and its second derivatives $\\partial_{\\kappa}\\partial_{\\lambda} g_{\\mu\\nu}$ at the specified coordinate point. These serve as the fundamental inputs for all subsequent calculations.\n\n2.  **Squared Line Element $ds^2$**: The squared line element is computed from the metric $g_{\\mu\\nu}$ and the given coordinate displacement vector $dx^{\\mu}$ using Einstein's summation convention, as per the definition:\n    $$\n    ds^{2} = g_{\\mu\\nu} \\, dx^{\\mu} \\, dx^{\\nu}\n    $$\n    This is a tensor contraction implemented efficiently using matrix-vector operations.\n\n3.  **Inverse Metric $g^{\\mu\\nu}$ and its Derivative $\\partial_{\\lambda}g^{\\mu\\nu}$**: The inverse metric $g^{\\mu\\nu}$ is calculated by numerically inverting the matrix representation of $g_{\\mu\\nu}$. The derivative of the inverse metric is then computed from the derivative of the metric using the identity derived from $\\partial_{\\lambda}(g^{\\mu\\alpha}g_{\\alpha\\nu}) = 0$:\n    $$\n    \\partial_{\\lambda} g^{\\mu\\nu} = -g^{\\mu\\alpha} (\\partial_{\\lambda} g_{\\alpha\\beta}) g^{\\beta\\nu}\n    $$\n    This formula is implemented using tensor products (specifically, `numpy.einsum`).\n\n4.  **Christoffel Symbols $\\Gamma^{\\rho}{}_{\\mu\\nu}$ and their Derivatives $\\partial_{\\lambda}\\Gamma^{\\rho}{}_{\\mu\\nu}$**: The Christoffel symbols of the second kind are computed using the standard formula for a metric-compatible, torsion-free connection:\n    $$\n    \\Gamma^{\\rho}{}_{\\mu\\nu} = \\frac{1}{2} g^{\\rho\\sigma} \\left( \\partial_{\\mu} g_{\\sigma\\nu} + \\partial_{\\nu} g_{\\sigma\\mu} - \\partial_{\\sigma} g_{\\mu\\nu} \\right)\n    $$\n    The derivatives of the Christoffel symbols, $\\partial_{\\lambda}\\Gamma^{\\rho}{}_{\\mu\\nu}$, are found by applying the product rule to the above expression:\n    $$\n    \\partial_{\\lambda} \\Gamma^{\\rho}{}_{\\mu\\nu} = \\frac{1}{2} (\\partial_{\\lambda} g^{\\rho\\sigma}) \\left( \\dots \\right) + \\frac{1}{2} g^{\\rho\\sigma} \\left( \\partial_{\\lambda}\\partial_{\\mu} g_{\\sigma\\nu} + \\partial_{\\lambda}\\partial_{\\nu} g_{\\sigma\\mu} - \\partial_{\\lambda}\\partial_{\\sigma} g_{\\mu\\nu} \\right)\n    $$\n    These computations rely on the metric derivatives calculated in step 1 and the inverse metric derivatives from step 3. All tensor contractions are performed using `numpy.einsum` for efficiency and clarity.\n\n5.  **Ricci Tensor $R_{\\mu\\nu}$**: The Ricci tensor is assembled from the Christoffel symbols and their derivatives according to its definition:\n    $$\n    R_{\\mu\\nu} = \\partial_{\\alpha} \\Gamma^{\\alpha}{}_{\\mu\\nu} - \\partial_{\\nu} \\Gamma^{\\alpha}{}_{\\mu\\alpha} + \\Gamma^{\\alpha}{}_{\\alpha\\beta} \\Gamma^{\\beta}{}_{\\mu\\nu} - \\Gamma^{\\alpha}{}_{\\mu\\beta} \\Gamma^{\\beta}{}_{\\alpha\\nu}\n    $$\n    Each term involves contractions over one or two indices, which are again implemented with `numpy.einsum` or explicit loops for clarity where `einsum` notation becomes ambiguous.\n\n6.  **Vacuum Check**: The computed Ricci tensor $R_{\\mu\\nu}$ is used to verify if the spacetime is a vacuum solution at the specified point. All given spacetimes (Minkowski, Schwarzschild outside the mass, and the pp-wave) are exact vacuum solutions, meaning their Ricci tensor should be identically zero, $R_{\\mu\\nu}=0$. Due to floating-point arithmetic, the computed components will be close to, but not exactly, zero. The vacuum condition is therefore checked numerically:\n    $$\n    \\mathrm{vacuum\\_ok} = \\left( \\max_{\\mu,\\nu} |R_{\\mu\\nu}|  \\varepsilon \\right)\n    $$\n    where the threshold is given as $\\varepsilon = 10^{-9}$.\n\nBy implementing these steps for each test case specified in the problem, we generate the required sequence of results: the squared line element $ds^2$ and the boolean vacuum check status for each test. The results are then aggregated into a single list and formatted as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# language: Python\n# version: 3.12\n# libraries:\n#   - name: numpy\n#     version: 1.23.5\n#   - name: scipy\n#     version: 1.11.4\n\nclass TensorAnalysis:\n    \"\"\"\n    Performs tensor calculus computations given a metric and its derivatives.\n    \"\"\"\n    def __init__(self, g, dg, ddg):\n        self.dim = g.shape[0]\n        self.g = g          # g_mn\n        self.dg = dg        # d_l g_mn\n        self.ddg = ddg      # d_k d_l g_mn\n\n        # Pre-compute all derived quantities\n        self.g_inv = np.linalg.inv(self.g) # g^rs\n        self.dg_inv = self._compute_dg_inv() # d_l g^mn\n        self.gamma = self._compute_gamma() # Gamma^r_mn\n        self.dgamma = self._compute_dgamma() # d_l Gamma^r_mn\n        self.ricci = self._compute_ricci() # R_mn\n\n    def _compute_dg_inv(self):\n        # d_l g^mn = -g^ma (d_l g_ab) g^bn\n        return -np.einsum('ma,lab,bn-lmn', self.g_inv, self.dg, self.g_inv)\n\n    def _compute_gamma(self):\n        # Gamma^r_mn = 1/2 g^rs (d_m g_sn + d_n g_sm - d_s g_mn)\n        christoffel_part_lower = self.dg.transpose(1, 2, 0) + self.dg.transpose(2, 1, 0) - self.dg\n        # The above is a compact way of writing:\n        # christoffel_part_lower[s,m,n] = dg[m,s,n] + dg[n,s,m] - dg[s,m,n]\n        return 0.5 * np.einsum('rs,smn-rmn', self.g_inv, christoffel_part_lower)\n\n    def _compute_dgamma(self):\n        # d_l Gamma^r_mn = 1/2 (d_l g^rs)(...) + 1/2 g^rs (d_l d_m g_sn + ...)\n        christoffel_part_lower = self.dg.transpose(1, 2, 0) + self.dg.transpose(2, 1, 0) - self.dg\n        term1 = 0.5 * np.einsum('lrs,smn-lrmn', self.dg_inv, christoffel_part_lower)\n\n        christoffel_deriv_part_lower = self.ddg.transpose(0, 2, 1, 3) + self.ddg.transpose(0, 3, 1, 2) - self.ddg.transpose(0, 2, 3, 1)        \n        # Above is equivalent to:\n        # cdpl[l,s,m,n] = ddg[l,m,s,n] + ddg[l,n,s,m] - ddg[l,s,m,n]\n        term2 = 0.5 * np.einsum('rs,lsmn-lrmn', self.g_inv, christoffel_deriv_part_lower)\n        \n        return term1 + term2\n\n    def _compute_ricci(self):\n        # R_mn = d_a G^a_mn - d_n G^a_ma + G^a_ab G^b_mn - G^a_mb G^b_an\n        term1 = np.einsum('aamn-mn', self.dgamma)\n        \n        # term2 = d_n G^a_ma. Loop is clearer than tricky einsum.\n        term2 = np.zeros((self.dim, self.dim))\n        for m in range(self.dim):\n            for n in range(self.dim):\n                for a in range(self.dim):\n                    term2[m, n] += self.dgamma[n, a, m, a]\n\n        term3 = np.einsum('aab,bmn-mn', self.gamma, self.gamma)\n        term4 = np.einsum('amb,ban-mn', self.gamma, self.gamma)\n        return term1 - term2 + term3 - term4\n\n    def compute_ds2(self, dx):\n        # ds^2 = g_mn dx^m dx^n\n        return np.einsum('ij,i,j-', self.g, dx, dx)\n\n    def get_ricci_tensor(self):\n        return self.ricci\n\nclass AnalyticMetric:\n    def __init__(self, dim=4, **kwargs):\n        self.dim = dim\n\n    def get_derivatives(self, coords):\n        raise NotImplementedError\n\nclass MinkowskiMetric(AnalyticMetric):\n    def get_derivatives(self, coords):\n        g = np.diag([-1.0, 1.0, 1.0, 1.0])\n        dg = np.zeros((self.dim, self.dim, self.dim))\n        ddg = np.zeros((self.dim, self.dim, self.dim, self.dim))\n        return g, dg, ddg\n\nclass SchwarzschildMetric(AnalyticMetric):\n    def __init__(self, M, dim=4):\n        super().__init__(dim)\n        self.M = M\n\n    def get_derivatives(self, coords):\n        _t, r, th, _p = coords\n        M = self.M\n        g = np.zeros((self.dim, self.dim))\n        dg = np.zeros((self.dim, self.dim, self.dim))\n        ddg = np.zeros((self.dim, self.dim, self.dim, self.dim))\n\n        f = 1.0 - 2.0 * M / r\n        sin_th = np.sin(th)\n        cos_th = np.cos(th)\n        sin_2th = np.sin(2.0 * th)\n        cos_2th = np.cos(2.0 * th)\n\n        # Metric components (non-zero)\n        g[0, 0] = -f\n        g[1, 1] = 1.0 / f\n        g[2, 2] = r**2\n        g[3, 3] = r**2 * sin_th**2\n\n        # First derivatives (only w.r.t r=1 and th=2 are non-zero)\n        # partial_r\n        df_dr = 2.0 * M / r**2\n        gtt_r = -df_dr\n        grr_r = -1.0 / f**2 * df_dr\n        dg[1, 0, 0] = gtt_r\n        dg[1, 1, 1] = grr_r\n        dg[1, 2, 2] = 2.0 * r\n        dg[1, 3, 3] = 2.0 * r * sin_th**2\n        # partial_theta\n        gpp_th = r**2 * sin_2th\n        dg[2, 3, 3] = gpp_th\n\n        # Second derivatives\n        # partial_r partial_r\n        d2f_dr2 = -4.0 * M / r**3\n        gtt_rr = -d2f_dr2\n        grr_rr = (2.0 / f**3) * df_dr**2 - (1.0 / f**2) * d2f_dr2\n        ddg[1, 1, 0, 0] = gtt_rr\n        ddg[1, 1, 1, 1] = grr_rr\n        ddg[1, 1, 2, 2] = 2.0\n        ddg[1, 1, 3, 3] = 2.0 * sin_th**2\n        # partial_th partial_th\n        gpp_thth = r**2 * 2.0 * cos_2th\n        ddg[2, 2, 3, 3] = gpp_thth\n        # partial_r partial_th (mixed)\n        gpp_rth = 2.0 * r * sin_2th\n        ddg[1, 2, 3, 3] = gpp_rth\n        ddg[2, 1, 3, 3] = gpp_rth\n        \n        return g, dg, ddg\n\nclass PPWaveMetric(AnalyticMetric):\n    def get_derivatives(self, coords):\n        u, _v, x, y = coords\n        g = np.zeros((self.dim, self.dim))\n        dg = np.zeros((self.dim, self.dim, self.dim))\n        ddg = np.zeros((self.dim, self.dim, self.dim, self.dim))\n\n        sin_u = np.sin(u)\n        cos_u = np.cos(u)\n        \n        H = sin_u * (x**2 - y**2)\n        \n        # Metric components\n        g[0, 0] = H\n        g[0, 1] = g[1, 0] = -1.0\n        g[2, 2] = 1.0\n        g[3, 3] = 1.0\n\n        # First derivatives (only g_00 depends on coords)\n        dg[0, 0, 0] = cos_u * (x**2 - y**2) # d_u g_uu\n        dg[2, 0, 0] = sin_u * (2.0 * x)     # d_x g_uu\n        dg[3, 0, 0] = sin_u * (-2.0 * y)    # d_y g_uu\n\n        # Second derivatives\n        ddg[0, 0, 0, 0] = -sin_u * (x**2 - y**2) # d_u d_u g_uu\n        ddg[2, 2, 0, 0] = sin_u * 2.0             # d_x d_x g_uu\n        ddg[3, 3, 0, 0] = sin_u * -2.0            # d_y d_y g_uu\n        \n        # Mixed derivatives\n        ddg[0, 2, 0, 0] = ddg[2, 0, 0, 0] = cos_u * (2.0 * x)     # d_u d_x g_uu\n        ddg[0, 3, 0, 0] = ddg[3, 0, 0, 0] = cos_u * (-2.0 * y)    # d_u d_y g_uu\n        # d_x d_y g_uu is zero\n\n        return g, dg, ddg\n\ndef solve():\n    test_cases = [\n        {\n            'name': 'A',\n            'metric_class': MinkowskiMetric,\n            'params': {},\n            'coords': np.array([0.0, 1.0, 2.0, 3.0]),\n            'dx': np.array([1.0, 0.5, 0.0, 0.0]),\n        },\n        {\n            'name': 'B',\n            'metric_class': SchwarzschildMetric,\n            'params': {'M': 1.0},\n            'coords': np.array([0.0, 10.0, np.pi/2, 0.0]),\n            'dx': np.array([1.0, 0.0, 0.0, 0.0]),\n        },\n        {\n            'name': 'C',\n            'metric_class': SchwarzschildMetric,\n            'params': {'M': 1.0},\n            'coords': np.array([0.0, 2.1, np.pi/2, 0.0]),\n            'dx': np.array([1.0, 0.0, 0.0, 0.0]),\n        },\n        {\n            'name': 'D',\n            'metric_class': PPWaveMetric,\n            'params': {},\n            'coords': np.array([0.3, 0.0, 1.0, 1.0]),\n            'dx': np.array([1.0, 0.0, 0.5, -0.5]),\n        },\n        {\n            'name': 'E',\n            'metric_class': PPWaveMetric,\n            'params': {},\n            'coords': np.array([1.0, 0.0, 2.0, 1.0]),\n            'dx': np.array([1.0, 0.0, 0.0, 0.0]),\n        },\n    ]\n\n    results = []\n    vacuum_threshold = 1e-9\n\n    for case in test_cases:\n        metric_instance = case['metric_class'](**case['params'])\n        g, dg, ddg = metric_instance.get_derivatives(case['coords'])\n        \n        analysis = TensorAnalysis(g, dg, ddg)\n        \n        ds2 = analysis.compute_ds2(case['dx'])\n        ricci = analysis.get_ricci_tensor()\n        \n        max_abs_ricci = np.max(np.abs(ricci))\n        vacuum_ok = max_abs_ricci  vacuum_threshold\n        \n        results.append(ds2)\n        results.append(vacuum_ok)\n    \n    # Format boolean as lowercase 'true'/'false' for consistency, then join.\n    formatted_results = [str(r).lower() if isinstance(r, bool) else str(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\nsolve()\n\n```", "id": "3493362"}, {"introduction": "In numerical simulations, the spacetime metric is not a static, analytical formula but a dynamic field evolved on a computational grid, where numerical errors can accumulate and push the metric into an unphysical state. This practice introduces essential diagnostic techniques to monitor the health of a simulation by verifying the metric's Lorentzian signature and the positive-definiteness of its spatial geometry. Learning to perform these checks is crucial for ensuring that fundamental concepts like time and space remain well-defined throughout a simulation. [@problem_id:3493424]", "problem": "A spacetime metric tensor $g_{\\mu\\nu}$ determines the line element $ds^2 = g_{\\mu\\nu} \\, dx^{\\mu} \\, dx^{\\nu}$ and the causal character of vectors in a numerical relativity simulation. In a physically valid Lorentzian spacetime relevant to gravitational wave modeling, the metric must have signature $(-,+,+,+)$, its induced spatial $3\\times 3$ block must be positive-definite, and the line element must classify representative vectors consistently: a time-like vector $u^{\\mu}$ must yield $ds^2 lt; 0$, while a space-like vector $s^{\\mu}$ must yield $ds^2 gt; 0$, in units where the speed of light is $c=1$. Your task is to write a program that verifies these properties for a given test suite of metrics and vectors, as would be required to catch signature or positivity violations in simulations.\n\nFundamental base and core definitions to use:\n- The metric tensor $g_{\\mu\\nu}$ is symmetric and defines the bilinear form for the line element $ds^2 = g_{\\mu\\nu} \\, v^{\\mu} \\, v^{\\nu}$ for any tangent vector $v^{\\mu}$.\n- A metric has Lorentzian signature $(-,+,+,+)$ if, by Sylvester’s law of inertia, the count of negative, positive, and zero eigenvalues of the symmetric matrix $g_{\\mu\\nu}$ is invariant and equals one negative and three positive, with no zero eigenvalues (non-degenerate).\n- In the $3+1$ decomposition, the induced spatial metric $\\gamma_{ij} \\equiv g_{ij}$ (the spatial $3\\times 3$ block in coordinates $(t,x,y,z)$ with indices $i,j \\in \\{1,2,3\\}$) must be positive-definite, i.e., all its eigenvalues must be strictly positive.\n- Causal classification for signature $(-,+,+,+)$: for a physically realizable time-like vector $u^{\\mu}$, $ds^2 = g_{\\mu\\nu} u^{\\mu} u^{\\nu} lt; 0$, and for a space-like vector $s^{\\mu}$, $ds^2 = g_{\\mu\\nu} s^{\\mu} s^{\\nu} gt; 0$.\n\nNumerical classification rule:\n- To model floating-point effects, use a tolerance $\\epsilon = 10^{-10}$ to classify eigenvalues and line elements. Count an eigenvalue as negative if it is $lt; -\\epsilon$, positive if it is $gt; \\epsilon$, and zero (degenerate) if its absolute value is $\\le \\epsilon$. For the line element classification, require $g_{\\mu\\nu} u^{\\mu} u^{\\nu} lt; -\\epsilon$ for time-like and $g_{\\mu\\nu} s^{\\mu} s^{\\nu} gt; \\epsilon$ for space-like.\n\nTest suite:\n- Case A (Minkowski spacetime): $g^{(A)}_{\\mu\\nu} = \\mathrm{diag}(-1,\\,1,\\,1,\\,1)$, $u^{\\mu}=(1,\\,0,\\,0,\\,0)$, $s^{\\mu}=(0,\\,1,\\,0,\\,0)$.\n- Case B (Transverse-Traceless (TT) plus-polarized gravitational wave, weak-field snapshot): $h=10^{-3}$, $g^{(B)}_{\\mu\\nu} = \\mathrm{diag}(-1,\\,1+h,\\,1-h,\\,1)$, $u^{\\mu}=(1,\\,0,\\,0,\\,0)$, $s^{\\mu}=(0,\\,1,\\,0,\\,0)$.\n- Case C (Euclidean metric, invalid for relativity): $g^{(C)}_{\\mu\\nu} = \\mathrm{diag}(1,\\,1,\\,1,\\,1)$, $u^{\\mu}=(1,\\,0,\\,0,\\,0)$, $s^{\\mu}=(0,\\,1,\\,0,\\,0)$.\n- Case D (Near-degenerate boundary case): $g^{(D)}_{\\mu\\nu} = \\mathrm{diag}(-10^{-12},\\,1,\\,1,\\,1)$, $u^{\\mu}=(1,\\,0,\\,0,\\,0)$, $s^{\\mu}=(0,\\,1,\\,0,\\,0)$.\n- Case E (TT cross-polarized gravitational wave, weak-field snapshot with off-diagonal spatial terms): $h=0.05$, components $g^{(E)}_{00}=-1$, $g^{(E)}_{11}=1$, $g^{(E)}_{22}=1$, $g^{(E)}_{33}=1$, $g^{(E)}_{12}=g^{(E)}_{21}=h$, all other components zero; $u^{\\mu}=(1,\\,0,\\,0,\\,0)$, $s^{\\mu}=(0,\\,1,\\,1,\\,0)$.\n\nProgram requirements:\n- For each case, compute:\n    1. Whether the full metric has Lorentzian signature $(-,+,+,+)$ with the tolerance $\\epsilon$.\n    2. Whether the spatial $3\\times 3$ block $g_{ij}$ is positive-definite with the tolerance $\\epsilon$.\n    3. Whether the line elements for $u^{\\mu}$ and $s^{\\mu}$ satisfy $g_{\\mu\\nu} u^{\\mu} u^{\\nu} lt; -\\epsilon$ and $g_{\\mu\\nu} s^{\\mu} s^{\\nu} gt; \\epsilon$.\n- Return a boolean per case, which is true if and only if all three checks pass for that case.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[r_1,r_2,r_3,r_4,r_5]$, where each $r_k$ is a boolean corresponding to the case $k \\in \\{A,B,C,D,E\\}$.", "solution": "The problem requires the validation of several given spacetime metrics, $g_{\\mu\\nu}$, against a set of fundamental properties required for physical relevance in numerical relativity and gravitational wave modeling. A metric is deemed valid for a given case if it satisfies three specific criteria simultaneously: having the correct Lorentzian signature, inducing a positive-definite spatial metric, and correctly classifying the causal character of representative test vectors.\n\nThe validation process for each case proceeds by implementing three sequential checks based on the definitions provided. A numerical tolerance of $\\epsilon = 10^{-10}$ is used for all floating-point comparisons.\n\n1.  **Lorentzian Signature Verification**: A $4 \\times 4$ metric tensor $g_{\\mu\\nu}$ has a Lorentzian signature $(-,+,+,+)$ if and only if its eigenvalues consist of exactly one negative value, three positive values, and no zero values. To verify this, we compute the eigenvalues of the matrix representation of $g_{\\mu\\nu}$. Using the specified tolerance $\\epsilon$, an eigenvalue $\\lambda$ is counted as negative if $\\lambda  -\\epsilon$, positive if $\\lambda  \\epsilon$, and zero if $|\\lambda| \\le \\epsilon$. The metric is non-degenerate and Lorentzian if the counts are one negative, three positive, and zero 'zero' eigenvalues.\n\n2.  **Positive-Definite Spatial Metric Verification**: In the $3+1$ decomposition of spacetime, the induced spatial metric, $\\gamma_{ij}$, is the $3 \\times 3$ submatrix of $g_{\\mu\\nu}$ corresponding to the spatial indices $i, j \\in \\{1, 2, 3\\}$ (for coordinates $(x^0, x^1, x^2, x^3)$). For a physically valid spacetime, $\\gamma_{ij}$ must be positive-definite, meaning all its eigenvalues must be strictly positive. We check this by computing the three eigenvalues of $\\gamma_{ij}$ and ensuring each is greater than the tolerance $\\epsilon$.\n\n3.  **Causal Character Verification**: The line element $ds^2 = g_{\\mu\\nu} v^{\\mu} v^{\\nu}$ determines the causal nature of a vector $v^{\\mu}$. For the given test vectors, a time-like vector $u^{\\mu}$ must satisfy $g_{\\mu\\nu} u^{\\mu} u^{\\nu}  -\\epsilon$, and a space-like vector $s^{\\mu}$ must satisfy $g_{\\mu\\nu} s^{\\mu} s^{\\nu}  \\epsilon$. This is calculated using matrix-vector multiplication as $(v)^T g v$.\n\nA case passes the overall validation if and only if all three of these checks are successful. We now apply this procedure to each test case.\n\n**Case A: Minkowski Spacetime**\n-   Metric: $g^{(A)}_{\\mu\\nu} = \\mathrm{diag}(-1, 1, 1, 1)$.\n-   Vectors: $u^{\\mu} = (1, 0, 0, 0)$, $s^{\\mu} = (0, 1, 0, 0)$.\n\n1.  **Signature**: The eigenvalues of the diagonal matrix $g^{(A)}_{\\mu\\nu}$ are its diagonal entries: $\\{-1, 1, 1, 1\\}$. There is one negative eigenvalue and three positive eigenvalues. All are well outside the tolerance region. This check **passes**.\n2.  **Spatial Metric**: The spatial block is $\\gamma^{(A)}_{ij} = \\mathrm{diag}(1, 1, 1)$. Its eigenvalues are $\\{1, 1, 1\\}$, all of which are greater than $\\epsilon$. This check **passes**.\n3.  **Causal Character**:\n    -   For $u^{\\mu}$, $ds^2 = g_{00} (u^0)^2 = (-1)(1)^2 = -1$. Since $-1  -\\epsilon$, this check **passes**.\n    -   For $s^{\\mu}$, $ds^2 = g_{11} (s^1)^2 = (1)(1)^2 = 1$. Since $1  \\epsilon$, this check **passes**.\n\nAll three checks pass. The result for Case A is **True**.\n\n**Case B: TT Plus-Polarized Gravitational Wave**\n-   Metric: $g^{(B)}_{\\mu\\nu} = \\mathrm{diag}(-1, 1+h, 1-h, 1)$, with $h = 10^{-3}$. So, $g^{(B)}_{\\mu\\nu} = \\mathrm{diag}(-1, 1.001, 0.999, 1)$.\n-   Vectors: $u^{\\mu} = (1, 0, 0, 0)$, $s^{\\mu} = (0, 1, 0, 0)$.\n\n1.  **Signature**: The eigenvalues are $\\{-1, 1.001, 0.999, 1\\}$. There is one negative and three positive eigenvalues. This check **passes**.\n2.  **Spatial Metric**: The spatial block is $\\gamma^{(B)}_{ij} = \\mathrm{diag}(1.001, 0.999, 1)$. Its eigenvalues are $\\{1.001, 0.999, 1\\}$, all positive. This check **passes**.\n3.  **Causal Character**:\n    -   For $u^{\\mu}$, $ds^2 = g_{00} (u^0)^2 = -1  -\\epsilon$. This check **passes**.\n    -   For $s^{\\mu}$, $ds^2 = g_{11} (s^1)^2 = (1+h)(1)^2 = 1.001  \\epsilon$. This check **passes**.\n\nAll three checks pass. The result for Case B is **True**.\n\n**Case C: Euclidean Metric**\n-   Metric: $g^{(C)}_{\\mu\\nu} = \\mathrm{diag}(1, 1, 1, 1)$.\n-   Vectors: $u^{\\mu} = (1, 0, 0, 0)$, $s^{\\mu} = (0, 1, 0, 0)$.\n\n1.  **Signature**: The eigenvalues are $\\{1, 1, 1, 1\\}$. There are zero negative eigenvalues and four positive eigenvalues. This violates the $(-,+,+,+)$ signature requirement. This check **fails**.\n\nSince the first check fails, the overall result for the case is determined. The result for Case C is **False**.\n\n**Case D: Near-Degenerate Metric**\n-   Metric: $g^{(D)}_{\\mu\\nu} = \\mathrm{diag}(-10^{-12}, 1, 1, 1)$.\n-   Vectors: $u^{\\mu} = (1, 0, 0, 0)$, $s^{\\mu} = (0, 1, 0, 0)$.\n\n1.  **Signature**: The eigenvalues are $\\{-10^{-12}, 1, 1, 1\\}$. We check the eigenvalue $\\lambda_0 = -10^{-12}$ against the tolerance $\\epsilon = 10^{-10}$. Since $|\\lambda_0| = 10^{-12} \\le 10^{-10}$, this eigenvalue is classified as zero. The counts are zero negative, three positive, and one zero eigenvalue. This violates the non-degenerate Lorentzian signature requirement. This check **fails**.\n\nThe case is invalid. For completeness, we note the causal check for $u^{\\mu}$ also fails: $ds^2 = g_{00}(u^0)^2 = -10^{-12}$. The condition $ds^2  -\\epsilon$ becomes $-10^{-12}  -10^{-10}$, which is false. The result for Case D is **False**.\n\n**Case E: TT Cross-Polarized Gravitational Wave**\n-   Metric: $g^{(E)}_{\\mu\\nu}$ has components $g_{00}=-1$, $g_{11}=g_{22}=g_{33}=1$, $g_{12}=g_{21}=h=0.05$. In matrix form:\n$$g^{(E)}_{\\mu\\nu} = \\begin{pmatrix} -1  0  0  0 \\\\ 0  1  0.05  0 \\\\ 0  0.05  1  0 \\\\ 0  0  0  1 \\end{pmatrix}$$\n-   Vectors: $u^{\\mu} = (1, 0, 0, 0)$, $s^{\\mu} = (0, 1, 1, 0)$.\n\n1.  **Signature**: The matrix is block-diagonal. The eigenvalues are those of the blocks: $\\{-1\\}$, $\\{1\\}$, and the submatrix $\\begin{pmatrix} 1  0.05 \\\\ 0.05  1 \\end{pmatrix}$. The eigenvalues of this $2 \\times 2$ submatrix are $\\lambda = 1 \\pm 0.05$, which are $1.05$ and $0.95$. The full set of eigenvalues for $g^{(E)}_{\\mu\\nu}$ is $\\{-1, 1, 1.05, 0.95\\}$. There is one negative and three positive eigenvalues. This check **passes**.\n2.  **Spatial Metric**: The spatial block is $\\gamma^{(E)}_{ij} = \\begin{pmatrix} 1  0.05  0 \\\\ 0.05  1  0 \\\\ 0  0  1 \\end{pmatrix}$. Its eigenvalues are $\\{1.05, 0.95, 1\\}$, all of which are positive. This check **passes**.\n3.  **Causal Character**:\n    -   For $u^{\\mu}$, $ds^2 = g_{00} (u^0)^2 = -1  -\\epsilon$. This check **passes**.\n    -   For $s^{\\mu}$, $ds^2 = g_{\\mu\\nu} s^{\\mu} s^{\\nu} = g_{11}(s^1)^2 + g_{22}(s^2)^2 + 2g_{12}s^1 s^2 = (1)(1)^2 + (1)(1)^2 + 2(0.05)(1)(1) = 1 + 1 + 0.1 = 2.1$. Since $2.1  \\epsilon$, this check **passes**.\n\nAll three checks pass. The result for Case E is **True**.\n\nFinal Summary of Booleans:\n- Case A: True\n- Case B: True\n- Case C: False\n- Case D: False\n- Case E: True", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates a test suite of spacetime metrics against physical criteria.\n\n    For each case, the program checks:\n    1. If the 4x4 metric has Lorentzian signature (-,+,+,+).\n    2. If the 3x3 spatial sub-metric is positive-definite.\n    3. If representative time-like and space-like vectors are correctly classified.\n\n    A case is valid (True) if and only if all three checks pass.\n    \"\"\"\n    \n    # Define the tolerance for floating-point comparisons as per the problem.\n    epsilon = 1e-10\n\n    # Test Case A: Minkowski spacetime\n    g_A = np.diag([-1.0, 1.0, 1.0, 1.0])\n    u_A = np.array([1.0, 0.0, 0.0, 0.0])\n    s_A = np.array([0.0, 1.0, 0.0, 0.0])\n\n    # Test Case B: Transverse-Traceless (TT) plus-polarized gravitational wave\n    h_B = 1e-3\n    g_B = np.diag([-1.0, 1.0 + h_B, 1.0 - h_B, 1.0])\n    u_B = np.array([1.0, 0.0, 0.0, 0.0])\n    s_B = np.array([0.0, 1.0, 0.0, 0.0])\n\n    # Test Case C: Euclidean metric (invalid for relativity)\n    g_C = np.diag([1.0, 1.0, 1.0, 1.0])\n    u_C = np.array([1.0, 0.0, 0.0, 0.0])\n    s_C = np.array([0.0, 1.0, 0.0, 0.0])\n\n    # Test Case D: Near-degenerate boundary case\n    g_D = np.diag([-1e-12, 1.0, 1.0, 1.0])\n    u_D = np.array([1.0, 0.0, 0.0, 0.0])\n    s_D = np.array([0.0, 1.0, 0.0, 0.0])\n\n    # Test Case E: TT cross-polarized gravitational wave\n    h_E = 0.05\n    g_E = np.array([\n        [-1.0, 0.0, 0.0, 0.0],\n        [0.0, 1.0, h_E, 0.0],\n        [0.0, h_E, 1.0, 0.0],\n        [0.0, 0.0, 0.0, 1.0]\n    ])\n    u_E = np.array([1.0, 0.0, 0.0, 0.0])\n    s_E = np.array([0.0, 1.0, 1.0, 0.0])\n\n    test_cases = [\n        (g_A, u_A, s_A),\n        (g_B, u_B, s_B),\n        (g_C, u_C, s_C),\n        (g_D, u_D, s_D),\n        (g_E, u_E, s_E),\n    ]\n\n    results = []\n    for g, u, s in test_cases:\n        # Check 1: Lorentzian signature\n        # Use np.linalg.eigvalsh as the metrics are real symmetric matrices.\n        eigs_g = np.linalg.eigvalsh(g)\n        \n        neg_count = np.sum(eigs_g  -epsilon)\n        pos_count = np.sum(eigs_g  epsilon)\n        zero_count = np.sum(np.abs(eigs_g) = epsilon)\n        \n        is_lorentzian = (neg_count == 1 and pos_count == 3 and zero_count == 0)\n\n        # Check 2: Positive-definite spatial metric\n        gamma = g[1:, 1:]\n        eigs_gamma = np.linalg.eigvalsh(gamma)\n        \n        is_spatial_pos_def = np.all(eigs_gamma  epsilon)\n\n        # Check 3: Causal classification\n        # Calculate line elements using matrix multiplication: v.T @ g @ v\n        ds2_u = u @ g @ u\n        ds2_s = s @ g @ s\n        \n        is_causal_correct = (ds2_u  -epsilon and ds2_s  epsilon)\n        \n        # A case is valid if and only if all three checks pass.\n        case_result = is_lorentzian and is_spatial_pos_def and is_causal_correct\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results)).lower()}]\")\n\nsolve()\n```", "id": "3493424"}, {"introduction": "The metric tensor does more than just define distances; it dictates the dynamics of matter and light through the principle of extremal proper time, encapsulated in the action $S = \\int ds$. This advanced practice explores how to leverage this principle directly by building a variational integrator, a sophisticated numerical method that discretizes the action itself. By implementing this for geodesics in the strong-field environment of a Schwarzschild black hole, you will see how this geometric approach leads to superior long-term accuracy and the preservation of conserved quantities, a key advantage in computational astrophysics. [@problem_id:3493419]", "problem": "Implement a self-consistent discrete variational integrator for timelike geodesics that preserves the metric first integrals arising from cyclic coordinates by discretizing the action $$S=\\int \\sqrt{-g_{\\mu\\nu}(x)\\,\\frac{dx^\\mu}{d\\lambda}\\,\\frac{dx^\\nu}{d\\lambda}}\\,d\\lambda$$ in a strong-field spacetime, and test the long-term phase accuracy. Use the following specifications.\n\nFundamental base and scenario:\n- In General Relativity (GR), the metric tensor $$g_{\\mu\\nu}$$ determines the line element $$ds^2=g_{\\mu\\nu}\\,dx^\\mu\\,dx^\\nu$$. Timelike geodesics extremize the proper-time action $$S=\\int \\sqrt{-g_{\\mu\\nu}(x)\\,\\dot x^\\mu\\,\\dot x^\\nu}\\,d\\lambda$$, where $$\\dot x^\\mu=d x^\\mu/d\\lambda$$ and $$\\lambda$$ is a parameter along the worldline. In coordinates $$(t,r,\\phi)$$ restricted to the equatorial plane $$\\theta=\\pi/2$$ of the Schwarzschild spacetime with mass $$M$$, the line element is $$ds^2=-(1-\\frac{2M}{r})\\,dt^2+(1-\\frac{2M}{r})^{-1}\\,dr^2+r^2\\,d\\phi^2$$.\n- Work in geometrized units where $$G=c=1$$. All angles must be in radians. Frequencies must be expressed in radians per unit coordinate time $$t$$.\n\nDiscrete variational integrator requirements:\n- Construct a discrete Lagrangian by applying midpoint quadrature to the action over one step from $$x_k$$ to $$x_{k+1}$$, and enforce the discrete Euler–Lagrange equations $$D_2 L_d(x_{k-1},x_k)+D_1 L_d(x_k,x_{k+1})=0$$ to advance the trajectory. Here $$L_d$$ is the discrete Lagrangian, and $$D_1$$, $$D_2$$ denote partial derivatives with respect to the first and second argument respectively. Treat $$t$$ and $$\\phi$$ as cyclic coordinates and verify the near-constancy of their associated discrete momenta along the trajectory.\n- Implement an implicit step solve for $$x_{k+1}$$ using a Newton method with a finite-difference Jacobian and a simple backtracking line search to enforce timelike steps (positive discrete proper length) and avoid leaving the domain $$r2M$$.\n\nInitialization and diagnostics:\n- Initialize a nearly circular equatorial timelike geodesic at radius $$r_0$$ using the known exact constants of motion for circular orbits to construct the initial 4-velocity $$(\\dot t,\\dot r,\\dot\\phi)$$ at $$r_0$$, with $$\\dot r=0$$. Use a small proper-time step $$h$$ to define the first discrete increment $$x_1-x_0=h\\,\\dot x^\\mu$$.\n- Throughout the integration, compute the discrete momenta associated with $$t$$ and $$\\phi$$ at each step from the discrete variational principle and report their fractional drifts over the full run. Also compute the average angular frequency $$\\Omega_{\\text{num}}=\\Delta\\phi/\\Delta t$$ over the entire simulation and compare against the exact circular-orbit frequency $$\\Omega_{\\text{exact}}=\\sqrt{M/r_0^3}$$; report the absolute frequency error $$|\\Omega_{\\text{num}}-\\Omega_{\\text{exact}}|$$. All angles must be in radians and frequencies in radians per unit coordinate time.\n\nTest suite:\n- Use the Schwarzschild equatorial metric as above. Provide results for the following parameter sets $$(M,r_0,h,N)$$, where $$N$$ is the total number of steps:\n  1. $$M=1.0$$, $$r_0=7.0$$, $$h=5\\times 10^{-3}$$, $$N=1500$$.\n  2. $$M=1.0$$, $$r_0=6.1$$, $$h=4\\times 10^{-3}$$, $$N=1800$$.\n  3. $$M=1.0$$, $$r_0=4.0$$, $$h=3\\times 10^{-3}$$, $$N=1200$$.\n- For each test case, run the integrator and compute three diagnostics:\n  - The fractional drift of the discrete momentum associated with $$t$$ over the run, defined as $$\\delta_t=\\frac{\\max_k |p^{(t)}_k|-\\min_k |p^{(t)}_k|}{\\frac{1}{K}\\sum_k |p^{(t)}_k|}$$.\n  - The fractional drift of the discrete momentum associated with $$\\phi$$, $$\\delta_\\phi=\\frac{\\max_k |p^{(\\phi)}_k|-\\min_k |p^{(\\phi)}_k|}{\\frac{1}{K}\\sum_k |p^{(\\phi)}_k|}$$.\n  - The absolute frequency error $$\\epsilon_\\Omega=|\\Omega_{\\text{num}}-\\Omega_{\\text{exact}}|$$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for the three test cases as a comma-separated list enclosed in square brackets, where each test case yields a list of three floats $$[\\delta_t,\\delta_\\phi,\\epsilon_\\Omega]$$ in that order. For example, the output must be of the form $$[[\\delta_t^{(1)},\\delta_\\phi^{(1)},\\epsilon_\\Omega^{(1)}],[\\delta_t^{(2)},\\delta_\\phi^{(2)},\\epsilon_\\Omega^{(2)}],[\\delta_t^{(3)},\\delta_\\phi^{(3)},\\epsilon_\\Omega^{(3)}]]$$ on a single line.", "solution": "The user requests the implementation of a discrete variational integrator for timelike geodesics in the Schwarzschild spacetime. The problem is rigorously defined, scientifically sound, and well-posed, providing a specific metric, discretization scheme, initialization procedure, and set of diagnostics. I will therefore proceed with a complete solution.\n\nThe core of the problem is to construct a numerical integrator that respects the geometric structure of the underlying physical system. Variational integrators achieve this by discretizing Hamilton's principle of stationary action, rather than the equations of motion directly. This approach leads to excellent long-term stability and preservation of conserved quantities associated with symmetries (Noether's theorem).\n\n**1. Continuous Formulation**\n\nThe motion of a massive particle in spacetime is described by a timelike geodesic, which extremizes the proper time $$\\int ds$$. The action is given as $$S = \\int L d\\lambda$$, where $$L$$ is the Lagrangian and $$\\lambda$$ is an affine parameter along the worldline.\n$$L(x^\\mu, \\dot{x}^\\mu) = \\sqrt{-g_{\\mu\\nu}(x)\\dot{x}^\\mu\\dot{x}^\\nu}$$\nHere, $$\\dot{x}^\\mu = dx^\\mu/d\\lambda$$. We consider the equatorial plane ($$\\theta=\\pi/2$$) of the Schwarzschild spacetime, with coordinates $$x^\\mu = (t, r, \\phi)$$. The line element $$ds^2 = g_{\\mu\\nu}dx^\\mu dx^\\nu$$ is:\n$$ds^2 = -(1-\\frac{2M}{r})dt^2 + (1-\\frac{2M}{r})^{-1}dr^2 + r^2d\\phi^2$$\nThe non-zero metric components are:\n$$\ng_{tt} = -(1-\\frac{2M}{r}), \\quad g_{rr} = (1-\\frac{2M}{r})^{-1}, \\quad g_{\\phi\\phi} = r^2\n$$\nThe Lagrangian for a particle is:\n$$\nL = \\sqrt{(1-\\frac{2M}{r})\\dot{t}^2 - (1-\\frac{2M}{r})^{-1}\\dot{r}^2 - r^2\\dot{\\phi}^2}\n$$\nThe coordinates $$t$$ and $$\\phi$$ are cyclic because the metric components do not depend on them. By Noether's theorem, this implies the conservation of their conjugate momenta:\n- $$p_t = \\frac{\\partial L}{\\partial \\dot{t}} = \\frac{g_{tt}\\dot{t}}{L} = \\frac{-(1-\\frac{2M}{r})\\dot{t}}{L}$$. The specific energy is $$E = -p_t$$.\n- $$p_\\phi = \\frac{\\partial L}{\\partial \\dot{\\phi}} = \\frac{g_{\\phi\\phi}\\dot{\\phi}}{L} = \\frac{r^2\\dot{\\phi}}{L}$$. The specific angular momentum is $$L_z = p_\\phi$$.\n\nIf we choose the parameter $$\\lambda$$ to be the proper time $$\\tau$$, then $$L=1$$ along the geodesic, simplifying the expressions for the momenta.\n\n**2. Discrete Variational Principle**\n\nWe discretize the action using a sum over short segments of the worldline, from $$x_k$$ to $$x_{k+1}$$. The discrete action is $$S_d = \\sum_k L_d(x_k, x_{k+1})$$. We construct the discrete Lagrangian $$L_d$$ by applying the midpoint rule to the continuous Lagrangian integral over one step. This amounts to evaluating the metric at the midpoint $$\\bar{x} = (x_k + x_{k+1})/2$$ and approximating the velocity as $$\\bar{\\dot{x}} = (x_{k+1} - x_k)/h$$, where $$h$$ is the step size (which we can identify with the parameter step $$\\Delta\\lambda$$).\n$$\nL_d(x_k, x_{k+1}) = \\sqrt{-g_{\\mu\\nu}(\\bar{x})(x^\\mu_{k+1}-x^\\mu_k)(x^\\nu_{k+1}-x^\\nu_k)}\n$$\nLetting $$\\Delta x^\\mu = x^\\mu_{k+1}-x^\\mu_k$$ and $$\\bar{r} = (r_k+r_{k+1})/2$$, this becomes:\n$$\nL_d(x_k, x_{k+1}) = \\sqrt{-( g_{tt}(\\bar{r})\\Delta t^2 + g_{rr}(\\bar{r})\\Delta r^2 + g_{\\phi\\phi}(\\bar{r})\\Delta\\phi^2 )}\n$$\nThe discrete equations of motion are found by extremizing $$S_d$$ with respect to an interior point $$x_k$$, leading to the discrete Euler-Lagrange (DEL) equations:\n$$\nD_2 L_d(x_{k-1}, x_k) + D_1 L_d(x_k, x_{k+1}) = 0\n$$\nwhere $$D_1$$ and $$D_2$$ denote partial derivatives with respect to the first ($$x_k$$) and second ($$x_{k+1}$$) arguments of $$L_d$$, respectively.\n\nFor a cyclic coordinate $$q^c$$ ($$t$$ or $$\\phi$$), the metric—and thus $$L_d$$—depends only on the difference $$\\Delta q^c = q^c_{k+1} - q^c_k$$. This leads to a discrete version of Noether's theorem. The DEL equation for $$q^c$$ becomes:\n$$\n\\frac{\\partial L_d(x_{k-1}, x_k)}{\\partial q^c_k} + \\frac{\\partial L_d(x_k, x_{k+1})}{\\partial q^c_k} = 0\n$$\n$$\n\\frac{\\partial L_d}{\\partial(\\Delta q^c)}\\bigg|_{k-1, k} - \\frac{\\partial L_d}{\\partial(\\Delta q^c)}\\bigg|_{k, k+1} = 0\n$$\nThis shows that the discrete momentum $$P_c = \\frac{\\partial L_d}{\\partial(\\Delta q^c)}$$ is conserved along the numerical trajectory. The quantities we will monitor are:\n- $$P_t \\equiv \\frac{\\partial L_d}{\\partial(\\Delta t)} = \\frac{-g_{tt}(\\bar{r})\\Delta t}{L_d} = \\frac{(1-2M/\\bar{r})\\Delta t}{L_d}$$\n- $$P_\\phi \\equiv \\frac{\\partial L_d}{\\partial(\\Delta \\phi)} = \\frac{-g_{\\phi\\phi}(\\bar{r})\\Delta \\phi}{L_d} = \\frac{-\\bar{r}^2 \\Delta\\phi}{L_d}$$\n\n**3. The Implicit Update Rule**\n\nThe DEL equations form a system of three coupled, nonlinear algebraic equations for the three unknown coordinates of $$x_{k+1} = (t_{k+1}, r_{k+1}, \\phi_{k+1})$$, given $$x_k$$ and $$x_{k-1}$$. Let $$y = x_{k+1}$$. The system $$\\mathbf{F}(y)=0$$ is:\n$$\n\\begin{cases}\nP_t(x_k, y) - P_t(x_{k-1}, x_k) = 0 \\\\\nP_\\phi(x_k, y) - P_r(x_{k-1}, x_k) = 0 \\\\\nD_2 L_d(x_{k-1}, x_k)_r + D_1 L_d(x_k, y)_r = 0\n\\end{cases}\n$$\nThe first two equations enforce the conservation of discrete momenta. The third equation, governing the radial dynamics, is more complex. We solve this system for $$y$$ using Newton's method. Starting from an initial guess $$y^{(0)}$$ (e.g., from linear extrapolation: $$y^{(0)} = 2x_k - x_{k-1}$$), we iterate:\n$$\ny^{(i+1)} = y^{(i)} - \\alpha J^{-1}(y^{(i)}) \\mathbf{F}(y^{(i)})\n$$\nThe Jacobian matrix $$J_{ij} = \\partial F_i/\\partial y_j$$ is computed using finite differences. The step size $$\\alpha$$ is determined by a backtracking line search, starting with $$\\alpha=1$$ and reducing it to ensure that each trial step satisfies physical constraints ($$r_{k+1}2M$$, timelike step $$L_d^20$$) and reduces the norm of the residual vector $$\\mathbf{F}$$.\n\n**4. Initialization**\n\nThe simulation is initialized for a nearly circular orbit. For an exact circular orbit at radius $$r_0$$, the initial 4-velocity components (parameterized by proper time $$\\tau$$) are derived by demanding $$\\dot{r}=0$$ and $$\\ddot{r}=0$$. This yields expressions for the conserved specific energy $$E$$ and angular momentum $$L_z$$:\n$$\nE = \\frac{r_0-2M}{\\sqrt{r_0(r_0-3M)}}, \\quad L_z = \\sqrt{\\frac{M r_0^2}{r_0-3M}}\n$$\nFrom these, we find the 4-velocity components:\n$$\n\\dot{t}_0 = \\frac{E}{1-2M/r_0}, \\quad \\dot{r}_0 = 0, \\quad \\dot{\\phi}_0 = \\frac{L_z}{r_0^2}\n$$\nThe first two points of the trajectory are set as $$x_0 = (0, r_0, 0)$$ and $$x_1 = x_0 + h(\\dot{t}_0, \\dot{r}_0, \\dot{\\phi}_0)$$, where $$h$$ is the specified proper-time step size. This provides the necessary history ($$x_{k-1}, x_k$$) to begin the integration loop for $$x_2$$.\n\n**5. Diagnostics**\n\nAfter integrating for $$N$$ steps, we compute the specified diagnostics:\n- **Fractional Momentum Drifts ($$\\delta_t, \\delta_\\phi$$):** For each step $$k=0, \\dots, N-2$$, we calculate the discrete momenta $$P_t(x_k, x_{k+1})$$ and $$P_\\phi(x_k, x_{k+1})$$. We then compute their fractional drift: $$\\frac{\\max|P| - \\min|P|}{\\text{mean}|P|}$$.\n- **Frequency Error ($$\\epsilon_\\Omega$$):** The numerical average angular frequency is $$\\Omega_{\\text{num}} = ( \\phi_N - \\phi_0 ) / ( t_N - t_0 )$$. This is compared to the exact Keplerian frequency for a circular orbit in Schwarzschild spacetime, $$\\Omega_{\\text{exact}} = \\sqrt{M/r_0^3}$$. The absolute error is then computed.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_variational_integrator(M, r0, h, N):\n    \"\"\"\n    Implements a self-consistent discrete variational integrator for timelike geodesics\n    in the Schwarzschild spacetime.\n    \n    Args:\n        M (float): Mass of the central object.\n        r0 (float): Initial radius of the nearly circular orbit.\n        h (float): Proper-time step size for initialization.\n        N (int): Total number of integration steps.\n        \n    Returns:\n        tuple: A tuple containing the three diagnostics (delta_t, delta_phi, eps_Omega).\n    \"\"\"\n\n    # --- Metric and its derivatives ---\n    def g_tt(r, M):\n        return -(1.0 - 2.0 * M / r)\n\n    def g_rr(r, M):\n        return 1.0 / (1.0 - 2.0 * M / r)\n\n    def g_phiphi(r, M):\n        return r**2\n\n    def dg_tt_dr(r, M):\n        return -2.0 * M / r**2\n\n    def dg_rr_dr(r, M):\n        val = 1.0 - 2.0 * M / r\n        return -1.0 / (val**2) * (2.0 * M / r**2)\n\n    def dg_phiphi_dr(r, M):\n        return 2.0 * r\n\n\n    # --- Discrete Lagrangian and related functions ---\n    def discrete_lagrangian_sq(x_k, x_kp1, M):\n        dt = x_kp1[0] - x_k[0]\n        dr = x_kp1[1] - x_k[1]\n        dphi = x_kp1[2] - x_k[2]\n        r_mid = 0.5 * (x_k[1] + x_kp1[1])\n\n        if r_mid = 2.0 * M:\n            return -1.0\n        \n        return -g_tt(r_mid, M) * dt**2 - g_rr(r_mid, M) * dr**2 - g_phiphi(r_mid, M) * dphi**2\n\n    def discrete_lagrangian(x_k, x_kp1, M):\n        val_sq = discrete_lagrangian_sq(x_k, x_kp1, M)\n        return np.sqrt(val_sq) if val_sq  0 else -1.0\n\n    def get_conserved_quantities(x_k, x_kp1, M):\n        dt = x_kp1[0] - x_k[0]\n        dphi = x_kp1[2] - x_k[2]\n        r_mid = 0.5 * (x_k[1] + x_kp1[1])\n        \n        ld = discrete_lagrangian(x_k, x_kp1, M)\n        if ld = 0:\n            return np.nan, np.nan\n\n        p_t = -g_tt(r_mid, M) * dt / ld\n        p_phi = -g_phiphi(r_mid, M) * dphi / ld\n        return p_t, p_phi\n\n    def get_DEL_r_component(x_prev, x_curr, x_next, M):\n        # Contribution from D2 L_d(x_{k-1}, x_k)\n        ld_prev = discrete_lagrangian(x_prev, x_curr, M)\n        if ld_prev = 0: return np.inf\n        r_mid_prev = 0.5 * (x_prev[1] + x_curr[1])\n        dt_prev, dr_prev, dphi_prev = x_curr - x_prev\n        df_dr_mid_prev = -dg_tt_dr(r_mid_prev, M) * dt_prev**2 - dg_rr_dr(r_mid_prev, M) * dr_prev**2 - dg_phiphi_dr(r_mid_prev, M) * dphi_prev**2\n        df_ddr_prev = -2.0 * g_rr(r_mid_prev, M) * dr_prev\n        dld_drk_prev = (0.5 * df_dr_mid_prev + df_ddr_prev) / (2.0 * ld_prev)\n        \n        # Contribution from D1 L_d(x_k, x_{k+1})\n        ld_next = discrete_lagrangian(x_curr, x_next, M)\n        if ld_next = 0: return np.inf\n        r_mid_next = 0.5 * (x_curr[1] + x_next[1])\n        dt_next, dr_next, dphi_next = x_next - x_curr\n        df_dr_mid_next = -dg_tt_dr(r_mid_next, M) * dt_next**2 - dg_rr_dr(r_mid_next, M) * dr_next**2 - dg_phiphi_dr(r_mid_next, M) * dphi_next**2\n        df_ddr_next = -2.0 * g_rr(r_mid_next, M) * dr_next\n        dld_drk_next = (0.5 * df_dr_mid_next - df_ddr_next) / (2.0 * ld_next)\n\n        return dld_drk_prev + dld_drk_next\n\n    # --- Newton Solver for implicit step ---\n    def newton_solver(x_prev, x_curr, M):\n        p_t_target, p_phi_target = get_conserved_quantities(x_prev, x_curr, M)\n\n        def F(x_next, F_args):\n            x_p, x_c, m, pt_tgt, pphi_tgt = F_args\n            pt_next, pphi_next = get_conserved_quantities(x_c, x_next, m)\n            if np.isnan(pt_next): return np.array([np.inf, np.inf, np.inf])\n            Fr = get_DEL_r_component(x_p, x_c, x_next, m)\n            return np.array([pt_next - pt_tgt, Fr, pphi_next - pphi_tgt])\n\n        F_args = (x_prev, x_curr, M, p_t_target, p_phi_target)\n        x_next_guess = x_curr + (x_curr - x_prev)\n        \n        max_iter, tol, fd_eps = 15, 1e-12, 1e-8\n        for _ in range(max_iter):\n            f_val = F(x_next_guess, F_args)\n            if np.linalg.norm(f_val)  tol: break\n\n            J = np.zeros((3, 3))\n            for j in range(3):\n                d_x = np.zeros(3); d_x[j] = fd_eps\n                f_perturbed = F(x_next_guess + d_x, F_args)\n                J[:, j] = (f_perturbed - f_val) / fd_eps\n\n            try:\n                delta_x = np.linalg.solve(J, -f_val)\n            except np.linalg.LinAlgError: return None\n\n            alpha = 1.0\n            for _ in range(10):\n                x_next_trial = x_next_guess + alpha * delta_x\n                is_valid = x_next_trial[1]  2.0 * M and discrete_lagrangian_sq(x_curr, x_next_trial, M)  0\n                if is_valid:\n                    f_trial_norm = np.linalg.norm(F(x_next_trial, F_args))\n                    if f_trial_norm  np.linalg.norm(f_val):\n                        x_next_guess = x_next_trial\n                        break\n                alpha /= 2.0\n            else: return None\n        else: return None\n        return x_next_guess\n\n    # --- Initialization ---\n    if r0 = 3.0 * M: raise ValueError(\"r0 must be  3M for circular orbits.\")\n    \n    E = (r0 - 2.0 * M) / np.sqrt(r0 * (r0 - 3.0 * M))\n    Lz = np.sqrt(M * r0**2 / (r0 - 3.0 * M))\n\n    dt_dtau = E / (1.0 - 2.0 * M / r0)\n    dphi_dtau = Lz / r0**2\n    \n    x0 = np.array([0.0, r0, 0.0])\n    x1 = np.array([h * dt_dtau, r0, h * dphi_dtau])\n    \n    x_traj = [x0, x1]\n    \n    # --- Integration Loop ---\n    for k in range(1, N):\n        x_next = newton_solver(x_traj[k-1], x_traj[k], M)\n        if x_next is None:\n            # If solver fails, pad trajectory and halt. Diagnostics will be poor.\n            for _ in range(k, N): x_traj.append(x_traj[-1])\n            break\n        x_traj.append(x_next)\n\n    # --- Diagnostics ---\n    p_t_vals, p_phi_vals = [], []\n    for k in range(N):\n        pt, pphi = get_conserved_quantities(x_traj[k], x_traj[k+1], M)\n        if not (np.isnan(pt) or np.isnan(pphi)):\n            p_t_vals.append(abs(pt))\n            p_phi_vals.append(abs(pphi))\n\n    p_t_vals, p_phi_vals = np.array(p_t_vals), np.array(p_phi_vals)\n\n    delta_t = (np.max(p_t_vals) - np.min(p_t_vals)) / np.mean(p_t_vals) if len(p_t_vals)  0 else 0\n    delta_phi = (np.max(p_phi_vals) - np.min(p_phi_vals)) / np.mean(p_phi_vals) if len(p_phi_vals)  0 else 0\n    \n    t_total = x_traj[N][0] - x_traj[0][0]\n    phi_total = x_traj[N][2] - x_traj[0][2]\n    \n    Omega_num = phi_total / t_total if t_total != 0 else 0\n    Omega_exact = np.sqrt(M / r0**3)\n    eps_Omega = abs(Omega_num - Omega_exact)\n    \n    return [delta_t, delta_phi, eps_Omega]\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (1.0, 7.0, 5e-3, 1500), # M, r0, h, N\n        (1.0, 6.1, 4e-3, 1800),\n        (1.0, 4.0, 3e-3, 1200),\n    ]\n\n    results = []\n    for case in test_cases:\n        M, r0, h, N = case\n        diag = run_variational_integrator(M, r0, h, N)\n        results.append(diag)\n    \n    # Custom formatting to match the required output style precisely.\n    result_str = \"[\"\n    for i, res in enumerate(results):\n        result_str += f\"[{','.join(f'{x:.10e}' for x in res)}]\"\n        if i  len(results) - 1:\n            result_str += \",\"\n    result_str += \"]\"\n        \n    print(result_str)\n\nsolve()\n```", "id": "3493419"}]}