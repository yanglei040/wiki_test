{"hands_on_practices": [{"introduction": "Gravitational waves are not just ripples in spacetime; they are carriers of energy and momentum. This energy itself acts as a source of gravity, leading to a permanent, non-oscillatory change in the spacetime metric known as the nonlinear or Christodoulou memory effect. This first exercise allows you to compute this effect directly by modeling a burst of gravitational waves and numerically integrating its energy flux, providing a tangible link between the wave's properties and the resulting spacetime distortion. [@problem_id:2399205]", "problem": "You are asked to write a complete, runnable program that models the gravitational-wave memory effect from a compact-binary-like burst, by numerically integrating the energy flux of a prescribed gravitational wave signal to determine the permanent displacement of test masses. Begin from fundamental and well-tested bases: the Isaacson effective stress-energy tensor for far-zone gravitational waves in General Relativity (GR) and the geodesic deviation response of a free arm to a quasi-static change in plus-polarized strain. Do not assume any specialized formula for the memory a priori; derive what you need from these bases.\n\nAssumptions and fundamental bases:\n- Work in the far-field, plane-wave, transverse-traceless approximation. Let $h_+(t)$ and $h_\\times(t)$ denote the two metric polarization strains measured at the detector location along a normal-incidence beam.\n- Use the Isaacson energy flux (power per unit area) carried by the wave,\n$$\nF(t) \\;=\\; \\frac{c^3}{16\\pi G}\\Big(\\dot{h}_+^2(t)+\\dot{h}_\\times^2(t)\\Big),\n$$\nwhere $G$ is Newton’s gravitational constant and $c$ is the speed of light, and $\\dot{h}$ denotes the time derivative of $h$.\n- For a detector arm aligned with the plus polarization basis, a quasi-static net change $\\Delta h_+$ in the plus strain produces a permanent displacement $\\Delta L$ given by\n$$\n\\frac{\\Delta L}{L} \\;=\\; \\frac{1}{2}\\,\\Delta h_+,\n$$\nwhere $L$ is the arm length. Take the detector plane to be orthogonal to the propagation direction and the arm exactly aligned with the plus polarization.\n\nDerive, from the above bases and the $1/R$ amplitude scaling in the far zone together with energy conservation at null infinity, the simplest line-of-sight, plane-wave relation that connects the time-integral of the measured flux to the nonlinear (Christodoulou) memory in the plus polarization along the line of sight. Use that relation to compute the permanent displacement $\\Delta L$.\n\nSignal model and numerical specifications:\n- Use a uniform time grid $t \\in [-0.5,\\,0.5]$ seconds with step $\\Delta t = 10^{-4}$ seconds.\n- For a given case, define\n$$\nh_+(t) \\;=\\; A\\,\\exp\\!\\Big(-\\frac{t^2}{2\\sigma^2}\\Big)\\cos\\!\\big(2\\pi f_0 t\\big),\\qquad\nh_\\times(t) \\;=\\; \\epsilon\\,A\\,\\exp\\!\\Big(-\\frac{t^2}{2\\sigma^2}\\Big)\\sin\\!\\big(2\\pi f_0 t\\big),\n$$\nwhere $A$ is a strain amplitude (dimensionless), $\\sigma$ is the Gaussian width in seconds, $f_0$ is a carrier frequency in hertz, and $\\epsilon \\in \\{0,1\\}$ toggles the presence of cross polarization.\n- Compute $\\dot{h}_+$ and $\\dot{h}_\\times$ with respect to time $t$ in seconds. You may do this analytically from the formulae above or numerically with a stable finite-difference scheme.\n- Numerically integrate any time integrals using the trapezoidal rule.\n- Use the following constants in International System of Units (SI): $G = 6.67430\\times 10^{-11}\\,\\mathrm{m^3\\,kg^{-1}\\,s^{-2}}$, $c = 2.99792458\\times 10^8\\,\\mathrm{m\\,s^{-1}}$, $1\\,\\mathrm{pc} = 3.085677581491367\\times 10^{16}\\,\\mathrm{m}$.\n\nOutput quantity and units:\n- For each test case, output the final permanent displacement $\\Delta L$ in meters, as a floating-point number.\n\nTest suite:\nFor all cases, use arm length $L = 4000$ meters and distance $R = 100$ megaparsecs, where $1\\,\\mathrm{Mpc} = 10^6\\,\\mathrm{pc}$. The four cases are:\n1. Case A (circularly polarized burst): $A = 1.0\\times 10^{-21}$, $f_0 = 150$, $\\sigma = 0.05$, $\\epsilon = 1$, $R = 100$.\n2. Case B (no signal): $A = 0.0$, $f_0 = 150$, $\\sigma = 0.05$, $\\epsilon = 1$, $R = 100$.\n3. Case C (plus-only burst): $A = 1.0\\times 10^{-21}$, $f_0 = 150$, $\\sigma = 0.05$, $\\epsilon = 0$, $R = 100$.\n4. Case D (stronger circular burst): $A = 2.0\\times 10^{-21}$, $f_0 = 150$, $\\sigma = 0.05$, $\\epsilon = 1$, $R = 100$.\n\nAll physical inputs are in SI units except distances quoted in megaparsecs, which you must convert to meters using the parsec definition above.\n\nFinal output format:\nYour program should produce a single line of output containing the four results as a comma-separated list enclosed in square brackets (for example, like $[x_1,x_2,x_3,x_4]$). Each $x_i$ must be a floating-point number giving $\\Delta L$ in meters.", "solution": "The problem posed is a valid exercise in computational physics, grounded in the principles of General Relativity. It requires the numerical calculation of the nonlinear gravitational-wave memory effect for a simplified burst signal. We will first establish the theoretical basis and the specific formula to be implemented, then proceed with the numerical solution as specified.\n\nThe problem asks for a derivation of the relationship between the measured gravitational wave energy flux and the permanent change in strain, $\\Delta h_+$, known as the Christodoulou memory. This effect arises from the fact that gravitational waves carry energy and momentum, and thus gravitate themselves. The stress-energy of the wave, as described by the Isaacson tensor, acts as a source in the Einstein field equations, generating a second-order, non-oscillatory component of the metric perturbation which persists after the wave has passed.\n\nThe Isaacson energy flux (power per unit area) is given by:\n$$\nF(t) = \\frac{c^3}{16\\pi G}\\left(\\dot{h}_+^2(t)+\\dot{h}_\\times^2(t)\\right)\n$$\nThe nonlinear memory is sourced by the time-integrated flux of gravitational-wave energy. A simplified, line-of-sight relationship connecting the memory to the radiated flux can be derived. The memory effect is a change in the metric, $\\Delta h$, which is related to the time integral of the source's effective stress-energy tensor. For gravitational waves, this source is proportional to the flux, $F(t)$. A derivation from the second-order field equations gives a relationship of the form:\n$$\n\\Delta h_+ \\propto \\frac{G R}{c^4} \\int_{-\\infty}^{\\infty} F(t) dt\n$$\nwhere $R$ is the distance to the source, and the factor of $R$ is present to account for the $1/R^2$ fall-off of the flux $F(t)$ as calculated from the measured strain $h \\propto 1/R$. Substituting the expression for $F(t)$ yields the formula to be implemented:\n$$\n\\Delta h_+ = \\frac{R}{8\\pi c} \\int_{-\\infty}^{\\infty} \\left( \\dot{h}_+^2(t) + \\dot{h}_\\times^2(t) \\right) dt\n$$\nThis formula is dimensionally correct. The strain $h$ is dimensionless, so $\\dot{h}$ has units of $s^{-1}$. The integral has units of $s^{-1}$. The prefactor $R/c$ has units of $s$, rendering $\\Delta h_+$ dimensionless. The physical scaling is also correct: for a source at distance $R$, the strain amplitude $h \\propto 1/R$, so $\\dot{h}^2 \\propto 1/R^2$. The integral term thus scales as $1/R^2$, and the overall $\\Delta h_+ \\propto (R) \\cdot (1/R^2) = 1/R$, as expected for a metric perturbation from a distant source.\n\nHaving established the key formula, we proceed to the numerical implementation.\nThe signal components are:\n$$\nh_+(t) = A\\,\\exp\\left(-\\frac{t^2}{2\\sigma^2}\\right)\\cos\\left(\\omega_0 t\\right)\n$$\n$$\nh_\\times(t) = \\epsilon\\,A\\,\\exp\\left(-\\frac{t^2}{2\\sigma^2}\\right)\\sin\\left(\\omega_0 t\\right)\n$$\nwhere $\\omega_0 = 2\\pi f_0$. Let the envelope be $E(t) = A\\,\\exp(-t^2/(2\\sigma^2))$.\nTheir time derivatives are calculated analytically using the product rule:\n$$\n\\dot{h}_+(t) = \\dot{E}(t)\\cos(\\omega_0 t) - \\omega_0 E(t)\\sin(\\omega_0 t)\n$$\n$$\n\\dot{h}_\\times(t) = \\epsilon \\left( \\dot{E}(t)\\sin(\\omega_0 t) + \\omega_0 E(t)\\cos(\\omega_0 t) \\right)\n$$\nwhere $\\dot{E}(t) = - \\frac{t}{\\sigma^2} E(t)$.\n\nThe algorithm is as follows:\n1.  Define the physical constants $G$, $c$, and the conversion factor for parsecs to meters.\n2.  Set up the time grid $t$ from $-0.5\\,s$ to $0.5\\,s$ with step $\\Delta t = 10^{-4}\\,s$.\n3.  For each test case with parameters $(A, f_0, \\sigma, \\epsilon, R, L)$:\n    a. Convert the distance $R$ from megaparsecs to meters.\n    b. Define the envelope function $E(t)$ and its derivative $\\dot{E}(t)$ on the time grid.\n    c. Calculate the arrays for $\\dot{h}_+(t)$ and $\\dot{h}_\\times(t)$ using the analytical formulae above.\n    d. Compute the integrand $I(t) = \\dot{h}_+^2(t) + \\dot{h}_\\times^2(t)$.\n    e. Numerically integrate $I(t)$ over the time grid using the trapezoidal rule to find $\\int I(t) dt$.\n    f. Calculate the permanent strain change $\\Delta h_+ = \\frac{R}{8\\pi c} \\int I(t) dt$.\n    g. Finally, compute the permanent displacement of the detector arm: $\\Delta L = \\frac{1}{2} L \\Delta h_+$.\n4.  Collect the results for all test cases and present them in the specified format.\n\nUnlike spin memory, which is sensitive to the difference in power between polarizations, the Christodoulou memory is sourced by the total energy flux. Therefore, we expect a non-zero memory effect for all cases with non-zero amplitude $A$, including the circularly polarized cases (A and D). For Case B, the amplitude $A=0$, so the result is trivially zero.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the gravitational-wave memory effect for several test cases.\n    \"\"\"\n\n    # Physical Constants in SI units\n    c = 2.99792458e8   # m s^-1\n    PC_TO_M = 3.085677581491367e16  # meters per parsec\n\n    # Shared parameters for all test cases\n    L_arm = 4000.0  # meters\n    R_dist_mpc = 100.0  # megaparsecs\n    R_dist_m = R_dist_mpc * 1e6 * PC_TO_M\n\n    # Numerical grid specifications\n    t_start = -0.5  # seconds\n    t_end = 0.5    # seconds\n    dt = 1e-4      # seconds\n    t = np.arange(t_start, t_end + dt, dt)\n\n    # Test suite: (A, f0, sigma, epsilon)\n    test_cases = [\n        # Case A: Circularly polarized burst\n        (1.0e-21, 150.0, 0.05, 1.0),\n        # Case B: No signal\n        (0.0, 150.0, 0.05, 1.0),\n        # Case C: Plus-only burst\n        (1.0e-21, 150.0, 0.05, 0.0),\n        # Case D: Stronger circular burst\n        (2.0e-21, 150.0, 0.05, 1.0),\n    ]\n\n    results = []\n    \n    for A, f0, sigma, epsilon in test_cases:\n        # If amplitude is zero, result is trivially zero\n        if A == 0.0:\n            results.append(0.0)\n            continue\n            \n        omega0 = 2.0 * np.pi * f0\n\n        # Define Gaussian envelope and its derivative\n        envelope_t = A * np.exp(-t**2 / (2.0 * sigma**2))\n        envelope_dot_t = -(t / sigma**2) * envelope_t\n\n        # Calculate time derivatives of h_plus and h_cross\n        cos_t = np.cos(omega0 * t)\n        sin_t = np.sin(omega0 * t)\n        \n        h_plus_dot_t = envelope_dot_t * cos_t - omega0 * envelope_t * sin_t\n        h_cross_dot_t = epsilon * (envelope_dot_t * sin_t + omega0 * envelope_t * cos_t)\n\n        # Integrand for Christodoulou memory calculation\n        integrand = h_plus_dot_t**2 + h_cross_dot_t**2\n\n        # Numerically integrate using the trapezoidal rule\n        integral_val = np.trapz(integrand, t, dx=dt)\n        \n        # Calculate the permanent strain change (memory) using a simplified\n        # relation derived from the gravitational wave stress-energy tensor.\n        prefactor = R_dist_m / (8.0 * np.pi * c)\n        delta_h_plus = prefactor * integral_val\n\n        # Calculate the permanent arm displacement\n        delta_L = 0.5 * L_arm * delta_h_plus\n        \n        results.append(delta_L)\n\n    # Format the final output as a comma-separated list in brackets\n    print(f\"[{results[0]},{results[1]},{results[2]},{results[3]}]\")\n\nsolve()\n\n```", "id": "2399205"}, {"introduction": "In numerical relativity, gravitational waveforms are often extracted not as the strain $h(t)$ directly, but as the Newman-Penrose scalar $\\Psi_4$, which is proportional to the strain's second time derivative. Recovering the physical strain and its memory component requires double time integration, a process susceptible to introducing non-physical, low-frequency drifts that can obscure the real signal. This practice immerses you in this common data analysis challenge, guiding you through the process of reconstructing the strain, modeling and subtracting numerical drift, and assessing the accuracy of the recovered memory. [@problem_id:3476243]", "problem": "You are tasked with designing and implementing a numerical procedure to assess gravitational wave memory contamination arising from numerical drift when reconstructing strain from the Newman–Penrose scalar. The physical and numerical context is as follows.\n\nFundamental base and definitions:\n- At future null infinity in the Transverse–Traceless (TT) gauge, the Newman–Penrose scalar $\\,\\Psi_4(u)\\,$ equals the negative second time derivative of the complex gravitational-wave strain $\\,h(u) = h_+(u) - i h_\\times(u)\\,$, i.e.,\n$$\\Psi_4(u) \\;=\\; -\\,\\frac{d^2 h(u)}{du^2}.$$\n- The gravitational-wave memory is the permanent displacement characterized by the net change in the real part of the strain across the burst:\n$$\\Delta h \\;=\\; \\lim_{u\\to +\\infty} \\mathrm{Re}\\,h(u) \\;-\\; \\lim_{u\\to -\\infty} \\mathrm{Re}\\,h(u).$$\n- In numerical relativity, one reconstructs $\\,h(u)\\,$ from $\\,\\Psi_4(u)\\,$ by double time-integration, but unknown integration constants induce a linear trend (numerical drift) $\\,d_0 + d_1 u\\,$ in the reconstructed strain. A standard mitigation is to fit and subtract this drift using data outside the burst (no-signal windows).\n\nYour program must:\n1. Construct synthetic test data $\\,\\Psi_4(u)\\,$ from a physically motivated $\\,h(u)\\,$ that contains a smooth memory step and an optional oscillatory component, then add Gaussian noise to $\\,\\Psi_4(u)\\,$.\n2. Reconstruct a preliminary strain $\\,h_{\\mathrm{raw}}(u)\\,$ by double integrating $\\,\\Psi_4(u)\\,$ with zero initial conditions (i.e., causal integrals with $\\,h(u_0)=0\\,$ and $\\,\\dot{h}(u_0)=0\\,$).\n3. Fit and subtract the linear drift model $\\,d_0 + d_1 u\\,$ from $\\,h_{\\mathrm{raw}}(u)\\,$ using least squares on the union of two no-signal time windows that exclude the burst.\n4. Estimate the recovered memory as the difference between the mean corrected strain $\\,h_{\\mathrm{corr}}(u)\\,$ at late and early times, and quantify contamination as the absolute error between the recovered and the true memory amplitude.\n\nSignal model and construction details:\n- Use retarded time $\\,u\\,$ in seconds and produce dimensionless strain quantities.\n- Define the smooth memory step using the error function:\n$$S(u) \\;=\\; \\tfrac{1}{2}\\,\\Bigl[1 + \\mathrm{erf}\\Bigl(\\frac{u-u_c}{\\sqrt{2}\\,\\sigma}\\Bigr)\\Bigr].$$\nLet the true memory be $\\,\\Delta h\\,$, so the memory contribution to strain is $\\,h_{\\mathrm{mem}}(u) = \\Delta h\\,S(u)\\,$. Its second derivative is\n$$\\frac{d^2 h_{\\mathrm{mem}}}{du^2}(u) \\;=\\; \\Delta h\\,\\frac{d^2 S}{du^2}(u) \\;=\\; -\\,\\Delta h\\,\\frac{u-u_c}{\\sqrt{2\\pi}\\,\\sigma^3}\\,\\exp\\!\\Bigl(-\\frac{(u-u_c)^2}{2\\sigma^2}\\Bigr),$$\nso the memory part of $\\,\\Psi_4(u)\\,$ is\n$$\\Psi_{4,\\mathrm{mem}}(u) \\;=\\; -\\,\\frac{d^2 h_{\\mathrm{mem}}}{du^2}(u) \\;=\\; \\Delta h\\,\\frac{u-u_c}{\\sqrt{2\\pi}\\,\\sigma^3}\\,\\exp\\!\\Bigl(-\\frac{(u-u_c)^2}{2\\sigma^2}\\Bigr).$$\n- Optionally include an oscillatory contribution to the strain\n$$h_{\\mathrm{osc}}(u) \\;=\\; A\\,\\sin(\\omega u)\\,\\exp\\!\\Bigl(-\\frac{(u-u_c)^2}{2\\tau^2}\\Bigr),$$\nwith Gaussian envelope of width $\\,\\tau\\,$. Denoting $\\,f(u) = \\exp\\!\\bigl(-\\frac{(u-u_c)^2}{2\\tau^2}\\bigr)\\,$, $\\,s(u)=\\sin(\\omega u)\\,$, one has $\\,f'(u) = -\\frac{u-u_c}{\\tau^2} f(u)\\,$ and $\\,f''(u) = \\bigl(\\frac{(u-u_c)^2}{\\tau^4}-\\frac{1}{\\tau^2}\\bigr)f(u)\\,$, as well as $\\,s''(u) = -\\omega^2 s(u)\\,$. Therefore,\n$$\\frac{d^2 h_{\\mathrm{osc}}}{du^2}(u) \\;=\\; A\\Bigl[f''(u)\\,s(u) + 2 f'(u)\\,\\omega\\cos(\\omega u) - \\omega^2 f(u)\\,s(u)\\Bigr],$$\nand the oscillatory part of $\\,\\Psi_4(u)\\,$ is\n$$\\Psi_{4,\\mathrm{osc}}(u) \\;=\\; -\\,\\frac{d^2 h_{\\mathrm{osc}}}{du^2}(u) \\;=\\; -A\\,f''(u)\\,s(u)\\;-\\;2A\\,\\omega f'(u)\\cos(\\omega u)\\;+\\;A\\,\\omega^2 f(u)\\,s(u).$$\n- The total $\\,\\Psi_4(u)\\,$ is\n$$\\Psi_4(u) \\;=\\; \\Psi_{4,\\mathrm{mem}}(u) \\;+\\; \\Psi_{4,\\mathrm{osc}}(u) \\;+\\; n(u),$$\nwhere $\\,n(u)\\,$ is zero-mean Gaussian noise with standard deviation $\\,\\sigma_n\\,$ in units of $\\,\\mathrm{s}^{-2}\\,$.\n\nNumerical reconstruction and drift removal:\n- Compute $\\,v(u) = \\int_{u_0}^u \\Psi_4(u')\\,du'\\,$ by trapezoidal cumulative integration with $\\,v(u_0) = 0\\,$, then compute\n$$h_{\\mathrm{raw}}(u) \\;=\\; \\int_{u_0}^u v(u')\\,du'$$\nby a second cumulative trapezoidal integration with $\\,h_{\\mathrm{raw}}(u_0) = 0\\,$. This induces an arbitrary linear trend $\\,d_0 + d_1 u\\,$ due to unknown integration constants, which must be estimated and removed.\n- For a given central time $\\,u_c\\,$ and exclusion half-width $\\,L\\,$ (seconds), define the no-signal windows as the union of $[u_{\\min},\\,u_c-L]$ and $[u_c+L,\\,u_{\\max}]$. Fit $\\,d_0 + d_1 u\\,$ to $\\,h_{\\mathrm{raw}}(u)\\,$ in these windows by least squares and subtract it to obtain $\\,h_{\\mathrm{corr}}(u)\\,$.\n- Estimate the recovered memory by\n$$\\Delta h_{\\mathrm{rec}} \\;=\\; \\overline{h_{\\mathrm{corr}}(u)}\\bigm|_{u \\in [u_c+L,\\,u_{\\max}]} \\;-\\; \\overline{h_{\\mathrm{corr}}(u)}\\bigm|_{u \\in [u_{\\min},\\,u_c-L]},$$\nwhere the overline denotes the arithmetic mean over the indicated interval.\n- Define the memory contamination metric as the absolute error\n$$\\varepsilon \\;=\\; \\bigl|\\Delta h_{\\mathrm{rec}} - \\Delta h\\bigr|.$$\n\nImplementation requirements:\n- All times $\\,u\\,$ must be in seconds, and all outputs are dimensionless strain. Angles for trigonometric functions use radians. The final answers must be dimensionless.\n- Perform numerical integrations using trapezoidal cumulative integration. You may use a robust library routine for cumulative trapezoidal integration.\n- Use a fixed random number generator seed to make the noise reproducible.\n\nTest suite:\nImplement the procedure above for the following four cases. Each case defines a uniform time grid $\\,u \\in [u_{\\min}, u_{\\max}]\\,$ with spacing $\\,\\Delta u\\,$, and parameters for the signal model and drift fit. All quantities are real-valued.\n\n- Case $\\,1\\,$ (happy path):\n  - $\\,u_{\\min} = -0.5\\,$, $\\,u_{\\max} = 0.5\\,$, $\\,\\Delta u = 10^{-3}\\,$.\n  - $\\,u_c = 0\\,$, $\\,\\sigma = 0.02\\,$, $\\,\\Delta h = 2\\times 10^{-22}\\,$.\n  - $\\,A = 5\\times 10^{-22}\\,$, $\\,\\omega = 500\\,$, $\\,\\tau = 0.05\\,$.\n  - $\\,\\sigma_n = 10^{-23}\\,$, $\\,L = 0.08\\,$.\n\n- Case $\\,2\\,$ (stronger oscillations and noise, shorter windows):\n  - $\\,u_{\\min} = -0.2\\,$, $\\,u_{\\max} = 0.2\\,$, $\\,\\Delta u = 5\\times 10^{-4}\\,$.\n  - $\\,u_c = 0\\,$, $\\,\\sigma = 0.01\\,$, $\\,\\Delta h = 1\\times 10^{-22}\\,$.\n  - $\\,A = 8\\times 10^{-22}\\,$, $\\,\\omega = 800\\,$, $\\,\\tau = 0.03\\,$.\n  - $\\,\\sigma_n = 3\\times 10^{-23}\\,$, $\\,L = 0.04\\,$.\n\n- Case $\\,3\\,$ (no oscillations, coarser sampling, wide window):\n  - $\\,u_{\\min} = -1.0\\,$, $\\,u_{\\max} = 1.0\\,$, $\\,\\Delta u = 2\\times 10^{-3}\\,$.\n  - $\\,u_c = 0\\,$, $\\,\\sigma = 0.05\\,$, $\\,\\Delta h = 5\\times 10^{-22}\\,$.\n  - $\\,A = 0\\,$, $\\,\\omega = 0\\,$, $\\,\\tau = 0.1\\,$.\n  - $\\,\\sigma_n = 5\\times 10^{-24}\\,$, $\\,L = 0.2\\,$.\n\n- Case $\\,4\\,$ (narrow memory, high frequency, high noise density):\n  - $\\,u_{\\min} = -0.05\\,$, $\\,u_{\\max} = 0.05\\,$, $\\,\\Delta u = 2\\times 10^{-4}\\,$.\n  - $\\,u_c = 0\\,$, $\\,\\sigma = 0.005\\,$, $\\,\\Delta h = 5\\times 10^{-23}\\,$.\n  - $\\,A = 2\\times 10^{-22}\\,$, $\\,\\omega = 1000\\,$, $\\,\\tau = 0.01\\,$.\n  - $\\,\\sigma_n = 5\\times 10^{-23}\\,$, $\\,L = 0.015\\,$.\n\nRequired final output:\n- For each case, compute the contamination metric $\\,\\varepsilon\\,$ defined above.\n- Your program should produce a single line of output containing the four results as a comma-separated list enclosed in square brackets. Each number must be printed in scientific notation with six significant digits (for example, $\\,1.234560\\mathrm{e}{-22}\\,$). The output must have the form\n$$\\texttt{[}\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4\\texttt{]}.$$\n\nAll computations must be done in floating-point arithmetic. No user input is permitted; all parameters are as stated above. Use a fixed random seed for the Gaussian noise so that the results are deterministic.", "solution": "The problem statement has been validated and found to be scientifically sound, well-posed, and objective. It provides a complete and consistent set of definitions, physical models, numerical procedures, and parameters to perform a quantitative analysis of gravitational wave memory contamination. The problem is directly relevant to the field of numerical relativity and represents a standard data analysis task. Therefore, a solution will be provided.\n\nThe objective is to implement a numerical procedure to quantify the contamination of the gravitational wave memory effect, $\\Delta h$, when the strain, $h(u)$, is reconstructed from the Newman-Penrose scalar, $\\Psi_4(u)$, in the presence of numerical drift and noise. The procedure involves synthesizing a realistic gravitational wave signal, reconstructing the strain via numerical integration, correcting for artifacts, and then measuring the error in the recovered memory. This process will be executed for four distinct test cases.\n\nThe procedure is as follows:\n\n1.  **Signal Synthesis**: For each test case, we first construct a discrete time series for the Newman-Penrose scalar, $\\Psi_4(u)$.\n    The time grid, $u$, is defined over the interval $[u_{\\min}, u_{\\max}]$ with a uniform spacing $\\Delta u$.\n    The total scalar, $\\Psi_4(u)$, is the sum of three components:\n    $$\\Psi_4(u) \\;=\\; \\Psi_{4,\\mathrm{mem}}(u) \\;+\\; \\Psi_{4,\\mathrm{osc}}(u) \\;+\\; n(u)$$\n    -   The memory component, $\\Psi_{4,\\mathrm{mem}}(u)$, is derived from the second derivative of a smooth step in the strain of total amplitude $\\Delta h$. Its functional form is given by:\n        $$\\Psi_{4,\\mathrm{mem}}(u) \\;=\\; \\Delta h\\,\\frac{u-u_c}{\\sqrt{2\\pi}\\,\\sigma^3}\\,\\exp\\!\\Bigl(-\\frac{(u-u_c)^2}{2\\sigma^2}\\Bigr)$$\n        where $u_c$ is the central time and $\\sigma$ controls the duration of the transition.\n    -   The oscillatory component, $\\Psi_{4,\\mathrm{osc}}(u)$, models the radiation during a merger event. It is the negative second time derivative of a sinusoidal signal with a Gaussian envelope:\n        $$h_{\\mathrm{osc}}(u) \\;=\\; A\\,\\sin(\\omega u)\\,\\exp\\!\\Bigl(-\\frac{(u-u_c)^2}{2\\tau^2}\\Bigr)$$\n        Using the product rule for differentiation and the provided definitions for the envelope $f(u) = \\exp\\!\\bigl(-\\frac{(u-u_c)^2}{2\\tau^2}\\bigr)$ and its derivatives $f'(u)$ and $f''(u)$, the oscillatory part of $\\Psi_4(u)$ is:\n        $$\\Psi_{4,\\mathrm{osc}}(u) \\;=\\; -A\\Bigl[f''(u)\\,\\sin(\\omega u) + 2 f'(u)\\,\\omega\\cos(\\omega u) - \\omega^2 f(u)\\,\\sin(\\omega u)\\Bigr]$$\n        For a given test case, if the amplitude $A$ is zero, this component is identically zero.\n    -   The noise component, $n(u)$, is modeled as a sequence of independent random variates drawn from a Gaussian (normal) distribution with a mean of $0$ and a standard deviation of $\\sigma_n$. To ensure reproducibility, a fixed seed is used for the random number generator.\n\n2.  **Strain Reconstruction**: The complex strain $h(u)$ is related to $\\Psi_4(u)$ by $\\Psi_4(u) = -d^2h/du^2$. Since the problem specifies all quantities are real, we consider a single real polarization. We reconstruct the strain from $\\Psi_4(u)$ by performing two successive indefinite integrations. With unknown integration constants, this would yield $h(u) = -\\iint \\Psi_4(u') du' du' + d_0 + d_1 u$. Numerically, we set the initial conditions to zero, corresponding to causal integration starting from $u_0 = u_{\\min}$. This yields a raw, uncorrected strain $h_{\\mathrm{raw}}(u)$. The integration is performed using the cumulative trapezoidal rule.\n    First, we compute the first integral, $v(u)$:\n    $$v(u) = \\int_{u_{\\min}}^u \\Psi_4(u')\\,du'$$\n    Then, we compute the second integral, the raw strain $h_{\\mathrm{raw}}(u)$:\n    $$h_{\\mathrm{raw}}(u) \\;=\\; \\int_{u_{\\min}}^u v(u')\\,du'$$\n    These integrations are performed numerically using a cumulative trapezoidal integration routine. The zero initial conditions, $v(u_{\\min})=0$ and $h_{\\mathrm{raw}}(u_{\\min})=0$, are implicitly handled by the choice of causal integration boundaries.\n\n3.  **Drift Correction**: The raw strain $h_{\\mathrm{raw}}(u)$ is contaminated by a linear drift term, $d_0 + d_1 u$, which is an artifact of the unknown true integration constants. This drift must be estimated and removed. We perform a linear least-squares fit of the model $y(u) = d_0 + d_1 u$ to the raw strain $h_{\\mathrm{raw}}(u)$. The fit is performed only on data within the \"no-signal\" windows, which are defined as the union of the time intervals $[u_{\\min}, u_c - L]$ and $[u_c + L, u_{\\max}]$. These regions are assumed to be dominated by the drift and noise, as the primary burst signal is localized around $u_c$.\n    Let $(u_i, y_i)$ be the discrete data pairs in these windows, where $y_i = h_{\\mathrm{raw}}(u_i)$. The coefficients $d_0$ and $d_1$ are found by minimizing the sum of squared residuals $\\sum_i (y_i - (d_0 + d_1 u_i))^2$.\n    Once the optimal $d_0$ and $d_1$ are found, the drift is subtracted from the entire raw strain timeseries to obtain the corrected strain:\n    $$h_{\\mathrm{corr}}(u) \\;=\\; h_{\\mathrm{raw}}(u) - (d_0 + d_1 u)$$\n\n4.  **Memory Recovery and Contamination Measurement**: The gravitational wave memory is the permanent offset in the strain after the burst has passed. We estimate this from the corrected strain, $h_{\\mathrm{corr}}(u)$, by comparing its average value at late times to its average value at early times. These time intervals are the same no-signal windows used for the drift fit.\n    The recovered memory, $\\Delta h_{\\mathrm{rec}}$, is calculated as:\n    $$\\Delta h_{\\mathrm{rec}} \\;=\\; \\overline{h_{\\mathrm{corr}}(u)}\\bigm|_{u \\in [u_c+L,\\,u_{\\max}]} \\;-\\; \\overline{h_{\\mathrm{corr}}(u)}\\bigm|_{u \\in [u_{\\min},\\,u_c-L]}$$\n    where the overline denotes the arithmetic mean.\n    Finally, the contamination metric, $\\varepsilon$, is defined as the absolute error between the recovered memory and the true memory amplitude, $\\Delta h$, that was used to generate the signal:\n    $$\\varepsilon \\;=\\; \\bigl|\\Delta h_{\\mathrm{rec}} - \\Delta h\\bigr|$$\n\nThis entire four-step procedure is implemented and applied to each of the four test cases provided in the problem statement, yielding a value of $\\varepsilon$ for each case. The final results are then formatted as required.", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import cumulative_trapezoid\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    # A fixed seed for the random number generator ensures reproducibility.\n    rng = np.random.default_rng(42)\n\n    test_cases = [\n        # Case 1\n        {\n            \"u_min\": -0.5, \"u_max\": 0.5, \"du\": 1e-3,\n            \"u_c\": 0.0, \"sigma\": 0.02, \"delta_h\": 2e-22,\n            \"A\": 5e-22, \"omega\": 500.0, \"tau\": 0.05,\n            \"sigma_n\": 1e-23, \"L\": 0.08,\n        },\n        # Case 2\n        {\n            \"u_min\": -0.2, \"u_max\": 0.2, \"du\": 5e-4,\n            \"u_c\": 0.0, \"sigma\": 0.01, \"delta_h\": 1e-22,\n            \"A\": 8e-22, \"omega\": 800.0, \"tau\": 0.03,\n            \"sigma_n\": 3e-23, \"L\": 0.04,\n        },\n        # Case 3\n        {\n            \"u_min\": -1.0, \"u_max\": 1.0, \"du\": 2e-3,\n            \"u_c\": 0.0, \"sigma\": 0.05, \"delta_h\": 5e-22,\n            \"A\": 0.0, \"omega\": 0.0, \"tau\": 0.1,\n            \"sigma_n\": 5e-24, \"L\": 0.2,\n        },\n        # Case 4\n        {\n            \"u_min\": -0.05, \"u_max\": 0.05, \"du\": 2e-4,\n            \"u_c\": 0.0, \"sigma\": 0.005, \"delta_h\": 5e-23,\n            \"A\": 2e-22, \"omega\": 1000.0, \"tau\": 0.01,\n            \"sigma_n\": 5e-23, \"L\": 0.015,\n        },\n    ]\n\n    results = []\n    for case_params in test_cases:\n        epsilon = calculate_memory_contamination(case_params, rng)\n        results.append(epsilon)\n\n    # Format the final output string as specified.\n    output_str = \"[\" + \",\".join([f\"{res:.6e}\" for res in results]) + \"]\"\n    print(output_str)\n\ndef calculate_memory_contamination(params, rng):\n    \"\"\"\n    Performs the full analysis for a single test case.\n    \"\"\"\n    # Unpack parameters for clarity\n    u_min, u_max, du = params[\"u_min\"], params[\"u_max\"], params[\"du\"]\n    u_c, sigma, delta_h = params[\"u_c\"], params[\"sigma\"], params[\"delta_h\"]\n    A, omega, tau = params[\"A\"], params[\"omega\"], params[\"tau\"]\n    sigma_n, L = params[\"sigma_n\"], params[\"L\"]\n\n    # 1. Signal Synthesis\n    # Create time grid\n    num_points = int(round((u_max - u_min) / du)) + 1\n    u = np.linspace(u_min, u_max, num=num_points)\n\n    # Memory component of Psi_4\n    u_rel = u - u_c\n    psi4_mem_prefactor = delta_h / (np.sqrt(2 * np.pi) * sigma**3)\n    psi4_mem = psi4_mem_prefactor * u_rel * np.exp(-u_rel**2 / (2 * sigma**2))\n\n    # Oscillatory component of Psi_4\n    if A != 0:\n        f = np.exp(-u_rel**2 / (2 * tau**2))\n        f_prime = -u_rel / tau**2 * f\n        f_double_prime = (u_rel**2 / tau**4 - 1 / tau**2) * f\n        \n        s = np.sin(omega * u)\n        c = np.cos(omega * u)\n        \n        d2h_osc_du2 = A * (f_double_prime * s + 2 * f_prime * omega * c - omega**2 * f * s)\n        psi4_osc = -d2h_osc_du2\n    else:\n        psi4_osc = np.zeros_like(u)\n\n    # Noise component\n    noise = rng.normal(loc=0.0, scale=sigma_n, size=len(u))\n\n    # Total Psi_4\n    psi4 = psi4_mem + psi4_osc + noise\n\n    # 2. Strain Reconstruction\n    # Double cumulative trapezoidal integration\n    v = cumulative_trapezoid(psi4, x=u, initial=0.0)\n    h_raw = cumulative_trapezoid(v, x=u, initial=0.0)\n\n    # 3. Drift Correction\n    # Define no-signal windows for fitting\n    early_fit_mask = u <= (u_c - L)\n    late_fit_mask = u >= (u_c + L)\n    fit_mask = early_fit_mask | late_fit_mask\n\n    # Get data points for the fit\n    u_fit = u[fit_mask]\n    h_raw_fit = h_raw[fit_mask]\n\n    # Perform linear least-squares fit: h_raw = d0 + d1*u\n    # The model matrix columns correspond to d0 (ones) and d1 (u)\n    A_matrix = np.vstack([np.ones_like(u_fit), u_fit]).T\n    coeffs, _, _, _ = np.linalg.lstsq(A_matrix, h_raw_fit, rcond=None)\n    d0, d1 = coeffs[0], coeffs[1]\n\n    # Subtract the fitted drift\n    h_corr = h_raw - (d0 + d1 * u)\n    \n    # 4. Memory Recovery and Contamination Measurement\n    # The averaging windows are the same as the fit windows\n    mean_early = np.mean(h_corr[early_fit_mask])\n    mean_late = np.mean(h_corr[late_fit_mask])\n    \n    delta_h_rec = mean_late - mean_early\n    \n    # Calculate contamination metric\n    epsilon = np.abs(delta_h_rec - delta_h)\n    \n    return epsilon\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3476243"}, {"introduction": "Translating a theoretical waveform into an observable signal requires confronting the limitations of real-world detectors. The gravitational wave memory effect, being a quasi-DC offset, is particularly vulnerable to the poor sensitivity of detectors at very low frequencies. In this final exercise, you will investigate this crucial observational challenge by injecting a known memory signal into a synthetic waveform, simulating the effect of a detector's low-frequency cutoff, and testing various baseline subtraction strategies to quantify how well the memory can be recovered from filtered data. [@problem_id:3476169]", "problem": "You are tasked with constructing a synthetic dataset to investigate gravitational wave memory effects in the context of Numerical Relativity (NR) and detector signal processing. The goal is to inject a known permanent strain offset (the \"memory\") into NR-like waveforms and evaluate recovery of the injected amplitude under detector band-limitation and baseline subtraction strategies.\n\nFundamental base and modeling assumptions:\n- The detector output is a linear response to a true strain time series $h(t)$.\n- Gravitational wave memory is modeled as a permanent change $\\Delta h$ in the strain, realized as a smooth step around an event time $t_0$ to ensure scientific realism and finite bandwidth.\n- Detector band-limitation is modeled by an ideal high-pass filter with cutoff frequency $f_{\\text{low}}$, represented by a transfer function $H(f)$ that is zero for $|f|<f_{\\text{low}}$ and one otherwise.\n- Baseline subtraction strategies are implemented as linear operations on the time series that remove constant or linear trends.\n\nConstruct the synthetic strain $h(t)$ on a uniform grid using the following components:\n1. An NR-like oscillatory component modeled as a Gaussian-enveloped linear chirp:\n   - Envelope: $A(t) = A_0 \\exp\\!\\left(-\\frac{(t-t_0)^2}{2\\sigma^2}\\right)$.\n   - Instantaneous phase: $\\phi(t) = 2\\pi\\left(f_1 (t-t_0) + \\frac{1}{2}k (t-t_0)^2\\right)$, so the instantaneous frequency is $f_{\\text{inst}}(t) = f_1 + k (t-t_0)$.\n   - Oscillatory strain: $h_{\\text{osc}}(t) = A(t)\\sin\\!\\big(\\phi(t)\\big)$.\n2. A smooth memory step function to inject the permanent offset $\\Delta h$:\n   - $h_{\\text{mem}}(t) = \\frac{\\Delta h}{2}\\left[1 + \\operatorname{erf}\\!\\left(\\frac{t-t_0}{\\sqrt{2}\\,\\sigma_s}\\right)\\right]$.\n3. The total strain is $h(t) = h_{\\text{osc}}(t) + h_{\\text{mem}}(t)$.\n\nProcessing:\n- Apply the ideal high-pass filter with cutoff $f_{\\text{low}}$ in the frequency domain to obtain a filtered strain $h_{\\text{hp}}(t)$.\n- Implement baseline subtraction strategies and estimate the memory amplitude by comparing time-averaged values over pre-event and post-event windows that exclude the transition region of the step:\n  - Define a guard interval $\\delta = 5\\sigma_s$ to exclude the transition region.\n  - Pre-event window: $[t_0 - \\delta - T_{\\text{pre}},\\, t_0 - \\delta]$.\n  - Post-event window: $[t_0 + \\delta,\\, t_0 + \\delta + T_{\\text{post}}]$.\n- Three baseline strategies:\n  1. \"none\": estimate $\\widehat{\\Delta h}$ as the difference of the post-event mean and pre-event mean of $h_{\\text{hp}}(t)$.\n  2. \"mean\\_pre\": subtract the pre-event mean of $h_{\\text{hp}}(t)$ from the entire series, then estimate $\\widehat{\\Delta h}$ as the post-event mean.\n  3. \"global\\_linear\": fit a linear trend $a + b t$ to $h_{\\text{hp}}(t)$ by least squares over the full window, subtract it, then estimate $\\widehat{\\Delta h}$ as the difference of post-event and pre-event means of the detrended series.\n\nNumerical specifications:\n- Sampling frequency $f_s = 1024$ Hz.\n- Total observation time $T_{\\text{tot}} = 64$ s.\n- Event time $t_0 = 32$ s.\n- Oscillatory component parameters: $A_0 = 3\\times 10^{-22}$, $\\sigma = 0.4$ s, $f_1 = 30$ Hz, $k = 400$ Hz/s.\n- Memory smoothness parameter: $\\sigma_s = 0.05$ s.\n- Default averaging windows: $T_{\\text{pre}} = 5$ s and $T_{\\text{post}} = 5$ s.\n\nTest suite:\nEvaluate the recovery (estimate $\\widehat{\\Delta h}$) for the following parameter sets, where each test case specifies $(\\Delta h, f_{\\text{low}}, \\text{strategy}, T_{\\text{pre}}, T_{\\text{post}})$:\n- Case $1$: $(1\\times 10^{-22},\\, 0.01,\\, \\text{\"mean\\_pre\"},\\, 5,\\, 5)$, a \"happy path\" with very low cutoff.\n- Case $2$: $(1\\times 10^{-22},\\, 10,\\, \\text{\"mean\\_pre\"},\\, 5,\\, 5)$, typical ground-based cutoff causing strong suppression of low-frequency content.\n- Case $3$: $(0,\\, 0.01,\\, \\text{\"global\\_linear\"},\\, 5,\\, 5)$, null memory to test bias under detrending.\n- Case $4$: $(5\\times 10^{-22},\\, 0.1,\\, \\text{\"none\"},\\, 5,\\, 5)$, larger memory with mild cutoff.\n- Case $5$: $(2\\times 10^{-22},\\, 0.01,\\, \\text{\"mean\\_pre\"},\\, 0.5,\\, 0.5)$, short averaging windows testing boundary conditions.\n\nRequired unit specification:\n- Strain is dimensionless; express all recovered estimates $\\widehat{\\Delta h}$ in dimensionless strain units as decimal floats.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,\\dots]$), ordered to correspond to Cases $1$ through $5$.", "solution": "The problem is valid as it presents a scientifically grounded, well-posed, and objective numerical experiment in gravitational wave data analysis. The models for the signal and detector effects, while simplified, are standard in the field. All parameters and procedures are specified unambiguously, allowing for a unique and verifiable solution.\n\nThe solution involves a three-stage process for each test case: a) generation of the synthetic strain time series, b) application of a high-pass filter in the frequency domain, and c) application of a specified time-domain estimation strategy to recover the memory amplitude.\n\nFirst, we establish the discrete time grid. Given a sampling frequency $f_s = 1024$ Hz and a total observation time $T_{\\text{tot}} = 64$ s, we define a time array with $N = f_s T_{\\text{tot}} = 65536$ points. The time step is $\\Delta t = 1/f_s$. The time samples are $t_i = i \\Delta t$ for $i = 0, 1, \\dots, N-1$. The event occurs at $t_0 = 32$ s.\n\nNext, we construct the total strain time series $h(t_i) = h_{\\text{osc}}(t_i) + h_{\\text{mem}}(t_i)$. The oscillatory component $h_{\\text{osc}}(t)$ is a Gaussian-enveloped linear chirp:\n$$h_{\\text{osc}}(t) = A_0 \\exp\\!\\left(-\\frac{(t-t_0)^2}{2\\sigma^2}\\right) \\sin\\!\\left(2\\pi\\left(f_1 (t-t_0) + \\frac{1}{2}k (t-t_0)^2\\right)\\right)$$\nwith parameters $A_0 = 3\\times 10^{-22}$, $\\sigma = 0.4$ s, $f_1 = 30$ Hz, and $k = 400$ Hz/s. The memory component $h_{\\text{mem}}(t)$ is a smooth step function modeled using the error function, $\\operatorname{erf}$:\n$$h_{\\text{mem}}(t) = \\frac{\\Delta h}{2}\\left[1 + \\operatorname{erf}\\!\\left(\\frac{t-t_0}{\\sqrt{2}\\,\\sigma_s}\\right)\\right]$$\nwhere $\\Delta h$ is the injected memory amplitude and $\\sigma_s = 0.05$ s controls the smoothness of the transition. The total strain $h(t)$ is the sum of these two components.\n\nThe second stage is to apply the ideal high-pass filter. This is most efficiently done in the frequency domain. We compute the Discrete Fourier Transform (DFT) of the time series $h(t_i)$, obtaining $\\tilde{h}(f_k) = \\mathcal{F}\\{h(t_i)\\}$, where $f_k$ are the discrete frequency bins. The ideal high-pass filter is represented by a transfer function $H(f)$ that is zero for frequencies below the cutoff and one otherwise. In the discrete domain, this becomes a mask:\n$$\nH(f_k) = \\begin{cases} 0 & \\text{if } |f_k| < f_{\\text{low}} \\\\ 1 & \\text{if } |f_k| \\ge f_{\\text{low}} \\end{cases}\n$$\nThe filtered signal in the frequency domain is $\\tilde{h}_{\\text{hp}}(f_k) = \\tilde{h}(f_k) \\cdot H(f_k)$. We then apply the inverse DFT to obtain the filtered time series $h_{\\text{hp}}(t_i) = \\mathcal{F}^{-1}\\{\\tilde{h}_{\\text{hp}}(f_k)\\}$. Due to numerical precision, the result of the inverse DFT may have a small imaginary component, which we discard by taking the real part.\n\nThe final stage is the estimation of the memory amplitude, $\\widehat{\\Delta h}$, using one of three baseline subtraction strategies. This requires defining pre- and post-event analysis windows that avoid the signal's central dynamics. With a guard interval $\\delta = 5\\sigma_s = 5 \\times 0.05\\,\\text{s} = 0.25\\,\\text{s}$, the windows are:\n- Pre-event window $W_{\\text{pre}} = [t_0 - \\delta - T_{\\text{pre}},\\, t_0 - \\delta]$\n- Post-event window $W_{\\text{post}} = [t_0 + \\delta,\\, t_0 + \\delta + T_{\\text{post}}]$\n\nThe estimation procedures are as follows, where $\\langle \\cdot \\rangle_W$ denotes the arithmetic mean over window $W$:\n1.  Strategy `none`: The estimate is the simple difference of means between the post-event and pre-event windows of the filtered data.\n    $$ \\widehat{\\Delta h} = \\langle h_{\\text{hp}}(t) \\rangle_{W_{\\text{post}}} - \\langle h_{\\text{hp}}(t) \\rangle_{W_{\\text{pre}}} $$\n2.  Strategy `mean_pre`: The mean of the pre-event window, $m_{\\text{pre}} = \\langle h_{\\text{hp}}(t) \\rangle_{W_{\\text{pre}}}$, is subtracted from the entire time series to create a detrended series $h'(t) = h_{\\text{hp}}(t) - m_{\\text{pre}}$. The estimate is then the mean of this detrended series in the post-event window.\n    $$ \\widehat{\\Delta h} = \\langle h'(t) \\rangle_{W_{\\text{post}}} = \\langle h_{\\text{hp}}(t) - m_{\\text{pre}} \\rangle_{W_{\\text{post}}} = \\langle h_{\\text{hp}}(t) \\rangle_{W_{\\text{post}}} - m_{\\text{pre}} $$\n    Analytically, this procedure is identical to the `none` strategy.\n\n3.  Strategy `global_linear`: A linear trend, $L(t) = a + bt$, is fitted to the entire filtered time series $h_{\\text{hp}}(t)$ using the method of least squares, which minimizes the sum of squared residuals $\\sum_i (h_{\\text{hp}}(t_i) - (a + bt_i))^2$. This trend is then subtracted from the data to yield a detrended series $h''(t) = h_{\\text{hp}}(t) - L(t)$. The estimate is the difference of means of this new series over the post- and pre-event windows.\n    $$ \\widehat{\\Delta h} = \\langle h''(t) \\rangle_{W_{\\text{post}}} - \\langle h''(t) \\rangle_{W_{\\text{pre}}} $$\nThis full procedure is executed for each of the five test cases provided.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf\nfrom scipy.fft import fft, ifft, fftfreq\n\ndef solve():\n    \"\"\"\n    Constructs, filters, and analyzes synthetic gravitational wave signals\n    with memory to estimate the injected memory amplitude under different\n    conditions as specified in the problem statement.\n    \"\"\"\n    # Numerical specifications from the problem statement\n    f_s = 1024.0  # Sampling frequency in Hz\n    T_tot = 64.0  # Total observation time in s\n    t_0 = 32.0    # Event time in s\n    A_0 = 3e-22   # Oscillatory component amplitude\n    sigma = 0.4   # Gaussian envelope width in s\n    f_1 = 30.0    # Initial instantaneous frequency in Hz\n    k = 400.0     # Frequency chirp rate in Hz/s\n    sigma_s = 0.05 # Memory step smoothness in s\n\n    # Define the discrete time grid\n    N = int(T_tot * f_s)\n    t = np.arange(N) / f_s\n\n    # Test cases from the problem statement\n    # Each case is a tuple: (delta_h, f_low, strategy, T_pre, T_post)\n    test_cases = [\n        (1e-22, 0.01, \"mean_pre\", 5.0, 5.0),\n        (1e-22, 10.0, \"mean_pre\", 5.0, 5.0),\n        (0.0, 0.01, \"global_linear\", 5.0, 5.0),\n        (5e-22, 0.1, \"none\", 5.0, 5.0),\n        (2e-22, 0.01, \"mean_pre\", 0.5, 0.5),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        delta_h, f_low, strategy, T_pre, T_post = case\n\n        # 1. Generate the synthetic strain time series h(t)\n        t_shifted = t - t_0\n        \n        # Oscillatory component: Gaussian-enveloped linear chirp\n        envelope = A_0 * np.exp(-t_shifted**2 / (2 * sigma**2))\n        phase = 2 * np.pi * (f_1 * t_shifted + 0.5 * k * t_shifted**2)\n        h_osc = envelope * np.sin(phase)\n\n        # Memory component: Smooth step function using erf\n        h_mem = (delta_h / 2.0) * (1 + erf(t_shifted / (np.sqrt(2) * sigma_s)))\n        \n        h_total = h_osc + h_mem\n\n        # 2. Apply the ideal high-pass filter in the frequency domain\n        freq_bins = fftfreq(N, d=1.0/f_s)\n        h_tilde = fft(h_total)\n        \n        # Create a boolean mask for the filter\n        # The filter is 1 for |f| >= f_low and 0 for |f| < f_low\n        filter_mask = np.abs(freq_bins) >= f_low\n        h_tilde_hp = h_tilde * filter_mask\n\n        # Transform back to the time domain and take the real part\n        h_hp = np.real(ifft(h_tilde_hp))\n\n        # 3. Estimate memory amplitude using the specified strategy\n        delta_guard = 5.0 * sigma_s\n\n        # Define analysis windows in terms of array indices\n        pre_start_idx = int((t_0 - delta_guard - T_pre) * f_s)\n        pre_end_idx = int((t_0 - delta_guard) * f_s)\n        post_start_idx = int((t_0 + delta_guard) * f_s)\n        post_end_idx = int((t_0 + delta_guard + T_post) * f_s)\n        \n        # Ensure indices stay within the array bounds\n        pre_start_idx = max(0, pre_start_idx)\n        pre_end_idx = min(N, pre_end_idx)\n        post_start_idx = max(0, post_start_idx)\n        post_end_idx = min(N, post_end_idx)\n\n        pre_window_data = h_hp[pre_start_idx:pre_end_idx]\n        post_window_data = h_hp[post_start_idx:post_end_idx]\n        \n        delta_h_hat = 0.0\n\n        if strategy == \"none\":\n            mean_pre = np.mean(pre_window_data)\n            mean_post = np.mean(post_window_data)\n            delta_h_hat = mean_post - mean_pre\n        \n        elif strategy == \"mean_pre\":\n            mean_pre = np.mean(pre_window_data)\n            # The definition is to subtract the pre-event mean from the\n            # whole series and then take the mean of the post-event window.\n            # This is mathematically equivalent to mean(post) - mean(pre).\n            h_detrended = h_hp - mean_pre\n            delta_h_hat = np.mean(h_detrended[post_start_idx:post_end_idx])\n\n        elif strategy == \"global_linear\":\n            # Fit a linear trend a + bt to the full time series\n            coeffs = np.polyfit(t, h_hp, 1) # returns [b, a]\n            linear_trend = coeffs[0] * t + coeffs[1]\n            h_detrended = h_hp - linear_trend\n            \n            # Estimate is the difference of means of the detrended series\n            mean_pre_detrended = np.mean(h_detrended[pre_start_idx:pre_end_idx])\n            mean_post_detrended = np.mean(h_detrended[post_start_idx:post_end_idx])\n            delta_h_hat = mean_post_detrended - mean_pre_detrended\n\n        results.append(delta_h_hat)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3476169"}]}