{"hands_on_practices": [{"introduction": "Before using a numerical code to explore the frontiers of physics, we must first establish confidence in its correctness. This practice introduces a cornerstone technique in scientific computing: the Method of Manufactured Solutions (MMS). You will verify a numerical solver for the dCS scalar field evolution equation, which lies at the heart of the theory's dynamics. By confirming that your code achieves the expected convergence rate for a known, manufactured solution, you will build essential skills for developing reliable computational tools for theoretical physics [@problem_id:3472081].", "problem": "You are asked to verify a numerical evolution code for the scalar sector of dynamical Chern-Simons (dCS) gravity using the Method of Manufactured Solutions. In the decoupling limit of dynamical Chern-Simons gravity on a flat spacetime background, the dCS scalar field satisfies a sourced wave equation of the form $\\Box \\vartheta = \\mathcal{S}$, where $\\Box$ is the d’Alembert operator in Minkowski spacetime and $\\mathcal{S}$ represents an effective source (for example, proportional to the gravitational Pontryagin density built from a background geometry). For code verification, you will work in one spatial dimension with periodic boundary conditions and construct a manufactured, analytic solution $\\vartheta(x,t)$, derive the corresponding source $\\mathcal{S}(x,t)$ consistent with the wave equation, and then verify that a second-order accurate finite-difference solver achieves the expected convergence rate.\n\nFundamental base for the derivation: the Minkowski-space scalar wave equation with an external source,\n$$\n\\partial_t^2 \\vartheta - c^2 \\partial_x^2 \\vartheta = \\mathcal{S},\n$$\nposed on a one-dimensional periodic domain $x \\in [0,1]$ with periodic boundary conditions and non-dimensionalized units in which $c$ is a dimensionless wave speed. The manufactured analytic solution is specified as\n$$\n\\vartheta(x,t) = \\sin(k x)\\cos(\\omega t),\n$$\nwith $k = 2\\pi m$, $m \\in \\mathbb{N}$, the angular frequency $\\omega > 0$, and $c > 0$. All quantities in this problem are dimensionless.\n\nYour tasks are:\n- Derive the source $\\mathcal{S}(x,t)$ implied by the manufactured solution and the wave equation above, expressing it in terms of $m$, $\\omega$, $c$, and $x$, $t$.\n- Implement a second-order accurate finite-difference method in space and a second-order accurate time integrator to evolve the fields $(\\vartheta, \\Pi)$, where $\\Pi = \\partial_t \\vartheta$, according to the first-order-in-time system\n$$\n\\partial_t \\vartheta = \\Pi, \\quad \\partial_t \\Pi = c^2 \\partial_x^2 \\vartheta + \\mathcal{S}(x,t).\n$$\nUse a uniform grid with $N$ points, grid spacing $\\Delta x = 1/N$, and periodic boundary conditions, with a time step $\\Delta t = \\mathrm{CFL} \\cdot \\Delta x / c$, where $\\mathrm{CFL} \\in (0,1)$ is a chosen constant.\n- Initialize at $t=0$ from the manufactured solution: $\\vartheta(x,0) = \\sin(k x)$ and $\\Pi(x,0) = \\partial_t \\vartheta(x,0) = 0$.\n- Evolve the system to a final time $T$, then compute the spatial $L^2$-norm of the error in $\\vartheta$,\n$$\nE_N = \\left( \\int_0^1 \\left[\\vartheta_N(x,T) - \\vartheta_{\\text{exact}}(x,T)\\right]^2 \\, dx \\right)^{1/2},\n$$\napproximated with the composite trapezoid rule on the uniform grid (which equals $\\sqrt{\\Delta x \\sum_j (\\cdot)^2}$ on a periodic uniform grid). Here $\\vartheta_N$ denotes the numerical solution using $N$ grid points.\n- For a grid refinement pair $(N_1, N_2)$ with $N_2 = 2 N_1$, compute the observed order of convergence\n$$\np_{\\mathrm{obs}} = \\frac{\\log(E_{N_1} / E_{N_2})}{\\log(\\Delta x_{N_1} / \\Delta x_{N_2})}.\n$$\n\nAngle units are radians. All quantities are dimensionless. Your program must implement the solver and compute $p_{\\mathrm{obs}}$ for each of the following three test cases. For each case, use $c = 1$, domain $x \\in [0,1]$, and periodic boundary conditions:\n- Case A (general source, moderate frequency): $m = 1$, $\\omega = 3.0$, $\\mathrm{CFL} = 0.4$, $T = 0.7$, grid pair $(N_1,N_2) = (32,64)$.\n- Case B (general source, higher spatial frequency): $m = 2$, $\\omega = 5.0$, $\\mathrm{CFL} = 0.4$, $T = 0.5$, grid pair $(N_1,N_2) = (48,96)$.\n- Case C (homogeneous wave equation, exact manufactured wave): $m = 1$, $\\omega = 2\\pi$, $\\mathrm{CFL} = 0.4$, $T = 0.4$, grid pair $(N_1,N_2) = (24,48)$.\n\nYour program should produce a single line of output containing the observed orders of convergence for the three cases as a comma-separated list enclosed in square brackets, with each value rounded to six decimal places, e.g., \"[2.000000,1.999999,2.000001]\", where each entry is a float. The final answers are unitless floats.\n\nDesign for coverage:\n- Case A is a typical case (“happy path”) with a nontrivial source.\n- Case B stresses spatial resolution with a higher mode number $m$.\n- Case C sets the source to zero by choosing $\\omega = c k$, testing the homogeneous wave case and boundary condition handling.\n\nImportant implementation details:\n- Space discretization: second-order centered finite differences for $\\partial_x^2 \\vartheta$.\n- Time discretization: a second-order accurate explicit scheme such as the two-stage explicit Runge–Kutta (Heun’s method) applied to the semi-discrete system above.\n- Use the same $\\mathrm{CFL}$ for $N_1$ and $N_2$ within each test to keep the time-discretization error at the same order in refinement studies.\n\nYour program must require no user input and must print only the final list on a single line. All computations are in non-dimensional units, and angle quantities are in radians. The final reported values must be floats rounded to six decimal places.", "solution": "The problem has been meticulously validated and is determined to be valid. It is scientifically grounded, well-posed, objective, self-contained, and formalizable. All necessary parameters and conditions are provided to construct a unique, verifiable solution.\n\nThe task is to verify a numerical solver for a sourced, one-dimensional scalar wave equation using the Method of Manufactured Solutions. This involves deriving the source term for a given analytic solution, implementing a second-order accurate numerical scheme, and confirming the theoretical convergence rate.\n\nFirst, we derive the source term $\\mathcal{S}(x,t)$ required by the wave equation\n$$\n\\partial_t^2 \\vartheta - c^2 \\partial_x^2 \\vartheta = \\mathcal{S}(x,t)\n$$\nand the manufactured solution\n$$\n\\vartheta(x,t) = \\sin(k x)\\cos(\\omega t),\n$$\nwhere $k=2\\pi m$. We compute the necessary partial derivatives of $\\vartheta(x,t)$. The second partial derivative with respect to time $t$ is:\n$$\n\\partial_t \\vartheta(x,t) = -\\omega \\sin(k x)\\sin(\\omega t)\n$$\n$$\n\\partial_t^2 \\vartheta(x,t) = -\\omega^2 \\sin(k x)\\cos(\\omega t)\n$$\nThe second partial derivative with respect to space $x$ is:\n$$\n\\partial_x \\vartheta(x,t) = k \\cos(k x)\\cos(\\omega t)\n$$\n$$\n\\partial_x^2 \\vartheta(x,t) = -k^2 \\sin(k x)\\cos(\\omega t)\n$$\nSubstituting these into the wave equation yields the source term $\\mathcal{S}$:\n$$\n\\mathcal{S}(x,t) = (-\\omega^2 \\sin(k x)\\cos(\\omega t)) - c^2 (-k^2 \\sin(k x)\\cos(\\omega t))\n$$\n$$\n\\mathcal{S}(x,t) = (-\\omega^2 + c^2 k^2) \\sin(k x)\\cos(\\omega t)\n$$\nThis is the analytic expression for the source term that must be implemented in the numerical solver. For Case C, where $c=1$, $m=1$, and $\\omega=2\\pi$, we have $k=2\\pi m = 2\\pi$. The prefactor becomes $(-\\omega^2 + c^2 k^2) = (-(2\\pi)^2 + 1^2 (2\\pi)^2) = 0$, so $\\mathcal{S}(x,t)=0$, as expected.\n\nNext, we design the numerical scheme. The problem is formulated as a first-order system in time:\n$$\n\\partial_t \\vartheta = \\Pi\n$$\n$$\n\\partial_t \\Pi = c^2 \\partial_x^2 \\vartheta + \\mathcal{S}(x,t)\n$$\nWe discretize the spatial domain $x \\in [0,1]$ using a uniform grid of $N$ points, $x_j = j \\Delta x$ for $j \\in \\{0, 1, ..., N-1\\}$, with grid spacing $\\Delta x = 1/N$. The second spatial derivative $\\partial_x^2 \\vartheta$ at a grid point $x_j$ is approximated using a second-order accurate centered finite-difference stencil, respecting the periodic boundary conditions:\n$$\n(\\partial_x^2 \\vartheta)_j \\approx \\frac{\\vartheta_{j+1} - 2\\vartheta_j + \\vartheta_{j-1}}{(\\Delta x)^2}\n$$\nwhere indices are evaluated modulo $N$. This semi-discretization results in a system of ordinary differential equations (ODEs) for the grid functions $\\vec{\\vartheta}(t)$ and $\\vec{\\Pi}(t)$.\n\nFor time evolution, we employ a second-order accurate explicit Runge-Kutta method, specifically Heun's method. Let the state vector be $\\mathbf{Y}(t) = (\\vec{\\vartheta}(t), \\vec{\\Pi}(t))^T$. The update from time $t_n$ to $t_{n+1} = t_n + \\Delta t$ is a two-stage process:\n1. Predictor step: An intermediate state $\\mathbf{Y}^*$ is computed using an explicit Euler step.\n$$\n\\vec{\\vartheta}^* = \\vec{\\vartheta}_n + \\Delta t \\cdot \\vec{\\Pi}_n\n$$\n$$\n\\vec{\\Pi}^* = \\vec{\\Pi}_n + \\Delta t \\cdot \\left(c^2 (\\partial_x^2\\vec{\\vartheta})_n + \\vec{\\mathcal{S}}(t_n)\\right)\n$$\n2. Corrector step: The final state $\\mathbf{Y}_{n+1}$ is computed using the average of the derivatives at the initial and predicted states.\n$$\n\\vec{\\vartheta}_{n+1} = \\vec{\\vartheta}_n + \\frac{\\Delta t}{2} (\\vec{\\Pi}_n + \\vec{\\Pi}^*)\n$$\n$$\n\\vec{\\Pi}_{n+1} = \\vec{\\Pi}_n + \\frac{\\Delta t}{2} \\left[ \\left(c^2 (\\partial_x^2\\vec{\\vartheta})_n + \\vec{\\mathcal{S}}(t_n)\\right) + \\left(c^2 (\\partial_x^2\\vec{\\vartheta})^* + \\vec{\\mathcal{S}}(t_{n+1})\\right) \\right]\n$$\nThe time step is set by the Courant-Friedrichs-Lewy (CFL) condition, $\\Delta t = \\mathrm{CFL} \\cdot \\Delta x / c$, which ensures stability and couples the spatial and temporal resolutions.\n\nThe initial conditions are set at $t=0$ from the manufactured solution: $\\vartheta(x,0) = \\sin(k x)$ and $\\Pi(x,0) = \\partial_t\\vartheta(x,0) = 0$. After evolving the system to the final time $T$, we compute the error. The spatial $L^2$-norm of the error between the numerical solution $\\vartheta_N(x,T)$ and the exact solution $\\vartheta_{\\text{exact}}(x,T)$ is approximated on the grid as:\n$$\nE_N = \\sqrt{\\Delta x \\sum_{j=0}^{N-1} \\left( \\vartheta_{N,j}(T) - \\vartheta_{\\text{exact}}(x_j, T) \\right)^2}\n$$\nTo verify the convergence rate, we compute the observed order of convergence, $p_{\\mathrm{obs}}$, using the errors $E_{N_1}$ and $E_{N_2}$ from two simulations with resolutions $N_1$ and $N_2 = 2N_1$:\n$$\np_{\\mathrm{obs}} = \\frac{\\log(E_{N_1} / E_{N_2})}{\\log(\\Delta x_1 / \\Delta x_2)} = \\frac{\\log(E_{N_1} / E_{N_2})}{\\log(2)}\n$$\nSince both the spatial and temporal discretizations are second-order accurate, and $\\Delta t \\propto \\Delta x$, we expect the overall method to be second-order, yielding $p_{\\mathrm{obs}} \\approx 2$. The following program implements this procedure.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the dCS wave equation verification problem for three test cases.\n    \"\"\"\n\n    def run_simulation_and_get_error(m, omega, c, cfl, T, N):\n        \"\"\"\n        Runs a single simulation and returns the L2 error.\n        \n        Args:\n            m (int): Mode number for the manufactured solution.\n            omega (float): Angular frequency.\n            c (float): Wave speed.\n            cfl (float): CFL factor.\n            T (float): Final evolution time.\n            N (int): Number of grid points.\n            \n        Returns:\n            float: The L2 norm of the error at time T.\n        \"\"\"\n        k = 2.0 * np.pi * m\n        dx = 1.0 / N\n        x = np.arange(N) * dx\n        dt = cfl * dx / c\n        n_steps = int(round(T / dt))\n\n        # Define analytic source and exact solution functions\n        def source_S(grid_x, t):\n            prefactor = -omega**2 + c**2 * k**2\n            if np.isclose(prefactor, 0.0):\n                return np.zeros_like(grid_x)\n            return prefactor * np.sin(k * grid_x) * np.cos(omega * t)\n\n        def exact_theta(grid_x, t):\n            return np.sin(k * grid_x) * np.cos(omega * t)\n\n        # Initial conditions from exact solution at t=0\n        theta = exact_theta(x, 0.0)\n        # pi = d(theta)/dt = -omega * sin(kx) * sin(wt). At t=0, pi is 0.\n        pi = np.zeros_like(x)\n        t = 0.0\n\n        # Time evolution using Heun's method (RK2)\n        for _ in range(n_steps):\n            # Stage 1: Predictor step (explicit Euler)\n            # RHS at current time t\n            d2x_theta = (np.roll(theta, -1) - 2 * theta + np.roll(theta, 1)) / (dx**2)\n            rhs_pi_t = c**2 * d2x_theta + source_S(x, t)\n            \n            # Predicted state at t + dt\n            theta_star = theta + dt * pi\n            pi_star = pi + dt * rhs_pi_t\n            \n            # Stage 2: Corrector step\n            # RHS at predicted time t + dt\n            t_plus_dt = t + dt\n            d2x_theta_star = (np.roll(theta_star, -1) - 2 * theta_star + np.roll(theta_star, 1)) / (dx**2)\n            rhs_pi_star = c**2 * d2x_theta_star + source_S(x, t_plus_dt)\n            \n            # Update fields using average of slopes\n            theta += 0.5 * dt * (pi + pi_star)\n            pi += 0.5 * dt * (rhs_pi_t + rhs_pi_star)\n            \n            t = t_plus_dt\n\n        # Compute L2 error against exact solution at final time T\n        theta_final_exact = exact_theta(x, T)\n        error_sq_integrand = (theta - theta_final_exact)**2\n        l2_error = np.sqrt(dx * np.sum(error_sq_integrand))\n        \n        return l2_error\n\n    # Define test cases as per the problem statement\n    # Each tuple: (m, omega, CFL, T, (N1, N2))\n    test_cases = [\n        (1, 3.0, 0.4, 0.7, (32, 64)),      # Case A\n        (2, 5.0, 0.4, 0.5, (48, 96)),      # Case B\n        (1, 2 * np.pi, 0.4, 0.4, (24, 48)) # Case C\n    ]\n    \n    c_wave_speed = 1.0\n    observed_orders = []\n\n    for m, omega, cfl, T, (N1, N2) in test_cases:\n        # Run simulations for the grid pair\n        error1 = run_simulation_and_get_error(m, omega, c_wave_speed, cfl, T, N1)\n        error2 = run_simulation_and_get_error(m, omega, c_wave_speed, cfl, T, N2)\n        \n        # Grid spacings\n        dx1 = 1.0 / N1\n        dx2 = 1.0 / N2\n        \n        # Calculate observed order of convergence\n        if error1 > 0 and error2 > 0:\n            p_obs = np.log(error1 / error2) / np.log(dx1 / dx2)\n        else:\n            # Handle cases with zero or near-zero error if they occur\n            p_obs = 0.0\n            \n        observed_orders.append(p_obs)\n\n    # Format and print the final results as specified\n    formatted_results = [f\"{order:.6f}\" for order in observed_orders]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3472081"}, {"introduction": "A hallmark of dynamical Chern-Simons gravity is its violation of parity symmetry, leading to distinctive signatures in gravitational wave propagation. This exercise provides a hands-on exploration of one such signature: amplitude birefringence. You will model the evolution of left- and right-handed circular polarizations of a gravitational wave in a dCS background, discovering how one can be amplified while the other is damped [@problem_id:3471988]. By solving the governing equation both analytically and numerically, you will gain direct insight into how the fundamental parity-violating coupling manifests as an observable phenomenon.", "problem": "Consider dynamical Chern-Simons gravity (dCS), defined by augmenting the Einstein-Hilbert action with a parity-violating coupling between a pseudo-scalar field and the Pontryagin density. In the decoupling limit where the pseudo-scalar field is treated as a prescribed background and spacetime is approximately Minkowski, linearized gravitational waves can be expressed as plane waves with circular polarization states. Let the background pseudo-scalar be homogeneous and linearly evolving, $\\vartheta(t) = \\vartheta_{0} + \\nu t$, with constant rate $\\nu$. In the small-coupling regime and for a single Fourier mode with comoving wavenumber $k$, the evolution of the amplitude of a circular polarization state $A \\in \\{+1,-1\\}$ can be modeled by the linear ordinary differential equation\n$$\n\\frac{d^{2} a_{A}}{dt^{2}} + 2 \\beta_{A}\\,\\frac{d a_{A}}{dt} + \\omega^{2}\\, a_{A} = 0,\n$$\nwhere $\\beta_{A} = A\\, \\lambda\\, k\\, \\nu$, $\\omega = k$, and $\\lambda$ is a dimensionless parameter that collects the relevant coupling constants and scales in dynamical Chern-Simons gravity. This model captures helicity-dependent amplitude birefringence in a homogeneous pseudo-scalar background. Work in natural units where $c=1$, and consider initial conditions $a_{A}(0)=1$ and $\\dot{a}_{A}(0)=0$. All amplitudes are dimensionless, and the final requested outputs are dimensionless floating-point errors.\n\nYour task is to calibrate and validate a numerical time-integration of the above equation against its analytic solution. The program you write must:\n\n- Implement a numerical integrator for the system by rewriting it as a first-order system in time and using a fixed-step fourth-order Runge–Kutta method for $a_{A}(t)$ and $\\dot{a}_{A}(t)$ over a time interval $[0,T]$ with $T>0$.\n- Derive and implement the closed-form analytic solution for $a_{A}(t)$ consistent with the above initial conditions and parameters $(A,k,\\lambda,\\nu)$.\n- For each test case listed below, compute the absolute error between the numerical and analytic solutions at $t=T$, i.e., $\\left|a_{A}^{\\text{num}}(T) - a_{A}^{\\text{ana}}(T)\\right|$.\n- Aggregate the errors for all test cases into a single list and print that list as the only output line.\n\nUse the following test suite to exercise different regimes:\n\n- Baseline general relativity (GR) limit with vanishing coupling: $(A,k,\\lambda,\\nu,T) = (+1,\\, 50.0,\\, 0.0,\\, 0.1,\\, 2.0)$. This validates recovery of GR when $\\lambda = 0$, with $k=\\omega=50.0$ and $T=2.0$.\n- Mild birefringence, underdamped right-handed mode: $(A,k,\\lambda,\\nu,T) = (+1,\\, 10.0,\\, 0.05,\\, 0.2,\\, 3.0)$, so that $\\beta_{A} = A \\lambda k \\nu = +0.1$ and $\\omega = 10.0$.\n- Mild birefringence with growth, underdamped left-handed mode: $(A,k,\\lambda,\\nu,T) = (-1,\\, 3.0,\\, 0.2,\\, 0.8,\\, 10.0)$, so that $\\beta_{A} = -0.48$ and $\\omega = 3.0$, testing stability under helicity-dependent amplification.\n- High-frequency wave with weak birefringence: $(A,k,\\lambda,\\nu,T) = (+1,\\, 200.0,\\, 0.001,\\, 0.5,\\, 0.5)$, so that $\\beta_{A} = +0.1$ and $\\omega = 200.0$, testing numerical resolution for rapid oscillations.\n\nAll quantities are to be treated as dimensionless in natural units. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[x1,x2,x3,x4]\"), where each $x_{i}$ is the absolute error for the corresponding test case as a floating-point number. No other text should be printed.", "solution": "The posed problem is valid. It is a well-defined initial value problem grounded in a standard physical model used to study phenomena in dynamical Chern-Simons gravity. It is self-contained, scientifically sound, and computationally feasible.\n\nThe core of the problem is to solve the second-order linear homogeneous ordinary differential equation (ODE) with constant coefficients:\n$$\n\\frac{d^{2} a_{A}}{dt^{2}} + 2 \\beta_{A}\\,\\frac{d a_{A}}{dt} + \\omega^{2}\\, a_{A} = 0\n$$\nsubject to the initial conditions $a_{A}(0)=1$ and $\\dot{a}_{A}(0)=0$. The parameters are given by $\\beta_{A} = A\\, \\lambda\\, k\\, \\nu$ and $\\omega = k$. We are asked to compare the numerical solution obtained via a fourth-order Runge-Kutta (RK$4$) method with the derived analytic solution.\n\n### 1. Derivation of the Analytic Solution\n\nWe begin by finding the characteristic equation of the ODE:\n$$\nr^2 + 2 \\beta_{A} r + \\omega^2 = 0\n$$\nThe roots $r$ are given by the quadratic formula:\n$$\nr = \\frac{-2 \\beta_{A} \\pm \\sqrt{(2 \\beta_{A})^2 - 4(1)(\\omega^2)}}{2} = -\\beta_{A} \\pm \\sqrt{\\beta_{A}^2 - \\omega^2}\n$$\nThe nature of the solution depends on the sign of the discriminant, $\\Delta = \\beta_{A}^2 - \\omega^2$. We analyze the three possible cases.\n\n**Case 1: Underdamped Motion ($\\beta_{A}^2 < \\omega^2$)**\nThe discriminant is negative. We define a real angular frequency $\\Omega = \\sqrt{\\omega^2 - \\beta_{A}^2}$. The roots are complex conjugates:\n$$\nr_{1,2} = -\\beta_{A} \\pm i\\Omega\n$$\nThe general solution is of the form:\n$$\na_{A}(t) = e^{-\\beta_{A} t} \\left( C_1 \\cos(\\Omega t) + C_2 \\sin(\\Omega t) \\right)\n$$\nWe apply the initial conditions to find the constants $C_1$ and $C_2$.\nFrom $a_{A}(0)=1$:\n$$\na_{A}(0) = e^{0} (C_1 \\cos(0) + C_2 \\sin(0)) = C_1 \\implies C_1 = 1\n$$\nThe first derivative is:\n$$\n\\dot{a}_{A}(t) = -\\beta_{A} e^{-\\beta_{A} t} \\left( \\cos(\\Omega t) + C_2 \\sin(\\Omega t) \\right) + e^{-\\beta_{A} t} \\left( -\\Omega \\sin(\\Omega t) + \\Omega C_2 \\cos(\\Omega t) \\right)\n$$\nFrom $\\dot{a}_{A}(0)=0$:\n$$\n\\dot{a}_{A}(0) = -\\beta_{A}(1) + \\Omega C_2 = 0 \\implies C_2 = \\frac{\\beta_{A}}{\\Omega}\n$$\nThus, the specific solution for the underdamped case is:\n$$\na_{A}(t) = e^{-\\beta_{A} t} \\left( \\cos(\\Omega t) + \\frac{\\beta_{A}}{\\Omega} \\sin(\\Omega t) \\right)\n$$\nAll test cases provided in the problem fall into this category, as $\\omega > |\\beta_A|$ for all of them. This includes the General Relativity case where $\\beta_A=0$, which simplifies to $a_A(t) = \\cos(\\omega t)$. It also includes the case with $\\beta_A < 0$, which exhibits exponential growth.\n\n**Case 2: Critically Damped Motion ($\\beta_{A}^2 = \\omega^2$)**\nThe discriminant is zero, yielding a single real root $r = -\\beta_{A}$. The general solution is:\n$$\na_{A}(t) = (C_1 + C_2 t) e^{-\\beta_{A} t}\n$$\nApplying $a_{A}(0)=1$ gives $C_1=1$. The derivative is $\\dot{a}_{A}(t) = C_2 e^{-\\beta_{A} t} - \\beta_A(C_1+C_2 t)e^{-\\beta_A t}$. Applying $\\dot{a}_A(0)=0$ gives $C_2 - \\beta_A C_1 = 0 \\implies C_2 = \\beta_A$. The solution is $a_A(t) = (1+\\beta_A t)e^{-\\beta_A t}$.\n\n**Case 3: Overdamped Motion ($\\beta_{A}^2 > \\omega^2$)**\nThe discriminant is positive. Let $q = \\sqrt{\\beta_{A}^2 - \\omega^2}$. The roots are real and distinct: $r_{1,2} = -\\beta_A \\pm q$. The general solution can be written as:\n$$\na_{A}(t) = e^{-\\beta_{A} t} \\left( C_1 \\cosh(q t) + C_2 \\sinh(q t) \\right)\n$$\nApplying $a_{A}(0)=1$ gives $C_1=1$. The derivative is $\\dot{a}_{A}(t) = -\\beta_A e^{-\\beta_A t}(\\dots) + e^{-\\beta_A t}(q C_1 \\sinh(qt) + q C_2 \\cosh(qt))$. Applying $\\dot{a}_A(0)=0$ gives $-\\beta_A C_1 + q C_2 = 0 \\implies C_2 = \\beta_A/q$. The solution is $a_A(t) = e^{-\\beta_A t} (\\cosh(qt) + \\frac{\\beta_A}{q}\\sinh(qt))$.\n\n### 2. Numerical Integration: Fourth-Order Runge-Kutta (RK4) Method\n\nTo apply a numerical integrator, we first convert the second-order ODE into a system of two first-order ODEs. Let the state vector be $\\mathbf{y}(t) = [y_1(t), y_2(t)]^T$, where $y_1 = a_A$ and $y_2 = \\dot{a}_A$. The system is:\n$$\n\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(t, \\mathbf{y})\n$$\nwhere\n$$\n\\frac{dy_1}{dt} = y_2\n$$\n$$\n\\frac{dy_2}{dt} = -2\\beta_A y_2 - \\omega^2 y_1\n$$\nSo, $\\mathbf{f}(t, \\mathbf{y}) = \\begin{pmatrix} y_2 \\\\ -2\\beta_A y_2 - \\omega^2 y_1 \\end{pmatrix}$. The initial state is $\\mathbf{y}(0) = [1, 0]^T$.\n\nThe RK$4$ method advances the solution from time $t_n$ to $t_{n+1} = t_n + h$ with a fixed step size $h$:\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{h}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\nwhere the intermediate slopes are:\n\\begin{align*}\n\\mathbf{k}_1 &= \\mathbf{f}(t_n, \\mathbf{y}_n) \\\\\n\\mathbf{k}_2 &= \\mathbf{f}(t_n + h/2, \\mathbf{y}_n + h/2 \\cdot \\mathbf{k}_1) \\\\\n\\mathbf{k}_3 &= \\mathbf{f}(t_n + h/2, \\mathbf{y}_n + h/2 \\cdot \\mathbf{k}_2) \\\\\n\\mathbf{k}_4 &= \\mathbf{f}(t_n + h, \\mathbf{y}_n + h \\cdot \\mathbf{k}_3)\n\\end{align*}\nTo ensure high accuracy, especially for the test case with high frequency $\\omega=200.0$, a small step size $h$ must be chosen. The period of the fastest oscillation is $P = 2\\pi/\\omega \\approx 0.0314$. A step size of $h=10^{-5}$ provides over $3000$ steps per period, which is more than sufficient for an accurate RK$4$ integration. To ensure the final time $T$ is reached exactly, the step size can be adjusted to $h_{\\text{adj}} = T/N$ where $N = \\lceil T/h \\rceil$.\n\n### 3. Error Computation\n\nFor each test case, we compute the analytic solution $a_A^{\\text{ana}}(T)$ and the numerical solution $a_A^{\\text{num}}(T) = y_1(T)$. The final output is the absolute error for each case:\n$$\n\\text{Error} = |a_A^{\\text{num}}(T) - a_A^{\\text{ana}}(T)|\n$$\nThe implementation will calculate this for each parameter set and collate the results.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the dCS ODE problem by comparing analytic and numerical solutions.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (A, k, lambda, nu, T)\n    test_cases = [\n        (1.0, 50.0, 0.0, 0.1, 2.0),\n        (1.0, 10.0, 0.05, 0.2, 3.0),\n        (-1.0, 3.0, 0.2, 0.8, 10.0),\n        (1.0, 200.0, 0.001, 0.5, 0.5),\n    ]\n\n    results = []\n    # Use a fixed step size for the RK4 integrator. This value is chosen to be small\n    # enough to guarantee high accuracy for the highest frequency in the test cases.\n    h = 1e-5\n\n    for case in test_cases:\n        A, k, lam, nu, T = case\n\n        # Calculate model parameters\n        omega = k\n        beta_A = A * lam * k * nu\n\n        # --- Analytic Solution ---\n        # The analytic solution depends on the discriminant of the characteristic equation.\n        # All test cases correspond to the underdamped/growing regime.\n        discriminant = beta_A**2 - omega**2\n\n        if discriminant  0:\n            # Underdamped case (includes undamped and growing modes)\n            Omega_val = np.sqrt(-discriminant)\n            # The analytic solution at time T\n            analytic_val = (np.exp(-beta_A * T) * \n                            (np.cos(Omega_val * T) + (beta_A / Omega_val) * np.sin(Omega_val * T)))\n        elif discriminant == 0:\n            # Critically damped case (not in test suite, but included for completeness)\n            analytic_val = (1 + beta_A * T) * np.exp(-beta_A * T)\n        else: # discriminant > 0\n            # Overdamped case (not in test suite)\n            q = np.sqrt(discriminant)\n            analytic_val = (np.exp(-beta_A * T) *\n                             (np.cosh(q * T) + (beta_A / q) * np.sinh(q * T)))\n\n\n        # --- Numerical Solution (RK4) ---\n        # State vector y = [a, a_dot]\n        y = np.array([1.0, 0.0])\n        \n        # The ODE system dy/dt = f(t, y)\n        def f(t_ignored, y_vec, beta, omega_sq):\n            y1, y2 = y_vec\n            dy1dt = y2\n            dy2dt = -2.0 * beta * y2 - omega_sq * y1\n            return np.array([dy1dt, dy2dt])\n            \n        # Calculate number of steps and adjust step size to land exactly on T\n        num_steps = int(np.ceil(T / h))\n        actual_h = T / num_steps\n        \n        omega_sq = omega**2\n        \n        t = 0.0\n        for _ in range(num_steps):\n            k1 = f(t, y, beta_A, omega_sq)\n            k2 = f(t + actual_h / 2.0, y + actual_h / 2.0 * k1, beta_A, omega_sq)\n            k3 = f(t + actual_h / 2.0, y + actual_h / 2.0 * k2, beta_A, omega_sq)\n            k4 = f(t + actual_h, y + actual_h * k3, beta_A, omega_sq)\n            \n            y += (actual_h / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n            t += actual_h\n        \n        numerical_val = y[0]\n        \n        # --- Calculate and store the absolute error ---\n        error = np.abs(numerical_val - analytic_val)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3471988"}, {"introduction": "Dynamical Chern-Simons gravity alters the very fabric of spacetime around spinning black holes, which in turn affects the motion of anything orbiting them. This practice focuses on a key feature of black hole accretion and binary dynamics: the Innermost Stable Circular Orbit (ISCO). You will investigate how dCS modifications to a black hole's frame-dragging shift the ISCO frequency, a potentially observable quantity in gravitational wave signals from binary inspirals [@problem_id:3472075]. This exercise will sharpen your ability to connect corrections in the spacetime metric to measurable changes in strong-field astrophysical phenomena.", "problem": "Consider a stationary, axisymmetric, asymptotically flat spacetime describing a spinning black hole of mass $M$ and dimensionless spin parameter $\\chi \\in [0,1)$. Work in geometrized units where $G=c=1$. Focus on equatorial circular timelike geodesics and the innermost stable circular orbit (ISCO). In General Relativity, the Kerr spacetime provides a baseline metric. In Boyer–Lindquist coordinates restricted to the equatorial plane $\\theta=\\pi/2$, the relevant Kerr metric components are functions of the radial coordinate $r$ and the spin parameter $a = \\chi M$, and one can use them to determine the orbital angular frequency $\\Omega$ of equatorial circular geodesics and the ISCO radius $r_{\\rm ISCO}$. In dynamical Chern-Simons (dCS) gravity (defined here as the parity-violating extension of General Relativity with an additional scalar field coupling to the Pontryagin density), leading-order slow-rotation, small-coupling corrections predominantly modify the frame-dragging sector encoded in the $g_{t\\phi}$ component.\n\nYour task is to design and implement a program that, for a specified set of $(\\chi,\\zeta)$ pairs, measures a numerically motivated dCS correction to the ISCO angular frequency and compares it to a slow-rotation analytic prediction. The comparison must be reported as dimensionless frequencies $M\\Omega$ and dimensionless discrepancies. Proceed as follows, starting from first principles:\n\n- Fundamental base:\n  - Use the Kerr spacetime as the zeroth-order background. For equatorial circular orbits in Kerr, the prograde orbital frequency is a known consequence of geodesic motion: it depends only on $r$ and $a$.\n  - The prograde ISCO radius $r_{\\rm ISCO}$ is a unique function of $a$, obtained by solving the marginal stability condition for equatorial timelike circular geodesics in Kerr. This function is exact within General Relativity and should be used as the baseline ISCO location for all cases in this problem.\n  - In the slow-rotation, small-coupling regime of dynamical Chern-Simons gravity, leading corrections to the spacetime predominantly enter through the frame-dragging sector. Model this by an additive correction to $g_{t\\phi}$ of the form $\\delta g_{t\\phi}(r) = \\zeta\\, a\\, \\mathcal{C}(r)$, with $M=1$ and\n    $$\\mathcal{C}(r) = c_0\\, r^{-4}\\left(1 + c_1 r^{-1} + c_2 r^{-2}\\right),$$\n    where $c_0=\\frac{5}{8}$, $c_1=\\frac{12}{7}$, and $c_2=\\frac{27}{10}$. This captures the correct qualitative radial fall-off and spin-coupling scaling for dCS-induced frame-dragging corrections, while remaining within the slow-rotation, small-coupling regime. Treat these coefficients as fixed model parameters.\n- Numerical measure of the dCS correction to the ISCO frequency:\n  - Interpret the dCS correction to $g_{t\\phi}$ as an effective shift in the spin parameter $a$ at a given radius, by matching the $g_{t\\phi}$ structure: in equatorial Kerr, $g_{t\\phi}^{\\rm Kerr} = -2a/r$. Define an effective spin $a_{\\rm eff}(r)$ by $-2 a_{\\rm eff}(r)/r \\equiv -2a/r + \\delta g_{t\\phi}(r)$, so that\n    $$\\delta a_{\\rm eff}(r) \\equiv a_{\\rm eff}(r) - a = -\\frac{r}{2}\\,\\delta g_{t\\phi}(r) = -\\frac{r}{2}\\,\\zeta\\, a\\, \\mathcal{C}(r).$$\n  - At the Kerr prograde ISCO radius $r_{\\rm ISCO}(a)$, compute the numerical dCS-corrected ISCO angular frequency by evaluating the prograde Kerr orbital frequency with the replacement $a \\to a_{\\rm eff}(r_{\\rm ISCO})$. Denote this by $\\Omega_{\\rm dCS,num}$.\n  - Define the Kerr ISCO angular frequency $\\Omega_{\\rm Kerr}$ by evaluating the prograde Kerr orbital frequency at $r_{\\rm ISCO}(a)$ with the unmodified spin $a$.\n  - The numerically measured dCS correction to the ISCO frequency is then\n    $$\\delta\\Omega_{\\rm num}(\\chi,\\zeta) \\equiv \\Omega_{\\rm dCS,num} - \\Omega_{\\rm Kerr}.$$\n- Slow-rotation analytic prediction for the frequency shift:\n  - In the slow-rotation, small-coupling regime, approximate the dCS-induced frequency shift at fixed $r_{\\rm ISCO}(a)$ by Taylor-expanding the Kerr orbital frequency in $a$ to first order in the effective spin shift $\\delta a_{\\rm eff}$:\n    $$\\delta\\Omega_{\\rm ana}(\\chi,\\zeta) \\equiv \\left.\\frac{\\partial \\Omega_{\\rm Kerr}(r,a)}{\\partial a}\\right|_{r=r_{\\rm ISCO}(a)} \\delta a_{\\rm eff}(r_{\\rm ISCO}(a)).$$\n  - This is the analytic slow-rotation prediction to be compared with the numerical measure $\\delta\\Omega_{\\rm num}$.\n\nImplementation requirements:\n\n- Use $M=1$ everywhere, so report all frequencies in units of $1/M$ and all outputs as dimensionless numbers.\n- For the prograde Kerr orbital frequency at radial coordinate $r$ and spin $a$, use the exact geodesic expression implied by General Relativity for equatorial circular orbits. For the prograde Kerr ISCO radius as a function of $a$, use the exact General Relativity expression for equatorial marginal stability.\n- For the dCS correction model, use the $\\delta g_{t\\phi}(r)$ given above and define $\\delta a_{\\rm eff}(r)$ accordingly.\n- For each test case $(\\chi,\\zeta)$, compute the relative discrepancy between the numerical and analytic corrections:\n  $$\\Delta(\\chi,\\zeta) \\equiv \\frac{\\delta\\Omega_{\\rm num}(\\chi,\\zeta) - \\delta\\Omega_{\\rm ana}(\\chi,\\zeta)}{\\max\\left(|\\delta\\Omega_{\\rm ana}(\\chi,\\zeta)|,\\,\\epsilon\\right)},$$\n  with $\\epsilon = 10^{-16}$ used only to avoid division by zero in cases where the analytic correction vanishes. The result is a dimensionless float for each test case.\n- Test suite:\n  - Use the following $(\\chi,\\zeta)$ pairs:\n    1. $(0.0,\\,10^{-2})$,\n    2. $(0.1,\\,10^{-3})$,\n    3. $(0.5,\\,10^{-2})$,\n    4. $(0.9,\\,2\\times 10^{-2})$.\n  - These cover a nonspinning boundary case, small spin and coupling, moderate spin, and near-extremal spin with small coupling.\n- Final output format:\n  - Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, \"[result1,result2,result3,result4]\". Each \"result\" must be the float $\\Delta(\\chi,\\zeta)$ for the corresponding test case, in the order listed above.\n\nYour solution must start from the fundamental laws and core definitions appropriate to General Relativity and dynamical Chern-Simons gravity, explain the modeling assumptions that connect the physical corrections to the computational quantities, and detail the algorithmic steps used to compute the outputs. All mathematical symbols must be presented in LaTeX. Ensure scientific realism by keeping the coupling $\\zeta$ small, interpreting $\\delta g_{t\\phi}$ as a leading-order frame-dragging modification, and explicitly reporting all frequencies in units of $1/M$.", "solution": "The problem requires designing a program to compute the discrepancy between a numerical estimate and an analytic approximation for the shift in the innermost stable circular orbit (ISCO) frequency of a spinning black hole due to dynamical Chern-Simons (dCS) gravity. The analysis is performed in the slow-rotation, small-coupling regime. The solution is developed from first principles of General Relativity (GR) and the provided dCS correction model.\n\nWe begin by establishing the theoretical foundation in geometrized units where $G=c=1$. The black hole mass is normalized to $M=1$, rendering all quantities dimensionless. The black hole's spin is characterized by the dimensionless parameter $a = \\chi$, where $\\chi \\in [0,1)$.\n\n### 1. General Relativistic Baseline: Equatorial Circular Geodesics in Kerr Spacetime\n\nThe unperturbed background is the Kerr spacetime. For timelike particles in circular, prograde orbits in the equatorial plane ($\\theta=\\pi/2$), the orbital angular frequency $\\Omega$ as measured by an observer at infinity is given by:\n$$\n\\Omega_{\\rm Kerr}(r, a) = \\frac{1}{r^{3/2} + a}\n$$\nHere, $r$ is the dimensionless Boyer-Lindquist radial coordinate and $a$ is the dimensionless spin parameter. The quantity $\\Omega_{\\rm Kerr}$ corresponds to the dimensionless product $M\\Omega$.\n\nThe radius of the innermost stable circular orbit, $r_{\\rm ISCO}$, is the smallest radius for which stable circular orbits exist. For prograde Kerr geodesics, it is the solution to the marginal stability condition and is given by the exact formula:\n$$\nr_{\\rm ISCO}(a) = 3 + Z_2 - \\sqrt{(3-Z_1)(3+Z_1+2Z_2)}\n$$\nwhere $Z_1$ and $Z_2$ are functions of the spin $a$:\n$$\nZ_1(a) = 1 + (1-a^2)^{1/3} \\left[ (1+a)^{1/3} + (1-a)^{1/3} \\right]\n$$\n$$\nZ_2(a) = \\sqrt{3a^2 + Z_1^2}\n$$\nThis radius $r_{\\rm ISCO}(a)$ serves as the fixed location at which we evaluate the frequency corrections.\n\n### 2. Dynamical Chern-Simons Correction Model\n\nThe problem models the leading-order dCS correction as a modification to the frame-dragging component of the metric, $g_{t\\phi}$. In the dimensionless coordinates used here (where distances are in units of $M$), the Kerr metric's equatorial $g_{t\\phi}$ component is $g_{t\\phi}^{\\rm Kerr} = -2a/r$. The dCS modification is an additive correction to this term:\n$$\n\\delta g_{t\\phi}(r) = \\zeta\\, a\\, \\mathcal{C}(r)\n$$\nwhere $\\zeta$ is the dimensionless dCS coupling constant and $\\mathcal{C}(r)$ is a radial function defined as:\n$$\n\\mathcal{C}(r) = c_0\\, r^{-4}\\left(1 + c_1 r^{-1} + c_2 r^{-2}\\right)\n$$\nwith given constants $c_0=5/8$, $c_1=12/7$, and $c_2=27/10$.\n\nTo quantify the effect of this metric correction on geodesic frequencies, we define an effective spin parameter $a_{\\rm eff}(r)$ that would produce the total (Kerr + dCS) $g_{t\\phi}$ value within the Kerr metric structure. The matching condition is:\n$$\ng_{t\\phi}^{\\rm total}(r) = g_{t\\phi}^{\\rm Kerr}(r) + \\delta g_{t\\phi}(r) \\equiv -\\frac{2 a_{\\rm eff}(r)}{r}\n$$\nSubstituting the expressions for the metric components, we find:\n$$\n-\\frac{2 a}{r} + \\zeta\\, a\\, \\mathcal{C}(r) = -\\frac{2 a_{\\rm eff}(r)}{r}\n$$\nThis allows us to solve for the shift in the effective spin, $\\delta a_{\\rm eff}(r) = a_{\\rm eff}(r) - a$:\n$$\n\\delta a_{\\rm eff}(r) = -\\frac{r}{2} \\delta g_{t\\phi}(r) = -\\frac{r}{2} \\zeta\\, a\\, \\mathcal{C}(r)\n$$\nThis spin shift encapsulates the leading-order dCS correction to the spacetime's frame-dragging at a given radius $r$.\n\n### 3. Frequency Shift Calculation and Discrepancy\n\nWe now define two methods to calculate the dCS-induced shift in the ISCO frequency.\n\n#### Numerical Measure\nThe \"numerical\" measure, $\\delta\\Omega_{\\rm num}$, is found by computing the full change in the Kerr frequency formula when the spin parameter $a$ is replaced by the effective spin $a_{\\rm eff}$. This evaluation is performed at the unperturbed GR ISCO radius, $r_{\\rm ISCO}(a)$.\nFirst, we find the effective spin at the ISCO radius, $a_{\\rm eff}(r_{\\rm ISCO}(a))$. The dCS-corrected frequency is then:\n$$\n\\Omega_{\\rm dCS,num} = \\Omega_{\\rm Kerr}\\left(r_{\\rm ISCO}(a), a_{\\rm eff}(r_{\\rm ISCO}(a))\\right) = \\Omega_{\\rm Kerr}\\left(r_{\\rm ISCO}(a), a + \\delta a_{\\rm eff}(r_{\\rm ISCO}(a))\\right)\n$$\nThe numerical frequency shift is the difference relative to the unperturbed Kerr frequency at the ISCO:\n$$\n\\delta\\Omega_{\\rm num} = \\Omega_{\\rm dCS,num} - \\Omega_{\\rm Kerr}(r_{\\rm ISCO}(a), a)\n$$\n\n#### Analytic Prediction (Linear Approximation)\nThe \"analytic\" prediction, $\\delta\\Omega_{\\rm ana}$, is derived from a first-order Taylor series expansion of the frequency function $\\Omega_{\\rm Kerr}(r, a)$ with respect to a small change in spin, $\\delta a_{\\rm eff}$, at a fixed radius $r=r_{\\rm ISCO}(a)$:\n$$\n\\delta\\Omega_{\\rm ana} = \\left. \\frac{\\partial \\Omega_{\\rm Kerr}(r,a)}{\\partial a} \\right|_{r=r_{\\rm ISCO}(a)} \\delta a_{\\rm eff}(r_{\\rm ISCO}(a))\n$$\nThe required partial derivative is:\n$$\n\\frac{\\partial \\Omega_{\\rm Kerr}}{\\partial a} = \\frac{\\partial}{\\partial a} (r^{3/2} + a)^{-1} = - (r^{3/2} + a)^{-2} = -\\left[\\Omega_{\\rm Kerr}(r,a)\\right]^2\n$$\nThus, the analytic prediction for the frequency shift is:\n$$\n\\delta\\Omega_{\\rm ana} = -\\left[\\Omega_{\\rm Kerr}(r_{\\rm ISCO}(a), a)\\right]^2 \\delta a_{\\rm eff}(r_{\\rm ISCO}(a))\n$$\n\n#### Relative Discrepancy\nThe central task is to compute the relative discrepancy $\\Delta$ between these two measures. This quantity measures the error of the linear approximation (the \"analytic\" method) relative to the full functional evaluation (the \"numerical\" method). It is defined as:\n$$\n\\Delta(\\chi,\\zeta) = \\frac{\\delta\\Omega_{\\rm num}(\\chi,\\zeta) - \\delta\\Omega_{\\rm ana}(\\chi,\\zeta)}{\\max\\left(|\\delta\\Omega_{\\rm ana}(\\chi,\\zeta)|,\\,\\epsilon\\right)}\n$$\nwhere $\\epsilon = 10^{-16}$ is a small regularization parameter to prevent division by zero, particularly for the non-spinning case ($\\chi=0$) where $\\delta\\Omega_{\\rm ana}=0$.\n\n### 4. Algorithmic Implementation\n\nThe computation for each given $(\\chi, \\zeta)$ pair proceeds as follows:\n1.  Set the dimensionless spin $a = \\chi$. If $a=0$, the discrepancy $\\Delta$ is analytically $0$, as the dCS correction vanishes.\n2.  Calculate the prograde Kerr ISCO radius $r_{\\rm ISCO}(a)$ using the exact GR formula.\n3.  Calculate the unperturbed Kerr orbital frequency $\\Omega_{\\rm Kerr}$ at $r_{\\rm ISCO}(a)$.\n4.  At $r_{\\rm ISCO}(a)$, compute the dCS radial function $\\mathcal{C}(r_{\\rm ISCO})$ and the effective spin shift $\\delta a_{\\rm eff}$.\n5.  Compute the numerical shift $\\delta\\Omega_{\\rm num}$ by evaluating the difference $\\Omega_{\\rm Kerr}(r_{\\rm ISCO}, a+\\delta a_{\\rm eff}) - \\Omega_{\\rm Kerr}(r_{\\rm ISCO}, a)$.\n6.  Compute the analytic shift $\\delta\\Omega_{\\rm ana}$ using the derived formula $-\\Omega_{\\rm Kerr}^2 \\delta a_{\\rm eff}$.\n7.  Finally, calculate the discrepancy $\\Delta$ using the provided formula.\n\nThis procedure is systematically applied to all test cases to generate the final output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_isco_radius(a: float) - float:\n    \"\"\"\n    Calculates the dimensionless prograde ISCO radius for a Kerr black hole.\n    M=1, so the spin parameter 'a' is the dimensionless spin 'chi'.\n    \n    Args:\n        a: Dimensionless spin parameter, chi.\n\n    Returns:\n        Dimensionless prograde ISCO radius, r_ISCO/M.\n    \"\"\"\n    if a == 0.0:\n        return 6.0\n    if a == 1.0:\n        return 1.0\n    \n    a2 = a * a\n    # Use np.cbrt for cube roots to handle potential floating point issues,\n    # though x**(1/3) is also fine for non-negative arguments.\n    term1_cbrt = np.cbrt(1.0 - a2)\n    term2_cbrt = np.cbrt(1.0 + a)\n    term3_cbrt = np.cbrt(1.0 - a)\n    \n    z1 = 1.0 + term1_cbrt * (term2_cbrt + term3_cbrt)\n    z2 = np.sqrt(3.0 * a2 + z1 * z1)\n    \n    # The '-' sign in 'mp' corresponds to prograde orbits.\n    r_isco = 3.0 + z2 - np.sqrt((3.0 - z1) * (3.0 + z1 + 2.0 * z2))\n    return r_isco\n\ndef omega_kerr(r: float, a: float) - float:\n    \"\"\"\n    Calculates the dimensionless prograde orbital frequency M*Omega for a\n    circular orbit in the Kerr spacetime.\n    \n    Args:\n        r: Dimensionless radial coordinate, r/M.\n        a: Dimensionless spin parameter, chi.\n\n    Returns:\n        Dimensionless orbital frequency, M*Omega.\n    \"\"\"\n    return 1.0 / (r**1.5 + a)\n\ndef calculate_discrepancy(chi: float, zeta: float) - float:\n    \"\"\"\n    Calculates the relative discrepancy Delta for a given (chi, zeta) pair.\n    \n    Args:\n        chi: Dimensionless spin parameter of the black hole.\n        zeta: Dimensionless dCS coupling constant.\n\n    Returns:\n        The discrepancy value Delta.\n    \"\"\"\n    a = chi  # With M=1, a = chi\n    epsilon = 1e-16\n\n    # For a non-spinning black hole (a=0), the dCS correction as modeled is zero.\n    # This implies delta_a_eff = 0, which makes both delta_omega_num and\n    # delta_omega_ana zero. The discrepancy is thus 0.\n    if a == 0.0:\n        return 0.0\n\n    # Step 1: Calculate the unperturbed Kerr prograde ISCO radius.\n    r_isco = get_isco_radius(a)\n\n    # Step 2: Calculate the unperturbed Kerr orbital frequency at the ISCO.\n    omega_gr = omega_kerr(r_isco, a)\n\n    # Step 3: Calculate the dCS correction terms at the ISCO radius.\n    # dCS model coefficients for the radial function C(r).\n    c0 = 5.0 / 8.0\n    c1 = 12.0 / 7.0\n    c2 = 27.0 / 10.0\n    \n    r_inv = 1.0 / r_isco\n    C_r = c0 * (r_inv**4) * (1.0 + c1 * r_inv + c2 * r_inv**2)\n    \n    # The shift in the effective spin parameter, evaluated at r_isco.\n    delta_a_eff = -0.5 * r_isco * zeta * a * C_r\n\n    # Step 4: Calculate the \"numerical\" frequency shift.\n    # This involves re-evaluating the full frequency formula with the shifted spin.\n    a_eff = a + delta_a_eff\n    omega_dcs_num_val = omega_kerr(r_isco, a_eff)\n    delta_omega_num = omega_dcs_num_val - omega_gr\n    \n    # Step 5: Calculate the \"analytic\" frequency shift (linear approximation).\n    # The derivative d(Omega)/da is -Omega^2.\n    domega_da = -omega_gr**2\n    delta_omega_ana = domega_da * delta_a_eff\n\n    # Step 6: Calculate the final relative discrepancy.\n    numerator = delta_omega_num - delta_omega_ana\n    denominator = max(abs(delta_omega_ana), epsilon)\n    \n    discrepancy = numerator / denominator\n    \n    return discrepancy\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the specified test suite.\n    It calculates the discrepancy for each case and prints the results\n    in the required format.\n    \"\"\"\n    \n    # Test suite: a list of (chi, zeta) pairs.\n    test_cases = [\n        (0.0, 1e-2),\n        (0.1, 1e-3),\n        (0.5, 1e-2),\n        (0.9, 2e-2),\n    ]\n\n    results = []\n    for chi, zeta in test_cases:\n        result = calculate_discrepancy(chi, zeta)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Using exponential notation for consistency and precision.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3472075"}]}