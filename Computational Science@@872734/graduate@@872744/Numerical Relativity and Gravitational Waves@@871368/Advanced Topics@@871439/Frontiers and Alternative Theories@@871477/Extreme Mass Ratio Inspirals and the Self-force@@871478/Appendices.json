{"hands_on_practices": [{"introduction": "The long, slow inspiral of an EMRI is governed by the two-timescale approximation, where the orbit evolves adiabatically under gravitational radiation reaction. This exercise allows you to numerically simulate this evolution using the well-established post-Newtonian formalism, combining the dissipative Peters-Mathews equations with the leading-order conservative effect of periastron advance. By implementing this model, you will gain hands-on experience in modeling the gradual decay of the orbit and the critical role of conservative effects in accumulating gravitational-wave phase [@problem_id:3474038].", "problem": "Consider an extreme mass ratio inspiral where a compact object of mass $\\mu$ orbits a massive black hole of mass $M$ with mass ratio $q = \\mu/M \\ll 1$. The goal is to test the adiabatic approximation by comparing the gravitational-wave phase accumulation $\\phi(t)$ computed from a purely dissipative self-force model (radiation reaction only) to a self-consistent evolution including a leading-order conservative piece. Work within the following physically justified and widely used approximations:\n\n1. Use Newtonian bound Keplerian orbits characterized by semi-major axis $a(t)$ and eccentricity $e(t)$ evolving due to gravitational radiation reaction according to the Peters-Mathews equations. These dissipative evolution equations are\n$$\n\\frac{da}{dt} = -\\frac{64}{5} \\frac{G^3 \\mu M (\\mu+M)}{c^5} \\frac{1}{a^3 (1-e^2)^{7/2}} \\left(1 + \\frac{73}{24} e^2 + \\frac{37}{96} e^4 \\right),\n$$\n$$\n\\frac{de}{dt} = -\\frac{304}{15} \\frac{G^3 \\mu M (\\mu+M)}{c^5} \\frac{e}{a^4 (1-e^2)^{5/2}} \\left(1 + \\frac{121}{304} e^2 \\right),\n$$\nwhere $G$ is the gravitational constant and $c$ is the speed of light.\n\n2. The instantaneous mean motion (orbital frequency in mean anomaly) is given by Kepler's third law\n$$\nn(a) = \\sqrt{\\frac{G (\\mu+M)}{a^3}}.\n$$\n\n3. Include a leading-order conservative general relativistic correction to the azimuthal phase via the periastron advance of a bound orbit. In the first post-Newtonian (1PN) limit, the periastron advance per orbit is\n$$\n\\Delta \\varpi = \\frac{6 \\pi G (\\mu+M)}{c^2 a (1 - e^2)},\n$$\nwhich corresponds to an azimuthal frequency correction factor\n$$\nk(a,e) = \\frac{3 G (\\mu+M)}{c^2 a (1 - e^2)},\n$$\nso that the azimuthal frequency becomes\n$$\n\\Omega_{\\phi}(a,e) = n(a) \\left(1 + k(a,e)\\right).\n$$\nThis conservative contribution is to be combined with the dissipative evolution for $a(t)$ and $e(t)$ self-consistently.\n\n4. For the dominant quadrupolar gravitational-wave harmonic, model the phase accumulation as\n$$\n\\phi_{\\text{diss}}(t) = 2 \\int_0^t n\\left(a(\\tau)\\right) \\, d\\tau,\n\\qquad\n\\phi_{\\text{cons}}(t) = 2 \\int_0^t n\\left(a(\\tau)\\right) \\left(1 + k\\left(a(\\tau), e(\\tau)\\right)\\right) d\\tau.\n$$\nDefine the phase difference\n$$\n\\Delta \\phi(t) = \\phi_{\\text{cons}}(t) - \\phi_{\\text{diss}}(t) = 2 \\int_0^t n\\left(a(\\tau)\\right) k\\left(a(\\tau), e(\\tau)\\right) d\\tau.\n$$\n\nAssume a non-spinning central black hole (Schwarzschild), so orbital plane inclination does not affect the leading-order phase dynamics; include the inclination as an input parameter with values specified below and treat its unit consistently. All angles must be provided in degrees; times must be handled in seconds; distances must be handled in meters; masses must be handled in kilograms. Express all final phase differences in radians.\n\nStarting from the above fundamental laws and facts, construct an algorithm that evolves $(a(t), e(t), \\Delta \\phi(t))$ from given initial conditions using the dissipative equations for $a(t)$ and $e(t)$ together with the conservative correction to the phase via $k(a,e)$. The evolution is adiabatic in the sense that $(a,e)$ change slowly compared to the orbital timescale.\n\nYour program must implement a robust ordinary differential equation integration over time using a scientifically sound numerical method. At the end of each evolution, output the value of $\\Delta \\phi(T)$ in radians.\n\nUse the following fixed physical constants:\n- $G = 6.67430 \\times 10^{-11} \\ \\mathrm{m^3 \\, kg^{-1} \\, s^{-2}}$,\n- $c = 299792458 \\ \\mathrm{m \\, s^{-1}}$,\n- $M_{\\odot} = 1.98847 \\times 10^{30} \\ \\mathrm{kg}$.\n\nUse the following global masses to realize $q = 10^{-6}$:\n- $M = 10^{6} M_{\\odot}$,\n- $\\mu = 1 M_{\\odot}$.\n\nDefine the gravitational radius $r_g = G M / c^2$ and set initial semi-major axis values $a_0$ as multiples of $r_g$.\n\nTest Suite:\nProvide three test cases that exercise different regimes. For each case, specify $(a_0, e_0, \\iota, T)$ as follows, where $\\iota$ is the orbital inclination provided in degrees (not used in the dynamics for Schwarzschild but included to ensure correct unit handling), $a_0$ is in meters, $e_0$ is dimensionless, and $T$ is in seconds. The mass ratio is fixed at $q = 10^{-6}$ for all cases.\n\n- Case 1 (happy path, moderate eccentricity and weak field):\n  - $a_0 = 100 \\, r_g$,\n  - $e_0 = 0.3$,\n  - $\\iota = 25^\\circ$,\n  - $T = 10^{6} \\ \\mathrm{s}$.\n\n- Case 2 (boundary case, nearly circular orbit):\n  - $a_0 = 100 \\, r_g$,\n  - $e_0 = 0.0$,\n  - $\\iota = 25^\\circ$,\n  - $T = 10^{5} \\ \\mathrm{s}$.\n\n- Case 3 (edge case, stronger field and higher eccentricity):\n  - $a_0 = 50 \\, r_g$,\n  - $e_0 = 0.7$,\n  - $\\iota = 25^\\circ$,\n  - $T = 5 \\times 10^{5} \\ \\mathrm{s}$.\n\nRequired Final Output:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases above. Each entry should be the floating-point value of $\\Delta \\phi(T)$ in radians computed for the corresponding case. For example, the output format must be\n$$\n[\\Delta \\phi_1, \\Delta \\phi_2, \\Delta \\phi_3].\n$$", "solution": "The user has provided a well-defined problem in the domain of gravitational-wave astrophysics. A validation of the problem statement confirms that it is scientifically grounded, well-posed, and contains all necessary information to proceed with a solution. No inconsistencies, ambiguities, or factual errors were found. The problem asks for the computation of a specific physical observable—the accumulated phase difference $\\Delta\\phi$ due to a conservative post-Newtonian effect—by numerically integrating a system of ordinary differential equations (ODEs) that model the evolution of a binary system undergoing an extreme mass ratio inspiral (EMRI).\n\nThe physical system is modeled by the state vector $\\vec{y}(t) = [a(t), e(t), \\Delta \\phi(t)]$, where $a$ is the orbital semi-major axis, $e$ is the eccentricity, and $\\Delta \\phi$ is the phase difference of interest. The evolution of this state is described by the initial value problem $\\frac{d\\vec{y}}{dt} = \\vec{F}(\\vec{y})$, with initial conditions $\\vec{y}(0) = [a_0, e_0, 0]$. The components of the ODE system $\\vec{F}(\\vec{y})$ are derived from the principles stated in the problem.\n\n1.  **Evolution of the Semi-Major Axis $a(t)$**: The rate of change of the semi-major axis is governed by the energy loss due to gravitational wave emission, given by the Peters-Mathews formula.\n    $$\n    \\frac{da}{dt} = -\\frac{64}{5} \\frac{G^3 \\mu M (\\mu+M)}{c^5} \\frac{1}{a^3 (1-e^2)^{7/2}} \\left(1 + \\frac{73}{24} e^2 + \\frac{37}{96} e^4 \\right)\n    $$\n    Here, $G$ is the gravitational constant, $c$ is the speed of light, and $\\mu$ and $M$ are the masses of the two objects. This equation describes the dissipative decay of the orbit.\n\n2.  **Evolution of the Eccentricity $e(t)$**: The change in eccentricity is also derived from the Peters-Mathews formalism, driven by the loss of orbital angular momentum to gravitational waves.\n    $$\n    \\frac{de}{dt} = -\\frac{304}{15} \\frac{G^3 \\mu M (\\mu+M)}{c^5} \\frac{e}{a^4 (1-e^2)^{5/2}} \\left(1 + \\frac{121}{304} e^2 \\right)\n    $$\n    This equation typically leads to the circularization of the orbit over time. If the initial eccentricity $e_0$ is $0$, the derivative $\\frac{de}{dt}$ is always zero, so the orbit remains circular.\n\n3.  **Evolution of the Phase Difference $\\Delta \\phi(t)$**: The problem defines the phase difference $\\Delta \\phi(t)$ as the integral of the additional phase accumulated per unit time due to the leading-order conservative periastron advance. The rate of change is therefore the integrand itself:\n    $$\n    \\frac{d(\\Delta \\phi)}{dt} = 2 \\, n(a) \\, k(a,e)\n    $$\n    The terms $n(a)$ and $k(a,e)$ are the orbital mean motion and the 1PN periastron advance factor, respectively:\n    $$\n    n(a) = \\sqrt{\\frac{G (\\mu+M)}{a^3}}, \\quad k(a,e) = \\frac{3 G (\\mu+M)}{c^2 a (1 - e^2)}\n    $$\n    Substituting these into the derivative yields the ODE for the phase difference:\n    $$\n    \\frac{d(\\Delta \\phi)}{dt} = 2 \\left(\\sqrt{\\frac{G (\\mu+M)}{a^3}}\\right) \\left(\\frac{3 G (\\mu+M)}{c^2 a (1 - e^2)}\\right) = \\frac{6 (G(\\mu+M))^{3/2}}{c^2 a^{5/2} (1 - e^2)}\n    $$\n\nThis system of three coupled, first-order ODEs forms a complete initial value problem that can be solved numerically. The algorithmic approach is as follows:\n1.  Define the necessary physical constants ($G$, $c$, $M_{\\odot}$) and system parameters ($M$, $\\mu$). From these, calculate the total mass $M_{tot} = M+\\mu$ and the gravitational radius of the primary black hole, $r_g = GM/c^2$.\n2.  For each test case, specified by the initial parameters $(a_0, e_0, \\iota, T)$:\n    a. Convert the initial semi-major axis $a_0$, given in units of $r_g$, into meters.\n    b. Set the initial state vector $\\vec{y}_0 = [a_0[\\text{m}], e_0, 0]$. The initial phase difference $\\Delta\\phi(0)$ is $0$. The inclination $\\iota$ is extraneous to the dynamics in this simplified model.\n    c. Implement a function that calculates the vector of derivatives, $\\frac{d\\vec{y}}{dt} = [\\frac{da}{dt}, \\frac{de}{dt}, \\frac{d(\\Delta \\phi)}{dt}]$, for a given state $\\vec{y}=[a, e, \\Delta\\phi]$.\n    d. Employ a robust numerical ODE solver, such as `scipy.integrate.solve_ivp`, to integrate the system from time $t=0$ to the final time $t=T$, starting from the initial state $\\vec{y}_0$.\n    e. From the solver's output, extract the value of the third state variable, $\\Delta\\phi$, at the final time $T$.\n3.  Arrange the computed values of $\\Delta\\phi(T)$ from all test cases into a single list and print it in the specified format.\n\nThis structured methodology ensures a correct and numerically stable solution. Using an adaptive solver like the default Runge-Kutta 4(5) method in `scipy.integrate.solve_ivp` is well-suited for this problem, as it can adjust its step size to maintain accuracy as the orbital parameters evolve and the characteristic timescales of the system change.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the EMRI evolution problem for a set of test cases.\n    \"\"\"\n    # Physical Constants\n    G = 6.67430e-11  # m^3 kg^-1 s^-2\n    c = 299792458.0  # m s^-1\n    M_sol = 1.98847e30 # kg\n\n    # System Masses\n    M = 1.0e6 * M_sol  # Primary black hole mass in kg\n    m = 1.0 * M_sol    # Compact object mass in kg\n    M_tot = M + m\n\n    # Pre-calculated common factors for the ODEs to improve performance\n    G3_c5_mM_Mtot = (G**3 / c**5) * m * M * M_tot\n    C_a_coeff = -(64.0 / 5.0) * G3_c5_mM_Mtot\n    C_e_coeff = -(304.0 / 15.0) * G3_c5_mM_Mtot\n    C_phi_coeff = 6.0 * (G * M_tot)**(3.0/2.0) / c**2\n\n    def ode_system(t, y):\n        \"\"\"\n        Defines the system of ordinary differential equations for [a, e, delta_phi].\n        y[0]: a (semi-major axis)\n        y[1]: e (eccentricity)\n        y[2]: delta_phi (phase difference)\n        \"\"\"\n        a, e, _ = y\n        \n        e2 = e * e\n        one_minus_e2 = 1.0 - e2\n        \n        # This condition prevents numerical errors if e approaches 1,\n        # which would signify a breakdown of the bound orbit model.\n        if one_minus_e2 <= 1e-12: # Add tolerance for float precision\n            return [0.0, 0.0, 0.0]\n\n        # Pre-calculate powers of a and (1-e^2) for efficiency\n        a3 = a * a * a\n        a4 = a3 * a\n        a_pow_2_5 = a**2.5\n        \n        one_minus_e2_pow_2_5 = one_minus_e2**2.5\n        one_minus_e2_pow_3_5 = one_minus_e2 * one_minus_e2_pow_2_5\n\n        # da/dt: rate of change of semi-major axis\n        f_a_poly = 1.0 + (73.0 / 24.0) * e2 + (37.0 / 96.0) * e2 * e2\n        dadt = C_a_coeff * f_a_poly / (a3 * one_minus_e2_pow_3_5)\n        \n        # de/dt: rate of change of eccentricity\n        # The factor of `e` ensures de/dt = 0 for perfectly circular orbits.\n        f_e_poly = 1.0 + (121.0 / 304.0) * e2\n        dedt = C_e_coeff * e * f_e_poly / (a4 * one_minus_e2_pow_2_5)\n\n        # d(Delta phi)/dt: rate of change of the conservative phase difference\n        d_delta_phi_dt = C_phi_coeff / (a_pow_2_5 * one_minus_e2)\n        \n        return [dadt, dedt, d_delta_phi_dt]\n\n    # Gravitational radius of the central black hole\n    r_g = G * M / c**2\n\n    # Define the test cases from the problem statement.\n    # Format: (initial a in r_g units, initial e, inclination in degrees, total time in seconds)\n    test_cases = [\n        (100.0, 0.3, 25.0, 1.0e6), # Case 1\n        (100.0, 0.0, 25.0, 1.0e5), # Case 2\n        (50.0, 0.7, 25.0, 5.0e5),  # Case 3\n    ]\n\n    results = []\n    for a0_factor, e0, _, T in test_cases:\n        # Set initial conditions for the current case\n        a0 = a0_factor * r_g\n        y0 = [a0, e0, 0.0]  # Initial state vector [a, e, delta_phi]\n        \n        # Time span for the integration\n        t_span = [0, T]\n        \n        # Solve the ODE system using a high-quality adaptive integrator\n        # The default 'RK45' method is suitable. Adding tighter tolerances\n        # for better accuracy in phase, which accumulates over long times.\n        sol = solve_ivp(\n            ode_system, \n            t_span, \n            y0, \n            method='RK45', \n            atol=1e-12, # Absolute tolerance\n            rtol=1e-9   # Relative tolerance\n        )\n        \n        # Extract the final value of delta_phi at time T\n        delta_phi_T = sol.y[2, -1]\n        \n        results.append(delta_phi_T)\n\n    # Print the final results in the exact specified format\n    print(f\"[{','.join(f'{r:.8g}' for r in results)}]\")\n\nsolve()\n```", "id": "3474038"}, {"introduction": "One of the most exciting prospects of EMRI science is the detection of transient orbital resonances, where the radial and vertical orbital frequencies form a rational ratio. This exercise employs a simplified toy model in action-angle variables to isolate the essential physics of a resonance crossing, allowing you to directly observe the characteristic phase jump in the gravitational waveform. This practice provides a clear illustration of a uniquely relativistic effect that serves as a powerful probe of the central black hole's spacetime geometry [@problem_id:3474025].", "problem": "Consider a simplified, self-consistent toy model of an extreme mass ratio inspiral (EMRI) in action-angle variables that captures transient resonances near a rational frequency ratio. Let the actions be $\\vec{J}=(J_{r},J_{\\theta})$ and the angles be $\\vec{q}=(q_{r},q_{\\theta})$. Assume:\n- The dissipative gravitational self-force induces slow action drift described by $\\dot{\\vec{J}}=q\\,\\vec{f}(\\vec{J})$, where $q$ is a small dimensionless parameter and $\\vec{f}$ is smooth. In this problem, take a linear drift model with constant rates so that $J_{r}(t)=J_{r}(0)-q\\,\\gamma_{r}\\,t$ and $J_{\\theta}(t)=J_{\\theta}(0)-q\\,\\gamma_{\\theta}\\,t$, where $\\gamma_{r}$ and $\\gamma_{\\theta}$ are constant drift coefficients.\n- The fundamental frequencies depend linearly on the actions: $\\omega_{r}(J_{r})=a_{r}+b_{r} J_{r}$ and $\\omega_{\\theta}(J_{\\theta})=a_{\\theta}+b_{\\theta} J_{\\theta}$, with given constants $a_{r},b_{r},a_{\\theta},b_{\\theta}$.\n- The angles evolve as $\\dot{q}_{r}=\\omega_{r}(J_{r}(t))$ and $\\dot{q}_{\\theta}=\\omega_{\\theta}(J_{\\theta}(t))+q\\,\\kappa\\,\\cos\\psi$, where $\\psi=n_{r}\\,q_{r}-n_{\\theta}\\,q_{\\theta}$ is the resonant phase for the rational ratio $n_{r}:n_{\\theta}=3:2$. The scalar $\\kappa$ sets the strength of the resonant perturbation in the angle dynamics. In a reference baseline (non-resonant) evolution, set $\\kappa=0$.\n- Work in dimensionless geometrized units with $G=c=M=1$, and use radians for all angles.\n\nThe gravitational wave phase is modeled as a linear combination of the angles, $\\phi_{h}(t)=m_{r}\\,q_{r}(t)+m_{\\theta}\\,q_{\\theta}(t)$, with fixed integers $m_{r}$ and $m_{\\theta}$. The toy gravitational wave strain is $h(t)=\\cos\\big(\\phi_{h}(t)\\big)$ with unit amplitude.\n\nYou must numerically integrate the system twice for each test case: once with the resonant perturbation with given $\\kappa>0$ and once without the resonant perturbation with $\\kappa=0$. Then:\n- Measure the phase jump $\\Delta\\phi$ induced by the transient resonance by unwrapping the phase difference $\\phi_{h}^{\\rm res}(t)-\\phi_{h}^{\\rm base}(t)$ between the resonant and baseline runs, and taking its net change between the final and initial times. Explicitly, compute $\\Delta\\phi=\\Big(\\mathrm{unwrap}\\big(\\phi_{h}^{\\rm res}-\\phi_{h}^{\\rm base}\\big)\\Big)\\big|_{t=T}-\\Big(\\mathrm{unwrap}\\big(\\phi_{h}^{\\rm res}-\\phi_{h}^{\\rm base}\\big)\\Big)\\big|_{t=0}$, in radians.\n- Estimate the Fourier-domain signature of the phase jump in the spectrum of $h(t)$ from the resonant run by computing the discrete Fourier transform of $h(t)$ on the interval $[0,T]$ with uniform sampling of step $\\Delta t$. Let $\\tilde{h}_{k}$ be the one-sided discrete Fourier transform magnitudes and let $k_{0}$ be the index of the largest nonzero-frequency bin. Define the sideband ratio $r$ as the average magnitude of the two immediate neighboring bins relative to the peak, namely $r=\\frac{1}{2}\\,\\frac{\\big|\\tilde{h}_{k_{0}-1}\\big|+\\big|\\tilde{h}_{k_{0}+1}\\big|}{\\big|\\tilde{h}_{k_{0}}\\big|}$, with appropriate one-sided boundary handling so that if $k_{0}$ lies at a boundary, use the single available neighbor. Report $r$ as a dimensionless float.\n\nFundamental base to use:\n- Action-angle Hamiltonian structure and definitions of actions and angles.\n- Slow dissipative drift due to the gravitational self-force encoded as $\\dot{\\vec{J}}=q\\,\\vec{f}(\\vec{J})$, with the supplied constant-rate model.\n- Angle evolution given by their instantaneous frequencies $\\dot{q}_{i}=\\omega_{i}(\\vec{J})$ and a small resonant perturbation proportional to $q\\,\\kappa\\,\\cos\\psi$.\n- The Fourier transform and the definition of spectral peaks and neighboring bins.\n\nImplementation requirements:\n- Use a fixed-step, deterministic numerical integrator appropriate for smooth ordinary differential equations to advance the angles $q_{r}(t)$ and $q_{\\theta}(t)$ on a uniform time grid $t_{n}=n\\,\\Delta t$ for $n=0,1,\\dots,N$, with $T=N\\,\\Delta t$.\n- At each substep, use the exact linear-in-time expressions for $J_{r}(t)$ and $J_{\\theta}(t)$ implied by the constant drift.\n- Unwrap phases in radians when computing $\\Delta\\phi$.\n- Compute the one-sided discrete Fourier spectrum of $h(t)$ over the full interval $[0,T]$ with uniform sampling $\\Delta t$ to obtain the sideband ratio $r$ as defined above.\n\nConstants common to all test cases:\n- $n_{r}=3$, $n_{\\theta}=2$.\n- $m_{r}=3$, $m_{\\theta}=2$.\n- $q=10^{-3}$.\n- $a_{r}=0.35$, $b_{r}=0.02$, $a_{\\theta}=0.5$, $b_{\\theta}=0.01$.\n- Initial actions $J_{r}(0)=1.0$, $J_{\\theta}(0)=0.8$.\n- Initial angles $q_{r}(0)=0$, $q_{\\theta}(0)=0$.\n\nTest suite:\nFor each case, specify $(\\gamma_{r},\\gamma_{\\theta},\\kappa,T,\\Delta t)$ as follows. All angles are in radians; times are in the same dimensionless units consistently with the dynamics.\n\n- Case $1$ (typical crossing): $(\\gamma_{r},\\gamma_{\\theta},\\kappa,T,\\Delta t)=(0.5,0.05,0.05,5000.0,0.5)$.\n- Case $2$ (weak resonance): $(\\gamma_{r},\\gamma_{\\theta},\\kappa,T,\\Delta t)=(0.5,0.05,0.005,5000.0,0.5)$.\n- Case $3$ (slow sweep, enhanced capture): $(\\gamma_{r},\\gamma_{\\theta},\\kappa,T,\\Delta t)=(0.1,0.01,0.05,20000.0,0.5)$.\n- Case $4$ (no crossing within window): $(\\gamma_{r},\\gamma_{\\theta},\\kappa,T,\\Delta t)=(-0.5,-0.05,0.05,5000.0,0.5)$.\n\nYour program must:\n- For each case, integrate the resonant system (with given $\\kappa>0$) and the baseline system (with $\\kappa=0$), compute $\\Delta\\phi$ and $r$ as defined above, and collect the pair $[\\Delta\\phi,r]$ as floats.\n- Produce a single line of output containing the results as a comma-separated list of lists, in the exact format $[[\\Delta\\phi_{1},r_{1}],[\\Delta\\phi_{2},r_{2}],[\\Delta\\phi_{3},r_{3}],[\\Delta\\phi_{4},r_{4}]]$.\n\nAll numeric outputs must be in radians for $\\Delta\\phi$ and dimensionless for $r$. Angles are measured in radians throughout. No user input is allowed; the program must be self-contained and use the test suite above.", "solution": "The problem as stated is scientifically grounded, well-posed, and objective. It presents a simplified but coherent toy model for studying transient resonances in extreme mass ratio inspirals (EMRIs), a valid and important topic in gravitational wave physics. The governing equations, initial conditions, and required computations are specified unambiguously. Therefore, the problem is deemed valid and a solution is provided below.\n\nThe core of the problem is to solve the equations of motion for the action-angle variables of a simplified EMRI system. The actions, $\\vec{J}(t) = (J_{r}(t), J_{\\theta}(t))$, evolve according to a prescribed linear drift:\n$$\nJ_{r}(t) = J_{r}(0) - q\\,\\gamma_{r}\\,t\n$$\n$$\nJ_{\\theta}(t) = J_{\\theta}(0) - q\\,\\gamma_{\\theta}\\,t\n$$\nwhere $q=10^{-3}$ is a small parameter, and $\\gamma_{r}$ and $\\gamma_{\\theta}$ are constant drift coefficients. The initial actions are $J_{r}(0)=1.0$ and $J_{\\theta}(0)=0.8$.\n\nThe fundamental orbital frequencies, $\\omega_r$ and $\\omega_\\theta$, depend linearly on the actions:\n$$\n\\omega_{r}(J_{r}) = a_{r} + b_{r} J_{r}\n$$\n$$\n\\omega_{\\theta}(J_{\\theta}) = a_{\\theta} + b_{\\theta} J_{\\theta}\n$$\nwith constants $a_{r}=0.35$, $b_{r}=0.02$, $a_{\\theta}=0.5$, and $b_{\\theta}=0.01$. Substituting the expressions for $J_r(t)$ and $J_\\theta(t)$ yields time-dependent frequencies which drive the evolution of the angle variables $\\vec{q}(t) = (q_{r}(t), q_{\\theta}(t))$.\n\nThe angles evolve according to the following system of first-order ordinary differential equations (ODEs):\n$$\n\\frac{dq_r}{dt} = \\omega_{r}(J_{r}(t))\n$$\n$$\n\\frac{dq_\\theta}{dt} = \\omega_{\\theta}(J_{\\theta}(t)) + q\\,\\kappa\\,\\cos(\\psi(t))\n$$\nwhere the initial conditions are $q_r(0)=0$ and $q_\\theta(0)=0$. The resonant phase is $\\psi(t) = n_{r}\\,q_{r}(t) - n_{\\theta}\\,q_{\\theta}(t)$, with the resonance defined by the integer ratio $n_r:n_\\theta = 3:2$. The parameter $\\kappa$ controls the strength of the resonant perturbation.\n\nThe problem requires numerical integration of this system. A fixed-step, fourth-order Runge-Kutta (RK4) method is an appropriate choice for this non-autonomous but smooth system of ODEs. The state vector is $\\vec{q}=(q_r, q_\\theta)$, and the derivative function $\\vec{F}(t, \\vec{q})$ is given by the right-hand sides of the angle evolution equations. An integration step from time $t_n$ to $t_{n+1} = t_n + \\Delta t$ is performed as:\n$$\n\\vec{k}_1 = \\Delta t \\, \\vec{F}(t_n, \\vec{q}_n)\n$$\n$$\n\\vec{k}_2 = \\Delta t \\, \\vec{F}(t_n + \\frac{\\Delta t}{2}, \\vec{q}_n + \\frac{\\vec{k}_1}{2})\n$$\n$$\n\\vec{k}_3 = \\Delta t \\, \\vec{F}(t_n + \\frac{\\Delta t}{2}, \\vec{q}_n + \\frac{\\vec{k}_2}{2})\n$$\n$$\n\\vec{k}_4 = \\Delta t \\, \\vec{F}(t_n + \\Delta t, \\vec{q}_n + \\vec{k}_3)\n$$\n$$\n\\vec{q}_{n+1} = \\vec{q}_n + \\frac{1}{6}(\\vec{k}_1 + 2\\vec{k}_2 + 2\\vec{k}_3 + \\vec{k}_4)\n$$\nAt each evaluation of $\\vec{F}$, the actions $J_r(t)$ and $J_\\theta(t)$ are calculated from their exact linear-in-time expressions.\n\nFor each test case specified by $(\\gamma_{r},\\gamma_{\\theta},\\kappa,T,\\Delta t)$, the following procedure is executed:\n1.  **Baseline Integration**: The ODE system is integrated from $t=0$ to $t=T$ with the perturbation strength set to $\\kappa=0$. This yields the baseline angle histories $q_{r}^{\\rm base}(t)$ and $q_{\\theta}^{\\rm base}(t)$.\n2.  **Resonant Integration**: The integration is repeated with the given non-zero value of $\\kappa$. This yields the resonant angle histories $q_{r}^{\\rm res}(t)$ and $q_{\\theta}^{\\rm res}(t)$.\n3.  **Phase Jump Calculation**: The gravitational wave phases for both runs are computed using $\\phi_{h}(t)=m_{r}\\,q_{r}(t)+m_{\\theta}\\,q_{\\theta}(t)$, where $m_r=3$ and $m_\\theta=2$. The phase difference, $\\phi_{h}^{\\rm res}(t)-\\phi_{h}^{\\rm base}(t)$, is calculated at each time step. The `numpy.unwrap` function is applied to this difference to resolve $2\\pi$ ambiguities. The total phase jump, $\\Delta\\phi$, is the difference between the final and initial values of this unwrapped phase difference.\n$$\n\\Delta\\phi = \\Big(\\mathrm{unwrap}\\big(\\phi_{h}^{\\rm res}-\\phi_{h}^{\\rm base}\\big)\\Big)\\big|_{t=T} - \\Big(\\mathrm{unwrap}\\big(\\phi_{h}^{\\rm res}-\\phi_{h}^{\\rm base}\\big)\\Big)\\big|_{t=0}\n$$\n4.  **Sideband Ratio Calculation**: The toy gravitational wave strain for the resonant case is computed as $h(t)=\\cos(\\phi_{h}^{\\rm res}(t))$. A one-sided discrete Fourier transform of the time series $h(t)$ is computed using `numpy.fft.rfft`. The magnitudes of the transform components, $|\\tilde{h}_k|$, are found. The index $k_0$ of the largest magnitude in the non-zero frequency part of the spectrum (i.e., for $k \\ge 1$) is identified. The sideband ratio, $r$, is calculated as the average magnitude of the immediate neighbors of the peak bin, normalized by the peak magnitude.\n$$\nr = \\frac{1}{2}\\,\\frac{\\big|\\tilde{h}_{k_{0}-1}\\big|+\\big|\\tilde{h}_{k_{0}+1}\\big|}{\\big|\\tilde{h}_{k_{0}}\\big|}\n$$\nAppropriate boundary handling is applied: if $k_0=1$, the neighbor at $k=0$ (DC component) is ignored and $r = |\\tilde{h}_2|/|\\tilde{h}_1|$. If $k_0$ is the last element in the spectrum, $r = |\\tilde{h}_{k_0-1}|/|\\tilde{h}_{k_0}|$.\n\nThis complete procedure is applied to each of the four test cases provided, and the resulting pairs $[\\Delta\\phi, r]$ are collected. The final output is a list of these pairs, formatted as specified.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the EMRI toy model problem for all test cases.\n    \"\"\"\n\n    # Constants common to all test cases\n    consts = {\n        \"nr\": 3, \"ntheta\": 2,\n        \"mr\": 3, \"mtheta\": 2,\n        \"epsilon\": 1e-3,\n        \"ar\": 0.35, \"br\": 0.02,\n        \"atheta\": 0.5, \"btheta\": 0.01,\n        \"J_r0\": 1.0, \"J_theta0\": 0.8,\n        \"q_r0\": 0.0, \"q_theta0\": 0.0,\n    }\n\n    # Test suite\n    test_cases = [\n        # (gamma_r, gamma_theta, kappa, T, dt)\n        (0.5, 0.05, 0.05, 5000.0, 0.5),    # Case 1\n        (0.5, 0.05, 0.005, 5000.0, 0.5),   # Case 2\n        (0.1, 0.01, 0.05, 20000.0, 0.5),   # Case 3\n        (-0.5, -0.05, 0.05, 5000.0, 0.5),  # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        result_pair = run_case(case, consts)\n        results.append(result_pair)\n    \n    # Format the final output string exactly as specified.\n    # [f\"[{dp},{r}]\" for dp, r in results] produces ['[dp1,r1]', '[dp2,r2]', ...]\n    # ','.join(...) then joins them with commas.\n    # The outer f\"[{...}]\" wraps the whole thing in brackets.\n    output_str = f\"[{','.join([f'[{dp},{r}]' for dp, r in results])}]\"\n    print(output_str)\n\ndef run_case(case_params, consts):\n    \"\"\"\n    Runs a single simulation for one test case and computes the required metrics.\n    \"\"\"\n    gamma_r, gamma_theta, kappa, T, dt = case_params\n    \n    # Time grid\n    num_steps = int(T / dt)\n    t_grid = np.linspace(0, T, num_steps + 1)\n    \n    # --- Define derivative function for ODEs ---\n    def derivatives(t, q, local_kappa):\n        q_r, q_theta = q[0], q[1]\n        \n        # Exact actions at time t\n        J_r_t = consts[\"J_r0\"] - consts[\"epsilon\"] * gamma_r * t\n        J_theta_t = consts[\"J_theta0\"] - consts[\"epsilon\"] * gamma_theta * t\n        \n        # Frequencies at time t\n        omega_r = consts[\"ar\"] + consts[\"br\"] * J_r_t\n        omega_theta = consts[\"atheta\"] + consts[\"btheta\"] * J_theta_t\n        \n        # Resonant phase\n        psi = consts[\"nr\"] * q_r - consts[\"ntheta\"] * q_theta\n        \n        # Derivatives\n        dq_r_dt = omega_r\n        dq_theta_dt = omega_theta + consts[\"epsilon\"] * local_kappa * np.cos(psi)\n        \n        return np.array([dq_r_dt, dq_theta_dt])\n\n    # --- Numerical Integrator (RK4) ---\n    def integrate(kappa_val):\n        q_history = np.zeros((num_steps + 1, 2))\n        q_history[0] = [consts[\"q_r0\"], consts[\"q_theta0\"]]\n        \n        for i in range(num_steps):\n            t = t_grid[i]\n            q_current = q_history[i]\n            \n            k1 = dt * derivatives(t, q_current, kappa_val)\n            k2 = dt * derivatives(t + dt/2, q_current + k1/2, kappa_val)\n            k3 = dt * derivatives(t + dt/2, q_current + k2/2, kappa_val)\n            k4 = dt * derivatives(t + dt, q_current + k3, kappa_val)\n            \n            q_history[i+1] = q_current + (k1 + 2*k2 + 2*k3 + k4) / 6\n        \n        return q_history\n\n    # 1. Integrate baseline (kappa=0) and resonant (kappa>0) systems\n    q_base_hist = integrate(kappa_val=0.0)\n    q_res_hist = integrate(kappa_val=kappa)\n\n    # 2. Compute phase jump Delta_phi\n    phi_h_base = consts[\"mr\"] * q_base_hist[:, 0] + consts[\"mtheta\"] * q_base_hist[:, 1]\n    phi_h_res = consts[\"mr\"] * q_res_hist[:, 0] + consts[\"mtheta\"] * q_res_hist[:, 1]\n    \n    phase_diff = phi_h_res - phi_h_base\n    unwrapped_diff = np.unwrap(phase_diff)\n    delta_phi = unwrapped_diff[-1] - unwrapped_diff[0]\n\n    # 3. Compute sideband ratio r\n    h_strain = np.cos(phi_h_res)\n    \n    # One-sided DFT for real signal\n    h_tilde = np.abs(np.fft.rfft(h_strain))\n    \n    # Find peak in AC spectrum (k>=1)\n    k0 = np.argmax(h_tilde[1:]) + 1\n    h_k0 = h_tilde[k0]\n    \n    num_bins = len(h_tilde)\n    \n    if h_k0 == 0: # Avoid division by zero, though unlikely\n        r = 0.0\n    elif k0 == 1:\n        # Left neighbor is DC (k=0), use only right neighbor (k=2)\n        # No 1/2 factor for single neighbor, as per instructions.\n        r = h_tilde[k0 + 1] / h_k0 if (k0 + 1) < num_bins else 0.0\n    elif k0 == num_bins - 1:\n        # Right neighbor doesn't exist, use only left\n        r = h_tilde[k0 - 1] / h_k0\n    else:\n        # Standard case: average of two neighbors\n        r = 0.5 * (h_tilde[k0 - 1] + h_tilde[k0 + 1]) / h_k0\n        \n    return [delta_phi, r]\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "3474025"}, {"introduction": "Accurately computing the gravitational self-force (GSF) requires overcoming the divergence of the particle's own field, a process known as regularization. This exercise introduces a key numerical technique used in the practical implementation of mode-sum regularization: the \"tail-fit\" procedure. You will learn to estimate the contribution from an infinite number of spherical harmonic modes by fitting an asymptotic model to a finite set of computed modes, a procedure essential for achieving high-accuracy GSF results [@problem_id:3474036].", "problem": "Design and implement a numerically robust tail-fit procedure to estimate the infinite-mode remainder in Mode-Sum Regularization (MSR) for the Gravitational Self-Force (GSF) of an Extreme Mass Ratio Inspiral (EMRI). Assume that after subtracting the known regularization parameters, the residual spherical-harmonic modes $F_{\\ell}$ for large multipole index $\\ell$ admit an asymptotic expansion in integer powers of $(\\ell+\\tfrac{1}{2})^{-1}$,\n$$\nF_{\\ell} \\sim \\sum_{j=1}^{m_{\\text{true}}} c^{\\text{true}}_{j}\\,(\\ell+\\tfrac{1}{2})^{-n^{\\text{true}}_{j}},\n$$\nwith $n^{\\text{true}}_{j} \\in \\mathbb{N}$ and coefficients $c^{\\text{true}}_{j} \\in \\mathbb{R}$. The objective is to estimate the infinite tail beyond a finite cutoff $L$,\n$$\nT = \\sum_{\\ell=L+1}^{\\infty} F_{\\ell},\n$$\nusing only a finite set of computed residual modes for $\\ell \\in \\{\\ell_{\\min},\\ldots,L\\}$. You must:\n- Construct a linear least-squares fit for a chosen model set of exponents $\\{n_{j}\\}_{j=1}^{m}$ to determine coefficients $\\{\\hat{c}_{j}\\}$ from the data $\\{F_{\\ell}\\}_{\\ell=\\ell_{\\min}}^{L}$.\n- Use the definition of the Hurwitz zeta function $\\zeta(s,a) = \\sum_{k=0}^{\\infty} (k+a)^{-s}$ to write the analytic expression for the fitted infinite tail,\n$$\n\\hat{T} = \\sum_{j=1}^{m} \\hat{c}_{j}\\,\\zeta\\!\\left(n_{j},\\,L+\\tfrac{3}{2}\\right).\n$$\n- Quantify the statistical uncertainty $\\sigma_{\\text{stat}}$ on $\\hat{T}$ by propagating the linear least-squares coefficient covariance to the linear functional defined by the vector $g$ with entries $g_{j}=\\zeta(n_{j}, L+\\tfrac{3}{2})$.\n- Control model-truncation error by a nested-model comparison: introduce an extended model with exponents $\\{n_{j}\\}_{j=1}^{m+1}$ that strictly contain the base model, refit on the same data, compute $\\hat{T}_{\\text{ext}}$, and define the truncation proxy $\\Delta T = |\\hat{T}_{\\text{ext}}-\\hat{T}|$. Report the combined uncertainty\n$$\n\\sigma_{\\text{comb}}=\\sqrt{\\sigma_{\\text{stat}}^{2}+\\Delta T^{2}}.\n$$\nAssume all quantities are dimensionless. Angles do not appear. The problem must be solved under the following constraints.\n\nFundamental base and modeling assumptions:\n- Use only that for sufficiently large $\\ell$, the residual after analytic MSR decays polynomially in $(\\ell+\\tfrac{1}{2})^{-1}$ due to the smoothness of the local singular field and the structure of high-$\\ell$ Green-function tails in General Relativity. Treat this as a well-tested asymptotic fact. Do not assume any particular values of the exponents beyond those provided in the test suite below.\n- Treat the finite-data residuals as generated by the asymptotic model plus additive, independent, zero-mean Gaussian noise with known standard deviation for each test case.\n- Use ordinary least squares on the linear-in-parameters model matrix $A_{\\ell j}=(\\ell+\\tfrac{1}{2})^{-n_{j}}$ to obtain $\\hat{c}_{j}$. Estimate the residual variance as $\\hat{\\sigma}^{2}=\\text{RSS}/\\nu$, where $\\text{RSS}$ is the residual sum of squares and $\\nu=N-m$ with $N$ the number of modes used and $m$ the number of fitted coefficients. If $\\nu \\leq 0$, set $\\hat{\\sigma}^{2}=0$.\n- Use the covariance $\\text{Cov}(\\hat{c})=\\hat{\\sigma}^{2}(A^{\\mathsf{T}}A)^{-1}$ when $(A^{\\mathsf{T}}A)$ is invertible; otherwise, use the Moore–Penrose pseudoinverse in its place.\n\nAlgorithmic requirements:\n- For each test case, generate synthetic data by drawing a Gaussian noise vector with the specified standard deviation and a fixed seed $20231105$. Construct $F_{\\ell}=\\sum_{j} c^{\\text{true}}_{j}(\\ell+\\tfrac{1}{2})^{-n^{\\text{true}}_{j}}+\\text{noise}$ for $\\ell \\in \\{\\ell_{\\min},\\ldots,L\\}$.\n- Fit the base model and extended model as specified per test case using the same data.\n- Compute the base-model tail $\\hat{T}$ and its statistical uncertainty $\\sigma_{\\text{stat}}$ via linear propagation, then compute the extended-model tail $\\hat{T}_{\\text{ext}}$ for $\\Delta T$, and finally compute $\\sigma_{\\text{comb}}$.\n- For each test, report the pair $(\\hat{T},\\sigma_{\\text{comb}})$.\n\nTest suite:\n- Test $1$ (happy path, even exponents with mild contamination):\n  - True exponents $[2,4,6]$, true coefficients $[5.0\\times 10^{-1},-3.0\\times 10^{-1},2.0\\times 10^{-1}]$.\n  - $\\ell_{\\min}=10$, $L=25$, noise standard deviation $1.0\\times 10^{-8}$.\n  - Fit exponents $[2,4]$; extended exponents $[2,4,6]$.\n- Test $2$ (low data count, exact model within noise):\n  - True exponents $[2,4]$, true coefficients $[1.0,0.0]$.\n  - $\\ell_{\\min}=5$, $L=8$, noise standard deviation $5.0\\times 10^{-10}$.\n  - Fit exponents $[2,4]$; extended exponents $[2,4,6]$.\n- Test $3$ (model mismatch with odd-power truth):\n  - True exponents $[3,5]$, true coefficients $[1.0\\times 10^{-1},5.0\\times 10^{-2}]$.\n  - $\\ell_{\\min}=8$, $L=20$, noise standard deviation $1.0\\times 10^{-10}$.\n  - Fit exponents $[2,4]$; extended exponents $[2,4,6]$.\n- Test $4$ (large cutoff, small tail, well-specified model):\n  - True exponents $[2,4,6]$, true coefficients $[2.0\\times 10^{-1},1.0\\times 10^{-1},-1.0\\times 10^{-1}]$.\n  - $\\ell_{\\min}=30$, $L=60$, noise standard deviation $1.0\\times 10^{-12}$.\n  - Fit exponents $[2,4,6]$; extended exponents $[2,4,6,8]$.\n- Test $5$ (noisy single-term case):\n  - True exponents $[2]$, true coefficients $[5.0\\times 10^{-2}]$.\n  - $\\ell_{\\min}=5$, $L=15$, noise standard deviation $1.0\\times 10^{-4}$.\n  - Fit exponents $[2]$; extended exponents $[2,4]$.\n\nFinal output format:\n- Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain for each test case, in order, the base-model tail estimate $\\hat{T}$ and the combined uncertainty $\\sigma_{\\text{comb}}$, for a total of $10$ floating-point numbers for the $5$ tests.\n- Each floating-point number must be printed in scientific notation with exactly $12$ digits after the decimal point.\n- For example, the required format is $[\\hat{T}_{1},\\sigma_{\\text{comb},1},\\hat{T}_{2},\\sigma_{\\text{comb},2},\\ldots,\\hat{T}_{5},\\sigma_{\\text{comb},5}]$.\n- The program must not require any user input, must not access external files or the network, and must use the fixed random seed $20231105$ to generate the Gaussian noise so that the output is reproducible.", "solution": "The problem requires the design and implementation of a numerical procedure to estimate the infinite tail of a mode sum, a common task in Gravitational Self-Force (GSF) calculations within the framework of Mode-Sum Regularization (MSR). The procedure involves fitting an asymptotic model to a finite number of computed modes and using this fit to extrapolate the sum to infinity. It also requires a careful quantification of both statistical and model-truncation uncertainties.\n\nThe core of the problem rests on the established asymptotic behavior of the residual GSF modes $F_{\\ell}$ for large multipole index $\\ell$. After subtracting analytically known singular parts (the regularization parameters), the remainder is known to decay polynomially. The problem posits the specific asymptotic model:\n$$\nF_{\\ell} \\sim \\sum_{j=1}^{m_{\\text{true}}} c^{\\text{true}}_{j}\\,(\\ell+\\tfrac{1}{2})^{-n^{\\text{true}}_{j}}\n$$\nwhere $n^{\\text{true}}_{j}$ are positive integers and $c^{\\text{true}}_{j}$ are real coefficients. We are provided with a finite set of \"data\" modes $\\{F_{\\ell}\\}_{\\ell=\\ell_{\\min}}^{L}$ and tasked with estimating the tail of the sum, $T = \\sum_{\\ell=L+1}^{\\infty} F_{\\ell}$.\n\nThe estimation procedure involves three main components: a linear least-squares fit to determine model coefficients, an analytical summation of the fitted model's tail using the Hurwitz zeta function, and a robust estimation of the total uncertainty.\n\nFirst, we perform a linear least-squares fit. We postulate a fitting model of the form $F_{\\ell} \\approx \\sum_{j=1}^{m} \\hat{c}_{j}\\,(\\ell+\\tfrac{1}{2})^{-n_{j}}$ for a chosen set of exponents $\\{n_{j}\\}_{j=1}^{m}$. This model is linear in the unknown coefficients $\\hat{c}_{j}$. We can express this as a matrix equation $y \\approx A c$, where $y$ is the vector of data modes $[F_{\\ell_{\\min}},\\ldots,F_{L}]^{\\mathsf{T}}$, $c$ is the vector of unknown coefficients $[\\hat{c}_{1},\\ldots,\\hat{c}_{m}]^{\\mathsf{T}}$, and $A$ is the design matrix. The number of data points is $N = L - \\ell_{\\min} + 1$. The design matrix $A$ has dimensions $N \\times m$, with entries $A_{ij} = (\\ell_{i}+\\tfrac{1}{2})^{-n_{j}}$, where $\\ell_i = \\ell_{\\min} + i - 1$ for $i=1, \\dots, N$. The ordinary least-squares solution for the coefficients that minimizes the residual sum of squares $\\text{RSS}=\\|y - Ac\\|^2$ is given by $\\hat{c} = (A^{\\mathsf{T}}A)^{-1}A^{\\mathsf{T}}y$. For numerical stability and to handle cases where $A^{\\mathsf{T}}A$ may be ill-conditioned or singular, we use the Moore-Penrose pseudoinverse, such that $\\hat{c} = (A^{\\mathsf{T}}A)^{+}A^{\\mathsf{T}}y$.\n\nSecond, once the coefficients $\\hat{c}$ are determined, we estimate the tail $T$ by summing the fitted function from $\\ell=L+1$ to infinity. This infinite sum, denoted $\\hat{T}$, can be calculated analytically:\n$$\n\\hat{T} = \\sum_{\\ell=L+1}^{\\infty} \\sum_{j=1}^{m} \\hat{c}_{j}\\,(\\ell+\\tfrac{1}{2})^{-n_{j}} = \\sum_{j=1}^{m} \\hat{c}_{j} \\left( \\sum_{\\ell=L+1}^{\\infty} (\\ell+\\tfrac{1}{2})^{-n_{j}} \\right)\n$$\nThe inner sum can be expressed using the Hurwitz zeta function, $\\zeta(s,a) = \\sum_{k=0}^{\\infty} (k+a)^{-s}$. By performing a change of index $k = \\ell - (L+1)$, the sum becomes:\n$$\n\\sum_{k=0}^{\\infty} (k+L+1+\\tfrac{1}{2})^{-n_j} = \\sum_{k=0}^{\\infty} (k+L+\\tfrac{3}{2})^{-n_j} = \\zeta(n_j, L+\\tfrac{3}{2})\n$$\nThus, the estimated tail is a linear combination of the fitted coefficients:\n$$\n\\hat{T} = \\sum_{j=1}^{m} \\hat{c}_{j}\\,\\zeta(n_j, L+\\tfrac{3}{2})\n$$\n\nThird, we quantify the uncertainty in this estimate. The total uncertainty arises from two primary sources: statistical error from noise in the input data, and systematic error from the truncation of the asymptotic model.\nThe statistical uncertainty, $\\sigma_{\\text{stat}}$, is calculated by propagating the uncertainty in the fitted coefficients $\\hat{c}$ to the final value $\\hat{T}$. Since $\\hat{T} = g^{\\mathsf{T}}\\hat{c}$, where $g$ is a vector with elements $g_j = \\zeta(n_j, L+\\tfrac{3}{2})$, the variance of $\\hat{T}$ is given by $\\sigma_{\\text{stat}}^2 = g^{\\mathsf{T}}\\text{Cov}(\\hat{c})g$. The covariance matrix of the coefficients is $\\text{Cov}(\\hat{c}) = \\hat{\\sigma}^2 (A^{\\mathsf{T}}A)^{+}$, where $\\hat{\\sigma}^2$ is the estimated variance of the residuals. This is computed as $\\hat{\\sigma}^2 = \\text{RSS}/\\nu$, with $\\text{RSS} = \\|y - A\\hat{c}\\|^2$ being the residual sum of squares from the fit, and $\\nu = N-m$ being the number of degrees of freedom. If $\\nu \\le 0$, we take $\\hat{\\sigma}^2=0$, which implies $\\sigma_{\\text{stat}}=0$.\n\nThe model truncation error is estimated using a nested-model comparison. We define a base model with $m$ exponents, $\\{n_j\\}_{j=1}^{m}$, and an extended model with $m+1$ exponents, $\\{n_j\\}_{j=1}^{m+1}$, where the extended set contains the base set. We fit both models to the same data, obtaining tail estimates $\\hat{T}$ and $\\hat{T}_{\\text{ext}}$. The absolute difference $\\Delta T = |\\hat{T}_{\\text{ext}} - \\hat{T}|$ serves as a proxy for the systematic error introduced by using a finite-term approximation for the true infinite asymptotic series.\n\nFinally, the statistical and systematic (truncation) errors are combined in quadrature to yield the total combined uncertainty:\n$$\n\\sigma_{\\text{comb}} = \\sqrt{\\sigma_{\\text{stat}}^2 + \\Delta T^2}\n$$\n\nThe overall algorithm proceeds as follows for each test case:\n$1$. A single random number generator is initialized with the specified seed $20231105$.\n$2$. For each test case, synthetic data $\\{F_{\\ell}\\}$ are generated for $\\ell \\in \\{\\ell_{\\min}, \\dots, L\\}$ by adding Gaussian noise with the specified standard deviation to the \"true\" model values.\n$3$. A dedicated function performs the fitting and analysis. It takes the data, the $\\ell$ range, and a set of exponents as input. It constructs the design matrix $A$, solves for the coefficients $\\hat{c}$ and RSS using a robust least-squares solver, computes the tail estimate $\\hat{T}$, and calculates the statistical uncertainty $\\sigma_{\\text{stat}}$.\n$4$. This function is first called with the base model exponents to obtain $\\hat{T}$ and $\\sigma_{\\text{stat}}$.\n$5$. It is then called with the extended model exponents to obtain $\\hat{T}_{\\text{ext}}$.\n$6$. The truncation error proxy $\\Delta T$ and the combined uncertainty $\\sigma_{\\text{comb}}$ are computed.\n$7$. The resulting pair $(\\hat{T}, \\sigma_{\\text{comb}})$ is stored.\n$8$. After processing all test cases, the collected results are formatted and printed as a single line of text. This ensures a complete, reproducible, and verifiable solution to the problem.", "answer": "```python\nimport numpy as np\nfrom scipy.special import zeta\n\ndef solve():\n    \"\"\"\n    Main function to run the tail-fitting procedure for all test cases.\n    \"\"\"\n    test_cases = [\n        # Test 1: Happy path, even exponents with mild contamination\n        {\n            \"true_coeffs\": [5.0e-1, -3.0e-1, 2.0e-1], \"true_exponents\": [2, 4, 6],\n            \"l_min\": 10, \"L\": 25, \"noise_std\": 1.0e-8,\n            \"fit_exponents\": [2, 4], \"ext_fit_exponents\": [2, 4, 6]\n        },\n        # Test 2: Low data count, exact model within noise\n        {\n            \"true_coeffs\": [1.0, 0.0], \"true_exponents\": [2, 4],\n            \"l_min\": 5, \"L\": 8, \"noise_std\": 5.0e-10,\n            \"fit_exponents\": [2, 4], \"ext_fit_exponents\": [2, 4, 6]\n        },\n        # Test 3: Model mismatch with odd-power truth\n        {\n            \"true_coeffs\": [1.0e-1, 5.0e-2], \"true_exponents\": [3, 5],\n            \"l_min\": 8, \"L\": 20, \"noise_std\": 1.0e-10,\n            \"fit_exponents\": [2, 4], \"ext_fit_exponents\": [2, 4, 6]\n        },\n        # Test 4: Large cutoff, small tail, well-specified model\n        {\n            \"true_coeffs\": [2.0e-1, 1.0e-1, -1.0e-1], \"true_exponents\": [2, 4, 6],\n            \"l_min\": 30, \"L\": 60, \"noise_std\": 1.0e-12,\n            \"fit_exponents\": [2, 4, 6], \"ext_fit_exponents\": [2, 4, 6, 8]\n        },\n        # Test 5: Noisy single-term case\n        {\n            \"true_coeffs\": [5.0e-2], \"true_exponents\": [2],\n            \"l_min\": 5, \"L\": 15, \"noise_std\": 1.0e-4,\n            \"fit_exponents\": [2], \"ext_fit_exponents\": [2, 4]\n        }\n    ]\n\n    # Fixed seed for reproducibility across the entire run.\n    rng = np.random.default_rng(20231105)\n    \n    results = []\n\n    for case in test_cases:\n        # Generate synthetic data for the current test case.\n        ell_modes = np.arange(case[\"l_min\"], case[\"L\"] + 1)\n        x_data = ell_modes + 0.5\n        \n        F_true = np.zeros_like(x_data, dtype=float)\n        for c, n in zip(case[\"true_coeffs\"], case[\"true_exponents\"]):\n            F_true += c * x_data**(-n)\n            \n        noise = rng.normal(scale=case[\"noise_std\"], size=len(ell_modes))\n        F_data = F_true + noise\n\n        # Perform fit for base model\n        T_hat, sigma_stat = _perform_fit_and_analysis_single(\n            F_data, ell_modes, case[\"L\"], case[\"fit_exponents\"]\n        )\n\n        # Perform fit for extended model\n        T_hat_ext, _ = _perform_fit_and_analysis_single(\n            F_data, ell_modes, case[\"L\"], case[\"ext_fit_exponents\"]\n        )\n\n        # Calculate truncation error proxy and combined uncertainty\n        delta_T = np.abs(T_hat_ext - T_hat)\n        sigma_comb = np.sqrt(sigma_stat**2 + delta_T**2)\n\n        results.extend([T_hat, sigma_comb])\n\n    # Print results in the specified format\n    print(f\"[{','.join(f'{val:.12e}' for val in results)}]\")\n\n\ndef _perform_fit_and_analysis_single(F_data, ell_modes, L, exponents):\n    \"\"\"\n    Performs a single tail fit and uncertainty analysis for a given model.\n\n    Args:\n        F_data: The array of mode values.\n        ell_modes: The array of l-modes corresponding to F_data.\n        L: The cutoff multipole.\n        exponents: The list of exponents defining the fit model.\n\n    Returns:\n        A tuple (T_hat, sigma_stat) containing the tail estimate and its\n        statistical uncertainty.\n    \"\"\"\n    x_data = ell_modes + 0.5\n    N = len(ell_modes)\n    m = len(exponents)\n\n    # Construct the design matrix A\n    A = np.array([x_data**(-n) for n in exponents]).T\n    \n    # Perform a linear least-squares fit\n    # np.linalg.lstsq is robust and can return the residual sum of squares\n    coeffs, rss_array, rank, s = np.linalg.lstsq(A, F_data, rcond=None)\n\n    # Estimate the tail sum using the Hurwitz zeta function\n    g = np.array([zeta(n, L + 1.5) for n in exponents])\n    T_hat = np.dot(coeffs, g)\n\n    # Calculate the statistical uncertainty\n    nu = N - m\n    \n    if nu > 0 and rss_array.size > 0:\n        rss = rss_array[0]\n        sigma_hat_sq = rss / nu\n    else:  #Handles underdetermined case (N <= m) or perfect fit\n        sigma_hat_sq = 0.0\n\n    # Covariance of coefficients: Cov(c) = sigma_hat^2 * (A^T A)^+\n    # np.linalg.pinv is used for the Moore-Penrose pseudoinverse as specified.\n    A_T_A_inv = np.linalg.pinv(A.T @ A)\n    cov_c = sigma_hat_sq * A_T_A_inv\n\n    # Variance of the tail estimate: Var(T_hat) = g^T Cov(c) g\n    var_T = g.T @ cov_c @ g\n    sigma_stat = np.sqrt(var_T)\n\n    return T_hat, sigma_stat\n\nsolve()\n```", "id": "3474036"}]}