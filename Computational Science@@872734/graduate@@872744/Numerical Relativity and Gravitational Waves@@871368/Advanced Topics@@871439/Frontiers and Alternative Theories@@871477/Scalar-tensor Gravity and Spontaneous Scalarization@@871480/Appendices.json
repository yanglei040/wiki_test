{"hands_on_practices": [{"introduction": "Solving Einstein's equations numerically requires a $3+1$ decomposition, which separates the equations into evolution equations and constraint equations that must always be satisfied. This exercise [@problem_id:3485631] explores how a scalar field contributes to the fundamental Hamiltonian and momentum constraints. It then delves into the practical methods used in modern numerical codes, like the CCZ4 formulation, to actively damp constraint violations and ensure a stable simulation.", "problem": "You are asked to connect fundamental definitions in the $3+1$ decomposition of General Relativity with a minimally coupled scalar field to the numerical behavior of constraint damping in the Conformal and Covariant formulation of the Z4 system (CCZ4). Your task has two parts: a derivation of constraint expressions including the scalar field, and a linear stability analysis of constraint propagation in a simplified CCZ4 model. Then you must implement a program that evaluates both the constraint residuals and predicts constraint damping (or growth) for a small test suite.\n\nPart A (derivation and discrete evaluation):\n- Start from the Einstein field equations in the $3+1$ decomposition and the stress-energy tensor of a minimally coupled scalar field in the Einstein frame. Use $G=c=1$ geometric units. Let the spacetime metric be decomposed using lapse $\\alpha$, shift $\\beta^{i}$, and spatial metric $\\gamma_{ij}$. The extrinsic curvature is $K_{ij}$ with trace $K \\equiv \\gamma^{ij} K_{ij}$.\n- The scalar field is $\\phi$ with canonical conjugate momentum $\\Pi \\equiv - n^{\\mu} \\nabla_{\\mu} \\phi$, where $n^{\\mu}$ is the unit normal to the spatial slices, and $D_{i}$ denotes the spatial covariant derivative compatible with $\\gamma_{ij}$. Assume a potential $V(\\phi)$.\n- Using only the definitions of the $3+1$ split and the scalar field stress-energy $T_{\\mu \\nu}$, derive the Hamiltonian constraint residual $H$ and the momentum constraint residual $M_{i}$ including the scalar-field contributions, expressed in terms of $\\gamma_{ij}$, $K_{ij}$, $\\phi$, $\\Pi$, and $V(\\phi)$. Do not assume any special symmetries during the derivation. Your derivation should identify the energy density $\\rho \\equiv n_{\\mu} n_{\\nu} T^{\\mu \\nu}$ and momentum density $j_{i} \\equiv - \\gamma_{i \\mu} n_{\\nu} T^{\\mu \\nu}$ of the scalar field and show how they enter the constraints.\n- For the numerical evaluation, specialize to a flat spatial metric $\\gamma_{ij}=\\delta_{ij}$, vanishing shift $\\beta^{i}=0$, unit lapse $\\alpha=1$, and vanishing extrinsic curvature $K_{ij}=0$. In this specialization the scalar field entirely sources the constraints. Use a periodic cubic domain of side length $L = 2\\pi$ in each direction with a uniform Cartesian grid. Use central finite differences with periodic boundary conditions to approximate $D_{i} \\phi$ as needed. Let the potential be $V(\\phi)=\\tfrac{1}{2} m^{2}\\phi^{2}$ and use $m=0$ for the test suite.\n\nPart B (linearized CCZ4 constraint-propagation model and stability test):\n- Consider the linearized, principal-part constraint-propagation subsystem for the Z4 variables $(\\Theta, Z_{i})$ around Minkowski spacetime, augmented by CCZ4 damping parameters $\\kappa_{1}$, $\\kappa_{2}$, $\\kappa_{3}$. In Fourier space with spatial wavenumber vector $k_{i}$ and magnitude $|k|$, restrict to the coupled longitudinal sector spanned by $(\\Theta, Z_{\\parallel})$, where $Z_{\\parallel} \\equiv \\hat{k}^{i} Z_{i}$ and $\\hat{k}^{i} \\equiv k^{i}/|k|$.\n- Using the defining structure of the Z4 constraint subsystem and the CCZ4 damping terms, construct the homogeneous linear ordinary differential equation system for $(\\Theta, Z_{\\parallel})$ that is consistent with a damped-wave principal part: the time derivative of $\\Theta$ includes a divergence of $Z_{i}$ and a damping proportional to $\\kappa_{1}(2+\\kappa_{2})$, and the time derivative of $Z_{i}$ includes the gradient of $\\Theta$ and a damping proportional to $\\kappa_{1}$; allow the coefficient multiplying the divergence in the $\\Theta$ equation to be $\\kappa_{3}$.\n- Show that the resulting $2\\times 2$ linear operator for the homogeneous Fourier mode with magnitude $|k|$ has the form of a constant-coefficient matrix whose eigenvalues can be written explicitly in terms of $\\kappa_{1}$, $\\kappa_{2}$, $\\kappa_{3}$, and $|k|$. Define the spectral abscissa as the largest real part among these eigenvalues. The stability test shall declare a case as damped if and only if the spectral abscissa is strictly negative.\n\nNumerical design requirements:\n- Implement a program that:\n  1. Builds the specified periodic grid on $[0,2\\pi]^3$ with $N=32$ points per dimension.\n  2. For each test case below, constructs $\\phi$ and $\\Pi$ fields on the grid using trigonometric functions with specified amplitudes and wavenumbers, computes $H$ and $M_{i}$ residuals specialized as instructed, and reports the root-mean-square (discrete $L^{2}$) norms: $||H||_{2} \\equiv \\sqrt{\\langle H^{2} \\rangle}$ and $||M||_{2} \\equiv \\sqrt{\\langle M_{i} M^{i} \\rangle}$, where $\\langle \\cdot \\rangle$ denotes the average over the grid, and indices on $M_{i}$ are raised with $\\delta^{ij}$.\n  3. For each test case, constructs the homogeneous longitudinal $(\\Theta, Z_{\\parallel})$ linear operator from Part B using the given $\\kappa_{1}$, $\\kappa_{2}$, $\\kappa_{3}$ and $|k|$ (the magnitude of the wavenumber vector used to build the fields), computes its eigenvalues, and evaluates the spectral abscissa to decide stability.\n- All reported quantities are dimensionless in geometric units with $G=c=1$.\n\nTest suite:\n- Use $N=32$, $L=2\\pi$, $m=0$. Define the scalar field and momentum by\n  - $\\phi(\\mathbf{x}) = A \\sin(k_{x} x + k_{y} y + k_{z} z)$,\n  - $\\Pi(\\mathbf{x}) = B \\sin(k_{x} x + k_{y} y + k_{z} z)$,\n  with amplitudes $A$ and $B$ and integer wavenumbers $(k_{x}, k_{y}, k_{z})$ given per case.\n- Provide three cases that cover a typical well-damped configuration, a boundary configuration with no damping, and a high-wavenumber configuration with a destabilizing choice of $\\kappa_{3}$:\n  1. Case $1$: $A=10^{-3}$, $B=0$, $(k_{x},k_{y},k_{z})=(1,0,0)$, $\\kappa_{1}=0.1$, $\\kappa_{2}=0$, $\\kappa_{3}=1$.\n  2. Case $2$: $A=0$, $B=10^{-3}$, $(k_{x},k_{y},k_{z})=(1,0,0)$, $\\kappa_{1}=0$, $\\kappa_{2}=0$, $\\kappa_{3}=1$.\n  3. Case $3$: $A=10^{-3}$, $B=10^{-3}$, $(k_{x},k_{y},k_{z})=(10,0,0)$, $\\kappa_{1}=0.02$, $\\kappa_{2}=0$, $\\kappa_{3}=-1$.\n- Angle arguments for the trigonometric functions are in radians. The wavenumber magnitude is $|k| = \\sqrt{k_{x}^{2} + k_{y}^{2} + k_{z}^{2}}$.\n\nFinal output specification:\n- For each test case, your program must produce a list with four entries:\n  - a boolean indicating whether the spectral abscissa is strictly negative (damped),\n  - the spectral abscissa as a float,\n  - the $L^{2}$ norm of $H$ as a float,\n  - the $L^{2}$ norm of $M$ as a float.\n- Your program should produce a single line of output containing the results as a comma-separated list of these per-case lists, enclosed in square brackets. For example, a valid output shape is\n  - $\\left[ [\\text{boolean}, \\text{float}, \\text{float}, \\text{float}], [\\dots], [\\dots] \\right]$,\n  and all floats must be rounded to exactly $6$ decimals in the printed output.", "solution": "The user-provided problem is assessed to be valid. It is scientifically grounded in the principles of general relativity and numerical analysis, is well-posed with a clear objective, and contains sufficient information for a unique solution.\n\n### Part A: Derivation and Evaluation of Constraint Residuals\n\nThe $3+1$ decomposition of Einstein's field equations, $G_{\\mu\\nu} = 8\\pi T_{\\mu\\nu}$ (in geometric units $G=c=1$), yields the Hamiltonian and momentum constraint equations on each spatial slice. These equations relate the intrinsic geometry of the slice (3-metric $\\gamma_{ij}$ and its Ricci scalar $R$), its extrinsic curvature ($K_{ij}$), and the matter content projected onto the slice. The constraint residuals, which must vanish for an exact solution, are:\n$$\nH \\equiv R + K^2 - K_{ij}K^{ij} - 16\\pi \\rho = 0\n$$\n$$\nM_i \\equiv D_j(K^j_i - \\delta^j_i K) - 8\\pi j_i = 0\n$$\nHere, $K \\equiv \\gamma^{ij}K_{ij}$ is the trace of the extrinsic curvature, and $D_i$ is the covariant derivative compatible with $\\gamma_{ij}$. The matter terms $\\rho$ and $j_i$ are the energy density and momentum density as measured by an observer moving orthogonal to the spatial slices. They are defined by projections of the stress-energy tensor $T^{\\mu\\nu}$ using the future-directed unit normal vector $n^{\\mu}$:\n$$\n\\rho \\equiv n_{\\mu} n_{\\nu} T^{\\mu \\nu}\n$$\n$$\nj_{i} \\equiv - \\gamma_{i \\mu} n_{\\nu} T^{\\mu \\nu}\n$$\nwhere $\\gamma_{i\\mu}$ is the projection tensor $\\gamma_{\\mu\\nu}$ with one spatial index.\n\nFor a minimally coupled scalar field $\\phi$ with potential $V(\\phi)$, the stress-energy tensor is given by:\n$$\nT_{\\mu \\nu} = \\nabla_{\\mu}\\phi \\nabla_{\\nu}\\phi - \\frac{1}{2} g_{\\mu \\nu} (\\nabla^{\\alpha}\\phi \\nabla_{\\alpha}\\phi + 2 V(\\phi))\n$$\nIn the $3+1$ formalism, the gradient of the scalar field is decomposed into its normal and spatial parts. The canonical momentum of the field is $\\Pi \\equiv -n^{\\mu}\\nabla_{\\mu}\\phi$. The spatial projection of the gradient is $D_i \\phi$. The full spacetime contraction of the gradient becomes $\\nabla^{\\alpha}\\phi \\nabla_{\\alpha}\\phi = -\\Pi^2 + D_i\\phi D^i\\phi$.\n\nWe can now compute $\\rho$ and $j_i$:\n$$\n\\rho = n_{\\mu}n_{\\nu}T^{\\mu\\nu} = n_{\\mu}n_{\\nu} \\left( \\nabla^{\\mu}\\phi \\nabla^{\\nu}\\phi - \\frac{1}{2} g^{\\mu\\nu} (\\dots) \\right) = (n_{\\mu}\\nabla^{\\mu}\\phi)^2 - \\frac{1}{2}(n_{\\mu}n_{\\nu}g^{\\mu\\nu})(-\\Pi^2 + D_k\\phi D^k\\phi + 2V)\n$$\nUsing $n_{\\mu}n^{\\mu} = -1$ and thus $n_{\\mu}n_{\\nu}g^{\\mu\\nu} = -1$, this simplifies to:\n$$\n\\rho = (-\\Pi)^2 - \\frac{1}{2}(-1)(-\\Pi^2 + D_k\\phi D^k\\phi + 2V(\\phi)) = \\frac{1}{2}\\Pi^2 + \\frac{1}{2}D_k\\phi D^k\\phi + V(\\phi)\n$$\nFor the momentum density:\n$$\nj_i = -\\gamma_{i\\mu}n_{\\nu}T^{\\mu\\nu} = -\\gamma_{i\\mu}n_{\\nu} \\left( \\nabla^{\\mu}\\phi \\nabla^{\\nu}\\phi - \\frac{1}{2}g^{\\mu\\nu}(\\dots) \\right) = -( \\gamma_{i\\mu}\\nabla^{\\mu}\\phi ) ( n_{\\nu}\\nabla^{\\nu}\\phi ) = -(D_i\\phi)(-\\Pi)\n$$\nThus, the momentum density is:\n$$\nj_i = \\Pi D_i\\phi\n$$\nSubstituting these expressions for $\\rho$ and $j_i$ into the constraint residuals yields:\n$$\nH = R + K^2 - K_{ij}K^{ij} - 16\\pi \\left( \\frac{1}{2}\\Pi^2 + \\frac{1}{2}D_k\\phi D^k\\phi + V(\\phi) \\right) = R + K^2 - K_{ij}K^{ij} - 8\\pi (\\Pi^2 + D_k\\phi D^k\\phi + 2V(\\phi))\n$$\n$$\nM_i = D_j(K^j_i - \\delta^j_i K) - 8\\pi \\Pi D_i\\phi\n$$\nFor the numerical evaluation, we specialize to a flat background with $\\gamma_{ij}=\\delta_{ij}$, $K_{ij}=0$, and potential $V(\\phi)=\\frac{1}{2}m^2\\phi^2$ with $m=0$. In this case, $R=0$, $K=0$, and $V(\\phi)=0$. The covariant derivative $D_i$ becomes the partial derivative $\\partial_i$. The constraint residuals simplify to:\n$$\nH = -8\\pi (\\Pi^2 + \\partial_k\\phi \\partial^k\\phi)\n$$\n$$\nM_i = -8\\pi \\Pi \\partial_i\\phi\n$$\nThese expressions are evaluated on a uniform Cartesian grid using second-order central finite differences for the partial derivatives with periodic boundary conditions.\n\n### Part B: Linearized CCZ4 Constraint-Propagation Analysis\n\nThe Conformal and Covariant Z4 (CCZ4) formulation introduces variables $\\Theta$ and $Z_i$ that are proportional to the Hamiltonian and momentum constraint violations, respectively. Their evolution equations include damping terms, controlled by parameters $\\kappa_1$ and $\\kappa_2$, designed to drive constraints to zero. The parameter $\\kappa_3$ affects the propagation speed of constraint violations.\n\nWe analyze the linearized constraint subsystem around Minkowski spacetime. In Fourier space, a mode with wavevector $k_i$ evolves according to a system of ordinary differential equations. The problem specifies the structure of the equations for the Fourier amplitudes $(\\hat{\\Theta}, \\hat{Z}_i)$:\n$$\n\\partial_t \\hat{\\Theta} = \\kappa_3 (i k_j \\hat{Z}^j) - \\kappa_1(2+\\kappa_2) \\hat{\\Theta}\n$$\n$$\n\\partial_t \\hat{Z}_i = i k_i \\hat{\\Theta} - \\kappa_1 \\hat{Z}_i\n$$\nWe project onto the longitudinal sector, defined by the direction of the wavevector $\\hat{k}^i = k^i/|k|$. Let $\\hat{Z}_{\\parallel} \\equiv \\hat{k}^j \\hat{Z}_j$. Noting that $k_j\\hat{Z}^j = |k|\\hat{Z}_\\parallel$ and $\\hat{k}^i(i k_i \\hat{\\Theta}) = i|k|\\hat{\\Theta}$, the system couples only $\\hat{\\Theta}$ and $\\hat{Z}_\\parallel$:\n$$\n\\partial_t \\hat{\\Theta} = i \\kappa_3 |k| \\hat{Z}_{\\parallel} - \\kappa_1(2+\\kappa_2) \\hat{\\Theta}\n$$\n$$\n\\partial_t \\hat{Z}_\\parallel = i |k| \\hat{\\Theta} - \\kappa_1 \\hat{Z}_\\parallel\n$$\nThis is a homogeneous linear system $\\frac{d\\mathbf{v}}{dt} = \\mathbf{M}\\mathbf{v}$ for the vector $\\mathbf{v} = (\\hat{\\Theta}, \\hat{Z}_\\parallel)^T$, with the matrix $\\mathbf{M}$:\n$$\n\\mathbf{M} = \\begin{pmatrix} -\\kappa_1(2+\\kappa_2)  i \\kappa_3 |k| \\\\ i |k|  -\\kappa_1 \\end{pmatrix}\n$$\nThe stability of the system is determined by the eigenvalues $\\lambda$ of $\\mathbf{M}$, found by solving the characteristic equation $\\det(\\mathbf{M}-\\lambda\\mathbf{I})=0$:\n$$\n(-\\kappa_1(2+\\kappa_2) - \\lambda)(-\\kappa_1 - \\lambda) - (i \\kappa_3 |k|)(i |k|) = 0\n$$\n$$\n\\lambda^2 + \\kappa_1(3+\\kappa_2)\\lambda + (\\kappa_1^2(2+\\kappa_2) + \\kappa_3 |k|^2) = 0\n$$\nThis is a quadratic equation whose solutions are:\n$$\n\\lambda = \\frac{-\\kappa_1(3+\\kappa_2) \\pm \\sqrt{(\\kappa_1(3+\\kappa_2))^2 - 4(\\kappa_1^2(2+\\kappa_2) + \\kappa_3 |k|^2)}}{2}\n$$\nThe discriminant simplifies to $\\Delta = \\kappa_1^2(1+\\kappa_2)^2 - 4\\kappa_3 |k|^2$. The spectral abscissa, $\\sigma \\equiv \\max(\\Re(\\lambda))$, determines stability. A strictly negative spectral abscissa ($\\sigma  0$) indicates that all constraint modes are damped.\nIf $\\Delta \\ge 0$, the eigenvalues are real, and the spectral abscissa is $\\sigma = \\frac{1}{2} \\left( -\\kappa_1(3+\\kappa_2) + \\sqrt{\\Delta} \\right)$.\nIf $\\Delta  0$, the eigenvalues are a complex conjugate pair, and the spectral abscissa is $\\sigma = \\frac{1}{2} \\left( -\\kappa_1(3+\\kappa_2) \\right)$.\n\n### Numerical Design\n\nThe implementation calculates the required quantities for each test case.\n1. A 3D Cartesian grid of size $N \\times N \\times N$ with $N=32$ is defined over the domain $[0, 2\\pi]^3$.\n2. The scalar field $\\phi$ and its momentum $\\Pi$ are constructed on this grid according to the specified trigonometric functions.\n3. The spatial derivatives $\\partial_i\\phi$ are computed using a second-order periodic central finite difference stencil, implemented efficiently using `numpy.roll`.\n4. The Hamiltonian residual $H$ and momentum residual vector components $M_i$ are calculated at each grid point using the specialized formulas from Part A.\n5. The discrete $L^2$-norms, $||H||_{2} = \\sqrt{\\langle H^{2} \\rangle}$ and $||M||_{2} = \\sqrt{\\langle M_{i} M^{i} \\rangle}$, are computed by averaging over all grid points.\n6. For Part B, the spectral abscissa is calculated using the derived formula, given the parameters $\\kappa_1, \\kappa_2, \\kappa_3$ and the wavenumber magnitude $|k|$ for each case. The stability is determined by testing if the spectral abscissa is strictly negative.\nThe results for each case are collected and formatted into the required output string.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by evaluating constraint residuals for a scalar field\n    and analyzing the stability of a simplified CCZ4 constraint damping system.\n    \"\"\"\n    \n    # Test cases from the problem statement\n    test_cases = [\n        {'A': 1e-3, 'B': 0, 'k_vec': (1,0,0), 'kappa1': 0.1, 'kappa2': 0, 'kappa3': 1},\n        {'A': 0, 'B': 1e-3, 'k_vec': (1,0,0), 'kappa1': 0, 'kappa2': 0, 'kappa3': 1},\n        {'A': 1e-3, 'B': 1e-3, 'k_vec': (10,0,0), 'kappa1': 0.02, 'kappa2': 0, 'kappa3': -1},\n    ]\n\n    # Grid parameters\n    N = 32\n    L = 2.0 * np.pi\n    h = L / N\n\n    # Grid coordinates\n    x_1d = np.linspace(0, L, N, endpoint=False)\n    y_1d = np.linspace(0, L, N, endpoint=False)\n    z_1d = np.linspace(0, L, N, endpoint=False)\n    xx, yy, zz = np.meshgrid(x_1d, y_1d, z_1d, indexing='ij')\n\n    all_results = []\n\n    for case in test_cases:\n        A = case['A']\n        B = case['B']\n        kx, ky, kz = case['k_vec']\n        kappa1 = case['kappa1']\n        kappa2 = case['kappa2']\n        kappa3 = case['kappa3']\n        k_mag = np.sqrt(kx**2 + ky**2 + kz**2)\n\n        # Part A: Constraint Residual Calculation\n        \n        # Define scalar field and its momentum on the grid\n        theta = kx * xx + ky * yy + kz * zz\n        phi = A * np.sin(theta)\n        Pi = B * np.sin(theta)\n\n        # Compute spatial derivatives using 2nd-order central finite differences\n        # with periodic boundary conditions (using np.roll).\n        dphi_dx = (np.roll(phi, -1, axis=0) - np.roll(phi, 1, axis=0)) / (2.0 * h)\n        dphi_dy = (np.roll(phi, -1, axis=1) - np.roll(phi, 1, axis=1)) / (2.0 * h)\n        dphi_dz = (np.roll(phi, -1, axis=2) - np.roll(phi, 1, axis=2)) / (2.0 * h)\n        \n        # Calculate constraint residuals H and M_i\n        H = -8.0 * np.pi * (Pi**2 + dphi_dx**2 + dphi_dy**2 + dphi_dz**2)\n        Mx = -8.0 * np.pi * Pi * dphi_dx\n        My = -8.0 * np.pi * Pi * dphi_dy\n        Mz = -8.0 * np.pi * Pi * dphi_dz\n\n        # Calculate L2 norms of the residuals\n        H_norm = np.sqrt(np.mean(H**2))\n        M_norm = np.sqrt(np.mean(Mx**2 + My**2 + Mz**2))\n\n        # Part B: Stability Analysis\n\n        # Calculate the discriminant of the characteristic equation\n        Delta = (kappa1 * (1.0 + kappa2))**2 - 4.0 * kappa3 * k_mag**2\n\n        if Delta >= 0:\n            spec_abs = (-kappa1 * (3.0 + kappa2) + np.sqrt(Delta)) / 2.0\n        else:\n            spec_abs = -kappa1 * (3.0 + kappa2) / 2.0\n        \n        is_damped = spec_abs  0.0\n\n        all_results.append([is_damped, spec_abs, H_norm, M_norm])\n\n    # Format the final output string\n    result_strings = []\n    for res in all_results:\n        # Format boolean and floats to 6 decimal places\n        bool_str = str(res[0])\n        float_strs = [f\"{x:.6f}\" for x in res[1:]]\n        result_strings.append(f\"[{bool_str},{','.join(float_strs)}]\")\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3485631"}, {"introduction": "Numerical simulations produce results that are inherently approximate, with errors that depend on the chosen grid resolution. A critical task is to estimate this numerical error and, if possible, extrapolate to the continuum limit of infinite resolution. This practice [@problem_id:3485638] introduces Richardson extrapolation as a powerful, standard technique to estimate the true value of a physical observable and provides a robust method for quantifying the numerical uncertainty of a simulation.", "problem": "You are given synthetic discrete-resolution data for the gravitational-wave phase and for the scalar radiation energy flux in a scalar-tensor theory with spontaneous scalarization. Assume the following foundational principles as the starting point for all derivations and computations: (i) the discretization error model for a numerically computed scalar quantity $u(h)$ at grid spacing $h$ is $u(h)=u_{0}+C h^{p}+\\mathcal{O}(h^{p+\\delta})$ with unknown constants $u_{0}$, $C$, and order $p0$, (ii) the post-Newtonian expansion of the scalar flux admits a truncated model of the form $F_{\\mathrm{inc}}(v)=a_{\\mathrm{s}} v^{6}$ (dipolar scalar flux), while higher-order scalar contributions at power $v^{q}$ are neglected in this model and appear as $c_{\\mathrm{miss}} v^{q}$, with unknown coefficient $c_{\\mathrm{miss}}$, and (iii) all quantities are reported in dimensionless units. Your tasks are to perform a consistent Richardson extrapolation for the gravitational-wave phase and the scalar flux to estimate the continuum values and the numerical uncertainties, and then to disentangle these numerical uncertainties from modeling errors associated with the neglected higher-order scalar post-Newtonian term by estimating $c_{\\mathrm{miss}}$ and its induced bias at the given orbital velocity.\n\nFor each test case, you are provided with three grid spacings $h_{1}h_{2}h_{3}$ in a constant ratio $r=h_{2}/h_{1}=h_{3}/h_{2}$, the measured gravitational-wave phase values $\\phi(h_{1}),\\phi(h_{2}),\\phi(h_{3})$, the measured scalar flux values $F(h_{1}),F(h_{2}),F(h_{3})$, the orbital velocity $v$, the included dipolar scalar flux coefficient $a_{\\mathrm{s}}$, and the neglected scalar post-Newtonian power $q$. From these data, you must:\n- Infer the observed convergence order $p$ separately for $\\phi$ and $F$ using three-resolution information and the error model.\n- Perform a two-level Richardson extrapolation to estimate the continuum values $\\phi_{R}$ and $F_{R}$ at $h\\to 0$.\n- Quantify the purely numerical uncertainty for each quantity as the magnitude of the leading truncation term inferred from the two finest runs.\n- For the scalar flux only, compute the included-model value $F_{\\mathrm{inc}}(v)=a_{\\mathrm{s}} v^{6}$, estimate the missing-coefficient $c_{\\mathrm{miss}}$ from the relation $F_{R}=F_{\\mathrm{inc}}(v)+c_{\\mathrm{miss}} v^{q}$, and report the induced modeling bias at the given $v$ as $|c_{\\mathrm{miss}}| v^{q}$.\n\nExpress all answers as dimensionless numbers. Angles are to be treated as dimensionless phases in radians but must be reported without units.\n\nTest suite:\n- Case A:\n  - Grid spacings: $h_{1}=0.1$, $h_{2}=0.2$, $h_{3}=0.4$.\n  - Gravitational-wave phase data: $\\phi(h_{1})=123.4568$, $\\phi(h_{2})=123.4624$, $\\phi(h_{3})=123.5072$.\n  - Scalar flux data: $F(h_{1})=0.00003407962$, $F(h_{2})=0.000034226885$, $F(h_{3})=0.00003505993$.\n  - Orbital velocity: $v=0.2$.\n  - Included scalar coefficient: $a_{\\mathrm{s}}=0.5$.\n  - Neglected scalar power: $q=8$.\n- Case B:\n  - Grid spacings: $h_{1}=0.06$, $h_{2}=0.09$, $h_{3}=0.135$.\n  - Gravitational-wave phase data: $\\phi(h_{1})=50.00061452$, $\\phi(h_{2})=50.00150174$, $\\phi(h_{3})=50.003663$.\n  - Scalar flux data: $F(h_{1})=0.000093088$, $F(h_{2})=0.0000931105$, $F(h_{3})=0.000093161125$.\n  - Orbital velocity: $v=0.25$.\n  - Included scalar coefficient: $a_{\\mathrm{s}}=0.6$.\n  - Neglected scalar power: $q=8$.\n- Case C:\n  - Grid spacings: $h_{1}=0.025$, $h_{2}=0.05$, $h_{3}=0.1$.\n  - Gravitational-wave phase data: $\\phi(h_{1})=10.00000001953125$, $\\phi(h_{2})=10.0000003125$, $\\phi(h_{3})=10.000005$.\n  - Scalar flux data: $F(h_{1})=0.001557734097125$, $F(h_{2})=0.001557734119$, $F(h_{3})=0.001557734294$.\n  - Orbital velocity: $v=0.35$.\n  - Included scalar coefficient: $a_{\\mathrm{s}}=0.7$.\n  - Neglected scalar power: $q=8$.\n\nYour program must compute, for each case, the following list of outputs in this exact order:\n- $\\phi_{R}$,\n- $\\sigma_{\\phi,\\mathrm{num}}$,\n- $p_{\\phi}$,\n- $F_{R}$,\n- $\\sigma_{F,\\mathrm{num}}$,\n- $p_{F}$,\n- $c_{\\mathrm{miss}}$,\n- $|c_{\\mathrm{miss}}| v^{q}$.\n\nReport the final result as a single line containing a list of three sublists, one per case, with each sublist containing the eight numbers above in the stated order. For example, your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each case contributes its own inner list in order A, B, C, like $[[\\cdots],[\\cdots],[\\cdots]]$.", "solution": "The problem statement has been validated and is deemed sound. It is scientifically grounded, well-posed, and objective. It provides a complete and consistent set of data and formal models to perform the required calculations. We may therefore proceed with the solution.\n\nThe problem requires a systematic error analysis of synthetic numerical data for two quantities: the gravitational-wave phase $\\phi$ and the scalar radiation energy flux $F$. The analysis involves inferring the numerical convergence order, extrapolating to the continuum limit ($h \\to 0$), estimating the numerical uncertainty, and disentangling this from the modeling uncertainty in the scalar flux. Let $u(h)$ represent a generic quantity, which can be either $\\phi(h)$ or $F(h)$, measured at three grid resolutions $h_1  h_2  h_3$ related by a constant factor $r = h_2/h_1 = h_3/h_2$.\n\nThe foundational assumption is the discretization error model for a numerically computed quantity $u(h)$:\n$$u(h) = u_0 + C h^p + \\mathcal{O}(h^{p+\\delta})$$\nwhere $u_0$ is the exact continuum value ($h \\to 0$), $C$ is an unknown constant, $p  0$ is the convergence order of the numerical method, and $\\delta  0$. We neglect the higher-order terms $\\mathcal{O}(h^{p+\\delta})$ and work with the model $u(h) \\approx u_0 + C h^p$.\n\nLet the three measurements be $u_1 = u(h_1)$, $u_2 = u(h_2)$, and $u_3 = u(h_3)$. From the model, we have the system of equations:\n$$u_1 \\approx u_0 + C h_1^p$$\n$$u_2 \\approx u_0 + C h_2^p = u_0 + C (r h_1)^p = u_0 + C h_1^p r^p$$\n$$u_3 \\approx u_0 + C h_3^p = u_0 + C (r^2 h_1)^p = u_0 + C h_1^p r^{2p}$$\n\n**1. Inference of the Convergence Order ($p_{\\phi}$, $p_{F}$)**\nTo determine the convergence order $p$, we analyze the differences between measurements at successive resolutions.\nThe difference between $u_2$ and $u_1$ is:\n$$u_2 - u_1 \\approx (u_0 + C h_1^p r^p) - (u_0 + C h_1^p) = C h_1^p (r^p - 1)$$\nThe difference between $u_3$ and $u_2$ is:\n$$u_3 - u_2 \\approx (u_0 + C h_1^p r^{2p}) - (u_0 + C h_1^p r^p) = C h_1^p r^p (r^p - 1)$$\nTaking the ratio of these differences eliminates the unknown constant $C$ and the grid spacing $h_1$:\n$$\\frac{u_3 - u_2}{u_2 - u_1} \\approx \\frac{C h_1^p r^p (r^p - 1)}{C h_1^p (r^p - 1)} = r^p$$\nSolving for $p$, we obtain the formula for the observed convergence order:\n$$p = \\frac{\\ln\\left(\\frac{u_3 - u_2}{u_2 - u_1}\\right)}{\\ln(r)}$$\nThis formula is applied separately to the datasets for $\\phi$ and $F$ to find $p_{\\phi}$ and $p_{F}$, respectively.\n\n**2. Richardson Extrapolation ($\\phi_{R}$, $F_{R}$)**\nRichardson extrapolation is a method to obtain a more accurate estimate of the continuum value $u_0$ by canceling the leading-order error term. Using the two finest resolution data points, $u_1$ and $u_2$, and the previously determined convergence order $p$, we can solve for $u_0$. Let us denote the extrapolated value as $u_R$.\nFrom the two equations for $u_1$ and $u_2$:\n$$u_1 \\approx u_0 + C h_1^p$$\n$$u_2 \\approx u_0 + C h_1^p r^p$$\nWe can eliminate the error term coefficient $C h_1^p$. From the first equation, $C h_1^p \\approx u_1 - u_0$. Substituting this into the second equation gives:\n$$u_2 \\approx u_0 + (u_1 - u_0) r^p$$\nSolving for $u_0$ yields the Richardson-extrapolated value $u_R$:\n$$u_R = u_0 \\approx \\frac{u_1 r^p - u_2}{r^p - 1}$$\nThis formula is used to compute the continuum estimates $\\phi_R$ and $F_R$.\n\n**3. Numerical Uncertainty ($\\sigma_{\\phi,\\mathrm{num}}$, $\\sigma_{F,\\mathrm{num}}$)**\nThe problem defines the numerical uncertainty as the magnitude of the leading truncation error term, inferred from the two finest runs. This corresponds to the error in the finest-resolution measurement, $u_1$. The error term is $E_1 = u_1 - u_0 \\approx C h_1^p$. We can estimate this quantity using our two-level system.\nFrom the derivation of the Richardson extrapolated value, we see that:\n$$u_R = \\frac{u_1 r^p - u_2}{r^p - 1} = \\frac{u_1(r^p - 1) - (u_2 - u_1)}{r^p-1} = u_1 - \\frac{u_2 - u_1}{r^p - 1}$$\nRearranging this equation gives:\n$$u_1 - u_R = \\frac{u_2 - u_1}{r^p - 1}$$\nThe left side, $u_1 - u_R$, is the difference between the finest-resolution data and the (more accurate) extrapolated value. This serves as an excellent estimate for the error $E_1=u_1-u_0$. The numerical uncertainty $\\sigma_{u,\\mathrm{num}}$ is the magnitude of this error estimate:\n$$\\sigma_{u,\\mathrm{num}} = |u_1 - u_R| = \\left| \\frac{u_2 - u_1}{r^p - 1} \\right| = \\left| \\frac{u_1 - u_2}{r^p - 1} \\right|$$\nThis is applied to find $\\sigma_{\\phi,\\mathrm{num}}$ and $\\sigma_{F,\\mathrm{num}}$.\n\n**4. Scalar Flux Model Analysis ($c_{\\mathrm{miss}}$, Modeling Bias)**\nThe final part of the problem involves analyzing the extrapolated scalar flux $F_R$ in the context of a theoretical post-Newtonian model.\nThe continuum flux $F_R$ is assumed to be the sum of an included model term, $F_{\\mathrm{inc}}(v)$, and a neglected higher-order term, $F_{\\mathrm{miss}}(v)$:\n$$F_R = F_{\\mathrm{inc}}(v) + F_{\\mathrm{miss}}(v)$$\nThe problem specifies the forms of these terms:\n$$F_{\\mathrm{inc}}(v) = a_{\\mathrm{s}} v^6$$\n$$F_{\\mathrm{miss}}(v) = c_{\\mathrm{miss}} v^q$$\nHere, $a_s$ is the given coefficient for the leading-order (dipolar) scalar flux, $v$ is the orbital velocity, $q$ is the power of the neglected term, and $c_{\\mathrm{miss}}$ is the unknown coefficient of this term.\n\nFirst, we compute the included term $F_{\\mathrm{inc}}(v)$ using the provided values of $a_s$ and $v$.\nNext, we estimate the missing coefficient $c_{\\mathrm{miss}}$ by rearranging the main relation:\n$$c_{\\mathrm{miss}} = \\frac{F_R - F_{\\mathrm{inc}}(v)}{v^q}$$\nFinally, the modeling bias is defined as the magnitude of the neglected term at the given velocity $v$. This quantity represents the systematic error introduced by truncating the theoretical model.\n$$\\text{Modeling Bias} = |F_{\\mathrm{miss}}(v)| = |c_{\\mathrm{miss}} v^q| = |F_R - F_{\\mathrm{inc}}(v)|$$\n\nThese formulas provide a complete algorithm to compute the eight required quantities for each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A\n        {\n            \"h_vals\": (0.1, 0.2, 0.4),\n            \"phi_vals\": (123.4568, 123.4624, 123.5072),\n            \"F_vals\": (0.00003407962, 0.000034226885, 0.00003505993),\n            \"v\": 0.2,\n            \"a_s\": 0.5,\n            \"q\": 8\n        },\n        # Case B\n        {\n            \"h_vals\": (0.06, 0.09, 0.135),\n            \"phi_vals\": (50.00061452, 50.00150174, 50.003663),\n            \"F_vals\": (0.000093088, 0.0000931105, 0.000093161125),\n            \"v\": 0.25,\n            \"a_s\": 0.6,\n            \"q\": 8\n        },\n        # Case C\n        {\n            \"h_vals\": (0.025, 0.05, 0.1),\n            \"phi_vals\": (10.00000001953125, 10.0000003125, 10.000005),\n            \"F_vals\": (0.001557734097125, 0.001557734119, 0.001557734294),\n            \"v\": 0.35,\n            \"a_s\": 0.7,\n            \"q\": 8\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        results.append(process_case(case))\n\n    # Format the final output string as a list of lists.\n    # Ex: [[item1,item2],[item3,item4]]\n    outer_parts = []\n    for res_list in results:\n        inner_parts = [str(x) for x in res_list]\n        outer_parts.append(f\"[{','.join(inner_parts)}]\")\n    final_output_str = f\"[{','.join(outer_parts)}]\"\n\n    print(final_output_str)\n\n\ndef process_case(case_data):\n    \"\"\"\n    Processes a single test case to compute all required output values.\n    \n    Args:\n        case_data (dict): A dictionary containing all input parameters for a case.\n    \n    Returns:\n        list: A list of the 8 computed results in the specified order.\n    \"\"\"\n    \n    def analyze_quantity(h_vals, u_vals):\n        \"\"\"Helper to perform Richardson analysis on a generic quantity u.\"\"\"\n        h1, h2, h3 = h_vals\n        u1, u2, u3 = u_vals\n        \n        # Grid spacing ratio\n        r = h2 / h1\n        \n        # Convergence order p\n        # Note: If u2-u1 is zero, this would cause a division by zero.\n        # The test data is constructed to avoid this.\n        diff_ratio = (u3 - u2) / (u2 - u1)\n        p = np.log(diff_ratio) / np.log(r)\n        \n        # Richardson extrapolation\n        rp = r**p\n        u_R = (u1 * rp - u2) / (rp - 1)\n        \n        # Numerical uncertainty\n        sigma_num = np.abs((u1 - u2) / (rp - 1))\n        \n        return u_R, sigma_num, p\n\n    # Unpack data for the current case\n    h_vals = case_data[\"h_vals\"]\n    phi_vals = case_data[\"phi_vals\"]\n    F_vals = case_data[\"F_vals\"]\n    v = case_data[\"v\"]\n    a_s = case_data[\"a_s\"]\n    q = case_data[\"q\"]\n\n    # Analyze gravitational-wave phase (phi)\n    phi_R, sigma_phi_num, p_phi = analyze_quantity(h_vals, phi_vals)\n\n    # Analyze scalar flux (F)\n    F_R, sigma_F_num, p_F = analyze_quantity(h_vals, F_vals)\n    \n    # Analyze scalar flux model\n    F_inc = a_s * v**6\n    c_miss = (F_R - F_inc) / (v**q)\n    modeling_bias = np.abs(F_R - F_inc)\n\n    return [\n        phi_R,\n        sigma_phi_num,\n        p_phi,\n        F_R,\n        sigma_F_num,\n        p_F,\n        c_miss,\n        modeling_bias,\n    ]\n\n# Execute the main function\nsolve()\n```", "id": "3485638"}, {"introduction": "In scalar-tensor gravity, compact objects like neutron stars can carry a 'scalar charge,' a physical property with no analog in General Relativity. This scalar charge sources a long-range scalar field, and measuring it is a key goal for testing these theories. This exercise [@problem_id:3485574] demonstrates how to extract this fundamental physical parameter and its uncertainty from the raw data of a numerical simulation by fitting the field's asymptotic profile.", "problem": "You are given discrete exterior samples of a massless scalar field in scalar-tensor gravity outside a compact object, obtained from numerical integrations of the vacuum equations. In the far field, the scalar field behaves as a spherical outgoing solution whose leading multipole is the monopole, so the asymptotic field at radii $r$ outside the source has the form $\\varphi(r) = \\varphi_{\\infty} + Q/r + \\mathcal{O}(1/r^2)$, where $\\varphi_{\\infty}$ is the cosmological asymptote and $Q$ is the effective scalar monopole. In geometrized units where $G=c=1$, the dimensionless scalar charge of the object is $\\alpha_A = Q/m_A$, where $m_A$ is the gravitational mass of the object. You receive a finite set of samples $\\{(r_i, \\varphi_i, \\sigma_i)\\}_{i=1}^N$, where each $r_i$ is a radius, each $\\varphi_i$ is a numerically computed scalar field value at $r_i$, and each $\\sigma_i$ is an estimated one-sigma uncertainty for $\\varphi_i$ arising from numerical truncation error at that $r_i$. Additionally, you are given $m_A$ and its one-sigma uncertainty $\\delta m_A$. Assume independent, Gaussian-distributed errors for the $\\varphi_i$ values, and independence between the inferred $Q$ and the mass uncertainty.\n\nYour task is to implement a numerical procedure, grounded in first principles, to estimate $\\alpha_A$ and its one-sigma uncertainty by fitting the $1/r$ tail of $\\varphi(r)$ with a linear model in $x_i = 1/r_i$, that is, $\\varphi_i \\approx \\varphi_{\\infty} + Q x_i$. The fitting must be performed under the assumption of independent Gaussian errors with known standard deviations $\\sigma_i$, and the uncertainty on $\\alpha_A$ must be obtained by propagating the parameter uncertainty from the fit and the uncertainty on $m_A$. Work strictly in geometrized units with $G=c=1$, so $r_i$ and $m_A$ are measured in the same length unit and $\\varphi$ is dimensionless. Express all final numerical answers as dimensionless decimals.\n\nImplement the following steps in your program:\n\n- Build the linear model with design matrix corresponding to parameters $(\\varphi_{\\infty}, Q)$ and data $(x_i, \\varphi_i)$ with weights $w_i = 1/\\sigma_i^2$.\n- Compute the maximum likelihood estimates for $(\\varphi_{\\infty}, Q)$ under independent Gaussian errors and the associated parameter covariance matrix.\n- Infer $\\alpha_A = Q/m_A$ and its one-sigma uncertainty by standard linear error propagation, assuming independence between the fitted $Q$ and the mass $m_A$ uncertainty.\n\nYour program must evaluate the following test suite and produce the requested outputs. Each test case provides $(r_i, \\varphi_i, \\sigma_i)$ arrays, $m_A$, and $\\delta m_A$:\n\n- Test case $1$ (happy path, moderately noisy tail):\n  - $r = [20.0, 30.0, 40.0, 50.0, 60.0, 80.0, 100.0]$\n  - $\\varphi = [0.01505, 0.01034, 0.00801, 0.00658, 0.00568, 0.004485, 0.00382]$\n  - $\\sigma = [1.0\\times 10^{-4}, 1.0\\times 10^{-4}, 1.0\\times 10^{-4}, 1.0\\times 10^{-4}, 1.0\\times 10^{-4}, 1.0\\times 10^{-4}, 1.0\\times 10^{-4}]$\n  - $m_A = 1.4$, $\\delta m_A = 0.02$\n- Test case $2$ (boundary condition with minimal points and nearly vanishing charge):\n  - $r = [100.0, 200.0]$\n  - $\\varphi = [0.00201, 0.00199]$\n  - $\\sigma = [5.0\\times 10^{-5}, 5.0\\times 10^{-5}]$\n  - $m_A = 2.0$, $\\delta m_A = 0.1$\n- Test case $3$ (heteroscedastic uncertainties and moderate coupling):\n  - $r = [25.0, 35.0, 55.0, 75.0, 95.0, 120.0]$\n  - $\\varphi = [0.0041, 0.0030357, 0.0024545, 0.0017867, 0.0017921, 0.0014667]$\n  - $\\sigma = [2.0\\times 10^{-4}, 2.0\\times 10^{-4}, 5.0\\times 10^{-4}, 3.0\\times 10^{-4}, 8.0\\times 10^{-4}, 2.0\\times 10^{-4}]$\n  - $m_A = 1.6$, $\\delta m_A = 0.03$\n- Test case $4$ (finite-radius systematics with an $1/r^2$ contamination term present in the data; fit still to the $1/r$ model):\n  - $r = [15.0, 20.0, 25.0, 35.0, 50.0, 70.0, 90.0]$\n  - $\\varphi = [0.0107056, 0.00823, 0.00671, 0.0050776, 0.0039, 0.00308, 0.0026841]$\n  - $\\sigma = [1.0\\times 10^{-4}, 1.0\\times 10^{-4}, 1.0\\times 10^{-4}, 1.0\\times 10^{-4}, 1.0\\times 10^{-4}, 1.0\\times 10^{-4}, 1.0\\times 10^{-4}]$\n  - $m_A = 1.3$, $\\delta m_A = 0.02$\n\nFor each test case, compute the estimated $\\alpha_A$ and its one-sigma uncertainty $\\delta \\alpha_A$ as floats. Your program should produce a single line of output containing the results as a comma-separated list of lists, where each inner list is of the form $[\\alpha_A, \\delta \\alpha_A]$, enclosed in square brackets. For example, an output of the form $[[a_1, d_1],[a_2, d_2],[a_3, d_3],[a_4, d_4]]$ is required, where each $a_i$ and $d_i$ are floats representing the estimated $\\alpha_A$ and its one-sigma uncertainty for the $i$-th test case. All answers are dimensionless decimals in geometrized units.", "solution": "The posed problem is to determine the dimensionless scalar charge $\\alpha_A$ of a compact object and its associated one-sigma uncertainty, $\\delta \\alpha_A$, from a discrete set of numerical data. This data represents samples of a massless scalar field $\\varphi$ at various radii $r$ in the exterior spacetime. The problem is scientifically grounded, well-posed, and provides all necessary information for a unique, stable solution based on established principles of statistical data analysis and physics.\n\nThe foundational physical model is the asymptotic behavior of the scalar field $\\varphi(r)$ in the far field, which is given by:\n$$\n\\varphi(r) = \\varphi_{\\infty} + \\frac{Q}{r} + \\mathcal{O}\\left(\\frac{1}{r^2}\\right)\n$$\nHere, $\\varphi_{\\infty}$ is the cosmological value of the scalar field, and $Q$ is the effective scalar monopole moment, or scalar charge, of the compact object. The dimensionless scalar charge is defined as $\\alpha_A = Q/m_A$, where $m_A$ is the gravitational mass of the object. We are given $N$ data points $\\{(r_i, \\varphi_i, \\sigma_i)\\}_{i=1}^N$, where $\\varphi_i$ is the measured field at radius $r_i$ with an independent, Gaussian-distributed uncertainty of standard deviation $\\sigma_i$.\n\nTo estimate the parameters $\\varphi_{\\infty}$ and $Q$, we linearize the model by defining the independent variable $x_i = 1/r_i$. The model then takes the form of a linear equation:\n$$\n\\varphi_i = \\varphi_{\\infty} + Q x_i\n$$\nThis is a linear regression problem. Given that the uncertainties $\\sigma_i$ on the measurements $\\varphi_i$ are known and represent independent Gaussian errors, the appropriate method for parameter estimation is weighted least squares (WLS), which corresponds to the maximum likelihood estimator. The goal is to find the parameter vector $\\hat{\\beta} = [\\hat{\\varphi}_{\\infty}, \\hat{Q}]^T$ that minimizes the chi-squared statistic:\n$$\n\\chi^2(\\beta) = \\sum_{i=1}^N w_i (\\varphi_i - (\\varphi_{\\infty} + Q x_i))^2\n$$\nwhere the weights are defined as $w_i = 1/\\sigma_i^2$.\n\nIn matrix notation, the problem is formulated as $y \\approx X\\beta$, where:\n- $y = [\\varphi_1, \\varphi_2, \\dots, \\varphi_N]^T$ is the vector of dependent variable measurements.\n- $X$ is the $N \\times 2$ design matrix, whose $i$-th row is $[1, x_i] = [1, 1/r_i]$.\n$$\nX = \\begin{pmatrix} 1  1/r_1 \\\\ 1  1/r_2 \\\\ \\vdots  \\vdots \\\\ 1  1/r_N \\end{pmatrix}\n$$\n- $\\beta = [\\varphi_{\\infty}, Q]^T$ is the vector of parameters to be estimated.\n\nThe WLS solution $\\hat{\\beta}$ is found by solving the normal equations:\n$$\n(X^T W X) \\hat{\\beta} = X^T W y\n$$\nwhere $W$ is the diagonal weight matrix with $W_{ii} = w_i = 1/\\sigma_i^2$. The solution for the estimated parameters is:\n$$\n\\hat{\\beta} = (X^T W X)^{-1} X^T W y\n$$\nThe covariance matrix of the estimated parameters $\\hat{\\beta}$ is given by the inverse of the Hessian of the $\\chi^2$ function, which is:\n$$\n\\text{Cov}(\\hat{\\beta}) = (X^T W X)^{-\"1}\n$$\nThis is a $2 \\times 2$ matrix:\n$$\n\\text{Cov}(\\hat{\\beta}) = \\begin{pmatrix} \\sigma_{\\varphi_{\\infty}}^2  \\text{Cov}(\\varphi_{\\infty}, Q) \\\\ \\text{Cov}(\\varphi_{\\infty}, Q)  \\sigma_Q^2 \\end{pmatrix}\n$$\nThe variance of the estimate for the scalar charge $Q$ is the second diagonal element, $\\sigma_Q^2$. Its one-sigma uncertainty is therefore $\\delta Q = \\sqrt{\\sigma_Q^2}$.\n\nFinally, we compute the desired quantity, $\\alpha_A = Q/m_A$, and its uncertainty. The estimate is simply $\\hat{\\alpha}_A = \\hat{Q}/m_A$. To find the uncertainty $\\delta \\alpha_A$, we use the standard formula for propagation of independent errors. Given that $\\alpha_A$ is a function of two independently measured quantities, $Q$ and $m_A$, with uncertainties $\\delta Q$ and $\\delta m_A$, its variance $\\sigma_{\\alpha_A}^2 = (\\delta \\alpha_A)^2$ is:\n$$\n(\\delta \\alpha_A)^2 = \\left( \\frac{\\partial \\alpha_A}{\\partial Q} \\right)^2 (\\delta Q)^2 + \\left( \\frac{\\partial \\alpha_A}{\\partial m_A} \\right)^2 (\\delta m_A)^2\n$$\nThe partial derivatives are $\\partial\\alpha_A/\\partial Q = 1/m_A$ and $\\partial\\alpha_A/\\partial m_A = -Q/m_A^2$. Substituting these into the formula yields:\n$$\n(\\delta \\alpha_A)^2 = \\left( \\frac{1}{m_A} \\right)^2 (\\delta Q)^2 + \\left( -\\frac{\\hat{Q}}{m_A^2} \\right)^2 (\\delta m_A)^2 = \\frac{(\\delta Q)^2}{m_A^2} + \\frac{\\hat{Q}^2 (\\delta m_A)^2}{m_A^4}\n$$\nThe one-sigma uncertainty in $\\alpha_A$ is the square root of this expression.\n\nThe numerical implementation will follow these steps precisely for each test case provided. We use `numpy` for efficient and accurate linear algebra operations to construct the matrices, solve the normal equations, and compute the resulting uncertainties.", "answer": "```python\nimport numpy as np\n\ndef calculate_alpha_A(r, phi, sigma_phi, m_A, delta_m_A):\n    \"\"\"\n    Estimates the dimensionless scalar charge alpha_A and its uncertainty.\n\n    The function performs a weighted linear least squares fit to the model\n    phi = phi_inf + Q * (1/r) to find the scalar charge Q and its\n    uncertainty delta_Q. It then propagates errors to find alpha_A = Q/m_A\n    and its uncertainty.\n\n    Args:\n        r (np.ndarray): Radii of scalar field samples.\n        phi (np.ndarray): Scalar field values at corresponding radii.\n        sigma_phi (np.ndarray): One-sigma uncertainties for phi values.\n        m_A (float): Gravitational mass of the compact object.\n        delta_m_A (float): One-sigma uncertainty of the mass.\n\n    Returns:\n        list: A list containing the estimated alpha_A and its uncertainty [alpha_A, delta_alpha_A].\n    \"\"\"\n    # Ensure inputs are numpy arrays for vector operations\n    r = np.asarray(r, dtype=float)\n    phi = np.asarray(phi, dtype=float)\n    sigma_phi = np.asarray(sigma_phi, dtype=float)\n\n    # 1. Build the linear model components\n    # Independent variable x = 1/r\n    x = 1.0 / r\n\n    # Design matrix X for model phi = beta_0 * 1 + beta_1 * x\n    # where beta_0 is phi_inf and beta_1 is Q\n    X = np.vstack((np.ones_like(x), x)).T\n\n    # Weights w_i = 1/sigma_i^2\n    weights = 1.0 / (sigma_phi**2)\n\n    # 2. Compute the maximum likelihood estimates for parameters (phi_inf, Q)\n    # The normal equations are (X.T W X) beta = X.T W y\n    # Let A = X.T W X\n    # Let b = X.T W y\n    # Here, W is a diagonal matrix, so (X.T W X) is sum(w_i * x_i_vec * x_i_vec.T)\n    # and (X.T W y) is sum(w_i * x_i_vec * y_i).\n    # A more direct computation using broadcasting:\n    A = X.T @ (X * weights[:, np.newaxis])\n    b = X.T @ (phi * weights)\n    \n    # Solve A * beta = b for beta\n    # beta_hat[0] is phi_inf, beta_hat[1] is Q\n    try:\n        beta_hat = np.linalg.solve(A, b)\n    except np.linalg.LinAlgError:\n        # This case is unlikely with the given problem constraints but is good practice.\n        return [np.nan, np.nan]\n    \n    Q_hat = beta_hat[1]\n\n    # 3. Compute the associated parameter covariance matrix\n    # Cov(beta) = (X.T W X)^-1 = A^-1\n    try:\n        cov_beta = np.linalg.inv(A)\n    except np.linalg.LinAlgError:\n        return [np.nan, np.nan]\n        \n    # Variance of Q is the [1,1] element of the covariance matrix\n    var_Q = cov_beta[1, 1]\n    # One-sigma uncertainty is the square root of the variance\n    delta_Q = np.sqrt(var_Q)\n\n    # 4. Infer alpha_A and its one-sigma uncertainty\n    alpha_A_hat = Q_hat / m_A\n    \n    # Propagate uncertainties assuming independence between Q and m_A\n    # (delta_alpha_A)^2 = (delta_Q/m_A)^2 + (Q*delta_m_A / m_A^2)^2\n    var_alpha_A = (delta_Q**2 / m_A**2) + (Q_hat**2 * delta_m_A**2 / m_A**4)\n    delta_alpha_A = np.sqrt(var_alpha_A)\n    \n    return [alpha_A_hat, delta_alpha_A]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {\n            \"r\": [20.0, 30.0, 40.0, 50.0, 60.0, 80.0, 100.0],\n            \"phi\": [0.01505, 0.01034, 0.00801, 0.00658, 0.00568, 0.004485, 0.00382],\n            \"sigma\": [1.0e-4, 1.0e-4, 1.0e-4, 1.0e-4, 1.0e-4, 1.0e-4, 1.0e-4],\n            \"m_A\": 1.4,\n            \"delta_m_A\": 0.02\n        },\n        # Test case 2\n        {\n            \"r\": [100.0, 200.0],\n            \"phi\": [0.00201, 0.00199],\n            \"sigma\": [5.0e-5, 5.0e-5],\n            \"m_A\": 2.0,\n            \"delta_m_A\": 0.1\n        },\n        # Test case 3\n        {\n            \"r\": [25.0, 35.0, 55.0, 75.0, 95.0, 120.0],\n            \"phi\": [0.0041, 0.0030357, 0.0024545, 0.0017867, 0.0017921, 0.0014667],\n            \"sigma\": [2.0e-4, 2.0e-4, 5.0e-4, 3.0e-4, 8.0e-4, 2.0e-4],\n            \"m_A\": 1.6,\n            \"delta_m_A\": 0.03\n        },\n        # Test case 4\n        {\n            \"r\": [15.0, 20.0, 25.0, 35.0, 50.0, 70.0, 90.0],\n            \"phi\": [0.0107056, 0.00823, 0.00671, 0.0050776, 0.0039, 0.00308, 0.0026841],\n            \"sigma\": [1.0e-4, 1.0e-4, 1.0e-4, 1.0e-4, 1.0e-4, 1.0e-4, 1.0e-4],\n            \"m_A\": 1.3,\n            \"delta_m_A\": 0.02\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_alpha_A(case[\"r\"], case[\"phi\"], case[\"sigma\"], case[\"m_A\"], case[\"delta_m_A\"])\n        results.append(result)\n\n    # Format the output as a string representation of a list of lists.\n    # str([1.2, 3.4]) -> '[1.2, 3.4]'\n    # ','.join(['[1.2, 3.4]', '[5.6, 7.8]']) -> '[1.2, 3.4],[5.6, 7.8]'\n    # Then enclose in outer brackets.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3485574"}]}