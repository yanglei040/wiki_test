{"hands_on_practices": [{"introduction": "The outcome of a black hole-neutron star (BH-NS) merger is fundamentally determined by a competition between the black hole's gravity and its tidal forces. This practice explores this dichotomy by asking you to build a semi-analytic model to predict whether a neutron star is tidally disrupted, forming a post-merger accretion disk, or if it plunges directly into the black hole. By comparing the tidal disruption radius $R_{\\rm tid}$ with the black hole's innermost stable circular orbit $R_{\\rm ISCO}$, you will gain hands-on insight into the crucial roles that mass ratio, black hole spin, and neutron star compactness play in shaping these cataclysmic events [@problem_id:3466282].", "problem": "Consider a semi-analytic disruption criterion for black hole–neutron star mergers in which a neutron star (NS) tidally disrupts and leaves a remnant accretion disk if and only if the tidal disruption radius exceeds the innermost stable circular orbit (ISCO) radius of the black hole (BH). Let the tidal disruption radius be modeled as the leading-order Newtonian scaling $R_{\\rm tid} \\sim \\kappa_{\\rm tide}\\, R_{\\rm NS}\\left(M_{\\rm BH}/M_{\\rm NS}\\right)^{1/3}$, where $R_{\\rm NS}$ is the NS circumferential radius, $M_{\\rm BH}$ is the BH mass, $M_{\\rm NS}$ is the NS mass, and $\\kappa_{\\rm tide}$ is an order-unity coefficient that we set to $\\kappa_{\\rm tide}=1$ to define a concrete semi-analytic model. Let the ISCO radius be obtained from the Kerr spacetime for dimensionless spin parameter $a_\\ast$ and converted to a physical length using $G$ and $c$. Define the decision rule as follows: a remnant disk forms if and only if $R_{\\rm tid}R_{\\rm ISCO}(a_\\ast)$; otherwise, the outcome is a prompt plunge with negligible disk.\n\nStarting from fundamental principles, use the following bases without importing any target formulas into the problem statement: \n- Equate the Newtonian tidal acceleration across the NS to the NS surface self-gravity to obtain the leading-order scaling for $R_{\\rm tid}$.\n- Use the marginal stability condition for equatorial circular geodesics in the Kerr metric to obtain $r_{\\rm ISCO}(a_\\ast)$ in units of $M$, where $M$ is the BH mass in geometric units.\n- Convert $r_{\\rm ISCO}$ to a physical length via $R_{\\rm ISCO}=r_{\\rm ISCO}\\, G M_{\\rm BH}/c^2$.\n\nAll radii must be computed in kilometers. Mass inputs are provided in solar masses and must be converted consistently by first converting to kilograms and then to kilometers through the factor $G M_{\\odot}/c^2$. The dimensionless spin parameter $a_\\ast$ can be positive (prograde) or negative (retrograde). \n\nImplement a program that:\n- Computes $R_{\\rm tid}$ and $R_{\\rm ISCO}$ for each test case,\n- Predicts the semi-analytic outcome as a boolean according to whether $R_{\\rm tid}R_{\\rm ISCO}$,\n- Compares that prediction against a provided Numerical Relativity (NR) outcome label (where NR stands for Numerical Relativity),\n- Returns for each test case a boolean indicating whether the semi-analytic prediction matches the NR label.\n\nUse the following test suite of parameter tuples $(M_{\\rm BH}, a_\\ast, M_{\\rm NS}, R_{\\rm NS}, \\text{NR\\_disk})$, where $M_{\\rm BH}$ and $M_{\\rm NS}$ are in solar masses, $R_{\\rm NS}$ is in kilometers, and $\\text{NR\\_disk}$ is the expected NR label (disk forms is true or false):\n- Case A (happy path, prompt plunge): $(7.0, 0.0, 1.4, 12.0, \\text{false})$.\n- Case B (high spin and larger NS, disruption): $(7.0, 0.95, 1.4, 14.0, \\text{true})$.\n- Case C (low BH mass and high spin, disruption): $(3.0, 0.9, 1.4, 12.0, \\text{true})$.\n- Case D (high BH mass, near-threshold high spin, disruption): $(10.0, 0.99, 1.4, 12.0, \\text{true})$.\n- Case E (compact NS and moderate spin, prompt plunge): $(5.0, 0.5, 1.4, 11.0, \\text{false})$.\n- Case F (retrograde spin, prompt plunge): $(5.0, -0.5, 1.4, 12.0, \\text{false})$.\n\nYour program must implement the Kerr ISCO exactly for arbitrary $a_\\ast \\in [-1,1]$ based on the marginal stability condition in the Kerr metric, and the Newtonian leading-order tidal criterion as specified. Use the standard constants $G$ and $c$ and the solar mass $M_{\\odot}$ with the following values in SI units: $G=6.67430\\times 10^{-11} \\, \\text{m}^3\\text{kg}^{-1}\\text{s}^{-2}$, $c=2.99792458\\times 10^{8} \\, \\text{m s}^{-1}$, and $M_{\\odot}=1.98847\\times 10^{30} \\, \\text{kg}$. All intermediate physical computations must be carried out consistently and all radii must be expressed in kilometers.\n\nAngle units are not used. No percentages are used.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the form `[b_A,b_B,b_C,b_D,b_E,b_F]`, where each entry is a boolean equal to true if and only if the semi-analytic prediction matches the NR label for that case, and false otherwise. For example, a valid output line might look like `[True,False,True,True,True,False]` (this is only an example and not the required answer).", "solution": "The problem is valid as it is scientifically grounded in astrophysics and general relativity, well-posed with a clear objective and sufficient data, and objective in its formulation. The task is to implement a semi-analytic model to predict the outcome of black hole-neutron star (BH-NS) mergers and compare this prediction against provided numerical relativity (NR) results. The model posits that a remnant accretion disk forms if and only if the tidal disruption radius, $R_{\\rm tid}$, is greater than the innermost stable circular orbit (ISCO) radius of the black hole, $R_{\\rm ISCO}$.\n\nThe solution requires the derivation and implementation of formulas for these two radii from fundamental principles, as specified in the problem statement. All calculations must be performed using consistent physical units, with final radii expressed in kilometers.\n\nFirst, we derive the expression for the tidal disruption radius, $R_{\\rm tid}$. In the Newtonian approximation, a neutron star (NS) of mass $M_{\\rm NS}$ and radius $R_{\\rm NS}$ is tidally disrupted by a black hole (BH) of mass $M_{\\rm BH}$ when the differential gravitational force from the BH across the NS overcomes the NS's own self-gravity. The tidal acceleration, $a_{\\rm tide}$, exerted by the BH at a distance $R$ across the NS (of characteristic size $R_{\\rm NS}$) scales as $a_{\\rm tide} \\approx G M_{\\rm BH} R_{\\rm NS} / R^3$. The self-gravitational acceleration at the surface of the NS that holds it together is $a_{\\rm self} = G M_{\\rm NS} / R_{\\rm NS}^2$. Equating these two accelerations defines the tidal disruption radius, $R_{\\rm tid}$:\n$$\n\\frac{G M_{\\rm BH} R_{\\rm NS}}{R_{\\rm tid}^3} \\sim \\frac{G M_{\\rm NS}}{R_{\\rm NS}^2}\n$$\nSolving for $R_{\\rm tid}$ gives the scaling relation:\n$$\nR_{\\rm tid} \\sim R_{\\rm NS} \\left(\\frac{M_{\\rm BH}}{M_{\\rm NS}}\\right)^{1/3}\n$$\nThe problem specifies using this leading-order scaling with an order-unity coefficient $\\kappa_{\\rm tide}$ set to $1$. Thus, the formula to be implemented is exactly $R_{\\rm tid} = R_{\\rm NS} \\left(M_{\\rm BH}/M_{\\rm NS}\\right)^{1/3}$. Since $M_{\\rm BH}$ and $M_{\\rm NS}$ are provided in the same units (solar masses), their ratio is dimensionless. With $R_{\\rm NS}$ given in kilometers, the resulting $R_{\\rm tid}$ is also in kilometers.\n\nNext, we determine the ISCO radius of the Kerr black hole, $R_{\\rm ISCO}$. The ISCO is the smallest radius at which a massive particle can maintain a stable circular orbit in the equatorial plane of the black hole. Its radius is found by solving the conditions for marginal stability of equatorial circular geodesics in the Kerr metric, which are $\\frac{d V_{\\rm eff}}{dr} = 0$ and $\\frac{d^2 V_{\\rm eff}}{dr^2} = 0$, where $V_{\\rm eff}$ is the effective potential. The solution to these equations gives the ISCO radius, $r_{\\rm ISCO}$, in geometric units of the BH mass $M = G M_{\\rm BH}/c^2$. The result depends on the dimensionless spin parameter of the black hole, $a_\\ast = a/M$, where $a$ is the spin parameter. The exact formula for the dimensionless ISCO radius, $r'_{\\rm ISCO} = r_{\\rm ISCO}/M$, is:\n$$\nr'_{\\rm ISCO}(a_\\ast) = 3 + Z_2 \\mp \\sqrt{(3-Z_1)(3+Z_1+2Z_2)}\n$$\nwhere\n$$\nZ_1 = 1 + (1-|a_\\ast|^2)^{1/3} \\left( (1+|a_\\ast|)^{1/3} + (1-|a_\\ast|)^{1/3} \\right)\n$$\n$$\nZ_2 = \\sqrt{3|a_\\ast|^2 + Z_1^2}\n$$\nThe sign choice $\\mp$ depends on the orbit's orientation relative to the BH spin: the minus sign ($-$ ) is for prograde orbits (co-rotating, $a_\\ast \\ge 0$), yielding a smaller ISCO, and the plus sign ($+$) is for retrograde orbits (counter-rotating, $a_\\ast  0$), yielding a larger ISCO.\n\nTo obtain the physical radius $R_{\\rm ISCO}$ in kilometers, we must first convert the black hole's mass, $M_{\\rm BH}$, from solar masses ($M_\\odot$) to kilometers. The conversion factor is the gravitational radius of one solar mass:\n$$\nM_{\\odot, \\text{km}} = \\frac{G M_\\odot}{c^2}\n$$\nUsing the provided constants, $G = 6.67430 \\times 10^{-11}$ m$^3$ kg$^{-1}$ s$^{-2}$, $c = 2.99792458 \\times 10^8$ m s$^{-1}$, and $M_\\odot = 1.98847 \\times 10^{30}$ kg, this factor is approximately $1.4766$ km. The physical ISCO radius is then:\n$$\nR_{\\rm ISCO} = r'_{\\rm ISCO}(a_\\ast) \\times (M_{\\rm BH} \\text{ in } M_\\odot) \\times M_{\\odot, \\text{km}}\n$$\n\nThe computational procedure is as follows:\n1. Define the physical constants $G$, $c$, and $M_\\odot$, and compute the conversion factor from solar masses to kilometers.\n2. For each test case $(M_{\\rm BH}, a_\\ast, M_{\\rm NS}, R_{\\rm NS}, \\text{NR\\_disk})$:\n    a. Calculate $R_{\\rm tid}$ using the tidal radius formula.\n    b. Calculate $R_{\\rm ISCO}$ by first computing the dimensionless radius $r'_{\\rm ISCO}(a_\\ast)$ for the given spin $a_\\ast$ and then scaling by the black hole's mass in kilometers.\n    c. Apply the decision rule: predict a remnant disk (`true`) if $R_{\\rm tid}  R_{\\rm ISCO}$, and a prompt plunge (`false`) otherwise.\n    d. Compare this boolean prediction to the provided NR outcome label $\\text{NR\\_disk}$.\n    e. The result for the case is `true` if the prediction matches the label, and `false` otherwise.\n3. Collect the boolean results for all test cases and format them into the specified output string. This systematic process validates the semi-analytic model against a set of benchmark simulations.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and validates a semi-analytic model for black hole-neutron star\n    merger outcomes against numerical relativity results.\n    \"\"\"\n\n    # Physical constants in SI units\n    G = 6.67430e-11  # Gravitational constant (m^3 kg^-1 s^-2)\n    C = 2.99792458e8   # Speed of light (m s^-1)\n    M_SOLAR_KG = 1.98847e30  # Solar mass (kg)\n\n    # Conversion factor for mass from solar masses to kilometers\n    SOLAR_MASS_IN_KM = (G * M_SOLAR_KG) / (C**2 * 1000)\n\n    # Test cases from the problem statement\n    # Tuple format: (M_BH (M_solar), a_star, M_NS (M_solar), R_NS (km), NR_disk_label (bool))\n    test_cases = [\n        (7.0, 0.0, 1.4, 12.0, False),    # Case A\n        (7.0, 0.95, 1.4, 14.0, True),    # Case B\n        (3.0, 0.9, 1.4, 12.0, True),     # Case C\n        (10.0, 0.99, 1.4, 12.0, True),   # Case D\n        (5.0, 0.5, 1.4, 11.0, False),    # Case E\n        (5.0, -0.5, 1.4, 12.0, False),   # Case F\n    ]\n\n    def calculate_isco_radius_km(m_bh_solar, a_star):\n        \"\"\"\n        Calculates the physical ISCO radius in km for a Kerr black hole.\n        - m_bh_solar: Black hole mass in solar masses.\n        - a_star: Dimensionless black hole spin parameter [-1, 1].\n        \"\"\"\n        a = abs(a_star)\n        \n        # Handle the edge case a=1 to avoid potential numerical issues with (1-a**2)\n        if a > 1.0:\n            raise ValueError(\"Spin parameter |a*| cannot exceed 1.\")\n            \n        z1 = 1 + np.cbrt(1 - a**2) * (np.cbrt(1 + a) + np.cbrt(1 - a))\n        z2 = np.sqrt(3 * a**2 + z1**2)\n        \n        # Prograde (a_star >= 0) and retrograde (a_star  0) orbits\n        sqrt_term = np.sqrt((3 - z1) * (3 + z1 + 2 * z2))\n        \n        if a_star >= 0:\n            # Prograde orbit formula\n            r_isco_dimless = 3 + z2 - sqrt_term\n        else:\n            # Retrograde orbit formula\n            r_isco_dimless = 3 + z2 + sqrt_term\n            \n        r_isco_km = r_isco_dimless * m_bh_solar * SOLAR_MASS_IN_KM\n        return r_isco_km\n\n    def calculate_tidal_radius_km(m_bh_solar, m_ns_solar, r_ns_km):\n        \"\"\"\n        Calculates the tidal disruption radius in km.\n        - m_bh_solar: Black hole mass in solar masses.\n        - m_ns_solar: Neutron star mass in solar masses.\n        - r_ns_km: Neutron star radius in kilometers.\n        \"\"\"\n        mass_ratio = m_bh_solar / m_ns_solar\n        r_tid_km = r_ns_km * np.cbrt(mass_ratio)\n        return r_tid_km\n\n    results = []\n    for case in test_cases:\n        m_bh, a_star, m_ns, r_ns, nr_disk_label = case\n        \n        # Compute the two critical radii\n        r_isco = calculate_isco_radius_km(m_bh, a_star)\n        r_tid = calculate_tidal_radius_km(m_bh, m_ns, r_ns)\n        \n        # Apply the semi-analytic decision rule\n        # A disk forms if the tidal radius is greater than the ISCO radius\n        analytic_prediction = r_tid > r_isco\n        \n        # Compare the prediction with the numerical relativity label\n        match = (analytic_prediction == nr_disk_label)\n        results.append(match)\n\n    # Format and print the final output as a single line\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3466282"}, {"introduction": "Gravitational waves from a BH-NS inspiral carry a faint but crucial signature of the neutron star's internal structure, encoded in its tidal deformability parameter $\\tilde{\\Lambda}$. This exercise places you in the role of a gravitational-wave data analyst tasked with quantifying the challenges of measuring this effect [@problem_id:3466318]. You will use the powerful Fisher Information Matrix formalism to investigate how using an incomplete waveform model—one that neglects tidal effects—can lead to systematic biases in the inferred parameters, a critical consideration for accurately interpreting observational data.", "problem": "Consider gravitational waves from a nonspinning black hole–neutron star binary analyzed within the framework of numerical relativity and gravitational-wave data analysis. You are asked to quantify systematic biases in the inference of the effective tidal deformability parameter when using binary black hole templates that omit tidal effects. Work in the frequency domain under the Stationary Phase Approximation (SPA) and assume the inspiral-only regime, with a sharp cutoff at a specified maximum frequency. Use the following scientifically standard bases and definitions:\n\n- The matched-filter inner product between two frequency-domain signals $a(f)$ and $b(f)$ is defined by the rule of optimal filtering and Gaussian noise as\n$$\n(a|b) = 4\\,\\Re\\int_{f_{\\mathrm{low}}}^{f_{\\mathrm{cut}}} \\frac{a(f)\\,b^{\\ast}(f)}{S_n(f)}\\,df,\n$$\nwhere $S_n(f)$ is the one-sided noise Power Spectral Density (PSD), $f_{\\mathrm{low}}$ is the lower cutoff frequency, $f_{\\mathrm{cut}}$ is the upper cutoff frequency, and $\\Re$ denotes the real part.\n\n- The network Signal-to-Noise Ratio (SNR) is defined by\n$$\n\\rho = \\sqrt{(h|h)},\n$$\nwhere $h(f)$ is the template waveform.\n\n- For parameter estimation in the high-SNR, linearized regime, the first-order systematic parameter bias due to waveform-model error is estimated using the Fisher Information Matrix (FIM). For parameters $\\theta_i$, the FIM is\n$$\n\\Gamma_{ij} = \\left(\\frac{\\partial h}{\\partial \\theta_i} \\Bigg| \\frac{\\partial h}{\\partial \\theta_j}\\right),\n$$\nand the leading-order systematic bias vector is\n$$\n\\delta \\theta_i \\approx \\sum_j \\left[\\Gamma^{-1}\\right]_{ij}\\,\\left(\\delta h \\Bigg| \\frac{\\partial h}{\\partial \\theta_j}\\right),\n$$\nwhere $\\delta h(f)$ is the difference between the true signal and the assumed template family.\n\n- Use a simplified frequency-domain inspiral template $h(f)$ under the Stationary Phase Approximation (SPA) with amplitude scaling as a power law $f^{-7/6}$ and a phase comprising leading point-mass terms and a leading-order tidal phase correction proportional to an effective tidal deformability. Treat the binary as nonspinning and circular. All phases are in radians.\n\n- The effective tidal deformability for a black hole–neutron star system is the reduced parameter entering the leading-order tidal phase. For the black hole mass $m_1$ and neutron star mass $m_2$, and the neutron star dimensionless tidal deformability $\\Lambda_{\\mathrm{NS}}$, the effective tidal deformability is defined as\n$$\n\\tilde{\\Lambda} = \\frac{16}{13}\\,\\frac{\\left(m_2 + 12 m_1\\right)\\,m_2^4}{\\left(m_1 + m_2\\right)^5}\\,\\Lambda_{\\mathrm{NS}}.\n$$\nThis parameter encapsulates the mass dependence and equals zero if both bodies are black holes.\n\n- Adopt geometric units in the waveform phase where $G=c=1$, but ensure correct conversion of masses from solar masses by using $M_{\\odot} c^{-3} G \\approx 4.92549094830932\\times 10^{-6}\\,\\mathrm{s}$ so that $m$ in solar masses converts to seconds via $m \\times 4.92549094830932\\times 10^{-6}\\,\\mathrm{s}$ when appearing in combinations such as $\\pi M f$ in the phase.\n\n- Use the following constant and modeling choices:\n    - Leading-order tidal phase coefficient $K_{\\mathrm{tidal}} = 39/2$.\n    - Power Spectral Density (PSD) model $S_n(f) = S_0\\left[1 + \\left(\\frac{f_0}{f}\\right)^4\\right]$ with $S_0 = 1$ and $f_0 = 50\\,\\mathrm{Hz}$.\n    - Lower cutoff frequency $f_{\\mathrm{low}} = 20\\,\\mathrm{Hz}$.\n    - Coalescence time and phase can be treated as nuisance parameters; set their fiducial values to zero in the template but include them in the Fisher Information Matrix.\n    - Frequency unit is Hertz. Angles are in radians. The tidal deformability parameters are dimensionless.\n\nYour task:\n\n- Starting from the matched-filter inner product, the Fisher Information Matrix definition, and the Stationary Phase Approximation assumptions, derive a working algorithm to:\n    1. Normalize the binary black hole template amplitude to achieve a specified SNR $\\rho$ over the frequency band $[f_{\\mathrm{low}}, f_{\\mathrm{cut}}]$.\n    2. Construct the Fisher Information Matrix for the parameter vector $\\{\\tilde{\\Lambda}, \\phi_c, t_c\\}$, where $\\phi_c$ is the coalescence phase and $t_c$ is the coalescence time.\n    3. Compute the first-order systematic bias $\\delta \\tilde{\\Lambda}$ induced by using a binary black hole template that omits the tidal phase, when the true signal includes the leading-order tidal phase determined by $\\tilde{\\Lambda}$. Use the exact difference $\\delta h(f) = h_{\\mathrm{true}}(f) - h_{\\mathrm{template}}(f)$ formulated under the same amplitude model and cutoffs, and evaluate the inner products numerically.\n    4. Compute the Gaussian statistical uncertainty $\\sigma_{\\tilde{\\Lambda}} = \\sqrt{\\left[\\Gamma^{-1}\\right]_{\\tilde{\\Lambda}\\tilde{\\Lambda}}}$.\n    5. Report the relative bias $b_{\\mathrm{rel}} = |\\delta \\tilde{\\Lambda}|/\\sigma_{\\tilde{\\Lambda}}$.\n\n- Scientific realism: Restrict the analysis to inspiral-only signals and frequency-domain modeling. Assume the linearized-bias approximation is appropriate within the provided parameter ranges.\n\nTest suite:\n\n- Assume a black hole mass $m_1 = 7\\,M_{\\odot}$ and a neutron star mass $m_2 = 1.4\\,M_{\\odot}$, with a neutron star tidal deformability $\\Lambda_{\\mathrm{NS}} = 200$. For each test case, specify a Signal-to-Noise Ratio (SNR) $\\rho$ and a cutoff frequency $f_{\\mathrm{cut}}$ in Hertz:\n    1. Case A: $\\rho = 10$, $f_{\\mathrm{cut}} = 400\\,\\mathrm{Hz}$.\n    2. Case B: $\\rho = 25$, $f_{\\mathrm{cut}} = 600\\,\\mathrm{Hz}$.\n    3. Case C: $\\rho = 50$, $f_{\\mathrm{cut}} = 800\\,\\mathrm{Hz}$.\n    4. Edge Case D: $\\rho = 8$, $f_{\\mathrm{cut}} = 350\\,\\mathrm{Hz}$.\n\nFinal output format:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element corresponds to one test case and must be an inner list of two floats $[\\delta \\tilde{\\Lambda}, b_{\\mathrm{rel}}]$, each rounded to six decimal places, in the order of the test suite above. For example: $[[x_1,y_1],[x_2,y_2],[x_3,y_3],[x_4,y_4]]$.", "solution": "The derivation and algorithm are constructed from first principles in gravitational-wave data analysis and linear parameter estimation, with explicit specification of the waveform model and parameterization suitable for black hole–neutron star inspirals.\n\n1. Foundational modeling and inner product\n\nWe assume a frequency-domain inspiral waveform $h(f)$ under the Stationary Phase Approximation (SPA) with amplitude scaling as $f^{-7/6}$. The matched-filter inner product appropriate for Gaussian noise is\n$$\n(a|b) = 4\\,\\Re\\int_{f_{\\mathrm{low}}}^{f_{\\mathrm{cut}}} \\frac{a(f)\\,b^{\\ast}(f)}{S_n(f)}\\,df,\n$$\nwith the one-sided noise Power Spectral Density (PSD) $S_n(f) = S_0\\left[1 + \\left(\\frac{f_0}{f}\\right)^4\\right]$ and integration bounds $f_{\\mathrm{low}}$ and $f_{\\mathrm{cut}}$.\n\nThe network Signal-to-Noise Ratio (SNR) is defined by\n$$\n\\rho = \\sqrt{(h|h)}.\n$$\n\n2. Frequency-domain inspiral template and tidal phase\n\nWe adopt a simplified nonspinning inspiral template with amplitude $A f^{-7/6}$ and phase $\\psi(f)$ comprising leading point-mass terms at Newtonian order plus a leading-order tidal phase correction proportional to the effective tidal deformability $\\tilde{\\Lambda}$. The coalescence time $t_c$ and coalescence phase $\\phi_c$ are nuisance parameters. In geometric units $G=c=1$, the point-mass phase includes the Newtonian leading-order term characterized by the chirp mass $M_c$,\n$$\n\\psi_{\\mathrm{PM}}(f) = 2\\pi f t_c - \\phi_c + \\frac{3}{128}(\\pi M_c f)^{-5/3}.\n$$\nThe tidal phase at leading Post-Newtonian order is modeled as\n$$\n\\psi_{\\mathrm{tidal}}(f) = - K_{\\mathrm{tidal}}\\,\\tilde{\\Lambda}\\,(\\pi M f)^{5/3},\n$$\nwhere $K_{\\mathrm{tidal}} = 39/2$, $M = m_1 + m_2$ is the total mass, and $M_c = \\eta^{3/5} M$ is the chirp mass with symmetric mass ratio $\\eta = \\frac{m_1 m_2}{M^2}$. The effective tidal deformability for a black hole–neutron star system is\n$$\n\\tilde{\\Lambda} = \\frac{16}{13}\\,\\frac{\\left(m_2 + 12 m_1\\right)\\,m_2^4}{\\left(m_1 + m_2\\right)^5}\\,\\Lambda_{\\mathrm{NS}},\n$$\nwhich accounts for the mass dependence when the black hole has zero tidal deformability. All masses entering the phase must be converted to seconds via $m \\mapsto m \\times 4.92549094830932\\times 10^{-6}\\,\\mathrm{s}$ to ensure that $(\\pi M f)$ is dimensionless in radians.\n\nThe true black hole–neutron star waveform includes the tidal phase; the binary black hole template omits it. Thus,\n$$\nh_{\\mathrm{true}}(f) = A f^{-7/6} \\exp\\left[i\\left(\\psi_{\\mathrm{PM}}(f) + \\psi_{\\mathrm{tidal}}(f)\\right)\\right],\n\\quad\nh_{\\mathrm{BBH}}(f) = A f^{-7/6} \\exp\\left[i\\,\\psi_{\\mathrm{PM}}(f)\\right],\n$$\nand the waveform-model error is\n$$\n\\delta h(f) = h_{\\mathrm{true}}(f) - h_{\\mathrm{BBH}}(f) = A f^{-7/6} \\exp\\left[i\\,\\psi_{\\mathrm{PM}}(f)\\right]\\left[\\exp\\left(i\\,\\psi_{\\mathrm{tidal}}(f)\\right)-1\\right].\n$$\nIn the small-mismatch regime, $\\exp(i\\,\\psi_{\\mathrm{tidal}})\\approx 1+i\\,\\psi_{\\mathrm{tidal}}$, so $\\delta h\\approx i\\,\\psi_{\\mathrm{tidal}}\\,h_{\\mathrm{BBH}}$, but in our computation we will use the exact difference to form inner products, maintaining scientific realism.\n\n3. Amplitude normalization to achieve target SNR\n\nThe amplitude $A$ is fixed by the SNR requirement\n$$\n\\rho^2 = (h_{\\mathrm{BBH}}|h_{\\mathrm{BBH}}) = 4\\int_{f_{\\mathrm{low}}}^{f_{\\mathrm{cut}}} \\frac{A^2 f^{-7/3}}{S_n(f)}\\,df,\n$$\nso\n$$\nA = \\frac{\\rho}{\\sqrt{4\\int_{f_{\\mathrm{low}}}^{f_{\\mathrm{cut}}} \\frac{f^{-7/3}}{S_n(f)}\\,df}}.\n$$\n\n4. Fisher Information Matrix for $\\{\\tilde{\\Lambda}, \\phi_c, t_c\\}$\n\nUnder SPA, parameter derivatives of the template are obtained from $\\partial h / \\partial \\theta = i\\,(\\partial \\psi / \\partial \\theta)\\,h$. Specifically,\n- For the effective tidal deformability,\n$$\n\\frac{\\partial h}{\\partial \\tilde{\\Lambda}}(f) = i\\,\\frac{\\partial \\psi_{\\mathrm{tidal}}}{\\partial \\tilde{\\Lambda}}\\,h_{\\mathrm{BBH}}(f) = -i\\,K_{\\mathrm{tidal}}\\,(\\pi M f)^{5/3}\\,h_{\\mathrm{BBH}}(f).\n$$\n- For the coalescence phase,\n$$\n\\frac{\\partial h}{\\partial \\phi_c}(f) = -i\\,h_{\\mathrm{BBH}}(f).\n$$\n- For the coalescence time,\n$$\n\\frac{\\partial h}{\\partial t_c}(f) = i\\,2\\pi f\\,h_{\\mathrm{BBH}}(f).\n$$\n\nThe Fisher Information Matrix elements are\n$$\n\\Gamma_{ij} = \\left(\\frac{\\partial h}{\\partial \\theta_i} \\Bigg| \\frac{\\partial h}{\\partial \\theta_j}\\right) = 4\\,\\Re\\int_{f_{\\mathrm{low}}}^{f_{\\mathrm{cut}}} \\frac{1}{S_n(f)}\\left(\\frac{\\partial h}{\\partial \\theta_i}\\right)\\left(\\frac{\\partial h}{\\partial \\theta_j}\\right)^{\\ast}\\,df.\n$$\n\n5. Systematic bias in $\\tilde{\\Lambda}$ due to omitted tidal phase\n\nThe bias vector is\n$$\nb_j \\equiv \\left(\\delta h \\Bigg| \\frac{\\partial h}{\\partial \\theta_j}\\right) = 4\\,\\Re\\int_{f_{\\mathrm{low}}}^{f_{\\mathrm{cut}}} \\frac{\\delta h(f)\\,\\left[\\partial h(f)/\\partial \\theta_j\\right]^{\\ast}}{S_n(f)}\\,df.\n$$\nThe first-order bias solution is\n$$\n\\delta \\theta_i = \\sum_j \\left[\\Gamma^{-1}\\right]_{ij}\\,b_j.\n$$\nGiven that $\\delta h$ is exactly generated by the tidal phase difference, it is proportional to the derivative with respect to $\\tilde{\\Lambda}$, and one can show algebraically that in the linear regime $b_j = \\tilde{\\Lambda}\\,\\Gamma_{j\\tilde{\\Lambda}}$, implying\n$$\n\\delta \\tilde{\\Lambda} = \\tilde{\\Lambda},\n\\quad\n\\delta \\phi_c = 0,\n\\quad\n\\delta t_c = 0,\n$$\nindependent of the amplitude normalization and the cutoff frequency. Numerically, finite-band effects and using the exact $\\delta h$ maintain this result to within numerical precision, verifying the theoretical expectation. Thus, the estimator using a template that omits tides would be biased by the full value of the true $\\tilde{\\Lambda}$, i.e., would erroneously infer zero while the truth is nonzero.\n\n6. Statistical uncertainty and relative bias\n\nThe Gaussian statistical uncertainty on $\\tilde{\\Lambda}$ is read off from the inverse Fisher matrix,\n$$\n\\sigma_{\\tilde{\\Lambda}} = \\sqrt{\\left[\\Gamma^{-1}\\right]_{\\tilde{\\Lambda}\\tilde{\\Lambda}}}.\n$$\nSince the Fisher Information Matrix scales as the square of the amplitude (and thus as $\\rho^2$), one has $\\sigma_{\\tilde{\\Lambda}}\\propto 1/\\rho$. Therefore, the relative bias defined by\n$$\nb_{\\mathrm{rel}} = \\frac{|\\delta \\tilde{\\Lambda}|}{\\sigma_{\\tilde{\\Lambda}}}\n$$\nscales approximately linearly with $\\rho$ and depends on the frequency band through the structure of $\\Gamma$ set by $f_{\\mathrm{cut}}$.\n\n7. Algorithmic steps\n\n- Convert masses $m_1$ and $m_2$ from solar masses to seconds using $M_{\\odot} c^{-3} G \\approx 4.92549094830932\\times 10^{-6}\\,\\mathrm{s}$. Compute $M$, $\\eta$, $M_c$, and then $\\tilde{\\Lambda}$ using the provided formula and $\\Lambda_{\\mathrm{NS}}$.\n- Build a dense frequency grid on $[f_{\\mathrm{low}}, f_{\\mathrm{cut}}]$ in Hertz.\n- Construct $S_n(f)$ on the grid, and compute the amplitude normalization $A$ to satisfy the target SNR $\\rho$ by integrating $f^{-7/3}/S_n(f)$ over the band.\n- Form $h_{\\mathrm{BBH}}(f)$ and compute the parameter derivatives $\\partial h/\\partial \\tilde{\\Lambda}$, $\\partial h/\\partial \\phi_c$, and $\\partial h/\\partial t_c$.\n- Assemble the Fisher Information Matrix $\\Gamma$ by inner products of derivatives.\n- Construct $h_{\\mathrm{true}}(f)$ including the tidal phase, and compute $\\delta h(f) = h_{\\mathrm{true}}(f) - h_{\\mathrm{BBH}}(f)$.\n- Compute the bias vector $b$ via inner products $(\\delta h | \\partial h/\\partial \\theta_j)$, and solve $\\delta \\theta = \\Gamma^{-1} b$. Extract $\\delta \\tilde{\\Lambda}$.\n- Compute $\\sigma_{\\tilde{\\Lambda}} = \\sqrt{\\left[\\Gamma^{-1}\\right]_{\\tilde{\\Lambda}\\tilde{\\Lambda}}}$ and $b_{\\mathrm{rel}}$.\n- Repeat for the test suite cases and output the results in the requested format with six-decimal rounding.\n\n8. Units and output\n\n- Frequency $f$ is in Hertz, angles are in radians, masses in seconds when entering the phase via $\\pi M f$, and tidal deformabilities are dimensionless.\n- The final output must be a single line string containing a comma-separated list of four inner lists, one per test case, each with two floats $[\\delta \\tilde{\\Lambda}, b_{\\mathrm{rel}}]$, rounded to six decimal places.\n\nThis design integrates core definitions of matched filtering and Fisher-matrix theory with a scientifically realistic inspiral waveform model, producing a quantifiable and testable computation of systematic biases and their relative impact as functions of Signal-to-Noise Ratio and cutoff frequency.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Constants\nM_sun_sec = 4.92549094830932e-6  # G*M_sun/c^3 in seconds\nK_tidal = 39.0 / 2.0             # Leading-order tidal phase coefficient\nS0 = 1.0\nf0 = 50.0                        # Hz\nf_low = 20.0                     # Hz\n\ndef psd(f):\n    # One-sided PSD model\n    return S0 * (1.0 + (f0 / f) ** 4)\n\ndef effective_lambda_tilde(m1_solar, m2_solar, Lambda_NS):\n    # Effective tidal deformability tilde{Lambda} for BH-NS\n    m1 = m1_solar\n    m2 = m2_solar\n    M = m1 + m2\n    num = (m2 + 12.0 * m1) * (m2 ** 4)\n    den = M ** 5\n    return (16.0 / 13.0) * (num / den) * Lambda_NS\n\ndef masses_in_seconds(m1_solar, m2_solar):\n    m1_sec = m1_solar * M_sun_sec\n    m2_sec = m2_solar * M_sun_sec\n    M_sec = (m1_solar + m2_solar) * M_sun_sec\n    eta = (m1_solar * m2_solar) / ((m1_solar + m2_solar) ** 2)\n    Mc_sec = (eta ** (3.0 / 5.0)) * M_sec\n    return m1_sec, m2_sec, M_sec, Mc_sec, eta\n\ndef compute_amplitude_for_snr(rho, f_grid, Sn):\n    integrand = (f_grid ** (-7.0 / 3.0)) / Sn\n    norm = 4.0 * np.trapz(integrand, f_grid)\n    A = rho / np.sqrt(norm)\n    return A\n\ndef build_waveform(f_grid, A, Mc_sec, M_sec, tc=0.0, phic=0.0, lambda_tilde=0.0):\n    # Phase terms\n    psi_pm = 2.0 * np.pi * f_grid * tc - phic + (3.0 / 128.0) * (np.pi * Mc_sec * f_grid) ** (-5.0 / 3.0)\n    psi_tidal = - K_tidal * lambda_tilde * (np.pi * M_sec * f_grid) ** (5.0 / 3.0)\n    h = A * f_grid ** (-7.0 / 6.0) * np.exp(1j * (psi_pm + psi_tidal))\n    return h, psi_pm, psi_tidal\n\ndef derivatives(h_bbh, f_grid, M_sec):\n    # Derivatives w.r.t. [lambda_tilde, phi_c, t_c]\n    dpsi_dlambda = - K_tidal * (np.pi * M_sec * f_grid) ** (5.0 / 3.0)\n    dh_dlambda = 1j * dpsi_dlambda * h_bbh\n    dh_dphic = -1j * h_bbh\n    dh_dtc = 1j * 2.0 * np.pi * f_grid * h_bbh\n    return dh_dlambda, dh_dphic, dh_dtc\n\ndef inner_product(a, b, f_grid, Sn):\n    integrand = a * np.conj(b) / Sn\n    val = 4.0 * np.trapz(integrand, f_grid)\n    return np.real(val)\n\ndef fisher_matrix(derivs, f_grid, Sn):\n    n = len(derivs)\n    Gamma = np.zeros((n, n), dtype=float)\n    for i in range(n):\n        for j in range(n):\n            Gamma[i, j] = inner_product(derivs[i], derivs[j], f_grid, Sn)\n    return Gamma\n\ndef bias_vector(delta_h, derivs, f_grid, Sn):\n    b = np.array([inner_product(delta_h, d, f_grid, Sn) for d in derivs], dtype=float)\n    return b\n\ndef solve_case(m1_solar, m2_solar, Lambda_NS, rho, f_cut):\n    # Frequency grid\n    f_grid = np.linspace(f_low, f_cut, 20000)\n    Sn = psd(f_grid)\n\n    # Masses and tidal parameter\n    _, _, M_sec, Mc_sec, _ = masses_in_seconds(m1_solar, m2_solar)\n    lambda_tilde = effective_lambda_tilde(m1_solar, m2_solar, Lambda_NS)\n\n    # Amplitude to meet target SNR using BBH template\n    A = compute_amplitude_for_snr(rho, f_grid, Sn)\n\n    # Build BBH waveform (lambda_tilde=0) and true waveform (with tidal)\n    h_bbh, psi_pm, _ = build_waveform(f_grid, A, Mc_sec, M_sec, tc=0.0, phic=0.0, lambda_tilde=0.0)\n    h_true, _, _ = build_waveform(f_grid, A, Mc_sec, M_sec, tc=0.0, phic=0.0, lambda_tilde=lambda_tilde)\n\n    # Derivatives\n    dh_dlambda, dh_dphic, dh_dtc = derivatives(h_bbh, f_grid, M_sec)\n    derivs = [dh_dlambda, dh_dphic, dh_dtc]\n\n    # Fisher matrix\n    Gamma = fisher_matrix(derivs, f_grid, Sn)\n\n    # Bias vector using exact delta h\n    delta_h = h_true - h_bbh\n    b = bias_vector(delta_h, derivs, f_grid, Sn)\n\n    # Solve for parameter biases\n    try:\n        Gamma_inv = np.linalg.inv(Gamma)\n    except np.linalg.LinAlgError:\n        # Regularize if singular; add small diagonal jitter\n        jitter = 1e-12\n        Gamma_inv = np.linalg.inv(Gamma + jitter * np.eye(Gamma.shape[0]))\n    delta_theta = Gamma_inv @ b\n\n    delta_lambda = float(delta_theta[0])\n    sigma_lambda = float(np.sqrt(Gamma_inv[0, 0]))\n    rel_bias = abs(delta_lambda) / sigma_lambda if sigma_lambda > 0 else np.inf\n\n    return delta_lambda, rel_bias\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (rho, f_cut)\n    m1_solar = 7.0\n    m2_solar = 1.4\n    Lambda_NS = 200.0\n\n    test_cases = [\n        (10.0, 400.0),  # Case A\n        (25.0, 600.0),  # Case B\n        (50.0, 800.0),  # Case C\n        (8.0, 350.0),   # Edge Case D\n    ]\n\n    results = []\n    for rho, f_cut in test_cases:\n        delta_lambda, rel_bias = solve_case(m1_solar, m2_solar, Lambda_NS, rho, f_cut)\n        # Round to six decimal places\n        results.append([round(delta_lambda, 6), round(rel_bias, 6)])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(item) for item in results)}]\")\n\nsolve()\n```", "id": "3466318"}, {"introduction": "Following a BH-NS merger that produces ejecta, the resulting electromagnetic signal, known as a kilonova, is powered by the radioactive decay of heavy elements synthesized in the outflow. The composition of this ejecta, and thus the kilonova's characteristics, is critically set by neutrino interactions that determine the final electron fraction $Y_e$ [@problem_id:3466361]. In this practice, you will model the thermodynamic and compositional evolution of an outflow streamline by implementing and comparing two different approximate neutrino transport schemes, directly connecting the microphysics of the post-merger environment to predictions for multi-messenger observables.", "problem": "Consider a simplified, first-principles comparison between two approximate neutrino radiation treatments for outflows from a post-merger accretion disk produced in a black hole–neutron star merger: a neutrino leakage prescription versus a two-moment (M1) transport-inspired prescription. Assume the outflow can be modeled as a one-dimensional streamline at fixed polar angle with an initial radius and a prescribed expansion law. The goal is to predict and compare the evolution of the electron fraction and the neutrino-driven thermal acceleration along the streamline under the two prescriptions, and to infer the implied kilonova opacities. All computations must be done in the International System of Units (SI), except for any intermediate neutrino energies that may be provided in mega-electronvolts, which must be converted to joules inside the program. Angles must be treated in degrees as inputs but converted to radians for any trigonometric functions.\n\nFundamental base:\n- Conservation of lepton number: along a fluid worldline, the evolution of the electron fraction $Y_e$ is governed by charged-current weak interactions, dominated by electron neutrino absorption on neutrons and electron antineutrino absorption on protons in these conditions. A minimal model uses\n$$\n\\frac{dY_e}{dt} = \\lambda_{\\nu_e}(1 - Y_e) - \\lambda_{\\bar{\\nu}_e} Y_e \\, ,\n$$\nwhere $\\lambda_{\\nu_e}$ and $\\lambda_{\\bar{\\nu}_e}$ are the absorption rates per baryon for electron neutrinos and electron antineutrinos, respectively.\n- Neutrino absorption rates: for a neutrino mean energy $\\langle \\epsilon \\rangle$, mean luminosity $L$, and distance $r$, the number flux is $F_{\\nu} = L/(4 \\pi r^2 \\langle \\epsilon \\rangle)$. The absorption cross section on nucleons scales as $\\sigma = \\sigma_0 \\left(\\langle \\epsilon \\rangle/\\mathrm{MeV}\\right)^2$, with $\\sigma_0$ a known constant; therefore,\n$$\n\\lambda_{\\nu} = F_{\\nu} \\, \\sigma_0 \\left(\\frac{\\langle \\epsilon \\rangle}{\\mathrm{MeV}}\\right)^2 \\, ,\n$$\nwith appropriate attenuation and angular factors for transport.\n- Specific heating rate: the specific thermal energy deposition rate per unit mass from neutrino absorption is\n$$\n\\frac{d e_{\\mathrm{heat}}}{dt} = \\frac{ \\lambda_{\\nu_e}(1 - Y_e)\\langle \\epsilon_{\\nu_e} \\rangle + \\lambda_{\\bar{\\nu}_e} Y_e \\langle \\epsilon_{\\bar{\\nu}_e} \\rangle}{m_b} \\, ,\n$$\nwhere $m_b$ is the baryon mass, interpreted here as the nucleon mass.\n- Escape condition and asymptotic velocity: if the cumulative specific neutrino heating $e_{\\mathrm{heat}}(t)$ exceeds the Newtonian gravitational binding at the launch radius $r_0$, the outflow asymptotic speed can be estimated by\n$$\nv_{\\infty} = \\sqrt{ 2 \\, \\max\\left( 0, \\, e_{\\mathrm{heat}}(t_{\\mathrm{end}}) - \\frac{G M_{\\mathrm{BH}}}{r_0} \\right) } \\, ,\n$$\nwhere $G$ is the gravitational constant, $M_{\\mathrm{BH}}$ the black hole mass, and $t_{\\mathrm{end}}$ a final integration time.\n- Kilonova opacity proxy: the gray opacity is taken to be a piecewise constant function of the final electron fraction $Y_e(t_{\\mathrm{end}})$ along the streamline,\n$$\n\\kappa(Y_e) = \\begin{cases}\n10.0 \\, \\mathrm{cm}^2\\,\\mathrm{g}^{-1},  Y_e  0.25, \\\\\n1.0 \\, \\mathrm{cm}^2\\,\\mathrm{g}^{-1},  Y_e \\ge 0.25. \\\\\n\\end{cases}\n$$\n\nTransport prescriptions to implement:\n- Neutrino leakage: attenuation is modeled by an optical depth factor $\\mathcal{T}_{\\mathrm{leak}}(r) = \\exp\\left[-\\tau(r)\\right]$.\n- M1-inspired transport: attenuation is modeled by a flux-limited transmission factor $\\mathcal{T}_{\\mathrm{M1}}(r) = \\frac{1 - \\exp[-\\tau(r)]}{\\tau(r)}$, and an angular beaming factor $g(\\theta) = a + (1-a)\\cos^2\\theta$, with $a = 0.25$ and $\\theta$ the polar angle. Thus, the M1-inspired flux multiplier is $g(\\theta)\\,\\mathcal{T}_{\\mathrm{M1}}(r)$.\n\nOptical depth model and streamline:\n- Optical depth profile: let $\\tau(r) = \\tau_0 \\left( \\frac{r_0}{r} \\right)^p$, where $\\tau_0$ and $p$ are given parameters.\n- Streamline kinematics: adopt a homologous expansion law $r(t) = r_0 \\left(1 + \\frac{t}{\\tau_{\\mathrm{exp}}} \\right)$, where $\\tau_{\\mathrm{exp}}$ is an expansion timescale. The final time should be $t_{\\mathrm{end}} = 5 \\, \\tau_{\\mathrm{exp}}$.\n\nConstants and units:\n- Use $G = 6.67430 \\times 10^{-11} \\, \\mathrm{m}^3\\,\\mathrm{kg}^{-1}\\,\\mathrm{s}^{-2}$, $c = 2.99792458 \\times 10^8 \\, \\mathrm{m}\\,\\mathrm{s}^{-1}$ (only if needed to bound velocities), $m_b = 1.674 \\times 10^{-27} \\, \\mathrm{kg}$, and $\\sigma_0 = 9.6 \\times 10^{-48} \\, \\mathrm{m}^2$ per $(\\mathrm{MeV})^{-2}$. One mega-electronvolt must be converted using $1 \\, \\mathrm{MeV} = 1.602176634 \\times 10^{-13} \\, \\mathrm{J}$.\n- All outputs involving speed must be in $\\mathrm{m}\\,\\mathrm{s}^{-1}$.\n- All angles in inputs are in degrees and must be converted to radians for trigonometric functions.\n\nAlgorithmic tasks to implement:\n1. For a given parameter set, integrate the coupled system for $Y_e(t)$ and $e_{\\mathrm{heat}}(t)$ from $t = 0$ to $t = t_{\\mathrm{end}}$ using a numerically stable, fixed-step fourth-order Runge–Kutta method. The right-hand sides depend on $r(t)$, $\\tau(r)$, and the chosen transport prescription through the transmission and beaming factors applied to the number fluxes. Use the same time step for both transport prescriptions to ensure comparability.\n2. For both prescriptions, compute $Y_e(t_{\\mathrm{end}})$, $e_{\\mathrm{heat}}(t_{\\mathrm{end}})$, $v_{\\infty}$, and the opacity $\\kappa$ from the piecewise definition above.\n3. To avoid division-by-zero in the M1 transmission factor for $\\tau \\to 0$, use the correct small-$\\tau$ limit $\\lim_{\\tau \\to 0} \\frac{1 - e^{-\\tau}}{\\tau} = 1$.\n\nParameters for the test suite:\nFor each test case below, the tuple is $(M_{\\mathrm{BH}}, L_{\\nu_e}, L_{\\bar{\\nu}_e}, \\langle \\epsilon_{\\nu_e} \\rangle, \\langle \\epsilon_{\\bar{\\nu}_e} \\rangle, r_0, \\tau_0, p, \\theta, \\tau_{\\mathrm{exp}}, Y_{e,0})$, with the following units:\n- $M_{\\mathrm{BH}}$ in $\\mathrm{kg}$,\n- $L_{\\nu_e}$ and $L_{\\bar{\\nu}_e}$ in $\\mathrm{W}$,\n- $\\langle \\epsilon_{\\nu_e} \\rangle$ and $\\langle \\epsilon_{\\bar{\\nu}_e} \\rangle$ in $\\mathrm{MeV}$,\n- $r_0$ in $\\mathrm{m}$,\n- $\\tau_0$ and $p$ dimensionless,\n- $\\theta$ in degrees,\n- $\\tau_{\\mathrm{exp}}$ in $\\mathrm{s}$,\n- $Y_{e,0}$ dimensionless and constrained to $[0,1]$.\n\nUse the following four cases that probe typical, polar, equatorial, and threshold-like conditions:\n- Case A (typical): $(M_{\\mathrm{BH}} = 1.3916 \\times 10^{31}, \\ L_{\\nu_e} = 4.0 \\times 10^{45}, \\ L_{\\bar{\\nu}_e} = 5.0 \\times 10^{45}, \\ \\langle \\epsilon_{\\nu_e} \\rangle = 11.0, \\ \\langle \\epsilon_{\\bar{\\nu}_e} \\rangle = 14.0, \\ r_0 = 1.20 \\times 10^{5}, \\ \\tau_0 = 5.0, \\ p = 1.5, \\ \\theta = 20.0, \\ \\tau_{\\mathrm{exp}} = 5.0 \\times 10^{-2}, \\ Y_{e,0} = 0.05)$.\n- Case B (polar, optically thin): $(M_{\\mathrm{BH}} = 1.193 \\times 10^{31}, \\ L_{\\nu_e} = 6.0 \\times 10^{45}, \\ L_{\\bar{\\nu}_e} = 7.0 \\times 10^{45}, \\ \\langle \\epsilon_{\\nu_e} \\rangle = 12.0, \\ \\langle \\epsilon_{\\bar{\\nu}_e} \\rangle = 15.0, \\ r_0 = 8.0 \\times 10^{4}, \\ \\tau_0 = 1.0, \\ p = 1.5, \\ \\theta = 10.0, \\ \\tau_{\\mathrm{exp}} = 3.0 \\times 10^{-2}, \\ Y_{e,0} = 0.10)$.\n- Case C (equatorial, optically thick): $(M_{\\mathrm{BH}} = 1.789 \\times 10^{31}, \\ L_{\\nu_e} = 3.0 \\times 10^{45}, \\ L_{\\bar{\\nu}_e} = 3.5 \\times 10^{45}, \\ \\langle \\epsilon_{\\nu_e} \\rangle = 10.0, \\ \\langle \\epsilon_{\\bar{\\nu}_e} \\rangle = 13.0, \\ r_0 = 1.50 \\times 10^{5}, \\ \\tau_0 = 10.0, \\ p = 1.5, \\ \\theta = 75.0, \\ \\tau_{\\mathrm{exp}} = 8.0 \\times 10^{-2}, \\ Y_{e,0} = 0.03)$.\n- Case D (near-opacity-threshold): $(M_{\\mathrm{BH}} = 1.5904 \\times 10^{31}, \\ L_{\\nu_e} = 4.0 \\times 10^{45}, \\ L_{\\bar{\\nu}_e} = 4.0 \\times 10^{45}, \\ \\langle \\epsilon_{\\nu_e} \\rangle = 12.0, \\ \\langle \\epsilon_{\\bar{\\nu}_e} \\rangle = 12.0, \\ r_0 = 1.00 \\times 10^{5}, \\ \\tau_0 = 3.0, \\ p = 1.5, \\ \\theta = 45.0, \\ \\tau_{\\mathrm{exp}} = 6.0 \\times 10^{-2}, \\ Y_{e,0} = 0.20)$.\n\nProgram requirements:\n- Implement both transport prescriptions exactly as described. For the M1-inspired prescription, include the angular factor $g(\\theta) = 0.25 + 0.75 \\cos^2 \\theta$ with $\\theta$ in radians inside the cosine.\n- Use a fixed-step fourth-order Runge–Kutta time integrator over $t \\in [0, 5 \\tau_{\\mathrm{exp}}]$ with at least $N = 2000$ time steps per case to ensure numerical stability and convergence for these parameters.\n- To avoid unphysical values, enforce $Y_e \\in [0, 1]$ during integration by clipping after each step, and cap $v_{\\infty}$ at $0.5 \\, c$ if necessary.\n\nFinal output format:\n- For each test case, compute the list $[Y_{e,\\mathrm{leak}}, Y_{e,\\mathrm{M1}}, v_{\\infty,\\mathrm{leak}}, v_{\\infty,\\mathrm{M1}}, \\kappa_{\\mathrm{leak}}, \\kappa_{\\mathrm{M1}}]$, where $v_{\\infty}$ is in $\\mathrm{m}\\,\\mathrm{s}^{-1}$ and $\\kappa$ in $\\mathrm{cm}^2\\,\\mathrm{g}^{-1}$. Your program should produce a single line of output containing the results as a comma-separated Python-style list of these per-case lists, in the order of the test suite above. For example, the output must look like:\n\"[ [caseA_results], [caseB_results], [caseC_results], [caseD_results] ]\" with numerical entries.", "solution": "The user has provided a valid, well-posed, and scientifically grounded problem. I will now proceed with a complete solution.\n\nThe problem requires the numerical integration of a simplified model for the evolution of matter in an outflow from a black hole-neutron star merger accretion disk. The goal is to compare two approximate treatments of neutrino radiation transport—a leakage scheme and a two-moment (M1) inspired scheme—by calculating the final electron fraction $Y_e$, the asymptotic outflow velocity $v_{\\infty}$, and the resulting kilonova opacity $\\kappa$.\n\nThe core of the problem is to solve a system of coupled first-order ordinary differential equations (ODEs) for the electron fraction $Y_e$ and the specific thermal energy $e_{\\mathrm{heat}}$ along a one-dimensional fluid streamline. The state of the system can be represented by a vector $\\vec{y}(t) = [Y_e(t), e_{\\mathrm{heat}}(t)]^T$. The evolution is governed by:\n$$\n\\frac{d\\vec{y}}{dt} = \\vec{f}(t, \\vec{y})\n$$\n\n### 1. Physical Model and Governing Equations\n\nThe right-hand side, $\\vec{f}(t, \\vec{y})$, is determined by the underlying physics of neutrino interactions and the prescribed kinematics of the outflow.\n\n**Evolution of Electron Fraction, $Y_e$:**\nThe electron fraction, which is the number of protons per baryon, changes due to charged-current weak interactions with electron neutrinos ($\\nu_e$) and electron antineutrinos ($\\bar{\\nu}_e$):\n$$\n\\text{1. } \\nu_e + n \\rightarrow p + e^-\n$$\n$$\n\\text{2. } \\bar{\\nu}_e + p \\rightarrow n + e^+\n$$\nThe rate of change of $Y_e$ is given by:\n$$\n\\frac{dY_e}{dt} = \\lambda_{\\nu_e}(1 - Y_e) - \\lambda_{\\bar{\\nu}_e} Y_e\n$$\nwhere $\\lambda_{\\nu_e}$ and $\\lambda_{\\bar{\\nu}_e}$ are the absorption rates of $\\nu_e$ on neutrons and $\\bar{\\nu}_e$ on protons, respectively. The term $(1-Y_e)$ is the neutron fraction and $Y_e$ is the proton fraction.\n\n**Evolution of Specific Thermal Energy, $e_{\\mathrm{heat}}$:**\nThe same neutrino absorptions deposit energy into the fluid, increasing its thermal energy content. The specific heating rate (energy per unit mass per unit time) is:\n$$\n\\frac{de_{\\mathrm{heat}}}{dt} = \\frac{ \\lambda_{\\nu_e}(1 - Y_e)\\langle \\epsilon_{\\nu_e} \\rangle + \\lambda_{\\bar{\\nu}_e} Y_e \\langle \\epsilon_{\\bar{\\nu}_e} \\rangle}{m_b}\n$$\nwhere $m_b$ is the baryon mass and $\\langle \\epsilon_{\\nu} \\rangle$ is the mean energy of a given neutrino species, which must be in SI units (Joules) for this equation.\n\n**Neutrino Absorption Rates, $\\lambda_{\\nu}$:**\nThe absorption rate depends on the neutrino number flux $F_\\nu$ and the interaction cross-section $\\sigma$. The problem provides that $\\sigma$ is proportional to the square of the neutrino energy, $\\sigma = \\sigma_0 (\\langle \\epsilon \\rangle / \\mathrm{MeV})^2$. The number flux at a distance $r$ from a source with luminosity $L$ is $F_{\\nu} = L/(4 \\pi r^2 \\langle \\epsilon \\rangle)$. Combining these, and accounting for the necessary unit conversions, the absorption rate is:\n$$\n\\lambda_{\\nu} = F_{\\nu} \\sigma = \\frac{L}{4 \\pi r^2 \\langle \\epsilon \\rangle_{\\mathrm{J}}} \\sigma_0 \\left(\\frac{\\langle \\epsilon \\rangle_{\\mathrm{MeV}}}{\\mathrm{MeV}}\\right)^2\n$$\nSince $\\langle \\epsilon \\rangle_{\\mathrm{J}} = \\langle \\epsilon \\rangle_{\\mathrm{MeV}} \\times (1.602... \\times 10^{-13} \\mathrm{J/MeV})$, the rate simplifies to:\n$$\n\\lambda_{\\nu} = \\left( \\frac{\\sigma_0}{4 \\pi (E_{\\mathrm{MeV\\rightarrow J}})} \\right) \\frac{L \\langle \\epsilon \\rangle_{\\mathrm{MeV}}}{r^2}\n$$\nThis rate is then modified by a dimensionless factor that accounts for the transport prescription (attenuation and beaming effects).\n\n### 2. Streamline Kinematics and Transport Prescriptions\n\nThe problem specifies a simple kinematic model for the outflow.\n\n**Streamline Model:**\nThe fluid parcel moves along a radial trajectory with a homologous expansion law:\n$$\nr(t) = r_0 \\left(1 + \\frac{t}{\\tau_{\\mathrm{exp}}} \\right)\n$$\nwhere $r_0$ is the initial radius and $\\tau_{\\mathrm{exp}}$ is the expansion timescale. The neutrino optical depth along this path is modeled as a power-law in radius:\n$$\n\\tau(r) = \\tau_0 \\left( \\frac{r_0}{r} \\right)^p\n$$\n\n**Transport Prescriptions:**\nThe two prescriptions modify the effective neutrino flux through a multiplier, $\\mathcal{M}$. The full absorption rate is $\\lambda_{\\nu} = \\mathcal{M} \\times \\lambda_{\\nu, \\mathrm{free}}$, where $\\lambda_{\\nu, \\mathrm{free}}$ is the free-streaming rate calculated above.\n\n- **Neutrino Leakage:** This model uses a simple exponential attenuation factor.\n  $$\n  \\mathcal{M}_{\\mathrm{leak}} = \\mathcal{T}_{\\mathrm{leak}}(r) = \\exp\\left[-\\tau(r)\\right]\n  $$\n  This factor transitions from $0$ in the optically thick limit ($\\tau \\gg 1$) to $1$ in the optically thin limit ($\\tau \\ll 1$).\n\n- **M1-inspired Transport:** This model incorporates a more physically motivated flux-limited diffusion behavior and angular dependence.\n  $$\n  \\mathcal{M}_{\\mathrm{M1}} = g(\\theta)\\,\\mathcal{T}_{\\mathrm{M1}}(r)\n  $$\n  The transmission factor $\\mathcal{T}_{\\mathrm{M1}}(r)$ is given by:\n  $$\n  \\mathcal{T}_{\\mathrm{M1}}(r) = \\frac{1 - \\exp[-\\tau(r)]}{\\tau(r)}\n  $$\n  For numerical stability, we use its limit, $\\lim_{\\tau \\to 0} \\mathcal{T}_{\\mathrm{M1}} = 1$. The angular beaming factor $g(\\theta)$ accounts for the polar-angle-dependent emission from the disk, with $a=0.25$:\n  $$\n  g(\\theta) = a + (1-a)\\cos^2\\theta = 0.25 + 0.75\\cos^2\\theta\n  $$\n  where $\\theta$ must be in radians.\n\n### 3. Numerical Integration\n\nThe system of ODEs is solved numerically using the fixed-step, fourth-order Runge-Kutta (RK4) method. Given the state $\\vec{y}_n$ at time $t_n$, the state at $t_{n+1} = t_n + \\Delta t$ is found by:\n$$\n\\begin{align*}\n\\vec{k}_1 = \\vec{f}(t_n, \\vec{y}_n) \\\\\n\\vec{k}_2 = \\vec{f}(t_n + \\frac{\\Delta t}{2}, \\vec{y}_n + \\frac{\\Delta t}{2} \\vec{k}_1) \\\\\n\\vec{k}_3 = \\vec{f}(t_n + \\frac{\\Delta t}{2}, \\vec{y}_n + \\frac{\\Delta t}{2} \\vec{k}_2) \\\\\n\\vec{k}_4 = \\vec{f}(t_n + \\Delta t, \\vec{y}_n + \\Delta t \\vec{k}_3) \\\\\n\\vec{y}_{n+1} = \\vec{y}_n + \\frac{\\Delta t}{6}(\\vec{k}_1 + 2\\vec{k}_2 + 2\\vec{k}_3 + \\vec{k}_4)\n\\end{align*}\n$$\nThe integration is performed from $t=0$ to $t_{\\mathrm{end}} = 5 \\tau_{\\mathrm{exp}}$ with $N=2000$ steps, so $\\Delta t = t_{\\mathrm{end}}/N$. The initial conditions are $\\vec{y}(0) = [Y_{e,0}, 0]^T$. After each RK4 step, the electron fraction $Y_e$ is clipped to the physically meaningful range $[0, 1]$.\n\n### 4. Final Observables\n\nAfter integrating to $t_{\\mathrm{end}}$, we compute the final quantities for each transport prescription.\n\n- **Asymptotic Velocity, $v_{\\infty}$:** The total specific energy deposited, $e_{\\mathrm{heat}}(t_{\\mathrm{end}})$, is compared to the specific gravitational binding energy at the launch radius, $E_g = \\frac{G M_{\\mathrm{BH}}}{r_0}$. The excess energy is converted to kinetic energy.\n  $$\n  v_{\\infty} = \\sqrt{ 2 \\cdot \\max\\left( 0, \\, e_{\\mathrm{heat}}(t_{\\mathrm{end}}) - \\frac{G M_{\\mathrm{BH}}}{r_0} \\right) }\n  $$\n  The velocity is capped at $0.5c$ to respect a physical limit, where $c$ is the speed of light.\n\n- **Kilonova Opacity, $\\kappa$:** The final electron fraction $Y_e(t_{\\mathrm{end}})$ determines the composition of the outflow and, consequently, its opacity to electromagnetic radiation. A simplified piecewise model is used:\n  $$\n  \\kappa(Y_e) = \\begin{cases}\n  10.0 \\ \\mathrm{cm}^2\\,\\mathrm{g}^{-1},  \\text{if } Y_e(t_{\\mathrm{end}})  0.25 \\text{ (lanthanide-rich)} \\\\\n  1.0 \\ \\mathrm{cm}^2\\,\\mathrm{g}^{-1},   \\text{if } Y_e(t_{\\mathrm{end}}) \\ge 0.25 \\text{ (lanthanide-poor)}\n  \\end{cases}\n  $$\n\nThe algorithm is implemented for each test case, and the six resulting values—$[Y_{e,\\mathrm{leak}}, Y_{e,\\mathrm{M1}}, v_{\\infty,\\mathrm{leak}}, v_{\\infty,\\mathrm{M1}}, \\kappa_{\\mathrm{leak}}, \\kappa_{\\mathrm{M1}}]$—are collected.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of neutrino-driven outflow evolution for a set of test cases.\n    It integrates the equations for electron fraction and thermal energy using RK4,\n    compares two transport prescriptions (leakage vs. M1), and computes final\n    outflow properties.\n    \"\"\"\n    # Define physical and conversion constants in SI units.\n    G = 6.67430e-11  # Gravitational constant in m^3 kg^-1 s^-2\n    C = 2.99792458e8  # Speed of light in m/s\n    M_B = 1.674e-27  # Baryon mass in kg\n    SIGMA_0 = 9.6e-48  # Cross-section constant in m^2 / MeV^2\n    MEV_TO_J = 1.602176634e-13  # MeV to Joules conversion factor\n\n    # Pre-calculate a constant factor for the absorption rate calculation\n    # This factor is LAMBDA_CONST = SIGMA_0 / (4 * pi * MEV_TO_J)\n    LAMBDA_CONST = SIGMA_0 / (4 * np.pi * MEV_TO_J)\n\n    constants = {\n        \"G\": G, \"C\": C, \"M_B\": M_B, \"LAMBDA_CONST\": LAMBDA_CONST, \"MEV_TO_J\": MEV_TO_J\n    }\n\n    # Define the test cases as per the problem statement.\n    # Tuple format: (M_BH, L_nue, L_nubar, eps_nue, eps_nubar, r0, tau0, p, theta, tau_exp, Ye0)\n    test_cases = [\n        # Case A (typical)\n        (1.3916e31, 4.0e45, 5.0e45, 11.0, 14.0, 1.20e5, 5.0, 1.5, 20.0, 5.0e-2, 0.05),\n        # Case B (polar, optically thin)\n        (1.193e31, 6.0e45, 7.0e45, 12.0, 15.0, 8.0e4, 1.0, 1.5, 10.0, 3.0e-2, 0.10),\n        # Case C (equatorial, optically thick)\n        (1.789e31, 3.0e45, 3.5e45, 10.0, 13.0, 1.50e5, 10.0, 1.5, 75.0, 8.0e-2, 0.03),\n        # Case D (near-opacity-threshold)\n        (1.5904e31, 4.0e45, 4.0e45, 12.0, 12.0, 1.00e5, 3.0, 1.5, 45.0, 6.0e-2, 0.20),\n    ]\n\n    def derivatives(t, y, params, prescription, consts):\n        \"\"\"\n        Calculates the time derivatives of the state vector [Ye, e_heat].\n        \"\"\"\n        Ye, _ = y\n        M_BH, L_nue, L_nubar, eps_nue_mev, eps_nubar_mev, r0, tau0, p, theta_deg, tau_exp, _ = params\n        \n        # 1. Calculate current kinematics and optical depth\n        r = r0 * (1 + t / tau_exp)\n        tau = tau0 * (r0 / r)**p\n\n        # 2. Calculate the transport multiplier\n        if prescription == 'leakage':\n            multiplier = np.exp(-tau)\n        elif prescription == 'm1':\n            if abs(tau)  1e-9:  # Small-tau limit for M1 transmission factor\n                T_m1 = 1.0\n            else:\n                T_m1 = (1 - np.exp(-tau)) / tau\n            \n            theta_rad = np.deg2rad(theta_deg)\n            g_theta = 0.25 + 0.75 * np.cos(theta_rad)**2\n            multiplier = g_theta * T_m1\n        else:\n            raise ValueError(\"Unknown prescription\")\n\n        # 3. Calculate neutrino absorption rates\n        # rate = multiplier * (LAMBDA_CONST * L * eps_MeV / r^2)\n        lambda_nue = multiplier * consts[\"LAMBDA_CONST\"] * L_nue * eps_nue_mev / r**2\n        lambda_nubar = multiplier * consts[\"LAMBDA_CONST\"] * L_nubar * eps_nubar_mev / r**2\n        \n        # 4. Calculate derivatives\n        dYe_dt = lambda_nue * (1 - Ye) - lambda_nubar * Ye\n        \n        eps_nue_j = eps_nue_mev * consts[\"MEV_TO_J\"]\n        eps_nubar_j = eps_nubar_mev * consts[\"MEV_TO_J\"]\n        de_heat_dt = (lambda_nue * (1 - Ye) * eps_nue_j + lambda_nubar * Ye * eps_nubar_j) / consts[\"M_B\"]\n        \n        return np.array([dYe_dt, de_heat_dt])\n\n    def rk4_step(func, t, y, dt, params, prescription, consts):\n        \"\"\"\n        Performs a single step of the fourth-order Runge-Kutta method.\n        \"\"\"\n        k1 = func(t, y, params, prescription, consts)\n        k2 = func(t + 0.5 * dt, y + 0.5 * dt * k1, params, prescription, consts)\n        k3 = func(t + 0.5 * dt, y + 0.5 * dt * k2, params, prescription, consts)\n        k4 = func(t + dt, y + dt * k3, params, prescription, consts)\n        return y + (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    def run_simulation(params, prescription, consts, n_steps):\n        \"\"\"\n        Runs a full integration for a given set of parameters and a prescription.\n        \"\"\"\n        _, _, _, _, _, _, _, _, _, tau_exp, Ye0 = params\n        \n        t_end = 5.0 * tau_exp\n        dt = t_end / n_steps\n        \n        y = np.array([Ye0, 0.0])\n        t = 0.0\n        \n        for _ in range(n_steps):\n            y = rk4_step(derivatives, t, y, dt, params, prescription, consts)\n            y[0] = np.clip(y[0], 0.0, 1.0) # Enforce physical bounds on Ye\n            t += dt\n            \n        return y\n\n    all_results = []\n    n_steps = 2000\n\n    for case_params in test_cases:\n        M_BH, _, _, _, _, r0, _, _, _, _, _ = case_params\n        \n        # Run simulation for both prescriptions\n        y_final_leak = run_simulation(case_params, 'leakage', constants, n_steps)\n        y_final_m1 = run_simulation(case_params, 'm1', constants, n_steps)\n        \n        Ye_final_leak, e_heat_final_leak = y_final_leak\n        Ye_final_m1, e_heat_final_m1 = y_final_m1\n        \n        # Post-processing: calculate final observables\n        E_grav = constants[\"G\"] * M_BH / r0\n        \n        # Leakage results\n        v_inf_leak = np.sqrt(2 * max(0, e_heat_final_leak - E_grav))\n        v_inf_leak = min(v_inf_leak, 0.5 * constants[\"C\"])\n        kappa_leak = 10.0 if Ye_final_leak  0.25 else 1.0\n        \n        # M1 results\n        v_inf_m1 = np.sqrt(2 * max(0, e_heat_final_m1 - E_grav))\n        v_inf_m1 = min(v_inf_m1, 0.5 * constants[\"C\"])\n        kappa_m1 = 10.0 if Ye_final_m1  0.25 else 1.0\n        \n        case_results = [\n            Ye_final_leak, Ye_final_m1, \n            v_inf_leak, v_inf_m1, \n            kappa_leak, kappa_m1\n        ]\n        all_results.append(case_results)\n\n    # Format the final output string as a Python-style list of lists.\n    # To match the example format exactly, we construct the string manually.\n    result_str = \"[\"\n    for i, res in enumerate(all_results):\n        # Format each number in scientific notation as requested.\n        res_str = f\"[{res[0]:.8e}, {res[1]:.8e}, {res[2]:.8e}, {res[3]:.8e}, {res[4]:.1f}, {res[5]:.1f}]\"\n        result_str += res_str\n        if i  len(all_results) - 1:\n            result_str += \", \"\n    result_str += \"]\"\n    \n    # Correction: The problem requests python-style list of lists.\n    # my previous `formatted_results` was correct. Let's re-evaluate.\n    # The example is `\"[ [caseA_results], [caseB_results], ... ]\"`.\n    # Let's adjust the final output to match this string representation more closely.\n    final_output_str = str(all_results).replace(\"], [\", \"],\\n [\")\n    # Actually the instruction is: \"Your program should produce a single line of output...\"\n    # The example given is `[ [caseA_results], [caseB_results], [caseC_results], [caseD_results] ]`.\n    # My python code produces: `[[4.22e-01, ...], [4.53e-01, ...]]` etc. which is correct python list-of-lists.\n    # But the sample has spaces after commas. Let's make it exactly like that.\n    print(str(all_results).replace(\"],\", \"], \"))\n\nsolve()\n```", "id": "3466361"}]}