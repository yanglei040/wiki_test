{"hands_on_practices": [{"introduction": "A crucial first step in any numerical simulation is verifying that the code works as expected and quantifying its errors. This exercise introduces a powerful and widely used technique, Richardson extrapolation, to systematically isolate and quantify different sources of numerical error—in this case, from spatial discretization, temporal integration, and boundary treatments [@problem_id:3469946]. Mastering this method allows you to construct a detailed error budget, providing deep insight into your simulation's behavior and building confidence in its results.", "problem": "You are given a scenario in numerical relativity and gravitational waves focusing on constraint violation monitoring in the Baumgarte-Shapiro-Shibata-Nakamura (BSSN) formulation. Let the Hamiltonian constraint norm be denoted by $H(h,\\Delta t,b)$, where $h$ is the spatial grid spacing, $\\Delta t$ is the time step, and $b$ is a boundary control parameter that scales the magnitude of constraint-violating reflections at the outer boundary. Assume a method-of-lines discretization where the leading-order discretization error separates into spatial and temporal truncation terms of known orders, and the boundary-induced contamination scales inversely with the boundary control parameter. Concretely, assume the model\n$$\nH(h,\\Delta t,b) \\approx \\hat{H} + A\\,h^p + B\\,(\\Delta t)^q + \\frac{C}{b},\n$$\nwhere $\\hat{H}$ is the continuum constraint norm, $A$, $B$, and $C$ are coefficients, $p$ is the spatial order of accuracy, and $q$ is the temporal order of accuracy. For this problem, take $p=4$, $q=2$, and the boundary scaling as $1/b$. All quantities in this problem are dimensionless and must be reported as pure floating-point numbers.\n\nYour task is to use Richardson extrapolation and pairwise parameter variation to estimate the continuum constraint norm $\\hat{H}$ and to construct an error budget separating the spatial, temporal, and boundary contributions at a specified target configuration. The approach must start from the fundamental base that, for sufficiently smooth solutions and stable schemes, truncation errors scale as powers of $h$ and $\\Delta t$ determined by the scheme, and boundary contamination scales as an inverse power of a control parameter for reflection strength. The derivation and algorithm must eliminate leading-order error contributions using Richardson extrapolation logic when varying one parameter at a time while holding the others fixed.\n\nFor each test case, you are provided three two-level measurements in which exactly one parameter is varied while the other two are held fixed, along with a target configuration $(h_\\star,\\Delta t_\\star,b_\\star)$ at which you must report the error budget. From these data, you must:\n- Estimate the coefficients $A$, $B$, and $C$.\n- Estimate the continuum norm $\\hat{H}$ via Richardson extrapolation that eliminates the leading-order term of the varied parameter and then subtracts the remaining contributions of the unvaried parameters.\n- Compute the error budget contributions at the target configuration: $E_s = A\\,h_\\star^p$, $E_t = B\\,(\\Delta t_\\star)^q$, and $E_b = C/b_\\star$.\n\nUse the following test suite. For each case, the three measurement pairs and the target configuration are provided. In each pair, only the named parameter changes; the other two parameters are identical across the pair. The values $H_1$ and $H_2$ are the measured norms for the first and second settings of the varied parameter.\n\nCase 1:\n- Spatial pair: $(h_1,h_2,\\Delta t,b,H_1,H_2) = \\left( \\frac{1}{64}, \\frac{1}{128}, \\frac{1}{256}, 16, 0.00313057559967041, 0.0031305532479286194 \\right)$\n- Temporal pair: $(\\Delta t_1,\\Delta t_2,h,b,H_1,H_2) = \\left( \\frac{1}{128}, \\frac{1}{256}, \\frac{1}{128}, 16, 0.003139708521366119, 0.0031305532479286194 \\right)$\n- Boundary pair: $(b_1,b_2,h,\\Delta t,H_1,H_2) = \\left( 8, 16, \\frac{1}{128}, \\frac{1}{256}, 0.006255553247928619, 0.0031305532479286194 \\right)$\n- Target: $(h_\\star,\\Delta t_\\star,b_\\star) = \\left( \\frac{1}{128}, \\frac{1}{256}, 16 \\right)$\n\nCase 2:\n- Spatial pair: $(h_1,h_2,\\Delta t,b,H_1,H_2) = \\left( \\frac{1}{64}, \\frac{1}{128}, \\frac{1}{64}, 8, 0.00630135196685791, 0.006301329615241116 \\right)$\n- Temporal pair: $(\\Delta t_1,\\Delta t_2,h,b,H_1,H_2) = \\left( \\frac{1}{64}, \\frac{1}{128}, \\frac{1}{128}, 8, 0.006301329615241116, 0.006264708521366119 \\right)$\n- Boundary pair: $(b_1,b_2,h,\\Delta t,H_1,H_2) = \\left( 4, 8, \\frac{1}{128}, \\frac{1}{128}, 0.01251470852136612, 0.006264708521366119 \\right)$\n- Target: $(h_\\star,\\Delta t_\\star,b_\\star) = \\left( \\frac{1}{64}, \\frac{1}{64}, 8 \\right)$\n\nCase 3:\n- Spatial pair: $(h_1,h_2,\\Delta t,b,H_1,H_2) = \\left( \\frac{1}{256}, \\frac{1}{512}, \\frac{1}{1024}, 64, 0.0007839408289955386, 0.0007839407406840473 \\right)$\n- Temporal pair: $(\\Delta t_1,\\Delta t_2,h,b,H_1,H_2) = \\left( \\frac{1}{1024}, \\frac{1}{2048}, \\frac{1}{512}, 64, 0.0007839407406840473, 0.0007837976895365864 \\right)$\n- Boundary pair: $(b_1,b_2,h,\\Delta t,H_1,H_2) = \\left( 32, 64, \\frac{1}{512}, \\frac{1}{1024}, 0.0015651907406840473, 0.0007839407406840473 \\right)$\n- Target: $(h_\\star,\\Delta t_\\star,b_\\star) = \\left( \\frac{1}{256}, \\frac{1}{1024}, 64 \\right)$\n\nYour program must produce, for each case, four floating-point numbers on a single output line aggregated across all cases in the following order:\n$[\\hat{H}_1, E_{s,1}, E_{t,1}, E_{b,1}, \\hat{H}_2, E_{s,2}, E_{t,2}, E_{b,2}, \\hat{H}_3, E_{s,3}, E_{t,3}, E_{b,3}]$\nwhere the subscript indexes the case number. The program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,...]\"). All outputs must be pure floating-point numbers with no units.\n\nThe reasoning must start from the core definitions and properties described above without providing shortcut formulas in the problem statement. You must derive from the scaling laws implied by method-of-lines discretization and stable schemes with smooth solutions to justify the Richardson extrapolation strategy and the separation of contributions into spatial, temporal, and boundary components.", "solution": "The problem requires the estimation of the continuum limit of the Hamiltonian constraint norm, $\\hat{H}$, and an error budget analysis for a given target configuration, based on a provided model for the total measured norm $H(h, \\Delta t, b)$. The model assumes that the total error is a sum of contributions from spatial discretization, temporal discretization, and boundary effects.\n\nThe fundamental model for the measured Hamiltonian constraint norm is given as:\n$$\nH(h, \\Delta t, b) \\approx \\hat{H} + A\\,h^p + B\\,(\\Delta t)^q + \\frac{C}{b}\n$$\nHere, $h$ is the spatial grid spacing, $\\Delta t$ is the time step, and $b$ is a boundary control parameter. $\\hat{H}$ represents the true continuum norm ($h \\to 0$, $\\Delta t \\to 0$, $b \\to \\infty$). The terms $A\\,h^p$, $B\\,(\\Delta t)^q$, and $C/b$ represent the dominant error contributions from spatial discretization, temporal discretization, and the outer boundary, respectively. The problem specifies the order of accuracy for the spatial scheme as $p=4$ and for the temporal scheme as $q=2$.\n\nOur objective is to determine the unknown coefficients $A$, $B$, $C$, and the continuum norm $\\hat{H}$ from a series of numerical experiments where one parameter is varied at a time.\n\nFirst, we determine the coefficients $A$, $B$, and $C$. This is achieved by taking pairs of measurements where only one parameter is changed.\n\nTo find the spatial error coefficient $A$, we consider two measurements, $H_1$ and $H_2$, performed at spatial resolutions $h_1$ and $h_2$, while keeping the time step $\\Delta t$ and boundary parameter $b$ constant. The model equations for these two measurements are:\n$$\nH_1 = H(h_1, \\Delta t, b) \\approx \\hat{H} + A\\,h_1^p + B\\,(\\Delta t)^q + \\frac{C}{b}\n$$\n$$\nH_2 = H(h_2, \\Delta t, b) \\approx \\hat{H} + A\\,h_2^p + B\\,(\\Delta t)^q + \\frac{C}{b}\n$$\nSubtracting the second equation from the first eliminates $\\hat{H}$, the temporal error term, and the boundary error term, isolating the effect of the spatial error:\n$$\nH_1 - H_2 \\approx A\\,(h_1^p - h_2^p)\n$$\nFrom this, we can solve for the coefficient $A$:\n$$\nA = \\frac{H_1 - H_2}{h_1^p - h_2^p}\n$$\nAn analogous procedure is used to find the temporal error coefficient $B$. We use two measurements where only the time step is varied between $\\Delta t_1$ and $\\Delta t_2$, while $h$ and $b$ are held fixed:\n$$\nH_1 = H(h, \\Delta t_1, b) \\approx \\hat{H} + A\\,h^p + B\\,(\\Delta t_1)^q + \\frac{C}{b}\n$$\n$$\nH_2 = H(h, \\Delta t_2, b) \\approx \\hat{H} + A\\,h^p + B\\,(\\Delta t_2)^q + \\frac{C}{b}\n$$\nSubtracting these yields:\n$$\nH_1 - H_2 \\approx B\\,((\\Delta t_1)^q - (\\Delta t_2)^q)\n$$\nSolving for $B$:\n$$\nB = \\frac{H_1 - H_2}{(\\Delta t_1)^q - (\\Delta t_2)^q}\n$$\nSimilarly, for the boundary coefficient $C$, we vary the boundary parameter between $b_1$ and $b_2$, keeping $h$ and $\\Delta t$ constant:\n$$\nH_1 = H(h, \\Delta t, b_1) \\approx \\hat{H} + A\\,h^p + B\\,(\\Delta t)^q + \\frac{C}{b_1}\n$$\n$$\nH_2 = H(h, \\Delta t, b_2) \\approx \\hat{H} + A\\,h^p + B\\,(\\Delta t)^q + \\frac{C}{b_2}\n$$\nSubtracting gives:\n$$\nH_1 - H_2 \\approx C\\,\\left(\\frac{1}{b_1} - \\frac{1}{b_2}\\right)\n$$\nAnd we solve for $C$:\n$$\nC = \\frac{H_1 - H_2}{\\frac{1}{b_1} - \\frac{1}{b_2}}\n$$\nWith the coefficients $A$, $B$, and $C$ determined, we can now estimate the continuum norm $\\hat{H}$. The problem directs us to use a procedure based on Richardson extrapolation. Let's consider the pair of measurements used to find $A$, where $h$ was varied. We can use these two measurements to produce a higher-order estimate of $H(h=0, \\Delta t, b)$. Let $r = h_1 / h_2$. The standard Richardson extrapolation formula to eliminate the $O(h^p)$ error term is:\n$$\nH_{\\text{extrap}, h} = \\frac{H_2\\,r^p - H_1}{r^p - 1}\n$$\nThis extrapolated value represents an estimate of the Hamiltonian norm in the limit $h \\to 0$, but at the fixed values of $\\Delta t$ and $b$ used in that specific measurement pair. Therefore, its value according to our model is:\n$$\nH_{\\text{extrap}, h} \\approx \\hat{H} + B\\,(\\Delta t)^q + \\frac{C}{b}\n$$\nSince we have already computed the coefficients $B$ and $C$, we can now isolate $\\hat{H}$ by subtracting the remaining error contributions:\n$$\n\\hat{H} \\approx H_{\\text{extrap}, h} - B\\,(\\Delta t)^q - \\frac{C}{b}\n$$\nwhere $\\Delta t$ and $b$ are the parameters held constant in the spatial variation experiment. This provides our estimate for the continuum norm.\n\nFinally, we are asked to compute the error budget for a specified target configuration $(h_\\star, \\Delta t_\\star, b_\\star)$. This involves calculating the magnitude of each error component at this target configuration using the coefficients we have found:\n$$\n\\text{Spatial Error: } E_s = A\\,h_\\star^p\n$$\n$$\n\\text{Temporal Error: } E_t = B\\,(\\Delta t_\\star)^q\n$$\n$$\n\\text{Boundary Error: } E_b = \\frac{C}{b_\\star}\n$$\nThe sum $E_s + E_t + E_b$ represents the total estimated error in the measurement $H(h_\\star, \\Delta t_\\star, b_\\star)$ relative to the continuum value $\\hat{H}$.\n\nThe described algorithm is applied to each test case provided. The specific values for the orders are $p=4$ and $q=2$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of estimating the continuum Hamiltonian norm and error budget\n    for a series of numerical relativity simulations.\n    \"\"\"\n    p = 4\n    q = 2\n\n    # (spatial_pair, temporal_pair, boundary_pair, target_config)\n    test_cases = [\n        # Case 1\n        (\n            {'h1': 1/64, 'h2': 1/128, 'dt': 1/256, 'b': 16, 'H1': 0.00313057559967041, 'H2': 0.0031305532479286194},\n            {'dt1': 1/128, 'dt2': 1/256, 'h': 1/128, 'b': 16, 'H1': 0.003139708521366119, 'H2': 0.0031305532479286194},\n            {'b1': 8, 'b2': 16, 'h': 1/128, 'dt': 1/256, 'H1': 0.006255553247928619, 'H2': 0.0031305532479286194},\n            {'h_star': 1/128, 'dt_star': 1/256, 'b_star': 16}\n        ),\n        # Case 2\n        (\n            {'h1': 1/64, 'h2': 1/128, 'dt': 1/64, 'b': 8, 'H1': 0.00630135196685791, 'H2': 0.006301329615241116},\n            {'dt1': 1/64, 'dt2': 1/128, 'h': 1/128, 'b': 8, 'H1': 0.006301329615241116, 'H2': 0.006264708521366119},\n            {'b1': 4, 'b2': 8, 'h': 1/128, 'dt': 1/128, 'H1': 0.01251470852136612, 'H2': 0.006264708521366119},\n            {'h_star': 1/64, 'dt_star': 1/64, 'b_star': 8}\n        ),\n        # Case 3\n        (\n            {'h1': 1/256, 'h2': 1/512, 'dt': 1/1024, 'b': 64, 'H1': 0.0007839408289955386, 'H2': 0.0007839407406840473},\n            {'dt1': 1/1024, 'dt2': 1/2048, 'h': 1/512, 'b': 64, 'H1': 0.0007839407406840473, 'H2': 0.0007837976895365864},\n            {'b1': 32, 'b2': 64, 'h': 1/512, 'dt': 1/1024, 'H1': 0.0015651907406840473, 'H2': 0.0007839407406840473},\n            {'h_star': 1/256, 'dt_star': 1/1024, 'b_star': 64}\n        ),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        spatial_pair, temporal_pair, boundary_pair, target = case\n\n        # Calculate coefficient A from the spatial pair\n        sp = spatial_pair\n        A_numerator = sp['H1'] - sp['H2']\n        A_denominator = sp['h1']**p - sp['h2']**p\n        A = A_numerator / A_denominator\n\n        # Calculate coefficient B from the temporal pair\n        tp = temporal_pair\n        B_numerator = tp['H1'] - tp['H2']\n        B_denominator = tp['dt1']**q - tp['dt2']**q\n        B = B_numerator / B_denominator\n\n        # Calculate coefficient C from the boundary pair\n        bp = boundary_pair\n        C_numerator = bp['H1'] - bp['H2']\n        C_denominator = (1 / bp['b1']) - (1 / bp['b2'])\n        C = C_numerator / C_denominator\n\n        # Estimate H_hat using Richardson extrapolation on the spatial pair\n        # H_extrap_h is an estimate for H(h=0, dt, b) = H_hat + B*dt^q + C/b\n        r_h = sp['h1'] / sp['h2']\n        H_extrap_h = (sp['H2'] * r_h**p - sp['H1']) / (r_h**p - 1)\n\n        # Subtract the remaining error terms to find H_hat\n        # Use dt and b from the spatial pair measurement\n        dt_s = sp['dt']\n        b_s = sp['b']\n        H_hat = H_extrap_h - (B * dt_s**q + C / b_s)\n\n        # Calculate the error budget for the target configuration\n        E_s = A * target['h_star']**p\n        E_t = B * target['dt_star']**q\n        E_b = C / target['b_star']\n\n        all_results.extend([H_hat, E_s, E_t, E_b])\n\n    # Format output as a single comma-separated list in brackets\n    print(f\"[{','.join(f'{r:.18e}' for r in all_results)}]\")\n\nsolve()\n```", "id": "3469946"}, {"introduction": "Once we can measure errors, we must learn to interpret them. This practice explores a subtle but central challenge in numerical relativity: distinguishing genuine physical effects from \"gauge\" artifacts arising from our choice of coordinates [@problem_id:3469971]. By injecting both physical and unphysical (gauge) waves into a simplified model, you will develop monitors that can differentiate a true, constraint-violating field from a purely coordinate-based disturbance that should, in principle, perfectly satisfy the constraints.", "problem": "Consider the linearized vacuum constraints of the $3+1$ formalism of General Relativity, linearized about flat space, where the spatial metric is $g_{ij} = \\delta_{ij} + h_{ij}$ with a small perturbation $h_{ij}$ and the extrinsic curvature contributions are neglected to first order. The linearized Hamiltonian constraint is\n$$\nH_{\\text{lin}}(x) = \\partial_i \\partial_j h_{ij}(x) - \\partial^2 h(x),\n$$\nwhere $h(x) = h_{ii}(x)$ is the trace of the perturbation, and $\\partial^2 = \\partial_x^2 + \\partial_y^2 + \\partial_z^2$. Assume all fields depend only on the single spatial coordinate $x$, so that $\\partial_y = \\partial_z = 0$, and model periodic boundary conditions on a one-dimensional domain of length $L$. In this one-dimensional dependence setting, the linearized Hamiltonian constraint reduces to\n$$\nH_{\\text{lin}}(x) = \\partial_x^2 h_{xx}(x) - \\partial_x^2 \\left(h_{xx}(x) + h_{yy}(x) + h_{zz}(x)\\right) = -\\partial_x^2\\left(h_{yy}(x) + h_{zz}(x)\\right).\n$$\nThis shows that longitudinal gauge content in $h_{xx}$ does not contribute to $H_{\\text{lin}}$, whereas scalar trace content $h_{yy} + h_{zz}$ does. A physical Transverse-Traceless (TT) wave traveling along the $x$-axis has $h_{xx} = 0$, $h_{yy} = A \\sin(k(x - t))$, $h_{zz} = -A \\sin(k(x - t))$, and therefore $h_{yy} + h_{zz} = 0$, which yields $H_{\\text{lin}}(x) = 0$. A pure gauge wave arising from an infinitesimal coordinate perturbation with displacement $\\xi_x(x,t)$ has $h_{xx}(x,t) = 2 \\partial_x \\xi_x(x,t)$ and $h_{yy} = h_{zz} = 0$, which also yields $H_{\\text{lin}}(x) = 0$.\n\nYour task is to implement a monitoring program that discriminates gauge-induced versus physical (scalar trace) contributions to the $L^2$ norm of the Hamiltonian constraint, $\\|H\\|_{L^2}$, in a controlled synthetic experiment. Work on a periodic domain of length $L = 2\\pi$ with $N$ equispaced grid points and spacing $\\Delta x = L/N$. Use $t = 0$.\n\nDefine the following synthetic injections on the grid $x_n = n \\Delta x$ for $n = 0, 1, \\dots, N-1$:\n\n- A controlled gauge wave:\n$$\n\\xi_x(x, t) = \\frac{a}{k_{\\mathrm{phys}}}\\cos\\left(k_{\\mathrm{phys}}(x - t)\\right), \\quad h_{xx}^{\\mathrm{gauge}}(x, t) = 2 \\partial_x \\xi_x(x, t) = -2 a \\sin\\left(k_{\\mathrm{phys}}(x - t)\\right),\n$$\nwith $h_{yy} = 0$, $h_{zz} = 0$. Here $k_{\\mathrm{phys}} = \\frac{2\\pi m}{L}$ is the physical wavenumber for integer mode number $m$.\n\n- A slightly perturbed, constraint-violating addition:\n$$\nh_{yy}^{\\mathrm{pert}}(x, t) = \\varepsilon \\sin\\left(k_{\\mathrm{phys}}(x - t) + \\phi\\right), \\quad h_{zz}^{\\mathrm{pert}}(x, t) = 0,\n$$\nwhich yields $h_{yy} + h_{zz} \\neq 0$ and therefore a nonzero $H_{\\text{lin}}(x)$.\n\n- A physical Transverse-Traceless (TT) wave traveling along $x$:\n$$\nh_{xx}^{\\mathrm{TT}}(x, t) = 0, \\quad h_{yy}^{\\mathrm{TT}}(x, t) = A_p \\sin\\left(k_{\\mathrm{phys}}(x - t)\\right), \\quad h_{zz}^{\\mathrm{TT}}(x, t) = -A_p \\sin\\left(k_{\\mathrm{phys}}(x - t)\\right),\n$$\nwhich keeps $h_{yy} + h_{zz} = 0$.\n\nConstruct three test cases on the same grid:\n- Test case $1$: only the controlled gauge wave, with $h_{xx} = h_{xx}^{\\mathrm{gauge}}$, $h_{yy} = 0$, $h_{zz} = 0$.\n- Test case $2$: the gauge wave plus the perturbed addition, with $h_{xx} = h_{xx}^{\\mathrm{gauge}}$, $h_{yy} = h_{yy}^{\\mathrm{pert}}$, $h_{zz} = 0$.\n- Test case $3$: the gauge wave plus the physical TT wave, with $h_{xx} = h_{xx}^{\\mathrm{gauge}}$, $h_{yy} = h_{yy}^{\\mathrm{TT}}$, $h_{zz} = h_{zz}^{\\mathrm{TT}}$.\n\nDevelop and compute the following monitors for each test case:\n- A finite-difference approximation to the Hamiltonian constraint on the grid,\n$$\nH_{\\mathrm{fd}}(x_n) = D_{xx} h_{xx}(x_n) - D_{xx}\\left(h_{xx}(x_n) + h_{yy}(x_n) + h_{zz}(x_n)\\right),\n$$\nwhere $D_{xx}$ is the second-order centered finite difference operator,\n$$\nD_{xx} f(x_n) = \\frac{f(x_{n+1}) - 2 f(x_n) + f(x_{n-1})}{\\Delta x^2},\n$$\nwith periodic indexing.\n\n- A spectral-derivative approximation to the scalar-trace contribution, using the discrete Fourier transform (DFT): define $S(x_n) = h_{yy}(x_n) + h_{zz}(x_n)$. Let $\\widehat{f}(k)$ be the DFT of $f(x)$ on the periodic grid, and let $k$ denote the angular wavenumber in Fourier space. Then compute\n$$\n\\left(-\\partial_x^2 S\\right)_{\\mathrm{sp}}(x) = \\mathcal{F}^{-1}\\left[\\left(k^2\\right)\\widehat{S}(k)\\right](x),\n$$\nwhere $\\mathcal{F}^{-1}$ denotes the inverse DFT and the angular wavenumbers are $k_n = \\frac{2\\pi n}{L}$ for integer $n$ matched to the DFT convention.\n\n- The $L^2$ norm of any grid field $f(x_n)$ is\n$$\n\\|f\\|_{L^2} = \\left( \\sum_{n=0}^{N-1} f(x_n)^2 \\Delta x \\right)^{1/2}.\n$$\n\nCompute for each test case:\n- $H$ norm: $\\|H_{\\mathrm{fd}}\\|_{L^2}$.\n- Physical scalar monitor: $M_{\\mathrm{phys}} = \\left\\|\\left(-\\partial_x^2 S\\right)_{\\mathrm{sp}}\\right\\|_{L^2}$.\n- Gauge contamination monitor: $M_{\\mathrm{gauge}} = \\left\\|H_{\\mathrm{fd}} - \\left(-\\partial_x^2 S\\right)_{\\mathrm{sp}}\\right\\|_{L^2}$, which quantifies the portion of the measured Hamiltonian constraint not explained by the scalar-trace contribution and is therefore attributable to gauge-only content and discretization artifacts.\n\nUse the following parameter values for a scientifically sound and nontrivial test suite:\n- Domain length $L = 2\\pi$.\n- Grid size $N = 256$.\n- Mode number $m = 4$, so $k_{\\mathrm{phys}} = \\frac{2\\pi m}{L}$.\n- Gauge amplitude $a = 0.1$.\n- Perturbation amplitude $\\varepsilon = 0.01$ and phase $\\phi = \\pi/5$.\n- Physical TT amplitude $A_p = 0.05$.\n- Time $t = 0$.\n\nYour program should produce a single line of output containing the nine results, in order, as a comma-separated list enclosed in square brackets, specifically\n$$\n[\\|H_{\\mathrm{fd}}\\|_{L^2}^{(1)}, M_{\\mathrm{phys}}^{(1)}, M_{\\mathrm{gauge}}^{(1)}, \\|H_{\\mathrm{fd}}\\|_{L^2}^{(2)}, M_{\\mathrm{phys}}^{(2)}, M_{\\mathrm{gauge}}^{(2)}, \\|H_{\\mathrm{fd}}\\|_{L^2}^{(3)}, M_{\\mathrm{phys}}^{(3)}, M_{\\mathrm{gauge}}^{(3)}],\n$$\nwhere the superscripts indicate the test case number. Express all nine outputs as floating-point numbers. No physical units are involved in this dimensionless synthetic experiment. Round each printed float to $8$ decimal places to make the single-line output stable and unambiguous across platforms.", "solution": "The user's request is to develop a program that monitors Hamiltonian constraint violations in a simplified 1D setting of linearized General Relativity. The goal is to distinguish between physical sources of constraint violation and numerical artifacts, which can be related to gauge dynamics.\n\n### Scientific Principles and Problem Formulation\n\nThe problem is rooted in the $3+1$ \"ADM\" formalism of General Relativity, where spacetime is foliated into a series of spatial slices. The evolution of the geometry is governed by evolution equations, but the initial data on a slice cannot be chosen freely. It must satisfy a set of four constraint equations. Here, we focus on the linearized Hamiltonian constraint, which for a metric perturbation $h_{ij}$ around flat space takes the form:\n$$\nH_{\\text{lin}} = \\partial_i \\partial_j h_{ij} - \\partial^2 h\n$$\nwhere $h=h_{kk}$ is the trace of the perturbation and repeated indices are summed. Specializing to a 1D problem where all fields depend only on the $x$ coordinate ($\\partial_y = \\partial_z = 0$), this constraint simplifies significantly:\n$$\nH_{\\text{lin}}(x) = \\partial_x^2 h_{xx} - \\partial_x^2 (h_{xx} + h_{yy} + h_{zz}) = -\\partial_x^2 (h_{yy} + h_{zz})\n$$\nWe define the scalar trace quantity $S(x) = h_{yy}(x) + h_{zz}(x)$. The Hamiltonian constraint is thus equivalent to the action of the negative Laplacian on this scalar trace:\n$$\nH_{\\text{lin}}(x) = -\\partial_x^2 S(x)\n$$\nThis equation reveals that a non-zero scalar trace $S$ acts as a source for Hamiltonian constraint violation. Importantly, pure gauge modes (unphysical coordinate artifacts) and Transverse-Traceless (TT) physical gravitational waves traveling in the $x$-direction are constructed to have $S=0$ and thus exactly satisfy the Hamiltonian constraint.\n\n### Numerical Implementation and Monitoring Strategy\n\nThe task is to implement and compare different numerical measures of this constraint for three synthetic test cases defined on a periodic 1D grid.\n\n**1. Numerical Operators:**\n\n- **Finite Difference Laplacian:** The continuous operator $\\partial_x^2$ is approximated by a second-order centered finite difference operator, $D_{xx}$:\n  $$\n  D_{xx} f(x_n) = \\frac{f(x_{n+1}) - 2 f(x_n) + f(x_{n-1})}{\\Delta x^2}\n  $$\n  where $\\Delta x$ is the grid spacing and periodic boundary conditions are used for indices. The finite-difference approximation of the Hamiltonian constraint, $H_{\\text{fd}}$, is computed as specified:\n  $$\n  H_{\\text{fd}} = D_{xx} h_{xx} - D_{xx}(h_{xx} + h_{yy} + h_{zz}) = -D_{xx}(S)\n  $$\n  While the $D_{xx} h_{xx}$ terms cancel mathematically, computing them can introduce floating-point noise in a real simulation, and the problem asks to compute it this way.\n\n- **Spectral Laplacian:** For periodic functions, a highly accurate way to compute derivatives is via the Fourier transform ($\\mathcal{F}$). The derivative property of the Fourier transform states that $\\mathcal{F}[\\partial_x f(x)] = ik\\mathcal{F}[f(x)]$, where $k$ is the angular wavenumber. Consequently, $-\\partial_x^2$ becomes multiplication by $k^2$ in Fourier space. The spectral evaluation of the constraint source is:\n  $$\n  (-\\partial_x^2 S)_{\\mathrm{sp}} = \\mathcal{F}^{-1}[k^2 \\mathcal{F}[S]]\n  $$\n  where $\\mathcal{F}^{-1}$ is the inverse Fourier transform. This method is free of truncation error for functions that are well-resolved on the grid.\n\n**2. The Monitors:**\n\nThe problem defines three monitors based on the $L^2$ norm, which for a grid function $f_n$ is $\\|f\\|_{L^2} = (\\sum_{n=0}^{N-1} f_n^2 \\Delta x)^{1/2}$.\n\n- **Total \"Measured\" Constraint Violation:** $\\|H_{\\mathrm{fd}}\\|_{L^2}$. This represents the total constraint violation as measured by the simple finite-difference method.\n\n- **Physical Scalar Monitor:** $M_{\\mathrm{phys}} = \\|(-\\partial_x^2 S)_{\\mathrm{sp}}\\|_{L^2}$. This uses the spectrally accurate method to quantify the \"true\" physical source of constraint violation originating from a non-zero scalar trace $S$.\n\n- **Gauge Contamination Monitor:** $M_{\\mathrm{gauge}} = \\|H_{\\mathrm{fd}} - (-\\partial_x^2 S)_{\\mathrm{sp}}\\|_{L^2}$. This measures the difference between the finite-difference and spectral evaluations. This difference is primarily due to the truncation error of the finite-difference operator. In more complex scenarios, such discrepancies can be seeded or amplified by gauge modes, hence the name.\n\n### Analysis of Test Cases\n\n- **Case 1 (Pure Gauge):** We set $h_{xx}$ to be a gauge wave and $h_{yy} = h_{zz} = 0$. This gives $S = 0$. Consequently, the analytical constraint $H_{\\text{lin}}$ is zero. Both numerical approximations, $H_{\\mathrm{fd}}$ and $(-\\partial_x^2 S)_{\\mathrm{sp}}$, will also be zero (up to machine precision). All three monitors are expected to be zero.\n\n- **Case 2 (Gauge + Perturbation):** We add a constraint-violating perturbation $h_{yy}^{\\mathrm{pert}}$, making $S \\neq 0$.\n    - $M_{\\mathrm{phys}}$ will be non-zero, providing a spectrally accurate measure of the violation.\n    - $\\|H_{\\mathrm{fd}}\\|_{L^2}$ will also be non-zero. Since $D_{xx}$ is a second-order approximation, its result will be close but not identical to the spectral one.\n    - $M_{\\mathrm{gauge}}$ will be small but non-zero, precisely quantifying the truncation error of the finite-difference method for the given grid resolution and wavenumber.\n\n- **Case 3 (Gauge + TT Wave):** We add a physical Transverse-Traceless (TT) gravitational wave. By definition, a TT wave has zero trace, so for this wave, $h_{yy}^{\\mathrm{TT}} + h_{zz}^{\\mathrm{TT}} = 0$. This leaves the total scalar trace $S=0$. This case is therefore identical to Case 1 from the perspective of the Hamiltonian constraint. All three monitors are expected to be zero, demonstrating that the monitors correctly identify this physical wave as a constraint-satisfying solution.\n\nThe implementation will proceed by setting up the grid, defining the helper functions for the numerical operators and the $L^2$ norm, constructing the fields for each of the three test cases, computing the three specified monitors, and formatting the results.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes Hamiltonian constraint monitors for three synthetic test cases\n    in linearized 1D gravity.\n    \"\"\"\n    # Define parameters from the problem statement\n    L = 2.0 * np.pi\n    N = 256\n    m = 4\n    a = 0.1\n    epsilon = 0.01\n    phi = np.pi / 5.0\n    Ap = 0.05\n    t = 0.0\n\n    # Grid setup\n    dx = L / N\n    x = np.arange(N) * dx\n    # Since L=2pi, the physical wavenumber k_phys = 2*pi*m/L simplifies to m.\n    k_phys = float(m)\n\n    # --- Helper functions defined within the solver scope ---\n    def D_xx(f, dx_val):\n        \"\"\"Computes the second derivative using a centered finite difference scheme.\"\"\"\n        f_plus_1 = np.roll(f, -1)\n        f_minus_1 = np.roll(f, 1)\n        return (f_plus_1 - 2.0 * f + f_minus_1) / dx_val**2\n\n    def neg_d2_spectral(f, N_val, dx_val):\n        \"\"\"Computes -d^2/dx^2 of a function f using spectral methods (FFT).\"\"\"\n        f_hat = np.fft.fft(f)\n        # Wavenumbers corresponding to the DFT frequencies.\n        # np.fft.fftfreq gives cycles/sample spacing; multiply by 2*pi for angular k.\n        freqs = np.fft.fftfreq(N_val, d=dx_val)\n        k = 2.0 * np.pi * freqs\n        \n        # In Fourier space, -d^2/dx^2 is equivalent to multiplication by k^2.\n        # d/dx -> ik,  d^2/dx^2 -> (ik)^2 = -k^2,  -d^2/dx^2 -> k^2\n        neg_d2f_hat = (k**2) * f_hat\n        \n        # Inverse FFT to get back to spatial domain.\n        # The result must be real; np.real removes negligible imaginary parts.\n        return np.real(np.fft.ifft(neg_d2f_hat))\n\n    def L2_norm(f, dx_val):\n        \"\"\"Computes the L2 norm of a grid function.\"\"\"\n        return np.sqrt(np.sum(np.square(f)) * dx_val)\n\n    # --- Define field components for test cases ---\n    # Common gauge wave component\n    h_xx_gauge = -2.0 * a * np.sin(k_phys * (x - t))\n    \n    # Empty field for convenience\n    zeros = np.zeros(N)\n    \n    # Constraint-violating perturbation component\n    h_yy_pert = epsilon * np.sin(k_phys * (x - t) + phi)\n    \n    # Transverse-Traceless (TT) wave components\n    h_yy_TT = Ap * np.sin(k_phys * (x - t))\n    h_zz_TT = -Ap * np.sin(k_phys * (x - t))\n\n    # --- Define the test cases from the problem statement ---\n    test_cases = [\n        # Case 1: Pure gauge wave\n        (h_xx_gauge, zeros, zeros),\n        # Case 2: Gauge wave + perturbation\n        (h_xx_gauge, h_yy_pert, zeros),\n        # Case 3: Gauge wave + physical TT wave\n        (h_xx_gauge, h_yy_TT, h_zz_TT)\n    ]\n\n    all_results = []\n    for hxx, hyy, hzz in test_cases:\n        # Compute H_fd using the specified formula: H_fd = Dxx(hxx) - Dxx(hxx + hyy + hzz)\n        # This simplifies to -Dxx(hyy + hzz), but we implement the given form.\n        term1 = D_xx(hxx, dx)\n        term2 = D_xx(hxx + hyy + hzz, dx)\n        H_fd = term1 - term2\n\n        # Scalar trace S = hyy + hzz\n        S = hyy + hzz\n\n        # Compute the spectral scalar-trace contribution: (-d^2 S/dx^2)_sp\n        neg_d2S_sp = neg_d2_spectral(S, N, dx)\n\n        # Compute the three monitors for the current case\n        H_norm = L2_norm(H_fd, dx)\n        M_phys = L2_norm(neg_d2S_sp, dx)\n        M_gauge = L2_norm(H_fd - neg_d2S_sp, dx)\n\n        all_results.extend([H_norm, M_phys, M_gauge])\n        \n    # Format and print the final output as a single line with 8 decimal places\n    output_str = \"[\" + \",\".join([f\"{r:.8f}\" for r in all_results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "3469971"}, {"introduction": "Beyond passive monitoring, advanced numerical relativity codes actively control constraint violations to ensure long-term stability. This exercise provides a hands-on introduction to constraint projection, a powerful technique that involves solving an elliptic partial differential equation to steer a numerically drifted solution back towards the physically valid \"constraint surface\" [@problem_id:3470000]. By implementing a single Newton-Raphson correction step for a model constraint equation, you will engage with the core concepts behind the elliptic solvers that are fundamental to both generating valid initial data and maintaining the fidelity of long-term evolutions.", "problem": "Consider the Hamiltonian constraint in General Relativity (GR) formulated under a conformal decomposition, where constraint violations in the conformal factor are corrected by projecting onto the constraint manifold via an elliptic solve. In a scientifically consistent simplified model on a two-dimensional, flat, unit square domain $[0,1]\\times[0,1]$, adopt the following constraint functional that mimics the structure of the conformal Lichnerowicz-type equation:\n$$\nH(\\phi) = -8\\,\\Delta \\phi + \\beta\\,\\phi^5 - S(x,y),\n$$\nwhere $\\phi$ is the conformal factor, $\\Delta$ is the Laplacian on $\\mathbb{R}^2$, $\\beta \\ge 0$ is a constant parameter controlling nonlinearity, and $S(x,y)$ is a smooth source constructed from prescribed extrinsic curvature and matter terms. Impose homogeneous Dirichlet boundary conditions $\\phi=0$ on $\\partial([0,1]\\times[0,1])$.\n\nDefine the source as\n$$\nS(x,y) = A\\,\\sin(2\\pi x)\\sin(2\\pi y) + B\\,\\exp\\!\\left(-\\frac{(x-\\tfrac{1}{2})^2+(y-\\tfrac{1}{2})^2}{2\\sigma^2}\\right),\n$$\nwith parameters $A$, $B$, $\\sigma>0$. Use a uniform grid with $N$ interior points per spatial dimension, so that the grid spacing is $h = \\frac{1}{N+1}$ and interior grid points are $(x_i,y_j) = (ih,jh)$ for $i,j \\in \\{1,2,\\dots,N\\}$.\n\nLet the initial conformal factor be\n$$\n\\phi_0(x,y) = \\varepsilon\\,\\sin(\\pi x)\\sin(\\pi y),\n$$\nwith parameter $\\varepsilon \\ge 0$. The goal is to propose and implement a constraint projection step that computes a correction $\\delta\\phi$ by solving a single elliptic equation derived from the linearization of $H(\\phi)$ about the current $\\phi$, and then updates $\\phi \\leftarrow \\phi + \\delta\\phi$. After this projection, evaluate the reduction in the discrete norm of the Hamiltonian constraint.\n\nStarting from fundamental definitions and principles, do the following:\n- Derive the linearized elliptic operator acting on the correction $\\delta\\phi$ by taking the Fréchet derivative of $H(\\phi)$ with respect to $\\phi$ and evaluating it at the current $\\phi$. Use this operator to define the constraint projection equation for $\\delta\\phi$ that must be solved on the grid with homogeneous Dirichlet boundary conditions.\n- Discretize the operators using second-order central differences on the interior grid with the standard five-point stencil for the Laplacian. Treat the boundary by enforcing $\\phi=0$ at grid points on $\\partial([0,1]\\times[0,1])$.\n- Compute the discrete $L^2$ norm of the Hamiltonian constraint residual on the interior grid,\n$$\n\\lVert H \\rVert_{h} = \\sqrt{h^2 \\sum_{i=1}^N \\sum_{j=1}^N \\left(H_{ij}\\right)^2},\n$$\nboth before and after the projection step, and report the reduction ratio\n$$\nr = \\frac{\\lVert H(\\phi_{\\text{after}})\\rVert_{h}}{\\lVert H(\\phi_{\\text{before}})\\rVert_{h}}.\n$$\nIf $\\lVert H(\\phi_{\\text{before}})\\rVert_{h}$ is numerically zero (for example, smaller than a fixed tolerance such as $10^{-14}$), define $r=0$.\n\nYour program must implement this projection and compute $r$ for each of the following test cases, covering diverse regimes including linear and nonlinear constraints, coarse and fine grids, and different source amplitudes. For each case, use the interior grid size $N$, initial amplitude $\\varepsilon$, nonlinearity parameter $\\beta$, and source parameters $A$, $B$, $\\sigma$:\n\n1. $N=32$, $\\varepsilon=0.1$, $\\beta=1.0$, $A=1.0$, $B=0.5$, $\\sigma=0.15$.\n2. $N=8$, $\\varepsilon=0.1$, $\\beta=1.0$, $A=1.0$, $B=0.5$, $\\sigma=0.15$.\n3. $N=32$, $\\varepsilon=0.0$, $\\beta=1.0$, $A=1.0$, $B=0.5$, $\\sigma=0.15$.\n4. $N=32$, $\\varepsilon=0.1$, $\\beta=0.0$, $A=1.0$, $B=0.5$, $\\sigma=0.15$.\n5. $N=64$, $\\varepsilon=0.2$, $\\beta=10.0$, $A=0.5$, $B=1.0$, $\\sigma=0.10$.\n\nYour program should produce a single line of output containing the five reduction ratios as a comma-separated list enclosed in square brackets, with each ratio expressed as a decimal number rounded to six digits after the decimal point (for example, $[0.123456,0.000001,0.987654,0.100000,0.250000]$). No angles or physical units are involved in this problem. Use precise floating-point arithmetic to compute the norms and solutions to the linear systems that arise from the elliptic equations. Ensure scientific realism by solving the linear system exactly using an appropriate method for sparse, symmetric positive definite systems.", "solution": "The problem requires the implementation of a single constraint-projection step for a simplified Hamiltonian constraint equation from numerical relativity. This step is equivalent to one iteration of the Newton-Raphson method for solving a nonlinear elliptic partial differential equation. The core of the task is to derive and discretize the linearized equation for the correction, solve the resulting linear system, and evaluate the reduction in the constraint violation.\n\nFirst, we derive the elliptic equation for the correction term $\\delta\\phi$. The Hamiltonian constraint functional is given as\n$$\nH(\\phi) = -8\\,\\Delta \\phi + \\beta\\,\\phi^5 - S(x,y).\n$$\nWe are given an initial state for the conformal factor, $\\phi_0$, which does not necessarily satisfy the constraint, meaning $H(\\phi_0) \\neq 0$. We seek a correction $\\delta\\phi$ such that the new field $\\phi = \\phi_0 + \\delta\\phi$ is a better approximation to a solution, i.e., $H(\\phi_0 + \\delta\\phi) \\approx 0$. To find $\\delta\\phi$, we linearize the functional $H(\\phi)$ around $\\phi_0$ by taking its Fréchet derivative. The expansion of $H(\\phi_0 + \\delta\\phi)$ for a small $\\delta\\phi$ is:\n$$\nH(\\phi_0 + \\delta\\phi) = -8\\,\\Delta (\\phi_0 + \\delta\\phi) + \\beta\\,(\\phi_0 + \\delta\\phi)^5 - S(x,y).\n$$\nUsing the binomial expansion for the nonlinear term, $(\\phi_0 + \\delta\\phi)^5 = \\phi_0^5 + 5\\phi_0^4\\delta\\phi + \\mathcal{O}((\\delta\\phi)^2)$, and retaining terms up to first order in $\\delta\\phi$, we get:\n$$\nH(\\phi_0 + \\delta\\phi) \\approx \\left(-8\\,\\Delta \\phi_0 + \\beta\\,\\phi_0^5 - S\\right) + \\left(-8\\,\\Delta(\\delta\\phi) + 5\\beta\\,\\phi_0^4\\delta\\phi\\right).\n$$\nThis expression can be written as $H(\\phi_0 + \\delta\\phi) \\approx H(\\phi_0) + L_{\\phi_0}[\\delta\\phi]$, where $L_{\\phi_0}$ is the linearized operator acting on the correction $\\delta\\phi$:\n$$\nL_{\\phi_0}[\\delta\\phi] = -8\\,\\Delta(\\delta\\phi) + 5\\beta\\,\\phi_0^4\\delta\\phi.\n$$\nThe constraint projection equation sets the linearized expression for $H(\\phi_0 + \\delta\\phi)$ to zero:\n$$\nL_{\\phi_0}[\\delta\\phi] = -H(\\phi_0).\n$$\nSubstituting the expressions for $L_{\\phi_0}$ and $H(\\phi_0)$, we obtain the elliptic partial differential equation for the correction $\\delta\\phi$:\n$$\n-8\\,\\Delta(\\delta\\phi) + 5\\beta\\,\\phi_0^4\\,\\delta\\phi = -(-8\\,\\Delta \\phi_0 + \\beta\\,\\phi_0^5 - S) = 8\\,\\Delta \\phi_0 - \\beta\\,\\phi_0^5 + S.\n$$\nThis equation must be solved for $\\delta\\phi$ on the unit square domain $[0,1]\\times[0,1]$ with homogeneous Dirichlet boundary conditions, $\\delta\\phi = 0$ on the boundary $\\partial([0,1]\\times[0,1])$, since the total field $\\phi$ must satisfy $\\phi=0$ on the boundary, and the initial field $\\phi_0$ is constructed to satisfy this.\n\nNext, we discretize this equation on a uniform grid. The domain is discretized with $N$ interior points in each dimension, leading to a grid spacing of $h = 1/(N+1)$. The interior grid points are $(x_i, y_j) = (ih, jh)$ for $i,j \\in \\{1, \\dots, N\\}$. A function $f(x,y)$ is represented by its values $f_{ij}$ on this grid. We use a second-order accurate five-point stencil for the Laplacian operator $\\Delta$:\n$$\n(\\Delta f)_{ij} \\approx \\frac{f_{i+1,j} + f_{i-1,j} + f_{i,j+1} + f_{i,j-1} - 4f_{ij}}{h^2}.\n$$\nApplying this discretization to the equation for $\\delta\\phi$ at each interior point $(i,j)$ yields a system of $N^2$ linear algebraic equations:\n$$\n-8\\frac{\\delta\\phi_{i+1,j} + \\delta\\phi_{i-1,j} + \\delta\\phi_{i,j+1} + \\delta\\phi_{i,j-1} - 4\\delta\\phi_{ij}}{h^2} + 5\\beta\\,\\phi_{0,ij}^4\\,\\delta\\phi_{ij} = -H(\\phi_0)_{ij}.\n$$\nHere, $\\delta\\phi_{ij}$ are the unknowns, $\\phi_{0,ij}$ are the known values of the initial field, and $H(\\phi_0)_{ij}$ is the discretized residual of the original constraint, calculated as\n$$\nH(\\phi_0)_{ij} = -8(\\Delta\\phi_0)_{ij} + \\beta\\,\\phi_{0,ij}^5 - S_{ij},\n$$\nwhere $(\\Delta\\phi_0)_{ij}$ is also computed using the five-point stencil. The homogeneous Dirichlet boundary conditions are enforced by setting $\\phi_0$ and $\\delta\\phi$ to $0$ for any index $i$ or $j$ equal to $0$ or $N+1$.\n\nThis system of equations can be written in matrix form as $M \\vec{d} = \\vec{b}$, where $\\vec{d}$ is a vector of length $N^2$ formed by flattening the grid of unknowns $\\delta\\phi_{ij}$, and $\\vec{b}$ is a vector of the same size formed by flattening $-H(\\phi_0)_{ij}$. The matrix $M$ is a sparse, symmetric, and positive-definite matrix of size $N^2 \\times N^2$. Its structure arises from the discretized operator $L_{\\phi_0}$. The diagonal entries are $(\\frac{32}{h^2} + 5\\beta\\,\\phi_{0,ij}^4)$, and the non-zero off-diagonal entries are $-\\frac{8}{h^2}$, corresponding to the four nearest neighbors on the grid. Due to its properties, this linear system can be reliably and efficiently solved for $\\vec{d}$.\n\nThe overall algorithm to compute the reduction ratio $r$ for a given set of parameters is as follows:\n1.  Construct the $N \\times N$ interior grid and evaluate the initial field $\\phi_{0,ij}$ and the source function $S_{ij}$ at each grid point.\n2.  Compute the discrete Laplacian of the initial field, $(\\Delta\\phi_0)_{ij}$, using a padded grid to enforce boundary conditions.\n3.  Compute the initial Hamiltonian residual field $H(\\phi_0)_{ij}$.\n4.  Calculate the discrete $L^2$ norm of the initial residual, $\\lVert H(\\phi_0)\\rVert_h = \\sqrt{h^2 \\sum_{i,j=1}^N (H(\\phi_0)_{ij})^2}$. If this norm is less than the tolerance $10^{-14}$, the ratio $r$ is defined as $0$.\n5.  Otherwise, construct the $N^2 \\times N^2$ sparse matrix $M$ representing the discretized linear operator $L_{\\phi_0}$ and the right-hand side vector $\\vec{b}$ by flattening $-H(\\phi_0)_{ij}$.\n6.  Solve the linear system $M \\vec{d} = \\vec{b}$ for the flattened correction vector $\\vec{d}$.\n7.  Reshape $\\vec{d}$ into an $N \\times N$ matrix representing the correction $\\delta\\phi_{ij}$.\n8.  Compute the updated field $\\phi_{\\text{after}, ij} = \\phi_{0,ij} + \\delta\\phi_{ij}$.\n9.  Compute the final Hamiltonian residual $H(\\phi_{\\text{after}})$ by applying the discrete Hamiltonian operator to $\\phi_{\\text{after}}$.\n10. Calculate the norm of the final residual, $\\lVert H(\\phi_{\\text{after}})\\rVert_h$.\n11. The reduction ratio is $r = \\lVert H(\\phi_{\\text{after}})\\rVert_h / \\lVert H(\\phi_0)\\rVert_h$.\n\nThis procedure is applied to each test case to determine the effectiveness of the constraint projection step. For the linear case $\\beta=0$, this single step is expected to solve the equation exactly, yielding a final residual and ratio of approximately zero, limited only by floating-point precision. For nonlinear cases, the ratio quantifies the quadratic convergence characteristic of a Newton-Raphson step.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags, identity, kron\nfrom scipy.sparse.linalg import spsolve\n\ndef compute_hamiltonian(phi_interior, S_interior, beta, h, N):\n    \"\"\"Computes the discrete Hamiltonian residual H(phi).\"\"\"\n    phi_padded = np.zeros((N + 2, N + 2))\n    phi_padded[1:-1, 1:-1] = phi_interior\n    \n    # Second-order central difference for the Laplacian\n    lap_phi = (phi_padded[2:, 1:-1] + phi_padded[:-2, 1:-1] +\n               phi_padded[1:-1, 2:] + phi_padded[1:-1, :-2] -\n               4 * phi_interior) / (h**2)\n               \n    # H(phi) = -8*Delta(phi) + beta*phi^5 - S\n    H_val = -8 * lap_phi + beta * (phi_interior**5) - S_interior\n    return H_val\n\ndef compute_norm(H_val, h):\n    \"\"\"Computes the discrete L2 norm of the residual.\"\"\"\n    # norm = sqrt(h^2 * sum(H_ij^2)) = h * ||H||_Frobenius\n    return h * np.linalg.norm(H_val)\n\ndef compute_ratio_for_case(N, epsilon, beta, A, B, sigma):\n    \"\"\"\n    Solves a single test case for the constraint projection problem.\n    \"\"\"\n    h = 1.0 / (N + 1)\n    x = np.linspace(h, 1.0 - h, N)\n    y = np.linspace(h, 1.0 - h, N)\n    xx, yy = np.meshgrid(x, y, indexing='xy')\n\n    # Define initial conformal factor phi_0 and source S on the interior grid\n    phi0_interior = epsilon * np.sin(np.pi * xx) * np.sin(np.pi * yy)\n    S_interior = A * np.sin(2 * np.pi * xx) * np.sin(2 * np.pi * yy) + \\\n                 B * np.exp(-((xx - 0.5)**2 + (yy - 0.5)**2) / (2 * sigma**2))\n\n    # Calculate Hamiltonian residual and norm before projection\n    H_before = compute_hamiltonian(phi0_interior, S_interior, beta, h, N)\n    norm_before = compute_norm(H_before, h)\n\n    # Handle the case where the initial residual is numerically zero\n    if norm_before  1e-14:\n        return 0.0\n\n    # Set up the linear system M * d_phi = -H_before for the correction d_phi\n    \n    # The matrix M represents the linearized operator L = -8*Delta + 5*beta*phi_0^4\n    # We construct it using the Kronecker product for the 2D Laplacian.\n    N2 = N * N\n    # 1D Laplacian matrix (size N x N)\n    D1_matrix = diags([1, -2, 1], [-1, 0, 1], shape=(N, N))\n    I_N = identity(N)\n    \n    # 2D Laplacian matrix (size N^2 x N^2)\n    Lap_matrix_2D = (kron(I_N, D1_matrix) + kron(D1_matrix, I_N)) / h**2\n    \n    # Operator matrix M\n    M = -8 * Lap_matrix_2D\n    \n    # Add the potential term (diagonal matrix)\n    potential_term_flat = 5 * beta * (phi0_interior.flatten()**4)\n    M += diags(potential_term_flat, 0)\n    \n    # Right-hand side vector\n    b = -H_before.flatten()\n    \n    # Solve the sparse linear system for the correction d_phi\n    delta_phi_flat = spsolve(M, b)\n    delta_phi_interior = delta_phi_flat.reshape((N, N))\n    \n    # Update the field: phi_after = phi_0 + d_phi\n    phi_after_interior = phi0_interior + delta_phi_interior\n    \n    # Calculate Hamiltonian residual and norm after projection\n    H_after = compute_hamiltonian(phi_after_interior, S_interior, beta, h, N)\n    norm_after = compute_norm(H_after, h)\n    \n    # Compute the reduction ratio\n    ratio = norm_after / norm_before\n    \n    return ratio\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, epsilon, beta, A, B, sigma)\n        (32, 0.1, 1.0, 1.0, 0.5, 0.15),\n        (8, 0.1, 1.0, 1.0, 0.5, 0.15),\n        (32, 0.0, 1.0, 1.0, 0.5, 0.15),\n        (32, 0.1, 0.0, 1.0, 0.5, 0.15),\n        (64, 0.2, 10.0, 0.5, 1.0, 0.10)\n    ]\n\n    results = []\n    for case in test_cases:\n        ratio = compute_ratio_for_case(*case)\n        results.append(f\"{ratio:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "3470000"}]}