{"hands_on_practices": [{"introduction": "Translation in eukaryotes begins with a search process, where the ribosome scans the messenger RNA for a start signal. This exercise [@problem_id:3325094] challenges you to build a kinetic model of this scanning mechanism from the ground up, treating it as a competition between moving, dissociating, and initiating. By deriving the initiation rates at both an upstream and a main open reading frame, you will gain hands-on experience in modeling stochastic processes, such as leaky scanning, and understand how mRNA architecture quantitatively controls protein production.", "problem": "A messenger ribonucleic acid (mRNA) is translated by the eukaryotic $43\\mathrm{S}$ preinitiation complex (PIC), which binds at the $5^{\\prime}$ cap and scans $5^{\\prime}\\to 3^{\\prime}$ to locate an AUG start codon. Assume the following well-tested mechanistic base: (i) scanning occurs at a constant velocity $v$ (nucleotides per second), (ii) recognition of an AUG within a local Kozak context is a memoryless (Poisson) capture process with a rate proportional to a dimensionless Kozak strength $s\\in[0,1]$, and (iii) while scanning, the PIC can dissociate with a constant hazard $k_{\\text{off}}$ (per second). These assumptions imply that the probability of not capturing (leaky scanning) over a finite recognition window equals the survival probability of a Poisson process, and that survival between sites along the $5^{\\prime}$ untranslated region equals the survival of a constant-hazard process over the corresponding scanning time.\n\nConsider an mRNA with a single upstream open reading frame (uORF) followed by the main open reading frame (main ORF). The uAUG is located $D$ nucleotides downstream of the cap, and the main AUG is located an additional $L$ nucleotides downstream of the uAUG. The recognition window around any AUG has width $w$ nucleotides. The capture rate at an AUG with Kozak strength $s$ is $k_{0}s$ (per second), where $k_{0}$ is a constant. The PIC loads on the cap at rate $J_{0}$ (per second). Assume noninteracting PICs (no queueing), no reinitiation after terminating the uORF, and that initiation at an AUG is instantaneous upon capture.\n\n1. Construct from first principles the leaky scanning probability $p_{\\text{leak}}(s)$ as a function of Kozak strength $s$, the recognition window width $w$, the scanning velocity $v$, and the base capture rate $k_{0}$.\n2. Using your expression for $p_{\\text{leak}}(s)$ and the constant-hazard survival during scanning, derive the steady-state initiation rates at the uORF ($J_{\\mathrm{u}}$) and at the main ORF ($J_{\\mathrm{m}}$) as functions of $J_{0}$, $D$, $L$, $v$, $k_{\\text{off}}$, $k_{0}$, $w$, and the respective Kozak strengths $s_{\\mathrm{u}}$ and $s_{\\mathrm{m}}$.\n3. Evaluate $J_{\\mathrm{u}}$ and $J_{\\mathrm{m}}$ numerically for the parameter set $J_{0}=\\,$ $0.50$ $\\mathrm{s}^{-1}$, $v=\\,$ $10$ $\\mathrm{nt}\\cdot\\mathrm{s}^{-1}$, $w=\\,$ $12$ $\\mathrm{nt}$, $k_{0}=\\,$ $2.0$ $\\mathrm{s}^{-1}$, $k_{\\text{off}}=\\,$ $0.010$ $\\mathrm{s}^{-1}$, $D=\\,$ $60$ $\\mathrm{nt}$, $L=\\,$ $120$ $\\mathrm{nt}$, $s_{\\mathrm{u}}=\\,$ $0.60$, and $s_{\\mathrm{m}}=\\,$ $0.90$.\n\nReport the two initiation rates as a two-entry row vector $\\big(J_{\\mathrm{u}},\\,J_{\\mathrm{m}}\\big)$ in $\\mathrm{s}^{-1}$, rounded to three significant figures.", "solution": "The problem statement has been validated and found to be scientifically grounded, well-posed, objective, and self-consistent. The model presented is a standard simplified representation of eukaryotic translation initiation, frequently used in computational systems biology. All necessary parameters and assumptions are clearly defined.\n\n### Part 1: Derivation of Leaky Scanning Probability $p_{\\text{leak}}(s)$\n\nThe problem defines the recognition of an AUG codon as a memoryless Poisson capture process. The probability of leaky scanning, $p_{\\text{leak}}(s)$, is the probability that the preinitiation complex (PIC) scans through the recognition window surrounding an AUG without being captured. This is equivalent to the survival probability of the Poisson process over the duration the PIC spends within the window.\n\nFirst, we determine the time, $\\Delta t$, that the PIC spends scanning across the recognition window of width $w$ at a constant velocity $v$:\n$$ \\Delta t = \\frac{w}{v} $$\nThe capture process has a rate $\\lambda$ which is given as $k_{0}s$, where $k_{0}$ is a base capture rate constant and $s$ is the dimensionless Kozak strength.\n$$ \\lambda = k_{0}s $$\nFor a Poisson process with a constant rate $\\lambda$, the probability of observing zero events (in this case, zero capture events) over a time interval $\\Delta t$ is given by:\n$$ P(N(\\Delta t)=0) = \\exp(-\\lambda \\Delta t) $$\nThis probability is, by definition, the leaky scanning probability $p_{\\text{leak}}(s)$. Substituting the expressions for $\\lambda$ and $\\Delta t$, we obtain:\n$$ p_{\\text{leak}}(s) = \\exp\\left(-k_{0}s \\frac{w}{v}\\right) $$\nThis expression gives the probability of a PIC failing to initiate at an AUG codon as a function of the Kozak strength $s$ and the system parameters $k_{0}$, $w$, and $v$.\n\n### Part 2: Derivation of steady-state Initiation Rates $J_{\\mathrm{u}}$ and $J_{\\mathrm{m}}$\n\nWe model the flow of PICs along the mRNA as a cascade of stochastic events. The rate of PICs loading onto the $5^{\\prime}$ cap is $J_{0}$.\n\n**Initiation Rate at the uORF ($J_{\\mathrm{u}}$):**\nFor a PIC to initiate at the upstream AUG (uAUG), it must first successfully scan from the $5^{\\prime}$ cap to the uAUG, a distance of $D$ nucleotides, without dissociating. The time taken for this is $t_{D} = D/v$. Dissociation is a constant-hazard process with rate $k_{\\text{off}}$. The probability of a PIC surviving this scanning segment is:\n$$ P_{\\text{surv}}(t_{D}) = \\exp(-k_{\\text{off}} t_{D}) = \\exp\\left(-\\frac{k_{\\text{off}} D}{v}\\right) $$\nThe rate at which PICs arrive at the uAUG recognition window is the initial loading rate $J_{0}$ multiplied by this survival probability:\n$$ J_{\\text{arrive, u}} = J_{0} \\exp\\left(-\\frac{k_{\\text{off}} D}{v}\\right) $$\nUpon arrival, the PIC is captured (initiates) with a probability of $1 - p_{\\text{leak}}(s_{\\mathrm{u}})$, where $s_{\\mathrm{u}}$ is the Kozak strength of the uAUG. The steady-state initiation rate at the uORF, $J_{\\mathrm{u}}$, is the arrival rate multiplied by the capture probability:\n$$ J_{\\mathrm{u}} = J_{\\text{arrive, u}} \\left(1 - p_{\\text{leak}}(s_{\\mathrm{u}})\\right) $$\nSubstituting the expressions for $J_{\\text{arrive, u}}$ and $p_{\\text{leak}}(s_{\\mathrm{u}})$:\n$$ J_{\\mathrm{u}} = J_{0} \\exp\\left(-\\frac{k_{\\text{off}} D}{v}\\right) \\left[1 - \\exp\\left(-\\frac{k_{0} s_{\\mathrm{u}} w}{v}\\right)\\right] $$\n\n**Initiation Rate at the Main ORF ($J_{\\mathrm{m}}$):**\nFor a PIC to initiate at the main AUG (mAUG), it must first pass the uAUG. This requires arriving at the uAUG and then undergoing leaky scanning. The rate of PICs leaking past the uAUG is:\n$$ J_{\\text{leak, u}} = J_{\\text{arrive, u}} \\cdot p_{\\text{leak}}(s_{\\mathrm{u}}) = J_{0} \\exp\\left(-\\frac{k_{\\text{off}} D}{v}\\right) \\exp\\left(-\\frac{k_{0} s_{\\mathrm{u}} w}{v}\\right) $$\nThese PICs must then scan the additional distance $L$ to reach the main AUG. The time taken is $t_{L} = L/v$, and the probability of surviving this segment without dissociation is:\n$$ P_{\\text{surv}}(t_{L}) = \\exp(-k_{\\text{off}} t_{L}) = \\exp\\left(-\\frac{k_{\\text{off}} L}{v}\\right) $$\nThe rate of PICs arriving at the main AUG is the leakage rate from the uAUG multiplied by the survival probability over the distance $L$:\n$$ J_{\\text{arrive, m}} = J_{\\text{leak, u}} \\cdot P_{\\text{surv}}(t_{L}) = J_{0} \\exp\\left(-\\frac{k_{\\text{off}} D}{v}\\right) \\exp\\left(-\\frac{k_{0} s_{\\mathrm{u}} w}{v}\\right) \\exp\\left(-\\frac{k_{\\text{off}} L}{v}\\right) $$\nCombining the exponential terms, the arrival rate at the main AUG is:\n$$ J_{\\text{arrive, m}} = J_{0} \\exp\\left(-\\frac{k_{\\text{off}}(D+L) + k_{0} s_{\\mathrm{u}} w}{v}\\right) $$\nThe initiation rate at the main ORF, $J_{\\mathrm{m}}$, is this arrival rate multiplied by the capture probability at the main AUG, which has Kozak strength $s_{\\mathrm{m}}$:\n$$ J_{\\mathrm{m}} = J_{\\text{arrive, m}} \\left(1 - p_{\\text{leak}}(s_{\\mathrm{m}})\\right) $$\nSubstituting the expressions for $J_{\\text{arrive, m}}$ and $p_{\\text{leak}}(s_{\\mathrm{m}})$ gives the final expression for $J_{\\mathrm{m}}$:\n$$ J_{\\mathrm{m}} = J_{0} \\exp\\left(-\\frac{k_{\\text{off}}(D+L) + k_{0} s_{\\mathrm{u}} w}{v}\\right) \\left[1 - \\exp\\left(-\\frac{k_{0} s_{\\mathrm{m}} w}{v}\\right)\\right] $$\n\n### Part 3: Numerical Evaluation\n\nWe are given the following parameter values:\n$J_{0}=\\,$ $0.50$ $\\mathrm{s}^{-1}$\n$v=\\,$ $10$ $\\mathrm{nt}\\cdot\\mathrm{s}^{-1}$\n$w=\\,$ $12$ $\\mathrm{nt}$\n$k_{0}=\\,$ $2.0$ $\\mathrm{s}^{-1}$\n$k_{\\text{off}}=\\,$ $0.010$ $\\mathrm{s}^{-1}$\n$D=\\,$ $60$ $\\mathrm{nt}$\n$L=\\,$ $120$ $\\mathrm{nt}$\n$s_{\\mathrm{u}}=\\,$ $0.60$\n$s_{\\mathrm{m}}=\\,$ $0.90$\n\nFirst, we calculate the values of the exponents in the derived expressions.\nFor $J_{\\mathrm{u}}$:\nThe dissociation exponent is $-\\frac{k_{\\text{off}} D}{v} = -\\frac{0.010 \\times 60}{10} = -0.06$.\nThe uAUG capture exponent is $-\\frac{k_{0} s_{\\mathrm{u}} w}{v} = -\\frac{2.0 \\times 0.60 \\times 12}{10} = -1.44$.\nSubstituting these into the expression for $J_{\\mathrm{u}}$:\n$$ J_{\\mathrm{u}} = 0.50 \\times \\exp(-0.06) \\times [1 - \\exp(-1.44)] $$\n$$ J_{\\mathrm{u}} \\approx 0.50 \\times 0.94176 \\times (1 - 0.23693) $$\n$$ J_{\\mathrm{u}} \\approx 0.50 \\times 0.94176 \\times 0.76307 \\approx 0.35932 \\, \\mathrm{s}^{-1} $$\n\nFor $J_{\\mathrm{m}}$:\nThe combined exponent for dissociation and leaky scanning is:\n$$ -\\frac{k_{\\text{off}}(D+L) + k_{0} s_{\\mathrm{u}} w}{v} = -\\frac{k_{\\text{off}}(60+120)}{10} - \\frac{k_{0} s_{\\mathrm{u}} w}{10} = -\\frac{0.010 \\times 180}{10} - 1.44 = -0.18 - 1.44 = -1.62 $$\nThe main AUG capture exponent is $-\\frac{k_{0} s_{\\mathrm{m}} w}{v} = -\\frac{2.0 \\times 0.90 \\times 12}{10} = -2.16$.\nSubstituting these into the expression for $J_{\\mathrm{m}}$:\n$$ J_{\\mathrm{m}} = 0.50 \\times \\exp(-1.62) \\times [1 - \\exp(-2.16)] $$\n$$ J_{\\mathrm{m}} \\approx 0.50 \\times 0.19791 \\times (1 - 0.11533) $$\n$$ J_{\\mathrm{m}} \\approx 0.50 \\times 0.19791 \\times 0.88467 \\approx 0.08754 \\, \\mathrm{s}^{-1} $$\n\nRounding both results to three significant figures, we get:\n$J_{\\mathrm{u}} \\approx 0.359$ $\\mathrm{s}^{-1}$\n$J_{\\mathrm{m}} \\approx 0.0875$ $\\mathrm{s}^{-1}$", "answer": "$$ \\boxed{ \\begin{pmatrix} 0.359 & 0.0875 \\end{pmatrix} } $$", "id": "3325094"}, {"introduction": "Once translation initiates, the ribosome's journey is a sequence of elongation cycles, the speed of which is a critical determinant of protein output. This practice [@problem_id:3325036] delves into the kinetics of elongation, asking you to model how codon-specific translation times depend on the availability of cognate tRNAs. You will implement a computational model to predict not only the average translation speed for a given gene but also how manipulating cellular resources—by overexpressing a rare tRNA—can impact the entire translational landscape.", "problem": "You are given a quantitative model of ribosome elongation that treats codon decoding as a two-stage process: first, selection and accommodation of the cognate transfer ribonucleic acid (tRNA), and second, peptide bond formation and translocation. Begin from the Central Dogma of Molecular Biology (CDMB) and the well-tested mechanistic facts that ribosome elongation proceeds codon-by-codon, that tRNA arrival and correct decoding can be modeled as a mass-action limited step with a rate proportional to the effective tRNA availability, and that peptide bond formation and translocation contribute an approximately codon-independent base time. The measured tRNA adaptiveness table provides dimensionless values for each codon that are proportional to effective tRNA availability. Your task is to compute, for a given messenger ribonucleic acid (mRNA), the expected elongation time per codon in seconds, and to predict the effect of overexpressing a rare tRNA isoacceptor on the aggregate translation throughput of a small set of representative mRNAs.\n\nDefinitions and constants to use:\n- The codon-independent base time for peptide bond formation and translocation is $t_{\\mathrm{pep}} = 0.02$ seconds.\n- The tRNA selection-accommodation step is modeled as a Poisson arrival process with rate constant $k_{\\mathrm{sel}} = 40$ $\\mathrm{s}^{-1}$ per unit adaptiveness. The measured adaptiveness value for codon $c$, denoted $w_c$, is proportional to the effective cognate tRNA availability for that codon.\n- Stop codons do not contribute to elongation time and should be excluded from per-codon averages and total elongation times.\n- The global translation throughput for a set of mRNAs indexed by $m$ with initiation rates $\\lambda_m$ (in $\\mathrm{s}^{-1}$) and total elongation times $T_{\\mathrm{elong},m}$ (in seconds) is defined, under a simplified non-collision limit, as $J_{\\mathrm{global}} = \\sum_m \\min\\!\\left(\\lambda_m, \\, 1 / T_{\\mathrm{elong},m}\\right)$.\n\nOperational requirements:\n1. For each test case, compute the expected elongation time per codon (in seconds) for a designated focus mRNA sequence. This is the mean of the elongation times across all non-stop codons of that sequence. Express the answer in seconds, rounded to six decimal places.\n2. Model overexpression of a single rare tRNA isoacceptor as a multiplicative increase by a factor $r$ applied to $w_c$ for all codons $c$ decoded by that isoacceptor. Recompute the global translation throughput $J_{\\mathrm{global}}$ after overexpression. Report the ratio $R = J_{\\mathrm{global}}^{\\mathrm{after}} / J_{\\mathrm{global}}^{\\mathrm{before}}$ as a decimal rounded to six decimal places.\n3. Codon sequences are provided as uppercase strings over the alphabet $\\{ \\mathrm{A}, \\mathrm{U}, \\mathrm{G}, \\mathrm{C} \\}$ and should be parsed in triplets. Stop codons are $\\mathrm{UAA}$, $\\mathrm{UAG}$, and $\\mathrm{UGA}$. If a stop codon appears, it should be ignored in time calculations.\n4. All outputs must be rounded to six decimal places.\n5. Final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is a two-element list $[t_{\\mathrm{mean}}, R]$ for a test case (e.g., $[[t_1,R_1],[t_2,R_2]]$).\n\nMeasured tRNA adaptiveness table (dimensionless $w_c$) for codons used in the test suite:\n- $\\mathrm{AUG} \\mapsto 0.9$, $\\mathrm{CGA} \\mapsto 0.05$, $\\mathrm{GCU} \\mapsto 0.8$, $\\mathrm{UUU} \\mapsto 0.7$, $\\mathrm{AAA} \\mapsto 0.6$, $\\mathrm{UGG} \\mapsto 0.5$, $\\mathrm{GAA} \\mapsto 0.9$, $\\mathrm{CUG} \\mapsto 0.75$, $\\mathrm{AUA} \\mapsto 0.3$.\n\nThe rare tRNA isoacceptor targeted for overexpression decodes only codon $\\mathrm{CGA}$ in this test suite.\n\nTest suite parameter sets:\n- Test case $1$:\n  - Focus mRNA: $\\mathrm{AUGCGAGCUCGAUUUAAAUGGUAA}$.\n  - Other mRNAs: $\\mathrm{AUGGCUUUUGAAGCUCUGUAA}$, $\\mathrm{AUGAUAUGGGCUAUAUAA}$.\n  - Initiation rates: $\\lambda_1 = 0.3$ $\\mathrm{s}^{-1}$, $\\lambda_2 = 0.5$ $\\mathrm{s}^{-1}$, $\\lambda_3 = 0.2$ $\\mathrm{s}^{-1}$.\n  - Overexpression factor: $r = 4.0$.\n\n- Test case $2$:\n  - Focus mRNA: $\\mathrm{AUGGCUUUUGAAUGGUAA}$.\n  - Other mRNAs: $\\mathrm{AUGAAAUGGGCUUAA}$, $\\mathrm{AUGCUGGCUUUUGAAUAA}$.\n  - Initiation rates: $\\lambda_1 = 0.4$ $\\mathrm{s}^{-1}$, $\\lambda_2 = 0.6$ $\\mathrm{s}^{-1}$, $\\lambda_3 = 0.3$ $\\mathrm{s}^{-1}$.\n  - Overexpression factor: $r = 10.0$.\n\n- Test case $3$:\n  - Focus mRNA: $\\mathrm{AUGCGACGACGACGAUAA}$.\n  - Other mRNAs: $\\mathrm{AUGGCUUUUAAAGCUUAA}$, $\\mathrm{AUGUGGGCUUGGUUUUAA}$.\n  - Initiation rates: $\\lambda_1 = 1.2$ $\\mathrm{s}^{-1}$, $\\lambda_2 = 0.6$ $\\mathrm{s}^{-1}$, $\\lambda_3 = 0.7$ $\\mathrm{s}^{-1}$.\n  - Overexpression factor: $r = 2.5$.\n\n- Test case $4$ (boundary):\n  - Focus mRNA: $\\mathrm{AUGCGAUGGGCUUUUAAAUAA}$.\n  - Other mRNAs: $\\mathrm{AUGGCUCUGGAAUUUUAA}$, $\\mathrm{AUGAAAUGGAUACUGUAA}$.\n  - Initiation rates: $\\lambda_1 = 0.5$ $\\mathrm{s}^{-1}$, $\\lambda_2 = 0.7$ $\\mathrm{s}^{-1}$, $\\lambda_3 = 0.4$ $\\mathrm{s}^{-1}$.\n  - Overexpression factor: $r = 1.0$.\n\nYour program must implement the above model and produce a single line of output containing the list of $[t_{\\mathrm{mean}}, R]$ pairs for the four test cases, rounded to six decimal places, in the exact format described.", "solution": "The problem has been validated against the specified criteria and is determined to be a valid, well-posed scientific problem.\n\n### Step 1: Extract Givens\n- **Model**: Ribosome elongation is a two-stage process: tRNA selection/accommodation and peptide bond formation/translocation.\n- **Constants**:\n    - Codon-independent base time for peptide bond formation and translocation, $t_{\\mathrm{pep}} = 0.02$ seconds.\n    - tRNA selection-accommodation rate constant, $k_{\\mathrm{sel}} = 40$ $\\mathrm{s}^{-1}$ per unit adaptiveness.\n- **Definitions**:\n    - Measured adaptiveness for codon $c$: $w_c$.\n    - Stop codons ($\\mathrm{UAA}$, $\\mathrm{UAG}$, $\\mathrm{UGA}$) are excluded from time calculations.\n    - Global translation throughput: $J_{\\mathrm{global}} = \\sum_m \\min\\!\\left(\\lambda_m, \\, 1 / T_{\\mathrm{elong},m}\\right)$.\n    - Initiation rate for mRNA $m$: $\\lambda_m$.\n    - Total elongation time for mRNA $m$: $T_{\\mathrm{elong},m}$.\n- **Operational Requirements**:\n    1. Compute expected elongation time per codon, $t_{\\mathrm{mean}}$, for a focus mRNA, rounded to six decimal places.\n    2. Compute the ratio $R = J_{\\mathrm{global}}^{\\mathrm{after}} / J_{\\mathrm{global}}^{\\mathrm{before}}$ after overexpression of a rare tRNA isoacceptor by a factor $r$, rounded to six decimal places.\n    3. mRNA sequences are parsed as triplets of $\\{ \\mathrm{A}, \\mathrm{U}, \\mathrm{G}, \\mathrm{C} \\}$.\n- **Measured tRNA Adaptiveness Table ($w_c$)**:\n    - $\\mathrm{AUG} \\mapsto 0.9$\n    - $\\mathrm{CGA} \\mapsto 0.05$\n    - $\\mathrm{GCU} \\mapsto 0.8$\n    - $\\mathrm{UUU} \\mapsto 0.7$\n    - $\\mathrm{AAA} \\mapsto 0.6$\n    - $\\mathrm{UGG} \\mapsto 0.5$\n    - $\\mathrm{GAA} \\mapsto 0.9$\n    - $\\mathrm{CUG} \\mapsto 0.75$\n    - $\\mathrm{AUA} \\mapsto 0.3$\n- **Overexpression Target**: The rare tRNA isoacceptor decodes only codon $\\mathrm{CGA}$.\n- **Test Cases**: Four test cases are provided, each specifying: a focus mRNA, a set of other mRNAs, their respective initiation rates $\\lambda_m$, and an overexpression factor $r$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, well-posed, and objective. It is based on a simplified but standard kinetic model of protein synthesis, a core topic in computational systems biology. All parameters, constants, and functions are explicitly defined, leading to a unique, computable solution for each test case. The problem is free from scientific falsehoods, ambiguity, or contradictions.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be provided.\n\n### Principle-Based Solution Design\n\nThe solution is constructed by first establishing a mathematical model for the elongation time of a single codon, then extending this to an entire mRNA sequence, and finally aggregating the results for a set of mRNAs to compute global throughput.\n\n**1. Modeling Elongation Time per Codon**\nThe total time to translate a single codon $c$, denoted $t_c$, is the sum of the time for the two stages described: tRNA selection/accommodation and peptide bond formation/translocation.\nThe peptide bond formation and translocation step is given as a constant base time, $t_{\\mathrm{pep}} = 0.02 \\, \\mathrm{s}$.\nThe tRNA selection-accommodation step is modeled as a Poisson arrival process. The rate of this process for a codon $c$ is proportional to the effective tRNA availability, which is quantified by the adaptiveness value $w_c$. The rate is $\\lambda_c = k_{\\mathrm{sel}} \\cdot w_c$. The expected time for an event in a Poisson process is the reciprocal of its rate. Therefore, the expected time for this selection step is:\n$$t_{\\mathrm{sel}, c} = \\frac{1}{\\lambda_c} = \\frac{1}{k_{\\mathrm{sel}} \\cdot w_c}$$\nThe total expected elongation time for codon $c$ is the sum of the times for the two stages:\n$$t_c = t_{\\mathrm{sel}, c} + t_{\\mathrm{pep}} = \\frac{1}{k_{\\mathrm{sel}} \\cdot w_c} + t_{\\mathrm{pep}}$$\nSubstituting the given constants, $k_{\\mathrm{sel}} = 40 \\, \\mathrm{s}^{-1}$ and $t_{\\mathrm{pep}} = 0.02 \\, \\mathrm{s}$, we get the specific formula for our problem:\n$$t_c = \\frac{1}{40 \\cdot w_c} + 0.02$$\n\n**2. Calculating Total and Mean Elongation Time**\nTo find the total elongation time for a given mRNA molecule, $T_{\\mathrm{elong},m}$, we parse its nucleotide sequence into a series of codons. We iterate through these codons, excluding any stop codons ($\\mathrm{UAA}$, $\\mathrm{UAG}$, $\\mathrm{UGA}$). For each non-stop codon $c_i$ in the sequence, we calculate its elongation time $t_{c_i}$ using the formula above and the provided adaptiveness table. The total elongation time is the sum over all $N_m$ non-stop codons:\n$$T_{\\mathrm{elong},m} = \\sum_{i=1}^{N_m} t_{c_i} = \\sum_{i=1}^{N_m} \\left( \\frac{1}{40 \\cdot w_{c_i}} + 0.02 \\right)$$\nThe first required output, the expected elongation time per codon for the focus mRNA, $t_{\\mathrm{mean}}$, is the arithmetic mean of these times:\n$$t_{\\mathrm{mean}} = \\frac{T_{\\mathrm{elong}, \\mathrm{focus}}}{N_{\\mathrm{focus}}}$$\nwhere $N_{\\mathrm{focus}}$ is the number of non-stop codons in the focus mRNA.\n\n**3. Calculating Global Throughput and the Overexpression Ratio**\nThe global translation throughput, $J_{\\mathrm{global}}$, is the sum of individual throughputs for a set of mRNAs. The throughput for a single mRNA $m$ is limited by the slower of two processes: translation initiation (at rate $\\lambda_m$) and translation elongation. The maximum rate of elongation is the reciprocal of the total time required to translate one full transcript, $1/T_{\\mathrm{elong},m}$. Thus, the throughput for mRNA $m$ is $J_m = \\min(\\lambda_m, 1/T_{\\mathrm{elong},m})$. The global throughput is the sum over all mRNAs in the set:\n$$J_{\\mathrm{global}} = \\sum_m J_m = \\sum_m \\min\\left(\\lambda_m, \\frac{1}{T_{\\mathrm{elong},m}}\\right)$$\nTo find the required ratio $R = J_{\\mathrm{global}}^{\\mathrm{after}} / J_{\\mathrm{global}}^{\\mathrm{before}}$, we must perform this calculation twice.\nFirst, we calculate $J_{\\mathrm{global}}^{\\mathrm{before}}$ using the original adaptiveness table $\\{w_c\\}$.\nSecond, we model the overexpression of the tRNA for codon $\\mathrm{CGA}$. This is represented by creating a new adaptiveness value, $w'_{\\mathrm{CGA}} = w_{\\mathrm{CGA}} \\cdot r$, where $r$ is the given overexpression factor. All other adaptiveness values remain unchanged. Using this modified adaptiveness table, we recalculate the total elongation time for each mRNA, $T_{\\mathrm{elong},m}^{\\mathrm{after}}$, which will only change for mRNAs containing the $\\mathrm{CGA}$ codon. We then compute the new global throughput, $J_{\\mathrm{global}}^{\\mathrm{after}}$.\nFinally, the ratio $R$ is calculated. Both $t_{\\mathrm{mean}}$ and $R$ are rounded to six decimal places as required. The entire process is repeated for each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the ribosome elongation problem for the given test suite.\n    \"\"\"\n    \n    # --- Define constants and model parameters ---\n    T_PEP = 0.02  # seconds\n    K_SEL = 40.0  # s^-1 per unit adaptiveness\n    \n    W_TABLE = {\n        'AUG': 0.9, 'CGA': 0.05, 'GCU': 0.8, 'UUU': 0.7, 'AAA': 0.6,\n        'UGG': 0.5, 'GAA': 0.9, 'CUG': 0.75, 'AUA': 0.3\n    }\n    \n    STOP_CODONS = {'UAA', 'UAG', 'UGA'}\n    RARE_CODON = 'CGA'\n    \n    # --- Define test cases from the problem statement ---\n    test_cases = [\n        {\n            \"mRNAs\": ['AUGCGAGCUCGAUUUAAAUGGUAA', 'AUGGCUUUUGAAGCUCUGUAA', 'AUGAUAUGGGCUAUAUAA'],\n            \"lambdas\": [0.3, 0.5, 0.2],\n            \"r\": 4.0\n        },\n        {\n            \"mRNAs\": ['AUGGCUUUUGAAUGGUAA', 'AUGAAAUGGGCUUAA', 'AUGCUGGCUUUUGAAUAA'],\n            \"lambdas\": [0.4, 0.6, 0.3],\n            \"r\": 10.0\n        },\n        {\n            \"mRNAs\": ['AUGCGACGACGACGAUAA', 'AUGGCUUUUAAAGCUUAA', 'AUGUGGGCUUGGUUUUAA'],\n            \"lambdas\": [1.2, 0.6, 0.7],\n            \"r\": 2.5\n        },\n        {\n            \"mRNAs\": ['AUGCGAUGGGCUUUUAAAUAA', 'AUGGCUCUGGAAUUUUAA', 'AUGAAAUGGAUACUGUAA'],\n            \"lambdas\": [0.5, 0.7, 0.4],\n            \"r\": 1.0\n        }\n    ]\n\n    # --- Helper function to parse mRNA and calculate elongation time ---\n    def calculate_elongation_time(mrna_seq, w_table):\n        \"\"\"\n        Parses an mRNA sequence and calculates its total elongation time.\n        \n        Args:\n            mrna_seq (str): The mRNA sequence.\n            w_table (dict): The codon adaptiveness table.\n        \n        Returns:\n            tuple: (total_elongation_time, number_of_non_stop_codons)\n        \"\"\"\n        codons = [mrna_seq[i:i+3] for i in range(0, len(mrna_seq), 3)]\n        total_time = 0.0\n        non_stop_codon_count = 0\n        \n        for codon in codons:\n            if len(codon) == 3 and codon not in STOP_CODONS:\n                w_c = w_table.get(codon)\n                # If a codon is not in the table, it cannot be translated.\n                # The problem implicitly guarantees all translatable codons are in the table.\n                if w_c is not None:\n                    t_c = (1.0 / (K_SEL * w_c)) + T_PEP\n                    total_time += t_c\n                    non_stop_codon_count += 1\n                    \n        return total_time, non_stop_codon_count\n\n    results = []\n\n    # --- Process each test case ---\n    for case in test_cases:\n        focus_mrna = case[\"mRNAs\"][0]\n        all_mrnas = case[\"mRNAs\"]\n        lambdas = case[\"lambdas\"]\n        r_factor = case[\"r\"]\n\n        # 1. Compute expected elongation time per codon (t_mean) for the focus mRNA\n        t_elong_focus, n_focus = calculate_elongation_time(focus_mrna, W_TABLE)\n        t_mean = t_elong_focus / n_focus if n_focus > 0 else 0.0\n        \n        # 2. Compute the global throughput ratio R\n        \n        # 'Before' calculation\n        j_global_before = 0.0\n        total_times_before = []\n        for mrna in all_mrnas:\n            t_elong, _ = calculate_elongation_time(mrna, W_TABLE)\n            total_times_before.append(t_elong)\n        \n        for t_elong, lmbda in zip(total_times_before, lambdas):\n            elongation_rate = 1.0 / t_elong if t_elong > 0 else float('inf')\n            j_global_before += min(lmbda, elongation_rate)\n\n        # 'After' calculation\n        w_table_after = W_TABLE.copy()\n        w_table_after[RARE_CODON] = W_TABLE[RARE_CODON] * r_factor\n        \n        j_global_after = 0.0\n        total_times_after = []\n        for mrna in all_mrnas:\n            t_elong, _ = calculate_elongation_time(mrna, w_table_after)\n            total_times_after.append(t_elong)\n\n        for t_elong, lmbda in zip(total_times_after, lambdas):\n            elongation_rate = 1.0 / t_elong if t_elong > 0 else float('inf')\n            j_global_after += min(lmbda, elongation_rate)\n            \n        ratio_r = j_global_after / j_global_before if j_global_before > 0 else 1.0\n\n        # Round and store results for the current test case\n        results.append([round(t_mean, 6), round(ratio_r, 6)])\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"[{t},{r}]\" for t, r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3325036"}, {"introduction": "The cell employs rigorous quality control mechanisms to ensure the fidelity of gene expression, and Nonsense-Mediated Decay (NMD) is a prime example. This hands-on exercise [@problem_id:3325004] explores the tight coupling between translation and mRNA stability by asking you to build a stochastic model of NMD triggering. You will calculate the probability that a premature termination event leads to mRNA degradation, based on ribosome kinetics and the position of molecular markers, thereby predicting the effective lifetime of a transcript.", "problem": "Consider a mechanistic stochastic model of translation-coupled messenger ribonucleic acid (mRNA) surveillance focused on Nonsense-Mediated Decay (NMD). Use the following fundamental base: (i) the Central Dogma, where translation proceeds codon-by-codon along a coding sequence; (ii) first-order, memoryless decay processes add their hazard rates; (iii) an exon junction complex (EJC) is deposited during splicing and NMD is triggered if translation terminates prematurely at a position that is sufficiently upstream of at least one downstream EJC, consistent with the canonical distance rule. You are to formalize the probability of NMD triggering from first principles of a discrete-time hazard process embedded in translation dynamics and then compute the resulting effective mRNA lifetime as the reciprocal of the total decay rate.\n\nDefinitions and assumptions to use:\n- The coding sequence has length $L$ codons. Codons are indexed by $i \\in \\{1,2,\\dots,L\\}$, where $i=L$ is the normal stop codon and $i \\in \\{1,\\dots,L-1\\}$ are positions at which premature termination may occur.\n- The ribosome elongation rate at codon $i$ is $k_i$ in units of codons per second. The residence time at codon $i$ is $1/k_i$ seconds.\n- Let $\\eta$ be a constant hazard per unit time for abortive termination that is independent of position, representing the aggregate of molecular events that lead to a premature termination event (for example, a nonsense codon or abortive termination under stress). Model the per-codon premature termination probability as $q_i = 1 - \\exp\\left(-\\eta/k_i\\right)$, which follows from a Poisson hazard with rate $\\eta$ over a residence time $1/k_i$ at codon $i$.\n- Let $S_{i}$ denote the probability that translation has not terminated prematurely before entering codon $i+1$, with $S_0 = 1$ and $S_i = \\prod_{j=1}^{i} (1-q_j)$.\n- Exon junction complex (EJC) positions are provided as a set of nucleotide coordinates $\\{e_m\\}$, each measured from the translation start site in nucleotides. The nucleotide coordinate for a termination at codon $i$ is $x_i = 3i$.\n- The canonical triggering condition is implemented as follows: a premature termination at codon $i$ triggers NMD if and only if there exists at least one EJC with coordinate $e$ such that $e - x_i \\ge d_{\\mathrm{thr}}$, where $d_{\\mathrm{thr}}$ is the threshold distance in nucleotides, consistent with the empirical $\\approx 50$–$\\approx 55$ nucleotide “rule.”\n- Let $\\delta_M$ be the baseline first-order mRNA decay rate (in $\\mathrm{s}^{-1}$), independent of translation, and let $\\gamma$ be the strength (in $\\mathrm{s}^{-1}$) of NMD-coupled additional decay per transcript, scaled by the probability that translation triggers NMD on a given attempt.\n- Define the probability that a given round of translation triggers NMD as $p_{\\mathrm{PTC}} = \\sum_{i=1}^{L-1} \\left(S_{i-1} q_i \\cdot \\mathbf{1}\\{\\exists e: e - 3i \\ge d_{\\mathrm{thr}}\\}\\right)$, where $\\mathbf{1}\\{\\cdot\\}$ is the indicator function.\n- The total effective decay rate is the sum of the independent hazards from baseline decay and NMD-coupled decay. Define the effective mRNA lifetime $\\tau$ as the reciprocal of this total rate. Express $\\tau$ in seconds.\n\nYour task:\n- Implement a program that, for each provided test case, computes the effective mRNA lifetime $\\tau$ in seconds by first computing $p_{\\mathrm{PTC}}$ from the definitions above and then combining with the baseline and NMD-coupled decay hazards.\n- Your implementation must treat a scalar $k$ as a uniform rate across all codons when a single value is provided, and must otherwise accept position-specific values $\\{k_i\\}$ when provided as a sequence.\n- For NMD triggering, use the exact inequality $e - 3i \\ge d_{\\mathrm{thr}}$.\n\nTest suite (each test case is a tuple $(L, k, \\{e_m\\}, d_{\\mathrm{thr}}, \\eta, \\delta_M, \\gamma)$):\n- Case A (general “happy path” with downstream EJCs and uniform elongation): $(L=\\,$$300$$,\\, k=\\,$$8$$,\\, \\{e_m\\}=\\{\\, $$500$$,\\, $$1200$$ \\,\\},\\, d_{\\mathrm{thr}}=\\,$$55$$,\\, \\eta=\\,$$0.008$$,\\, \\delta_M=\\,$$0.0002$$,\\, \\gamma=\\,$$0.0025$$)$.\n- Case B (no EJCs downstream; NMD cannot trigger): $(L=\\,$$400$$,\\, k=\\,$$10$$,\\, \\{e_m\\}=\\varnothing,\\, d_{\\mathrm{thr}}=\\,$$55$$,\\, \\eta=\\,$$0.01$$,\\, \\delta_M=\\,$$0.0003$$,\\, \\gamma=\\,$$0.003$$)$.\n- Case C (premature termination hazard concentrated after the last EJC): $(L=\\,$$300$$,\\, k=\\,[\\, k_i \\,],\\, \\{e_m\\}=\\{\\, $$450$$ \\,\\},\\, d_{\\mathrm{thr}}=\\,$$55$$,\\, \\eta=\\,$$0.02$$,\\, \\delta_M=\\,$$0.00025$$,\\, \\gamma=\\,$$0.01$$)$ where $k_i=\\,$$200$$ for $i \\le $$200$$ and $k_i=\\,$$2$$ for $i > $$200$$.\n- Case D (near-threshold scenario with an EJC close to the normal stop; hazard concentrated in the last few codons): $(L=\\,$$150$$,\\, k=\\,[\\, k_i \\,],\\, \\{e_m\\}=\\{\\, $$490$$ \\,\\},\\, d_{\\mathrm{thr}}=\\,$$55$$,\\, \\eta=\\,$$0.01$$,\\, \\delta_M=\\,$$0.0004$$,\\, \\gamma=\\,$$0.02$$)$ where $k_i=\\,$$500$$ for $i \\le $$147$$ and $k_i=\\,$$1$$ for $i \\in \\{ $$148$$, $$149$$ \\}$.\n\nOutput specification:\n- For each test case, compute the effective lifetime $\\tau$ in seconds and round each result to $6$ decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order [Case A, Case B, Case C, Case D]. For example, the output format must be exactly like $[\\tau_A,\\tau_B,\\tau_C,\\tau_D]$ with each $\\tau$ rendered as a decimal number rounded to $6$ places and expressed in seconds.", "solution": "The problem has been validated and is determined to be scientifically grounded, well-posed, and self-contained. The provided parameters and definitions are consistent with established principles of molecular and systems biology, allowing for a direct and rigorous solution.\n\nThe central task is to compute the effective mRNA lifetime, $\\tau$, which is defined as the reciprocal of the total effective decay rate, $\\delta_{\\text{eff}}$. The total decay rate is the sum of two independent, first-order hazard rates: a baseline, translation-independent decay rate $\\delta_M$, and an NMD-coupled decay rate. The NMD-coupled pathway's contribution is its maximum rate, $\\gamma$, scaled by the probability that a given round of translation successfully triggers NMD, denoted $p_{\\mathrm{PTC}}$.\n\nThe total effective decay rate is thus given by:\n$$\n\\delta_{\\text{eff}} = \\delta_M + \\gamma \\cdot p_{\\mathrm{PTC}}\n$$\nAnd the effective lifetime is:\n$$\n\\tau = \\frac{1}{\\delta_{\\text{eff}}} = \\frac{1}{\\delta_M + \\gamma \\cdot p_{\\mathrm{PTC}}}\n$$\nThe core of the problem is to calculate $p_{\\mathrm{PTC}}$ from first principles as defined in the problem statement.\n\nThe probability of NMD being triggered in a single translation event, $p_{\\mathrm{PTC}}$, is the sum of probabilities of NMD-triggering premature termination events over all possible premature termination codons, $i \\in \\{1, 2, \\dots, L-1\\}$. For a premature termination at a specific codon $i$ to occur and trigger NMD, two conditions must be met:\n1. The ribosome must translate codons $1$ through $i-1$ without terminating, and then terminate prematurely at codon $i$.\n2. The termination at codon $i$ must satisfy the NMD distance rule.\n\nLet's formalize these probabilities.\nThe ribosome residence time at codon $j$ is $1/k_j$. Given a constant hazard rate of premature termination $\\eta$, the probability of terminating at codon $j$ during its traversal is modeled as a Poisson process. The probability of one or more termination events occurring during the time interval $1/k_j$ is $q_j = 1 - \\exp(-\\eta/k_j)$. Consequently, the probability of successfully traversing codon $j$ is $1-q_j$.\n\nThe probability of surviving translation from codon $1$ through $i-1$ is the product of the individual survival probabilities for each codon. This is given by $S_{i-1}$, where $S_0=1$ and for $i > 1$:\n$$\nS_{i-1} = \\prod_{j=1}^{i-1} (1-q_j)\n$$\nThe probability of terminating specifically at codon $i$ is the probability of surviving up to codon $i$ (i.e., reaching it) multiplied by the probability of terminating at $i$. This is $S_{i-1} \\cdot q_i$.\n\nNext, we incorporate the NMD triggering condition. A premature termination at codon $i$ (nucleotide position $x_i = 3i$) triggers NMD if and only if there exists at least one exon junction complex (EJC) at a position $e$ from the set $\\{e_m\\}$ that is at least $d_{\\mathrm{thr}}$ nucleotides downstream. This condition is expressed using an indicator function, $\\mathbf{1}\\{\\cdot\\}$:\n$$\n\\mathbf{1}\\{\\exists e \\in \\{e_m\\} : e - 3i \\ge d_{\\mathrm{thr}}\\}\n$$\nThis function evaluates to $1$ if the condition is true for any $e \\in \\{e_m\\}$, and $0$ otherwise.\n\nCombining these elements, the total probability of triggering NMD, $p_{\\mathrm{PTC}}$, is the sum over all possible premature termination sites $i=1, \\dots, L-1$:\n$$\np_{\\mathrm{PTC}} = \\sum_{i=1}^{L-1} \\left( S_{i-1} \\cdot q_i \\cdot \\mathbf{1}\\{\\exists e \\in \\{e_m\\} : e - 3i \\ge d_{\\mathrm{thr}}\\} \\right)\n$$\n\nThe computational algorithm proceeds as follows for each test case:\n1.  Initialize $p_{\\mathrm{PTC}} = 0$ and the survival probability tracker $S = 1.0$ (representing $S_0$).\n2.  Construct the position-specific elongation rate vector, $\\{k_i\\}$, for $i \\in \\{1, \\dots, L-1\\}$. If a scalar $k$ is given, all $k_i$ are set to this value.\n3.  Iterate $i$ from $1$ to $L-1$:\n    a. Calculate the per-codon termination probability $q_i = 1 - \\exp(-\\eta/k_i)$.\n    b. Check the NMD triggering condition: determine if there exists any EJC position $e$ in $\\{e_m\\}$ such that $e - 3i \\ge d_{\\mathrm{thr}}$.\n    c. If the NMD condition is met, the probability of this specific event, $S \\cdot q_i$, is added to the running total for $p_{\\mathrm{PTC}}$. Note that at the start of iteration $i$, the variable $S$ holds the value for $S_{i-1}$.\n    d. Update the survival probability for the next iteration: $S \\leftarrow S \\cdot (1-q_i)$. This updates the value from $S_{i-1}$ to $S_i$.\n4.  After the loop completes, calculate the total effective decay rate $\\delta_{\\text{eff}} = \\delta_M + \\gamma \\cdot p_{\\mathrm{PTC}}$.\n5.  Finally, compute the effective mRNA lifetime $\\tau = 1 / \\delta_{\\text{eff}}$.\n\nThis procedure is applied to each of the four test cases provided, yielding the required numerical results.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the effective mRNA lifetime based on a stochastic model of\n    translation-coupled nonsense-mediated decay (NMD).\n    \"\"\"\n\n    # Define a helper to create the k-rate array for specific test cases.\n    def get_k_array_case_c(L):\n        k = np.zeros(L)  # Use 0-based index for array, map to 1-based codon index\n        for i in range(1, L): # Loop over codon indices 1 to L-1\n            if i <= 200:\n                k[i] = 200.0\n            else:\n                k[i] = 2.0\n        return k\n\n    def get_k_array_case_d(L):\n        k = np.zeros(L)\n        for i in range(1, L):\n            if i <= 147:\n                k[i] = 500.0\n            elif i in [148, 149]:\n                k[i] = 1.0\n        return k\n\n    # Test suite: (L, k, {e_m}, d_thr, eta, delta_M, gamma)\n    test_cases = [\n        (300, 8.0, {500, 1200}, 55, 0.008, 0.0002, 0.0025), # Case A\n        (400, 10.0, set(), 55, 0.01, 0.0003, 0.003),         # Case B\n        (300, get_k_array_case_c, {450}, 55, 0.02, 0.00025, 0.01), # Case C\n        (150, get_k_array_case_d, {490}, 55, 0.01, 0.0004, 0.02)  # Case D\n    ]\n\n    results = []\n    for params in test_cases:\n        L, k_param, e_m, d_thr, eta, delta_M, gamma = params\n\n        # Step 1: Set up the elongation rate array k_i for codons i=1..L-1.\n        # The array will be indexed 1 to L-1 for clarity.\n        k_rates = np.zeros(L) \n        if isinstance(k_param, (int, float)):\n            k_rates[1:L] = k_param\n        elif callable(k_param):\n            # For cases C and D, a function generates the array\n            k_rates = k_param(L)\n        \n        # Step 2: Calculate p_PTC\n        p_ptc = 0.0\n        # S_i_minus_1 stores the survival probability S_{i-1}\n        S_i_minus_1 = 1.0 \n\n        # Iterate through all possible premature termination codons i = 1 to L-1\n        for i in range(1, L):\n            k_i = k_rates[i]\n            \n            # This should not happen with valid inputs, but as a safeguard.\n            if k_i <= 0:\n                continue\n\n            # Per-codon premature termination probability\n            q_i = 1.0 - np.exp(-eta / k_i)\n            \n            # Check NMD triggering condition.\n            # Termination at codon i corresponds to nucleotide position 3*i\n            x_i = 3 * i\n            is_nmd_competent = False\n            if e_m: # Only check if there are any EJCs\n                if any(e - x_i >= d_thr for e in e_m):\n                    is_nmd_competent = True\n            \n            # If termination at i is NMD-competent, add its probability to p_ptc\n            if is_nmd_competent:\n                # Probability of surviving up to codon i and terminating at i\n                p_termination_at_i = S_i_minus_1 * q_i\n                p_ptc += p_termination_at_i\n            \n            # Update the survival probability for the next codon.\n            # S_i = S_{i-1} * (1 - q_i)\n            S_i_minus_1 *= (1.0 - q_i)\n\n        # Step 3: Calculate total decay rate and lifetime\n        delta_eff = delta_M + gamma * p_ptc\n        tau = 1.0 / delta_eff\n        \n        results.append(tau)\n\n    # Format the results to 6 decimal places and print in the specified format.\n    # The f-string formatting '{r:.6f}' correctly handles rounding.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n\n```", "id": "3325004"}]}