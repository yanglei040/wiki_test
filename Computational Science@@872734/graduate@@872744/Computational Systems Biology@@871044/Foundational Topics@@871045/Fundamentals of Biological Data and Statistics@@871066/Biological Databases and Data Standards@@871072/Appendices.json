{"hands_on_practices": [{"introduction": "This first practice takes us to the foundational level of genomic data: the raw sequencing read. Here, we will work with the FASTQ format, specifically focusing on decoding the crucial information embedded within the quality score string. This exercise demonstrates the direct mathematical link between the text-based representation in a data file and the probabilistic assessment of data quality. Mastering this conversion ([@problem_id:3291731]) is a fundamental skill for anyone performing quality control on next-generation sequencing data or developing tools that operate on these primary files.", "problem": "You are given a single-read record in the FASTQ format (Sanger encoding). In the Sanger standard, American Standard Code for Information Interchange (ASCII) characters on the quality line are mapped to integer Phred quality scores (Phred) by subtracting an offset of $33$, that is, for a quality character $c$ with ASCII code $\\mathrm{ord}(c)$, the quality score is $Q(c) = \\mathrm{ord}(c) - 33$. The Phred quality score $Q$ is defined by the relationship $Q = -10 \\log_{10}(p)$, where $p$ is the probability that the corresponding base call is incorrect.\n\nConsider the following logically defined FASTQ record (the nucleotide sequence content is irrelevant to the computation but has length $100$):\n\n@read0001\nACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGT\n+\nThe quality line is the concatenation of $25$ occurrences of the character ‘I’, followed by $25$ occurrences of the character ‘5’, followed by $20$ occurrences of the character ‘@’, followed by $20$ occurrences of the character ‘C’, followed by $10$ occurrences of the character ‘+’.\n\nUsing only the definitions above as the foundational starting point:\n- Compute the mean Phred quality score $\\bar{Q}$ across the read of length $100$.\n- Compute the expected error rate for the read, defined as the arithmetic mean of the per-base error probabilities implied by the Phred scores.\n\nReport the expected error rate as your final answer, expressed as a unitless decimal, rounded to five significant figures. Do not report any intermediate values as part of your final answer.", "solution": "The objective is to compute the expected error rate for the given FASTQ read. This rate is the arithmetic mean of the per-base error probabilities. The calculation proceeds in three steps:\n1.  Determine the Phred quality score ($Q$) for each type of character in the quality string.\n2.  Convert each Phred score into its corresponding error probability ($p$).\n3.  Calculate the weighted average of these probabilities based on the frequency of each character.\n\n**Step 1: Calculate Phred Scores**\n\nThe quality string consists of $100$ characters: $25$ 'I's, $25$ '5's, $20$ '@'s, $20$ 'C's, and $10$ '+'s.\nAccording to the Sanger FASTQ standard, the Phred score $Q$ is derived from the ASCII value of the quality character $c$ using the formula:\n$Q(c) = \\mathrm{ord}(c) - 33$\n\nWe find the ASCII values and compute the Phred score for each character:\n-   For 'I': $\\mathrm{ord}('I') = 73 \\implies Q_I = 73 - 33 = 40$\n-   For '5': $\\mathrm{ord}('5') = 53 \\implies Q_5 = 53 - 33 = 20$\n-   For '@': $\\mathrm{ord}('@') = 64 \\implies Q_@ = 64 - 33 = 31$\n-   For 'C': $\\mathrm{ord}('C') = 67 \\implies Q_C = 67 - 33 = 34$\n-   For '+': $\\mathrm{ord}('+') = 43 \\implies Q_+ = 43 - 33 = 10$\n\nAs an intermediate step, the mean Phred score, $\\bar{Q}$, can be calculated:\n$\\bar{Q} = \\frac{(25 \\cdot 40) + (25 \\cdot 20) + (20 \\cdot 31) + (20 \\cdot 34) + (10 \\cdot 10)}{100} = \\frac{1000 + 500 + 620 + 680 + 100}{100} = \\frac{2900}{100} = 29$.\n\n**Step 2: Convert Phred Scores to Error Probabilities**\n\nThe per-base error probability $p$ is related to the Phred score $Q$ by the formula:\n$Q = -10 \\log_{10}(p)$\n\nSolving for $p$, we get:\n$p = 10^{-Q/10}$\n\nWe apply this to each of our calculated Phred scores:\n-   $p_I = 10^{-40/10} = 10^{-4} = 0.0001$\n-   $p_5 = 10^{-20/10} = 10^{-2} = 0.01$\n-   $p_@ = 10^{-31/10} = 10^{-3.1} \\approx 0.00079433$\n-   $p_C = 10^{-34/10} = 10^{-3.4} \\approx 0.00039811$\n-   $p_+ = 10^{-10/10} = 10^{-1} = 0.1$\n\n**Step 3: Calculate the Expected Error Rate**\n\nThe expected error rate for the read is the arithmetic mean of the per-base error probabilities, $\\bar{p}$. We calculate this as the weighted average of the probabilities for each character type:\n$\\bar{p} = \\frac{1}{100} \\sum n_k \\cdot p_k$\n$\\bar{p} = \\frac{1}{100} [ (25 \\cdot 10^{-4}) + (25 \\cdot 10^{-2}) + (20 \\cdot 10^{-3.1}) + (20 \\cdot 10^{-3.4}) + (10 \\cdot 10^{-1}) ]$\n$\\bar{p} = \\frac{1}{100} [ (0.0025) + (0.25) + (20 \\cdot 0.000794328...) + (20 \\cdot 0.000398107...) + (1.0) ]$\n$\\bar{p} = \\frac{1}{100} [ 0.0025 + 0.25 + 0.01588656... + 0.00796214... + 1.0 ]$\n$\\bar{p} = \\frac{1}{100} [ 1.2763487... ]$\n$\\bar{p} \\approx 0.012763487$\n\nFinally, rounding the result to five significant figures as requested:\n$\\bar{p} \\approx 0.012763$", "answer": "$$ \\boxed{0.012763} $$", "id": "3291731"}, {"introduction": "Moving from raw data to structured biological knowledge, this exercise focuses on interpreting genomic annotations using the Generic Feature Format version 3 (GFF3). You will reconstruct complete transcript models by parsing the hierarchical relationships encoded in the file's `ID` and `Parent` attributes. This practice simulates the common and essential bioinformatics task of building computational representations of genes from standard annotation files. By implementing a parser and validator ([@problem_id:3291684]), you will gain a deep, practical understanding of how genome annotations are structured and how to programmatically navigate them.", "problem": "You are given a description and constraints based on the Generic Feature Format version 3 (GFF3) data standard, used extensively in computational systems biology to represent genomic features and their relationships. The goal is to reconstruct transcript exon chains from GFF3-compliant feature records and to detect invalid Parent relationships according to the specification.\n\nFundamental base: Use the canonical rules of the GFF3 specification. The Generic Feature Format version 3 (GFF3) is a tab-delimited format with nine fields per feature line: sequence identifier, source, type, start, end, score, strand, phase, and attributes. The attributes field contains key-value pairs such as identifiers and relationships. The following facts are used as foundational rules:\n- Coordinates are $1$-based and inclusive. A feature has start coordinate $s$ and end coordinate $e$ where $s \\le e$.\n- Parent-child relationships are expressed via attributes with keys $ID$ and $Parent$. A child lists its parent(s) via the $Parent$ tag; multiple parents are separated by commas.\n- Features of type gene, messenger RNA (mRNA), and exon must conform to the following parentage constraints: an mRNA’s $Parent$ must reference a gene, and an exon’s $Parent$ must reference an mRNA. A gene should not have a $Parent$ tag.\n- Transcript exon chain order depends on strand: on the positive strand $+$, order by ascending genomic coordinate; on the negative strand $-$, order by descending genomic coordinate. A tie in start should be broken by end.\n\nTask: For each provided GFF3 snippet, reconstruct the exon chains for each mRNA and detect whether there exists any invalid $Parent$ reference, where invalid means either:\n- a $Parent$ identifier does not exist among the defined feature $ID$s, or\n- a $Parent$ exists but is of the wrong type (for example, an exon referencing a gene), or\n- a gene line has a $Parent$ attribute at all.\n\nAlgorithmic requirement:\n- Parse features and build a mapping from $ID$ to type and strand for mRNA.\n- For each exon, associate it to each $Parent$ mRNA if the parent exists and is of type mRNA.\n- For each mRNA, sort its associated exons to form its exon chain. Sorting is by $(s,e)$ ascending for $+$, and by $(s,e)$ descending for $-$, with ties broken by $e$.\n- Detect invalid $Parent$ references using the rules above.\n- The computational complexity should be justified from principles, relying on dictionary lookups and sorting.\n\nInput model: Your program must internally embed the test suite as strings; no external input is allowed. Each GFF3 snippet comprises valid tab-delimited records using the nine fields and attributes containing $ID$ and $Parent$ tags.\n\nTest suite:\n- Case $1$ (positive strand, single transcript, ordered exons): gene $g1$, mRNA $t1$ ($Parent=g1$), exons at coordinates $[100,200]$ and $[300,400]$, both with $Parent=t1$ and strand $+$.\n- Case $2$ (negative strand, single transcript, out-of-order exons): gene $g2$, mRNA $t2$ ($Parent=g2$), exons at $[450,480]$ and $[500,600]$, both with $Parent=t2$ and strand $-$; output exon chain must be ordered by descending start, yielding exon starts $500$ before $450$.\n- Case $3$ (invalid parent reference): gene $g3$, mRNA $t3$ ($Parent=g3$); exons at $[200,250]$ with $Parent=t3$ and at $[260,300]$ with $Parent=mr\\_unknown$ (nonexistent). Invalid $Parent$ detection must be true; the exon chain for $t3$ must include only its valid exon.\n- Case $4$ (multiple parents with one invalid): gene $g4$, mRNA $t4$ ($Parent=g4$); exon at $[150,180]$ with $Parent=t4,t4b$ (where $t4b$ is missing) and another exon at $[800,900]$ with $Parent=t4$. Invalid $Parent$ detection must be true; $t4$’s chain must include both exons in ascending order on strand $+$.\n- Case $5$ (boundary conditions: tie-breaking in sorting and multiple transcripts): gene $g5$; mRNAs $t5$ and $t5b$ (both $Parent=g5$), all on strand $+$. For $t5$, exons at $[100,150]$, $[100,120]$, and $[160,170]$. For $t5b$, exons at $[210,220]$ and $[300,320]$. The $t5$ chain must sort $[100,120]$ before $[100,150]$ due to tie-breaking on end, then $[160,170]$. The $t5b$ chain must be $[210,220]$ followed by $[300,320]$.\n\nOutput format:\n- For each test case, output a list in the form $[B,N,C]$ where $B$ is a boolean indicating whether any invalid $Parent$ reference was detected, $N$ is an integer equal to the number of mRNAs reconstructed, and $C$ is a list of exon chains (one per mRNA sorted lexicographically by mRNA $ID$). Each exon chain must be a list of integers formed by concatenating the start and end coordinates as $[s_1,e_1,s_2,e_2,\\dots]$ in transcript order.\n- Your program should produce a single line of output containing the results for the five test cases as a comma-separated list enclosed in square brackets, for example: $[[\\dots],[\\dots],[\\dots],[\\dots],[\\dots]]$.\n\nAnswer types: All outputs must be booleans, integers, floats, or lists of these types. There must be no strings in the output beyond the enclosing brackets that are produced by standard list formatting.\n\nYour program must be a complete, runnable Python program that embeds the test suite internally and adheres to the specified output format. No external inputs or files are permitted.", "solution": "The problem requires the reconstruction of transcript exon chains and the validation of parent-child relationships according to the Generic Feature Format version 3 (GFF3) specification. The solution is implemented as a systematic, multi-pass algorithm that first parses and indexes all genomic features, then validates their relationships and reconstructs transcript models, and finally assembles and formats the output.\n\nThe core of the algorithm relies on efficient data structures, primarily dictionaries (hash maps), to store and retrieve feature information. This ensures that operations such as finding a feature by its identifier ($ID$) are performed in average-case constant time, which is crucial for performance.\n\nThe process for each GFF3 snippet is as follows:\n\n**Step 1: Parsing and Indexing**\n\nFirst, we process the raw GFF3 data. Each line, representing a single genomic feature, is parsed into its nine constituent fields. Of these, we are interested in the feature `type` (field $3$), `start` and `end` coordinates (fields $4$ and $5$), `strand` (field $7$), and `attributes` (field $9$).\n\nThe `attributes` field, a semicolon-separated list of `key=value` pairs, is parsed to extract the unique feature `ID` and any `Parent` identifiers. Since the `Parent` attribute can specify multiple parents in a comma-separated list, these are parsed into a list of strings.\n\nAll parsed features are stored in a primary dictionary, let's call it `feature_map`. This dictionary maps each feature's `ID` to an object containing its essential properties: `type`, `strand`, and a list of `Parent` IDs. Coordinates are temporarily stored with exon features for later use. This indexing is critical, as it allows for rapid lookups ($O(1)$ average time) when validating parent-child links. A separate list of all `mRNA` feature `ID`s is also maintained.\n\n**Step 2: Validation and Exon Association**\n\nThe second pass iterates through all parsed features to validate the parentage rules specified in the problem and to associate exons with their parent mRNAs. A boolean flag, `invalid_parent_detected`, is initialized to `false` and is set to `true` if any rule violation is found.\n\nThe validation rules are applied as follows:\n1.  **Gene with Parent**: If a feature of `type` 'gene' is found to have a `Parent` attribute, `invalid_parent_detected` is set to `true`.\n2.  **mRNA Parentage**: For each feature of `type` 'mRNA', we iterate through its `Parent` IDs. For each parent ID `p_id`:\n    - If `p_id` is not a key in `feature_map`, the parent does not exist. `invalid_parent_detected` is set to `true`.\n    - If `p_id` exists, we check if `feature_map[p_id].type` is 'gene'. If not, the parent is of the wrong type, and `invalid_parent_detected` is set to `true`.\n3.  **Exon Parentage**: For each feature of `type` 'exon', we iterate through its `Parent` IDs. For each parent ID `p_id`:\n    - If `p_id` is not in `feature_map`, `invalid_parent_detected` is set to `true`.\n    - If `p_id` exists, we check if `feature_map[p_id].type` is 'mRNA'. If it is not, `invalid_parent_detected` is set to `true`. If it is a valid 'mRNA' parent, the exon's coordinates $(s, e)$ are added to a list associated with that `p_id` in a separate dictionary, `mrna_to_exons`. This dictionary maps each mRNA `ID` to a list of its constituent exons.\n\n**Step 3: Exon Chain Assembly and Sorting**\n\nAfter validation, the `mrna_to_exons` dictionary contains all valid mRNA-to-exon associations. The final step is to construct the ordered exon chains for each mRNA.\n\nFirst, the mRNA `ID`s are sorted lexicographically to ensure a deterministic output order for the final list of chains. Then, for each mRNA:\n- The list of associated exons is retrieved.\n- The `strand` of the mRNA is looked up from the `feature_map`.\n- The sorting order of exons is determined by the `strand`:\n    - For a positive strand (`+`), exons are sorted by their `start` coordinate in ascending order. Ties in `start` are broken by the `end` coordinate, also in ascending order. This corresponds to sorting pairs $(s, e)$ lexicographically.\n    - For a negative strand (`-`), exons are sorted by their `start` coordinate in descending order. Ties are broken by the `end` coordinate, also in descending order. This is equivalent to reverse lexicographical sorting of pairs $(s, e)$.\n- The sorted list of exon coordinate pairs is then flattened into a single list of integers of the form $[s_1, e_1, s_2, e_2, \\dots]$.\n\n**Final Output Generation**\n\nFor each test case, the final result is a $3$-element list $[B, N, C]$ where:\n- $B$ is the `invalid_parent_detected` boolean flag.\n- $N$ is the total number of `mRNA` features found in the input snippet.\n- $C$ is the list of flattened, sorted exon chains, ordered according to the lexicographically sorted mRNA `ID`s.\n\n**Computational Complexity**\n\nLet $N$ be the number of features (lines) in the GFF3 snippet.\n- The parsing and indexing phase (Step 1) requires a single pass over the $N$ lines, with dictionary insertions taking $O(1)$ average time. This phase is $O(N)$.\n- The validation and association phase (Step 2) involves another pass over the $N$ features. For each feature, we may check a small number of parents. Each check is a dictionary lookup ($O(1)$). This phase is also approximately $O(N)$.\n- The assembly and sorting phase (Step 3) is dominated by sorting the exons for each mRNA. If there are $K$ mRNAs and the $k$-th mRNA has $E_k$ exons, the total time is $\\sum_{k=1}^{K} O(E_k \\log E_k)$. In the worst case, where all $N$ features are exons of a single transcript, this becomes $O(N \\log N)$. Sorting the $K$ mRNA IDs takes $O(K \\log K)$.\nThe overall complexity is therefore dominated by sorting, resulting in an efficient $O(N \\log N)$ algorithm.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the GFF3 transcript reconstruction and validation problem.\n    This function embeds the test suite and processes each case according to GFF3 rules.\n    \"\"\"\n    test_cases_gff3 = [\n        # Case 1: positive strand, single transcript, ordered exons\n        \"\"\"\nchr1\\t.\\tgene\\t100\\t400\\t.\\t+\\t.\\tID=g1\nchr1\\t.\\tmRNA\\t100\\t400\\t.\\t+\\t.\\tID=t1;Parent=g1\nchr1\\t.\\texon\\t100\\t200\\t.\\t+\\t.\\tID=e1;Parent=t1\nchr1\\t.\\texon\\t300\\t400\\t.\\t+\\t.\\tID=e2;Parent=t1\n        \"\"\",\n        # Case 2: negative strand, single transcript, out-of-order exons\n        \"\"\"\nchr2\\t.\\tgene\\t450\\t600\\t.\\t-\\t.\\tID=g2\nchr2\\t.\\tmRNA\\t450\\t600\\t.\\t-\\t.\\tID=t2;Parent=g2\nchr2\\t.\\texon\\t500\\t600\\t.\\t-\\t.\\tID=e3;Parent=t2\nchr2\\t.\\texon\\t450\\t480\\t.\\t-\\t.\\tID=e4;Parent=t2\n        \"\"\",\n        # Case 3: invalid parent reference (nonexistent)\n        \"\"\"\nchr3\\t.\\tgene\\t200\\t300\\t.\\t+\\t.\\tID=g3\nchr3\\t.\\tmRNA\\t200\\t300\\t.\\t+\\t.\\tID=t3;Parent=g3\nchr3\\t.\\texon\\t200\\t250\\t.\\t+\\t.\\tID=e5;Parent=t3\nchr3\\t.\\texon\\t260\\t300\\t.\\t+\\t.\\tID=e6;Parent=mr_unknown\n        \"\"\",\n        # Case 4: multiple parents with one invalid\n        \"\"\"\nchr4\\t.\\tgene\\t150\\t900\\t.\\t+\\t.\\tID=g4\nchr4\\t.\\tmRNA\\t150\\t900\\t.\\t+\\t.\\tID=t4;Parent=g4\nchr4\\t.\\texon\\t150\\t180\\t.\\t+\\t.\\tID=e7;Parent=t4,t4b\nchr4\\t.\\texon\\t800\\t900\\t.\\t+\\t.\\tID=e8;Parent=t4\n        \"\"\",\n        # Case 5: boundary conditions: tie-breaking and multiple transcripts\n        \"\"\"\nchr5\\t.\\tgene\\t100\\t320\\t.\\t+\\t.\\tID=g5\nchr5\\t.\\tmRNA\\t100\\t170\\t.\\t+\\t.\\tID=t5;Parent=g5\nchr5\\t.\\tmRNA\\t210\\t320\\t.\\t+\\t.\\tID=t5b;Parent=g5\nchr5\\t.\\texon\\t100\\t150\\t.\\t+\\t.\\tID=e9;Parent=t5\nchr5\\t.\\texon\\t100\\t120\\t.\\t+\\t.\\tID=e10;Parent=t5\nchr5\\t.\\texon\\t160\\t170\\t.\\t+\\t.\\tID=e11;Parent=t5\nchr5\\t.\\texon\\t210\\t220\\t.\\t+\\t.\\tID=e12;Parent=t5b\nchr5\\t.\\texon\\t300\\t320\\t.\\t+\\t.\\tID=e13;Parent=t5b\n        \"\"\"\n    ]\n\n    results = []\n    \n    for gff3_data in test_cases_gff3:\n        lines = [line for line in gff3_data.strip().split('\\n') if line.strip()]\n        \n        feature_map = {}\n        all_features = [] # To iterate over in the second pass\n\n        # Pass 1: Parse and index all features\n        for line in lines:\n            fields = line.strip().split('\\t')\n            seqid, source, ftype, start, end, score, strand, phase, attributes_str = fields\n            start, end = int(start), int(end)\n\n            # Parse attributes\n            attrs = {}\n            for part in attributes_str.split(';'):\n                if '=' in part:\n                    key, value = part.split('=', 1)\n                    attrs[key] = value\n\n            feature_id = attrs.get('ID')\n            parents = attrs.get('Parent', '').split(',') if attrs.get('Parent') else []\n\n            feature_info = {\n                'id': feature_id,\n                'type': ftype,\n                'start': start,\n                'end': end,\n                'strand': strand,\n                'parents': parents\n            }\n            \n            if feature_id:\n                feature_map[feature_id] = feature_info\n            \n            all_features.append(feature_info)\n\n        invalid_parent_found = False\n        mrna_ids = sorted([fid for fid, finfo in feature_map.items() if finfo['type'] == 'mRNA'])\n        mrna_to_exons = {mid: [] for mid in mrna_ids}\n        \n        # Pass 2: Validate relationships and associate exons\n        for feature in all_features:\n            ftype = feature['type']\n            parents = feature['parents']\n\n            if ftype == 'gene' and parents:\n                invalid_parent_found = True\n\n            elif ftype == 'mRNA':\n                if not parents: # An mRNA must have a parent\n                  invalid_parent_found = True\n                for parent_id in parents:\n                    if parent_id not in feature_map:\n                        invalid_parent_found = True\n                    elif feature_map.get(parent_id, {}).get('type') != 'gene':\n                        invalid_parent_found = True\n            \n            elif ftype == 'exon':\n                if not parents: # An exon must have a parent\n                  invalid_parent_found = True\n                for parent_id in parents:\n                    if parent_id not in feature_map:\n                        invalid_parent_found = True\n                    else:\n                        parent_feature = feature_map.get(parent_id)\n                        if parent_feature and parent_feature.get('type') == 'mRNA':\n                            # This check handles cases where an exon parent is a valid mRNA\n                            # but that mRNA is not in the list of mRNAs to be processed (e.g. from another gene).\n                            if parent_id in mrna_to_exons:\n                                mrna_to_exons[parent_id].append((feature['start'], feature['end']))\n                        else:\n                            invalid_parent_found = True\n        \n        # Pass 3: Sort exons and format output\n        exon_chains = []\n        for mrna_id in mrna_ids:\n            exons = mrna_to_exons[mrna_id]\n            strand = feature_map[mrna_id]['strand']\n            \n            if strand == '+':\n                exons.sort(key=lambda x: (x[0], x[1]))\n            elif strand == '-':\n                exons.sort(key=lambda x: (x[0], x[1]), reverse=True)\n            \n            chain = [coord for exon_coords in exons for coord in exon_coords]\n            exon_chains.append(chain)\n\n        results.append([invalid_parent_found, len(mrna_ids), exon_chains])\n\n    # Format the final output string exactly as specified.\n    # The default string representation of lists, booleans, and integers is used.\n    output_str = '[' + ','.join(map(str, results)) + ']'\n    print(output_str)\n\nsolve()\n```", "id": "3291684"}, {"introduction": "Our final practice addresses a critical component of modern data-intensive science: ensuring that data is Findable, Accessible, Interoperable, and Reusable (FAIR). You will design and implement a formal data standard for an experiment's sample metadata using a JSON Schema. This task moves beyond the sequence data itself to the descriptive information that gives it context and value. By defining and enforcing rules for metadata records ([@problem_id:3291672]), you will learn how to programmatically guarantee data integrity and consistency, a vital skill for enabling large-scale data integration and ensuring the reproducibility of scientific findings.", "problem": "You are tasked with designing and programmatically enforcing a data standard for sample metadata in a single-cell ribonucleic acid sequencing (scRNA-seq; single-cell RNA sequencing) study. The goal is to translate first principles of data integrity and interoperability, such as Findable, Accessible, Interoperable, Reusable (FAIR), into a concrete validation scheme for tabular records represented in JavaScript Object Notation (JSON; JavaScript Object Notation). From the perspective of mathematical logic and set theory, a schema specifies admissible values by establishing type constraints, set membership (enumerations), and numeric order relations over specified domains.\n\nStarting from the following foundational bases:\n- Types as sets: a string field takes values from a set of all finite character sequences, an integer field takes values from the set of integers $\\mathbb{Z}$, and a numeric field takes values from the set of real numbers $\\mathbb{R}$.\n- Set membership constraints: enumeration constraints require $x \\in S$ where $S$ is an explicitly listed finite set.\n- Order constraints: numeric ranges are expressed as $a \\le x \\le b$ for lower bound $a$ and upper bound $b$ within $\\mathbb{R}$ or $\\mathbb{Z}$.\n\nPropose a JSON Schema that enforces the following properties over each record $r$:\n- Required fields and their types:\n  - $sample\\_id$: string.\n  - $species$: string, with enumeration $S\\_{\\text{species}} = \\{\\text{\"Homo sapiens\"}, \\text{\"Mus musculus\"}\\}$.\n  - $tissue$: string, with enumeration $S\\_{\\text{tissue}} = \\{\\text{\"lung\"}, \\text{\"liver\"}, \\text{\"kidney\"}\\}$.\n  - $platform$: string, with enumeration $S\\_{\\text{platform}} = \\{\\text{\"10x Genomics\"}, \\text{\"Smart-seq2\"}, \\text{\"Drop-seq\"}\\}$.\n  - $umi\\_count$: integer with range constraint $1 \\le umi\\_count \\le 10^6$.\n  - $mito\\_fraction$: number with range constraint $0 \\le mito\\_fraction \\le 1$, expressed as a decimal (do not use a percentage sign).\n  - $doublet\\_probability$: number with range constraint $0 \\le doublet\\_probability \\le 1$, expressed as a decimal (do not use a percentage sign).\n  - $age\\_years$: integer with range constraint $0 \\le age\\_years \\le 120$, expressed in years.\n  - $sex$: string, with enumeration $S\\_{\\text{sex}} = \\{\\text{\"male\"}, \\text{\"female\"}, \\text{\"unknown\"}\\}$.\n- Optional fields may be present but are not required. Any present field must comply with its declared type and any applicable constraints.\n- Additional properties not listed above may be present; they do not affect validation outcomes provided all required fields satisfy constraints.\n\nYour program must:\n1. Construct the above schema as an internal data object.\n2. Validate a test suite of five records against the schema, producing a boolean validity for each record, where $\\text{True}$ indicates the record conforms to the schema and $\\text{False}$ indicates a violation.\n3. Demonstrate detection of three specific malformed records:\n   - Missing required field.\n   - Enumeration violation (value not in the required set).\n   - Numeric range violation (value outside the required bounds).\n4. Use the following test suite with explicit values:\n   - Record A (happy path): $sample\\_id$ = \"SC0001\", $species$ = \"Homo sapiens\", $tissue$ = \"lung\", $platform$ = \"10x Genomics\", $umi\\_count$ = $50000$, $mito\\_fraction$ = $0.08$, $doublet\\_probability$ = $0.05$, $age\\_years$ = $34$, $sex$ = \"female\".\n   - Record B (boundary conditions): $sample\\_id$ = \"SC0002\", $species$ = \"Mus musculus\", $tissue$ = \"liver\", $platform$ = \"Smart-seq2\", $umi\\_count$ = $1$, $mito\\_fraction$ = $0.0$, $doublet\\_probability$ = $1.0$, $age\\_years$ = $0$, $sex$ = \"male\".\n   - Record C (missing required field): $sample\\_id$ = \"SC0003\", $tissue$ = \"kidney\", $platform$ = \"Drop-seq\", $umi\\_count$ = $20000$, $mito\\_fraction$ = $0.12$, $doublet\\_probability$ = $0.1$, $age\\_years$ = $12$, $sex$ = \"unknown\". The $species$ field is intentionally omitted.\n   - Record D (enumeration violation): $sample\\_id$ = \"SC0004\", $species$ = \"Drosophila melanogaster\", $tissue$ = \"lung\", $platform$ = \"10x Genomics\", $umi\\_count$ = $30000$, $mito\\_fraction$ = $0.07$, $doublet\\_probability$ = $0.02$, $age\\_years$ = $5$, $sex$ = \"female\".\n   - Record E (numeric range violation): $sample\\_id$ = \"SC0005\", $species$ = \"Homo sapiens\", $tissue$ = \"liver\", $platform$ = \"Smart-seq2\", $umi\\_count$ = $500000$, $mito\\_fraction$ = $1.2$, $doublet\\_probability$ = $0.03$, $age\\_years$ = $27$, $sex$ = \"male\".\n5. The final output format must be a single line containing the results as a comma-separated list enclosed in square brackets. For example, if your results for records A through E are $[v\\_A, v\\_B, v\\_C, v\\_D, v\\_E]$ with $v\\_i \\in \\{\\text{True}, \\text{False}\\}$, print exactly \"[True,False,True,False,True]\".\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5]\"). The answers for all test cases must be booleans.", "solution": "The solution is grounded in established principles of data integrity and formal semantics of schemas. We start from the view that a schema defines a subset of the Cartesian product of field domains, enforcing constraints by intersection with sets defined by type, enumeration, and interval bounds.\n\n1. Define types as sets. For each field $f$, assign a type $T\\_f$:\n   - For strings, $T\\_f$ is the set of finite character sequences.\n   - For integers, $T\\_f = \\mathbb{Z}$.\n   - For numbers, $T\\_f = \\mathbb{R}$.\n\n2. Define required fields. Let $R$ be the set of required field names. A record $r$ is admissible only if $\\forall f \\in R$, $f \\in \\text{dom}(r)$, where $\\text{dom}(r)$ is the set of keys present in $r$. This enforces presence.\n\n3. Enforce type constraints. For each present field $f$, check $r[f] \\in T\\_f$. In code, this is a runtime type test. For integer fields, we must ensure $r[f] \\in \\mathbb{Z}$ and exclude boolean values because in many programming languages booleans are a subtype of integers; thus we explicitly require $r[f]$ to be an integer and not a boolean.\n\n4. Enforce enumeration constraints. For fields with enumeration, let $S\\_f$ be the finite allowed set. Require $r[f] \\in S\\_f$. This implements the set membership predicate $x \\in S$.\n\n5. Enforce numeric ranges. For numeric fields with inclusive bounds, a value $x$ is valid if $a \\le x \\le b$ where $a$ and $b$ are the minimum and maximum respectively. Here:\n   - $1 \\le umi\\_count \\le 10^6$ for the unique molecular identifier count.\n   - $0 \\le mito\\_fraction \\le 1$ and $0 \\le doublet\\_probability \\le 1$ with values expressed as decimals.\n   - $0 \\le age\\_years \\le 120$.\n\n6. Compose the validator. The validator function iterates through required fields to check presence, then iterates over properties to:\n   - assert types,\n   - apply enumeration checks when defined,\n   - apply minimum and maximum checks when defined.\n   Any violation yields a boolean $\\text{False}$; otherwise return $\\text{True}$.\n\n7. Apply to the test suite:\n   - Record A satisfies all constraints: types match, all required fields present, enumerations valid, and numeric values inside ranges; therefore it is $\\text{True}$.\n   - Record B checks boundary inclusivity: $umi\\_count = 1$, $mito\\_fraction = 0.0$, $doublet\\_probability = 1.0$, $age\\_years = 0$ are all within inclusive bounds, and enumerations are valid; therefore it is $\\text{True}$.\n   - Record C omits $species$, a required field. By step $2$, $\\exists f \\in R$ such that $f \\notin \\text{dom}(r)$, thus it is $\\text{False}$.\n   - Record D sets $species$ to \"Drosophila melanogaster\" which violates $S\\_{\\text{species}}$. Since $r[\\text{species}] \\notin S\\_{\\text{species}}$, it is $\\text{False}$.\n   - Record E sets $mito\\_fraction = 1.2$ which violates $0 \\le mito\\_fraction \\le 1$. Because $1.2 \\notin [0,1]$, it is $\\text{False}$.\n\n8. Output aggregation. Collect the five booleans $[v\\_A, v\\_B, v\\_C, v\\_D, v\\_E]$ and print them as a single line in the required format. This satisfies the testability requirement and demonstrates schema-based validation detecting the three malformed records.\n\nThis approach directly implements the intersection of constraints from types, enumerations, and numeric intervals, aligning with the FAIR principles by making data interoperable through strict conformance to a shared schema.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n# We use only the Python standard library.\nfrom typing import Any, Dict, List\n\ndef is_integer(value: Any) -> bool:\n    # Exclude booleans (which are subclasses of int in Python)\n    return isinstance(value, int) and not isinstance(value, bool)\n\ndef is_number(value: Any) -> bool:\n    # Accept ints and floats, but exclude booleans\n    return (isinstance(value, int) and not isinstance(value, bool)) or isinstance(value, float)\n\ndef validate_record(record: Dict[str, Any], schema: Dict[str, Any]) -> bool:\n    # Check required fields presence\n    for req in schema.get(\"required\", []):\n        if req not in record:\n            return False\n\n    properties = schema.get(\"properties\", {})\n\n    # Validate each property that appears in the record and is defined in the schema\n    for key, prop in properties.items():\n        if key not in record:\n            # If not present, skip unless it's required (handled above)\n            continue\n        value = record[key]\n        # Type checks\n        expected_type = prop.get(\"type\")\n        if expected_type == \"string\":\n            if not isinstance(value, str):\n                return False\n        elif expected_type == \"integer\":\n            if not is_integer(value):\n                return False\n        elif expected_type == \"number\":\n            if not is_number(value):\n                return False\n        else:\n            # Unknown type in schema; for robustness, consider invalid\n            return False\n\n        # Enumeration check\n        enum_values = prop.get(\"enum\")\n        if enum_values is not None:\n            if value not in enum_values:\n                return False\n\n        # Range checks (minimum and maximum, inclusive)\n        if expected_type in (\"integer\", \"number\"):\n            if \"minimum\" in prop:\n                if value < prop[\"minimum\"]:\n                    return False\n            if \"maximum\" in prop:\n                if value > prop[\"maximum\"]:\n                    return False\n\n    # All checks passed\n    return True\n\ndef solve():\n    # Define the JSON Schema as a Python dictionary\n    schema = {\n        \"type\": \"object\",\n        \"required\": [\n            \"sample_id\",\n            \"species\",\n            \"tissue\",\n            \"platform\",\n            \"umi_count\",\n            \"mito_fraction\",\n            \"doublet_probability\",\n            \"age_years\",\n            \"sex\"\n        ],\n        \"properties\": {\n            \"sample_id\": {\"type\": \"string\"},\n            \"species\": {\n                \"type\": \"string\",\n                \"enum\": [\"Homo sapiens\", \"Mus musculus\"]\n            },\n            \"tissue\": {\n                \"type\": \"string\",\n                \"enum\": [\"lung\", \"liver\", \"kidney\"]\n            },\n            \"platform\": {\n                \"type\": \"string\",\n                \"enum\": [\"10x Genomics\", \"Smart-seq2\", \"Drop-seq\"]\n            },\n            \"umi_count\": {\n                \"type\": \"integer\",\n                \"minimum\": 1,\n                \"maximum\": 10**6\n            },\n            \"mito_fraction\": {\n                \"type\": \"number\",\n                \"minimum\": 0.0,\n                \"maximum\": 1.0\n            },\n            \"doublet_probability\": {\n                \"type\": \"number\",\n                \"minimum\": 0.0,\n                \"maximum\": 1.0\n            },\n            \"age_years\": {\n                \"type\": \"integer\",\n                \"minimum\": 0,\n                \"maximum\": 120\n            },\n            \"sex\": {\n                \"type\": \"string\",\n                \"enum\": [\"male\", \"female\", \"unknown\"]\n            },\n            # Optional fields example (not required)\n            \"library_prep\": {\n                \"type\": \"string\",\n                \"enum\": [\"polyA\", \"totalRNA\"]\n            },\n            \"batch_id\": {\"type\": \"string\"}\n        },\n        # Allow additional properties without affecting validation\n        \"additionalProperties\": True\n    }\n\n    # Define the test cases (records A-E)\n    test_cases: List[Dict[str, Any]] = [\n        # Record A (happy path)\n        {\n            \"sample_id\": \"SC0001\",\n            \"species\": \"Homo sapiens\",\n            \"tissue\": \"lung\",\n            \"platform\": \"10x Genomics\",\n            \"umi_count\": 50000,\n            \"mito_fraction\": 0.08,\n            \"doublet_probability\": 0.05,\n            \"age_years\": 34,\n            \"sex\": \"female\"\n        },\n        # Record B (boundary conditions)\n        {\n            \"sample_id\": \"SC0002\",\n            \"species\": \"Mus musculus\",\n            \"tissue\": \"liver\",\n            \"platform\": \"Smart-seq2\",\n            \"umi_count\": 1,\n            \"mito_fraction\": 0.0,\n            \"doublet_probability\": 1.0,\n            \"age_years\": 0,\n            \"sex\": \"male\"\n        },\n        # Record C (missing required field: species)\n        {\n            \"sample_id\": \"SC0003\",\n            \"tissue\": \"kidney\",\n            \"platform\": \"Drop-seq\",\n            \"umi_count\": 20000,\n            \"mito_fraction\": 0.12,\n            \"doublet_probability\": 0.1,\n            \"age_years\": 12,\n            \"sex\": \"unknown\"\n        },\n        # Record D (enumeration violation: species not allowed)\n        {\n            \"sample_id\": \"SC0004\",\n            \"species\": \"Drosophila melanogaster\",\n            \"tissue\": \"lung\",\n            \"platform\": \"10x Genomics\",\n            \"umi_count\": 30000,\n            \"mito_fraction\": 0.07,\n            \"doublet_probability\": 0.02,\n            \"age_years\": 5,\n            \"sex\": \"female\"\n        },\n        # Record E (numeric range violation: mito_fraction > 1)\n        {\n            \"sample_id\": \"SC0005\",\n            \"species\": \"Homo sapiens\",\n            \"tissue\": \"liver\",\n            \"platform\": \"Smart-seq2\",\n            \"umi_count\": 500000,\n            \"mito_fraction\": 1.2,\n            \"doublet_probability\": 0.03,\n            \"age_years\": 27,\n            \"sex\": \"male\"\n        },\n    ]\n\n    results = []\n    for rec in test_cases:\n        result = validate_record(rec, schema)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3291672"}]}