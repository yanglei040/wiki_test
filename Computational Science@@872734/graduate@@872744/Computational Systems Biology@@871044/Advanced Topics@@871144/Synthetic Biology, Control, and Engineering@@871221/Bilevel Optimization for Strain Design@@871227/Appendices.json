{"hands_on_practices": [{"introduction": "The most direct way to understand bilevel optimization for strain design is to build it. This first practice challenges you to implement the complete bilevel algorithm for a toy metabolic network by enumerating all possible engineering strategies [@problem_id:3290717]. You will model the upper-level engineer's choice of reaction knockouts and the lower-level cell's response, which is assumed to maximize its growth, providing hands-on experience with the core computational loop and the concept of a pessimistic 'worst-case' product yield, a crucial consideration when a cell has multiple ways to achieve optimal growth.", "problem": "You are given a toy case study in bilevel optimization for strain design framed in Flux Balance Analysis (FBA). The organism is represented by a minimal metabolic network with steady-state mass balance and irreversible reaction bounds. The bilevel design problem models an upper-level engineer choosing reaction knockouts to maximize worst-case product formation at the lower-level organism’s optimal growth. You must implement a complete, runnable program that evaluates the worst-case product formation under all allowable knockout sets and returns the best choice.\n\nFundamental base and assumptions:\n- Flux Balance Analysis (FBA) uses the steady-state approximation for intracellular metabolites, which yields linear equalities of the form $$S\\,\\mathbf{v}=\\mathbf{0},$$ where $S$ is the stoichiometric matrix and $\\mathbf{v}$ is the vector of reaction fluxes.\n- Reaction fluxes are bounded by irreversible constraints $\\ell_i \\le v_i \\le u_i$ for each reaction $i$.\n- The organism’s growth is modeled by a biomass reaction flux $v_2$, which the organism maximizes at steady-state.\n- The lower-level organism is assumed to potentially choose among multiple growth-optimal flux distributions; here, we evaluate the pessimistic case in which, among all flux vectors that achieve maximum growth, the organism chooses one that minimizes product secretion flux $v_3$. This corresponds to a lexicographic bilevel: first maximize $v_2$, then minimize $v_3$ subject to the same constraints and an equality enforcing $v_2=v_2^\\star$, where $v_2^\\star$ is the optimal growth obtained from the first step.\n\nNetwork definition:\n- Reactions indexed as $R_0, R_1, R_2, R_3, R_4$ with fluxes $v_0, v_1, v_2, v_3, v_4$ respectively:\n  - $R_0$: Glucose uptake $\\text{G}_{\\text{ext}} \\rightarrow \\text{G}$.\n  - $R_1$: Oxygen uptake $\\text{O}_{\\text{ext}} \\rightarrow \\text{O}$.\n  - $R_2$: Biomass growth $G + 2\\,O \\rightarrow \\text{Biomass}$.\n  - $R_3$: Product formation $G \\rightarrow \\text{P}_{\\text{ext}}$.\n  - $R_4$: Waste formation $G \\rightarrow \\text{W}_{\\text{ext}}$.\n- Internal steady-state mass balance equalities on intracellular glucose $G$ and oxygen $O$:\n  - $v_0 - v_2 - v_3 - v_4 = 0$,\n  - $v_1 - 2\\,v_2 = 0$.\n- Bounds:\n  - Fixed glucose uptake: $v_0 \\in [G_{\\mathrm{fixed}},\\,G_{\\mathrm{fixed}}]$, where $G_{\\mathrm{fixed}}$ is a specified nonnegative number.\n  - Oxygen uptake: $v_1 \\in [0,\\,O_{\\max}]$, where $O_{\\max}$ is a specified nonnegative number.\n  - Biomass growth minimum viability: $v_2 \\in [\\gamma,\\,U_2]$ with $\\gamma \\ge 0$ and $U_2$ a large upper bound (you may choose $U_2=100$).\n  - Product and waste fluxes: $v_3 \\in [0,\\,U_3]$, $v_4 \\in [0,\\,U_4]$ with large bounds (you may choose $U_3=U_4=100$).\n- Candidate knockouts are restricted to the set $\\{R_3, R_4\\}$. A knockout of reaction $R_i$ implements $v_i=0$ via bounds $[0,0]$.\n\nBilevel optimization definition:\n- Upper level chooses a knockout set $\\mathcal{K} \\subseteq \\{3,4\\}$ with $|\\mathcal{K}| \\le K$ to maximize the worst-case product flux at lower-level optimum growth:\n  1. Lower-level step $1$: maximize $v_2$ subject to mass balances and bounds with knockouts in $\\mathcal{K}$ applied.\n  2. Lower-level step $2$: among solutions that achieve the optimal growth $v_2^\\star$, minimize $v_3$ with the same constraints and with the additional equality $v_2=v_2^\\star$.\n- The upper-level objective is the minimal product flux $v_3^{\\min}(\\mathcal{K})$ returned by step $2$; the engineer selects $\\mathcal{K}$ that maximizes this value.\n\nBitmask encoding of knockout sets:\n- Reactions are indexed $0,1,2,3,4$ corresponding to $R_0,R_1,R_2,R_3,R_4$.\n- A knockout set $\\mathcal{K}$ is encoded as an integer bitmask $M$ where bit $i$ is $1$ if reaction $R_i$ is knocked out and $0$ otherwise. For example, knocking out only $R_4$ corresponds to $M=2^4=16$, knocking out only $R_3$ corresponds to $M=2^3=8$, and no knockouts corresponds to $M=0$.\n\nYour task:\n- Implement a program in the specified environment that:\n  - Enumerates all knockout sets $\\mathcal{K} \\subseteq \\{3,4\\}$ with $|\\mathcal{K}| \\le K$.\n  - For each $\\mathcal{K}$, solves the lower-level step $1$ (maximize $v_2$). If infeasible, discard $\\mathcal{K}$.\n  - For feasible $\\mathcal{K}$, solves the lower-level step $2$ (minimize $v_3$ with $v_2=v_2^\\star$). If infeasible, discard $\\mathcal{K}$.\n  - Selects $\\mathcal{K}$ that maximizes the worst-case product flux $v_3^{\\min}(\\mathcal{K})$. In case of ties, choose the smallest bitmask $M$.\n- For any test case where no knockout set yields feasibility in step $1$, return the sentinel pair `[-1,-1.0]`.\n\nTest suite:\n- You must implement the following test cases as a list, each defined by $[G_{\\mathrm{fixed}},\\,O_{\\max},\\,\\gamma,\\,K]$:\n  1. $[10,\\,6,\\,2.5,\\,1]$: happy path with oxygen limiting growth and one allowed knockout.\n  2. $[10,\\,6,\\,2.5,\\,0]$: boundary with no knockouts allowed.\n  3. $[5,\\,6,\\,2.0,\\,1]$: reduced glucose forcing less leftover carbon.\n  4. $[10,\\,6,\\,2.5,\\,2]$: up to two knockouts allowed; the set knocking out both product and waste may become infeasible.\n  5. $[10,\\,4,\\,2.5,\\,1]$: oxygen too low to meet minimum growth, making all sets infeasible.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results for the test suite as a comma-separated list enclosed in square brackets, where each element is a two-element list `[M, v_3]` for the selected knockout bitmask `M` and the corresponding worst-case product flux `v_3`, in the order of the test cases. For example, `[[M_1,v_{3,1}], [M_2,v_{3,2}], \\dots]`.\n- Express each `v_3` as a floating-point number. No physical units are required for this toy model.", "solution": "The problem presents a valid, well-posed bilevel optimization task for metabolic strain design. The objective is to determine an optimal set of reaction knockouts to maximize the worst-case formation of a target product. The problem is framed within Flux Balance Analysis (FBA), a standard constraint-based modeling approach in computational systems biology. The solution requires iteratively solving a series of Linear Programming (LP) problems.\n\nThe core of the problem consists of a two-level optimization structure:\n1.  An **upper level**, representing an engineer, chooses a knockout strategy $$\\mathcal{K}$$ from a set of allowed modifications.\n2.  A **lower level**, representing the cell's metabolism, optimizes its own objective (growth) given the genetic modifications imposed by the upper level.\n\nWe assume a pessimistic or worst-case scenario for the lower level: among all possible metabolic states (flux distributions) that achieve maximum growth, the cell will adopt one that minimizes the production of the desired compound.\n\nThe overall algorithm proceeds by enumerating all permissible knockout strategies, evaluating the outcome of each, and selecting the best one according to the engineer's objective.\n\n**Mathematical Formulation**\n\nThe metabolic network is described by a system of linear equations and inequalities. Let the vector of reaction fluxes be $$\\mathbf{v} = [v_0, v_1, v_2, v_3, v_4]^T$$.\n\nThe steady-state mass balance constraints are given as $$S\\mathbf{v}=\\mathbf{0}$$. For this specific network, the explicit equations are:\n$$v_0 - v_2 - v_3 - v_4 = 0$$\n$$v_1 - 2v_2 = 0$$\n\nThese two equations can be written in matrix form as $$A_{eq}\\mathbf{v}=\\mathbf{b}_{eq}$$, where:\n$$\nA_{eq} = \\begin{pmatrix}\n1 & 0 & -1 & -1 & -1 \\\\\n0 & 1 & -2 & 0 & 0\n\\end{pmatrix}\n, \\quad \\mathbf{b}_{eq} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}\n$$\n\nThe flux for each reaction $$i$$ is also constrained by lower and upper bounds, $$\\ell_i \\le v_i \\le u_i$$. For a given test case with parameters $$G_{\\mathrm{fixed}}$$, $$O_{\\max}$$, and $$\\gamma$$, the base bounds are:\n- $$v_0 \\in [G_{\\mathrm{fixed}}, G_{\\mathrm{fixed}}]$$\n- $$v_1 \\in [0, O_{\\max}]$$\n- $$v_2 \\in [\\gamma, 100]$$\n- $$v_3 \\in [0, 100]$$\n- $$v_4 \\in [0, 100]$$\n\nA reaction knockout of $$R_i$$ is implemented by setting its bounds to $$[0, 0]$$. The candidate reactions for knockout are $$R_3$$ and $$R_4$$.\n\n**Bilevel Optimization Algorithm**\n\nFor each test case, we must consider all valid knockout sets $$\\mathcal{K} \\subseteq \\{3, 4\\}$$ where the number of knockouts $$|\\mathcal{K}|$$ does not exceed the given limit $$K$$. Each set $$\\mathcal{K}$$ is encoded by an integer bitmask $$M$$. We evaluate each valid mask $$M$$.\n\nFor a given mask $$M$$:\n1.  **Lower-Level Step 1: Maximize Growth**\n    We first solve for the maximum possible biomass flux $$v_2$$. This is a Linear Programming (LP) problem:\n    $$\n    \\begin{align*}\n    v_2^\\star = \\max_{\\mathbf{v}} \\quad & v_2 \\\\\n    \\text{subject to} \\quad & A_{eq}\\mathbf{v} = \\mathbf{b}_{eq} \\\\\n    & \\ell_i(M) \\le v_i \\le u_i(M) \\quad \\text{for } i=0, \\dots, 4\n    \\end{align*}\n    $$\n    The bounds $$\\ell_i(M)$$ and $$u_i(M)$$ are the base bounds modified according to the knockouts in $$M$$. If this LP is infeasible (i.e., no flux vector can satisfy all constraints, such as the minimum growth requirement $$\\gamma$$), the knockout strategy $$M$$ is discarded.\n\n2.  **Lower-Level Step 2: Minimize Product Flux (Worst-Case)**\n    If Step 1 is feasible, we find the worst-case product flux by minimizing $$v_3$$ while constraining the growth rate to its maximum achievable value, $$v_2^\\star$$. This is a second LP problem:\n    $$\n    \\begin{align*}\n    v_3^{\\min}(M) = \\min_{\\mathbf{v}} \\quad & v_3 \\\\\n    \\text{subject to} \\quad & A_{eq}\\mathbf{v} = \\mathbf{b}_{eq} \\\\\n    & \\ell_i(M) \\le v_i \\le u_i(M) \\quad \\text{for } i=0, \\dots, 4 \\\\\n    & v_2 = v_2^\\star\n    \\end{align*}\n    $$\n    The value $$v_3^{\\min}(M)$$ is the guaranteed minimum product yield for the knockout strategy $$M$$.\n\n**Upper-Level Decision**\n\nAfter evaluating $$v_3^{\\min}(M)$$ for all feasible and permissible masks $$M$$, the upper-level problem is to select the mask $$M^\\star$$ that maximizes this value:\n$$ M^\\star = \\arg\\max_{M} \\{v_3^{\\min}(M)\\} $$\nIn case of a tie in $$v_3^{\\min}$$ values, the mask with the smallest integer value $$M$$ is chosen. If no knockout strategy results in a feasible model, the sentinel value $$[-1, -1.0]$$ is returned for that test case.\n\n**Implementation Details**\n\nThe described algorithm is implemented using Python with the `scipy.optimize.linprog` function, which solves standard-form LP problems.\n- Maximization of $$v_2$$ is achieved by minimizing $$-v_2$$, i.e., using an objective vector $$c = [0, 0, -1, 0, 0]^T$$.\n- The constraint $$v_2 = v_2^\\star$$ in the second LP is implemented by setting the bounds for the variable $$v_2$$ to `[v_2_star, v_2_star]`.\n- The program iterates through the provided test cases, applies the bilevel algorithm for each, and reports the optimal mask and corresponding worst-case product flux.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve_case(G_fixed, O_max, gamma, K):\n    \"\"\"\n    Solves the bilevel optimization problem for a single test case.\n    \n    Args:\n        G_fixed (float): The fixed glucose uptake rate.\n        O_max (float): The maximum oxygen uptake rate.\n        gamma (float): The minimum required biomass flux for viability.\n        K (int): The maximum number of allowed knockouts.\n\n    Returns:\n        list: A list containing the best knockout mask and the corresponding\n              worst-case product flux, e.g., [mask, v3_min].\n              Returns [-1, -1.0] if no feasible strategy is found.\n    \"\"\"\n    # Stoichiometric matrix for equality constraints v0-v2-v3-v4=0, v1-2v2=0\n    A_eq = np.array([\n        [1, 0, -1, -1, -1],  # Glucose balance\n        [0, 1, -2, 0, 0]     # Oxygen balance\n    ])\n    b_eq = np.array([0, 0])\n    \n    # Large upper bound for unconstrained fluxes\n    U_large = 100.0\n    \n    # Base bounds for the fluxes [v0, v1, v2, v3, v4]\n    base_bounds = [\n        (G_fixed, G_fixed),   # v0: Glucose uptake\n        (0, O_max),           # v1: Oxygen uptake\n        (gamma, U_large),     # v2: Biomass growth\n        (0, U_large),         # v3: Product formation\n        (0, U_large)          # v4: Waste formation\n    ]\n\n    # Define all possible knockout strategies (mask, number of knockouts)\n    # R3 knockout corresponds to bit 3 (2^3=8)\n    # R4 knockout corresponds to bit 4 (2^4=16)\n    knockout_options = [\n        (0, 0),    # No knockouts\n        (8, 1),    # Knockout R3\n        (16, 1),   # Knockout R4\n        (24, 2)    # Knockout R3 and R4\n    ]\n    \n    # Filter for strategies that are permissible under the K limit\n    masks_to_test = [m for m, k_count in knockout_options if k_count = K]\n    \n    best_mask = -1\n    best_v3_min = -1.0\n\n    for M in masks_to_test:\n        bounds = base_bounds.copy()\n        \n        # Apply knockouts by setting the bounds of the flux to [0, 0]\n        if M  8:  # Test bit 3 for R3 knockout\n            bounds[3] = (0, 0)\n        if M  16: # Test bit 4 for R4 knockout\n            bounds[4] = (0, 0)\n        \n        # --- Lower-Level Step 1: Maximize v2 ---\n        # Objective: max(v2) is equivalent to min(-v2)\n        c1 = np.array([0, 0, -1, 0, 0])\n        res1 = linprog(c=c1, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n        \n        if not res1.success:\n            continue  # This knockout strategy is infeasible.\n        \n        v2_star = -res1.fun\n\n        # --- Lower-Level Step 2: Minimize v3 at optimal growth ---\n        bounds_step2 = bounds.copy()\n        # Enforce v2 = v2_star by setting the bounds for v2\n        bounds_step2[2] = (v2_star, v2_star)\n        \n        # Objective: min(v3)\n        c2 = np.array([0, 0, 0, 1, 0])\n        res2 = linprog(c=c2, A_eq=A_eq, b_eq=b_eq, bounds=bounds_step2, method='highs')\n        \n        if not res2.success:\n            # This would be an unexpected failure, but we handle it defensively.\n            continue\n            \n        v3_min = res2.fun\n\n        # --- Upper-Level: Update best result ---\n        if best_mask == -1:\n            best_mask = M\n            best_v3_min = v3_min\n        else:\n            # Update if current v3_min is better, or if it's a tie and the mask is smaller\n            # Using a tolerance for robust float comparison\n            if v3_min > best_v3_min + 1e-9:\n                best_v3_min = v3_min\n                best_mask = M\n            elif abs(v3_min - best_v3_min)  1e-9 and M  best_mask:\n                best_mask = M\n    \n    return [best_mask, float(best_v3_min)]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # [G_fixed, O_max, gamma, K]\n        [10, 6, 2.5, 1],\n        [10, 6, 2.5, 0],\n        [5, 6, 2.0, 1],\n        [10, 6, 2.5, 2],\n        [10, 4, 2.5, 1],\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The default str() representation of a list includes a space, e.g., '[16, 7.0]',\n    # which is consistent with the problem's example format of `[M, v_3]`.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3290717"}, {"introduction": "A successful microbial strain must often perform reliably across a range of different conditions, such as variations in feedstock quality. This exercise extends the basic bilevel framework to tackle the challenge of robust design by considering multiple environmental scenarios simultaneously [@problem_id:3290694]. Your task is to find a single genetic design that maximizes the guaranteed, or 'worst-case', product flux across all scenarios, while ensuring the cell remains viable in each one. This practice introduces the 'max-min' optimization structure, a cornerstone of designing robust biological systems that can handle environmental uncertainty.", "problem": "Consider a multi-scenario bilevel strain design problem based on steady-state Flux Balance Analysis (FBA). The intracellular steady-state condition is represented by the linear constraint $S v^{(k)} = 0$ for each scenario index $k$, where $S \\in \\mathbb{R}^{m \\times n}$ is a stoichiometric matrix, $v^{(k)} \\in \\mathbb{R}^n$ is the reaction flux vector for scenario $k$, and bounds $l^{(k)} \\le v^{(k)} \\le u^{(k)}$ are imposed componentwise. The inner problem in each scenario $k$ selects a flux vector $v^{(k)}$ that maximizes a growth objective $c_{\\mu}^\\top v^{(k)}$, where $c_{\\mu} \\in \\mathbb{R}^n$. To make the product flux uniquely defined at optimal growth, a lexicographic criterion is used: first solve the growth maximization to obtain the optimal growth value $\\mu^{*(k)}$, then, among all flux vectors that achieve growth at least $\\mu^{*(k)}$, select the one that maximizes a product objective $c_{p}^\\top v^{(k)}$. The outer problem selects a single design $x$ from a finite catalog $\\mathcal{X}$ that modifies the bounds $(l^{(k)}, u^{(k)})$ in a design-dependent manner, with the goal of maximizing the worst-case product flux across all scenarios, while ensuring scenario-wise viability thresholds on the optimal growth values. Formally, for a given $x \\in \\mathcal{X}$ and scenario $k$, define the design-modified bounds as $l^{(k)}(x), u^{(k)}(x)$ and define the inner growth optimum as\n$$\n\\mu^{*(k)}(x) \\;=\\; \\max_{v \\in \\mathbb{R}^n} \\;\\; c_{\\mu}^\\top v \\quad \\text{subject to} \\quad S v = 0,\\;\\; l^{(k)}(x) \\le v \\le u^{(k)}(x).\n$$\nImpose a viability requirement $\\mu^{*(k)}(x) \\ge \\underline{\\mu}^{(k)}$ for each scenario $k$, where $\\underline{\\mu}^{(k)} \\in \\mathbb{R}_{\\ge 0}$ is given. Then define the product-yielding lexicographic step for each $k$ as\n$$\nv_{p}^{(k)}(x) \\;=\\; \\max_{v \\in \\mathbb{R}^n} \\;\\; c_{p}^\\top v \\quad \\text{subject to} \\quad S v = 0,\\;\\; l^{(k)}(x) \\le v \\le u^{(k)}(x),\\;\\; c_{\\mu}^\\top v \\ge \\mu^{*(k)}(x) - \\tau,\n$$\nwith a small tolerance $\\tau \\in \\mathbb{R}_{>0}$ to avoid numerical issues. The outer problem chooses $x \\in \\mathcal{X}$ to maximize the worst-case product,\n$$\n\\max_{x \\in \\mathcal{X}} \\;\\; \\min_{k} \\; v_{p}^{(k)}(x) \\qquad \\text{subject to} \\qquad \\mu^{*(k)}(x) \\ge \\underline{\\mu}^{(k)} \\;\\; \\text{for all}\\; k.\n$$\nYou must implement a program that, for the following test suite of three cases, computes the optimal outer objective value as a real number for each case and outputs the results as a single line.\n\nAll three cases use the same stoichiometric matrix $S \\in \\mathbb{R}^{2 \\times 5}$ with $n = 5$ reactions and $m = 2$ intracellular metabolites. The reactions are ordered as follows: $v_1$ is glucose uptake, $v_2$ is biomass formation (growth), $v_3$ is precursor formation, $v_4$ is product formation, and $v_5$ is a competing waste route. The metabolites are ordered as intracellular glucose and the intracellular precursor. The stoichiometric matrix $S$ is\n$$\nS \\;=\\; \\begin{bmatrix}\n1  -1  -1  0  -1\\\\\n0  0  1  -1  0\n\\end{bmatrix}.\n$$\nThe growth objective vector is $c_{\\mu} = \\begin{bmatrix}0  1  0  0  0\\end{bmatrix}^\\top$, and the product objective vector is $c_{p} = \\begin{bmatrix}0  0  0  1  0\\end{bmatrix}^\\top$. All lower bounds are $0$ unless otherwise modified by the design. Each scenario $k$ has its own upper bounds $u^{(k)}$ as specified below, with common lower bounds $l^{(k)} = \\begin{bmatrix}0  0  0  0  0\\end{bmatrix}^\\top$ before design modifications.\n\nA single design $x$ must be selected from the discrete set $\\mathcal{X} = \\{x^{(0)}, x^{(1)}, x^{(2)}, x^{(3)}\\}$. The design-dependent bound modifications are defined as follows. For any scenario $k$, let $u^{(k)}_{\\text{base}}$ denote the base upper bounds before design; then:\n1. Baseline design $x^{(0)}$ imposes no changes, that is, $u^{(k)}(x^{(0)}) = u^{(k)}_{\\text{base}}$ and $l^{(k)}(x^{(0)}) = l^{(k)}$.\n2. Waste knockout design $x^{(1)}$ eliminates the competing route by setting the upper bound of $v_5$ to $0$ in every scenario, that is, $u^{(k)}(x^{(1)})_5 = 0$ with all other components equal to $u^{(k)}_{\\text{base}}$.\n3. Growth cap design $x^{(2)}$ imposes an upper bound cap on $v_2$ of $4$, that is, $u^{(k)}(x^{(2)})_2 = \\min\\{u^{(k)}_{\\text{base},2}, 4\\}$ in every scenario, with all other components equal to $u^{(k)}_{\\text{base}}$.\n4. Product overexpression design $x^{(3)}$ increases the product capacity by a factor of $3$, that is, $u^{(k)}(x^{(3)})_4 = 3 \\, u^{(k)}_{\\text{base},4}$ in every scenario, with all other components equal to $u^{(k)}_{\\text{base}}$.\n\nIn all cases, use the lexicographic tolerance $\\tau = 10^{-9}$. Each case consists of three scenarios with specified base upper bounds $u^{(k)}_{\\text{base}}$ and viability thresholds $\\underline{\\mu}^{(k)}$ as follows.\n\nCase A:\nThe three scenarios have base upper bounds\n$$\nu^{(1)}_{\\text{base}} = \\begin{bmatrix}10  100  100  3  8\\end{bmatrix}^\\top,\\quad\nu^{(2)}_{\\text{base}} = \\begin{bmatrix}5  100  100  1.5  4\\end{bmatrix}^\\top,\\quad\nu^{(3)}_{\\text{base}} = \\begin{bmatrix}8  100  100  2  7\\end{bmatrix}^\\top.\n$$\nThe viability thresholds are\n$$\n\\underline{\\mu}^{(1)} = 0.5,\\quad \\underline{\\mu}^{(2)} = 0.2,\\quad \\underline{\\mu}^{(3)} = 0.2.\n$$\n\nCase B:\nThe base upper bounds are the same as in Case A. The viability thresholds are stricter,\n$$\n\\underline{\\mu}^{(1)} = 6,\\quad \\underline{\\mu}^{(2)} = 4.5,\\quad \\underline{\\mu}^{(3)} = 4.\n$$\n\nCase C:\nThe base upper bounds are the same as in Case A except that the third scenario has a tighter product capacity,\n$$\nu^{(3)}_{\\text{base}} = \\begin{bmatrix}8  100  100  0.5  7\\end{bmatrix}^\\top.\n$$\nThe viability thresholds are the same as in Case A,\n$$\n\\underline{\\mu}^{(1)} = 0.5,\\quad \\underline{\\mu}^{(2)} = 0.2,\\quad \\underline{\\mu}^{(3)} = 0.2.\n$$\n\nFor each case, the task is to compute the optimal outer objective value, namely the maximum over $x \\in \\mathcal{X}$ of the minimum across $k$ of the lexicographic product flux $v_{p}^{(k)}(x)$, subject to the viability constraints $\\mu^{*(k)}(x) \\ge \\underline{\\mu}^{(k)}$ for all scenarios $k$. Your program must solve the inner problems as described and enumerate the finite design set to determine the best $x$ for each case.\n\nAngle units are not used. There are no physical units in the numerical output. The required final output format is a single line containing a Python-style list of three floating-point numbers, one per case in the order A, B, C. Each number must be rounded to exactly six decimal places. For example, the format must be like `[a,b,c]` where $a$, $b$, and $c$ are floats with six digits after the decimal point and no spaces after commas, such as `[1.234000,0.000100,5.600000]`.", "solution": "The problem statement describes a multi-scenario bilevel optimization problem for metabolic strain design. The task is to identify an optimal design strategy from a finite catalog that maximizes the worst-case product yield across several environmental scenarios, subject to viability constraints on cellular growth. The problem is well-posed, scientifically grounded in the principles of Flux Balance Analysis (FBA), and provides all necessary data for a unique solution. We can therefore proceed with a full solution.\n\nThe overall problem can be formulated as:\n$$\n\\max_{x \\in \\mathcal{X}} \\left( \\min_{k} v_{p}^{(k)}(x) \\right)\n$$\nsubject to the viability constraint that for each scenario $k$, the maximal growth rate $\\mu^{*(k)}(x)$ must satisfy $\\mu^{*(k)}(x) \\ge \\underline{\\mu}^{(k)}$. A design $x$ that fails this condition for any scenario $k$ is considered non-viable and is excluded from the set of candidate solutions for the outer maximization problem.\n\nThe core of the problem lies in solving the inner lexicographic optimization for each design $x \\in \\mathcal{X}$ and scenario $k$. This involves two sequential Linear Programs (LPs).\n\n**Step 1: Analytical Simplification of the Metabolic Model**\n\nFirst, we analyze the steady-state mass balance constraint $S v = 0$, where $v = [v_1, v_2, v_3, v_4, v_5]^\\top$. The stoichiometric matrix is given as:\n$$\nS = \\begin{bmatrix}\n1  -1  -1  0  -1 \\\\\n0  0  1  -1  0\n\\end{bmatrix}\n$$\nThis matrix equation corresponds to two linear equations:\n1. $v_1 - v_2 - v_3 - v_5 = 0$\n2. $v_3 - v_4 = 0$\n\nFrom the second equation, we directly obtain $v_3 = v_4$. Substituting this into the first equation yields $v_1 = v_2 + v_4 + v_5$.\nThese two relations show that the $5$-dimensional flux vector $v$ is determined by three independent fluxes. We can choose the growth flux $v_2$, the product flux $v_4$, and the waste flux $v_5$ as our independent variables. The remaining fluxes, precursor formation $v_3$ and glucose uptake $v_1$, are dependent.\n\nThe full set of constraints for the LPs can be reformulated in terms of these independent fluxes. For any given design $x$ and scenario $k$, let the bounds be $l^{(k)}(x) \\le v \\le u^{(k)}(x)$. Given that all base lower bounds are $l_i = 0$, we have $v_i \\ge 0$ for all reactions $i \\in \\{1, \\dots, 5\\}$. The upper bounds $u_i$ on the dependent fluxes impose constraints on the independent ones:\n- $v_1 \\le u_1 \\implies v_2 + v_4 + v_5 \\le u_1$\n- $v_3 \\le u_3 \\implies v_4 \\le u_3$\n\nCombining these with the direct bounds on the independent fluxes, the feasible space for $(v_2, v_4, v_5)$ is defined by:\n- $v_2 + v_4 + v_5 \\le u_1$\n- $0 \\le v_2 \\le u_2$\n- $0 \\le v_4 \\le \\min(u_3, u_4)$\n- $0 \\le v_5 \\le u_5$\n\n**Step 2: Solving the Inner Optimization Problems**\n\nWith the simplified constraints, we can find analytical solutions for the two inner LPs. For a given design $x$ and scenario $k$, the bounds $(u_1, u_2, u_3, u_4, u_5)$ are fixed.\n\n**LP 1: Growth Maximization**\nThe first objective is to maximize the growth flux, $c_\\mu^\\top v = v_2$.\n$$\n\\mu^{*(k)}(x) = \\max_{v_2, v_4, v_5} v_2\n$$\nsubject to the simplified constraints. To maximize $v_2$, we must choose the smallest possible non-negative values for $v_4$ and $v_5$ in the constraint $v_2 + v_4 + v_5 \\le u_1$. The minimum values are $v_4=0$ and $v_5=0$. This reduces the constraints on $v_2$ to $v_2 \\le u_1$ and $v_2 \\le u_2$. Therefore, the optimal growth rate is:\n$$\n\\mu^{*(k)}(x) = \\min(u_1, u_2)\n$$\n\n**LP 2: Product Maximization (Lexicographic Step)**\nThe second objective is to maximize the product flux, $c_p^\\top v = v_4$, subject to achieving a growth rate of at least $\\mu^{*(k)}(x) - \\tau$.\n$$\nv_p^{(k)}(x) \\text{ value} = \\max_{v_2, v_4, v_5} v_4\n$$\nsubject to the simplified constraints and the additional lexicographic constraint:\n$$\nv_2 \\ge \\mu^{*(k)}(x) - \\tau\n$$\nTo maximize $v_4$, we must choose the smallest possible values for $v_2$ and $v_5$ in the constraint $v_2 + v_4 + v_5 \\le u_1$. The minimum allowed value for $v_2$ is $\\mu^{*(k)}(x) - \\tau$. The minimum value for $v_5$ is $0$. Substituting these into the inequality gives:\n$$\n(\\mu^{*(k)}(x) - \\tau) + v_4 + 0 \\le u_1 \\implies v_4 \\le u_1 - \\mu^{*(k)}(x) + \\tau\n$$\nThe final maximal product flux is also limited by its own capacity, $v_4 \\le \\min(u_3, u_4)$. Thus, the solution is:\n$$\nv_p^{(k)}(x) \\text{ value} = \\min(\\min(u_3, u_4), u_1 - \\mu^{*(k)}(x) + \\tau)\n$$\nSubstituting the expression for $\\mu^{*(k)}(x) = \\min(u_1, u_2)$:\n$$\nv_p^{(k)}(x) \\text{ value} = \\min(\\min(u_3, u_4), u_1 - \\min(u_1, u_2) + \\tau)\n$$\n\n**Step 3: Algorithmic Evaluation of Designs**\n\nWith these analytical solutions, we can implement the full procedure by iterating through the finite set of designs for each case. For each case (A, B, C):\n1. Initialize the maximum worst-case product, $P_{\\text{opt}}$, to a very small number (e.g., $-\\infty$).\n2. For each design $x \\in \\{x^{(0)}, x^{(1)}, x^{(2)}, x^{(3)}\\}$:\n   a. Initialize a flag, `is_viable`, to `true` and a list, `product_fluxes`, to store results for the scenarios.\n   b. For each scenario $k \\in \\{1, 2, 3\\}$:\n      i. Determine the upper bounds $u^{(k)}(x)$ by applying the modification rule for design $x$ to the base upper bounds $u^{(k)}_{\\text{base}}$.\n      ii. Calculate the maximal growth rate $\\mu^{*(k)}(x) = \\min(u_1, u_2)$.\n      iii. Check for viability: If $\\mu^{*(k)}(x)  \\underline{\\mu}^{(k)}$, set `is_viable` to `false` and break from the scenario loop, as this design is invalid.\n      iv. If viable, calculate the maximal product flux $v_p^{(k)}(x)$ using the derived formula. Append this value to `product_fluxes`.\n   c. If `is_viable` remains `true` after checking all scenarios:\n      i. Find the worst-case (minimum) product flux for this design: $P_{\\text{worst}}(x) = \\min(\\text{product\\_fluxes})$.\n      ii. Update the overall optimum: $P_{\\text{opt}} = \\max(P_{\\text{opt}}, P_{\\text{worst}}(x))$.\n3. The final value $P_{\\text{opt}}$ is the answer for the case. If no design is viable, the maximum is taken over an empty set, conventionally $-\\infty$. In this problem, at least one design proves viable for each case.\n\nBy applying this algorithm to the data supplied for Cases A, B, and C, we can compute the required optimal objective values. For example, in Case A with design $x^{(2)}$, the growth is capped at $u_2=4$. For scenario $1$, the new bounds are $[10, 4, 100, 3, 8]^\\top$. The growth is $\\mu^* = \\min(10, 4) = 4$, which exceeds the threshold $\\underline{\\mu}^{(1)}=0.5$. The product flux is $\\min(\\min(100, 3), 10 - 4 + \\tau) = \\min(3, 6+\\tau) = 3$. This process is repeated for all designs and scenarios to find the final optimum. For Case B, the stricter viability thresholds $\\underline{\\mu}^{(k)}$ render design $x^{(2)}$ non-viable because its capped growth of $4$ is less than $\\underline{\\mu}^{(1)}=6$ and $\\underline{\\mu}^{(2)}=4.5$. The final optimal values are derived from the best-performing viable design for each case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the multi-scenario bilevel strain design problem for three given cases.\n    \"\"\"\n    \n    # Global parameters from the problem statement\n    tau = 1e-9\n    designs = ['baseline', 'waste_ko', 'growth_cap', 'product_over']\n\n    def solve_case(base_upper_bounds, viability_thresholds):\n        \"\"\"\n        Calculates the optimal outer objective value for a single case.\n\n        This involves iterating through all possible designs, checking their viability\n        across all scenarios, and finding the design that maximizes the worst-case\n        product flux.\n        \"\"\"\n        max_worst_case_product = -np.inf\n\n        for design in designs:\n            scenario_product_fluxes = []\n            design_is_viable = True\n\n            for k in range(3):  # Iterate through the three scenarios\n                u_base = base_upper_bounds[k]\n                u_mod = u_base.copy()\n\n                # Apply design modifications to the base upper bounds\n                if design == 'waste_ko':\n                    # Design x^(1): Waste knockout\n                    u_mod[4] = 0.0\n                elif design == 'growth_cap':\n                    # Design x^(2): Growth cap\n                    u_mod[1] = min(u_base[1], 4.0)\n                elif design == 'product_over':\n                    # Design x^(3): Product overexpression\n                    u_mod[3] = 3.0 * u_base[3]\n\n                u1, u2, u3, u4, u5 = u_mod\n\n                # Analytically solve the inner optimization problems\n                \n                # LP1: Maximize growth (v_2)\n                # mu_star = min(u_1, u_2)\n                mu_star = min(u1, u2)\n\n                # Check viability constraint for the current scenario\n                if mu_star  viability_thresholds[k]:\n                    design_is_viable = False\n                    break  # This design is not viable, no need to check other scenarios\n\n                # LP2: Maximize product (v_4) subject to near-optimal growth\n                # vp = min(min(u_3, u_4), u_1 - min(u_1, u_2) + tau)\n                u4_prime = min(u3, u4)\n                if u1 = u2:\n                    # In this case, u_1 - min(u_1, u_2) = u_1 - u_1 = 0\n                    vp = min(u4_prime, tau)\n                else: # u1 > u2\n                    # In this case, u_1 - min(u_1, u_2) = u_1 - u_2\n                    vp = min(u4_prime, u1 - u2 + tau)\n                \n                scenario_product_fluxes.append(vp)\n            \n            # If the design was viable across all scenarios, evaluate its performance\n            if design_is_viable:\n                worst_case_product = min(scenario_product_fluxes)\n                if worst_case_product > max_worst_case_product:\n                    max_worst_case_product = worst_case_product\n\n        # If no design was viable, the result is -inf.\n        # The problem setup ensures at least one design is viable.\n        if max_worst_case_product == -np.inf:\n            return 0.0\n        \n        return max_worst_case_product\n\n    # Define the test cases from the problem statement.\n    case_A_ubs = [\n        np.array([10., 100., 100., 3., 8.]),\n        np.array([5., 100., 100., 1.5, 4.]),\n        np.array([8., 100., 100., 2., 7.])\n    ]\n    case_A_mus = [0.5, 0.2, 0.2]\n\n    # Case B uses the same bounds as Case A but with stricter viability thresholds.\n    case_B_ubs = case_A_ubs\n    case_B_mus = [6.0, 4.5, 4.0]\n\n    # Case C modifies the bounds of the third scenario from Case A.\n    case_C_ubs = [\n        np.array([10., 100., 100., 3., 8.]),\n        np.array([5., 100., 100., 1.5, 4.]),\n        np.array([8., 100., 100., 0.5, 7.])\n    ]\n    case_C_mus = case_A_mus\n\n    test_cases = [\n        (case_A_ubs, case_A_mus),\n        (case_B_ubs, case_B_mus),\n        (case_C_ubs, case_C_mus),\n    ]\n\n    results = []\n    for ubs, mus in test_cases:\n        result = solve_case(ubs, mus)\n        results.append(result)\n\n    # Format the final output string as specified.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3290694"}, {"introduction": "Real-world biological processes are inherently noisy, with parameters like enzymatic efficiency and product yields exhibiting stochastic behavior. This final practice moves beyond discrete scenarios to address design under true uncertainty, where the goal is to manage the risk of poor performance [@problem_id:3290710]. You will evaluate designs not just on their worst-case performance, but using a sophisticated risk measure, Conditional Value at Risk ($CVaR_{\\alpha}$), to constrain the average performance in the tail-end of the outcome distribution. This exercise bridges metabolic engineering with modern risk management, enabling the selection of designs that are robust in a probabilistic sense.", "problem": "You are given a minimal linear steady-state metabolic model used in Flux Balance Analysis (FBA) to study strain design in the presence of uncertainty in product yields. The model has flux variables $v_g$ (biomass growth), $v_p$ (product secretion), $v_o$ (overflow byproduct), and $v_u$ (substrate uptake). For each uncertainty scenario $s \\in \\{1,\\dots,N\\}$, the scenario-dependent stoichiometric conversion costs are $c_g^{(s)} = 1 / y_g^{(s)}$ and $c_p^{(s)} = 1 / y_p^{(s)}$, where $y_g^{(s)}$ and $y_p^{(s)}$ are the biomass and product yields, respectively. The overflow cost $c_o$ is scenario-independent. Redox balancing requires that the consumption of cellular reducing equivalents by growth, product, and overflow equals the generation from substrate uptake. The inner (cell) optimization problem is to maximize growth:\n \nGiven a design choice $x = (x_p, x_o) \\in \\{0,1\\}^2$ that toggles the availability of the product pathway ($x_p$) and the overflow pathway ($x_o$), the inner problem for scenario $s$ is the linear program:\n \nMaximize $v_g$ subject to\n- Substrate balance: $v_u - c_g^{(s)} v_g - c_p^{(s)} v_p - c_o v_o = 0$,\n- Redox balance: $r_g v_g + r_p v_p + r_o v_o - r_u v_u = 0$,\n- Bounds: $0 \\le v_g \\le G_{\\max}$, $0 \\le v_p \\le P_{\\max} x_p$, $0 \\le v_o \\le O_{\\max} x_o$, $0 \\le v_u \\le U$,\n \nwhere $U$, $G_{\\max}$, $P_{\\max}$, $O_{\\max}$, $r_u$, $r_g$, $r_p$, $r_o$, and $c_o$ are fixed nonnegative parameters, and $y_g^{(s)}$, $y_p^{(s)}$ are given and strictly positive. For a given $x$, define $v_g^{\\star (s)}(x)$ as the optimal growth for scenario $s$. The worst-case product flux among growth-optimal solutions is defined by solving a second linear program that minimizes $v_p$ subject to the same constraints plus $v_g = v_g^{\\star (s)}(x)$. Denote this worst-case product flux by $z^{(s)}(x)$.\n \nThe outer (engineer) problem chooses $x$ to satisfy a tail-risk constraint on $v_p$ under uncertainty across the $N$ scenarios. Specifically, for a chosen confidence level $\\alpha \\in [0,1)$ and threshold $\\tau \\ge 0$, enforce the lower-tail Conditional Value at Risk (CVaR) constraint\n$$\n\\mathrm{CVaR}_{\\alpha}\\big( \\{ z^{(s)}(x) \\}_{s=1}^N \\big) \\ge \\tau,\n$$\nand simultaneously ensure viability, i.e., $\\min_s v_g^{\\star (s)}(x) \\ge \\varepsilon$ for a small tolerance $\\varepsilon > 0$. The design cost is the number of knockouts, $\\mathrm{cost}(x) = (1 - x_p) + (1 - x_o)$. Among all $x$ that satisfy the CVaR and viability constraints, choose one with minimum $\\mathrm{cost}(x)$. If multiple designs tie, use the deterministic tie-breaking order that prefers larger $x_p + x_o$, then larger $x_p$, then larger $x_o$.\n \nYou will implement a program that, for each test case, enumerates all four designs $x \\in \\{0,1\\}^2$, computes $z^{(s)}(x)$ across scenarios by solving the inner growth-maximization and worst-case product-minimization linear programs, evaluates $\\mathrm{CVaR}_{\\alpha}$, checks feasibility of the CVaR and viability constraints, and selects the design according to the rule above. If no design satisfies the constraints, return $-1$. Otherwise, return an integer code that encodes the chosen design $x = (x_p, x_o)$ as $\\mathrm{code}(x) = 2 x_o + x_p$; thus, the mapping is: $(x_p,x_o) = (0,0) \\mapsto 0$, $(1,0) \\mapsto 1$, $(0,1) \\mapsto 2$, $(1,1) \\mapsto 3$.\n \nUse only the following fixed model parameters for all test cases: $U = 10$, $G_{\\max} = 10^6$, $P_{\\max} = 10^6$, $O_{\\max} = 10^6$ unless otherwise specified in the test case, $r_u = 1$, $r_g = 0.5$, $r_p = 3$, $r_o = 3$, $c_o = 1$, and $\\varepsilon = 10^{-6}$.\n \nConditional Value at Risk (CVaR) definition to be used: For empirical samples $z^{(1)},\\dots,z^{(N)}$, the lower-tail $\\mathrm{CVaR}_{\\alpha}$ is the optimal value of\n$$\n\\max_{\\eta \\in \\mathbb{R}} \\ \\eta - \\frac{1}{(1-\\alpha) N} \\sum_{s=1}^{N} \\max\\{ \\eta - z^{(s)}, 0 \\}.\n$$\nThis definition must be used to evaluate the CVaR, not an approximation.\n \nTest suite (each case is independent):\n- Case $1$: $N = 5$ scenarios with yields $y_g = [0.50, 0.60, 0.55, 0.65, 0.52]$, $y_p = [0.50, 0.45, 0.60, 0.70, 0.48]$, $\\alpha = 0.80$, $\\tau = 2.60$.\n- Case $2$: Same yields as Case $1$, $\\alpha = 0.00$, $\\tau = 2.90$.\n- Case $3$: Same yields as Case $1$, $\\alpha = 0.95$, $\\tau = 2.90$.\n- Case $4$: Same yields as Case $1$, $\\alpha = 0.50$, $\\tau = 0.00$.\n \nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., `[result1,result2,result3,result4]`), where each result is the integer design code for the corresponding test case as defined above (or $-1$ if infeasible).", "solution": "The user has provided a well-defined computational problem in the domain of metabolic engineering and systems biology. The problem requires the implementation of a bilevel optimization framework to determine an optimal strain design under uncertainty. The problem statement is validated as follows:\n\n### Step 1: Extract Givens\n- **Model:** A linear steady-state metabolic model with four flux variables: $v_g$ (biomass growth), $v_p$ (product secretion), $v_o$ (overflow byproduct), and $v_u$ (substrate uptake).\n- **Design Variables:** $x = (x_p, x_o) \\in \\{0, 1\\}^2$ toggles product and overflow pathways.\n- **Scenarios:** $N$ uncertainty scenarios, indexed by $s \\in \\{1,\\dots,N\\}$.\n- **Scenario-dependent Parameters:** Biomass yield $y_g^{(s)}$ and product yield $y_p^{(s)}$, defining costs $c_g^{(s)} = 1/y_g^{(s)}$ and $c_p^{(s)} = 1/y_p^{(s)}$.\n- **Inner Problem (Cellular Objective):** A two-stage linear program for each scenario $s$ and design $x$.\n    1.  **Maximize Growth:** Maximize $v_g$ subject to a set of linear equality and inequality constraints (substrate balance, redox balance, and flux bounds). The optimal growth is denoted $v_g^{\\star(s)}(x)$.\n    2.  **Minimize Product Flux:** Minimize $v_p$ subject to the same constraints plus the additional constraint $v_g = v_g^{\\star(s)}(x)$. The optimal product flux is denoted $z^{(s)}(x)$.\n- **Constraints on Fluxes:**\n    - Substrate balance: $v_u - c_g^{(s)} v_g - c_p^{(s)} v_p - c_o v_o = 0$.\n    - Redox balance: $r_g v_g + r_p v_p + r_o v_o - r_u v_u = 0$.\n    - Bounds: $0 \\le v_g \\le G_{\\max}$, $0 \\le v_p \\le P_{\\max} x_p$, $0 \\le v_o \\le O_{\\max} x_o$, $0 \\le v_u \\le U$.\n- **Outer Problem (Engineering Objective):**\n    - **Identify feasible designs:** A design $x$ is feasible if it satisfies two conditions:\n        1.  **Viability:** $\\min_{s} v_g^{\\star(s)}(x) \\ge \\varepsilon$.\n        2.  **CVaR Constraint:** $\\mathrm{CVaR}_{\\alpha}\\big(\\{z^{(s)}(x)\\}_{s=1}^N\\big) \\ge \\tau$.\n    - **Select optimal design:** Among all feasible designs, select the one that minimizes the cost function $\\mathrm{cost}(x) = (1 - x_p) + (1 - x_o)$.\n    - **Tie-breaking:** If costs are tied, prefer larger $x_p + x_o$, then larger $x_p$, then larger $x_o$.\n    - **Output:** If no design is feasible, return $-1$. Otherwise, return an integer code for the optimal design: $\\mathrm{code}(x) = 2x_o + x_p$.\n- **CVaR Definition:** The lower-tail Conditional Value at Risk at confidence level $\\alpha$ for samples $\\{z^{(s)}\\}$ is defined as the optimal value of the problem:\n    $$ \\max_{\\eta \\in \\mathbb{R}} \\ \\eta - \\frac{1}{(1-\\alpha) N} \\sum_{s=1}^{N} \\max\\{ \\eta - z^{(s)}, 0 \\} $$\n- **Fixed Parameters:** $U=10$, $G_{\\max}=10^6$, $P_{\\max}=10^6$, $O_{\\max}=10^6$, $r_u=1$, $r_g=0.5$, $r_p=3$, $r_o=3$, $c_o=1$, $\\varepsilon=10^{-6}$.\n- **Test Cases:** Four cases are provided, each specifying $N$, lists of yields $y_g$ and $y_p$, and parameters $\\alpha$ and $\\tau$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is evaluated against the validation criteria:\n- **Scientifically Grounded:** The problem uses established concepts from Flux Balance Analysis (FBA) and bilevel optimization (like OptKnock), which are standard in computational systems biology. The use of Conditional Value at Risk (CVaR) for decision-making under uncertainty is a standard technique from operations research and finance, and its application here is scientifically valid.\n- **Well-Posed:** The inner problems are Linear Programs (LPs) over compact feasible sets, so optimal solutions $v_g^{\\star(s)}(x)$ and $z^{(s)}(x)$ are guaranteed to exist. The outer problem is a search over a finite set of four designs, with clear feasibility criteria and a deterministic, unambiguous rule for selecting the optimal design. The provided CVaR definition corresponds to maximizing a concave, piecewise-linear function, which has a well-defined maximum.\n- **Objective:** The problem is specified with mathematical precision, using standard notation and providing all necessary parameters. There are no subjective or ambiguous statements.\n- **No Flaws:** The problem does not violate scientific principles, is formally specified, is self-contained, and poses a non-trivial but solvable computational challenge.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. A solution will be developed by implementing the procedure described in the problem statement.\n\n### Solution Plan\nThe solution will be implemented by systematically evaluating each of the four possible designs, $x \\in \\{(0,0), (1,0), (0,1), (1,1)\\}$. For each design, we will simulate its performance across all $N$ scenarios.\n\n**1. Inner Problem Simulation:** For each design $x$ and scenario $s$, we must find $v_g^{\\star(s)}(x)$ and $z^{(s)}(x)$. This requires solving two sequential LPs.\n    - **LP for $v_g^{\\star(s)}(x)$:** We maximize $v_g$ subject to the model's mass balance, redox balance, and flux bounds. The variables are the four fluxes $(v_g, v_p, v_o, v_u)$. This LP can be solved using `scipy.optimize.linprog`.\n    - **LP for $z^{(s)}(x)$:** We minimize $v_p$ subject to the same constraints as the first LP, plus the new constraint $v_g = v_g^{\\star(s)}(x)$, where $v_g^{\\star(s)}(x)$ is the optimal value from the first LP. This is also solved using `scipy.optimize.linprog`.\n\n**2. Feasibility Evaluation:** After computing $\\{v_g^{\\star(s)}(x)\\}_{s=1}^N$ and $\\{z^{(s)}(x)\\}_{s=1}^N$ for a design $x$, we check its feasibility.\n    - **Viability Check:** We verify if the minimum growth rate across all scenarios is above the threshold $\\varepsilon$: $\\min_s v_g^{\\star(s)}(x) \\ge \\varepsilon$.\n    - **CVaR Calculation  Check:** We compute $\\mathrm{CVaR}_{\\alpha}$ using the provided formula. The expression to be maximized is a concave, piecewise-linear function of $\\eta$. The maximum value must be attained at one of the sample points $\\eta = z^{(k)}$ for some $k \\in \\{1,\\dots,N\\}$. Thus, we can find the CVaR by evaluating the objective function for each unique $z^{(s)}(x)$ value and taking the maximum. We then check if this value is greater than or equal to the threshold $\\tau$.\n\n**3. Optimal Design Selection:** We collect all designs that are found to be feasible.\n    - If no designs are feasible, the result is $-1$.\n    - If one or more designs are feasible, we select the one with the minimum cost, where $\\mathrm{cost}(x) = (1-x_p)+(1-x_o)$. The costs are $0$ for $(1,1)$, $1$ for $(1,0)$ and $(0,1)$, and $2$ for $(0,0)$.\n    - The tie-breaking rules (prefer larger $x_p+x_o$, then larger $x_p$) uniquely resolve the tie between $(1,0)$ and $(0,1)$ in favor of $(1,0)$. This establishes a strict preference order for feasible designs: $(1,1)$ is best, then $(1,0)$, then $(0,1)$, and finally $(0,0)$.\n    - The chosen design is then converted to its integer code $\\mathrm{code}(x) = 2x_o + x_p$.\n\nThis structured approach will be implemented for each test case to produce the final results.", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Main function to solve all test cases for the bilevel optimization problem.\n    \"\"\"\n    \n    # -- Fixed Model Parameters --\n    U = 10.0\n    G_MAX = 1.0e6\n    P_MAX = 1.0e6\n    O_MAX = 1.0e6\n    R_U = 1.0\n    R_G = 0.5\n    R_P = 3.0\n    R_O = 3.0\n    C_O = 1.0\n    EPSILON = 1.0e-6\n\n    # -- Design space and preference order from cost/tie-breaking --\n    # Preferred order: (1,1), (1,0), (0,1), (0,0)\n    DESIGNS = [(1, 1), (1, 0), (0, 1), (0, 0)]\n\n    def solve_fluxes_for_scenario(x_p, x_o, y_g_s, y_p_s):\n        \"\"\"\n        Solves the inner bilevel LP for a given design and scenario.\n        Returns (v_g_star, z_s), the optimal growth and worst-case product flux.\n        \"\"\"\n        c_g_s = 1.0 / y_g_s\n        c_p_s = 1.0 / y_p_s\n\n        # Variables: [v_g, v_p, v_o, v_u]\n        \n        # -- Stage 1: Maximize growth (v_g) --\n        # Objective: min -v_g\n        c1 = np.array([-1.0, 0.0, 0.0, 0.0])\n        \n        # Equality constraints:\n        # v_u - c_g*v_g - c_p*v_p - c_o*v_o = 0\n        # r_u*v_u - r_g*v_g - r_p*v_p - r_o*v_o = 0\n        A_eq = np.array([\n            [-c_g_s, -c_p_s, -C_O, 1.0],\n            [-R_G, -R_P, -R_O, R_U]\n        ])\n        b_eq = np.array([0.0, 0.0])\n\n        # Bounds:\n        bounds1 = [\n            (0.0, G_MAX),\n            (0.0, P_MAX * x_p),\n            (0.0, O_MAX * x_o),\n            (0.0, U)\n        ]\n        \n        # Use 'highs' for robustness and performance\n        res1 = linprog(c=c1, A_eq=A_eq, b_eq=b_eq, bounds=bounds1, method='highs')\n\n        if not res1.success:\n            return (0.0, 0.0)\n\n        v_g_star = -res1.fun if res1.fun is not None else 0.0\n        v_g_star = max(0.0, v_g_star) # Ensure non-negative from solver quirks\n\n        # -- Stage 2: Minimize product flux (v_p) given v_g = v_g_star --\n        # Objective: min v_p\n        c2 = np.array([0.0, 1.0, 0.0, 0.0])\n        \n        # Fix v_g to v_g_star via bounds\n        bounds2 = [\n            (v_g_star, v_g_star),\n            (0.0, P_MAX * x_p),\n            (0.0, O_MAX * x_o),\n            (0.0, U)\n        ]\n\n        res2 = linprog(c=c2, A_eq=A_eq, b_eq=b_eq, bounds=bounds2, method='highs')\n        \n        if not res2.success:\n            return (v_g_star, 0.0)\n\n        z_s = res2.fun if res2.fun is not None else 0.0\n        z_s = max(0.0, z_s)\n\n        return (v_g_star, z_s)\n\n    def compute_cvar(z_values, alpha, N):\n        \"\"\"\n        Computes CVaR using the provided maximization formula.\n        The maximum of the concave piecewise-linear objective function is found at one of the z_k.\n        \"\"\"\n        # Handle alpha=0 case: CVaR is the mean\n        if alpha == 0.0:\n            return np.mean(z_values)\n        \n        # Handle alpha -> 1 case: CVaR approaches the minimum\n        if 1.0 - alpha  1e-9:\n            return np.min(z_values)\n\n        unique_z = np.unique(z_values)\n        max_f_eta = -np.inf\n\n        for eta in unique_z:\n            sum_max = np.sum(np.maximum(0, eta - z_values))\n            f_eta = eta - (1.0 / ((1.0 - alpha) * N)) * sum_max\n            if f_eta > max_f_eta:\n                max_f_eta = f_eta\n        \n        return max_f_eta\n\n    def solve_for_case(case):\n        \"\"\"Solves one complete test case and returns the design code.\"\"\"\n        N, yg_list, yp_list, alpha, tau = case\n        \n        feasible_designs = []\n\n        for x_p, x_o in DESIGNS:\n            v_g_stars = np.zeros(N)\n            z_values = np.zeros(N)\n            \n            for i in range(N):\n                v_g_star, z_s = solve_fluxes_for_scenario(x_p, x_o, yg_list[i], yp_list[i])\n                v_g_stars[i] = v_g_star\n                z_values[i] = z_s\n            \n            # 1. Check viability\n            is_viable = np.min(v_g_stars) >= EPSILON\n            \n            if is_viable:\n                # 2. Check CVaR constraint\n                cvar_val = compute_cvar(z_values, alpha, N)\n                is_cvar_ok = cvar_val >= tau\n                \n                if is_cvar_ok:\n                    feasible_designs.append((x_p, x_o))\n        \n        # 3. Select best design from feasible set based on pre-determined preference\n        if not feasible_designs:\n            return -1\n        \n        for preferred_design in DESIGNS:\n            if preferred_design in feasible_designs:\n                best_design = preferred_design\n                # 4. Encode the design\n                return 2 * best_design[1] + best_design[0]\n        \n        return -1 # Should be unreachable\n\n    # --- Test Suite ---\n    yg = [0.50, 0.60, 0.55, 0.65, 0.52]\n    yp = [0.50, 0.45, 0.60, 0.70, 0.48]\n    N = 5\n    \n    test_cases = [\n        (N, yg, yp, 0.80, 2.60),  # Case 1\n        (N, yg, yp, 0.00, 2.90),  # Case 2\n        (N, yg, yp, 0.95, 2.90),  # Case 3\n        (N, yg, yp, 0.50, 0.00),  # Case 4\n    ]\n\n    results = [solve_for_case(case) for case in test_cases]\n    \n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3290710"}]}