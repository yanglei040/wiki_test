{"hands_on_practices": [{"introduction": "Before analyzing gene expression, it is crucial to understand how we obtain the counts themselves. Unique Molecular Identifiers (UMIs) are essential for removing amplification bias, but the finite number of UMI sequences means that distinct RNA molecules can sometimes be assigned the same tag, an event known as a \"collision.\" This exercise guides you through deriving a mathematical model to predict the expected number of unique UMIs, helping you quantify the potential for saturation and undercounting of highly expressed genes based on fundamental principles of probability theory [@problem_id:3348560].", "problem": "You are designing a mathematical method for estimating deduplicated unique molecular identifiers (UMIs) in single-cell ribonucleic acid sequencing (single-cell RNA-seq). Assume the following generative model for one gene in one cell: the number of captured complementary deoxyribonucleic acid (cDNA) molecules is a random variable $N$ that follows a Poisson distribution with mean $\\lambda$, written $N \\sim \\mathrm{Poisson}(\\lambda)$. Each molecule is tagged by an independently and uniformly sampled UMI of length $L$ over the deoxyribonucleic acid alphabet $\\{A, C, G, T\\}$, so the UMI label space has size $M = 4^L$. Multiple molecules that are assigned the same UMI label are indistinguishable after amplification and sequencing, so the observed number of unique UMIs equals the number of distinct labels occupied by the $N$ molecules. Assume uniform and independent assignment of UMIs across molecules and that $N$ is independent of the labeling.\n\nStarting only from fundamental definitions and well-tested results about the Poisson distribution (you may use that if $N \\sim \\mathrm{Poisson}(\\lambda)$ and each of $N$ items is independently assigned to one of $M$ categories with equal probability $1/M$, then the number of items in each category is independent and follows $\\mathrm{Poisson}(\\lambda/M)$), derive an exact, closed-form expression for the expected number of unique UMIs observed as a function of $\\lambda$ and $L$, denoted $\\mathbb{E}[U \\mid \\lambda, L]$. Your derivation must be purely from first principles using valid properties of the Poisson distribution and linearity of expectation, without invoking any shortcut occupancy formulas.\n\nThen, implement a program that:\n- Computes $M = 4^L$.\n- Computes the exact expected value $\\mathbb{E}[U \\mid \\lambda, L]$ from your derived expression.\n- Uses a numerically stable evaluation strategy suitable for both very small and very large values of $\\lambda/M$.\n- Processes the following test suite of $(L,\\lambda)$ pairs and outputs the result for each in order:\n  1. $(L,\\lambda) = (0, 3.5)$\n  2. $(L,\\lambda) = (2, 1.0)$\n  3. $(L,\\lambda) = (6, 5000.0)$\n  4. $(L,\\lambda) = (8, 1000000.0)$\n  5. $(L,\\lambda) = (12, 100000.0)$\n  6. $(L,\\lambda) = (4, 0.0)$\n\nAll outputs are real numbers. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each value rounded to exactly six digits after the decimal point (for example, $[0.123456,2.000000,15.500000]$). No other text should be printed. There are no physical units or angle units involved, and any fractional values must be expressed in decimal form as specified. The program must be completely deterministic and require no input.", "solution": "The problem asks for an exact, closed-form expression for the expected number of unique Unique Molecular Identifiers (UMIs), denoted $\\mathbb{E}[U \\mid \\lambda, L]$, under a specific generative model. The model assumes the number of captured cDNA molecules, $N$, follows a Poisson distribution with mean $\\lambda$, written as $N \\sim \\mathrm{Poisson}(\\lambda)$. Each of these $N$ molecules is independently tagged with a UMI of length $L$ from the alphabet $\\{A, C, G, T\\}$. The total number of possible UMIs is thus $M = 4^L$. The assignment is uniform and independent.\n\nLet $U$ be the random variable for the number of unique UMIs observed. This is the number of distinct UMI labels present in the set of $N$ molecules. To derive the expectation of $U$, $\\mathbb{E}[U]$, we can use the principle of linearity of expectation.\n\nLet us define a set of indicator random variables, $\\{I_i\\}_{i=1}^{M}$, one for each of the $M$ possible UMI labels. The indicator variable $I_i$ is defined as:\n$$\nI_i =\n\\begin{cases}\n1 & \\text{if UMI label } i \\text{ is assigned to at least one molecule} \\\\\n0 & \\text{if UMI label } i \\text{ is not assigned to any molecule}\n\\end{cases}\n$$\nThe total number of unique UMIs, $U$, is the sum of these indicator variables over all possible UMI labels:\n$$U = \\sum_{i=1}^{M} I_i$$\nBy the linearity of expectation, the expected value of $U$ is the sum of the expected values of the individual indicator variables:\n$$\\mathbb{E}[U] = \\mathbb{E}\\left[\\sum_{i=1}^{M} I_i\\right] = \\sum_{i=1}^{M} \\mathbb{E}[I_i]$$\nThe expectation of an indicator variable is equal to the probability of the event it indicates. Thus, $\\mathbb{E}[I_i] = P(I_i = 1)$.\n$$\\mathbb{E}[U] = \\sum_{i=1}^{M} P(I_i = 1)$$\nSince the UMI for each molecule is chosen uniformly and independently from the $M$ possibilities, the probability of any specific UMI label $i$ being used is the same for all $i$. Therefore, we can simplify the sum:\n$$\\mathbb{E}[U] = M \\cdot P(I_1 = 1)$$\nwhere $P(I_1 = 1)$ is the probability that the first UMI label is used at least once. It is often easier to compute the probability of the complementary event, $P(I_1 = 0)$, which is the probability that UMI label $1$ is never used.\n$$P(I_1 = 1) = 1 - P(I_1 = 0)$$\nSubstituting this into our expression for $\\mathbb{E}[U]$ yields:\n$$\\mathbb{E}[U] = M \\cdot (1 - P(I_1 = 0))$$\nTo find $P(I_1 = 0)$, we must determine the probability that no molecule is assigned UMI label $1$. Let $N_i$ be the random variable representing the number of molecules assigned to UMI label $i$. The event $I_1 = 0$ is equivalent to the event $N_1 = 0$.\n\nThe problem states a key property of the Poisson distribution: if the total count of items, $N$, is a Poisson random variable with mean $\\lambda$, i.e., $N \\sim \\mathrm{Poisson}(\\lambda)$, and each of these $N$ items is independently assigned to one of $M$ categories with equal probability $1/M$, then the number of items in any given category $i$, $N_i$, is an independent Poisson random variable with mean $\\lambda/M$. This is known as the Poisson splitting or thinning property.\n\nApplying this property to our problem, the number of molecules $N_1$ assigned to UMI label $1$ follows a Poisson distribution with mean $\\lambda/M$:\n$$N_1 \\sim \\mathrm{Poisson}(\\lambda/M)$$\nThe probability mass function of a Poisson distribution with mean $\\mu$ is given by $P(k; \\mu) = \\frac{e^{-\\mu}\\mu^k}{k!}$. We need to find the probability that $N_1 = 0$. Using the probability mass function with mean $\\mu = \\lambda/M$ and $k=0$:\n$$P(N_1 = 0) = \\frac{e^{-\\lambda/M}(\\lambda/M)^0}{0!} = e^{-\\lambda/M}$$\nThis gives us the probability that a specific UMI is not used. Substituting this back into the expression for $\\mathbb{E}[U]$:\n$$\\mathbb{E}[U] = M \\cdot (1 - e^{-\\lambda/M})$$\nGiven that $M = 4^L$, the final, exact closed-form expression for the expected number of unique UMIs as a function of $\\lambda$ and $L$ is:\n$$\\mathbb{E}[U \\mid \\lambda, L] = 4^L \\left(1 - e^{-\\lambda/4^L}\\right)$$\nThis concludes the derivation from first principles.\n\nFor numerical implementation, evaluating the expression $1 - e^{-x}$ for $x = \\lambda/M$ can be prone to catastrophic cancellation when $x$ is very small. In this regime, $e^{-x}$ is very close to $1$, and the subtraction loses significant precision. A numerically stable method is to use the `expm1` function, which accurately computes $e^y - 1$ for small $y$. The term can be rewritten as $1 - e^{-x} = -(e^{-x} - 1) = -\\mathrm{expm1}(-x)$. This ensures accurate computation for all values of $\\lambda/M$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the expected number of unique UMIs for a given set of parameters.\n    The derivation shows the expected number of unique UMIs E[U] is M * (1 - exp(-lambda/M)),\n    where M = 4^L.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, lambda)\n        (0, 3.5),\n        (2, 1.0),\n        (6, 5000.0),\n        (8, 1000000.0),\n        (12, 100000.0),\n        (4, 0.0),\n    ]\n\n    results = []\n    for L, lambd in test_cases:\n        # Calculate M = 4^L, the size of the UMI label space.\n        # L must be an integer, so we ensure it is treated as such for the power.\n        M = 4.0**float(L)\n\n        # The case lambda = 0 is trivial: if there are no molecules, there are no UMIs.\n        if lambd == 0.0:\n            expected_U = 0.0\n        else:\n            # The argument for the exponential function.\n            x = lambd / M\n\n            # We use the numerically stable np.expm1 function to calculate 1 - exp(-x).\n            # 1 - exp(-x) = - (exp(-x) - 1) = -expm1(-x).\n            # This avoids catastrophic cancellation when x is close to 0.\n            one_minus_exp_term = -np.expm1(-x)\n            \n            expected_U = M * one_minus_exp_term\n        \n        results.append(expected_U)\n\n    # Format the final results into a single string as specified.\n    # Each value is rounded to exactly six digits after the decimal point.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```", "id": "3348560"}, {"introduction": "A major challenge in single-cell data quality is contamination from ambient RNA released by lysed cells during sample preparation. This practice provides a hands-on implementation of a widely used decontamination algorithm based on a simple but powerful mixture model [@problem_id:3348555]. By subtracting the expected contribution of the ambient profile from each cell's observed counts, you will directly see how this crucial cleaning step can enhance the biological signal, which you will quantify by measuring the improvement in marker gene specificity.", "problem": "You are given a scenario in single-cell RNA sequencing (scRNA-seq) where observed Unique Molecular Identifier (UMI) counts per gene in each cell are affected by ambient RNA contamination. A commonly accepted generative view is that the observed counts arise from sampling a mixture of a cell-internal expression profile and an ambient profile. Let there be $n$ cells and $G$ genes. For each cell $i \\in \\{1,\\dots,n\\}$ and gene $g \\in \\{1,\\dots,G\\}$, define the observed counts as $N_{ig} \\in \\mathbb{N}_0$. Let $\\mathbf{a} \\in \\mathbb{R}_{\\ge 0}^{G}$ be a nonnegative ambient profile over genes that represents the distribution of ambient molecules, and let $c_i \\in [0,1]$ denote the contamination fraction for cell $i$ that represents the expected proportion of counts attributable to ambient contamination. The ambient profile must satisfy $\\sum_{g=1}^{G} a_g = 1$; if not, it should be normalized.\n\n**Fundamental Basis**\n\nIn scRNA-seq with Unique Molecular Identifier (UMI) counting, a well-tested model treats counts as arising from sampling where the expected observed count vector for cell $i$ is a convex mixture of its internal profile and ambient profile. Specifically, if $T_i = \\sum_{g=1}^{G} N_{ig}$ denotes the total observed counts in cell $i$, then the expected ambient-attributable counts per gene in cell $i$ are proportional to $c_i T_i$ and distributed across genes according to $\\mathbf{a}$, reflecting the fact that ambient contamination adds counts following the ambient distribution. The true, decontaminated counts should remove the ambient-attributable component while respecting nonnegativity of counts.\n\n**Marker Gene Specificity**\n\nSuppose each cell $i$ is assigned a label $y_i$ from a finite set of cell types $\\mathcal{Y}$, and for each type $y \\in \\mathcal{Y}$ there is a marker gene set $\\mathcal{S}(y) \\subseteq \\{1,\\dots,G\\}$. Define the marker specificity for cell $i$ under a count matrix $\\mathbf{X} \\in \\mathbb{R}_{\\ge 0}^{n \\times G}$ as the fraction of its total counts that fall within $\\mathcal{S}(y_i)$:\n$$\ns_i(\\mathbf{X}) \\;=\\; \n\\begin{cases}\n\\dfrac{\\sum_{g \\in \\mathcal{S}(y_i)} X_{ig}}{\\sum_{g=1}^{G} X_{ig}} & \\text{if } \\sum_{g=1}^{G} X_{ig} > 0, \\\\\n0 & \\text{otherwise}.\n\\end{cases}\n$$\nTo evaluate the effect of decontamination on marker specificity, compare the mean specificity across cells before and after decontamination, that is compute\n$$\n\\Delta \\;=\\; \\dfrac{1}{n} \\sum_{i=1}^{n} s_i(\\mathbf{D}) \\;-\\; \\dfrac{1}{n} \\sum_{i=1}^{n} s_i(\\mathbf{N}),\n$$\nwhere $\\mathbf{N}$ is the observed counts and $\\mathbf{D}$ is the decontaminated counts.\n\n**Task**\n\nStarting from the fundamental mixture view described above, design and implement a program that:\n- Derives a nonnegative decontamination operator that removes the expected ambient-attributable counts per gene in each cell based on $\\mathbf{a}$, $c_i$, and $T_i$, yielding a decontaminated count matrix $\\mathbf{D}$.\n- Computes the improvement in mean marker specificity $\\Delta$ between $\\mathbf{N}$ and $\\mathbf{D}$ for each test case.\n\nYour algorithm must satisfy the following constraints:\n- The ambient profile $\\mathbf{a}$ must be normalized to sum to $1$ if it does not already.\n- The decontaminated counts per gene must be nonnegative; if subtraction would result in negative values, they must be clipped to $0$.\n- If a cell’s total decontaminated counts sum to $0$, its specificity must be defined as $0$.\n- If a cell type has an empty marker set, its specificity contribution is $0$ for that cell.\n\n**Test suite**\n\nImplement your solution for the following parameter sets. Each test case specifies an observed counts matrix $\\mathbf{N}^{(k)}$, ambient profile $\\mathbf{a}^{(k)}$, per-cell contamination fractions $\\mathbf{c}^{(k)}$, cell labels $\\mathbf{y}^{(k)}$, and marker sets $\\mathcal{S}^{(k)}$. All indices are $0$-based for genes in the marker sets.\n\nTest case $1$ (happy path, moderate contamination):\n- $n = 3$, $G = 5$,\n- $\\mathbf{N}^{(1)} = \\begin{bmatrix}\n12 & 8 & 1 & 3 & 0 \\\\\n2 & 4 & 15 & 0 & 1 \\\\\n0 & 1 & 0 & 20 & 5\n\\end{bmatrix}$,\n- $\\mathbf{a}^{(1)} = \\begin{bmatrix} 0.25 & 0.25 & 0.2 & 0.2 & 0.1 \\end{bmatrix}$,\n- $\\mathbf{c}^{(1)} = \\begin{bmatrix} 0.2 & 0.3 & 0.15 \\end{bmatrix}$,\n- $\\mathbf{y}^{(1)} = \\begin{bmatrix} \\text{A} & \\text{B} & \\text{C} \\end{bmatrix}$,\n- $\\mathcal{S}^{(1)}(\\text{A}) = \\{0,1\\}$, $\\mathcal{S}^{(1)}(\\text{B}) = \\{2\\}$, $\\mathcal{S}^{(1)}(\\text{C}) = \\{3\\}$.\n\nTest case $2$ (boundary condition, zero contamination):\n- $n = 2$, $G = 4$,\n- $\\mathbf{N}^{(2)} = \\begin{bmatrix}\n5 & 0 & 0 & 5 \\\\\n0 & 10 & 0 & 0\n\\end{bmatrix}$,\n- $\\mathbf{a}^{(2)} = \\begin{bmatrix} 0.4 & 0.1 & 0.4 & 0.1 \\end{bmatrix}$,\n- $\\mathbf{c}^{(2)} = \\begin{bmatrix} 0 & 0 \\end{bmatrix}$,\n- $\\mathbf{y}^{(2)} = \\begin{bmatrix} \\text{C} & \\text{A} \\end{bmatrix}$,\n- $\\mathcal{S}^{(2)}(\\text{A}) = \\{1\\}$, $\\mathcal{S}^{(2)}(\\text{C}) = \\{3\\}$.\n\nTest case $3$ (edge case, high contamination and clipping):\n- $n = 2$, $G = 4$,\n- $\\mathbf{N}^{(3)} = \\begin{bmatrix}\n3 & 1 & 0 & 0 \\\\\n1 & 0 & 2 & 0\n\\end{bmatrix}$,\n- $\\mathbf{a}^{(3)} = \\begin{bmatrix} 0.7 & 0.2 & 0.1 & 0.0 \\end{bmatrix}$,\n- $\\mathbf{c}^{(3)} = \\begin{bmatrix} 0.95 & 0.8 \\end{bmatrix}$,\n- $\\mathbf{y}^{(3)} = \\begin{bmatrix} \\text{A} & \\text{B} \\end{bmatrix}$,\n- $\\mathcal{S}^{(3)}(\\text{A}) = \\{0\\}$, $\\mathcal{S}^{(3)}(\\text{B}) = \\{2\\}$.\n\nTest case $4$ (edge case, total decontaminated counts vanish):\n- $n = 1$, $G = 3$,\n- $\\mathbf{N}^{(4)} = \\begin{bmatrix}\n1 & 0 & 0\n\\end{bmatrix}$,\n- $\\mathbf{a}^{(4)} = \\begin{bmatrix} 0.6 & 0.3 & 0.1 \\end{bmatrix}$,\n- $\\mathbf{c}^{(4)} = \\begin{bmatrix} 1.0 \\end{bmatrix}$,\n- $\\mathbf{y}^{(4)} = \\begin{bmatrix} \\text{A} \\end{bmatrix}$,\n- $\\mathcal{S}^{(4)}(\\text{A}) = \\{0\\}$.\n\nTest case $5$ (edge case, empty marker set for one label):\n- $n = 2$, $G = 3$,\n- $\\mathbf{N}^{(5)} = \\begin{bmatrix}\n10 & 5 & 0 \\\\\n0 & 0 & 8\n\\end{bmatrix}$,\n- $\\mathbf{a}^{(5)} = \\begin{bmatrix} 0.2 & 0.2 & 0.6 \\end{bmatrix}$,\n- $\\mathbf{c}^{(5)} = \\begin{bmatrix} 0.2 & 0.4 \\end{bmatrix}$,\n- $\\mathbf{y}^{(5)} = \\begin{bmatrix} \\text{D} & \\text{B} \\end{bmatrix}$,\n- $\\mathcal{S}^{(5)}(\\text{D}) = \\varnothing$, $\\mathcal{S}^{(5)}(\\text{B}) = \\{2\\}$.\n\n**Final output format**\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case’s result must be the float $\\Delta$ rounded to six decimal places. For example, output should look like $[\\delta_1,\\delta_2,\\dots,\\delta_5]$ where each $\\delta_k$ is a decimal with six places. No other text should be printed.", "solution": "The problem is valid. It is scientifically grounded in established models of ambient RNA contamination in single-cell RNA sequencing, it is well-posed with clear definitions and constraints, and it is expressed objectively. All necessary parameters and conditions are provided to derive a unique, meaningful solution.\n\nThe solution is developed in three stages: first, the derivation of the decontamination operator from the provided generative model; second, the formalization of the marker specificity metric; and third, the specification of the complete algorithm to compute the change in mean marker specificity, $\\Delta$.\n\n**1. Derivation of the Decontamination Operator**\n\nThe problem posits a generative model where the observed UMI counts, $\\mathbf{N} \\in \\mathbb{N}_0^{n \\times G}$, for $n$ cells and $G$ genes are a mixture of true cellular counts and ambient RNA counts. The ambient RNA contribution is defined by an ambient profile $\\mathbf{a} \\in \\mathbb{R}_{\\ge 0}^{G}$ (a probability distribution over genes, $\\sum_{g=1}^{G} a_g = 1$) and a per-cell contamination fraction $c_i \\in [0,1]$.\n\nFor each cell $i$, the total observed UMI count is $T_i = \\sum_{g=1}^{G} N_{ig}$. The contamination fraction $c_i$ represents the expected proportion of these total counts that originate from the ambient pool. Therefore, the total number of expected ambient counts in cell $i$ is $c_i T_i$.\n\nThese ambient counts are distributed across the $G$ genes according to the ambient profile $\\mathbf{a}$. The expected number of ambient counts for a specific gene $g$ in cell $i$, denoted $A_{ig}$, is the total expected ambient count for that cell multiplied by the relative frequency of gene $g$ in the ambient profile, $a_g$.\n$$\nE[A_{ig}] = (c_i T_i) a_g\n$$\nThe goal of decontamination is to estimate the true, cell-internal counts by removing this expected ambient component from the observed counts $N_{ig}$. Let $\\mathbf{D} \\in \\mathbb{R}_{\\ge 0}^{n \\times G}$ be the matrix of decontaminated counts. An element $D_{ig}$ is obtained by subtracting the expected ambient count from the observed count:\n$$\nD_{ig} = N_{ig} - c_i T_i a_g\n$$\nA critical constraint is that counts must be nonnegative. If the subtraction results in a negative value (which can happen if the observed count $N_{ig}$ is lower than the expected ambient contribution, due to sampling noise), the value must be clipped at $0$. This leads to the final form of the decontamination operator:\n$$\nD_{ig} = \\max(0, N_{ig} - c_i T_i a_g)\n$$\nThis operation is applied to each gene in each cell to produce the full decontaminated matrix $\\mathbf{D}$.\n\n**2. Marker Gene Specificity**\n\nMarker gene specificity for a cell $i$ is defined as the fraction of its total UMI counts that are attributed to the set of marker genes, $\\mathcal{S}(y_i)$, for its assigned cell type, $y_i$. For a generic count matrix $\\mathbf{X} \\in \\mathbb{R}_{\\ge 0}^{n \\times G}$, the specificity $s_i(\\mathbf{X})$ is:\n$$\ns_i(\\mathbf{X}) \\;=\\; \n\\begin{cases}\n\\dfrac{\\sum_{g \\in \\mathcal{S}(y_i)} X_{ig}}{\\sum_{g=1}^{G} X_{ig}} & \\text{if } \\sum_{g=1}^{G} X_{ig} > 0 \\\\\n0 & \\text{otherwise}\n\\end{cases}\n$$\nThis formula applies to both the observed counts matrix $\\mathbf{N}$ and the decontaminated counts matrix $\\mathbf{D}$. The problem also specifies that if a marker set $\\mathcal{S}(y_i)$ is empty, the numerator is $0$, thus $s_i(\\mathbf{X}) = 0$. The overall quality metric is the change in the mean specificity across all $n$ cells after decontamination:\n$$\n\\Delta \\;=\\; \\bar{s}(\\mathbf{D}) - \\bar{s}(\\mathbf{N}) \\;=\\; \\left(\\dfrac{1}{n} \\sum_{i=1}^{n} s_i(\\mathbf{D})\\right) \\;-\\; \\left(\\dfrac{1}{n} \\sum_{i=1}^{n} s_i(\\mathbf{N})\\right)\n$$\n\n**3. Algorithm for Computing Specificity Improvement $\\Delta$**\n\nThe complete algorithm for a given test case ($\\mathbf{N}, \\mathbf{a}, \\mathbf{c}, \\mathbf{y}, \\mathcal{S}$) is as follows:\n\n1.  **Normalize Ambient Profile**: Check if $\\sum_{g=1}^{G} a_g = 1$. If not, normalize $\\mathbf{a}$ by dividing it by its sum. Let the normalized profile be $\\mathbf{a}'$.\n    $$\n    \\mathbf{a}' = \\dfrac{\\mathbf{a}}{\\sum_{g=1}^{G} a_g}\n    $$\n2.  **Calculate Mean Specificity for Observed Counts**:\n    a. For each cell $i=1, \\dots, n$, calculate the total observed counts $T_i = \\sum_{g=1}^{G} N_{ig}$.\n    b. For each cell $i$, calculate its specificity $s_i(\\mathbf{N})$ using the formula, its label $y_i$, and the corresponding marker set $\\mathcal{S}(y_i)$. Handle the cases where $T_i=0$ or $\\mathcal{S}(y_i)$ is empty.\n    c. Compute the mean observed specificity $\\bar{s}(\\mathbf{N}) = \\frac{1}{n} \\sum_{i=1}^{n} s_i(\\mathbf{N})$.\n\n3.  **Perform Decontamination**:\n    a. For each cell $i=1, \\dots, n$, calculate the decontaminated count vector $\\mathbf{D}_{i,:}$ using the operator derived above:\n       $$\n       D_{ig} = \\max(0, N_{ig} - c_i T_i a'_g) \\quad \\text{for } g=1, \\dots, G\n       $$\n    b. These vectors form the decontaminated matrix $\\mathbf{D}$.\n\n4.  **Calculate Mean Specificity for Decontaminated Counts**:\n    a. For each cell $i=1, \\dots, n$, calculate the total decontaminated counts $T'_i = \\sum_{g=1}^{G} D_{ig}$.\n    b. For each cell $i$, calculate its decontaminated specificity $s_i(\\mathbf{D})$ using the formula, with $T'_i=0$ resulting in $s_i(\\mathbf{D})=0$.\n    c. Compute the mean decontaminated specificity $\\bar{s}(\\mathbf{D}) = \\frac{1}{n} \\sum_{i=1}^{n} s_i(\\mathbf{D})$.\n\n5.  **Compute Final Metric**: Calculate the difference $\\Delta = \\bar{s}(\\mathbf{D}) - \\bar{s}(\\mathbf{N})$. The result is rounded to six decimal places as required.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        {\n            \"N\": np.array([[12, 8, 1, 3, 0], [2, 4, 15, 0, 1], [0, 1, 0, 20, 5]]),\n            \"a\": np.array([0.25, 0.25, 0.2, 0.2, 0.1]),\n            \"c\": np.array([0.2, 0.3, 0.15]),\n            \"y\": ['A', 'B', 'C'],\n            \"S\": {'A': {0, 1}, 'B': {2}, 'C': {3}}\n        },\n        {\n            \"N\": np.array([[5, 0, 0, 5], [0, 10, 0, 0]]),\n            \"a\": np.array([0.4, 0.1, 0.4, 0.1]),\n            \"c\": np.array([0.0, 0.0]),\n            \"y\": ['C', 'A'],\n            \"S\": {'A': {1}, 'C': {3}}\n        },\n        {\n            \"N\": np.array([[3, 1, 0, 0], [1, 0, 2, 0]]),\n            \"a\": np.array([0.7, 0.2, 0.1, 0.0]),\n            \"c\": np.array([0.95, 0.8]),\n            \"y\": ['A', 'B'],\n            \"S\": {'A': {0}, 'B': {2}}\n        },\n        {\n            \"N\": np.array([[1, 0, 0]]),\n            \"a\": np.array([0.6, 0.3, 0.1]),\n            \"c\": np.array([1.0]),\n            \"y\": ['A'],\n            \"S\": {'A': {0}}\n        },\n        {\n            \"N\": np.array([[10, 5, 0], [0, 0, 8]]),\n            \"a\": np.array([0.2, 0.2, 0.6]),\n            \"c\": np.array([0.2, 0.4]),\n            \"y\": ['D', 'B'],\n            \"S\": {'D': set(), 'B': {2}}\n        }\n    ]\n\n    results = []\n\n    def calculate_mean_specificity(X, y_labels, marker_sets):\n        \"\"\"\n        Helper function to calculate the mean marker specificity for a count matrix.\n        \"\"\"\n        n, _ = X.shape\n        total_specificity = 0.0\n        for i in range(n):\n            total_counts_i = np.sum(X[i, :])\n            if total_counts_i == 0:\n                specificity_i = 0.0\n            else:\n                cell_type = y_labels[i]\n                marker_genes = marker_sets.get(cell_type, set())\n                if not marker_genes:\n                    specificity_i = 0.0\n                else:\n                    marker_indices = list(marker_genes)\n                    marker_counts = np.sum(X[i, marker_indices])\n                    specificity_i = marker_counts / total_counts_i\n            total_specificity += specificity_i\n        return total_specificity / n\n\n    for case in test_cases:\n        N, a, c, y, S = case[\"N\"], case[\"a\"], case[\"c\"], case[\"y\"], case[\"S\"]\n        \n        # Step 1: Normalize ambient profile 'a' if necessary\n        a_sum = np.sum(a)\n        if not np.isclose(a_sum, 1.0):\n            a = a / a_sum\n\n        # Step 2: Calculate mean specificity for observed counts N\n        mean_specificity_N = calculate_mean_specificity(N, y, S)\n\n        # Step 3: Perform decontamination\n        # Calculate total observed counts per cell\n        T = np.sum(N, axis=1)\n        \n        # Calculate the expected ambient counts to subtract for each cell and gene.\n        # This requires broadcasting:\n        # c (n,1) * T (n,1) * a (1,G) -> (n,G)\n        ambient_subtraction_matrix = c.reshape(-1, 1) * T.reshape(-1, 1) * a.reshape(1, -1)\n\n        # Decontaminate by subtracting and clipping at 0\n        D = np.maximum(0, N - ambient_subtraction_matrix)\n\n        # Step 4: Calculate mean specificity for decontaminated counts D\n        mean_specificity_D = calculate_mean_specificity(D, y, S)\n        \n        # Step 5: Compute the final metric delta\n        delta = mean_specificity_D - mean_specificity_N\n        results.append(delta)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "3348555"}, {"introduction": "Once counts are cleaned, the next step is often to identify the most biologically informative genes for downstream analysis. This exercise introduces the core concept of identifying Highly Variable Genes (HVGs), which are genes whose expression variability across cells exceeds what is expected from technical noise alone [@problem_id:3348549]. You will implement this foundational feature selection technique by modeling the mean-variance relationship of gene expression and compare how different statistical assumptions, such as a Poisson versus a Negative Binomial noise model, can impact the final set of selected genes.", "problem": "You are given normalized counts matrices and a fitted mean-variance curve for each dataset. Your task is to programmatically compute Highly Variable Genes (HVGs) under two noise models, the Poisson model and the Negative Binomial model, and compare the selections. Your program must follow the definitions and procedures below precisely and produce a single-line output aggregating the results for all provided test cases.\n\nDefinitions and required computations:\n- Let $X \\in \\mathbb{R}^{n \\times p}$ denote a normalized counts matrix with $n$ cells (rows) and $p$ genes (columns).\n- For each gene $g \\in \\{0,1,\\dots,p-1\\}$, compute the sample mean across cells\n  $$\\bar{x}_g \\equiv \\frac{1}{n} \\sum_{i=1}^{n} x_{ig},$$\n  and the unbiased sample variance\n  $$s_g^2 \\equiv \\frac{1}{n-1} \\sum_{i=1}^{n} \\left(x_{ig} - \\bar{x}_g\\right)^2.$$\n- A fitted mean-variance curve is provided as a quadratic function\n  $$\\hat{v}_{\\text{trend}}(m) = a + b\\,m + c\\,m^2,$$\n  with given coefficients $a$, $b$, and $c$ per dataset.\n- Under the Poisson noise model, the variance-mean relationship is $v_{\\text{P}}(m) = m$. Define the model-constrained expected variance as\n  $$E_{\\text{P}}(m) \\equiv \\max\\left( \\hat{v}_{\\text{trend}}(m), \\, v_{\\text{P}}(m) \\right) = \\max\\left( a + b\\,m + c\\,m^2,\\, m \\right).$$\n- Under the Negative Binomial noise model with dispersion parameter $\\alpha > 0$, the variance-mean relationship is $v_{\\text{NB}}(m) = m + \\alpha\\,m^2$. Define the model-constrained expected variance as\n  $$E_{\\text{NB}}(m) \\equiv \\max\\left( \\hat{v}_{\\text{trend}}(m), \\, v_{\\text{NB}}(m) \\right) = \\max\\left( a + b\\,m + c\\,m^2,\\, m + \\alpha\\,m^2 \\right).$$\n- For numerical stability, when dividing by an expected variance, use a small constant $\\varepsilon = 10^{-8}$ to avoid division by zero by replacing any denominator $d$ with $\\max(d, \\varepsilon)$.\n- Define the standardized residual dispersion for each gene $g$ under a model as\n  $$r_g^{(\\cdot)} \\equiv \\frac{s_g^2 - E_{(\\cdot)}(\\bar{x}_g)}{\\max\\left( E_{(\\cdot)}(\\bar{x}_g), \\, \\varepsilon \\right)},$$\n  where $(\\cdot) \\in \\{\\text{P}, \\text{NB}\\}$ indicates the model.\n- HVG selection rule for a given model: select the indices of the top $K$ genes by descending $r_g^{(\\cdot)}$ among those with strictly positive residuals $r_g^{(\\cdot)} > 0$. If fewer than $K$ genes have strictly positive residuals, return all with strictly positive residuals. Break ties by:\n  $1)$ larger $\\bar{x}_g$ (descending),\n  $2)$ smaller gene index $g$ (ascending).\n- All gene indices are $0$-based integers.\n\nTest suite:\nFor each test case $t \\in \\{1,2,3,4\\}$, you are given a matrix $X^{(t)}$, coefficients $(a^{(t)}, b^{(t)}, c^{(t)})$, a Negative Binomial dispersion $\\alpha^{(t)}$, and a target $K^{(t)}$. Your program must compute and return for each test $t$ a pair of lists: the HVG indices under the Poisson model and under the Negative Binomial model, respectively.\n\n- Test case $1$:\n  - $X^{(1)}$ has $n=5$ rows and $p=6$ columns with rows\n    $[2, 0, 3, 1, 10, 5]$,\n    $[3, 0, 4, 1, 11, 6]$,\n    $[2, 0, 8, 1, 9, 5]$,\n    $[3, 0, 2, 1, 12, 4]$,\n    $[2, 0, 5, 1, 8, 5]$.\n  - $(a^{(1)}, b^{(1)}, c^{(1)}) = (0.2, 0.7, 0.02)$.\n  - $\\alpha^{(1)} = 0.1$.\n  - $K^{(1)} = 3$.\n\n- Test case $2$:\n  - $X^{(2)}$ has $n=4$ rows and $p=4$ columns with rows\n    $[0, 0, 0, 10]$,\n    $[0, 0, 0, 10]$,\n    $[0, 0, 0, 10]$,\n    $[0, 0, 0, 11]$.\n  - $(a^{(2)}, b^{(2)}, c^{(2)}) = (0.1, 0.1, 0.01)$.\n  - $\\alpha^{(2)} = 0.05$.\n  - $K^{(2)} = 2$.\n\n- Test case $3$:\n  - $X^{(3)}$ has $n=5$ rows and $p=4$ columns with rows\n    $[0, 5, 0, 1]$,\n    $[0, 5, 0, 1]$,\n    $[0, 5, 50, 1]$,\n    $[0, 5, 0, 1]$,\n    $[0, 5, 0, 1]$.\n  - $(a^{(3)}, b^{(3)}, c^{(3)}) = (0.1, 0.2, 0.0)$.\n  - $\\alpha^{(3)} = 0.1$.\n  - $K^{(3)} = 1$.\n\n- Test case $4$:\n  - $X^{(4)}$ has $n=4$ rows and $p=3$ columns with rows\n    $[5, 10, 0]$,\n    $[7, 10, 5]$,\n    $[6, 10, 0]$,\n    $[8, 10, 5]$.\n  - $(a^{(4)}, b^{(4)}, c^{(4)}) = (0.1, 0.5, 0.0)$.\n  - $\\alpha^{(4)} = 1.0$.\n  - $K^{(4)} = 2$.\n\nFinal output format:\n- Your program should produce a single line of output containing a list with one entry per test case, in order $t=1,2,3,4$.\n- Each entry must be a two-element list: the first element is the list of HVG indices under the Poisson model, and the second element is the list under the Negative Binomial model.\n- The entire output must be printed on a single line, with comma separators and no spaces, for example:\n  `[[[i_P_1,i_P_2],[i_NB_1]],[[...],[...]],[[...],[...]],[[...],[...]]]`\nwhere $i\\_P\\_\\cdot$ and $i\\_{NB}\\_\\cdot$ are integers. If a list is empty, it must be printed as `[]`. Your program must not print any other text.", "solution": "The problem requires the identification of Highly Variable Genes (HVGs) from normalized single-cell RNA-seq count data using two distinct statistical noise models: the Poisson model and the Negative Binomial model. The procedure is a well-defined computational workflow standard in bioinformatics, designed to distinguish genes with significant biological variation from those whose observed variance is consistent with statistical noise inherent in the sequencing process.\n\nThe fundamental principle is the analysis of the mean-variance relationship of gene expression counts. For count data, the variance of a gene's expression across cells is intrinsically linked to its mean expression level. We will systematically compute per-gene statistics, model the expected variance based on the mean, and then identify genes whose observed variance significantly exceeds this expectation.\n\nThe algorithmic procedure is as follows:\n\n1.  **Per-Gene Statistics Calculation**: For each dataset, represented by a normalized counts matrix $X$ of size $n \\times p$ (where $n$ is the number of cells and $p$ is the number of genes), we first compute two essential statistics for every gene $g$:\n    -   The sample mean expression, $\\bar{x}_g = \\frac{1}{n} \\sum_{i=1}^{n} x_{ig}$.\n    -   The unbiased sample variance of expression, $s_g^2 = \\frac{1}{n-1} \\sum_{i=1}^{n} (x_{ig} - \\bar{x}_g)^2$.\n    These calculations are performed across the $n$ cells for each of the $p$ genes.\n\n2.  **Modeling Expected Variance**: The core of HVG detection lies in comparing the observed variance $s_g^2$ to an expected variance derived from a model. The problem specifies two such models, and combines them with a pre-fitted trend.\n\n    -   A general trend of variance-versus-mean is captured by a fitted quadratic function, $\\hat{v}_{\\text{trend}}(m) = a + b m + c m^2$. This trend accounts for systematic biases and global patterns in the data.\n\n    -   **Poisson Model**: This model assumes that the counts for a gene with mean expression $m$ follow a Poisson distribution, for which the variance is equal to the mean. The theoretical variance is $v_{\\text{P}}(m) = m$. The expected variance under this model, $E_{\\text{P}}(m)$, is defined as the maximum of the fitted trend and the theoretical Poisson variance: $E_{\\text{P}}(m) \\equiv \\max(\\hat{v}_{\\text{trend}}(m), v_{\\text{P}}(m))$. This formulation ensures that the expected variance is at least as large as what is predicted by both the general trend and the fundamental noise model.\n\n    -   **Negative Binomial (NB) Model**: The NB distribution is a more flexible model for overdispersed count data, which is typical for scRNA-seq. Its variance is a quadratic function of the mean: $v_{\\text{NB}}(m) = m + \\alpha m^2$, where $\\alpha > 0$ is the dispersion parameter. A larger $\\alpha$ indicates greater overdispersion (variance much larger than the mean). The expected variance for the NB model is defined analogously: $E_{\\text{NB}}(m) \\equiv \\max(\\hat{v}_{\\text{trend}}(m), v_{\\text{NB}}(m))$.\n\n3.  **Quantifying Excess Variation**: To identify genes with unusually high variance, we compute the standardized residual dispersion, $r_g$, for each gene. This metric quantifies how much the observed variance $s_g^2$ deviates from the expected variance $E_{(\\cdot)}(\\bar{x}_g)$, normalized by the expected variance itself. For a given model $(\\cdot) \\in \\{\\text{P}, \\text{NB}\\}$, it is calculated as:\n    $$r_g^{(\\cdot)} = \\frac{s_g^2 - E_{(\\cdot)}(\\bar{x}_g)}{\\max(E_{(\\cdot)}(\\bar{x}_g), \\varepsilon)}$$\n    A small constant $\\varepsilon = 10^{-8}$ is used in the denominator to prevent division by zero, a necessary precaution for genes with zero or near-zero expected variance. A positive residual, $r_g^{(\\cdot)} > 0$, indicates that the gene's observed variance is higher than expected under the model, suggesting it is a candidate for being an HVG.\n\n4.  **HVG Selection and Ranking**: The final step is to select the top HVGs based on their residual dispersion values.\n    -   First, we filter the genes to retain only those with a strictly positive residual, $r_g^{(\\cdot)} > 0$.\n    -   Next, these candidate genes are ranked. The primary sorting key is the residual dispersion $r_g^{(\\cdot)}$ in descending order. To ensure a unique and deterministic ranking, ties are broken using two subsequent criteria: first by higher mean expression $\\bar{x}_g$ (descending), and then by lower gene index $g$ (ascending).\n    -   Finally, we select the indices of the top $K$ genes from this ranked list. If the number of genes with positive residuals is less than $K$, all of them are selected.\n\nThis procedure is applied independently for both the Poisson and Negative Binomial models for each test case provided. The implementation will leverage vectorized operations for efficiency, computing the means, variances, and residuals for all genes simultaneously.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final aggregated result.\n    \"\"\"\n    test_cases = [\n        {\n            \"X\": np.array([\n                [2, 0, 3, 1, 10, 5],\n                [3, 0, 4, 1, 11, 6],\n                [2, 0, 8, 1, 9, 5],\n                [3, 0, 2, 1, 12, 4],\n                [2, 0, 5, 1, 8, 5]\n            ], dtype=float),\n            \"coeffs\": (0.2, 0.7, 0.02),\n            \"alpha\": 0.1,\n            \"K\": 3\n        },\n        {\n            \"X\": np.array([\n                [0, 0, 0, 10],\n                [0, 0, 0, 10],\n                [0, 0, 0, 10],\n                [0, 0, 0, 11]\n            ], dtype=float),\n            \"coeffs\": (0.1, 0.1, 0.01),\n            \"alpha\": 0.05,\n            \"K\": 2\n        },\n        {\n            \"X\": np.array([\n                [0, 5, 0, 1],\n                [0, 5, 0, 1],\n                [0, 5, 50, 1],\n                [0, 5, 0, 1],\n                [0, 5, 0, 1]\n            ], dtype=float),\n            \"coeffs\": (0.1, 0.2, 0.0),\n            \"alpha\": 0.1,\n            \"K\": 1\n        },\n        {\n            \"X\": np.array([\n                [5, 10, 0],\n                [7, 10, 5],\n                [6, 10, 0],\n                [8, 10, 5]\n            ], dtype=float),\n            \"coeffs\": (0.1, 0.5, 0.0),\n            \"alpha\": 1.0,\n            \"K\": 2\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        hvg_p = compute_hvgs(case[\"X\"], case[\"coeffs\"], case[\"K\"], model='poisson')\n        hvg_nb = compute_hvgs(case[\"X\"], case[\"coeffs\"], case[\"K\"], model='neg_binomial', alpha=case[\"alpha\"])\n        results.append([hvg_p, hvg_nb])\n\n    # Format the final output string exactly as specified.\n    case_strings = []\n    for res_pair in results:\n        p_str = ','.join(map(str, res_pair[0]))\n        nb_str = ','.join(map(str, res_pair[1]))\n        case_strings.append(f'[[{p_str}],[{nb_str}]]')\n    \n    print(f\"[{','.join(case_strings)}]\")\n\ndef compute_hvgs(X, coeffs, K, model, alpha=None):\n    \"\"\"\n    Computes Highly Variable Genes (HVGs) for a given counts matrix and parameters.\n\n    Args:\n        X (np.ndarray): n x p normalized counts matrix.\n        coeffs (tuple): (a, b, c) coefficients for the mean-variance trend.\n        K (int): The number of top HVGs to select.\n        model (str): 'poisson' or 'neg_binomial'.\n        alpha (float, optional): Dispersion parameter for the NB model. Required if model is 'neg_binomial'.\n\n    Returns:\n        list: A list of 0-based integer indices of the selected HVGs.\n    \"\"\"\n    n, p = X.shape\n    if n  2:\n        return []\n\n    a, b, c = coeffs\n    epsilon = 1e-8\n\n    # Step 1: Compute per-gene sample mean and variance\n    means = np.mean(X, axis=0)\n    # ddof=1 for unbiased sample variance (1/(n-1))\n    variances = np.var(X, axis=0, ddof=1)\n\n    # Step 2: Compute expected variance based on the model\n    v_trend = a + b * means + c * means**2\n\n    if model == 'poisson':\n        v_model = means\n    elif model == 'neg_binomial':\n        if alpha is None:\n            raise ValueError(\"alpha must be provided for the Negative Binomial model.\")\n        v_model = means + alpha * means**2\n    else:\n        raise ValueError(\"Unknown model specified.\")\n\n    expected_variances = np.maximum(v_trend, v_model)\n\n    # Step 3: Compute standardized residual dispersion\n    denominators = np.maximum(expected_variances, epsilon)\n    residuals = (variances - expected_variances) / denominators\n\n    # Step 4: Filter, rank, and select HVGs\n    candidates = []\n    for g in range(p):\n        if residuals[g] > 0:\n            # Store (residual, mean, gene_index) for sorting\n            candidates.append((residuals[g], means[g], g))\n\n    # Sort based on the specified tie-breaking rules:\n    # 1. residual descending (reverse=True on item[0])\n    # 2. mean descending (reverse=True on item[1])\n    # 3. gene index ascending (reverse=False on item[2], so we use -item[2] with reverse=True)\n    candidates.sort(key=lambda item: (item[0], item[1], -item[2]), reverse=True)\n\n    # Select the top K gene indices\n    hvg_indices = [item[2] for item in candidates[:K]]\n    \n    return hvg_indices\n\nsolve()\n```", "id": "3348549"}]}