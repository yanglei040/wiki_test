{"hands_on_practices": [{"introduction": "Before we can simulate metabolic activity, we must ensure our network model is built on a solid foundation, which is the law of conservation of mass. This exercise [@problem_id:3312958] will guide you through the process of translating reaction equations into a stoichiometric matrix, $S$, and systematically verifying that each reaction is elementally balanced. Mastering this is a critical first step in model curation, as any simulation based on an imbalanced network would be physically meaningless.", "problem": "You are curating a draft genome-scale metabolic subnetwork and must verify that its reactions respect the law of conservation of atoms and mass, a prerequisite for gap-filling decisions. Consider the following metabolite list with compartments and empirical formulas, where $[e]$ denotes the extracellular compartment and $[c]$ denotes the cytosolic compartment. Treat the same chemical in different compartments as distinct species.\n\n- $ \\mathrm{glc}[e] $ (glucose, extracellular): formula $ \\mathrm{C}_{6} \\mathrm{H}_{12} \\mathrm{O}_{6} $.\n- $ \\mathrm{glc}[c] $ (glucose, cytosol): formula $ \\mathrm{C}_{6} \\mathrm{H}_{12} \\mathrm{O}_{6} $.\n- $ \\mathrm{pi}[c] $ (inorganic phosphate, cytosol): formula $ \\mathrm{H}_{1} \\mathrm{O}_{4} \\mathrm{P}_{1} $.\n- $ \\mathrm{h2o}[c] $ (water, cytosol): formula $ \\mathrm{H}_{2} \\mathrm{O}_{1} $.\n- $ \\mathrm{g6p}[c] $ (glucose-6-phosphate, cytosol): formula $ \\mathrm{C}_{6} \\mathrm{H}_{11} \\mathrm{O}_{9} \\mathrm{P}_{1} $.\n- $ \\mathrm{h}[c] $ (proton, cytosol): formula $ \\mathrm{H}_{1} $.\n- $ \\mathrm{pyr}[c] $ (pyruvate, cytosol): formula $ \\mathrm{C}_{3} \\mathrm{H}_{3} \\mathrm{O}_{3} $.\n- $ \\mathrm{lac}[c] $ (lactate, cytosol): formula $ \\mathrm{C}_{3} \\mathrm{H}_{5} \\mathrm{O}_{3} $.\n- $ \\mathrm{co2}[c] $ (carbon dioxide, cytosol): formula $ \\mathrm{C}_{1} \\mathrm{O}_{2} $.\n\nThe draft network includes the following reactions, listed with integer stoichiometric coefficients. Production is on the right-hand side and consumption is on the left-hand side.\n\n- $ R_{1}: \\ \\mathrm{glc}[e] \\rightarrow \\mathrm{glc}[c] $.\n- $ R_{2}: \\ \\mathrm{glc}[c] + \\mathrm{pi}[c] \\rightarrow \\mathrm{g6p}[c] + \\mathrm{h2o}[c] $.\n- $ R_{3}: \\ \\mathrm{g6p}[c] + \\mathrm{h2o}[c] \\rightarrow \\mathrm{glc}[c] + \\mathrm{pi}[c] $.\n- $ R_{4}: \\ \\mathrm{pyr}[c] + 2 \\ \\mathrm{h}[c] \\rightarrow \\mathrm{lac}[c] $.\n- $ R_{5}: \\ \\mathrm{pyr}[c] \\rightarrow \\mathrm{lac}[c] + \\mathrm{co2}[c] $.\n- $ R_{6}: \\ \\mathrm{glc}[e] \\rightarrow \\varnothing $ (glucose exchange to a boundary sink).\n\nTasks:\n\n1. Using the sign convention that reactants have negative coefficients and products have positive coefficients, construct the stoichiometric matrix $ S $ with rows ordered as $ [ \\mathrm{glc}[e], \\mathrm{glc}[c], \\mathrm{pi}[c], \\mathrm{h2o}[c], \\mathrm{g6p}[c], \\mathrm{h}[c], \\mathrm{pyr}[c], \\mathrm{lac}[c], \\mathrm{co2}[c] ] $ and columns ordered as $ [ R_{1}, R_{2}, R_{3}, R_{4}, R_{5}, R_{6} ] $.\n\n2. Invoke the law of conservation of atoms and the definition of the stoichiometric matrix to verify elemental balance for each internal reaction, by comparing total counts of $ \\mathrm{C} $, $ \\mathrm{H} $, $ \\mathrm{O} $, and $ \\mathrm{P} $ on the left-hand side versus the right-hand side. Treat $ R_{6} $ as a boundary exchange (do not include it in the internal-balance verification).\n\n3. Let the atomic weights be symbolically denoted by $ w_{\\mathrm{C}} $, $ w_{\\mathrm{H}} $, $ w_{\\mathrm{O}} $, and $ w_{\\mathrm{P}} $, with each $ w_{\\alpha} > 0 $. Using these weights and the elemental counts, justify mass balance for those reactions that are atomically balanced, and detect mass imbalance for any reaction that is not atomically balanced.\n\n4. Let $ k $ be the number of reactions among $ \\{ R_{1}, R_{2}, R_{3}, R_{4}, R_{5} \\} $ that are not atomically balanced. Report the value of $ k $. The final answer must be a single integer. No rounding is necessary, and no units are required.", "solution": "We begin from the definitions used in constraint-based modeling and the law of conservation of mass and atoms.\n\n- The stoichiometric matrix $ S \\in \\mathbb{R}^{m \\times n} $ encodes reaction stoichiometry with $ m $ metabolites as rows and $ n $ reactions as columns. For a reaction $ j $, the stoichiometric coefficient $ S_{ij} $ is negative if metabolite $ i $ is consumed and positive if it is produced.\n\n- Atomic balance for an element $ \\alpha \\in \\{ \\mathrm{C}, \\mathrm{H}, \\mathrm{O}, \\mathrm{P} \\} $ in a reaction requires that the total number of atoms of $ \\alpha $ on the left-hand side equals that on the right-hand side. This follows from the law of conservation of atoms.\n\n- If each element is conserved and atomic weights $ w_{\\alpha} $ are positive constants, then mass is conserved because the total mass is a linear combination of conserved atomic counts with positive weights.\n\nStep 1: Construct the stoichiometric matrix $ S $.\n\nWe adhere to the metabolite order $ [ \\mathrm{glc}[e], \\mathrm{glc}[c], \\mathrm{pi}[c], \\mathrm{h2o}[c], \\mathrm{g6p}[c], \\mathrm{h}[c], \\mathrm{pyr}[c], \\mathrm{lac}[c], \\mathrm{co2}[c] ] $ and the reaction order $ [ R_{1}, R_{2}, R_{3}, R_{4}, R_{5}, R_{6} ] $. We translate each reaction to column entries:\n\n- $ R_{1}: \\ \\mathrm{glc}[e] \\rightarrow \\mathrm{glc}[c] $ gives $ S_{\\mathrm{glc}[e],R_{1}} = -1 $, $ S_{\\mathrm{glc}[c],R_{1}} = +1 $, all others $ 0 $.\n\n- $ R_{2}: \\ \\mathrm{glc}[c] + \\mathrm{pi}[c] \\rightarrow \\mathrm{g6p}[c] + \\mathrm{h2o}[c] $ gives $ S_{\\mathrm{glc}[c],R_{2}} = -1 $, $ S_{\\mathrm{pi}[c],R_{2}} = -1 $, $ S_{\\mathrm{g6p}[c],R_{2}} = +1 $, $ S_{\\mathrm{h2o}[c],R_{2}} = +1 $, all others $ 0 $.\n\n- $ R_{3}: \\ \\mathrm{g6p}[c] + \\mathrm{h2o}[c] \\rightarrow \\mathrm{glc}[c] + \\mathrm{pi}[c] $ gives $ S_{\\mathrm{g6p}[c],R_{3}} = -1 $, $ S_{\\mathrm{h2o}[c],R_{3}} = -1 $, $ S_{\\mathrm{glc}[c],R_{3}} = +1 $, $ S_{\\mathrm{pi}[c],R_{3}} = +1 $, all others $ 0 $.\n\n- $ R_{4}: \\ \\mathrm{pyr}[c] + 2 \\ \\mathrm{h}[c] \\rightarrow \\mathrm{lac}[c] $ gives $ S_{\\mathrm{pyr}[c],R_{4}} = -1 $, $ S_{\\mathrm{h}[c],R_{4}} = -2 $, $ S_{\\mathrm{lac}[c],R_{4}} = +1 $, all others $ 0 $.\n\n- $ R_{5}: \\ \\mathrm{pyr}[c] \\rightarrow \\mathrm{lac}[c] + \\mathrm{co2}[c] $ gives $ S_{\\mathrm{pyr}[c],R_{5}} = -1 $, $ S_{\\mathrm{lac}[c],R_{5}} = +1 $, $ S_{\\mathrm{co2}[c],R_{5}} = +1 $, all others $ 0 $.\n\n- $ R_{6}: \\ \\mathrm{glc}[e] \\rightarrow \\varnothing $ gives $ S_{\\mathrm{glc}[e],R_{6}} = -1 $, all others $ 0 $.\n\nTherefore,\n$$\nS \\ = \\\n\\begin{pmatrix}\n-1 & 0 & 0 & 0 & 0 & -1 \\\\\n+1 & -1 & +1 & 0 & 0 & 0 \\\\\n0 & -1 & +1 & 0 & 0 & 0 \\\\\n0 & +1 & -1 & 0 & 0 & 0 \\\\\n0 & +1 & -1 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & -2 & 0 & 0 \\\\\n0 & 0 & 0 & -1 & -1 & 0 \\\\\n0 & 0 & 0 & +1 & +1 & 0 \\\\\n0 & 0 & 0 & 0 & +1 & 0\n\\end{pmatrix}\n$$\nwhere rows correspond to $ [ \\mathrm{glc}[e], \\mathrm{glc}[c], \\mathrm{pi}[c], \\mathrm{h2o}[c], \\mathrm{g6p}[c], \\mathrm{h}[c], \\mathrm{pyr}[c], \\mathrm{lac}[c], \\mathrm{co2}[c] ] $ and columns to $ [ R_{1}, R_{2}, R_{3}, R_{4}, R_{5}, R_{6} ] $.\n\nStep 2: Verify elemental balance for internal reactions $ R_{1} $ through $ R_{5} $.\n\nWe use the empirical formulas:\n\n- $ \\mathrm{glc} $: $ \\mathrm{C}_{6} \\mathrm{H}_{12} \\mathrm{O}_{6} $.\n- $ \\mathrm{pi} $: $ \\mathrm{H}_{1} \\mathrm{O}_{4} \\mathrm{P}_{1} $.\n- $ \\mathrm{h2o} $: $ \\mathrm{H}_{2} \\mathrm{O}_{1} $.\n- $ \\mathrm{g6p} $: $ \\mathrm{C}_{6} \\mathrm{H}_{11} \\mathrm{O}_{9} \\mathrm{P}_{1} $.\n- $ \\mathrm{h} $: $ \\mathrm{H}_{1} $.\n- $ \\mathrm{pyr} $: $ \\mathrm{C}_{3} \\mathrm{H}_{3} \\mathrm{O}_{3} $.\n- $ \\mathrm{lac} $: $ \\mathrm{C}_{3} \\mathrm{H}_{5} \\mathrm{O}_{3} $.\n- $ \\mathrm{co2} $: $ \\mathrm{C}_{1} \\mathrm{O}_{2} $.\n\nFor each reaction, we compute total elemental counts on left-hand side (LHS) and right-hand side (RHS):\n\n- $ R_{1}: \\ \\mathrm{glc}[e] \\rightarrow \\mathrm{glc}[c] $. LHS elements: $ (\\mathrm{C}, \\mathrm{H}, \\mathrm{O}, \\mathrm{P}) = (6, 12, 6, 0) $. RHS: $ (6, 12, 6, 0) $. Balanced for all listed elements.\n\n- $ R_{2}: \\ \\mathrm{glc}[c] + \\mathrm{pi}[c] \\rightarrow \\mathrm{g6p}[c] + \\mathrm{h2o}[c] $. LHS: $ (6, 12, 6, 0) + (0, 1, 4, 1) = (6, 13, 10, 1) $. RHS: $ (6, 11, 9, 1) + (0, 2, 1, 0) = (6, 13, 10, 1) $. Balanced.\n\n- $ R_{3}: \\ \\mathrm{g6p}[c] + \\mathrm{h2o}[c] \\rightarrow \\mathrm{glc}[c] + \\mathrm{pi}[c] $. LHS: $ (6, 11, 9, 1) + (0, 2, 1, 0) = (6, 13, 10, 1) $. RHS: $ (6, 12, 6, 0) + (0, 1, 4, 1) = (6, 13, 10, 1) $. Balanced.\n\n- $ R_{4}: \\ \\mathrm{pyr}[c] + 2 \\ \\mathrm{h}[c] \\rightarrow \\mathrm{lac}[c] $. LHS: $ (3, 3, 3, 0) + 2 \\times (0, 1, 0, 0) = (3, 5, 3, 0) $. RHS: $ (3, 5, 3, 0) $. Balanced.\n\n- $ R_{5}: \\ \\mathrm{pyr}[c] \\rightarrow \\mathrm{lac}[c] + \\mathrm{co2}[c] $. LHS: $ (3, 3, 3, 0) $. RHS: $ (3, 5, 3, 0) + (1, 0, 2, 0) = (4, 5, 5, 0) $. Not balanced: the differences RHS minus LHS are $ (\\Delta \\mathrm{C}, \\Delta \\mathrm{H}, \\Delta \\mathrm{O}, \\Delta \\mathrm{P}) = (1, 2, 2, 0) \\neq (0, 0, 0, 0) $.\n\nThus, among internal reactions $ R_{1} $ through $ R_{5} $, only $ R_{5} $ is atomically imbalanced.\n\nStep 3: Verify mass balance using atomic weights.\n\nLet $ w_{\\mathrm{C}}, w_{\\mathrm{H}}, w_{\\mathrm{O}}, w_{\\mathrm{P}} > 0 $ be the atomic weights of carbon, hydrogen, oxygen, and phosphorus, respectively. For a reaction, denote by $ \\nu_{\\alpha}^{\\mathrm{LHS}} $ and $ \\nu_{\\alpha}^{\\mathrm{RHS}} $ the total counts of element $ \\alpha $ on the left and right. The mass on each side is\n$$\nM_{\\mathrm{LHS}} \\ = \\ \\sum_{\\alpha \\in \\{\\mathrm{C},\\mathrm{H},\\mathrm{O},\\mathrm{P}\\}} w_{\\alpha} \\, \\nu_{\\alpha}^{\\mathrm{LHS}}, \n\\quad\nM_{\\mathrm{RHS}} \\ = \\ \\sum_{\\alpha \\in \\{\\mathrm{C},\\mathrm{H},\\mathrm{O},\\mathrm{P}\\}} w_{\\alpha} \\, \\nu_{\\alpha}^{\\mathrm{RHS}}.\n$$\nIf a reaction is atomically balanced, then for each $ \\alpha $ we have $ \\nu_{\\alpha}^{\\mathrm{LHS}} = \\nu_{\\alpha}^{\\mathrm{RHS}} $, hence $ M_{\\mathrm{LHS}} = M_{\\mathrm{RHS}} $ by linearity. This applies to $ R_{1}, R_{2}, R_{3}, R_{4} $, confirming mass balance.\n\nFor $ R_{5} $, the net change in elemental counts is $ (\\Delta \\mathrm{C}, \\Delta \\mathrm{H}, \\Delta \\mathrm{O}, \\Delta \\mathrm{P}) = (1, 2, 2, 0) $. The mass difference (RHS minus LHS) is\n$$\n\\Delta M \\ = \\ w_{\\mathrm{C}} \\cdot 1 \\ + \\ w_{\\mathrm{H}} \\cdot 2 \\ + \\ w_{\\mathrm{O}} \\cdot 2 \\ + \\ w_{\\mathrm{P}} \\cdot 0 \\ = \\ w_{\\mathrm{C}} \\ + \\ 2 w_{\\mathrm{H}} \\ + \\ 2 w_{\\mathrm{O}}.\n$$\nSince $ w_{\\mathrm{C}}, w_{\\mathrm{H}}, w_{\\mathrm{O}} > 0 $, it follows that $ \\Delta M > 0 $, so $ R_{5} $ is not mass balanced. This is consistent with the atomic imbalance found above.\n\nStep 4: Report $ k $, the number of atomically imbalanced reactions among $ \\{ R_{1}, R_{2}, R_{3}, R_{4}, R_{5} \\} $.\n\nFrom Step 2, exactly one reaction ($ R_{5} $) is imbalanced, so $ k = 1 $.", "answer": "$$\\boxed{1}$$", "id": "3312958"}, {"introduction": "Once a model's reactions are confirmed to be mass-balanced, the next step is to diagnose its structural integrity and functional potential. A common issue in draft reconstructions is the presence of \"blocked reactions\"â€”reactions that can never carry flux under any steady-state condition because they are part of incomplete pathways. This practice [@problem_id:3312933] introduces a core technique based on Flux Variability Analysis (FVA) to systematically identify these blocked reactions, revealing which parts of your network are disconnected and require targeted curation.", "problem": "You are given a set of linear steady-state metabolic network models characterized by a stoichiometric matrix $S \\in \\mathbb{R}^{m \\times n}$, a flux vector $v \\in \\mathbb{R}^{n}$, and lower and upper bounds on each reaction flux given by $l \\in \\mathbb{R}^{n}$ and $u \\in \\mathbb{R}^{n}$. The feasible flux space is defined by the constraints $S v = 0$ and $l \\le v \\le u$. A reaction $i$ is said to be blocked if and only if for all feasible $v$, one has $v_i = 0$. Your task is to determine the set of blocked reactions for each provided test model using individual linear optimization tests per reaction: determine the maximum and minimum achievable flux for each reaction $i$ subject to $S v = 0$ and $l \\le v \\le u$. If both the maximum and minimum are numerically equal to $0$ (within a small numerical tolerance), then reaction $i$ is blocked.\n\nBase assumptions you must use:\n- The steady-state mass balance is encoded by $S v = 0$.\n- The feasible flux set is a convex polyhedron defined by linear equalities and bound constraints.\n- Determining whether a reaction $i$ is blocked can be done by solving two linear programs: maximize $v_i$ and minimize $v_i$ over the feasible set. If both optima are $0$ (within tolerance), then $v_i$ is necessarily $0$ for all feasible flux vectors.\n\nNumerical tolerance:\n- Treat any computed maximum or minimum with absolute value less than $\\epsilon$ as $0$, where $\\epsilon = 10^{-9}$.\n\nInput data (three test cases):\n\nTest case $1$:\n- $S_1 = \\begin{bmatrix} -1 & 1 & -1 \\\\ 1 & -1 & 0 \\end{bmatrix}$\n- $l_1 = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix}$, $u_1 = \\begin{bmatrix} 1000 \\\\ 1000 \\\\ 1000 \\end{bmatrix}$\n\nTest case $2$:\n- $S_2 = \\begin{bmatrix} 1 & -1 & 0 & -1 \\\\ 0 & 1 & -1 & 0 \\end{bmatrix}$\n- $l_2 = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix}$, $u_2 = \\begin{bmatrix} 10 \\\\ 10 \\\\ 10 \\\\ 0 \\end{bmatrix}$\n\nTest case $3$:\n- $S_3 = \\begin{bmatrix} -1 & 0 & 1 \\\\ 1 & -1 & 0 \\\\ 0 & 1 & -1 \\end{bmatrix}$\n- $l_3 = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix}$, $u_3 = \\begin{bmatrix} 5 \\\\ 5 \\\\ 0 \\end{bmatrix}$\n\nRequirements:\n- For each test case $k \\in \\{1, 2, 3\\}$, compute the set of indices of blocked reactions using the individual optimization tests described above.\n- Use zero-based indexing for reaction indices in the final reported lists.\n- Use the numerical tolerance $\\epsilon = 10^{-9}$ for deciding if a reaction is blocked.\n- If a linear program is infeasible for a particular objective in a given test, treat the corresponding optimum as $0$ for the purpose of the blocked-reaction test in that model.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of lists, one list per test case, enclosed in square brackets. For example: [[0,1],[2],[]].\n- Each inner list must contain the zero-based indices (integers) of the blocked reactions for that test case, in non-decreasing order.\n\nPhysical units:\n- No physical units are involved; all quantities are dimensionless real numbers.\n\nAngle unit:\n- Not applicable.\n\nPercentages:\n- Not applicable.", "solution": "The problem requires the identification of blocked reactions in several steady-state metabolic network models. A reaction is defined as blocked if its corresponding flux is zero in every possible feasible flux distribution. The determination will be accomplished using an established computational method known as Flux Variability Analysis (FVA).\n\nA metabolic network operating at steady-state is described by the linear system of equations:\n$$ S v = 0 $$\nwhere $S \\in \\mathbb{R}^{m \\times n}$ is the stoichiometric matrix for a system of $m$ metabolites and $n$ reactions, and $v \\in \\mathbb{R}^{n}$ is the vector of reaction fluxes. The fluxes are further constrained by lower and upper bounds, $l \\in \\mathbb{R}^{n}$ and $u \\in \\mathbb{R}^{n}$ respectively, such that for each reaction $i \\in \\{0, 1, \\dots, n-1\\}$:\n$$ l_i \\le v_i \\le u_i $$\nThese constraints collectively define the feasible flux space, $\\mathcal{F}$, which is a convex polyhedron in $\\mathbb{R}^n$:\n$$ \\mathcal{F} = \\{ v \\in \\mathbb{R}^n \\mid S v = 0, \\ l \\le v \\le u \\} $$\nA reaction $i$ is blocked if and only if for every feasible flux vector $v \\in \\mathcal{F}$, the $i$-th component $v_i$ is equal to $0$.\n\nTo determine if a reaction $i$ is blocked, we must find the range of values that $v_i$ can take over the entire feasible set $\\mathcal{F}$. This is achieved by solving two linear programming (LP) problems for each reaction $i$: one to find its minimum possible flux, $v_i^{\\min}$, and one to find its maximum possible flux, $v_i^{\\max}$.\n\nThe minimization problem for reaction $i$ is formulated as:\n$$ v_i^{\\min} = \\min_{v} \\ c^T v $$\nsubject to:\n$$ S v = 0 $$\n$$ l \\le v \\le u $$\nwhere the objective function vector is $c = e_i$, the $i$-th standard basis vector (a vector with $1$ at index $i$ and $0$ elsewhere).\n\nThe maximization problem for reaction $i$ is formulated as:\n$$ v_i^{\\max} = \\max_{v} \\ c^T v $$\nsubject to the same constraints. This is computationally handled as a minimization problem by negating the objective function:\n$$ v_i^{\\max} = - \\min_{v} \\ (-e_i)^T v $$\nA reaction $i$ is blocked if and only if the solution to these two problems yields $v_i^{\\min} = 0$ and $v_i^{\\max} = 0$. Due to the nature of floating-point arithmetic in numerical solvers, this condition is tested against a small tolerance $\\epsilon = 10^{-9}$. A reaction $i$ is thus classified as blocked if:\n$$ |v_i^{\\min}| < \\epsilon \\quad \\text{and} \\quad |v_i^{\\max}| < \\epsilon $$\nThe problem specifies that if any linear program is found to be infeasible (meaning the set $\\mathcal{F}$ is empty), the corresponding optimum should be treated as $0$. This implies that if a model has no feasible steady-state solution, all its reactions will be declared blocked by this procedure.\n\nLet us illustrate with Test Case 1:\n- $S_1 = \\begin{bmatrix} -1 & 1 & -1 \\\\ 1 & -1 & 0 \\end{bmatrix}$\n- $l_1 = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix}$, $u_1 = \\begin{bmatrix} 1000 \\\\ 1000 \\\\ 1000 \\end{bmatrix}$\n\nThe steady-state constraints $S_1 v = 0$ are:\n1. $-v_0 + v_1 - v_2 = 0$\n2. $v_0 - v_1 = 0$\n\nFrom equation (2), we deduce $v_0 = v_1$. Substituting this into equation (1) gives $-v_0 + v_0 - v_2 = 0$, which simplifies to $-v_2 = 0$, or $v_2 = 0$. This holds for any feasible flux vector $v \\in \\mathcal{F}$. Therefore, the flux through reaction $2$ (with zero-based index) is always zero. Its minimum and maximum achievable fluxes are both $0$, so it is a blocked reaction. For reactions $0$ and $1$, since $v_0 = v_1$ and the bounds are $0 \\le v_0 \\le 1000$ and $0 \\le v_1 \\le 1000$, the feasible flux is of the form $[a, a, 0]^T$ for any $a \\in [0, 1000]$. Thus, the flux ranges for $v_0$ and $v_1$ are $[0, 1000]$, and they are not blocked. The set of blocked reactions for this case is $\\{2\\}$.\n\nA similar analysis is applied to all three test cases. For each case, we iterate through every reaction, solve the corresponding pair of LPs using a numerical solver, and check the resulting optima against the tolerance $\\epsilon$ to identify the complete set of blocked reactions. The final implementation will use the `linprog` function from the `scipy.optimize` library to solve these optimization problems.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves the metabolic network blocked reaction problem for the three test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"S\": np.array([[-1, 1, -1], [1, -1, 0]]),\n            \"l\": np.array([0, 0, 0]),\n            \"u\": np.array([1000, 1000, 1000]),\n        },\n        {\n            \"S\": np.array([[1, -1, 0, -1], [0, 1, -1, 0]]),\n            \"l\": np.array([0, 0, 0, 0]),\n            \"u\": np.array([10, 10, 10, 0]),\n        },\n        {\n            \"S\": np.array([[-1, 0, 1], [1, -1, 0], [0, 1, -1]]),\n            \"l\": np.array([0, 0, 0]),\n            \"u\": np.array([5, 5, 0]),\n        },\n    ]\n\n    epsilon = 1e-9\n    \n    def find_blocked_reactions(S, l, u):\n        \"\"\"\n        Determines the set of blocked reactions for a given metabolic model.\n\n        A reaction i is blocked if its flux v_i must be 0 in any feasible\n        steady-state flux distribution. This is tested by minimizing and\n        maximizing v_i subject to the network constraints. If both the\n        minimum and maximum are 0 (within tolerance), the reaction is blocked.\n        \"\"\"\n        m, n = S.shape\n        b_eq = np.zeros(m)\n        bounds = [(li, ui) for li, ui in zip(l, u)]\n        \n        blocked_indices = []\n\n        for i in range(n):\n            # --- Minimize v_i ---\n            c_min = np.zeros(n)\n            c_min[i] = 1\n            res_min = linprog(c=c_min, A_eq=S, b_eq=b_eq, bounds=bounds, method='highs')\n            \n            # Per problem instructions, if LP is infeasible (status=2), treat optimum as 0.\n            # We generalize this to any non-successful termination, as this typically\n            # indicates an infeasible model for FVA-type problems.\n            if not res_min.success:\n                min_flux = 0.0\n            else:\n                min_flux = res_min.fun\n\n            # --- Maximize v_i (by minimizing -v_i) ---\n            c_max = np.zeros(n)\n            c_max[i] = -1\n            res_max = linprog(c=c_max, A_eq=S, b_eq=b_eq, bounds=bounds, method='highs')\n\n            if not res_max.success:\n                max_flux = 0.0\n            else:\n                max_flux = -res_max.fun\n\n            # --- Check blocking condition ---\n            if abs(min_flux) < epsilon and abs(max_flux) < epsilon:\n                blocked_indices.append(i)\n                \n        return blocked_indices\n\n    all_results = []\n    for case in test_cases:\n        S = case[\"S\"]\n        l = case[\"l\"]\n        u = case[\"u\"]\n        blocked = find_blocked_reactions(S, l, u)\n        all_results.append(blocked)\n\n    # Format the final output string exactly as specified.\n    # e.g., [[0,1],[2],[]]\n    formatted_strings = []\n    for sublist in all_results:\n        s = f\"[{','.join(map(str, sublist))}]\"\n        formatted_strings.append(s)\n    \n    final_output = f\"[{','.join(formatted_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3312933"}, {"introduction": "A key test of a metabolic model's predictive power is its ability to simulate known biological functions, such as cell growth. When a draft model fails this test, we must perform \"gap-filling\" to identify and add the missing biochemical knowledge. This final hands-on problem [@problem_id:3312957] simulates this crucial curation task, challenging you to implement a parsimonious gap-filling algorithm that uses Flux Balance Analysis (FBA) to find the minimal set of reactions needed to restore a desired function like biomass production.", "problem": "You are given a small steady-state metabolic network and asked to perform Flux Balance Analysis (FBA) to compute an optimal flux distribution that maximizes biomass while satisfying the mass balance constraints and flux bounds. You must also perform gap-filling by adding a minimal set of candidate reactions, if necessary, to enable a target biomass production above a given threshold. The foundational base for this task is the stoichiometric mass balance at steady state, which imposes $S v = 0$, where $S$ is the stoichiometric matrix and $v$ is the flux vector, together with reaction flux bounds $l \\le v \\le u$. Flux Balance Analysis (FBA) is a linear optimization to maximize biomass flux subject to these constraints, and gap-filling is the process of adding reactions to restore model functionality under these constraints.\n\nDefinitions and assumptions:\n- The stoichiometric matrix $S$ is defined with rows corresponding to internal metabolites and columns corresponding to reactions. Each reaction column contains stoichiometric coefficients for metabolites, with consumption as negative and production as positive.\n- Exchange reactions for metabolite uptake are represented as columns with a negative stoichiometric coefficient for the internal metabolite (for example, $EX\\_A$ has $-1$ for metabolite $A$ and $0$ elsewhere), with flux bounds set to allow uptake as negative flux: lower bound $< 0$ and upper bound $= 0$.\n- The biomass reaction is represented as a column that consumes biomass precursors. For the toy networks below, the biomass reaction consumes metabolite $C$ with stoichiometric $-1$ for $C$.\n- All fluxes must be expressed in millimoles per gram dry weight per hour, abbreviated as $mmol\\,gDW^{-1}\\,h^{-1}$. Your outputs should be rounded to four decimals.\n- Use $0$-based indexing for reaction indices.\n\nYou must implement a program that for each test case:\n1. Performs gap-filling by adding the minimal number of candidate reactions (if needed) to achieve biomass production above a threshold $\\tau$.\n2. Computes the optimal flux distribution $v^\\*$ by maximizing the biomass reaction flux under $S v = 0$ and bounds $l \\le v \\le u$ using linear programming.\n3. Verifies and returns booleans indicating whether $S v^\\* = 0$ is satisfied within a tolerance and whether bound constraints are satisfied.\n4. Returns, for each test case, a list with four entries: the optimal biomass flux (rounded to four decimals, in $mmol\\,gDW^{-1}\\,h^{-1}$), a boolean for mass balance consistency, a boolean for bounds consistency, and the list of indices of added candidate reactions (using $0$-based indexing).\n\nTest suite specification:\nAll metabolites are $A$, $B$, $C$ (three internal metabolites). For each case, the base network includes a subset of reactions with specified stoichiometries and bounds. Candidate reactions can be added during gap-filling. The biomass reaction index is always the last base reaction index in each test case.\n\n- Case $1$ (already functional network):\n  - Base reactions (columns of $S$) and bounds:\n    - $EX\\_A$: stoichiometry $[-1, 0, 0]$, bounds $[-3, 0]$.\n    - $R1$: stoichiometry $[-1, +1, 0]$, bounds $[0, 1000]$.\n    - $R2$: stoichiometry $[0, -1, +1]$, bounds $[0, 1000]$.\n    - $Biomass$: stoichiometry $[0, 0, -1]$, bounds $[0, 1000]$.\n  - Candidate reactions:\n    - $R\\_{alt}$: stoichiometry $[-1, 0, +1]$, bounds $[0, 1000]$.\n  - Biomass reaction index: $3$.\n  - Threshold $\\tau$: $2.0$.\n\n- Case $2$ (missing one reaction that must be added):\n  - Base reactions:\n    - $EX\\_A$: $[-1, 0, 0]$, bounds $[-2, 0]$.\n    - $R1$: $[-1, +1, 0]$, bounds $[0, 1000]$.\n    - $Biomass$: $[0, 0, -1]$, bounds $[0, 1000]$.\n  - Candidate reactions:\n    - $R2$: $[0, -1, +1]$, bounds $[0, 1000]$.\n  - Biomass reaction index: $2$.\n  - Threshold $\\tau$: $1.5$.\n\n- Case $3$ (requires two reactions to be added):\n  - Base reactions:\n    - $EX\\_A$: $[-1, 0, 0]$, bounds $[-1.5, 0]$.\n    - $Biomass$: $[0, 0, -1]$, bounds $[0, 1000]$.\n  - Candidate reactions:\n    - $R1$: $[-1, +1, 0]$, bounds $[0, 1000]$.\n    - $R2$: $[0, -1, +1]$, bounds $[0, 1000]$.\n  - Biomass reaction index: $1$.\n  - Threshold $\\tau$: $1.0$.\n\n- Case $4$ (boundary case with no uptake allowed; growth impossible):\n  - Base reactions:\n    - $EX\\_A$: $[-1, 0, 0]$, bounds $[0, 0]$.\n    - $R1$: $[-1, +1, 0]$, bounds $[0, 1000]$.\n    - $R2$: $[0, -1, +1]$, bounds $[0, 1000]$.\n    - $Biomass$: $[0, 0, -1]$, bounds $[0, 1000]$.\n  - Candidate reactions: none.\n  - Biomass reaction index: $3$.\n  - Threshold $\\tau$: $0.1$.\n\nAlgorithmic requirements:\n- Formulate FBA as a linear program that maximizes the biomass flux subject to $S v = 0$ and $l \\le v \\le u$. You must not use any shortcuts beyond linear programming and must ensure numerical stability.\n- For gap-filling, search over subsets of candidate reactions in increasing cardinality to find the smallest set that enables an optimal biomass flux strictly greater than the threshold $\\tau$. If multiple subsets of the same cardinality satisfy the threshold, choose the one that yields the highest optimal biomass flux. If no subset satisfies the threshold, select the empty subset and compute the optimal flux distribution for the base network only.\n- Verify consistency with the constraints by computing the infinity norm of the mass balance residual $||S v^\\*||_\\infty$ and checking it is below a tolerance of $10^{-8}$. Also verify all bounds are satisfied within a tolerance of $10^{-8}$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each test case result itself encoded as a list: $[biomass,mb\\_ok,bounds\\_ok,[added\\_indices]]$. For example: $[[3.0000,True,True,[]],[2.0000,True,True,[0]],...]$. All flux values must be in $mmol\\,gDW^{-1}\\,h^{-1}$ and rounded to four decimals. The booleans must be exact logical values. The list of added indices must use $0$-based indexing.", "solution": "The problem requires the implementation of two fundamental algorithms in computational systems biology: Flux Balance Analysis (FBA) and model gap-filling. The goal is to determine the optimal metabolic flux distribution for a given network that maximizes biomass production, potentially after augmenting the network with a minimal set of reactions from a candidate pool to meet a specified production threshold.\n\n### Principle 1: Mass Balance and Steady State\n\nAt the core of FBA is the principle of mass conservation. For a metabolic network operating at a steady state, the concentration of each internal metabolite remains constant. This implies that for each metabolite, the total rate of production must equal the total rate of consumption. This constraint can be expressed mathematically as a system of linear equations:\n$$\nS v = 0\n$$\nwhere $S$ is the stoichiometric matrix of size $m \\times n$ ($m$ metabolites, $n$ reactions), and $v$ is the vector of reaction fluxes (rates) of size $n \\times 1$. Each entry $S_{ij}$ in the matrix represents the stoichiometric coefficient of metabolite $i$ in reaction $j$. By convention, a negative coefficient ($S_{ij} < 0$) signifies consumption, and a positive coefficient ($S_{ij} > 0$) signifies production. The vector equation $S v = 0$ ensures that there is no net accumulation or depletion of any internal metabolite.\n\n### Principle 2: Flux Balance Analysis (FBA) as Linear Programming\n\nWhile the steady-state assumption constrains the possible flux distributions, it does not typically define a unique solution. The space of feasible flux vectors satisfying $S v = 0$ is further constrained by thermodynamic and capacity limitations, which are represented as lower and upper bounds on individual fluxes:\n$$\nl \\le v \\le u\n$$\nwhere $l$ and $u$ are vectors of lower and upper bounds, respectively. For instance, an irreversible reaction has a lower bound of $0$. An exchange reaction allowing uptake of a nutrient from the environment will have a negative lower bound (e.g., $v_{uptake} \\in [-10, 0]$).\n\nFBA uses linear programming (LP) to find a specific, biologically meaningful flux distribution from the feasible set. This is achieved by optimizing an objective function, which is typically the flux of a \"biomass reaction\". This reaction is a modeling construct that simulates the production of cellular biomass by consuming precursor metabolites in ratios derived from experimental measurements. Maximizing its flux is assumed to be equivalent to the organism's growth rate.\n\nThe FBA problem is therefore formulated as the following LP:\n$$\n\\begin{align*}\n\\text{maximize} \\quad & c^T v \\\\\n\\text{subject to} \\quad & S v = 0 \\\\\n& l \\le v \\le u\n\\end{align*}\n$$\nHere, $c$ is the objective vector, which contains a $1$ at the position corresponding to the biomass reaction and $0$s elsewhere.\n\n### Principle 3: Model Gap-Filling\n\nMetabolic network reconstructions from genomic data are often incomplete, containing \"gaps\" (missing reactions) that prevent the model from simulating known biological functions, such as producing biomass. Gap-filling is the computational process of identifying a minimal set of reactions from a universal database (or a specified candidate pool) to add to the model to restore the desired functionality.\n\nThis problem can be framed as a combinatorial optimization problem. We seek the smallest subset of candidate reactions that, when added to the base model, allows the biomass flux to exceed a given threshold, $\\tau$. The algorithmic approach specified in the problem is a systematic search based on the principle of parsimony (minimality):\n\n1.  Search over the cardinality of the added reaction set, $k$, starting from $k=0$.\n2.  For a given $k$, test all possible combinations of $k$ reactions from the candidate pool.\n3.  For each combination, augment the base model with the chosen reactions and perform FBA to calculate the maximum biomass flux.\n4.  If the biomass flux from any combination exceeds $\\tau$, then $k$ is the minimal cardinality. The search stops, and among all successful combinations of size $k$, the one yielding the highest biomass flux is chosen.\n5.  If no combination for any $k$ satisfies the condition, the original, un-augmented base model is used.\n\n### Algorithmic Implementation\n\nThe solution is implemented by combining these principles into a coherent algorithm.\n\n1.  **FBA Solver**: A core function is created to solve the FBA linear program. It takes a stoichiometric matrix $S$, bounds vectors $l$ and $u$, and the index of the biomass reaction as input. Using the `scipy.optimize.linprog` library function, it formulates and solves the LP. The objective function is set to minimize $-v_{biomass}$ to achieve maximization. The function returns the optimal biomass flux and the corresponding full flux vector $v^*$.\n\n2.  **Gap-Filling Procedure**: For each test case, the gap-filling logic is executed.\n    - The algorithm first analyzes the base network (cardinality $k=0$). It runs the FBA solver and stores the resulting biomass flux and flux vector.\n    - It checks if this base-case biomass flux is greater than the threshold $\\tau$. If it is, the problem is solved, as the minimal set of added reactions is the empty set.\n    - If the threshold is not met, the algorithm proceeds to search for minimal non-empty sets. It iterates through cardinalities $k=1, 2, \\dots$ up to the total number of candidate reactions. For each $k$, `itertools.combinations` is used to generate all unique subsets of candidate reactions of that size.\n    - For each subset, a temporary new model is constructed by augmenting the base $S$ matrix and bounds vectors with those of the selected candidates. The FBA solver is then called on this temporary model.\n    - If the resulting biomass flux exceeds $\\tau$, the result (biomass value, flux vector, and indices of added reactions) is stored.\n    - After all combinations for a given $k$ are tested, if any have satisfied the threshold, the one yielding the maximum biomass is selected as the final solution, and the search terminates. This adheres to the dual criteria of minimal cardinality first, then maximal objective.\n    - If the search over all $k$ completes with no solution found, the initial result from the base network is retained as the final answer.\n\n3.  **Verification and Output**: Once the optimal configuration (base or gap-filled) and its corresponding flux vector $v^*$ are determined, two verification checks are performed as required.\n    - The mass balance constraint is verified by calculating the residual vector $Sv^*$ and checking if its infinity norm, $||Sv^*||_\\infty$, is less than the tolerance $10^{-8}$.\n    - The bounds constraints are verified by checking that each flux $v_i^*$ lies within its corresponding bounds $[l_i, u_i]$, allowing for the same numerical tolerance of $10^{-8}$.\n    - The final result for each case, containing the rounded optimal biomass, the two boolean verification flags, and the sorted list of added candidate indices, is collected. The final output is formatted into the specified string representation.", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\nfrom itertools import combinations\n\nclass FormattedFloat:\n    \"\"\"A wrapper for floats to control their string representation for printing.\"\"\"\n    def __init__(self, value, precision=4):\n        self.value = value\n        self.precision = precision\n\n    def __repr__(self):\n        return f\"{self.value:.{self.precision}f}\"\n\ndef solve():\n    \"\"\"\n    Main function to define, solve, and format the results for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1: Functional network\n        {\n            \"base_reactions\": {\n                \"stoichiometry\": [[-1, -1, 0, 0], [0, 1, -1, 0], [0, 0, 1, -1]],\n                \"bounds\": [(-3, 0), (0, 1000), (0, 1000), (0, 1000)]\n            },\n            \"candidate_reactions\": {\n                \"stoichiometry\": [[-1], [0], [1]],\n                \"bounds\": [(0, 1000)]\n            },\n            \"biomass_idx\": 3,\n            \"tau\": 2.0\n        },\n        # Case 2: Missing one reaction\n        {\n            \"base_reactions\": {\n                \"stoichiometry\": [[-1, -1, 0], [0, 1, 0], [0, 0, -1]],\n                \"bounds\": [(-2, 0), (0, 1000), (0, 1000)]\n            },\n            \"candidate_reactions\": {\n                \"stoichiometry\": [[0], [-1], [1]],\n                \"bounds\": [(0, 1000)]\n            },\n            \"biomass_idx\": 2,\n            \"tau\": 1.5\n        },\n        # Case 3: Requires two reactions\n        {\n            \"base_reactions\": {\n                \"stoichiometry\": [[-1, 0], [0, 0], [0, -1]],\n                \"bounds\": [(-1.5, 0), (0, 1000)]\n            },\n            \"candidate_reactions\": {\n                \"stoichiometry\": [[-1, 0], [1, -1], [0, 1]],\n                \"bounds\": [(0, 1000), (0, 1000)]\n            },\n            \"biomass_idx\": 1,\n            \"tau\": 1.0\n        },\n        # Case 4: No uptake, no growth\n        {\n            \"base_reactions\": {\n                \"stoichiometry\": [[-1, -1, 0, 0], [0, 1, -1, 0], [0, 0, 1, -1]],\n                \"bounds\": [(0, 0), (0, 1000), (0, 1000), (0, 1000)]\n            },\n            \"candidate_reactions\": None,\n            \"biomass_idx\": 3,\n            \"tau\": 0.1\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _process_case(case)\n        results.append(result)\n\n    # Format the final output string exactly as required\n    result_strings = []\n    for r in results:\n        # Use FormattedFloat for custom number formatting within the list structure\n        r[0] = FormattedFloat(r[0])\n        result_strings.append(str(r).replace(\"'\", \"\").replace(\" \", \"\"))\n    \n    print(f\"[{','.join(result_strings)}]\")\n\ndef _run_fba(S, bounds, obj_idx):\n    \"\"\"Performs Flux Balance Analysis using linear programming.\"\"\"\n    num_rxns = S.shape[1]\n    # Objective: maximize flux through obj_idx, which is min(-flux)\n    c = np.zeros(num_rxns)\n    c[obj_idx] = -1\n    \n    A_eq = S\n    b_eq = np.zeros(S.shape[0])\n    \n    res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n    \n    if res.success:\n        # Return positive biomass flux and the full flux vector\n        return -res.fun, res.x\n    else:\n        # If optimization fails, assume zero flux\n        return 0.0, np.zeros(num_rxns)\n\ndef _process_case(case_data):\n    \"\"\"\n    Handles gap-filling and FBA for a single test case.\n    \"\"\"\n    base_stoichiometry = np.array(case_data[\"base_reactions\"][\"stoichiometry\"], dtype=float)\n    base_bounds = case_data[\"base_reactions\"][\"bounds\"]\n    \n    if case_data[\"candidate_reactions\"]:\n        candidate_stoichiometry = np.array(case_data[\"candidate_reactions\"][\"stoichiometry\"], dtype=float)\n        candidate_bounds = case_data[\"candidate_reactions\"][\"bounds\"]\n        num_candidates = candidate_stoichiometry.shape[1]\n    else:\n        candidate_stoichiometry = np.empty((base_stoichiometry.shape[0], 0))\n        candidate_bounds = []\n        num_candidates = 0\n\n    biomass_idx = case_data[\"biomass_idx\"]\n    tau = case_data[\"tau\"]\n    \n    # 1. Analyze the base network (k=0)\n    base_biomass, base_v = _run_fba(base_stoichiometry, base_bounds, biomass_idx)\n    \n    best_result = {\n        \"biomass\": base_biomass,\n        \"v\": base_v,\n        \"added_indices\": [],\n        \"S\": base_stoichiometry,\n        \"bounds\": base_bounds\n    }\n\n    # If base network is sufficient, we are done with gap-filling\n    if base_biomass > tau + 1e-9:\n        pass\n    else:\n        # 2. Perform gap-filling for k=1, 2, ...\n        for k in range(1, num_candidates + 1):\n            candidate_indices_combinations = combinations(range(num_candidates), k)\n            solutions_at_k = []\n            \n            for combo_indices in candidate_indices_combinations:\n                added_S = candidate_stoichiometry[:, combo_indices]\n                added_bounds = [candidate_bounds[i] for i in combo_indices]\n                \n                S_new = np.hstack((base_stoichiometry, added_S))\n                bounds_new = base_bounds + added_bounds\n                \n                # Biomass index is unchanged as candidates are appended\n                biomass, v = _run_fba(S_new, bounds_new, biomass_idx)\n                \n                if biomass > tau + 1e-9:\n                    solutions_at_k.append({\n                        \"biomass\": biomass,\n                        \"v\": v,\n                        \"added_indices\": list(combo_indices),\n                        \"S\": S_new,\n                        \"bounds\": bounds_new\n                    })\n            \n            if solutions_at_k:\n                # Minimal set size k found. Select the best among them.\n                best_at_k = max(solutions_at_k, key=lambda x: x[\"biomass\"])\n                best_result = best_at_k\n                break  # Exit search since minimal k is found\n    \n    # 3. Verification of the final chosen solution\n    final_S = best_result[\"S\"]\n    final_v = best_result[\"v\"]\n    final_bounds = best_result[\"bounds\"]\n    \n    # Mass balance check: ||S*v||_inf < tol\n    mass_balance_residual = final_S @ final_v\n    mb_ok = np.all(np.abs(mass_balance_residual) < 1e-8)\n    \n    # Bounds check: l - tol <= v <= u + tol\n    bounds_ok = True\n    for i, flux in enumerate(final_v):\n        lb, ub = final_bounds[i]\n        if lb is not None and flux < lb - 1e-8:\n            bounds_ok = False\n            break\n        if ub is not None and flux > ub + 1e-8:\n            bounds_ok = False\n            break\n    \n    # 4. Format and return the result for this case\n    return [\n        best_result[\"biomass\"],\n        mb_ok,\n        bounds_ok,\n        sorted(best_result[\"added_indices\"])\n    ]\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3312957"}]}