{"hands_on_practices": [{"introduction": "A foundational step in constructing any whole-cell model is to account for the cell's energy budget. This practice challenges you to apply the principle of steady-state mass balance to calculate the minimal ATP production flux required to sustain a minimal cell's core functions. By systematically summing the energetic costs of transcription, translation, and transport, you will develop a concrete understanding of how cellular resources are allocated and build a quantitative framework for analyzing cellular bioenergetics [@problem_id:3358581].", "problem": "A minimal whole-cell model is considered under balanced exponential growth in which the intracellular adenosine triphosphate (ATP) pool is at steady state. Use a mass-balance formulation on ATP grounded in conservation of mass and the definition of balanced growth: at steady state, the time derivative of intracellular ATP amount is zero, so ATP production must equal the sum of ATP consumption by cellular processes plus the dilution of the intracellular ATP pool due to growth. The cell executes the following processes at specified rates: ribonucleic acid (RNA) transcription, protein translation, and active transport of two solutes. The fundamental energetic assumptions are that transcription consumes one nucleoside triphosphate per nucleotide incorporated; that the energetic cost of any nucleoside triphosphate (ATP, guanosine triphosphate (GTP), uridine triphosphate, cytidine triphosphate) can be expressed in ATP equivalents at a one-to-one cost via nucleoside diphosphate kinase (NDPK) and associated phosphorylation reactions; that aminoacyl-tRNA charging costs two ATP equivalents per amino acid incorporated (ATP to adenosine monophosphate counts as two high-energy phosphate bonds); and that during translation, each peptide bond formation consumes two GTP, while each initiation event consumes one GTP, all counted as ATP equivalents at 1:1 cost via NDPK. Active transport of each solute consumes a fixed number of ATP molecules per solute translocated. The dilution term arises from exponential growth at specific growth rate $\\mu$ acting on the intracellular ATP amount, which is the product of the ATP concentration and the cell volume.\n\nParameters:\n- Specific growth rate $\\mu = 1.00 \\times 10^{-4}\\ \\mathrm{s^{-1}}$.\n- Intracellular ATP concentration $C_{\\mathrm{ATP}} = 3.00 \\times 10^{-3}\\ \\mathrm{mol\\ L^{-1}}$.\n- Cell volume $V_{\\mathrm{cell}} = 1.00 \\times 10^{-15}\\ \\mathrm{L}$.\n- Total transcription elongation rate (nucleotides incorporated per second across the genome) $R_{\\mathrm{nt}} = 1.20 \\times 10^{5}\\ \\mathrm{s^{-1}}$; assume a cost of $1$ ATP equivalent per nucleotide incorporated.\n- Total translation elongation rate (amino acids incorporated per second across all ribosomes) $R_{\\mathrm{aa}} = 5.00 \\times 10^{4}\\ \\mathrm{s^{-1}}$.\n- Polypeptide initiation events per second $R_{\\mathrm{init}} = 2.00 \\times 10^{2}\\ \\mathrm{s^{-1}}$; assume $2$ GTP per peptide bond and $1$ GTP per initiation, all counted as ATP equivalents at $1:1$ cost via NDPK.\n- Active transport fluxes: solute A imported at $R_{A} = 8.00 \\times 10^{4}\\ \\mathrm{s^{-1}}$ with a cost of $1$ ATP per molecule; solute B imported at $R_{B} = 2.00 \\times 10^{4}\\ \\mathrm{s^{-1}}$ with a cost of $1$ ATP per molecule.\n- Avogadro’s constant $N_{\\mathrm{A}} = 6.022 \\times 10^{23}\\ \\mathrm{mol^{-1}}$.\n\nUsing only the principles of steady-state mass balance and the above stoichiometric ATP equivalent costs, compute the minimal ATP production flux $J_{\\mathrm{ATP}}^{\\min}$ required to sustain these processes at steady state, including dilution. Express $J_{\\mathrm{ATP}}^{\\min}$ in $\\mathrm{mol\\ s^{-1}}$ per cell, and round your answer to four significant figures.", "solution": "The core of this problem rests on the principle of mass balance for the intracellular ATP pool at steady state. Under the condition of balanced exponential growth, the time derivative of the total amount of ATP in the cell, $N_{\\mathrm{ATP}}$, is zero. The mass balance equation is:\n$$\n\\frac{dN_{\\mathrm{ATP}}}{dt} = J_{\\mathrm{ATP}}^{\\mathrm{prod}} - J_{\\mathrm{ATP}}^{\\mathrm{cons}} - J_{\\mathrm{ATP}}^{\\mathrm{dilution}} = 0\n$$\nwhere $J_{\\mathrm{ATP}}^{\\mathrm{prod}}$ is the rate of ATP production, $J_{\\mathrm{ATP}}^{\\mathrm{cons}}$ is the rate of ATP consumption by cellular processes, and $J_{\\mathrm{ATP}}^{\\mathrm{dilution}}$ is the rate of ATP dilution due to the increase in cell volume during growth. All fluxes are in units of $\\mathrm{mol\\ s^{-1}}$. The problem asks for the minimal ATP production flux, $J_{\\mathrm{ATP}}^{\\min}$, which is the rate required to balance the sinks:\n$$\nJ_{\\mathrm{ATP}}^{\\min} = J_{\\mathrm{ATP}}^{\\mathrm{cons}} + J_{\\mathrm{ATP}}^{\\mathrm{dilution}}\n$$\nWe will calculate each term on the right-hand side separately.\n\nFirst, we calculate the total consumption flux, $J_{\\mathrm{ATP}}^{\\mathrm{cons}}$. This is the sum of ATP consumed by transcription, translation, and active transport. The rates are given in events per second (e.g., nucleotides per second). We will first calculate the total consumption rate in molecules of ATP per second, denoted $R_{\\mathrm{ATP}}^{\\mathrm{cons}}$, and then convert it to a molar flux using Avogadro's constant, $N_{\\mathrm{A}}$.\n$$\nJ_{\\mathrm{ATP}}^{\\mathrm{cons}} = \\frac{R_{\\mathrm{ATP}}^{\\mathrm{cons}}}{N_{\\mathrm{A}}}\n$$\nThe total rate $R_{\\mathrm{ATP}}^{\\mathrm{cons}}$ is the sum of the rates for each process:\n$$\nR_{\\mathrm{ATP}}^{\\mathrm{cons}} = R_{\\mathrm{ATP}}^{\\mathrm{transcription}} + R_{\\mathrm{ATP}}^{\\mathrm{translation}} + R_{\\mathrm{ATP}}^{\\mathrm{transport}}\n$$\n1.  **Transcription consumption rate ($R_{\\mathrm{ATP}}^{\\mathrm{transcription}}$)**: The cost is $1$ ATP equivalent per nucleotide incorporated.\n    $$\n    R_{\\mathrm{ATP}}^{\\mathrm{transcription}} = R_{\\mathrm{nt}} \\times 1 = 1.20 \\times 10^{5}\\ \\mathrm{s^{-1}}\n    $$\n2.  **Translation consumption rate ($R_{\\mathrm{ATP}}^{\\mathrm{translation}}$)**: This cost includes three parts: aminoacyl-tRNA charging ($2$ ATP per amino acid), initiation ($1$ ATP equivalent per event), and peptide bond formation/elongation ($2$ ATP equivalents per amino acid).\n    $$\n    R_{\\mathrm{ATP}}^{\\mathrm{translation}} = (R_{\\mathrm{aa}} \\times 2) + (R_{\\mathrm{init}} \\times 1) + (R_{\\mathrm{aa}} \\times 2) = 4 R_{\\mathrm{aa}} + R_{\\mathrm{init}}\n    $$\n    Substituting the given values:\n    $$\n    R_{\\mathrm{ATP}}^{\\mathrm{translation}} = 4 \\times (5.00 \\times 10^{4}\\ \\mathrm{s^{-1}}) + (2.00 \\times 10^{2}\\ \\mathrm{s^{-1}}) = 2.00 \\times 10^{5}\\ \\mathrm{s^{-1}} + 200\\ \\mathrm{s^{-1}} = 2.002 \\times 10^{5}\\ \\mathrm{s^{-1}}\n    $$\n3.  **Transport consumption rate ($R_{\\mathrm{ATP}}^{\\mathrm{transport}}$)**: This is the sum of costs for transporting solutes A and B. Both have a cost of $1$ ATP per molecule.\n    $$\n    R_{\\mathrm{ATP}}^{\\mathrm{transport}} = (R_{A} \\times 1) + (R_{B} \\times 1) = R_{A} + R_{B}\n    $$\n    Substituting the given values:\n    $$\n    R_{\\mathrm{ATP}}^{\\mathrm{transport}} = (8.00 \\times 10^{4}\\ \\mathrm{s^{-1}}) + (2.00 \\times 10^{4}\\ \\mathrm{s^{-1}}) = 1.00 \\times 10^{5}\\ \\mathrm{s^{-1}}\n    $$\nNow, we sum these rates to get the total consumption rate in molecules per second:\n$$\nR_{\\mathrm{ATP}}^{\\mathrm{cons}} = (1.20 \\times 10^{5}) + (2.002 \\times 10^{5}) + (1.00 \\times 10^{5}) = 4.202 \\times 10^{5}\\ \\mathrm{s^{-1}}\n$$\nThe consumption flux in moles per second is:\n$$\nJ_{\\mathrm{ATP}}^{\\mathrm{cons}} = \\frac{4.202 \\times 10^{5}\\ \\mathrm{s^{-1}}}{N_{\\mathrm{A}}} = \\frac{4.202 \\times 10^{5}}{6.022 \\times 10^{23}}\\ \\mathrm{mol\\ s^{-1}}\n$$\n\nNext, we calculate the dilution flux, $J_{\\mathrm{ATP}}^{\\mathrm{dilution}}$. This flux arises because the total amount of ATP, $N_{\\mathrm{ATP}}$, is diluted into a larger volume as the cell grows. The rate of dilution is given by the product of the specific growth rate $\\mu$ and the amount of ATP.\n$$\nJ_{\\mathrm{ATP}}^{\\mathrm{dilution}} = \\mu \\cdot N_{\\mathrm{ATP}}\n$$\nThe amount of ATP in the cell, $N_{\\mathrm{ATP}}$, is the product of its concentration, $C_{\\mathrm{ATP}}$, and the cell volume, $V_{\\mathrm{cell}}$.\n$$\nN_{\\mathrm{ATP}} = C_{\\mathrm{ATP}} \\cdot V_{\\mathrm{cell}} = (3.00 \\times 10^{-3}\\ \\mathrm{mol\\ L^{-1}}) \\times (1.00 \\times 10^{-15}\\ \\mathrm{L}) = 3.00 \\times 10^{-18}\\ \\mathrm{mol}\n$$\nNow, we can calculate the dilution flux:\n$$\nJ_{\\mathrm{ATP}}^{\\mathrm{dilution}} = \\mu \\cdot N_{\\mathrm{ATP}} = (1.00 \\times 10^{-4}\\ \\mathrm{s^{-1}}) \\times (3.00 \\times 10^{-18}\\ \\mathrm{mol}) = 3.00 \\times 10^{-22}\\ \\mathrm{mol\\ s^{-1}}\n$$\n\nFinally, we compute the minimal total ATP production flux, $J_{\\mathrm{ATP}}^{\\min}$, by summing the consumption and dilution fluxes:\n$$\nJ_{\\mathrm{ATP}}^{\\min} = J_{\\mathrm{ATP}}^{\\mathrm{cons}} + J_{\\mathrm{ATP}}^{\\mathrm{dilution}} = \\frac{4.202 \\times 10^{5}}{6.022 \\times 10^{23}}\\ \\mathrm{mol\\ s^{-1}} + 3.00 \\times 10^{-22}\\ \\mathrm{mol\\ s^{-1}}\n$$\nCalculating the numerical values:\n$$\nJ_{\\mathrm{ATP}}^{\\mathrm{cons}} \\approx 6.977748 \\times 10^{-19}\\ \\mathrm{mol\\ s^{-1}}\n$$\n$$\nJ_{\\mathrm{ATP}}^{\\min} \\approx (6.977748 \\times 10^{-19}) + (3.00 \\times 10^{-22})\\ \\mathrm{mol\\ s^{-1}}\n$$\nTo add these numbers, we adjust the exponent of the smaller term:\n$$\nJ_{\\mathrm{ATP}}^{\\min} \\approx (6.977748 \\times 10^{-19}) + (0.00300 \\times 10^{-19})\\ \\mathrm{mol\\ s^{-1}} = 6.980748 \\times 10^{-19}\\ \\mathrm{mol\\ s^{-1}}\n$$\nThe problem requires the answer to be rounded to four significant figures.\n$$\nJ_{\\mathrm{ATP}}^{\\min} \\approx 6.981 \\times 10^{-19}\\ \\mathrm{mol\\ s^{-1}}\n$$\nThe final symbolic expression for the required flux is:\n$$\nJ_{\\mathrm{ATP}}^{\\min} = \\frac{R_{\\mathrm{nt}} + 4R_{\\mathrm{aa}} + R_{\\mathrm{init}} + R_{A} + R_{B}}{N_{\\mathrm{A}}} + \\mu C_{\\mathrm{ATP}} V_{\\mathrm{cell}}\n$$\nPlugging in all values leads to the calculated result.", "answer": "$$\n\\boxed{6.981 \\times 10^{-19}}\n$$", "id": "3358581"}, {"introduction": "Moving from static budgets to dynamic behavior, we now explore how a minimal cell responds to environmental perturbations over time. This practice guides you through deriving a dynamic model of osmotic regulation from first principles, coupling water flow, solute transport, and cell geometry into a system of ordinary differential equations. By simulating a cell's response to osmotic shock and evaluating its survival against physical limits, you will gain hands-on experience in building and analyzing predictive biophysical models of cellular physiology [@problem_id:3358577].", "problem": "Model osmotic regulation in a minimal spherical cell by coupling membrane transport kinetics and water flow to cell volume dynamics and turgor pressure. Use the following foundational relations and definitions as the starting point: conservation of mass for the intracellular solute, van’t Hoff osmotic pressure, and kinematic relations for a sphere. Do not assume any shortcuts beyond these. Let the cell be initially isotonic at $t=0^{-}$ and subjected at $t=0^{+}$ to an external osmotic step change. The target is to determine viability under the shock over a finite horizon.\n\nFoundational base to use:\n- Membrane solute flux per unit area: $J_{s} = P\\left(C_{\\text{out}} - C_{\\text{in}}\\right)$, where $P$ is the solute permeability (units $\\mathrm{m\\,s^{-1}}$), $C_{\\text{out}}$ is the external solute concentration (units $\\mathrm{mol\\,m^{-3}}$), and $C_{\\text{in}}$ is the internal solute concentration (units $\\mathrm{mol\\,m^{-3}}$).\n- Van’t Hoff law for osmotic pressure difference: $\\Delta \\pi = R T \\left(C_{\\text{in}} - C_{\\text{out}}\\right)$, where $R$ is the universal gas constant (units $\\mathrm{J\\,mol^{-1}\\,K^{-1}}$) and $T$ is the absolute temperature (units $\\mathrm{K}$).\n- Volumetric water flux law: $\\dfrac{dV}{dt} = L_{p} A(V)\\, \\Delta \\pi$, where $L_{p}$ is the hydraulic permeability (units $\\mathrm{m\\,Pa^{-1}\\,s^{-1}}$), $A(V)$ is the membrane area (units $\\mathrm{m^{2}}$), and $V$ is the cell volume (units $\\mathrm{m^{3}}$).\n- Spherical geometry relating area and volume: $A(V) = \\left(36\\pi\\right)^{1/3} V^{2/3}$.\n\nDerive, from these bases and conservation of intracellular solute, the coupled ordinary differential equations (ODEs) for $V(t)$ and $C_{\\text{in}}(t)$ when the external concentration is stepped at $t=0^{+}$ from $C_{\\text{out},0}$ to a new constant $C_{\\text{out,shock}}$. The internal mole quantity is $N(t) = C_{\\text{in}}(t)\\,V(t)$, and conservation gives $\\dfrac{dN}{dt} = J_{s}\\,A(V)$. Turgor pressure is defined here as $P_{\\text{turgor}}(t) = R T \\left(C_{\\text{in}}(t) - C_{\\text{out}}(t)\\right)$.\n\nViability criterion over a finite horizon: the cell is viable if and only if, for all $t \\in [0, t_{\\text{end}}]$, both of the following hold:\n1. Membrane area does not exceed its lytic limit: $A\\left(V(t)\\right) \\le A_{\\max}$, where $A_{0} = A\\left(V_{0}\\right)$ is the initial area and $A_{\\max} = A_{0}\\left(1 + \\varepsilon_{\\max}\\right)$. Here $\\varepsilon_{\\max}$ is the maximum allowable fractional area expansion (dimensionless).\n2. Volume does not fall below its functional minimum: $V(t) \\ge V_{\\min}$, where $V_{\\min} = V_{0}\\left(1 - \\phi_{\\min}\\right)$ and $\\phi_{\\min}$ is the maximum allowable fractional volume loss (dimensionless).\n\nInitial conditions at $t=0$: $V(0) = V_{0}$ and $C_{\\text{in}}(0) = C_{\\text{out},0}$.\n\nImplement the derived ODEs for a step change $C_{\\text{out}}(t) = C_{\\text{out,shock}}$ for $t \\ge 0$. Use a numerically stable integrator over $[0, t_{\\text{end}}]$ with event detection for the two viability conditions to stop integration immediately if a violation occurs. Assume a single neutral solute, no active transport, constant $P$, constant $L_{p}$, constant $T$, and spherical geometry throughout. Report boolean viability for each test case, where $true$ indicates the cell remained within the viability bounds throughout $[0, t_{\\text{end}}]$ and $false$ indicates a violation occurred.\n\nPhysical units to use in all parameters:\n- Concentrations in $\\mathrm{mol\\,m^{-3}}$ (note: $1\\,\\mathrm{mol\\,m^{-3}}$ equals $1\\,\\mathrm{mM}$).\n- Volume in $\\mathrm{m^{3}}$.\n- Area in $\\mathrm{m^{2}}$.\n- Permeability $P$ in $\\mathrm{m\\,s^{-1}}$.\n- Hydraulic permeability $L_{p}$ in $\\mathrm{m\\,Pa^{-1}\\,s^{-1}}$.\n- Temperature $T$ in $\\mathrm{K}$.\n- Gas constant $R$ in $\\mathrm{J\\,mol^{-1}\\,K^{-1}}$.\n- Time in $\\mathrm{s}$.\n- Fractional limits $\\varepsilon_{\\max}$ and $\\phi_{\\min}$ are dimensionless.\n\nTest suite specification. For all cases below, use $R = 8.314\\,\\mathrm{J\\,mol^{-1}\\,K^{-1}}$ and initial external concentration $C_{\\text{out},0}$ equal to the initial internal concentration. Each test case is an ordered tuple $(V_{0}, C_{\\text{out},0}, C_{\\text{out,shock}}, P, L_{p}, T, t_{\\text{end}}, \\varepsilon_{\\max}, \\phi_{\\min})$:\n- Case $1$ (happy path, mild hypotonic shock): $\\left(1.0\\times 10^{-18}\\,\\mathrm{m^{3}},\\,300\\,\\mathrm{mol\\,m^{-3}},\\,200\\,\\mathrm{mol\\,m^{-3}},\\,1.0\\times 10^{-8}\\,\\mathrm{m\\,s^{-1}},\\,5.0\\times 10^{-15}\\,\\mathrm{m\\,Pa^{-1}\\,s^{-1}},\\,310\\,\\mathrm{K},\\,100\\,\\mathrm{s},\\,0.04,\\,0.40\\right)$.\n- Case $2$ (severe hypotonic shock with high water permeability; likely lysis boundary): $\\left(1.0\\times 10^{-18}\\,\\mathrm{m^{3}},\\,300\\,\\mathrm{mol\\,m^{-3}},\\,50\\,\\mathrm{mol\\,m^{-3}},\\,1.0\\times 10^{-8}\\,\\mathrm{m\\,s^{-1}},\\,2.0\\times 10^{-14}\\,\\mathrm{m\\,Pa^{-1}\\,s^{-1}},\\,310\\,\\mathrm{K},\\,50\\,\\mathrm{s},\\,0.04,\\,0.40\\right)$.\n- Case $3$ (strong hypertonic shock with slow solute permeability; likely shrinkage boundary): $\\left(1.0\\times 10^{-18}\\,\\mathrm{m^{3}},\\,300\\,\\mathrm{mol\\,m^{-3}},\\,900\\,\\mathrm{mol\\,m^{-3}},\\,1.0\\times 10^{-9}\\,\\mathrm{m\\,s^{-1}},\\,1.0\\times 10^{-14}\\,\\mathrm{m\\,Pa^{-1}\\,s^{-1}},\\,310\\,\\mathrm{K},\\,100\\,\\mathrm{s},\\,0.04,\\,0.40\\right)$.\n- Case $4$ (strong hypertonic shock with high solute permeability; potential recovery): $\\left(1.0\\times 10^{-18}\\,\\mathrm{m^{3}},\\,300\\,\\mathrm{mol\\,m^{-3}},\\,900\\,\\mathrm{mol\\,m^{-3}},\\,5.0\\times 10^{-8}\\,\\mathrm{m\\,s^{-1}},\\,1.0\\times 10^{-14}\\,\\mathrm{m\\,Pa^{-1}\\,s^{-1}},\\,310\\,\\mathrm{K},\\,100\\,\\mathrm{s},\\,0.04,\\,0.40\\right)$.\n- Case $5$ (boundary hypotonic shock with low water permeability; near area limit): $\\left(1.0\\times 10^{-18}\\,\\mathrm{m^{3}},\\,300\\,\\mathrm{mol\\,m^{-3}},\\,150\\,\\mathrm{mol\\,m^{-3}},\\,5.0\\times 10^{-9}\\,\\mathrm{m\\,s^{-1}},\\,3.0\\times 10^{-15}\\,\\mathrm{m\\,Pa^{-1}\\,s^{-1}},\\,310\\,\\mathrm{K},\\,200\\,\\mathrm{s},\\,0.04,\\,0.40\\right)$.\n\nYour program should implement the derived ODEs, simulate each test case over $[0, t_{\\text{end}}]$ with event detection for $A\\left(V(t)\\right) = A_{\\max}$ and $V(t) = V_{\\min}$, and return for each case a boolean that is $true$ if the cell remains viable and $false$ otherwise. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\left[\\text{True},\\text{False},\\text{True},\\text{False},\\text{True}\\right]$). No other output is permitted.", "solution": "### **Derivation of the Coupled ODE System**\n\nThe state of the system is described by two variables: the cell volume, $V(t)$, and the intracellular solute concentration, $C_{\\text{in}}(t)$. We must derive the expressions for their rates of change, $\\frac{dV}{dt}$ and $\\frac{dC_{\\text{in}}}{dt}$.\n\n**1. Derivation of $\\frac{dV}{dt}$:**\n\nThis equation is derived by direct substitution of the provided laws. The volumetric water flux is given as:\n$$ \\frac{dV}{dt} = L_{p} A(V) \\Delta \\pi $$\nSubstituting the van't Hoff law for $\\Delta \\pi = R T (C_{\\text{in}} - C_{\\text{out}})$ and the spherical geometry relation $A(V) = \\kappa V^{2/3}$ (where $\\kappa = (36\\pi)^{1/3}$ is a geometric constant):\n$$ \\frac{dV}{dt} = L_{p} (\\kappa V^{2/3}) R T (C_{\\text{in}} - C_{\\text{out}}) $$\nRearranging for convention:\n$$ \\frac{dV}{dt} = \\kappa L_{p} R T V(t)^{2/3} \\left(C_{\\text{in}}(t) - C_{\\text{out,shock}}\\right) $$\nThis is the first ODE of our system. It describes how the cell volume changes in response to the osmotic pressure difference across the membrane.\n\n**2. Derivation of $\\frac{dC_{\\text{in}}}{dt}$:**\n\nThis derivation starts from the conservation of the number of moles of solute, $N(t)$, inside the cell. We are given $N(t) = C_{\\text{in}}(t) V(t)$. Differentiating with respect to time using the product rule yields:\n$$ \\frac{dN}{dt} = \\frac{dC_{\\text{in}}}{dt} V(t) + C_{\\text{in}}(t) \\frac{dV}{dt} $$\nThe conservation of mass law states that the rate of change of moles is equal to the net solute flux across the membrane area:\n$$ \\frac{dN}{dt} = J_{s} A(V) $$\nSubstituting the expression for the solute flux, $J_{s} = P(C_{\\text{out}} - C_{\\text{in}})$:\n$$ \\frac{dN}{dt} = P (C_{\\text{out,shock}} - C_{\\text{in}}(t)) A(V) $$\nEquating the two expressions for $\\frac{dN}{dt}$:\n$$ \\frac{dC_{\\text{in}}}{dt} V(t) + C_{\\text{in}}(t) \\frac{dV}{dt} = P (C_{\\text{out,shock}} - C_{\\text{in}}(t)) A(V) $$\nSolving for $\\frac{dC_{\\text{in}}}{dt}$:\n$$ \\frac{dC_{\\text{in}}}{dt} = \\frac{1}{V(t)} \\left[ P (C_{\\text{out,shock}} - C_{\\text{in}}(t)) A(V) - C_{\\text{in}}(t) \\frac{dV}{dt} \\right] $$\nThis equation shows that the change in internal concentration is due to two effects: the flux of solute across the membrane (first term) and the dilution or concentration effect from volume changes (second term).\n\nWe can substitute the known expressions for $A(V) = \\kappa V^{2/3}$ and the previously derived $\\frac{dV}{dt}$:\n$$ \\frac{dC_{\\text{in}}}{dt} = \\frac{1}{V} \\left[ P (C_{\\text{out}} - C_{\\text{in}}) (\\kappa V^{2/3}) - C_{\\text{in}} \\left( \\kappa L_{p} R T V^{2/3} (C_{\\text{in}} - C_{\\text{out}}) \\right) \\right] $$\nNote that $C_{\\text{out}} = C_{\\text{out,shock}}$. Factoring out common terms and simplifying:\n$$ \\frac{dC_{\\text{in}}}{dt} = \\frac{\\kappa V^{2/3}}{V} \\left[ P (C_{\\text{out}} - C_{\\text{in}}) - C_{\\text{in}} L_{p} R T (C_{\\text{in}} - C_{\\text{out}}) \\right] $$\n$$ \\frac{dC_{\\text{in}}}{dt} = \\kappa V^{-1/3} \\left[ P (C_{\\text{out}} - C_{\\text{in}}) + C_{\\text{in}} L_{p} R T (C_{\\text{out}} - C_{\\text{in}}) \\right] $$\n$$ \\frac{dC_{\\text{in}}}{dt} = \\kappa V(t)^{-1/3} (C_{\\text{out,shock}} - C_{\\text{in}}(t)) \\left[ P + C_{\\text{in}}(t) L_{p} R T \\right] $$\nThis is the second ODE of our system.\n\n**Summary of the ODE System:**\nThe system to be solved numerically is:\n$$\n\\begin{cases}\n\\frac{dV}{dt} = \\kappa L_{p} R T V^{2/3} (C_{\\text{in}} - C_{\\text{out,shock}}) \\\\\n\\frac{dC_{\\text{in}}}{dt} = \\kappa V^{-1/3} (C_{\\text{out,shock}} - C_{\\text{in}}) (P + C_{\\text{in}} L_{p} R T)\n\\end{cases}\n$$\nwith initial conditions $V(0) = V_0$ and $C_{\\text{in}}(0) = C_{\\text{out},0}$.\n\n### **Numerical Solution and Viability Assessment**\n\nThe derived system of two coupled, first-order, non-linear ODEs will be solved using a numerical integrator. The `scipy.integrate.solve_ivp` function from the SciPy library is suitable for this task, as it provides robust algorithms and supports event detection.\n\n**Viability Constraints as Events:**\nThe viability of the cell is constrained by a maximum area (to prevent lysis) and a minimum volume (to maintain function). These constraints will be implemented as terminal events in the ODE solver. If an event is triggered, the integration stops, and the cell is considered non-viable.\n\n1.  **Lysis Condition (Maximum Area):**\n    The area must not exceed $A_{\\max} = A_0 (1 + \\varepsilon_{\\max})$. Since $A(V) = \\kappa V^{2/3}$, this implies a maximum volume, $V_{\\max}$:\n    $$ \\kappa V_{\\max}^{2/3} = \\kappa V_0^{2/3} (1 + \\varepsilon_{\\max}) \\implies V_{\\max} = V_0 (1 + \\varepsilon_{\\max})^{3/2} $$\n    The event function will be $f_{\\text{lysis}}(t, y) = V_{\\max} - V(t)$. The solver will detect when this function crosses zero.\n\n2.  **Shrinkage Condition (Minimum Volume):**\n    The volume must not fall below $V_{\\min} = V_0 (1 - \\phi_{\\min})$.\n    The event function will be $f_{\\text{shrink}}(t, y) = V(t) - V_{\\min}$. The solver will detect when this function crosses zero.\n\nIf the integration completes over the entire time interval $[0, t_{\\text{end}}]$ without any of these events being triggered, the cell is deemed viable for that set of conditions. Otherwise, it is not. The final program will iterate through each test case, perform the simulation with event detection, and report the boolean viability outcome.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the cell viability problem for a set of test cases.\n    \"\"\"\n    # Test suite specification. Each case is a tuple:\n    # (V0, C_out0, C_out_shock, P, Lp, T, t_end, eps_max, phi_min)\n    test_cases = [\n        # Case 1: happy path, mild hypotonic shock\n        (1.0e-18, 300, 200, 1.0e-8, 5.0e-15, 310, 100, 0.04, 0.40),\n        # Case 2: severe hypotonic shock with high water permeability\n        (1.0e-18, 300, 50, 1.0e-8, 2.0e-14, 310, 50, 0.04, 0.40),\n        # Case 3: strong hypertonic shock with slow solute permeability\n        (1.0e-18, 300, 900, 1.0e-9, 1.0e-14, 310, 100, 0.04, 0.40),\n        # Case 4: strong hypertonic shock with high solute permeability\n        (1.0e-18, 300, 900, 5.0e-8, 1.0e-14, 310, 100, 0.04, 0.40),\n        # Case 5: boundary hypotonic shock with low water permeability\n        (1.0e-18, 300, 150, 5.0e-9, 3.0e-15, 310, 200, 0.04, 0.40),\n    ]\n\n    results = []\n    R = 8.314  # J mol^-1 K^-1\n    KAPPA = (36 * np.pi)**(1/3) # Geometric factor for sphere\n\n    def model(t, y, params):\n        \"\"\"\n        Defines the coupled ODE system.\n        y[0] = V(t) (cell volume)\n        y[1] = Cin(t) (internal concentration)\n        \"\"\"\n        V, C_in = y\n        P, Lp, T, C_out_shock = params['P'], params['Lp'], params['T'], params['C_out_shock']\n\n        # Avoid division by zero or negative volume underflow if integration is unstable\n        if V = 0:\n            return [0, 0]\n\n        # Rate of change of volume (dV/dt)\n        dVdt = KAPPA * Lp * R * T * V**(2/3) * (C_in - C_out_shock)\n        \n        # Rate of change of internal concentration (dCin/dt)\n        term1 = KAPPA * V**(-1/3)\n        term2 = C_out_shock - C_in\n        term3 = P + C_in * Lp * R * T\n        dCindt = term1 * term2 * term3\n        \n        return [dVdt, dCindt]\n\n    for case in test_cases:\n        V0, C_out0, C_out_shock, P, Lp, T, t_end, eps_max, phi_min = case\n\n        # Initial internal concentration is isotonic with initial external concentration\n        C_in0 = C_out0\n        \n        # Viability boundaries\n        V_min = V0 * (1 - phi_min)\n        V_max = V0 * (1 + eps_max)**(1.5)\n\n        # Event: Cell shrinks below minimum functional volume\n        def event_shrinkage(t, y, params):\n            return y[0] - V_min\n        event_shrinkage.terminal = True\n        event_shrinkage.direction = -1 # Event triggers when volume is decreasing\n\n        # Event: Cell swells beyond maximum lytic area/volume\n        def event_lysis(t, y, params):\n            return y[0] - V_max\n        event_lysis.terminal = True\n        event_lysis.direction = 1 # Event triggers when volume is increasing\n\n        # Parameters for the ODE function\n        params = {\n            'P': P, 'Lp': Lp, 'T': T, 'C_out_shock': C_out_shock\n        }\n        \n        # Initial state vector\n        y0 = [V0, C_in0]\n        \n        # Time span for integration\n        t_span = [0, t_end]\n\n        sol = solve_ivp(\n            fun=model,\n            t_span=t_span,\n            y0=y0,\n            method='Radau', # Good for potentially stiff problems\n            events=[event_shrinkage, event_lysis],\n            args=(params,),\n            dense_output=False\n        )\n\n        # A cell is viable if the integration completes without triggering a terminal event.\n        # This occurs when sol.status is 0 (integration reached t_end) or when\n        # no terminal events are recorded in `sol.t_events`.\n        is_viable = all(len(evt) == 0 for evt in sol.t_events)\n        \n        results.append(is_viable)\n\n    # Format the final output as a comma-separated list of booleans\n    # Python's str(True) - 'True', str(False) - 'False' as per example `[True,False,...]`\n    output_str = '[' + ','.join(map(str, results)) + ']'\n    print(output_str)\n\nsolve()\n```", "id": "3358577"}, {"introduction": "A predictive model is incomplete without well-calibrated parameters derived from experimental data. This final practice delves into the crucial task of parameter inference using a Bayesian framework, where prior knowledge is systematically updated with new observations. You will implement a numerical scheme to compute the posterior distributions for the kinetic parameters of a gene expression module, learning to quantify uncertainty and diagnose practical issues like parameter non-identifiability [@problem_id:3358634].", "problem": "Consider a minimal gene expression module within a whole-cell model under steady-state conditions. Messenger ribonucleic acid (mRNA) is synthesized at a transcription rate and degraded, and protein is synthesized from mRNA at a translation rate and degraded. Assume the following mass-action steady-state relationships derived from Ordinary Differential Equation (ODE) models of transcription and translation under a constant input:\n1. The steady-state mRNA copy number under input $u$ is $m_{\\mathrm{ss}} = \\dfrac{k_{\\mathrm{tx}} \\, u}{\\delta_m}$.\n2. The steady-state protein copy number under input $u$ is $p_{\\mathrm{ss}} = \\dfrac{k_{\\mathrm{tx}} \\, k_{\\mathrm{tl}} \\, u}{\\delta_m \\, \\delta_p}$.\n3. The protein half-life is $t_{1/2} = \\dfrac{\\ln 2}{\\delta_p}$.\n\nParameters are strictly positive. Let the unknown kinetic parameters be $\\theta = (k_{\\mathrm{tx}}, k_{\\mathrm{tl}}, \\delta_p)$, where $k_{\\mathrm{tx}}$ is the transcription rate, $k_{\\mathrm{tl}}$ is the translation rate, and $\\delta_p$ is the protein degradation rate. The mRNA degradation rate $\\delta_m$ is known.\n\nAssume Bayesian inference with independent log-normal priors on each component of $\\theta$. Equivalently, in log-parameter space $z = (\\ln k_{\\mathrm{tx}}, \\ln k_{\\mathrm{tl}}, \\ln \\delta_p)$, each component has a Normal prior: $z_i \\sim \\mathcal{N}(\\mu_i, \\sigma_i^2)$, independently for $i \\in \\{1,2,3\\}$. Measurement noise models are Gaussian and independent across measurements and experiments as follows:\n- For steady-state protein measurements $y_p$ under inputs $u$, $y_p \\sim \\mathcal{N}\\!\\left(p_{\\mathrm{ss}}(\\theta; u), \\sigma_p^2\\right)$.\n- For steady-state mRNA measurements $y_m$ under inputs $u$, $y_m \\sim \\mathcal{N}\\!\\left(m_{\\mathrm{ss}}(\\theta; u), \\sigma_m^2\\right)$.\n- For half-life measurement $y_t$, $y_t \\sim \\mathcal{N}\\!\\left(t_{1/2}(\\theta), \\sigma_t^2\\right)$.\n\nLet the posterior over $z$ be proportional to the product of the prior density in $z$ and the likelihood induced by the above observation model. Define the posterior variance of the log-parameter $z_i$ as $\\mathrm{Var}_{\\text{post}}(z_i)$ and the prior variance as $\\mathrm{Var}_{\\text{prior}}(z_i) = \\sigma_i^2$. Define the variance reduction for parameter $i$ as\n$$\nR_i = 1 - \\frac{\\mathrm{Var}_{\\text{post}}(z_i)}{\\mathrm{Var}_{\\text{prior}}(z_i)}.\n$$\nA parameter is considered weakly constrained if $R_i  0.5$.\n\nYour task is to:\n- Use Bayes’ theorem to combine the specified prior and likelihood to obtain the posterior distribution over $z$.\n- Numerically approximate the posterior over $z$ by discretizing each $z_i$ on a uniform grid spanning $[\\mu_i - 4 \\sigma_i, \\, \\mu_i + 4 \\sigma_i]$ with $41$ equally spaced points per dimension (a $41 \\times 41 \\times 41$ tensor grid in $z$-space).\n- Compute the normalized posterior weights on the grid up to a common proportionality constant using the unnormalized log-density, and then compute $\\mathrm{Var}_{\\text{post}}(z_i)$ by weighted sums on this grid.\n- Classify each parameter as weakly constrained if $R_i  0.5$.\n\nUse the known mRNA degradation rate $\\delta_m = 0.2$ in min$^{-1}$. Units for parameters and measurements are as follows: $k_{\\mathrm{tx}}$ in min$^{-1}$, $k_{\\mathrm{tl}}$ in min$^{-1}$, $\\delta_p$ in min$^{-1}$, $\\delta_m$ in min$^{-1}$, steady-state molecule counts in molecules per cell, and half-life in minutes. All measurements and parameters must be used consistently in these units. The output is purely logical (integers $0$ or $1$) and thus no unit expression is required in the final output.\n\nTest suite. Apply your program to the following three cases. In each case, treat the observations as fixed given numbers (do not simulate additional noise).\n\n- Case A (steady-state protein only; identifiability-limited):\n  - Inputs for protein measurements: $u = [1.0, 2.0]$ (dimensionless).\n  - Observed proteins: $y_p = [1015.0, 1990.0]$ with $\\sigma_p = 50.0$ molecules per cell.\n  - No mRNA measurements and no half-life measurement.\n  - Prior means and standard deviations in log-space:\n    - $\\mu = [\\ln(2.0), \\ln(5.0), \\ln(0.05)]$,\n    - $\\sigma = [1.0, 1.0, 1.0]$.\n\n- Case B (protein, mRNA, and half-life; strongly informative):\n  - Inputs for protein measurements: $u = [1.0, 2.0]$.\n  - Observed proteins: $y_p = [1015.0, 1990.0]$ with $\\sigma_p = 50.0$ molecules per cell.\n  - mRNA measurement under $u = 1.0$: observed $y_m = 10.5$ with $\\sigma_m = 0.5$ molecules per cell.\n  - Half-life measurement: observed $y_t = 13.8$ with $\\sigma_t = 0.5$ minutes.\n  - Prior means and standard deviations in log-space:\n    - $\\mu = [\\ln(2.0), \\ln(5.0), \\ln(0.05)]$,\n    - $\\sigma = [1.0, 1.0, 1.0]$.\n\n- Case C (informative prior on transcription, protein only):\n  - Inputs for protein measurements: $u = [1.0, 2.0]$.\n  - Observed proteins: $y_p = [1015.0, 1990.0]$ with $\\sigma_p = 50.0$ molecules per cell.\n  - No mRNA measurements and no half-life measurement.\n  - Prior means and standard deviations in log-space:\n    - $\\mu = [\\ln(2.0), \\ln(5.0), \\ln(0.05)]$,\n    - $\\sigma = [0.05, 1.0, 1.0]$.\n\nAlgorithmic requirements:\n- Work in $z$-space. The prior density is the product of Normal densities for each $z_i$. The likelihood terms are Gaussian on the observables with means given by the mass-action steady-state relationships expressed in terms of $z$:\n  - $p_{\\mathrm{ss}} = \\exp(z_1 + z_2 - z_3) \\cdot \\dfrac{u}{\\delta_m}$,\n  - $m_{\\mathrm{ss}} = \\exp(z_1) \\cdot \\dfrac{u}{\\delta_m}$,\n  - $t_{1/2} = \\dfrac{\\ln 2}{\\exp(z_3)}$.\n- Compute the unnormalized log posterior on the grid by adding the log prior and log likelihoods. For numerical stability, subtract the maximum log unnormalized posterior before exponentiation. Normalize the weights to sum to $1$ over the grid to approximate expectations.\n- Compute the posterior variances of $z_1, z_2, z_3$ and the reductions $R_1, R_2, R_3$.\n\nFinal output specification:\n- For each case, output a list of three integers in the order $[k_{\\mathrm{tx}}, k_{\\mathrm{tl}}, \\delta_p]$, where $1$ denotes “weakly constrained” and $0$ denotes “not weakly constrained” according to the threshold $R_i  0.5$.\n- Your program should produce a single line of output containing the results for the three cases as a comma-separated list of these three-element lists, with no spaces. For example: [[1,0,1],[0,0,0],[1,1,1]].", "solution": "The problem requires performing Bayesian parameter inference for a minimal gene expression model and subsequently classifying each parameter as \"weakly constrained\" based on the reduction in variance from the prior to the posterior distribution. The analysis is to be performed numerically on a discrete grid in log-parameter space for three distinct cases.\n\n### Step 1: Theoretical Framework\n\nThe core of the problem lies in applying Bayes' theorem. The posterior probability distribution of the parameters $z$ given the data $y$, denoted $P(z|y)$, is proportional to the product of the likelihood of the data given the parameters, $\\mathcal{L}(y|z)$, and the prior probability of the parameters, $P(z)$.\n$$\nP(z|y) \\propto \\mathcal{L}(y|z) P(z)\n$$\nWorking with logarithms is more numerically stable and convenient, as it turns products into sums:\n$$\n\\ln P(z|y) = \\ln \\mathcal{L}(y|z) + \\ln P(z) + \\text{constant}\n$$\nThe parameters are defined in log-space as $z = (z_1, z_2, z_3) = (\\ln k_{\\mathrm{tx}}, \\ln k_{\\mathrm{tl}}, \\ln \\delta_p)$, where $k_{\\mathrm{tx}}$ is the transcription rate, $k_{\\mathrm{tl}}$ is the translation rate, and $\\delta_p$ is the protein degradation rate.\n\n### Step 2: Prior Distribution\n\nThe problem states that the parameters $z_i$ have independent Normal priors: $z_i \\sim \\mathcal{N}(\\mu_i, \\sigma_i^2)$. The joint log-prior density, ignoring constant terms, is the sum of the individual log-priors:\n$$\n\\ln P(z) \\propto \\sum_{i=1}^{3} \\ln \\mathcal{N}(z_i | \\mu_i, \\sigma_i^2) \\propto -\\frac{1}{2}\\sum_{i=1}^{3} \\left( \\frac{z_i - \\mu_i}{\\sigma_i} \\right)^2\n$$\nThe prior variance for each log-parameter $z_i$ is $\\mathrm{Var}_{\\text{prior}}(z_i) = \\sigma_i^2$.\n\n### Step 3: Likelihood Function\n\nThe measurements are assumed to be independent, so the total log-likelihood is the sum of the log-likelihoods for each observation. The noise for each measurement type is Gaussian.\n\nThe model predictions in terms of $z$ are:\n-   Steady-state protein: $p_{\\mathrm{ss}}(z; u) = \\frac{k_{\\mathrm{tx}} k_{\\mathrm{tl}} u}{\\delta_m \\delta_p} = \\frac{\\exp(z_1) \\exp(z_2) u}{\\delta_m \\exp(z_3)} = \\frac{u}{\\delta_m} \\exp(z_1 + z_2 - z_3)$\n-   Steady-state mRNA: $m_{\\mathrm{ss}}(z; u) = \\frac{k_{\\mathrm{tx}} u}{\\delta_m} = \\frac{u}{\\delta_m} \\exp(z_1)$\n-   Protein half-life: $t_{1/2}(z) = \\frac{\\ln 2}{\\delta_p} = (\\ln 2) \\exp(-z_3)$\n\nThe log-likelihood contributions (ignoring constants) are:\n-   For a set of protein measurements $\\{y_{p,j}\\}$ at inputs $\\{u_j\\}$ with noise $\\sigma_p$:\n    $$\n    \\ln \\mathcal{L}_p(y_p|z) = \\sum_{j} -\\frac{(y_{p,j} - p_{\\mathrm{ss}}(z; u_j))^2}{2\\sigma_p^2}\n    $$\n-   For an mRNA measurement $y_m$ at input $u_m$ with noise $\\sigma_m$:\n    $$\n    \\ln \\mathcal{L}_m(y_m|z) = -\\frac{(y_m - m_{\\mathrm{ss}}(z; u_m))^2}{2\\sigma_m^2}\n    $$\n-   For a half-life measurement $y_t$ with noise $\\sigma_t$:\n    $$\n    \\ln \\mathcal{L}_t(y_t|z) = -\\frac{(y_t - t_{1/2}(z))^2}{2\\sigma_t^2}\n    $$\nThe total log-likelihood is $\\ln \\mathcal{L}(y|z) = \\ln \\mathcal{L}_p + \\ln \\mathcal{L}_m + \\ln \\mathcal{L}_t$, where terms are omitted if the corresponding data is not available for a given case.\n\n### Step 4: Numerical Approximation of the Posterior\n\nThe continuous posterior distribution is approximated on a discrete grid. Each parameter axis $z_i$ is discretized into $41$ points over the range $[\\mu_i - 4\\sigma_i, \\mu_i + 4\\sigma_i]$. This creates a $41 \\times 41 \\times 41$ grid in the $3$-dimensional parameter space.\n\nFor each point $z_k$ on this grid, we compute the unnormalized log-posterior:\n$$\n\\ln P_{\\text{unnorm}}(z_k|y) = \\ln P(z_k) + \\ln \\mathcal{L}(y|z_k)\n$$\nFor numerical stability, we subtract the maximum value before exponentiating to obtain unnormalized weights $w(z_k)$:\n$$\nw(z_k) = \\exp(\\ln P_{\\text{unnorm}}(z_k|y) - \\max_{j} \\{\\ln P_{\\text{unnorm}}(z_j|y)\\})\n$$\nThese weights are then normalized to sum to $1$ to yield the discrete posterior probability mass function, $W(z_k)$:\n$$\nW(z_k) = \\frac{w(z_k)}{\\sum_{j} w(z_j)}\n$$\n\n### Step 5: Posterior Variance and Parameter Constraint\n\nWith the normalized posterior weights $W(z_k)$, the posterior moments for each parameter $z_i$ are computed as weighted sums over the grid.\n-   Posterior Mean: $E_{\\text{post}}[z_i] \\approx \\sum_k z_{i,k} W(z_k)$\n-   Posterior Mean of Squares: $E_{\\text{post}}[z_i^2] \\approx \\sum_k z_{i,k}^2 W(z_k)$\n-   Posterior Variance: $\\mathrm{Var}_{\\text{post}}(z_i) = E_{\\text{post}}[z_i^2] - (E_{\\text{post}}[z_i])^2$\n\nThe variance reduction $R_i$ quantifies how much the data has constrained the parameter relative to the prior uncertainty:\n$$\nR_i = 1 - \\frac{\\mathrm{Var}_{\\text{post}}(z_i)}{\\mathrm{Var}_{\\text{prior}}(z_i)} = 1 - \\frac{\\mathrm{Var}_{\\text{post}}(z_i)}{\\sigma_i^2}\n$$\nA parameter is classified as \"weakly constrained\" if $R_i  0.5$, which means the data failed to reduce the parameter's variance by at least $50\\%$.\n\n### Step 6: Case Analysis Logic\n-   **Case A**: With only protein data, the model is structurally non-identifiable. The measurements can only constrain the combination $z_1 + z_2 - z_3$, but not the individual parameters. With broad priors, the marginal posterior variances for each $z_i$ are expected to be close to their prior variances, resulting in small $R_i$ values.\n-   **Case B**: The availability of mRNA and half-life data resolves the non-identifiability. The mRNA data constrains $z_1$, the half-life data constrains $z_3$, and the protein data then constrains the remaining parameter $z_2$. A significant variance reduction is expected for all three parameters.\n-   **Case C**: This case is identical to Case A in terms of data but features a very informative (narrow) prior for $z_1$. The posterior variance for $z_1$ will be dominated by its already small prior variance, so the data provides little additional reduction, leading to $R_1 \\approx 0$. The structural non-identifiability for $z_2$ and $z_3$ remains, so their variances will also not be significantly reduced.", "answer": "```python\nimport numpy as np\n\ndef analyze_case(case_data):\n    \"\"\"\n    Analyzes a single parameter inference case using grid-based Bayesian inference.\n\n    Args:\n        case_data (dict): A dictionary containing all the data and prior\n                          information for a single experimental case.\n\n    Returns:\n        list: A list of three integers (0 or 1) indicating if each parameter\n              (k_tx, k_tl, delta_p) is weakly constrained (1) or not (0).\n    \"\"\"\n    mu = case_data['mu']\n    sigma = case_data['sigma']\n    num_points = 41\n    delta_m = 0.2\n\n    # 1. Generate the parameter grid in log-space (z-space)\n    z1_grid = np.linspace(mu[0] - 4 * sigma[0], mu[0] + 4 * sigma[0], num_points)\n    z2_grid = np.linspace(mu[1] - 4 * sigma[1], mu[1] + 4 * sigma[1], num_points)\n    z3_grid = np.linspace(mu[2] - 4 * sigma[2], mu[2] + 4 * sigma[2], num_points)\n    \n    # Use 'ij' indexing to match loop order intuition (i=z1, j=z2, k=z3)\n    Z1, Z2, Z3 = np.meshgrid(z1_grid, z2_grid, z3_grid, indexing='ij')\n\n    # 2. Calculate the log-prior probability on the grid\n    log_prior = -0.5 * (\n        ((Z1 - mu[0]) / sigma[0])**2 +\n        ((Z2 - mu[1]) / sigma[1])**2 +\n        ((Z3 - mu[2]) / sigma[2])**2\n    )\n\n    # 3. Calculate the log-likelihood on the grid\n    log_likelihood = np.zeros_like(Z1)\n\n    # Add contribution from protein measurements if present\n    if 'yp' in case_data:\n        for y, u in zip(case_data['yp'], case_data['up']):\n            p_ss_model = np.exp(Z1 + Z2 - Z3) * u / delta_m\n            log_likelihood += -0.5 * ((y - p_ss_model) / case_data['sigma_p'])**2\n\n    # Add contribution from mRNA measurement if present\n    if 'ym' in case_data:\n        m_ss_model = np.exp(Z1) * case_data['um'] / delta_m\n        log_likelihood += -0.5 * ((case_data['ym'] - m_ss_model) / case_data['sigma_m'])**2\n\n    # Add contribution from half-life measurement if present\n    if 'yt' in case_data:\n        t_half_model = np.log(2) * np.exp(-Z3)\n        log_likelihood += -0.5 * ((case_data['yt'] - t_half_model) / case_data['sigma_t'])**2\n\n    # 4. Calculate posterior weights\n    # Sum log-prior and log-likelihood for unnormalized log-posterior\n    log_posterior_unnorm = log_prior + log_likelihood\n    \n    # Stabilize by subtracting the max value before exponentiation\n    log_posterior_stable = log_posterior_unnorm - np.max(log_posterior_unnorm)\n    posterior_weights = np.exp(log_posterior_stable)\n    \n    # Normalize weights to sum to 1\n    posterior_weights /= np.sum(posterior_weights)\n\n    # 5. Calculate posterior variances, variance reduction, and classify\n    results = []\n    grids = [Z1, Z2, Z3]\n    prior_vars = [s**2 for s in sigma]\n\n    for i in range(3):\n        # Calculate posterior mean and variance using weighted sums\n        post_mean = np.sum(grids[i] * posterior_weights)\n        post_mean_sq = np.sum(grids[i]**2 * posterior_weights)\n        post_var = post_mean_sq - post_mean**2\n        \n        prior_var = prior_vars[i]\n        \n        # Calculate variance reduction R_i\n        R_i = 1 - post_var / prior_var\n        \n        # Classify as weakly constrained if R_i  0.5\n        is_weakly_constrained = 1 if R_i  0.5 else 0\n        results.append(is_weakly_constrained)\n        \n    return results\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run analysis, and print results.\n    \"\"\"\n    # Define the three test cases as dictionaries\n    case_A = {\n        'name': 'protein only',\n        'up': [1.0, 2.0],\n        'yp': [1015.0, 1990.0],\n        'sigma_p': 50.0,\n        'mu': [np.log(2.0), np.log(5.0), np.log(0.05)],\n        'sigma': [1.0, 1.0, 1.0]\n    }\n\n    case_B = {\n        'name': 'protein, mRNA, and half-life',\n        'up': [1.0, 2.0],\n        'yp': [1015.0, 1990.0],\n        'sigma_p': 50.0,\n        'um': 1.0,\n        'ym': 10.5,\n        'sigma_m': 0.5,\n        'yt': 13.8,\n        'sigma_t': 0.5,\n        'mu': [np.log(2.0), np.log(5.0), np.log(0.05)],\n        'sigma': [1.0, 1.0, 1.0]\n    }\n\n    case_C = {\n        'name': 'informative prior on transcription, protein only',\n        'up': [1.0, 2.0],\n        'yp': [1015.0, 1990.0],\n        'sigma_p': 50.0,\n        'mu': [np.log(2.0), np.log(5.0), np.log(0.05)],\n        'sigma': [0.05, 1.0, 1.0]\n    }\n    \n    test_cases = [case_A, case_B, case_C]\n    \n    all_results = []\n    for case in test_cases:\n        result = analyze_case(case)\n        all_results.append(result)\n        \n    # Format the final output string to match the problem specification\n    result_strings = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\n# Execute the solution\nsolve()\n\n```", "id": "3358634"}]}