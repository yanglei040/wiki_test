{"hands_on_practices": [{"introduction": "To begin our exploration, we bridge the gap between the continuous, deterministic world of ordinary differential equations (ODEs) and the discrete, probabilistic realm of stochastic processes. This first practice examines a simple birth-death system, a cornerstone of molecular systems biology. By deriving and comparing the analytical solution for the deterministic concentration against the time-evolving mean and variance from the stochastic model, we gain direct insight into how macroscopic averages relate to underlying molecular fluctuations and establish a quantitative understanding of intrinsic noise [@problem_id:3300946].", "problem": "Consider a well-mixed, isothermal reaction system in a fixed volume where species $A$ is synthesized and removed via interaction with a chemostatted species $B$. The network consists of the following reactions:\n\n1. Zeroth-order synthesis: $\\varnothing \\rightarrow A$ with rate constant $k_0$ having units $\\mathrm{mol}\\,\\mathrm{L}^{-1}\\,\\mathrm{s}^{-1}$.\n2. $B$-catalyzed removal: $A + B \\rightarrow B$ with mass-action rate constant $k_1$ having units $\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$.\n3. First-order degradation: $A \\rightarrow \\varnothing$ with rate constant $k_2$ having units $\\mathrm{s}^{-1}$.\n\nAssume that $[B](t)$ is maintained constant by a chemostat at $[B](t) = [B](0)$ for all time, and focus on the special case $k_2 = 0$. Using the law of mass action and standard deterministic chemical kinetics, derive the ordinary differential equation for the concentration trajectory $[A](t)$ and solve it analytically for $k_2 = 0$ under the assumption that $[B](t)$ is constant. Then, for the stochastic description based on the Chemical Master Equation (CME), model the molecule count of $A$ as a continuous-time birth-death process in a volume $V$ (in $\\mathrm{L}$), with births at propensity $\\lambda = k_0 V N_\\mathrm{A}$ and deaths at propensity $\\mu n$ where $\\mu = k_1 [B](0)$, $n$ is the molecule count of $A$, and $N_\\mathrm{A} = 6.02214076 \\times 10^{23}\\,\\mathrm{mol}^{-1}$ is Avogadro's constant. Derive the mean $E[n(t)]$ and the variance $\\mathrm{Var}[n(t)]$ for this process in terms of $\\lambda$, $\\mu$, and the initial molecule count $n(0)$, assuming the initial molecule count is known exactly (initial variance zero).\n\nYour program must implement the analytic deterministic solution for $[A](t)$, along with the CME mean $E[n(t)]$ and variance $\\mathrm{Var}[n(t)]$ at a specified evaluation time $T$. For numerical evaluation, use the following scientifically plausible test suite with fixed physical units. In all cases, concentrations must be expressed in $\\mathrm{mol}\\,\\mathrm{L}^{-1}$, time in $\\mathrm{s}$, and molecule counts are dimensionless integers in principle, though expectations and variances may be non-integer real numbers.\n\nTest suite (each case provides $(V, k_0, k_1, [B](0), [A](0), n(0), T)$):\n\nCase $1$ (general \"happy path\"):\n- $V = 1.0 \\times 10^{-15}\\,\\mathrm{L}$\n- $k_0 = 2.0 \\times 10^{-8}\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}\\,\\mathrm{s}^{-1}$\n- $k_1 = 1.0 \\times 10^{6}\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$\n- $[B](0) = 5.0 \\times 10^{-7}\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$\n- $[A](0) = 1.0 \\times 10^{-7}\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$\n- $n(0) = 60$ (a consistent, fixed integer initialization)\n- $T = 10.0\\,\\mathrm{s}$\n\nCase $2$ (boundary condition with $[B](0) = 0$, no removal):\n- $V = 1.0 \\times 10^{-15}\\,\\mathrm{L}$\n- $k_0 = 1.0 \\times 10^{-9}\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}\\,\\mathrm{s}^{-1}$\n- $k_1 = 5.0 \\times 10^{5}\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$\n- $[B](0) = 0.0\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$\n- $[A](0) = 0.0\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$\n- $n(0) = 0$\n- $T = 100.0\\,\\mathrm{s}$\n\nCase $3$ (fast relaxation with large $[B](0)$):\n- $V = 1.0 \\times 10^{-15}\\,\\mathrm{L}$\n- $k_0 = 5.0 \\times 10^{-9}\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}\\,\\mathrm{s}^{-1}$\n- $k_1 = 2.0 \\times 10^{7}\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$\n- $[B](0) = 1.0 \\times 10^{-6}\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$\n- $[A](0) = 3.0 \\times 10^{-7}\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$\n- $n(0) = 181$\n- $T = 0.1\\,\\mathrm{s}$\n\nRequired outputs for each test case $i$ at time $T$:\n- Deterministic concentration $[A](T)$ in $\\mathrm{mol}\\,\\mathrm{L}^{-1}$, rounded to six decimal places.\n- Stochastic mean molecule count $E[n(T)]$, rounded to six decimal places.\n- Stochastic variance $\\mathrm{Var}[n(T)]$, rounded to six decimal places.\n\nFinal output format:\nYour program should produce a single line of output containing the aggregated results for the three test cases, in order, as a comma-separated list enclosed in square brackets, where the $i$-th case contributes three consecutive floating-point numbers in the order specified above. For example, the output must have the form\n$[a_1,m_1,v_1,a_2,m_2,v_2,a_3,m_3,v_3]$,\nwhere $a_i$ is $[A](T)$ in $\\mathrm{mol}\\,\\mathrm{L}^{-1}$, $m_i$ is $E[n(T)]$, and $v_i$ is $\\mathrm{Var}[n(T)]$, all rounded to six decimal places.", "solution": "**1. Deterministic Model Solution**\n\nThe rate of change of the concentration of species $A$, denoted $[A]$, is given by the law of mass action. For the given reactions and with $k_2=0$ and $[B](t)$ constant at $[B](0)$, the ordinary differential equation (ODE) is:\n$$\n\\frac{d[A]}{dt} = k_0 - k_1 [B](0) [A]\n$$\nLet $\\mu' = k_1 [B](0)$. The ODE becomes $\\frac{d[A]}{dt} = k_0 - \\mu'[A]$, a first-order linear ODE.\nIf $\\mu' \\ne 0$, we can find the steady-state concentration $[A]_{ss}$ by setting $\\frac{d[A]}{dt} = 0$, which gives $[A]_{ss} = k_0 / \\mu'$. The solution to the ODE with initial condition $[A](0)$ is:\n$$\n[A](t) = [A]_{ss} + ([A](0) - [A]_{ss}) e^{-\\mu' t} = \\frac{k_0}{\\mu'} + \\left([A](0) - \\frac{k_0}{\\mu'}\\right)e^{-\\mu' t}\n$$\nIf $\\mu' = 0$ (i.e., $[B](0)=0$), the ODE simplifies to $\\frac{d[A]}{dt} = k_0$. Integrating from $t=0$ gives the solution:\n$$\n[A](t) = [A](0) + k_0 t\n$$\n\n**2. Stochastic Model Moments**\n\nThe system is a linear birth-death process for the molecule count $n$ of species $A$.\n-   Birth propensity (constant): $\\lambda = k_0 V N_\\mathrm{A}$\n-   Death propensity (linear): $a_{death}(n) = \\mu n$, where $\\mu = k_1 [B](0)$.\n\n**Mean ($E[n(t)]$)**: The time evolution of the mean, $\\langle n(t) \\rangle = E[n(t)]$, is given by:\n$$\n\\frac{d\\langle n \\rangle}{dt} = \\lambda - \\mu \\langle n \\rangle\n$$\nThis ODE has the same form as the deterministic equation. For $\\mu \\ne 0$, the solution with initial condition $n(0)$ is:\n$$\n\\langle n(t) \\rangle = \\frac{\\lambda}{\\mu} + \\left(n(0) - \\frac{\\lambda}{\\mu}\\right)e^{-\\mu t}\n$$\nFor $\\mu = 0$, the solution is:\n$$\n\\langle n(t) \\rangle = n(0) + \\lambda t\n$$\n\n**Variance ($\\mathrm{Var}[n(t)]$)**: The time evolution of the variance, $V(t) = \\mathrm{Var}[n(t)]$, is given by the ODE:\n$$\n\\frac{dV}{dt} = -2\\mu V(t) + \\lambda + \\mu\\langle n(t) \\rangle\n$$\nWith the initial condition $V(0)=0$ (as $n(0)$ is known exactly), this linear ODE can be solved.\nFor $\\mu \\ne 0$, substituting the expression for $\\langle n(t) \\rangle$ and solving yields:\n$$\nV(t) = \\frac{\\lambda}{\\mu}(1 - e^{-2\\mu t}) + \\left(n(0) - \\frac{\\lambda}{\\mu}\\right)(e^{-\\mu t} - e^{-2\\mu t})\n$$\nFor $\\mu = 0$, the variance ODE becomes $\\frac{dV}{dt} = \\lambda$. The solution is:\n$$\nV(t) = \\lambda t\n$$", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the deterministic concentration, and stochastic mean and variance\n    for a chemical reaction system under three different test cases.\n    \"\"\"\n    \n    # Avogadro's constant\n    NA = 6.02214076e23  # mol^-1\n\n    # Test suite: (V, k0, k1, B0, A0, n0, T)\n    test_cases = [\n        # Case 1 (general \"happy path\")\n        {\n            \"V\": 1.0e-15,      # L\n            \"k0\": 2.0e-8,      # mol L^-1 s^-1\n            \"k1\": 1.0e6,       # L mol^-1 s^-1\n            \"B0\": 5.0e-7,      # mol L^-1\n            \"A0\": 1.0e-7,      # mol L^-1\n            \"n0\": 60,          # dimensionless\n            \"T\": 10.0          # s\n        },\n        # Case 2 (boundary condition with B0 = 0)\n        {\n            \"V\": 1.0e-15,\n            \"k0\": 1.0e-9,\n            \"k1\": 5.0e5,\n            \"B0\": 0.0,\n            \"A0\": 0.0,\n            \"n0\": 0,\n            \"T\": 100.0\n        },\n        # Case 3 (fast relaxation with large B0)\n        {\n            \"V\": 1.0e-15,\n            \"k0\": 5.0e-9,\n            \"k1\": 2.0e7,\n            \"B0\": 1.0e-6,\n            \"A0\": 3.0e-7,\n            \"n0\": 181,\n            \"T\": 0.1\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        V = case[\"V\"]\n        k0 = case[\"k0\"]\n        k1 = case[\"k1\"]\n        B0 = case[\"B0\"]\n        A0 = case[\"A0\"]\n        n0 = case[\"n0\"]\n        T = case[\"T\"]\n        \n        # Calculate composite parameters\n        mu = k1 * B0          # s^-1 (for both models)\n        lambd = k0 * V * NA   # s^-1 (stochastic birth rate)\n\n        # Initialize results for the current case\n        det_A_T = 0.0\n        stoch_mean_T = 0.0\n        stoch_var_T = 0.0\n\n        if mu > 0:\n            # Deterministic solution\n            A_ss = k0 / mu\n            det_A_T = A_ss + (A0 - A_ss) * np.exp(-mu * T)\n            \n            # Stochastic mean\n            n_ss = lambd / mu\n            stoch_mean_T = n_ss + (n0 - n_ss) * np.exp(-mu * T)\n            \n            # Stochastic variance\n            term1 = n_ss * (1 - np.exp(-2 * mu * T))\n            term2 = (n0 - n_ss) * (np.exp(-mu * T) - np.exp(-2 * mu * T))\n            stoch_var_T = term1 + term2\n        else: # mu == 0 case\n            # Deterministic solution\n            det_A_T = A0 + k0 * T\n            \n            # Stochastic mean\n            stoch_mean_T = n0 + lambd * T\n            \n            # Stochastic variance\n            stoch_var_T = lambd * T\n            \n        results.extend([det_A_T, stoch_mean_T, stoch_var_T])\n\n    # Format output to six decimal places as required\n    formatted_results = [f'{val:.6f}' for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3300946"}, {"introduction": "While the mean and variance provide a partial picture, the full power of stochastic modeling lies in its ability to predict the entire probability distribution of molecular counts. This exercise guides you through the analytical solution of the Chemical Master Equation (CME) for the stationary state of a linear birth-death process. This is a rare case where the CME can be solved exactly, yielding the Poisson distribution—a foundational result in the study of gene expression noise and other stochastic phenomena in biology [@problem_id:3300898].", "problem": "Consider a well-mixed single-cell system in which the copy number $n(t) \\in \\{0,1,2,\\dots\\}$ of a gene product evolves as a continuous-time Markov jump process with the following elementary reactions: production (birth) adds one molecule at a constant rate $k_b > 0$, and degradation (death) removes one molecule at a rate proportional to the current copy number with rate constant $k_d > 0$. This corresponds to the reaction scheme $\\varnothing \\xrightarrow{k_b} X$ and $X \\xrightarrow{k_d} \\varnothing$, with mass-action degradation. Let $P(n,t)$ denote the probability that the system has $n$ molecules at time $t$.\n\nStarting from the Kolmogorov forward equation (also called the Chemical Master Equation (CME)) for $P(n,t)$ implied by these reactions, derive the stationary probability mass function $P(n)$ for $n \\in \\mathbb{N}_0$ under the assumption that a stationary distribution exists and the chain is positive recurrent. Express the stationary distribution in closed form and identify it in terms of a well-known discrete distribution, together with its mean. Then, using the deterministic counterpart $dn/dt = k_b - k_d n$ for the expected copy number in the limit of large system size, discuss the consistency of the deterministic steady state with the mean of the stationary stochastic distribution.\n\nYour final answer must be the closed-form expression for the stationary $P(n)$ as a function of $n$, $k_b$, and $k_d$. No rounding is required, and no units are required since $P(n)$ is dimensionless.", "solution": "The problem statement has been validated and is deemed sound, well-posed, and scientifically grounded. It presents a canonical birth-death process, a fundamental model in stochastic chemical kinetics. We may proceed with the solution.\n\nThe system is described by two elementary reactions:\n1. Production: $\\varnothing \\xrightarrow{k_b} X$, with a constant propensity $a_1(n) = k_b$. This reaction increases the molecule count $n$ by $1$.\n2. Degradation: $X \\xrightarrow{k_d} \\varnothing$, with a mass-action propensity $a_2(n) = k_d n$. This reaction decreases the molecule count $n$ by $1$. The parameters $k_b$ and $k_d$ are positive real constants.\n\nThe state of the system is the integer copy number $n \\in \\{0, 1, 2, \\dots\\}$. Let $P(n,t)$ be the probability of being in state $n$ at time $t$. The time evolution of $P(n,t)$ is governed by the Kolmogorov forward equation, also known as the Chemical Master Equation (CME). The rate of change of $P(n,t)$ is given by the balance of probability fluxes into and out of state $n$:\n$$\n\\frac{dP(n,t)}{dt} = (\\text{flux in}) - (\\text{flux out})\n$$\nFor a general state $n \\ge 1$, the flux into state $n$ comes from production from state $n-1$ (at rate $k_b$) and degradation from state $n+1$ (at rate $k_d(n+1)$). The flux out of state $n$ goes to state $n+1$ via production (at rate $k_b$) and to state $n-1$ via degradation (at rate $k_d n$). Thus, for $n \\ge 1$:\n$$\n\\frac{dP(n,t)}{dt} = k_b P(n-1,t) + k_d(n+1)P(n+1,t) - (k_b + k_d n)P(n,t)\n$$\nFor the boundary case $n=0$, the state $n-1$ is not possible. Flux into state $0$ can only occur from state $1$ via degradation. Flux out of state $0$ can only occur to state $1$ via production. Therefore:\n$$\n\\frac{dP(0,t)}{dt} = k_d P(1,t) - k_b P(0,t)\n$$\nThe problem asks for the stationary probability mass function, $P(n)$, which is the limit of $P(n,t)$ as $t \\to \\infty$. At steady state, $\\frac{dP(n,t)}{dt} = 0$ for all $n$. Let $P(n)$ denote the stationary probability $P(n, \\infty)$. The system of equations becomes:\nFor $n \\ge 1$:\n$$\n0 = k_b P(n-1) + k_d(n+1)P(n+1) - (k_b + k_d n)P(n) \\quad (*_1)\n$$\nFor $n=0$:\n$$\n0 = k_d P(1) - k_b P(0) \\quad (*_2)\n$$\nThis is a birth-death process, for which the steady-state condition implies that the net probability flux between any two adjacent states must be zero. This condition is known as detailed balance. The flux from state $n$ to $n+1$ is due to production ($k_b P(n)$), and the flux from state $n+1$ to $n$ is due to degradation ($k_d(n+1)P(n+1)$). The detailed balance condition is:\n$$\nk_b P(n) = k_d(n+1)P(n+1) \\quad \\text{for } n \\ge 0\n$$\nThis single recurrence relation is equivalent to the infinite set of linear equations $(*_1)$ and $(*_2)$. For example, for $n=0$, it gives $k_b P(0) = k_d P(1)$, which is exactly equation $(*_2)$. Substituting $k_d(n+1)P(n+1) = k_b P(n)$ and, by shifting the index, $k_d n P(n) = k_b P(n-1)$ into equation $(*_1)$, we get $0 = k_d n P(n) + k_b P(n) - (k_b + k_d n)P(n) = 0$, confirming its validity.\n\nWe can solve this recurrence relation for $P(n)$ in terms of $P(0)$:\n$$\nP(n+1) = \\frac{k_b}{k_d(n+1)} P(n)\n$$\nLet's iterate to find the general form:\nFor $n=0$: $P(1) = \\frac{k_b}{k_d(1)}P(0)$\nFor $n=1$: $P(2) = \\frac{k_b}{k_d(2)}P(1) = \\frac{k_b}{k_d(2)}\\frac{k_b}{k_d(1)}P(0) = \\frac{1}{2 \\cdot 1}\\left(\\frac{k_b}{k_d}\\right)^2 P(0)$\nFor $n=2$: $P(3) = \\frac{k_b}{k_d(3)}P(2) = \\frac{k_b}{k_d(3)} \\frac{1}{2}\\left(\\frac{k_b}{k_d}\\right)^2 P(0) = \\frac{1}{3 \\cdot 2 \\cdot 1}\\left(\\frac{k_b}{k_d}\\right)^3 P(0)$\nBy induction, the general expression for $P(n)$ is:\n$$\nP(n) = \\frac{1}{n!} \\left(\\frac{k_b}{k_d}\\right)^n P(0)\n$$\nTo find $P(0)$, we use the normalization condition that the sum of all probabilities must be unity:\n$$\n\\sum_{n=0}^{\\infty} P(n) = 1\n$$\nSubstituting our expression for $P(n)$:\n$$\n\\sum_{n=0}^{\\infty} \\frac{1}{n!} \\left(\\frac{k_b}{k_d}\\right)^n P(0) = 1\n$$\n$$\nP(0) \\sum_{n=0}^{\\infty} \\frac{1}{n!} \\left(\\frac{k_b}{k_d}\\right)^n = 1\n$$\nThe sum is the Taylor series expansion for the exponential function, $\\sum_{k=0}^{\\infty} \\frac{x^k}{k!} = \\exp(x)$. With $x = k_b/k_d$, we have:\n$$\nP(0) \\exp\\left(\\frac{k_b}{k_d}\\right) = 1\n$$\nThis gives $P(0) = \\exp\\left(-\\frac{k_b}{k_d}\\right)$.\nSubstituting this back into the expression for $P(n)$, we obtain the final closed-form expression for the stationary probability mass function:\n$$\nP(n) = \\frac{1}{n!} \\left(\\frac{k_b}{k_d}\\right)^n \\exp\\left(-\\frac{k_b}{k_d}\\right)\n$$\nThis is the probability mass function of a Poisson distribution with parameter $\\lambda = \\frac{k_b}{k_d}$. The mean of a Poisson-distributed random variable with parameter $\\lambda$ is $\\lambda$. Therefore, the mean copy number at steady state is:\n$$\n\\langle n \\rangle = \\frac{k_b}{k_d}\n$$\nNext, we analyze the deterministic counterpart. The deterministic rate equation for the copy number $n$ is given as:\n$$\n\\frac{dn}{dt} = k_b - k_d n\n$$\nThe deterministic steady state, $n_{ss}$, is found by setting the time derivative to zero:\n$$\n0 = k_b - k_d n_{ss}\n$$\nSolving for $n_{ss}$ yields:\n$$\nn_{ss} = \\frac{k_b}{k_d}\n$$\nUpon comparison, we find that the mean of the stationary stochastic distribution, $\\langle n \\rangle$, is exactly equal to the steady state of the deterministic rate equation, $n_{ss}$. This perfect correspondence is a specific feature of systems with only zero-order and first-order reactions (i.e., linear propensities). The deterministic model, which can be viewed as an approximation that neglects fluctuations, correctly predicts the average behavior of the full stochastic system in this case. For systems involving higher-order reactions (non-linear propensities), this identity generally does not hold, and the mean of the stochastic model will deviate from the prediction of the deterministic model.", "answer": "$$\n\\boxed{\\frac{1}{n!} \\left( \\frac{k_b}{k_d} \\right)^{n} \\exp\\left(-\\frac{k_b}{k_d}\\right)}\n$$", "id": "3300898"}, {"introduction": "Many crucial biological functions arise from complex, non-linear reaction networks, such as the genetic toggle switch, which can exhibit bistability. While a deterministic model can predict the existence of multiple stable states, it fails to capture the stochastic, noise-induced transitions between them—events that are often central to cell-fate decisions. This advanced practice introduces a powerful computational technique, Forward Flux Sampling (FFS), to simulate these rare switching events and quantify their rates, showcasing how stochastic simulation is indispensable for understanding the dynamics of complex biological circuits [@problem_id:3300870].", "problem": "Consider a mutual-repression toggle-switch gene network modeled at the level of proteins, with two species $X$ and $Y$ whose copy numbers in the system state are given by $(x,y)\\in\\mathbb{N}_0^2$. Production of $X$ is repressed by $Y$, and production of $Y$ is repressed by $X$. The stochastic dynamics are governed by the Chemical Master Equation (CME), which models a continuous-time Markov chain on the lattice of nonnegative integer pairs with reactions and propensities specified as follows. The reactions are: (1) production of $X$ with stoichiometric change $(+1,0)$, (2) degradation of $X$ with stoichiometric change $(-1,0)$, (3) production of $Y$ with stoichiometric change $(0,+1)$, and (4) degradation of $Y$ with stoichiometric change $(0,-1)$. The corresponding propensity functions are $a_1(x,y)=\\alpha_X/(1+(y/K)^n)$, $a_2(x,y)=\\delta_X x$, $a_3(x,y)=\\alpha_Y/(1+(x/K)^n)$, and $a_4(x,y)=\\delta_Y y$, where $\\alpha_X$ and $\\alpha_Y$ are maximal production rates (in $\\text{molecules}\\cdot\\text{min}^{-1}$), $K$ is a repression threshold (in $\\text{molecules}$), $n$ is a Hill coefficient, and $\\delta_X$ and $\\delta_Y$ are first-order degradation rates (in $\\text{min}^{-1}$). The CME infinitesimal generator $\\mathcal{L}$ acts on functions $f:\\mathbb{N}_0^2\\to\\mathbb{R}$ by\n$$\n(\\mathcal{L}f)(x,y)=\\sum_{j=1}^4 a_j(x,y)\\left[f\\big((x,y)+\\nu_j\\big)-f(x,y)\\right],\n$$\nwhere $\\nu_1=(1,0)$, $\\nu_2=(-1,0)$, $\\nu_3=(0,1)$, and $\\nu_4=(0,-1)$.\n\nIn the deterministic limit (mean-field), the expected concentrations satisfy ordinary differential equations $dx/dt=\\alpha_X/(1+(y/K)^n)-\\delta_X x$ and $dy/dt=\\alpha_Y/(1+(x/K)^n)-\\delta_Y y$. For suitable parameter values, the system exhibits bistability with two basins of attraction corresponding to high $Y$ and low $X$ (denote this basin $A$) and high $X$ and low $Y$ (denote this basin $B$). Stochasticity induces rare switching events from $A$ to $B$.\n\nYour task is to set up the CME state representation per the above and implement a rare-event simulation strategy to estimate the switching rate $k_{A\\to B}$ (in $\\text{min}^{-1}$) from basin $A$ to basin $B$, using Forward Flux Sampling (FFS). Use the scalar order parameter $\\phi(x,y)=x-y$, and define the following regions and interfaces in the state space: basin $A$ as $\\{\\phi\\le \\phi_A\\}$, basin $B$ as $\\{\\phi\\ge \\phi_B\\}$, and intermediate interfaces $\\lambda_0<\\lambda_1<\\cdots<\\lambda_{m-1}$ with $\\phi_A<\\lambda_0$ and $\\lambda_{m-1}<\\phi_B$.\n\nForward Flux Sampling estimates the rate $k_{A\\to B}$ by the product\n$$\nk_{A\\to B}=\\Phi_A \\times \\prod_{k=0}^{m-1} P(\\lambda_{k+1}\\mid \\lambda_k),\n$$\nwhere $\\Phi_A$ is the flux of trajectories crossing $\\lambda_0$ while originating in $A$, and $P(\\lambda_{k+1}\\mid\\lambda_k)$ is the conditional probability of reaching interface $\\lambda_{k+1}$ before returning to $A$, given that the trajectory is at $\\lambda_k$. In implementation terms:\n- Estimate $\\Phi_A$ by simulating the stochastic dynamics with the Stochastic Simulation Algorithm (SSA; also known as the Gillespie algorithm), starting from an initial state deep in $A$, accumulating the total time spent in $A$ and counting crossings of $\\lambda_0$ that occur directly from $A$. Compute $\\Phi_A$ as the number of such crossings divided by the total time spent in $A$.\n- For each stage $k$, starting from a set of saved crossing states at $\\lambda_k$, launch a fixed number of trial SSA trajectories terminating upon either returning to $A$ or reaching the next interface (or $B$ at the final stage). Estimate $P(\\lambda_{k+1}\\mid\\lambda_k)$ as the fraction of trials that succeed. For $k<m-1$, collect successful crossing states at $\\lambda_{k+1}$ to seed the next stage.\n\nYou must implement the CME-based SSA exactly as outlined, using the above propensity functions and reaction stoichiometries. All time must be measured in $\\text{minutes}$, and all rates must be reported in $\\text{min}^{-1}$ as real-valued floats.\n\nTest suite. Run your program on the following three parameter sets to produce $k_{A\\to B}$ estimates:\n- Case $1$ (symmetric, moderate bistability): $\\alpha_X=\\alpha_Y=20$, $\\delta_X=\\delta_Y=1$, $K=10$, $n=2$, $\\phi_A=-14$, interfaces $\\lambda=\\{-12,-8,-4,0,4,8\\}$, $\\phi_B=12$, initial state $(x_0,y_0)=(0,20)$, flux sampling time budget in $A$ equal to $T_A=250$ minutes, maximum stored crossings at $\\lambda_0$ equal to $N_0=20$, and trials per stage equal to $M=10$.\n- Case $2$ (asymmetric production favoring $X$): $\\alpha_X=22$, $\\alpha_Y=18$, $\\delta_X=\\delta_Y=1$, $K=10$, $n=2$, $\\phi_A=-14$, interfaces $\\lambda=\\{-12,-8,-4,0,4,8\\}$, $\\phi_B=12$, initial state $(x_0,y_0)=(0,18)$, $T_A=250$ minutes, $N_0=20$, $M=10$.\n- Case $3$ (higher copy-number, reduced noise): $\\alpha_X=\\alpha_Y=26$, $\\delta_X=\\delta_Y=1$, $K=10$, $n=2$, $\\phi_A=-14$, interfaces $\\lambda=\\{-12,-8,-4,0,4,8\\}$, $\\phi_B=12$, initial state $(x_0,y_0)=(0,26)$, $T_A=300$ minutes, $N_0=20$, $M=10$.\n\nFor each case, estimate $k_{A\\to B}$ using Forward Flux Sampling as described. Your program should produce a single line of output containing the three estimated rates, in $\\text{min}^{-1}$, as a comma-separated list enclosed in square brackets, in the order of the test suite cases, for example $[r_1,r_2,r_3]$. Use a fixed pseudorandom seed so the output is reproducible.", "solution": "The rate of the rare transition event from basin $A$ (high-$Y$/low-$X$) to basin $B$ (high-$X$/low-$Y$) is estimated using the Forward Flux Sampling (FFS) algorithm. This method relies on simulating exact stochastic trajectories of the system using the Gillespie Stochastic Simulation Algorithm (SSA) and decomposing the rare event into a series of more frequent steps between interfaces defined by an order parameter, $\\phi(x,y)=x-y$.\n\n**1. Stochastic Simulation Algorithm (SSA)**\nEach trajectory is generated by iterating the following SSA steps:\n1.  For a given state $(x,y)$, calculate the four reaction propensities: $a_1(x,y) = \\alpha_X/(1+(y/K)^n)$, $a_2(x,y)=\\delta_X x$, $a_3(x,y)=\\alpha_Y/(1+(x/K)^n)$, and $a_4(x,y)=\\delta_Y y$.\n2.  Compute the total propensity, $a_{\\text{tot}} = \\sum_j a_j$.\n3.  Draw the time to the next reaction, $\\Delta t$, from an exponential distribution with rate $a_{\\text{tot}}$.\n4.  Select the reaction to occur, with probability for reaction $j$ being $a_j/a_{\\text{tot}}$.\n5.  Update the state according to the selected reaction's stoichiometry and advance time by $\\Delta t$.\n\n**2. Forward Flux Sampling (FFS) Implementation**\nThe overall rate is computed as the product $k_{A\\to B} = \\Phi_A \\prod_{k=0}^{m-1} P(\\lambda_{k+1} \\mid \\lambda_k)$.\n\n*   **Flux Estimation ($\\Phi_A$)**: A long SSA trajectory is initiated in basin $A$. The total time spent in $A$ ($T_A^{sim}$) is recorded, along with the number of times ($N_c$) the trajectory crosses from $A$ to the first interface, $\\lambda_0$. The flux is estimated as $\\Phi_A = N_c / T_A^{sim}$. States at which the system first crosses $\\lambda_0$ are collected to initialize the next stage.\n\n*   **Conditional Probability Estimation ($P(\\lambda_{k+1} \\mid \\lambda_k)$)**: This is an iterative process for each interface $\\lambda_k$ (where $\\lambda_m = \\phi_B$).\n    1.  A fixed number of trial trajectories ($M$) are initiated from states sampled from the collection of successful crossings of interface $\\lambda_k$.\n    2.  Each trial is run until it either returns to basin $A$ (failure) or reaches the next interface $\\lambda_{k+1}$ (success).\n    3.  The probability $P(\\lambda_{k+1} \\mid \\lambda_k)$ is estimated as the fraction of successful trials.\n    4.  The configurations of successful trials at $\\lambda_{k+1}$ are saved to serve as the starting pool for the subsequent stage.\n\nIf at any stage all trials fail, the conditional probability is zero, and the overall rate $k_{A \\to B}$ is consequently zero. The final rate is the product of the initial flux and all calculated conditional probabilities.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the Forward Flux Sampling algorithm to estimate the switching rate \n    for a stochastic toggle-switch model for three specified test cases.\n    \"\"\"\n\n    # Set a fixed seed for reproducibility as required by the problem.\n    np.random.seed(42)\n\n    def calculate_propensities(state, params):\n        \"\"\"Calculates the propensities for the four reactions.\"\"\"\n        x, y = state\n        alpha_X, alpha_Y, delta_X, delta_Y, K, n = params['alpha_X'], params['alpha_Y'], params['delta_X'], params['delta_Y'], params['K'], params['n']\n        \n        a1 = alpha_X / (1 + (y / K)**n)  # Production of X\n        a2 = delta_X * x                 # Degradation of X\n        a3 = alpha_Y / (1 + (x / K)**n)  # Production of Y\n        a4 = delta_Y * y                 # Degradation of Y\n        \n        return np.array([a1, a2, a3, a4])\n\n    def ssa_step(state, params):\n        \"\"\"Performs a single step of the Gillespie SSA.\"\"\"\n        propensities = calculate_propensities(state, params)\n        total_propensity = np.sum(propensities)\n        \n        if total_propensity == 0:\n            return state, np.inf\n        \n        # Time to next reaction\n        dt = np.random.exponential(1.0 / total_propensity)\n        \n        # Choose which reaction occurs\n        r = np.random.uniform(0, 1) * total_propensity\n        \n        stoichiometry = np.array([[1, 0], [-1, 0], [0, 1], [0, -1]])\n        \n        if r  propensities[0]:\n            reaction_idx = 0\n        elif r  propensities[0] + propensities[1]:\n            reaction_idx = 1\n        elif r  propensities[0] + propensities[1] + propensities[2]:\n            reaction_idx = 2\n        else:\n            reaction_idx = 3\n            \n        new_state = tuple(np.add(state, stoichiometry[reaction_idx]))\n        \n        return new_state, dt\n\n    def order_parameter(state):\n        \"\"\"Calculates the order parameter phi(x,y) = x - y.\"\"\"\n        return state[0] - state[1]\n\n    def run_ffs_case(case_params):\n        \"\"\"Runs the full Forward Flux Sampling simulation for a single case.\"\"\"\n        \n        # --- Phase 0: Flux Estimation (Phi_A) ---\n        time_in_A = 0.0\n        crossings_of_lambda0 = 0\n        saved_crossings = []\n        \n        state = case_params['initial_state']\n        \n        # Unpack FFS parameters\n        interfaces = case_params['interfaces']\n        phi_A = case_params['phi_A']\n        phi_B = case_params['phi_B']\n        lambda_0 = interfaces[0]\n        T_A_budget = case_params['T_A']\n        N_0_max = case_params['N_0']\n\n        # Flux sampling phase\n        while time_in_A  T_A_budget:\n            phi_before = order_parameter(state)\n            \n            new_state, dt = ssa_step(state, case_params)\n            \n            if phi_before = phi_A:\n                time_in_A += dt\n                phi_after = order_parameter(new_state)\n                # Check for crossing from A to outside lambda_0\n                if phi_after > lambda_0:\n                    crossings_of_lambda0 += 1\n                    if len(saved_crossings)  N_0_max:\n                        saved_crossings.append(new_state)\n            \n            state = new_state\n\n        if time_in_A == 0:\n            flux_A = 0.0\n        else:\n            flux_A = crossings_of_lambda0 / time_in_A\n        \n        if flux_A == 0.0 or not saved_crossings:\n            return 0.0\n            \n        # --- Interface Sampling Phases ---\n        cond_probs = []\n        current_configs = saved_crossings\n        \n        full_interface_list = interfaces + [phi_B]\n        \n        for k in range(len(interfaces)):\n            if not current_configs:\n                # If no configurations reached the previous interface, the chain is broken.\n                cond_probs.append(0.0)\n                continue\n                \n            lambda_k_plus_1 = full_interface_list[k+1]\n            \n            num_trials = case_params['M']\n            successes = 0\n            next_configs = []\n            \n            # Sample starting configurations for the trials, with replacement\n            start_indices = np.random.randint(0, len(current_configs), size=num_trials)\n            \n            for idx in start_indices:\n                trial_state = current_configs[idx]\n                \n                # Run trial SSA from the starting configuration\n                while True:\n                    phi = order_parameter(trial_state)\n                    \n                    # Check for termination conditions\n                    if phi = phi_A: # Returned to basin A (failure)\n                        break \n                    if phi >= lambda_k_plus_1: # Reached next interface (success)\n                        successes += 1\n                        next_configs.append(trial_state)\n                        break\n                    \n                    trial_state, _ = ssa_step(trial_state, case_params)\n            \n            prob_k = successes / num_trials if num_trials > 0 else 0.0\n            cond_probs.append(prob_k)\n            \n            current_configs = next_configs\n\n        # --- Final Rate Calculation ---\n        total_prob_product = np.prod(cond_probs)\n        k_A_to_B = flux_A * total_prob_product\n        \n        return k_A_to_B\n\n    test_cases = [\n        # Case 1 (symmetric, moderate bistability)\n        {\n            'alpha_X': 20, 'alpha_Y': 20, 'delta_X': 1, 'delta_Y': 1, 'K': 10, 'n': 2,\n            'phi_A': -14, 'interfaces': [-12, -8, -4, 0, 4, 8], 'phi_B': 12,\n            'initial_state': (0, 20), 'T_A': 250, 'N_0': 20, 'M': 10\n        },\n        # Case 2 (asymmetric production favoring X)\n        {\n            'alpha_X': 22, 'alpha_Y': 18, 'delta_X': 1, 'delta_Y': 1, 'K': 10, 'n': 2,\n            'phi_A': -14, 'interfaces': [-12, -8, -4, 0, 4, 8], 'phi_B': 12,\n            'initial_state': (0, 18), 'T_A': 250, 'N_0': 20, 'M': 10\n        },\n        # Case 3 (higher copy-number, reduced noise)\n        {\n            'alpha_X': 26, 'alpha_Y': 26, 'delta_X': 1, 'delta_Y': 1, 'K': 10, 'n': 2,\n            'phi_A': -14, 'interfaces': [-12, -8, -4, 0, 4, 8], 'phi_B': 12,\n            'initial_state': (0, 26), 'T_A': 300, 'N_0': 20, 'M': 10\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        rate = run_ffs_case(case)\n        results.append(rate)\n\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\n# Execute the solver\nsolve()\n\n```", "id": "3300870"}]}