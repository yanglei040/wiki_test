{"hands_on_practices": [{"introduction": "Understanding the function of every gene is a central goal in systems biology. This first practice lays the groundwork by tackling the prediction of single gene essentiality, which identifies genes indispensable for an organism's survival under specific conditions. By implementing a Flux Balance Analysis (FBA) simulation for single-gene knockouts, you will translate theoretical Gene-Protein-Reaction (GPR) rules into a computational workflow, a foundational skill for all subsequent genetic perturbation studies [@problem_id:3313310].", "problem": "Consider the problem of computing single gene essentiality using Flux Balance Analysis (FBA). Flux Balance Analysis (FBA) is defined on a metabolic network with a stoichiometric matrix $S \\in \\mathbb{R}^{m \\times n}$, a flux vector $v \\in \\mathbb{R}^{n}$, steady-state mass balance constraints $S v = 0$, and reaction bounds $l \\le v \\le u$, where $l \\in \\mathbb{R}^{n}$ and $u \\in \\mathbb{R}^{n}$. A linear objective $c^{\\top} v$ is maximized to represent growth, where $c \\in \\mathbb{R}^{n}$. Gene-to-reaction associations are represented by gene-protein-reaction rules using Boolean logic in disjunctive normal form, namely an OR-of-ANDs. Each reaction $i$ has an associated rule $\\mathcal{R}_i = \\bigvee_{k} \\bigwedge_{g \\in C_{i,k}} g$, where $C_{i,k}$ are clauses of gene indices; a reaction is active if and only if at least one clause is fully satisfied by the present genes. A single gene deletion removes a gene, and reactions whose rules become unsatisfied must have their bounds enforced to $v_i = 0$ by setting $l_i = u_i = 0$. A gene is defined as essential if and only if the wild-type optimal objective $z_{\\mathrm{WT}} = \\max_{v} c^{\\top} v$ under $S v = 0$ and $l \\le v \\le u$ is at least a given threshold $\\epsilon$ and the knockout optimal objective $z_{\\mathrm{KO}}$ computed under the same constraints but with rules enforced for the deleted gene is strictly less than $\\epsilon$. All numerical comparisons must use real numbers and must be implemented exactly as stated.\n\nYour task is to write a complete, runnable program that:\n- For each provided test case, computes $z_{\\mathrm{WT}}$ by solving the linear program $\\max_{v} c^{\\top} v$ subject to $S v = 0$ and $l \\le v \\le u$.\n- For each gene index $g \\in \\{0, 1, \\dots, G-1\\}$, computes $z_{\\mathrm{KO}}^{(g)}$ by enforcing gene deletion on reaction rules (setting $v_i = 0$ for reactions $i$ whose rule is unsatisfied under the deletion of gene $g$), and resolving the linear program.\n- Determines the set of essential genes for the test case as those indices $g$ such that $z_{\\mathrm{WT}} \\ge \\epsilon$ and $z_{\\mathrm{KO}}^{(g)}  \\epsilon$.\n- Produces a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, where each element is a list of integers representing the essential gene indices in ascending order for the corresponding test case (for example, $[\\,[0,2],\\,[1]\\,]$).\n\nUse the following test suite, expressed in purely mathematical terms. In every case, use the objective vector $c$ and bounds $(l, u)$ as specified. All reactions are forward irreversible unless otherwise indicated. The unit of flux is arbitrary and does not affect the logical determination; no physical units must be reported.\n\nTest Case $1$ (happy path with isoenzymes):\n- Metabolites: $m = 2$ labeled as $A$ and $B$; reactions: $n = 3$ labeled as $0, 1, 2$.\n- Stoichiometric matrix:\n$$\nS = \n\\begin{bmatrix}\n1  -1  0 \\\\\n0  1  -1\n\\end{bmatrix}.\n$$\n- Bounds:\n$$\nl = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix}, \\quad\nu = \\begin{bmatrix} 10 \\\\ 1000 \\\\ 1000 \\end{bmatrix}.\n$$\n- Objective:\n$$\nc = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\end{bmatrix}.\n$$\n- Gene count: $G = 3$ with indices $0, 1, 2$.\n- Reaction rules:\n  - Reaction $0$: no gene rule (always active).\n  - Reaction $1$: $(0) \\lor (1)$.\n  - Reaction $2$: $(2)$.\n- Threshold: $\\epsilon = 10^{-6}$.\n\nTest Case $2$ (boundary with complex requirement):\n- Same $S$, $c$, and $l, u$ as in Test Case $1$.\n- Gene count: $G = 3$ with indices $0, 1, 2$.\n- Reaction rules:\n  - Reaction $0$: no gene rule (always active).\n  - Reaction $1$: $(0 \\land 1)$.\n  - Reaction $2$: $(2)$.\n- Threshold: $\\epsilon = 10^{-6}$.\n\nTest Case $3$ (edge case with zero wild-type growth and an unmapped gene):\n- Stoichiometric matrix:\n$$\nS = \n\\begin{bmatrix}\n1  -1  0 \\\\\n0  1  -1\n\\end{bmatrix}.\n$$\n- Bounds:\n$$\nl = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix}, \\quad\nu = \\begin{bmatrix} 0 \\\\ 1000 \\\\ 1000 \\end{bmatrix}.\n$$\n- Objective:\n$$\nc = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\end{bmatrix}.\n$$\n- Gene count: $G = 4$ with indices $0, 1, 2, 3$.\n- Reaction rules:\n  - Reaction $0$: no gene rule (always active).\n  - Reaction $1$: $(0) \\lor (1)$.\n  - Reaction $2$: $(2)$.\n- Threshold: $\\epsilon = 10^{-6}$.\n\nTest Case $4$ (numerical threshold boundary):\n- Stoichiometric matrix:\n$$\nS = \n\\begin{bmatrix}\n1  -1  0 \\\\\n0  1  -1\n\\end{bmatrix}.\n$$\n- Bounds:\n$$\nl = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix}, \\quad\nu = \\begin{bmatrix} 10^{-6} \\\\ 1000 \\\\ 1000 \\end{bmatrix}.\n$$\n- Objective:\n$$\nc = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\end{bmatrix}.\n$$\n- Gene count: $G = 3$ with indices $0, 1, 2$.\n- Reaction rules:\n  - Reaction $0$: no gene rule (always active).\n  - Reaction $1$: $(0) \\lor (1)$.\n  - Reaction $2$: $(2)$.\n- Threshold: $\\epsilon = 10^{-6}$.\n\nYour program must construct and solve each linear program, enforce gene deletions by zeroing the bounds of reactions whose gene rules become unsatisfied, determine essential genes using the stated criterion, and output a single line in the exact format $[\\text{case}_1,\\text{case}_2,\\text{case}_3,\\text{case}_4]$ where each $\\text{case}_k$ is a Python-style list of integers representing essential gene indices in ascending order for Test Case $k$.", "solution": "The problem statement has been meticulously reviewed and is determined to be valid. It is scientifically grounded in the established principles of computational systems biology, specifically Flux Balance Analysis (FBA) and metabolic network modeling. The problem is well-posed, providing all necessary mathematical definitions and data ($S$, $l$, $u$, $c$, gene-protein-reaction rules, and the essentiality threshold $\\epsilon$) for each test case. The language is objective and precise, leaving no room for ambiguity. The task is to implement a standard in-silico gene essentiality analysis, which is a formalizable and verifiable computational problem.\n\nThe solution proceeds by first principles, beginning with the mathematical formulation of Flux Balance Analysis. FBA models the behavior of a metabolic network at steady-state. The core of FBA is a linear program (LP) designed to find a particular flux distribution $v$ through all reactions in the network that optimizes a given cellular objective, such as the production of biomass.\n\nThe FBA problem in its general form is:\n$$\n\\begin{align*}\n\\text{maximize} \\quad  z = c^{\\top} v \\\\\n\\text{subject to} \\quad  S v = \\mathbf{0} \\\\\n l \\le v \\le u\n\\end{align*}\n$$\nwhere:\n- $v \\in \\mathbb{R}^{n}$ is the vector of reaction fluxes for the $n$ reactions in the network.\n- $S \\in \\mathbb{R}^{m \\times n}$ is the stoichiometric matrix, representing the mass balance of the $m$ metabolites.\n- $c \\in \\mathbb{R}^{n}$ is the objective vector, defining the linear combination of fluxes to be maximized (e.g., a \"biomass reaction\").\n- $l, u \\in \\mathbb{R}^{n}$ are the lower and upper bounds on the individual reaction fluxes, respectively, constraining reaction rates due to thermodynamic and enzymatic capacity limitations.\n- The constraint $S v = \\mathbf{0}$ enforces the steady-state assumption, meaning that for each metabolite, the total rate of production equals the total rate of consumption.\n\nGene-to-reaction associations are encoded by Gene-Protein-Reaction (GPR) rules. The problem specifies these rules in Disjunctive Normal Form (DNF), an OR-of-ANDs. A reaction $i$ is catalyzed, and thus can carry flux, if and only if its GPR rule $\\mathcal{R}_i$ is evaluated to be true. The rule $\\mathcal{R}_i = \\bigvee_{k} \\bigwedge_{g \\in C_{i,k}} g$ is true if at least one of its AND-clauses $C_{i,k}$ is true. A clause is true if all genes $g$ within it are present and functional.\n\nA single gene deletion simulation involves designating a specific gene $g$ as absent. This may cause some GPR rules to evaluate to false. If the rule $\\mathcal{R}_i$ for reaction $i$ becomes false, that reaction is considered \"knocked out\". This is enforced in the model by setting the bounds for that reaction's flux to zero, i.e., $l_i = u_i = 0$, thereby forcing $v_i = 0$.\n\nThe determination of gene essentiality follows a precise criterion. A gene $g$ is essential if and only if two conditions are met:\n$1$. The optimal objective value for the wild-type (WT) organism, $z_{\\mathrm{WT}}$, is greater than or equal to a viability threshold $\\epsilon$, i.e., $z_{\\mathrm{WT}} \\ge \\epsilon$.\n$2$. The optimal objective value for the knockout (KO) organism, where gene $g$ has been deleted, $z_{\\mathrm{KO}}^{(g)}$, is strictly less than this threshold, i.e., $z_{\\mathrm{KO}}^{(g)}  \\epsilon$.\n\nThe algorithm to solve the problem for each test case is as follows:\n\n1.  **Parse GPR Rules**: The provided Boolean rules are parsed into a data structure amenable to computation. A list of lists of lists is suitable, where the outer list corresponds to reactions, the middle list to OR-clauses, and the inner list to AND-ed genes. For a reaction without a rule, a special value (e.g., `None`) is used.\n2.  **Solve for Wild-Type Growth**: An LP is formulated and solved using the original bounds ($l, u$) to compute the wild-type optimal objective, $z_{\\mathrm{WT}}$. This is achieved using a numerical LP solver. Note that standard solvers like `scipy.optimize.linprog` perform minimization. To maximize $c^{\\top}v$, we minimize $-c^{\\top}v$, and the resulting optimal value is negated.\n3.  **Assess Wild-Type Viability**: The computed $z_{\\mathrm{WT}}$ is compared to the threshold $\\epsilon$. If $z_{\\mathrm{WT}}  \\epsilon$, the organism is considered non-viable from the start, and by definition, no gene can be essential. The result for this case is an empty set.\n4.  **Perform Single Gene Deletion Analysis**: If $z_{\\mathrm{WT}} \\ge \\epsilon$, we proceed to test each gene. For each gene index $g \\in \\{0, 1, ..., G-1\\}$:\n    a. A new set of flux bounds, $(l_{\\mathrm{KO}}, u_{\\mathrm{KO}})$, is initialized from the wild-type bounds $(l, u)$.\n    b. For each reaction $i$, its GPR rule $\\mathcal{R}_i$ is evaluated under the condition that gene $g$ is absent.\n    c. If $\\mathcal{R}_i$ evaluates to false, the reaction is knocked out by setting its bounds to zero: $l_{\\mathrm{KO}, i} = 0$ and $u_{\\mathrm{KO}, i} = 0$.\n    d. A new LP is solved with these modified bounds to compute the knockout objective value, $z_{\\mathrm{KO}}^{(g)}$.\n    e. The essentiality criterion is applied: if $z_{\\mathrm{KO}}^{(g)}  \\epsilon$, gene $g$ is added to the list of essential genes for the current test case.\n5.  **Aggregate and Format Results**: After iterating through all genes, the list of essential gene indices is sorted in ascending order. This process is repeated for all test cases. The final output is a formatted string containing the lists of essential genes for each case.", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves for essential genes in a series of metabolic models\n    using Flux Balance Analysis (FBA).\n    \"\"\"\n\n    test_cases = [\n        # Test Case 1: happy path with isoenzymes\n        {\n            \"S\": np.array([[1, -1, 0], [0, 1, -1]], dtype=np.float64),\n            \"l\": np.array([0, 0, 0], dtype=np.float64),\n            \"u\": np.array([10, 1000, 1000], dtype=np.float64),\n            \"c\": np.array([0, 0, 1], dtype=np.float64),\n            \"G\": 3,\n            \"gpr_rules\": [None, [[0], [1]], [[2]]],\n            \"epsilon\": 1e-6,\n        },\n        # Test Case 2: boundary with complex requirement\n        {\n            \"S\": np.array([[1, -1, 0], [0, 1, -1]], dtype=np.float64),\n            \"l\": np.array([0, 0, 0], dtype=np.float64),\n            \"u\": np.array([10, 1000, 1000], dtype=np.float64),\n            \"c\": np.array([0, 0, 1], dtype=np.float64),\n            \"G\": 3,\n            \"gpr_rules\": [None, [[0, 1]], [[2]]],\n            \"epsilon\": 1e-6,\n        },\n        # Test Case 3: edge case with zero wild-type growth and an unmapped gene\n        {\n            \"S\": np.array([[1, -1, 0], [0, 1, -1]], dtype=np.float64),\n            \"l\": np.array([0, 0, 0], dtype=np.float64),\n            \"u\": np.array([0, 1000, 1000], dtype=np.float64),\n            \"c\": np.array([0, 0, 1], dtype=np.float64),\n            \"G\": 4,\n            \"gpr_rules\": [None, [[0], [1]], [[2]]],\n            \"epsilon\": 1e-6,\n        },\n        # Test Case 4: numerical threshold boundary\n        {\n            \"S\": np.array([[1, -1, 0], [0, 1, -1]], dtype=np.float64),\n            \"l\": np.array([0, 0, 0], dtype=np.float64),\n            \"u\": np.array([1e-6, 1000, 1000], dtype=np.float64),\n            \"c\": np.array([0, 0, 1], dtype=np.float64),\n            \"G\": 3,\n            \"gpr_rules\": [None, [[0], [1]], [[2]]],\n            \"epsilon\": 1e-6,\n        },\n    ]\n\n    all_results = []\n\n    def run_fba(c_obj, S, l_bounds, u_bounds):\n        \"\"\"Helper to run a single FBA linear program.\"\"\"\n        m, n = S.shape\n        bounds = list(zip(l_bounds, u_bounds))\n        # scipy.optimize.linprog minimizes, so we minimize -c to maximize c\n        res = linprog(-c_obj, A_eq=S, b_eq=np.zeros(m), bounds=bounds, method='highs')\n        \n        # If solver is successful, return the maximized objective. Otherwise, 0.\n        # The zero vector is always feasible in these problems, so infeasibility implies 0 growth.\n        # Unboundedness is not possible with finite upper bounds.\n        if res.success:\n            return -res.fun\n        return 0.0\n\n    def is_reaction_active(rule, deleted_gene_idx):\n        \"\"\"Evaluates a GPR rule given a deleted gene.\"\"\"\n        if rule is None:\n            return True  # Reaction always active if no rule\n        \n        # OR logic over clauses\n        for clause in rule:\n            is_clause_satisfied = True\n            # AND logic over genes in a clause\n            for gene in clause:\n                if gene == deleted_gene_idx:\n                    is_clause_satisfied = False\n                    break\n            if is_clause_satisfied:\n                return True # One satisfied clause is enough\n        \n        return False # No clause was satisfied\n\n    for case in test_cases:\n        S, l, u, c = case[\"S\"], case[\"l\"], case[\"u\"], case[\"c\"]\n        G, gpr_rules, epsilon = case[\"G\"], case[\"gpr_rules\"], case[\"epsilon\"]\n        \n        # 1. Compute wild-type growth\n        z_wt = run_fba(c, S, l, u)\n\n        # 2. Check for viability. If not viable, no genes are essential.\n        if z_wt  epsilon:\n            all_results.append([])\n            continue\n\n        # 3. Perform single gene deletion analysis\n        essential_genes = []\n        for g_idx in range(G):\n            # Create copies of bounds for the knockout simulation\n            l_ko, u_ko = l.copy(), u.copy()\n\n            # Apply GPR logic for the deleted gene\n            for i, rule in enumerate(gpr_rules):\n                if not is_reaction_active(rule, g_idx):\n                    # Knock out the reaction by setting bounds to 0\n                    l_ko[i] = 0.0\n                    u_ko[i] = 0.0\n            \n            # Compute knockout growth\n            z_ko = run_fba(c, S, l_ko, u_ko)\n\n            # 4. Check essentiality criterion\n            if z_ko  epsilon:\n                essential_genes.append(g_idx)\n        \n        essential_genes.sort()\n        all_results.append(essential_genes)\n\n    # 5. Format output\n    formatted_results = []\n    for res_list in all_results:\n        # Convert list to string like '[1,2,3]' and remove spaces\n        s = str(res_list).replace(\" \", \"\")\n        formatted_results.append(s)\n\n    # Join the strings with commas and enclose in brackets\n    output_str = f\"[{','.join(formatted_results)}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3313310"}, {"introduction": "Building upon the single-deletion framework, we now explore the powerful concept of synthetic lethality, where the simultaneous loss of two non-essential genes proves fatal. This phenomenon reveals the robustness and redundancy within metabolic networks and is a cornerstone of modern strategies for developing targeted cancer therapies. This exercise challenges you to implement a double-gene deletion simulation to systematically identify these crucial genetic interactions [@problem_id:3313293].", "problem": "You are given a minimal, steady-state metabolic network and asked to implement double gene deletion simulations to determine synthetic lethality using Flux Balance Analysis (FBA). From first principles, FBA assumes intracellular concentrations are at quasi-steady state, imposing the linear constraints $$S \\, v = 0,$$ where $S$ is the stoichiometric matrix, and $v$ is the reaction flux vector. Reaction fluxes are bounded by $$\\ell \\le v \\le u,$$ where $\\ell$ and $u$ are the lower and upper bounds. A cellular growth surrogate is represented by maximizing a linear objective function $$\\max_{v} \\; c^\\top v.$$ Gene deletions propagate to reaction knockouts by the Gene-Protein-Reaction (GPR) mapping: if a gene required by a reaction is deleted, the corresponding reaction’s flux bounds are set to zero. Viability is defined by whether the optimal objective value is at least a threshold; synthetic lethality for a gene pair means each single deletion is viable while the double deletion is not.\n\nNetwork definition:\n- Metabolites: internal glucose $G$, intermediate $X$, and intermediate $Y$.\n- Reactions:\n    - $r_1$: glucose uptake, written as external source to internal $G$.\n    - $r_2$: $G \\rightarrow X$.\n    - $r_3$: $G \\rightarrow Y$.\n    - $r_4$: $X + Y \\rightarrow$ biomass drain.\n    - $r_5$: $G \\rightarrow$ biomass drain.\n- Stoichiometric matrix $S \\in \\mathbb{R}^{3 \\times 5}$ with metabolite rows ordered $(G, X, Y)$ and reaction columns ordered $(r_1, r_2, r_3, r_4, r_5)$:\n$$\nS =\n\\begin{bmatrix}\n+1  -1  -1  0  -1 \\\\\n0  +1  0  -1  0 \\\\\n0  0  +1  -1  0 \\\\\n\\end{bmatrix}.\n$$\n- The objective function is the sum of biomass-producing fluxes, i.e., $c = [0, 0, 0, 1, 1]^\\top$, so the objective value is $v_4 + v_5$.\n- Bounds:\n    - All reactions are irreversible with lower bounds $\\ell_i = 0$ for $i \\in \\{1,2,3,4,5\\}$.\n    - The glucose uptake reaction $r_1$ has upper bound $u_1 = U$, where $U$ is a nonnegative constant (in mmol per gram dry weight per hour, abbreviated mmol/(gDW·h)).\n    - All other reactions have upper bounds $u_i = L$ for $i \\in \\{2,3,4,5\\}$, where $L$ is a large finite constant (use $L = 10^6$).\n- Gene-Protein-Reaction (GPR) mapping:\n    - $r_2$ requires gene $gA$.\n    - $r_3$ requires gene $gB$.\n    - $r_4$ requires gene $gC$.\n    - $r_5$ requires gene $gD$.\n    - $r_1$ (uptake) is treated as environmentally constrained and not gene-limited in this setup.\n- Gene deletion rule: deleting gene $g$ sets $u_j = \\ell_j = 0$ for every reaction $r_j$ whose GPR requires $g$, while other bounds remain unchanged.\n- Viability criterion: given threshold $\\tau \\ge 0$ (in mmol/(gDW·h)), a strain is viable if the optimal objective value satisfies $v_4^\\star + v_5^\\star \\ge \\tau$.\n- Synthetic lethality criterion for a gene pair $(g_p, g_q)$: both single deletions are viable, the double deletion is non-viable, and the wild-type is viable, all evaluated at the same $(U, \\tau)$.\n\nTask:\n- Implement a program that, for each test case, performs:\n    - Wild-type FBA to compute the optimal objective value.\n    - Single deletions of $g_p$ and $g_q$ separately and FBA for each.\n    - Double deletion of $(g_p, g_q)$ and FBA.\n    - Returns a boolean indicating synthetic lethality as defined above.\n\nAll fluxes and thresholds are in mmol/(gDW·h); no other units are involved. Angles are not used. The final outputs are booleans.\n\nTest suite:\n- Case $1$: $(gA, gD)$ with $U = 10$ and $\\tau = 1.0$.\n- Case $2$: $(gA, gB)$ with $U = 10$ and $\\tau = 0.5$.\n- Case $3$: $(gB, gD)$ with $U = 8$ and $\\tau = 4.0$.\n- Case $4$: $(gA, gD)$ with $U = 0$ and $\\tau = 0.0$.\n- Case $5$: $(gC, gD)$ with $U = 6$ and $\\tau = 2.5$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[{\\text{True}},{\\text{False}},\\dots]$) with no spaces.", "solution": "We begin from the steady-state mass balance assumption that intracellular metabolite concentrations are approximately constant on the timescale of interest, which yields the linear constraints $$S \\, v = 0,$$ where $S$ is the stoichiometric matrix and $v$ is the reaction flux vector. Flux Balance Analysis (FBA) poses a linear program: $$\\max_{v} \\; c^\\top v \\quad \\text{subject to} \\quad S v = 0, \\quad \\ell \\le v \\le u.$$ This relies on the widely used and well-tested observation that at steady state, metabolic fluxes redistribute to maximize a cellular objective under physicochemical constraints.\n\nIn our network, metabolites are $G$, $X$, and $Y$, and reactions are ordered $(r_1, r_2, r_3, r_4, r_5)$ with stoichiometry\n$$\nS =\n\\begin{bmatrix}\n+1  -1  -1  0  -1 \\\\\n0  +1  0  -1  0 \\\\\n0  0  +1  -1  0 \\\\\n\\end{bmatrix}.\n$$\nThe constraints unpack to:\n- For metabolite $G$: $$+1 \\cdot v_1 - 1 \\cdot v_2 - 1 \\cdot v_3 - 1 \\cdot v_5 = 0.$$\n- For metabolite $X$: $$+1 \\cdot v_2 - 1 \\cdot v_4 = 0 \\;\\Rightarrow\\; v_4 = v_2.$$\n- For metabolite $Y$: $$+1 \\cdot v_3 - 1 \\cdot v_4 = 0 \\;\\Rightarrow\\; v_4 = v_3.$$\n\nHence at steady state, the $X$ and $Y$ channel to biomass via $r_4$ requires equal fluxes $v_2 = v_3 = v_4$, while $G$ is balanced by $v_1 = v_2 + v_3 + v_5 = 2 v_4 + v_5$. All reactions are irreversible with lower bounds $\\ell_i = 0$. The uptake reaction has upper bound $u_1 = U$ (mmol/(gDW·h)), and internal reactions have large upper bounds $u_i = L$ for $i \\in \\{2,3,4,5\\}$ with $L = 10^6$. The objective is to maximize $$c^\\top v = v_4 + v_5.$$\n\nGenes regulate reactions via Gene-Protein-Reaction (GPR) mapping: $gA \\rightarrow r_2$, $gB \\rightarrow r_3$, $gC \\rightarrow r_4$, $gD \\rightarrow r_5$. Deleting a gene sets the corresponding reaction bounds to zero ($\\ell_j = u_j = 0$), effectively removing the reaction from the feasible set. Viability is defined by whether the optimal objective value satisfies $$v_4^\\star + v_5^\\star \\ge \\tau,$$ where $\\tau$ is a given threshold (mmol/(gDW·h)). Synthetic lethality for $(g_p, g_q)$ holds if the wild type is viable, both single deletions are viable, and the double deletion is non-viable, when evaluated under the same $(U, \\tau)$.\n\nAlgorithmic design:\n- Formulate the linear program for each condition (wild type, single deletions, double deletion) using the same stoichiometric constraints and bounds, with gene deletions applying zero bounds to reactions that require the deleted gene(s).\n- Use a linear programming solver to maximize $c^\\top v$. Since common solvers minimize, we minimize $-c^\\top v$ equivalently. The equality constraints $S v = 0$ and bounds $\\ell \\le v \\le u$ are enforced.\n- Compute the optimal objective value $z^\\star = v_4^\\star + v_5^\\star$ for each condition and compare against the threshold $\\tau$ to determine viability and synthetic lethality.\n\nReasoning about the network structure provides intuition:\n- With all reactions present, the $G \\rightarrow$ biomass via $r_5$ uses $1$ unit of $G$ per unit of objective, while the $X + Y \\rightarrow$ biomass via $r_4$ requires $2$ units of $G$ per unit of objective (because $v_2 = v_3 = v_4$ and each consumes $1$ unit of $G$). Therefore, for a fixed uptake limit $U$, the optimal solution prefers $r_5$ (direct path) and yields $$z^\\star_{\\text{WT}} = U.$$\n- If $r_5$ is deleted (by deleting $gD$), the only growth path is via $r_4$, which requires $2$ units of $G$ per unit growth, yielding $$2 v_4 \\le U \\;\\Rightarrow\\; z^\\star_{\\text{single }gD} = v_4^\\star \\le \\frac{U}{2}.$$ With large internal bounds, the optimal choice is $v_4^\\star = \\frac{U}{2}$ so $$z^\\star_{\\text{single }gD} = \\frac{U}{2}.$$\n- If either $r_2$ or $r_3$ is deleted (by deleting $gA$ or $gB$), then $v_4 = 0$ by stoichiometry, and the only growth path is via $r_5$ if present, yielding $$z^\\star_{\\text{single }gA} = U \\quad \\text{and} \\quad z^\\star_{\\text{single }gB} = U.$$\n- For double deletions:\n    - $(gA, gD)$ deletes $r_2$ and $r_5$, leaving $r_3$ and $r_4$ but with $v_2 = 0$ the equality $v_4 = v_2$ implies $v_4 = 0$, and with $r_5$ deleted there is no alternative, so $$z^\\star_{\\text{double }(gA,gD)} = 0.$$\n    - $(gB, gD)$ is symmetric to $(gA, gD)$, also yielding $$z^\\star_{\\text{double }(gB,gD)} = 0.$$\n    - $(gA, gB)$ deletes both $r_2$ and $r_3$, so $v_4 = 0$ but $r_5$ remains, yielding $$z^\\star_{\\text{double }(gA,gB)} = U.$$\n    - $(gC, gD)$ deletes both biomass reactions $r_4$ and $r_5$, yielding $$z^\\star_{\\text{double }(gC,gD)} = 0.$$\n\nApplying thresholds:\n- Case $1$: $(gA, gD)$, $U = 10$, $\\tau = 1.0$.\n    - Wild type: $10 \\ge 1.0$ viable.\n    - Single $gA$: $10 \\ge 1.0$ viable; single $gD$: $5 \\ge 1.0$ viable.\n    - Double: $0  1.0$ non-viable.\n    - Synthetic lethal: True.\n- Case $2$: $(gA, gB)$, $U = 10$, $\\tau = 0.5$.\n    - Wild type: $10 \\ge 0.5$ viable.\n    - Single $gA$: $10 \\ge 0.5$ viable; single $gB$: $10 \\ge 0.5$ viable.\n    - Double: $10 \\ge 0.5$ viable.\n    - Synthetic lethal: False.\n- Case $3$: $(gB, gD)$, $U = 8$, $\\tau = 4.0$.\n    - Wild type: $8 \\ge 4.0$ viable.\n    - Single $gB$: $8 \\ge 4.0$ viable; single $gD$: $\\frac{8}{2} = 4.0 \\ge 4.0$ viable at equality.\n    - Double: $0  4.0$ non-viable.\n    - Synthetic lethal: True.\n- Case $4$: $(gA, gD)$, $U = 0$, $\\tau = 0.0$.\n    - Wild type: $0 \\ge 0.0$ viable at equality.\n    - Single $gA$: $0 \\ge 0.0$ viable; single $gD$: $0 \\ge 0.0$ viable.\n    - Double: $0 \\ge 0.0$ viable.\n    - Synthetic lethal: False.\n- Case $5$: $(gC, gD)$, $U = 6$, $\\tau = 2.5$.\n    - Wild type: $6 \\ge 2.5$ viable.\n    - Single $gC$: $6 \\ge 2.5$ viable; single $gD$: $3 \\ge 2.5$ viable.\n    - Double: $0  2.5$ non-viable.\n    - Synthetic lethal: True.\n\nThus, the expected boolean outcomes in order are $[{\\text{True}},{\\text{False}},{\\text{True}},{\\text{False}},{\\text{True}}]$. The program implements the linear programming for generality and reproduces these results by solving the optimization for each case and applying the synthetic lethality criterion.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef fba_growth(U, deleted_genes):\n    \"\"\"\n    Compute the maximal growth (objective value v4 + v5) for the given uptake bound U\n    and a set of deleted genes under steady-state FBA with linear constraints.\n    \"\"\"\n    # Stoichiometric matrix S for metabolites (G, X, Y) and reactions (r1..r5)\n    S = np.array([\n        [ 1.0, -1.0, -1.0,  0.0, -1.0],  # G balance\n        [ 0.0,  1.0,  0.0, -1.0,  0.0],  # X balance\n        [ 0.0,  0.0,  1.0, -1.0,  0.0],  # Y balance\n    ])\n\n    # Objective c: maximize v4 + v5 - in linprog, minimize -c^T v\n    c = np.array([0.0, 0.0, 0.0, 1.0, 1.0])\n    c_min = -c  # since linprog minimizes\n\n    # Large upper bound for internal reactions\n    L = 1e6\n\n    # Base bounds: all irreversible, r1 upper bound = U\n    lower_bounds = np.zeros(5, dtype=float)\n    upper_bounds = np.array([U, L, L, L, L], dtype=float)\n\n    # Gene-to-reaction mapping\n    gene_to_reactions = {\n        'gA': [1],  # r2\n        'gB': [2],  # r3\n        'gC': [3],  # r4\n        'gD': [4],  # r5\n        # r1 uptake is environmentally constrained (no gene mapping)\n    }\n\n    # Apply gene deletions: set bounds of mapped reactions to zero\n    for g in deleted_genes:\n        for rxn_idx in gene_to_reactions.get(g, []):\n            lower_bounds[rxn_idx] = 0.0\n            upper_bounds[rxn_idx] = 0.0\n\n    bounds = list(zip(lower_bounds.tolist(), upper_bounds.tolist()))\n\n    # Equality constraints Sv = 0\n    A_eq = S\n    b_eq = np.zeros(S.shape[0], dtype=float)\n\n    # Solve LP\n    res = linprog(c=c_min, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n    if not res.success:\n        # If infeasible or solver failed, return 0.0 growth (conservative)\n        return 0.0\n\n    v = res.x\n    growth = float(v[3] + v[4])  # v4 + v5\n    # Numerical safety: tiny negative due to tolerance - clip to 0\n    if growth  0 and growth > -1e-9:\n        growth = 0.0\n    return growth\n\ndef is_synthetic_lethal(g1, g2, U, tau):\n    \"\"\"\n    Determine synthetic lethality for a gene pair (g1, g2) under (U, tau):\n    WT viable, both singles viable, double non-viable.\n    \"\"\"\n    wt_growth = fba_growth(U, deleted_genes=[])\n    g1_growth = fba_growth(U, deleted_genes=[g1])\n    g2_growth = fba_growth(U, deleted_genes=[g2])\n    double_growth = fba_growth(U, deleted_genes=[g1, g2])\n\n    wt_ok = wt_growth >= tau\n    singles_ok = (g1_growth >= tau) and (g2_growth >= tau)\n    double_fail = double_growth  tau\n\n    return wt_ok and singles_ok and double_fail\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (gene1, gene2, U, tau)\n    test_cases = [\n        ('gA', 'gD', 10.0, 1.0),   # Case 1\n        ('gA', 'gB', 10.0, 0.5),   # Case 2\n        ('gB', 'gD', 8.0, 4.0),    # Case 3\n        ('gA', 'gD', 0.0, 0.0),    # Case 4\n        ('gC', 'gD', 6.0, 2.5),    # Case 5\n    ]\n\n    results = []\n    for g1, g2, U, tau in test_cases:\n        result = is_synthetic_lethal(g1, g2, U, tau)\n        results.append(result)\n\n    # Final print statement in the exact required format: no spaces.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3313293"}, {"introduction": "A proficient computational biologist not only knows how to run a simulation but also understands its underlying assumptions and potential pitfalls. This advanced practice moves beyond simple implementation to a critical evaluation of methodology, focusing on the concept of alternative optima in FBA solutions. You will compare the rigorous, re-optimization-based approach for predicting synthetic lethality against a common but flawed 'naive' projection method, providing direct insight into why careful handling of the FBA solution space is essential for generating reliable predictions [@problem_id:3313299].", "problem": "You are asked to implement a complete, runnable program that performs constraint-based simulations to predict synthetic lethal gene pairs using steady-state linear optimization of a biochemical network. The fundamental base is the steady-state mass balance and bound-constrained linear programming used in Flux Balance Analysis (FBA). Specifically, consider a stoichiometric matrix $S \\in \\mathbb{R}^{m \\times n}$, a flux vector $v \\in \\mathbb{R}^n$, lower and upper bounds $l \\in \\mathbb{R}^n$ and $u \\in \\mathbb{R}^n$, an objective coefficient vector $c \\in \\mathbb{R}^n$, and a gene-to-reaction mapping. Under the quasi-steady-state assumption (no intracellular accumulation), all internal metabolites satisfy the mass balance constraint $S v = 0$. The feasible flux space is defined by $l \\le v \\le u$. The biomass production rate is represented by the linear objective $c^\\top v$, which must be maximized for a given genotype and medium. A gene deletion is modeled as a set of reaction flux constraints $v_j = 0$ for all reactions $j$ controlled by the deleted gene. A gene pair $\\{g_i,g_j\\}$ is synthetic lethal if and only if the following three conditions hold simultaneously under the specified medium: (i) the wild-type flux balance analysis yields $\\max c^\\top v  \\varepsilon$, (ii) both single deletions $\\{g_i\\}$ and $\\{g_j\\}$ yield $\\max c^\\top v  \\varepsilon$, and (iii) the double deletion $\\{g_i,g_j\\}$ yields $\\max c^\\top v \\le \\varepsilon$, where $\\varepsilon = 10^{-9}$ is a small viability threshold. You must also implement a naive classifier that does not re-optimize after deletions: it first computes a single wild-type optimal flux vector $v^\\star$ that maximizes $c^\\top v$, then predicts that a gene pair is lethal if simply zeroing the corresponding reaction fluxes in $v^\\star$ yields a vector that either violates $S v = 0$ (beyond a small tolerance) or has $c^\\top v \\le \\varepsilon$. This naive method is intended to illustrate how alternative optimal solutions can inflate false positives by relying on a single optimal reference flux rather than re-optimizing after each deletion.\n\nYour program must implement both the correct FBA-based synthetic lethality test and the naive projection-based test and apply them to the following test suite. All linear programs must be solved exactly as stated; no heuristic shortcuts may be used. Angles do not appear. There are no physical units required in the output. All results must be numerical: booleans, integers, floats, or lists of these, as specified below.\n\nTest Suite:\n\nTest Case $1$ (parallel pathways with alternative optima):\n\n- Internal metabolites: $G$, $P$.\n\n- Reactions (columns of $S$) with indices $0,1,2,3,4$:\n  - Exchange uptake $r_0$: $\\varnothing \\rightarrow G$.\n  - Pathway $1$ $r_1$: $G \\rightarrow P$.\n  - Pathway $2$ $r_2$: $G \\rightarrow P$.\n  - Biomass drain $r_3$: $P \\rightarrow \\varnothing$.\n  - Waste drain $r_4$: $G \\rightarrow \\varnothing$.\n\n- Stoichiometric matrix $S \\in \\mathbb{R}^{2 \\times 5}$ with metabolite order $(G,P)$ and reaction order $(r_0,r_1,r_2,r_3,r_4)$:\n  $$\n  S = \\begin{bmatrix}\n  1  -1  -1  0  -1 \\\\\n  0  1  1  -1  0\n  \\end{bmatrix}.\n  $$\n\n- Bounds $l \\le v \\le u$:\n  $$\n  l = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix},\\quad\n  u = \\begin{bmatrix} 10 \\\\ 10 \\\\ 4 \\\\ 1000 \\\\ 1000 \\end{bmatrix}.\n  $$\n\n- Objective coefficients for biomass:\n  $$\n  c = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 1 \\\\ 0 \\end{bmatrix}.\n  $$\n\n- Genes and mapping to reactions:\n  - $g_1 \\mapsto \\{r_1\\}$,\n  - $g_2 \\mapsto \\{r_2\\}$,\n  - $g_3 \\mapsto \\{r_3\\}$,\n  - $g_4 \\mapsto \\{r_4\\}$.\n\n- Gene pairs to evaluate (indexed for reporting): index $0$: $(g_1,g_2)$, index $1$: $(g_1,g_4)$, index $2$: $(g_2,g_4)$.\n\nTest Case $2$ (no substrate boundary case):\n\n- Same $S$, $c$, genes, and pairs as in Test Case $1$, but with uptake disabled by tightening the bound of $r_0$:\n  $$\n  l = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix},\\quad\n  u = \\begin{bmatrix} 0 \\\\ 10 \\\\ 4 \\\\ 1000 \\\\ 1000 \\end{bmatrix}.\n  $$\n\nTest Case $3$ (orphan gene and non-synthetic lethals):\n\n- Internal metabolites: $A$, $P$.\n\n- Reactions (columns of $S$) with indices $0,1,2,3$:\n  - Exchange uptake $r_0$: $\\varnothing \\rightarrow A$.\n  - Synthesis $r_1$: $A \\rightarrow P$.\n  - Biomass drain $r_2$: $P \\rightarrow \\varnothing$.\n  - Side drain $r_3$: $A \\rightarrow \\varnothing$.\n\n- Stoichiometric matrix $S \\in \\mathbb{R}^{2 \\times 4}$ with metabolite order $(A,P)$ and reaction order $(r_0,r_1,r_2,r_3)$:\n  $$\n  S = \\begin{bmatrix}\n  1  -1  0  -1 \\\\\n  0  1  -1  0\n  \\end{bmatrix}.\n  $$\n\n- Bounds $l \\le v \\le u$:\n  $$\n  l = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix},\\quad\n  u = \\begin{bmatrix} 5 \\\\ 5 \\\\ 1000 \\\\ 1000 \\end{bmatrix}.\n  $$\n\n- Objective coefficients for biomass:\n  $$\n  c = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\\\ 0 \\end{bmatrix}.\n  $$\n\n- Genes and mapping to reactions:\n  - $g_a \\mapsto \\{r_1\\}$,\n  - $g_b \\mapsto \\{r_2\\}$,\n  - $g_c \\mapsto \\{r_3\\}$,\n  - $g_{\\text{orph}}$ maps to no reaction (an orphan gene).\n\n- Gene pairs to evaluate (indexed for reporting): index $0$: $(g_a,g_{\\text{orph}})$, index $1$: $(g_c,g_{\\text{orph}})$, index $2$: $(g_a,g_c)$.\n\nAlgorithmic requirements:\n\n- Correct FBA viability test: For any genotype, solve the linear program\n  $$\n  \\max_{v \\in \\mathbb{R}^n}\\; c^\\top v \\quad \\text{subject to} \\quad S v = 0,\\;\\; l \\le v \\le u,\\;\\; v_j = 0 \\;\\; \\forall j \\in \\mathcal{R}_{\\text{deleted}},\n  $$\n  where $\\mathcal{R}_{\\text{deleted}}$ is the set of reaction indices controlled by the deleted genes. A genotype is viable if and only if the obtained optimal value is strictly greater than $\\varepsilon = 10^{-9}$.\n\n- Synthetic lethality: A pair $\\{g_i,g_j\\}$ is synthetic lethal if and only if the wild-type is viable, both single-deletion genotypes are viable, and the double-deletion genotype is non-viable according to the criterion above.\n\n- Naive projection-based lethality test: Compute a single wild-type optimal flux $v^\\star$ by maximizing $c^\\top v$ once. For each pair $\\{g_i,g_j\\}$, form a projected vector $\\tilde v$ by taking $v^\\star$ and setting to zero all components $v^\\star_k$ where $k \\in \\mathcal{R}_{g_i} \\cup \\mathcal{R}_{g_j}$. Classify the pair as lethal under the naive test if either $\\|S \\tilde v\\|_\\infty  \\tau$ where $\\tau = 10^{-9}$ or $c^\\top \\tilde v \\le \\varepsilon$. This test deliberately ignores re-optimization to expose the role of alternative optimal fluxes.\n\nYour program should compute, for each test case, three outputs in order:\n\n- The integer count of correctly predicted synthetic lethal pairs (by the correct FBA-based definition).\n\n- The integer count of pairs predicted lethal by the naive projection test.\n\n- A list of the indices (in ascending order) of the pairs that are false positives, i.e., predicted lethal by the naive test but not synthetic lethal by the correct test.\n\nFinal output format:\n\nYour program should produce a single line of output containing a list of length $3$ (one entry per test case). Each entry must itself be a list of the form $[\\text{count\\_true\\_SL}, \\text{count\\_naive\\_lethal}, \\text{sorted\\_false\\_positive\\_indices}]$. The entire output must be printed as a single Python-style list literal, for example: $[[\\cdot,\\cdot,[\\cdot]], [\\cdot,\\cdot,[\\cdot]], [\\cdot,\\cdot,[\\cdot]]]$.", "solution": "The problem requires the implementation of two distinct methods for predicting synthetic lethal gene pairs in a metabolic network, followed by a comparative analysis on a given test suite. The first method is the canonical approach based on Flux Balance Analysis (FBA), which involves re-optimizing the network's objective function for each genetic perturbation. The second is a naive projection-based method that relies on a single wild-type optimal flux distribution, designed to illustrate common pitfalls in constraint-based modeling.\n\nThe foundational principle is the quasi-steady-state assumption for intracellular metabolites, which is mathematically expressed as a mass balance constraint. For a metabolic network with $m$ metabolites and $n$ reactions, this constraint is given by the linear system:\n$$\nS v = 0\n$$\nwhere $S \\in \\mathbb{R}^{m \\times n}$ is the stoichiometric matrix and $v \\in \\mathbb{R}^n$ is the vector of reaction fluxes. Each flux $v_j$ is further constrained by lower and upper bounds, $l_j \\le v_j \\le u_j$, determined by thermodynamics and substrate availability. Within this feasible flux space, FBA seeks to find a flux vector $v$ that maximizes a cellular objective function, typically represented as a linear combination of fluxes, $Z = c^\\top v$. The standard FBA problem is thus a Linear Program (LP):\n$$\n\\max_{v} \\quad c^\\top v \\\\\n\\text{subject to} \\quad S v = 0 \\\\\nl \\le v \\le u\n$$\n\nA gene deletion is simulated by constraining the fluxes of all enzyme-catalyzed reactions associated with that gene to zero. If gene $g$ controls the set of reactions $\\mathcal{R}_g$, its deletion imposes the constraint $v_j = 0$ for all $j \\in \\mathcal{R}_g$. This is implemented by setting the corresponding lower and upper bounds to zero: $l_j = u_j = 0$.\n\nThe problem defines a gene pair $\\{g_i, g_j\\}$ as synthetic lethal if and only if four conditions are met:\n1. The wild-type (WT) organism is viable: its maximal objective value $Z_{WT}  \\varepsilon$.\n2. The single-gene deletion of $g_i$ results in a viable phenotype: $Z_{\\Delta g_i}  \\varepsilon$.\n3. The single-gene deletion of $g_j$ also results in a viable phenotype: $Z_{\\Delta g_j}  \\varepsilon$.\n4. The double-gene deletion of both $g_i$ and $g_j$ results in a non-viable phenotype: $Z_{\\Delta g_i \\Delta g_j} \\le \\varepsilon$.\nThe viability threshold is given as $\\varepsilon = 10^{-9}$. This \"correct\" method requires solving four separate LP problems for each gene pair.\n\nIn contrast, the \"naive\" projection-based method is designed to be computationally cheaper but conceptually flawed. It operates as follows:\n1. Solve the FBA problem for the wild-type once to obtain a *single* optimal flux vector, $v^\\star$.\n2. For a given gene pair $\\{g_i, g_j\\}$, construct a projected flux vector $\\tilde{v}$ by taking $v^\\star$ and setting to zero the fluxes of reactions controlled by $g_i$ or $g_j$. So, $\\tilde{v}_k = 0$ if $k \\in \\mathcal{R}_{g_i} \\cup \\mathcal{R}_{g_j}$, and $\\tilde{v}_k = v^\\star_k$ otherwise.\n3. The pair is classified as lethal if this projection $\\tilde{v}$ is invalid, which is defined as either violating the steady-state mass balance condition, $\\|S \\tilde{v}\\|_\\infty  \\tau$ (with tolerance $\\tau = 10^{-9}$), or resulting in a biomass production rate below the viability threshold, $c^\\top \\tilde{v} \\le \\varepsilon$.\n\nThe flaw in the naive method stems from the potential existence of alternative optima in the wild-type FBA problem. When multiple flux distributions yield the same maximal objective value, the solver returns just one, $v^\\star$. If this specific $v^\\star$ happens to not use a pathway that could compensate for a gene deletion, the naive method will incorrectly predict lethality due to a mass balance violation. The correct method avoids this by re-optimizing, allowing the network to find any compensatory routes that may exist in the feasible space of the perturbed system.\n\nThe algorithm proceeds by first defining a function `solve_fba` that takes the model parameters ($c$, $S$, $l$, $u$) and solves the corresponding LP using `scipy.optimize.linprog`. Since `linprog` minimizes, we provide it with the negative objective vector, $-c$, and then negate the resulting optimal value to get the maximum.\n\nFor each test case:\n1. The wild-type objective value $Z_{WT}$ and an optimal flux vector $v^\\star$ are computed. If $Z_{WT} \\le \\varepsilon$, no pairs can be synthetic lethal by definition.\n2. We iterate through each gene pair $\\{g_i, g_j\\}$ to be tested.\n3. For the correct FBA method, we simulate the single deletions of $g_i$ and $g_j$ and the double deletion $\\{g_i, g_j\\}$ by adjusting the flux bounds and calling `solve_fba` for each. We then apply the four-condition definition of synthetic lethality.\n4. For the naive method, we use the pre-computed $v^\\star$. For each pair, we create the projected vector $\\tilde{v}$ and check for mass balance violation ($S\\tilde{v} \\neq 0$) or low objective value ($c^\\top\\tilde{v} \\le \\varepsilon$).\n5. A pair is identified as a false positive if it is predicted lethal by the naive method but is not actually synthetic lethal according to the correct FBA-based method.\n6. The counts of true synthetic lethals, naive lethals, and the indices of false positives are collected for each test case.\n\n**Test Case 1 Analysis**: This case models two parallel pathways ($r_1$ and $r_2$) that can produce metabolite $P$. The wild-type optimal biomass is $10$, achievable by any combination of $v_1$ and $v_2$ such that $v_1+v_2 = 10$ (respecting individual bounds). The pair $(g_1, g_2)$ is synthetic lethal because deleting either gene alone is non-lethal (the other pathway compensates), but deleting both is lethal. The other pairs are not synthetic lethal. The naive method's prediction will depend on the specific $v^\\star$ found by the LP solver. If the solver picks a $v^\\star$ that uses only one pathway (e.g., $v_1=10, v_2=0$), projecting this solution for deletions involving the other pathway's gene ($g_2$) may not cause a violation, while deletions involving the active pathway's gene ($g_1$) will likely cause a mass balance error, leading to false positives.\n\n**Test Case 2 Analysis**: The uptake reaction $r_0$ is disabled ($u_0=0$), so no substrate can enter the system. The only feasible solution for the wild-type is the zero-flux vector ($v=0$), making the biomass $0$. Since the wild-type is non-viable, no pairs can be synthetic lethal. The naive method, however, starts with $v^\\star=0$. Any projection $\\tilde{v}$ will also be $0$, which satisfies mass balance but has an objective value of $0$, which is $\\le \\varepsilon$. Thus, the naive method will incorrectly predict all pairs as lethal.\n\n**Test Case 3 Analysis**: This case features a linear pathway and an orphan gene. The WT is viable. Single deletion of $g_a$ (which blocks the main pathway to biomass) is lethal, so no pair involving $g_a$ can be synthetic lethal. Deletion of $g_{\\text{orph}}$ has no effect. Consequently, there are no synthetic lethal pairs in this case. The naive method, starting with the unique optimal $v^\\star = [5, 5, 5, 0]^\\top$, will project this vector for deletions. Deleting $g_a$ by setting $\\tilde{v}_1=0$ will break mass balance, causing a false positive prediction for pairs $(g_a, g_{\\text{orph}})$ and $(g_a, g_c)$.", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the synthetic lethality analysis.\n    \"\"\"\n    \n    epsilon = 1e-9\n    tau = 1e-9\n\n    test_cases = [\n        # Test Case 1: parallel pathways with alternative optima\n        {\n            \"S\": np.array([\n                [1, -1, -1, 0, -1],\n                [0, 1, 1, -1, 0]\n            ]),\n            \"l\": np.array([0, 0, 0, 0, 0]),\n            \"u\": np.array([10, 10, 4, 1000, 1000]),\n            \"c\": np.array([0, 0, 0, 1, 0]),\n            \"gene_map\": {\n                'g1': [1], 'g2': [2], 'g3': [3], 'g4': [4]\n            },\n            \"pairs\": [('g1', 'g2'), ('g1', 'g4'), ('g2', 'g4')]\n        },\n        # Test Case 2: no substrate boundary case\n        {\n            \"S\": np.array([\n                [1, -1, -1, 0, -1],\n                [0, 1, 1, -1, 0]\n            ]),\n            \"l\": np.array([0, 0, 0, 0, 0]),\n            \"u\": np.array([0, 10, 4, 1000, 1000]),\n            \"c\": np.array([0, 0, 0, 1, 0]),\n            \"gene_map\": {\n                'g1': [1], 'g2': [2], 'g3': [3], 'g4': [4]\n            },\n            \"pairs\": [('g1', 'g2'), ('g1', 'g4'), ('g2', 'g4')]\n        },\n        # Test Case 3: orphan gene and non-synthetic lethals\n        {\n            \"S\": np.array([\n                [1, -1, 0, -1],\n                [0, 1, -1, 0]\n            ]),\n            \"l\": np.array([0, 0, 0, 0]),\n            \"u\": np.array([5, 5, 1000, 1000]),\n            \"c\": np.array([0, 0, 1, 0]),\n            \"gene_map\": {\n                'ga': [1], 'gb': [2], 'gc': [3], 'g_orph': []\n            },\n            \"pairs\": [('ga', 'g_orph'), ('gc', 'g_orph'), ('ga', 'gc')]\n        }\n    ]\n\n    all_results = []\n    for case_data in test_cases:\n        result = process_case(case_data, epsilon, tau)\n        all_results.append(result)\n        \n    # Format the output as a compact Python-style list literal string.\n    print(str(all_results).replace(\" \", \"\"))\n\ndef solve_fba(c, S, l, u):\n    \"\"\"\n    Solves the FBA linear program: max c^T v s.t. Sv=0, l = v = u.\n    Returns the maximal objective value and the optimal flux vector.\n    \"\"\"\n    num_reactions = S.shape[1]\n    bounds = list(zip(l, u))\n    \n    # scipy.optimize.linprog minimizes, so we minimize -c^T v\n    res = linprog(c=-c, A_eq=S, b_eq=np.zeros(S.shape[0]), bounds=bounds, method='highs')\n    \n    if res.success:\n        return -res.fun, res.x\n    else:\n        # Infeasible or unbounded, so objective value is treated as 0 (non-viable)\n        return 0.0, np.zeros(num_reactions)\n\ndef process_case(case_data, epsilon, tau):\n    \"\"\"\n    Processes a single test case to find synthetic lethal pairs.\n    \"\"\"\n    S = case_data[\"S\"]\n    l_base = case_data[\"l\"]\n    u_base = case_data[\"u\"]\n    c = case_data[\"c\"]\n    gene_map = case_data[\"gene_map\"]\n    pairs_to_test = case_data[\"pairs\"]\n\n    true_sl_count = 0\n    naive_lethal_count = 0\n    false_positive_indices = []\n\n    # Get wild-type solution\n    wt_obj, v_star = solve_fba(c, S, l_base, u_base)\n    wt_is_viable = wt_obj > epsilon\n\n    for idx, (g1, g2) in enumerate(pairs_to_test):\n        is_true_sl = False\n        is_naive_lethal = False\n\n        # --- Correct FBA-based Synthetic Lethality Test ---\n        if wt_is_viable:\n            # Single deletion of g1\n            l_g1, u_g1 = l_base.copy(), u_base.copy()\n            for rxn_idx in gene_map.get(g1, []):\n                l_g1[rxn_idx], u_g1[rxn_idx] = 0, 0\n            g1_obj, _ = solve_fba(c, S, l_g1, u_g1)\n            g1_is_viable = g1_obj > epsilon\n\n            # Single deletion of g2\n            l_g2, u_g2 = l_base.copy(), u_base.copy()\n            for rxn_idx in gene_map.get(g2, []):\n                l_g2[rxn_idx], u_g2[rxn_idx] = 0, 0\n            g2_obj, _ = solve_fba(c, S, l_g2, u_g2)\n            g2_is_viable = g2_obj > epsilon\n\n            # Double deletion of g1 and g2\n            l_g1g2, u_g1g2 = l_base.copy(), u_base.copy()\n            reactions_to_delete = set(gene_map.get(g1, [])) | set(gene_map.get(g2, []))\n            for rxn_idx in reactions_to_delete:\n                l_g1g2[rxn_idx], u_g1g2[rxn_idx] = 0, 0\n            g1g2_obj, _ = solve_fba(c, S, l_g1g2, u_g1g2)\n            double_is_non_viable = g1g2_obj = epsilon\n\n            if g1_is_viable and g2_is_viable and double_is_non_viable:\n                is_true_sl = True\n                true_sl_count += 1\n        \n        # --- Naive Projection-based Lethality Test ---\n        v_tilde = v_star.copy()\n        reactions_to_delete_naive = set(gene_map.get(g1, [])) | set(gene_map.get(g2, []))\n        for rxn_idx in reactions_to_delete_naive:\n            v_tilde[rxn_idx] = 0.0\n\n        mass_balance_error = np.max(np.abs(S @ v_tilde))\n        projected_biomass = c @ v_tilde\n\n        if mass_balance_error > tau or projected_biomass = epsilon:\n            is_naive_lethal = True\n            naive_lethal_count += 1\n\n        # Check for false positives\n        if is_naive_lethal and not is_true_sl:\n            false_positive_indices.append(idx)\n            \n    return [true_sl_count, naive_lethal_count, sorted(false_positive_indices)]\n\nsolve()\n```", "id": "3313299"}]}