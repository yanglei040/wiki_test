{"hands_on_practices": [{"introduction": "To create independent streams for parallel simulations, we need a way to jump forward in a pseudo-random sequence by a massive number of steps without costly iteration. This practice demonstrates the fundamental 'skip-ahead' technique, a cornerstone for creating non-overlapping subsequences for generators like LCGs. By representing the generator's update as an affine transformation, we can use the elegant power of binary exponentiation to compute the state billions or trillions of steps ahead almost instantly, forming the basis for robust parallel stream management.", "problem": "Consider the Linear Congruential Generator (LCG) defined by the recurrence $x_{k+1} = (a x_k + c) \\bmod m$ on the state space $\\{0,1,\\dots,m-1\\}$, where $m = 2^{48}$, $a = 25214903917$, and $c = 11$. In stochastic simulation and Monte Carlo methods (MC), seed initialization and stream independence are achieved by deterministic skip-ahead so that multiple independent substreams can be constructed from a single generator without overlap in prescribed windows.\n\nStarting from the following fundamental base:\n- The LCG recurrence $x_{k+1} = (a x_k + c) \\bmod m$ defines an affine map $f(x) = (a x + c) \\bmod m$ over the ring $\\mathbb{Z}/m\\mathbb{Z}$.\n- Composition of affine maps is associative and closed: if $f(x) = (A x + C) \\bmod m$ and $g(x) = (B x + D) \\bmod m$ then $g \\circ f$ is an affine map over $\\mathbb{Z}/m\\mathbb{Z}$.\n- Binary exponentiation (also called exponentiation by squaring) reduces repeated composition to $O(\\log t)$ compositions.\n\nYour tasks are:\n1. Derive, from first principles, an algorithm that computes $x_{n+t}$ from a given $x_n$ for arbitrary nonnegative integer $t$ using binary exponentiation of affine maps modulo $m$. Specialize your derivation to $t = 10^{12}$ and show how to compute $x_{n+10^{12}}$ without iterating the recurrence $10^{12}$ times and without requiring any modular inverse that may not exist in $\\mathbb{Z}/2^{48}\\mathbb{Z}$.\n2. Analyze the time and space complexity of your algorithm as functions of $t$ and discuss how this supports stream independence via skip-ahead in Monte Carlo simulation.\n3. Implement the algorithm in a complete, runnable program and apply it to the following test suite. Each test case produces a single boolean or integer result:\n   - Test 1 (correctness against naive iteration): Let $x_n = 42$ and $t = 1000$. Compute $x_{n+t}$ by your skip-ahead algorithm and by direct iteration of the LCG, and return a boolean indicating whether the two results are equal.\n   - Test 2 (identity boundary): Let $x_n = 1234567890123$ and $t = 0$. Compute and return $x_{n+t}$ as an integer.\n   - Test 3 (single-step boundary): Let $x_n = 1$ and $t = 1$. Compute and return $x_{n+t}$ as an integer.\n   - Test 4 (large skip from zero): Let $x_n = 0$ and $t = 10^{12}$. Compute and return $x_{n+t}$ as an integer.\n   - Test 5 (empirical substream independence in a window): Define two substreams using stride $S = 10^{12}$. Let the initial seed be $x_0 = 1234567890123$, define the second seed as $x_0' = x_{0+S}$ via your skip-ahead algorithm, and then produce the first $L = 1000$ states of each substream by direct iteration. Return a boolean indicating whether the sets of the first $L$ states of the two substreams are disjoint.\n\nYour program should produce a single line of output containing the results of the tests as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5]\"). No physical units or angles are involved; all quantities are pure integers or booleans in the specified ring arithmetic.", "solution": "The problem asks for the derivation, analysis, and implementation of an efficient algorithm to compute the state $x_{n+t}$ of a Linear Congruential Generator (LCG) given a starting state $x_n$, without performing $t$ iterations. This technique is known as skip-ahead or jump-ahead.\n\nThe LCG is defined by the recurrence relation:\n$$x_{k+1} = (a x_k + c) \\bmod m$$\nwith parameters $m = 2^{48}$, $a = 25214903917$, and $c = 11$.\n\n### 1. Derivation of the Skip-Ahead Algorithm\n\nThe core principle is to represent the LCG recurrence as the repeated application of an affine transformation and then use an efficient algorithm to compute the $t$-th power of this transformation.\n\n**Step 1: Formalize the LCG as an Affine Map**\nThe recurrence $x_{k+1} = (ax_k + c) \\pmod m$ can be expressed as the application of a function $f$ to the state $x_k$:\n$$x_{k+1} = f(x_k)$$\nwhere $f(x) = (ax + c) \\pmod m$. This is an affine transformation on the ring of integers modulo $m$, $\\mathbb{Z}/m\\mathbb{Z}$.\nTo find the state after $t$ steps, $x_{n+t}$, we must apply the map $f$ a total of $t$ times to the initial state $x_n$:\n$$x_{n+t} = f(f(\\dots f(x_n)\\dots)) = f^t(x_n)$$\n\n**Step 2: The Algebra of Affine Map Composition**\nLet us analyze the composition of two such affine maps. Consider two maps, $g(x) = (A'x + C') \\pmod m$ and $h(x) = (Ax + C) \\pmod m$. Their composition $(g \\circ h)(x)$ is:\n$$(g \\circ h)(x) = g(h(x)) = A'(Ax + C) + C' = (A'A)x + (A'C + C') \\pmod m$$\nThe composition of two affine maps is another affine map. We can define a composition operation on the coefficient pairs $(A, C)$. If $g$ corresponds to the pair $(A', C')$ and $h$ to $(A, C)$, their composition $g \\circ h$ corresponds to a new pair:\n$$(A', C') \\circ (A, C) = (A'A \\pmod m, (A'C + C') \\pmod m)$$\nThis composition operation is associative, which is a crucial property for exponentiation.\n\nA brute-force calculation of $x_{n+t}$ would be $f^t(x_n)$, which is computationally expensive. A more direct formula can be found by induction:\n$$x_{n+1} = ax_n + c$$\n$$x_{n+2} = a(ax_n+c)+c = a^2x_n + ac+c$$\n$$x_{n+3} = a(a^2x_n+ac+c)+c = a^3x_n + a^2c+ac+c$$\nThe general form for $x_{n+t}$ is:\n$$x_{n+t} = \\left(a^t x_n + c \\sum_{i=0}^{t-1} a^i\\right) \\pmod m$$\nThe sum is a geometric series, which has a closed-form solution $\\sum_{i=0}^{t-1} a^i = \\frac{a^t-1}{a-1}$. Using this, we would get:\n$$x_{n+t} = \\left(a^t x_n + c \\frac{a^t-1}{a-1}\\right) \\pmod m$$\nThis formula requires division by $a-1$, which means we would need to find the modular multiplicative inverse of $(a-1) \\pmod m$. For $m=2^{48}$ and $a=25214903917$, $a-1=25214903916$, which is an even number. Since $m$ is also even, $\\gcd(a-1, m) \\neq 1$, and thus the modular inverse of $(a-1) \\pmod{2^{48}}$ does not exist. This approach is therefore invalid for the given parameters, as correctly noted in the problem statement.\n\n**Step 3: Binary Exponentiation of Affine Maps**\nThe valid approach, which avoids modular inverses, is to compute the coefficients of the composed map $f^t(x) = (A_t x + C_t) \\pmod m$ using the composition rule and binary exponentiation (also known as exponentiation by squaring).\n\nThe goal is to compute the pair $(A_t, C_t)$ that represents $f^t$. This is equivalent to computing the $t$-th power of the map $f$, represented by its coefficient pair $(a, c)$, under the composition operation.\n\nThe algorithm for computing $(A_t, C_t) = (a, c)^t$ is as follows:\nLet the binary representation of $t$ be $t = \\sum_{i=0}^k b_i 2^i$, where $b_i \\in \\{0, 1\\}$. Then $f^t = \\prod_{i: b_i=1} f^{2^i}$. We can compute this product iteratively.\n\n1.  **Initialization**:\n    The identity map is $id(x) = 1 \\cdot x + 0$, so its coefficient pair is $(1, 0)$. This will be our accumulator for the final result.\n    Let $(A_{res}, C_{res}) = (1, 0)$.\n    The base map is $f^1$, corresponding to the pair $(a, c)$.\n    Let $(A_{base}, C_{base}) = (a, c)$.\n\n2.  **Iteration**: We process the bits of $t$ from least significant to most significant.\n    While $t  0$:\n    a. If the current least significant bit of $t$ is $1$, we compose our accumulated result with the current base map:\n       $(A_{res}, C_{res}) \\leftarrow (A_{base}, C_{base}) \\circ (A_{res}, C_{res})$. Using the composition rule, this becomes:\n       - $A_{res, new} = (A_{base} \\cdot A_{res}) \\pmod m$\n       - $C_{res, new} = (A_{base} \\cdot C_{res} + C_{base}) \\pmod m$\n    b. We square the base map to prepare for the next bit, as $f^{2^{i+1}} = f^{2^i} \\circ f^{2^i}$:\n       $(A_{base}, C_{base}) \\leftarrow (A_{base}, C_{base}) \\circ (A_{base}, C_{base})$. This becomes:\n       - $A_{base, new} = (A_{base} \\cdot A_{base}) \\pmod m$\n       - $C_{base, new} = (A_{base} \\cdot C_{base} + C_{base}) \\pmod m$\n    c. We discard the processed bit of $t$ by right-shifting: $t \\leftarrow t \\gg 1$.\n\n3.  **Finalization**:\n    After the loop finishes, the pair $(A_{res}, C_{res})$ will be $(A_t, C_t)$.\n    The final state $x_{n+t}$ is then computed by applying this map to $x_n$:\n    $$x_{n+t} = (A_t \\cdot x_n + C_t) \\pmod m$$\nThis algorithm computes the result using only modular multiplication and addition, with no need for inverses. For $t = 10^{12}$, this algorithm is exceptionally efficient, as the number of iterations is proportional to $\\log_2(10^{12})$.\n\n### 2. Complexity Analysis and Application to Stream Independence\n\n**Time Complexity**\nThe binary exponentiation algorithm iterates approximately $\\log_2 t$ times. Inside each iteration, a fixed number of modular multiplications and additions are performed to carry out the two composition operations. The numbers involved are bounded by $m$, and for a fixed $m$, these arithmetic operations take constant time. Therefore, the time complexity to compute the coefficients $(A_t, C_t)$ is $O(\\log t)$. After computing the coefficients, a single application of the map requires one multiplication and one addition, which is an $O(1)$ operation. The overall time complexity of the skip-ahead algorithm is thus $O(\\log t)$.\n\n**Space Complexity**\nThe algorithm requires a fixed number of variables to store the coefficients of the accumulator and base maps, along with the input parameters. The memory usage does not scale with $t$. Consequently, the space complexity is $O(1)$.\n\n**Support for Stream Independence in Monte Carlo Simulation**\nIn parallel Monte Carlo simulations, it is critical that each of the $P$ parallel processes generates a sequence of random numbers that is statistically independent from the others. A single LCG produces one long sequence of states. A robust method to create independent \"substreams\" for each process is to partition this main sequence.\n\nWe can assign process $i$ (for $i \\in \\{0, 1, \\dots, P-1\\}$) a substream starting at seed $x_S^{(i)} = x_{i \\cdot S}$, where $S$ is a very large skip distance or stride. For instance, we could choose $S=10^{12}$.\n- Process $0$ starts with $x_0$.\n- Process $1$ starts with $x_S$, computed as $f^S(x_0)$.\n- Process $2$ starts with $x_{2S}$, computed as $f^S(x_S)$.\n- And so on, with process $i$ starting at $x_{iS} = f^S(x_{(i-1)S})$.\n\nThe derived skip-ahead algorithm with its $O(\\log S)$ time complexity is the enabling technology for this approach. Computing the starting seed for each process is nearly instantaneous, even for enormous strides like $S=10^{12}$. Without this algorithm, calculating $x_{i \\cdot S}$ would require $i \\cdot S$ iterations, which would be computationally infeasible and defeat the purpose of parallelization.\n\nBy choosing $S$ to be much larger than the number of random variates any single process will consume, we can ensure that the substreams used by different processes do not overlap, thereby providing a practical guarantee of their statistical independence.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the LCG skip-ahead problem by implementing the algorithm derived from\n    first principles and running the specified test cases.\n    \"\"\"\n    # Parameters of the LCG from the problem statement\n    m = 2**48\n    a = 25214903917\n    c = 11\n    # For m=2**k, modulo can be done with a bitwise AND, which is faster.\n    mask = m - 1\n\n    def power_map(t: int, a_base: int, c_base: int, mod_mask: int):\n        \"\"\"\n        Computes the coefficients (A_t, C_t) of the composed affine map f^t,\n        where f^t(x) = (A_t * x + C_t) mod m, using binary exponentiation.\n\n        The composition of g(x)=a1*x+c1 and h(x)=a2*x+c2 is g(h(x)) = (a1*a2)*x + (a1*c2+c1).\n        The corresponding operation on coefficient pairs is (a1, c1) o (a2, c2) - (a1*a2, a1*c2+c1).\n        \"\"\"\n        if t == 0:\n            # Identity map: x - 1*x + 0\n            return 1, 0\n\n        # Accumulator for the final map, initialized to identity.\n        final_a, final_c = 1, 0\n\n        # Current power of the base map, starts with f^1 = (a, c).\n        current_a, current_c = a_base, c_base\n        \n        power = t\n        while power > 0:\n            if power % 2 == 1:\n                # Accumulate this power: final_map - current_map o final_map\n                final_a, final_c = (\n                    (current_a * final_a)  mod_mask,\n                    (current_a * final_c + current_c)  mod_mask\n                )\n\n            # Square the current power map: current_map - current_map o current_map\n            current_a, current_c = (\n                (current_a * current_a)  mod_mask,\n                (current_a * current_c + current_c)  mod_mask\n            )\n            \n            power //= 2\n        \n        return final_a, final_c\n\n    def skip_ahead(x_n: int, t: int):\n        \"\"\"\n        Computes x_{n+t} from x_n by finding the composed map f^t and applying it.\n        \"\"\"\n        if t == 0:\n            return x_n\n        \n        A_t, C_t = power_map(t, a, c, mask)\n        return (A_t * x_n + C_t)  mask\n    \n    def lcg_step(x: int):\n        \"\"\"Performs a single step of the LCG.\"\"\"\n        return (a * x + c)  mask\n\n    results = []\n\n    # Test 1: correctness against naive iteration\n    x_n_1, t_1 = 42, 1000\n    res_skip_1 = skip_ahead(x_n_1, t_1)\n    res_iter_1 = x_n_1\n    for _ in range(t_1):\n        res_iter_1 = lcg_step(res_iter_1)\n    results.append(res_skip_1 == res_iter_1)\n\n    # Test 2: identity boundary (t=0)\n    x_n_2, t_2 = 1234567890123, 0\n    res_2 = skip_ahead(x_n_2, t_2)\n    results.append(res_2)\n\n    # Test 3: single-step boundary (t=1)\n    x_n_3, t_3 = 1, 1\n    res_3 = skip_ahead(x_n_3, t_3)\n    results.append(res_3)\n\n    # Test 4: large skip from zero\n    x_n_4, t_4 = 0, 10**12\n    res_4 = skip_ahead(x_n_4, t_4)\n    results.append(res_4)\n\n    # Test 5: empirical substream independence in a window\n    S_5 = 10**12\n    L_5 = 1000\n    x0_5 = 1234567890123\n    \n    # Generate first substream\n    stream1 = []\n    current_x1 = x0_5\n    for _ in range(L_5):\n        stream1.append(current_x1)\n        current_x1 = lcg_step(current_x1)\n        \n    # Find start of second substream and generate it\n    x0_prime_5 = skip_ahead(x0_5, S_5)\n    stream2 = []\n    current_x2 = x0_prime_5\n    for _ in range(L_5):\n        stream2.append(current_x2)\n        current_x2 = lcg_step(current_x2)\n\n    # Check for disjointness using sets for efficiency\n    set1 = set(stream1)\n    set2 = set(stream2)\n    results.append(set1.isdisjoint(set2))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3338260"}, {"introduction": "Before implementing a parallel random number generator, a sound theoretical analysis can prevent subtle but catastrophic failures that empirical tests might miss. This exercise explores a seemingly plausible but deeply flawed method for creating parallel streams: assigning each stream a unique increment parameter. By analyzing the generator's structure at its most fundamental level—the least significant bit—you will uncover severe deterministic correlations that violate the assumption of stream independence, highlighting why robust stream generation methods are not arbitrary.", "problem": "Consider a family of random number generator streams defined by the Permuted Congruential Generator (PCG), where each stream has its own increment. The internal state for stream $i$ evolves as an affine Linear Congruential Generator (LCG) over the ring of integers modulo $2^{64}$:\n$$\nx^{(i)}_{n+1} \\equiv a\\,x^{(i)}_{n} + c_i \\pmod{2^{64}},\n$$\nwhere $a$ is a fixed odd multiplier and $c_i$ is a fixed per-stream increment. The output permutation used by PCG is a bijection on $64$-bit words; for the purposes of this problem, focus on the statistical properties of the internal state itself, in particular its lowest-order bits. Assume initial states $x^{(i)}_0$ are chosen independently and uniformly from $\\{0,1,\\dots,2^{64}-1\\}$ for each stream $i$.\n\nPart A: Using the ring structure modulo powers of $2$, analyze the evolution of the least significant bit (LSB) $b^{(i)}_n := x^{(i)}_n \\bmod 2$ for arbitrary streams $i$ and $j$. Derive conditions on the increments $c_i$ and $c_j$ under which the LSB processes of distinct streams, $b^{(i)}_n$ and $b^{(j)}_n$, avoid deterministic coupling over time. Your analysis must start from the definition of the recurrence modulo $2$ and reason from first principles about how parity evolves. State clearly whether full-period requirements for each stream (with modulus $2^{64}$) are compatible with your LSB independence conditions.\n\nPart B (counterexample and calculation): Consider a practitioner who mistakenly sets one stream’s increment to be even. Specifically, take stream $j$ with $c_j \\equiv 0 \\pmod{2}$, while maintaining the standard full-period conditions for other streams. For stream $j$, define the empirical mean of its LSB over its LSB-period as\n$$\n\\hat{\\mu}_{\\text{LSB}} := \\frac{1}{N}\\sum_{n=0}^{N-1} b^{(j)}_n,\n$$\nwhere $N$ is the length of the LSB cycle that results from the recurrence for $b^{(j)}_n$. Compute the magnitude of the bias\n$$\n\\left|\\hat{\\mu}_{\\text{LSB}} - \\frac{1}{2}\\right|\n$$\nthat this poor choice of $c_j$ induces. Your final answer must be a single real number. No rounding is required.", "solution": "The problem is divided into two parts. Part A requires an analysis of the least significant bit (LSB) of the generator's internal state to derive conditions for stream independence and to check compatibility with full-period requirements. Part B requires the calculation of a specific statistical bias resulting from a poor choice of generator parameters.\n\nPart A: LSB Analysis and Stream Independence\n\nThe internal state of stream $i$ is governed by the recurrence relation:\n$$\nx^{(i)}_{n+1} \\equiv a\\,x^{(i)}_{n} + c_i \\pmod{2^{64}}\n$$\nwhere $a$ is a fixed odd multiplier and $c_i$ is the per-stream increment.\n\nTo analyze the least significant bit (LSB), we consider this recurrence modulo $2$. The LSB of $x^{(i)}_n$ is defined as $b^{(i)}_n := x^{(i)}_n \\bmod 2$. Taking the recurrence modulo $2$ yields:\n$$\nx^{(i)}_{n+1} \\bmod 2 \\equiv (a\\,x^{(i)}_{n} + c_i) \\bmod 2\n$$\nUsing the properties of modular arithmetic, this becomes:\n$$\nb^{(i)}_{n+1} \\equiv ( (a \\bmod 2) \\cdot (x^{(i)}_{n} \\bmod 2) + (c_i \\bmod 2) ) \\pmod 2\n$$\n$$\nb^{(i)}_{n+1} \\equiv ( (a \\bmod 2) \\cdot b^{(i)}_n + (c_i \\bmod 2) ) \\pmod 2\n$$\nThe problem states that the multiplier $a$ is odd, which means $a \\equiv 1 \\pmod 2$. Substituting this into the LSB recurrence gives:\n$$\nb^{(i)}_{n+1} \\equiv b^{(i)}_n + (c_i \\bmod 2) \\pmod 2\n$$\nThis is a simple first-order linear recurrence for the LSB sequence. Let $C_i = c_i \\bmod 2$. The LSB sequence is then given by unrolling the recurrence:\n$$\nb^{(i)}_n \\equiv b^{(i)}_0 + n \\cdot C_i \\pmod 2\n$$\nThis equation reveals the entire structure of the LSB sequence. If $C_i = 0$ (i.e., $c_i$ is even), the recurrence is $b^{(i)}_{n+1} \\equiv b^{(i)}_n \\pmod 2$, meaning the LSB is constant for all $n$. If $C_i = 1$ (i.e., $c_i$ is odd), the recurrence is $b^{(i)}_{n+1} \\equiv b^{(i)}_n + 1 \\pmod 2$, meaning the LSB flips at every step, producing an alternating sequence of period $2$.\n\nNow, consider two distinct streams, $i$ and $j$. Their LSB sequences are:\n$$\nb^{(i)}_n \\equiv b^{(i)}_0 + n \\cdot (c_i \\bmod 2) \\pmod 2\n$$\n$$\nb^{(j)}_n \\equiv b^{(j)}_0 + n \\cdot (c_j \\bmod 2) \\pmod 2\n$$\nDeterministic coupling occurs if there is a simple, fixed relationship between $b^{(i)}_n$ and $b^{(j)}_n$ that does not depend on $n$ in a complex way. Let's examine the exclusive-or (XOR) of the two sequences, which is equivalent to their sum modulo $2$:\n$$\nb^{(i)}_n \\oplus b^{(j)}_n \\equiv b^{(i)}_n + b^{(j)}_n \\pmod 2\n$$\n$$\nb^{(i)}_n + b^{(j)}_n \\equiv (b^{(i)}_0 + n(c_i \\bmod 2)) + (b^{(j)}_0 + n(c_j \\bmod 2)) \\pmod 2\n$$\n$$\nb^{(i)}_n + b^{(j)}_n \\equiv (b^{(i)}_0 + b^{(j)}_0) + n((c_i \\bmod 2) + (c_j \\bmod 2)) \\pmod 2\n$$\nIf the increments have the same parity, $c_i \\equiv c_j \\pmod 2$, then $(c_i \\bmod 2) = (c_j \\bmod 2)$.\nLet $C = c_i \\bmod 2 = c_j \\bmod 2$. Then $(c_i \\bmod 2) + (c_j \\bmod 2) = C+C = 2C \\equiv 0 \\pmod 2$.\nIn this case, the relationship simplifies to:\n$$\nb^{(i)}_n + b^{(j)}_n \\equiv b^{(i)}_0 + b^{(j)}_0 \\pmod 2\n$$\nThis means $b^{(i)}_n \\oplus b^{(j)}_n = b^{(i)}_0 \\oplus b^{(j)}_0$, which is a constant for all $n$. The two LSB sequences are perfectly correlated (or anti-correlated). For instance, if $b^{(i)}_0 = b^{(j)}_0$, then $b^{(i)}_n = b^{(j)}_n$ for all $n$. This is a severe deterministic coupling that is highly undesirable for independent random number streams.\n\nTo avoid this deterministic coupling, the coefficient of $n$ in the expression for $b^{(i)}_n + b^{(j)}_n$ must be non-zero. This requires:\n$$\n(c_i \\bmod 2) + (c_j \\bmod 2) \\not\\equiv 0 \\pmod 2\n$$\nThis is equivalent to $(c_i \\bmod 2) \\neq (c_j \\bmod 2)$. That is, the increments $c_i$ and $c_j$ must have different parity.\n\nNext, we assess the compatibility of this condition with the requirement for each stream to have a full period. For a Linear Congruential Generator of the form $x_{n+1} \\equiv ax_n+c \\pmod{2^k}$ with $k \\ge 2$, a full period of $2^k$ is achieved if and only if two conditions are met (Theorem A, Section 3.2.1.2 of Knuth's TAOCP, Vol 2):\n1. The increment $c$ is odd.\n2. The multiplier $a$ satisfies $a \\equiv 1 \\pmod 4$.\n\nFor our generator with modulus $2^{64}$, the full-period requirement for stream $i$ dictates that its increment $c_i$ must be odd, i.e., $c_i \\equiv 1 \\pmod 2$. For stream $j$ to also have a full period, its increment $c_j$ must also be odd, $c_j \\equiv 1 \\pmod 2$.\nThis implies $c_i \\equiv c_j \\pmod 2$.\n\nTherefore, the condition for avoiding LSB coupling ($c_i \\not\\equiv c_j \\pmod 2$) is fundamentally incompatible with the condition that both streams achieve the maximum possible period ($c_i \\equiv 1 \\pmod 2$ and $c_j \\equiv 1 \\pmod 2$). This reveals a critical weakness in creating multiple streams by only varying the LCG increment.\n\nPart B: Bias Calculation\n\nIn this part, we consider a stream $j$ where the practitioner has mistakenly chosen an even increment, $c_j \\equiv 0 \\pmod 2$. The LSB recurrence for this stream is:\n$$\nb^{(j)}_{n+1} \\equiv b^{(j)}_n + (c_j \\bmod 2) \\pmod 2 \\implies b^{(j)}_{n+1} \\equiv b^{(j)}_n \\pmod 2\n$$\nThis recurrence implies that the LSB sequence is constant: $b^{(j)}_n = b^{(j)}_0$ for all $n \\ge 0$. The sequence is either $0, 0, 0, \\dots$ or $1, 1, 1, \\dots$, depending on the LSB of the initial state $x^{(j)}_0$.\n\nThe problem defines $N$ as the length of the LSB cycle. For a constant sequence, the cycle length is $N=1$. The empirical mean of the LSB over this period is:\n$$\n\\hat{\\mu}_{\\text{LSB}} = \\frac{1}{N}\\sum_{n=0}^{N-1} b^{(j)}_n = \\frac{1}{1} \\sum_{n=0}^{0} b^{(j)}_n = b^{(j)}_0\n$$\nSo the empirical mean is simply the initial LSB, $b^{(j)}_0$.\n\nThe initial state $x^{(j)}_0$ is chosen uniformly from $\\{0, 1, \\dots, 2^{64}-1\\}$. This set contains $2^{63}$ even numbers and $2^{63}$ odd numbers. Therefore, the LSB $b^{(j)}_0 = x^{(j)}_0 \\bmod 2$ is $0$ with probability $1/2$ and $1$ with probability $1/2$.\n\nThe ideal mean for a sequence of unbiased random bits is $1/2$. The bias is the deviation of the empirical mean from this ideal value. We are asked to compute the magnitude of this bias:\n$$\n\\left|\\hat{\\mu}_{\\text{LSB}} - \\frac{1}{2}\\right|\n$$\nWe must evaluate this for the two possible outcomes of $\\hat{\\mu}_{\\text{LSB}}$:\n\\begin{enumerate}\n    \\item If $x^{(j)}_0$ is even, then $b^{(j)}_0=0$, and $\\hat{\\mu}_{\\text{LSB}} = 0$. The magnitude of the bias is $\\left|0 - \\frac{1}{2}\\right| = \\frac{1}{2}$.\n    \\item If $x^{(j)}_0$ is odd, then $b^{(j)}_0=1$, and $\\hat{\\mu}_{\\text{LSB}} = 1$. The magnitude of the bias is $\\left|1 - \\frac{1}{2}\\right| = \\frac{1}{2}$.\n\\end{enumerate}\nIn both cases, the magnitude of the bias induced by the poor choice of an even increment $c_j$ is exactly $\\frac{1}{2}$. This represents a catastrophic failure of the generator's LSB sequence, which is fixed at a single value instead of seeming random. The resulting empirical mean is maximally biased, being as far as possible from the ideal mean of $1/2$ for a binary value.", "answer": "$$\\boxed{\\frac{1}{2}}$$", "id": "3338270"}, {"introduction": "While theoretical analysis reveals design flaws, empirical testing provides the final verdict on a generator's practical performance. This practice pits two common parallelization strategies, the 'leapfrog' method and the robust 'skip-ahead' seeding method, against each other in a head-to-head comparison. You will implement both techniques and use a fundamental statistical tool, the empirical covariance, to diagnose hidden linear dependencies between streams, providing a tangible demonstration of why certain methods are more trustworthy than others in practice.", "problem": "You are given the task of programmatically diagnosing cross-stream correlation in parallelized pseudo-random number generation using a Linear Congruential Generator (LCG). The LCG is defined by the recurrence relation\n$$\nx_{n+1} = (a x_n + c) \\bmod m,\n$$\nwith output transformation\n$$\nU_n = \\frac{x_n}{m}.\n$$\nTwo standard methods to create parallel streams from a base LCG are considered.\n\n1. Leapfrog splitting: For a fixed number of streams $P$, stream $i$ (with $0 \\le i  P$) uses the subsequence $\\{x_{i}, x_{i+P}, x_{i+2P}, \\dots\\}$, so its $t$-th output is $U^{(i)}_t = x_{i + t P}/m$.\n\n2. Skip-ahead seeding: For a fixed stride $L$, stream $i$ is seeded at $x_{iL}$ and then advances one step at a time, so its $t$-th output is $U^{(i)}_t = x_{iL + t}/m$.\n\nWe adopt the following foundational definitions.\n\n- Independence of two streams $(U^{(i)}_t)$ and $(U^{(j)}_t)$ for $i \\ne j$ is compatible with the condition $\\operatorname{Cov}(U^{(i)}_t, U^{(j)}_t) = 0$ for each fixed $t$, assuming identical distributions and finite variance.\n- The empirical (unbiased) covariance estimator for two finite sequences $(u_t)$ and $(v_t)$ of length $T$ is\n$$\n\\widehat{\\operatorname{Cov}}(u,v) = \\frac{1}{T-1}\\sum_{t=1}^{T} \\left(u_t - \\bar u\\right)\\left(v_t - \\bar v\\right),\n$$\nwhere $\\bar u = \\frac{1}{T}\\sum_{t=1}^{T} u_t$ and $\\bar v = \\frac{1}{T}\\sum_{t=1}^{T} v_t$.\n\nYour program must, for each test case listed below, construct two streams with indices $i=0$ and $j=1$ using both leapfrog splitting and skip-ahead seeding. For each method, estimate\n$$\n\\widehat{\\operatorname{Cov}}\\left((U^{(0)}_t)_{t=1}^T, (U^{(1)}_t)_{t=1}^T\\right),\n$$\nand report the resulting covariance estimates as real numbers.\n\nImplementation constraints and derivation requirements:\n\n- You must implement a general $k$-step skip-ahead for an LCG by composing affine maps. Use the fact that repeated application of the affine update $x \\mapsto a x + c \\pmod m$ can be expressed as a single affine map $x \\mapsto a_k x + c_k \\pmod m$, where\n$$\n\\begin{pmatrix}\na_k  c_k\\\\\n0  1\n\\end{pmatrix}\n=\n\\begin{pmatrix}\na  c\\\\\n0  1\n\\end{pmatrix}^{k}\n\\pmod m.\n$$\nYou must compute this using exponentiation by repeated squaring under the modulus $m$, which is valid because matrix multiplication composes affine maps and exponentiation by squaring is a well-tested method for powering under a ring.\n\n- For leapfrog splitting with $P$ streams, stream $i$ must start from $x_i$ and then repeatedly apply the $P$-step affine map derived above. For skip-ahead seeding with stride $L$, stream $i$ must start from $x_{iL}$ and then repeatedly apply the $1$-step affine map.\n\n- Convert states to uniforms by $U = x/m$ in floating-point arithmetic.\n\nTest suite:\n\nFor each test case, use $P=4$ streams and estimate covariances between the two streams with indices $i=0$ and $j=1$. Use length $T=200000$. Use the common initial seed $x_0 = 42$ for the base LCG.\n\n- Test case $1$ (happy path, multiplicative LCG with prime modulus):\n  - $m = 2147483647$, $a = 16807$, $c = 0$\n  - Skip-ahead stride $L = 10^7$\n\n- Test case $2$ (mixed LCG with composite modulus):\n  - $m = 2147483648$, $a = 1103515245$, $c = 12345$\n  - Skip-ahead stride $L = 10^6$\n\n- Test case $3$ (full-period mixed LCG with power-of-two modulus):\n  - $m = 1048576$, $a = 5$, $c = 1$\n  - Skip-ahead stride $L = 65536$\n\nProgram requirements:\n\n- Your program must compute, for each test case, two values:\n  - The empirical covariance estimate for leapfrog splitting between streams $i=0$ and $j=1$.\n  - The empirical covariance estimate for skip-ahead seeding between streams $i=0$ and $j=1$.\n- The final output must be a single line containing a comma-separated list enclosed in square brackets with six floating-point numbers in this exact order:\n  - $[\\text{leapfrog\\_case1}, \\text{skipahead\\_case1}, \\text{leapfrog\\_case2}, \\text{skipahead\\_case2}, \\text{leapfrog\\_case3}, \\text{skipahead\\_case3}]$\n\nNo physical units are involved. Angles are not used. No percentages are required; all reported values are real numbers in standard decimal form.", "solution": "The problem requires the programmatic diagnosis of cross-stream correlation for two parallelization strategies of a Linear Congruential Generator (LCG). The two strategies are leapfrog splitting and skip-ahead seeding. The diagnosis is performed by estimating the empirical covariance between the first two streams (indexed $i=0$ and $j=1$).\n\nThe core of the LCG is the recurrence relation:\n$$\nx_{n+1} = (a x_n + c) \\bmod m\n$$\nwhere $x_n$ is the integer state at step $n$, and $a$, $c$, and $m$ are the multiplier, increment, and modulus, respectively. The output uniform random variate is $U_n = x_n/m$. This recurrence is an affine transformation on the ring of integers modulo $m$.\n\nTo advance the generator by $k$ steps, from $x_n$ to $x_{n+k}$, we can compose this affine map with itself $k$ times. This composition corresponds to matrix exponentiation. The state update can be written in homogeneous coordinates as:\n$$\n\\begin{pmatrix} x_{n+1} \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} a  c \\\\ 0  1 \\end{pmatrix} \\begin{pmatrix} x_n \\\\ 1 \\end{pmatrix} \\pmod m\n$$\nIterating this $k$ times yields:\n$$\n\\begin{pmatrix} x_{n+k} \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} a  c \\\\ 0  1 \\end{pmatrix}^k \\begin{pmatrix} x_n \\\\ 1 \\end{pmatrix} \\pmod m\n$$\nLet the $k$-step transition matrix be $M_k = \\begin{pmatrix} a_k  c_k \\\\ 0  1 \\end{pmatrix}$, where $M_k = \\begin{pmatrix} a  c \\\\ 0  1 \\end{pmatrix}^k \\pmod m$. The $k$-step update is then $x_{n+k} = (a_k x_n + c_k) \\bmod m$. The matrix $M_k$ can be calculated efficiently using the method of exponentiation by squaring, performing matrix multiplications modulo $m$. Since the second row is always $(0, 1)$, we only need to compute the transformation of the pair $(a, c)$. If we have two such transformations $(a', c')$ and $(a'', c'')$, their composition is:\n$$\n(a', c') \\circ (a'', c'') = (a'a'' \\pmod m, (a'c'' + c') \\pmod m)\n$$\nThis corresponds to the multiplication of their associated matrices. The identity transformation is $(1, 0)$.\n\nThe implementation will proceed as follows for each test case, which provides parameters $(m, a, c, L)$ and fixes $P=4$, $T=200000$, and $x_0=42$.\n\n**1. Leapfrog Splitting**\nFor this method with $P$ streams, stream $i$ consists of the sequence $\\{x_i, x_{i+P}, x_{i+2P}, \\dots\\}$. The problem states we must compare streams $i=0$ and $j=1$.\n\n- First, we compute the $P$-step affine map $(a_P, c_P)$ by calculating $M_P = \\begin{pmatrix} a  c \\\\ 0  1 \\end{pmatrix}^P \\pmod m$. In this problem, $P=4$.\n- The seed for stream $0$ is $x_0$.\n- The seed for stream $1$ is $x_1 = (a x_0 + c) \\bmod m$.\n- We generate a sequence of $T$ states for stream $0$ by starting with $s_0^{(0)} = x_0$ and repeatedly applying the $P$-step transformation: $s_{t+1}^{(0)} = (a_P s_t^{(0)} + c_P) \\bmod m$ for $t = 0, \\dots, T-2$.\n- Similarly, we generate a sequence of $T$ states for stream $1$ by starting with $s_0^{(1)} = x_1$ and applying the same $P$-step transformation.\n- The two sequences of states are converted to uniform variates by dividing by $m$.\n\n**2. Skip-Ahead Seeding**\nFor this method with stride $L$, stream $i$ starts at state $x_{iL}$ and proceeds with the original $1$-step LCG. We compare streams $i=0$ and $j=1$.\n\n- The seed for stream $0$ is $x_{0 \\cdot L} = x_0$.\n- The seed for stream $1$ is $x_{1 \\cdot L} = x_L$. To find this seed, we compute the $L$-step affine map $(a_L, c_L)$ by calculating $M_L = \\begin{pmatrix} a  c \\\\ 0  1 \\end{pmatrix}^L \\pmod m$. The seed is then $x_L = (a_L x_0 + c_L) \\bmod m$.\n- We generate a sequence of $T$ states for stream $0$ by starting with $s_0^{(0)} = x_0$ and repeatedly applying the $1$-step transformation: $s_{t+1}^{(0)} = (a s_t^{(0)} + c) \\bmod m$ for $t = 0, \\dots, T-2$.\n- We generate a sequence of $T$ states for stream $1$ by starting with $s_0^{(1)} = x_L$ and applying the same $1$-step transformation.\n- The two sequences of states are converted to uniform variates by dividing by $m$.\n\n**3. Covariance Estimation**\nFor each of the two methods, we obtain two sequences of uniform variates of length $T$, which we an denote as $(u_t)_{t=1}^T$ and $(v_t)_{t=1}^T$. We then compute the empirical unbiased covariance using the provided formula:\n$$\n\\widehat{\\operatorname{Cov}}(u,v) = \\frac{1}{T-1}\\sum_{t=1}^{T} \\left(u_t - \\bar u\\right)\\left(v_t - \\bar v\\right)\n$$\nwhere $\\bar u$ and $\\bar v$ are the sample means of the respective sequences. This will be calculated numerically for the generated streams.\n\nThe procedure is repeated for all three test cases, and the six resulting covariance estimates are reported.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n\n    # Test cases: (m, a, c, L)\n    test_cases = [\n        (2147483647, 16807, 0, 10**7),\n        (2147483648, 1103515245, 12345, 10**6),\n        (1048576, 5, 1, 65536)\n    ]\n    \n    # Common parameters\n    P = 4\n    T = 200000\n    x0 = 42\n    \n    results = []\n    \n    for m, a, c, L in test_cases:\n        # --- Leapfrog Splitting ---\n        \n        # 1. Compute P-step affine map (a_P, c_P)\n        a_P, c_P = mat_pow((a, c), P, m)\n        \n        # 2. Determine initial seeds for stream 0 and 1\n        seed0_leap = x0\n        seed1_leap = (a * x0 + c) % m\n        \n        # 3. Generate streams\n        stream0_leap = generate_sequence(seed0_leap, T, a_P, c_P, m)\n        stream1_leap = generate_sequence(seed1_leap, T, a_P, c_P, m)\n        \n        # 4. Calculate covariance\n        cov_leapfrog = calculate_covariance(stream0_leap, stream1_leap)\n        results.append(cov_leapfrog)\n        \n        # --- Skip-ahead Seeding ---\n        \n        # 1. Compute L-step affine map to find seed for stream 1\n        a_L, c_L = mat_pow((a, c), L, m)\n        \n        # 2. Determine initial seeds for stream 0 and 1\n        seed0_skip = x0\n        seed1_skip = (a_L * x0 + c_L) % m\n        \n        # 3. Generate streams using 1-step map\n        stream0_skip = generate_sequence(seed0_skip, T, a, c, m)\n        stream1_skip = generate_sequence(seed1_skip, T, a, c, m)\n        \n        # 4. Calculate covariance\n        cov_skipahead = calculate_covariance(stream0_skip, stream1_skip)\n        results.append(cov_skipahead)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef mat_mul(A, B, m):\n    \"\"\"\n    Composes two LCG affine maps represented by (a, c) tuples.\n    This corresponds to multiplying their transformation matrices modulo m.\n    If A is (a1, c1) and B is (a2, c2), the composition is\n    (a1*a2, a1*c2 + c1) mod m.\n    \"\"\"\n    a1, c1 = A\n    a2, c2 = B\n    new_a = (a1 * a2) % m\n    new_c = (a1 * c2 + c1) % m\n    return (new_a, new_c)\n\ndef mat_pow(A, k, m):\n    \"\"\"\n    Computes A^k mod m for an affine map A=(a,c) using exponentiation by squaring.\n    \"\"\"\n    # Identity transformation is (1, 0)\n    res = (1, 0)\n    # The exponentiation by squaring algorithm\n    base = A\n    while k > 0:\n        if k % 2 == 1:\n            res = mat_mul(res, base, m)\n        base = mat_mul(base, base, m)\n        k //= 2\n    return res\n\ndef generate_sequence(seed, length, a, c, m):\n    \"\"\"\n    Generates a sequence of random variates from an LCG.\n    Returns a numpy array of uniform variates in [0, 1).\n    \"\"\"\n    states = np.empty(length, dtype=np.uint64)\n    current_state = seed\n    for i in range(length):\n        states[i] = current_state\n        current_state = (a * current_state + c) % m\n    \n    # Convert states to uniforms\n    return states / m\n\ndef calculate_covariance(u, v):\n    \"\"\"\n    Computes the unbiased sample covariance between two sequences u and v.\n    \"\"\"\n    # ddof=1 for unbiased estimator (N-1 in denominator)\n    # np.cov returns the covariance matrix. We need the off-diagonal element.\n    cov_matrix = np.cov(u, v, ddof=1)\n    return cov_matrix[0, 1]\n\nsolve()\n```", "id": "3338230"}]}