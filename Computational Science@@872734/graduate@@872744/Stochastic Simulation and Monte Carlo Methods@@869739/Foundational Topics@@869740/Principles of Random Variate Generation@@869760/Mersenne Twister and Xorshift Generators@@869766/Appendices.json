{"hands_on_practices": [{"introduction": "The xorshift family of generators is highly regarded for its speed and simplicity, relying on just a few bitwise shift and exclusive-or operations. Despite their simple algorithmic description, these operations define a linear transformation over the finite field of two elements, $\\mathbb{F}_2$. This exercise guides you through the crucial process of translating the generator's algorithm into its underlying matrix representation, a fundamental step for any rigorous analysis [@problem_id:3320137]. By constructing the transition matrix and examining its characteristic polynomial, you will learn to apply the powerful tools of linear algebra to determine a generator's period.", "problem": "Consider a four-word xorshift generator known as xorshift128. Its internal state at step $n$ is the $128$-bit vector $s_{n} \\in \\{0,1\\}^{128}$, partitioned into four $32$-bit words $x_{n}, y_{n}, z_{n}, w_{n} \\in \\{0,1\\}^{32}$. The bitwise exclusive-or is the group operation in the vector space over the Galois Field (GF) $\\mathbb{F}_{2}$, so all updates are linear over $\\mathbb{F}_{2}$. Define the left-shift-by-$k$ and right-shift-by-$k$ maps on a $32$-bit word by zero-filling and discarding shifted-out bits. Let $S_{L}(k) \\in \\mathbb{F}_{2}^{32 \\times 32}$ and $S_{R}(k) \\in \\mathbb{F}_{2}^{32 \\times 32}$ denote the matrices implementing these maps, so that for any $u \\in \\{0,1\\}^{32}$ one has $u \\ll k = S_{L}(k) u$ and $u \\gg k = S_{R}(k) u$. Concretely, with indices $i,j \\in \\{0,1,\\dots,31\\}$, take\n$$\n\\big(S_{L}(k)\\big)_{i,j} =\n\\begin{cases}\n1  \\text{if } j+k = i, \\\\\n0  \\text{otherwise},\n\\end{cases}\n\\qquad\n\\big(S_{R}(k)\\big)_{i,j} =\n\\begin{cases}\n1  \\text{if } j = i+k, \\\\\n0  \\text{otherwise}.\n\\end{cases}\n$$\nConsider the following update rule (with shift parameters $a = 11$, $b = 8$, and $c = 19$):\n$$\nt_{n} = x_{n} \\oplus (x_{n} \\ll a), \\quad\nx_{n+1} = y_{n}, \\quad\ny_{n+1} = z_{n}, \\quad\nz_{n+1} = w_{n}, \\quad\nw_{n+1} = w_{n} \\oplus (w_{n} \\gg c) \\oplus t_{n} \\oplus (t_{n} \\gg b),\n$$\nwhere $\\oplus$ denotes addition in $\\mathbb{F}_{2}$, and $\\ll, \\gg$ denote the left and right shifts defined above. By stacking the words, represent the state as the column vector\n$$\ns_{n} =\n\\begin{pmatrix}\nx_{n} \\\\\ny_{n} \\\\\nz_{n} \\\\\nw_{n}\n\\end{pmatrix}\n\\in \\mathbb{F}_{2}^{128}.\n$$\nTasks:\n- Using only linear-algebra primitives over $\\mathbb{F}_{2}$ and the definitions of $S_{L}(k)$ and $S_{R}(k)$, construct the $\\mathbb{F}_{2}$-linear transition matrix $M \\in \\mathbb{F}_{2}^{128 \\times 128}$ such that $s_{n+1} = M s_{n}$, in block form with $32 \\times 32$ blocks. Express the blocks in terms of $I_{32}$, $S_{L}(a)$, and $S_{R}(b), S_{R}(c)$.\n- Compute the characteristic polynomial $p(\\lambda) \\in \\mathbb{F}_{2}[\\lambda]$ of $M$, expressing it in closed form using a determinant of a $32 \\times 32$ matrix polynomial in $\\lambda$.\n- From first principles of linear recurrences over finite fields, determine the period of the generator on the nonzero state space $\\mathbb{F}_{2}^{128} \\setminus \\{0\\}$.\n\nProvide your final answer as a single row matrix with three entries: the block expression for $M$, the characteristic polynomial $p(\\lambda)$, and the period expression; entries may be matrix or scalar analytic expressions, and the period must be expressed exactly without numerical approximation. No rounding is required, and no physical units are involved. The answer must be a calculation object as specified.", "solution": "The user wants me to solve a problem about a xorshift128 generator.\n\n### Step 1: Problem Validation\n\nI will first validate the problem statement.\n\n#### Step 1.1: Extract Givens\n\n-   **State Space**: The state at step $n$ is a $128$-bit vector $s_{n} \\in \\{0,1\\}^{128}$, which is partitioned into four $32$-bit words $x_{n}, y_{n}, z_{n}, w_{n} \\in \\{0,1\\}^{32}$.\n-   **Field**: All operations are in the Galois Field $\\mathbb{F}_{2}$. The bitwise exclusive-or ($\\oplus$) corresponds to addition.\n-   **Shift Operators**: The left-shift ($u \\ll k$) and right-shift ($u \\gg k$) maps are represented by matrices $S_{L}(k) \\in \\mathbb{F}_{2}^{32 \\times 32}$ and $S_{R}(k) \\in \\mathbb{F}_{2}^{32 \\times 32}$, respectively. Their definitions are provided as:\n    $$ \\big(S_{L}(k)\\big)_{i,j} = \\begin{cases} 1  \\text{if } j+k = i, \\\\ 0  \\text{otherwise}, \\end{cases} \\qquad \\big(S_{R}(k)\\big)_{i,j} = \\begin{cases} 1  \\text{if } j = i+k, \\\\ 0  \\text{otherwise}. \\end{cases} $$\n-   **Constants**: The shift parameters are given as $a = 11$, $b = 8$, and $c = 19$.\n-   **Recurrence Relations**: The state update rules are:\n    $$\n    t_{n} = x_{n} \\oplus (x_{n} \\ll a) \\\\\n    x_{n+1} = y_{n} \\\\\n    y_{n+1} = z_{n} \\\\\n    z_{n+1} = w_{n} \\\\\n    w_{n+1} = w_{n} \\oplus (w_{n} \\gg c) \\oplus t_{n} \\oplus (t_{n} \\gg b)\n    $$\n-   **State Vector**: The state is represented by the column vector $s_{n} = (x_{n}^T, y_{n}^T, z_{n}^T, w_{n}^T)^T \\in \\mathbb{F}_{2}^{128}$.\n-   **Tasks**:\n    1.  Construct the transition matrix $M \\in \\mathbb{F}_{2}^{128 \\times 128}$ such that $s_{n+1} = M s_{n}$, expressing its $32 \\times 32$ blocks in terms of $I_{32}$, $S_{L}(a)$, $S_{R}(b)$, and $S_{R}(c)$.\n    2.  Compute the characteristic polynomial $p(\\lambda) \\in \\mathbb{F}_{2}[\\lambda]$ of $M$.\n    3.  Determine the period of the generator on the nonzero state space $\\mathbb{F}_{2}^{128} \\setminus \\{0\\}$.\n\n#### Step 1.2: Validate Using Extracted Givens\n\n-   **Scientifically Grounded**: The problem describes a linear-feedback shift register (LFSR) known as a xorshift generator. This is a standard and well-understood topic in computational mathematics and computer science, specifically in the area of pseudorandom number generation. The mathematical framework is linear algebra over the finite field $\\mathbb{F}_{2}$, which is rigorous and well-established. The problem is scientifically sound.\n-   **Well-Posed**: The problem provides a complete definition of a linear dynamical system and asks for its transition matrix, characteristic polynomial, and period. These are all well-defined mathematical objects that can be uniquely determined from the given information. The problem is well-posed.\n-   **Objective**: The problem is stated in precise, formal mathematical language, devoid of any subjectivity, ambiguity, or opinion. It is purely objective.\n\n#### Step 1.3: Verdict and Action\n\nThe problem is valid as it is scientifically grounded, well-posed, and objective. I will proceed with the solution.\n\n### Step 2: Solution\n\n#### Task 1: Construct the Transition Matrix $M$\n\nThe state update is given by the linear transformation $s_{n+1} = M s_n$. We need to find the $128 \\times 128$ matrix $M$ over $\\mathbb{F}_2$ in its $4 \\times 4$ block form, where each block is a $32 \\times 32$ matrix. The state vectors are $s_n = (x_n^T, y_n^T, z_n^T, w_n^T)^T$ and $s_{n+1} = (x_{n+1}^T, y_{n+1}^T, z_{n+1}^T, w_{n+1}^T)^T$.\n\nThe update rules for the first three words are simple shifts in the block vector:\n$x_{n+1} = y_n \\implies x_{n+1} = 0 \\cdot x_n + I_{32} \\cdot y_n + 0 \\cdot z_n + 0 \\cdot w_n$\n$y_{n+1} = z_n \\implies y_{n+1} = 0 \\cdot x_n + 0 \\cdot y_n + I_{32} \\cdot z_n + 0 \\cdot w_n$\n$z_{n+1} = w_n \\implies z_{n+1} = 0 \\cdot x_n + 0 \\cdot y_n + 0 \\cdot z_n + I_{32} \\cdot w_n$\n\nThese equations determine the first three block-rows of the matrix $M$:\n-   Row 1: $[0, I_{32}, 0, 0]$\n-   Row 2: $[0, 0, I_{32}, 0]$\n-   Row 3: $[0, 0, 0, I_{32}]$\n\nNow we analyze the update for $w_{n+1}$. We first express the intermediate term $t_n$ in matrix form:\n$t_n = x_n \\oplus (x_n \\ll a) = I_{32} x_n + S_L(a) x_n = (I_{32} + S_L(a)) x_n$.\n\nNext, we express $w_{n+1}$ in terms of the words at step $n$. All arithmetic is in $\\mathbb{F}_2$.\n$w_{n+1} = w_n \\oplus (w_n \\gg c) \\oplus t_n \\oplus (t_n \\gg b)$\nUsing the linearity of the shift operators, we can write this in matrix form:\n$w_{n+1} = (I_{32} w_n + S_R(c) w_n) + (I_{32} t_n + S_R(b) t_n)$\n$w_{n+1} = (I_{32} + S_R(c)) w_n + (I_{32} + S_R(b)) t_n$\n\nNow substitute the expression for $t_n$:\n$w_{n+1} = (I_{32} + S_R(c)) w_n + (I_{32} + S_R(b)) (I_{32} + S_L(a)) x_n$\n\nThis equation gives the fourth block-row of $M$:\n$w_{n+1} = M_{41} x_n + M_{42} y_n + M_{43} z_n + M_{44} w_n$.\nBy comparing coefficients, we identify the blocks:\n$M_{41} = (I_{32} + S_R(b))(I_{32} + S_L(a))$\n$M_{42} = 0$\n$M_{43} = 0$\n$M_{44} = I_{32} + S_R(c)$\n\nCombining these blocks, the transition matrix $M$ is a block companion matrix:\n$$\nM = \\begin{pmatrix}\n0  I_{32}  0  0 \\\\\n0  0  I_{32}  0 \\\\\n0  0  0  I_{32} \\\\\n(I_{32} + S_R(b))(I_{32} + S_L(a))  0  0  I_{32} + S_R(c)\n\\end{pmatrix}\n$$\n\n#### Task 2: Compute the Characteristic Polynomial $p(\\lambda)$\n\nThe characteristic polynomial is $p(\\lambda) = \\det(M - \\lambda I_{128})$. Since we are working over $\\mathbb{F}_2$, this is equivalent to $p(\\lambda) = \\det(M + \\lambda I_{128})$.\n$$\nM + \\lambda I_{128} = \\begin{pmatrix}\n\\lambda I_{32}  I_{32}  0  0 \\\\\n0  \\lambda I_{32}  I_{32}  0 \\\\\n0  0  \\lambda I_{32}  I_{32} \\\\\nA  0  0  B + \\lambda I_{32}\n\\end{pmatrix}\n$$\nwhere $A = (I_{32} + S_R(b))(I_{32} + S_L(a))$ and $B = I_{32} + S_R(c)$.\nFor a block companion matrix of the form\n$$ C = \\begin{pmatrix} 0  I  \\dots  0 \\\\ \\vdots   \\ddots  \\\\ 0  0  \\dots  I \\\\ C_0  C_1  \\dots  C_{k-1} \\end{pmatrix} $$\nthe characteristic polynomial is given by $\\det(\\lambda^k I - \\sum_{i=0}^{k-1} \\lambda^i C_i)$.\nWorking in $\\mathbb{F}_2$, subtraction is the same as addition. Thus, the characteristic polynomial is:\n$p(\\lambda) = \\det(\\lambda^4 I_{32} + \\lambda^3 C_3 + \\lambda^2 C_2 + \\lambda C_1 + C_0)$\nSubstituting the values of $C_i$:\n$p(\\lambda) = \\det(\\lambda^4 I_{32} + \\lambda^3 (I_{32} + S_R(c)) + \\lambda^2(0) + \\lambda(0) + (I_{32} + S_R(b))(I_{32} + S_L(a)))$\nThis simplifies to:\n$$\np(\\lambda) = \\det(\\lambda^4 I_{32} + \\lambda^3 (I_{32} + S_R(c)) + (I_{32} + S_R(b))(I_{32} + S_L(a)))\n$$\nThis is a polynomial of degree $4 \\times 32 = 128$ in $\\mathbb{F}_2[\\lambda]$.\n\n#### Task 3: Determine the Period of the Generator\n\nThe sequence of states is generated by $s_{n+1} = M s_n$. Since the transformation $M$ is linear and invertible (as $\\det(M) = \\det(A) = \\det(I+S_R(b))\\det(I+S_L(a)) = 1 \\cdot 1 = 1$, since $S_L(a)$ and $S_R(b)$ are nilpotent and $I+N$ is invertible for nilpotent $N$ in fields of characteristic $2$), the state $s_n=0$ is a fixed point. For any nonzero initial state $s_0 \\in \\mathbb{F}_2^{128} \\setminus \\{0\\}$, the sequence of states $s_n$ is periodic. The period is the smallest integer $k  0$ such that $s_k=s_0$, which is equivalent to finding the order of the matrix $M$ in the general linear group $GL(128, \\mathbb{F}_2)$.\n\nFrom the theory of linear recurrences over finite fields, the maximum possible period for a $d$-dimensional recurrence is $2^d - 1$. This maximum period is achieved if and only if the characteristic polynomial of the transition matrix, $p(\\lambda)$, is a primitive polynomial of degree $d$ over $\\mathbb{F}_2$. A primitive polynomial is an irreducible polynomial which is also a generator of the multiplicative group of the extension field $\\mathbb{F}_{2^d}$.\n\nThe generator described in this problem, with parameters $a=11, b=8, c=19$, is a specific instance of the `xorshift128` generator designed by George Marsaglia. Such generators are constructed by carefully choosing the shift parameters precisely so that the resulting characteristic polynomial is primitive. The problem names the generator, implicitly providing the information that it is of maximal period. Proving the primitivity of a degree-$128$ polynomial from first principles is a task of immense computational complexity and is beyond the scope of this problem. The principle to be applied here is the connection between primitive characteristic polynomials and maximal-length sequences.\n\nGiven that the characteristic polynomial $p(\\lambda)$ is a primitive polynomial of degree $128$ over $\\mathbb{F}_2$, the transition matrix $M$ is a generator of a cyclic subgroup of order $2^{128}-1$ within $GL(128, \\mathbb{F}_2)$. Consequently, the state space $\\mathbb{F}_2^{128} \\setminus \\{0\\}$ is partitioned into a single cycle of length $2^{128}-1$.\n\nTherefore, the period of the generator on the nonzero state space is $2^{128} - 1$.", "answer": "$$ \\boxed{ \\begin{pmatrix} \\begin{pmatrix} 0  I_{32}  0  0 \\\\ 0  0  I_{32}  0 \\\\ 0  0  0  I_{32} \\\\ (I_{32} + S_R(b))(I_{32} + S_L(a))  0  0  I_{32} + S_R(c) \\end{pmatrix}  \\det(\\lambda^4 I_{32} + \\lambda^3 (I_{32} + S_R(c)) + (I_{32} + S_R(b))(I_{32} + S_L(a)))  2^{128} - 1 \\end{pmatrix} } $$", "id": "3320137"}, {"introduction": "While many generators are designed to have a single, massive cycle, this is only true if their characteristic polynomial is primitive. This practice explores the more complex, and common, scenario where the polynomial is reducible, leading to a richer state space structure. The Chinese Remainder Theorem provides a framework for decomposing the state space into independent subspaces, each corresponding to an irreducible factor of the characteristic polynomial [@problem_id:3320141]. By dissecting a toy generator's state space into its constituent cycles, you will gain a deep, intuitive understanding of how abstract polynomial properties directly govern the generator's global dynamics, including the number and length of so-called \"short cycles\".", "problem": "An abstraction of the Mersenne Twister (MT) state transition is an invertible linear map over the two-element field $\\mathbb{F}_{2}$, acting on a finite-dimensional $\\mathbb{F}_{2}$-vector space. Consider a toy Mersenne Twister (MT) state transition $T$ on $\\mathbb{F}_{2}^{12}$ with the following properties.\n\n1. The characteristic polynomial of $T$ is \n$$\nP(x) \\;=\\; p_{1}(x)\\,p_{2}(x),\n$$\nwhere $p_{1}(x)$ and $p_{2}(x)$ are distinct monic irreducible polynomials over $\\mathbb{F}_{2}$ of degrees $8$ and $4$, respectively, each with nonzero constant term. Assume $p_{2}(x)=x^{4}+x+1$ and that $p_{1}(x)$ is some fixed degree-$8$ irreducible polynomial. \n\n2. Regard $\\mathbb{F}_{2}^{12}$ as the $\\mathbb{F}_{2}[x]$-module obtained from the action of $T$ by $x\\cdot v := T(v)$. By the Chinese Remainder Theorem for modules and coprimeness of $p_{1}$ and $p_{2}$, the space decomposes as an $\\mathbb{F}_{2}[x]$-module\n$$\n\\mathbb{F}_{2}^{12} \\;\\cong\\; \\mathbb{F}_{2}[x]/(p_{1}) \\;\\oplus\\; \\mathbb{F}_{2}[x]/(p_{2}),\n$$\nwhere the action of $T$ corresponds to multiplication by the residue class of $x$ in each component.\n\n3. Let $m_{i}$ denote the multiplicative order of the residue class of $x$ in the unit group $\\big(\\mathbb{F}_{2}[x]/(p_{i})\\big)^{\\times}$, which divides $2^{\\deg p_{i}}-1$. It is known that $\\deg p_{2}=4$ and $p_{2}(x)=x^{4}+x+1$ is primitive of order $m_{2}=15$, and that there exists a degree-$8$ irreducible $p_{1}$ for which $m_{1}=17$ (non-primitive). Assume these orders hold for the given $p_{1}$ and $p_{2}$.\n\nUsing only the linearity over $\\mathbb{F}_{2}$ and the above structural facts, do the following:\n\na) Derive the cycle structure of $T$ on $\\mathbb{F}_{2}^{12}$ in terms of the four disjoint classes of states corresponding to the pair $(u,v) \\in \\mathbb{F}_{2}[x]/(p_{1}) \\oplus \\mathbb{F}_{2}[x]/(p_{2})$ being zero or nonzero on each component. Express the period of a state in each class in terms of $m_{1}$ and $m_{2}$, and justify your conclusions from first principles.\n\nb) Compute the period of a generic nonzero state (meaning both components $u$ and $v$ are nonzero). Also compute how many states have this generic period, and how many cycles of the generic period exist.\n\nc) Define a “short cycle” to be any cycle whose length is strictly less than the generic period. Determine how many short cycles there are in total. Give your final answer as a single integer (no units).", "solution": "The problem describes a linear transformation $T$ on the vector space $V = \\mathbb{F}_{2}^{12}$ over the field of two elements $\\mathbb{F}_{2}$. The structure of this transformation is given by its characteristic polynomial $P(x) = p_{1}(x)p_{2}(x)$, where $p_{1}(x)$ and $p_{2}(x)$ are distinct irreducible polynomials over $\\mathbb{F}_{2}$ with degrees $\\deg p_{1} = 8$ and $\\deg p_{2} = 4$.\n\nSince $p_{1}(x)$ and $p_{2}(x)$ are coprime, the Chinese Remainder Theorem for polynomial rings implies that the space $V$ decomposes as a direct sum of $T$-invariant subspaces $V_1$ and $V_2$:\n$$\nV \\cong V_1 \\oplus V_2\n$$\nwhere $V_1 = \\ker(p_1(T))$ and $V_2 = \\ker(p_2(T))$. As $\\mathbb{F}_{2}[x]$-modules, where the action of $x$ corresponds to the action of $T$, this decomposition is given as:\n$$\nV \\cong \\frac{\\mathbb{F}_{2}[x]}{(p_{1}(x))} \\oplus \\frac{\\mathbb{F}_{2}[x]}{(p_{2}(x))}\n$$\nThe subspaces $V_1$ and $V_2$ are vector spaces over $\\mathbb{F}_2$ of dimension $\\deg p_1 = 8$ and $\\deg p_2 = 4$, respectively. Thus, $|V_1| = 2^8 = 256$ and $|V_2| = 2^4 = 16$. The total number of states in $V$ is $|V_1| \\times |V_2| = 2^8 \\times 2^4 = 2^{12} = 4096$.\n\nAny state $w \\in V$ can be uniquely represented as a pair $(u, v)$ where $u \\in V_1$ and $v \\in V_2$. The action of $T$ on such a pair is component-wise: $T(w) = T((u, v)) = (T_1(u), T_2(v))$, where $T_1$ and $T_2$ are the restrictions of $T$ to $V_1$ and $V_2$. In the module representation, $T_1$ corresponds to multiplication by $x$ in $\\mathbb{F}_2[x]/(p_1(x))$ and $T_2$ corresponds to multiplication by $x$ in $\\mathbb{F}_2[x]/(p_2(x))$.\n\nThe period of a state $w=(u,v)$ is the smallest positive integer $k$ such that $T^k(w) = w$. This is equivalent to the conditions $T_1^k(u) = u$ and $T_2^k(v) = v$.\n\na) To derive the cycle structure, we classify states based on whether their components $u$ and $v$ are zero or nonzero.\n\n1.  **Class 1: $u=0, v=0$**. This corresponds to the zero state $w=(0,0) \\in V$. $T(0,0) = (0,0)$, so the period is $1$. There is exactly $1$ such state, forming a single cycle of length $1$.\n\n2.  **Class 2: $u \\neq 0, v=0$**. The state is $w=(u,0)$ with $u \\in V_1 \\setminus \\{0\\}$. The period $k$ is the smallest integer such that $T_1^k(u) = u$. Since $p_1(x)$ is irreducible, $V_1 \\cong \\mathbb{F}_2[x]/(p_1(x))$ is a field, specifically the finite field $\\mathbb{F}_{2^8}$. For any nonzero $u \\in V_1$, the equation $T_1^k(u) = u$ is equivalent to $x^k u = u$. As $V_1$ is a field, we can multiply by $u^{-1}$ to get $x^k = 1$ in $V_1$. The smallest positive integer $k$ for which this holds is the multiplicative order of the residue class of $x$ in the group $(\\mathbb{F}_2[x]/(p_1(x)))^\\times$. The problem gives this order as $m_1 = 17$. Therefore, every state in this class has a period of $m_1 = 17$.\n\n3.  **Class 3: $u=0, v \\neq 0$**. The state is $w=(0,v)$ with $v \\in V_2 \\setminus \\{0\\}$. By identical reasoning as in Class 2, the period is determined by the multiplicative order of $x$ in the field $V_2 \\cong \\mathbb{F}_2[x]/(p_2(x)) = \\mathbb{F}_{2^4}$. The problem provides that $p_2(x) = x^4+x+1$ is primitive, so this order is $m_2 = 2^4 - 1 = 15$. Thus, every state in this class has a period of $m_2 = 15$.\n\n4.  **Class 4: $u \\neq 0, v \\neq 0$**. The period $k$ must satisfy both $T_1^k(u)=u$ and $T_2^k(v)=v$. This is equivalent to $x^k=1$ in $V_1$ and $x^k=1$ in $V_2$. This means $k$ must be a common multiple of the orders $m_1$ and $m_2$. The smallest such positive integer $k$ is the least common multiple of these orders. The period of any state in this class is $\\operatorname{lcm}(m_1, m_2)$.\n\nb) A generic nonzero state is one where both components are nonzero, i.e., a state from Class 4.\n\nThe period of a generic state is $\\operatorname{lcm}(m_1, m_2) = \\operatorname{lcm}(17, 15)$. Since $17$ is prime and $15 = 3 \\times 5$, $\\gcd(17, 15) = 1$. Therefore, the period is $\\operatorname{lcm}(17, 15) = 17 \\times 15 = 255$.\n\nThe number of states with this generic period is the number of ways to choose a nonzero $u \\in V_1$ and a nonzero $v \\in V_2$.\nNumber of choices for $u \\neq 0$ is $|V_1| - 1 = 2^8 - 1 = 256 - 1 = 255$.\nNumber of choices for $v \\neq 0$ is $|V_2| - 1 = 2^4 - 1 = 16 - 1 = 15$.\nThe total number of states with the generic period is $(2^8-1)(2^4-1) = 255 \\times 15 = 3825$.\n\nThese $3825$ states are partitioned into disjoint cycles, each of length $255$. The number of such cycles is the total number of states divided by the cycle length:\nNumber of cycles = $\\frac{3825}{255} = 15$.\n\nc) A \"short cycle\" is a cycle with length strictly less than the generic period of $255$. These correspond to states in Classes 1, 2, and 3. We must count the number of cycles, not the number of states.\n\n-   **Cycles of length 1**: These come from Class 1 states. There is $1$ such state, $(0,0)$, which forms $1$ cycle of length $1$.\n\n-   **Cycles of length 17**: These come from Class 2 states ($u \\neq 0, v=0$). There are $|V_1|-1 = 2^8-1 = 255$ such states. Each of these states lies on a cycle of length $m_1=17$. The number of such cycles is $\\frac{255}{17} = 15$.\n\n-   **Cycles of length 15**: These come from Class 3 states ($u=0, v \\neq 0$). There are $|V_2|-1 = 2^4-1 = 15$ such states. Each of these states lies on a cycle of length $m_2=15$. The number of such cycles is $\\frac{15}{15} = 1$.\n\nThe lengths $1$, $15$, and $17$ are all strictly less than $255$. The total number of short cycles is the sum of the number of cycles of these lengths.\nTotal number of short cycles = (Number of cycles of length $1$) + (Number of cycles of length $15$) + (Number of cycles of length $17$).\nTotal number of short cycles = $1 + 1 + 15 = 17$.", "answer": "$$\\boxed{17}$$", "id": "3320141"}, {"introduction": "After analyzing the abstract mathematical structure of linear generators, it is vital to connect theory to observable, practical behavior. A key concern with any linear generator is the quality of its output when starting from a non-ideal initial state, such as one with a very low Hamming weight (few set bits). This computational exercise challenges you to empirically investigate the transient behavior of both xorshift and Mersenne Twister generators, measuring how long it takes for the output sequence to achieve statistical equilibrium [@problem_id:3320097]. By simulating the generators and tracking key metrics, you will gain a practical appreciation for the importance of proper initialization and the potential pitfalls of linear recurrences.", "problem": "You are to design and implement a program that empirically studies the Hamming-weight dynamics of two classes of pseudo-random number generators, and evaluates whether low-Hamming-weight seeds induce long transients in the associated Uniform distribution on the unit interval (U(0,1)) output sequence. The two generators are the Mersenne Twister (MT) and a single-step Exclusive-Or shift (xorshift) generator.\n\nStart from the following fundamental base:\n- A pseudo-random number generator (PRNG) is a deterministic map that produces a sequence intended to approximate independent samples from a target distribution, commonly the Uniform distribution on the unit interval (U(0,1)).\n- The state of many PRNGs is naturally modeled over the binary field, and their transitions are linear over the binary field or are compositions of bitwise operations. For a state represented as a $w$-bit word, the Hamming weight $H(x)$ of a word $x$ is the number of positions that are equal to $1$.\n- The Uniform distribution on the unit interval (U(0,1)) mapping for a $w$-bit output $x$ is defined by $u = x / 2^w$.\n\nThe two PRNGs to study are:\n1. Mersenne Twister (MT), whose internal state transition can be written as a linear transformation over the binary field, $x_{n+1} = A x_n$, where $A$ is a fixed matrix determined by the algorithm. In implementation, do not construct $A$; instead, use a reference implementation to generate the $w$-bit outputs and treat the update rule abstractly as linear.\n2. A single-step xorshift generator defined by\n$$\nx_{n+1} = x_n \\oplus (x_n \\ll a) \\oplus (x_n \\gg b),\n$$\nwhere $\\oplus$ denotes bitwise XOR, $\\ll$ denotes left shift, and $\\gg$ denotes right shift. The state is kept to $w$ bits by masking to $2^w - 1$ after each update.\n\nFor both generators:\n- Represent the output word as a $w$-bit unsigned integer and map it to $u_n = x_n / 2^w$ to obtain a value in $[0,1)$.\n- Define the empirical sample mean at time $n$ as $m_n = \\frac{1}{n}\\sum_{k=1}^n u_k$.\n- Define the instantaneous normalized Hamming weight at time $n$ as $r_n = H(x_n)/w$.\n\nDefine the transient length $T$ for a given generator and seed as the smallest index $n^\\star$ such that for the window of indices $j \\in \\{n^\\star, n^\\star+1, \\dots, n^\\star+W-1\\}$ both conditions\n$$\n\\lvert m_j - 0.5 \\rvert \\le \\varepsilon \\quad \\text{and} \\quad \\lvert r_j - 0.5 \\rvert \\le \\delta\n$$\nhold simultaneously, with the additional constraint $n^\\star \\ge n_{\\min}$. If no such $n^\\star$ exists up to $N_{\\max}$, set $T = N_{\\max}$.\n\nUse the following fixed parameters for all tests:\n- Word width $w = 32$.\n- Xorshift parameters $a = 13$ and $b = 17$.\n- Window length $W = 512$.\n- Minimum starting index $n_{\\min} = 64$.\n- Maximum number of steps $N_{\\max} = 100000$.\n- Mean tolerance $\\varepsilon = 0.01$.\n- Hamming-weight tolerance $\\delta = 0.125$.\n- For the mapping to U(0,1), always use $u_n = x_n / 2^w$.\n\nImplement the xorshift update exactly as stated. For Mersenne Twister (MT), use a reference MT19937 implementation to produce $w$-bit outputs and apply the U(0,1) mapping.\n\nTest Suite:\nCompute the transient length $T$ for both generators using the following $w$-bit seeds:\n- $s^{(1)} = 1$ (Hamming weight $1$).\n- $s^{(2)} = 2^{31} + 1$ (Hamming weight $2$).\n- $s^{(3)} = 0x12345678$ (a typical mid-weight pattern).\n- $s^{(4)} = 2^{32} - 1$ (Hamming weight $32$).\n- $s^{(5)} = 0$ (the absorbing state for the xorshift).\n\nFor each seed $s^{(i)}$ in the order $s^{(1)}, s^{(2)}, s^{(3)}, s^{(4)}, s^{(5)}$, compute and report the pair $[T_{\\text{xorshift}}, T_{\\text{MT}}]$.\n\nFinal Output Format:\nYour program should produce a single line of output containing a comma-separated list of the $5$ pairs corresponding to the seeds, enclosed in square brackets, with no spaces. For example,\n$$\n[ [T_{\\text{xorshift}}^{(1)},T_{\\text{MT}}^{(1)}],[T_{\\text{xorshift}}^{(2)},T_{\\text{MT}}^{(2)}],\\dots,[T_{\\text{xorshift}}^{(5)},T_{\\text{MT}}^{(5)}] ]\n$$\nbut rendered without spaces as\n$[[T_{\\text{xorshift}}^{(1)},T_{\\text{MT}}^{(1)}],[T_{\\text{xorshift}}^{(2)},T_{\\text{MT}}^{(2)}],[T_{\\text{xorshift}}^{(3)},T_{\\text{MT}}^{(3)}],[T_{\\text{xorshift}}^{(4)},T_{\\text{MT}}^{(4)}],[T_{\\text{xorshift}}^{(5)},T_{\\text{MT}}^{(5)}]]$.\n\nAll numeric outputs must be integers. The program must be self-contained and require no input.", "solution": "The problem will first be validated against the specified criteria of scientific soundness, well-posedness, and objectivity.\n\n### Problem Validation\n\n#### Step 1: Extract Givens\n\nThe verbatim givens extracted from the problem statement are as follows:\n\n- **Pseudo-Random Number Generators (PRNGs):**\n    1.  **Mersenne Twister (MT):** State transition is abstractly linear, $x_{n+1} = A x_n$. Use a reference MT19937 implementation to generate $w$-bit outputs.\n    2.  **xorshift:** A single-step generator defined by $x_{n+1} = x_n \\oplus (x_n \\ll a) \\oplus (x_n \\gg b)$, with state masked to $w$ bits.\n\n- **Fixed Parameters:**\n    - Word width: $w = 32$.\n    - Xorshift parameters: $a = 13$, $b = 17$.\n    - Window length: $W = 512$.\n    - Minimum starting index: $n_{\\min} = 64$.\n    - Maximum number of steps: $N_{\\max} = 100000$.\n    - Mean tolerance: $\\varepsilon = 0.01$.\n    - Hamming-weight tolerance: $\\delta = 0.125$.\n\n- **Definitions and Mappings:**\n    - Uniform mapping: $u_n = x_n / 2^w$.\n    - Empirical sample mean: $m_n = \\frac{1}{n}\\sum_{k=1}^n u_k$.\n    - Instantaneous normalized Hamming weight: $r_n = H(x_n)/w$, where $H(x)$ is the Hamming weight of $x$.\n\n- **Transient Length ($T$):**\n    - The smallest index $n^\\star$ such that:\n        1. $n^\\star \\ge n_{\\min}$.\n        2. For all $j \\in \\{n^\\star, n^\\star+1, \\dots, n^\\star+W-1\\}$, the conditions $\\lvert m_j - 0.5 \\rvert \\le \\varepsilon$ and $\\lvert r_j - 0.5 \\rvert \\le \\delta$ hold simultaneously.\n    - If no such $n^\\star$ exists up to $N_{\\max}$, then $T = N_{\\max}$.\n\n- **Test Suite (Seeds):**\n    - $s^{(1)} = 1$\n    - $s^{(2)} = 2^{31} + 1$\n    - $s^{(3)} = 0x12345678$\n    - $s^{(4)} = 2^{32} - 1$\n    - $s^{(5)} = 0$\n\n- **Output Requirement:**\n    - For each seed $s^{(i)}$, compute $[T_{\\text{xorshift}}, T_{\\text{MT}}]$.\n    - The final output is a single-line string of these pairs formatted as $[[...],[...],...]$.\n\n#### Step 2: Validate Using Extracted Givens\n\nThe problem is assessed against the validation criteria:\n\n- **Scientifically Grounded:** The problem is firmly rooted in the fields of computer science, numerical methods, and statistics. Mersenne Twister and xorshift generators are standard, well-documented PRNGs. The study of their state-space dynamics, particularly the behavior of low-Hamming-weight seeds and the transient period before reaching a stationary distribution, is a valid and important topic in stochastic simulation. The metrics used (sample mean, Hamming weight) are standard tools for analyzing PRNG output.\n\n- **Well-Posed:** The problem is well-posed. It provides all necessary parameters and unambiguous definitions to deterministically compute the transient length $T$. The existence of a solution is guaranteed because the simulation has a maximum length $N_{\\max}$, which serves as the default value for $T$ if the stability criteria are not met. The procedure is deterministic, ensuring a unique solution for each test case.\n\n- **Objective:** The problem is entirely objective, specified using precise mathematical definitions and numerical constants. There are no subjective or opinion-based statements.\n\n- **Flaw Analysis:**\n    1.  **Scientific/Factual Unsoundness:** None. The premises are factually correct. The identification of the seed $s^{(5)} = 0$ as an absorbing state for the given xorshift generator ($0 \\oplus (0 \\ll a) \\oplus (0 \\gg b) = 0$) is accurate.\n    2.  **Non-Formalizable or Irrelevant:** None. The problem is formalizable and directly relevant to the topic of PRNGs.\n    3.  **Incomplete or Contradictory Setup:** None. All required data and definitions are provided and are mutually consistent.\n    4.  **Unrealistic or Infeasible:** None. The simulation length $N_{\\max} = 100000$ and other parameters define a computationally feasible task.\n    5.  **Ill-Posed or Poorly Structured:** None. The definition of the transient length $T$ is precise and allows for a unique determination.\n    6.  **Pseudo-Profound, Trivial, or Tautological:** None. The problem requires a non-trivial simulation and analysis. The investigation connects seed properties (Hamming weight) to output quality, which is a core concept in PRNG evaluation.\n    7.  **Outside Scientific Verifiability:** None. The results are computationally verifiable by re-implementing the specified algorithm.\n\n#### Step 3: Verdict and Action\nThe problem is **valid**. A full solution will be provided.\n\n### Solution Design\n\nThe core of the problem is to implement a simulation for two PRNGs and determine a \"transient length\" $T$ based on the statistical properties of their output sequences. The solution will be structured in three main parts: implementation of the PRNGs, the algorithm for computing $T$, and the main execution loop for the test suite.\n\n#### 1. PRNG Implementations\n\nTwo generator functions will be created, one for xorshift and one for Mersenne Twister. Each will be initialized with a seed and will produce a sequence of $w=32$-bit unsigned integers.\n\n- **xorshift Generator:** The state update rule is $x_{n+1} = x_n \\oplus (x_n \\ll a) \\oplus (x_n \\gg b)$. The initial state $x_0$ is the provided seed. All operations are performed on $32$-bit unsigned integers, which requires masking with $2^{32}-1$ (or $0xFFFFFFFF$) after bitwise operations in Python to simulate fixed-width integer arithmetic. The seed $s^{(5)}=0$ is a fixed point, which will result in a sequence of zeros.\n\n- **Mersenne Twister (MT19937):** The problem specifies using a reference implementation. For this, the `numpy.random.MT19937` bit generator is the standard and correct choice in the specified Python environment. This generator will be seeded, and a `numpy.random.Generator` instance will be used to draw $32$-bit unsigned integers. The NumPy implementation correctly handles special seeds, such as $0$, by scrambling them to initialize a non-degenerate state vector.\n\n#### 2. Algorithm for Transient Length ($T$)\n\nA direct, two-loop approach (iterating through all possible start times $n^\\star$ and for each checking the next $W$ values) would be computationally expensive ($O(N_{\\max} \\cdot W)$). A more efficient single-pass algorithm ($O(N_{\\max})$) will be used.\n\nThe single-pass algorithm proceeds as follows:\n1. Initialize a counter for consecutive successful steps, `consecutive_successes`, to $0$.\n2. Iterate from $n=1$ to $N_{\\max}$. In each step:\n    a. Generate the next $w$-bit value $x_n$ from the PRNG.\n    b. Calculate the derived quantities: $u_n = x_n / 2^w$, the running mean $m_n = \\frac{1}{n}\\sum_{k=1}^n u_k$, and the normalized Hamming weight $r_n = H(x_n)/w$.\n    c. Check if the stability conditions are met: $C_n = (\\lvert m_n - 0.5 \\rvert \\le \\varepsilon) \\land (\\lvert r_n - 0.5 \\rvert \\le \\delta)$.\n    d. If $C_n$ is true, increment `consecutive_successes`. Otherwise, reset it to $0$.\n    e. After the update, check if `consecutive_successes` has reached the window length $W$. If it has, a stable window has just been completed. The starting index of this window is $n^\\star = n - W + 1$.\n    f. We must also satisfy the constraint $n^\\star \\ge n_{\\min}$. If `consecutive_successes` $\\ge W$ and $n - W + 1 \\ge n_{\\min}$, we have found the smallest $n^\\star$ that meets all criteria. The value $T = n - W + 1$ is returned, and the simulation for this generator-seed pair terminates.\n3. If the loop completes without finding such a window, the transient length $T$ is taken to be $N_{\\max}$.\n\nThis algorithm correctly identifies the *first* occurrence of a stable window of length $W$ whose starting index $n^\\star$ is at least $n_{\\min}$.\n\n#### 3. Main Execution and Output Formatting\n\nA main function will orchestrate the entire process.\n1. Define the fixed parameters ($w$, $a$, $b$, $W$, $n_{\\min}$, $N_{\\max}$, $\\varepsilon$, $\\delta$) and the list of seeds.\n2. Create a list to store the final results.\n3. Iterate through each seed in the specified order.\n4. For each seed, call the function that computes $T$ for both the `xorshift` and `MT` generators.\n5. Store the resulting pair $[T_{\\text{xorshift}}, T_{\\text{MT}}]$ in the results list.\n6. After processing all seeds, format the list of pairs into the required compact string format, e.g., `[[...],[...]]`, and print it to standard output.\n\nThis design is modular, efficient, and directly implements the logic described in the validated problem statement.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to conduct the PRNG study and produce the final output.\n    \"\"\"\n    \n    # Fixed parameters as specified in the problem statement.\n    W = 512          # Window length\n    N_MIN = 64       # Minimum starting index for T\n    N_MAX = 100000   # Maximum number of steps\n    EPSILON = 0.01   # Mean tolerance\n    DELTA = 0.125    # Hamming-weight tolerance\n    W_BITS = 32      # Word width\n    XOR_A = 13       # Xorshift parameter a\n    XOR_B = 17       # Xorshift parameter b\n\n    # Test suite of seeds.\n    test_cases = [\n        1,\n        2**31 + 1,\n        0x12345678,\n        2**32 - 1,\n        0,\n    ]\n\n    def compute_transient_length(generator_type, seed):\n        \"\"\"\n        Computes the transient length T for a given generator and seed.\n\n        Args:\n            generator_type (str): 'xorshift' or 'mt'.\n            seed (int): The initial seed for the generator.\n\n        Returns:\n            int: The computed transient length T.\n        \"\"\"\n        # Constants for 32-bit arithmetic and normalization.\n        TWO_POW_W = 2**W_BITS\n        MASK = TWO_POW_W - 1\n\n        # Initialize the appropriate generator.\n        if generator_type == 'xorshift':\n            x_state = seed  MASK\n            def next_val():\n                nonlocal x_state\n                # The state updates and the new state is the output value.\n                x_state = (x_state ^ (x_state  XOR_A) ^ (x_state  XOR_B))  MASK\n                return x_state\n        elif generator_type == 'mt':\n            bg = np.random.MT19937(seed)\n            rg = np.random.Generator(bg)\n            def next_val():\n                return int(rg.integers(TWO_POW_W, dtype=np.uint32))\n        else:\n            raise ValueError(\"Unknown generator type\")\n\n        total_u = 0.0\n        consecutive_successes = 0\n\n        # Main simulation loop from n=1 to N_MAX.\n        for n in range(1, N_MAX + 1):\n            x_n = next_val()\n\n            # Calculate derived metrics for the current step.\n            u_n = x_n / TWO_POW_W\n            total_u += u_n\n            m_n = total_u / n\n            r_n = bin(x_n).count('1') / W_BITS\n\n            # Check if the stability conditions are met.\n            is_success = (abs(m_n - 0.5) = EPSILON) and (abs(r_n - 0.5) = DELTA)\n            \n            if is_success:\n                consecutive_successes += 1\n            else:\n                consecutive_successes = 0\n\n            # Check if a stable window of length W has been found.\n            # The window is [n - W + 1, n]. Its start must be = N_MIN.\n            if consecutive_successes = W:\n                n_star = n - W + 1\n                if n_star = N_MIN:\n                    return n_star # Found the smallest T.\n\n        # If the loop finishes, no such window was found.\n        return N_MAX\n\n    results = []\n    for seed in test_cases:\n        t_xorshift = compute_transient_length('xorshift', seed)\n        t_mt = compute_transient_length('mt', seed)\n        results.append([t_xorshift, t_mt])\n    \n    # Format the final output string exactly as specified.\n    final_output = str(results).replace(' ', '')\n    print(final_output)\n\nsolve()\n```", "id": "3320097"}]}