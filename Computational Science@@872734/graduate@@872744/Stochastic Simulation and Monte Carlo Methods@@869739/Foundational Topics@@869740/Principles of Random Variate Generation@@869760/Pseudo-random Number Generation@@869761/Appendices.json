{"hands_on_practices": [{"introduction": "The first step in mastering pseudo-random number generation is to understand that not all simple algorithms produce high-quality randomness. Linear Congruential Generators (LCGs) are a classic example, where certain parameter choices can lead to catastrophic failures. This practice delves into one of the most famous flaws: the poor behavior of low-order bits in LCGs with a power-of-two modulus. By working through this theoretical exercise [@problem_id:3333419], you will develop a first-principles understanding of serial correlation and see how a generator's mathematical definition can directly lead to predictable, non-random patterns in its output.", "problem": "Consider a Linear Congruential Generator (LCG) defined by the recurrence $x_{t+1} \\equiv a x_t + c \\pmod{m}$ with modulus $m = 2^w$, multiplier $a$, and increment $c$. It is widely recognized that in modulo arithmetic, congruences propagate down to residues modulo divisors, so the recurrence for the $k$ lowest-order bits (i.e., modulo $2^k$ with $k \\leq w$) is $x_{t+1} \\equiv a x_t + c \\pmod{2^k}$. In this problem, you will analyze the impact of using low-order bits to form pseudo-random variates in stochastic simulation.\n\nLet $w = 3$, $a = 1$, $c = 1$, and $m = 2^w = 8$. Define the pseudo-random variate $U_t$ by mapping the $k = 3$ lowest-order bits of $x_t$ into the unit interval via $U_t = (x_t \\bmod 2^k)/2^k$. Assume an unknown seed $x_0$ that is uniformly distributed on $\\{0,1,\\dots,7\\}$, and consider the Monte Carlo estimator of the mean, $\\hat{\\mu}_n = \\frac{1}{n} \\sum_{t=1}^{n} U_t$.\n\nYour tasks are:\n1. Starting from the definition of the LCG, formally show that with the above parameters the sequence of low-order-bit variates obeys $U_{t+1} \\equiv U_t + 2^{-3} \\pmod{1}$, and deduce that this induces severe serial correlations. Your argument must rely only on the recurrence definition, modular arithmetic, and the mapping from bits to the unit interval.\n2. Using only first principles for the variance of averages of dependent sequences, compute the exact variance $\\operatorname{Var}[\\hat{\\mu}_n]$ when $n = 3$, taking the expectation with respect to the uniform seed $x_0$.\n\nExpress your final answer as an exact fraction. Do not round.", "solution": "The problem is found to be valid as it is scientifically grounded in the theory of pseudo-random number generation, is well-posed with a complete and consistent set of givens, and is expressed in objective, formal language. We may therefore proceed with the solution.\n\nThe problem is divided into two parts. The first is to establish a deterministic recurrence for the pseudo-random variates $U_t$. The second is to compute the variance of a Monte Carlo estimator based on a sequence of these variates.\n\n**Part 1: Recurrence Relation for $U_t$**\n\nThe Linear Congruential Generator (LCG) is defined by the recurrence relation $x_{t+1} \\equiv a x_t + c \\pmod{m}$. The problem provides the specific parameters: multiplier $a=1$, increment $c=1$, and modulus $m=2^w$ with $w=3$, so $m=2^3=8$. The recurrence is thus:\n$$\nx_{t+1} \\equiv x_t + 1 \\pmod{8}\n$$\nThis means that for any integer state $x_t \\in \\{0, 1, \\dots, 7\\}$, the next state $x_{t+1}$ is given by $x_{t+1} = (x_t + 1) \\bmod 8$.\n\nThe pseudo-random variate $U_t$ is defined by mapping the $k$ lowest-order bits of $x_t$ to the unit interval $[0, 1)$. The number of bits is specified as $k=3$. The mapping is $U_t = (x_t \\bmod 2^k)/2^k$. With $k=3$, this becomes:\n$$\nU_t = \\frac{x_t \\bmod 2^3}{2^3} = \\frac{x_t \\bmod 8}{8}\n$$\nSince the states $x_t$ are themselves the result of a modulo $8$ operation, they are always in the set $\\{0, 1, \\dots, 7\\}$. For any such $x_t$, we have $x_t \\bmod 8 = x_t$. Therefore, the relation simplifies to:\n$$\nU_t = \\frac{x_t}{8}\n$$\nThis implies $x_t = 8 U_t$. We can substitute this into the recurrence for $x_t$. The next state is given by $x_{t+1} = (x_t + 1) \\bmod 8$. The corresponding variate $U_{t+1}$ is:\n$$\nU_{t+1} = \\frac{x_{t+1}}{8} = \\frac{(x_t + 1) \\bmod 8}{8}\n$$\nSubstituting $x_t = 8 U_t$:\n$$\nU_{t+1} = \\frac{(8 U_t + 1) \\bmod 8}{8}\n$$\nThe operation $(z \\bmod N)/N$ gives the fractional part of the number $z/N$, which can be written as $\\{z/N\\}$ or $z/N \\pmod 1$. Applying this insight, we get:\n$$\nU_{t+1} = \\frac{8 U_t + 1}{8} \\pmod 1 = \\left(U_t + \\frac{1}{8}\\right) \\pmod 1\n$$\nWith $2^{-3} = 1/8$, we have successfully shown that the sequence of variates obeys the relation:\n$$\nU_{t+1} \\equiv U_t + 2^{-3} \\pmod{1}\n$$\nThis recurrence is fully deterministic. Given any $U_t$, the value of $U_{t+1}$ is uniquely determined. This demonstrates a perfect linear relationship between successive values, which represents an extreme case of serial correlation. A plot of pairs $(U_t, U_{t+1})$ would show points lying on just two parallel lines, $y=x+1/8$ and $y=x-7/8$, which is a catastrophic failure for a sequence intended to be pseudo-random.\n\n**Part 2: Variance Calculation for $\\hat{\\mu}_3$**\n\nThe Monte Carlo estimator for the mean is given by $\\hat{\\mu}_n = \\frac{1}{n} \\sum_{t=1}^{n} U_t$. We are asked to compute its variance for $n=3$, which is $\\operatorname{Var}[\\hat{\\mu}_3]$.\n$$\n\\operatorname{Var}[\\hat{\\mu}_3] = \\operatorname{Var}\\left[\\frac{1}{3}(U_1 + U_2 + U_3)\\right] = \\frac{1}{9} \\operatorname{Var}[U_1 + U_2 + U_3]\n$$\nThe variance of a sum of random variables is given by:\n$$\n\\operatorname{Var}\\left[\\sum_{t=1}^{n} U_t\\right] = \\sum_{i=1}^{n} \\sum_{j=1}^{n} \\operatorname{Cov}[U_i, U_j] = \\sum_{t=1}^{n} \\operatorname{Var}[U_t] + 2 \\sum_{1 \\le i < j \\le n} \\operatorname{Cov}[U_i, U_j]\n$$\nFor $n=3$, this expands to:\n$$\n\\operatorname{Var}[U_1 + U_2 + U_3] = \\operatorname{Var}[U_1] + \\operatorname{Var}[U_2] + \\operatorname{Var}[U_3] + 2(\\operatorname{Cov}[U_1, U_2] + \\operatorname{Cov}[U_1, U_3] + \\operatorname{Cov}[U_2, U_3])\n$$\nThe expectation is taken over the distribution of the seed $x_0$, which is uniform on $\\{0, 1, \\dots, 7\\}$. The sequence of states is $x_t = (x_0 + t) \\bmod 8$, and the variates are $U_t = x_t/8$.\n\nFirst, we establish the properties of the sequence $\\{U_t\\}$. Since $x_0$ is a uniform random variable on $\\{0, 1, \\dots, 7\\}$, and $t$ is a constant, the variable $x_t = (x_0 + t) \\bmod 8$ is also uniformly distributed on $\\{0, 1, \\dots, 7\\}$ for any $t \\ge 1$. Consequently, each $U_t$ follows the same discrete uniform distribution on the set $\\{0, \\frac{1}{8}, \\frac{2}{8}, \\dots, \\frac{7}{8}\\}$, with $P(U_t = i/8) = 1/8$ for $i \\in \\{0, \\dots, 7\\}$. This implies the sequence is stationary, so $\\operatorname{E}[U_t]$ and $\\operatorname{Var}[U_t]$ are constant for all $t$, and the autocovariance $\\operatorname{Cov}[U_t, U_{t+k}]$ depends only on the lag $k$.\n\nWe compute the first and second moments of $U_t$:\n$$\n\\operatorname{E}[U_t] = \\sum_{i=0}^{7} \\frac{i}{8} P\\left(x_t = i\\right) = \\frac{1}{8} \\sum_{i=0}^{7} \\frac{i}{8} = \\frac{1}{64} \\frac{7(8)}{2} = \\frac{28}{64} = \\frac{7}{16}\n$$\n$$\n\\operatorname{E}[U_t^2] = \\sum_{i=0}^{7} \\left(\\frac{i}{8}\\right)^2 P\\left(x_t = i\\right) = \\frac{1}{8} \\sum_{i=0}^{7} \\frac{i^2}{64} = \\frac{1}{512} \\sum_{i=0}^{7} i^2 = \\frac{1}{512} \\frac{7(7+1)(2 \\cdot 7+1)}{6} = \\frac{140}{512} = \\frac{35}{128}\n$$\nThe variance is:\n$$\n\\operatorname{Var}[U_t] = \\operatorname{E}[U_t^2] - (\\operatorname{E}[U_t])^2 = \\frac{35}{128} - \\left(\\frac{7}{16}\\right)^2 = \\frac{35}{128} - \\frac{49}{256} = \\frac{70 - 49}{256} = \\frac{21}{256}\n$$\nSo, $\\operatorname{Var}[U_1] = \\operatorname{Var}[U_2] = \\operatorname{Var}[U_3] = 21/256$.\n\nNext, we compute the autocovariances $\\gamma(k) = \\operatorname{Cov}[U_t, U_{t+k}]$.\n$\\gamma(k) = \\operatorname{E}[U_t U_{t+k}] - \\operatorname{E}[U_t]\\operatorname{E}[U_{t+k}] = \\operatorname{E}[U_t U_{t+k}] - (7/16)^2$.\nWe have $U_{t+k} = ((x_t+k)\\pmod 8)/8$.\n$$\n\\operatorname{E}[U_t U_{t+k}] = \\operatorname{E}\\left[\\frac{x_t}{8} \\frac{(x_t+k)\\pmod 8}{8}\\right] = \\frac{1}{64}\\operatorname{E}[x_t ((x_t+k)\\pmod 8)]\n$$\nThe expectation is over $x_t \\sim U\\{0, \\dots, 7\\}$.\n$$\n\\operatorname{E}[x_t ((x_t+k)\\pmod 8)] = \\frac{1}{8}\\sum_{j=0}^{7} j ((j+k)\\pmod 8)\n$$\nFor lag $k=1$:\n$$\n\\frac{1}{8}\\sum_{j=0}^{7} j ((j+1)\\pmod 8) = \\frac{1}{8}(0 \\cdot 1 + 1 \\cdot 2 + 2 \\cdot 3 + 3 \\cdot 4 + 4 \\cdot 5 + 5 \\cdot 6 + 6 \\cdot 7 + 7 \\cdot 0) = \\frac{112}{8} = 14\n$$\nSo $\\operatorname{E}[U_t U_{t+1}] = 14/64 = 7/32$.\n$\\gamma(1) = \\operatorname{Cov}[U_1, U_2] = \\operatorname{Cov}[U_2, U_3] = \\frac{7}{32} - \\frac{49}{256} = \\frac{56 - 49}{256} = \\frac{7}{256}$.\n\nFor lag $k=2$:\n$$\n\\frac{1}{8}\\sum_{j=0}^{7} j ((j+2)\\pmod 8) = \\frac{1}{8}(0 \\cdot 2 + 1 \\cdot 3 + 2 \\cdot 4 + 3 \\cdot 5 + 4 \\cdot 6 + 5 \\cdot 7 + 6 \\cdot 0 + 7 \\cdot 1) = \\frac{92}{8} = \\frac{23}{2}\n$$\nSo $\\operatorname{E}[U_t U_{t+2}] = (23/2)/64 = 23/128$.\n$\\gamma(2) = \\operatorname{Cov}[U_1, U_3] = \\frac{23}{128} - \\frac{49}{256} = \\frac{46 - 49}{256} = -\\frac{3}{256}$.\n\nNow we assemble the variance of the sum:\n\\begin{align*} \\operatorname{Var}[U_1 + U_2 + U_3] &= 3 \\operatorname{Var}[U_t] + 2(2\\gamma(1) + \\gamma(2)) \\\\ &= 3\\left(\\frac{21}{256}\\right) + 2\\left(2\\left(\\frac{7}{256}\\right) - \\frac{3}{256}\\right) \\\\ &= \\frac{63}{256} + 2\\left(\\frac{14 - 3}{256}\\right) \\\\ &= \\frac{63}{256} + 2\\left(\\frac{11}{256}\\right) = \\frac{63+22}{256} = \\frac{85}{256} \\end{align*}\nFinally, the variance of the estimator $\\hat{\\mu}_3$ is:\n$$\n\\operatorname{Var}[\\hat{\\mu}_3] = \\frac{1}{9} \\operatorname{Var}[U_1 + U_2 + U_3] = \\frac{1}{9} \\cdot \\frac{85}{256} = \\frac{85}{2304}\n$$\nThe numerator is $85 = 5 \\times 17$ and the denominator is $2304 = 9 \\times 256 = 3^2 \\times 2^8$, so the fraction is in its simplest form.", "answer": "$$\n\\boxed{\\frac{85}{2304}}\n$$", "id": "3333419"}, {"introduction": "While theoretical analysis can reveal flaws in specific generator classes, a general-purpose empirical toolkit is essential for validating the output of any PRNG. The chi-square goodness-of-fit test is a cornerstone of such statistical validation, used to check if a set of observed frequencies is consistent with a specified distribution. This hands-on coding task [@problem_id:3529430] will equip you with a practical method to quantify the quality of a random number stream and appreciate the subtleties of statistical testing, such as the crucial role of sample size and binning strategy.", "problem": "Consider a Monte Carlo workflow in computational High-Energy Physics (HEP) where uniform pseudo-random numbers on the interval $[0,1)$ are used as the base random variates to sample kinematic variables. A foundational requirement for scientific validity is that the pseudo-random number generator produces values that are consistent with the uniform distribution on $[0,1)$. To test this, one can partition the interval $[0,1)$ into $k$ equal-width bins and perform a chi-square goodness-of-fit test to assess whether the observed bin counts are consistent with uniformity.\n\nStarting from the fundamental base that, under the null hypothesis of uniformity, each draw falls independently into any bin with probability $p = 1/k$, the vector of bin counts follows a multinomial distribution with parameters $N$ and probabilities $(p_1, p_2, \\dots, p_k)$, where $p_i = p$ for all $i$. The expected count in each bin is $E_i = N p$, and the per-bin variance is $\\mathrm{Var}(O_i) = N p (1 - p)$ for each bin count $O_i$. For large $N$ with fixed $k$ such that expected counts are not small, the Pearson chi-square statistic\n$$\n\\chi^2 = \\sum_{i=1}^{k} \\frac{(O_i - E_i)^2}{E_i}\n$$\nis approximately distributed as the chi-square distribution with $k-1$ degrees of freedom.\n\nYour task is to implement a complete program that:\n- Generates $N$ pseudo-random values on $[0,1)$ using a specified generator type and seed.\n- Bins the values into $k$ equal-width bins on $[0,1)$.\n- Computes the observed counts $O_i$, the expected counts $E_i = N/k$ (identical for all bins), and the per-bin variance $\\mathrm{Var}(O_i) = N \\cdot \\frac{1}{k} \\cdot \\left(1 - \\frac{1}{k}\\right)$ under the multinomial model.\n- Computes the Pearson chi-square statistic $\\chi^2$ and the associated $p$-value using the chi-square distribution with $k-1$ degrees of freedom.\n- Decides whether to reject the null hypothesis of uniformity at significance level $\\alpha$ by comparing the $p$-value to $\\alpha$.\n- Reports whether the asymptotic chi-square approximation is expected to be valid according to the common rule-of-thumb $E_i \\geq 5$.\n\nYour program must implement two generator types:\n- \"uniform\": high-quality pseudo-random numbers from the default portable computer generator (PCG) via a reproducible seed.\n- \"quantized10\": the same high-quality generator followed by a deterministic quantization that maps each value $u$ to $\\lfloor 10 u \\rfloor / 10$, yielding only $10$ discrete levels in $[0,1)$.\n\nFor each test case, your program must output a list in the following format:\n[$\\chi^2$, dof, p-value, reject, E, Var, approx_valid],\nwhere $\\chi^2$ is a float, `dof` is an integer equal to $k-1$, `p-value` is a float, `reject` is a boolean indicating whether p-value < $\\alpha$, $E$ is the expected count per bin (a float equal to $N/k$), $\\mathrm{Var}$ is the per-bin variance (a float equal to $N \\cdot \\frac{1}{k} \\cdot \\left(1 - \\frac{1}{k}\\right)$), and `approx_valid` is a boolean indicating whether $E \\geq 5$.\n\nDesign considerations:\n- The binning must be defined by bin edges at $0, \\frac{1}{k}, \\frac{2}{k}, \\dots, 1$, with values $u$ assigned to bin index $\\lfloor k u \\rfloor$ for $u \\in [0,1)$.\n- The final output must aggregate the results of all test cases into a single line representation of a list containing one sublist per test case.\n\nUse the following test suite to exercise different facets of the problem, including the \"happy path\" case, boundary conditions on expected counts, and edge cases where many bins have small or zero counts, along with a deliberately nonuniform generator:\n\n1. $N = 100000$, $k = 100$, $\\alpha = 0.01$, generator type \"uniform\", seed $12345$.\n2. $N = 5000$, $k = 1000$, $\\alpha = 0.05$, generator type \"uniform\", seed $54321$.\n3. $N = 10000$, $k = 5000$, $\\alpha = 0.05$, generator type \"uniform\", seed $1$.\n4. $N = 100$, $k = 10$, $\\alpha = 0.1$, generator type \"uniform\", seed $2025$.\n5. $N = 10000$, $k = 100$, $\\alpha = 0.001$, generator type \"quantized10\", seed $7$.\n6. $N = 1000$, $k = 1000$, $\\alpha = 0.05$, generator type \"uniform\", seed $314159$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a list as described above and appears in the same order as the test suite (for example, $[[\\dots],[\\dots],\\dots]$). No physical units or angle units apply to this problem.", "solution": "The problem requires the implementation of a statistical validation procedure for pseudo-random number generators (PRNGs), a critical task in computational science, particularly for Monte Carlo simulations in high-energy physics. The core of the task is to perform a Pearson's chi-square ($\\chi^2$) goodness-of-fit test to assess whether a PRNG's output is consistent with a uniform distribution on the interval $[0,1)$. The solution will be designed based on fundamental principles of probability and statistics.\n\nThe logical procedure is as follows:\n$1$. The null hypothesis, $H_0$, posits that the generated numbers are drawn from a continuous uniform distribution on $[0,1)$.\n$2$. To test this, the interval $[0,1)$ is partitioned into $k$ contiguous, equal-width subintervals (bins). Under $H_0$, the probability of a random variate falling into any specific bin is identical for all bins, with a value of $p = 1/k$.\n$3$. A total of $N$ random variates are generated. The counts of variates falling into each bin, denoted by the vector $(O_1, O_2, \\dots, O_k)$, are recorded. This vector of observed counts mathematically follows a multinomial distribution with parameters $N$ (number of trials) and $(p_1, p_2, \\dots, p_k)$ (event probabilities), where $p_i = 1/k$ for all $i \\in \\{1, \\dots, k\\}$.\n\nFrom these foundational principles, we derive the necessary quantities for the test. The expected count for each bin $i$, denoted $E_i$, is given by the mean of the corresponding marginal binomial distribution, which is $E_i = N p_i$. Since all $p_i$ are equal to $1/k$, the expected count is the same for all bins:\n$$\nE = E_i = N \\cdot \\frac{1}{k}\n$$\nThe variance of the count in a single bin $i$, $\\mathrm{Var}(O_i)$, is given by the variance of a binomial variable:\n$$\n\\mathrm{Var}(O_i) = N p_i (1 - p_i) = N \\cdot \\frac{1}{k} \\left(1 - \\frac{1}{k}\\right)\n$$\nThis variance quantifies the expected random fluctuation of bin counts around their mean value.\n\nThe Pearson's chi-square test statistic, $\\chi^2$, is constructed to measure the total discrepancy between the observed counts, $O_i$, and the expected counts under the null hypothesis, $E$. It is defined as the sum of the squared differences, normalized by the expected count:\n$$\n\\chi^2 = \\sum_{i=1}^{k} \\frac{(O_i - E)^2}{E}\n$$\nA large value of this statistic indicates a significant deviation from the expected uniform distribution. A key result in statistics, the Pearson's chi-square theorem, states that for a sufficiently large sample size $N$, this $\\chi^2$ statistic is approximately distributed as a chi-square distribution. The number of degrees of freedom ($\\text{dof}$) for this distribution is $\\nu = k - 1$. The one degree of freedom is lost because of the linear constraint imposed on the observed counts, namely that their sum must equal the total number of samples: $\\sum_{i=1}^{k} O_i = N$.\n\nThe validity of this chi-square approximation is contingent on the expected counts not being too small. A widely used heuristic, specified in the problem, is that the approximation is considered reliable if the expected count in every bin is at least $5$, i.e., $E \\ge 5$.\n\nThe hypothesis test is then conducted by calculating the $p$-value. The $p$-value represents the probability of observing a $\\chi^2$ statistic at least as large as the one computed from the data, assuming the null hypothesis $H_0$ is true. For this right-tailed test, it is given by:\n$$\np\\text{-value} = P(\\chi^2_{\\nu} \\ge \\chi^2_{\\text{observed}})\n$$\nwhere $\\chi^2_{\\nu}$ is a random variable following the chi-square distribution with $\\nu = k-1$ degrees of freedom. This probability is computed using the survival function ($1 - \\text{CDF}$) of the chi-square distribution.\n\nFinally, a decision is made by comparing the $p$-value to a pre-determined significance level, $\\alpha$. If the $p$-value is less than $\\alpha$ ($p<\\alpha$), it implies that the observed data is very unlikely to have occurred by chance if the generator were truly uniform. Consequently, we reject the null hypothesis and conclude that there is statistically significant evidence that the PRNG is not uniform. If $p \\ge \\alpha$, we fail to reject the null hypothesis.\n\nThe implementation will proceed as follows:\n- For each test case defined by parameters $(N, k, \\alpha, \\text{generator\\_type}, \\text{seed})$, a reproducible `numpy` PRNG (`PCG64`) is initialized with the given seed.\n- $N$ random numbers are generated. For the `\"uniform\"` type, the generator's output is used directly. For the `\"quantized10\"` type, the output values $u$ are transformed via the function $u \\mapsto \\lfloor 10u \\rfloor / 10$, which introduces a clear non-uniformity by restricting values to $10$ discrete levels.\n- The `numpy.histogram` function is used to efficiently bin the generated samples into $k$ equal-width bins on $[0,1)$ and obtain the observed counts $O_i$.\n- The derived quantities—$E$, $\\mathrm{Var}(O_i)$, $\\chi^2$, and the degrees of freedom $\\nu$—are calculated according to their definitions.\n- The `scipy.stats.chi2.sf` function is used to compute the $p$-value from the $\\chi^2$ statistic and degrees of freedom.\n- The booleans for rejecting $H_0$ and for the validity of the chi-square approximation are determined.\n- The results for each test case are collected and formatted into the specified list-of-lists structure for the final output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, k, alpha, generator_type, seed)\n        (100000, 100, 0.01, \"uniform\", 12345),\n        (5000, 1000, 0.05, \"uniform\", 54321),\n        (10000, 5000, 0.05, \"uniform\", 1),\n        (100, 10, 0.1, \"uniform\", 2025),\n        (10000, 100, 0.001, \"quantized10\", 7),\n        (1000, 1000, 0.05, \"uniform\", 314159),\n    ]\n\n    results = []\n    for params in test_cases:\n        N, k, alpha, gen_type, seed = params\n        result = perform_chi_square_test(N, k, alpha, gen_type, seed)\n        results.append(result)\n\n    # Format the final output string as a list of lists, without extra spaces.\n    # e.g., [[val1,val2,...],[val1,val2,...]]\n    sublist_strs = []\n    for sublist in results:\n        # str(item) for bool produces 'True'/'False' with capital letters, which is standard for Python.\n        item_strs = [str(item) for item in sublist]\n        sublist_strs.append(f\"[{','.join(item_strs)}]\")\n    \n    final_output_str = f\"[{','.join(sublist_strs)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output_str)\n\ndef perform_chi_square_test(N, k, alpha, generator_type, seed):\n    \"\"\"\n    Performs a chi-square goodness-of-fit test for a single test case.\n\n    Args:\n        N (int): Number of pseudo-random values to generate.\n        k (int): Number of bins to partition the [0,1) interval into.\n        alpha (float): Significance level for the hypothesis test.\n        generator_type (str): Type of generator (\"uniform\" or \"quantized10\").\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        list: A list containing the test results in the specified format:\n              [chi^2, dof, p-value, reject, E, Var, approx_valid]\n    \"\"\"\n    # 1. Generate pseudo-random numbers\n    rng = np.random.default_rng(seed)\n    if generator_type == \"uniform\":\n        samples = rng.random(size=N)\n    elif generator_type == \"quantized10\":\n        u_samples = rng.random(size=N)\n        samples = np.floor(10 * u_samples) / 10\n    else:\n        # This case should not be reached with the given problem statement.\n        raise ValueError(f\"Unknown generator type: {generator_type}\")\n\n    # 2. Bin the values to get observed counts\n    # np.histogram bins are [min, max] with bins=k and range=(0,1) resulting in\n    # bins of width 1/k. The last bin is inclusive on the right edge.\n    observed_counts, _ = np.histogram(samples, bins=k, range=(0, 1))\n\n    # 3. Compute expected counts and degrees of freedom\n    expected_count = N / k\n    dof = k - 1\n    \n    # 4. Compute Pearson's chi-square statistic\n    # The case expected_count=0 is only possible if N=0, which is not the case here.\n    # The sum is over all k bins.\n    chi2_stat = np.sum((observed_counts - expected_count)**2 / expected_count)\n\n    # 5. Calculate p-value\n    # The p-value is the probability of observing a chi-square value as extreme\n    # or more extreme than the one calculated, given the null hypothesis is true.\n    # This is given by the survival function (1 - CDF).\n    p_value = chi2.sf(chi2_stat, dof)\n\n    # 6. Decide whether to reject the null hypothesis\n    reject_null = p_value < alpha\n\n    # 7. Report if the asymptotic chi-square approximation is valid\n    # Based on the common rule-of-thumb E_i >= 5.\n    approx_valid = expected_count >= 5\n\n    # 8. Compute the per-bin variance under the multinomial model\n    variance = N * (1 / k) * (1 - 1 / k)\n\n    return [\n        float(chi2_stat),\n        int(dof),\n        float(p_value),\n        bool(reject_null),\n        float(expected_count),\n        float(variance),\n        bool(approx_valid),\n    ]\n\n# Execute the main function when the script is run.\nsolve()\n```", "id": "3529430"}, {"introduction": "Understanding the mathematical structure of a PRNG is not only for identifying its weaknesses but also for harnessing its properties for advanced applications. In modern computational science, running simulations in parallel requires the ability to generate multiple independent, non-overlapping random number streams. This exercise explores how the linear recurrence underlying many generators can be represented by a state-transition matrix. By implementing a \"skip-ahead\" function using matrix exponentiation [@problem_id:3333414], you will learn the powerful technique of partitioning a generator's sequence, a fundamental mechanism that enables reproducible and statistically robust parallel Monte Carlo simulations.", "problem": "Consider linear pseudo-random number generators defined by linear recurrences on a finite algebraic structure and their state-transition representation as linear maps. Use the following foundational bases: (i) the definition of a linear recurrence over the ring of integers modulo $m$, denoted $\\mathbb{Z}/m\\mathbb{Z}$, and over the finite field with two elements, denoted $\\mathbb{F}_2$, (ii) the interpretation of generator state evolution as repeated application of a linear transformation represented by a matrix, and (iii) the fact that composing a linear map $k$ times corresponds to taking the $k$-th power of its matrix representation. From these bases, derive a skip-ahead method and design a substream construction that ensures nonoverlapping fixed-length segments when the underlying period is sufficiently large.\n\nYou must solve the following tasks.\n\n1. Define a linear congruential generator (LCG) over $\\mathbb{Z}/m\\mathbb{Z}$ with recurrence $x_{n+1} \\equiv a x_n + c \\pmod{m}$, where $x_n \\in \\mathbb{Z}/m\\mathbb{Z}$. Show how to embed the affine map into a linear map by augmenting the state with a constant component, and derive the corresponding state-transition matrix in $\\mathbb{Z}/m\\mathbb{Z}$ whose powers implement skip-ahead by $k$ steps.\n\n2. Define a linear feedback shift register (LFSR) over $\\mathbb{F}_2$ of degree $d$ based on a feedback polynomial and express its update as a linear transformation of the $d$-dimensional state vector in $\\mathbb{F}_2^d$. Derive the companion-like state-transition matrix whose powers implement skip-ahead by $k$ steps.\n\n3. Implement matrix multiplication and fast exponentiation by squaring for matrices over $\\mathbb{Z}/m\\mathbb{Z}$ and over $\\mathbb{F}_2$ so that for any square matrix $T$ and nonnegative integer $k$, you can compute $T^k$ in the respective algebra with all arithmetic performed modulo $m$ (for $\\mathbb{Z}/m\\mathbb{Z}$) or modulo $2$ (for $\\mathbb{F}_2$).\n\n4. Implement a method to partition a generator’s stream into nonoverlapping substreams of fixed length $L$ by selecting starting states $\\{s_0, s_L, s_{2L}, \\dots\\}$ and generating $L$ consecutive states from each start. Express the selection of the $i$-th starting state in terms of the $L$-step transition, and specify the condition under which these substreams are nonoverlapping.\n\nYour program must, for the specified test suite below, verify correctness of skip-ahead versus naive iteration and verify nonoverlap of substreams by checking set intersections of their states.\n\nTest Suite:\n\n- LCG over $\\mathbb{Z}/m\\mathbb{Z}$:\n  - Modulus $m = 10007$, multiplier $a = 173$, increment $c = 317$, initial seed $x_0 = 42$.\n  - Skip-ahead verification: $k = 250$.\n  - Substreams: substream length $L = 50$, number of substreams $N = 3$.\n\n- LFSR over $\\mathbb{F}_2$:\n  - Degree $d = 5$ with feedback polynomial $p(x) = x^5 + x^2 + 1$ interpreted as the recurrence $x_{n+5} = x_{n+2} + x_n$ in $\\mathbb{F}_2$.\n  - Initial state vector $s_0 = [1, 0, 0, 0, 0]$ (as elements of $\\mathbb{F}_2$).\n  - Skip-ahead verification: $k = 13$.\n  - Substreams: substream length $L = 7$, number of substreams $N = 4$.\n  - Boundary verifications:\n    - Identity property for skip-ahead: $k = 0$ must map $s_0$ to itself.\n    - Overlap detection when the substream length equals the period: let $P$ denote the period of the LFSR starting from $s_0$; take $L = P$ and $N = 2$ and check whether the constructed substreams overlap.\n\nFor each of the following checks, produce a boolean result:\n- LCG skip-ahead equality for $k = 250$ comparing matrix-based skip-ahead to naive iteration.\n- LCG substream nonoverlap for $L = 50$, $N = 3$.\n- LFSR skip-ahead equality for $k = 13$ comparing matrix-based skip-ahead to naive iteration.\n- LFSR substream nonoverlap for $L = 7$, $N = 4$.\n- LFSR identity property for $k = 0$.\n- LFSR substream nonoverlap when $L = P$ and $N = 2$ (this should detect overlap as applicable).\n\nFinal Output Format:\nYour program should produce a single line of output containing the six boolean results, in the order listed above, as a comma-separated list enclosed in square brackets (e.g., \"[True,False,True,True,True,False]\"). No additional text should be printed.\n\nThe program must be self-contained and require no input. It must be runnable in any modern language, but your final answer must be provided as Python code conforming to the specified execution environment constraints.", "solution": "We start from the definition of linear recurrences and their representation as linear maps. A linear recurrence over the ring of integers modulo $m$, $\\mathbb{Z}/m\\mathbb{Z}$, has the form $x_{n+1} \\equiv a x_n + c \\pmod{m}$, where $a, c \\in \\mathbb{Z}/m\\mathbb{Z}$. This map is affine, not linear, because of the constant term $c$. A standard method to represent affine maps as linear maps is to augment the state with a constant component. Define the augmented state vector $y_n \\in (\\mathbb{Z}/m\\mathbb{Z})^2$ by $y_n = \\begin{bmatrix} x_n \\\\ 1 \\end{bmatrix}$. Then the update can be written as\n$$\ny_{n+1} = \\begin{bmatrix} a & c \\\\ 0 & 1 \\end{bmatrix} y_n \\pmod{m}.\n$$\nDenote the transition matrix by $T = \\begin{bmatrix} a & c \\\\ 0 & 1 \\end{bmatrix}$. Applying the recurrence $k$ times corresponds to composing the transformation $k$ times, which yields\n$$\ny_{n+k} = T^k y_n \\pmod{m},\n$$\nand the first component of $y_{n+k}$ is $x_{n+k}$, the desired skip-ahead value.\n\nFor a linear feedback shift register (LFSR) over the finite field $\\mathbb{F}_2$, consider a degree $d$ recurrence induced by a feedback polynomial $p(x) = x^d + \\sum_{i=0}^{d-1} c_i x^i$ with $c_i \\in \\{0, 1\\}$. The recurrence relation is $x_{n+d} = \\sum_{i=0}^{d-1} c_i x_{n+i}$ in $\\mathbb{F}_2$. Define the state vector $s_n = \\begin{bmatrix} x_n & x_{n+1} & \\cdots & x_{n+d-1} \\end{bmatrix}^\\top \\in \\mathbb{F}_2^d$. The update $s_{n+1}$ can be expressed as\n$$\ns_{n+1} = A s_n \\pmod{2},\n$$\nwhere $A$ is the companion-like matrix\n$$\nA = \\begin{bmatrix}\n0 & 1 & 0 & \\cdots & 0 \\\\\n0 & 0 & 1 & \\cdots & 0 \\\\\n\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n0 & 0 & 0 & \\cdots & 1 \\\\\nc_0 & c_1 & c_2 & \\cdots & c_{d-1}\n\\end{bmatrix}.\n$$\nFor the concrete case $p(x) = x^5 + x^2 + 1$, we have $d = 5$ and coefficients $c_0 = 1$, $c_1 = 0$, $c_2 = 1$, $c_3 = 0$, $c_4 = 0$. Thus,\n$$\nA = \\begin{bmatrix}\n0 & 1 & 0 & 0 & 0 \\\\\n0 & 0 & 1 & 0 & 0 \\\\\n0 & 0 & 0 & 1 & 0 \\\\\n0 & 0 & 0 & 0 & 1 \\\\\n1 & 0 & 1 & 0 & 0\n\\end{bmatrix}.\n$$\nAs before, the skip-ahead by $k$ steps is implemented by $A^k$, i.e., $s_{n+k} = A^k s_n \\pmod{2}$.\n\nTo compute $T^k$ efficiently for any square matrix $T$ over $\\mathbb{Z}/m\\mathbb{Z}$ or $\\mathbb{F}_2$, we use exponentiation by squaring, which follows from the identity $T^{2r} = (T^r)^2$ and $T^{2r+1} = (T^r)^2 T$. This method reduces the number of multiplications from $O(k)$ to $O(\\log k)$. At each multiplication, we perform arithmetic modulo $m$ (or modulo $2$ for $\\mathbb{F}_2$), ensuring that the operations remain within the appropriate algebraic structure.\n\nFor substream construction, let $T$ be the state-transition matrix in the relevant structure, and $s_0$ the initial state vector. Define the $L$-step transition $U = T^L$. Then the starting state of the $i$-th substream is $s^{(i)}_0 = U^i s_0$. The $j$-th state within the $i$-th substream is $s^{(i)}_j = T^j s^{(i)}_0$. These substreams are nonoverlapping if the sets $\\{ s^{(i)}_j : 0 \\le j < L \\}$ across different $i$ are pairwise disjoint, which holds whenever the generator’s period $P$ satisfies $N L \\le P$ and we choose contiguous segments partitioned by stride $L$.\n\nVerification methodology in the program:\n- For the LCG over $\\mathbb{Z}/m\\mathbb{Z}$ with $m = 10007$, $a = 173$, $c = 317$, $x_0 = 42$, we compute $x_{250}$ in two ways: (i) naive iteration by applying $x_{n+1} \\equiv a x_n + c \\pmod{m}$ repeatedly, and (ii) matrix skip-ahead via the augmented state transition and $T^{250}$. Equality yields a boolean result.\n- For the same LCG, we construct $N = 3$ substreams of length $L = 50$ via stride $L$ and check that the sets of states in each substream do not intersect.\n- For the LFSR over $\\mathbb{F}_2$ of degree $d = 5$ with $p(x) = x^5 + x^2 + 1$, starting from $s_0 = [1, 0, 0, 0, 0]$, we compute $s_{13}$ by naive iteration and by matrix skip-ahead $A^{13}$ and check equality.\n- For the same LFSR, we construct $N = 4$ substreams of length $L = 7$ and verify nonoverlap by set intersection of states.\n- We verify the identity property $A^0 = I$ by checking that applying $A^0$ to $s_0$ returns $s_0$.\n- We determine the period $P$ by iterating until the initial state $s_0$ is revisited and then test the case $L = P$, $N = 2$ for nonoverlap, which should indicate overlap due to the cyclic nature.\n\nThe program outputs a single line listing six booleans, in order: LCG skip-ahead equality, LCG nonoverlap, LFSR skip-ahead equality, LFSR nonoverlap, LFSR identity at $k = 0$, LFSR nonoverlap when $L = P$, $N = 2$. This format satisfies the requirement for quantifiable answers and a clear, testable output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef mat_mul_mod(A, B, mod):\n    # Multiply two matrices A (n x m) and B (m x p) modulo mod\n    n = len(A)\n    m = len(A[0])\n    assert m == len(B), \"Inner dimensions must match\"\n    p = len(B[0])\n    C = [[0] * p for _ in range(n)]\n    for i in range(n):\n        for k in range(m):\n            aik = A[i][k]\n            if aik == 0:\n                continue\n            for j in range(p):\n                C[i][j] = (C[i][j] + aik * B[k][j]) % mod\n    return C\n\ndef mat_vec_mul_mod(A, v, mod):\n    # Multiply matrix A (n x m) with vector v (m), modulo mod\n    n = len(A)\n    m = len(A[0])\n    assert m == len(v), \"Dimension mismatch in mat-vec multiply\"\n    res = [0] * n\n    for i in range(n):\n        s = 0\n        row = A[i]\n        for j in range(m):\n            s += row[j] * v[j]\n        res[i] = s % mod\n    return res\n\ndef mat_pow_mod(A, k, mod):\n    # Exponentiation by squaring: compute A^k modulo mod\n    n = len(A)\n    assert n == len(A[0]), \"Matrix must be square\"\n    # Identity matrix\n    I = [[0] * n for _ in range(n)]\n    for i in range(n):\n        I[i][i] = 1 % mod\n    if k == 0:\n        return I\n    # Copy A\n    base = [row[:] for row in A]\n    result = I\n    exp = k\n    while exp > 0:\n        if exp & 1:\n            result = mat_mul_mod(result, base, mod)\n        base = mat_mul_mod(base, base, mod)\n        exp >>= 1\n    return result\n\ndef lcg_step(x, a, c, m):\n    return (a * x + c) % m\n\ndef generate_lcg_substreams(a, c, m, x0, L, N):\n    # Using augmented matrix T over Z/mZ\n    T = [[a % m, c % m],\n         [0,      1 % m]]\n    s0 = [x0 % m, 1]\n    substreams = []\n    for i in range(N):\n        # compute start state for substream i: T^(i*L) * s0\n        Ti = mat_pow_mod(T, i * L, m)\n        si = mat_vec_mul_mod(Ti, s0, m)\n        # Generate L states by repeatedly applying T\n        states = []\n        curr = si[:]\n        for _ in range(L):\n            states.append(curr[0])  # record x component\n            curr = mat_vec_mul_mod(T, curr, m)\n        substreams.append(states)\n    return substreams\n\ndef lfsr_period(A, s0):\n    # Compute the period of LFSR starting from s0 by detecting when state repeats\n    mod = 2\n    seen = 0\n    s = s0[:]\n    while True:\n        s = mat_vec_mul_mod(A, s, mod)\n        seen += 1\n        if s == s0:\n            return seen\n\ndef generate_lfsr_substreams(A, s0, L, N):\n    mod = 2\n    T = A\n    substreams = []\n    # Precompute U = T^L\n    U = mat_pow_mod(T, L, mod)\n    # Precompute starts\n    # s^(i)_0 = U^i s0\n    Ui = [[1 if r == c else 0 for c in range(len(T))] for r in range(len(T))]\n    # Alternatively compute U^i by exponentiation each time for simplicity given small sizes\n    for i in range(N):\n        Ti = mat_pow_mod(U, i, mod)\n        si = mat_vec_mul_mod(Ti, s0, mod)\n        # Generate L states\n        states = []\n        curr = si[:]\n        for _ in range(L):\n            states.append(tuple(curr))  # record full state vector\n            curr = mat_vec_mul_mod(T, curr, mod)\n        substreams.append(states)\n    return substreams\n\ndef check_nonoverlap(substreams):\n    # Check pairwise that sets of states do not intersect\n    sets = [set(ss) for ss in substreams]\n    for i in range(len(sets)):\n        for j in range(i + 1, len(sets)):\n            if sets[i].intersection(sets[j]):\n                return False\n    return True\n\ndef solve():\n    results = []\n\n    # Test 1: LCG skip-ahead equality\n    m = 10007\n    a = 173\n    c = 317\n    x0 = 42\n    k = 250\n    # Build augmented transition matrix\n    T_lcg = [[a % m, c % m],\n             [0,      1]]\n    s0_lcg = [x0 % m, 1]\n    Tk = mat_pow_mod(T_lcg, k, m)\n    s_skip = mat_vec_mul_mod(Tk, s0_lcg, m)\n    x_skip_matrix = s_skip[0]\n    # Naive iteration\n    x_naive = x0 % m\n    for _ in range(k):\n        x_naive = lcg_step(x_naive, a, c, m)\n    b1 = (x_skip_matrix == x_naive)\n    results.append(b1)\n\n    # Test 2: LCG nonoverlap substreams\n    L = 50\n    N = 3\n    lcg_substreams = generate_lcg_substreams(a, c, m, x0, L, N)\n    b2 = check_nonoverlap(lcg_substreams)\n    results.append(b2)\n\n    # Test 3: LFSR skip-ahead equality\n    d = 5\n    # Companion-like matrix for p(x) = x^5 + x^2 + 1\n    A = [\n        [0, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 0, 1],\n        [1, 0, 1, 0, 0],\n    ]\n    s0 = [1, 0, 0, 0, 0]\n    k_lfsr = 13\n    Ak = mat_pow_mod(A, k_lfsr, 2)\n    s_skip_lfsr = mat_vec_mul_mod(Ak, s0, 2)\n    # Naive iteration\n    s_naive = s0[:]\n    for _ in range(k_lfsr):\n        s_naive = mat_vec_mul_mod(A, s_naive, 2)\n    b3 = (s_skip_lfsr == s_naive)\n    results.append(b3)\n\n    # Test 4: LFSR nonoverlap substreams\n    L_lfsr = 7\n    N_lfsr = 4\n    lfsr_substreams = generate_lfsr_substreams(A, s0, L_lfsr, N_lfsr)\n    b4 = check_nonoverlap(lfsr_substreams)\n    results.append(b4)\n\n    # Test 5: LFSR identity property for k = 0\n    A0 = mat_pow_mod(A, 0, 2)\n    s_id = mat_vec_mul_mod(A0, s0, 2)\n    b5 = (s_id == s0)\n    results.append(b5)\n\n    # Test 6: LFSR overlap when L equals the period and N = 2\n    P = lfsr_period(A, s0)\n    L_eq_P = P\n    N_two = 2\n    lfsr_substreams_period = generate_lfsr_substreams(A, s0, L_eq_P, N_two)\n    # Expect overlap due to cycling\n    b6 = check_nonoverlap(lfsr_substreams_period)\n    results.append(b6)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3333414"}]}