{"hands_on_practices": [{"introduction": "At the heart of any Gillespie algorithm implementation lies the propensity function, which translates the system's microscopic state into the instantaneous probability of each reaction firing. This exercise [@problem_id:3353359] challenges you to implement the general combinatorial formula for mass-action propensities, moving beyond simplistic cases to a robust function that correctly handles reactions of any order. Developing this core component is the essential first step toward building a versatile and accurate stochastic simulation engine.", "problem": "Consider a well-mixed, continuous-time Markov chain model of a chemical reaction network under stochastic mass-action kinetics, as used by the Stochastic Simulation Algorithm (SSA), also known as the Gillespie algorithm. Let there be $d$ species and $R$ reaction channels. A system state is the vector $X \\in \\mathbb{N}^d$, where $X_i$ is the copy number of species $i$. Each reaction channel $r$ is characterized by a nonnegative rate constant $c_r$ and a reactant stoichiometric vector $\\nu_r^- \\in \\mathbb{N}^d$ indicating the number of molecules of each species consumed when the reaction fires. The reaction order is the sum $\\sum_{i=1}^d \\nu_{r,i}^-$. Under stochastic mass-action kinetics, the instantaneous propensity $a_r(X)$ is the product of the intrinsic rate constant $c_r$ and the number of distinct unordered selections of reactant molecules that can be drawn from the current state $X$ consistent with the required multiplicities given by $\\nu_r^-$. If $X_i  \\nu_{r,i}^-$ for any species $i$, then $a_r(X)$ must be zero.\n\nTask. Design and implement a robust, general algorithm that, given an arbitrary nonnegative integer state vector $X \\in \\mathbb{N}^d$ and a list of reactions $\\{(c_r,\\nu_r^-)\\}_{r=1}^R$ with reaction orders ranging from $0$ to $3$ inclusive, returns all propensities $\\{a_r(X)\\}_{r=1}^R$ computed according to the above principle. Your algorithm must not special-case individual reaction patterns; it must correctly compute the number of reactant selections for all reaction orders $0$ through $3$ by reasoning from the counting principle described above. The algorithm must remain correct in edge cases such as zero-order reactions, insufficient copy numbers, and repeated identical reactants.\n\nImplementation constraints. The program must be self-contained and must not read any input. It must compute propensities for the following test suite. For each test case, species are indexed by position in the vectors. Each reaction is specified as a pair $(c_r,\\nu_r^-)$ where $\\nu_r^-$ is listed in the species order.\n\nTest case A:\n- Species count $d = 4$, state $X = [6,5,3,0]$.\n- Reactions (rate constant, reactant stoichiometric vector):\n  - $(0.75,[0,0,0,0])$\n  - $(0.1,[1,0,0,0])$\n  - $(0.02,[1,1,0,0])$\n  - $(0.03,[0,2,0,0])$\n  - $(0.001,[1,1,1,0])$\n  - $(0.004,[2,1,0,0])$\n  - $(0.005,[3,0,0,0])$\n  - $(0.07,[0,0,2,0])$\n  - $(1.0,[0,0,0,1])$\n  - $(0.11,[0,1,1,0])$\n\nTest case B:\n- Species count $d = 3$, state $X = [2,1,0]$.\n- Reactions:\n  - $(0.5,[3,0,0])$\n  - $(0.5,[2,1,0])$\n  - $(0.5,[1,1,1])$\n  - $(0.5,[0,2,0])$\n  - $(2.0,[0,0,0])$\n  - $(1.25,[1,0,0])$\n  - $(0.2,[1,1,0])$\n\nTest case C:\n- Species count $d = 2$, state $X = [50,40]$.\n- Reactions:\n  - $(10^{-3},[2,0])$\n  - $(10^{-6},[3,0])$\n  - $(2\\times 10^{-4},[1,1])$\n  - $(10^{-6},[2,1])$\n  - $(10^{-7},[0,3])$\n  - $(3.14,[0,0])$\n  - $(0.01,[1,0])$\n\nOutput specification. Your program must compute, for each test case, the list of all propensities in the order the reactions are specified. It must then produce a single line of output containing the three lists as a comma-separated list enclosed in square brackets, with no whitespace characters. Concretely, the output must be of the form $[[\\cdot],[\\cdot],[\\cdot]]$, where each inner bracket contains the floating-point propensities for that test case in order, written as decimals or in standard scientific notation. The outputs are dimensionless in this task. The final printed line must contain only this aggregate list and nothing else.", "solution": "We begin from the continuous-time Markov chain description of a well-mixed reaction network under stochastic mass-action kinetics. The state is $X \\in \\mathbb{N}^d$, where $X_i$ counts the molecules of species $i$. A reaction channel $r$ is defined by a rate constant $c_r \\ge 0$ and a reactant stoichiometric vector $\\nu_r^- \\in \\mathbb{N}^d$. The reaction order is $\\sum_{i=1}^d \\nu_{r,i}^-$. The fundamental definition of the propensity $a_r(X)$ under stochastic mass-action is that $a_r(X)$ equals the product of $c_r$ and the number of distinct unordered selections of reactant molecules present in $X$ that match the multiplicities required by $\\nu_r^-$. If any required multiplicity exceeds the available copies, then no valid selection exists and the propensity must be zero.\n\nWe derive an explicit counting rule. For a fixed reaction channel $r$, consider species $i$ with $X_i$ indistinguishable molecules available. We must select $\\nu_{r,i}^-$ molecules of species $i$ to participate (if $\\nu_{r,i}^- = 0$, nothing is chosen from this species). Because molecules of the same species are indistinguishable and only multiplicity matters, the number of ways to select $\\nu_{r,i}^-$ molecules from $X_i$ is the binomial coefficient\n$$\n\\binom{X_i}{\\nu_{r,i}^-} =\n\\begin{cases}\n\\dfrac{X_i!}{\\nu_{r,i}^-!\\,(X_i-\\nu_{r,i}^-)!},  \\text{if } 0 \\le \\nu_{r,i}^- \\le X_i,\\\\\n0,  \\text{if } \\nu_{r,i}^-  X_i.\n\\end{cases}\n$$\nThe selections across species are independent choices, so the total number of distinct unordered selections consistent with $\\nu_r^-$ is the product over all species:\n$$\nN_r(X) \\;=\\; \\prod_{i=1}^d \\binom{X_i}{\\nu_{r,i}^-}.\n$$\nTherefore, by the defining principle of stochastic mass-action kinetics, the propensity is\n$$\na_r(X) \\;=\\; c_r \\, N_r(X) \\;=\\; c_r \\prod_{i=1}^d \\binom{X_i}{\\nu_{r,i}^-}.\n$$\nThis single rule simultaneously handles all cases:\n- Zero-order reactions have $\\nu_r^- = 0$ componentwise, so each factor is $\\binom{X_i}{0} = 1$ and $a_r(X) = c_r$.\n- First-order reactions have exactly one component $\\nu_{r,i}^- = 1$, yielding $a_r(X) = c_r X_i$.\n- Second-order heterogeneous reactions have two distinct species with $\\nu_{r,i}^- = 1$, giving $a_r(X) = c_r X_i X_j$; second-order homogeneous reactions have $\\nu_{r,i}^- = 2$ for a single species, giving $a_r(X) = c_r \\binom{X_i}{2} = c_r X_i (X_i - 1)/2$.\n- Third-order reactions cover the patterns $\\nu_{r,i}^- \\in \\{(3,0,\\dots),(2,1,0,\\dots),(1,1,1,0,\\dots)\\}$ across species, and the formula specializes respectively to $a_r(X) = c_r \\binom{X_i}{3}$, $a_r(X) = c_r \\binom{X_i}{2} X_j$, and $a_r(X) = c_r X_i X_j X_k$ when the relevant multiplicities are available. If any required multiplicity exceeds the available $X_i$, the corresponding binomial coefficient is zero and thus $a_r(X) = 0$.\n\nAlgorithm design. The algorithm iterates over reactions $r = 1,\\dots,R$. For each reaction, it computes the product $\\prod_{i=1}^d \\binom{X_i}{\\nu_{r,i}^-}$ using integer-safe binomial coefficients. Specifically, for each species $i$:\n- If $\\nu_{r,i}^- = 0$, the factor is $1$.\n- Else if $\\nu_{r,i}^-  X_i$, the product becomes $0$ and we can short-circuit.\n- Else multiply the running product by the exact integer value $\\binom{X_i}{\\nu_{r,i}^-}$.\nFinally multiply the integer product by the floating-point rate constant $c_r$ to obtain $a_r(X)$. This is numerically robust for reaction orders up to $3$, since all binomial coefficients are modest in size and exactly representable as integers, and the only source of floating-point rounding is the final scaling by $c_r$.\n\nComplexity. For each reaction, the computation costs $O(d)$ time and uses $O(1)$ additional space. For the given test suite, this is trivial computationally.\n\nNow we evaluate the specified test cases.\n\nTest case A: $X = [6,5,3,0]$ and the reactions listed. Applying $a_r(X) = c_r \\prod_i \\binom{X_i}{\\nu_{r,i}^-}$:\n- $(0.75,[0,0,0,0])$: $0.75 \\times 1 = 0.75$.\n- $(0.1,[1,0,0,0])$: $0.1 \\times \\binom{6}{1} = 0.6$.\n- $(0.02,[1,1,0,0])$: $0.02 \\times \\binom{6}{1}\\binom{5}{1} = 0.6$.\n- $(0.03,[0,2,0,0])$: $0.03 \\times \\binom{5}{2} = 0.3$.\n- $(0.001,[1,1,1,0])$: $0.001 \\times \\binom{6}{1}\\binom{5}{1}\\binom{3}{1} = 0.09$.\n- $(0.004,[2,1,0,0])$: $0.004 \\times \\binom{6}{2}\\binom{5}{1} = 0.3$.\n- $(0.005,[3,0,0,0])$: $0.005 \\times \\binom{6}{3} = 0.1$.\n- $(0.07,[0,0,2,0])$: $0.07 \\times \\binom{3}{2} = 0.21$.\n- $(1.0,[0,0,0,1])$: $1.0 \\times \\binom{0}{1} = 0$.\n- $(0.11,[0,1,1,0])$: $0.11 \\times \\binom{5}{1}\\binom{3}{1} = 1.65$.\nTherefore, the propensity list is $[0.75,0.6,0.6,0.3,0.09,0.3,0.1,0.21,0.0,1.65]$.\n\nTest case B: $X = [2,1,0]$:\n- $(0.5,[3,0,0])$: $0.5 \\times \\binom{2}{3} = 0$.\n- $(0.5,[2,1,0])$: $0.5 \\times \\binom{2}{2}\\binom{1}{1} = 0.5$.\n- $(0.5,[1,1,1])$: $0.5 \\times \\binom{0}{1} = 0$.\n- $(0.5,[0,2,0])$: $0.5 \\times \\binom{1}{2} = 0$.\n- $(2.0,[0,0,0])$: $2.0 \\times 1 = 2.0$.\n- $(1.25,[1,0,0])$: $1.25 \\times \\binom{2}{1} = 2.5$.\n- $(0.2,[1,1,0])$: $0.2 \\times \\binom{2}{1}\\binom{1}{1} = 0.4$.\nTherefore, the propensity list is $[0.0,0.5,0.0,0.0,2.0,2.5,0.4]$.\n\nTest case C: $X = [50,40]$:\n- $(10^{-3},[2,0])$: $10^{-3} \\times \\binom{50}{2} = 1.225$.\n- $(10^{-6},[3,0])$: $10^{-6} \\times \\binom{50}{3} = 0.0196$.\n- $(2\\times 10^{-4},[1,1])$: $(2\\times 10^{-4}) \\times \\binom{50}{1}\\binom{40}{1} = 0.4$.\n- $(10^{-6},[2,1])$: $10^{-6} \\times \\binom{50}{2}\\binom{40}{1} = 0.049$.\n- $(10^{-7},[0,3])$: $10^{-7} \\times \\binom{40}{3} = 0.000988$.\n- $(3.14,[0,0])$: $3.14 \\times 1 = 3.14$.\n- $(0.01,[1,0])$: $0.01 \\times \\binom{50}{1} = 0.5$.\nTherefore, the propensity list is $[1.225,0.0196,0.4,0.049,0.000988,3.14,0.5]$.\n\nThe program below implements the general algorithm described, applies it to the test suite, and prints the three lists in a single-line, whitespace-free format as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport math\nimport numpy as np  # numpy is available; not strictly needed but permitted.\n\ndef comb_nonneg(n: int, k: int) - int:\n    \"\"\"Return C(n,k) for integers n,k with the convention C(n,k)=0 if kn or k0.\"\"\"\n    if k  0:\n        return 0\n    if k  n:\n        return 0\n    # For k==0 or k==n, math.comb handles correctly as 1\n    return math.comb(n, k)\n\ndef propensity_for_reaction(state, reactant_stoich, rate_constant) - float:\n    \"\"\"\n    Compute propensity a = c * product_i C(state[i], reactant_stoich[i]).\n    If any required multiplicity exceeds availability, propensity is zero.\n    \"\"\"\n    product = 1\n    for xi, si in zip(state, reactant_stoich):\n        c = comb_nonneg(int(xi), int(si))\n        if c == 0:\n            return 0.0\n        product *= c\n    return float(rate_constant) * float(product)\n\ndef compute_propensities(state, reactions):\n    \"\"\"\n    state: list[int] of species counts\n    reactions: list of tuples (rate_constant: float, reactant_stoich: list[int])\n    returns: list[float] propensities\n    \"\"\"\n    props = []\n    for rate, stoich in reactions:\n        props.append(propensity_for_reaction(state, stoich, rate))\n    return props\n\ndef format_float(x: float) - str:\n    \"\"\"\n    Format a float into a concise string without unnecessary whitespace,\n    using up to 12 significant digits, avoiding long binary tails.\n    \"\"\"\n    # Use general format; this trims trailing zeros and uses scientific notation when appropriate.\n    s = format(x, \".12g\")\n    return s\n\ndef format_list_no_spaces(lst):\n    \"\"\"Format a list of floats as [v1,v2,...] with no spaces.\"\"\"\n    return \"[\" + \",\".join(format_float(x) for x in lst) + \"]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Test case A\n    state_A = [6, 5, 3, 0]\n    reactions_A = [\n        (0.75, [0, 0, 0, 0]),\n        (0.1, [1, 0, 0, 0]),\n        (0.02, [1, 1, 0, 0]),\n        (0.03, [0, 2, 0, 0]),\n        (0.001, [1, 1, 1, 0]),\n        (0.004, [2, 1, 0, 0]),\n        (0.005, [3, 0, 0, 0]),\n        (0.07, [0, 0, 2, 0]),\n        (1.0, [0, 0, 0, 1]),\n        (0.11, [0, 1, 1, 0]),\n    ]\n\n    # Test case B\n    state_B = [2, 1, 0]\n    reactions_B = [\n        (0.5, [3, 0, 0]),\n        (0.5, [2, 1, 0]),\n        (0.5, [1, 1, 1]),\n        (0.5, [0, 2, 0]),\n        (2.0, [0, 0, 0]),\n        (1.25, [1, 0, 0]),\n        (0.2, [1, 1, 0]),\n    ]\n\n    # Test case C\n    state_C = [50, 40]\n    reactions_C = [\n        (1e-3, [2, 0]),\n        (1e-6, [3, 0]),\n        (2e-4, [1, 1]),\n        (1e-6, [2, 1]),\n        (1e-7, [0, 3]),\n        (3.14, [0, 0]),\n        (0.01, [1, 0]),\n    ]\n\n    test_cases = [\n        (state_A, reactions_A),\n        (state_B, reactions_B),\n        (state_C, reactions_C),\n    ]\n\n    results = []\n    for state, reactions in test_cases:\n        props = compute_propensities(state, reactions)\n        results.append(props)\n\n    # Prepare nested list formatting without spaces\n    inner = \",\".join(format_list_no_spaces(r) for r in results)\n    print(f\"[{inner}]\")\n\nsolve()\n```", "id": "3353359"}, {"introduction": "While the Gillespie algorithm is exact, its step-by-step nature can be slow for large systems, making approximate methods like `tau-leaping` indispensable. This problem [@problem_id:3353308] guides you through the derivation of a sophisticated `tau-leap` variant—the binomial leap—which elegantly solves the common issue of reactant populations becoming negative in simulations. By reasoning from the probabilistic fate of individual molecules over a time step $\\tau$, you will see how to build faster algorithms without sacrificing essential physical realism.", "problem": "Consider a well-mixed isothermal reaction system under the Chemical Master Equation framework in which the Stochastic Simulation Algorithm (SSA) applies. Reactions are partitioned into a subset with low molecular counts that risk violating nonnegativity under naive tau-leaping, and a complementary subset with sufficiently large counts. The low-count subset is treated with a binomial tau-leap designed to preserve nonnegativity by ensuring that reaction firings cannot exceed the available reactant molecules. Focus on the unimolecular decay reaction $A \\xrightarrow{c} \\emptyset$, where $c$ is a positive rate constant with dimension of inverse time, and let $X_{A}(t)$ denote the number of molecules of species $A$ at the start of a leap of duration $\\tau>0$. Starting from the SSA’s foundational assumptions about exponential waiting times and propensities in the Chemical Master Equation, derive a binomial tau-leap for the low-count subset that enforces nonnegativity. In particular, derive the parameters $(n,p)$ of the binomial distribution used to sample the number of firings of $A \\xrightarrow{c} \\emptyset$ during the leap of duration $\\tau$ in terms of $c$, $\\tau$, and $X_{A}(t)$. Provide your final answer as a row matrix containing $n$ and $p$ in symbolic form. No numerical approximation is required.", "solution": "The derivation begins with the fundamental assumptions of the Stochastic Simulation Algorithm (SSA), which models the time evolution of a chemically reacting system as a continuous-time, discrete-state Markov jump process. For a unimolecular reaction $A \\xrightarrow{c} \\emptyset$, the propensity function, which gives the probability per unit time that the reaction will occur, is $a(X_A) = c X_A$, where $X_A$ is the number of molecules of species $A$ and $c$ is the stochastic rate constant.\n\nThe binomial tau-leap method seeks to approximate the number of reaction firings over a finite time interval $\\tau$ while preserving the nonnegativity of reactant populations. The key insight for a unimolecular reaction is to consider the fate of each individual reactant molecule independently.\n\nLet $X_A(t)$ be the number of molecules of species $A$ at time $t$. We consider the time interval $[t, t+\\tau]$. Since the system is well-mixed, each of the $X_A(t)$ molecules of $A$ behaves identically and independently of the others. The reaction $A \\xrightarrow{c} \\emptyset$ implies that each individual molecule of $A$ has a constant probability per unit time, $c$, of undergoing a decay event.\n\nThe waiting time for a specific, single molecule of $A$ to decay is a random variable, let's call it $T_{decay}$, that follows an exponential distribution with rate parameter $c$. The probability density function is $f(s) = c \\exp(-cs)$ for $s \\ge 0$.\n\nThe probability that this single, specific molecule will decay within the time interval of duration $\\tau$ is the probability that its decay time $T_{decay}$ is less than or equal to $\\tau$. This is given by the cumulative distribution function (CDF) of the exponential distribution:\n$$\nP(T_{decay} \\le \\tau) = \\int_{0}^{\\tau} c \\exp(-cs) \\, ds = \\left[ -\\exp(-cs) \\right]_{0}^{\\tau} = -\\exp(-c\\tau) - (-\\exp(0)) = 1 - \\exp(-c\\tau)\n$$\nLet's define this probability as $p$:\n$$\np = 1 - \\exp(-c\\tau)\n$$\nThis value $p$ is the probability that any one of the $X_A(t)$ molecules will decay during the interval $[t, t+\\tau]$.\n\nNow, we consider the entire population of $X_A(t)$ molecules at the start of the interval. Each molecule represents an independent trial. We can define a \"success\" for a trial as the event that the corresponding molecule decays within the time $\\tau$. We have $X_A(t)$ such independent Bernoulli trials, and the probability of success for each trial is $p = 1 - \\exp(-c\\tau)$.\n\nThe total number of reaction firings, let's denote it by $K$, during the interval $[t, t+\\tau]$, is the total number of successes in these $X_A(t)$ trials. The probability distribution of the number of successes in a fixed number of independent Bernoulli trials is, by definition, the binomial distribution.\n\nTherefore, the number of firings $K$ is a random variable drawn from a binomial distribution with parameters $n$ and $p$, where:\n1.  The number of trials, $n$, is the number of reactant molecules available at the start of the leap, which is $X_A(t)$.\n2.  The probability of success for each trial, $p$, is the probability of a single molecule decaying within the leap, which we derived as $1 - \\exp(-c\\tau)$.\n\nSo, we have $K \\sim \\text{Binomial}(n, p)$ with:\n$$\nn = X_A(t)\n$$\n$$\np = 1 - \\exp(-c\\tau)\n$$\nThis formulation inherently enforces nonnegativity. The number of firings $K$ sampled from $\\text{Binomial}(X_A(t), p)$ is an integer such that $0 \\le K \\le X_A(t)$. The number of molecules of $A$ at the end of the leap is $X_A(t+\\tau) = X_A(t) - K$. Since $K \\le X_A(t)$, it is guaranteed that $X_A(t+\\tau) \\ge 0$. This resolves the primary issue of reactant depletion that affects naive tau-leaping methods.\n\nThe parameters of the binomial distribution for sampling the number of firings of the reaction $A \\xrightarrow{c} \\emptyset$ during a leap of duration $\\tau$, starting with $X_A(t)$ molecules, are thus $n=X_A(t)$ and $p=1-\\exp(-c\\tau)$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\nX_A(t)  1 - \\exp(-c\\tau)\n\\end{pmatrix}\n}\n$$", "id": "3353308"}, {"introduction": "A bug in a simulation can produce results that look plausible but are physically incorrect, making verification a critical part of computational science. This exercise [@problem_id:3353365] challenges you to think like a software tester for the Gillespie algorithm. You will evaluate a series of proposed validation checks, learning to separate theoretically sound tests from those based on common misconceptions, a vital skill for producing reliable and reproducible scientific results.", "problem": "Consider implementing the Stochastic Simulation Algorithm (SSA) for a well-mixed reaction network modeled as a continuous-time Markov chain with states $\\mathbf{X}(t) \\in \\mathbb{Z}_{\\ge 0}^n$, stoichiometric change vectors $\\boldsymbol{\\nu}_j \\in \\mathbb{Z}^n$, and propensities $a_j(\\mathbf{x})$ that satisfy the chemical master equation (CME). A team proposes several tests to verify correctness of their SSA implementation. Your task is to identify which of the proposed tests are theoretically sound, based on first principles of the CME and the continuous-time Markov chain construction underlying the SSA. Assume propensities are standard mass-action where appropriate, and that random numbers used by the SSA are independent and identically distributed Uniform($0,1$). Select all valid tests.\n\nA. Conservation-law and non-negativity invariant test: For the reversible unimolecular network $S_1 \\xrightleftharpoons[c_2]{c_1} S_2$ with propensities $a_1(\\mathbf{x}) = c_1 X_1$ and $a_2(\\mathbf{x}) = c_2 X_2$, verify across many SSA trajectories that $X_1(t) + X_2(t) = X_1(0) + X_2(0)$ for all $t \\ge 0$, and that $X_1(t) \\ge 0$ and $X_2(t) \\ge 0$ for all $t \\ge 0$.\n\nB. Zero-propensity edge case: Include a bimolecular reaction $2 S_1 \\to S_2$ with mass-action propensity $a_3(\\mathbf{x}) = c_3 \\binom{X_1}{2}$ in a network that also has the reversible unimolecular reactions in option A. Initialize with $X_1(0) = 1$, $X_2(0) = 0$. Verify that reaction $3$ never fires until some other reaction changes the state so that $X_1 \\ge 2$, at which point the firing of reaction $3$ becomes possible.\n\nC. Single-reaction goodness-of-fit: Consider the single-reaction birth process $\\varnothing \\to S_1$ with constant propensity $a(\\mathbf{x}) = c$ independent of $\\mathbf{x}$. Using many independent SSA paths, perform a Kolmogorov–Smirnov (KS) goodness-of-fit test for the inter-event waiting times against the exponential distribution with rate $c$, and a chi-square test that the event count in a fixed window of length $T$ is Poisson with mean $c T$.\n\nD. First-event selection probability test: For a general network with reactions indexed by $j \\in \\{1, \\dots, m\\}$ and propensities $a_j(\\mathbf{x})$, fix an initial state $\\mathbf{X}(0) = \\mathbf{x}_0$. Across many independent runs, stop each trajectory after the first reaction fires, and estimate the probability that reaction $j$ is the first to fire. Verify that this empirical probability agrees with $a_j(\\mathbf{x}_0) / a_0(\\mathbf{x}_0)$, where $a_0(\\mathbf{x}) = \\sum_{i=1}^m a_i(\\mathbf{x})$.\n\nE. Raw-time exponential fit in general networks: For a general multireaction network with state-dependent propensities, pool all inter-event waiting times $\\tau_k$ observed along full SSA trajectories and perform a KS test that $\\tau_k$ are independent and identically distributed exponential random variables with rate $a_0(\\mathbf{X}(0))$.\n\nF. Time-rescaling goodness-of-fit: For a general multireaction network, compute the transformed inter-event times $Z_k = \\int_{t_k}^{t_{k+1}} a_0(\\mathbf{X}(s)) \\, ds$, where $t_k$ and $t_{k+1}$ are consecutive reaction times and $a_0(\\mathbf{x}) = \\sum_{j=1}^m a_j(\\mathbf{x})$. Perform a KS test that $Z_k$ are independent and identically distributed exponential random variables with rate $1$, and complement with a quantile-quantile plot against the exponential distribution with rate $1$.\n\nG. Max-propensity heuristic check: At each reaction step, verify that the reaction fired is the one with the largest propensity $a_j(\\mathbf{X})$ among all reactions; flag any trajectory where a reaction with smaller propensity fires.\n\nSelect all tests that are theoretically valid for verifying correctness of an SSA implementation.", "solution": "The SSA is an exact simulation method for the stochastic time evolution of a well-mixed reacting system. At each step, for a system in state $\\mathbf{x}$, the algorithm performs two tasks:\n1.  Draw a time-to-next-event, $\\tau$, from an exponential distribution with rate $a_0(\\mathbf{x}) = \\sum_{j=1}^m a_j(\\mathbf{x})$.\n2.  Draw the index of the next reaction, $j$, from a discrete distribution where the probability of choosing reaction $j$ is $a_j(\\mathbf{x}) / a_0(\\mathbf{x})$.\n\nThe new state is then $\\mathbf{x} + \\boldsymbol{\\nu}_j$ at time $t + \\tau$. All proposed tests will be evaluated against these first principles.\n\n**A. Conservation-law and non-negativity invariant test**\n\nThis test proposes to verify two properties for the reversible reaction $S_1 \\xrightleftharpoons[c_2]{c_1} S_2$.\n1.  **Conservation Law**: The reactions are $S_1 \\to S_2$ and $S_2 \\to S_1$. The stoichiometric change vectors are $\\boldsymbol{\\nu}_1 = (-1, 1)^T$ and $\\boldsymbol{\\nu}_2 = (1, -1)^T$, where the state is $(X_1, X_2)^T$. For any reaction that fires, the change in the total number of molecules, $X_1 + X_2$, is $\\Delta(X_1 + X_2) = \\nu_{j,1} + \\nu_{j,2}$. For both $j=1$ and $j=2$, this sum is $0$. Thus, $X_1(t) + X_2(t)$ is a constant of motion, or a conservation law, for the system. A correct SSA implementation must preserve all such linear conservation laws. Verifying that $X_1(t) + X_2(t) = X_1(0) + X_2(0)$ is a valid test of the state update step.\n2.  **Non-negativity**: The state variables $X_1(t)$ and $X_2(t)$ represent molecule counts and must be non-negative integers. The mass-action propensities $a_1(\\mathbf{x}) = c_1 X_1$ and $a_2(\\mathbf{x}) = c_2 X_2$ are defined such that if a species count is zero (e.g., $X_1 = 0$), the propensity of any reaction consuming that species is also zero ($a_1 = 0$). According to the SSA, a reaction with zero propensity has zero probability of being chosen. Therefore, a correct implementation will never allow a reaction to fire that would result in a negative population count. Checking that $X_1(t) \\ge 0$ and $X_2(t) \\ge 0$ is a fundamental and valid test.\n\nThe verdict for this option is **Correct**.\n\n**B. Zero-propensity edge case**\n\nThis test examines the algorithm's behavior when a reaction propensity is exactly zero. The reaction $2S_1 \\to S_2$ has a mass-action propensity $a_3(\\mathbf{x}) = c_3 \\binom{X_1}{2} = c_3 \\frac{X_1(X_1-1)}{2}$. If the system is initialized with $X_1(0) = 1$, the initial propensity is $a_3 = c_3 \\frac{1(1-1)}{2} = 0$. Since the probability of selecting reaction $j$ is $a_j(\\mathbf{x})/a_0(\\mathbf{x})$, the probability of selecting reaction $3$ is $0/a_0(\\mathbf{x}) = 0$. Reaction $3$ cannot fire. It only becomes possible for it to fire if another reaction in the network first increases the population of $S_1$ to at least $2$. This is a crucial edge case. A faulty implementation (e.g., one with poor handling of floating-point arithmetic or indexing) might incorrectly select a reaction with zero propensity. This test is designed to catch such a flaw.\n\nThe verdict for this option is **Correct**.\n\n**C. Single-reaction goodness-of-fit**\n\nThis test considers a simple birth process $\\varnothing \\to S_1$ with constant propensity $a(\\mathbf{x}) = c$.\n1.  **Inter-event times**: The total propensity is $a_0(\\mathbf{x}) = c$, which is constant. According to the SSA, the time between consecutive events, $\\tau$, must be drawn from an exponential distribution with rate $a_0(\\mathbf{x}) = c$. Since the rate is constant, all inter-event times are independent and identically distributed (i.i.d.) random variables from $\\text{Exponential}(c)$. A Kolmogorov-Smirnov (KS) test is a standard statistical procedure to check if a sample of data comes from a specified continuous distribution. Thus, it is a valid way to test the \"when\" part of the SSA.\n2.  **Event count**: A process where events occur with a constant rate $c$ is a homogeneous Poisson process. For such a process, the number of events occurring in a fixed time interval of length $T$ follows a Poisson distribution with mean $\\lambda = cT$. A chi-square goodness-of-fit test is a standard method to test if count data follows a particular discrete distribution, like the Poisson. This is also a valid verification method.\n\nThe verdict for this option is **Correct**.\n\n**D. First-event selection probability test**\n\nThis test focuses on the reaction selection rule. For a fixed initial state $\\mathbf{X}(0) = \\mathbf{x}_0$, the total propensity is fixed at $a_0(\\mathbf{x}_0) = \\sum_{j=1}^m a_j(\\mathbf{x}_0)$. The theoretical probability that the very first reaction to fire is reaction $j$ is given by the SSA's selection rule: $P(j|\\mathbf{x}_0) = a_j(\\mathbf{x}_0) / a_0(\\mathbf{x}_0)$. By running many independent simulations and recording which reaction fires first, one can generate an empirical frequency distribution. Comparing this empirical distribution to the theoretical probabilities $\\{P(j|\\mathbf{x}_0)\\}_{j=1}^m$ (e.g., using a chi-square test) provides a direct and powerful verification of the \"which\" part of the SSA implementation.\n\nThe verdict for this option is **Correct**.\n\n**E. Raw-time exponential fit in general networks**\n\nThis test proposes pooling all inter-event times $\\tau_k$ from trajectories of a general network and testing if they fit an exponential distribution with rate $a_0(\\mathbf{X}(0))$. This is theoretically incorrect. The inter-event time $\\tau_k$ is drawn from an exponential distribution with rate $a_0(\\mathbf{X}(t_{k-1}))$, where $\\mathbf{X}(t_{k-1})$ is the state *at that time*. In a general network, the state $\\mathbf{X}$ changes, so the total propensity $a_0$ is a function of time, $a_0(t) \\equiv a_0(\\mathbf{X}(t))$. The waiting times $\\tau_k$ are therefore drawn from exponential distributions with *different* rates. They are independent but not identically distributed. Pooling them creates a mixture distribution, which is not, in general, an exponential distribution. Testing this mixture against a specific exponential distribution (especially one with the an arbitrarily chosen rate from the initial time) is statistically and theoretically unfounded.\n\nThe verdict for this option is **Incorrect**.\n\n**F. Time-rescaling goodness-of-fit**\n\nThis test is a sophisticated and correct alternative to E. It uses the time-rescaling theorem. The inter-event time $\\tau_k = t_{k+1} - t_k$ is a random variable drawn from $\\text{Exponential}(\\lambda_k)$, where the rate is $\\lambda_k = a_0(\\mathbf{X}(t_k))$. The state $\\mathbf{X}(s)$ is constant for $s \\in [t_k, t_{k+1})$, so $\\mathbf{X}(s) = \\mathbf{X}(t_k)$ on this interval. The proposed transformed variable is $Z_k = \\int_{t_k}^{t_{k+1}} a_0(\\mathbf{X}(s)) \\, ds$. Since the integrand is constant, this becomes $Z_k = a_0(\\mathbf{X}(t_k)) \\cdot (t_{k+1} - t_k) = \\lambda_k \\tau_k$. If a random variable $\\tau_k \\sim \\text{Exponential}(\\lambda_k)$, then the scaled random variable $Z_k = \\lambda_k \\tau_k$ follows an exponential distribution with rate $1$. This holds for every step $k$. Therefore, the sequence of transformed times $\\{Z_k\\}$ should be a sample of i.i.d. random variables from the standard $\\text{Exponential}(1)$ distribution. Using a KS test or a Q-Q plot to verify this is a powerful and theoretically sound method for validating the timing aspect of the SSA in the general case of state-dependent propensities.\n\nThe verdict for this option is **Correct**.\n\n**G. Max-propensity heuristic check**\n\nThis test proposes to verify that the reaction with the largest propensity is always the one that fires. This is a fundamental misunderstanding of the SSA. The SSA is a stochastic algorithm, not a deterministic one. The propensities determine the *probabilities* of reactions, not a deterministic choice. A reaction $j$ is chosen with probability $a_j(\\mathbf{x}) / a_0(\\mathbf{x})$. While a reaction with a larger propensity is more likely to be chosen, any reaction with a non-zero propensity has a non-zero chance of occurring. For example, if $a_1(\\mathbf{x}) = 100$ and $a_2(\\mathbf{x}) = 1$, reaction $2$ has a small but non-zero probability of being selected, approximately $1/101$. A correct SSA implementation must be able to select reaction $2$. Flagging a trajectory where this happens as an error would be incorrect. This test describes a greedy algorithm, not the SSA.\n\nThe verdict for this option is **Incorrect**.\n\nIn summary, the theoretically valid tests are A, B, C, D, and F.", "answer": "$$\\boxed{ABCDF}$$", "id": "3353365"}]}