{"hands_on_practices": [{"introduction": "The foundation of analyzing any complex queueing system is the ability to build a robust event-driven simulator. This first practice guides you through the essential mechanics of implementing such a simulation for a single-server queue with a finite capacity, a common feature known as balking. By coding the logic for handling arrivals and departures, managing state variables, and accumulating statistics over time, you will develop the core skills needed to measure a wide array of standard performance metrics, from server utilization to customer waiting times [@problem_id:3343632]. This exercise is fundamental for translating theoretical queueing models into practical, computational tools for performance evaluation.", "problem": "Consider a single-server queueing system with exponentially distributed inter-arrival and service times and balking. Let $Q(t)$ denote the total number of customers in the system (including any in service) at time $t$. Arrivals form a Poisson process with rate $\\lambda$ (in $\\mathrm{s}^{-1}$), service times are independent and exponentially distributed with rate $\\mu$ (in $\\mathrm{s}^{-1}$), and the server can process one customer at a time. Balking occurs according to the following rule: an arriving customer is admitted only if $Q(t)  b$, where $b$ is a finite capacity threshold; otherwise, the customer balks and departs immediately without entering the system. When $b = \\infty$, there is no balking and the system is the standard $M/M/1$ queue. When $b$ is finite, the system is an $M/M/1/b$ loss/finite-capacity system.\n\nStarting from the fundamental facts that (i) the Poisson process has independent and stationary increments and exponentially distributed inter-arrival times, and (ii) exponential service times are memoryless and independent of arrivals, implement an event-driven stochastic simulation of this system over a finite horizon of length $T$ seconds. For each test case, use a pseudorandom number generator seeded with $s$ and re-seed per case with $s+i$ for case index $i$ starting from $i=0$, so that the results are reproducible.\n\nYour simulation must compute the following performance metrics over the simulation horizon:\n- The estimated effective admitted arrival rate $\\hat{\\lambda}_{\\mathrm{eff}}$ in $\\mathrm{s}^{-1}$, defined as the number of admitted arrivals divided by $T$.\n- The estimated balking fraction $\\hat{p}_{\\mathrm{balk}}$, defined as the number of balked arrivals divided by the total number of arrival attempts (admitted plus balked). This must be reported as a decimal.\n- The estimated server utilization $\\hat{\\rho}$, defined as the fraction of time the server is busy over $[0,T]$.\n- The estimated time-average number in system $\\widehat{E}[Q]$, computed as the integral of $Q(t)$ over $[0,T]$ divided by $T$.\n- The estimated average waiting time in queue $\\widehat{E}[W]$ in seconds, defined as the average of $W_i$, where $W_i$ is the waiting time (arrival to service-start) for admitted customers who start service within $[0,T]$.\n- The estimated average sojourn time $\\widehat{E}[S]$ in seconds, defined as the average of $S_i$, where $S_i$ is the time in system (arrival to departure) for customers who depart within $[0,T]$.\n- The estimated throughput $\\widehat{\\theta}$ in $\\mathrm{s}^{-1}$, defined as the number of departures within $[0,T]$ divided by $T$.\n- A stability indicator $\\mathrm{stable}$ (boolean), defined as $True$ if either $b$ is finite (the continuous-time Markov chain is positive recurrent due to finite state space) or, when $b=\\infty$, if $\\lambda  \\mu$ (the standard $M/M/1$ stability condition), and $False$ otherwise.\n\nAll times must be reported in seconds and all rates in $\\mathrm{s}^{-1}$. Angles are not applicable. Express the balking fraction as a decimal, not a percentage. Your algorithm must be event-driven: generate the next arrival time as an exponential increment with parameter $\\lambda$, and the next service completion time as an exponential increment with parameter $\\mu$ conditional on the server being busy. Update time-averaged quantities by integrating piecewise-constant trajectories between events. Do not use shortcut formulas for the stationary distribution; derive metrics empirically via simulation.\n\nTest Suite:\nUse the following parameter sets and horizon, with a common base seed $s=314159$:\n1. Case A (happy path, stable $M/M/1$): $\\lambda = 0.8$, $\\mu = 1.0$, $b = \\infty$, $T = 20000$.\n2. Case B (overloaded without balking, stabilized by finite capacity): $\\lambda = 1.2$, $\\mu = 1.0$, $b = 5$, $T = 20000$.\n3. Case C (pure loss system): $\\lambda = 2.0$, $\\mu = 1.0$, $b = 1$, $T = 20000$.\n4. Case D (degenerate zero capacity): $\\lambda = 1.0$, $\\mu = 1.0$, $b = 0$, $T = 20000$.\n5. Case E (fast service, large but finite capacity): $\\lambda = 5.0$, $\\mu = 10.0$, $b = 50$, $T = 20000$.\n\nRequired Final Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case’s result must be an ordered list in the following order:\n$[\\hat{\\lambda}_{\\mathrm{eff}}, \\hat{p}_{\\mathrm{balk}}, \\hat{\\rho}, \\widehat{E}[Q], \\widehat{E}[W], \\widehat{E}[S], \\widehat{\\theta}, \\mathrm{stable}]$.\nAggregate all five test case lists into a single list, so the final output is\n$[[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot]]$\nprinted on a single line.", "solution": "The user wants to solve the problem. I will first validate the problem statement.\n\n### Step 1: Extract Givens\n- **System Model**: Single-server queueing system with balking.\n- **Arrival Process**: Poisson process with rate $\\lambda$ ($\\mathrm{s}^{-1}$). Inter-arrival times are independent and exponentially distributed.\n- **Service Process**: Service times are independent and exponentially distributed with rate $\\mu$ ($\\mathrm{s}^{-1}$). Single server.\n- **State Variable**: $Q(t)$ is the total number of customers in the system at time $t$.\n- **Balking Rule**: An arriving customer is admitted only if $Q(t)  b$, where $b$ is a finite capacity threshold. If $Q(t) \\ge b$, the customer balks.\n- **Special Cases**: If $b = \\infty$, the system is a standard $M/M/1$ queue. If $b$ is finite, it is an $M/M/1/b$ queue.\n- **Simulation Parameters**:\n    - Simulation horizon: $T$ seconds.\n    - Pseudorandom number generator base seed: $s=314159$.\n    - Seeding rule: For test case index $i$ (starting from $i=0$), use seed $s+i$.\n- **Performance Metrics to Compute**:\n    1.  $\\hat{\\lambda}_{\\mathrm{eff}}$: Estimated effective admitted arrival rate ($\\mathrm{s}^{-1}$) = (number of admitted arrivals) / $T$.\n    2.  $\\hat{p}_{\\mathrm{balk}}$: Estimated balking fraction = (number of balked arrivals) / (total arrival attempts).\n    3.  $\\hat{\\rho}$: Estimated server utilization = (fraction of time server is busy over $[0,T]$).\n    4.  $\\widehat{E}[Q]$: Estimated time-average number in system = $(\\int_0^T Q(t) dt) / T$.\n    5.  $\\widehat{E}[W]$: Estimated average waiting time in queue (s) = average of $W_i$ for admitted customers who start service within $[0,T]$.\n    6.  $\\widehat{E}[S]$: Estimated average sojourn time (s) = average of $S_i$ for customers who depart within $[0,T]$.\n    7.  $\\widehat{\\theta}$: Estimated throughput ($\\mathrm{s}^{-1}$) = (number of departures within $[0,T]$) / $T$.\n    8.  $\\mathrm{stable}$: Stability indicator (boolean) = $True$ if $b$ is finite or ($\\lambda  \\mu$ and $b=\\infty$), $False$ otherwise.\n- **Methodology**: Event-driven simulation. Do not use analytical formulas for stationary distributions.\n- **Test Suite**:\n    1.  Case A: $\\lambda = 0.8$, $\\mu = 1.0$, $b = \\infty$, $T = 20000$.\n    2.  Case B: $\\lambda = 1.2$, $\\mu = 1.0$, $b = 5$, $T = 20000$.\n    3.  Case C: $\\lambda = 2.0$, $\\mu = 1.0$, $b = 1$, $T = 20000$.\n    4.  Case D: $\\lambda = 1.0$, $\\mu = 1.0$, $b = 0$, $T = 20000$.\n    5.  Case E: $\\lambda = 5.0$, $\\mu = 10.0$, $b = 50$, $T = 20000$.\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded**: The problem describes the simulation of an $M/M/1/b$ queue, a canonical model in queueing theory, which is a well-established field within applied probability and operations research. The methodology of event-driven simulation is the standard and correct approach for analyzing such stochastic systems. All concepts are firmly based on established scientific and mathematical principles.\n2.  **Well-Posed**: The problem is specified with complete and unambiguous information. All necessary parameters ($\\lambda$, $\\mu$, $b$, $T$) and the seeding protocol for the random number generator are provided for each test case. The definitions of the performance metrics are precise. This structure ensures that for a given implementation of the specified random number generator, a unique and meaningful set of results can be obtained.\n3.  **Objective**: The problem statement is written in formal, objective language, free of any subjective or opinion-based claims. All terms are standard and rigorously defined.\n4.  **No Flaws**: The problem is free of the flaws listed in the instructions. It is scientifically sound, fully formalizable, complete, and well-structured. It is a non-trivial computational task that accurately reflects a standard problem in stochastic simulation.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A complete, reasoned solution will be provided.\n\n---\n\nThe problem requires the implementation of an event-driven simulation for a single-server queueing system with balking, known as an $M/M/1/b$ queue. The simulation will be used to estimate several key performance metrics over a finite time horizon $T$.\n\n**1. System Modeling and Simulation Approach**\n\nThe system state is characterized by $Q(t)$, the number of customers in the system. The state changes only at discrete points in time corresponding to two types of events: customer arrivals and service completions (departures). This makes event-driven simulation the natural and efficient methodology. We maintain a simulation clock and an event calendar containing the times of the next scheduled arrival and departure. The simulation proceeds by advancing the clock to the time of the next imminent event.\n\nThe fundamental properties of the Poisson arrival process and exponential service times are crucial.\n- Inter-arrival times are independent and identically distributed (i.i.d.) exponential random variables with mean $1/\\lambda$. This allows us to schedule the next arrival event at time $t_{current} + \\Delta t_A$, where $\\Delta t_A \\sim \\text{Exponential}(\\lambda)$.\n- Service times are i.i.d. exponential random variables with mean $1/\\mu$. The memoryless property of the exponential distribution simplifies the logic: the remaining service time for a customer in service is independent of how long they have already been in service. Thus, when a customer begins service at time $t_{start}$, we can schedule their departure at $t_{start} + S$, where $S \\sim \\text{Exponential}(\\mu)$.\n\n**2. Simulation Algorithm**\n\nThe simulation algorithm is structured as follows:\n\n**Initialization:**\n1.  Initialize the simulation clock, $t_{clock}$, to $0$.\n2.  Initialize the system state: number of customers in the system, $N$, to $0$.\n3.  Initialize statistical accumulators to $0$: number of arrivals (attempted, admitted, balked), number of departures, total server busy time, area under the $Q(t)$ curve, total waiting time, and total sojourn time.\n4.  Initialize an empty First-In-First-Out (FIFO) queue, `customer_arrivals`, to store the arrival times of customers currently in the system. This is essential for calculating waiting and sojourn times.\n5.  Schedule the first arrival: generate an inter-arrival time $\\Delta t_A \\sim \\text{Exponential}(\\lambda)$ and set the next arrival time, $t_{arrival}$, to $t_{clock} + \\Delta t_A$.\n6.  Set the next departure time, $t_{departure}$, to infinity, as the system is initially empty and the server is idle.\n\n**Main Simulation Loop:**\nThe loop continues as long as the next event time is less than the simulation horizon $T$.\n\n1.  Identify the next event: $t_{next\\_event} = \\min(t_{arrival}, t_{departure})$.\n2.  If $t_{next\\_event} \\ge T$, exit the loop.\n3.  Update time-averaged statistics: The state $N$ has been constant during the interval $[t_{last\\_event}, t_{next\\_event}]$.\n    - Update area under $Q(t)$: $\\text{Area}[Q] \\leftarrow \\text{Area}[Q] + N \\times (t_{next\\_event} - t_{clock})$.\n    - Update server busy time: If $N  0$, $\\text{BusyTime} \\leftarrow \\text{BusyTime} + (t_{next\\_event} - t_{clock})$.\n4.  Advance the clock: $t_{clock} \\leftarrow t_{next\\_event}$.\n5.  Process the event:\n    - **If $t_{clock} = t_{arrival}$ (Arrival Event):**\n        a. Increment the total attempted arrivals counter.\n        b. Check the balking condition: If $N  b$, the customer is admitted.\n            i. Increment admitted arrivals counter.\n            ii. Add the current time, $t_{clock}$, to the `customer_arrivals` queue.\n            iii. Increment the number in system: $N \\leftarrow N + 1$.\n            iv. If the server was idle ($N$ was $0$), the customer starts service immediately. Their waiting time is $0$. Increment the count of customers who started service and schedule a departure: generate service time $S \\sim \\text{Exponential}(\\mu)$ and set $t_{departure} = t_{clock} + S$.\n        c. If $N \\ge b$, the customer balks. Increment the balked arrivals counter. $N$ remains unchanged.\n        d. Schedule the next arrival: generate $\\Delta t_A \\sim \\text{Exponential}(\\lambda)$ and set $t_{arrival} = t_{clock} + \\Delta t_A$.\n    - **If $t_{clock} = t_{departure}$ (Departure Event):**\n        a. Increment the departures counter.\n        b. Retrieve the arrival time of the departing customer by removing the head of the `customer_arrivals` queue. Calculate their sojourn time $S_i = t_{clock} - (\\text{arrival time})$. Add $S_i$ to the total sojourn time accumulator and increment the count of departed customers.\n        c. Decrement the number in system: $N \\leftarrow N - 1$.\n        d. If the system is now empty ($N=0$), the server becomes idle. Set $t_{departure} = \\infty$.\n        e. If the system is not empty ($N0$), the next customer in the queue begins service.\n            i. Their waiting time is $W_i = t_{clock} - (\\text{arrival time of new customer})$. Add $W_i$ to the total waiting time accumulator and increment the count of customers who started service.\n            ii. Schedule their departure: generate $S \\sim \\text{Exponential}(\\mu)$ and set $t_{departure} = t_{clock} + S$.\n\n**Termination and Final Calculations:**\n1.  After the loop terminates, the last event occurred at $t_{clock}  T$. We must account for the final interval $[t_{clock}, T]$ during which the state $N$ remained constant. Update $\\text{Area}[Q]$ and $\\text{BusyTime}$ for this final duration.\n2.  Compute the final metrics based on their definitions using the accumulated statistics and the horizon $T$:\n    - $\\hat{\\lambda}_{\\mathrm{eff}} = (\\text{admitted arrivals}) / T$\n    - $\\hat{p}_{\\mathrm{balk}} = (\\text{balked arrivals}) / (\\text{total arrivals})$\n    - $\\hat{\\rho} = (\\text{total busy time}) / T$\n    - $\\widehat{E}[Q] = (\\text{Area}[Q]) / T$\n    - $\\widehat{E}[W] = (\\text{total wait time}) / (\\text{customers who started service})$\n    - $\\widehat{E}[S] = (\\text{total sojourn time}) / (\\text{departed customers})$\n    - $\\widehat{\\theta} = (\\text{departures}) / T$\n    - $\\mathrm{stable} = (b \\neq \\infty) \\lor (\\lambda  \\mu)$\n    Special care is taken for cases where denominators are zero (e.g., no customers departed), in which case the corresponding average is reported as $0$.\n\nThis rigorous, event-by-event simulation approach correctly models the stochastic dynamics of the $M/M/1/b$ system and allows for the empirical estimation of the required performance metrics without relying on analytical steady-state formulas, as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n\n    def simulate(lambda_, mu, b, T, seed):\n        \"\"\"\n        Performs an event-driven simulation of an M/M/1/b queue.\n\n        Args:\n            lambda_ (float): Arrival rate.\n            mu (float): Service rate.\n            b (float or int): System capacity threshold for balking.\n            T (int): Simulation horizon time.\n            seed (int): Seed for the random number generator.\n\n        Returns:\n            list: A list containing the eight calculated performance metrics.\n        \"\"\"\n        rng = np.random.default_rng(seed)\n\n        # State variables\n        clock = 0.0\n        num_in_system = 0\n        time_next_arrival = rng.exponential(scale=1.0/lambda_) if lambda_  0 else float('inf')\n        time_next_departure = float('inf')\n        \n        # FIFO queue for customers in system, storing their arrival times\n        customer_arrival_times = collections.deque()\n\n        # Statistical accumulators\n        last_event_time = 0.0\n        total_arrivals_attempted = 0\n        num_admitted = 0\n        num_balked = 0\n        num_departures = 0\n        \n        total_busy_time = 0.0\n        area_num_in_system = 0.0\n        \n        total_sojourn_time = 0.0\n        num_customers_sojourned = 0\n        \n        total_wait_time = 0.0\n        num_customers_waited = 0\n\n        # Main simulation loop\n        while time_next_arrival  T or time_next_departure  T:\n            \n            next_event_time = min(time_next_arrival, time_next_departure)\n            \n            # Update time-averaged statistics for the interval since the last event\n            time_since_last_event = next_event_time - last_event_time\n            area_num_in_system += num_in_system * time_since_last_event\n            if num_in_system  0:\n                total_busy_time += time_since_last_event\n\n            clock = next_event_time\n\n            # Process the next event\n            if clock == time_next_arrival:  # Arrival Event\n                total_arrivals_attempted += 1\n                \n                if num_in_system  b:\n                    # Customer is admitted\n                    num_admitted += 1\n                    customer_arrival_times.append(clock)\n                    num_in_system += 1\n                    \n                    if num_in_system == 1:  # Server was idle\n                        # Customer starts service immediately, waiting time is 0\n                        total_wait_time += 0.0\n                        num_customers_waited += 1\n                        \n                        service_time = rng.exponential(scale=1.0/mu) if mu  0 else float('inf')\n                        time_next_departure = clock + service_time\n                else:\n                    # Customer balks\n                    num_balked += 1\n                \n                # Schedule next arrival\n                inter_arrival_time = rng.exponential(scale=1.0/lambda_) if lambda_  0 else float('inf')\n                time_next_arrival = clock + inter_arrival_time\n                \n            else:  # Departure Event (clock == time_next_departure)\n                num_departures += 1\n                num_in_system -= 1\n                \n                # Record sojourn time for the departing customer\n                arrival_time_of_departed = customer_arrival_times.popleft()\n                sojourn_time = clock - arrival_time_of_departed\n                total_sojourn_time += sojourn_time\n                num_customers_sojourned += 1\n                \n                if num_in_system  0: # A customer from the queue starts service\n                    # Record waiting time for the customer starting service\n                    arrival_time_new_service = customer_arrival_times[0]\n                    wait_time = clock - arrival_time_new_service\n                    total_wait_time += wait_time\n                    num_customers_waited += 1\n                    \n                    # Schedule new departure\n                    service_time = rng.exponential(scale=1.0/mu) if mu  0 else float('inf')\n                    time_next_departure = clock + service_time\n                else: # System becomes empty\n                    time_next_departure = float('inf')\n\n            last_event_time = clock\n            \n        # Account for the final interval from the last event time to T\n        final_interval = T - last_event_time\n        if final_interval  0:\n            area_num_in_system += num_in_system * final_interval\n            if num_in_system  0:\n                total_busy_time += final_interval\n\n        # Calculate final performance metrics\n        eff_arrival_rate = num_admitted / T\n        balk_fraction = num_balked / total_arrivals_attempted if total_arrivals_attempted  0 else 0.0\n        utilization = total_busy_time / T\n        avg_num_in_system = area_num_in_system / T\n        avg_wait_time = total_wait_time / num_customers_waited if num_customers_waited  0 else 0.0\n        avg_sojourn_time = total_sojourn_time / num_customers_sojourned if num_customers_sojourned  0 else 0.0\n        throughput = num_departures / T\n        \n        is_stable = (b != float('inf')) or (lambda_  mu)\n\n        return [\n            eff_arrival_rate, balk_fraction, utilization,\n            avg_num_in_system, avg_wait_time, avg_sojourn_time,\n            throughput, is_stable\n        ]\n\n    # Define the test cases from the problem statement.\n    base_seed = 314159\n    test_cases = [\n        (0.8, 1.0, float('inf'), 20000), # Case A\n        (1.2, 1.0, 5, 20000),          # Case B\n        (2.0, 1.0, 1, 20000),          # Case C\n        (1.0, 1.0, 0, 20000),          # Case D\n        (5.0, 10.0, 50, 20000),         # Case E\n    ]\n    \n    all_results = []\n    for i, (lambda_val, mu_val, b_val, T_val) in enumerate(test_cases):\n        case_seed = base_seed + i\n        result = simulate(lambda_val, mu_val, b_val, T_val, case_seed)\n        all_results.append(result)\n        \n    formatted_results = []\n    for res in all_results:\n        # Format each inner list as a string without spaces\n        formatted_res = f\"[{','.join(map(str, res))}]\"\n        formatted_results.append(formatted_res)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3343632"}, {"introduction": "Beyond simply measuring performance, simulation allows us to empirically investigate the subtle and powerful principles that govern stochastic systems. This practice focuses on one of the most celebrated and often misunderstood results in queueing theory: the PASTA (Poisson Arrivals See Time Averages) property. You will design a simulation to compare the system state distribution as seen by an arriving customer versus that seen by an observer at a random point in time [@problem_id:3343617]. By testing this for both Poisson and non-Poisson arrival processes, you will gain a deep, hands-on understanding of why the memoryless property of Poisson arrivals is so critical and why many analytical shortcuts are not valid for more general systems.", "problem": "Consider a single-server queue operating under First-Come First-Served (FCFS) discipline. Let the system state be the number of customers in the system (in service plus in queue) at time $t$, denoted by $Q(t)$. Service times are independent and identically distributed exponential random variables with rate parameter $\\mu$ in $1/\\mathrm{s}$, independent of the arrival process and all history. The arrival process is either a Poisson process with rate $\\lambda$ in $1/\\mathrm{s}$ or a renewal process with a specified interarrival time distribution having mean $1/\\lambda$ seconds.\n\nTask 1 (Statement of Poisson Arrivals See Time Averages (PASTA)): State the Poisson Arrivals See Time Averages (PASTA) property formally for Poisson arrivals, in terms of $Q(t)$ and the distribution observed at arrival epochs. Explicitly define the arrival-epoch observation as $Q(T_n^-)$, where $T_n$ is the time of the $n$-th arrival and $Q(T_n^-)$ denotes the left-limit just before the $n$-th arrival enters the system.\n\nTask 2 (Design and implement a simulation to empirically confirm PASTA): Design and implement an event-driven stochastic simulation that:\n- Simulates the continuous-time evolution of $Q(t)$ for a single-server FCFS queue with exponential service times of rate $\\mu$ in $1/\\mathrm{s}$.\n- For the arrival process, supports three regimes: Poisson with rate $\\lambda$ in $1/\\mathrm{s}$, deterministic interarrival times equal to $1/\\lambda$ seconds, and Erlang-$2$ interarrival times (Gamma with shape parameter $2$ and rate parameter adjusted to give mean $1/\\lambda$ seconds).\n- Uses a warm-up of $N_{\\mathrm{warm}}$ arrivals to reduce transient bias, then collects statistics over the next $N$ arrivals.\n\nDefine the empirical time-average distribution and the empirical arrival-epoch distribution over states as follows. For any integer state $k \\ge 0$:\n- The empirical time-average probability is\n$$\n\\hat{p}_k^{\\mathrm{time}} = \\frac{1}{T_{\\mathrm{obs}}} \\int_{t_0}^{t_0 + T_{\\mathrm{obs}}} \\mathbf{1}\\{Q(t) = k\\}\\, dt,\n$$\nwhere $t_0$ is the time at which data collection starts (immediately after the warm-up ends) and $T_{\\mathrm{obs}}$ is the total observation time in seconds accumulated during the $N$ arrivals used for data collection.\n- The empirical arrival-epoch probability is\n$$\n\\hat{p}_k^{\\mathrm{arr}} = \\frac{1}{N} \\sum_{n=1}^{N} \\mathbf{1}\\{Q(T_{n,\\mathrm{obs}}^-) = k\\},\n$$\nwhere $T_{n,\\mathrm{obs}}$ is the time of the $n$-th arrival counted in the observation window (i.e., after the warm-up).\n\nTo quantify agreement between the two empirical distributions, compute the $\\ell_1$ distance defined as\n$$\nD = \\sum_{k \\in \\mathcal{K}} \\left| \\hat{p}_k^{\\mathrm{time}} - \\hat{p}_k^{\\mathrm{arr}} \\right|,\n$$\nwhere $\\mathcal{K}$ is the union of states observed either in time-average measurement or at arrival epochs during the observation window. $D$ is dimensionless.\n\nTask 3 (Explain failure conditions): Explain, in terms of fundamental stochastic principles, when and why PASTA fails for non-Poisson arrival processes.\n\nPhysical and numerical units: Time must be treated in seconds, arrival rates $\\lambda$ and service rates $\\mu$ in $1/\\mathrm{s}$. All output values must be dimensionless real numbers.\n\nTest suite and required output:\nUse the following three test cases, each specified by $(\\text{arrival type}, \\lambda, \\mu, N_{\\mathrm{warm}}, N, \\text{seed})$, with time expressed in seconds and rates in $1/\\mathrm{s}$:\n1. Case $1$: $(\\text{Poisson}, \\lambda = 0.8, \\mu = 1.0, N_{\\mathrm{warm}} = 10000, N = 100000, \\text{seed} = 12345)$.\n2. Case $2$: $(\\text{Poisson}, \\lambda = 0.95, \\mu = 1.0, N_{\\mathrm{warm}} = 10000, N = 100000, \\text{seed} = 54321)$.\n3. Case $3$: $(\\text{Deterministic}, \\lambda = 0.8, \\mu = 1.0, N_{\\mathrm{warm}} = 10000, N = 100000, \\text{seed} = 67890)$.\n\nFor the Erlang-$2$ interarrival option, the shape is $2$ and the rate is chosen so the mean interarrival time is $1/\\lambda$ seconds; however, this option is not used in the test suite and is provided to generalize your implementation.\n\nYour program should produce a single line of output containing the $\\ell_1$ distances $D$ for the three cases in the given order, as a comma-separated list enclosed in square brackets, for example, $[d_1,d_2,d_3]$. Each $d_i$ must be a floating-point number. No additional text should be printed.", "solution": "The user has provided a multi-part problem concerning the Poisson Arrivals See Time Averages (PASTA) property in queueing theory. The tasks involve a formal statement of the property, the design and implementation of a stochastic simulation to verify it empirically, and an explanation for its failure under non-Poisson arrival conditions. The problem is well-defined, scientifically sound, and internally consistent.\n\n### Task 1: Formal Statement of the PASTA Property\n\nThe PASTA property is a fundamental result in queueing theory that connects the perspective of an outside observer watching the system at a random moment in time with the perspective of a customer arriving at the system. It applies specifically to systems with a Poisson arrival process.\n\nFormally, let $Q(t)$ be the number of customers in the system at time $t$. The long-run time-average (or steady-state) probability that the system is in state $k$ is given by:\n$$\n\\pi_k = \\lim_{t \\to \\infty} P(Q(t) = k)\n$$\nprovided this limit exists.\n\nNow, consider the sequence of arrival times $\\{T_n\\}_{n \\ge 1}$. Let $Q(T_n^-)$ be the number of customers in the system as seen by the $n$-th arrival, evaluated at the left-limit just before the arrival occurs. The long-run arrival-epoch probability that an arriving customer finds the system in state $k$ is given by:\n$$\na_k = \\lim_{n \\to \\infty} P(Q(T_n^-) = k)\n$$\nprovided this limit exists.\n\nThe PASTA property states that if the arrival process is a Poisson process, then the two distributions are identical:\n$$\na_k = \\pi_k \\quad \\text{for all states } k \\ge 0\n$$\nIn essence, **P**oisson **A**rrivals **S**ee **T**ime **A**verages. This equivalence arises from the memoryless property of the Poisson process. The probability of an arrival occurring in a small interval $(t, t+dt]$ is $\\lambda dt$, independent of the history of the process and, critically, independent of the current state of the system $Q(t)$. Therefore, arrivals do not \"time\" themselves to coincide with periods of high or low congestion; they effectively sample the system state at truly random moments, yielding the same statistical distribution as a continuous-time observer.\n\n### Task 2: Simulation Design and Implementation\n\nTo empirically investigate the PASTA property, we will construct an event-driven simulation of a single-server queue.\n\n**Core Components of the Simulation:**\n1.  **Simulation Clock ($t_{sim}$):** A variable that tracks the current time in the simulation. It does not advance continuously but jumps from one event time to the next.\n2.  **System State ($N_{sys}$):** An integer variable representing the number of customers in the system, $Q(t)$.\n3.  **Event List (EL):** A priority queue that stores future events, ordered by their scheduled time of occurrence. Each event is a tuple `(event_time, event_type)`, e.g., $(1.23, \\text{ARRIVAL})$.\n\n**Event-Driven Algorithm:**\nThe simulation proceeds by repeatedly executing the following steps:\n1.  Extract the next chronological event from the Event List.\n2.  Advance the simulation clock $t_{sim}$ to the time of this event.\n3.  Update statistics based on the time elapsed since the last event.\n4.  Process the event, which involves changing the system state $N_{sys}$ and scheduling new, future events.\n\n**Event Handling Logic:**\n-   **ARRIVAL Event:**\n    1.  Collect arrival-epoch statistics if within the observation window: record the system state $N_{sys}$ just before this new arrival is added.\n    2.  Increment the system state: $N_{sys} \\leftarrow N_{sys} + 1$.\n    3.  If the system was previously empty ($N_{sys}$ was $0$), the arriving customer immediately enters service. A new DEPARTURE event is scheduled for time $t_{sim} + \\text{service_time}$, where the service time is a random variate drawn from an exponential distribution with rate $\\mu$.\n    4.  Schedule the next ARRIVAL event at time $t_{sim} + \\text{interarrival_time}$. The interarrival time is a random variate drawn from the specified arrival process distribution (Exponential for Poisson, a constant for Deterministic, or Gamma for Erlang).\n\n-   **DEPARTURE Event:**\n    1.  Decrement the system state: $N_{sys} \\leftarrow N_{sys} - 1$.\n    2.  If customers are still waiting in the queue ($N_{sys}  0$), the next customer in line immediately enters service. A new DEPARTURE event is scheduled for time $t_{sim} + \\text{service_time}$.\n\n**Statistics Collection:**\nThe simulation runs for $N_{\\mathrm{warm}}$ arrivals (warm-up phase) to mitigate transient bias, followed by $N$ arrivals (observation phase).\n-   **Warm-up Phase:** The simulation runs, but no statistics are collected.\n-   **Observation Phase:** This phase begins at the time of the $(N_{\\mathrm{warm}}+1)$-th arrival, let's call it $t_0$, and ends at the time of the $(N_{\\mathrm{warm}}+N)$-th arrival, let's call it $t_f$. The total observation time is $T_{\\mathrm{obs}} = t_f - t_0$.\n    -   **Empirical Arrival-Epoch Probability ($\\hat{p}_k^{\\mathrm{arr}}$):** For each of the $N$ arrivals within the observation phase, we record the system state $N_{sys}$ at the instant of arrival. We maintain a count, $C_k^{\\mathrm{arr}}$, for each state $k$. After the simulation, $\\hat{p}_k^{\\mathrm{arr}} = C_k^{\\mathrm{arr}} / N$.\n    -   **Empirical Time-Average Probability ($\\hat{p}_k^{\\mathrm{time}}$):** We maintain an array or dictionary, $T_k^{\\mathrm{state}}$, which stores the total time the system has spent in each state $k$. Whenever an event occurs at time $t_{new}$, the time elapsed since the previous event at $t_{old}$, which is $\\Delta t = t_{new} - t_{old}$, is added to the entry for the state that was active during that interval. After the simulation, $\\hat{p}_k^{\\mathrm{time}} = T_k^{\\mathrm{state}} / T_{\\mathrm{obs}}$.\n\n**Quantifying Agreement:**\nThe discrepancy between the two empirical distributions is measured by the $\\ell_1$ distance:\n$$\nD = \\sum_{k \\in \\mathcal{K}} \\left| \\hat{p}_k^{\\mathrm{time}} - \\hat{p}_k^{\\mathrm{arr}} \\right|\n$$\nwhere $\\mathcal{K}$ is the set of all unique states observed during the simulation's observation phase. A value of $D$ near $0$ indicates strong agreement, empirically confirming the PASTA property.\n\n### Task 3: Failure of PASTA for Non-Poisson Arrivals\n\nThe PASTA property fails for non-Poisson arrival processes because such processes possess \"memory,\" which creates a statistical correlation between the arrival instants and the state of the queueing system. An arriving customer's view is no longer a \"random sample\" of the system's evolution.\n\n**Mechanism of Failure:**\nThe key is the distribution of interarrival times. For a Poisson process, interarrival times follow an exponential distribution, which is memoryless. For any other renewal process, the interarrival time distribution is not memoryless. This lack of memorylessness is what invalidates PASTA. We can analyze this through the squared coefficient of variation of the interarrival times, $c_A^2$.\n-   **Poisson Process:** The exponential distribution has $c_A^2 = 1$. This is the PASTA case.\n-   **Less Variable Arrivals ($c_A^2  1$):** This includes **Deterministic** arrivals ($c_A^2=0$) and **Erlang** arrivals ($c_A^2 = 1/k  1$ for Erlang-$k$). These processes are more \"regular\" or \"orderly\" than a Poisson process. The regularity tends to space out arrivals, giving the server more opportunity to complete service and reduce the queue length between successive arrivals. Consequently, an arrival is more likely to find the system in a less congested state (or empty) compared to an observer arriving at a random moment in time. This leads to an \"arrival-time bias\" where the arrival-epoch distribution is skewed towards lower queue lengths: $a_k  \\pi_k$ for small $k$ and $a_k  \\pi_k$ for large $k$. Therefore, $a_k \\ne \\pi_k$.\n-   **More Variable Arrivals ($c_A^2  1$):** This includes hyperexponential arrivals. These processes are more \"bursty\" than Poisson. Arrivals tend to come in clumps. An arrival is likely to occur shortly after a previous one, before the server has had time to clear the work. This means an arrival is more likely to find the system in a more congested state than a random-time observer would. In this case, the arrival-epoch distribution is skewed towards higher queue lengths: $a_k  \\pi_k$ for small $k$ and $a_k  \\pi_k$ for large $k$. Again, $a_k \\ne \\pi_k$.\n\nIn summary, any deviation from the memoryless property of the Poisson process (quantified by $c_A^2 \\ne 1$) introduces a dependency between the arrival stream and the system state, causing PASTA to fail. The simulation for the deterministic case (Case 3) is expected to yield a non-negligible $\\ell_1$ distance $D$, demonstrating this failure.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\nfrom collections import defaultdict\n\ndef simulate_queue(arrival_type, lam, mu, n_warm, n_obs, seed):\n    \"\"\"\n    Simulates a single-server FCFS queue and calculates the L1 distance\n    between time-average and arrival-epoch state distributions.\n    \n    Args:\n        arrival_type (str): 'poisson', 'deterministic', or 'erlang2'.\n        lam (float): Arrival rate.\n        mu (float): Service rate.\n        n_warm (int): Number of warm-up arrivals.\n        n_obs (int): Number of observation arrivals.\n        seed (int): Seed for the random number generator.\n        \n    Returns:\n        float: The L1 distance D.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n\n    def generate_interarrival_time():\n        if arrival_type == 'poisson':\n            return rng.exponential(scale=1.0 / lam)\n        elif arrival_type == 'deterministic':\n            return 1.0 / lam\n        elif arrival_type == 'erlang2':\n            # Erlang-2 is Gamma with shape=2. Mean = shape/rate.\n            # We want mean = 1/lam, so 2/rate = 1/lam - rate = 2*lam.\n            # Numpy's scale is 1/rate.\n            return rng.gamma(shape=2, scale=1.0 / (2.0 * lam))\n        else:\n            raise ValueError(\"Unknown arrival type\")\n\n    def generate_service_time():\n        return rng.exponential(scale=1.0 / mu)\n\n    # Simulation state variables\n    current_time = 0.0\n    last_event_time = 0.0\n    num_in_system = 0\n    event_list = []\n\n    # Statistics collectors\n    time_in_state = defaultdict(float)\n    arrivals_at_state = defaultdict(int)\n    \n    # Simulation control\n    num_arrivals_processed = 0\n    total_arrivals_to_process = n_warm + n_obs\n    \n    t_start_obs = 0.0\n    t_end_obs = 0.0\n\n    # Schedule the first arrival\n    heapq.heappush(event_list, (generate_interarrival_time(), 'ARRIVAL'))\n\n    while event_list:\n        event_time, event_type = heapq.heappop(event_list)\n        \n        # Calculate time delta since last event\n        dt = event_time - last_event_time\n        \n        # If in observation phase, update time-in-state statistics\n        # The check `num_arrivals_processed = n_warm` ensures we only collect\n        # stats after the warmup phase is completed.\n        if num_arrivals_processed = n_warm and dt  0:\n            time_in_state[num_in_system] += dt\n\n        current_time = event_time\n        last_event_time = event_time\n        \n        # --- Event Processing ---\n        if event_type == 'ARRIVAL':\n            # Collect arrival-epoch stats if in observation period\n            if num_arrivals_processed = n_warm:\n                arrivals_at_state[num_in_system] += 1\n\n            # Update state\n            num_in_system += 1\n            \n            # If server was idle, start service and schedule a departure\n            if num_in_system == 1:\n                departure_time = current_time + generate_service_time()\n                heapq.heappush(event_list, (departure_time, 'DEPARTURE'))\n            \n            num_arrivals_processed += 1\n            \n            # Start of observation period\n            if num_arrivals_processed == n_warm:\n                t_start_obs = current_time\n            \n            # End of simulation run\n            if num_arrivals_processed == total_arrivals_to_process:\n                t_end_obs = current_time\n                break\n\n            # Schedule next arrival\n            next_arrival_time = current_time + generate_interarrival_time()\n            heapq.heappush(event_list, (next_arrival_time, 'ARRIVAL'))\n\n        elif event_type == 'DEPARTURE':\n            # Update state\n            num_in_system -= 1\n            \n            # If queue is not empty, start serving next customer\n            if num_in_system  0:\n                departure_time = current_time + generate_service_time()\n                heapq.heappush(event_list, (departure_time, 'DEPARTURE'))\n\n    # --- Post-Processing and Calculation of D ---\n    total_obs_time = t_end_obs - t_start_obs\n    \n    # Time-average probabilities\n    p_time = defaultdict(float)\n    if total_obs_time  0:\n        for k, T_k in time_in_state.items():\n            p_time[k] = T_k / total_obs_time\n            \n    # Arrival-epoch probabilities\n    p_arr = defaultdict(float)\n    if n_obs  0:\n        for k, C_k in arrivals_at_state.items():\n            p_arr[k] = C_k / n_obs\n            \n    # Calculate L1 distance\n    all_states = set(p_time.keys()) | set(p_arr.keys())\n    dist = 0.0\n    for k in all_states:\n        dist += abs(p_time[k] - p_arr[k])\n        \n    return dist\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'arrival_type': 'poisson', 'lam': 0.8, 'mu': 1.0, 'n_warm': 10000, 'n_obs': 100000, 'seed': 12345},\n        {'arrival_type': 'poisson', 'lam': 0.95, 'mu': 1.0, 'n_warm': 10000, 'n_obs': 100000, 'seed': 54321},\n        {'arrival_type': 'deterministic', 'lam': 0.8, 'mu': 1.0, 'n_warm': 10000, 'n_obs': 100000, 'seed': 67890},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = simulate_queue(**case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3343617"}, {"introduction": "A key task in system design and optimization is understanding not just the performance of a system, but its sensitivity to changes in system parameters. This advanced practice introduces the Likelihood Ratio (LR) method, a powerful technique for estimating the gradient of a performance measure from simulation runs. You will derive the LR \"weight\" from the underlying birth-death process of an M/M/1 queue and implement a Monte Carlo estimator for the derivative of system performance with respect to the arrival rate, $\\lambda$ [@problem_id:3343656]. This exercise demonstrates how simulation can move beyond estimating simple averages to provide the crucial gradient information needed for sophisticated optimization and sensitivity analysis tasks.", "problem": "You are to implement a complete, runnable program that estimates the sensitivity with respect to the arrival rate parameter of the expected long-run loss in an $M/M/1$ queue using the Likelihood Ratio (LR) method based on pathwise derivatives of the birth–death process likelihood. The problem must be solved from first principles in stochastic simulation and Monte Carlo methods. Consider an $M/M/1$ queueing system, which is a Continuous-Time Markov Chain (CTMC) with birth–death dynamics: arrivals follow a Poisson process with rate $\\lambda$ (events per second), service times are exponentially distributed with rate $\\mu$ (events per second), and the system state $X_t$ denotes the number of customers in the system at time $t$ (in seconds). The CTMC generator has off-diagonal transition rates $q_{i,i+1}=\\lambda$ and $q_{i,i-1}=\\mu$ for $i\\ge 1$, with $q_{0,-1}=0$, and diagonal elements $q_{i,i}=-q_i$ where $q_i=\\sum_{j\\ne i}q_{i,j}$. Assume $\\lambda\\mu$ to ensure stability and existence of the stationary distribution.\n\nStart from the core definition of the path likelihood of a CTMC parameterized by $(\\lambda,\\mu)$, and derive the pathwise LR weight as the derivative with respect to $\\lambda$ of the log-likelihood of a sample path over a fixed time horizon $[0,T]$. Use this weight to construct an unbiased LR estimator for the derivative with respect to $\\lambda$ of the expected time-average performance functional\n$$\nL_T \\;=\\; \\frac{1}{T}\\int_0^T g(X_t)\\,dt,\n$$\nwhere $g$ is a bounded measurable function of the system state. The LR estimator must be of the form\n$$\n\\widehat{\\nabla_\\lambda E[L_T]} \\;=\\; \\frac{1}{R}\\sum_{r=1}^R L_T^{(r)} \\, W^{(r)}(\\lambda)\n$$\nwhere $R$ is the number of independent replications, $L_T^{(r)}$ is the time-average functional of the $r$-th path, and $W^{(r)}(\\lambda)$ is the pathwise LR weight derived from the birth–death process likelihood over $[0,T]$. The LR estimator must be implemented by simulating the $M/M/1$ queue as a birth–death process with event-driven dynamics, maintaining the integral of $g(X_t)$ over time, and counting arrivals within $[0,T]$.\n\nYour program must:\n- Simulate the $M/M/1$ queue from $t=0$ to $t=T$ with units in seconds. Arrival and service rates $\\lambda$ and $\\mu$ are in events per second.\n- For each path, compute the integral $\\int_0^T g(X_t)\\,dt$ and the number of arrivals within $[0,T]$.\n- Construct the LR weight $W(\\lambda)$ by differentiating the path log-likelihood with respect to $\\lambda$ using the birth–death process representation.\n- Output the LR estimate of $\\frac{d}{d\\lambda}E[L_T]$ in seconds for each test case.\n\nFor verification, in addition to the LR estimate, also compute the known analytic derivative of the stationary expectation for two choices of $g$:\n1. $g(x)=x$ (the number in system). In steady state, $E[g(X)]=E[X]=\\frac{\\lambda}{\\mu-\\lambda}$ for $\\lambda\\mu$. Use this to obtain the analytic derivative $\\frac{d}{d\\lambda}E[X]$.\n2. $g(x)=\\mathbf{1}\\{x0\\}$ (the busy indicator). In steady state, $E[g(X)]=P\\{X0\\}=\\frac{\\lambda}{\\mu}$ for $\\lambda\\mu$. Use this to obtain the analytic derivative $\\frac{d}{d\\lambda}E[\\mathbf{1}\\{X0\\}]$.\n\nTime must be measured in seconds and the derivative values must be expressed in seconds. Your program should produce estimates by averaging over $R$ independent replications for each test case, and compare the LR estimate to the corresponding analytic derivative by reporting the absolute error.\n\nImplement the following test suite of parameter values, which cover light traffic, moderate traffic, and near-heavy traffic, and both choices of $g$:\n- Case 1 (moderate traffic, $g(x)=x$): $\\lambda=0.5$ events/second, $\\mu=1.0$ events/second, $T=1000$ seconds, $R=800$ replications.\n- Case 2 (light traffic, $g(x)=x$): $\\lambda=0.1$ events/second, $\\mu=1.0$ events/second, $T=2000$ seconds, $R=800$ replications.\n- Case 3 (near heavy traffic, $g(x)=x$): $\\lambda=0.95$ events/second, $\\mu=1.0$ events/second, $T=5000$ seconds, $R=500$ replications.\n- Case 4 (moderate traffic, $g(x)=\\mathbf{1}\\{x0\\}$): $\\lambda=0.8$ events/second, $\\mu=1.0$ events/second, $T=2000$ seconds, $R=500$ replications.\n- Case 5 (light traffic with faster service, $g(x)=\\mathbf{1}\\{x0\\}$): $\\lambda=0.2$ events/second, $\\mu=2.0$ events/second, $T=2000$ seconds, $R=800$ replications.\n\nFinal output format requirement:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets.\n- For each test case, output three floats in seconds, rounded to six decimal places, in the order: LR estimate, analytic derivative, absolute error. Concatenate these triples across all test cases into a single flat list. For example, an output line of the form\n$$\n[\\text{est}_1,\\text{analytic}_1,\\text{err}_1,\\text{est}_2,\\text{analytic}_2,\\text{err}_2,\\ldots]\n$$\nmust be printed, with all numbers in seconds and rounded to six decimal places.", "solution": "The problem requires the implementation of a Likelihood Ratio (LR) estimator for the sensitivity of an M/M/1 queue's performance with respect to its arrival rate, $\\lambda$. This will be accomplished by deriving the necessary estimator from first principles of stochastic processes and implementing an event-driven simulation. The results will be validated against known analytical formulas for the steady-state case.\n\n**1. Theoretical Framework**\n\nAn M/M/1 queue is a continuous-time Markov chain (CTMC) on the state space $S = \\{0, 1, 2, \\dots\\}$, where the state $X_t$ represents the number of customers in the system at time $t$. The system dynamics are governed by birth-death transition rates:\n-   Arrival (birth): $q_{i, i+1} = \\lambda$ for $i \\ge 0$.\n-   Service completion (death): $q_{i, i-1} = \\mu$ for $i \\ge 1$, with $q_{0,-1}=0$.\n\nThe total rate of leaving state $i$, $q_i$, is the sum of rates of all possible transitions out of $i$:\n-   $q_0 = \\lambda$\n-   $q_i = \\lambda + \\mu$ for $i \\ge 1$\n\nThe problem asks for the derivative of the expected time-average performance, $\\frac{d}{d\\lambda} E[L_T]$, where $L_T = \\frac{1}{T}\\int_0^T g(X_t) dt$. The Likelihood Ratio method is a general approach for estimating such derivatives. It relies on the identity:\n$$\n\\nabla_\\theta E_\\theta[H] = E_\\theta[H \\cdot \\nabla_\\theta \\log f_\\theta]\n$$\nwhere $f_\\theta$ is the probability density of the underlying random process, parameterized by $\\theta$. In our case, the parameter is $\\theta = \\lambda$, and $H = L_T$. The term $W(\\lambda) = \\nabla_\\lambda \\log f_\\lambda$ is the score function, or LR weight.\n\n**2. Derivation of the Likelihood Ratio Weight for an M/M/1 Path**\n\nTo find the LR weight $W(\\lambda)$, we must first establish the likelihood of a sample path of the M/M/1 process. A path observed over $[0, T]$ is defined by the initial state $x_0$, the sequence of subsequent states visited $x_1, \\dots, x_{N(T)}$, and the jump times $t_1, \\dots, t_{N(T)}$, where $N(T)$ is the total number of transitions in $[0, T]$.\n\nThe likelihood density function $\\mathcal{L}(\\text{path})$ for a CTMC path is given by the product of the probabilities of the observed state transitions and the probability densities of the sojourn times in each state:\n$$\n\\mathcal{L}(\\text{path}) = \\left( \\prod_{k=0}^{N(T)-1} q_{x_k, x_{k+1}} \\right) \\exp\\left( - \\int_0^T q_{X_s} ds \\right)\n$$\nThe corresponding log-likelihood, $\\ell = \\log \\mathcal{L}$, is:\n$$\n\\ell(\\lambda) = \\sum_{k=0}^{N(T)-1} \\log q_{x_k, x_{k+1}} - \\int_0^T q_{X_s} ds\n$$\nThe LR weight $W(\\lambda)$ is the derivative of the log-likelihood with respect to $\\lambda$:\n$$\nW(\\lambda) = \\frac{d\\ell(\\lambda)}{d\\lambda} = \\frac{d}{d\\lambda} \\left( \\sum_{k=0}^{N(T)-1} \\log q_{x_k, x_{k+1}} \\right) - \\frac{d}{d\\lambda} \\left( \\int_0^T q_{X_s} ds \\right)\n$$\nWe analyze each term separately:\n\na) The summation term involves derivatives of the transition rates $q_{i,j}$. The only transition rate that depends on $\\lambda$ is the arrival rate, $q_{i, i+1} = \\lambda$. The service rate $q_{i, i-1} = \\mu$ is independent of $\\lambda$. Thus, the derivative $\\frac{d}{d\\lambda}\\log q_{x_k, x_{k+1}}$ is non-zero only for arrival events:\n- If transition $k$ is an arrival: $q_{x_k, x_{k+1}} = \\lambda$, so $\\frac{d}{d\\lambda}\\log \\lambda = \\frac{1}{\\lambda}$.\n- If transition $k$ is a departure: $q_{x_k, x_{k+1}} = \\mu$, so $\\frac{d}{d\\lambda}\\log \\mu = 0$.\n\nLet $N_a(T)$ be the total number of arrivals in $[0, T]$. The summation term simplifies to:\n$$\n\\sum_{k=0}^{N(T)-1} \\frac{d}{d\\lambda}\\log q_{x_k, x_{k+1}} = \\frac{N_a(T)}{\\lambda}\n$$\n\nb) The integral term involves the derivative of the exit rates $q_i$:\n- For state $i=0$: $q_0 = \\lambda \\implies \\frac{dq_0}{d\\lambda} = 1$.\n- For state $i \\ge 1$: $q_i = \\lambda + \\mu \\implies \\frac{dq_i}{d\\lambda} = 1$.\n\nThe derivative of the exit rate with respect to $\\lambda$ is $1$ for any state $i \\ge 0$. Therefore:\n$$\n\\frac{d}{d\\lambda} \\left( \\int_0^T q_{X_s} ds \\right) = \\int_0^T \\frac{dq_{X_s}}{d\\lambda} ds = \\int_0^T 1 \\, ds = T\n$$\n\nCombining both parts, we obtain the LR weight for a path of the M/M/1 process over $[0, T]$:\n$$\nW(\\lambda) = \\frac{N_a(T)}{\\lambda} - T\n$$\nThis elegant result indicates that the score function depends only on the number of arrivals observed during the interval, the interval duration, and the arrival rate parameter.\n\n**3. LR Estimator and Simulation Algorithm**\n\nThe LR estimator for the sensitivity $\\frac{d}{d\\lambda}E[L_T]$ is constructed by averaging the product of the performance measure and the LR weight over $R$ independent replications:\n$$\n\\widehat{\\nabla_\\lambda E[L_T]} = \\frac{1}{R} \\sum_{r=1}^R L_T^{(r)} \\, W^{(r)}(\\lambda)\n$$\nwhere $L_T^{(r)}$ and $W^{(r)}(\\lambda)$ are computed from the $r$-th simulated path.\n\nThe simulation of a single M/M/1 path up to time $T$ proceeds via an event-driven algorithm, assuming an initial state of an empty system, $X_0=0$:\n1.  Initialize simulation time $t=0$, state $X=0$, accumulated performance integral $I_g = 0$, and arrival count $N_a=0$.\n2.  While $t  T$:\n    a.  Determine the current arrival rate $\\lambda_{arr} = \\lambda$ and service rate $\\lambda_{ser} = \\mu$ if $X  0$, else $0$. The total event rate is $\\lambda_{total} = \\lambda_{arr} + \\lambda_{ser}$.\n    b.  Generate the time until the next event, $\\Delta t$, from an exponential distribution with rate $\\lambda_{total}$.\n    c.  If $t + \\Delta t  T$, the simulation ends in this step. The time spent in the current state $X$ until $T$ is $T-t$. Update the integral: $I_g \\leftarrow I_g + g(X) \\cdot (T-t)$. Set $t=T$ and break the loop.\n    d.  Otherwise, update the integral for the time spent in the current state: $I_g \\leftarrow I_g + g(X) \\cdot \\Delta t$.\n    e.  Advance time: $t \\leftarrow t + \\Delta t$.\n    f.  Determine the event type. With probability $\\lambda_{arr}/\\lambda_{total}$, it is an arrival ($X \\leftarrow X+1$, $N_a \\leftarrow N_a+1$); otherwise, it is a service completion ($X \\leftarrow X-1$).\n3.  After the loop terminates, calculate the path performance $L_T = I_g / T$ and the LR weight $W(\\lambda) = N_a / \\lambda - T$. The product $L_T \\cdot W(\\lambda)$ is the sample for this replication.\n\n**4. Analytical Verification**\n\nFor large $T$, $E[L_T]$ approaches the steady-state expectation $E[g(X)]$. The simulation results will be compared against the analytical derivatives of these steady-state expectations. The stability condition $\\lambda  \\mu$ is assumed.\n\n1.  For $g(x) = x$, the performance measure is the average number of customers. The steady-state mean is $E[X] = \\frac{\\lambda}{\\mu-\\lambda}$. The derivative with respect to $\\lambda$ is:\n    $$\n    \\frac{d}{d\\lambda}E[X] = \\frac{d}{d\\lambda}\\left(\\frac{\\lambda}{\\mu-\\lambda}\\right) = \\frac{\\mu}{(\\mu-\\lambda)^2}\n    $$\n2.  For $g(x) = \\mathbf{1}\\{x0\\}$, the performance measure is the server utilization. The steady-state mean is $E[\\mathbf{1}\\{X0\\}] = P(X0) = \\frac{\\lambda}{\\mu}$. The derivative with respect to $\\lambda$ is:\n    $$\n    \\frac{d}{d\\lambda}E[\\mathbf{1}\\{X0\\}] = \\frac{d}{d\\lambda}\\left(\\frac{\\lambda}{\\mu}\\right) = \\frac{1}{\\mu}\n    $$\nThese formulas provide the benchmark values for assessing the accuracy of the LR estimator.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1 (moderate traffic, g(x)=x)\n        {'lambda_val': 0.5, 'mu_val': 1.0, 'T': 1000, 'R': 800, 'g_type': 'x'},\n        # Case 2 (light traffic, g(x)=x)\n        {'lambda_val': 0.1, 'mu_val': 1.0, 'T': 2000, 'R': 800, 'g_type': 'x'},\n        # Case 3 (near heavy traffic, g(x)=x)\n        {'lambda_val': 0.95, 'mu_val': 1.0, 'T': 5000, 'R': 500, 'g_type': 'x'},\n        # Case 4 (moderate traffic, g(x)=1{x0})\n        {'lambda_val': 0.8, 'mu_val': 1.0, 'T': 2000, 'R': 500, 'g_type': 'indicator'},\n        # Case 5 (light traffic with faster service, g(x)=1{x0})\n        {'lambda_val': 0.2, 'mu_val': 2.0, 'T': 2000, 'R': 800, 'g_type': 'indicator'},\n    ]\n\n    # Use a fixed seed for reproducibility.\n    rng = np.random.default_rng(seed=12345)\n    \n    results = []\n    for params in test_cases:\n        lambda_val = params['lambda_val']\n        mu_val = params['mu_val']\n        g_type = params['g_type']\n\n        lr_estimate = run_simulation(\n            lambda_val=lambda_val,\n            mu_val=mu_val,\n            T=params['T'],\n            R=params['R'],\n            g_type=g_type,\n            rng=rng\n        )\n\n        if g_type == 'x':\n            analytic_derivative = mu_val / (mu_val - lambda_val)**2\n        else:  # g_type == 'indicator'\n            analytic_derivative = 1.0 / mu_val\n        \n        abs_error = abs(lr_estimate - analytic_derivative)\n\n        results.extend([lr_estimate, analytic_derivative, abs_error])\n    \n    print(f\"[{','.join(f'{x:.6f}' for x in results)}]\")\n\ndef run_simulation(lambda_val: float, mu_val: float, T: int, R: int, g_type: str, rng: np.random.Generator):\n    \"\"\"\n    Runs R replications of the M/M/1 simulation and returns the LR estimate.\n    \"\"\"\n    if g_type == 'x':\n        g_func = lambda x: float(x)\n    elif g_type == 'indicator':\n        g_func = lambda x: 1.0 if x  0 else 0.0\n    else:\n        raise ValueError(\"Invalid g_type specified.\")\n        \n    path_products = []\n    for _ in range(R):\n        integral_g, n_arrivals = simulate_path(lambda_val, mu_val, T, g_func, rng)\n        \n        # Calculate performance measure L_T\n        L_T = integral_g / T\n        \n        # Calculate Likelihood Ratio weight W\n        W = n_arrivals / lambda_val - T\n        \n        # Product for this path\n        path_products.append(L_T * W)\n        \n    # The LR estimate is the mean of the products over all replications\n    return np.mean(path_products)\n\ndef simulate_path(lambda_val: float, mu_val: float, T: int, g_func, rng: np.random.Generator):\n    \"\"\"\n    Simulates a single path of the M/M/1 queue for time T.\n    Returns the performance integral and the number of arrivals.\n    \"\"\"\n    t = 0.0  # Current time\n    x = 0    # Number of customers in system\n    \n    integral_g = 0.0  # \\int_0^T g(X_t) dt\n    n_arrivals = 0    # Number of arrivals in [0, T]\n\n    while t  T:\n        if x == 0:\n            rate_arrival = lambda_val\n            rate_service = 0.0\n        else:\n            rate_arrival = lambda_val\n            rate_service = mu_val\n        \n        total_rate = rate_arrival + rate_service\n        \n        # Time to next event\n        dt = rng.exponential(scale=1.0 / total_rate)\n        \n        # If next event is after T, handle final interval and terminate\n        if t + dt  T:\n            time_in_state = T - t\n            integral_g += g_func(x) * time_in_state\n            break\n        \n        # Update integral for the time spent in the current state\n        time_in_state = dt\n        integral_g += g_func(x) * time_in_state\n        \n        # Advance time\n        t += dt\n        \n        # Determine event type\n        if rng.random()  rate_arrival / total_rate:\n            # Arrival\n            x += 1\n            n_arrivals += 1\n        else:\n            # Service completion\n            x -= 1\n            \n    return integral_g, n_arrivals\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "3343656"}]}