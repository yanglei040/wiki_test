{"hands_on_practices": [{"introduction": "A discrete-event simulation is fundamentally driven by the occurrence of random events over time. To build a valid model, we must be able to generate random variates that follow specific probability distributions, such as the exponential or geometric distributions often used to model interarrival times. This first practice focuses on the foundational inverse-transform method, a powerful and universal technique for this task. By deriving the sampling formulas from first principles and implementing them, you will gain a deep understanding of how to turn a simple stream of uniform random numbers into the stochastic engine for your simulations [@problem_id:3303686].", "problem": "Consider the task of generating interarrival times in discrete-event simulation for both a continuous-time arrival process and a discrete-time arrival process. The continuous-time process is modeled by the exponential distribution with rate parameter $\\lambda  0$, and the discrete-time process is modeled by the geometric distribution with success probability $p \\in (0,1]$ on the support $\\{1,2,3,\\dots\\}$, interpreted as the number of discrete time steps until the first arrival. You are to derive the inverse-transform sampling formulas starting from fundamental definitions and implement generation of these interarrival times using only a source of independent draws $U \\sim \\mathrm{Unif}(0,1)$.\n\nThe fundamental base consists of the following core definitions and facts:\n- The cumulative distribution function (CDF) $F_X(x)$ of a real-valued random variable $X$ is defined by $F_X(x) = \\mathbb{P}(X \\le x)$.\n- The inverse-transform sampling principle states that if $U \\sim \\mathrm{Unif}(0,1)$ and $F_X$ is a strictly increasing continuous CDF, then $X = F_X^{-1}(U)$ has CDF $F_X$. For a discrete distribution supported on positive integers, the inverse-transform sampling uses the quantile function $Q(u) = \\inf\\{k \\in \\mathbb{N} : F_X(k) \\ge u\\}$, where $\\mathbb{N} = \\{1,2,3,\\dots\\}$ with the specified support.\n- The exponential distribution with rate $\\lambda$ is the unique continuous distribution with the memoryless property; its distribution is characterized by the survival function $S(t) = \\mathbb{P}(T  t)$ satisfying $S(t+s) = S(t)S(s)$ and $S(0) = 1$, where $t \\ge 0$ and $s \\ge 0$, and the constant hazard rate $\\lambda$ implies $S(t) = \\exp(-\\lambda t)$ for $t \\ge 0$. The corresponding CDF $F(t)$ is strictly increasing on $[0,\\infty)$.\n- The geometric distribution on $\\{1,2,3,\\dots\\}$ with probability of success $p \\in (0,1]$ has probability mass function $\\mathbb{P}(K = k) = (1-p)^{k-1}p$ for $k \\in \\mathbb{N}$ and a nondecreasing CDF $F(k)$.\n\nTasks:\n1. Derive, from the above definitions and facts, the explicit inverse-transform sampling expressions needed to map independent draws $U \\sim \\mathrm{Unif}(0,1)$ to interarrival times for:\n   - The exponential distribution with rate $\\lambda$, producing real-valued interarrival times $T \\ge 0$.\n   - The geometric distribution with success probability $p$ on $\\{1,2,\\dots\\}$, producing integer-valued interarrival steps $K \\in \\mathbb{N}$.\n   Your derivations must start from the CDF definitions and the inverse-transform principle without using shortcut formulas.\n\n2. Implement a program that uses a Random Number Generator (RNG) seeded per test case to produce the required interarrival times by inverse-transform sampling. The program must not call any library function that directly samples from exponential or geometric distributions; it must use only independent draws $U \\sim \\mathrm{Unif}(0,1)$ and the derived formulas.\n\n3. For numerical stability in the presence of values $U$ close to $0$ or $1$ and values $p$ close to $0$ or $1$, your implementation should use stable transformations (for example, functions that compute $\\log(1-x)$ reliably for small $x$).\n\n4. Design and execute the following test suite. For each test case, generate exactly $n$ independent samples and output the list of generated interarrival times for that case:\n   - Test Case $1$: Exponential with $\\lambda = 1.5$, $n = 5$, seed $42$.\n   - Test Case $2$: Geometric with $p = 0.3$, $n = 5$, seed $123$.\n   - Test Case $3$: Exponential with $\\lambda = 0.01$, $n = 5$, seed $7$.\n   - Test Case $4$: Geometric with $p = 0.99$, $n = 10$, seed $99$.\n   - Test Case $5$: Geometric with $p = 1.0$, $n = 7$, seed $555$.\n   - Test Case $6$: Exponential with $\\lambda = 10.0$, $n = 8$, seed $2023$.\n\n5. Final Output Format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each result should be the list of generated interarrival times for the corresponding test case in the order listed above. For example, the output should have the form $[L_1,L_2,L_3,L_4,L_5,L_6]$, where $L_i$ is the list of $n$ generated values for test case $i$. All outputs must be unitless real numbers for exponential interarrivals and unitless integers for geometric interarrivals.", "solution": "The problem is valid as it is scientifically grounded in probability theory and stochastic simulation, well-posed with clear objectives and constraints, and formulated with objective, unambiguous language. The solution requires deriving and implementing the standard inverse-transform sampling method for the exponential and geometric distributions.\n\nThe derivation and implementation proceed in two parts, one for each distribution.\n\n### 1. Exponential Distribution Interarrival Times\n\nThe objective is to derive the formula for generating a random variable $T$ from an exponential distribution with rate parameter $\\lambda  0$, given a uniform random draw $U \\sim \\mathrm{Unif}(0,1)$.\n\nThe derivation begins with the fundamental properties of the exponential distribution. It is defined by its survival function, $S(t)$, which is the probability that the event has not occurred by time $t$. For an exponential process with a constant hazard rate $\\lambda$, the survival function is:\n$$ S(t) = \\mathbb{P}(T  t) = \\exp(-\\lambda t) \\quad \\text{for } t \\ge 0 $$\nThe cumulative distribution function (CDF), $F(t)$, is the probability that the event has occurred by time $t$. It is related to the survival function by $F(t) = \\mathbb{P}(T \\le t) = 1 - \\mathbb{P}(T  t)$.\nSubstituting the expression for $S(t)$:\n$$ F(t) = 1 - \\exp(-\\lambda t) $$\nThe inverse-transform sampling principle states that if $U$ is a random variable uniformly distributed on $(0,1)$, then the random variable $X = F_X^{-1}(U)$ has the CDF $F_X$. For the exponential distribution, we set $U = F(T)$ and solve for $T$:\n$$ U = 1 - \\exp(-\\lambda T) $$\nWe rearrange the equation to isolate $T$:\n$$ \\exp(-\\lambda T) = 1 - U $$\nTaking the natural logarithm of both sides gives:\n$$ \\ln(\\exp(-\\lambda T)) = \\ln(1 - U) $$\n$$ -\\lambda T = \\ln(1 - U) $$\nFinally, solving for $T$ yields the inverse-transform formula:\n$$ T = -\\frac{1}{\\lambda} \\ln(1 - U) $$\nSince $U$ is a $\\mathrm{Unif}(0,1)$ random variable, the variable $U' = 1 - U$ is also a $\\mathrm{Unif}(0,1)$ random variable. Therefore, the formula is often simplified to $T = -\\frac{1}{\\lambda} \\ln(U)$. However, for rigorous derivation from the CDF and for numerical stability considerations presented in the problem, we will proceed with the $T = -\\frac{1}{\\lambda} \\ln(1-U)$ form. When implementing this, a function that computes $\\ln(1-x)$ accurately for small $x$ (e.g., `log1p(-U)` for small `U`) should be used to maintain numerical precision, as suggested by the problem.\n\n### 2. Geometric Distribution Interarrival Steps\n\nThe objective is to derive the formula for generating a random variable $K$ from a geometric distribution with success probability $p \\in (0,1]$ on the support of positive integers $\\mathbb{N} = \\{1, 2, 3, \\dots\\}$.\n\nThe probability mass function (PMF) is given as:\n$$ \\mathbb{P}(K = k) = (1-p)^{k-1}p \\quad \\text{for } k \\in \\{1, 2, 3, \\dots\\} $$\nThe CDF, $F(k) = \\mathbb{P}(K \\le k)$, is the sum of the PMF from $j=1$ to $k$:\n$$ F(k) = \\sum_{j=1}^{k} (1-p)^{j-1}p $$\nThis is a finite geometric series. Let $q = 1-p$. The sum is:\n$$ F(k) = p \\sum_{j=1}^{k} q^{j-1} = p \\left( \\frac{1 - q^k}{1 - q} \\right) $$\nSubstituting $q = 1-p$ back into the denominator:\n$$ F(k) = p \\left( \\frac{1 - (1-p)^k}{1 - (1-p)} \\right) = p \\left( \\frac{1 - (1-p)^k}{p} \\right) = 1 - (1-p)^k $$\nFor a discrete distribution, the inverse-transform method uses the quantile function $Q(u) = \\inf\\{k \\in \\mathbb{N} : F(k) \\ge u\\}$. We set $U \\sim \\mathrm{Unif}(0,1)$ and find the smallest integer $K$ that satisfies the inequality:\n$$ F(K) \\ge U $$\n$$ 1 - (1-p)^K \\ge U $$\nRearranging the inequality:\n$$ 1 - U \\ge (1-p)^K $$\nTo solve for $K$, we take the natural logarithm of both sides. Since $p \\in (0,1]$, we have $1-p \\in [0,1)$. The natural logarithm $\\ln(x)$ is an increasing function for $x0$. Thus, for $1-p \\in (0,1)$, we have $\\ln(1-p)  0$.\nTaking logs:\n$$ \\ln(1 - U) \\ge \\ln((1-p)^K) $$\n$$ \\ln(1 - U) \\ge K \\ln(1-p) $$\nTo isolate $K$, we must divide by $\\ln(1-p)$. Since this term is negative, we must reverse the inequality sign:\n$$ \\frac{\\ln(1 - U)}{\\ln(1-p)} \\le K $$\nSo, $K$ must be an integer greater than or equal to $\\frac{\\ln(1 - U)}{\\ln(1-p)}$. The smallest such integer is given by the ceiling function:\n$$ K = \\left\\lceil \\frac{\\ln(1 - U)}{\\ln(1-p)} \\right\\rceil $$\nThis is the required formula for $p \\in (0,1)$.\n\nFor the special case $p = 1$, the PMF is $\\mathbb{P}(K=1) = 1$ and $\\mathbb{P}(K=k) = 0$ for $k  1$. The CDF is $F(k)=1$ for all $k \\ge 1$. The condition $\\inf\\{k \\in \\mathbb{N} : F(k) \\ge U\\}$ becomes $\\inf\\{k \\in \\mathbb{N} : 1 \\ge U\\}$, which is always $1$ for any $U \\in (0,1)$. Thus, for $p=1$, $K=1$. The formula would involve $\\ln(0)$, so this case should be handled separately in implementation.\n\nFor numerical stability, especially when $p$ is small, the terms $\\ln(1-U)$ and $\\ln(1-p)$ should be calculated using functions like `log1p` to avoid loss of precision.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by generating interarrival times for exponential and\n    geometric distributions using the inverse-transform method.\n    \"\"\"\n    test_cases = [\n        {'type': 'exp', 'params': {'lambda': 1.5, 'n': 5, 'seed': 42}},\n        {'type': 'geom', 'params': {'p': 0.3, 'n': 5, 'seed': 123}},\n        {'type': 'exp', 'params': {'lambda': 0.01, 'n': 5, 'seed': 7}},\n        {'type': 'geom', 'params': {'p': 0.99, 'n': 10, 'seed': 99}},\n        {'type': 'geom', 'params': {'p': 1.0, 'n': 7, 'seed': 555}},\n        {'type': 'exp', 'params': {'lambda': 10.0, 'n': 8, 'seed': 2023}},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        case_type = case['type']\n        params = case['params']\n        n = params['n']\n        seed = params['seed']\n        \n        # Create a new Random Number Generator for each case with the specified seed\n        rng = np.random.default_rng(seed)\n        \n        # Generate n independent draws from Unif(0,1)\n        # The numpy.random.random() function generates numbers in the interval [0.0, 1.0)\n        # For the derivation F^{-1}(U), U should be in (0,1).\n        # A value of U=0 is possible. For exponential, log1p(-0) = 0, T=0.\n        # For geometric, log1p(-0)/log1p(-p) = 0, ceil(0)=0. However, support starts at 1.\n        # The quantile formula inf{k: F(k)=u} handles u=0 correctly if F(k) are positive. F(0)=0.\n        # We will proceed with U in [0,1) as generated by rng.random().\n        \n        U = rng.random(size=n)\n        \n        if case_type == 'exp':\n            lambda_val = params['lambda']\n            # Using T = -(1/lambda) * log(1-U), implemented with numerically stable log1p(-U)\n            # This handles U near 0 gracefully.\n            samples = -(1/lambda_val) * np.log1p(-U)\n            # Convert to a standard Python list for formatting\n            samples_list = samples.tolist()\n\n        elif case_type == 'geom':\n            p_val = params['p']\n            \n            # Handle the special case p=1.0\n            if p_val == 1.0:\n                # Interarrival time is always 1\n                samples = np.ones(n, dtype=int)\n            else:\n                # Using K = ceil(log(1-U)/log(1-p))\n                # Both logarithms are implemented with numerically stable log1p\n                numerator = np.log1p(-U)\n                denominator = np.log1p(-p_val)\n                samples = np.ceil(numerator / denominator)\n                # The result must be integer-valued. A result of 0 is possible if U is very\n                # close to 0 but not exactly 0. The support is {1,2,...}.\n                # If U=0, num=0, ratio=0, ceil(0)=0. We should ensure results are = 1.\n                # The quantile function is inf{k = 1}, so 0 is not a valid output.\n                # If U == 0, the inequality F(k) = 0 is solved by k=1 for any p1.\n                # So the result should be 1.\n                samples[samples == 0] = 1\n                samples = samples.astype(int)\n\n            # Convert to a standard Python list for formatting\n            samples_list = samples.tolist()\n\n        # Format the list of numbers into a string '[v1,v2,...]' without spaces\n        formatted_list = f\"[{','.join(map(str, samples_list))}]\"\n        all_results.append(formatted_list)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "3303686"}, {"introduction": "With the tools to generate random events, we can now construct the core of a simulator: the engine that processes events in chronological order and updates the system's state. This exercise guides you through building a next-event simulation for a basic $GI/G/1$ single-server queue. By using predetermined sequences for interarrival and service times, you can isolate and master the fundamental time-advance mechanism and state-update logic, which form the heart of any discrete-event simulation program [@problem_id:3303619].", "problem": "You are to implement a next-event discrete-event simulation of a single-server queueing system of type $GI/G/1$ (General Independent arrival process / General service time / single server) under First-Come-First-Served (FCFS) discipline, using scheduled arrivals formed by a specified finite sequence of interarrival times and a specified finite sequence of service times. The goal is to compute the empirical waiting time distribution of the customers in the system for each provided test case.\n\nFundamental base and definitions: The $GI/G/1$ queue is defined by an arrival process where interarrival times are independent and possibly non-identically distributed, and service times are independent and possibly non-identically distributed. For a given finite sequence of interarrival times $\\{a_1, a_2, \\ldots, a_n\\}$ and a finite sequence of service times $\\{s_1, s_2, \\ldots, s_n\\}$, the scheduled arrival times are constructed by the cumulative sum $t_k = \\sum_{i=1}^{k} a_i$ for each $k \\in \\{1,2,\\ldots,n\\}$. The server serves one customer at a time under the FCFS discipline. The waiting time $w_k$ of customer $k$ is the duration between the scheduled arrival time $t_k$ and the time their service begins. Service completion times and resulting queue states are determined by event scheduling.\n\nEvent handling policy: If an arrival event and a departure event are scheduled at the same time, process the departure event first before the arrival event. This tie-breaking rule ensures that an arrival at time $t$ that coincides with a scheduled departure at time $t$ observes the server as idle and can begin service immediately.\n\nImplementation requirement: You must implement a next-event simulation that:\n- Initializes the system at time $0$ with the server idle and an empty queue.\n- Processes events in nondecreasing time order, always jumping the simulation clock to the time of the next event.\n- Upon an arrival at time $t_k$, if the server is idle, the customer’s service begins at time $t_k$; otherwise, the customer joins the queue.\n- Upon a departure, if the queue is nonempty, the next customer in FCFS order begins service immediately at the departure time; otherwise, the server becomes idle.\n- Records the waiting time $w_k$ for each of the $n$ customers as the time their service begins minus $t_k$.\n\nEmpirical distribution requirement: For a given finite list of thresholds $\\{x_1, x_2, \\ldots, x_m\\}$, compute the empirical cumulative distribution function (ECDF) of waiting times at each threshold, defined by\n$$\\hat{F}(x_j) = \\frac{1}{n} \\sum_{k=1}^{n} \\mathbf{1}\\{w_k \\le x_j\\}, \\quad j = 1,2,\\ldots,m,$$\nwhere $\\mathbf{1}\\{\\cdot\\}$ is the indicator function. All time quantities are measured in arbitrary consistent time units, and the empirical cumulative probabilities must be expressed as decimals.\n\nTest suite: Your program must compute the ECDF values for the following four parameter sets. For each test case, use the interarrival sequence, service sequence, and thresholds as specified. All numbers are to be treated as exact real values.\n\n- Test case $1$ (moderate variability, typical load):\n  Interarrival times $\\,[1.0,\\,0.4,\\,0.8,\\,1.5,\\,0.7]$,\n  Service times $\\,[0.5,\\,1.2,\\,0.3,\\,0.6,\\,0.9]$,\n  Thresholds $\\,[0.0,\\,0.2,\\,0.5,\\,1.0]$.\n\n- Test case $2$ (high load, sustained queueing):\n  Interarrival times $\\,[0.2,\\,0.2,\\,0.2,\\,0.2,\\,0.2,\\,0.2]$,\n  Service times $\\,[0.5,\\,0.7,\\,0.4,\\,0.6,\\,0.8,\\,0.9]$,\n  Thresholds $\\,[0.0,\\,0.5,\\,1.0,\\,1.5]$.\n\n- Test case $3$ (idle gaps and short bursts, many zero waits):\n  Interarrival times $\\,[3.0,\\,0.1,\\,5.0,\\,0.2]$,\n  Service times $\\,[0.5,\\,0.4,\\,0.3,\\,0.2]$,\n  Thresholds $\\,[0.0,\\,0.1,\\,0.4,\\,0.8]$.\n\n- Test case $4$ (boundary behavior with zero service times):\n  Interarrival times $\\,[1.0,\\,1.0,\\,1.0]$,\n  Service times $\\,[0.0,\\,0.0,\\,0.0]$,\n  Thresholds $\\,[0.0,\\,0.001]$.\n\nOutput specification: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must be flat and must concatenate, in order, the ECDF values for each test case arranged by the thresholds in the order they appear. That is, if the ECDF values for test case $i$ at its thresholds are $\\,[v_{i,1},\\,v_{i,2},\\,\\ldots,\\,v_{i,m_i}]$, then the final output must be\n$$[v_{1,1},\\,v_{1,2},\\,\\ldots,\\,v_{1,m_1},\\,v_{2,1},\\,\\ldots,\\,v_{2,m_2},\\,v_{3,1},\\,\\ldots,\\,v_{3,m_3},\\,v_{4,1},\\,\\ldots,\\,v_{4,m_4}].$$", "solution": "The user wants to simulate a $GI/G/1$ queue.\n\n### Step 1: Extract Givens\n- **System Model**: Single-server queueing system specified as $GI/G/1$ (General Independent arrival process, General service time, one server).\n- **Service Discipline**: First-Come-First-Served (FCFS).\n- **Input Data**: A finite sequence of interarrival times $\\{a_1, a_2, \\ldots, a_n\\}$ and a finite sequence of service times $\\{s_1, s_2, \\ldots, s_n\\}$.\n- **Arrival Time Definition**: Scheduled arrival time for customer $k$ is $t_k = \\sum_{i=1}^{k} a_i$.\n- **Waiting Time Definition**: The waiting time $w_k$ for customer $k$ is the duration between the scheduled arrival time $t_k$ and the time their service begins.\n- **Initial Conditions**: At time $t=0$, the server is idle and the queue is empty.\n- **Event Handling Tie-Breaking Rule**: If an arrival event and a departure event are scheduled at the same time, the departure event is processed first.\n- **Output Requirement**: Compute the empirical cumulative distribution function (ECDF) of waiting times, $\\hat{F}(x_j) = \\frac{1}{n} \\sum_{k=1}^{n} \\mathbf{1}\\{w_k \\le x_j\\}$, for given sets of thresholds $\\{x_j\\}$.\n- **Test Cases**:\n    - **Test Case 1**:\n        - Interarrival times: $[1.0, 0.4, 0.8, 1.5, 0.7]$\n        - Service times: $[0.5, 1.2, 0.3, 0.6, 0.9]$\n        - Thresholds: $[0.0, 0.2, 0.5, 1.0]$\n    - **Test Case 2**:\n        - Interarrival times: $[0.2, 0.2, 0.2, 0.2, 0.2, 0.2]$\n        - Service times: $[0.5, 0.7, 0.4, 0.6, 0.8, 0.9]$\n        - Thresholds: $[0.0, 0.5, 1.0, 1.5]$\n    - **Test Case 3**:\n        - Interarrival times: $[3.0, 0.1, 5.0, 0.2]$\n        - Service times: $[0.5, 0.4, 0.3, 0.2]$\n        - Thresholds: $[0.0, 0.1, 0.4, 0.8]$\n    - **Test Case 4**:\n        - Interarrival times: $[1.0, 1.0, 1.0]$\n        - Service times: $[0.0, 0.0, 0.0]$\n        - Thresholds: $[0.0, 0.001]$\n- **Output Format**: A single line containing a comma-separated list of all ECDF values from all test cases, concatenated in order, enclosed in square brackets.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem describes the simulation of a $GI/G/1$ queue, a canonical model in queueing theory and stochastic simulation. The methodology proposed (next-event simulation) and the quantities to be computed (waiting times, ECDF) are standard and well-defined. All concepts are firmly based on established principles of mathematics and operations research.\n- **Well-Posed**: The problem is well-posed. Given finite, deterministic sequences of interarrival and service times, the system's evolution is deterministic. A unique sequence of waiting times exists for each test case, leading to a unique ECDF. All necessary parameters and initial conditions are provided.\n- **Objective**: The problem is stated in precise, objective language. Key terms like waiting time, FCFS discipline, and the tie-breaking rule are explicitly defined, leaving no room for ambiguity.\n- **Overall Assessment**: The problem does not violate any of the invalidity criteria. It is a complete, consistent, and scientifically sound problem in the domain of discrete-event simulation.\n\n### Step 3: Verdict and Action\nThe problem is valid. A solution will be provided.\n\nThe problem requires the implementation of a next-event simulation for a single-server queue ($GI/G/1$) with a First-Come-First-Served (FCFS) discipline. The simulation's objective is to compute the empirical waiting time distribution for a finite set of $n$ customers whose interarrival and service times are predetermined.\n\nThe core principle of this discrete-event simulation is to track the state of the system over time. For a single-server queue, the most critical state variable is the time at which the server becomes available. Let's denote this variable as $T_{free}$. The simulation clock does not advance at fixed increments but jumps from one event to the next. Since the arrival times are pre-scheduled, we can process customers sequentially from $k=1, 2, \\ldots, n$.\n\nThe simulation logic proceeds as follows:\n$1$. **Initialization**: The system starts with an empty queue and an idle server at time $t=0$. This is modeled by setting the initial server free time to $T_{free} = 0$. We also need to compute the absolute arrival times, $t_k$, for each customer $k$. Given the interarrival times $\\{a_1, a_2, \\ldots, a_n\\}$, the arrival time of the $k$-th customer is $t_k = \\sum_{i=1}^{k} a_i$. We can precompute these for all $k$.\n\n$2$. **Sequential Customer Processing**: We iterate through each customer $k$ from $1$ to $n$. For each customer $k$, with their arrival time $t_k$ and service time $s_k$, we determine their waiting time $w_k$.\n\n$3$. **Waiting Time Calculation**: A customer $k$ arriving at time $t_k$ can only begin service when two conditions are met: the customer has arrived, and the server is free. The server becomes free at time $T_{free}$ (from the previous customer, or initially $0$). Therefore, the service for customer $k$ will start at time $T_{start,k} = \\max(t_k, T_{free})$.\n\nThe waiting time, $w_k$, is defined as the time elapsed between the customer's arrival and the start of their service.\n$$w_k = T_{start,k} - t_k$$\nSubstituting the expression for $T_{start,k}$, we get:\n$$w_k = \\max(t_k, T_{free}) - t_k = \\max(0, T_{free} - t_k)$$\nThis expression correctly shows that a customer waits ($w_k  0$) only if they arrive before the server is free ($t_k  T_{free}$). The specified tie-breaking rule (departure before arrival) is naturally handled: if a customer arrives at the exact moment the server becomes free ($t_k = T_{free}$), their waiting time is $w_k = \\max(0, T_{free} - T_{free}) = 0$.\n\n$4$. **State Update**: Once customer $k$ begins service at $T_{start,k}$, the server will be busy for the duration of their service time, $s_k$. The server will thus become free again at the new time $T_{free, new} = T_{start,k} + s_k$. This updated value of $T_{free}$ is then used for the next customer, $k+1$. This iterative update forms the core of the simulation. For $k=1$, the initial $T_{free}$ is $0$, so $w_1 = \\max(0, 0 - t_1) = 0$, which is correct as the first customer never waits.\n\n$5$. **Empirical Distribution Calculation**: After iterating through all $n$ customers and recording their waiting times $\\{w_1, w_2, \\ldots, w_n\\}$, we compute the Empirical Cumulative Distribution Function (ECDF) at the given thresholds $\\{x_1, x_2, \\ldots, x_m\\}$. The ECDF, $\\hat{F}(x_j)$, is the fraction of customers whose waiting time was less than or equal to the threshold $x_j$.\n$$\\hat{F}(x_j) = \\frac{1}{n} \\sum_{k=1}^{n} \\mathbf{1}\\{w_k \\le x_j\\}$$\nwhere $\\mathbf{1}\\{\\cdot\\}$ is the indicator function, which is $1$ if the condition is true and $0$ otherwise. This is calculated for each provided threshold $x_j$ for each test case.\nThe entire process is deterministic for the given inputs and is implemented by sequentially applying these steps for each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a GI/G/1 queue simulation and computes ECDF of waiting times\n    for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"interarrivals\": [1.0, 0.4, 0.8, 1.5, 0.7],\n            \"services\": [0.5, 1.2, 0.3, 0.6, 0.9],\n            \"thresholds\": [0.0, 0.2, 0.5, 1.0]\n        },\n        {\n            \"interarrivals\": [0.2, 0.2, 0.2, 0.2, 0.2, 0.2],\n            \"services\": [0.5, 0.7, 0.4, 0.6, 0.8, 0.9],\n            \"thresholds\": [0.0, 0.5, 1.0, 1.5]\n        },\n        {\n            \"interarrivals\": [3.0, 0.1, 5.0, 0.2],\n            \"services\": [0.5, 0.4, 0.3, 0.2],\n            \"thresholds\": [0.0, 0.1, 0.4, 0.8]\n        },\n        {\n            \"interarrivals\": [1.0, 1.0, 1.0],\n            \"services\": [0.0, 0.0, 0.0],\n            \"thresholds\": [0.0, 0.001]\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        interarrivals = case[\"interarrivals\"]\n        services = case[\"services\"]\n        thresholds = case[\"thresholds\"]\n\n        num_customers = len(interarrivals)\n        \n        # 1. Calculate absolute arrival times from interarrival times.\n        arrival_times = np.cumsum(interarrivals)\n        \n        # 2. Simulate the queue to get waiting times for each customer.\n        waiting_times = np.zeros(num_customers)\n        server_free_time = 0.0\n        \n        for k in range(num_customers):\n            # Get arrival and service time for customer k.\n            t_k = arrival_times[k]\n            s_k = services[k]\n            \n            # Service begins at the maximum of arrival time and when the server is free.\n            service_start_time = max(t_k, server_free_time)\n            \n            # Waiting time is the delay between arrival and service start.\n            w_k = service_start_time - t_k\n            waiting_times[k] = w_k\n            \n            # Update the time the server will become free for the next customer.\n            server_free_time = service_start_time + s_k\n            \n        # 3. Compute the ECDF for the given thresholds.\n        n_float = float(num_customers)\n        for x_j in thresholds:\n            # Count customers with waiting time = threshold.\n            count = np.sum(waiting_times = x_j)\n            # ECDF is the fraction of such customers.\n            ecdf_value = count / n_float\n            all_results.append(ecdf_value)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3303619"}, {"introduction": "Real-world systems are rarely as simple as a single first-come-first-served queue. This final practice challenges you to model a more complex and realistic scenario: a multi-class system with a preemptive-resume priority discipline. Implementing this model requires integrating random variate generation and event scheduling while managing advanced dynamics such as preemption, multiple queues, and tracking remaining service times. This capstone exercise will solidify your ability to design and build flexible simulation models capable of capturing intricate system behaviors [@problem_id:3303670].", "problem": "You are tasked with designing and implementing a discrete-event simulation to study response time distributions for a single-server, multi-class queue operating under a preemptive-resume priority discipline. The system has multiple customer classes, with class-specific Poisson arrival processes and class-specific exponential service times. The scheduling rule is strictly priority-based with preemption and resume: at any instant, the server works on a job from the highest priority class present in the system; if a higher-priority job arrives while a lower-priority job is in service, the lower-priority job is preempted and its remaining service time is saved; when preempted jobs are eligible to resume, they do so before any later arrivals of the same class, and within each class the order is First-In, First-Out (FIFO). Your objective is to implement the simulation and compute empirical class-specific response time cumulative distribution functions evaluated on prescribed time grids.\n\nThe implementation must start from the following foundational base:\n- For each class $i$, arrivals follow a Poisson process with rate $\\lambda_i$, which implies that interarrival times are independent and identically distributed exponential random variables with rate parameter $\\lambda_i$, and hence mean $1/\\lambda_i$.\n- For each class $i$, service times are independent and identically distributed exponential random variables with rate parameter $\\mu_i$, and hence mean $1/\\mu_i$.\n- The response time for a job is defined as its departure time minus its arrival time, measured in seconds. Convert all time measurements into seconds.\n\nYou must build and use an event-calendar based discrete-event simulator that:\n- Maintains the next arrival time for each class $i$ based on exponential interarrival times with rate $\\lambda_i$.\n- Maintains the currently served job (if any), the remaining service time of preempted jobs, and FIFO queues for waiting jobs in each class where preempted jobs resume ahead of later arrivals at the same priority level.\n- Advances the current time to the earliest of the next arrival across all classes or the next completion of the job in service.\n- On an arrival event at time $t$ from class $k$, creates a job with a sampled service time from the exponential distribution with rate $\\mu_k$, enqueues it to the class $k$ queue, and performs preemption if the arriving class $k$ has strictly higher priority than the job currently in service.\n- On a completion event at time $t$, records the job’s response time and selects the next job to serve by choosing from the highest priority class among non-empty queues, following FIFO order within that class.\n\nYou must simulate until a specified total number of job completions has occurred across all classes in each test case. For each class $i$, you must compute the empirical cumulative distribution function (CDF) of response times evaluated at a given grid of time points $\\{t_1, t_2, \\ldots, t_m\\}$ given in seconds. For each such $t_j$, compute the empirical probability (expressed as a decimal) that a job’s response time is less than or equal to $t_j$.\n\nTime is measured in seconds. Probabilities must be expressed as decimals (not with a percentage sign). All outputs must be numerical.\n\nImplement the final program in Python with the specifications provided in the final answer section, and ensure reproducibility by using the provided random seeds. Use only the Python standard library and the specified versions of NumPy and SciPy, though SciPy is not required. Your program must not accept any input and must produce a single line of output aggregating the results from all test cases in the exact required format.\n\nTest Suite and Parameters:\n- Test Case $1$ (happy path, moderate load):\n  - Number of classes: $2$.\n  - Arrival rates: $\\lambda_1 = 0.8$, $\\lambda_2 = 0.4$ (in $s^{-1}$).\n  - Service rates: $\\mu_1 = 2.0$, $\\mu_2 = 1.0$ (in $s^{-1}$).\n  - Priorities (smaller is higher): class $1$ has priority $1$, class $2$ has priority $2$.\n  - Time grid for CDF evaluation (in seconds): $[0.2, 0.5, 1.0, 2.0]$.\n  - Total completions to simulate: $25000$.\n  - Random seed: $20240501$.\n- Test Case $2$ (heavy but stable load, three classes):\n  - Number of classes: $3$.\n  - Arrival rates: $\\lambda_1 = 0.9$, $\\lambda_2 = 0.7$, $\\lambda_3 = 0.5$ (in $s^{-1}$).\n  - Service rates: $\\mu_1 = 3.0$, $\\mu_2 = 2.0$, $\\mu_3 = 2.5$ (in $s^{-1}$).\n  - Priorities (smaller is higher): class $1$ has priority $1$, class $2$ has priority $2$, class $3$ has priority $3$.\n  - Time grid for CDF evaluation (in seconds): $[0.1, 0.25, 0.5, 1.0, 2.0]$.\n  - Total completions to simulate: $30000$.\n  - Random seed: $20240502$.\n- Test Case $3$ (edge case with slow high-priority class and fast lower-priority class):\n  - Number of classes: $2$.\n  - Arrival rates: $\\lambda_1 = 0.05$, $\\lambda_2 = 0.9$ (in $s^{-1}$).\n  - Service rates: $\\mu_1 = 0.5$, $\\mu_2 = 3.0$ (in $s^{-1}$).\n  - Priorities (smaller is higher): class $1$ has priority $1$, class $2$ has priority $2$.\n  - Time grid for CDF evaluation (in seconds): $[1.0, 2.0, 5.0, 10.0]$.\n  - Total completions to simulate: $20000$.\n  - Random seed: $20240503$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The result for each test case must be a list whose elements are themselves lists, one per class, containing the empirical CDF values at the specified grid points in the prescribed order. For example, the output should look like:\n$[ [ [c_{1,1}, c_{1,2}, \\ldots], [c_{2,1}, \\ldots] ], [ [\\ldots], [\\ldots], [\\ldots] ], [ [\\ldots], [\\ldots] ] ]$,\nwhere $c_{i,j}$ denotes the empirical CDF value for class $i$ at grid point $j$ in the corresponding test case. The program must print exactly this single line with numeric values and rectangular brackets, with no additional text.", "solution": "The problem requires the design and implementation of a discrete-event simulation for a single-server, multi-class queueing system operating under a preemptive-resume priority discipline. The solution is constructed by modeling the system's state, advancing time based on events, and processing these events according to the specified rules.\n\n**1. Verification of Problem Statement**\nThe problem is first validated for scientific soundness and completeness.\n- **Scientific Grounding**: The model described is a classical M/M/1 priority queue, a well-established model in queueing theory. The arrival processes are Poisson, characterized by rates $\\lambda_i$, and service times are exponential, with rates $\\mu_i$. The stability condition for such a system is that the total server utilization, $\\rho = \\sum_{i} \\rho_i = \\sum_{i} (\\lambda_i / \\mu_i)$, must be less than $1$.\n  - For Test Case $1$: $\\rho = (0.8/2.0) + (0.4/1.0) = 0.4 + 0.4 = 0.8  1$.\n  - For Test Case $2$: $\\rho = (0.9/3.0) + (0.7/2.0) + (0.5/2.5) = 0.3 + 0.35 + 0.2 = 0.85  1$.\n  - For Test Case $3$: $\\rho = (0.05/0.5) + (0.9/3.0) = 0.1 + 0.3 = 0.4  1$.\nAll test cases describe stable queueing systems, for which long-run statistics like the response time distribution are well-defined.\n- **Well-Posedness**: The problem provides all necessary parameters, including arrival and service rates for each class, priority assignments, a definitive termination condition (total number of completions), and specific random seeds for reproducibility. The objective, computing empirical Cumulative Distribution Functions (CDFs), is clearly stated.\n- **Objectivity and Clarity**: The problem uses standard, unambiguous terminology from stochastic simulation and queueing theory. The rules for preemption and queue management are explicitly defined.\n\nThe problem is therefore deemed valid and a solution can be constructed.\n\n**2. Simulation Model Design**\nA discrete-event simulation approach is employed. The simulation state evolves only at discrete points in time where events occur.\n\n**2.1. State Representation**\nThe state of the system at any time $t$ is captured by the following variables:\n- **Simulation Clock ($t_{current}$)**: The current time in the simulation.\n- **Job Representation**: Each job is an object with attributes: its class index $i$, arrival time $t_{arrival}$, total service time $S_{total}$, and remaining service time $S_{rem}$.\n- **Queues**: A set of queues, one for each priority class. Since jobs of the same class are served in a First-In, First-Out (FIFO) order, and preempted jobs must resume before later arrivals of the same class, a double-ended queue (`deque`) is an appropriate data structure for each class. New arrivals are added to the back, and preempted jobs are added to the front. The set of queues is represented as a list of `deque`s, indexed by priority.\n- **Server State**: A variable representing the job currently in service, or a `None` state if the server is idle.\n- **Event Calendar**: This is the core of the simulator, dictating the progression of time. For this system, there are two types of events: job arrivals and service completions. The event calendar can be managed by tracking two sets of times:\n  - `next_arrival_times`: A list where the $i$-th element is the scheduled time of the next arrival for class $i$.\n  - `next_completion_time`: The scheduled time of completion for the job currently in service. This is set to infinity if the server is idle.\n- **Data Collectors**: Lists to store the measured response times for each class of job upon their completion.\n\n**2.2. Simulation Dynamics: The Main Loop**\nThe simulation proceeds by repeatedly advancing the clock to the time of the next imminent event.\n1. At each step, identify the next event and its time, $t_{next}$, by finding the minimum of all next arrival times and the next completion time: $$t_{next} = \\min(\\min_{i} \\{\\text{next\\_arrival\\_times}[i]\\}, \\text{next\\_completion\\_time})$$\n2. Advance the simulation clock: $t_{current} \\leftarrow t_{next}$. Before processing the event, if a job was in service, its remaining service time is reduced by the elapsed duration, $\\Delta t = t_{next} - t_{previous}$.\n3. Identify the event type (arrival of class $i$ or completion) and execute the corresponding logic.\n4. The loop continues until the total number of completed jobs reaches the specified threshold.\n\n**2.3. Event Handling Logic**\n\n**Arrival Event (Class $k$ at time $t_{current}$):**\n1. A new `Job` instance is created for class $k$. Its arrival time is $t_{current}$. Its total service time is sampled from an exponential distribution with rate $\\mu_k$, i.e., $S \\sim \\text{Exp}(\\mu_k)$. The remaining service time is initialized to this total service time.\n2. The next arrival for class $k$ is scheduled by sampling an interarrival time $\\Delta T \\sim \\text{Exp}(\\lambda_k)$ and setting the new arrival time to $t_{current} + \\Delta T$.\n3. The new job is placed in the system:\n   - **If the server is idle**: The job immediately enters service. Its completion time is scheduled at $t_{current} + S_{rem}$.\n   - **If the server is busy**: Let the job in service be $J_{serv}$ of class $p_{serv}$. The arriving job is of class $k$ with priority $p_k$.\n     - If $p_k  p_{serv}$ (arriving job has strictly higher priority):\n       - The currently serving job, $J_{serv}$, is preempted. Its state (including its updated $S_{rem}$) is saved, and it is placed at the front of the queue for its class, $p_{serv}$.\n       - The new job from class $k$ enters service. Its completion time is scheduled at $t_{current} + S_{rem}$.\n     - If $p_k \\geq p_{serv}$ (arriving job has equal or lower priority):\n       - The new job is placed at the back of the queue for its class, $p_k$. The server continues to process $J_{serv}$.\n\n**Completion Event (at time $t_{current}$):**\n1. The `Job` that was in service, $J_{finished}$, has now completed.\n2. Its response time, $R = t_{current} - t_{arrival}$, is calculated and stored in the data collector for its class.\n3. The total number of completions is incremented.\n4. The server becomes momentarily idle. A new job must be selected for service. The selection rule is to scan the queues in order of priority (from highest, $p=1$, to lowest).\n   - The first non-empty queue encountered provides the next job to be served. This job is removed from the front of its queue.\n5. If a next job is found:\n   - It enters service. Its completion is scheduled at $t_{current} + S_{rem}$. Note that for a job that was preempted, $S_{rem}  S_{total}$.\n6. If no jobs are waiting in any queue, the server becomes idle, and `next_completion_time` is set to infinity.\n\n**3. Output Calculation**\nAfter the simulation run completes, the collected response times are used to compute the empirical CDF for each class. For a given class $i$ with $N_i$ completed jobs and a set of evaluation points $\\{t_j\\}$, the empirical CDF value $F_i(t_j)$ is the fraction of observed response times less than or equal to $t_j$:\n$$ \\hat{F}_i(t_j) = \\frac{1}{N_i} \\sum_{k=1}^{N_i} \\mathbf{1}\\{R_{i,k} \\leq t_j\\} $$\nwhere $R_{i,k}$ is the response time of the $k$-th completed job of class $i$, and $\\mathbf{1}\\{\\cdot\\}$ is the indicator function. This is efficiently computed by sorting the response times and using a search algorithm to find the count of values below each grid point.", "answer": "```python\nimport numpy as np\nfrom collections import deque\nimport math\n\nclass Job:\n    \"\"\"Represents a job in the queueing system.\"\"\"\n    def __init__(self, class_id, arrival_time, service_time):\n        self.class_id = class_id\n        self.arrival_time = arrival_time\n        self.service_time = service_time\n        self.remaining_service_time = service_time\n\ndef run_simulation(params):\n    \"\"\"\n    Runs a discrete-event simulation of a single-server, multi-class queue\n    with a preemptive-resume priority discipline.\n    \"\"\"\n    num_classes = params[\"num_classes\"]\n    lambdas = params[\"lambdas\"]\n    mus = params[\"mus\"]\n    priorities = params[\"priorities\"]\n    time_grid = params[\"time_grid\"]\n    total_completions = params[\"total_completions\"]\n    seed = params[\"seed\"]\n    \n    rng = np.random.default_rng(seed)\n    current_time = 0.0\n    completions_count = 0\n    queues = [deque() for _ in range(num_classes)]\n    response_times = [[] for _ in range(num_classes)]\n    job_in_service = None\n    \n    next_arrival_times = [rng.exponential(1.0 / l) for l in lambdas]\n    next_completion_time = float('inf')\n    \n    # Correctly ordered class indices according to priority (highest prio first)\n    prio_sorted_class_indices = np.argsort(priorities)\n\n    while completions_count  total_completions:\n        min_arrival_time = min(next_arrival_times)\n        arrival_class_idx = next_arrival_times.index(min_arrival_time)\n        \n        if min_arrival_time  next_completion_time:\n            next_event_time = min_arrival_time\n            is_arrival = True\n        else:\n            next_event_time = next_completion_time\n            is_arrival = False\n        \n        if job_in_service:\n            job_in_service.remaining_service_time -= (next_event_time - current_time)\n\n        current_time = next_event_time\n\n        if is_arrival:\n            service_time = rng.exponential(1.0 / mus[arrival_class_idx])\n            new_job = Job(arrival_class_idx, current_time, service_time)\n            next_arrival_times[arrival_class_idx] = current_time + rng.exponential(1.0 / lambdas[arrival_class_idx])\n\n            if job_in_service is None:\n                job_in_service = new_job\n                next_completion_time = current_time + new_job.remaining_service_time\n            else:\n                arriving_priority = priorities[new_job.class_id]\n                current_priority = priorities[job_in_service.class_id]\n                \n                if arriving_priority  current_priority:\n                    preempted_job = job_in_service\n                    queues[preempted_job.class_id].appendleft(preempted_job)\n                    job_in_service = new_job\n                    next_completion_time = current_time + new_job.remaining_service_time\n                else:\n                    queues[new_job.class_id].append(new_job)\n        else:\n            finished_job = job_in_service\n            response_times[finished_job.class_id].append(current_time - finished_job.arrival_time)\n            completions_count += 1\n            \n            job_in_service = None\n            next_completion_time = float('inf')\n\n            for class_idx in prio_sorted_class_indices:\n                if queues[class_idx]:\n                    job_in_service = queues[class_idx].popleft()\n                    next_completion_time = current_time + job_in_service.remaining_service_time\n                    break\n    \n    all_class_cdfs = []\n    for i in range(num_classes):\n        class_rt_np = np.array(response_times[i])\n        if len(class_rt_np) == 0:\n            all_class_cdfs.append([0.0] * len(time_grid))\n            continue\n        \n        class_rt_np.sort()\n        counts = np.searchsorted(class_rt_np, time_grid, side='right')\n        cdf_values = counts / len(class_rt_np)\n        all_class_cdfs.append(cdf_values.tolist())\n        \n    return all_class_cdfs\n\ndef solve():\n    test_cases = [\n        {\n            \"num_classes\": 2,\n            \"lambdas\": [0.8, 0.4],\n            \"mus\": [2.0, 1.0],\n            \"priorities\": [1, 2],\n            \"time_grid\": [0.2, 0.5, 1.0, 2.0],\n            \"total_completions\": 25000,\n            \"seed\": 20240501\n        },\n        {\n            \"num_classes\": 3,\n            \"lambdas\": [0.9, 0.7, 0.5],\n            \"mus\": [3.0, 2.0, 2.5],\n            \"priorities\": [1, 2, 3],\n            \"time_grid\": [0.1, 0.25, 0.5, 1.0, 2.0],\n            \"total_completions\": 30000,\n            \"seed\": 20240502\n        },\n        {\n            \"num_classes\": 2,\n            \"lambdas\": [0.05, 0.9],\n            \"mus\": [0.5, 3.0],\n            \"priorities\": [1, 2],\n            \"time_grid\": [1.0, 2.0, 5.0, 10.0],\n            \"total_completions\": 20000,\n            \"seed\": 20240503\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(case)\n        results.append(result)\n\n    # Format the final output string exactly as required\n    final_output_str = f\"[{','.join(map(str, results))}]\".replace(\" \", \"\")\n    print(final_output_str)\n\nsolve()\n```", "id": "3303670"}]}