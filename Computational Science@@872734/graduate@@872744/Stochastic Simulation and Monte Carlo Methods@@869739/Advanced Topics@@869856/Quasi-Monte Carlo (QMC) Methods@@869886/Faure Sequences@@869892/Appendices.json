{"hands_on_practices": [{"introduction": "Understanding Faure sequences begins with their one-dimensional case, which is famously known as the van der Corput sequence. This first practice provides a concrete starting point by guiding you through the manual computation of the sequence's initial terms using the base-3 radical-inverse function [@problem_id:3308091]. By constructing these points yourself, you will gain direct insight into the digit-reversal mechanism and observe the sequence's remarkable stratification property, a foundational concept underpinning the uniformity of all low-discrepancy sequences.", "problem": "In the context of Quasi-Monte Carlo (QMC) methods using Low-Discrepancy Sequences (LDS), the Faure sequence in one dimension reduces to the radical inverse function in a prime base. Let the base be $3$. For any nonnegative integer $n \\in \\mathbb{N}_{0}$, write its base-$3$ expansion as $n = \\sum_{k=0}^{K} a_{k} 3^{k}$ with digits $a_{k} \\in \\{0,1,2\\}$. The base-$3$ radical inverse is defined by\n$$\n\\phi_{3}(n) = \\sum_{k=0}^{K} a_{k} 3^{-(k+1)}.\n$$\nThis construction is a fundamental ingredient underlying one-dimensional components of Faure sequences and is used to generate stratified samples on $[0,1)$.\n\nCompute $\\phi_{3}(n)$ for $n=0,1,2,\\dots,9$. Then, using only the base-$3$ digit representation and the definition above, verify that the set $\\{\\phi_{3}(n) : 0 \\leq n  3^{m}\\}$ places exactly one point in each interval\n$$\nI_{j,m} = \\left[\\frac{j}{3^{m}}, \\frac{j+1}{3^{m}}\\right), \\quad j = 0,1,\\dots,3^{m}-1,\n$$\nfor $m=1$ and $m=2$. Interpret the intervals as left-closed and right-open.\n\nReport the first $10$ terms $\\phi_{3}(n)$, in the order of increasing $n$, as a single row vector using the LaTeX $\\texttt{pmatrix}$ environment in your final answer. No rounding is required, and no physical units are involved.", "solution": "The starting point is the definition of the base-$3$ radical inverse $\\phi_{3}(n)$, which maps the base-$3$ digits of $n$ from integer powers to negative powers, thereby producing a point in $[0,1)$. This digit-reversal mechanism is the core construction for one-dimensional components of Faure sequences and the van der Corput sequence.\n\nFirst, compute $\\phi_{3}(n)$ for $n=0,1,\\dots,9$ by expressing each $n$ in base $3$:\n- For $n=0$, the base-$3$ expansion is $0$, so $a_{0}=0$ and\n$$\n\\phi_{3}(0) = 0.\n$$\n- For $n=1$, the base-$3$ expansion is $1$, so $a_{0}=1$ and\n$$\n\\phi_{3}(1) = \\frac{1}{3}.\n$$\n- For $n=2$, the base-$3$ expansion is $2$, so $a_{0}=2$ and\n$$\n\\phi_{3}(2) = \\frac{2}{3}.\n$$\n- For $n=3$, the base-$3$ expansion is $10$, so $a_{0}=0$, $a_{1}=1$ and\n$$\n\\phi_{3}(3) = \\frac{0}{3} + \\frac{1}{9} = \\frac{1}{9}.\n$$\n- For $n=4$, the base-$3$ expansion is $11$, so $a_{0}=1$, $a_{1}=1$ and\n$$\n\\phi_{3}(4) = \\frac{1}{3} + \\frac{1}{9} = \\frac{4}{9}.\n$$\n- For $n=5$, the base-$3$ expansion is $12$, so $a_{0}=2$, $a_{1}=1$ and\n$$\n\\phi_{3}(5) = \\frac{2}{3} + \\frac{1}{9} = \\frac{7}{9}.\n$$\n- For $n=6$, the base-$3$ expansion is $20$, so $a_{0}=0$, $a_{1}=2$ and\n$$\n\\phi_{3}(6) = \\frac{0}{3} + \\frac{2}{9} = \\frac{2}{9}.\n$$\n- For $n=7$, the base-$3$ expansion is $21$, so $a_{0}=1$, $a_{1}=2$ and\n$$\n\\phi_{3}(7) = \\frac{1}{3} + \\frac{2}{9} = \\frac{5}{9}.\n$$\n- For $n=8$, the base-$3$ expansion is $22$, so $a_{0}=2$, $a_{1}=2$ and\n$$\n\\phi_{3}(8) = \\frac{2}{3} + \\frac{2}{9} = \\frac{8}{9}.\n$$\n- For $n=9$, the base-$3$ expansion is $100$, so $a_{0}=0$, $a_{1}=0$, $a_{2}=1$ and\n$$\n\\phi_{3}(9) = \\frac{0}{3} + \\frac{0}{9} + \\frac{1}{27} = \\frac{1}{27}.\n$$\n\nThus, the first $10$ terms are\n$$\n\\phi_{3}(n) = 0,\\ \\frac{1}{3},\\ \\frac{2}{3},\\ \\frac{1}{9},\\ \\frac{4}{9},\\ \\frac{7}{9},\\ \\frac{2}{9},\\ \\frac{5}{9},\\ \\frac{8}{9},\\ \\frac{1}{27}\n$$\nfor $n=0,1,\\dots,9$ respectively.\n\nNext, verify the stratification property over intervals of length $3^{-m}$ for $m=1$ and $m=2$. Consider $m \\in \\mathbb{N}$, and $n$ constrained to $0 \\leq n  3^{m}$. Then $n$ has a base-$3$ expansion using at most $m$ digits:\n$$\nn = \\sum_{k=0}^{m-1} a_{k} 3^{k}, \\quad a_{k} \\in \\{0,1,2\\}.\n$$\nBy the definition of $\\phi_{3}(n)$,\n$$\n\\phi_{3}(n) = \\sum_{k=0}^{m-1} a_{k} 3^{-(k+1)} = \\frac{1}{3^{m}} \\sum_{k=0}^{m-1} a_{k} 3^{m-1-k}.\n$$\nDefine the integer\n$$\nj(n) = \\sum_{k=0}^{m-1} a_{k} 3^{m-1-k}.\n$$\nSince the map from the digit vector $(a_{0},a_{1},\\dots,a_{m-1})$ to $j$ is a bijection from $\\{0,1,2\\}^{m}$ to $\\{0,1,\\dots,3^{m}-1\\}$ (it is exactly the standard base-$3$ encoding but with reversed digit order), each choice of digits yields a unique $j$ in $\\{0,1,\\dots,3^{m}-1\\}$, and conversely each such $j$ yields a unique digit vector. Therefore,\n$$\n\\phi_{3}(n) = \\frac{j(n)}{3^{m}},\n$$\nand as $n$ ranges over $0,1,\\dots,3^{m}-1$, the set $\\{\\phi_{3}(n)\\}$ is exactly the set $\\left\\{\\frac{j}{3^{m}} : j = 0,1,\\dots,3^{m}-1\\right\\}$, each appearing exactly once.\n\nThis immediately implies stratification: for the partition into left-closed, right-open intervals\n$$\nI_{j,m} = \\left[\\frac{j}{3^{m}}, \\frac{j+1}{3^{m}}\\right), \\quad j = 0,1,\\dots,3^{m}-1,\n$$\neach interval $I_{j,m}$ contains exactly one point of $\\{\\phi_{3}(n) : 0 \\leq n  3^{m}\\}$, namely $\\frac{j}{3^{m}}$ itself.\n\nApply this to the specific cases requested:\n- For $m=1$, the set $\\{\\phi_{3}(n) : 0 \\leq n  3\\}$ is $\\{0,\\frac{1}{3},\\frac{2}{3}\\}$, and the intervals are $I_{0,1}=[0,\\frac{1}{3})$, $I_{1,1}=[\\frac{1}{3},\\frac{2}{3})$, $I_{2,1}=[\\frac{2}{3},1)$. Each interval contains exactly its left endpoint among these values, so there is exactly one point in each interval.\n- For $m=2$, the set $\\{\\phi_{3}(n) : 0 \\leq n  9\\}$ is $\\left\\{\\frac{j}{9} : j=0,1,\\dots,8\\right\\}$, specifically $\\{0,\\frac{1}{9},\\frac{2}{9},\\dots,\\frac{8}{9}\\}$ in some order. The intervals $I_{j,2}=\\left[\\frac{j}{9},\\frac{j+1}{9}\\right)$ each contain exactly $\\frac{j}{9}$ from that set, so there is exactly one point in each interval.\n\nHence, the first $3^{m}$ terms are perfectly stratified over the triadic partition of $[0,1)$ into intervals of length $3^{-m}$ for $m=1$ and $m=2$. The tenth term $\\phi_{3}(9)=\\frac{1}{27}$ begins the next block corresponding to $m=3$ and is consistent with the same digit-reversal principle.\n\nThe requested final report is the row vector of the first $10$ terms in the order of increasing $n$.", "answer": "$$\\boxed{\\begin{pmatrix}\n0  \\frac{1}{3}  \\frac{2}{3}  \\frac{1}{9}  \\frac{4}{9}  \\frac{7}{9}  \\frac{2}{9}  \\frac{5}{9}  \\frac{8}{9}  \\frac{1}{27}\n\\end{pmatrix}}$$", "id": "3308091"}, {"introduction": "While the one-dimensional sequence is well-stratified, the true power of Faure sequences emerges in multiple dimensions, where they form what are known as $(t,m,s)$-nets. This practice delves into the algebraic machinery behind this property, using powers of the Pascal matrix over a finite field to generate points in a unit hypercube [@problem_id:3308024]. By verifying that the first $b^m$ points perfectly occupy a grid of elementary boxes, you will demonstrate this defining characteristic of nets and appreciate why they offer significant advantages over random sampling in Quasi-Monte Carlo methods.", "problem": "Consider the digital construction of low-discrepancy sequences used in Quasi-Monte Carlo (QMC) methods. Let the base be $b=3$ (a prime), and consider the Faure sequence in spatial dimension $s=3$. Work over the Finite Field of order $3$ (FF), denoted $\\mathbb{F}_{3}$.\n\nUse the following fundamental definitions and facts:\n\n- A digital sequence in base $b$ is defined via generating matrices over $\\mathbb{F}_{b}$ applied to the base-$b$ digit vector of the nonnegative integer index $n$. Let $n=\\sum_{k=0}^{\\infty} a_{k} b^{k}$ with digits $a_{k} \\in \\{0,1,\\dots,b-1\\}$, and collect the first $m$ digits into the column vector $\\boldsymbol{a}=(a_{0},a_{1},\\dots,a_{m-1})^{\\top}$. The coordinate-$j$ digit vector $\\boldsymbol{y}^{(j)}=(y^{(j)}_{1},\\dots,y^{(j)}_{m})^{\\top}$ is obtained by $\\boldsymbol{y}^{(j)}=C_{j}\\,\\boldsymbol{a}$ over $\\mathbb{F}_{b}$, where $C_{j}$ is an upper-triangular generating matrix. The corresponding coordinate in $[0,1)$ is $x^{(j)}(n)=\\sum_{r=1}^{m} y^{(j)}_{r}\\,b^{-r}$.\n- In the Faure construction for $b$ prime and $s \\leq b$, the matrices $C_{j}$ are powers of the Pascal matrix modulo $b$. Let $P$ be the upper-triangular Pascal matrix with entries $p_{r,k} \\equiv \\binom{k-1}{r-1} \\bmod b$ for $1 \\leq r \\leq k \\leq m$, and $p_{r,k}=0$ if $rk$. Then $C_{j}=P^{j-1}$ for $j=1,2,\\dots,s$.\n\nTake $m=3$ digits. Perform the following tasks:\n\n1. Construct explicitly the matrices $P$, $P^{2}$, and hence $C_{1}$, $C_{2}$, $C_{3}$ over $\\mathbb{F}_{3}$ for $m=3$.\n2. Using these $C_{j}$, derive the three-digit formulas for the coordinates $x^{(1)}(n)$, $x^{(2)}(n)$, $x^{(3)}(n)$ in terms of the base-$3$ digits $(a_{0},a_{1},a_{2})$ of $n$, for $n=0,1,\\dots,26$ (i.e., for all $\\boldsymbol{a} \\in \\mathbb{F}_{3}^{3}$).\n3. Consider the collection of $3$-adic elementary boxes in $[0,1)^{3}$ at resolution $m=3$ with equal digit depths $d_{1}=d_{2}=d_{3}=1$. These are the $3^{3}$ boxes of the form $\\prod_{j=1}^{3} \\left[\\frac{t_{j}}{3},\\frac{t_{j}+1}{3}\\right)$ with $(t_{1},t_{2},t_{3}) \\in \\{0,1,2\\}^{3}$. Using only the formal definitions above, determine the occupancy counts of the first $b^{m}=27$ points of the Faure sequence among these $3^{3}$ boxes.\n4. Define the multinomial chi-squared statistic for testing uniform occupancy across these $3^{3}$ boxes by\n$$\n\\chi^{2} \\;=\\; \\sum_{i=1}^{27} \\frac{(O_{i}-E_{i})^{2}}{E_{i}},\n$$\nwhere $O_{i}$ is the observed count in box $i$ and $E_{i}$ is the expected count under exact uniformity. Compute $\\chi^{2}$ for the $27$ points constructed above. Express the final answer as a single real value. No rounding is required and no physical units are involved.", "solution": "The problem asks for a multi-part analysis of a Faure sequence in base $b=3$ and dimension $s=3$, using $m=3$ digits. The analysis involves constructing the generating matrices, deriving coordinate formulas, determining point distribution in elementary boxes, and calculating a chi-squared statistic. All calculations are performed over the finite field $\\mathbb{F}_{3}$.\n\nFirst, the givens are validated. The problem statement is self-contained, scientifically grounded in the theory of Quasi-Monte Carlo methods, and well-posed. All definitions and parameters ($b=3$, $s=3$, $m=3$) are specified and consistent. The tasks are sequential and lead to a unique, verifiable solution. Therefore, the problem is valid.\n\n**Part 1: Construction of Generating Matrices**\n\nThe generating matrices for the Faure sequence are given by $C_{j} = P^{j-1}$ for $j=1, 2, \\dots, s$. Here, $s=3$, so we need $C_{1}$, $C_{2}$, and $C_{3}$. This requires computing the $m \\times m = 3 \\times 3$ Pascal matrix $P$ and its square $P^{2}$ over $\\mathbb{F}_{3}$.\n\nThe entries of the upper-triangular Pascal matrix $P$ are given by $p_{r,k} \\equiv \\binom{k-1}{r-1} \\pmod b$ for $1 \\le r \\le k \\le m$. With $b=3$ and $m=3$, the entries are calculated as follows (all modulo $3$):\n$p_{1,1} = \\binom{1-1}{1-1} = \\binom{0}{0} = 1$\n$p_{1,2} = \\binom{2-1}{1-1} = \\binom{1}{0} = 1$\n$p_{2,2} = \\binom{2-1}{2-1} = \\binom{1}{1} = 1$\n$p_{1,3} = \\binom{3-1}{1-1} = \\binom{2}{0} = 1$\n$p_{2,3} = \\binom{3-1}{2-1} = \\binom{2}{1} = 2$\n$p_{3,3} = \\binom{3-1}{3-1} = \\binom{2}{2} = 1$\nAll other entries $p_{r,k}$ for $rk$ are $0$. This gives the matrix:\n$$ P = \\begin{pmatrix} 1  1  1 \\\\ 0  1  2 \\\\ 0  0  1 \\end{pmatrix} $$\nNext, we compute $P^{2}$ over $\\mathbb{F}_{3}$:\n$$ P^{2} = P \\cdot P = \\begin{pmatrix} 1  1  1 \\\\ 0  1  2 \\\\ 0  0  1 \\end{pmatrix} \\begin{pmatrix} 1  1  1 \\\\ 0  1  2 \\\\ 0  0  1 \\end{pmatrix} $$\n$$ = \\begin{pmatrix} 1 \\cdot 1 + 1 \\cdot 0 + 1 \\cdot 0  1 \\cdot 1 + 1 \\cdot 1 + 1 \\cdot 0  1 \\cdot 1 + 1 \\cdot 2 + 1 \\cdot 1 \\\\ 0 \\cdot 1 + 1 \\cdot 0 + 2 \\cdot 0  0 \\cdot 1 + 1 \\cdot 1 + 2 \\cdot 0  0 \\cdot 1 + 1 \\cdot 2 + 2 \\cdot 1 \\\\ 0 \\cdot 1 + 0 \\cdot 0 + 1 \\cdot 0  0 \\cdot 1 + 0 \\cdot 1 + 1 \\cdot 0  0 \\cdot 1 + 0 \\cdot 2 + 1 \\cdot 1 \\end{pmatrix} \\pmod 3 $$\n$$ = \\begin{pmatrix} 1  2  4 \\\\ 0  1  4 \\\\ 0  0  1 \\end{pmatrix} \\pmod 3 = \\begin{pmatrix} 1  2  1 \\\\ 0  1  1 \\\\ 0  0  1 \\end{pmatrix} $$\nThe generating matrices $C_{j}$ for $j=1, 2, 3$ are:\n$C_{1} = P^{1-1} = P^{0} = I = \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix}$\n$C_{2} = P^{2-1} = P^{1} = P = \\begin{pmatrix} 1  1  1 \\\\ 0  1  2 \\\\ 0  0  1 \\end{pmatrix}$\n$C_{3} = P^{3-1} = P^{2} = \\begin{pmatrix} 1  2  1 \\\\ 0  1  1 \\\\ 0  0  1 \\end{pmatrix}$\n\n**Part 2: Coordinate Formulas**\n\nThe digit vector $\\boldsymbol{y}^{(j)} = (y_1^{(j)}, y_2^{(j)}, y_3^{(j)})^{\\top}$ for coordinate $j$ is found by applying $C_j$ to the base-$3$ digit vector $\\boldsymbol{a} = (a_0, a_1, a_2)^{\\top}$ of the index $n = a_0 + 3a_1 + 9a_2$. The coordinate value is $x^{(j)}(n) = \\sum_{r=1}^{3} y_r^{(j)} 3^{-r}$. The \"three-digit formulas\" are the expressions for the digits $y_r^{(j)}$ in terms of $a_0, a_1, a_2$.\n\nFor coordinate $j=1$:\n$\\boldsymbol{y}^{(1)} = C_1 \\boldsymbol{a} = I \\boldsymbol{a} = \\boldsymbol{a}$.\n$y_1^{(1)} = a_0$\n$y_2^{(1)} = a_1$\n$y_3^{(1)} = a_2$\n\nFor coordinate $j=2$:\n$\\boldsymbol{y}^{(2)} = C_2 \\boldsymbol{a} = P \\boldsymbol{a}$.\n$$ \\begin{pmatrix} y_1^{(2)} \\\\ y_2^{(2)} \\\\ y_3^{(2)} \\end{pmatrix} = \\begin{pmatrix} 1  1  1 \\\\ 0  1  2 \\\\ 0  0  1 \\end{pmatrix} \\begin{pmatrix} a_0 \\\\ a_1 \\\\ a_2 \\end{pmatrix} = \\begin{pmatrix} a_0 + a_1 + a_2 \\\\ a_1 + 2a_2 \\\\ a_2 \\end{pmatrix} \\pmod 3 $$\n\nFor coordinate $j=3$:\n$\\boldsymbol{y}^{(3)} = C_3 \\boldsymbol{a} = P^2 \\boldsymbol{a}$.\n$$ \\begin{pmatrix} y_1^{(3)} \\\\ y_2^{(3)} \\\\ y_3^{(3)} \\end{pmatrix} = \\begin{pmatrix} 1  2  1 \\\\ 0  1  1 \\\\ 0  0  1 \\end{pmatrix} \\begin{pmatrix} a_0 \\\\ a_1 \\\\ a_2 \\end{pmatrix} = \\begin{pmatrix} a_0 + 2a_1 + a_2 \\\\ a_1 + a_2 \\\\ a_2 \\end{pmatrix} \\pmod 3 $$\n\n**Part 3: Occupancy Counts**\n\nWe consider $3^3 = 27$ elementary boxes of the form $B_{t_1, t_2, t_3} = \\prod_{j=1}^{3} \\left[\\frac{t_{j}}{3},\\frac{t_{j}+1}{3}\\right)$ for $(t_1, t_2, t_3) \\in \\{0,1,2\\}^3$.\nA point $\\boldsymbol{x}(n) = (x^{(1)}(n), x^{(2)}(n), x^{(3)}(n))$ lies in the box $B_{t_1, t_2, t_3}$ if and only if $\\lfloor 3x^{(j)}(n) \\rfloor = t_j$ for each $j \\in \\{1,2,3\\}$.\nFrom the formula $x^{(j)}(n) = \\frac{y_1^{(j)}}{3} + \\frac{y_2^{(j)}}{9} + \\frac{y_3^{(j)}}{27}$, we have $3x^{(j)}(n) = y_1^{(j)} + \\frac{y_2^{(j)}}{3} + \\frac{y_3^{(j)}}{9}$. Since $y_r^{(j)} \\in \\{0, 1, 2\\}$, the fractional part is always less than $1$, so $\\lfloor 3x^{(j)}(n) \\rfloor = y_1^{(j)}$.\nThus, a point $\\boldsymbol{x}(n)$ is in box $B_{t_1, t_2, t_3}$ if and only if its vector of first digits $(y_1^{(1)}, y_1^{(2)}, y_1^{(3)})$ is equal to $(t_1, t_2, t_3)$.\n\nUsing the formulas from Part 2, this condition translates to a system of linear equations for the input digits $(a_0, a_1, a_2)$ over $\\mathbb{F}_3$:\n$$ y_1^{(1)} = a_0 = t_1 $$\n$$ y_1^{(2)} = a_0 + a_1 + a_2 = t_2 $$\n$$ y_1^{(3)} = a_0 + 2a_1 + a_2 = t_3 $$\nThis can be written in matrix form as $M \\boldsymbol{a} = \\boldsymbol{t}$:\n$$ \\begin{pmatrix} 1  0  0 \\\\ 1  1  1 \\\\ 1  2  1 \\end{pmatrix} \\begin{pmatrix} a_0 \\\\ a_1 \\\\ a_2 \\end{pmatrix} = \\begin{pmatrix} t_1 \\\\ t_2 \\\\ t_3 \\end{pmatrix} $$\nThe number of points in a given box corresponds to the number of solutions $\\boldsymbol{a} \\in \\mathbb{F}_3^3$ for the corresponding $\\boldsymbol{t} \\in \\mathbb{F}_3^3$. The first $27$ points of the sequence correspond to $n=0, 1, \\dots, 26$, which exhaust all possible vectors $\\boldsymbol{a} = (a_0, a_1, a_2)^\\top$ in $\\mathbb{F}_3^3$ exactly once.\nTo find the number of solutions, we check if the matrix $M$ is invertible by computing its determinant in $\\mathbb{F}_3$:\n$$ \\det(M) = 1 \\cdot \\det\\begin{pmatrix} 1  1 \\\\ 2  1 \\end{pmatrix} - 0 + 0 = 1(1 \\cdot 1 - 1 \\cdot 2) = 1 - 2 = -1 \\equiv 2 \\pmod 3 $$\nSince $\\det(M) = 2 \\neq 0$ in $\\mathbb{F}_3$, the matrix $M$ is invertible. This implies that for every target vector $\\boldsymbol{t} = (t_1, t_2, t_3) \\in \\mathbb{F}_3^3$, there is exactly one unique solution vector $\\boldsymbol{a} = (a_0, a_1, a_2) \\in \\mathbb{F}_3^3$.\nTherefore, each of the $27$ boxes contains exactly one point from the first $27$ points of the sequence. The occupancy count $O_i$ for each box $i$ is $1$.\n\n**Part 4: Chi-Squared Statistic Calculation**\n\nThe multinomial chi-squared statistic is given by $\\chi^{2} = \\sum_{i=1}^{27} \\frac{(O_{i}-E_{i})^{2}}{E_{i}}$.\nWe have $N=27$ points distributed among $K=27$ boxes.\nThe observed counts, as determined in Part 3, are $O_i = 1$ for all $i=1, \\dots, 27$.\nThe expected counts $E_i$ under the hypothesis of exact uniformity are $E_i = N/K = 27/27 = 1$ for all $i=1, \\dots, 27$.\nSubstituting these values into the formula:\n$$ \\chi^{2} = \\sum_{i=1}^{27} \\frac{(1-1)^{2}}{1} = \\sum_{i=1}^{27} \\frac{0^2}{1} = \\sum_{i=1}^{27} 0 = 0 $$\nThe chi-squared statistic is $0$, which signifies a perfect agreement between the observed distribution of the first $27$ Faure points and the uniform distribution across the $27$ elementary boxes. This is a characteristic feature of low-discrepancy sequences known as $(t,m,s)$-nets.", "answer": "$$\\boxed{0}$$", "id": "3308024"}, {"introduction": "A theoretical understanding of Faure sequences must be paired with the ability to generate them efficiently for practical applications, as a naive implementation based directly on the definition $C_j = B^{j-1}$ is computationally prohibitive. This exercise challenges you to bridge theory and practice by designing an algorithm that leverages the recursive structure of the generating matrices. This approach enables the computation of all $s$ coordinates with a much-improved time complexity of $O(s m^2)$, making Faure sequences a viable tool for real-world problems [@problem_id:3308045].", "problem": "You are to construct and analyze an algorithm for computing the coordinates of the Faure low-discrepancy sequence used in Quasi-Monte Carlo (QMC) simulation within the framework of digital sequences. The construction of the Faure sequence in dimension $s$ over base $b$ is defined by a family of generating matrices $\\{C_j\\}_{j=1}^s$ derived from a base matrix $B$ built from Pascal's triangle modulo $b$. The base-$b$ representation of the nonnegative integer $n$ is written as $n = \\sum_{k=0}^{m-1} n_k b^k$ with digits $(n_0,\\dots,n_{m-1})$, where each $n_k \\in \\{0,1,\\dots,b-1\\}$. The coordinate $x_j(n)$ is computed via the digital construction $y^{(j)} = C_j \\cdot \\mathbf{n} \\pmod{b}$, where $\\mathbf{n} = (n_0,\\dots,n_{m-1})^\\top$, and the real number $x_j(n)$ is the base-$b$ radical inverse formed from the digit vector $y^{(j)}$, namely $x_j(n) = \\sum_{r=0}^{m-1} y^{(j)}_r b^{-(r+1)}$. The family of generating matrices satisfies $C_j = B^{j-1}$ with arithmetic modulo $b$, where $B$ is the infinite lower-triangular Pascal matrix truncated to $m \\times m$ entries for computation, with entries $B_{r,k} = \\binom{r}{k} \\bmod b$ for $0 \\leq k \\leq r$ and $0$ otherwise. Your task is to design an algorithm that, given $n$ and its base-$b$ digits $(n_0,\\dots,n_{m-1})$ (from least to most significant), computes all $s$ coordinates $x_1(n),\\dots,x_s(n)$ using only arithmetic modulo $b$ and achieves an operation count of order $O(s m^2)$.\n\nUse only arithmetic modulo $b$ and the structural properties of Pascal’s triangle to construct $B$ and to perform the required matrix-vector products. Derive the algorithm starting from the core definitions of digital sequences and Pascal’s triangle, and justify the time complexity $O(s m^2)$ without invoking any shortcut formulas beyond the defining relation $C_j = B^{j-1}$.\n\nImplement your algorithm in a complete, runnable program. The program must compute the coordinate vectors with $m$-digit precision and convert each coordinate to a real number $x_j(n)$ as specified. Each real-valued coordinate must be rounded to $12$ decimal places. There are no physical units involved in this problem. There are no angles involved. Percentages are not used.\n\nTest Suite:\nFor each test case, $b$ is a prime base, $s$ is the dimension, and $(n_0,\\dots,n_{m-1})$ are the base-$b$ digits of $n$ (least significant digit first). For completeness, $n$ is also given, though the computation must use only the digits.\n\n- Case $1$: $b = 2$, $s = 3$, $m = 5$, digits $(n_0,\\dots,n_{4}) = (1,0,1,1,0)$, integer $n = 13$.\n- Case $2$: $b = 3$, $s = 4$, $m = 6$, digits $(n_0,\\dots,n_{5}) = (2,1,0,2,1,1)$, integer $n = 2 + 1 \\cdot 3 + 0 \\cdot 3^2 + 2 \\cdot 3^3 + 1 \\cdot 3^4 + 1 \\cdot 3^5$.\n- Case $3$: $b = 5$, $s = 1$, $m = 1$, digits $(n_0) = (4)$, integer $n = 4$.\n- Case $4$: $b = 7$, $s = 5$, $m = 4$, digits $(n_0,\\dots,n_{3}) = (6,0,3,1)$, integer $n = 6 + 0 \\cdot 7 + 3 \\cdot 7^2 + 1 \\cdot 7^3$.\n- Case $5$: $b = 3$, $s = 2$, $m = 3$, digits $(n_0,\\dots,n_{2}) = (0,0,0)$, integer $n = 0$.\n\nRequired final output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case’s result is the list of $s$ floats for its coordinates at $m$-digit precision. For example, the intended structure is $[[x_{1}^{(1)},\\dots,x_{s}^{(1)}],[x_{1}^{(2)},\\dots,x_{s}^{(2)}],\\dots]$, and the program should print exactly one such line. Each float must be rounded to $12$ decimal places.", "solution": "The problem requires the design and implementation of an algorithm to compute the first $s$ coordinates of the Faure low-discrepancy sequence for a given integer $n$. The algorithm must operate within a specified time complexity of $O(s m^2)$, where $s$ is the number of dimensions and $m$ is the number of base-$b$ digits used for precision. The solution must be derived from first principles and justified.\n\n### Step 1: Formal Definition of the Faure Sequence\n\nThe Faure sequence is a type of digital sequence. The coordinates are constructed using linear algebra over a finite field.\n\nLet $b$ be a prime base. The non-negative integer $n$ is represented in base $b$ with $m$ digits, with the least significant digit first:\n$$\n\\mathbf{n} = (n_0, n_1, \\dots, n_{m-1})^\\top\n$$\nwhere $n = \\sum_{k=0}^{m-1} n_k b^k$ and each digit $n_k \\in \\{0, 1, \\dots, b-1\\}$.\n\nThe $j$-th coordinate of the $n$-th point in the sequence, denoted $x_j(n)$, is obtained through a two-step process:\n1.  **Digital Scrambling**: An intermediate digit vector $y^{(j)} = (y^{(j)}_0, y^{(j)}_1, \\dots, y^{(j)}_{m-1})^\\top$ is computed by applying a generating matrix $C_j$ to the digit vector $\\mathbf{n}$. All arithmetic is performed modulo $b$:\n    $$\n    y^{(j)} = C_j \\cdot \\mathbf{n} \\pmod{b}\n    $$\n2.  **Radical Inversion**: The real-valued coordinate $x_j(n) \\in [0, 1)$ is constructed from the digits of $y^{(j)}$ using the base-$b$ radical inverse function:\n    $$\n    x_j(n) = \\sum_{r=0}^{m-1} y^{(j)}_r b^{-(r+1)}\n    $$\n\nThe generating matrices $\\{C_j\\}_{j=1}^s$ for the $s$-dimensional Faure sequence are defined as powers of a base matrix $B$:\n$$\nC_j = B^{j-1} \\pmod{b} \\quad \\text{for } j=1, 2, \\dots, s\n$$\nThe matrix $C_1 = B^0$ is the $m \\times m$ identity matrix $I$.\n\nThe base matrix $B$ is the $m \\times m$ lower-triangular Pascal matrix, whose entries are binomial coefficients evaluated modulo $b$:\n$$\nB_{r,k} = \\binom{r}{k} \\pmod{b} \\quad \\text{for } 0 \\le k \\le r  m\n$$\nand $B_{r,k} = 0$ for $k  r$.\n\n### Step 2: Algorithmic Design and Complexity Analysis\n\nA direct approach would be to first construct $B$, then for each $j$ from $1$ to $s$, compute $C_j=B^{j-1}$ and then $y^{(j)}=C_j \\mathbf{n}$.\n- Constructing $B$: This takes $O(m^2)$ operations.\n- Computing $C_j = B^{j-1}$: If done by repeated matrix multiplication ($C_j = B \\cdot C_{j-1}$), each new matrix $C_j$ costs $O(m^3)$ operations. Over all $s$ dimensions, this would be $O(s m^3)$. For typical values of $m$ and $s$, this is computationally expensive and exceeds the required complexity bound of $O(s m^2)$.\n\nTo achieve the desired complexity, we must avoid the explicit computation of each full matrix $C_j$. The key insight is to reorder the operations. Instead of computing the matrix product $B^{j-1}$ first, we apply the matrices to the vector $\\mathbf{n}$ sequentially.\n\nWe wish to compute the sequence of vectors $y^{(1)}, y^{(2)}, \\dots, y^{(s)}$.\n- For $j=1$:\n  $$\n  y^{(1)} = C_1 \\cdot \\mathbf{n} = B^0 \\cdot \\mathbf{n} = I \\cdot \\mathbf{n} = \\mathbf{n}\n  $$\n- For $j1$, we can establish a recurrence relation:\n  $$\n  y^{(j)} = C_j \\cdot \\mathbf{n} = B^{j-1} \\cdot \\mathbf{n} = B \\cdot (B^{j-2} \\cdot \\mathbf{n})\n  $$\n  Recognizing that $y^{(j-1)} = B^{j-2} \\cdot \\mathbf{n}$, we get:\n  $$\n  y^{(j)} = B \\cdot y^{(j-1)} \\pmod{b}\n  $$\nThis recurrence allows us to compute each subsequent digit vector $y^{(j)}$ from the previous one, $y^{(j-1)}$, via a single matrix-vector multiplication.\n\n### Step 3: The $O(s m^2)$ Algorithm\n\nBased on the preceding analysis, the efficient algorithm is as follows:\n\n1.  **Construct Base Matrix $B$**: Create the $m \\times m$ matrix $B$ where $B_{r,k} = \\binom{r}{k} \\pmod b$. This can be done efficiently in $O(m^2)$ time using Pascal's identity, $\\binom{r}{k} = \\binom{r-1}{k-1} + \\binom{r-1}{k}$, which holds modulo any integer $b$. We build the matrix row-by-row.\n    - For each row $r=0, \\dots, m-1$:\n        - $B_{r,0} = \\binom{r}{0} = 1$.\n        - For $k=1, \\dots, r$: $B_{r,k} = (B_{r-1,k-1} + B_{r-1,k}) \\pmod b$.\n\n2.  **Initialize**:\n    - Let $y_{vec}$ be the current scrambled digit vector. Initialize it with the input digits of $n$: $y_{vec} \\leftarrow \\mathbf{n}$.\n    - Create an empty list to store the final coordinate values.\n\n3.  **Compute Coordinate for $j=1$**:\n    - The first digit vector is $y^{(1)} = \\mathbf{n}$.\n    - Compute $x_1(n) = \\sum_{r=0}^{m-1} y_{vec}[r] \\cdot b^{-(r+1)}$. Add this to the results list. This step takes $O(m)$ time.\n\n4.  **Iterate for $j=2, \\dots, s$**:\n    - Update the digit vector using the recurrence: $y_{vec} \\leftarrow B \\cdot y_{vec} \\pmod b$. This is a matrix-vector product, which requires $O(m^2)$ operations.\n    - Compute the coordinate $x_j(n) = \\sum_{r=0}^{m-1} y_{vec}[r] \\cdot b^{-(r+1)}$. This takes $O(m)$ time. Add it to the results list.\n\n### Step 4: Final Complexity Justification\n\nThe total complexity of this algorithm is the sum of the complexities of its parts:\n- Construction of matrix $B$: $O(m^2)$.\n- Iterative computation for $j=2, \\dots, s$: There are $s-1$ iterations. Each iteration is dominated by the matrix-vector multiplication, which costs $O(m^2)$. The total cost for this loop is $(s-1) \\times O(m^2) = O(s m^2)$.\n- Radical inverse calculations: There are $s$ such calculations, each taking $O(m)$ time. The total cost is $O(sm)$.\n\nThe overall time complexity is $O(m^2 + s m^2 + sm) = O(s m^2)$, since typically $s \\ge 1$. This meets the problem's requirement. The algorithm relies solely on fundamental definitions and arithmetic modulo $b$, as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_faure_coordinates(b, s, m, n_digits):\n    \"\"\"\n    Computes the first s coordinates of the Faure sequence for a given n.\n\n    Args:\n        b (int): The prime base.\n        s (int): The dimension of the sequence.\n        m (int): The number of digits for precision.\n        n_digits (tuple): The base-b digits of n, least significant first.\n\n    Returns:\n        list: A list of s float coordinates, rounded to 12 decimal places.\n    \"\"\"\n\n    # Step 1: Construct the m x m Pascal matrix B modulo b.\n    # The matrix B has entries B_rk = binom(r, k) mod b.\n    # We use Pascal's identity: binom(r, k) = binom(r-1, k-1) + binom(r-1, k).\n    B = np.zeros((m, m), dtype=int)\n    for r in range(m):\n        B[r, 0] = 1\n        for k in range(1, r + 1):\n            B[r, k] = (B[r - 1, k - 1] + B[r - 1, k]) % b\n\n    # Convert the input digits tuple to a NumPy column vector\n    n_vec = np.array(n_digits, dtype=int)\n\n    # list to store the final coordinate values\n    coordinates = []\n\n    # y_vec will hold the sequence of scrambled digit vectors y^(j)\n    y_vec = n_vec.copy()\n\n    # Step 2  3: Compute coordinate for j=1.\n    # For j=1, C_1 is the identity matrix, so y^(1) = n_vec.\n    # The radical inverse calculation converts the digit vector to a float.\n    val = 0.0\n    b_inv_power = 1.0 / b\n    for r in range(m):\n        val += y_vec[r] * b_inv_power\n        b_inv_power /= b\n    coordinates.append(round(val, 12))\n\n    # Step 4: Iterate for j=2 to s.\n    # Each subsequent y^(j) is obtained by multiplying the previous y^(j-1) by B.\n    for _ in range(2, s + 1):\n        # y^(j) = B * y^(j-1) mod b\n        y_vec = (B @ y_vec) % b\n\n        # Radical inverse calculation for the new y_vec\n        val = 0.0\n        b_inv_power = 1.0 / b\n        for r in range(m):\n            val += y_vec[r] * b_inv_power\n            b_inv_power /= b\n        coordinates.append(round(val, 12))\n\n    return coordinates\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: b=2, s=3, m=5, n_digits=(1,0,1,1,0), n=13\n        {'b': 2, 's': 3, 'm': 5, 'n_digits': (1, 0, 1, 1, 0)},\n        # Case 2: b=3, s=4, m=6, n_digits=(2,1,0,2,1,1), n=383\n        {'b': 3, 's': 4, 'm': 6, 'n_digits': (2, 1, 0, 2, 1, 1)},\n        # Case 3: b=5, s=1, m=1, n_digits=(4), n=4\n        {'b': 5, 's': 1, 'm': 1, 'n_digits': (4,)},\n        # Case 4: b=7, s=5, m=4, n_digits=(6,0,3,1), n=496\n        {'b': 7, 's': 5, 'm': 4, 'n_digits': (6, 0, 3, 1)},\n        # Case 5: b=3, s=2, m=3, n_digits=(0,0,0), n=0\n        {'b': 3, 's': 2, 'm': 3, 'n_digits': (0, 0, 0)},\n    ]\n\n    results = []\n    for case in test_cases:\n        coords = compute_faure_coordinates(\n            case['b'], case['s'], case['m'], case['n_digits']\n        )\n        results.append(coords)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3308045"}]}