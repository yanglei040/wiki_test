{"hands_on_practices": [{"introduction": "Understanding the theoretical underpinnings of a numerical method is the first step toward implementing it effectively. This exercise uses the fundamental tool of Taylor series analysis to rigorously determine the formal order of accuracy for both a simple first-order (Godunov) and a more sophisticated second-order (MUSCL) reconstruction. By working through this derivation [@problem_id:3514794], you will gain a concrete understanding of how piecewise-linear reconstruction improves accuracy in smooth regions of a flow.", "problem": "Consider the linear advection equation $u_{t} + a u_{x} = 0$ with constant speed $a0$ on a uniform grid with cell centers $x_{i}$ and spacing $\\Delta x$. In a finite-volume discretization used in astrophysical hydrodynamics, the semi-discrete update for the cell average $\\bar{u}_{i}(t)$ involves a numerical flux $F_{i+1/2}$ at each interface $x_{i+1/2} = x_{i} + \\tfrac{1}{2}\\Delta x$. For $a0$, use the upwind form $F_{i+1/2} = a\\,u^{-}_{i+1/2}$, where $u^{-}_{i+1/2}$ is the left-biased reconstructed state at $x_{i+1/2}$ built from cell data at $x_{i}$. Compare the following two reconstructions in smooth regions:\n\n- Piecewise-constant (Godunov): $u^{-}_{i+1/2} = \\bar{u}_{i}$.\n\n- Piecewise-linear Monotonic Upstream-centered Scheme for Conservation Laws (MUSCL) with a Total Variation Diminishing (TVD) limiter that reduces to a centered slope in smooth regions: $u^{-}_{i+1/2} = \\bar{u}_{i} + \\tfrac{1}{2}\\Delta x\\, s_{i}$ with $s_{i} = \\dfrac{\\bar{u}_{i+1}-\\bar{u}_{i-1}}{2\\Delta x}$ in smooth regions.\n\nAssume $u(x,t)$ is sufficiently smooth so that Taylor expansions about $x_{i}$ are valid and that $\\bar{u}_{i}$ denotes the exact cell average $\\bar{u}_{i} = \\dfrac{1}{\\Delta x}\\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t)\\,\\mathrm{d}x$. Using only these fundamental definitions and expansions about $x_{i}$, derive the leading-order truncation error of the numerical flux at $x_{i+1/2}$, i.e., the leading term in $F_{i+1/2} - a\\,u(x_{i+1/2},t)$ as $\\Delta x \\to 0$, for each reconstruction. From these leading terms, determine the formal order $p$ of the numerical flux in smooth regions for each method, defined by $F_{i+1/2} - a\\,u(x_{i+1/2},t) = \\mathcal{O}(\\Delta x^{p})$.\n\nState your final answer as the row vector $\\left(p_{\\mathrm{Godunov}},\\,p_{\\mathrm{MUSCL}}\\right)$. No rounding is required. The final answer must be provided as a single row vector using the LaTeX $\\mathrm{pmatrix}$ environment as specified.", "solution": "The problem requires the derivation of the formal order of accuracy, $p$, for the numerical flux $F_{i+1/2}$ in two finite-volume reconstruction schemes for the linear advection equation $u_t + a u_x = 0$, where the advection speed $a$ is a positive constant. The order $p$ is defined by the truncation error $F_{i+1/2} - a\\,u(x_{i+1/2},t) = \\mathcal{O}(\\Delta x^p)$ in smooth regions of the solution. The analysis will be performed by expressing all quantities as Taylor series expansions.\n\nThe numerical flux for $a > 0$ is given by the upwind formula $F_{i+1/2} = a\\,u^{-}_{i+1/2}$, where $u^{-}_{i+1/2}$ is the reconstructed value of the solution at the left side of the interface $x_{i+1/2}$. The truncation error of the flux is therefore $a\\,(u^{-}_{i+1/2} - u(x_{i+1/2},t))$. The core of the analysis is to determine the leading-order error of the reconstruction, $u^{-}_{i+1/2} - u(x_{i+1/2},t)$.\n\nFor this analysis, we will expand all quantities in a Taylor series about the interface location $x_{i+1/2}$. Let $z = x_{i+1/2}$ and let $v(x) = u(x,t)$ denote the exact solution at time $t$. The goal is to analyze $u^{-}_{i+1/2} - v(z)$. The reconstructions are based on the exact cell averages, $\\bar{u}_{j} = \\frac{1}{\\Delta x}\\int_{x_{j-1/2}}^{x_{j+1/2}} v(x)\\,\\mathrm{d}x$.\n\nFirst, we establish a general expression for a cell average $\\bar{u}_j$ by expanding $v(x)$ about $z = x_{i+1/2}$. For an arbitrary cell $j$, its average is given by:\n$$ \\bar{u}_{j} = \\frac{1}{\\Delta x} \\int_{x_{j-1/2}}^{x_{j+1/2}} \\left( v(z) + v'(z)(x-z) + \\frac{v''(z)}{2}(x-z)^2 + \\mathcal{O}((x-z)^3) \\right) \\mathrm{d}x $$\nLet's evaluate this for the cells relevant to the reconstructions at $x_{i+1/2}$, namely cells $i$, $i+1$, and $i-1$.\n\nFor cell $i$, the integration interval is $[x_{i-1/2}, x_{i+1/2}] = [z-\\Delta x, z]$.\n$$ \\bar{u}_{i} = \\frac{1}{\\Delta x} \\left[ v(z)(x-z) + \\frac{v'(z)}{2}(x-z)^2 + \\frac{v''(z)}{6}(x-z)^3 + \\dots \\right]_{z-\\Delta x}^{z} $$\n$$ \\bar{u}_{i} = \\frac{1}{\\Delta x} \\left( 0 - \\left( v(z)(-\\Delta x) + \\frac{v'(z)}{2}(-\\Delta x)^2 + \\frac{v''(z)}{6}(-\\Delta x)^3 + \\dots \\right) \\right)  $$\n$$ \\bar{u}_{i} = v(z) - \\frac{1}{2}v'(z)\\Delta x + \\frac{1}{6}v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) $$\n\nFor cell $i+1$, the interval is $[x_{i+1/2}, x_{i+3/2}] = [z, z+\\Delta x]$.\n$$ \\bar{u}_{i+1} = \\frac{1}{\\Delta x} \\left[ v(z)(x-z) + \\frac{v'(z)}{2}(x-z)^2 + \\frac{v''(z)}{6}(x-z)^3 + \\dots \\right]_{z}^{z+\\Delta x} $$\n$$ \\bar{u}_{i+1} = v(z) + \\frac{1}{2}v'(z)\\Delta x + \\frac{1}{6}v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) $$\n\nFor cell $i-1$, the interval is $[x_{i-3/2}, x_{i-1/2}] = [z-2\\Delta x, z-\\Delta x]$.\n$$ \\bar{u}_{i-1} = \\frac{1}{\\Delta x} \\left[ v(z)(x-z) + \\frac{v'(z)}{2}(x-z)^2 + \\frac{v''(z)}{6}(x-z)^3 + \\dots \\right]_{z-2\\Delta x}^{z-\\Delta x} $$\n$$ \\bar{u}_{i-1} = \\frac{1}{\\Delta x} \\left( v(z)((-\\Delta x) - (-2\\Delta x)) + \\frac{v'(z)}{2}((-\\Delta x)^2 - (-2\\Delta x)^2) + \\frac{v''(z)}{6}((-\\Delta x)^3 - (-2\\Delta x)^3) + \\dots \\right) $$\n$$ \\bar{u}_{i-1} = \\frac{1}{\\Delta x} \\left( v(z)\\Delta x - \\frac{3}{2}v'(z)\\Delta x^2 + \\frac{7}{6}v''(z)\\Delta x^3 + \\dots \\right) $$\n$$ \\bar{u}_{i-1} = v(z) - \\frac{3}{2}v'(z)\\Delta x + \\frac{7}{6}v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) $$\n\nWith these expressions, we can now analyze each reconstruction.\n\n**1. Piecewise-constant (Godunov) Reconstruction**\n\nThe Godunov reconstruction uses the cell-average value directly:\n$$ u^{-}_{i+1/2} = \\bar{u}_{i} $$\nThe reconstruction error is $u^{-}_{i+1/2} - v(z) = \\bar{u}_i - v(z)$. Using our expansion for $\\bar{u}_i$:\n$$ \\bar{u}_{i} - v(z) = \\left( v(z) - \\frac{1}{2}v'(z)\\Delta x + \\frac{1}{6}v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) \\right) - v(z) $$\n$$ \\bar{u}_{i} - v(z) = -\\frac{1}{2}v'(z)\\Delta x + \\mathcal{O}(\\Delta x^2) $$\nThe leading-order error term is of order $\\mathcal{O}(\\Delta x)$. The truncation error of the flux is:\n$$ F_{i+1/2} - a\\,v(z) = a(\\bar{u}_{i} - v(z)) = -\\frac{a}{2}v'(z)\\Delta x + \\mathcal{O}(\\Delta x^2) $$\nThis is an $\\mathcal{O}(\\Delta x)$ error, so the formal order of the Godunov flux is $p_{\\mathrm{Godunov}} = 1$.\n\n**2. Piecewise-linear (MUSCL) Reconstruction**\n\nThe MUSCL reconstruction is given by:\n$$ u^{-}_{i+1/2} = \\bar{u}_{i} + \\frac{1}{2}\\Delta x\\, s_{i} $$\nwhere the slope $s_i$ in smooth regions is $s_{i} = \\frac{\\bar{u}_{i+1}-\\bar{u}_{i-1}}{2\\Delta x}$. First, we find the expansion for the slope term using our expressions for the cell averages:\n$$ \\bar{u}_{i+1} - \\bar{u}_{i-1} = \\left( v(z) + \\frac{1}{2}v'(z)\\Delta x + \\frac{1}{6}v''(z)\\Delta x^2 \\right) - \\left( v(z) - \\frac{3}{2}v'(z)\\Delta x + \\frac{7}{6}v''(z)\\Delta x^2 \\right) + \\mathcal{O}(\\Delta x^3) $$\n$$ \\bar{u}_{i+1} - \\bar{u}_{i-1} = \\left(\\frac{1}{2} + \\frac{3}{2}\\right) v'(z)\\Delta x + \\left(\\frac{1}{6} - \\frac{7}{6}\\right) v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) $$\n$$ \\bar{u}_{i+1} - \\bar{u}_{i-1} = 2v'(z)\\Delta x - v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) $$\nNow, we compute the slope $s_i$:\n$$ s_{i} = \\frac{2v'(z)\\Delta x - v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3)}{2\\Delta x} = v'(z) - \\frac{1}{2}v''(z)\\Delta x + \\mathcal{O}(\\Delta x^2) $$\nNext, we substitute the expansions for $\\bar{u}_i$ and $s_i$ into the reconstruction formula:\n$$ u^{-}_{i+1/2} = \\left( v(z) - \\frac{1}{2}v'(z)\\Delta x + \\frac{1}{6}v''(z)\\Delta x^2 \\right) + \\frac{1}{2}\\Delta x \\left( v'(z) - \\frac{1}{2}v''(z)\\Delta x \\right) + \\mathcal{O}(\\Delta x^3) $$\n$$ u^{-}_{i+1/2} = v(z) - \\frac{1}{2}v'(z)\\Delta x + \\frac{1}{6}v''(z)\\Delta x^2 + \\frac{1}{2}v'(z)\\Delta x - \\frac{1}{4}v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) $$\nThe terms involving $v'(z)\\Delta x$ cancel:\n$$ u^{-}_{i+1/2} = v(z) + \\left(\\frac{1}{6} - \\frac{1}{4}\\right)v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) $$\n$$ u^{-}_{i+1/2} = v(z) - \\frac{1}{12}v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) $$\nThe reconstruction error is $u^{-}_{i+1/2} - v(z) = -\\frac{1}{12}v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3)$. The leading-order term is of order $\\mathcal{O}(\\Delta x^2)$. The truncation error of the flux is:\n$$ F_{i+1/2} - a\\,v(z) = a(u^{-}_{i+1/2} - v(z)) = -\\frac{a}{12}v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) $$\nThis is an $\\mathcal{O}(\\Delta x^2)$ error, so the formal order of the MUSCL flux is $p_{\\mathrm{MUSCL}} = 2$.\n\nThe orders of the numerical flux for the Godunov and MUSCL methods are $1$ and $2$, respectively.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1  2\n\\end{pmatrix}\n}\n$$", "id": "3514794"}, {"introduction": "With the theoretical benefits of second-order schemes established, the next step is to translate theory into a working code. This practice guides you through the implementation of a complete MUSCL-Hancock scheme, a robust method widely used in astrophysical simulations. You will not only build the scheme from scratch, incorporating a TVD slope limiter to ensure stability, but also perform a convergence study to verify that your implementation achieves the expected second-order accuracy [@problem_id:3514849].", "problem": "Consider the linear advection equation $u_t + a u_x = 0$ with constant advection speed $a \\in \\mathbb{R}$ on the periodic domain $[0,1]$. Let a uniform finite-volume mesh be defined by cells $I_i = [x_{i-1/2}, x_{i+1/2}]$ of width $\\Delta x = 1/N$ with centers $x_i = (i + 1/2)\\Delta x$ for integer indices $i \\in \\{0,1,\\dots,N-1\\}$ and periodic indexing. Denote the cell average at time $t^n$ by $U_i^n \\approx \\frac{1}{\\Delta x}\\int_{I_i} u(x,t^n)\\,dx$. The integral form of conservation over one time step gives the exact update\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x} \\left( f\\big(u(x_{i+1/2}, t)\\big) - f\\big(u(x_{i-1/2}, t)\\big) \\right) \\quad \\text{with} \\quad f(u) = a u.\n$$\nYou are to derive, implement, and test a second-order Monotonic Upstream-centered Scheme for Conservation Laws with the Hancock predictor (MUSCL-Hancock) using the Monotonized Central (MC) slope limiter. Proceed as follows, starting only from the integral conservation law and the definition of the flux, and using a piecewise linear reconstruction within each cell.\n\n1) Derivation. Use a piecewise linear reconstruction within each cell at time $t^n$ of the form\n$$\nU_i(x,t^n) = U_i^n + \\sigma_i \\frac{x - x_i}{\\Delta x},\n$$\nwhere $\\sigma_i$ is a limited slope constructed from neighboring cell averages. Define the MC slope via the minmod function. For any real numbers $p,q$, define $\\operatorname{minmod}(p,q) = \\operatorname{sign}(p) \\min(|p|,|q|)$ if $pq  0$ and $0$ otherwise. Extend this to three arguments by $\\operatorname{minmod}(p,q,r) = \\operatorname{sign}(p)\\min(|p|,|q|,|r|)$ if $p q  0$ and $q r  0$ and $0$ otherwise. The MC-limited slope is\n$$\n\\sigma_i = \\operatorname{minmod}\\!\\left( \\frac{U_{i+1}^n - U_{i-1}^n}{2},\\; 2\\left(U_i^n - U_{i-1}^n\\right),\\; 2\\left(U_{i+1}^n - U_i^n\\right) \\right).\n$$\nForm the left and right interface states at $t^n$ by\n$$\nU_{i+1/2}^{L,n} = U_i^n + \\frac{1}{2}\\sigma_i, \\qquad U_{i+1/2}^{R,n} = U_{i+1}^n - \\frac{1}{2}\\sigma_{i+1}.\n$$\nApply a Hancock predictor to advance these interface states by a half time step $\\Delta t/2$ using local flux differences,\n$$\nU_{i+1/2}^{L,n+1/2} = U_{i+1/2}^{L,n} - \\frac{\\Delta t}{2\\Delta x} \\left( f\\!\\left(U_{i+1/2}^{L,n}\\right) - f\\!\\left(U_{i-1/2}^{R,n}\\right) \\right),\n$$\n$$\nU_{i+1/2}^{R,n+1/2} = U_{i+1/2}^{R,n} - \\frac{\\Delta t}{2\\Delta x} \\left( f\\!\\left(U_{i+3/2}^{L,n}\\right) - f\\!\\left(U_{i+1/2}^{R,n}\\right) \\right).\n$$\nClose the scheme with the Godunov flux for the linear advection equation. For constant $a$, this reduces to upwinding:\n$$\nF_{i+1/2}^{n+1/2} =\n\\begin{cases}\na\\, U_{i+1/2}^{L,n+1/2},  a  0,\\\\\na\\, U_{i+1/2}^{R,n+1/2},  a  0,\\\\\n0,  a = 0.\n\\end{cases}\n$$\nFinally, update the cell averages by\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+1/2}^{n+1/2} - F_{i-1/2}^{n+1/2}\\right).\n$$\nAssume a Courant–Friedrichs–Lewy (CFL) number $\\nu = |a| \\Delta t / \\Delta x \\le 1$.\n\n2) Implementation. Implement the fully discrete MUSCL-Hancock method with the MC limiter and Godunov flux as derived above on $[0,1]$ with periodic boundary conditions. Use the smooth initial condition\n$$\nu(x,0) = \\sin(2\\pi x),\n$$\nwhose exact solution is\n$$\nu(x,t) = \\sin\\!\\left( 2\\pi (x - a t) \\right),\n$$\nunder periodicity. Use cell averages initialized by sampling $u(x,0)$ at cell centers $x_i$. Set the time step from a target CFL number $\\nu$ by $\\Delta t = \\nu \\Delta x / |a|$, then choose an integer number of steps $N_t$ so that the final time $T$ is reached exactly by setting $\\Delta t = T/N_t$ with $N_t = \\lceil T / (\\nu \\Delta x / |a|) \\rceil$, ensuring $\\nu \\le 1$.\n\n3) Error measurement and convergence verification. Measure the discrete $L^1$-error at time $T$ as\n$$\nE_{L^1} = \\sum_{i=0}^{N-1} \\left| U_i^N - u(x_i,T) \\right| \\Delta x,\n$$\nwhere $U_i^N$ is the numerical solution at the final time and $u(x_i,T)$ is the exact solution evaluated at $x_i$ with periodic wrap. For two meshes with sizes $\\Delta x_1$ and $\\Delta x_2$ and corresponding $L^1$-errors $E_1$ and $E_2$, compute the observed convergence rate\n$$\np = \\frac{\\log(E_1/E_2)}{\\log(\\Delta x_1 / \\Delta x_2)}.\n$$\n\n4) Test suite. Use the following parameter sets to test the method. All quantities are nondimensional; no physical units are required.\n- Test A (positive advection, convergence study): $a = 1$, $T = 0.1$, CFL target $\\nu = 0.45$, mesh sizes $N \\in \\{50, 100, 200, 400\\}$.\n- Test B (negative advection, convergence study): $a = -1$, $T = 0.1$, CFL target $\\nu = 0.45$, mesh sizes $N \\in \\{50, 100, 200, 400\\}$.\n- Test C (near-CFL boundary behavior): $a = 1$, $T = 0.1$, CFL target $\\nu = 0.95$, mesh size $N = 200$.\n\nFor Tests A and B, compute the $L^1$-errors for each $N$ and the observed convergence rates between successive refinements: from $N=50$ to $N=100$, from $N=100$ to $N=200$, and from $N=200$ to $N=400$. For each of Tests A and B, also determine a boolean that is true if and only if both of the two finest-grid rates (from $N=100$ to $N=200$ and from $N=200$ to $N=400$) are at least $1.8$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the following order:\n$$\n\\big[ E^{A}_{50}, E^{A}_{100}, E^{A}_{200}, E^{A}_{400},\\; p^{A}_{50\\to 100}, p^{A}_{100\\to 200}, p^{A}_{200\\to 400},\\; E^{B}_{50}, E^{B}_{100}, E^{B}_{200}, E^{B}_{400},\\; p^{B}_{50\\to 100}, p^{B}_{100\\to 200}, p^{B}_{200\\to 400},\\; E^{C}_{200},\\; \\text{okA},\\; \\text{okB} \\big],\n$$\nwhere $E^{A}_{N}$ denotes the $L^1$-error for Test A at resolution $N$, $p^{A}_{N\\to 2N}$ the observed rate between $N$ and $2N$, similarly for Test B, $E^{C}_{200}$ the $L^1$-error for Test C, and the booleans $\\text{okA}$ and $\\text{okB}$ encode the convergence checks as specified. Each numerical entry must be printed as a floating-point number in standard decimal notation, and the booleans as either True or False.", "solution": "The user has provided a well-defined problem in computational physics, specifically concerning the numerical solution of the linear advection equation using a second-order finite-volume method. The problem is scientifically sound, self-contained, and all parameters and methods are specified without ambiguity. It constitutes a standard verification test for a numerical scheme. Therefore, the problem is deemed valid and a full solution will be provided.\n\nThe problem requires the derivation, implementation, and testing of the MUSCL-Hancock scheme for the linear advection equation, $u_t + a u_x = 0$, where $u=u(x,t)$ is a conserved quantity, $a$ is the constant advection speed, and the spatial domain is a periodic unit interval, $x \\in [0,1]$. The core of the finite-volume method is to evolve cell-averaged quantities, $U_i^n$, which approximate the average of $u(x,t)$ over a cell $I_i$ at time $t^n$. The update from time $t^n$ to $t^{n+1}=t^n+\\Delta t$ is given by the exact conservation law in integral form:\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x} \\left( F_{i+1/2} - F_{i-1/2} \\right)\n$$\nHere, $\\Delta x$ is the uniform cell width, and $F_{i \\pm 1/2}$ represents the numerical flux across the cell interfaces at $x_{i \\pm 1/2}$. The challenge is to approximate these fluxes to achieve second-order accuracy in space and time while preventing unphysical oscillations near sharp gradients.\n\nThe MUSCL-Hancock scheme achieves this through a multi-step predictor-corrector approach.\n\n**1. Piecewise Linear Reconstruction**\nFirst-order methods like the Godunov scheme assume a piecewise constant data representation, using only the cell average $U_i^n$. To achieve higher order, we reconstruct a more detailed representation of the solution within each cell. The MUSCL scheme employs a piecewise linear reconstruction:\n$$\nU_i(x,t^n) = U_i^n + \\sigma_i \\frac{x - x_i}{\\Delta x} \\quad \\text{for} \\quad x \\in I_i = [x_{i-1/2}, x_{i+1/2}]\n$$\nHere, $x_i$ is the center of cell $i$, and $\\sigma_i$ is the slope of the solution within that cell. The choice of $\\sigma_i$ is critical. An unlimited centered-difference slope would provide second-order accuracy for smooth solutions but would introduce spurious oscillations near discontinuities (violating the Total Variation Diminishing, or TVD, property).\n\n**2. Slope Limiting**\nTo prevent oscillations, the slope $\\sigma_i$ is \"limited\". The problem specifies the Monotonized Central (MC) limiter. For each cell $i$, we consider three candidate slopes: a centered difference slope, and scaled forward and backward difference slopes. Using the cell averages $U^n$ at time $t^n$, these are:\n- Centered: $\\frac{U_{i+1}^n - U_{i-1}^n}{2}$\n- Forward: $2(U_{i+1}^n - U_i^n)$\n- Backward: $2(U_i^n - U_{i-1}^n)$\n\nThe MC-limited slope $\\sigma_i$ is then computed using the `minmod` function, which selects the candidate with the smallest absolute value if all three have the same sign, and returns zero otherwise. This choice ensures that the reconstruction does not create new local maxima or minima.\n$$\n\\sigma_i = \\operatorname{minmod}\\!\\left( \\frac{U_{i+1}^n - U_{i-1}^n}{2},\\; 2\\left(U_{i+1}^n - U_i^n\\right),\\; 2\\left(U_{i+1}^n - U_i^n\\right) \\right)\n$$\nThe `minmod` function is defined as $\\operatorname{minmod}(p,q,r) = \\operatorname{sign}(p)\\min(|p|,|q|,|r|)$ if $p, q, r$ have the same sign, and $0$ otherwise.\n\n**3. Predictor Step: Time Evolution of Interface States**\nWith the linear reconstruction, we can define unique values at the left and right sides of each cell interface $x_{i+1/2}$:\n$$\nU_{i+1/2}^{L,n} = U_i(x_{i+1/2}, t^n) = U_i^n + \\frac{1}{2}\\sigma_i\n$$\n$$\nU_{i+1/2}^{R,n} = U_{i+1}(x_{i+1/2}, t^n) = U_{i+1}^n - \\frac{1}{2}\\sigma_{i+1}\n$$\nA simple Godunov-type approach would solve the Riemann problem between $U_{i+1/2}^{L,n}$ and $U_{i+1/2}^{R,n}$. To achieve second-order time accuracy, the Hancock predictor step evolves these interface states by a half time-step, $\\Delta t/2$. The governing equation $u_t = -a u_x$ is used to approximate this evolution. For the piecewise linear data, $u_x \\approx \\sigma_i/\\Delta x$ in cell $i$. The evolved solution inside cell $i$ is:\n$$\nU_i(x, t^{n+1/2}) = U_i(x,t^n) - \\frac{\\Delta t}{2} a \\frac{\\sigma_i}{\\Delta x} = U_i^n + \\sigma_i \\frac{x-x_i}{\\Delta x} - \\frac{a \\Delta t}{2 \\Delta x} \\sigma_i\n$$\nEvaluating this at the interfaces gives the time-evolved left and right states. Let $\\nu' = a \\Delta t / \\Delta x$ be the signed CFL number.\nAt the left side of interface $x_{i+1/2}$ (coming from cell $i$):\n$$\nU_{i+1/2}^{L,n+1/2} = U_i(x_{i+1/2}, t^{n+1/2}) = U_i^n + \\frac{1}{2}\\sigma_i - \\frac{a \\Delta t}{2 \\Delta x}\\sigma_i = U_i^n + \\frac{1}{2}(1 - \\nu')\\sigma_i\n$$\nAt the right side of interface $x_{i+1/2}$ (coming from cell $i+1$):\n$$\nU_{i+1/2}^{R,n+1/2} = U_{i+1}(x_{i+1/2}, t^{n+1/2}) = U_{i+1}^n - \\frac{1}{2}\\sigma_{i+1} - \\frac{a \\Delta t}{2 \\Delta x}\\sigma_{i+1} = U_{i+1}^n - \\frac{1}{2}(1 + \\nu')\\sigma_{i+1}\n$$\nThese formulae are equivalent to the more abstract \"flux difference\" formulation presented in the problem statement for the linear advection case, as was verified during the validation phase.\n\n**4. Corrector Step: Flux Calculation and Update**\nThe corrector step uses the time-evolved interface states, $U_{i+1/2}^{L,n+1/2}$ and $U_{i+1/2}^{R,n+1/2}$, to calculate the numerical flux $F_{i+1/2}$. This is now a Riemann problem at time $t^{n+1/2}$. For linear advection with flux $f(u)=au$, the Godunov flux is a simple upwind selection:\n$$\nF_{i+1/2} =\n\\begin{cases}\na\\, U_{i+1/2}^{L,n+1/2},  \\text{if } a > 0 \\\\\na\\, U_{i+1/2}^{R,n+1/2},  \\text{if } a  0 \\\\\n0,  \\text{if } a = 0\n\\end{cases}\n$$\nFinally, the cell averages are updated using the conservative formula:\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x} \\left( F_{i+1/2} - F_{i-1/2} \\right)\n$$\nThis completes one full time step of the scheme. The process is repeated until the final time $T$ is reached. Periodic boundary conditions are handled by appropriate array indexing, for which `numpy.roll` is highly suitable. The time step $\\Delta t$ is chosen to meet a target CFL number $\\nu = |a| \\Delta t / \\Delta x \\le 1$ and to ensure the final time $T$ is an integer multiple of $\\Delta t$. The $L^1$ error is computed against the known exact solution, and convergence rates are calculated to verify that the implementation achieves the expected second-order accuracy for smooth solutions.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to execute the test suite for the MUSCL-Hancock scheme.\n    \"\"\"\n\n    def minmod3_vec(p, q, r):\n        \"\"\"\n        Vectorized three-argument minmod function.\n        minmod(p,q,r) = sign(p)*min(|p|,|q|,|r|) if signs match, 0 otherwise.\n        \"\"\"\n        s_p = np.sign(p)\n        condition = (s_p == np.sign(q))  (s_p == np.sign(r))\n        abs_min = np.minimum(np.abs(p), np.minimum(np.abs(q), np.abs(r)))\n        return np.where(condition, s_p * abs_min, 0.0)\n\n    def run_simulation(N, a, T, nu_target):\n        \"\"\"\n        Runs a single simulation of the linear advection equation.\n\n        Args:\n            N (int): Number of grid cells.\n            a (float): Advection speed.\n            T (float): Final time.\n            nu_target (float): Target CFL number.\n\n        Returns:\n            float: The L1 error at the final time T.\n        \"\"\"\n        # Mesh setup\n        dx = 1.0 / N\n        x = np.linspace(dx / 2.0, 1.0 - dx / 2.0, N)\n\n        # Time step setup\n        if a == 0:\n            dt_target = T\n        else:\n            dt_target = nu_target * dx / abs(a)\n        \n        num_steps = math.ceil(T / dt_target)\n        dt = T / num_steps\n\n        # Initial condition\n        U = np.sin(2 * np.pi * x)\n\n        # Main time loop\n        for _ in range(num_steps):\n            # Periodic boundary handling using np.roll\n            U_p1 = np.roll(U, -1)  # U_{i+1}\n            U_m1 = np.roll(U, 1)   # U_{i-1}\n\n            # 1. Slope Calculation (MC Limiter)\n            delta_U_fwd = U_p1 - U\n            delta_U_bwd = U - U_m1\n            delta_U_cen = (U_p1 - U_m1) / 2.0\n            \n            sigma = minmod3_vec(delta_U_cen, 2 * delta_U_fwd, 2 * delta_U_bwd)\n\n            # 2. Predictor Step\n            nu_prime = a * dt / dx  # Signed CFL number\n            \n            # Evolved left states at interfaces i+1/2\n            U_L_half = U + 0.5 * (1.0 - nu_prime) * sigma\n            \n            # Evolved right states at interfaces i+1/2\n            # Needs sigma from cell i+1, so roll sigma array\n            sigma_p1 = np.roll(sigma, -1)\n            U_R_half = U_p1 - 0.5 * (1.0 + nu_prime) * sigma_p1\n\n            # 3. Corrector Step (Flux Calculation)\n            if a > 0:\n                F = a * U_L_half\n            elif a  0:\n                F = a * U_R_half\n            else:\n                F = np.zeros(N)\n\n            # 4. Update cell averages\n            F_m1 = np.roll(F, 1)  # Flux at interface i-1/2\n            U = U - (dt / dx) * (F - F_m1)\n\n        # Error calculation\n        u_exact = np.sin(2 * np.pi * (x - a * T))\n        l1_error = np.sum(np.abs(U - u_exact)) * dx\n        return l1_error\n\n    def calculate_rate(e1, e2, n1, n2):\n        \"\"\"Calculates convergence rate p from two errors and resolutions.\"\"\"\n        dx1 = 1.0 / n1\n        dx2 = 1.0 / n2\n        if e1 == 0.0 or e2 == 0.0:\n            return 0.0\n        return np.log(e1 / e2) / np.log(dx1 / dx2)\n\n    # Test Suite Parameters\n    params_A = {'a': 1.0, 'T': 0.1, 'nu': 0.45, 'Ns': [50, 100, 200, 400]}\n    params_B = {'a': -1.0, 'T': 0.1, 'nu': 0.45, 'Ns': [50, 100, 200, 400]}\n    params_C = {'a': 1.0, 'T': 0.1, 'nu': 0.95, 'N': 200}\n\n    results = []\n\n    # --- Test A ---\n    errors_A = []\n    for n in params_A['Ns']:\n        err = run_simulation(n, params_A['a'], params_A['T'], params_A['nu'])\n        errors_A.append(err)\n    \n    rates_A = []\n    for i in range(len(params_A['Ns']) - 1):\n        rate = calculate_rate(errors_A[i], errors_A[i+1], params_A['Ns'][i], params_A['Ns'][i+1])\n        rates_A.append(rate)\n    \n    okA = rates_A[-2] >= 1.8 and rates_A[-1] >= 1.8\n    results.extend(errors_A)\n    results.extend(rates_A)\n\n    # --- Test B ---\n    errors_B = []\n    for n in params_B['Ns']:\n        err = run_simulation(n, params_B['a'], params_B['T'], params_B['nu'])\n        errors_B.append(err)\n    \n    rates_B = []\n    for i in range(len(params_B['Ns']) - 1):\n        rate = calculate_rate(errors_B[i], errors_B[i+1], params_B['Ns'][i], params_B['Ns'][i+1])\n        rates_B.append(rate)\n\n    okB = rates_B[-2] >= 1.8 and rates_B[-1] >= 1.8\n    results.extend(errors_B)\n    results.extend(rates_B)\n\n    # --- Test C ---\n    error_C = run_simulation(params_C['N'], params_C['a'], params_C['T'], params_C['nu'])\n    results.append(error_C)\n    \n    # Booleans\n    results.append(okA)\n    results.append(okB)\n\n    # Final print statement\n    print_str = \",\".join(map(str, results))\n    print(f\"[{print_str}]\")\n\nsolve()\n\n```", "id": "3514849"}, {"introduction": "While second-order TVD schemes are powerful, modern computational astrophysics often demands even higher fidelity to capture complex phenomena like turbulence and fine shock structures. This practice introduces the Weighted Essentially Non-Oscillatory (WENO) method, which systematically achieves higher orders of accuracy. By implementing the core logic of a fifth-order WENO reconstruction [@problem_id:3514861], you will learn how to combine information from multiple stencils using nonlinear weights to build a scheme that is both highly accurate and non-oscillatory.", "problem": "Consider the one-dimensional linear advection conservation law\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0,\n$$\nwith constant advection speed $a$ on a uniform grid of spacing $\\Delta x$, and a finite volume representation with cell averages $\\bar{u}_i(t) = \\frac{1}{\\Delta x}\\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t)\\,dx$. In high-resolution shock-capturing methods for computational astrophysics, numerical fluxes at cell interfaces are constructed using high-order non-oscillatory reconstructions. Weighted Essentially Non-Oscillatory (WENO) schemes aim to retain high-order accuracy in smooth regions while avoiding spurious oscillations near discontinuities. Total Variation Diminishing (TVD) schemes with slope limiters achieve similar goals but are limited to lower orders; WENO schemes generalize the concept through nonlinear weights based on smoothness indicators.\n\nStarting from the conservative finite volume formulation and the requirement of upwind bias suitable for advection, use Lax-Friedrichs flux splitting to write the physical flux $f(u)=a u$ as $f(u)=f^+(u)+f^-(u)$ where\n$$\nf^\\pm(u) = \\frac{1}{2}\\left(f(u)\\pm \\alpha u\\right),\\quad \\alpha = |a|.\n$$\nFor the case $a\\ge 0$ and a uniform grid, the left-biased state $u_{i+1/2}^-$ is reconstructed from cell averages $\\{\\bar{u}_{i-2},\\bar{u}_{i-1},\\bar{u}_{i},\\bar{u}_{i+1},\\bar{u}_{i+2}\\}$ using a fifth-order WENO procedure based on three overlapping substencils and nonlinear weights derived from Jiang–Shu smoothness indicators. The small parameter for numerical regularization must be set to $\\varepsilon = 10^{-6}$, and the weight exponent to $p=2$. Assume canonical linear weights appropriate for a uniform grid. The final target quantity for each provided dataset is the reconstructed left interface state $u_{i+1/2}^-$, expressed as a floating-point number.\n\nYour task is to implement a complete, runnable program that, for each test case, takes the five given cell averages $(\\bar{u}_{i-2},\\bar{u}_{i-1},\\bar{u}_{i},\\bar{u}_{i+1},\\bar{u}_{i+2})$ and computes the single reconstructed value $u_{i+1/2}^-$. The advection speed should be taken as $a=1$ (dimensionless), and you should use the Lax-Friedrichs flux split conceptually to justify the upwind-biased left reconstruction, but the requested output is the reconstructed left state $u_{i+1/2}^-$ itself. No physical units are involved; all quantities are dimensionless real numbers. Angles do not appear. Percentages do not appear.\n\nImplement the algorithm in a way that is universally applicable to any modern programming language. The specifics of grids, $a$, $\\varepsilon$, and $p$ are fixed as above. Use the following test suite of discrete datasets:\n\n- Case $1$: $(\\bar{u}_{i-2},\\bar{u}_{i-1},\\bar{u}_{i},\\bar{u}_{i+1},\\bar{u}_{i+2}) = (0.1,\\,0.2,\\,0.3,\\,0.4,\\,0.5)$.\n- Case $2$: $(\\bar{u}_{i-2},\\bar{u}_{i-1},\\bar{u}_{i},\\bar{u}_{i+1},\\bar{u}_{i+2}) = (\\sin(-2),\\,\\sin(-1),\\,\\sin(0),\\,\\sin(1),\\,\\sin(2))$, with the standard sine function in radians, numerically $( -0.9092974268256817,\\,-0.8414709848078965,\\,0.0,\\,0.8414709848078965,\\,0.9092974268256817)$.\n- Case $3$: $(\\bar{u}_{i-2},\\bar{u}_{i-1},\\bar{u}_{i},\\bar{u}_{i+1},\\bar{u}_{i+2}) = (1.0,\\,1.0,\\,1.0,\\,0.0,\\,0.0)$.\n- Case $4$: $(\\bar{u}_{i-2},\\bar{u}_{i-1},\\bar{u}_{i},\\bar{u}_{i+1},\\bar{u}_{i+2}) = (0.7,\\,0.7,\\,0.7,\\,0.7,\\,0.7)$.\n- Case $5$: $(\\bar{u}_{i-2},\\bar{u}_{i-1},\\bar{u}_{i},\\bar{u}_{i+1},\\bar{u}_{i+2}) = (1.0,\\,0.0,\\,-1.0,\\,0.0,\\,1.0)$.\n\nYour program should produce a single line of output containing the reconstructed values for the five cases as a comma-separated list enclosed in square brackets, in the order given above, for example\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5].\n$$\nAll outputs must be floating-point numbers. No other text should be printed.", "solution": "The problem requires the computation of a left-biased, fifth-order Weighted Essentially Non-Oscillatory (WENO) reconstruction of a state variable $u$ at a cell interface, denoted as $u_{i+1/2}^-$. The provided context is the one-dimensional linear advection equation, $\\partial_t u + a\\,\\partial_x u = 0$, on a uniform grid, which is a prototype for hyperbolic conservation laws encountered in computational astrophysics. For a positive advection speed, $a > 0$, an upwind-biased finite volume scheme requires the reconstruction of the state at the left side of the interface $x_{i+1/2}$ to compute the numerical flux. The problem specifies $a=1$, which confirms the necessity of computing $u_{i+1/2}^-$.\n\nThe reconstruction will be performed using a five-point stencil of cell-averaged data, $\\{\\bar{u}_{i-2}, \\bar{u}_{i-1}, \\bar{u}_{i}, \\bar{u}_{i+1}, \\bar{u}_{i+2}\\}$. The fifth-order WENO procedure, specifically the WENO-JS scheme by Jiang and Shu, achieves high accuracy in smooth regions and prevents spurious oscillations at discontinuities by forming a nonlinear combination of several lower-order reconstructions.\n\nThe procedure is as follows:\n\n1.  **Substencil Reconstructions**: The five-point stencil is divided into three overlapping three-point substencils, $S_k$ for $k \\in \\{0,1,2\\}$:\n    -   $S_0 = \\{\\bar{u}_{i-2}, \\bar{u}_{i-1}, \\bar{u}_{i}\\}$\n    -   $S_1 = \\{\\bar{u}_{i-1}, \\bar{u}_{i}, \\bar{u}_{i+1}\\}$\n    -   $S_2 = \\{\\bar{u}_{i}, \\bar{u}_{i+1}, \\bar{u}_{i+2}\\}$\n\n    On each substencil $S_k$, a quadratic polynomial $p_k(x)$ is constructed, and its value at the interface $x_{i+1/2}$ provides a third-order accurate candidate reconstruction, $u_{i+1/2, k}^- = p_k(x_{i+1/2})$. The standard formulas for these reconstructions on a uniform grid are:\n    $$\n    \\begin{aligned}\n    u_{i+1/2, 0}^- = \\frac{1}{3}\\bar{u}_{i-2} - \\frac{7}{6}\\bar{u}_{i-1} + \\frac{11}{6}\\bar{u}_{i} \\\\\n    u_{i+1/2, 1}^- = -\\frac{1}{6}\\bar{u}_{i-1} + \\frac{5}{6}\\bar{u}_{i} + \\frac{1}{3}\\bar{u}_{i+1} \\\\\n    u_{i+1/2, 2}^- = \\frac{1}{3}\\bar{u}_{i} + \\frac{5}{6}\\bar{u}_{i+1} - \\frac{1}{6}\\bar{u}_{i+2}\n    \\end{aligned}\n    $$\n\n2.  **Smoothness Indicators**: To measure the presence of discontinuities in each substencil, smoothness indicators $IS_k$ are computed. These are based on the squared sums of scaled derivatives of the reconstruction polynomials $p_k(x)$. For the WENO5 scheme, the standard Jiang-Shu indicators are:\n    $$\n    \\begin{aligned}\n    IS_0 = \\frac{13}{12}(\\bar{u}_{i-2} - 2\\bar{u}_{i-1} + \\bar{u}_i)^2 + \\frac{1}{4}(\\bar{u}_{i-2} - 4\\bar{u}_{i-1} + 3\\bar{u}_i)^2 \\\\\n    IS_1 = \\frac{13}{12}(\\bar{u}_{i-1} - 2\\bar{u}_i + \\bar{u}_{i+1})^2 + \\frac{1}{4}(\\bar{u}_{i-1} - \\bar{u}_{i+1})^2 \\\\\n    IS_2 = \\frac{13}{12}(\\bar{u}_i - 2\\bar{u}_{i+1} + \\bar{u}_{i+2})^2 + \\frac{1}{4}(3\\bar{u}_i - 4\\bar{u}_{i+1} + \\bar{u}_{i+2})^2\n    \\end{aligned}\n    $$\n\n3.  **Nonlinear Weights**: The final reconstruction is a convex combination of the candidate reconstructions $u_{i+1/2, k}^-$. The weights $\\omega_k$ are computed in a way that gives more influence to reconstructions from smoother stencils (those with smaller $IS_k$). First, un-normalized weights $\\alpha_k$ are calculated using the canonical linear weights $d_k$, the smoothness indicators $IS_k$, a small regularization parameter $\\varepsilon$, and a power $p$:\n    $$\n    \\alpha_k = \\frac{d_k}{(IS_k + \\varepsilon)^p}\n    $$\n    The problem specifies $\\varepsilon = 10^{-6}$ and $p=2$. The canonical linear weights for achieveing fifth-order accuracy for the $u_{i+1/2}^-$ reconstruction are $d_0=0.1$, $d_1=0.6$, and $d_2=0.3$. These weights sum to $1$.\n\n    The final nonlinear weights $\\omega_k$ are obtained by normalizing the $\\alpha_k$:\n    $$\n    \\omega_k = \\frac{\\alpha_k}{\\sum_{j=0}^{2} \\alpha_j}\n    $$\n\n4.  **Final Reconstruction**: The WENO5 reconstructed value at the interface is the weighted average of the candidate reconstructions:\n    $$\n    u_{i+1/2}^- = \\sum_{k=0}^{2} \\omega_k u_{i+1/2, k}^-\n    $$\n\nThis algorithm is determinate and provides a single numerical value for $u_{i+1/2}^-$ given the five input cell averages. The implementation will systematically apply these formulas to each of the provided test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Computes the fifth-order WENO reconstruction for several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Linear data\n        (0.1, 0.2, 0.3, 0.4, 0.5),\n        # Case 2: Sine function\n        (math.sin(-2.0), math.sin(-1.0), math.sin(0.0), math.sin(1.0), math.sin(2.0)),\n        # Case 3: Step function (discontinuity)\n        (1.0, 1.0, 1.0, 0.0, 0.0),\n        # Case 4: Constant data\n        (0.7, 0.7, 0.7, 0.7, 0.7),\n        # Case 5: Oscillatory data\n        (1.0, 0.0, -1.0, 0.0, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = weno5_reconstruct(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.16f}' for r in results)}]\")\n\ndef weno5_reconstruct(u_stencil):\n    \"\"\"\n    Calculates the 5th order WENO reconstruction u_{i+1/2}^-\n    from a 5-point stencil of cell averages.\n\n    Args:\n        u_stencil: A tuple or list of 5 floating-point numbers representing\n                   (u_{i-2}, u_{i-1}, u_{i}, u_{i+1}, u_{i+2}).\n\n    Returns:\n        The reconstructed value at the interface u_{i+1/2}^-.\n    \"\"\"\n    u_im2, u_im1, u_i, u_ip1, u_ip2 = u_stencil\n    \n    # WENO parameters as specified in the problem\n    epsilon = 1e-6\n    p = 2\n    \n    # Canonical linear weights for u_{i+1/2}^-\n    d = np.array([0.1, 0.6, 0.3])\n\n    # Sub-stencil reconstructions (3rd order)\n    u_rec = np.array([\n        (1/3)*u_im2 - (7/6)*u_im1 + (11/6)*u_i,\n        (-1/6)*u_im1 + (5/6)*u_i + (1/3)*u_ip1,\n        (1/3)*u_i + (5/6)*u_ip1 - (1/6)*u_ip2\n    ])\n\n    # Jiang-Shu smoothness indicators\n    IS = np.array([\n        (13/12)*(u_im2 - 2*u_im1 + u_i)**2 + (1/4)*(u_im2 - 4*u_im1 + 3*u_i)**2,\n        (13/12)*(u_im1 - 2*u_i + u_ip1)**2 + (1/4)*(u_im1 - u_ip1)**2,\n        (13/12)*(u_i - 2*u_ip1 + u_ip2)**2 + (1/4)*(3*u_i - 4*u_ip1 + u_ip2)**2\n    ])\n    \n    # Un-normalized nonlinear weights\n    alpha = d / (IS + epsilon)**p\n    \n    # Normalized nonlinear weights\n    omega = alpha / np.sum(alpha)\n    \n    # Final reconstructed value\n    u_reconstructed = np.dot(omega, u_rec)\n    \n    return u_reconstructed\n\nsolve()\n```", "id": "3514861"}]}