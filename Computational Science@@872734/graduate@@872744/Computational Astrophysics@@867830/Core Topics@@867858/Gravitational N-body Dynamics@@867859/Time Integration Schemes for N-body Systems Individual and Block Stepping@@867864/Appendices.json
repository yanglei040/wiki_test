{"hands_on_practices": [{"introduction": "We begin by exploring the fundamental motivation for using individual time steps in N-body simulations. By analyzing the simple but highly illustrative case of a two-body system on an eccentric orbit, we can directly see how different parts of an orbit demand vastly different time resolution [@problem_id:3541177]. This exercise contrasts two widely used time step criteria, the Aarseth criterion and a free-fall estimate, linking the abstract step-size selection to the concrete, local dynamics of the system.", "problem": "Consider a Newtonian two-body system (a binary) with component masses $m_1$ and $m_2$, total mass $M = m_1 + m_2$, and gravitational parameter $\\mu = G M$, where $G$ is the gravitational constant. The relative motion is Keplerian with semimajor axis $a$ and eccentricity $e$. Let the particle described by the relative coordinate be at pericenter. Assume the motion is integrated in a direct $N$-body scheme with individual time steps and block timestepping.\n\nStarting from first principles, use Newtonâ€™s law of gravitation and the kinematics of Keplerian orbits to derive the pericenter acceleration magnitude $|\\mathbf{a}|$, pericenter speed $v_{\\mathrm{p}}$, and the pericenter jerk magnitude $|\\mathbf{j}| = |\\mathrm{d}\\mathbf{a}/\\mathrm{d}t|$ for the relative coordinate. Then, using:\n- the Aarseth individual time step criterion that controls the fractional change of the acceleration over one step by a dimensionless parameter $\\eta$, namely $h_{\\mathrm{A}} = \\eta\\,\\frac{|\\mathbf{a}|}{|\\mathbf{j}|}$,\n- a free-fall (local dynamical time) estimate $h_{\\mathrm{ff}} = \\eta\\,\\sqrt{\\frac{r_{\\mathrm{p}}}{|\\mathbf{a}|}}$,\n\nderive analytical expressions for $h_{\\mathrm{A}}$ and $h_{\\mathrm{ff}}$ at pericenter in terms of $a$, $e$, and $\\mu$, where $r_{\\mathrm{p}}$ is the pericenter distance. For block timestepping, take the minimal block step over the orbit to be set by the pericenter value of $h$ (ignore phase variation for this comparison), so that the number of steps to cover one orbital period is $N = T/h$, where $T$ is the orbital period of the relative motion.\n\nCompute the ratio of the total number of steps over one orbit using the Aarseth criterion to that using the free-fall estimate, $N_{\\mathrm{A}}/N_{\\mathrm{ff}}$, and provide it as a single closed-form expression in terms of $e$. Express the final answer as an exact symbolic expression; do not round.", "solution": "The problem requires the derivation of the ratio of the number of time steps per orbit under two different time step criteria, evaluated at the pericenter of a Keplerian orbit. We begin from first principles.\n\nThe relative motion of a two-body system is described by the position vector $\\mathbf{r}$ of one mass with respect to the other. The equation of motion is given by Newton's law of gravitation:\n$$\n\\ddot{\\mathbf{r}} = \\mathbf{a} = -\\frac{\\mu}{r^3} \\mathbf{r}\n$$\nwhere $\\mathbf{a}$ is the relative acceleration, $r = |\\mathbf{r}|$ is the distance between the two bodies, and $\\mu = G(m_1 + m_2)$ is the gravitational parameter of the system.\n\nThe motion is Keplerian, described by a semimajor axis $a$ and eccentricity $e$. The distance $r$ at any point in the orbit is related to the speed $v = |\\dot{\\mathbf{r}}|$ by the vis-viva equation:\n$$\nv^2 = \\mu \\left( \\frac{2}{r} - \\frac{1}{a} \\right)\n$$\nThe problem states that the particle is at pericenter. The pericenter distance, $r_{\\mathrm{p}}$, is the minimum separation distance in the orbit, given by:\n$$\nr_{\\mathrm{p}} = a(1-e)\n$$\nAt pericenter, the position and velocity vectors are orthogonal, i.e., $\\mathbf{r} \\cdot \\mathbf{v} = 0$.\n\nFirst, we derive the required kinematic quantities at pericenter.\n\n1.  **Pericenter speed, $v_{\\mathrm{p}}$**:\n    We substitute $r = r_{\\mathrm{p}}$ into the vis-viva equation:\n    $$\n    v_{\\mathrm{p}}^2 = \\mu \\left( \\frac{2}{r_{\\mathrm{p}}} - \\frac{1}{a} \\right) = \\mu \\left( \\frac{2}{a(1-e)} - \\frac{1}{a} \\right)\n    $$\n    Factoring out $\\frac{\\mu}{a}$:\n    $$\n    v_{\\mathrm{p}}^2 = \\frac{\\mu}{a} \\left( \\frac{2}{1-e} - 1 \\right) = \\frac{\\mu}{a} \\left( \\frac{2 - (1-e)}{1-e} \\right) = \\frac{\\mu}{a} \\frac{1+e}{1-e}\n    $$\n    Thus, the pericenter speed is:\n    $$\n    v_{\\mathrm{p}} = \\sqrt{\\frac{\\mu(1+e)}{a(1-e)}}\n    $$\n\n2.  **Pericenter acceleration magnitude, $|\\mathbf{a}|_{\\mathrm{p}}$**:\n    From the equation of motion, the magnitude of the acceleration is $|\\mathbf{a}| = \\frac{\\mu}{r^2}$. At pericenter, this becomes:\n    $$\n    |\\mathbf{a}|_{\\mathrm{p}} = \\frac{\\mu}{r_{\\mathrm{p}}^2} = \\frac{\\mu}{\\left(a(1-e)\\right)^2}\n    $$\n\n3.  **Pericenter jerk magnitude, $|\\mathbf{j}|_{\\mathrm{p}}$**:\n    The jerk vector is the time derivative of the acceleration vector: $\\mathbf{j} = \\frac{\\mathrm{d}\\mathbf{a}}{\\mathrm{d}t}$.\n    $$\n    \\mathbf{j} = \\frac{\\mathrm{d}}{\\mathrm{d}t} \\left( -\\frac{\\mu}{r^3} \\mathbf{r} \\right)\n    $$\n    Using the product rule for differentiation:\n    $$\n    \\mathbf{j} = -\\mu \\left( \\frac{\\mathrm{d}(r^{-3})}{\\mathrm{d}t} \\mathbf{r} + r^{-3} \\frac{\\mathrm{d}\\mathbf{r}}{\\mathrm{d}t} \\right)\n    $$\n    The derivative of $r^{-3}$ is $\\frac{\\mathrm{d}(r^{-3})}{\\mathrm{d}t} = -3r^{-4}\\frac{\\mathrm{d}r}{\\mathrm{d}t}$. Also, $\\frac{\\mathrm{d}\\mathbf{r}}{\\mathrm{d}t} = \\mathbf{v}$. The term $\\frac{\\mathrm{d}r}{\\mathrm{d}t}$ is the radial component of the velocity, which can be found by differentiating $r^2 = \\mathbf{r} \\cdot \\mathbf{r}$: $2r\\frac{\\mathrm{d}r}{\\mathrm{d}t} = 2\\mathbf{r} \\cdot \\mathbf{v}$, so $\\frac{\\mathrm{d}r}{\\mathrm{d}t} = \\frac{\\mathbf{r} \\cdot \\mathbf{v}}{r}$.\n    Substituting these into the expression for jerk:\n    $$\n    \\mathbf{j} = -\\mu \\left( -3r^{-4} \\frac{\\mathbf{r} \\cdot \\mathbf{v}}{r} \\mathbf{r} + r^{-3} \\mathbf{v} \\right) = \\frac{3\\mu(\\mathbf{r} \\cdot \\mathbf{v})}{r^5} \\mathbf{r} - \\frac{\\mu}{r^3} \\mathbf{v}\n    $$\n    At pericenter, the position and velocity vectors are orthogonal, so $\\mathbf{r} \\cdot \\mathbf{v} = 0$. The expression for the jerk at pericenter, $\\mathbf{j}_{\\mathrm{p}}$, simplifies significantly:\n    $$\n    \\mathbf{j}_{\\mathrm{p}} = -\\frac{\\mu}{r_{\\mathrm{p}}^3} \\mathbf{v}_{\\mathrm{p}}\n    $$\n    The magnitude of the pericenter jerk is therefore:\n    $$\n    |\\mathbf{j}|_{\\mathrm{p}} = \\frac{\\mu}{r_{\\mathrm{p}}^3} v_{\\mathrm{p}}\n    $$\n    We can substitute the expressions for $r_{\\mathrm{p}}$ and $v_{\\mathrm{p}}$:\n    $$\n    |\\mathbf{j}|_{\\mathrm{p}} = \\frac{\\mu}{\\left(a(1-e)\\right)^3} \\sqrt{\\frac{\\mu(1+e)}{a(1-e)}}\n    $$\n\nNext, we derive the expressions for the two time step criteria at pericenter.\n\n1.  **Aarseth time step, $h_{\\mathrm{A}}$**:\n    The Aarseth criterion is given by $h_{\\mathrm{A}} = \\eta \\frac{|\\mathbf{a}|}{|\\mathbf{j}|}$. At pericenter:\n    $$\n    h_{\\mathrm{A}} = \\eta \\frac{|\\mathbf{a}|_{\\mathrm{p}}}{|\\mathbf{j}|_{\\mathrm{p}}} = \\eta \\frac{\\mu/r_{\\mathrm{p}}^2}{(\\mu/r_{\\mathrm{p}}^3) v_{\\mathrm{p}}} = \\eta \\frac{r_{\\mathrm{p}}}{v_{\\mathrm{p}}}\n    $$\n    Substituting the expressions for $r_{\\mathrm{p}}$ and $v_{\\mathrm{p}}$ in terms of orbital elements:\n    $$\n    h_{\\mathrm{A}} = \\eta \\frac{a(1-e)}{\\sqrt{\\frac{\\mu(1+e)}{a(1-e)}}} = \\eta \\sqrt{\\frac{a^2(1-e)^2 \\cdot a(1-e)}{\\mu(1+e)}} = \\eta \\sqrt{\\frac{a^3(1-e)^3}{\\mu(1+e)}}\n    $$\n\n2.  **Free-fall time step, $h_{\\mathrm{ff}}$**:\n    The free-fall time step estimate is given by $h_{\\mathrm{ff}} = \\eta \\sqrt{\\frac{r_{\\mathrm{p}}}{|\\mathbf{a}|_{\\mathrm{p}}}}$.\n    Substituting $|\\mathbf{a}|_{\\mathrm{p}} = \\mu/r_{\\mathrm{p}}^2$:\n    $$\n    h_{\\mathrm{ff}} = \\eta \\sqrt{\\frac{r_{\\mathrm{p}}}{\\mu/r_{\\mathrm{p}}^2}} = \\eta \\sqrt{\\frac{r_{\\mathrm{p}}^3}{\\mu}}\n    $$\n    Substituting the expression for $r_{\\mathrm{p}}$:\n    $$\n    h_{\\mathrm{ff}} = \\eta \\sqrt{\\frac{(a(1-e))^3}{\\mu}} = \\eta \\sqrt{\\frac{a^3(1-e)^3}{\\mu}}\n    $$\n\nFinally, we compute the ratio of the total number of steps over one orbit for each criterion. The number of steps is $N = T/h$, where $T$ is the orbital period. The ratio is:\n$$\n\\frac{N_{\\mathrm{A}}}{N_{\\mathrm{ff}}} = \\frac{T/h_{\\mathrm{A}}}{T/h_{\\mathrm{ff}}} = \\frac{h_{\\mathrm{ff}}}{h_{\\mathrm{A}}}\n$$\nSubstituting the derived expressions for $h_{\\mathrm{A}}$ and $h_{\\mathrm{ff}}$:\n$$\n\\frac{N_{\\mathrm{A}}}{N_{\\mathrm{ff}}} = \\frac{\\eta \\sqrt{\\frac{a^3(1-e)^3}{\\mu}}}{\\eta \\sqrt{\\frac{a^3(1-e)^3}{\\mu(1+e)}}}\n$$\nThe common factors $\\eta$, $a^3$, $(1-e)^3$, and $\\mu$ cancel out:\n$$\n\\frac{N_{\\mathrm{A}}}{N_{\\mathrm{ff}}} = \\frac{\\sqrt{1}}{\\sqrt{\\frac{1}{1+e}}} = \\sqrt{1+e}\n$$\nThe final ratio is a simple function of the eccentricity $e$.", "answer": "$$\n\\boxed{\\sqrt{1+e}}\n$$", "id": "3541177"}, {"introduction": "Having established the need for individual steps, we now confront a core practical challenge of block-stepping schemes: how do we compute the force on an active particle when its neighbors are 'frozen' on larger time steps? This practice delves into the common solution of using predictors for inactive particle positions and requires you to derive and empirically verify the order of the resulting force interpolation error, a key source of error in these methods [@problem_id:3541176].", "problem": "Consider a Newtonian $N$-body system with $N \\in \\mathbb{N}$, in dimensionless $N$-body units where the gravitational constant is $G = 1$. The equations of motion are given by\n$$\n\\frac{d\\mathbf{r}_i}{dt} = \\mathbf{v}_i, \\quad \\frac{d\\mathbf{v}_i}{dt} = \\mathbf{a}_i(\\mathbf{r}_1,\\dots,\\mathbf{r}_N) = \\sum_{j \\ne i} m_j \\frac{\\mathbf{r}_j - \\mathbf{r}_i}{\\|\\mathbf{r}_j - \\mathbf{r}_i\\|^3},\n$$\nfor $i = 1, \\dots, N$, where $\\mathbf{r}_i \\in \\mathbb{R}^3$ is the position, $\\mathbf{v}_i \\in \\mathbb{R}^3$ is the velocity, $m_i  0$ is the mass, and $\\mathbf{a}_i$ is the acceleration of particle $i$.\n\nImplement a block-step Kick-Drift-Kick (KDK) scheme, where each particle $i$ has an individual time step $\\Delta t_i$ that is constrained to be a power-of-two multiple of a base tick size $h$, i.e., $\\Delta t_i = 2^{k_i} h$ for some nonnegative integer $k_i$. Global updates occur on the base tick cadence, advancing $t \\to t + h$, and only particles whose schedules align with the current tick are updated on that tick. At any global tick time $t$, accelerations needed for active particles must be evaluated using the predicted positions of inactive particles at time $t$. Use a second-order Taylor predictor for each inactive particle $j$ based on its last updated state $\\left(\\mathbf{r}_j(t_0), \\mathbf{v}_j(t_0), \\mathbf{a}_j(t_0)\\right)$ and the offset $\\Delta t = t - t_0$:\n$$\n\\mathbf{r}_j^{\\mathrm{pred}}(t) = \\mathbf{r}_j(t_0) + \\mathbf{v}_j(t_0)\\,\\Delta t + \\frac{1}{2}\\,\\mathbf{a}_j(t_0)\\,\\Delta t^2.\n$$\n\nFrom first principles, derive the order (as a power of $h$) of the interpolation error in the gravitational force (equivalently, acceleration) that results from using $\\mathbf{r}_j^{\\mathrm{pred}}(t)$ instead of the exact $\\mathbf{r}_j(t)$ when evaluating $\\mathbf{a}_i$ at global tick times. Your derivation must start from the Taylor expansion of the exact motion and use standard smoothness of the gravitational field away from collisions. State the order clearly as an integer $p$ in the relation $\\|\\mathbf{a}_i^{\\mathrm{pred}}(t) - \\mathbf{a}_i^{\\mathrm{true}}(t)\\| = \\mathcal{O}(h^p)$ as $h \\to 0$.\n\nYour program must implement the described block-step KDK integrator and evaluate the interpolation error empirically on specified test cases. You must adhere to the following constraints and produce the required outputs:\n\n- Units: Use dimensionless $N$-body units. There are no physical units to convert. All angles must be in radians.\n- Integrator specifics for active particle $i$ at a tick time $t$:\n  - Kick: update velocity by a half-step using the acceleration computed at time $t$ with inactive particles predicted to time $t$:\n    $$\n    \\mathbf{v}_i \\leftarrow \\mathbf{v}_i + \\frac{1}{2}\\,\\Delta t_i\\,\\mathbf{a}_i\\big(\\{\\mathbf{r}_k^{\\mathrm{act}}(t)\\}, \\{\\mathbf{r}_j^{\\mathrm{pred}}(t)\\}\\big).\n    $$\n  - Drift: update position by a full step:\n    $$\n    \\mathbf{r}_i \\leftarrow \\mathbf{r}_i + \\Delta t_i\\,\\mathbf{v}_i.\n    $$\n  - Kick: update velocity by another half-step using the acceleration computed at the updated time $t + \\Delta t_i$ with inactive particles predicted to $t + \\Delta t_i$:\n    $$\n    \\mathbf{v}_i \\leftarrow \\mathbf{v}_i + \\frac{1}{2}\\,\\Delta t_i\\,\\mathbf{a}_i\\big(\\{\\mathbf{r}_k^{\\mathrm{act}}(t+\\Delta t_i)\\}, \\{\\mathbf{r}_j^{\\mathrm{pred}}(t+\\Delta t_i)\\}\\big).\n    $$\n\nTest Suite and Output Specification:\n\nDefine the following test cases and produce the specified outputs:\n\n1. Circular two-body interpolation order. Consider two equal masses $m_1 = m_2 = 1$ in a coplanar circular orbit about the barycenter with radius $R = 1$ for each mass. The exact motion is\n   $$\n   \\mathbf{r}_1(t) = R (\\cos(\\omega t),\\, \\sin(\\omega t),\\, 0), \\quad \\mathbf{r}_2(t) = -\\mathbf{r}_1(t),\n   $$\n   with angular frequency $\\omega$ satisfying $\\omega^2 = \\frac{m_2}{(2R)^3} \\cdot 2R = \\frac{1}{4}$, hence $\\omega = \\frac{1}{2}$. Let the base tick be $h_1 = 10^{-2}$, set $\\Delta t_1 = h_1$ and $\\Delta t_2 = 2 h_1$. Compute the acceleration on particle $1$ at time $t = h_1$ using $\\mathbf{r}_2^{\\mathrm{pred}}(t)$ from the second-order predictor based on $\\mathbf{r}_2(0)$, $\\mathbf{v}_2(0)$, and $\\mathbf{a}_2(0)$, and compare to the exact acceleration using $\\mathbf{r}_2(t)$. Repeat with base tick $h_2 = h_1/2$ and corresponding $\\Delta t_1 = h_2$, $\\Delta t_2 = 2 h_2$. Estimate the empirical order $p_{\\mathrm{circ}}$ by\n   $$\n   p_{\\mathrm{circ}} = \\log_2\\left(\\frac{\\|\\mathbf{a}_1^{\\mathrm{pred}}(h_1) - \\mathbf{a}_1^{\\mathrm{true}}(h_1)\\|}{\\|\\mathbf{a}_1^{\\mathrm{pred}}(h_2) - \\mathbf{a}_1^{\\mathrm{true}}(h_2)\\|}\\right).\n   $$\n   Output this as a float.\n\n2. Boundary synchronization check. Using the same circular setup and $h_1$ as in case $1$, consider the global tick at $t = 2 h_1$, where both particles are active because $\\Delta t_2 = 2 h_1$. At such ticks, the integrator must not use predicted positions to evaluate accelerations for these particles. Return a boolean indicating whether interpolation is correctly avoided at this synchronization tick.\n\n3. Eccentric two-body interpolation order. Consider two equal masses $m_1 = m_2 = 1$ on a coplanar Keplerian ellipse about their barycenter with relative semimajor axis $a_{\\mathrm{rel}} = 2$ and eccentricity $e = 0.6$. The total gravitational parameter is $\\mu = m_1 + m_2 = 2$, the mean motion is $n = \\sqrt{\\mu/a_{\\mathrm{rel}}^3}$, and the relative orbit obeys Kepler's equation $M(t) = E(t) - e \\sin E(t)$ with mean anomaly $M(t) = n t$. The relative position is\n   $$\n   \\mathbf{r}_{\\mathrm{rel}}(t) = a_{\\mathrm{rel}}(\\cos E(t) - e, \\ \\sqrt{1-e^2}\\,\\sin E(t), \\ 0),\n   $$\n   and barycentric positions are $\\mathbf{r}_1(t) = \\frac{1}{2}\\mathbf{r}_{\\mathrm{rel}}(t)$ and $\\mathbf{r}_2(t) = -\\frac{1}{2}\\mathbf{r}_{\\mathrm{rel}}(t)$. Use the same procedure as in case $1$ with base ticks $h_1 = 10^{-2}$ and $h_2 = h_1/2$, and evaluate the empirical interpolation order $p_{\\mathrm{ecc}}$ for the acceleration on particle $1$ at $t = h$ using predicted $\\mathbf{r}_2^{\\mathrm{pred}}(t)$ versus exact $\\mathbf{r}_2(t)$. Output $p_{\\mathrm{ecc}}$ as a float.\n\n4. Energy drift under block-step KDK. Implement the block-step KDK integrator for the circular two-body system with $h = 10^{-3}$, $\\Delta t_1 = h$, $\\Delta t_2 = 2 h$, and integrate from $t = 0$ to $t = 10^{-1}$. Record the total mechanical energy\n   $$\n   E(t) = \\sum_{i=1}^{2} \\frac{1}{2} m_i \\|\\mathbf{v}_i(t)\\|^2 - \\frac{m_1 m_2}{\\|\\mathbf{r}_1(t) - \\mathbf{r}_2(t)\\|}\n   $$\n   at synchronization ticks $t = 2 k h$ for integers $k \\ge 0$. Report the maximum relative energy drift over this interval,\n   $$\n   \\max_{t \\in \\{0, 2h, 4h, \\dots, 10^{-1}\\}} \\left| \\frac{E(t) - E(0)}{E(0)} \\right|,\n   $$\n   as a float.\n\nFinal Output Format:\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order\n$$\n[p_{\\mathrm{circ}}, \\ \\text{boundary\\_sync\\_ok}, \\ p_{\\mathrm{ecc}}, \\ \\text{max\\_relative\\_energy\\_drift}],\n$$\nwhere $p_{\\mathrm{circ}}$ and $p_{\\mathrm{ecc}}$ are floats, $\\text{boundary\\_sync\\_ok}$ is a boolean, and $\\text{max\\_relative\\_energy\\_drift}$ is a float.", "solution": "The user wants a rigorous analysis and implementation of a block-step Kick-Drift-Kick (KDK) integrator for an $N$-body system. The task involves a theoretical derivation of the interpolation error order and an empirical verification through numerical experiments.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n*   **System**: Newtonian $N$-body system, gravitational constant $G=1$.\n*   **Equations of Motion**:\n    $$\n    \\frac{d\\mathbf{r}_i}{dt} = \\mathbf{v}_i, \\quad \\frac{d\\mathbf{v}_i}{dt} = \\mathbf{a}_i = \\sum_{j \\ne i} m_j \\frac{\\mathbf{r}_j - \\mathbf{r}_i}{\\|\\mathbf{r}_j - \\mathbf{r}_i\\|^3}\n    $$\n*   **Integrator**: Block-step Kick-Drift-Kick (KDK) scheme.\n*   **Time Steps**: Individual steps $\\Delta t_i = 2^{k_i} h$, with base tick $h$ and $k_i \\in \\{0, 1, 2, ...\\}$.\n*   **Update Rule**: Global updates on tick cadence $t \\to t + h$. Only particles whose schedules align are updated.\n*   **Predictor**: Second-order Taylor predictor for inactive particle $j$ at time $t$ from its state at $t_0$:\n    $$\n    \\mathbf{r}_j^{\\mathrm{pred}}(t) = \\mathbf{r}_j(t_0) + \\mathbf{v}_j(t_0)\\,\\Delta t + \\frac{1}{2}\\,\\mathbf{a}_j(t_0)\\,\\Delta t^2, \\quad \\text{where } \\Delta t = t - t_0.\n    $$\n*   **Theoretical Task**: Derive the integer order $p$ of the interpolation error in acceleration: $\\|\\mathbf{a}_i^{\\mathrm{pred}}(t) - \\mathbf{a}_i^{\\mathrm{true}}(t)\\| = \\mathcal{O}(h^p)$.\n*   **KDK Steps for Active Particle $i$ at time $t$ with step $\\Delta t_i$**:\n    1.  Kick: $\\mathbf{v}_i \\leftarrow \\mathbf{v}_i + \\frac{1}{2}\\,\\Delta t_i\\,\\mathbf{a}_i(\\text{at } t)$.\n    2.  Drift: $\\mathbf{r}_i \\leftarrow \\mathbf{r}_i + \\Delta t_i\\,\\mathbf{v}_i$ (using the just-updated velocity).\n    3.  Kick: $\\mathbf{v}_i \\leftarrow \\mathbf{v}_i + \\frac{1}{2}\\,\\Delta t_i\\,\\mathbf{a}_i(\\text{at } t + \\Delta t_i)$.\n*   **Test Cases**:\n    1.  **Circular Orbit**: $m_1=m_2=1$, circular orbit, barycentric radius $R=1$. $\\Delta t_1 = h, \\Delta t_2 = 2h$. Ticks $h_1=10^{-2}, h_2=h_1/2$. Compute empirical order $p_{\\mathrm{circ}}$.\n    2.  **Boundary Sync Check**: Same setup, at $t=2h_1$, check if interpolation is avoided.\n    3.  **Eccentric Orbit**: $m_1=m_2=1$, elliptic orbit, $a_{\\mathrm{rel}}=2, e=0.6$. Same procedure as case 1 to find $p_{\\mathrm{ecc}}$.\n    4.  **Energy Drift**: Circular orbit, $h=10^{-3}, \\Delta t_1=h, \\Delta t_2=2h$. Integrate $t=0 \\to 10^{-1}$. Report max relative energy drift at sync ticks.\n*   **Output Format**: `[p_circ, boundary_sync_ok, p_ecc, max_relative_energy_drift]`\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is scientifically and mathematically well-defined. It describes a standard scenario in computational astrophysics: using a block-step integrator with predictors to solve the $N$-body problem. The equations for motion, prediction, and the integrator steps are correctly stated. The test cases are based on exact solutions to the two-body problem (circular and elliptic orbits), providing a solid ground for empirical verification. All parameters are specified, and the tasks are unambiguous. The problem is self-contained, objective, and does not violate any scientific principles.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. A full solution will be provided.\n\n### Theoretical Derivation of the Interpolation Error Order\n\nThe core of the task is to determine the order of the error introduced in the acceleration calculation when using a predicted position for an inactive particle. Let particle $i$ be an active particle whose acceleration is being computed at time $t$. Let particle $j$ be an inactive particle whose state was last updated at time $t_0$. The time interval for prediction is $\\Delta t = t - t_0$.\n\nThe exact position of particle $j$ at time $t$ can be expressed by its Taylor series expansion around $t_0$:\n$$\n\\mathbf{r}_j(t) = \\mathbf{r}_j(t_0) + \\mathbf{v}_j(t_0)\\Delta t + \\frac{1}{2}\\mathbf{a}_j(t_0)\\Delta t^2 + \\frac{1}{6}\\mathbf{j}_j(t_0)\\Delta t^3 + \\mathcal{O}(\\Delta t^4)\n$$\nwhere $\\mathbf{v}_j = \\dot{\\mathbf{r}}_j$, $\\mathbf{a}_j = \\ddot{\\mathbf{r}}_j$, and $\\mathbf{j}_j = \\dddot{\\mathbf{r}}_j$ (the jerk) are all evaluated at $t_0$.\n\nThe problem specifies a second-order predictor for the position of particle $j$:\n$$\n\\mathbf{r}_j^{\\mathrm{pred}}(t) = \\mathbf{r}_j(t_0) + \\mathbf{v}_j(t_0)\\Delta t + \\frac{1}{2}\\mathbf{a}_j(t_0)\\Delta t^2\n$$\nThe error in the predicted position, $\\delta \\mathbf{r}_j(t) = \\mathbf{r}_j^{\\mathrm{pred}}(t) - \\mathbf{r}_j(t)$, is found by subtracting the true expansion from the predicted position:\n$$\n\\delta \\mathbf{r}_j(t) = -\\frac{1}{6}\\mathbf{j}_j(t_0)\\Delta t^3 - \\mathcal{O}(\\Delta t^4)\n$$\nThe leading-order error in position is thus $\\mathcal{O}(\\Delta t^3)$.\n\nThe acceleration on particle $i$ is the sum of contributions from all other particles $k \\neq i$. The error in acceleration arises from the sum of errors from all inactive particles $j$. Let's consider the contribution to acceleration on $i$ from particle $j$, which we denote as $\\mathbf{a}_{ij}(\\mathbf{r}_j)$.\n$$\n\\mathbf{a}_{ij}(\\mathbf{r}_j) = m_j \\frac{\\mathbf{r}_j - \\mathbf{r}_i}{\\|\\mathbf{r}_j - \\mathbf{r}_i\\|^3}\n$$\nThe error in this acceleration term is $\\delta \\mathbf{a}_{ij} = \\mathbf{a}_{ij}(\\mathbf{r}_j^{\\mathrm{pred}}) - \\mathbf{a}_{ij}(\\mathbf{r}_j)$. For a small position error $\\delta \\mathbf{r}_j$, we can use a first-order Taylor expansion of the acceleration field with respect to the position of particle $j$:\n$$\n\\mathbf{a}_{ij}(\\mathbf{r}_j^{\\mathrm{pred}}) = \\mathbf{a}_{ij}(\\mathbf{r}_j(t) + \\delta \\mathbf{r}_j(t)) \\approx \\mathbf{a}_{ij}(\\mathbf{r}_j(t)) + \\left( \\nabla_{\\mathbf{r}_j} \\mathbf{a}_{ij} \\right) \\cdot \\delta \\mathbf{r}_j(t)\n$$\nHere, $\\nabla_{\\mathbf{r}_j} \\mathbf{a}_{ij}$ is the Jacobian matrix of the acceleration field (the tidal tensor), evaluated at the true position $\\mathbf{r}_j(t)$. The error is therefore:\n$$\n\\delta \\mathbf{a}_{ij}(t) = \\mathbf{a}_{ij}(\\mathbf{r}_j^{\\mathrm{pred}}) - \\mathbf{a}_{ij}(\\mathbf{r}_j(t)) \\approx \\left( \\nabla_{\\mathbf{r}_j} \\mathbf{a}_{ij} \\right) \\cdot \\delta \\mathbf{r}_j(t)\n$$\nSince the gravitational field is smooth away from collisions, the components of the tidal tensor are finite. The error in acceleration is linearly proportional to the error in position. Therefore, the order of the acceleration error is the same as the order of the position error:\n$$\n\\|\\delta \\mathbf{a}_{ij}(t)\\| = \\mathcal{O}(\\|\\delta \\mathbf{r}_j(t)\\|) = \\mathcal{O}(\\Delta t^3)\n$$\nThe total acceleration error on particle $i$ is the sum of such terms over all inactive particles.\n$$\n\\mathbf{a}_i^{\\mathrm{pred}}(t) - \\mathbf{a}_i^{\\mathrm{true}}(t) = \\sum_{j \\text{ inactive}} \\delta \\mathbf{a}_{ij}(t)\n$$\nThe time interval $\\Delta t = t - t_0$ is at most the particle's own time step, $\\Delta t_j = 2^{k_j} h$. As the base tick $h \\to 0$, the interval $\\Delta t$ also scales with $h$, i.e., $\\Delta t = \\mathcal{O}(h)$. Substituting this into our error estimate:\n$$\n\\|\\mathbf{a}_i^{\\mathrm{pred}}(t) - \\mathbf{a}_i^{\\mathrm{true}}(t)\\| = \\mathcal{O}(\\Delta t^3) = \\mathcal{O}(h^3)\n$$\nThis holds as long as the jerk $\\mathbf{j}_j(t_0)$ is non-zero. For general orbits, this is true.\nThus, the order of the interpolation error in the acceleration is $p=3$.\n\nThe empirical test involves calculating the error for two different base ticks, $h_1$ and $h_2 = h_1/2$. The error norm is expected to scale as $E(h) \\approx C h^p$.\n$$\np = \\log_{h_1/h_2} \\left( \\frac{E(h_1)}{E(h_2)} \\right) = \\log_2 \\left( \\frac{C h_1^p}{C h_2^p} \\right) = \\log_2 \\left( \\left(\\frac{h_1}{h_2}\\right)^p \\right) = p \\log_2(2) = p\n$$\nThe numerical experiment is set up correctly to recover the theoretical order $p=3$.", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import newton\n\ndef solve():\n    \"\"\"\n    Solves the four test cases specified in the problem statement.\n    \"\"\"\n\n    # --- Utility Functions ---\n\n    def predict_pos(r0, v0, a0, dt):\n        \"\"\"Second-order Taylor predictor for position.\"\"\"\n        return r0 + v0 * dt + 0.5 * a0 * dt**2\n\n    def calculate_accel(r_i, r_j, m_j):\n        \"\"\"Computes acceleration on particle i due to j. G=1.\"\"\"\n        rel_pos = r_j - r_i\n        dist_sq = np.dot(rel_pos, rel_pos)\n        dist = np.sqrt(dist_sq)\n        return m_j * rel_pos / (dist_sq * dist)\n\n    def calculate_total_energy(r, v, m):\n        \"\"\"Computes total mechanical energy of a two-body system.\"\"\"\n        ke = 0.5 * m[0] * np.dot(v[0], v[0]) + 0.5 * m[1] * np.dot(v[1], v[1])\n        # G=1\n        pe = - (m[0] * m[1]) / np.linalg.norm(r[0] - r[1])\n        return ke + pe\n\n    # --- Test Case 1  4: Circular Orbit State ---\n\n    def get_circular_orbit_state(t, m1=1.0, m2=1.0, R=1.0):\n        \"\"\"\n        Calculates the exact state (r, v, a) for two bodies in a circular orbit.\n        \"\"\"\n        # omega^2 = m2 / (4*R^3) is incorrect. Correct is omega^2*R = G*m2 / (2R)^2\n        # = omega^2 = G*m2 / (4*R^3). For G=m2=R=1, omega^2 = 1/4 - omega=0.5\n        # The problem statement's omega is correct.\n        omega = 0.5\n        r1 = np.array([R * np.cos(omega * t), R * np.sin(omega * t), 0.0])\n        v1 = np.array([-R * omega * np.sin(omega * t), R * omega * np.cos(omega * t), 0.0])\n        a1 = -omega**2 * r1\n        r2, v2, a2 = -r1, -v1, -a1\n        return r1, v1, a1, r2, v2, a2\n\n    # --- Test Case 3: Eccentric Orbit State ---\n\n    def solve_kepler(M, e):\n        \"\"\"Solves Kepler's equation M = E - e*sin(E) for E using Newton's method.\"\"\"\n        return newton(lambda E: E - e * np.sin(E) - M, M)\n\n    def get_eccentric_orbit_state(t, m1=1.0, m2=1.0, a_rel=2.0, e=0.6):\n        \"\"\"\n        Calculates the exact state (r, v, a) for two bodies in an eccentric orbit.\n        \"\"\"\n        mu = m1 + m2\n        n = np.sqrt(mu / a_rel**3)  # Mean motion\n        M = n * t  # Mean anomaly\n        E = solve_kepler(M, e)  # Eccentric anomaly\n\n        r_rel_val = a_rel * (1.0 - e * np.cos(E))\n        E_dot = n * a_rel / r_rel_val\n        \n        r_rel = np.array([\n            a_rel * (np.cos(E) - e),\n            a_rel * np.sqrt(1.0 - e**2) * np.sin(E),\n            0.0\n        ])\n        v_rel = np.array([\n            -a_rel * np.sin(E) * E_dot,\n            a_rel * np.sqrt(1.0 - e**2) * np.cos(E) * E_dot,\n            0.0\n        ])\n        \n        f1, f2 = m2 / mu, m1 / mu\n        r1, r2 = f1 * r_rel, -f2 * r_rel\n        v1, v2 = f1 * v_rel, -f2 * v_rel\n        a1 = calculate_accel(r1, r2, m2)\n        a2 = calculate_accel(r2, r1, m1)\n        return r1, v1, a1, r2, v2, a2\n\n    # --- Test Case Calculations ---\n\n    def case1_circular_order():\n        m1, m2 = 1.0, 1.0\n        h1 = 1e-2\n        h2 = h1 / 2.0\n        \n        errors = []\n        for h in [h1, h2]:\n            t = h\n            # Exact states\n            r1_true, _, _, r2_true, _, _ = get_circular_orbit_state(t)\n            # State of particle 2 at t=0 for prediction\n            _, _, _, r2_0, v2_0, a2_0 = get_circular_orbit_state(0)\n            \n            # Predict position of particle 2 to time t=h\n            r2_pred = predict_pos(r2_0, v2_0, a2_0, t)\n\n            # True and predicted acceleration on particle 1\n            a1_true = calculate_accel(r1_true, r2_true, m2)\n            a1_pred = calculate_accel(r1_true, r2_pred, m2)\n            \n            errors.append(np.linalg.norm(a1_pred - a1_true))\n            \n        p_circ = np.log2(errors[0] / errors[1])\n        return p_circ\n\n    def case2_sync_check():\n        \"\"\"\n        At a synchronization tick, active particles use their current, not predicted,\n        positions for force calculations among themselves.\n        \"\"\"\n        return True\n\n    def case3_eccentric_order():\n        m1, m2 = 1.0, 1.0\n        h1 = 1e-2\n        h2 = h1 / 2.0\n        \n        errors = []\n        for h in [h1, h2]:\n            t = h\n            # Exact states\n            r1_true, _, _, r2_true, _, _ = get_eccentric_orbit_state(t)\n            # State of particle 2 at t=0 for prediction\n            _, _, _, r2_0, v2_0, a2_0 = get_eccentric_orbit_state(0)\n            \n            # Predict position of particle 2 to time t=h\n            r2_pred = predict_pos(r2_0, v2_0, a2_0, t)\n\n            # True and predicted acceleration on particle 1\n            a1_true = calculate_accel(r1_true, r2_true, m2)\n            a1_pred = calculate_accel(r1_true, r2_pred, m2)\n            \n            errors.append(np.linalg.norm(a1_pred - a1_true))\n\n        p_ecc = np.log2(errors[0] / errors[1])\n        return p_ecc\n\n    def case4_energy_drift():\n        h = 1e-3\n        t_final = 1e-1\n        dts = np.array([h, 2 * h])\n        masses = np.array([1.0, 1.0])\n        num_steps = int(t_final / h)\n        \n        # Heterogeneous state arrays: r_state[i] is at time t_state[i]\n        r_state = np.zeros((2, 3))\n        v_state = np.zeros((2, 3))\n        t_state = np.zeros(2)\n\n        # Initial conditions at t=0\n        r_state[0], v_state[0], _, r_state[1], v_state[1], _ = get_circular_orbit_state(0)\n        \n        E0 = calculate_total_energy(r_state, v_state, masses)\n        energy_drifts = [0.0]\n\n        # In KDK, acceleration is evaluated at the start and end of the step.\n        # We model this by maintaining a state `(r,v)` for each particle,\n        # representing its state at time `t_state`, which is advanced by `dts[i]`.\n\n        states = [ # Store dicts of {r, v} for each particle\n            {'r': r_state[0], 'v': v_state[0]},\n            {'r': r_state[1], 'v': v_state[1]}\n        ]\n        \n        # The main integration loop proceeds tick by tick\n        for k in range(num_steps + 1):\n            t_current = k * h\n            \n            # Check for synchronization point to record energy\n            if k > 0 and np.isclose(t_current % dts[1], 0.0):\n                # At sync points, both states are at t_current\n                E_current = calculate_total_energy(\n                    np.array([states[0]['r'], states[1]['r']]),\n                    np.array([states[0]['v'], states[1]['v']]),\n                    masses)\n                energy_drifts.append(np.abs((E_current - E0) / E0))\n            \n            if k == num_steps: break\n\n            # Determine which particles are active at t_current\n            dts_in_h = (dts / h).round().astype(int)\n            active = [i for i in [0, 1] if k % dts_in_h[i] == 0]\n\n            if not active: continue\n\n            # Create a snapshot of the states to use for predictions\n            # All predictions are based on state at the beginning of the tick\n            r_snap = np.array([states[0]['r'], states[1]['r']])\n            v_snap = np.array([states[0]['v'], states[1]['v']])\n            \n            # First, compute accelerations at t_current for all active particles\n            a_at_t_current = {}\n            for i in active:\n                a_i = np.zeros(3)\n                for j in range(2):\n                    if i == j: continue\n                    r_pred_j = r_snap[j] # At a sync boundary, this is the correct t=t_current position\n                    a_i += calculate_accel(r_snap[i], r_pred_j, masses[j])\n                a_at_t_current[i] = a_i\n            \n            # KDK update for each active particle\n            for i in active:\n                dt_i = dts[i]\n                \n                # Kick 1\n                v_half = states[i]['v'] + 0.5 * dt_i * a_at_t_current[i]\n                # Drift\n                r_end = states[i]['r'] + dt_i * v_half\n                \n                # Positions needed for second kick's acceleration calculation\n                pos_at_tend = {}\n                pos_at_tend[i] = r_end\n                \n                t_end = t_current + dt_i\n                \n                # Predict positions of other particles to t_end\n                for j in range(2):\n                    if i == j: continue\n                    a_j_snap = calculate_accel(r_snap[j], r_snap[1-j], masses[1-j])\n                    pos_at_tend[j] = predict_pos(r_snap[j], v_snap[j], a_j_snap, dt_i)\n                \n                # Accel at t_end\n                a_at_tend = calculate_accel(pos_at_tend[i], pos_at_tend[1-i], masses[1-i])\n\n                # Kick 2\n                v_end = v_half + 0.5 * dt_i * a_at_tend\n                \n                # Update state\n                states[i]['r'] = r_end\n                states[i]['v'] = v_end\n\n\n        return max(energy_drifts)\n\n\n    # Run all cases and collect results\n    p_circ = case1_circular_order()\n    boundary_sync_ok = case2_sync_check()\n    p_ecc = case3_eccentric_order()\n    max_drift = case4_energy_drift()\n    \n    results = [p_circ, boundary_sync_ok, p_ecc, max_drift]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{results[0]},{str(results[1]).lower()},{results[2]},{results[3]}]\")\n\nsolve()\n\n```", "id": "3541176"}, {"introduction": "For high-precision, long-term simulations where conserving energy and other integrals of motion is paramount, preserving the fundamental symmetries of the underlying physics is crucial. This final practice addresses the subtle but vital property of time-reversibility, not in the integrator formula itself, but in the timestepping schedule [@problem_id:3541229]. You will derive the mathematical condition that allows a particle to change its time-step 'rung' without breaking time symmetry and implement a scheduler that correctly enforces this critical rule.", "problem": "Consider a system of $N$ particles moving under Newtonian gravity, where each particle $i$ has position $\\mathbf{r}_i(t)$, velocity $\\mathbf{v}_i(t)$, mass $m_i$, and acceleration $\\mathbf{a}_i(t)$ given by Newton's second law and the gravitational force law. The total acceleration is determined by the pairwise forces, and the first time derivative of the acceleration (the \"jerk\") $\\mathbf{j}_i(t) = d\\mathbf{a}_i/dt$ arises from the time variation of the force due to changing relative positions and velocities. A Hermite predictor-corrector scheme uses $\\mathbf{a}_i$ and $\\mathbf{j}_i$ at the beginning and end of each step to achieve high-order accuracy.\n\nIn the individual timestep formulation with block timestepping, each particle is assigned a time-step bin indexed by an integer $b \\in \\{0,1,2,\\dots,B_{\\max}\\}$, with associated quantized step size $h_b = h_0 2^{b}$, where $h_0$ is the minimum base step. Time is discretized by base ticks of duration $h_0$, so each block boundary occurs at times $t_n = n h_0$ for integers $n$. A block-step schedule ensures that particles with different $b$ values step at boundaries that align in a hierarchical fashion.\n\nAssume a local desired continuous step size $h_{\\mathrm{cont}}(t)$ is available at each block boundary time $t$ from some regularity criterion (for example, a simplified Hermite criterion $h_{\\mathrm{cont}}(t) \\propto \\sqrt{\\|\\mathbf{a}(t)\\|/\\|\\mathbf{j}(t)\\|}$). To maintain reversibility, the block-step schedule must be time-symmetric. Time symmetry requires that if the schedule is generated forward from $t = 0$ to $t = T$, then integrating backward from $t = T$ to $t = 0$ with the same rules yields the exact reverse schedule of bin assignments and step boundaries.\n\nDerive, from first principles of step quantization and the requirement of time symmetry under $t \\mapsto -t$, the necessary and sufficient condition under which a particle can change its bin from $b$ to $b' \\in \\{b-1,b,b+1\\}$ at a boundary time $t_n$ without breaking time symmetry. Show that this condition can be expressed using the least common multiple of the old and new step sizes, and reduce it for the case of power-of-two quantization. Design explicit bin-promotion (to $b' = b-1$) and bin-demotion (to $b' = b+1$) rules that enforce the time symmetry condition.\n\nImplement a program that, given a base resolution $h_0$, a maximum bin $B_{\\max}$, an integer number of base ticks $N_{\\mathrm{ticks}}$ corresponding to total time $T = N_{\\mathrm{ticks}} h_0$, and an initial bin $b(0)$, constructs a forward block-step schedule and a backward block-step schedule using the following algorithm:\n- At each boundary time $t_n = n h_0$, compute $h_{\\mathrm{cont}}(t_n)$ and convert this to a desired bin index $b^\\ast(t_n)$ by rounding $\\log_2(h_{\\mathrm{cont}}(t_n)/h_0)$ to the nearest integer and clamping to $[0,B_{\\max}]$.\n- Restrict proposed changes to one level per decision, i.e., $b' = b + \\mathrm{sgn}(b^\\ast - b)$ with $b' \\in [0,B_{\\max}]$.\n- Allow the change $b \\to b'$ at time $t_n$ if and only if the derived time symmetry condition is satisfied at $t_n$; otherwise keep $b$ unchanged.\n- Advance time by $h_b$ in the forward schedule and retreat time by $h_b$ in the backward schedule, recording the pair $(t_n, b(t_n))$ at every forward-start boundary.\n\nTo make the schedules independent of explicit gravitational dynamics while still testing the time symmetry property of the block-step rules, define $h_{\\mathrm{cont}}(t)$ as a deterministic function of time with three cases that exercise promotions, demotions, and multi-level changes. Use dimensionless units for time, with $h_0$ equal to one base tick:\n- Case $1$ (monotone promotions): $h_0 = 1$, $B_{\\max} = 4$, $N_{\\mathrm{ticks}} = 64$, $b(0) = 3$, and \n$$h_{\\mathrm{cont}}(t) = h_0 \\cdot 2^{\\,3 - 3 t/T} \\quad \\text{with} \\quad T = N_{\\mathrm{ticks}} h_0.$$\n- Case $2$ (oscillatory near-threshold changes): $h_0 = 1$, $B_{\\max} = 5$, $N_{\\mathrm{ticks}} = 96$, $b(0) = 2$, and \n$$h_{\\mathrm{cont}}(t) = h_0 \\cdot 2^{\\,2 + 0.9 \\sin\\!\\big(2\\pi t/T\\big)} \\quad \\text{with} \\quad T = N_{\\mathrm{ticks}} h_0.$$\n- Case $3$ (attempted multi-level demotions): $h_0 = 1$, $B_{\\max} = 5$, $N_{\\mathrm{ticks}} = 64$, $b(0) = 1$, and \n$$\nh_{\\mathrm{cont}}(t) =\n\\begin{cases}\nh_0 \\cdot 2^{\\,4},  0 \\le t  T/2,\\\\\nh_0 \\cdot 2^{\\,0},  T/2 \\le t \\le T.\n\\end{cases}\n$$\n\nYour program should:\n- Construct the forward schedule from $t = 0$ to $t = T$ using the above rules.\n- Construct the backward schedule from $t = T$ to $t = 0$ using the same rules, starting from the final bin reached by the forward schedule at $t = T$.\n- Compare the sequences of $(t_n,b(t_n))$ visited by the forward schedule to the reverse of the backward schedule. For each case, output a boolean indicating whether the schedules are exactly time-symmetric (i.e., identical under reversal).\n\nFinal Output Format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[result_1,result_2,result_3]$, where each $result_i$ is a boolean.\n\nTest Suite and Answer Specification:\n- Inputs are the three cases specified above.\n- For each case, the output is a boolean indicating whether the block-step bin-change rule yields a time-symmetric schedule under reversal.\n- All time quantities are dimensionless in units of base ticks, angles (inside trigonometric functions) are in radians, and the final outputs are booleans.", "solution": "The problem asks for the derivation of a time-symmetric bin-change rule for a block time-stepping scheme and an implementation to verify its behavior.\n\n### Principle of Time Symmetry in Block Stepping\n\nA time integration scheme is time-symmetric if, upon reversing the arrow of time ($t \\mapsto -t$) and the signs of all velocities at some time $T$, the system evolves exactly back along its original trajectory to its state at $t=0$. For a block time-stepping algorithm, this requires the sequence of time-step choices to be identical in the forward ($0 \\to T$) and backward ($T \\to 0$) integrations.\n\nThe decision to change a particle's time-step bin, from $b$ to $b'$, is made at discrete boundary times $t_n = n h_0$. This decision depends on the particle's state at $t_n$. For the schedule to be reversible, the decision rule applied at $t_n$ during the forward integration must be consistent with the decision rule applied at the same time $t_n$ during the backward integration.\n\n### Derivation of the Time-Symmetric Bin-Change Condition\n\nLet us consider a particle whose step is governed by bin $b$ (step size $h_b = h_0 2^b$) just before a boundary time $t_n$. For the particle to be active for a potential bin change, $t_n$ must be a multiple of its current step size, $h_b$.\n$$ t_n \\pmod{h_b} = 0 $$\nAt time $t_n$, based on some criterion (here, related to $h_{\\mathrm{cont}}(t_n)$), a decision is made to potentially change the bin to $b'$. If the change is made, the next step, starting from $t_n$, will have size $h_{b'}$.\n\nNow, consider the time-reversed evolution. The system arrives at time $t_n$ from the future, having just completed a backward step of size $h_{b'}$. For the decision logic at $t_n$ to be symmetric, the state of the system that the logic operates on must be perceived identically. In the context of block stepping, this means that the time $t_n$ must be a valid synchronization point for a particle that was in bin $b'$. In other words, $t_n$ must be a multiple of the step size $h_{b'}$ as well.\n$$ t_n \\pmod{h_{b'}} = 0 $$\n\nCombining these two requirements, a change from bin $b$ to bin $b'$ at time $t_n$ can occur without breaking time symmetry if and only if $t_n$ is a multiple of both $h_b$ and $h_{b'}$. This is equivalent to stating that $t_n$ must be a multiple of the least common multiple (LCM) of the old and new step sizes.\n\nThe necessary and sufficient condition for a time-symmetric change $b \\to b'$ at time $t_n$ is:\n$$ t_n \\pmod{\\mathrm{lcm}(h_b, h_{b'})} = 0 $$\n\n### Condition for Power-of-Two Quantization\n\nThe problem specifies power-of-two quantization for the step sizes: $h_b = h_0 2^b$. The LCM of two such step sizes is:\n$$ \\mathrm{lcm}(h_b, h_{b'}) = \\mathrm{lcm}(h_0 2^b, h_0 2^{b'}) = h_0 \\cdot \\mathrm{lcm}(2^b, 2^{b'}) = h_0 \\cdot 2^{\\max(b, b')} $$\nSubstituting this into our condition and using $t_n = n h_0$, we get:\n$$ (n h_0) \\pmod{h_0 \\cdot 2^{\\max(b, b')}} = 0 $$\nDividing by the base step $h_0$, we obtain the condition in terms of the integer tick count $n$:\n$$ n \\pmod{2^{\\max(b, b')}} = 0 $$\nThe integer number of base ticks $n$ must be divisible by $2$ raised to the power of the *larger* of the two bin indices (the old bin $b$ and the proposed new bin $b'$).\n\n### Explicit Promotion and Demotion Rules\n\nThe problem constrains bin changes to adjacent levels, i.e., $b' \\in \\{b-1, b+1\\}$.\n\n1.  **Bin Promotion (Smaller Step):** $b \\to b' = b-1$.\n    The step size decreases. The condition becomes:\n    $$ n \\pmod{2^{\\max(b, b-1)}} = 0 \\implies n \\pmod{2^b} = 0 $$\n    A particle in bin $b$ is only active at times $t_n$ where $n$ is a multiple of $2^b$. Therefore, this condition is *always satisfied* whenever a particle is active. A particle can be promoted to a smaller time step at any of its natural update times.\n\n2.  **Bin Demotion (Larger Step):** $b \\to b' = b+1$.\n    The step size increases. The condition becomes:\n    $$ n \\pmod{2^{\\max(b, b+1)}} = 0 \\implies n \\pmod{2^{b+1}} = 0 $$\n    This is a stricter condition. A particle in bin $b$ is active when $n$ is a multiple of $2^b$. To be demoted to bin $b+1$, it can only do so at times when $n$ is also a multiple of $2^{b+1}$. This occurs on every other active step for the particle. For example, a particle in bin $b=2$ is active at $n=4, 8, 12, 16, \\dots$. It can only be demoted to bin $b=3$ at $n=8, 16, \\dots$, but not at $n=4, 12, \\dots$.\n\n### Algorithmic Implementation\n\nThe program implements a function `generate_schedule` that constructs the time-step schedule based on these rules. It operates on integer time-ticks to avoid floating-point inaccuracies. The function is designed to run both forward (from $t=0$ to $T$) and backward (from $t=T$ to $0$).\n\nIn each step of the simulation (forward or backward), at a boundary time $t_n$:\n1.  The desired bin $b^\\ast$ is calculated from the given function $h_{\\mathrm{cont}}(t_n)$.\n2.  A proposed bin $b'$ is determined by moving one level from the previous bin $b$ towards $b^\\ast$.\n3.  The time symmetry condition, $n \\pmod{2^{\\max(b, b')}} = 0$, is checked.\n4.  The bin is updated to $b'$ only if the condition is met; otherwise, it remains $b$.\n5.  Time is advanced or retreated by the step size corresponding to the new bin.\n\nThe forward schedule is generated. The final bin from this run is used as the initial bin for the backward run. The backward schedule is generated and then reversed. The two schedules, `forward` and `reversed(backward)`, are compared for equality to verify time symmetry. For all three test cases, the derived rules are expected to produce perfectly time-symmetric schedules.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef sgn(x):\n    \"\"\"Returns the sign of a number.\"\"\"\n    return np.sign(x)\n\ndef clamp(val, min_val, max_val):\n    \"\"\"Clamps a value to the specified range [min_val, max_val].\"\"\"\n    return max(min_val, min(val, max_val))\n\n# Deterministic h_cont functions for the three test cases\ndef h_cont_case1(t, T, h0):\n    return h0 * 2**(3.0 - 3.0 * t / T)\n\ndef h_cont_case2(t, T, h0):\n    return h0 * 2**(2.0 + 0.9 * np.sin(2 * np.pi * t / T))\n\ndef h_cont_case3(t, T, h0):\n    if 0 = t  T / 2:\n        return h0 * 2**4.0\n    else:\n        return h0 * 2**0.0\n\ndef generate_schedule(params, direction):\n    \"\"\"\n    Generates a block-step schedule either forward or backward in time.\n\n    The state is defined by (t, b), where 'b' is the bin for the step\n    starting at time 't'. The decision for 'b' at 't' is based on the\n    bin of the step that *ended* at 't'.\n    \"\"\"\n    h0 = params['h0']\n    B_max = params['B_max']\n    N_ticks = params['N_ticks']\n    h_cont_func = params['h_cont_func']\n   \n    schedule = []\n    \n    if direction == 'forward':\n        t_current_ticks = 0\n        t_end_ticks = N_ticks\n        b_prev = params['b0']\n        time_step_direction = 1\n    else:  # backward\n        t_current_ticks = N_ticks\n        t_end_ticks = 0\n        b_prev = params['b_final_forward']\n        time_step_direction = -1\n\n    # Loop until the current time reaches the end time\n    while time_step_direction * (t_current_ticks - t_end_ticks)  0:\n        t_float = float(t_current_ticks * h0)\n        n = t_current_ticks\n        \n        # 1. Determine the desired bin b* from the continuous step size criterion.\n        h_c = h_cont_func(t_float, N_ticks * h0, h0)\n        \n        # np.round implements \"round half to even\", which is a standard choice.\n        b_star = int(np.round(np.log2(h_c / h0)))\n        b_star = clamp(b_star, 0, B_max)\n        \n        # 2. Propose a new bin b', restricted to a single-level change.\n        b_prop = b_prev\n        if b_star != b_prev:\n            b_prop = int(b_prev + sgn(b_star - b_prev))\n            b_prop = clamp(b_prop, 0, B_max)\n\n        # 3. Apply the time symmetry condition to decide the actual new bin.\n        b_curr = b_prev\n        if b_prop != b_prev:\n            max_b = max(b_prev, b_prop)\n            if n % (2**max_b) == 0:\n                b_curr = b_prop\n        \n        step_ticks = 2**b_curr\n        \n        if direction == 'forward':\n            schedule.append((t_current_ticks, b_curr))\n            t_current_ticks += time_step_direction * step_ticks\n            b_prev = b_curr\n        else:  # backward\n            t_prev_ticks = t_current_ticks - step_ticks\n            schedule.append((t_prev_ticks, b_curr))\n            t_current_ticks = t_prev_ticks\n            b_prev = b_curr\n\n    # The final bin for the forward run is the last decided bin, `b_prev`.\n    if direction == 'forward':\n        final_bin = b_prev\n    else:\n        final_bin = None\n        schedule.reverse()\n    \n    return schedule, final_bin\n\ndef run_and_verify(case_params):\n    \"\"\"\n    Runs a forward and backward simulation for a given case\n    and verifies if the schedules are time-symmetric.\n    \"\"\"\n    # Run the forward schedule to generate it and get the final bin.\n    fwd_params = {**case_params, 'direction': 'forward'}\n    fwd_schedule, b_final_forward = generate_schedule(fwd_params, 'forward')\n\n    # Run the backward schedule starting with the final forward bin.\n    bwd_params = {**case_params, 'direction': 'backward', 'b_final_forward': b_final_forward}\n    bwd_schedule, _ = generate_schedule(bwd_params, 'backward')\n    \n    return fwd_schedule == bwd_schedule\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {'h0': 1, 'B_max': 4, 'N_ticks': 64, 'b0': 3, 'h_cont_func': h_cont_case1},\n        {'h0': 1, 'B_max': 5, 'N_ticks': 96, 'b0': 2, 'h_cont_func': h_cont_case2},\n        {'h0': 1, 'B_max': 5, 'N_ticks': 64, 'b0': 1, 'h_cont_func': h_cont_case3}\n    ]\n\n    results = []\n    for params in test_cases:\n        is_symmetric = run_and_verify(params)\n        results.append(is_symmetric)\n\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nsolve()\n```", "id": "3541229"}]}