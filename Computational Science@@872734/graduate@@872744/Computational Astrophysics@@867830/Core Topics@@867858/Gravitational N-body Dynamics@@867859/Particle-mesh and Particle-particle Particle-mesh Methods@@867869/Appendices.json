{"hands_on_practices": [{"introduction": "The foundation of any Particle-Mesh (PM) simulation is the assignment scheme, which translates the discrete particle distribution into a smooth density field on a grid. This exercise provides foundational practice with the widely-used Cloud-In-Cell (CIC) scheme, which offers a balance between accuracy and computational expense. By working through this direct calculation [@problem_id:3529293], you will gain a concrete intuition for how a particle's mass is distributed among its neighboring grid nodes, a process equivalent to trilinear interpolation.", "problem": "Consider a uniform Cartesian mesh used in the Particle-Mesh (PM) method with grid nodes at positions $(ih, jh, kh)$ for integers $i$, $j$, and $k$, where $h$ is the uniform grid spacing. In the Cloud-In-Cell (CIC) mass assignment scheme, the particle mass is distributed to the mesh nodes using a separable, piecewise-linear shape function that conserves mass and is supported by the $8$ corner nodes of the cell that encloses the particle.\n\nA single particle of unit mass is located at position $\\boldsymbol{x}_{p} = (0.3h, 0.7h, 0.1h)$, which lies inside the elementary cell bounded by the planes $x=0$, $x=h$, $y=0$, $y=h$, $z=0$, and $z=h$. Using the Cloud-In-Cell (CIC) assignment rule, compute the mass fractions deposited to the $8$ neighboring corner nodes of the enclosing cell in the following fixed order:\n$(0,0,0)$, $(h,0,0)$, $(0,h,0)$, $(h,h,0)$, $(0,0,h)$, $(h,0,h)$, $(0,h,h)$, $(h,h,h)$.\n\nExpress each fraction as an exact rational number, and present your final answer as a single row vector. No rounding is required. The fractions are dimensionless.", "solution": "The user wants to solve a particle-mesh problem. The problem is validated first.\n\n### Step 1: Extract Givens\n-   **Mesh Type**: Uniform Cartesian mesh with grid nodes at positions $(i h, j h, k h)$ for integers $i$, $j$, and $k$.\n-   **Grid Spacing**: $h$ is the uniform grid spacing.\n-   **Assignment Scheme**: Cloud-In-Cell (CIC), described as a separable, piecewise-linear shape function that conserves mass and is supported by 8 corner nodes.\n-   **Particle Properties**: A single particle of unit mass, $m_p = 1$.\n-   **Particle Position**: $\\boldsymbol{x}_{p} = (0.3 h, 0.7 h, 0.1 h)$.\n-   **Enclosing Cell**: The cell is bounded by the planes $x=0$, $x=h$, $y=0$, $y=h$, $z=0$, and $z=h$. Its eight corner nodes are at $(ih, jh, kh)$ for $i,j,k \\in \\{0,1\\}$.\n-   **Task**: Compute the mass fractions deposited to the 8 neighboring corner nodes.\n-   **Output Order**: The fractions must be for the nodes in the fixed order: $(0,0,0)$, $(h,0,0)$, $(0,h,0)$, $(h,h,0)$, $(0,0,h)$, $(h,0,h)$, $(0,h,h)$, $(h,h,h)$.\n-   **Output Format**: Each fraction must be an exact rational number, presented in a single row vector.\n\n### Step 2: Validate Using Extracted Givens\n-   **Scientifically Grounded**: The problem describes the Cloud-In-Cell (CIC) scheme, a standard and correct method used in computational astrophysics for N-body simulations. The principles are sound.\n-   **Well-Posed**: The problem is well-posed. The particle's position is clearly defined within a specific cell, and the CIC method provides a unique and stable algorithm for distributing the mass.\n-   **Objective**: The language is precise and unambiguous.\n-   **Completeness**: All necessary information (particle position, mass, cell definition, assignment scheme) is provided.\n-   **Consistency**: There are no internal contradictions.\n\n### Step 3: Verdict and Action\nThe problem is valid. A solution will be provided.\n\n***\n\nThe Cloud-In-Cell (CIC) mass assignment scheme distributes a particle's mass to the $8$ vertices of the grid cell that contains it. This distribution is equivalent to trilinear interpolation. The fraction of mass assigned to each vertex is proportional to the volume of the sub-cuboid that is diagonally opposite to that vertex, formed by planes passing through the particle's position parallel to the cell faces.\n\nA particle of unit mass, $m_p=1$, is located at position $\\boldsymbol{x}_{p} = (x_p, y_p, z_p) = (0.3h, 0.7h, 0.1h)$. The elementary cell containing the particle is defined by the $8$ corner nodes at positions $\\boldsymbol{x}_{ijk} = (ih, jh, kh)$, where $h$ is the grid spacing and $i, j, k \\in \\{0, 1\\}$.\n\nFirst, we define the particle's normalized, dimensionless coordinates within this cell, relative to the node at the origin $(0,0,0)$:\n$$ t_x = \\frac{x_p - 0}{h} = \\frac{0.3h}{h} = 0.3 $$\n$$ t_y = \\frac{y_p - 0}{h} = \\frac{0.7h}{h} = 0.7 $$\n$$ t_z = \\frac{z_p - 0}{h} = \\frac{0.1h}{h} = 0.1 $$\nThe particle is located at the normalized position $(t_x, t_y, t_z) = (0.3, 0.7, 0.1)$ within the unit cube defined by the normalized coordinates.\n\nThe CIC scheme uses a separable assignment function, meaning the total weight for a node is the product of $1$-dimensional linear interpolation weights. For a given dimension, say $x$, the weights assigned to the bounding nodes at $i=0$ and $i=1$ are:\n$$ w_x(0) = 1 - t_x $$\n$$ w_x(1) = t_x $$\nSimilarly for the $y$ and $z$ dimensions:\n$$ w_y(0) = 1 - t_y, \\quad w_y(1) = t_y $$\n$$ w_z(0) = 1 - t_z, \\quad w_z(1) = t_z $$\nThe mass fraction, $f_{ijk}$, assigned to the node at $(ih, jh, kh)$ is given by the product of these $1$-dimensional weights:\n$$ f_{ijk} = w_x(i) \\cdot w_y(j) \\cdot w_z(k) $$\nSince the particle's mass is $m_p=1$, these fractions are the absolute masses deposited on the grid nodes.\n\nUsing the particle's normalized position, we calculate the $1$-dimensional weights:\n$$ w_x(0) = 1 - 0.3 = 0.7 = \\frac{7}{10} \\quad \\text{and} \\quad w_x(1) = 0.3 = \\frac{3}{10} $$\n$$ w_y(0) = 1 - 0.7 = 0.3 = \\frac{3}{10} \\quad \\text{and} \\quad w_y(1) = 0.7 = \\frac{7}{10} $$\n$$ w_z(0) = 1 - 0.1 = 0.9 = \\frac{9}{10} \\quad \\text{and} \\quad w_z(1) = 0.1 = \\frac{1}{10} $$\n\nNow, we compute the mass fraction for each of the $8$ nodes in the specified order.\n\n1.  Node at $(0,0,0)$, corresponding to $(i,j,k)=(0,0,0)$:\n    $f_{000} = w_x(0) \\cdot w_y(0) \\cdot w_z(0) = \\frac{7}{10} \\times \\frac{3}{10} \\times \\frac{9}{10} = \\frac{189}{1000}$\n\n2.  Node at $(h,0,0)$, corresponding to $(i,j,k)=(1,0,0)$:\n    $f_{100} = w_x(1) \\cdot w_y(0) \\cdot w_z(0) = \\frac{3}{10} \\times \\frac{3}{10} \\times \\frac{9}{10} = \\frac{81}{1000}$\n\n3.  Node at $(0,h,0)$, corresponding to $(i,j,k)=(0,1,0)$:\n    $f_{010} = w_x(0) \\cdot w_y(1) \\cdot w_z(0) = \\frac{7}{10} \\times \\frac{7}{10} \\times \\frac{9}{10} = \\frac{441}{1000}$\n\n4.  Node at $(h,h,0)$, corresponding to $(i,j,k)=(1,1,0)$:\n    $f_{110} = w_x(1) \\cdot w_y(1) \\cdot w_z(0) = \\frac{3}{10} \\times \\frac{7}{10} \\times \\frac{9}{10} = \\frac{189}{1000}$\n\n5.  Node at $(0,0,h)$, corresponding to $(i,j,k)=(0,0,1)$:\n    $f_{001} = w_x(0) \\cdot w_y(0) \\cdot w_z(1) = \\frac{7}{10} \\times \\frac{3}{10} \\times \\frac{1}{10} = \\frac{21}{1000}$\n\n6.  Node at $(h,0,h)$, corresponding to $(i,j,k)=(1,0,1)$:\n    $f_{101} = w_x(1) \\cdot w_y(0) \\cdot w_z(1) = \\frac{3}{10} \\times \\frac{3}{10} \\times \\frac{1}{10} = \\frac{9}{1000}$\n\n7.  Node at $(0,h,h)$, corresponding to $(i,j,k)=(0,1,1)$:\n    $f_{011} = w_x(0) \\cdot w_y(1) \\cdot w_z(1) = \\frac{7}{10} \\times \\frac{7}{10} \\times \\frac{1}{10} = \\frac{49}{1000}$\n\n8.  Node at $(h,h,h)$, corresponding to $(i,j,k)=(1,1,1)$:\n    $f_{111} = w_x(1) \\cdot w_y(1) \\cdot w_z(1) = \\frac{3}{10} \\times \\frac{7}{10} \\times \\frac{1}{10} = \\frac{21}{1000}$\n\nAs a consistency check, we verify that the sum of the mass fractions equals $1$, which is a required property of the CIC scheme (mass conservation).\n$$ \\sum_{i,j,k \\in \\{0,1\\}} f_{ijk} = \\frac{1}{1000} (189 + 81 + 441 + 189 + 21 + 9 + 49 + 21) = \\frac{1000}{1000} = 1 $$\nThe sum confirms the calculations are correct. The final answer is the ordered list of these fractions.\nThe resulting row vector of mass fractions is:\n$$ \\begin{pmatrix} \\frac{189}{1000}  \\frac{81}{1000}  \\frac{441}{1000}  \\frac{189}{1000}  \\frac{21}{1000}  \\frac{9}{1000}  \\frac{49}{1000}  \\frac{21}{1000} \\end{pmatrix} $$", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{189}{1000}  \\frac{81}{1000}  \\frac{441}{1000}  \\frac{189}{1000}  \\frac{21}{1000}  \\frac{9}{1000}  \\frac{49}{1000}  \\frac{21}{1000}\n\\end{pmatrix}\n}\n$$", "id": "3529293"}, {"introduction": "A complete PM simulation involves more than just mass assignment; it requires calculating forces from the gridded potential and integrating particle trajectories over time. This hands-on coding exercise [@problem_id:3529327] guides you through building a miniature PM solver for a particle orbiting in a static potential, allowing you to focus on the interplay between force interpolation and the time-integration scheme. By analyzing the energy conservation of the system, you will develop essential skills in verifying the accuracy and stability of numerical N-body codes.", "problem": "Consider a single test particle moving in a fixed spherically symmetric gravitational potential that corresponds to a Plummer sphere. Use a Particle-Mesh (PM) discretization of this potential on a uniform Cartesian grid in a cubic domain, and integrate the particle’s motion with a time-symmetric leapfrog scheme for exactly one orbital period of a circular orbit. Estimate the secular energy error as a function of the time step size $\\Delta t$. All quantities are to be expressed in dimensionless code units, where the gravitational constant $G$ equals $1$.\n\nThe Plummer sphere gravitational potential is defined by the well-tested formula\n$$\n\\Phi(r) = -\\frac{G M}{\\sqrt{r^2 + a^2}},\n$$\nwhere $r$ is the radial distance from the origin, $M$ is the total mass, and $a$ is the softening length. The gravitational acceleration is given by Newton’s second law and the gradient of the potential,\n$$\n\\mathbf{a}(\\mathbf{x}) = -\\nabla \\Phi(\\mathbf{x}).\n$$\n\nYou must construct a PM representation of the static potential by sampling $\\Phi(\\mathbf{x})$ on a uniform mesh and computing $\\nabla \\Phi(\\mathbf{x})$ on the mesh using finite differences. Use trilinear interpolation to evaluate the potential and its gradient at the particle’s position. Then integrate the particle’s orbit using a leapfrog time integrator (kick-drift-kick) that respects Newton’s second law.\n\nAssume the following fixed parameters in dimensionless code units:\n- $G = 1$, $M = 1$, $a = 0.1$.\n- The cubic domain is $[-L/2, L/2]^3$ with $L = 4$.\n- Use a uniform mesh with $N = 64$ nodes per dimension.\n- Initialize the particle at $\\mathbf{x}_0 = (r_0, 0, 0)$ with $r_0 = 1$. Choose the initial velocity $\\mathbf{v}_0 = (0, v_{\\mathrm{circ}}, 0)$, where $v_{\\mathrm{circ}}$ is the circular velocity computed by equating the centripetal acceleration to the gravitational acceleration in the Plummer potential:\n$$\n\\frac{v_{\\mathrm{circ}}^2}{r_0} = \\frac{G M r_0}{(r_0^2 + a^2)^{3/2}}.\n$$\n\nUse the circular orbit period\n$$\nT = \\frac{2\\pi r_0}{v_{\\mathrm{circ}}},\n$$\nwith angles measured in radians.\n\nDefine the total mechanical energy at position $\\mathbf{x}$ and velocity $\\mathbf{v}$ by\n$$\nE = \\frac{1}{2}\\|\\mathbf{v}\\|^2 + \\Phi(\\mathbf{x}),\n$$\nwhere $\\Phi(\\mathbf{x})$ is obtained via trilinear interpolation of the PM potential on the mesh, and $\\|\\mathbf{v}\\|$ is the Euclidean norm. The secular energy error after integrating for one orbital period is the absolute fractional difference\n$$\n\\epsilon = \\left|\\frac{E(T) - E(0)}{E(0)}\\right|.\n$$\nReport $\\epsilon$ as a decimal number (dimensionless).\n\nImplement the following:\n1. Construct the PM potential $\\Phi$ on the mesh and compute its gradient $\\nabla \\Phi$ at mesh nodes using central differences in the interior and one-sided differences at the boundaries.\n2. For a given $\\Delta t$, integrate for exactly one period $T$ using the leapfrog method and trilinear interpolation to compute the acceleration at intermediate positions.\n3. Compute and return the secular energy error $\\epsilon$ using the PM-interpolated potential for both $E(0)$ and $E(T)$.\n\nTest Suite:\nFor the same setup above, evaluate the secular energy error $\\epsilon$ for the following time steps, each chosen to exactly divide the period:\n- $\\Delta t = T/200$,\n- $\\Delta t = T/100$,\n- $\\Delta t = T/50$,\n- $\\Delta t = T/20$,\n- $\\Delta t = T/8$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5]\"). Each result is the value of $\\epsilon$ for the corresponding $\\Delta t$ in the order listed above. All outputs are dimensionless decimals.", "solution": "The user has provided a problem from computational astrophysics that requires simulating a particle's orbit and evaluating the energy conservation of a Particle-Mesh (PM) scheme. The problem is valid as it is scientifically grounded, well-posed, and objective. It provides a complete and consistent set of parameters, initial conditions, and numerical methods for a standard computational experiment.\n\nThe solution proceeds as follows:\n\n1.  **System Definition and Initial Conditions:**\n    The problem describes a test particle under the influence of a static gravitational potential generated by a Plummer sphere, with potential $\\Phi(r) = -G M / \\sqrt{r^2 + a^2}$. The parameters are given in dimensionless code units as $G=1$, $M=1$, and the softening length $a=0.1$. The particle is initialized in a circular orbit in the $x-y$ plane at a radius $r_0=1$. The circular velocity, $v_{\\mathrm{circ}}$, is determined by balancing the gravitational force with the centripetal force:\n    $$\n    \\frac{v_{\\mathrm{circ}}^2}{r_0} = |\\mathbf{a}(r_0)| = \\left|-\\frac{d\\Phi}{dr}\\right|_{r=r_0} = \\frac{G M r_0}{(r_0^2 + a^2)^{3/2}}\n    $$\n    This gives an initial position $\\mathbf{x}_0 = (r_0, 0, 0)$ and velocity $\\mathbf{v}_0 = (0, v_{\\mathrm{circ}}, 0)$. The orbital period, which is the total integration time, is $T = 2\\pi r_0 / v_{\\mathrm{circ}}$.\n\n2.  **Particle-Mesh (PM) Discretization:**\n    The core of the PM method is to represent the continuous gravitational field on a discrete grid. The simulation is performed in a cubic domain of side length $L=4$, centered at the origin.\n    -   **Grid Generation:** A uniform Cartesian mesh with $N=64$ nodes per dimension is constructed. The grid spacing is $h = L / (N-1)$.\n    -   **Potential Sampling:** The analytical Plummer potential $\\Phi(\\mathbf{x})$ is evaluated at the coordinates of each of the $N \\times N \\times N$ grid nodes and stored in a 3D array, $\\Phi_{\\text{grid}}$.\n    -   **Force Field Calculation:** The gravitational acceleration field, $\\mathbf{a}(\\mathbf{x}) = -\\nabla\\Phi(\\mathbf{x})$, is computed on the grid by taking the numerical gradient of the potential grid, $\\Phi_{\\text{grid}}$. The gradient is computed using second-order central differences for interior nodes and first-order one-sided differences at the boundaries, as specified. This yields three 3D arrays, $\\mathbf{a}_{x, \\text{grid}}$, $\\mathbf{a}_{y, \\text{grid}}$, and $\\mathbf{a}_{z, \\text{grid}}$, representing the components of the acceleration field at each grid node.\n\n3.  **Particle Integration:**\n    To integrate the particle's equations of motion, $\\ddot{\\mathbf{x}} = \\mathbf{a}(\\mathbf{x})$, we require the acceleration at the particle's position, which generally does not coincide with a grid node.\n    -   **Field Interpolation:** Trilinear interpolation is used to evaluate both the potential $\\Phi$ and the acceleration components $\\mathbf{a}$ at an arbitrary particle position $\\mathbf{x}$. This is achieved by finding the grid cell containing the particle and performing a weighted average of the values at the cell's 8 corners. The weights are determined by the particle's fractional position within the cell.\n    -   **Leapfrog Integration (Kick-Drift-Kick):** The particle's state $(\\mathbf{x}(t), \\mathbf{v}(t))$ is advanced in time using a time-symmetric leapfrog integrator. The specific variant used is the \"velocity Verlet\" algorithm, which is equivalent to a Kick-Drift-Kick (KDK) scheme. For a single timestep $\\Delta t$, the update from state $(\\mathbf{x}_n, \\mathbf{v}_n)$ to $(\\mathbf{x}_{n+1}, \\mathbf{v}_{n+1})$ is:\n        1.  **Kick:** $\\mathbf{v}_{n+1/2} = \\mathbf{v}_n + \\mathbf{a}(\\mathbf{x}_n) \\frac{\\Delta t}{2}$\n        2.  **Drift:** $\\mathbf{x}_{n+1} = \\mathbf{x}_n + \\mathbf{v}_{n+1/2} \\Delta t$\n        3.  **Kick:** $\\mathbf{v}_{n+1} = \\mathbf{v}_{n+1/2} + \\mathbf{a}(\\mathbf{x}_{n+1}) \\frac{\\Delta t}{2}$\n    This scheme is second-order accurate in $\\Delta t$ and is symplectic, which leads to excellent long-term energy conservation properties (i.e., no secular energy drift).\n\n4.  **Energy Error Calculation:**\n    The total energy of the particle is defined using the PM-interpolated potential, not the analytical one, to consistently assess the error of the numerical method itself. The energy at a given state $(\\mathbf{x}, \\mathbf{v})$ is:\n    $$\n    E = \\frac{1}{2}\\|\\mathbf{v}\\|^2 + \\Phi_{\\text{interp}}(\\mathbf{x})\n    $$\n    The initial energy $E(0)$ is computed using the initial state $(\\mathbf{x}_0, \\mathbf{v}_0)$. The final energy $E(T)$ is computed after integrating for one full period $T$. The secular energy error $\\epsilon$ is the absolute fractional difference:\n    $$\n    \\epsilon = \\left|\\frac{E(T) - E(0)}{E(0)}\\right|\n    $$\n    This calculation is repeated for several time step sizes $\\Delta t$, which are chosen as integer fractions of the period $T$. Since the leapfrog integrator has a local truncation error of order $\\mathcal{O}(\\Delta t^3)$, the global energy error over a fixed interval is expected to scale as $\\epsilon \\propto \\Delta t^2$.", "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import RegularGridInterpolator\n\ndef solve():\n    \"\"\"\n    Solves the particle-mesh orbit integration problem.\n    \"\"\"\n    # 1. System Parameters and Initial Conditions\n    G = 1.0\n    M = 1.0\n    a = 0.1\n    L = 4.0\n    N = 64\n    r0 = 1.0\n\n    # Test cases: time step as a fraction of the period T\n    T_divisors = [200, 100, 50, 20, 8]\n\n    # Derived constants and initial conditions\n    h = L / (N - 1)\n    grid_coords = np.linspace(-L / 2, L / 2, N)\n\n    # Circular velocity for a Plummer potential\n    v_circ_sq = (G * M * r0**2) / (r0**2 + a**2)**1.5\n    v_circ = np.sqrt(v_circ_sq)\n    \n    # Orbital period\n    T = 2 * np.pi * r0 / v_circ\n\n    # Initial state vectors\n    x0 = np.array([r0, 0.0, 0.0])\n    v0 = np.array([0.0, v_circ, 0.0])\n\n    # 2. PM Grid Construction\n    # Create grid coordinate arrays\n    X, Y, Z = np.meshgrid(grid_coords, grid_coords, grid_coords, indexing='ij')\n\n    # Compute potential on the grid\n    R_sq = X**2 + Y**2 + Z**2\n    Phi_grid = -G * M / np.sqrt(R_sq + a**2)\n\n    # Compute acceleration field using numerical gradient of the potential field\n    # np.gradient uses 2nd-order central differences for the interior\n    # and 1st-order one-sided differences at boundaries, as required.\n    # The gradient is returned as a list of arrays [d/dx, d/dy, d/dz]\n    # because meshgrid's indexing was 'ij'.\n    grad_Phi = np.gradient(Phi_grid, h)\n    Acc_x_grid = -grad_Phi[0]\n    Acc_y_grid = -grad_Phi[1]\n    Acc_z_grid = -grad_Phi[2]\n\n    # 3. Create Interpolators\n    # Stack all fields for efficient multi-value interpolation\n    values_to_interpolate = np.stack(\n        [Phi_grid, Acc_x_grid, Acc_y_grid, Acc_z_grid], axis=-1\n    )\n    \n    # The interpolator function will be used to get potential and acceleration\n    # at any off-grid particle position. 'linear' corresponds to trilinear.\n    interpolator = RegularGridInterpolator(\n        (grid_coords, grid_coords, grid_coords),\n        values_to_interpolate,\n        method='linear',\n        bounds_error=True  # Ensure particle stays within the simulation box\n    )\n\n    def get_potential_and_accel(pos):\n        # The interpolator expects a (n_points, n_dims) array.\n        # For a single point, we reshape and then squeeze the output.\n        interp_values = interpolator(pos.reshape(1, -1))\n        return interp_values[0] # Returns [phi, ax, ay, az]\n\n    # Calculate initial energy E(0) using the interpolated potential\n    phi0, _, _, _ = get_potential_and_accel(x0)\n    E0 = 0.5 * np.dot(v0, v0) + phi0\n\n    results = []\n    \n    # 4. Integration and Error Calculation Loop\n    for divisor in T_divisors:\n        dt = T / divisor\n        N_steps = int(divisor)\n\n        # Reset particle state for each test run\n        x = np.copy(x0)\n        v = np.copy(v0)\n\n        # KDK Leapfrog / Velocity Verlet Integrator\n        # Get initial acceleration\n        _, ax, ay, az = get_potential_and_accel(x)\n        a_current = np.array([ax, ay, az])\n\n        for _ in range(N_steps):\n            # Kick (half step)\n            v_half_step = v + a_current * dt / 2.0\n            # Drift (full step)\n            x = x + v_half_step * dt\n            # Update acceleration at the new position\n            _, ax_new, ay_new, az_new = get_potential_and_accel(x)\n            a_new = np.array([ax_new, ay_new, az_new])\n            # Kick (second half step)\n            v = v_half_step + a_new * dt / 2.0\n            # Store the new acceleration for the next iteration\n            a_current = a_new\n        \n        # At this point, x and v are the final state at time T\n        x_final = x\n        v_final = v\n\n        # Calculate final energy E(T)\n        phi_final, _, _, _ = get_potential_and_accel(x_final)\n        E_final = 0.5 * np.dot(v_final, v_final) + phi_final\n\n        # Calculate and store the secular energy error\n        error = np.abs((E_final - E0) / E0)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3529327"}, {"introduction": "The Particle-Particle Particle-Mesh (P³M) method enhances PM's accuracy by correcting for the loss of short-range force resolution inherent in grid-based methods. This correction is achieved through a direct, computationally expensive particle-particle force summation within a specific cutoff radius, $r_c$. This problem [@problem_id:3529362] challenges you to design the core algorithmic component that makes this feasible: a cell-linked list for efficient neighbor finding, connecting theoretical design choices to practical performance estimation.", "problem": "In a self-gravitating $N$-body calculation using the particle-particle particle-mesh ($P^3M$) method, the total Newtonian force is split into a short-range particle-particle component truncated at a cutoff radius $r_c$ and a long-range particle-mesh component computed on a mesh of spacing $h$. The cutoff is defined by $r_c = \\alpha h$ for a fixed dimensionless constant $\\alpha > 0$. To accelerate the short-range particle-particle evaluation, you will design a cell-linked list neighbor search in a three-dimensional periodic domain populated by particles drawn from a uniform Poisson process with number density $n$.\n\nDesign the neighbor search as follows: partition space into a uniform grid of cubic cells of edge length $\\ell$ such that every true neighbor within distance $r_c$ of a particle must reside in that particle’s own cell or one of its face-, edge-, or corner-adjacent neighbor cells. To minimize the number of distance checks, choose the smallest admissible $\\ell$ satisfying this requirement, and for each particle, restrict the candidate set to the particles found in the union of its own cell and these adjacent cells. Assume $N$ is sufficiently large that boundary corrections are negligible, and that the candidate set is pruned by an exact distance check against $r_c$ after the cell-based culling.\n\nUsing only fundamental geometric and probabilistic reasoning, compute the expected number of candidate pairs per particle generated by this cell-linked list procedure, expressed in closed form in terms of $n$, $\\alpha$, and $h$. Your final answer must be a single analytic expression. Do not include units in the final boxed answer.", "solution": "The problem asks for the expected number of candidate pairs per particle generated by a specific cell-linked list procedure in a three-dimensional periodic domain. The particles are distributed according to a uniform Poisson process with number density $n$.\n\nFirst, we must determine the size of the cubic cells, denoted by $\\ell$. The design specifies a search region for any given particle that includes its own cell and the $26$ adjacent cells (those sharing a face, edge, or corner). This constitutes a $3 \\times 3 \\times 3$ block of cells. The crucial requirement is that this search region must contain every \"true\" neighbor, i.e., any other particle within a distance of $r_c$. The cell size $\\ell$ must be the smallest value that satisfies this condition.\n\nLet two particles be located at positions $\\vec{x}_1$ and $\\vec{x}_2$. Let the Cartesian components of these vectors be $(x_{1,1}, x_{1,2}, x_{1,3})$ and $(x_{2,1}, x_{2,2}, x_{2,3})$, respectively. The cells are aligned with the coordinate axes. The cell index for a particle at position $\\vec{x}$ in the $k$-th dimension is given by $i_k(\\vec{x}) = \\lfloor x_k / \\ell \\rfloor$. Two particles are in the same or adjacent cells (i.e., they are \"cell-neighbors\") if and only if the absolute difference of their cell indices is less than or equal to $1$ in all three dimensions:\n$$|i_k(\\vec{x}_1) - i_k(\\vec{x}_2)| \\le 1 \\quad \\text{for } k=1, 2, 3$$\nThe problem's requirement can be stated as: if $|\\vec{x}_1 - \\vec{x}_2| \\le r_c$, then the particles must be cell-neighbors.\n\nIt is more convenient to analyze the contrapositive statement: if two particles are *not* cell-neighbors, their separation must be strictly greater than $r_c$. Two particles are not cell-neighbors if, for at least one dimension $k$, the absolute difference of their cell indices is 2 or more:\n$$|i_k(\\vec{x}_1) - i_k(\\vec{x}_2)| \\ge 2$$\nLet's analyze the minimum possible distance between two particles that are not cell-neighbors. Consider the separation in the $k$-th dimension, $\\Delta x_k = x_{1,k} - x_{2,k}$. The cell indices are $i_k(\\vec{x}_1) = \\lfloor x_{1,k}/\\ell \\rfloor$ and $i_k(\\vec{x}_2) = \\lfloor x_{2,k}/\\ell \\rfloor$.\nFrom the definition of the floor function, we have the general inequality $q-1  \\lfloor q \\rfloor \\le q$. This implies:\n$$\\frac{x_{1,k}}{\\ell} - 1  \\lfloor \\frac{x_{1,k}}{\\ell} \\rfloor \\le \\frac{x_{1,k}}{\\ell}$$\n$$-\\frac{x_{2,k}}{\\ell} \\le - \\lfloor \\frac{x_{2,k}}{\\ell} \\rfloor  -\\frac{x_{2,k}}{\\ell} + 1$$\nAdding these inequalities gives:\n$$\\frac{\\Delta x_k}{\\ell} - 1  i_k(\\vec{x}_1) - i_k(\\vec{x}_2)  \\frac{\\Delta x_k}{\\ell} + 1$$\nIf the particles are not cell-neighbors, there is some dimension $k$ where $|i_k(\\vec{x}_1) - i_k(\\vec{x}_2)| \\ge 2$. Let's assume $i_k(\\vec{x}_1) - i_k(\\vec{x}_2) \\ge 2$. From the inequalities above, this implies:\n$$2 \\le i_k(\\vec{x}_1) - i_k(\\vec{x}_2)  \\frac{\\Delta x_k}{\\ell} + 1$$\n$$1  \\frac{\\Delta x_k}{\\ell} \\implies \\Delta x_k  \\ell$$\nThis shows that if two particles are separated by at least one full cell in any dimension, their coordinate separation in that dimension must be strictly greater than $\\ell$. The squared distance between the particles is $|\\vec{x}_1 - \\vec{x}_2|^2 = (\\Delta x_1)^2 + (\\Delta x_2)^2 + (\\Delta x_3)^2$. If for some $k$, $|\\Delta x_k|  \\ell$, then $|\\vec{x}_1 - \\vec{x}_2|^2 \\ge (\\Delta x_k)^2  \\ell^2$. Thus, the distance between them must be $|\\vec{x}_1 - \\vec{x}_2|  \\ell$.\n\nSo, for any pair of particles that are not cell-neighbors, their separation is strictly greater than $\\ell$. To satisfy the contrapositive requirement that their separation must be greater than $r_c$, we must ensure that $\\ell \\ge r_c$. If this holds, then distance $ \\ell \\ge r_c$, which fulfills the condition.\nThe problem requires the *smallest* admissible value for $\\ell$. Therefore, we must choose $\\ell = r_c$.\n\nNow we compute the expected number of candidate pairs per particle. For a given particle, the candidate particles are all other particles located in the $3 \\times 3 \\times 3$ block of cells centered on the given particle's cell.\nThe volume of a single cubic cell is $V_{cell} = \\ell^3$.\nThe total volume of the search region, which comprises $3 \\times 3 \\times 3 = 27$ cells, is:\n$$V_{search} = 27 V_{cell} = 27 \\ell^3$$\nThe particles are distributed via a uniform Poisson process with number density $n$. A fundamental property of such a process is that the number of particles in any volume $V$ is a Poisson-distributed random variable with mean $n V$. Furthermore, due to the independence property of the Poisson process (formalized by Slivnyak's theorem), conditioning on the presence of a particle at a specific location does not change the distribution of the other particles.\nTherefore, for any given particle, the expected number of *other* particles within its search volume $V_{search}$ is simply the density $n$ multiplied by the volume $V_{search}$. Let $N_{cand}$ be the expected number of candidate pairs per particle.\n$$N_{cand} = n V_{search} = n (27 \\ell^3)$$\nWe have established that the optimal cell size is $\\ell = r_c$. The problem also states that the cutoff radius $r_c$ is related to the mesh spacing $h$ by $r_c = \\alpha h$, where $\\alpha$ is a dimensionless constant.\nSubstituting these relations into the expression for $N_{cand}$:\n$$\\ell = r_c = \\alpha h$$\n$$N_{cand} = 27 n (\\alpha h)^3 = 27 n \\alpha^3 h^3$$\nThis is the final expression for the expected number of candidate pairs per particle.", "answer": "$$\\boxed{27 n \\alpha^{3} h^{3}}$$", "id": "3529362"}]}