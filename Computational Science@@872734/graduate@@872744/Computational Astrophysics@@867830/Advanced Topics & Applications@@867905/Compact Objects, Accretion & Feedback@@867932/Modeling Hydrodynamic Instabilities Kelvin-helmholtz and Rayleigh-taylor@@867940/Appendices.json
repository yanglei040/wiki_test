{"hands_on_practices": [{"introduction": "Before we can trust a simulation to model complex physical phenomena, we must first confirm that our code correctly solves the governing equations. The Method of Manufactured Solutions (MMS) is a powerful and rigorous technique for code verification. This practice guides you through implementing an MMS test for the linearized Euler equations, teaching you to assess whether your numerical implementation achieves its designed order of accuracy, a fundamental skill for any computational scientist [@problem_id:3519370].", "problem": "Consider the two-dimensional, inviscid, compressible Euler equations linearized about a steady shear flow. Let the base (background) state be uniform density and pressure with a spatially varying streamwise velocity, specifically: background density $\\rho_0$ and pressure $p_0$ are constants, the adiabatic index is $\\gamma$, the speed of sound is $c \\equiv \\sqrt{\\gamma p_0 / \\rho_0}$, and the background velocity is $\\mathbf{U}(y) = U(y)\\,\\hat{\\mathbf{x}}$ with $U(y)$ differentiable. For small perturbations $(\\rho',u',v',p')$ about this base state, assume isentropic relations so that $p' = c^2 \\rho'$. In the linear approximation, the primitive-variable form of the equations for the perturbations is\n$$\n\\frac{\\partial \\rho'}{\\partial t} + U(y) \\frac{\\partial \\rho'}{\\partial x} + \\rho_0\\left(\\frac{\\partial u'}{\\partial x} + \\frac{\\partial v'}{\\partial y}\\right) = 0,\n$$\n$$\n\\rho_0\\left(\\frac{\\partial u'}{\\partial t} + U(y)\\frac{\\partial u'}{\\partial x} + v' \\frac{dU}{dy}\\right) + \\frac{\\partial p'}{\\partial x} = 0,\n$$\n$$\n\\rho_0\\left(\\frac{\\partial v'}{\\partial t} + U(y)\\frac{\\partial v'}{\\partial x}\\right) + \\frac{\\partial p'}{\\partial y} = 0,\n$$\nwith $p' = c^2 \\rho'$.\n\nYou will verify the spatial order of accuracy of finite-difference reconstructions for the above linearized operator using the Method of Manufactured Solutions (MMS). The idea is to define a smooth, periodic manufactured perturbation $(\\rho',u',v')$ and a background shear $U(y)$ on a periodic square domain and compute the exact source terms that make the manufactured solution an exact solution of the forced equations. Then, by applying a discrete spatial operator of nominal order $p$ to the manufactured fields and subtracting the exact source, the residual represents the spatial truncation error. The two-norm ($L_2$) of this residual should scale like $\\mathcal{O}(\\Delta x^p)$ for grid spacing $\\Delta x$.\n\nWork on the periodic square domain $\\Omega = [0,1]\\times[0,1]$ with periodic boundaries in both directions. Let the background shear be $U(y) = U_0 \\sin(2\\pi y)$ so that $\\frac{dU}{dy} = 2\\pi U_0 \\cos(2\\pi y)$. Define a smooth manufactured perturbation at time $t$ by\n$$\n\\rho'(x,y,t) = A_\\rho \\cos(k_x x + k_y y + \\omega t),\\quad\nu'(x,y,t) = A_u \\sin(k_x x + k_y y + \\omega t),\\quad\nv'(x,y,t) = A_v \\cos(k_x x + k_y y + \\omega t),\n$$\nand $p' = c^2 \\rho'$, where $k_x = 2\\pi m$, $k_y = 2\\pi n$, and $m,n$ are positive integers. Assume $A_\\rho$, $A_u$, $A_v$, and $\\omega$ are positive constants with small amplitudes to ensure linearity. The exact source terms $S_\\rho$, $S_u$, and $S_v$ are defined by substituting the manufactured solution into the continuous equations:\n$$\nS_\\rho \\equiv \\frac{\\partial \\rho'}{\\partial t} + U(y) \\frac{\\partial \\rho'}{\\partial x} + \\rho_0\\left(\\frac{\\partial u'}{\\partial x} + \\frac{\\partial v'}{\\partial y}\\right),\n$$\n$$\nS_u \\equiv \\rho_0\\left(\\frac{\\partial u'}{\\partial t} + U(y)\\frac{\\partial u'}{\\partial x} + v' \\frac{dU}{dy}\\right) + \\frac{\\partial p'}{\\partial x},\n$$\n$$\nS_v \\equiv \\rho_0\\left(\\frac{\\partial v'}{\\partial t} + U(y)\\frac{\\partial v'}{\\partial x}\\right) + \\frac{\\partial p'}{\\partial y}.\n$$\nFor a fixed time $t_0$, define the discrete spatial operator $L_h^{(p)}$ by replacing the spatial derivatives $\\frac{\\partial}{\\partial x}$ and $\\frac{\\partial}{\\partial y}$ with periodic, centered finite differences of nominal order $p$ (use $p \\in \\{2,4\\}$), while keeping time derivatives exact via the analytic manufactured solution. Specifically, for a grid with $N_x = N_y = N$ and $\\Delta x = \\Delta y = 1/N$, use centered finite differences:\n- For $p = 2$, the first derivative in the $x$-direction is approximated by the standard three-point stencil, and similarly in $y$.\n- For $p = 4$, the first derivative is approximated by the standard five-point stencil, and similarly in $y$.\nUse periodic boundary conditions implemented via index wrapping. Use the exact analytic $\\frac{dU}{dy}$ in the $v' \\frac{dU}{dy}$ term to avoid confounding errors.\n\nDefine the discrete residual components at time $t_0$ by\n$$\nR_\\rho^{(p)} \\equiv \\left[\\frac{\\partial \\rho'}{\\partial t} + U(y) D_x^{(p)}[\\rho'] + \\rho_0\\left(D_x^{(p)}[u'] + D_y^{(p)}[v']\\right)\\right] - S_\\rho,\n$$\n$$\nR_u^{(p)} \\equiv \\left[\\rho_0\\left(\\frac{\\partial u'}{\\partial t} + U(y)D_x^{(p)}[u'] + v' \\frac{dU}{dy}\\right) + D_x^{(p)}[p']\\right] - S_u,\n$$\n$$\nR_v^{(p)} \\equiv \\left[\\rho_0\\left(\\frac{\\partial v'}{\\partial t} + U(y)D_x^{(p)}[v']\\right) + D_y^{(p)}[p']\\right] - S_v.\n$$\nHere $D_x^{(p)}$ and $D_y^{(p)}$ denote order-$p$ periodic centered finite differences in $x$ and $y$, respectively. The discrete two-norm of the residual is defined as\n$$\n\\|R^{(p)}\\|_{2,h} \\equiv \\left(\\int_\\Omega \\left[(R_\\rho^{(p)})^2+(R_u^{(p)})^2+(R_v^{(p)})^2\\right]\\,dA \\right)^{1/2}\n\\approx \\left(\\sum_{i,j}\\left[(R_\\rho^{(p)})_{i,j}^2+(R_u^{(p)})_{i,j}^2+(R_v^{(p)})_{i,j}^2\\right]\\Delta x \\Delta y\\right)^{1/2}.\n$$\nFor smooth periodic functions, the truncation error of order-$p$ centered differences is known to scale as $\\mathcal{O}(\\Delta x^p)$ and $\\mathcal{O}(\\Delta y^p)$ in each direction. On a uniform grid with $\\Delta x = \\Delta y$, the norm $\\|R^{(p)}\\|_{2,h}$ should scale as $\\mathcal{O}(\\Delta x^p)$.\n\nTask:\n- Implement the above manufactured-solution residual evaluation at time $t_0 = 0$ using the given background and perturbation fields. Fix $\\rho_0 = 1$, $\\gamma = 1.4$, and $c = \\sqrt{\\gamma p_0 / \\rho_0}$ with $p_0$ chosen so that $c = 1$ (that is, set $p_0 = \\rho_0 c^2/\\gamma$ with $c = 1$). Use amplitudes $A_\\rho = 10^{-6}$, $A_u = 10^{-6}$, $A_v = 10^{-6}$, and angular frequency $\\omega = 1$ (radians per unit time).\n- For each specified reconstruction order $p$ and background shear amplitude $U_0$, evaluate $\\|R^{(p)}\\|_{2,h}$ on a sequence of grids with $N \\in \\{16,32,64,128\\}$ and compute the measured order $\\hat{p}$ by a least-squares linear fit of $\\log \\|R^{(p)}\\|_{2,h}$ versus $\\log \\Delta x$.\n- Use integer wavenumbers $(m,n)$ to define $k_x = 2\\pi m$ and $k_y = 2\\pi n$.\n\nTest suite:\n- Case $1$ (happy path): $p = 2$, $U_0 = 0.3$, $(m,n) = (1,2)$.\n- Case $2$ (higher order): $p = 4$, $U_0 = 0.3$, $(m,n) = (1,2)$.\n- Case $3$ (edge case, no shear and anisotropy in wavenumbers): $p = 4$, $U_0 = 0$, $(m,n) = (3,1)$.\n\nYour program must compute $\\hat{p}$ for each case and produce a single line of output containing the three measured orders as a comma-separated Python list in the order of the cases, rounded to three decimal places, for example, $[2.001,3.998,4.012]$. No other output should be produced.\n\nAll quantities are nondimensional in this verification task. Angles in trigonometric functions are in radians. The final output must be a single line in the format described above. The answers are pure floats with no units.", "solution": "The problem requires the verification of the spatial order of accuracy for finite-difference discretizations of the 2D linearized, inviscid, compressible Euler equations. The Method of Manufactured Solutions (MMS) is employed, a standard verification technique in computational science. The process involves defining a smooth analytical solution, substituting it into the governing partial differential equations (PDEs) to derive corresponding analytical source terms, and then measuring the convergence of the residual—the difference between the discretized PDE operator applied to the manufactured solution and the analytical source term—as the grid is refined.\n\nThe governing equations for the perturbations $(\\rho', u', v', p')$ around a steady shear flow $\\mathbf{U}(y) = U(y)\\,\\hat{\\mathbf{x}}$ with constant background density $\\rho_0$ and pressure $p_0$ are given by:\n$$\n\\frac{\\partial \\rho'}{\\partial t} + U(y) \\frac{\\partial \\rho'}{\\partial x} + \\rho_0\\left(\\frac{\\partial u'}{\\partial x} + \\frac{\\partial v'}{\\partial y}\\right) = 0\n$$\n$$\n\\rho_0\\left(\\frac{\\partial u'}{\\partial t} + U(y)\\frac{\\partial u'}{\\partial x} + v' \\frac{dU}{dy}\\right) + \\frac{\\partial p'}{\\partial x} = 0\n$$\n$$\n\\rho_0\\left(\\frac{\\partial v'}{\\partial t} + U(y)\\frac{\\partial v'}{\\partial x}\\right) + \\frac{\\partial p'}{\\partial y} = 0\n$$\nsupplemented by the isentropic relation $p' = c^2 \\rho'$, where $c = \\sqrt{\\gamma p_0 / \\rho_0}$ is the constant speed of sound.\n\nThe MMS procedure defines the analytical source terms $S_\\rho$, $S_u$, and $S_v$ that force the manufactured solution to be an exact solution to the modified PDEs:\n$$\n\\frac{\\partial \\rho'}{\\partial t} + U(y) \\frac{\\partial \\rho'}{\\partial x} + \\rho_0\\left(\\frac{\\partial u'}{\\partial x} + \\frac{\\partial v'}{\\partial y}\\right) = S_\\rho\n$$\n$$\n\\rho_0\\left(\\frac{\\partial u'}{\\partial t} + U(y)\\frac{\\partial u'}{\\partial x} + v' \\frac{dU}{dy}\\right) + \\frac{\\partial p'}{\\partial x} = S_u\n$$\n$$\n\\rho_0\\left(\\frac{\\partial v'}{\\partial t} + U(y)\\frac{\\partial v'}{\\partial x}\\right) + \\frac{\\partial p'}{\\partial y} = S_v\n$$\n\nThe specified background flow profile is $U(y) = U_0 \\sin(2\\pi y)$, with derivative $\\frac{dU}{dy} = 2\\pi U_0 \\cos(2\\pi y)$. The manufactured solution is given by:\n$$\n\\rho'(x,y,t) = A_\\rho \\cos(k_x x + k_y y + \\omega t)\n$$\n$$\nu'(x,y,t) = A_u \\sin(k_x x + k_y y + \\omega t)\n$$\n$$\nv'(x,y,t) = A_v \\cos(k_x x + k_y y + \\omega t)\n$$\nwhere $k_x = 2\\pi m$ and $k_y = 2\\pi n$. The evaluation is performed at $t_0 = 0$. Let $\\phi(x,y) = k_x x + k_y y$. The manufactured fields and their analytical derivatives at $t_0=0$ are:\n- Fields: $\\rho' = A_\\rho \\cos(\\phi)$, $u' = A_u \\sin(\\phi)$, $v' = A_v \\cos(\\phi)$, $p' = c^2 A_\\rho \\cos(\\phi)$.\n- Time derivatives: $\\frac{\\partial \\rho'}{\\partial t} = -A_\\rho \\omega \\sin(\\phi)$, $\\frac{\\partial u'}{\\partial t} = A_u \\omega \\cos(\\phi)$, $\\frac{\\partial v'}{\\partial t} = -A_v \\omega \\sin(\\phi)$.\n- Spatial derivatives:\n$\\frac{\\partial \\rho'}{\\partial x} = -k_x A_\\rho \\sin(\\phi)$, $\\frac{\\partial \\rho'}{\\partial y} = -k_y A_\\rho \\sin(\\phi)$\n$\\frac{\\partial u'}{\\partial x} = k_x A_u \\cos(\\phi)$, $\\frac{\\partial u'}{\\partial y} = k_y A_u \\cos(\\phi)$\n$\\frac{\\partial v'}{\\partial x} = -k_x A_v \\sin(\\phi)$, $\\frac{\\partial v'}{\\partial y} = -k_y A_v \\sin(\\phi)$\n$\\frac{\\partial p'}{\\partial x} = -c^2 k_x A_\\rho \\sin(\\phi)$, $\\frac{\\partial p'}{\\partial y} = -c^2 k_y A_\\rho \\sin(\\phi)$\n\nSubstituting these into the definitions of the source terms yields their exact analytical expressions at $t_0=0$:\n$S_\\rho = -A_\\rho \\omega \\sin(\\phi) + U_0 \\sin(2\\pi y)(-k_x A_\\rho \\sin(\\phi)) + \\rho_0(k_x A_u \\cos(\\phi) - k_y A_v \\sin(\\phi))$\n$S_u = \\rho_0 \\left( A_u \\omega \\cos(\\phi) + U_0 \\sin(2\\pi y)(k_x A_u \\cos(\\phi)) + A_v \\cos(\\phi) (2\\pi U_0 \\cos(2\\pi y)) \\right) - c^2 k_x A_\\rho \\sin(\\phi)$\n$S_v = \\rho_0 \\left( -A_v \\omega \\sin(\\phi) + U_0 \\sin(2\\pi y)(-k_x A_v \\sin(\\phi)) \\right) - c^2 k_y A_\\rho \\sin(\\phi)$\nThese source terms, along with the manufactured solution fields, are evaluated on a uniform grid with $N \\times N$ cells and spacing $\\Delta x = \\Delta y = 1/N$.\n\nThe spatial derivatives are approximated using centered finite-difference operators, denoted $D_x^{(p)}$ and $D_y^{(p)}$ for order $p$. For a function $f$ on the grid, these are:\n- $p=2$: $D_x^{(2)}[f]_{i,j} = \\frac{f_{i+1,j} - f_{i-1,j}}{2 \\Delta x}$\n- $p=4$: $D_x^{(4)}[f]_{i,j} = \\frac{-f_{i+2,j} + 8f_{i+1,j} - 8f_{i-1,j} + f_{i-2,j}}{12 \\Delta x}$\n(and analogously for $D_y^{(p)}$). Periodicity is handled by wrapping indices.\n\nThe discrete residuals, $R_\\rho^{(p)}$, $R_u^{(p)}$, and $R_v^{(p)}$, are computed by applying these discrete operators to the manufactured solution fields and subtracting the analytical source terms:\n$$\nR_\\rho^{(p)} = \\left[\\frac{\\partial \\rho'}{\\partial t} + U(y) D_x^{(p)}[\\rho'] + \\rho_0\\left(D_x^{(p)}[u'] + D_y^{(p)}[v']\\right)\\right] - S_\\rho\n$$\n$$\nR_u^{(p)} = \\left[\\rho_0\\left(\\frac{\\partial u'}{\\partial t} + U(y)D_x^{(p)}[u'] + v' \\frac{dU}{dy}\\right) + D_x^{(p)}[p']\\right] - S_u\n$$\n$$\nR_v^{(p)} = \\left[\\rho_0\\left(\\frac{\\partial v'}{\\partial t} + U(y)D_x^{(p)}[v']\\right) + D_y^{(p)}[p']\\right] - S_v\n$$\nThe terms $\\frac{\\partial \\rho'}{\\partial t}$, $\\frac{\\partial u'}{\\partial t}$, $\\frac{\\partial v'}{\\partial t}$, and $\\frac{dU}{dy}$ are evaluated using their exact analytical forms.\n\nThe total truncation error is quantified by the discrete $L_2$-norm of the residual vector over the domain $\\Omega = [0,1]^2$:\n$$\n\\|R^{(p)}\\|_{2,h} = \\left(\\sum_{i,j}\\left[(R_\\rho^{(p)})_{i,j}^2+(R_u^{(p)})_{i,j}^2+(R_v^{(p)})_{i,j}^2\\right]\\Delta x \\Delta y\\right)^{1/2}\n$$\nFor a method of order $p$, this norm is expected to scale as $\\|R^{(p)}\\|_{2,h} \\propto (\\Delta x)^p$. To measure the observed order of accuracy, $\\hat{p}$, we compute $\\|R^{(p)}\\|_{2,h}$ for a sequence of grid resolutions $N \\in \\{16, 32, 64, 128\\}$, corresponding to $\\Delta x = 1/N$. A linear least-squares fit is then performed on the logarithm of the error norm versus the logarithm of the grid spacing: $\\log(\\|R^{(p)}\\|_{2,h}) = \\hat{p} \\log(\\Delta x) + \\text{const}$. The slope of this fit gives the measured order $\\hat{p}$.\n\nThe implementation computes $\\hat{p}$ for three test cases by executing this procedure with the provided parameters: $\\rho_0=1$, $c=1$, $A_\\rho = A_u = A_v = 10^{-6}$, $\\omega=1$, and specific values for $p$, $U_0$, $m$, and $n$ for each case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the MMS test cases and print the results.\n    \"\"\"\n    # Global constants from the problem statement\n    RHO_0 = 1.0\n    C = 1.0\n    A_RHO = 1e-6\n    A_U = 1e-6\n    A_V = 1e-6\n    OMEGA = 1.0\n\n    def fd_deriv(f, dx, axis, p):\n        \"\"\"\n        Computes the periodic centered finite-difference derivative of order p.\n        \"\"\"\n        if p == 2:\n            # Stencil: (f_{i+1} - f_{i-1}) / (2*dx)\n            return (np.roll(f, -1, axis=axis) - np.roll(f, 1, axis=axis)) / (2.0 * dx)\n        elif p == 4:\n            # Stencil: (-f_{i+2} + 8f_{i+1} - 8f_{i-1} + f_{i-2}) / (12*dx)\n            return (-np.roll(f, -2, axis=axis) + 8.0 * np.roll(f, -1, axis=axis) -\n                    8.0 * np.roll(f, 1, axis=axis) + np.roll(f, 2, axis=axis)) / (12.0 * dx)\n        else:\n            raise ValueError(\"Unsupported order p. Use p=2 or p=4.\")\n\n    def calculate_order(p, U0, m, n):\n        \"\"\"\n        Calculates the measured order of accuracy for a single test case.\n        \"\"\"\n        k_x = 2.0 * np.pi * m\n        k_y = 2.0 * np.pi * n\n        resolutions = [16, 32, 64, 128]\n        log_dxs = []\n        log_errors = []\n\n        for N in resolutions:\n            dx = 1.0 / N\n            dy = dx  # Grid is uniform\n\n            # Create grid coordinates\n            x_pts = np.arange(N) * dx\n            y_pts = np.arange(N) * dy\n            xx, yy = np.meshgrid(x_pts, y_pts, indexing='xy')\n\n            # Phase at t=0\n            phi = k_x * xx + k_y * yy\n\n            # --- Analytical solution and sources at t=0 ---\n            # Manufactured fields\n            rho_p = A_RHO * np.cos(phi)\n            u_p = A_U * np.sin(phi)\n            v_p = A_V * np.cos(phi)\n            p_p = C**2 * rho_p\n            \n            # Analytical time derivatives\n            d_rho_p_dt = -A_RHO * OMEGA * np.sin(phi)\n            d_u_p_dt = A_U * OMEGA * np.cos(phi)\n            d_v_p_dt = -A_V * OMEGA * np.sin(phi)\n            \n            # Analytical spatial derivatives\n            d_rho_p_dx = -k_x * A_RHO * np.sin(phi)\n            d_rho_p_dy = -k_y * A_RHO * np.sin(phi)\n            d_u_p_dx = k_x * A_U * np.cos(phi)\n            d_v_p_dy = -k_y * A_V * np.sin(phi)\n            d_p_p_dx = C**2 * d_rho_p_dx\n            d_p_p_dy = C**2 * d_rho_p_dy\n            \n            # Background flow and its derivative\n            U_y = U0 * np.sin(2 * np.pi * yy)\n            dU_dy = 2 * np.pi * U0 * np.cos(2 * np.pi * yy)\n            \n            # Analytical source terms\n            S_rho = d_rho_p_dt + U_y * d_rho_p_dx + RHO_0 * (d_u_p_dx + d_v_p_dy)\n            S_u = RHO_0 * (d_u_p_dt + U_y * d_u_p_dx + v_p * dU_dy) + d_p_p_dx\n            S_v = RHO_0 * (d_v_p_dt + U_y * (-k_x * A_V * np.sin(phi))) + d_p_p_dy\n\n            # --- Discretized operator and Residual ---\n            # Discretized spatial derivatives\n            # axis=1 for x, axis=0 for y with 'xy' indexing\n            Dx_rho_p = fd_deriv(rho_p, dx, axis=1, p=p)\n            Dx_u_p = fd_deriv(u_p, dx, axis=1, p=p)\n            Dx_v_p = fd_deriv(v_p, dx, axis=1, p=p)\n            Dx_p_p = fd_deriv(p_p, dx, axis=1, p=p)\n            \n            Dy_v_p = fd_deriv(v_p, dy, axis=0, p=p)\n            Dy_p_p = fd_deriv(p_p, dy, axis=0, p=p)\n            \n            # Assemble discrete LHS of the equations\n            L_rho = d_rho_p_dt + U_y * Dx_rho_p + RHO_0 * (Dx_u_p + Dy_v_p)\n            L_u = RHO_0 * (d_u_p_dt + U_y * Dx_u_p + v_p * dU_dy) + Dx_p_p\n            L_v = RHO_0 * (d_v_p_dt + U_y * Dx_v_p) + Dy_p_p\n\n            # Residuals\n            R_rho = L_rho - S_rho\n            R_u = L_u - S_u\n            R_v = L_v - S_v\n            \n            # L2 norm of the residual vector\n            residual_norm_sq = np.sum(R_rho**2 + R_u**2 + R_v**2) * dx * dy\n            residual_norm = np.sqrt(residual_norm_sq)\n            \n            log_dxs.append(np.log(dx))\n            log_errors.append(np.log(residual_norm))\n\n        # --- Convergence analysis ---\n        # Linear fit: log(error) vs log(dx)\n        # log(error) = p_hat * log(dx) + const\n        slope, _ = np.polyfit(log_dxs, log_errors, 1)\n        \n        return slope\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (p, U0, m, n)\n        (2, 0.3, 1, 2),  # Case 1\n        (4, 0.3, 1, 2),  # Case 2\n        (4, 0.0, 3, 1),  # Case 3\n    ]\n\n    results = []\n    for p_val, U0_val, m_val, n_val in test_cases:\n        order = calculate_order(p=p_val, U0=U0_val, m=m_val, n=n_val)\n        results.append(order)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.3f}' for r in results)}]\")\n\nsolve()\n```", "id": "3519370"}, {"introduction": "Hydrodynamic simulations generate vast arrays of numbers representing physical fields at discrete points. To gain physical insight, we must process this raw data into meaningful diagnostics. This practice focuses on quantifying the outcome of instabilities like Kelvin-Helmholtz and Rayleigh-Taylor, which is often turbulent mixing. You will learn to implement essential post-processing metrics for compressible flows, such as scalar variance and turbulent kinetic energy, using the appropriate density-weighted (Favre) averaging techniques [@problem_id:3519383].", "problem": "You are given snapshots from ideal compressible hydrodynamics simulations relevant to Kelvin-Helmholtz (KH) and Rayleigh-Taylor (RT) flows. Each snapshot is represented on a uniform grid by arrays of cell-centered density $\\rho_i$ in $\\mathrm{kg\\,m^{-3}}$, velocity components $u_{x,i}$ and $u_{y,i}$ in $\\mathrm{m\\,s^{-1}}$, and a passive scalar mass fraction $Y_i$ (dimensionless) that labels one of the fluids. The grid is uniform, so all cells have equal volume. Consider the following three global mix metrics and compute them from the fields:\n\n- A mass-weighted scalar variance of the passive scalar mass fraction over the domain, defined using a density-weighted (Favre) average.\n- A mass-weighted mixing fraction defined as the fraction of total mass residing in cells whose passive scalar lies strictly between a prescribed tolerance $\\delta$ and $1-\\delta$.\n- The turbulent kinetic energy (TKE) per unit mass, defined using a density-weighted decomposition of the velocity field.\n\nStart from the conservation of mass and the definition of a density-weighted average for compressible flow, together with the definition of a fluctuation as the departure from an appropriate mean. Use these to derive expressions that depend only on $\\rho_i$, $u_{x,i}$, $u_{y,i}$, and $Y_i$, and a user-specified $\\delta$. Clearly distinguish any domain averages, mass-weighted averages, and fluctuation fields in your derivation. Assume a uniform grid so that volume weighting reduces to simple summation, and use density weighting whenever a mass-weighted average is needed. Express the turbulent kinetic energy per unit mass in $\\mathrm{m^2\\,s^{-2}}$, rounded to six decimal places. The other two metrics are dimensionless and must also be rounded to six decimal places.\n\nYour program must implement the derived expressions and evaluate them on the following test suite of cases, each specified by arrays with $4$ cells:\n\n- Case $1$ (unmixed, uniform velocity):\n  - $\\rho = (1, 1, 1, 1)$ in $\\mathrm{kg\\,m^{-3}}$\n  - $u_x = (1, 1, 1, 1)$ and $u_y = (0, 0, 0, 0)$ in $\\mathrm{m\\,s^{-1}}$\n  - $Y = (0, 0, 1, 1)$ (dimensionless)\n  - $\\delta = 0.01$\n- Case $2$ (fully mixed scalar, variable density and opposing velocities):\n  - $\\rho = (1, 2, 1, 2)$ in $\\mathrm{kg\\,m^{-3}}$\n  - $u_x = (1, -1, 1, -1)$ and $u_y = (0, 0, 0, 0)$ in $\\mathrm{m\\,s^{-1}}$\n  - $Y = (0.5, 0.5, 0.5, 0.5)$ (dimensionless)\n  - $\\delta = 0.01$\n- Case $3$ (partially mixed interface, stratified density, shear):\n  - $\\rho = (3, 3, 1, 1)$ in $\\mathrm{kg\\,m^{-3}}$\n  - $u_x = (0.5, 0.5, -0.5, -0.5)$ and $u_y = (0, 0, 0, 0)$ in $\\mathrm{m\\,s^{-1}}$\n  - $Y = (0.98, 0.9, 0.1, 0.02)$ (dimensionless)\n  - $\\delta = 0.05$\n\nDesign for coverage:\n- Case $1$ probes an unmixed state with trivial turbulence measure under uniform flow.\n- Case $2$ probes complete scalar mixing and nontrivial turbulent kinetic energy under density weighting.\n- Case $3$ probes partial mixing, nontrivial scalar variance, and shear with density stratification as in RT initial conditions.\n\nYour program should produce a single line of output containing the results as a comma-separated list of per-case triplets, where each triplet is ordered as $[\\text{scalar\\_variance}, \\text{mixing\\_fraction}, \\text{tke}]$. The overall output must be a single list containing the three per-case lists, for example:\n\"[[v1,m1,k1],[v2,m2,k2],[v3,m3,k3]]\"\nAll values must be rounded to six decimal places, with TKE in $\\mathrm{m^2\\,s^{-2}}$ and the other two dimensionless.", "solution": "The problem requires the derivation and computation of three diagnostic metrics for compressible hydrodynamic flows from discrete cell-centered data. The metrics are the mass-weighted scalar variance, the mass-weighted mixing fraction, and the turbulent kinetic energy per unit mass. The derivations will begin from the fundamental definition of a density-weighted (Favre) average for discrete data on a uniform grid.\n\nLet the computational domain be composed of $N$ cells, indexed by $i = 1, \\dots, N$. The quantities provided for each cell are density $\\rho_i$, velocity components $u_{x,i}$ and $u_{y,i}$, and a passive scalar mass fraction $Y_i$. Since the grid is uniform, each cell has the same volume $V$. The mass in cell $i$ is $m_i = \\rho_i V$.\n\nThe total mass over the domain is $M_{tot} = \\sum_{i=1}^{N} m_i = \\sum_{i=1}^{N} \\rho_i V = V \\sum_{i=1}^{N} \\rho_i$.\n\nA mass-weighted or Favre average of any quantity $\\phi$ is defined as the integral of $\\rho \\phi$ over the domain, divided by the total mass. For a discrete grid, this becomes:\n$$ \\widetilde{\\phi} = \\frac{\\sum_{i=1}^{N} \\phi_i m_i}{\\sum_{i=1}^{N} m_i} = \\frac{\\sum_{i=1}^{N} \\phi_i \\rho_i V}{\\sum_{i=1}^{N} \\rho_i V} = \\frac{\\sum_{i=1}^{N} \\rho_i \\phi_i}{\\sum_{i=1}^{N} \\rho_i} $$\nThe cell volume $V$ cancels, simplifying the expression. This definition will be used for all required averages.\n\n### Metric 1: Mass-Weighted Scalar Variance\nThe scalar variance measures the degree of inhomogeneity of the scalar field $Y$. For compressible flows, it is defined using Favre-averaged quantities. The fluctuation of the scalar in cell $i$ is the difference between the local value and the Favre-mean value: $Y_i'' = Y_i - \\widetilde{Y}$.\n\nThe Favre-mean of the scalar $Y$ is:\n$$ \\widetilde{Y} = \\frac{\\sum_{i=1}^{N} \\rho_i Y_i}{\\sum_{i=1}^{N} \\rho_i} $$\nThe mass-weighted variance, $\\sigma_Y^2$, is the Favre-average of the squared fluctuations, $(Y'')^2$:\n$$ \\sigma_Y^2 = \\widetilde{(Y'')^2} = \\widetilde{(Y - \\widetilde{Y})^2} $$\nSubstituting the definition of the Favre average:\n$$ \\sigma_Y^2 = \\frac{\\sum_{i=1}^{N} \\rho_i (Y_i - \\widetilde{Y})^2}{\\sum_{i=1}^{N} \\rho_i} $$\nFor computational purposes, it is often more stable and efficient to use an alternative form derived from expanding the square: $\\widetilde{(Y - \\widetilde{Y})^2} = \\widetilde{Y^2 - 2Y\\widetilde{Y} + \\widetilde{Y}^2}$. By the linearity of the averaging operator, this is $\\widetilde{Y^2} - 2\\widetilde{Y}\\widetilde{Y} + \\widetilde{Y}^2 = \\widetilde{Y^2} - (\\widetilde{Y})^2$.\nThe final discrete expression for the mass-weighted scalar variance is:\n$$ \\sigma_Y^2 = \\frac{\\sum_{i=1}^{N} \\rho_i Y_i^2}{\\sum_{i=1}^{N} \\rho_i} - \\left( \\frac{\\sum_{i=1}^{N} \\rho_i Y_i}{\\sum_{i=1}^{N} \\rho_i} \\right)^2 $$\nThis quantity is dimensionless as $Y_i$ is a dimensionless mass fraction.\n\n### Metric 2: Mass-Weighted Mixing Fraction\nThis metric, $M_\\delta$, quantifies the fraction of the total mass that is in a \"mixed\" state. A cell $i$ is considered mixed if its scalar mass fraction $Y_i$ lies strictly between a tolerance $\\delta$ and $1-\\delta$, i.e., $\\delta  Y_i  1 - \\delta$.\n\nThe total mass of mixed fluid, $M_{mixed}$, is the sum of masses of all cells that satisfy this condition.\n$$ M_{mixed} = \\sum_{i \\text{ s.t. } \\delta  Y_i  1-\\delta} m_i = \\sum_{i=1}^{N} m_i \\cdot I(\\delta  Y_i  1-\\delta) $$\nwhere $I(\\cdot)$ is the indicator function, which is $1$ if the condition is true and $0$ otherwise. Substituting $m_i = \\rho_i V$:\n$$ M_{mixed} = V \\sum_{i=1}^{N} \\rho_i \\cdot I(\\delta  Y_i  1-\\delta) $$\nThe mixing fraction is the ratio of the mixed mass to the total mass, $M_\\delta = M_{mixed} / M_{tot}$.\n$$ M_\\delta = \\frac{V \\sum_{i=1}^{N} \\rho_i \\cdot I(\\delta  Y_i  1-\\delta)}{V \\sum_{i=1}^{N} \\rho_i} = \\frac{\\sum_{i=1}^{N} \\rho_i \\cdot I(\\delta  Y_i  1-\\delta)}{\\sum_{i=1}^{N} \\rho_i} $$\nThis metric is a dimensionless ratio of masses.\n\n### Metric 3: Turbulent Kinetic Energy Per Unit Mass\nThe turbulent kinetic energy (TKE) per unit mass, $k$, is the kinetic energy associated with velocity fluctuations. The velocity field $\\mathbf{u}$ is decomposed into its Favre-mean part $\\widetilde{\\mathbf{u}}$ and its fluctuating part $\\mathbf{u}''$: $\\mathbf{u}_i = \\widetilde{\\mathbf{u}} + \\mathbf{u}_i''$.\n\nThe Favre-mean velocity components are:\n$$ \\widetilde{u_x} = \\frac{\\sum_{i=1}^{N} \\rho_i u_{x,i}}{\\sum_{i=1}^{N} \\rho_i} \\quad \\text{and} \\quad \\widetilde{u_y} = \\frac{\\sum_{i=1}^{N} \\rho_i u_{y,i}}{\\sum_{i=1}^{N} \\rho_i} $$\nThe TKE per unit mass is defined as half the Favre-average of the squared magnitude of the velocity fluctuations:\n$$ k = \\frac{1}{2}\\widetilde{|\\mathbf{u}''|^2} = \\frac{1}{2}\\widetilde{(u_x''^2 + u_y''^2)} = \\frac{1}{2}\\left( \\widetilde{(u_x - \\widetilde{u_x})^2} + \\widetilde{(u_y - \\widetilde{u_y})^2} \\right) $$\nUsing the same variance identity as for the scalar, $\\widetilde{(\\phi - \\widetilde{\\phi})^2} = \\widetilde{\\phi^2} - (\\widetilde{\\phi})^2$, we can write $k$ as:\n$$ k = \\frac{1}{2} \\left[ \\left( \\widetilde{u_x^2} - (\\widetilde{u_x})^2 \\right) + \\left( \\widetilde{u_y^2} - (\\widetilde{u_y})^2 \\right) \\right] $$\nSubstituting the discrete definitions for the Favre averages gives the final expression:\n$$ k = \\frac{1}{2} \\left[ \\left( \\frac{\\sum \\rho_i u_{x,i}^2}{\\sum \\rho_i} - \\left(\\frac{\\sum \\rho_i u_{x,i}}{\\sum \\rho_i}\\right)^2 \\right) + \\left( \\frac{\\sum \\rho_i u_{y,i}^2}{\\sum \\rho_i} - \\left(\\frac{\\sum \\rho_i u_{y,i}}{\\sum \\rho_i}\\right)^2 \\right) \\right] $$\nThe units of $k$ are those of velocity squared, i.e., $\\mathrm{m^2\\,s^{-2}}$.\n\nThese derived expressions can now be implemented to compute the required metrics for the given test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes three global mix metrics for several test cases from ideal\n    compressible hydrodynamics simulations.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (unmixed, uniform velocity)\n        {\n            \"rho\": np.array([1.0, 1.0, 1.0, 1.0]),\n            \"ux\": np.array([1.0, 1.0, 1.0, 1.0]),\n            \"uy\": np.array([0.0, 0.0, 0.0, 0.0]),\n            \"Y\": np.array([0.0, 0.0, 1.0, 1.0]),\n            \"delta\": 0.01\n        },\n        # Case 2 (fully mixed scalar, variable density and opposing velocities)\n        {\n            \"rho\": np.array([1.0, 2.0, 1.0, 2.0]),\n            \"ux\": np.array([1.0, -1.0, 1.0, -1.0]),\n            \"uy\": np.array([0.0, 0.0, 0.0, 0.0]),\n            \"Y\": np.array([0.5, 0.5, 0.5, 0.5]),\n            \"delta\": 0.01\n        },\n        # Case 3 (partially mixed interface, stratified density, shear)\n        {\n            \"rho\": np.array([3.0, 3.0, 1.0, 1.0]),\n            \"ux\": np.array([0.5, 0.5, -0.5, -0.5]),\n            \"uy\": np.array([0.0, 0.0, 0.0, 0.0]),\n            \"Y\": np.array([0.98, 0.9, 0.1, 0.02]),\n            \"delta\": 0.05\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        rho = case[\"rho\"]\n        ux = case[\"ux\"]\n        uy = case[\"uy\"]\n        Y = case[\"Y\"]\n        delta = case[\"delta\"]\n\n        # Total mass is proportional to sum of densities for a uniform grid.\n        sum_rho = np.sum(rho)\n\n        # Metric 1: Mass-weighted scalar variance of Y\n        # Formula: sigma_Y^2 = Y^2_favre - (Y_favre)^2\n        favre_Y = np.sum(rho * Y) / sum_rho\n        favre_Y2 = np.sum(rho * Y**2) / sum_rho\n        scalar_variance = favre_Y2 - favre_Y**2\n\n        # Metric 2: Mass-weighted mixing fraction\n        # Formula: M_delta = (sum of mass in \"mixed\" cells) / (total mass)\n        # A cell is \"mixed\" if delta  Y  1 - delta.\n        is_mixed_mask = (Y > delta)  (Y  (1.0 - delta))\n        mixed_mass = np.sum(rho[is_mixed_mask])\n        if sum_rho > 0:\n            mixing_fraction = mixed_mass / sum_rho\n        else:\n            mixing_fraction = 0.0 # Avoid division by zero if total mass is zero\n\n        # Metric 3: Turbulent kinetic energy (TKE) per unit mass\n        # Formula: k = 0.5 * [ (ux^2 - ux^2) + (uy^2 - uy^2) ]\n        favre_ux = np.sum(rho * ux) / sum_rho\n        favre_uy = np.sum(rho * uy) / sum_rho\n        favre_ux2 = np.sum(rho * ux**2) / sum_rho\n        favre_uy2 = np.sum(rho * uy**2) / sum_rho\n        \n        tke_x = favre_ux2 - favre_ux**2\n        tke_y = favre_uy2 - favre_uy**2\n        tke = 0.5 * (tke_x + tke_y)\n\n        results.append([scalar_variance, mixing_fraction, tke])\n\n    # Format the final output string as per problem specification.\n    # The format is a list of lists, with each number rounded to 6 decimal places,\n    # and no spaces within the inner lists.\n    formatted_triplets = []\n    for triplet in results:\n        v, m, k = triplet\n        formatted_triplets.append(f\"[{v:.6f},{m:.6f},{k:.6f}]\")\n    \n    final_output_string = f\"[{','.join(formatted_triplets)}]\"\n    print(final_output_string)\n\nsolve()\n```", "id": "3519383"}, {"introduction": "The accuracy of a simulation depends not only on the correctness of the code but also on the subtle properties of the numerical schemes employed. Numerical diffusion, an unavoidable artifact of discretization, can artificially suppress the growth of physical instabilities. This exercise explores how the choice of reconstruction order in a finite-volume scheme—a key factor controlling numerical diffusion—directly impacts the measured growth rate of the Kelvin-Helmholtz instability, providing critical insight into the relationship between numerical methods and physical fidelity [@problem_id:3519393].", "problem": "Consider the incompressible Kelvin-Helmholtz instability of two semi-infinite, equal-density layers separated by a vortex sheet. The upper layer moves at velocity $+U/2$ and the lower layer at velocity $-U/2$ in the $x$ direction, so the velocity jump is $\\Delta U = U$. A single sinusoidal perturbation with wavelength $\\lambda$ and wavenumber $k = 2\\pi/\\lambda$ is imposed along the sheet. In the inviscid incompressible limit, the linear growth rate of the perturbation amplitude is given by a well-tested formula from classical stability theory: $\\gamma_{\\mathrm{true}} = \\tfrac{1}{2} k \\Delta U$. Throughout, use the unit meters per second for velocity (m/s), meters for length (m), and seconds for time (s), so that growth rates are in $\\mathrm{s}^{-1}$.\n\nYour task is to quantify how the use of different piecewise reconstruction orders in a finite-volume Godunov method affects the measured Kelvin-Helmholtz linear growth rate when the perturbation is sampled with $N$ points per wavelength. Model the numerical dissipation due to reconstruction by analyzing the semi-discrete upwind advection operator for a single Fourier mode. Proceed as follows:\n\n1. Adopt a uniform grid with spacing $\\Delta x = \\lambda/N$ and define the Fourier phase $\\theta = k \\Delta x = 2\\pi/N$. The angle unit is radians.\n\n2. Consider a positive characteristic speed $a = U/2$ representing the advective signal speed entering the Riemann solver dissipation. Construct the semi-discrete finite-volume update for linear advection with numerical flux at cell faces given by upwind reconstruction of order $r$ from the left. Specifically, to approximate the left state at interface $x_{i+1/2}$, use Lagrange polynomial interpolation of degree $r-1$ on the backward stencil $\\{x_i, x_{i-1}, \\dots, x_{i-(r-1)}\\}$ evaluated at $x_{i+1/2}$. This yields coefficients $\\{c_m\\}_{m=0}^{r-1}$ such that the reconstructed left state is $u_{i+1/2}^- = \\sum_{m=0}^{r-1} c_m\\, u_{i-m}$.\n\n3. For a single Fourier mode $u_i(t) = \\exp(i \\theta i)\\,A(t)$, insert the reconstruction into the semi-discrete flux-difference operator $du_i/dt = -\\frac{a}{\\Delta x}\\left(u_{i+1/2}^- - u_{i-1/2}^-\\right)$ and determine the complex amplification rate $\\Lambda_r(\\theta)$ defined by $dA/dt = \\Lambda_r(\\theta)\\,A$. The numerical amplitude damping rate is $D_r(\\theta) = -\\mathrm{Re}\\,\\Lambda_r(\\theta)$ with units $\\mathrm{s}^{-1}$.\n\n4. Define the measured Kelvin-Helmholtz linear growth rate as $\\gamma_{\\mathrm{meas}} = \\gamma_{\\mathrm{true}} - D_r(\\theta)$. The relative growth-rate error is then $\\varepsilon_r(N) = \\left(\\gamma_{\\mathrm{true}} - \\gamma_{\\mathrm{meas}}\\right)/\\gamma_{\\mathrm{true}}$, which must be expressed as a decimal number (not a percentage).\n\nCompute $\\varepsilon_r(N)$ for the three commonly used reconstruction orders that correspond to the following methods in the linear regime:\n- Second-order Monotonic Upstream-centered Schemes for Conservation Laws (MUSCL), $r=2$.\n- Third-order Piecewise Parabolic Method (PPM), $r=3$.\n- Fifth-order Weighted Essentially Non-Oscillatory (WENO5), $r=5$.\n\nUse the above semi-discrete analysis with the Lagrange-interpolated upwind reconstruction to evaluate $D_r(\\theta)$ exactly for each $r$ and $N$; do not assume any a priori power-law error model.\n\nTest Suite and Answer Specification:\n- Use the fixed physical parameters $U = 1000\\,\\mathrm{m/s}$ and $\\lambda = 1\\,\\mathrm{m}$ for all cases. This implies $k = 2\\pi\\,\\mathrm{m}^{-1}$ and $\\gamma_{\\mathrm{true}} = \\tfrac{1}{2} k U$ in $\\mathrm{s}^{-1}$.\n- Evaluate the relative error $\\varepsilon_r(N)$ for the following twelve parameter sets $(N,r)$:\n  - $(N,r) \\in \\{(8,2),(8,3),(8,5),(16,2),(16,3),(16,5),(32,2),(32,3),(32,5),(64,2),(64,3),(64,5)\\}$.\n- Each test case’s answer is a single float equal to $\\varepsilon_r(N)$ (dimensionless) expressed as a decimal number (not a percentage).\n- Final Output Format: Your program should produce a single line of output containing the twelve results, in the exact order listed above, as a comma-separated list enclosed in square brackets, for example, \"[result1,result2,...,result12]\".", "solution": "The user wants to compute the relative error in the Kelvin-Helmholtz instability growth rate due to numerical dissipation from different-order reconstruction schemes in a finite-volume method. The analysis is performed on a simplified model problem: the linear advection equation.\n\nThe problem is determined to be valid as it is scientifically grounded in computational fluid dynamics, well-posed, objective, and internally consistent. We can proceed with the solution.\n\nThe core task is to calculate the relative growth-rate error, $\\varepsilon_r(N)$, defined as:\n$$\n\\varepsilon_r(N) = \\frac{\\gamma_{\\mathrm{true}} - \\gamma_{\\mathrm{meas}}}{\\gamma_{\\mathrm{true}}}\n$$\nThe problem specifies the measured growth rate, $\\gamma_{\\mathrm{meas}}$, as the true physical growth rate, $\\gamma_{\\mathrm{true}}$, diminished by the numerical amplitude damping rate, $D_r(\\theta)$, from the model advection problem.\n$$\n\\gamma_{\\mathrm{meas}} = \\gamma_{\\mathrm{true}} - D_r(\\theta)\n$$\nSubstituting this into the error definition gives:\n$$\n\\varepsilon_r(N) = \\frac{\\gamma_{\\mathrm{true}} - (\\gamma_{\\mathrm{true}} - D_r(\\theta))}{\\gamma_{\\mathrm{true}}} = \\frac{D_r(\\theta)}{\\gamma_{\\mathrm{true}}}\n$$\nOur goal is thus to find expressions for $\\gamma_{\\mathrm{true}}$ and $D_r(\\theta)$.\n\nFirst, we calculate the true physical growth rate, $\\gamma_{\\mathrm{true}}$. The problem provides the formula from classical linear stability theory:\n$$\n\\gamma_{\\mathrm{true}} = \\frac{1}{2} k \\Delta U\n$$\nThe givens are the velocity jump $\\Delta U = U = 1000\\,\\mathrm{m/s}$ and the perturbation wavelength $\\lambda = 1\\,\\mathrm{m}$. The wavenumber $k$ is related to the wavelength by $k = 2\\pi/\\lambda$.\n$$\n\\gamma_{\\mathrm{true}} = \\frac{1}{2} \\left(\\frac{2\\pi}{\\lambda}\\right) U = \\frac{\\pi U}{\\lambda}\n$$\nUsing the provided values, $\\gamma_{\\mathrm{true}} = \\pi (1000\\,\\mathrm{m/s}) / (1\\,\\mathrm{m}) = 1000\\pi\\,\\mathrm{s}^{-1}$.\n\nNext, we derive the numerical damping rate, $D_r(\\theta)$. We start with the semi-discrete finite-volume update for linear advection, with characteristic speed $a  0$:\n$$\n\\frac{du_i}{dt} = -\\frac{a}{\\Delta x}\\left(u_{i+1/2}^- - u_{i-1/2}^-\\right)\n$$\nHere, $u_{i+1/2}^-$ is the state reconstructed at the left of interface $x_{i+1/2}$ using Lagrange interpolation of degree $r-1$ on the backward stencil $\\{x_i, x_{i-1}, \\dots, x_{i-(r-1)}\\}$. This reconstruction can be written as a linear combination of the cell-average values $u_{i-m}$:\n$$\nu_{i+1/2}^- = \\sum_{m=0}^{r-1} c_m u_{i-m}\n$$\nThe coefficients $\\{c_m\\}$ are determined by the choice of interpolation stencil and evaluation point. For the stencil of nodes $\\{x_{i-m}\\}_{m=0}^{r-1}$ and evaluation at $x_{i+1/2}$, these coefficients are constant for a uniform grid.\n\nWe analyze the behavior of this operator on a single Fourier mode, $u_i(t) = \\exp(i \\theta i) A(t)$, where $\\theta = k \\Delta x = 2\\pi/N$ is the discrete Fourier phase. The problem defines the complex amplification rate $\\Lambda_r(\\theta)$ via the relation $dA/dt = \\Lambda_r(\\theta) A(t)$.\n\nSubstituting the Fourier mode ansatz into the left-hand side of the semi-discrete equation gives:\n$$\n\\frac{d}{dt} \\left( e^{i \\theta i} A(t) \\right) = e^{i \\theta i} \\frac{dA}{dt} = e^{i \\theta i} \\Lambda_r(\\theta) A(t)\n$$\nFor the right-hand side, we first express the reconstructed states in terms of the Fourier mode:\n$$\nu_{i+1/2}^- = \\sum_{m=0}^{r-1} c_m u_{i-m} = \\sum_{m=0}^{r-1} c_m \\left( e^{i \\theta (i-m)} A(t) \\right) = A(t) e^{i \\theta i} \\sum_{m=0}^{r-1} c_m e^{-i \\theta m}\n$$\nThe reconstruction at the preceding interface, $u_{i-1/2}^-$, uses the same coefficients but on a stencil shifted one cell to the left, i.e., applied to $\\{u_{i-1}, u_{i-2}, \\dots, u_{i-r}\\}$:\n$$\nu_{i-1/2}^- = \\sum_{m=0}^{r-1} c_m u_{i-1-m} = \\sum_{m=0}^{r-1} c_m \\left( e^{i \\theta (i-1-m)} A(t) \\right) = A(t) e^{i \\theta i} e^{-i \\theta} \\sum_{m=0}^{r-1} c_m e^{-i \\theta m}\n$$\nLet's define the symbol of the reconstruction operator as $S_r(\\theta) = \\sum_{m=0}^{r-1} c_m e^{-i \\theta m}$. The reconstructed states simplify to:\n$$\nu_{i+1/2}^- = A(t) e^{i \\theta i} S_r(\\theta) \\quad \\text{and} \\quad u_{i-1/2}^- = A(t) e^{i \\theta i} e^{-i \\theta} S_r(\\theta)\n$$\nSubstituting these into the right-hand side of the semi-discrete equation:\n$$\n-\\frac{a}{\\Delta x} \\left( A(t) e^{i \\theta i} S_r(\\theta) - A(t) e^{i \\theta i} e^{-i \\theta} S_r(\\theta) \\right) = -\\frac{a}{\\Delta x} A(t) e^{i \\theta i} S_r(\\theta) \\left(1 - e^{-i \\theta}\\right)\n$$\nEquating the transformed left and right sides and canceling the common factor $A(t) e^{i \\theta i}$ yields the expression for $\\Lambda_r(\\theta)$:\n$$\n\\Lambda_r(\\theta) = -\\frac{a}{\\Delta x} \\left(1 - e^{-i\\theta}\\right) S_r(\\theta)\n$$\nThe numerical amplitude damping rate is defined as $D_r(\\theta) = -\\mathrm{Re}\\,\\Lambda_r(\\theta)$.\n$$\nD_r(\\theta) = -\\mathrm{Re}\\left[ -\\frac{a}{\\Delta x} \\left(1 - e^{-i\\theta}\\right) S_r(\\theta) \\right] = \\frac{a}{\\Delta x} \\mathrm{Re}\\left[ \\left(1 - e^{-i\\theta}\\right) S_r(\\theta) \\right]\n$$\nThe Lagrange interpolation coefficients $c_m$ for reconstruction at $x_{i+1/2}$ from nodes $\\{x_i, x_{i-1}, \\ldots, x_{i-(r-1)}\\}$ can be computed in a shifted coordinate system where the nodes are $\\{0, -1, \\ldots, -(r-1)\\}$ and the evaluation point is $1/2$. The formula for the $m$-th coefficient is:\n$$\nc_m = \\prod_{j=0, j \\neq m}^{r-1} \\frac{\\frac{1}{2} - (-j)}{(-m) - (-j)} = \\prod_{j=0, j \\neq m}^{r-1} \\frac{j + 1/2}{j-m}\n$$\n\nFinally, we combine everything to get the expression for the relative error $\\varepsilon_r(N)$.\nGiven $a = U/2$, $\\Delta x = \\lambda/N$, $\\theta = 2\\pi/N$, and $\\gamma_{\\mathrm{true}} = \\pi U / \\lambda$:\n$$\n\\frac{a}{\\Delta x} = \\frac{U/2}{\\lambda/N} = \\frac{UN}{2\\lambda}\n$$\n$$\nD_r(\\theta) = \\frac{UN}{2\\lambda} \\mathrm{Re}\\left[ \\left(1 - e^{-i 2\\pi/N}\\right) \\sum_{m=0}^{r-1} c_m e^{-i m 2\\pi/N} \\right]\n$$\n$$\n\\varepsilon_r(N) = \\frac{D_r(\\theta)}{\\gamma_{\\mathrm{true}}} = \\frac{\\frac{UN}{2\\lambda} \\mathrm{Re}\\left[ \\dots \\right]}{\\frac{\\pi U}{\\lambda}} = \\frac{N}{2\\pi} \\mathrm{Re}\\left[ \\left(1 - e^{-i 2\\pi/N}\\right) \\sum_{m=0}^{r-1} c_m e^{-i m 2\\pi/N} \\right]\n$$\nThis final formula is implemented for each pair $(N, r)$ in the test suite using the physical parameters $U=1000\\,\\mathrm{m/s}$ and $\\lambda=1\\,\\mathrm{m}$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_lagrange_coeffs(r: int) - np.ndarray:\n    \"\"\"\n    Computes the Lagrange interpolation coefficients for an r-point\n    upwind reconstruction evaluated at the half-integer interface.\n    The stencil is {x_i, ..., x_{i-(r-1)}} and the evaluation\n    point is x_{i+1/2}. In a shifted grid where x_{i-j} is at -j,\n    the evaluation point is at +1/2.\n\n    Args:\n        r: The order of reconstruction (number of points in the stencil).\n\n    Returns:\n        A numpy array of r coefficients.\n    \"\"\"\n    coeffs = np.zeros(r)\n    nodes = np.arange(0, -r, -1, dtype=float)\n    eval_point = 0.5\n\n    for m in range(r):\n        m_node = nodes[m]\n        numerator = 1.0\n        denominator = 1.0\n        for j in range(r):\n            if j != m:\n                numerator *= (eval_point - nodes[j])\n                denominator *= (m_node - nodes[j])\n        coeffs[m] = numerator / denominator\n    return coeffs\n\ndef solve():\n    \"\"\"\n    Computes the relative growth-rate error for the Kelvin-Helmholtz instability\n    due to numerical dissipation from different piecewise reconstruction orders.\n    \"\"\"\n    # Define the physical parameters from the problem statement.\n    U = 1000.0  # m/s\n    lambda_val = 1.0  # m\n\n    # Calculate the true physical growth rate\n    k = 2.0 * np.pi / lambda_val\n    gamma_true = 0.5 * k * U\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (8, 2), (8, 3), (8, 5),\n        (16, 2), (16, 3), (16, 5),\n        (32, 2), (32, 3), (32, 5),\n        (64, 2), (64, 3), (64, 5),\n    ]\n\n    results = []\n    for N, r in test_cases:\n        # Step 1: Define grid-dependent parameters\n        theta = 2.0 * np.pi / N\n\n        # Step 2: Get reconstruction coefficients\n        coeffs = get_lagrange_coeffs(r)\n\n        # Step 3: Determine the complex amplification rate Lambda_r(theta)\n        # First, compute the symbol of the reconstruction operator S_r(theta)\n        S_r_theta = 0.0 + 0.0j\n        m_indices = np.arange(r)\n        S_r_theta = np.sum(coeffs * np.exp(-1j * theta * m_indices))\n        \n        # Calculate Lambda_r(theta)\n        # a / Delta_x = (U/2) / (lambda/N) = U*N/(2*lambda)\n        a_over_dx = U * N / (2.0 * lambda_val)\n        lambda_r = -a_over_dx * (1.0 - np.exp(-1j * theta)) * S_r_theta\n        \n        # Step 4: Calculate numerical damping rate D_r and relative error epsilon\n        # D_r = -Re(Lambda_r)\n        D_r = -np.real(lambda_r)\n        \n        # epsilon = D_r / gamma_true\n        epsilon = D_r / gamma_true\n        results.append(epsilon)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3519393"}]}