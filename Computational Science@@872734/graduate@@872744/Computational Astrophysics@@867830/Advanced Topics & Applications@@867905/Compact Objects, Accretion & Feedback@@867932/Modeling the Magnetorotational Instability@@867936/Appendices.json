{"hands_on_practices": [{"introduction": "A robust numerical simulation begins with a correct and conservative implementation of the governing equations. This practice focuses on a foundational and often tricky aspect of shearing-box codes: ensuring that the source terms modeling Coriolis, tidal, and shear effects are coupled to a consistent energy source term. By deriving and implementing these terms from first principles, you will verify the conservation of total energy at the discrete level, a critical validation step for any magnetohydrodynamics code [@problem_id:3521855].", "problem": "You are to design and implement a conservative finite-volume discretization for compressible ideal magnetohydrodynamics (MHD) in a local shearing-box model of an accretion disk to verify balanced energy exchange among kinetic, magnetic, and thermal components while correctly applying shear source terms that model magnetorotational instability (MRI) physics. Your solution must start from first principles: write the conservative one-dimensional ideal MHD system along the radial coordinate, derive fluxes from the conservation laws, and construct source terms consistent with the shearing-box approximation and energy accounting. Then implement the resulting update in code and quantitatively assess discrete energy balance for a test suite.\n\nBegin from the conservation form of ideal MHD and the shearing-box equations. In a local frame co-rotating with angular velocity $\\Omega$, with shear parameter $q$, define the conservative state vector per cell as $U = [\\rho, m_x, m_y, m_z, B_x, B_y, B_z, E]$, where $\\rho$ is mass density, $\\boldsymbol{m} = \\rho \\boldsymbol{v}$ is momentum density, $\\boldsymbol{B}$ is magnetic field, and $E$ is total energy density. The thermodynamic pressure $p$ is recovered from the internal energy density $e_{\\mathrm{th}}$ via an ideal gas relation $p = (\\gamma - 1) e_{\\mathrm{th}}$, with adiabatic index $\\gamma$. The total energy density is $E = e_{\\mathrm{th}} + \\tfrac{1}{2}\\rho |\\boldsymbol{v}|^2 + \\tfrac{1}{2}|\\boldsymbol{B}|^2$. The equations are discretized in a finite-volume sense along the $x$ (radial) direction with periodic boundary conditions and no external boundaries.\n\nUse a local Riemann solver approximation that is consistent with the conservative integral form. A robust choice is a Lax–Friedrichs (Rusanov) flux, where an inter-cell numerical flux $F_{i+\\tfrac{1}{2}}$ between cells $i$ and $i+1$ is computed from the left and right states $U_L$ and $U_R$ using the physical MHD fluxes and a single dissipation speed $a_{\\max}$ that exceeds all characteristic wave speeds. The update for each cell $i$ over a time step $\\Delta t$ is given by a conservative flux-divergence term and physically motivated source terms,\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\tfrac{1}{2}}^n - F_{i-\\tfrac{1}{2}}^n\\right) + \\Delta t\\, S(U_i^n).\n$$\n\nModel the shearing box source terms that represent Coriolis and tidal effects on momentum, and the effect of background shear on induction. In the shearing-box approximation with local angular velocity $\\Omega$ and shear parameter $q$, the momentum source terms are\n$$\nS_{m_x} = 2 \\rho \\Omega v_y,\\quad\nS_{m_y} = - (2 - q)\\rho \\Omega v_x,\\quad\nS_{m_z} = 0,\n$$\nand the induction source term that represents background shear is\n$$\nS_{B_y} = - q \\Omega B_x, \\quad S_{B_x} = 0,\\quad S_{B_z} = 0.\n$$\nEnsure total energy consistency by including the corresponding work terms in the energy source,\n$$\nS_E = \\boldsymbol{v}\\cdot \\boldsymbol{S}_m + \\boldsymbol{B}\\cdot \\boldsymbol{S}_B.\n$$\nNote that the Coriolis force does no work, i.e., $\\boldsymbol{v}\\cdot(2\\boldsymbol{\\Omega}\\times\\boldsymbol{v}) = 0$, and that the magnetic energy source must be $S_{E,\\mathrm{mag}} = \\boldsymbol{B}\\cdot \\boldsymbol{S}_B$ to capture the work done by background shear on the magnetic field. You must derive the physical fluxes for one-dimensional ideal MHD along the $x$-direction from the conservation laws and use them in the numerical flux.\n\nAll variables are nondimensionalized and expressed in code units, so no physical unit conversion is required. Angles do not appear explicitly, so no angle unit specification is required.\n\nImplement the algorithm in a single program using a uniform grid of $N$ cells, domain length $L$, and periodic boundaries. Use a global time step $\\Delta t$ that satisfies a Courant condition based on the maximum estimated fast signal speed and is also small enough to stably integrate the source terms. Perform a single explicit time step from initial conditions to evaluate the discrete energy balance. For each test case, compute the residual energy imbalance defined as\n$$\nR = \\left(\\sum_i E_i^{n+1}\\right) - \\left(\\sum_i E_i^{n}\\right) - \\Delta t \\left(\\sum_i S_{E,i}\\right),\n$$\nwhich should be approximately zero if the discretization balances energy exchange among kinetic, magnetic, and thermal components and the source work is applied consistently. Express the residuals as floating-point numbers.\n\nTest Suite:\nUse the following four test cases to probe different aspects of the discretization. All quantities are in nondimensional code units, and $L = 1$ and periodic boundary conditions are used in all cases. In each case, use $N = 64$ cells, $\\gamma = \\tfrac{5}{3}$, and compute $\\Delta t$ from a Courant factor $C = 0.3$ with the maximum characteristic speed, additionally limited by the source time scales.\n\n- Case $1$ (happy path, no shear): $\\Omega = 1$, $q = 0$. Uniform initial state with $\\rho = 1$, $p = 1$, $v_x = 0.3$, $v_y = 0.2$, $v_z = 0$, $B_x = 0$, $B_y = 0$, $B_z = 0$.\n- Case $2$ (shear induction with magnetic energy work): $\\Omega = 1$, $q = \\tfrac{3}{2}$. Uniform initial state with $\\rho = 1$, $p = 1$, $v_x = 0$, $v_y = 0$, $v_z = 0$, $B_x = 0.5$, $B_y = 0.3$, $B_z = 0$.\n- Case $3$ (pressure work exchange, hydrodynamic compressive flow): $\\Omega = 0$, $q = 0$. Initial state with $\\rho(x) = 1$, $p(x) = 1$, $B_x = 0$, $B_y = 0$, $B_z = 0$, $v_x(x) = 0.5\\sin(2\\pi x)$, $v_y(x) = 0$, $v_z(x) = 0$.\n- Case $4$ (magnetic tension exchange): $\\Omega = 0$, $q = 0$. Initial state with $\\rho(x) = 1$, $p(x) = 1$, $v_x(x) = 0$, $v_y(x) = 0.3\\cos(2\\pi x)$, $v_z(x) = 0$, $B_x = 0.5$, $B_y(x) = 0.2\\sin(2\\pi x)$, $B_z(x) = 0$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the residual energy imbalances for the four test cases as a comma-separated list enclosed in square brackets, in the order of the cases listed above. For example, the output must look like\n$$\n[\\text{residual}_1,\\text{residual}_2,\\text{residual}_3,\\text{residual}_4].\n$$\nEach residual must be a floating-point number. No other text should be printed.", "solution": "The problem is well-posed, scientifically grounded, and provides all necessary information to construct a numerical solution. It represents a standard verification test for a magnetohydrodynamics (MHD) code incorporating shearing-box source terms. The task is to implement a one-dimensional finite-volume scheme and verify its energy conservation properties. We will first derive the necessary equations from first principles and then outline the algorithm for implementation.\n\n### 1. Ideal MHD Equations and Shearing-Box Model\n\nThe problem is defined in a local, co-rotating Cartesian frame $(x, y, z)$ corresponding to the radial, azimuthal, and vertical directions in an accretion disk. The ideal MHD equations are expressed in conservative form, $\\frac{\\partial U}{\\partial t} + \\frac{\\partial F}{\\partial x} = S$, where $U$ is the vector of conserved quantities, $F$ is the flux vector in the $x$-direction, and $S$ is the source term vector.\n\nThe state vector of conserved quantities per unit volume is given by:\n$$\nU = [\\rho, m_x, m_y, m_z, B_x, B_y, B_z, E]^T\n$$\nwhere $\\rho$ is the mass density, $\\boldsymbol{m} = \\rho\\boldsymbol{v}$ is the momentum density, $\\boldsymbol{B}$ is the magnetic field, and $E$ is the total energy density.\n\nThe primitive variables $(\\rho, \\boldsymbol{v}, p, \\boldsymbol{B})$ are recovered from the conserved state $U$ as follows:\n- Mass density: $\\rho = U_1$\n- Velocity: $\\boldsymbol{v} = (v_x, v_y, v_z) = (\\frac{m_x}{\\rho}, \\frac{m_y}{\\rho}, \\frac{m_z}{\\rho}) = (\\frac{U_2}{U_1}, \\frac{U_3}{U_1}, \\frac{U_4}{U_1})$\n- Magnetic field: $\\boldsymbol{B} = (B_x, B_y, B_z) = (U_5, U_6, U_7)$\n\nThe total energy density $E$ is the sum of internal (thermal), kinetic, and magnetic energies:\n$$\nE = e_{\\mathrm{th}} + \\frac{1}{2}\\rho|\\boldsymbol{v}|^2 + \\frac{1}{2}|\\boldsymbol{B}|^2 = e_{\\mathrm{th}} + \\frac{|\\boldsymbol{m}|^2}{2\\rho} + \\frac{|\\boldsymbol{B}|^2}{2}\n$$\nThe internal energy density $e_{\\mathrm{th}}$ can thus be calculated from $U$:\n$$\ne_{\\mathrm{th}} = E - \\frac{m_x^2 + m_y^2 + m_z^2}{2\\rho} - \\frac{B_x^2 + B_y^2 + B_z^2}{2}\n$$\nThe system is closed with an ideal gas equation of state, relating the thermal pressure $p$ to the internal energy density:\n$$\np = (\\gamma - 1)e_{\\mathrm{th}}\n$$\nwhere $\\gamma$ is the adiabatic index. The total pressure is $p_{\\mathrm{tot}} = p + \\frac{1}{2}|\\boldsymbol{B}|^2$.\n\n### 2. Physical Fluxes and Source Terms\n\nThe physical flux vector $F(U)$ in the $x$-direction for the ideal MHD equations is:\n$$\nF(U) = \\begin{pmatrix}\n\\rho v_x \\\\\n\\rho v_x^2 + p_{\\mathrm{tot}} - B_x^2 \\\\\n\\rho v_x v_y - B_x B_y \\\\\n\\rho v_x v_z - B_x B_z \\\\\n0 \\\\\nv_y B_x - v_x B_y \\\\\nv_z B_x - v_x B_z \\\\\n(E + p_{\\mathrm{tot}})v_x - (\\boldsymbol{v} \\cdot \\boldsymbol{B})B_x\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nm_x \\\\\n\\frac{m_x^2}{\\rho} + p + \\frac{1}{2}(B_y^2 + B_z^2 - B_x^2) \\\\\n\\frac{m_x m_y}{\\rho} - B_x B_y \\\\\n\\frac{m_x m_z}{\\rho} - B_x B_z \\\\\n0 \\\\\n\\frac{m_y B_x - m_x B_y}{\\rho} \\\\\n\\frac{m_z B_x - m_x B_z}{\\rho} \\\\\n(E + p + \\frac{1}{2}|\\boldsymbol{B}|^2)\\frac{m_x}{\\rho} - \\frac{m_x B_x + m_y B_y + m_z B_z}{\\rho} B_x\n\\end{pmatrix}\n$$\nNote that for 1D flow along $x$, the divergence-free condition $\\nabla \\cdot \\boldsymbol{B} = 0$ implies $\\frac{\\partial B_x}{\\partial x} = 0$, making $B_x$ spatially uniform. The induction equation $\\frac{\\partial B_x}{\\partial t} = 0$ for 1D flows means the corresponding physical flux component is zero.\n\nThe shearing-box source terms $S(U)$ are given for momentum and induction. We must derive the energy source term $S_E$ to ensure conservation.\nThe specified momentum and magnetic source terms are:\n$$\nS_m = \\begin{pmatrix} S_{m_x} \\\\ S_{m_y} \\\\ S_{m_z} \\end{pmatrix} = \\begin{pmatrix} 2 \\rho \\Omega v_y \\\\ -(2-q)\\rho \\Omega v_x \\\\ 0 \\end{pmatrix}, \\quad\nS_B = \\begin{pmatrix} S_{B_x} \\\\ S_{B_y} \\\\ S_{B_z} \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ -q \\Omega B_x \\\\ 0 \\end{pmatrix}\n$$\nwhere $\\Omega$ is the local orbital frequency and $q$ is the shear parameter.\nThe total energy source term $S_E$ is the rate of work done by these source terms: $S_E = \\boldsymbol{v} \\cdot S_m + \\boldsymbol{B} \\cdot S_B$.\n$$\nS_E = v_x (2 \\rho \\Omega v_y) + v_y (-(2-q)\\rho \\Omega v_x) + v_z(0) + B_x(0) + B_y(-q \\Omega B_x) + B_z(0)\n$$\n$$\nS_E = (2 - (2-q))\\rho\\Omega v_x v_y - q\\Omega B_x B_y = q\\rho\\Omega v_x v_y - q\\Omega B_x B_y\n$$\nIn terms of conservative variables:\n$$\nS_E = q\\Omega\\left(\\frac{m_x m_y}{\\rho} - B_x B_y\\right)\n$$\nThe complete source vector is:\n$$\nS(U) = [0, S_{m_x}, S_{m_y}, 0, 0, S_{B_y}, 0, S_E]^T\n$$\n\n### 3. Numerical Discretization\n\nWe use a finite-volume method on a uniform grid of $N$ cells of width $\\Delta x = L/N$. The cell-averaged state is updated via:\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}}^n - F_{i-\\frac{1}{2}}^n\\right) + \\Delta t S(U_i^n)\n$$\nThe numerical flux $F_{i+\\frac{1}{2}}$ at the interface between cells $i$ and $i+1$ is approximated using the Lax-Friedrichs (Rusanov) formula:\n$$\nF_{i+\\frac{1}{2}} = \\frac{1}{2}\\left(F(U_L) + F(U_R)\\right) - \\frac{1}{2}a_{\\max}\\left(U_R - U_L\\right)\n$$\nHere, $U_L = U_i$ and $U_R = U_{i+1}$ are the states to the left and right of the interface. $a_{\\max}$ is an estimate of the maximum signal speed across the entire grid, ensuring numerical stability. It is given by the maximum of $|v_x| + c_{f,x}$ over all cells, where $c_{f,x}$ is the fast magnetosonic speed in the $x$-direction:\n$$\nc_{f,x}^2 = \\frac{1}{2} \\left[ (c_s^2 + v_A^2) + \\sqrt{(c_s^2 + v_A^2)^2 - 4 c_s^2 v_{Ax}^2} \\right]\n$$\nwith sound speed $c_s^2 = \\frac{\\gamma p}{\\rho}$, total Alfvén speed $v_A^2 = \\frac{|\\boldsymbol{B}|^2}{\\rho}$, and x-component Alfvén speed $v_{Ax}^2 = \\frac{B_x^2}{\\rho}$.\n\nThe time step $\\Delta t$ is constrained by both the Courant-Friedrichs-Lewy (CFL) condition for the hyperbolic fluxes and the stability of the source-term integration:\n$$\n\\Delta t = C \\min\\left(\\frac{\\Delta x}{a_{\\max}}, \\tau_{\\text{source}}\\right)\n$$\nwhere $C=0.3$ is the Courant factor. A reasonable choice for the source term timescale is $\\tau_{\\text{source}} = 1/|\\Omega|$ when $\\Omega \\neq 0$.\n\n### 4. Energy Balance Verification\n\nWith periodic boundary conditions, the sum of flux differences over the entire domain telescopes to zero: $\\sum_i (F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}) = 0$. Summing the update equation over all cells $i$ gives:\n$$\n\\sum_i U_i^{n+1} = \\sum_i U_i^n + \\Delta t \\sum_i S(U_i^n)\n$$\nFocusing on the energy component (the last element of $U$), this implies:\n$$\n\\sum_i E_i^{n+1} = \\sum_i E_i^n + \\Delta t \\sum_i S_{E,i}\n$$\nThe problem asks to compute the residual energy imbalance, defined as:\n$$\nR = \\left(\\sum_i E_i^{n+1}\\right) - \\left(\\sum_i E_i^{n}\\right) - \\Delta t \\left(\\sum_i S_{E,i}\\right)\n$$\nBased on the discrete conservation property, this residual $R$ should be zero up to floating-point precision. The calculation serves as a stringent test of the code's correctness, especially the consistent implementation of the energy source term.\n\n### 5. Algorithm Summary\n\nFor each test case:\n1.  Initialize a uniform grid with $N=64$ cells over the domain $L=1$.\n2.  Set the initial state vector $U^n$ in each cell based on the given primitive variables.\n3.  Compute the initial total energy $\\mathcal{E}^n = \\sum_i E_i^n$.\n4.  Calculate primitive variables and wave speeds for all cells. Determine the global maximum signal speed $a_{\\max}$.\n5.  Calculate the time step $\\Delta t$ using the CFL and source term constraints.\n6.  Compute the source vector $S(U_i^n)$ for all cells and the total energy source contribution $\\Delta t \\sum_i S_{E,i}$.\n7.  For each interface $i+\\frac{1}{2}$ (from $i=0$ to $N-1$, with periodic wrapping), compute the Rusanov flux $F_{i+\\frac{1}{2}}$.\n8.  Update the state in each cell to $U^{n+1}$ using the conservative finite-volume formula.\n9.  Compute the final total energy $\\mathcal{E}^{n+1} = \\sum_i E_i^{n+1}$.\n10. Calculate the residual $R = \\mathcal{E}^{n+1} - \\mathcal{E}^n - \\Delta t \\sum_i S_{E,i}$.\n\nThis procedure will be applied to all four specified test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Note: scipy is permitted but not required for this problem.\n\n# Global constant for adiabatic index\nGAMMA = 5.0 / 3.0\n\ndef cons_to_prim(U):\n    \"\"\"\n    Convert an array of conservative state vectors to primitive variables.\n    U: (N, 8) array of [rho, mx, my, mz, Bx, By, Bz, E]\n    Returns: rho, v, B, p - each as a numpy array.\n    \"\"\"\n    rho = U[:, 0]\n    # Ensure density is positive to avoid division by zero\n    rho_inv = 1.0 / np.maximum(rho, 1e-100)\n    \n    vx = U[:, 1] * rho_inv\n    vy = U[:, 2] * rho_inv\n    vz = U[:, 3] * rho_inv\n    v = np.stack((vx, vy, vz), axis=-1)\n    \n    Bx = U[:, 4]\n    By = U[:, 5]\n    Bz = U[:, 6]\n    B = np.stack((Bx, By, Bz), axis=-1)\n    \n    v_sq = np.sum(v**2, axis=1)\n    B_sq = np.sum(B**2, axis=1)\n    \n    e_th = U[:, 7] - 0.5 * rho * v_sq - 0.5 * B_sq\n    p = (GAMMA - 1.0) * e_th\n    \n    return rho, v, B, p\n\ndef get_physical_flux(U, prim_vars):\n    \"\"\"\n    Calculate the physical MHD flux vector in the x-direction.\n    U: (N, 8) array of conservative variables.\n    prim_vars: tuple of (rho, v, B, p) arrays.\n    Returns: F, an (N, 8) array of physical fluxes.\n    \"\"\"\n    rho, v, B, p = prim_vars\n    vx, vy, vz = v[:, 0], v[:, 1], v[:, 2]\n    Bx, By, Bz = B[:, 0], B[:, 1], B[:, 2]\n    \n    B_sq = np.sum(B**2, axis=1)\n    p_tot = p + 0.5 * B_sq\n    \n    F = np.zeros_like(U)\n    F[:, 0] = rho * vx\n    F[:, 1] = rho * vx**2 + p_tot - Bx**2\n    F[:, 2] = rho * vx * vy - Bx * By\n    F[:, 3] = rho * vx * vz - Bx * Bz\n    F[:, 4] = 0.0\n    F[:, 5] = vy * Bx - vx * By\n    F[:, 6] = vz * Bx - vx * Bz\n    \n    v_dot_B = np.sum(v * B, axis=1)\n    F[:, 7] = (U[:, 7] + p_tot) * vx - v_dot_B * Bx\n    \n    return F\n\ndef get_source_terms(U, prim_vars, q, Omega):\n    \"\"\"\n    Calculate the shearing-box source terms.\n    U: (N, 8) array of conservative variables.\n    prim_vars: tuple of (rho, v, B, p) arrays.\n    q, Omega: shear parameter and angular velocity.\n    Returns: S, an (N, 8) array of source terms.\n    \"\"\"\n    if Omega == 0.0:\n        return np.zeros_like(U)\n\n    rho, v, B, _ = prim_vars\n    vx, vy = v[:, 0], v[:, 1]\n    Bx, By = B[:, 0], B[:, 1]\n    \n    S = np.zeros_like(U)\n    \n    # Momentum sources\n    S[:, 1] = 2.0 * rho * Omega * vy\n    S[:, 2] = -(2.0 - q) * rho * Omega * vx\n    \n    # Induction sources\n    S[:, 5] = -q * Omega * Bx\n    \n    # Energy source (work done by other sources)\n    # S_E = q * rho * Omega * vx * vy - q * Omega * Bx * By\n    S[:, 7] = q * Omega * (U[:, 1] * U[:, 2] / rho - U[:, 4] * U[:, 5])\n\n    return S\n\ndef get_max_wave_speed(prim_vars):\n    \"\"\"\n    Calculate the maximum characteristic wave speed over the grid.\n    prim_vars: tuple of (rho, v, B, p) arrays.\n    Returns: a_max, a scalar float.\n    \"\"\"\n    rho, v, B, p = prim_vars\n    # Ensure positivity for stability\n    rho_safe = np.maximum(rho, 1e-100)\n    p_safe = np.maximum(p, 1e-100)\n\n    c_s_sq = GAMMA * p_safe / rho_safe\n    v_A_sq = np.sum(B**2, axis=1) / rho_safe\n    v_Ax_sq = B[:, 0]**2 / rho_safe\n    \n    radicand = (c_s_sq + v_A_sq)**2 - 4.0 * c_s_sq * v_Ax_sq\n    radicand = np.maximum(radicand, 0.0) # Ensure non-negative\n    \n    c_f_sq = 0.5 * (c_s_sq + v_A_sq + np.sqrt(radicand))\n    c_f = np.sqrt(c_f_sq)\n    \n    signal_speeds = np.abs(v[:, 0]) + c_f\n    return np.max(signal_speeds)\n\ndef run_simulation_step(N, L, q, Omega, C, initial_conditions_func):\n    \"\"\"\n    Performs a single time step for a given test case and computes the energy residual.\n    \"\"\"\n    dx = L / N\n    x = (np.arange(N) + 0.5) * dx\n    \n    # 1. Set up initial conditions\n    rho, v, B, p = initial_conditions_func(x)\n    \n    U = np.zeros((N, 8))\n    U[:, 0] = rho\n    U[:, 1:4] = rho[:, np.newaxis] * v\n    U[:, 4:7] = B\n    e_th = p / (GAMMA - 1.0)\n    U[:, 7] = e_th + 0.5 * rho * np.sum(v**2, axis=1) + 0.5 * np.sum(B**2, axis=1)\n    \n    # 2. Compute total initial energy and primitives\n    total_energy_initial = np.sum(U[:, 7])\n    prim_vars = cons_to_prim(U)\n    \n    # 3. Compute time step\n    a_max = get_max_wave_speed(prim_vars)\n    dt_cfl = dx / a_max\n    \n    if Omega != 0.0:\n        dt_source = 1.0 / np.abs(Omega)\n        dt = C * min(dt_cfl, dt_source)\n    else:\n        dt = C * dt_cfl\n        \n    # 4. Compute source terms and total energy source work\n    S = get_source_terms(U, prim_vars, q, Omega)\n    total_energy_source_work = dt * np.sum(S[:, 7])\n    \n    # 5. Compute numerical fluxes (Rusanov)\n    F_physical = get_physical_flux(U, prim_vars)\n    F_hat = np.zeros((N, 8))\n    \n    for i in range(N):\n        i_right = (i + 1) % N\n        U_L, U_R = U[i, :], U[i_right, :]\n        F_L, F_R = F_physical[i, :], F_physical[i_right, :]\n        \n        F_hat[i, :] = 0.5 * (F_L + F_R) - 0.5 * a_max * (U_R - U_L)\n        \n    # 6. Update conservative state vector\n    U_new = np.copy(U)\n    for i in range(N):\n        i_left_flux = (i - 1 + N) % N\n        flux_divergence = (F_hat[i, :] - F_hat[i_left_flux, :]) / dx\n        U_new[i, :] = U[i, :] - dt * flux_divergence + dt * S[i, :]\n        \n    # 7. Compute final total energy\n    total_energy_final = np.sum(U_new[:, 7])\n    \n    # 8. Compute and return residual\n    residual = total_energy_final - total_energy_initial - total_energy_source_work\n    return residual\n\ndef solve():\n    N = 64\n    L = 1.0\n    C = 0.3\n    \n    # Test case definitions\n    test_cases_params = [\n        {'q': 0.0, 'Omega': 1.0},\n        {'q': 1.5, 'Omega': 1.0},\n        {'q': 0.0, 'Omega': 0.0},\n        {'q': 0.0, 'Omega': 0.0},\n    ]\n\n    def ic_case1(x):\n        N_pts = len(x)\n        rho = np.full(N_pts, 1.0)\n        p = np.full(N_pts, 1.0)\n        v = np.zeros((N_pts, 3))\n        v[:, 0] = 0.3\n        v[:, 1] = 0.2\n        B = np.zeros((N_pts, 3))\n        return rho, v, B, p\n\n    def ic_case2(x):\n        N_pts = len(x)\n        rho = np.full(N_pts, 1.0)\n        p = np.full(N_pts, 1.0)\n        v = np.zeros((N_pts, 3))\n        B = np.zeros((N_pts, 3))\n        B[:, 0] = 0.5\n        B[:, 1] = 0.3\n        return rho, v, B, p\n\n    def ic_case3(x):\n        N_pts = len(x)\n        rho = np.full(N_pts, 1.0)\n        p = np.full(N_pts, 1.0)\n        v = np.zeros((N_pts, 3))\n        v[:, 0] = 0.5 * np.sin(2.0 * np.pi * x)\n        B = np.zeros((N_pts, 3))\n        return rho, v, B, p\n\n    def ic_case4(x):\n        N_pts = len(x)\n        rho = np.full(N_pts, 1.0)\n        p = np.full(N_pts, 1.0)\n        v = np.zeros((N_pts, 3))\n        v[:, 1] = 0.3 * np.cos(2.0 * np.pi * x)\n        B = np.zeros((N_pts, 3))\n        B[:, 0] = 0.5\n        B[:, 1] = 0.2 * np.sin(2.0 * np.pi * x)\n        return rho, v, B, p\n\n    initial_conditions_funcs = [ic_case1, ic_case2, ic_case3, ic_case4]\n    \n    results = []\n    for i in range(len(test_cases_params)):\n        params = test_cases_params[i]\n        ic_func = initial_conditions_funcs[i]\n        \n        residual = run_simulation_step(\n            N=N, L=L, q=params['q'], Omega=params['Omega'], C=C,\n            initial_conditions_func=ic_func\n        )\n        results.append(residual)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3521855"}, {"introduction": "Even schemes designed for ideal magnetohydrodynamics possess inherent numerical dissipation that can significantly influence simulation outcomes, particularly for instabilities like the MRI. This exercise provides a direct, first-principles method to characterize the numerical toolkit you build by quantifying the effective numerical resistivity $\\eta_{\\mathrm{num}}$ and viscosity $\\nu_{\\mathrm{num}}$. By measuring the decay rates of linear MHD waves, you can determine the effective magnetic Prandtl number $\\mathrm{Pm}_{\\mathrm{num}} = \\nu_{\\mathrm{num}} / \\eta_{\\mathrm{num}}$, a key parameter that governs the behavior of MRI turbulence [@problem_id:3521904].", "problem": "You are asked to design and implement a program that infers the effective numerical magnetic diffusivity (resistivity) and kinematic viscosity introduced by a given discretization in Magnetohydrodynamics (MHD), by measuring decay rates of small-amplitude linear waves. This is directly relevant to modeling the Magnetorotational Instability (MRI), where the numerical magnetic Prandtl number controls linear growth and saturation. Your program must be based on first principles of linear resistive-viscous MHD, not on empirically guessed formulas, and must be logically deduced from fundamental equations.\n\nConsider a uniform, electrically conducting, compressible fluid with constant mass density $\\rho_0$ and uniform background magnetic field magnitude $B_0$. Let $\\mu_0$ denote the vacuum magnetic permeability, and $c_s$ the isothermal sound speed. The numerical discretization of a conservative MHD scheme can be modeled as adding effective Laplacian terms with constant coefficients to the linearized equations: an effective kinematic viscosity $\\nu_{\\mathrm{num}}$ acting on the velocity field, and an effective resistivity $\\eta_{\\mathrm{num}}$ acting on the magnetic field. For small-amplitude plane waves of wavenumber $k$ and angular frequency $\\omega$, the wave amplitude $A(t)$ decays exponentially in time, $A(t) \\propto \\exp(-\\gamma t)$, where $\\gamma$ is the decay rate. The aim is to derive from first principles explicit formulas that relate $\\gamma$ to $\\nu_{\\mathrm{num}}$ and $\\eta_{\\mathrm{num}}$ for two specific geometries:\n\n1. A transverse Alfvén wave propagating parallel to the background magnetic field ($\\boldsymbol{k} \\parallel \\boldsymbol{B}_0$). This mode is incompressible and has ideal phase speed $v_A = B_0/\\sqrt{\\mu_0 \\rho_0}$.\n\n2. A fast magnetosonic compressive wave propagating perpendicular to the background magnetic field ($\\boldsymbol{k} \\perp \\boldsymbol{B}_0$). This mode has ideal phase speed $c_f = \\sqrt{c_s^2 + v_A^2}$.\n\nStarting from the fundamental resistive-viscous MHD equations, linearize about the uniform background, and use plane-wave ansatz to derive the relationships linking the decay rate $\\gamma$ to $\\nu_{\\mathrm{num}}$ and $\\eta_{\\mathrm{num}}$ for each of the above two wave geometries. Your derivation must be based solely on conservation laws and linear mode energetics; you must not use any pre-memorized shortcut formulas. Your result should express $\\gamma$ in terms of $k$, $\\nu_{\\mathrm{num}}$, $\\eta_{\\mathrm{num}}$, $c_s$, and $v_A$ for each wave type. You will then construct an algorithm that, given measured $\\gamma$ values for both wave types at the same $k$ and the same background state $(\\rho_0, B_0, c_s)$, solves for $\\nu_{\\mathrm{num}}$ and $\\eta_{\\mathrm{num}}$, and reports the numerical magnetic Prandtl number, defined as $\\mathrm{Pm}_{\\mathrm{num}} = \\nu_{\\mathrm{num}} / \\eta_{\\mathrm{num}}$.\n\nUnits and conventions:\n- Use the International System of Units (SI). All inputs must be interpreted as SI quantities. You must compute and report $\\nu_{\\mathrm{num}}$ and $\\eta_{\\mathrm{num}}$ in $\\mathrm{m}^2/\\mathrm{s}$ internally, and report the final $\\mathrm{Pm}_{\\mathrm{num}}$ as a dimensionless float.\n- Angles, if any, must be in radians. In this problem, you will use $\\theta = 0$ for the Alfvén wave and $\\theta = \\pi/2$ for the fast magnetosonic wave.\n\nTest suite:\nYou must apply your algorithm to the following five test cases. In each case, the background parameters $(\\rho_0, B_0, c_s)$, the wavenumber $k$, and the measured decay rates $(\\gamma_A, \\gamma_F)$ are provided. The Alfvén decay rate $\\gamma_A$ corresponds to the transverse Alfvén wave with $\\boldsymbol{k} \\parallel \\boldsymbol{B}_0$, and the fast magnetosonic decay rate $\\gamma_F$ corresponds to the compressive fast mode with $\\boldsymbol{k} \\perp \\boldsymbol{B}_0$. All quantities are in SI units; decay rates are in $\\mathrm{s}^{-1}$, wavenumbers are in $\\mathrm{m}^{-1}$, $B_0$ is in $\\mathrm{T}$, $\\rho_0$ in $\\mathrm{kg}/\\mathrm{m}^3$, and $c_s$ in $\\mathrm{m}/\\mathrm{s}$.\n\n- Case 1 (gas-pressure-dominated):\n  $\\rho_0 = 1.0 \\times 10^{-6}$, $B_0 = 1.0 \\times 10^{-3}$, $c_s = 1.0 \\times 10^{4}$, $k = 1.0 \\times 10^{-6}$,\n  measured $\\gamma_A = 3.500000 \\times 10^{-12}$, measured $\\gamma_F = 2.507943 \\times 10^{-12}$.\n\n- Case 2 (magnetically dominated):\n  $\\rho_0 = 1.0 \\times 10^{-8}$, $B_0 = 3.0 \\times 10^{-3}$, $c_s = 2.0 \\times 10^{3}$, $k = 5.0 \\times 10^{-7}$,\n  measured $\\gamma_A = 1.375000 \\times 10^{-12}$, measured $\\gamma_F = 1.368375 \\times 10^{-12}$.\n\n- Case 3 (near balance $v_A \\sim c_s$):\n  $\\rho_0 = 5.0 \\times 10^{-7}$, $B_0 = 2.0 \\times 10^{-3}$, $c_s = 3.0 \\times 10^{3}$, $k = 2.0 \\times 10^{-6}$,\n  measured $\\gamma_A = 9.000000 \\times 10^{-12}$, measured $\\gamma_F = 5.484375 \\times 10^{-12}$.\n\n- Case 4 (very gas-pressure-dominated):\n  $\\rho_0 = 2.0 \\times 10^{-6}$, $B_0 = 5.0 \\times 10^{-4}$, $c_s = 2.0 \\times 10^{4}$, $k = 1.5 \\times 10^{-6}$,\n  measured $\\gamma_A = 2.812500 \\times 10^{-12}$, measured $\\gamma_F = 2.250140 \\times 10^{-12}$.\n\n- Case 5 (extremely magnetically dominated):\n  $\\rho_0 = 1.0 \\times 10^{-9}$, $B_0 = 5.0 \\times 10^{-3}$, $c_s = 1.0 \\times 10^{3}$, $k = 8.0 \\times 10^{-7}$,\n  measured $\\gamma_A = 3.360000 \\times 10^{-13}$, measured $\\gamma_F = 3.359946 \\times 10^{-13}$.\n\nAlgorithmic requirements:\n- From first principles, derive the two decay-rate formulas and the resulting inversion expressions for $\\nu_{\\mathrm{num}}$ and $\\eta_{\\mathrm{num}}$ in terms of the measured $\\gamma_A$ and $\\gamma_F$ and the known $(k, c_s, v_A)$.\n- Implement a robust solver that, for each test case, computes $v_A = B_0/\\sqrt{\\mu_0 \\rho_0}$, inverts the measured decay rates to estimate $\\nu_{\\mathrm{num}}$ and $\\eta_{\\mathrm{num}}$, and computes $\\mathrm{Pm}_{\\mathrm{num}}$.\n- If the algebraic inversion becomes ill-conditioned due to $1 - v_A^2/(c_s^2 + v_A^2)$ being extremely small, you must still return a finite float based on double-precision arithmetic, provided the denominator is strictly positive. If the denominator is non-positive, treat the case as invalid and return a Not-a-Number value encoded as a floating-point NaN.\n\nFinal output specification:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry is the dimensionless numerical magnetic Prandtl number for the corresponding test case, rounded to six decimal places. For example, the output format must look like \"[x1,x2,x3,x4,x5]\" where each xi is a decimal float with six digits after the decimal point, in the same order as the test suite above.", "solution": "The problem statement is scientifically sound, self-contained, and well-posed. It describes a standard method in computational astrophysics for quantifying numerical dissipation. I will proceed with a solution based on first principles.\n\nThe starting point is the set of linearized, compressible, resistive, and viscous magnetohydrodynamic (MHD) equations for perturbations about a static, uniform background with density $\\rho_0$, magnetic field $\\boldsymbol{B}_0$, and isothermal sound speed $c_s$. The numerical scheme's dissipative effects are modeled by an effective kinematic viscosity $\\nu_{\\mathrm{num}}$ and an effective magnetic resistivity $\\eta_{\\mathrm{num}}$. The equations are:\n\n1.  Continuity: $\\frac{\\partial \\rho_1}{\\partial t} + \\rho_0 \\nabla \\cdot \\boldsymbol{v}_1 = 0$\n2.  Momentum: $\\rho_0 \\frac{\\partial \\boldsymbol{v}_1}{\\partial t} = -c_s^2 \\nabla \\rho_1 + \\frac{1}{\\mu_0} (\\nabla \\times \\boldsymbol{b}_1) \\times \\boldsymbol{B}_0 + \\rho_0 \\nu_{\\mathrm{num}} \\nabla^2 \\boldsymbol{v}_1$\n3.  Induction: $\\frac{\\partial \\boldsymbol{b}_1}{\\partial t} = \\nabla \\times (\\boldsymbol{v}_1 \\times \\boldsymbol{B}_0) + \\eta_{\\mathrm{num}} \\nabla^2 \\boldsymbol{b}_1$\n\nHere, $\\rho_1$, $\\boldsymbol{v}_1$, and $\\boldsymbol{b}_1$ are the small-amplitude perturbations in density, velocity, and magnetic field, respectively. $\\mu_0$ is the vacuum permeability. We adopt a plane-wave ansatz for all perturbed quantities, of the form $f_1 \\propto \\exp[i(\\boldsymbol{k} \\cdot \\boldsymbol{r} - \\omega t)]$, where $\\boldsymbol{k}$ is the wavevector and $\\omega$ is the complex angular frequency. This substitution transforms the differential operators as $\\frac{\\partial}{\\partial t} \\rightarrow -i\\omega$ and $\\nabla \\rightarrow i\\boldsymbol{k}$. A complex frequency $\\omega = \\omega_r + i\\omega_i$ with a negative imaginary part $\\omega_i  0$ corresponds to a temporal decay $e^{\\omega_i t}$. The problem defines the decay rate as $\\gamma = -\\omega_i  0$.\n\n### Case 1: Transverse Alfvén Wave ($\\boldsymbol{k} \\parallel \\boldsymbol{B}_0$)\nFor this geometry, we can align the coordinate system such that $\\boldsymbol{B}_0 = B_0 \\hat{\\boldsymbol{z}}$ and $\\boldsymbol{k} = k \\hat{\\boldsymbol{z}}$. This wave mode is incompressible, meaning $\\nabla \\cdot \\boldsymbol{v}_1 = 0$, which implies $\\boldsymbol{k} \\cdot \\boldsymbol{v}_1 = 0$. From the continuity equation, this also means $\\rho_1 = 0$ (for a non-zero frequency $\\omega$). The momentum equation thus loses its pressure gradient term. The linearized equations become:\n$$ -i\\omega \\rho_0 \\boldsymbol{v}_1 = \\frac{1}{\\mu_0} (i\\boldsymbol{k} \\times \\boldsymbol{b}_1) \\times \\boldsymbol{B}_0 - \\rho_0 \\nu_{\\mathrm{num}} k^2 \\boldsymbol{v}_1 $$\n$$ -i\\omega \\boldsymbol{b}_1 = i\\boldsymbol{k} \\times (\\boldsymbol{v}_1 \\times \\boldsymbol{B}_0) - \\eta_{\\mathrm{num}} k^2 \\boldsymbol{b}_1 $$\nUsing the vector identity for the triple cross product and the conditions $\\boldsymbol{k} \\parallel \\boldsymbol{B}_0$ and $\\boldsymbol{k} \\cdot \\boldsymbol{v}_1 = 0$, these simplify to a coupled system for the transverse perturbations $\\boldsymbol{v}_1$ and $\\boldsymbol{b}_1$:\n$$ (-i\\omega + \\nu_{\\mathrm{num}} k^2) \\rho_0 \\boldsymbol{v}_1 = \\frac{i}{\\mu_0} (\\boldsymbol{k} \\cdot \\boldsymbol{B}_0) \\boldsymbol{b}_1 $$\n$$ (-i\\omega + \\eta_{\\mathrm{num}} k^2) \\boldsymbol{b}_1 = i (\\boldsymbol{k} \\cdot \\boldsymbol{B}_0) \\boldsymbol{v}_1 $$\nFor a non-trivial solution to exist, the determinant of the coefficients must be zero. This yields the dispersion relation:\n$$ (-i\\omega + \\nu_{\\mathrm{num}} k^2) (-i\\omega + \\eta_{\\mathrm{num}} k^2) = \\frac{(\\boldsymbol{k} \\cdot \\boldsymbol{B}_0)^2}{\\mu_0 \\rho_0} = k^2 v_A^2 $$\nwhere $v_A = B_0 / \\sqrt{\\mu_0 \\rho_0}$ is the ideal Alfvén speed. To find the decay rate, we assume dissipation is weak, so the frequency is a small perturbation from the ideal frequency $\\omega_0 = k v_A$. Let $\\omega = \\omega_0 - i\\gamma_A = k v_A - i\\gamma_A$, where $\\gamma_A$ is small. Substituting this into the dispersion relation and keeping only first-order terms in $\\nu_{\\mathrm{num}}$, $\\eta_{\\mathrm{num}}$, and $\\gamma_A$:\n$$ (-i(k v_A - i\\gamma_A) + \\nu_{\\mathrm{num}} k^2) (-i(k v_A - i\\gamma_A) + \\eta_{\\mathrm{num}} k^2) \\approx -k^2 v_A^2 $$\n$$ (-\\gamma_A - ik v_A + \\nu_{\\mathrm{num}} k^2) (-\\gamma_A - ik v_A + \\eta_{\\mathrm{num}} k^2) \\approx -k^2 v_A^2 $$\nExpanding and linearizing gives:\n$$ (-ik v_A)^2 - ik v_A(\\nu_{\\mathrm{num}}k^2 - \\gamma_A) - ik v_A(\\eta_{\\mathrm{num}}k^2 - \\gamma_A) \\approx -k^2 v_A^2 $$\n$$ -k^2 v_A^2 - ik^3 v_A (\\nu_{\\mathrm{num}} + \\eta_{\\mathrm{num}}) + 2i k v_A \\gamma_A \\approx -k^2 v_A^2 $$\n$$ 2 \\gamma_A = k^2 (\\nu_{\\mathrm{num}} + \\eta_{\\mathrm{num}}) $$\nThis gives our first relation for the decay rate of the Alfvén wave:\n$$ \\gamma_A = \\frac{1}{2} k^2 (\\nu_{\\mathrm{num}} + \\eta_{\\mathrm{num}}) $$\n\n### Case 2: Fast Magnetosonic Wave ($\\boldsymbol{k} \\perp \\boldsymbol{B}_0$)\nFor this case, we choose $\\boldsymbol{B}_0 = B_0 \\hat{\\boldsymbol{z}}$ and $\\boldsymbol{k} = k \\hat{\\boldsymbol{x}}$, so $\\boldsymbol{k} \\cdot \\boldsymbol{B}_0 = 0$. The wave is compressive, so $\\rho_1 \\ne 0$. The linearized equations become:\n$$ \\omega \\rho_1 = \\rho_0 (k v_{1x}) $$\n$$ (-i\\omega + \\nu_{\\mathrm{num}} k^2) \\rho_0 \\boldsymbol{v}_1 = -i c_s^2 \\boldsymbol{k} \\rho_1 - \\frac{i}{\\mu_0} (\\boldsymbol{b}_1 \\cdot \\boldsymbol{B}_0) \\boldsymbol{k} $$\n$$ (-i\\omega + \\eta_{\\mathrm{num}} k^2) \\boldsymbol{b}_1 = -i (\\boldsymbol{k} \\cdot \\boldsymbol{v}_1) \\boldsymbol{B}_0 $$\nThe induction equation shows that the magnetic perturbation $\\boldsymbol{b}_1$ is parallel to $\\boldsymbol{B}_0$. The momentum equation's force terms are all directed along $\\boldsymbol{k}$, so the velocity perturbation is longitudinal, $\\boldsymbol{v}_1 = v_{1x} \\hat{\\boldsymbol{x}}$. Combining these gives the dispersion relation:\n$$ (-i\\omega + \\nu_{\\mathrm{num}} k^2) = \\frac{c_s^2 k^2}{-i\\omega} + \\frac{v_A^2 k^2}{-i\\omega + \\eta_{\\mathrm{num}} k^2} $$\nAgain, we perturb around the ideal solution, whose frequency $\\omega_0$ satisfies $\\omega_0^2 = (c_s^2 + v_A^2)k^2 = c_f^2 k^2$. Let $\\omega = \\omega_0 - i\\gamma_F$. Substituting and linearizing yields:\n$$ \\gamma_F = \\frac{1}{2} k^2 \\left( \\nu_{\\mathrm{num}} + \\eta_{\\mathrm{num}} \\frac{v_A^2}{c_s^2 + v_A^2} \\right) $$\n\n### Inversion for $\\nu_{\\mathrm{num}}$ and $\\eta_{\\mathrm{num}}$\nWe now have a system of two linear equations for the two unknowns $\\nu_{\\mathrm{num}}$ and $\\eta_{\\mathrm{num}}$ based on the measured decay rates $\\gamma_A$ and $\\gamma_F$:\n1. $2\\gamma_A / k^2 = \\nu_{\\mathrm{num}} + \\eta_{\\mathrm{num}}$\n2. $2\\gamma_F / k^2 = \\nu_{\\mathrm{num}} + \\eta_{\\mathrm{num}} \\frac{v_A^2}{c_s^2 + v_A^2}$\n\nLet $\\Gamma_A = 2\\gamma_A/k^2$ and $\\Gamma_F = 2\\gamma_F/k^2$. Let $f = v_A^2 / (c_s^2 + v_A^2)$.\nSubtracting the second equation from the first gives:\n$\\Gamma_A - \\Gamma_F = \\eta_{\\mathrm{num}}(1-f)$\nNoting that $1-f = 1 - \\frac{v_A^2}{c_s^2+v_A^2} = \\frac{c_s^2}{c_s^2+v_A^2}$, we solve for $\\eta_{\\mathrm{num}}$:\n$$ \\eta_{\\mathrm{num}} = \\frac{\\Gamma_A - \\Gamma_F}{1 - f} = \\frac{2(\\gamma_A - \\gamma_F)}{k^2} \\left( \\frac{c_s^2 + v_A^2}{c_s^2} \\right) $$\nWe can then find $\\nu_{\\mathrm{num}}$ from the first equation: $\\nu_{\\mathrm{num}} = \\Gamma_A - \\eta_{\\mathrm{num}}$. This can be expressed as:\n$$ \\nu_{\\mathrm{num}} = \\frac{\\Gamma_F - f \\Gamma_A}{1 - f} = \\frac{2}{k^2 c_s^2} \\left[ \\gamma_F(c_s^2+v_A^2) - \\gamma_A v_A^2 \\right] $$\nThe numerical magnetic Prandtl number is $\\mathrm{Pm}_{\\mathrm{num}} = \\nu_{\\mathrm{num}} / \\eta_{\\mathrm{num}}$. Dividing the expressions for $\\nu_{\\mathrm{num}}$ and $\\eta_{\\mathrm{num}}$:\n$$ \\mathrm{Pm}_{\\mathrm{num}} = \\frac{\\nu_{\\mathrm{num}}}{\\eta_{\\mathrm{num}}} = \\frac{\\gamma_F(c_s^2+v_A^2) - \\gamma_A v_A^2}{(\\gamma_A - \\gamma_F)(c_s^2+v_A^2)} $$\nThis is the final expression implemented in the program.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import constants\n\ndef solve():\n    \"\"\"\n    Infers effective numerical magnetic diffusivity and kinematic viscosity\n    by measuring decay rates of small-amplitude linear MHD waves. It then\n    calculates the numerical magnetic Prandtl number.\n    \"\"\"\n    \n    # Use the precise value of mu_0 from scipy.constants as required for the\n    # test cases, which are designed around this standard value.\n    mu_0 = constants.mu_0\n\n    # Define the test cases from the problem statement.\n    # Each tuple contains: (rho_0, B_0, c_s, k, gamma_A, gamma_F)\n    # All values are in SI units.\n    test_cases = [\n        # Case 1 (gas-pressure-dominated)\n        (1.0e-6, 1.0e-3, 1.0e4, 1.0e-6, 3.5e-12, 2.507943e-12),\n        # Case 2 (magnetically dominated)\n        (1.0e-8, 3.0e-3, 2.0e3, 5.0e-7, 1.375e-12, 1.368375e-12),\n        # Case 3 (near balance v_A ~ c_s)\n        (5.0e-7, 2.0e-3, 3.0e3, 2.0e-6, 9.0e-12, 5.484375e-12),\n        # Case 4 (very gas-pressure-dominated)\n        (2.0e-6, 5.0e-4, 2.0e4, 1.5e-6, 2.8125e-12, 2.250140e-12),\n        # Case 5 (extremely magnetically dominated)\n        (1.0e-9, 5.0e-3, 1.0e3, 8.0e-7, 3.36e-13, 3.359946e-13),\n    ]\n\n    results = []\n    for case in test_cases:\n        rho_0, B_0, c_s, k, gamma_A, gamma_F = case\n\n        # Calculate squared speeds: Alfvén, sound, and fast magnetosonic\n        v_A_sq = B_0**2 / (mu_0 * rho_0)\n        c_s_sq = c_s**2\n        c_f_sq = c_s_sq + v_A_sq\n\n        # The term c_s^2 is the denominator in the inversion for nu_num and eta_num.\n        # The problem asks to return NaN if a denominator is non-positive.\n        # For all test cases, c_s  0, so c_s^2  0.\n        if c_s_sq = 0:\n            results.append(np.nan)\n            continue\n        \n        # Calculate the numerical magnetic Prandtl number, Pm_num = nu_num / eta_num,\n        # using the derived formula:\n        # Pm_num = (gamma_F * c_f^2 - gamma_A * v_A^2) / ((gamma_A - gamma_F) * c_f^2)\n        # This form is robust when implemented with double-precision floats.\n        numerator = gamma_F * c_f_sq - gamma_A * v_A_sq\n        denominator = (gamma_A - gamma_F) * c_f_sq\n        \n        # Avoid division by zero, which physically corresponds to eta_num = 0,\n        # leading to an infinite Prandtl number.\n        if abs(denominator)  1e-40:\n             pm_num = np.inf\n        else:\n             pm_num = numerator / denominator\n        \n        results.append(pm_num)\n\n    # Format the results as a list of strings with 6 decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3521904"}, {"introduction": "Connecting numerical methods to physical outcomes is a vital skill in computational astrophysics. This exercise utilizes a simplified ordinary differential equation (ODE) model of an MRI channel mode to explore how algorithmic choices affect the physics of nonlinear saturation. By comparing phenomenological models for constrained transport (CT) and hyperbolic divergence cleaning (HC), you will quantify how the choice of divergence-control strategy can impact the saturated stress parameter $\\alpha$, providing insight that would be far more computationally expensive to obtain from full three-dimensional simulations [@problem_id:3521863].", "problem": "You are asked to design and implement a minimal, self-consistent computational experiment that compares two divergence-control strategies for the magnetic field in a local shearing-box model of the Magnetorotational Instability (MRI): constrained transport (CT) versus hyperbolic cleaning (HC). The goal is to quantify the impact on the saturation amplitude through the dimensionless stress parameter $\\alpha$, defined as $\\alpha = \\langle T_{xy} \\rangle / \\langle P \\rangle$, where $T_{xy}$ is the sum of Maxwell and Reynolds stresses and $P$ is the thermal pressure. Your program must produce a single line of output containing a comma-separated list of $\\alpha$ values for prescribed test cases, rounded to six decimal places, enclosed in square brackets. No units are required for the output because $\\alpha$ is dimensionless.\n\nStart from the fundamental laws of ideal magnetohydrodynamics (MHD) in a local shearing box with rotation rate $\\Omega$ and shear parameter $q$, including the Coriolis and tidal source terms, and the induction equation for the magnetic field. Consider a uniform density $\\rho$ and a uniform, vertical background magnetic field of strength $B_0$, which defines an Alfvén speed $v_A = B_0 / \\sqrt{\\mu_0 \\rho}$, where $\\mu_0$ is the magnetic permeability of free space. In this setting, a single axisymmetric channel-mode perturbation with vertical wavenumber $k$ can be modeled with a reduced ordinary differential equation (ODE) system for the velocity perturbation components $u_x(t)$, $u_y(t)$ and the magnetic perturbation components $b_x(t)$, $b_y(t)$, where the magnetic perturbations are measured in Alfvén units $b_i = \\delta B_i / \\sqrt{\\mu_0 \\rho}$ so that magnetic and velocity perturbations have the same units. The reduced, incompressible, linearized MRI system is\n$$\n\\frac{d u_x}{d t} - 2 \\Omega u_y = k v_A b_x, \\quad\n\\frac{d u_y}{d t} + (2 - q) \\Omega u_x = k v_A b_y,\n$$\n$$\n\\frac{d b_x}{d t} = k v_A u_x, \\quad\n\\frac{d b_y}{d t} - q \\Omega b_x = k v_A u_y.\n$$\nTo remain scientifically realistic for saturation and to mimic numerical and microphysical dissipation, augment the above with explicit kinematic viscosity $\\nu$ and resistivity $\\eta$, and with a simple energy-dependent parasitic sink term that mimics secondary instabilities draining energy from the channel mode at large amplitude. Let $E = u_x^2 + u_y^2 + b_x^2 + b_y^2$. The complete ODE system to integrate is\n$$\n\\frac{d u_x}{d t} = 2 \\Omega u_y + k v_A b_x - \\nu k^2 u_x - \\kappa E u_x,\n$$\n$$\n\\frac{d u_y}{d t} = - (2 - q) \\Omega u_x + k v_A b_y - \\nu k^2 u_y - \\kappa E u_y,\n$$\n$$\n\\frac{d b_x}{d t} = k v_A u_x - \\eta k^2 b_x - \\kappa E b_x - \\gamma_{\\mathrm{H}} b_x,\n$$\n$$\n\\frac{d b_y}{d t} = q \\Omega b_x + k v_A u_y - \\eta k^2 b_y - \\kappa E b_y - \\gamma_{\\mathrm{H}} b_y.\n$$\nThe parameter $\\kappa  0$ sets the strength of the parasitic drain. The parameter $\\gamma_{\\mathrm{H}}$ models the effect of divergence cleaning on the magnetic perturbations:\n- For constrained transport (CT), set $\\gamma_{\\mathrm{H}} = 0$, reflecting exact maintenance of the solenoidal constraint $\\nabla \\cdot \\mathbf{B} = 0$ in the discrete evolution.\n- For hyperbolic cleaning (HC), approximate the energetic impact of divergence-cleaning waves by a linear damping of magnetic perturbations at rate\n$$\n\\gamma_{\\mathrm{H}} = \\sigma \\frac{c_h^2}{c_p^2},\n$$\nwhere $c_h$ is the cleaning-wave speed, $c_p$ is the parabolic damping control speed, and $\\sigma \\in [0,1]$ is an effective numerical coupling coefficient that parameterizes inadvertent coupling between solenoidal and non-solenoidal magnetic components in a discrete scheme. This phenomenological closure is intended to capture the leading-order impact of hyperbolic cleaning on MRI saturation in a reduced model.\n\nDefine the instantaneous total stress as\n$$\nT_{xy}(t) = \\rho \\left(u_x u_y - b_x b_y\\right),\n$$\nwhich is the sum of the Reynolds stress $\\rho u_x u_y$ and the Maxwell stress $- \\rho b_x b_y$ (because $b_i$ are in Alfvén units). Define the saturation measure\n$$\n\\alpha = \\frac{1}{P} \\frac{1}{t_2 - t_1} \\int_{t_1}^{t_2} T_{xy}(t) \\, dt,\n$$\nwhere $P$ is the thermal pressure, $t_1 = \\frac{2}{3} T$ is the beginning of the averaging window, and $t_2 = T$ is the end of the simulation of total duration $T$.\n\nAlgorithm requirements:\n- Implement the ODE system above and integrate it using a fixed-step, explicit, fourth-order Runge–Kutta method.\n- Use initial conditions $u_x(0) = u_y(0) = b_x(0) = b_y(0) = 10^{-6}$.\n- Use a uniform time step $\\Delta t$ and simulate over a total time $T$.\n- Compute $\\alpha$ as the time-average of $T_{xy}(t)/P$ over $t \\in [t_1, t_2]$.\n- For CT runs, use $\\gamma_{\\mathrm{H}} = 0$. For HC runs, compute $\\gamma_{\\mathrm{H}}$ from the specified $c_h$, $c_p$, and $\\sigma$.\n\nTest suite:\nProvide results for the following three parameter sets, each tested with CT and HC, in the specified order. All constants not mentioned explicitly below are shared across all tests and defined as: $\\Omega = 1$, $q = \\frac{3}{2}$, $\\rho = 1$, $\\mu_0 = 1$, $P = 1$, $\\nu = 10^{-3}$, $\\eta = 10^{-3}$, $\\kappa = 2 \\times 10^{-2}$, $T = 150$, $\\Delta t = 10^{-2}$. The Alfvén speed $v_A$ and wavenumber $k$ are given per case.\n- Case $1$ (MRI-unstable baseline): $v_A = 10^{-1}$, $k = 5$. For HC, use $c_h = 1$, $c_p = 1$, $\\sigma = 2 \\times 10^{-1}$.\n- Case $2$ (MRI-stable boundary): $v_A = 10^{-1}$, $k = 40$. For HC, use $c_h = 1$, $c_p = 1$, $\\sigma = 2 \\times 10^{-1}$. This case has $k v_A  \\sqrt{2 q} \\, \\Omega$, so linear MRI growth is not expected.\n- Case $3$ (HC approximating CT): $v_A = 10^{-1}$, $k = 5$. For HC, use $c_h = 4$, $c_p = 2$, $\\sigma = 5 \\times 10^{-3}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the six results as a comma-separated list enclosed in square brackets, in the following order: $\\left[\\alpha_{\\mathrm{CT,1}}, \\alpha_{\\mathrm{HC,1}}, \\alpha_{\\mathrm{CT,2}}, \\alpha_{\\mathrm{HC,2}}, \\alpha_{\\mathrm{CT,3}}, \\alpha_{\\mathrm{HC,3}}\\right]$, where the subscripts denote method and case index.\n- Each value must be rounded to six decimal places.\n- No other text should be printed.\n\nAll quantities are nondimensional in this setup, so no physical units need be reported. Angles do not appear explicitly; any trigonometric functions, if introduced, must assume arguments in radians. The outputs are pure floats as specified above.", "solution": "The problem statement is assessed to be valid. It is scientifically grounded in the principles of magnetohydrodynamics (MHD), specifically the study of the magnetorotational instability (MRI) using a local shearing-box approximation. The problem is well-posed, providing a complete set of non-linear ordinary differential equations (ODEs), all necessary parameters, initial conditions, and a clear numerical method for their solution. The objective is to compare two numerical strategies for maintaining the solenoidal constraint on the magnetic field ($\\nabla \\cdot \\mathbf{B} = 0$), namely constrained transport (CT) and hyperbolic cleaning (HC), by quantifying their effect on the instability's saturation level. This is accomplished by solving a reduced, phenomenological model and calculating the dimensionless stress parameter $\\alpha$. The problem is computationally feasible and its components are unambiguously defined.\n\nThe analysis proceeds by solving the specified system of ODEs for the evolution of velocity perturbations ($u_x, u_y$) and magnetic field perturbations ($b_x, b_y$) in a reduced channel-mode model of the MRI. The state vector of the system is $\\mathbf{y}(t) = [u_x(t), u_y(t), b_x(t), b_y(t)]^T$. The governing equations are:\n$$\n\\frac{d u_x}{d t} = 2 \\Omega u_y + k v_A b_x - \\nu k^2 u_x - \\kappa E u_x\n$$\n$$\n\\frac{d u_y}{d t} = - (2 - q) \\Omega u_x + k v_A b_y - \\nu k^2 u_y - \\kappa E u_y\n$$\n$$\n\\frac{d b_x}{d t} = k v_A u_x - \\eta k^2 b_x - \\kappa E b_x - \\gamma_{\\mathrm{H}} b_x\n$$\n$$\n\\frac{d b_y}{d t} = q \\Omega b_x + k v_A u_y - \\eta k^2 b_y - \\kappa E b_y - \\gamma_{\\mathrm{H}} b_y\n$$\nHere, $\\Omega$ is the angular velocity, $q$ is the shear parameter, $v_A$ is the Alfvén speed, and $k$ is the vertical wavenumber. Dissipative effects are modeled by kinematic viscosity $\\nu$ and resistivity $\\eta$. Saturation is achieved via a parasitic drain term with strength $\\kappa$, where the energy $E$ is given by $E = u_x^2 + u_y^2 + b_x^2 + b_y^2$.\n\nThe parameter $\\gamma_{\\mathrm{H}}$ encapsulates the effect of the divergence control scheme. For the constrained transport (CT) method, which maintains $\\nabla \\cdot \\mathbf{B} = 0$ to machine precision by design, we set $\\gamma_{\\mathrm{H}} = 0$. For the hyperbolic cleaning (HC) method, which damps divergence errors, we use a phenomenological damping term with rate $\\gamma_{\\mathrm{H}} = \\sigma \\frac{c_h^2}{c_p^2}$, where $\\sigma$, $c_h$, and $c_p$ are model parameters specified for the HC cases.\n\nThe system of ODEs is an initial value problem, which we solve numerically using the explicit fourth-order Runge-Kutta (RK4) method with a fixed time step $\\Delta t$. For a generic ODE system $\\frac{d\\mathbf{y}}{dt} = f(t, \\mathbf{y})$, the state $\\mathbf{y}_{n+1}$ at time $t_{n+1}$ is found from the state $\\mathbf{y}_n$ at time $t_n$ by:\n$$\n\\mathbf{k}_1 = \\Delta t \\cdot f(t_n, \\mathbf{y}_n)\n$$\n$$\n\\mathbf{k}_2 = \\Delta t \\cdot f(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\mathbf{k}_1}{2})\n$$\n$$\n\\mathbf{k}_3 = \\Delta t \\cdot f(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\mathbf{k}_2}{2})\n$$\n$$\n\\mathbf{k}_4 = \\Delta t \\cdot f(t_n + \\Delta t, \\mathbf{y}_n + \\mathbf{k}_3)\n$$\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{1}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\nThe system is integrated from $t=0$ to $t=T$ with initial conditions $u_x(0) = u_y(0) = b_x(0) = b_y(0) = 10^{-6}$.\n\nAfter obtaining the time series for the state variables, we compute the saturation stress parameter $\\alpha$. First, the instantaneous stress $T_{xy}(t)$ is calculated. Since the magnetic perturbations $b_i$ are in Alfvén units, the stress, which is the sum of Reynolds and Maxwell stresses, is given by:\n$$\nT_{xy}(t) = \\rho (u_x(t) u_y(t) - b_x(t) b_y(t))\n$$\nThe dimensionless saturation parameter $\\alpha$ is the time-average of the stress (normalized by thermal pressure $P$), computed over the final third of the simulation time, from $t_1 = \\frac{2}{3}T$ to $t_2 = T$:\n$$\n\\alpha = \\frac{\\langle T_{xy} \\rangle}{P} = \\frac{1}{P} \\left( \\frac{1}{t_2 - t_1} \\int_{t_1}^{t_2} T_{xy}(t) \\, dt \\right)\n$$\nNumerically, this is calculated as the arithmetic mean of the discrete $T_{xy}(t_i)$ values computed at each time step $t_i$ within the averaging window $[t_1, t_2]$.\n\nThe implementation will consist of a function defining the ODE system's right-hand side, a function implementing the RK4 step, and a main orchestrator function. This main function iterates through the prescribed test cases, sets up the parameters for both CT and HC methods, runs the simulation, calculates $\\alpha$, and appends the rounded result to a list. Finally, the list of six $\\alpha$ values is printed in the specified format. The parameters for all simulations are: $\\Omega = 1$, $q = 3/2$, $\\rho = 1$, $\\mu_0 = 1$, $P = 1$, $\\nu = 10^{-3}$, $\\eta = 10^{-3}$, $\\kappa = 2 \\times 10^{-2}$, $T = 150$, and $\\Delta t = 10^{-2}$. The case-specific parameters $v_A$, $k$, and the HC parameters are applied as defined in the test suite.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the computational experiment and print the results.\n    \"\"\"\n\n    # Shared parameters across all test cases\n    shared_params = {\n        'Omega': 1.0,\n        'q': 1.5,\n        'rho': 1.0,\n        'P': 1.0,\n        'nu': 1e-3,\n        'eta': 1e-3,\n        'kappa': 2e-2,\n        'T': 150.0,\n        'dt': 1e-2,\n    }\n\n    # Test case definitions\n    test_cases = [\n        {   # Case 1: MRI-unstable baseline\n            'v_A': 1e-1,\n            'k': 5.0,\n            'hc_params': {'c_h': 1.0, 'c_p': 1.0, 'sigma': 2e-1}\n        },\n        {   # Case 2: MRI-stable boundary\n            'v_A': 1e-1,\n            'k': 40.0,\n            'hc_params': {'c_h': 1.0, 'c_p': 1.0, 'sigma': 2e-1}\n        },\n        {   # Case 3: HC approximating CT\n            'v_A': 1e-1,\n            'k': 5.0,\n            'hc_params': {'c_h': 4.0, 'c_p': 2.0, 'sigma': 5e-3}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Run 1: Constrained Transport (CT)\n        params_ct = {**shared_params, **case, 'gamma_H': 0.0}\n        alpha_ct = run_simulation(params_ct)\n        results.append(round(alpha_ct, 6))\n\n        # Run 2: Hyperbolic Cleaning (HC)\n        hc = case['hc_params']\n        gamma_H_hc = hc['sigma'] * (hc['c_h']**2 / hc['c_p']**2)\n        params_hc = {**shared_params, **case, 'gamma_H': gamma_H_hc}\n        alpha_hc = run_simulation(params_hc)\n        results.append(round(alpha_hc, 6))\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef ode_rhs(y, params):\n    \"\"\"\n    Computes the right-hand side of the MRI ODE system.\n    y: state vector [ux, uy, bx, by]\n    params: dictionary of physical and numerical parameters\n    \"\"\"\n    ux, uy, bx, by = y\n    \n    # Unpack parameters\n    Omega = params['Omega']\n    q = params['q']\n    k = params['k']\n    v_A = params['v_A']\n    nu = params['nu']\n    eta = params['eta']\n    kappa = params['kappa']\n    gamma_H = params['gamma_H']\n\n    # Energy in the perturbations\n    E = ux**2 + uy**2 + bx**2 + by**2\n\n    # Physical dissipation terms\n    visc_diss = nu * k**2\n    res_diss = eta * k**2\n    \n    # Derivatives\n    dux_dt = 2.0 * Omega * uy + k * v_A * bx - visc_diss * ux - kappa * E * ux\n    duy_dt = -(2.0 - q) * Omega * ux + k * v_A * by - visc_diss * uy - kappa * E * uy\n    dbx_dt = k * v_A * ux - res_diss * bx - kappa * E * bx - gamma_H * bx\n    dby_dt = q * Omega * bx + k * v_A * uy - res_diss * by - kappa * E * by - gamma_H * by\n    \n    return np.array([dux_dt, duy_dt, dbx_dt, dby_dt])\n\ndef rk4_step(func, y, dt, params):\n    \"\"\"\n    Performs a single step of the 4th-order Runge-Kutta method.\n    \"\"\"\n    k1 = dt * func(y, params)\n    k2 = dt * func(y + 0.5 * k1, params)\n    k3 = dt * func(y + 0.5 * k2, params)\n    k4 = dt * func(y + k3, params)\n    \n    return y + (k1 + 2.0 * k2 + 2.0 * k3 + k4) / 6.0\n\ndef run_simulation(params):\n    \"\"\"\n    Integrates the ODE system and computes the alpha parameter.\n    \"\"\"\n    # Unpack parameters\n    T = params['T']\n    dt = params['dt']\n    rho = params['rho']\n    P = params['P']\n\n    # Time setup\n    n_steps = int(T / dt)\n    t_start_avg_idx = int((2.0/3.0 * T) / dt)\n\n    # Initial conditions\n    y = np.array([1e-6, 1e-6, 1e-6, 1e-6])\n    \n    stress_values = []\n    \n    # Main integration loop\n    for i in range(n_steps):\n        y = rk4_step(ode_rhs, y, dt, params)\n        \n        # Collect stress values in the averaging window\n        if i = t_start_avg_idx:\n            ux, uy, bx, by = y\n            T_xy = rho * (ux * uy - bx * by)\n            stress_values.append(T_xy)\n            \n    # Compute alpha\n    avg_T_xy = np.mean(stress_values)\n    alpha = avg_T_xy / P\n    \n    return alpha\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3521863"}]}