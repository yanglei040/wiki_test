{"hands_on_practices": [{"introduction": "Before a core-collapse supernova simulation can begin, the continuous structure of the progenitor star must be faithfully represented on a discrete computational grid. This initial mapping is a critical step that requires careful treatment to ensure fundamental physical laws, such as the conservation of baryonic mass, are respected from the outset. This exercise [@problem_id:3533781] will guide you through the process of developing a robust algorithm to initialize your simulation, ensuring that the total mass and the distribution of other physical quantities are accurately preserved during discretization.", "problem": "You are given spherically symmetric progenitor profiles described by continuous functions for the mass density $\\rho(r)$ in $\\mathrm{g\\,cm^{-3}}$, thermodynamic temperature $T(r)$ in $\\mathrm{K}$, and electron fraction $Y_e(r)$ (dimensionless). The goal is to map these functions onto a finite-volume spherical grid of concentric shells and compute cell-averaged quantities in a way that enforces baryon mass conservation and preserves mass-weighted integrals of intensive scalars. You must derive an algorithm from first principles that constructs the mapped shell-averaged fields and verifies integral preservation.\n\nStart from the following fundamentals:\n- Spherical volume element $dV = 4\\pi r^2 dr$.\n- Shell volume $V_i = \\int_{r_{i-1/2}}^{r_{i+1/2}} 4\\pi r^2\\,dr$.\n- Total baryonic mass $M = \\int_0^{R_{\\max}} \\rho(r)\\,dV$ in $\\mathrm{g}$.\n- Mass-weighted integral of an intensive scalar $\\phi(r)$ (e.g., electron fraction or temperature) is $I_\\phi = \\int_0^{R_{\\max}} \\rho(r)\\,\\phi(r)\\,dV$.\n\nDefine the finite-volume shell-averaged quantities that must be computed from the continuous fields:\n- The shell-averaged density $\\bar{\\rho}_i$ must satisfy $\\bar{\\rho}_i V_i = \\int_{r_{i-1/2}}^{r_{i+1/2}} \\rho(r)\\,dV$ to ensure baryon mass conservation in each shell.\n- For any intensive scalar $\\phi(r)$, the shell-averaged mass-weighted value $\\bar{\\phi}_i$ must satisfy $\\bar{\\phi}_i \\left(\\bar{\\rho}_i V_i\\right) = \\int_{r_{i-1/2}}^{r_{i+1/2}} \\rho(r)\\,\\phi(r)\\,dV$ to preserve the shell-integrated mass-weighted quantity.\n\nYour program must:\n- Construct a spherical shell grid on $[0,R_{\\max}]$ with $N$ shells using a geometric spacing with ratio $q \\ge 1$. Let $\\Delta r_i = \\Delta r_0\\,q^i$ for $i=0,\\dots,N-1$, where $\\sum_{i=0}^{N-1}\\Delta r_i = R_{\\max}$. This defines the shell edges $r_{i+1/2}$ with $r_{1/2}=0$ and $r_{N+1/2}=R_{\\max}$.\n- For each shell, compute $V_i$, $\\bar{\\rho}_i$, $\\overline{Y_e}_i$, and $\\bar{T}_i$ by evaluating the required volume and mass-weighted integrals. Use numerically stable and accurate quadrature for the needed integrals. If a profile is piecewise-defined with a discontinuity at a known radius $r = r_\\star$, split any integral at $r_\\star$ to ensure robustness.\n- Verify preservation by computing the following relative errors for each test case:\n  - The relative error in total mass $\\epsilon_M = \\left|\\sum_i \\bar{\\rho}_i V_i - \\int_0^{R_{\\max}} \\rho(r)\\,dV\\right| \\big/ \\left(\\int_0^{R_{\\max}} \\rho(r)\\,dV\\right)$.\n  - The relative error in the mass-weighted electron fraction integral $\\epsilon_{Y} = \\left|\\sum_i \\bar{\\rho}_i \\overline{Y_e}_i V_i - \\int_0^{R_{\\max}} \\rho(r) Y_e(r)\\,dV\\right| \\big/ \\left(\\int_0^{R_{\\max}} \\rho(r) Y_e(r)\\,dV\\right)$.\n  - The relative error in the mass-weighted temperature integral $\\epsilon_{T} = \\left|\\sum_i \\bar{\\rho}_i \\bar{T}_i V_i - \\int_0^{R_{\\max}} \\rho(r) T(r)\\,dV\\right| \\big/ \\left(\\int_0^{R_{\\max}} \\rho(r) T(r)\\,dV\\right)$.\nThese three errors are dimensionless and must be reported as decimal floating-point numbers.\n\nUse the following test suite, with all radii in $\\mathrm{cm}$, densities in $\\mathrm{g\\,cm^{-3}}$, temperatures in $\\mathrm{K}$, and electron fractions dimensionless:\n\nTest case $1$ (smooth, polytrope-like core):\n- Domain radius $R_{\\max} = 3\\times 10^8$.\n- Grid parameters $N=128$, $q=1.03$.\n- Profiles:\n  - $\\rho(r) = \\dfrac{\\rho_c}{\\left(1 + \\left(\\dfrac{r}{r_c}\\right)^2\\right)^n}$ with $\\rho_c = 10^{10}$, $r_c = 10^7$, $n = 1.5$.\n  - $T(r) = \\dfrac{T_c}{1 + \\left(\\dfrac{r}{2\\times 10^7}\\right)^{1.3}}$ with $T_c = 7\\times 10^9$.\n  - $Y_e(r) = 0.5 - 0.1\\,\\dfrac{r}{R_{\\max}}$.\n\nTest case $2$ (discontinuous core-envelope transition):\n- Domain radius $R_{\\max} = 3\\times 10^8$.\n- Grid parameters $N=96$, $q=1.05$.\n- Transition radius $r_{\\mathrm{core}} = 1.5\\times 10^8$.\n- Profiles:\n  - $\\rho(r) = \\begin{cases}\n    6\\times 10^9,  r \\le r_{\\mathrm{core}},\\\\\n    6\\times 10^9 \\left(\\dfrac{r}{r_{\\mathrm{core}}}\\right)^{-3},  r  r_{\\mathrm{core}}.\n    \\end{cases}$\n  - $T(r) = 8\\times 10^9 \\exp\\!\\left(-\\dfrac{r}{1.2\\times 10^8}\\right)$.\n  - $Y_e(r) = \\begin{cases}\n    0.44,  r \\le r_{\\mathrm{core}},\\\\\n    0.50,  r  r_{\\mathrm{core}}.\n    \\end{cases}$\nFor this case, you must treat the discontinuity at $r=r_{\\mathrm{core}}$ explicitly when integrating.\n\nTest case $3$ (centrally peaked, rapidly varying core):\n- Domain radius $R_{\\max} = 2.5\\times 10^8$.\n- Grid parameters $N=200$, $q=1.02$.\n- Profiles:\n  - $\\rho(r) = 2\\times 10^{10}\\,\\exp\\!\\left(-\\left(\\dfrac{r}{2\\times 10^7}\\right)^{1/2}\\right)$.\n  - $T(r) = \\dfrac{10^{10}}{1 + \\left(\\dfrac{r}{5\\times 10^7}\\right)^{1.5}}$.\n  - $Y_e(r) = 0.48 - 0.05\\,\\tanh\\!\\left(\\dfrac{r}{10^8}\\right)$.\n\nRequired final output format:\n- Your program should produce a single line of output containing all nine relative errors for the three test cases, concatenated in order as $\\left[\\epsilon_M^{(1)},\\epsilon_{Y}^{(1)},\\epsilon_{T}^{(1)},\\epsilon_M^{(2)},\\epsilon_{Y}^{(2)},\\epsilon_{T}^{(2)},\\epsilon_M^{(3)},\\epsilon_{Y}^{(3)},\\epsilon_{T}^{(3)}\\right]$ as a comma-separated list enclosed in square brackets (for example, $\\left[0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0\\right]$). The values must be decimal floats. Angles are not involved. All reported values are unitless relative errors.", "solution": "The problem requires the development and implementation of an algorithm to map continuous, spherically symmetric progenitor profiles onto a discrete finite-volume grid. The mapping must strictly conserve baryonic mass and preserve the total mass-weighted integrals of intensive thermodynamic quantities. The validity of the implemented algorithm is to be verified by computing the relative error between the discretized sums and the 'exact' continuous integrals.\n\nThe theoretical derivation proceeds from first principles as follows.\n\n**1. Spherical Grid Construction**\nThe one-dimensional radial domain $[0, R_{\\max}]$ is discretized into $N$ contiguous, non-overlapping concentric shells. Let the shell index be $i = 0, 1, \\dots, N-1$. Shell $i$ is the volume enclosed between the spherical surfaces at radii $r_i$ and $r_{i+1}$. This defines $N+1$ interfaces at radii $r_0, r_1, \\dots, r_N$, where $r_0 = 0$ and $r_N = R_{\\max}$.\n\nThe grid spacing is geometric, meaning the width of each shell, $\\Delta r_i = r_{i+1} - r_i$, follows the relation $\\Delta r_i = \\Delta r_0 \\, q^i$ for a constant ratio $q \\ge 1$. The width of the first shell, $\\Delta r_0$, is determined by the constraint that the sum of all shell widths must equal the total domain size:\n$$ R_{\\max} = \\sum_{i=0}^{N-1} \\Delta r_i = \\sum_{i=0}^{N-1} \\Delta r_0 \\, q^i = \\Delta r_0 \\sum_{i=0}^{N-1} q^i $$\nFor $q  1$, the geometric series sum is $\\frac{q^N-1}{q-1}$, which gives $\\Delta r_0 = R_{\\max} \\frac{q-1}{q^N-1}$. For uniform spacing where $q=1$, the sum is $N$, giving $\\Delta r_0 = R_{\\max}/N$.\n\nThe interface radii are then fully determined. Starting with $r_0=0$, each subsequent radius is calculated as:\n$$ r_{j} = \\sum_{k=0}^{j-1} \\Delta r_k = \\sum_{k=0}^{j-1} \\Delta r_0 \\, q^k = \\Delta r_0 \\frac{q^j - 1}{q-1} \\quad (\\text{for } j=1, \\dots, N \\text{ and } q  1) $$\nFor $q=1$, this simplifies to $r_j = j \\cdot \\Delta r_0$.\n\n**2. Discretization of Physical Quantities**\nThe goal is to define shell-averaged quantities ($\\bar{\\rho}_i$, $\\overline{Y_e}_i$, $\\bar{T}_i$) that satisfy conservation laws.\n\n**Shell Volume**\nThe volume of shell $i$, $V_i$, is the integral of the spherical volume element $dV = 4\\pi r^2 dr$ between its bounding radii, $r_i$ and $r_{i+1}$:\n$$ V_i = \\int_{r_i}^{r_{i+1}} 4\\pi r^2 dr = 4\\pi \\left[\\frac{r^3}{3}\\right]_{r_i}^{r_{i+1}} = \\frac{4\\pi}{3} (r_{i+1}^3 - r_i^3) $$\nThis is an exact analytical formula.\n\n**Mass Conservation and Shell-Averaged Density**\nThe baryonic mass contained within shell $i$, denoted $M_i$, is the integral of the continuous density function $\\rho(r)$ over the shell volume:\n$$ M_i = \\int_{V_i} \\rho(r) \\, dV = \\int_{r_i}^{r_{i+1}} \\rho(r) (4\\pi r^2) dr $$\nThe principle of mass conservation requires that the mass assigned to the discrete cell, given by $\\bar{\\rho}_i V_i$, must be exactly equal to the continuous mass $M_i$. This defines the shell-averaged density $\\bar{\\rho}_i$:\n$$ \\bar{\\rho}_i V_i = M_i \\implies \\bar{\\rho}_i = \\frac{M_i}{V_i} = \\frac{\\int_{r_i}^{r_{i+1}} 4\\pi \\rho(r) r^2 dr}{\\frac{4\\pi}{3} (r_{i+1}^3 - r_i^3)} = \\frac{3}{r_{i+1}^3 - r_i^3} \\int_{r_i}^{r_{i+1}} \\rho(r) r^2 dr $$\n\n**Preservation of Mass-Weighted Scalar Integrals**\nFor any intensive scalar quantity $\\phi(r)$ (e.g., temperature $T(r)$ or electron fraction $Y_e(r)$), we must preserve its mass-weighted integral. The total amount of the quantity $\\rho \\phi$ in shell $i$ is $\\int_{V_i} \\rho(r) \\phi(r) dV$. In the discretized scheme, this is represented by $\\bar{\\phi}_i M_i$. Equating these defines the mass-weighted shell-averaged value $\\bar{\\phi}_i$:\n$$ \\bar{\\phi}_i M_i = \\int_{V_i} \\rho(r) \\phi(r) dV = \\int_{r_i}^{r_{i+1}} \\rho(r) \\phi(r) (4\\pi r^2) dr $$\n$$ \\implies \\bar{\\phi}_i = \\frac{1}{M_i} \\int_{r_i}^{r_{i+1}} \\rho(r) \\phi(r) (4\\pi r^2) dr $$\nThis formulation ensures that the sum of the discrete quantities over all shells correctly reproduces the global integral of the continuous quantity.\n\n**3. Numerical Evaluation and Verification**\nThe integrals for $M_i$ and $\\bar{\\phi}_i M_i$ generally cannot be solved analytically for arbitrary profiles $\\rho(r)$ and $\\phi(r)$. They must be computed using numerical quadrature. High-quality adaptive quadrature routines, such as `scipy.integrate.quad` in Python, are suitable for this task. These routines can achieve accuracy close to machine precision.\n\nFor profiles with known discontinuities, such as in Test Case $2$ at $r=r_{\\mathrm{core}}$, it is crucial to inform the quadrature algorithm of these points. If a shell $[r_i, r_{i+1}]$ contains $r_{\\mathrm{core}}$, the integral must be split, or the point must be passed to the integrator, to avoid numerical errors and ensure an accurate result.\n\nThe verification process confirms the integrity of the mapping. By construction, the sum of a quantity over the discrete shells must equal the total integral over the continuous domain, limited only by the precision of the numerical integration and floating-point arithmetic.\nThe total mass from the grid is $M_{\\mathrm{grid}} = \\sum_{i=0}^{N-1} \\bar{\\rho}_i V_i = \\sum_{i=0}^{N-1} M_i$.\nThe 'exact' total mass is $M_{\\mathrm{tot}} = \\int_0^{R_{\\max}} \\rho(r) dV$.\nThe relative error in mass is:\n$$ \\epsilon_M = \\frac{\\left| M_{\\mathrm{grid}} - M_{\\mathrm{tot}} \\right|}{M_{\\mathrm{tot}}} $$\nSimilarly, for a scalar $\\phi$, the total mass-weighted quantity from the grid is $I_{\\phi, \\mathrm{grid}} = \\sum_{i=0}^{N-1} \\bar{\\phi}_i M_i$.\nThe 'exact' total is $I_{\\phi, \\mathrm{tot}} = \\int_0^{R_{\\max}} \\rho(r) \\phi(r) dV$.\nThe relative error is:\n$$ \\epsilon_\\phi = \\frac{\\left| I_{\\phi, \\mathrm{grid}} - I_{\\phi, \\mathrm{tot}} \\right|}{I_{\\phi, \\mathrm{tot}}} $$\nThese errors quantify the self-consistency of the numerical method.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n\n    # Test Case 1: Smooth, polytrope-like core\n    case1 = {\n        \"R_max\": 3e8,\n        \"N\": 128,\n        \"q\": 1.03,\n        \"discontinuity_points\": None,\n        \"rho_func\": lambda r: 1e10 / (1 + (r / 1e7)**2)**1.5,\n        \"T_func\": lambda r: 7e9 / (1 + (r / 2e7)**1.3),\n        \"Ye_func\": lambda r: 0.5 - 0.1 * r / 3e8,\n    }\n\n    # Test Case 2: Discontinuous core-envelope transition\n    r_core_case2 = 1.5e8\n    \n    def rho_case2(r):\n        return np.where(r = r_core_case2, 6e9, 6e9 * (r / r_core_case2)**(-3))\n\n    def T_case2(r):\n        return 8e9 * np.exp(-r / 1.2e8)\n\n    def Ye_case2(r):\n        return np.where(r = r_core_case2, 0.44, 0.50)\n\n    case2 = {\n        \"R_max\": 3e8,\n        \"N\": 96,\n        \"q\": 1.05,\n        \"discontinuity_points\": [r_core_case2],\n        \"rho_func\": rho_case2,\n        \"T_func\": T_case2,\n        \"Ye_func\": Ye_case2,\n    }\n\n    # Test Case 3: Centrally peaked, rapidly varying core\n    case3 = {\n        \"R_max\": 2.5e8,\n        \"N\": 200,\n        \"q\": 1.02,\n        \"discontinuity_points\": None,\n        \"rho_func\": lambda r: 2e10 * np.exp(-(r / 2e7)**0.5),\n        \"T_func\": lambda r: 1e10 / (1 + (r / 5e7)**1.5),\n        \"Ye_func\": lambda r: 0.48 - 0.05 * np.tanh(r / 1e8),\n    }\n\n    test_cases = [case1, case2, case3]\n    all_results = []\n\n    for case in test_cases:\n        errors = process_case(case)\n        all_results.extend(errors)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\n\ndef process_case(case_params):\n    \"\"\"\n    Processes a single test case: builds the grid, computes averaged quantities,\n    and returns the relative errors.\n    \"\"\"\n    R_max = case_params[\"R_max\"]\n    N = case_params[\"N\"]\n    q = case_params[\"q\"]\n    rho_func = case_params[\"rho_func\"]\n    T_func = case_params[\"T_func\"]\n    Ye_func = case_params[\"Ye_func\"]\n    points = case_params[\"discontinuity_points\"]\n\n    # 1. Grid Construction\n    interfaces = np.zeros(N + 1)\n    if q == 1.0:\n        interfaces = np.linspace(0, R_max, N + 1)\n    else:\n        # dr_0 = R_max * (q - 1) / (q^N - 1)\n        dr0 = R_max * (q - 1) / (q**N - 1)\n        # r_j = dr_0 * (q^j - 1) / (q - 1)\n        # Using a loop to avoid potential floating point issues with large powers\n        # A closed form is also good: r_j = dr0 * (q**j - 1) / (q - 1)\n        for j in range(1, N + 1):\n             interfaces[j] = dr0 * (q**j - 1) / (q - 1)\n    \n    # 2. Define Integrands\n    # Integrand for mass: rho(r) * 4 * pi * r^2\n    mass_integrand = lambda r: rho_func(r) * 4.0 * np.pi * r**2\n    # Integrand for mass-weighted Ye: Ye(r) * rho(r) * 4 * pi * r^2\n    Ye_integrand = lambda r: Ye_func(r) * rho_func(r) * 4.0 * np.pi * r**2\n    # Integrand for mass-weighted T: T(r) * rho(r) * 4 * pi * r^2\n    T_integrand = lambda r: T_func(r) * rho_func(r) * 4.0 * np.pi * r**2\n\n    # 3. Calculate \"Exact\" Total Integrals\n    M_total = quad(mass_integrand, 0, R_max, points=points)[0]\n    IY_total = quad(Ye_integrand, 0, R_max, points=points)[0]\n    IT_total = quad(T_integrand, 0, R_max, points=points)[0]\n    \n    # 4. Compute Shell Quantities and Sums\n    shell_masses = np.zeros(N)\n    shell_I_Ye = np.zeros(N)\n    shell_I_T = np.zeros(N)\n\n    for i in range(N):\n        r_a, r_b = interfaces[i], interfaces[i+1]\n        \n        # Integrate over the shell\n        # M_i = integral of mass_integrand from r_a to r_b\n        shell_masses[i] = quad(mass_integrand, r_a, r_b, points=points)[0]\n        # I_{Y,i} = integral of Ye_integrand from r_a to r_b\n        shell_I_Ye[i] = quad(Ye_integrand, r_a, r_b, points=points)[0]\n        # I_{T,i} = integral of T_integrand from r_a to r_b\n        shell_I_T[i] = quad(T_integrand, r_a, r_b, points=points)[0]\n\n    # Sum up the discrete shell quantities\n    # By construction, M_grid = Sum(M_i)\n    M_grid = np.sum(shell_masses)\n    \n    # By construction, IY_grid = Sum(Ye_bar_i * M_i) = Sum(I_{Y,i}/M_i * M_i) = Sum(I_{Y,i})\n    IY_grid = np.sum(shell_I_Ye)\n    IT_grid = np.sum(shell_I_T)\n\n    # 5. Calculate Relative Errors\n    eps_M = np.abs(M_grid - M_total) / M_total if M_total != 0 else 0.0\n    eps_Y = np.abs(IY_grid - IY_total) / IY_total if IY_total != 0 else 0.0\n    eps_T = np.abs(IT_grid - IT_total) / IT_total if IT_total != 0 else 0.0\n    \n    return [eps_M, eps_Y, eps_T]\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3533781"}, {"introduction": "As the stellar core collapses to nuclear densities, physical processes operate on vastly different timescales, leading to numerically \"stiff\" systems of equations that pose a major challenge for time integration. The rapid electron captures that drive the deleptonization of the core are a prime example of such stiffness. In this practice [@problem_id:3533784], you will implement and analyze a widely used Implicit-Explicit (IMEX) time-stepping scheme to handle these stiff source terms, learning to balance numerical stability with computational accuracy and efficiency.", "problem": "Consider a single Lagrangian fluid element during the infall phase of a core-collapse supernova. Neglecting advection and neutrino transport feedback on the time step of interest, the electron fraction evolves due to electron capture on nuclei and free protons according to the ordinary differential equation (ODE)\n$$\n\\frac{dY_e}{dt}=-\\lambda_{\\mathrm{ec}}(\\rho)\\,Y_e,\n$$\nwhere $Y_e$ is the electron fraction and $\\lambda_{\\mathrm{ec}}(\\rho)$ is the electron-capture rate, modeled here as a density-only power law\n$$\n\\lambda_{\\mathrm{ec}}(\\rho)=\\lambda_0\\left(\\frac{\\rho}{\\rho_0}\\right)^{\\alpha}.\n$$\nAssume the constants are\n$$\n\\lambda_0=5\\,\\mathrm{s^{-1}},\\quad \\rho_0=10^9\\,\\mathrm{g\\,cm^{-3}},\\quad \\alpha=0.6.\n$$\nImplement a one-parameter Implicit-Explicit (IMEX) update for the stiff source term using the $\\theta$-method splitting of the linear source over a single time step of size $\\Delta t$:\n$$\nY_e^{n+1}=Y_e^n+\\Delta t\\left[-(1-\\theta)\\,\\lambda_{\\mathrm{ec}}(\\rho)\\,Y_e^n-\\theta\\,\\lambda_{\\mathrm{ec}}(\\rho)\\,Y_e^{n+1}\\right],\n$$\nwith a fixed implicitness parameter\n$$\n\\theta=0.3.\n$$\nFor this linear test problem, the update is a linear amplification mapping $Y_e^{n+1}=G\\,Y_e^n$ with amplification factor $G(\\Delta t,\\rho,\\theta)$. Using this amplification factor, you must classify each $(\\Delta t,\\rho)$ pair with two properties:\n\n- Numerical stability with physical monotonicity: declare the step “stable” if and only if $0\\le G(\\Delta t,\\rho,\\theta)\\le 1$, which guarantees no sign change and no increase in $Y_e$.\n- Local accuracy: declare the step “accurate” if the one-step relative error with respect to the exact solution is below the tolerance $\\varepsilon$,\n$$\n\\frac{\\left|G(\\Delta t,\\rho,\\theta)-e^{-\\lambda_{\\mathrm{ec}}(\\rho)\\,\\Delta t}\\right|}{e^{-\\lambda_{\\mathrm{ec}}(\\rho)\\,\\Delta t}}\\le \\varepsilon,\\quad \\varepsilon=10^{-3}.\n$$\n\nYou must derive $G(\\Delta t,\\rho,\\theta)$ and apply it to the following test suite of densities and time steps:\n\n- Densities (in $\\mathrm{g\\,cm^{-3}}$): $\\rho\\in\\{10^8,10^{10},10^{12}\\}$.\n- Time steps (in $\\mathrm{s}$): $\\Delta t\\in\\{10^{-6},10^{-4},10^{-3},5\\times 10^{-3},2\\times 10^{-2}\\}$.\n\nFor each ordered pair $(\\rho,\\Delta t)$, assign a classification code $c$ defined as follows:\n- $c=2$ if the step is stable and accurate,\n- $c=1$ if the step is stable but not accurate,\n- $c=0$ if the step is not stable (that is, outside the monotone stability region).\n\nYour program must compute all classifications for the Cartesian product of the above sets ordered with $\\rho$ as the outer loop in ascending order and $\\Delta t$ as the inner loop in ascending order. The output must be a single line containing the $15$ integer codes in this order as a comma-separated list enclosed in square brackets, for example, $[c_1,c_2,\\dots,c_{15}]$. All computations should use the units provided above for $\\rho$ and $\\Delta t$, and the output codes are unitless integers. No other text should be printed.\n\nYour implementation must be a complete, runnable program that carries out the above classification by deriving and using $G(\\Delta t,\\rho,\\theta)$; do not hard-code the answers.", "solution": "We start from the evolution equation for the electron fraction of a Lagrangian fluid element,\n$$\n\\frac{dY_e}{dt}=-\\lambda_{\\mathrm{ec}}(\\rho)Y_e,\n$$\nwhere the electron-capture rate is modeled as\n$$\n\\lambda_{\\mathrm{ec}}(\\rho)=\\lambda_0\\left(\\frac{\\rho}{\\rho_0}\\right)^{\\alpha},\\quad \\lambda_0=5\\,\\mathrm{s^{-1}},\\ \\rho_0=10^9\\,\\mathrm{g\\,cm^{-3}},\\ \\alpha=0.6.\n$$\nFor fixed $\\rho$ over a single time step, the ODE is linear with constant coefficients and the exact solution over a step of size $\\Delta t$ is\n$$\nY_e(t+\\Delta t)=Y_e(t)\\,e^{-\\lambda_{\\mathrm{ec}}(\\rho)\\,\\Delta t}.\n$$\nTo design a numerically robust update that treats stiffness implicitly while retaining a notion of an Implicit-Explicit (IMEX) split, we consider a $\\theta$-method partition of the source term. Let $Y_e^n$ be the state at time $t^n$ and $Y_e^{n+1}$ at $t^{n+1}=t^n+\\Delta t$. We discretize\n$$\nY_e^{n+1}=Y_e^n+\\Delta t\\left[-(1-\\theta)\\lambda_{\\mathrm{ec}}(\\rho)\\,Y_e^n-\\theta\\lambda_{\\mathrm{ec}}(\\rho)\\,Y_e^{n+1}\\right],\n$$\nwith a fixed implicitness parameter $\\theta$. This is a valid IMEX treatment in the sense of treating a portion of the stiff term implicitly and the remainder explicitly; with only a stiff source present, it reduces to a one-parameter family of linearly implicit updates. Rearranging the discrete equation yields\n$$\nY_e^{n+1}+\\Delta t\\,\\theta\\,\\lambda_{\\mathrm{ec}}(\\rho)\\,Y_e^{n+1}=Y_e^n-\\Delta t\\,(1-\\theta)\\,\\lambda_{\\mathrm{ec}}(\\rho)\\,Y_e^n,\n$$\nso that\n$$\nY_e^{n+1}=\\frac{1-(1-\\theta)\\,\\lambda_{\\mathrm{ec}}(\\rho)\\,\\Delta t}{1+\\theta\\,\\lambda_{\\mathrm{ec}}(\\rho)\\,\\Delta t}\\,Y_e^n.\n$$\nDefine the non-dimensional stiffness parameter $z=\\lambda_{\\mathrm{ec}}(\\rho)\\,\\Delta t$. The amplification factor is then\n$$\nG(z,\\theta)=\\frac{1-(1-\\theta)\\,z}{1+\\theta\\,z}.\n$$\nThe stability requirement we impose for this physical decay problem is numerical stability with physical monotonicity, namely $0\\le G\\le 1$. Because the denominator $1+\\theta z$ is strictly positive for $z\\ge 0$ and $\\theta\\ge 0$, the condition $0\\le G\\le 1$ reduces to\n$$\n0\\le 1-(1-\\theta)\\,z\\le 1+\\theta\\,z.\n$$\nThe right inequality, $1-(1-\\theta)z\\le 1+\\theta z$, is always true for $z\\ge 0$. The left inequality, $1-(1-\\theta)z\\ge 0$, gives the monotone stability region\n$$\n0\\le z\\le \\frac{1}{1-\\theta}.\n$$\nFor the given choice $\\theta=0.3$, this bound is\n$$\n0\\le z\\le \\frac{1}{1-0.3}=\\frac{1}{0.7}\\approx 1.428571\\ldots\n$$\nThus, any $(\\rho,\\Delta t)$ pair with $z=\\lambda_{\\mathrm{ec}}(\\rho)\\Delta t\\le 1/(1-\\theta)$ is monotone-stable, and otherwise the method yields $G0$ and violates the physical monotonic decay, which we classify as unstable.\n\nFor accuracy, we compare the numerical one-step update to the exact one-step solution. The exact amplification is $e^{-z}$ and the numerical amplification is $G(z,\\theta)$. The one-step relative error is\n$$\n\\mathrm{err}(z,\\theta)=\\frac{\\left|G(z,\\theta)-e^{-z}\\right|}{e^{-z}}.\n$$\nWe declare the step accurate if $\\mathrm{err}(z,\\theta)\\le \\varepsilon$ with $\\varepsilon=10^{-3}$. For small $z$, a Taylor expansion confirms first-order accuracy: $G(z,\\theta)=1-z+\\theta(1-\\theta)z^2+\\mathcal{O}(z^3)$ while $e^{-z}=1-z+\\tfrac{1}{2}z^2+\\mathcal{O}(z^3)$, giving a local error proportional to $|(\\theta(1-\\theta)-\\tfrac{1}{2})z^2|$ at leading order. As $z$ increases, the error grows, crossing the tolerance at a problem-dependent threshold.\n\nTo evaluate the test suite, we compute\n$$\n\\lambda_{\\mathrm{ec}}(\\rho)=5\\left(\\frac{\\rho}{10^9\\,\\mathrm{g\\,cm^{-3}}}\\right)^{0.6}\\,\\mathrm{s^{-1}}\n$$\nfor each specified density $\\rho\\in\\{10^8,10^{10},10^{12}\\}\\,\\mathrm{g\\,cm^{-3}}$, then evaluate $z=\\lambda_{\\mathrm{ec}}(\\rho)\\Delta t$ for each $\\Delta t\\in\\{10^{-6},10^{-4},10^{-3},5\\times 10^{-3},2\\times 10^{-2}\\}\\,\\mathrm{s}$. For each pair we compute $G(z,0.3)$, test stability via $0\\le G\\le 1$, and compute the error $\\mathrm{err}(z,0.3)$ to compare with $\\varepsilon=10^{-3}$. The classification code $c$ is assigned as $c=2$ if stable and accurate, $c=1$ if stable but not accurate, and $c=0$ if not stable.\n\nAlgorithmically, this reduces to:\n- Loop over $\\rho$ in ascending order and $\\Delta t$ in ascending order.\n- Compute $\\lambda_{\\mathrm{ec}}(\\rho)$ and $z$.\n- Compute $G$ and check $0\\le G\\le 1$ for stability.\n- Compute $\\mathrm{err}$ and compare with $\\varepsilon$ for accuracy.\n- Append the corresponding integer code to the results list.\n\nFinally, print the results as a single line in the exact format $[c_1,c_2,\\dots,c_{15}]$. This procedure ensures the mapping of stability and accuracy regions in the $(\\Delta t,\\rho)$ plane for the specified IMEX update and rate model, using physically meaningful criteria grounded in the exponential decay dynamics of the stiff source term.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef lambda_ec(rho, lambda0=5.0, rho0=1e9, alpha=0.6):\n    \"\"\"\n    Electron-capture rate model: lambda_ec = lambda0 * (rho / rho0)^alpha\n    rho in g/cm^3, lambda in 1/s\n    \"\"\"\n    return lambda0 * (rho / rho0) ** alpha\n\ndef amplification_factor(z, theta):\n    \"\"\"\n    Amplification factor G for the theta-IMEX update on y' = -lambda y with z=lambda*dt.\n    G = (1 - (1-theta)*z) / (1 + theta*z)\n    \"\"\"\n    return (1.0 - (1.0 - theta) * z) / (1.0 + theta * z)\n\ndef classify_case(rho, dt, theta=0.3, eps=1e-3):\n    \"\"\"\n    Classify one (rho, dt) pair.\n    Returns:\n        2 if stable and accurate,\n        1 if stable but not accurate,\n        0 if unstable (violates monotone stability 0 = G = 1).\n    \"\"\"\n    lam = lambda_ec(rho)\n    z = lam * dt\n    G = amplification_factor(z, theta)\n    # Monotone stability: non-negative and no growth.\n    stable = (G = 0.0) and (G = 1.0)\n    if not stable:\n        return 0\n    # Relative one-step error vs exact exponential decay.\n    exact = np.exp(-z)\n    rel_err = abs(G - exact) / exact if exact != 0.0 else np.inf\n    if rel_err = eps:\n        return 2\n    else:\n        return 1\n\ndef solve():\n    # Define the test cases from the problem statement.\n    densities = [1e8, 1e10, 1e12]  # g/cm^3\n    timesteps = [1e-6, 1e-4, 1e-3, 5e-3, 2e-2]  # s\n    theta = 0.3\n    eps = 1e-3\n\n    results = []\n    for rho in densities:\n        for dt in timesteps:\n            c = classify_case(rho, dt, theta=theta, eps=eps)\n            results.append(c)\n\n    # Final print statement in the exact required format: no spaces.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3533784"}, {"introduction": "The central mystery of core-collapse supernovae is understanding the mechanism that revives the stalled shock wave and drives a successful explosion. The leading theory posits that this revival is governed by a delicate balance between rapid neutrino heating in the \"gain region\" and the relentless infall of overlying material. This capstone exercise [@problem_id:3533769] will have you build a semi-analytic model to explore this critical timescale competition, allowing you to quantify the conditions necessary for shock revival and gain deep physical insight into the heart of the explosion.", "problem": "You are to derive, implement, and test a spherically symmetric, optically thin heating model for the gain region in a core-collapse supernova. Your goal is to compute the neutrino heating efficiency and to evaluate the shock revival condition based on a ratio of characteristic timescales. The result must be a complete, runnable program that outputs the requested values for a specified test suite.\n\nStart from the following fundamental bases and core definitions:\n- Newtonian gravity and gravitational potential energy: a mass element at radius $r$ in the potential of a central mass $M_{\\mathrm{NS}}$ has specific gravitational potential $-\\dfrac{G M_{\\mathrm{NS}}}{r}$, where $G$ is the gravitational constant.\n- Mass conservation in steady flow: the advective residence time of mass in a control volume equals total mass in the volume divided by the mass flux through it.\n- Optically thin radiative transfer with pure absorption: along a radial trajectory through a slab of mass column density $\\Sigma$, the absorbed fraction of an incident energy flux is $1-e^{-\\tau}$ with optical depth $\\tau=\\kappa\\,\\Sigma$, where $\\kappa$ is the mass absorption opacity.\n- Charged-current electron-flavor neutrino absorption cross-section scaling with squared neutrino energy: $\\sigma_{\\mathrm{abs}}(\\varepsilon)\\approx \\sigma_0\\left(\\dfrac{\\varepsilon}{\\mathrm{MeV}}\\right)^2$ with $\\sigma_0$ a constant.\n\nAssume a spherically symmetric gain region from radius $R_g$ (gain radius) to $R_s$ (shock radius), with a power-law density profile\n$$\n\\rho(r)=\\rho_g\\left(\\dfrac{r}{R_g}\\right)^{-n},\n$$\nand take $n=2$ for analytic tractability. You are given a neutrino luminosity $L_\\nu$ and an effective mean neutrino energy $\\langle \\varepsilon_\\nu \\rangle$.\n\nDerive and implement the following, using only the fundamental bases above (do not invoke any other specialized supernova scaling relations):\n\n1) Heating efficiency. Use the optically thin absorption model to express the heating efficiency as the absorbed fraction of the neutrino luminosity across the gain layer,\n$$\n\\eta \\equiv \\dfrac{\\dot{Q}_{\\mathrm{heat}}}{L_\\nu} = 1 - e^{-\\tau_{\\mathrm{gain}}}, \\quad \\tau_{\\mathrm{gain}} = \\int_{R_g}^{R_s} \\kappa\\,\\rho(r)\\,dr,\n$$\nwith mass absorption opacity\n$$\n\\kappa = \\dfrac{\\sigma_{\\mathrm{abs}}}{m_b} = \\dfrac{\\sigma_0}{m_b}\\left(\\dfrac{\\langle \\varepsilon_\\nu \\rangle}{\\mathrm{MeV}}\\right)^2,\n$$\nwhere $m_b$ is the baryon mass. For $n=2$, compute the gain-region column density\n$$\n\\Sigma \\equiv \\int_{R_g}^{R_s} \\rho(r)\\,dr = \\rho_g R_g \\left(1 - \\dfrac{R_g}{R_s}\\right),\n$$\nso that $\\tau_{\\mathrm{gain}}=\\kappa\\,\\Sigma$.\n\n2) Advective timescale. Using mass conservation, compute the advective residence time\n$$\n\\tau_{\\mathrm{adv}} = \\dfrac{M_{\\mathrm{gain}}}{\\dot{M}},\n$$\nwhere the gain mass for $n=2$ is\n$$\nM_{\\mathrm{gain}} = 4\\pi \\int_{R_g}^{R_s} \\rho(r)\\,r^2\\,dr = 4\\pi \\rho_g R_g^2 \\left(R_s - R_g\\right).\n$$\n\n3) Heating timescale. Compute the magnitude of the gravitational binding energy of the gain region as\n$$\nE_{\\mathrm{bind}} = 4\\pi G M_{\\mathrm{NS}} \\int_{R_g}^{R_s} \\rho(r)\\,r\\,dr = 4\\pi G M_{\\mathrm{NS}} \\rho_g R_g^2 \\ln\\!\\left(\\dfrac{R_s}{R_g}\\right),\n$$\nand the net neutrino heating rate as $\\dot{Q}_{\\mathrm{heat}}=\\eta L_\\nu$. Then define\n$$\n\\tau_{\\mathrm{heat}} = \\dfrac{E_{\\mathrm{bind}}}{\\dot{Q}_{\\mathrm{heat}}}.\n$$\n\n4) Shock revival condition. Define the shock revival diagnostic as\n$$\n\\mathcal{R} \\equiv \\dfrac{\\tau_{\\mathrm{adv}}}{\\tau_{\\mathrm{heat}}},\n$$\nand declare revival if $\\mathcal{R}  1$.\n\nConstants and units to use:\n- All computations must be in centimeter-gram-second (cgs) units.\n- Gravitational constant $G = 6.674\\times 10^{-8}\\,\\mathrm{cm^3\\,g^{-1}\\,s^{-2}}$.\n- Solar mass $M_\\odot = 1.98847\\times 10^{33}\\,\\mathrm{g}$.\n- Neutron star mass $M_{\\mathrm{NS}} = 1.4\\,M_\\odot$.\n- Gain radius $R_g = 100\\,\\mathrm{km} = 1.0\\times 10^{7}\\,\\mathrm{cm}$.\n- Density normalization at the gain radius $\\rho_g = 1.0\\times 10^{9}\\,\\mathrm{g\\,cm^{-3}}$.\n- Density power-law index $n=2$ (as stated above).\n- Neutrino luminosity $L_\\nu = 3.0\\times 10^{52}\\,\\mathrm{erg\\,s^{-1}}$.\n- Effective mean neutrino energy $\\langle \\varepsilon_\\nu \\rangle = 12\\,\\mathrm{MeV}$.\n- Baryon mass $m_b = 1.674\\times 10^{-24}\\,\\mathrm{g}$.\n- Charged-current absorption cross-section coefficient $\\sigma_0 = 9.0\\times 10^{-44}\\,\\mathrm{cm^2}$.\n\nTest suite. For each case, you are given an accretion rate $\\dot{M}$ in $M_\\odot\\,\\mathrm{s^{-1}}$ and a shock radius $R_s$ in $\\mathrm{km}$:\n- Case A: $\\dot{M} = 0.3$, $R_s=150$.\n- Case B: $\\dot{M} = 0.05$, $R_s=150$.\n- Case C: $\\dot{M} = 1.0$, $R_s=150$.\n- Case D: $\\dot{M} = 0.3$, $R_s=250$.\n- Case E (edge case with very low accretion): $\\dot{M} = 0.01$, $R_s=150$.\n\nFor each case, compute:\n- The heating efficiency $\\eta$ (dimensionless).\n- The ratio $\\mathcal{R}=\\tau_{\\mathrm{adv}}/\\tau_{\\mathrm{heat}}$ (dimensionless).\n- The boolean flag `revive` defined as `True` if $\\mathcal{R}>1$ and `False` otherwise.\n\nFinal output format:\n- Your program must produce a single line containing a list of results for the five cases, in the order [Case A, Case B, Case C, Case D, Case E].\n- Each case’s result must be a nested list of the form `[revive, eta, R]`, where `revive` is a boolean, and $\\eta$ and $\\mathcal{R}$ are floating-point numbers rounded to six decimal places.\n- The final output must be a single line with the overall list and no additional text, for example: `[[False,0.012345,0.678901],[True,0.023456,1.234567],...]`.\n\nAngle units do not apply. No other inputs are required. All constants and parameters are provided above. All results are dimensionless and must be printed as floating-point numbers rounded to six decimal places as specified.", "solution": "The problem requires the derivation and implementation of a simplified, spherically symmetric model for neutrino heating in the gain region of a core-collapse supernova. The objective is to compute the neutrino heating efficiency $\\eta$, the ratio of characteristic timescales $\\mathcal{R} = \\tau_{\\mathrm{adv}}/\\tau_{\\mathrm{heat}}$, and determine a shock revival condition based on this ratio for a given set of parameters. All calculations will be performed in the centimeter-gram-second (cgs) system of units.\n\nThe model is based on a set of fundamental principles and definitions. The gain region extends from a gain radius $R_g$ to a shock radius $R_s$. The density distribution within this region follows a power law $\\rho(r)=\\rho_g(r/R_g)^{-n}$, with the index specified as $n=2$.\n\nThe derivation proceeds in three main steps, followed by the description of the computational implementation.\n\n1.  **Heating Efficiency, $\\eta$**\n\nThe heating efficiency, $\\eta$, is defined as the fraction of the total neutrino luminosity $L_\\nu$ that is absorbed by the matter in the gain region. The net heating rate is thus $\\dot{Q}_{\\mathrm{heat}} = \\eta L_\\nu$.\n\nUsing the provided model for optically thin radiative transfer with pure absorption, the efficiency is given by:\n$$\n\\eta = 1 - e^{-\\tau_{\\mathrm{gain}}}\n$$\nwhere $\\tau_{\\mathrm{gain}}$ is the total optical depth of the gain region to neutrinos. The optical depth is calculated by integrating the product of the mass absorption opacity $\\kappa$ and the mass density $\\rho(r)$ along a radial path from $R_g$ to $R_s$:\n$$\n\\tau_{\\mathrm{gain}} = \\int_{R_g}^{R_s} \\kappa\\,\\rho(r)\\,dr\n$$\nThe opacity $\\kappa$ is assumed to be constant throughout the gain region. It is derived from the neutrino absorption cross-section per baryon, $\\sigma_{\\mathrm{abs}}$, and the baryon mass, $m_b$. Given the cross-section's dependence on the squared neutrino energy $\\varepsilon$, $\\sigma_{\\mathrm{abs}}(\\varepsilon) \\approx \\sigma_0 (\\varepsilon/\\mathrm{MeV})^2$, the opacity for neutrinos with an effective mean energy $\\langle \\varepsilon_\\nu \\rangle$ is:\n$$\n\\kappa = \\dfrac{\\sigma_{\\mathrm{abs}}}{m_b} = \\dfrac{\\sigma_0}{m_b}\\left(\\dfrac{\\langle \\varepsilon_\\nu \\rangle}{\\mathrm{MeV}}\\right)^2\n$$\nThe integral for the optical depth simplifies to $\\tau_{\\mathrm{gain}} = \\kappa \\Sigma$, where $\\Sigma$ is the total mass column density of the gain region. The problem provides the result of the integration for the specific case of $n=2$:\n$$\n\\Sigma = \\int_{R_g}^{R_s} \\rho(r)\\,dr = \\int_{R_g}^{R_s} \\rho_g \\left(\\dfrac{r}{R_g}\\right)^{-2} dr = \\rho_g R_g \\left(1 - \\dfrac{R_g}{R_s}\\right)\n$$\nBy calculating $\\kappa$ from the given constants and $\\Sigma$ for each test case's $R_s$, we can determine $\\tau_{\\mathrm{gain}}$ and subsequently the heating efficiency $\\eta$.\n\n2.  **Characteristic Timescales: $\\tau_{\\mathrm{adv}}$ and $\\tau_{\\mathrm{heat}}$**\n\nThe revival of the supernova shock is governed by the competition between two processes: the advection of matter through the gain region and the heating of that matter by neutrinos. These processes are characterized by the advective timescale, $\\tau_{\\mathrm{adv}}$, and the heating timescale, $\\tau_{\\mathrm{heat}}$.\n\nThe **advective timescale**, $\\tau_{\\mathrm{adv}}$, is the residence time of matter in the gain region. Based on mass conservation in a steady flow, it is the ratio of the total mass in the gain region, $M_{\\mathrm{gain}}$, to the mass accretion rate, $\\dot{M}$:\n$$\n\\tau_{\\mathrm{adv}} = \\dfrac{M_{\\mathrm{gain}}}{\\dot{M}}\n$$\nThe mass in the gain region, $M_{\\mathrm{gain}}$, is found by integrating the density over the volume of the spherical shell from $R_g$ to $R_s$. For the given density profile with $n=2$, the integral is provided:\n$$\nM_{\\mathrm{gain}} = 4\\pi \\int_{R_g}^{R_s} \\rho(r)\\,r^2\\,dr = 4\\pi \\int_{R_g}^{R_s} \\rho_g \\left(\\dfrac{r}{R_g}\\right)^{-2} r^2\\,dr = 4\\pi \\rho_g R_g^2 (R_s - R_g)\n$$\nThe **heating timescale**, $\\tau_{\\mathrm{heat}}$, represents the time required for the absorbed neutrino energy to overcome the gravitational binding of the matter in the gain region. It is defined as the ratio of the magnitude of the gravitational binding energy of the gain mass, $E_{\\mathrm{bind}}$, to the net heating rate, $\\dot{Q}_{\\mathrm{heat}}$:\n$$\n\\tau_{\\mathrm{heat}} = \\dfrac{E_{\\mathrm{bind}}}{\\dot{Q}_{\\mathrm{heat}}}\n$$\nThe binding energy, $E_{\\mathrm{bind}}$, is calculated by integrating the specific gravitational potential energy over all mass elements in the gain region. The central object is a neutron star of mass $M_{\\mathrm{NS}}$. For the $n=2$ density profile, this integral is provided:\n$$\nE_{\\mathrm{bind}} = 4\\pi G M_{\\mathrm{NS}} \\int_{R_g}^{R_s} \\rho(r)\\,r\\,dr = 4\\pi G M_{\\mathrm{NS}} \\int_{R_g}^{R_s} \\rho_g \\left(\\dfrac{r}{R_g}\\right)^{-2} r\\,dr = 4\\pi G M_{\\mathrm{NS}} \\rho_g R_g^2 \\ln\\left(\\dfrac{R_s}{R_g}\\right)\n$$\nThe denominator, $\\dot{Q}_{\\mathrm{heat}}$, is calculated using the previously determined heating efficiency $\\eta$ and the given neutrino luminosity $L_\\nu$.\n\n3.  **Shock Revival Condition**\n\nThe competition between advection and heating is quantified by the dimensionless ratio $\\mathcal{R}$:\n$$\n\\mathcal{R} \\equiv \\dfrac{\\tau_{\\mathrm{adv}}}{\\tau_{\\mathrm{heat}}}\n$$\nA value of $\\mathcal{R}  1$ signifies that the heating timescale is shorter than the advective timescale. This implies that matter is heated sufficiently to become unbound before it is advected onto the neutron star. Therefore, the condition for successful shock revival in this model is $\\mathcal{R}  1$.\n\nThe computational procedure is as follows:\nFirst, all physical constants ($G$, $M_\\odot$, etc.) are defined in cgs units. The neutron star mass $M_{\\mathrm{NS}}$ is computed. The mass absorption opacity $\\kappa$ is a constant for all test cases and is calculated once.\n\nFor each test case, specified by an accretion rate $\\dot{M}$ (in $M_\\odot\\,\\mathrm{s^{-1}}$) and a shock radius $R_s$ (in km):\n1.  Convert $\\dot{M}$ to $\\mathrm{g\\,s^{-1}}$ and $R_s$ to $\\mathrm{cm}$.\n2.  Calculate the column density $\\Sigma$ using the given $R_s$.\n3.  Compute the optical depth $\\tau_{\\mathrm{gain}} = \\kappa\\Sigma$ and the heating efficiency $\\eta = 1 - e^{-\\tau_{\\mathrm{gain}}}$.\n4.  Calculate the mass in the gain region, $M_{\\mathrm{gain}}$.\n5.  Calculate the advective timescale $\\tau_{\\mathrm{adv}} = M_{\\mathrm{gain}}/\\dot{M}$.\n6.  Calculate the binding energy of the gain region, $E_{\\mathrm{bind}}$.\n7.  Calculate the total heating rate $\\dot{Q}_{\\mathrm{heat}} = \\eta L_\\nu$.\n8.  Calculate the heating timescale $\\tau_{\\mathrm{heat}} = E_{\\mathrm{bind}}/\\dot{Q}_{\\mathrm{heat}}$.\n9.  Compute the diagnostic ratio $\\mathcal{R} = \\tau_{\\mathrm{adv}}/\\tau_{\\mathrm{heat}}$.\n10. Determine the revival flag: `True` if $\\mathcal{R}  1$, otherwise `False`.\n11. Store and format the results (`revive`, $\\eta$, $\\mathcal{R}$) to the required precision.\n\nThis systematic application of the derived formulae allows for the evaluation of the shock revival condition for each specified scenario.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the neutrino heating efficiency and shock revival condition for\n    a simplified core-collapse supernova model.\n    \"\"\"\n    \n    # Constants and units (all in cgs)\n    G = 6.674e-8        # Gravitational constant [cm^3 g^-1 s^-2]\n    M_SOLAR = 1.98847e33 # Solar mass [g]\n    M_NS = 1.4 * M_SOLAR # Neutron star mass [g]\n    R_g = 1.0e7          # Gain radius [cm] (100 km)\n    rho_g = 1.0e9        # Density at gain radius [g cm^-3]\n    L_nu = 3.0e52        # Neutrino luminosity [erg s^-1]\n    eps_nu_mean = 12.0   # Effective mean neutrino energy [MeV]\n    m_b = 1.674e-24      # Baryon mass [g]\n    sigma_0 = 9.0e-44    # Cross-section coefficient [cm^2]\n\n    # Pre-calculate constant mass absorption opacity kappa [cm^2 g^-1]\n    kappa = (sigma_0 / m_b) * (eps_nu_mean**2)\n\n    # Test suite: (M_dot [M_solar/s], R_s [km])\n    test_cases = [\n        (0.3, 150.0),   # Case A\n        (0.05, 150.0),  # Case B\n        (1.0, 150.0),   # Case C\n        (0.3, 250.0),   # Case D\n        (0.01, 150.0),  # Case E\n    ]\n\n    results = []\n    for m_dot_msun_s, r_s_km in test_cases:\n        # Convert inputs to cgs units\n        m_dot = m_dot_msun_s * M_SOLAR  # Mass accretion rate [g s^-1]\n        r_s = r_s_km * 1.0e5          # Shock radius [cm]\n\n        # 1) Heating efficiency eta\n        # Column density Sigma [g cm^-2]\n        Sigma = rho_g * R_g * (1.0 - R_g / r_s)\n        \n        # Optical depth tau_gain (dimensionless)\n        tau_gain = kappa * Sigma\n        \n        # Heating efficiency eta (dimensionless)\n        eta = 1.0 - np.exp(-tau_gain)\n\n        # 2) Advective timescale tau_adv\n        # Mass in the gain region M_gain [g]\n        M_gain = 4.0 * np.pi * rho_g * R_g**2 * (r_s - R_g)\n        \n        # Advective timescale tau_adv [s]\n        tau_adv = M_gain / m_dot\n\n        # 3) Heating timescale tau_heat\n        # Gravitational binding energy of the gain region E_bind [erg]\n        E_bind = 4.0 * np.pi * G * M_NS * rho_g * R_g**2 * np.log(r_s / R_g)\n        \n        # Net heating rate Q_heat_dot [erg s^-1]\n        Q_heat_dot = eta * L_nu\n        \n        # Heating timescale tau_heat [s]\n        tau_heat = E_bind / Q_heat_dot\n\n        # 4) Shock revival condition\n        # Diagnostic ratio R (dimensionless)\n        R_ratio = tau_adv / tau_heat\n        \n        # Revival flag (boolean)\n        revive = R_ratio  1.0\n        \n        results.append([revive, eta, R_ratio])\n\n    # Final print statement in the exact required format.\n    # Format: [[bool,float,float],[bool,float,float],...]\n    output_strings = []\n    for res in results:\n        bool_str = str(res[0])\n        eta_str = f\"{res[1]:.6f}\"\n        R_str = f\"{res[2]:.6f}\"\n        output_strings.append(f\"[{bool_str},{eta_str},{R_str}]\")\n    \n    print(f\"[{','.join(output_strings)}]\")\n\nsolve()\n```", "id": "3533769"}]}