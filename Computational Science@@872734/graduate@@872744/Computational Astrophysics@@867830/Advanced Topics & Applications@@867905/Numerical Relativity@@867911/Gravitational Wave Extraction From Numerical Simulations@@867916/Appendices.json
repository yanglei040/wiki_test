{"hands_on_practices": [{"introduction": "The first step in analyzing the rich structure of gravitational radiation from a numerical simulation is to decompose the wave signal on a spherical extraction surface into a basis of spin-weighted spherical harmonics. Because this decomposition is performed numerically on a finite grid of points, the discrete approximation to the projection integral can cause power from a dominant mode to \"leak\" into adjacent modes, a phenomenon known as spectral leakage. This exercise will give you direct experience with the projection machinery, allowing you to quantify this leakage and explore how sampling resolution and signal windowing can be used to control it [@problem_id:3471549].", "problem": "You are given the task of quantifying spherical harmonic leakage when projecting a pure spin-weighted spherical harmonic signal onto a finite grid. In gravitational wave extraction in numerical relativity, the complex strain on the sphere is decomposed into spin-weighted spherical harmonics of spin weight $s=-2$. The spin-weighted spherical harmonics $\\ {}_sY_{\\ell m}(\\theta,\\phi)$ form an orthonormal basis on the two-sphere under the inner product induced by the spherical measure, and in the continuum,\n$$\n\\int_0^{2\\pi}\\int_0^\\pi\\ {}_sY_{\\ell m}(\\theta,\\phi)\\ {}_sY_{\\ell' m'}^*(\\theta,\\phi)\\ \\sin\\theta\\ d\\theta\\ d\\phi = \\delta_{\\ell \\ell'}\\delta_{m m'}.\n$$\nFinite-resolution sampling and windowing of the signal modify the effective inner product and can cause leakage of power into neighboring $(\\ell,m)$ modes.\n\nStarting from the fundamental definition that a coefficient of the mode $(\\ell,m)$ in the expansion of a complex field $f(\\theta,\\phi)$ is obtained by the inner product\n$$\nc_{\\ell m} = \\int_0^{2\\pi}\\int_0^\\pi f(\\theta,\\phi)\\ {}_sY_{\\ell m}^*(\\theta,\\phi)\\ \\sin\\theta\\ d\\theta\\ d\\phi,\n$$\nyou must approximate this integral using a rectangular quadrature on a uniform grid in colatitude and azimuth with mid-point sampling in colatitude. Specifically, let $N_\\theta$ and $N_\\phi$ denote the number of samples in colatitude and azimuth, respectively. Define $\\Delta\\theta = \\pi/N_\\theta$ and $\\Delta\\phi = 2\\pi/N_\\phi$, with mid-point colatitude samples $\\theta_i = (i+1/2)\\Delta\\theta$ for $i=0,\\dots,N_\\theta-1$, and azimuth samples $\\phi_j = j\\Delta\\phi$ for $j=0,\\dots,N_\\phi-1$. The discrete approximation to $c_{\\ell m}$ is then\n$$\nc_{\\ell m} \\approx \\sum_{i=0}^{N_\\theta-1}\\sum_{j=0}^{N_\\phi-1} f(\\theta_i,\\phi_j)\\ {}_sY_{\\ell m}^*(\\theta_i,\\phi_j)\\ \\sin\\theta_i\\ \\Delta\\theta\\ \\Delta\\phi.\n$$\n\nConsider the pure input signal\n$$\nf(\\theta,\\phi) = {}_{-2}Y_{2,2}(\\theta,\\phi),\n$$\nand apply a window function $w(\\theta)$ multiplicatively to the signal before projection, producing $f_w(\\theta,\\phi) = w(\\theta)\\ f(\\theta,\\phi)$. The window acts only in colatitude. The window functions to consider are:\n- Rectangular window: $w(\\theta) = 1$.\n- Hann window in colatitude: with $x = \\theta/\\pi$, $w(\\theta) = \\tfrac{1}{2}\\big(1 - \\cos(2\\pi x)\\big)$.\n- Tukey window in colatitude with parameter $\\alpha\\in(0,1]$: with $x=\\theta/\\pi$,\n$$\nw(\\theta) = \\begin{cases}\n\\tfrac{1}{2}\\left[1 + \\cos\\left(\\pi\\left(\\tfrac{2x}{\\alpha} - 1\\right)\\right)\\right], & 0 \\le x < \\tfrac{\\alpha}{2},\\\\\n1, & \\tfrac{\\alpha}{2} \\le x \\le 1 - \\tfrac{\\alpha}{2},\\\\\n\\tfrac{1}{2}\\left[1 + \\cos\\left(\\pi\\left(\\tfrac{2(1-x)}{\\alpha} - 1\\right)\\right)\\right], & 1 - \\tfrac{\\alpha}{2} < x \\le 1.\n\\end{cases}\n$$\n\nFor each specified sampling grid and window, compute the discrete projection coefficients $c_{\\ell m}$ for the sideband modes $(\\ell,m)\\in\\{(2,1),(3,2),(4,4)\\}$ using angles measured in radians. Define the sideband power fraction for each mode as\n$$\nP_{\\ell m} = \\frac{|c_{\\ell m}|^2}{|c_{2,2}|^2},\n$$\nwhere both numerator and denominator are computed within the same sampling and windowing configuration. The denominator uses the $(\\ell,m)=(2,2)$ mode.\n\nYou must implement the spin-weighted spherical harmonics $\\ {}_sY_{\\ell m}(\\theta,\\phi)$ using the standard Wigner small-$d$ function construction and the azimuthal phase, and perform the discrete summations as specified above. All angles are in radians.\n\nTest Suite:\nUse the following set of parameter values $(N_\\theta, N_\\phi, \\text{window}, \\alpha)$:\n1. $(64, 128, \\text{rect}, 0.0)$\n2. $(8, 16, \\text{rect}, 0.0)$\n3. $(64, 128, \\text{hann\\_theta}, 0.0)$\n4. $(128, 256, \\text{tukey\\_theta}, 0.25)$\n\nFor each test case, compute and return the three sideband power fractions $P_{2,1}$, $P_{3,2}$, and $P_{4,4}$ in that order. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list should be flattened across test cases in order, yielding nine total entries for three test cases and twelve total entries for four test cases. For example, the final output format must be\n$$\n[ P_{2,1}^{(1)}, P_{3,2}^{(1)}, P_{4,4}^{(1)}, P_{2,1}^{(2)}, P_{3,2}^{(2)}, P_{4,4}^{(2)}, \\dots ].\n$$\nAll computed values must be floating point numbers. Angles must be handled in radians throughout. No physical units are involved in this computation. Ensure numerical stability and scientific realism by correctly implementing the spin-weighted spherical harmonics via their Wigner small-$d$ construction and by using the specified quadrature scheme.", "solution": "The user's problem requires the computation of sideband power fractions that arise from the numerical projection of a pure spin-weighted spherical harmonic signal onto a finite grid, under various windowing schemes. This is a standard problem in the analysis of gravitational wave signals from numerical relativity, where spectral leakage due to finite resolution and windowing can corrupt the extracted mode content. The problem is scientifically grounded, well-posed, and all its components are formally defined. Therefore, it is a valid problem.\n\nThe solution is implemented by following these principal steps:\n1.  **Decomposition of the Problem**: The core task is to compute the discrete approximation of the inner product integral $$c_{\\ell m} = \\int_{S^2} f_w(\\theta,\\phi)\\ {}_sY_{\\ell m}^*(\\theta,\\phi)\\ d\\Omega,$$ where $d\\Omega = \\sin\\theta\\ d\\theta\\ d\\phi$. The spin weight for gravitational wave strain is $s=-2$. The input signal is a pure mode, $f(\\theta,\\phi) = {}_{-2}Y_{2,2}(\\theta,\\phi)$, which is then multiplied by a colatitude-dependent window function $w(\\theta)$ to give $f_w(\\theta,\\phi) = w(\\theta)f(\\theta,\\phi)$.\n2.  **Numerical Quadrature**: The integral for $c_{\\ell m}$ is approximated using a rectangular quadrature rule on a uniform grid. The grid has $N_\\theta$ points in colatitude $\\theta$ and $N_\\phi$ points in azimuth $\\phi$. The grid points are $\\theta_i = (i+1/2)\\Delta\\theta$ for $i \\in \\{0, \\dots, N_\\theta-1\\}$ and $\\phi_j = j\\Delta\\phi$ for $j \\in \\{0, \\dots, N_\\phi-1\\}$, where $\\Delta\\theta = \\pi/N_\\theta$ and $\\Delta\\phi = 2\\pi/N_\\phi$. The discretized coefficient is\n    $$c_{\\ell m} \\approx \\sum_{i=0}^{N_\\theta-1}\\sum_{j=0}^{N_\\phi-1} f_w(\\theta_i,\\phi_j)\\ {}_{-2}Y_{\\ell m}^*(\\theta_i,\\phi_j)\\ \\sin\\theta_i\\ \\Delta\\theta\\ \\Delta\\phi.$$\n    The use of mid-point sampling for $\\theta$ avoids singularities at the poles ($\\theta=0,\\pi$).\n3.  **Spin-Weighted Spherical Harmonics Implementation**: A crucial component is the numerical evaluation of the spin-weighted spherical harmonics, ${}_sY_{\\ell m}(\\theta,\\phi)$. These are defined as\n    $${}_sY_{\\ell m}(\\theta,\\phi) = (-1)^s \\sqrt{\\frac{2\\ell+1}{4\\pi}} d^\\ell_{m,s}(\\theta) e^{im\\phi},$$\n    where $d^\\ell_{m,s}(\\theta)$ are the Wigner small-$d$ functions. To ensure correctness and numerical stability for the required modest values of $\\ell$, an implementation based on the Wigner-Clebsch-Gordan series (Wigner's formula) is chosen. The formula from Varshalovich, Moskalev, & Khersonskii is used for the $d^\\ell_{m',m}(\\beta)$ function, mapping $(m', m) \\to (m, s)$ for our use case:\n    $$d^\\ell_{m,s}(\\theta) = \\left[ (\\ell+m)!(\\ell-m)!(\\ell+s)!(\\ell-s)! \\right]^{1/2} \\sum_z \\frac{(-1)^z}{z!(m-s+z)!(\\ell-m-z)!(\\ell+s-z)!} (\\cos(\\theta/2))^{2\\ell+s-m-2z}(\\sin(\\theta/2))^{m-s+2z}.$$\n    The summation over $z$ includes all integer values for which the arguments of the factorials are non-negative. This can be expressed as a sum from $z_{min} = \\max(0, s-m)$ to $z_{max} = \\min(\\ell-m, \\ell+s)$. To handle potentially large numbers in the factorials, their logarithms are computed using `scipy.special.gammaln`, where $\\ln(n!) = \\text{gammaln}(n+1)$.\n4.  **Projection Kernel**: The projection requires the complex conjugate, ${}_{-2}Y_{\\ell m}^*(\\theta,\\phi)$. Given that the Wigner $d$-functions are real, we have\n    $${}_{-2}Y_{\\ell m}^*(\\theta, \\phi) = (-1)^{-2} \\sqrt{\\frac{2\\ell+1}{4\\pi}} d^\\ell_{m,-2}(\\theta) e^{-im\\phi} = \\sqrt{\\frac{2\\ell+1}{4\\pi}} d^\\ell_{m,-2}(\\theta) e^{-im\\phi}.$$\n    This is implemented by computing ${}_{-2}Y_{\\ell m}$ and then taking its complex conjugate.\n5.  **Window Functions**: The specified window functions (Rectangular, Hann, and Tukey) are implemented as functions of colatitude $\\theta$. The Tukey window is parameterized by $\\alpha$.\n6.  **Power Fraction Calculation**: For each test case, specified by $(N_\\theta, N_\\phi, \\text{window}, \\alpha)$, the process is as follows:\n    a. A $2$D grid of $(\\theta, \\phi)$ values is generated.\n    b. The input signal $f(\\theta,\\phi)$ and the projection kernels ${}_{-2}Y_{\\ell m}^*$ for the modes $(\\ell,m) \\in \\{(2,1),(3,2),(4,4),(2,2)\\}$ are evaluated on this grid.\n    c. The appropriate window function $w(\\theta)$ is applied to the input signal.\n    d. The discrete sums for the coefficients $c_{\\ell m}$ are computed.\n    e. The sideband power fractions are calculated as $P_{\\ell m} = |c_{\\ell m}|^2 / |c_{2,2}|^2$ for $(\\ell,m) \\in \\{(2,1),(3,2),(4,4)\\}$.\n7.  **Execution**: A main function iterates through the provided test suite, calls a subroutine to perform the calculations for each case, and aggregates the results into a single list for final output, formatted as specified.\n\nThe algorithmic design is thus a direct and robust implementation of the mathematical prescription in the problem statement, using standard, numerically stable techniques appropriate for the discipline.", "answer": "```python\nimport numpy as np\nfrom scipy.special import gammaln\n\ndef wigner_d(l, m1, m2, theta):\n    \"\"\"\n    Computes the Wigner small-d function d^l_{m1,m2}(theta) using the\n    summation formula from Varshalovich, Moskalev, & Khersonskii.\n    This implementation uses logarithms of factorials for numerical stability.\n    \"\"\"\n    # Wigner d-functions are defined for |m1| <= l and |m2| <= l.\n    if abs(m1) > l or abs(m2) > l:\n        return np.zeros_like(np.asarray(theta), dtype=float)\n\n    # Convert theta to a numpy array to handle scalar and array inputs uniformly.\n    theta = np.asarray(theta)\n    \n    # Summation limits for z\n    z_min = max(0, m2 - m1)\n    z_max = min(l - m1, l + m2)\n    \n    # Pre-compute the logarithm of the constant square-root factor.\n    log_sqrt_factor = 0.5 * (gammaln(l + m1 + 1) + gammaln(l - m1 + 1) +\n                             gammaln(l + m2 + 1) + gammaln(l - m2 + 1))\n    \n    # Initialize the result array.\n    d_val = np.zeros_like(theta, dtype=float)\n    \n    cos_half_theta = np.cos(theta / 2.0)\n    sin_half_theta = np.sin(theta / 2.0)\n    \n    for z in range(z_min, z_max + 1):\n        # Logarithm of the denominator in the summation term\n        log_denom_z = (gammaln(z + 1) +\n                       gammaln(m1 - m2 + z + 1) +\n                       gammaln(l - m1 - z + 1) +\n                       gammaln(l + m2 - z + 1))\n        \n        # Logarithm of the z-th term's coefficient\n        log_C_z = log_sqrt_factor - log_denom_z\n        C_z = np.exp(log_C_z)\n        \n        # Power exponents for cos and sin terms\n        pow_cos = 2 * l + m2 - m1 - 2 * z\n        pow_sin = m1 - m2 + 2 * z\n        \n        # The grid for theta avoids 0 and pi, so cos_half_theta and sin_half_theta are non-zero.\n        # This prevents issues with 0**negative_power.\n        term_z = C_z * (cos_half_theta**pow_cos) * (sin_half_theta**pow_sin)\n        \n        d_val += (-1)**z * term_z\n            \n    return d_val\n\ndef spin_weighted_Y(s, l, m, theta, phi):\n    \"\"\"\n    Computes the spin-weighted spherical harmonic sYlm(theta, phi).\n    \"\"\"\n    if abs(m) > l or abs(s) > l:\n        if isinstance(theta, np.ndarray):\n            return np.zeros_like(theta, dtype=complex)\n        else:\n            return 0.0 + 0.0j\n\n    # In sYlm, the d-function is d^l_{m,s}. So m1=m, m2=s.\n    d_func = wigner_d(l, m, s, theta)\n    norm = np.sqrt((2 * l + 1) / (4 * np.pi))\n    phase = np.exp(1j * m * phi)\n    \n    return (-1)**s * norm * d_func * phase\n\ndef get_window_function(name, alpha, N_theta):\n    \"\"\"\n    Generates the specified window function array.\n    \"\"\"\n    theta = (np.arange(N_theta) + 0.5) * np.pi / N_theta\n    if name == 'rect':\n        return np.ones(N_theta)\n    \n    x = theta / np.pi\n    if name == 'hann_theta':\n        return 0.5 * (1 - np.cos(2 * np.pi * x))\n    elif name == 'tukey_theta':\n        w = np.ones_like(x)\n        # First section of the Tukey window\n        mask1 = x < alpha / 2.0\n        w[mask1] = 0.5 * (1 + np.cos(np.pi * (2 * x[mask1] / alpha - 1)))\n        # Last section of the Tukey window\n        mask3 = x > 1 - alpha / 2.0\n        w[mask3] = 0.5 * (1 + np.cos(np.pi * (2 * (1 - x[mask3]) / alpha - 1)))\n        return w\n    else:\n        raise ValueError(f\"Unknown window: {name}\")\n\ndef calculate_power_fractions(N_theta, N_phi, window_name, alpha):\n    \"\"\"\n    Performs the full calculation for a single test case.\n    \"\"\"\n    s = -2 # Spin weight\n    \n    # 1. Set up the grid\n    delta_theta = np.pi / N_theta\n    delta_phi = 2 * np.pi / N_phi\n    \n    theta_pts = (np.arange(N_theta) + 0.5) * delta_theta\n    phi_pts = np.arange(N_phi) * delta_phi\n    \n    theta_mesh, phi_mesh = np.meshgrid(theta_pts, phi_pts, indexing='ij')\n\n    # 2. Define the input signal on the grid\n    # f(theta, phi) = -2_Y_2,2(theta, phi)\n    input_signal_grid = spin_weighted_Y(s, 2, 2, theta_mesh, phi_mesh)\n    \n    # 3. Apply the window function\n    window = get_window_function(window_name, alpha, N_theta)\n    # Window is 1D (theta-dependent), broadcast it to the 2D grid\n    windowed_signal_grid = window[:, np.newaxis] * input_signal_grid\n    \n    # 4. Compute projection coefficients\n    modes_to_calculate = [(2, 2), (2, 1), (3, 2), (4, 4)]\n    coeffs = {}\n    \n    d_omega = np.sin(theta_mesh) * delta_theta * delta_phi\n\n    for l_val, m_val in modes_to_calculate:\n        # Kernel is the complex conjugate of sYlm\n        kernel_grid = np.conj(spin_weighted_Y(s, l_val, m_val, theta_mesh, phi_mesh))\n        \n        integrand = windowed_signal_grid * kernel_grid\n        \n        c_lm = np.sum(integrand * d_omega)\n        coeffs[(l_val, m_val)] = c_lm\n\n    # 5. Calculate power fractions\n    c_22_sq = np.abs(coeffs[(2, 2)])**2\n    \n    if c_22_sq == 0:\n        # Avoid division by zero, though it's physically unlikely here.\n        P_21 = P_32 = P_44 = np.inf\n    else:\n        P_21 = np.abs(coeffs[(2, 1)])**2 / c_22_sq\n        P_32 = np.abs(coeffs[(3, 2)])**2 / c_22_sq\n        P_44 = np.abs(coeffs[(4, 4)])**2 / c_22_sq\n        \n    return [P_21, P_32, P_44]\n\ndef solve():\n    \"\"\"\n    Main solver function that iterates through test cases and prints the result.\n    \"\"\"\n    test_cases = [\n        (64, 128, 'rect', 0.0),\n        (8, 16, 'rect', 0.0),\n        (64, 128, 'hann_theta', 0.0),\n        (128, 256, 'tukey_theta', 0.25),\n    ]\n\n    results = []\n    for case in test_cases:\n        N_theta, N_phi, window_name, alpha = case\n        case_results = calculate_power_fractions(N_theta, N_phi, window_name, alpha)\n        results.extend(case_results)\n\n    # Format the final output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3471549"}, {"introduction": "After computing a physical quantity like a gravitational wave mode, a critical task in numerical science is to verify its accuracy. This practice introduces convergence testing, a cornerstone technique used to demonstrate that a numerical solution is approaching the true, continuum solution at a predictable rate as the grid resolution is increased. Using synthetic waveform data from three different resolutions, you will implement the full analysis pipeline to measure the convergence order of the waveform phase and use Richardson extrapolation to estimate the truncation error of the most accurate result [@problem_id:3513467].", "problem": "You are given three independent numerical relativity runs that produce the complex gravitational-wave strain mode $h_{22}(t)$ at three spatial grid resolutions $\\Delta$, $\\Delta/1.5$, and $\\Delta/2$. The task is to estimate the convergence order of the phase of $h_{22}$ using only these three runs and then use that estimate to compute a Richardson-extrapolated phase and an estimate of the discretization error at the finest resolution.\n\nFundamental base and core definitions to be used:\n- The gravitational-wave strain multipole $h_{\\ell m}(t)$ is a complex function $h_{\\ell m}(t) = A_{\\ell m}(t) e^{i \\phi_{\\ell m}(t)}$, where $A_{\\ell m}(t)$ is the amplitude and $\\phi_{\\ell m}(t)$ is the phase. For the quadrupole mode, set $\\ell=2$, $m=2$; the phase is $\\phi_{22}(t) = \\arg(h_{22}(t))$.\n- Finite-resolution numerical schemes that are consistent with a continuum limit yield, for a scalar diagnostic $Q$ at fixed physical time $t$, the model $Q_{\\Delta}(t) = Q^{\\star}(t) + C(t) \\Delta^{p}$, where $Q^{\\star}(t)$ is the continuum value, $C(t)$ is a resolution-independent coefficient, and $p$ is the formal convergence order of the scheme.\n- For three resolutions $\\Delta_{0}=\\Delta$, $\\Delta_{1}=\\Delta/1.5$, $\\Delta_{2}=\\Delta/2$, define $D_{01} = Q_{\\Delta_{0}} - Q_{\\Delta_{1}}$ and $D_{12} = Q_{\\Delta_{1}} - Q_{\\Delta_{2}}$. Under the single-power error model above, $D_{01} = C(\\Delta_{0}^{p}-\\Delta_{1}^{p})$ and $D_{12} = C(\\Delta_{1}^{p}-\\Delta_{2}^{p})$, which implies that $p$ satisfies the nonlinear scalar equation\n$$\n\\frac{D_{01}}{D_{12}} = \\frac{\\Delta_{0}^{p} - \\Delta_{1}^{p}}{\\Delta_{1}^{p} - \\Delta_{2}^{p}}.\n$$\nThis equation must be solved numerically for $p$ when refinement factors are not equal.\n- Once $p$ is estimated, the continuum value $Q^{\\star}$ can be obtained by eliminating $C$ and solving $Q^{\\star} = Q_{\\Delta_{0}} - C \\Delta_{0}^{p}$ with $C = D_{01}/(\\Delta_{0}^{p}-\\Delta_{1}^{p})$. The discretization error at the finest resolution is then $e_{\\Delta_{2}} = |Q_{\\Delta_{2}} - Q^{\\star}|$.\n\nTask requirements:\n- Implement a program that, for each test case below, constructs synthetic data for $h_{22}(t)$ at the three resolutions and at a single reference time $t_{\\mathrm{ref}}$, extracts the phase $\\phi_{22}$ from each resolution, estimates the convergence order $p$ by solving the nonlinear scalar equation above, computes the Richardson-extrapolated continuum phase $\\phi^{\\star}(t_{\\mathrm{ref}})$, and returns the discretization error at the finest resolution $\\Delta/2$ defined as $|\\phi_{\\Delta/2}(t_{\\mathrm{ref}}) - \\phi^{\\star}(t_{\\mathrm{ref}})|$.\n- Use the following physically motivated synthetic model for the continuum waveform and its resolution-dependent phase error at fixed time. Define a continuum phase and amplitude\n$$\n\\phi^{\\star}(t) = \\phi_{0} + \\omega_{0} t + \\beta t^{2}, \\quad A^{\\star}(t) = A_{0} \\left(1 + \\gamma t\\right),\n$$\nand construct the continuum strain\n$$\nh^{\\star}_{22}(t) = A^{\\star}(t) \\, e^{i \\phi^{\\star}(t)}.\n$$\nAssume the finite-resolution waveform has a phase error of the form\n$$\n\\delta \\phi(\\Delta, t) = \\alpha \\, \\sin(\\omega_{\\kappa} t) \\, \\Delta^{p_{\\mathrm{true}}},\n$$\nand define the finite-resolution complex strain at resolution $\\Delta$ by\n$$\nh_{22}(t; \\Delta) = A^{\\star}(t) \\, e^{i \\left[\\phi^{\\star}(t) + \\delta \\phi(\\Delta, t)\\right]}.\n$$\nAt the single evaluation time $t_{\\mathrm{ref}}$ of each test case, extract the finite-resolution phases $\\phi_{\\Delta}(t_{\\mathrm{ref}}) = \\arg(h_{22}(t_{\\mathrm{ref}}; \\Delta))$, $\\phi_{\\Delta/1.5}(t_{\\mathrm{ref}})$, and $\\phi_{\\Delta/2}(t_{\\mathrm{ref}})$ and treat these as the three $Q_{\\Delta}$ values in the convergence analysis above.\n- Angle unit: All phases and phase errors must be computed and reported in radians.\n- Physical units: Treat $t$ in seconds and $A^{\\star}$ as dimensionless scaling factors appropriate to gravitational-wave strain. Your program must report the discretization error in radians.\n- Numerical robustness: If both differences $D_{01}$ and $D_{12}$ have magnitude smaller than $10^{-12}$, return $p=0.0$ and $e_{\\Delta/2}=0.0$ for that test case.\n\nTest suite:\nFor each test case $k$, you are given $(\\Delta, \\phi_{0}, \\omega_{0}, \\beta, A_{0}, \\gamma, \\alpha, p_{\\mathrm{true}}, \\omega_{\\kappa}, t_{\\mathrm{ref}})$:\n\n- Test case $1$ (general \"happy path\"):\n  - $\\Delta = 0.8$\n  - $\\phi_{0} = 0.0$\n  - $\\omega_{0} = 0.5$\n  - $\\beta = 0.02$\n  - $A_{0} = 1\\times 10^{-21}$\n  - $\\gamma = 0.0$\n  - $\\alpha = 0.5$\n  - $p_{\\mathrm{true}} = 3.2$\n  - $\\omega_{\\kappa} = 0.3$\n  - $t_{\\mathrm{ref}} = 0.7$\n- Test case $2$ (near-cancellation edge case with very small phase error at the chosen time):\n  - $\\Delta = 0.4$\n  - $\\phi_{0} = 0.0$\n  - $\\omega_{0} = 0.1$\n  - $\\beta = 0.0005$\n  - $A_{0} = 8\\times 10^{-22}$\n  - $\\gamma = 0.0$\n  - $\\alpha = 0.3$\n  - $p_{\\mathrm{true}} = 4.5$\n  - $\\omega_{\\kappa} = 0.3$\n  - $t_{\\mathrm{ref}} = 0.03333333333333333$\n- Test case $3$ (lower-order method with larger phase error amplitude):\n  - $\\Delta = 0.9$\n  - $\\phi_{0} = 0.1$\n  - $\\omega_{0} = 0.3$\n  - $\\beta = 0.01$\n  - $A_{0} = 1.2\\times 10^{-21}$\n  - $\\gamma = 0.0$\n  - $\\alpha = 1.5$\n  - $p_{\\mathrm{true}} = 2.0$\n  - $\\omega_{\\kappa} = 0.3$\n  - $t_{\\mathrm{ref}} = 0.5$\n\nYour program must:\n- For each test case, compute the three finite-resolution phases at $t_{\\mathrm{ref}}$, estimate the convergence order $p$, perform Richardson extrapolation to estimate $\\phi^{\\star}(t_{\\mathrm{ref}})$, and compute the finest-level discretization error $e_{\\Delta/2}$ in radians.\n- Produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $[p_{1}, e_{1}, p_{2}, e_{2}, p_{3}, e_{3}]$, where $p_{k}$ and $e_{k}$ are the estimated convergence order and finest-resolution discretization error for test case $k$, respectively. All entries must be floating-point numbers in radians where applicable.", "solution": "The problem statement has been validated and is deemed sound. It is scientifically grounded in the principles of numerical analysis and computational astrophysics, specifically concerning the convergence testing of numerical solutions. The problem is well-posed, objective, and contains all necessary information to proceed with a unique, verifiable solution.\n\nThe task is to analyze the convergence of a synthetic gravitational wave phase, $\\phi_{22}(t)$, generated at three different spatial resolutions. The analysis involves estimating the convergence order, $p$, performing a Richardson extrapolation to find the continuum-limit phase, $\\phi^{\\star}$, and calculating the discretization error at the finest resolution.\n\nThe methodology is executed in four main steps for each test case provided.\n\n**1. Generation of Synthetic Phase Data**\n\nThe problem provides a model for a synthetic gravitational waveform at a reference time $t_{\\mathrm{ref}}$. The true, continuum phase $\\phi^{\\star}(t_{\\mathrm{ref}})$ is given by the quadratic model:\n$$\n\\phi^{\\star}(t_{\\mathrm{ref}}) = \\phi_{0} + \\omega_{0} t_{\\mathrm{ref}} + \\beta t_{\\mathrm{ref}}^{2}\n$$\nThe numerical error in the phase at a finite grid resolution $\\Delta$ is modeled as:\n$$\n\\delta \\phi(\\Delta, t_{\\mathrm{ref}}) = \\alpha \\, \\sin(\\omega_{\\kappa} t_{\\mathrm{ref}}) \\, \\Delta^{p_{\\mathrm{true}}}\n$$\nwhere $p_{\\mathrm{true}}$ is the known, true convergence order of the underlying (but here, synthetic) numerical method.\n\nThe full phase at a finite resolution $\\Delta$, denoted $\\phi_{\\Delta}(t_{\\mathrm{ref}})$, is the sum of the continuum value and the discretization error:\n$$\n\\phi_{\\Delta}(t_{\\mathrm{ref}}) = \\phi^{\\star}(t_{\\mathrm{ref}}) + \\delta \\phi(\\Delta, t_{\\mathrm{ref}})\n$$\nThis structure conforms to the general error model $Q_{\\Delta}(t) = Q^{\\star}(t) + C(t) \\Delta^{p}$, where the scalar diagnostic is the phase, $Q = \\phi_{22}$, the continuum value is $Q^\\star = \\phi^\\star$, the coefficient is $C(t_{\\mathrm{ref}}) = \\alpha \\sin(\\omega_{\\kappa} t_{\\mathrm{ref}})$, and the convergence order is $p = p_{\\mathrm{true}}$.\n\nFor each test case, we are given a coarsest resolution $\\Delta$. The analysis uses three resolutions:\n- Coarse: $\\Delta_0 = \\Delta$\n- Medium: $\\Delta_1 = \\Delta / 1.5$\n- Fine: $\\Delta_2 = \\Delta / 2$\n\nWe compute the phase values $\\phi_{\\Delta_0}(t_{\\mathrm{ref}})$, $\\phi_{\\Delta_1}(t_{\\mathrm{ref}})$, and $\\phi_{\\Delta_2}(t_{\\mathrm{ref}})$ using the formulas above. These three values serve as the input for the convergence analysis. For brevity, we will denote them $\\phi_0$, $\\phi_1$, and $\\phi_2$.\n\n**2. Estimation of the Convergence Order**\n\nThe convergence order $p$ is estimated using the three calculated phase values. We define the differences between consecutive resolutions:\n$$\nD_{01} = \\phi_0 - \\phi_1\n$$\n$$\nD_{12} = \\phi_1 - \\phi_2\n$$\nSubstituting the error model, we find:\n$$\nD_{01} = C(t_{\\mathrm{ref}}) (\\Delta_0^p - \\Delta_1^p)\n$$\n$$\nD_{12} = C(t_{\\mathrm{ref}}) (\\Delta_1^p - \\Delta_2^p)\n$$\nTaking the ratio of these differences eliminates the unknown coefficient $C(t_{\\mathrm{ref}})$:\n$$\n\\frac{D_{01}}{D_{12}} = \\frac{\\Delta_0^p - \\Delta_1^p}{\\Delta_1^p - \\Delta_2^p}\n$$\nThis is a nonlinear scalar equation for the unknown convergence order $p$. To solve for $p$, we define a function $f(p)$ whose root we must find:\n$$\nf(p) = \\frac{\\Delta_0^p - \\Delta_1^p}{\\Delta_1^p - \\Delta_2^p} - \\frac{D_{01}}{D_{12}} = 0\n$$\nThis equation is solved numerically using a standard root-finding algorithm, such as the Brent-Dekker method, which is robust and efficient for single-variable functions. A search interval for $p$, such as $[0.1, 10]$, is appropriate, as typical convergence orders in scientific computing fall within this range.\n\nA numerical robustness clause is specified: if the magnitudes of both differences are negligible, i.e., $|D_{01}| < 10^{-12}$ and $|D_{12}| < 10^{-12}$, the ratio $D_{01}/D_{12}$ is ill-defined. In this scenario, the numerical error is below the specified tolerance, so we set the estimated convergence order $p = 0.0$ and the corresponding error estimate to $0.0$.\n\n**3. Richardson Extrapolation of the Continuum Phase**\n\nOnce the convergence order $p$ has been estimated, we can compute an extrapolated value for the continuum phase, $\\phi^{\\star}_{\\mathrm{est}}$. The procedure, known as Richardson extrapolation, eliminates the leading-order error term. Using the coarse and medium resolution data, we first estimate the error coefficient $C(t_{\\mathrm{ref}})$:\n$$\nC_{\\mathrm{est}} = \\frac{D_{01}}{\\Delta_0^p - \\Delta_1^p}\n$$\nThen, we correct the coarse-resolution phase $\\phi_0$ by subtracting the estimated error term:\n$$\n\\phi^{\\star}_{\\mathrm{est}} = \\phi_0 - C_{\\mathrm{est}} \\Delta_0^p\n$$\nAn equivalent and often more numerically stable formulation is:\n$$\n\\phi^{\\star}_{\\mathrm{est}} = \\frac{\\phi_1 \\Delta_0^p - \\phi_0 \\Delta_1^p}{\\Delta_0^p - \\Delta_1^p}\n$$\nThis value $\\phi^{\\star}_{\\mathrm{est}}$ is a more accurate estimate of the true continuum phase than any of the finite-resolution values. For our synthetic data, if the estimated $p$ is identical to $p_{\\mathrm{true}}$, then $\\phi^{\\star}_{\\mathrm{est}}$ will be identical to $\\phi^{\\star}(t_{\\mathrm{ref}})$.\n\n**4. Estimation of the Discretization Error**\n\nThe final step is to compute the discretization error at the finest resolution, $\\Delta_2$. This error is defined as the absolute difference between the numerical value at that resolution and the extrapolated continuum value:\n$$\ne_{\\Delta_2} = |\\phi_2 - \\phi^{\\star}_{\\mathrm{est}}|\n$$\nThis quantity provides an estimate of the error inherent in the finest-resolution simulation data. The entire procedure is applied to each test case specified in the problem.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves the gravitational wave phase convergence problem for all test cases.\n    \"\"\"\n    # Test cases defined as tuples of:\n    # (Delta, phi0, omega0, beta, A0, gamma, alpha, p_true, omega_kappa, t_ref)\n    test_cases = [\n        (0.8, 0.0, 0.5, 0.02, 1e-21, 0.0, 0.5, 3.2, 0.3, 0.7),\n        (0.4, 0.0, 0.1, 0.0005, 8e-22, 0.0, 0.3, 4.5, 0.3, 0.03333333333333333),\n        (0.9, 0.1, 0.3, 0.01, 1.2e-21, 0.0, 1.5, 2.0, 0.3, 0.5)\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        Delta, phi0, omega0, beta, A0, gamma, alpha, p_true, omega_kappa, t_ref = case\n\n        # Define the three resolutions\n        res = np.array([Delta, Delta / 1.5, Delta / 2.0])\n        d0, d1, d2 = res[0], res[1], res[2]\n\n        # 1. Generation of Synthetic Phase Data\n        # Calculate the continuum phase at t_ref\n        phi_star = phi0 + omega0 * t_ref + beta * t_ref**2\n\n        # Calculate the phase error coefficient C(t)\n        c_t = alpha * np.sin(omega_kappa * t_ref)\n\n        # Calculate the phase at each resolution\n        # phi_delta = phi_star + C(t) * delta^p_true\n        phases = phi_star + c_t * (res**p_true)\n        phi_d0, phi_d1, phi_d2 = phases[0], phases[1], phases[2]\n\n        # 2. Estimation of the Convergence Order\n        # Compute differences\n        D01 = phi_d0 - phi_d1\n        D12 = phi_d1 - phi_d2\n\n        # Check for numerical robustness\n        if abs(D01) < 1e-12 and abs(D12) < 1e-12:\n            p_est = 0.0\n            e_d2 = 0.0\n            results.extend([p_est, e_d2])\n            continue\n        \n        # Define the function to find the root of for p\n        # ratio_diff = D01 / D12\n        # f(p) = (d0^p - d1^p) / (d1^p - d2^p) - ratio_diff = 0\n        \n        # Handle the case where D12 is zero or very small\n        if abs(D12) < 1e-15:\n            # This case implies very high or infinite convergence order, or cancellation.\n            # While not specified in the problem, a large p is a reasonable proxy.\n            # However, with synthetic data, this is unlikely unless D01 is also zero.\n            # Using the provided robustness check logic covers this.\n            # For this problem, this branch will not be taken.\n            p_est=10.0 # A default large value or error handling\n            \n        else:\n            ratio_diff = D01 / D12\n            def f(p):\n                # Using np.power for robust handling of floating point exponents\n                term1 = np.power(d0, p) - np.power(d1, p)\n                term2 = np.power(d1, p) - np.power(d2, p)\n                if abs(term2) < 1e-15:  # Avoid division by zero\n                    return np.inf\n                return term1/term2 - ratio_diff\n\n            try:\n                # Search for the root in a physically reasonable interval for p\n                p_est = brentq(f, a=0.1, b=10.0, xtol=1e-12, rtol=1e-12)\n            except ValueError:\n                # If brentq fails (e.g., no sign change), it means the model is not followed.\n                # For this problem's synthetic data, this should not happen.\n                p_est = np.nan # Or other error indicator\n\n        # 3. Richardson Extrapolation of the Continuum Phase\n        # phi_star_est = (phi_d1 * d0^p - phi_d0 * d1^p) / (d0^p - d1^p)\n        # The form from the problem statement is used for consistency.\n        C_est = D01 / (np.power(d0, p_est) - np.power(d1, p_est))\n        phi_star_est = phi_d0 - C_est * np.power(d0, p_est)\n\n        # 4. Estimation of the Discretization Error\n        e_d2 = abs(phi_d2 - phi_star_est)\n\n        results.extend([p_est, e_d2])\n\n    # Final print statement in the exact required format.\n    # The format required is a simple list of floats.\n    # Example for one result: [3.2, 0.00548...]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3513467"}, {"introduction": "Many numerical relativity codes compute the Newman-Penrose curvature scalar $\\Psi_4$, from which the gravitational wave strain, $h$, must be recovered via time integration. This process is notoriously sensitive to low-frequency numerical noise and gauge effects, which, upon integration, can produce unphysical secular drifts in the strain. This advanced exercise guides you through the derivation and implementation of a powerful, regularized inversion technique in the frequency domain that robustly recovers a stable strain signal from noisy $\\Psi_4$ data, a common challenge in modern gravitational wave modeling [@problem_id:3513534].", "problem": "Consider an asymptotically flat spacetime in which gravitational radiation is extracted using the Newmanâ€“Penrose scalar $\\Psi_4$, with the standard relation at future null infinity that the complex strain $h \\equiv h_+ - i h_\\times$ satisfies $\\Psi_4 = \\ddot{h}$, where a dot denotes a derivative with respect to time. In many numerical relativity simulations, finite-radius extraction and numerical artifacts introduce low-frequency contamination into $\\Psi_4$, causing secular drift when recovering $h$ by time-integration. To mitigate this, we pose the following regularized inversion problem: given a real-valued time series $\\Psi_4(t)$ sampled uniformly over a finite interval, recover a real-valued strain-like quantity $h(t)$ by minimizing the functional\n$$\n\\mathcal{J}[h] = \\int_0^T \\left(\\ddot{h}(t) - \\Psi_4(t)\\right)^2 \\, dt \\;+\\; \\lambda \\int_0^T \\left(\\dot{h}(t)\\right)^2 \\, dt,\n$$\nwhere $T$ is the total duration and $\\lambda \\ge 0$ is a regularization parameter with units of $\\mathrm{s}^{-2}$. Starting from first principles of the calculus of variations and the relation between $\\Psi_4$ and $h$, derive the necessary condition for a minimizer $h(t)$ and propose a computationally efficient algorithm to obtain $h(t)$ from a discrete time series $\\Psi_4(t_n)$ assuming periodic boundary conditions over $[0,T]$. Your algorithm should be applicable to any uniformly sampled input and should clearly explain how units are handled.\n\nConstruct a synthetic test signal that emulates a compact binary chirp strain and its corresponding $\\Psi_4$ with physically plausible units as follows. Define the true strain\n$$\nh_{\\mathrm{true}}(t) = A(t) \\sin\\big(\\phi(t)\\big),\n$$\nwith amplitude\n$$\nA(t) = A_0 \\left(1 + \\alpha \\frac{t}{T}\\right),\n$$\nand phase\n$$\n\\phi(t) = 2\\pi\\left(f_0 t + \\tfrac{1}{2}\\beta t^2\\right),\n$$\nwhere $A_0$, $\\alpha$, $f_0$, and $\\beta$ are constants. Compute the exact second derivative\n$$\n\\ddot{h}_{\\mathrm{true}}(t) = A''(t)\\sin\\big(\\phi(t)\\big) + 2 A'(t)\\phi'(t)\\cos\\big(\\phi(t)\\big) + A(t)\\phi''(t)\\cos\\big(\\phi(t)\\big) - A(t)\\big(\\phi'(t)\\big)^2\\sin\\big(\\phi(t)\\big),\n$$\nusing $A'(t)$, $A''(t)$, $\\phi'(t)$, and $\\phi''(t)$ implied by the definitions above. Contaminate the ideal $\\Psi_4(t) = \\ddot{h}_{\\mathrm{true}}(t)$ with a small constant offset and a low-frequency sinusoidal term representing gauge and extraction systematics, plus small white noise:\n$$\n\\Psi_4^{\\mathrm{data}}(t) = \\ddot{h}_{\\mathrm{true}}(t) + \\delta + \\varepsilon \\sin(2\\pi f_{\\mathrm{low}} t) + \\eta(t),\n$$\nwhere $\\delta$ and $\\varepsilon$ are constants, $f_{\\mathrm{low}}$ is a low frequency, and $\\eta(t)$ is zero-mean Gaussian noise. Use a fixed random seed to ensure reproducibility.\n\nImplement the regularized inversion by working in the frequency domain with a Fast Fourier Transform (FFT), carefully defining the angular frequency grid and handling the zero-frequency component consistently with the imposed periodic boundary conditions. Then, reconstruct $h(t)$ and quantify two diagnostics as functions of $\\lambda$:\n- A bias metric defined as the root-mean-square error (RMSE) between the reconstructed strain $h_{\\mathrm{rec}}(t)$ and $h_{\\mathrm{true}}(t)$,\n$$\n\\mathrm{RMSE}(\\lambda) = \\sqrt{\\frac{1}{N}\\sum_{n=0}^{N-1}\\left(h_{\\mathrm{rec}}(t_n) - h_{\\mathrm{true}}(t_n)\\right)^2},\n$$\nwhere $N$ is the number of time samples.\n- A residual drift metric defined as the best-fit linear slope $m$ (in units of strain per second) obtained by least-squares fitting of $h_{\\mathrm{rec}}(t)$ to $m t + b$ over $[0,T]$,\n$$\n(m, b) = \\arg\\min_{m,b} \\sum_{n=0}^{N-1} \\left(h_{\\mathrm{rec}}(t_n) - m t_n - b\\right)^2.\n$$\n\nNumerical setup and units:\n- Use total duration $T = $ $4$ $\\mathrm{s}$, uniform sampling interval $\\Delta t = $ $1/2048$ $\\mathrm{s}$, so $N = $ $8192$ samples.\n- Use $A_0 = $ $1\\times 10^{-21}$ (dimensionless strain), $\\alpha = $ $0.5$ (dimensionless), $f_0 = $ $30$ $\\mathrm{Hz}$, and $\\beta = $ $15$ $\\mathrm{Hz/s}$.\n- Use contamination parameters $\\delta = $ $1\\times 10^{-23}$ $\\mathrm{s}^{-2}$, $\\varepsilon = $ $5\\times 10^{-23}$ $\\mathrm{s}^{-2}$, and $f_{\\mathrm{low}} = $ $0.5$ $\\mathrm{Hz}$.\n- Use Gaussian noise $\\eta(t)$ with standard deviation $\\sigma = $ $1\\times 10^{-20}$ $\\mathrm{s}^{-2}$ and a fixed pseudorandom generator seed equal to $42$.\n\nTest suite:\n- Evaluate the reconstruction for $\\lambda$ values $\\lambda = $ $0$, $\\lambda = $ $1$, $\\lambda = $ $10$, and $\\lambda = $ $100$, all in $\\mathrm{s}^{-2}$.\n- For each $\\lambda$, compute $\\mathrm{RMSE}(\\lambda)$ (dimensionless strain) and the drift slope $m(\\lambda)$ (strain per second).\n\nOutput specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result must be a two-element list $[\\mathrm{RMSE}(\\lambda), m(\\lambda)]$, so the final output must look like $[[x_1,y_1],[x_2,y_2],[x_3,y_3],[x_4,y_4]]$, where each $x_i$ is a float in dimensionless strain and each $y_i$ is a float in strain per second.\n\nYour task:\n- Derive the necessary condition for the minimizer $h(t)$ starting from the given functional and explain how this leads to a frequency-domain solution under periodic boundary conditions.\n- Implement the algorithm to generate the synthetic signal, perform the regularized inversion using FFT with properly defined angular frequencies in $\\mathrm{rad/s}$, reconstruct $h(t)$ for the specified $\\lambda$ values, and compute the specified diagnostics.\n- Express the drift slope $m(\\lambda)$ in $\\mathrm{strain/s}$ and the RMSE in dimensionless strain. The final printed output must strictly follow the format described above, with all four test cases aggregated into a single line.", "solution": "The problem asks for the derivation and implementation of a regularized inversion method to recover a gravitational wave strain signal $h(t)$ from its noisy second time derivative, $\\Psi_4(t)$. The inversion is posed as a minimization problem for the functional:\n$$\n\\mathcal{J}[h] = \\int_0^T \\left(\\ddot{h}(t) - \\Psi_4(t)\\right)^2 \\, dt \\;+\\; \\lambda \\int_0^T \\left(\\dot{h}(t)\\right)^2 \\, dt\n$$\nThe first term enforces fidelity to the physical relation $\\ddot{h} = \\Psi_4$, while the second term is a Tikhonov regularization term that penalizes large values of the first derivative $\\dot{h}(t)$. This is particularly effective at suppressing low-frequency drift in the reconstructed $h(t)$, which arises from integrating low-frequency noise or offsets present in $\\Psi_4(t)$. The regularization parameter $\\lambda$ controls the trade-off between data fidelity and the suppression of such drift.\n\n### Step 1: Derivation of the Necessary Condition for a Minimizer\n\nTo find the function $h(t)$ that minimizes the functional $\\mathcal{J}[h]$, we employ the calculus of variations. The necessary condition for an extremum is that the first variation of the functional, $\\delta\\mathcal{J}$, must vanish for any arbitrary perturbation $\\delta h(t)$ that respects the boundary conditions. The integrand of the functional is a function of $t$, $h(t)$, and its derivatives, $L(t, h, \\dot{h}, \\ddot{h}) = (\\ddot{h} - \\Psi_4)^2 + \\lambda (\\dot{h})^2$. The general form of the Euler-Lagrange equation for a functional containing second derivatives is:\n$$\n\\frac{\\partial L}{\\partial h} - \\frac{d}{dt}\\left(\\frac{\\partial L}{\\partial \\dot{h}}\\right) + \\frac{d^2}{dt^2}\\left(\\frac{\\partial L}{\\partial \\ddot{h}}\\right) = 0\n$$\nWe compute the partial derivatives of $L$:\n- $\\frac{\\partial L}{\\partial h} = 0$\n- $\\frac{\\partial L}{\\partial \\dot{h}} = 2\\lambda\\dot{h}(t)$\n- $\\frac{\\partial L}{\\partial \\ddot{h}} = 2(\\ddot{h}(t) - \\Psi_4(t))$\n\nSubstituting these into the Euler-Lagrange equation yields:\n$$\n0 - \\frac{d}{dt}(2\\lambda\\dot{h}) + \\frac{d^2}{dt^2}(2(\\ddot{h} - \\Psi_4)) = 0\n$$\nAssuming $\\lambda$ is a constant, we simplify the equation:\n$$\n-\\lambda\\ddot{h} + \\ddddot{h} - \\ddot{\\Psi}_4 = 0\n$$\nRearranging gives a fourth-order linear ordinary differential equation for the optimal $h(t)$:\n$$\n\\frac{d^4 h}{dt^4} - \\lambda \\frac{d^2 h}{dt^2} = \\frac{d^2 \\Psi_4}{dt^2}\n$$\n\n### Step 2: Frequency-Domain Solution\n\nThis differential equation is readily solved in the frequency domain, especially given the assumption of periodic boundary conditions on the interval $[0, T]$. We can represent $h(t)$ and $\\Psi_4(t)$ by their Fourier series:\n$$\nh(t) = \\sum_{k=-\\infty}^{\\infty} \\tilde{h}_k e^{i\\omega_k t} \\quad , \\quad \\Psi_4(t) = \\sum_{k=-\\infty}^{\\infty} \\tilde{\\Psi}_{4,k} e^{i\\omega_k t}\n$$\nwhere $\\omega_k = 2\\pi k/T$ are the angular frequencies and $\\tilde{h}_k$, $\\tilde{\\Psi}_{4,k}$ are the complex Fourier coefficients. In the frequency domain, time differentiation $\\frac{d}{dt}$ corresponds to multiplication by $i\\omega_k$. Applying this to our differential equation, we transform it into an algebraic equation for each frequency mode $k$:\n$$\n(i\\omega_k)^4 \\tilde{h}_k - \\lambda (i\\omega_k)^2 \\tilde{h}_k = (i\\omega_k)^2 \\tilde{\\Psi}_{4,k}\n$$\n$$\n\\omega_k^4 \\tilde{h}_k + \\lambda \\omega_k^2 \\tilde{h}_k = -\\omega_k^2 \\tilde{\\Psi}_{4,k}\n$$\n$$\n\\omega_k^2 (\\omega_k^2 + \\lambda) \\tilde{h}_k = -\\omega_k^2 \\tilde{\\Psi}_{4,k}\n$$\n\nWe must consider two cases for solving for $\\tilde{h}_k$:\n1.  **Non-zero frequency ($\\omega_k \\neq 0$):** We can divide by $\\omega_k^2$:\n    $$\n    (\\omega_k^2 + \\lambda) \\tilde{h}_k = -\\tilde{\\Psi}_{4,k} \\implies \\tilde{h}_k = \\frac{-\\tilde{\\Psi}_{4,k}}{\\omega_k^2 + \\lambda}\n    $$\n    This is the frequency-domain filter. In the absence of regularization ($\\lambda=0$), this reduces to $\\tilde{h}_k = -\\tilde{\\Psi}_{4,k}/\\omega_k^2$, which is the direct frequency-domain equivalent of double integration. The regularization term $\\lambda$ prevents the denominator from becoming very small at low frequencies, thus suppressing the amplification of low-frequency noise.\n\n2.  **Zero frequency ($\\omega_k = 0$, the DC component):** The equation becomes $0 = 0$. This means $\\tilde{h}_0$ (the mean value of $h(t)$) is not constrained by the minimization problem. This is physically expected, as the gravitational wave strain is a measure of spacetime distortion and is only defined up to an arbitrary constant offset (a gauge freedom). To obtain a unique solution, we must impose an additional constraint. A common and physically sensible choice is to require the reconstructed strain to have zero mean, which corresponds to setting $\\tilde{h}_0 = 0$.\n\n### Step 3: Algorithm for Discrete Time Series\n\nFor a discrete time series $\\Psi_{4,n} = \\Psi_4(t_n)$ sampled with interval $\\Delta t$ for $N$ points, the algorithm proceeds as follows:\n\n1.  **Compute FFT:** Calculate the Discrete Fourier Transform (DFT) of the input data $\\Psi_{4,n}$ using a Fast Fourier Transform (FFT) algorithm:\n    $$\n    \\tilde{\\Psi}_{4,k} = \\text{FFT}(\\Psi_{4,n})\n    $$\n2.  **Define Frequencies:** Construct the corresponding discrete angular frequency grid $\\omega_k$. For a sampling interval $\\Delta t$ and $N$ points, the frequencies are $f_k = k/(N\\Delta t)$, and the angular frequencies are $\\omega_k = 2\\pi f_k$. Most FFT libraries provide a helper function (like `numpy.fft.fftfreq`) for this.\n3.  **Apply Filter:** Construct the Fourier coefficients of the reconstructed strain, $\\tilde{h}_k$, by applying the derived filter:\n    $$\n    \\tilde{h}_k = \n    \\begin{cases}\n      0 & \\text{if } k=0 \\text{ (i.e., } \\omega_k=0) \\\\\n      \\frac{-\\tilde{\\Psi}_{4,k}}{\\omega_k^2 + \\lambda} & \\text{if } k \\neq 0 \\text{ (i.e., } \\omega_k \\neq 0)\n    \\end{cases}\n    $$\n4.  **Compute Inverse FFT:** Transform the result back to the time domain using an inverse FFT to obtain the reconstructed strain $h_{\\mathrm{rec}}(t_n)$:\n    $$\n    h_{\\mathrm{rec},n} = \\text{IFFT}(\\tilde{h}_k)\n    $$\n    Since the input data is real, the reconstructed strain should also be real, so we take the real part of the IFFT result.\n\n### Step 4: Unit Handling and Diagnostics\n\nThe physical units are handled consistently. Given that $h$ is dimensionless and time is in seconds ($\\mathrm{s}$), $\\ddot{h}$ and $\\Psi_4$ have units of $\\mathrm{s}^{-2}$. The parameter $\\lambda$ has units of $\\mathrm{s}^{-2}$ to ensure dimensional consistency in the functional. In the frequency domain, $\\omega_k$ has units of $\\mathrm{rad/s}$ (or simply $\\mathrm{s}^{-1}$), so $\\omega_k^2 + \\lambda$ is also in $\\mathrm{s}^{-2}$. The filter thus has units of $\\mathrm{s}^2$, which correctly transforms a quantity in $\\mathrm{s}^{-2}$ (like $\\Psi_4$) to a dimensionless one (like $h$).\n\nThe diagnostics are computed on the resulting time series $h_{\\mathrm{rec}}(t_n)$. The RMSE provides a measure of the total error against the true signal, while the drift slope $m$, obtained from a linear least-squares fit, quantifies the residual linear drift that the regularization aims to suppress. The units of $m$ will be strain/second, or $\\mathrm{s}^{-1}$.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements a regularized inversion to recover a gravitational wave\n    strain signal from its noisy second derivative, following the problem statement.\n    \"\"\"\n    # Numerical setup and units\n    T = 4.0  # s\n    dt = 1/2048.0  # s\n    N = int(T / dt)  # Number of samples, 8192\n    \n    # Synthetic signal parameters\n    A0 = 1.0e-21  # dimensionless strain\n    alpha = 0.5  # dimensionless\n    f0 = 30.0  # Hz\n    beta = 15.0  # Hz/s\n    \n    # Contamination parameters\n    delta = 1.0e-23  # s^-2\n    epsilon = 5.0e-23  # s^-2\n    f_low = 0.5  # Hz\n    sigma = 1.0e-20  # s^-2\n    seed = 42\n    \n    # Test suite regularization parameters\n    lambdas = [0.0, 1.0, 10.0, 100.0]  # s^-2\n\n    # --- 1. Generate Synthetic Signal ---\n    t = np.arange(N) * dt\n\n    # True strain h_true(t)\n    A = A0 * (1.0 + alpha * t / T)\n    phi = 2.0 * np.pi * (f0 * t + 0.5 * beta * t**2)\n    h_true = A * np.sin(phi)\n\n    # True Psi_4 = ddot(h_true)\n    A_p = A0 * alpha / T  # A'(t), constant\n    A_pp = 0.0  # A''(t)\n    phi_p = 2.0 * np.pi * (f0 + beta * t)  # phi'(t)\n    phi_pp = 2.0 * np.pi * beta  # phi''(t), constant\n\n    psi4_true = (A_pp * np.sin(phi) +\n                 2.0 * A_p * phi_p * np.cos(phi) +\n                 A * phi_pp * np.cos(phi) -\n                 A * (phi_p**2) * np.sin(phi))\n\n    # Contaminated data Psi_4^data(t)\n    np.random.seed(seed)\n    eta = np.random.normal(loc=0.0, scale=sigma, size=N)\n    psi4_data = (psi4_true + delta +\n                 epsilon * np.sin(2.0 * np.pi * f_low * t) +\n                 eta)\n\n    # --- 2. Perform Regularized Inversion ---\n    \n    # FFT setup\n    freqs = np.fft.fftfreq(N, dt)\n    omegas = 2.0 * np.pi * freqs\n    psi4_fft = np.fft.fft(psi4_data)\n    \n    results = []\n    \n    for lmbda in lambdas:\n        # Construct the frequency-domain filter.\n        # The filter is zero at zero-frequency to enforce mean(h_rec)=0.\n        # This handles the unconstrained nature of the DC component.\n        h_fft = np.zeros_like(psi4_fft, dtype=complex)\n        \n        # Apply filter only to non-zero frequencies\n        nonzero_indices = np.where(omegas != 0)\n        omegas_nz = omegas[nonzero_indices]\n        \n        filter_vals = -1.0 / (omegas_nz**2 + lmbda)\n        h_fft[nonzero_indices] = psi4_fft[nonzero_indices] * filter_vals\n        \n        # Transform back to time domain\n        h_rec = np.fft.ifft(h_fft).real\n\n        # --- 3. Compute Diagnostics ---\n        \n        # RMSE (dimensionless strain)\n        rmse = np.sqrt(np.mean((h_rec - h_true)**2))\n        \n        # Drift slope m (strain per second)\n        # np.polyfit performs a least-squares fit and returns [slope, intercept]\n        m, b = np.polyfit(t, h_rec, 1)\n        \n        results.append([rmse, m])\n\n    # Final print statement in the exact required format\n    # The default string representation of a list of lists matches the spec.\n    print(f\"{results}\")\n\nsolve()\n```", "id": "3513534"}]}