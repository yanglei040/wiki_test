{"hands_on_practices": [{"introduction": "The interaction of radiation with gas involves processes like photoionization and recombination that can occur on vastly different timescales. This disparity makes the governing ordinary differential equations \"stiff,\" posing a major challenge for numerical integration. This practice provides a foundational exercise in confronting stiffness by implementing and comparing the stability, accuracy, and cost of a simple explicit method versus a robust implicit method for a single-cell ionization model [@problem_id:3507618].", "problem": "Consider the evolution of the hydrogen ionization fraction $x(t) \\in [0,1]$ in a single, spatially homogeneous control volume representative of an intergalactic medium cell during cosmic reionization. Assume constant hydrogen number density $n_{\\mathrm{H}}$ and a constant photoionization rate per hydrogen atom $\\Gamma$ due to an external radiation field. Neglect collisional ionization and adopt Case B recombination at fixed temperature with coefficient $\\alpha_{\\mathrm{B}}$. The governing Ordinary Differential Equation (ODE) is\n$$\n\\frac{dx}{dt} = (1 - x)\\,\\Gamma - \\alpha_{\\mathrm{B}}\\,n_{\\mathrm{H}}\\,x^2,\n$$\nwhich arises from balancing photoionizations with radiative recombinations. Define the recombination timescale\n$$\nt_{\\mathrm{rec}} = \\frac{1}{\\alpha_{\\mathrm{B}}\\,n_{\\mathrm{H}}},\n$$\nand let $k \\equiv \\alpha_{\\mathrm{B}}\\,n_{\\mathrm{H}}$.\n\nTask A (derivation): Starting from the ODE, linearize the dynamics around the stable equilibrium $x_{\\infty}$ (the positive root of $k\\,x^2 + \\Gamma\\,x - \\Gamma = 0$), and analyze the Forward Euler explicit discretization. Derive a sufficient timestep condition, expressible in terms of a chosen dimensionless parameter $0 < \\epsilon < 1$ and the recombination timescale $t_{\\mathrm{rec}}$, that ensures the explicit update does not produce oscillatory approach to $x_{\\infty}$ and thus prevents step-to-step overshoot in the ionization fraction. Your derivation should use only the Jacobian of the right-hand side evaluated at $x_{\\infty}$ and the Forward Euler stability behavior for a linear test equation with a negative eigenvalue. Interpret the physical meaning of the criterion in terms of stiffness governed by recombination.\n\nTask B (algorithmic comparison): Implement two time integrators for the ODE over a finite horizon $T$ starting from $x(0) = x_0$:\n- An explicit Forward Euler method,\n$$\nx^{n+1} = x^n + \\Delta t\\left[(1 - x^n)\\,\\Gamma - k\\,(x^n)^2\\right].\n$$\n- An implicit Backward Euler method,\n$$\nx^{n+1} = x^n + \\Delta t\\left[(1 - x^{n+1})\\,\\Gamma - k\\,(x^{n+1})^2\\right],\n$$\nwhich reduces to a quadratic equation for $x^{n+1}$ at each step; select the physically admissible root in $[0,1]$.\n\nFor reference accuracy, use the exact solution of the Riccati equation with constant coefficients. Let $x_1$ and $x_2$ be the two steady-state roots of $k\\,x^2 + \\Gamma\\,x - \\Gamma = 0$ (with $x_1 > 0$ and $x_2 < 0$), and define $\\lambda = \\sqrt{\\Gamma^2 + 4\\,\\Gamma\\,k} = k\\,(x_1 - x_2)$. For an initial condition $x(0) = x_0$, the exact solution is\n$$\nx(t) = \\frac{x_1 - C\\,e^{-\\lambda t}\\,x_2}{1 - C\\,e^{-\\lambda t}}, \\quad C = \\frac{x_0 - x_1}{x_0 - x_2}.\n$$\n\nCost model: Count the explicit method cost as $w_{\\mathrm{exp}} = 1$ per step and the implicit method cost as $w_{\\mathrm{imp}} = 4$ per step, reflecting the additional algebraic solve work. The total cost is the number of steps times the corresponding weight. If the final step would overshoot $T$ with a fixed $\\Delta t$, shorten only the last step so the sum of steps equals exactly $T$.\n\nOvershoot metric: For the explicit method, record the maximum overshoot above the physical bound $x \\le 1$ encountered during the integration,\n$$\n\\mathrm{overshoot}_{\\max} = \\max_{n}\\,\\max\\left(0, x^n - 1\\right).\n$$\n\nAccuracy metric: Report the final-time absolute errors for both integrators,\n$$\nE_{\\mathrm{exp}} = \\left|x_{\\mathrm{exp}}(T) - x_{\\mathrm{exact}}(T)\\right|,\\quad\nE_{\\mathrm{imp}} = \\left|x_{\\mathrm{imp}}(T) - x_{\\mathrm{exact}}(T)\\right|.\n$$\n\nUnits: Use $n_{\\mathrm{H}}$ in $\\mathrm{cm}^{-3}$, $\\alpha_{\\mathrm{B}}$ in $\\mathrm{cm}^3\\,\\mathrm{s}^{-1}$, $\\Gamma$ in $\\mathrm{s}^{-1}$, and all times, including $t_{\\mathrm{rec}}$, $T$, and $\\Delta t$, in $\\mathrm{s}$. The initial fraction $x_0$ and overshoot are dimensionless.\n\nTest suite: Your program must evaluate the following five scientifically plausible parameter sets, each denoted by a tuple $(\\alpha_{\\mathrm{B}}, n_{\\mathrm{H}}, \\Gamma, x_0, \\epsilon, T_{\\mathrm{factor}}, \\Delta t_{\\mathrm{factor}})$, where $T = T_{\\mathrm{factor}}\\,t_{\\mathrm{rec}}$ and $\\Delta t = \\Delta t_{\\mathrm{factor}}\\,\\epsilon\\,t_{\\mathrm{rec}}$:\n- Case $1$: $(2.6\\times10^{-13}, 1.0\\times10^{-2}, 1.0\\times10^{-15}, 0.0, 0.2, 2.0, 0.25)$, a \"happy path\" explicit timestep well within the criterion.\n- Case $2$: $(2.6\\times10^{-13}, 1.0\\times10^{-2}, 1.0\\times10^{-15}, 0.0, 0.2, 2.0, 0.95)$, a boundary-adjacent explicit timestep just below the safety margin.\n- Case $3$: $(2.6\\times10^{-13}, 1.0\\times10^{-2}, 1.0\\times10^{-15}, 0.0, 0.2, 2.0, 1.2)$, a supercritical explicit timestep intended to trigger overshoot or oscillatory behavior.\n- Case $4$: $(2.6\\times10^{-13}, 1.0\\times10^{-1}, 2.0\\times10^{-14}, 0.0, 0.1, 1.0, 0.5)$, a stiffer density with explicit timestep safely constrained.\n- Case $5$: $(2.6\\times10^{-13}, 1.0\\times10^{-3}, 1.0\\times10^{-16}, 0.0, 0.3, 3.0, 1.1)$, a low density case with an above-criterion explicit timestep.\n\nFor each case, also compute the boolean criterion check encoded as an integer,\n$$\n\\mathrm{pass} = \\begin{cases}\n1 & \\text{if }\\Delta t < \\epsilon\\,t_{\\mathrm{rec}},\\\\\n0 & \\text{otherwise.}\n\\end{cases}\n$$\n\nFinal output format: Your program should produce a single line of output containing all case results aggregated into a list of lists. For each case, return a list with the six entries\n$$\n[\\mathrm{pass},\\ \\mathrm{overshoot}_{\\max},\\ E_{\\mathrm{exp}},\\ E_{\\mathrm{imp}},\\ \\mathrm{cost}_{\\mathrm{exp}},\\ \\mathrm{cost}_{\\mathrm{imp}}],\n$$\nin that order. The final line must be\n$$\n[\\,[\\cdots],\\,[\\cdots],\\,[\\cdots],\\,[\\cdots],\\,[\\cdots]\\,].\n$$\nAll numerical entries must be of type boolean, integer, float, or lists thereof. The boolean must be encoded as $0$ or $1$ (integers).", "solution": "The problem is assessed to be valid. It is scientifically grounded in the established theory of photoionization and recombination, presents a well-posed ordinary differential equation with a known analytical solution, and defines a clear, objective set of computational tasks and metrics. The parameters provided are stated to be scientifically plausible for environments relevant to cosmic reionization.\n\n### Task A: Derivation of Timestep Condition\n\nThe evolution of the ionization fraction $x(t)$ is governed by the ordinary differential equation (ODE):\n$$\n\\frac{dx}{dt} = f(x) = (1 - x)\\Gamma - kx^2\n$$\nwhere $\\Gamma$ is the photoionization rate and $k = \\alpha_{\\mathrm{B}}n_{\\mathrm{H}}$ is the recombination rate coefficient scaled by the hydrogen number density.\n\nAn equilibrium state $x_{\\infty}$ is reached when $\\frac{dx}{dt} = 0$, which requires solving the quadratic equation:\n$$\nk x_{\\infty}^2 + \\Gamma x_{\\infty} - \\Gamma = 0\n$$\nThe problem specifies that we are interested in the stable equilibrium, which corresponds to the unique positive root of this equation, as can be verified by analyzing the system's dynamics.\n\nTo analyze the behavior of a numerical method near this equilibrium, we linearize the ODE around $x = x_{\\infty}$. Let $x(t) = x_{\\infty} + \\delta x(t)$, where $\\delta x$ is a small perturbation. The dynamics of the perturbation are approximated by:\n$$\n\\frac{d(\\delta x)}{dt} \\approx J(x_{\\infty}) \\cdot \\delta x\n$$\nHere, $J(x)$ is the Jacobian of the right-hand side, $f(x)$.\n$$\nJ(x) = \\frac{df}{dx} = \\frac{d}{dx} \\left( \\Gamma - \\Gamma x - kx^2 \\right) = -\\Gamma - 2kx\n$$\nEvaluating the Jacobian at the equilibrium point $x_{\\infty}$ gives the eigenvalue $\\lambda_{\\text{sys}}$ of the linearized system:\n$$\n\\lambda_{\\text{sys}} = J(x_{\\infty}) = -\\Gamma - 2kx_{\\infty}\n$$\nSince $\\Gamma > 0$, $k > 0$, and $x_{\\infty} > 0$, this eigenvalue is always negative, confirming that $x_{\\infty}$ is a stable fixed point.\n\nThe Forward Euler method applied to the linearized test equation $\\frac{dy}{dt} = \\lambda_{\\text{sys}} y$ is given by:\n$$\ny^{n+1} = y^n + \\Delta t (\\lambda_{\\text{sys}} y^n) = (1 + \\Delta t \\lambda_{\\text{sys}}) y^n\n$$\nFor the numerical solution to converge to the equilibrium without oscillations, the amplification factor $(1 + \\Delta t \\lambda_{\\text{sys}})$ must be non-negative. That is:\n$$\n1 + \\Delta t \\lambda_{\\text{sys}} \\ge 0\n$$\nSubstituting the expressions for $\\lambda_{\\text{sys}}$ and solving for the timestep $\\Delta t$:\n$$\n1 + \\Delta t (-\\Gamma - 2kx_{\\infty}) \\ge 0 \\implies 1 \\ge \\Delta t (\\Gamma + 2kx_{\\infty}) \\implies \\Delta t \\le \\frac{1}{\\Gamma + 2kx_{\\infty}}\n$$\nThis is the rigorous condition on the timestep $\\Delta t$ to prevent numerical oscillations in the vicinity of the equilibrium point $x_{\\infty}$. The quantity $\\tau_{\\text{relax}} = (\\Gamma + 2kx_{\\infty})^{-1}$ is the characteristic timescale for the system to relax to equilibrium.\n\nThe problem asks to interpret a simplified, sufficient condition of the form $\\Delta t  \\epsilon t_{\\mathrm{rec}}$, where $t_{\\mathrm{rec}} = 1/k$. This form is physically motivated. The term $kx^2$ represents recombination, a process whose characteristic timescale is approximately $x / (kx^2) = 1/(kx)$. For a highly ionized medium ($x \\approx 1$), this timescale is simply $1/k = t_{\\mathrm{rec}}$. In many astrophysical scenarios, particularly in denser regions of the intergalactic medium, recombination can be the fastest process, making the system of equations \"stiff\". For an explicit time integration scheme like Forward Euler to remain stable and accurate when applied to a stiff system, its timestep must be limited by the shortest timescale present. Therefore, it is a common and robust practice to constrain the timestep to be a fraction of the recombination time:\n$$\n\\Delta t  C \\cdot t_{\\mathrm{rec}}\n$$\nwhere $C$ is a dimensionless safety factor, here denoted by $\\epsilon$ ($0  \\epsilon  1$). While the formally derived condition depends on the specific state $x_{\\infty}$ and on $\\Gamma$, the criterion $\\Delta t  \\epsilon t_{\\mathrm{rec}}$ provides a practical, conservative upper bound that ensures numerical stability by resolving the timescale of the process that often governs the system's stiffness.\n\n### Task B: Algorithmic Design\n\nThe implementation compares the Forward Euler (explicit) and Backward Euler (implicit) methods against the exact analytical solution for several test cases.\n\n**1. Preliminaries:**\nFor each test case, we first compute the derived physical parameters from the input tuple $(\\alpha_{\\mathrm{B}}, n_{\\mathrm{H}}, \\Gamma, x_0, \\epsilon, T_{\\mathrm{factor}}, \\Delta t_{\\mathrm{factor}})$.\n- Recombination rate constant: $k = \\alpha_{\\mathrm{B}} n_{\\mathrm{H}}$\n- Recombination timescale: $t_{\\mathrm{rec}} = 1/k$\n- Total integration time: $T = T_{\\mathrm{factor}} t_{\\mathrm{rec}}$\n- Timestep for both methods: $\\Delta t = \\Delta t_{\\mathrm{factor}} \\epsilon t_{\\mathrm{rec}}$\n- The timestep criterion check is evaluated: $\\mathrm{pass} = 1$ if $\\Delta t_{\\mathrm{factor}}  1$, and $0$ otherwise, since this is equivalent to $\\Delta t  \\epsilon t_{\\mathrm{rec}}$.\n\n**2. Exact Solution:**\nThe exact solution at the final time $T$ is computed for reference. This requires the roots of $k x^2 + \\Gamma x - \\Gamma = 0$:\n$$\nx_{1,2} = \\frac{-\\Gamma \\pm \\sqrt{\\Gamma^2 + 4\\Gamma k}}{2k}\n$$\nWe identify the positive root $x_1 = x_{\\infty}$ and the negative root $x_2$. We also compute $\\lambda = \\sqrt{\\Gamma^2 + 4\\Gamma k}$ (which is equal to $k(x_1-x_2)$) and the integration constant $C = (x_0 - x_1) / (x_0 - x_2)$. The exact solution at time $T$ is then:\n$$\nx_{\\text{exact}}(T) = \\frac{x_1 - C e^{-\\lambda T} x_2}{1 - C e^{-\\lambda T}}\n$$\n\n**3. Time Integration Loop:**\nFor both numerical methods, the total number of steps is $N = \\lceil T / \\Delta t \\rceil$. The integration proceeds for $N-1$ steps of size $\\Delta t$, followed by a final, smaller step of size $\\Delta t_{\\text{final}} = T - (N-1)\\Delta t$ to land exactly at $T$.\n\n**4. Forward Euler Method:**\nStarting with $x_{\\mathrm{exp}}^0 = x_0$, we iterate:\n$$\nx_{\\mathrm{exp}}^{n+1} = x_{\\mathrm{exp}}^n + \\Delta t_n \\left[ (1 - x_{\\mathrm{exp}}^n)\\Gamma - k(x_{\\mathrm{exp}}^n)^2 \\right]\n$$\nwhere $\\Delta t_n$ is the current step size. During this process, we track the maximum overshoot above the physical limit $x=1$: $\\mathrm{overshoot}_{\\max} = \\max_{n} \\max(0, x_{\\mathrm{exp}}^n - 1)$. The final error is $E_{\\mathrm{exp}} = |x_{\\mathrm{exp}}(T) - x_{\\text{exact}}(T)|$ and the cost is $\\mathrm{cost}_{\\mathrm{exp}} = N \\cdot w_{\\mathrm{exp}} = N$.\n\n**5. Backward Euler Method:**\nStarting with $x_{\\mathrm{imp}}^0 = x_0$, each step requires solving for $x^{n+1}$ from the implicit equation:\n$$\nx^{n+1} = x^n + \\Delta t_n \\left[ (1 - x^{n+1})\\Gamma - k(x^{n+1})^2 \\right]\n$$\nThis is rearranged into a standard quadratic form $ay^2 + by + c = 0$ for $y = x^{n+1}$:\n$$\n(\\Delta t_n k) y^2 + (1 + \\Delta t_n \\Gamma) y - (x^n + \\Delta t_n \\Gamma) = 0\n$$\nThe coefficients are $a = \\Delta t_n k$, $b = 1 + \\Delta t_n \\Gamma$, and $c = -(x^n + \\Delta t_n \\Gamma)$. Since $ac  0$ (for physical inputs), the quadratic equation has one positive and one negative real root. We choose the physically admissible positive root:\n$$\nx_{\\mathrm{imp}}^{n+1} = \\frac{-b + \\sqrt{b^2 - 4ac}}{2a}\n$$\nThe final error is $E_{\\mathrm{imp}} = |x_{\\mathrm{imp}}(T) - x_{\\text{exact}}(T)|$ and the cost is $\\mathrm{cost}_{\\mathrm{imp}} = N \\cdot w_{\\mathrm{imp}} = 4N$.\n\n**6. Output Aggregation:**\nFor each test case, the six required metrics $[\\mathrm{pass}, \\mathrm{overshoot}_{\\max}, E_{\\mathrm{exp}}, E_{\\mathrm{imp}}, \\mathrm{cost}_{\\mathrm{exp}}, \\mathrm{cost}_{\\mathrm{imp}}]$ are collected into a list. The final output is a list containing these five results lists.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the ionization ODE problem for a suite of test cases, comparing\n    Forward Euler and Backward Euler methods against an exact solution.\n    \"\"\"\n    # Test suite: (alpha_B, n_H, Gamma, x0, epsilon, T_factor, dt_factor)\n    test_cases = [\n        # Case 1: \"happy path\" explicit timestep\n        (2.6e-13, 1.0e-2, 1.0e-15, 0.0, 0.2, 2.0, 0.25),\n        # Case 2: boundary-adjacent explicit timestep\n        (2.6e-13, 1.0e-2, 1.0e-15, 0.0, 0.2, 2.0, 0.95),\n        # Case 3: supercritical explicit timestep\n        (2.6e-13, 1.0e-2, 1.0e-15, 0.0, 0.2, 2.0, 1.2),\n        # Case 4: stiffer density, constrained timestep\n        (2.6e-13, 1.0e-1, 2.0e-14, 0.0, 0.1, 1.0, 0.5),\n        # Case 5: low density, supercritical timestep\n        (2.6e-13, 1.0e-3, 1.0e-16, 0.0, 0.3, 3.0, 1.1),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        alpha_B, n_H, Gamma, x0, epsilon, T_factor, dt_factor = case\n\n        # 1. Calculate derived parameters\n        k = alpha_B * n_H\n        t_rec = 1.0 / k\n        T = T_factor * t_rec\n        dt = dt_factor * epsilon * t_rec\n\n        # 2. Perform boolean criterion check\n        # The condition dt  epsilon * t_rec is equivalent to dt_factor  1\n        passes_criterion = 1 if dt_factor  1.0 else 0\n\n        # 3. Compute exact solution at time T\n        # Roots of k*x^2 + Gamma*x - Gamma = 0\n        sqrt_discriminant = np.sqrt(Gamma**2 + 4 * Gamma * k)\n        x1 = (-Gamma + sqrt_discriminant) / (2 * k)  # Positive root x_inf\n        x2 = (-Gamma - sqrt_discriminant) / (2 * k)  # Negative root\n\n        # Integration constant C\n        # Denominator x0 - x2 is never zero since x0 = 0 and x2  0\n        C = (x0 - x1) / (x0 - x2)\n        \n        # Exact solution x(T)\n        # The term lambda in the problem is sqrt_discriminant\n        x_exact_T = (x1 - C * np.exp(-sqrt_discriminant * T) * x2) / \\\n                    (1 - C * np.exp(-sqrt_discriminant * T))\n\n        # 4. Perform numerical integrations\n        if T == 0:\n            N_steps = 0\n            timesteps = []\n        else:\n            N_steps = int(np.ceil(T / dt))\n            # The last step is adjusted to end exactly at T\n            timesteps = [dt] * (N_steps - 1)\n            last_step = T - (N_steps - 1) * dt\n            if last_step  1e-12 * T: # Avoid negligible last step\n                timesteps.append(last_step)\n            else: # If last step is tiny, adjust previous step and reduce N\n                if N_steps  1:\n                    timesteps[-1] += last_step\n                N_steps = len(timesteps)\n\n\n        # --- Forward Euler ---\n        x_exp = x0\n        max_overshoot = 0.0\n        if N_steps  0:\n            for step_dt in timesteps:\n                dxdt = (1.0 - x_exp) * Gamma - k * x_exp**2\n                x_exp_new = x_exp + step_dt * dxdt\n                # Track maximum overshoot above physical bound x=1\n                current_overshoot = x_exp_new - 1.0\n                if current_overshoot  max_overshoot:\n                    max_overshoot = current_overshoot\n                x_exp = x_exp_new\n        \n        # Ensure overshoot is non-negative as per definition\n        max_overshoot = max(0.0, max_overshoot)\n        E_exp = abs(x_exp - x_exact_T)\n        cost_exp = N_steps * 1\n\n        # --- Backward Euler ---\n        x_imp = x0\n        if N_steps  0:\n            for step_dt in timesteps:\n                # Solve quadratic equation for x_imp^{n+1}\n                # (dt*k) y^2 + (1+dt*Gamma) y - (x_imp^n + dt*Gamma) = 0\n                a = step_dt * k\n                b = 1.0 + step_dt * Gamma\n                c = -(x_imp + step_dt * Gamma)\n                # Choose the physically admissible (positive) root\n                x_imp = (-b + np.sqrt(b**2 - 4 * a * c)) / (2 * a)\n\n        E_imp = abs(x_imp - x_exact_T)\n        cost_imp = N_steps * 4\n\n        all_results.append([\n            passes_criterion, max_overshoot, E_exp, E_imp, cost_exp, cost_imp\n        ])\n\n    # Final print statement in the exact required format.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3507618"}, {"introduction": "Beyond local chemistry, accurately tracking the propagation of radiation through space is paramount. Since solving the full, multi-dimensional radiative transfer equation is computationally prohibitive in large cosmological volumes, various approximations are used. This exercise lets you compare the performance of popular methods—such as the M1 moment closure and the Optically Thin Variable Eddington Tensor (OTVET) approximation—against an exact ray-tracing solution in a classic shadowing test, providing concrete insight into their strengths and weaknesses in anisotropic radiation fields [@problem_id:3507616].", "problem": "You are to implement and compare three approximate radiative transfer closures in a simplified anisotropic two-source shadowing test relevant to cosmological radiation hydrodynamics for reionization. The goal is to compute the angular anisotropy metric and quantify deviations across methods using only first principles and well-tested formulas.\n\nThe fundamental base for this task is as follows.\n\n- Consider steady, isotropic point sources of ionizing radiation in vacuum. For a single point source of bolometric luminosity $L$ at position $\\mathbf{x}_s$, the energy flux magnitude at radius $r$ in the absence of absorption is $L/(4\\pi r^2)$ by energy conservation over a sphere. The radiation energy density $E$ is related to the flux $\\mathbf{F}$ by $\\mathbf{F} = c E \\hat{\\mathbf{n}}$ under free streaming, where $c$ is the speed of light and $\\hat{\\mathbf{n}}$ is the unit vector pointing from the source to the field point. Therefore, for a field point at $\\mathbf{x}$ with $r = \\|\\mathbf{x}-\\mathbf{x}_s\\|$, one has\n$$\nE_s(\\mathbf{x}) = \\frac{L}{4\\pi c\\, r^2}, \\quad \\mathbf{F}_s(\\mathbf{x}) = c\\,E_s(\\mathbf{x})\\,\\frac{\\mathbf{x}-\\mathbf{x}_s}{\\|\\mathbf{x}-\\mathbf{x}_s\\|}.\n$$\n- For multiple independent sources in vacuum, superposition applies: $E(\\mathbf{x}) = \\sum_s E_s(\\mathbf{x})$ and $\\mathbf{F}(\\mathbf{x}) = \\sum_s \\mathbf{F}_s(\\mathbf{x})$, provided the line of sight from each source to $\\mathbf{x}$ is free of opaque obstacles.\n- Introduce an opaque circular absorber (a dense neutral clump) of radius $R$ centered at $\\mathbf{x}_c$, which fully blocks any ray whose straight line segment from a source to a field point intersects the disk. In that case, the corresponding source’s contribution is set to zero along that line of sight.\n\nDefine the angular anisotropy metric (the reduced flux) at a point to be\n$$\nA(\\mathbf{x}) \\equiv \\frac{\\|\\mathbf{F}(\\mathbf{x})\\|}{c\\,E(\\mathbf{x})},\n$$\nwhich must satisfy $0 \\le A \\le 1$ by construction. Note that any global constants in $E_s$ cancel in this ratio.\n\nYou must compare three methods to estimate $A(\\mathbf{x})$.\n\n1. Long-characteristics (LC) ray tracing: treat each source independently, apply exact straight-line occlusion by the obstacle, and superpose. This yields\n$$\nE_{\\mathrm{LC}}(\\mathbf{x}) = \\sum_{s \\in \\mathcal{V}(\\mathbf{x})} \\frac{L_s}{4\\pi c\\, r_s^2}, \\quad \\mathbf{F}_{\\mathrm{LC}}(\\mathbf{x}) = \\sum_{s \\in \\mathcal{V}(\\mathbf{x})} c\\,\\frac{L_s}{4\\pi c\\, r_s^2}\\,\\hat{\\mathbf{n}}_s,\n$$\nwhere $\\mathcal{V}(\\mathbf{x})$ is the set of sources with unblocked lines of sight to $\\mathbf{x}$, $r_s = \\|\\mathbf{x}-\\mathbf{x}_s\\|$, and $\\hat{\\mathbf{n}}_s = (\\mathbf{x}-\\mathbf{x}_s)/r_s$. Then\n$$\nA_{\\mathrm{LC}}(\\mathbf{x}) = \\frac{\\left\\|\\sum_{s \\in \\mathcal{V}(\\mathbf{x})} \\frac{L_s}{r_s^2}\\,\\hat{\\mathbf{n}}_s\\right\\|}{\\sum_{s \\in \\mathcal{V}(\\mathbf{x})} \\frac{L_s}{r_s^2}}.\n$$\n\n2. M1 moment closure (M1): in steady, free-streaming regions the local radiation moments satisfy $\\mathbf{F}=cE\\,\\mathbf{f}$ with reduced flux $\\mathbf{f}$ equal to the normalized flux vector. For a local mixture of non-interacting beams, the M1 reduced flux is the normalized superposition of directional contributions. In the present static test without solving evolution equations, this gives the same algebraic reduced flux as LC under the same occlusion set:\n$$\nA_{\\mathrm{M1}}(\\mathbf{x}) = \\frac{\\left\\|\\sum_{s \\in \\mathcal{V}(\\mathbf{x})} \\frac{L_s}{r_s^2}\\,\\hat{\\mathbf{n}}_s\\right\\|}{\\sum_{s \\in \\mathcal{V}(\\mathbf{x})} \\frac{L_s}{r_s^2}}.\n$$\n\n3. Optically Thin Variable Eddington Tensor (OTVET): the Eddington tensor and hence the angular structure are constructed from the optically thin field ignoring absorption and occlusion. In this static comparison, take the OTVET predicted direction as the optically thin weighted average of source directions using weights proportional to $E_s^{\\mathrm{thin}} \\propto L_s/r_s^2$ with all sources included. If the true local energy density is $E_{\\mathrm{LC}}(\\mathbf{x})$, an OTVET-consistent anisotropy estimate is\n$$\nA_{\\mathrm{OTVET}}(\\mathbf{x}) = \\left\\|\\sum_{s} w_s(\\mathbf{x})\\,\\hat{\\mathbf{n}}_s\\right\\|,\\quad w_s(\\mathbf{x}) = \\frac{\\frac{L_s}{r_s^2}}{\\sum_{s'} \\frac{L_{s'}}{r_{s'}^2}},\n$$\nwhere the sum in $A_{\\mathrm{OTVET}}$ runs over all sources regardless of occlusion.\n\nImplement a program that, for a fixed two-source, one-obstacle geometry, evaluates $A$ for each method at several specified field points and reports the deviations from the LC reference.\n\nGeometry and parameters:\n\n- Two identical sources with luminosities $L_1=L_2=1$ located at $\\mathbf{x}_1 = (-2,0)$ and $\\mathbf{x}_2 = (2,0)$.\n- One opaque circular obstacle centered at $\\mathbf{x}_c=(0,0)$ with radius $R=0.5$.\n- Four field points:\n  - Test case $1$: $\\mathbf{x}^{(1)} = (-1,\\,0.2)$.\n  - Test case $2$: $\\mathbf{x}^{(2)} = (0,\\,1)$.\n  - Test case $3$: $\\mathbf{x}^{(3)} = (0.6,\\,0)$.\n  - Test case $4$: $\\mathbf{x}^{(4)} = (0,\\,0.6)$.\n\nFor each test case $i \\in \\{1,2,3,4\\}$, compute:\n- $A_{\\mathrm{LC}}(\\mathbf{x}^{(i)})$ using exact straight-line segment versus circle intersection for occlusion,\n- $A_{\\mathrm{M1}}(\\mathbf{x}^{(i)})$ using the same visible source set as LC,\n- $A_{\\mathrm{OTVET}}(\\mathbf{x}^{(i)})$ using all sources irrespective of occlusion,\nand the absolute deviations\n$$\n\\Delta_{\\mathrm{M1}}^{(i)} = \\left|A_{\\mathrm{M1}}(\\mathbf{x}^{(i)}) - A_{\\mathrm{LC}}(\\mathbf{x}^{(i)})\\right|,\\quad\n\\Delta_{\\mathrm{OTVET}}^{(i)} = \\left|A_{\\mathrm{OTVET}}(\\mathbf{x}^{(i)}) - A_{\\mathrm{LC}}(\\mathbf{x}^{(i)})\\right|.\n$$\n\nAll results are dimensionless; no physical units are required in the output. Angles should be treated in radians internally where needed for vector normalization, but no angle values are to be printed.\n\nOutput specification:\n\n- Your program must produce a single line containing a list of four sublists, one per test case $i=1,2,3,4$.\n- Each sublist must contain five decimal numbers rounded to six digits after the decimal point in the following order: $[A_{\\mathrm{LC}}, A_{\\mathrm{M1}}, A_{\\mathrm{OTVET}}, \\Delta_{\\mathrm{M1}}, \\Delta_{\\mathrm{OTVET}}]$.\n- The final output must be exactly a single line of the form\n$$\n\\left[\\,[a_{11},a_{12},a_{13},a_{14},a_{15}],\\,[a_{21},a_{22},a_{23},a_{24},a_{25}],\\,[a_{31},a_{32},a_{33},a_{34},a_{35}],\\,[a_{41},a_{42},a_{43},a_{44},a_{45}]\\,\\right],\n$$\nwith no additional text.\n\nTest suite coverage:\n\n- Test case $1$ is a general off-axis point where one source is occluded and the other is visible, probing strong anisotropy and OTVET deviation.\n- Test case $2$ is a happy-path point where both sources are visible far above the obstacle, probing partial cancellation and agreement among methods.\n- Test case $3$ is a near-axis point on the right where the left source is occluded, probing unidirectional illumination and OTVET deviation.\n- Test case $4$ is a near-boundary point where both sources are visible but the geometry is close to the obstacle, probing sensitivity to anisotropy without occlusion.\n\nYour implementation must be a complete, runnable program that performs these computations precisely as described and prints the results in the exact specified format. No user input is allowed, and no external files should be used.", "solution": "The problem has been validated and is determined to be sound. It is scientifically grounded in the principles of radiative transfer, well-posed with all necessary parameters and definitions provided, and formalizable into a direct computational task. The comparison between Long-Characteristics (LC), M1, and Optically Thin Variable Eddington Tensor (OTVET) methods constitutes a standard, meaningful problem in computational astrophysics for evaluating the performance of radiative transfer approximations.\n\nThe task is to compute the angular anisotropy metric, $A(\\mathbf{x}) \\equiv \\frac{\\|\\mathbf{F}(\\mathbf{x})\\|}{c\\,E(\\mathbf{x})}$, for a specific 2D configuration using three different methods. The setup consists of two isotropic point sources, one opaque circular obstacle, and four specified field points.\n\nThe core of the computation involves two main steps for each field point $\\mathbf{x}$: first, determining which sources are occluded by the obstacle, and second, applying the distinct formula for each method ($A_{\\mathrm{LC}}$, $A_{\\mathrm{M1}}$, $A_{\\mathrm{OTVET}}$) based on the visibility of the sources.\n\nThe geometric and physical parameters are:\n- Sources: $L_1=1$ at $\\mathbf{x}_1 = (-2, 0)$ and $L_2=1$ at $\\mathbf{x}_2 = (2, 0)$.\n- Obstacle: Circle centered at $\\mathbf{x}_c=(0,0)$ with radius $R=0.5$.\n- Field Points: $\\mathbf{x}^{(1)} = (-1, 0.2)$, $\\mathbf{x}^{(2)} = (0, 1)$, $\\mathbf{x}^{(3)} = (0.6, 0)$, $\\mathbf{x}^{(4)} = (0, 0.6)$.\n\nThe computational procedure is as follows:\n\n1.  **Occlusion Detection**: For each source $\\mathbf{x}_s$ and field point $\\mathbf{x}_p$, we must determine if the line segment connecting them intersects the circular obstacle defined by $\\|\\mathbf{x}\\|^2 \\le R^2$. Since neither the sources nor the field points lie within the obstacle, this is equivalent to finding the minimum distance from the circle's center ($\\mathbf{x}_c = \\mathbf{0}$) to the line segment $[\\mathbf{x}_s, \\mathbf{x}_p]$ and checking if this distance is less than or equal to $R$. This minimum distance, $d_{\\mathrm{min}}$, is found by projecting the vector from a segment endpoint (e.g., $\\mathbf{x}_s$) to the circle's center onto the segment's direction vector, $\\mathbf{d} = \\mathbf{x}_p - \\mathbf{x}_s$. The projection parameter $t = \\frac{(\\mathbf{x}_c - \\mathbf{x}_s) \\cdot \\mathbf{d}}{\\mathbf{d} \\cdot \\mathbf{d}}$. If $t \\in [0, 1]$, the closest point lies on the interior of the segment, and $d_{\\mathrm{min}}$ is the perpendicular distance. Otherwise, the closest point is one of the endpoints, $\\mathbf{x}_s$ or $\\mathbf{x}_p$. A source $s$ is visible from $\\mathbf{x}_p$ if its line of sight is not occluded. The set of visible sources is denoted $\\mathcal{V}(\\mathbf{x}_p)$.\n\n2.  **Calculation of Anisotropy Metrics**: For each field point $\\mathbf{x}$, we compute the following quantities. Note that since luminosities $L_s=1$ are identical, they can be factored out. Let $I_s(\\mathbf{x}) = 1/\\|\\mathbf{x}-\\mathbf{x}_s\\|^2 = 1/r_s^2$ be the un-normalized energy density contribution and $\\hat{\\mathbf{n}}_s = (\\mathbf{x}-\\mathbf{x}_s)/r_s$ be the direction vector.\n\n    -   **Long-Characteristics ($A_{\\mathrm{LC}}$)**: This is the ground truth. The calculation involves only the visible sources.\n    $$\n    A_{\\mathrm{LC}}(\\mathbf{x}) = \\frac{\\left\\| \\sum_{s \\in \\mathcal{V}(\\mathbf{x})} I_s(\\mathbf{x}) \\hat{\\mathbf{n}}_s \\right\\|}{\\sum_{s \\in \\mathcal{V}(\\mathbf{x})} I_s(\\mathbf{x})}\n    $$\n    If only one source is visible, the sums contain a single term, yielding $A_{\\mathrm{LC}} = \\|\\hat{\\mathbf{n}}_s\\| = 1$. If no sources are visible, $A_{\\mathrm{LC}}$ is undefined, but this does not occur in the test cases.\n\n    -   **M1 Closure ($A_{\\mathrm{M1}}$)**: The problem states that for this static test, the M1 method uses the same set of visible sources and yields the same result as the LC method.\n    $$\n    A_{\\mathrm{M1}}(\\mathbf{x}) = A_{\\mathrm{LC}}(\\mathbf{x})\n    $$\n\n    -   **Optically Thin Variable Eddington Tensor ($A_{\\mathrm{OTVET}}$)**: This method constructs its anisotropy based on the optically thin radiation field, meaning it considers all sources, irrespective of occlusion.\n    $$\n    A_{\\mathrm{OTVET}}(\\mathbf{x}) = \\left\\| \\sum_s w_s(\\mathbf{x}) \\hat{\\mathbf{n}}_s \\right\\|, \\quad \\text{where} \\quad w_s(\\mathbf{x}) = \\frac{I_s(\\mathbf{x})}{\\sum_{s'} I_{s'}(\\mathbf{x})}\n    $$\n    The sums for $w_s$ and for $A_{\\mathrm{OTVET}}$ run over all sources $s$ and $s'$.\n\n3.  **Calculation of Deviations**: The absolute differences from the LC reference are computed as:\n    $$\n    \\Delta_{\\mathrm{M1}} = |A_{\\mathrm{M1}} - A_{\\mathrm{LC}}| = 0 \\quad (\\text{by definition in this problem})\n    $$\n    $$\n    \\Delta_{\\mathrm{OTVET}} = |A_{\\mathrm{OTVET}} - A_{\\mathrm{LC}}|\n    $$\n\nThis procedure is applied to each of the four test cases.\n\n**Case 1: $\\mathbf{x} = (-1, 0.2)$**\n-   Occlusion: Source $\\mathbf{x}_1=(-2,0)$ is visible. Source $\\mathbf{x}_2=(2,0)$ is occluded, as the line of sight passes through the obstacle.\n-   $A_{\\mathrm{LC}}, A_{\\mathrm{M1}}$: With only one visible source, the field is perfectly anisotropic. $A_{\\mathrm{LC}} = A_{\\mathrm{M1}} = 1$.\n-   $A_{\\mathrm{OTVET}}$: Calculated using both sources, yielding a value less than $1$ due to the averaging of two different direction vectors.\n-   Result: $A_{\\mathrm{LC}} = 1.0$, $A_{\\mathrm{M1}} = 1.0$, $A_{\\mathrm{OTVET}} \\approx 0.797613$. Deviations: $\\Delta_{\\mathrm{M1}} = 0.0$, $\\Delta_{\\mathrm{OTVET}} \\approx 0.202387$.\n\n**Case 2: $\\mathbf{x} = (0, 1)$**\n-   Occlusion: By symmetry, the point is far enough from the obstacle that both sources are visible.\n-   $A_{\\mathrm{LC}}, A_{\\mathrm{M1}}$: Calculated with both sources.\n-   $A_{\\mathrm{OTVET}}$: Since all sources are visible, the set of sources used is the same as for LC. The formulas for $A_{\\mathrm{LC}}$ and $A_{\\mathrm{OTVET}}$ are mathematically equivalent in this scenario.\n-   Result: $A_{\\mathrm{LC}} = A_{\\mathrm{M1}} = A_{\\mathrm{OTVET}} = 1/\\sqrt{5} \\approx 0.447214$. Deviations: $\\Delta_{\\mathrm{M1}} = 0.0$, $\\Delta_{\\mathrm{OTVET}} = 0.0$.\n\n**Case 3: $\\mathbf{x} = (0.6, 0)$**\n-   Occlusion: The point lies on the x-axis. The line of sight to $\\mathbf{x}_1=(-2,0)$ passes through the origin and is thus occluded. The line of sight to $\\mathbf{x}_2=(2,0)$ is clear.\n-   $A_{\\mathrm{LC}}, A_{\\mathrm{M1}}$: With only one visible source, the field is perfectly anisotropic. $A_{\\mathrm{LC}} = A_{\\mathrm{M1}} = 1$.\n-   $A_{\\mathrm{OTVET}}$: Calculated using both sources. The two direction vectors are opposing ($\\hat{\\mathbf{n}}_1=(1,0), \\hat{\\mathbf{n}}_2=(-1,0)$), leading to significant cancellation and a low anisotropy value.\n-   Result: $A_{\\mathrm{LC}} = 1.0$, $A_{\\mathrm{M1}} = 1.0$, $A_{\\mathrm{OTVET}} \\approx 0.550570$. Deviations: $\\Delta_{\\mathrm{M1}} = 0.0$, $\\Delta_{\\mathrm{OTVET}} \\approx 0.449430$.\n\n**Case 4: $\\mathbf{x} = (0, 0.6)$**\n-   Occlusion: The point is on the y-axis, just outside the obstacle ($0.6 > R=0.5$). Both lines of sight pass close to but do not intersect the obstacle. Both sources are visible.\n-   $A_{\\mathrm{LC}}, A_{\\mathrm{M1}}, A_{\\mathrm{OTVET}}$: As in Case 2, all sources are visible, so all three methods yield the same result.\n-   Result: $A_{\\mathrm{LC}} = A_{\\mathrm{M1}} = A_{\\mathrm{OTVET}} = 0.6/\\sqrt{2^2+0.6^2} \\approx 0.287348$. Deviations: $\\Delta_{\\mathrm{M1}} = 0.0$, $\\Delta_{\\mathrm{OTVET}} = 0.0$.\n\nThe final code implements these calculations precisely.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares three approximate radiative transfer closures\n    in a simplified anisotropic two-source shadowing test.\n    \"\"\"\n\n    # Define geometry and parameters\n    sources = [\n        {'pos': np.array([-2.0, 0.0]), 'L': 1.0},\n        {'pos': np.array([2.0, 0.0]), 'L': 1.0}\n    ]\n    obstacle = {'center': np.array([0.0, 0.0]), 'radius': 0.5}\n    \n    # Define test cases (field points)\n    test_cases = [\n        np.array([-1.0, 0.2]),\n        np.array([0.0, 1.0]),\n        np.array([0.6, 0.0]),\n        np.array([0.0, 0.6])\n    ]\n\n    def is_occluded(source_pos, point_pos, obs_center, obs_radius):\n        \"\"\"\n        Checks if the line segment from source_pos to point_pos is occluded\n        by a circular obstacle.\n        \n        This is done by finding the point on the line segment closest to the\n        obstacle's center and checking if its distance is within the radius.\n        \"\"\"\n        # Vector from source to point\n        vec_sp = point_pos - source_pos\n        d_sq = np.dot(vec_sp, vec_sp)\n        if d_sq == 0:  # Point is at the source\n            return False\n\n        # Vector from source to obstacle center\n        vec_s_obs = obs_center - source_pos\n\n        # Project vec_s_obs onto vec_sp to find the closest point on the infinite line\n        # t = (obs_center - source_pos) . (point_pos - source_pos) / |point_pos - source_pos|^2\n        t = np.dot(vec_s_obs, vec_sp) / d_sq\n        \n        # Clamp t to [0, 1] to find the closest point on the line segment\n        t_clamped = np.clip(t, 0.0, 1.0)\n\n        # Calculate the closest point on the segment to the obstacle center\n        closest_point_on_segment = source_pos + t_clamped * vec_sp\n        \n        # Calculate distance from this point to the obstacle center\n        dist_sq = np.sum((closest_point_on_segment - obs_center)**2)\n        \n        return dist_sq = obs_radius**2\n\n    results = []\n    \n    for x_p in test_cases:\n        # Determine the set of visible sources\n        visible_sources_indices = []\n        for i, s in enumerate(sources):\n            if not is_occluded(s['pos'], x_p, obstacle['center'], obstacle['radius']):\n                visible_sources_indices.append(i)\n\n        # --- Calculate A_LC and A_M1 ---\n        # (Based on visible sources)\n        A_lc = 0.0\n        if visible_sources_indices:\n            sum_flux_vec_lc = np.zeros(2)\n            sum_energy_den_lc = 0.0\n            for i in visible_sources_indices:\n                s = sources[i]\n                r_vec = x_p - s['pos']\n                r_mag = np.linalg.norm(r_vec)\n                n_hat = r_vec / r_mag\n                intensity = s['L'] / r_mag**2\n                \n                sum_flux_vec_lc += intensity * n_hat\n                sum_energy_den_lc += intensity\n            \n            if sum_energy_den_lc  0:\n                A_lc = np.linalg.norm(sum_flux_vec_lc) / sum_energy_den_lc\n        \n        A_m1 = A_lc  # As per problem statement\n        delta_m1 = abs(A_m1 - A_lc)\n\n        # --- Calculate A_OTVET ---\n        # (Based on ALL sources)\n        sum_weighted_n_hat_otvet = np.zeros(2)\n        total_intensity_otvet = 0.0\n        \n        intensities = []\n        unit_vectors = []\n        for s in sources:\n            r_vec = x_p - s['pos']\n            r_mag = np.linalg.norm(r_vec)\n            if r_mag  0:\n                n_hat = r_vec / r_mag\n                intensity = s['L'] / r_mag**2\n                intensities.append(intensity)\n                unit_vectors.append(n_hat)\n                total_intensity_otvet += intensity\n            else: # field point is at a source location\n                intensities.append(0)\n                unit_vectors.append(np.zeros(2))\n        \n        if total_intensity_otvet  0:\n            for i in range(len(sources)):\n                weight = intensities[i] / total_intensity_otvet\n                sum_weighted_n_hat_otvet += weight * unit_vectors[i]\n\n        A_otvet = np.linalg.norm(sum_weighted_n_hat_otvet)\n        delta_otvet = abs(A_otvet - A_lc)\n\n        # Store the results for this test case\n        results.append([A_lc, A_m1, A_otvet, delta_m1, delta_otvet])\n\n    # Format the final output string as specified\n    sublist_strs = []\n    for sublist in results:\n        sublist_strs.append(f\"[{','.join([f'{val:.6f}' for val in sublist])}]\")\n    \n    final_output_str = f\"[{','.join(sublist_strs)}]\"\n    print(final_output_str)\n\nsolve()\n```", "id": "3507616"}, {"introduction": "Modern cosmological simulations are multi-physics codes that couple distinct physical processes like hydrodynamics, gravity, and radiative transfer. The most common technique for this coupling is operator splitting, where each process is advanced sequentially over a small time step. This practice delves into the numerical analysis of this critical technique, allowing you to derive the \"commutator error\" that governs its accuracy and investigate how the stability of the full scheme depends on the properties of its component parts [@problem_id:3507596].", "problem": "Consider a spatially homogeneous cell model for cosmological reionization in which radiation and gas hydrodynamics are coupled but treated by operator splitting. Let the state vector be $\\mathbf{y} = [x, e, E_r]^\\top$, where $x$ is the dimensionless ionization fraction, $e$ is the dimensionless gas internal energy density, and $E_r$ is the dimensionless radiation energy density. Assume the dynamics over a single operator-split time step are governed by linear, time-independent operators $\\mathcal{L}_\\mathrm{rad}$ (radiation processes) and $\\mathcal{L}_\\mathrm{hydro}$ (hydrodynamic expansion/cooling) acting additively on $\\mathbf{y}$, so that the full system is\n$$\n\\frac{d\\mathbf{y}}{dt} = \\left(\\mathcal{L}_\\mathrm{rad} + \\mathcal{L}_\\mathrm{hydro}\\right)\\mathbf{y},\n$$\nwith $\\mathcal{L}_\\mathrm{rad}$ and $\\mathcal{L}_\\mathrm{hydro}$ represented as $3\\times 3$ matrices. The operator splitting strategies considered are the Lie product (sequential) formula and the symmetric Strang splitting. For the Lie product, the one-step map over $\\Delta t$ is $\\exp\\!\\left(\\mathcal{L}_\\mathrm{hydro}\\Delta t\\right)\\exp\\!\\left(\\mathcal{L}_\\mathrm{rad}\\Delta t\\right)$, while the Strang composition is $\\exp\\!\\left(\\mathcal{L}_\\mathrm{hydro}\\frac{\\Delta t}{2}\\right)\\exp\\!\\left(\\mathcal{L}_\\mathrm{rad}\\Delta t\\right)\\exp\\!\\left(\\mathcal{L}_\\mathrm{hydro}\\frac{\\Delta t}{2}\\right)$. The exact flow over $\\Delta t$ for the combined operator is $\\exp\\!\\left((\\mathcal{L}_\\mathrm{rad} + \\mathcal{L}_\\mathrm{hydro})\\Delta t\\right)$.\n\nStarting from the basic definitions of a flow map and the exponential of a linear operator, derive the leading local error for the Lie product and for the symmetric composition in terms of operator commutators, using the Baker–Campbell–Hausdorff expansion (BCH). Explain under what conditions the symmetric composition achieves second-order accuracy, and identify circumstances under which this accuracy can be lost in practice when subflows are not integrated exactly.\n\nThen, implement numerically the following evaluation for a set of test matrices. In all cases, use the same initial condition $\\mathbf{y}_0 = [x_0, e_0, E_{r,0}]^\\top = [\\,0.01,\\,1.0,\\,0.5\\,]^\\top$ and a finite final time $T$ specified per test case. The operators are:\n\n- Test case A (moderate non-commutativity, stable radiation):\n  $$\n  \\mathcal{L}_\\mathrm{rad}^{(A)} = \\begin{bmatrix}\n  -0.1  0.0  0.5 \\\\\n  0.0  -0.1  0.4 \\\\\n  -0.05  0.0  -0.6\n  \\end{bmatrix},\\quad\n  \\mathcal{L}_\\mathrm{hydro}^{(A)} = \\begin{bmatrix}\n  0.0  0.0  0.0 \\\\\n  0.0  -0.2  0.0 \\\\\n  0.0  0.0  -1.0\n  \\end{bmatrix},\\quad\n  T_A = 1.0,\\quad \\Delta t_A = 0.05.\n  $$\n\n- Test case B (stiff radiation intended to induce instability in an explicit radiation substep):\n  $$\n  \\mathcal{L}_\\mathrm{rad}^{(B)} = \\begin{bmatrix}\n  -10.0  0.0  8.0 \\\\\n  0.0  -5.0  4.0 \\\\\n  -2.0  0.0  -60.0\n  \\end{bmatrix},\\quad\n  \\mathcal{L}_\\mathrm{hydro}^{(B)} = \\begin{bmatrix}\n  0.0  0.0  0.0 \\\\\n  0.0  -0.2  0.0 \\\\\n  0.0  0.0  -1.0\n  \\end{bmatrix},\\quad\n  T_B = 1.0,\\quad \\Delta t_B = 0.2.\n  $$\n\n- Test case C (commuting diagonal operators):\n  $$\n  \\mathcal{L}_\\mathrm{rad}^{(C)} = \\operatorname{diag}(-0.2,\\,-0.3,\\,-0.4),\\quad\n  \\mathcal{L}_\\mathrm{hydro}^{(C)} = \\operatorname{diag}(0.0,\\,-0.1,\\,-0.5),\\quad\n  T_C = 1.0,\\quad \\Delta t_C = 0.1.\n  $$\n\n- Test case D (strong non-normal coupling, stable radiation):\n  $$\n  \\mathcal{L}_\\mathrm{rad}^{(D)} = \\begin{bmatrix}\n  -1.0  0.0  4.0 \\\\\n  0.0  -0.5  3.0 \\\\\n  -2.0  0.0  -1.0\n  \\end{bmatrix},\\quad\n  \\mathcal{L}_\\mathrm{hydro}^{(D)} = \\begin{bmatrix}\n  0.0  0.0  0.0 \\\\\n  0.0  -0.1  0.0 \\\\\n  0.0  0.0  -0.2\n  \\end{bmatrix},\\quad\n  T_D = 1.0,\\quad \\Delta t_D = 0.1.\n  $$\n\nFor each test case, compute the following quantities:\n\n1. The commutator $[\\mathcal{L}_\\mathrm{rad},\\mathcal{L}_\\mathrm{hydro}] = \\mathcal{L}_\\mathrm{rad}\\,\\mathcal{L}_\\mathrm{hydro} - \\mathcal{L}_\\mathrm{hydro}\\,\\mathcal{L}_\\mathrm{rad}$ and its Frobenius norm $\\|[\\mathcal{L}_\\mathrm{rad},\\mathcal{L}_\\mathrm{hydro}]\\|_F$.\n\n2. The local Lie product one-step error at step size $\\Delta t$ applied to $\\mathbf{y}_0$, defined as the Euclidean norm\n$$\n\\left\\|\\exp\\!\\left((\\mathcal{L}_\\mathrm{rad}+\\mathcal{L}_\\mathrm{hydro})\\Delta t\\right)\\mathbf{y}_0 - \\exp\\!\\left(\\mathcal{L}_\\mathrm{hydro}\\Delta t\\right)\\exp\\!\\left(\\mathcal{L}_\\mathrm{rad}\\Delta t\\right)\\mathbf{y}_0\\right\\|_2.\n$$\n\n3. The measured global order for a Strang-like composition in which the hydrodynamics subflow is integrated exactly but the radiation subflow is advanced by a single explicit forward Euler step. Specifically, define a one-step Strang-like update as\n$$\n\\mathbf{y}^{n+\\frac{1}{2}} = \\exp\\!\\left(\\mathcal{L}_\\mathrm{hydro}\\frac{\\Delta t}{2}\\right)\\mathbf{y}^n,\\quad\n\\mathbf{y}^{n+1^-} = \\left(I + \\Delta t\\,\\mathcal{L}_\\mathrm{rad}\\right)\\mathbf{y}^{n+\\frac{1}{2}},\\quad\n\\mathbf{y}^{n+1} = \\exp\\!\\left(\\mathcal{L}_\\mathrm{hydro}\\frac{\\Delta t}{2}\\right)\\mathbf{y}^{n+1^-},\n$$\nand iterate these steps to time $T$ using $N = \\lfloor T/\\Delta t\\rfloor$ steps. Let $\\mathbf{y}_\\mathrm{exact}(T) = \\exp\\!\\left((\\mathcal{L}_\\mathrm{rad}+\\mathcal{L}_\\mathrm{hydro})T\\right)\\mathbf{y}_0$. Compute the global error $\\mathbf{e}_{\\Delta t} = \\mathbf{y}(T;\\Delta t) - \\mathbf{y}_\\mathrm{exact}(T)$ and repeat with step size $\\Delta t/2$ to obtain $\\mathbf{e}_{\\Delta t/2}$. Estimate the convergence order as\n$$\np = \\frac{\\log\\left(\\|\\mathbf{e}_{\\Delta t}\\|_2 / \\|\\mathbf{e}_{\\Delta t/2}\\|_2\\right)}{\\log(2)}.\n$$\n\n4. A failure indicator for the Strang-like composition. Define failure as a boolean that is true if either the measured order $p$ is less than $1.5$ or the explicit radiation substep is linearly unstable at the chosen $\\Delta t$, which can be diagnosed by the spectral radius $\\rho\\!\\left(I + \\Delta t\\,\\mathcal{L}_\\mathrm{rad}\\right)  1$. In addition, if any component of the numerical solution becomes not-a-number or infinite during the integration to $T$, set failure to true.\n\nAll quantities are dimensionless. Your program must evaluate these four quantities for each of the four test cases above and produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a list of the form $[E_\\mathrm{Lie},\\,\\|[\\mathcal{L}_\\mathrm{rad},\\mathcal{L}_\\mathrm{hydro}]\\|_F,\\,p,\\,\\text{failure}]$. Here $E_\\mathrm{Lie}$ is a float, $\\|[\\mathcal{L}_\\mathrm{rad},\\mathcal{L}_\\mathrm{hydro}]\\|_F$ is a float, $p$ is a float (use a not-a-number representation if it cannot be computed), and $\\text{failure}$ is a boolean. The final output must have the format\n$$\n[\\,[E_\\mathrm{Lie}^{(A)},\\,\\|[\\cdot,\\cdot]\\|_F^{(A)},\\,p^{(A)},\\,\\text{failure}^{(A)}],\\,[E_\\mathrm{Lie}^{(B)},\\,\\|[\\cdot,\\cdot]\\|_F^{(B)},\\,p^{(B)},\\,\\text{failure}^{(B)}],\\,[E_\\mathrm{Lie}^{(C)},\\,\\|[\\cdot,\\cdot]\\|_F^{(C)},\\,p^{(C)},\\,\\text{failure}^{(C)}],\\,[E_\\mathrm{Lie}^{(D)},\\,\\|[\\cdot,\\cdot]\\|_F^{(D)},\\,p^{(D)},\\,\\text{failure}^{(D)}]\\,].\n$$\nYour implementation must be self-contained and must not require any user input. Provide results in the exact output format described, aggregating all four test cases into the single line.", "solution": "The problem presents a valid and well-posed exercise in numerical analysis, specifically concerning operator splitting methods for systems of linear ordinary differential equations. The context is a simplified model of cosmological radiation hydrodynamics, but the core task is a rigorous mathematical and computational investigation of standard numerical techniques. All givens, including matrices, initial conditions, and evaluation metrics, are clearly defined and self-consistent. The problem is scientifically grounded in the theory of differential equations and numerical methods, containing no factual or logical inconsistencies.\n\nThe solution consists of two parts: a theoretical derivation of the local error for the specified splitting methods, and a numerical implementation to evaluate their properties on a set of test cases.\n\n### Theoretical Analysis of Operator Splitting Error\n\nThe governing differential equation is given by\n$$\n\\frac{d\\mathbf{y}}{dt} = \\left(\\mathcal{L}_\\mathrm{rad} + \\mathcal{L}_\\mathrm{hydro}\\right)\\mathbf{y} = \\mathcal{L}\\mathbf{y}\n$$\nwhere $\\mathcal{L}_\\mathrm{rad}$ and $\\mathcal{L}_\\mathrm{hydro}$ are time-independent $3 \\times 3$ matrices. The exact solution over a time step $\\Delta t$ is given by the action of the matrix exponential of the total operator, $\\mathbf{y}(t_0 + \\Delta t) = \\exp(\\mathcal{L}\\Delta t)\\mathbf{y}(t_0)$. Operator splitting methods approximate this exact evolution by a composition of evolutions under the individual operators. Let $A = \\mathcal{L}_\\mathrm{rad}\\Delta t$ and $B = \\mathcal{L}_\\mathrm{hydro}\\Delta t$. The exact one-step map is $\\Phi_\\mathrm{exact}(\\Delta t) = \\exp(A+B)$.\n\n#### Lie Product Splitting\n\nThe first-order Lie product formula (also known as Godunov splitting) approximates the evolution as a sequential application of the two sub-flows:\n$$\n\\Phi_\\mathrm{Lie}(\\Delta t) = \\exp(B)\\exp(A) = \\exp(\\mathcal{L}_\\mathrm{hydro}\\Delta t)\\exp(\\mathcal{L}_\\mathrm{rad}\\Delta t)\n$$\nTo find the local error, we compare this to the exact map. The Baker–Campbell–Hausdorff (BCH) formula gives the product of two matrix exponentials as a single exponential:\n$$\n\\exp(B)\\exp(A) = \\exp\\left(B+A + \\frac{1}{2}[B,A] + \\frac{1}{12}\\left([B,[B,A]] - [A,[B,A]]\\right) + \\mathcal{O}(\\Delta t^3)\\right)\n$$\nUsing the antisymmetry of the commutator, $[B,A] = -[A,B]$, this becomes:\n$$\n\\Phi_\\mathrm{Lie}(\\Delta t) = \\exp\\left(A+B - \\frac{1}{2}[A,B] + \\mathcal{O}(\\Delta t^3)\\right)\n$$\nThe local truncation error operator, $E_\\mathrm{Lie}(\\Delta t)$, is the difference between the exact map and the approximate map:\n$$\nE_\\mathrm{Lie}(\\Delta t) = \\Phi_\\mathrm{exact}(\\Delta t) - \\Phi_\\mathrm{Lie}(\\Delta t) = \\exp(A+B) - \\exp\\left(A+B - \\frac{1}{2}[A,B] + \\dots\\right)\n$$\nFor small $\\Delta t$, we can expand the exponentials.\n$$\n\\exp(A+B) = I + (A+B) + \\frac{1}{2}(A+B)^2 + \\mathcal{O}(\\Delta t^3) = I + A+B + \\frac{1}{2}(A^2+AB+BA+B^2) + \\mathcal{O}(\\Delta t^3)\n$$\n$$\n\\exp(B)\\exp(A) = \\left(I+B+\\frac{B^2}{2}+\\dots\\right)\\left(I+A+\\frac{A^2}{2}+\\dots\\right) = I+A+B+BA+\\frac{A^2}{2}+\\frac{B^2}{2} + \\mathcal{O}(\\Delta t^3)\n$$\nSubtracting the two expansions gives the leading-order error:\n$$\nE_\\mathrm{Lie}(\\Delta t) = \\frac{1}{2}(AB-BA) + \\mathcal{O}(\\Delta t^3) = \\frac{1}{2}[A,B] + \\mathcal{O}(\\Delta t^3) = \\frac{1}{2}\\Delta t^2 [\\mathcal{L}_\\mathrm{rad}, \\mathcal{L}_\\mathrm{hydro}] + \\mathcal{O}(\\Delta t^3)\n$$\nThe local error is of order $\\mathcal{O}(\\Delta t^2)$, which makes the Lie product a first-order accurate method globally. The error is directly proportional to the commutator of the operators, vanishing if and only if $[\\mathcal{L}_\\mathrm{rad}, \\mathcal{L}_\\mathrm{hydro}] = 0$.\n\n#### Symmetric Strang Splitting\n\nThe second-order symmetric Strang splitting formula is given by:\n$$\n\\Phi_\\mathrm{Strang}(\\Delta t) = \\exp(B/2)\\exp(A)\\exp(B/2) = \\exp\\left(\\mathcal{L}_\\mathrm{hydro}\\frac{\\Delta t}{2}\\right)\\exp(\\mathcal{L}_\\mathrm{rad}\\Delta t)\\exp\\left(\\mathcal{L}_\\mathrm{hydro}\\frac{\\Delta t}{2}\\right)\n$$\nDue to its symmetric construction, the error expansion for this map contains only odd powers of $\\Delta t$. A more elaborate application of the BCH formula shows that:\n$$\n\\Phi_\\mathrm{Strang}(\\Delta t) = \\exp\\left( (A+B) + \\frac{\\Delta t^3}{12}[\\mathcal{L}_\\mathrm{rad},[\\mathcal{L}_\\mathrm{rad},\\mathcal{L}_\\mathrm{hydro}]] + \\frac{\\Delta t^3}{24}[\\mathcal{L}_\\mathrm{hydro},[\\mathcal{L}_\\mathrm{hydro},\\mathcal{L}_\\mathrm{rad}]] + \\mathcal{O}(\\Delta t^5) \\right)\n$$\nThe leading term in the difference between the argument of the exact exponential, $A+B$, and the Strang approximation is of order $\\mathcal{O}(\\Delta t^3)$. Thus, the local truncation error for Strang splitting is $\\mathcal{O}(\\Delta t^3)$, making it a second-order accurate method globally.\n\nThis second-order accuracy is achieved under the crucial assumption that the individual sub-flows, e.g., $\\exp(\\mathcal{L}_\\mathrm{rad}\\Delta t)$, are computed exactly. In practice, these sub-flows are often themselves approximated by a numerical integrator. If a sub-flow is approximated using a method with local error $\\mathcal{O}(\\Delta t^{q+1})$, the overall order of the splitting scheme is reduced to the minimum of its intrinsic order and the order of the sub-step integrator.\n\nThe problem specifies a mixed scheme where the radiation sub-flow is approximated by a single explicit forward Euler step, which is a first-order method:\n$$\n\\exp(\\mathcal{L}_\\mathrm{rad}\\Delta t) \\approx I + \\Delta t\\,\\mathcal{L}_\\mathrm{rad}\n$$\nThe error in this approximation is $\\exp(\\Delta t\\,\\mathcal{L}_\\mathrm{rad}) - (I + \\Delta t\\,\\mathcal{L}_\\mathrm{rad}) = \\frac{1}{2}\\Delta t^2 \\mathcal{L}_\\mathrm{rad}^2 + \\mathcal{O}(\\Delta t^3)$. This introduces a local error of order $\\mathcal{O}(\\Delta t^2)$ into the overall one-step map. The local error of the Strang splitting part is $\\mathcal{O}(\\Delta t^3)$, but it is now contaminated by the $\\mathcal{O}(\\Delta t^2)$ error from the inaccurate sub-step integration. The total local error is therefore dominated by the less accurate component, becoming $\\mathcal{O}(\\Delta t^2)$. This reduces the global accuracy of the entire scheme from second-order to first-order.\n\n### Numerical Implementation\n\nThe following Python code implements the required calculations for each of the four test cases. Matrix exponentials are computed using `scipy.linalg.expm`. The numerical integration for the Strang-like scheme is performed in a loop, and the convergence order is estimated using solutions at two different step sizes, $\\Delta t$ and $\\Delta t/2$. The failure criteria are evaluated as specified.\n\nFor each test case, the four required quantities are computed:\n1.  **Frobenius norm of the commutator**: $\\|[\\mathcal{L}_\\mathrm{rad},\\mathcal{L}_\\mathrm{hydro}]\\|_F$. This is calculated directly from the matrix definitions.\n2.  **Local Lie error**: This is the Euclidean norm of the difference between the state vector evolved over one step $\\Delta t$ using the exact map and the Lie product map, starting from $\\mathbf{y}_0$.\n3.  **Measured global order $p$**: The mixed Strang-like scheme is integrated to the final time $T$ using step sizes $\\Delta t$ and $\\Delta t/2$. The global errors with respect to the exact solution are computed, and the order $p$ is derived from their ratio.\n4.  **Failure indicator**: This boolean flag is set to `True` if any of the specified failure conditions are met: the measured order $p$ is not a number or is less than $1.5$; the explicit Euler substep for radiation is linearly unstable (spectral radius of the update matrix $ 1$); or the numerical integration produces non-finite values.\n\nThe implementation is structured to iterate through the test cases and aggregate the results into the specified final output format.", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Solves the operator splitting problem for four test cases.\n    \"\"\"\n    \n    # Define initial condition\n    y0 = np.array([0.01, 1.0, 0.5])\n\n    # Define test cases as a list of dictionaries\n    test_cases = [\n        # Test case A\n        {'L_rad': np.array([[-0.1, 0.0, 0.5], [0.0, -0.1, 0.4], [-0.05, 0.0, -0.6]]),\n         'L_hydro': np.array([[0.0, 0.0, 0.0], [0.0, -0.2, 0.0], [0.0, 0.0, -1.0]]),\n         'T': 1.0, 'dt': 0.05},\n        # Test case B\n        {'L_rad': np.array([[-10.0, 0.0, 8.0], [0.0, -5.0, 4.0], [-2.0, 0.0, -60.0]]),\n         'L_hydro': np.array([[0.0, 0.0, 0.0], [0.0, -0.2, 0.0], [0.0, 0.0, -1.0]]),\n         'T': 1.0, 'dt': 0.2},\n        # Test case C\n        {'L_rad': np.diag([-0.2, -0.3, -0.4]),\n         'L_hydro': np.diag([0.0, -0.1, -0.5]),\n         'T': 1.0, 'dt': 0.1},\n        # Test case D\n        {'L_rad': np.array([[-1.0, 0.0, 4.0], [0.0, -0.5, 3.0], [-2.0, 0.0, -1.0]]),\n         'L_hydro': np.array([[0.0, 0.0, 0.0], [0.0, -0.1, 0.0], [0.0, 0.0, -0.2]]),\n         'T': 1.0, 'dt': 0.1},\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        L_rad = case['L_rad']\n        L_hydro = case['L_hydro']\n        T = case['T']\n        dt = case['dt']\n\n        # 1. Commutator and its Frobenius norm ($E_\\mathrm{Lie}$ is item 2)\n        commutator = L_rad @ L_hydro - L_hydro @ L_rad\n        norm_comm = np.linalg.norm(commutator, 'fro')\n\n        # 2. Local Lie product one-step error ($E_\\mathrm{Lie}$)\n        L_sum = L_rad + L_hydro\n        exact_map_step = expm(L_sum * dt)\n        lie_map_step = expm(L_hydro * dt) @ expm(L_rad * dt)\n        y_exact_step = exact_map_step @ y0\n        y_lie_step = lie_map_step @ y0\n        lie_error = np.linalg.norm(y_exact_step - y_lie_step, 2)\n        \n        # 3. Measured global order p for Strang-like composition\n        def integrate_mixed(current_dt):\n            N = int(T / current_dt)\n            y = y0.copy()\n            \n            hydro_map_half = expm(L_hydro * current_dt / 2.0)\n            rad_map_euler = np.eye(y0.shape[0]) + current_dt * L_rad\n            one_step_map = hydro_map_half @ rad_map_euler @ hydro_map_half\n            \n            integration_failed = False\n            for _ in range(N):\n                y = one_step_map @ y\n                if np.any(np.isnan(y)) or np.any(np.isinf(y)):\n                    integration_failed = True\n                    break\n            \n            return y, N * current_dt, integration_failed\n\n        y_dt, T_eff_dt, fail_dt = integrate_mixed(dt)\n        y_dt_half, T_eff_dt_half, fail_dt_half = integrate_mixed(dt / 2.0)\n\n        p = np.nan\n        has_integration_failure = fail_dt or fail_dt_half\n        \n        if not has_integration_failure:\n            y_exact_dt = expm(L_sum * T_eff_dt) @ y0\n            y_exact_dt_half = expm(L_sum * T_eff_dt_half) @ y0\n            \n            err_norm_dt = np.linalg.norm(y_dt - y_exact_dt, 2)\n            err_norm_dt_half = np.linalg.norm(y_dt_half - y_exact_dt_half, 2)\n\n            if err_norm_dt  1e-15 and err_norm_dt_half  1e-15:\n                ratio = err_norm_dt / err_norm_dt_half\n                if ratio  0:\n                    p = np.log(ratio) / np.log(2)\n        \n        # 4. Failure indicator\n        rad_map_euler_dt = np.eye(y0.shape[0]) + dt * L_rad\n        spectral_radius = np.max(np.abs(np.linalg.eigvals(rad_map_euler_dt)))\n        is_unstable = spectral_radius  1.0\n        \n        p_is_nan = np.isnan(p)\n        order_too_low = (not p_is_nan) and (p  1.5)\n        \n        failure = bool(has_integration_failure or is_unstable or p_is_nan or order_too_low)\n        \n        # Format results for this case\n        case_results = [lie_error, norm_comm, p, failure]\n        all_results.append(case_results)\n\n    # Format final output string\n    formatted_results = []\n    for r in all_results:\n        p_str = 'nan' if np.isnan(r[2]) else str(r[2])\n        fail_str = str(r[3]).lower()\n        formatted_results.append(f\"[{r[0]},{r[1]},{p_str},{fail_str}]\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3507596"}]}