{"hands_on_practices": [{"introduction": "At the heart of any code that uses spectral methods, from cosmological simulations to fluid dynamics, lies the crucial task of correctly interpreting the output of a Fast Fourier Transform (FFT). This exercise focuses on the fundamental mapping between the array indices of an FFT grid and the physical wavevectors, $\\mathbf{k}$, they represent. Mastering this step, including the proper handling of zero and Nyquist frequencies to enforce the reality of physical fields, is an essential prerequisite for accurately solving differential equations and analyzing power spectra in Fourier space. [@problem_id:3512441]", "problem": "You are generating cosmological initial conditions for a Gaussian random field on a three-dimensional periodic cubic domain with side lengths $L_x$, $L_y$, and $L_z$, discretized on a regular grid of sizes $N_x$, $N_y$, and $N_z$ with spacings $\\Delta_x = L_x/N_x$, $\\Delta_y = L_y/N_y$, and $\\Delta_z = L_z/N_z$. You will compute the first- and second-order Lagrangian perturbation theory (2LPT) displacements by solving Poisson-type equations in Fourier space, so you must accurately map Fast Fourier Transform (FFT) array indices to physical wavevector components and enforce the reality of the real-space fields.\n\nStart from the definition of the discrete Fourier transform of a real scalar field $\\delta(\\mathbf{x})$ sampled on the grid, consistent with a three-dimensional periodic Fourier series representation on integers $m_a \\in \\mathbb{Z}$ for $a \\in \\{x,y,z\\}$:\n$$\n\\delta(\\mathbf{x}_{\\mathbf{n}}) = \\sum_{\\mathbf{m}} \\tilde{\\delta}(\\mathbf{k}_{\\mathbf{m}}) \\exp\\!\\left(i \\mathbf{k}_{\\mathbf{m}} \\cdot \\mathbf{x}_{\\mathbf{n}}\\right), \\quad \\mathbf{x}_{\\mathbf{n}} = \\left(n_x \\Delta_x, n_y \\Delta_y, n_z \\Delta_z\\right), \\quad \\mathbf{k}_{\\mathbf{m}} = \\left(\\tfrac{2\\pi m_x}{L_x}, \\tfrac{2\\pi m_y}{L_y}, \\tfrac{2\\pi m_z}{L_z}\\right),\n$$\nwith $n_a \\in \\{0,1,\\dots,N_a-1\\}$. For a real field $\\delta(\\mathbf{x})$, the Fourier coefficients obey the Hermitian symmetry $\\tilde{\\delta}(-\\mathbf{k}) = \\tilde{\\delta}(\\mathbf{k})^*$.\n\nIn practice, FFT libraries present the discrete spectrum in different index orderings. Two common conventions are:\n- The raw, “unshifted” FFT output ordering per axis $a$ with indices $i_a \\in \\{0,1,\\dots,N_a-1\\}$.\n- The reindexed “shifted” ordering (for example, via a function that moves the zero-frequency to the center), with indices $s_a \\in \\{0,1,\\dots,N_a-1\\}$ corresponding to ascending signed frequencies from negative to positive.\n\nTo ensure the generated Gaussian random field and all derived first-order and second-order Lagrangian perturbation theory displacement fields are strictly real in real space, it is necessary to use the correct integer-frequency mapping from FFT array indices to physical $\\mathbf{k}$ values under each convention, and to apply the correct treatment of the zero and Nyquist modes that are self-conjugate.\n\nWhich option correctly specifies:\n(i) the mapping from FFT array indices to the integer triplet $(m_x, m_y, m_z)$ and hence to physical $\\mathbf{k}$ for both the unshifted and shifted conventions in three dimensions (covering even and odd $N_a$), and\n(ii) the correct handling of the zero and Nyquist modes needed to satisfy $\\tilde{\\delta}(-\\mathbf{k}) = \\tilde{\\delta}(\\mathbf{k})^*$ so that $\\delta(\\mathbf{x})$ is real?\n\nChoose the best option.\n\nA. Unshifted mapping: for each axis $a$ with size $N_a$ and raw index $i_a \\in \\{0,\\dots,N_a-1\\}$, define the integer frequency\n$$\nm_a(i_a) = \\begin{cases} i_a, & \\text{if } 0 \\le i_a \\le \\frac{N_a}{2} \\text{ (even } N_a) \\\\ i_a - N_a, & \\text{if } \\frac{N_a}{2} < i_a \\le N_a - 1 \\text{ (even } N_a) \\\\ i_a, & \\text{if } 0 \\le i_a \\le \\frac{N_a - 1}{2} \\text{ (odd } N_a) \\\\ i_a - N_a, & \\text{if } \\frac{N_a + 1}{2} \\le i_a \\le N_a - 1 \\text{ (odd } N_a) \\end{cases}\n$$\nShifted mapping: for each axis $a$ with shifted index $s_a \\in \\{0,\\dots,N_a - 1\\}$, define\n$$\nm_a(s_a) = s_a - \\left\\lfloor \\tfrac{N_a}{2} \\right\\rfloor,\n$$\nso that the signed integers ascend from $- \\left\\lfloor \\tfrac{N_a}{2} \\right\\rfloor$ to $+\\left\\lceil \\tfrac{N_a}{2} \\right\\rceil - 1$. The physical wavevector is\n$$\nk_a = \\frac{2\\pi m_a}{L_a}, \\quad \\mathbf{k} = (k_x, k_y, k_z).\n$$\nZero and Nyquist handling: enforce $\\tilde{\\delta}(-\\mathbf{k}) = \\tilde{\\delta}(\\mathbf{k})^*$ by pairing distinct modes; for any mode that is its own negative under the discrete symmetry $2 m_a \\equiv 0 \\pmod{N_a}$ for all $a$ (that is, each component $m_a \\in \\{0, N_a/2\\}$ when $N_a$ is even), set $\\tilde{\\delta}(\\mathbf{k})$ to be purely real. In particular, the zero mode $(m_x,m_y,m_z)=(0,0,0)$ and the full set of “corner” Nyquist combinations with $m_a \\in \\{0, N_a/2\\}$ (when applicable) are real. All other modes are handled by Hermitian pairing.\n\nB. Unshifted mapping: $k_a = \\dfrac{2\\pi i_a}{L_a}$ for $i_a \\in \\{0,\\dots,N_a-1\\}$ with no wrap-around; shifted mapping: $k_a = \\dfrac{2\\pi s_a}{L_a}$. Zero and Nyquist handling: only the zero mode must be real; Nyquist modes can be complex with independent real and imaginary parts because their negatives are represented elsewhere.\n\nC. Unshifted mapping: $m_a(i_a) = i_a$ for $i_a < \\tfrac{N_a}{2}$ and $m_a(i_a) = \\tfrac{N_a}{2} - i_a$ for $i_a \\ge \\tfrac{N_a}{2}$; shifted mapping: $m_a(s_a) = s_a$ for all $s_a$. Physical wavenumbers are $k_a = \\dfrac{m_a}{\\Delta_a}$ without the factor of $2\\pi$. Zero and Nyquist handling: set the imaginary part to zero only when exactly one axis is at the Nyquist value; the zero mode need not be constrained because Hermitian symmetry will enforce reality after the inverse FFT.\n\nD. Unshifted mapping: $m_a(i_a) = i_a - N_a$ for all $i_a$; shifted mapping: $m_a(s_a) = s_a - N_a$ so that negative indices occupy the first half but zero frequency is at index $s_a = N_a$. Physical wavenumbers are $k_a = \\dfrac{\\pi m_a}{L_a}$ limited to the range $\\lvert k_a \\rvert \\le \\dfrac{\\pi}{\\Delta_a}$. Zero and Nyquist handling: treat all modes, including zero and Nyquist, as independent complex degrees of freedom and rely on numerical roundoff to cancel imaginary parts in real space.", "solution": "We begin from the periodic Fourier series on a finite three-dimensional domain. For each axis $a \\in \\{x,y,z\\}$, the continuous representation of a field on a periodic domain of length $L_a$ admits discrete Fourier modes with physical wavenumbers\n$$\nk_a = \\frac{2\\pi m_a}{L_a}, \\quad m_a \\in \\mathbb{Z}.\n$$\nSampling on a uniform grid $\\{n_a \\in \\{0,\\dots,N_a-1\\}\\}$ selects a finite set of these integers $m_a$ with associated discrete Fourier transform coefficients $\\tilde{\\delta}(\\mathbf{k}_{\\mathbf{m}})$, and the inverse transform reconstructs the field via\n$$\n\\delta(\\mathbf{x}_{\\mathbf{n}}) = \\sum_{m_x} \\sum_{m_y} \\sum_{m_z} \\tilde{\\delta}(\\mathbf{k}_{\\mathbf{m}}) \\exp\\!\\left(i \\left(\\frac{2\\pi m_x}{L_x} n_x \\Delta_x + \\frac{2\\pi m_y}{L_y} n_y \\Delta_y + \\frac{2\\pi m_z}{L_z} n_z \\Delta_z\\right)\\right),\n$$\nwith $\\Delta_a = L_a/N_a$ and $\\mathbf{x}_{\\mathbf{n}} = (n_x \\Delta_x, n_y \\Delta_y, n_z \\Delta_z)$. The discrete Fourier transform implements these sums in a particular index ordering determined by the FFT convention.\n\nThe key is the mapping from FFT array indices to the integer frequencies $\\mathbf{m} = (m_x, m_y, m_z)$, which then map to the physical $\\mathbf{k}$ via $k_a = 2\\pi m_a / L_a$. Two common conventions are the raw “unshifted” ordering and the “fftshifted” ordering.\n\nUnshifted ordering. For each axis $a$, the FFT output array has indices $i_a \\in \\{0,1,\\dots,N_a-1\\}$. The frequencies are ordered so that nonnegative integers appear first, followed by negative integers. For even $N_a$, the standard unshifted sequence of integers is\n$$\n0,\\;1,\\;2,\\;\\dots,\\;\\frac{N_a}{2},\\;-\\frac{N_a}{2}+1,\\;-\\frac{N_a}{2}+2,\\;\\dots,\\;-1,\n$$\nwhich corresponds to the mapping\n$$\nm_a(i_a) = \\begin{cases} i_a, & 0 \\le i_a \\le \\frac{N_a}{2} \\\\ i_a - N_a, & \\frac{N_a}{2} < i_a \\le N_a - 1 \\end{cases}\n$$\nFor odd $N_a$, there is no Nyquist integer; the sequence is\n$$\n0,\\;1,\\;2,\\;\\dots,\\;\\frac{N_a-1}{2},\\;-\\frac{N_a-1}{2},\\;-\\frac{N_a-1}{2}+1,\\;\\dots,\\;-1,\n$$\nand the mapping becomes\n$$\nm_a(i_a) = \\begin{cases} i_a, & 0 \\le i_a \\le \\frac{N_a - 1}{2} \\\\ i_a - N_a, & \\frac{N_a + 1}{2} \\le i_a \\le N_a - 1 \\end{cases}\n$$\nThese expressions encode the wrap-around (modulo $N_a$) of negative frequencies into the upper half of the index range.\n\nShifted ordering. After reindexing by a “shift” that moves the zero frequency to the middle of the array (such as an “fftshift”), the sequence of integers per axis $a$ is ascending from negative to positive. For even $N_a$, it is\n$$\n-\\frac{N_a}{2},\\;-\\frac{N_a}{2}+1,\\;\\dots,\\;-1,\\;0,\\;1,\\;\\dots,\\;\\frac{N_a}{2}-1,\n$$\nand for odd $N_a$, it is\n$$\n-\\frac{N_a - 1}{2},\\;-\\frac{N_a - 1}{2}+1,\\;\\dots,\\;-1,\\;0,\\;1,\\;\\dots,\\;\\frac{N_a - 1}{2}.\n$$\nA compact mapping that covers both cases is\n$$\nm_a(s_a) = s_a - \\left\\lfloor \\frac{N_a}{2} \\right\\rfloor, \\quad s_a \\in \\{0,\\dots,N_a - 1\\},\n$$\nwhich yields the desired ordered integer sequence. In all cases, the physical wavevector components follow from $k_a = 2\\pi m_a/L_a$.\n\nReality and Hermitian symmetry. For a real field $\\delta(\\mathbf{x})$, the discrete Fourier coefficients must satisfy Hermitian symmetry,\n$$\n\\tilde{\\delta}(-\\mathbf{k}) = \\tilde{\\delta}(\\mathbf{k})^*,\n$$\nso that the inverse transform is real. For modes where $-\\mathbf{k}$ is at a distinct array index from $\\mathbf{k}$, this is enforced by generating a complex coefficient at $\\mathbf{k}$ and setting the coefficient at $-\\mathbf{k}$ to its complex conjugate. However, whenever a mode is its own negative under the discrete symmetry, the Hermitian condition reduces to $\\tilde{\\delta}(\\mathbf{k}) = \\tilde{\\delta}(\\mathbf{k})^*$, implying that the coefficient is purely real. In the discrete setting, a mode is self-conjugate if and only if, for each axis $a$, the integer $m_a$ satisfies\n$$\n2 m_a \\equiv 0 \\pmod{N_a},\n$$\nwhich means $m_a \\in \\{0, N_a/2\\}$ when $N_a$ is even, and $m_a = 0$ when $N_a$ is odd. Therefore:\n- The zero mode $(m_x,m_y,m_z) = (0,0,0)$ is always purely real.\n- For even $N_a$, any “corner” combination with each component $m_a \\in \\{0, N_a/2\\}$ is self-conjugate and must be purely real. There are up to $2^d$ such points in $d$ dimensions (for $d=3$, up to $8$ points), depending on which axes have even sizes.\n- All other modes occur in $\\pm \\mathbf{k}$ pairs and must be set as complex-conjugate pairs.\n\nThis is essential in cosmological initial condition generation: improper handling of zero and Nyquist modes violates $\\tilde{\\delta}(-\\mathbf{k}) = \\tilde{\\delta}(\\mathbf{k})^*$ and yields complex contamination in real-space fields, corrupting both first-order displacements (Zel’dovich approximation) and second-order Lagrangian perturbation theory corrections.\n\nWe now assess the options.\n\nOption A. This option gives the correct unshifted mappings for even and odd $N_a$, properly capturing the wrap-around of negative integers into the upper half of the index range. It provides the compact shifted mapping $m_a = s_a - \\lfloor N_a/2 \\rfloor$. The physical $k_a$ are correctly given by $k_a = 2\\pi m_a/L_a$. For reality handling, it correctly states Hermitian pairing for distinct $\\pm \\mathbf{k}$ and that any mode that is its own negative (all components satisfying $2 m_a \\equiv 0 \\pmod{N_a}$) must be purely real, explicitly including the zero mode and all Nyquist corner combinations. This is the correct and complete specification.\n\nVerdict: Correct.\n\nOption B. This option maps $k_a$ linearly to the raw indices $i_a$ without wrap-around. It does not account for negative frequencies and thus cannot recover the signed integer spectrum; it also incorrectly maps shifted indices $s_a$ directly to positive $k_a$ values. In the handling of the zero and Nyquist modes, it erroneously claims the Nyquist modes can be complex with independent real and imaginary parts. That violates the self-conjugacy condition for modes with $m_a = N_a/2$ (when even), making the inverse transform non-real.\n\nVerdict: Incorrect.\n\nOption C. This option proposes $m_a(i_a) = i_a$ for $i_a < N_a/2$ and $m_a(i_a) = N_a/2 - i_a$ otherwise, which is not the standard unshifted mapping and produces incorrect negative-frequency indices (e.g., it flips sign and magnitude in a way that does not match modulo $N_a$ arithmetic). The shifted mapping $m_a(s_a) = s_a$ is also wrong because it fails to center zero and to include negative integers. The physical wavenumbers $k_a = m_a/\\Delta_a$ omit the necessary factor of $2\\pi$ and use the wrong scaling. The zero and Nyquist handling is incorrect: self-conjugacy depends on all axes, not just exactly one axis at Nyquist, and the zero mode must be constrained to be real explicitly.\n\nVerdict: Incorrect.\n\nOption D. This option sets $m_a(i_a) = i_a - N_a$ for all $i_a$, which incorrectly shifts the entire spectrum and places zero frequency at a negative integer, not matching any common FFT ordering. The shifted mapping $m_a(s_a) = s_a - N_a$ likewise misplaces zero at index $N_a$, which is outside the valid range. The physical wavenumbers $k_a = \\pi m_a/L_a$ are missing the factor of $2$, and the stated limit $\\lvert k_a \\rvert \\le \\pi/\\Delta_a$ is a sampling-theory statement, not a mapping rule; moreover, the mapping itself is wrong. The handling of zero and Nyquist modes as independent complex degrees of freedom is incorrect and will not ensure a real inverse field.\n\nVerdict: Incorrect.\n\nTherefore, the only option that correctly provides both the index-to-$\\mathbf{k}$ mappings for common FFT conventions and the necessary zero/Nyquist handling to preserve real-field consistency is Option A.", "answer": "$$\\boxed{A}$$", "id": "3512441"}, {"introduction": "Before applying a complex algorithm to a real-world problem, it is critical to verify its implementation against a known solution. This practice employs the 'method of manufactured solutions' to rigorously test the core of a Second-Order Lagrangian Perturbation Theory (2LPT) code. By injecting a simple, analytic first-order potential with a known tidal quadrupole, we can derive the exact analytic form of the second-order displacement field, providing a precise benchmark against which to validate our numerical results. [@problem_id:3512423]", "problem": "Design and implement a self-contained program that constructs a periodic, three-dimensional Lagrangian perturbation theory test harness to validate second-order Lagrangian perturbation theory (2LPT) anisotropic displacements induced by a known tidal quadrupole in the initial potential. Work entirely with dimensionless quantities on a periodic cube of side length $L$, and use discrete Fourier transforms to solve Poisson-type equations. The program must produce a single line of output containing a list of floating-point values, each corresponding to the maximum relative error between numerical and analytic root-mean-square (RMS) components of the 2LPT displacement for a specified test case.\n\nBegin from the following bases:\n- The Lagrangian displacement is expanded as $\\boldsymbol{\\Psi} = \\sum_{n \\ge 1} \\boldsymbol{\\Psi}^{(n)}$ with $\\boldsymbol{\\Psi}^{(n)} = -\\boldsymbol{\\nabla} \\phi^{(n)}$, where $\\phi^{(n)}$ is the scalar potential at order $n$.\n- The governing second-order equation for the scalar potential in second-order Lagrangian perturbation theory (2LPT) is\n$$\n\\nabla^2 \\phi^{(2)}(\\boldsymbol{x}) \\;=\\; \\sum_{i>j} \\left( \\phi^{(1)}_{,ii}(\\boldsymbol{x}) \\, \\phi^{(1)}_{,jj}(\\boldsymbol{x}) \\;-\\; \\left[\\phi^{(1)}_{,ij}(\\boldsymbol{x})\\right]^2 \\right),\n$$\nwhere $\\phi^{(1)}_{,ij} \\equiv \\partial_i \\partial_j \\phi^{(1)}$.\n\nInject a known, spatially periodic tidal quadrupole into the initial (first-order) potential by prescribing\n$$\n\\phi^{(1)}(\\boldsymbol{x}) \\;=\\; A \\sum_{i \\in \\{x,y,z\\}} a_i \\cos\\!\\left( K \\, x_i \\right),\n$$\nwith $A$ a dimensionless amplitude, $\\boldsymbol{a} = (a_x,a_y,a_z)$ a dimensionless coefficient triplet that encodes the quadrupolar anisotropy, and $K = 2\\pi m / L$ the fundamental wavenumber with integer mode index $m$. Use $m = 1$. Work on a regular grid with $N^3$ points on the periodic cube $[0,L)^3$.\n\nTasks to implement:\n1. Construct the real-space source term for the 2LPT scalar potential using only first-order second derivatives,\n$$\nS(\\boldsymbol{x}) \\;\\equiv\\; \\sum_{i>j} \\left( \\phi^{(1)}_{,ii} \\phi^{(1)}_{,jj} - \\left[\\phi^{(1)}_{,ij}\\right]^2 \\right).\n$$\nFor the separable cosine ansatz above, $\\phi^{(1)}_{,ij} = 0$ for $i \\neq j$ and $\\phi^{(1)}_{,ii} = -A \\, a_i \\, K^2 \\cos(K x_i)$, so that\n$$\nS(\\boldsymbol{x}) \\;=\\; A^2 K^4 \\left( a_x a_y \\cos(K x) \\cos(K y) \\;+\\; a_x a_z \\cos(K x) \\cos(K z) \\;+\\; a_y a_z \\cos(K y) \\cos(K z) \\right).\n$$\n2. Solve the Poisson equation for the second-order potential on the periodic cube using spectral methods,\n$$\n\\nabla^2 \\phi^{(2)}(\\boldsymbol{x}) \\;=\\; S(\\boldsymbol{x}),\n$$\nwith periodic boundary conditions and vanishing mean for $\\phi^{(2)}$. In Fourier space, for each nonzero wavevector $\\boldsymbol{k} = (k_x,k_y,k_z)$ with $k^2 = k_x^2 + k_y^2 + k_z^2$, the solution satisfies\n$$\n\\tilde{\\phi}^{(2)}(\\boldsymbol{k}) \\;=\\; - \\frac{\\tilde{S}(\\boldsymbol{k})}{k^2}, \\quad \\text{and} \\quad \\tilde{\\phi}^{(2)}(\\boldsymbol{0}) \\;=\\; 0,\n$$\nwhere tildes denote discrete Fourier transforms.\n3. Compute the second-order displacement field by spectral differentiation,\n$$\n\\tilde{\\Psi}^{(2)}_i(\\boldsymbol{k}) \\;=\\; i k_i \\, \\tilde{\\phi}^{(2)}(\\boldsymbol{k}), \\quad \\text{and inverse transform to obtain } \\Psi^{(2)}_i(\\boldsymbol{x}).\n$$\n4. Compute the numerical RMS of each component over the full grid,\n$$\n\\mathrm{RMS}^{\\mathrm{num}}_i \\;=\\; \\sqrt{\\langle \\left(\\Psi^{(2)}_i(\\boldsymbol{x})\\right)^2 \\rangle_{\\boldsymbol{x}} }.\n$$\n5. Derive and evaluate the analytic RMS for the chosen separable cosine ansatz. Using independence of factors across coordinates on the uniform grid and $\\langle \\sin^2(K x_i) \\rangle = 1/2$, $\\langle \\cos^2(K x_i) \\rangle = 1/2$, the $i$-th component’s RMS is\n$$\n\\mathrm{RMS}^{\\mathrm{ana}}_i \\;=\\; \\frac{A^2 K^3}{4} \\, \\sqrt{ a_i^2 \\left( \\sum_{j \\neq i} a_j^2 \\right) }.\n$$\n6. For each specified test case, report the maximum relative error across components,\n$$\n\\epsilon_{\\max} \\;=\\; \\max_{i \\in \\{x,y,z\\}} \\begin{cases} \\left| \\dfrac{\\mathrm{RMS}^{\\mathrm{num}}_i - \\mathrm{RMS}^{\\mathrm{ana}}_i}{\\mathrm{RMS}^{\\mathrm{ana}}_i} \\right|, & \\text{if}\\ \\mathrm{RMS}^{\\mathrm{ana}}_i \\neq 0 \\\\ \\left| \\mathrm{RMS}^{\\mathrm{num}}_i \\right|, & \\text{if}\\ \\mathrm{RMS}^{\\mathrm{ana}}_i = 0 \\end{cases}\n$$\n\nNumerical implementation requirements:\n- Use a periodic cube with side length $L = 1$ and grid size $N = 64$ for all tests.\n- Use $m = 1$, hence $K = 2\\pi$.\n- Use discrete Fourier transforms with wave numbers $k_i = 2\\pi \\, n_i / L$, where $n_i$ are the standard integer frequencies corresponding to the discrete Fourier transform on a grid of size $N$.\n- Use dimensionless units throughout.\n\nTest suite:\n- Case $1$: $(A, a_x, a_y, a_z) = (0.05, 1, -1, 0)$.\n- Case $2$: $(A, a_x, a_y, a_z) = (0.1, 1, 1, -2)$.\n- Case $3$: $(A, a_x, a_y, a_z) = (0.2, 0, 0, 0)$.\n\nRequired output:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases, for example, $[\\epsilon_1,\\epsilon_2,\\epsilon_3]$. Each $\\epsilon_i$ must be a floating-point number.\n\nNo physical units appear; all quantities are strictly dimensionless. Angles, when they appear inside trigonometric functions, are in radians by construction of the discrete Fourier representation.", "solution": "The user-provided problem is assessed as valid. It is scientifically sound, well-posed, objective, and contains all necessary information for a unique solution. The core task is to implement a numerical test of second-order Lagrangian Perturbation Theory (2LPT) against a prescribed analytic solution, a standard validation procedure in computational cosmology. The methodology relies on established principles of Fourier analysis for solving differential equations on periodic domains.\n\nThe following is a principled, step-by-step description of the implemented solution.\n\nThe program's objective is to compute the maximum relative error between a numerically calculated second-order Lagrangian displacement field, $\\boldsymbol{\\Psi}^{(2)}$, and its known analytical counterpart for a specific initial condition. The entire procedure is carried out on a three-dimensional periodic grid.\n\n**1. Grid and Constant Initialization**\nThe simulation domain is a periodic cube of side length $L=1$, discretized on a regular grid of $N^3$ points, with $N=64$. The fundamental wavenumber for the initial potential is $K = 2\\pi m / L$, where the mode index is $m=1$. Since $L=1$, this simplifies to $K=2\\pi$. We construct three-dimensional coordinate arrays $x, y, z$ representing the grid points $(x_i, y_j, z_k)$ for $i,j,k \\in \\{0, 1, \\dots, N-1\\}$.\n\n**2. Construction of the 2LPT Source Term**\nThe problem begins with a prescribed first-order potential, $\\phi^{(1)}$, which is a separable cosine ansatz:\n$$\n\\phi^{(1)}(\\boldsymbol{x}) \\;=\\; A \\sum_{i \\in \\{x,y,z\\}} a_i \\cos\\!\\left( K \\, x_i \\right)\n$$\nThe source term $S(\\boldsymbol{x})$ for the second-order potential, $\\phi^{(2)}$, is defined by the derivatives of $\\phi^{(1)}$:\n$$\nS(\\boldsymbol{x}) \\;\\equiv\\; \\sum_{i>j} \\left( \\phi^{(1)}_{,ii} \\phi^{(1)}_{,jj} - \\left[\\phi^{(1)}_{,ij}\\right]^2 \\right)\n$$\nFor the given separable form of $\\phi^{(1)}$, the cross-derivatives $\\phi^{(1)}_{,ij}$ for $i \\neq j$ are zero. The second derivatives are $\\phi^{(1)}_{,ii} = -A \\, a_i \\, K^2 \\cos(K x_i)$. Substituting these into the definition of $S(\\boldsymbol{x})$ yields the analytical expression used in the code:\n$$\nS(\\boldsymbol{x}) \\;=\\; A^2 K^4 \\left( a_x a_y \\cos(K x) \\cos(K y) \\;+\\; a_x a_z \\cos(K x) \\cos(K z) \\;+\\; a_y a_z \\cos(K y) \\cos(K z) \\right)\n$$\nThis source term is evaluated on the real-space grid for the given parameters $A$ and $\\boldsymbol{a}=(a_x, a_y, a_z)$ of each test case.\n\n**3. Spectral Solution for the Second-Order Potential**\nThe second-order potential $\\phi^{(2)}$ is governed by the Poisson equation $\\nabla^2 \\phi^{(2)}(\\boldsymbol{x}) = S(\\boldsymbol{x})$. On a periodic domain, this equation is most efficiently solved using spectral methods.\nFirst, the source term is transformed into Fourier space using the three-dimensional Fast Fourier Transform (FFT), $\\tilde{S}(\\boldsymbol{k}) = \\mathcal{F}[S(\\boldsymbol{x})]$, which is implemented with `scipy.fft.fftn`.\nIn Fourier space, the Laplacian operator $\\nabla^2$ becomes multiplication by $-k^2$, where $k^2 = k_x^2 + k_y^2 + k_z^2$ is the squared magnitude of the wavevector $\\boldsymbol{k}$. The discrete wavevectors $k_i$ corresponding to the grid are generated using `scipy.fft.fftfreq`.\nThe Poisson equation thus transforms into an algebraic equation for the Fourier modes of the potential:\n$$\n-k^2 \\tilde{\\phi}^{(2)}(\\boldsymbol{k}) = \\tilde{S}(\\boldsymbol{k}) \\quad \\implies \\quad \\tilde{\\phi}^{(2)}(\\boldsymbol{k}) = - \\frac{\\tilde{S}(\\boldsymbol{k})}{k^2}\n$$\nThis solution is valid for all $\\boldsymbol{k} \\neq \\boldsymbol{0}$. For the zero-frequency mode ($\\boldsymbol{k}=\\boldsymbol{0}$), division by $k^2=0$ is undefined. The physical constraint of zero mean for the potential, $\\langle \\phi^{(2)} \\rangle=0$, sets the Fourier-space DC component to zero, $\\tilde{\\phi}^{(2)}(\\boldsymbol{0})=0$. This is handled explicitly in the code.\n\n**4. Computation of the 2LPT Displacement Field**\nThe 2LPT displacement field is the negative gradient of the potential, $\\boldsymbol{\\Psi}^{(2)} = -\\boldsymbol{\\nabla}\\phi^{(2)}$. Similar to the Laplacian, the gradient operator has a simple representation in Fourier space: $\\mathcal{F}[\\boldsymbol{\\nabla} f(\\boldsymbol{x})] = i\\boldsymbol{k}\\tilde{f}(\\boldsymbol{k})$.\nTherefore, the Fourier modes of the displacement field components are computed by:\n$$\n\\tilde{\\Psi}^{(2)}_i(\\boldsymbol{k}) = -i k_i \\tilde{\\phi}^{(2)}(\\boldsymbol{k})\n$$\nOnce the Fourier-space displacement components $\\tilde{\\Psi}^{(2)}_i(\\boldsymbol{k})$ are calculated, they are transformed back to real space using the inverse FFT (`scipy.fft.ifftn`). Since the original field is real, the resulting displacement components $\\Psi^{(2)}_i(\\boldsymbol{x})$ must also be real. We explicitly take the real part of the inverse FFT output to discard any small, spurious imaginary components arising from floating-point inaccuracies.\n\n**5. Validation and Error Calculation**\nThe final part of the process is to validate the numerical result.\nThe numerical root-mean-square (RMS) of each displacement component is computed by taking the square root of the mean of the squared field values over the entire grid:\n$$\n\\mathrm{RMS}^{\\mathrm{num}}_i \\;=\\; \\sqrt{\\frac{1}{N^3} \\sum_{\\boldsymbol{x}} \\left(\\Psi^{(2)}_i(\\boldsymbol{x})\\right)^2 }\n$$\nThis is implemented using `numpy.sqrt` and `numpy.mean`.\nThese numerical results are compared against the analytically derived RMS values, provided in the problem statement:\n$$\n\\mathrm{RMS}^{\\mathrm{ana}}_i \\;=\\; \\frac{A^2 K^3}{4} \\, \\sqrt{ a_i^2 \\left( \\sum_{j \\neq i} a_j^2 \\right) }\n$$\nFor each component $i \\in \\{x,y,z\\}$, the relative error is computed. A conditional check is necessary to handle cases where the analytical RMS is zero. If $\\mathrm{RMS}^{\\mathrm{ana}}_i = 0$, the error is defined as the absolute value of the numerical RMS, $|\\mathrm{RMS}^{\\mathrm{num}}_i|$. Otherwise, it is the standard relative error, $|\\mathrm{RMS}^{\\mathrm{num}}_i - \\mathrm{RMS}^{\\mathrm{ana}}_i| / |\\mathrm{RMS}^{\\mathrm{ana}}_i|$.\nThe final output for each test case is the maximum of these three component-wise errors, $\\epsilon_{\\max}$. This entire procedure is repeated for all specified test cases.", "answer": "```python\nimport numpy as np\nfrom scipy import fft\n\ndef compute_2lpt_error(params):\n    \"\"\"\n    Computes the maximum relative error for 2LPT displacement for one test case.\n\n    This function implements the full chain:\n    1. Set up the grid and initial potential parameters.\n    2. Compute the real-space source term S(x).\n    3. Solve the Poisson equation for phi^(2) in Fourier space.\n    4. Compute the displacement field Psi^(2) via spectral differentiation.\n    5. Calculate numerical and analytical RMS values.\n    6. Return the maximum relative error across components.\n    \"\"\"\n    # Unpack test case parameters\n    A, ax, ay, az = params\n\n    # Numerical and physical constants\n    L = 1.0\n    N = 64\n    m = 1\n    K = 2.0 * np.pi * m / L\n\n    # 1. Construct the real-space grid\n    grid_1d = np.arange(N, dtype=float) * L / N\n    # Use 'ij' indexing for coordinate arrays to match the typical (x,y,z) loop order\n    x, y, z = np.meshgrid(grid_1d, grid_1d, grid_1d, indexing='ij')\n\n    # 2. Construct the real-space source term for the 2LPT scalar potential\n    S = A**2 * K**4 * (\n        ax * ay * np.cos(K * x) * np.cos(K * y) +\n        ax * az * np.cos(K * x) * np.cos(K * z) +\n        ay * az * np.cos(K * y) * np.cos(K * z)\n    )\n\n    # 3. Solve the Poisson equation using spectral methods\n    # Fourier transform the source term\n    S_k = fft.fftn(S)\n\n    # Create the k-space grid of wavevectors\n    k_freq = fft.fftfreq(N, d=L / N) * 2.0 * np.pi\n    kx, ky, kz = np.meshgrid(k_freq, k_freq, k_freq, indexing='ij')\n    \n    # Calculate k-squared, handling the k=0 mode to avoid division by zero\n    k_squared = kx**2 + ky**2 + kz**2\n    # The [0,0,0] element is the DC mode (k=0).\n    # Temporarily set k_squared[0,0,0] to a non-zero value to avoid a warning.\n    k_squared[0, 0, 0] = 1.0\n\n    # Solve for phi_2_k = -S_k / k^2\n    phi2_k = -S_k / k_squared\n    # Enforce zero mean for phi^(2) by setting the k=0 mode to zero.\n    phi2_k[0, 0, 0] = 0.0\n\n    # 4. Compute the second-order displacement field by spectral differentiation\n    # Psi_i = -grad_i phi  =>  Psi_i_k = -i * k_i * phi_k\n    Psi2x_k = -1j * kx * phi2_k\n    Psi2y_k = -1j * ky * phi2_k\n    Psi2z_k = -1j * kz * phi2_k\n\n    # Inverse transform to get real-space displacement fields\n    Psi2x = fft.ifftn(Psi2x_k).real\n    Psi2y = fft.ifftn(Psi2y_k).real\n    Psi2z = fft.ifftn(Psi2z_k).real\n\n    # 5. Compute the numerical RMS of each displacement component\n    rms_num_x = np.sqrt(np.mean(Psi2x**2))\n    rms_num_y = np.sqrt(np.mean(Psi2y**2))\n    rms_num_z = np.sqrt(np.mean(Psi2z**2))\n    rms_num = np.array([rms_num_x, rms_num_y, rms_num_z])\n\n    # 6. Derive and evaluate the analytic RMS\n    prefactor = (A**2 * K**3) / 4.0\n    a = np.array([ax, ay, az])\n    \n    rms_ana_x = prefactor * np.sqrt(a[0]**2 * (a[1]**2 + a[2]**2))\n    rms_ana_y = prefactor * np.sqrt(a[1]**2 * (a[0]**2 + a[2]**2))\n    rms_ana_z = prefactor * np.sqrt(a[2]**2 * (a[0]**2 + a[1]**2))\n    rms_ana = np.array([rms_ana_x, rms_ana_y, rms_ana_z])\n\n    # 7. Compute the maximum relative error across components\n    errors = np.zeros(3)\n    for i in range(3):\n        if rms_ana[i] != 0.0:\n            errors[i] = np.abs((rms_num[i] - rms_ana[i]) / rms_ana[i])\n        else:\n            errors[i] = np.abs(rms_num[i])\n            \n    return np.max(errors)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.05, 1.0, -1.0, 0.0),   # Case 1\n        (0.1, 1.0, 1.0, -2.0),    # Case 2\n        (0.2, 0.0, 0.0, 0.0),     # Case 3\n    ]\n\n    results = []\n    for case in test_cases:\n        max_error = compute_2lpt_error(case)\n        results.append(max_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3512423"}, {"introduction": "With the foundational tools for Fourier analysis and code verification in place, we now tackle a complete, end-to-end problem: generating multi-species initial conditions for a cosmological simulation. This capstone exercise integrates the generation of a Gaussian random field with the physics of different matter components, described by unique transfer functions. You will implement the full 1LPT and 2LPT displacement calculations and, crucially, perform the statistical validation checks that ensure the final particle distribution is a faithful and numerically robust representation of our theoretical model. [@problem_id:3512400]", "problem": "You are tasked with constructing a program that generates three-dimensional cosmological initial conditions for two pressureless species on a periodic cubic domain using Gaussian random fields and Second-Order Lagrangian Perturbation Theory (2LPT). The program must compute species-specific Fourier-space overdensity fields, displacements using the first-order Zel'dovich approximation and 2LPT sourced by the total matter field, and verify that the total matter power spectrum equals the theoretically expected weighted sum based on species fractions and transfer functions.\n\nUse a cubic grid with side length $L$ and $N^3$ uniformly spaced cells with periodic boundary conditions. Work entirely in a dimensionless system; no physical units are required. Use radians for any angular quantities if they arise implicitly in the definition of the Fourier wavenumbers.\n\nFundamental base:\n- The domain is a periodic cube, and the Fourier wavenumbers are $k_x = \\frac{2\\pi}{L} n_x$, $k_y = \\frac{2\\pi}{L} n_y$, $k_z = \\frac{2\\pi}{L} n_z$, where $n_i \\in \\mathbb{Z}$ are the integer grid wave indices defined by the Fast Fourier Transform (FFT).\n- A statistically homogeneous and isotropic Gaussian random field $\\delta(\\mathbf{x})$ is defined in Fourier space by $\\delta(\\mathbf{k}) = \\sqrt{P(k)}\\,G(\\mathbf{k})$, where $P(k)$ is the isotropic power spectrum and $G(\\mathbf{k})$ is a complex Gaussian random field with zero mean, unit variance per independent mode, and Hermitian symmetry ensuring a real $\\delta(\\mathbf{x})$.\n- For two species with mass fractions $f_1$ and $f_2$ satisfying $f_1 + f_2 = 1$, the adiabatic construction uses a single Gaussian random field $G(\\mathbf{k})$ and species transfer functions $T_1(k)$ and $T_2(k)$ so that $\\delta_1(\\mathbf{k}) = T_1(k)\\sqrt{P_0(k)}\\,G(\\mathbf{k})$ and $\\delta_2(\\mathbf{k}) = T_2(k)\\sqrt{P_0(k)}\\,G(\\mathbf{k})$. The total matter overdensity is $\\delta_m(\\mathbf{k}) = f_1\\delta_1(\\mathbf{k}) + f_2\\delta_2(\\mathbf{k})$.\n- The first-order Lagrangian displacement (Zel'dovich) field satisfies $\\boldsymbol{\\Psi}^{(1)}(\\mathbf{k}) = i\\,\\frac{\\mathbf{k}}{k^2}\\,\\delta_m(\\mathbf{k})$ for $\\mathbf{k} \\neq \\mathbf{0}$, with the zero mode set to zero.\n- Define the first-order potential $\\phi^{(1)}$ by the Poisson relation $\\nabla^2 \\phi^{(1)}(\\mathbf{x}) = \\delta_m(\\mathbf{x})$, i.e., $\\phi^{(1)}(\\mathbf{k}) = -\\delta_m(\\mathbf{k})/k^2$ for $\\mathbf{k} \\neq \\mathbf{0}$ and zero at $\\mathbf{k}=\\mathbf{0}$. The standard 2LPT source term in real space is \n$$\nS_2(\\mathbf{x}) = \\sum_{i>j}\\Big(\\phi^{(1)}_{,ii}(\\mathbf{x})\\,\\phi^{(1)}_{,jj}(\\mathbf{x}) - \\left[\\phi^{(1)}_{,ij}(\\mathbf{x})\\right]^2\\Big),\n$$\nwhere commas denote spatial derivatives. The 2LPT potential satisfies $\\nabla^2 \\phi^{(2)}(\\mathbf{x}) = S_2(\\mathbf{x})$, hence $\\phi^{(2)}(\\mathbf{k}) = -S_2(\\mathbf{k})/k^2$ for $\\mathbf{k} \\neq \\mathbf{0}$, and the second-order displacement is $\\boldsymbol{\\Psi}^{(2)}(\\mathbf{x}) = -\\nabla \\phi^{(2)}(\\mathbf{x})$.\n\nProgram requirements:\n1. Construct the isotropic base power spectrum\n$$\nP_0(k) = A\\,k^{n}\\,\\exp\\left[-\\left(\\frac{k}{k_c}\\right)^8\\right],\n$$\nwith constants $A$, $n$, and $k_c$ provided per test case. Let the total matter transfer be $T_m(k) \\equiv 1$. For species $1$, use a shape\n$$\nT_1(k) = 1 + a\\,e^{-(k/k_0)^2} - \\tfrac{1}{2}a\\,e^{-(k/k_1)^2},\n$$\nwith parameters $a$, $k_0$, and $k_1$ given per test case. Enforce adiabaticity by defining\n$$\nT_2(k) = \\frac{T_m(k) - f_1 T_1(k)}{f_2},\n$$\nfor $f_2 \\neq 0$. Use the same realization $G(\\mathbf{k})$ in both species so that\n$\n\\delta_s(\\mathbf{k}) = T_s(k)\\sqrt{P_0(k)}\\,G(\\mathbf{k})\n$\nfor $s\\in\\{1,2\\}$ and\n$\n\\delta_m(\\mathbf{k}) = \\left[f_1 T_1(k) + f_2 T_2(k)\\right]\\sqrt{P_0(k)}\\,G(\\mathbf{k}).\n$\nGenerate $G(\\mathbf{k})$ by FFT of a real-space white noise field to ensure Hermitian symmetry, and carry all fields on the full three-dimensional grid.\n\n2. Compute the first-order Zel'dovich displacement $\\boldsymbol{\\Psi}^{(1)}(\\mathbf{k})$ from $\\delta_m(\\mathbf{k})$. Compute $\\phi^{(1)}$ by solving the Poisson equation in Fourier space, construct the second derivatives $\\phi^{(1)}_{,ij}(\\mathbf{x})$ via spectral differentiation, assemble $S_2(\\mathbf{x})$, solve for $\\phi^{(2)}(\\mathbf{k})$, and compute the second-order displacement $\\boldsymbol{\\Psi}^{(2)}(\\mathbf{x})$.\n\n3. Verification of the total matter field:\n   - Estimate the spherically averaged total matter power spectrum by binning $|\\delta_m(\\mathbf{k})|^2$ into shells of width $\\Delta k = 2\\pi/L$ in $k$-space, excluding the zero mode and any shell with fewer than a minimum number of contributing modes (choose a threshold that ensures numerical stability).\n   - For each shell, compute the predicted power by binning\n   $$\n   \\left|G(\\mathbf{k})\\right|^2\\,\\left[f_1 T_1(k) + f_2 T_2(k)\\right]^2 P_0(k)\n   $$\n   over the same modes in that shell. Take the ratio of the measured to predicted binned powers. Report the maximum absolute fractional deviation across accepted shells, restricted to wavenumbers below a conservative fraction of the Nyquist wavenumber to avoid anisotropy at the grid limit.\n   - Independently verify the first-order kinematic consistency by computing the relative root-mean-square error of the identity $-\\nabla\\cdot\\boldsymbol{\\Psi}^{(1)}(\\mathbf{x}) = \\delta_m(\\mathbf{x})$, using spectral derivatives. Report this relative error.\n\nYour program must implement the above and produce, for each test case, a pair of floating-point numbers: the maximum absolute fractional deviation in the power-spectrum check, and the relative root-mean-square error of the first-order divergence identity. Aggregate the results for all test cases as a list of lists on a single output line. Do not print any additional text.\n\nTest suite:\nProvide results for the following three test cases. All symbols are as defined above, and all numbers are to be interpreted as dimensionless values consistent with the chosen units:\n- Case A (general case): $N=32$, $L=200$, $f_1=0.84$, $f_2=0.16$, $A=1$, $n=1$, $k_c=3$, $a=0.2$, $k_0=0.3$, $k_1=1.0$.\n- Case B (nearly single-species limit): $N=24$, $L=150$, $f_1=0.99$, $f_2=0.01$, $A=1$, $n=1$, $k_c=3$, $a=-0.3$, $k_0=0.4$, $k_1=1.2$.\n- Case C (equal fractions with stronger scale dependence): $N=28$, $L=220$, $f_1=0.5$, $f_2=0.5$, $A=1$, $n=1$, $k_c=3$, $a=0.5$, $k_0=0.25$, $k_1=0.9$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a two-element list of the two floats per test case. For example, the format must be exactly\n$\n[[x_1,y_1],[x_2,y_2],[x_3,y_3]]\n$\nwith no spaces anywhere in the line.", "solution": "The user's problem is assessed to be valid. It is scientifically grounded in the standard cosmological perturbation theory framework, well-posed with a clear algorithmic path to a unique solution for a given random seed, and all necessary parameters and equations are provided. The task is a standard, albeit multi-step, procedure in computational cosmology.\n\nThe solution proceeds by implementing the specified algorithm. The core steps are: 1) setting up the computational grid in Fourier space, 2) generating a Gaussian random field with the appropriate statistical properties, 3) constructing the matter density and LPT displacement fields, and 4) performing the required verification checks.\n\n**1. Grid and Wavenumber Representation**\nThe simulation is performed on a cubic grid of size $N \\times N \\times N$ representing a physical volume of side length $L$. We operate in Fourier space, which is natural for a periodic domain. The discrete wavevectors are given by $\\mathbf{k} = (k_x, k_y, k_z)$, where each component $k_i$ for $i \\in \\{x, y, z\\}$ is defined as $k_i = \\frac{2\\pi}{L} n_i$. The indices $n_i$ are integers spanning the range appropriate for a Fast Fourier Transform (FFT), typically from $-N/2$ to $N/2-1$. These wavevector components are readily generated using `numpy.fft.fftfreq` and `numpy.meshgrid` to form three-dimensional arrays $k_x, k_y, k_z$. From these, the magnitude of each wavevector, $k = \\sqrt{k_x^2 + k_y^2 + k_z^2}$, is computed. The special case $\\mathbf{k}=\\mathbf{0}$ (the \"DC mode\") must be handled carefully to avoid division by zero in subsequent steps. An inverse squared wavenumber field, $1/k^2$, is pre-computed with its value at $k=0$ explicitly set to $0$.\n\n**2. Generation of the Gaussian Random Field**\nA statistically homogeneous and isotropic Gaussian random field is characterized in Fourier space by its modes $\\delta(\\mathbf{k})$. The phases of these modes are random, and their amplitudes are drawn from a Rayleigh distribution such that $\\langle |\\delta(\\mathbf{k})|^2 \\rangle = P(k)$, where $P(k)$ is the power spectrum. To guarantee that the field is real in configuration space, the Fourier modes must obey the Hermitian symmetry condition $\\delta(-\\mathbf{k}) = \\delta^*(\\mathbf{k})$.\n\nThe problem specifies generating a complex Gaussian field $G(\\mathbf{k})$ with zero mean, unit variance per independent mode, and Hermitian symmetry. An effective way to satisfy these properties is to first generate a real-space white noise field, $w(\\mathbf{x})$, by drawing $N^3$ values from a standard normal distribution. The FFT of this real field, $G(\\mathbf{k}) = \\mathcal{F}[w(\\mathbf{x})]$, automatically satisfies the Hermitian property. The mean of the field is set to zero by explicitly nullifying the $k=0$ mode, $G(\\mathbf{k}=\\mathbf{0})=0$.\n\n**3. Construction of Matter and Displacement Fields**\nWith the base random field $G(\\mathbf{k})$ established, we construct all other fields.\n*   **Power Spectrum and Transfer Functions**: The base power spectrum $P_0(k) = A k^n \\exp[-(k/k_c)^8]$ and the species-1 transfer function $T_1(k) = 1 + a e^{-(k/k_0)^2} - \\frac{1}{2}a e^{-(k/k_1)^2}$ are computed for all values of $k$ on the grid.\n*   **Total Matter Overdensity**: The problem specifies an adiabatic setup where the total matter transfer function $T_m(k) \\equiv 1$. The species-2 transfer function is defined as $T_2(k) = (T_m(k) - f_1 T_1(k))/f_2$. This enforces that the mass-weighted total transfer function, $f_1 T_1(k) + f_2 T_2(k)$, is identically equal to $T_m(k) = 1$. Consequently, the total matter overdensity field in Fourier space simplifies to $\\delta_m(\\mathbf{k}) = [f_1 T_1(k) + f_2 T_2(k)] \\sqrt{P_0(k)} G(\\mathbf{k}) = \\sqrt{P_0(k)} G(\\mathbf{k})$.\n\n*   **First-Order (Zel'dovich) Displacement**: The displacement field $\\boldsymbol{\\Psi}^{(1)}$ is related to the overdensity by $\\nabla \\cdot \\boldsymbol{\\Psi}^{(1)}(\\mathbf{x}) = -\\delta_m(\\mathbf{x})$. In Fourier space, this becomes $i\\mathbf{k} \\cdot \\boldsymbol{\\Psi}^{(1)}(\\mathbf{k}) = -\\delta_m(\\mathbf{k})$. The irrotational nature of this initial displacement allows us to write it as the gradient of a potential, $\\boldsymbol{\\Psi}^{(1)} = -\\nabla \\phi^{(1)}$, leading to the expression $\\boldsymbol{\\Psi}^{(1)}(\\mathbf{k}) = i \\frac{\\mathbf{k}}{k^2} \\delta_m(\\mathbf{k})$. This vector field is computed component-wise in Fourier space.\n\n*   **Second-Order (2LPT) Displacement**: The 2LPT calculation involves several steps:\n    1.  The first-order potential $\\phi^{(1)}$ is found by solving the Poisson equation $\\nabla^2 \\phi^{(1)} = \\delta_m$. In Fourier space, this is a simple algebraic relation: $\\phi^{(1)}(\\mathbf{k}) = -\\delta_m(\\mathbf{k})/k^2$.\n    2.  The second-order source term, $S_2(\\mathbf{x}) = \\sum_{i>j}(\\phi^{(1)}_{,ii}\\phi^{(1)}_{,jj} - [\\phi^{(1)}_{,ij}]^2)$, is constructed in real space. This requires computing all second spatial derivatives of $\\phi^{(1)}(\\mathbf{x})$. These are calculated efficiently in Fourier space, where differentiation corresponds to multiplication by wavevectors: $\\phi^{(1)}_{,ij}(\\mathbf{x}) = \\mathcal{F}^{-1}[-k_i k_j \\phi^{(1)}(\\mathbf{k})]$.\n    3.  After computing the six unique second derivatives ($\\phi^{(1)}_{,xx}$, $\\phi^{(1)}_{,yy}$, $\\phi^{(1)}_{,zz}$, $\\phi^{(1)}_{,xy}$, $\\phi^{(1)}_{,xz}$, $\\phi^{(1)}_{,yz}$), they are multiplied as per the formula for $S_2(\\mathbf{x})$ at each grid point.\n    4.  The second-order potential $\\phi^{(2)}$ is found by solving another Poisson equation, $\\nabla^2 \\phi^{(2)} = S_2$. Again, this is done in Fourier space: $\\phi^{(2)}(\\mathbf{k}) = -S_2(\\mathbf{k})/k^2$, where $S_2(\\mathbf{k}) = \\mathcal{F}[S_2(\\mathbf{x})]$.\n    5.  Finally, the second-order displacement is the negative gradient of this potential, $\\boldsymbol{\\Psi}^{(2)}(\\mathbf{x}) = -\\nabla \\phi^{(2)}(\\mathbf{x})$, which in Fourier space is $\\boldsymbol{\\Psi}^{(2)}(\\mathbf{k}) = -i\\mathbf{k}\\,\\phi^{(2)}(\\mathbf{k})$.\n\n**4. Verification Procedures**\nTwo numerical checks are performed to validate the implementation.\n*   **Power Spectrum Verification**: This check compares the numerically realized power spectrum against the theoretical expectation. The \"measured\" power per mode is $|\\delta_m(\\mathbf{k})|^2$. The \"predicted\" power is $|G(\\mathbf{k})|^2 |f_1 T_1(k) + f_2 T_2(k)|^2 P_0(k)$. These two quantities are analytically identical for each mode. The check bins both quantities into spherical shells in $k$-space of width $\\Delta k = 2\\pi/L$. The ratio of the total measured power to the total predicted power in each bin is computed. The test metric is the maximum absolute fractional deviation, $\\max(|P_{\\text{meas}}/P_{\\text{pred}} - 1|)$, across all bins that contain a sufficient number of modes (e.g., more than $10$) and lie below half the Nyquist frequency to avoid grid-scale anisotropies. This value should be on the order of machine floating-point precision.\n\n*   **Kinematic Consistency**: This check verifies the fundamental relationship between the first-order displacement and the matter overdensity, $-\\nabla \\cdot \\boldsymbol{\\Psi}^{(1)}(\\mathbf{x}) = \\delta_m(\\mathbf{x})$. This identity is most easily tested in Fourier space, where it becomes $-i\\mathbf{k} \\cdot \\boldsymbol{\\Psi}^{(1)}(\\mathbf{k}) = \\delta_m(\\mathbf{k})$ for $\\mathbf{k} \\neq \\mathbf{0}$. The left-hand side is computed from the generated $\\boldsymbol{\\Psi}^{(1)}(\\mathbf{k})$ and the right-hand side is the generated $\\delta_m(\\mathbf{k})$. The relative root-mean-square error, $\\sqrt{\\sum|\\text{LHS} - \\text{RHS}|^2 / \\sum|\\text{RHS}|^2}$, where the sum is over all Fourier modes, is calculated. This value should also be near machine precision, confirming the correct implementation of the Fourier-space operators.\n\nThe implementation encapsulates these steps within a function that is called for each test case, producing the two specified verification metrics.", "answer": "```python\nimport numpy as np\n\ndef compute_initial_conditions(N, L, f1, f2, A, n_spec, k_c, a, k0, k1):\n    \"\"\"\n    Generates cosmological initial conditions and performs verification checks.\n    \"\"\"\n    # 1. Setup Grid\n    k_vec = np.fft.fftfreq(N, d=L / N) * 2 * np.pi\n    kx, ky, kz = np.meshgrid(k_vec, k_vec, k_vec, indexing='ij')\n    k_mag = np.sqrt(kx**2 + ky**2 + kz**2)\n    \n    k_is_zero = (k_mag == 0)\n    k_mag_safe = np.where(k_is_zero, 1.0, k_mag)\n    k_sq_inv = 1.0 / k_mag_safe**2\n    k_sq_inv[k_is_zero] = 0.0\n\n    # 2. Generate Initial Random Field\n    white_noise = np.random.randn(N, N, N)\n    G_k = np.fft.fftn(white_noise)\n    G_k[0, 0, 0] = 0.0  # Enforce zero mean for the field\n\n    # Power spectrum and transfer functions\n    P0_k = A * k_mag_safe**n_spec * np.exp(-(k_mag_safe / k_c)**8)\n    P0_k[k_is_zero] = 0.0\n\n    T1_k = 1.0 + a * np.exp(-(k_mag / k0)**2) - 0.5 * a * np.exp(-(k_mag / k1)**2)\n    \n    # Total matter overdensity field (since f1*T1 + f2*T2 = 1)\n    delta_m_k = np.sqrt(P0_k) * G_k\n\n    # 3. Compute LPT Displacements\n    # First-order (Zel'dovich)\n    Psi1_kx = 1j * kx * k_sq_inv * delta_m_k\n    Psi1_ky = 1j * ky * k_sq_inv * delta_m_k\n    Psi1_kz = 1j * kz * k_sq_inv * delta_m_k\n    \n    # Second-order (2LPT)\n    phi1_k = -delta_m_k * k_sq_inv\n    \n    d2phi1_dx2_k = -kx**2 * phi1_k\n    d2phi1_dy2_k = -ky**2 * phi1_k\n    d2phi1_dz2_k = -kz**2 * phi1_k\n    d2phi1_dxdy_k = -kx * ky * phi1_k\n    d2phi1_dxdz_k = -kx * kz * phi1_k\n    d2phi1_dydz_k = -ky * kz * phi1_k\n\n    d2phi1_xx = np.fft.ifftn(d2phi1_dx2_k).real\n    d2phi1_yy = np.fft.ifftn(d2phi1_dy2_k).real\n    d2phi1_zz = np.fft.ifftn(d2phi1_dz2_k).real\n    d2phi1_xy = np.fft.ifftn(d2phi1_dxdy_k).real\n    d2phi1_xz = np.fft.ifftn(d2phi1_dxdz_k).real\n    d2phi1_yz = np.fft.ifftn(d2phi1_dydz_k).real\n    \n    S2_x = (d2phi1_xx * d2phi1_yy - d2phi1_xy**2) + \\\n           (d2phi1_xx * d2phi1_zz - d2phi1_xz**2) + \\\n           (d2phi1_yy * d2phi1_zz - d2phi1_yz**2)\n    \n    S2_k = np.fft.fftn(S2_x)\n    phi2_k = -S2_k * k_sq_inv\n\n    _ = -1j * kx * phi2_k  # Psi2_kx, not needed for verification but computed as required\n    _ = -1j * ky * phi2_k  # Psi2_ky\n    _ = -1j * kz * phi2_k  # Psi2_kz\n\n    # 4. Verification\n    \n    # 4a. Power Spectrum Check\n    P_meas_k = np.abs(delta_m_k)**2\n    \n    T2_k = (1.0 - f1 * T1_k) / f2\n    total_T_k_explicit = f1 * T1_k + f2 * T2_k\n    P_pred_k = np.abs(G_k)**2 * np.abs(total_T_k_explicit)**2 * P0_k\n\n    k_fundamental = 2 * np.pi / L\n    k_nyquist = np.pi * N / L\n    k_max_verify = k_nyquist / 2.0\n    \n    k_flat = k_mag.flatten()\n    valid_modes = ~k_is_zero.flatten()\n    k_flat_valid = k_flat[valid_modes]\n    \n    max_k_val = np.max(k_flat_valid) if k_flat_valid.size > 0 else 0\n    num_bins = int(np.ceil(max_k_val / k_fundamental)) + 1\n\n    bin_indices = np.floor(k_flat_valid / k_fundamental).astype(int)\n    \n    binned_P_meas = np.bincount(bin_indices, weights=P_meas_k.flatten()[valid_modes], minlength=num_bins)\n    binned_P_pred = np.bincount(bin_indices, weights=P_pred_k.flatten()[valid_modes], minlength=num_bins)\n    counts = np.bincount(bin_indices, minlength=num_bins)\n\n    ratios = []\n    min_modes_per_bin = 10\n    \n    for i in range(num_bins):\n        k_bin_center = (i + 0.5) * k_fundamental\n        if counts[i] >= min_modes_per_bin and binned_P_pred[i] > 1e-30 and k_bin_center  k_max_verify:\n             ratio = binned_P_meas[i] / binned_P_pred[i]\n             ratios.append(ratio)\n    \n    max_frac_dev = np.max(np.abs(np.array(ratios) - 1.0)) if ratios else 0.0\n\n    # 4b. Kinematic Consistency Check\n    LHS_k = -(1j * kx * Psi1_kx + 1j * ky * Psi1_ky + 1j * kz * Psi1_kz)\n    RHS_k = delta_m_k\n    err_k = LHS_k - RHS_k\n    \n    norm_err_sq = np.sum(np.abs(err_k)**2)\n    norm_rhs_sq = np.sum(np.abs(RHS_k)**2)\n    \n    rel_rms_err = np.sqrt(norm_err_sq / norm_rhs_sq) if norm_rhs_sq > 0 else 0.0\n\n    return [max_frac_dev, rel_rms_err]\n\ndef solve():\n    # Set a consistent seed for reproducibility of random numbers.\n    np.random.seed(42)\n\n    test_cases = [\n        # Case A\n        {'N': 32, 'L': 200, 'f1': 0.84, 'f2': 0.16, 'A': 1, 'n_spec': 1, 'k_c': 3, 'a': 0.2, 'k0': 0.3, 'k1': 1.0},\n        # Case B\n        {'N': 24, 'L': 150, 'f1': 0.99, 'f2': 0.01, 'A': 1, 'n_spec': 1, 'k_c': 3, 'a': -0.3, 'k0': 0.4, 'k1': 1.2},\n        # Case C\n        {'N': 28, 'L': 220, 'f1': 0.5, 'f2': 0.5, 'A': 1, 'n_spec': 1, 'k_c': 3, 'a': 0.5, 'k0': 0.25, 'k1': 0.9},\n    ]\n\n    results = []\n    for params in test_cases:\n        result = compute_initial_conditions(**params)\n        results.append(result)\n\n    output_str = str(results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```", "id": "3512400"}]}