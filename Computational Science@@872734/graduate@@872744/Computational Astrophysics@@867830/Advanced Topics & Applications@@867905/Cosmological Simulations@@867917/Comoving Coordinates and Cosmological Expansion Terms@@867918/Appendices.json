{"hands_on_practices": [{"introduction": "A fundamental consequence of cosmic expansion is its effect on the motion of objects. Peculiar momentum, the momentum of a particle relative to the Hubble flow, is not conserved but instead decays over time due to a \"Hubble drag\" effect. This exercise provides a direct, hands-on experience with this phenomenon by numerically solving the first-order ordinary differential equation that governs the evolution of comoving peculiar momentum [@problem_id:3506150]. By implementing and benchmarking several standard numerical integrators against the exact analytical solution, you will gain practical skills in solving cosmological equations of motion and evaluating the accuracy of numerical methods.", "problem": "Implement a complete, runnable program that integrates free-streaming peculiar momentum in comoving coordinates for a particle evolving in conformal time. Begin from the following fundamental base: in an expanding, spatially flat Friedmann–Robertson–Walker background, free-streaming peculiar momentum satisfies the first-order Ordinary Differential Equation (ODE) $u'(\\tau) + \\mathcal{H}(\\tau)\\,u(\\tau) = 0$, where $\\tau$ is conformal time, $u(\\tau)$ is the comoving peculiar momentum, and $\\mathcal{H}(\\tau) = a'(\\tau)/a(\\tau)$ is the conformal Hubble parameter with $a(\\tau)$ the scale factor. You must derive an exact discrete-time integrator implied by the analytical solution to this ODE and benchmark it against explicit numerical schemes that directly time-step the ODE $u'(\\tau) + \\mathcal{H}(\\tau)\\,u(\\tau) = 0$.\n\nYour program must:\n- Use dimensionless quantities throughout; no physical units are required or permitted.\n- Implement the following cosmological backgrounds as functions of conformal time $\\tau$:\n  - Radiation-dominated: $a(\\tau) = \\tau$, yielding $\\mathcal{H}(\\tau) = 1/\\tau$ for $\\tau > 0$.\n  - Matter-dominated: $a(\\tau) = \\tau^2$, yielding $\\mathcal{H}(\\tau) = 2/\\tau$ for $\\tau > 0$.\n  - Cosmological-constant-dominated (de Sitter in conformal time): $a(\\tau) = -1/\\tau$, yielding $\\mathcal{H}(\\tau) = -1/\\tau$ for $\\tau < 0$.\n- Implement four integration schemes that advance $u(\\tau)$ from an initial time $\\tau_0$ to a final time $\\tau_1$ using $N$ uniform steps of size $\\Delta \\tau = (\\tau_1 - \\tau_0)/N$:\n  - An exact discrete integrator implied by the analytical solution to the ODE, applied stepwise over each interval.\n  - Forward (explicit) Euler applied to the ODE $u'(\\tau) + \\mathcal{H}(\\tau)\\,u(\\tau) = 0$.\n  - Implicit Euler applied to the same ODE.\n  - Classical fourth-order Runge–Kutta (RK4) applied to the same ODE.\n- For benchmarking, compute the relative error at $\\tau_1$ for each scheme with respect to the exact analytical solution of the ODE, defined as $\\varepsilon = \\lvert u_{\\text{num}}(\\tau_1) - u_{\\text{exact}}(\\tau_1) \\rvert / \\max(\\lvert u_{\\text{exact}}(\\tau_1) \\rvert, 10^{-15})$.\n\nDesign a test suite that exercises distinct regimes and edge cases:\n- Test case $1$ (happy path, radiation-dominated): $\\tau_0 = 1$, $\\tau_1 = 4$, $u_0 = 1.23$, $N = 20$, with $a(\\tau) = \\tau$.\n- Test case $2$ (happy path, matter-dominated): $\\tau_0 = 1$, $\\tau_1 = 2$, $u_0 = -2.5$, $N = 50$, with $a(\\tau) = \\tau^2$.\n- Test case $3$ (boundary: zero momentum, de Sitter): $\\tau_0 = -1$, $\\tau_1 = -0.5$, $u_0 = 0$, $N = 30$, with $a(\\tau) = -1/\\tau$.\n- Test case $4$ (edge: extremely coarse stepping, radiation-dominated): $\\tau_0 = 1$, $\\tau_1 = 4$, $u_0 = 3$, $N = 1$, with $a(\\tau) = \\tau$.\n\nFor each test case, your program must output a single list of four floats, in the fixed order: $[\\varepsilon_{\\text{exact-step}}, \\varepsilon_{\\text{forward-Euler}}, \\varepsilon_{\\text{implicit-Euler}}, \\varepsilon_{\\text{RK4}}]$. Aggregate the results from all test cases into a single line containing an outer list of these four-element lists. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[[e_{1,1}, e_{1,2}, e_{1,3}, e_{1,4}], [e_{2,1}, e_{2,2}, e_{2,3}, e_{2,4}], [e_{3,1}, e_{3,2}, e_{3,3}, e_{3,4}], [e_{4,1}, e_{4,2}, e_{4,3}, e_{4,4}]]$.\n\nNo user input is allowed; all parameters must be coded into the program exactly as specified above. The final printed output must be the single line in the specified format. Ensure scientific realism by keeping $\\tau$ values within domains where $a(\\tau)$ and $\\mathcal{H}(\\tau)$ are finite and well-defined (do not cross $\\tau = 0$ in the de Sitter case). The program must be structured and documented clearly so that a developer can verify correctness and reproduce the benchmark.", "solution": "The problem requires the implementation and benchmarking of several numerical integration schemes for the evolution of a particle's comoving peculiar momentum, $u$, in an expanding universe. The evolution is described by a first-order ordinary differential equation (ODE) in terms of conformal time, $\\tau$.\n\nThe fundamental governing equation provided is:\n$$\n\\frac{du}{d\\tau} + \\mathcal{H}(\\tau)u(\\tau) = 0\n$$\nwhere $u'(\\tau) = du/d\\tau$, and $\\mathcal{H}(\\tau) = a'(\\tau)/a(\\tau)$ is the conformal Hubble parameter, with $a(\\tau)$ being the cosmological scale factor. This equation describes the \"Hubble drag\" on the peculiar momentum, which decreases as the universe expands.\n\nFirst, we solve this ODE analytically to establish a ground truth for benchmarking. The equation is a first-order linear homogeneous ODE, which can be solved by separation of variables:\n$$\n\\frac{du}{u} = -\\mathcal{H}(\\tau)d\\tau\n$$\nIntegrating from an initial time $\\tau_0$ to a later time $\\tau$ gives:\n$$\n\\int_{u(\\tau_0)}^{u(\\tau)} \\frac{d\\tilde{u}}{\\tilde{u}} = -\\int_{\\tau_0}^{\\tau} \\mathcal{H}(\\tilde{\\tau})d\\tilde{\\tau}\n$$\n$$\n\\ln\\left(\\frac{u(\\tau)}{u(\\tau_0)}\\right) = -\\int_{\\tau_0}^{\\tau} \\frac{a'(\\tilde{\\tau})}{a(\\tilde{\\tau})}d\\tilde{\\tau} = -\\left[\\ln(a(\\tilde{\\tau}))\\right]_{\\tau_0}^{\\tau} = -(\\ln(a(\\tau)) - \\ln(a(\\tau_0))) = \\ln\\left(\\frac{a(\\tau_0)}{a(\\tau)}\\right)\n$$\nExponentiating both sides yields the exact analytical solution:\n$$\nu(\\tau) = u(\\tau_0) \\frac{a(\\tau_0)}{a(\\tau)}\n$$\nThis result shows that the comoving peculiar momentum redshifts, its magnitude decreasing in inverse proportion to the scale factor, $u \\propto 1/a$.\n\nThe program will implement and compare four integration schemes to solve the ODE from an initial time $\\tau_0$ to a final time $\\tau_1$ over $N$ uniform steps of size $\\Delta\\tau = (\\tau_1 - \\tau_0)/N$. Let $u_i = u(\\tau_i)$ where $\\tau_i = \\tau_0 + i\\Delta\\tau$.\n\n$1$. **Exact Stepwise Integrator**: This scheme applies the exact analytical solution over each discrete time step from $\\tau_i$ to $\\tau_{i+1}$. The update rule is directly derived from the analytical solution:\n$$\nu_{i+1} = u_i \\frac{a(\\tau_i)}{a(\\tau_{i+1})}\n$$\nBy construction, this method will yield the exact result at $\\tau_1$ up to floating-point precision, so its relative error should be near zero.\n\n$2$. **Forward (Explicit) Euler Method**: This is the simplest numerical scheme. It approximates the derivative at the beginning of the interval, $\\tau_i$. The ODE is written as $u' = -\\mathcal{H}(\\tau)u(\\tau)$. The update rule is:\n$$\nu_{i+1} = u_i + \\Delta\\tau \\cdot u'(\\tau_i) = u_i - \\Delta\\tau \\mathcal{H}(\\tau_i) u_i = u_i (1 - \\Delta\\tau \\mathcal{H}(\\tau_i))\n$$\n\n$3$. **Implicit Euler Method**: This scheme evaluates the derivative at the end of the interval, $\\tau_{i+1}$, making it more stable for stiff problems. The update rule is:\n$$\nu_{i+1} = u_i + \\Delta\\tau \\cdot u'(\\tau_{i+1}) = u_i - \\Delta\\tau \\mathcal{H}(\\tau_{i+1}) u_{i+1}\n$$\nSolving for $u_{i+1}$ yields the explicit update rule:\n$$\nu_{i+1}(1 + \\Delta\\tau \\mathcal{H}(\\tau_{i+1})) = u_i \\implies u_{i+1} = \\frac{u_i}{1 + \\Delta\\tau \\mathcal{H}(\\tau_{i+1})}\n$$\n\n$4$. **Classical Fourth-Order Runge-Kutta (RK4) Method**: This is a higher-order method that provides greater accuracy by evaluating the derivative at multiple points within the step. For an ODE $u' = f(\\tau, u)$, the update rule is:\n$$\nu_{i+1} = u_i + \\frac{\\Delta\\tau}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n$$\nwhere, for our specific problem $f(\\tau, u) = -\\mathcal{H}(\\tau)u(\\tau)$:\n- $k_1 = f(\\tau_i, u_i) = -\\mathcal{H}(\\tau_i)u_i$\n- $k_2 = f(\\tau_i + \\frac{\\Delta\\tau}{2}, u_i + \\frac{\\Delta\\tau}{2}k_1) = -\\mathcal{H}(\\tau_i + \\frac{\\Delta\\tau}{2})(u_i + \\frac{\\Delta\\tau}{2}k_1)$\n- $k_3 = f(\\tau_i + \\frac{\\Delta\\tau}{2}, u_i + \\frac{\\Delta\\tau}{2}k_2) = -\\mathcal{H}(\\tau_i + \\frac{\\Delta\\tau}{2})(u_i + \\frac{\\Delta\\tau}{2}k_2)$\n- $k_4 = f(\\tau_i + \\Delta\\tau, u_i + \\Delta\\tau k_3) = -\\mathcal{H}(\\tau_i + \\Delta\\tau)(u_i + \\Delta\\tau k_3)$\n\nThe specified cosmological models are:\n- Radiation-dominated: $a(\\tau) = \\tau$, $\\mathcal{H}(\\tau) = 1/\\tau$, for $\\tau > 0$.\n- Matter-dominated: $a(\\tau) = \\tau^2$, $\\mathcal{H}(\\tau) = 2/\\tau$, for $\\tau > 0$.\n- de Sitter: $a(\\tau) = -1/\\tau$, $\\mathcal{H}(\\tau) = -1/\\tau$, for $\\tau < 0$.\nFor all these models, the ODE has the form $u' = -c \\cdot u/\\tau$ for some constant $c$. It is a known property that the RK4 method provides the exact solution for ODEs of this form. Consequently, we expect the RK4 error to be near zero for all test cases.\n\nThe benchmarking process is as follows:\n- For each test case, the parameters $(\\tau_0, \\tau_1, u_0, N)$ and the cosmological model are defined.\n- The exact final momentum $u_{\\text{exact}}(\\tau_1) = u_0 a(\\tau_0)/a(\\tau_1)$ is computed.\n- For each of the four numerical schemes, the final momentum $u_{\\text{num}}(\\tau_1)$ is computed by iterating $N$ times from $\\tau_0$.\n- The relative error, $\\varepsilon$, is calculated for each scheme using the provided formula:\n$$\n\\varepsilon = \\frac{\\lvert u_{\\text{num}}(\\tau_1) - u_{\\text{exact}}(\\tau_1) \\rvert}{\\max(\\lvert u_{\\text{exact}}(\\tau_1) \\rvert, 10^{-15})}\n$$\nThe program collates these errors for each test case and presents them in the specified list-of-lists format.", "answer": "```python\n#\n# Meticulous and Exacting STEM Professor\n# Solution for Comoving Momentum Integration\n#\n\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main entry point for the program. Defines test cases, runs benchmarks,\n    and prints the final results in the specified format.\n    \"\"\"\n\n    # Dictionary mapping cosmology names to their scale factor and Hubble parameter functions.\n    cosmology_models = {\n        'radiation': {\n            'a': lambda tau: tau,\n            'H': lambda tau: 1.0 / tau\n        },\n        'matter': {\n            'a': lambda tau: tau**2,\n            'H': lambda tau: 2.0 / tau\n        },\n        'de_sitter': {\n            'a': lambda tau: -1.0 / tau,\n            'H': lambda tau: -1.0 / tau\n        }\n    }\n\n    # Define the test suite as specified in the problem statement.\n    test_cases = [\n        {'cosmology': 'radiation', 'tau0': 1.0, 'tau1': 4.0, 'u0': 1.23, 'N': 20},\n        {'cosmology': 'matter',    'tau0': 1.0, 'tau1': 2.0, 'u0': -2.5, 'N': 50},\n        {'cosmology': 'de_sitter', 'tau0': -1.0, 'tau1': -0.5, 'u0': 0.0, 'N': 30},\n        {'cosmology': 'radiation', 'tau0': 1.0, 'tau1': 4.0, 'u0': 3.0, 'N': 1},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        errors = run_benchmark(case, cosmology_models)\n        all_results.append(errors)\n\n    # Format the final output string as a list of lists.\n    # The default string representation of floats is used as no specific format was required.\n    inner_lists_str = []\n    for res_list in all_results:\n        inner_lists_str.append(f\"[{','.join(map(str, res_list))}]\")\n    \n    final_output = f\"[{','.join(inner_lists_str)}]\"\n    print(final_output)\n\n\ndef run_benchmark(case, cosmology_models):\n    \"\"\"\n    Runs all integration schemes for a single test case and returns their relative errors.\n\n    Args:\n        case (dict): A dictionary containing parameters for the test case\n                     (cosmology, tau0, tau1, u0, N).\n        cosmology_models (dict): A dictionary of cosmological model functions.\n\n    Returns:\n        list: A list of four floats representing the relative errors for each scheme.\n    \"\"\"\n    cosmology = case['cosmology']\n    tau0, tau1, u0, N = case['tau0'], case['tau1'], case['u0'], case['N']\n\n    a_func = cosmology_models[cosmology]['a']\n    H_func = cosmology_models[cosmology]['H']\n\n    # Generate time steps. np.linspace correctly handles N=1 (2 points).\n    tau_steps = np.linspace(tau0, tau1, N + 1)\n    delta_tau = (tau1 - tau0) / N\n\n    # Calculate the exact analytical solution at the final time for reference.\n    u_exact_final = u0 * a_func(tau0) / a_func(tau1)\n\n    # Run each of the four integration schemes.\n    u_exact_step_final = integrate_exact_step(u0, tau_steps, a_func)\n    u_forward_euler_final = integrate_forward_euler(u0, tau_steps, delta_tau, H_func)\n    u_implicit_euler_final = integrate_implicit_euler(u0, tau_steps, delta_tau, H_func)\n    u_rk4_final = integrate_rk4(u0, tau_steps, delta_tau, H_func)\n\n    # Collect the numerical results.\n    numerical_solutions = [\n        u_exact_step_final,\n        u_forward_euler_final,\n        u_implicit_euler_final,\n        u_rk4_final\n    ]\n    \n    # Calculate the relative error for each scheme.\n    errors = [calculate_relative_error(u_num, u_exact_final) for u_num in numerical_solutions]\n    \n    return errors\n\n\ndef calculate_relative_error(u_num, u_exact):\n    \"\"\"\n    Calculates the relative error according to the specified formula.\n    \"\"\"\n    numerator = np.abs(u_num - u_exact)\n    denominator = np.maximum(np.abs(u_exact), 1e-15)\n    return numerator / denominator\n\n\ndef integrate_exact_step(u0, tau_steps, a_func):\n    \"\"\"Integrator based on the exact solution applied stepwise.\"\"\"\n    u = u0\n    for i in range(len(tau_steps) - 1):\n        u = u * a_func(tau_steps[i]) / a_func(tau_steps[i+1])\n    return u\n\n\ndef integrate_forward_euler(u0, tau_steps, delta_tau, H_func):\n    \"\"\"Forward (explicit) Euler integrator.\"\"\"\n    u = u0\n    for i in range(len(tau_steps) - 1):\n        tau_i = tau_steps[i]\n        u = u * (1.0 - delta_tau * H_func(tau_i))\n    return u\n\n\ndef integrate_implicit_euler(u0, tau_steps, delta_tau, H_func):\n    \"\"\"Implicit Euler integrator.\"\"\"\n    u = u0\n    for i in range(len(tau_steps) - 1):\n        tau_i_plus_1 = tau_steps[i+1]\n        u = u / (1.0 + delta_tau * H_func(tau_i_plus_1))\n    return u\n\n\ndef integrate_rk4(u0, tau_steps, delta_tau, H_func):\n    \"\"\"Classical fourth-order Runge-Kutta (RK4) integrator.\"\"\"\n    # Define the function f(tau, u) = u' for the ODE u' = -H(tau) * u\n    f = lambda tau, u: -H_func(tau) * u\n    u = u0\n    for i in range(len(tau_steps) - 1):\n        tau_i = tau_steps[i]\n        \n        k1 = f(tau_i, u)\n        k2 = f(tau_i + 0.5 * delta_tau, u + 0.5 * delta_tau * k1)\n        k3 = f(tau_i + 0.5 * delta_tau, u + 0.5 * delta_tau * k2)\n        k4 = f(tau_i + delta_tau, u + delta_tau * k3)\n        \n        u = u + (delta_tau / 6.0) * (k1 + 2.0*k2 + 2.0*k3 + k4)\n    return u\n\n# Execute the main function when the script is run.\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "3506150"}, {"introduction": "Before tackling complex structures, a cosmological simulation code must first correctly model an empty, uniformly expanding universe. This \"uniform expansion test\" is a critical diagnostic: a test particle initially at rest in the comoving frame must remain at rest, as there are no peculiar forces to accelerate it. This practice challenges you to numerically verify this principle by integrating the equations of motion and quantifying the spurious drift away from the true solution [@problem_id:3506173]. Comparing the performance of different integrators like Explicit Euler and Velocity Verlet will offer valuable insights into why certain numerical schemes are preferred in modern N-body codes.", "problem": "Consider a spatially uniform, pressureless, matter-dominated Universe modeled in the Newtonian limit with a scale factor $a(t)$ and Hubble parameter $H(t)$. In a flat Einstein–de Sitter Universe, the Friedmann equation implies $H^2(t) = \\frac{8 \\pi G}{3} \\rho_b(t)$ and $a(t) \\propto t^{2/3}$ where $t$ is cosmic time, $G$ is the gravitational constant, and $\\rho_b(t)$ is the homogeneous background density. In this background, the physical position $r(t)$ of a free test particle satisfies the second-order Ordinary Differential Equation (ODE) $ \\frac{d^2 r}{dt^2} = - \\frac{4 \\pi G}{3} \\rho_b(t) \\, r(t)$, which is the gravitational field within a uniform density distribution.\n\nDefine the comoving coordinate $x(t) = r(t)/a(t)$. For a particle initially comoving with the Hubble flow (that is, $r(t_0) = a(t_0) x_0$ and $\\frac{dr}{dt}(t_0) = H(t_0) r(t_0)$ with $x_0$ constant), one expects $x(t) = x_0$ exactly for all $t$, since the particle remains at rest in comoving coordinates.\n\nYour task is to write a complete, runnable program that:\n- Implements the dynamical system in the specified uniform background using dimensionless code units chosen to make the relations exact and numerically well-conditioned.\n- Numerically integrates the particle’s motion for multiple integrator choices and time step sizes.\n- Verifies that a particle initially at rest in comoving coordinates remains at rest and quantifies the spurious drift $|x(t) - x_0|$ as a function of integrator choice and time step size.\n\nUse the following dimensionless normalization:\n- Set $G = 1$ and choose $t_0 = 1$ so that $a(t) = t^{2/3}$ and $H(t) = \\frac{2}{3 t}$ exactly.\n- Choose $\\rho_0 = \\rho_b(t_0)$ such that $H_0^2 = \\frac{8 \\pi G}{3} \\rho_0$ with $H_0 = \\frac{2}{3}$, which implies $\\rho_0 = \\frac{1}{6 \\pi}$.\n- With this choice, the ODE reduces to $\\frac{d^2 r}{dt^2} = - \\frac{2}{9} \\frac{r}{t^2}$.\n- Initialize at $t = t_0 = 1$ with $x_0 = 1$, $r(t_0) = a(t_0) x_0 = 1$, and $\\frac{dr}{dt}(t_0) = \\frac{2}{3}$.\n\nYou must implement and compare the following time integration schemes applied to the first-order system for $(r, v)$ where $v = \\frac{dr}{dt}$:\n- Explicit Euler method: update $v$ and $r$ using the acceleration $a_r(t, r) = - \\frac{2}{9} \\frac{r}{t^2}$ evaluated at the current step.\n- Velocity Verlet (Kick–Drift–Kick) method: a time-centered scheme that performs a half-step update of $v$, a full-step update of $r$, and then another half-step update of $v$, with explicit time dependence handled at the start and end of each step.\n- Classical fourth-order Runge–Kutta (RK4): compute the updates using the standard four-stage procedure for the system $\\frac{dr}{dt} = v$, $\\frac{dv}{dt} = - \\frac{2}{9} \\frac{r}{t^2}$, taking care to pass the appropriate time to each stage.\n\nFor each integrator and time step, integrate from $t = t_0 = 1$ to $t_f = 10$. At every step, compute the comoving coordinate $x(t) = \\frac{r(t)}{a(t)} = \\frac{r(t)}{t^{2/3}}$ and track the maximum absolute drift $\\max_t |x(t) - x_0|$ over the integration interval. All reported drifts must be expressed as dimensionless floats.\n\nTest Suite:\n- Case $1$: Explicit Euler with $\\Delta t = 0.5$.\n- Case $2$: Explicit Euler with $\\Delta t = 0.05$.\n- Case $3$: Velocity Verlet with $\\Delta t = 0.1$.\n- Case $4$: Classical Runge–Kutta $4$ with $\\Delta t = 0.5$.\n- Case $5$: Classical Runge–Kutta $4$ with $\\Delta t = 0.01$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[result_1,result_2,result_3,result_4,result_5]$), where each $result_i$ is the maximum absolute drift $\\max_t |x(t) - x_0|$ for the corresponding test case, reported as a float in dimensionless comoving-coordinate units.", "solution": "The user-provided problem has been assessed and is determined to be **valid**. The problem is scientifically grounded in standard cosmological models, is mathematically well-posed as an initial value problem for an ordinary differential equation, and is presented with objective, unambiguous language and data.\n\nThe problem requires the numerical integration of a test particle's equation of motion within a simplified model of a matter-dominated, expanding Universe (an Einstein-de Sitter model). The goal is to quantify the numerical error, or \"drift\", introduced by different integration schemes for a particle that should, analytically, remain at a constant comoving position.\n\nThe governing physical model is specified in a dimensionless form. The particle's physical position $r(t)$ evolves according to the second-order Ordinary Differential Equation (ODE):\n$$\n\\frac{d^2 r}{dt^2} = - \\frac{2}{9} \\frac{r}{t^2}\n$$\nThis equation describes the gravitational acceleration experienced by a particle within a uniform, expanding medium in this model. The integration is to be performed over the time interval $t \\in [1, 10]$.\n\nThe initial conditions are set at $t_0 = 1$. The particle is initially at a comoving position $x_0 = 1$. The physical position is therefore $r(t_0) = a(t_0) x_0$, where the scale factor $a(t) = t^{2/3}$. This gives $r(1) = 1^{2/3} \\cdot 1 = 1$. The particle is also initially comoving with the Hubble flow, meaning its initial physical velocity matches the expansion velocity at its location: $\\frac{dr}{dt}(t_0) = H(t_0) r(t_0)$. With the Hubble parameter $H(t) = \\frac{2}{3t}$, the initial velocity is $\\frac{dr}{dt}(1) = H(1) r(1) = (\\frac{2}{3 \\cdot 1}) \\cdot 1 = \\frac{2}{3}$.\n\nTo solve this numerically, we first convert the second-order ODE into a system of two coupled first-order ODEs. Let $v(t) = \\frac{dr}{dt}$. The system is:\n$$\n\\frac{dr}{dt} = v\n$$\n$$\n\\frac{dv}{dt} = a_r(t, r) = - \\frac{2}{9} \\frac{r}{t^2}\n$$\nwith initial conditions $(r_0, v_0) = (1, 2/3)$ at $t_0 = 1$.\n\nWe are tasked to implement three numerical integration schemes to solve this system from $t_0=1$ to $t_f=10$ with a discrete time step $\\Delta t$. At each time $t_n$ in the integration, we compute the comoving coordinate $x(t_n) = \\frac{r(t_n)}{a(t_n)} = \\frac{r(t_n)}{t_n^{2/3}}$. The primary metric for evaluation is the maximum absolute drift from the analytical solution, $\\max_t |x(t) - x_0|$, where the initial comoving position is $x_0=1$.\n\nThe three integration schemes are implemented as follows:\n\n1.  **Explicit Euler Method:** This is a first-order method. Given the state $(r_n, v_n)$ at time $t_n$, the state at $t_{n+1} = t_n + \\Delta t$ is computed using the derivatives evaluated at the beginning of the interval:\n    $$\n    v_{n+1} = v_n + \\Delta t \\cdot a_r(t_n, r_n)\n    $$\n    $$\n    r_{n+1} = r_n + \\Delta t \\cdot v_n\n    $$\n    This method is simple but known to be not very accurate and can suffer from instability for oscillatory systems.\n\n2.  **Velocity Verlet (Kick–Drift–Kick) Method:** This is a second-order, symplectic integrator, widely used in molecular dynamics and N-body simulations due to its good energy conservation properties over long integrations. For a force that depends on position and time, the steps are:\n    *   **Kick (half step):** Update velocity using the acceleration at the start of the step.\n        $$v_{n+1/2} = v_n + \\frac{\\Delta t}{2} a_r(t_n, r_n)$$\n    *   **Drift (full step):** Update position using the new half-step velocity.\n        $$r_{n+1} = r_n + \\Delta t \\cdot v_{n+1/2}$$\n    *   **Kick (half step):** Compute the new acceleration at the end of the step, $a_r(t_{n+1}, r_{n+1})$, and update velocity to its final value.\n        $$v_{n+1} = v_{n+1/2} + \\frac{\\Delta t}{2} a_r(t_{n+1}, r_{n+1})$$\n\n3.  **Classical Fourth-Order Runge–Kutta (RK4) Method:** This is a fourth-order method, offering much higher accuracy for a given step size compared to lower-order methods. Let the state vector be $\\mathbf{y} = [r, v]^T$ and the derivative function be $\\mathbf{f}(t, \\mathbf{y}) = [v, a_r(t,r)]^T$. The update rule is:\n    $$\n    \\mathbf{k}_1 = \\Delta t \\cdot \\mathbf{f}(t_n, \\mathbf{y}_n)\n    $$\n    $$\n    \\mathbf{k}_2 = \\Delta t \\cdot \\mathbf{f}(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\mathbf{k}_1}{2})\n    $$\n    $$\n    \\mathbf{k}_3 = \\Delta t \\cdot \\mathbf{f}(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\mathbf{k}_2}{2})\n    $$\n    $$\n    \\mathbf{k}_4 = \\Delta t \\cdot \\mathbf{f}(t_n + \\Delta t, \\mathbf{y}_n + \\mathbf{k}_3)\n    $$\n    $$\n    \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{1}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + 2\\mathbf{k}_4)\n    $$\n    This involves evaluating the acceleration at four different points in the $(t, r, v)$ phase space per step to achieve its high accuracy.\n\nThe program implements these three methods in separate functions. A main loop iterates through the specified test cases. For each case, it initializes the state to $(t, r, v) = (1, 1, 2/3)$, calculates the total number of steps, and enters a loop that advances the simulation one step at a time. Within this loop, the comoving coordinate $x(t)$ is calculated at the beginning of each step, and the maximum drift from $x_0=1$ is tracked. A final check is performed at $t=t_f=10$. The accumulated maximum drift is then stored. Finally, the results for all test cases are collected and printed.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef accel(t: float, r: float) -> float:\n    \"\"\"Calculates the acceleration of the particle.\"\"\"\n    # The time t=0 is avoided by the problem's integration range [1, 10].\n    return -2.0/9.0 * r / t**2\n\ndef euler_integrate(dt: float) -> float:\n    \"\"\"\n    Integrates the particle's motion using the Explicit Euler method.\n    Returns the maximum absolute comoving drift.\n    \"\"\"\n    t0, tf = 1.0, 10.0\n    r, v = 1.0, 2.0 / 3.0\n    x0 = 1.0\n\n    n_steps = int(round((tf - t0) / dt))\n    max_drift = 0.0\n\n    for i in range(n_steps):\n        t = t0 + i * dt\n        \n        # Calculate drift at the start of the step\n        current_x = r / t**(2.0/3.0)\n        max_drift = max(max_drift, abs(current_x - x0))\n\n        # Update step\n        a = accel(t, r)\n        r_new = r + v * dt\n        v_new = v + a * dt\n        r, v = r_new, v_new\n    \n    # Final drift check at t_f\n    final_x = r / tf**(2.0/3.0)\n    max_drift = max(max_drift, abs(final_x - x0))\n    \n    return max_drift\n\ndef verlet_integrate(dt: float) -> float:\n    \"\"\"\n    Integrates the particle's motion using the Velocity Verlet (KDK) method.\n    Returns the maximum absolute comoving drift.\n    \"\"\"\n    t0, tf = 1.0, 10.0\n    r, v = 1.0, 2.0 / 3.0\n    x0 = 1.0\n\n    n_steps = int(round((tf - t0) / dt))\n    max_drift = 0.0\n\n    for i in range(n_steps):\n        t = t0 + i * dt\n        \n        # Calculate drift at the start of the step\n        current_x = r / t**(2.0/3.0)\n        max_drift = max(max_drift, abs(current_x - x0))\n\n        # Kick-Drift-Kick update\n        a_current = accel(t, r)\n        v_half = v + 0.5 * dt * a_current\n        r_next = r + dt * v_half\n        t_next = t + dt\n        a_next = accel(t_next, r_next)\n        v_next = v_half + 0.5 * dt * a_next\n        r, v = r_next, v_next\n\n    # Final drift check at t_f\n    final_x = r / tf**(2.0/3.0)\n    max_drift = max(max_drift, abs(final_x - x0))\n    \n    return max_drift\n\ndef rk4_integrate(dt: float) -> float:\n    \"\"\"\n    Integrates the particle's motion using the Classical RK4 method.\n    Returns the maximum absolute comoving drift.\n    \"\"\"\n    t0, tf = 1.0, 10.0\n    r, v = 1.0, 2.0 / 3.0\n    x0 = 1.0\n\n    n_steps = int(round((tf - t0) / dt))\n    max_drift = 0.0\n\n    for i in range(n_steps):\n        t = t0 + i * dt\n        \n        # Calculate drift at the start of the step\n        current_x = r / t**(2.0/3.0)\n        max_drift = max(max_drift, abs(current_x - x0))\n\n        # RK4 stages\n        k1_r = dt * v\n        k1_v = dt * accel(t, r)\n\n        k2_r = dt * (v + k1_v / 2.0)\n        k2_v = dt * accel(t + dt / 2.0, r + k1_r / 2.0)\n\n        k3_r = dt * (v + k2_v / 2.0)\n        k3_v = dt * accel(t + dt / 2.0, r + k2_r / 2.0)\n\n        k4_r = dt * (v + k3_v)\n        k4_v = dt * accel(t + dt, r + k3_r)\n        \n        # Update step\n        r += (k1_r + 2.0 * k2_r + 2.0 * k3_r + k4_r) / 6.0\n        v += (k1_v + 2.0 * k2_v + 2.0 * k3_v + k4_v) / 6.0\n\n    # Final drift check at t_f\n    final_x = r / tf**(2.0/3.0)\n    max_drift = max(max_drift, abs(final_x - x0))\n    \n    return max_drift\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        ('Euler', 0.5),\n        ('Euler', 0.05),\n        ('Verlet', 0.1),\n        ('RK4', 0.5),\n        ('RK4', 0.01),\n    ]\n\n    integrators = {\n        'Euler': euler_integrate,\n        'Verlet': verlet_integrate,\n        'RK4': rk4_integrate\n    }\n\n    results = []\n    for integrator_name, dt in test_cases:\n        func = integrators[integrator_name]\n        drift = func(dt)\n        results.append(drift)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3506173"}, {"introduction": "The equations of motion in cosmology can be formulated with respect to different independent variables, such as cosmic time $t$, conformal time $\\eta$, or the scale factor $a$. This choice is not merely cosmetic; it can significantly affect the complexity of the equations and the performance of numerical integrators. This advanced exercise delves into this crucial aspect of code design by tasking you with integrating the motion of a particle in a comoving potential using all three time variables [@problem_id:3506154]. By measuring how well each scheme conserves a known energy invariant, you will discover why certain time coordinates, like conformal time, can dramatically simplify problems and improve numerical accuracy.", "problem": "You are asked to implement and compare three constant step-size control strategies for numerically integrating the comoving equations of motion of a single particle in a spatially flat Friedmann–Lemaître–Robertson–Walker (FLRW) universe. The strategies are based on the independent variables cosmic time $t$, conformal time $\\eta$, and scale factor $a$. Your comparison must quantify the impact of each strategy on the conservation of a comoving energy invariant.\n\nFundamental base and definitions:\n- Let the physical position be $\\mathbf{r}(t)=a(t)\\,\\mathbf{x}(t)$, where $a(t)$ is the scale factor and $\\mathbf{x}$ is the comoving coordinate. Consider one spatial dimension, so that $x$ and $r$ are scalars. Define the Hubble parameter $H(a)$ via $H(a)=\\dot{a}/a$, where the dot denotes derivative with respect to $t$.\n- Let the dimensionless Hubble function be $h(a)=H(a)/H_0$, where $H_0$ is a constant reference value. Assume a flat Lambda Cold Dark Matter model such that $h(a)=\\sqrt{\\Omega_{\\mathrm{m}} a^{-3}+\\Omega_{\\Lambda}}$ with constants $\\Omega_{\\mathrm{m}}$ and $\\Omega_{\\Lambda}$ satisfying $\\Omega_{\\mathrm{m}}+\\Omega_{\\Lambda}=1$.\n- Define conformal time $\\eta$ by $d\\eta=dt/a$. The scale factor $a$ is related to $\\eta$ and $t$ by\n$$\n\\frac{d\\eta}{da}=\\frac{1}{a^2 h(a)},\\qquad \\frac{dt}{da}=\\frac{1}{a h(a)}.\n$$\n- Consider a comoving harmonic potential $\\phi(x)=\\tfrac{1}{2}\\,\\omega_c^2\\,x^2$ that is independent of $\\eta$, with constant $\\omega_c>0$.\n\nEquations of motion:\n- In conformal time, the comoving equations of motion are\n$$\n\\frac{dx}{d\\eta}=u,\\qquad \\frac{du}{d\\eta}=-\\omega_c^2\\,x,\n$$\nwhere $u$ is the comoving canonical momentum conjugate to $x$ (equal to $dx/d\\eta$ for unit mass). The comoving energy\n$$\nE_c(\\eta)=\\tfrac{1}{2}\\,u^2+\\tfrac{1}{2}\\,\\omega_c^2\\,x^2\n$$\nis an invariant for this time-independent comoving potential, and therefore must be conserved by the exact dynamics.\n\n- Rewriting the same dynamics using cosmic time $t$, and using only the definitions above without introducing any additional cosmological formulas, yields\n$$\n\\frac{dx}{dt}=\\frac{u}{a},\\qquad \\frac{du}{dt}=-\\frac{\\omega_c^2}{a}\\,x,\\qquad \\frac{da}{dt}=a\\,h(a).\n$$\n\n- Rewriting with scale factor $a$ as the independent variable yields\n$$\n\\frac{dx}{da}=\\frac{u}{a^2 h(a)},\\qquad \\frac{du}{da}=-\\frac{\\omega_c^2}{a^2 h(a)}\\,x.\n$$\n\nNumerical method requirement:\n- Implement a single-step explicit second-order Runge–Kutta (midpoint) method for a general first-order system $\\dfrac{d\\mathbf{y}}{ds}=\\mathbf{F}(s,\\mathbf{y})$, where $s$ is the chosen independent variable ($t$, $\\eta$, or $a$). The step from $s_n$ to $s_{n+1}=s_n+\\Delta s$ is\n$$\n\\mathbf{k}_1=\\mathbf{F}(s_n,\\mathbf{y}_n),\\quad \\mathbf{k}_2=\\mathbf{F}\\left(s_n+\\tfrac{1}{2}\\Delta s,\\ \\mathbf{y}_n+\\tfrac{1}{2}\\Delta s\\,\\mathbf{k}_1\\right),\\quad \\mathbf{y}_{n+1}=\\mathbf{y}_n+\\Delta s\\,\\mathbf{k}_2.\n$$\n\nPerformance metric:\n- For each strategy, compute the maximum relative drift of the comoving energy\n$$\n\\delta_{\\max}=\\max_{n}\\left|\\frac{E_c(n)-E_c(0)}{E_c(0)}\\right|,\n$$\nwhere $E_c(n)$ is the comoving energy at step index $n$, and $E_c(0)$ is the initial comoving energy. All quantities are dimensionless.\n\nImplementation details:\n- Use the dimensionless Hubble function $h(a)=\\sqrt{\\Omega_{\\mathrm{m}} a^{-3}+\\Omega_{\\Lambda}}$ to evaluate $d\\eta/da$ and $dt/da$, and to evolve $a(t)$ when integrating with $t$ as the independent variable.\n- When integrating with $\\eta$ as the independent variable, obtain the total $\\Delta \\eta$ over the interval $[a_{\\mathrm{i}},a_{\\mathrm{f}}]$ by integrating $d\\eta/da$ over $a$; likewise, when integrating with $t$ as the independent variable, obtain the total $\\Delta t$ over $[a_{\\mathrm{i}},a_{\\mathrm{f}}]$ by integrating $dt/da$ over $a$. Use constant step sizes $\\Delta s$ determined by dividing these totals by the number of steps $N$.\n- Initial conditions are specified at $a=a_{\\mathrm{i}}$ as $x(0)=x_0$ and $u(0)=u_0$.\n\nTest suite:\n- Case $1$ (general Lambda Cold Dark Matter): $\\Omega_{\\mathrm{m}}=0.3$, $\\Omega_{\\Lambda}=0.7$, $a_{\\mathrm{i}}=0.1$, $a_{\\mathrm{f}}=1.0$, $\\omega_c=0.5$, $x_0=1.0$, $u_0=0.0$, $N=1000$.\n- Case $2$ (Einstein–de Sitter matter-only, early times): $\\Omega_{\\mathrm{m}}=1.0$, $\\Omega_{\\Lambda}=0.0$, $a_{\\mathrm{i}}=0.01$, $a_{\\mathrm{f}}=0.1$, $\\omega_c=2.0$, $x_0=0.2$, $u_0=0.0$, $N=1500$.\n- Case $3$ (cosmological constant dominated, late times): $\\Omega_{\\mathrm{m}}=0.0$, $\\Omega_{\\Lambda}=1.0$, $a_{\\mathrm{i}}=0.5$, $a_{\\mathrm{f}}=2.0$, $\\omega_c=0.1$, $x_0=1.0$, $u_0=0.0$, $N=800$.\n\nRequired final output format:\n- Your program should produce a single line of output containing a list of length $3$, where each element is itself a list of length $3$ with the maximum relative energy drifts for the three strategies in the order $[t,\\eta,a]$, corresponding to the three test cases in the order $[1,2,3]$. For example, the output must look like\n$$\n\\big[[\\delta_{t,1},\\delta_{\\eta,1},\\delta_{a,1}],\\ [\\delta_{t,2},\\delta_{\\eta,2},\\delta_{a,2}],\\ [\\delta_{t,3},\\delta_{\\eta,3},\\delta_{a,3}]\\big],\n$$\nprinted as a single line with square brackets and commas, with dimensionless floating-point numbers.", "solution": "The user has requested the implementation and comparison of three numerical integration strategies for the equations of motion of a particle in a comoving harmonic potential. The validation and solution are presented below.\n\n### **Problem Validation**\n\n**Step 1: Extract Givens**\n-   **Model**: Spatially flat Friedmann–Lemaître–Robertson–Walker (FLRW) universe.\n-   **Coordinates & Relations**: Physical position $r(t) = a(t)x(t)$, where $x$ is the comoving coordinate. Hubble parameter $H(a) = \\dot{a}/a$. Dimensionless Hubble function $h(a) = H(a)/H_0 = \\sqrt{\\Omega_{\\mathrm{m}} a^{-3} + \\Omega_{\\Lambda}}$ with $\\Omega_{\\mathrm{m}} + \\Omega_{\\Lambda} = 1$. Conformal time defined by $d\\eta = dt/a$.\n-   **Key Differential Relations**: $\\frac{d\\eta}{da} = \\frac{1}{a^2 h(a)}$, $\\frac{dt}{da} = \\frac{1}{a h(a)}$.\n-   **Potential and Invariant**: Comoving harmonic potential $\\phi(x) = \\frac{1}{2}\\omega_c^2 x^2$. The associated comoving energy $E_c = \\frac{1}{2}u^2 + \\frac{1}{2}\\omega_c^2 x^2$ is an invariant, where $u$ is the comoving canonical momentum.\n-   **Equations of Motion (EOMs)**:\n    1.  Independent variable $\\eta$: $\\frac{dx}{d\\eta}=u$, $\\frac{du}{d\\eta}=-\\omega_c^2 x$.\n    2.  Independent variable $t$: $\\frac{dx}{dt}=\\frac{u}{a}$, $\\frac{du}{dt}=-\\frac{\\omega_c^2}{a}x$, $\\frac{da}{dt}=a h(a)$.\n    3.  Independent variable $a$: $\\frac{dx}{da}=\\frac{u}{a^2 h(a)}$, $\\frac{du}{da}=-\\frac{\\omega_c^2}{a^2 h(a)}x$.\n-   **Numerical Method**: Explicit second-order Runge–Kutta (midpoint) method for $\\frac{d\\mathbf{y}}{ds}=\\mathbf{F}(s,\\mathbf{y})$:\n    $$\n    \\mathbf{k}_1=\\mathbf{F}(s_n,\\mathbf{y}_n),\\quad \\mathbf{k}_2=\\mathbf{F}\\left(s_n+\\tfrac{1}{2}\\Delta s,\\ \\mathbf{y}_n+\\tfrac{1}{2}\\Delta s\\,\\mathbf{k}_1\\right),\\quad \\mathbf{y}_{n+1}=\\mathbf{y}_n+\\Delta s\\,\\mathbf{k}_2.\n    $$\n-   **Performance Metric**: Maximum relative energy drift $\\delta_{\\max}=\\max_{n}\\left|\\frac{E_c(n)-E_c(0)}{E_c(0)}\\right|$.\n-   **Integration Procedure**: For a given integration range $[a_{\\mathrm{i}}, a_{\\mathrm{f}}]$ and $N$ steps:\n    -   Total integration times $\\Delta t_{\\text{total}} = \\int_{a_{\\mathrm{i}}}^{a_{\\mathrm{f}}} \\frac{da}{a h(a)}$ and $\\Delta \\eta_{\\text{total}} = \\int_{a_{\\mathrm{i}}}^{a_{\\mathrm{f}}} \\frac{da}{a^2 h(a)}$.\n    -   Constant step sizes are $\\Delta t = \\Delta t_{\\text{total}}/N$, $\\Delta \\eta = \\Delta \\eta_{\\text{total}}/N$, and $\\Delta a = (a_{\\mathrm{f}}-a_{\\mathrm{i}})/N$.\n-   **Initial Conditions**: $x(0)=x_0, u(0)=u_0$ at scale factor $a=a_{\\mathrm{i}}$.\n-   **Test Cases**:\n    -   Case 1: $\\Omega_{\\mathrm{m}}=0.3, \\Omega_{\\Lambda}=0.7, a_{\\mathrm{i}}=0.1, a_{\\mathrm{f}}=1.0, \\omega_c=0.5, x_0=1.0, u_0=0.0, N=1000$.\n    -   Case 2: $\\Omega_{\\mathrm{m}}=1.0, \\Omega_{\\Lambda}=0.0, a_{\\mathrm{i}}=0.01, a_{\\mathrm{f}}=0.1, \\omega_c=2.0, x_0=0.2, u_0=0.0, N=1500$.\n    -   Case 3: $\\Omega_{\\mathrm{m}}=0.0, \\Omega_{\\Lambda}=1.0, a_{\\mathrm{i}}=0.5, a_{\\mathrm{f}}=2.0, \\omega_c=0.1, x_0=1.0, u_0=0.0, N=800$.\n-   **Output Format**: Print a single-line list of lists: $[[\\delta_{t,1},\\delta_{\\eta,1},\\delta_{a,1}], [\\delta_{t,2},\\delta_{\\eta,2},\\delta_{a,2}], [\\delta_{t,3},\\delta_{\\eta,3},\\delta_{a,3}]]$.\n\n**Step 2: Validate Using Extracted Givens**\n-   **Scientific Grounding**: The problem is based on the standard $\\Lambda$CDM cosmological model and classical mechanics, which are established scientific principles. The equations of motion are textbook derivations for a particle in an expanding universe. The setup is scientifically sound.\n-   **Well-Posedness**: All necessary parameters, initial conditions, and governing equations are explicitly provided for each test case. The numerical method is clearly defined. The task is to execute a well-defined numerical experiment. The problem is well-posed.\n-   **Objectivity**: The problem statement is written in precise, objective mathematical language, free from ambiguity or subjective claims.\n-   **Consistency Check**: The various forms of the equations of motion are consistent with each other via the chain rule and the definitions provided (e.g., $\\frac{dx}{dt} = \\frac{dx}{d\\eta}\\frac{d\\eta}{dt} = u \\cdot \\frac{1}{a}$). The use of the dimensionless Hubble function $h(a)$ in the EOMs like $\\frac{da}{dt}=a h(a)$ implicitly sets the Hubble constant $H_0=1$ in the chosen system of units, a standard practice in theoretical cosmology. Since all equations are given explicitly, this forms a self-contained and consistent system.\n-   **Feasibility**: The parameters chosen are physically representative of different cosmic epochs. The numerical integrations are standard and can be performed with the specified libraries. The problem is feasible.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A complete solution will be provided.\n\n### **Principle-Based Design**\n\nThe core of the problem is to compare the numerical stability of three different formulations of the same physical dynamics. The system is a comoving harmonic oscillator, for which comoving energy is a conserved quantity. The accuracy of a numerical integrator can be measured by how well it preserves this invariant. The three formulations use cosmic time $t$, conformal time $\\eta$, and the scale factor $a$ as the independent integration variables.\n\n**1. General Numerical Method: Second-Order Runge-Kutta (Midpoint)**\nA generic function will be implemented for the RK2 midpoint step as defined in the problem. This function will take the right-hand-side (RHS) function $\\mathbf{F}$, the current independent variable value $s$, the state vector $\\mathbf{y}$, and the step size $\\Delta s$, and return the updated state vector.\n\n**2. Integration Strategies**\n\n-   **Strategy I: Integration with respect to Cosmic Time $t$**\n    -   The state vector is $\\mathbf{y} = [x, u, a]$. We must integrate the evolution of the scale factor $a$ alongside the particle's coordinates, as the EOMs for $x$ and $u$ explicitly depend on $a$.\n    -   The system of ODEs is $\\frac{d\\mathbf{y}}{dt} = \\mathbf{F}_t(\\mathbf{y}) = [u/a, -\\omega_c^2 x/a, a h(a)]$. This system is autonomous (the RHS does not explicitly depend on $t$).\n    -   The total integration time $\\Delta t_{\\text{total}}$ is computed by numerically integrating $\\frac{dt}{da} = \\frac{1}{a h(a)}$ from $a_{\\mathrm{i}}$ to $a_{\\mathrm{f}}$. The step size is $\\Delta t = \\Delta t_{\\text{total}} / N$.\n\n-   **Strategy II: Integration with respect to Conformal Time $\\eta$**\n    -   The EOMs in conformal time, $\\frac{dx}{d\\eta}=u$ and $\\frac{du}{d\\eta}=-\\omega_c^2 x$, describe a simple harmonic oscillator. The coefficients are constant.\n    -   The state vector is $\\mathbf{y} = [x, u]$. The ODE system is $\\frac{d\\mathbf{y}}{d\\eta} = \\mathbf{F}_\\eta(\\mathbf{y}) = [u, -\\omega_c^2 x]$. This system is linear, autonomous, and its exact solution lies on an ellipse in phase space, making it an ideal test for an integrator.\n    -   The total integration time $\\Delta \\eta_{\\text{total}}$ is computed by numerically integrating $\\frac{d\\eta}{da} = \\frac{1}{a^2 h(a)}$ from $a_{\\mathrm{i}}$ to $a_{\\mathrm{f}}$. The step size is $\\Delta \\eta = \\Delta \\eta_{\\text{total}} / N$. This choice of variable is expected to yield the highest accuracy due to the simple, time-independent form of the EOMs.\n\n-   **Strategy III: Integration with respect to Scale Factor $a$**\n    -   The state vector is $\\mathbf{y} = [x, u]$.\n    -   The EOMs are $\\frac{d\\mathbf{y}}{da} = \\mathbf{F}_a(a, \\mathbf{y}) = [\\frac{u}{a^2 h(a)}, -\\frac{\\omega_c^2 x}{a^2 h(a)}]$. This system is non-autonomous, as the RHS explicitly depends on the integration variable $a$. This variability in the coefficients can challenge a fixed-step-size integrator.\n    -   The step size is simply $\\Delta a = (a_{\\mathrm{f}} - a_{\\mathrm{i}}) / N$. The integration proceeds in uniform steps of the scale factor.\n\n**3. Implementation Structure**\nA main function will iterate through the three test cases provided. For each case, it will call three separate solver functions, one for each integration strategy. Each solver will:\n1.  Define the specific dimensionless Hubble function $h(a)$ based on the case parameters.\n2.  If necessary, compute the total integration interval (for $t$ and $\\eta$) using `scipy.integrate.quad`.\n3.  Determine the constant step size.\n4.  Initialize the state vector, and calculate the initial comoving energy $E_c(0)$.\n5.  Loop $N$ times, applying the RK2 step at each iteration. Inside the loop, the current comoving energy $E_c(n)$ is computed and the maximum relative drift $\\delta_{\\max}$ is updated.\n6.  Return the final $\\delta_{\\max}$.\n\nThe results from the three strategies for each case will be collected and formatted into the required nested list for the final output.", "answer": "```python\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Solves the comoving equations of motion using three different integration strategies\n    and computes the maximum relative energy drift for each.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (LCDM)\n        {'Omega_m': 0.3, 'Omega_L': 0.7, 'a_i': 0.1, 'a_f': 1.0, \n         'omega_c': 0.5, 'x0': 1.0, 'u0': 0.0, 'N': 1000},\n        # Case 2 (EdS)\n        {'Omega_m': 1.0, 'Omega_L': 0.0, 'a_i': 0.01, 'a_f': 0.1, \n         'omega_c': 2.0, 'x0': 0.2, 'u0': 0.0, 'N': 1500},\n        # Case 3 (de Sitter)\n        {'Omega_m': 0.0, 'Omega_L': 1.0, 'a_i': 0.5, 'a_f': 2.0, \n         'omega_c': 0.1, 'x0': 1.0, 'u0': 0.0, 'N': 800}\n    ]\n\n    all_results = []\n\n    def rk2_midpoint_step(F, s, y, ds, params):\n        \"\"\"A single RK2 midpoint step.\"\"\"\n        k1 = F(s, y, params)\n        y_mid = y + 0.5 * ds * k1\n        s_mid = s + 0.5 * ds\n        k2 = F(s_mid, y_mid, params)\n        y_next = y + ds * k2\n        return y_next\n\n    # --- RHS functions for the ODEs ---\n    def F_t(t, y, params):\n        x, u, a = y\n        h_func = params['h_func']\n        omega_c = params['omega_c']\n        # Avoid division by zero if a becomes very small, although not expected here.\n        if a == 0:\n            return np.zeros(3)\n        return np.array([u / a, -omega_c**2 * x / a, a * h_func(a)])\n\n    def F_eta(eta, y, params):\n        x, u = y\n        omega_c = params['omega_c']\n        return np.array([u, -omega_c**2 * x])\n\n    def F_a(a, y, params):\n        x, u = y\n        h_func = params['h_func']\n        omega_c = params['omega_c']\n        # Avoid division by zero at a=0.\n        if a == 0:\n            return np.zeros(2)\n        common_factor = 1.0 / (a**2 * h_func(a))\n        return np.array([u * common_factor, -omega_c**2 * x * common_factor])\n\n    # --- Solver for each strategy ---\n    def solve_with_t(params):\n        N, a_i, a_f, x0, u0 = params['N'], params['a_i'], params['a_f'], params['x0'], params['u0']\n        h_func = params['h_func']\n        \n        total_t, _ = integrate.quad(lambda a: 1.0 / (a * h_func(a)), a_i, a_f)\n        dt = total_t / N\n        \n        y = np.array([x0, u0, a_i])\n        \n        E_c_0 = 0.5 * u0**2 + 0.5 * params['omega_c']**2 * x0**2\n        if E_c_0 == 0: return 0.0\n        \n        max_drift = 0.0\n        \n        s = 0.0\n        for _ in range(N):\n            y = rk2_midpoint_step(F_t, s, y, dt, params)\n            s += dt\n            x_n, u_n, _ = y\n            E_c_n = 0.5 * u_n**2 + 0.5 * params['omega_c']**2 * x_n**2\n            drift = abs((E_c_n - E_c_0) / E_c_0)\n            if drift > max_drift:\n                max_drift = drift\n        return max_drift\n\n    def solve_with_eta(params):\n        N, a_i, a_f, x0, u0 = params['N'], params['a_i'], params['a_f'], params['x0'], params['u0']\n        h_func = params['h_func']\n        \n        total_eta, _ = integrate.quad(lambda a: 1.0 / (a**2 * h_func(a)), a_i, a_f)\n        deta = total_eta / N\n        \n        y = np.array([x0, u0])\n        \n        E_c_0 = 0.5 * u0**2 + 0.5 * params['omega_c']**2 * x0**2\n        if E_c_0 == 0: return 0.0\n        \n        max_drift = 0.0\n        \n        s = 0.0\n        for _ in range(N):\n            y = rk2_midpoint_step(F_eta, s, y, deta, params)\n            s += deta\n            x_n, u_n = y\n            E_c_n = 0.5 * u_n**2 + 0.5 * params['omega_c']**2 * x_n**2\n            drift = abs((E_c_n - E_c_0) / E_c_0)\n            if drift > max_drift:\n                max_drift = drift\n        return max_drift\n\n    def solve_with_a(params):\n        N, a_i, a_f, x0, u0 = params['N'], params['a_i'], params['a_f'], params['x0'], params['u0']\n        \n        da = (a_f - a_i) / N\n        \n        y = np.array([x0, u0])\n        \n        E_c_0 = 0.5 * u0**2 + 0.5 * params['omega_c']**2 * x0**2\n        if E_c_0 == 0: return 0.0\n\n        max_drift = 0.0\n        \n        s = a_i\n        for _ in range(N):\n            y = rk2_midpoint_step(F_a, s, y, da, params)\n            s += da\n            x_n, u_n = y\n            E_c_n = 0.5 * u_n**2 + 0.5 * params['omega_c']**2 * x_n**2\n            drift = abs((E_c_n - E_c_0) / E_c_0)\n            if drift > max_drift:\n                max_drift = drift\n        return max_drift\n\n    for case_params in test_cases:\n        Omega_m = case_params['Omega_m']\n        Omega_L = case_params['Omega_L']\n        \n        # Define the dimensionless Hubble function for the current case\n        def h_func(a):\n            return np.sqrt(Omega_m * a**-3 + Omega_L)\n        \n        current_params = case_params.copy()\n        current_params['h_func'] = h_func\n\n        # Calculate drift for each strategy\n        drift_t = solve_with_t(current_params)\n        drift_eta = solve_with_eta(current_params)\n        drift_a = solve_with_a(current_params)\n        \n        all_results.append([drift_t, drift_eta, drift_a])\n    \n    # Format the output string as required\n    result_str = str(all_results).replace(\" \", \"\")\n    print(result_str)\n\nsolve()\n```", "id": "3506154"}]}