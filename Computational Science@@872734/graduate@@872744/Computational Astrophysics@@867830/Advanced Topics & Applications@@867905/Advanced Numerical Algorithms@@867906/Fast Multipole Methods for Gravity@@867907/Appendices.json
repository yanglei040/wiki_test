{"hands_on_practices": [{"introduction": "The foundation of the Fast Multipole Method's \"upward pass\" lies in efficiently encoding the gravitational influence of particle clusters into a compact set of multipole moments. This first practice focuses on implementing and verifying the two most fundamental operators in this process: Particle-to-Multipole (P2M) and Multipole-to-Multipole (M2M) translations. By programming these operators and confirming they obey an exact mathematical identity, you will build the essential machinery for hierarchically summarizing source distributions, a critical first step in constructing a working FMM code [@problem_id:3510054].", "problem": "You are asked to implement and verify two core operators from the Fast Multipole Method (FMM) for Newtonian gravity: Particle-to-Multipole (P2M) and Multipole-to-Multipole (M2M). Begin from the Newtonian gravitational potential, which for point masses is given by $$\\Phi(\\mathbf{r}) = - G \\sum_{i=1}^{N} \\frac{m_i}{\\|\\mathbf{r} - \\mathbf{x}_i\\|},$$ where $G$ is the gravitational constant, $\\mathbf{r}$ is the field point in space, $m_i$ is the mass of particle $i$, and $\\mathbf{x}_i$ is its position. The Fast Multipole Method (FMM) organizes the computation by expanding the potential in terms of moments about cluster centers and translating these moments between centers.\n\nDefine a multi-index $\\alpha = (\\alpha_x, \\alpha_y, \\alpha_z)$ with nonnegative integers and $|\\alpha| = \\alpha_x + \\alpha_y + \\alpha_z$. For any vector $\\mathbf{u} = (u_x, u_y, u_z)$, define the monomial $$\\mathbf{u}^{\\alpha} = u_x^{\\alpha_x} u_y^{\\alpha_y} u_z^{\\alpha_z},$$ and the multi-index factorial $$\\alpha! = \\alpha_x! \\, \\alpha_y! \\, \\alpha_z!.$$ For multi-indices $\\beta \\le \\alpha$ componentwise, define the multi-index binomial coefficient $$\\binom{\\alpha}{\\beta} = \\binom{\\alpha_x}{\\beta_x} \\binom{\\alpha_y}{\\beta_y} \\binom{\\alpha_z}{\\beta_z}.$$\n\nThe Particle-to-Multipole (P2M) moments of order up to $p$ about a center $\\mathbf{c}$ are the raw moments $$M_{\\alpha}(\\mathbf{c}) = \\sum_{i=1}^{N} m_i \\left(\\mathbf{x}_i - \\mathbf{c}\\right)^{\\alpha} \\quad \\text{for all } |\\alpha| \\le p.$$ These moments appear naturally as coefficients in the Taylor series of the potential about $\\mathbf{c}$ via multi-index derivatives of $1/\\|\\mathbf{r}-\\mathbf{c}\\|$; the computation of $M_{\\alpha}(\\mathbf{c})$ from $\\{m_i,\\mathbf{x}_i\\}$ is the P2M operation.\n\nGiven moments $M_{\\alpha}(\\mathbf{c}_{\\text{child}})$ about a child cell center $\\mathbf{c}_{\\text{child}}$, the Multipole-to-Multipole (M2M) translation to a parent center $\\mathbf{c}_{\\text{parent}}$ with translation vector $\\mathbf{d} = \\mathbf{c}_{\\text{parent}} - \\mathbf{c}_{\\text{child}}$ is defined by the exact multi-index multinomial identity $$M'_{\\alpha}(\\mathbf{c}_{\\text{parent}}) = \\sum_{\\beta \\le \\alpha} \\binom{\\alpha}{\\beta} \\left(-\\mathbf{d}\\right)^{\\alpha - \\beta} M_{\\beta}(\\mathbf{c}_{\\text{child}}) \\quad \\text{for all } |\\alpha| \\le p.$$ This follows from writing $\\left(\\mathbf{x}_i - \\mathbf{c}_{\\text{parent}}\\right) = \\left(\\mathbf{x}_i - \\mathbf{c}_{\\text{child}}\\right) - \\mathbf{d}$ and applying the multinomial expansion. The direct P2M moments about the parent center are $$M_{\\alpha}(\\mathbf{c}_{\\text{parent}}) = \\sum_{i=1}^{N} m_i \\left(\\mathbf{x}_i - \\mathbf{c}_{\\text{parent}}\\right)^{\\alpha}.$$\n\nYour task is to write a complete, runnable program that, for each provided test case, computes:\n- the P2M moments $M_{\\alpha}(\\mathbf{c}_{\\text{child}})$ up to order $p$,\n- the M2M-translated moments $M'_{\\alpha}(\\mathbf{c}_{\\text{parent}})$ using the formula above, and\n- the direct P2M moments $M_{\\alpha}(\\mathbf{c}_{\\text{parent}})$.\n\nFor each test case, report the maximum relative moment error defined as $$\\max_{|\\alpha| \\le p} \\frac{\\left|M'_{\\alpha}(\\mathbf{c}_{\\text{parent}}) - M_{\\alpha}(\\mathbf{c}_{\\text{parent}})\\right|}{\\max\\left(1, \\left|M_{\\alpha}(\\mathbf{c}_{\\text{parent}})\\right|\\right)},$$ which is dimensionless. All inputs are in International System of Units (SI): positions in meters and masses in kilograms. The reported error must be a dimensionless float.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $\\left[\\text{result1},\\text{result2},\\text{result3}\\right]$). Use the following test suite of parameter values, each test case given as $\\left(\\{m_i\\}, \\{\\mathbf{x}_i\\}, \\mathbf{c}_{\\text{child}}, \\mathbf{c}_{\\text{parent}}, p\\right)$:\n\n- Test case $1$ (general case): masses $\\left[5.0\\times 10^{10}, 3.0\\times 10^{10}, 7.5\\times 10^{10}, 1.2\\times 10^{10}\\right]$ kilograms, positions in meters $$\\left[\\left(0.1,-0.2,0.3\\right), \\left(-0.4,0.5,-0.6\\right), \\left(0.7,0.0,-0.1\\right), \\left(-0.2,-0.3,0.4\\right)\\right],$$ child center $\\left(0.0,0.0,0.0\\right)$ meters, parent center $\\left(0.5,-0.3,0.2\\right)$ meters, and order $p=3$.\n- Test case $2$ (single particle at child center): masses $\\left[2.0\\times 10^{11}\\right]$ kilograms, positions in meters $$\\left[\\left(1.0,2.0,-1.5\\right)\\right],$$ child center $\\left(1.0,2.0,-1.5\\right)$ meters, parent center $\\left(1.2,1.8,-1.4\\right)$ meters, and order $p=4$.\n- Test case $3$ (empty cluster): masses $\\left[\\right]$ kilograms, positions $\\left[\\right]$, child center $\\left(0.0,0.0,0.0\\right)$ meters, parent center $\\left(0.1,0.1,0.1\\right)$ meters, and order $p=3$.\n- Test case $4$ (zero translation vector): masses $\\left[1.0\\times 10^{9}, 5.0\\times 10^{9}\\right]$ kilograms, positions in meters $$\\left[\\left(0.02,-0.01,0.03\\right), \\left(-0.05,0.04,-0.02\\right)\\right],$$ child center $\\left(0.1,-0.2,0.3\\right)$ meters, parent center $\\left(0.1,-0.2,0.3\\right)$ meters, and order $p=2$.\n- Test case $5$ (monopole only): masses $\\left[1.0\\times 10^{12}, 2.0\\times 10^{12}, 3.0\\times 10^{12}\\right]$ kilograms, positions in meters $$\\left[\\left(10.0,0.0,-5.0\\right), \\left(-3.0,2.0,1.0\\right), \\left(0.5,-0.5,0.25\\right)\\right],$$ child center $\\left(1.0,1.0,1.0\\right)$ meters, parent center $\\left(-1.0,2.0,0.0\\right)$ meters, and order $p=0$.\n\nImplement the computations using exact multi-index algebra as specified. Your program must output a single line containing the dimensionless maximum relative errors for the five test cases as a comma-separated list enclosed in square brackets.", "solution": "The problem requires the implementation and numerical verification of two fundamental operators of the Fast Multipole Method (FMM): the Particle-to-Multipole (P2M) and Multipole-to-Multipole (M2M) translations. The verification relies on an exact mathematical identity connecting moments computed at a parent cell's center to those computed at a child cell's center.\n\nThe mathematical foundation is based on multi-index notation. A multi-index is a vector of non-negative integers, $\\alpha = (\\alpha_x, \\alpha_y, \\alpha_z)$, with order $|\\alpha| = \\alpha_x + \\alpha_y + \\alpha_z$. This notation simplifies expressions involving multivariable Taylor series. For a vector $\\mathbf{u} = (u_x, u_y, u_z)$, we define $\\mathbf{u}^{\\alpha} = u_x^{\\alpha_x} u_y^{\\alpha_y} u_z^{\\alpha_z}$.\n\nThe P2M operator computes the multipole moments $M_{\\alpha}(\\mathbf{c})$ of a cluster of particles with masses $\\{m_i\\}$ and positions $\\{\\mathbf{x}_i\\}$ about a center point $\\mathbf{c}$. These are defined as the raw moments of the mass distribution relative to the center:\n$$M_{\\alpha}(\\mathbf{c}) = \\sum_{i=1}^{N} m_i \\left(\\mathbf{x}_i - \\mathbf{c}\\right)^{\\alpha} \\quad \\text{for all } |\\alpha| \\le p,$$\nwhere $p$ is the maximum order of the expansion.\n\nThe M2M operator translates these moments from a child center $\\mathbf{c}_{\\text{child}}$ to a parent center $\\mathbf{c}_{\\text{parent}}$. Let $\\mathbf{d} = \\mathbf{c}_{\\text{parent}} - \\mathbf{c}_{\\text{child}}$ be the translation vector. The translated moments, denoted $M'_{\\alpha}(\\mathbf{c}_{\\text{parent}})$, are given by the formula:\n$$M'_{\\alpha}(\\mathbf{c}_{\\text{parent}}) = \\sum_{\\beta \\le \\alpha} \\binom{\\alpha}{\\beta} \\left(-\\mathbf{d}\\right)^{\\alpha - \\beta} M_{\\beta}(\\mathbf{c}_{\\text{child}}) \\quad \\text{for all } |\\alpha| \\le p,$$\nwhere $\\binom{\\alpha}{\\beta}$ is the multi-index binomial coefficient, defined as $\\binom{\\alpha}{\\beta} = \\binom{\\alpha_x}{\\beta_x} \\binom{\\alpha_y}{\\beta_y} \\binom{\\alpha_z}{\\beta_z}$. This formula is an exact identity derived from the multinomial expansion of $(\\mathbf{x}_i - \\mathbf{c}_{\\text{parent}})^\\alpha = ((\\mathbf{x}_i - \\mathbf{c}_{\\text{child}}) - \\mathbf{d})^\\alpha$.\n\nThe core task is to verify this identity numerically. This is accomplished by comparing the M2M-translated moments $M'_{\\alpha}(\\mathbf{c}_{\\text{parent}})$ against the moments computed directly at the parent center, $M_{\\alpha}(\\mathbf{c}_{\\text{parent}})$, using the P2M formula. In exact arithmetic, these two quantities must be identical.\n\nThe algorithmic procedure is as follows:\n\n1.  **Multi-index Generation**: For a given expansion order $p$, we first generate all multi-indices $\\alpha = (\\alpha_x, \\alpha_y, \\alpha_z)$ such that $\\alpha_x + \\alpha_y + \\alpha_z \\le p$. This can be achieved with three nested loops, iterating through all valid combinations of $\\alpha_x, \\alpha_y, \\alpha_z$. These indices will serve as keys for storing and accessing moment values.\n\n2.  **P2M Implementation**: A function is implemented to compute $M_{\\alpha}(\\mathbf{c})$ for all $|\\alpha| \\le p$. The function takes the set of particles $\\{m_i, \\mathbf{x}_i\\}$, a center $\\mathbf{c}$, and the list of multi-indices. For each particle, we compute its displacement vector $\\mathbf{v}_i = \\mathbf{x}_i - \\mathbf{c}$. Then, for each multi-index $\\alpha$, we compute the term $m_i \\mathbf{v}_i^{\\alpha}$ and accumulate it into the total moment $M_{\\alpha}(\\mathbf{c})$. In the case of an empty particle cluster, all moments are zero.\n\n3.  **M2M Implementation**: A second function is implemented for the M2M translation. It takes the pre-computed child moments $M_{\\beta}(\\mathbf{c}_{\\text{child}})$, the child and parent centers, and the list of target multi-indices $\\alpha$. For each $\\alpha$, it performs a summation over all multi-indices $\\beta$ such that each component of $\\beta$ is less than or equal to the corresponding component of $\\alpha$ (i.e., $\\beta_x \\le \\alpha_x, \\beta_y \\le \\alpha_y, \\beta_z \\le \\alpha_z$). Each term in the sum is the product of the multi-index binomial coefficient $\\binom{\\alpha}{\\beta}$, the monomial of the negative translation vector $(-\\mathbf{d})^{\\alpha - \\beta}$, and the corresponding child moment $M_{\\beta}(\\mathbf{c}_{\\text{child}})$.\n\n4.  **Verification and Error Calculation**: For each test case, we perform the following sequence of computations:\n    a. Compute the child moments $M_{\\alpha}(\\mathbf{c}_{\\text{child}})$ using the P2M operator.\n    b. Translate these moments to the parent center to obtain $M'_{\\alpha}(\\mathbf{c}_{\\text{parent}})$ using the M2M operator.\n    c. Compute the ground-truth parent moments $M_{\\alpha}(\\mathbf{c}_{\\text{parent}})$ by applying the P2M operator directly with the same set of particles but centered at $\\mathbf{c}_{\\text{parent}}$.\n    d. Compare the translated moments $M'_{\\alpha}(\\mathbf{c}_{\\text{parent}})$ with the directly computed moments $M_{\\alpha}(\\mathbf{c}_{\\text{parent}})$ for all $|\\alpha| \\le p$. The discrepancy is quantified using the maximum relative error:\n    $$\\max_{|\\alpha| \\le p} \\frac{\\left|M'_{\\alpha}(\\mathbf{c}_{\\text{parent}}) - M_{\\alpha}(\\mathbf{c}_{\\text{parent}})\\right|}{\\max\\left(1, \\left|M_{\\alpha}(\\mathbf{c}_{\\text{parent}})\\right|\\right)}$$\n    This metric provides a robust measure of numerical disagreement, avoiding division by zero and giving a relative error for large moments. Any non-zero error arises purely from the limitations of floating-point arithmetic, as the underlying mathematical identity is exact.\n\nThe provided test suite covers a range of scenarios, including a general case, a single particle at the child center, an empty cluster, zero translation, and a monopole-only expansion ($p=0$), thereby ensuring a thorough validation of the implementation.", "answer": "```python\nimport numpy as np\nfrom scipy.special import comb\n\ndef generate_multi_indices(p):\n    \"\"\"Generates all 3D multi-indices alpha with |alpha| <= p.\"\"\"\n    indices = []\n    for ax in range(p + 1):\n        for ay in range(p - ax + 1):\n            for az in range(p - ax - ay + 1):\n                indices.append((ax, ay, az))\n    return indices\n\ndef p2m(masses, positions, center, multi_indices):\n    \"\"\"\n    Computes Particle-to-Multipole (P2M) moments.\n    M_alpha(c) = sum_i m_i * (x_i - c)^alpha\n    \"\"\"\n    moments = {idx: 0.0 for idx in multi_indices}\n    if not masses:\n        return moments\n\n    positions_np = np.array(positions, dtype=np.float64)\n    center_np = np.array(center, dtype=np.float64)\n    masses_np = np.array(masses, dtype=np.float64)\n    \n    displacements = positions_np - center_np\n\n    for alpha in multi_indices:\n        # Calculate (x_i - c)^alpha for all particles i\n        # This is a vectorized operation\n        terms = (np.power(displacements[:, 0], alpha[0]) *\n                 np.power(displacements[:, 1], alpha[1]) *\n                 np.power(displacements[:, 2], alpha[2]))\n        \n        # Sum m_i * (x_i - c)^alpha over all i\n        moments[alpha] = np.sum(masses_np * terms)\n            \n    return moments\n\ndef m2m(child_moments, c_child, c_parent, multi_indices):\n    \"\"\"\n    Performs Multipole-to-Multipole (M2M) translation.\n    M'_alpha(c_p) = sum_{beta <= alpha} C(alpha, beta) * (-d)^(alpha-beta) * M_beta(c_c)\n    \"\"\"\n    parent_moments = {idx: 0.0 for idx in multi_indices}\n    d = np.array(c_parent, dtype=np.float64) - np.array(c_child, dtype=np.float64)\n    neg_d = -d\n\n    for alpha in multi_indices:\n        ax, ay, az = alpha\n        temp_sum = 0.0\n        # Iterate over all beta such that beta_i <= alpha_i for each component i\n        for bx in range(ax + 1):\n            for by in range(ay + 1):\n                for bz in range(az + 1):\n                    beta = (bx, by, bz)\n                    \n                    # Since |beta| <= |alpha| <= p, beta is always a valid key in child_moments\n                    alpha_minus_beta = (ax - bx, ay - by, az - bz)\n                    \n                    # Multi-index Binomial Coefficient C(alpha, beta)\n                    C = (comb(ax, bx, exact=False) * \n                         comb(ay, by, exact=False) *\n                         comb(az, bz, exact=False))\n                    \n                    # Power of negative translation vector (-d)^(alpha-beta)\n                    D_term = (np.power(neg_d[0], alpha_minus_beta[0]) *\n                              np.power(neg_d[1], alpha_minus_beta[1]) *\n                              np.power(neg_d[2], alpha_minus_beta[2]))\n                    \n                    M_beta = child_moments[beta]\n                    \n                    temp_sum += C * D_term * M_beta\n                    \n        parent_moments[alpha] = temp_sum\n        \n    return parent_moments\n\ndef solve():\n    \"\"\"\n    Solves the FMM operator verification problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (general case)\n        (\n            [5.0e10, 3.0e10, 7.5e10, 1.2e10],\n            [(0.1, -0.2, 0.3), (-0.4, 0.5, -0.6), (0.7, 0.0, -0.1), (-0.2, -0.3, 0.4)],\n            (0.0, 0.0, 0.0), (0.5, -0.3, 0.2), 3\n        ),\n        # Test case 2 (single particle at child center)\n        (\n            [2.0e11],\n            [(1.0, 2.0, -1.5)],\n            (1.0, 2.0, -1.5), (1.2, 1.8, -1.4), 4\n        ),\n        # Test case 3 (empty cluster)\n        (\n            [],\n            [],\n            (0.0, 0.0, 0.0), (0.1, 0.1, 0.1), 3\n        ),\n        # Test case 4 (zero translation vector)\n        (\n            [1.0e9, 5.0e9],\n            [(0.02, -0.01, 0.03), (-0.05, 0.04, -0.02)],\n            (0.1, -0.2, 0.3), (0.1, -0.2, 0.3), 2\n        ),\n        # Test case 5 (monopole only)\n        (\n            [1.0e12, 2.0e12, 3.0e12],\n            [(10.0, 0.0, -5.0), (-3.0, 2.0, 1.0), (0.5, -0.5, 0.25)],\n            (1.0, 1.0, 1.0), (-1.0, 2.0, 0.0), 0\n        )\n    ]\n\n    results = []\n    for case in test_cases:\n        masses, positions, c_child, c_parent, p = case\n\n        # 1. Generate multi-indices for the given order p\n        multi_indices = generate_multi_indices(p)\n\n        # 2. Compute P2M moments at the child center\n        child_moments = p2m(masses, positions, c_child, multi_indices)\n\n        # 3. Translate moments from child to parent center (M2M)\n        translated_parent_moments = m2m(child_moments, c_child, c_parent, multi_indices)\n\n        # 4. Compute direct P2M moments at the parent center for verification\n        direct_parent_moments = p2m(masses, positions, c_parent, multi_indices)\n\n        # 5. Calculate the maximum relative error\n        max_rel_error = 0.0\n        for alpha in multi_indices:\n            m_translated = translated_parent_moments[alpha]\n            m_direct = direct_parent_moments[alpha]\n            \n            numerator = np.abs(m_translated - m_direct)\n            denominator = np.maximum(1.0, np.abs(m_direct))\n            \n            error = numerator / denominator\n            if error > max_rel_error:\n                max_rel_error = error\n        \n        results.append(max_rel_error)\n\n    # Format the final output as specified\n    print(f\"[{','.join(f'{r:.16e}' for r in results)}]\")\n\nsolve()\n```", "id": "3510054"}, {"introduction": "A correct FMM implementation must not only be algorithmically sound but also faithful to the underlying physics. This practice provides a powerful end-to-end validation test based on Newton's shell theorem, which states that the gravitational field inside a spherically symmetric mass shell is zero. You will implement the \"downward pass\" operators to calculate the potential from a local expansion and, by simulating a discrete spherical shell, you will confront the concept of numerical self-force—an artifact of discretization that this exercise will help you quantify and understand [@problem_id:3510080].", "problem": "You are asked to design and implement a minimal, self-contained validation program for the Fast Multipole Method (FMM) for three-dimensional Newtonian gravity, starting from first principles and connecting the physics and numerics. The program will use a uniformly massed spherical shell as the source configuration to demonstrate the analytic property that the interior gravitational field is zero and will quantify the emergence and removal of a numerical self-force due to roundoff and truncation at finite expansion order. Your implementation must compute a local expansion using real surface spherical harmonics, evaluate the gravitational potential, differentiate to obtain the gravitational acceleration, and compare different operator choices.\n\nThe fundamental base is Newton’s law of universal gravitation and the addition theorem for the Laplace kernel. Use the following foundational facts:\n\n- The Newtonian potential at a target position $\\vec{x} \\in \\mathbb{R}^3$ due to point masses at positions $\\vec{x}_i$ with masses $m_i$ and the gravitational constant $G$ is\n$$\n\\Phi(\\vec{x}) = - G \\sum_i \\frac{m_i}{\\|\\vec{x}-\\vec{x}_i\\|},\n$$\nand the gravitational acceleration is\n$$\n\\vec{g}(\\vec{x}) = - \\nabla \\Phi(\\vec{x}).\n$$\n\n- For a continuous, uniformly massed spherical shell of radius $R$ and total mass $M$, the exact interior gravitational acceleration is\n$$\n\\vec{g}(\\vec{x}) = \\vec{0} \\quad \\text{for all } \\|\\vec{x}\\| < R.\n$$\n\n- The Laplace kernel addition theorem gives an interior local expansion in real spherical harmonics that can be written as\n$$\n\\frac{1}{\\|\\vec{x}_i-\\vec{x}\\|} = \\sum_{\\ell=0}^{\\infty} \\sum_{m=-\\ell}^{\\ell} \\frac{4\\pi}{2\\ell+1} \\frac{r^\\ell}{r_i^{\\ell+1}} \\, Y_{\\ell m}(\\hat{\\vec{x}}) \\, Y_{\\ell m}(\\hat{\\vec{x}}_i),\n$$\nwhere $r = \\|\\vec{x}\\|$, $r_i = \\|\\vec{x}_i\\|$, and $Y_{\\ell m}$ are orthonormal real spherical harmonics on the unit sphere with direction unit vectors $\\hat{\\vec{x}} = \\vec{x}/\\|\\vec{x}\\|$ and $\\hat{\\vec{x}}_i = \\vec{x}_i/\\|\\vec{x}_i\\|$. This leads to a Particle-to-Local (P2L) accumulation\n$$\nL_{\\ell m} = \\frac{4\\pi}{2\\ell+1} \\sum_i m_i \\frac{Y_{\\ell m}(\\hat{\\vec{x}}_i)}{r_i^{\\ell+1}},\n$$\nand a Local-to-Particle (L2P) evaluation of the potential\n$$\n\\Phi(\\vec{x}) = - G \\sum_{\\ell=0}^p \\sum_{m=-\\ell}^{\\ell} L_{\\ell m} \\, r^\\ell \\, Y_{\\ell m}(\\hat{\\vec{x}}),\n$$\nwhere $p$ is the truncation order. The gravitational acceleration $\\vec{g}(\\vec{x})$ is obtained by differentiating $\\Phi(\\vec{x})$ with respect to $\\vec{x}$.\n\nYou must implement the above for a discrete approximation of a uniform spherical shell of radius $R$ by placing $N$ equal masses $m_i = M/N$ on the sphere in antipodal pairs so that the discrete shell is as symmetric as possible. Use real spherical harmonics normalized to be orthonormal on the unit sphere, and compute $L_{\\ell m}$ up to order $p$. Evaluate $\\Phi(\\vec{x})$ at interior points $\\|\\vec{x}\\| = d < R$ and obtain $\\vec{g}(\\vec{x})$ numerically by central differences of $\\Phi(\\vec{x})$ along each Cartesian coordinate direction. Quantify the magnitude of the resulting $\\vec{g}(\\vec{x})$ to reveal any numerical self-force. Then implement a symmetry-enforced operator that projects the local expansion onto the spherically symmetric subspace by zeroing all $L_{\\ell m}$ for $\\ell \\geq 1$, and show that the self-force is eliminated.\n\nThe local expansion and its evaluation must be implemented in a way that is independent of any external code or data. All spherical harmonic entities must be computed numerically in your program.\n\nParameterization and test suite:\n\n- Use the normalization $G = 1$, $M = 1$, and $R = 1$, so that the normalization scale for acceleration is $G M / R^2 = 1$ and the magnitude of computed $\\|\\vec{g}\\|$ is dimensionless and can be reported directly.\n\n- Construct the discrete spherical shell with $N = 600$ point masses on the sphere of radius $R$, arranged in antipodal pairs using a deterministic rule so that the distribution is as symmetric as possible.\n\n- Implement real spherical harmonics $Y_{\\ell m}$ for all integer degrees $\\ell$ with $0 \\leq \\ell \\leq p$ and orders $-\\ell \\leq m \\leq \\ell$ in a real basis using associated Legendre polynomials and $\\cos(m\\phi)$, $\\sin(m\\phi)$ factors. Ensure orthonormality on the unit sphere by using the standard normalization\n$$\nY_{\\ell 0}(\\theta,\\phi) = \\sqrt{\\frac{2\\ell+1}{4\\pi}} \\, P_\\ell(\\cos\\theta),\n$$\nand for $m > 0$,\n$$\nY_{\\ell m}^{(c)}(\\theta,\\phi) = \\sqrt{2} \\, \\sqrt{\\frac{2\\ell+1}{4\\pi} \\frac{(\\ell-m)!}{(\\ell+m)!}} \\, P_\\ell^m(\\cos\\theta) \\cos(m\\phi),\n$$\n$$\nY_{\\ell m}^{(s)}(\\theta,\\phi) = \\sqrt{2} \\, \\sqrt{\\frac{2\\ell+1}{4\\pi} \\frac{(\\ell-m)!}{(\\ell+m)!}} \\, P_\\ell^m(\\cos\\theta) \\sin(m\\phi).\n$$\nMap these into a single index $m \\in \\{-\\ell,\\dots,\\ell\\}$ by identifying $Y_{\\ell,-m} \\equiv Y_{\\ell m}^{(s)}$ and $Y_{\\ell,m} \\equiv Y_{\\ell m}^{(c)}$ for $m>0$.\n\n- For the analytic uniform shell, derive the exact local expansion coefficients:\n$$\nL_{00} = \\sqrt{4\\pi}\\, \\frac{M}{R}, \\quad L_{\\ell m} = 0 \\text{ for } \\ell \\geq 1.\n$$\nUse this to demonstrate that $\\vec{g}(\\vec{x}) = \\vec{0}$ for all interior $d$.\n\n- For the discrete shell, compute $L_{\\ell m}$ by summation over the point masses. Evaluate $\\Phi(\\vec{x})$ via the truncated expansion and obtain $\\vec{g}(\\vec{x})$ via central differences using a step size $h$ satisfying $h \\ll R$.\n\n- Implement a symmetry-enforced operator that sets $L_{\\ell m} = 0$ for all $\\ell \\geq 1$ and evaluate the resulting $\\vec{g}(\\vec{x})$.\n\nTest suite:\n\nCompute the magnitude $\\|\\vec{g}(\\vec{x})\\|$ (normalized by $G M / R^2$) for the following six cases, aggregating the results in the required output format:\n\n- Case $1$: discrete shell, $d = 0$, $p = 8$, symmetry-enforced operator off.\n- Case $2$: discrete shell, $d = 0.3 R$, $p = 2$, symmetry-enforced operator off.\n- Case $3$: discrete shell, $d = 0.3 R$, $p = 8$, symmetry-enforced operator off.\n- Case $4$: discrete shell, $d = 0.9 R$, $p = 8$, symmetry-enforced operator off.\n- Case $5$: analytic uniform shell, $d = 0.3 R$, $p = 8$ (coefficients set analytically as above).\n- Case $6$: discrete shell with symmetry-enforced operator (projection to $\\ell = 0$ only), $d = 0.3 R$, $p = 8$.\n\nFinal output format:\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5,\\text{result}_6],\n$$\nwhere each $\\text{result}_k$ is a floating-point number equal to $\\|\\vec{g}\\|$ normalized by $G M / R^2$ for case $k$.\n\nAngles within spherical harmonic evaluations must be in radians. No external input is allowed; everything must be computed internally. The numerical differentiation step $h$ must be chosen to be a small fraction of $R$ so that the derivative is numerically stable; justify your choice in the solution, and use the same $h$ for all cases. Because the final reported quantities are dimensionless, no physical units need to be specified in the output. The implementation must be fully deterministic across runs.", "solution": "The problem statement is a valid and well-posed directive in the field of computational astrophysics. It asks for the design and implementation of a numerical experiment to validate a key aspect of the Fast Multipole Method (FMM) for Newtonian gravity. The problem is scientifically grounded in the principles of Newtonian mechanics and the mathematical theory of multipole expansions. It provides a clear, self-contained set of physical laws, mathematical formulas, and numerical parameters. The task is objective, requiring the computation of specific physical quantities under defined conditions, and is free of any scientific or logical contradictions. The slight ambiguity in the deterministic rule for point distribution is resolved by selecting a standard, symmetric method (a Fibonacci spiral with antipodes), which aligns with the stated goal of achieving a symmetric distribution. The special case of evaluation at the origin ($d=0$) is mathematically well-defined in the limit and computationally feasible. Therefore, the problem is valid and a solution can be constructed.\n\n### Theoretical Foundation and Analytic Derivation\n\nThe program's purpose is to numerically investigate the gravitational field inside a spherical mass shell. According to Newton's shell theorem, for a spherically symmetric shell of mass $M$ and radius $R$, the gravitational acceleration $\\vec{g}(\\vec{x})$ is zero for any point $\\vec{x}$ inside the shell (i.e., for $\\|\\vec{x}\\| < R$). We first demonstrate this a priori using the provided multipole expansion formalism.\n\nThe potential $\\Phi(\\vec{x})$ is given by a local expansion in terms of real spherical harmonics $Y_{\\ell m}$:\n$$\n\\Phi(\\vec{x}) = - G \\sum_{\\ell=0}^{\\infty} \\sum_{m=-\\ell}^{\\ell} L_{\\ell m} \\, r^\\ell \\, Y_{\\ell m}(\\hat{\\vec{x}})\n$$\nwhere $r = \\|\\vec{x}\\|$, $\\hat{\\vec{x}} = \\vec{x}/r$, and the local expansion coefficients $L_{\\ell m}$ are determined by the source distribution. For a continuous, uniform spherical shell of radius $R$ and total mass $M$, the surface mass density is $\\sigma = M / (4\\pi R^2)$. The summation in the Particle-to-Local (P2L) formula becomes an integral over the surface of the sphere, $S$:\n$$\nL_{\\ell m} = \\frac{4\\pi}{2\\ell+1} \\int_{S} \\sigma \\frac{Y_{\\ell m}(\\hat{\\vec{x}}')}{R^{\\ell+1}} dS'\n$$\nSubstituting $dS' = R^2 d\\Omega'$ (where $d\\Omega'$ is the solid angle element) and the constant $\\sigma$:\n$$\nL_{\\ell m} = \\frac{4\\pi}{2\\ell+1} \\frac{\\sigma R^2}{R^{\\ell+1}} \\int_{S^2} Y_{\\ell m}(\\hat{\\vec{x}}') d\\Omega' = \\frac{M}{(2\\ell+1)R^{\\ell-1}} \\int_{S^2} Y_{\\ell m}(\\hat{\\vec{x}}') d\\Omega'\n$$\nThe integral of a spherical harmonic over the unit sphere is non-zero only for the $(\\ell, m) = (0, 0)$ mode. Specifically, noting that $Y_{00} = 1/\\sqrt{4\\pi}$ is constant, we use the orthonormality property $\\int_{S^2} Y_{\\ell m} Y_{\\ell' m'} d\\Omega' = \\delta_{\\ell\\ell'} \\delta_{mm'}$:\n$$\n\\int_{S^2} Y_{\\ell m}(\\hat{\\vec{x}}') d\\Omega' = \\int_{S^2} Y_{\\ell m}(\\hat{\\vec{x}}') (\\sqrt{4\\pi} Y_{00}(\\hat{\\vec{x}}')) d\\Omega' = \\sqrt{4\\pi} \\delta_{\\ell 0} \\delta_{m 0}\n$$\nTherefore, all coefficients $L_{\\ell m}$ are zero for $\\ell \\geq 1$. For $(\\ell, m) = (0, 0)$:\n$$\nL_{00} = \\frac{M}{(2(0)+1)R^{0-1}} (\\sqrt{4\\pi}) = \\sqrt{4\\pi} \\frac{M}{R}\n$$\nThis matches the analytic coefficients provided in the problem statement. Inserting these coefficients back into the expansion for the potential $\\Phi(\\vec{x})$ inside the shell:\n$$\n\\Phi(\\vec{x}) = - G \\left( L_{00} r^0 Y_{00}(\\hat{\\vec{x}}) + \\sum_{\\ell=1}^{\\infty} \\dots \\right) = - G \\left( \\left(\\sqrt{4\\pi}\\frac{M}{R}\\right) \\cdot 1 \\cdot \\left(\\frac{1}{\\sqrt{4\\pi}}\\right) \\right) = - \\frac{GM}{R}\n$$\nThe potential inside the shell is constant. Consequently, the gravitational acceleration, $\\vec{g}(\\vec{x}) = - \\nabla \\Phi(\\vec{x})$, is the gradient of a constant, which is identically zero: $\\vec{g}(\\vec{x}) = \\vec{0}$. This formally proves the shell theorem within the FMM framework.\n\n### Numerical Implementation\n\nThe core of the task is to translate this formalism into a numerical program.\n\n**1. Source Particle Distribution**\nA discrete approximation of the uniform shell is constructed using $N=600$ particles of equal mass $m_i=M/N$. To satisfy the requirement for a symmetric, deterministic arrangement in antipodal pairs, we generate $N/2 = 300$ points on the unit sphere using a Fibonacci spiral, which provides a highly uniform distribution. For each point $\\vec{p}_i$ generated, its antipode $-\\vec{p}_i$ is also added to the set of source positions. This construction strictly ensures that for every mass particle, there is another identical mass particle at the diametrically opposite position. This antipodal symmetry has a crucial consequence: for any multipole of odd degree $\\ell$, its contribution from a point and its antipode cancel out. That is, $Y_{\\ell m}(-\\hat{\\vec{x}}) = (-1)^\\ell Y_{\\ell m}(\\hat{\\vec{x}})$. The sum over pairs gives $[1 + (-1)^\\ell] Y_{\\ell m}(\\hat{\\vec{x}})$. This is zero if $\\ell$ is odd. Thus, all discrete $L_{\\ell m}$ coefficients for odd $\\ell$ will be analytically zero, a property we can use to verify the implementation. The non-zero coefficients for even $\\ell \\ge 2$ represent the deviation of the discrete distribution from perfect spherical symmetry and are the source of the numerical self-force.\n\n**2. Real Spherical Harmonics**\nThe real, orthonormal spherical harmonics $Y_{\\ell m}$ are implemented as functions of polar angle $\\theta$ and azimuthal angle $\\phi$ according to the specified formulae. The computation relies on the associated Legendre polynomials $P_\\ell^m(\\cos\\theta)$, which are efficiently and accurately calculated using `scipy.special.lpmv`. The normalization factors containing factorials are calculated directly, as the maximum expansion order $p=8$ is small enough to avoid numerical overflow. A function `cart_to_spherical` is used to convert Cartesian coordinates $(x,y,z)$ to the required spherical coordinates $(r, \\theta, \\phi)$.\n\n**3. P2L and L2P Implementation**\nWith the source points and spherical harmonic functions in place, the program performs the two main FMM steps:\n- **Particle-to-Local (P2L)**: The local expansion coefficients $L_{\\ell m}$ for the discrete shell are computed by summing the contributions from all $N=600$ particles up to a maximum order $p_{max}=8$:\n$$\nL_{\\ell m} = \\frac{4\\pi}{2\\ell+1} \\frac{M/N}{R^{\\ell+1}} \\sum_{i=1}^{N} Y_{\\ell m}(\\hat{\\vec{x}}_i)\n$$\n- **Local-to-Particle (L2P)**: The potential $\\Phi(\\vec{x})$ at a target point $\\vec{x}$ is evaluated by summing the truncated local expansion using the computed $L_{\\ell m}$ coefficients:\n$$\n\\Phi(\\vec{x}) = - G \\sum_{\\ell=0}^{p} \\sum_{m=-\\ell}^{\\ell} L_{\\ell m} \\, r^\\ell \\, Y_{\\ell m}(\\hat{\\vec{x}})\n$$\nA special case is handled for $\\vec{x}=\\vec{0}$, where only the $\\ell=0$ term contributes, yielding $\\Phi(\\vec{0}) = -G L_{00} Y_{00} = -G L_{00}/\\sqrt{4\\pi}$.\n\n**4. Gravitational Acceleration and Numerical Differentiation**\nThe gravitational acceleration $\\vec{g} = -\\nabla\\Phi$ is computed numerically using a second-order central difference scheme for each Cartesian component:\n$$\ng_x(\\vec{x}) \\approx - \\frac{\\Phi(x+h, y, z) - \\Phi(x-h, y, z)}{2h}\n$$\nand similarly for $g_y$ and $g_z$. The step size $h$ must be chosen to balance the truncation error of the finite difference approximation (proportional to $h^2$) and the round-off error from floating-point subtraction (proportional to $\\epsilon/h$, where $\\epsilon$ is machine precision). With characteristic scales of $R=1$ and $|\\Phi| \\approx 1$, and using double-precision arithmetic ($\\epsilon \\approx 10^{-16}$), an optimal choice for $h$ is typically around $\\epsilon^{1/3} \\approx 10^{-5.3}$. We choose a conservative and standard value of $h=10^{-6}$, which is much smaller than the shell radius $R=1$ and provides a stable and accurate approximation of the gradient.\n\n**5. Symmetry-Enforced Operator**\nThis operator simulates an ideal scenario where only the spherically symmetric component of the source distribution is considered. It is implemented by taking the full set of computed discrete $L_{\\ell m}$ coefficients and setting all coefficients to zero for $\\ell \\geq 1$, retaining only the $L_{00}$ term. This effectively projects the potential onto its monopole component, analytically forcing it to be constant inside the shell.\n\n### Analysis of Test Cases\nThe six test cases are designed to probe different aspects of the numerical method:\n- **Case 1**: Evaluates $\\vec{g}$ at the exact center ($d=0$). Due to the perfect antipodal symmetry of the source points, the potential function $\\Phi(\\vec{x})$ is an even function, $\\Phi(-\\vec{x})=\\Phi(\\vec{x})$. The central difference formula at the origin, e.g., for $g_x$, involves $\\Phi(h,0,0) - \\Phi(-h,0,0)$, which evaluates to zero. Thus, the computed acceleration $\\|\\vec{g}\\|$ is expected to be numerically zero.\n- **Case 2 & 3**: Compare the self-force at $d=0.3R$ for low ($p=2$) and high ($p=8$) expansion orders. The FMM expansion converges to the true potential of the *discrete* particle set as $p$ increases. Since the discrete set is not perfectly symmetric, it does produce a non-zero interior field. Thus, increasing $p$ from $2$ to $8$ should yield a more accurate (and likely larger) value for this non-zero force.\n- **Case 4**: Evaluates the self-force at $d=0.9R$ with $p=8$. The contribution of higher-order multipoles scales with $(r/R)^\\ell$. As this point is much closer to the shell, the effect of the non-zero $L_{\\ell m}$ for $\\ell \\ge 2$ should be significantly more pronounced than at $d=0.3R$, leading to a much larger $\\|\\vec{g}\\|$.\n- **Case 5**: Uses the analytically derived coefficients for a perfect continuous shell. As proven above, this must result in a constant potential and thus $\\|\\vec{g}\\| = \\vec{0}$ (up to machine precision). This case serves as a baseline and validates the L2P evaluation and differentiation steps.\n- **Case 6**: Applies the symmetry-enforced operator to the discrete coefficients. By explicitly zeroing all non-monopole terms ($L_{\\ell m}$ for $\\ell \\ge 1$), the potential is forced to be constant, and $\\|\\vec{g}\\|$ must again be numerically zero. This demonstrates that the numerical self-force is entirely contained in the higher-order multipole moments generated by the discretization.", "answer": "```python\nimport numpy as np\nfrom scipy.special import lpmv, factorial\nimport math\n\n# Meticulous setup of constants and parameters\nG_const = 1.0\nM_const = 1.0\nR_const = 1.0\nN_particles = 600\nDIFF_H = 1e-6 # Step size for central difference\n\ndef cart_to_spherical(pos):\n    \"\"\"Converts Cartesian coordinates to spherical (r, theta, phi).\"\"\"\n    x, y, z = pos\n    r = np.linalg.norm(pos)\n    if r == 0:\n        return 0.0, 0.0, 0.0\n    theta = np.arccos(z / r)\n    phi = np.arctan2(y, x)\n    return r, theta, phi\n\nclass SphericalHarmonics:\n    \"\"\"Computes real, orthonormal spherical harmonics Y_lm.\"\"\"\n    \n    _memo_fact = {}\n    _memo_lpmv = {}\n\n    @classmethod\n    def _factorial(cls, n):\n        if n not in cls._memo_fact:\n            cls._memo_fact[n] = factorial(n, exact=False)\n        return cls._memo_fact[n]\n\n    @classmethod\n    def get_Ylm(cls, l, m, theta, phi):\n        \"\"\"\n        Computes the value of the real orthonormal spherical harmonic Y_lm(theta, phi).\n        \"\"\"\n        if l < 0 or abs(m) > l:\n            raise ValueError(\"Invalid (l, m) indices\")\n\n        abs_m = abs(m)\n        cos_theta = np.cos(theta)\n        \n        # Use memoization for P_lm evaluation\n        lpmv_key = (abs_m, l, cos_theta)\n        if lpmv_key not in cls._memo_lpmv:\n            # SciPy's lpmv computes P_l^m(cos(theta))\n            cls._memo_lpmv[lpmv_key] = lpmv(abs_m, l, cos_theta)\n        plm = cls._memo_lpmv[lpmv_key]\n\n        if m == 0:\n            norm = np.sqrt((2 * l + 1) / (4 * np.pi))\n            return norm * plm\n        else:\n            # Use log-gamma for stability if factorials were large, but l up to p=8 is fine.\n            fact_ratio = cls._factorial(l - abs_m) / cls._factorial(l + abs_m)\n            norm = np.sqrt(2.0 * (2 * l + 1) / (4 * np.pi) * fact_ratio)\n            \n            if m > 0:\n                return norm * plm * np.cos(m * phi)\n            else: # m < 0\n                return norm * plm * np.sin(abs_m * phi)\n\ndef generate_antipodal_sphere_points(N, R):\n    \"\"\"\n    Generates N points on a sphere of radius R in antipodal pairs.\n    Uses a Fibonacci spiral for the base N/2 points.\n    \"\"\"\n    if N % 2 != 0:\n        raise ValueError(\"N must be even for antipodal pairs.\")\n    \n    points = np.zeros((N, 3))\n    n_half = N // 2\n    \n    golden_ratio = (1 + np.sqrt(5)) / 2\n    \n    for i in range(n_half):\n        z = 1 - (2 * i + 1) / n_half\n        radius_xy = np.sqrt(1 - z**2)\n        \n        phi_angle = 2 * np.pi * i / golden_ratio\n        \n        x = radius_xy * np.cos(phi_angle)\n        y = radius_xy * np.sin(phi_angle)\n        \n        points[i] = [R * x, R * y, R * z]\n        points[i + n_half] = [-R * x, -R * y, -R * z]\n        \n    return points\n\ndef compute_L_lm(particles, M, R, N, p_max):\n    \"\"\"\n    Computes the Particle-to-Local (P2L) expansion coefficients L_lm.\n    \"\"\"\n    L_lm = {}\n    m_particle = M / N\n    \n    particle_sph_coords = [cart_to_spherical(p) for p in particles]\n\n    for l in range(p_max + 1):\n        for m in range(-l, l + 1):\n            y_lm_sum = 0.0\n            for r_i, theta_i, phi_i in particle_sph_coords:\n                y_lm_sum += SphericalHarmonics.get_Ylm(l, m, theta_i, phi_i)\n            \n            # For our shell, r_i is always R. r_i**(l+1) = R**(l+1).\n            prefactor = (4 * np.pi) / (2 * l + 1)\n            L_lm[(l, m)] = prefactor * m_particle * y_lm_sum / (R**(l + 1))\n            \n    return L_lm\n\ndef evaluate_potential(pos, p, L_lm, G):\n    \"\"\"\n    Evaluates the potential Phi at a given position using the L2P expansion.\n    \"\"\"\n    r, theta, phi = cart_to_spherical(pos)\n\n    if r == 0:\n        # Potential at the origin depends only on the L_00 term.\n        # Phi(0) = -G * L_00 * Y_00 = -G * L_00 / sqrt(4pi)\n        if (0, 0) in L_lm:\n            return -G * L_lm[(0, 0)] / np.sqrt(4 * np.pi)\n        else:\n            return 0.0\n\n    phi_val = 0.0\n    for l in range(p + 1):\n        r_pow_l = r**l\n        for m in range(-l, l + 1):\n            if (l, m) in L_lm and L_lm[(l, m)] != 0:\n                y_lm_val = SphericalHarmonics.get_Ylm(l, m, theta, phi)\n                phi_val += L_lm[(l, m)] * r_pow_l * y_lm_val\n    \n    return -G * phi_val\n\ndef calculate_g_magnitude(target_pos, p, L_lm, G, h):\n    \"\"\"\n    Computes the magnitude of the gravitational acceleration vector g = -grad(Phi)\n    using central differences.\n    \"\"\"\n    x, y, z = target_pos\n    \n    # Calculate g_x\n    phi_plus_x = evaluate_potential(np.array([x + h, y, z]), p, L_lm, G)\n    phi_minus_x = evaluate_potential(np.array([x - h, y, z]), p, L_lm, G)\n    g_x = -(phi_plus_x - phi_minus_x) / (2 * h)\n\n    # Calculate g_y\n    phi_plus_y = evaluate_potential(np.array([x, y + h, z]), p, L_lm, G)\n    phi_minus_y = evaluate_potential(np.array([x, y - h, z]), p, L_lm, G)\n    g_y = -(phi_plus_y - phi_minus_y) / (2 * h)\n    \n    # Calculate g_z\n    phi_plus_z = evaluate_potential(np.array([x, y, z + h]), p, L_lm, G)\n    phi_minus_z = evaluate_potential(np.array([x, y, z - h]), p, L_lm, G)\n    g_z = -(phi_plus_z - phi_minus_z) / (2 * h)\n    \n    return np.linalg.norm([g_x, g_y, g_z])\n\n\ndef solve():\n    test_cases = [\n    # (d/R, p, use_symmetry_operator, use_analytic_coeffs)\n        (0.0,   8, False, False),  # Case 1\n        (0.3,   2, False, False),  # Case 2\n        (0.3,   8, False, False),  # Case 3\n        (0.9,   8, False, False),  # Case 4\n        (0.3,   8, False, True),   # Case 5\n        (0.3,   8, True,  False),  # Case 6\n    ]\n\n    p_max = max(case[1] for case in test_cases)\n    \n    # 1. Generate source particles\n    particles = generate_antipodal_sphere_points(N_particles, R_const)\n    \n    # 2. Compute discrete L_lm coefficients once for the highest p\n    L_lm_discrete = compute_L_lm(particles, M_const, R_const, N_particles, p_max)\n    \n    results = []\n    for d_ratio, p, symm_enforced, is_analytic in test_cases:\n        d = d_ratio * R_const\n        \n        # Since the setup is symmetric, we can test along one axis.\n        target_pos = np.array([d, 0.0, 0.0])\n        \n        current_L_lm = {}\n        if is_analytic:\n            # Case 5: Use analytic L_lm for a perfect sphere\n            for l in range(p + 1):\n                for m in range(-l, l + 1):\n                    current_L_lm[(l,m)] = 0.0\n            current_L_lm[(0,0)] = np.sqrt(4 * np.pi) * M_const / R_const\n        else:\n            # Use pre-computed discrete coefficients\n            current_L_lm = L_lm_discrete.copy()\n            \n            if symm_enforced:\n                # Case 6: Project discrete coefficients onto l=0 mode\n                L00_val = current_L_lm.get((0,0), 0.0)\n                for l in range(1, p + 1):\n                    for m in range(-l, l + 1):\n                        current_L_lm[(l,m)] = 0.0\n        \n        g_mag = calculate_g_magnitude(target_pos, p, current_L_lm, G_const, DIFF_H)\n        results.append(g_mag)\n\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3510080"}, {"introduction": "In realistic astrophysical simulations, the distribution of matter is highly non-uniform, making a fixed expansion order $p$ for all interactions computationally inefficient. This advanced practice addresses this challenge by guiding you through the implementation of an adaptive error-control scheme. You will develop an in-situ error estimator that uses information from the source multipole moments themselves to dynamically select the minimum expansion order $p$ needed to meet a specified accuracy target for each interaction, reflecting a key feature of modern, high-performance FMM codes [@problem_id:3510075].", "problem": "You are to implement an in-situ estimator for truncation error in the Fast Multipole Method (FMM) for Newtonian gravity that auto-tunes the multipole expansion order per interaction list to meet a uniform relative force error target. The estimator must use ratios of precomputed source multipole moments to infer a conservative local decay rate and decide the minimal expansion order $p$ per source-target pair. All quantities are nondimensionalized with gravitational constant $G=1$, so no physical units appear in the numerical values.\n\nBegin from the following fundamental base:\n- Newtonian potential: for a source with mass density $\\rho(\\mathbf{x}')$ and a target location $\\mathbf{x}$, the gravitational potential is $\\Phi(\\mathbf{x}) = -\\int \\rho(\\mathbf{x}') \\, \\lVert \\mathbf{x}-\\mathbf{x}' \\rVert^{-1} \\, d^3\\mathbf{x}'$ and the force magnitude scaling is $F \\sim \\lVert \\nabla \\Phi \\rVert$.\n- Analyticity and convergence: for a bounded source region of radius $a$ and a target region at separation $R$ satisfying $R > a$, the multipole expansion of $1/\\lVert \\mathbf{x}-\\mathbf{x}' \\rVert$ converges absolutely, and truncation after order $p$ produces a remainder whose magnitude decays at least geometrically with ratio $\\rho = a/R$.\n\nYou are given, for each source-target pair, the center-to-center separation $d$, the source bounding radius $a$, the target bounding radius $b$, the total source mass $M_0$, and a list of precomputed source multipole moment magnitudes $\\{ m_k \\}_{k=0}^{K}$, where $m_0 = M_0$ and $m_k$ is a nonnegative scalar summarizing the magnitude of all order-$k$ multipole moments about the source cell center. You must:\n- Estimate a conservative local geometric decay factor $\\hat{r}$ from the data using moment ratios and the geometric bound $\\rho = a/R$ with $R = d - b$.\n- Define dimensionless normalized moments $\\alpha_k = m_k / (M_0 a^k)$ for $k \\ge 0$.\n- Construct a conservative envelope for the first neglected normalized moment amplitude at order $p+1$ via\n$$\nA_{\\mathrm{env}}(p) \\equiv \\max_{0 \\le j \\le \\min(p,K)} \\left( \\alpha_j \\, \\hat{r}^{\\, p - j} \\right).\n$$\n- Use the following estimator for the relative force error when truncating at order $p$\n$$\n\\mathcal{E}_{\\mathrm{rel}}(p) \\;=\\; A_{\\mathrm{env}}(p)\\;\\frac{\\hat{r}}{1-\\hat{r}}\\;\\left(\\frac{a}{R}\\right)^{p+1},\n$$\nwhich is obtained by comparing the estimated tail to the monopole force scale $M_0/R^2$ and summing a geometric series with ratio at most $\\hat{r}$.\n- Choose the minimal integer $p \\in \\{0,1,\\dots,p_{\\max}\\}$, where $p_{\\max} = K$, such that $\\mathcal{E}_{\\mathrm{rel}}(p) \\le \\varepsilon$, where $\\varepsilon$ is the target uniform relative force error budget for the given pair. If no such $p$ exists, return $-1$ for that pair.\n\nDefinition of the in-situ local decay estimator $\\hat{r}$:\n- Let $R = d - b$ and $\\rho = a/R$. Compute $\\alpha_k = m_k / (M_0 a^k)$ for all $k$ with $a > 0$.\n- Form the set of admissible local ratios $\\mathcal{Q} = \\{ q_k \\equiv \\alpha_k / \\alpha_{k-1} \\;|\\; 1 \\le k \\le K,\\; \\alpha_{k-1} > 0,\\; \\alpha_k > 0 \\}$. If $\\mathcal{Q}$ is nonempty, define $q_{\\mathrm{tail}}$ as the maximum of the last $\\min(3,|\\mathcal{Q}|)$ elements of $\\mathcal{Q}$ in index order; otherwise set $q_{\\mathrm{tail}} = \\rho$. Finally, define\n$$\n\\hat{r} \\;=\\; \\min\\left(\\rho,\\; q_{\\mathrm{tail}}\\right),\n$$\nand clamp $\\hat{r}$ into the interval $[0,1 - 10^{-12}]$ to avoid division by zero.\n\nEdge conditions and constraints:\n- Assume $a > 0$, $b \\ge 0$, $d > b$, and $m_k \\ge 0$ with $m_0 = M_0 > 0$. If $R \\le 0$ or $\\rho \\ge 1$, the input violates the well-separated requirement; such cases are not included in the test suite.\n- If all $\\alpha_k = 0$ for $k \\ge 1$, then $\\mathcal{Q}$ is empty and $\\hat{r} = \\rho$. The envelope $A_{\\mathrm{env}}(p)$ then decays as $\\hat{r}^p$ from $\\alpha_0=1$, and the estimator still applies.\n- Your program must implement the above logic exactly and return an integer $p$ per case, with $-1$ if no $p \\le p_{\\max}$ satisfies the error tolerance.\n\nTest suite to implement and evaluate:\n- Case 1 (far field, uniform moments):\n  - $M_0 = 1.0$, $a = 0.5$, $b = 0.2$, $d = 3.0$, $\\varepsilon = 10^{-4}$,\n  - $K = 8$ and $m_k = M_0 a^k$ for $k = 0,1,\\dots,8$; explicitly $[1.0, 0.5, 0.25, 0.125, 0.0625, 0.03125, 0.015625, 0.0078125, 0.00390625]$.\n- Case 2 (closer field, uniform moments):\n  - $M_0 = 1.0$, $a = 0.5$, $b = 0.2$, $d = 1.0$, $\\varepsilon = 10^{-3}$,\n  - $K = 24$ and $m_k = M_0 a^k$ for $k = 0,1,\\dots,24$.\n- Case 3 (high symmetry with vanishing odd moments):\n  - $M_0 = 1.0$, $a = 0.3$, $b = 0.1$, $d = 1.0$, $\\varepsilon = 10^{-6}$,\n  - Moments: $m_0 = 1.0$, $m_1 = 0.0$, $m_2 = 0.1 \\, a^2$, $m_3 = 0.0$, $m_4 = 0.01 \\, a^4$, and $m_k = 0$ for $k \\ge 5$ up to $K = 8$.\n- Case 4 (heterogeneous clustering with growing mid-order content):\n  - $M_0 = 1.0$, $a = 0.6$, $b = 0.05$, $d = 2.0$, $\\varepsilon = 5 \\cdot 10^{-4}$,\n  - Normalized amplitudes $\\alpha_k = [1.0, 0.2, 0.5, 1.2, 0.9, 0.5, 0.3, 0.18, 0.1]$ for $k = 0,\\dots,8$, and moments $m_k = \\alpha_k M_0 a^k$.\n- Case 5 (insufficient maximum order to meet a very tight tolerance):\n  - $M_0 = 1.0$, $a = 0.9$, $b = 0.1$, $d = 1.05$, $\\varepsilon = 10^{-8}$,\n  - $K = 6$ and $m_k = M_0 a^k$ for $k = 0,1,\\dots,6$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, \"[result1,result2,result3]\"), where each result is the chosen integer $p$ for the corresponding case in the order listed above. If a case has no feasible $p \\le K$, output $-1$ for that case.", "solution": "The problem requires the implementation of an algorithm to determine the minimal multipole expansion order, denoted by $p$, required to achieve a specified relative force error tolerance, $\\varepsilon$, for a given source-target cell pair in a Fast Multipole Method (FMM) context for Newtonian gravity. The method is an in-situ error estimator, meaning it utilizes data available during the FMM computation itself, specifically the precomputed multipole moments of the source cell.\n\nThe analytical foundation of this problem lies in the multipole expansion of the Newtonian potential, where the potential at a target location $\\mathbf{x}$ due to a source distribution $\\rho(\\mathbf{x}')$ is given by $\\Phi(\\mathbf{x}) = -\\int \\rho(\\mathbf{x}') \\, \\lVert \\mathbf{x}-\\mathbf{x}' \\rVert^{-1} \\, d^3\\mathbf{x}'$. For a source cell of radius $a$ and a target cell at a minimum separation $R$, the expansion of the Green's function, $1/\\lVert \\mathbf{x}-\\mathbf{x}' \\rVert$, converges provided the cells are well-separated, i.e., $R > a$. Truncating this expansion after order $p$ introduces an error. The magnitude of the leading error term, and thus the overall error, is expected to scale proportionally to $\\smash{(a/R)^{p+1}}$. The problem provides a sophisticated heuristic estimator for this relative error.\n\nThe core of the task is to implement the given error estimator, $\\mathcal{E}_{\\mathrm{rel}}(p)$, and use it to find the smallest integer $p \\in \\{0, 1, \\dots, K\\}$ (where $K$ is the maximum available expansion order) such that $\\mathcal{E}_{\\mathrm{rel}}(p) \\le \\varepsilon$.\n\nThe error estimator is defined as:\n$$\n\\mathcal{E}_{\\mathrm{rel}}(p) = A_{\\mathrm{env}}(p) \\cdot \\frac{\\hat{r}}{1-\\hat{r}} \\cdot \\left(\\frac{a}{R}\\right)^{p+1}\n$$\n\nThis formula is composed of three key components, each of which must be calculated precisely as specified.\n\n1.  **Geometric Decay and Separation:** The term $\\smash{(a/R)^{p+1}}$ captures the fundamental geometric decay of the truncation error. Here, $a$ is the source bounding radius, and $R = d - b$ is the minimum separation between the source and target spheres, with $d$ being the center-to-center distance and $b$ the target bounding radius. We define the fundamental geometric decay ratio as $\\rho = a/R$.\n\n2.  **Local Decay Estimator $\\hat{r}$:** This factor, $\\hat{r}$, provides a more refined, data-driven estimate of the error decay rate. It is designed to be conservative (i.e., to not underestimate the error) by comparing the purely geometric decay $\\rho$ with decay rates inferred from the source's actual multipole moments.\n    - First, the dimensionless normalized moment magnitudes, $\\alpha_k = m_k / (M_0 a^k)$, are computed for $k = 0, \\dots, K$. Here, $m_k$ are the provided moment magnitudes and $M_0 = m_0$ is the total source mass. By definition, $\\alpha_0 = 1$.\n    - Next, a set of local decay ratios, $\\mathcal{Q} = \\{ q_k \\equiv \\alpha_k / \\alpha_{k-1} \\;|\\; 1 \\le k \\le K,\\; \\alpha_{k-1} > 0,\\; \\alpha_k > 0 \\}$, is formed. These ratios measure the decay between consecutive non-zero normalized moments.\n    - If $\\mathcal{Q}$ is not empty, an estimate $q_{\\mathrm{tail}}$ is taken as the maximum of the last $\\min(3, |\\mathcal{Q}|)$ ratios in $\\mathcal{Q}$. This focuses on the asymptotic behavior of the moments. If $\\mathcal{Q}$ is empty (e.g., due to vanishing higher-order moments), $q_{\\mathrm{tail}}$ is conservatively set to $\\rho$.\n    - Finally, $\\hat{r}$ is defined as the more conservative (slower) of the two decay rates: $\\hat{r} = \\min(\\rho, q_{\\mathrm{tail}})$. A numerical clamp, $\\hat{r} \\in [0, 1 - 10^{-12}]$, is applied to prevent division by zero in the error formula.\n\n3.  **Amplitude Envelope $A_{\\mathrm{env}}(p)$:** This term estimates the magnitude of the normalized moment at the first neglected order, $p+1$. A simple assumption of monotonic decay can be fragile if the $\\alpha_k$ sequence is non-monotonic (e.g., for heterogeneous sources). The specified envelope provides a robust, conservative estimate by projecting forward the maximum influence of all preceding moments:\n    $$\n    A_{\\mathrm{env}}(p) \\equiv \\max_{0 \\le j \\le \\min(p,K)} \\left( \\alpha_j \\, \\hat{r}^{\\, p - j} \\right)\n    $$\n    This can be computed efficiently within a loop over $p$ using the recurrence $A_{\\mathrm{env}}(p) = \\max \\left( A_{\\mathrm{env}}(p-1) \\cdot \\hat{r}, \\alpha_p \\right)$, with the base case $A_{\\mathrm{env}}(0) = \\alpha_0 = 1$.\n\nThe factor $\\smash{\\hat{r} / (1-\\hat{r})}$ in the estimator arises from summing a geometric series with ratio $\\hat{r}$, which bounds the contribution of all neglected terms beyond order $p+1$.\n\nThe overall algorithm proceeds as follows:\nFirst, for a given source-target pair's parameters ($M_0$, $a$, $b$, $d$, $\\varepsilon$, $K$, $\\{m_k\\}$), the quantities $R$, $\\rho$, and the sequence $\\alpha_k$ are computed.\nSecond, the local decay estimator $\\hat{r}$ is determined according to its definition.\nThird, we iterate through candidate expansion orders $p$ from $0$ to $K$. In each iteration, we calculate $A_{\\mathrm{env}}(p)$ and then the full error estimate $\\mathcal{E}_{\\mathrm{rel}}(p)$. The first value of $p$ for which $\\mathcal{E}_{\\mathrm{rel}}(p) \\le \\varepsilon$ is the desired result. If the loop completes without finding such a $p$, it implies that the error tolerance cannot be met with the available moment information, and the function returns $-1$.\nThis procedure is applied to each test case provided in the problem statement to generate the final list of results.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _calculate_p(M0, a, b, d, epsilon, K, m_k):\n    \"\"\"\n    Calculates the minimal multipole expansion order p for a single case.\n    \"\"\"\n    # Step 1: Pre-computation of geometric factors and normalized moments.\n    R = d - b\n    # Problem statement guarantees R > 0 and a/R < 1 for test cases.\n    rho = a / R\n\n    # Calculate normalized moments alpha_k\n    # Note: a > 0 is a given constraint for all test cases.\n    alpha_k = np.array([m / (M0 * a**k) if M0 > 0 and a > 0 else 0 for k, m in enumerate(m_k)], dtype=np.float64)\n    # Correct for k=0 with a=0 case, although not in problem tests. Also handles M0=0.\n    if M0 > 0:\n        alpha_k[0] = m_k[0] / M0\n    \n    # Step 2: Determination of the local decay estimator r_hat.\n    q_ratios = []\n    for k in range(1, K + 1):\n        if alpha_k[k-1] > 0 and alpha_k[k] > 0:\n            q_ratios.append(alpha_k[k] / alpha_k[k-1])\n    \n    if not q_ratios:\n        q_tail = rho\n    else:\n        num_to_consider = min(3, len(q_ratios))\n        tail_ratios = q_ratios[-num_to_consider:]\n        q_tail = max(tail_ratios)\n\n    r_hat = min(rho, q_tail)\n    \n    # Clamp r_hat to avoid division by zero in the error estimator.\n    r_hat = np.clip(r_hat, 0.0, 1.0 - 1e-12)\n\n    # Step 3: Iterative search for p.\n    # Initialize A_env for p=0\n    # A_env(p-1) is not defined for p=0. Base case is A_env(0) = alpha_0 = 1.\n    A_env_p = 1.0\n\n    for p in range(K + 1):\n        # Calculate A_env(p) using the efficient recurrence relation\n        # A_env(p) = max(A_env(p-1) * r_hat, alpha_p)\n        if p > 0:\n            # Note: min(p, K) is just p since we loop p up to K.\n            A_env_p = max(A_env_p * r_hat, alpha_k[p])\n\n        # Calculate the relative force error estimator E_rel(p).\n        # The term rho**(p+1) is (a/R)**(p+1).\n        error_factor = r_hat / (1.0 - r_hat)\n        error = A_env_p * error_factor * (rho**(p + 1))\n\n        if error <= epsilon:\n            return p\n\n    # If the loop finishes, no suitable p was found.\n    return -1\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the solver.\n    \"\"\"\n    \n    # Case 1: far field, uniform moments\n    a1 = 0.5\n    K1 = 8\n    m_k1 = [1.0 * a1**k for k in range(K1 + 1)]\n    case1 = {'M0': 1.0, 'a': a1, 'b': 0.2, 'd': 3.0, 'epsilon': 1e-4, 'K': K1, 'm_k': m_k1}\n\n    # Case 2: closer field, uniform moments\n    a2 = 0.5\n    K2 = 24\n    m_k2 = [1.0 * a2**k for k in range(K2 + 1)]\n    case2 = {'M0': 1.0, 'a': a2, 'b': 0.2, 'd': 1.0, 'epsilon': 1e-3, 'K': K2, 'm_k': m_k2}\n\n    # Case 3: high symmetry with vanishing odd moments\n    a3 = 0.3\n    K3 = 8\n    m_k3 = np.zeros(K3 + 1, dtype=np.float64)\n    m_k3[0] = 1.0\n    m_k3[1] = 0.0\n    m_k3[2] = 0.1 * a3**2\n    m_k3[3] = 0.0\n    m_k3[4] = 0.01 * a3**4\n    case3 = {'M0': 1.0, 'a': a3, 'b': 0.1, 'd': 1.0, 'epsilon': 1e-6, 'K': K3, 'm_k': m_k3}\n\n    # Case 4: heterogeneous clustering\n    a4 = 0.6\n    K4 = 8\n    alpha_k4 = np.array([1.0, 0.2, 0.5, 1.2, 0.9, 0.5, 0.3, 0.18, 0.1])\n    m_k4 = [alpha_k4[k] * 1.0 * a4**k for k in range(K4 + 1)]\n    case4 = {'M0': 1.0, 'a': a4, 'b': 0.05, 'd': 2.0, 'epsilon': 5e-4, 'K': K4, 'm_k': m_k4}\n    \n    # Case 5: insufficient maximum order\n    a5 = 0.9\n    K5 = 6\n    m_k5 = [1.0 * a5**k for k in range(K5 + 1)]\n    case5 = {'M0': 1.0, 'a': a5, 'b': 0.1, 'd': 1.05, 'epsilon': 1e-8, 'K': K5, 'm_k': m_k5}\n    \n    test_cases = [case1, case2, case3, case4, case5]\n\n    results = []\n    for case in test_cases:\n        result = _calculate_p(**case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3510075"}]}