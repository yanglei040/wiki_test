{"hands_on_practices": [{"introduction": "In computational electromagnetics, the theoretical elegance of vector calculus identities must translate into algebraic truths within our discrete models. This practice focuses on the cornerstone of Gauss's law: the Divergence Theorem. You will numerically verify that the discrete outward flux of a vector field across the boundary of a complex polyhedral cell equals the discrete volume integral of its divergence inside, even on highly skewed meshes common in practical engineering problems.[@problem_id:3310393] This exercise is a fundamental sanity check for any finite volume or finite element code, ensuring that the geometric and quadrature rules are correctly implemented.", "problem": "Design and implement a program to numerically verify the equivalence between the integral and differential forms of Gauss's law for electric displacement on highly skewed convex polyhedral control volumes. The verification must be carried out by computing, for each control volume $K$, the absolute difference between the outward flux of the electric displacement field across its boundary and the volume integral of the free charge density inside it, namely the quantity\n$$\n\\left|\\sum_{f \\subset \\partial K} \\int_{f} \\mathbf{D}\\cdot \\mathbf{n}_{f}\\, dA \\;-\\; \\int_{K} \\rho\\, dV \\right|.\n$$\nThe program must compute this difference using only numerical quadrature with specified accuracy properties, on a set of prescribed skewed polyhedral cells. All physical quantities must be expressed in the International System of Units (SI). The final output must be the absolute differences in coulombs (C), one per test case.\n\nFundamental base to be used:\n- Vector calculus definition of divergence and the divergence theorem as applied in computational electromagnetics.\n- The constitutive Gauss's law in differential form for the electric displacement field states that the divergence of the electric displacement field equals the free charge density, and its integral counterpart equates the outward flux of $\\mathbf{D}$ to the enclosed free charge. You must not assume any boundary conditions or material relations beyond what is specified below.\n- Numerical quadrature rules of provable polynomial exactness on simplices: a degree-$2$ symmetric three-point quadrature on triangles and the centroid rule on tetrahedra.\n\nField specification:\n- Define the electric displacement field $\\mathbf{D}:\\mathbb{R}^3\\to\\mathbb{R}^3$ by the quadratic polynomial components\n$$\nD_x(x,y,z) = a\\,x^2 + b\\,y z + c\\,x + d,\\quad\nD_y(x,y,z) = e\\,y^2 + f\\,z x + g\\,y + h,\\quad\nD_z(x,y,z) = i\\,z^2 + j\\,x y + k\\,z + l,\n$$\nwith constants\n$$\na=0.7,\\; b=-1.3,\\; c=0.25,\\; d=-0.5,\\quad\ne=-0.4,\\; f=1.1,\\; g=0.35,\\; h=0.2,\\quad\ni=0.6,\\; j=-0.9,\\; k=-0.45,\\; l=0.1.\n$$\nFrom the definition of divergence, the free charge density is\n$$\n\\rho(x,y,z) = \\frac{\\partial D_x}{\\partial x} + \\frac{\\partial D_y}{\\partial y} + \\frac{\\partial D_z}{\\partial z}\n= 2 a\\,x + 2 e\\,y + 2 i\\,z + c + g + k\n= 1.4\\,x - 0.8\\,y + 1.2\\,z + 0.15.\n$$\nInterpret $\\mathbf{D}$ in coulombs per square meter (C/m$^2$) and $\\rho$ in coulombs per cubic meter (C/m$^3$).\n\nGeometric and numerical setup:\n- For each polyhedral control volume $K$, the outward flux $\\sum_{f \\subset \\partial K} \\int_{f} \\mathbf{D}\\cdot \\mathbf{n}_{f}\\, dA$ must be computed by decomposing each planar polygonal face $f$ into triangles $(\\mathbf{a},\\mathbf{b},\\mathbf{c})$ using a fan triangulation about one vertex, taking the outward unit normal $\\mathbf{n}_f$ constant over the face, and applying the degree-$2$ symmetric three-point quadrature on each triangle:\n  - Use the barycentric quadrature points $(\\lambda_1,\\lambda_2,\\lambda_3) \\in \\{(2/3,1/6,1/6),(1/6,2/3,1/6),(1/6,1/6,2/3)\\}$ with equal weights $w=1/3$.\n  - Map each barycentric tuple to a physical point $\\mathbf{p}=\\lambda_1 \\mathbf{a}+\\lambda_2 \\mathbf{b}+\\lambda_3 \\mathbf{c}$ and accumulate $\\sum w\\, (\\mathbf{D}(\\mathbf{p})\\cdot \\mathbf{n}_f)\\, \\text{area}(\\triangle \\mathbf{a}\\mathbf{b}\\mathbf{c})$ over all quadrature points and all triangles of the face.\n- The volume integral $\\int_{K} \\rho\\, dV$ must be computed by decomposing the convex polyhedron into tetrahedra formed by a reference point $\\mathbf{r}$ strictly inside $K$ and the triangular fan of each face, and applying the centroid rule on each tetrahedron:\n  - For each tetrahedron with vertices $(\\mathbf{r},\\mathbf{a},\\mathbf{b},\\mathbf{c})$, use its centroid $\\mathbf{m}=(\\mathbf{r}+\\mathbf{a}+\\mathbf{b}+\\mathbf{c})/4$ and exact volume $V_{\\text{tet}} = \\left|\\det(\\mathbf{a}-\\mathbf{r},\\mathbf{b}-\\mathbf{r},\\mathbf{c}-\\mathbf{r})\\right|/6$, and accumulate $\\rho(\\mathbf{m})\\, V_{\\text{tet}}$.\n  - You must use $\\mathbf{r}$ equal to the arithmetic mean of all vertices of $K$, which lies inside $K$ for all convex test cells provided here.\n\nTest suite (all coordinates are in meters):\n- Test case $1$ (skewed tetrahedron). Vertices: $(0,0,0)$, $(3.0,0.1,0.0)$, $(0.2,2.5,0.05)$, $(0.1,0.05,0.8)$. Faces as vertex loops: $[0,1,2]$, $[0,3,1]$, $[1,3,2]$, $[2,3,0]$.\n- Test case $2$ (highly skewed, near-degenerate tetrahedron). Vertices: $(0,0,0)$, $(10.0,0.01,0.02)$, $(0.02,9.0,0.03)$, $(0.01,0.02,0.001)$. Faces: $[0,1,2]$, $[0,3,1]$, $[1,3,2]$, $[2,3,0]$.\n- Test case $3$ (affinely skewed hexahedron). Start from the unit cube vertices with indices $0$ to $7$: $(0,0,0)$, $(1,0,0)$, $(1,1,0)$, $(0,1,0)$, $(0,0,1)$, $(1,0,1)$, $(1,1,1)$, $(0,1,1)$. Apply the affine map $(x',y',z') = (x + 0.8 y + 0.6 z,\\; 1.2 y + 0.1 z,\\; 0.2 y + 0.9 z)$. Faces (as loops of indices in the transformed list): $[0,1,2,3]$, $[4,5,6,7]$, $[0,3,7,4]$, $[1,5,6,2]$, $[0,1,5,4]$, $[3,2,6,7]$.\n- Test case $4$ (sheared pentagonal prism). Base pentagon in the $z=0$ plane with vertices (indices $0$ to $4$): $(0.0,0.0,0.0)$, $(2.0,0.2,0.0)$, $(2.5,1.5,0.0)$, $(1.2,2.6,0.0)$, $(-0.1,1.3,0.0)$. Top pentagon obtained by shear and lift: for each base $(x,y,0)$ define top $(x+1.5,\\; y-0.4,\\; 0.3)$. Top vertices have indices $5$ to $9$ corresponding to base indices $0$ to $4$. Faces: bottom $[0,1,2,3,4]$, top $[5,6,7,8,9]$, and five lateral faces $[0,1,6,5]$, $[1,2,7,6]$, $[2,3,8,7]$, $[3,4,9,8]$, $[4,0,5,9]$.\n\nImplementation requirements:\n- For each face, ensure its vertex loop orientation yields an outward normal. You must enforce outward orientation by computing a provisional face normal and flipping the loop if the normal points toward the polyhedron centroid instead of away from it.\n- For each test case, compute the absolute difference $\\left|\\sum_{f} \\int_{f} \\mathbf{D}\\cdot \\mathbf{n}_{f}\\, dA - \\int_{K} \\rho\\, dV \\right|$ in coulombs (C).\n- Angle units are not applicable. All output values must be in coulombs (C).\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[r1,r2,r3,r4]\"). Each entry must be a floating-point number.\n\nThe expected behavior is that the differences are on the order of numerical roundoff for these quadrature choices, even on highly skewed cells, because the surface integral of the quadratic $\\mathbf{D}$ and the volume integral of the linear $\\rho$ are integrated exactly by the specified quadrature rules on simplicial subelements.", "solution": "The objective is to numerically verify the equivalence between the integral and differential forms of Gauss's law for a given electric displacement field $\\mathbf{D}$ on several convex polyhedral volumes $K$. This equivalence is articulated by the Divergence Theorem, which states that the outward flux of a vector field across a closed surface is equal to the volume integral of the divergence of that field within the volume enclosed by the surface:\n$$\n\\sum_{f \\subset \\partial K} \\int_{f} \\mathbf{D}\\cdot \\mathbf{n}_{f}\\, dA = \\int_{K} (\\nabla \\cdot \\mathbf{D})\\, dV\n$$\nIn this context, $\\nabla \\cdot \\mathbf{D} = \\rho$, where $\\rho$ is the free electric charge density. The task reduces to computing the absolute difference between the left-hand side (total flux) and the right-hand side (total enclosed charge).\n\nThe electric displacement field $\\mathbf{D}(x,y,z)$ is a vector field with quadratic polynomial components:\n$$\n\\begin{aligned}\nD_x(x,y,z) &= 0.7\\,x^2 - 1.3\\,y z + 0.25\\,x - 0.5 \\\\\nD_y(x,y,z) &= -0.4\\,y^2 + 1.1\\,z x + 0.35\\,y + 0.2 \\\\\nD_z(x,y,z) &= 0.6\\,z^2 - 0.9\\,x y - 0.45\\,z + 0.1\n\\end{aligned}\n$$\nThe free charge density $\\rho(x,y,z)$ is the divergence of $\\mathbf{D}$:\n$$\n\\rho(x,y,z) = \\frac{\\partial D_x}{\\partial x} + \\frac{\\partial D_y}{\\partial y} + \\frac{\\partial D_z}{\\partial z}\n= 1.4\\,x - 0.8\\,y + 1.2\\,z + 0.15\n$$\nNotably, $\\mathbf{D}$ is a quadratic polynomial field, and its divergence $\\rho$ is a linear polynomial field.\n\nThe numerical strategy hinges on specific quadrature rules chosen for their exactness properties with respect to these integrands.\n\n**1. Computation of the Flux Integral $\\int_{\\partial K} \\mathbf{D}\\cdot \\mathbf{n}\\,dA$**\n\nThe total flux is the sum of fluxes through each planar face $f$ of the polyhedron $K$. For each face, the unit normal vector $\\mathbf{n}_f$ is constant. The integrand $\\mathbf{D}(x,y,z) \\cdot \\mathbf{n}_f$ is a quadratic polynomial in the spatial coordinates $(x,y,z)$. To compute the integral over a polygonal face, the face is first decomposed into a fan of triangles, with the first vertex of its defining loop serving as the common vertex.\n\nFor each triangle $(\\mathbf{a},\\mathbf{b},\\mathbf{c})$, the integral is computed using the specified degree-$2$ symmetric three-point quadrature rule. This rule is exact for polynomials of degree up to $2$. The quadrature points $\\mathbf{p}_k$ are defined via barycentric coordinates $(\\lambda_1, \\lambda_2, \\lambda_3)$ as $\\mathbf{p}_k = \\lambda_1^{(k)}\\mathbf{a} + \\lambda_2^{(k)}\\mathbf{b} + \\lambda_3^{(k)}\\mathbf{c}$. The specified points are $\\{(2/3, 1/6, 1/6), (1/6, 2/3, 1/6), (1/6, 1/6, 2/3)\\}$, each with weight $w_k=1/3$.\nThe integral over one triangle is thus calculated exactly as:\n$$\n\\int_{\\triangle} \\mathbf{D} \\cdot \\mathbf{n}_f \\,dA = \\text{Area}(\\triangle) \\sum_{k=1}^3 w_k \\, (\\mathbf{D}(\\mathbf{p}_k) \\cdot \\mathbf{n}_f)\n$$\nThe total flux is the sum of these values over all triangles comprising the boundary $\\partial K$.\n\n**2. Computation of the Charge Integral $\\int_K \\rho\\,dV$**\n\nThe total charge is computed by decomposing the polyhedron $K$ into a set of tetrahedra. This decomposition is achieved by selecting a reference point $\\mathbf{r}$ inside the polyhedron (taken as the arithmetic mean of its vertices) and forming a tetrahedron for each triangle on the boundary surface. A tetrahedron is thus defined by the vertices $(\\mathbf{r}, \\mathbf{a}, \\mathbf{b}, \\mathbf{c})$, where $(\\mathbf{a}, \\mathbf{b}, \\mathbf{c})$ are the vertices of a triangle from a face's fan triangulation. This method ensures a complete partition of the convex volume $K$.\n\nThe integrand $\\rho(x,y,z)$ is a linear polynomial. The integral over each tetrahedron is computed using the centroid rule, which evaluates the integrand at the tetrahedron's centroid $\\mathbf{m} = (\\mathbf{r}+\\mathbf{a}+\\mathbf{b}+\\mathbf{c})/4$. This one-point rule is exact for linear polynomials.\nThe integral over one tetrahedron is thus calculated exactly as:\n$$\n\\int_{\\text{tet}} \\rho\\, dV = V_{\\text{tet}} \\cdot \\rho(\\mathbf{m})\n$$\nwhere the volume is given by $V_{\\text{tet}} = \\frac{1}{6} |\\det(\\mathbf{a}-\\mathbf{r}, \\mathbf{b}-\\mathbf{r}, \\mathbf{c}-\\mathbf{r})|$. The total charge is the sum of these values over all tetrahedra in the decomposition.\n\n**3. Algorithmic Implementation**\n\nThe core of the algorithm proceeds as follows for each test case:\n1.  **Preprocessing**: The list of vertices and face loops for the polyhedron $K$ is established. The polyhedron centroid $\\mathbf{r}$ is computed as the arithmetic mean of all vertex coordinates.\n2.  **Face Iteration**: The algorithm iterates through each face defined by a loop of vertex indices.\n3.  **Normal Orientation**: For each face, a provisional normal is computed from the first three vertices in its loop. The dot product of this normal with a vector from the polyhedron centroid $\\mathbf{r}$ to a point on the face (e.g., the first vertex) is checked. If the dot product is negative, the normal is pointing inwards, and the vertex loop of the face is reversed to ensure an outward orientation. The final, correctly oriented unit normal $\\mathbf{n}_f$ is then computed.\n4.  **Simplicial Decomposition and Integration**: Each (now correctly oriented) face is decomposed into a fan of triangles. For each triangle:\n    a.  The flux contribution is calculated using the 3-point quadrature rule and added to a running total for the flux.\n    b.  A tetrahedron is formed with the polyhedron centroid $\\mathbf{r}$. The charge contribution is calculated using the centroid rule and added to a running total for the charge.\n5.  **Final Calculation**: After processing all faces, the absolute difference between the total accumulated flux and the total accumulated charge is computed.\n\nSince both quadrature rules are exact for their respective polynomial integrands (quadratic on triangles, linear on tetrahedra), the computed flux and charge should be equal up to floating-point precision. The resulting difference is therefore expected to be a small number close to machine epsilon.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global constants for the electric displacement field components\n_A, _B, _C, _D = 0.7, -1.3, 0.25, -0.5\n_E, _F, _G, _H = -0.4, 1.1, 0.35, 0.2\n_I, _J, _K, _L = 0.6, -0.9, -0.45, 0.1\n\ndef D_field(p: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the electric displacement vector D at a point p.\n    The field D is quadratic in coordinates.\n    p: A numpy array [x, y, z].\n    \"\"\"\n    x, y, z = p[0], p[1], p[2]\n    Dx = _A * x**2 + _B * y * z + _C * x + _D\n    Dy = _E * y**2 + _F * z * x + _G * y + _H\n    Dz = _I * z**2 + _J * x * y + _K * z + _L\n    return np.array([Dx, Dy, Dz])\n\ndef rho_density(p: np.ndarray) -> float:\n    \"\"\"\n    Computes the free charge density rho = div(D) at a point p.\n    The density rho is linear in coordinates.\n    p: A numpy array [x, y, z].\n    \"\"\"\n    x, y, z = p[0], p[1], p[2]\n    # rho = 2*A*x + 2*E*y + 2*I*z + C + G + K\n    return 2 * _A * x + 2 * _E * y + 2 * _I * z + _C + _G + _K\n\ndef compute_divergence_theorem_error(vertices: list, faces: list) -> float:\n    \"\"\"\n    Computes the absolute difference between the flux integral (surface) and\n    the charge integral (volume) for a given polyhedral control volume.\n\n    Args:\n        vertices: A list of [x, y, z] coordinate tuples/lists for the polyhedron.\n        faces: A list of lists, where each inner list contains the vertex indices\n               defining a face loop.\n\n    Returns:\n        The absolute difference |flux - charge| in coulombs.\n    \"\"\"\n    vertices = np.array(vertices, dtype=float)\n    poly_centroid = np.mean(vertices, axis=0)\n    \n    total_flux = 0.0\n    total_charge = 0.0\n\n    # Quadrature points for triangles (barycentric) and their equal weights\n    bary_coords = np.array([[2/3, 1/6, 1/6], [1/6, 2/3, 1/6], [1/6, 1/6, 2/3]])\n    quad_weight = 1/3\n\n    # Reference point for tetrahedral decomposition of the volume\n    r_center = poly_centroid\n\n    for face_indices in faces:\n        # 1. Ensure face has an outward-pointing normal\n        v_indices = list(face_indices)\n        v0, v1, v2 = vertices[v_indices[0]], vertices[v_indices[1]], vertices[v_indices[2]]\n        \n        provisional_normal = np.cross(v1 - v0, v2 - v0)\n        vec_to_face = v0 - poly_centroid\n\n        if np.dot(provisional_normal, vec_to_face) < 0:\n            v_indices.reverse() # Flip loop if normal points inward\n\n        face_verts = vertices[v_indices]\n        \n        # 2. Compute the constant unit normal for the planar face\n        v0, v1, v2 = face_verts[0], face_verts[1], face_verts[2]\n        face_normal_vec = np.cross(v1 - v0, v2 - v0)\n        norm_of_normal = np.linalg.norm(face_normal_vec)\n        if norm_of_normal < 1e-12: # Avoid division by zero for degenerate faces\n            continue\n        face_unit_normal = face_normal_vec / norm_of_normal\n\n        # 3. Decompose the polygonal face into a fan of triangles (v0 is the hub)\n        for i in range(1, len(face_verts) - 1):\n            a, b, c = face_verts[0], face_verts[i], face_verts[i+1]\n\n            # --- Surface Integral (Flux) Calculation for the triangle (a,b,c) ---\n            # The 3-point rule is exact for the quadratic integrand D.n\n            tri_area = 0.5 * np.linalg.norm(np.cross(b - a, c - a))\n            \n            # Map barycentric quadrature coordinates to physical space\n            quad_points_physical = bary_coords @ np.array([a, b, c])\n            \n            flux_contribution = 0.0\n            for p_q in quad_points_physical:\n                D_at_p = D_field(p_q)\n                integrand_val = np.dot(D_at_p, face_unit_normal)\n                flux_contribution += quad_weight * integrand_val\n            \n            total_flux += flux_contribution * tri_area\n            \n            # --- Volume Integral (Charge) Calculation for tetrahedron (r,a,b,c) ---\n            # The centroid rule is exact for the linear integrand rho\n            tet_volume = np.abs(np.dot(a - r_center, np.cross(b - r_center, c - r_center))) / 6.0\n            \n            tet_centroid = (r_center + a + b + c) / 4.0\n            rho_at_centroid = rho_density(tet_centroid)\n            total_charge += rho_at_centroid * tet_volume\n\n    return np.abs(total_flux - total_charge)\n\n\ndef solve():\n    \"\"\"\n    Defines the test cases, computes the results, and prints them\n    in the specified format.\n    \"\"\"\n    test_cases_data = []\n\n    # Test Case 1: Skewed tetrahedron\n    verts1 = [(0,0,0), (3.0,0.1,0.0), (0.2,2.5,0.05), (0.1,0.05,0.8)]\n    faces1 = [[0,1,2], [0,3,1], [1,3,2], [2,3,0]]\n    test_cases_data.append({'vertices': verts1, 'faces': faces1})\n\n    # Test Case 2: Highly skewed, near-degenerate tetrahedron\n    verts2 = [(0,0,0), (10.0,0.01,0.02), (0.02,9.0,0.03), (0.01,0.02,0.001)]\n    faces2 = [[0,1,2], [0,3,1], [1,3,2], [2,3,0]]\n    test_cases_data.append({'vertices': verts2, 'faces': faces2})\n\n    # Test Case 3: Affinely skewed hexahedron\n    unit_cube_verts = [\n        (0,0,0), (1,0,0), (1,1,0), (0,1,0),\n        (0,0,1), (1,0,1), (1,1,1), (0,1,1)\n    ]\n    def affine_map(v):\n        x, y, z = v\n        xp = x + 0.8 * y + 0.6 * z\n        yp = 1.2 * y + 0.1 * z\n        zp = 0.2 * y + 0.9 * z\n        return (xp, yp, zp)\n    verts3 = [affine_map(v) for v in unit_cube_verts]\n    faces3 = [\n        [0,1,2,3], [4,5,6,7], [0,3,7,4], [1,5,6,2], [0,1,5,4], [3,2,6,7]\n    ]\n    test_cases_data.append({'vertices': verts3, 'faces': faces3})\n\n    # Test Case 4: Sheared pentagonal prism\n    base_verts = [\n        (0.0,0.0,0.0), (2.0,0.2,0.0), (2.5,1.5,0.0), \n        (1.2,2.6,0.0), (-0.1,1.3,0.0)\n    ]\n    def shear_lift_map(v):\n        x, y, z = v\n        return (x + 1.5, y - 0.4, 0.3)\n    top_verts = [shear_lift_map(v) for v in base_verts]\n    verts4 = base_verts + top_verts\n    faces4 = [\n        [0,1,2,3,4], [5,6,7,8,9], \n        [0,1,6,5], [1,2,7,6], [2,3,8,7], [3,4,9,8], [4,0,5,9]\n    ]\n    test_cases_data.append({'vertices': verts4, 'faces': faces4})\n\n    results = []\n    for case in test_cases_data:\n        diff = compute_divergence_theorem_error(case['vertices'], case['faces'])\n        results.append(diff)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3310393"}, {"introduction": "Gauss's law for magnetism, $ \\nabla \\cdot \\mathbf{B} = 0 $, is an absolute constraint in classical electrodynamics, reflecting the experimental fact that magnetic monopoles do not exist. However, not all numerical schemes automatically preserve this crucial property, and discretization errors can lead to the creation of spurious \"numerical monopoles.\" This practice explores how different discretization strategies affect the preservation of this solenoidal constraint.[@problem_id:3310372] By contrasting a simple collocated finite-difference scheme with the industry-standard staggered Yee grid, you will gain firsthand insight into why structure-preserving (or mimetic) discretizations are vital for building physically robust electromagnetic solvers.", "problem": "Consider Maxwell's equations in their quasi-static form and focus on Gauss's law for magnetism, which states that the magnetic flux density satisfies $\\nabla \\cdot \\mathbf{B} = 0$. In numerical computations, discretization errors can generate nonzero effective magnetic monopole density $\\rho_m = \\nabla \\cdot \\mathbf{B}$. Your task is to quantify $\\rho_m$ induced by discretization and study its scaling with mesh refinement and with the approximation order (interpreted here as polynomial degree) for different discretization approaches on a three-dimensional periodic domain.\n\nYou must implement a program that performs the following tasks, starting from the fundamental base consisting of Maxwell's equations, vector calculus identities, and the definition of discrete derivatives on uniform grids:\n\n- Work on a cubic periodic domain $\\Omega = [0,2\\pi]^3$, where all coordinate angles must be treated in radians.\n- Define a smooth, divergence-free magnetic field $\\mathbf{B}(\\mathbf{x})$ by prescribing a continuously differentiable vector potential $\\mathbf{A}(\\mathbf{x})$ and computing $\\mathbf{B} = \\nabla \\times \\mathbf{A}$ analytically. Use the specific choice\n$$\n\\mathbf{A}(\\mathbf{x}) = \\begin{bmatrix}\n\\sin(y+z)\\\\\n\\sin(z+x)\\\\\n\\sin(x+y)\n\\end{bmatrix}, \\qquad \\mathbf{x} = (x,y,z),\n$$\nso that\n$$\n\\mathbf{B}(\\mathbf{x}) = \\nabla \\times \\mathbf{A}(\\mathbf{x}) = \\begin{bmatrix}\n\\cos(x+y) - \\cos(x+z)\\\\\n\\cos(y+z) - \\cos(x+y)\\\\\n\\cos(x+z) - \\cos(y+z)\n\\end{bmatrix},\n$$\nand therefore $\\nabla \\cdot \\mathbf{B}(\\mathbf{x}) = 0$ exactly.\n\n- Implement two discretizations to approximate $\\rho_m$:\n    1. A collocated nodal finite-difference discretization on a uniform $N\\times N\\times N$ grid with periodic boundary conditions. Approximate the divergence $\\nabla \\cdot \\mathbf{B}$ by summing directional derivatives computed with periodic central-difference stencils of order $q \\in \\{2,4\\}$ along each axis. Interpret the stencil order $q$ as the polynomial degree of the discrete approximation. You must compute $\\rho_m$ on the nodal grid as the sum of the three directional derivatives of the sampled $\\mathbf{B}$ components.\n    2. A staggered Yee-type discretization on the same periodic grid, placing the components of $\\mathbf{A}$ on grid edges, computing $\\mathbf{B}$ on faces via a discrete curl that uses periodic forward differences, and then computing the discrete divergence at cell centers by summing face flux differences. This scheme should satisfy a discrete divergence-of-curl identity and therefore yield $\\rho_m$ that is zero up to machine precision.\n\n- For each computed $\\rho_m$ field, quantify the error by its root-mean-square (RMS) value over the grid,\n$$\n\\mathrm{RMS}(\\rho_m) = \\left( \\frac{1}{N^3} \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} \\sum_{k=0}^{N-1} \\rho_m(i,j,k)^2 \\right)^{1/2}.\n$$\nTreat this RMS value as a dimensionless float.\n\n- Study the scaling with mesh refinement and polynomial degree by evaluating a test suite covering multiple $N$ and $q$ values:\n    - Collocated nodal finite difference with $q=2$: $N \\in \\{16, 32, 64\\}$.\n    - Collocated nodal finite difference with $q=4$: $N \\in \\{16, 32, 64\\}$.\n    - Staggered Yee-type discrete curl-divergence: $N \\in \\{16, 32, 64\\}$.\n\n- Your program must compute the RMS values of $\\rho_m$ for the above nine cases, in the order listed. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[\\text{result}_1,\\text{result}_2,\\ldots,\\text{result}_9]$). Each element must be a float. All angle quantities must be in radians, and the RMS values must be dimensionless floats. No user input is permitted; all parameters are fixed as stated.\n\nAll mathematics must be handled consistently and realistically. The discretization must use periodic boundary conditions on $\\Omega$ and uniform spacings $h_x = h_y = h_z = 2\\pi/N$. Ensure that the numerical implementations are self-consistent and adhere to the descriptions above. The goal is to empirically examine how $\\mathrm{RMS}(\\rho_m)$ scales with mesh refinement and discretization order and to contrast this with the divergence-preserving property of the staggered Yee-type scheme.", "solution": "The problem statement is valid. It is scientifically grounded in Maxwell's equations and computational electromagnetics, well-posed with all necessary parameters and methods defined, and objectively stated.\n\nThe problem asks for a quantitative comparison of the numerical magnetic monopole density, $\\rho_m = \\nabla \\cdot \\mathbf{B}$, generated by two different discretization schemes for a given analytical magnetic field $\\mathbf{B}$. The analytical field is derived from a vector potential $\\mathbf{A}$, ensuring that it is divergence-free, i.e., $\\nabla \\cdot \\mathbf{B} = 0$.\n\nThe vector potential is given by\n$$\n\\mathbf{A}(\\mathbf{x}) = \\begin{bmatrix}\n\\sin(y+z)\\\\\n\\sin(z+x)\\\\\n\\sin(x+y)\n\\end{bmatrix}, \\quad \\text{where } \\mathbf{x} = (x,y,z)\n$$\nThe corresponding magnetic field is computed analytically as $\\mathbf{B} = \\nabla \\times \\mathbf{A}$:\n$$\n\\mathbf{B}(\\mathbf{x}) = \\begin{bmatrix}\n\\frac{\\partial A_z}{\\partial y} - \\frac{\\partial A_y}{\\partial z} \\\\\n\\frac{\\partial A_x}{\\partial z} - \\frac{\\partial A_z}{\\partial x} \\\\\n\\frac{\\partial A_y}{\\partial x} - \\frac{\\partial A_x}{\\partial y}\n\\end{bmatrix} = \\begin{bmatrix}\n\\cos(x+y) - \\cos(x+z)\\\\\n\\cos(y+z) - \\cos(x+y)\\\\\n\\cos(x+z) - \\cos(y+z)\n\\end{bmatrix}\n$$\nThe vector calculus identity $\\nabla \\cdot (\\nabla \\times \\mathbf{A}) = 0$ guarantees that this analytical field is exactly divergence-free. However, when discretized on a grid, this property is not always preserved. The numerical divergence, $\\tilde{\\nabla} \\cdot \\tilde{\\mathbf{B}}$, which we denote $\\rho_m$, may be non-zero due to truncation errors. We will quantify this error using the root-mean-square (RMS) value over an $N \\times N \\times N$ grid in the periodic domain $[0, 2\\pi]^3$. The grid spacing is $h = 2\\pi/N$.\n\nThe RMS error is defined as:\n$$\n\\mathrm{RMS}(\\rho_m) = \\left( \\frac{1}{N^3} \\sum_{i,j,k=0}^{N-1} |\\rho_m(i,j,k)|^2 \\right)^{1/2}\n$$\n\nWe will implement and compare two discretization schemes.\n\n1. Collocated Nodal Finite-Difference Scheme.\nIn this approach, all components of the vector field $\\mathbf{B}$ ($B_x, B_y, B_z$) are evaluated at the same grid points (nodes), $(x_i, y_j, z_k) = (ih, jh, kh)$. The divergence $\\rho_m = \\nabla \\cdot \\mathbf{B}$ is approximated by summing the numerical partial derivatives at each node:\n$$\n\\rho_m(i,j,k) = \\left. \\frac{\\partial B_x}{\\partial x} \\right|_{(i,j,k)} + \\left. \\frac{\\partial B_y}{\\partial y} \\right|_{(i,j,k)} + \\left. \\frac{\\partial B_z}{\\partial z} \\right|_{(i,j,k)}\n$$\nThe partial derivatives are computed using periodic central-difference stencils of order $q$.\nFor order $q=2$, the stencil is:\n$$\n\\frac{\\partial f}{\\partial x}\\bigg|_i \\approx \\frac{f_{i+1} - f_{i-1}}{2h}\n$$\nFor order $q=4$, the stencil is:\n$$\n\\frac{\\partial f}{\\partial x}\\bigg|_i \\approx \\frac{-f_{i+2} + 8f_{i+1} - 8f_{i-1} + f_{i-2}}{12h}\n$$\nPeriodicity is handled by wrapping indices around the grid (e.g., $f_{N} = f_0$, $f_{-1} = f_{N-1}$). The truncation error of this scheme is expected to be proportional to $h^q$, so we anticipate that $\\mathrm{RMS}(\\rho_m)$ will decrease as $N$ increases and as $q$ increases.\n\n2. Staggered Yee-type Scheme.\nThis scheme, fundamental to the Finite-Difference Time-Domain (FDTD) method, places different field components at different locations within a grid cell. This staggered arrangement is designed to preserve certain vector calculus identities at the discrete level.\nAs per the problem description, we start by sampling the vector potential $\\mathbf{A}$ on the grid edges, compute $\\mathbf{B}$ on the faces using a discrete curl, and then compute $\\rho_m$ in the cell centers using a discrete divergence. A concrete implementation of this is as follows:\n- Define discrete difference operators on a periodic grid. For a grid function $F_{i,j,k}$, let $D_x$, $D_y$, $D_z$ be backward difference operators, e.g., $D_x F_{i,j,k} = (F_{i,j,k} - F_{i-1,j,k})/h$.\n- Sample the components of $\\mathbf{A}$ on appropriately staggered grids. We can represent this by storing arrays `Ax`, `Ay`, `Az`, where each array corresponds to values at different physical locations.\n- Compute the discrete curl of $\\mathbf{A}$ to obtain the components of $\\mathbf{B}$. We define the discrete curl operator $\\tilde{\\nabla} \\times$ as:\n$$\n\\tilde{\\mathbf{B}} = \\tilde{\\nabla} \\times \\mathbf{A} = \\begin{bmatrix}\nD_y A_z - D_z A_y \\\\\nD_z A_x - D_x A_z \\\\\nD_x A_y - D_y A_x\n\\end{bmatrix}\n$$\n- Compute the discrete divergence of $\\tilde{\\mathbf{B}}$ to find $\\rho_m$. The discrete divergence operator $\\tilde{\\nabla} \\cdot$ is:\n$$\n\\rho_m = \\tilde{\\nabla} \\cdot \\tilde{\\mathbf{B}} = D_x \\tilde{B}_x + D_y \\tilde{B}_y + D_z \\tilde{B}_z\n$$\n- Substituting the expression for $\\tilde{\\mathbf{B}}$ into the divergence equation gives:\n$$\n\\rho_m = D_x(D_y A_z - D_z A_y) + D_y(D_z A_x - D_x A_z) + D_z(D_x A_y - D_y A_x)\n$$\n- Since discrete difference operators commute (e.g., $D_x D_y = D_y D_x$), the terms cancel in pairs:\n$$\n\\rho_m = (D_x D_y A_z - D_y D_x A_z) + (D_y D_z A_x - D_z D_y A_x) + (D_z D_x A_y - D_x D_z A_y) = 0\n$$\nThis demonstrates that the discrete identity $\\tilde{\\nabla} \\cdot (\\tilde{\\nabla} \\times \\mathbf{A}) \\equiv 0$ holds. Consequently, the computed $\\rho_m$ should be zero up to machine floating-point precision, irrespective of the grid resolution $N$.\n\nThe program will implement these two schemes, calculate the RMS of $\\rho_m$ for the nine specified test cases, and report the results. We expect the collocated scheme's error to decrease with $N$ and $q$, while the Yee scheme's error should remain near machine zero.", "answer": "```python\nimport numpy as np\n\ndef calculate_collocated(N, q):\n    \"\"\"\n    Calculates RMS of numerical divergence using a collocated finite-difference scheme.\n\n    Args:\n        N (int): Number of grid points along each dimension.\n        q (int): Order of the central difference stencil (2 or 4).\n\n    Returns:\n        float: The RMS value of the numerical magnetic monopole density.\n    \"\"\"\n    h = 2.0 * np.pi / N\n    coords = np.arange(N) * h\n    \n    # Create a nodal grid (all components at the same points)\n    # Use 'ij' indexing for intuitive axis mapping: axis 0 -> z, axis 1 -> y, axis 2 -> x\n    z_coords, y_coords, x_coords = np.meshgrid(coords, coords, coords, indexing='ij')\n\n    # Sample the analytical B field on the nodal grid\n    B_x = np.cos(x_coords + y_coords) - np.cos(x_coords + z_coords)\n    B_y = np.cos(y_coords + z_coords) - np.cos(x_coords + y_coords)\n    B_z = np.cos(x_coords + z_coords) - np.cos(y_coords + z_coords)\n\n    def central_diff(F, h_val, order, axis):\n        if order == 2:\n            # 2nd-order central difference\n            return (np.roll(F, -1, axis=axis) - np.roll(F, 1, axis=axis)) / (2 * h_val)\n        elif order == 4:\n            # 4th-order central difference\n            return (-np.roll(F, -2, axis=axis) + 8 * np.roll(F, -1, axis=axis) -\n                    8 * np.roll(F, 1, axis=axis) + np.roll(F, 2, axis=axis)) / (12 * h_val)\n        else:\n            raise ValueError(\"Unsupported order q. Must be 2 or 4.\")\n\n    # Compute numerical derivatives\n    # Axis 2 corresponds to x, 1 to y, 0 to z\n    dBx_dx = central_diff(B_x, h, q, axis=2)\n    dBy_dy = central_diff(B_y, h, q, axis=1)\n    dBz_dz = central_diff(B_z, h, q, axis=0)\n\n    # Calculate numerical magnetic monopole density\n    rho_m = dBx_dx + dBy_dy + dBz_dz\n\n    # Calculate RMS error\n    rms_error = np.sqrt(np.mean(rho_m**2))\n    return rms_error\n\ndef calculate_yee(N):\n    \"\"\"\n    Calculates RMS of numerical divergence using a staggered Yee-type scheme.\n\n    Returns:\n        float: The RMS value of the numerical magnetic monopole density.\n    \"\"\"\n    h = 2.0 * np.pi / N\n    \n    # Primal grid nodes (p) and dual grid nodes (d)\n    # The staggered grid points are midpoints between primal nodes.\n    p_coords = np.arange(N) * h\n    d_coords = (np.arange(N) + 0.5) * h\n    \n    # Grid indexing: axis 0 -> z, axis 1 -> y, axis 2 -> x\n\n    # Sample A components on edge-centered grids\n    # Ax is on (p, d, d) grid: (x_i, y_{j+1/2}, z_{k+1/2})\n    Z_d, Y_d, X_p = np.meshgrid(d_coords, d_coords, p_coords, indexing='ij')\n    A_x = np.sin(Y_d + Z_d)\n    \n    # Ay is on (d, p, d) grid: (x_{i+1/2}, y_j, z_{k+1/2})\n    Z_d, Y_p, X_d = np.meshgrid(d_coords, p_coords, d_coords, indexing='ij')\n    A_y = np.sin(Z_d + X_d)\n    \n    # Az is on (d, d, p) grid: (x_{i+1/2}, y_{j+1/2}, z_k)\n    Z_p, Y_d, X_d = np.meshgrid(p_coords, d_coords, d_coords, indexing='ij')\n    A_z = np.sin(X_d + Y_d)\n\n    # Define backward difference operators using np.roll\n    # Dx(F_i) = (F_i - F_{i-1}) / h\n    def D_x(F): return (F - np.roll(F, 1, axis=2)) / h\n    def D_y(F): return (F - np.roll(F, 1, axis=1)) / h\n    def D_z(F): return (F - np.roll(F, 1, axis=0)) / h\n\n    # Discrete curl: B = curl(A)\n    # This maps edge-centered A to face-centered B\n    B_x = D_y(A_z) - D_z(A_y)\n    B_y = D_z(A_x) - D_x(A_z)\n    B_z = D_x(A_y) - D_y(A_x)\n    \n    # Discrete divergence: rho_m = div(B)\n    # This maps face-centered B to cell-centered rho_m\n    rho_m = D_x(B_x) + D_y(B_y) + D_z(B_z)\n\n    # Calculate RMS error. This should be close to machine precision.\n    rms_error = np.sqrt(np.mean(rho_m**2))\n    return rms_error\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    N_vals = [16, 32, 64]\n    results = []\n\n    # Case 1: Collocated, q=2\n    for N in N_vals:\n        results.append(calculate_collocated(N, q=2))\n\n    # Case 2: Collocated, q=4\n    for N in N_vals:\n        results.append(calculate_collocated(N, q=4))\n\n    # Case 3: Staggered Yee-type\n    for N in N_vals:\n        results.append(calculate_yee(N))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3310372"}, {"introduction": "The connection between charge and the electric field, governed by Gauss's law, is not merely static; it is a dynamic relationship enforced by the charge continuity equation, $ \\frac{\\partial \\rho}{\\partial t} + \\nabla \\cdot \\mathbf{J} = 0 $. In time-domain simulations like FDTD, any violation of charge conservation by a numerical current source will inevitably lead to an unphysical accumulation of divergence error in the electric field. This practice guides you to derive and numerically verify how a non-charge-conserving source corrupts the solution over time.[@problem_id:3310387] Successfully completing this exercise will underscore the critical need for consistent source modeling to ensure the long-term stability and physical accuracy of dynamic simulations.", "problem": "Consider a two-dimensional transverse electric ($\\mathrm{TE}_z$) finite-difference time-domain (FDTD) scheme on a uniform Yee grid with square cells of edge length $\\Delta x = \\Delta y$. The electric field has components $E_x$ and $E_y$ staggered on cell edges, and the magnetic field has component $H_z$ staggered on cell centers. Let the discrete fields be stored on indices $i \\in \\{0,1,\\ldots,N_x-1\\}$ and $j \\in \\{0,1,\\ldots,N_y-1\\}$, with periodic boundary conditions in both directions. Assume vacuum permittivity $\\varepsilon_0$ and vacuum permeability $\\mu_0$, and define the speed of light $c = 1/\\sqrt{\\varepsilon_0 \\mu_0}$.\n\nDefine the discrete update equations (explicit leapfrog time stepping) at time step $n$ as follows, where all discrete mathematical operators are the standard Yee grid difference operators and all quantities, including indices and constants, are in $\\LaTeX$:\n\n- Ampère–Maxwell equation updates for the electric field components (from time $t^{n-1/2}$ to $t^{n+1/2}$):\n$$\nE_x^{n+1/2}(i,j) = E_x^{n-1/2}(i,j) + \\frac{\\Delta t}{\\varepsilon_0} \\left( \\frac{H_z^n(i,j) - H_z^n(i,j-1)}{\\Delta y} - J_x^n(i,j) \\right),\n$$\n$$\nE_y^{n+1/2}(i,j) = E_y^{n-1/2}(i,j) + \\frac{\\Delta t}{\\varepsilon_0} \\left( - \\frac{H_z^n(i,j) - H_z^n(i-1,j)}{\\Delta x} - J_y^n(i,j) \\right),\n$$\nwith periodic wrap for indices $i-1$ and $j-1$.\n\n- Faraday’s law update for the magnetic field (from time $t^{n}$ to $t^{n+1}$):\n$$\nH_z^{n+1}(i,j) = H_z^n(i,j) + \\frac{\\Delta t}{\\mu_0} \\left( \\frac{E_y^{n+1/2}(i+1,j) - E_y^{n+1/2}(i,j)}{\\Delta x} - \\frac{E_x^{n+1/2}(i,j+1) - E_x^{n+1/2}(i,j)}{\\Delta y} \\right),\n$$\nwith periodic wrap for indices $i+1$ and $j+1$.\n\nDefine the discrete divergence operator acting on the staggered electric field to evaluate Gauss’s law at cell centers:\n$$\n(\\nabla_d \\cdot \\mathbf{E})^n(i,j) = \\frac{E_x^n(i,j) - E_x^n(i-1,j)}{\\Delta x} + \\frac{E_y^n(i,j) - E_y^n(i,j-1)}{\\Delta y}.\n$$\nLet the charge density be identically zero, $\\rho^n(i,j) = 0$ for all $n$, $i$, and $j$. The discrete Gauss’s law residual at time $t^n$ is then\n$$\ng^n(i,j) = (\\nabla_d \\cdot \\mathbf{E})^n(i,j) - \\frac{\\rho^n(i,j)}{\\varepsilon_0} = (\\nabla_d \\cdot \\mathbf{E})^n(i,j).\n$$\n\nAssume that the current deposition is non-charge-conserving: the discrete continuity equation\n$$\n\\frac{\\partial \\rho}{\\partial t} + \\nabla \\cdot \\mathbf{J} = 0\n$$\nis not enforced in its discrete form. Specifically, let the current be applied only to a single $E_x$ edge as a constant-in-time source with amplitude $J_0$ in $\\mathrm{A/m^2}$, and no corresponding update to $\\rho$. Formally, for a chosen index $(i_0,j_0)$,\n$$\nJ_x^n(i,j) = \\begin{cases}\nJ_0, & \\text{if } i=i_0, j=j_0, \\\\\n0, & \\text{otherwise},\n\\end{cases}\n\\quad\nJ_y^n(i,j) = 0,\n$$\nfor all time steps $n$. This current deposition violates the discrete continuity equation, producing a nonzero discrete divergence of $\\mathbf{J}$.\n\nStarting from Maxwell’s equations and the Yee grid identities, derive the time evolution of the discrete Gauss’s law residual $g^n(i,j)$ and obtain its dependence on the time step $\\Delta t$ and the mesh size $\\Delta x$ in terms of rates or exponents, under the following measurement protocols:\n\n1. Fixed number of steps protocol: keep the number of time steps $N$ fixed while varying the time step $\\Delta t$, with fixed mesh size $\\Delta x$.\n2. Fixed physical time protocol: keep the physical time $T=N \\Delta t$ fixed while varying the time step $\\Delta t$, with fixed mesh size $\\Delta x$.\n3. Spatial refinement protocol: keep the physical time $T$ fixed while varying the mesh size $\\Delta x$, with fixed $\\Delta t$ small enough to satisfy stability for all considered meshes.\n4. Constant Courant–Friedrichs–Lewy (CFL) protocol: keep the CFL number fixed, i.e., choose $\\Delta t = \\sigma \\Delta x / (c \\sqrt{2})$ for a fixed $\\sigma \\in (0,1)$, and keep the number of steps $N$ fixed, while varying $\\Delta x$.\n\nPredict the scaling exponents $p$ and $q$ such that, in each protocol, the maximum-norm residual at the final time,\n$$\nG = \\max_{i,j} |g^n(i,j)|,\n$$\nbehaves as $G \\propto (\\Delta t)^p (\\Delta x)^q$, with $p$ and $q$ depending on the protocol as specified above.\n\nThen, implement the described FDTD scheme and numerically verify the predicted rates by computing measured exponents through two-point log-log slopes across the paired parameter sets in the test suite below. Use the following constants and units:\n- $\\varepsilon_0 = 8.854187817 \\times 10^{-12} \\, \\mathrm{F/m}$, $\\mu_0 = 4\\pi \\times 10^{-7} \\, \\mathrm{H/m}$, $c = 1/\\sqrt{\\varepsilon_0 \\mu_0}$.\n- Use $\\Delta x$ in $\\mathrm{m}$, $\\Delta t$ in $\\mathrm{s}$, $J_0$ in $\\mathrm{A/m^2}$.\n- Report the maximum-norm residual $G$ in $\\mathrm{V/m^2}$, but the final outputs must be dimensionless exponents as decimal floats.\n\nThe test suite parameter sets are:\n\n- Test case $1$ (fixed number of steps): $N_x = N_y = 64$, $\\Delta x = 1.0 \\times 10^{-3} \\, \\mathrm{m}$, $J_0 = 10 \\, \\mathrm{A/m^2}$, $N = 200$. Use two time steps $\\Delta t_1 = 0.2 \\, \\Delta x / (c \\sqrt{2})$ and $\\Delta t_2 = 0.1 \\, \\Delta x / (c \\sqrt{2})$. Compute $G_1$ and $G_2$, and the measured exponent $p_{N\\text{ fixed}} = \\frac{\\log(G_2/G_1)}{\\log(\\Delta t_2/\\Delta t_1)}$.\n\n- Test case $2$ (fixed physical time): Same $N_x$, $N_y$, $\\Delta x$, and $J_0$. Use the same $\\Delta t_1$ and $\\Delta t_2$ as above, but choose $N_1 = 200$ and $N_2 = 400$, so that $T_1 = N_1 \\Delta t_1 = T_2 = N_2 \\Delta t_2$. Compute $G_1$ and $G_2$, and the measured exponent $p_{T\\text{ fixed}} = \\frac{\\log(G_2/G_1)}{\\log(\\Delta t_2/\\Delta t_1)}$.\n\n- Test case $3$ (spatial refinement at fixed physical time): Two meshes with $(N_x,N_y,\\Delta x_1) = (64,64, 1.0 \\times 10^{-3}\\, \\mathrm{m})$ and $(N_x,N_y,\\Delta x_2) = (128,128, 0.5 \\times 10^{-3}\\, \\mathrm{m})$. Choose a single time step $\\Delta t = 0.05 \\, \\Delta x_2/(c \\sqrt{2})$ that satisfies stability for both meshes, and $N=400$ steps for both, so the physical time $T=N\\Delta t$ is fixed. With $J_0 = 10 \\, \\mathrm{A/m^2}$ on the corresponding central edge for each mesh, compute $G_1$ and $G_2$, and the measured exponent $q_{T\\text{ fixed}} = \\frac{\\log(G_2/G_1)}{\\log(\\Delta x_2/\\Delta x_1)}$.\n\n- Test case $4$ (constant CFL and fixed number of steps): Two meshes with $(N_x,N_y,\\Delta x_1) = (64,64, 1.0 \\times 10^{-3}\\, \\mathrm{m})$ and $(N_x,N_y,\\Delta x_2) = (128,128, 0.5 \\times 10^{-3}\\, \\mathrm{m})$. Choose $\\sigma = 0.1$ and set $\\Delta t_k = \\sigma \\Delta x_k/(c \\sqrt{2})$ for $k \\in \\{1,2\\}$. Use $N=200$ steps for both meshes. With $J_0 = 10 \\, \\mathrm{A/m^2}$ on the corresponding central edge for each mesh, compute $G_1$ and $G_2$, and the measured exponent $q_{\\mathrm{CFL}, N\\text{ fixed}} = \\frac{\\log(G_2/G_1)}{\\log(\\Delta x_2/\\Delta x_1)}$.\n\nYour program should implement the above and produce a single line of output containing the four measured exponents as a comma-separated list enclosed in square brackets (for example, $[\\text{result1},\\text{result2},\\text{result3},\\text{result4}]$). The outputs must be decimal floats. Angles are not involved, so no angle units are required. Ensure numerical stability by respecting the Courant–Friedrichs–Lewy (CFL) condition. The final answer must be code, and the program must be complete and runnable without any user input.", "solution": "The user wants to analyze the behavior of the Gauss's law residual in a 2D TEz Finite-Difference Time-Domain (FDTD) simulation when the discrete continuity equation is not satisfied by the current source.\n\n### Problem Validation\n\nThe problem is reviewed against the specified criteria.\n\n- **Givens**: The problem provides the full set of FDTD update equations for a 2D TEz grid, the definition of the discrete divergence operator, the definition of the Gauss's law residual $g^n(i,j)$, a specific non-charge-conserving current source $J_x(i,j) = J_0 \\delta_{i,i_0}\\delta_{j,j_0}$, and four explicit protocols for numerical experiments with all necessary parameters ($N_x, N_y, \\Delta x, \\Delta t, N, J_0$). Physical constants $\\varepsilon_0$ and $\\mu_0$ are provided.\n- **Scientific Grounding**: The problem is based on the standard Yee FDTD algorithm, a well-established method in computational electromagnetics. The core question—analyzing the violation of Gauss's law due to a non-charge-conserving source—is a fundamental and practical topic in the field, known as \"divergence cleaning\" or \"charge conservation\" analysis. The premises and equations are scientifically and mathematically sound.\n- **Well-Posedness**: The problem is unambiguous and self-contained. The FDTD scheme with given sources and boundary conditions has a unique, stable solution (provided the CFL condition is met, which is implicitly handled by the test case parameters). The questions asked are precise and have definite, derivable answers.\n- **Objectivity**: The problem is stated in precise, objective mathematical and physical language, free of subjective claims.\n\n**Verdict**: The problem is **valid**. It is a well-formulated problem in computational electromagnetics that requires both theoretical derivation and numerical verification.\n\n### Theoretical Derivation of Scaling Exponents\n\nThe primary goal is to derive the time evolution of the discrete Gauss's law residual, $g^n(i,j)$. The residual at a given time is defined as the discrete divergence of the electric field. In the leapfrog scheme, electric fields are defined at half-integer time steps ($t^{n-1/2}, t^{n+1/2}, \\ldots$). We define the residual at time $t^{n+1/2}$ as $g^{n+1/2}(i,j) = (\\nabla_d \\cdot \\mathbf{E})^{n+1/2}(i,j)$. This is the most direct approach that avoids time-averaging E-fields. The evolution of this quantity is found by taking the discrete divergence of Ampère's law.\n\nLet's denote the discrete divergence operator by $\\nabla_d \\cdot$ and the discrete curl operator used in the FDTD updates by $\\nabla_d \\times$. The Ampère-Maxwell update for the electric field is:\n$$\n\\frac{\\mathbf{E}^{n+1/2} - \\mathbf{E}^{n-1/2}}{\\Delta t} = \\frac{1}{\\varepsilon_0} (\\nabla_d \\times \\mathbf{H}^n - \\mathbf{J}^n)\n$$\nTaking the discrete divergence of this equation gives:\n$$\n\\nabla_d \\cdot \\left( \\frac{\\mathbf{E}^{n+1/2} - \\mathbf{E}^{n-1/2}}{\\Delta t} \\right) = \\frac{1}{\\varepsilon_0} \\nabla_d \\cdot (\\nabla_d \\times \\mathbf{H}^n - \\mathbf{J}^n)\n$$\nSince the divergence and time-differencing operators commute, the left side becomes:\n$$\n\\frac{(\\nabla_d \\cdot \\mathbf{E})^{n+1/2} - (\\nabla_d \\cdot \\mathbf{E})^{n-1/2}}{\\Delta t} = \\frac{g^{n+1/2} - g^{n-1/2}}{\\Delta t}\n$$\nThe right side becomes:\n$$\n\\frac{1}{\\varepsilon_0} (\\nabla_d \\cdot (\\nabla_d \\times \\mathbf{H}^n) - \\nabla_d \\cdot \\mathbf{J}^n)\n$$\nA key property of the Yee FDTD scheme is that the discrete operators are constructed to satisfy the vector identity $\\nabla \\cdot (\\nabla \\times \\mathbf{A}) = 0$ in its discrete form, i.e., $\\nabla_d \\cdot (\\nabla_d \\times \\mathbf{A}) = 0$. This can be confirmed by explicitly writing out the nested finite-difference operators, which cancel out perfectly.\nThus, the evolution equation for the residual simplifies to:\n$$\n\\frac{g^{n+1/2} - g^{n-1/2}}{\\Delta t} = - \\frac{1}{\\varepsilon_0} (\\nabla_d \\cdot \\mathbf{J}^n)\n$$\nThis can be written as a recurrence relation:\n$$\ng^{n+1/2}(i,j) = g^{n-1/2}(i,j) - \\frac{\\Delta t}{\\varepsilon_0} (\\nabla_d \\cdot \\mathbf{J}^n)(i,j)\n$$\nAssuming the simulation starts from zero fields, the initial residual $g^{-1/2}(i,j) = 0$. The current source is given as constant in time, so $(\\nabla_d \\cdot \\mathbf{J}^n)$ is independent of the time step index $n$. Let's denote it by $(\\nabla_d \\cdot \\mathbf{J})$. Unrolling the recurrence for $N$ time steps, the residual at the final time $t^{N-1/2}$ is:\n$$\ng^{N-1/2}(i,j) = \\sum_{n=0}^{N-1} (g^{n+1/2} - g^{n-1/2}) = -\\sum_{n=0}^{N-1} \\frac{\\Delta t}{\\varepsilon_0} (\\nabla_d \\cdot \\mathbf{J})(i,j) = - \\frac{N \\Delta t}{\\varepsilon_0} (\\nabla_d \\cdot \\mathbf{J})(i,j)\n$$\nNext, we compute the discrete divergence of the specified current source. The source is $J_x(i,j) = J_0$ at a single location $(i_0, j_0)$ and zero otherwise, with $J_y = 0$.\n$$\n(\\nabla_d \\cdot \\mathbf{J})(i,j) = \\frac{J_x(i,j) - J_x(i-1,j)}{\\Delta x} + \\frac{J_y(i,j) - J_y(i,j-1)}{\\Delta y}\n$$\nThis is non-zero only at two locations:\n- At $(i,j)=(i_0, j_0)$: $(\\nabla_d \\cdot \\mathbf{J}) = \\frac{J_0 - 0}{\\Delta x} = \\frac{J_0}{\\Delta x}$\n- At $(i,j)=(i_0+1, j_0)$: $(\\nabla_d \\cdot \\mathbf{J}) = \\frac{0 - J_0}{\\Delta x} = -\\frac{J_0}{\\Delta x}$\nThe maximum absolute value of the current divergence is $\\max_{i,j}|(\\nabla_d \\cdot \\mathbf{J})(i,j)| = \\frac{J_0}{\\Delta x}$.\n\nThe quantity of interest is the maximum-norm residual at the final time, $G = \\max_{i,j} |g^{N-1/2}(i,j)|$.\n$$\nG = \\max_{i,j} \\left| - \\frac{N \\Delta t}{\\varepsilon_0} (\\nabla_d \\cdot \\mathbf{J})(i,j) \\right| = \\frac{N \\Delta t}{\\varepsilon_0} \\max_{i,j} |(\\nabla_d \\cdot \\mathbf{J})(i,j)| = \\frac{N \\Delta t J_0}{\\varepsilon_0 \\Delta x}\n$$\nThis single expression $G \\propto N \\Delta t (\\Delta x)^{-1}$ allows us to predict the scaling exponents $p$ and $q$ (in $G \\propto (\\Delta t)^p (\\Delta x)^q$) for each protocol.\n\n1.  **Fixed number of steps protocol**: $N$ and $\\Delta x$ are fixed. $G \\propto \\Delta t$. Thus, the exponent is $p = 1$.\n2.  **Fixed physical time protocol**: The total physical time $T=N \\Delta t$ is fixed, and $\\Delta x$ is fixed. Substituting $N=T/\\Delta t$ into the expression for $G$, we get $G = \\frac{(T/\\Delta t) \\Delta t J_0}{\\varepsilon_0 \\Delta x} = \\frac{T J_0}{\\varepsilon_0 \\Delta x}$. This is independent of $\\Delta t$. Thus, the exponent is $p = 0$.\n3.  **Spatial refinement protocol**: The physical time $T=N \\Delta t$ is fixed. We vary the mesh size $\\Delta x$. $G = \\frac{T J_0}{\\varepsilon_0 \\Delta x} \\propto (\\Delta x)^{-1}$. Thus, the exponent is $q = -1$.\n4.  **Constant CFL protocol**: The CFL number $\\sigma$ is fixed, so $\\Delta t = \\frac{\\sigma \\Delta x}{c \\sqrt{2}} \\propto \\Delta x$. The number of steps $N$ is fixed. We vary $\\Delta x$. Substituting $\\Delta t$ into the expression for $G$: $G = \\frac{N (\\sigma \\Delta x / (c\\sqrt{2})) J_0}{\\varepsilon_0 \\Delta x} = \\frac{N \\sigma J_0}{\\varepsilon_0 c \\sqrt{2}}$. This expression is independent of $\\Delta x$. Thus, the exponent is $q = 0$.\n\nThe predicted exponents are: $p_{N\\text{ fixed}} = 1$, $p_{T\\text{ fixed}} = 0$, $q_{T\\text{ fixed}} = -1$, and $q_{\\mathrm{CFL}, N\\text{ fixed}} = 0$.\nThe following Python code implements the FDTD simulation to numerically verify these predictions.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and compute scaling exponents.\n    \"\"\"\n    # Define physical constants as provided\n    EPS0 = 8.854187817e-12  # F/m\n    MU0 = 4 * np.pi * 1e-7  # H/m\n    C0 = 1 / np.sqrt(EPS0 * MU0) # Speed of light in vacuum (m/s)\n\n    def run_simulation(Nx, Ny, dx, dt, N_steps, J0):\n        \"\"\"\n        Performs a 2D TEz FDTD simulation based on the problem statement.\n        \n        Args:\n            Nx (int): Number of grid cells in x.\n            Ny (int): Number of grid cells in y.\n            dx (float): Grid spacing in x (and y).\n            dt (float): Time step size.\n            N_steps (int): Total number of time steps.\n            J0 (float): Amplitude of the current source.\n\n        Returns:\n            float: The maximum-norm of the Gauss's law residual at the final time.\n        \"\"\"\n        dy = dx  # Square cells\n\n        # Initialize field arrays\n        Ex = np.zeros((Nx, Ny))\n        Ey = np.zeros((Nx, Ny))\n        Hz = np.zeros((Nx, Ny))\n\n        # Setup the current source Jx at the grid center\n        i0, j0 = Nx // 2, Ny // 2\n        Jx = np.zeros((Nx, Ny))\n        Jx[i0, j0] = J0\n        Jy = np.zeros((Nx, Ny))  # Jy is zero everywhere\n\n        # FDTD update coefficients\n        c_e = dt / EPS0\n        c_h = dt / MU0\n\n        # Main FDTD time-stepping loop\n        for _ in range(N_steps):\n            # Update Electric fields E (from t^n-1/2 to t^n+1/2)\n            # using H at t^n\n            dHz_dy = (Hz - np.roll(Hz, 1, axis=1)) / dy\n            dHz_dx = (Hz - np.roll(Hz, 1, axis=0)) / dx\n            \n            Ex += c_e * (dHz_dy - Jx)\n            Ey += c_e * (-dHz_dx - Jy)\n\n            # Update Magnetic field H (from t^n to t^n+1)\n            # using E at t^n+1/2\n            dEy_dx = (np.roll(Ey, -1, axis=0) - Ey) / dx\n            dEx_dy = (np.roll(Ex, -1, axis=1) - Ex) / dy\n            \n            Hz += c_h * (dEy_dx - dEx_dy)\n\n        # After the loop, Ex and Ey are at the final time t^(N-1/2).\n        # Calculate the discrete divergence residual g^N = div(E^(N-1/2)).\n        # g = (Ex(i,j) - Ex(i-1,j))/dx + (Ey(i,j) - Ey(i,j-1))/dy\n        dEx_dx = (Ex - np.roll(Ex, 1, axis=0)) / dx\n        dEy_dy = (Ey - np.roll(Ey, 1, axis=1)) / dy\n        g = dEx_dx + dEy_dy\n\n        # The residual G is the maximum-norm of g.\n        G = np.max(np.abs(g))\n        \n        return G\n\n    # List to store the four computed exponents\n    results = []\n    \n    # --- Test Case 1: Fixed number of steps ---\n    Nx, Ny = 64, 64\n    dx = 1.0e-3\n    J0 = 10.0\n    N = 200\n    dt_base = dx / (C0 * np.sqrt(2))\n    \n    dt1_case1 = 0.2 * dt_base\n    dt2_case1 = 0.1 * dt_base\n    \n    G1 = run_simulation(Nx, Ny, dx, dt1_case1, N, J0)\n    G2 = run_simulation(Nx, Ny, dx, dt2_case1, N, J0)\n    \n    p_N_fixed = np.log(G2 / G1) / np.log(dt2_case1 / dt1_case1)\n    results.append(p_N_fixed)\n\n    # --- Test Case 2: Fixed physical time ---\n    N1_case2 = 200\n    dt1_case2 = 0.2 * dt_base\n    N2_case2 = 400\n    dt2_case2 = 0.1 * dt_base\n    # Verification: T1 = N1*dt1, T2 = N2*dt2. N2/N1 = 2, dt1/dt2 = 2. So T1=T2.\n    \n    G1 = run_simulation(Nx, Ny, dx, dt1_case2, N1_case2, J0)\n    G2 = run_simulation(Nx, Ny, dx, dt2_case2, N2_case2, J0)\n    \n    p_T_fixed = np.log(G2 / G1) / np.log(dt2_case2 / dt1_case2)\n    results.append(p_T_fixed)\n\n    # --- Test Case 3: Spatial refinement at fixed physical time ---\n    N_case3 = 400\n    # Mesh 1\n    Nx1, Ny1, dx1 = 64, 64, 1.0e-3\n    # Mesh 2\n    Nx2, Ny2, dx2 = 128, 128, 0.5e-3\n    dt_case3 = 0.05 * dx2 / (C0 * np.sqrt(2))\n\n    G1 = run_simulation(Nx1, Ny1, dx1, dt_case3, N_case3, J0)\n    G2 = run_simulation(Nx2, Ny2, dx2, dt_case3, N_case3, J0)\n\n    q_T_fixed = np.log(G2 / G1) / np.log(dx2 / dx1)\n    results.append(q_T_fixed)\n\n    # --- Test Case 4: Constant CFL and fixed number of steps ---\n    N_case4 = 200\n    sigma = 0.1\n    cfl_factor = sigma / (C0 * np.sqrt(2))\n\n    # Mesh 1\n    Nx1, Ny1, dx1 = 64, 64, 1.0e-3\n    dt1 = dx1 * cfl_factor\n    # Mesh 2\n    Nx2, Ny2, dx2 = 128, 128, 0.5e-3\n    dt2 = dx2 * cfl_factor\n    \n    G1 = run_simulation(Nx1, Ny1, dx1, dt1, N_case4, J0)\n    G2 = run_simulation(Nx2, Ny2, dx2, dt2, N_case4, J0)\n\n    q_CFL_N_fixed = np.log(G2 / G1) / np.log(dx2 / dx1)\n    results.append(q_CFL_N_fixed)\n\n    # Print the final list of exponents in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3310387"}]}