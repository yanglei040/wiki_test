{"hands_on_practices": [{"introduction": "The Finite-Difference Time-Domain (FDTD) method is a cornerstone of computational electromagnetics, directly solving Maxwell's equations in the time domain. However, discretizing spacetime introduces numerical artifacts, the most critical of which is numerical dispersion. This practice [@problem_id:3354598] provides a foundational exercise in analyzing this phenomenon by deriving and calculating the numerical phase velocity for waves propagating on a Yee grid, a crucial step in assessing the accuracy of any FDTD simulation.", "problem": "Consider a two-dimensional homogeneous, isotropic, source-free medium characterized by permittivity $\\epsilon$ and permeability $\\mu$. Starting from Maxwell's equations and the constitutive relations, a wave equation for electromagnetic fields can be obtained. In a uniform Cartesian grid, the standard Yee scheme uses staggered spatial sampling with grid steps $\\Delta x$ and $\\Delta y$ and a staggered time step $\\Delta t$ under the Courant-Friedrichs-Lewy (CFL) stability limit. For a plane wave propagating at an oblique angle in the $x$-$y$ plane, the numerical dispersion relation of the Yee scheme links the angular frequency $\\omega$ and the wavenumber components $k_x$ and $k_y$.\n\nYour tasks are:\n- Derive, from first principles, the numerical dispersion relation of the Yee scheme by applying a plane-wave ansatz to the discrete update equations for a homogeneous medium. Then, for a given propagation angle, define $k_x$ and $k_y$ in terms of the wavenumber magnitude $k$ and angle, and use the dispersion relation to compute $\\omega$.\n- Use the dispersion relation to compute the numerical phase velocity $v_{\\mathrm{p,num}}=\\omega/k$, where $k=\\sqrt{k_x^2+k_y^2}$, and compare it to the exact phase velocity $c=1/\\sqrt{\\mu\\epsilon}$ of a continuous plane wave in the same medium. Report the absolute phase velocity error $e=v_{\\mathrm{p,num}}-c$ in $\\mathrm{m/s}$, expressed as a decimal number (not a percentage).\n- Implement a program that, for each test case below, computes the absolute phase velocity error $e$ using $\\omega$ obtained from the Yee numerical dispersion relation in two dimensions. Use degree units for angles.\n\nUse the following test suite. Each case is specified by $(\\Delta x,\\Delta y,\\Delta t,\\phi,\\lambda,\\mu,\\epsilon)$ with units $(\\mathrm{m},\\mathrm{m},\\mathrm{s},\\text{degrees},\\mathrm{m},\\mathrm{H/m},\\mathrm{F/m})$:\n1. $\\Delta x=1\\times 10^{-3}$, $\\Delta y=1\\times 10^{-3}$, $\\Delta t=0.98\\cdot \\dfrac{\\Delta x}{\\sqrt{2}c_0}$, $\\phi=30^\\circ$, $\\lambda=1\\times 10^{-2}$, $\\mu=\\mu_0$, $\\epsilon=\\epsilon_0$, where $\\mu_0=4\\pi\\times 10^{-7}$ and $\\epsilon_0=8.854187817\\times 10^{-12}$, and $c_0=1/\\sqrt{\\mu_0\\epsilon_0}$.\n2. $\\Delta x=5\\times 10^{-4}$, $\\Delta y=1\\times 10^{-3}$, $\\Delta t=0.85\\cdot \\left(\\dfrac{1}{c_0\\sqrt{\\dfrac{1}{\\Delta x^2}+\\dfrac{1}{\\Delta y^2}}}\\right)$, $\\phi=60^\\circ$, $\\lambda=5\\times 10^{-3}$, $\\mu=\\mu_0$, $\\epsilon=\\epsilon_0$.\n3. $\\Delta x=1\\times 10^{-3}$, $\\Delta y=1\\times 10^{-3}$, $\\Delta t=0.5\\cdot \\dfrac{\\Delta x}{\\sqrt{2}c_0}$, $\\phi=0^\\circ$, $\\lambda=2.5\\times \\Delta x$, $\\mu=\\mu_0$, $\\epsilon=\\epsilon_0$.\n4. $\\Delta x=2\\times 10^{-3}$, $\\Delta y=2\\times 10^{-3}$, $\\Delta t=0.5\\cdot \\dfrac{\\Delta x}{\\sqrt{2}c_0}$, $\\phi=45^\\circ$, $\\lambda=4\\times \\Delta x$, $\\mu=\\mu_0$, $\\epsilon=\\epsilon_0$.\n5. $\\Delta x=1.5\\times 10^{-3}$, $\\Delta y=7.5\\times 10^{-4}$, $\\Delta t=0.9\\cdot \\left(\\dfrac{1}{c^\\star\\sqrt{\\dfrac{1}{\\Delta x^2}+\\dfrac{1}{\\Delta y^2}}}\\right)$, $\\phi=20^\\circ$, $\\lambda=6\\times 10^{-3}$, $\\mu=\\mu_0$, $\\epsilon=4\\epsilon_0$, and $c^\\star=1/\\sqrt{\\mu\\epsilon}$ for this medium.\n\nFor each case:\n- Compute the exact phase velocity $c=1/\\sqrt{\\mu\\epsilon}$.\n- Compute the wavenumber magnitude $k=2\\pi/\\lambda$ and components $k_x=k\\cos(\\phi)$ and $k_y=k\\sin(\\phi)$ with $\\phi$ in degrees.\n- Solve the Yee numerical dispersion relation in two dimensions for $\\omega$ and evaluate $v_{\\mathrm{p,num}}=\\omega/k$.\n- Report the absolute phase velocity error $e=v_{\\mathrm{p,num}}-c$ in $\\mathrm{m/s}$.\n\nYour program should produce a single line of output containing the results for the five test cases as a comma-separated list enclosed in square brackets, for example, $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5\\right]$, where each $\\text{result}_i$ is the computed error $e$ for the $i$-th case in $\\mathrm{m/s}$.", "solution": "The problem requires the derivation of the numerical dispersion relation for the two-dimensional Yee Finite-Difference Time-Domain (FDTD) scheme and its application to compute the numerical phase velocity error for several test cases.\n\nLet us begin from first principles. The propagation of electromagnetic waves in a homogeneous, isotropic, and source-free medium is governed by Maxwell's curl equations:\n$$ \\nabla \\times \\mathbf{E} = -\\frac{\\partial \\mathbf{B}}{\\partial t} $$\n$$ \\nabla \\times \\mathbf{H} = \\frac{\\partial \\mathbf{D}}{\\partial t} $$\nWith the linear constitutive relations $\\mathbf{D} = \\epsilon \\mathbf{E}$ and $\\mathbf{B} = \\mu \\mathbf{H}$, where $\\epsilon$ is the permittivity and $\\mu$ is the permeability of the medium, the equations become:\n$$ \\nabla \\times \\mathbf{E} = -\\mu \\frac{\\partial \\mathbf{H}}{\\partial t} \\quad (1) $$\n$$ \\nabla \\times \\mathbf{H} = \\epsilon \\frac{\\partial \\mathbf{E}}{\\partial t} \\quad (2) $$\nFor a two-dimensional problem in the $x$-$y$ plane, we can consider the Transverse Magnetic ($TM_z$) mode, for which the only non-zero field components are $E_z$, $H_x$, and $H_y$. The vector equations $(1)$ and $(2)$ decompose into a set of three scalar equations:\n$$ \\frac{\\partial E_z}{\\partial y} = -\\mu \\frac{\\partial H_x}{\\partial t} \\quad (3) $$\n$$ \\frac{\\partial E_z}{\\partial x} = \\mu \\frac{\\partial H_y}{\\partial t} \\quad (4) $$\n$$ \\frac{\\partial H_y}{\\partial x} - \\frac{\\partial H_x}{\\partial y} = \\epsilon \\frac{\\partial E_z}{\\partial t} \\quad (5) $$\n\nThe Yee FDTD scheme discretizes these equations on a staggered grid. A field component $F(x,y,t)$ is represented as $F^n(i,j) = F(i\\Delta x, j\\Delta y, n\\Delta t)$. The spatial and temporal staggering of the $TM_z$ components is as follows:\n- $E_z$ is evaluated at grid points $(i\\Delta x, j\\Delta y)$ and time steps $n\\Delta t$.\n- $H_x$ is evaluated at $(i\\Delta x, (j+1/2)\\Delta y)$ and time steps $(n+1/2)\\Delta t$.\n- $H_y$ is evaluated at $((i+1/2)\\Delta x, j\\Delta y)$ and time steps $(n+1/2)\\Delta t$.\n\nApplying central finite differences to equations $(3)-(5)$ yields the Yee update equations:\n$$ \\frac{E_z^n(i, j+1) - E_z^n(i, j)}{\\Delta y} = -\\mu \\frac{H_x^{n+1/2}(i, j+1/2) - H_x^{n-1/2}(i, j+1/2)}{\\Delta t} \\quad (6) $$\n$$ \\frac{E_z^n(i+1, j) - E_z^n(i, j)}{\\Delta x} = \\mu \\frac{H_y^{n+1/2}(i+1/2, j) - H_y^{n-1/2}(i+1/2, j)}{\\Delta t} \\quad (7) $$\n$$ \\frac{H_y^{n+1/2}(i+1/2, j) - H_y^{n+1/2}(i-1/2, j)}{\\Delta x} - \\frac{H_x^{n+1/2}(i, j+1/2) - H_x^{n+1/2}(i, j-1/2)}{\\Delta y} = \\epsilon \\frac{E_z^{n+1}(i, j) - E_z^n(i, j)}{\\Delta t} \\quad (8) $$\n\nTo find the numerical dispersion relation, we postulate a plane-wave solution (ansatz) on the discrete grid. For a wave with angular frequency $\\omega$ and wavevector components $k_x$ and $k_y$, the fields are:\n$$ E_z^n(i,j) = E_{z0} e^{\\mathrm{j}(k_x i\\Delta x + k_y j\\Delta y - \\omega n\\Delta t)} $$\n$$ H_x^{n+1/2}(i,j+1/2) = H_{x0} e^{\\mathrm{j}(k_x i\\Delta x + k_y (j+1/2)\\Delta y - \\omega (n+1/2)\\Delta t)} $$\n$$ H_y^{n+1/2}(i+1/2,j) = H_{y0} e^{\\mathrm{j}(k_x (i+1/2)\\Delta x + k_y j\\Delta y - \\omega (n+1/2)\\Delta t)} $$\nwhere $E_{z0}$, $H_{x0}$, and $H_{y0}$ are complex amplitudes. Substituting these into the update equations allows us to solve for the relationship between $\\omega$, $k_x$, and $k_y$.\n\nFrom equation $(6)$:\n$$ E_{z0} \\frac{e^{\\mathrm{j}k_y\\Delta y} - 1}{\\Delta y} = -\\mu H_{x0} e^{\\mathrm{j}k_y\\Delta y/2} \\frac{e^{-\\mathrm{j}\\omega\\Delta t/2} - e^{\\mathrm{j}\\omega\\Delta t/2}}{\\Delta t} $$\nUsing the identity $e^{\\mathrm{j}\\theta}-1=e^{\\mathrm{j}\\theta/2}(2\\mathrm{j}\\sin(\\theta/2))$, the equation simplifies to:\n$$ \\frac{E_{z0}}{\\Delta y} e^{\\mathrm{j}k_y\\Delta y/2} (2\\mathrm{j}\\sin(k_y\\Delta y/2)) = \\mu \\frac{H_{x0}}{\\Delta t} e^{\\mathrm{j}k_y\\Delta y/2} (2\\mathrm{j}\\sin(\\omega\\Delta t/2)) $$\n$$ H_{x0} = \\frac{E_{z0}}{\\mu} \\frac{\\Delta t}{\\Delta y} \\frac{\\sin(k_y\\Delta y/2)}{\\sin(\\omega\\Delta t/2)} \\quad (9) $$\n\nFrom equation $(7)$:\n$$ E_{z0} \\frac{e^{\\mathrm{j}k_x\\Delta x} - 1}{\\Delta x} = \\mu H_{y0} e^{\\mathrm{j}k_x\\Delta x/2} \\frac{e^{-\\mathrm{j}\\omega\\Delta t/2} - e^{\\mathrm{j}\\omega\\Delta t/2}}{\\Delta t} $$\n$$ \\frac{E_{z0}}{\\Delta x} e^{\\mathrm{j}k_x\\Delta x/2} (2\\mathrm{j}\\sin(k_x\\Delta x/2)) = -\\mu \\frac{H_{y0}}{\\Delta t} e^{\\mathrm{j}k_x\\Delta x/2} (2\\mathrm{j}\\sin(\\omega\\Delta t/2)) $$\n$$ H_{y0} = -\\frac{E_{z0}}{\\mu} \\frac{\\Delta t}{\\Delta x} \\frac{\\sin(k_x\\Delta x/2)}{\\sin(\\omega\\Delta t/2)} \\quad (10) $$\n\nFinally, substituting the ansatz into equation $(8)$:\n$$ \\frac{H_{y0}}{\\Delta x} (2\\mathrm{j}\\sin(k_x\\Delta x/2)) - \\frac{H_{x0}}{\\Delta y} (2\\mathrm{j}\\sin(k_y\\Delta y/2)) = \\epsilon \\frac{E_{z0}}{\\Delta t} (-2\\mathrm{j}\\sin(\\omega\\Delta t/2)) $$\nNow, substitute expressions for $H_{x0}$ and $H_{y0}$ from $(9)$ and $(10)$:\n$$ \\frac{1}{\\Delta x} \\left(-\\frac{E_{z0}}{\\mu} \\frac{\\Delta t}{\\Delta x} \\frac{\\sin(k_x\\Delta x/2)}{\\sin(\\omega\\Delta t/2)}\\right)\\sin(k_x\\Delta x/2) - \\frac{1}{\\Delta y}\\left(\\frac{E_{z0}}{\\mu} \\frac{\\Delta t}{\\Delta y} \\frac{\\sin(k_y\\Delta y/2)}{\\sin(\\omega\\Delta t/2)}\\right)\\sin(k_y\\Delta y/2) = -\\frac{\\epsilon E_{z0}}{\\Delta t}\\sin(\\omega\\Delta t/2) $$\nDividing by $-E_{z0}$ and rearranging gives:\n$$ \\frac{\\Delta t}{\\mu \\sin(\\omega\\Delta t/2)}\\left(\\frac{\\sin^2(k_x\\Delta x/2)}{\\Delta x^2} + \\frac{\\sin^2(k_y\\Delta y/2)}{\\Delta y^2}\\right) = \\frac{\\epsilon}{\\Delta t}\\sin(\\omega\\Delta t/2) $$\nMultiplying terms and using the relation for the speed of light in the medium, $c=1/\\sqrt{\\mu\\epsilon}$, we arrive at the numerical dispersion relation for the 2D Yee scheme:\n$$ \\left(\\frac{1}{\\Delta x}\\sin\\left(\\frac{k_x\\Delta x}{2}\\right)\\right)^2 + \\left(\\frac{1}{\\Delta y}\\sin\\left(\\frac{k_y\\Delta y}{2}\\right)\\right)^2 = \\left(\\frac{1}{c\\Delta t}\\sin\\left(\\frac{\\omega\\Delta t}{2}\\right)\\right)^2 $$\n\nTo compute the numerical phase velocity, we first solve for the numerical angular frequency $\\omega$:\n$$ \\sin\\left(\\frac{\\omega\\Delta t}{2}\\right) = c\\Delta t \\sqrt{\\left(\\frac{\\sin(k_x\\Delta x/2)}{\\Delta x}\\right)^2 + \\left(\\frac{\\sin(k_y\\Delta y/2)}{\\Delta y}\\right)^2} $$\n$$ \\omega = \\frac{2}{\\Delta t}\\arcsin\\left(c\\Delta t \\sqrt{\\left(\\frac{\\sin(k_x\\Delta x/2)}{\\Delta x}\\right)^2 + \\left(\\frac{\\sin(k_y\\Delta y/2)}{\\Delta y}\\right)^2}\\right) $$\nThe numerical phase velocity $v_{\\mathrm{p,num}}$ is defined as the ratio of this numerical angular frequency $\\omega$ to the magnitude of the continuous-space wavenumber $k=\\sqrt{k_x^2+k_y^2}$:\n$$ v_{\\mathrm{p,num}} = \\frac{\\omega}{k} $$\nThe absolute phase velocity error $e$ is the difference between the numerical phase velocity and the exact phase velocity $c$ in the continuous medium:\n$$ e = v_{\\mathrm{p,num}} - c $$\n\nFor each test case, the following procedure is implemented:\n1.  Define the constants $\\mu_0=4\\pi\\times 10^{-7} \\, \\mathrm{H/m}$ and $\\epsilon_0=8.854187817\\times 10^{-12} \\, \\mathrm{F/m}$.\n2.  For a given test case $(\\Delta x, \\Delta y, \\Delta t, \\phi, \\lambda, \\mu, \\epsilon)$:\n    a. Compute the exact phase velocity $c=1/\\sqrt{\\mu\\epsilon}$.\n    b. Compute the wavenumber magnitude $k = 2\\pi/\\lambda$.\n    c. Convert the propagation angle $\\phi$ from degrees to radians.\n    d. Compute the wavenumber components $k_x=k\\cos(\\phi)$ and $k_y=k\\sin(\\phi)$.\n    e. Substitute all values into the derived equation for $\\omega$.\n    f. Compute the numerical phase velocity $v_{\\mathrm{p,num}}=\\omega/k$.\n    g. Calculate the absolute error $e = v_{\\mathrm{p,num}} - c$.\nThis procedure is repeated for all five test cases provided.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the numerical phase velocity error for the 2D Yee FDTD scheme\n    for a set of test cases.\n    \"\"\"\n    \n    # Define physical constants from the problem statement\n    mu_0 = 4 * np.pi * 1e-7  # H/m\n    epsilon_0 = 8.854187817e-12  # F/m\n    c_0 = 1 / np.sqrt(mu_0 * epsilon_0)\n\n    # Test cases: (dx, dy, dt_spec, phi_deg, lam_spec, mu_r, eps_r)\n    # dt_spec = (factor, type, c_ref_str)\n    #   type: 'iso' for dx=dy, 'aniso' for dx!=dy\n    #   c_ref_str: 'c0' for vacuum speed, 'c_medium' for material speed\n    # lam_spec = (type, value) where type can be 'abs' or 'rel' to dx\n    test_cases = [\n        (1e-3, 1e-3, (0.98, 'iso', 'c0'), 30, ('abs', 1e-2), 1.0, 1.0),\n        (5e-4, 1e-3, (0.85, 'aniso', 'c0'), 60, ('abs', 5e-3), 1.0, 1.0),\n        (1e-3, 1e-3, (0.5, 'iso', 'c0'), 0, ('rel', 2.5), 1.0, 1.0),\n        (2e-3, 2e-3, (0.5, 'iso', 'c0'), 45, ('rel', 4.0), 1.0, 1.0),\n        (1.5e-3, 7.5e-4, (0.9, 'aniso', 'c_medium'), 20, ('abs', 6e-3), 1.0, 4.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        dx, dy, dt_spec, phi_deg, lam_spec, mu_r, eps_r = case\n        \n        # Unpack specifications\n        dt_factor, dt_type, c_ref_str = dt_spec\n        lam_type, lam_val = lam_spec\n\n        # 1. Calculate medium properties and exact phase velocity\n        mu = mu_r * mu_0\n        epsilon = eps_r * epsilon_0\n        c = 1 / np.sqrt(mu * epsilon)\n        \n        # 2. Calculate time step dt\n        if c_ref_str == 'c0':\n            c_ref_for_dt = c_0\n        else: # 'c_medium'\n            c_ref_for_dt = c\n\n        if dt_type == 'iso':\n            dt = dt_factor * dx / (np.sqrt(2) * c_ref_for_dt)\n        else: # 'aniso'\n            dt = dt_factor / (c_ref_for_dt * np.sqrt(1/dx**2 + 1/dy**2))\n\n        # 3. Calculate wavelength and wavenumber\n        if lam_type == 'rel':\n            lam = lam_val * dx\n        else: # 'abs'\n            lam = lam_val\n\n        k = 2 * np.pi / lam\n        phi_rad = np.deg2rad(phi_deg)\n        kx = k * np.cos(phi_rad)\n        ky = k * np.sin(phi_rad)\n\n        # 4. Solve numerical dispersion relation for omega\n        term_x = (np.sin(kx * dx / 2) / dx)**2\n        term_y = (np.sin(ky * dy / 2) / dy)**2\n        \n        arcsin_arg = c * dt * np.sqrt(term_x + term_y)\n        \n        # The argument must be <= 1 for a stable scheme\n        if arcsin_arg > 1.0 and not np.isclose(arcsin_arg, 1.0):\n             # This should not happen for the given stable test cases\n             raise ValueError(f\"FDTD scheme is unstable. arcsin argument > 1: {arcsin_arg}\")\n        if arcsin_arg > 1.0: # Clamp for floating point inaccuracies\n             arcsin_arg = 1.0\n        \n        omega = (2 / dt) * np.arcsin(arcsin_arg)\n\n        # 5. Compute numerical phase velocity and error\n        v_p_num = omega / k\n        error = v_p_num - c\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3354598"}, {"introduction": "We now shift from time-domain wave propagation to the frequency-domain analysis of resonant structures, which are governed by the Helmholtz eigenproblem. This practice [@problem_id:3354613] explores a powerful analytical tool, the shape derivative, to predict how a cavity's resonant frequency shifts due to small boundary perturbations. Mastering this concept is essential for understanding device sensitivity and provides a theoretical basis for gradient-based optimization in electromagnetic engineering.", "problem": "Consider a two-dimensional perfectly electrically conducting cavity that supports time-harmonic fields satisfying the scalar Helmholtz eigenproblem for a mode amplitude $u$,\n$$\\nabla^2 u + k^2 u = 0 \\quad \\text{in } \\Omega,$$\nwith Dirichlet boundary condition $u\\vert_{\\partial \\Omega}=0$. In a rectangular cavity $\\Omega = (0,L_x)\\times(0,L_y)$, the eigenpairs are indexed by positive integers $(m,n)$, with eigenfunctions $u_{m,n}(x,y)=\\sin\\!\\big(\\frac{m\\pi x}{L_x}\\big)\\sin\\!\\big(\\frac{n\\pi y}{L_y}\\big)$ and eigenvalues $\\lambda_{m,n}=k_{m,n}^2=\\big(\\frac{m\\pi}{L_x}\\big)^2+\\big(\\frac{n\\pi}{L_y}\\big)^2$. Suppose the cavity boundary is perturbed by a small normal displacement field $\\varepsilon V_n$ supported on a portion of $\\partial \\Omega$, where $\\varepsilon$ is a small scalar. Define the frequency shift as the wavenumber change $\\Delta k = k(\\varepsilon)-k(0)$.\n\nYour task is to design, derive, and implement from first principles a boundary perturbation method to compute the first-order frequency shift $\\Delta k$ due to small geometric changes $\\delta \\Gamma$ using the shape derivative of the eigenvalue:\n1) Start from the scalar Helmholtz eigenproblem in the cavity as the fundamental base within computational electromagnetics. Use the normalization $\\int_{\\Omega} u^2 \\, d\\Omega = 1$ for the unperturbed eigenfunction $u$.\n2) Derive from first principles the first-order shape derivative of the eigenvalue $d\\lambda/d\\varepsilon$ for Dirichlet boundary conditions under a smooth normal boundary displacement field $V_n$ supported on a subset of $\\partial \\Omega$.\n3) Specialize your derivation to the rectangle $\\Omega=(0,L_x)\\times(0,L_y)$ and a uniform outward motion by $\\varepsilon$ of one straight boundary segment:\n   - Case X: the right boundary at $x=L_x$ moves to $x=L_x+\\varepsilon$ with $V_n=1$ on that boundary and $V_n=0$ elsewhere.\n   - Case Y: the top boundary at $y=L_y$ moves to $y=L_y+\\varepsilon$ with $V_n=1$ on that boundary and $V_n=0$ elsewhere.\n4) Using your shape-derivative result and the $L^2$-normalized unperturbed eigenfunction, compute the first-order prediction $\\Delta \\lambda_{\\text{shape}} \\approx \\varepsilon \\, d\\lambda/d\\varepsilon$ and the corresponding first-order wavenumber shift $\\Delta k_{\\text{shape}} \\approx \\Delta \\lambda_{\\text{shape}}/(2k)$, where $k=\\sqrt{\\lambda}$ is the unperturbed wavenumber.\n5) Validate your first-order prediction by comparing it to the exact wavenumber shift computed from the analytic eigenvalue formula in the perturbed rectangle with the moved boundary:\n   - For Case X, the exact perturbed eigenvalue is $\\lambda(\\varepsilon)=\\big(\\frac{m\\pi}{L_x+\\varepsilon}\\big)^2+\\big(\\frac{n\\pi}{L_y}\\big)^2$.\n   - For Case Y, the exact perturbed eigenvalue is $\\lambda(\\varepsilon)=\\big(\\frac{m\\pi}{L_x}\\big)^2+\\big(\\frac{n\\pi}{L_y+\\varepsilon}\\big)^2$.\n   From this, define $\\Delta k_{\\text{exact}} = \\sqrt{\\lambda(\\varepsilon)} - \\sqrt{\\lambda(0)}$.\n6) Report, for each test case, the relative error between the shape-derivative prediction and the exact wavenumber shift, defined as\n$$\\mathrm{err} = \\frac{\\left|\\Delta k_{\\text{shape}} - \\Delta k_{\\text{exact}}\\right|}{\\left|\\Delta k_{\\text{exact}}\\right|}.$$\n\nPhysical units: treat $L_x$ and $L_y$ in meters, $k$ and $\\Delta k$ in inverse meters. The relative error is dimensionless.\n\nImplement a complete, runnable program that computes the relative error for the following test suite. Each test specifies $(L_x, L_y, m, n, \\text{boundary}, \\varepsilon)$:\n- Test $1$: $L_x=1.0$, $L_y=1.0$, $m=1$, $n=1$, boundary $=$ right (Case X), $\\varepsilon = 1\\times 10^{-3}$.\n- Test $2$: $L_x=1.0$, $L_y=1.0$, $m=1$, $n=2$, boundary $=$ top (Case Y), $\\varepsilon = 1\\times 10^{-3}$.\n- Test $3$: $L_x=1.0$, $L_y=1.0$, $m=3$, $n=2$, boundary $=$ right (Case X), $\\varepsilon = 5\\times 10^{-2}$.\n- Test $4$: $L_x=2.0$, $L_y=0.5$, $m=2$, $n=3$, boundary $=$ top (Case Y), $\\varepsilon = 1\\times 10^{-4}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[r1,r2,r3,r4]\"), where each $r_i$ is the relative error for Test $i$ as a floating-point number. No other output is permitted.", "solution": "The problem requires the derivation and implementation of a boundary perturbation method to calculate the first-order frequency shift of a two-dimensional electromagnetic cavity resonator. The analysis is based on the shape derivative of the eigenvalue of the scalar Helmholtz equation.\n\nThe governing equation for a time-harmonic mode amplitude $u$ in a two-dimensional domain $\\Omega$ is the scalar Helmholtz eigenproblem:\n$$ \\nabla^2 u + k^2 u = 0 \\quad \\text{in } \\Omega $$\nwith a perfectly conducting boundary, which imposes a Dirichlet boundary condition $u\\vert_{\\partial \\Omega}=0$. The eigenvalue is $\\lambda = k^2$, where $k$ is the wavenumber. The unperturbed eigenfunction $u$ is assumed to be real and normalized such that $\\int_{\\Omega} u^2 \\, d\\Omega = 1$.\n\n**1. First-Principles Derivation of the Eigenvalue Shape Derivative**\n\nLet the domain $\\Omega$ be perturbed by a smooth normal displacement field $\\varepsilon V_n$ on its boundary $\\partial \\Omega$, where $\\varepsilon$ is a small parameter. The new domain is $\\Omega_\\varepsilon$. Let the corresponding eigenpair be $(\\lambda_\\varepsilon, u_\\varepsilon)$ satisfying $\\nabla^2 u_\\varepsilon + \\lambda_\\varepsilon u_\\varepsilon = 0$ in $\\Omega_\\varepsilon$ and $u_\\varepsilon=0$ on $\\partial\\Omega_\\varepsilon$.\n\nWe begin by multiplying the perturbed Helmholtz equation by the unperturbed eigenfunction $u$ and integrating over the perturbed domain $\\Omega_\\varepsilon$:\n$$ \\int_{\\Omega_\\varepsilon} (u \\nabla^2 u_\\varepsilon + \\lambda_\\varepsilon u u_\\varepsilon) \\, d\\Omega_\\varepsilon = 0 $$\nApplying Green's second identity, $\\int_D (f \\nabla^2 g - g \\nabla^2 f) dD = \\int_{\\partial D} (f \\frac{\\partial g}{\\partial n} - g \\frac{\\partial f}{\\partial n}) dS$, on the domain $\\Omega_\\varepsilon$ with functions $u$ and $u_\\varepsilon$:\n$$ \\int_{\\Omega_\\varepsilon} u \\nabla^2 u_\\varepsilon \\, d\\Omega_\\varepsilon = \\int_{\\Omega_\\varepsilon} u_\\varepsilon \\nabla^2 u \\, d\\Omega_\\varepsilon + \\int_{\\partial\\Omega_\\varepsilon} \\left( u \\frac{\\partial u_\\varepsilon}{\\partial n_\\varepsilon} - u_\\varepsilon \\frac{\\partial u}{\\partial n_\\varepsilon} \\right) dS_\\varepsilon $$\nSince $u$ is an eigenfunction on the original domain $\\Omega$, $\\nabla^2 u = -\\lambda u$ holds within $\\Omega_\\varepsilon$ (assuming $\\Omega \\subset \\Omega_\\varepsilon$ or vice-versa, which holds for small $\\varepsilon$). Also, by definition, $u_\\varepsilon = 0$ on the perturbed boundary $\\partial\\Omega_\\varepsilon$. Substituting these into the identity gives:\n$$ \\int_{\\Omega_\\varepsilon} u \\nabla^2 u_\\varepsilon \\, d\\Omega_\\varepsilon = \\int_{\\Omega_\\varepsilon} u_\\varepsilon (-\\lambda u) \\, d\\Omega_\\varepsilon + \\int_{\\partial\\Omega_\\varepsilon} u \\frac{\\partial u_\\varepsilon}{\\partial n_\\varepsilon} \\, dS_\\varepsilon $$\nNow, substituting this back into the first integrated equation:\n$$ -\\lambda \\int_{\\Omega_\\varepsilon} u_\\varepsilon u \\, d\\Omega_\\varepsilon + \\int_{\\partial\\Omega_\\varepsilon} u \\frac{\\partial u_\\varepsilon}{\\partial n_\\varepsilon} \\, dS_\\varepsilon + \\lambda_\\varepsilon \\int_{\\Omega_\\varepsilon} u u_\\varepsilon \\, d\\Omega_\\varepsilon = 0 $$\n$$ (\\lambda_\\varepsilon - \\lambda) \\int_{\\Omega_\\varepsilon} u u_\\varepsilon \\, d\\Omega_\\varepsilon = - \\int_{\\partial\\Omega_\\varepsilon} u \\frac{\\partial u_\\varepsilon}{\\partial n_\\varepsilon} \\, dS_\\varepsilon $$\nTo find the first-order change, we consider the limit as $\\varepsilon \\to 0$.\nThe eigenvalue change is $\\Delta \\lambda = \\lambda_\\varepsilon - \\lambda \\approx \\varepsilon \\frac{d\\lambda}{d\\varepsilon}$.\nAs $\\varepsilon \\to 0$, we have $u_\\varepsilon \\to u$, $\\Omega_\\varepsilon \\to \\Omega$, and the integral on the left side approaches $\\int_\\Omega u^2 d\\Omega = 1$ due to the specified normalization. Thus, the left side is approximately $\\varepsilon \\frac{d\\lambda}{d\\varepsilon}$.\n\nFor the boundary integral on the right side, a point $x_s$ on the perturbed boundary $\\partial\\Omega_\\varepsilon$ can be expressed as $x_s = x + \\varepsilon V_n \\mathbf{n}$, where $x \\in \\partial\\Omega$ and $\\mathbf{n}$ is the outward normal at $x$. We Taylor expand the unperturbed eigenfunction $u$ at the perturbed boundary point $x_s$:\n$$ u(x_s) = u(x + \\varepsilon V_n \\mathbf{n}) \\approx u(x) + \\varepsilon V_n \\frac{\\partial u}{\\partial n}(x) $$\nSince $u=0$ on the unperturbed boundary $\\partial\\Omega$, we have $u(x_s) \\approx \\varepsilon V_n \\frac{\\partial u}{\\partial n}(x)$.\nFurther, as $\\varepsilon \\to 0$, $\\frac{\\partial u_\\varepsilon}{\\partial n_\\varepsilon} \\to \\frac{\\partial u}{\\partial n}$ and $dS_\\varepsilon \\to dS$. The boundary integral becomes:\n$$ - \\int_{\\partial\\Omega} \\left(\\varepsilon V_n \\frac{\\partial u}{\\partial n}\\right) \\left(\\frac{\\partial u}{\\partial n}\\right) \\, dS = -\\varepsilon \\int_{\\partial\\Omega} V_n \\left(\\frac{\\partial u}{\\partial n}\\right)^2 \\, dS $$\nEquating the first-order terms on both sides:\n$$ \\varepsilon \\frac{d\\lambda}{d\\varepsilon} = -\\varepsilon \\int_{\\partial\\Omega} V_n \\left(\\frac{\\partial u}{\\partial n}\\right)^2 \\, dS $$\nDividing by $\\varepsilon$ yields the shape derivative of the eigenvalue for Dirichlet boundary conditions, known as Hadamard's formula:\n$$ \\frac{d\\lambda}{d\\varepsilon} = - \\int_{\\partial\\Omega} V_n \\left(\\frac{\\partial u}{\\partial n}\\right)^2 \\, dS $$\n\n**2. Specialization to a Rectangular Cavity**\n\nFor a rectangular cavity $\\Omega = (0,L_x)\\times(0,L_y)$, the unperturbed eigenfunctions are $u_{m,n}(x,y)=\\sin(\\frac{m\\pi x}{L_x})\\sin(\\frac{n\\pi y}{L_y})$, where $m, n$ are positive integers. We first normalize this eigenfunction. The normalization constant $C$ is found from $\\int_0^{L_y}\\int_0^{L_x} (C u_{m,n})^2 dx dy = 1$:\n$$ C^2 \\int_0^{L_x} \\sin^2\\Big(\\frac{m\\pi x}{L_x}\\Big) dx \\int_0^{L_y} \\sin^2\\Big(\\frac{n\\pi y}{L_y}\\Big) dy = C^2 \\Big(\\frac{L_x}{2}\\Big) \\Big(\\frac{L_y}{2}\\Big) = 1 \\implies C = \\frac{2}{\\sqrt{L_x L_y}} $$\nThe normalized eigenfunction is $u(x,y) = \\frac{2}{\\sqrt{L_x L_y}} \\sin(\\frac{m\\pi x}{L_x})\\sin(\\frac{n\\pi y}{L_y})$.\n\n**Case X: Perturbation of the right boundary $x=L_x$**\nThe perturbation is an outward displacement, so $V_n=1$ on the segment $\\{x=L_x, 0<y<L_y\\}$ and $V_n=0$ elsewhere. The outward normal is $\\mathbf{n}=(1,0)$, so $\\frac{\\partial u}{\\partial n} = \\frac{\\partial u}{\\partial x}$.\n$$ \\frac{\\partial u}{\\partial x} = \\frac{2}{\\sqrt{L_x L_y}} \\Big(\\frac{m\\pi}{L_x}\\Big) \\cos\\Big(\\frac{m\\pi x}{L_x}\\Big)\\sin\\Big(\\frac{n\\pi y}{L_y}\\Big) $$\nEvaluated at $x=L_x$:\n$$ \\frac{\\partial u}{\\partial x}\\bigg|_{x=L_x} = \\frac{2m\\pi}{L_x\\sqrt{L_x L_y}} \\cos(m\\pi) \\sin\\Big(\\frac{n\\pi y}{L_y}\\Big) = (-1)^m \\frac{2m\\pi}{L_x\\sqrt{L_x L_y}} \\sin\\Big(\\frac{n\\pi y}{L_y}\\Big) $$\nSubstituting this into the shape derivative formula:\n$$ \\frac{d\\lambda}{d\\varepsilon} = - \\int_0^{L_y} (1) \\left( (-1)^m \\frac{2m\\pi}{L_x\\sqrt{L_x L_y}} \\sin\\Big(\\frac{n\\pi y}{L_y}\\Big) \\right)^2 dy $$\n$$ \\frac{d\\lambda}{d\\varepsilon} = - \\frac{4 m^2 \\pi^2}{L_x^2(L_x L_y)} \\int_0^{L_y} \\sin^2\\Big(\\frac{n\\pi y}{L_y}\\Big) dy = - \\frac{4 m^2 \\pi^2}{L_x^3 L_y} \\Big(\\frac{L_y}{2}\\Big) = - \\frac{2 m^2 \\pi^2}{L_x^3} $$\n\n**Case Y: Perturbation of the top boundary $y=L_y$**\nThe perturbation is $V_n=1$ for $\\{y=L_y, 0<x<L_x\\}$ and $V_n=0$ elsewhere. The normal is $\\mathbf{n}=(0,1)$, so $\\frac{\\partial u}{\\partial n} = \\frac{\\partial u}{\\partial y}$. Following a symmetric calculation:\n$$ \\frac{\\partial u}{\\partial y}\\bigg|_{y=L_y} = (-1)^n \\frac{2n\\pi}{L_y\\sqrt{L_x L_y}} \\sin\\Big(\\frac{m\\pi x}{L_x}\\Big) $$\n$$ \\frac{d\\lambda}{d\\varepsilon} = - \\int_0^{L_x} (1) \\left( (-1)^n \\frac{2n\\pi}{L_y\\sqrt{L_x L_y}} \\sin\\Big(\\frac{m\\pi x}{L_x}\\Big) \\right)^2 dx = - \\frac{4 n^2 \\pi^2}{L_y^3 L_x} \\Big(\\frac{L_x}{2}\\Big) = - \\frac{2 n^2 \\pi^2}{L_y^3} $$\n\n**3. First-Order Wavenumber Shift Prediction**\nThe first-order change in the eigenvalue $\\lambda$ is $\\Delta \\lambda_{\\text{shape}} \\approx \\varepsilon \\frac{d\\lambda}{d\\varepsilon}$. Since $\\lambda=k^2$, we have $d\\lambda = 2k\\,dk$, so for small changes, $\\Delta\\lambda \\approx 2k \\Delta k$. The first-order wavenumber shift is then:\n$$ \\Delta k_{\\text{shape}} \\approx \\frac{\\Delta \\lambda_{\\text{shape}}}{2k} = \\frac{\\varepsilon}{2k} \\frac{d\\lambda}{d\\varepsilon} $$\nwhere $k=\\sqrt{\\lambda_{m,n}} = \\sqrt{(\\frac{m\\pi}{L_x})^2+(\\frac{n\\pi}{L_y})^2}$ is the unperturbed wavenumber.\n\nFor Case X: $\\Delta k_{\\text{shape}} = \\frac{\\varepsilon}{2k} \\Big(-\\frac{2m^2\\pi^2}{L_x^3}\\Big) = -\\frac{\\varepsilon m^2\\pi^2}{k L_x^3}$\nFor Case Y: $\\Delta k_{\\text{shape}} = \\frac{\\varepsilon}{2k} \\Big(-\\frac{2n^2\\pi^2}{L_y^3}\\Big) = -\\frac{\\varepsilon n^2\\pi^2}{k L_y^3}$\n\n**4. Exact Wavenumber Shift for Validation**\nThe exact eigenvalue in the perturbed rectangle can be calculated analytically.\nFor Case X, the perturbed dimensions are $(L_x+\\varepsilon, L_y)$. The perturbed eigenvalue and wavenumber are:\n$$ \\lambda(\\varepsilon) = \\Big(\\frac{m\\pi}{L_x+\\varepsilon}\\Big)^2+\\Big(\\frac{n\\pi}{L_y}\\Big)^2, \\quad k(\\varepsilon) = \\sqrt{\\lambda(\\varepsilon)} $$\nFor Case Y, the perturbed dimensions are $(L_x, L_y+\\varepsilon)$. The perturbed eigenvalue and wavenumber are:\n$$ \\lambda(\\varepsilon) = \\Big(\\frac{m\\pi}{L_x}\\Big)^2+\\Big(\\frac{n\\pi}{L_y+\\varepsilon}\\Big)^2, \\quad k(\\varepsilon) = \\sqrt{\\lambda(\\varepsilon)} $$\nThe exact wavenumber shift is $\\Delta k_{\\text{exact}} = k(\\varepsilon) - k(0)$.\n\n**5. Relative Error**\nThe relative error between the shape derivative prediction and the exact shift is computed as:\n$$ \\mathrm{err} = \\frac{\\left|\\Delta k_{\\text{shape}} - \\Delta k_{\\text{exact}}\\right|}{\\left|\\Delta k_{\\text{exact}}\\right|} $$\nThe following program implements these formulas to compute this error for the specified test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the relative error between the shape-derivative prediction\n    and the exact wavenumber shift for a perturbed rectangular cavity.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is (Lx, Ly, m, n, boundary, epsilon)\n    test_cases = [\n        (1.0, 1.0, 1, 1, 'right', 1e-3),\n        (1.0, 1.0, 1, 2, 'top', 1e-3),\n        (1.0, 1.0, 3, 2, 'right', 5e-2),\n        (2.0, 0.5, 2, 3, 'top', 1e-4),\n    ]\n\n    results = []\n    for case in test_cases:\n        Lx, Ly, m, n, boundary, eps = case\n\n        # Unperturbed wavenumber k_0\n        k0_sq = (m * np.pi / Lx)**2 + (n * np.pi / Ly)**2\n        k0 = np.sqrt(k0_sq)\n\n        if boundary == 'right':\n            # Case X: Right boundary moves\n            # Shape derivative prediction for Delta_k\n            d_lambda_d_eps = -2 * (m * np.pi)**2 / Lx**3\n            delta_k_shape = (eps * d_lambda_d_eps) / (2 * k0)\n\n            # Exact Delta_k\n            k_eps_sq = (m * np.pi / (Lx + eps))**2 + (n * np.pi / Ly)**2\n            k_eps = np.sqrt(k_eps_sq)\n            delta_k_exact = k_eps - k0\n\n        elif boundary == 'top':\n            # Case Y: Top boundary moves\n            # Shape derivative prediction for Delta_k\n            d_lambda_d_eps = -2 * (n * np.pi)**2 / Ly**3\n            delta_k_shape = (eps * d_lambda_d_eps) / (2 * k0)\n\n            # Exact Delta_k\n            k_eps_sq = (m * np.pi / Lx)**2 + (n * np.pi / (Ly + eps))**2\n            k_eps = np.sqrt(k_eps_sq)\n            delta_k_exact = k_eps - k0\n        \n        else:\n            # Should not happen with the given test cases\n            raise ValueError(\"Invalid boundary specified.\")\n\n        # Relative error calculation\n        if abs(delta_k_exact) == 0:\n            # This case should not occur for non-zero epsilon\n            # and non-trivial perturbations. If it does, the error is ambiguous.\n            rel_error = 0.0 if delta_k_shape == 0 else np.inf\n        else:\n            rel_error = np.abs(delta_k_shape - delta_k_exact) / np.abs(delta_k_exact)\n        \n        results.append(rel_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3354613"}, {"introduction": "For exterior scattering problems, boundary integral equation (BIE) methods offer a powerful alternative to volume-based discretization. A notorious challenge in BIEs, however, is the problem of interior resonance, which leads to ill-conditioned systems at certain frequencies. This exercise [@problem_id:3354579] illuminates this issue by analyzing the spectral properties and conditioning of the Electric Field (EFIE), Magnetic Field (MFIE), and Combined Field (CFIE) formulations, demonstrating why the CFIE is indispensable for robust scattering simulations.", "problem": "Consider the homogeneous Helmholtz equation for time-harmonic fields in three dimensions, written for a complex-valued scalar field as $$\\nabla^2 u(\\mathbf{x}) + k^2 u(\\mathbf{x}) = 0,$$ where $k$ is the wavenumber. The free-space Helmholtz Greenâ€™s function is $$G(\\mathbf{x},\\mathbf{y}) = \\frac{e^{ik|\\mathbf{x}-\\mathbf{y}|}}{4\\pi |\\mathbf{x}-\\mathbf{y}|}.$$ On a smooth closed surface $\\Gamma$, the classical boundary integral operators are the single-layer operator $$\\mathcal{S}[\\rho](\\mathbf{x}) = \\int_{\\Gamma} G(\\mathbf{x},\\mathbf{y}) \\rho(\\mathbf{y}) \\,\\mathrm{d}S_{\\mathbf{y}},$$ and the double-layer operator $$\\mathcal{K}[\\rho](\\mathbf{x}) = \\int_{\\Gamma} \\frac{\\partial G(\\mathbf{x},\\mathbf{y})}{\\partial n_{\\mathbf{y}}} \\rho(\\mathbf{y}) \\,\\mathrm{d}S_{\\mathbf{y}},$$ where $\\partial/\\partial n_{\\mathbf{y}}$ denotes the derivative with respect to the outward normal at $\\mathbf{y} \\in \\Gamma$. The exterior limit of the double-layer potential on $\\Gamma$ exhibits the jump relation and is commonly written as $\\left(-\\frac{1}{2}\\mathcal{I} + \\mathcal{K}\\right)[\\rho]$ where $\\mathcal{I}$ denotes the identity operator. In computational electromagnetics for perfectly electrically conducting scatterers, the Electric Field Integral Equation (EFIE), the Magnetic Field Integral Equation (MFIE), and the Combined Field Integral Equation (CFIE) are used to enforce the boundary conditions. In scalar Helmholtz analogs suitable for conditioning analysis, EFIE corresponds to the single-layer equation, MFIE to the second-kind double-layer equation, and CFIE to a linear combination of the two.\n\nLet $\\Gamma$ be the sphere of radius $a$ centered at the origin. Using spherical harmonics, the operators $\\mathcal{S}$ and $\\mathcal{K}$ are diagonalized by the spherical harmonics $Y_{\\ell m}(\\hat{\\mathbf{x}})$ on the sphere, where $\\ell \\in \\mathbb{N}_0$ and $-\\ell \\le m \\le \\ell$. Let $x = ka$ be the dimensionless size parameter. Define the spherical Bessel function of the first kind $j_{\\ell}(x)$ and the spherical Hankel function of the first kind $h_{\\ell}^{(1)}(x) = j_{\\ell}(x) + i y_{\\ell}(x)$, where $y_{\\ell}(x)$ is the spherical Bessel function of the second kind. Denote by $h_{\\ell}^{(1)\\prime}(x)$ the derivative of $h_{\\ell}^{(1)}(x)$ with respect to its argument $x$.\n\nWhen the density is a spherical harmonic $Y_{\\ell m}$, the single-layer operator acts as $$\\mathcal{S}[Y_{\\ell m}] = \\lambda_{\\ell}^{\\mathcal{S}} \\, Y_{\\ell m}, \\quad \\lambda_{\\ell}^{\\mathcal{S}} = \\frac{a x}{i} \\, j_{\\ell}(x) \\, h_{\\ell}^{(1)}(x).$$ The principal value double-layer operator contributes $$\\mathcal{K}[Y_{\\ell m}] = \\lambda_{\\ell}^{\\mathcal{K}} \\, Y_{\\ell m}, \\quad \\lambda_{\\ell}^{\\mathcal{K}} = \\frac{x^2}{i} \\, j_{\\ell}(x) \\, h_{\\ell}^{(1)\\prime}(x),$$ and the MFIE operator has eigenvalues $$\\mu_{\\ell}^{\\text{MFIE}} = -\\frac{1}{2} + \\lambda_{\\ell}^{\\mathcal{K}}.$$ A dimensionless CFIE operator can be formed by $$\\nu_{\\ell}^{\\text{CFIE}} = \\alpha \\, \\mu_{\\ell}^{\\text{MFIE}} + \\eta \\, j_{\\ell}(x) \\, h_{\\ell}^{(1)}(x),$$ where $\\alpha \\in (0,1)$ and $\\eta > 0$ are coupling parameters. For a truncated spherical harmonic expansion up to degree $\\ell_{\\max}$, define the conditioning (condition number) of each operator as $$\\kappa(\\mathcal{O}) = \\frac{\\max_{0 \\le \\ell \\le \\ell_{\\max}} |\\lambda_{\\ell}(\\mathcal{O})|}{\\min_{0 \\le \\ell \\le \\ell_{\\max}} |\\lambda_{\\ell}(\\mathcal{O})|},$$ where $\\lambda_{\\ell}(\\mathcal{O})$ is the eigenvalue of the operator $\\mathcal{O}$ acting on $Y_{\\ell m}$, and the minimum is taken over strictly positive magnitudes to avoid division by zero if any eigenvalue vanishes numerically. This $\\kappa$ provides a proxy for conditioning of the truncated discrete system.\n\nTask. Implement a program that:\n- Computes the eigenvalues $\\lambda_{\\ell}^{\\mathcal{S}}$, $\\mu_{\\ell}^{\\text{MFIE}}$, and $\\nu_{\\ell}^{\\text{CFIE}}$ for $\\ell = 0,1,\\dots,\\ell_{\\max}$ with $\\ell_{\\max} = \\lceil x \\rceil + 8$, for a given sphere radius $a$ and size parameter $x = k a$.\n- Computes the condition numbers $\\kappa(\\mathcal{S})$, $\\kappa(\\text{MFIE})$, and $\\kappa(\\text{CFIE})$ by taking the ratio of the largest to the smallest nonzero absolute eigenvalues among $\\ell = 0,\\dots,\\ell_{\\max}$.\n- Uses the following test suite of parameter sets, which span small $x$, moderate $x$, near-resonant $x$, and large $x$:\n    1. $a = 1$ meter, $x = 0.1$, $\\alpha = 0.5$, $\\eta = 0.7$.\n    2. $a = 1$ meter, $x = 1.0$, $\\alpha = 0.5$, $\\eta = 0.7$.\n    3. $a = 1$ meter, $x = 3.1415926535$, $\\alpha = 0.5$, $\\eta = 0.7$.\n    4. $a = 1$ meter, $x = 6.0$, $\\alpha = 0.5$, $\\eta = 0.7$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The result for each test case must be a list of three floating-point numbers in the order $[\\kappa(\\mathcal{S}), \\kappa(\\text{MFIE}), \\kappa(\\text{CFIE})]$. Therefore, the final output format must be a single line like: [[kS1,kM1,kC1],[kS2,kM2,kC2],[kS3,kM3,kC3],[kS4,kM4,kC4]]. No physical units are required in the output; all condition numbers are dimensionless.", "solution": "The problem requires a numerical analysis of the conditioning of three boundary integral equation formulations (EFIE, MFIE, and CFIE analogs) for the Helmholtz equation on a sphere. The key insight is that on a sphere, the integral operators are diagonalized by spherical harmonics $Y_{\\ell m}$, reducing the analysis of the operator to the analysis of its eigenvalues $\\lambda_{\\ell}$. The condition number, a proxy for numerical stability, is then the ratio of the maximum to the minimum non-zero eigenvalue magnitudes over a truncated range of modes $\\ell$.\n\nThe overall procedure for each test case $(a, x, \\alpha, \\eta)$ is as follows:\n1.  **Determine Truncation Degree**: The calculation is performed for modes $\\ell$ from $0$ up to $\\ell_{\\max} = \\lceil x \\rceil + 8$, where $x=ka$.\n2.  **Evaluate Special Functions**: The eigenvalue formulas involve spherical Bessel functions ($j_{\\ell}(x)$), Hankel functions ($h_{\\ell}^{(1)}(x)$), and their derivatives. These are computed for the given $x$ and for each required degree $\\ell$.\n3.  **Compute Eigenvalues**: For each $\\ell$, the eigenvalues for the single-layer ($\\lambda_{\\ell}^{\\mathcal{S}}$), MFIE ($\\mu_{\\ell}^{\\text{MFIE}}$), and CFIE ($\\nu_{\\ell}^{\\text{CFIE}}$) operators are calculated using the formulas provided in the problem statement. The MFIE eigenvalue $\\mu_{\\ell}^{\\text{MFIE}}$ depends on the double-layer eigenvalue $\\lambda_{\\ell}^{\\mathcal{K}}$. The CFIE eigenvalue $\\nu_{\\ell}^{\\text{CFIE}}$ is a linear combination of the MFIE and a term proportional to the EFIE operator, designed to avoid the vanishing eigenvalues that plague the individual formulations at interior resonant frequencies.\n4.  **Calculate Condition Numbers**: For each of the three sets of eigenvalues, the condition number $\\kappa$ is computed as the ratio of the maximum to the minimum of their absolute values, excluding any zeros.\n\nThis procedure quantitatively demonstrates why the CFIE is robust against the interior resonance problem that leads to severe ill-conditioning in the EFIE and MFIE formulations, a critical concept in computational electromagnetics.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import spherical_jn, spherical_yn\n\ndef solve():\n    \"\"\"\n    Computes and compares the condition numbers of scalar EFIE, MFIE, and CFIE\n    analogs for scattering from a sphere.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (a, x, alpha, eta)\n        (1.0, 0.1, 0.5, 0.7),\n        (1.0, 1.0, 0.5, 0.7),\n        (1.0, 3.1415926535, 0.5, 0.7),\n        (1.0, 6.0, 0.5, 0.7),\n    ]\n\n    results = []\n    for a, x, alpha, eta in test_cases:\n        # Step 1: Determine the truncation degree l_max\n        l_max = int(np.ceil(x)) + 8\n        l_range = np.arange(0, l_max + 1)\n\n        # Step 2: Evaluate special functions j_l(x), y_l(x), and their derivatives\n        # h_l^(1)(x) = j_l(x) + i * y_l(x)\n        # scipy.special functions are vectorized, so they compute for all l in l_range at once.\n        jl_x = spherical_jn(l_range, x)\n        yl_x = spherical_yn(l_range, x)\n        \n        # Derivatives with respect to the argument x\n        jl_x_prime = spherical_jn(l_range, x, derivative=True)\n        yl_x_prime = spherical_yn(l_range, x, derivative=True)\n\n        h1l_x = jl_x + 1j * yl_x\n        h1l_x_prime = jl_x_prime + 1j * yl_x_prime\n\n        # Step 3: Compute eigenvalues for each operator\n        \n        # Eigenvalues for single-layer operator (S)\n        # lambda_l^S = (a*x/i) * j_l(x) * h_l^(1)(x) = -i*a*x*j_l*h_l\n        lambda_S = -1j * a * x * jl_x * h1l_x\n        \n        # Eigenvalues for double-layer operator (K)\n        # lambda_l^K = (x^2/i) * j_l(x) * h_l^(1)'(x) = -i*x^2*j_l*h_l'\n        lambda_K = -1j * x**2 * jl_x * h1l_x_prime\n        \n        # Eigenvalues for MFIE operator\n        # mu_l^MFIE = -1/2 + lambda_l^K\n        mu_MFIE = -0.5 + lambda_K\n        \n        # Eigenvalues for CFIE operator\n        # nu_l^CFIE = alpha * mu_l^MFIE + eta * j_l(x) * h_l^(1)(x)\n        nu_CFIE = alpha * mu_MFIE + eta * jl_x * h1l_x\n\n        # Step 4: Calculate condition numbers\n        \n        def calculate_condition_number(eigenvalues):\n            \"\"\"\n            Computes condition number as max(|lambda|)/min(|lambda| > 0).\n            \"\"\"\n            abs_vals = np.abs(eigenvalues)\n            # Filter out any zero or near-zero magnitudes to avoid division by zero\n            # and adhere to the problem's \"strictly positive magnitudes\" rule.\n            non_zero_abs_vals = abs_vals[abs_vals > 0]\n            \n            if non_zero_abs_vals.size == 0:\n                # This case implies all eigenvalues are zero, condition number is ill-defined.\n                # Could be 1.0 (for a zero operator) or inf.\n                # Assuming it does not occur for the given test cases.\n                return 1.0 \n                \n            max_abs = np.max(non_zero_abs_vals)\n            min_abs = np.min(non_zero_abs_vals)\n            \n            return max_abs / min_abs\n\n        kappa_S = calculate_condition_number(lambda_S)\n        kappa_MFIE = calculate_condition_number(mu_MFIE)\n        kappa_CFIE = calculate_condition_number(nu_CFIE)\n        \n        results.append([kappa_S, kappa_MFIE, kappa_CFIE])\n\n    # Final print statement in the exact required format.\n    # The string representation of a list is '[item1, item2, ...]'\n    # Joining these with commas and enclosing in brackets gives the desired output.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3354579"}]}