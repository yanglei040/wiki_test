{"hands_on_practices": [{"introduction": "Scattering parameters obtained from a numerical solver must conform to fundamental physical laws, such as the conservation of energy. For any passive device, the total power scattered from its ports cannot exceed the power incident upon them. This practice [@problem_id:3346657] guides you through implementing a crucial validation test, based on the discrete Poynting flux, to computationally verify the passivity of a given $S$-matrix and identify non-physical results that can arise from numerical errors or incorrect model setup.", "problem": "Consider a linear time-invariant multiport microwave network modeled by scattering parameters (S-parameters). Let the incident wave amplitude vector be denoted by $\\mathbf{a} \\in \\mathbb{C}^N$ and the scattered (outgoing) wave amplitude vector by $\\mathbf{b} \\in \\mathbb{C}^N$. The scattering relation is $\\mathbf{b} = \\mathbf{S} \\mathbf{a}$, where $\\mathbf{S} \\in \\mathbb{C}^{N \\times N}$ is the scattering matrix extracted numerically from a computational electromagnetics solver. Assume standard power-wave normalization at each port with real, positive reference impedances so that the time-averaged net Poynting flux associated with the port waves satisfies $\\sum_{j=1}^N |b_j|^2 - \\sum_{i=1}^N |a_i|^2 = P_{\\text{out}} - P_{\\text{in}}$, where $P_{\\text{in}}$ and $P_{\\text{out}}$ are the total incoming and outgoing powers across all ports, respectively.\n\nStarting from Maxwell's equations and the Poynting theorem for time-harmonic fields, the net time-averaged outward Poynting flux through a surface enclosing the device equals the input power minus any dissipated power. For a lossless passive network, the dissipated power is zero, and energy conservation implies $P_{\\text{out}} - P_{\\text{in}} = 0$ for any excitation $\\mathbf{a}$. In a discrete computational setting, define a Poynting flux-based test that, for a finite set of excitations $\\{\\mathbf{a}^{(k)}\\}$, computes the quantity\n$$\n\\Delta^{(k)} = \\sum_{j=1}^N \\left| b^{(k)}_j \\right|^2 - \\sum_{i=1}^N \\left| a^{(k)}_i \\right|^2,\n$$\nwhere $\\mathbf{b}^{(k)} = \\mathbf{S} \\mathbf{a}^{(k)}$, and then flags a violation in a numerically extracted $\\mathbf{S}$ for a lossless setup whenever the setup shows an apparent net energy loss, i.e., whenever $\\Delta^{(k)} < -\\tau$ for any $k$, within a user-chosen numerical tolerance $\\tau > 0$. The tolerance accounts for finite-precision roundoff.\n\nYour task is to implement a complete program that performs this discrete test for the following specified test suite. For each test case, compute whether any of the provided excitations yields a negative Poynting flux difference below the tolerance and return a boolean indicating detection of such a violation.\n\nUse the following test suite:\n\n- Case 1 (two-port, ideal lossless swap): $N=2$, \n$$\n\\mathbf{S}_1 = \\begin{bmatrix} 0 & 1 \\\\ 1 & 0 \\end{bmatrix},\n$$\nexcitations \n$$\n\\mathbf{a}^{(1)}_1 = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix},\\quad\n\\mathbf{a}^{(1)}_2 = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix},\\quad\n\\mathbf{a}^{(1)}_3 = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\\\ \\mathrm{j} \\end{bmatrix}.\n$$\n\n- Case 2 (two-port, numerically lossy swap): $N=2$, \n$$\n\\mathbf{S}_2 = \\begin{bmatrix} 0 & 0.99 \\\\ 0.99 & 0 \\end{bmatrix},\n$$\nexcitations \n$$\n\\mathbf{a}^{(2)}_1 = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix},\\quad\n\\mathbf{a}^{(2)}_2 = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix},\\quad\n\\mathbf{a}^{(2)}_3 = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\\\ \\mathrm{j} \\end{bmatrix}.\n$$\n\n- Case 3 (two-port, active diagonal gain): $N=2$, \n$$\n\\mathbf{S}_3 = \\begin{bmatrix} 1.01 & 0 \\\\ 0 & 1.01 \\end{bmatrix},\n$$\nexcitations \n$$\n\\mathbf{a}^{(3)}_1 = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix},\\quad\n\\mathbf{a}^{(3)}_2 = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix},\\quad\n\\mathbf{a}^{(3)}_3 = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\\\ -\\mathrm{j} \\end{bmatrix}.\n$$\n\n- Case 4 (three-port, unitary discrete Fourier transform): $N=3$, \n$$\n\\mathbf{S}_4 = \\frac{1}{\\sqrt{3}} \\begin{bmatrix}\n1 & 1 & 1 \\\\\n1 & e^{\\mathrm{j}\\frac{2\\pi}{3}} & e^{\\mathrm{j}\\frac{4\\pi}{3}} \\\\\n1 & e^{\\mathrm{j}\\frac{4\\pi}{3}} & e^{\\mathrm{j}\\frac{8\\pi}{3}}\n\\end{bmatrix},\n$$\nexcitations \n$$\n\\mathbf{a}^{(4)}_1 = \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\end{bmatrix},\\quad\n\\mathbf{a}^{(4)}_2 = \\begin{bmatrix} 0 \\\\ 1 \\\\ 0 \\end{bmatrix},\\quad\n\\mathbf{a}^{(4)}_3 = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\end{bmatrix},\\quad\n\\mathbf{a}^{(4)}_4 = \\begin{bmatrix} 1 \\\\ e^{\\mathrm{j}\\frac{\\pi}{4}} \\\\ e^{-\\mathrm{j}\\frac{\\pi}{3}} \\end{bmatrix}.\n$$\n\n- Case 5 (two-port, near-lossless within tolerance): $N=2$, \n$$\n\\mathbf{S}_5 = \\begin{bmatrix} 0 & 1 - 10^{-7} \\\\ 1 - 10^{-7} & 0 \\end{bmatrix},\n$$\nexcitations \n$$\n\\mathbf{a}^{(5)}_1 = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix},\\quad\n\\mathbf{a}^{(5)}_2 = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix},\\quad\n\\mathbf{a}^{(5)}_3 = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\\\ \\mathrm{j} \\end{bmatrix}.\n$$\n\nUse a common tolerance $\\tau = 10^{-6}$ for all cases.\n\nImplement an algorithm that, for each case, evaluates $\\Delta^{(k)}$ across all specified excitations and returns the boolean value $\\mathrm{True}$ if any $\\Delta^{(k)} < -\\tau$ and $\\mathrm{False}$ otherwise.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4,r_5]$), where each $r_m$ is the boolean result for case $m$. No physical units and no angle unit conversions are required; complex exponentials are to be handled in radians.", "solution": "We begin from Maxwell's equations in differential form for time-harmonic fields with the convention $e^{\\mathrm{j}\\omega t}$:\n$$\n\\nabla \\times \\mathbf{E} = -\\mathrm{j}\\omega \\mu \\mathbf{H}, \\quad\n\\nabla \\times \\mathbf{H} = \\mathbf{J} + \\mathrm{j}\\omega \\epsilon \\mathbf{E}.\n$$\nThe complex Poynting vector is $\\mathbf{S} = \\frac{1}{2} \\mathbf{E} \\times \\mathbf{H}^*$, and the time-averaged Poynting theorem integrates over a closed surface $\\partial V$ enclosing the device to yield\n$$\n\\int_{\\partial V} \\mathrm{Re}\\{\\mathbf{S}\\} \\cdot \\mathbf{\\hat{n}} \\, \\mathrm{d}A = P_{\\text{out}} = P_{\\text{in}} - P_{\\text{diss}},\n$$\nwhere $P_{\\text{in}}$ is the time-averaged power delivered by sources through the ports and $P_{\\text{diss}}$ is the time-averaged dissipated power inside the volume $V$. For a lossless passive device, $P_{\\text{diss}} = 0$, and energy conservation implies $P_{\\text{out}} = P_{\\text{in}}$.\n\nIn multiport microwave network theory with standard power-wave normalization and real, positive reference impedances, the incident and outgoing port waves are represented by $\\mathbf{a} \\in \\mathbb{C}^N$ and $\\mathbf{b} \\in \\mathbb{C}^N$, respectively. The scattering relation is linear:\n$$\n\\mathbf{b} = \\mathbf{S} \\mathbf{a},\n$$\nwhere $\\mathbf{S} \\in \\mathbb{C}^{N \\times N}$ is the scattering matrix (S-parameters). Under power-wave normalization, the total time-averaged power entering and leaving through the ports are\n$$\nP_{\\text{in}} = \\sum_{i=1}^N |a_i|^2, \\qquad P_{\\text{out}} = \\sum_{j=1}^N |b_j|^2.\n$$\nFor a lossless passive network, the Poynting theorem implies $P_{\\text{out}} - P_{\\text{in}} = 0$ for any excitation $\\mathbf{a}$. This condition can be expressed equivalently by the unitarity of the scattering matrix, $\\mathbf{S}^\\dagger \\mathbf{S} = \\mathbf{I}$, but in a discrete numerical setting we assess conservation directly from the port-wave powers to avoid relying on global matrix properties that may be obscured by numerical error.\n\nDefine the discrete Poynting flux difference for a specific excitation $\\mathbf{a}^{(k)}$ as\n$$\n\\Delta^{(k)} = \\sum_{j=1}^N \\left| b^{(k)}_j \\right|^2 - \\sum_{i=1}^N \\left| a^{(k)}_i \\right|^2,\n$$\nwhere $\\mathbf{b}^{(k)} = \\mathbf{S} \\mathbf{a}^{(k)}$. In exact arithmetic for a lossless device, $\\Delta^{(k)} = 0$ for all $k$. In finite-precision computations, we introduce a tolerance $\\tau > 0$ and declare a violation of the lossless setup if $\\Delta^{(k)} < -\\tau$ for any $k$. The negative sign specifically identifies apparent net absorption beyond the tolerance, which is incompatible with the assumed losslessness. Positive values indicate apparent net generation (active behavior), which also violates losslessness; however, the requested test flags the negative side to detect apparent dissipation inconsistencies in the extracted $\\mathbf{S}$.\n\nAlgorithmically, for each test case:\n1. Initialize the tolerance $\\tau = 10^{-6}$.\n2. For each specified excitation vector $\\mathbf{a}^{(k)}$, compute $\\mathbf{b}^{(k)} = \\mathbf{S} \\mathbf{a}^{(k)}$.\n3. Compute $\\Delta^{(k)} = \\sum_{j=1}^N |b^{(k)}_j|^2 - \\sum_{i=1}^N |a^{(k)}_i|^2$.\n4. If any $\\Delta^{(k)} < -\\tau$, flag the case as a violation (return $\\mathrm{True}$); otherwise, return $\\mathrm{False}$.\n\nWe now reason through expectations for the provided test suite:\n\n- Case 1: $\\mathbf{S}_1$ swaps the ports with unit magnitude, and the excitations have unit total power. For each excitation, $P_{\\text{out}} = P_{\\text{in}}$, so $\\Delta^{(k)} = 0$ and no violation is flagged. The result is $\\mathrm{False}$.\n\n- Case 2: $\\mathbf{S}_2$ swaps ports with magnitude $0.99$, so $P_{\\text{out}} = 0.99^2 P_{\\text{in}} = 0.9801 P_{\\text{in}}$. For unit-power excitations, $\\Delta^{(k)} = 0.9801 - 1 = -0.0199 < -\\tau$, which flags a violation. The result is $\\mathrm{True}$.\n\n- Case 3: $\\mathbf{S}_3$ applies a gain of $1.01$ on each port, so $P_{\\text{out}} = 1.01^2 P_{\\text{in}} = 1.0201 P_{\\text{in}}$, giving $\\Delta^{(k)} = 0.0201 > 0$. This does not meet the condition $\\Delta^{(k)} < -\\tau$, so the test does not flag a negative violation. The result is $\\mathrm{False}$.\n\n- Case 4: $\\mathbf{S}_4$ is the $3 \\times 3$ discrete Fourier transform matrix normalized by $1/\\sqrt{3}$, which is unitary. Hence, $P_{\\text{out}} = P_{\\text{in}}$ for any excitation, yielding $\\Delta^{(k)} = 0$ within numerical precision and no negative violation. The result is $\\mathrm{False}$.\n\n- Case 5: $\\mathbf{S}_5$ is nearly lossless with magnitude $1 - 10^{-7}$; thus $P_{\\text{out}} = (1 - 10^{-7})^2 P_{\\text{in}} = (1 - 2 \\cdot 10^{-7} + 10^{-14}) P_{\\text{in}}$. For unit-power excitations, $\\Delta^{(k)} \\approx -2 \\cdot 10^{-7}$, which is greater than $-\\tau = -10^{-6}$, so no violation is flagged under the specified tolerance. The result is $\\mathrm{False}$.\n\nThe program implements these computations exactly and outputs a single line with the list of booleans $[r_1,r_2,r_3,r_4,r_5]$ corresponding to the five cases.", "answer": "```python\nimport numpy as np\n\ndef poynting_flux_difference(S: np.ndarray, a: np.ndarray) -> float:\n    \"\"\"\n    Compute Delta = sum |b_j|^2 - sum |a_i|^2 for b = S a.\n    \"\"\"\n    b = S @ a\n    return float(np.sum(np.abs(b) ** 2) - np.sum(np.abs(a) ** 2))\n\ndef check_negative_violation(S: np.ndarray, excitations: list, tol: float) -> bool:\n    \"\"\"\n    Return True if any excitation produces Delta < -tol.\n    \"\"\"\n    for a in excitations:\n        delta = poynting_flux_difference(S, a)\n        if delta < -tol:\n            return True\n    return False\n\ndef solve():\n    tau = 1e-6  # tolerance\n\n    # Case 1: two-port, ideal lossless swap\n    S1 = np.array([[0.0, 1.0],\n                   [1.0, 0.0]], dtype=complex)\n    a1_1 = np.array([1.0+0.0j, 0.0+0.0j])\n    a1_2 = np.array([0.0+0.0j, 1.0+0.0j])\n    a1_3 = (1/np.sqrt(2)) * np.array([1.0+0.0j, 1.0j])\n    excitations1 = [a1_1, a1_2, a1_3]\n\n    # Case 2: two-port, numerically lossy swap\n    S2 = np.array([[0.0, 0.99],\n                   [0.99, 0.0]], dtype=complex)\n    a2_1 = np.array([1.0+0.0j, 0.0+0.0j])\n    a2_2 = np.array([0.0+0.0j, 1.0+0.0j])\n    a2_3 = (1/np.sqrt(2)) * np.array([1.0+0.0j, 1.0j])\n    excitations2 = [a2_1, a2_2, a2_3]\n\n    # Case 3: two-port, active diagonal gain\n    S3 = np.array([[1.01, 0.0],\n                   [0.0, 1.01]], dtype=complex)\n    a3_1 = np.array([1.0+0.0j, 0.0+0.0j])\n    a3_2 = np.array([0.0+0.0j, 1.0+0.0j])\n    a3_3 = (1/np.sqrt(2)) * np.array([1.0+0.0j, -1.0j])\n    excitations3 = [a3_1, a3_2, a3_3]\n\n    # Case 4: three-port, unitary DFT\n    # Construct the 3x3 DFT matrix normalized by 1/sqrt(3)\n    N = 3\n    F = np.zeros((N, N), dtype=complex)\n    for m in range(N):\n        for n in range(N):\n            F[m, n] = np.exp(1j * 2 * np.pi * m * n / N)\n    S4 = (1/np.sqrt(3)) * F\n    a4_1 = np.array([1.0+0.0j, 0.0+0.0j, 0.0+0.0j])\n    a4_2 = np.array([0.0+0.0j, 1.0+0.0j, 0.0+0.0j])\n    a4_3 = np.array([0.0+0.0j, 0.0+0.0j, 1.0+0.0j])\n    a4_4 = np.array([1.0+0.0j, np.exp(1j*np.pi/4), np.exp(-1j*np.pi/3)])\n    excitations4 = [a4_1, a4_2, a4_3, a4_4]\n\n    # Case 5: two-port, near-lossless within tolerance\n    S5 = np.array([[0.0, 1.0 - 1e-7],\n                   [1.0 - 1e-7, 0.0]], dtype=complex)\n    a5_1 = np.array([1.0+0.0j, 0.0+0.0j])\n    a5_2 = np.array([0.0+0.0j, 1.0+0.0j])\n    a5_3 = (1/np.sqrt(2)) * np.array([1.0+0.0j, 1.0j])\n    excitations5 = [a5_1, a5_2, a5_3]\n\n    test_cases = [\n        (S1, excitations1),\n        (S2, excitations2),\n        (S3, excitations3),\n        (S4, excitations4),\n        (S5, excitations5),\n    ]\n\n    results = []\n    for S, excitations in test_cases:\n        violation = check_negative_violation(S, excitations, tau)\n        results.append(violation)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3346657"}, {"introduction": "In practical simulations and measurements, the device-under-test (DUT) is often embedded within feed structures or launchers, whose responses obscure the DUT's intrinsic behavior. While $S$-parameters elegantly describe input-output relations, they are not suited for cascading networks; for this, the transmission (or chain) matrix, $T$, is the natural choice. This exercise [@problem_id:3346692] provides hands-on practice in the essential technique of de-embedding, where you will convert between $S$- and $T$-matrices to algebraically remove the effects of surrounding networks and isolate the true performance of the DUT.", "problem": "A two-port measurement structure in a full-wave numerical solver is composed of an identical feed launcher on each side and a reciprocal device-under-test (DUT) at a single frequency. All ports are referenced to a real characteristic impedance $Z_{0} = 50\\,\\Omega$. The solver returns the scattering matrix $S$ of the entire three-block cascade (left feed, DUT, right feed). You are tasked with de-embedding the feeds to recover the DUT scattering matrix by constructing transmission (chain) matrices and algebraically removing the feed contributions.\n\nBase the derivation on first principles: define the complex power-wave variables $a_{n}$ and $b_{n}$ at port $n$, state the scattering matrix relation $b = S\\,a$, and define the transmission (chain) matrix in terms of port voltages and currents (the $A$–$B$–$C$–$D$ matrix). Derive the $A$–$B$–$C$–$D$ matrix from $S$ using only these definitions and linear algebra. Use the fact that identical feeds are present on both sides to perform the de-embedding by appropriate matrix inversion and cascading.\n\nAt the operating frequency, the individual feed launcher has scattering parameters\n$$\nS_{11}^{(\\mathrm{feed})} = \\frac{1}{10},\\quad S_{22}^{(\\mathrm{feed})} = \\frac{1}{10},\\quad S_{21}^{(\\mathrm{feed})} = \\frac{19}{20},\\quad S_{12}^{(\\mathrm{feed})} = \\frac{19}{20},\n$$\nand the simulated three-block cascade (feed–DUT–feed) has scattering parameters\n$$\nS_{11}^{(\\mathrm{tot})} = S_{22}^{(\\mathrm{tot})} = \\frac{491}{3105},\\quad S_{21}^{(\\mathrm{tot})} = S_{12}^{(\\mathrm{tot})} = \\frac{1805}{2484}.\n$$\n\nConstruct the transmission matrices $T^{(\\mathrm{feed})}$ and $T^{(\\mathrm{tot})}$ in the voltage–current chain form $(A,B;C,D)$ using $Z_{0}$, then recover the DUT transmission matrix by algebraically removing the feeds on both sides. Convert the resulting DUT transmission matrix back to $S^{(\\mathrm{DUT})}$ using your derived relations.\n\nWhat is the value of the DUT forward transmission coefficient $S_{21}^{(\\mathrm{DUT})}$ at this frequency? Express your final answer as a real number and round to four significant figures.", "solution": "We begin with the power-wave definitions at a port of real reference impedance $Z_{0}$: for port $n$, the incident and reflected waves $a_{n}$ and $b_{n}$ are related to port voltage $V_{n}$ and current $I_{n}$ by\n$$\na_{n} = \\frac{V_{n} + Z_{0} I_{n}}{2\\sqrt{Z_{0}}},\\qquad b_{n} = \\frac{V_{n} - Z_{0} I_{n}}{2\\sqrt{Z_{0}}}.\n$$\nThe two-port scattering relation is\n$$\n\\begin{pmatrix} b_{1} \\\\ b_{2} \\end{pmatrix}\n=\n\\begin{pmatrix}\nS_{11} & S_{12} \\\\\nS_{21} & S_{22}\n\\end{pmatrix}\n\\begin{pmatrix} a_{1} \\\\ a_{2} \\end{pmatrix}.\n$$\nFor cascading, the convenient representation is the voltage–current transmission (chain) matrix, commonly denoted $(A,B;C,D)$ (the $A$–$B$–$C$–$D$ matrix), defined by\n$$\n\\begin{pmatrix} V_{1} \\\\ I_{1} \\end{pmatrix}\n=\n\\begin{pmatrix}\nA & B \\\\\nC & D\n\\end{pmatrix}\n\\begin{pmatrix} V_{2} \\\\ I_{2} \\end{pmatrix}.\n$$\nOur fundamental base is linear network theory under the $Z_{0}$-normalized power-wave framework, which ensures that both $S$ and $(A,B;C,D)$ are linearly related via the underlying $(V,I)$ variables.\n\nTo derive $(A,B;C,D)$ from $S$, we express $(V,I)$ in terms of $(a,b)$ using the definitions:\n$$\nV_{n} = \\sqrt{Z_{0}}(a_{n} + b_{n}),\\qquad I_{n} = \\frac{1}{\\sqrt{Z_{0}}}(a_{n} - b_{n}),\n$$\nand combine with $b = S\\,a$. Eliminating $a_{2}$ and $b_{2}$ in favor of $(V_{2}, I_{2})$ and similarly writing $(V_{1}, I_{1})$ in terms of $(a_{1}, b_{1})$ yields, after algebraic manipulation,\n$$\nA = \\frac{(1+S_{11})(1-S_{22}) + S_{12} S_{21}}{2 S_{21}},\\quad\nB = Z_{0}\\,\\frac{(1+S_{11})(1+S_{22}) - S_{12} S_{21}}{2 S_{21}},\n$$\n$$\nC = \\frac{1}{Z_{0}}\\,\\frac{(1-S_{11})(1-S_{22}) - S_{12} S_{21}}{2 S_{21}},\\quad\nD = \\frac{(1-S_{11})(1+S_{22}) + S_{12} S_{21}}{2 S_{21}}.\n$$\nThese relations follow directly from the linear transformations between $(a,b)$ and $(V,I)$ and the definition of the chain matrix.\n\nConversely, converting from $(A,B;C,D)$ back to $S$ under real $Z_{0}$ is obtained by solving the port-matching problem with $(V,I)$ waves:\n$$\n\\Delta \\equiv A + \\frac{B}{Z_{0}} + C Z_{0} + D,\n$$\n$$\nS_{21} = \\frac{2}{\\Delta},\\quad\nS_{11} = \\frac{A + \\frac{B}{Z_{0}} - C Z_{0} - D}{\\Delta},\\quad\nS_{22} = \\frac{-A + \\frac{B}{Z_{0}} - C Z_{0} + D}{\\Delta},\\quad\nS_{12} = \\frac{2(AD - BC)}{\\Delta}.\n$$\n\nWe now compute the feed launcher $(A,B;C,D)^{(\\mathrm{feed})}$ from its given $S^{(\\mathrm{feed})}$ at $Z_{0} = 50$:\n$$\nS_{11}^{(\\mathrm{feed})} = \\frac{1}{10},\\quad S_{22}^{(\\mathrm{feed})} = \\frac{1}{10},\\quad S_{21}^{(\\mathrm{feed})} = S_{12}^{(\\mathrm{feed})} = \\frac{19}{20}.\n$$\nCompute the products needed:\n$$\n(1+S_{11})(1-S_{22}) = \\left(1 + \\frac{1}{10}\\right)\\left(1 - \\frac{1}{10}\\right) = \\frac{11}{10}\\cdot\\frac{9}{10} = \\frac{99}{100},\n$$\n$$\nS_{12} S_{21} = \\left(\\frac{19}{20}\\right)^{2} = \\frac{361}{400}.\n$$\nThus\n$$\nA^{(\\mathrm{feed})} = \\frac{\\frac{99}{100} + \\frac{361}{400}}{2\\cdot \\frac{19}{20}}\n= \\frac{\\frac{396}{400} + \\frac{361}{400}}{\\frac{38}{20}}\n= \\frac{\\frac{757}{400}}{\\frac{38}{20}}\n= \\frac{757}{400}\\cdot\\frac{20}{38}\n= \\frac{757}{760},\n$$\n$$\n(1+S_{11})(1+S_{22}) = \\frac{11}{10}\\cdot\\frac{11}{10} = \\frac{121}{100},\\quad\n(1-S_{11})(1-S_{22}) = \\frac{9}{10}\\cdot\\frac{9}{10} = \\frac{81}{100}.\n$$\nHence\n$$\nB^{(\\mathrm{feed})} = 50\\cdot\\frac{\\frac{121}{100} - \\frac{361}{400}}{2\\cdot \\frac{19}{20}}\n= 50\\cdot\\frac{\\frac{484}{400} - \\frac{361}{400}}{\\frac{38}{20}}\n= 50\\cdot\\frac{\\frac{123}{400}}{\\frac{38}{20}}\n= 50\\cdot\\frac{123}{400}\\cdot\\frac{20}{38}\n= \\frac{615}{76},\n$$\n$$\nC^{(\\mathrm{feed})} = \\frac{1}{50}\\cdot\\frac{\\frac{81}{100} - \\frac{361}{400}}{2\\cdot \\frac{19}{20}}\n= \\frac{1}{50}\\cdot\\frac{\\frac{324}{400} - \\frac{361}{400}}{\\frac{38}{20}}\n= \\frac{1}{50}\\cdot\\frac{-\\frac{37}{400}}{\\frac{38}{20}}\n= \\frac{1}{50}\\cdot\\left(-\\frac{37}{400}\\cdot\\frac{20}{38}\\right)\n= -\\frac{37}{38000},\n$$\n$$\nD^{(\\mathrm{feed})} = \\frac{\\left(1-\\frac{1}{10}\\right)\\left(1+\\frac{1}{10}\\right) + \\frac{361}{400}}{2\\cdot \\frac{19}{20}} = \\frac{757}{760}.\n$$\nTherefore,\n$$\nT^{(\\mathrm{feed})} \\equiv\n\\begin{pmatrix}\nA^{(\\mathrm{feed})} & B^{(\\mathrm{feed})} \\\\\nC^{(\\mathrm{feed})} & D^{(\\mathrm{feed})}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\frac{757}{760} & \\frac{615}{76} \\\\\n-\\frac{37}{38000} & \\frac{757}{760}\n\\end{pmatrix}.\n$$\n\nNext, compute the chain matrix of the total cascade $T^{(\\mathrm{tot})}$ from $S^{(\\mathrm{tot})}$ using the same formulas. The given values are\n$$\nS_{11}^{(\\mathrm{tot})} = S_{22}^{(\\mathrm{tot})} = \\frac{491}{3105},\\qquad\nS_{21}^{(\\mathrm{tot})} = S_{12}^{(\\mathrm{tot})} = \\frac{1805}{2484}.\n$$\nWe form\n$$\nA^{(\\mathrm{tot})} = \\frac{\\left(1 + \\frac{491}{3105}\\right)\\left(1 - \\frac{491}{3105}\\right) + \\left(\\frac{1805}{2484}\\right)^{2}}{2\\cdot \\frac{1805}{2484}},\n$$\n$$\nB^{(\\mathrm{tot})} = 50\\,\\frac{\\left(1 + \\frac{491}{3105}\\right)\\left(1 + \\frac{491}{3105}\\right) - \\left(\\frac{1805}{2484}\\right)^{2}}{2\\cdot \\frac{1805}{2484}},\n$$\n$$\nC^{(\\mathrm{tot})} = \\frac{1}{50}\\,\\frac{\\left(1 - \\frac{491}{3105}\\right)\\left(1 - \\frac{491}{3105}\\right) - \\left(\\frac{1805}{2484}\\right)^{2}}{2\\cdot \\frac{1805}{2484}},\n$$\n$$\nD^{(\\mathrm{tot})} = \\frac{\\left(1 - \\frac{491}{3105}\\right)\\left(1 + \\frac{491}{3105}\\right) + \\left(\\frac{1805}{2484}\\right)^{2}}{2\\cdot \\frac{1805}{2484}}.\n$$\nCarrying out the arithmetic (keeping exact rational forms to avoid numerical error) yields\n$$\nT^{(\\mathrm{tot})}\n=\n\\begin{pmatrix}\n\\displaystyle \\frac{7466980}{7220000} & \\displaystyle \\frac{4040220}{144400} \\\\\n\\displaystyle \\frac{897820}{361000000} & \\displaystyle \\frac{7466980}{7220000}\n\\end{pmatrix}.\n$$\nWe now de-embed the identical feeds from the total transmission matrix. For a left–DUT–right cascade with identical feeds, the chain matrices satisfy\n$$\nT^{(\\mathrm{tot})} = T^{(\\mathrm{feed})}\\,T^{(\\mathrm{DUT})}\\,T^{(\\mathrm{feed})}.\n$$\nSolving for the DUT matrix,\n$$\nT^{(\\mathrm{DUT})} = \\left(T^{(\\mathrm{feed})}\\right)^{-1}\\,T^{(\\mathrm{tot})}\\,\\left(T^{(\\mathrm{feed})}\\right)^{-1}.\n$$\nCompute $\\left(T^{(\\mathrm{feed})}\\right)^{-1}$. For a $2\\times 2$ matrix,\n$$\n\\left(T^{(\\mathrm{feed})}\\right)^{-1}\n=\n\\frac{1}{A^{(\\mathrm{feed})}D^{(\\mathrm{feed})} - B^{(\\mathrm{feed})}C^{(\\mathrm{feed})}}\n\\begin{pmatrix}\nD^{(\\mathrm{feed})} & -B^{(\\mathrm{feed})} \\\\\n- C^{(\\mathrm{feed})} & A^{(\\mathrm{feed})}\n\\end{pmatrix}.\n$$\nReciprocal passive two-ports satisfy $A D - B C = 1$, which holds here (indeed\n$$\nA^{(\\mathrm{feed})}D^{(\\mathrm{feed})} - B^{(\\mathrm{feed})}C^{(\\mathrm{feed})}\n= \\left(\\frac{757}{760}\\right)^{2} - \\left(\\frac{615}{76}\\right)\\left(-\\frac{37}{38000}\\right)\n= 1\n$$\nexactly). Therefore,\n$$\n\\left(T^{(\\mathrm{feed})}\\right)^{-1}\n=\n\\begin{pmatrix}\n\\frac{757}{760} & -\\frac{615}{76} \\\\\n\\frac{37}{38000} & \\frac{757}{760}\n\\end{pmatrix}.\n$$\nPerforming the matrix products\n$$\nT^{(\\mathrm{DUT})} = \\begin{pmatrix}\n\\frac{757}{760} & -\\frac{615}{76} \\\\\n\\frac{37}{38000} & \\frac{757}{760}\n\\end{pmatrix}\n\\begin{pmatrix}\n\\frac{7466980}{7220000} & \\frac{4040220}{144400} \\\\\n\\frac{897820}{361000000} & \\frac{7466980}{7220000}\n\\end{pmatrix}\n\\begin{pmatrix}\n\\frac{757}{760} & -\\frac{615}{76} \\\\\n\\frac{37}{38000} & \\frac{757}{760}\n\\end{pmatrix}\n$$\nyields, after exact rational simplification,\n$$\nT^{(\\mathrm{DUT})} =\n\\begin{pmatrix}\n\\frac{41}{40} & \\frac{45}{4} \\\\\n\\frac{9}{2000} & \\frac{41}{40}\n\\end{pmatrix}.\n$$\nThis chain matrix corresponds to a matched reciprocal attenuator. Converting $T^{(\\mathrm{DUT})}$ back to $S^{(\\mathrm{DUT})}$,\n$$\n\\Delta_{\\mathrm{DUT}} = A^{(\\mathrm{DUT})} + \\frac{B^{(\\mathrm{DUT})}}{Z_{0}} + C^{(\\mathrm{DUT})} Z_{0} + D^{(\\mathrm{DUT})}\n= \\frac{41}{40} + \\frac{\\frac{45}{4}}{50} + \\left(\\frac{9}{2000}\\right) 50 + \\frac{41}{40}\n= \\frac{41}{40} + \\frac{9}{40} + \\frac{9}{40} + \\frac{41}{40}\n= \\frac{100}{40}\n= \\frac{5}{2}.\n$$\nTherefore,\n$$\nS_{21}^{(\\mathrm{DUT})} = \\frac{2}{\\Delta_{\\mathrm{DUT}}} = \\frac{2}{5/2} = \\frac{4}{5} = 0.8,\n$$\nand, consistently,\n$$\nS_{11}^{(\\mathrm{DUT})} = \\frac{A + \\frac{B}{Z_{0}} - C Z_{0} - D}{\\Delta} = 0,\\qquad\nS_{22}^{(\\mathrm{DUT})} = 0,\\qquad\nS_{12}^{(\\mathrm{DUT})} = \\frac{2(AD - BC)}{\\Delta} = \\frac{2\\cdot 1}{5/2} = \\frac{4}{5} = 0.8,\n$$\nconfirming reciprocal matched attenuation.\n\nThus, the de-embedded device-under-test forward transmission is\n$$\nS_{21}^{(\\mathrm{DUT})} = 0.8.\n$$\nRounded to four significant figures, the requested value is $0.8000$.", "answer": "$$\\boxed{0.8000}$$", "id": "3346692"}, {"introduction": "Scattering parameters from frequency-domain solvers provide a discrete, band-limited view of a component's behavior, which is insufficient for transient or system-level time-domain simulations. To create a predictive broadband model, we can approximate the $S$-parameter data with a rational function, a process known as macromodeling. This practice [@problem_id:3346664] explores how to construct a stable and passive rational model that enforces physical constraints like reciprocity, by formulating the approximation as a constrained, weighted least-squares fitting problem.", "problem": "You are given discrete frequency-domain scattering parameter data for a two-port, linear time-invariant (LTI) network. Your task is to construct and implement a constrained rational fitting procedure for the scattering matrix that enforces reciprocity and geometric symmetry while minimizing a frequency-weighted error. The fitting must be performed for a rational model with fixed stable poles shared across matrix entries. The solution must be a complete, runnable program that computes the requested metrics for a specified test suite and prints the final results in the exact format described at the end of this prompt.\n\nThe scattering matrix is a complex-valued function of complex frequency and is denoted by $S(s) \\in \\mathbb{C}^{2\\times 2}$ where $s=\\mathrm{j}2\\pi f$, with $f$ in Hertz. For a reciprocal and geometrically symmetric two-port, reciprocity and symmetry imply $S_{12}(s)=S_{21}(s)$ and $S_{11}(s)=S_{22}(s)$ for all complex frequencies $s$ of interest. You will approximate the true data by a rational model with preassigned poles that also enforces these constraints:\n$$\n\\hat S(s)=\n\\begin{bmatrix}\n\\displaystyle \\sum_{k=1}^{K}\\frac{r^{(\\mathrm{d})}_k}{s-a_k}+d^{(\\mathrm{d})} & \\displaystyle \\sum_{k=1}^{K}\\frac{r^{(\\mathrm{o})}_k}{s-a_k}+d^{(\\mathrm{o})} \\\\\n\\displaystyle \\sum_{k=1}^{K}\\frac{r^{(\\mathrm{o})}_k}{s-a_k}+d^{(\\mathrm{o})} & \\displaystyle \\sum_{k=1}^{K}\\frac{r^{(\\mathrm{d})}_k}{s-a_k}+d^{(\\mathrm{d})}\n\\end{bmatrix},\n$$\nwhere $a_k\\in\\mathbb{C}$ are fixed, stable poles with $\\operatorname{Re}\\{a_k\\}<0$ for all $k\\in\\{1,\\dots,K\\}$, $r^{(\\mathrm{d})}_k\\in\\mathbb{C}$ and $r^{(\\mathrm{o})}_k\\in\\mathbb{C}$ are the diagonal and off-diagonal residues, respectively, and $d^{(\\mathrm{d})},d^{(\\mathrm{o})}\\in\\mathbb{C}$ are constant terms. This model enforces $\\hat S_{12}(s)=\\hat S_{21}(s)$ and $\\hat S_{11}(s)=\\hat S_{22}(s)$ by construction.\n\nYou will be given a discrete frequency grid $\\{f_i\\}_{i=1}^N$ and corresponding complex matrices $S(f_i)$, with $s_i=\\mathrm{j}2\\pi f_i$. Let $W_i\\ge 0$ denote nonnegative real frequency weights. Define the frequency-weighted error objective over the grid as the weighted Frobenius norm\n$$\nJ=\\sum_{i=1}^{N} W_i \\left\\| \\hat S(s_i)-S(s_i) \\right\\|_{F}^{2}.\n$$\nYour task is to compute the least squares solution that minimizes $J$ over the unknowns $\\{r^{(\\mathrm{d})}_k\\}_{k=1}^{K},\\{r^{(\\mathrm{o})}_k\\}_{k=1}^{K},d^{(\\mathrm{d})},d^{(\\mathrm{o})}$ using the fixed poles $\\{a_k\\}_{k=1}^{K}$ and to report a normalized weighted root-mean-square (RMS) error\n$$\n\\varepsilon_{\\mathrm{wRMS}}=\\sqrt{\\frac{\\sum_{i=1}^{N} W_i \\left\\|\\hat S(s_i)-S(s_i)\\right\\|_{F}^{2}}{\\sum_{i=1}^{N} W_i}}.\n$$\nFor all computations, use $f$ in Hertz and $s=\\mathrm{j}2\\pi f$. The final error values are dimensionless.\n\nYou must implement the fitting as a complex-valued, frequency-weighted linear least squares problem. The reciprocity and symmetry constraints must be enforced by parameter sharing as shown in the rational model above. Do not regularize or modify the poles. Ensure numerical stability by using the provided stable real poles.\n\nUse the following data that defines a test suite spanning multiple cases. All symbols and numbers below are to be used exactly as stated.\n\nFundamental setup and common definitions:\n1. Number of poles: $K=3$.\n2. Fixed poles (in radians per second):\n$$\na_1=-2\\pi\\cdot 0.5\\times 10^{9},\\quad\na_2=-2\\pi\\cdot 2.0\\times 10^{9},\\quad\na_3=-2\\pi\\cdot 8.0\\times 10^{9}.\n$$\n3. Frequency grid $\\{f_i\\}_{i=1}^{N}$, with $N=9$, in Hertz:\n$$\n\\left[f_1,\\dots,f_9\\right]=\\left[0.5, 1.0, 2.0, 3.5, 5.0, 7.5, 10.0, 15.0, 20.0\\right]\\times 10^{9}.\n$$\n4. For any complex frequency $s_i=\\mathrm{j}2\\pi f_i$, define the basis functions\n$$\n\\phi_k(s_i)=\\frac{1}{s_i-a_k},\\quad k\\in\\{1,2,3\\}.\n$$\n\nTest case definitions:\n- Test case $1$ (ideal symmetric reciprocal data):\n  Use the rational model with the following exact real coefficients:\n  $$\n  \\left[r^{(\\mathrm{d})}_1,r^{(\\mathrm{d})}_2,r^{(\\mathrm{d})}_3\\right]=\\left[0.08, -0.03, 0.015\\right],\n  $$\n  $$\n  \\left[r^{(\\mathrm{o})}_1,r^{(\\mathrm{o})}_2,r^{(\\mathrm{o})}_3\\right]=\\left[0.20, 0.09, -0.05\\right],\n  $$\n  $$\n  d^{(\\mathrm{d})}=0.01,\\quad d^{(\\mathrm{o})}=-0.005.\n  $$\n  For each $i\\in\\{1,\\dots,9\\}$, define $S_{11}(f_i)=S_{22}(f_i)=\\sum_{k=1}^{3} r^{(\\mathrm{d})}_k \\phi_k(s_i)+d^{(\\mathrm{d})}$ and $S_{12}(f_i)=S_{21}(f_i)=\\sum_{k=1}^{3} r^{(\\mathrm{o})}_k \\phi_k(s_i)+d^{(\\mathrm{o})}$. Frequency weights are\n  $$\n  W_i=\\frac{1}{1+\\left(\\frac{f_i}{10^{10}}\\right)^{2}},\\quad i\\in\\{1,\\dots,9\\}.\n  $$\n\n- Test case $2$ (asymmetric perturbation of the off-diagonal entries):\n  Start from the same $S(f_i)$ from Test case $1$ and add an antisymmetric real perturbation to the off-diagonal entries:\n  $$\n  \\delta=0.02,\\quad f_{\\mathrm{d}}=5.0\\times 10^{9},\n  $$\n  $$\n  \\tau_i=\\exp\\left(-\\frac{f_i}{f_{\\mathrm{d}}}\\right),\n  $$\n  $$\n  S_{12}(f_i)\\leftarrow S_{12}(f_i)+\\delta\\,\\tau_i,\\quad S_{21}(f_i)\\leftarrow S_{21}(f_i)-\\delta\\,\\tau_i,\n  $$\n  while leaving $S_{11}(f_i)$ and $S_{22}(f_i)$ unchanged. Use the same weights $W_i$ as in Test case $1$.\n\n- Test case $3$ (outlier at one frequency with zero weight):\n  Start from the same $S(f_i)$ from Test case $1$, then add a large real outlier to all four entries at the single frequency index corresponding to $f=15.0\\times 10^{9}$ Hertz:\n  $$\n  \\Delta=0.5,\\quad S_{pq}(15.0\\times 10^{9})\\leftarrow S_{pq}(15.0\\times 10^{9})+\\Delta\\quad \\text{for all }p,q\\in\\{1,2\\}.\n  $$\n  Use the same weights $W_i$ as in Test case $1$, except set the weight at $f=15.0\\times 10^{9}$ Hertz to zero:\n  $$\n  W_i\\leftarrow 0\\quad \\text{if }f_i=15.0\\times 10^{9}.\n  $$\n\nYour program must, for each of the three test cases, perform the following steps:\n1. Build the complex-valued weighted linear system that enforces the rational model and the reciprocity plus symmetry constraints, with unknowns $\\{r^{(\\mathrm{d})}_k\\}_{k=1}^{3},\\{r^{(\\mathrm{o})}_k\\}_{k=1}^{3},d^{(\\mathrm{d})},d^{(\\mathrm{o})}$.\n2. Solve the frequency-weighted complex least squares problem that minimizes $J$.\n3. Reconstruct $\\hat S(s_i)$ on the grid and compute the normalized weighted RMS error $\\varepsilon_{\\mathrm{wRMS}}$ as defined above.\n\nAngle usage is implicit in complex arithmetic and does not require unit specification. All frequencies $f$ must be treated in Hertz, and all poles $a_k$ must be treated in radians per second. The final numerical answers are dimensionless.\n\nFinal output format requirement:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with three floating-point numbers in the order of Test cases $1,2,3$, for example, $[x_1,x_2,x_3]$, with no spaces.", "solution": "The problem is to determine the optimal coefficients of a constrained rational model for a two-port scattering matrix, $S(s)$, such that a frequency-weighted error metric is minimized. The model must enforce reciprocity, $\\hat S_{12}(s) = \\hat S_{21}(s)$, and geometric symmetry, $\\hat S_{11}(s) = \\hat S_{22}(s)$. This is achieved by using a shared set of coefficients for the respective diagonal and off-diagonal elements. The problem is a linear-least squares fitting problem, as the model is linear in the unknown coefficients (residues and constant terms) and the poles are fixed.\n\nThe rational model for the scattering matrix, $\\hat S(s)$, is given by:\n$$\n\\hat S(s)=\n\\begin{bmatrix}\n\\hat S_{11}(s) & \\hat S_{12}(s) \\\\\n\\hat S_{21}(s) & \\hat S_{22}(s)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\displaystyle \\sum_{k=1}^{K}\\frac{r^{(\\mathrm{d})}_k}{s-a_k}+d^{(\\mathrm{d})} & \\displaystyle \\sum_{k=1}^{K}\\frac{r^{(\\mathrm{o})}_k}{s-a_k}+d^{(\\mathrm{o})} \\\\\n\\displaystyle \\sum_{k=1}^{K}\\frac{r^{(\\mathrm{o})}_k}{s-a_k}+d^{(\\mathrm{o})} & \\displaystyle \\sum_{k=1}^{K}\\frac{r^{(\\mathrm{d})}_k}{s-a_k}+d^{(\\mathrm{d})}\n\\end{bmatrix}\n$$\nThe unknown coefficients are the complex-valued residues $\\{r^{(\\mathrm{d})}_k\\}_{k=1}^{K}, \\{r^{(\\mathrm{o})}_k\\}_{k=1}^{K}$ and the complex-valued constant terms $d^{(\\mathrm{d})}, d^{(\\mathrm{o})}$. The poles $\\{a_k\\}_{k=1}^{K}$ are fixed.\n\nThe objective is to minimize the frequency-weighted error $J$ over a discrete set of $N$ frequencies $\\{f_i\\}_{i=1}^N$ (with $s_i = \\mathrm{j}2\\pi f_i$):\n$$\nJ=\\sum_{i=1}^{N} W_i \\left\\| \\hat S(s_i)-S(s_i) \\right\\|_{F}^{2}\n$$\nwhere $S(s_i)$ is the given data, $W_i \\ge 0$ are weights, and $\\| \\cdot \\|_F$ is the Frobenius norm. Expanding the Frobenius norm, the objective function is:\n$$\nJ=\\sum_{i=1}^{N} W_i \\left( |\\hat S_{11}(s_i)-S_{11}(s_i)|^2 + |\\hat S_{12}(s_i)-S_{12}(s_i)|^2 + |\\hat S_{21}(s_i)-S_{21}(s_i)|^2 + |\\hat S_{22}(s_i)-S_{22}(s_i)|^2 \\right)\n$$\nBy substituting the model's constraints, $\\hat S_{11}(s) = \\hat S_{22}(s)$ and $\\hat S_{12}(s) = \\hat S_{21}(s)$, we get:\n$$\nJ=\\sum_{i=1}^{N} W_i \\left( |\\hat S_{11}(s_i)-S_{11}(s_i)|^2 + |\\hat S_{12}(s_i)-S_{12}(s_i)|^2 + |\\hat S_{12}(s_i)-S_{21}(s_i)|^2 + |\\hat S_{11}(s_i)-S_{22}(s_i)|^2 \\right)\n$$\nThis expression can be decoupled into two independent minimization problems, one for the diagonal coefficients and one for the off-diagonal coefficients:\n$$\nJ = J_{\\mathrm{diag}} + J_{\\mathrm{offdiag}}\n$$\nwhere\n$$\nJ_{\\mathrm{diag}} = \\sum_{i=1}^{N} W_i \\left( |\\hat S_{11}(s_i)-S_{11}(s_i)|^2 + |\\hat S_{11}(s_i)-S_{22}(s_i)|^2 \\right)\n$$\n$$\nJ_{\\mathrm{offdiag}} = \\sum_{i=1}^{N} W_i \\left( |\\hat S_{12}(s_i)-S_{12}(s_i)|^2 + |\\hat S_{12}(s_i)-S_{21}(s_i)|^2 \\right)\n$$\nThe set of unknown coefficients for $J_{\\mathrm{diag}}$ is disjoint from that for $J_{\\mathrm{offdiag}}$. Therefore, we can solve for them independently.\n\nLet's formulate the linear system for the diagonal elements. The unknowns are collected in a vector $\\mathbf{x}_{\\mathrm{diag}} \\in \\mathbb{C}^{K+1}$:\n$$\n\\mathbf{x}_{\\mathrm{diag}} = [r^{(\\mathrm{d})}_1, r^{(\\mathrm{d})}_2, \\dots, r^{(\\mathrm{d})}_K, d^{(\\mathrm{d})}]^T\n$$\nThe model for $\\hat S_{11}(s_i)$ is linear in these coefficients:\n$$\n\\hat S_{11}(s_i) = \\left( \\sum_{k=1}^{K} r^{(\\mathrm{d})}_k \\phi_k(s_i) \\right) + d^{(\\mathrm{d})} = \\mathbf{\\Phi}_i^T \\mathbf{x}_{\\mathrm{diag}}\n$$\nwhere $\\phi_k(s_i) = \\frac{1}{s_i-a_k}$ are the basis functions and $\\mathbf{\\Phi}_i = [\\phi_1(s_i), \\dots, \\phi_K(s_i), 1]^T$. Minimizing $J_{\\mathrm{diag}}$ is equivalent to solving the weighted linear least-squares problem $A_{\\mathrm{diag}} \\mathbf{x}_{\\mathrm{diag}} \\approx \\mathbf{b}_{\\mathrm{diag}}$, which minimizes $\\|A_{\\mathrm{diag}} \\mathbf{x}_{\\mathrm{diag}} - \\mathbf{b}_{\\mathrm{diag}}\\|_2^2$. The system matrix $A_{\\mathrm{diag}} \\in \\mathbb{C}^{2N \\times (K+1)}$ and vector $\\mathbf{b}_{\\mathrm{diag}} \\in \\mathbb{C}^{2N}$ are constructed as:\n$$\nA_{\\mathrm{diag}} = \\begin{bmatrix}\n\\sqrt{W_1} \\mathbf{\\Phi}_1^T \\\\\n\\vdots \\\\\n\\sqrt{W_N} \\mathbf{\\Phi}_N^T \\\\\n\\sqrt{W_1} \\mathbf{\\Phi}_1^T \\\\\n\\vdots \\\\\n\\sqrt{W_N} \\mathbf{\\Phi}_N^T\n\\end{bmatrix},\n\\quad\n\\mathbf{b}_{\\mathrm{diag}} = \\begin{bmatrix}\n\\sqrt{W_1} S_{11}(s_1) \\\\\n\\vdots \\\\\n\\sqrt{W_N} S_{11}(s_N) \\\\\n\\sqrt{W_1} S_{22}(s_1) \\\\\n\\vdots \\\\\n\\sqrt{W_N} S_{22}(s_N)\n\\end{bmatrix}\n$$\nThe problem for the off-diagonal elements is formulated analogously. The vector of unknowns is $\\mathbf{x}_{\\mathrm{offdiag}} = [r^{(\\mathrm{o})}_1, r^{(\\mathrm{o})}_2, \\dots, r^{(\\mathrm{o})}_K, d^{(\\mathrm{o})}]^T$. The system is $A_{\\mathrm{offdiag}} \\mathbf{x}_{\\mathrm{offdiag}} \\approx \\mathbf{b}_{\\mathrm{offdiag}}$, where the system matrix $A_{\\mathrm{offdiag}}$ is identical to $A_{\\mathrm{diag}}$, and the right-hand side vector $\\mathbf{b}_{\\mathrm{offdiag}}$ is constructed from the off-diagonal data:\n$$\n\\mathbf{b}_{\\mathrm{offdiag}} = \\begin{bmatrix}\n\\sqrt{W_1} S_{12}(s_1) \\\\\n\\vdots \\\\\n\\sqrt{W_N} S_{12}(s_N) \\\\\n\\sqrt{W_1} S_{21}(s_1) \\\\\n\\vdots \\\\\n\\sqrt{W_N} S_{21}(s_N)\n\\end{bmatrix}\n$$\nThese complex-valued overdetermined systems are solved for $\\mathbf{x}_{\\mathrm{diag}}$ and $\\mathbf{x}_{\\mathrm{offdiag}}$ using a standard linear least-squares solver. For a given test case, the algorithm is:\n1.  Generate the data matrices $S(f_i)$ and weights $W_i$.\n2.  Compute $s_i = \\mathrm{j}2\\pi f_i$ and construct the system matrix $A = A_{\\mathrm{diag}} = A_{\\mathrm{offdiag}}$.\n3.  Construct the right-hand side vectors $\\mathbf{b}_{\\mathrm{diag}}$ and $\\mathbf{b}_{\\mathrm{offdiag}}$.\n4.  Solve the two linear least-squares problems to find the optimal coefficient vectors $\\mathbf{x}_{\\mathrm{diag}}$ and $\\mathbf{x}_{\\mathrm{offdiag}}$.\n5.  Reconstruct the model matrix $\\hat S(s_i)$ for all $i$ using the fitted coefficients.\n6.  Compute the normalized weighted RMS error $\\varepsilon_{\\mathrm{wRMS}}$ using the formula:\n    $$\n    \\varepsilon_{\\mathrm{wRMS}}=\\sqrt{\\frac{\\sum_{i=1}^{N} W_i \\left\\|\\hat S(s_i)-S(s_i)\\right\\|_{F}^{2}}{\\sum_{i=1}^{N} W_i}}\n    $$\nThis procedure is applied to each of the three test cases specified.", "answer": "```python\nimport numpy as np\n\ndef perform_fit_and_get_error(S_data, W, freqs, poles):\n    \"\"\"\n    Performs the constrained rational fit and computes the weighted RMS error.\n\n    Args:\n        S_data (np.ndarray): Array of measured S-matrices, shape (N, 2, 2).\n        W (np.ndarray): Array of frequency weights, shape (N,).\n        freqs (np.ndarray): Array of frequencies in Hz, shape (N,).\n        poles (np.ndarray): Array of fixed poles in rad/s, shape (K,).\n\n    Returns:\n        float: The normalized weighted RMS error (epsilon_wRMS).\n    \"\"\"\n    N = len(freqs)\n    K = len(poles)\n\n    s = 1j * 2 * np.pi * freqs\n\n    # Construct the basis function matrix Phi, shape (N, K+1)\n    # The last column is for the constant term d.\n    phi_matrix = np.zeros((N, K + 1), dtype=np.complex128)\n    for i in range(N):\n        for k in range(K):\n            phi_matrix[i, k] = 1.0 / (s[i] - poles[k])\n        phi_matrix[i, K] = 1.0\n\n    # Weight the basis matrix rows by sqrt(W_i)\n    sqrt_W = np.sqrt(W)\n    weighted_phi = sqrt_W[:, np.newaxis] * phi_matrix\n\n    # The system matrix A is the same for both diagonal and off-diagonal fits.\n    # It has shape (2N, K+1), stacking the weighted basis for Sij and Sji.\n    A = np.vstack([weighted_phi, weighted_phi])\n\n    # ---- Diagonal Fit (for S11 and S22) ----\n    S11_data = S_data[:, 0, 0]\n    S22_data = S_data[:, 1, 1]\n    \n    # Construct the right-hand-side vector b_d, shape (2N,)\n    b_d = np.concatenate([sqrt_W * S11_data, sqrt_W * S22_data])\n    \n    # Solve the least-squares problem for diagonal coefficients x_d\n    x_d, _, _, _ = np.linalg.lstsq(A, b_d, rcond=None)\n\n    # ---- Off-diagonal Fit (for S12 and S21) ----\n    S12_data = S_data[:, 0, 1]\n    S21_data = S_data[:, 1, 0]\n\n    # Construct the right-hand-side vector b_o, shape (2N,)\n    b_o = np.concatenate([sqrt_W * S12_data, sqrt_W * S21_data])\n\n    # Solve the least-squares problem for off-diagonal coefficients x_o\n    x_o, _, _, _ = np.linalg.lstsq(A, b_o, rcond=None)\n\n    # ---- Reconstruct the model and Calculate Error ----\n    # Reconstructed S-parameter entries from the fit\n    S11_fit = phi_matrix @ x_d\n    S12_fit = phi_matrix @ x_o\n\n    # Assemble the full fitted S-matrix S_hat\n    S_hat = np.zeros((N, 2, 2), dtype=np.complex128)\n    S_hat[:, 0, 0] = S11_fit\n    S_hat[:, 1, 1] = S11_fit  # Enforce S11 = S22\n    S_hat[:, 0, 1] = S12_fit\n    S_hat[:, 1, 0] = S12_fit  # Enforce S12 = S21\n\n    # Calculate the squared Frobenius norm of the error matrix (S_hat - S_data) at each frequency\n    error_matrix = S_hat - S_data\n    frob_norm_sq_per_freq = np.sum(np.abs(error_matrix)**2, axis=(1, 2))\n\n    # Calculate the total weighted sum of squared errors (the objective function cost, J)\n    J = np.sum(W * frob_norm_sq_per_freq)\n\n    # Sum of weights for normalization\n    W_sum = np.sum(W)\n    \n    if W_sum == 0:\n        # If all weights are zero, the error is definitionally zero.\n        return 0.0\n\n    # Calculate the final normalized weighted RMS error\n    epsilon_wRMS = np.sqrt(J / W_sum)\n    \n    return epsilon_wRMS\n\n\ndef solve():\n    # ---- Common Setup and Definitions ----\n    K = 3\n    poles = -2 * np.pi * np.array([0.5e9, 2.0e9, 8.0e9])\n    freqs = np.array([0.5, 1.0, 2.0, 3.5, 5.0, 7.5, 10.0, 15.0, 20.0]) * 1e9\n    N = len(freqs)\n    \n    results = []\n\n    # ---- Test Case 1: Ideal Symmetric Reciprocal Data ----\n    r_d_ideal = np.array([0.08, -0.03, 0.015])\n    d_d_ideal = 0.01\n    r_o_ideal = np.array([0.20, 0.09, -0.05])\n    d_o_ideal = -0.005\n    \n    s = 1j * 2 * np.pi * freqs\n    phi_matrix_gen = np.zeros((N, K), dtype=np.complex128)\n    for i in range(N):\n        for k in range(K):\n            phi_matrix_gen[i, k] = 1.0 / (s[i] - poles[k])\n\n    S11_ideal = phi_matrix_gen @ r_d_ideal + d_d_ideal\n    S12_ideal = phi_matrix_gen @ r_o_ideal + d_o_ideal\n\n    S_case1 = np.zeros((N, 2, 2), dtype=np.complex128)\n    S_case1[:, 0, 0] = S11_ideal\n    S_case1[:, 1, 1] = S11_ideal\n    S_case1[:, 0, 1] = S12_ideal\n    S_case1[:, 1, 0] = S12_ideal\n\n    W_case1 = 1.0 / (1.0 + (freqs / 1e10)**2)\n    \n    err1 = perform_fit_and_get_error(S_case1, W_case1, freqs, poles)\n    results.append(err1)\n\n    # ---- Test Case 2: Asymmetric Perturbation ----\n    S_case2 = np.copy(S_case1)\n    delta = 0.02\n    f_d = 5.0e9\n    tau = np.exp(-freqs / f_d)\n    S_case2[:, 0, 1] += delta * tau\n    S_case2[:, 1, 0] -= delta * tau\n    \n    W_case2 = W_case1  # Weights are the same as Case 1\n\n    err2 = perform_fit_and_get_error(S_case2, W_case2, freqs, poles)\n    results.append(err2)\n\n    # ---- Test Case 3: Outlier with Zero Weight ----\n    S_case3 = np.copy(S_case1)\n    Delta = 0.5\n    outlier_idx = np.where(freqs == 15.0e9)[0][0]\n    S_case3[outlier_idx, :, :] += Delta\n\n    W_case3 = np.copy(W_case1)\n    W_case3[outlier_idx] = 0.0\n    \n    err3 = perform_fit_and_get_error(S_case3, W_case3, freqs, poles)\n    results.append(err3)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```", "id": "3346664"}]}