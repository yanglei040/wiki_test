{"hands_on_practices": [{"introduction": "Before building complex multiphysics models, it is essential to verify that the numerical discretization faithfully represents the underlying physical laws. This practice provides a rigorous test of discrete energy conservation by directly comparing the electromagnetic power dissipated in a simulated object to the resulting change in its thermal energy. By implementing a Finite Volume Method and checking that the energy residual is numerically zero, you will build confidence in your code's ability to correctly couple the electromagnetic and thermal domains [@problem_id:3304816].", "problem": "A one-dimensional coupled Electromagnetic (EM)–thermal conduction verification is to be performed by implementing a discrete conservation check over a uniform rod using the Finite Volume Method (FVM). The computational goal is to test, in a fully discrete setting, that the volumetric EM dissipation equals the combined rate of thermal energy increase and conductive boundary exchange, when these are evaluated consistently at the same discrete time level. The derivation must start from first principles: Maxwell's equations giving rise to the EM energy balance and Ohm's law, together with the heat conduction partial differential equation. The governing statements, expressed without shortcuts, are that the EM power density supplied to matter is $\\,\\mathbf{J}\\cdot\\mathbf{E}\\,$ and that the thermal evolution is governed by a diffusion operator and volumetric heating. In one dimension ($\\,x\\,$), with cross-sectional area $\\,A\\,$, material density $\\,\\rho\\,$, specific heat $\\,c\\,$, thermal conductivity $\\,k\\,$, electrical conductivity $\\,\\sigma\\,$, temperature field $\\,T(x,t)\\,$, and electric field $\\,E(x,t)\\,$, you must:\n\n- Discretize the rod of length $\\,L\\,$ into $\\,N\\,$ uniform control volumes of width $\\,\\Delta x = L/N\\,$, using cell centers at $\\,x_i = (i - \\tfrac{1}{2})\\Delta x\\,$ for $\\,i=1,\\dots,N\\,$.\n- Use a single explicit time step $\\,\\Delta t\\,$ to update the temperature via the divergence of $\\,k\\nabla T\\,$ and the local Joule heating $\\,\\sigma E^2\\,$, evaluated at time level $\\,t^n\\,$.\n- Evaluate the discrete volumetric EM dissipation $\\,\\int_{\\Omega} \\mathbf{J}\\cdot\\mathbf{E}\\,dV\\,$ by summing $\\,\\sigma E_i^2\\,V_i\\,$ over all cells at time $\\,t^n\\,$, where $\\,V_i = A\\,\\Delta x\\,$.\n- Evaluate the discrete rate of thermal energy increase $\\,\\int_{\\Omega} \\rho c\\,\\partial_t T\\,dV\\,$ by summing $\\,\\rho c\\,\\frac{T_i^{n+1}-T_i^n}{\\Delta t}\\,V_i\\,$ over all cells.\n- Evaluate the discrete boundary exchange $\\,\\int_{\\partial\\Omega} k\\nabla T\\cdot \\mathbf{n}\\,dS\\,$ using one-sided face gradients consistent with the FVM interior stencil at time $\\,t^n\\,$. For Dirichlet temperature boundaries $\\,T(0,t)=T_{\\text{left}}\\,$ and $\\,T(L,t)=T_{\\text{right}}\\,$, compute $\\,G_{1/2} = \\frac{T_1^n - T_{\\text{left}}}{\\Delta x}\\,$ and $\\,G_{N+1/2} = \\frac{T_{\\text{right}} - T_N^n}{\\Delta x}\\,$, then the boundary integral is $\\,A\\,k\\,(G_{N+1/2}-G_{1/2})\\,$. For insulated boundaries (homogeneous Neumann), set $\\,G_{1/2}=0\\,$ and $\\,G_{N+1/2}=0\\,$.\n\nYou must compute, for each test case, the scalar residual\n$$\nr \\;=\\; \\left(\\sum_{i=1}^{N} \\sigma E_i^2 V_i\\right) \\;-\\; \\left(\\sum_{i=1}^{N} \\rho c \\frac{T_i^{n+1}-T_i^n}{\\Delta t} V_i \\;-\\; A k (G_{N+1/2} - G_{1/2})\\right),\n$$\nwhich, under a consistent discretization, should be numerically close to $\\,0\\,$. Report $\\,r\\,$ in watts (W) for each test case.\n\nImplement the FVM update for $\\,T\\,$ using the discrete divergence of $\\,k\\nabla T\\,$ at time $\\,t^n\\,$ with uniform $\\,k\\,$:\n$$\n\\left[\\nabla\\cdot(k\\nabla T)\\right]_i^n \\;=\\; \\frac{k}{\\Delta x}\\left(G_{i+1/2}^n - G_{i-1/2}^n\\right), \\quad G_{i+1/2}^n \\;=\\; \\frac{T_{i+1}^n - T_i^n}{\\Delta x}, \\quad i=1,\\dots,N,\n$$\nwhere at boundaries $\\,G_{1/2}^n\\,$ and $\\,G_{N+1/2}^n\\,$ are defined by the boundary condition as described above. Use $\\,T_i^{n+1} = T_i^n + \\Delta t\\left(\\frac{1}{\\rho c}\\left[\\nabla\\cdot(k\\nabla T)\\right]_i^n + \\frac{1}{\\rho c}\\sigma E_i^2\\right)\\,$.\n\nUse the following test suite (all constants expressed in the International System of Units):\n\n- Test case $\\,1\\,$ (general Dirichlet “happy path” with nonzero boundary exchange):\n  - $\\,L = 1.0\\,$, $\\,N = 100\\,$, $\\,A = 1.0\\,$, $\\,\\rho = 7800.0\\,$, $\\,c = 500.0\\,$, $\\,k = 50.0\\,$, $\\,\\sigma = 1.0\\times 10^{6}\\,$, $\\,\\Delta t = 0.01\\,$.\n  - Boundary: Dirichlet with $\\,T_{\\text{left}} = 300.0\\,$, $\\,T_{\\text{right}} = 300.0\\,$.\n  - Initial temperature: $\\,T(x,0) = 300.0 + 50.0\\sin\\left(\\pi x / L\\right)\\,$.\n  - Electric field: $\\,E(x) = 10.0 + 5.0\\sin\\left(2\\pi x / L\\right)\\,$.\n\n- Test case $\\,2\\,$ (insulated boundary, Neumann $\\,0\\,$):\n  - $\\,L = 1.0\\,$, $\\,N = 80\\,$, $\\,A = 1.0\\,$, $\\,\\rho = 7800.0\\,$, $\\,c = 500.0\\,$, $\\,k = 100.0\\,$, $\\,\\sigma = 2.0\\times 10^{6}\\,$, $\\,\\Delta t = 0.01\\,$.\n  - Boundary: Neumann with $\\,G_{1/2} = 0\\,$ and $\\,G_{N+1/2} = 0\\,$.\n  - Initial temperature: $\\,T(x,0) = 350.0 + 25.0\\cos\\left(2\\pi x / L\\right)\\,$.\n  - Electric field: $\\,E(x) = 7.0\\,$ (uniform).\n\n- Test case $\\,3\\,$ (no EM heating, pure conduction under Dirichlet):\n  - $\\,L = 1.0\\,$, $\\,N = 120\\,$, $\\,A = 1.0\\,$, $\\,\\rho = 7800.0\\,$, $\\,c = 500.0\\,$, $\\,k = 200.0\\,$, $\\,\\sigma = 0.0\\,$, $\\,\\Delta t = 0.01\\,$.\n  - Boundary: Dirichlet with $\\,T_{\\text{left}} = 350.0\\,$, $\\,T_{\\text{right}} = 300.0\\,$.\n  - Initial temperature: $\\,T(x,0) = 350.0 - 50.0 x / L\\,$ (linear).\n  - Electric field: $\\,E(x) = 0.0\\,$.\n\n- Test case $\\,4\\,$ (single-cell edge case under Dirichlet):\n  - $\\,L = 1.0\\,$, $\\,N = 1\\,$, $\\,A = 1.0\\,$, $\\,\\rho = 7800.0\\,$, $\\,c = 500.0\\,$, $\\,k = 10.0\\,$, $\\,\\sigma = 5.0\\times 10^{5}\\,$, $\\,\\Delta t = 0.01\\,$.\n  - Boundary: Dirichlet with $\\,T_{\\text{left}} = 310.0\\,$, $\\,T_{\\text{right}} = 290.0\\,$.\n  - Initial temperature: $\\,T(x,0) = 310.0 - 20.0 x / L\\,$ (linear).\n  - Electric field: $\\,E(x) = 3.0\\,$ (uniform).\n\nYour program must implement the above discretization and compute the residual $\\,r\\,$ for each test case. Express the residuals in watts (W) as floating-point numbers. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\,[r_1,r_2,r_3,r_4]\\,$). No other output is permitted. Angles, if any arise, must be in radians. Percentages must not be used; use decimals for any fractional quantities.", "solution": "The problem statement has been critically validated and is deemed valid. It is scientifically grounded in the principles of heat transfer and electromagnetism, is mathematically well-posed, and all provided data, equations, and conditions are self-contained and consistent. The task is to perform a numerical verification of discrete energy conservation for a one-dimensional electromagnetic–thermal coupling problem using the Finite Volume Method (FVM).\n\nThe physical principle underpinning this problem is the conservation of energy, which, for a system involving heat conduction and volumetric heat generation, is described by the heat equation. In one dimension ($x$), for a material with density $\\rho$, specific heat $c$, and thermal conductivity $k$, the temperature field $T(x,t)$ evolves according to:\n$$\n\\rho c \\frac{\\partial T}{\\partial t} = \\nabla \\cdot (k \\nabla T) + S\n$$\nwhere $S$ is the volumetric heat source density. In this problem, the heat source is Joule heating arising from an electric field $E$ in a material with electrical conductivity $\\sigma$. According to Ohm's law, the current density is $J = \\sigma E$, and the power density dissipated as heat is $S = J \\cdot E = \\sigma E^2$. Thus, the governing partial differential equation (PDE) is:\n$$\n\\rho c \\frac{\\partial T}{\\partial t} = \\frac{\\partial}{\\partial x}\\left(k \\frac{\\partial T}{\\partial x}\\right) + \\sigma E^2\n$$\nTo verify energy conservation, we integrate this PDE over the entire domain, a rod of length $L$ and cross-sectional area $A$. The volume of the domain is $\\Omega$.\n$$\n\\int_{\\Omega} \\rho c \\frac{\\partial T}{\\partial t} dV = \\int_{\\Omega} \\nabla \\cdot (k \\nabla T) dV + \\int_{\\Omega} \\sigma E^2 dV\n$$\nApplying the divergence theorem to the first term on the right-hand side transforms the volume integral of the divergence of the heat flux into a surface integral of the flux over the boundary $\\partial\\Omega$:\n$$\n\\int_{\\Omega} \\nabla \\cdot (k \\nabla T) dV = \\int_{\\partial\\Omega} (k \\nabla T) \\cdot \\mathbf{n} \\, dS\n$$\nwhere $\\mathbf{n}$ is the outward-pointing normal vector at the boundary. The equation for global energy balance can be rearranged to state that the total supplied power must equal the rate of change of stored energy plus the power exiting through the boundaries:\n$$\n\\underbrace{\\int_{\\Omega} \\sigma E^2 dV}_{\\text{EM Dissipation}} = \\underbrace{\\int_{\\Omega} \\rho c \\frac{\\partial T}{\\partial t} dV}_{\\text{Rate of Thermal Energy Increase}} - \\underbrace{\\int_{\\partial\\Omega} k (\\nabla T) \\cdot \\mathbf{n} \\, dS}_{\\text{Net Heat Outflow}}\n$$\nThe problem requires checking if a specific FVM discretization maintains this conservation law in its algebraic, discrete form. The rod is discretized into $N$ control volumes, each of width $\\Delta x = L/N$ and volume $V_i = A \\Delta x$. The temperature in cell $i$ is $T_i$.\n\nThe provided FVM time-update scheme for the temperature in cell $i$ from time $t^n$ to $t^{n+1}=t^n+\\Delta t$ is:\n$$\nT_i^{n+1} = T_i^n + \\frac{\\Delta t}{\\rho c} \\left( \\left[\\nabla\\cdot(k\\nabla T)\\right]_i^n + \\sigma E_i^2 \\right)\n$$\nRearranging this equation gives the discrete equivalent of the local PDE at cell $i$:\n$$\n\\rho c \\frac{T_i^{n+1}-T_i^n}{\\Delta t} = \\left[\\nabla\\cdot(k\\nabla T)\\right]_i^n + \\sigma E_i^2\n$$\nTo obtain the global discrete energy balance, we multiply by the cell volume $V_i = A\\Delta x$ and sum over all $N$ cells:\n$$\n\\sum_{i=1}^N \\rho c \\frac{T_i^{n+1}-T_i^n}{\\Delta t} V_i = \\sum_{i=1}^N \\left[\\nabla\\cdot(k\\nabla T)\\right]_i^n V_i + \\sum_{i=1}^N \\sigma E_i^2 V_i\n$$\nThe term on the left represents the discrete rate of thermal energy increase. The second term on the right is the discrete volumetric EM dissipation. The crucial step is to evaluate the sum of the discrete divergence terms. Using the provided definition:\n$$\n\\sum_{i=1}^N \\left[\\nabla\\cdot(k\\nabla T)\\right]_i^n V_i = \\sum_{i=1}^N \\frac{k}{\\Delta x}\\left(G_{i+1/2}^n - G_{i-1/2}^n\\right) (A \\Delta x) = Ak \\sum_{i=1}^N \\left(G_{i+1/2}^n - G_{i-1/2}^n\\right)\n$$\nwhere $G_{i+1/2}^n = (T_{i+1}^n - T_i^n)/\\Delta x$ are the gradients at the interior faces. This summation is a telescoping series:\n$$\n\\sum_{i=1}^N \\left(G_{i+1/2}^n - G_{i-1/2}^n\\right) = (G_{3/2}^n - G_{1/2}^n) + (G_{5/2}^n - G_{3/2}^n) + \\dots + (G_{N+1/2}^n - G_{N-1/2}^n)\n$$\nAll interior face gradient terms cancel out, leaving only the boundary terms:\n$$\nAk \\sum_{i=1}^N \\left(G_{i+1/2}^n - G_{i-1/2}^n\\right) = Ak(G_{N+1/2}^n - G_{1/2}^n)\n$$\nThis term corresponds precisely to the discrete representation of the net heat inflow from the boundaries, noting that the boundary exchange integral $\\int_{\\partial\\Omega} k\\nabla T\\cdot \\mathbf{n}\\,dS$ evaluates to $Ak(G_{N+1/2}^n - G_{1/2}^n)$. Substituting this result back into the summed equation yields the discrete global energy balance:\n$$\n\\sum_{i=1}^N \\rho c \\frac{T_i^{n+1}-T_i^n}{\\Delta t} V_i = Ak(G_{N+1/2}^n - G_{1/2}^n) + \\sum_{i=1}^N \\sigma E_i^2 V_i\n$$\nThe residual $r$ to be computed is defined as:\n$$\nr = \\left(\\sum_{i=1}^{N} \\sigma E_i^2 V_i\\right) - \\left(\\sum_{i=1}^{N} \\rho c \\frac{T_i^{n+1}-T_i^n}{\\Delta t} V_i - A k (G_{N+1/2}^n - G_{1/2}^n)\\right)\n$$\nBy rearranging the discrete global energy balance equation, we see that $r$ must be identically zero:\n$$\n\\left(\\sum_{i=1}^{N} \\sigma E_i^2 V_i\\right) + A k (G_{N+1/2}^n - G_{1/2}^n) - \\left(\\sum_{i=1}^{N} \\rho c \\frac{T_i^{n+1}-T_i^n}{\\Delta t} V_i\\right) = 0\n$$\nTherefore, the task reduces to implementing the FVM update and the evaluation of each term in the residual expression precisely as defined. The expected result for $r$ is a value numerically close to zero, with any non-zero value attributable to floating-point representation and arithmetic errors.\n\nThe implementation will proceed as follows for each test case:\n1.  Define all physical and numerical parameters ($L, N, A, \\rho, c, k, \\sigma, \\Delta t$).\n2.  Construct the spatial grid of $N$ cell centers $x_i = (i-1/2)\\Delta x$.\n3.  Evaluate the initial temperature field $T_i^n$ and the electric field $E_i$ at each cell center $x_i$.\n4.  Calculate the boundary gradients $G_{1/2}^n$ and $G_{N+1/2}^n$ based on the specified boundary conditions (Dirichlet or Neumann).\n5.  Calculate the interior face gradients $G_{i+1/2}^n = (T_{i+1}^n - T_i^n)/\\Delta x$ for $i=1, \\dots, N-1$.\n6.  Compute the discrete divergence of thermal flux, $\\left[\\nabla\\cdot(k\\nabla T)\\right]_i^n$, for each cell.\n7.  Perform the single explicit time step to find the new temperature field $T_i^{n+1}$.\n8.  Compute the three components of the residual equation: the total EM dissipation, the total rate of thermal energy increase, and the boundary exchange term.\n9.  Combine these three components to find the final residual $r$.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    \n    test_cases = [\n        {\n            # Test case 1\n            'L': 1.0, 'N': 100, 'A': 1.0, 'rho': 7800.0, 'c': 500.0, 'k': 50.0, \n            'sigma': 1.0e6, 'dt': 0.01,\n            'bc_type': 'dirichlet', \n            'T_left': 300.0, 'T_right': 300.0,\n            'T_initial_func': lambda x, L: 300.0 + 50.0 * np.sin(np.pi * x / L),\n            'E_field_func': lambda x, L: 10.0 + 5.0 * np.sin(2 * np.pi * x / L)\n        },\n        {\n            # Test case 2\n            'L': 1.0, 'N': 80, 'A': 1.0, 'rho': 7800.0, 'c': 500.0, 'k': 100.0, \n            'sigma': 2.0e6, 'dt': 0.01,\n            'bc_type': 'neumann',\n            'T_initial_func': lambda x, L: 350.0 + 25.0 * np.cos(2 * np.pi * x / L),\n            'E_field_func': lambda x, L: 7.0\n        },\n        {\n            # Test case 3\n            'L': 1.0, 'N': 120, 'A': 1.0, 'rho': 7800.0, 'c': 500.0, 'k': 200.0, \n            'sigma': 0.0, 'dt': 0.01,\n            'bc_type': 'dirichlet',\n            'T_left': 350.0, 'T_right': 300.0,\n            'T_initial_func': lambda x, L: 350.0 - 50.0 * x / L,\n            'E_field_func': lambda x, L: 0.0\n        },\n        {\n            # Test case 4\n            'L': 1.0, 'N': 1, 'A': 1.0, 'rho': 7800.0, 'c': 500.0, 'k': 10.0, \n            'sigma': 5.0e5, 'dt': 0.01,\n            'bc_type': 'dirichlet',\n            'T_left': 310.0, 'T_right': 290.0,\n            'T_initial_func': lambda x, L: 310.0 - 20.0 * x / L,\n            'E_field_func': lambda x, L: 3.0\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        residual = calculate_residual(params)\n        results.append(residual)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_residual(params):\n    \"\"\"\n    Calculates the energy conservation residual for a single test case.\n    \"\"\"\n    # Unpack parameters\n    L, N, A, rho, c, k, sigma, dt = \\\n        params['L'], params['N'], params['A'], params['rho'], \\\n        params['c'], params['k'], params['sigma'], params['dt']\n    \n    # Grid setup\n    dx = L / N\n    # Cell centers x_i for i = 1, ..., N\n    x = (np.arange(N) + 0.5) * dx\n    V_i = A * dx\n\n    # Initialize fields at time t^n\n    T_n = params['T_initial_func'](x, L)\n    E = params['E_field_func'](x, L)\n    # Ensure E is an array for scalar E_field_func\n    if np.isscalar(E):\n        E = np.full(N, E)\n\n    # Calculate face gradients G_{i+1/2}^n\n    # Interior gradients first\n    if N > 1:\n        G_interior = (T_n[1:] - T_n[:-1]) / dx\n    else:\n        G_interior = np.array([])\n        \n    # Boundary gradients\n    if params['bc_type'] == 'dirichlet':\n        T_left, T_right = params['T_left'], params['T_right']\n        G_half = (T_n[0] - T_left) / dx          # G_{1/2}\n        G_N_plus_half = (T_right - T_n[-1]) / dx # G_{N+1/2}\n    elif params['bc_type'] == 'neumann':\n        G_half = 0.0\n        G_N_plus_half = 0.0\n    \n    # Assemble all face gradients into a single array of size N+1\n    # G[0] = G_{1/2}, G[1...N-1] = G_{3/2...N-1/2}, G[N] = G_{N+1/2}\n    G = np.zeros(N + 1)\n    G[0] = G_half\n    G[-1] = G_N_plus_half\n    if N > 1:\n        G[1:-1] = G_interior\n\n    # Calculate discrete divergence of thermal flux for each cell\n    # [nabla . (k nabla T)]_i^n = (k/dx) * (G_{i+1/2} - G_{i-1/2})\n    div_term = (k / dx) * (G[1:] - G[:-1])\n\n    # Joule heating term\n    joule_heat = sigma * E**2\n    \n    # Update temperature to T^{n+1} using explicit Euler step\n    T_np1 = T_n + (dt / (rho * c)) * (div_term + joule_heat)\n\n    # --- Calculate terms for the residual ---\n\n    # 1. Total volumetric EM dissipation\n    em_dissipation = np.sum(sigma * E**2 * V_i)\n\n    # 2. Total rate of thermal energy increase\n    thermal_increase_rate = np.sum(rho * c * (T_np1 - T_n) / dt * V_i)\n\n    # 3. Boundary exchange term (net heat flux INTO the domain)\n    # The problem defines the boundary exchange integral as a positive outflow:\n    # integral(k*nabla(T).n) dS = A*k*(G_N+1/2 - G_1/2)\n    # The residual formula is Source - (Storage - Boundary_Exchange)\n    boundary_exchange = A * k * (G_N_plus_half - G_half)\n\n    # Calculate the final residual r\n    r = em_dissipation - (thermal_increase_rate - boundary_exchange)\n    \n    return r\n\nsolve()\n```", "id": "3304816"}, {"introduction": "Many real-world electromagnetic–thermal coupling problems are non-linear because material properties like conductivity and permittivity depend strongly on temperature. This practice moves from linear verification to solving such a non-linear system for a polymer heated by microwaves. You will implement a fixed-point iterative scheme, a common and powerful technique, to find the steady-state temperature where the absorbed electromagnetic power balances the convective heat loss [@problem_id:3304789].", "problem": "You are given a simplified, yet physically grounded, coupled electromagnetic–thermal model for a polymer sample heated by microwaves inside a driven parallel-plate resonator. The goal is to construct a computational procedure that iteratively updates the electromagnetic fields and the temperature until steady-state convergence, using a stopping criterion based on an energy residual norm. The problem must be solved using the following fundamental bases.\n\nStart from the frequency-domain formulation of Maxwell’s equations with sinusoidal steady-state driving, the material constitutive relation, and conservation of energy:\n- The time-average volumetric electromagnetic dissipation density in a linear, isotropic, lossy dielectric under a time-harmonic electric field $\\mathbf{E}$ of angular frequency $\\omega$ is given by\n$$\np_{\\mathrm{loss}}(T) = \\tfrac{1}{2}\\left(\\sigma(T) + \\omega \\varepsilon_0 \\epsilon''(T)\\right)\\left\\lVert \\mathbf{E}\\right\\rVert^2,\n$$\nwhere $\\sigma(T)$ is the electrical conductivity, $\\epsilon''(T)$ is the imaginary part of the relative permittivity, and $\\varepsilon_0$ is the vacuum permittivity.\n- The sample fills the gap of a parallel-plate capacitor of plate area $A$ and plate spacing $d$, so the capacitance is $C = \\varepsilon_0 \\varepsilon' A / d$, where $\\varepsilon'$ is the real part of the relative permittivity, taken temperature-independent. The dielectric loss may be represented by an equivalent conductance\n$$\nG_{\\mathrm{d}}(T) = \\omega \\varepsilon_0 \\frac{A}{d}\\,\\epsilon''(T) + \\frac{A}{d}\\,\\sigma(T),\n$$\nso that the average absorbed electromagnetic power in the dielectric volume is $P_{\\mathrm{abs}}(T) = \\tfrac{1}{2} V^2 G_{\\mathrm{d}}(T)$, where $V$ is the root mean square voltage across the capacitor.\n- The resonator is driven with a prescribed average input power $P_{\\mathrm{in}}$ and has additional temperature-independent losses represented by a parasitic conductance $G_{\\mathrm{c}}$. Under steady-state sinusoidal operation, power balance in the resonator gives\n$$\nP_{\\mathrm{in}} = \\tfrac{1}{2} V^2 \\left(G_{\\mathrm{c}} + G_{\\mathrm{d}}(T)\\right),\n$$\nso that the field amplitude and the absorbed power depend on $T$ through $G_{\\mathrm{d}}(T)$. Eliminate $V$ to obtain the absorbed power as a function of temperature,\n$$\nP_{\\mathrm{abs}}(T) = P_{\\mathrm{in}}\\,\\frac{G_{\\mathrm{d}}(T)}{G_{\\mathrm{c}} + G_{\\mathrm{d}}(T)}.\n$$\n- The thermal steady-state energy balance of the lumped sample equates absorbed power to convective heat loss,\n$$\nP_{\\mathrm{abs}}(T) - h S \\left(T - T_{\\mathrm{amb}}\\right) = 0,\n$$\nwhere $h$ is the convective heat transfer coefficient, $S$ is the convective surface area, and $T_{\\mathrm{amb}}$ is the ambient temperature.\n\nDefine the energy residual at temperature iterate $T$ as\n$$\nr(T) = P_{\\mathrm{abs}}(T) - h S \\left(T - T_{\\mathrm{amb}}\\right).\n$$\nConstruct a fixed-point iterative procedure that alternates between electromagnetic update and thermal update, using the mapping\n$$\nT_{\\mathrm{new}} \\leftarrow T_{\\mathrm{amb}} + \\frac{P_{\\mathrm{abs}}(T_{\\mathrm{old}})}{h S},\n$$\noptionally with under-relaxation. Use the stopping criterion based on the energy residual norm\n$$\n\\frac{\\left|r(T)\\right|}{P_{\\mathrm{in}}} \\le \\tau,\n$$\nwhere $\\tau$ is a prescribed tolerance. The final temperature must be reported in Kelvin.\n\nAll computations must be performed in International System of Units (SI). Angles, if any, must be in radians. The only outputs required are the converged steady-state temperatures, rounded to three decimal places, in Kelvin.\n\nTest suite and parameters:\n- Common constants for all cases:\n  - Vacuum permittivity: $\\varepsilon_0 = 8.854187817\\times 10^{-12}\\,\\mathrm{F/m}$.\n  - Frequency: $f = 2.45\\times 10^{9}\\,\\mathrm{Hz}$; angular frequency $\\omega = 2\\pi f$.\n  - Real part of relative permittivity: $\\varepsilon' = 2.5$.\n  - Plate area: $A = 1.0\\times 10^{-2}\\,\\mathrm{m}^2$.\n  - Plate spacing: $d = 1.0\\times 10^{-2}\\,\\mathrm{m}$.\n  - Convective surface area: $S = 2A$.\n  - Ambient temperature: $T_{\\mathrm{amb}} = 293.15\\,\\mathrm{K}$.\n  - Initial guess for temperature iteration: $T_0 = T_{\\mathrm{amb}}$.\n  - Convergence tolerance: $\\tau = 1.0\\times 10^{-8}$.\n  - Maximum iterations: $N_{\\max} = 100000$.\n- Measured property models for each case are provided as temperature-dependent functions $\\sigma(T)$ and $\\epsilon''(T)$ based on polynomials in $(T - T_{\\mathrm{ref}})$ with $T_{\\mathrm{ref}} = 293.15\\,\\mathrm{K}$. Explicitly, use\n  - $\\sigma(T) = a_0 + a_1\\,(T - T_{\\mathrm{ref}}) + a_2\\,(T - T_{\\mathrm{ref}})^2$ in $\\mathrm{S/m}$,\n  - $\\epsilon''(T) = b_0 + b_1\\,(T - T_{\\mathrm{ref}}) + b_2\\,(T - T_{\\mathrm{ref}})^2$ (dimensionless).\n- Test cases:\n  1. Case A (moderate, temperature-increasing losses):\n     - Input power: $P_{\\mathrm{in}} = 200\\,\\mathrm{W}$.\n     - Parasitic conductance: $G_{\\mathrm{c}} = 5.0\\times 10^{-3}\\,\\mathrm{S}$.\n     - Convection coefficient: $h = 20\\,\\mathrm{W/(m^2\\,K)}$.\n     - $\\sigma(T)$ coefficients: $a_0 = 5.0\\times 10^{-5}$, $a_1 = 5.0\\times 10^{-7}$, $a_2 = 0$.\n     - $\\epsilon''(T)$ coefficients: $b_0 = 2.0\\times 10^{-2}$, $b_1 = 1.5\\times 10^{-4}$, $b_2 = 0$.\n  2. Case B (very low losses and low input power):\n     - Input power: $P_{\\mathrm{in}} = 10\\,\\mathrm{W}$.\n     - Parasitic conductance: $G_{\\mathrm{c}} = 5.0\\times 10^{-3}\\,\\mathrm{S}$.\n     - Convection coefficient: $h = 10\\,\\mathrm{W/(m^2\\,K)}$.\n     - $\\sigma(T)$ coefficients: $a_0 = 1.0\\times 10^{-6}$, $a_1 = 1.0\\times 10^{-8}$, $a_2 = 0$.\n     - $\\epsilon''(T)$ coefficients: $b_0 = 5.0\\times 10^{-3}$, $b_1 = 2.0\\times 10^{-5}$, $b_2 = 0$.\n  3. Case C (higher input power with dominant parasitic loss):\n     - Input power: $P_{\\mathrm{in}} = 500\\,\\mathrm{W}$.\n     - Parasitic conductance: $G_{\\mathrm{c}} = 2.0\\times 10^{-2}\\,\\mathrm{S}$.\n     - Convection coefficient: $h = 20\\,\\mathrm{W/(m^2\\,K)}$.\n     - $\\sigma(T)$ coefficients: $a_0 = 2.0\\times 10^{-4}$, $a_1 = 2.0\\times 10^{-7}$, $a_2 = 0$.\n     - $\\epsilon''(T)$ coefficients: $b_0 = 3.0\\times 10^{-2}$, $b_1 = 1.0\\times 10^{-4}$, $b_2 = 0$.\n  4. Case D (constant losses with strong convection):\n     - Input power: $P_{\\mathrm{in}} = 200\\,\\mathrm{W}$.\n     - Parasitic conductance: $G_{\\mathrm{c}} = 5.0\\times 10^{-3}\\,\\mathrm{S}$.\n     - Convection coefficient: $h = 100\\,\\mathrm{W/(m^2\\,K)}$.\n     - $\\sigma(T)$ coefficients: $a_0 = 5.0\\times 10^{-5}$, $a_1 = 0$, $a_2 = 0$.\n     - $\\epsilon''(T)$ coefficients: $b_0 = 2.0\\times 10^{-2}$, $b_1 = 0$, $b_2 = 0$.\n\nTasks to implement:\n- For each test case, implement $\\sigma(T)$ and $\\epsilon''(T)$ as specified polynomials.\n- Implement $G_{\\mathrm{d}}(T)$ using $G_{\\mathrm{d}}(T) = \\omega \\varepsilon_0 \\frac{A}{d}\\,\\epsilon''(T) + \\frac{A}{d}\\,\\sigma(T)$.\n- Implement $P_{\\mathrm{abs}}(T) = P_{\\mathrm{in}}\\,\\frac{G_{\\mathrm{d}}(T)}{G_{\\mathrm{c}} + G_{\\mathrm{d}}(T)}$.\n- Iteratively update $T$ using the fixed-point map $T_{\\mathrm{new}} \\leftarrow T_{\\mathrm{amb}} + \\frac{P_{\\mathrm{abs}}(T_{\\mathrm{old}})}{h S}$ until the normalized residual $\\left|r(T)\\right|/P_{\\mathrm{in}} \\le \\tau$, where $r(T) = P_{\\mathrm{abs}}(T) - h S \\left(T - T_{\\mathrm{amb}}\\right)$. Use under-relaxation if needed to ensure convergence, but the stopping criterion must be solely the residual norm.\n- Report the final converged steady-state temperatures in Kelvin for the four cases.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[T_A,T_B,T_C,T_D]$, where each $T_\\cdot$ is the converged steady-state temperature in $\\mathrm{K}$ rounded to three decimal places.", "solution": "The user wants to solve a coupled electromagnetic–thermal problem to find the steady-state temperature of a polymer sample heated by microwaves.\n\n### Step 1: Extract Givens\n\n-   **Governing equations:**\n    -   Time-average volumetric electromagnetic dissipation density: $p_{\\mathrm{loss}}(T) = \\tfrac{1}{2}\\left(\\sigma(T) + \\omega \\varepsilon_0 \\epsilon''(T)\\right)\\left\\lVert \\mathbf{E}\\right\\rVert^2$.\n    -   Equivalent dielectric conductance: $G_{\\mathrm{d}}(T) = \\omega \\varepsilon_0 \\frac{A}{d}\\,\\epsilon''(T) + \\frac{A}{d}\\,\\sigma(T)$.\n    -   Resonator power balance: $P_{\\mathrm{in}} = \\tfrac{1}{2} V^2 \\left(G_{\\mathrm{c}} + G_{\\mathrm{d}}(T)\\right)$.\n    -   Absorbed power in the dielectric: $P_{\\mathrm{abs}}(T) = P_{\\mathrm{in}}\\,\\frac{G_{\\mathrm{d}}(T)}{G_{\\mathrm{c}} + G_{\\mathrm{d}}(T)}$.\n    -   Thermal steady-state energy balance: $P_{\\mathrm{abs}}(T) - h S \\left(T - T_{\\mathrm{amb}}\\right) = 0$.\n\n-   **Iterative procedure and stopping criterion:**\n    -   Energy residual: $r(T) = P_{\\mathrm{abs}}(T) - h S \\left(T - T_{\\mathrm{amb}}\\right)$.\n    -   Fixed-point iterative map: $T_{\\mathrm{new}} \\leftarrow T_{\\mathrm{amb}} + \\frac{P_{\\mathrm{abs}}(T_{\\mathrm{old}})}{h S}$.\n    -   Stopping criterion: $\\frac{\\left|r(T)\\right|}{P_{\\mathrm{in}}} \\le \\tau$.\n\n-   **Material property models:**\n    -   Conductivity: $\\sigma(T) = a_0 + a_1\\,(T - T_{\\mathrm{ref}}) + a_2\\,(T - T_{\\mathrm{ref}})^2$.\n    -   Imaginary part of relative permittivity: $\\epsilon''(T) = b_0 + b_1\\,(T - T_{\\mathrm{ref}}) + b_2\\,(T - T_{\\mathrm{ref}})^2$.\n    -   Reference temperature for polynomials: $T_{\\mathrm{ref}} = 293.15\\,\\mathrm{K}$.\n\n-   **Common constants and parameters:**\n    -   Vacuum permittivity: $\\varepsilon_0 = 8.854187817\\times 10^{-12}\\,\\mathrm{F/m}$.\n    -   Frequency: $f = 2.45\\times 10^{9}\\,\\mathrm{Hz}$.\n    -   Angular frequency: $\\omega = 2\\pi f$.\n    -   Real part of relative permittivity: $\\varepsilon' = 2.5$.\n    -   Plate area: $A = 1.0\\times 10^{-2}\\,\\mathrm{m}^2$.\n    -   Plate spacing: $d = 1.0\\times 10^{-2}\\,\\mathrm{m}$.\n    -   Convective surface area: $S = 2A$.\n    -   Ambient temperature: $T_{\\mathrm{amb}} = 293.15\\,\\mathrm{K}$.\n    -   Initial guess for temperature: $T_0 = T_{\\mathrm{amb}}$.\n    -   Convergence tolerance: $\\tau = 1.0\\times 10^{-8}$.\n    -   Maximum iterations: $N_{\\max} = 100000$.\n\n-   **Test Case A:**\n    -   $P_{\\mathrm{in}} = 200\\,\\mathrm{W}$, $G_{\\mathrm{c}} = 5.0\\times 10^{-3}\\,\\mathrm{S}$, $h = 20\\,\\mathrm{W/(m^2\\,K)}$.\n    -   $\\sigma(T)$ coeffs: $a_0 = 5.0\\times 10^{-5}$, $a_1 = 5.0\\times 10^{-7}$, $a_2 = 0$.\n    -   $\\epsilon''(T)$ coeffs: $b_0 = 2.0\\times 10^{-2}$, $b_1 = 1.5\\times 10^{-4}$, $b_2 = 0$.\n\n-   **Test Case B:**\n    -   $P_{\\mathrm{in}} = 10\\,\\mathrm{W}$, $G_{\\mathrm{c}} = 5.0\\times 10^{-3}\\,\\mathrm{S}$, $h = 10\\,\\mathrm{W/(m^2\\,K)}$.\n    -   $\\sigma(T)$ coeffs: $a_0 = 1.0\\times 10^{-6}$, $a_1 = 1.0\\times 10^{-8}$, $a_2 = 0$.\n    -   $\\epsilon''(T)$ coeffs: $b_0 = 5.0\\times 10^{-3}$, $b_1 = 2.0\\times 10^{-5}$, $b_2 = 0$.\n\n-   **Test Case C:**\n    -   $P_{\\mathrm{in}} = 500\\,\\mathrm{W}$, $G_{\\mathrm{c}} = 2.0\\times 10^{-2}\\,\\mathrm{S}$, $h = 20\\,\\mathrm{W/(m^2\\,K)}$.\n    -   $\\sigma(T)$ coeffs: $a_0 = 2.0\\times 10^{-4}$, $a_1 = 2.0\\times 10^{-7}$, $a_2 = 0$.\n    -   $\\epsilon''(T)$ coeffs: $b_0 = 3.0\\times 10^{-2}$, $b_1 = 1.0\\times 10^{-4}$, $b_2 = 0$.\n\n-   **Test Case D:**\n    -   $P_{\\mathrm{in}} = 200\\,\\mathrm{W}$, $G_{\\mathrm{c}} = 5.0\\times 10^{-3}\\,\\mathrm{S}$, $h = 100\\,\\mathrm{W/(m^2\\,K)}$.\n    -   $\\sigma(T)$ coeffs: $a_0 = 5.0\\times 10^{-5}$, $a_1 = 0$, $a_2 = 0$.\n    -   $\\epsilon''(T)$ coeffs: $b_0 = 2.0\\times 10^{-2}$, $b_1 = 0$, $b_2 = 0$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, deriving from Maxwell's equations and the principles of energy conservation. A simplified lumped-element model is used, which is a standard and valid approach for this type of analysis. The equations for power absorption and thermal balance are consistent and physically sound.\n\nThe problem is well-posed. It specifies a clear computational task: finding the root of the energy residual function $r(T) = 0$ using a fixed-point iteration. All necessary constants, material property models, initial conditions, and a clear stopping criterion are provided. The parameters given are physically plausible. The problem is objective, stated in formal mathematical language, and self-contained. There are no contradictions, ambiguities, or factual errors.\n\n### Step 3: Verdict and Action\nThe problem is valid. A reasoned solution will be provided.\n\nThe problem is to find the steady-state temperature $T$ that satisfies the thermal energy balance equation:\n$$\nP_{\\mathrm{abs}}(T) = h S (T - T_{\\mathrm{amb}})\n$$\nThis is a nonlinear root-finding problem for the function $r(T) = P_{\\mathrm{abs}}(T) - h S (T - T_{\\mathrm{amb}})$. The problem specifies using a fixed-point iteration method. The thermal balance equation can be rearranged into the form $T = g(T)$, suitable for fixed-point iteration:\n$$\nT = T_{\\mathrm{amb}} + \\frac{P_{\\mathrm{abs}}(T)}{h S}\n$$\nThis gives the iterative map:\n$$\nT_{k+1} = T_{\\mathrm{amb}} + \\frac{P_{\\mathrm{abs}}(T_k)}{h S}\n$$\nwhere $T_k$ is the temperature at iteration $k$. The fixed point of this iteration, where $T_{k+1} = T_k$, is the solution to the original energy balance equation.\n\nThe computational procedure is as follows:\nFirst, we establish functions to compute the temperature-dependent material properties and derived physical quantities. The conductivity $\\sigma(T)$ and the imaginary part of the relative permittivity $\\epsilon''(T)$ are given as quadratic polynomials in $(T - T_{\\mathrm{ref}})$:\n$$ \\sigma(T) = a_0 + a_1(T - T_{\\mathrm{ref}}) + a_2(T - T_{\\mathrm{ref}})^2 $$\n$$ \\epsilon''(T) = b_0 + b_1(T - T_{\\mathrm{ref}}) + b_2(T - T_{\\mathrm{ref}})^2 $$\nUsing these, the equivalent dielectric conductance $G_{\\mathrm{d}}(T)$ is calculated as:\n$$ G_{\\mathrm{d}}(T) = \\omega \\varepsilon_0 \\frac{A}{d}\\epsilon''(T) + \\frac{A}{d}\\sigma(T) $$\nwhere $\\omega = 2\\pi f$. The power absorbed by the sample, $P_{\\mathrm{abs}}(T)$, is then found using the power-divider relation:\n$$ P_{\\mathrm{abs}}(T) = P_{\\mathrm{in}}\\frac{G_{\\mathrm{d}}(T)}{G_{\\mathrm{c}} + G_{\\mathrm{d}}(T)} $$\nThe core of the solution is an iterative loop that implements the fixed-point method. The process for each test case is:\n$1$. Initialize the temperature to the ambient temperature, $T_0 = T_{\\mathrm{amb}}$.\n$2$. Begin the iteration loop, from $k=0$ up to a maximum of $N_{\\max}$ iterations.\n$3$. At each iteration $k$, using the current temperature $T_k$:\n    a. Calculate the energy residual $r(T_k) = P_{\\mathrm{abs}}(T_k) - h S (T_k - T_{\\mathrm{amb}})$.\n    b. Check the stopping criterion. The iteration is considered converged and terminates if the normalized residual is less than or equal to the tolerance $\\tau$:\n    $$ \\frac{|r(T_k)|}{P_{\\mathrm{in}}} \\le \\tau $$\n    c. If the condition is not met, calculate the next temperature estimate $T_{k+1}$ using the update rule:\n    $$ T_{k+1} = T_{\\mathrm{amb}} + \\frac{P_{\\mathrm{abs}}(T_k)}{h S} $$\n    d. The problem mentions the option of under-relaxation. A general update rule with a relaxation factor $\\alpha \\in (0, 1]$ would be $T_{k+1}^{\\text{relaxed}} = (1-\\alpha)T_k + \\alpha T_{k+1}$. For this problem, the iteration is stable with $\\alpha=1$ (no relaxation), so we simply set the next temperature for iteration $k+1$ to be $T_{k+1}$.\n$4$. If the loop completes without convergence, an error is raised. Otherwise, the final converged temperature is the result for that case.\n\nThis procedure is applied to each of the four test cases provided, using their specific sets of parameters. The final results are rounded to three decimal places and presented in the required format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the coupled electromagnetic-thermal problem for four test cases.\n    \"\"\"\n\n    # Define common constants and parameters from the problem statement.\n    EPS_0 = 8.854187817e-12  # Vacuum permittivity in F/m\n    F = 2.45e9                # Frequency in Hz\n    OMEGA = 2 * np.pi * F     # Angular frequency in rad/s\n    A = 1.0e-2                # Plate area in m^2\n    D = 1.0e-2                # Plate spacing in m\n    S = 2 * A                 # Convective surface area in m^2\n    T_AMB = 293.15            # Ambient temperature in K\n    T_REF = 293.15            # Reference temperature for polynomials in K\n    T0 = T_AMB                # Initial guess for temperature in K\n    TOL = 1.0e-8              # Convergence tolerance\n    N_MAX = 100000            # Maximum number of iterations\n    ALPHA = 1.0               # Under-relaxation factor (1.0 = no relaxation)\n\n    # Test cases as defined in the problem.\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"P_in\": 200.0, \"G_c\": 5.0e-3, \"h\": 20.0,\n            \"sigma_coeffs\": (5.0e-5, 5.0e-7, 0.0),\n            \"eps_im_coeffs\": (2.0e-2, 1.5e-4, 0.0)\n        },\n        {\n            \"name\": \"Case B\",\n            \"P_in\": 10.0, \"G_c\": 5.0e-3, \"h\": 10.0,\n            \"sigma_coeffs\": (1.0e-6, 1.0e-8, 0.0),\n            \"eps_im_coeffs\": (5.0e-3, 2.0e-5, 0.0)\n        },\n        {\n            \"name\": \"Case C\",\n            \"P_in\": 500.0, \"G_c\": 2.0e-2, \"h\": 20.0,\n            \"sigma_coeffs\": (2.0e-4, 2.0e-7, 0.0),\n            \"eps_im_coeffs\": (3.0e-2, 1.0e-4, 0.0)\n        },\n        {\n            \"name\": \"Case D\",\n            \"P_in\": 200.0, \"G_c\": 5.0e-3, \"h\": 100.0,\n            \"sigma_coeffs\": (5.0e-5, 0.0, 0.0),\n            \"eps_im_coeffs\": (2.0e-2, 0.0, 0.0)\n        }\n    ]\n\n    def run_simulation(case_params):\n        \"\"\"\n        Runs the fixed-point iteration for a single test case.\n        \"\"\"\n        P_in = case_params[\"P_in\"]\n        G_c = case_params[\"G_c\"]\n        h = case_params[\"h\"]\n        sigma_coeffs = case_params[\"sigma_coeffs\"]\n        eps_im_coeffs = case_params[\"eps_im_coeffs\"]\n\n        def sigma_T(T):\n            \"\"\"Calculates electrical conductivity sigma(T).\"\"\"\n            delta_T = T - T_REF\n            a0, a1, a2 = sigma_coeffs\n            return a0 + a1 * delta_T + a2 * delta_T**2\n\n        def eps_im_T(T):\n            \"\"\"Calculates imaginary relative permittivity epsilon''(T).\"\"\"\n            delta_T = T - T_REF\n            b0, b1, b2 = eps_im_coeffs\n            return b0 + b1 * delta_T + b2 * delta_T**2\n\n        def Gd_T(T):\n            \"\"\"Calculates equivalent dielectric conductance G_d(T).\"\"\"\n            sigma = sigma_T(T)\n            eps_im = eps_im_T(T)\n            return OMEGA * EPS_0 * (A / D) * eps_im + (A / D) * sigma\n\n        def Pabs_T(T):\n            \"\"\"Calculates absorbed electromagnetic power P_abs(T).\"\"\"\n            Gd = Gd_T(T)\n            # Handle case where both Gc and Gd are zero to avoid division by zero.\n            if G_c + Gd == 0:\n                return 0.0\n            return P_in * Gd / (G_c + Gd)\n\n        T = T0\n        for _ in range(N_MAX):\n            P_abs_current = Pabs_T(T)\n            \n            # Calculate the energy residual at the current temperature T\n            r = P_abs_current - h * S * (T - T_AMB)\n            \n            # Check for convergence using the normalized residual\n            # Handle P_in = 0 case to avoid division by zero.\n            if P_in == 0:\n                norm_res = np.abs(r)\n            else:\n                norm_res = np.abs(r) / P_in\n            \n            if norm_res = TOL:\n                return T\n\n            # Compute the next temperature iterate using the fixed-point map\n            T_next = T_AMB + P_abs_current / (h * S)\n            \n            # Apply under-relaxation and update the temperature for the next iteration\n            T = (1 - ALPHA) * T + ALPHA * T_next\n        \n        # If the loop finishes without converging, raise an error.\n        raise RuntimeError(f\"{case_params['name']} did not converge within {N_MAX} iterations.\")\n\n    results = []\n    for case in test_cases:\n        converged_T = run_simulation(case)\n        results.append(np.round(converged_T, 3))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3304789"}, {"introduction": "Transient coupled simulations often face a significant computational challenge: the vastly different time scales of the physics involved, where electromagnetic effects can be orders of magnitude faster than thermal changes. This advanced practice introduces a multi-rate operator-splitting algorithm, a powerful technique to improve efficiency by using different time steps for the fast (EM) and slow (thermal) subsystems. You will quantify the accuracy of this splitting method by comparing it against a high-fidelity monolithic solver and investigate how the coupling nonlinearity impacts the error [@problem_id:3304854].", "problem": "Consider a lumped, one-dimensional electromagnetic–thermal coupling model where an electrically conductive medium with temperature-dependent conductivity is driven by a spatially uniform, time-independent electric field. The aim is to design and analyze a multi-rate, operator-splitting algorithm in which the electromagnetic subsystem is advanced with a smaller time step than the thermal subsystem, and to quantify the effect of the thermal nonlinearity on the splitting error.\n\nAssume the following coupled system of ordinary differential equations (ODEs) for the electric current density and temperature:\n1. Electromagnetic subsystem (Drude-type conduction relaxation):\n$$\\tau \\,\\dfrac{dJ}{dt} + J = \\sigma\\!\\left(T\\right)\\,E_{0},$$\nwhere $J$ is the current density, $E_{0}$ is a constant applied electric field, $\\tau$ is a positive relaxation time, and $\\sigma\\!\\left(T\\right)$ is the electrical conductivity as a function of temperature.\n\n2. Thermal energy balance (lumped capacity with linear cooling to an ambient temperature $T_{0}$):\n$$C \\,\\dfrac{dT}{dt} = J\\,E_{0} - H \\,\\left(T - T_{0}\\right),$$\nwhere $T$ is the temperature, $C$ is the volumetric heat capacity, and $H$ is a positive heat loss coefficient.\n\nAssume a linear temperature dependence of conductivity about $T_{0}$:\n$$\\sigma\\!\\left(T\\right) = \\sigma_{0} + g \\,\\left(T - T_{0}\\right),$$\nwhere $\\sigma_{0}  0$ is the reference conductivity at $T_{0}$ and $g = \\left.\\dfrac{d\\sigma}{dT}\\right|_{T_{0}}$ is the thermal nonlinearity parameter.\n\nInitial conditions are\n$$J(0) = 0,\\quad T(0) = T_{0}.$$\n\nFundamental base: Use conservation of charge and the Drude current relaxation model for the electromagnetic subsystem, Joule heating $p = J\\,E_{0}$ for electromagnetic-to-thermal coupling, and lumped energy balance for the thermal subsystem. No other constitutive shortcuts are permitted beyond these definitions.\n\nAlgorithmic task:\n- Implement a monolithic high-accuracy reference integrator for the coupled system using the classical fourth-order Runge–Kutta method with a sufficiently small, uniform time step $h_{\\mathrm{ref}}$.\n- Implement a first-order Lie operator-splitting, multi-rate algorithm in which:\n  - The thermal state $T$ is frozen within each thermal macro-step of size $\\Delta t_{T}$.\n  - The electromagnetic subsystem is subcycled with a uniform micro-step $\\Delta t_{\\mathrm{EM}}$ such that an integer number $m = \\Delta t_{T}/\\Delta t_{\\mathrm{EM}}$ of electromagnetic steps fit into one thermal step.\n  - Within each macro-step, the electromagnetic subsystem is advanced from $t^{n}$ to $t^{n+1} = t^{n} + \\Delta t_{T}$ using $m$ explicit Euler micro-steps for $J$ with $T$ held fixed at $T^{n}$.\n  - The temperature is then advanced by one explicit Euler step using the macro-step-averaged Joule heating, defined as the arithmetic mean of $J\\,E_{0}$ over the $m$ micro-steps.\n\nNumerical parameters, units, and horizon:\n- Use $E_{0} = 10^{3}\\,\\mathrm{V/m}$, $\\tau = 10^{-6}\\,\\mathrm{s}$, $\\sigma_{0} = 10^{4}\\,\\mathrm{S/m}$, $C = 3 \\times 10^{6}\\,\\mathrm{J/(m^{3}\\,K)}$, $H = 10^{4}\\,\\mathrm{W/(m^{3}\\,K)}$, and $T_{0} = 300\\,\\mathrm{K}$.\n- Use a total simulation time $T_{\\mathrm{end}} = 10^{-4}\\,\\mathrm{s}$.\n- Use $\\Delta t_{\\mathrm{EM}} = 10^{-7}\\,\\mathrm{s}$, $\\Delta t_{T} = 5 \\times 10^{-6}\\,\\mathrm{s}$, and $h_{\\mathrm{ref}} = 5 \\times 10^{-9}\\,\\mathrm{s}$. Ensure that $m = \\Delta t_{T}/\\Delta t_{\\mathrm{EM}}$ is an integer and that $\\Delta t_{T}/h_{\\mathrm{ref}}$ is also an integer so that macro-step endpoints align with the reference time grid exactly.\n\nTest suite:\nEvaluate the algorithm for the following values of the thermal nonlinearity parameter $g = \\left.\\dfrac{d\\sigma}{dT}\\right|_{T_{0}}$ (in $\\mathrm{S/(m\\,K)}$):\n- Case A (happy path): $g = 10$.\n- Case B (stronger nonlinearity): $g = 50$.\n- Case C (no thermal nonlinearity; boundary case): $g = 0$.\n- Case D (negative slope; edge case): $g = -10$.\n\nError metric and units:\n- At each thermal macro-step endpoint $t^{n}$, compute the difference between the splitting solution $T_{\\mathrm{split}}\\!\\left(t^{n}\\right)$ and the reference solution $T_{\\mathrm{ref}}\\!\\left(t^{n}\\right)$.\n- Report the root-mean-square error over all macro-step endpoints:\n$$\\varepsilon_{T} = \\sqrt{\\dfrac{1}{N}\\sum_{n=1}^{N}\\left(T_{\\mathrm{split}}\\!\\left(t^{n}\\right) - T_{\\mathrm{ref}}\\!\\left(t^{n}\\right)\\right)^{2}},$$\nwhere $N$ is the number of thermal macro-steps. Express $\\varepsilon_{T}$ in kelvin.\n\nFinal output specification:\n- Your program must compute $\\varepsilon_{T}$ for each of the four specified values of $g$.\n- Your program should produce a single line of output containing the four errors as a comma-separated list enclosed in square brackets in the order of the cases $[A,B,C,D]$, with each value printed in scientific notation with six significant figures, in kelvin. For example, the format must be exactly like\n$[\\text{float}_A,\\text{float}_B,\\text{float}_C,\\text{float}_D]$,\nwith no additional text.\n\nScientific realism and scope:\n- The model, parameters, and algorithms must be physically plausible and numerically stable for the specified settings.\n- Do not use or assume any closed-form expression for the splitting error; all error values must be obtained by numerical computation as described.", "solution": "The problem is valid as it presents a well-posed, scientifically grounded initial value problem in computational physics. It defines a clear, non-trivial task: to implement and compare a monolithic high-order integrator against a multi-rate operator-splitting scheme for a coupled electromagnetic-thermal system, and to quantify the splitting error as a function of the system's nonlinearity. All parameters, initial conditions, and numerical procedures are explicitly and consistently defined.\n\nThe physical system is described by a coupled pair of ordinary differential equations (ODEs). The first governs the evolution of the electric current density, $J$, and is based on a Drude-like relaxation model. The second describes the evolution of the temperature, $T$, based on a lumped-capacity thermal model that includes Joule heating and linear cooling.\n\nThe system of ODEs is given by:\n$$ \\tau \\,\\frac{dJ}{dt} + J = \\sigma(T)\\,E_{0} $$\n$$ C \\,\\frac{dT}{dt} = J\\,E_{0} - H \\,(T - T_{0}) $$\nThese can be rewritten in standard state-space form, $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(t, \\mathbf{y})$, with the state vector $\\mathbf{y}(t) = [J(t), T(t)]^T$:\n$$ \\frac{dJ}{dt} = \\frac{1}{\\tau} \\left( \\sigma(T) E_0 - J \\right) $$\n$$ \\frac{dT}{dt} = \\frac{1}{C} \\left( J E_0 - H (T - T_0) \\right) $$\nThe electrical conductivity, $\\sigma$, is a linear function of temperature:\n$$ \\sigma(T) = \\sigma_0 + g (T - T_0) $$\nThe system is subject to the initial conditions $J(0) = 0$ and $T(0) = T_0$. The parameter $g$ introduces a two-way coupling between the electromagnetic and thermal subsystems. If $g=0$, the coupling is one-way: $J$ influences $T$ via Joule heating, but $T$ does not influence $J$.\n\nA high-accuracy reference solution is computed using the classical fourth-order Runge-Kutta (RK4) method. This monolithic scheme advances both state variables, $J$ and $T$, simultaneously with a small time step $h_{\\mathrm{ref}}$. For a state vector $\\mathbf{y}_n$ at time $t_n$, the state at $t_{n+1} = t_n + h$ is found by:\n$$ \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{h}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4) $$\nwhere the stages $\\mathbf{k}_i$ are evaluations of the right-hand side function $\\mathbf{f}(\\mathbf{y})$:\n$$ \\mathbf{k}_1 = \\mathbf{f}(t_n, \\mathbf{y}_n) $$\n$$ \\mathbf{k}_2 = \\mathbf{f}(t_n + h/2, \\mathbf{y}_n + h/2 \\cdot \\mathbf{k}_1) $$\n$$ \\mathbf{k}_3 = \\mathbf{f}(t_n + h/2, \\mathbf{y}_n + h/2 \\cdot \\mathbf{k}_2) $$\n$$ \\mathbf{k}_4 = \\mathbf{f}(t_n + h, \\mathbf{y}_n + h \\cdot \\mathbf{k}_3) $$\nThis method is applied with a very small step size $h = h_{\\mathrm{ref}}$ to generate a solution, $(J_{\\mathrm{ref}}(t), T_{\\mathrm{ref}}(t))$, that is considered the ground truth for error analysis.\n\nThe multi-rate algorithm employs a first-order Lie operator splitting scheme. The full system evolution operator is split into an electromagnetic part and a thermal part. The simulation proceeds in macro-steps of duration $\\Delta t_T$. Within each macro-step from $t^n$ to $t^{n+1} = t^n + \\Delta t_T$, the following sequence is executed:\n\n1.  **Electromagnetic Sub-problem**: The thermal state is frozen at its value from the beginning of the macro-step, $T(t) \\approx T^n$. The electromagnetic ODE, now a linear equation with a constant source term, is solved over the interval $[t^n, t^{n+1}]$:\n    $$ \\frac{dJ}{dt} = \\frac{1}{\\tau} \\left( (\\sigma_0 + g(T^n - T_0)) E_0 - J \\right) $$\n    This is advanced using $m = \\Delta t_T / \\Delta t_{\\mathrm{EM}}$ micro-steps of size $\\Delta t_{\\mathrm{EM}}$ with the first-order explicit Euler method. Starting with $j_0 = J^n$, the update for each micro-step is:\n    $$ j_{k+1} = j_k + \\Delta t_{\\mathrm{EM}} \\cdot \\frac{1}{\\tau} \\left( \\sigma(T^n) E_0 - j_k \\right) \\quad \\text{for } k = 0, \\dots, m-1 $$\n    The final current density for the macro-step is $J^{n+1} = j_m$.\n\n2.  **Coupling and Thermal Sub-problem**: The Joule heating term, $J E_0$, for the thermal update is calculated by averaging over the $m$ intermediate current density values computed in the micro-steps:\n    $$ \\langle p \\rangle^n = \\langle J E_0 \\rangle = \\frac{E_0}{m} \\sum_{k=1}^{m} j_k $$\n    The temperature is then advanced by a single explicit Euler step of size $\\Delta t_T$, using this averaged heating term:\n    $$ T^{n+1} = T^n + \\frac{\\Delta t_T}{C} \\left( \\langle p \\rangle^n - H (T^n - T_0) \\right) $$\n\nThis splitting scheme introduces an error, primarily because freezing the temperature $T^n$ during the electromagnetic sub-cycling ignores the change in conductivity that would occur in the true coupled system. The magnitude of this error is expected to correlate with the nonlinearity parameter $g$.\n\nTo quantify this splitting error, the temperature solution from the splitting algorithm, $T_{\\mathrm{split}}(t^n) = T^n$, is compared to the reference solution, $T_{\\mathrm{ref}}(t^n)$, at each macro-step endpoint $t^n$ for $n=1, \\dots, N$, where $N=T_{\\mathrm{end}}/\\Delta t_T$ is the total number of macro-steps. The root-mean-square (RMS) error is computed as:\n$$ \\varepsilon_{T} = \\sqrt{\\frac{1}{N}\\sum_{n=1}^{N}\\left(T_{\\mathrm{split}}\\!\\left(t^{n}\\right) - T_{\\mathrm{ref}}\\!\\left(t^{n}\\right)\\right)^{2}} $$\nThis metric provides a single value representing the average deviation of the splitting solution from the reference solution over the simulation horizon. The computation is repeated for four different values of $g$ to assess the impact of thermal nonlinearity on the algorithm's accuracy.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the coupled electromagnetic-thermal problem using a monolithic RK4\n    method and a multi-rate splitting method, then computes the RMS error\n    between them for different thermal nonlinearity parameters.\n    \"\"\"\n\n    # Numerical parameters and constants\n    E0 = 1.0e3         # V/m\n    tau = 1.0e-6       # s\n    sigma0 = 1.0e4     # S/m\n    C = 3.0e6          # J/(m^3 K)\n    H = 1.0e4          # W/(m^3 K)\n    T0 = 300.0         # K\n\n    # Simulation horizon and time steps\n    T_end = 1.0e-4     # s\n    dt_EM = 1.0e-7     # s\n    dt_T = 5.0e-6      # s\n    h_ref = 5.0e-9     # s\n\n    # Initial conditions\n    y0 = np.array([0.0, T0])  # [J(0), T(0)]\n\n    # Test suite for the thermal nonlinearity parameter g\n    test_cases = [10.0, 50.0, 0.0, -10.0]  # Cases A, B, C, D\n\n    # Store results\n    rms_errors = []\n\n    def rhs(t, y, g):\n        \"\"\"\n        Right-hand side of the coupled ODE system dy/dt = f(t, y).\n        y = [J, T]\n        \"\"\"\n        J, T = y\n        sigma = sigma0 + g * (T - T0)\n        dJ_dt = (sigma * E0 - J) / tau\n        dT_dt = (J * E0 - H * (T - T0)) / C\n        return np.array([dJ_dt, dT_dt])\n\n    def solve_rk4(g):\n        \"\"\"\n        Solves the ODE system using the classical 4th-order Runge-Kutta method.\n        \"\"\"\n        num_steps = int(T_end / h_ref)\n        t_points = np.linspace(0, T_end, num_steps + 1)\n        y_solution = np.zeros((num_steps + 1, 2))\n        y_solution[0] = y0\n        y = y0.copy()\n\n        for i in range(num_steps):\n            t = t_points[i]\n            k1 = rhs(t, y, g)\n            k2 = rhs(t + 0.5 * h_ref, y + 0.5 * h_ref * k1, g)\n            k3 = rhs(t + 0.5 * h_ref, y + 0.5 * h_ref * k2, g)\n            k4 = rhs(t + h_ref, y + h_ref * k3, g)\n            y += (h_ref / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n            y_solution[i + 1] = y\n        \n        return t_points, y_solution\n\n    def solve_splitting(g):\n        \"\"\"\n        Solves the ODE system using the specified multi-rate Lie splitting method.\n        \"\"\"\n        num_macro_steps = int(T_end / dt_T)\n        m = int(dt_T / dt_EM)\n        \n        t_points = np.linspace(0, T_end, num_macro_steps + 1)\n        y_solution = np.zeros((num_macro_steps + 1, 2))\n        y_solution[0] = y0\n        \n        J_n, T_n = y0\n\n        for i in range(num_macro_steps):\n            # Freeze T at the start of the macro-step\n            sigma_n = sigma0 + g * (T_n - T0)\n            \n            # --- Electromagnetic sub-problem (m micro-steps) ---\n            j_k = J_n\n            joule_heating_sum = 0.0\n            for _ in range(m):\n                j_k_plus_1 = j_k + dt_EM * (sigma_n * E0 - j_k) / tau\n                joule_heating_sum += j_k_plus_1 * E0\n                j_k = j_k_plus_1\n            \n            # J at the end of the macro-step\n            J_n_plus_1 = j_k\n\n            # --- Thermal sub-problem (1 macro-step) ---\n            avg_joule_heating = joule_heating_sum / m\n            T_n_plus_1 = T_n + dt_T * (avg_joule_heating - H * (T_n - T0)) / C\n\n            # Update state for the next macro-step\n            J_n, T_n = J_n_plus_1, T_n_plus_1\n            y_solution[i + 1] = [J_n, T_n]\n\n        return t_points, y_solution\n\n    for g_val in test_cases:\n        # 1. Compute high-accuracy reference solution\n        t_ref, y_ref = solve_rk4(g_val)\n        T_ref = y_ref[:, 1]\n        \n        # 2. Compute splitting solution\n        t_split, y_split = solve_splitting(g_val)\n        T_split = y_split[:, 1]\n\n        # 3. Sample reference solution at macro-step endpoints\n        ref_sample_indices = np.round(t_split / h_ref).astype(int)\n        T_ref_sampled = T_ref[ref_sample_indices]\n\n        # 4. Calculate RMS error\n        # Sum is from n=1 to N, so we compare points from the end of the first step onwards\n        diffs = T_split[1:] - T_ref_sampled[1:]\n        rms_error = np.sqrt(np.mean(diffs**2))\n        rms_errors.append(rms_error)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{err:.6e}' for err in rms_errors)}]\")\n\nsolve()\n```", "id": "3304854"}]}