{"hands_on_practices": [{"introduction": "Before we can model a lumped element, we must first learn how to accurately extract physical quantities like voltage from the discrete FDTD grid. A port's voltage is defined by a line integral of the electric field, which is approximated on a Yee grid by a \"staircase\" sum along grid edges. This exercise guides you through the process of deriving and applying a calibration factor to correct for the geometric discrepancy between this discrete sum and the true continuous integral [@problem_id:3327462]. Mastering this practice is essential for understanding how continuous physical concepts are translated into and measured within a discrete simulation space.", "problem": "In the Finite-Difference Time-Domain (FDTD) method using the Yee grid for two-dimensional transverse electromagnetic fields in vacuum, a lumped circuit port is often incorporated by extracting a voltage as a discrete line integral of the electric field along a prescribed contour that approximates the physical port. To calibrate this extraction so that the discrete sum equals the continuum line integral, consider the following uniform-field test.\n\nAssume the electric field is uniform in space and time-harmonic with negligible spatial variation across the port region, so that the instantaneous field can be treated as constant over the calibration contour. Let the uniform field be $\\mathbf{E}_{0} = E_{0}(\\cos\\phi\\,\\hat{\\mathbf{x}} + \\sin\\phi\\,\\hat{\\mathbf{y}})$, where $E_{0}$ is the magnitude and $\\phi$ is the angle the field makes with the $x$-axis. Let the straight port segment have Euclidean length $L$ and be oriented at angle $\\theta$ relative to the $x$-axis. The analytic potential difference across the port is the continuum line integral $V_{\\text{analytic}} = \\displaystyle \\int_{\\ell} \\mathbf{E}_{0}\\cdot d\\boldsymbol{\\ell}$.\n\nOn the Yee grid, let the spatial steps be $\\Delta x = \\Delta y = 1.00\\ \\text{mm}$. The straight port segment has length $L = 11.2\\ \\text{mm}$ and orientation $\\theta = 35^{\\circ}$. The uniform field has magnitude $E_{0} = 4.00\\ \\text{V/m}$ and direction $\\phi = 13^{\\circ}$. The discrete contour that approximates the straight port is constructed from grid-aligned edges and consists of $m = 9$ segments along $+\\hat{\\mathbf{x}}$ and $n = 6$ segments along $+\\hat{\\mathbf{y}}$. The uncalibrated discrete voltage extraction is\n$$\n\\tilde{V} = \\sum_{\\text{x-edges}} E_{x}\\,\\Delta x + \\sum_{\\text{y-edges}} E_{y}\\,\\Delta y = m\\,\\Delta x\\,E_{x} + n\\,\\Delta y\\,E_{y},\n$$\nwith $E_{x} = E_{0}\\cos\\phi$ and $E_{y} = E_{0}\\sin\\phi$.\n\nDefine a dimensionless calibration constant $C$ such that the calibrated discrete voltage $V_{\\text{cal}} = C\\,\\tilde{V}$ equals the analytic line integral $V_{\\text{analytic}}$ for this uniform-field test. Starting from the fundamental relationship between potential difference and the line integral of the electric field, and the Yee-grid discrete representation described above, derive an expression for $C$ and compute its numerical value for the parameters given. Use angles in degrees and express the final $C$ as a dimensionless number. Round your answer to four significant figures. Finally, verify within your derivation that $C\\,\\tilde{V} = V_{\\text{analytic}}$ under the stated conditions, using the provided $E_{0}$ only where necessary for that verification; the reported $C$ must be independent of $E_{0}$.", "solution": "The problem requires the derivation and calculation of a dimensionless calibration constant, $C$, used to equate a discrete voltage measurement on a Finite-Difference Time-Domain (FDTD) grid with its corresponding continuous, analytic value.\n\nFirst, we determine the analytic potential difference, $V_{\\text{analytic}}$, which is defined as the line integral of the electric field along the physical port's contour. The electric field is uniform and given by $\\mathbf{E}_{0} = E_{0}(\\cos\\phi\\,\\hat{\\mathbf{x}} + \\sin\\phi\\,\\hat{\\mathbf{y}})$. The port is a straight line segment of Euclidean length $L$ at an angle $\\theta$ with respect to the $x$-axis. This path can be represented by a vector $\\boldsymbol{\\ell} = L(\\cos\\theta\\,\\hat{\\mathbf{x}} + \\sin\\theta\\,\\hat{\\mathbf{y}})$.\n\nSince the electric field $\\mathbf{E}_{0}$ is uniform (constant in space), the line integral simplifies to the dot product of the field vector and the path vector:\n$$V_{\\text{analytic}} = \\int_{\\ell} \\mathbf{E}_{0}\\cdot d\\boldsymbol{\\ell} = \\mathbf{E}_{0} \\cdot \\int_{\\ell} d\\boldsymbol{\\ell} = \\mathbf{E}_{0} \\cdot \\boldsymbol{\\ell}$$\nSubstituting the vector expressions for $\\mathbf{E}_{0}$ and $\\boldsymbol{\\ell}$:\n$$V_{\\text{analytic}} = \\left( E_{0}(\\cos\\phi\\,\\hat{\\mathbf{x}} + \\sin\\phi\\,\\hat{\\mathbf{y}}) \\right) \\cdot \\left( L(\\cos\\theta\\,\\hat{\\mathbf{x}} + \\sin\\theta\\,\\hat{\\mathbf{y}}) \\right)$$\nEvaluating the dot product yields:\n$$V_{\\text{analytic}} = E_{0}L(\\cos\\phi\\cos\\theta + \\sin\\phi\\sin\\theta)$$\nUsing the trigonometric identity for the cosine of the difference of two angles, $\\cos(\\theta-\\phi) = \\cos\\theta\\cos\\phi + \\sin\\theta\\sin\\phi$, we obtain a compact expression for the analytic voltage:\n$$V_{\\text{analytic}} = E_{0}L\\cos(\\theta - \\phi)$$\n\nNext, we formulate the uncalibrated discrete voltage, $\\tilde{V}$. This is calculated by summing the potential drops along the grid-aligned segments that approximate the port. The discrete path consists of $m$ segments of length $\\Delta x$ in the $+\\hat{\\mathbf{x}}$ direction and $n$ segments of length $\\Delta y$ in the $+\\hat{\\mathbf{y}}$ direction. The uncalibrated voltage is given as:\n$$\\tilde{V} = \\sum_{\\text{x-edges}} E_{x}\\,\\Delta x + \\sum_{\\text{y-edges}} E_{y}\\,\\Delta y$$\nFor a uniform field with components $E_{x} = E_{0}\\cos\\phi$ and $E_{y} = E_{0}\\sin\\phi$, this sum simplifies to:\n$$\\tilde{V} = m\\,\\Delta x\\,E_{x} + n\\,\\Delta y\\,E_{y} = m\\,\\Delta x\\,(E_{0}\\cos\\phi) + n\\,\\Delta y\\,(E_{0}\\sin\\phi)$$\nFactoring out the electric field magnitude $E_{0}$:\n$$\\tilde{V} = E_{0} (m\\,\\Delta x\\,\\cos\\phi + n\\,\\Delta y\\,\\sin\\phi)$$\n\nThe calibration constant $C$ is defined by the condition that the calibrated discrete voltage, $V_{\\text{cal}} = C\\,\\tilde{V}$, equals the analytic voltage, $V_{\\text{analytic}}$.\n$$C\\,\\tilde{V} = V_{\\text{analytic}}$$\nWe can now solve for $C$ by substituting the expressions for $V_{\\text{analytic}}$ and $\\tilde{V}$:\n$$C = \\frac{V_{\\text{analytic}}}{\\tilde{V}} = \\frac{E_{0}L\\cos(\\theta - \\phi)}{E_{0} (m\\,\\Delta x\\,\\cos\\phi + n\\,\\Delta y\\,\\sin\\phi)}$$\nAs required, the electric field magnitude $E_{0}$ cancels, showing that $C$ is independent of the field strength:\n$$C = \\frac{L\\cos(\\theta - \\phi)}{m\\,\\Delta x\\,\\cos\\phi + n\\,\\Delta y\\,\\sin\\phi}$$\nThis is the symbolic expression for the calibration constant. This derivation inherently satisfies the verification requirement, as multiplying this expression for $C$ by $\\tilde{V}$ trivially recovers the expression for $V_{\\text{analytic}}$.\n\nFinally, we compute the numerical value of $C$ using the provided parameters:\n$L = 11.2\\ \\text{mm}$\n$\\theta = 35^{\\circ}$\n$\\phi = 13^{\\circ}$\n$m = 9$\n$n = 6$\n$\\Delta x = 1.00\\ \\text{mm}$\n$\\Delta y = 1.00\\ \\text{mm}$\n\nSince the units of length (mm) are present in both the numerator (from $L$) and the denominator (from $\\Delta x$ and $\\Delta y$), they cancel, making $C$ dimensionless.\n$$C = \\frac{11.2 \\cos(35^{\\circ} - 13^{\\circ})}{9(1.00)\\cos(13^{\\circ}) + 6(1.00)\\sin(13^{\\circ})}$$\n$$C = \\frac{11.2 \\cos(22^{\\circ})}{9\\cos(13^{\\circ}) + 6\\sin(13^{\\circ})}$$\nWe evaluate the trigonometric functions:\n$\\cos(22^{\\circ}) \\approx 0.92718385$\n$\\cos(13^{\\circ}) \\approx 0.97437006$\n$\\sin(13^{\\circ}) \\approx 0.22495105$\nSubstituting these into the expression for $C$:\n$$C \\approx \\frac{11.2 \\times 0.92718385}{9 \\times 0.97437006 + 6 \\times 0.22495105}$$\n$$C \\approx \\frac{10.3844591}{8.7693305 + 1.3497063}$$\n$$C \\approx \\frac{10.3844591}{10.1190368}$$\n$$C \\approx 1.02623049$$\nRounding the result to four significant figures gives the final value for the calibration constant.", "answer": "$$\\boxed{1.026}$$", "id": "3327462"}, {"introduction": "Once we can reliably measure voltage, the next challenge is to enforce the constitutive relationship of the lumped element within the FDTD time-stepping algorithm. This practice involves implementing the discrete-time update equations that govern the voltage-current relationship for a series resistor-capacitor (RC) circuit. By simulating the circuit's response and performing a Fourier analysis, you will verify that the numerical model correctly reproduces the element's theoretical frequency-domain impedance [@problem_id:3327488]. This hands-on coding exercise provides a crucial validation step for any FDTD implementation, building confidence in the simulation's physical accuracy.", "problem": "Consider a one-dimensional Transverse Electromagnetic (TEM) line discretized by the Finite-Difference Time-Domain (FDTD) method, and the incorporation of a single series lumped element at one discrete link. The objective is to compute the input impedance $Z_{\\text{in}}(\\omega)$ of a series connection of a resistor and a capacitor, and to verify its agreement with the continuous-time expression $Z(\\omega) = R + \\frac{1}{j \\omega C}$ within the limits of the time discretization. The context is computational electromagnetics, and the analysis must start from first principles and proceed to a discrete-time implementation suitable for FDTD time-stepping.\n\nBegin with the fundamental laws. Maxwell's equations in differential form imply Ampere-Maxwell law,\n$$\n\\nabla \\times \\mathbf{H} = \\mathbf{J} + \\frac{\\partial \\mathbf{D}}{\\partial t},\n$$\nwhere $\\mathbf{J}$ is the current density and $\\mathbf{D} = \\epsilon \\mathbf{E}$ for a linear isotropic medium with permittivity $\\epsilon$. In a one-dimensional TEM line, these reduce to the Telegrapher relations, which themselves arise from the integral forms of Faraday's law and Ampere-Maxwell law. In the Yee-staggered time-stepping of Finite-Difference Time-Domain (FDTD), the electric field-like quantity is evaluated at integer time indices and the magnetic field-like quantity at half-integer time indices. A lumped series element inserted across a discrete gap of length $\\ell$ modifies the local current in Ampere's update by introducing a concentrated lumped current term $I(t)$, such that the discrete current density contribution is $J_{\\text{lumped}}(t) = \\frac{I(t)}{A}$ localized at the gap cross-sectional area $A$, and the gap voltage obeys a Kirchhoff Voltage Law across the series elements.\n\nFor a series resistor $R$ and capacitor $C$, the instantaneous voltage across the lumped element is\n$$\nv(t) = v_R(t) + v_C(t), \\quad v_R(t) = R i(t), \\quad i_C(t) = C \\frac{\\mathrm{d} v_C(t)}{\\mathrm{d} t},\n$$\nwhere $i(t)$ is the lumped current through the series branch, $v_R(t)$ is the voltage across the resistor, and $v_C(t)$ is the voltage across the capacitor. In the FDTD staggering, define $v^n$ at integer time index $n$ and $i^{n+\\frac{1}{2}}$ and $v_C^{n+\\frac{1}{2}}$ at half-integer time indices. Using the backward-Euler discretization consistent with implicit time integration for the capacitor,\n$$\nv_C^{n+\\frac{1}{2}} = v_C^{n-\\frac{1}{2}} + \\frac{\\Delta t}{C} i^{n+\\frac{1}{2}},\n$$\nand the series voltage relation\n$$\nv^n = R i^{n+\\frac{1}{2}} + v_C^{n+\\frac{1}{2}},\n$$\nsolving for $i^{n+\\frac{1}{2}}$ gives the discrete-time update\n$$\ni^{n+\\frac{1}{2}} = \\frac{v^n - v_C^{n-\\frac{1}{2}}}{R + \\frac{\\Delta t}{C}}.\n$$\nThis $i^{n+\\frac{1}{2}}$ is the lumped current that would be subtracted from the curl term in Ampere's update in a full electromagnetic FDTD formulation via $J_{\\text{lumped}} = I/A$. For the present purpose of impedance computation, we treat $v^n$ as an externally applied sinusoidal gap voltage and compute the resulting current via the above recursion.\n\nThe input impedance $Z_{\\text{in}}(\\omega)$ is defined in the frequency domain as\n$$\nZ_{\\text{in}}(\\omega) = \\frac{V(\\omega)}{I(\\omega)},\n$$\nwhere $V(\\omega)$ and $I(\\omega)$ are the Fourier transforms of the gap voltage $v(t)$ and the lumped current $i(t)$. For simulation on a discrete-time grid with sampling interval $\\Delta t$, the Discrete Fourier Transform (DFT) coefficient at bin index $k$ for a block of $N$ samples is\n$$\nX_k = \\sum_{n=0}^{N-1} x^n \\, e^{-j \\frac{2\\pi k n}{N}},\n$$\nand the angular frequency associated with bin $k$ is\n$$\n\\omega_k = \\frac{2 \\pi k}{N \\Delta t}.\n$$\nIf the excitation $v^n$ is sinusoidal at $\\omega_k$, the ratio\n$$\nZ_{\\text{in}}(\\omega_k) \\approx \\frac{V_k}{I_k}\n$$\napproximates the input impedance. In continuous time, the series impedance is $Z(\\omega) = R + \\frac{1}{j \\omega C}$. In discrete time with backward Euler, the effective discrete capacitor impedance is\n$$\nZ_C^{\\text{BE}}(\\omega) = \\frac{\\Delta t}{C} \\cdot \\frac{1}{1 - e^{-j \\omega \\Delta t}},\n$$\nand the series discrete-time impedance is $Z^{\\text{BE}}(\\omega) = R + Z_C^{\\text{BE}}(\\omega)$. As $\\omega \\Delta t \\to 0$, the backward-Euler approximation approaches the continuous-time limit $Z(\\omega) = R + \\frac{1}{j \\omega C}$.\n\nYour task is to implement the discrete-time update above to compute $Z_{\\text{in}}(\\omega_k)$ numerically for a set of test cases by driving the lumped series branch with a sinusoidal $v^n$ at a specified bin index $k$ for a block of $N$ samples. Use a burn-in of sufficient duration to suppress transients, then compute $V_k$ and $I_k$ on the last $N$ samples and form $Z_{\\text{in}}(\\omega_k) = \\frac{V_k}{I_k}$. Compare the numerical $Z_{\\text{in}}(\\omega_k)$ with the continuous-time analytic expression $Z(\\omega_k) = R + \\frac{1}{j \\omega_k C}$ by reporting the relative error\n$$\n\\varepsilon = \\frac{\\left| Z_{\\text{in}}(\\omega_k) - Z(\\omega_k) \\right|}{\\left| Z(\\omega_k) \\right|}.\n$$\n\nUnits and numerical specification: Use resistance $R$ in ohms, capacitance $C$ in farads, time step $\\Delta t$ in seconds, angular frequency $\\omega_k$ in radians per second. Express the final outputs as dimensionless floats for $\\varepsilon$.\n\nTest suite: For each test case, parameters are $(R, C, \\Delta t, N, k, V_0)$, where $V_0$ is the sinusoid amplitude for $v^n = V_0 \\sin(\\omega_k n \\Delta t)$. Use the following scientifically sound test suite designed for coverage:\n- Case $1$ (happy path near corner frequency): $(R, C, \\Delta t, N, k, V_0) = (50, 100 \\times 10^{-12}, 10^{-11}, 8192, 3, 1)$.\n- Case $2$ (low frequency below corner): $(R, C, \\Delta t, N, k, V_0) = (50, 100 \\times 10^{-12}, 10^{-11}, 8192, 1, 1)$.\n- Case $3$ (high frequency well below Nyquist): $(R, C, \\Delta t, N, k, V_0) = (50, 100 \\times 10^{-12}, 10^{-11}, 8192, 200, 1)$.\n- Case $4$ (near Nyquist edge case): $(R, C, \\Delta t, N, k, V_0) = (50, 100 \\times 10^{-12}, 10^{-11}, 8192, 4095, 1)$.\n- Case $5$ (different $R$ and $C$ to test parameter sensitivity): $(R, C, \\Delta t, N, k, V_0) = (5, 10 \\times 10^{-12}, 5 \\times 10^{-12}, 4096, 8, 1)$.\n\nAlgorithmic requirements: Implement the update\n$$\ni^{n+\\frac{1}{2}} = \\frac{v^n - v_C^{n-\\frac{1}{2}}}{R + \\frac{\\Delta t}{C}}, \\quad v_C^{n+\\frac{1}{2}} = v_C^{n-\\frac{1}{2}} + \\frac{\\Delta t}{C} i^{n+\\frac{1}{2}},\n$$\nsimulate for a burn-in duration of\n$$\nN_{\\text{burn}} = \\left\\lceil \\frac{10 R C}{\\Delta t} \\right\\rceil\n$$\nsamples, then compute the Discrete Fourier Transform (DFT) coefficients on the last $N$ samples:\n$$\nV_k = \\sum_{n=0}^{N-1} v^n e^{-j \\frac{2\\pi k n}{N}}, \\quad I_k = \\sum_{n=0}^{N-1} i^{n+\\frac{1}{2}} e^{-j \\frac{2\\pi k n}{N}},\n$$\nand form $Z_{\\text{in}}(\\omega_k) = \\frac{V_k}{I_k}$ and the relative error $\\varepsilon$ with respect to $Z(\\omega_k) = R + \\frac{1}{j \\omega_k C}$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the five test cases, for example, $\"[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4,\\varepsilon_5]\"$, where each $\\varepsilon_i$ is a float. No other text may be printed.", "solution": "The problem has been meticulously examined and is determined to be valid. It is scientifically grounded in the principles of computational electromagnetics, specifically the Finite-Difference Time-Domain (FDTD) method. The problem is well-posed, self-contained, and all parameters, equations, and evaluation criteria are explicitly defined. It presents a standard exercise in numerical methods: implementing a specified discrete-time algorithm to model a physical system and quantifying its accuracy by comparing the numerical results against the known continuous-time analytical solution.\n\nThe objective is to compute the input impedance $Z_{\\text{in}}(\\omega_k)$ of a series resistor-capacitor (RC) circuit that is modeled using a specific discrete-time update scheme suitable for incorporation into an FDTD simulation. This numerical impedance will then be compared to the ideal continuous-time impedance $Z(\\omega_k) = R + \\frac{1}{j \\omega_k C}$ by calculating the relative error $\\varepsilon$.\n\nThe methodology involves a direct time-domain simulation of the provided discrete update equations. The process for each test case is as follows:\n\n1.  **Parameter Initialization**: For each case, the parameters $(R, C, \\Delta t, N, k, V_0)$ are defined. $R$ is the resistance, $C$ is the capacitance, $\\Delta t$ is the time step, $N$ is the number of samples for Fourier analysis, $k$ is the frequency bin index, and $V_0$ is the amplitude of the excitation voltage.\n\n2.  **Frequency and Burn-in Calculation**: The angular frequency of excitation is determined by the bin index $k$ via the relation $\\omega_k = \\frac{2 \\pi k}{N \\Delta t}$. A burn-in period of $N_{\\text{burn}} = \\left\\lceil \\frac{10 R C}{\\Delta t} \\right\\rceil$ time steps is computed. This duration, equivalent to $10$ times the circuit's time constant $\\tau=RC$, ensures that any initial transients have decayed and the system has reached a sinusoidal steady state before data acquisition begins.\n\n3.  **Time-Stepping Simulation**: A simulation loop is executed for a total of $N_{\\text{total}} = N_{\\text{burn}} + N$ time steps, indexed by $n$. At each step $n$:\n    a. The sinusoidal input voltage is calculated: $v^n = V_0 \\sin(\\omega_k n \\Delta t)$.\n    b. The lumped current $i^{n+\\frac{1}{2}}$ and capacitor voltage $v_C^{n+\\frac{1}{2}}$ are computed using the prescribed recurrence relations, which are derived from a backward-Euler-like treatment of the capacitor on a staggered time grid:\n    $$\n    i^{n+\\frac{1}{2}} = \\frac{v^n - v_C^{n-\\frac{1}{2}}}{R + \\frac{\\Delta t}{C}}\n    $$\n    $$\n    v_C^{n+\\frac{1}{2}} = v_C^{n-\\frac{1}{2}} + \\frac{\\Delta t}{C} i^{n+\\frac{1}{2}}\n    $$\n    The simulation starts from rest, with the initial capacitor voltage $v_C^{-1/2} = 0$. The value of $v_C$ is updated at each step to be used in the subsequent step.\n\n4.  **Data Acquisition**: During the final $N$ steps of the simulation (i.e., for $n$ from $N_{\\text{burn}}$ to $N_{\\text{burn}} + N - 1$), the computed values of the voltage $v^n$ and current $i^{n+\\frac{1}{2}}$ are stored in arrays.\n\n5.  **Frequency-Domain Analysis**: After the simulation, the Discrete Fourier Transform (DFT) is applied to the collected time-domain data. The problem defines the relevant DFT coefficients as:\n    $$\n    V_k = \\sum_{m=0}^{N-1} v_{\\text{acq}}^m e^{-j \\frac{2\\pi k m}{N}}\n    $$\n    $$\n    I_k = \\sum_{m=0}^{N-1} i_{\\text{acq}}^m e^{-j \\frac{2\\pi k m}{N}}\n    $$\n    where $v_{\\text{acq}}^m$ and $i_{\\text{acq}}^m$ are the $m$-th samples in the acquired data arrays of length $N$. These coefficients correspond to the frequency $\\omega_k$.\n\n6.  **Impedance Calculation**: The numerical input impedance is calculated as the ratio of the complex DFT coefficients:\n    $$\n    Z_{\\text{in}}(\\omega_k) = \\frac{V_k}{I_k}\n    $$\n    This numerical result inherently includes the discretization error of the time-stepping scheme.\n\n7.  **Error Evaluation**: The numerical impedance $Z_{\\text{in}}(\\omega_k)$ is compared against the theoretical continuous-time impedance $Z(\\omega_k) = R + \\frac{1}{j \\omega_k C}$. The relative error $\\varepsilon$ is computed as specified:\n    $$\n    \\varepsilon = \\frac{\\left| Z_{\\text{in}}(\\omega_k) - Z(\\omega_k) \\right|}{\\left| Z(\\omega_k) \\right|}\n    $$\nThis procedure is repeated for all five test cases provided in the problem statement, and the resulting relative errors are reported.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the numerical input impedance of a series RC circuit using a\n    discrete-time FDTD-style update and calculates the relative error against\n    the continuous-time analytical impedance.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (R, C, dt, N, k, V0)\n        (50.0, 100e-12, 10e-12, 8192, 3, 1.0),\n        (50.0, 100e-12, 10e-12, 8192, 1, 1.0),\n        (50.0, 100e-12, 10e-12, 8192, 200, 1.0),\n        (50.0, 100e-12, 10e-12, 8192, 4095, 1.0),\n        (5.0, 10e-12, 5e-12, 4096, 8, 1.0),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        R, C, dt, N, k, V0 = case\n\n        # Calculate angular frequency for the given bin k\n        # Handle k=0 case to avoid division by zero, although not in test suite.\n        if k == 0:\n            omega_k = 0.0\n        else:\n            omega_k = (2.0 * np.pi * k) / (N * dt)\n\n        # Calculate burn-in duration\n        # Time constant tau = R * C\n        N_burn = int(np.ceil((10.0 * R * C) / dt))\n        \n        N_total = N_burn + N\n        \n        # Arrays to store voltage and current for DFT\n        v_samples = np.zeros(N)\n        i_samples = np.zeros(N)\n\n        # Initial condition: capacitor voltage is zero.\n        # This variable represents v_C at the (n-1/2) time step.\n        vc_prev = 0.0\n        \n        # Pre-compute the denominator for the current update\n        i_denom = R + dt / C\n\n        # Time-stepping loop\n        for n in range(N_total):\n            # 1. Calculate input voltage at integer time step n\n            t = n * dt\n            v_n = V0 * np.sin(omega_k * t)\n\n            # 2. Calculate current at half time step n+1/2\n            i_n_plus_half = (v_n - vc_prev) / i_denom\n\n            # 3. Calculate capacitor voltage at half time step n+1/2\n            vc_n_plus_half = vc_prev + (dt / C) * i_n_plus_half\n            \n            # 4. Update the previous capacitor voltage for the next iteration\n            vc_prev = vc_n_plus_half\n\n            # 5. Store samples after burn-in period\n            if n >= N_burn:\n                sample_idx = n - N_burn\n                v_samples[sample_idx] = v_n\n                i_samples[sample_idx] = i_n_plus_half\n\n        # Compute DFT of the collected samples\n        V_dft = np.fft.fft(v_samples)\n        I_dft = np.fft.fft(i_samples)\n\n        # Extract the coefficients at bin k\n        V_k = V_dft[k]\n        I_k = I_dft[k]\n\n        # Calculate numerical input impedance\n        # Add a small epsilon to denominator to avoid division by zero if I_k is zero\n        Z_numerical = V_k / (I_k + 1e-30)\n\n        # Calculate continuous-time analytical impedance\n        if omega_k == 0.0:\n            # For DC, capacitor is an open circuit, impedance is infinite.\n            # However, the problem formulation implies comparison where it's defined.\n            # In this context, we'd skip a k=0 case, but handling for robustness.\n            # Since no k=0 exists, this branch is not taken.\n            Z_analytical = np.inf\n        else:\n            Z_analytical = R + 1.0 / (1j * omega_k * C)\n\n        # Calculate the relative error\n        if np.isinf(Z_analytical):\n            error = np.inf if not np.isinf(Z_numerical) else 0.0\n        else:\n             error = np.abs(Z_numerical - Z_analytical) / np.abs(Z_analytical)\n        \n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3327488"}, {"introduction": "The accuracy of an FDTD simulation with lumped elements depends critically on their precise spatial placement. This practice explores the \"staircase error\" that arises when an element located between grid nodes is naively \"snapped\" to the nearest discrete point. Using transmission line theory as an analytical tool, you will quantify this error and then implement a subcell interpolation scheme to distribute the element's effect between adjacent nodes, demonstrating a significant improvement in accuracy [@problem_id:3327459]. This technique is vital for flexible and precise modeling of complex devices whose features do not align perfectly with the simulation grid.", "problem": "You are asked to quantify and mitigate the staircase error that arises when embedding a lumped element in a uniform one-dimensional Finite-Difference Time-Domain (FDTD) grid. The staircase error arises when a lumped element located at a subcell offset is naively snapped to the nearest grid node, instead of being represented with a subcell interpolation. You must model this scenario in the frequency domain using a physically consistent two-port cascading approach and compute the change in the extracted input impedance due to a half-cell shift of the lumped element. You must also implement an interpolation strategy and quantify its improvement.\n\nStart from the fundamental one-dimensional Maxwell equations and the definition of a lossless uniform medium. Using these, you must derive the frequency-domain relation between voltage and current along the line and cast it into a two-port network representation. Represent a finite, homogeneous, lossless transmission line of total length $L$ terminated by a matched load with characteristic impedance $Z_{0}$. The line supports time-harmonic fields at angular frequency $\\omega = 2 \\pi f$, with real phase constant $\\beta = \\omega \\sqrt{\\mu \\epsilon}$ and wave impedance $Z_{0} = \\sqrt{\\mu/\\epsilon}$, where $\\epsilon = \\epsilon_{0} \\epsilon_{r}$ and $\\mu = \\mu_{0} \\mu_{r}$.\n\nA shunt lumped capacitance $C$ to ground is embedded at position $x$ within the line. Model this capacitance as an admittance $Y(\\omega) = j \\omega C$ inserted in shunt at the chosen position. You must compute the input impedance at $z = 0$ of the cascaded network consisting of a line section from $z = 0$ to the shunt, followed by the shunt, followed by the remaining line section to the matched termination. Then, quantify the change in the extracted input impedance when the shunt element is shifted by half a cell relative to a grid node. Finally, propose and implement a subcell interpolation that distributes the shunt admittance between adjacent grid nodes to mitigate the staircase error.\n\nYour derivation and implementation must obey the following modeling constraints.\n\n- Use a uniform spatial step $\\Delta z$ for the notional FDTD grid. Electric field sample locations (grid nodes) are at positions $n \\Delta z$ with integer $n$. The actual element position is $x = x_{\\mathrm{L}} + \\alpha \\Delta z$ for a fractional offset $\\alpha \\in [0,1]$, where $x_{\\mathrm{L}} = n \\Delta z$ is the left node. The half-cell shift corresponds to $\\alpha = 0.5$.\n- The naive staircase model snaps the element to the nearest node. For concreteness, treat the naive snap as placing the entire shunt admittance at $x_{\\mathrm{L}}$ (i.e., $\\alpha_{\\mathrm{naive}} = 0$).\n- The true model places the entire shunt admittance at the actual position $x = x_{\\mathrm{L}} + \\alpha \\Delta z$.\n- The proposed interpolation model distributes the shunt admittance into two shunts at the neighboring nodes with weights $Y_{1} = (1 - \\alpha) Y$ at $x_{\\mathrm{L}}$ and $Y_{2} = \\alpha Y$ at $x_{\\mathrm{R}} = x_{\\mathrm{L}} + \\Delta z$. For the half-cell shift with $\\alpha = 0.5$, both weights are equal. This linear interpolation is consistent with subcell volumetric weighting.\n\nFor each configuration, compute the input impedance $Z_{\\mathrm{in}}$ at $z = 0$ using a cascade of two-port networks for the left line, the shunt(s), and the right line, and a matched load $Z_{0}$ at $z = L$. Express angles in radians. Express impedances in ohms.\n\nYour program must implement the above, and for each test case output two errors, as follows.\n\n- Compute the absolute error magnitude in ohms of the naive snap relative to the true placement:\n  $$\\Delta Z_{\\mathrm{naive}} = \\left| Z_{\\mathrm{in,naive}} - Z_{\\mathrm{in,true}} \\right|.$$\n- Compute the absolute error magnitude in ohms of the interpolated model relative to the true placement:\n  $$\\Delta Z_{\\mathrm{interp}} = \\left| Z_{\\mathrm{in,interp}} - Z_{\\mathrm{in,true}} \\right|.$$\n\nImplementation details to respect.\n\n- Use the vacuum constants $\\epsilon_{0}$ and $\\mu_{0}$ and the specified relative parameters to compute $Z_{0}$ and $\\beta$ for each test.\n- Use a two-port network (transmission matrix) cascade for line sections and shunt elements to obtain $Z_{\\mathrm{in}}$ with a matched termination $Z_{0}$.\n- The output for each test case must be a list of two floating-point numbers $[\\Delta Z_{\\mathrm{naive}}, \\Delta Z_{\\mathrm{interp}}]$ in ohms, rounded to six decimal places.\n\nTest Suite. Your program must compute the errors for the following cases and aggregate them into a single output line.\n\n- Case $\\mathrm{A}$ (happy path, free space): $\\epsilon_{r} = 1$, $\\mu_{r} = 1$, $f = 1.0 \\times 10^{9}\\ \\mathrm{Hz}$, $L = 0.3\\ \\mathrm{m}$, $\\Delta z = 0.01\\ \\mathrm{m}$, $C = 1.0 \\times 10^{-12}\\ \\mathrm{F}$, $n = 10$, $\\alpha = 0.5$.\n- Case $\\mathrm{B}$ (higher permittivity, higher frequency): $\\epsilon_{r} = 4$, $\\mu_{r} = 1$, $f = 3.0 \\times 10^{9}\\ \\mathrm{Hz}$, $L = 0.1\\ \\mathrm{m}$, $\\Delta z = 0.005\\ \\mathrm{m}$, $C = 0.5 \\times 10^{-12}\\ \\mathrm{F}$, $n = 5$, $\\alpha = 0.5$.\n- Case $\\mathrm{C}$ (lower frequency, moderate permittivity): $\\epsilon_{r} = 2.25$, $\\mu_{r} = 1$, $f = 1.0 \\times 10^{8}\\ \\mathrm{Hz}$, $L = 0.2\\ \\mathrm{m}$, $\\Delta z = 0.02\\ \\mathrm{m}$, $C = 10.0 \\times 10^{-12}\\ \\mathrm{F}$, $n = 3$, $\\alpha = 0.5$.\n- Case $\\mathrm{D}$ (boundary condition, element at node): $\\epsilon_{r} = 1$, $\\mu_{r} = 1$, $f = 2.0 \\times 10^{9}\\ \\mathrm{Hz}$, $L = 0.2\\ \\mathrm{m}$, $\\Delta z = 0.01\\ \\mathrm{m}$, $C = 2.0 \\times 10^{-12}\\ \\mathrm{F}$, $n = 8$, $\\alpha = 0.0$.\n- Case $\\mathrm{E}$ (strong loading, free space): $\\epsilon_{r} = 1$, $\\mu_{r} = 1$, $f = 2.0 \\times 10^{9}\\ \\mathrm{Hz}$, $L = 0.15\\ \\mathrm{m}$, $\\Delta z = 0.0075\\ \\mathrm{m}$, $C = 50.0 \\times 10^{-12}\\ \\mathrm{F}$, $n = 6$, $\\alpha = 0.5$.\n\nFinal Output Format. Your program should produce a single line containing a list of five entries, one per test case, where each entry is a two-element list in the order $[\\Delta Z_{\\mathrm{naive}}, \\Delta Z_{\\mathrm{interp}}]$ in ohms, each rounded to six decimal places. For example:\n\"[ [a1,b1],[a2,b2],[a3,b3],[a4,b4],[a5,b5] ]\" but without spaces. Your exact output must be a single line of the form \"[[a1,b1],[a2,b2],[a3,b3],[a4,b4],[a5,b5]]\".", "solution": "The problem statement is a valid, well-posed problem in computational electromagnetics and microwave engineering. It is scientifically grounded in transmission line theory and two-port network analysis, which are derived from Maxwell's equations. The problem is objective, self-contained, and all necessary parameters for a unique solution are provided. We may therefore proceed with a formal derivation and solution.\n\nThe objective is to analyze the error introduced by the \"staircase\" approximation in a one-dimensional Finite-Difference Time-Domain (FDTD) grid when incorporating a lumped element at a subcell position. We model this scenario in the frequency domain using a cascade of two-port networks.\n\nA lossless, uniform transmission line is characterized by its frequency-domain behavior, which is derived from the one-dimensional Telegrapher's equations for time-harmonic fields $(\\exp(j \\omega t))$:\n$$\n\\frac{dV(z)}{dz} = -j \\omega L' I(z)\n$$\n$$\n\\frac{dI(z)}{dz} = -j \\omega C' V(z)\n$$\nwhere $V(z)$ and $I(z)$ are the phasor voltage and current at position $z$, and $L'$ and $C'$ are the per-unit-length inductance and capacitance, respectively. The solution to these equations gives the characteristic impedance $Z_0 = \\sqrt{L'/C'}$ and the propagation constant $\\gamma = j \\beta = j \\omega \\sqrt{L'C'}$. For a medium with permittivity $\\epsilon = \\epsilon_0 \\epsilon_r$ and permeability $\\mu = \\mu_0 \\mu_r$, these parameters are given by $Z_0 = \\sqrt{\\mu/\\epsilon}$ and the phase constant $\\beta = \\omega \\sqrt{\\mu \\epsilon}$.\n\nThe relationship between the voltage and current at two different points on the line, say $z=z_1$ and $z=z_2$, can be expressed using a two-port network representation. We use the ABCD matrix (or transmission matrix) formalism, which relates the input port ($V_1, I_1$) to the output port ($V_2, I_2$):\n$$\n\\begin{pmatrix} V_1 \\\\ I_1 \\end{pmatrix} = \\begin{pmatrix} A & B \\\\ C & D \\end{pmatrix} \\begin{pmatrix} V_2 \\\\ I_2 \\end{pmatrix}\n$$\nFor a section of lossless transmission line of length $d$, the ABCD matrix is:\n$$\n\\mathbf{T}_{\\mathrm{line}}(d) = \\begin{pmatrix} \\cos(\\beta d) & j Z_0 \\sin(\\beta d) \\\\ j \\frac{1}{Z_0} \\sin(\\beta d) & \\cos(\\beta d) \\end{pmatrix}\n$$\nA shunt element with admittance $Y$ has an ABCD matrix:\n$$\n\\mathbf{T}_{\\mathrm{shunt}}(Y) = \\begin{pmatrix} 1 & 0 \\\\ Y & 1 \\end{pmatrix}\n$$\nWhen multiple two-port networks are cascaded, the total ABCD matrix is the product of the individual matrices in the order they appear from input to output. For a system composed of networks $\\mathbf{T}_1, \\mathbf{T}_2, \\ldots, \\mathbf{T}_N$, the total matrix is $\\mathbf{T}_{\\mathrm{total}} = \\mathbf{T}_1 \\mathbf{T}_2 \\cdots \\mathbf{T}_N$.\n\nGiven a total ABCD matrix for a network terminated by a load impedance $Z_L$, the input impedance $Z_{\\mathrm{in}}$ is calculated as:\n$$\nZ_{\\mathrm{in}} = \\frac{A Z_L + B}{C Z_L + D}\n$$\nIn this problem, the transmission line of total length $L$ is terminated by a matched load, so $Z_L = Z_0$.\n\nWe will now model the three specified configurations for placing a shunt capacitor $C$ with admittance $Y(\\omega) = j \\omega C$ on the transmission line. The element's true position is $x = x_{\\mathrm{L}} + \\alpha \\Delta z$, where $x_{\\mathrm{L}} = n \\Delta z$ is the coordinate of the $n$-th grid node.\n\n**1. True Model:** The shunt admittance $Y$ is placed at its exact physical location $x$. This is modeled as a cascade of a line section of length $x$, the shunt element, and a final line section of length $L-x$.\nThe total transmission matrix is:\n$$\n\\mathbf{T}_{\\mathrm{true}} = \\mathbf{T}_{\\mathrm{line}}(x) \\cdot \\mathbf{T}_{\\mathrm{shunt}}(Y) \\cdot \\mathbf{T}_{\\mathrm{line}}(L-x)\n$$\nThe input impedance $Z_{\\mathrm{in,true}}$ is then computed using this matrix and the matched load $Z_L = Z_0$.\n\n**2. Naive Snap Model:** The shunt admittance $Y$ is \"snapped\" to the nearest grid node, which is defined as the left node $x_{\\mathrm{L}}$. This corresponds to setting the subcell offset $\\alpha=0$ in the true model. This is a cascade of a line section of length $x_{\\mathrm{L}}$, the shunt element, and a final line section of length $L-x_{\\mathrm{L}}$.\n$$\n\\mathbf{T}_{\\mathrm{naive}} = \\mathbf{T}_{\\mathrm{line}}(x_{\\mathrm{L}}) \\cdot \\mathbf{T}_{\\mathrm{shunt}}(Y) \\cdot \\mathbf{T}_{\\mathrm{line}}(L-x_{\\mathrm{L}})\n$$\nThe input impedance $Z_{\\mathrm{in,naive}}$ is computed accordingly.\n\n**3. Interpolated Model:** The shunt admittance $Y$ is distributed between the two adjacent grid nodes, $x_{\\mathrm{L}}$ and $x_{\\mathrm{R}} = x_{\\mathrm{L}} + \\Delta z$, using linear weighting.\n- An admittance $Y_1 = (1-\\alpha)Y$ is placed at $x_{\\mathrm{L}}$.\n- An admittance $Y_2 = \\alpha Y$ is placed at $x_{\\mathrm{R}}$.\nThis is modeled as a cascade of five components: a line section to the first shunt, the first shunt, a line section to the second shunt, the second shunt, and the final line section.\n$$\n\\mathbf{T}_{\\mathrm{interp}} = \\mathbf{T}_{\\mathrm{line}}(x_{\\mathrm{L}}) \\cdot \\mathbf{T}_{\\mathrm{shunt}}(Y_1) \\cdot \\mathbf{T}_{\\mathrm{line}}(\\Delta z) \\cdot \\mathbf{T}_{\\mathrm{shunt}}(Y_2) \\cdot \\mathbf{T}_{\\mathrm{line}}(L-x_{\\mathrm{R}})\n$$\nwhere the length of the final section is $L - x_{\\mathrm{R}} = L - (x_{\\mathrm{L}} + \\Delta z)$.\nThe input impedance $Z_{\\mathrm{in,interp}}$ is computed from this total matrix.\n\nFor each test case, we first calculate the physical constants from the given parameters:\n- Vacuum permittivity: $\\epsilon_0 \\approx 8.854 \\times 10^{-12} \\ \\mathrm{F/m}$\n- Vacuum permeability: $\\mu_0 = 4\\pi \\times 10^{-7} \\ \\mathrm{H/m}$\n- Angular frequency: $\\omega = 2\\pi f$\n- Medium permittivity: $\\epsilon = \\epsilon_r \\epsilon_0$\n- Medium permeability: $\\mu = \\mu_r \\mu_0$\n- Characteristic impedance: $Z_0 = \\sqrt{\\mu/\\epsilon}$\n- Phase constant: $\\beta = \\omega \\sqrt{\\mu\\epsilon}$\n- Shunt admittance: $Y = j \\omega C$\n\nWith these values, we construct the ABCD matrices for each of the three models, compute their respective input impedances ($Z_{\\mathrm{in,true}}$, $Z_{\\mathrm{in,naive}}$, $Z_{\\mathrm{in,interp}}$), and finally calculate the required error magnitudes:\n$$\n\\Delta Z_{\\mathrm{naive}} = | Z_{\\mathrm{in,naive}} - Z_{\\mathrm{in,true}} |\n$$\n$$\n\\Delta Z_{\\mathrm{interp}} = | Z_{\\mathrm{in,interp}} - Z_{\\mathrm{in,true}} |\n$$\nThese steps are implemented in the provided Python code for each test case.\nFor Case D, where $\\alpha=0$, the true position $x$ coincides with the grid node $x_{\\mathrm{L}}$. Consequently, the naive model becomes identical to the true model. Furthermore, the interpolated model places an admittance $Y_1 = (1-0)Y = Y$ at $x_{\\mathrm{L}}$ and $Y_2 = 0 \\cdot Y = 0$ at $x_{\\mathrm{R}}$. This also reduces to the true model configuration. Therefore, for $\\alpha=0$, we expect both $\\Delta Z_{\\mathrm{naive}}$ and $\\Delta Z_{\\mathrm{interp}}$ to be zero, which serves as a validation of the method.", "answer": "```python\nimport numpy as np\nfrom scipy.constants import epsilon_0, mu_0\n\ndef solve():\n    \"\"\"\n    Computes staircase and interpolation errors for a lumped element in a 1D FDTD grid.\n    \"\"\"\n    \n    # Test cases: (er, mur, f, L, dz, C, n, alpha)\n    test_cases = [\n        # Case A: Happy path, free space\n        (1.0, 1.0, 1.0e9, 0.3, 0.01, 1.0e-12, 10, 0.5),\n        # Case B: Higher permittivity, higher frequency\n        (4.0, 1.0, 3.0e9, 0.1, 0.005, 0.5e-12, 5, 0.5),\n        # Case C: Lower frequency, moderate permittivity\n        (2.25, 1.0, 1.0e8, 0.2, 0.02, 10.0e-12, 3, 0.5),\n        # Case D: Boundary condition, element at node\n        (1.0, 1.0, 2.0e9, 0.2, 0.01, 2.0e-12, 8, 0.0),\n        # Case E: Strong loading, free space\n        (1.0, 1.0, 2.0e9, 0.15, 0.0075, 50.0e-12, 6, 0.5),\n    ]\n\n    results = []\n\n    def get_tline_abcd(d, Z0, beta):\n        cos_bd = np.cos(beta * d)\n        sin_bd = np.sin(beta * d)\n        return np.array([\n            [cos_bd, 1j * Z0 * sin_bd],\n            [1j * sin_bd / Z0, cos_bd]\n        ], dtype=np.complex128)\n\n    def get_shunt_abcd(Y):\n        return np.array([\n            [1, 0],\n            [Y, 1]\n        ], dtype=np.complex128)\n\n    def get_zin(abcd_total, ZL):\n        A, B = abcd_total[0, 0], abcd_total[0, 1]\n        C, D = abcd_total[1, 0], abcd_total[1, 1]\n        # Handle case C*ZL + D == 0, though unlikely with physical params\n        denominator = C * ZL + D\n        if np.abs(denominator)  1e-18:\n            return np.inf\n        return (A * ZL + B) / denominator\n\n    for case in test_cases:\n        er, mur, f, L, dz, C, n, alpha = case\n\n        # Calculate physical parameters\n        omega = 2 * np.pi * f\n        epsilon = er * epsilon_0\n        mu = mur * mu_0\n        Z0 = np.sqrt(mu / epsilon)\n        beta = omega * np.sqrt(mu * epsilon)\n        Y = 1j * omega * C\n\n        # Define positions\n        x_L = n * dz\n        x_R = x_L + dz\n        x_true = x_L + alpha * dz\n\n        # 1. True Model\n        T_line_L_true = get_tline_abcd(x_true, Z0, beta)\n        T_shunt_true = get_shunt_abcd(Y)\n        T_line_R_true = get_tline_abcd(L - x_true, Z0, beta)\n        T_total_true = T_line_L_true @ T_shunt_true @ T_line_R_true\n        Z_in_true = get_zin(T_total_true, Z0)\n\n        # 2. Naive Snap Model (element snapped to x_L)\n        # This is equivalent to alpha = 0 for the \"true\" model structure\n        T_line_L_naive = get_tline_abcd(x_L, Z0, beta)\n        T_shunt_naive = get_shunt_abcd(Y)\n        T_line_R_naive = get_tline_abcd(L - x_L, Z0, beta)\n        T_total_naive = T_line_L_naive @ T_shunt_naive @ T_line_R_naive\n        Z_in_naive = get_zin(T_total_naive, Z0)\n\n        # 3. Interpolated Model\n        Y1 = (1 - alpha) * Y\n        Y2 = alpha * Y\n        \n        # Check if the right line segment has non-negative length\n        # This is guaranteed by problem constraints but good practice.\n        if L - x_R  -1e-12: # Check for negative length with tolerance\n             # In a real application, would raise an error.\n             # Here, this would indicate an invalid problem setup.\n             Z_in_interp = np.nan \n        else:\n            T_L1_interp = get_tline_abcd(x_L, Z0, beta)\n            T_S1_interp = get_shunt_abcd(Y1)\n            T_mid_interp = get_tline_abcd(dz, Z0, beta)\n            T_S2_interp = get_shunt_abcd(Y2)\n            T_R_interp = get_tline_abcd(L - x_R, Z0, beta)\n            \n            T_total_interp = T_L1_interp @ T_S1_interp @ T_mid_interp @ T_S2_interp @ T_R_interp\n            Z_in_interp = get_zin(T_total_interp, Z0)\n\n        # Calculate errors\n        delta_Z_naive = np.abs(Z_in_naive - Z_in_true)\n        delta_Z_interp = np.abs(Z_in_interp - Z_in_true)\n\n        results.append([round(delta_Z_naive, 6), round(delta_Z_interp, 6)])\n\n    # Format the final output string\n    formatted_results = [f\"[{r[0]},{r[1]}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3327459"}]}