{"hands_on_practices": [{"introduction": "A cornerstone of the spectral element method's efficiency is its ability to perform operator actions without assembling large, dense element matrices. This is achieved through an elegant procedure known as sum-factorization, which leverages the tensor-product structure of the basis functions. This following exercise [@problem_id:3349976] walks through a 'pencil-and-paper' complexity analysis to reveal how this technique reduces the computational cost of applying the curl-curl operator from a prohibitive $\\mathcal{O}(p^6)$ to a highly efficient $\\mathcal{O}(p^4)$ per element, explaining the method's excellent performance at high polynomial orders $p$.", "problem": "Consider the frequency-domain Maxwell equations in a homogeneous, isotropic medium with constant permittivity and permeability, where the electric field $\\mathbf{E}$ satisfies the vector Helmholtz form $\\nabla \\times \\nabla \\times \\mathbf{E} - k^{2} \\mathbf{E} = \\mathbf{J}$. Focus on the element-local application of the curl-curl operator $\\nabla \\times \\nabla \\times \\mathbf{E}$ in a Spectral Element Method (SEM) on a single affine hexahedral element. Use a tensor-product Lagrange basis of degree $p$ with Gauss–Lobatto–Legendre (GLL) nodes in each one-dimensional coordinate, so that there are $N = p+1$ nodes per coordinate and $N^{3}$ nodes per element. Assume the mapping from the reference element to the physical element is affine, with constant geometric factors and Jacobian, so that metric terms are constant and can be ignored for operation counting at leading order.\n\nDefine the one-dimensional nodal basis functions $\\ell_{i}(\\xi)$, for $i = 0,\\dots,p$, on the reference interval with GLL nodes, and let the one-dimensional derivative matrix $D$ be the dense ($N \\times N$) matrix with entries $D_{\\alpha\\beta} = \\frac{\\mathrm{d}\\ell_{\\beta}}{\\mathrm{d}\\xi}$ evaluated at the node $\\xi_{\\alpha}$. The three-dimensional tensor-product basis on the reference element $[-1,1]^{3}$ is $\\ell_{i}(\\xi)\\,\\ell_{j}(\\eta)\\,\\ell_{k}(\\zeta)$. The discrete vector field $\\mathbf{E}$ has three components, each represented on the same tensor-product grid. Consider a matrix-free, element-local operator application in which all derivatives and contractions are performed by sum-factorization, that is, by applying one-dimensional transforms along lines of fixed indices in the tensor-product grid rather than forming dense three-dimensional matrices.\n\nStarting from the weak form of the curl-curl operator and the definition of the tensor-product basis, derive the sum-factorized plan for evaluating the curl $\\nabla \\times \\mathbf{E}$ at the $N^{3}$ grid points and then accumulating the weak form contributions back to the nodal coefficients. In your derivation, treat each application of a one-dimensional ($N \\times N$) derivative matrix to a line of length $N$ as costing $N^{2}$ scalar Floating-Point Multiply-Add (FMA) operations. Define Floating-Point Multiply-Add (FMA) on its first occurrence. Count only the leading-order operation terms and ignore all $\\mathcal{O}(N^{3})$ costs such as pointwise linear combinations, constant metric scalings, and diagonal mass operations.\n\nThen, analytically compare the leading-order operation count for a naive dense approach that applies a fully assembled element-local matrix of size ($3N^{3} \\times 3N^{3}$) to a vector, with the leading-order operation count for the sum-factorized approach. Finally, state the closed-form expression (in terms of $p$) for the leading-order number of FMA operations per element required to apply the curl-curl operator using sum-factorization.\n\nExpress your final answer as a single closed-form expression in $p$. No units are required. No rounding is required.", "solution": "The problem requires an analysis of the computational cost for applying the element-local curl-curl operator, $\\nabla \\times \\nabla \\times (\\cdot)$, within a Spectral Element Method (SEM) framework. We are asked to derive the operation count for a matrix-free sum-factorized approach and compare it to a naive dense matrix-vector product, providing the final cost in terms of the polynomial degree $p$.\n\nFirst, we establish the unit of computational work. A Floating-Point Multiply-Add (FMA) operation is a fused operation that computes $d = a \\times b + c$ and is counted as a single operation.\n\nThe core of the problem lies in evaluating the weak-form contribution from a single hexahedral element $\\Omega_e$. For a vector test function $\\mathbf{v}$ and the electric field $\\mathbf{E}$, this contribution is given by the integral:\n$$\n\\int_{\\Omega_e} (\\nabla \\times \\mathbf{v}) \\cdot (\\nabla \\times \\mathbf{E}) \\, dV\n$$\nTo analyze the computational cost, we map this integral to a reference element $\\hat{\\Omega} = [-1,1]^3$. Let the affine mapping be $\\mathbf{x}(\\boldsymbol{\\xi}) = F \\boldsymbol{\\xi} + \\mathbf{c}$, where $\\mathbf{x} = (x,y,z)$ are physical coordinates and $\\boldsymbol{\\xi} = (\\xi, \\eta, \\zeta)$ are reference coordinates. The Jacobian of this transformation, $J = \\frac{\\partial \\mathbf{x}}{\\partial \\boldsymbol{\\xi}}$, is a constant matrix. The differential volume element transforms as $dV = |J| d\\hat{V}$, where $|J|$ is the constant determinant of the Jacobian.\n\nThe curl operator transforms according to the relation $\\nabla \\times = (J^{-T} \\nabla_{\\boldsymbol{\\xi}}) \\times$, where $\\nabla_{\\boldsymbol{\\xi}}$ is the del operator in reference coordinates. Applying this to a vector field $\\mathbf{A}$, we get $\\nabla \\times \\mathbf{A} = J^{-T} (\\nabla_{\\boldsymbol{\\xi}} \\times \\mathbf{A})$, since $J^{-T}$ is a constant matrix. The weak form on the reference element becomes:\n$$\n\\int_{\\hat{\\Omega}} \\left( J^{-T} (\\nabla_{\\boldsymbol{\\xi}} \\times \\mathbf{v}) \\right) \\cdot \\left( J^{-T} (\\nabla_{\\boldsymbol{\\xi}} \\times \\mathbf{E}) \\right) |J| \\, d\\hat{V}\n$$\nThis can be rewritten using matrix notation for the dot product:\n$$\n|J| \\int_{\\hat{\\Omega}} (\\nabla_{\\boldsymbol{\\xi}} \\times \\mathbf{v})^T (J^{-1} J^{-T}) (\\nabla_{\\boldsymbol{\\xi}} \\times \\mathbf{E}) \\, d\\hat{V}\n$$\nThe matrix $G = J^{-1} J^{-T}$ contains the constant metric tensor components. The numerical evaluation of this integral using Gauss-Lobatto-Legendre (GLL) quadrature proceeds by evaluating the integrand at the $N^3$ GLL nodes and summing the results with appropriate quadrature weights. The overall operator application can be decomposed into a sequence of steps. Let the discrete nodal representation of $\\mathbf{E}$ be denoted by the vector of coefficients $\\underline{\\mathbf{E}}$.\n\nThe sum-factorized plan is as follows:\n1.  Compute the reference curl, $\\mathbf{c}_E = \\nabla_{\\boldsymbol{\\xi}} \\times \\mathbf{E}$, at all $N^3$ GLL nodes.\n2.  Apply the metric tensor and quadrature weights pointwise: at each node $(i,j,k)$, compute $\\tilde{\\mathbf{c}}_E = |J| w_{ijk} G (\\mathbf{c}_E)_{ijk}$.\n3.  Apply the transpose of the reference curl operator, $(\\nabla_{\\boldsymbol{\\xi}} \\times)^T$, to the field of weighted values $\\tilde{\\mathbf{c}}_E$ to accumulate the final nodal coefficients $\\underline{\\mathbf{F}}$.\n\nThe problem states that we should count only leading-order terms and ignore $\\mathcal{O}(N^3)$ costs such as pointwise linear combinations and scalings. Step 2 involves only pointwise operations at the $N^3$ nodes and thus has a cost of $\\mathcal{O}(N^3)$, which we will ignore. The dominant cost resides in Steps 1 and 3.\n\n**Step 1: Cost of Evaluating the Reference Curl $(\\nabla_{\\boldsymbol{\\xi}} \\times \\mathbf{E})$**\n\nThe reference curl is given by:\n$$\n\\nabla_{\\boldsymbol{\\xi}} \\times \\mathbf{E} = \\left(\\frac{\\partial E_z}{\\partial \\eta} - \\frac{\\partial E_y}{\\partial \\zeta}\\right)\\hat{\\xi} + \\left(\\frac{\\partial E_x}{\\partial \\zeta} - \\frac{\\partial E_z}{\\partial \\xi}\\right)\\hat{\\eta} + \\left(\\frac{\\partial E_y}{\\partial \\xi} - \\frac{\\partial E_x}{\\partial \\eta}\\right)\\hat{\\zeta}\n$$\nTo evaluate this at the $N^3$ nodes, we need to compute the nodal values of six partial derivatives: $\\frac{\\partial E_y}{\\partial \\xi}$, $\\frac{\\partial E_z}{\\partial \\xi}$, $\\frac{\\partial E_x}{\\partial \\eta}$, $\\frac{\\partial E_z}{\\partial \\eta}$, $\\frac{\\partial E_x}{\\partial \\zeta}$, and $\\frac{\\partial E_y}{\\partial \\zeta}$.\n\nLet's analyze the cost of computing one of these, for instance, $\\frac{\\partial E_x}{\\partial \\eta}$. The field component $E_x$ is represented on a tensor-product grid of $N \\times N \\times N$ nodal values. Using sum-factorization, the derivative with respect to $\\eta$ is computed by applying the one-dimensional ($N \\times N$) derivative matrix $D$ to data along each of the $N^2$ lines oriented in the $\\eta$-direction.\n- The number of such lines is $N^2$ (one for each $(\\xi_i, \\zeta_k)$ index pair).\n- The cost of applying the dense $N \\times N$ matrix $D$ to a vector of length $N$ is given as $N^2$ FMA operations.\n- Therefore, the total cost to compute the derivative of one scalar field (like $E_x$) with respect to one direction (like $\\eta$) over the entire 3D grid is $N^2 \\text{ lines} \\times N^2 \\text{ FMA/line} = N^4$ FMA.\n\nSince we need to compute $6$ such partial derivatives, the total cost for Step 1 is:\n$$\n\\text{Cost}_{\\text{Step 1}} = 6 \\times N^4 \\text{ FMA}\n$$\nThe subsequent pointwise subtractions to form the components of $\\mathbf{c}_E$ are $\\mathcal{O}(N^3)$ operations and are ignored as per the problem's instructions.\n\n**Step 3: Cost of Applying the Transpose Reference Curl $(\\nabla_{\\boldsymbol{\\xi}} \\times)^T$**\n\nThis step involves applying the discrete transpose of the operator from Step 1. The operation consists of applying the transpose of the partial derivative operators. For example, the contribution to the final nodal coefficients of $E_x$ comes from the components of $\\tilde{\\mathbf{c}}_E$ that involved derivatives of $E_x$ in Step 1. This process requires applying the transpose of the 1D derivative matrix, $D^T$, along the corresponding grid lines. The cost of applying an $N \\times N$ matrix $D^T$ to a vector of length $N$ is also $N^2$ FMA. The structure of the operator $(\\nabla_{\\boldsymbol{\\xi}} \\times)^T$ is identical to that of $\\nabla_{\\boldsymbol{\\xi}} \\times$ in terms of the number of derivative applications. It also requires the evaluation of 6 partial derivative-like operations.\nTherefore, the cost of Step 3 is also:\n$$\n\\text{Cost}_{\\text{Step 3}} = 6 \\times N^4 \\text{ FMA}\n$$\n\n**Total Sum-Factorization Cost**\n\nThe total leading-order cost for the sum-factorized curl-curl operator application is the sum of the costs from Steps 1 and 3:\n$$\n\\text{Cost}_{\\text{SF}} = 6 N^4 + 6 N^4 = 12 N^4 \\text{ FMA}\n$$\n\n**Comparison with the Naive Dense Approach**\n\nIn a naive approach, one would explicitly form the element-local stiffness matrix, $K_e^{curlcurl}$.\n- The number of degrees of freedom (DoFs) on the element for the vector field $\\mathbf{E}$ is $3$ components per node $\\times$ $N^3$ nodes = $3N^3$.\n- The dense stiffness matrix $K_e^{curlcurl}$ would have dimensions $(3N^3) \\times (3N^3)$.\n- Applying this operator corresponds to a matrix-vector product. The cost of multiplying a $(3N^3 \\times 3N^3)$ dense matrix by a vector of length $3N^3$ is approximately $(3N^3)^2$ FMA operations.\n$$\n\\text{Cost}_{\\text{Dense}} = (3N^3)^2 = 9 N^6 \\text{ FMA}\n$$\nThe sum-factorization approach has a cost of $12N^4$, while the dense approach has a cost of $9N^6$. The ratio of costs is $\\text{Cost}_{\\text{Dense}} / \\text{Cost}_{\\text{SF}} = \\frac{9N^6}{12N^4} = \\frac{3}{4}N^2$. For any $p \\ge 1$ (i.e., $N \\ge 2$), the sum-factorized approach is vastly more efficient, and its advantage grows quadratically with the number of nodes per dimension, $N$.\n\n**Final Expression for Sum-Factorization Cost**\n\nThe problem asks for the closed-form expression for the leading-order number of FMA operations in terms of the polynomial degree $p$. With $N = p+1$, the total cost is:\n$$\n\\text{Cost}_{\\text{SF}} = 12 N^4 = 12 (p+1)^4\n$$", "answer": "$$\\boxed{12(p+1)^4}$$", "id": "3349976"}, {"introduction": "Beyond efficient operator application, the performance of an SEM solver depends critically on how the resulting global system of equations is handled. Static condensation is a powerful algebraic technique that exploits the hierarchical nature of high-order basis functions to dramatically reduce the size of the problem that must be solved globally. This practice [@problem_id:3350015] delves into the mechanics of this procedure, guiding you to partition degrees of freedom and derive the favorable $\\mathcal{O}(p^2)$ scaling of the condensed system, which is key to designing fast iterative solvers.", "problem": "Consider the time-harmonic electromagnetic field governed by Maxwell’s equations in a bounded Lipschitz domain $\\Omega \\subset \\mathbb{R}^3$. The electric field is $\\mathbf{E}(\\mathbf{x})$, the magnetic permeability is $\\mu(\\mathbf{x})$, and the electric permittivity is $\\varepsilon(\\mathbf{x})$. Under standard assumptions leading to the curl-curl operator in the weak formulation, the partial differential equation reduces to the bilinear form involving $\\nabla \\times \\mathbf{E}$ and the test functions. The Spectral Element Method (SEM) is employed with high-order, tensor-product hexahedral elements, using the curl-conforming vector space based on Nédélec first-kind elements constructed from tensor-product polynomial spaces.\n\nStarting from the weak form and the definition of the curl-conforming space, derive a static condensation procedure for the resulting discrete system associated with the curl-curl operator. Explicitly partition the element-level matrix into interior and boundary blocks, eliminate the interior unknowns, and form the Schur complement governing the boundary unknowns. Then, rigorously count the degrees of freedom per element for the curl-conforming spectral element space of order $p$, and split them into interior and boundary subsets. Use these counts to show that the full system dimension per element scales as $\\mathcal{O}(p^3)$ while the statically condensed dimension per element scales as $\\mathcal{O}(p^2)$, and explain why this dimensional reduction impacts solver performance for iterative methods whose per-iteration cost scales with the number of unknowns.\n\nYou must express the degrees-of-freedom counts using a tensor-product construction. Let the curl-conforming spectral element space on a reference hexahedron be built from polynomial spaces of the form $Q_{a,b,c}$, where the dimension is $(a+1)(b+1)(c+1)$. For the three vector components, the admissible triplets of degrees are such that the component aligned with a coordinate direction has one axis of degree $p-1$ and the other two axes of degree $p$. From first principles, derive the total count per element and the split between interior and boundary unknowns by analyzing which basis functions have zero tangential trace on the element boundary.\n\nNext, extend the counting to a structured mesh of $N_x \\times N_y \\times N_z$ hexahedral elements. Provide formulas for the global number of condensed (boundary) unknowns using unique counts of mesh edges and faces:\n- The number of edges aligned with the $x$-axis equals $N_x (N_y + 1) (N_z + 1)$, with analogous expressions for the other axes.\n- The number of faces orthogonal to the $x$-axis equals $(N_x + 1) N_y N_z$, with analogous expressions for the other axes.\nAssume the high-order Nédélec first-kind construction in which each edge carries $p$ unknowns and each face carries $2 p (p-1)$ tangential unknowns. The full global unknown count equals the condensed count plus the interior count, where the interior count per element equals $3 p (p-1)^2$ and interior unknowns do not couple across elements.\n\nFinally, implement a complete, runnable program that computes, for a given polynomial order $p$ and mesh dimensions $(N_x,N_y,N_z)$, the following three quantities:\n- The total number of unknowns in the full system.\n- The total number of unknowns in the statically condensed system.\n- The ratio of the two totals, interpreted as a proxy for per-iteration cost in an iterative solver whose work per iteration scales linearly with the number of unknowns.\n\nDesign a test suite that includes a general case, small-order boundary cases, and anisotropic mesh cases:\n- Case $1$: $p=1$, $N_x=1$, $N_y=1$, $N_z=1$.\n- Case $2$: $p=2$, $N_x=1$, $N_y=1$, $N_z=1$.\n- Case $3$: $p=4$, $N_x=2$, $N_y=2$, $N_z=2$.\n- Case $4$: $p=8$, $N_x=1$, $N_y=2$, $N_z=3$.\n- Case $5$: $p=10$, $N_x=3$, $N_y=3$, $N_z=1$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case’s result is the list $[N_{\\text{full}},N_{\\text{condensed}},\\text{ratio}]$. For example, the overall format must be $[[a_1,b_1,r_1],[a_2,b_2,r_2],\\dots]$. No physical units are required in the output. All mathematical symbols in this problem statement must be written in LaTeX using $...$ for inline math, and every number must appear within LaTeX math delimiters.", "solution": "The problem is valid. It is a well-posed theoretical and computational exercise in the field of spectral element methods for computational electromagnetics, grounded in established mathematical and numerical principles.\n\nThe analysis begins with the weak formulation of the time-harmonic Maxwell's equations, leading to a system of linear equations $A\\mathbf{u}=\\mathbf{f}$ after discretization. We use the Spectral Element Method (SEM) with high-order curl-conforming vector basis functions on a mesh of hexahedral elements. The procedure of static condensation, its effect on system size, and its implementation for counting degrees of freedom (DoFs) are detailed below.\n\n**Static Condensation Procedure**\n\nStatic condensation is an efficient technique for solving linear systems by eliminating a subset of unknowns at the element level before global assembly. In the context of SEM, the unknowns (degrees of freedom) within each element are partitioned into two sets: interior unknowns ($\\mathbf{u}_I$), whose basis functions have support only within that element, and boundary unknowns ($\\mathbf{u}_B$), whose basis functions have support extending to the element boundary and are shared with adjacent elements.\n\nFor a single element $(e)$, the local system of equations $A^{(e)} \\mathbf{u}^{(e)} = \\mathbf{f}^{(e)}$ can be written in block form corresponding to this partitioning:\n$$\n\\begin{pmatrix} A_{II} & A_{IB} \\\\ A_{BI} & A_{BB} \\end{pmatrix}\n\\begin{pmatrix} \\mathbf{u}_I \\\\ \\mathbf{u}_B \\end{pmatrix} =\n\\begin{pmatrix} \\mathbf{f}_I \\\\ \\mathbf{f}_B \\end{pmatrix}\n$$\nHere, $A_{II}$ represents the coupling among interior DoFs, $A_{BB}$ represents the coupling among boundary DoFs, and $A_{IB}$ and $A_{BI}$ ($=A_{IB}^T$ for symmetric problems) represent the coupling between interior and boundary DoFs.\n\nBecause interior basis functions have zero trace on the element boundary, they do not couple with basis functions from any other element. This means the submatrix $A_{II}$ is purely local to the element and can be inverted independently. From the first row of the block system, we can express the interior unknowns in terms of the boundary unknowns:\n$$\nA_{II} \\mathbf{u}_I + A_{IB} \\mathbf{u}_B = \\mathbf{f}_I \\implies \\mathbf{u}_I = A_{II}^{-1} (\\mathbf{f}_I - A_{IB} \\mathbf{u}_B)\n$$\nSubstituting this expression into the second row of the block system eliminates $\\mathbf{u}_I$:\n$$\nA_{BI} \\left( A_{II}^{-1} (\\mathbf{f}_I - A_{IB} \\mathbf{u}_B) \\right) + A_{BB} \\mathbf{u}_B = \\mathbf{f}_B\n$$\nRearranging the terms to group those involving the unknown $\\mathbf{u}_B$ yields the condensed system for the boundary unknowns:\n$$\n(A_{BB} - A_{BI} A_{II}^{-1} A_{IB}) \\mathbf{u}_B = \\mathbf{f}_B - A_{BI} A_{II}^{-1} \\mathbf{f}_I\n$$\nThis equation is of the form $S \\mathbf{u}_B = \\hat{\\mathbf{f}}_B$, where:\n-   $S = A_{BB} - A_{BI} A_{II}^{-1} A_{IB}$ is the Schur complement matrix. It represents the effective stiffness matrix for the boundary unknowns after the interior effects have been \"condensed out\".\n-   $\\hat{\\mathbf{f}}_B = \\mathbf{f}_B - A_{BI} A_{II}^{-1} \\mathbf{f}_I$ is the modified load vector for the boundary unknowns.\n\nThe global system is formed by assembling the Schur complement matrices $S^{(e)}$ and modified load vectors $\\hat{\\mathbf{f}}_B^{(e)}$ from all elements. This results in a much smaller global system involving only the boundary DoFs. After solving the global condensed system for all $\\mathbf{u}_B$, the interior unknowns $\\mathbf{u}_I$ can be recovered for each element via back-substitution using the previously derived formula.\n\n**Degree-of-Freedom Counting and Asymptotic Scaling**\n\nTo understand the benefits of static condensation, we must count the number of interior and boundary DoFs. For a hexahedral element using Nédélec first-kind curl-conforming elements of polynomial order $p$, the vector basis functions $\\mathbf{E} = (E_x, E_y, E_z)^T$ are constructed from tensor-product polynomial spaces. On a reference element $\\hat{K} = [-1, 1]^3$ with coordinates $(\\xi_1, \\xi_2, \\xi_3)$, the function space is:\n$$\n\\mathbf{V}_p(\\hat{K}) = \\left\\{ \\mathbf{E} \\mid E_x \\in Q_{p-1, p, p}(\\hat{K}), \\quad E_y \\in Q_{p, p-1, p}(\\hat{K}), \\quad E_z \\in Q_{p, p, p-1}(\\hat{K}) \\right\\}\n$$\nwhere $Q_{a,b,c}$ is the space of polynomials with maximum degree $a$ in $\\xi_1$, $b$ in $\\xi_2$, and $c$ in $\\xi_3$. The dimension of $Q_{a,b,c}$ is $(a+1)(b+1)(c+1)$.\n\nThe total number of DoFs per element, $N_{\\text{total,elem}}$, is the dimension of $\\mathbf{V}_p(\\hat{K})$:\n$$\nN_{\\text{total,elem}} = \\dim(Q_{p-1, p, p}) + \\dim(Q_{p, p-1, p}) + \\dim(Q_{p, p, p-1})\n$$\n$$\nN_{\\text{total,elem}} = (p)(p+1)(p+1) + (p+1)(p)(p+1) + (p+1)(p+1)(p) = 3p(p+1)^2\n$$\nFor large $p$, the leading term is $3p(p^2) = 3p^3$, so the total number of DoFs per element scales as $\\mathcal{O}(p^3)$.\n\nInterior DoFs correspond to basis functions whose tangential trace vanishes on the element boundary $\\partial\\hat{K}$. For the $x$-component $E_x \\in Q_{p-1, p, p}$, its tangential components are zero on all faces if $E_x$ is zero on the faces orthogonal to the $\\xi_2$ and $\\xi_3$ axes (i.e., at $\\xi_2=\\pm 1$ and $\\xi_3=\\pm 1$). This requires $E_x$ to be of the form $E_x(\\xi_1, \\xi_2, \\xi_3) = (1-\\xi_2^2)(1-\\xi_3^2) \\psi(\\xi_1, \\xi_2, \\xi_3)$. For $E_x$ to remain in $Q_{p-1,p,p}$, the polynomial $\\psi$ must belong to $Q_{p-1, p-2, p-2}$. The number of such interior basis functions for the $x$-component is $\\dim(Q_{p-1, p-2, p-2}) = p(p-1)(p-1) = p(p-1)^2$.\nBy symmetry, the number of interior basis functions for the $y$ and $z$ components are also $p(p-1)^2$.\nThe total number of interior DoFs per element, $N_{I, \\text{elem}}$, is:\n$$\nN_{I, \\text{elem}} = 3p(p-1)^2\n$$\nFor large $p$, this also scales as $\\mathcal{O}(p^3)$.\n\nThe number of boundary DoFs per element, $N_{B, \\text{elem}}$, is the difference between the total and interior DoFs:\n$$\nN_{B, \\text{elem}} = N_{\\text{total,elem}} - N_{I, \\text{elem}} = 3p(p+1)^2 - 3p(p-1)^2\n$$\n$$\nN_{B, \\text{elem}} = 3p \\left[ (p^2+2p+1) - (p^2-2p+1) \\right] = 3p(4p) = 12p^2\n$$\nThe dimension of the statically condensed system at the element level, $N_{B, \\text{elem}}$, scales as $\\mathcal{O}(p^2)$.\n\nThis dimensional reduction from $\\mathcal{O}(p^3)$ to $\\mathcal{O}(p^2)$ per element is significant. The per-iteration cost of many iterative solvers, such as the Conjugate Gradient method, is dominated by the sparse matrix-vector product, which scales linearly with the number of unknowns in the global system. By eliminating the $\\mathcal{O}(p^3)$ interior unknowns from each element, static condensation reduces the size of the global system to only the $\\mathcal{O}(p^2)$ boundary unknowns (per element), thereby substantially decreasing the computational work required for each iteration of the global solve.\n\n**Global Degree-of-Freedom Counting**\n\nFor a structured mesh of $N_x \\times N_y \\times N_z$ elements, we can count the total number of unknowns in the full and condensed systems. The interior DoFs are unique to each element, while the boundary DoFs are shared across elements at common edges and faces.\n\nThe total number of unknowns in the condensed system, $N_{\\text{condensed}}$, is the sum of all unique boundary DoFs across the mesh. These are associated with the mesh edges and faces.\nNumber of edges:\n-   $x$-aligned: $N_{\\text{edges},x} = N_x (N_y + 1) (N_z + 1)$\n-   $y$-aligned: $N_{\\text{edges},y} = N_y (N_x + 1) (N_z + 1)$\n-   $z$-aligned: $N_{\\text{edges},z} = N_z (N_x + 1) (N_y + 1)$\nTotal edges: $N_{\\text{edges}} = N_{\\text{edges},x} + N_{\\text{edges},y} + N_{\\text{edges},z}$\nEach edge carries $p$ DoFs.\n\nNumber of faces:\n-   Orthogonal to $x$-axis: $N_{\\text{faces},x} = (N_x + 1) N_y N_z$\n-   Orthogonal to $y$-axis: $N_{\\text{faces},y} = N_x (N_y + 1) N_z$\n-   Orthogonal to $z$-axis: $N_{\\text{faces},z} = N_x N_y (N_z + 1)$\nTotal faces: $N_{\\text{faces}} = N_{\\text{faces},x} + N_{\\text{faces},y} + N_{\\text{faces},z}$\nEach face carries $2p(p-1)$ tangential DoFs.\n\nThus, the total number of unknowns in the condensed system is:\n$$\nN_{\\text{condensed}} = p \\cdot N_{\\text{edges}} + 2p(p-1) \\cdot N_{\\text{faces}}\n$$\nNote that for $p=1$, the face contribution vanishes, as expected.\n\nThe total number of unknowns in the full system, $N_{\\text{full}}$, is the sum of the condensed system unknowns and all interior unknowns across all elements.\nTotal number of elements is $N_e = N_x N_y N_z$.\nEach element has $N_{I, \\text{elem}} = 3p(p-1)^2$ interior DoFs.\n$$\nN_{\\text{full}} = N_{\\text{condensed}} + N_{I, \\text{elem}} \\cdot N_e = N_{\\text{condensed}} + 3p(p-1)^2 \\cdot (N_x N_y N_z)\n$$\nThese formulas allow for the direct computation of system sizes for both approaches.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the number of unknowns for full and statically condensed systems\n    in a Spectral Element Method discretization for electromagnetics.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (p, Nx, Ny, Nz)\n    test_cases = [\n        (1, 1, 1, 1),\n        (2, 1, 1, 1),\n        (4, 2, 2, 2),\n        (8, 1, 2, 3),\n        (10, 3, 3, 1),\n    ]\n\n    results = []\n    for case in test_cases:\n        p, Nx, Ny, Nz = case\n\n        # Ensure integer types for calculations to avoid float precision issues\n        p, Nx, Ny, Nz = int(p), int(Nx), int(Ny), int(Nz)\n\n        # Calculate the total number of unique edges in the structured mesh\n        num_edges_x = Nx * (Ny + 1) * (Nz + 1)\n        num_edges_y = Ny * (Nx + 1) * (Nz + 1)\n        num_edges_z = Nz * (Nx + 1) * (Ny + 1)\n        total_edges = num_edges_x + num_edges_y + num_edges_z\n\n        # Calculate the total number of unique faces in the structured mesh\n        num_faces_x = (Nx + 1) * Ny * Nz\n        num_faces_y = Nx * (Ny + 1) * Nz\n        num_faces_z = Nx * Ny * (Nz + 1)\n        total_faces = num_faces_x + num_faces_y + num_faces_z\n\n        # Degrees of freedom (DoFs) per geometric entity based on polynomial order p\n        # For p=1, there are no face or interior DoFs.\n        dofs_per_edge = p\n        if p > 1:\n            dofs_per_face = 2 * p * (p - 1)\n            dofs_per_interior = 3 * p * (p - 1)**2\n        else: # p=1 case\n            dofs_per_face = 0\n            dofs_per_interior = 0\n\n        # Calculate the total number of unknowns in the statically condensed system\n        # This is the sum of boundary DoFs (on edges and faces).\n        N_condensed = (dofs_per_edge * total_edges) + (dofs_per_face * total_faces)\n\n        # Calculate the total number of unknowns in the full system\n        # This is the condensed size plus the interior DoFs for all elements.\n        num_elements = Nx * Ny * Nz\n        total_interior_dofs = dofs_per_interior * num_elements\n        N_full = N_condensed + total_interior_dofs\n        \n        # Calculate the ratio as a proxy for per-iteration cost reduction\n        # Handle the case where N_condensed could be 0, though not possible for p>=1.\n        if N_condensed > 0:\n            ratio = N_full / N_condensed\n        else:\n            ratio = 1.0 # If no boundary DoFs, full and condensed are same (e.g., size 0)\n\n        # Format results for the current test case\n        # N_full and N_condensed are integers, ratio is float\n        case_result = [N_full, N_condensed, ratio]\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # Example: [[12,12,1.0],[54,48,1.125]]\n    # Using str(item) handles converting lists to strings '[...]'\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3350015"}, {"introduction": "While high-order accuracy is a primary advantage of SEM, it can be compromised by seemingly minor implementation shortcuts, particularly in how integrals in the weak form are approximated. This coding exercise [@problem_id:3350051] addresses the practical consequences of 'variational crimes,' where inexact numerical quadrature is used for assembling matrices, a common issue with spatially varying material properties. By building and testing a 1D solver, you will gain first-hand experience quantifying the impact of different integration strategies on the accuracy of computed eigenfrequencies and scattering parameters.", "problem": "Consider the one-dimensional time-harmonic reduction of Maxwell's equations for a linearly polarized field in a lossless, non-magnetic medium on the unit interval $[0,1]$. Under separation of variables and assuming piecewise smooth permittivity, the electric field component $u(x)$ satisfies the scalar Helmholtz-type model. Two settings are of interest:\n\n1. An eigenfrequency problem (closed cavity with perfectly conducting boundaries): find angular frequency $\\omega$ and nontrivial $u(x)$ such that\n$$\n-\\frac{d^2 u}{dx^2} = \\omega^2 \\mu_0 \\epsilon_0 \\epsilon_r(x) u \\quad \\text{in } (0,1), \\quad u(0)=0, \\; u(1)=0,\n$$\nwhere $\\epsilon_r(x)$ is the relative permittivity, $\\epsilon_0$ is the vacuum permittivity, and $\\mu_0$ is the vacuum permeability. Use nondimensionalized units so that $\\mu_0 \\epsilon_0 = 1$, implying the continuous exact fundamental eigenfrequency for constant $\\epsilon_r(x) \\equiv 1$ is $\\omega_1 = \\pi$.\n\n2. A driven scattering problem on $(0,1)$: for a given real wavenumber $k > 0$ and constant $\\epsilon_r(x) \\equiv 1$, find $u(x)$ satisfying\n$$\n-\\frac{d^2 u}{dx^2} - k^2 u = 0 \\quad \\text{in } (0,1),\n$$\nwith first-order absorbing boundary condition at $x=1$, and an incident plane wave of unit amplitude imposed at $x=0$. Consistently, use Robin-type conditions\n$$\n\\frac{du}{dx}(1) - i k u(1) = 0, \\quad \\frac{du}{dx}(0) + i k u(0) = 2 i k,\n$$\nso that the exact continuous reflection amplitude at $x=0$ is zero. The discrete estimate of the reflection coefficient is taken as\n$$\nR = \\frac{i k u(0) - u'(0)}{i k u(0) + u'(0)},\n$$\nand we measure $|R|$.\n\nDiscretize both problems using the high-order Spectral Element Method (SEM) on a mesh of $N_e$ uniform elements on $[0,1]$ with polynomial degree $p$ Lagrange basis functions $\\{\\ell_j(\\xi)\\}_{j=0}^{p}$ constructed at Gauss-Lobatto-Legendre (GLL) nodes $\\{\\xi_j\\}_{j=0}^{p}$ on the reference interval $[-1,1]$. Let the element-wise affine map be $x(\\xi) = x_e^L + \\frac{h_e}{2}(\\xi+1)$ with Jacobian $J_e = \\frac{h_e}{2}$. The standard $H^1$-conforming SEM leads to element stiffness and mass matrices\n$$\nK_e = \\frac{1}{J_e} \\int_{-1}^{1} \\ell_i'(\\xi) \\ell_j'(\\xi) \\, d\\xi, \\quad\nM_e = J_e \\int_{-1}^{1} \\epsilon_r(x(\\xi)) \\ell_i(\\xi) \\ell_j(\\xi) \\, d\\xi,\n$$\nassembled globally in the usual way. The stiffness integral is a polynomial of degree at most $2p-2$ and is exactly integrated by GLL quadrature of order $p+1$, whereas the mass integral involves a product of two degree-$p$ polynomials and a potentially nonpolynomial coefficient and is the locus of “variational crimes.”\n\nInvestigate the impact of inexact quadrature in the mass matrix on the discrete eigenfrequencies and scattering amplitudes by contrasting two mass assembly strategies:\n\n- Inexact GLL mass (variational crime): approximate $M_e$ using GLL quadrature at the interpolation nodes $\\{\\xi_j\\}$ with weights $\\{w_j^{\\mathrm{GLL}}\\}$:\n$$\nM_e^{\\mathrm{GLL}} \\approx J_e \\sum_{q=0}^{p} w_q^{\\mathrm{GLL}} \\epsilon_r(x(\\xi_q)) \\ell_i(\\xi_q) \\ell_j(\\xi_q),\n$$\nwhich for constant $\\epsilon_r$ reduces to a diagonal element mass matrix but is inexact for degree $2p$ polynomials.\n\n- Overintegrated mass: approximate $M_e$ using Gauss-Legendre (GL) quadrature with $q = p+1$ points $\\{\\hat{\\xi}_m, \\hat{w}_m\\}_{m=1}^{q}$,\n$$\nM_e^{\\mathrm{OI}} \\approx J_e \\sum_{m=1}^{q} \\hat{w}_m \\epsilon_r(x(\\hat{\\xi}_m)) \\ell_i(\\hat{\\xi}_m) \\ell_j(\\hat{\\xi}_m),\n$$\nwhich exactly integrates the mass bilinear form for constant $\\epsilon_r$ (degree up to $2p$) and reduces aliasing for variable $\\epsilon_r(x)$.\n\nUse exact GLL for the stiffness matrix in all cases:\n$$\nK_e = \\frac{1}{J_e} \\sum_{q=0}^{p} w_q^{\\mathrm{GLL}} \\ell_i'(\\xi_q) \\ell_j'(\\xi_q).\n$$\n\nFrom first principles, derive the weak forms, the assembly formulae, and the boundary contributions for the scattering problem, and then implement a program that:\n\n- Assembles global matrices for both quadrature strategies.\n- Solves the generalized eigenproblem $K u = \\omega^2 M u$ with essential boundary conditions for the first eigenpair.\n- Solves the linear system for the driven scattering problem with the above Robin boundary conditions and evaluates the discrete reflection amplitude.\n\nProvide a test suite of parameter sets that exercise different aspects and edge cases. Use nondimensional units and report dimensionless results. Specifically, compute and output the following five scalar quantities as a single final result:\n\n1. For constant $\\epsilon_r(x) \\equiv 1$ on $[0,1]$, with $N_e = 2$ elements and degree $p=3$, compute the relative error $|\\omega_{1}^{\\mathrm{GLL}} - \\pi|/\\pi$ of the smallest eigenfrequency using inexact GLL mass.\n\n2. For the same setup as in item $1$, compute the relative error $|\\omega_{1}^{\\mathrm{OI}} - \\pi|/\\pi$ using overintegrated mass with $q=p+1$ Gauss-Legendre points.\n\n3. For variable permittivity $\\epsilon_r(x) = 1 + 0.3 \\cos(10 \\pi x)$, with $N_e = 8$ and $p=5$, compute the relative difference between the first eigenfrequencies obtained with inexact and overintegrated mass: $|\\omega_{1}^{\\mathrm{GLL}} - \\omega_{1}^{\\mathrm{OI}}| / |\\omega_{1}^{\\mathrm{OI}}|$.\n\n4. For the scattering problem with constant $\\epsilon_r \\equiv 1$, $N_e = 16$, $p=5$, and wavenumber $k = 12 \\pi$, compute the magnitude of the reflection coefficient $|R^{\\mathrm{GLL}}|$ using inexact mass.\n\n5. For the same scattering setup as in item $4$, compute $|R^{\\mathrm{OI}}|$ using overintegrated mass.\n\nAngle quantities are in radians. All five outputs are dimensionless real numbers. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[r1,r2,r3,r4,r5]\"), in the order described above. No input is required; all parameters are fixed as given in the test suite.", "solution": "The user has provided a problem that requires the implementation and comparison of two different mass matrix assembly strategies within the Spectral Element Method (SEM) framework for one-dimensional electromagnetic problems. The problems are the Helmholtz eigenvalue problem for a resonant cavity and a driven scattering problem with absorbing boundary conditions.\n\n### I. Problem Validation\n\nFirst, a rigorous validation of the problem statement is performed.\n\n**Step 1: Extract Givens**\n- **Eigenfrequency Problem**:\n  - Governing Equation: $-\\frac{d^2 u}{dx^2} = \\omega^2 \\epsilon_r(x) u$ on $x \\in (0,1)$, using nondimensional units where $\\mu_0 \\epsilon_0 = 1$.\n  - Boundary Conditions (BCs): $u(0)=0$, $u(1)=0$ (Perfect Electric Conductor).\n  - Reference Solution: For $\\epsilon_r(x) \\equiv 1$, the exact fundamental eigenfrequency is $\\omega_1 = \\pi$.\n\n- **Driven Scattering Problem**:\n  - Governing Equation: $-\\frac{d^2 u}{dx^2} - k^2 u = 0$ on $x \\in (0,1)$ for a given wavenumber $k>0$ and $\\epsilon_r(x) \\equiv 1$.\n  - BCs (Robin-type): $\\frac{du}{dx}(1) - i k u(1) = 0$ (absorbing) and $\\frac{du}{dx}(0) + i k u(0) = 2 i k$ (incident wave).\n  - Exact Solution: $u(x)=e^{ikx}$, for which the reflection coefficient is zero.\n  - Discrete Reflection Coefficient: $R = \\frac{i k u(0) - u'(0)}{i k u(0) + u'(0)}$.\n\n- **SEM Discretization**:\n  - Mesh: $N_e$ uniform elements on $[0,1]$.\n  - Basis: Degree-$p$ Lagrange polynomials on Gauss-Lobatto-Legendre (GLL) nodes.\n  - Stiffness Matrix ($K_e$): Exact integration using GLL quadrature of order $p+1$.\n  - Mass Matrix ($M_e$): Two variants are to be compared:\n    1.  **Inexact GLL mass ($M_e^{\\mathrm{GLL}}$)**: \"Mass lumping\" via GLL quadrature, yielding a diagonal matrix. This is a \"variational crime\" as the quadrature rule is inexact for the integrand $\\ell_i \\ell_j$.\n    2.  **Overintegrated mass ($M_e^{\\mathrm{OI}}$)**: Integration using a Gauss-Legendre (GL) rule with $q=p+1$ points, which is exact for constant $\\epsilon_r$.\n\n- **Test Suite**:\n  1.  Eigenproblem, $\\epsilon_r \\equiv 1$, $N_e=2$, $p=3$: Compute relative error of $\\omega_1^{\\mathrm{GLL}}$ vs $\\pi$.\n  2.  Eigenproblem, $\\epsilon_r \\equiv 1$, $N_e=2$, $p=3$: Compute relative error of $\\omega_1^{\\mathrm{OI}}$ vs $\\pi$.\n  3.  Eigenproblem, $\\epsilon_r(x) = 1 + 0.3 \\cos(10 \\pi x)$, $N_e=8$, $p=5$: Compute relative difference $|\\omega_1^{\\mathrm{GLL}} - \\omega_1^{\\mathrm{OI}}| / |\\omega_1^{\\mathrm{OI}}|$.\n  4.  Scattering, $k=12\\pi$, $N_e=16$, $p=5$: Compute $|R^{\\mathrm{GLL}}|$.\n  5.  Scattering, $k=12\\pi$, $N_e=16$, $p=5$: Compute $|R^{\\mathrm{OI}}|$.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientifically Grounded**: The problem is based on the scalar Helmholtz equation, a standard model derived from Maxwell's equations. The eigenproblem and scattering problem are canonical in wave physics and computational electromagnetics. All numerical methods mentioned (SEM, GLL/GL quadrature, mass lumping) are well-established. Verdict: **Valid**.\n- **Well-Posed**: The eigenproblem is a standard Sturm-Liouville problem, which is well-posed. The scattering problem with the specified Robin boundary conditions is also well-posed, and an exact solution is provided, confirming this. Their discrete counterparts are formulated as standard generalized eigenvalue and linear system problems, which are numerically solvable. Verdict: **Valid**.\n- **Objective**: All parameters, equations, and quantities to be computed are specified with mathematical precision. The language is objective and free of ambiguity. Verdict: **Valid**.\n- **Other Flaws**: The problem is complete, consistent, computationally feasible, and non-trivial. It addresses a core concept in numerical methods—the effect of quadrature error (\"variational crimes\") on solution accuracy.\n\n**Step 3: Verdict and Action**\nThe problem is **valid**. A complete, reasoned solution will be provided.\n\n### II. Derivation and Algorithmic Design\n\nThe solution requires implementing a one-dimensional, $H^1$-conforming Spectral Element Method.\n\n**1. Weak Formulation**\n\n*   **Eigenproblem**: Multiply $-\\frac{d^2 u}{dx^2} = \\omega^2 \\epsilon_r(x) u$ by a test function $v$ from the space $V = H_0^1(0,1) = \\{v \\in H^1(0,1) | v(0)=v(1)=0\\}$. Integrating by parts yields the weak form: Find $(\\omega^2, u) \\in (\\mathbb{R}, V)$ such that\n    $$ a(u,v) = \\int_0^1 u' v' dx = \\omega^2 \\int_0^1 \\epsilon_r(x) u v dx = \\omega^2 m(u,v) \\quad \\forall v \\in V. $$\n    Discretizing with $u(x) = \\sum_j u_j N_j(x)$ leads to the generalized matrix eigenvalue problem $K \\mathbf{u} = \\omega^2 M \\mathbf{u}$, where $K_{ij} = a(N_j, N_i)$ and $M_{ij} = m(N_j, N_i)$. The Dirichlet boundary conditions are enforced by restricting the problem to interior degrees of freedom.\n\n*   **Scattering Problem**: Multiply $-\\frac{d^2 u}{dx^2} - k^2 u = 0$ by a test function conjugate $\\bar{v}$ from $V = H^1(0,1)$. Integrating by parts yields:\n    $$ \\int_0^1 u' \\bar{v}' dx - [u'\\bar{v}]_0^1 - k^2 \\int_0^1 u \\bar{v} dx = 0. $$\n    Substituting the Robin BCs $u'(1) = i k u(1)$ and $u'(0) = -i k u(0) + 2ik$ into the boundary term $[u'\\bar{v}]_0^1 = u'(1)\\bar{v}(1) - u'(0)\\bar{v}(0)$ gives the weak form: Find $u \\in V$ such that for all $v \\in V$,\n    $$ \\underbrace{\\int_0^1 u' \\bar{v}' dx - k^2 \\int_0^1 u \\bar{v} dx - ik u(1)\\bar{v}(1) - ik u(0)\\bar{v}(0)}_{a(u,v)} = \\underbrace{-2ik\\bar{v}(0)}_{L(v)}. $$\n    Discretization leads to the linear system $A \\mathbf{u} = \\mathbf{b}$, where $A_{ij} = a(N_j, N_i)$ and $b_i = L(N_i)$. The matrix is $A = K - k^2 M - C$, where $C$ contains the boundary contributions. For the global nodal basis $N_j$, $C$ is a matrix with non-zero entries $C_{0,0} = ik$ and $C_{N_{dof}-1, N_{dof}-1} = ik$. The right-hand side vector $\\mathbf{b}$ has a single non-zero entry $b_0 = -2ik$.\n\n**2. SEM Implementation**\n\nThe core components are:\n*   **Basis Functions**: A helper class is constructed to manage the degree-$p$ Lagrange basis on the reference interval $[-1,1]$. It computes the GLL nodes, weights, and the crucial differentiation matrix $D_{ij} = \\ell_j'(\\xi_i)$, which is fundamental for forming the reference stiffness matrix.\n*   **Matrix Assembly**: A loop iterates through each of the $N_e$ elements.\n    *   The element stiffness matrix is calculated by scaling the reference stiffness matrix: $K_e = (1/J_e) K_{ref}$, where $J_e = h_e/2$ is the Jacobian of the affine map from $[-1,1]$ to the element.\n    *   The element mass matrix $M_e$ is computed according to the specified `mass_type`:\n        *   `GLL`: A diagonal matrix whose entries are products of the Jacobian, GLL weights, and permittivity values at the GLL nodes. $ (M_e^{\\mathrm{GLL}})_{ii} = J_e w_i^{\\mathrm{GLL}} \\epsilon_r(x(\\xi_i)) $.\n        *   `OI`: A full matrix computed by performing numerical quadrature using $q=p+1$ Gauss-Legendre points, which correctly integrates the polynomial part of the mass term for constant permittivity. $(M_e^{\\mathrm{OI}})_{ij} = J_e \\sum_{m=1}^{q} \\hat{w}_m \\epsilon_r(x(\\hat{\\xi}_m)) \\ell_i(\\hat{\\xi}_m) \\ell_j(\\hat{\\xi}_m)$.\n    *   Element matrices are added to the global `dof x dof` matrices using a standard local-to-global index mapping, where `dof` $= N_e p + 1$.\n\n**3. Problem Solvers**\n\n*   **Eigenproblem**: After assembly, the rows and columns corresponding to the boundary nodes ($x=0, 1$) are removed from $K$ and $M$ to enforce the Dirichlet conditions. The resulting smaller generalized eigenvalue problem is solved using `scipy.linalg.eigh`. The smallest returned eigenvalue corresponds to $\\omega_1^2$.\n*   **Scattering Problem**: The complex linear system $A \\mathbf{u} = \\mathbf{b}$ is constructed and solved using `numpy.linalg.solve`. To compute the reflection coefficient $R$, an estimate for the derivative $u'(0)$ is required. This is obtained from the numerical solution $\\mathbf{u}$ using the differentiation matrix for the first element: $u'(0) = (1/J_0)\\sum_{j=0}^{p} u_j D_{0j}$, where $u_j$ are the first $p+1$ components of $\\mathbf{u}$.\n\nThis structured approach ensures that all aspects of the problem are handled correctly, from the underlying mathematical theory to the specific implementation details of the SEM.", "answer": "```python\nimport numpy as np\nimport scipy.special\nimport scipy.linalg\nfrom numpy.polynomial.legendre import leggauss\n\nclass _SpectralBasis:\n    \"\"\"\n    A helper class to manage properties of 1D Lagrange polynomial basis \n    functions defined on Gauss-Lobatto-Legendre (GLL) nodes.\n    \"\"\"\n    def __init__(self, p):\n        self.p = p\n        \n        if p == 0:\n            self.nodes = np.array([-1.0])\n            self.weights = np.array([2.0])\n        else:\n            # GLL nodes are the endpoints [-1, 1] and the roots of the \n            # derivative of the degree-p Legendre polynomial, L_p'.\n            coeffs = scipy.special.legendre(p)\n            deriv_coeffs = coeffs.deriv()\n            interior_nodes = np.roots(deriv_coeffs)\n            self.nodes = np.unique(np.sort(np.concatenate(([-1.0], interior_nodes, [1.0]))))\n            \n            # GLL weights are calculated from the values of L_p at the nodes.\n            lp_vals = scipy.special.eval_legendre(p, self.nodes)\n            self.weights = 2.0 / (p * (p + 1) * lp_vals**2)\n\n        # The differentiation matrix D_ij = l_j'(xi_i) is pre-computed.\n        self.diff_matrix = self._compute_diff_matrix()\n        \n    def _compute_diff_matrix(self):\n        p, nodes = self.p, self.nodes\n        D = np.zeros((p + 1, p + 1))\n        lp_vals = scipy.special.eval_legendre(p, nodes)\n        \n        for i in range(p + 1):\n            for j in range(p + 1):\n                if i != j:\n                    D[i, j] = lp_vals[i] / (lp_vals[j] * (nodes[i] - nodes[j]))\n        \n        if p > 0:\n            D[0, 0] = -p * (p + 1) / 4.0\n            D[p, p] = p * (p + 1) / 4.0\n        return D\n\n    def lagrange_basis_at_points(self, eval_points):\n        \"\"\"Evaluates all p+1 Lagrange basis functions at a set of points.\"\"\"\n        p, nodes = self.p, self.nodes\n        L = np.ones((len(eval_points), p + 1))\n        for j in range(p + 1):\n            for i in range(len(eval_points)):\n                val = 1.0\n                for m in range(p + 1):\n                    if m != j:\n                        val *= (eval_points[i] - nodes[m]) / (nodes[j] - nodes[m])\n                L[i, j] = val\n        return L\n\ndef _run_calculation(params):\n    \"\"\"\n    Performs a single SEM calculation for a given set of parameters.\n    This function handles both eigenproblems and scattering problems.\n    \"\"\"\n    Ne, p, eps_r_func, mass_type, k = params\n    \n    basis = _SpectralBasis(p)\n    dof = Ne * p + 1\n    h = 1.0 / Ne\n    \n    K_global = np.zeros((dof, dof))\n    M_global = np.zeros((dof, dof))\n\n    # Reference element stiffness matrix (integrated exactly with GLL quadrature)\n    K_ref = basis.diff_matrix.T @ np.diag(basis.weights) @ basis.diff_matrix\n\n    # Assembly loop over elements\n    for e in range(Ne):\n        J = h / 2.0  # Jacobian of the affine map\n        x_left = e * h\n        \n        # Scale reference stiffness matrix\n        K_elem = (1.0 / J) * K_ref\n        \n        # Compute element mass matrix based on the specified strategy\n        if mass_type == 'GLL':\n            elem_nodes_x = x_left + J * (basis.nodes + 1)\n            eps_vals = eps_r_func(elem_nodes_x)\n            M_elem = J * np.diag(basis.weights * eps_vals)\n        elif mass_type == 'OI':\n            q = p + 1 # Number of quadrature points for over-integration\n            gl_nodes, gl_weights = leggauss(q)\n            \n            L_at_gl = basis.lagrange_basis_at_points(gl_nodes)\n            gl_nodes_x = x_left + J * (gl_nodes + 1)\n            eps_vals_at_gl = eps_r_func(gl_nodes_x)\n            \n            W_eps = np.diag(gl_weights * eps_vals_at_gl)\n            M_elem_ref = L_at_gl.T @ W_eps @ L_at_gl\n            M_elem = J * M_elem_ref\n        \n        # Add element contributions to global matrices\n        for i in range(p + 1):\n            for j in range(p + 1):\n                g_i, g_j = e * p + i, e * p + j\n                K_global[g_i, g_j] += K_elem[i, j]\n                M_global[g_i, g_j] += M_elem[i, j]\n    \n    # EIGENPROBLEM SOLVER\n    if k is None:\n        # Enforce u(0)=u(1)=0 by using only interior degrees of freedom\n        interior_dofs = slice(1, dof - 1)\n        K_int = K_global[interior_dofs, interior_dofs]\n        M_int = M_global[interior_dofs, interior_dofs]\n        \n        # Solve the generalized eigenvalue problem K*u = lambda*M*u\n        eigenvalues, _ = scipy.linalg.eigh(K_int, M_int)\n        omega_sq = eigenvalues[0] # Smallest eigenvalue\n        return np.sqrt(omega_sq)\n        \n    # SCATTERING PROBLEM SOLVER\n    else:\n        # Form complex system matrix A = K - k^2*M - C_boundary\n        A = (K_global - k**2 * M_global).astype(np.complex128)\n        A[0, 0] -= 1j * k\n        A[dof-1, dof-1] -= 1j * k\n        \n        # Form right-hand side vector from boundary condition\n        b = np.zeros(dof, dtype=np.complex128)\n        b[0] = -2j * k\n        \n        # Solve the linear system\n        u_sol = np.linalg.solve(A, b)\n        \n        # Calculate reflection coefficient R from the numerical solution\n        u0 = u_sol[0]\n        J0 = h / 2.0\n        D_first_row = basis.diff_matrix[0, :]\n        u_prime_0 = (1.0 / J0) * np.dot(u_sol[:p + 1], D_first_row)\n        \n        numerator = 1j * k * u0 - u_prime_0\n        denominator = 1j * k * u0 + u_prime_0\n        \n        R = numerator / denominator if np.abs(denominator) > 1e-15 else 0.\n        return np.abs(R)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the permittivity functions for the test cases\n    eps_r_const = lambda x: np.ones_like(x, dtype=float)\n    eps_r_variable = lambda x: 1.0 + 0.3 * np.cos(10 * np.pi * x)\n\n    # Define the parameter sets for the five required calculations\n    # Format: (Ne, p, eps_r_func, mass_type, k)\n    # k=None indicates an eigenproblem.\n    test_cases = [\n        # 1. Eigenproblem, GLL mass, constant eps_r\n        (2, 3, eps_r_const, 'GLL', None),\n        # 2. Eigenproblem, OI mass, constant eps_r\n        (2, 3, eps_r_const, 'OI', None),\n        # 3. Eigenproblem, variable eps_r, comparison\n        {'Ne': 8, 'p': 5, 'eps_r': eps_r_variable},\n        # 4. Scattering, GLL mass\n        (16, 5, eps_r_const, 'GLL', 12 * np.pi),\n        # 5. Scattering, OI mass\n        (16, 5, eps_r_const, 'OI', 12 * np.pi),\n    ]\n\n    results = []\n\n    # Case 1\n    omega1_gll = _run_calculation(test_cases[0])\n    results.append(np.abs(omega1_gll - np.pi) / np.pi)\n\n    # Case 2\n    omega1_oi = _run_calculation(test_cases[1])\n    results.append(np.abs(omega1_oi - np.pi) / np.pi)\n\n    # Case 3\n    params_gll = (test_cases[2]['Ne'], test_cases[2]['p'], test_cases[2]['eps_r'], 'GLL', None)\n    params_oi = (test_cases[2]['Ne'], test_cases[2]['p'], test_cases[2]['eps_r'], 'OI', None)\n    omega1_var_gll = _run_calculation(params_gll)\n    omega1_var_oi = _run_calculation(params_oi)\n    results.append(np.abs(omega1_var_gll - omega1_var_oi) / np.abs(omega1_var_oi))\n    \n    # Case 4\n    results.append(_run_calculation(test_cases[3]))\n\n    # Case 5\n    results.append(_run_calculation(test_cases[4]))\n\n    # Print results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3350051"}]}