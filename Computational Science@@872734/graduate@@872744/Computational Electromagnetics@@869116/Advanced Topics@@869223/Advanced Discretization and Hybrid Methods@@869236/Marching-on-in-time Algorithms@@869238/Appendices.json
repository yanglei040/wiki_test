{"hands_on_practices": [{"introduction": "Any physical simulation must obey the fundamental laws of physics, and for electromagnetics, the finite speed of light imposes a strict causality condition: an effect cannot precede its cause. This practice provides a concrete method for verifying that a Marching-on-in-Time (MOT) algorithm respects this principle, a critical step in code validation [@problem_id:3328621]. By designing a detector for pre-causal artifacts in a synthetic signal, you will gain hands-on experience with a crucial diagnostic tool for time-domain solvers.", "problem": "You are asked to formalize and implement a causality test for time-domain boundary integral equation solvers that use Marching-on-in-Time (MOT) updates in computational electromagnetics. The goal is to design a programmatic detector that, given a discrete-time surface current response to an impulsive excitation, determines whether any nonzero current appears before the physically mandated retarded time of influence due to finite propagation speed.\n\nBegin from the following foundational principles and definitions.\n\n- In free space, Maxwell’s equations imply that electromagnetic disturbances propagate at the speed of light $c$. For an impulsive excitation at a source patch located at position $\\mathbf{r}_{s}$ and an observation patch at position $\\mathbf{r}_{o}$, the Euclidean distance is $R = \\lVert \\mathbf{r}_{o} - \\mathbf{r}_{s} \\rVert$. The retarded time of first influence is $t_{\\star} = R / c$. For $t  t_{\\star}$, the fields and the induced surface current density are identically zero in the ideal continuous-time, continuous-space model.\n\n- In a Marching-on-in-Time (MOT) scheme for the time-domain Electric Field Integral Equation (EFIE), time is discretized at sample times $t_{n} = n \\Delta t$ for nonnegative integers $n$, where $\\Delta t$ is the fixed time step. A discrete-time impulsive excitation is applied at $n = 0$ at a source patch. If the solver is causal, the observed discrete surface current samples $J_{o}[n]$ at a distant patch must satisfy $J_{o}[n] = 0$ for all $n$ such that $t_{n}  t_{\\star}$. For $t_{n} \\ge t_{\\star}$, $J_{o}[n]$ may be nonzero.\n\n- We will model the observed discrete current response $J_{o}[n]$ by a synthetic, fully specified, piecewise function that captures an ideal causal response and, optionally, a pre-causal “echo” to simulate a causality violation. This allows testing the detector without access to a full MOT code.\n\nDefine the synthetic observed current sequence for $n = 0,1,\\ldots,N-1$ at times $t_{n} = n \\Delta t$ as\n$$\nJ_{o}[n] =\n\\begin{cases}\nA \\exp\\!\\big(-\\alpha \\left(t_{n} - t_{\\star}\\right)\\big),  t_{n} \\ge t_{\\star}, \\\\\n0,  t_{n}  t_{\\star},\n\\end{cases}\n\\quad\\text{(causal part)}\n$$\naugmented by an optional pre-causal Gaussian “echo” defined for $t_{n}  t_{\\star}$ as\n$$\nJ_{\\text{pre}}[n] = A_{\\text{pre}} \\exp\\!\\left(-\\dfrac{\\left(t_{n} - \\left(t_{\\star} - \\tau_{\\text{pre}}\\right)\\right)^{2}}{\\sigma_{\\text{pre}}^{2}}\\right),\n$$\nwhere $A$ is a positive amplitude for the causal exponential tail, $\\alpha$ is a positive decay rate in $\\mathrm{s}^{-1}$, $A_{\\text{pre}} \\ge 0$ is the peak pre-echo amplitude, $\\tau_{\\text{pre}}  0$ positions the pre-echo center before $t_{\\star}$ by $\\tau_{\\text{pre}}$, and $\\sigma_{\\text{pre}}  0$ controls the width. The full synthetic observed sequence is\n$$\nJ_{o}[n] \\leftarrow J_{o}[n] + \\begin{cases}\nJ_{\\text{pre}}[n],  t_{n}  t_{\\star}, \\\\\n0,  t_{n} \\ge t_{\\star}.\n\\end{cases}\n$$\n\nDefine a causality violation detector as follows. Given parameters $(R, c, \\Delta t, N, A, \\alpha, A_{\\text{pre}}, \\tau_{\\text{pre}}, \\sigma_{\\text{pre}}, \\varepsilon)$, synthesize $J_{o}[n]$ using the above rules with $t_{\\star} = R/c$ and test whether there exists any index $n$ with $t_{n}  t_{\\star}$ such that $\\lvert J_{o}[n] \\rvert  \\varepsilon$. If such an $n$ exists, declare a violation (boolean value $\\mathrm{True}$); otherwise, declare no violation (boolean value $\\mathrm{False}$). The tolerance $\\varepsilon$ is a user-specified nonnegative threshold to avoid flagging insignificant numerical noise. Note that the equality $\\lvert J_{o}[n] \\rvert = \\varepsilon$ is not to be flagged as a violation.\n\nImplement a program to apply this detector to the following test suite. All distances must be treated in meters, all times in seconds, decay rates in inverse seconds, and the current amplitude parameters are dimensionless in this synthetic model. Use the speed of light in vacuum $c = 299\\,792\\,458\\ \\mathrm{m/s}$.\n\nYour program must synthesize the sequences exactly as specified and produce, for each case, a single boolean indicating whether a violation is detected.\n\nTest Suite (each case provides $(R, \\Delta t, N, A, \\alpha, A_{\\text{pre}}, \\tau_{\\text{pre}}, \\sigma_{\\text{pre}}, \\varepsilon)$; $c$ is fixed to $299\\,792\\,458\\ \\mathrm{m/s}$):\n- Case 1 (happy path, strictly causal):\n  - $R = 5.0\\ \\mathrm{m}$,\n  - $\\Delta t = 1.0 \\times 10^{-9}\\ \\mathrm{s}$,\n  - $N = 64$,\n  - $A = 1.0$,\n  - $\\alpha = 5.0 \\times 10^{7}\\ \\mathrm{s}^{-1}$,\n  - $A_{\\text{pre}} = 0.0$,\n  - $\\tau_{\\text{pre}} = 1.0 \\times 10^{-9}\\ \\mathrm{s}$,\n  - $\\sigma_{\\text{pre}} = 5.0 \\times 10^{-10}\\ \\mathrm{s}$,\n  - $\\varepsilon = 1.0 \\times 10^{-6}$.\n\n- Case 2 (boundary equality $t_{\\star}$ on-grid):\n  - $R = 5.99584916\\ \\mathrm{m}$, which equals $c \\times 20.0 \\times 10^{-9}\\ \\mathrm{s}$,\n  - $\\Delta t = 1.0 \\times 10^{-9}\\ \\mathrm{s}$,\n  - $N = 40$,\n  - $A = 1.0$,\n  - $\\alpha = 5.0 \\times 10^{7}\\ \\mathrm{s}^{-1}$,\n  - $A_{\\text{pre}} = 0.0$,\n  - $\\tau_{\\text{pre}} = 1.0 \\times 10^{-9}\\ \\mathrm{s}$,\n  - $\\sigma_{\\text{pre}} = 5.0 \\times 10^{-10}\\ \\mathrm{s}$,\n  - $\\varepsilon = 1.0 \\times 10^{-6}$.\n\n- Case 3 (near-causal pre-echo below threshold):\n  - $R = 5.0\\ \\mathrm{m}$,\n  - $\\Delta t = 1.0 \\times 10^{-9}\\ \\mathrm{s}$,\n  - $N = 64$,\n  - $A = 1.0$,\n  - $\\alpha = 5.0 \\times 10^{7}\\ \\mathrm{s}^{-1}$,\n  - $A_{\\text{pre}} = 1.0 \\times 10^{-5}$,\n  - $\\tau_{\\text{pre}} = 3.0 \\times 10^{-9}\\ \\mathrm{s}$,\n  - $\\sigma_{\\text{pre}} = 1.0 \\times 10^{-9}\\ \\mathrm{s}$,\n  - $\\varepsilon = 1.0 \\times 10^{-4}$.\n\n- Case 4 (explicit causality violation above threshold):\n  - $R = 5.0\\ \\mathrm{m}$,\n  - $\\Delta t = 1.0 \\times 10^{-9}\\ \\mathrm{s}$,\n  - $N = 64$,\n  - $A = 1.0$,\n  - $\\alpha = 5.0 \\times 10^{7}\\ \\mathrm{s}^{-1}$,\n  - $A_{\\text{pre}} = 1.0 \\times 10^{-2}$,\n  - $\\tau_{\\text{pre}} = 3.0 \\times 10^{-9}\\ \\mathrm{s}$,\n  - $\\sigma_{\\text{pre}} = 1.0 \\times 10^{-9}\\ \\mathrm{s}$,\n  - $\\varepsilon = 1.0 \\times 10^{-4}$.\n\n- Case 5 (edge case at threshold equality):\n  - $R = 5.0\\ \\mathrm{m}$,\n  - $\\Delta t = 1.0 \\times 10^{-9}\\ \\mathrm{s}$,\n  - $N = 64$,\n  - $A = 1.0$,\n  - $\\alpha = 5.0 \\times 10^{7}\\ \\mathrm{s}^{-1}$,\n  - $A_{\\text{pre}} = 5.0 \\times 10^{-3}$,\n  - $\\tau_{\\text{pre}} = 6.782047599076 \\times 10^{-10}\\ \\mathrm{s}$,\n  - $\\sigma_{\\text{pre}} = 2.0 \\times 10^{-10}\\ \\mathrm{s}$,\n  - $\\varepsilon = 5.0 \\times 10^{-3}$.\n  This choice of $\\tau_{\\text{pre}}$ centers the pre-echo at the last strictly pre-causal sample for $R = 5.0\\ \\mathrm{m}$ and $\\Delta t = 1.0 \\times 10^{-9}\\ \\mathrm{s}$, since $t_{\\star} = R / c \\approx 1.66782047599076 \\times 10^{-8}\\ \\mathrm{s}$ and $t_{16} = 1.6 \\times 10^{-8}\\ \\mathrm{s}$, hence $\\tau_{\\text{pre}} \\approx t_{\\star} - t_{16} = 6.782047599076 \\times 10^{-10}\\ \\mathrm{s}$. With this configuration, the peak pre-echo magnitude equals $\\varepsilon$ at a strictly pre-causal index and must not be flagged.\n\nYour program should:\n- Implement the synthesis rule and detector as defined.\n- Apply the detector to the five cases in the order listed.\n- Produce a single line of output containing the five boolean results as a comma-separated list enclosed in square brackets, with no spaces. For example, an output could look like $[\\mathrm{False},\\mathrm{True},\\ldots]$ but with the actual booleans for the specified cases.\n\nThere is no user input. All constants and parameters are as given above. The final outputs are booleans, so no physical unit applies to the outputs. Ensure all internal quantities that represent time are in seconds and all distances are in meters, using $c = 299\\,792\\,458\\ \\mathrm{m/s}$.", "solution": "The problem is valid as it is scientifically grounded in the principles of computational electromagnetics, well-posed with a clear and objective set of definitions and constraints, and requires the implementation of a specific, verifiable algorithm.\n\nThe core of the problem lies in the principle of causality as dictated by Maxwell's equations. In a vacuum, effects cannot propagate faster than the speed of light, $c$. For a source at position $\\mathbf{r}_s$ and an observer at $\\mathbf{r}_o$, the earliest time an influence can be felt is the retarded time, $t_{\\star} = R/c$, where $R = \\lVert \\mathbf{r}_{o} - \\mathbf{r}_{s} \\rVert$ is the Euclidean distance. Before this time, for all $t  t_{\\star}$, any fields or induced currents at the observer's location must be identically zero.\n\nIn the context of a numerical Marching-on-in-Time (MOT) algorithm, time is discretized into steps $t_n = n \\Delta t$ for non-negative integers $n$. A causal MOT solver must computationally enforce the physical principle, ensuring the discrete surface current $J_o[n]$ is zero for all time indices $n$ such that $t_n  t_{\\star}$.\n\nThe task is to design a detector for violations of this discrete causality condition. The methodology is based on a synthetic current signal $J_o[n]$ which models an ideal response combined with a potential non-causal artifact. The full synthetic signal is given by the sum of a causal part and a pre-causal part. The causal part, which is non-zero only for $t_n \\ge t_{\\star}$, is defined as\n$$\nJ_{o}[n] = A \\exp\\!\\big(-\\alpha \\left(t_{n} - t_{\\star}\\right)\\big), \\quad t_{n} \\ge t_{\\star}.\n$$\nThe pre-causal part, or \"echo,\" exists only for $t_n  t_{\\star}$ and is modeled as a Gaussian pulse:\n$$\nJ_{\\text{pre}}[n] = A_{\\text{pre}} \\exp\\!\\left(-\\dfrac{\\left(t_{n} - \\left(t_{\\star} - \\tau_{\\text{pre}}\\right)\\right)^{2}}{\\sigma_{\\text{pre}}^{2}}\\right), \\quad t_n  t_{\\star}.\n$$\nThe complete signal is the sum of these two components, each restricted to its respective time domain.\n\nThe causality detector must determine if there exists any time index $n$ in the pre-causal domain ($t_n  t_{\\star}$) for which the magnitude of the signal, $|J_o[n]|$, is strictly greater than a specified numerical tolerance, $\\varepsilon$.\n\nA crucial simplification arises from the definitions. For any time $t_n  t_{\\star}$, the causal component of $J_o[n]$ is zero by definition. Therefore, in the pre-causal epoch, the total signal $J_o[n]$ is equal to the pre-causal echo $J_{\\text{pre}}[n]$. The test for a causality violation thus reduces to checking if $|J_{\\text{pre}}[n]|  \\varepsilon$ for any $n$ where $t_n  t_{\\star}$.\n\nThe algorithm implemented is as follows:\n$1$. For a given set of parameters $(R, \\Delta t, N, A, \\alpha, A_{\\text{pre}}, \\tau_{\\text{pre}}, \\sigma_{\\text{pre}}, \\varepsilon)$, calculate the retarded time $t_{\\star} = R/c$, using $c = 299\\,792\\,458\\ \\mathrm{m/s}$.\n$2$. A key logical optimization is performed first. The maximum value of the Gaussian function $J_{\\text{pre}}[n]$ is its amplitude $A_{\\text{pre}}$. If $A_{\\text{pre}} \\le \\varepsilon$, it is impossible for the condition $J_{\\text{pre}}[n]  \\varepsilon$ to be satisfied for any $n$. Therefore, if $A_{\\text{pre}} = 0$ (no pre-causal signal) or if its maximum possible value is not strictly greater than the threshold, we can immediately conclude there is no violation (`False`). This correctly handles the case where the peak pre-causal signal is exactly equal to the threshold, as specified in the problem ($|J_o[n]| = \\varepsilon$ is not a violation).\n$3$. If $A_{\\text{pre}}  \\varepsilon$, a violation is possible. The algorithm iterates through the time indices $n$ from $0$ up to $N-1$.\n$4$. For each $n$, the time $t_n = n \\Delta t$ is calculated. If $t_n \\ge t_{\\star}$, we have entered the causal domain, so the search for pre-causal violations can terminate.\n$5$. For each time step in the pre-causal domain ($t_n  t_{\\star}$), the value of $J_{\\text{pre}}[n]$ is computed. Since $A_{\\text{pre}} \\ge 0$, the exponential term is always positive, so $|J_{\\text{pre}}[n]| = J_{\\text{pre}}[n]$.\n$6$. This value is compared to the threshold $\\varepsilon$. If $J_{\\text{pre}}[n]  \\varepsilon$, a causality violation has been found, and the function returns `True`.\n$7$. If the loop over all relevant pre-causal indices $n$ completes without the condition being met, no violation exists, and the function returns `False`.\nThis procedure is applied to each of the five test cases to produce the final list of boolean results.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and runs a causality test for synthetic MOT signals.\n    \"\"\"\n\n    def causality_detector(params):\n        \"\"\"\n        Detects causality violations for a single test case.\n\n        A violation occurs if |J_o[n]|  epsilon for any t_n  t_star.\n        For t_n  t_star, J_o[n] is identical to the pre-causal component J_pre[n].\n        \"\"\"\n        R, dt, N, A, alpha, A_pre, tau_pre, sigma_pre, epsilon = params\n        C = 299792458.0  # Speed of light in m/s\n\n        t_star = R / C\n\n        # Optimization: If the peak amplitude of the pre-causal echo is not strictly\n        # greater than the threshold, no violation is possible, as the exponential\n        # term is at most 1. This also correctly handles A_pre = 0 and the\n        # equality case |J_o[n]| = epsilon.\n        if A_pre = epsilon:\n            return False\n\n        # Iterate through discrete time steps up to the retarded time\n        for n in range(N):\n            t_n = n * dt\n\n            # We are only interested in the pre-causal time domain\n            if t_n = t_star:\n                break  # Exit loop once we reach or pass the retarded time\n\n            # Calculate the pre-causal echo signal value at time t_n\n            t_center = t_star - tau_pre\n            exponent_numerator = (t_n - t_center)**2\n            exponent_denominator = sigma_pre**2\n            \n            # Avoid division by zero, although sigma_pre  0 is a given\n            if exponent_denominator == 0:\n                # This case should not be reached given problem constraints\n                j_pre_n = 0.0 if exponent_numerator  0 else A_pre\n            else:\n                exponent = -exponent_numerator / exponent_denominator\n                j_pre_n = A_pre * np.exp(exponent)\n\n            # Check for violation. The signal is non-negative, so abs() is not needed.\n            # The condition is strictly greater than epsilon.\n            if j_pre_n  epsilon:\n                return True  # Violation detected\n\n        # If the loop completes without finding any violation\n        return False\n\n    # Test Suite (R, delta_t, N, A, alpha, A_pre, tau_pre, sigma_pre, epsilon)\n    test_cases = [\n        # Case 1: happy path, strictly causal (A_pre = 0)\n        (5.0, 1.0e-9, 64, 1.0, 5.0e7, 0.0, 1.0e-9, 5.0e-10, 1.0e-6),\n        # Case 2: t_star on-grid, causal (A_pre = 0)\n        (5.99584916, 1.0e-9, 40, 1.0, 5.0e7, 0.0, 1.0e-9, 5.0e-10, 1.0e-6),\n        # Case 3: pre-echo below threshold (A_pre  epsilon)\n        (5.0, 1.0e-9, 64, 1.0, 5.0e7, 1.0e-5, 3.0e-9, 1.0e-9, 1.0e-4),\n        # Case 4: explicit causality violation (A_pre  epsilon and echo is significant)\n        (5.0, 1.0e-9, 64, 1.0, 5.0e7, 1.0e-2, 3.0e-9, 1.0e-9, 1.0e-4),\n        # Case 5: edge case at threshold equality (A_pre = epsilon)\n        (5.0, 1.0e-9, 64, 1.0, 5.0e7, 5.0e-3, 6.782047599076e-10, 2.0e-10, 5.0e-3),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = causality_detector(case)\n        results.append(result)\n\n    # Format the output as a comma-separated list of booleans in brackets.\n    # Python's str() of a boolean is 'True' or 'False', which matches the desired format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3328621"}, {"introduction": "Beyond correctness, the quality of a wave solver is judged by its accuracy. A primary source of error in discrete simulations is numerical dispersion, a frequency-dependent phase error that distorts signals as they propagate. This exercise demonstrates a powerful technique for improving accuracy through the use of higher-order temporal basis functions [@problem_id:3328595]. By comparing the phase fidelity of reconstructions using different polynomial degrees, you will gain a practical understanding of how higher-order methods improve the performance of MOT simulations.", "problem": "Consider a time-domain retarded-potential model that captures the essential temporal structure encountered in marching-on-in-time (MOT) formulations of electromagnetic surface integral equations. Let the incident field be a known scalar excitation $E_{\\text{inc}}(t)$ and the induced current density be modeled as a scalar function $J(t)$ related by the retarded convolution\n$$\nJ(t) = \\int_{-\\infty}^{\\infty} g(t-\\tau) E_{\\text{inc}}(\\tau)\\, d\\tau,\n$$\nwhere the scalar kernel is the causal point-delay $g(t) = \\delta(t-\\tau_0)$ with a fixed propagation delay $\\tau_0  0$. By the sifting property of the Dirac delta function, the exact current is\n$$\nJ_{\\text{exact}}(t) = E_{\\text{inc}}(t - \\tau_0).\n$$\nIn marching-on-in-time, the current is represented on a uniform temporal grid with time step $\\Delta t$ using a finite-support temporal basis (also called temporal shape functions) as\n$$\nJ_r(t) \\approx \\sum_{n=0}^{N-1} I_n \\, B_r\\!\\left(\\frac{t - n \\Delta t}{\\Delta t}\\right),\n$$\nwhere $r$ is the polynomial degree of the basis, $B_r$ is a cardinal interpolatory basis of degree $r$ with compact support spanning $r+1$ time steps, and $I_n$ are coefficients obtained by collocation on the temporal grid, here taken as samples of the exact solution $I_n = J_{\\text{exact}}(n\\Delta t)$. For an interpolatory basis, $B_r(0)=1$ and $B_r(k)=0$ for integer $k \\neq 0$ within its support.\n\nYou will implement and compare the following interpolatory temporal bases:\n- Piecewise linear (degree $r=1$), also called the hat function.\n- Piecewise cubic (degree $r=3$), implemented via 4-point cardinal Lagrange interpolation on the integer stencil.\n- Piecewise quartic (degree $r=4$), implemented via 5-point cardinal Lagrange interpolation on the integer stencil.\n\nThe input signal is a linearly chirped excitation with a smooth window to enforce finite support:\n$$\nE_{\\text{inc}}(t) = A(t)\\cos\\!\\left(2\\pi\\left(f_0 t + \\tfrac{1}{2}\\alpha t^2\\right)\\right),\n\\quad \\text{for } 0 \\le t \\le T,\\quad \\text{and } E_{\\text{inc}}(t)=0 \\text{ otherwise},\n$$\nwhere the sweep rate is $\\alpha = \\frac{f_1 - f_0}{T}$ and the Hann window is $A(t) = \\tfrac{1}{2}\\left(1 - \\cos\\!\\left(\\frac{2\\pi t}{T}\\right)\\right)$. The exact current is $J_{\\text{exact}}(t) = E_{\\text{inc}}(t - \\tau_0)$.\n\nYour task is to:\n1. Construct the coarse temporal grid $t_n = n\\Delta t$ for $n=0,1,\\dots,N-1$ and define the coefficients $I_n = J_{\\text{exact}}(n\\Delta t)$.\n2. Reconstruct the continuous-time current $J_r(t)$ on a fine grid $t_m^{\\text{fine}} = m\\Delta t/L$ for $m=0,1,\\dots,LN-1$ using the degree-$r$ interpolatory basis via cardinal Lagrange interpolation on each local stencil.\n3. Compute the Discrete Fourier Transform (DFT) of both $J_{\\text{exact}}(t_m^{\\text{fine}})$ and $J_r(t_m^{\\text{fine}})$ using a Fast Fourier Transform on the fine grid. Let the one-sided DFTs be $\\hat{J}_{\\text{exact}}(\\omega_k)$ and $\\hat{J}_r(\\omega_k)$ at frequencies $\\omega_k = 2\\pi f_k$, where $f_k$ are the nonnegative DFT frequencies determined by the fine sampling interval $\\Delta t/L$.\n4. Define the phase error for basis degree $r$ on the frequency bins within the chirp band $[f_0,f_1]$ where the exact spectrum magnitude is significant, as\n$$\n\\phi_r(\\omega_k,\\Delta t) = \\operatorname{unwrap}\\left(\\arg\\left(\\hat{J}_r(\\omega_k)\\right) - \\arg\\left(\\hat{J}_{\\text{exact}}(\\omega_k)\\right)\\right),\n$$\nwith phase in radians. Use an amplitude mask to retain only those $k$ for which $\\left|\\hat{J}_{\\text{exact}}(\\omega_k)\\right| \\ge \\eta \\max_{f_0 \\le f \\le f_1} \\left|\\hat{J}_{\\text{exact}}(2\\pi f)\\right|$, with a fixed significance threshold $\\eta = 0.2$.\n5. Report the root-mean-square (RMS) phase error in radians over the retained bins:\n$$\n\\mathrm{RMS}_r = \\sqrt{\\frac{1}{K}\\sum_{k \\in \\mathcal{K}} \\phi_r(\\omega_k,\\Delta t)^2},\n$$\nwhere $\\mathcal{K}$ is the set of retained frequency bins and $K = |\\mathcal{K}|$.\n\nPhysical unit requirements:\n- All times must be in seconds.\n- All frequencies must be in Hertz.\n- All angles must be in radians.\n- The final phase error must be reported in radians as real-valued floats.\n\nImplement the above and evaluate the three temporal bases $r\\in\\{1,3,4\\}$ on the following test suite. In each test, use the specified $\\Delta t$, integer length $N$, chirp band $[f_0,f_1]$, delay $\\tau_0$, and oversampling factor $L$ to define the grids and signals as above. The total duration is $T = N\\Delta t$.\n\nTest suite:\n- Test 1 (happy path, fractional delay within band):\n    - $\\Delta t = 5.0\\times 10^{-10}\\ \\text{s}$, $N=4096$, $f_0 = 5.0\\times 10^{7}\\ \\text{Hz}$, $f_1 = 8.0\\times 10^{8}\\ \\text{Hz}$, $\\tau_0 = 2.3\\,\\Delta t$, $L=8$.\n- Test 2 (boundary case with near-Nyquist band edge and integer delay):\n    - $\\Delta t = 5.0\\times 10^{-10}\\ \\text{s}$, $N=4096$, $f_0 = 5.0\\times 10^{7}\\ \\text{Hz}$, $f_1 = 9.0\\times 10^{8}\\ \\text{Hz}$, $\\tau_0 = 8\\,\\Delta t$, $L=8$.\n- Test 3 (smaller time step, higher band, fractional delay):\n    - $\\Delta t = 2.5\\times 10^{-10}\\ \\text{s}$, $N=4096$, $f_0 = 5.0\\times 10^{7}\\ \\text{Hz}$, $f_1 = 1.5\\times 10^{9}\\ \\text{Hz}$, $\\tau_0 = 2.7\\,\\Delta t$, $L=8$.\n\nYour program must:\n- Implement cardinal Lagrange interpolation of degrees $r=1,3,4$ on local integer stencils of length $r+1$ with zero padding outside the sampled interval.\n- Construct $J_{\\text{exact}}(t)$ and $J_r(t)$ on the fine grid and compute the DFT-based phase errors as defined.\n- For each test, compute and collect the three RMS phase errors $\\mathrm{RMS}_1$, $\\mathrm{RMS}_3$, and $\\mathrm{RMS}_4$ (in radians).\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a list of lists, one inner list per test in the same order as above. Each inner list must be in the form $[\\mathrm{RMS}_1,\\mathrm{RMS}_3,\\mathrm{RMS}_4]$, where each entry is a floating-point number in radians. For example: [[x11,x13,x14],[x21,x23,x24],[x31,x33,x34]].", "solution": "The problem is assessed to be valid. It is scientifically grounded in the principles of computational electromagnetics and numerical analysis, specifically addressing the representation of time-domain signals using temporal basis functions in Marching-on-in-Time (MOT) algorithms. The problem is well-posed, with a complete and consistent set of definitions, parameters, and objectives that lead to a unique and verifiable solution. All terms are formally defined, and the required physical parameters and numerical procedures are standard within the field.\n\nThe solution proceeds by first constructing the specified input signal and the exact retarded response. Then, for each specified temporal basis degree $r \\in \\{1, 3, 4\\}$, the continuous-time current is reconstructed from its samples on a coarse grid. Finally, the phase accuracy of each reconstruction is quantified in the frequency domain against the exact solution.\n\n**1. Signal and Grid Generation**\n\nFor each test case, we are given a time step $\\Delta t$, the number of time steps $N$, a frequency chirp band $[f_0, f_1]$, a propagation delay $\\tau_0$, and a fine-grid oversampling factor $L$.\n\nThe total duration of the incident signal is $T = N \\Delta t$.\nThe coarse temporal grid is defined as $t_n = n \\Delta t$ for $n \\in \\{0, 1, \\dots, N-1\\}$.\nThe fine temporal grid for analysis is $t_m^{\\text{fine}} = m \\frac{\\Delta t}{L}$ for $m \\in \\{0, 1, \\dots, LN-1\\}$. Let $N_{\\text{fine}} = LN$.\n\nThe incident field $E_{\\text{inc}}(t)$ is a linearly chirped cosine pulse with a Hann window for smooth start and end:\n$$\nE_{\\text{inc}}(t) = \n\\begin{cases} \n\\frac{1}{2}\\left(1 - \\cos\\left(\\frac{2\\pi t}{T}\\right)\\right) \\cos\\left(2\\pi\\left(f_0 t + \\frac{1}{2}\\alpha t^2\\right)\\right)  \\text{for } 0 \\le t \\le T \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\nwhere the chirp rate is $\\alpha = \\frac{f_1 - f_0}{T}$.\n\nThe exact current $J_{\\text{exact}}(t)$ is a time-delayed version of the incident field, given by the sifting property of the Dirac delta kernel:\n$$\nJ_{\\text{exact}}(t) = E_{\\text{inc}}(t - \\tau_0)\n$$\nThe coefficients $I_n$ for the MOT representation are the samples of this exact current on the coarse grid:\n$$\nI_n = J_{\\text{exact}}(t_n) = J_{\\text{exact}}(n \\Delta t), \\quad n \\in \\{0, 1, \\dots, N-1\\}\n$$\n\n**2. Current Reconstruction via Interpolation**\n\nThe approximate current $J_r(t)$ is reconstructed from the coarse-grid samples $\\{I_n\\}$ using basis functions of degree $r$. The problem specifies this reconstruction as a sum of shifted basis functions, $J_r(t) = \\sum_{n=0}^{N-1} I_n \\, B_r\\!\\left(\\frac{t - n \\Delta t}{\\Delta t}\\right)$, but also refers to the bases as \"piecewise\" and implemented via \"Lagrange interpolation on a local stencil\". This is most consistently interpreted as a piecewise polynomial interpolation scheme. For each coarse time interval $[t_n, t_{n+1}]$, a polynomial of degree $r$ is constructed using a stencil of $r+1$ nearby samples $\\{I_k\\}$, and this polynomial is used to compute the values of $J_r(t)$ for $t \\in [t_n, t_{n+1}]$. This approach is equivalent to the convolutional sum, where $B_r(\\tau)$ is a piecewise polynomial function with compact support, known as a fundamental spline of the Lagrange type.\n\nFor the implementation:\n- **Degree $r=1$ (Piecewise Linear)**: This corresponds to the standard \"hat\" basis. For any $t \\in [t_n, t_{n+1}]$, the value $J_1(t)$ is computed by linear interpolation between the points $(t_n, I_n)$ and $(t_{n+1}, I_{n+1})$. This is efficiently implemented over the entire fine grid.\n- **Degree $r=3$ (Piecewise Cubic)**: For each interval $[t_n, t_{n+1}]$, we use a $4$-point stencil to construct a cubic Lagrange polynomial. A standard choice is the stencil of samples $\\{I_{n-1}, I_n, I_{n+1}, I_{n+2}\\}$. This polynomial is then evaluated at the fine-grid points within $[t_n, t_{n+1}]$.\n- **Degree $r=4$ (Piecewise Quartic)**: Similarly, for each interval $[t_n, t_{n+1}]$, we use a $5$-point stencil. A centered choice relative to the interval points is $\\{I_{n-2}, I_{n-1}, I_n, I_{n+1}, I_{n+2}\\}$. This stencil involves samples corresponding to coarse times $\\{t_{n-2}, \\dots, t_{n+2}\\}$. A quartic Lagrange polynomial is constructed from these samples and evaluated on the fine grid over $[t_n, t_{n+1}]$.\n\nAt the boundaries of the domain $[0, T]$, the stencils may require samples $I_n$ with $n0$ or $n \\ge N$. As per the problem's specification of \"zero padding\", we assume $I_n = 0$ for these indices.\n\n**3. Spectral Analysis and Phase Error Calculation**\n\nThe accuracy of the reconstruction is evaluated in the frequency domain.\n1.  **Fourier Transform**: The one-sided Discrete Fourier Transforms (DFT) of the exact current, $\\hat{J}_{\\text{exact}}(\\omega_k)$, and the reconstructed current, $\\hat{J}_r(\\omega_k)$, are computed using the Fast Fourier Transform (FFT) algorithm on the finely sampled signals $J_{\\text{exact}}(t_m^{\\text{fine}})$ and $J_r(t_m^{\\text{fine}})$. The corresponding discrete frequencies are $f_k = k / (N_{\\text{fine}} \\cdot (\\Delta t/L))$.\n\n2.  **Amplitude Masking**: The phase error is meaningful only where the signal has significant energy. We first identify the frequency bins $k$ that fall within the chirp band $[f_0, f_1]$. Within this band, we find the maximum spectral magnitude of the exact signal, $M_{\\text{max}} = \\max_{f_k \\in [f_0, f_1]} \\left|\\hat{J}_{\\text{exact}}(2\\pi f_k)\\right|$. The analysis is restricted to the set of frequency bins $\\mathcal{K}$ where the magnitude exceeds a fraction $\\eta=0.2$ of this maximum:\n$$\n\\mathcal{K} = \\left\\{ k \\;\\middle|\\; f_k \\in [f_0, f_1] \\text{ and } \\left|\\hat{J}_{\\text{exact}}(2\\pi f_k)\\right| \\ge \\eta M_{\\text{max}} \\right\\}\n$$\n\n3.  **Phase Error**: For each frequency $\\omega_k$ corresponding to an index $k \\in \\mathcal{K}$, the raw phase difference is computed: $\\Delta\\phi(\\omega_k) = \\arg(\\hat{J}_r(\\omega_k)) - \\arg(\\hat{J}_{\\text{exact}}(\\omega_k))$. This difference is then unwrapped to resolve $2\\pi$ ambiguities, yielding the continuous phase error $\\phi_r(\\omega_k, \\Delta t)$.\n\n4.  **RMS Metric**: The final error metric is the root-mean-square (RMS) of the unwrapped phase error over all retained frequency bins:\n$$\n\\mathrm{RMS}_r = \\sqrt{\\frac{1}{K}\\sum_{k \\in \\mathcal{K}} \\phi_r(\\omega_k, \\Delta t)^2}\n$$\nwhere $K=|\\mathcal{K}|$ is the number of bins in the masked set. This procedure is repeated for each degree $r$ and for each test case.", "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import interp1d, barycentric_interpolate\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Test 1: Happy path\n        {'dt': 5.0e-10, 'N': 4096, 'f0': 5.0e7, 'f1': 8.0e8, 'tau0_factor': 2.3, 'L': 8},\n        # Test 2: Near-Nyquist\n        {'dt': 5.0e-10, 'N': 4096, 'f0': 5.0e7, 'f1': 9.0e8, 'tau0_factor': 8.0, 'L': 8},\n        # Test 3: Smaller time step, higher band\n        {'dt': 2.5e-10, 'N': 4096, 'f0': 5.0e7, 'f1': 1.5e9, 'tau0_factor': 2.7, 'L': 8}\n    ]\n\n    all_results = []\n    for params in test_cases:\n        results_per_case = run_test_case(**params)\n        all_results.append(results_per_case)\n\n    # Format the final output string as a list of lists.\n    # e.g., [[x11,x13,x14],[x21,x23,x24],[x31,x33,x34]]\n    output_str = '[' + ','.join(['[' + ','.join([f\"{val:.8f}\" for val in res]) + ']' for res in all_results]) + ']'\n    print(output_str)\n\ndef run_test_case(dt, N, f0, f1, tau0_factor, L):\n    \"\"\"\n    Executes a single test case for the given parameters.\n    \"\"\"\n    T = N * dt\n    tau0 = tau0_factor * dt\n    alpha = (f1 - f0) / T\n\n    # Define the incident field E_inc(t)\n    def e_inc(t):\n        # Ensure t is a numpy array for vectorized operations\n        t = np.asarray(t)\n        # Signal is defined on [0, T], zero otherwise\n        active_mask = (t = 0)  (t = T)\n        result = np.zeros_like(t, dtype=float)\n        \n        t_active = t[active_mask]\n        \n        # Hann window\n        amplitude = 0.5 * (1 - np.cos(2 * np.pi * t_active / T))\n        # Chirp signal\n        phase = 2 * np.pi * (f0 * t_active + 0.5 * alpha * t_active**2)\n        \n        result[active_mask] = amplitude * np.cos(phase)\n        return result\n\n    # Define the exact current J_exact(t)\n    def j_exact(t):\n        return e_inc(t - tau0)\n\n    # --- Grids and Coefficients ---\n    t_coarse = np.arange(N) * dt\n    I_coeffs = j_exact(t_coarse)\n\n    N_fine = N * L\n    dt_fine = dt / L\n    t_fine = np.arange(N_fine) * dt_fine\n\n    J_exact_fine = j_exact(t_fine)\n\n    rms_errors = []\n    for r in [1, 3, 4]:\n        J_recon_fine = reconstruct_current(I_coeffs, r, L, dt)\n        rms_error = calculate_rms_phase_error(J_recon_fine, J_exact_fine, dt_fine, f0, f1)\n        rms_errors.append(rms_error)\n        \n    return rms_errors\n\ndef reconstruct_current(I_coeffs, r, L, dt):\n    \"\"\"\n    Reconstructs the continuous-time current on a fine grid using piecewise\n    Lagrange interpolation of degree r.\n    \"\"\"\n    N = len(I_coeffs)\n    N_fine = N * L\n    t_fine = np.arange(N_fine) * (dt / L)\n    J_recon = np.zeros(N_fine)\n\n    if r == 1:\n        # Degree 1 (linear interpolation) is efficiently handled by interp1d\n        t_coarse_nodes = np.arange(N + 1) * dt\n        I_extended = np.pad(I_coeffs, (0, 1), 'constant')\n        interp_func = interp1d(t_coarse_nodes, I_extended, kind='linear', bounds_error=False, fill_value=0.0)\n        return interp_func(t_fine)\n\n    # For r  1, use piecewise barycentric interpolation\n    # Determine padding needed based on stencil choice\n    if r == 3: # Stencil: [n-1, n, n+1, n+2]\n        pad_before, pad_after = 1, 2\n    elif r == 4: # Stencil: [n-2, n-1, n, n+1, n+2]\n        pad_before, pad_after = 2, 2\n    else:\n        raise ValueError(f\"Unsupported degree r={r}\")\n\n    I_padded = np.pad(I_coeffs, (pad_before, pad_after), 'constant')\n\n    for n in range(N):\n        m_start = n * L\n        m_end = (n + 1) * L\n        t_interval_fine = t_fine[m_start:m_end]\n\n        if r == 3:\n            stencil_n_indices = np.array([n - 1, n, n + 1, n + 2])\n        elif r == 4:\n            stencil_n_indices = np.array([n - 2, n - 1, n, n + 1, n + 2])\n        \n        t_stencil_nodes = stencil_n_indices * dt\n        I_stencil_values = I_padded[stencil_n_indices + pad_before]\n\n        J_recon[m_start:m_end] = barycentric_interpolate(t_stencil_nodes, I_stencil_values, t_interval_fine)\n        \n    return J_recon\n\ndef calculate_rms_phase_error(j_recon, j_exact, dt_fine, f0, f1, eta=0.2):\n    \"\"\"\n    Calculates the RMS phase error in the frequency domain.\n    \"\"\"\n    N_fine = len(j_exact)\n    \n    # Compute one-sided FFTs\n    J_hat_recon = np.fft.rfft(j_recon)\n    J_hat_exact = np.fft.rfft(j_exact)\n    \n    # Get corresponding frequencies\n    freqs = np.fft.rfftfreq(N_fine, d=dt_fine)\n    \n    # Identify frequency bins in the chirp band [f0, f1]\n    band_indices = np.where((freqs = f0)  (freqs = f1))[0]\n    \n    if len(band_indices) == 0:\n        return 0.0\n\n    # Apply amplitude mask\n    J_hat_exact_band = J_hat_exact[band_indices]\n    max_mag_in_band = np.max(np.abs(J_hat_exact_band))\n    \n    threshold = eta * max_mag_in_band\n    \n    mask = np.abs(J_hat_exact_band) = threshold\n    \n    masked_indices = band_indices[mask]\n    \n    if len(masked_indices) == 0:\n        return 0.0\n\n    # Calculate phase error\n    phase_recon = np.angle(J_hat_recon[masked_indices])\n    phase_exact = np.angle(J_hat_exact[masked_indices])\n    \n    phase_error = phase_recon - phase_exact\n    unwrapped_phase_error = np.unwrap(phase_error)\n    \n    # Compute RMS error\n    rms_error = np.sqrt(np.mean(unwrapped_phase_error**2))\n    \n    return rms_error\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "3328595"}, {"introduction": "Perhaps the most significant challenge in many MOT schemes is late-time instability, a numerical artifact where the solution grows exponentially without bound, corrupting long-time simulations. The standard remedy is the Time-Domain Combined Field Integral Equation (TD-CFIE), which judiciously mixes two different integral equation formulations. This practice uses a surrogate model to explore the core mechanism of the TD-CFIE, allowing you to find an optimal mixing parameter, $\\eta$, that suppresses numerical instabilities and ensures a robust simulation [@problem_id:3328585].", "problem": "You are tasked with constructing a time-domain Combined Field Integral Equation (TD-CFIE) marching-on-in-time algorithm for the surface current density on a perfectly electric conducting (PEC) sphere, by combining the time-domain Electric Field Integral Equation (TD-EFIE) and the time-domain Magnetic Field Integral Equation (TD-MFIE) kernels with a scalar mixing parameter. Begin from first principles grounded in Maxwell's equations and standard PEC boundary conditions. The goal is to select a mixing parameter that minimizes the growth of the discrete surface current over time for a high-frequency regime.\n\nStart from the time-domain Maxwell equations in free space for electric field $\\mathbf{E}(\\mathbf{r},t)$ and magnetic field $\\mathbf{H}(\\mathbf{r},t)$, with electric flux density $\\mathbf{D}(\\mathbf{r},t)$, magnetic flux density $\\mathbf{B}(\\mathbf{r},t)$, and linear constitutive relations, and enforce the PEC boundary conditions for the tangential electric field. Consider the time-domain integral equation formulation mapping the unknown surface current density $\\mathbf{J}(\\mathbf{r},t)$ on the sphere to the scattered fields via retarded potentials. The TD-EFIE and TD-MFIE define convolution operators with kernels $K_E(t)$ and $K_M(t)$ acting on $\\mathbf{J}(\\mathbf{r},t)$ over the surface. The TD-CFIE operator is defined as a convex combination of kernels,\n$$\nK_C(t) = \\eta\\, K_E(t) + (1-\\eta)\\, K_M(t),\n$$\nwhere $0 \\le \\eta \\le 1$ is the mixing parameter.\n\nDiscretize in space using a single dominant vector spherical harmonic mode to reduce the operator to a scalar surrogate for one modal coefficient $J(t)$, and in time using a uniform grid with step $\\Delta t$ and piecewise-constant temporal basis. After Galerkin testing in space and time, the TD-CFIE yields a linear causal discrete convolution equation for the modal coefficient,\n$$\n\\sum_{m=0}^{M} Z_C[m]\\, J^{n-m} = V^n,\n$$\nwhere $J^n$ approximates $J(n\\Delta t)$, $M$ is a finite memory depth, $Z_C[m]$ are the discrete TD-CFIE weights, and $V^n$ is the tested excitation. The marching-on-in-time update for zero subsequent excitation ($V^n = 0$ for $n \\ge 1$) is\n$$\nJ^n = -\\frac{1}{Z_C[0]} \\sum_{m=1}^{\\min(M,n)} Z_C[m]\\, J^{n-m},\\quad n\\ge 1,\n$$\nwith prescribed initial condition $J^0 = 1$ and $J^n=0$ for $n0$.\n\nTo define a scientifically-consistent, reduced-order surrogate for a PEC sphere of radius $a$ in a high-frequency regime characterized by a wavenumber $k$ with $ka \\gg 1$, assume the following parametric forms for the discrete TD-EFIE and TD-MFIE weights that capture causality, damping, and oscillatory behavior of radiation:\n$$\nZ_E[0] = z_{E0}, \\quad Z_M[0] = z_{M0},\n$$\n$$\nZ_E[m] = A_E\\, \\frac{e^{-\\alpha m} \\sin(\\omega m \\Delta t)}{m+m_d}, \\quad Z_M[m] = A_M\\, \\frac{e^{-\\alpha m} \\sin(\\omega m \\Delta t)}{m+m_d}, \\quad m\\ge 1,\n$$\nwith $z_{M0} = 0.5$ corresponding to the classical principal-value term of the MFIE on a smooth closed surface, and a small but nonzero $z_{E0}$ capturing the TD-EFIE self-term. The amplitudes $A_E$ and $A_M$ scale with $ka$ to represent the stronger EFIE coupling at high frequency, with $A_E = \\min(1.0, 0.02\\,ka)$ and $A_M = 0.5\\,A_E$. The damping factor is $\\alpha = 0.05$, and the short causal delay is encoded by the integer $m_d = 3$. The angular frequency is $\\omega = c\\,k$, where $c$ is the speed of light in vacuum. The mixing yields\n$$\nZ_C[m] = \\eta\\, Z_E[m] + (1-\\eta)\\, Z_M[m], \\quad m=0,1,\\dots,M.\n$$\n\nUse the marching-on-in-time update to propagate $J^n$ for $n=1,2,\\dots,N$ with the initial condition $J^0 = 1$ and $J^n = 0$ for $n  0$, and with zero tested excitation $V^n=0$ for $n\\ge 1$. For a given $\\eta$, define the growth metric\n$$\nG(\\eta) = \\max_{0 \\le n \\le N} \\left|J^n\\right|,\n$$\nand select the optimal mixing parameter\n$$\n\\eta^\\star = \\arg\\min_{\\eta \\in \\{0.00,0.01,\\dots,1.00\\}} G(\\eta).\n$$\n\nImplement the above model and procedure in a complete, runnable program. Use the speed of light $c = 299792458\\,\\mathrm{m/s}$, express radii in meters and time steps in seconds, and use radians for all angles. Define the time step $\\Delta t$ via the period $T = 2\\pi/\\omega$ as $\\Delta t = T/p$ for an integer $p$. For each test case, compute $\\omega$ from $k = (ka)/a$, set $z_{E0} = 0.1 + 0.02\\cdot\\pi/(10\\,ka)$, and use the above $Z_E[m]$ and $Z_M[m]$ with parameters $M$, $m_d$, and $\\alpha$ as specified.\n\nTest Suite:\n- Case $1$ (happy path): $a = 0.1\\,\\mathrm{m}$, $ka = 50$, $p = 20$, $N = 200$, $M = 12$.\n- Case $2$ (boundary coarser time step): $a = 0.05\\,\\mathrm{m}$, $ka = 50$, $p = 10$, $N = 200$, $M = 12$.\n- Case $3$ (edge lower $ka$ and longer memory): $a = 0.1\\,\\mathrm{m}$, $ka = 30$, $p = 20$, $N = 400$, $M = 20$.\n\nRequired Final Output Format:\nYour program should produce a single line of output containing the three optimal mixing parameters for the test suite as a comma-separated list enclosed in square brackets, for example, `[0.123, 0.456, 0.789]`, where each entry is a floating-point number rounded to three decimal places.", "solution": "The objective is to determine the optimal scalar mixing parameter, $\\eta^\\star$, for a time-domain Combined Field Integral Equation (TD-CFIE) formulation designed to model the surface current on a perfectly electric conducting (PEC) sphere. The optimization criterion is the minimization of the temporal growth of a discrete modal current coefficient, a known challenge in marching-on-in-time (MOT) algorithms, particularly for the time-domain Electric Field Integral Equation (TD-EFIE).\n\nThe foundation of this problem lies in Maxwell's equations, which govern the behavior of the electric field $\\mathbf{E}(\\mathbf{r},t)$ and magnetic field $\\mathbf{H}(\\mathbf{r},t)$. For a PEC body, the total tangential electric field on its surface must vanish. This boundary condition, combined with the representation of scattered fields using retarded potentials sourced by an unknown surface current density $\\mathbf{J}(\\mathbf{r},t)$, leads to integral equations. The TD-EFIE arises from enforcing the boundary condition on the electric field, while the time-domain Magnetic Field Integral Equation (TD-MFIE) arises from the boundary condition on the magnetic field.\n\nThe TD-CFIE is a linear combination of these two formulations, constructed to leverage the stability properties of the TD-MFIE to mitigate the late-time instabilities often observed in TD-EFIE MOT schemes. The combined operator kernel is $K_C(t) = \\eta\\, K_E(t) + (1-\\eta)\\, K_M(t)$, where $\\eta \\in [0, 1]$ is the mixing parameter.\n\nAfter spatial and temporal discretization, the continuous integral equation is transformed into a discrete linear convolution for a single modal coefficient of the current, denoted $J^n \\approx J(n\\Delta t)$:\n$$\n\\sum_{m=0}^{M} Z_C[m]\\, J^{n-m} = V^n\n$$\nHere, $Z_C[m]$ are the discrete impedance matrix elements for the TD-CFIE, $V^n$ represents the sampled excitation, and $M$ is the finite memory depth of the interaction.\n\nThe problem specifies a surrogate model for the discrete impedance weights corresponding to the TD-EFIE ($Z_E[m]$) and TD-MFIE ($Z_M[m]$) for a PEC sphere of radius $a$ in a high-frequency regime ($ka \\gg 1$). The TD-CFIE weights are a convex combination:\n$$\nZ_C[m] = \\eta\\, Z_E[m] + (1-\\eta)\\, Z_M[m], \\quad m=0,1,\\dots,M.\n$$\nThe specific parametric forms for the EFIE and MFIE weights are given as:\n$$\nZ_E[0] = z_{E0}, \\quad Z_M[0] = z_{M0} = 0.5\n$$\n$$\nZ_E[m] = A_E\\, \\frac{e^{-\\alpha m} \\sin(\\omega m \\Delta t)}{m+m_d}, \\quad Z_M[m] = A_M\\, \\frac{e^{-\\alpha m} \\sin(\\omega m \\Delta t)}{m+m_d}, \\quad m\\ge 1\n$$\nThe parameters are defined based on the physical setup:\n- Wavenumber: $k=(ka)/a$\n- Angular frequency: $\\omega = c\\,k$, with $c = 299792458\\,\\mathrm{m/s}$\n- Time step: $\\Delta t = T/p = (2\\pi/\\omega)/p$\n- EFIE self-term: $z_{E0} = 0.1 + 0.02\\cdot\\pi/(10\\,ka)$\n- Amplitudes: $A_E = \\min(1.0, 0.02\\,ka)$ and $A_M = 0.5\\,A_E$\n- Damping factor: $\\alpha = 0.05$\n- Causal delay: $m_d = 3$\n\nThe core of the algorithm is the MOT update scheme. By isolating the present-time current coefficient $J^n$ (which corresponds to $m=0$ in the sum), we obtain a recurrence relation. Assuming zero excitation for subsequent time steps ($V^n = 0$ for $n \\ge 1$), the update rule is:\n$$\nJ^n = -\\frac{1}{Z_C[0]} \\sum_{m=1}^{\\min(M,n)} Z_C[m]\\, J^{n-m},\\quad n\\ge 1\n$$\nThis process is initiated with the conditions $J^0 = 1$ and $J^n = 0$ for $n  0$. The term $Z_C[0] = \\eta z_{E0} + (1-\\eta) z_{M0}$ is guaranteed to be positive since $z_{E0}  0$, $z_{M0}  0$, and $\\eta \\in [0, 1]$, ensuring the update is always well-defined.\n\nTo find the optimal mixing parameter $\\eta^\\star$, we follow a numerical optimization procedure. We define a growth metric $G(\\eta)$ as the maximum absolute value of the current coefficient over the simulation time:\n$$\nG(\\eta) = \\max_{0 \\le n \\le N} \\left|J^n\\right|\n$$\nThe optimal parameter $\\eta^\\star$ is the one that minimizes this metric over a discrete grid of possible values:\n$$\n\\eta^\\star = \\arg\\min_{\\eta \\in \\{0.00,0.01,\\dots,1.00\\}} G(\\eta)\n$$\nThe computational procedure for each test case is as follows:\n1.  Calculate the derived physical and model parameters ($k, \\omega, \\Delta t, z_{E0}, A_E, A_M$) from the given inputs ($a, ka, p$).\n2.  Pre-compute the impedance weight arrays $Z_E[m]$ and $Z_M[m]$ for $m \\in [0, M]$.\n3.  Iterate through each candidate value of $\\eta$ from $0.00$ to $1.00$ in steps of $0.01$.\n4.  For each $\\eta$, compute the corresponding CFIE weights $Z_C[m]$.\n5.  Simulate the time evolution of the current $J^n$ from $n=1$ to $N$ using the MOT recurrence relation and the initial condition $J^0=1$.\n6.  Calculate the growth metric $G(\\eta)$ from the resulting sequence $J^n$.\n7.  Keep track of the $\\eta$ that yields the minimum value of $G(\\eta)$ observed so far.\n8.  The final $\\eta$ that results in the global minimum of $G(\\eta)$ is the optimal parameter $\\eta^\\star$ for the given test case. This process is repeated for all test cases specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the optimal TD-CFIE mixing parameter for several test cases.\n    \"\"\"\n    \n    # Define physical constants and test cases from the problem statement.\n    c = 299792458.0  # Speed of light in m/s\n    \n    test_cases = [\n        # Case 1 (happy path): a=0.1, ka=50, p=20, N=200, M=12\n        {'a': 0.1, 'ka': 50, 'p': 20, 'N': 200, 'M': 12},\n        # Case 2 (boundary coarser time step): a=0.05, ka=50, p=10, N=200, M=12\n        {'a': 0.05, 'ka': 50, 'p': 10, 'N': 200, 'M': 12},\n        # Case 3 (edge lower ka and longer memory): a=0.1, ka=30, p=20, N=400, M=20\n        {'a': 0.1, 'ka': 30, 'p': 20, 'N': 400, 'M': 20},\n    ]\n\n    results = []\n    for case in test_cases:\n        optimal_eta = find_optimal_eta(case, c)\n        results.append(optimal_eta)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.3f}' for r in results)}]\")\n\ndef find_optimal_eta(params, c):\n    \"\"\"\n    Finds the optimal mixing parameter eta for a single test case.\n    \n    Args:\n        params (dict): A dictionary containing the parameters for the test case\n                       (a, ka, p, N, M).\n        c (float): The speed of light.\n\n    Returns:\n        float: The optimal mixing parameter eta_star.\n    \"\"\"\n    a = params['a']\n    ka = params['ka']\n    p = params['p']\n    N = params['N']\n    M = params['M']\n    \n    # Given model parameters\n    alpha = 0.05\n    m_d = 3\n    z_M0 = 0.5\n    \n    # Step 1: Calculate derived physical and model parameters\n    k = ka / a\n    omega = c * k\n    T = 2 * np.pi / omega\n    dt = T / p\n    \n    z_E0 = 0.1 + 0.02 * np.pi / (10 * ka)\n    A_E = min(1.0, 0.02 * ka)\n    A_M = 0.5 * A_E\n    \n    # Step 2: Pre-compute the impedance weight arrays Z_E and Z_M\n    m_vals = np.arange(1, M + 1)\n    common_term = np.exp(-alpha * m_vals) * np.sin(omega * m_vals * dt) / (m_vals + m_d)\n    \n    Z_E = np.zeros(M + 1)\n    Z_M = np.zeros(M + 1)\n    \n    Z_E[0] = z_E0\n    Z_M[0] = z_M0\n    \n    Z_E[1:] = A_E * common_term\n    Z_M[1:] = A_M * common_term\n    \n    # Step 3: Optimization loop to find eta_star\n    eta_grid = np.linspace(0.00, 1.00, 101)\n    min_growth = float('inf')\n    optimal_eta = -1.0\n    \n    for eta in eta_grid:\n        # Step 4: Compute CFIE weights Z_C\n        Z_C = eta * Z_E + (1 - eta) * Z_M\n        \n        # Step 5: Run MOT simulation\n        J = np.zeros(N + 1)\n        J[0] = 1.0\n        \n        Z_C0_inv = 1.0 / Z_C[0]\n        \n        for n in range(1, N + 1):\n            # Calculate the summation part of the recurrence\n            sum_term = 0.0\n            limit = min(M, n)\n            for m in range(1, limit + 1):\n                sum_term += Z_C[m] * J[n - m]\n            \n            J[n] = -Z_C0_inv * sum_term\n            \n        # Step 6: Calculate the growth metric G(eta)\n        growth = np.max(np.abs(J))\n        \n        # Step 7: Update the optimal eta\n        if growth  min_growth:\n            min_growth = growth\n            optimal_eta = eta\n            \n    return optimal_eta\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3328585"}]}