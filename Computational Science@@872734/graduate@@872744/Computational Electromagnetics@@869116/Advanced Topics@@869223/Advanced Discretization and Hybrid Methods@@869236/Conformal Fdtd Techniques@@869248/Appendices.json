{"hands_on_practices": [{"introduction": "The power of conformal FDTD lies in its ability to accurately model complex, curved geometries on a simple Cartesian grid. The first and most critical step in this process is creating a robust \"geometry engine\" that can interpret an arbitrary shape—typically represented by a triangulated surface—and compute its interaction with each grid cell. This exercise challenges you to build such an engine from first principles, implementing robust polygon clipping algorithms to determine the essential geometric quantities like cut-cell areas, normals, and edge intersection lengths needed for advanced FDTD updates [@problem_id:3294796].", "problem": "Design and implement a complete, runnable program that, for a triangulated surface embedded in a unit Cartesian cell, computes robust geometric measures required by conformal Finite-Difference Time-Domain (FDTD) techniques. Your program must implement from first principles an algorithm that, given a set of triangles in three-dimensional space, computes the following for the portion of the surface lying inside the unit cube defined by $[0,1] \\times [0,1] \\times [0,1]$:\n\n- The total cut-surface area $A_{\\mathrm{cut}}$ inside the cube.\n- The area-weighted unit normal $\\mathbf{n}_{\\mathrm{cut}}$ of the cut-surface inside the cube, defined by normalizing the vector area integral $\\int_{S_{\\mathrm{cut}}} \\mathbf{\\hat{n}} \\, \\mathrm{d}S$, where $S_{\\mathrm{cut}}$ is the portion of the triangulated surface inside the cube and $\\mathbf{\\hat{n}}$ is the unit normal of the surface oriented consistently with the triangle orientation.\n- For each of the $12$ edges of the unit cube, the edge-length fraction $f_e \\in [0,1]$ equal to the total one-dimensional measure of the intersection between that cube edge and the cut-surface region, divided by the full edge length. Here, the \"intersection length\" between a cube edge (a line segment) and the two-dimensional cut-surface is zero unless the edge lies in the plane of some triangle and overlaps the triangle’s interior; in such coplanar cases, this intersection can be a nontrivial segment of length between $0$ and $1$.\n\nYour derivation and implementation must begin from the integral form of Maxwell’s equations underlying the Finite-Difference Time-Domain method, where discrete updates rely on face fluxes and edge circulations. Hence, the cut-surface area and area-weighted normals arise from geometric measures in the discrete Stokes and divergence theorems, and edge-length fractions arise from metric terms on grid edges when surfaces coincide with grid edges. You must not assume any shortcut formulas beyond standard definitions of planes, convex polyhedron clipping, polygon area via vector area, and line clipping against half-planes.\n\nAlgorithmic requirements:\n\n1. Surface clipping. Each triangle must be robustly clipped against the unit cube by sequential half-space clipping with the $6$ axis-aligned planes $x \\ge 0$, $x \\le 1$, $y \\ge 0$, $y \\le 1$, $z \\ge 0$, $z \\le 1$. Use a numerically robust inside/outside test with a tolerance $\\varepsilon$, and compute intersection points by linear interpolation in the plane predicate values to avoid catastrophic cancellation.\n\n2. Area and normal accumulation. For each clipped polygon (a triangle or a convex polygon subset thereof), compute its vector area $\\mathbf{A} = \\frac{1}{2} \\sum_{i} \\mathbf{r}_i \\times \\mathbf{r}_{i+1}$, where $\\mathbf{r}_i$ are polygon vertices in cyclic order. Accumulate $\\mathbf{A}$ across all triangles to obtain $\\mathbf{A}_{\\mathrm{tot}}$, then compute $A_{\\mathrm{cut}} = \\lVert \\mathbf{A}_{\\mathrm{tot}} \\rVert$ and $\\mathbf{n}_{\\mathrm{cut}} = \\mathbf{A}_{\\mathrm{tot}} / \\lVert \\mathbf{A}_{\\mathrm{tot}} \\rVert$ if $\\lVert \\mathbf{A}_{\\mathrm{tot}} \\rVert > \\varepsilon$, otherwise set $\\mathbf{n}_{\\mathrm{cut}} = \\mathbf{0}$.\n\n3. Edge length fractions. Let the $12$ cube edges be the line segments:\n   - $e_0 : (0,0,0) \\rightarrow (1,0,0)$,\n   - $e_1 : (0,0,0) \\rightarrow (0,1,0)$,\n   - $e_2 : (0,0,0) \\rightarrow (0,0,1)$,\n   - $e_3 : (1,0,0) \\rightarrow (1,1,0)$,\n   - $e_4 : (1,0,0) \\rightarrow (1,0,1)$,\n   - $e_5 : (0,1,0) \\rightarrow (1,1,0)$,\n   - $e_6 : (0,1,0) \\rightarrow (0,1,1)$,\n   - $e_7 : (0,0,1) \\rightarrow (1,0,1)$,\n   - $e_8 : (0,0,1) \\rightarrow (0,1,1)$,\n   - $e_9 : (1,1,0) \\rightarrow (1,1,1)$,\n   - $e_{10} : (1,0,1) \\rightarrow (1,1,1)$,\n   - $e_{11} : (0,1,1) \\rightarrow (1,1,1)$.\n   For each triangle that clips to a nonempty polygon inside the cube, compute its plane with unit normal $\\mathbf{\\hat{n}}_{\\triangle}$ and test each edge $e$ for coplanarity with that plane using a distance tolerance $\\varepsilon$. If an edge is coplanar, project both the clipped polygon and the edge to a $2$-dimensional basis $\\{\\mathbf{u}, \\mathbf{v}\\}$ spanning the triangle plane, and compute the length of the edge segment lying inside the projected polygon by clipping the segment against the polygon’s half-planes. Normalize by the full edge length (which is $1$ for the unit cube) to obtain the contribution to $f_e$ from that triangle. If multiple triangles contribute to the same edge, take the union of the covered parametric intervals along the edge before summing lengths, to avoid double-counting.\n\n4. Numerical robustness against degeneracy. Your implementation must explicitly guard against:\n   - Degenerate triangles with near-zero area.\n   - Nearly parallel or nearly coplanar intersections between triangles and clipping planes.\n   - Nearly coplanar cube edges with triangle planes leading to ambiguous classification. Use consistent tolerances in inside/outside tests and interval merging, and ensure half-plane normals are oriented consistently with polygon vertex ordering.\n\nAll quantities are dimensionless. Your program must round all reported floating-point values to exactly 10 decimal places.\n\nTest suite and required outputs:\n\nImplement the algorithm above and evaluate it on the following four test cases. Each test case is a list of triangles, and each triangle is given by three vertices $(x,y,z)$:\n\n- Test case $1$ (generic oblique intersection):\n  - Single triangle with vertices $(-0.2, 0.2, 0.2)$, $(1.2, 0.8, 0.2)$, $(0.5, 0.5, 1.2)$.\n\n- Test case $2$ (coplanar with a face, producing nonzero edge fractions):\n  - Single triangle with vertices $(0.0, 0.0, 0.0)$, $(1.0, 0.0, 0.0)$, $(0.0, 1.0, 0.0)$.\n\n- Test case $3$ (nearly tangential intersection, robustness to small offsets):\n  - Single triangle with vertices $(-0.1, 0.5, 10^{-12})$, $(1.1, 0.5, -10^{-12})$, $(0.5, -0.1, 10^{-12})$.\n\n- Test case $4$ (degenerate triangle with zero area):\n  - Single triangle with vertices $(0.2, 0.2, 0.2)$, $(0.6, 0.6, 0.6)$, $(1.0, 1.0, 1.0)$.\n\nFor each test case, your program must output a list containing:\n- The total cut-surface area $A_{\\mathrm{cut}}$,\n- The components of the area-weighted unit normal $\\mathbf{n}_{\\mathrm{cut}} = (n_x,n_y,n_z)$,\n- The $12$ edge-length fractions $[f_0, f_1, \\dots, f_{11}]$ in the edge order specified above.\n\nFinal output format:\n\nYour program should produce a single line of output containing the results for all test cases as a comma-separated list of lists, where each inner list is ordered as $[A_{\\mathrm{cut}}, n_x, n_y, n_z, f_0, f_1, \\dots, f_{11}]$. All numbers must be rounded to exactly 10 decimal places. For example, a valid outer structure is like \"[[...],[...],[...],[...]]\" with each \"...\" replaced by the 16 numbers for that test case.", "solution": "The problem requires the design and implementation of an algorithm to compute specific geometric measures of a triangulated surface as it intersects a unit cube. These measures—cut-surface area $A_{\\mathrm{cut}}$, area-weighted unit normal $\\mathbf{n}_{\\mathrm{cut}}$, and cube edge-length fractions $f_e$—are fundamental quantities in advanced computational electromagnetics, particularly in conformal Finite-Difference Time-Domain (FDTD) methods. In FDTD, Maxwell's equations are discretized on a grid. Conformal techniques adapt the standard algorithm at grid cells intersected by material boundaries, such as a triangulated surface. The discrete forms of Stokes' theorem and the divergence theorem, which are used to update the magnetic and electric fields respectively, require geometric information about how the surface cuts through the grid cell. The cut-surface area $A_{\\mathrm{cut}}$ and its area-weighted normal $\\mathbf{n}_{\\mathrm{cut}}$ are used to compute surface-averaged fields or fluxes, while edge-length fractions $f_e$ provide modified metric terms for line integrals along grid edges that are partially covered by the surface.\n\nThe algorithm proceeds from first principles, processing each triangle individually and accumulating the results. The core steps for a surface composed of multiple triangles are:\n1.  Iterate through each input triangle.\n2.  For each triangle, robustly clip it against the six faces of the unit cube $[0,1]^3$. This yields a convex polygon (or nothing if the triangle is entirely outside the cube).\n3.  Compute the vector area of the resulting clipped polygon. Accumulate these vector areas over all triangles.\n4.  For each triangle and its resulting clipped polygon, determine if the triangle's plane is coplanar with any of the $12$ unit cube edges. If so, compute the length of intersection between the cube edge and the clipped polygon.\n5.  After processing all triangles, finalize the global quantities: compute the total cut area and normal from the accumulated vector area, and for each cube edge, merge any overlapping intersection intervals and sum their lengths to find the total edge fraction.\n\nA numerical tolerance, denoted by $\\varepsilon$, is used for all floating-point comparisons to ensure robustness against geometric degeneracies and floating-point inaccuracies.\n\n**Step 1: Surface Clipping**\nEach triangle is treated as a convex polygon and is clipped against the unit cube. The cube is a convex volume defined by the intersection of six half-spaces: $x \\ge 0$, $x \\le 1$, $y \\ge 0$, $y \\le 1$, $z \\ge 0$, and $z \\le 1$. We employ the Sutherland-Hodgman algorithm, which clips a convex polygon against a sequence of convex half-spaces, with each clipping operation producing a new convex polygon that becomes the input for the next.\n\nFor a single half-space defined by a plane with point $\\mathbf{p}_0$ and inward-pointing normal $\\mathbf{n}$, we process each edge of the input polygon, from vertex $\\mathbf{S}$ to $\\mathbf{E}$:\n- A point $\\mathbf{v}$ is \"inside\" the half-space if its signed distance $d(\\mathbf{v}) = (\\mathbf{v} - \\mathbf{p}_0) \\cdot \\mathbf{n} \\ge -\\varepsilon$.\n- If both $\\mathbf{S}$ and $\\mathbf{E}$ are inside, the vertex $\\mathbf{E}$ is added to the output polygon.\n- If $\\mathbf{S}$ is inside and $\\mathbf{E}$ is outside, the intersection point $\\mathbf{I}$ is computed and added to the output.\n- If both $\\mathbf{S}$ and $\\mathbf{E}$ are outside, nothing is added.\n- If $\\mathbf{S}$ is outside and $\\mathbf{E}$ is inside, the intersection point $\\mathbf{I}$ and the vertex $\\mathbf{E}$ are added to the output.\n\nThe intersection point $\\mathbf{I}$ for the line segment $\\mathbf{SE}$ is found using linear interpolation based on the signed distances of the endpoints. The parametric position $t \\in [0,1]$ of the intersection along the edge $\\mathbf{L}(t) = \\mathbf{S} + t(\\mathbf{E}-\\mathbf{S})$ is given by $t = d(\\mathbf{S}) / (d(\\mathbf{S}) - d(\\mathbf{E}))$. The intersection point is then $\\mathbf{I} = \\mathbf{S} + t(\\mathbf{E}-\\mathbf{S})$. This method is numerically stable, especially when the edge is nearly parallel to the clipping plane (i.e., $|d(\\mathbf{S}) - d(\\mathbf{E})|$ is small). A near-zero denominator $(\\mathbf{E}-\\mathbf{S}) \\cdot \\mathbf{n}$ indicates parallelism, a case handled by checking if either endpoint is inside.\n\n**Step 2: Area and Normal Accumulation**\nFor each clipped polygon resulting from the process above, we compute its vector area $\\mathbf{A}_{\\mathrm{poly}}$. For a polygon with vertices $\\mathbf{r}_0, \\mathbf{r}_1, \\dots, \\mathbf{r}_{N-1}$ in sequential order, the vector area is given by the formula:\n$$ \\mathbf{A}_{\\mathrm{poly}} = \\frac{1}{2} \\sum_{i=0}^{N-1} \\mathbf{r}_i \\times \\mathbf{r}_{i+1} $$\nwhere $\\mathbf{r}_N = \\mathbf{r}_0$. This formula provides a vector whose direction is normal to the polygon and whose magnitude is its area. The orientation is consistent with the vertex ordering (right-hand rule).\n\nThe total vector area of the cut surface, $\\mathbf{A}_{\\mathrm{tot}}$, is the sum of the vector areas of all clipped polygons:\n$$ \\mathbf{A}_{\\mathrm{tot}} = \\sum_{\\text{triangles}} \\mathbf{A}_{\\mathrm{poly}} $$\nFrom $\\mathbf{A}_{\\mathrm{tot}}$, the required global quantities are computed:\n- The total cut-surface area: $A_{\\mathrm{cut}} = \\lVert \\mathbf{A}_{\\mathrm{tot}} \\rVert$.\n- The area-weighted unit normal: $\\mathbf{n}_{\\mathrm{cut}} = \\mathbf{A}_{\\mathrm{tot}} / \\lVert \\mathbf{A}_{\\mathrm{tot}} \\rVert$, if $\\lVert \\mathbf{A}_{\\mathrm{tot}} \\rVert > \\varepsilon$. Otherwise, if the total area is negligible, $\\mathbf{n}_{\\mathrm{cut}} = \\mathbf{0}$.\n\n**Step 3: Edge-Length Fractions**\nThe edge-length fraction $f_e$ quantifies the portion of a cube edge $e$ that lies within the surface. This is non-zero only if the cube edge is coplanar with a triangle that has a non-empty intersection with the cube.\n\nFor each original triangle that produces a non-empty clipped polygon:\n1.  **Coplanarity Test**: The triangle's plane is defined by one of its vertices, say $\\mathbf{v}_0$, and its unit normal $\\hat{\\mathbf{n}}_{\\triangle}$. A cube edge $e$ running from $\\mathbf{P}_{\\text{start}}$ to $\\mathbf{P}_{\\text{end}}$ is considered coplanar if both its endpoints lie on the triangle's plane within tolerance $\\varepsilon$. That is, $|(\\mathbf{P}_{\\text{start}} - \\mathbf{v}_0) \\cdot \\hat{\\mathbf{n}}_{\\triangle}| < \\varepsilon$ and $|(\\mathbf{P}_{\\text{end}} - \\mathbf{v}_0) \\cdot \\hat{\\mathbf{n}}_{\\triangle}| < \\varepsilon$.\n\n2.  **Intersection Calculation**: If an edge $e$ is coplanar, we must find the length of the intersection between this edge segment and the corresponding `clipped_poly`. This is a 3D line segment clipping problem against a convex polygon, for which the Cyrus-Beck algorithm is suitable. Let the edge be parameterized as $\\mathbf{L}(t) = \\mathbf{P}_{\\text{start}} + t(\\mathbf{P}_{\\text{end}} - \\mathbf{P}_{\\text{start}})$ for $t \\in [0, 1]$. We maintain an interval $[t_{\\text{in}}, t_{\\text{out}}]$, initialized to $[0, 1]$. For each edge of the `clipped_poly`, we compute its outward-pointing normal within the plane and find the intersection parameter $t$ with the line $\\mathbf{L}(t)$. Depending on whether the line is entering or leaving the polygon's half-space, we update either $t_{\\text{in}}$ or $t_{\\text{out}}$. If at any point $t_{\\text{in}} > t_{\\text{out}}$, the intersection is empty. The final interval $[t_{\\text{in}}, t_{\\text{out}}]$ represents the portion of the cube edge (in parametric coordinates) that is inside the polygon.\n\n3.  **Interval Accumulation and Merging**: A single cube edge may be coplanar with multiple triangles. To avoid double-counting, we store the computed intersection intervals $[t_{\\text{in}}, t_{\\text{out}}]$ for each of the $12$ cube edges. After all triangles are processed, for each edge, we merge the collected list of potentially overlapping intervals into a set of disjoint intervals. This is done by sorting the intervals by their start points and iteratively combining any that overlap. The total length of these merged disjoint intervals gives the total intersection length. Since the cube edges have unit length, this total length is the edge fraction $f_e$.\n\n**Step 4: Numerical Robustness**\nDegenerate cases are handled explicitly. Triangles with a near-zero area (collinear vertices) are identified by checking if the magnitude of the cross product of its edge vectors is below $\\varepsilon^2$. Such triangles are ignored as they contribute nothing to area or volume. All geometric tests—inside/outside checks, coplanarity, and parallelism in line clipping—are performed using the tolerance $\\varepsilon$ to prevent failures due to floating-point representation errors.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    \n    # Define a consistent tolerance for floating-point comparisons.\n    EPS = 1e-12\n\n    def sutherland_hodgman_clip(polygon, clip_planes):\n        \"\"\"\n        Clips a convex polygon against a list of convex half-spaces (planes).\n        \"\"\"\n        clipped_polygon = list(polygon)\n        for plane_point, plane_normal in clip_planes:\n            input_list = list(clipped_polygon)\n            clipped_polygon.clear()\n            if not input_list:\n                return []\n\n            s = input_list[-1]\n            for e in input_list:\n                s_dist = np.dot(s - plane_point, plane_normal)\n                e_dist = np.dot(e - plane_point, plane_normal)\n                \n                s_inside = s_dist >= -EPS\n                e_inside = e_dist >= -EPS\n\n                if s_inside and e_inside:\n                    clipped_polygon.append(e)\n                elif s_inside and not e_inside:\n                    # S is in, E is out: intersection\n                    den = s_dist - e_dist\n                    if abs(den) > EPS:\n                        t = s_dist / den\n                        intersection = s + t * (e - s)\n                        clipped_polygon.append(intersection)\n                elif not s_inside and e_inside:\n                    # S is out, E is in: intersection then E\n                    den = s_dist - e_dist\n                    if abs(den) > EPS:\n                        t = s_dist / den\n                        intersection = s + t * (e - s)\n                        clipped_polygon.append(intersection)\n                    clipped_polygon.append(e)\n                # Both S and E are out: do nothing\n                s = e\n        return clipped_polygon\n\n    def get_vector_area(polygon):\n        \"\"\"\n        Computes the vector area of a 3D polygon.\n        \"\"\"\n        if len(polygon) < 3:\n            return np.array([0.0, 0.0, 0.0])\n        \n        total_area = np.array([0.0, 0.0, 0.0])\n        for i in range(len(polygon)):\n            v1 = polygon[i]\n            v2 = polygon[(i + 1) % len(polygon)]\n            total_area += np.cross(v1, v2)\n        \n        return total_area / 2.0\n\n    def merge_intervals(intervals):\n        \"\"\"\n        Merges a list of overlapping intervals.\n        \"\"\"\n        if not intervals:\n            return []\n        \n        intervals.sort(key=lambda x: x[0])\n        \n        merged = [intervals[0]]\n        for current_start, current_end in intervals[1:]:\n            last_start, last_end = merged[-1]\n            \n            # Use tolerance for merging\n            if current_start <= last_end + EPS:\n                merged[-1] = (last_start, max(last_end, current_end))\n            else:\n                merged.append((current_start, current_end))\n                \n        return merged\n\n    def compute_edge_fractions(triangle, clipped_poly, edge_definitions, edge_intervals):\n        \"\"\"\n        Computes intersection of a triangle's plane with cube edges and updates intervals.\n        \"\"\"\n        v0, v1, v2 = triangle\n        \n        tri_normal_vec = np.cross(v1 - v0, v2 - v0)\n        norm_mag = np.linalg.norm(tri_normal_vec)\n        if norm_mag < EPS:\n            return # Degenerate triangle\n\n        tri_normal = tri_normal_vec / norm_mag\n\n        for i, (p_start, p_end) in enumerate(edge_definitions):\n            # 1. Coplanarity Test\n            dist_start = abs(np.dot(p_start - v0, tri_normal))\n            dist_end = abs(np.dot(p_end - v0, tri_normal))\n\n            if dist_start < EPS and dist_end < EPS:\n                # 2. Intersection Calculation (Cyrus-Beck)\n                edge_dir = p_end - p_start\n                t_in, t_out = 0.0, 1.0\n\n                for j in range(len(clipped_poly)):\n                    poly_v1 = clipped_poly[j]\n                    poly_v2 = clipped_poly[(j + 1) % len(clipped_poly)]\n                    poly_edge_dir = poly_v2 - poly_v1\n                    \n                    # Outward normal in the triangle plane\n                    outward_normal = np.cross(poly_edge_dir, tri_normal)\n                    \n                    numerator = np.dot(poly_v1 - p_start, outward_normal)\n                    denominator = np.dot(edge_dir, outward_normal)\n\n                    if abs(denominator) < EPS: # Line is parallel to polygon edge\n                        if numerator > 0: # Line is outside this half-plane\n                            t_in = 1.0; t_out = 0.0 # Empty intersection\n                            break\n                        # Otherwise, inside, continue\n                    else:\n                        t = numerator / denominator\n                        if denominator > 0: # Exiting\n                            t_out = min(t_out, t)\n                        else: # Entering\n                            t_in = max(t_in, t)\n                \n                if t_in < t_out:\n                    edge_intervals[i].append((t_in, t_out))\n\n    # Cube definition\n    cube_clip_planes = [\n        (np.array([0, 0, 0]), np.array([1, 0, 0])),  # x >= 0\n        (np.array([1, 0, 0]), np.array([-1, 0, 0])), # x <= 1\n        (np.array([0, 0, 0]), np.array([0, 1, 0])),  # y >= 0\n        (np.array([0, 1, 0]), np.array([0, -1, 0])), # y <= 1\n        (np.array([0, 0, 0]), np.array([0, 0, 1])),  # z >= 0\n        (np.array([0, 0, 1]), np.array([0, 0, -1])), # z <= 1\n    ]\n\n    edge_defs = [\n        (np.array([0,0,0]), np.array([1,0,0])), # e0\n        (np.array([0,0,0]), np.array([0,1,0])), # e1\n        (np.array([0,0,0]), np.array([0,0,1])), # e2\n        (np.array([1,0,0]), np.array([1,1,0])), # e3\n        (np.array([1,0,0]), np.array([1,0,1])), # e4\n        (np.array([0,1,0]), np.array([1,1,0])), # e5\n        (np.array([0,1,0]), np.array([0,1,1])), # e6\n        (np.array([0,0,1]), np.array([1,0,1])), # e7\n        (np.array([0,0,1]), np.array([0,1,1])), # e8\n        (np.array([1,1,0]), np.array([1,1,1])), # e9\n        (np.array([1,0,1]), np.array([1,1,1])), # e10\n        (np.array([0,1,1]), np.array([1,1,1])), # e11\n    ]\n\n    # Test cases\n    test_cases = [\n        # Test case 1\n        [[np.array([-0.2, 0.2, 0.2]), np.array([1.2, 0.8, 0.2]), np.array([0.5, 0.5, 1.2])]],\n        # Test case 2\n        [[np.array([0.0, 0.0, 0.0]), np.array([1.0, 0.0, 0.0]), np.array([0.0, 1.0, 0.0])]],\n        # Test case 3\n        [[np.array([-0.1, 0.5, 1e-12]), np.array([1.1, 0.5, -1e-12]), np.array([0.5, -0.1, 1e-12])]],\n        # Test case 4\n        [[np.array([0.2, 0.2, 0.2]), np.array([0.6, 0.6, 0.6]), np.array([1.0, 1.0, 1.0])]],\n    ]\n    \n    final_results = []\n    \n    for triangles in test_cases:\n        total_vector_area = np.array([0.0, 0.0, 0.0])\n        edge_intervals = [[] for _ in range(12)]\n\n        for triangle in triangles:\n            # Check for degenerate triangle before clipping\n            v0, v1, v2 = triangle\n            if np.linalg.norm(np.cross(v1 - v0, v2 - v0)) < EPS**2:\n                continue\n\n            clipped_polygon = sutherland_hodgman_clip(triangle, cube_clip_planes)\n            \n            if len(clipped_polygon) >= 3:\n                poly_area = get_vector_area(clipped_polygon)\n                total_vector_area += poly_area\n                compute_edge_fractions(triangle, clipped_polygon, edge_defs, edge_intervals)\n        \n        # Finalize area and normal\n        A_cut = np.linalg.norm(total_vector_area)\n        n_cut = np.array([0.0, 0.0, 0.0])\n        if A_cut > EPS:\n            n_cut = total_vector_area / A_cut\n            \n        # Finalize edge fractions\n        f_edges = []\n        for i in range(12):\n            merged = merge_intervals(edge_intervals[i])\n            total_length = sum(end - start for start, end in merged)\n            f_edges.append(total_length)\n            \n        # Format results\n        case_result = [A_cut, n_cut[0], n_cut[1], n_cut[2]] + f_edges\n        rounded_result = [f\"{x:.10f}\" for x in case_result]\n        final_results.append(rounded_result)\n\n    # Format output string\n    output_str = \"[\"\n    for i, res in enumerate(final_results):\n        output_str += f\"[{','.join(res)}]\"\n        if i < len(final_results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    \n    print(output_str)\n\nsolve()\n```", "id": "3294796"}, {"introduction": "With the ability to compute geometric factors for curved boundaries, we can now construct a complete conformal FDTD simulation. This practice guides you through implementing a 2D time-stepping loop for a circular resonant cavity, where the standard FDTD update equations are modified at the curved PEC boundary using the computed geometric information. A key test for the validity of any numerical electromagnetics solver for lossless systems is the conservation of energy; by tracking the total discrete energy over time, you will verify that your conformal implementation correctly models a physically non-dissipative system [@problem_id:3294784].", "problem": "Consider a two-dimensional Transverse Electric in the out-of-plane direction (TE$_z$) configuration of Maxwell’s equations in a simply-connected vacuum region bounded by a smooth Perfect Electric Conductor (PEC). Let the PEC boundary be a circle of radius $R$ centered at the origin. The vacuum domain is the open disk $\\{(x,y): x^2 + y^2 < R^2\\}$. The fields are $\\mathbf{E} = (E_x, E_y, 0)$ and $\\mathbf{H} = (0, 0, H_z)$, with vacuum permittivity $\\varepsilon_0$ and vacuum permeability $\\mu_0$. The speed of light is $c = 1/\\sqrt{\\varepsilon_0 \\mu_0}$. The continuous integral forms of Maxwell’s equations for this polarization are\n$$\n\\frac{\\partial}{\\partial t}\\left(\\mu_0 H_z \\right) = -\\left(\\nabla \\times \\mathbf{E}\\right)_z,\\quad\n\\frac{\\partial}{\\partial t}\\left(\\varepsilon_0 E_x\\right) = \\left(\\nabla \\times \\mathbf{H}\\right)_x,\\quad\n\\frac{\\partial}{\\partial t}\\left(\\varepsilon_0 E_y\\right) = \\left(\\nabla \\times \\mathbf{H}\\right)_y,\n$$\ntogether with the PEC boundary condition that the tangential electric field vanishes on the circular boundary. \n\nYour task is to implement a conformal finite-difference time-domain (FDTD) scheme that respects the geometry of the circular PEC by modifying the update of the magnetic field using geometric fractions, while leaving the electric field updates in the standard Yee form but enforcing zero fields on edges that are completely outside the vacuum region. Specifically, use a uniform Cartesian Yee grid covering a square domain $[-L_x/2,L_x/2]\\times[-L_y/2,L_y/2]$ with $N_x$ cells in $x$ and $N_y$ cells in $y$, spacings $\\Delta x = L_x/N_x$, $\\Delta y = L_y/N_y$, and time step $\\Delta t$ chosen via the Courant–Friedrichs–Lewy (CFL) condition \n$$\n\\Delta t = \\alpha \\left( c \\sqrt{\\Delta x^{-2} + \\Delta y^{-2}} \\right)^{-1},\n$$\nfor a specified factor $\\alpha \\in (0,1)$. Place the PEC circular boundary of radius $R$ at the center $(0,0)$.\n\nConformal update for $H_z$: For each primal cell, let $A_{\\text{eff}}$ be the area of the intersection of the cell and the disk $x^2+y^2<R^2$. For the four edges of the cell (top, bottom, right, left), let $\\ell_{\\text{top}}$, $\\ell_{\\text{bot}}$, $\\ell_{\\text{right}}$, $\\ell_{\\text{left}}$ be the lengths of those edge segments lying strictly within the disk. Then the discrete update for $H_z$ at cell $(i,j)$ is\n$$\nH_z^{n+\\frac{1}{2}} = H_z^{n-\\frac{1}{2}} - \\frac{\\Delta t}{\\mu_0 A_{\\text{eff}}} \\left[ E_x^{n}\\big|_{\\text{top}} \\, \\ell_{\\text{top}} - E_x^{n}\\big|_{\\text{bot}} \\, \\ell_{\\text{bot}} + E_y^{n}\\big|_{\\text{right}} \\, \\ell_{\\text{right}} - E_y^{n}\\big|_{\\text{left}} \\, \\ell_{\\text{left}} \\right],\n$$\nwith the convention that if $A_{\\text{eff}}=0$ then $H_z$ is identically zero and not updated.\n\nElectric field updates: Use the standard Yee updates without geometric scaling,\n$$\nE_x^{n+1} = E_x^n + \\frac{\\Delta t}{\\varepsilon_0} \\frac{ H_z^{n+\\frac{1}{2}}(i,j) - H_z^{n+\\frac{1}{2}}(i,j-1)}{\\Delta y},\\quad\nE_y^{n+1} = E_y^n - \\frac{\\Delta t}{\\varepsilon_0} \\frac{ H_z^{n+\\frac{1}{2}}(i,j) - H_z^{n+\\frac{1}{2}}(i-1,j)}{\\Delta x},\n$$\napplied wherever the edge is at least partially inside the disk. For any Yee edge that lies completely outside the disk, enforce $E_x=0$ or $E_y=0$ at all times. This realizes the PEC boundary condition conformally while keeping the explicit time stepping.\n\nDiscrete electromagnetic energy: Define the discrete total energy per unit out-of-plane length at time step $n$ by\n$$\n\\mathcal{W}^n = \\frac{1}{2}\\mu_0 \\sum_{\\text{cells}} \\left(H_z^n\\right)^2 A_{\\text{eff}} \\; + \\; \\frac{1}{2}\\varepsilon_0 \\sum_{\\text{$E_x$ edges}} \\left(E_x^n\\right)^2 \\, \\Delta x \\, \\ell^\\star_{x} \\; + \\; \\frac{1}{2}\\varepsilon_0 \\sum_{\\text{$E_y$ edges}} \\left(E_y^n\\right)^2 \\, \\Delta y \\, \\ell^\\star_{y},\n$$\nwhere $\\ell^\\star_{x}$ is the length of the dual vertical segment of size $\\Delta y$ associated to an $E_x$ edge that lies within the disk, and $\\ell^\\star_{y}$ is the length of the dual horizontal segment of size $\\Delta x$ associated to an $E_y$ edge that lies within the disk. For edges entirely outside the disk, the contribution is zero.\n\nGeometry computation requirements:\n- For each horizontal edge at constant $y=y_0$ and spanning $x \\in [x_0,x_1]$ with $x_1-x_0=\\Delta x$, compute the segment length inside the circle exactly by overlapping the interval $[x_0,x_1]$ with the circle chord $[-\\sqrt{R^2-y_0^2},+\\sqrt{R^2-y_0^2}]$ if $|y_0|<R$, and zero otherwise. Set $\\ell = \\max\\{0,\\min(x_1,\\sqrt{R^2-y_0^2}) - \\max(x_0,-\\sqrt{R^2-y_0^2})\\}$.\n- For each vertical edge at constant $x=x_0$ and spanning $y \\in [y_0,y_1]$ with $y_1-y_0=\\Delta y$, compute the segment length inside the circle exactly by overlapping $[y_0,y_1]$ with $[-\\sqrt{R^2-x_0^2},+\\sqrt{R^2-x_0^2}]$ if $|x_0|<R$, and zero otherwise. Set $\\ell = \\max\\{0,\\min(y_1,\\sqrt{R^2-x_0^2}) - \\max(y_0,-\\sqrt{R^2-x_0^2})\\}$.\n- For each magnetic cell, approximate $A_{\\text{eff}}$ by uniform subsampling at $p\\times p$ quadrature points per cell and taking the fraction of samples inside the disk times the full area $\\Delta x \\Delta y$, with $p \\ge 4$ fixed for all tests.\n\nInitial condition: At $t=0$, set $E_x=0$ and $E_y=0$ everywhere. Initialize $H_z$ to a smooth, localized distribution centered at the origin to avoid exciting spurious boundary currents, for example $H_z(x,y,0)=H_0 \\exp\\left(-\\frac{x^2+y^2}{2\\sigma^2}\\right)$ with $H_0=1$ and $\\sigma=0.2R$. Since the cavity is closed and the medium is lossless, the discrete energy $\\mathcal{W}^n$ should remain constant in time, up to numerical dispersion and quadrature errors, if the conformal updates do not introduce artificial loss.\n\nVerification metric: For each simulation, compute the minimal fractional energy drop over the run,\n$$\n\\delta_{\\min} = \\frac{\\mathcal{W}^0 - \\min_{0 \\le n \\le N_t} \\mathcal{W}^n}{\\mathcal{W}^0},\n$$\nwhere $N_t$ is the number of time steps. Report $\\delta_{\\min}$ as a decimal (not a percentage). A small value indicates that no artificial loss was introduced by the conformal boundary treatment.\n\nTest suite and required output:\n- Use vacuum parameters $\\varepsilon_0 = 8.854187817\\times 10^{-12}$ (in $\\text{F/m}$) and $\\mu_0 = 4\\pi\\times 10^{-7}$ (in $\\text{H/m}$). The cavity and domain dimensions $L_x$ and $L_y$ are in meters; express $R$, $\\Delta x$, $\\Delta y$, and $\\Delta t$ in meters and seconds as usual in the implementation, but the output metric $\\delta_{\\min}$ is dimensionless.\n- Use subsampling resolution $p=8$ for $A_{\\text{eff}}$ in all tests.\n- Simulate the following cases, each starting from rest as described and run for the specified number of steps $N_t$:\n    1. Case A (happy path): $L_x=L_y=1$, $N_x=N_y=80$, $R=0.4$, $\\alpha=0.90$, $N_t=1000$.\n    2. Case B (geometry edge case): $L_x=L_y=1$, $N_x=N_y=64$, $R=0.2$, $\\alpha=0.90$, $N_t=800$.\n    3. Case C (near-CFL stress): $L_x=L_y=1$, $N_x=N_y=96$, $R=0.45$, $\\alpha=0.98$, $N_t=1200$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order [Case A, Case B, Case C], for example $[\\delta_{\\min,A},\\delta_{\\min,B},\\delta_{\\min,C}]$.\n\nAll angles, where applicable, are in radians. The output must be real numbers printed as decimals. The numerical values must be computed by your program; do not hard-code the answers.", "solution": "The user-provided problem is assessed to be valid. It is scientifically grounded in the principles of computational electromagnetics, specifically the Finite-Difference Time-Domain (FDTD) method. The problem is well-posed, providing a complete set of partial differential equations, boundary conditions, initial conditions, and numerical parameters. The language is objective and the requirements are formalizable into a concrete numerical algorithm. The task is to implement a specific conformal FDTD scheme for a 2D TE$_z$ problem inside a circular Perfect Electric Conductor (PEC) and to verify its energy conservation properties.\n\nThe solution will be developed by following these steps:\n1.  Discretization of the computational domain using a standard Yee grid.\n2.  Pre-computation of all necessary geometric factors that encode the circular boundary into the Cartesian grid.\n3.  Implementation of the time-stepping loop using the leapfrog algorithm with the specified conformal updates.\n4.  Calculation of the discrete electromagnetic energy at each time step.\n5.  Evaluation of the energy conservation metric for the specified test cases.\n\n### 1. Discretization and Grid Setup\nThe continuous 2D domain is discretized using a uniform Cartesian grid as specified. The problem uses the Transverse Electric (TE$_z$) polarization, where the electric field $\\mathbf{E} = (E_x, E_y, 0)$ lies in the $xy$-plane and the magnetic field $\\mathbf{H} = (0, 0, H_z)$ is perpendicular to it. In the standard Yee FDTD scheme, the field components are spatially and temporally staggered.\n- The scalar magnetic field component $H_z$ is sampled at the center of each grid cell $(i, j)$ and at half-integer time steps $n+1/2$. A cell $(i,j)$ covers the area $[x_i, x_{i+1}] \\times [y_j, y_{j+1}]$.\n- The electric field component $E_x$ is sampled at the center of the horizontal edges of each cell and at integer time steps $n$.\n- The electric field component $E_y$ is sampled at the center of the vertical edges of each cell and at integer time steps $n$.\n\nThe simulation domain is a square $[-L_x/2, L_x/2] \\times [-L_y/2, L_y/2]$ with $N_x \\times N_y$ cells. The spatial and temporal step sizes are given by:\n$$ \\Delta x = \\frac{L_x}{N_x}, \\quad \\Delta y = \\frac{L_y}{N_y} $$\n$$ \\Delta t = \\alpha \\left( c \\sqrt{\\frac{1}{\\Delta x^2} + \\frac{1}{\\Delta y^2}} \\right)^{-1} $$\nwhere $c = 1/\\sqrt{\\varepsilon_0 \\mu_0}$ is the speed of light in vacuum and $\\alpha$ is the Courant factor.\n\n### 2. Geometric Pre-computation\nTo incorporate the circular PEC boundary of radius $R$ into the Cartesian grid, several geometric factors must be computed for each cell and edge before the time-stepping simulation begins.\n\n- **Effective Area ($A_{\\text{eff}}$)**: For each $H_z$ cell, $A_{\\text{eff}}$ is the area of the cell that lies inside the circle $x^2 + y^2 < R^2$. As specified, this is approximated by creating a uniform $p \\times p$ grid of sub-points within each cell and calculating the fraction of points that fall inside the circle, multiplied by the cell area $\\Delta x \\Delta y$.\n\n- **Effective Edge Lengths for H-update ($\\ell_{\\text{edge}}$)**: For each cell, the lengths of its four edges (top, bottom, left, right) that lie within the circle are computed. These are denoted $\\ell_{\\text{top}}$, $\\ell_{\\text{bot}}$, $\\ell_{\\text{right}}$, and $\\ell_{\\text{left}}$. The calculation uses the provided exact formula for the intersection length of a line segment with a circular chord. For a horizontal edge at height $y_0$ spanning $[x_0, x_1]$, the length inside the circle is $\\ell = \\max\\{0, \\min(x_1, \\sqrt{R^2-y_0^2}) - \\max(x_0, -\\sqrt{R^2-y_0^2})\\}$ for $|y_0|<R$, and zero otherwise. An analogous formula applies to vertical edges.\n\n- **Effective Dual-Edge Lengths for Energy Calculation ($\\ell^\\star$)**: The energy calculation requires lengths of *dual* grid segments that lie within the circle. For an $E_x$ component located on a horizontal primary edge, its associated dual segment is a vertical line of length $\\Delta y$ passing through its location. $\\ell^\\star_x$ is the length of this dual segment inside the circle. Similarly, $\\ell^\\star_y$ is the length of the dual horizontal segment for an $E_y$ component. These are computed using the same intersection logic as for the primary edges.\n\n### 3. FDTD Time-Stepping Algorithm\nThe simulation evolves the fields in time using a leapfrog scheme.\n\n- **Initialization**: At time $t=0$, the electric fields $E_x$ and $E_y$ are zero everywhere. The magnetic field $H_z$ is initialized with a smooth Gaussian pulse, $H_z(x,y,0) = H_0 \\exp\\left(-\\frac{x^2+y^2}{2\\sigma^2}\\right)$. For the leapfrog scheme, this initial condition at $t=0$ is used to represent the state at $t=-\\Delta t/2$, i.e., $H_z^{n=-1/2}$.\n\n- **H-Field Update**: At each step, $H_z$ is advanced from time $n-1/2$ to $n+1/2$ using the provided conformal update rule, which is a discrete version of Faraday's law of induction, $\\oint \\mathbf{E} \\cdot d\\mathbf{l} = - \\frac{\\partial}{\\partial t} \\int_S \\mu_0 H_z dS$:\n$$ H_z^{n+\\frac{1}{2}}(i,j) = H_z^{n-\\frac{1}{2}}(i,j) - \\frac{\\Delta t}{\\mu_0 A_{\\text{eff}}(i,j)} \\left[ E_x^{n}(i, j+1) \\ell_{\\text{top}} - E_x^{n}(i,j) \\ell_{\\text{bot}} + E_y^{n}(i+1,j) \\ell_{\\text{right}} - E_y^{n}(i,j) \\ell_{\\text{left}} \\right] $$\nThis update is only performed for cells where $A_{\\text{eff}} > 0$. For cells entirely outside the circle ($A_{\\text{eff}} = 0$), $H_z$ remains zero.\n\n- **E-Field Update**: The electric field components are advanced from time $n$ to $n+1$ using the standard, non-conformal Yee updates, which are discrete forms of Ampère's law:\n$$ E_x^{n+1}(i,j) = E_x^n(i,j) + \\frac{\\Delta t}{\\varepsilon_0} \\frac{ H_z^{n+\\frac{1}{2}}(i,j) - H_z^{n+\\frac{1}{2}}(i,j-1)}{\\Delta y} $$\n$$ E_y^{n+1}(i,j) = E_y^n(i,j) - \\frac{\\Delta t}{\\varepsilon_0} \\frac{ H_z^{n+\\frac{1}{2}}(i,j) - H_z^{n+\\frac{1}{2}}(i-1,j)}{\\Delta x} $$\nFollowing this update, the PEC boundary condition is enforced. Any electric field component whose corresponding edge lies completely outside the circular domain (i.e., its effective edge length is zero) is explicitly set to zero.\n\n### 4. Energy Conservation and Verification\nThe discrete electromagnetic energy per unit length, $\\mathcal{W}^n$, is a measure of the total energy stored in the fields within the circular cavity. It is computed at each integer time step $n$. Since the TE$_z$ fields are defined at different time instances, a time-averaging step is required for the magnetic field to co-locate it with the electric field:\n$$ H_z^n = \\frac{1}{2} \\left( H_z^{n-\\frac{1}{2}} + H_z^{n+\\frac{1}{2}} \\right) $$\nThe total energy is then the sum of the magnetic and electric energy contributions:\n$$ \\mathcal{W}^n = \\frac{1}{2}\\mu_0 \\sum_{i,j} \\left(H_z^n(i,j)\\right)^2 A_{\\text{eff}}(i,j) + \\frac{1}{2}\\varepsilon_0 \\sum_{i,j} \\left(E_x^n(i,j)\\right)^2 \\, \\Delta x \\, \\ell^\\star_{x}(i,j) + \\frac{1}{2}\\varepsilon_0 \\sum_{i,j} \\left(E_y^n(i,j)\\right)^2 \\, \\Delta y \\, \\ell^\\star_{y}(i,j) $$\nFor a lossless system, this quantity should be conserved. The verification metric $\\delta_{\\min}$ quantifies the maximum fractional deviation from the initial energy $\\mathcal{W}^0$ throughout the simulation:\n$$ \\delta_{\\min} = \\frac{\\mathcal{W}^0 - \\min_{0 \\le n \\le N_t} \\mathcal{W}^n}{\\mathcal{W}^0} $$\nA small value of $\\delta_{\\min}$ indicates that the numerical scheme is not artificially dissipative and correctly models the lossless nature of the PEC cavity. The algorithm is implemented to calculate this metric for the three specified test cases.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the FDTD simulations for all test cases and print the results.\n    \"\"\"\n\n    class ConformalFDTDSim:\n        \"\"\"\n        Encapsulates the logic for a 2D TEz conformal FDTD simulation.\n        \"\"\"\n        def __init__(self, Lx, Ly, Nx, Ny, R, alpha, Nt, p):\n            # Physical constants\n            self.EPS0 = 8.854187817e-12\n            self.MU0 = 4 * np.pi * 1e-7\n            self.C = 1 / np.sqrt(self.EPS0 * self.MU0)\n\n            # Simulation parameters\n            self.Lx, self.Ly = Lx, Ly\n            self.Nx, self.Ny = Nx, Ny\n            self.R = R\n            self.alpha = alpha\n            self.Nt = Nt\n            self.p = p\n\n            # Discretization\n            self.dx = self.Lx / self.Nx\n            self.dy = self.Ly / self.Ny\n            self.dt = self.alpha / (self.C * np.sqrt(1/self.dx**2 + 1/self.dy**2))\n\n            # Precompute geometric factors\n            self._precompute_geometry()\n\n        def _compute_len(self, p0, p1, R, orth_coord):\n            \"\"\"Computes intersection length of a segment with a circle's chord.\"\"\"\n            if np.abs(orth_coord) >= R:\n                return 0.0\n            chord_half_len = np.sqrt(R**2 - orth_coord**2)\n            overlap_min = max(p0, -chord_half_len)\n            overlap_max = min(p1, chord_half_len)\n            return max(0.0, overlap_max - overlap_min)\n\n        def _precompute_geometry(self):\n            \"\"\"Precomputes all geometric factors for the conformal FDTD scheme.\"\"\"\n            # Grid coordinates\n            x_h = -self.Lx/2 + (np.arange(self.Nx) + 0.5) * self.dx\n            y_h = -self.Ly/2 + (np.arange(self.Ny) + 0.5) * self.dy\n            x_ey = -self.Lx/2 + np.arange(self.Nx + 1) * self.dx\n            y_ex = -self.Ly/2 + np.arange(self.Ny + 1) * self.dy\n            \n            # --- Geometry for H_z update ---\n            self.A_eff = np.zeros((self.Nx, self.Ny))\n            self.l_top = np.zeros((self.Nx, self.Ny))\n            self.l_bot = np.zeros((self.Nx, self.Ny))\n            self.l_left = np.zeros((self.Nx, self.Ny))\n            self.l_right = np.zeros((self.Nx, self.Ny))\n\n            for i in range(self.Nx):\n                for j in range(self.Ny):\n                    x_min, x_max = x_ey[i], x_ey[i+1]\n                    y_min, y_max = y_ex[j], y_ex[j+1]\n\n                    # A_eff via subsampling\n                    sub_dx = self.dx / self.p\n                    sub_dy = self.dy / self.p\n                    sub_x = x_min + (np.arange(self.p) + 0.5) * sub_dx\n                    sub_y = y_min + (np.arange(self.p) + 0.5) * sub_dy\n                    sub_X, sub_Y = np.meshgrid(sub_x, sub_y)\n                    inside_mask = sub_X**2 + sub_Y**2 < self.R**2\n                    self.A_eff[i, j] = np.sum(inside_mask) / self.p**2 * self.dx * self.dy\n                    \n                    # Effective edge lengths\n                    self.l_bot[i, j] = self._compute_len(x_min, x_max, self.R, y_min)\n                    self.l_top[i, j] = self._compute_len(x_min, x_max, self.R, y_max)\n                    self.l_left[i, j] = self._compute_len(y_min, y_max, self.R, x_min)\n                    self.l_right[i, j] = self._compute_len(y_min, y_max, self.R, x_max)\n            \n            self.inv_mu0_A_eff = np.zeros((self.Nx, self.Ny))\n            mask = self.A_eff > 0\n            self.inv_mu0_A_eff[mask] = 1.0 / (self.MU0 * self.A_eff[mask])\n\n            # --- Geometry for E-field zeroing and Energy ---\n            ex_loc_x = -self.Lx/2 + (np.arange(self.Nx) + 0.5) * self.dx\n            ex_loc_y = -self.Ly/2 + np.arange(self.Ny + 1) * self.dy\n            ey_loc_x = -self.Lx/2 + np.arange(self.Nx + 1) * self.dx\n            ey_loc_y = -self.Ly/2 + (np.arange(self.Ny) + 0.5) * self.dy\n\n            self.l_x_edges = np.zeros((self.Nx, self.Ny + 1))\n            self.l_star_x = np.zeros((self.Nx, self.Ny + 1))\n            for i in range(self.Nx):\n                for j in range(self.Ny + 1):\n                    x, y = ex_loc_x[i], ex_loc_y[j]\n                    self.l_x_edges[i, j] = self._compute_len(x - self.dx/2, x + self.dx/2, self.R, y)\n                    self.l_star_x[i, j] = self._compute_len(y - self.dy/2, y + self.dy/2, self.R, x)\n\n            self.l_y_edges = np.zeros((self.Nx + 1, self.Ny))\n            self.l_star_y = np.zeros((self.Nx + 1, self.Ny))\n            for i in range(self.Nx + 1):\n                for j in range(self.Ny):\n                    x, y = ey_loc_x[i], ey_loc_y[j]\n                    self.l_y_edges[i, j] = self._compute_len(y - self.dy/2, y + self.dy/2, self.R, x)\n                    self.l_star_y[i, j] = self._compute_len(x - self.dx/2, x + self.dx/2, self.R, y)\n\n        def run(self):\n            \"\"\"Executes the FDTD time-stepping loop and returns the metric.\"\"\"\n            # Field arrays\n            ex = np.zeros((self.Nx, self.Ny + 1))\n            ey = np.zeros((self.Nx + 1, self.Ny))\n            hz = np.zeros((self.Nx, self.Ny))\n\n            # Initial condition for H_z at t=0 (used as t=-dt/2)\n            H0 = 1.0\n            sigma = 0.2 * self.R\n            x_h = -self.Lx/2 + (np.arange(self.Nx) + 0.5) * self.dx\n            y_h = -self.Ly/2 + (np.arange(self.Ny) + 0.5) * self.dy\n            X_h, Y_h = np.meshgrid(x_h, y_h, indexing='ij')\n            hz = H0 * np.exp(-(X_h**2 + Y_h**2) / (2 * sigma**2))\n            hz[self.A_eff == 0] = 0.0 # Enforce H=0 outside the physical domain\n\n            C_ex = self.dt / (self.EPS0 * self.dy)\n            C_ey = -self.dt / (self.EPS0 * self.dx)\n\n            W_history = []\n\n            for n in range(self.Nt):\n                hz_old = hz.copy() # H at n-1/2\n\n                # Update H_z to n+1/2\n                curl_E_x_term = ex[:, 1:] * self.l_top - ex[:, :-1] * self.l_bot\n                curl_E_y_term = ey[1:, :] * self.l_right - ey[:-1, :] * self.l_left\n                hz -= self.dt * self.inv_mu0_A_eff * (curl_E_y_term + curl_E_x_term)\n\n                # Time average H_z to get H at time n\n                hz_avg = 0.5 * (hz_old + hz)\n                \n                # Calculate energy at time n\n                W_H = 0.5 * self.MU0 * np.sum(hz_avg**2 * self.A_eff)\n                W_Ex = 0.5 * self.EPS0 * np.sum(ex**2 * self.dx * self.l_star_x)\n                W_Ey = 0.5 * self.EPS0 * np.sum(ey**2 * self.dy * self.l_star_y)\n                W_total = W_H + W_Ex + W_Ey\n                W_history.append(W_total)\n\n                # Update E_x to n+1\n                ex[:, 1:-1] += C_ex * (hz[:, 1:] - hz[:, :-1])\n                \n                # Update E_y to n+1\n                ey[1:-1, :] += C_ey * (hz[1:, :] - hz[:-1, :])\n\n                # Enforce PEC by zeroing E fields on edges outside the circle\n                ex[self.l_x_edges == 0] = 0.0\n                ey[self.l_y_edges == 0] = 0.0\n\n            W0 = W_history[0]\n            if W0 == 0:\n                return 0.0 \n            min_W = min(W_history)\n            delta_min = (W0 - min_W) / W0\n            return delta_min\n\n    # Test suite parameters\n    test_cases = [\n        # (Lx, Ly, Nx, Ny, R, alpha, Nt)\n        (1.0, 1.0, 80, 80, 0.4, 0.90, 1000),  # Case A\n        (1.0, 1.0, 64, 64, 0.2, 0.90, 800),   # Case B\n        (1.0, 1.0, 96, 96, 0.45, 0.98, 1200), # Case C\n    ]\n    p_subsampling = 8\n\n    results = []\n    for params in test_cases:\n        sim = ConformalFDTDSim(*params, p=p_subsampling)\n        result = sim.run()\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3294784"}, {"introduction": "Beyond verifying stability and energy conservation, a crucial step in developing numerical methods is to rigorously quantify their accuracy. The Method of Manufactured Solutions (MMS) provides a powerful framework for this task by comparing the numerical solution against a pre-defined, analytical \"manufactured\" solution. In this exercise, you will apply MMS to a 2D problem featuring the Dey-Mittra conformal scheme, calculating the numerical error, or residual, to verify that the discrete Maxwell's curl operators converge to their continuous counterparts at the expected rate [@problem_id:3298064].", "problem": "You are to implement, from first principles, a computational experiment that quantifies the residuals of discretized Maxwell curl equations under the Dey–Mittra conformal method in two-dimensional transverse magnetic (TM$_z$) polarization. The manufactured solution uses smooth fields in free space with a perfectly electric conductor (PEC) boundary defined by a circle. The Dey–Mittra conformal method modifies the finite-difference time-domain (FDTD) update equations near curved PEC boundaries by weighting edge lengths and face areas by their vacuum (non-PEC) fractions.\n\nThe domain is the square region $[0,1] \\times [0,1]$ in meters (SI units). Let the circle be centered at $(x_c,y_c)=(0.5,0.5)$ with radius $r$ (meters). The manufactured electric field is the TM$_z$ component\n$$\nE_z(x,y) = \\begin{cases}\n\\sin(\\pi x)\\cos(\\pi y)\\left(\\rho^2 - r^2\\right)^2, & \\rho > r, \\\\\n0, & \\rho \\le r,\n\\end{cases}\n$$\nwhere $\\rho^2 = (x-x_c)^2 + (y-y_c)^2$. This choice ensures $E_z=0$ on the circular PEC boundary and inside the PEC region. Consider vacuum with permittivity $\\varepsilon_0$ and permeability $\\mu_0$, and time-harmonic fields at angular frequency $\\omega$ (radians per second) using the phasor convention. In free space, the fundamental laws are $\\nabla \\times \\mathbf{E} = - i \\omega \\mu_0 \\mathbf{H}$ and $\\nabla \\times \\mathbf{H} = i \\omega \\varepsilon_0 \\mathbf{E}$.\n\nDiscretize on a uniform Yee grid with $N_x \\times N_y$ cells, spatial steps $\\Delta x = 1/N_x$ and $\\Delta y = 1/N_y$. Place electric field samples $E_z(i,j)$ at cell centers $(x_i,y_j)=((i+\\tfrac{1}{2})\\Delta x,(j+\\tfrac{1}{2})\\Delta y)$ for $i=0,\\dots,N_x-1$, $j=0,\\dots,N_y-1$. Place magnetic field samples on edges: $H_x(i,j)$ at $(x=(i+\\tfrac{1}{2})\\Delta x,y=j\\Delta y)$ for $i=0,\\dots,N_x-1$, $j=0,\\dots,N_y$ and $H_y(i,j)$ at $(x=i\\Delta x,y=(j+\\tfrac{1}{2})\\Delta y)$ for $i=0,\\dots,N_x$, $j=0,\\dots,N_y-1$. The continuous manufactured $E_z(x,y)$ induces continuous derivatives $\\partial E_z/\\partial x$ and $\\partial E_z/\\partial y$ (piecewise outside the PEC), which in vacuum yield the continuous magnetic fields via Faraday's law:\n$$\nH_x(x,y) = \\frac{i}{\\omega \\mu_0} \\frac{\\partial E_z}{\\partial y}(x,y), \\quad\nH_y(x,y) = \\frac{i}{\\omega \\mu_0} \\left(-\\frac{\\partial E_z}{\\partial x}(x,y)\\right),\n$$\nwith $H_x=H_y=0$ inside the PEC.\n\nImplement the Dey–Mittra weighting for curved PEC via geometric fractions:\n- For a vertical segment (supporting $H_x$ and the discrete $\\partial/\\partial y$ operator), at fixed $x$, segment endpoints $(y_0,y_1)$, the free-space length fraction $L_y^{\\mathrm{free}} \\in [0,1]$ is the fraction of segment length lying outside the circle $\\rho \\le r$.\n- For a horizontal segment (supporting $H_y$ and the discrete $\\partial/\\partial x$ operator), at fixed $y$, segment endpoints $(x_0,x_1)$, the free-space length fraction $L_x^{\\mathrm{free}} \\in [0,1]$ is defined analogously.\n- For a cell area, the free-space area fraction $A^{\\mathrm{free}} \\in [0,1]$ is the fraction of the rectangular cell area lying outside the circle. Approximate $A^{\\mathrm{free}}$ by uniform subcell sampling at $n_s \\times n_s$ points per cell with $n_s=16$.\n\nUsing these weights, form two discrete residuals under the Dey–Mittra method:\n1. The Faraday residual at interior magnetic edges (excluding outer domain boundaries where one-sided differences would be required) measures the weighted discrete curl of $\\mathbf{E}$ against the continuous derivative. For $H_x$ edges at indices $(i,j)$ with $j=1,\\dots,N_y-1$,\n$$\nR_{F,x}(i,j) = \\left[\\frac{L_y^{\\mathrm{free}}(i,j)}{\\Delta y}\\left(E_z(i,j) - E_z(i,j-1)\\right)\\right] - \\left.\\frac{\\partial E_z}{\\partial y}\\right|_{(x=(i+\\tfrac{1}{2})\\Delta x,\\; y=j\\Delta y)}.\n$$\nFor $H_y$ edges at indices $(i,j)$ with $i=1,\\dots,N_x-1$,\n$$\nR_{F,y}(i,j) = \\left[-\\frac{L_x^{\\mathrm{free}}(i,j)}{\\Delta x}\\left(E_z(i,j) - E_z(i-1,j)\\right)\\right] - \\left.\\left(-\\frac{\\partial E_z}{\\partial x}\\right)\\right|_{(x=i\\Delta x,\\; y=(j+\\tfrac{1}{2})\\Delta y)}.\n$$\nAggregate the Faraday residual as a single dimensionless relative $\\ell_2$ norm,\n$$\n\\mathcal{R}_F = \\sqrt{\\frac{\\sum |R_{F,x}|^2 + \\sum |R_{F,y}|^2}{\\sum \\left|\\left.\\frac{\\partial E_z}{\\partial y}\\right|\\right|^2 + \\sum \\left|\\left.-\\frac{\\partial E_z}{\\partial x}\\right|\\right|^2}},\n$$\nwhere sums are over the respective interior edge indices.\n\n2. The Ampère–Maxwell residual at electric field cell centers compares the weighted discrete curl of $\\mathbf{H}$ to $i\\omega\\varepsilon_0 E_z$. For a cell $(i,j)$, define the circulation using Dey–Mittra edge-length weights:\n$$\nC(i,j) = \\big[ L_x^{\\mathrm{free}}(i+1,j)\\, H_y(i+1,j) - L_x^{\\mathrm{free}}(i,j)\\, H_y(i,j) \\big] - \\big[ L_y^{\\mathrm{free}}(i,j+1)\\, H_x(i,j+1) - L_y^{\\mathrm{free}}(i,j)\\, H_x(i,j) \\big].\n$$\nThen the weighted discrete curl per unit free-space area is $C(i,j)/(A^{\\mathrm{free}}(i,j)\\Delta x \\Delta y)$ for cells with $A^{\\mathrm{free}}(i,j) > 0$. The residual at the cell center is\n$$\nR_A(i,j) = \\frac{C(i,j)}{A^{\\mathrm{free}}(i,j)\\Delta x \\Delta y} - i \\omega \\varepsilon_0 E_z(i,j),\n$$\nand the dimensionless relative $\\ell_2$ norm is\n$$\n\\mathcal{R}_A = \\sqrt{\\frac{\\sum_{A^{\\mathrm{free}}>0} |R_A|^2}{\\sum_{A^{\\mathrm{free}}>0} |i \\omega \\varepsilon_0 E_z|^2}}.\n$$\n\nYou must compute the above residuals for the following test suite of parameter sets, which explore typical and edge scenarios:\n- Case 1 (general “happy path”): $N_x=N_y=64$, $r=0.35\\,\\mathrm{m}$, $\\omega=2\\pi\\times 10^9\\,\\mathrm{rad/s}$.\n- Case 2 (near-boundary circle): $N_x=N_y=64$, $r=0.49\\,\\mathrm{m}$, $\\omega=2\\pi\\times 10^9\\,\\mathrm{rad/s}$.\n- Case 3 (coarse grid): $N_x=N_y=24$, $r=0.20\\,\\mathrm{m}$, $\\omega=2\\pi\\times 10^8\\,\\mathrm{rad/s}$.\n- Case 4 (higher frequency, finer grid): $N_x=N_y=96$, $r=0.15\\,\\mathrm{m}$, $\\omega=2\\pi\\times 2\\times 10^9\\,\\mathrm{rad/s}$.\n\nAll computations must use SI units (meters for geometry, radians per second for angular frequency). The outputs $\\mathcal{R}_F$ and $\\mathcal{R}_A$ are dimensionless floats. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a two-element list of floats in the order $[\\mathcal{R}_F,\\mathcal{R}_A]$. Specifically, the final output must be of the form\n$$\n\\texttt{[[rF1,rA1],[rF2,rA2],[rF3,rA3],[rF4,rA4]]}\n$$\nwith no additional text.", "solution": "The problem statement has been validated and is deemed sound, well-posed, and scientifically grounded in the principles of computational electromagnetics. It presents a clear task: to implement a method of manufactured solutions to quantify the accuracy of the Dey–Mittra conformal finite-difference time-domain (FDTD) method for a two-dimensional transverse magnetic (TM$_z$) problem involving a circular perfectly electric conductor (PEC). We will now proceed with a principled derivation and an outline of the computational algorithm.\n\nThe problem is defined in a square domain $x, y \\in [0, 1] \\times [0, 1]$ meters, with a circular PEC of radius $r$ centered at $(x_c, y_c) = (0.5, 0.5)$. The analysis is performed in the frequency domain, assuming time-harmonic fields with angular frequency $\\omega$ and a phasor dependence of $e^{i\\omega t}$.\n\nThe core of the validation lies in comparing the results of discrete operators applied to a known analytical solution with the analytical results of the corresponding continuous operators. This is the method of manufactured solutions.\n\n**1. Manufactured Solution and Analytical Fields**\n\nThe specified manufactured out-of-plane electric field component is:\n$$\nE_z(x,y) = \\begin{cases}\n\\sin(\\pi x)\\cos(\\pi y)\\left(\\rho^2 - r^2\\right)^2, & \\rho > r \\\\\n0, & \\rho \\le r\n\\end{cases}\n$$\nwhere $\\rho^2 = (x-x_c)^2 + (y-y_c)^2$. This function is zero on the PEC boundary ($\\rho=r$) and inside the PEC, satisfying the necessary boundary condition. The term $(\\rho^2-r^2)^2$ ensures that not only $E_z$ but also its first derivatives are zero on the boundary, leading to a smooth field behavior near the conductor.\n\nFrom Faraday's law in the frequency domain, $\\nabla \\times \\mathbf{E} = -i\\omega\\mu_0\\mathbf{H}$, we derive the analytical in-plane magnetic field components:\n$$\nH_x(x,y) = \\frac{i}{\\omega \\mu_0} \\frac{\\partial E_z}{\\partial y}, \\qquad H_y(x,y) = -\\frac{i}{\\omega \\mu_0} \\frac{\\partial E_z}{\\partial x}\n$$\nThe partial derivatives of $E_z$ are found using the product rule. Let $S(x) = \\sin(\\pi x)$, $C(y)=\\cos(\\pi y)$, and $P(x,y) = (\\rho^2 - r^2)^2$. Then $E_z = S(x)C(y)P(x,y)$.\n$$\n\\frac{\\partial E_z}{\\partial x} = [\\pi \\cos(\\pi x)C(y)]P(x,y) + S(x)C(y)\\left[\\frac{\\partial P}{\\partial x}\\right] = \\pi \\cos(\\pi x)\\cos(\\pi y)(\\rho^2-r^2)^2 + \\sin(\\pi x)\\cos(\\pi y) \\cdot 4(x-x_c)(\\rho^2-r^2)\n$$\n$$\n\\frac{\\partial E_z}{\\partial y} = [-\\pi S(x)\\sin(\\pi y)]P(x,y) + S(x)C(y)\\left[\\frac{\\partial P}{\\partial y}\\right] = -\\pi \\sin(\\pi x)\\sin(\\pi y)(\\rho^2-r^2)^2 + \\sin(\\pi x)\\cos(\\pi y) \\cdot 4(y-y_c)(\\rho^2-r^2)\n$$\nThese derivatives are zero for $\\rho \\le r$. These analytical expressions for $E_z$, $\\partial E_z/\\partial x$, and $\\partial E_z/\\partial y$ serve as the \"ground truth\" for our numerical experiment.\n\n**2. Discretization and The Yee Grid**\n\nThe domain is discretized into a uniform grid of $N_x \\times N_y$ cells, with grid spacings $\\Delta x = 1/N_x$ and $\\Delta y = 1/N_y$. The field components are staggered according to the Yee scheme:\n- $E_z(i,j)$ is at cell centers: $((i+\\frac{1}{2})\\Delta x, (j+\\frac{1}{2})\\Delta y)$.\n- $H_x(i,j)$ is at the midpoints of horizontal edges: $((i+\\frac{1}{2})\\Delta x, j\\Delta y)$.\n- $H_y(i,j)$ is at the midpoints of vertical edges: $(i\\Delta x, (j+\\frac{1}{2})\\Delta y)$.\n\n**3. Dey–Mittra Conformal Method Geometric Weights**\n\nThe Dey–Mittra method adapts the standard FDTD equations for cells and edges cut by the PEC boundary. This is achieved by weighting the finite difference stencil terms by geometric fractions representing the portion of the cell or edge that lies in free space.\n\n- **Area Fraction $A^{\\mathrm{free}}(i,j)$**: For each cell $(i,j)$, this is the fraction of its area $\\Delta x \\Delta y$ that is outside the circle $\\rho \\le r$. We approximate this by testing $n_s \\times n_s = 16 \\times 16$ uniformly distributed sub-points within the cell.\n\n- **Length Fractions $L_x^{\\mathrm{free}}(i,j)$ and $L_y^{\\mathrm{free}}(i,j)$**: For each edge segment on the Yee grid, this is the fraction of its length that is in free space. To compute this, we solve for the intersection of the line segment with the circle. A line segment from $\\mathbf{p}_0$ to $\\mathbf{p}_1$ is parameterized as $\\mathbf{p}(t) = \\mathbf{p}_0 + t(\\mathbf{p}_1-\\mathbf{p}_0)$ for $t \\in [0, 1]$. Substituting this into the circle equation $\\|\\mathbf{p}(t) - \\mathbf{c}\\|^2 = r^2$ yields a quadratic equation in $t$. The real roots of this equation between $0$ and $1$ are the intersection points. By analyzing the intervals between $\\{0, \\text{roots}, 1\\}$, we can sum the lengths of the sub-segments that lie outside the circle.\n\n**4. Residual Calculation**\n\nThe a priori residuals measure the extent to which the manufactured solution fails to satisfy the discrete Maxwell's equations.\n\n**Faraday's Law Residual ($\\mathcal{R}_F$):**\nThis residual quantifies the error in the discrete curl of $\\mathbf{E}$. The discrete approximation of $\\partial E_z/\\partial y$ at an $H_x$ location $(i,j)$ is $\\frac{1}{\\Delta y}(E_z(i,j) - E_z(i,j-1))$. The Dey-Mittra correction weights this by the length fraction of the corresponding dual grid edge, giving a modified term:\n$$\n\\left(\\nabla \\times \\mathbf{E}\\right)_{x, \\text{discrete}} \\approx \\frac{L_y^{\\mathrm{free}}(i,j)}{\\Delta y} (E_z(i,j) - E_z(i,j-1))\n$$\nThe residual $R_{F,x}$ is the difference between this discrete approximation and the exact analytical derivative $\\partial E_z/\\partial y$ at that point. A similar expression holds for $R_{F,y}$. The total residual $\\mathcal{R}_F$ is the relative $\\ell_2$ norm of these errors over all interior grid edges:\n$$\n\\mathcal{R}_F = \\sqrt{\\frac{\\sum_{i,j}^{\\text{int}} |R_{F,x}(i,j)|^2 + \\sum_{i,j}^{\\text{int}} |R_{F,y}(i,j)|^2}{\\sum_{i,j}^{\\text{int}} \\left|\\left.\\frac{\\partial E_z}{\\partial y}\\right|_{(i,j)}\\right|^2 + \\sum_{i,j}^{\\text{int}} \\left|\\left.-\\frac{\\partial E_z}{\\partial x}\\right|_{(i,j)}\\right|^2}}\n$$\n\n**Ampère-Maxwell Law Residual ($\\mathcal{R}_A$):**\nThis residual quantifies the error in the discrete curl of $\\mathbf{H}$. The discrete curl of $\\mathbf{H}$ at a cell $(i,j)$ is an approximation of $(\\nabla \\times \\mathbf{H})_z$ and is calculated as the circulation of $\\mathbf{H}$ around the cell, divided by the cell area. The Dey-Mittra method modifies both the circulation calculation (by weighting the $H$-field terms by their edge length fractions) and the area (by using the free-space area fraction $A^{\\mathrm{free}}$). The circulation is:\n$$\nC(i,j) = \\sum_{\\text{edges}} (\\mathbf{H} \\cdot \\Delta\\mathbf{l})_{\\text{weighted}} = \\big[ L_x^{\\mathrm{free}}(i+1,j) H_y(i+1,j) - L_x^{\\mathrm{free}}(i,j) H_y(i,j) \\big] - \\big[ L_y^{\\mathrm{free}}(i,j+1) H_x(i,j+1) - L_y^{\\mathrm{free}}(i,j) H_x(i,j) \\big]\n$$\nThe residual at the cell center is the difference between the discrete curl and the source term from Ampère's law:\n$$\nR_A(i,j) = \\frac{C(i,j)}{A^{\\mathrm{free}}(i,j)\\Delta x \\Delta y} - i \\omega \\varepsilon_0 E_z(i,j), \\quad \\text{for } A^{\\mathrm{free}}(i,j)>0\n$$\nThe total residual $\\mathcal{R}_A$ is the relative $\\ell_2$ norm over all cells with non-zero free-space area:\n$$\n\\mathcal{R}_A = \\sqrt{\\frac{\\sum_{i,j, A^{\\mathrm{free}}>0} |R_A(i,j)|^2}{\\sum_{i,j, A^{\\mathrm{free}}>0} |i \\omega \\varepsilon_0 E_z(i,j)|^2}}\n$$\n\n**5. Algorithm Implementation**\n\nThe algorithm proceeds as follows for each test case $(N_x, N_y, r, \\omega)$:\n1.  Define grid parameters ($\\Delta x, \\Delta y$) and physical constants ($\\varepsilon_0, \\mu_0$).\n2.  Generate coordinate arrays for all $E_z$, $H_x$, and $H_y$ grid locations.\n3.  Compute the geometric fractions $A^{\\mathrm{free}}$, $L_x^{\\mathrm{free}}$, and $L_y^{\\mathrm{free}}$ for all relevant cells and edges by implementing the sub-sampling and line-circle intersection algorithms.\n4.  Evaluate the analytical manufactured fields ($E_z$, $H_x$, $H_y$) on their respective Yee grid locations. The $H$ fields will be complex-valued.\n5.  Evaluate the analytical derivatives ($\\partial E_z/\\partial x$, $\\partial E_z/\\partial y$) at the appropriate magnetic field grid locations. These serve as the reference for the Faraday residual.\n6.  Calculate the Faraday residual $\\mathcal{R}_F$ by summing the squared errors over the interior magnetic field edges and normalizing.\n7.  Calculate the Ampère-Maxwell residual $\\mathcal{R}_A$ by computing the weighted circulation for each cell, comparing to the source term, summing the squared errors, and normalizing.\n8.  Store the pair $[\\mathcal{R}_F, \\mathcal{R}_A]$ for the given test case.\nThe final output is an aggregation of these pairs for all test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.constants import epsilon_0, mu_0\n\ndef get_line_segment_free_length_fraction(p0, p1, circle_center, circle_radius):\n    \"\"\"\n    Calculates the fraction of a line segment's length that is outside a circle.\n    \"\"\"\n    p0 = np.array(p0)\n    p1 = np.array(p1)\n    circle_center = np.array(circle_center)\n    \n    d = p1 - p0\n    f = p0 - circle_center\n    \n    a = np.dot(d, d)\n    b = 2 * np.dot(f, d)\n    c = np.dot(f, f) - circle_radius**2\n    \n    # If segment has zero length, check its position\n    if a < 1e-12:\n        return 1.0 if c > 0 else 0.0\n\n    discriminant = b**2 - 4*a*c\n    \n    if discriminant < 1e-9:  # No real roots or tangent\n        # Check midpoint of the segment\n        return 1.0 if c > 0 else 0.0\n\n    sqrt_discriminant = np.sqrt(discriminant)\n    t1 = (-b - sqrt_discriminant) / (2 * a)\n    t2 = (-b + sqrt_discriminant) / (2 * a)\n    \n    intersections = []\n    if 0 < t1 < 1:\n        intersections.append(t1)\n    if 0 < t2 < 1:\n        intersections.append(t2)\n        \n    points = sorted(list(set([0.0] + intersections + [1.0])))\n    \n    free_length_fraction = 0.0\n    for i in range(len(points) - 1):\n        t_start, t_end = points[i], points[i+1]\n        t_mid = (t_start + t_end) / 2.0\n        p_mid = p0 + t_mid * d\n        if np.dot(p_mid - circle_center, p_mid - circle_center) > circle_radius**2:\n            free_length_fraction += (t_end - t_start)\n            \n    return free_length_fraction\n\ndef manufactured_E_z(x, y, r, xc, yc):\n    \"\"\"Calculates the manufactured Ez field.\"\"\"\n    rho2 = (x - xc)**2 + (y - yc)**2\n    mask = rho2 > r**2\n    val = np.sin(np.pi * x) * np.cos(np.pi * y) * (rho2 - r**2)**2\n    return np.where(mask, val, 0.0)\n\ndef manufactured_dEz_dx(x, y, r, xc, yc):\n    \"\"\"Calculates the analytical partial derivative dEz/dx.\"\"\"\n    rho2 = (x - xc)**2 + (y - yc)**2\n    mask = rho2 > r**2\n    term1 = np.pi * np.cos(np.pi * x) * np.cos(np.pi * y) * (rho2 - r**2)**2\n    term2 = np.sin(np.pi * x) * np.cos(np.pi * y) * 4 * (x - xc) * (rho2 - r**2)\n    return np.where(mask, term1 + term2, 0.0)\n\ndef manufactured_dEz_dy(x, y, r, xc, yc):\n    \"\"\"Calculates the analytical partial derivative dEz/dy.\"\"\"\n    rho2 = (x - xc)**2 + (y - yc)**2\n    mask = rho2 > r**2\n    term1 = -np.pi * np.sin(np.pi * x) * np.sin(np.pi * y) * (rho2 - r**2)**2\n    term2 = np.sin(np.pi * x) * np.cos(np.pi * y) * 4 * (y - yc) * (rho2 - r**2)\n    return np.where(mask, term1 + term2, 0.0)\n\ndef calculate_residuals(Nx, Ny, r, omega):\n    \"\"\"\n    Computes Faraday and Ampere-Maxwell law residuals for a given parameter set.\n    \"\"\"\n    dx, dy = 1.0 / Nx, 1.0 / Ny\n    xc, yc = 0.5, 0.5\n    ns = 16  # Subsampling grid size\n\n    # --- 1. Coordinate Grids ---\n    x_e = (np.arange(Nx) + 0.5) * dx\n    y_e = (np.arange(Ny) + 0.5) * dy\n    xx_e, yy_e = np.meshgrid(x_e, y_e, indexing='ij')\n\n    x_hx = (np.arange(Nx) + 0.5) * dx\n    y_hx = np.arange(Ny + 1) * dy\n    xx_hx, yy_hx = np.meshgrid(x_hx, y_hx, indexing='ij')\n\n    x_hy = np.arange(Nx + 1) * dx\n    y_hy = (np.arange(Ny) + 0.5) * dy\n    xx_hy, yy_hy = np.meshgrid(x_hy, y_hy, indexing='ij')\n\n    circle_center = (xc, yc)\n    \n    # --- 2. Geometric Fractions ---\n    # Area fraction A_free\n    A_free = np.zeros((Nx, Ny))\n    sub_dx, sub_dy = dx / ns, dy / ns\n    sub_x_offsets = (np.arange(ns) + 0.5) * sub_dx\n    sub_y_offsets = (np.arange(ns) + 0.5) * sub_dy\n    for i in range(Nx):\n        for j in range(Ny):\n            cell_x_start, cell_y_start = i * dx, j * dy\n            sub_x = cell_x_start + sub_x_offsets\n            sub_y = cell_y_start + sub_y_offsets\n            ssx, ssy = np.meshgrid(sub_x, sub_y, indexing='ij')\n            rho2_sub = (ssx - xc)**2 + (ssy - yc)**2\n            outside_count = np.sum(rho2_sub > r**2)\n            A_free[i, j] = outside_count / (ns * ns)\n\n    # Length fraction L_y_free (for Hx edges, vertical dual segment)\n    L_y_free = np.zeros((Nx, Ny + 1))\n    for i in range(Nx):\n        x_pos = (i + 0.5) * dx\n        for j in range(Ny + 1):\n             L_y_free[i, j] = get_line_segment_free_length_fraction((x_pos, j * dy - dy/2), (x_pos, j * dy + dy/2), circle_center, r)\n\n    # Length fraction L_x_free (for Hy edges, horizontal dual segment)\n    L_x_free = np.zeros((Nx + 1, Ny))\n    for j in range(Ny):\n        y_pos = (j + 0.5) * dy\n        for i in range(Nx + 1):\n            L_x_free[i, j] = get_line_segment_free_length_fraction((i * dx-dx/2, y_pos), (i * dx+dx/2, y_pos), circle_center, r)\n\n    # --- 3. Evaluate Manufactured Solution ---\n    Ez_grid = manufactured_E_z(xx_e, yy_e, r, xc, yc)\n    \n    dEz_dy_at_hx = manufactured_dEz_dy(xx_hx, yy_hx, r, xc, yc)\n    dEz_dx_at_hy = manufactured_dEz_dx(xx_hy, yy_hy, r, xc, yc)\n\n    Hx_grid = (1j / (omega * mu_0)) * dEz_dy_at_hx\n    Hy_grid = (-1j / (omega * mu_0)) * dEz_dx_at_hy\n    \n    # --- 4. Faraday Residual R_F ---\n    num_R_F, den_R_F = 0.0, 0.0\n    \n    # Sum over interior Hx edges\n    for i in range(Nx):\n        for j in range(1, Ny):\n            disc_deriv = (L_y_free[i, j] / dy) * (Ez_grid[i, j] - Ez_grid[i, j - 1])\n            R_Fx = disc_deriv - dEz_dy_at_hx[i, j]\n            num_R_F += np.abs(R_Fx)**2\n            den_R_F += np.abs(dEz_dy_at_hx[i, j])**2\n            \n    # Sum over interior Hy edges\n    for j in range(Ny):\n        for i in range(1, Nx):\n            disc_deriv = -(L_x_free[i, j] / dx) * (Ez_grid[i, j] - Ez_grid[i - 1, j])\n            R_Fy = disc_deriv - (-dEz_dx_at_hy[i, j])\n            num_R_F += np.abs(R_Fy)**2\n            den_R_F += np.abs(dEz_dx_at_hy[i, j])**2\n            \n    R_F = np.sqrt(num_R_F / den_R_F) if den_R_F > 0 else 0.0\n\n    # --- 5. Ampere-Maxwell Residual R_A ---\n    num_R_A, den_R_A = 0.0, 0.0\n    \n    for i in range(Nx):\n        for j in range(Ny):\n            if A_free[i, j] > 1e-9:\n                # Weighted circulation C(i,j)\n                C_ij = (L_x_free[i + 1, j] * Hy_grid[i + 1, j] * dx - L_x_free[i, j] * Hy_grid[i, j] * dx) - \\\n                       (L_y_free[i, j + 1] * Hx_grid[i, j + 1] * dy - L_y_free[i, j] * Hx_grid[i, j] * dy)\n                \n                # Corrected C_ij definition: fractions apply to fields, not lengths which are already dx/dy\n                C_ij = (L_x_free[i + 1, j] * Hy_grid[i + 1, j] - L_x_free[i, j] * Hy_grid[i, j]) * dx - \\\n                       (L_y_free[i, j + 1] * Hx_grid[i, j + 1] - L_y_free[i, j] * Hx_grid[i, j]) * dy\n                \n                discrete_curl_H = C_ij / (A_free[i, j] * dx * dy)\n                \n                source_term = 1j * omega * epsilon_0 * Ez_grid[i, j]\n                R_Aij = discrete_curl_H - source_term\n                \n                num_R_A += np.abs(R_Aij)**2\n                den_R_A += np.abs(source_term)**2\n                \n    R_A = np.sqrt(num_R_A / den_R_A) if den_R_A > 0 else 0.0\n\n    return R_F, R_A\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (Nx, Ny, r, omega)\n        (64, 64, 0.35, 2 * np.pi * 1e9),\n        (64, 64, 0.49, 2 * np.pi * 1e9),\n        (24, 24, 0.20, 2 * np.pi * 1e8),\n        (96, 96, 0.15, 2 * np.pi * 2e9),\n    ]\n\n    results = []\n    for Nx, Ny, r, omega in test_cases:\n        res_F, res_A = calculate_residuals(Nx, Ny, r, omega)\n        results.append([res_F, res_A])\n\n    # Format the output string exactly as required\n    output_str = \"[\" + \",\".join([f\"[{rF:.6e},{rA:.6e}]\" for rF, rA in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "3298064"}]}