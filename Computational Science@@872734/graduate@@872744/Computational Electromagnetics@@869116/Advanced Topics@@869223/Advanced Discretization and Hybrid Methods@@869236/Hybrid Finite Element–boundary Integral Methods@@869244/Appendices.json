{"hands_on_practices": [{"introduction": "The heart of any hybrid FE-BI method lies in the coupling that occurs at the interface between the finite element and boundary integral domains. This first practice provides a foundational exercise in translating the physical principle of tangential field continuity into a discrete coupling matrix. By deriving and implementing the integral that links interior Nédélec basis functions to surface Rao-Wilton-Glisson (RWG) functions, you will gain first-hand experience with the essential mechanics of hybrid formulations [@problem_id:3315828].", "problem": "You are asked to derive and implement the discrete coupling between interior vector Finite Element Method (FEM) degrees of freedom and exterior surface basis functions used in the Boundary Element Method (BEM) for electromagnetic scattering. Specifically, consider the lowest-order Nédélec edge elements in tetrahedra for the interior field and the Rao–Wilton–Glisson (RWG) basis functions on a triangulated surface. Your task is to construct the coupling matrix entry that maps each interior edge-element degree of freedom to a single RWG coefficient by integrating the tangential trace of the interior basis functions against the RWG basis on the surface interface $\\Gamma$.\n\nStart from the following fundamental base:\n\n- Maxwell’s equations enforce the continuity of the tangential electric field across an interface, which leads to the weak enforcement involving surface integrals over the interface $\\Gamma$ of interior-trace fields against surface test functions.\n- The lowest-order Nédélec (first kind) edge basis function on a tetrahedron with vertices $\\boldsymbol{p}_0, \\boldsymbol{p}_1, \\boldsymbol{p}_2, \\boldsymbol{p}_3$ associated with edge $(i,j)$ is defined via barycentric coordinates as $\\boldsymbol{N}_{ij}(\\boldsymbol{r}) = \\lambda_i(\\boldsymbol{r}) \\nabla \\lambda_j - \\lambda_j(\\boldsymbol{r}) \\nabla \\lambda_i$, where $\\lambda_k$ are the barycentric coordinates and $\\nabla \\lambda_k$ are constant vectors on the tetrahedron.\n- The Rao–Wilton–Glisson (RWG) basis function is supported on two adjacent surface triangles $T^+$ and $T^-$ that share one common edge. It is defined piecewise as $\\boldsymbol{f}(\\boldsymbol{r}) = \\dfrac{l_e}{2 A^+}\\left(\\boldsymbol{r} - \\boldsymbol{r}^+_{\\text{op}}\\right)$ on $T^+$ and $\\boldsymbol{f}(\\boldsymbol{r}) = -\\dfrac{l_e}{2 A^-}\\left(\\boldsymbol{r} - \\boldsymbol{r}^-_{\\text{op}}\\right)$ on $T^-$, where $l_e$ is the length of the common edge, $A^\\pm$ are the areas of $T^\\pm$, and $\\boldsymbol{r}^\\pm_{\\text{op}}$ are the vertices opposite the common edge on $T^\\pm$. This vector field is tangential to the surface by construction.\n- On a triangular face, the barycentric coordinates satisfy standard integral identities. For a triangle $T$ with area $A$ and vertices indexed by $\\{a,b,c\\}$, the integrals of barycentric monomials are $\\int_T \\lambda_i \\, \\mathrm{d}S = \\dfrac{A}{3}$ for $i \\in \\{a,b,c\\}$ and $0$ otherwise; and $\\int_T \\lambda_i \\lambda_j \\, \\mathrm{d}S = \\dfrac{A}{6}$ if $i=j \\in \\{a,b,c\\}$, $\\dfrac{A}{12}$ if $i \\neq j$ with $i,j \\in \\{a,b,c\\}$, and $0$ otherwise. Also, for any point $\\boldsymbol{r} \\in T$, $\\boldsymbol{r} = \\lambda_a \\boldsymbol{p}_a + \\lambda_b \\boldsymbol{p}_b + \\lambda_c \\boldsymbol{p}_c$, so $\\int_T \\lambda_i \\boldsymbol{r} \\, \\mathrm{d}S = \\sum_{m \\in \\{a,b,c\\}} \\boldsymbol{p}_m \\int_T \\lambda_i \\lambda_m \\, \\mathrm{d}S$.\n\nThe coupling entry to be computed for a given interior edge $(i,j)$ with Nédélec basis $\\boldsymbol{N}_{ij}$ and a single RWG basis $\\boldsymbol{f}$ supported on $T^+$ and $T^-$ is the surface inner product over $\\Gamma$ restricted to the support of the RWG, namely the scalar\n$$\nC_{ij} = \\int_{T^+} \\boldsymbol{N}_{ij}(\\boldsymbol{r}) \\cdot \\boldsymbol{f}(\\boldsymbol{r}) \\, \\mathrm{d}S + \\int_{T^-} \\boldsymbol{N}_{ij}(\\boldsymbol{r}) \\cdot \\boldsymbol{f}(\\boldsymbol{r}) \\, \\mathrm{d}S.\n$$\nBecause $\\boldsymbol{f}$ is tangential to $\\Gamma$, and the Nédélec trace’s tangential projection is $\\boldsymbol{N}_{ij} - (\\boldsymbol{N}_{ij} \\cdot \\boldsymbol{n}) \\boldsymbol{n}$, the dot product $\\boldsymbol{N}_{ij} \\cdot \\boldsymbol{f}$ equals its tangential projection dotted with $\\boldsymbol{f}$, ensuring that the normal component of $\\boldsymbol{N}_{ij}$ does not contribute.\n\nGeometry and meshing for this problem are specified as follows:\n\n- The surface interface $\\Gamma$ is the union of two triangles $T^+$ and $T^-$ forming a square in the plane $z=0$:\n  - $\\boldsymbol{v}_0 = (0,0,0)$,\n  - $\\boldsymbol{v}_1 = (1,0,0)$,\n  - $\\boldsymbol{v}_2 = (0,1,0)$,\n  - $\\boldsymbol{v}_3 = (1,1,0)$.\n  - $T^+$ has vertices $(\\boldsymbol{v}_0,\\boldsymbol{v}_1,\\boldsymbol{v}_2)$.\n  - $T^-$ has vertices $(\\boldsymbol{v}_3,\\boldsymbol{v}_2,\\boldsymbol{v}_1)$.\n  - The common edge is between $\\boldsymbol{v}_1$ and $\\boldsymbol{v}_2$. The opposite vertices are $\\boldsymbol{v}_0$ for $T^+$ and $\\boldsymbol{v}_3$ for $T^-$.\n- The interior domain is meshed by two tetrahedra, one attached to each triangle:\n  - Tetrahedron $A$ has vertices $(\\boldsymbol{v}_0,\\boldsymbol{v}_1,\\boldsymbol{v}_2,\\boldsymbol{v}_4)$.\n  - Tetrahedron $B$ has vertices $(\\boldsymbol{v}_3,\\boldsymbol{v}_2,\\boldsymbol{v}_1,\\boldsymbol{v}_5)$.\n- For each tetrahedron, consider all $6$ lowest-order Nédélec basis functions associated with edges $(0,1)$, $(0,2)$, $(0,3)$, $(1,2)$, $(1,3)$, $(2,3)$ in local vertex indexing. This yields a total of $12$ interior edge-element degrees of freedom.\n- The coupling matrix thus maps these $12$ interior degrees of freedom to the single RWG coefficient supported on $(T^+,T^-)$; it will be represented as a single row vector of length $12$.\n\nYour tasks:\n\n1. Derive from the base definitions an exact expression for each integral $\\int_{T^\\pm} \\boldsymbol{N}_{ij}(\\boldsymbol{r}) \\cdot \\boldsymbol{f}(\\boldsymbol{r}) \\, \\mathrm{d}S$ using only barycentric identities on the triangle $T^\\pm$ and the constant gradients $\\nabla \\lambda_k$ from the adjacent tetrahedron. Express all intermediate steps clearly in your solution and justify the elimination of the normal component of $\\boldsymbol{N}_{ij}$ from the integral due to the tangentiality of $\\boldsymbol{f}$.\n2. Implement a program that constructs the coupling row for three different test cases (varying the interior apex positions $\\boldsymbol{v}_4$ and $\\boldsymbol{v}_5$):\n   - Test case $1$: $\\boldsymbol{v}_4 = (0,0,1)$, $\\boldsymbol{v}_5 = (1,1,1)$.\n   - Test case $2$: $\\boldsymbol{v}_4 = (0.2,0.1,0.9)$, $\\boldsymbol{v}_5 = (0.8,1.3,1.1)$.\n   - Test case $3$: $\\boldsymbol{v}_4 = (-0.1,0.2,0.7)$, $\\boldsymbol{v}_5 = (1.1,0.9,1.4)$.\n3. Use exact barycentric integral identities on triangles and exact analytic gradients of barycentric coordinates on tetrahedra. Do not use numerical quadrature.\n4. Your program should produce a single line of output containing the three coupling rows as a comma-separated list of lists, each inner list being the $12$-entry row of real numbers for the corresponding test case, formatted like $[[r_{1,1},\\dots,r_{1,12}],[r_{2,1},\\dots,r_{2,12}],[r_{3,1},\\dots,r_{3,12}]]$.\n\nNo user input is permitted. The output contains pure numbers without units, since the integral is dimensionally consistent within the discretization. Angles are not involved in this computation.\n\nMake sure your derivation and implementation demonstrate the chain from electromagnetic interface conditions to the discretized coupling, and that the final computation uses only the definitions and identities provided. The test suite covers a typical configuration, a mildly skewed interior mesh, and a more pronounced skew, to probe stability of the construction. The final answer must be a complete, runnable program.", "solution": "The problem requires the derivation and implementation of the coupling matrix entries between interior Nédélec finite element basis functions and exterior RWG boundary element basis functions. The coupling is established through a surface integral on the interface between the FEM and BEM domains.\n\n### Problem Validation\n\nThe given problem is first subjected to a rigorous validation procedure.\n\n**Step 1: Extract Givens**\n- **Coupling Integral**: $C_{ij} = \\int_{T^+} \\boldsymbol{N}_{ij}(\\boldsymbol{r}) \\cdot \\boldsymbol{f}(\\boldsymbol{r}) \\, \\mathrm{d}S + \\int_{T^-} \\boldsymbol{N}_{ij}(\\boldsymbol{r}) \\cdot \\boldsymbol{f}(\\boldsymbol{r}) \\, \\mathrm{d}S$.\n- **Nédélec Basis (lowest-order, first kind)**: $\\boldsymbol{N}_{ij}(\\boldsymbol{r}) = \\lambda_i(\\boldsymbol{r}) \\nabla \\lambda_j - \\lambda_j(\\boldsymbol{r}) \\nabla \\lambda_i$.\n- **RWG Basis**: $\\boldsymbol{f}(\\boldsymbol{r}) = \\frac{l_e}{2 A^+}(\\boldsymbol{r} - \\boldsymbol{r}^+_{\\text{op}})$ on $T^+$ and $\\boldsymbol{f}(\\boldsymbol{r}) = -\\frac{l_e}{2 A^-}(\\boldsymbol{r} - \\boldsymbol{r}^-_{\\text{op}})$ on $T^-$.\n- **Barycentric Integral Identities (on a triangle $T$ of area $A$ with vertices $\\{a,b,c\\}$)**:\n  - $\\int_T \\lambda_i \\, \\mathrm{d}S = A/3$ for $i \\in \\{a,b,c\\}$.\n  - $\\int_T \\lambda_i \\lambda_j \\, \\mathrm{d}S = A/6$ for $i=j \\in \\{a,b,c\\}$; $A/12$ for $i \\neq j \\in \\{a,b,c\\}$.\n  - $\\int_T \\lambda_i \\boldsymbol{r} \\, \\mathrm{d}S = \\sum_{m \\in \\{a,b,c\\}} \\boldsymbol{p}_m \\int_T \\lambda_i \\lambda_m \\, \\mathrm{d}S$.\n- **Geometry**:\n  - Surface vertices: $\\boldsymbol{v}_0 = (0,0,0)$, $\\boldsymbol{v}_1 = (1,0,0)$, $\\boldsymbol{v}_2 = (0,1,0)$, $\\boldsymbol{v}_3 = (1,1,0)$.\n  - $T^+$ vertices: $(\\boldsymbol{v}_0,\\boldsymbol{v}_1,\\boldsymbol{v}_2)$. $T^-$ vertices: $(\\boldsymbol{v}_3,\\boldsymbol{v}_2,\\boldsymbol{v}_1)$.\n  - Common edge for RWG: $(\\boldsymbol{v}_1, \\boldsymbol{v}_2)$, with opposite vertices $\\boldsymbol{r}^+_{\\text{op}} = \\boldsymbol{v}_0$ and $\\boldsymbol{r}^-_{\\text{op}} = \\boldsymbol{v}_3$.\n  - Tetrahedron $A$: $(\\boldsymbol{v}_0,\\boldsymbol{v}_1,\\boldsymbol{v_2},\\boldsymbol{v}_4)$. Tetrahedron $B$: $(\\boldsymbol{v}_3,\\boldsymbol{v}_2,\\boldsymbol{v}_1,\\boldsymbol{v}_5)$.\n- **Degrees of Freedom**: $6$ Nédélec edges for each tetrahedron, for a total of $12$. The order is specified as local edges $(0,1), (0,2), (0,3), (1,2), (1,3), (2,3)$ for Tet $A$, then for Tet $B$.\n- **Test Cases**: Three pairs of coordinates for $(\\boldsymbol{v}_4, \\boldsymbol{v}_5)$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded in the principles of computational electromagnetics, specifically hybrid FEM-BEM formulations. The basis function definitions and mathematical identities are standard and correct. The problem is well-posed, providing all necessary geometric and mathematical information to arrive at a unique, computable solution. The language is objective and precise. The problem is non-trivial and tests core concepts of the discretization method. There are no contradictions, ambiguities, or unrealistic assumptions.\n\n**Step 3: Verdict and Action**\nThe problem is deemed **valid**. A full derivation and solution will be provided.\n\n### Derivation of the Coupling Integral\n\nThe goal is to derive an analytical expression for the coupling entry $C_{ij}$. This entry represents the weak-form coupling between an interior Nédélec basis function $\\boldsymbol{N}_{ij}$ and a surface RWG basis function $\\boldsymbol{f}$.\n\nThe total coupling is the sum of integrals over the two triangles $T^+$ and $T^-$ that constitute the support of $\\boldsymbol{f}$:\n$$C_{ij} = \\int_{T^+} \\boldsymbol{N}_{ij}(\\boldsymbol{r}) \\cdot \\boldsymbol{f}(\\boldsymbol{r}) \\, \\mathrm{d}S + \\int_{T^-} \\boldsymbol{N}_{ij}(\\boldsymbol{r}) \\cdot \\boldsymbol{f}(\\boldsymbol{r}) \\, \\mathrm{d}S$$\nThe Nédélec basis function $\\boldsymbol{N}_{ij}$ is associated with a specific tetrahedron. For a basis function on tetrahedron $A$, its support is limited to tetrahedron $A$. Since $T^-$ is not a face of tetrahedron $A$, the restriction of any basis function from $A$ to $T^-$ is zero. Consequently, for a basis function $\\boldsymbol{N}_{A,ij}$ from tetrahedron $A$, the coupling integral simplifies to:\n$$C_{A,ij} = \\int_{T^+} \\boldsymbol{N}_{A,ij}(\\boldsymbol{r}) \\cdot \\boldsymbol{f}(\\boldsymbol{r}) \\, \\mathrm{d}S$$\nSimilarly, for a basis function $\\boldsymbol{N}_{B,kl}$ from tetrahedron $B$, which has $T^-$ as a face, the coupling is:\n$$C_{B,kl} = \\int_{T^-} \\boldsymbol{N}_{B,kl}(\\boldsymbol{r}) \\cdot \\boldsymbol{f}(\\boldsymbol{r}) \\, \\mathrm{d}S$$\n\nLet us derive a general formula for the integral $I_T = \\int_T \\boldsymbol{N}_{ij}(\\boldsymbol{r}) \\cdot \\boldsymbol{f}(\\boldsymbol{r}) \\, \\mathrm{d}S$, where $T$ is a face of the tetrahedron supporting $\\boldsymbol{N}_{ij}$. We substitute the definitions:\n$$I_T = \\int_T \\left(\\lambda_i \\nabla \\lambda_j - \\lambda_j \\nabla \\lambda_i\\right) \\cdot \\alpha_T (\\boldsymbol{r} - \\boldsymbol{r}_{\\text{op}}) \\, \\mathrm{d}S$$\nwhere $\\alpha_T$ is the scalar coefficient of the RWG function on triangle $T$ and $\\boldsymbol{r}_{\\text{op}}$ is the opposite vertex. As the gradients $\\nabla\\lambda_k$ are constant vectors within the tetrahedron, we can take them and $\\alpha_T$ out of the integral:\n$$I_T = \\alpha_T \\left[ \\nabla \\lambda_j \\cdot \\int_T \\lambda_i (\\boldsymbol{r} - \\boldsymbol{r}_{\\text{op}}) \\, \\mathrm{d}S - \\nabla \\lambda_i \\cdot \\int_T \\lambda_j (\\boldsymbol{r} - \\boldsymbol{r}_{\\text{op}}) \\, \\mathrm{d}S \\right]$$\nLet's define the vector integral $\\boldsymbol{K}_k = \\int_T \\lambda_k (\\boldsymbol{r} - \\boldsymbol{r}_{\\text{op}}) \\, \\mathrm{d}S$. Then $I_T = \\alpha_T (\\nabla \\lambda_j \\cdot \\boldsymbol{K}_i - \\nabla \\lambda_i \\cdot \\boldsymbol{K}_j)$. The integral $\\boldsymbol{K}_k$ can be evaluated using the provided barycentric identities.\nThe functions $\\lambda_k$ are the barycentric coordinates of the tetrahedron. Let the tetrahedron have vertices $\\{\\boldsymbol{p}_0, \\boldsymbol{p}_1, \\boldsymbol{p}_2, \\boldsymbol{p}_3\\}$, and let triangle $T$ be the face with vertices $\\{\\boldsymbol{p}_a, \\boldsymbol{p}_b, \\boldsymbol{p}_c\\}$. On this face, the barycentric coordinate corresponding to the fourth vertex (not on the face) is zero. The other three tetrahedral barycentric coordinates, when restricted to $T$, behave exactly as the triangular barycentric coordinates of $T$.\nIf the index $k$ of a Nédélec basis vertex is not among the vertices of the face $T$ (i.e., $k \\notin \\{a,b,c\\}$), then $\\lambda_k(\\boldsymbol{r}) = 0$ for all $\\boldsymbol{r} \\in T$, which implies $\\boldsymbol{K}_k = \\boldsymbol{0}$. This correctly captures that an edge element not touching a face has no tangential trace on it.\nIf $k \\in \\{a,b,c\\}$, we expand $\\boldsymbol{K}_k$:\n$$\\boldsymbol{K}_k = \\int_T \\lambda_k \\boldsymbol{r} \\, \\mathrm{d}S - \\boldsymbol{r}_{\\text{op}} \\int_T \\lambda_k \\, \\mathrm{d}S$$\nUsing the identities, with $A_T$ being the area of triangle $T$:\n$\\int_T \\lambda_k \\, \\mathrm{d}S = A_T/3$.\n$\\int_T \\lambda_k \\boldsymbol{r} \\, \\mathrm{d}S = \\sum_{m \\in \\{a,b,c\\}} \\boldsymbol{p}_m \\int_T \\lambda_k \\lambda_m \\, \\mathrm{d}S = \\boldsymbol{p}_k (A_T/6) + \\sum_{m \\in \\{a,b,c\\}, m\\neq k} \\boldsymbol{p}_m (A_T/12) = \\frac{A_T}{12} (2\\boldsymbol{p}_k + \\sum_{m \\in \\{a,b,c\\}, m\\neq k} \\boldsymbol{p}_m) = \\frac{A_T}{12} (\\boldsymbol{p}_k + \\sum_{m \\in \\{a,b,c\\}} \\boldsymbol{p}_m)$.\nSubstituting these into the expression for $\\boldsymbol{K}_k$:\n$$\\boldsymbol{K}_k = \\frac{A_T}{12} \\left(\\boldsymbol{p}_k + \\sum_{m \\in \\{a,b,c\\}} \\boldsymbol{p}_m \\right) - \\boldsymbol{r}_{\\text{op}} \\frac{A_T}{3} = \\frac{A_T}{12} \\left(\\boldsymbol{p}_k + \\sum_{m \\in \\{a,b,c\\}} \\boldsymbol{p}_m - 4\\boldsymbol{r}_{\\text{op}}\\right)$$\nThe term $\\boldsymbol{N}_{ij} \\cdot \\boldsymbol{f}$ correctly handles the tangential coupling. The RWG function $\\boldsymbol{f}$ is tangential to the surface $\\Gamma$ by its definition. $\\boldsymbol{N}_{ij}$ can be decomposed into tangential and normal components, $\\boldsymbol{N}_{ij} = \\boldsymbol{N}_{ij,t} + \\boldsymbol{N}_{ij,n}$. The dot product is $\\boldsymbol{N}_{ij} \\cdot \\boldsymbol{f} = \\boldsymbol{N}_{ij,t} \\cdot \\boldsymbol{f} + \\boldsymbol{N}_{ij,n} \\cdot \\boldsymbol{f}$. Since $\\boldsymbol{f}$ is tangential, its dot product with the normal component $\\boldsymbol{N}_{ij,n}$ is zero, so $\\boldsymbol{N}_{ij,n} \\cdot \\boldsymbol{f} = 0$. Thus, the integral correctly captures the interaction between the tangential components of the fields, as required by electromagnetic boundary conditions.\n\n### Implementation Specifics\n\nThe implementation calculates this integral for each of the $12$ interior Nédélec basis functions.\n\n**1. Geometric Constants:**\n- $T^+$ has vertices $\\boldsymbol{v}_0, \\boldsymbol{v}_1, \\boldsymbol{v}_2$. Area $A^+ = 1/2$. $\\boldsymbol{r}^+_{\\text{op}} = \\boldsymbol{v}_0$.\n- $T^-$ has vertices $\\boldsymbol{v}_3, \\boldsymbol{v}_2, \\boldsymbol{v}_1$. Area $A^- = 1/2$. $\\boldsymbol{r}^-_{\\text{op}} = \\boldsymbol{v}_3$.\n- Common edge length $l_e = ||\\boldsymbol{v}_2 - \\boldsymbol{v}_1|| = \\sqrt{2}$.\n- RWG coefficient for $T^+$: $\\alpha_{T^+} = l_e / (2A^+) = \\sqrt{2}$.\n- RWG coefficient for $T^-$: $\\alpha_{T^-} = -l_e / (2A^-) = -\\sqrt{2}$.\n\n**2. Gradient Calculation:** For a tetrahedron with vertices $\\boldsymbol{p}_0, \\boldsymbol{p}_1, \\boldsymbol{p}_2, \\boldsymbol{p}_3$, we define the matrix $S = [\\boldsymbol{p}_1-\\boldsymbol{p}_0, \\boldsymbol{p}_2-\\boldsymbol{p}_0, \\boldsymbol{p}_3-\\boldsymbol{p}_0]$. The gradients of the barycentric coordinates $\\lambda_1, \\lambda_2, \\lambda_3$ are the rows of $S^{-1}$. The gradient $\\nabla\\lambda_0$ is computed from the sum property $\\sum_{k=0}^3 \\lambda_k = 1$, which implies $\\sum_{k=0}^3 \\nabla\\lambda_k = \\boldsymbol{0}$.\n\n**3. Coupling for Tetrahedron A:**\n- Local vertices: $(\\boldsymbol{p}_0, \\boldsymbol{p}_1, \\boldsymbol{p}_2, \\boldsymbol{p}_3)_{\\text{A}} = (\\boldsymbol{v}_0, \\boldsymbol{v}_1, \\boldsymbol{v}_2, \\boldsymbol{v}_4)$.\n- Interface face: $T^+$ with local vertices $\\{0,1,2\\}$.\n- The vector integrals $\\boldsymbol{K}_{A,k}$ are non-zero only for $k \\in \\{0,1,2\\}$.\n- The coupling for edge $(i,j)$ is $C_{A,ij} = \\alpha_{T^+} (\\nabla \\lambda_{Aj} \\cdot \\boldsymbol{K}_{A,i} - \\nabla \\lambda_{Ai} \\cdot \\boldsymbol{K}_{A,j})$.\n\n**4. Coupling for Tetrahedron B:**\n- Local vertices: $(\\boldsymbol{p}_0, \\boldsymbol{p}_1, \\boldsymbol{p}_2, \\boldsymbol{p}_3)_{\\text{B}} = (\\boldsymbol{v}_3, \\boldsymbol{v}_2, \\boldsymbol{v}_1, \\boldsymbol{v}_5)$.\n- Interface face: $T^-$ with local vertices $\\{0,1,2\\}$.\n- The vector integrals $\\boldsymbol{K}_{B,k}$ are non-zero only for $k \\in \\{0,1,2\\}$.\n- The coupling for edge $(k,l)$ is $C_{B,kl} = \\alpha_{T^-} (\\nabla \\lambda_{Bl} \\cdot \\boldsymbol{K}_{B,k} - \\nabla \\lambda_{Bk} \\cdot \\boldsymbol{K}_{B,l})$.\n\nThe program below implements this logic for the three test cases.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements the FEM-BEM coupling matrix for the specified problem.\n    \"\"\"\n    # Define the surface vertices\n    v0 = np.array([0.0, 0.0, 0.0])\n    v1 = np.array([1.0, 0.0, 0.0])\n    v2 = np.array([0.0, 1.0, 0.0])\n    v3 = np.array([1.0, 1.0, 0.0])\n\n    # Test cases for the apex vertices v4 and v5\n    test_cases = [\n        (np.array([0.0, 0.0, 1.0]), np.array([1.0, 1.0, 1.0])),\n        (np.array([0.2, 0.1, 0.9]), np.array([0.8, 1.3, 1.1])),\n        (np.array([-0.1, 0.2, 0.7]), np.array([1.1, 0.9, 1.4])),\n    ]\n\n    all_results = []\n\n    # Geometric properties of the RWG basis support\n    # Triangle T+\n    T_plus_verts = [v0, v1, v2]\n    A_plus = 0.5 * np.linalg.norm(np.cross(v1 - v0, v2 - v0))\n    r_op_plus = v0\n\n    # Triangle T-\n    T_minus_verts = [v3, v2, v1]\n    A_minus = 0.5 * np.linalg.norm(np.cross(v2 - v3, v1 - v3))\n    r_op_minus = v3\n\n    # Common edge length for RWG\n    l_e = np.linalg.norm(v2 - v1)\n\n    # RWG coefficients\n    alpha_plus = l_e / (2 * A_plus)\n    alpha_minus = -l_e / (2 * A_minus)\n\n    # Local edge indexing for a tetrahedron\n    edges = [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]\n\n    def compute_grads(p0, p1, p2, p3):\n        \"\"\"Computes the gradients of barycentric coordinates for a tetrahedron.\"\"\"\n        S = np.array([p1 - p0, p2 - p0, p3 - p0]).T\n        inv_S = np.linalg.inv(S)\n        grad1 = inv_S[0, :]\n        grad2 = inv_S[1, :]\n        grad3 = inv_S[2, :]\n        grad0 = -(grad1 + grad2 + grad3)\n        return [grad0, grad1, grad2, grad3]\n\n    def compute_K_vectors(face_verts, r_op, area):\n        \"\"\"Computes the vector integrals K_k for a triangular face.\"\"\"\n        p_a, p_b, p_c = face_verts\n        sum_p = p_a + p_b + p_c\n        K_vecs = {}\n        # k=a (local index 0 on face)\n        K_vecs[0] = (area / 12.0) * (p_a + sum_p - 4 * r_op)\n        # k=b (local index 1 on face)\n        K_vecs[1] = (area / 12.0) * (p_b + sum_p - 4 * r_op)\n        # k=c (local index 2 on face)\n        K_vecs[2] = (area / 12.0) * (p_c + sum_p - 4 * r_op)\n        return K_vecs\n\n    for v4, v5 in test_cases:\n        coupling_row = []\n\n        # === Tetrahedron A ===\n        tet_A_verts = [v0, v1, v2, v4]\n        grads_A = compute_grads(*tet_A_verts)\n        # Face T+ corresponds to local vertices 0, 1, 2 of Tet A\n        # The K vectors need to be indexed by local tet indices (0, 1, 2)\n        K_vecs_A_face = compute_K_vectors(T_plus_verts, r_op_plus, A_plus)\n        K_A = {0: K_vecs_A_face[0], 1: K_vecs_A_face[1], 2: K_vecs_A_face[2], 3: np.zeros(3)}\n        \n        for i, j in edges:\n            K_i = K_A[i]\n            K_j = K_A[j]\n            grad_i = grads_A[i]\n            grad_j = grads_A[j]\n            \n            C_ij = alpha_plus * (np.dot(grad_j, K_i) - np.dot(grad_i, K_j))\n            coupling_row.append(C_ij)\n\n        # === Tetrahedron B ===\n        tet_B_verts = [v3, v2, v1, v5]\n        grads_B = compute_grads(*tet_B_verts)\n        # Face T- corresponds to local vertices 0, 1, 2 of Tet B\n        K_vecs_B_face = compute_K_vectors(T_minus_verts, r_op_minus, A_minus)\n        K_B = {0: K_vecs_B_face[0], 1: K_vecs_B_face[1], 2: K_vecs_B_face[2], 3: np.zeros(3)}\n\n        for i, j in edges:\n            K_i = K_B[i]\n            K_j = K_B[j]\n            grad_i = grads_B[i]\n            grad_j = grads_B[j]\n            \n            C_ij = alpha_minus * (np.dot(grad_j, K_i) - np.dot(grad_i, K_j))\n            coupling_row.append(C_ij)\n            \n        all_results.append(coupling_row)\n\n    # Format the final output string exactly as required\n    output_str = f\"[{','.join([f'[{\",\".join(map(str, row))}]' for row in all_results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3315828"}, {"introduction": "In practical applications, requiring the finite element volume mesh to perfectly conform to the boundary integral surface mesh can be a significant constraint. This exercise tackles this real-world challenge by introducing a mortar method for non-conforming interfaces. You will implement a projection operator that conserves discrete charge, ensuring a physically consistent transfer of information between mismatched meshes and developing a critical skill for building flexible and robust hybrid solvers [@problem_id:3315760].", "problem": "Consider a single connected planar interface modeled as the interval $\\Gamma = [0,1]$ with the natural arc-length coordinate $s \\in [0,1]$. In time-harmonic electromagnetics with angular frequency $\\omega  0$, the surface (or line) charge conservation on $\\Gamma$ is given by the continuity equation in weak form: for any sufficiently smooth test function $\\varphi$, \n$$\n\\mathrm{i}\\,\\omega \\int_{\\Gamma} \\rho_s \\,\\varphi \\,\\mathrm{d}s + \\int_{\\Gamma} \\nabla_{\\!s} \\cdot \\mathbf{J}_t \\,\\varphi \\,\\mathrm{d}s = 0,\n$$\nwhere $\\rho_s$ is the surface charge density and $\\mathbf{J}_t$ is the tangential surface current density. In a one-dimensional interface model (the interval $\\Gamma$), the tangential field reduces to a scalar flux $j(s)$ constant within each surface element, and the surface divergence reduces to a signed difference of fluxes across adjacent elements.\n\nTwo independent discretizations of $\\Gamma$ are given:\n- A Finite Element (FE) surface mesh with nodes $\\mathcal{X} = \\{x_0, x_1, \\ldots, x_n\\}$, where $0 = x_0  x_1  \\cdots  x_n = 1$. The FE trace space is the space of piecewise constant functions on the FE elements $K_i = [x_i, x_{i+1}]$ for $i = 0, \\ldots, n-1$. The FE tangential flux is represented by coefficients $\\mathbf{v} \\in \\mathbb{R}^n$ where $v_i$ is the constant value of $j(s)$ on $K_i$.\n- A Boundary Integral (BI) surface mesh with nodes $\\mathcal{Y} = \\{y_0, y_1, \\ldots, y_m\\}$, where $0 = y_0  y_1  \\cdots  y_m = 1$. The BI trace space is the space of piecewise constant functions on the BI elements $I_j = [y_j, y_{j+1}]$ for $j = 0, \\ldots, m-1$. The BI tangential flux is represented by coefficients $\\mathbf{w} \\in \\mathbb{R}^m$ where $w_j$ is the constant value on $I_j$.\n\nThe computational objective is to transfer the tangential flux from the FE trace space to the BI trace space across a nonconforming interface (the meshes $\\mathcal{X}$ and $\\mathcal{Y}$ differ), using a mortar method that preserves discrete charge conservation. You must:\n\n- Design a mortar space $M_h$ and a projection operator $\\Pi : V_h(\\mathcal{X}) \\to W_h(\\mathcal{Y})$ that transfers $\\mathbf{v}$ to $\\mathbf{w} = \\Pi \\mathbf{v}$ such that discrete charge conservation is preserved at the BI mesh level. The design must start from the conservation law and a weak enforcement of continuity that is consistent with the divergence (difference) operator induced by the BI mesh. \n- The mortar space $M_h$ must be chosen so that the projection enforces equality of the integrals of $j(s)$ over each BI element, ensuring that for each BI element $I_j$ the integral of the transferred field equals that of the original field restricted to $I_j$.\n- The projection operator must be computable solely from the meshes $\\mathcal{X}$, $\\mathcal{Y}$ and the FE coefficients $\\mathbf{v}$, by integrating over element overlaps $K_i \\cap I_j$.\n\nYou must implement an algorithm that takes $(\\mathcal{X}, \\mathbf{v}, \\mathcal{Y})$ and returns $\\mathbf{w}$ with the following properties:\n- For every BI element $I_j$, the equality\n$$\n\\int_{I_j} \\left(\\sum_{i=0}^{n-1} v_i \\,\\chi_{K_i}(s)\\right)\\,\\mathrm{d}s \\;=\\; \\int_{I_j} \\left(\\sum_{j'=0}^{m-1} w_{j'} \\,\\chi_{I_{j'}}(s)\\right)\\,\\mathrm{d}s\n$$\nholds exactly in arithmetic, where $\\chi_{A}$ denotes the characteristic function of a set $A$; that is,\n$$\nw_j \\, |I_j| = \\sum_{i=0}^{n-1} v_i \\, |K_i \\cap I_j|.\n$$\n- This condition implies preservation of discrete charge conservation on the BI mesh in the sense that the cumulative integrals at BI nodes, $\\int_{0}^{y_k} j(s)\\,\\mathrm{d}s$, are preserved when computed from $\\mathbf{v}$ and from $\\mathbf{w}$.\n\nYour program must:\n- Implement the conservative mortar projection described above with a linear-time two-pointer sweep over the two meshes to accumulate overlap integrals.\n- For each test case, return the projected BI coefficients $\\mathbf{w}$ and a boolean indicating whether, within a numerical tolerance $\\varepsilon = 1 \\times 10^{-12}$, each BI cell integral computed from $\\mathbf{v}$ equals that computed from $\\mathbf{w}$.\n\nNo physical units are needed in this problem. Angles do not appear and need not be specified.\n\nTest Suite:\nProvide results for the following three test cases. Each test case is defined by the triplet $(\\mathcal{X}, \\mathbf{v}, \\mathcal{Y})$.\n\n- Test case $1$ (nonmatching meshes, mixed signs):\n  - $\\mathcal{X} = [0.0, 0.2, 0.5, 0.7, 1.0]$\n  - $\\mathbf{v} = [1.0, 0.0, 2.0, -1.0]$\n  - $\\mathcal{Y} = [0.0, 0.3, 0.6, 1.0]$\n\n- Test case $2$ (matching meshes, identity check):\n  - $\\mathcal{X} = [0.0, 0.3, 0.6, 1.0]$\n  - $\\mathbf{v} = [2.0, -1.0, 0.5]$\n  - $\\mathcal{Y} = [0.0, 0.3, 0.6, 1.0]$\n\n- Test case $3$ (highly nonuniform FE mesh to uniform BI mesh):\n  - $\\mathcal{X} = [0.0, 0.05, 0.2, 0.21, 0.8, 1.0]$\n  - $\\mathbf{v} = [10.0, 0.0, -5.0, 1.0, 0.0]$\n  - $\\mathcal{Y} = [0.0, 0.25, 0.5, 0.75, 1.0]$\n\nFinal Output Format:\nYour program should produce a single line of output containing a Python-style list of results for the three test cases. Each test case result must be a two-element list $[\\mathbf{w}, \\mathrm{ok}]$, where $\\mathbf{w}$ is the list of BI coefficients and $\\mathrm{ok}$ is a boolean that is $\\mathrm{True}$ if and only if each BI element integral is preserved within $\\varepsilon = 1 \\times 10^{-12}$, and $\\mathrm{False}$ otherwise. The final printed line must therefore have the structure\n$$\n\\big[ [\\mathbf{w}^{(1)}, \\mathrm{ok}^{(1)}],\\; [\\mathbf{w}^{(2)}, \\mathrm{ok}^{(2)}],\\; [\\mathbf{w}^{(3)}, \\mathrm{ok}^{(3)}] \\big].\n$$", "solution": "The problem requires the design and implementation of a projection operator to transfer a piecewise constant tangential flux field from a Finite Element (FE) mesh to a nonconforming Boundary Integral (BI) mesh, while preserving discrete charge conservation. The interface is a one-dimensional interval $\\Gamma = [0,1]$.\n\nThe physical principle at the core of this problem is the conservation of charge, mathematically expressed by the continuity equation. In its weak form for a time-harmonic field on the surface $\\Gamma$, this is given by:\n$$\n\\mathrm{i}\\,\\omega \\int_{\\Gamma} \\rho_s \\,\\varphi \\,\\mathrm{d}s + \\int_{\\Gamma} \\nabla_{\\!s} \\cdot \\mathbf{J}_t \\,\\varphi \\,\\mathrm{d}s = 0\n$$\nfor any suitable test function $\\varphi$. Here, $\\mathbf{J}_t$ is the tangential surface current density, which in this one-dimensional model is a scalar flux $j(s)$, and $\\rho_s$ is the surface charge density. For a segment $[a, b] \\subset \\Gamma$, integrating the divergence term gives $\\int_a^b \\nabla_s \\cdot \\mathbf{J}_t \\,ds = j(b) - j(a)$, which represents the net flux leaving the segment. A discrete conservation law aims to preserve this net flux or related integrated quantities upon transfer between meshes.\n\nThe problem defines a specific local conservation constraint for the projection $\\Pi$ that maps the FE flux representation to the BI flux representation. The FE flux is given by $j_{FE}(s) = \\sum_{i=0}^{n-1} v_i \\,\\chi_{K_i}(s)$, where $v_i$ are coefficients on the FE mesh elements $K_i = [x_i, x_{i+1}]$. The BI flux is $j_{BI}(s) = \\sum_{j=0}^{m-1} w_j \\,\\chi_{I_j}(s)$, where $w_j$ are the unknown coefficients on the BI mesh elements $I_j = [y_j, y_{j+1}]$. $\\chi_A$ is the characteristic function of a set $A$.\n\nThe mandated conservation constraint is that the integral of the flux must be preserved over each BI element $I_j$:\n$$\n\\int_{I_j} j_{FE}(s)\\,\\mathrm{d}s \\;=\\; \\int_{I_j} j_{BI}(s)\\,\\mathrm{d}s\n$$\nThis is a strong, local conservation property. Let's analyze both sides of this equation.\n\nThe right-hand side (RHS) is straightforward to evaluate. Since $w_j$ is constant on $I_j$ and $\\chi_{I_{j'}}(s)$ is zero on $I_j$ for $j' \\neq j$:\n$$\n\\int_{I_j} j_{BI}(s)\\,\\mathrm{d}s = \\int_{I_j} \\left(\\sum_{j'=0}^{m-1} w_{j'} \\,\\chi_{I_{j'}}(s)\\right)\\,\\mathrm{d}s = w_j \\int_{I_j} \\mathrm{d}s = w_j \\, |I_j|\n$$\nwhere $|I_j| = y_{j+1} - y_j$ is the length of the BI element $I_j$.\n\nThe left-hand side (LHS) involves integrating the FE field over the BI element $I_j$:\n$$\n\\int_{I_j} j_{FE}(s)\\,\\mathrm{d}s = \\int_{I_j} \\left(\\sum_{i=0}^{n-1} v_i \\,\\chi_{K_i}(s)\\right)\\,\\mathrm{d}s\n$$\nBy linearity of the integral, we can swap the summation and integration:\n$$\n\\int_{I_j} j_{FE}(s)\\,\\mathrm{d}s = \\sum_{i=0}^{n-1} v_i \\int_{I_j} \\chi_{K_i}(s)\\,\\mathrm{d}s = \\sum_{i=0}^{n-1} v_i \\, |K_i \\cap I_j|\n$$\nThe integral of the characteristic function $\\chi_{K_i}$ over the interval $I_j$ is simply the length of the intersection of the two intervals, $|K_i \\cap I_j|$.\n\nEquating the evaluated LHS and RHS gives the explicit relationship for each coefficient $w_j$:\n$$\nw_j \\, |I_j| = \\sum_{i=0}^{n-1} v_i \\, |K_i \\cap I_j|\n$$\nSince the BI mesh $\\mathcal{Y}$ consists of strictly ordered nodes, we have $|I_j| = y_{j+1} - y_j  0$. We can therefore solve for $w_j$:\n$$\nw_j = \\frac{1}{|I_j|} \\sum_{i=0}^{n-1} v_i \\, |K_i \\cap I_j|\n$$\nThis formula defines the projection operator $\\Pi$. The problem is now reduced to the computational task of calculating this expression for each $j \\in \\{0, \\dots, m-1\\}$.\n\nThe main computational challenge is to efficiently compute the sum, which requires finding the lengths of all intersections $|K_i \\cap I_j|$. A naive nested loop iterating through all $i$ and $j$ would have a time complexity of $O(nm)$. However, both the FE mesh elements $\\{K_i\\}$ and the BI mesh elements $\\{I_j\\}$ form sorted partitions of the interval $[0,1]$. This structure allows for a far more efficient algorithm.\n\nWe can employ a linear-time two-pointer sweep algorithm, with complexity $O(n+m)$. The algorithm proceeds as follows:\n1. Initialize two pointers, $i=0$ for the FE elements and $j=0$ for the BI elements.\n2. Initialize an array, `w_integrals`, of size $m$ to store the sum (the total integral of $j_{FE}$ over each $I_j$) for each BI element.\n3. While $i  n$ and $j  m$:\n    a. Consider the current FE element $K_i = [x_i, x_{i+1}]$ and BI element $I_j = [y_j, y_{j+1}]$.\n    b. Calculate the start and end of their intersection: $s_{start} = \\max(x_i, y_j)$ and $s_{end} = \\min(x_{i+1}, y_{j+1})$.\n    c. The length of the overlap is `overlap_length` $= \\max(0, s_{end} - s_{start})$.\n    d. If `overlap_length` is positive, add the contribution to the integral accumulator for the $j$-th BI element: `w_integrals[j] += v_i * overlap_length`.\n    e. Advance the pointer corresponding to the element that \"finishes\" first. If $x_{i+1} \\leq y_{j+1}$, it means that element $K_i$ cannot overlap with any subsequent BI elements beyond $I_j$, so we are done with $K_i$ for now. We increment $i$. Otherwise, $I_j$ finishes first, so we increment $j$.\n4. After the loop terminates, the `w_integrals` array contains the value of $\\sum_{i=0}^{n-1} v_i \\, |K_i \\cap I_j|$ for each $j$.\n5. The final coefficients $w_j$ are obtained by dividing each entry of `w_integrals` by the corresponding BI element length: $w_j = \\text{w\\_integrals}[j] / |I_j|$.\n\nThis procedure guarantees that the cumulative integral $\\int_0^{y_k} j(s)\\,\\mathrm{d}s$ is preserved at each BI node $y_k$, as specified in the problem statement. This is because our primary conservation rule $\\int_{I_j} j_{FE} ds = \\int_{I_j} j_{BI} ds$ for each $j$ implies $\\sum_{j=0}^{k-1} \\int_{I_j} j_{FE} ds = \\sum_{j=0}^{k-1} \\int_{I_j} j_{BI} ds$, which is exactly $\\int_0^{y_k} j_{FE} ds = \\int_0^{y_k} j_{BI} ds$. This property is crucial for ensuring that the discrete divergence operator on the BI mesh produces results consistent with the underlying FE data.\n\nThe final part of the task is to verify the computation numerically. For each BI element $I_j$, we must check if the original integral value (stored in `w_integrals[j]`) is equal to the integral value computed from the projected solution, $w_j |I_j|$, within a given tolerance $\\varepsilon$. This confirms the numerical stability and correctness of the implementation.\n$$\n\\left| \\left( \\sum_{i=0}^{n-1} v_i \\, |K_i \\cap I_j| \\right) - w_j |I_j| \\right| \\le \\varepsilon\n$$\nThe boolean `ok` is the result of this check being true for all $j=0, \\ldots, m-1$.", "answer": "```python\nimport numpy as np\n\ndef project_and_verify(X, v, Y, tol=1e-12):\n    \"\"\"\n    Projects a piecewise constant function from an FE mesh to a BI mesh\n    using a conservative mortar method and verifies the projection.\n\n    Args:\n        X (list or np.ndarray): FE mesh nodes, sorted.\n        v (list or np.ndarray): FE coefficients for elements [X_i, X_{i+1}].\n        Y (list or np.ndarray): BI mesh nodes, sorted.\n        tol (float): Numerical tolerance for verification.\n\n    Returns:\n        tuple: A tuple containing:\n            - list: The projected BI coefficients w.\n            - bool: True if the projection is correct for all BI elements, False otherwise.\n    \"\"\"\n    n = len(X) - 1  # Number of FE elements\n    m = len(Y) - 1  # Number of BI elements\n\n    if n != len(v):\n        raise ValueError(\"Length of v must be len(X) - 1\")\n\n    # This array will store the integral of the FE field over each BI element.\n    # It corresponds to the numerator in the formula for w_j.\n    w_integrals = np.zeros(m)\n\n    # Two-pointer sweep algorithm\n    i = 0  # Pointer for FE elements\n    j = 0  # Pointer for BI elements\n\n    while i  n and j  m:\n        # Current FE element K_i = [x_i, x_{i+1}]\n        x_i = X[i]\n        x_i_plus_1 = X[i+1]\n\n        # Current BI element I_j = [y_j, y_{j+1}]\n        y_j = Y[j]\n        y_j_plus_1 = Y[j+1]\n\n        # Calculate overlap interval [s_start, s_end]\n        s_start = max(x_i, y_j)\n        s_end = min(x_i_plus_1, y_j_plus_1)\n\n        # Calculate overlap length and add contribution if non-zero\n        overlap_length = s_end - s_start\n        if overlap_length  0:\n            w_integrals[j] += v[i] * overlap_length\n\n        # Advance the pointer of the element that ends first\n        if x_i_plus_1  y_j_plus_1:\n            i += 1\n        elif y_j_plus_1  x_i_plus_1:\n            j += 1\n        else: # x_i_plus_1 == y_j_plus_1\n            i += 1\n            j += 1\n            \n    # Calculate BI element lengths\n    I_lengths = np.diff(Y)\n    \n    # Calculate final BI coefficients w\n    # Use np.divide with a where clause to avoid division by zero, although\n    # mesh construction rules should prevent I_lengths[j] == 0.\n    w = np.divide(w_integrals, I_lengths, out=np.zeros_like(w_integrals), where=(I_lengths != 0))\n\n    # Verification step\n    # Check if integral from FE data equals integral from projected BI data\n    # i.e., w_integrals[j] == w[j] * I_lengths[j]\n    verification_integrals = w * I_lengths\n    \n    # Check if the absolute difference is within tolerance for all elements\n    all_ok = np.all(np.abs(w_integrals - verification_integrals) = tol)\n\n    return w.tolist(), bool(all_ok)\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"X\": [0.0, 0.2, 0.5, 0.7, 1.0],\n            \"v\": [1.0, 0.0, 2.0, -1.0],\n            \"Y\": [0.0, 0.3, 0.6, 1.0],\n        },\n        {\n            \"X\": [0.0, 0.3, 0.6, 1.0],\n            \"v\": [2.0, -1.0, 0.5],\n            \"Y\": [0.0, 0.3, 0.6, 1.0],\n        },\n        {\n            \"X\": [0.0, 0.05, 0.2, 0.21, 0.8, 1.0],\n            \"v\": [10.0, 0.0, -5.0, 1.0, 0.0],\n            \"Y\": [0.0, 0.25, 0.5, 0.75, 1.0],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        w, ok = project_and_verify(case[\"X\"], case[\"v\"], case[\"Y\"])\n        results.append([w, ok])\n    \n    # Print the final list of results in the specified format.\n    # The default str() representation of a list of lists matches the required output format.\n    print(str(results))\n\nsolve()\n\n```", "id": "3315760"}, {"introduction": "Once a hybrid system is assembled, the next challenge is to solve it efficiently while guaranteeing accuracy for a specific engineering goal, such as the far-field radiation pattern. This advanced practice moves beyond static discretization to the implementation of a goal-oriented adaptive mesh refinement (AMR) algorithm. You will develop a cost-aware strategy that intelligently decides whether to refine the interior FEM mesh or the exterior BEM mesh, providing insight into how modern solvers automate the process of achieving optimal efficiency [@problem_id:3315744].", "problem": "Consider time-harmonic electromagnetic scattering in free space where the electric field $\\mathbf{E}$ with angular frequency $\\omega$ satisfies Maxwell’s equations. In a hybrid discretization that couples the Finite Element Method (FEM) in a bounded volume domain $\\Omega$ with a Boundary Integral (BI) equation on the enclosing surface $\\Gamma$, the FEM approximates the interior field while the BI enforces the radiation condition and represents the exterior field. The hybrid finite element–boundary integral method seeks $\\mathbf{E}_h$ such that the volume weak form and the boundary integral coupling conditions are both satisfied. The far-field amplitude in a given observation direction is a linear functional $J(\\mathbf{E})$ of the electromagnetic field (for example, via the Stratton–Chu representation), and the quantity of interest is the far-field error $|J(\\mathbf{E}) - J(\\mathbf{E}_h)|$.\n\nStarting from the time-harmonic Maxwell curl–curl equation in the interior,\n$$\n\\nabla \\times \\left( \\mu^{-1} \\nabla \\times \\mathbf{E} \\right) - \\omega^2 \\varepsilon \\mathbf{E} = \\mathbf{0} \\quad \\text{in } \\Omega,\n$$\nwith $\\mu$ the magnetic permeability and $\\varepsilon$ the electric permittivity, and from a boundary integral formulation on $\\Gamma$ that enforces the outgoing radiation condition in the exterior, goal-oriented a posteriori error analysis yields an error representation that decomposes the far-field error into contributions from volume residuals and boundary residuals weighted by the adjoint (dual) solution. Denote by the set of tetrahedral volume elements $\\{K_i\\}_{i=1}^{N_{\\mathrm{vol}}}$ with characteristic sizes $\\{h_i^{\\mathrm{vol}}\\}$ and by the set of triangular surface elements $\\{T_j\\}_{j=1}^{N_{\\mathrm{surf}}}$ with characteristic sizes $\\{h_j^{\\mathrm{surf}}\\}$. Let the free-space speed of light be $c = 2.99792458 \\times 10^8\\,\\mathrm{m/s}$ and the wavenumber be $k = 2\\pi f/c$, where $f$ is the frequency in $\\mathrm{Hz}$.\n\nDefine computable local indicators for the volume and surface contributions that scale with mesh size and wavenumber,\n$$\n\\eta_i^{\\mathrm{vol}} = A_{\\mathrm{vol}} \\left(k\\, h_i^{\\mathrm{vol}}\\right)^{p_{\\mathrm{vol}}} \\rho_i, \\quad\n\\eta_j^{\\mathrm{surf}} = A_{\\mathrm{surf}} \\left(k\\, h_j^{\\mathrm{surf}}\\right)^{p_{\\mathrm{surf}}} \\sigma_j,\n$$\nwhere $A_{\\mathrm{vol}}$ and $A_{\\mathrm{surf}}$ are positive scaling constants reflecting material contrast and discretization order, $p_{\\mathrm{vol}}0$ and $p_{\\mathrm{surf}}0$ are convergence exponents, and $\\rho_i0$, $\\sigma_j0$ are computable residual amplitudes. Let $w_i^{\\mathrm{vol}}$ and $w_j^{\\mathrm{surf}}$ be positive adjoint-based influence weights that reflect the sensitivity of the far-field functional $J(\\mathbf{E})$ to perturbations in the corresponding elements. In this problem, assume the weights are modeled by\n$$\nw_i^{\\mathrm{vol}} = \\frac{1}{1 + \\left(k\\, h_i^{\\mathrm{vol}}\\right)^2}, \\qquad\nw_j^{\\mathrm{surf}} = \\frac{1}{1 + \\left(k\\, h_j^{\\mathrm{surf}}\\right)}.\n$$\nDefine the far-field error estimator as\n$$\n\\mathcal{E}_{\\mathrm{ff}} = \\left( \\sum_{i=1}^{N_{\\mathrm{vol}}} w_i^{\\mathrm{vol}} \\left(\\eta_i^{\\mathrm{vol}}\\right)^2 + \\sum_{j=1}^{N_{\\mathrm{surf}}} w_j^{\\mathrm{surf}} \\left(\\eta_j^{\\mathrm{surf}}\\right)^2 \\right)^{1/2},\n$$\nand suppose that refining a volume element $K_i$ halves its size $h_i^{\\mathrm{vol}} \\mapsto h_i^{\\mathrm{vol}}/2$, and similarly for a surface element $T_j$ where $h_j^{\\mathrm{surf}} \\mapsto h_j^{\\mathrm{surf}}/2$. Under this refinement, the indicators contract according to the scaling exponents:\n$$\n\\eta_i^{\\mathrm{vol}} \\mapsto 2^{-p_{\\mathrm{vol}}}\\, \\eta_i^{\\mathrm{vol}}, \\qquad\n\\eta_j^{\\mathrm{surf}} \\mapsto 2^{-p_{\\mathrm{surf}}}\\, \\eta_j^{\\mathrm{surf}},\n$$\nand the weights update with the new sizes. Let the computational cost of one refinement of a volume element be $c_{\\mathrm{vol}}0$ and for a surface element be $c_{\\mathrm{surf}}0$.\n\nTask. Propose and implement an adaptive refinement algorithm that, at each iteration, selects either one volume tetrahedron or one surface triangle to refine in order to minimize the far-field error estimator $\\mathcal{E}_{\\mathrm{ff}}$ subject to a target tolerance $\\varepsilon_{\\mathrm{ff}}$. The selection must balance volume and surface refinements by maximizing the predicted error reduction per unit cost. That is, for each candidate element, predict the decrease in $\\mathcal{E}_{\\mathrm{ff}}^2$ due to halving its size using the given indicator and weight models, and select the element that maximizes the ratio of predicted decrease to refinement cost. Repeat until $\\mathcal{E}_{\\mathrm{ff}} \\le \\varepsilon_{\\mathrm{ff}}$ or a maximum number of iterations is reached. The program must output, for each test case, a list containing the boolean indicating whether the tolerance was achieved, the total number of iterations, the total number of volume refinements, the total number of surface refinements, and the final estimated far-field error $\\mathcal{E}_{\\mathrm{ff}}$.\n\nUse the following deterministic residual amplitudes:\n$$\n\\rho_i = \\frac{1}{1+i}, \\qquad \\sigma_j = \\frac{1}{1+j}.\n$$\nUse the following deterministic initial element sizes:\n$$\nh_i^{\\mathrm{vol}} = \\bar{h}_{\\mathrm{vol}} \\left(1 + 0.3\\sin(i)\\right), \\qquad\nh_j^{\\mathrm{surf}} = \\bar{h}_{\\mathrm{surf}} \\left(1 + 0.3\\cos(j)\\right),\n$$\nwith $\\bar{h}_{\\mathrm{vol}}0$ and $\\bar{h}_{\\mathrm{surf}}0$.\n\nImplement the algorithm in a single program that runs without any external input and produces the results for the following test suite. All physical quantities must use International System of Units (SI). Frequencies must be in $\\mathrm{Hz}$, lengths in $\\mathrm{m}$, and the far-field error tolerance and estimator must be dimensionless. The final far-field error must be reported as a decimal number.\n\nTest suite:\n- Case $1$ (happy path): $f = 3.0\\times 10^9\\,\\mathrm{Hz}$, $L = 0.1\\,\\mathrm{m}$, $N_{\\mathrm{vol}} = 32$, $N_{\\mathrm{surf}} = 64$, $\\bar{h}_{\\mathrm{vol}} = L/20$, $\\bar{h}_{\\mathrm{surf}} = L/30$, $A_{\\mathrm{vol}} = 1.0$, $A_{\\mathrm{surf}} = 1.0$, $p_{\\mathrm{vol}} = 1.0$, $p_{\\mathrm{surf}} = 1.0$, $c_{\\mathrm{vol}} = 2.0$, $c_{\\mathrm{surf}} = 1.0$, $\\varepsilon_{\\mathrm{ff}} = 1.0\\times 10^{-3}$, maximum iterations $= 1000$.\n- Case $2$ (tight tolerance boundary): $f = 1.0\\times 10^{10}\\,\\mathrm{Hz}$, $L = 0.2\\,\\mathrm{m}$, $N_{\\mathrm{vol}} = 40$, $N_{\\mathrm{surf}} = 80$, $\\bar{h}_{\\mathrm{vol}} = 0.01\\,\\mathrm{m}$, $\\bar{h}_{\\mathrm{surf}} = 0.007\\,\\mathrm{m}$, $A_{\\mathrm{vol}} = 1.0$, $A_{\\mathrm{surf}} = 1.5$, $p_{\\mathrm{vol}} = 1.0$, $p_{\\mathrm{surf}} = 1.0$, $c_{\\mathrm{vol}} = 2.0$, $c_{\\mathrm{surf}} = 1.0$, $\\varepsilon_{\\mathrm{ff}} = 1.0\\times 10^{-6}$, maximum iterations $= 600$.\n- Case $3$ (low frequency and cost imbalance): $f = 1.0\\times 10^8\\,\\mathrm{Hz}$, $L = 0.5\\,\\mathrm{m}$, $N_{\\mathrm{vol}} = 20$, $N_{\\mathrm{surf}} = 40$, $\\bar{h}_{\\mathrm{vol}} = 0.02\\,\\mathrm{m}$, $\\bar{h}_{\\mathrm{surf}} = 0.015\\,\\mathrm{m}$, $A_{\\mathrm{vol}} = 0.8$, $A_{\\mathrm{surf}} = 1.2$, $p_{\\mathrm{vol}} = 1.0$, $p_{\\mathrm{surf}} = 1.0$, $c_{\\mathrm{vol}} = 1.5$, $c_{\\mathrm{surf}} = 1.0$, $\\varepsilon_{\\mathrm{ff}} = 1.0\\times 10^{-4}$, maximum iterations $= 600$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a list in the order $\\left[\\text{success}, \\text{iterations}, \\text{volume\\_refinements}, \\text{surface\\_refinements}, \\mathcal{E}_{\\mathrm{ff}}\\right]$. For example, the output should look like $\\left[[\\text{True},10,5,7,9.1e-4],[\\text{False},600,320,280,2.3e-6],[\\text{True},\\dots]\\right]$ with actual numbers computed by your program.", "solution": "The problem asks for the design and implementation of a goal-oriented adaptive mesh refinement (AMR) algorithm for a hybrid finite element–boundary integral (FEM-BI) method in computational electromagnetics. The objective is to efficiently reduce the estimated error in a specific quantity of interest, the far-field amplitude, below a given tolerance $\\varepsilon_{\\mathrm{ff}}$. The algorithm must iteratively refine either a volume (tetrahedral) element or a surface (triangular) element, making the selection based on which refinement offers the maximum predicted error reduction per unit of computational cost.\n\nThe proposed algorithm is a greedy, iterative procedure. At each step, it identifies the single most \"profitable\" element to refine and updates the mesh state accordingly. This process repeats until the estimated error $\\mathcal{E}_{\\mathrm{ff}}$ falls below the target tolerance $\\varepsilon_{\\mathrm{ff}}$ or a maximum number of iterations is reached.\n\nThe core components of the algorithm are as follows:\n\n1.  **State Representation**: The state of the discretized domain at any iteration is defined by the set of characteristic sizes of all volume and surface elements, $\\{h_i^{\\mathrm{vol}}\\}_{i=1}^{N_{\\mathrm{vol}}}$ and $\\{h_j^{\\mathrm{surf}}\\}_{j=1}^{N_{\\mathrm{surf}}}$. All other parameters, such as residual amplitudes $\\rho_i$ and $\\sigma_j$, are assumed to be fixed for each element throughout the simulation as per the problem definition.\n\n2.  **Error Estimator Calculation**: In each iteration, the total far-field error estimator $\\mathcal{E}_{\\mathrm{ff}}$ is computed. This estimator is the square root of the sum of squared, weighted local error indicators over all elements:\n    $$\n    \\mathcal{E}_{\\mathrm{ff}} = \\left( \\sum_{i=1}^{N_{\\mathrm{vol}}} w_i^{\\mathrm{vol}} \\left(\\eta_i^{\\mathrm{vol}}\\right)^2 + \\sum_{j=1}^{N_{\\mathrm{surf}}} w_j^{\\mathrm{surf}} \\left(\\eta_j^{\\mathrm{surf}}\\right)^2 \\right)^{1/2}\n    $$\n    The individual components are calculated based on the current element sizes:\n    -   The wavenumber is $k = 2\\pi f/c$.\n    -   Local indicators: $\\eta_i^{\\mathrm{vol}} = A_{\\mathrm{vol}} \\left(k\\, h_i^{\\mathrm{vol}}\\right)^{p_{\\mathrm{vol}}} \\rho_i$ and $\\eta_j^{\\mathrm{surf}} = A_{\\mathrm{surf}} \\left(k\\, h_j^{\\mathrm{surf}}\\right)^{p_{\\mathrm{surf}}} \\sigma_j$.\n    -   Adjoint weights: $w_i^{\\mathrm{vol}} = \\frac{1}{1 + \\left(k\\, h_i^{\\mathrm{vol}}\\right)^2}$ and $w_j^{\\mathrm{surf}} = \\frac{1}{1 + \\left(k\\, h_j^{\\mathrm{surf}}\\right)}$.\n\n3.  **Refinement Selection Criterion**: The algorithm employs a cost-aware greedy strategy. To select which element to refine, we predict the reduction in the squared error, $\\mathcal{E}_{\\mathrm{ff}}^2$, that would result from refining each candidate element. This balances the potential error reduction against the computational cost of the refinement.\n\n    For a given volume element $K_i$, its current contribution to the squared error is $C_i^{\\mathrm{vol}} = w_i^{\\mathrm{vol}} \\left(\\eta_i^{\\mathrm{vol}}\\right)^2$. If we refine this element, its size becomes $h_i^{\\mathrm{vol, new}} = h_i^{\\mathrm{vol}}/2$. According to the problem's scaling rules, the indicator contracts to $\\eta_i^{\\mathrm{vol, new}} = 2^{-p_{\\mathrm{vol}}} \\eta_i^{\\mathrm{vol}}$. The weight updates to $w_i^{\\mathrm{vol, new}} = \\frac{1}{1 + \\left(k h_i^{\\mathrm{vol, new}}\\right)^2}$. The new contribution to the squared error would be $C_i^{\\mathrm{vol, new}} = w_i^{\\mathrm{vol, new}} (\\eta_i^{\\mathrm{vol, new}})^2$.\n\n    The predicted reduction in $\\mathcal{E}_{\\mathrm{ff}}^2$ from refining element $K_i$ is therefore $\\Delta_i^{\\mathrm{vol}} = C_i^{\\mathrm{vol}} - C_i^{\\mathrm{vol, new}}$. The selection metric, which represents the error reduction per unit cost, is:\n    $$\n    M_i^{\\mathrm{vol}} = \\frac{\\Delta_i^{\\mathrm{vol}}}{c_{\\mathrm{vol}}}\n    $$\n    An analogous metric, $M_j^{\\mathrm{surf}}$, is computed for each surface element $T_j$:\n    $$\n    M_j^{\\mathrm{surf}} = \\frac{\\Delta_j^{\\mathrm{surf}}}{c_{\\mathrm{surf}}} = \\frac{w_j^{\\mathrm{surf}} (\\eta_j^{\\mathrm{surf}})^2 - w_j^{\\mathrm{surf, new}} (\\eta_j^{\\mathrm{surf, new}})^2}{c_{\\mathrm{surf}}}\n    $$\n    At each iteration, the algorithm computes $M_i^{\\mathrm{vol}}$ for all $i \\in \\{1, \\dots, N_{\\mathrm{vol}}\\}$ and $M_j^{\\mathrm{surf}}$ for all $j \\in \\{1, \\dots, N_{\\mathrm{surf}}\\}$. The element corresponding to the maximum value among all these metrics is chosen for refinement.\n\n4.  **Adaptive Loop and Termination**: The overall algorithm proceeds as follows:\n    a. Initialize element sizes $\\{h_i^{\\mathrm{vol}}\\}$ and $\\{h_j^{\\mathrm{surf}}\\}$ and residual amplitudes $\\{\\rho_i\\}$ and $\\{\\sigma_j\\}$ based on the provided formulas. Initialize iteration and refinement counters to $0$.\n    b. Start the main loop, which runs for a maximum number of iterations.\n    c. In each iteration, calculate the current total error estimator $\\mathcal{E}_{\\mathrm{ff}}$.\n    d. Check for termination: If $\\mathcal{E}_{\\mathrm{ff}} \\le \\varepsilon_{\\mathrm{ff}}$, the tolerance is met. The loop terminates, and success is recorded.\n    e. If not terminated, compute the selection metrics $M_i^{\\mathrm{vol}}$ and $M_j^{\\mathrm{surf}}$ for all elements.\n    f. Identify the element (either volume or surface) with the globally maximum metric value.\n    g. Refine the selected element: update its size by halving it ($h \\mapsto h/2$).\n    h. Increment the appropriate refinement counter (volume or surface) and the total iteration counter.\n    i. If the loop completes by reaching the maximum iteration limit without satisfying the tolerance, the process terminates and reports failure to converge.\n    j. Upon termination, report the success status, total iterations, total volume and surface refinements, and the final value of $\\mathcal{E}_{\\mathrm{ff}}$.\n\nThis algorithm is implemented using NumPy for efficient vectorized computation of indicators, weights, and metrics across all elements simultaneously, avoiding slow, explicit loops in Python.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the adaptive refinement simulation for all test cases.\n    \"\"\"\n    \n    # Speed of light in m/s\n    c = 2.99792458e8\n\n    # Test suite from the problem statement\n    test_cases = [\n        # Case 1 (happy path)\n        {'f': 3.0e9, 'L': 0.1, 'N_vol': 32, 'N_surf': 64, 'h_bar_vol_factor': 1/20.0, 'h_bar_surf_factor': 1/30.0,\n         'A_vol': 1.0, 'A_surf': 1.0, 'p_vol': 1.0, 'p_surf': 1.0, 'c_vol': 2.0, 'c_surf': 1.0,\n         'tol': 1.0e-3, 'max_iter': 1000},\n        # Case 2 (tight tolerance boundary)\n        {'f': 1.0e10, 'L': 0.2, 'N_vol': 40, 'N_surf': 80, 'h_bar_vol': 0.01, 'h_bar_surf': 0.007,\n         'A_vol': 1.0, 'A_surf': 1.5, 'p_vol': 1.0, 'p_surf': 1.0, 'c_vol': 2.0, 'c_surf': 1.0,\n         'tol': 1.0e-6, 'max_iter': 600},\n        # Case 3 (low frequency and cost imbalance)\n        {'f': 1.0e8, 'L': 0.5, 'N_vol': 20, 'N_surf': 40, 'h_bar_vol': 0.02, 'h_bar_surf': 0.015,\n         'A_vol': 0.8, 'A_surf': 1.2, 'p_vol': 1.0, 'p_surf': 1.0, 'c_vol': 1.5, 'c_surf': 1.0,\n         'tol': 1.0e-4, 'max_iter': 600}\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result = run_simulation(params, c)\n        all_results.append(result)\n    \n    # Format the output string to match the required format exactly\n    output_parts = []\n    for r in all_results:\n        # Format: [success, iterations, volume_refinements, surface_refinements, E_ff]\n        # str(bool) gives 'True'/'False'\n        part = f\"[{str(r[0])},{r[1]},{r[2]},{r[3]},{r[4]}]\"\n        output_parts.append(part)\n    \n    print(f\"[{','.join(output_parts)}]\")\n\n\ndef run_simulation(params, c):\n    \"\"\"\n    Runs the adaptive refinement algorithm for a single test case.\n    \"\"\"\n    # Unpack parameters\n    f = params['f']\n    N_vol, N_surf = params['N_vol'], params['N_surf']\n    A_vol, A_surf = params['A_vol'], params['A_surf']\n    p_vol, p_surf = params['p_vol'], params['p_surf']\n    c_vol, c_surf = params['c_vol'], params['c_surf']\n    tol, max_iter = params['tol'], params['max_iter']\n\n    if 'h_bar_vol_factor' in params:\n        L = params['L']\n        h_bar_vol = L * params['h_bar_vol_factor']\n        h_bar_surf = L * params['h_bar_surf_factor']\n    else:\n        h_bar_vol = params['h_bar_vol']\n        h_bar_surf = params['h_bar_surf']\n        \n    k = 2 * np.pi * f / c\n\n    # Initialization\n    # Indices for deterministic formulas (1-based)\n    vol_indices = np.arange(1, N_vol + 1)\n    surf_indices = np.arange(1, N_surf + 1)\n\n    # Residual amplitudes (fixed)\n    rho_vol = 1.0 / (1.0 + vol_indices)\n    sigma_surf = 1.0 / (1.0 + surf_indices)\n\n    # Initial element sizes\n    h_vol = h_bar_vol * (1.0 + 0.3 * np.sin(vol_indices))\n    h_surf = h_bar_surf * (1.0 + 0.3 * np.cos(surf_indices))\n\n    iterations = 0\n    vol_refinements = 0\n    surf_refinements = 0\n    success = False\n    E_ff = float('inf')\n\n    for i in range(max_iter):\n        iterations = i\n\n        # Calculate current error estimator\n        kh_vol = k * h_vol\n        kh_surf = k * h_surf\n\n        eta_vol = A_vol * (kh_vol ** p_vol) * rho_vol\n        eta_surf = A_surf * (kh_surf ** p_surf) * sigma_surf\n        \n        w_vol = 1.0 / (1.0 + kh_vol**2)\n        w_surf = 1.0 / (1.0 + kh_surf)\n        \n        contrib_sq_vol = w_vol * eta_vol**2\n        contrib_sq_surf = w_surf * eta_surf**2\n        \n        E_ff_sq = np.sum(contrib_sq_vol) + np.sum(contrib_sq_surf)\n        E_ff = np.sqrt(E_ff_sq)\n\n        if E_ff = tol:\n            success = True\n            break\n        \n        # Predict error reduction for all elements\n        \n        # Volume elements\n        kh_vol_new = kh_vol / 2.0\n        eta_vol_new = eta_vol * (2.0**(-p_vol))\n        w_vol_new = 1.0 / (1.0 + kh_vol_new**2)\n        contrib_sq_vol_new = w_vol_new * eta_vol_new**2\n        reductions_vol = contrib_sq_vol - contrib_sq_vol_new\n        metrics_vol = reductions_vol / c_vol\n\n        # Surface elements\n        kh_surf_new = kh_surf / 2.0\n        eta_surf_new = eta_surf * (2.0**(-p_surf))\n        w_surf_new = 1.0 / (1.0 + kh_surf_new)\n        contrib_sq_surf_new = w_surf_new * eta_surf_new**2\n        reductions_surf = contrib_sq_surf - contrib_sq_surf_new\n        metrics_surf = reductions_surf / c_surf\n\n        # Select element with max metric and refine\n        best_vol_idx = np.argmax(metrics_vol)\n        best_surf_idx = np.argmax(metrics_surf)\n        \n        if metrics_vol[best_vol_idx] = metrics_surf[best_surf_idx]:\n            h_vol[best_vol_idx] /= 2.0\n            vol_refinements += 1\n        else:\n            h_surf[best_surf_idx] /= 2.0\n            surf_refinements += 1\n    \n    # If loop finished due to max_iter, one final calculation of E_ff is needed\n    if not success:\n      iterations += 1\n      # Recalculate final error after the last refinement\n      kh_vol = k * h_vol\n      kh_surf = k * h_surf\n      eta_vol = A_vol * (kh_vol ** p_vol) * rho_vol\n      eta_surf = A_surf * (kh_surf ** p_surf) * sigma_surf\n      w_vol = 1.0 / (1.0 + kh_vol**2)\n      w_surf = 1.0 / (1.0 + kh_surf)\n      contrib_sq_vol = w_vol * eta_vol**2\n      contrib_sq_surf = w_surf * eta_surf**2\n      E_ff_sq = np.sum(contrib_sq_vol) + np.sum(contrib_sq_surf)\n      E_ff = np.sqrt(E_ff_sq)\n\n    return [success, iterations, vol_refinements, surf_refinements, E_ff]\n\nsolve()\n```", "id": "3315744"}]}