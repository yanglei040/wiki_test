{"hands_on_practices": [{"introduction": "The fundamental task of ray tracing is to solve the equations of motion for light in an inhomogeneous medium. This exercise moves beyond simple analytical cases by tackling this problem numerically, using the robust framework of Hamiltonian mechanics. By implementing and comparing a standard Runge-Kutta integrator with a structure-preserving symplectic method, you will gain critical insights into the importance of choosing an algorithm that respects the underlying physics, particularly for ensuring long-term accuracy and the conservation of physical invariants [@problem_id:3311401].", "problem": "You are to implement and compare two numerical integrators for geometrical-optics ray propagation in an inhomogeneous, isotropic medium with a rapidly varying refractive index, focusing on both energy conservation and travel-time accuracy. The comparison is to be performed on a graded-index (GRIN) lens model with strong gradients. The task is framed in purely mathematical terms based on Hamiltonian ray dynamics derived from Fermat’s principle and the eikonal approximation, and the final answer must be a complete, runnable program as specified.\n\nBegin from the following fundamentals:\n\n- Rays in an inhomogeneous, isotropic, stationary medium of refractive index $n(\\mathbf{x})$ follow from Fermat’s principle and the eikonal approximation, which admit a Hamiltonian formulation with canonical position $\\mathbf{x} \\in \\mathbb{R}^2$, canonical momentum $\\mathbf{p} \\in \\mathbb{R}^2$, and Hamiltonian\n$$\nH(\\mathbf{x},\\mathbf{p}) = \\tfrac{1}{2}\\left(\\lVert \\mathbf{p} \\rVert^2 - n^2(\\mathbf{x})\\right).\n$$\n- The corresponding canonical equations are\n$$\n\\frac{d\\mathbf{x}}{d\\tau} = \\frac{\\partial H}{\\partial \\mathbf{p}} = \\mathbf{p}, \\qquad \\frac{d\\mathbf{p}}{d\\tau} = -\\frac{\\partial H}{\\partial \\mathbf{x}} = \\tfrac{1}{2}\\nabla n^2(\\mathbf{x}),\n$$\nwhere $\\tau$ is a path parameter with units of meters such that the optical travel time $T$ satisfies\n$$\nT = \\frac{1}{c_0} \\int n^2(\\mathbf{x}(\\tau)) \\, d\\tau,\n$$\nwith $c_0$ being the vacuum speed of light.\n\nConsider a two-dimensional GRIN lens with profile\n$$\nn^2(\\mathbf{x}) = n_0^2 - \\alpha \\lVert \\mathbf{x} \\rVert^2,\n$$\nwhere $n_0 > 0$ is constant and $\\alpha > 0$ has units of inverse square meters. This medium is strongly inhomogeneous for large $\\alpha$, leading to stiff ray dynamics. The canonical equations become\n$$\n\\frac{d\\mathbf{x}}{d\\tau} = \\mathbf{p}, \\qquad \\frac{d\\mathbf{p}}{d\\tau} = -\\alpha \\, \\mathbf{x}.\n$$\n\nTasks:\n\n1. Implement two time-stepping schemes for the Hamiltonian system above:\n   - A classical explicit Runge–Kutta method of order $4$ applied to the first-order system for $(\\mathbf{x}, \\mathbf{p})$.\n   - A second-order symplectic splitting (Störmer–Verlet) method applied to the separable Hamiltonian $H(\\mathbf{x},\\mathbf{p}) = T(\\mathbf{p}) + V(\\mathbf{x})$ with $T(\\mathbf{p}) = \\tfrac{1}{2}\\lVert \\mathbf{p} \\rVert^2$ and $V(\\mathbf{x}) = -\\tfrac{1}{2} n^2(\\mathbf{x})$.\n\n2. For each integrator and each test case below, propagate a ray over exactly one full oscillation period in $\\tau$ (i.e., for a total parameter length $\\tau_{\\text{end}} = \\tfrac{2\\pi}{\\sqrt{\\alpha}}$), using a fixed nominal step size $h$ but shortening the final step to land exactly at $\\tau_{\\text{end}}$.\n\n3. Use initial conditions constructed to satisfy the geometric-optics constraint $H=0$ at $\\tau = 0$:\n   - Let $r_c = \\tfrac{n_0}{\\sqrt{\\alpha}}$.\n   - Let $A = \\rho \\, r_c$ with $\\rho = 0.6$, and choose $\\mathbf{x}(0) = [A, 0]^{\\mathsf{T}}$.\n   - Choose $\\mathbf{p}(0) = [0, \\sqrt{n_0^2 - \\alpha A^2}]^{\\mathsf{T}}$, which ensures $H(\\mathbf{x}(0),\\mathbf{p}(0)) = 0$.\n\n4. For each integrator and test case, evaluate:\n   - The maximum absolute Hamiltonian drift over the trajectory,\n     $$\n     \\Delta H_{\\max} = \\max_{k}\\left|H(\\mathbf{x}_k,\\mathbf{p}_k) - H(\\mathbf{x}_0,\\mathbf{p}_0)\\right|.\n     $$\n     Report this as a dimensionless float.\n   - The absolute travel-time error,\n     $$\n     \\left|T_{\\text{num}} - T_{\\text{exact}}\\right|,\n     $$\n     where $T_{\\text{num}}$ is computed by the trapezoidal rule applied to $\\tfrac{1}{c_0}\\int_0^{\\tau_{\\text{end}}} n^2(\\mathbf{x}(\\tau)) \\, d\\tau$, and $T_{\\text{exact}}$ is the analytic value for one full period in this GRIN medium derived from the fundamentals above. Express this error in seconds as a float.\n\n5. Use the constants $n_0 = 1.6$ (dimensionless) and $c_0 = 299792458$ (in meters per second). All positions are in meters, $\\alpha$ is in inverse square meters, and $\\tau$ is in meters.\n\n6. Test Suite. For each pair $(\\alpha, h)$ below, run both integrators and compute the two metrics described. The period is $\\tau_{\\text{end}} = \\tfrac{2\\pi}{\\sqrt{\\alpha}}$ in meters.\n   - Case $1$: $\\alpha = 400$, $h = 0.05$.\n   - Case $2$: $\\alpha = 2500$, $h = 0.039$.\n   - Case $3$: $\\alpha = 25$, $h = 0.3$.\n   - Case $4$: $\\alpha = 10000$, $h = 0.015$.\n\n7. Output format. Your program should produce a single line of output containing the results for the test suite as a comma-separated list enclosed in square brackets. Each test case should contribute a list of four floats in the order\n   $$\n   \\left[\\Delta H_{\\max}^{\\mathrm{RK4}}, \\, \\left|T_{\\text{num}}^{\\mathrm{RK4}} - T_{\\text{exact}}\\right|, \\, \\Delta H_{\\max}^{\\mathrm{SV}}, \\, \\left|T_{\\text{num}}^{\\mathrm{SV}} - T_{\\text{exact}}\\right|\\right],\n   $$\n   where superscripts indicate the integrator used. The travel-time error must be in seconds, and the Hamiltonian drift is dimensionless. The final output should look like\n   $$\n   \\left[\\,[a_1, b_1, c_1, d_1],[a_2, b_2, c_2, d_2],[a_3, b_3, c_3, d_3],[a_4, b_4, c_4, d_4]\\,\\right],\n   $$\n   with each $a_i$, $b_i$, $c_i$, $d_i$ being Python-format floats.\n\nAll angles, if any arise in your derivations, must be in radians. All travel-time values and errors must be expressed in seconds. No percentage signs are permitted; use decimals for any fractional quantities.", "solution": "The problem is valid as it is scientifically grounded in Hamiltonian mechanics and geometrical optics, well-posed as a standard initial value problem, and self-contained with all necessary constants, initial conditions, and procedures fully specified.\n\nThe problem requires the implementation and comparison of two numerical integrators for simulating ray propagation in a two-dimensional graded-index (GRIN) medium. The comparison focuses on the conservation of a system invariant (the Hamiltonian) and the accuracy of a path-integrated quantity (the optical travel time).\n\nThe governing physics is described by Hamiltonian ray dynamics. For a medium with refractive index $n(\\mathbf{x})$, the canonical equations for the ray position $\\mathbf{x}(\\tau) \\in \\mathbb{R}^2$ and momentum $\\mathbf{p}(\\tau) \\in \\mathbb{R}^2$ are derived from the Hamiltonian $H(\\mathbf{x},\\mathbf{p}) = \\frac{1}{2}(\\lVert \\mathbf{p} \\rVert^2 - n^2(\\mathbf{x}))$. The equations of motion are:\n$$\n\\frac{d\\mathbf{x}}{d\\tau} = \\frac{\\partial H}{\\partial \\mathbf{p}} = \\mathbf{p}\n$$\n$$\n\\frac{d\\mathbf{p}}{d\\tau} = -\\frac{\\partial H}{\\partial \\mathbf{x}} = \\frac{1}{2}\\nabla n^2(\\mathbf{x})\n$$\nHere, $\\tau$ is a path parameter. For physical rays, the Hamiltonian is a constant of motion, and its value is constrained to be zero, i.e., $H(\\mathbf{x}(\\tau), \\mathbf{p}(\\tau)) = 0$ for all $\\tau$. This implies that along the ray path, the magnitude of the ray momentum vector equals the local refractive index: $\\lVert\\mathbf{p}(\\tau)\\rVert = n(\\mathbf{x}(\\tau))$.\n\nThe specific medium is a GRIN lens with a parabolic profile:\n$$\nn^2(\\mathbf{x}) = n_0^2 - \\alpha \\lVert \\mathbf{x} \\rVert^2\n$$\nwhere $n_0$ and $\\alpha$ are positive constants. For this profile, the gradient term is $\\frac{1}{2}\\nabla n^2(\\mathbf{x}) = \\frac{1}{2}\\nabla(n_0^2 - \\alpha(x^2+y^2)) = -\\alpha\\mathbf{x}$. The system of ordinary differential equations (ODEs) becomes:\n$$\n\\frac{d\\mathbf{x}}{d\\tau} = \\mathbf{p}, \\qquad \\frac{d\\mathbf{p}}{d\\tau} = -\\alpha \\mathbf{x}\n$$\nThis is equivalent to the second-order system $\\frac{d^2\\mathbf{x}}{d\\tau^2} + \\alpha\\mathbf{x} = 0$, which describes a simple harmonic oscillator with angular frequency $\\omega = \\sqrt{\\alpha}$.\n\nBefore implementing numerical solvers, we derive the exact analytical solution and the exact travel time $T_{\\text{exact}}$, which serves as the benchmark for accuracy. The initial conditions are specified as $\\mathbf{x}(0) = [A, 0]^{\\mathsf{T}}$ and $\\mathbf{p}(0) = [0, \\sqrt{n_0^2 - \\alpha A^2}]^{\\mathsf{T}}$, with $A = \\rho r_c = \\rho n_0 / \\sqrt{\\alpha}$ and $\\rho = 0.6$. Substituting these values simplifies the initial momentum to $\\mathbf{p}(0)=[0, 0.8 n_0]^{\\mathsf{T}}$. The general solution to the harmonic oscillator equation is $\\mathbf{x}(\\tau) = \\mathbf{C}_1 \\cos(\\sqrt{\\alpha}\\tau) + \\mathbf{C}_2 \\sin(\\sqrt{\\alpha}\\tau)$. Applying the initial conditions yields the exact trajectory:\n$$\n\\mathbf{x}(\\tau) = \\begin{bmatrix} A \\cos(\\sqrt{\\alpha}\\tau) \\\\ \\frac{\\sqrt{n_0^2 - \\alpha A^2}}{\\sqrt{\\alpha}} \\sin(\\sqrt{\\alpha}\\tau) \\end{bmatrix} = \\begin{bmatrix} (0.6 n_0 / \\sqrt{\\alpha}) \\cos(\\sqrt{\\alpha}\\tau) \\\\ (0.8 n_0 / \\sqrt{\\alpha}) \\sin(\\sqrt{\\alpha}\\tau) \\end{bmatrix}\n$$\nThe period of oscillation in the parameter $\\tau$ is $\\tau_p = 2\\pi/\\sqrt{\\alpha}$. The problem requires integration over exactly this period, so $\\tau_{\\text{end}} = 2\\pi/\\sqrt{\\alpha}$.\n\nThe optical travel time $T$ is given by $T = \\frac{1}{c_0} \\int n^2(\\mathbf{x}(\\tau)) d\\tau$. Since $H=0$ along the true path, we have $n^2(\\mathbf{x}(\\tau)) = \\lVert\\mathbf{p}(\\tau)\\rVert^2$. We can compute $\\mathbf{p}(\\tau) = \\frac{d\\mathbf{x}}{d\\tau}$ and integrate its squared norm, but a more elegant derivation for the exact travel time $T_{\\text{exact}}$ over one period is as follows:\n$$\nT_{\\text{exact}} = \\frac{1}{c_0} \\int_{0}^{\\tau_{\\text{end}}} \\left( n_0^2 - \\alpha \\lVert \\mathbf{x}(\\tau) \\rVert^2 \\right) d\\tau\n$$\nWe need to evaluate the integral of $\\lVert \\mathbf{x}(\\tau) \\rVert^2$:\n$$\n\\int_{0}^{\\tau_{\\text{end}}} \\lVert \\mathbf{x}(\\tau) \\rVert^2 d\\tau = \\int_{0}^{2\\pi/\\sqrt{\\alpha}} \\left( A^2 \\cos^2(\\sqrt{\\alpha}\\tau) + \\frac{n_0^2 - \\alpha A^2}{\\alpha} \\sin^2(\\sqrt{\\alpha}\\tau) \\right) d\\tau\n$$\nUsing the definite integrals $\\int_0^{2\\pi} \\cos^2\\theta d\\theta = \\pi$ and $\\int_0^{2\\pi} \\sin^2\\theta d\\theta = \\pi$, with the substitution $\\theta = \\sqrt{\\alpha}\\tau$, we find:\n$$\n\\int_{0}^{\\tau_{\\text{end}}} \\lVert \\mathbf{x}(\\tau) \\rVert^2 d\\tau = \\frac{1}{\\sqrt{\\alpha}} \\left( A^2 \\pi + \\frac{n_0^2 - \\alpha A^2}{\\alpha} \\pi \\right) = \\frac{\\pi}{\\alpha\\sqrt{\\alpha}} \\left( \\alpha A^2 + n_0^2 - \\alpha A^2 \\right) = \\frac{\\pi n_0^2}{\\alpha\\sqrt{\\alpha}}\n$$\nSubstituting this back into the expression for $T_{\\text{exact}}$:\n$$\nT_{\\text{exact}} = \\frac{1}{c_0} \\left( n_0^2 \\tau_{\\text{end}} - \\alpha \\int_{0}^{\\tau_{\\text{end}}} \\lVert \\mathbf{x}(\\tau) \\rVert^2 d\\tau \\right) = \\frac{1}{c_0} \\left( n_0^2 \\frac{2\\pi}{\\sqrt{\\alpha}} - \\alpha \\frac{\\pi n_0^2}{\\alpha\\sqrt{\\alpha}} \\right) = \\frac{n_0^2 \\pi}{c_0 \\sqrt{\\alpha}}\n$$\nThis simple formula provides the exact travel time for comparison.\n\nNext, we specify the numerical integrators. The state of the system is the $4$-dimensional vector $\\mathbf{y} = [\\mathbf{x}^{\\mathsf{T}}, \\mathbf{p}^{\\mathsf{T}}]^{\\mathsf{T}} = [x, y, p_x, p_y]^{\\mathsf{T}}$. The ODE system is $\\frac{d\\mathbf{y}}{d\\tau} = \\mathbf{f}(\\mathbf{y})$, where $\\mathbf{f}(\\mathbf{y}) = [p_x, p_y, -\\alpha x, -\\alpha y]^{\\mathsf{T}}$.\n\nThe first integrator is the classical fourth-order Runge-Kutta method (RK4). For a step size $h$, one step from $\\mathbf{y}_n$ to $\\mathbf{y}_{n+1}$ is:\n$$\n\\mathbf{k}_1 = h \\, \\mathbf{f}(\\mathbf{y}_n)\n$$\n$$\n\\mathbf{k}_2 = h \\, \\mathbf{f}(\\mathbf{y}_n + \\mathbf{k}_1/2)\n$$\n$$\n\\mathbf{k}_3 = h \\, \\mathbf{f}(\\mathbf{y}_n + \\mathbf{k}_2/2)\n$$\n$$\n\\mathbf{k}_4 = h \\, \\mathbf{f}(\\mathbf{y}_n + \\mathbf{k}_3)\n$$\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{1}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\nRK4 is a general-purpose integrator and is not designed to preserve the geometric structures of Hamiltonian systems, such as symplecticity.\n\nThe second integrator is the second-order Störmer-Verlet (SV) method, a symplectic integrator well-suited for separable Hamiltonians of the form $H(\\mathbf{x}, \\mathbf{p}) = T(\\mathbf{p}) + V(\\mathbf{x})$. In our case, $T(\\mathbf{p}) = \\frac{1}{2}\\lVert \\mathbf{p} \\rVert^2$ and $V(\\mathbf{x}) = -\\frac{1}{2}n^2(\\mathbf{x}) = -\\frac{1}{2}(n_0^2 - \\alpha \\lVert \\mathbf{x} \\rVert^2)$. The force is $\\mathbf{F}(\\mathbf{x}) = -\\nabla V(\\mathbf{x}) = -\\alpha\\mathbf{x}$. The position-Verlet update scheme for one step of size $h$ is:\n$$\n\\mathbf{p}_{n+1/2} = \\mathbf{p}_n + \\frac{h}{2} \\mathbf{F}(\\mathbf{x}_n) = \\mathbf{p}_n - \\frac{h}{2} \\alpha \\mathbf{x}_n\n$$\n$$\n\\mathbf{x}_{n+1} = \\mathbf{x}_n + h \\mathbf{p}_{n+1/2}\n$$\n$$\n\\mathbf{p}_{n+1} = \\mathbf{p}_{n+1/2} + \\frac{h}{2} \\mathbf{F}(\\mathbf{x}_{n+1}) = \\mathbf{p}_{n+1/2} - \\frac{h}{2} \\alpha \\mathbf{x}_{n+1}\n$$\nThis method is time-reversible and preserves the symplectic two-form, which leads to excellent long-term stability and bounded energy error for Hamiltonian systems.\n\nFor each integrator and test case, we perform a simulation from $\\tau=0$ to $\\tau_{\\text{end}}$. The number of full steps of size $h$ is $N = \\lfloor\\tau_{\\text{end}}/h\\rfloor$. The final step has a smaller size $h_{\\text{last}} = \\tau_{\\text{end}} - N h$ to land exactly at the target time. The trajectory $(\\mathbf{x}_k, \\mathbf{p}_k)$ is stored at each time point $\\tau_k$.\n\nThe evaluation metrics are computed from the stored trajectory.\nThe maximum Hamiltonian drift is calculated as:\n$$\n\\Delta H_{\\max} = \\max_{k} \\left| H(\\mathbf{x}_k, \\mathbf{p}_k) - H(\\mathbf{x}_0, \\mathbf{p}_0) \\right|\n$$\nSince the initial condition is constructed such that $H(\\mathbf{x}_0, \\mathbf{p}_0) = 0$, this simplifies to $\\Delta H_{\\max} = \\max_{k} | \\frac{1}{2}(\\lVert\\mathbf{p}_k\\rVert^2 - (n_0^2 - \\alpha\\lVert\\mathbf{x}_k\\rVert^2)) |$.\n\nThe numerical travel time, $T_{\\text{num}}$, is computed using the trapezoidal rule on the stored values of $n^2(\\mathbf{x}_k)$ at times $\\tau_k$:\n$$\nT_{\\text{num}} = \\frac{1}{c_0} \\sum_{k=0}^{M-1} \\frac{n^2(\\mathbf{x}_k) + n^2(\\mathbf{x}_{k+1})}{2} (\\tau_{k+1}-\\tau_k)\n$$\nwhere $M$ is the total number of steps. The absolute error is then $|T_{\\text{num}} - T_{\\text{exact}}|$.\n\nThe implementation will consist of functions for each integrator step, a main simulation loop that applies the chosen integrator and collects trajectory data, and a top-level script to iterate through the test cases and format the results as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n    # Global constants\n    n0 = 1.6  # Dimensionless\n    c0 = 299792458.0  # m/s\n    rho = 0.6  # Dimensionless\n\n    # Test suite: (alpha [m^-2], h [m])\n    test_cases = [\n        (400.0, 0.05),\n        (2500.0, 0.039),\n        (25.0, 0.3),\n        (10000.0, 0.015),\n    ]\n\n    results = []\n    for alpha, h in test_cases:\n        # Calculate case-specific parameters\n        sqrt_alpha = np.sqrt(alpha)\n        tau_end = 2.0 * np.pi / sqrt_alpha\n\n        # Initial conditions\n        A = rho * n0 / sqrt_alpha\n        x0 = np.array([A, 0.0])\n        p0 = np.array([0.0, 0.8 * n0])\n\n        # Exact travel time\n        t_exact = (n0**2 * np.pi) / (c0 * sqrt_alpha)\n\n        # Run RK4 simulation\n        h_drift_rk4, t_err_rk4 = run_simulation(\n            \"rk4\", alpha, h, tau_end, x0, p0, n0, c0, t_exact\n        )\n\n        # Run Störmer-Verlet simulation\n        h_drift_sv, t_err_sv = run_simulation(\n            \"sv\", alpha, h, tau_end, x0, p0, n0, c0, t_exact\n        )\n\n        results.append([h_drift_rk4, t_err_rk4, h_drift_sv, t_err_sv])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation(integrator_name, alpha, h, tau_end, x0, p0, n0, c0, t_exact):\n    \"\"\"\n    Runs a single simulation for a given integrator and returns the metrics.\n    \"\"\"\n    # Initialize trajectory storage\n    tau = 0.0\n    x, p = x0.copy(), p0.copy()\n    \n    tau_vals = [tau]\n    x_traj = [x]\n    p_traj = [p]\n\n    # Integration loop\n    while tau  tau_end:\n        step_h = min(h, tau_end - tau)\n        if step_h  1e-12: # Avoid tiny final steps\n            break\n\n        if integrator_name == \"rk4\":\n            y = np.concatenate((x, p))\n            k1 = step_h * f_ode(y, alpha)\n            k2 = step_h * f_ode(y + 0.5 * k1, alpha)\n            k3 = step_h * f_ode(y + 0.5 * k2, alpha)\n            k4 = step_h * f_ode(y + k3, alpha)\n            y_next = y + (k1 + 2.0 * k2 + 2.0 * k3 + k4) / 6.0\n            x, p = y_next[:2], y_next[2:]\n        elif integrator_name == \"sv\":\n            p_half = p - (step_h / 2.0) * alpha * x\n            x_next = x + step_h * p_half\n            p = p_half - (step_h / 2.0) * alpha * x_next\n            x = x_next\n        \n        tau += step_h\n        \n        tau_vals.append(tau)\n        x_traj.append(x)\n        p_traj.append(p)\n    \n    # Calculate metrics\n    x_traj_arr = np.array(x_traj)\n    p_traj_arr = np.array(p_traj)\n    tau_vals_arr = np.array(tau_vals)\n\n    # Hamiltonian drift\n    n_sq_vals = n0**2 - alpha * np.sum(x_traj_arr**2, axis=1)\n    p_sq_vals = np.sum(p_traj_arr**2, axis=1)\n    hamiltonian_vals = 0.5 * (p_sq_vals - n_sq_vals)\n    h_drift_max = np.max(np.abs(hamiltonian_vals)) # H(0)=0\n\n    # Travel time error\n    t_num = np.trapz(n_sq_vals, tau_vals_arr) / c0\n    t_error = np.abs(t_num - t_exact)\n\n    return h_drift_max, t_error\n\ndef f_ode(y, alpha):\n    \"\"\"\n    Derivative function for the 4D state vector y = [x, y, px, py].\n    \"\"\"\n    x, y_coord, px, py = y\n    return np.array([px, py, -alpha * x, -alpha * y_coord])\n\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3311401"}, {"introduction": "Beyond simply simulating where rays go, a powerful application of computational optics lies in automated design. This practice introduces the adjoint method, a highly efficient technique for calculating how a system's performance changes with respect to its design parameters. You will implement this advanced method to find the shape gradient for a refractive surface that molds light into a desired pattern, a common goal in illumination engineering and laser beam shaping, and verify your results using the trusted finite-difference technique [@problem_id:3311421].", "problem": "Consider a two-dimensional refractive interface described by a scalar height function $s(x;\\mathbf{p})$ where $x$ is the lateral coordinate and $\\mathbf{p}$ denotes the vector of shape parameters. A collimated bundle of rays enters from a homogeneous medium of refractive index $n_1$ and propagates along the negative $y$-axis, strikes the refractive interface at $y=s(x;\\mathbf{p})$, and refracts into a second homogeneous medium of refractive index $n_2$. The refracted rays then propagate to a planar target located at $y=Y_t$, producing an irradiance distribution on the target. The task is to compute the shape gradient of an energy-matching objective using adjoint ray tracing and verify the gradient accuracy via finite differences.\n\nFundamental base:\n- Use Snell's law of refraction derived from Fermat's principle: for a unit incident direction $\\mathbf{I}$ and a unit normal $\\mathbf{N}$ at the interface, the unit refracted direction $\\mathbf{T}$ obeys the vector form $\\mathbf{T}=\\eta\\,\\mathbf{I}+(\\eta\\,\\cos\\theta_i-\\cos\\theta_t)\\,\\mathbf{N}$, where $\\eta=n_1/n_2$, $\\cos\\theta_i=-\\mathbf{N}\\cdot\\mathbf{I}$, and $\\cos\\theta_t=\\sqrt{1-\\eta^2(1-\\cos^2\\theta_i)}$ under no total internal reflection.\n- Use local energy conservation in geometrical optics: the irradiance on the target can be represented by transporting input ray energy to the target via an approximation of the Dirac delta distribution through a smooth kernel.\n\nModel and discretization:\n- The interface is a rotationally symmetric curve parameterized as $s(x;\\mathbf{p})=p_0+p_2 x^2$, where $p_0$ is an axial offset in $\\mathrm{m}$ and $p_2$ is a quadratic curvature coefficient in $\\mathrm{m}^{-1}$.\n- The incident rays are distributed uniformly across an aperture $x\\in[-W,W]$ with ray positions $\\{x_i\\}_{i=1}^{N}$ and constant input irradiance density $I_0$ in $\\mathrm{W/m}$. Each ray carries energy $w_i=I_0\\Delta x$, where $\\Delta x = \\frac{2W}{N-1}$ is the ray sampling interval in $\\mathrm{m}$.\n- At point $x_i$ on the interface, the unit normal is constructed from the surface slope $s'(x_i;\\mathbf{p})$ as $\\mathbf{N}=\\frac{1}{\\sqrt{1+(s')^2}}(-s',1)$, and the unit incident direction is $\\mathbf{I}=(0,-1)$. The refracted direction $\\mathbf{T}=(T_x,T_y)$ is obtained from Snell's law.\n- The refracted ray starting at $(x_i,s(x_i;\\mathbf{p}))$ intersects the target plane at $y=Y_t$ at the lateral position $x_t(x_i;\\mathbf{p})$ given by $x_t(x_i;\\mathbf{p})=x_i+T_x t_i$, where $t_i=\\frac{Y_t-s(x_i;\\mathbf{p})}{T_y}$ is the travel parameter.\n- The target irradiance is computed on a uniform grid $\\{x_k\\}_{k=1}^{M}$ over a specified range using a normalized Gaussian kernel $\\varphi_\\sigma(x)=\\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\!\\left(-\\frac{x^2}{2\\sigma^2}\\right)$ in $\\mathrm{m}^{-1}$ to approximate the Dirac delta that transports each ray’s energy to the target. The numerical irradiance is $I_{\\text{num}}(x_k;\\mathbf{p})=\\sum_{i=1}^{N}w_i\\,\\varphi_\\sigma(x_k-x_t(x_i;\\mathbf{p}))$ in $\\mathrm{W/m}$.\n- The target prescription is a normalized Gaussian $I_{\\text{tgt}}(x_k)=\\frac{P}{\\sqrt{2\\pi}\\sigma_t}\\exp\\!\\left(-\\frac{x_k^2}{2\\sigma_t^2}\\right)$ in $\\mathrm{W/m}$, where $P=I_0\\cdot 2W$ is the total input power in $\\mathrm{W}$ and $\\sigma_t$ is the target width in $\\mathrm{m}$.\n\nObjective:\n- Define the least-squares mismatch $J(\\mathbf{p})=\\frac{1}{2}\\sum_{k=1}^{M}\\left(I_{\\text{num}}(x_k;\\mathbf{p})-I_{\\text{tgt}}(x_k)\\right)^2\\,\\Delta x_{\\text{tgt}}$, where $\\Delta x_{\\text{tgt}}$ is the target grid spacing in $\\mathrm{m}$.\n\nAdjoint ray tracing gradient:\n- Derive the adjoint-based shape gradient $\\nabla_{\\mathbf{p}} J$ by reverse accumulation from the target plane to the interface. Use the chain rule with the kernel derivative $\\varphi'_\\sigma(x)=-\\frac{x}{\\sigma^2}\\varphi_\\sigma(x)$ and the geometric derivatives of $x_t$ with respect to $(p_0,p_2)$ via $(s,s')$.\n- The required geometric derivatives at each ray are $\\frac{\\partial x_t}{\\partial s}$ and $\\frac{\\partial x_t}{\\partial s'}$ obtained from the refraction kinematics and the intersection with the target plane, and then combine them via $\\frac{\\partial x_t}{\\partial p_0}=\\frac{\\partial x_t}{\\partial s}$ and $\\frac{\\partial x_t}{\\partial p_2}=x_i^2\\frac{\\partial x_t}{\\partial s}+2x_i\\frac{\\partial x_t}{\\partial s'}$.\n\nVerification by finite differences:\n- Verify the adjoint gradient by comparing it to a central finite-difference approximation with small perturbations $\\delta_{p_0}$ in $\\mathrm{m}$ and $\\delta_{p_2}$ in $\\mathrm{m}^{-1}$.\n\nUnits and output:\n- All distances must be treated in $\\mathrm{m}$, refractive indices are unitless, and irradiance in $\\mathrm{W/m}$. Angles are not used directly; directions are represented as unit vectors.\n- Your program must compute, for each specified test case, the relative error between the adjoint gradient and the finite-difference gradient for both parameters $p_0$ and $p_2$, defined as $\\frac{\\left|\\text{grad}_{\\text{adj}}-\\text{grad}_{\\text{fd}}\\right|}{\\max\\left(\\left|\\text{grad}_{\\text{fd}}\\right|,10^{-12}\\right)}$, yielding two floats per test case.\n- The final output must be a single line containing a Python list of lists, where each inner list corresponds to a test case and contains the two floats for the relative gradient errors in the order $[e_{p_0},e_{p_2}]$.\n\nTest suite:\n- Use the following three cases that collectively examine typical behavior, a near-boundary flat-surface condition, and a stronger curvature with higher index contrast. For each, specify $(n_1,n_2,W,N,Y_t,\\sigma,\\sigma_t,I_0,p_0,p_2,X_{\\max},M,\\delta_{p_0},\\delta_{p_2})$:\n    - Case $1$ (general focusing): $(n_1,n_2,W,N,Y_t,\\sigma,\\sigma_t,I_0,p_0,p_2,X_{\\max},M,\\delta_{p_0},\\delta_{p_2})=(1.0,1.5,0.02,201,0.20,0.002,0.010,1.0,0.0,50.0,0.04,801,10^{-6},10^{-6})$.\n    - Case $2$ (flat interface edge case): $(n_1,n_2,W,N,Y_t,\\sigma,\\sigma_t,I_0,p_0,p_2,X_{\\max},M,\\delta_{p_0},\\delta_{p_2})=(1.0,1.2,0.02,201,0.20,0.002,0.010,1.0,0.0,0.0,0.04,801,10^{-6},10^{-6})$.\n    - Case $3$ (strong curvature, higher contrast): $(n_1,n_2,W,N,Y_t,\\sigma,\\sigma_t,I_0,p_0,p_2,X_{\\max},M,\\delta_{p_0},\\delta_{p_2})=(1.0,1.7,0.015,301,0.15,0.001,0.008,1.0,0.0,300.0,0.03,601,10^{-6},10^{-6})$.\n- Your program should produce a single line of output containing the results as a comma-separated Python list of lists, for example, $[\\,[e_{p_0}^{(1)},e_{p_2}^{(1)}],\\,[e_{p_0}^{(2)},e_{p_2}^{(2)}],\\,[e_{p_0}^{(3)},e_{p_2}^{(3)}]\\,]$ where superscripts denote the test case index.\n\nRequirements:\n- Implement the forward ray tracing using Snell’s law from first principles.\n- Implement the adjoint gradient accumulation from the target mismatch to the surface parameters.\n- Implement central finite differences for verification.\n- Ensure numerical stability by avoiding total internal reflection, and by using the specified small perturbations for finite differences.", "solution": "The user has provided a valid, well-posed problem in the field of computational optics. The task is to calculate the shape gradient of a least-squares objective function using the adjoint method and verify its accuracy against a finite-difference approximation. The optical system consists of a single refractive interface defined by a quadratic profile, separating two homogeneous media.\n\nThe solution will be presented in three main parts:\n1.  **Forward Model**: This section describes the process of tracing rays from the source to the target plane and calculating the resulting irradiance distribution and objective function.\n2.  **Adjoint Model**: This section details the derivation of the gradient of the objective function with respect to the shape parameters using the adjoint state method. This involves back-propagating sensitivities from the target plane to the refractive interface.\n3.  **Verification**: This section outlines the central finite-difference method used to obtain a numerical approximation of the gradient, which serves as a benchmark for verifying the analytical adjoint gradient.\n\n### 1. Forward Model: Ray Tracing and Objective Function\n\nThe forward model simulates the physical process of light propagation and interaction.\n\n**1.1. Ray Generation and Interface Interaction**\nA set of $N$ rays is initialized on a uniform grid $\\{x_i\\}$ over the input aperture $x \\in [-W, W]$. Each ray propagates along the negative $y$-axis with an initial direction vector $\\mathbf{I} = (0, -1)$ and carries an energy $w = I_0 \\Delta x$, where $\\Delta x = \\frac{2W}{N-1}$.\n\nFor each ray $i$ incident at lateral position $x_i$, it strikes the refractive interface $s(x; \\mathbf{p}) = p_0 + p_2 x^2$ at the point $(x_i, s_i = s(x_i; \\mathbf{p}))$. At this point, the surface slope is $s'_i = \\frac{\\partial s}{\\partial x}(x_i; \\mathbf{p}) = 2p_2 x_i$. The unit normal vector to the interface, pointing into the first medium (upwards), is given by:\n$$\n\\mathbf{N}_i = \\frac{1}{\\sqrt{1 + (s'_i)^2}}(-s'_i, 1)\n$$\nThe incident direction is $\\mathbf{I}=(0,-1)$. The cosine of the angle of incidence $\\theta_i$ is computed as $\\cos\\theta_i = -\\mathbf{N}_i \\cdot \\mathbf{I} = N_{iy} = (1+(s'_i)^2)^{-1/2}$.\n\n**1.2. Refraction via Snell's Law**\nThe refracted ray direction $\\mathbf{T}_i = (T_{ix}, T_{iy})$ is determined by the vector form of Snell's law:\n$$\n\\mathbf{T}_i = \\eta \\mathbf{I} + (\\eta \\cos\\theta_i - \\cos\\theta_t) \\mathbf{N}_i\n$$\nwhere $\\eta = n_1/n_2$ is the relative refractive index, and $\\cos\\theta_t = \\sqrt{1 - \\eta^2(1 - \\cos^2\\theta_i)}$. Since all test cases have $n_1  n_2$, $\\eta  1$, and total internal reflection does not occur.\nBy expanding the vector equation, we can derive an explicit expression for the $x$-component of the refracted direction, $T_{ix}$, as a function of the slope $s'_i$:\n$$\nT_{ix} = \\frac{-s'_i}{1+(s'_i)^2} \\left(\\eta - \\sqrt{1+(s'_i)^2(1-\\eta^2)}\\right)\n$$\nSince $\\mathbf{T}_i$ is a unit vector, $T_{ix}^2 + T_{iy}^2 = 1$. The physical situation dictates that rays propagate towards the target plane, so we must have $T_{iy}  0$. Thus, $T_{iy} = -\\sqrt{1 - T_{ix}^2}$.\n\n**1.3. Propagation to Target and Irradiance Calculation**\nThe refracted ray from $(x_i, s_i)$ propagates to the target plane at $y=Y_t$. The travel parameter $t_i$ is found from the $y$-component of the ray path: $Y_t = s_i + T_{iy} t_i$, which gives $t_i = (Y_t - s_i) / T_{iy}$. The lateral position of the ray on the target is then:\n$$\nx_{t,i} = x_i + T_{ix} t_i\n$$\nThe irradiance on the target is calculated on a uniform grid $\\{x_k\\}$ of $M$ points. Each ray's energy is distributed onto this grid using a normalized Gaussian kernel $\\varphi_\\sigma(z)$ to approximate a Dirac delta function. The numerical irradiance at each grid point $x_k$ is the sum of contributions from all $N$ rays:\n$$\nI_{\\text{num}}(x_k; \\mathbf{p}) = \\sum_{i=1}^{N} w \\, \\varphi_\\sigma(x_k - x_{t,i}(\\mathbf{p}))\n$$\n\n**1.4. Objective Function**\nThe objective is to match the computed irradiance $I_{\\text{num}}$ to a prescribed target irradiance $I_{\\text{tgt}}$. The misfit is quantified by a least-squares objective function $J(\\mathbf{p})$:\n$$\nJ(\\mathbf{p}) = \\frac{1}{2} \\sum_{k=1}^{M} (I_{\\text{num}}(x_k; \\mathbf{p}) - I_{\\text{tgt}}(x_k))^2 \\Delta x_{\\text{tgt}}\n$$\nwhere $\\Delta x_{\\text{tgt}}$ is the spacing of the target grid points.\n\n### 2. Adjoint Model: Gradient Calculation\n\nThe adjoint method provides an efficient way to compute the gradient $\\nabla_\\mathbf{p} J$ by avoiding repeated forward simulations. It relies on the chain rule to back-propagate sensitivities from the objective function to the design parameters.\n\n**2.1. Gradient of the Objective Function**\nThe gradient of $J$ with respect to a parameter $p_j$ (where $j \\in \\{0, 2\\}$) is:\n$$\n\\frac{\\partial J}{\\partial p_j} = \\sum_{k=1}^{M} (I_{\\text{num}}(x_k) - I_{\\text{tgt}}(x_k)) \\frac{\\partial I_{\\text{num}}(x_k)}{\\partial p_j} \\Delta x_{\\text{tgt}}\n$$\nThe derivative of the numerical irradiance is:\n$$\n\\frac{\\partial I_{\\text{num}}(x_k)}{\\partial p_j} = \\sum_{i=1}^{N} w \\, \\varphi'_\\sigma(x_k - x_{t,i}) \\left( -\\frac{\\partial x_{t,i}}{\\partial p_j} \\right)\n$$\nwhere $\\varphi'_\\sigma$ is the derivative of the Gaussian kernel. Substituting and rearranging the sums, we get:\n$$\n\\frac{\\partial J}{\\partial p_j} = \\sum_{i=1}^{N} \\left( -w \\sum_{k=1}^{M} \\Delta x_{\\text{tgt}} (I_{\\text{num}}(x_k) - I_{\\text{tgt}}(x_k)) \\varphi'_\\sigma(x_k-x_{t,i}) \\right) \\frac{\\partial x_{t,i}}{\\partial p_j}\n$$\nThe term in the parenthesis is the adjoint variable, or sensitivity, $\\bar{x}_{t,i}$, which represents the contribution of a small change in the ray's target position $x_{t,i}$ to the total change in the objective function $J$.\n$$\n\\bar{x}_{t,i} = \\frac{\\partial J}{\\partial x_{t,i}}\n$$\nSo, the total gradient is an accumulation over all rays:\n$$\n\\frac{\\partial J}{\\partial p_j} = \\sum_{i=1}^{N} \\bar{x}_{t,i} \\frac{\\partial x_{t,i}}{\\partial p_j}\n$$\n\n**2.2. Geometric Sensitivities**\nThe final step is to find the geometric sensitivities $\\frac{\\partial x_{t,i}}{\\partial p_j}$. We use the local surface height $s_i$ and slope $s'_i$ as intermediate variables. By the chain rule:\n$$\n\\frac{\\partial x_{t,i}}{\\partial p_j} = \\frac{\\partial x_{t,i}}{\\partial s_i}\\frac{\\partial s_i}{\\partial p_j} + \\frac{\\partial x_{t,i}}{\\partial s'_i}\\frac{\\partial s'_i}{\\partial p_j}\n$$\nFrom $s_i = p_0 + p_2 x_i^2$ and $s'_i = 2p_2 x_i$, we have:\n*   $\\frac{\\partial s_i}{\\partial p_0} = 1$, $\\frac{\\partial s'_i}{\\partial p_0} = 0 \\implies \\frac{\\partial x_{t,i}}{\\partial p_0} = \\frac{\\partial x_{t,i}}{\\partial s_i}$\n*   $\\frac{\\partial s_i}{\\partial p_2} = x_i^2$, $\\frac{\\partial s'_i}{\\partial p_2} = 2x_i \\implies \\frac{\\partial x_{t,i}}{\\partial p_2} = x_i^2 \\frac{\\partial x_{t,i}}{\\partial s_i} + 2x_i \\frac{\\partial x_{t,i}}{\\partial s'_i}$\n\nThe derivatives of the target position $x_t$ with respect to $s$ and $s'$ can be derived from $x_t = x + T_x(s') \\frac{Y_t - s}{T_y(s')}$:\n$$\n\\frac{\\partial x_t}{\\partial s} = \\frac{\\partial}{\\partial s}\\left(x + T_x \\frac{Y_t-s}{T_y}\\right) = -\\frac{T_x}{T_y}\n$$\n$$\n\\frac{\\partial x_t}{\\partial s'} = \\frac{\\partial}{\\partial s'}\\left(x + T_x \\frac{Y_t-s}{T_y}\\right) = (Y_t-s)\\frac{\\partial}{\\partial s'}\\left(\\frac{T_x}{T_y}\\right) = t \\left( \\frac{\\partial T_x}{\\partial s'} - \\frac{T_x}{T_y}\\frac{\\partial T_y}{\\partial s'}\\right)\n$$\nUsing the property $T_x^2+T_y^2=1$, which implies $T_x \\frac{\\partial T_x}{\\partial s'} + T_y \\frac{\\partial T_y}{\\partial s'} = 0$, the expression simplifies to:\n$$\n\\frac{\\partial x_t}{\\partial s'} = \\frac{t}{T_y^2} \\frac{\\partial T_x}{\\partial s'}\n$$\nThe derivative $\\frac{\\partial T_x}{\\partial s'}$ is found by differentiating the explicit expression for $T_x(s')$.\n\nWith these components, the full adjoint gradient can be assembled and computed.\n\n### 3. Verification via Finite Differences\n\nTo verify the correctness of the derived adjoint gradient, we compare it to a numerical approximation obtained using the central finite-difference formula. For each parameter $p_j$, the gradient is approximated as:\n$$\n\\frac{\\partial J}{\\partial p_j} \\approx \\frac{J(\\mathbf{p} + \\delta_j \\mathbf{e}_j) - J(\\mathbf{p} - \\delta_j \\mathbf{e}_j)}{2\\delta_j}\n$$\nwhere $\\mathbf{e}_j$ is a standard basis vector and $\\delta_j$ is a small perturbation (e.g., $10^{-6}$). This requires two additional evaluations of the objective function $J$ for each parameter. The relative error between the adjoint gradient $(\\text{grad}_{\\text{adj}})$ and the finite-difference gradient $(\\text{grad}_{\\text{fd}})$ is then computed as:\n$$\n\\text{Error} = \\frac{|\\text{grad}_{\\text{adj}} - \\text{grad}_{\\text{fd}}|}{\\max(|\\text{grad}_{\\text{fd}}|, 10^{-12})}\n$$\nA small relative error (typically close to machine precision or the precision of the finite-difference approximation) confirms the correctness of the complex adjoint implementation.", "answer": "```python\nimport numpy as np\n\nclass SimulationParameters:\n    \"\"\"A helper class to hold all simulation parameters for a given case.\"\"\"\n    def __init__(self, n1, n2, W, N, Yt, sigma, sigma_t, I0, p0, p2, Xmax, M, delta_p0, delta_p2):\n        self.n1 = n1\n        self.n2 = n2\n        self.eta = n1 / n2\n        self.W = W\n        self.N = N\n        self.Yt = Yt\n        self.sigma = sigma\n        self.sigma_t = sigma_t\n        self.I0 = I0\n        self.p_vec = np.array([p0, p2], dtype=float)\n        self.Xmax = Xmax\n        self.M = M\n        self.delta_p = np.array([delta_p0, delta_p2], dtype=float)\n\n        # Derived parameters\n        self.x_in = np.linspace(-self.W, self.W, self.N)\n        self.dx_in = (2.0 * self.W) / (self.N - 1) if self.N > 1 else 0\n        self.ray_energy = self.I0 * self.dx_in\n        self.P_total = self.I0 * 2.0 * self.W\n        \n        self.x_target_grid = np.linspace(-self.Xmax, self.Xmax, self.M)\n        self.dx_target = (2.0 * self.Xmax) / (self.M - 1) if self.M > 1 else 0\n\ndef gaussian_kernel(x, sigma):\n    \"\"\"Computes the value of a Gaussian kernel.\"\"\"\n    return (1.0 / (np.sqrt(2.0 * np.pi) * sigma)) * np.exp(-x**2 / (2.0 * sigma**2))\n\ndef gaussian_kernel_deriv(x, sigma):\n    \"\"\"Computes the derivative of a Gaussian kernel.\"\"\"\n    return -x / sigma**2 * gaussian_kernel(x, sigma)\n\ndef compute_objective_and_intermediates(p_vec, params):\n    \"\"\"Performs forward ray tracing and computes the objective function J and intermediate values.\"\"\"\n    p0, p2 = p_vec\n    \n    x_i = params.x_in\n    s_i = p0 + p2 * x_i**2\n    s_prime_i = 2.0 * p2 * x_i\n\n    s_prime_sq = s_prime_i**2\n    term_in_sqrt = 1.0 + s_prime_sq * (1.0 - params.eta**2)\n    # This check is formally not needed since eta  1, but is good practice.\n    if np.any(term_in_sqrt  0):\n        raise ValueError(\"Total Internal Reflection encountered, problem is ill-defined for these parameters.\")\n    \n    sqrt_term = np.sqrt(term_in_sqrt)\n    Tx = (-s_prime_i * (params.eta - sqrt_term)) / (1.0 + s_prime_sq)\n    \n    Ty_sq = 1.0 - Tx**2\n    Ty_sq[Ty_sq  0] = 0.0\n    Ty = -np.sqrt(Ty_sq)\n\n    t_i = (params.Yt - s_i) / Ty\n    x_t = x_i + Tx * t_i\n\n    delta_x = params.x_target_grid[:, np.newaxis] - x_t[np.newaxis, :]\n    I_num = params.ray_energy * np.sum(gaussian_kernel(delta_x, params.sigma), axis=1)\n\n    I_tgt = (params.P_total / (np.sqrt(2.0 * np.pi) * params.sigma_t)) * \\\n            np.exp(-params.x_target_grid**2 / (2.0 * params.sigma_t**2))\n\n    J = 0.5 * np.sum((I_num - I_tgt)**2) * params.dx_target\n    \n    intermediates = {\n        'x_i': x_i, 's_prime_i': s_prime_i, 'Tx': Tx, 'Ty': Ty, 't_i': t_i,\n        'I_num': I_num, 'I_tgt': I_tgt, 'delta_x': delta_x\n    }\n    \n    return J, intermediates\n\ndef compute_adjoint_gradient(p_vec, params):\n    \"\"\"Computes the gradient of the objective function using the adjoint method.\"\"\"\n    _, intermediates = compute_objective_and_intermediates(p_vec, params)\n    \n    x_i = intermediates['x_i']\n    s_prime_i = intermediates['s_prime_i']\n    Tx, Ty, t_i = intermediates['Tx'], intermediates['Ty'], intermediates['t_i']\n    I_num, I_tgt, delta_x = intermediates['I_num'], intermediates['I_tgt'], intermediates['delta_x']\n    \n    mismatch = (I_num - I_tgt)[:, np.newaxis]\n    kernel_deriv = gaussian_kernel_deriv(delta_x, params.sigma)\n    x_t_bar = -params.ray_energy * params.dx_target * np.sum(mismatch * kernel_deriv, axis=0)\n    \n    dxt_ds = -Tx / Ty\n    \n    s_prime_sq = s_prime_i**2\n    eta_sq = params.eta**2\n    \n    f = -s_prime_i / (1.0 + s_prime_sq)\n    f_prime = (s_prime_sq - 1.0) / (1.0 + s_prime_sq)**2\n\n    term_in_sqrt = 1.0 + s_prime_sq * (1.0 - eta_sq)\n    sqrt_term = np.sqrt(term_in_sqrt)\n    g = params.eta - sqrt_term\n    \n    g_prime = np.zeros_like(s_prime_i)\n    # Avoid division by zero when s_prime_i is 0\n    nonzero_s_prime = s_prime_i != 0\n    g_prime[nonzero_s_prime] = -s_prime_i[nonzero_s_prime] * (1.0 - eta_sq) / sqrt_term[nonzero_s_prime]\n\n    dTx_ds_prime = f_prime * g + f * g_prime\n    dxt_ds_prime = (t_i / Ty**2) * dTx_ds_prime\n    \n    grad_p0 = np.sum(x_t_bar * dxt_ds)\n    grad_p2 = np.sum(x_t_bar * (dxt_ds * x_i**2 + dxt_ds_prime * 2.0 * x_i))\n    \n    return np.array([grad_p0, grad_p2])\n\ndef compute_fd_gradient(p_vec, params):\n    \"\"\"Computes the gradient using central finite differences for verification.\"\"\"\n    grad_fd = np.zeros_like(p_vec, dtype=float)\n    for i in range(len(p_vec)):\n        p_plus = p_vec.copy()\n        p_minus = p_vec.copy()\n        p_plus[i] += params.delta_p[i]\n        p_minus[i] -= params.delta_p[i]\n        \n        J_plus, _ = compute_objective_and_intermediates(p_plus, params)\n        J_minus, _ = compute_objective_and_intermediates(p_minus, params)\n        \n        grad_fd[i] = (J_plus - J_minus) / (2.0 * params.delta_p[i])\n        \n    return grad_fd\n    \ndef solve():\n    \"\"\"Main function to run test cases and print results.\"\"\"\n    test_cases = [\n        (1.0, 1.5, 0.02, 201, 0.20, 0.002, 0.010, 1.0, 0.0, 50.0, 0.04, 801, 1e-6, 1e-6),\n        (1.0, 1.2, 0.02, 201, 0.20, 0.002, 0.010, 1.0, 0.0, 0.0, 0.04, 801, 1e-6, 1e-6),\n        (1.0, 1.7, 0.015, 301, 0.15, 0.001, 0.008, 1.0, 0.0, 300.0, 0.03, 601, 1e-6, 1e-6)\n    ]\n    \n    results = []\n    \n    for case in test_cases:\n        params = SimulationParameters(*case)\n        \n        grad_adj = compute_adjoint_gradient(params.p_vec, params)\n        grad_fd = compute_fd_gradient(params.p_vec, params)\n        \n        denominator = np.maximum(np.abs(grad_fd), 1e-12)\n        rel_errors = np.abs(grad_adj - grad_fd) / denominator\n        \n        results.append(rel_errors.tolist())\n\n    print(str(results))\n\nsolve()\n```", "id": "3311421"}, {"introduction": "Geometrical optics also provides a powerful lens for understanding some of the most advanced concepts in physics, such as invisibility cloaking. This exercise explores the fascinating field of Transformation Optics, where complex materials are designed by warping spacetime coordinates. You will discover that the seemingly complicated task of tracing a ray through a cloaking device becomes a simple matter of mapping straight lines in a virtual space, providing a tangible and computationally accessible way to grasp the profound principles behind these exotic optical structures [@problem_id:3311384].", "problem": "Let a planar, static Transformation Optics (TO) cloak be specified by a coordinate map from physical coordinates to virtual free-space coordinates $\\mathbf{x} \\mapsto \\mathbf{x}'$ that is radially symmetric in two spatial dimensions. The cloak occupies the annulus between an inner radius $a$ and an outer radius $b$ (with $0  a  b$) centered at the origin, and the mapping is defined as\n$$\n\\mathbf{x}'=\n\\begin{cases}\n\\mathbf{x},  \\|\\mathbf{x}\\| \\ge b,\\\\\n\\dfrac{b}{b-a}\\left(\\|\\mathbf{x}\\|-a\\right)\\dfrac{\\mathbf{x}}{\\|\\mathbf{x}\\|},  a \\le \\|\\mathbf{x}\\| \\le b,\n\\end{cases}\n$$\nwhile the time coordinate is unchanged. The inverse map from virtual free-space coordinates $\\mathbf{x}'$ back to physical coordinates $\\mathbf{x}$ is\n$$\n\\mathbf{x}=\n\\begin{cases}\n\\mathbf{x}',  \\|\\mathbf{x}'\\| \\ge b,\\\\\n\\left(a+\\dfrac{b-a}{b}\\|\\mathbf{x}'\\|\\right)\\dfrac{\\mathbf{x}'}{\\|\\mathbf{x}'\\|},  0  \\|\\mathbf{x}'\\| \\le b,\\\\\n\\text{any point on the circle of radius }a,  \\mathbf{x}' = \\mathbf{0}.\n\\end{cases}\n$$\nUnder this mapping, the induced material tensors are impedance matched and the rays in the physical cloak follow the images of straight rays in the virtual space. The invariance of the time coordinate implies that the travel time in the physical cloak equals the Euclidean path length in the virtual space divided by the speed of light in vacuum.\n\nStarting from the geometric-optics limit of Maxwell's equations and Fermat's principle, one must construct and track rays by sampling points along straight-line trajectories in the virtual space and mapping them back to physical space. For each ray, verify that the mapped physical trajectory circumvents the cloaked disk $\\|\\mathbf{x}\\|  a$ and compute the induced time delay relative to straight propagation in free space between the same endpoints.\n\nUse the following physically consistent constants and parameters and express all distances in meters and all times in seconds:\n- Speed of light $c=299{,}792{,}458\\,\\mathrm{m/s}$.\n- Cloak inner radius $a=0.5\\,\\mathrm{m}$ and outer radius $b=1.0\\,\\mathrm{m}$.\n- Number of path samples $N=20{,}001$ uniformly spaced along the virtual straight line segment.\n\nDefine the test suite of four rays by the start point $\\mathbf{x}_s=(-2.0\\,\\mathrm{m},\\,y_0)$ and the end point $\\mathbf{x}_e=(2.0\\,\\mathrm{m},\\,y_0)$ for the following values of $y_0$:\n- Case $1$ (centerline crossing): $y_0=0.0\\,\\mathrm{m}$.\n- Case $2$ (happy path within cloak): $y_0=0.25\\,\\mathrm{m}$.\n- Case $3$ (near-grazing of outer boundary): $y_0=0.99\\,\\mathrm{m}$.\n- Case $4$ (completely outside cloak): $y_0=1.50\\,\\mathrm{m}$.\n\nFor each case, perform the following computations:\n- Construct the virtual straight path $\\mathbf{x}'(t) = \\mathbf{x}_s + t(\\mathbf{x}_e - \\mathbf{x}_s)$ for $t \\in [0,1]$ sampled at $N$ points, map it back to physical space via the inverse map, and compute the minimal physical radius $r_{\\min} = \\min_t \\|\\mathbf{x}(t)\\|$.\n- Verify circumvention by evaluating the boolean $\\text{circumvent} = (r_{\\min} \\ge a - \\varepsilon)$ with tolerance $\\varepsilon = 10^{-9} \\, \\mathrm{m}$.\n- Compute the travel time through the cloak $t_{\\mathrm{cloak}}$ as the Euclidean length of the virtual path divided by $c$, i.e., $t_{\\text{cloak}} = \\frac{L'}{c}$ where $L' = \\sum_{i=1}^{N-1} \\|\\mathbf{x}'_{i+1} - \\mathbf{x}'_i\\|$.\n- Compute the free-space baseline time $t_{\\text{free}} = \\frac{\\|\\mathbf{x}_e - \\mathbf{x}_s\\|}{c}$.\n- Report the induced time delay $\\Delta t = t_{\\text{cloak}} - t_{\\text{free}}$ in seconds.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each result is the list $[\\text{circumvent},\\Delta t]$ for one test case, in the order of the cases above. For example, the output format must be\n$$\n[[\\text{circumvent}_1, \\Delta t_1],[\\text{circumvent}_2, \\Delta t_2],[\\text{circumvent}_3, \\Delta t_3],[\\text{circumvent}_4, \\Delta t_4]].\n$$\nAngles are not used in this problem, so no angle unit is required. All computed times must be in seconds. The expected qualitative behavior is that all rays circumvent the cloaked disk and the ideal cloak introduces zero time delay, up to numerical error.", "solution": "The geometric-optics limit of Maxwell's equations yields the eikonal equation for the phase function $\\Phi(\\mathbf{x})$, with rays given by the gradient direction of $\\Phi$ and satisfying Fermat's principle that the optical path length is stationary. In Transformation Optics (TO), one uses a smooth, invertible coordinate mapping $\\mathbf{x} \\mapsto \\mathbf{x}'$ that transforms the free-space Maxwell equations into those in a physical anisotropic medium with constitutive tensors related to the Jacobian of the mapping. When the time coordinate is unchanged and the medium is impedance matched, rays in the physical medium are exactly the images of straight rays in the virtual free space, and the coordinate time experienced by the ray equals the Euclidean arclength in the virtual space divided by the vacuum speed of light.\n\nLet the cloak be the annulus $a \\le \\|\\mathbf{x}\\| \\le b$ with the radial map $\\mathbf{x} \\mapsto \\mathbf{x}'$ defined by the piecewise relation\n$$\n\\mathbf{x}'=\n\\begin{cases}\n\\mathbf{x},  \\|\\mathbf{x}\\| \\ge b,\\\\\n\\dfrac{b}{b-a}\\left(\\|\\mathbf{x}\\|-a\\right)\\dfrac{\\mathbf{x}}{\\|\\mathbf{x}\\|},  a \\le \\|\\mathbf{x}\\| \\le b,\n\\end{cases}\n$$\nand the inverse map\n$$\n\\mathbf{x}=\n\\begin{cases}\n\\mathbf{x}',  \\|\\mathbf{x}'\\| \\ge b,\\\\\n\\left(a+\\dfrac{b-a}{b}\\|\\mathbf{x}'\\|\\right)\\dfrac{\\mathbf{x}'}{\\|\\mathbf{x}'\\|},  0  \\|\\mathbf{x}'\\| \\le b,\\\\\n\\text{any point on the circle of radius }a,  \\mathbf{x}' = \\mathbf{0}.\n\\end{cases}\n$$\nDenote the Jacobian of the forward mapping by $\\mathbf{J}=\\partial \\mathbf{x}'/\\partial \\mathbf{x}$. In TO, the metric induced in physical space is $\\mathbf{g}=\\mathbf{J}^\\top\\mathbf{J}$ and null geodesics of the optical metric correspond to straight lines in the virtual coordinates $\\mathbf{x}'$. Since the time coordinate is unchanged, the ray travel time is\n$$\nt_{\\text{cloak}} = \\frac{1}{c}\\int \\sqrt{d\\mathbf{x}' \\cdot d\\mathbf{x}'} = \\frac{L'}{c},\n$$\nwhere $L'$ is the Euclidean length of the ray in virtual space and $c$ is the vacuum speed of light. For a straight-line segment between endpoints $\\mathbf{x}_s$ and $\\mathbf{x}_e$, $L'$ equals the Euclidean distance $\\|\\mathbf{x}_e-\\mathbf{x}_s\\|$, hence\n$$\nt_{\\text{cloak}} = \\frac{\\|\\mathbf{x}_e - \\mathbf{x}_s\\|}{c} = t_{\\text{free}},\n$$\nso the ideal cloak introduces zero time delay:\n$$\n\\Delta t = t_{\\text{cloak}} - t_{\\text{free}} = 0.\n$$\nTo verify circumvention, consider the mapping of the minimal virtual radius along a straight path. For the horizontal line $\\mathbf{x}'(t)=\\mathbf{x}_s+t(\\mathbf{x}_e-\\mathbf{x}_s)$ with $\\mathbf{x}_s=(-2.0\\,\\mathrm{m},\\,y_0)$ and $\\mathbf{x}_e=(2.0\\,\\mathrm{m},\\,y_0)$, the minimal virtual radius is $r'_{\\min} = |y_0|$. The inverse map yields the minimal physical radius\n$$\nr_{\\min} = a + \\frac{b-a}{b}r'_{\\min} \\ge a,\n$$\nwith equality at $y_0=0$ and strict inequality for $y_0 > 0$. Therefore every mapped ray circumvents the disk $\\|\\mathbf{x}\\|  a$.\n\nAlgorithmically, we discretize the virtual straight path with $N$ samples to obtain points $\\{\\mathbf{x}'_i\\}_{i=1}^N$, then map each point back to physical space using the inverse map. The special case $\\mathbf{x}' = \\mathbf{0}$ is handled by assigning any point on the circle $\\|\\mathbf{x}\\| = a$, which suffices for verifying the minimal radius and does not affect the travel time because $t_{\\mathrm{cloak}}$ is computed in virtual space. We compute:\n- The minimal physical radius $r_{\\min} = \\min_i \\|\\mathbf{x}_i\\|$ and the boolean $\\text{circumvent} = (r_{\\min} \\ge a - \\varepsilon)$ with $\\varepsilon = 10^{-9} \\, \\mathrm{m}$.\n- The virtual path length $L' = \\sum_{i=1}^{N-1} \\|\\mathbf{x}'_{i+1} - \\mathbf{x}'_i\\|$, hence $t_{\\mathrm{cloak}}=L'/c$.\n- The free-space baseline time $t_{\\text{free}} = \\|\\mathbf{x}_e - \\mathbf{x}_s\\|/c$.\n- The time delay $\\Delta t = t_{\\text{cloak}} - t_{\\text{free}}$, which is theoretically $0$ for an ideal cloak but may be numerically nonzero at the level of discretization error.\n\nFor the test suite with $a=0.5\\,\\mathrm{m}$, $b=1.0\\,\\mathrm{m}$, $c=299{,}792{,}458\\,\\mathrm{m/s}$, $N=20{,}001$, and $y_0\\in\\{0.0\\,\\mathrm{m},\\,0.25\\,\\mathrm{m},\\,0.99\\,\\mathrm{m},\\,1.50\\,\\mathrm{m}\\}$, all cases satisfy $\\text{circumvent}=\\text{True}$ and $\\Delta t \\approx 0$ in seconds. The program implements these steps and outputs the required single-line format containing, for each case, the boolean and the float time delay in seconds.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef virtual_to_physical_point(xp: np.ndarray, a: float, b: float, fallback_dir: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Map a single virtual point xp (R^2) to physical space according to the inverse cloak map.\n    xp: virtual point (2D)\n    a, b: inner and outer radii\n    fallback_dir: unit direction to use if xp is at the origin (undefined angle)\n    \"\"\"\n    rprime = np.linalg.norm(xp)\n    if rprime >= b:\n        return xp.copy()\n    elif rprime > 1e-15:\n        r = a + (b - a) * (rprime / b)\n        return (r / rprime) * xp\n    else:\n        # xp == 0: map to circle of radius a along fallback_dir\n        return a * fallback_dir\n\ndef map_virtual_path_to_physical(xs: np.ndarray, xe: np.ndarray, a: float, b: float, N: int) -> (np.ndarray, np.ndarray):\n    \"\"\"\n    Construct the virtual straight path from xs to xe sampled at N points, and map to physical space.\n    Returns (virtual_points[N,2], physical_points[N,2]).\n    \"\"\"\n    t = np.linspace(0.0, 1.0, N)\n    virtual_points = xs[None, :] + t[:, None] * (xe - xs)[None, :]\n    # Fallback direction: use the overall direction of the path (unit vector)\n    path_dir = xe - xs\n    norm_dir = np.linalg.norm(path_dir)\n    if norm_dir  1e-15:\n        fallback_dir = np.array([1.0, 0.0])\n    else:\n        fallback_dir = path_dir / norm_dir\n\n    physical_points = np.empty_like(virtual_points)\n    for i in range(N):\n        physical_points[i, :] = virtual_to_physical_point(virtual_points[i, :], a, b, fallback_dir)\n\n    return virtual_points, physical_points\n\ndef compute_virtual_length(virtual_points: np.ndarray) -> float:\n    \"\"\"Compute the Euclidean length of a polyline given by virtual_points (N, 2).\"\"\"\n    diffs = np.diff(virtual_points, axis=0)\n    seg_lengths = np.linalg.norm(diffs, axis=1)\n    return float(np.sum(seg_lengths))\n\ndef solve():\n    # Constants and parameters\n    c = 299_792_458.0  # m/s\n    a = 0.5  # m\n    b = 1.0  # m\n    N = 20001\n    eps_tol = 1e-9  # m\n\n    # Test cases: start and end points for different y0\n    y_values = [0.0, 0.25, 0.99, 1.50]\n    test_cases = []\n    for y0 in y_values:\n        xs = np.array([-2.0, y0], dtype=float)\n        xe = np.array([ 2.0, y0], dtype=float)\n        test_cases.append((xs, xe))\n\n    results = []\n    for xs, xe in test_cases:\n        # Construct virtual straight path and map to physical\n        vpath, ppath = map_virtual_path_to_physical(xs, xe, a, b, N)\n\n        # Minimal physical radius along the path\n        radii = np.linalg.norm(ppath, axis=1)\n        rmin = float(np.min(radii))\n        circumvent = (rmin >= (a - eps_tol))\n\n        # Travel times\n        L_virtual = compute_virtual_length(vpath)\n        t_cloak = L_virtual / c\n        L_free = np.linalg.norm(xe - xs)\n        t_free = L_free / c\n\n        delta_t = t_cloak - t_free  # seconds\n\n        results.append([circumvent, delta_t])\n\n    # Final print statement in the exact required format.\n    # Convert to string with Python's default formatting.\n    # Ensuring single-line output.\n    print(f\"[[{results[0][0]},{results[0][1]}],[{results[1][0]},{results[1][1]}],[{results[2][0]},{results[2][1]}],[{results[3][0]},{results[3][1]}]]\")\n\nsolve()\n```", "id": "3311384"}]}