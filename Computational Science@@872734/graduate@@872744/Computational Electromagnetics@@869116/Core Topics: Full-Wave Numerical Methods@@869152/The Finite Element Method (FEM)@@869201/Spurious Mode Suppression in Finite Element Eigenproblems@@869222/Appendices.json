{"hands_on_practices": [{"introduction": "To effectively address a complex numerical issue, it is often invaluable to first distill its essence into a simpler, more transparent model. This practice guides you through the construction of a one-dimensional toy model that clearly exposes the root cause of spurious modes in Maxwell's eigenproblems [@problem_id:3350389]. By observing how standard nodal elements fail to correctly represent the gradient fields in the kernel of the curl operator, you will gain a fundamental intuition for why certain discretizations are doomed to fail and why specialized elements are necessary.", "problem": "Consider the time-harmonic, source-free Maxwell eigenproblem in a perfectly electrically conducting (PEC) cavity, written in variational form: find an electric field $\\mathbf{E} \\in H(\\mathrm{curl},\\Omega)$ and a wavenumber $\\kappa^{2} \\in \\mathbb{R}$ such that\n$$\n\\int_{\\Omega} \\mu^{-1} \\, (\\nabla \\times \\mathbf{E}) \\cdot (\\nabla \\times \\mathbf{v}) \\, \\mathrm{d}\\mathbf{x} \\;=\\; \\kappa^{2} \\int_{\\Omega} \\epsilon \\, \\mathbf{E}\\cdot \\mathbf{v} \\, \\mathrm{d}\\mathbf{x}\n\\quad \\text{for all } \\mathbf{v} \\in H(\\mathrm{curl},\\Omega),\n$$\nwith PEC boundary condition $\\,\\mathbf{n}\\times \\mathbf{E} = \\mathbf{0}$ on $\\partial \\Omega$. It is a fundamental fact that the kernel of the curl operator contains all gradients $\\,\\nabla \\phi\\,$ with $\\phi \\in H^{1}_{0}(\\Omega)$, because $\\,\\nabla \\times \\nabla \\phi = \\mathbf{0}$. This nullspace is the root cause of spurious modes when inappropriate finite element spaces are used.\n\nTo expose the mechanism in the simplest setting, construct a one-dimensional ($1$D) toy model on the interval $(0,L)$ that mimics the separation between Transverse Electric (TE) and Transverse Magnetic (TM) families. Model TE with a scalar field $u \\in H^{1}_{0}(0,L)$ and the eigenproblem\n$$\n\\int_{0}^{L} u'(x) \\, v'(x) \\, \\mathrm{d}x \\;=\\; \\lambda \\int_{0}^{L} u(x) \\, v(x) \\, \\mathrm{d}x \\quad \\text{for all } v \\in H^{1}_{0}(0,L),\n$$\nand model the TM gradient subspace by a surrogate scalar field $w \\in H^{1}(0,L)$ that is intended to represent the (illegally) nodal approximation of a field in $H(\\mathrm{curl},\\Omega)$, together with the bilinear form\n$$\na(w,v) \\;=\\; \\int_{0}^{L} \\big(\\mathrm{curl}\\, w\\big)\\,\\big(\\mathrm{curl}\\, v\\big)\\,\\mathrm{d}x,\n$$\nwhere in $1$D we set $\\mathrm{curl}\\, w \\equiv 0$ to mimic the exact vanishing of $\\nabla \\times \\nabla \\phi$ for all scalar potentials $\\phi$ in higher dimensions. Let $V_{h}$ be the space of continuous, piecewise-linear (linear Lagrange) functions on a uniform partition of $(0,L)$ into $n$ subintervals, with no essential boundary conditions imposed, so that $\\dim V_{h} = n+1$.\n\nYou will:\n- Derive, from the above variational bases and from Maxwell’s equations, why the discrete TM surrogate bilinear form vanishes identically on $V_{h}$, turning the generalized eigenproblem into a pure mass-matrix pencil.\n- Show that adding a single mean-zero gauge constraint $\\int_{0}^{L} w_{h}(x)\\,\\mathrm{d}x = 0$ removes exactly one dimension from $V_{h}$ but does not change the fact that all remaining discrete eigenpairs satisfy $\\lambda = 0$, thereby explicitly characterizing the spurious eigenspace.\n- Explain, at a conceptual level, how in higher dimensions the use of edge elements (for example, first-kind Nédélec elements) satisfies a discrete compactness property that prevents gradient fields from polluting the positive spectrum, while nodal elements do not.\n- Propose at least two simple, scientifically sound test fixtures that a practitioner could implement to detect and quantify spurious modes in computational electromagnetics using the Finite Element Method (FEM). Your proposals should be consistent with the above derivation and should isolate the mechanism of spurious mode generation or suppression.\n\nFinally, take $n = 5$ and compute the exact number of spurious zero-eigenvalue modes produced by the mis-discretized TM surrogate on $V_{h}$ after enforcing the single mean-zero gauge constraint. Provide your final answer as a single integer. No rounding is required and no physical units are needed.", "solution": "The problem statement is a valid exercise in computational electromagnetics, specifically concerning the numerical pathology of spurious modes in finite element eigenvalue analysis. It is scientifically grounded, well-posed, objective, and internally consistent. It uses a standard pedagogical one-dimensional ($1$D) model to illustrate a complex phenomenon that occurs in higher dimensions. All terms are defined adequately for the successful completion of the task. We may therefore proceed with a full solution.\n\nThe analysis is structured into four parts as requested, followed by the final numerical calculation.\n\n### Part 1: Vanishing Bilinear Form and Consequent Eigenproblem\n\nThe problem defines a surrogate model for Transverse Magnetic (TM) modes using a scalar field $w$ and a bilinear form $a(w,v)$. The finite element space for this model is $V_{h}$, the space of continuous, piecewise-linear Lagrange functions on a partition of the interval $(0,L)$ into $n$ subintervals, with no essential boundary conditions imposed. The dimension of this space, corresponding to the number of nodes, is $\\dim V_{h} = n+1$.\n\nThe crucial definition for this $1$D toy model is the action of the `curl` operator on a scalar field $w$, which is given as:\n$$\n\\mathrm{curl}\\, w \\equiv 0\n$$\nThis definition is a direct analogue to the vector calculus identity $\\nabla \\times (\\nabla \\phi) = \\mathbf{0}$, where the scalar field $w$ in the $1$D model plays the role of the scalar potential $\\phi$ in three dimensions. The nodal basis functions in $V_h$ are intended to mimic an invalid choice of nodal elements for a vector field in $H(\\mathrm{curl},\\Omega)$, which inadvertently contains this gradient subspace.\n\nThe bilinear form for the TM surrogate is:\n$$\na(w,v) = \\int_{0}^{L} \\big(\\mathrm{curl}\\, w\\big)\\,\\big(\\mathrm{curl}\\, v\\big)\\,\\mathrm{d}x\n$$\nFor any two functions $w_h, v_h \\in V_h$, according to the given definition, we have $\\mathrm{curl}\\, w_h = 0$ and $\\mathrm{curl}\\, v_h = 0$. Consequently, the integrand is identically zero:\n$$\n\\big(\\mathrm{curl}\\, w_h(x)\\big)\\,\\big(\\mathrm{curl}\\, v_h(x)\\big) = 0 \\cdot 0 = 0 \\quad \\text{for all } x \\in (0,L)\n$$\nTherefore, the bilinear form vanishes for all functions in the chosen discrete space:\n$$\na(w_h, v_h) = \\int_{0}^{L} 0 \\,\\mathrm{d}x = 0 \\quad \\text{for all } w_h, v_h \\in V_h\n$$\nThe corresponding generalized eigenvalue problem is to find $(\\lambda, w_h) \\in (\\mathbb{R}, V_h)$ such that for all $v_h \\in V_h$:\n$$\na(w_h, v_h) = \\lambda \\int_{0}^{L} w_h(x) v_h(x) \\,\\mathrm{d}x\n$$\nSubstituting the result that $a(w_h, v_h)=0$, the equation becomes:\n$$\n0 = \\lambda \\int_{0}^{L} w_h(x) v_h(x) \\,\\mathrm{d}x\n$$\nIn a finite element context, this is written as a matrix eigenproblem $\\mathbf{K}\\mathbf{c} = \\lambda \\mathbf{M}\\mathbf{c}$. The stiffness matrix $\\mathbf{K}$ has entries $K_{ij} = a(\\phi_i, \\phi_j)$, where $\\{\\phi_i\\}$ is the basis for $V_h$. From our derivation, $\\mathbf{K}$ is the zero matrix. The mass matrix $\\mathbf{M}$ has entries $M_{ij} = \\int_{0}^{L} \\phi_i \\phi_j \\,\\mathrm{d}x$. Since the basis functions $\\{\\phi_i\\}$ are linearly independent, the mass matrix $\\mathbf{M}$ is symmetric positive definite.\n\nThe eigenproblem $0 = \\lambda \\mathbf{M}\\mathbf{c}$ implies that for any non-zero eigenvector $\\mathbf{c}$, we must have $\\lambda = 0$. Since this holds for any vector in the $(n+1)$-dimensional space, the entire space $V_h$ is an eigenspace corresponding to the eigenvalue $\\lambda=0$. This means the discretization produces $\\dim(V_h) = n+1$ spurious modes, all with eigenvalue zero.\n\n### Part 2: Effect of the Mean-Zero Gauge Constraint\n\nA gauge constraint is introduced:\n$$\n\\int_{0}^{L} w_{h}(x)\\,\\mathrm{d}x = 0\n$$\nLet us define a new space $V_h^0 = \\{w_h \\in V_h \\mid \\int_{0}^{L} w_{h}(x)\\,\\mathrm{d}x = 0\\}$. Any function $w_h \\in V_h$ can be expressed as a linear combination of the basis functions $\\phi_i$ for $i=0, 1, \\dots, n$: $w_h(x) = \\sum_{i=0}^{n} c_i \\phi_i(x)$. The constraint becomes a single linear equation on the coefficients $c_i$:\n$$\n\\sum_{i=0}^{n} c_i \\left( \\int_{0}^{L} \\phi_i(x)\\,\\mathrm{d}x \\right) = 0\n$$\nSince the standard Lagrange \"hat\" basis functions are non-negative and not identically zero, their integrals are positive. This is a non-trivial linear constraint on the $(n+1)$-dimensional space of coefficients. A single linear constraint reduces the dimension of a vector space by exactly one. Therefore, the dimension of the constrained space is:\n$$\n\\dim(V_h^0) = \\dim(V_h) - 1 = (n+1) - 1 = n\n$$\nThe eigenvalue problem is now posed on this smaller space: find $(\\lambda, w_h) \\in (\\mathbb{R}, V_h^0)$ such that $a(w_h, v_h) = \\lambda \\int_0^L w_h v_h \\,dx$ for all $v_h \\in V_h^0$.\nThe fundamental property that $a(w_h, v_h) = 0$ is unaffected by the integral constraint on the functions. It remains true for all functions in $V_h^0 \\subset V_h$. Thus, the eigenproblem on the constrained space is still\n$$\n0 = \\lambda \\int_{0}^{L} w_h(x) v_h(x) \\,\\mathrm{d}x\n$$\nfor all $v_h \\in V_h^0$. For any non-zero eigenfunction $w_h \\in V_h^0$, the eigenvalue $\\lambda$ must be zero. The entire $n$-dimensional space $V_h^0$ is the eigenspace for $\\lambda=0$. The constraint removes one spurious mode, but $n$ spurious modes remain. This explicitly characterizes the spurious eigenspace as the space of mean-zero, continuous, piecewise-linear functions, which has dimension $n$.\n\n### Part 3: Spurious Mode Suppression by Edge Elements\n\nIn higher dimensions ($2$D and $3$D), the root of the problem is the failure of certain finite element spaces to correctly represent the nullspace of the curl operator. The space of square-integrable vector fields with square-integrable curls is denoted $H(\\mathrm{curl},\\Omega)$. The nullspace of the curl operator in the continuous setting is precisely the set of gradient fields: $\\{\\mathbf{u} \\in L^2(\\Omega) \\mid \\nabla \\times \\mathbf{u} = \\mathbf{0}\\} = \\{\\nabla \\phi \\mid \\phi \\in H^1(\\Omega)\\}$.\n\nWhen **nodal elements** are used to discretize a vector field $\\mathbf{E}$, one typically assigns vector-valued degrees of freedom to the nodes of the mesh. The resulting finite element space, let's call it $\\mathbf{V}_h^{\\text{nodal}}$, contains a large subspace of discrete gradients, i.e., fields of the form $\\nabla \\phi_h$ where $\\phi_h$ is a standard scalar (e.g., Lagrange) finite element function. However, for a general $\\mathbf{v}_h \\in \\mathbf{V}_h^{\\text{nodal}}$, the property $\\nabla \\times (\\nabla \\phi_h) = \\mathbf{0}$ is not preserved at the discrete level, meaning the discrete curl of a discrete gradient is not necessarily zero. The stiffness matrix $\\mathbf{K}$ with entries $K_{ij} = \\int_{\\Omega} (\\nabla \\times \\mathbf{v}_i) \\cdot (\\nabla \\times \\mathbf{v}_j) \\,d\\mathbf{x}$ acquires a large, numerically-approximated nullspace that does not accurately correspond to the true analytical nullspace. This mismatch pollutes the computed spectrum with non-physical, spurious modes.\n\n**Edge elements** (e.g., first-kind Nédélec elements) are specifically designed to avoid this problem. Their degrees of freedom are not nodal values, but rather the tangential components of the vector field along the edges of the mesh elements. This construction ensures that the tangential component of the field is continuous across element interfaces, which is exactly the continuity requirement for fields in $H(\\mathrm{curl},\\Omega)$. The resulting finite element space, let's call it $\\mathbf{V}_h^{\\text{edge}}$, possesses a critical property, often represented by a commuting diagram. This property, fundamental to Finite Element Exterior Calculus (FEEC), ensures that the discrete curl of a discrete gradient is exactly zero. That is, if one takes a scalar Lagrange space $S_h$ and the Nédélec edge space $\\mathbf{V}_h^{\\text{edge}}$, then:\n$$\n\\nabla \\times (\\nabla \\phi_h) = \\mathbf{0} \\quad \\text{for all } \\phi_h \\in S_h\n$$\nThis means that the discrete curl nullspace within $\\mathbf{V}_h^{\\text{edge}}$ is precisely the space of discrete gradients $\\{\\nabla\\phi_h \\mid \\phi_h \\in S_h\\}$. This property, often referred to as constructing a stable and conforming cochain complex, ensures that the kernel of the discrete stiffness operator is cleanly separated from the rest of the operator's spectrum. The \"discrete compactness property\" associated with these elements guarantees that the approximation of the non-zero part of the spectrum is convergent and free of spurious modes. The zero-eigenvalue modes corresponding to the gradient fields are correctly captured and do not contaminate the physically meaningful, positive eigenvalues.\n\n### Part 4: Proposed Test Fixtures\n\nHere are two scientifically sound test fixtures to detect and quantify spurious modes in a finite element code for computational electromagnetics.\n\n**1. The Canonical Cavity Resonance Test**\n- **Principle**: This test compares numerical results against a known analytical solution. The rectangular (or cuboid) cavity with Perfectly Electrically Conducting (PEC) walls is an ideal candidate as its resonant frequencies and mode structures (TE and TM) are known exactly.\n- **Implementation**:\n    1.  Model a 2D rectangular cavity of size $a \\times b$ or a 3D cuboid cavity of size $a \\times b \\times c$. Apply PEC boundary conditions ($\\mathbf{n} \\times \\mathbf{E} = \\mathbf{0}$) on all walls.\n    2.  Use the FEM code to compute the lowest, e.g., $20-50$, eigenpairs $(\\kappa_i^2, \\mathbf{E}_i)$.\n    3.  Analytically, the eigenvalues are given by $\\kappa^2_{mnp} = (\\frac{m\\pi}{a})^2 + (\\frac{n\\pi}{b})^2 + (\\frac{p\\pi}{c})^2$, where $m,n,p$ are integers defining the mode order (with appropriate restrictions for TE/TM families).\n- **Detection and Quantification**: Spurious modes are identified in two ways:\n    a.  **Spectrum Pollution**: The computed list of eigenvalues will contain values that do not match any of the analytical $\\kappa^2_{mnp}$ values. These are spurious.\n    b.  **Nullspace Dimension**: A well-behaved discretization (like with edge elements) will produce a cluster of zero eigenvalues corresponding to the gradient fields, cleanly separated from the positive physical eigenvalues. An improper discretization (like with nodal elements) will produce a much larger number of zero or near-zero eigenvalues. The number of such modes can be counted and compared against the theoretical dimension of the discrete gradient space, which for nodal elements is roughly the number of interior mesh nodes.\n\n**2. The Divergence-Check Test**\n- **Principle**: This test leverages a physical property of the eigenmodes. In a source-free region ($\\rho=0$), Maxwell's equations require physical electric field modes to be divergence-free: $\\nabla \\cdot (\\epsilon \\mathbf{E}) = 0$. Spurious modes arising from the incorrect handling of the gradient nullspace often violate this condition significantly.\n- **Implementation**:\n    1.  Solve the eigenproblem for any reasonable cavity geometry (the canonical cavity from Test 1 is suitable).\n    2.  For each computed eigenmode $\\mathbf{E}_i$, calculate the $L^2$-norm of its divergence: $D_i = ||\\nabla \\cdot \\mathbf{E}_i||_{L^2} = (\\int_{\\Omega} |\\nabla \\cdot \\mathbf{E}_i|^2 \\,d\\mathbf{x})^{1/2}$. Note that the divergence should be calculated element-wise, as fields in $H(\\mathrm{curl})$ do not necessarily have globally defined, square-integrable divergence.\n    3.  Plot the computed eigenvalues $\\kappa_i^2$ versus their corresponding divergence norm $D_i$.\n- **Detection and Quantification**: The resulting scatter plot will typically show two distinct populations:\n    a.  **Physical Modes**: These will appear as points with positive eigenvalues $(\\kappa_i^2  0)$ and very small divergence norms $(D_i \\approx 0)$.\n    b.  **Spurious Modes**: These will appear as points with large divergence norms $(D_i \\gg 0)$. Their corresponding eigenvalues may be zero or non-zero, polluting the entire spectrum.\n    A practitioner can set a divergence threshold to programmatically identify and count spurious modes, thereby quantifying the quality of the solver and discretization choice.\n\n### Final Calculation\n\nThe problem asks for the number of spurious, zero-eigenvalue modes produced by the mis-discretized TM surrogate on the space $V_h$ after enforcing the single mean-zero gauge constraint, for the specific case where the mesh consists of $n=5$ subintervals.\n\nAs established in Part 2:\n1.  The initial space $V_h$ of continuous, piecewise-linear functions without boundary conditions on a mesh of $n$ elements has a dimension of $n+1$.\n2.  The bilinear form $a(w_h, v_h)$ is identically zero for all functions in this space, meaning every non-zero function is an eigenvector with eigenvalue $\\lambda=0$. The number of spurious modes is initially $n+1$.\n3.  The single gauge constraint $\\int_0^L w_h(x) dx = 0$ is a non-trivial linear constraint that reduces the dimension of the space by $1$.\n4.  The number of remaining spurious modes is the dimension of the constrained space, which is $(n+1) - 1 = n$.\n\nGiven the parameter $n = 5$:\nThe number of spurious zero-eigenvalue modes is $n=5$.", "answer": "$$\\boxed{5}$$", "id": "3350389"}, {"introduction": "One of the most common pragmatic strategies for suppressing spurious modes is the penalty method, which adds a term to the variational formulation to penalize non-physical divergence. This exercise provides a hands-on exploration of the crucial trade-offs involved by using a simplified but conceptually powerful block-matrix model [@problem_id:3350403]. You will implement this model to quantify how the penalty parameter $\\alpha$ perturbs the true physical spectrum and test a physically-motivated scaling law designed to optimize its performance.", "problem": "Consider the source-free frequency-domain Maxwell eigenproblem in a bounded domain with perfectly conducting boundary conditions, stated in terms of the electric field as follows: find the nontrivial field $\\mathbf{E}$ and frequency $\\omega$ such that\n$$\n\\nabla \\times \\left(\\mu^{-1} \\nabla \\times \\mathbf{E}\\right) = \\omega^2 \\, \\epsilon \\, \\mathbf{E}, \\quad \\text{with} \\quad \\nabla \\cdot (\\epsilon \\mathbf{E}) = 0,\n$$\nwhere $\\epsilon$ is the permittivity and $\\mu$ is the permeability. In finite element discretizations that do not exactly enforce the divergence-free constraint $\\nabla \\cdot (\\epsilon \\mathbf{E})=0$, spurious modes contaminate the spectrum unless the constraint is either enforced exactly (e.g., via Lagrange multipliers or projection onto the divergence-free subspace) or weakly enforced via a penalty term added to the bilinear form:\n$$\na_{\\alpha}(\\mathbf{E}_h, \\mathbf{v}_h) = \\int_{\\Omega} \\mu^{-1} \\left(\\nabla \\times \\mathbf{E}_h\\right)\\cdot\\left(\\nabla \\times \\mathbf{v}_h\\right) \\, d\\Omega + \\alpha \\int_{\\Omega} \\left(\\nabla \\cdot (\\epsilon \\mathbf{E}_h)\\right)\\left(\\nabla \\cdot (\\epsilon \\mathbf{v}_h)\\right) \\, d\\Omega,\n$$\nwhere $\\alpha0$ is the penalty strength and $\\mathbf{E}_h, \\mathbf{v}_h$ are finite element trial and test fields. The penalty modifies the discrete operator and perturbs the true eigenvalues. A central advanced question is to quantify the perturbation of the true eigenvalues as a function of $\\alpha$, mesh size $h$, and polynomial degree $p$, and to propose and test an $h$–$p$ scaling law for $\\alpha$ that asymptotically suppresses spurious modes while minimizing perturbation of physical eigenvalues.\n\nTo make this question computationally concrete and universally implementable, consider the following principled block-structured discrete model that captures the interaction between the physical (divergence-free) subspace and the spurious (gradient) subspace. Let the discrete field space be decomposed into the direct sum of a physical subspace of dimension $n_{\\mathrm{phys}}$ and a gradient subspace of dimension $n_{\\mathrm{grad}}$. Define the symmetric block operator\n$$\n\\mathbf{A}_{\\alpha}(h,p) = \n\\begin{bmatrix}\n\\mathbf{\\Lambda}  \\beta(h,p)\\,\\mathbf{C} \\\\\n\\beta(h,p)\\,\\mathbf{C}^{\\top}  \\alpha \\mathbf{I}_{n_{\\mathrm{grad}}}\n\\end{bmatrix},\n$$\nwhere:\n- $\\mathbf{\\Lambda} \\in \\mathbb{R}^{n_{\\mathrm{phys}} \\times n_{\\mathrm{phys}}}$ is diagonal with the true physical eigenvalues $\\lambda_1, \\ldots, \\lambda_{n_{\\mathrm{phys}}}$,\n- $\\mathbf{C} \\in \\mathbb{R}^{n_{\\mathrm{phys}} \\times n_{\\mathrm{grad}}}$ models the coupling between physical and spurious components induced by discretization,\n- $\\beta(h,p)$ encodes the magnitude of the physical–spurious coupling as a function of mesh size $h$ and polynomial degree $p$,\n- $\\alpha0$ is the penalty strength, and $\\mathbf{I}_{n_{\\mathrm{grad}}}$ is the identity in the gradient subspace.\n\nIn the case of exact constraint enforcement, the operator reduces to the restriction onto the physical subspace,\n$$\n\\mathbf{A}_{\\mathrm{exact}} = \\mathbf{\\Lambda},\n$$\nand the eigenvalues are exactly $\\lambda_1,\\ldots,\\lambda_{n_{\\mathrm{phys}}}$. Under penalty enforcement with finite $\\alpha$, the physical eigenvalues are perturbed by the off-diagonal coupling $\\beta(h,p)\\,\\mathbf{C}$.\n\nFor the purposes of this problem, take:\n- $n_{\\mathrm{phys}}=6$ and $n_{\\mathrm{grad}}=4$,\n- $\\mathbf{\\Lambda} = \\mathrm{diag}\\left(\\lambda_1,\\ldots,\\lambda_6\\right)$ with $\\lambda_k = \\pi^2 \\cdot s_k$ and $(s_1,\\ldots,s_6) = (2,5,8,10,13,17)$,\n- $\\mathbf{C}$ equal to the $6\\times 4$ matrix with ones on its first four diagonal entries and zeros elsewhere (i.e., $C_{ii}=1$ for $i=1,2,3,4$, and $0$ otherwise),\n- $\\beta(h,p) = \\frac{h^p}{p}$.\n\nLet $\\lambda_k^{\\alpha}(h,p)$ denote the first $n_{\\mathrm{phys}}$ eigenvalues of $\\mathbf{A}_{\\alpha}(h,p)$ sorted in nondecreasing order, and define the relative perturbation of the true physical eigenvalues due to penalty enforcement by\n$$\n\\delta(h,p,\\alpha) = \\max_{1\\le k\\le n_{\\mathrm{phys}}} \\left| \\frac{\\lambda_k^{\\alpha}(h,p) - \\lambda_k}{\\lambda_k} \\right|.\n$$\n\nTasks:\n1. Implement the above block-structured model operator and compute the perturbed eigenvalues for given $(h,p,\\alpha)$.\n2. Quantify the maximum relative perturbation $\\delta(h,p,\\alpha)$ for each case in the test suite below.\n3. Propose an optimal scaling law $\\alpha_{\\mathrm{opt}}(h,p)$ that suppresses spurious coupling while controlling eigenvalue perturbation. Justify your proposal using first-principles reasoning involving approximation properties and inverse inequalities. Implement your proposed law as $\\alpha_{\\mathrm{opt}}(h,p) = c \\, \\dfrac{p^2}{h^2}$ with $c=1$ and, for each test case, also compute $\\delta\\big(h,p,\\alpha_{\\mathrm{opt}}(h,p)\\big)$.\n\nUse the following test suite of parameter values, which covers representative, boundary, and edge scenarios:\n- Case 1 (happy path, mild mesh, low order, weak penalty): $(h,p,\\alpha) = (0.5,\\,1,\\,0.1)$,\n- Case 2 (moderately refined mesh, moderate order, moderate penalty not following the proposed scaling): $(h,p,\\alpha) = (0.25,\\,2,\\,1.0)$,\n- Case 3 (refined mesh, higher order, strong penalty): $(h,p,\\alpha) = (0.125,\\,3,\\,100.0)$.\n\nYour program should, for each case, compute two floats:\n- the maximum relative perturbation $\\delta(h,p,\\alpha)$ at the given $\\alpha$,\n- the maximum relative perturbation at the proposed scaling $\\delta\\big(h,p,\\alpha_{\\mathrm{opt}}(h,p)\\big)$,\n\nand produce a single line of output containing these six results aggregated in a comma-separated list enclosed in square brackets in the order\n$$\n\\big[\\delta(h_1,p_1,\\alpha_1), \\delta(h_1,p_1,\\alpha_{\\mathrm{opt},1}), \\delta(h_2,p_2,\\alpha_2), \\delta(h_2,p_2,\\alpha_{\\mathrm{opt},2}), \\delta(h_3,p_3,\\alpha_3), \\delta(h_3,p_3,\\alpha_{\\mathrm{opt},3})\\big],\n$$\nwhere $\\alpha_{\\mathrm{opt},i} = \\alpha_{\\mathrm{opt}}(h_i,p_i)$. The final numeric outputs are dimensionless floats. No physical units are required, and no angles or percentages are involved. The program must be complete and runnable as-is, without any external input or files, and must follow the specified output format exactly.", "solution": "The problem presented is a well-posed and scientifically sound inquiry into a fundamental technique used in computational electromagnetics for finite element analysis. It concerns the suppression of non-physical, or \"spurious,\" solutions that arise from the discretization of Maxwell's eigenproblem when the divergence-free constraint on the electric field is not strictly enforced. The proposed penalty method, which adds a term proportional to the squared divergence of the field, is a standard approach to mitigate this issue. The problem provides a simplified but conceptually correct block-matrix model, $\\mathbf{A}_{\\alpha}(h,p)$, which captures the essential interaction between the physical (divergence-free) and spurious (gradient) subspaces. This model allows for a focused analysis of the effects of the penalty parameter $\\alpha$ on the computed eigenvalues. All parameters and definitions required for a unique numerical solution are provided, and the problem is free of contradictions or ambiguities. It represents a valid and insightful computational exercise.\n\nThe core of the problem is to understand the trade-off in choosing the penalty parameter $\\alpha$. If $\\alpha$ is too small, the spurious modes are not sufficiently penalized and their corresponding eigenvalues may appear within the range of the physical spectrum, corrupting the solution. If $\\alpha$ is too large, the penalty term can excessively perturb the physical modes, leading to inaccurate physical eigenvalues. The goal is to find a scaling for $\\alpha$ with respect to the discretization parameters—mesh size $h$ and polynomial degree $p$—that optimally balances these competing effects.\n\nThe problem asks for the proposal and justification of a scaling law for $\\alpha$. A principled choice can be derived from the properties of the finite element discretization. The penalized weak form is:\n$$\na_{\\alpha}(\\mathbf{E}_h, \\mathbf{v}_h) = \\int_{\\Omega} \\mu^{-1} \\left(\\nabla \\times \\mathbf{E}_h\\right)\\cdot\\left(\\nabla \\times \\mathbf{v}_h\\right) \\, d\\Omega + \\alpha \\int_{\\Omega} \\left(\\nabla \\cdot (\\epsilon \\mathbf{E}_h)\\right)\\left(\\nabla \\cdot (\\epsilon \\mathbf{v}_h)\\right) \\, d\\Omega\n$$\nThe first term, the curl-curl term, corresponds to a second-order differential operator. In a discrete setting, the eigenvalues of the corresponding matrix scale roughly as $(p/h)^2$. The penalty term, $\\alpha \\int_{\\Omega} (\\nabla\\cdot\\mathbf{E}_h)^2 \\, d\\Omega$, is intended to enforce $\\nabla\\cdot\\mathbf{E}_h \\approx 0$. A common heuristic for setting penalty parameters is to balance the operator norms. An \"inverse inequality\" from finite element theory states that for a function $\\mathbf{v}_h$ in the discrete space, the norm of its derivative is bounded by the function's own norm multiplied by a factor dependent on $h$ and $p$, e.g., $\\|\\nabla \\cdot \\mathbf{v}_h\\|_{L^2} \\le C \\frac{p}{h} \\|\\mathbf{v}_h\\|_{L^2}$. The penalty term's contribution to the stiffness matrix involves this derivative, and to ensure it is effective relative to the mass matrix (from the right-hand side of the eigenproblem), a strong penalty is needed. Choosing $\\alpha$ to scale as $(p/h)^2$ is a particularly aggressive scaling strategy. This choice, $\\alpha_{\\mathrm{opt}}(h,p) = c \\, (p/h)^2$, aims to make the penalty term's discrete operator norm comparable to that of the curl-curl operator. This ensures that for any combination of $h$ and $p$, the penalty is strong enough to push the spurious eigenvalues to values significantly larger than the physical eigenvalues of interest. The perturbation of a physical eigenvalue $\\lambda_k$ by a spurious mode with eigenvalue $\\lambda_s \\approx \\alpha$ is approximately proportional to $\\beta^2 / |\\lambda_k - \\alpha|$. By making $\\alpha$ very large via the proposed scaling, the denominator grows, thus minimizing the perturbation. The specific law to be tested is $\\alpha_{\\mathrm{opt}}(h,p) = p^2/h^2$ (i.e., with $c=1$).\n\nThe computational procedure is as follows. For each test case defined by a tuple $(h, p, \\alpha)$, we perform two calculations.\n\nFirst, using the given $\\alpha$:\n1.  The model parameters are set: $n_{\\mathrm{phys}}=6$, $n_{\\mathrm{grad}}=4$. The true physical eigenvalues are $\\lambda_k = \\pi^2 s_k$ for $k=1,\\ldots,6$, with $\\mathbf{s}=(2,5,8,10,13,17)$.\n2.  The $10 \\times 10$ symmetric block matrix $\\mathbf{A}_{\\alpha}(h,p)$ is constructed. The blocks are:\n    -   Top-left ($6 \\times 6$): $\\mathbf{\\Lambda} = \\mathrm{diag}(\\lambda_1, \\ldots, \\lambda_6)$.\n    -   Top-right ($6 \\times 4$) and bottom-left ($4 \\times 6$): The coupling is given by $\\beta(h,p)\\mathbf{C}$ and its transpose, where $\\beta(h,p) = h^p/p$ and $\\mathbf{C}$ is a matrix with $C_{ii}=1$ for $i=1,2,3,4$ and zeros elsewhere.\n    -   Bottom-right ($4 \\times 4$): The penalty is $\\alpha \\mathbf{I}_{4}$.\n3.  The eigenvalues of $\\mathbf{A}_{\\alpha}$ are computed. As the matrix is real and symmetric, all eigenvalues are real. They are sorted in non-decreasing order.\n4.  The first $n_{\\mathrm{phys}}=6$ of these sorted eigenvalues, $\\lambda_k^{\\alpha}$, are the perturbed physical eigenvalues.\n5.  The maximum relative perturbation is calculated as $\\delta(h,p,\\alpha) = \\max_{1\\le k\\le 6} |\\lambda_k^{\\alpha} - \\lambda_k|/\\lambda_k$.\n\nSecond, this entire procedure is repeated using the proposed optimal penalty parameter, $\\alpha_{\\mathrm{opt}}(h,p) = p^2/h^2$, to compute $\\delta(h,p,\\alpha_{\\mathrm{opt}})$.\n\nThis process is applied to all three test cases, and the six resulting $\\delta$ values are collected for the final output.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the eigenvalue perturbation problem for the given test cases.\n    \n    This function implements the block-structured model for a penalized finite\n    element eigenproblem, computes the perturbed eigenvalues for different\n    parameter sets, and quantifies the maximum relative perturbation.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (h, p, alpha_given)\n        (0.5, 1, 0.1),\n        (0.25, 2, 1.0),\n        (0.125, 3, 100.0),\n    ]\n\n    # --- Fixed parameters of the model ---\n    n_phys = 6\n    n_grad = 4\n    \n    # True physical eigenvalues\n    s_k = np.array([2.0, 5.0, 8.0, 10.0, 13.0, 17.0])\n    lambda_true = np.pi**2 * s_k\n    \n    # Coupling matrix C\n    # C is a 6x4 matrix with C_ii=1 for i=1,2,3,4, and 0 otherwise.\n    C = np.zeros((n_phys, n_grad))\n    np.fill_diagonal(C, 1.0)\n    \n    # Diagonal block Lambda\n    Lambda = np.diag(lambda_true)\n\n    results = []\n\n    for h, p, alpha_given in test_cases:\n        # --- Common calculation for both alpha values ---\n        # Coupling magnitude beta\n        beta = (h**p) / p\n        \n        # Off-diagonal blocks\n        coupling_block = beta * C\n        \n        # Upper part of the matrix A is the same for both calculations\n        A_upper = np.hstack([Lambda, coupling_block])\n\n        # --- 1. Calculation for the given alpha ---\n        \n        # Assemble the full matrix A_alpha\n        A_lower_given = np.hstack([coupling_block.T, alpha_given * np.identity(n_grad)])\n        A_alpha_given = np.vstack([A_upper, A_lower_given])\n        \n        # Compute eigenvalues. eigvalsh is for symmetric matrices and is efficient.\n        # The eigenvalues are not guaranteed to be sorted.\n        eigenvalues_given = np.sort(np.linalg.eigvalsh(A_alpha_given))\n        \n        # The first n_phys eigenvalues are the perturbed physical ones.\n        lambda_perturbed_given = eigenvalues_given[:n_phys]\n        \n        # Calculate maximum relative perturbation\n        delta_given = np.max(np.abs((lambda_perturbed_given - lambda_true) / lambda_true))\n        results.append(delta_given)\n\n        # --- 2. Calculation for the proposed optimal alpha ---\n        \n        # Proposed optimal penalty strength\n        alpha_opt = (p**2) / (h**2)\n        \n        # Assemble the full matrix A_alpha_opt\n        A_lower_opt = np.hstack([coupling_block.T, alpha_opt * np.identity(n_grad)])\n        A_alpha_opt = np.vstack([A_upper, A_lower_opt])\n        \n        # Compute eigenvalues\n        eigenvalues_opt = np.sort(np.linalg.eigvalsh(A_alpha_opt))\n        \n        # The first n_phys eigenvalues are the perturbed physical ones.\n        lambda_perturbed_opt = eigenvalues_opt[:n_phys]\n        \n        # Calculate maximum relative perturbation\n        delta_opt = np.max(np.abs((lambda_perturbed_opt - lambda_true) / lambda_true))\n        results.append(delta_opt)\n\n    # Final print statement in the exact required format.\n    # The use of map(str, ...) allows for default float formatting.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3350403"}, {"introduction": "The choice of finite element basis functions is the most fundamental decision in preventing spurious modes. This practice contrasts two major discretization strategies: a conforming method that inherently respects the structure of the $H(\\mathrm{curl})$ space, and a non-conforming Discontinuous Galerkin (DG) method that offers flexibility at the cost of requiring explicit stabilization [@problem_id:3350338]. By implementing simplified algebraic models for both, you will directly observe how inter-element jump penalties are essential for suppressing the large number of spurious modes generated by the DG method, thereby revealing the core principles of modern stable discretizations.", "problem": "Consider the source-free time-harmonic Maxwell curl-curl eigenproblem in two spatial dimensions on the unit square domain with Perfect Electric Conductor (PEC) boundary conditions. The partial differential equation is the generalized eigenproblem\n$$\n\\nabla \\times \\left( \\nabla \\times \\mathbf{E} \\right) = \\lambda \\, \\mathbf{E}\n$$\nwith boundary condition\n$$\n\\mathbf{n} \\times \\mathbf{E} = \\mathbf{0} \\quad \\text{on the boundary},\n$$\nwhere $\\mathbf{n}$ is the outward unit normal. The unknown $\\mathbf{E}$ is in the Sobolev space $H(\\mathrm{curl})$. In a discrete setting on a structured quadrilateral mesh with $N_x$ cells in the $x$-direction and $N_y$ cells in the $y$-direction, we investigate spurious mode suppression in finite element eigenproblems by comparing two discretizations:\n\n- A conforming $H(\\mathrm{curl})$ edge discretization that enforces tangential continuity of the field across mesh edges and effectively represents a standard edge-element formulation.\n- A nonconforming $H(\\mathrm{curl})$ Discontinuous Galerkin (DG) discretization with an upwind-type numerical flux and a stabilization parameter $\\tau$ penalizing inter-element tangential jumps.\n\nThe goal is to tune the stabilization parameter $\\tau$ to suppress nonphysical gradient modes (spurious modes) and compare the resulting near-zero eigenspectrum against the conforming edge discretization on the same mesh.\n\nStarting from the Stokes theorem and the weak formulation of the curl-curl operator, consider the following purely algebraic mimetic construction on a structured grid:\n\n1. Conforming edge discretization. Introduce one degree of freedom per unique mesh edge representing the tangential component of $\\mathbf{E}$ integrated against a suitable test function. For each cell indexed by $(i,j)$ with $i \\in \\{0,\\dots,N_x-1\\}$ and $j \\in \\{0,\\dots,N_y-1\\}$, define the discrete scalar curl as an oriented edge sum:\n$$\nc_{i,j} = e^{\\mathrm{bot}}_{i,j} + e^{\\mathrm{right}}_{i+1,j} - e^{\\mathrm{top}}_{i,j+1} - e^{\\mathrm{left}}_{i,j},\n$$\nwhere $e^{\\mathrm{bot}}_{i,j}$, $e^{\\mathrm{right}}_{i+1,j}$, $e^{\\mathrm{top}}_{i,j+1}$, and $e^{\\mathrm{left}}_{i,j}$ denote the tangential degrees of freedom on the bottom, right, top, and left edges of cell $(i,j)$, respectively, with consistent orientation. Let $B$ be the matrix mapping the vector of edge unknowns to the vector of cell curls, i.e., $c = B \\, e$. The conforming stiffness and mass matrices are then\n$$\nK_{\\mathrm{conf}} = B^\\top B, \\quad M_{\\mathrm{conf}} = I,\n$$\nwith PEC boundary conditions imposed by removing boundary-edge unknowns (i.e., eliminating Dirichlet degrees of freedom where $\\mathbf{n} \\times \\mathbf{E} = \\mathbf{0}$ is enforced).\n\n2. Nonconforming DG $H(\\mathrm{curl})$ discretization. Introduce four degrees of freedom per cell, one for each oriented local edge: bottom, right, top, and left. For each cell $(i,j)$, define the local discrete curl as\n$$\nc_{i,j}^{\\mathrm{loc}} = e^{\\mathrm{bot}}_{i,j} + e^{\\mathrm{right}}_{i,j} - e^{\\mathrm{top}}_{i,j} - e^{\\mathrm{left}}_{i,j}.\n$$\nLet $B_{i,j}$ be the $1 \\times 4$ row vector $[+1, +1, -1, -1]$ mapping the cell-local edge unknowns to the local curl. The block-diagonal local stiffness is\n$$\nK_{\\mathrm{loc}} = \\bigoplus_{i,j} B_{i,j}^\\top B_{i,j}.\n$$\nTo weakly enforce inter-element consistency and suppress spurious gradient modes, introduce an upwind-type stabilization on the tangential jump across interior edges. For each interior horizontal shared edge between a lower cell $(i,j-1)$ and an upper cell $(i,j)$, penalize the jump between the upper cell’s bottom edge and the lower cell’s top edge; for each interior vertical shared edge between a left cell $(i-1,j)$ and a right cell $(i,j)$, penalize the jump between the right edge of the left cell and the left edge of the right cell. The resulting stabilization operator is\n$$\nS(\\tau) = \\tau \\sum_{e \\in \\Gamma_{\\mathrm{int}}} \\left( u^+_e - u^-_e \\right)^2,\n$$\nwhich discretely contributes $2 \\times 2$ blocks of the form\n$$\n\\begin{bmatrix} \\tau  -\\tau \\\\ -\\tau  \\tau \\end{bmatrix}\n$$\non the paired degrees of freedom across each interior edge, where $\\Gamma_{\\mathrm{int}}$ denotes the set of interior edges and $u^\\pm_e$ are the tangential traces from adjacent cells. The DG stiffness and mass matrices are\n$$\nK_{\\mathrm{DG}}(\\tau) = K_{\\mathrm{loc}} + S(\\tau), \\quad M_{\\mathrm{DG}} = I.\n$$\nPEC boundary conditions are enforced by removing boundary-edge unknowns at the per-cell level.\n\nFor both discretizations, consider the discrete generalized eigenvalue problem\n$$\nK \\, x = \\lambda \\, M \\, x,\n$$\nwhich, with $M = I$, reduces to the standard symmetric eigenvalue problem. Define the numerical diagnostic of spurious or gradient-like modes as the count of eigenvalues below a small threshold $\\varepsilon$:\n$$\nN_{\\mathrm{near0}} = \\# \\{ \\lambda \\mid \\lambda  \\varepsilon \\}.\n$$\n\nImplement the above algebraic operators for both discretizations on the same mesh and evaluate $N_{\\mathrm{near0}}$ for the following test suite, with $\\varepsilon = 10^{-8}$:\n\n- Test case $1$: Nonconforming DG with $N_x = 2$, $N_y = 2$, $\\tau = 0$.\n- Test case $2$: Nonconforming DG with $N_x = 2$, $N_y = 2$, $\\tau = 5$.\n- Test case $3$: Nonconforming DG with $N_x = 3$, $N_y = 2$, $\\tau = 100$.\n- Test case $4$: Conforming edge discretization with $N_x = 2$, $N_y = 2$.\n\nYour program must produce a single line of output containing the results for the test suite as a comma-separated list of integers enclosed in square brackets, in the exact order given above (e.g., $[n_1,n_2,n_3,n_4]$). No physical units are involved; everything is dimensionless. Angles do not appear. Percentages are not used. The final outputs are integers.", "solution": "The starting point is the source-free time-harmonic Maxwell equation in curl-curl form. On a two-dimensional domain, with Perfect Electric Conductor (PEC) boundary conditions, the eigenproblem seeks nontrivial $\\mathbf{E} \\in H(\\mathrm{curl})$ and $\\lambda \\in \\mathbb{R}$ such that\n$$\n\\nabla \\times (\\nabla \\times \\mathbf{E}) = \\lambda \\, \\mathbf{E}, \\quad \\mathbf{n} \\times \\mathbf{E} = \\mathbf{0} \\text{ on } \\partial \\Omega.\n$$\nThe key numerical challenge is that gradient fields, i.e., $\\mathbf{E} = \\nabla \\phi$, have zero curl and can appear as nonphysical modes. In conforming $H(\\mathrm{curl})$ edge spaces, these gradient fields lie in the kernel of the curl-curl operator and do not pollute nonzero eigenvalues. In nonconforming Discontinuous Galerkin (DG) formulations without sufficient stabilization, additional per-element gradient-like nullspace can appear because jumps in tangential components are permitted, enlarging the discrete kernel. Penalizing tangential jumps suppresses these spurious modes by coupling the elements and reducing the nullspace to the physically consistent gradient subspace.\n\nPrinciples and constructions:\n\n1. From Stokes theorem in the plane, the integral of the curl over a cell equals the line integral of the tangential component of $\\mathbf{E}$ around the boundary:\n$$\n\\int_{\\kappa_{i,j}} (\\nabla \\times \\mathbf{E}) \\, \\mathrm{d}A = \\oint_{\\partial \\kappa_{i,j}} \\mathbf{E} \\cdot \\mathrm{d}\\boldsymbol{\\ell}.\n$$\nA consistent mimetic discrete version is to represent the curl via an oriented sum of edge unknowns (tangential degrees of freedom), yielding the mapping $c = B \\, e$ for the conforming discretization, where each row of $B$ contains the coefficients $+1$ or $-1$ corresponding to the oriented contribution of the four edges of a cell.\n\n2. The conforming stiffness $K_{\\mathrm{conf}} = B^\\top B$ is a discrete analog of the $L^2$ norm of the curl, i.e., $\\sum_{\\kappa} c_{\\kappa}^2$, while $M_{\\mathrm{conf}} = I$ is a simple lumped mass. Enforcing $\\mathbf{n} \\times \\mathbf{E} = \\mathbf{0}$ on the boundary is done by eliminating boundary-edge degrees of freedom (Dirichlet elimination), restricting the operator to interior edge unknowns. In this setting, any discrete gradient field consistent with the boundary conditions yields zero circulation per cell and thus lies in the kernel of $K_{\\mathrm{conf}}$, but these do not cause spurious nonzero eigenvalues.\n\n3. The nonconforming DG $H(\\mathrm{curl})$ formulation introduces per-cell edge unknowns $(e^{\\mathrm{bot}}, e^{\\mathrm{right}}, e^{\\mathrm{top}}, e^{\\mathrm{left}})$, and the local discrete curl is\n$$\nc_{i,j}^{\\mathrm{loc}} = e^{\\mathrm{bot}}_{i,j} + e^{\\mathrm{right}}_{i,j} - e^{\\mathrm{top}}_{i,j} - e^{\\mathrm{left}}_{i,j}.\n$$\nThe local stiffness $K_{\\mathrm{loc}}$ is block diagonal with $4 \\times 4$ blocks equal to $B_{i,j}^\\top B_{i,j}$, where $B_{i,j} = [1, 1, -1, -1]$. Absent stabilization ($\\tau = 0$), each local block has rank $1$, producing a large per-cell nullspace of dimension $3$, leading to a significant number of near-zero eigenvalues when assembled globally.\n\n4. Upwind-type numerical fluxes in DG for the curl operator contribute terms that penalize tangential jumps across interior edges. In the algebraic prototype, we model this by adding the stabilization operator\n$$\nS(\\tau) = \\tau \\sum_{e \\in \\Gamma_{\\mathrm{int}}} \\left( u^+_e - u^-_e \\right)^2,\n$$\nwhich, in matrix form, adds $2 \\times 2$ blocks of\n$$\n\\begin{bmatrix} \\tau  -\\tau \\\\ -\\tau  \\tau \\end{bmatrix}\n$$\non the degree-of-freedom pairs across each interior shared edge. This couples neighboring cells and suppresses per-element gradient-like modes, shrinking the discrete kernel to the physically consistent gradient subspace. PEC boundary conditions are enforced by eliminating per-cell boundary edge unknowns (bottom edges for $j=0$, top edges for $j=N_y-1$, left edges for $i=0$, and right edges for $i=N_x-1$).\n\nAlgorithmic design and computation:\n\n- Mesh indexing. For the conforming discretization, index unique horizontal edges by $(i,j)$ with $i \\in \\{0,\\dots,N_x-1\\}$ and $j \\in \\{0,\\dots,N_y\\}$, and unique vertical edges by $(i,j)$ with $i \\in \\{0,\\dots,N_x\\}$ and $j \\in \\{0,\\dots,N_y-1\\}$. Build the mapping matrix $B$ by assigning the coefficients $+1$ for bottom and right edges and $-1$ for top and left edges of each cell, consistent with orientation. Enforce PEC by selecting only interior edges: horizontal edges with $j \\in \\{1,\\dots,N_y-1\\}$ and vertical edges with $i \\in \\{1,\\dots,N_x-1\\}$. Form $K_{\\mathrm{conf}} = B^\\top B$ on the reduced interior edge set.\n\n- For the DG discretization, index per-cell local edges by $4$ unknowns per cell. Assemble $K_{\\mathrm{loc}}$ by adding $\\mathrm{outer}(b,b)$ for $b = [1, 1, -1, -1]$ on each cell’s local edge block. Assemble the stabilization $S(\\tau)$ by iterating interior shared edges (horizontal and vertical) and adding $\\tau [[1,-1],[-1,1]]$ on the paired degrees of freedom. Enforce PEC by removing per-cell boundary edge unknowns. Form $K_{\\mathrm{DG}}(\\tau)$ on the reduced set of unknowns.\n\n- Eigenvalue analysis. With $M = I$, solve the symmetric eigenvalue problem $K x = \\lambda x$ and count eigenvalues below $\\varepsilon = 10^{-8}$:\n$$\nN_{\\mathrm{near0}} = \\# \\{ \\lambda \\mid \\lambda  \\varepsilon \\}.\n$$\nA larger $N_{\\mathrm{near0}}$ indicates more spurious or gradient-like modes. As $\\tau$ increases, $N_{\\mathrm{near0}}$ for the DG discretization should decrease and approach the conforming baseline, indicating suppression of spurious per-element gradient modes.\n\nTest suite and output. Evaluate $N_{\\mathrm{near0}}$ for:\n\n- Test case $1$: DG with $(N_x, N_y, \\tau) = (2, 2, 0)$.\n- Test case $2$: DG with $(N_x, N_y, \\tau) = (2, 2, 5)$.\n- Test case $3$: DG with $(N_x, N_y, \\tau) = (3, 2, 100)$.\n- Test case $4$: Conforming with $(N_x, N_y) = (2, 2)$.\n\nProduce a single line of output: $[n_1,n_2,n_3,n_4]$, where $n_k$ are the integer counts of near-zero eigenvalues for the $k$-th test case.\n\nThis design is principle-based: it starts from the weak form and Stokes theorem, constructs discrete curl operators via oriented edge integrals, and incorporates DG flux stabilization to suppress nonconforming gradient modes. The algebraic mimetic operators capture the essential behavior of $H(\\mathrm{curl})$ discretizations and allow a clear, testable comparison focused on spurious mode suppression.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef assemble_conforming_K(Nx: int, Ny: int) - np.ndarray:\n    \"\"\"\n    Assemble the conforming mimetic curl-curl stiffness K = B^T B for a structured grid.\n    PEC boundary conditions are enforced by eliminating boundary edge DOFs.\n    \"\"\"\n    # Index unique horizontal edges: i=0..Nx-1, j=0..Ny\n    h_idx = -np.ones((Nx, Ny + 1), dtype=int)\n    # Index unique vertical edges: i=0..Nx, j=0..Ny-1\n    v_idx = -np.ones((Nx + 1, Ny), dtype=int)\n\n    idx = 0\n    for j in range(Ny + 1):\n        for i in range(Nx):\n            h_idx[i, j] = idx\n            idx += 1\n    for j in range(Ny):\n        for i in range(Nx + 1):\n            v_idx[i, j] = idx\n            idx += 1\n    n_edges = idx\n\n    # Build B mapping edge DOFs to cell curls\n    n_cells = Nx * Ny\n    B = np.zeros((n_cells, n_edges), dtype=float)\n    r = 0\n    for j in range(Ny):\n        for i in range(Nx):\n            bottom = h_idx[i, j]\n            right = v_idx[i + 1, j]\n            top = h_idx[i, j + 1]\n            left = v_idx[i, j]\n            # Oriented sum: bottom + right - top - left\n            B[r, bottom] += 1.0\n            B[r, right] += 1.0\n            B[r, top]   -= 1.0\n            B[r, left]  -= 1.0\n            r += 1\n\n    # Interior edge DOFs (PEC: remove boundary edges)\n    interior = []\n    # Horizontal interior edges: j = 1..Ny-1\n    for j in range(1, Ny):\n        for i in range(Nx):\n            interior.append(h_idx[i, j])\n    # Vertical interior edges: i = 1..Nx-1\n    for j in range(Ny):\n        for i in range(1, Nx):\n            interior.append(v_idx[i, j])\n    interior = np.array(interior, dtype=int)\n\n    # Reduced operator\n    B_red = B[:, interior]\n    K_conf = B_red.T @ B_red\n    return K_conf\n\ndef assemble_DG_K(Nx: int, Ny: int, tau: float) - np.ndarray:\n    \"\"\"\n    Assemble the nonconforming DG H(curl) mimetic curl-curl stiffness:\n    K_DG(tau) = K_loc + S(tau), with PEC enforced by eliminating per-cell boundary edge DOFs.\n    Local edge ordering per cell: [bottom, right, top, left].\n    \"\"\"\n    n_cells = Nx * Ny\n    n_dofs = 4 * n_cells\n    K = np.zeros((n_dofs, n_dofs), dtype=float)\n\n    # Local cell contributions: B_cell = [1, 1, -1, -1], K_loc += B^T B\n    for j in range(Ny):\n        for i in range(Nx):\n            cell_id = j * Nx + i\n            edofs = [4 * cell_id + s for s in range(4)]\n            b = np.array([1.0, 1.0, -1.0, -1.0])\n            K[np.ix_(edofs, edofs)] += np.outer(b, b)\n\n    # Stabilization across interior shared edges: tau * [[1,-1],[-1,1]]\n    # Horizontal shared edges: lower cell (j-1) top vs upper cell (j) bottom\n    for j in range(1, Ny):\n        for i in range(Nx):\n            lower = (j - 1) * Nx + i\n            upper = j * Nx + i\n            dof_lower_top = 4 * lower + 2  # top of lower cell\n            dof_upper_bottom = 4 * upper + 0  # bottom of upper cell\n            K[dof_lower_top, dof_lower_top] += tau\n            K[dof_upper_bottom, dof_upper_bottom] += tau\n            K[dof_lower_top, dof_upper_bottom] -= tau\n            K[dof_upper_bottom, dof_lower_top] -= tau\n    # Vertical shared edges: left cell (i-1) right vs right cell (i) left\n    for j in range(Ny):\n        for i in range(1, Nx):\n            left = j * Nx + (i - 1)\n            right = j * Nx + i\n            dof_left_right = 4 * left + 1   # right of left cell\n            dof_right_left = 4 * right + 3  # left of right cell\n            K[dof_left_right, dof_left_right] += tau\n            K[dof_right_left, dof_right_left] += tau\n            K[dof_left_right, dof_right_left] -= tau\n            K[dof_right_left, dof_left_right] -= tau\n\n    # Enforce PEC by removing boundary edge DOFs per cell\n    keep = np.ones(n_dofs, dtype=bool)\n    for j in range(Ny):\n        for i in range(Nx):\n            cell_id = j * Nx + i\n            # Bottom boundary (j == 0): remove bottom\n            if j == 0:\n                keep[4 * cell_id + 0] = False\n            # Top boundary (j == Ny-1): remove top\n            if j == Ny - 1:\n                keep[4 * cell_id + 2] = False\n            # Left boundary (i == 0): remove left\n            if i == 0:\n                keep[4 * cell_id + 3] = False\n            # Right boundary (i == Nx-1): remove right\n            if i == Nx - 1:\n                keep[4 * cell_id + 1] = False\n\n    K_red = K[np.ix_(keep, keep)]\n    return K_red\n\ndef count_near_zero_eigs(K: np.ndarray, eps: float = 1e-8) - int:\n    \"\"\"\n    Compute symmetric eigenvalues of K and count those below eps.\n    \"\"\"\n    if K.size == 0:\n        return 0\n    w = np.linalg.eigvalsh(K)\n    return int(np.sum(w  eps))\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Format: (\"DG\" or \"CONF\", Nx, Ny, tau)\n    test_cases = [\n        (\"DG\",   2, 2, 0.0),    # Test case 1\n        (\"DG\",   2, 2, 5.0),    # Test case 2\n        (\"DG\",   3, 2, 100.0),  # Test case 3\n        (\"CONF\", 2, 2, None),   # Test case 4\n    ]\n\n    eps = 1e-8\n    results = []\n    for method, Nx, Ny, tau in test_cases:\n        if method == \"CONF\":\n            K = assemble_conforming_K(Nx, Ny)\n            count = count_near_zero_eigs(K, eps=eps)\n        elif method == \"DG\":\n            K = assemble_DG_K(Nx, Ny, tau=float(tau))\n            count = count_near_zero_eigs(K, eps=eps)\n        else:\n            raise ValueError(\"Unknown method.\")\n        results.append(count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3350338"}]}