{"hands_on_practices": [{"introduction": "Before delving into complex simulations, it is essential to grasp the fundamental mechanics of the isoparametric mapping. This first exercise provides a direct, hands-on calculation of the mapping from a reference tetrahedron to a curved physical element. By computing the physical coordinates of a point within the element, you will gain a concrete understanding of how nodal positions and quadratic shape functions combine to define a curved geometry [@problem_id:3320941].", "problem": "Consider a curved quadratic isoparametric tetrahedral element used in the Finite Element Method (FEM) for solving Maxwell's equations in computational electromagnetics near a smooth, conducting boundary. The isoparametric mapping from the reference tetrahedron with local coordinates $(\\xi,\\eta,\\zeta)$ to physical space is defined by the Lagrange interpolation using nodal shape functions. Let the barycentric coordinates be $L_1 = \\xi$, $L_2 = \\eta$, $L_3 = \\zeta$, and $L_4 = 1 - \\xi - \\eta - \\zeta$, and let the quadratic tetrahedral shape functions be the standard $10$-node Lagrange polynomials:\n$$\nN_1 = L_1(2L_1 - 1),\\quad\nN_2 = L_2(2L_2 - 1),\\quad\nN_3 = L_3(2L_3 - 1),\\quad\nN_4 = L_4(2L_4 - 1),\n$$\n$$\nN_5 = 4L_1L_2,\\quad\nN_6 = 4L_2L_3,\\quad\nN_7 = 4L_3L_1,\\quad\nN_8 = 4L_1L_4,\\quad\nN_9 = 4L_2L_4,\\quad\nN_{10} = 4L_3L_4.\n$$\nThe physical coordinate mapping is\n$$\n\\mathbf{x}(\\xi,\\eta,\\zeta) = \\sum_{i=1}^{10} N_i(\\xi,\\eta,\\zeta)\\,\\mathbf{x}_i,\n$$\nwhere $\\{\\mathbf{x}_i\\}_{i=1}^{10}$ are the physical nodal coordinates of the curved element. The vertices are\n$$\n\\mathbf{x}_1 = (0,0,0)\\,\\text{m},\\quad\n\\mathbf{x}_2 = (1,0,0)\\,\\text{m},\\quad\n\\mathbf{x}_3 = (0,1,0)\\,\\text{m},\\quad\n\\mathbf{x}_4 = (0,0,1)\\,\\text{m},\n$$\nand the midside nodes are\n$$\n\\mathbf{x}_5 = \\left(\\frac{1}{2},0,\\frac{1}{8}\\right)\\,\\text{m},\\quad\n\\mathbf{x}_6 = \\left(\\frac{1}{2},\\frac{1}{2},\\frac{1}{8}\\right)\\,\\text{m},\\quad\n\\mathbf{x}_7 = \\left(0,\\frac{1}{2},\\frac{1}{8}\\right)\\,\\text{m},\n$$\n$$\n\\mathbf{x}_8 = \\left(0,0,\\frac{1}{2}\\right)\\,\\text{m},\\quad\n\\mathbf{x}_9 = \\left(\\frac{1}{2},0,\\frac{1}{2}\\right)\\,\\text{m},\\quad\n\\mathbf{x}_{10} = \\left(0,\\frac{1}{2},\\frac{1}{2}\\right)\\,\\text{m}.\n$$\nThese midside node placements on the face $1$-$2$-$3$ represent a smooth outward bulge (curved boundary), while the edges connected to node $4$ remain straight.\n\nCompute the physical coordinate vector $\\mathbf{x}$ at the parameter point $(\\xi,\\eta,\\zeta) = \\left(\\frac{1}{4},\\frac{1}{4},\\frac{1}{4}\\right)$. Express the three components of $\\mathbf{x}$ in meters. Use exact values; no rounding is necessary. Then, interpret the result in terms of boundary curvature fidelity, comparing qualitatively to what would be obtained with a linear ($4$-node) tetrahedral mapping at the same parameter point.", "solution": "The problem requires the computation of the physical coordinates $\\mathbf{x} = (x,y,z)$ within a quadratic isoparametric tetrahedral element at a specific local parameter point $(\\xi,\\eta,\\zeta)$, and a subsequent qualitative analysis comparing the result to a linear element approximation.\n\n### Step 1: Problem Validation\nThe problem statement provides a complete and consistent set of givens for an isoparametric mapping calculation.\n- **Givens**:\n    - Local coordinates: $(\\xi, \\eta, \\zeta)$.\n    - Barycentric coordinates: $L_1 = \\xi$, $L_2 = \\eta$, $L_3 = \\zeta$, $L_4 = 1 - \\xi - \\eta - \\zeta$.\n    - Quadratic shape functions $N_i$ for $i=1, \\dots, 10$.\n    - Isoparametric mapping formula: $\\mathbf{x}(\\xi,\\eta,\\zeta) = \\sum_{i=1}^{10} N_i(\\xi,\\eta,\\zeta)\\,\\mathbf{x}_i$.\n    - Nodal coordinates $\\{\\mathbf{x}_i\\}_{i=1}^{10}$.\n    - Parameter point for evaluation: $(\\xi,\\eta,\\zeta) = \\left(\\frac{1}{4},\\frac{1}{4},\\frac{1}{4}\\right)$.\n- **Validation**:\n    - The problem is **scientifically grounded** in the Finite Element Method (FEM), a standard and well-established numerical technique in computational science and engineering.\n    - The provided shape functions are the standard 10-node Lagrange polynomials for a quadratic tetrahedron.\n    - The nodal coordinates are well-defined, creating a specific curved geometry. The description of \"outward bulge\" for the face $1-2-3$ (which lies in the plane $z=0$) with midside nodes at $z = 1/8 > 0$ is slightly misstated; it describes an *inward* bulge into the tetrahedron's volume (assuming the interior is where $L_4 > 0$). However, this minor descriptive inaccuracy does not affect the mathematical validity of the setup, as the nodal coordinates unambiguously define the geometry.\n    - The problem is **well-posed**: all necessary information is provided, and the task leads to a unique, meaningful solution.\n    - The language is **objective** and precise.\n\n- **Verdict**: The problem is valid.\n\n### Step 2: Computation of Physical Coordinates\n\nThe first step is to evaluate the barycentric coordinates $L_i$ at the given parameter point $(\\xi,\\eta,\\zeta) = \\left(\\frac{1}{4},\\frac{1}{4},\\frac{1}{4}\\right)$.\n$$\nL_1 = \\xi = \\frac{1}{4}\n$$\n$$\nL_2 = \\eta = \\frac{1}{4}\n$$\n$$\nL_3 = \\zeta = \\frac{1}{4}\n$$\n$$\nL_4 = 1 - \\xi - \\eta - \\zeta = 1 - \\frac{1}{4} - \\frac{1}{4} - \\frac{1}{4} = \\frac{1}{4}\n$$\nThe evaluation point is the barycenter of the reference tetrahedron.\n\nNext, we evaluate the 10 quadratic shape functions $N_i$ at this point.\nFor the vertex nodes ($i=1,2,3,4$):\n$$\nN_i = L_i(2L_i - 1) = \\frac{1}{4}\\left(2\\left(\\frac{1}{4}\\right) - 1\\right) = \\frac{1}{4}\\left(\\frac{1}{2} - 1\\right) = \\frac{1}{4}\\left(-\\frac{1}{2}\\right) = -\\frac{1}{8}\n$$\nSo, $N_1 = N_2 = N_3 = N_4 = -\\frac{1}{8}$.\n\nFor the midside nodes ($i=5, \\dots, 10$):\nThe general form is $N_{ij} = 4L_iL_j$.\n$$\nN_5 = 4L_1L_2 = 4\\left(\\frac{1}{4}\\right)\\left(\\frac{1}{4}\\right) = \\frac{1}{4}\n$$\n$$\nN_6 = 4L_2L_3 = 4\\left(\\frac{1}{4}\\right)\\left(\\frac{1}{4}\\right) = \\frac{1}{4}\n$$\n$$\nN_7 = 4L_3L_1 = 4\\left(\\frac{1}{4}\\right)\\left(\\frac{1}{4}\\right) = \\frac{1}{4}\n$$\n$$\nN_8 = 4L_1L_4 = 4\\left(\\frac{1}{4}\\right)\\left(\\frac{1}{4}\\right) = \\frac{1}{4}\n$$\n$$\nN_9 = 4L_2L_4 = 4\\left(\\frac{1}{4}\\right)\\left(\\frac{1}{4}\\right) = \\frac{1}{4}\n$$\n$$\nN_{10} = 4L_3L_4 = 4\\left(\\frac{1}{4}\\right)\\left(\\frac{1}{4}\\right) = \\frac{1}{4}\n$$\nAs a consistency check, the sum of the shape functions must be unity: $\\sum_{i=1}^{10} N_i = 4\\left(-\\frac{1}{8}\\right) + 6\\left(\\frac{1}{4}\\right) = -\\frac{1}{2} + \\frac{3}{2} = 1$. The values are correct.\n\nFinally, we compute the physical coordinate vector $\\mathbf{x} = \\sum_{i=1}^{10} N_i \\mathbf{x}_i$. Let $\\mathbf{x} = (x,y,z)$. We compute each component separately.\nThe nodal coordinates are:\n$\\mathbf{x}_1 = (0,0,0)$, $\\mathbf{x}_2 = (1,0,0)$, $\\mathbf{x}_3 = (0,1,0)$, $\\mathbf{x}_4 = (0,0,1)$.\n$\\mathbf{x}_5 = (\\frac{1}{2},0,\\frac{1}{8})$, $\\mathbf{x}_6 = (\\frac{1}{2},\\frac{1}{2},\\frac{1}{8})$, $\\mathbf{x}_7 = (0,\\frac{1}{2},\\frac{1}{8})$.\n$\\mathbf{x}_8 = (0,0,\\frac{1}{2})$, $\\mathbf{x}_9 = (\\frac{1}{2},0,\\frac{1}{2})$, $\\mathbf{x}_{10} = (0,\\frac{1}{2},\\frac{1}{2})$.\n\nFor the $x$-component:\n$$\nx = \\sum_{i=1}^{10} N_i x_i = N_2 x_2 + N_5 x_5 + N_6 x_6 + N_9 x_9\n$$\n$$\nx = \\left(-\\frac{1}{8}\\right)(1) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right)\n$$\n$$\nx = -\\frac{1}{8} + \\frac{1}{8} + \\frac{1}{8} + \\frac{1}{8} = \\frac{2}{8} = \\frac{1}{4}\n$$\n\nFor the $y$-component:\n$$\ny = \\sum_{i=1}^{10} N_i y_i = N_3 y_3 + N_6 y_6 + N_7 y_7 + N_{10} y_{10}\n$$\n$$\ny = \\left(-\\frac{1}{8}\\right)(1) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right)\n$$\n$$\ny = -\\frac{1}{8} + \\frac{1}{8} + \\frac{1}{8} + \\frac{1}{8} = \\frac{2}{8} = \\frac{1}{4}\n$$\n\nFor the $z$-component:\n$$\nz = \\sum_{i=1}^{10} N_i z_i = N_4 z_4 + N_5 z_5 + N_6 z_6 + N_7 z_7 + N_8 z_8 + N_9 z_9 + N_{10} z_{10}\n$$\n$$\nz = \\left(-\\frac{1}{8}\\right)(1) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{8}\\right) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{8}\\right) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{8}\\right) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right)\n$$\n$$\nz = -\\frac{1}{8} + 3\\left(\\frac{1}{32}\\right) + 3\\left(\\frac{1}{8}\\right) = -\\frac{1}{8} + \\frac{3}{32} + \\frac{3}{8}\n$$\n$$\nz = \\frac{-4 + 3 + 12}{32} = \\frac{11}{32}\n$$\nThe physical coordinate vector is $\\mathbf{x} = \\left(\\frac{1}{4}, \\frac{1}{4}, \\frac{11}{32}\\right)$ meters.\n\n### Step 3: Qualitative Interpretation\n\nTo interpret this result, we compare it with the coordinate obtained from a linear ($4$-node) tetrahedral mapping. For a linear element, the mapping is defined solely by the vertices:\n$$\n\\mathbf{x}_{\\text{lin}}(\\xi,\\eta,\\zeta) = \\sum_{i=1}^{4} L_i(\\xi,\\eta,\\zeta)\\,\\mathbf{x}_i\n$$\nAt the same parameter point $(\\xi,\\eta,\\zeta) = \\left(\\frac{1}{4},\\frac{1}{4},\\frac{1}{4}\\right)$, where $L_1 = L_2 = L_3 = L_4 = \\frac{1}{4}$:\n$$\n\\mathbf{x}_{\\text{lin}} = \\frac{1}{4}\\mathbf{x}_1 + \\frac{1}{4}\\mathbf{x}_2 + \\frac{1}{4}\\mathbf{x}_3 + \\frac{1}{4}\\mathbf{x}_4\n$$\n$$\n\\mathbf{x}_{\\text{lin}} = \\frac{1}{4}\\left[(0,0,0) + (1,0,0) + (0,1,0) + (0,0,1)\\right] = \\frac{1}{4}(1,1,1) = \\left(\\frac{1}{4}, \\frac{1}{4}, \\frac{1}{4}\\right)\n$$\nThe linear mapping simply yields the physical centroid of the four vertices.\n\n**Comparison and Fidelity**:\n-   **Linear Element**: The linear element produces a physical element with straight edges and flat faces. It maps the reference tetrahedron's barycenter to the physical barycenter of the vertices, $\\mathbf{x}_{\\text{lin}} = \\left(\\frac{1}{4}, \\frac{1}{4}, \\frac{8}{32}\\right)$. This constitutes a first-order, or piecewise linear, approximation of the geometry. If the actual boundary is curved, the linear element can only represent it as a collection of flat facets, leading to a \"staircase\" approximation that introduces geometrical error.\n\n-   **Quadratic Element**: The quadratic element uses midside nodes to define a higher-order, curved geometry. The resulting coordinate is $\\mathbf{x}_{\\text{quad}} = \\left(\\frac{1}{4}, \\frac{1}{4}, \\frac{11}{32}\\right)$. The $x$ and $y$ components are identical to the linear case, but the $z$ component is different: $z_{\\text{quad}} = \\frac{11}{32}$ versus $z_{\\text{lin}} = \\frac{8}{32}$. The displacement $\\Delta z = \\frac{3}{32}$ is a direct consequence of the midside nodes being shifted from their straight-edge positions. Specifically, the midside nodes $\\mathbf{x}_5, \\mathbf{x}_6, \\mathbf{x}_7$ on the face $z=0$ were given a positive $z$-component of $\\frac{1}{8}$, creating a curved surface that bulges into the element's volume.\n\n-   **Conclusion**: The quadratic isoparametric element provides superior boundary curvature fidelity. It allows the finite element mesh to conform smoothly and accurately to curved boundaries, which is crucial for problems in computational electromagnetics where boundary conditions on conducting surfaces must be enforced precisely. A linear element's geometric inaccuracy can lead to significant errors in the computed fields, surface currents, and scattering parameters, whereas the quadratic element's ability to model curvature drastically improves the solution's accuracy.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{4}  \\frac{1}{4}  \\frac{11}{32}\n\\end{pmatrix}\n}\n$$", "id": "3320941"}, {"introduction": "Isoparametric elements provide an approximation, not an exact replica, of a curved boundary. This practice focuses on quantifying the geometric error inherent in this approximation, a critical step in understanding mesh quality and its impact on solution accuracy. You will model a circular arc with a quadratic element and derive the radial deviation, revealing where the approximation is exact and where it deviates most significantly [@problem_id:3320945].", "problem": "In Computational Electromagnetics (CEM), high-order curvilinear elements are employed to represent perfectly conducting boundaries with reduced geometric error. Consider a two-dimensional, perfectly conducting circular arc of radius $R = 1.000$ meters, centered at the origin, spanning angles from $-\\alpha$ to $+\\alpha$, with $\\alpha = \\pi/6$ radians. An isoparametric quadratic edge is used to approximate this arc. The edge is parameterized by a reference coordinate $\\xi \\in [-1,1]$, and uses three boundary points at $\\xi = -1, 0, 1$ mapped to the exact circular arc at angles $-\\alpha$, $0$, $+\\alpha$, respectively.\n\nUsing the standard second-order Lagrange isoparametric mapping for the edge, construct the approximate geometric mapping $(x(\\xi), y(\\xi))$ from the reference coordinate to physical coordinates. Then, quantify the geometric deviation from the exact circle by the radial error function\n$$\n\\delta(\\xi) = \\sqrt{x(\\xi)^{2} + y(\\xi)^{2}} - R,\n$$\nand determine the maximum absolute radial deviation over $\\xi \\in [-1,1]$.\n\nExpress the final answer as a single real number in meters, rounded to four significant figures. Angles must be treated in radians.", "solution": "### Step 1: Problem Validation\nThe problem is scientifically valid, well-posed, and based on standard principles of the Finite Element Method (FEM). It requires the quantification of geometric error when a quadratic isoparametric element is used to approximate a circular arc. All necessary information is provided: the exact geometry (a circular arc of radius $R=1$ and angle $\\alpha=\\pi/6$), the approximation method (3-node quadratic Lagrange interpolation), and the error metric (maximum radial deviation). The objective is clear and leads to a unique solution.\n\n### Step 2: Define Lagrange Basis Functions and Nodal Coordinates\nFor a 1D quadratic element with nodes at $\\xi \\in \\{-1, 0, 1\\}$, the standard Lagrange basis functions are:\n- $N_{-1}(\\xi) = \\frac{1}{2}\\xi(\\xi-1)$\n- $N_0(\\xi) = 1 - \\xi^2$\n- $N_1(\\xi) = \\frac{1}{2}\\xi(\\xi+1)$\n\nThe physical coordinates of the three nodes are on the circular arc at angles $-\\alpha$, $0$, and $+\\alpha$, where $R=1$ and $\\alpha=\\pi/6$.\n- Node at $\\xi=-1$: $\\mathbf{x}_{-1} = (R\\cos(-\\alpha), R\\sin(-\\alpha)) = (\\cos(\\pi/6), -\\sin(\\pi/6)) = (\\frac{\\sqrt{3}}{2}, -\\frac{1}{2})$\n- Node at $\\xi=0$: $\\mathbf{x}_{0} = (R\\cos(0), R\\sin(0)) = (1, 0)$\n- Node at $\\xi=1$: $\\mathbf{x}_{1} = (R\\cos(\\alpha), R\\sin(\\alpha)) = (\\cos(\\pi/6), \\sin(\\pi/6)) = (\\frac{\\sqrt{3}}{2}, \\frac{1}{2})$\n\n### Step 3: Construct the Isoparametric Mapping\nThe mapping $\\mathbf{x}(\\xi) = (x(\\xi), y(\\xi))$ is given by $\\mathbf{x}(\\xi) = N_{-1}(\\xi)\\mathbf{x}_{-1} + N_0(\\xi)\\mathbf{x}_{0} + N_1(\\xi)\\mathbf{x}_{1}$.\n\nFor the x-component:\n$x(\\xi) = \\frac{1}{2}\\xi(\\xi-1)\\left(\\frac{\\sqrt{3}}{2}\\right) + (1-\\xi^2)(1) + \\frac{1}{2}\\xi(\\xi+1)\\left(\\frac{\\sqrt{3}}{2}\\right)$\n$x(\\xi) = \\frac{\\sqrt{3}}{4}(\\xi^2-\\xi) + 1-\\xi^2 + \\frac{\\sqrt{3}}{4}(\\xi^2+\\xi) = \\frac{\\sqrt{3}}{2}\\xi^2 + 1-\\xi^2 = 1 - \\left(1-\\frac{\\sqrt{3}}{2}\\right)\\xi^2$\n\nFor the y-component:\n$y(\\xi) = \\frac{1}{2}\\xi(\\xi-1)\\left(-\\frac{1}{2}\\right) + (1-\\xi^2)(0) + \\frac{1}{2}\\xi(\\xi+1)\\left(\\frac{1}{2}\\right)$\n$y(\\xi) = -\\frac{1}{4}(\\xi^2-\\xi) + \\frac{1}{4}(\\xi^2+\\xi) = \\frac{1}{4}(2\\xi) = \\frac{\\xi}{2}$\n\n### Step 4: Define and Analyze the Radial Error Function\nThe radial error is $\\delta(\\xi) = \\sqrt{x(\\xi)^2 + y(\\xi)^2} - R$. With $R=1$, the squared radius is:\n$r^2(\\xi) = x(\\xi)^2 + y(\\xi)^2 = \\left[1 - \\left(1-\\frac{\\sqrt{3}}{2}\\right)\\xi^2\\right]^2 + \\left(\\frac{\\xi}{2}\\right)^2$\nLet $C = 1 - \\frac{\\sqrt{3}}{2}$. Then $r^2(\\xi) = (1 - C\\xi^2)^2 + \\frac{\\xi^2}{4} = 1 - 2C\\xi^2 + C^2\\xi^4 + \\frac{1}{4}\\xi^2$.\n$r^2(\\xi) = 1 + \\left(\\frac{1}{4} - 2C\\right)\\xi^2 + C^2\\xi^4$.\nWe can verify that $\\frac{1}{4} - 2C = \\frac{1}{4} - 2(1-\\frac{\\sqrt{3}}{2}) = \\frac{1}{4} - 2 + \\sqrt{3} = \\sqrt{3} - \\frac{7}{4}$.\nAnd $C^2 = (1-\\frac{\\sqrt{3}}{2})^2 = 1 - \\sqrt{3} + \\frac{3}{4} = \\frac{7}{4} - \\sqrt{3} = -(\\sqrt{3} - \\frac{7}{4})$.\nSo, $\\frac{1}{4} - 2C = -C^2$.\nThe squared radius simplifies to:\n$r^2(\\xi) = 1 - C^2\\xi^2 + C^2\\xi^4 = 1 + C^2(\\xi^4 - \\xi^2)$.\n\nThe radial error function is $\\delta(\\xi) = \\sqrt{1 + C^2(\\xi^4 - \\xi^2)} - 1$.\nAt the nodes $\\xi \\in \\{-1, 0, 1\\}$, the term $\\xi^4 - \\xi^2 = 0$, so $\\delta(\\xi) = 0$, as expected.\nFor $\\xi \\in (-1, 1)$, $\\xi^4 - \\xi^2  0$, which means $r^2(\\xi)  1$ and the radial error $\\delta(\\xi)$ is negative. The approximated arc is always inside the true circle.\n\n### Step 5: Find the Maximum Absolute Radial Deviation\nTo find the maximum absolute deviation $|\\delta(\\xi)| = 1 - \\delta(\\xi) - 1 = 1 - \\sqrt{1 + C^2(\\xi^4 - \\xi^2)}$, we need to find the minimum value of $r^2(\\xi)$. This occurs where the term $g(\\xi) = \\xi^4 - \\xi^2$ is minimum.\nTaking the derivative, $g'(\\xi) = 4\\xi^3 - 2\\xi = 2\\xi(2\\xi^2 - 1)$.\nThe critical points are $\\xi=0$ and $\\xi = \\pm\\frac{1}{\\sqrt{2}}$.\n- $g(0) = 0$\n- $g(\\pm 1) = 0$\n- $g(\\pm\\frac{1}{\\sqrt{2}}) = (\\frac{1}{4}) - (\\frac{1}{2}) = -\\frac{1}{4}$\nThe minimum value of $\\xi^4 - \\xi^2$ is $-\\frac{1}{4}$.\n\nThe maximum absolute error is therefore:\n$|\\delta|_{max} = 1 - \\sqrt{1 + C^2(-\\frac{1}{4})} = 1 - \\sqrt{1 - \\frac{C^2}{4}}$\nNow we substitute the value of $C^2 = \\frac{7}{4} - \\sqrt{3}$:\n$|\\delta|_{max} = 1 - \\sqrt{1 - \\frac{1}{4}\\left(\\frac{7}{4} - \\sqrt{3}\\right)} = 1 - \\sqrt{1 - \\frac{7}{16} + \\frac{\\sqrt{3}}{4}} = 1 - \\sqrt{\\frac{9}{16} + \\frac{\\sqrt{3}}{4}}$\n$|\\delta|_{max} = 1 - \\sqrt{\\frac{9+4\\sqrt{3}}{16}} = 1 - \\frac{\\sqrt{9+4\\sqrt{3}}}{4}$\n\n### Step 6: Numerical Calculation\nWe compute the final value:\n$\\sqrt{3} \\approx 1.7320508$\n$9 + 4\\sqrt{3} \\approx 9 + 4(1.7320508) = 9 + 6.9282032 = 15.9282032$\n$\\sqrt{15.9282032} \\approx 3.9910153$\n$\\frac{\\sqrt{9+4\\sqrt{3}}}{4} \\approx \\frac{3.9910153}{4} \\approx 0.9977538$\n$|\\delta|_{max} \\approx 1 - 0.9977538 = 0.0022462$\nRounding to four significant figures gives $0.002246$.", "answer": "$$\n\\boxed{0.002246}\n$$", "id": "3320945"}, {"introduction": "The quality of a finite element mesh is not just an aesthetic concern; it directly influences the stability and accuracy of the numerical solution. This comprehensive coding exercise connects the geometric quality of a curved element to its performance in a simulation. By implementing key distortion metrics and measuring their correlation with interpolation and integration errors, you will develop a practical intuition for why maintaining low-distortion elements is paramount in computational science [@problem_id:3320978].", "problem": "Consider a two-dimensional isoparametric quadratic quadrilateral element with nine nodes defined on the reference square with coordinates $(\\xi,\\eta)\\in[-1,1]\\times[-1,1]$. The isoparametric mapping from the reference square to the physical element is constructed using the tensor-product quadratic Lagrange basis on the three-node set $\\{\\xi=-1,0,1\\}\\times\\{\\eta=-1,0,1\\}$, and the physical node coordinates $\\{\\mathbf{x}_i\\}_{i=1}^{9}$ are given for each test case. The Jacobian matrix $\\mathbf{J}(\\xi,\\eta)$ of the mapping is defined by the partial derivatives of the physical coordinates with respect to $(\\xi,\\eta)$ and its determinant is $\\det \\mathbf{J}(\\xi,\\eta)$. Let the analytic scalar field be $f(x,y)=\\sin(\\pi x)\\cos(\\pi y)$, treated as dimensionless.\n\nStarting from the fundamental definitions of isoparametric mapping, metric tensors, and Gaussian quadrature rules, implement a program that, for each test case, computes the following distortion metrics and accuracy measures:\n\n1. Mean skewness $\\overline{s}$: For each sample point $(\\xi,\\eta)$, let $\\mathbf{a}=\\partial\\mathbf{x}/\\partial\\xi$ and $\\mathbf{b}=\\partial\\mathbf{x}/\\partial\\eta$ be the columns of $\\mathbf{J}$. Define the local skewness as $s=\\left|\\frac{\\mathbf{a}\\cdot\\mathbf{b}}{\\|\\mathbf{a}\\|\\|\\mathbf{b}\\|}\\right|$. Compute $\\overline{s}$ as the arithmetic mean of $s$ over an interior sampling grid of $n_s\\times n_s$ points, where $n_s$ is set to $7$. The angle is implicitly measured in radians via the cosine function.\n\n2. Mean aspect ratio $\\overline{r}$: At each sample point, compute the singular values $\\sigma_{\\max}$ and $\\sigma_{\\min}$ of $\\mathbf{J}$ and define $r=\\sigma_{\\max}/\\sigma_{\\min}$. Compute $\\overline{r}$ as the arithmetic mean of $r$ over the same sampling grid.\n\n3. Minimum Jacobian determinant $\\min_{\\text{samples}} \\det \\mathbf{J}$: Evaluate $\\det \\mathbf{J}$ on the sampling grid and report its minimum value over the sampled points (do not take the absolute value).\n\n4. Field interpolation $L^2$-error: Using the same quadratic Lagrange basis used for the geometric mapping, form the isoparametric interpolation $f_h(\\xi,\\eta)=\\sum_{i=1}^{9}N_i(\\xi,\\eta) f(\\mathbf{x}_i)$, where $N_i$ are the shape functions and $\\mathbf{x}_i$ are the physical node coordinates. Compute the $L^2$-norm of the interpolation error over the physical element,\n$$\n\\|f-f_h\\|_{L^2(\\Omega_e)}=\\left(\\int_{\\Omega_e} (f-f_h)^2 \\, d\\Omega\\right)^{1/2},\n$$\nby transforming to the reference domain and approximating the integral with tensor-product Gaussian quadrature of order $q_h=7$ using the absolute value $\\left|\\det \\mathbf{J}\\right|$ as the measure factor under the mapping.\n\n5. Integration accuracy: Compute the integral $I=\\int_{\\Omega_e} f \\, d\\Omega$ with tensor-product Gaussian quadrature of order $q_\\ell=3$, and a reference value $I_{\\text{ref}}$ with order $q_h=7$, both using the absolute value $\\left|\\det \\mathbf{J}\\right|$. Report the absolute integration error $|I-I_{\\text{ref}}|$.\n\nUse sampling points that exclude the boundary by placing the $n_s$ points uniformly within $(-1,1)$ on each axis at positions $\\xi_i=-1+\\frac{2i}{n_s+1}$ and $\\eta_j=-1+\\frac{2j}{n_s+1}$ for $i,j\\in\\{1,\\dots,n_s\\}$.\n\nRelate the distortion metrics to the accuracy measures by computing all quantities and returning numerical values for each test case. Larger skewness and aspect ratio typically indicate higher distortion and are expected to correlate with larger interpolation and integration errors.\n\nTest Suite (each test case provides the nine physical nodes in row-major order corresponding to $(\\xi,\\eta)\\in\\{(-1,-1),(0,-1),(1,-1),(-1,0),(0,0),(1,0),(-1,1),(0,1),(1,1)\\}$):\n\n- Test Case $1$ (mildly curved, nearly rectangular):\n$\\left[\n(0.0,0.0),\\,\n(1.0,-0.03),\\,\n(2.0,0.05),\\,\n(-0.02,0.5),\\,\n(1.02,0.52),\\,\n(2.03,0.5),\\,\n(0.0,1.0),\\,\n(1.0,1.03),\\,\n(2.0,1.05)\n\\right]$.\n\n- Test Case $2$ (skewed and moderately curved):\n$\\left[\n(0.0,0.0),\\,\n(1.0,0.10),\\,\n(2.0,0.3),\\,\n(0.03,0.42),\\,\n(1.07,0.57),\\,\n(2.08,0.68),\\,\n(0.1,0.8),\\,\n(1.12,0.97),\\,\n(2.1,1.1)\n\\right]$.\n\n- Test Case $3$ (thin and significantly curved):\n$\\left[\n(0.0,0.0),\\,\n(1.5,0.06),\\,\n(3.0,0.2),\\,\n(0.2,0.22),\\,\n(1.62,0.27),\\,\n(3.15,0.33),\\,\n(0.5,0.4),\\,\n(1.9,0.47),\\,\n(3.2,0.5)\n\\right]$.\n\nYour program should produce a single line of output containing the results for the three test cases as a comma-separated list enclosed in square brackets, where each test case result is itself a list of five floating-point numbers in the order $\\left[\\overline{s},\\overline{r},\\min \\det \\mathbf{J},\\|f-f_h\\|_{L^2(\\Omega_e)},|I-I_{\\text{ref}}|\\right]$. For example, the output format is $\\left[ [a_1,a_2,a_3,a_4,a_5], [b_1,b_2,b_3,b_4,b_5], [c_1,c_2,c_3,c_4,c_5] \\right]$, with all entries expressed as decimal numbers.", "solution": "The problem requires the computation of several distortion metrics and accuracy measures for a two-dimensional, nine-node isoparametric quadratic quadrilateral element. The analysis involves concepts from finite element methods, including isoparametric mapping, numerical integration using Gaussian quadrature, and error estimation. The full procedure is detailed below, beginning with fundamental definitions.\n\n### 1. Isoparametric Formulation\n\nThe core of the method is the isoparametric mapping, which uses the same set of basis functions (shape functions) to define the element's geometry and to interpolate a field over the element.\n\n#### 1.1. Reference Element and Shape Functions\nThe reference element is a square in the computational domain, defined by $(\\xi, \\eta) \\in [-1, 1] \\times [-1, 1]$. For a nine-node quadratic element, the nodes are located at the tensor product of the points $\\{-1, 0, 1\\}$ on each axis.\n\nFirst, we define the one-dimensional quadratic Lagrange basis functions, $L_k(\\zeta)$, for a variable $\\zeta \\in [-1, 1]$ with nodes at $\\zeta \\in \\{-1, 0, 1\\}$.\nLet the nodal positions be $\\zeta_1 = -1$, $\\zeta_2 = 0$, and $\\zeta_3 = 1$. The basis functions are:\n- $L_1(\\zeta) = \\frac{(\\zeta - \\zeta_2)(\\zeta - \\zeta_3)}{(\\zeta_1 - \\zeta_2)(\\zeta_1 - \\zeta_3)} = \\frac{\\zeta(\\zeta - 1)}{(-1)(-2)} = \\frac{1}{2}\\zeta(\\zeta - 1)$\n- $L_2(\\zeta) = \\frac{(\\zeta - \\zeta_1)(\\zeta - \\zeta_3)}{(\\zeta_2 - \\zeta_1)(\\zeta_2 - \\zeta_3)} = \\frac{(\\zeta + 1)(\\zeta - 1)}{(1)(-1)} = 1 - \\zeta^2$\n- $L_3(\\zeta) = \\frac{(\\zeta - \\zeta_1)(\\zeta - \\zeta_2)}{(\\zeta_3 - \\zeta_1)(\\zeta_3 - \\zeta_2)} = \\frac{(\\zeta + 1)\\zeta}{(2)(1)} = \\frac{1}{2}\\zeta(\\zeta + 1)$\n\nThe two-dimensional shape functions $N_i(\\xi, \\eta)$ for the nine nodes are formed by the tensor product of these 1D functions. Given the specified row-major node ordering, if we have node indices $j,k \\in \\{1,2,3\\}$ for the $\\xi$ and $\\eta$ directions respectively, the global node index $i$ (from 1 to 9) and the corresponding shape function are given by $N_i(\\xi, \\eta) = L_j(\\xi) L_k(\\eta)$. For example, for node $i=5$ at $(\\xi, \\eta)=(0,0)$, the shape function is $N_5(\\xi, \\eta) = L_2(\\xi)L_2(\\eta) = (1-\\xi^2)(1-\\eta^2)$.\n\n#### 1.2. Geometric Mapping and Field Interpolation\nThe isoparametric mapping from the reference coordinates $(\\xi, \\eta)$ to the physical coordinates $\\mathbf{x} = (x, y)$ is given by:\n$$ \\mathbf{x}(\\xi, \\eta) = \\sum_{i=1}^{9} N_i(\\xi, \\eta) \\mathbf{x}_i $$\nwhere $\\mathbf{x}_i = (x_i, y_i)$ are the coordinates of the $i$-th physical node.\n\nSimilarly, the scalar field $f(x, y)$ is interpolated over the element using the same shape functions:\n$$ f_h(\\xi, \\eta) = \\sum_{i=1}^{9} N_i(\\xi, \\eta) f(\\mathbf{x}_i) $$\nwhere $f_h$ is the approximation of $f$ and $f(\\mathbf{x}_i)$ is the value of the true field at the physical node $i$.\n\n### 2. Jacobian Matrix and Distortion Metrics\n\nThe local distortion of the mapping is characterized by the Jacobian matrix $\\mathbf{J}$, which relates infinitesimal changes in reference coordinates to infinitesimal changes in physical coordinates.\n\n#### 2.1. Jacobian Matrix\nThe Jacobian matrix is defined as:\n$$ \\mathbf{J}(\\xi, \\eta) = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi}  \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi}  \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix} $$\nThe partial derivatives are found by differentiating the mapping equation:\n$$ \\frac{\\partial \\mathbf{x}}{\\partial \\xi} = \\sum_{i=1}^{9} \\frac{\\partial N_i}{\\partial \\xi} \\mathbf{x}_i \\quad \\text{and} \\quad \\frac{\\partial \\mathbf{x}}{\\partial \\eta} = \\sum_{i=1}^{9} \\frac{\\partial N_i}{\\partial \\eta} \\mathbf{x}_i $$\nThe derivatives of the shape functions are required, e.g., $\\frac{\\partial N_i}{\\partial \\xi} = \\frac{d L_j(\\xi)}{d \\xi} L_k(\\eta)$.\n\n#### 2.2. Distortion Metrics\nThe problem asks for three metrics to be evaluated over an interior $n_s \\times n_s$ sampling grid, where $n_s=7$.\n1.  **Mean Skewness $\\overline{s}$**: The columns of $\\mathbf{J}$, $\\mathbf{a} = \\frac{\\partial \\mathbf{x}}{\\partial \\xi}$ and $\\mathbf{b} = \\frac{\\partial \\mathbf{x}}{\\partial \\eta}$, represent the mapped basis vectors. Skewness measures the deviation from orthogonality. The local skewness $s$ is the absolute value of the cosine of the angle between them:\n    $$ s(\\xi, \\eta) = \\left| \\frac{\\mathbf{a} \\cdot \\mathbf{b}}{\\|\\mathbf{a}\\| \\|\\mathbf{b}\\|} \\right| $$\n    The mean skewness $\\overline{s}$ is the arithmetic average of $s$ over the sampling grid. A value of $0$ is ideal (orthogonal), while a value near $1$ indicates severe distortion.\n\n2.  **Mean Aspect Ratio $\\overline{r}$**: This metric measures the stretching of the element. It is defined as the ratio of the largest to the smallest singular values of the Jacobian matrix, $\\sigma_{\\max}$ and $\\sigma_{\\min}$:\n    $$ r(\\xi, \\eta) = \\frac{\\sigma_{\\max}(\\mathbf{J})}{\\sigma_{\\min}(\\mathbf{J})} $$\n    The mean aspect ratio $\\overline{r}$ is the arithmetic average of $r$ over the sampling grid. An ideal element has an aspect ratio of $1$.\n\n3.  **Minimum Jacobian Determinant $\\min \\det \\mathbf{J}$**: The determinant of the Jacobian, $\\det \\mathbf{J}$, is the local ratio of area in the physical domain to area in the reference domain. A non-positive determinant indicates a locally invalid (folded) mapping. We find the minimum value of $\\det \\mathbf{J}$ over the sampling grid.\n\n### 3. Accuracy Measures\n\nDistortion affects the accuracy of both field interpolation and numerical integration.\n\n#### 3.1. $L^2$-Error of Field Interpolation\nThe error in approximating the field $f$ by $f_h$ is measured by the $L^2$-norm of their difference over the physical element $\\Omega_e$:\n$$ \\|f - f_h\\|_{L^2(\\Omega_e)} = \\left( \\int_{\\Omega_e} (f(\\mathbf{x}) - f_h(\\mathbf{x}))^2 \\, d\\Omega \\right)^{1/2} $$\nTo compute this, we transform the integral to the reference element:\n$$ \\int_{\\Omega_e} g(\\mathbf{x}) \\, d\\Omega = \\int_{-1}^{1} \\int_{-1}^{1} g(\\mathbf{x}(\\xi, \\eta)) |\\det \\mathbf{J}(\\xi, \\eta)| \\, d\\xi \\, d\\eta $$\nApplying this with $g = (f-f_h)^2$, the error norm becomes:\n$$ \\|f - f_h\\|_{L^2(\\Omega_e)} = \\left( \\int_{-1}^{1} \\int_{-1}^{1} (f(\\mathbf{x}(\\xi, \\eta)) - f_h(\\xi, \\eta))^2 |\\det \\mathbf{J}(\\xi, \\eta)| \\, d\\xi \\, d\\eta \\right)^{1/2} $$\nThis integral is approximated using a $q_h \\times q_h$ tensor-product Gaussian quadrature rule, where $q_h=7$. The formula for 2D Gaussian quadrature is:\n$$ \\int_{-1}^{1}\\int_{-1}^{1} G(\\xi, \\eta) \\, d\\xi \\, d\\eta \\approx \\sum_{j=1}^{q} \\sum_{k=1}^{q} w_j w_k G(\\xi_j, \\eta_k) $$\nwhere $(\\xi_j, \\eta_k)$ are the quadrature points and $(w_j, w_k)$ are the corresponding weights.\n\n#### 3.2. Integration Accuracy\nWe assess how element distortion affects the accuracy of numerical integration by comparing the integral of the field $f$ computed with two different quadrature orders. The integral is:\n$$ I = \\int_{\\Omega_e} f(\\mathbf{x}) \\, d\\Omega = \\int_{-1}^{1} \\int_{-1}^{1} f(\\mathbf{x}(\\xi, \\eta)) |\\det \\mathbf{J}(\\xi, \\eta)| \\, d\\xi \\, d\\eta $$\n- A low-accuracy integral, $I$, is computed using a low-order quadrature rule ($q_\\ell=3$).\n- A high-accuracy reference integral, $I_{\\text{ref}}$, is computed using a high-order rule ($q_h=7$).\nThe absolute integration error is then $|I - I_{\\text{ref}}|$.\n\n### 4. Computational Algorithm\nFor each test case (a set of 9 physical node coordinates $\\mathbf{x}_i$):\n1.  Define the $n_s \\times n_s = 7 \\times 7$ interior sampling grid.\n2.  Initialize accumulators for mean skewness, mean aspect ratio, and a variable for minimum Jacobian determinant.\n3.  Iterate over each point $(\\xi, \\eta)$ in the sampling grid:\n    a. Calculate the Jacobian matrix $\\mathbf{J}(\\xi, \\eta)$.\n    b. Compute local skewness $s$, aspect ratio $r$, and $\\det \\mathbf{J}$.\n    c. Update the accumulators and the minimum determinant.\n4.  Calculate the final mean values $\\overline{s}$ and $\\overline{r}$.\n5.  Set up the $q_h=7$ point Gaussian quadrature rule.\n6.  Evaluate the analytic field $f(\\mathbf{x}_i)$ at each of the 9 physical nodes.\n7.  Calculate the $L^2$ interpolation error integral by summing contributions at each quadrature point. Take the square root of the result.\n8.  Calculate the reference integral $I_{\\text{ref}}$ using the $q_h=7$ quadrature rule.\n9.  Set up the $q_\\ell=3$ point Gaussian quadrature rule.\n10. Calculate the low-order integral $I$ using the $q_\\ell=3$ rule.\n11. Compute the absolute integration error $|I - I_{\\text{ref}}|$.\n12. Collect the five computed values: $\\overline{s}$, $\\overline{r}$, $\\min \\det \\mathbf{J}$, $\\|f-f_h\\|_{L^2(\\Omega_e)}$, and $|I-I_{\\text{ref}}|$.\n\nThis procedure is repeated for each test case, yielding the requested numerical results.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef one_d_basis(z: float) -> np.ndarray:\n    \"\"\"Computes the 1D quadratic Lagrange basis functions at a point z.\"\"\"\n    l1 = 0.5 * z * (z - 1.0)\n    l2 = 1.0 - z**2\n    l3 = 0.5 * z * (z + 1.0)\n    return np.array([l1, l2, l3])\n\ndef one_d_basis_deriv(z: float) -> np.ndarray:\n    \"\"\"Computes the derivatives of the 1D quadratic Lagrange basis functions.\"\"\"\n    dl1 = z - 0.5\n    dl2 = -2.0 * z\n    dl3 = z + 0.5\n    return np.array([dl1, dl2, dl3])\n\ndef shape_functions(xi: float, eta: float) -> np.ndarray:\n    \"\"\"Computes the 9-node quadratic shape functions at (xi, eta).\"\"\"\n    l_xi = one_d_basis(xi)\n    l_eta = one_d_basis(eta)\n    n_vec = np.zeros(9)\n    for i in range(3):  # eta node index\n        for j in range(3):  # xi node index\n            n_vec[i * 3 + j] = l_xi[j] * l_eta[i]\n    return n_vec\n\ndef shape_derivatives(xi: float, eta: float) -> tuple[np.ndarray, np.ndarray]:\n    \"\"\"Computes derivatives of shape functions w.r.t. xi and eta.\"\"\"\n    l_xi = one_d_basis(xi)\n    dl_xi = one_d_basis_deriv(xi)\n    l_eta = one_d_basis(eta)\n    dl_eta = one_d_basis_deriv(eta)\n    \n    dn_dxi = np.zeros(9)\n    dn_deta = np.zeros(9)\n    \n    for i in range(3):\n        for j in range(3):\n            k = i * 3 + j\n            dn_dxi[k] = dl_xi[j] * l_eta[i]\n            dn_deta[k] = l_xi[j] * dl_eta[i]\n            \n    return dn_dxi, dn_deta\n\ndef jacobian(xi: float, eta: float, physical_nodes: np.ndarray) -> np.ndarray:\n    \"\"\"Computes the Jacobian matrix of the mapping at (xi, eta).\"\"\"\n    dn_dxi, dn_deta = shape_derivatives(xi, eta)\n    \n    # J is a 2x2 matrix\n    # J[0,0] = dN_dxi . x_coords, J[1,0] = dN_dxi . y_coords\n    # J[0,1] = dN_deta . x_coords, J[1,1] = dN_deta . y_coords\n    \n    j_matrix = np.zeros((2, 2))\n    j_matrix[:, 0] = np.dot(dn_dxi, physical_nodes)   # d(x,y)/dxi\n    j_matrix[:, 1] = np.dot(dn_deta, physical_nodes) # d(x,y)/deta\n    \n    return j_matrix\n\ndef f_analytic(x: float, y: float) -> float:\n    \"\"\"The analytic scalar field.\"\"\"\n    return np.sin(np.pi * x) * np.cos(np.pi * y)\n\ndef calculate_all_metrics(physical_nodes: np.ndarray) -> list[float]:\n    \"\"\"\n    Computes all required distortion and accuracy metrics for a given element.\n    \"\"\"\n    n_s = 7\n    q_h = 7\n    q_l = 3\n\n    # 1. Compute distortion metrics\n    s_vals, r_vals, det_j_vals = [], [], []\n    sample_points_1d = -1.0 + 2.0 * (np.arange(n_s) + 1.0) / (n_s + 1.0)\n\n    for eta_s in sample_points_1d:\n        for xi_s in sample_points_1d:\n            j_mat = jacobian(xi_s, eta_s, physical_nodes)\n            a, b = j_mat[:, 0], j_mat[:, 1]\n\n            # Skewness\n            norm_a = np.linalg.norm(a)\n            norm_b = np.linalg.norm(b)\n            if norm_a > 1e-12 and norm_b > 1e-12:\n                cos_theta = np.dot(a, b) / (norm_a * norm_b)\n                s_vals.append(np.abs(cos_theta))\n            else: # Should not happen for valid elements\n                s_vals.append(0.0)\n\n            # Aspect ratio from singular values\n            _, s_svd, _ = np.linalg.svd(j_mat)\n            if s_svd.min() > 1e-12:\n                r_vals.append(s_svd.max() / s_svd.min())\n            else: # Folded element\n                r_vals.append(np.inf)\n\n            # Jacobian determinant\n            det_j_vals.append(np.linalg.det(j_mat))\n\n    s_mean = np.mean(s_vals)\n    r_mean = np.mean(r_vals)\n    min_det_j = np.min(det_j_vals)\n    \n    # 2. Compute L^2 interpolation error\n    xi_h, w_h = np.polynomial.legendre.leggauss(q_h)\n    f_at_nodes = f_analytic(physical_nodes[:, 0], physical_nodes[:, 1])\n\n    error_integral_sum = 0.0\n    for w_eta, eta_q in zip(w_h, xi_h):\n        for w_xi, xi_q in zip(w_h, xi_h):\n            n_vec = shape_functions(xi_q, eta_q)\n            f_h = np.dot(n_vec, f_at_nodes)\n            \n            x_mapped, y_mapped = np.dot(n_vec, physical_nodes)\n            f_true = f_analytic(x_mapped, y_mapped)\n            \n            det_j = np.linalg.det(jacobian(xi_q, eta_q, physical_nodes))\n            \n            error_integral_sum += (f_true - f_h)**2 * np.abs(det_j) * w_xi * w_eta\n    \n    l2_error = np.sqrt(error_integral_sum)\n    \n    # 3. Compute integration accuracy\n    # I_ref (high order, q_h=7)\n    i_ref = 0.0\n    for w_eta, eta_q in zip(w_h, xi_h):\n        for w_xi, xi_q in zip(w_h, xi_h):\n            n_vec = shape_functions(xi_q, eta_q)\n            x_mapped, y_mapped = np.dot(n_vec, physical_nodes)\n            f_true = f_analytic(x_mapped, y_mapped)\n            det_j = np.linalg.det(jacobian(xi_q, eta_q, physical_nodes))\n            i_ref += f_true * np.abs(det_j) * w_xi * w_eta\n\n    # I (low order, q_l=3)\n    xi_l, w_l = np.polynomial.legendre.leggauss(q_l)\n    i_low = 0.0\n    for w_eta, eta_q in zip(w_l, xi_l):\n        for w_xi, xi_q in zip(w_l, xi_l):\n            n_vec = shape_functions(xi_q, eta_q)\n            x_mapped, y_mapped = np.dot(n_vec, physical_nodes)\n            f_true = f_analytic(x_mapped, y_mapped)\n            det_j = np.linalg.det(jacobian(xi_q, eta_q, physical_nodes))\n            i_low += f_true * np.abs(det_j) * w_xi * w_eta\n            \n    int_error = np.abs(i_low - i_ref)\n    \n    return [s_mean, r_mean, min_det_j, l2_error, int_error]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1\n        [(0.0, 0.0), (1.0, -0.03), (2.0, 0.05),\n         (-0.02, 0.5), (1.02, 0.52), (2.03, 0.5),\n         (0.0, 1.0), (1.0, 1.03), (2.0, 1.05)],\n        # Test Case 2\n        [(0.0, 0.0), (1.0, 0.10), (2.0, 0.3),\n         (0.03, 0.42), (1.07, 0.57), (2.08, 0.68),\n         (0.1, 0.8), (1.12, 0.97), (2.1, 1.1)],\n        # Test Case 3\n        [(0.0, 0.0), (1.5, 0.06), (3.0, 0.2),\n         (0.2, 0.22), (1.62, 0.27), (3.15, 0.33),\n         (0.5, 0.4), (1.9, 0.47), (3.2, 0.5)]\n    ]\n\n    all_results = []\n    for case_nodes in test_cases:\n        physical_nodes_arr = np.array(case_nodes)\n        metrics = calculate_all_metrics(physical_nodes_arr)\n        all_results.append(metrics)\n\n    # Final print statement in the exact required format.\n    print(f\"[[{', '.join(f'{x:.8f}' for x in all_results[0])}], [{', '.join(f'{x:.8f}' for x in all_results[1])}], [{', '.join(f'{x:.8f}' for x in all_results[2])}]]\")\n\nsolve()\n```", "id": "3320978"}]}