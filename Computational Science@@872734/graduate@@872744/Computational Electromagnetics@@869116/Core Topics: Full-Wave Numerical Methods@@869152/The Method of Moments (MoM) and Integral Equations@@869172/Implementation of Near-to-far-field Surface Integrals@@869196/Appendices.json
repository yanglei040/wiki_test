{"hands_on_practices": [{"introduction": "A robust implementation of a near-to-far-field transform must not only be numerically correct but also consistent with fundamental physical laws. This first practice guides you through the process of verifying your algorithm against the Lorentz reciprocity theorem. By computing the transfer function between two antennas and confirming its symmetry when their roles as transmitter and receiver are swapped, you will perform an end-to-end validation of your entire numerical pipeline, from the generation of near-fields to the final far-field integration [@problem_id:3317922].", "problem": "You are to implement a complete algorithm based on first principles of electromagnetics to validate electromagnetic reciprocity using a near-to-far-field surface integral constructed from tangential fields on a closed surface. The goal is to compute the complex transfer quantities between two infinitesimal antennas using only the fields measured on a Huygens surface and then to verify that the transfer function is symmetric when transmitter and receiver roles are swapped, up to a specified tolerance due to discretization.\n\nStart from the fundamental time-harmonic Maxwell equations in free space with angular frequency $\\omega$, wavenumber $k$, permittivity $\\varepsilon_0$, permeability $\\mu_0$, and intrinsic impedance $\\eta_0$. Use the electromagnetic equivalence principle on a closed surface to represent radiated fields through equivalent electric and magnetic surface currents constructed from the tangential near fields on the surface. Model each antenna as an infinitesimal electric dipole with a specified electric dipole moment vector inside the surface. Derive expressions for the near fields of a point electric dipole source that are valid throughout the near zone, and then express the far field at any observation direction in terms of surface-only quantities via a near-to-far transformation based on those equivalent currents. Use these derived expressions to numerically compute the transfer functions and test symmetry.\n\nScenario specification:\n- Medium: free space with permittivity $\\varepsilon_0$ in $\\mathrm{F/m}$, permeability $\\mu_0$ in $\\mathrm{H/m}$, wavenumber $k = \\omega \\sqrt{\\mu_0 \\varepsilon_0}$ in $\\mathrm{rad/m}$, and intrinsic impedance $\\eta_0 = \\sqrt{\\mu_0 / \\varepsilon_0}$ in $\\Omega$.\n- Source model: infinitesimal electric dipole at the origin with electric dipole moment vector $\\mathbf{p}$ in $\\mathrm{C \\cdot m}$, time dependence $\\mathrm{e}^{j \\omega t}$.\n- Measurement surface $S$: a cube of side length $L$ centered at the origin, discretized into $N \\times N$ patches per face. For each patch, use its center position $\\mathbf{r}'$, unit normal $\\hat{\\mathbf{n}}(\\mathbf{r}')$, and area $\\Delta S$.\n- Equivalent currents on $S$: construct using the tangential electric field $\\mathbf{E}(\\mathbf{r}')$ and magnetic field $\\mathbf{H}(\\mathbf{r}')$ on $S$.\n- Far-field evaluation: at a point at distance $R$ along unit direction $\\hat{\\mathbf{k}}$, compute the radiated far-zone electric field $\\mathbf{E}_\\infty(\\hat{\\mathbf{k}};R)$ by integrating appropriate combinations of the equivalent currents over $S$.\n- Transfer quantity: for a receiving infinitesimal dipole with unit orientation vector $\\hat{\\mathbf{u}}_{\\mathrm{rx}}$, define a complex scalar proportional to the induced voltage as $S_{21} = \\hat{\\mathbf{u}}_{\\mathrm{rx}} \\cdot \\mathbf{E}_\\infty(\\hat{\\mathbf{k}};R)$ when antenna $\\mathrm{A}$ transmits and $\\mathrm{B}$ receives. When roles are swapped, define $S_{12}$ analogously. You must check $|S_{21} - S_{12}| \\le \\delta$, where $\\delta$ is a specified nonnegative tolerance.\n\nAlgorithmic requirements:\n1. Derive the exact near fields $\\mathbf{E}(\\mathbf{r}')$ and $\\mathbf{H}(\\mathbf{r}')$ on the surface $S$ due to a point electric dipole at the origin with moment $\\mathbf{p}$.\n2. From these surface fields, construct equivalent electric and magnetic surface currents using the equivalence principle on $S$.\n3. Derive a near-to-far-field surface integral based on those equivalent currents that yields the far-zone electric field $\\mathbf{E}_\\infty(\\hat{\\mathbf{k}};R)$ at observation direction $\\hat{\\mathbf{k}}$ and range $R$.\n4. Implement the surface integral numerically on the discretized cube $S$.\n5. Compute the complex transfer scalars $S_{21}$ and $S_{12}$ for specified antenna orientations and observation directions, and verify the symmetry condition within the given tolerance $\\delta$.\n\nUnits:\n- Distances must be expressed in meters.\n- Frequency must be expressed in hertz.\n- The transfer quantities $S_{21}$ and $S_{12}$ and the absolute difference must be treated as dimensionless complex and real quantities, respectively.\n\nTest suite:\nFor each test, the transmitter is an infinitesimal electric dipole at the origin enclosed by the same cube surface $S$. The receiver is placed in the far zone at distance $R$ along a specified unit direction. When roles are swapped, repeat with the transmitter at the origin but with the receiver placed at the opposite direction to preserve a symmetric free-space path length. Use the following test cases with parameters:\n\n- Test 1 (happy path):\n  - Cube side length $L = 1.0$ meters.\n  - Discretization $N = 24$ patches per face dimension.\n  - Frequency $f = 300 \\times 10^6$ hertz.\n  - Range $R = 20.0$ meters.\n  - Transmitter orientation $\\hat{\\mathbf{u}}_{\\mathrm{A}} = [0, 1, 0]$.\n  - Receiver orientation $\\hat{\\mathbf{u}}_{\\mathrm{B}} = [1, 0, 0]$.\n  - Receiver direction $\\hat{\\mathbf{k}}_{\\mathrm{B}} = [1, 0, 0]$; swapped receiver direction $\\hat{\\mathbf{k}}_{\\mathrm{A}} = [-1, 0, 0]$.\n  - Tolerance $\\delta = 1 \\times 10^{-3}$.\n\n- Test 2 (coarser discretization, looser tolerance):\n  - $L = 1.0$ meters, $N = 8$, $f = 300 \\times 10^6$ hertz, $R = 20.0$ meters.\n  - $\\hat{\\mathbf{u}}_{\\mathrm{A}} = [0, 1, 0]$, $\\hat{\\mathbf{u}}_{\\mathrm{B}} = [1, 0, 0]$.\n  - $\\hat{\\mathbf{k}}_{\\mathrm{B}} = [1, 0, 0]$, $\\hat{\\mathbf{k}}_{\\mathrm{A}} = [-1, 0, 0]$.\n  - $\\delta = 1 \\times 10^{-2}$.\n\n- Test 3 (axial null edge case):\n  - $L = 1.0$ meters, $N = 12$, $f = 300 \\times 10^6$ hertz, $R = 20.0$ meters.\n  - $\\hat{\\mathbf{u}}_{\\mathrm{A}} = [0, 0, 1]$, $\\hat{\\mathbf{u}}_{\\mathrm{B}} = [0, 0, 1]$.\n  - $\\hat{\\mathbf{k}}_{\\mathrm{B}} = [0, 0, 1]$, $\\hat{\\mathbf{k}}_{\\mathrm{A}} = [0, 0, -1]$.\n  - $\\delta = 2 \\times 10^{-3}$.\n\nProgram output specification:\nYour program must produce a single line containing a comma-separated Python list of booleans corresponding to the three tests, in the order listed. Each boolean must be $\\mathrm{True}$ if the symmetry condition $|S_{21} - S_{12}| \\le \\delta$ is satisfied for that test, and $\\mathrm{False}$ otherwise. For example, the output format must be exactly like $\\left[\\mathrm{True},\\mathrm{False},\\mathrm{True}\\right]$.", "solution": "The user problem is a valid and well-posed task in computational electromagnetics. It requires the implementation of a numerical algorithm to verify the principle of electromagnetic reciprocity. The solution will proceed by first deriving the necessary theoretical expressions from first principles and then detailing the numerical algorithm for their implementation.\n\n### 1. Theoretical Foundation\n\nThe analysis is based on time-harmonic Maxwell's equations in free space, assuming a time-dependence of $e^{j \\omega t}$. The medium is characterized by permittivity $\\varepsilon_0$, permeability $\\mu_0$, angular frequency $\\omega$, wavenumber $k = \\omega / c = \\omega\\sqrt{\\mu_0\\varepsilon_0}$, and intrinsic impedance $\\eta_0 = \\sqrt{\\mu_0/\\varepsilon_0}$.\n\n#### 1.1 Fields of an Infinitesimal Electric Dipole\n\nAn infinitesimal electric dipole located at the origin with a dipole moment vector $\\mathbf{p}$ generates electric and magnetic fields throughout space. The exact expressions for these fields at a position vector $\\mathbf{r}$ (where $r=|\\mathbf{r}|$ and $\\hat{\\mathbf{r}}=\\mathbf{r}/r$) are given by:\n\nThe electric field $\\mathbf{E}(\\mathbf{r})$ is:\n$$\n\\mathbf{E}(\\mathbf{r}; \\mathbf{p}) = \\frac{e^{-jkr}}{4\\pi\\varepsilon_0} \\left\\{ k^2 \\frac{(\\hat{\\mathbf{r}} \\times \\mathbf{p}) \\times \\hat{\\mathbf{r}}}{r} + \\left(\\frac{1}{r^3} + \\frac{jk}{r^2}\\right) \\left(3\\hat{\\mathbf{r}}(\\hat{\\mathbf{r}}\\cdot\\mathbf{p}) - \\mathbf{p}\\right) \\right\\}\n$$\nThe magnetic field $\\mathbf{H}(\\mathbf{r})$ is:\n$$\n\\mathbf{H}(\\mathbf{r}; \\mathbf{p}) = \\frac{j\\omega}{4\\pi} \\left(jk + \\frac{1}{r}\\right) \\frac{e^{-jkr}}{r} (\\mathbf{p} \\times \\hat{\\mathbf{r}})\n$$\nThese formulas are valid in both the near-field and far-field regions and will be used to determine the tangential fields on the Huygens surface. For the purpose of the numerical calculation, the dipole moment magnitude is taken to be unity, i.e., $\\mathbf{p} = \\hat{\\mathbf{u}}$ where $\\hat{\\mathbf{u}}$ is the specified orientation vector.\n\n#### 1.2 Electromagnetic Equivalence Principle\n\nThe electromagnetic equivalence principle (a form of Huygens' principle) allows for the calculation of fields radiated by a source contained within a closed surface $S$ by replacing the source with a set of equivalent electric and magnetic surface currents on $S$. These currents are defined based on the tangential components of the fields on the surface. For an outward-pointing normal vector $\\hat{\\mathbf{n}}(\\mathbf{r}')$ at a point $\\mathbf{r}'$ on $S$, the equivalent currents are:\n\nEquivalent electric surface current:\n$$\n\\mathbf{J}_s(\\mathbf{r}') = \\hat{\\mathbf{n}}(\\mathbf{r}') \\times \\mathbf{H}(\\mathbf{r}')\n$$\nEquivalent magnetic surface current:\n$$\n\\mathbf{M}_s(\\mathbf{r}') = -\\hat{\\mathbf{n}}(\\mathbf{r}') \\times \\mathbf{E}(\\mathbf{r}')\n$$\nThese currents, radiating in free space, replicate the fields of the original source everywhere outside of $S$.\n\n#### 1.3 Near-to-Far-Field Transformation (NFFT)\n\nThe far-zone electric field produced by these surface currents can be calculated by a surface integral. The far-field approximation simplifies the Green's function in the integral formulation. We first define the radiation vectors $\\mathbf{N}(\\hat{\\mathbf{k}})$ and $\\mathbf{L}(\\hat{\\mathbf{k}})$ for a given far-field observation direction $\\hat{\\mathbf{k}}$:\n$$\n\\mathbf{N}(\\hat{\\mathbf{k}}) = \\iint_S \\mathbf{J}_s(\\mathbf{r}') e^{jk\\hat{\\mathbf{k}}\\cdot\\mathbf{r}'} dS'\n$$\n$$\n\\mathbf{L}(\\hat{\\mathbf{k}}) = \\iint_S \\mathbf{M}_s(\\mathbf{r}') e^{jk\\hat{\\mathbf{k}}\\cdot\\mathbf{r}'} dS'\n$$\nThe far-zone electric field $\\mathbf{E}_\\infty$ at a large distance $R$ in the direction $\\hat{\\mathbf{k}}$ is then given by:\n$$\n\\mathbf{E}_\\infty(R\\hat{\\mathbf{k}}) \\approx \\frac{-jk e^{-jkR}}{4\\pi R} \\left[ \\eta_0 \\left(\\mathbf{N}(\\hat{\\mathbf{k}}) - \\left(\\mathbf{N}(\\hat{\\mathbf{k}}) \\cdot \\hat{\\mathbf{k}}\\right)\\hat{\\mathbf{k}}\\right) + \\left(\\mathbf{L}(\\hat{\\mathbf{k}}) \\times \\hat{\\mathbf{k}}\\right) \\right]\n$$\nThe term $\\mathbf{N} - (\\mathbf{N} \\cdot \\hat{\\mathbf{k}})\\hat{\\mathbf{k}}$ represents the component of $\\mathbf{N}$ that is transverse to the direction of propagation $\\hat{\\mathbf{k}}$. The cross product $\\mathbf{L} \\times \\hat{\\mathbf{k}}$ is also inherently transverse.\n\n### 2. Reciprocity Verification\n\nThe Lorentz reciprocity theorem, applied to two sets of sources $(\\mathbf{J}_1, \\mathbf{M}_1)$ and $(\\mathbf{J}_2, \\mathbf{M}_2)$, leads to relations between the fields they produce. For two infinitesimal electric dipoles, $\\mathbf{p}_1$ at $\\mathbf{r}_1$ and $\\mathbf{p}_2$ at $\\mathbf{r}_2$, the theorem implies $\\mathbf{p}_1 \\cdot \\mathbf{E}_2(\\mathbf{r}_1) = \\mathbf{p}_2 \\cdot \\mathbf{E}_1(\\mathbf{r}_2)$.\n\nIn this problem, a specific test for reciprocity is defined:\n1.  **For $S_{21}$**: A transmitter (A) with moment $\\mathbf{p}_A$ is at the origin. The far-field $\\mathbf{E}_{\\infty, A}$ is measured at direction $\\hat{\\mathbf{k}}_B$. The transfer quantity is the projection of this field onto the receiver's (B) orientation $\\hat{\\mathbf{u}}_B$: $S_{21} = \\hat{\\mathbf{u}}_B \\cdot \\mathbf{E}_{\\infty, A}(R\\hat{\\mathbf{k}}_B; \\mathbf{p}_A)$.\n\n2.  **For $S_{12}$**: The roles are swapped. The transmitter (B) with moment $\\mathbf{p}_B$ is now at the origin. The receiver (A) is in the far field at the opposite direction, $\\hat{\\mathbf{k}}_A = -\\hat{\\mathbf{k}}_B$. The transfer quantity is $S_{12} = \\hat{\\mathbf{u}}_A \\cdot \\mathbf{E}_{\\infty, B}(R\\hat{\\mathbf{k}}_A; \\mathbf{p}_B)$.\n\nAnalytically, the far-field of a dipole $\\mathbf{p}$ at the origin is $\\mathbf{E}_\\infty \\propto (\\hat{\\mathbf{k}} \\times \\mathbf{p}) \\times \\hat{\\mathbf{k}}$.\n$S_{21}$ is proportional to $\\hat{\\mathbf{u}}_B \\cdot ((\\hat{\\mathbf{k}}_B \\times \\mathbf{p}_A) \\times \\hat{\\mathbf{k}}_B) = (\\mathbf{p}_A \\cdot \\hat{\\mathbf{u}}_B) - (\\mathbf{p}_A \\cdot \\hat{\\mathbf{k}}_B)(\\hat{\\mathbf{u}}_B \\cdot \\hat{\\mathbf{k}}_B)$.\n$S_{12}$ is proportional to $\\hat{\\mathbf{u}}_A \\cdot ((\\hat{\\mathbf{k}}_A \\times \\mathbf{p}_B) \\times \\hat{\\mathbf{k}}_A)$. Substituting $\\hat{\\mathbf{k}}_A = -\\hat{\\mathbf{k}}_B$, this becomes $\\hat{\\mathbf{u}}_A \\cdot ((\\hat{\\mathbf{k}}_B \\times \\mathbf{p}_B) \\times \\hat{\\mathbf{k}}_B) = (\\mathbf{p}_B \\cdot \\hat{\\mathbf{u}}_A) - (\\mathbf{p}_B \\cdot \\hat{\\mathbf{k}}_B)(\\hat{\\mathbf{u}}_A \\cdot \\hat{\\mathbf{k}}_B)$.\nWith $\\mathbf{p}_A = \\hat{\\mathbf{u}}_A$ and $\\mathbf{p}_B = \\hat{\\mathbf{u}}_B$, the two expressions are identical, confirming that $S_{21}=S_{12}$ analytically. The numerical computation will introduce errors, and the goal is to verify that these errors are small and the symmetry holds within the tolerance $\\delta$.\n\n### 3. Numerical Algorithm\n\nThe surface integrals for the radiation vectors $\\mathbf{N}$ and $\\mathbf{L}$ are approximated by a summation over a discretized surface.\n\n1.  **Surface Discretization**: The cubic Huygens surface of side length $L$ is divided into $6$ faces. Each face is discretized into an $N \\times N$ grid of square patches. For each patch $i$, its center position $\\mathbf{r}'_i$, outward unit normal vector $\\hat{\\mathbf{n}}_i$, and area $\\Delta S = (L/N)^2$ are computed.\n\n2.  **Integration via Summation**: The integrals for $\\mathbf{N}$ and $\\mathbf{L}$ are computed as Riemann sums:\n    $$\n    \\mathbf{N}(\\hat{\\mathbf{k}}) \\approx \\sum_{i=1}^{6N^2} \\mathbf{J}_s(\\mathbf{r}'_i) e^{jk\\hat{\\mathbf{k}}\\cdot\\mathbf{r}'_i} \\Delta S\n    $$\n    $$\n    \\mathbf{L}(\\hat{\\mathbf{k}}) \\approx \\sum_{i=1}^{6N^2} \\mathbf{M}_s(\\mathbf{r}'_i) e^{jk\\hat{\\mathbf{k}}\\cdot\\mathbf{r}'_i} \\Delta S\n    $$\n\n3.  **Computational Steps**: For each test case, the algorithm proceeds as follows:\n    a. Calculate physical constants based on the given frequency $f$: $\\omega=2\\pi f$, $k=\\omega/c$.\n    b. Generate the mesh of patches for the cubic surface.\n    c. **Compute $S_{21}$**:\n        i. Set $\\mathbf{p} = \\hat{\\mathbf{u}}_A$.\n        ii. Numerically compute $\\mathbf{N}_A(\\hat{\\mathbf{k}}_B)$ and $\\mathbf{L}_A(\\hat{\\mathbf{k}}_B)$ by summing over all patches. For each patch, this involves evaluating $\\mathbf{E}(\\mathbf{r}'_i; \\mathbf{p})$ and $\\mathbf{H}(\\mathbf{r}'_i; \\mathbf{p})$ to find the equivalent currents.\n        iii. Calculate $\\mathbf{E}_{\\infty, A}$ using the NFFT formula with $\\mathbf{N}_A$, $\\mathbf{L}_A$, and $\\hat{\\mathbf{k}}_B$.\n        iv. Compute $S_{21} = \\hat{\\mathbf{u}}_B \\cdot \\mathbf{E}_{\\infty, A}$.\n    d. **Compute $S_{12}$**:\n        i. Set $\\mathbf{p} = \\hat{\\mathbf{u}}_B$.\n        ii. Numerically compute $\\mathbf{N}_B(\\hat{\\mathbf{k}}_A)$ and $\\mathbf{L}_B(\\hat{\\mathbf{k}}_A)$ by summing over all patches, using the far-field direction $\\hat{\\mathbf{k}}_A$.\n        iii. Calculate $\\mathbf{E}_{\\infty, B}$ using the NFFT formula with $\\mathbf{N}_B$, $\\mathbf{L}_B$, and $\\hat{\\mathbf{k}}_A$.\n        iv. Compute $S_{12} = \\hat{\\mathbf{u}}_A \\cdot \\mathbf{E}_{\\infty, B}$.\n    e. **Verification**: Check if the condition $|S_{21} - S_{12}| \\le \\delta$ is met. The result is a Boolean value.\n\nThis procedure is repeated for all test cases specified in the problem statement. The fact that the test cases are all analytical nulls provides a stringent test of the numerical method's ability to preserve the underlying physical symmetry, as any computed non-zero field is due to numerical approximation errors.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import constants\n\ndef solve():\n    \"\"\"\n    Main solver function that iterates through test cases and prints the results.\n    \"\"\"\n    # Physical constants\n    c0 = constants.c\n    eps0 = constants.epsilon_0\n    mu0 = constants.mu_0\n    eta0 = np.sqrt(mu0 / eps0)\n    \n    # Test cases from the problem statement\n    test_cases = [\n        {\n            \"L\": 1.0, \"N\": 24, \"f\": 300e6, \"R\": 20.0,\n            \"u_A\": np.array([0, 1, 0]), \"u_B\": np.array([1, 0, 0]),\n            \"k_B\": np.array([1, 0, 0]), \"k_A\": np.array([-1, 0, 0]),\n            \"delta\": 1e-3\n        },\n        {\n            \"L\": 1.0, \"N\": 8, \"f\": 300e6, \"R\": 20.0,\n            \"u_A\": np.array([0, 1, 0]), \"u_B\": np.array([1, 0, 0]),\n            \"k_B\": np.array([1, 0, 0]), \"k_A\": np.array([-1, 0, 0]),\n            \"delta\": 1e-2\n        },\n        {\n            \"L\": 1.0, \"N\": 12, \"f\": 300e6, \"R\": 20.0,\n            \"u_A\": np.array([0, 0, 1]), \"u_B\": np.array([0, 0, 1]),\n            \"k_B\": np.array([0, 0, 1]), \"k_A\": np.array([0, 0, -1]),\n            \"delta\": 2e-3\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        # Unpack parameters\n        L, N, f, R = params[\"L\"], params[\"N\"], params[\"f\"], params[\"R\"]\n        u_A, u_B = params[\"u_A\"], params[\"u_B\"]\n        k_B, k_A = params[\"k_B\"], params[\"k_A\"]\n        delta = params[\"delta\"]\n\n        # Derived parameters\n        omega = 2 * np.pi * f\n        k = omega / c0\n        \n        # Generate the surface mesh\n        patches = generate_cube_surface(L, N)\n        \n        # Calculate S21 and S12\n        s21 = calculate_transfer_quantity(u_A, u_B, k_B, patches, k, omega, R, eps0, eta0)\n        s12 = calculate_transfer_quantity(u_B, u_A, k_A, patches, k, omega, R, eps0, eta0)\n        \n        # Verify reciprocity\n        is_symmetric = np.abs(s21 - s12) = delta\n        results.append(is_symmetric)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef generate_cube_surface(L, N):\n    \"\"\"\n    Generates a list of patches for a cube surface centered at the origin.\n    Each patch is represented by its center, normal vector, and area.\n    \"\"\"\n    patches = []\n    dL = L / N\n    dS = dL * dL\n    \n    # Grid for one face\n    grid_coords = np.linspace(-L/2 + dL/2, L/2 - dL/2, N)\n    \n    # +/- X faces\n    for i in range(N):\n        for j in range(N):\n            # +X face\n            patches.append((np.array([L/2, grid_coords[i], grid_coords[j]]), np.array([1, 0, 0]), dS))\n            # -X face\n            patches.append((np.array([-L/2, grid_coords[i], grid_coords[j]]), np.array([-1, 0, 0]), dS))\n    \n    # +/- Y faces\n    for i in range(N):\n        for j in range(N):\n            # +Y face\n            patches.append((np.array([grid_coords[i], L/2, grid_coords[j]]), np.array([0, 1, 0]), dS))\n            # -Y face\n            patches.append((np.array([grid_coords[i], -L/2, grid_coords[j]]), np.array([0, -1, 0]), dS))\n    \n    # +/- Z faces\n    for i in range(N):\n        for j in range(N):\n            # +Z face\n            patches.append((np.array([grid_coords[i], grid_coords[j], L/2]), np.array([0, 0, 1]), dS))\n            # -Z face\n            patches.append((np.array([grid_coords[i], grid_coords[j], -L/2]), np.array([0, 0, -1]), dS))\n            \n    return patches\n\n\ndef get_dipole_fields(r_prime, p, k, omega, eps0):\n    \"\"\"\n    Calculates the E and H fields from an infinitesimal dipole at the origin.\n    Args:\n        r_prime (np.ndarray): Position vector of the observation point.\n        p (np.ndarray): Dipole moment vector.\n        k (float): Wavenumber.\n        omega (float): Angular frequency.\n        eps0 (float): Vacuum permittivity.\n    Returns:\n        (E_field, H_field) tuple of np.ndarray.\n    \"\"\"\n    r_norm = np.linalg.norm(r_prime)\n    if r_norm == 0:\n        # Avoid singularity at the origin, though not expected for surface points\n        return (np.zeros(3, dtype=complex), np.zeros(3, dtype=complex))\n    \n    r_hat = r_prime / r_norm\n    \n    # Common phase factor\n    exp_term = np.exp(-1j * k * r_norm)\n\n    # E-field calculation\n    r_hat_dot_p = np.dot(r_hat, p)\n    term1_E = k**2 * np.cross(np.cross(r_hat, p), r_hat) / r_norm\n    term2_E = (1 / r_norm**3 + 1j * k / r_norm**2) * (3 * r_hat * r_hat_dot_p - p)\n    E_field = (exp_term / (4 * np.pi * eps0)) * (term1_E + term2_E)\n    \n    # H-field calculation\n    p_cross_r_hat = np.cross(p, r_hat)\n    term1_H = (1j * k + 1 / r_norm) * (exp_term / r_norm) * p_cross_r_hat\n    H_field = (1j * omega / (4 * np.pi)) * term1_H\n    \n    return E_field, H_field\n\ndef calculate_transfer_quantity(p_tx, u_rx, k_hat_rx, patches, k, omega, R, eps0, eta0):\n    \"\"\"\n    Calculates a single transfer quantity S_ij using the NFFT algorithm.\n    Args:\n        p_tx (np.ndarray): Transmitter dipole orientation vector.\n        u_rx (np.ndarray): Receiver dipole orientation vector.\n        k_hat_rx (np.ndarray): Receiver far-field direction vector.\n        patches (list): List of surface patches.\n        k, omega, R, eps0, eta0: Physical parameters.\n    Returns:\n        Complex scalar transfer quantity S_ij.\n    \"\"\"\n    # Dipole moment p0 is assumed to be 1 C.m\n    p_vec = p_tx.astype(float)\n    \n    N_rad = np.zeros(3, dtype=complex)\n    L_rad = np.zeros(3, dtype=complex)\n    \n    for r_prime, n_hat, dS in patches:\n        # Calculate near fields on the patch\n        E_near, H_near = get_dipole_fields(r_prime, p_vec, k, omega, eps0)\n\n        # Calculate equivalent currents\n        Js = np.cross(n_hat, H_near)\n        Ms = -np.cross(n_hat, E_near)\n        \n        # Phase term for NFFT integral\n        phase_term = np.exp(1j * k * np.dot(k_hat_rx, r_prime))\n        \n        # Accumulate radiation vectors (numerical integration)\n        N_rad += Js * phase_term * dS\n        L_rad += Ms * phase_term * dS\n        \n    # Calculate far-field vector F\n    N_transverse = N_rad - np.dot(N_rad, k_hat_rx) * k_hat_rx\n    L_cross_k = np.cross(L_rad, k_hat_rx)\n    F_vector = eta0 * N_transverse + L_cross_k\n    \n    # Calculate full far-field E_infinity\n    prefactor = (-1j * k * np.exp(-1j * k * R)) / (4 * np.pi * R)\n    E_inf = prefactor * F_vector\n    \n    # Compute transfer quantity\n    S = np.dot(u_rx, E_inf)\n    \n    return S\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3317922"}, {"introduction": "Numerical solvers often introduce subtle, non-physical artifacts into the near-field data used for transformations. This exercise tackles a critical source of error: discretization-induced normal field components on the Huygens surface, which violate the assumptions of the surface equivalence principle. You will derive and implement a projection operator to enforce the correct physical boundary conditions on the discrete data, thereby improving the accuracy and robustness of your far-field results [@problem_id:3317900]. This practice is essential for building confidence in results obtained from real-world, imperfect simulation data.", "problem": "Consider a time-harmonic electromagnetic field with $e^{+i\\omega t}$ convention in a homogeneous, isotropic, source-free medium with permittivity $\\epsilon$, permeability $\\mu$, wavenumber $k=\\omega\\sqrt{\\mu\\epsilon}$, and wave impedance $\\eta=\\sqrt{\\mu/\\epsilon}$. Let $\\mathcal{S}$ be a closed Huygens surface consisting of the six faces of a cube of side length $L$ centered at the origin. Denote by $\\hat{\\mathbf{n}}(\\mathbf{r})$ the outward unit normal on $\\mathcal{S}$ at surface point $\\mathbf{r}\\in\\mathcal{S}$. The near-to-far-field surface integral uses equivalent electric and magnetic surface currents on $\\mathcal{S}$ to produce the radiated far field in a given observation direction $\\hat{\\mathbf{r}}$.\n\nStarting from the macroscopic Maxwell equations in differential form,\n$$\\nabla\\times\\mathbf{E}= -i\\omega\\mu\\,\\mathbf{H},\\qquad \\nabla\\times\\mathbf{H}= i\\omega\\epsilon\\,\\mathbf{E},\\qquad \\nabla\\cdot\\epsilon\\mathbf{E}=0,\\qquad \\nabla\\cdot\\mu\\mathbf{H}=0,$$\nand the surface equivalence principle, derive principled expressions for the far-zone electric field $\\mathbf{E}_\\infty(\\hat{\\mathbf{r}})$ in terms of surface integrals of equivalent electric and magnetic currents defined on $\\mathcal{S}$. Your derivation must identify the effect of any normal components of the fields on $\\mathcal{S}$ that arise from discretization, and must justify why only tangential components are physically admissible for the Love equivalence formulation on a Huygens surface.\n\nYou are to construct a discrete implementation of the near-to-far-field transform and assess the impact of discretization-induced nonphysical normal components on $\\mathcal{S}$. Specifically:\n\n- Derive a projection operator $\\mathcal{Q}(\\hat{\\mathbf{n}})$ that acts on a vector field sample $\\mathbf{v}\\in\\mathbb{R}^3$ at a surface point and enforces the discrete constraints $\\hat{\\mathbf{n}}\\cdot\\mathbf{E}=0$ and $\\hat{\\mathbf{n}}\\cdot\\mathbf{H}=0$ while minimally perturbing $\\mathbf{v}$ in the Euclidean norm. Express $\\mathcal{Q}$ explicitly in terms of $\\hat{\\mathbf{n}}$.\n\n- Using the surface equivalence principle, express the far-zone field $\\mathbf{E}_\\infty(\\hat{\\mathbf{r}})$ as a functional of the equivalent surface currents. Then provide a discrete quadrature formula that approximates the continuous surface integrals by weighted sums over a uniformly discretized set of surface points on each face of the cube. The quadrature must include the phase factor $e^{ik\\,\\hat{\\mathbf{r}}\\cdot\\mathbf{r}}$ evaluated at each surface point.\n\n- Implement a test scenario in which tangential fields $\\mathbf{E}_t(\\mathbf{r})$ and $\\mathbf{H}_t(\\mathbf{r})=(1/\\eta)\\,\\hat{\\mathbf{n}}(\\mathbf{r})\\times \\mathbf{E}_t(\\mathbf{r})$ are synthesized on $\\mathcal{S}$ via a smooth, face-localized distribution\n$$\\mathbf{E}_t(\\mathbf{r})=\\mathbf{t}_{\\text{face}}(\\mathbf{r})\\,E_0\\,\\exp\\!\\left(-\\frac{\\|\\mathbf{u}_{\\text{face}}(\\mathbf{r})\\|^2}{\\sigma^2}\\right),$$\nwhere $\\mathbf{t}_{\\text{face}}(\\mathbf{r})$ is a unit tangent direction on that face and $\\mathbf{u}_{\\text{face}}(\\mathbf{r})$ is the in-face position vector measured from the center of that face. Use this to define the exact tangential equivalent currents on $\\mathcal{S}$ by $\\mathbf{M}_s(\\mathbf{r})=-\\hat{\\mathbf{n}}(\\mathbf{r})\\times\\mathbf{E}_t(\\mathbf{r})$ and $\\mathbf{J}_s(\\mathbf{r})=\\hat{\\mathbf{n}}(\\mathbf{r})\\times\\mathbf{H}_t(\\mathbf{r})$, and compute a reference far-field $\\mathbf{E}_\\infty^{\\text{ref}}(\\hat{\\mathbf{r}})$ via your discrete near-to-far-field transform.\n\n- Simulate discretization-induced nonphysical normal components by contaminating the measured fields with normal-direction noise and by using perturbed (misaligned) normals $\\tilde{\\mathbf{n}}(\\mathbf{r})$ obtained by rotating $\\hat{\\mathbf{n}}(\\mathbf{r})$ by a small angle around a fixed axis. Define the naive currents $\\mathbf{M}_s^{\\text{naive}}(\\mathbf{r})=-\\tilde{\\mathbf{n}}(\\mathbf{r})\\times\\mathbf{E}_{\\text{meas}}(\\mathbf{r})$ and $\\mathbf{J}_s^{\\text{naive}}(\\mathbf{r})=\\tilde{\\mathbf{n}}(\\mathbf{r})\\times\\mathbf{H}_{\\text{meas}}(\\mathbf{r})$ from the contaminated measurements. Also define the projected fields $\\mathbf{E}_{\\text{proj}}(\\mathbf{r})=\\mathcal{Q}(\\hat{\\mathbf{n}}(\\mathbf{r}))\\,\\mathbf{E}_{\\text{meas}}(\\mathbf{r})$ and $\\mathbf{H}_{\\text{proj}}(\\mathbf{r})=\\mathcal{Q}(\\hat{\\mathbf{n}}(\\mathbf{r}))\\,\\mathbf{H}_{\\text{meas}}(\\mathbf{r})$, and form the corrected currents $\\mathbf{M}_s^{\\text{proj}}(\\mathbf{r})=-\\hat{\\mathbf{n}}(\\mathbf{r})\\times\\mathbf{E}_{\\text{proj}}(\\mathbf{r})$ and $\\mathbf{J}_s^{\\text{proj}}(\\mathbf{r})=\\hat{\\mathbf{n}}(\\mathbf{r})\\times\\mathbf{H}_{\\text{proj}}(\\mathbf{r})$.\n\n- For a set of observation directions $\\{\\hat{\\mathbf{r}}_m\\}$ parameterized by polar angle $\\theta$ and azimuth $\\phi$ in radians, compute the relative $\\ell^2$ error of the naive and projected far fields,\n$$\\varepsilon_{\\text{naive}}=\\sqrt{\\frac{\\sum_m\\|\\mathbf{E}_\\infty^{\\text{naive}}(\\hat{\\mathbf{r}}_m)-\\mathbf{E}_\\infty^{\\text{ref}}(\\hat{\\mathbf{r}}_m)\\|_2^2}{\\sum_m\\|\\mathbf{E}_\\infty^{\\text{ref}}(\\hat{\\mathbf{r}}_m)\\|_2^2}},\\qquad \\varepsilon_{\\text{proj}}=\\sqrt{\\frac{\\sum_m\\|\\mathbf{E}_\\infty^{\\text{proj}}(\\hat{\\mathbf{r}}_m)-\\mathbf{E}_\\infty^{\\text{ref}}(\\hat{\\mathbf{r}}_m)\\|_2^2}{\\sum_m\\|\\mathbf{E}_\\infty^{\\text{ref}}(\\hat{\\mathbf{r}}_m)\\|_2^2}}.$$\nReport the improvement factor $\\rho=\\varepsilon_{\\text{naive}}/\\varepsilon_{\\text{proj}}$.\n\nUse the following physically realistic constants and geometry for numerical evaluation: cube side length $L=1\\,\\mathrm{m}$, speed of light $c=299{,}792{,}458\\,\\mathrm{m/s}$, frequency $f=300\\,\\mathrm{MHz}$, wavelength $\\lambda=c/f=1\\,\\mathrm{m}$, wavenumber $k=2\\pi/\\lambda=2\\pi\\,\\mathrm{rad/m}$, and impedance $\\eta\\approx 376.730313668\\,\\Omega$. Use field amplitude $E_0=1\\,\\mathrm{V/m}$ and Gaussian width $\\sigma=L/3\\,\\mathrm{m}$. Observation directions should be specified by $(\\theta,\\phi)$ in radians. The normal perturbation angle input must be specified in degrees. The surface quadrature should use $N\\times N$ points per face, placed at cell centers, with uniform area weights.\n\nDesign a test suite of $4$ cases to explore different discretization effects:\n- Case $1$: normal perturbation angle $5^\\circ$, contamination amplitudes $\\alpha_E=0$ and $\\alpha_H=0$, and $N=20$.\n- Case $2$: normal perturbation angle $5^\\circ$, contamination amplitudes $\\alpha_E=0.1$ and $\\alpha_H=0.1$, and $N=20$.\n- Case $3$: normal perturbation angle $15^\\circ$, contamination amplitudes $\\alpha_E=0.5$ and $\\alpha_H=0.5$, and $N=20$.\n- Case $4$: normal perturbation angle $10^\\circ$, contamination amplitudes $\\alpha_E=0.2$ and $\\alpha_H=0.2$, and $N=8$.\n\nYour program must compute the improvement factors $\\rho$ for these four cases using a fixed random seed for reproducibility and produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[\\rho_1,\\rho_2,\\rho_3,\\rho_4]$). The output entries must be floating-point numbers. All angles in the observation set must be in radians. No physical units need to be included in the final numerical outputs because the reported quantities are dimensionless.", "solution": "The problem requires the derivation and implementation of a near-to-far-field transformation for electromagnetic fields on a closed cubical surface, with a specific focus on assessing and correcting errors arising from discretization-induced nonphysical field components.\n\n### 1. Theoretical Foundation: The Surface Equivalence Principle and Far-Field Radiation\n\nThe foundation of the near-to-far-field transform is the surface equivalence principle, an extension of Huygens' principle derived from the vector Green's theorem or the Stratton-Chu formulation. It states that the electromagnetic fields $(\\mathbf{E}, \\mathbf{H})$ in a source-free volume $V$ can be exactly reproduced by a set of equivalent electric and magnetic surface currents, $\\mathbf{J}_s$ and $\\mathbf{M}_s$ respectively, placed on the closed surface $\\mathcal{S}$ bounding $V$. These currents radiate in a homogeneous medium identical to that filling $V$. The time-harmonic convention is taken as $e^{+i\\omega t}$.\n\nThe equivalent currents are defined in terms of the tangential components of the fields on $\\mathcal{S}$:\n$$ \\mathbf{J}_s(\\mathbf{r}') = \\hat{\\mathbf{n}}(\\mathbf{r}') \\times \\mathbf{H}(\\mathbf{r}') $$\n$$ \\mathbf{M}_s(\\mathbf{r}') = -\\hat{\\mathbf{n}}(\\mathbf{r}') \\times \\mathbf{E}(\\mathbf{r}') $$\nwhere $\\mathbf{r}' \\in \\mathcal{S}$ is a point on the surface and $\\hat{\\mathbf{n}}(\\mathbf{r}')$ is the outward unit normal.\n\nThese currents produce fields throughout space. The far-zone electric field $\\mathbf{E}_\\infty$ at a large distance $r = \\|\\mathbf{r}\\|$ from the origin in the direction $\\hat{\\mathbf{r}}=\\mathbf{r}/r$ can be found using the far-field approximation of the radiation integrals. The essential step involves approximating the distance from a source point $\\mathbf{r}'$ to the observation point $\\mathbf{r}$ as $\\|\\mathbf{r}-\\mathbf{r}'\\| \\approx r - \\hat{\\mathbf{r}}\\cdot\\mathbf{r}'$. For an outgoing wave with spatial dependence $e^{-ikr}$, the Green's function becomes $\\frac{e^{-ik\\|\\mathbf{r}-\\mathbf{r}'\\|}}{4\\pi\\|\\mathbf{r}-\\mathbf{r}'\\|} \\approx \\frac{e^{-ikr}}{4\\pi r}e^{ik\\hat{\\mathbf{r}}\\cdot\\mathbf{r}'}$.\n\nThe far-field is conveniently expressed in terms of two radiation vectors, $\\mathbf{N}(\\hat{\\mathbf{r}})$ and $\\mathbf{L}(\\hat{\\mathbf{r}})$, which are the spatial Fourier transforms of the surface currents:\n$$ \\mathbf{N}(\\hat{\\mathbf{r}}) = \\iint_{\\mathcal{S}} \\mathbf{J}_s(\\mathbf{r}') e^{ik\\hat{\\mathbf{r}}\\cdot\\mathbf{r}'} dS' $$\n$$ \\mathbf{L}(\\hat{\\mathbf{r}}) = \\iint_{\\mathcal{S}} \\mathbf{M}_s(\\mathbf{r}') e^{ik\\hat{\\mathbf{r}}\\cdot\\mathbf{r}'} dS' $$\nwhere $k=\\omega\\sqrt{\\mu\\epsilon}$ is the wavenumber.\n\nThe far-zone electric field is transverse to the direction of propagation $\\hat{\\mathbf{r}}$ and is given by:\n$$ \\mathbf{E}_\\infty(\\mathbf{r}) \\approx C(r) \\left[ -\\eta \\hat{\\mathbf{r}}\\times(\\hat{\\mathbf{r}}\\times\\mathbf{N}(\\hat{\\mathbf{r}})) - \\hat{\\mathbf{r}}\\times\\mathbf{L}(\\hat{\\mathbf{r}}) \\right] $$\nwhere $C(r) = \\frac{-ik e^{-ikr}}{4\\pi r}$ is a complex scalar representing propagation and decay, and $\\eta=\\sqrt{\\mu/\\epsilon}$ is the wave impedance. Since the error metrics involve ratios of field magnitudes, this common factor $C(r)$ will cancel. We are thus concerned with the vector part of the far field:\n$$ \\mathbf{E}_{\\infty,\\text{vec}}(\\hat{\\mathbf{r}}) = -\\eta \\hat{\\mathbf{r}}\\times(\\hat{\\mathbf{r}}\\times\\mathbf{N}(\\hat{\\mathbf{r}})) - \\hat{\\mathbf{r}}\\times\\mathbf{L}(\\hat{\\mathbf{r}}) $$\nThis expression correctly shows that the far field is transverse, as $\\hat{\\mathbf{r}} \\cdot \\mathbf{E}_{\\infty,\\text{vec}}(\\hat{\\mathbf{r}}) = 0$.\n\n### 2. Role of Field Components and Discretization Errors\n\nThe equivalence principle definitions for $\\mathbf{J}_s$ and $\\mathbf{M}_s$ involve only the tangential components of the fields on $\\mathcal{S}$, since the cross product with $\\hat{\\mathbf{n}}$ annihilates any normal component. In an exact, physical scenario within a source-free region, Maxwell's equations impose $\\nabla\\cdot\\mathbf{E}=0$ and $\\nabla\\cdot\\mathbf{H}=0$. This implies a relationship between the normal field components and the surface divergence of the tangential components, governed by the continuity equations for the equivalent charges and currents: $\\nabla_s \\cdot \\mathbf{J}_s = -i\\omega (\\epsilon \\hat{\\mathbf{n}}\\cdot\\mathbf{E})$ and $\\nabla_s \\cdot \\mathbf{M}_s = -i\\omega (\\mu \\hat{\\mathbf{n}}\\cdot\\mathbf{H})$.\n\nIn numerical simulations (e.g., FDTD, FEM), discretization errors can lead to violations of the divergence-free condition, resulting in spurious, non-physical normal components on the Huygens surface. These sampled fields $(\\mathbf{E}_{\\text{meas}}, \\mathbf{H}_{\\text{meas}})$ may have $\\hat{\\mathbf{n}}\\cdot\\mathbf{E}_{\\text{meas}} \\neq 0$ and $\\hat{\\mathbf{n}}\\cdot\\mathbf{H}_{\\text{meas}} \\neq 0$ in a way that is inconsistent with the tangential fields. Furthermore, the discrete representation of the surface may lead to perturbed normals $\\tilde{\\mathbf{n}} \\neq \\hat{\\mathbf{n}}$.\n\nIf one naively computes the currents using these imperfect data, such as $\\mathbf{J}_s^{\\text{naive}}=\\tilde{\\mathbf{n}}\\times\\mathbf{H}_{\\text{meas}}$, the error is twofold:\n1. The use of the perturbed normal $\\tilde{\\mathbf{n}}$ instead of the true normal $\\hat{\\mathbf{n}}$.\n2. The non-physical normal component of $\\mathbf{H}_{\\text{meas}}$, which should not contribute to the current, erroneously \"leaks\" into the calculation because $\\tilde{\\mathbf{n}}\\times(\\mathbf{H}_{\\text{meas}}\\cdot\\hat{\\mathbf{n}})\\hat{\\mathbf{n}} \\neq 0$ when $\\tilde{\\mathbf{n}}$ is not parallel to $\\hat{\\mathbf{n}}$.\n\n### 3. Error Mitigation via Tangential Projection\n\nTo address these errors, we can enforce the physical constraint that only tangential fields contribute to the currents. This is achieved by projecting the measured fields onto the tangent plane defined by the true normal $\\hat{\\mathbf{n}}$.\nWe seek a projection operator $\\mathcal{Q}(\\hat{\\mathbf{n}})$ that, for any vector $\\mathbf{v}$, produces a vector $\\mathbf{v}_{\\text{proj}}$ such that $\\hat{\\mathbf{n}}\\cdot\\mathbf{v}_{\\text{proj}}=0$ while minimizing the Euclidean distance $\\|\\mathbf{v}-\\mathbf{v}_{\\text{proj}}\\|_2$. This is solved by the standard orthogonal projection. Any vector $\\mathbf{v}$ can be decomposed as $\\mathbf{v} = \\mathbf{v}_{\\|} + \\mathbf{v}_{\\perp}$, where $\\mathbf{v}_{\\|} = (\\mathbf{v}\\cdot\\hat{\\mathbf{n}})\\hat{\\mathbf{n}}$ is the component parallel to $\\hat{\\mathbf{n}}$ and $\\mathbf{v}_{\\perp}$ is the component perpendicular to $\\hat{\\mathbf{n}}$. The desired projection is $\\mathbf{v}_{\\perp}$.\n$$ \\mathcal{Q}(\\hat{\\mathbf{n}})\\mathbf{v} = \\mathbf{v}_{\\perp} = \\mathbf{v} - \\mathbf{v}_{\\|} = \\mathbf{v} - (\\mathbf{v}\\cdot\\hat{\\mathbf{n}})\\hat{\\mathbf{n}} $$\nIn matrix form, with $\\hat{\\mathbf{n}}$ as a column vector, this operator is $\\mathcal{Q}(\\hat{\\mathbf{n}}) = \\mathbf{I} - \\hat{\\mathbf{n}}\\hat{\\mathbf{n}}^T$, where $\\mathbf{I}$ is the $3 \\times 3$ identity matrix.\n\nBy applying this operator to the measured fields, we define the projected fields:\n$$ \\mathbf{E}_{\\text{proj}}(\\mathbf{r}) = \\mathcal{Q}(\\hat{\\mathbf{n}}(\\mathbf{r}))\\,\\mathbf{E}_{\\text{meas}}(\\mathbf{r}) \\qquad \\mathbf{H}_{\\text{proj}}(\\mathbf{r}) = \\mathcal{Q}(\\hat{\\mathbf{n}}(\\mathbf{r}))\\,\\mathbf{H}_{\\text{meas}}(\\mathbf{r}) $$\nThese projected fields are guaranteed to be tangential to the true surface. The corrected currents are then computed using the true normal and these projected fields:\n$$ \\mathbf{M}_s^{\\text{proj}}(\\mathbf{r})=-\\hat{\\mathbf{n}}(\\mathbf{r})\\times\\mathbf{E}_{\\text{proj}}(\\mathbf{r}) \\qquad \\mathbf{J}_s^{\\text{proj}}(\\mathbf{r})=\\hat{\\mathbf{n}}(\\mathbf{r})\\times\\mathbf{H}_{\\text{proj}}(\\mathbf{r}) $$\n\n### 4. Discrete Implementation on a Cubical Surface\n\nThe surface integrals for the radiation vectors $\\mathbf{N}$ and $\\mathbf{L}$ are computed numerically using a quadrature rule. The Huygens surface $\\mathcal{S}$ is a cube of side length $L$ composed of six faces, $\\mathcal{S} = \\bigcup_{j=1}^6 \\mathcal{S}_j$. Each face $\\mathcal{S}_j$ is discretized into an $N \\times N$ uniform grid of cells. The integral over $\\mathcal{S}$ becomes a sum of integrals over the $6N^2$ cells. Using a midpoint rule, the integral is approximated by a weighted sum over the cell centers.\nLet the set of all cell centers on $\\mathcal{S}$ be $\\{\\mathbf{r}_i\\}_{i=1}^{6N^2}$, with each cell having area $\\Delta S = (L/N)^2$. The discrete approximation of the radiation vectors is:\n$$ \\mathbf{N}(\\hat{\\mathbf{r}}) \\approx \\sum_{i=1}^{6N^2} \\mathbf{J}_s(\\mathbf{r}_i) e^{ik\\hat{\\mathbf{r}}\\cdot\\mathbf{r}_i} \\Delta S $$\n$$ \\mathbf{L}(\\hat{\\mathbf{r}}) \\approx \\sum_{i=1}^{6N^2} \\mathbf{M}_s(\\mathbf{r}_i) e^{ik\\hat{\\mathbf{r}}\\cdot\\mathbf{r}_i} \\Delta S $$\n\n### 5. Summary of Numerical Test Procedure\n\nThe problem specifies a numerical experiment to quantify the effectiveness of the projection method.\n1.  **Reference Calculation**: A reference far field $\\mathbf{E}_\\infty^{\\text{ref}}$ is computed from ideal tangential fields $\\mathbf{E}_t, \\mathbf{H}_t$ on the exact surface geometry. The currents are $\\mathbf{M}_s^{\\text{ref}} = -\\hat{\\mathbf{n}}\\times\\mathbf{E}_t$ and $\\mathbf{J}_s^{\\text{ref}} = \\hat{\\mathbf{n}}\\times\\mathbf{H}_t$, where $\\mathbf{E}_t$ is tangential by construction.\n2.  **Naive Calculation**: The fields are contaminated with normal-direction noise to create $\\mathbf{E}_{\\text{meas}}, \\mathbf{H}_{\\text{meas}}$, and the surface normals are perturbed to $\\tilde{\\mathbf{n}}$. A naive far field $\\mathbf{E}_\\infty^{\\text{naive}}$ is computed from currents $\\mathbf{M}_s^{\\text{naive}} = -\\tilde{\\mathbf{n}}\\times\\mathbf{E}_{\\text{meas}}$ and $\\mathbf{J}_s^{\\text{naive}} = \\tilde{\\mathbf{n}}\\times\\mathbf{H}_{\\text{meas}}$.\n3.  **Projected Calculation**: A corrected far field $\\mathbf{E}_\\infty^{\\text{proj}}$ is computed from currents $\\mathbf{M}_s^{\\text{proj}}$ and $\\mathbf{J}_s^{\\text{proj}}$, which are derived from the projected fields $\\mathbf{E}_{\\text{proj}} = \\mathcal{Q}(\\hat{\\mathbf{n}})\\mathbf{E}_{\\text{meas}}$ and $\\mathbf{H}_{\\text{proj}} = \\mathcal{Q}(\\hat{\\mathbf{n}})\\mathbf{H}_{\\text{meas}}$ using the true normal $\\hat{\\mathbf{n}}$.\n\nThe relative $\\ell^2$ errors $\\varepsilon_{\\text{naive}}$ and $\\varepsilon_{\\text{proj}}$ are computed by comparing the naive and projected far fields against the reference over a set of observation directions $\\{\\hat{\\mathbf{r}}_m\\}$. The improvement factor is the ratio $\\rho = \\varepsilon_{\\text{naive}} / \\varepsilon_{\\text{proj}}$, which quantifies the error reduction achieved by the projection method.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the near-to-far-field simulation for the given test cases.\n    \"\"\"\n    # Physical and numerical constants\n    L = 1.0  # Cube side length in meters\n    f = 300.0e6  # Frequency in Hz\n    c = 299792458.0  # Speed of light in m/s\n    # The problem implies using lambda=1m and k=2pi for simplicity.\n    lambda_ = 1.0\n    k = 2 * np.pi / lambda_\n    eta = 376.730313668  # Impedance of free space in Ohms\n    E0 = 1.0  # Field amplitude in V/m\n    sigma = L / 3.0  # Gaussian width\n    \n    # Set fixed random seed for reproducibility\n    np.random.seed(0)\n\n    # Define the observation grid\n    n_theta = 30\n    n_phi = 60\n    theta_vals = np.linspace(1e-3, np.pi - 1e-3, n_theta)  # Avoid poles\n    phi_vals = np.linspace(0, 2 * np.pi, n_phi, endpoint=False)\n    theta_grid, phi_grid = np.meshgrid(theta_vals, phi_vals)\n    r_hats = np.array([\n        np.sin(theta_grid) * np.cos(phi_grid),\n        np.sin(theta_grid) * np.sin(phi_grid),\n        np.cos(theta_grid)\n    ]).T.reshape(-1, 3)\n\n    # Test cases from the problem statement\n    test_cases = [\n        {'angle_deg': 5, 'alpha_E': 0.0, 'alpha_H': 0.0, 'N': 20},\n        {'angle_deg': 5, 'alpha_E': 0.1, 'alpha_H': 0.1, 'N': 20},\n        {'angle_deg': 15, 'alpha_E': 0.5, 'alpha_H': 0.5, 'N': 20},\n        {'angle_deg': 10, 'alpha_E': 0.2, 'alpha_H': 0.2, 'N': 8},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        N = case['N']\n        angle_deg = case['angle_deg']\n        alpha_E = case['alpha_E']\n        alpha_H = case['alpha_H']\n\n        # 1. Generate surface points and normals for the cube\n        ds = (L / N)**2\n        face_centers = L / 2.0 * np.array([\n            [1, 0, 0], [-1, 0, 0], [0, 1, 0], [0, -1, 0], [0, 0, 1], [0, 0, -1]\n        ])\n        \n        # Define tangent vectors for each face for E-field polarization\n        t_vectors = np.array([\n            [0, 1, 0], [0, 1, 0], [0, 0, 1], [0, 0, 1], [1, 0, 0], [1, 0, 0]\n        ])\n\n        u_coords = np.linspace(-L / 2 + L / (2 * N), L / 2 - L / (2 * N), N)\n        v_coords = np.linspace(-L / 2 + L / (2 * N), L / 2 - L / (2 * N), N)\n        u_grid, v_grid = np.meshgrid(u_coords, v_coords)\n        uv_pairs = np.stack([u_grid.ravel(), v_grid.ravel()], axis=-1)\n\n        surface_points = []\n        surface_normals = []\n        tangent_vecs_on_surface = []\n        in_face_vecs_sq_norm = np.sum(uv_pairs**2, axis=1)\n\n        for i, center in enumerate(face_centers):\n            normal = center / np.linalg.norm(center)\n            \n            # Map uv_pairs to 3D points on the face\n            u_ax = t_vectors[i]\n            v_ax = np.cross(normal, u_ax)\n            \n            points_on_face = center + uv_pairs[:, 0, None] * u_ax + uv_pairs[:, 1, None] * v_ax\n            surface_points.append(points_on_face)\n            surface_normals.extend([normal] * (N * N))\n            tangent_vecs_on_surface.extend([u_ax] * (N * N))\n        \n        r_primes = np.concatenate(surface_points)\n        n_hats = np.array(surface_normals)\n        t_faces = np.array(tangent_vecs_on_surface)\n        u_face_sq_norms = np.tile(in_face_vecs_sq_norm, 6)\n\n        # 2. Synthesize fields and currents (Reference, Naive, Projected)\n        \n        # Reference fields (purely tangential)\n        gauss_factor = E0 * np.exp(-u_face_sq_norms / sigma**2)\n        E_t = t_faces * gauss_factor[:, np.newaxis]\n        H_t = (1/eta) * np.cross(n_hats, E_t)\n\n        M_ref = -np.cross(n_hats, E_t)\n        J_ref = np.cross(n_hats, H_t)\n\n        # Measured fields (with noise) and perturbed normals\n        noise_E = np.random.randn(len(r_primes))\n        noise_H = np.random.randn(len(r_primes))\n        E_meas = E_t + n_hats * (alpha_E * E0 * noise_E)[:, np.newaxis]\n        H_meas = H_t + n_hats * (alpha_H * (E0/eta) * noise_H)[:, np.newaxis]\n        \n        rot_axis = np.array([0, 1, 0])\n        angle_rad = np.deg2rad(angle_deg)\n        n_tildes = np.array([\n            v * np.cos(angle_rad) + np.cross(rot_axis, v) * np.sin(angle_rad) + \n            rot_axis * np.dot(rot_axis, v) * (1 - np.cos(angle_rad))\n            for v in n_hats\n        ])\n        \n        # Naive currents\n        M_naive = -np.cross(n_tildes, E_meas)\n        J_naive = np.cross(n_tildes, H_meas)\n        \n        # Projected fields and currents\n        E_proj = E_meas - np.sum(E_meas * n_hats, axis=1)[:, np.newaxis] * n_hats\n        H_proj = H_meas - np.sum(H_meas * n_hats, axis=1)[:, np.newaxis] * n_hats\n        M_proj = -np.cross(n_hats, E_proj)\n        J_proj = np.cross(n_hats, H_proj)\n\n        # 3. Calculate far fields for each case\n        \n        def calculate_far_field(J_s, M_s):\n            phase_matrix = np.exp(1j * k * (r_hats @ r_primes.T))\n            \n            # Using (M, P) @ (P, 3) -> (M, 3) for vectorized calculation\n            N_vecs = phase_matrix @ (J_s * ds)\n            L_vecs = phase_matrix @ (M_s * ds)\n            \n            r_hats_x_L = np.cross(r_hats, L_vecs)\n            r_hats_x_N = np.cross(r_hats, N_vecs)\n            r_hats_x_r_hats_x_N = np.cross(r_hats, r_hats_x_N)\n\n            E_vec = -eta * r_hats_x_r_hats_x_N - r_hats_x_L\n            return E_vec\n\n        E_ff_ref = calculate_far_field(J_ref, M_ref)\n        E_ff_naive = calculate_far_field(J_naive, M_naive)\n        E_ff_proj = calculate_far_field(J_proj, M_proj)\n\n        # 4. Compute errors and improvement factor\n        \n        norm_ref_sq = np.sum(np.abs(E_ff_ref)**2)\n        \n        diff_naive_sq = np.sum(np.abs(E_ff_naive - E_ff_ref)**2)\n        diff_proj_sq = np.sum(np.abs(E_ff_proj - E_ff_ref)**2)\n\n        eps_naive = np.sqrt(diff_naive_sq / norm_ref_sq) if norm_ref_sq > 0 else 0\n        eps_proj = np.sqrt(diff_proj_sq / norm_ref_sq) if norm_ref_sq > 0 else 0\n\n        if eps_proj  1e-15: # If projected error is numerically zero\n            rho = np.inf if eps_naive > 1e-15 else 1.0\n        else:\n            rho = eps_naive / eps_proj\n            \n        results.append(rho)\n\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```", "id": "3317900"}, {"introduction": "In practical simulations, particularly with methods like FDTD or FEM, the near-field recording surface must often be placed near or even inside the domain's absorbing boundary, such as a Perfectly Matched Layer (PML). The PML intentionally alters the fields to absorb them, which contaminates the data needed for a standard free-space transformation. This advanced practice explores how to correct for these effects by deriving and implementing a transformation based on the PML's underlying complex coordinate stretching, a vital technique for accurate far-field analysis in modern computational electromagnetics [@problem_id:3317929].", "problem": "Implement, justify, and assess a near-to-far-field transformation for a two-dimensional scalar transverse-magnetic polarization (TM$^z$) benchmark in free space, when the available near-field data are sampled on a circular contour that lies arbitrarily close to or inside a perfectly matched layer (PML). Your implementation must be based on the scalar Helmholtz formulation and the equivalence principle, and must include a correction derived from an inverse stretching mapping. You must compute and compare the far field obtained with and without the proposed correction on a line-source (two-dimensional Hertzian dipole) benchmark.\n\nStart from the following fundamental base:\n\n- Maxwells equations in the frequency domain imply that the out-of-plane electric field $E_z(\\mathbf{r})$ for TM$^z$ polarization in a homogeneous, isotropic, source-free region satisfies the scalar Helmholtz equation $\\nabla^2 E_z(\\mathbf{r}) + k^2 E_z(\\mathbf{r}) = 0$, where $k = \\omega \\sqrt{\\mu_0 \\epsilon_0}$ is the free-space wavenumber.\n- The Greens function for the two-dimensional scalar Helmholtz equation in free space is $G(\\mathbf{r},\\mathbf{r}') = \\dfrac{\\mathrm{j}}{4} H_0^{(1)}\\!\\left(k \\left\\lVert \\mathbf{r} - \\mathbf{r}' \\right\\rVert \\right)$, where $H_0^{(1)}(\\cdot)$ is the zeroth-order Hankel function of the first kind.\n- The field at an observation point $\\mathbf{r}$ outside a closed contour $\\Gamma$ that encloses sources can be represented by a boundary integral involving $E_z$ and its outward normal derivative $\\partial E_z/\\partial n'$ on $\\Gamma$ and the Greens function $G$ and its outward normal derivative with respect to $\\mathbf{r}' \\in \\Gamma$. Do not assume any shortcut formulas in your design; you must derive and implement the appropriate normal derivatives and measures from these foundations.\n\nDefine the benchmark and data model as follows:\n\n- A two-dimensional line source located at the origin produces the analytic free-space field $E_z^{\\mathrm{free}}(\\mathbf{r}) = H_0^{(1)}\\!\\left(k \\left\\lVert \\mathbf{r} \\right\\rVert \\right)$ and its radial derivative $\\dfrac{\\partial E_z^{\\mathrm{free}}}{\\partial r}(\\mathbf{r}) = -k\\, H_1^{(1)}\\!\\left(k \\left\\lVert \\mathbf{r} \\right\\rVert \\right)$, where $H_1^{(1)}(\\cdot)$ is the first-order Hankel function of the first kind and $r = \\left\\lVert \\mathbf{r} \\right\\rVert$.\n- A radial PML of inner radius $R_0$ and thickness $L$ is modeled by a complex coordinate stretching along the radial direction:\n  $$ s_r(r) = \\begin{cases}\n  1,  r  R_0,\\\\\n  1 + \\mathrm{j}\\,\\alpha \\left(\\dfrac{r - R_0}{L}\\right)^m,  R_0 \\le r \\le R_0 + L,\\\\\n  1 + \\mathrm{j}\\,\\alpha,  r  R_0 + L,\n  \\end{cases}\n  $$\n  and the associated complex-stretched radial coordinate\n  $$ \\tilde{r}(r) = \\begin{cases}\n  r,  r  R_0,\\\\\n  R_0 + \\displaystyle\\int_{R_0}^{r} s_r(\\rho)\\, \\mathrm{d}\\rho,  r \\ge R_0,\n  \\end{cases}\n  $$\n  so that within the PML annulus the analytically simulated recorded field is $E_z^{\\mathrm{rec}}(r) = H_0^{(1)}\\!\\left(k\\,\\tilde{r}(r)\\right)$ and its outward normal derivative with respect to the physical radius is $\\dfrac{\\partial E_z^{\\mathrm{rec}}}{\\partial r}(r) = -k\\,H_1^{(1)}\\!\\left(k\\,\\tilde{r}(r)\\right)\\, s_r(r)$ by the chain rule.\n- The near-field data are sampled on a circular contour $\\Gamma$ of radius $R_c$ centered at the origin, with outward unit normal $\\hat{\\mathbf{n}}'(\\theta)$ and line element $\\mathrm{d}\\ell' = R_c\\,\\mathrm{d}\\theta$, parameterized by the polar angle $\\theta \\in [0, 2\\pi)$.\n\nPropose and implement the following inverse-stretching correction:\n\n- Use the recorded field $E_z^{\\mathrm{rec}}$ directly as the field datum, but correct the outward normal derivative by the inverse metric factor,\n  $$ \\left(\\dfrac{\\partial E_z}{\\partial n'}\\right)_{\\mathrm{corr}} = \\dfrac{1}{s_r(R_c)} \\left(\\dfrac{\\partial E_z^{\\mathrm{rec}}}{\\partial n'}\\right), $$\n  which corresponds to a pullback of the normal derivative under the complex stretch. The line element scaling for a purely radial stretch is left unchanged on a circular contour, i.e., $\\mathrm{d}\\ell'_{\\mathrm{corr}} = \\mathrm{d}\\ell'$.\n- Compute the far field on a circle of observation radius $R_{\\mathrm{obs}}$ using the boundary integral twice: once with the uncorrected data $(E_z^{\\mathrm{rec}},\\, \\partial E_z^{\\mathrm{rec}}/\\partial n')$ and once with the corrected data $(E_z^{\\mathrm{rec}},\\, (\\partial E_z/\\partial n')_{\\mathrm{corr}})$.\n\nNumerical specifications:\n\n- Use the speed of light in vacuum $c_0 = \\dfrac{1}{\\sqrt{\\mu_0 \\epsilon_0}}$ with $\\mu_0 = 4\\pi \\times 10^{-7}\\,\\text{H/m}$ and $\\epsilon_0 = 8.854187817 \\times 10^{-12}\\,\\text{F/m}$. The operating frequency is $f = 3.0 \\times 10^{8}\\,\\text{Hz}$, so that $\\omega = 2\\pi f$ and $k = \\dfrac{\\omega}{c_0}$. Distances are in meters and angles are in radians.\n- Use PML parameters $\\alpha = 2.0$ and $m = 2$ with inner radius $R_0 = 1.0\\,\\text{m}$ and thickness $L = 0.5\\,\\text{m}$.\n- Use the observation circle radius $R_{\\mathrm{obs}} = 5.0\\,\\text{m}$. Evaluate the far field on a uniform grid of angles $\\phi \\in [0, 2\\pi)$.\n\nTest suite:\n\nFor each of the following four contour radii $R_c$, compute the relative root-mean-square error between the numerically reconstructed field on the observation circle and the analytic free-space field $E_z^{\\mathrm{free}}$ for both the uncorrected and corrected cases. Then report the improvement factor, defined as the ratio of corrected error to uncorrected error (a number less than $1$ indicates improvement):\n\n- Case $1$: $R_c = 0.95\\,\\text{m}$ (just inside the physical region).\n- Case $2$: $R_c = 1.00\\,\\text{m}$ (at the PML interface).\n- Case $3$: $R_c = 1.10\\,\\text{m}$ (shallow inside the PML).\n- Case $4$: $R_c = 1.40\\,\\text{m}$ (deep inside the PML).\n\nAlgorithmic constraints:\n\n- Discretize the contour integral using a uniform parameterization in $\\theta$. You must compute the required outward normal derivative of the Greens function from its definition and the chain rule applied to $H_0^{(1)}(\\cdot)$.\n- The final result for each case is a single floating-point number: the improvement factor defined as $\\mathrm{err}_{\\mathrm{corr}} / \\mathrm{err}_{\\mathrm{uncorr}}$, where each error is the square root of the ratio of the angle-averaged squared magnitude of the difference to that of the analytic field.\n\nRequired final output format:\n\n- Your program must produce a single line containing a Python-style list of the four improvement factors in the order of Cases $1$ through $4$, with each element printed as a decimal number. For example, the output format must be exactly like $[x_1,x_2,x_3,x_4]$ (no spaces).\n\nAngle unit: radians. All distances must be in meters. Frequencies are in hertz. The field values are dimensionless complex amplitudes normalized to the analytic Greens function convention adopted above. The output must be the improvement factors as dimensionless real numbers rounded by the default Python string conversion.", "solution": "The problem requires the implementation and assessment of a near-to-far-field (NFTF) transformation for a two-dimensional scalar transverse-magnetic (TM$^z$) wave problem. The transformation must handle near-field data sampled on a circular contour $\\Gamma$ that may lie within a perfectly matched layer (PML). The solution is based on the scalar Kirchhoff-Helmholtz boundary integral, derived from Green's second identity, and incorporates a proposed correction for the PML interference.\n\n**1. Theoretical Foundation: The Boundary Integral Equation**\n\nThe out-of-plane electric field component $E_z(\\mathbf{r})$ for a TM$^z$ wave in a source-free, homogeneous, and isotropic region satisfies the scalar Helmholtz equation:\n$$\n\\nabla^2 E_z(\\mathbf{r}) + k^2 E_z(\\mathbf{r}) = 0\n$$\nwhere $k = \\omega/c_0$ is the free-space wavenumber, $\\omega = 2\\pi f$ is the angular frequency, and $c_0$ is the speed of light in vacuum.\n\nThe field $E_z(\\mathbf{r})$ at an observation point $\\mathbf{r}$ located outside a closed region $\\Omega$ containing all sources can be reconstructed from the field values on its boundary contour $\\Gamma = \\partial\\Omega$. This is given by the Kirchhoff-Helmholtz boundary integral formula:\n$$\nE_z(\\mathbf{r}) = \\oint_{\\Gamma} \\left[ E_z(\\mathbf{r}') \\frac{\\partial G(\\mathbf{r}, \\mathbf{r}')}{\\partial n'} - G(\\mathbf{r}, \\mathbf{r}') \\frac{\\partial E_z(\\mathbf{r}')}{\\partial n'} \\right] \\, \\mathrm{d}\\ell'\n$$\nHere, $\\mathbf{r}' \\in \\Gamma$ is a source point on the integration contour, $\\hat{\\mathbf{n}}'$ is the outward unit normal vector to $\\Gamma$ at $\\mathbf{r}'$, $\\partial/\\partial n' = \\hat{\\mathbf{n}}' \\cdot \\nabla'$ denotes the outward normal derivative with respect to the source coordinates, and $\\mathrm{d}\\ell'$ is the differential arc length element.\n\nThe function $G(\\mathbf{r}, \\mathbf{r}')$ is the free-space Green's function for the $2$D Helmholtz equation, which represents the field from a unit-strength line source:\n$$\nG(\\mathbf{r}, \\mathbf{r}') = \\frac{\\mathrm{j}}{4} H_0^{(1)}\\!\\left(k \\left\\lVert \\mathbf{r} - \\mathbf{r}' \\right\\rVert \\right)\n$$\nwhere $\\mathrm{j} = \\sqrt{-1}$ is the imaginary unit and $H_0^{(1)}$ is the zeroth-order Hankel function of the first kind.\n\n**2. Derivation of the Integrand Terms**\n\nTo implement the integral, we must derive an explicit expression for the normal derivative of the Green's function, $\\partial G/\\partial n'$. Using the chain rule, we have:\n$$\n\\frac{\\partial G(\\mathbf{r}, \\mathbf{r}')}{\\partial n'} = \\nabla' G(\\mathbf{r}, \\mathbf{r}') \\cdot \\hat{\\mathbf{n}}'\n$$\nLet $u = \\left\\lVert \\mathbf{r} - \\mathbf{r}' \\right\\rVert$. The gradient of $G$ with respect to $\\mathbf{r}'$ is:\n$$\n\\nabla' G = \\frac{\\mathrm{d}G}{\\mathrm{d}u} \\nabla' u = \\left( \\frac{\\mathrm{j}}{4} \\frac{\\mathrm{d}}{\\mathrm{d}u} H_0^{(1)}(ku) \\right) \\left( \\frac{-(\\mathbf{r} - \\mathbf{r}')}{u} \\right)\n$$\nUsing the identity $\\frac{\\mathrm{d}}{\\mathrm{d}z} H_0^{(1)}(z) = -H_1^{(1)}(z)$, where $H_1^{(1)}$ is the first-order Hankel function of the first kind, we get:\n$$\n\\nabla' G = \\left( \\frac{\\mathrm{j}}{4} \\left(-k H_1^{(1)}(ku)\\right) \\right) \\left( \\frac{-(\\mathbf{r} - \\mathbf{r}')}{u} \\right) = \\frac{\\mathrm{j}k}{4u} H_1^{(1)}(ku) (\\mathbf{r} - \\mathbf{r}')\n$$\nThus, the normal derivative is:\n$$\n\\frac{\\partial G(\\mathbf{r}, \\mathbf{r}')}{\\partial n'} = \\frac{\\mathrm{j}k}{4 \\left\\lVert \\mathbf{r} - \\mathbf{r}' \\right\\rVert} H_1^{(1)}\\!\\left(k \\left\\lVert \\mathbf{r} - \\mathbf{r}' \\right\\rVert\\right) (\\mathbf{r} - \\mathbf{r}') \\cdot \\hat{\\mathbf{n}}'\n$$\n\n**3. Problem-Specific Formulation**\n\nThe problem defines a cylindrically symmetric setup. The integration contour $\\Gamma$ is a circle of radius $R_c$, parameterized by $\\mathbf{r}'(\\theta) = (R_c \\cos\\theta, R_c \\sin\\theta)$ for $\\theta \\in [0, 2\\pi)$. The outward normal is $\\hat{\\mathbf{n}}' = (\\cos\\theta, \\sin\\theta)$, which is the radial unit vector $\\hat{\\mathbf{r}}'$. The line element is $\\mathrm{d}\\ell' = R_c \\, \\mathrm{d}\\theta$. The observation points lie on a circle of radius $R_{\\mathrm{obs}}$, parameterized by $\\mathbf{r}(\\phi) = (R_{\\mathrm{obs}} \\cos\\phi, R_{\\mathrm{obs}} \\sin\\phi)$.\n\nDue to the cylindrical symmetry of the source and geometry, the reconstructed field $E_z(\\mathbf{r})$ will be independent of the observation angle $\\phi$. We can therefore compute the field at a single point, for example $\\mathbf{r}_{\\mathrm{obs}} = (R_{\\mathrm{obs}}, 0)$, by integrating over $\\theta \\in [0, 2\\pi)$. For this setup:\n- $\\left\\lVert \\mathbf{r}_{\\mathrm{obs}} - \\mathbf{r}'(\\theta) \\right\\rVert = \\sqrt{(R_{\\mathrm{obs}} - R_c \\cos\\theta)^2 + (-R_c \\sin\\theta)^2} = \\sqrt{R_{\\mathrm{obs}}^2 - 2R_{\\mathrm{obs}}R_c\\cos\\theta + R_c^2}$.\n- $(\\mathbf{r}_{\\mathrm{obs}} - \\mathbf{r}'(\\theta)) \\cdot \\hat{\\mathbf{n}}'(\\theta) = (R_{\\mathrm{obs}}\\hat{\\mathbf{x}} - R_c\\hat{\\mathbf{r}}') \\cdot \\hat{\\mathbf{r}}' = R_{\\mathrm{obs}}(\\hat{\\mathbf{x}} \\cdot \\hat{\\mathbf{r}}') - R_c(\\hat{\\mathbf{r}}' \\cdot \\hat{\\mathbf{r}}') = R_{\\mathrm{obs}}\\cos\\theta - R_c$.\n\n**4. PML Model and Near-Field Data**\n\nThe near-field data are not from a pure free-space simulation but from a domain truncated by a radial PML. The PML is modeled by a complex coordinate stretching factor $s_r(r)$ for the radial coordinate $r$. For a radius $r$ inside the PML ($R_0 \\le r \\le R_0+L$), this factor is $s_r(r) = 1 + \\mathrm{j}\\,\\alpha \\left(\\frac{r - R_0}{L}\\right)^m$ with $m=2$. This leads to a complex-stretched radial coordinate $\\tilde{r}(r) = R_0 + \\int_{R_0}^r s_r(\\rho)\\,\\mathrm{d}\\rho$ for $r \\ge R_0$. Evaluating the integral with $m=2$ yields:\n$$\n\\tilde{r}(r) = R_0 + (r-R_0) + \\frac{\\mathrm{j}\\alpha}{3L^2}(r-R_0)^3 \\quad \\text{for } R_0 \\le r \\le R_0+L\n$$\nFor $r  R_0$, $s_r(r)=1$ and $\\tilde{r}(r)=r$.\n\nThe \"recorded\" field on the contour $\\Gamma$ of radius $R_c$ is given by substituting $\\tilde{r}(R_c)$ into the analytic solution for a line source:\n- $E_z^{\\mathrm{rec}}(R_c) = H_0^{(1)}\\!\\left(k\\,\\tilde{r}(R_c)\\right)$.\n- The normal (radial) derivative is obtained via the chain rule: $\\dfrac{\\partial E_z^{\\mathrm{rec}}}{\\partial n'}(R_c) = \\dfrac{\\mathrm{d}}{\\mathrm{d}r} H_0^{(1)}(k\\tilde{r}(r))\\big|_{r=R_c} = -k H_1^{(1)}(k\\tilde{r}(R_c)) \\frac{\\mathrm{d}\\tilde{r}}{\\mathrm{d}r}\\big|_{r=R_c} = -k H_1^{(1)}(k\\tilde{r}(R_c)) s_r(R_c)$.\n\n**5. Uncorrected vs. Corrected Transformation**\n\nThe NFTF integral assumes free-space fields. Using the PML-affected fields directly is the \"uncorrected\" approach.\n- **Uncorrected data**:\n  - $E_z^{\\mathrm{uncorr}} = E_z^{\\mathrm{rec}}(R_c)$\n  - $\\left(\\dfrac{\\partial E_z}{\\partial n'}\\right)_{\\mathrm{uncorr}} = \\dfrac{\\partial E_z^{\\mathrm{rec}}}{\\partial n'}(R_c)$\n\nThe PML fundamentally alters the field behavior. The proposed correction attempts to reverse this effect on the normal derivative by dividing out the complex stretching factor, which is the metric component of the coordinate transformation. This is a pullback operation that attempts to recover a derivative more representative of free-space propagation.\n- **Corrected data**:\n  - $E_z^{\\mathrm{corr}} = E_z^{\\mathrm{rec}}(R_c)$ (the field value itself is not corrected)\n  - $\\left(\\dfrac{\\partial E_z}{\\partial n'}\\right)_{\\mathrm{corr}} = \\dfrac{1}{s_r(R_c)} \\left(\\dfrac{\\partial E_z^{\\mathrm{rec}}}{\\partial n'}\\right) = -k H_1^{(1)}(k\\tilde{r}(R_c))$\n\n**6. Numerical Implementation and Assessment**\n\nThe boundary integral is evaluated numerically using a simple quadrature rule (trapezoidal or midpoint rule on a uniform grid in $\\theta$). For $N_p$ discretization points $\\theta_i = 2\\pi i/N_p$, the integral for the field at $\\mathbf{r}_{\\mathrm{obs}}$ becomes a sum:\n$$\nE_z^{\\mathrm{num}} \\approx \\sum_{i=0}^{N_p-1} \\left[ E_z^{\\mathrm{data}} \\frac{\\partial G(\\mathbf{r}_{\\mathrm{obs}}, \\mathbf{r}'_i)}{\\partial n'} - G(\\mathbf{r}_{\\mathrm{obs}}, \\mathbf{r}'_i) \\left(\\frac{\\partial E_z}{\\partial n'}\\right)_{\\mathrm{data}} \\right] R_c \\Delta\\theta\n$$\nwhere $\\mathbf{r}'_i = \\mathbf{r}'(\\theta_i)$ and $\\Delta\\theta=2\\pi/N_p$. The terms $E_z^{\\mathrm{data}}$ and $(\\partial E_z/\\partial n')_{\\mathrm{data}}$ are constants with respect to $\\theta$ and are taken from either the uncorrected or corrected data sets.\n\nThe accuracy of the reconstruction is assessed by comparing the numerical result, $E_z^{\\mathrm{num}}$, to the known analytic free-space field at the observation radius, $E_z^{\\mathrm{anal}} = H_0^{(1)}(k R_{\\mathrm{obs}})$. The relative RMS error is defined as:\n$$\n\\mathrm{err} = \\sqrt{\\frac{\\int_0^{2\\pi} |E_z^{\\mathrm{num}}(\\phi) - E_z^{\\mathrm{anal}}(\\phi)|^2 \\, \\mathrm{d}\\phi}{\\int_0^{2\\pi} |E_z^{\\mathrm{anal}}(\\phi)|^2 \\, \\mathrm{d}\\phi}}\n$$\nSince both the numerical and analytic fields are constant with respect to the observation angle $\\phi$ due to symmetry, this simplifies to:\n$$\n\\mathrm{err} = \\frac{|E_z^{\\mathrm{num}} - E_z^{\\mathrm{anal}}|}{|E_z^{\\mathrm{anal}}|}\n$$\nThe improvement factor is the ratio of the error with the correction to the error without it: $I = \\mathrm{err}_{\\mathrm{corr}} / \\mathrm{err}_{\\mathrm{uncorr}}$. A value $I  1$ indicates that the correction improves accuracy. For the case where the contour is in free space ($R_c  R_0$), we have $s_r(R_c)=1$, so the corrected and uncorrected data are identical. This implies $\\mathrm{err}_{\\mathrm{corr}} = \\mathrm{err}_{\\mathrm{uncorr}}$, and the improvement factor must be $1$. This serves as a validation for the implementation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import hankel1\n\ndef solve():\n    \"\"\"\n    Implements and assesses a near-to-far-field transformation for a 2D TMz\n    problem with near-field data sampled from within a PML.\n    \"\"\"\n\n    # --- 1. Define Constants and Parameters ---\n    # Physical constants\n    mu0 = 4 * np.pi * 1e-7  # H/m\n    eps0 = 8.854187817e-12 # F/m\n    c0 = 1 / np.sqrt(mu0 * eps0) # m/s\n\n    # Wave parameters\n    f = 3.0e8  # Hz\n    omega = 2 * np.pi * f # rad/s\n    k = omega / c0 # rad/m\n\n    # PML parameters\n    alpha = 2.0\n    m = 2.0\n    R0 = 1.0  # m\n    L = 0.5   # m\n\n    # Geometry\n    Robs = 5.0 # m\n    \n    # Numerical integration points\n    Np = 2000\n\n    # Test cases\n    test_cases = [0.95, 1.00, 1.10, 1.40]\n\n    # --- 2. Helper Functions ---\n    def s_r(r, R0, L, alpha, m):\n        \"\"\"Calculates the complex stretching factor s_r(r).\"\"\"\n        if r  R0:\n            return 1.0 + 0.0j\n        elif R0 = r = R0 + L:\n            return 1.0 + 1j * alpha * ((r - R0) / L)**m\n        else: # r > R0 + L\n            return 1.0 + 1j * alpha\n\n    def tilde_r(r, R0, L, alpha, m):\n        \"\"\"Calculates the complex-stretched radial coordinate tilde_r(r).\"\"\"\n        if r  R0:\n            return r + 0.0j\n        elif R0 = r = R0 + L:\n            # Analytic integral of s_r(rho) from R0 to r\n            integral_part = (r - R0) + (1j * alpha / (L**m * (m + 1))) * (r - R0)**(m + 1)\n            return R0 + integral_part\n        else: # r > R0 + L. Not needed for this problem's test cases.\n            # Integral from R0 to R0+L\n            int_pml_layer = L + (1j * alpha * L) / (m + 1)\n            # Integral from R0+L to r\n            int_outer = (1 + 1j * alpha) * (r - (R0 + L))\n            return R0 + int_pml_layer + int_outer\n\n    def compute_far_field(Rc, Robs, k, Ez_data, dEz_dn_data, Np):\n        \"\"\"\n        Computes the far field at a single observation point (Robs, 0)\n        using the boundary integral equation.\n        \"\"\"\n        d_theta = 2 * np.pi / Np\n        integral_sum = 0.0 + 0.0j\n\n        for i in range(Np):\n            theta = i * d_theta\n            \n            # Distance from source point on contour to observation point\n            u = np.sqrt(Robs**2 - 2 * Robs * Rc * np.cos(theta) + Rc**2)\n            \n            # (r_obs - r') dot n'\n            dot_product = Robs * np.cos(theta) - Rc\n            \n            # Green's function and its normal derivative\n            G = (1j / 4) * hankel1(0, k * u)\n            dG_dn = (1j * k / (4 * u)) * hankel1(1, k * u) * dot_product\n            \n            # Integrand for this point\n            integrand = (Ez_data * dG_dn - G * dEz_dn_data)\n            \n            # Add contribution to sum (d_ell = Rc * d_theta)\n            integral_sum += integrand * Rc * d_theta\n            \n        return integral_sum\n\n    # --- 3. Main Calculation Loop ---\n    results = []\n    \n    # Analytic field at observation circle for error comparison\n    Ez_anal = hankel1(0, k * Robs)\n    abs_Ez_anal = np.abs(Ez_anal)\n\n    for Rc in test_cases:\n        # Calculate near-field \"recorded\" data on contour of radius Rc\n        sr_Rc = s_r(Rc, R0, L, alpha, m)\n        tr_Rc = tilde_r(Rc, R0, L, alpha, m)\n        \n        Ez_rec = hankel1(0, k * tr_Rc)\n        dEz_rec_dn = -k * sr_Rc * hankel1(1, k * tr_Rc) # Chain rule derivative\n        \n        # --- Uncorrected case ---\n        dEz_uncorr_dn = dEz_rec_dn\n        Ez_uncorr = compute_far_field(Rc, Robs, k, Ez_rec, dEz_uncorr_dn, Np)\n        err_uncorr = np.abs(Ez_uncorr - Ez_anal) / abs_Ez_anal\n\n        # --- Corrected case ---\n        dEz_corr_dn = dEz_rec_dn / sr_Rc\n        Ez_corr = compute_far_field(Rc, Robs, k, Ez_rec, dEz_corr_dn, Np)\n        err_corr = np.abs(Ez_corr - Ez_anal) / abs_Ez_anal\n        \n        # Calculate improvement factor\n        # Handle potential division by zero if uncorrected error is near zero\n        if err_uncorr  1e-15:\n             improvement = 1.0 if err_corr  1e-15 else float('inf')\n        else:\n             improvement = err_corr / err_uncorr\n        \n        results.append(improvement)\n\n    # --- 4. Final Output ---\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3317929"}]}