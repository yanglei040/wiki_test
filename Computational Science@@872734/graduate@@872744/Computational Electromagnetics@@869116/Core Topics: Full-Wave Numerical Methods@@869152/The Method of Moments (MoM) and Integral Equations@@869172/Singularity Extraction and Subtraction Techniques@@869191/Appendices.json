{"hands_on_practices": [{"introduction": "Effective singularity subtraction begins with a precise analytical understanding of the kernel's behavior. In two-dimensional problems, the Green's function for the Helmholtz equation exhibits a logarithmic singularity, which is fundamentally different from the $1/R$ singularity in 3D. This exercise challenges you to derive the small-argument asymptotic form of the 2D Green's function from the series expansions of Bessel functions, thereby isolating the singular logarithmic term and identifying the finite part that remains [@problem_id:3348056]. This derivation is a critical first step in developing robust boundary element methods for 2D wave problems.", "problem": "Consider the time-harmonic scalar Helmholtz equation in two spatial dimensions with free-space boundary conditions,\n$$(\\nabla^{2} + k^{2})\\,G(\\mathbf{r}) = -\\delta(\\mathbf{r}),$$\nwhere $k>0$ is the wavenumber and $\\delta(\\cdot)$ is the Dirac delta distribution. The free-space Green’s function is given by\n$$G(\\mathbf{r}) = \\frac{i}{4} H_{0}^{(1)}(k r),$$\nwhere $r = \\|\\mathbf{r}\\|$ and $H_{0}^{(1)}$ is the order-zero Hankel function of the first kind. In computational electromagnetics, especially within boundary integral formulations and the Boundary Element Method (BEM), it is standard to perform singularity extraction by subtracting the static two-dimensional Green’s function kernel $-\\frac{1}{2\\pi}\\ln r$ to isolate a finite remainder at coincident points.\n\nStarting from fundamental definitions and well-tested series representations for the Bessel functions $J_{0}$ and $Y_{0}$ underlying $H_{0}^{(1)} = J_{0} + i Y_{0}$, derive the small-argument asymptotic of $G(\\mathbf{r})$ as $r \\to 0^{+}$, identify the leading logarithmic singularity, and determine the finite constant term that remains after subtracting $-\\frac{1}{2\\pi}\\ln r$. Your derivation must make clear how the logarithmic singularity arises and how the constant term depends on $k$.\n\nProvide, as your final answer, the explicit asymptotic expression for $G(\\mathbf{r})$ up to and including the constant term, i.e., an expression of the form\n$$-\\frac{1}{2\\pi}\\ln r + \\text{constant in } r$$\nwith the $k$-dependent constant fully specified. No numerical evaluation or rounding is required. The final answer must be a single closed-form analytic expression.", "solution": "The problem is first subjected to validation.\n\n### Step 1: Extract Givens\n- The governing equation is the two-dimensional, time-harmonic scalar Helmholtz equation: $(\\nabla^{2} + k^{2})\\,G(\\mathbf{r}) = -\\delta(\\mathbf{r})$.\n- The wavenumber $k$ is a positive real number, $k>0$.\n- The source term is the Dirac delta distribution, $\\delta(\\mathbf{r})$.\n- The free-space Green’s function is given as $G(\\mathbf{r}) = \\frac{i}{4} H_{0}^{(1)}(k r)$, where $r = \\|\\mathbf{r}\\|$.\n- $H_{0}^{(1)}$ is the order-zero Hankel function of the first kind.\n- The technique of singularity extraction involves subtracting the static Green's function, which is $-\\frac{1}{2\\pi}\\ln r$.\n- The Hankel function is related to the Bessel functions of the first kind ($J_0$) and second kind ($Y_0$) by $H_{0}^{(1)} = J_{0} + i Y_{0}$.\n- The task is to derive the small-argument asymptotic behavior of $G(\\mathbf{r})$ for $r \\to 0^{+}$ using the series representations for $J_0$ and $Y_0$, and to express the result in the form $-\\frac{1}{2\\pi}\\ln r + \\text{constant}$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded:** The problem statement is entirely grounded in established mathematical physics and computational science. The Helmholtz equation, Green's functions, Bessel and Hankel functions, and the method of singularity extraction are all standard and well-documented concepts.\n- **Well-Posed:** The problem is well-posed. It asks for the derivation of a specific, known asymptotic limit of a defined function. The required steps are outlined, and a unique analytical solution exists.\n- **Objective:** The problem is stated in precise, objective, and formal mathematical language, free from any ambiguity or subjective elements.\n- **Conclusion:** The problem is scientifically sound, internally consistent, complete, and well-posed. It does not violate any of the specified criteria for invalidity.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A full solution will be provided.\n\n### Derivation of the Asymptotic Expression\n\nThe objective is to determine the asymptotic behavior of the two-dimensional free-space Green's function for the Helmholtz equation as the radial distance $r = \\|\\mathbf{r}\\|$ approaches zero. The Green's function is given by:\n$$G(\\mathbf{r}) = \\frac{i}{4} H_{0}^{(1)}(k r)$$\nwhere $k > 0$ is the wavenumber and $H_{0}^{(1)}$ is the Hankel function of the first kind, of order zero.\n\nFirst, we express the Hankel function in terms of the Bessel function of the first kind, $J_0$, and the Bessel function of the second kind (or Neumann function), $Y_0$:\n$$H_{0}^{(1)}(z) = J_{0}(z) + i Y_{0}(z)$$\nSubstituting this definition into the expression for $G(\\mathbf{r})$ with the argument $z = kr$:\n$$G(\\mathbf{r}) = \\frac{i}{4} \\left( J_{0}(k r) + i Y_{0}(k r) \\right) = \\frac{i}{4} J_{0}(k r) - \\frac{1}{4} Y_{0}(k r)$$\nTo find the behavior as $r \\to 0^{+}$, we need the small-argument asymptotic expansions of $J_0(z)$ and $Y_0(z)$ for $z \\to 0^{+}$.\n\nThe series representation for the Bessel function $J_0(z)$ is:\n$$J_{0}(z) = \\sum_{m=0}^{\\infty} \\frac{(-1)^{m}}{(m!)^{2}} \\left(\\frac{z}{2}\\right)^{2m} = 1 - \\frac{z^2}{4} + \\frac{z^4}{64} - \\dots$$\nAs $z \\to 0$, the leading term is $1$. Thus, for small $r$:\n$$J_{0}(k r) = 1 + O((kr)^2)$$\n\nThe small-argument expansion for the Bessel function $Y_0(z)$ is more complex and is the source of the logarithmic singularity. The standard expansion is:\n$$Y_{0}(z) = \\frac{2}{\\pi} \\left[ \\left( \\ln\\left(\\frac{z}{2}\\right) + \\gamma \\right) J_0(z) - \\sum_{m=1}^{\\infty} \\frac{(-1)^m}{(m!)^2} \\left( \\sum_{j=1}^{m} \\frac{1}{j} \\right) \\left(\\frac{z}{2}\\right)^{2m} \\right]$$\nwhere $\\gamma \\approx 0.5772$ is the Euler-Mascheroni constant.\nFor $z \\to 0$, we know $J_0(z) \\to 1$. The summation term behaves as $O(z^2)$. Therefore, the leading-order behavior of $Y_0(z)$ is determined by the first term:\n$$Y_{0}(z) \\approx \\frac{2}{\\pi} \\left( \\ln\\left(\\frac{z}{2}\\right) + \\gamma \\right) \\cdot 1 = \\frac{2}{\\pi} \\left( \\ln(z) - \\ln(2) + \\gamma \\right)$$\nSubstituting $z=kr$, we get the small-argument behavior for $Y_0(kr)$:\n$$Y_{0}(k r) = \\frac{2}{\\pi} \\left( \\ln(kr) - \\ln(2) + \\gamma \\right) + O((kr)^2 \\ln(kr)) = \\frac{2}{\\pi} \\left( \\ln(k) + \\ln(r) - \\ln(2) + \\gamma \\right) + O((kr)^2 \\ln(kr))$$\n\nNow we substitute the asymptotic forms of $J_0(kr)$ and $Y_0(kr)$ back into the expression for $G(\\mathbf{r})$:\n$$G(\\mathbf{r}) \\approx \\frac{i}{4}(1) - \\frac{1}{4} \\left[ \\frac{2}{\\pi} \\left( \\ln(k) + \\ln(r) - \\ln(2) + \\gamma \\right) \\right]$$\nSimplifying this expression:\n$$G(\\mathbf{r}) \\approx \\frac{i}{4} - \\frac{1}{2\\pi} \\left( \\ln(k) + \\ln(r) - \\ln(2) + \\gamma \\right)$$\nTo match the requested form, we separate the term containing $\\ln(r)$:\n$$G(\\mathbf{r}) \\approx -\\frac{1}{2\\pi}\\ln(r) + \\left[ \\frac{i}{4} - \\frac{1}{2\\pi} \\left( \\ln(k) - \\ln(2) + \\gamma \\right) \\right]$$\nThe term $-\\frac{1}{2\\pi}\\ln(r)$ is the expected logarithmic singularity, which is identical to the Green's function for the 2D Laplacian operator, often called the static kernel. The remaining part is a constant with respect to $r$:\n$$\\text{Constant} = \\frac{i}{4} - \\frac{1}{2\\pi} \\left( \\ln(k) - \\ln(2) + \\gamma \\right) = \\frac{i}{4} - \\frac{1}{2\\pi} \\left( \\ln\\left(\\frac{k}{2}\\right) + \\gamma \\right)$$\nThis constant represents the finite part of the Helmholtz Green's function at the origin after the logarithmic singularity has been subtracted. Its dependence on the wavenumber $k$ arises directly from the argument of the logarithm in the $Y_0$ expansion.\n\nThe complete asymptotic expression for $G(\\mathbf{r})$ as $r \\to 0^{+}$ up to the constant term is therefore:\n$$G(\\mathbf{r}) \\approx -\\frac{1}{2\\pi}\\ln(r) + \\frac{i}{4} - \\frac{1}{2\\pi}\\left(\\ln\\left(\\frac{k}{2}\\right) + \\gamma\\right)$$\nThis result is fundamental for numerical methods like the Boundary Element Method, where subtracting this analytical form of the singularity allows for accurate numerical integration of the remaining well-behaved function.", "answer": "$$\n\\boxed{-\\frac{1}{2\\pi}\\ln(r) + \\frac{i}{4} - \\frac{1}{2\\pi}\\left(\\ln\\left(\\frac{k}{2}\\right) + \\gamma\\right)}\n$$", "id": "3348056"}, {"introduction": "Theory provides the 'what' to subtract; numerical implementation demonstrates the 'why'. When an observation point is close to an integration patch, the Green's function kernel becomes sharply peaked, posing a severe challenge for standard quadrature rules. This hands-on coding exercise provides a direct and quantitative measure of the power of singularity subtraction by comparing a naive integration with a regularized approach for a near-singular integral, allowing you to witness the dramatic improvement in accuracy firsthand [@problem_id:3348122].", "problem": "Consider the static free-space Green’s kernel for the Laplace equation, defined by $G(\\mathbf{r},\\mathbf{r}') = \\dfrac{1}{4\\pi \\|\\mathbf{r} - \\mathbf{r}'\\|}$, where $\\mathbf{r}$ is the observation point and $\\mathbf{r}'$ is the source point on a planar surface. Let the reference triangle be the right triangle lying in the plane $z=0$ with vertices at $(0,0,0)$, $(1,0,0)$, and $(0,1,0)$. Its centroid is at $\\mathbf{r}_{c} = \\left(\\dfrac{1}{3}, \\dfrac{1}{3}, 0\\right)$. For an observation point a distance $\\delta$ above the centroid, $\\mathbf{r}_{\\text{obs}}(\\delta) = \\left(\\dfrac{1}{3}, \\dfrac{1}{3}, \\delta\\right)$ with $\\delta > 0$, define the kernel over the triangle by\n$$\nG(x,y;\\delta) = \\frac{1}{4\\pi\\sqrt{(x - \\tfrac{1}{3})^2 + (y - \\tfrac{1}{3})^2 + \\delta^2}},\n$$\nfor $(x,y)$ inside the triangle $\\{(x,y)\\,|\\, x \\ge 0,\\ y \\ge 0,\\ x + y \\le 1\\}$.\n\nLet the source weighting be the linear basis function equal to the barycentric coordinate associated with the vertex at $(1,0,0)$, namely $\\phi(x,y) = x$. The quantity of interest is the surface integral\n$$\nI(\\delta) = \\int_{T} \\phi(x,y)\\,G(x,y;\\delta)\\, \\mathrm{d}S = \\int_{0}^{1} \\int_{0}^{1-x} x\\, G(x,y;\\delta)\\,\\mathrm{d}y\\,\\mathrm{d}x,\n$$\nwhere $T$ denotes the reference triangle and $\\mathrm{d}S$ is the surface element in $\\mathrm{m}^2$. Although $I(\\delta)$ is finite for any $\\delta > 0$, numerical evaluation becomes challenging for small $\\delta$ due to the near-singular behavior of $G(x,y;\\delta)$ around $(x,y) = \\left(\\tfrac{1}{3}, \\tfrac{1}{3}\\right)$.\n\nA classical singularity extraction and subtraction technique rewrites the integral as\n$$\nI(\\delta) = \\underbrace{\\int_{T} \\big(\\phi(x,y) - \\phi(\\mathbf{r}_{c})\\big)\\, G(x,y;\\delta)\\, \\mathrm{d}S}_{I_{\\text{rem}}(\\delta)}\\;+\\; \\underbrace{\\phi(\\mathbf{r}_{c}) \\int_{T} G(x,y;\\delta)\\,\\mathrm{d}S}_{I_{\\text{sing}}(\\delta)},\n$$\nwhere $\\phi(\\mathbf{r}_{c}) = \\tfrac{1}{3}$ and $I_{\\text{rem}}(\\delta)$ has a milder local behavior because $\\phi(x,y) - \\phi(\\mathbf{r}_{c})$ vanishes at the centroid, reducing the peak severity of the integrand near the singularity.\n\nStarting from the fundamental definition of the Green’s function and the geometric parametrization of the triangle, implement and compare two numerical strategies for evaluating $I(\\delta)$:\n- A naive tensor-product Gauss–Legendre quadrature on the $(x,y)$ domain, with a fixed modest order $n$, directly approximating the double integral $\\int_{0}^{1} \\int_{0}^{1-x} x\\, G(x,y;\\delta)\\, \\mathrm{d}y\\,\\mathrm{d}x$.\n- A subtraction-based strategy that evaluates $I_{\\text{rem}}(\\delta)$ using the same modest quadrature order $n$ and evaluates $I_{\\text{sing}}(\\delta)$ with a significantly higher-order quadrature $n_{\\text{ref}}$ to emulate an analytically known singular contribution in practice.\n\nUse Gauss–Legendre quadrature in one dimension to approximate the integrals over $x \\in [0,1]$ and, for each $x$, over $y \\in [0,1-x]$, with the correct affine mapping and scaling of weights. Your program must:\n- Compute a high-accuracy reference $I_{\\text{ref}}(\\delta)$ by applying the high-order quadrature $n_{\\text{ref}}$ directly to $I(\\delta)$ (without subtraction).\n- Compute the absolute error of the naive method, $E_{\\text{naive}}(\\delta) = \\big| I_{\\text{naive}}(\\delta) - I_{\\text{ref}}(\\delta) \\big|$.\n- Compute the absolute error of the subtraction method, $E_{\\text{sub}}(\\delta) = \\big| I_{\\text{sub}}(\\delta) - I_{\\text{ref}}(\\delta) \\big|$.\n- Report the accuracy gain defined as\n$$\n\\Gamma(\\delta) = \\frac{E_{\\text{naive}}(\\delta)}{E_{\\text{sub}}(\\delta)}.\n$$\n\nPhysical units: treat $\\delta$ in meters and areas in square meters, but report the final accuracy gain $\\Gamma(\\delta)$ as a dimensionless float.\n\nAngle units do not arise in this problem.\n\nTest suite:\n- Use three values of $\\delta$ to exercise different regimes: $\\delta_1 = 10^{-1}\\,\\mathrm{m}$, $\\delta_2 = 10^{-3}\\,\\mathrm{m}$, and $\\delta_3 = 10^{-5}\\,\\mathrm{m}$.\n- Use a modest quadrature order $n = 24$ for the naive and the remainder integrals, and a high-order $n_{\\text{ref}} = 400$ for the reference and the singular part in the subtraction method.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test suite, for example $[\\Gamma(\\delta_1),\\Gamma(\\delta_2),\\Gamma(\\delta_3)]$. The outputs must be in the canonical Python float format.\n\nEnsure scientific realism by basing your approach on the above Green’s function definition and correct quadrature rules. Do not use any external data or shortcuts; implement the quadrature and subtraction exactly as specified.", "solution": "The problem requires a comparison of two numerical integration strategies for a near-singular integral arising in the context of the boundary element method for the Laplace equation. The quantity of interest is the integral $I(\\delta) = \\int_{T} \\phi(x,y) G(x,y;\\delta) \\mathrm{d}S$ over a reference triangle $T$, where $G$ is the static free-space Green's kernel and $\\phi$ is a linear source weighting. The near-singularity arises as the observation point, located at a distance $\\delta$ above the triangle's centroid, approaches the surface (i.e., as $\\delta \\to 0$). We will compare a direct, naive numerical quadrature with a more sophisticated singularity subtraction technique.\n\nThe core principle of singularity subtraction is to regularize the integrand. The integral $I(\\delta)$ is rewritten as:\n$$\nI(\\delta) = \\int_{T} \\big(\\phi(x,y) - \\phi(\\mathbf{r}_{c})\\big)\\, G(x,y;\\delta)\\, \\mathrm{d}S \\;+\\; \\phi(\\mathbf{r}_{c}) \\int_{T} G(x,y;\\delta)\\,\\mathrm{d}S\n$$\nThis splits the original integral into a \"remainder\" term $I_{\\text{rem}}(\\delta)$ and a \"singular\" term $I_{\\text{sing}}(\\delta)$. The crucial insight is that the source weighting function $\\phi(x,y)=x$ is smooth. By subtracting its value at the centroid, $\\phi(\\mathbf{r}_c) = \\phi(1/3, 1/3) = 1/3$, the new factor in the remainder integrand, $\\phi(x,y) - \\phi(\\mathbf{r}_c) = x - 1/3$, becomes zero at the $x$-coordinate of the near-singularity location. This cancellation significantly reduces the integrand's peak value, making $I_{\\text{rem}}(\\delta)$ much smoother and more amenable to accurate approximation with a low-order numerical quadrature. The singular behavior is isolated in $I_{\\text{sing}}(\\delta)$, which can then be handled with a high-accuracy method (here, a high-order quadrature) or, in practice, analytical formulas.\n\nTo perform the numerical integration over the reference triangle $T = \\{(x,y)\\,|\\, x \\ge 0,\\, y \\ge 0,\\, x + y \\le 1\\}$, we express the surface integral as an iterated integral:\n$$\n\\int_{T} f(x,y) \\mathrm{d}S = \\int_{0}^{1} \\left( \\int_{0}^{1-x} f(x,y) \\mathrm{d}y \\right) \\mathrm{d}x\n$$\nWe apply a tensor product of one-dimensional Gauss-Legendre quadrature rules. This requires mapping the standard quadrature interval $[-1, 1]$ to the integration limits $[0, 1]$ for the outer integral and $[0, 1-x]$ for the inner integral.\n\nFor the outer integral over $x$, the affine mapping from $\\xi \\in [-1, 1]$ to $x \\in [0, 1]$ is $x(\\xi) = \\frac{1}{2}(\\xi+1)$, with Jacobian $\\frac{\\mathrm{d}x}{\\mathrm{d}\\xi} = \\frac{1}{2}$.\nFor the inner integral over $y$, for a fixed $x$, the mapping from $\\eta \\in [-1, 1]$ to $y \\in [0, 1-x]$ is $y(\\eta) = \\frac{1-x}{2}(\\eta+1)$, with Jacobian $\\frac{\\mathrm{d}y}{\\mathrm{d}\\eta} = \\frac{1-x}{2}$.\n\nCombining these, the approximation for an $N$-point quadrature in each dimension becomes:\n$$\nI \\approx \\sum_{i=1}^{N} \\sum_{j=1}^{N} f(x_i, y_{ij}) \\, w_i w_j \\, \\left(\\frac{1-x_i}{4}\\right)\n$$\nwhere $(\\xi_k, w_k)$ for $k=1, \\dots, N$ are the $N$-point Gauss-Legendre nodes and weights, and the evaluation points are $x_i = \\frac{1}{2}(\\xi_i+1)$ and $y_{ij} = \\frac{1-x_i}{2}(\\eta_j+1)$ (using $\\eta_j = \\xi_j$).\n\nThe computational procedure is as follows:\n$1$. A high-accuracy reference value, $I_{\\text{ref}}(\\delta)$, is computed by integrating the original integrand, $\\phi(x,y)G(x,y;\\delta)$, using a high-order quadrature with $n_{\\text{ref}} = 400$.\n$2$. The naive approximation, $I_{\\text{naive}}(\\delta)$, is computed by integrating the same function but with a modest quadrature order of $n = 24$.\n$3$. The subtraction method approximation, $I_{\\text{sub}}(\\delta)$, is computed in two parts:\n    -   The regular part, $I_{\\text{rem}}(\\delta)$, is computed by integrating the regularized integrand, $(\\phi(x,y) - \\phi(\\mathbf{r}_c))G(x,y;\\delta)$, using the modest order $n = 24$.\n    -   The singular part, $I_{\\text{sing}}(\\delta)$, is computed by evaluating $\\phi(\\mathbf{r}_c) \\int_T G(x,y;\\delta)\\,\\mathrm{d}S$, where the integral of the Green's function $G$ is computed using the high order $n_{\\text{ref}} = 400$.\n    -   The final value is $I_{\\text{sub}}(\\delta) = I_{\\text{rem}}(\\delta) + I_{\\text{sing}}(\\delta)$.\n$4$. For each $\\delta$, the absolute errors $E_{\\text{naive}}(\\delta) = |I_{\\text{naive}}(\\delta) - I_{\\text{ref}}(\\delta)|$ and $E_{\\text{sub}}(\\delta) = |I_{\\text{sub}}(\\delta) - I_{\\text{ref}}(\\delta)|$ are calculated. The accuracy gain, $\\Gamma(\\delta) = E_{\\text{naive}}(\\delta) / E_{\\text{sub}}(\\delta)$, quantifies the effectiveness of the subtraction method. A larger value of $\\Gamma(\\delta)$ indicates a greater improvement in accuracy for the same computational cost (of the regular part).", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Computes the accuracy gain of a singularity subtraction technique for a near-singular\n    integral over a triangular domain.\n    \"\"\"\n\n    # Define the test cases and parameters from the problem statement.\n    test_deltas = [1e-1, 1e-3, 1e-5]\n    n_modest = 24\n    n_ref = 400\n    phi_centroid = 1.0 / 3.0\n    xc, yc = 1.0 / 3.0, 1.0 / 3.0\n\n    # Pre-compute Gauss-Legendre nodes and weights to avoid redundant calculations.\n    nodes_modest, weights_modest = roots_legendre(n_modest)\n    nodes_ref, weights_ref = roots_legendre(n_ref)\n\n    def G(x, y, delta):\n        \"\"\"\n        The static free-space Green's kernel for the Laplace equation.\n        G(r, r') = 1 / (4 * pi * ||r - r'||)\n        \"\"\"\n        inv_4pi = 1.0 / (4.0 * np.pi)\n        distance_sq = (x - xc)**2 + (y - yc)**2 + delta**2\n        return inv_4pi / np.sqrt(distance_sq)\n\n    def naive_integrand(x, y, delta):\n        \"\"\"\n        The original integrand: phi(x,y) * G(x,y;delta).\n        phi(x,y) = x\n        \"\"\"\n        return x * G(x, y, delta)\n\n    def rem_integrand(x, y, delta):\n        \"\"\"\n        The remainder integrand after subtraction: (phi(x,y) - phi_c) * G.\n        \"\"\"\n        return (x - phi_centroid) * G(x, y, delta)\n\n    def quad_2d_triangle(func, delta, nodes, weights):\n        \"\"\"\n        Performs 2D Gauss-Legendre quadrature over the reference triangle.\n        The integration is done on a [-1,1] x [-1,1] square and mapped to the triangle.\n        \"\"\"\n        # Create a 2D grid of nodes and weights using broadcasting\n        xi = nodes[:, np.newaxis]\n        eta = nodes[np.newaxis, :]\n        wi = weights[:, np.newaxis]\n        wj = weights[np.newaxis, :]\n\n        # Affine mapping from standard square to triangle\n        x = 0.5 * (xi + 1.0)\n        y = 0.5 * (1.0 - x) * (eta + 1.0)\n\n        # Jacobian of the transformation\n        jacobian = 0.25 * (1.0 - x)\n\n        # Evaluate the integrand at all quadrature points\n        integrand_values = func(x, y, delta)\n\n        # Compute the integral by summing weighted values\n        integral = np.sum(wi * wj * integrand_values * jacobian)\n        \n        return integral\n\n\n    results = []\n    for delta in test_deltas:\n        # 1. Compute the high-accuracy reference value using n_ref points.\n        I_ref = quad_2d_triangle(naive_integrand, delta, nodes_ref, weights_ref)\n\n        # 2. Compute the naive approximation using n_modest points.\n        I_naive = quad_2d_triangle(naive_integrand, delta, nodes_modest, weights_modest)\n\n        # 3. Compute the subtraction-based approximation.\n        #    - The remainder term is integrated with the modest order.\n        I_rem = quad_2d_triangle(rem_integrand, delta, nodes_modest, weights_modest)\n        #    - The singular term's integral part is computed with high order.\n        I_G_ref = quad_2d_triangle(G, delta, nodes_ref, weights_ref)\n        I_sing = phi_centroid * I_G_ref\n        \n        I_sub = I_rem + I_sing\n\n        # 4. Compute absolute errors and the accuracy gain.\n        E_naive = np.abs(I_naive - I_ref)\n        E_sub = np.abs(I_sub - I_ref)\n        \n        # Handle the case where the subtraction method is extremely accurate,\n        # to avoid division by a number close to machine epsilon.\n        if E_sub == 0.0:\n            # If the subtraction method error is zero, the gain is effectively infinite.\n            # This can happen due to floating point limitations. We can report a large number\n            # or handle it as a special case. Here, if E_naive is also zero, gain is 1.\n            # Otherwise, gain is large. Since E_naive is not expected to be zero, it's safe to say gain is huge.\n            gamma = np.inf if E_naive > 0.0 else 1.0\n        else:\n            gamma = E_naive / E_sub\n            \n        results.append(gamma)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3348122"}, {"introduction": "Advanced numerical codes require rigorous verification, and the Method of Manufactured Solutions (MMS) is a powerful technique for achieving this. In MMS, a problem is constructed around a known analytical solution to precisely benchmark numerical errors. This practice guides you through implementing a variable-order singularity subtraction scheme for a potential integral, using a manufactured source distribution to systematically analyze how the accuracy of your computation improves as the order of the subtracted polynomial series is increased [@problem_id:3348130].", "problem": "Consider the free-space scalar single-layer potential generated by a smooth, compactly supported surface source on a planar disk. Let the surface be the disk of radius $a$ in the plane $z=0$, centered at the origin. Let the free-space Green's function for the Laplace equation be $G(\\mathbf{r},\\mathbf{r}') = \\dfrac{1}{4\\pi \\|\\mathbf{r}-\\mathbf{r}'\\|}$. Let the manufactured surface density be radially symmetric and analytic, given by $\\sigma(\\rho) = \\sum_{p=0}^{P} c_p \\,\\rho^{2p}$, where $\\rho = \\sqrt{x'^2+y'^2}$ is the radial coordinate on the disk, $c_p$ are real coefficients, and $P$ is a nonnegative integer.\n\nThe target quantity is the scalar potential at the observation point $\\mathbf{r} = (0,0,0)$:\n$$\n\\phi = \\int_{S} \\sigma(\\rho) \\, G(\\mathbf{r},\\mathbf{r}') \\, \\mathrm{d}S' \\, ,\n$$\nwhere $S$ is the disk of radius $a$, $\\mathbf{r}' = (x',y',0)$, and $\\mathrm{d}S' = \\mathrm{d}x'\\mathrm{d}y'$.\n\nNear the observation point, the kernel is weakly singular because $G(\\mathbf{r},\\mathbf{r}') = \\dfrac{1}{4\\pi \\sqrt{x'^2+y'^2}} = \\dfrac{1}{4\\pi \\rho}$. A standard singularity extraction and subtraction technique of order $L$ proceeds by adding and subtracting a truncated series expansion of the source density about the singular point and integrating the subtracted terms analytically while integrating the remainder numerically:\n$$\n\\sigma(\\rho) = \\underbrace{\\sum_{p=0}^{L} c_p \\,\\rho^{2p}}_{\\text{subtracted terms}} \\;+\\; \\underbrace{\\left(\\sum_{p=L+1}^{P} c_p \\,\\rho^{2p}\\right)}_{\\text{remainder}} \\, ,\n$$\nso that\n$$\n\\phi = \\int_{S} \\frac{\\sigma(\\rho) - \\sum_{p=0}^{L} c_p \\,\\rho^{2p}}{4\\pi \\rho} \\,\\mathrm{d}S' \\;+\\; \\int_{S} \\frac{\\sum_{p=0}^{L} c_p \\,\\rho^{2p}}{4\\pi \\rho} \\,\\mathrm{d}S' \\, .\n$$\nThe first term is regularized by construction as $L$ increases, which improves numerical quadrature behavior; the second term is to be evaluated in closed form using fundamental principles.\n\nStarting only from the free-space Green's function, polar-coordinate change of variables, and basic properties of analytic functions, derive a closed-form expression for the potential at the origin for the given manufactured source. Then design a numerical algorithm that:\n- Implements the subtraction strategy of order $L$ and evaluates the remainder integral by tensor-product Gauss–Legendre quadrature over the disk expressed as a $y$-outer integral with $x$-inner limits depending on $y$.\n- Adds back the analytically integrated subtracted terms to form the numerical approximation $\\phi_L$.\n- Benchmarks the absolute error $\\varepsilon_L = |\\phi_L - \\phi_{\\text{exact}}|$ against the derived closed-form $\\phi_{\\text{exact}}$ for each specified subtraction order $L$.\n\nUse the following manufactured parameters, which are dimensionless:\n- Disk radius $a = 1$.\n- Polynomial degree $P = 3$ with coefficients $c_0 = 1.0$, $c_1 = -0.7$, $c_2 = 0.5$, $c_3 = -0.2$.\n\nNumerically integrate the remainder using Gauss–Legendre quadrature with $N_y$ nodes in the outer integral and $N_x$ nodes in the inner integral. For scientific realism, ensure that the nodes and weights are correctly scaled from $[-1,1]$ to the appropriate physical intervals.\n\nTest Suite and required output:\n- Four test cases corresponding to subtraction orders $L \\in \\{0,1,2,3\\}$ with the same quadrature sizes $N_y = 64$ and $N_x = 64$.\n- For each case, compute the absolute error $\\varepsilon_L$ as a float.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\").\n\nAll quantities are unitless. Angles, where needed internally, must be treated in radians. The final numerical answers must be floats. Do not print any explanatory text; only print the list in the specified format.", "solution": "The problem statement is scientifically grounded, well-posed, and objective. It provides a complete and consistent set of definitions, parameters, and constraints to derive an analytical solution and implement a specific numerical verification scheme. The problem is a standard exercise in computational science, specifically in the context of integral equation methods for potential theory, involving a manufactured solution to test a singularity subtraction technique. Therefore, the problem is valid.\n\n### Analytical Derivation of the Exact Potential\n\nThe scalar potential $\\phi$ at the origin $\\mathbf{r}=(0,0,0)$ due to a surface source density $\\sigma(\\mathbf{r}')$ on a surface $S$ is given by the single-layer potential integral:\n$$\n\\phi = \\int_{S} \\sigma(\\mathbf{r}') G(\\mathbf{r}, \\mathbf{r}') \\, \\mathrm{d}S'\n$$\nThe surface $S$ is a disk of radius $a$ in the $z=0$ plane, centered at the origin. The observation point is $\\mathbf{r}=(0,0,0)$, and the source point is $\\mathbf{r}'=(x',y',0)$. The free-space Green's function for the Laplace equation is $G(\\mathbf{r},\\mathbf{r}') = \\frac{1}{4\\pi \\|\\mathbf{r}-\\mathbf{r}'\\|}$. At the origin, this simplifies to $G((0,0,0), \\mathbf{r}') = \\frac{1}{4\\pi \\|\\mathbf{r}'\\|}$.\n\nOn the disk, we use the radial coordinate $\\rho = \\|\\mathbf{r}'\\| = \\sqrt{x'^2+y'^2}$. The singular kernel is thus $G = \\frac{1}{4\\pi \\rho}$. The source density is given as a radially symmetric, analytic function $\\sigma(\\rho) = \\sum_{p=0}^{P} c_p \\,\\rho^{2p}$.\n\nThe integral for the potential $\\phi_{\\text{exact}}$ is:\n$$\n\\phi_{\\text{exact}} = \\int_{S} \\frac{\\sigma(\\rho)}{4\\pi \\rho} \\, \\mathrm{d}S'\n$$\nDue to the radial symmetry of the integrand and the domain, it is most natural to evaluate this integral using polar coordinates, where $\\mathrm{d}S' = \\rho \\, \\mathrm{d}\\rho \\, \\mathrm{d}\\theta'$. The limits of integration are $\\rho \\in [0, a]$ and $\\theta' \\in [0, 2\\pi]$.\n$$\n\\phi_{\\text{exact}} = \\int_{0}^{2\\pi} \\int_{0}^{a} \\frac{\\sigma(\\rho)}{4\\pi \\rho} (\\rho \\, \\mathrm{d}\\rho \\, \\mathrm{d}\\theta')\n$$\nThe $\\rho$ in the denominator cancels with the $\\rho$ from the area element:\n$$\n\\phi_{\\text{exact}} = \\frac{1}{4\\pi} \\int_{0}^{2\\pi} \\mathrm{d}\\theta' \\int_{0}^{a} \\sigma(\\rho) \\, \\mathrm{d}\\rho\n$$\nThe integral over $\\theta'$ yields $2\\pi$.\n$$\n\\phi_{\\text{exact}} = \\frac{2\\pi}{4\\pi} \\int_{0}^{a} \\sigma(\\rho) \\, \\mathrm{d}\\rho = \\frac{1}{2} \\int_{0}^{a} \\sigma(\\rho) \\, \\mathrm{d}\\rho\n$$\nSubstituting the polynomial form of $\\sigma(\\rho)$:\n$$\n\\phi_{\\text{exact}} = \\frac{1}{2} \\int_{0}^{a} \\left( \\sum_{p=0}^{P} c_p \\rho^{2p} \\right) \\mathrm{d}\\rho\n$$\nInterchanging the finite sum and the integral:\n$$\n\\phi_{\\text{exact}} = \\frac{1}{2} \\sum_{p=0}^{P} c_p \\int_{0}^{a} \\rho^{2p} \\, \\mathrm{d}\\rho\n$$\nThe elementary integral is $\\int_{0}^{a} \\rho^{2p} \\, \\mathrm{d}\\rho = \\left[ \\frac{\\rho^{2p+1}}{2p+1} \\right]_{0}^{a} = \\frac{a^{2p+1}}{2p+1}$.\nThis yields the closed-form expression for the exact potential at the origin:\n$$\n\\phi_{\\text{exact}} = \\frac{1}{2} \\sum_{p=0}^{P} c_p \\frac{a^{2p+1}}{2p+1}\n$$\n\n### Singularity Subtraction Scheme\n\nThe problem proposes a singularity subtraction technique of order $L$. The potential is split into two parts: an analytically integrable part containing the singularity and a regularized remainder to be integrated numerically.\n$$\n\\phi = \\underbrace{\\int_{S} \\frac{\\sigma(\\rho) - \\sum_{p=0}^{L} c_p \\,\\rho^{2p}}{4\\pi \\rho} \\,\\mathrm{d}S'}_{I_{\\text{rem}}(L)} \\;+\\; \\underbrace{\\int_{S} \\frac{\\sum_{p=0}^{L} c_p \\,\\rho^{2p}}{4\\pi \\rho} \\,\\mathrm{d}S'}_{I_{\\text{sub}}(L)}\n$$\nThe numerical approximation is $\\phi_L = I_{\\text{rem, numerical}}(L) + I_{\\text{sub}}(L)$.\n\nThe analytical term $I_{\\text{sub}}(L)$ has the same form as the exact potential integral, but with the summation truncated at $p=L$. Following the same derivation:\n$$\nI_{\\text{sub}}(L) = \\frac{1}{2} \\sum_{p=0}^{L} c_p \\frac{a^{2p+1}}{2p+1}\n$$\n\nThe remainder integral $I_{\\text{rem}}(L)$ has an integrand that is regular at the origin. The numerator is $\\sigma(\\rho) - \\sum_{p=0}^{L} c_p \\,\\rho^{2p} = \\sum_{p=L+1}^{P} c_p \\,\\rho^{2p}$. The integrand is thus:\n$$\nf_L(\\rho) = \\frac{\\sum_{p=L+1}^{P} c_p \\rho^{2p}}{4\\pi \\rho} = \\frac{1}{4\\pi} \\sum_{p=L+1}^{P} c_p \\rho^{2p-1}\n$$\nThe leading term in this expansion behaves as $\\rho^{2(L+1)-1} = \\rho^{2L+1}$. For $L \\ge 0$, the exponent $2L+1$ is positive, ensuring that the integrand $f_L(\\rho)$ vanishes as $\\rho \\to 0$ and is therefore regular across the entire domain of integration.\n\n### Numerical Integration of the Remainder\n\nThe problem specifies that the remainder integral, $I_{\\text{rem}}(L) = \\int_S f_L(\\rho) \\, \\mathrm{d}S'$, must be computed using tensor-product Gauss-Legendre quadrature over the disk expressed in Cartesian coordinates:\n$$\nI_{\\text{rem}}(L) = \\int_{-a}^{a} \\left( \\int_{-\\sqrt{a^2-y'^2}}^{\\sqrt{a^2-y'^2}} f_L(\\sqrt{x'^2+y'^2}) \\, \\mathrm{d}x' \\right) \\mathrm{d}y'\n$$\nWe apply a change of variables to map the standard Gauss-Legendre interval $[-1, 1]$ to the integration limits.\n\n1.  **Outer Integral (over $y'$):** The integration is over $y' \\in [-a, a]$. We use the linear mapping $\\eta \\in [-1, 1] \\to y'$:\n    $$ y'(\\eta) = a \\eta, \\quad \\mathrm{d}y' = a \\, \\mathrm{d}\\eta $$\n\n2.  **Inner Integral (over $x'$):** For a fixed outer node $\\eta_j$, corresponding to $y'_j = a \\eta_j$, the inner limits are $x' \\in [-X_j, X_j]$, where $X_j = \\sqrt{a^2 - (y'_j)^2} = a\\sqrt{1-\\eta_j^2}$. We use the mapping $\\xi \\in [-1, 1] \\to x'$:\n    $$ x'(\\xi) = X_j \\xi, \\quad \\mathrm{d}x' = X_j \\, \\mathrm{d}\\xi $$\n\nThe double integral is approximated by a nested sum:\n$$\nI_{\\text{rem}}(L) \\approx \\sum_{j=1}^{N_y} w_j^{(\\eta)} \\left[ a \\left( \\sum_{i=1}^{N_x} w_i^{(\\xi)} f_L(\\rho_{ij}) X_j \\right) \\right]\n$$\nwhere $(\\eta_j, w_j^{(\\eta)})$ are the $N_y$ Gauss-Legendre nodes and weights for the outer integral, $(\\xi_i, w_i^{(\\xi)})$ are the $N_x$ nodes and weights for the inner integral, and $\\rho_{ij}$ is the radial position corresponding to the node pair $(\\xi_i, \\eta_j)$:\n$$\n\\rho_{ij} = \\sqrt{(x'( \\xi_i))^2 + (y'(\\eta_j))^2} = \\sqrt{(X_j \\xi_i)^2 + (a\\eta_j)^2}\n$$\nThe Jacobian of the complete transformation is $a \\cdot X_j = a^2\\sqrt{1-\\eta_j^2}$, which is correctly accounted for by the separate Jacobians of the inner ($X_j$) and outer ($a$) transformations.\n\n### Error Calculation\n\nFor each subtraction order $L \\in \\{0, 1, 2, 3\\}$, the numerical approximation of the potential is calculated as $\\phi_L = I_{\\text{sub}}(L) + I_{\\text{rem, numerical}}(L)$. The absolute error is then computed by comparing this approximation to the exact analytical value:\n$$\n\\varepsilon_L = |\\phi_L - \\phi_{\\text{exact}}|\n$$\nFor the case $L=P=3$, the remainder sum $\\sum_{p=4}^{3}$ is empty, so $f_3(\\rho)=0$ and $I_{\\text{rem}}(3)=0$. The subtracted term $I_{\\text{sub}}(3)$ becomes identical to $\\phi_{\\text{exact}}$. Consequently, $\\phi_3 = \\phi_{\\text{exact}}$, and the error $\\varepsilon_3$ is expected to be zero to within machine precision.", "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Solves the singularity subtraction problem as specified.\n    \n    This function computes the absolute error between an exact analytical potential\n    and a numerical approximation using a singularity subtraction technique. The\n    problem involves a scalar potential on a disk with a manufactured source.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    a = 1.0  # Disk radius\n    P = 3    # Polynomial degree of the source\n    # Source coefficients c_p for p=0, 1, 2, 3\n    c_coeffs = np.array([1.0, -0.7, 0.5, -0.2])\n\n    # --- Numerical Parameters ---\n    Ny = 64  # Number of quadrature nodes for the outer (y) integral\n    Nx = 64  # Number of quadrature nodes for the inner (x) integral\n\n    # --- Test Cases ---\n    L_values = [0, 1, 2, 3]  # Subtraction orders\n\n    def get_exact_potential(radius, p_max, coeffs):\n        \"\"\"\n        Computes the exact potential at the origin in closed form.\n        phi_exact = 0.5 * sum_{p=0 to P} c_p * a^(2p+1) / (2p+1)\n        \"\"\"\n        p_vals = np.arange(p_max + 1)\n        denominators = 2 * p_vals + 1\n        terms = coeffs * (radius**denominators) / denominators\n        return 0.5 * np.sum(terms)\n\n    def get_analytical_subtracted_term(radius, l_order, p_max, coeffs):\n        \"\"\"\n        Computes the analytically integrated subtracted term.\n        I_sub = 0.5 * sum_{p=0 to L} c_p * a^(2p+1) / (2p+1)\n        \"\"\"\n        if l_order < 0:\n            return 0.0\n        # Ensure we don't try to access coeffs beyond its defined length\n        capped_l_order = min(l_order, p_max)\n        p_vals = np.arange(capped_l_order + 1)\n        denominators = 2 * p_vals + 1\n        terms = coeffs[:capped_l_order+1] * (radius**denominators) / denominators\n        return 0.5 * np.sum(terms)\n\n    def remainder_integrand(rho, l_order, p_max, coeffs):\n        \"\"\"\n        Computes the regularized integrand of the remainder term.\n        f_L(rho) = (1 / 4pi) * sum_{p=L+1 to P} c_p * rho^(2p-1)\n        \"\"\"\n        if l_order >= p_max:\n            return np.zeros_like(rho) if hasattr(rho, 'shape') else 0.0\n\n        p_range = np.arange(l_order + 1, p_max + 1)\n        \n        # Use np.atleast_1d to handle both scalar and array inputs for rho\n        rho_arr = np.atleast_1d(rho)\n        \n        # Broadcasting computes rho^(power) for each rho and each power in p_range\n        # rho_arr[:, np.newaxis] has shape (len(rho_arr), 1)\n        # 2 * p_range - 1 has shape (len(p_range),)\n        # powers matrix has shape (len(rho_arr), len(p_range))\n        powers = rho_arr[:, np.newaxis] ** (2 * p_range - 1)\n        \n        # Sum over the p-index (axis=1)\n        integrand_sum = np.sum(coeffs[p_range] * powers, axis=1)\n        \n        result = integrand_sum / (4.0 * np.pi)\n        \n        # Return a scalar if the input was a scalar\n        return result.item() if isinstance(rho, (int, float)) else result\n\n    def get_numerical_remainder_integral(radius, l_order, p_max, coeffs, nx_nodes, ny_nodes):\n        \"\"\"\n        Computes the remainder integral using tensor-product Gauss-Legendre quadrature.\n        \"\"\"\n        xi_nodes, xi_weights = roots_legendre(nx_nodes)\n        eta_nodes, eta_weights = roots_legendre(ny_nodes)\n\n        integral_val = 0.0\n        \n        outer_jacobian = radius\n        \n        # Outer integral over y'\n        for j in range(ny_nodes):\n            eta_j = eta_nodes[j]\n            w_eta_j = eta_weights[j]\n            y_j = radius * eta_j\n            \n            x_max_j = radius * np.sqrt(1.0 - eta_j**2)\n            \n            if x_max_j == 0.0:  # This occurs at the poles (eta = +/- 1)\n                continue\n\n            inner_jacobian = x_max_j\n            \n            # Map inner nodes from [-1, 1] to [-x_max_j, x_max_j]\n            x_nodes = x_max_j * xi_nodes\n            \n            # Calculate radial distance rho at each inner quadrature point\n            rho_vals = np.sqrt(x_nodes**2 + y_j**2)\n            \n            # Evaluate the integrand at all inner points for the current outer point\n            integrand_vals = remainder_integrand(rho_vals, l_order, p_max, coeffs)\n            \n            # Calculate the inner integral via quadrature sum\n            inner_integral = np.sum(xi_weights * integrand_vals) * inner_jacobian\n            \n            # Accumulate the outer integral value\n            integral_val += w_eta_j * inner_integral\n\n        return integral_val * outer_jacobian\n\n    # --- Main Calculation Loop ---\n    \n    phi_exact = get_exact_potential(a, P, c_coeffs)\n    errors = []\n\n    for L in L_values:\n        # Calculate the analytical part of the potential\n        I_sub_analytical = get_analytical_subtracted_term(a, L, P, c_coeffs)\n        \n        # Calculate the remainder integral numerically\n        I_rem_numerical = get_numerical_remainder_integral(a, L, P, c_coeffs, Nx, Ny)\n        \n        # The total numerical approximation for the potential\n        phi_L = I_sub_analytical + I_rem_numerical\n        \n        # Calculate the absolute error\n        error = np.abs(phi_L - phi_exact)\n        errors.append(error)\n        \n    # --- Format and Print Output ---\n    print(f\"[{','.join(map(str, errors))}]\")\n\nsolve()\n```", "id": "3348130"}]}