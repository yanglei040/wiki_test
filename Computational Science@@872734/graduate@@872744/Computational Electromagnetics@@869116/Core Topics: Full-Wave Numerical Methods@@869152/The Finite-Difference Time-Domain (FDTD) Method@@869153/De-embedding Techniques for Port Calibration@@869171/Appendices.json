{"hands_on_practices": [{"introduction": "One of the most common requirements in port calibration is to correct for the propagation delay introduced by fixtures and cables. This delay, if unaccounted for, adds a frequency-dependent phase error to the measurement. This exercise [@problem_id:3297499] guides you through the fundamental process of de-embedding this delay, starting from the time-shift property of the Fourier transform. You will learn to derive the phase correction for a known delay and, conversely, to estimate an unknown delay from measured phase dataâ€”a crucial skill for practical characterization.", "problem": "You are calibrating the transmission scattering parameter $S_{21}$ of a two-port network in a computational electromagnetics workflow. The measurement reference planes are offset from the device under test by a uniform, frequency-independent propagation delay. In the frequency domain, a pure time delay manifests as a linear phase term. Use the time-shift property of the Fourier transform as the only admissible starting point: a shift by a positive time delay in the time domain corresponds to a linear-in-frequency phase change in the complex frequency response. From this base, reason out the appropriate phase de-embedding correction for a known delay and a regression-based method to estimate the delay from phase data when the delay is unknown.\n\nTasks:\n- Using the time-shift property as the fundamental base, derive the form of the unwrapped phase of $S_{21}(f)$ when an otherwise frequency-independent device is cascaded with a uniform time delay, and from that derivation determine the phase correction that must be applied to de-embed the delay. Angles must be treated in radians.\n- Using the same starting point, derive how to extract the time delay by a linear least-squares fit to unwrapped phase versus frequency. Specify which fit coefficient corresponds to the delay and justify the sign convention. Angles must be treated in radians and frequency in hertz.\n- Implement these two operations in a program:\n  - For cases where the delay is known, compute the phase correction to be added to the measured $S_{21}$ phase at a specified frequency.\n  - For cases where the delay is unknown and the measurement is a pure delay plus a constant phase offset (and possibly a small deterministic phase ripple), estimate the delay by a linear fit to the unwrapped phase versus frequency.\n\nPhysical and numerical units:\n- Report all angles in radians.\n- Report all time delays in seconds.\n- All frequencies are in hertz.\n\nTest suite:\nDefine the following four test cases. In every case, the complex measurement is synthesized as $S_{21}^{\\mathrm{meas}}(f) = A \\exp\\left(j\\left(\\phi_{0} + \\Delta\\phi_{\\mathrm{extra}}(f)\\right)\\right)$, where $A$ is a constant real amplitude, $\\phi_{0}$ is a constant phase offset in radians, and $\\Delta\\phi_{\\mathrm{extra}}(f)$ is the phase contribution due to the fixtures and any specified ripple. All arithmetic should treat angles in radians, frequencies in hertz, and time in seconds.\n\n- Case K$1$ (known delay; compute a phase correction at the median frequency index):\n  - Frequencies $\\mathbf{f}_{1} = [\\,1.0\\times 10^{9},\\,2.0\\times 10^{9},\\,3.0\\times 10^{9},\\,4.0\\times 10^{9},\\,5.0\\times 10^{9}\\,]\\,\\mathrm{Hz}$.\n  - Amplitude $A_{1} = 0.9$.\n  - Constant phase offset $\\phi_{0,1} = 0.7\\,\\mathrm{rad}$.\n  - Pure time delay $\\tau_{1} = 0.5\\times 10^{-9}\\,\\mathrm{s}$.\n  - No additional ripple, so $\\Delta\\phi_{\\mathrm{extra}}(f) = \\Delta\\phi_{\\mathrm{delay}}(f)$ only.\n  - Required output for this case: the de-embedding phase correction (to be added to the measured phase) evaluated at the median frequency index in $\\mathbf{f}_{1}$, expressed in radians.\n\n- Case U$2$ (unknown delay; estimate delay from a linear fit to unwrapped phase versus frequency):\n  - Frequencies $\\mathbf{f}_{2} = [\\,2.0\\times 10^{9},\\,3.0\\times 10^{9},\\,4.0\\times 10^{9},\\,5.0\\times 10^{9},\\,6.0\\times 10^{9},\\,7.0\\times 10^{9},\\,8.0\\times 10^{9},\\,9.0\\times 10^{9},\\,1.0\\times 10^{10}\\,]\\,\\mathrm{Hz}$.\n  - Amplitude $A_{2} = 0.95$.\n  - Constant phase offset $\\phi_{0,2} = -0.4\\,\\mathrm{rad}$.\n  - Pure time delay $\\tau_{2} = 0.275\\times 10^{-9}\\,\\mathrm{s}$.\n  - No additional ripple beyond the delay, so $\\Delta\\phi_{\\mathrm{extra}}(f) = \\Delta\\phi_{\\mathrm{delay}}(f)$ only.\n  - Required output for this case: the estimated delay in seconds, obtained by linear least-squares fitting of unwrapped measured phase versus frequency.\n\n- Case K$3$ (known zero delay; boundary condition for phase correction):\n  - Frequencies $\\mathbf{f}_{3} = [\\,9.0\\times 10^{9},\\,1.0\\times 10^{10},\\,1.1\\times 10^{10}\\,]\\,\\mathrm{Hz}$.\n  - Amplitude $A_{3} = 0.7$.\n  - Constant phase offset $\\phi_{0,3} = 1.2\\,\\mathrm{rad}$.\n  - Pure time delay $\\tau_{3} = 0.0\\,\\mathrm{s}$.\n  - No additional ripple beyond the delay, so $\\Delta\\phi_{\\mathrm{extra}}(f) = \\Delta\\phi_{\\mathrm{delay}}(f)$ only.\n  - Required output for this case: the de-embedding phase correction (to be added to the measured phase) evaluated at the median frequency index in $\\mathbf{f}_{3}$, expressed in radians.\n\n- Case U$4$ (unknown delay with small deterministic phase ripple):\n  - Frequencies $\\mathbf{f}_{4} = [\\,1.0\\times 10^{9},\\,2.0\\times 10^{9},\\,3.0\\times 10^{9},\\,4.0\\times 10^{9},\\,5.0\\times 10^{9},\\,6.0\\times 10^{9}\\,]\\,\\mathrm{Hz}$.\n  - Amplitude $A_{4} = 1.0$.\n  - Constant phase offset $\\phi_{0,4} = 0.3\\,\\mathrm{rad}$.\n  - Pure time delay $\\tau_{4} = 0.08\\times 10^{-9}\\,\\mathrm{s}$.\n  - Deterministic ripple of amplitude $\\alpha = 0.05\\,\\mathrm{rad}$ with angular argument proportional to frequency: set $\\Delta\\phi_{\\mathrm{extra}}(f) = \\Delta\\phi_{\\mathrm{delay}}(f) + \\alpha \\sin\\!\\left(2\\pi f / f_{\\mathrm{r}}\\right)$ with $f_{\\mathrm{r}} = 1.5\\times 10^{10}\\,\\mathrm{Hz}$.\n  - Required output for this case: the estimated delay in seconds, obtained by linear least-squares fitting of unwrapped measured phase versus frequency.\n\nImplementation details:\n- For each case, synthesize $S_{21}^{\\mathrm{meas}}(f)$ from the specified parameters. Treat the phase due to the uniform delay as linear in frequency according to the time-shift property, and add any specified ripple and constant offset.\n- Unwrap phase consistently across the frequency array before fitting.\n- For known-delay cases, compute the phase correction to be added at the median index in the provided frequency array.\n- For unknown-delay cases, compute the best-fit line to unwrapped phase versus frequency in the least-squares sense and infer the delay from the fit. Use only the fit result to form the reported delay; do not use the provided true delay in the computation.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the following order: $[\\,$K$1$ phase correction at median frequency in radians, U$2$ estimated delay in seconds, K$3$ phase correction at median frequency in radians, U$4$ estimated delay in seconds$\\,]$. For example, the output should look like $[\\text{result}_{1},\\text{result}_{2},\\text{result}_{3},\\text{result}_{4}]$ with each entry a real number.", "solution": "The problem of de-embedding a uniform time delay from a frequency-domain measurement of a two-port network is a standard procedure in computational and experimental electromagnetics, particularly in the calibration of vector network analyzer (VNA) measurements. The problem is scientifically grounded, well-posed, and all provided parameters are physically realistic and computationally sufficient. It is therefore deemed valid.\n\nThe solution is developed in two parts. First, the required mathematical relationships for phase correction and delay estimation are derived from the time-shift property of the Fourier transform as mandated. Second, these relationships are algorithmically applied to the specified test cases.\n\n**Part 1: Derivation from First Principles**\n\nThe fundamental principle provided is the time-shift property of the Fourier transform. Let a signal in the time domain be denoted by $s(t)$, and its Fourier transform in the frequency domain be $S(f)$, where $f$ is the frequency in Hertz and the Fourier transform is defined with angular frequency $\\omega = 2\\pi f$. The transform pair is:\n$$ s(t) \\leftrightarrow S(f) $$\nThe time-shift property states that a delay of $\\tau$ seconds in the time domain corresponds to a multiplication by a complex exponential $e^{-j2\\pi f \\tau}$ in the frequency domain:\n$$ s(t-\\tau) \\leftrightarrow S(f) e^{-j2\\pi f \\tau} $$\nA two-port network, such as a device under test (DUT), is characterized by its scattering parameters (S-parameters). The transmission parameter from port $1$ to port $2$, denoted $S_{21}(f)$, is a complex frequency-domain function representing the device's response.\n\nIf the measurement setup includes fixtures or cables that introduce a total propagation delay of $\\tau$, the measured transmission parameter, $S_{21}^{\\mathrm{meas}}(f)$, is the true parameter of the DUT, $S_{21}^{\\mathrm{DUT}}(f)$, cascaded with the frequency response of the pure delay. The impulse response of a pure delay is a delta function shifted in time, $h(t) = \\delta(t-\\tau)$, and its frequency response is $H_{\\mathrm{delay}}(f) = e^{-j2\\pi f \\tau}$.\n\nTherefore, the measured parameter is the product of the true parameter and the delay response:\n$$ S_{21}^{\\mathrm{meas}}(f) = S_{21}^{\\mathrm{DUT}}(f) \\cdot H_{\\mathrm{delay}}(f) = S_{21}^{\\mathrm{DUT}}(f) e^{-j2\\pi f \\tau} $$\nTo analyze the phase relationship, we express the complex S-parameters in polar form, for example, $S_{21}(f) = |S_{21}(f)| e^{j \\phi(f)}$, where $\\phi(f)$ is the phase of the S-parameter at frequency $f$. The equation becomes:\n$$ |S_{21}^{\\mathrm{meas}}(f)| e^{j \\phi_{\\mathrm{meas}}(f)} = \\left( |S_{21}^{\\mathrm{DUT}}(f)| e^{j \\phi_{\\mathrm{DUT}}(f)} \\right) e^{-j2\\pi f \\tau} $$\nBy equating the magnitudes and phases separately, we observe that the magnitude is unaffected by a pure delay ($|S_{21}^{\\mathrm{meas}}(f)| = |S_{21}^{\\mathrm{DUT}}(f)|$), while the phases are related by:\n$$ \\phi_{\\mathrm{meas}}(f) = \\phi_{\\mathrm{DUT}}(f) - 2\\pi f \\tau $$\nThis relationship strictly holds for the unwrapped phase, as the term $-2\\pi f \\tau$ can span a range greater than $2\\pi$ radians over a typical measurement bandwidth.\n\n**Task 1: Derivation of the Phase Correction (De-embedding)**\n\nDe-embedding is the process of recovering the true DUT response, $\\phi_{\\mathrm{DUT}}(f)$, from the measured response, $\\phi_{\\mathrm{meas}}(f)$. By rearranging the phase equation, we solve for $\\phi_{\\mathrm{DUT}}(f)$:\n$$ \\phi_{\\mathrm{DUT}}(f) = \\phi_{\\mathrm{meas}}(f) + 2\\pi f \\tau $$\nThis equation shows that to de-embed a known, positive time delay $\\tau$, one must add a positive, linearly increasing phase term to the measured phase. The required phase correction to be added, $\\phi_{\\mathrm{corr}}(f)$, is therefore:\n$$ \\phi_{\\mathrm{corr}}(f) = +2\\pi f \\tau $$\nAll angles are in radians, frequency $f$ is in Hertz, and time delay $\\tau$ is in seconds.\n\n**Task 2: Derivation of Delay Estimation via Linear Fit**\n\nWhen the delay $\\tau$ is unknown, it can be estimated from the measured phase data. We again start from the relationship for the unwrapped measured phase:\n$$ \\phi_{\\mathrm{meas}}(f) = \\phi_{\\mathrm{DUT}}(f) - 2\\pi \\tau f $$\nThe problem states that for this estimation, the DUT can be modeled as having a constant phase offset, $\\phi_0$, which is a common assumption for electrically short devices or as a first-order approximation. Thus, we set $\\phi_{\\mathrm{DUT}}(f) = \\phi_0$. The model for the measured phase becomes:\n$$ \\phi_{\\mathrm{meas}}(f) = \\phi_0 - 2\\pi \\tau f $$\nThis equation is in the form of a straight line, $y = c + mx$, where:\n- The dependent variable $y$ is the unwrapped measured phase, $\\phi_{\\mathrm{meas}}(f)$.\n- The independent variable $x$ is the frequency, $f$.\n- The y-intercept $c$ is the constant phase offset of the DUT, $\\phi_0$.\n- The slope $m$ is the coefficient of the frequency term, $m = -2\\pi \\tau$.\n\nGiven a set of measurements of unwrapped phase $\\phi_{\\mathrm{meas}}(f_i)$ at discrete frequencies $f_i$, we can perform a linear least-squares regression to find the best-fit slope, $m$. From the estimated slope, the time delay $\\tau$ can be determined by rearranging the slope equation:\n$$ \\tau = -\\frac{m}{2\\pi} $$\nThe sign convention is justified as follows: a positive physical time delay $\\tau > 0$ causes the signal to arrive later, which corresponds to an increasingly negative phase lag as frequency increases. This results in a negative slope ($m  0$) for the plot of phase versus frequency. The negative sign in the formula $\\tau = -m/(2\\pi)$ correctly converts this negative slope back into a positive time delay, consistent with physical causality.\n\n**Part 2: Algorithmic Implementation**\n\nThe program implements these two derived procedures for the four specified test cases.\n\nFor cases K$1$ and K$3$, where the delay $\\tau$ is known, the task is to compute the phase correction. The derived formula $\\phi_{\\mathrm{corr}}(f) = 2\\pi f \\tau$ is applied at the specified frequency, which is the frequency at the median index of the provided array.\n\nFor cases U$2$ and U$4$, where the delay $\\tau$ is unknown, the task is to estimate it. The following steps are performed:\n$1$. Synthesize the complex S-parameter data, $S_{21}^{\\mathrm{meas}}(f)$, for each frequency point. The unwrapped phase, $\\phi_{\\mathrm{meas}}(f)$, is calculated according to the model $S_{21}^{\\mathrm{meas}}(f) = A \\exp\\left(j\\left(\\phi_{0} + \\Delta\\phi_{\\mathrm{extra}}(f)\\right)\\right)$. The extra phase, $\\Delta\\phi_{\\mathrm{extra}}(f)$, is composed of the linear phase from the delay, $\\Delta\\phi_{\\mathrm{delay}}(f) = -2\\pi \\tau f$, and any specified deterministic ripple. By construction, the synthesized phase array is already unwrapped.\n$2$. A linear least-squares fit is performed on the synthesized unwrapped phase data points $(\\phi_{\\mathrm{meas}}(f_i), f_i)$ using `numpy.polyfit` with degree $1$. This yields the slope $m$ and intercept $c$ of the best-fit line.\n$3$. The estimated delay, $\\tau_{\\mathrm{est}}$, is calculated from the slope using the derived formula $\\tau_{\\mathrm{est}} = -m/(2\\pi)$.\n\nFor case U$4$, the presence of a sinusoidal phase ripple adds a small, non-linear perturbation to the otherwise linear phase characteristic. The least-squares fitting process naturally averages over such zero-mean (or near-zero-mean over the data interval) variations to find the dominant linear trend, providing a robust estimate of the underlying group delay.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the de-embedding problem for four test cases as specified.\n    - For known delays, computes phase correction.\n    - For unknown delays, estimates the delay from a linear fit to phase data.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Using a list of dictionaries for clarity and structure.\n    test_cases = [\n        {\n            \"id\": \"K1\",\n            \"type\": \"known_delay\",\n            \"f\": np.array([1.0e9, 2.0e9, 3.0e9, 4.0e9, 5.0e9]),\n            \"A\": 0.9,\n            \"phi0\": 0.7,\n            \"tau\": 0.5e-9,\n            \"ripple\": None,\n        },\n        {\n            \"id\": \"U2\",\n            \"type\": \"unknown_delay\",\n            \"f\": np.arange(2.0e9, 1.0e10 + 1e9, 1.0e9),\n            \"A\": 0.95,\n            \"phi0\": -0.4,\n            \"tau\": 0.275e-9,\n            \"ripple\": None,\n        },\n        {\n            \"id\": \"K3\",\n            \"type\": \"known_delay\",\n            \"f\": np.array([9.0e9, 1.0e10, 1.1e10]),\n            \"A\": 0.7,\n            \"phi0\": 1.2,\n            \"tau\": 0.0,\n            \"ripple\": None,\n        },\n        {\n            \"id\": \"U4\",\n            \"type\": \"unknown_delay\",\n            \"f\": np.arange(1.0e9, 6.0e9 + 1e9, 1.0e9),\n            \"A\": 1.0,\n            \"phi0\": 0.3,\n            \"tau\": 0.08e-9,\n            \"ripple\": {\"alpha\": 0.05, \"fr\": 1.5e10},\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        if case[\"type\"] == \"known_delay\":\n            # For known delay cases, compute the phase correction to be added\n            # at the median frequency index.\n            f_array = case[\"f\"]\n            tau = case[\"tau\"]\n\n            # The median index for an array with an odd number of elements.\n            median_index = len(f_array) // 2\n            f_median = f_array[median_index]\n\n            # The phase correction is phi_corr(f) = 2 * pi * tau * f.\n            phase_correction = 2 * np.pi * tau * f_median\n            results.append(phase_correction)\n\n        elif case[\"type\"] == \"unknown_delay\":\n            # For unknown delay cases, estimate the delay by fitting\n            # a line to the unwrapped phase vs. frequency.\n            f_array = case[\"f\"]\n            phi0 = case[\"phi0\"]\n            tau_true = case[\"tau\"]  # Used only for data synthesis.\n\n            # Step 1: Synthesize the measured unwrapped phase.\n            # The phase due to delay is phi_delay(f) = -2 * pi * tau * f.\n            phase_from_delay = -2 * np.pi * tau_true * f_array\n            \n            # Start with the constant offset and the delay phase.\n            unwrapped_phase = phi0 + phase_from_delay\n\n            # Add any specified phase ripple.\n            if case[\"ripple\"] is not None:\n                alpha = case[\"ripple\"][\"alpha\"]\n                f_r = case[\"ripple\"][\"fr\"]\n                phase_from_ripple = alpha * np.sin(2 * np.pi * f_array / f_r)\n                unwrapped_phase += phase_from_ripple\n\n            # Step 2: Perform a linear least-squares fit.\n            # a.k.a. polynomial fit of degree 1.\n            # model is: phi(f) = slope * f + intercept\n            slope, _ = np.polyfit(f_array, unwrapped_phase, 1)\n\n            # Step 3: Infer the delay from the slope.\n            # From derivation, slope m = -2 * pi * tau.\n            # So, tau = -slope / (2 * pi).\n            tau_estimated = -slope / (2 * np.pi)\n            results.append(tau_estimated)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3297499"}, {"introduction": "Scattering parameters are fundamentally defined with respect to a reference impedance, which is often a standardized $50\\,\\Omega$. However, for differential circuits, it is common to renormalize the ports to a differential impedance, like $100\\,\\Omega$. This practice [@problem_id:3297476] explores the essential technique of port renormalization. By applying the fundamental relationship between impedance and reflection coefficient, you will compute the new mixed-mode S-parameters for a device after changing the reference impedance of its differential port.", "problem": "Consider a perfectly symmetric two-conductor Device Under Test (DUT) measured in a mixed-mode basis using a Vector Network Analyzer (VNA) after port calibration. By symmetry and balance, there is no mode conversion at the frequency of interest, so the mixed-mode description reduces to two uncoupled one-ports: the differential mode and the common mode. The measured mixed-mode impedance matrix at this frequency is diagonal,\n$$\n\\mathbf{Z}_{\\mathrm{mm}}=\\begin{pmatrix}\nZ_{dd}  0 \\\\\n0  Z_{cc}\n\\end{pmatrix},\n$$\nwith entries $Z_{dd}=80+\\mathrm{j}40\\,\\Omega$ and $Z_{cc}=25-\\mathrm{j}10\\,\\Omega$, where $\\mathrm{j}$ denotes the unit imaginary number used in electrical engineering. The existing single-ended per-conductor reference impedance used in the initial calibration is $Z_{\\mathrm{se,old}}=40\\,\\Omega$, which implies the mixed-mode reference impedances $R_{d,\\mathrm{old}}=2Z_{\\mathrm{se,old}}=80\\,\\Omega$ for the differential mode and $R_{c,\\mathrm{old}}=Z_{\\mathrm{se,old}}/2=20\\,\\Omega$ for the common mode.\n\nYou now wish to apply a de-embedding renormalization to the differential mixed-mode port so that its desired reference impedance is $2Z_0$, with $Z_0=50\\,\\Omega$. Thus, the new differential reference impedance is $R_{d,\\mathrm{new}}=2Z_0=100\\,\\Omega$. The common-mode reference is intentionally left unchanged at $R_{c,\\mathrm{old}}=20\\,\\Omega$.\n\nStarting only from the fundamental definition of scattering parameters in terms of power waves referenced to a real reference impedance and the basic mixed-mode decomposition that produces uncoupled differential and common-mode ports under perfect symmetry, derive the expressions that map the given mixed-mode impedance entries to the renormalized mixed-mode reflection coefficients. Then compute the renormalized mixed-mode reflection coefficients $S_{dd,\\mathrm{new}}$ and $S_{cc,\\mathrm{new}}$.\n\nExpress both $S_{dd,\\mathrm{new}}$ and $S_{cc,\\mathrm{new}}$ in rectangular complex form $a+\\mathrm{j}b$ with no units, and round your answers to four significant figures. Provide your final result as two entries in a single row.", "solution": "We begin from first principles. For a one-port with port voltage $V$ and current $I$, referenced to a real reference impedance $R0$, the power-wave definitions are\n$$\na=\\frac{V+RI}{2\\sqrt{R}},\\qquad b=\\frac{V-RI}{2\\sqrt{R}},\n$$\nand the one-port scattering parameter is the reflection coefficient\n$$\nS=\\frac{b}{a}.\n$$\nEliminating $V$ and $I$ using the terminal relation $V=ZI$ for the one-port yields the well-tested mapping between the load impedance $Z$ and the reflection coefficient referenced to $R$,\n$$\nS=\\frac{Z-R}{Z+R}.\n$$\nThis relation is the fundamental base that connects impedances to scattering parameters for a given reference impedance.\n\nIn the mixed-mode description for a perfectly symmetric two-conductor DUT with no mode conversion, the differential and common-mode ports are uncoupled one-ports. The mixed-mode impedance matrix is diagonal,\n$$\n\\mathbf{Z}_{\\mathrm{mm}}=\\begin{pmatrix}\nZ_{dd}  0 \\\\\n0  Z_{cc}\n\\end{pmatrix},\n$$\nwith $Z_{dd}=80+\\mathrm{j}40\\,\\Omega$ and $Z_{cc}=25-\\mathrm{j}10\\,\\Omega$. The renormalization operation changes only the reference impedance used to compute the scattering parameter for the differential mode; the physical $\\mathbf{Z}_{\\mathrm{mm}}$ is intrinsic to the DUT and does not depend on the reference. Because the modes are uncoupled, changing the differential-mode reference leaves the common-mode scattering parameter unaffected except for its own reference, which we are not changing.\n\nTherefore:\n1. For the differential mode, the renormalized reflection coefficient referenced to $R_{d,\\mathrm{new}}=100\\,\\Omega$ is\n$$\nS_{dd,\\mathrm{new}}=\\frac{Z_{dd}-R_{d,\\mathrm{new}}}{Z_{dd}+R_{d,\\mathrm{new}}}=\\frac{(80+\\mathrm{j}40)-100}{(80+\\mathrm{j}40)+100}=\\frac{-20+\\mathrm{j}40}{180+\\mathrm{j}40}.\n$$\nWe simplify this ratio. First factor out $20$:\n$$\n\\frac{-20+\\mathrm{j}40}{180+\\mathrm{j}40}=\\frac{-1+\\mathrm{j}2}{9+\\mathrm{j}2}.\n$$\nMultiply numerator and denominator by the complex conjugate of the denominator:\n$$\n\\frac{(-1+\\mathrm{j}2)(9-\\mathrm{j}2)}{(9+\\mathrm{j}2)(9-\\mathrm{j}2)}=\\frac{(-9)+\\mathrm{j}2+\\mathrm{j}18+4}{81+4}=\\frac{-5+\\mathrm{j}20}{85}=-\\frac{1}{17}+\\mathrm{j}\\frac{4}{17}.\n$$\nIn rectangular form, this is $-\\frac{1}{17}+\\mathrm{j}\\frac{4}{17}$.\n\n2. For the common mode, since we are leaving its reference impedance unchanged at $R_{c,\\mathrm{old}}=20\\,\\Omega$, the renormalized common-mode scattering parameter equals the one computed from $Z_{cc}$ referenced to $20\\,\\Omega$:\n$$\nS_{cc,\\mathrm{new}}=\\frac{Z_{cc}-R_{c,\\mathrm{old}}}{Z_{cc}+R_{c,\\mathrm{old}}}=\\frac{(25-\\mathrm{j}10)-20}{(25-\\mathrm{j}10)+20}=\\frac{5-\\mathrm{j}10}{45-\\mathrm{j}10}.\n$$\nFactor out $5$ and simplify:\n$$\n\\frac{5-\\mathrm{j}10}{45-\\mathrm{j}10}=\\frac{1-\\mathrm{j}2}{9-\\mathrm{j}2}=\\frac{(1-\\mathrm{j}2)(9+\\mathrm{j}2)}{(9-\\mathrm{j}2)(9+\\mathrm{j}2)}=\\frac{9+\\mathrm{j}2-\\mathrm{j}18+4}{81+4}=\\frac{13-\\mathrm{j}16}{85}=\\frac{13}{85}-\\mathrm{j}\\frac{16}{85}.\n$$\nIn rectangular form, this is $\\frac{13}{85}-\\mathrm{j}\\frac{16}{85}$.\n\nFinally, we round both complex numbers to four significant figures as required. Using the exact fractional forms:\n- For $S_{dd,\\mathrm{new}}=-\\frac{1}{17}+\\mathrm{j}\\frac{4}{17}$, we have $-\\frac{1}{17}\\approx -0.0588235\\ldots$ and $\\frac{4}{17}\\approx 0.2352941\\ldots$, which to four significant figures gives\n$$\nS_{dd,\\mathrm{new}}\\approx -0.05882+\\mathrm{j}0.2353.\n$$\n- For $S_{cc,\\mathrm{new}}=\\frac{13}{85}-\\mathrm{j}\\frac{16}{85}$, we have $\\frac{13}{85}\\approx 0.1529412\\ldots$ and $\\frac{16}{85}\\approx 0.1882353\\ldots$, which to four significant figures gives\n$$\nS_{cc,\\mathrm{new}}\\approx 0.1529-\\mathrm{j}0.1882.\n$$\n\nThus, the renormalization of the differential port to $2Z_0$ modifies $S_{dd}$ to the value above, while $S_{cc}$ remains the value computed with its unchanged reference.", "answer": "$$\\boxed{\\begin{pmatrix}-0.05882+\\mathrm{j}0.2353  0.1529-\\mathrm{j}0.1882\\end{pmatrix}}$$", "id": "3297476"}, {"introduction": "De-embedding processes and measurement noise can sometimes yield a model that violates the fundamental physical law of energy conservation, appearing as a non-passive device. Enforcing passivity is a critical final step to ensure a model's physical realizability. This advanced exercise [@problem_id:3297516] introduces a powerful computational technique to correct for such violations. You will formulate and solve a convex optimization problem to find the minimal perturbation that renders a scattering matrix robustly passive, a method with wide applications in model validation.", "problem": "You are given a scattering-parameter matrix function $S(\\omega) \\in \\mathbb{C}^{n \\times n}$ describing a calibrated multiport device under test (DUT) after port de-embedding. For a passive, linear, time-invariant network, the scattering representation implies energy conservation through the inequality $S(\\omega)^{\\mathrm{H}} S(\\omega) \\preceq I$, where $I$ is the identity matrix and $A \\preceq B$ denotes that $B - A$ is positive semidefinite. Equivalently, $\\|S(\\omega)\\|_{2} \\leq 1$ for all angular frequencies $\\omega$, where $\\|\\cdot\\|_{2}$ denotes the operator norm (largest singular value). Measurement and de-embedding introduce bounded uncertainty $E(\\omega)$ such that $\\|E(\\omega)\\|_{2} \\leq u(\\omega)$ for a known bound $u(\\omega) \\in [0,1]$. Under this uncertainty model, robust passivity of the corrected model $S(\\omega) + \\Delta(\\omega)$ means that the worst-case operator norm remains bounded by $1$:\n$$\n\\sup_{\\|E(\\omega)\\|_{2} \\leq u(\\omega)} \\|S(\\omega) + \\Delta(\\omega) + E(\\omega)\\|_{2} \\leq 1 \\quad \\text{for all } \\omega.\n$$\nYou are asked to compute, for several test cases, the minimal perturbation $\\Delta(\\omega)$ that enforces robust passivity while minimizing the total squared Frobenius norm across all frequency samples. Formulate the convex optimization problem at each sampled frequency $\\omega_k$ using the objective $\\sum_k \\|\\Delta(\\omega_k)\\|_{F}^{2}$ subject to robust passivity constraints, and solve it exactly by computing the projection of $S(\\omega_k)$ onto the operator-norm ball of radius $1 - u(\\omega_k)$. Use the following fundamental bases:\n\n- Scattering passivity: $S(\\omega)^{\\mathrm{H}} S(\\omega) \\preceq I$.\n- Operator norm subadditivity and worst-case bound: $\\sup_{\\|E\\|_{2} \\leq u} \\|X + E\\|_{2} = \\|X\\|_{2} + u$.\n- Frobenius norm: $\\|A\\|_{F} = \\sqrt{\\mathrm{trace}(A^{\\mathrm{H}} A)}$.\n- Singular value decomposition (SVD): for $A \\in \\mathbb{C}^{n \\times n}$, $A = U \\Sigma V^{\\mathrm{H}}$ with unitary $U,V$ and diagonal $\\Sigma = \\mathrm{diag}(\\sigma_1,\\dots,\\sigma_n)$, $\\sigma_i \\geq 0$.\n\nYour program must implement the exact solution of this convex projection: for each $\\omega_k$, compute the SVD of $S(\\omega_k)$, clamp each singular value $\\sigma_i(\\omega_k)$ to $\\min\\{\\sigma_i(\\omega_k), 1 - u(\\omega_k)\\}$, reconstruct the projected matrix $S_{\\mathrm{proj}}(\\omega_k)$, and set $\\Delta(\\omega_k) = S_{\\mathrm{proj}}(\\omega_k) - S(\\omega_k)$. Report the aggregate minimal perturbation magnitude across all $\\omega_k$ samples for each test case as the value\n$$\n\\left\\|\\Delta\\right\\|_{F, \\mathrm{agg}} = \\sqrt{\\sum_{k} \\|\\Delta(\\omega_k)\\|_{F}^{2}},\n$$\nwhich is dimensionless.\n\nTest Suite:\n\nCompute $\\left\\|\\Delta\\right\\|_{F, \\mathrm{agg}}$ for each of the following four test cases. In all cases, the number of ports is $n = 2$, and the frequency grid contains three samples indexed by $k = 1,2,3$. Matrices are specified entry-wise, with $\\mathrm{j}$ denoting the imaginary unit.\n\n- Test Case 1 (happy path; already robustly passive):\n  - $u(\\omega_k) = 0.02$ for $k=1,2,3$.\n  - $S(\\omega_1) = \\begin{bmatrix} 0.10  0.05 \\\\ 0.02  0.08 \\end{bmatrix}$,\n    $S(\\omega_2) = \\begin{bmatrix} 0.15  -0.05\\,\\mathrm{j} \\\\ 0.01  0.12 \\end{bmatrix}$,\n    $S(\\omega_3) = \\begin{bmatrix} 0.20  0 \\\\ 0  0.20 \\end{bmatrix}$.\n- Test Case 2 (boundary-condition case; near the passivity limit):\n  - $u(\\omega_k) = 0.03$ for $k=1,2,3$.\n  - $S(\\omega_1) = \\begin{bmatrix} 0.99  0 \\\\ 0  0.99 \\end{bmatrix}$,\n    $S(\\omega_2) = \\begin{bmatrix} 1.02  0 \\\\ 0  0.95 \\end{bmatrix}$,\n    $S(\\omega_3) = \\begin{bmatrix} 0.98  0 \\\\ 0  0.98 \\end{bmatrix}$.\n- Test Case 3 (significantly non-passive; large correction needed):\n  - $u(\\omega_k) = 0.10$ for $k=1,2,3$.\n  - $S(\\omega_1) = \\begin{bmatrix} 1.30  0 \\\\ 0  0.80 \\end{bmatrix}$,\n    $S(\\omega_2) = \\begin{bmatrix} 1.10  0 \\\\ 0  1.05 \\end{bmatrix}$,\n    $S(\\omega_3) = \\begin{bmatrix} 2.00  0 \\\\ 0  0.10 \\end{bmatrix}$.\n- Test Case 4 (extreme uncertainty; only the zero matrix is robustly passive):\n  - $u(\\omega_k) = 1.00$ for $k=1,2,3$.\n  - $S(\\omega_1) = \\begin{bmatrix} 0.30  0 \\\\ 0  0.20 \\end{bmatrix}$,\n    $S(\\omega_2) = \\begin{bmatrix} 0.10  0 \\\\ 0  0.40 \\end{bmatrix}$,\n    $S(\\omega_3) = \\begin{bmatrix} 0.50  0 \\\\ 0  0.50 \\end{bmatrix}$.\n\nAlgorithmic Requirements:\n\n- For each matrix $S(\\omega_k)$, compute its singular value decomposition $U(\\omega_k) \\Sigma(\\omega_k) V(\\omega_k)^{\\mathrm{H}}$ and define $\\Sigma_{\\mathrm{proj}}(\\omega_k) = \\mathrm{diag}\\!\\left(\\min\\{\\sigma_i(\\omega_k), 1 - u(\\omega_k)\\}\\right)$.\n- Form $S_{\\mathrm{proj}}(\\omega_k) = U(\\omega_k) \\Sigma_{\\mathrm{proj}}(\\omega_k) V(\\omega_k)^{\\mathrm{H}}$ and $\\Delta(\\omega_k) = S_{\\mathrm{proj}}(\\omega_k) - S(\\omega_k)$.\n- Compute $\\left\\|\\Delta\\right\\|_{F, \\mathrm{agg}} = \\sqrt{\\sum_k \\|\\Delta(\\omega_k)\\|_{F}^{2}}$ for the test case.\n\nFinal Output Format:\n\nYour program should produce a single line of output containing the results for the four test cases as a comma-separated list enclosed in square brackets, with each value rounded to six decimal places (e.g., \"[0.000000,0.123456,1.000000,0.500000]\"). No physical units are involved; all quantities are dimensionless.", "solution": "The problem requires the computation of a minimal perturbation, $\\Delta(\\omega)$, to a set of scattering parameter matrices, $S(\\omega)$, to ensure robust passivity. The minimization is performed with respect to the aggregate squared Frobenius norm of the perturbation over a discrete set of frequencies, $\\omega_k$.\n\nFirst, we must formalize the constraint of robust passivity. The problem states that a corrected model, $S(\\omega) + \\Delta(\\omega)$, is robustly passive under an uncertainty model with bound $u(\\omega)$ if the following condition holds for all frequencies $\\omega$:\n$$\n\\sup_{\\|E(\\omega)\\|_{2} \\leq u(\\omega)} \\|S(\\omega) + \\Delta(\\omega) + E(\\omega)\\|_{2} \\leq 1\n$$\nHere, $\\|\\cdot\\|_{2}$ denotes the operator norm, which is equal to the largest singular value of the matrix. The problem provides the fundamental property of the operator norm: $\\sup_{\\|E\\|_{2} \\leq u} \\|X + E\\|_{2} = \\|X\\|_{2} + u$. Applying this property to the robust passivity condition at each discrete frequency sample $\\omega_k$, we get:\n$$\n\\|S(\\omega_k) + \\Delta(\\omega_k)\\|_{2} + u(\\omega_k) \\leq 1\n$$\nThis inequality can be rearranged to define the constraint on the corrected matrix, which we denote as $S'_{\\text{proj}}(\\omega_k) = S(\\omega_k) + \\Delta(\\omega_k)$:\n$$\n\\|S'_{\\text{proj}}(\\omega_k)\\|_{2} \\leq 1 - u(\\omega_k)\n$$\nLet's define the passivity radius at each frequency as $R_k = 1 - u(\\omega_k)$. The condition is that the largest singular value of the corrected matrix $S'_{\\text{proj}}(\\omega_k)$ must not exceed $R_k$.\n\nThe objective is to find the perturbation $\\Delta$ that minimizes the aggregate squared Frobenius norm, $\\|\\Delta\\|_{F, \\mathrm{agg}}^{2} = \\sum_k \\|\\Delta(\\omega_k)\\|_{F}^{2}$. Since the objective function is a sum of non-negative terms, and the constraints for each frequency $\\omega_k$ are independent of one another, we can minimize the total sum by minimizing each term $\\|\\Delta(\\omega_k)\\|_{F}^{2}$ independently.\n\nFor each frequency $\\omega_k$, we must solve the following optimization problem:\n$$\n\\begin{aligned}\n\\underset{\\Delta(\\omega_k) \\in \\mathbb{C}^{n \\times n}}{\\text{minimize}}  \\quad \\|\\Delta(\\omega_k)\\|_{F}^{2} \\\\\n\\text{subject to}  \\quad \\|S(\\omega_k) + \\Delta(\\omega_k)\\|_{2} \\leq R_k\n\\end{aligned}\n$$\nThis is equivalent to finding a matrix $S'_{\\text{proj}}(\\omega_k)$ that satisfies the operator norm constraint and is closest to the original matrix $S(\\omega_k)$ in the Frobenius norm sense. This is a classic problem of projecting a matrix onto the convex set of all matrices whose operator norm is bounded by a given radius. The solution to this problem is given by singular value thresholding (or clamping).\n\nLet the singular value decomposition (SVD) of the matrix $S(\\omega_k)$ be:\n$$\nS(\\omega_k) = U_k \\Sigma_k V_k^{\\mathrm{H}}\n$$\nwhere $U_k$ and $V_k$ are unitary matrices, and $\\Sigma_k = \\mathrm{diag}(\\sigma_{k,1}, \\sigma_{k,2}, \\dots, \\sigma_{k,n})$ is a diagonal matrix of non-negative singular values $\\sigma_{k,i}$ in non-increasing order. The solution to the projection problem, $S'_{\\text{proj}}(\\omega_k)$, is obtained by clamping the singular values of $S(\\omega_k)$ that exceed the radius $R_k = 1 - u(\\omega_k)$. The projected matrix is given by:\n$$\nS'_{\\text{proj}}(\\omega_k) = U_k \\Sigma'_{k} V_k^{\\mathrm{H}}\n$$\nwhere $\\Sigma'_{k} = \\mathrm{diag}(\\sigma'_{k,1}, \\sigma'_{k,2}, \\dots, \\sigma'_{k,n})$, and each new singular value is calculated as:\n$$\n\\sigma'_{k,i} = \\min(\\sigma_{k,i}, R_k) = \\min(\\sigma_{k,i}, 1 - u(\\omega_k))\n$$\nThe optimal perturbation $\\Delta(\\omega_k)$ is then the difference between the projected and original matrices:\n$$\n\\Delta(\\omega_k) = S'_{\\text{proj}}(\\omega_k) - S(\\omega_k) = U_k (\\Sigma'_k - \\Sigma_k) V_k^{\\mathrm{H}}\n$$\nWe need to calculate the squared Frobenius norm of this perturbation. The Frobenius norm is unitarily invariant, meaning $\\|A\\|_{F} = \\|UAV\\|_{F}$ for any unitary $U, V$. Therefore:\n$$\n\\|\\Delta(\\omega_k)\\|_{F}^{2} = \\|U_k (\\Sigma'_k - \\Sigma_k) V_k^{\\mathrm{H}}\\|_{F}^{2} = \\|\\Sigma'_k - \\Sigma_k\\|_{F}^{2}\n$$\nSince $\\Sigma'_k - \\Sigma_k$ is a diagonal matrix with entries $(\\sigma'_{k,i} - \\sigma_{k,i})$, its squared Frobenius norm is the sum of the squares of these diagonal entries:\n$$\n\\|\\Delta(\\omega_k)\\|_{F}^{2} = \\sum_{i=1}^{n} (\\sigma'_{k,i} - \\sigma_{k,i})^2 = \\sum_{i=1}^{n} (\\min(\\sigma_{k,i}, 1 - u(\\omega_k)) - \\sigma_{k,i})^2\n$$\nThis expression can be simplified. If $\\sigma_{k,i} \\leq 1-u(\\omega_k)$, the term is zero. If $\\sigma_{k,i}  1-u(\\omega_k)$, the term is $( (1-u(\\omega_k)) - \\sigma_{k,i} )^2 = (\\sigma_{k,i} - (1-u(\\omega_k)))^2$. Thus, the sum is only over the singular values that violate the constraint:\n$$\n\\|\\Delta(\\omega_k)\\|_{F}^{2} = \\sum_{\\sigma_{k,i}  1-u(\\omega_k)} (\\sigma_{k,i} - (1-u(\\omega_k)))^2\n$$\nFinally, the aggregate minimal perturbation magnitude is the square root of the sum of these squared norms over all frequency samples:\n$$\n\\left\\|\\Delta\\right\\|_{F, \\mathrm{agg}} = \\sqrt{\\sum_{k} \\|\\Delta(\\omega_k)\\|_{F}^{2}}\n$$\nThis procedure will be applied to each test case. For each $S(\\omega_k)$, we compute its singular values, calculate the sum of squared differences for those exceeding the threshold $1-u(\\omega_k)$, sum these contributions across all frequencies $k$ for a given test case, and take the square root of the total sum.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the robust passivity enforcement problem for a set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"u\": 0.02,\n            \"S_matrices\": [\n                np.array([[0.10, 0.05], [0.02, 0.08]], dtype=complex),\n                np.array([[0.15, -0.05j], [0.01, 0.12]], dtype=complex),\n                np.array([[0.20, 0], [0, 0.20]], dtype=complex)\n            ]\n        },\n        {\n            \"u\": 0.03,\n            \"S_matrices\": [\n                np.array([[0.99, 0], [0, 0.99]], dtype=complex),\n                np.array([[1.02, 0], [0, 0.95]], dtype=complex),\n                np.array([[0.98, 0], [0, 0.98]], dtype=complex)\n            ]\n        },\n        {\n            \"u\": 0.10,\n            \"S_matrices\": [\n                np.array([[1.30, 0], [0, 0.80]], dtype=complex),\n                np.array([[1.10, 0], [0, 1.05]], dtype=complex),\n                np.array([[2.00, 0], [0, 0.10]], dtype=complex)\n            ]\n        },\n        {\n            \"u\": 1.00,\n            \"S_matrices\": [\n                np.array([[0.30, 0], [0, 0.20]], dtype=complex),\n                np.array([[0.10, 0], [0, 0.40]], dtype=complex),\n                np.array([[0.50, 0], [0, 0.50]], dtype=complex)\n            ]\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        u_k = case[\"u\"]\n        s_matrices = case[\"S_matrices\"]\n        \n        # Threshold for the operator norm based on robust passivity\n        radius = 1.0 - u_k\n        \n        total_delta_norm_sq = 0.0\n        \n        for S_k in s_matrices:\n            # Compute singular values of S(omega_k).\n            # We only need the singular values, not the full SVD matrices U and Vh.\n            # `compute_uv=False` is more efficient.\n            singular_values = np.linalg.svd(S_k, compute_uv=False)\n            \n            # Identify singular values that violate the passivity constraint.\n            violating_svs = singular_values[singular_values  radius]\n            \n            # Calculate the squared difference for each violating singular value.\n            # This is (\\sigma_i - R)^2 for each \\sigma_i  R.\n            squared_diffs = (violating_svs - radius)**2\n            \n            # The squared Frobenius norm of Delta(omega_k) is the sum of these squared differences.\n            delta_k_norm_sq = np.sum(squared_diffs)\n            \n            # Accumulate the squared norms over all frequency samples.\n            total_delta_norm_sq += delta_k_norm_sq\n            \n        # The aggregate Frobenius norm is the square root of the total sum.\n        agg_delta_norm = np.sqrt(total_delta_norm_sq)\n        results.append(agg_delta_norm)\n\n    # Final print statement in the exact required format.\n    # Each value must be rounded to six decimal places.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "3297516"}]}