{"hands_on_practices": [{"introduction": "A constitutive model, whether derived from first principles or learned from data, is not arbitrary; it must adhere to the fundamental laws of physics. This practice focuses on the second law of thermodynamics, expressed through the Clausius-Duhem inequality, which mandates non-negative dissipation in any isothermal process. By implementing a computational check for this condition ([@problem_id:3557155]), you will gain hands-on experience in assessing the thermodynamic admissibility of different candidate energy functions, a critical step in validating any new material model.", "problem": "You are given discrete, time-ordered measurements of small-strain tensors and Cauchy stress tensors, denoted by the set of pairs $\\{(\\boldsymbol{\\varepsilon}_k,\\boldsymbol{\\sigma}_k)\\}_{k=0}^N$, where each $\\boldsymbol{\\varepsilon}_k$ and $\\boldsymbol{\\sigma}_k$ is a symmetric $3\\times 3$ tensor. Under the small-strain assumption and isothermal conditions, the Clausius-Duhem inequality (CDI) for mechanical dissipation at the continuum level states that the rate of dissipation per unit volume satisfies $\\boldsymbol{\\sigma}:\\dot{\\boldsymbol{\\varepsilon}} - \\dot{\\psi} \\ge 0$, where $\\psi$ is the Helmholtz free energy density. In a discrete-time setting with backward differences, this yields a segment-wise discrete dissipation\n$$\n\\mathcal{D}_k = \\boldsymbol{\\sigma}_k : \\left( \\boldsymbol{\\varepsilon}_k - \\boldsymbol{\\varepsilon}_{k-1} \\right) - \\left[ \\psi(\\boldsymbol{\\varepsilon}_k) - \\psi(\\boldsymbol{\\varepsilon}_{k-1}) \\right],\n$$\nand a cumulative dissipation over the history\n$$\n\\mathcal{D}_{\\mathrm{tot}} = \\sum_{k=1}^N \\mathcal{D}_k.\n$$\nThe double contraction $:$ of second-order tensors is defined by $\\mathbf{A}:\\mathbf{B} = \\sum_{i=1}^3\\sum_{j=1}^3 A_{ij}B_{ij}$, and the Frobenius norm satisfies $\\|\\mathbf{A}\\|_F^2 = \\mathbf{A}:\\mathbf{A}$.\n\nYour task is to implement a program that, for a given candidate energy density $\\psi(\\boldsymbol{\\varepsilon})$, computes the segment-wise discrete dissipation $\\mathcal{D}_k$ and the cumulative dissipation $\\mathcal{D}_{\\mathrm{tot}}$ for several test histories, and verifies the non-negativity condition $\\mathcal{D}_k \\ge 0$ for all segments $k=1,\\dots,N$. The discrete dissipation is an energy per unit volume and must be expressed in pascals (Pa). You must check the non-negativity using a numerical tolerance of $10^{-12}\\,\\mathrm{Pa}$, that is, treat a segment as non-negative if $\\mathcal{D}_k \\ge -10^{-12}\\,\\mathrm{Pa}$.\n\nImplement the following candidate energy densities:\n- Isotropic linear elastic energy with Lamé parameters $\\lambda>0$ and $\\mu>0$,\n$$\n\\psi_{\\mathrm{lin}}(\\boldsymbol{\\varepsilon};\\lambda,\\mu) = \\tfrac{1}{2}\\lambda \\left(\\mathrm{tr}\\,\\boldsymbol{\\varepsilon}\\right)^2 + \\mu\\, \\boldsymbol{\\varepsilon}:\\boldsymbol{\\varepsilon}.\n$$\n- Quartic convex energy with coefficients $\\alpha \\ge 0$ and $\\beta > 0$,\n$$\n\\psi_{\\mathrm{quartic}}(\\boldsymbol{\\varepsilon};\\alpha,\\beta) = \\alpha\\, \\|\\boldsymbol{\\varepsilon}\\|_F^2 + \\beta\\, \\|\\boldsymbol{\\varepsilon}\\|_F^4.\n$$\n- Concave quadratic energy (thermodynamically inadmissible) with coefficient $\\alpha>0$,\n$$\n\\psi_{\\mathrm{concave}}(\\boldsymbol{\\varepsilon};\\alpha) = -\\alpha\\, \\|\\boldsymbol{\\varepsilon}\\|_F^2.\n$$\nFor test cases in which the measured stress is consistent with the chosen $\\psi$, use $\\boldsymbol{\\sigma}_k = \\partial \\psi/\\partial \\boldsymbol{\\varepsilon}\\,\\big|_{\\boldsymbol{\\varepsilon}_k}$, with the following gradients:\n- For $\\psi_{\\mathrm{lin}}$: $\\boldsymbol{\\sigma} = \\lambda\\,\\mathrm{tr}(\\boldsymbol{\\varepsilon})\\,\\mathbf{I} + 2\\mu\\,\\boldsymbol{\\varepsilon}$, where $\\mathbf{I}$ is the identity tensor.\n- For $\\psi_{\\mathrm{quartic}}$: $\\boldsymbol{\\sigma} = 2\\alpha\\,\\boldsymbol{\\varepsilon} + 4\\beta\\,\\|\\boldsymbol{\\varepsilon}\\|_F^2\\,\\boldsymbol{\\varepsilon}$.\n- For $\\psi_{\\mathrm{concave}}$: $\\boldsymbol{\\sigma} = -2\\alpha\\,\\boldsymbol{\\varepsilon}$.\n\nIn addition, include one test case with measured stress taken from an idealized uniaxial elastic-perfectly plastic response with yield stress $\\sigma_y>0$. In that case, restrict to a uniaxial strain path with $\\varepsilon_{11}\\neq 0$ and all other strain components equal to zero, and define the measured stress by\n$$\n\\sigma_{11,k} = \\mathrm{sign}(\\varepsilon_{11,k}) \\,\\min\\!\\left( E_{\\mathrm{eff}}\\, \\varepsilon_{11,k},\\, \\sigma_y \\right), \\quad \\sigma_{ij,k}=0 \\;\\text{for}\\; (i,j)\\neq(1,1),\n$$\nwhere $E_{\\mathrm{eff}} = \\lambda + 2\\mu$ is the effective uniaxial modulus associated with the isotropic linear elastic $\\psi_{\\mathrm{lin}}$ used in that test, and $\\mathrm{sign}(\\cdot)$ denotes the sign function.\n\nTest Suite. For scientific coverage, use the following four histories and parameters:\n\n1. Convex quadratic energy with consistent stress (happy path). Use $\\psi_{\\mathrm{lin}}$ with $\\lambda = 6.0\\times 10^{10}\\,\\mathrm{Pa}$ and $\\mu = 4.0\\times 10^{10}\\,\\mathrm{Pa}$. Let $N=4$ and\n$$\n\\boldsymbol{\\varepsilon}_0 = \\begin{bmatrix} 0 & 0 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0 \\end{bmatrix},\\;\n\\boldsymbol{\\varepsilon}_1 = \\begin{bmatrix} 1.0\\times 10^{-3} & 1.5\\times 10^{-4} & 0 \\\\ 1.5\\times 10^{-4} & -2.0\\times 10^{-4} & 5.0\\times 10^{-5} \\\\ 0 & 5.0\\times 10^{-5} & 3.0\\times 10^{-4} \\end{bmatrix},\n$$\n$$\n\\boldsymbol{\\varepsilon}_2 = \\begin{bmatrix} 2.0\\times 10^{-3} & 1.0\\times 10^{-4} & -1.0\\times 10^{-4} \\\\ 1.0\\times 10^{-4} & 4.0\\times 10^{-4} & 2.0\\times 10^{-5} \\\\ -1.0\\times 10^{-4} & 2.0\\times 10^{-5} & 1.0\\times 10^{-3} \\end{bmatrix},\n\\quad\n\\boldsymbol{\\varepsilon}_3 = \\begin{bmatrix} 1.5\\times 10^{-3} & 0 & 0 \\\\ 0 & 1.0\\times 10^{-3} & 0 \\\\ 0 & 0 & 5.0\\times 10^{-4} \\end{bmatrix},\n$$\n$$\n\\boldsymbol{\\varepsilon}_4 = \\begin{bmatrix} 1.5\\times 10^{-3} & 2.0\\times 10^{-5} & -1.0\\times 10^{-5} \\\\ 2.0\\times 10^{-5} & 1.2\\times 10^{-3} & 0 \\\\ -1.0\\times 10^{-5} & 0 & 4.0\\times 10^{-4} \\end{bmatrix}.\n$$\nUse $\\boldsymbol{\\sigma}_k = \\partial \\psi_{\\mathrm{lin}}/\\partial \\boldsymbol{\\varepsilon}\\,\\big|_{\\boldsymbol{\\varepsilon}_k}$.\n\n2. Concave quadratic energy with consistent stress (edge case showing violation). Use $\\psi_{\\mathrm{concave}}$ with $\\alpha = 1.0\\times 10^{9}\\,\\mathrm{Pa}$. Let $N=3$ and\n$$\n\\boldsymbol{\\varepsilon}_0 = \\begin{bmatrix} 0 & 0 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0 \\end{bmatrix},\\;\n\\boldsymbol{\\varepsilon}_1 = \\begin{bmatrix} 3.0\\times 10^{-3} & 0 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0 \\end{bmatrix},\n$$\n$$\n\\boldsymbol{\\varepsilon}_2 = \\begin{bmatrix} 6.0\\times 10^{-3} & 0 & 0 \\\\ 0 & -2.0\\times 10^{-3} & 0 \\\\ 0 & 0 & 1.0\\times 10^{-3} \\end{bmatrix},\\quad\n\\boldsymbol{\\varepsilon}_3 = \\begin{bmatrix} 2.0\\times 10^{-3} & 0 & 0 \\\\ 0 & 2.0\\times 10^{-3} & 0 \\\\ 0 & 0 & -1.0\\times 10^{-3} \\end{bmatrix}.\n$$\nUse $\\boldsymbol{\\sigma}_k = \\partial \\psi_{\\mathrm{concave}}/\\partial \\boldsymbol{\\varepsilon}\\,\\big|_{\\boldsymbol{\\varepsilon}_k}$.\n\n3. Quartic convex energy with a repeated state (boundary case with zero increment). Use $\\psi_{\\mathrm{quartic}}$ with $\\alpha = 2.5\\times 10^{8}\\,\\mathrm{Pa}$ and $\\beta = 5.0\\times 10^{11}\\,\\mathrm{Pa}$. Let $N=4$ and\n$$\n\\boldsymbol{\\varepsilon}_0 = \\begin{bmatrix} 0 & 0 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0 \\end{bmatrix},\\;\n\\boldsymbol{\\varepsilon}_1 = \\begin{bmatrix} -1.0\\times 10^{-3} & 2.0\\times 10^{-4} & 0 \\\\ 2.0\\times 10^{-4} & -1.0\\times 10^{-3} & 0 \\\\ 0 & 0 & -1.0\\times 10^{-3} \\end{bmatrix},\n$$\n$$\n\\boldsymbol{\\varepsilon}_2 = \\boldsymbol{\\varepsilon}_1,\\quad\n\\boldsymbol{\\varepsilon}_3 = \\begin{bmatrix} -2.0\\times 10^{-3} & 3.0\\times 10^{-4} & 0 \\\\ 3.0\\times 10^{-4} & -5.0\\times 10^{-4} & 1.0\\times 10^{-4} \\\\ 0 & 1.0\\times 10^{-4} & -2.0\\times 10^{-4} \\end{bmatrix},\n$$\n$$\n\\boldsymbol{\\varepsilon}_4 = \\begin{bmatrix} -2.5\\times 10^{-3} & 0 & 0 \\\\ 0 & -1.0\\times 10^{-3} & 0 \\\\ 0 & 0 & 0 \\end{bmatrix}.\n$$\nUse $\\boldsymbol{\\sigma}_k = \\partial \\psi_{\\mathrm{quartic}}/\\partial \\boldsymbol{\\varepsilon}\\,\\big|_{\\boldsymbol{\\varepsilon}_k}$.\n\n4. Elastic energy used with measured elastic-perfectly plastic stress (edge case showing potential violation). Use $\\psi_{\\mathrm{lin}}$ with $\\lambda = 6.0\\times 10^{10}\\,\\mathrm{Pa}$ and $\\mu = 4.0\\times 10^{10}\\,\\mathrm{Pa}$, and yield stress $\\sigma_y = 1.0\\times 10^{8}\\,\\mathrm{Pa}$. Let $N=3$ and consider a uniaxial strain path\n$$\n\\boldsymbol{\\varepsilon}_0 = \\mathbf{0},\\quad\n\\boldsymbol{\\varepsilon}_1 = \\begin{bmatrix} 5.0\\times 10^{-4} & 0 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0 \\end{bmatrix},\\quad\n\\boldsymbol{\\varepsilon}_2 = \\begin{bmatrix} 1.0\\times 10^{-3} & 0 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0 \\end{bmatrix},\\quad\n\\boldsymbol{\\varepsilon}_3 = \\begin{bmatrix} 2.0\\times 10^{-3} & 0 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0 \\end{bmatrix},\n$$\nand measured stress given by the elastic-perfectly plastic rule above with $E_{\\mathrm{eff}}=\\lambda+2\\mu$.\n\nProgram Requirements. Your program must:\n- Implement the above $\\psi$ functions and, where instructed, the corresponding stress functions.\n- For each test case, compute all segment-wise dissipation values $\\mathcal{D}_k$ and the cumulative $\\mathcal{D}_{\\mathrm{tot}}$ in pascals.\n- Verify the non-negativity condition for each segment using the tolerance $10^{-12}\\,\\mathrm{Pa}$ and report whether all segments in the test case are non-negative.\n- Produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $[\\mathcal{D}_{\\mathrm{tot}}^{(1)},\\mathrm{all\\_nonneg}^{(1)},\\mathcal{D}_{\\mathrm{tot}}^{(2)},\\mathrm{all\\_nonneg}^{(2)},\\mathcal{D}_{\\mathrm{tot}}^{(3)},\\mathrm{all\\_nonneg}^{(3)},\\mathcal{D}_{\\mathrm{tot}}^{(4)},\\mathrm{all\\_nonneg}^{(4)}]$, where $\\mathcal{D}_{\\mathrm{tot}}^{(i)}$ is a float in pascals and $\\mathrm{all\\_nonneg}^{(i)}$ is a boolean indicating whether all segments in test case $i$ satisfy $\\mathcal{D}_k \\ge -10^{-12}\\,\\mathrm{Pa}$.", "solution": "The problem statement is evaluated as valid. It is scientifically grounded in the principles of continuum mechanics, specifically the thermodynamic constraint on material behavior imposed by the Clausius-Duhem inequality. The problem is well-posed, providing all necessary data, parameters, and functional forms for a direct computational solution. The definitions and test cases are clear, objective, and self-contained.\n\nThe core of the problem is to verify the discrete form of the Clausius-Duhem inequality (CDI) for several material models and loading histories. The CDI, in the context of isothermal mechanical processes, states that the rate of dissipation must be non-negative. Its discrete counterpart for a time segment from step $k-1$ to $k$ is given by\n$$\n\\mathcal{D}_k = \\boldsymbol{\\sigma}_k : (\\boldsymbol{\\varepsilon}_k - \\boldsymbol{\\varepsilon}_{k-1}) - \\left[ \\psi(\\boldsymbol{\\varepsilon}_k) - \\psi(\\boldsymbol{\\varepsilon}_{k-1}) \\right] \\ge 0\n$$\nwhere $\\boldsymbol{\\varepsilon}_k$ is the small-strain tensor, $\\boldsymbol{\\sigma}_k$ is the Cauchy stress tensor, and $\\psi$ is the Helmholtz free energy density. The aforementioned condition must hold for every segment $k=1, \\dots, N$. The total dissipation over the history is the sum $\\mathcal{D}_{\\mathrm{tot}} = \\sum_{k=1}^N \\mathcal{D}_k$.\n\nThe computational procedure involves implementing the given candidate functions for the Helmholtz free energy density $\\psi$ and the corresponding stress tensors $\\boldsymbol{\\sigma}$. For each test case, the program will iterate through the provided time-ordered strain history $\\{\\boldsymbol{\\varepsilon}_k\\}$. In each segment, it calculates the incremental work $\\boldsymbol{\\sigma}_k : (\\boldsymbol{\\varepsilon}_k - \\boldsymbol{\\varepsilon}_{k-1})$ and the change in stored energy $\\psi(\\boldsymbol{\\varepsilon}_k) - \\psi(\\boldsymbol{\\varepsilon}_{k-1})$, and subsequently the dissipation $\\mathcal{D}_k$.\n\nThe implementation will heavily rely on numerical tensor algebra, for which the `numpy` library is well-suited. Tensors $\\boldsymbol{\\varepsilon}$ and $\\boldsymbol{\\sigma}$ are represented as $3\\times3$ `numpy` arrays. The essential tensor operations required are:\n- The trace, $\\mathrm{tr}\\,\\boldsymbol{\\varepsilon} = \\sum_{i=1}^3 \\varepsilon_{ii}$.\n- The double contraction, $\\mathbf{A}:\\mathbf{B} = \\sum_{i,j} A_{ij}B_{ij}$, which is equivalent to the element-wise product followed by a sum.\n- The squared Frobenius norm, $\\|\\mathbf{A}\\|_F^2 = \\mathbf{A}:\\mathbf{A}$.\n\nLet us analyze the theoretical expectation for each test case:\n\n1.  **Isotropic Linear Elastic Energy ($\\psi_{\\mathrm{lin}}$)**: The energy function $\\psi_{\\mathrm{lin}}(\\boldsymbol{\\varepsilon}) = \\frac{1}{2}\\lambda (\\mathrm{tr}\\,\\boldsymbol{\\varepsilon})^2 + \\mu\\, \\boldsymbol{\\varepsilon}:\\boldsymbol{\\varepsilon}$ is a quadratic form. With Lamé parameters $\\lambda > 0$ and $\\mu > 0$, this function is strictly convex. The stress is given by $\\boldsymbol{\\sigma} = \\partial\\psi_{\\mathrm{lin}}/\\partial\\boldsymbol{\\varepsilon}$. In this so-called *hyperelastic* case, the discrete dissipation $\\mathcal{D}_k$ is equivalent to the Bregman divergence associated with the convex function $\\psi$.\n    $$\n    \\mathcal{D}_k = \\frac{\\partial\\psi}{\\partial\\boldsymbol{\\varepsilon}}\\bigg|_{\\boldsymbol{\\varepsilon}_k} : (\\boldsymbol{\\varepsilon}_k - \\boldsymbol{\\varepsilon}_{k-1}) - (\\psi(\\boldsymbol{\\varepsilon}_k) - \\psi(\\boldsymbol{\\varepsilon}_{k-1}))\n    $$\n    Due to the convexity of $\\psi$, this quantity is guaranteed to be non-negative. In fact, for a quadratic function like $\\psi_{\\mathrm{lin}}$, this expression simplifies to $\\mathcal{D}_k = \\psi_{\\mathrm{lin}}(\\boldsymbol{\\varepsilon}_k - \\boldsymbol{\\varepsilon}_{k-1})$. Since $\\psi_{\\mathrm{lin}}$ is positive definite for non-zero strains, we expect $\\mathcal{D}_k \\ge 0$, with equality only if $\\boldsymbol{\\varepsilon}_k = \\boldsymbol{\\varepsilon}_{k-1}$. All segments are thus expected to satisfy the CDI.\n\n2.  **Concave Quadratic Energy ($\\psi_{\\mathrm{concave}}$)**: The energy $\\psi_{\\mathrm{concave}}(\\boldsymbol{\\varepsilon}) = -\\alpha\\, \\|\\boldsymbol{\\varepsilon}\\|_F^2$ with $\\alpha>0$ is strictly concave. Such an energy function is thermodynamically inadmissible for stable materials. With $\\boldsymbol{\\sigma} = \\partial\\psi_{\\mathrm{concave}}/\\partial\\boldsymbol{\\varepsilon}$, a direct calculation shows:\n    $$\n    \\mathcal{D}_k = -\\alpha \\|\\boldsymbol{\\varepsilon}_k - \\boldsymbol{\\varepsilon}_{k-1}\\|_F^2\n    $$\n    Since $\\alpha>0$ and $\\|\\cdot\\|_F^2$ is non-negative, $\\mathcal{D}_k$ will be non-positive. For any segment where the strain changes ($\\boldsymbol{\\varepsilon}_k \\neq \\boldsymbol{\\varepsilon}_{k-1}$), we expect a strict violation of the CDI, i.e., $\\mathcal{D}_k < 0$.\n\n3.  **Quartic Convex Energy ($\\psi_{\\mathrm{quartic}}$)**: The function $\\psi_{\\mathrm{quartic}}(\\boldsymbol{\\varepsilon}) = \\alpha\\, \\|\\boldsymbol{\\varepsilon}\\|_F^2 + \\beta\\, \\|\\boldsymbol{\\varepsilon}\\|_F^4$ with $\\alpha \\ge 0, \\beta > 0$ is strictly convex. As in the first case, the material is hyperelastic, and the convexity of $\\psi$ ensures that the dissipation $\\mathcal{D}_k$ is non-negative. One segment in this test case is defined by $\\boldsymbol{\\varepsilon}_2 = \\boldsymbol{\\varepsilon}_1$, which implies $\\boldsymbol{\\varepsilon}_2 - \\boldsymbol{\\varepsilon}_1 = \\mathbf{0}$. For this segment, the dissipation $\\mathcal{D}_2$ must be exactly zero, which our implementation must handle correctly. All segments are expected to satisfy the CDI.\n\n4.  **Elastic Energy with Plastic Stress**: Here, the chosen energy function $\\psi_{\\mathrm{lin}}$ represents only the elastic, recoverable part of the energy storage. The stress, however, is taken from an elastic-perfectly plastic model, which includes non-recoverable (dissipative) deformation. The stress is not derivable from the chosen $\\psi$, i.e., $\\boldsymbol{\\sigma}_k \\neq \\partial\\psi_{\\mathrm{lin}}/\\partial\\boldsymbol{\\varepsilon}\\big|_{\\boldsymbol{\\varepsilon}_k}$. Consequently, the calculated quantity $\\mathcal{D}_k$ does not represent the true physical dissipation. The framework requires that $\\psi$ be the total Helmholtz free energy. By using an incomplete $\\psi$, violations of the computed non-negativity are possible and, in this case, expected. Specifically, when the material yields, the stress becomes capped at $\\sigma_y$, while the stored elastic energy (computed via $\\psi_{\\mathrm{lin}}$ and total strain $\\boldsymbol{\\varepsilon}_k$) continues to increase quadratically. This mismatch can lead to a calculated $\\mathcal{D}_k < 0$.\n\nThe program will be structured to handle each of these cases. It will define functions for each $\\psi$ and $\\boldsymbol{\\sigma}$. A main loop will iterate through the four test suites, calculating the stress history, segment-wise dissipations $\\mathcal{D}_k$, cumulative dissipation $\\mathcal{D}_{\\mathrm{tot}}$, and verifying the non-negativity condition against the given tolerance of $10^{-12}\\,\\mathrm{Pa}$. The final results will be aggregated and formatted as specified.", "answer": "```python\nimport numpy as np\n\n# A meticulous and exacting professor in the STEM fields.\n\ndef solve():\n    \"\"\"\n    Computes and verifies discrete dissipation for several constitutive models.\n    \"\"\"\n    TOL = 1e-12\n\n    # Utility functions for tensor algebra\n    def double_dot(A, B):\n        \"\"\"Computes the double dot product of two 3x3 tensors.\"\"\"\n        return np.sum(A * B)\n\n    def frobenius_norm_sq(A):\n        \"\"\"Computes the squared Frobenius norm of a 3x3 tensor.\"\"\"\n        return double_dot(A, A)\n\n    # Candidate energy and stress functions\n    def psi_lin(eps, lam, mu):\n        \"\"\"Isotropic linear elastic energy density.\"\"\"\n        return 0.5 * lam * np.trace(eps)**2 + mu * double_dot(eps, eps)\n\n    def sigma_lin(eps, lam, mu):\n        \"\"\"Stress from isotropic linear elastic energy.\"\"\"\n        return lam * np.trace(eps) * np.eye(3) + 2 * mu * eps\n\n    def psi_quartic(eps, alpha, beta):\n        \"\"\"Quartic convex energy density.\"\"\"\n        norm_sq = frobenius_norm_sq(eps)\n        return alpha * norm_sq + beta * norm_sq**2\n\n    def sigma_quartic(eps, alpha, beta):\n        \"\"\"Stress from quartic convex energy.\"\"\"\n        norm_sq = frobenius_norm_sq(eps)\n        return 2 * alpha * eps + 4 * beta * norm_sq * eps\n\n    def psi_concave(eps, alpha):\n        \"\"\"Concave quadratic energy density.\"\"\"\n        return -alpha * frobenius_norm_sq(eps)\n\n    def sigma_concave(eps, alpha):\n        \"\"\"Stress from concave quadratic energy.\"\"\"\n        return -2 * alpha * eps\n\n    # --- Test Suite Setup ---\n\n    # Case 1: Convex quadratic energy with consistent stress\n    case1_params = {'lam': 6.0e10, 'mu': 4.0e10}\n    case1_eps_hist = [\n        np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]),\n        np.array([[1.0e-3, 1.5e-4, 0.0], [1.5e-4, -2.0e-4, 5.0e-5], [0.0, 5.0e-5, 3.0e-4]]),\n        np.array([[2.0e-3, 1.0e-4, -1.0e-4], [1.0e-4, 4.0e-4, 2.0e-5], [-1.0e-4, 2.0e-5, 1.0e-3]]),\n        np.array([[1.5e-3, 0.0, 0.0], [0.0, 1.0e-3, 0.0], [0.0, 0.0, 5.0e-4]]),\n        np.array([[1.5e-3, 2.0e-5, -1.0e-5], [2.0e-5, 1.2e-3, 0.0], [-1.0e-5, 0.0, 4.0e-4]])\n    ]\n\n    # Case 2: Concave quadratic energy with consistent stress\n    case2_params = {'alpha': 1.0e9}\n    case2_eps_hist = [\n        np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]),\n        np.array([[3.0e-3, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]),\n        np.array([[6.0e-3, 0.0, 0.0], [0.0, -2.0e-3, 0.0], [0.0, 0.0, 1.0e-3]]),\n        np.array([[2.0e-3, 0.0, 0.0], [0.0, 2.0e-3, 0.0], [0.0, 0.0, -1.0e-3]])\n    ]\n\n    # Case 3: Quartic convex energy with a repeated state\n    case3_params = {'alpha': 2.5e8, 'beta': 5.0e11}\n    _eps1_case3 = np.array([[-1.0e-3, 2.0e-4, 0.0], [2.0e-4, -1.0e-3, 0.0], [0.0, 0.0, -1.0e-3]])\n    case3_eps_hist = [\n        np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]),\n        _eps1_case3,\n        _eps1_case3.copy(),\n        np.array([[-2.0e-3, 3.0e-4, 0.0], [3.0e-4, -5.0e-4, 1.0e-4], [0.0, 1.0e-4, -2.0e-4]]),\n        np.array([[-2.5e-3, 0.0, 0.0], [0.0, -1.0e-3, 0.0], [0.0, 0.0, 0.0]])\n    ]\n\n    # Case 4: Elastic energy with measured elastic-perfectly plastic stress\n    case4_params = {'lam': 6.0e10, 'mu': 4.0e10, 'sigma_y': 1.0e8}\n    case4_eps_hist = [\n        np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]),\n        np.array([[5.0e-4, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]),\n        np.array([[1.0e-3, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]),\n        np.array([[2.0e-3, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]])\n    ]\n    \n    test_suite = [\n        {'psi_func': psi_lin, 'sigma_type': 'consistent', 'sigma_func': sigma_lin, 'params': case1_params, 'eps_hist': case1_eps_hist},\n        {'psi_func': psi_concave, 'sigma_type': 'consistent', 'sigma_func': sigma_concave, 'params': case2_params, 'eps_hist': case2_eps_hist},\n        {'psi_func': psi_quartic, 'sigma_type': 'consistent', 'sigma_func': sigma_quartic, 'params': case3_params, 'eps_hist': case3_eps_hist},\n        {'psi_func': psi_lin, 'sigma_type': 'plastic', 'params': case4_params, 'eps_hist': case4_eps_hist}\n    ]\n\n    results = []\n\n    for case in test_suite:\n        eps_hist = case['eps_hist']\n        params = case['params']\n        psi_func = case['psi_func']\n        N = len(eps_hist) - 1\n        \n        # Generate stress history\n        sigma_hist = [np.zeros((3, 3))] * (N + 1)\n        if case['sigma_type'] == 'consistent':\n            sigma_func = case['sigma_func']\n            sigma_hist = [sigma_func(eps, **params) for eps in eps_hist]\n        elif case['sigma_type'] == 'plastic':\n            lam, mu, sigma_y = params['lam'], params['mu'], params['sigma_y']\n            E_eff = lam + 2 * mu\n            temp_sigma_hist = []\n            for k in range(N + 1):\n                eps_k = eps_hist[k]\n                stress_k = np.zeros((3, 3))\n                if k > 0: # sigma_0 is not used\n                    eps11_k = eps_k[0, 0]\n                    sigma11_elastic = E_eff * eps11_k\n                    sigma11_k = np.sign(eps11_k) * min(abs(sigma11_elastic), sigma_y)\n                    stress_k[0, 0] = sigma11_k\n                temp_sigma_hist.append(stress_k)\n            sigma_hist = temp_sigma_hist\n\n        # Calculate dissipation\n        d_total = 0.0\n        all_nonneg = True\n        \n        for k in range(1, N + 1):\n            eps_k = eps_hist[k]\n            eps_km1 = eps_hist[k-1]\n            sigma_k = sigma_hist[k]\n\n            work_inc = double_dot(sigma_k, eps_k - eps_km1)\n            psi_k = psi_func(eps_k, **{p: v for p, v in params.items() if p not in ['sigma_y']})\n            psi_km1 = psi_func(eps_km1, **{p: v for p, v in params.items() if p not in ['sigma_y']})\n            \n            d_k = work_inc - (psi_k - psi_km1)\n            d_total += d_k\n            \n            if d_k < -TOL:\n                all_nonneg = False\n        \n        results.extend([d_total, str(all_nonneg).lower()])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3557155"}, {"introduction": "The principle of material frame indifference, or objectivity, dictates that a material's response must be independent of the observer's rigid body motion. Enforcing this constraint is paramount for data-driven models that operate on tensorial quantities like the deformation gradient. This exercise ([@problem_id:3557115]) guides you through a state-of-the-art technique to ensure objectivity by construction: learning the constitutive relationship in the invariant space of principal stretches and reconstructing the full stress tensor via spectral decomposition. You will also implement adversarial rotations to numerically verify the model's invariance and quantify any potential leakage due to numerical precision.", "problem": "You are asked to implement and validate a data-driven constitutive model that enforces material frame indifference (objectivity) by training in principal stretch variables and reconstructing stress via spectral mappings. The goal is to (i) learn a mapping from principal stretches to principal stresses using a shared functional form that depends only on objective quantities, (ii) reconstruct the full Cauchy stress tensor for arbitrary deformations using spectral decomposition, and (iii) design and evaluate adversarial rotations to quantify any invariance leakage of the learned model.\n\nStart from the following fundamental base:\n- Material frame indifference requires that for all proper orthogonal rotations $Q \\in \\mathbb{R}^{3 \\times 3}$ with $\\det(Q) = 1$, the Cauchy stress mapping $\\sigma$ satisfies $\\sigma(QF) = Q \\, \\sigma(F) \\, Q^{\\mathsf{T}}$ for every deformation gradient $F \\in \\mathbb{R}^{3 \\times 3}$ with $\\det(F) > 0$.\n- The polar decomposition states $F = R U$, where $R \\in \\mathbb{R}^{3 \\times 3}$ is a proper rotation and $U \\in \\mathbb{R}^{3 \\times 3}$ is the right stretch tensor, symmetric positive definite.\n- The left Cauchy-Green tensor is $B = F F^{\\mathsf{T}}$, with eigenvalues $\\beta_i$ and orthonormal eigenvectors that define principal directions. The principal stretches are $\\lambda_i = \\sqrt{\\beta_i}$, and the Jacobian is $J = \\lambda_1 \\lambda_2 \\lambda_3$.\n- Define the Kirchhoff stress $\\tau = J \\, \\sigma$. For isotropic elastic materials, $\\tau$ and $B$ commute and share eigenvectors. The principal Kirchhoff stresses $\\tau_i$ may be expressed in terms of the principal stretches $\\lambda_i$ and $J$ through an isotropic constitutive relation.\n\nUse the following well-tested constitutive law (in consistent nondimensional units) to generate supervised training signals and ground-truth comparisons:\n- For a compressible Neo-Hookean material with shear modulus $\\mu$ and bulk modulus $\\kappa$, the Cauchy stress is\n$$\n\\sigma(F) = \\frac{\\mu}{J}\\left(B - I\\right) + \\kappa \\left(J - 1\\right) I,\n$$\nwhere $I$ is the identity tensor. Consequently, the principal Kirchhoff stresses satisfy\n$$\n\\tau_i = \\mu\\left(\\lambda_i^2 - 1\\right) + \\kappa \\, J \\left(J - 1\\right).\n$$\n\nYour tasks:\n1. Design a small data-driven constitutive model that maps principal stretches to principal Kirchhoff stresses while enforcing objectivity by construction:\n   - Use inputs $x_i = \\ln(\\lambda_i)$ and the volumetric coupling variable $s = \\sum_{j=1}^3 x_j = \\ln(J)$.\n   - Employ a shared linear model for each principal component, with identical parameters across $i \\in \\{1,2,3\\}$, of the form\n   $$\n   \\widehat{\\tau}_i = w_1 \\, \\exp(2 x_i) + w_2 \\cdot 1 + w_3 \\, \\exp(2 s) + w_4 \\, \\exp(s),\n   $$\n   which ensures permutation-equivariant treatment of principal directions and couples the deviatoric and volumetric responses through $s$. Fit the parameter vector $w \\in \\mathbb{R}^4$ by least squares using synthetic training data sampled from the given constitutive law.\n2. Reconstruct the full predicted Cauchy stress tensor for a given deformation $F$ as follows:\n   - Compute $B = F F^{\\mathsf{T}}$ and obtain its spectral decomposition to recover principal directions and stretches $\\lambda_i = \\sqrt{\\beta_i}$ with $J = \\lambda_1 \\lambda_2 \\lambda_3$.\n   - Evaluate the learned model $\\widehat{\\tau}_i$ on the principal stretches and assemble the predicted Kirchhoff stress tensor $\\widehat{\\tau} = \\sum_{i=1}^3 \\widehat{\\tau}_i \\, v_i \\otimes v_i$, where $v_i$ are the eigenvectors of $B$.\n   - Return the predicted Cauchy stress $\\widehat{\\sigma} = \\widehat{\\tau} / J$.\n3. Propose adversarial rotations to evaluate invariance leakage of the learned model:\n   - For a fixed stretch tensor $U = \\mathrm{diag}(\\lambda_1,\\lambda_2,\\lambda_3)$ and a chosen reference rotation $R_{\\text{ref}}$, form $F_1 = R_{\\text{ref}} U$.\n   - For multiple randomly sampled rotations $Q_k$ with angles in radians, define $F_{2,k} = Q_k F_1$ and compute the learned stresses $\\widehat{\\sigma}(F_1)$ and $\\widehat{\\sigma}(F_{2,k})$.\n   - Define the invariance leakage metric for each $k$ as\n   $$\n   \\mathcal{L}_k = \\frac{\\left\\| \\widehat{\\sigma}(F_{2,k}) - Q_k \\, \\widehat{\\sigma}(F_1) \\, Q_k^{\\mathsf{T}} \\right\\|_F}{\\left\\| \\widehat{\\sigma}(F_1) \\right\\|_F + \\epsilon},\n   $$\n   where $\\|\\cdot\\|_F$ denotes the Frobenius norm and $\\epsilon$ is a small positive number to avoid division by zero. Report the maximum leakage $\\max_k \\mathcal{L}_k$ over the adversarial set for each test case.\n\nTraining data protocol:\n- Sample $N_{\\text{train}} = 256$ independent triplets of principal stretches by drawing $x_i = \\ln(\\lambda_i)$ from a normal distribution with mean $0$ and standard deviation $0.4$, then set $\\lambda_i = \\exp(x_i)$, $J = \\prod_i \\lambda_i$. Use the above Neo-Hookean law with $\\mu = 2.0$ and $\\kappa = 10.0$ to compute the exact targets $\\tau_i$ and fit $w$ via least squares over all principal components pooled together.\n- Use a fixed random seed to make the sampling and training deterministic.\n\nAdversarial rotation generation:\n- Sample $K = 25$ random rotations $Q_k$ by choosing a random axis uniformly on the unit sphere and a random angle uniformly in $[0, \\pi)$ radians, then constructing $Q_k$ via the Rodrigues formula. Use deterministic seeding so results are reproducible.\n\nTest suite:\n- Use three test cases with prescribed principal stretches and a fixed reference rotation axis and angle. In all cases, the reference rotation axis is proportional to $(1,1,1)$, normalized, and the reference rotation angle is $\\alpha = 1.234$ radians.\n  1. Case A (moderate nearly isochoric): $\\lambda = (1.10, 0.95, 0.96)$.\n  2. Case B (large anisotropic): $\\lambda = (1.60, 0.70, 1.30)$.\n  3. Case C (near-degenerate directions): $\\lambda = (1.00, 1.00, 1.05)$.\n- For each case:\n  - Form $U = \\mathrm{diag}(\\lambda)$ and $F_1 = R_{\\text{ref}} U$.\n  - Compute the true Cauchy stress using the given constitutive law and the predicted Cauchy stress using the learned model. Report the relative Frobenius error\n  $$\n  e = \\frac{\\left\\|\\widehat{\\sigma}(F_1) - \\sigma(F_1)\\right\\|_F}{\\left\\|\\sigma(F_1)\\right\\|_F}.\n  $$\n  - Compute the maximum invariance leakage $\\max_k \\mathcal{L}_k$ over the $K$ adversarial rotations defined above.\n\nAngle unit specification:\n- All angles must be in radians.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets of length $6$, ordered as\n  $$\n  [e_A, \\max \\mathcal{L}_A, e_B, \\max \\mathcal{L}_B, e_C, \\max \\mathcal{L}_C],\n  $$\n  where $e_{\\cdot}$ is the relative Frobenius error for the base deformation $F_1$ and $\\max \\mathcal{L}_{\\cdot}$ is the maximum invariance leakage under the adversarial rotations for each case. The output entries are real numbers (floats) without units and must be expressed as decimals.", "solution": "The problem is valid. It is scientifically grounded in the principles of continuum mechanics, well-posed with a clear and deterministic procedure for obtaining a unique solution, and described with objective, formal language. The tasks are relevant to the field of data-driven computational mechanics and involve a non-trivial implementation of model training, prediction, and validation.\n\nThe solution proceeds in three main parts as specified: (1) training a data-driven constitutive model, (2) implementing a stress reconstruction algorithm based on spectral decomposition, and (3) evaluating the model's material frame indifference using adversarial rotations.\n\n### Part 1: Constitutive Model Training\n\nThe objective is to learn a mapping from principal stretches $\\lambda_i$ to principal Kirchhoff stresses $\\tau_i$. The ground-truth relationship is given by the compressible Neo-Hookean model with shear modulus $\\mu = 2.0$ and bulk modulus $\\kappa = 10.0$:\n$$\n\\tau_i = \\mu\\left(\\lambda_i^2 - 1\\right) + \\kappa \\, J \\left(J - 1\\right)\n$$\nwhere $J = \\lambda_1 \\lambda_2 \\lambda_3$ is the Jacobian.\n\nThe proposed data-driven model is a linear model for the principal Kirchhoff stress $\\widehat{\\tau}_i$:\n$$\n\\widehat{\\tau}_i = w_1 \\, \\exp(2 x_i) + w_2 \\cdot 1 + w_3 \\, \\exp(2 s) + w_4 \\, \\exp(s)\n$$\nwhere $x_i = \\ln(\\lambda_i)$ and $s = \\sum_j x_j = \\ln(J)$. Substituting these definitions, the model form becomes:\n$$\n\\widehat{\\tau}_i = w_1 \\lambda_i^2 + w_2 + w_3 J^2 + w_4 J\n$$\nThis form is an appropriate choice as it is a linear combination of terms that appear in the true law $\\tau_i = \\mu \\lambda_i^2 - \\mu + \\kappa J^2 - \\kappa J$. We expect the learned weights to approximate $w_1 \\approx \\mu$, $w_2 \\approx -\\mu$, $w_3 \\approx \\kappa$, and $w_4 \\approx -\\kappa$.\n\nTraining is performed using a synthetic dataset. $N_{\\text{train}} = 256$ samples of principal stretches are generated by first drawing logarithmic stretches $x_i$ from a normal distribution $\\mathcal{N}(0, 0.4^2)$. The principal stretches are then $\\lambda_i = \\exp(x_i)$. For each set of $(\\lambda_1, \\lambda_2, \\lambda_3)$, the target principal stresses $(\\tau_1, \\tau_2, \\tau_3)$ are computed using the Neo-Hookean formula.\n\nThe parameter vector $w = [w_1, w_2, w_3, w_4]^{\\mathsf{T}}$ is determined by solving a linear least-squares problem of the form $A w = b$. The data from all $3$ principal directions for all $N_{\\text{train}}$ samples are pooled, resulting in $3 \\times N_{\\text{train}} = 768$ data points. The design matrix $A$ is of size $(768, 4)$ and the target vector $b$ is of size $(768, 1)$. For each data point $k$ corresponding to a sample $j$ and principal direction $i$, the rows of $A$ and $b$ are structured as:\n$$\nA_k = [\\lambda_{j,i}^2, \\quad 1, \\quad J_j^2, \\quad J_j], \\quad b_k = \\tau_{j,i}\n$$\nThe system is solved for $w$ using `numpy.linalg.lstsq`. A fixed random seed ensures the reproducibility of the training data and thus the learned weights $w$.\n\n### Part 2: Stress Tensor Reconstruction\n\nThe learned model operates on principal stretches, which are scalar invariants. To predict the full Cauchy stress tensor $\\widehat{\\sigma}$ for an arbitrary deformation gradient $F$, we use a spectral reconstruction method. This procedure inherently enforces material frame indifference.\n\nGiven a deformation gradient $F$ with $\\det(F) > 0$:\n1.  Compute the left Cauchy-Green tensor $B = F F^{\\mathsf{T}}$. $B$ is symmetric and positive definite.\n2.  Perform a spectral decomposition of $B$ to find its eigenvalues $\\beta_i$ and corresponding orthonormal eigenvectors $v_i$. That is, $B = \\sum_{i=1}^3 \\beta_i v_i \\otimes v_i$.\n3.  The principal stretches are the square roots of the eigenvalues of $B$: $\\lambda_i = \\sqrt{\\beta_i}$. The eigenvectors $v_i$ define the principal directions of stretch in the spatial configuration. The eigenvalues are sorted to maintain a consistent ordering, e.g., $\\lambda_1 \\le \\lambda_2 \\le \\lambda_3$.\n4.  The Jacobian is computed as $J = \\lambda_1 \\lambda_2 \\lambda_3$.\n5.  The learned model $\\widehat{\\tau}_i(w, \\lambda_1, \\lambda_2, \\lambda_3)$ is used to predict the principal Kirchhoff stresses $\\widehat{\\tau}_i$.\n6.  The full Kirchhoff stress tensor $\\widehat{\\tau}$ is reconstructed in the basis of eigenvectors of $B$:\n    $$\n    \\widehat{\\tau} = \\sum_{i=1}^3 \\widehat{\\tau}_i \\, v_i \\otimes v_i\n    $$\n    This operation correctly aligns the principal stresses with the principal directions of stretch.\n7.  Finally, the predicted Cauchy stress tensor is obtained by scaling the Kirchhoff stress: $\\widehat{\\sigma} = \\widehat{\\tau} / J$.\n\n### Part 3: Adversarial Validation of Frame Indifference\n\nMaterial frame indifference requires that the constitutive law be independent of the observer's rigid body rotation. Mathematically, for any proper orthogonal tensor $Q$, the stress response must satisfy $\\sigma(QF) = Q \\sigma(F) Q^{\\mathsf{T}}$.\n\nThe spectral reconstruction method is designed to satisfy this property by construction. To verify this numerically and quantify any \"leakage\" due to floating-point imprecision, we employ an adversarial test.\n1.  A base deformation $F_1 = R_{\\text{ref}} U$ is created from a pure stretch $U = \\mathrm{diag}(\\lambda_1, \\lambda_2, \\lambda_3)$ and a reference rotation $R_{\\text{ref}}$.\n2.  A set of $K=25$ random \"adversarial\" rotations $Q_k$ are generated.\n3.  For each $Q_k$, a new deformation $F_{2,k} = Q_k F_1$ is formed. This represents the same physical deformation $F_1$ viewed from a rotated frame.\n4.  The model predicts the stress for both deformations: $\\widehat{\\sigma}(F_1)$ and $\\widehat{\\sigma}(F_{2,k})$.\n5.  If the model is perfectly objective, it must satisfy $\\widehat{\\sigma}(F_{2,k}) = Q_k \\widehat{\\sigma}(F_1) Q_k^{\\mathsf{T}}$.\n6.  The invariance leakage is quantified using the metric:\n    $$\n    \\mathcal{L}_k = \\frac{\\left\\| \\widehat{\\sigma}(F_{2,k}) - Q_k \\, \\widehat{\\sigma}(F_1) \\, Q_k^{\\mathsf{T}} \\right\\|_F}{\\left\\| \\widehat{\\sigma}(F_1) \\right\\|_F + \\epsilon}\n    $$\n    where $\\|\\cdot\\|_F$ is the Frobenius norm and $\\epsilon$ is a small regularization constant. For our model, any non-zero value of $\\mathcal{L}_k$ is attributable to numerical floating-point errors in the sequence of matrix operations (especially `eigh`). The test reports the maximum leakage $\\max_k \\mathcal{L}_k$ over the set of adversarial rotations.\n\nThe implementation uses fixed seeds for all random number generation to ensure full reproducibility of the training, adversarial rotation generation, and final results. For the test cases, the relative error between the model's prediction $\\widehat{\\sigma}(F_1)$ and the ground truth $\\sigma(F_1)$ is also computed to assess the accuracy of the learned linear model.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef rodrigues_rotation(axis, angle):\n    \"\"\"\n    Computes the rotation matrix for a given axis and angle using Rodrigues' formula.\n    \"\"\"\n    axis = np.asarray(axis, dtype=float)\n    axis /= np.linalg.norm(axis)\n    \n    K = np.array([[0, -axis[2], axis[1]],\n                  [axis[2], 0, -axis[0]],\n                  [-axis[1], axis[0], 0]])\n    \n    R = np.identity(3) + np.sin(angle) * K + (1 - np.cos(angle)) * (K @ K)\n    return R\n\ndef solve():\n    \"\"\"\n    Main function to perform model training, evaluation, and reporting.\n    \"\"\"\n    # --- Constants and Hyperparameters ---\n    MU = 2.0\n    KAPPA = 10.0\n    N_TRAIN = 256\n    K_ADV = 25\n    EPSILON = 1e-15\n    TRAIN_SEED = 42\n    ADV_SEED = 123\n\n    # --- 1. Training Phase ---\n    rng_train = np.random.default_rng(TRAIN_SEED)\n    # Generate logarithmic stretches x_i = ln(lambda_i)\n    x_train = rng_train.normal(loc=0.0, scale=0.4, size=(N_TRAIN, 3))\n    lambdas_train = np.exp(x_train)\n    J_train = np.prod(lambdas_train, axis=1)\n\n    # Compute ground-truth Kirchhoff stresses (targets)\n    # tau_i = mu*(lambda_i^2 - 1) + kappa*J*(J-1)\n    tau_train = MU * (lambdas_train**2 - 1) + KAPPA * J_train[:, np.newaxis] * (J_train[:, np.newaxis] - 1)\n    \n    # Assemble design matrix A and target vector b for least squares Aw=b\n    # Model: tau_hat_i = w1*lambda_i^2 + w2*1 + w3*J^2 + w4*J\n    # All 3*N_TRAIN components are pooled together\n    b = tau_train.flatten()\n    A = np.zeros((3 * N_TRAIN, 4))\n    A[:, 0] = (lambdas_train**2).flatten()\n    A[:, 1] = 1.0\n    A[:, 2] = (np.repeat(J_train, 3)**2)\n    A[:, 3] = np.repeat(J_train, 3)\n\n    # Solve for the weight vector w\n    w, _, _, _ = np.linalg.lstsq(A, b, rcond=None)\n\n    # --- Define Prediction and Ground Truth Functions ---\n    def predict_sigma_hat(F, w_fit):\n        \"\"\"Predicts Cauchy stress using the learned spectral model.\"\"\"\n        if np.linalg.det(F) <= 0:\n            return np.full((3, 3), np.nan) # Invalid deformation\n        B = F @ F.T\n        # eigh returns sorted eigenvalues and corresponding eigenvectors\n        betas, V = np.linalg.eigh(B)\n        \n        # Clamp small negative numerical noise before sqrt\n        betas[betas < 0] = 0\n        lambdas = np.sqrt(betas)\n        J = np.prod(lambdas)\n        if J < EPSILON: J = EPSILON # Avoid division by zero\n        \n        # Evaluate learned model for principal Kirchhoff stresses\n        tau_hat_i = w_fit[0] * lambdas**2 + w_fit[1] + w_fit[2] * J**2 + w_fit[3] * J\n        \n        # Reconstruct Kirchhoff stress tensor\n        tau_hat = V @ np.diag(tau_hat_i) @ V.T\n        \n        # Return Cauchy stress\n        return tau_hat / J\n\n    def true_sigma(F, mu, kappa):\n        \"\"\"Computes Cauchy stress using the true Neo-Hookean law.\"\"\"\n        J = np.linalg.det(F)\n        if J <= 0:\n            return np.full((3, 3), np.nan)\n        B = F @ F.T\n        I = np.identity(3)\n        return (mu/J) * (B - I) + kappa * (J - 1) * I\n\n    # --- 2. Test Suite Execution ---\n    results = []\n    test_cases = [\n        np.array([1.10, 0.95, 0.96]),\n        np.array([1.60, 0.70, 1.30]),\n        np.array([1.00, 1.00, 1.05])\n    ]\n\n    # Reference rotation for base deformation\n    axis_ref = np.array([1.0, 1.0, 1.0])\n    angle_ref = 1.234\n    R_ref = rodrigues_rotation(axis_ref, angle_ref)\n    \n    rng_adv = np.random.default_rng(ADV_SEED)\n\n    for lambdas_test in test_cases:\n        # --- Base Deformation Analysis ---\n        U = np.diag(lambdas_test)\n        F1 = R_ref @ U\n        \n        sigma_hat_1 = predict_sigma_hat(F1, w)\n        sigma_true_1 = true_sigma(F1, MU, KAPPA)\n\n        # Compute relative Frobenius error\n        error_num = np.linalg.norm(sigma_hat_1 - sigma_true_1, 'fro')\n        error_den = np.linalg.norm(sigma_true_1, 'fro')\n        relative_error = error_num / error_den if error_den > EPSILON else 0.0\n        results.append(relative_error)\n\n        # --- Adversarial Analysis for Invariance Leakage ---\n        max_leakage = 0.0\n        den_L = np.linalg.norm(sigma_hat_1, 'fro') + EPSILON\n\n        for _ in range(K_ADV):\n            # Generate random rotation as per problem specification\n            axis_adv = rng_adv.normal(size=3)\n            norm_axis = np.linalg.norm(axis_adv)\n            if norm_axis < EPSILON:\n                axis_adv = np.array([1.0, 0.0, 0.0]) # fallback for zero vector\n            else:\n                axis_adv /= norm_axis\n\n            angle_adv = rng_adv.uniform(0, np.pi)\n            Qk = rodrigues_rotation(axis_adv, angle_adv)\n            \n            F2k = Qk @ F1\n            sigma_hat_2k = predict_sigma_hat(F2k, w)\n            sigma_transformed = Qk @ sigma_hat_1 @ Qk.T\n            \n            num_L = np.linalg.norm(sigma_hat_2k - sigma_transformed, 'fro')\n            Lk = num_L / den_L\n            \n            if Lk > max_leakage:\n                max_leakage = Lk\n        \n        results.append(max_leakage)\n\n    # --- 3. Final Output ---\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3557115"}, {"introduction": "The practical utility of a learned constitutive model is often determined by its performance when integrated into a larger numerical simulation framework, such as the Finite Element Method (FEM). For the stability and convergence of implicit FEM solvers, an accurate material tangent—the derivative of stress with respect to strain—is as important as the stress prediction itself. This exercise ([@problem_id:3557090]) introduces the concept of Sobolev training, an advanced technique that enriches the learning process by including data on the derivatives of the energy function, directly promoting the accuracy of the resulting material tangents.", "problem": "Implement a complete, runnable program that demonstrates Sobolev training for a data-driven hyperelastic constitutive model by augmenting the loss with derivatives of the Neural Network (NN) outputs with respect to invariants and evaluates how this improves prediction of tangents for coupling into Finite Element (FE) formulations.\n\nYou will work with an isotropic, compressible hyperelastic material where the strain energy density is a scalar function of invariants of the right Cauchy-Green tensor. Start from the following fundamental base:\n\n- Hyperelasticity: the Cauchy stress is derived from a scalar strain energy density function through tensorial differentiation with respect to appropriate strain measures.\n- Invariants: for a deformation gradient $F$, define $C = F^{\\mathsf{T}} F$, its invariants $I_1 = \\mathrm{tr}(C)$, and the Jacobian $J = \\det(F)$.\n- Chain rule and basic calculus: for a composition $W(I_1, J)$, use $\\mathrm{d} W = \\dfrac{\\partial W}{\\partial I_1} \\mathrm{d} I_1 + \\dfrac{\\partial W}{\\partial J} \\mathrm{d} J$.\n\nYou must derive, from first principles, the stress expression needed to compute stresses from $W(I_1, J)$ and implement it in your program. The derivation must be done in your solution reasoning, not in the program comments. You must not rely on any formulas not deducible from the stated fundamentals.\n\nData generation:\n\n- Use a synthetic but scientifically plausible energy density function of the form\n  $$W(I_1, J) = \\tfrac{1}{2} \\mu_1 (I_1 - 3) + 0.1\\, a_2 (I_1 - 3)^2 + k_1 \\ln J + \\tfrac{1}{2} \\kappa (\\ln J)^2 + 0.05\\, k_3 (\\ln J)^3,$$\n  with dimensionless constants chosen as $\\mu_1 = 20$, $a_2 = 3$, $k_1 = -20$, $\\kappa = 50$, and $k_3 = 5$. All quantities are treated as dimensionless for this exercise.\n- From this $W$, compute the exact derivatives with respect to invariants:\n  $$\\dfrac{\\partial W}{\\partial I_1} \\quad\\text{and}\\quad \\dfrac{\\partial W}{\\partial J}.$$\n- Generate training data by sampling diagonal deformation gradients $F = \\mathrm{diag}(\\lambda_1, \\lambda_2, \\lambda_3)$ with principal stretches $\\lambda_i$ in the interval $[0.7, 1.3]$. For each sample, compute $I_1$, $J$, $W(I_1, J)$, and the exact derivatives with respect to $I_1$ and $J$.\n\nLearning model:\n\n- Use a single-hidden-layer NN with fixed random features as the hypothesis space. Specifically, define hidden features $\\phi_j(x) = \\tanh(w_j^{\\mathsf{T}} x + b_j)$ for $x = [I_1, J]^{\\mathsf{T}}$, where $w_j \\in \\mathbb{R}^2$ and $b_j \\in \\mathbb{R}$ are fixed random parameters, and learn only the linear output weights $\\beta \\in \\mathbb{R}^{M}$ so that the model is $W_\\beta(x) = \\sum_{j=1}^{M} \\beta_j \\phi_j(x)$. This ensures that both $W_\\beta$ and its input derivatives are linear in $\\beta$.\n- Define the Sobolev training objective as a weighted least-squares problem combining data mismatch on energies and their derivatives:\n  $$\\mathcal{L}(\\beta) = \\dfrac{1}{N} \\sum_{n=1}^{N} \\left( W_\\beta(x_n) - W(x_n) \\right)^2 + \\alpha \\left\\| \\nabla_x W_\\beta(x_n) - \\nabla_x W(x_n) \\right\\|_2^2,$$\n  where $\\alpha \\ge 0$ is a tunable weight and $\\nabla_x = \\left[ \\dfrac{\\partial}{\\partial I_1}, \\dfrac{\\partial}{\\partial J} \\right]^{\\mathsf{T}}$.\n- Implement both baseline training ($\\alpha = 0$) and Sobolev training ($\\alpha > 0$), each solved as a single linear least-squares problem with Tikhonov regularization on $\\beta$.\n\nStress and tangent evaluation:\n\n- Derive from first principles the Cauchy stress $\\sigma$ for an energy $W(I_1, J)$ in terms of the invariants, their derivatives, and the deformation tensors. Implement this formula in code for diagonal $F$.\n- Define two one-parameter deformation paths for evaluation:\n  1. Volumetric (hydrostatic) path: $F(\\lambda) = \\lambda I$, with $\\lambda \\in [0.85, 1.15]$.\n  2. Isochoric (volume-preserving) uniaxial path: $F(\\gamma) = \\mathrm{diag}(\\gamma, \\gamma^{-1/2}, \\gamma^{-1/2})$, with $\\gamma \\in [0.8, 1.25]$.\n- For each path, compute the directional tangent by central finite differences of the $11$-component of the Cauchy stress with respect to the path parameter (that is, $\\dfrac{\\mathrm{d} \\sigma_{11}}{\\mathrm{d} \\lambda}$ for the volumetric path and $\\dfrac{\\mathrm{d} \\sigma_{11}}{\\mathrm{d} \\gamma}$ for the isochoric path). Use a sufficiently small symmetric difference quotient and ensure that the perturbations remain within the specified parameter intervals.\n- Compute the root-mean-square error (RMSE) of the predicted tangents (baseline and Sobolev) against the true tangents obtained from the exact model over a set of evenly spaced points along each path and report the average of the two RMSEs (volumetric and isochoric).\n\nNumerical and output requirements:\n\n- All quantities are dimensionless; do not report any physical units.\n- Angles are not used; no angle unit specification is needed.\n- The program must internally set a random seed for reproducibility for each test case.\n- Implement the following test suite of three cases, each defined by a tuple $(\\text{seed}, N_{\\text{train}}, M_{\\text{features}}, \\alpha, \\lambda_{\\text{ridge}}, \\sigma_{\\text{noise}})$:\n  1. Case A (happy path): $(123, 128, 200, 10.0, 10^{-4}, 0.01)$\n  2. Case B (low data): $(456, 32, 200, 20.0, 10^{-4}, 0.01)$\n  3. Case C (control, no Sobolev gain): $(789, 128, 200, 0.0, 10^{-4}, 0.01)$\n- In each case, additive independent zero-mean Gaussian noise with standard deviation $\\sigma_{\\text{noise}}$ is applied to the energy and each derivative training label independently. Ensure the same noise realization is used for both baseline and Sobolev training in a given case.\n- For each case, compare the averaged tangent RMSEs for the baseline and the Sobolev-trained models and output a boolean that is true if the Sobolev-trained model’s averaged tangent RMSE is at least $5\\%$ lower than the baseline’s averaged tangent RMSE, and false otherwise. Formally, output true if\n  $$\\mathrm{RMSE}_{\\mathrm{Sob}} \\le (1 - 0.05)\\, \\mathrm{RMSE}_{\\mathrm{Base}},$$\n  and false otherwise.\n- Your program should produce a single line of output containing the results as a comma-separated list of Python booleans enclosed in square brackets (e.g., \"[True,False,True]\") corresponding to the three cases in the order A, B, C.\n\nThe program must be self-contained, not require any user input or external files, and must be written in Python. All calculations must be deterministic and reproducible given the specified seeds. The code must complete within reasonable time on a standard CPU, using only basic linear algebra operations.", "solution": "The objective is to implement and evaluate a Sobolev training scheme for a data-driven hyperelastic constitutive model. This involves several steps: first, deriving the necessary continuum mechanics expressions from first principles; second, generating synthetic data from a known energy function; third, training a neural network model with and without derivative information; and finally, evaluating the models' ability to predict material tangents along specific deformation paths.\n\n### Part 1: Derivation of the Cauchy Stress Tensor\n\nThe core of a hyperelastic model is the strain energy density function, $W$, which is a scalar potential from which stress is derived. For an isotropic material, $W$ is a function of the invariants of a suitable strain tensor. Here, we consider $W$ as a function of the first invariant of the right Cauchy-Green tensor, $I_1$, and the determinant of the deformation gradient, $J$.\n\nLet $\\boldsymbol{F}$ be the deformation gradient tensor. The right and left Cauchy-Green tensors are defined as $\\boldsymbol{C} = \\boldsymbol{F}^{\\mathsf{T}}\\boldsymbol{F}$ and $\\boldsymbol{B} = \\boldsymbol{F}\\boldsymbol{F}^{\\mathsf{T}}$, respectively. The specified invariants are $I_1 = \\mathrm{tr}(\\boldsymbol{C})$ and $J = \\det(\\boldsymbol{F})$. Note that $J = \\sqrt{\\det(\\boldsymbol{C})}$.\n\nThe fundamental relationship between the strain energy and stress is given through the principle of virtual work. The rate of change of strain energy per unit reference volume, $\\dot{W}$, is equal to the power expended by the stresses. In the material description, this is expressed as $\\dot{W} = \\frac{1}{2}\\boldsymbol{S}:\\dot{\\boldsymbol{C}}$, where $\\boldsymbol{S}$ is the symmetric second Piola-Kirchhoff (2nd P-K) stress tensor and $\\dot{\\boldsymbol{C}}$ is the material time derivative of $\\boldsymbol{C}$. This relationship implies that $\\boldsymbol{S} = 2\\frac{\\partial W}{\\partial \\boldsymbol{C}}$.\n\nSince $W$ is a function of $I_1$ and $J$, which are themselves functions of $\\boldsymbol{C}$, we apply the chain rule:\n$$\n\\boldsymbol{S} = 2 \\left( \\frac{\\partial W}{\\partial I_1} \\frac{\\partial I_1}{\\partial \\boldsymbol{C}} + \\frac{\\partial W}{\\partial J} \\frac{\\partial J}{\\partial \\boldsymbol{C}} \\right)\n$$\nWe need the derivatives of the invariants with respect to $\\boldsymbol{C}$:\n1.  For $I_1 = \\mathrm{tr}(\\boldsymbol{C}) = C_{kk}$, the differential is $\\mathrm{d}I_1 = \\mathrm{d}(\\mathrm{tr}(\\boldsymbol{C})) = \\mathrm{tr}(\\mathrm{d}\\boldsymbol{C}) = \\boldsymbol{I}:\\mathrm{d}\\boldsymbol{C}$, where $\\boldsymbol{I}$ is the second-order identity tensor. Thus, $\\frac{\\partial I_1}{\\partial \\boldsymbol{C}} = \\boldsymbol{I}$.\n2.  For $J = \\sqrt{\\det(\\boldsymbol{C})}$, the differential is $\\mathrm{d}J = \\frac{1}{2\\sqrt{\\det(\\boldsymbol{C})}}\\mathrm{d}(\\det(\\boldsymbol{C}))$. Using Jacobi's formula, $\\mathrm{d}(\\det(\\boldsymbol{C})) = \\det(\\boldsymbol{C})\\mathrm{tr}(\\boldsymbol{C}^{-1}\\mathrm{d}\\boldsymbol{C}) = \\det(\\boldsymbol{C})(\\boldsymbol{C}^{-1})^{\\mathsf{T}}:\\mathrm{d}\\boldsymbol{C}$. Since $\\boldsymbol{C}$ is symmetric, its inverse is also symmetric, so this simplifies to $\\det(\\boldsymbol{C})\\boldsymbol{C}^{-1}:\\mathrm{d}\\boldsymbol{C}$. Substituting this into the expression for $\\mathrm{d}J$ gives:\n    $$\n    \\mathrm{d}J = \\frac{1}{2J} (J^2 \\boldsymbol{C}^{-1}:\\mathrm{d}\\boldsymbol{C}) = \\frac{J}{2}\\boldsymbol{C}^{-1}:\\mathrm{d}\\boldsymbol{C}\n    $$\n    Therefore, $\\frac{\\partial J}{\\partial \\boldsymbol{C}} = \\frac{J}{2}\\boldsymbol{C}^{-1}$.\n\nSubstituting these derivatives back into the expression for $\\boldsymbol{S}$:\n$$\n\\boldsymbol{S} = 2 \\left( \\frac{\\partial W}{\\partial I_1} \\boldsymbol{I} + \\frac{\\partial W}{\\partial J} \\frac{J}{2}\\boldsymbol{C}^{-1} \\right) = 2\\frac{\\partial W}{\\partial I_1}\\boldsymbol{I} + J\\frac{\\partial W}{\\partial J}\\boldsymbol{C}^{-1}\n$$\nThe Cauchy stress tensor $\\boldsymbol{\\sigma}$, which represents true stress in the deformed configuration, is obtained by a push-forward operation on $\\boldsymbol{S}$: $\\boldsymbol{\\sigma} = \\frac{1}{J}\\boldsymbol{F}\\boldsymbol{S}\\boldsymbol{F}^{\\mathsf{T}}$.\n$$\n\\boldsymbol{\\sigma} = \\frac{1}{J}\\boldsymbol{F} \\left( 2\\frac{\\partial W}{\\partial I_1}\\boldsymbol{I} + J\\frac{\\partial W}{\\partial J}\\boldsymbol{C}^{-1} \\right) \\boldsymbol{F}^{\\mathsf{T}}\n$$\nDistributing the terms yields:\n$$\n\\boldsymbol{\\sigma} = \\frac{2}{J}\\frac{\\partial W}{\\partial I_1}\\boldsymbol{F}\\boldsymbol{I}\\boldsymbol{F}^{\\mathsf{T}} + \\frac{\\partial W}{\\partial J}\\boldsymbol{F}\\boldsymbol{C}^{-1}\\boldsymbol{F}^{\\mathsf{T}}\n$$\nWe identify $\\boldsymbol{F}\\boldsymbol{F}^{\\mathsf{T}} = \\boldsymbol{B}$ and simplify the second term: $\\boldsymbol{F}\\boldsymbol{C}^{-1}\\boldsymbol{F}^{\\mathsf{T}} = \\boldsymbol{F}(\\boldsymbol{F}^{\\mathsf{T}}\\boldsymbol{F})^{-1}\\boldsymbol{F}^{\\mathsf{T}} = \\boldsymbol{F}\\boldsymbol{F}^{-1}(\\boldsymbol{F}^{\\mathsf{T}})^{-1}\\boldsymbol{F}^{\\mathsf{T}} = \\boldsymbol{I}\\boldsymbol{I} = \\boldsymbol{I}$.\nThe final expression for the Cauchy stress tensor is:\n$$\n\\boldsymbol{\\sigma} = \\frac{2}{J}\\frac{\\partial W}{\\partial I_1}\\boldsymbol{B} + \\frac{\\partial W}{\\partial J}\\boldsymbol{I}\n$$\nFor a diagonal deformation gradient $\\boldsymbol{F} = \\mathrm{diag}(\\lambda_1, \\lambda_2, \\lambda_3)$, the principal stretches are $\\lambda_i$. The corresponding tensors and invariants are:\n$\\boldsymbol{C} = \\mathrm{diag}(\\lambda_1^2, \\lambda_2^2, \\lambda_3^2)$, $\\boldsymbol{B} = \\mathrm{diag}(\\lambda_1^2, \\lambda_2^2, \\lambda_3^2)$, $I_1 = \\lambda_1^2 + \\lambda_2^2 + \\lambda_3^2$, and $J = \\lambda_1\\lambda_2\\lambda_3$. The Cauchy stress tensor $\\boldsymbol{\\sigma}$ is also diagonal, with principal components:\n$$\n\\sigma_{ii} = \\frac{2}{J}\\frac{\\partial W}{\\partial I_1}\\lambda_i^2 + \\frac{\\partial W}{\\partial J}\n$$\nThis expression is used to compute stresses from the data-driven model's predictions of $W$'s derivatives.\n\n### Part 2: Data Generation and Model Training\n\nA synthetic ground truth is established using the energy function:\n$W(I_1, J) = \\tfrac{1}{2} \\mu_1 (I_1 - 3) + 0.1\\, a_2 (I_1 - 3)^2 + k_1 \\ln J + \\tfrac{1}{2} \\kappa (\\ln J)^2 + 0.05\\, k_3 (\\ln J)^3$.\nThe exact derivatives are computed analytically:\n$\\frac{\\partial W}{\\partial I_1} = \\frac{\\mu_1}{2} + 0.2 a_2 (I_1 - 3)$ and $\\frac{\\partial W}{\\partial J} = \\frac{1}{J} (k_1 + \\kappa \\ln J + 0.15 k_3 (\\ln J)^2)$.\nTraining data $\\{x_n, y_n\\}_{n=1}^N$ are generated by sampling principal stretches, computing $x_n = [I_1, J]^{\\mathsf{T}}$ and the \"labels\" $y_n = [W, \\frac{\\partial W}{\\partial I_1}, \\frac{\\partial W}{\\partial J}]^{\\mathsf{T}}$, and adding Gaussian noise.\n\nThe learning model is a random feature model, $W_\\beta(x) = \\sum_{j=1}^{M} \\beta_j \\phi_j(x) = \\boldsymbol{\\Phi}(x)^{\\mathsf{T}}\\boldsymbol{\\beta}$, where features $\\phi_j(x)=\\tanh(\\boldsymbol{w}_j^\\mathsf{T}x+b_j)$ have fixed random weights $\\boldsymbol{w}_j$ and biases $b_j$. The gradient is $\\nabla_x W_\\beta(x) = (\\nabla_x \\boldsymbol{\\Phi}(x))\\boldsymbol{\\beta}$.\n\nThe Sobolev training objective, including Tikhonov regularization, is to find $\\boldsymbol{\\beta}$ that minimizes:\n$$\n\\mathcal{L}(\\boldsymbol{\\beta}) = \\sum_{n=1}^{N} \\left[ (W_\\beta(x_n) - W(x_n))^2 + \\alpha \\left\\| \\nabla_x W_\\beta(x_n) - \\nabla_x W(x_n) \\right\\|_2^2 \\right] + \\lambda_{\\text{ridge}} \\|\\boldsymbol{\\beta}\\|_2^2\n$$\nThis is a linear least-squares problem. For each training sample $n$, we form a block of equations for the energy and its two derivatives. The global system can be written as $\\| \\boldsymbol{A} \\boldsymbol{\\beta} - \\boldsymbol{y} \\|_2^2 + \\lambda_{\\text{ridge}} \\|\\boldsymbol{\\beta}\\|_2^2$, where $\\boldsymbol{A}$ and $\\boldsymbol{y}$ are constructed as:\n$$\n\\boldsymbol{A} = \\begin{pmatrix} \\boldsymbol{\\Phi}(x_1)^{\\mathsf{T}} \\\\ \\vdots \\\\ \\boldsymbol{\\Phi}(x_N)^{\\mathsf{T}} \\\\ \\sqrt{\\alpha} (\\frac{\\partial}{\\partial I_1}\\boldsymbol{\\Phi}(x_1))^{\\mathsf{T}} \\\\ \\vdots \\\\ \\sqrt{\\alpha} (\\frac{\\partial}{\\partial J}\\boldsymbol{\\Phi}(x_N))^{\\mathsf{T}} \\end{pmatrix}, \\quad \n\\boldsymbol{y} = \\begin{pmatrix} W(x_1) \\\\ \\vdots \\\\ W(x_N) \\\\ \\sqrt{\\alpha} \\frac{\\partial W}{\\partial I_1}(x_1) \\\\ \\vdots \\\\ \\sqrt{\\alpha} \\frac{\\partial W}{\\partial J}(x_N) \\end{pmatrix}\n$$\nThe problem is solved using a standard regularized least-squares solver. Baseline training uses $\\alpha=0$, considering only energy data. Sobolev training uses $\\alpha > 0$.\n\n### Part 3: Tangent Evaluation\n\nThe models are evaluated on their ability to predict the material tangent, which is crucial for implicit finite element simulations. We compute the directional derivative of a stress component along a prescribed deformation path. For the volumetric path $\\boldsymbol{F}(\\lambda) = \\lambda\\boldsymbol{I}$ and the isochoric path $\\boldsymbol{F}(\\gamma) = \\mathrm{diag}(\\gamma, \\gamma^{-1/2}, \\gamma^{-1/2})$, we evaluate $\\frac{\\mathrm{d}\\sigma_{11}}{\\mathrm{d}\\lambda}$ and $\\frac{\\mathrm{d}\\sigma_{11}}{\\mathrm{d}\\gamma}$, respectively. These tangents are approximated using a central finite difference scheme with a small step size $\\delta$:\n$$\n\\frac{\\mathrm{d}\\sigma_{11}}{\\mathrm{d}p} \\approx \\frac{\\sigma_{11}(p+\\delta/2) - \\sigma_{11}(p-\\delta/2)}{\\delta}\n$$\nwhere $p$ is the path parameter ($\\lambda$ or $\\gamma$). The root-mean-square error (RMSE) of the predicted tangents is computed against the tangents from the true model. An average RMSE is calculated over both paths. The final criterion for success is whether the Sobolev model's average RMSE is at least $5\\%$ lower than the baseline model's, i.e., $\\mathrm{RMSE}_{\\mathrm{Sob}} \\le 0.95 \\times \\mathrm{RMSE}_{\\mathrm{Base}}$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# No other libraries are permitted.\n\nclass TrueModel:\n    \"\"\"Computes the ground truth energy, derivatives, and stress.\"\"\"\n    def __init__(self):\n        self.mu1 = 20.0\n        self.a2 = 3.0\n        self.k1 = -20.0\n        self.kappa = 50.0\n        self.k3 = 5.0\n\n    def get_W_and_derivatives(self, I1, J):\n        \"\"\"Computes W and its derivatives wrt invariants.\"\"\"\n        # Ensure logJ is numerically stable, though J>0 for the given stretch range.\n        J_safe = np.maximum(J, 1e-9)\n        logJ = np.log(J_safe)\n        \n        W = (0.5 * self.mu1 * (I1 - 3.0) +\n             0.1 * self.a2 * (I1 - 3.0)**2 +\n             self.k1 * logJ +\n             0.5 * self.kappa * logJ**2 +\n             0.05 * self.k3 * logJ**3)\n        \n        dW_dI1 = 0.5 * self.mu1 + 0.2 * self.a2 * (I1 - 3.0)\n        \n        dW_dJ = (1.0 / J_safe) * (self.k1 + self.kappa * logJ + 0.15 * self.k3 * logJ**2)\n        \n        return W, dW_dI1, dW_dJ\n\n    def get_stress_11(self, F_diag):\n        \"\"\"Computes the 11-component of the Cauchy stress.\"\"\"\n        lambda1 = F_diag[..., 0]\n        lambda2 = F_diag[..., 1]\n        lambda3 = F_diag[..., 2]\n        \n        I1 = lambda1**2 + lambda2**2 + lambda3**2\n        J = lambda1 * lambda2 * lambda3\n        \n        _, dW_dI1, dW_dJ = self.get_W_and_derivatives(I1, J)\n        \n        # sigma_11 = (2/J) * dW/dI1 * lambda1^2 + dW/dJ\n        sigma11 = (2.0 / J) * dW_dI1 * lambda1**2 + dW_dJ\n        \n        return sigma11\n\nclass HyperelasticNN:\n    \"\"\"A random feature model for the hyperelastic energy.\"\"\"\n    def __init__(self, beta, w, b):\n        self.beta = beta\n        self.w = w\n        self.b = b\n\n    def get_W_and_derivatives(self, I1, J):\n        \"\"\"Predicts W and its derivatives from the NN model.\"\"\"\n        X = np.stack([I1, J], axis=-1)\n        if X.ndim == 1:\n            X = X[np.newaxis, :]\n            \n        U = X @ self.w.T + self.b\n        Phi = np.tanh(U)\n        \n        W_pred = Phi @ self.beta\n\n        dPhi_dU = 1.0 - Phi**2\n        \n        dPhi_dI1 = dPhi_dU * self.w[:, 0]\n        dW_dI1_pred = dPhi_dI1 @ self.beta\n        \n        dPhi_dJ = dPhi_dU * self.w[:, 1]\n        dW_dJ_pred = dPhi_dJ @ self.beta\n        \n        return W_pred.squeeze(), dW_dI1_pred.squeeze(), dW_dJ_pred.squeeze()\n\n    def get_stress_11(self, F_diag):\n        \"\"\"Predicts the 11-component of the Cauchy stress.\"\"\"\n        lambda1 = F_diag[..., 0]\n        lambda2 = F_diag[..., 1]\n        lambda3 = F_diag[..., 2]\n        \n        I1 = lambda1**2 + lambda2**2 + lambda3**2\n        J = lambda1 * lambda2 * lambda3\n        \n        _, dW_dI1, dW_dJ = self.get_W_and_derivatives(I1, J)\n        \n        sigma11 = (2.0 / J) * dW_dI1 * lambda1**2 + dW_dJ\n        \n        return sigma11\n\ndef train_model(X_train, Y_train_noisy, M_features, alpha, lambda_ridge, w, b):\n    \"\"\"Solves for the NN weights beta using (regularized) least squares.\"\"\"\n    N_train = X_train.shape[0]\n    \n    # Unpack noisy labels\n    W_noisy, dWdI1_noisy, dWdJ_noisy = Y_train_noisy.T\n\n    # Compute feature matrix and its derivatives\n    U = X_train @ w.T + b\n    Phi = np.tanh(U)\n    \n    dPhi_dU = 1.0 - Phi**2\n    dPhi_dI1 = dPhi_dU * w[:, 0]\n    dPhi_dJ = dPhi_dU * w[:, 1]\n    \n    # Assemble the system matrix A for the least-squares problem\n    A = np.vstack([\n        Phi,\n        np.sqrt(alpha) * dPhi_dI1,\n        np.sqrt(alpha) * dPhi_dJ\n    ])\n    \n    # Assemble the target vector y\n    y = np.concatenate([\n        W_noisy,\n        np.sqrt(alpha) * dWdI1_noisy,\n        np.sqrt(alpha) * dWdJ_noisy\n    ])\n    \n    # Augment for Tikhonov (ridge) regularization\n    A_aug = np.vstack([A, np.sqrt(lambda_ridge) * np.eye(M_features)])\n    y_aug = np.concatenate([y, np.zeros(M_features)])\n    \n    # Solve the linear system\n    beta, _, _, _ = np.linalg.lstsq(A_aug, y_aug, rcond=None)\n    \n    return beta\n\ndef eval_model_tangent(stress_predictor, path_type, num_points=100, dp=1e-6):\n    \"\"\"Evaluates the directional tangent of sigma_11 along a path.\"\"\"\n    if path_type == 'volumetric':\n        p_vals = np.linspace(0.85, 1.15, num_points)\n        def get_F(p_vec):\n            return np.vstack([p_vec, p_vec, p_vec]).T\n    elif path_type == 'isochoric':\n        p_vals = np.linspace(0.8, 1.25, num_points)\n        def get_F(p_vec):\n            # Use np.power for vectorized exponentiation\n            return np.vstack([p_vec, np.power(p_vec, -0.5), np.power(p_vec, -0.5)]).T\n    else:\n        raise ValueError(\"Invalid path type\")\n        \n    p_plus = p_vals + dp / 2.0\n    p_minus = p_vals - dp / 2.0\n    \n    F_plus = get_F(p_plus)\n    F_minus = get_F(p_minus)\n\n    sigma_plus = stress_predictor(F_plus)\n    sigma_minus = stress_predictor(F_minus)\n    \n    tangents = (sigma_plus - sigma_minus) / dp\n    return tangents\n\ndef run_case(case_params):\n    \"\"\"Runs a full test case from data generation to evaluation.\"\"\"\n    seed, N_train, M_features, alpha_sob, lambda_ridge, sigma_noise = case_params\n\n    rng = np.random.default_rng(seed)\n    true_model = TrueModel()\n\n    # Data Generation\n    lambdas = rng.uniform(0.7, 1.3, size=(N_train, 3))\n    I1 = np.sum(lambdas**2, axis=1)\n    J = np.prod(lambdas, axis=1)\n    X_train = np.stack([I1, J], axis=1)\n    \n    W_true, dWdI1_true, dWdJ_true = true_model.get_W_and_derivatives(I1, J)\n    \n    W_noisy = W_true + rng.normal(0, sigma_noise, size=N_train)\n    dWdI1_noisy = dWdI1_true + rng.normal(0, sigma_noise, size=N_train)\n    dWdJ_noisy = dWdJ_true + rng.normal(0, sigma_noise, size=N_train)\n    Y_train_noisy = np.stack([W_noisy, dWdI1_noisy, dWdJ_noisy], axis=1)\n    \n    # Model Training\n    w = rng.standard_normal(size=(M_features, 2))\n    b = rng.uniform(-1.0, 1.0, size=M_features)\n\n    # Baseline model\n    beta_base = train_model(X_train, Y_train_noisy, M_features, 0.0, lambda_ridge, w, b)\n    model_base = HyperelasticNN(beta_base, w, b)\n    \n    # Sobolev model\n    beta_sob = train_model(X_train, Y_train_noisy, M_features, alpha_sob, lambda_ridge, w, b)\n    model_sob = HyperelasticNN(beta_sob, w, b)\n\n    # Evaluation\n    rmses_base, rmses_sob = [], []\n    for path in ['volumetric', 'isochoric']:\n        tangents_true = eval_model_tangent(true_model.get_stress_11, path)\n        \n        tangents_base = eval_model_tangent(model_base.get_stress_11, path)\n        rmse_base = np.sqrt(np.mean((tangents_base - tangents_true)**2))\n        rmses_base.append(rmse_base)\n\n        tangents_sob = eval_model_tangent(model_sob.get_stress_11, path)\n        rmse_sob = np.sqrt(np.mean((tangents_sob - tangents_true)**2))\n        rmses_sob.append(rmse_sob)\n        \n    avg_rmse_base = np.mean(rmses_base)\n    avg_rmse_sob = np.mean(rmses_sob)\n    \n    return avg_rmse_sob <= 0.95 * avg_rmse_base\n\ndef solve():\n    \"\"\"Defines and runs the test suite.\"\"\"\n    test_cases = [\n        (123, 128, 200, 10.0, 1e-4, 0.01),  # Case A\n        (456, 32, 200, 20.0, 1e-4, 0.01),   # Case B\n        (789, 128, 200, 0.0, 1e-4, 0.01),   # Case C\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_case(case)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3557090"}]}