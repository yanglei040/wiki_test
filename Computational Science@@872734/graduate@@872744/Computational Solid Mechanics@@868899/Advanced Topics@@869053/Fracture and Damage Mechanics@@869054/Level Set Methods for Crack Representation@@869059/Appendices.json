{"hands_on_practices": [{"introduction": "Before simulating crack growth, we must first accurately represent an initial crack within the computational domain. This foundational exercise ([@problem_id:3577077]) guides you through the construction of the two essential fields for crack representation: the signed distance function $\\phi$ and the crack-tip arc-length function $\\psi$. Mastering this geometric initialization is the crucial first step for any subsequent analysis of fracture mechanics using level set methods.", "problem": "You are given a set of connected line segments in the plane that define an oriented crack as a polyline. The polyline is specified by ordered vertices $\\{\\mathbf{x}_0,\\mathbf{x}_1,\\ldots,\\mathbf{x}_{N-1}\\}$ with $\\mathbf{x}_i \\in \\mathbb{R}^2$. The final vertex $\\mathbf{x}_{N-1}$ is the crack tip. Your task is to construct two scalar fields on a set of query points $\\{\\mathbf{p}_k\\}$:\n\n1. A signed distance function (SDF) $\\phi(\\mathbf{p})$ to the polyline representing the crack surface.\n2. An arc-length function $\\psi(\\mathbf{p})$ that returns the cumulative distance along the polyline from the crack tip to the closest point on the polyline.\n\nBase your derivation and algorithm on the following fundamental definitions and geometric facts:\n\n- For each segment $i$ from $\\mathbf{x}_i$ to $\\mathbf{x}_{i+1}$, define the segment vector $\\mathbf{v}_i = \\mathbf{x}_{i+1} - \\mathbf{x}_i$, the segment length $L_i = \\|\\mathbf{v}_i\\|_2$, the unit tangent $\\mathbf{t}_i = \\mathbf{v}_i / L_i$, and the unit normal $\\mathbf{n}_i$ obtained by a $+90^\\circ$ rotation of $\\mathbf{t}_i$, i.e., $\\mathbf{n}_i = R_{90}\\,\\mathbf{t}_i$ where $R_{90} = \\begin{pmatrix}0  -1 \\\\ 1  0\\end{pmatrix}$. This convention makes $\\mathbf{n}_i$ point to the \"left\" of the oriented segment.\n- The unsigned Euclidean distance from a point $\\mathbf{p}$ to segment $i$ is given by the minimum over the segment of $\\|\\mathbf{p} - (\\mathbf{x}_i + s\\,\\mathbf{v}_i)\\|_2$ for $s \\in [0,1]$. Let $s_i^\\ast = \\mathrm{clamp}\\left(\\frac{(\\mathbf{p}-\\mathbf{x}_i)\\cdot \\mathbf{v}_i}{\\mathbf{v}_i \\cdot \\mathbf{v}_i},\\,0,\\,1\\right)$ be the clamped projection parameter and $\\mathbf{q}_i^\\ast = \\mathbf{x}_i + s_i^\\ast \\mathbf{v}_i$ be the closest point on segment $i$ to $\\mathbf{p}$.\n- The signed distance to segment $i$ is obtained by multiplying the unsigned distance by a side indicator based on the oriented normal, $\\mathrm{sign}_i(\\mathbf{p}) = \\begin{cases}+1  \\text{if } \\mathbf{n}_i \\cdot (\\mathbf{p} - \\mathbf{q}_i^\\ast) \\ge 0\\\\-1  \\text{otherwise}\\end{cases}$. The signed distance candidate from segment $i$ is then $\\phi_i(\\mathbf{p}) = \\mathrm{sign}_i(\\mathbf{p})\\,\\|\\mathbf{p}-\\mathbf{q}_i^\\ast\\|_2$.\n- The polyline signed distance $\\phi(\\mathbf{p})$ is defined by selecting the segment index $i^\\ast$ that minimizes the unsigned distance $\\|\\mathbf{p}-\\mathbf{q}_{i}^\\ast\\|_2$ and setting $\\phi(\\mathbf{p}) = \\phi_{i^\\ast}(\\mathbf{p})$.\n- The arc-length from the tip to any vertex $j$ is defined by $$s(\\mathbf{x}_{N-1}) = 0,\\quad s(\\mathbf{x}_{j}) = \\sum_{m=j}^{N-2} L_m \\quad \\text{for } j=0,1,\\ldots,N-2.$$ For a point $\\mathbf{p}$ whose closest point is on segment $i$ at parameter $s_i^\\ast$, the arc-length field is $$\\psi(\\mathbf{p}) = s(\\mathbf{x}_{i+1}) + (1 - s_i^\\ast)\\,L_i,$$ which measures the cumulative distance from the tip $\\mathbf{x}_{N-1}$ to the closest point along the polyline. Distances are to be expressed in meters.\n\nAssumptions and conventions:\n\n- All coordinates $\\mathbf{x}_i$ and $\\mathbf{p}_k$ are given in meters. Your outputs $\\phi$ and $\\psi$ must be in meters.\n- The polyline is non-degenerate: each segment has strictly positive length.\n- The sign convention for $\\phi$ uses the oriented normal $\\mathbf{n}_i$ as above; $\\phi(\\mathbf{p})  0$ if $\\mathbf{p}$ lies to the \"left\" of the locally oriented segment at the closest point, and $\\phi(\\mathbf{p})  0$ if to the \"right\". If $\\mathbf{p}-\\mathbf{q}_i^\\ast$ is orthogonal to $\\mathbf{n}_i$, use the nonnegative branch in the side indicator, i.e., $\\mathrm{sign}_i(\\mathbf{p}) = +1$ for zero dot product.\n\nTasks:\n\n- Implement a program that, for each test case below, computes the lists of $\\phi$ and $\\psi$ values for the provided query points using the definitions above.\n\nTest suite:\n\n- Test case 1:\n  - Polyline vertices: $\\{(0.0, 0.0),\\,(2.0, 0.0)\\}$ with tip at $(2.0,0.0)$.\n  - Query points: $\\{(1.0, 0.5),\\,(1.0,-0.5),\\,(2.5, 0.0),\\,(0.0,-0.5)\\}$.\n- Test case 2:\n  - Polyline vertices: $\\{(0.0,0.0),\\,(1.0,0.0),\\,(1.0,1.0)\\}$ with tip at $(1.0,1.0)$.\n  - Query points: $\\{(0.25,0.20),\\,(0.80,0.75),\\,(0.50,-0.30),\\,(-0.20,0.00)\\}$.\n- Test case 3:\n  - Polyline vertices: $\\{(0.0,0.0),\\,(2.0,1.0),\\,(3.0,3.0),\\,(5.0,2.0)\\}$ with tip at $(5.0,2.0)$.\n  - Query points: $\\{(2.5,2.0),\\,(3.5,2.1),\\,(4.5,2.2),\\,(0.0,0.0)\\}$.\n\nFinal output format:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets.\n- For each test case, output first the sequence of $\\phi$ values for the query points in the order given, followed by the sequence of $\\psi$ values for the same points, both in meters.\n- Concatenate the outputs for the three test cases in order. For example, the final output should be of the form\n  $$[\\phi_{1,1},\\ldots,\\phi_{1,M_1},\\psi_{1,1},\\ldots,\\psi_{1,M_1},\\phi_{2,1},\\ldots,\\psi_{3,M_3}]$$\n  where $M_i$ is the number of query points in test case $i$.", "solution": "The problem statement is a valid, well-posed problem in computational geometry, directly relevant to the field of computational solid mechanics for representing cracks using level set methods. All definitions, data, and constraints are scientifically sound, consistent, and complete. The problem requires the implementation of an algorithm to compute two scalar fields, a signed distance function $\\phi$ and an arc-length function $\\psi$, for a given polyline crack and a set of query points.\n\n### Algorithmic Approach\n\nThe core of the problem is to find, for each query point $\\mathbf{p}$, the closest point on the polyline crack. The polyline is a collection of line segments. The closest point on the polyline is the one that minimizes the Euclidean distance among all closest points on individual segments. Once this globally closest point and its corresponding segment are identified, the fields $\\phi(\\mathbf{p})$ and $\\psi(\\mathbf{p})$ are computed based on the provided definitions.\n\nThe overall algorithm is as follows:\n1.  For each test case, retrieve the polyline vertices $\\{\\mathbf{x}_0, \\ldots, \\mathbf{x}_{N-1}\\}$ and the query points $\\{\\mathbf{p}_k\\}$.\n2.  **Pre-computation Phase**: For the given polyline, pre-calculate properties for each segment $i \\in \\{0, \\ldots, N-2\\}$, which connects $\\mathbf{x}_i$ to $\\mathbf{x}_{i+1}$:\n    -   The segment vector $\\mathbf{v}_i = \\mathbf{x}_{i+1} - \\mathbf{x}_i$.\n    -   The segment length $L_i = \\|\\mathbf{v}_i\\|_2$ and its square $L_i^2 = \\mathbf{v}_i \\cdot \\mathbf{v}_i$.\n    -   The unit tangent vector $\\mathbf{t}_i = \\mathbf{v}_i / L_i$.\n    -   The unit normal vector $\\mathbf{n}_i = R_{90}\\,\\mathbf{t}_i$, where $R_{90}$ is the $+90^\\circ$ rotation matrix. If $\\mathbf{t}_i = (t_x, t_y)$, then $\\mathbf{n}_i = (-t_y, t_x)$.\n    -   The arc-lengths $s(\\mathbf{x}_j)$ from the crack tip $\\mathbf{x}_{N-1}$ to each vertex $\\mathbf{x}_j$. These are computed iteratively backwards from the tip: $s(\\mathbf{x}_{N-1}) = 0$, and for $j = N-2, \\ldots, 0$, $s(\\mathbf{x}_j) = s(\\mathbf{x}_{j+1}) + L_j$.\n3.  **Query Phase**: For each query point $\\mathbf{p}$:\n    a. Initialize a minimum squared distance to infinity.\n    b. Iterate through each segment $i$ of the polyline.\n        i.  Calculate the parameter $s_i^\\ast$ that determines the closest point on the infinite line containing segment $i$. This is done by projecting the vector $\\mathbf{p}-\\mathbf{x}_i$ onto the segment vector $\\mathbf{v}_i$:\n            $$s_i = \\frac{(\\mathbf{p}-\\mathbf{x}_i)\\cdot \\mathbf{v}_i}{\\mathbf{v}_i \\cdot \\mathbf{v}_i}$$\n        ii. The parameter for the closest point on the segment is found by clamping $s_i$ to the interval $[0, 1]$:\n            $$s_i^\\ast = \\mathrm{clamp}(s_i, 0, 1)$$\n        iii. The closest point on segment $i$ is then $\\mathbf{q}_i^\\ast = \\mathbf{x}_i + s_i^\\ast \\mathbf{v}_i$.\n        iv. Compute the squared distance $d_i^2 = \\|\\mathbf{p}-\\mathbf{q}_i^\\ast\\|_2^2$.\n        v. If $d_i^2$ is less than the current minimum squared distance, update the minimum and store the segment index $i^\\ast$, the parameter $s_{i^\\ast}^\\ast$, and the closest point $\\mathbf{q}_{i^\\ast}^\\ast$.\n    c. After checking all segments, we will have identified the globally closest segment $i^\\ast$, the closest point on the polyline $\\mathbf{q}^\\ast = \\mathbf{q}_{i^\\ast}^\\ast$, the minimum distance $d_{\\min} = \\sqrt{\\|\\mathbf{p}-\\mathbf{q}^\\ast\\|_2^2}$, and the corresponding projection parameter $s_{i^\\ast}^\\ast$.\n4.  **Field Computation**:\n    a. **Signed Distance Function $\\phi(\\mathbf{p})$**: The sign is determined by the orientation of the vector $\\mathbf{p} - \\mathbf{q}^\\ast$ with respect to the normal of the closest segment, $\\mathbf{n}_{i^\\ast}$.\n        $$\\mathrm{sign} = \\begin{cases}+1  \\text{if } \\mathbf{n}_{i^\\ast} \\cdot (\\mathbf{p} - \\mathbf{q}^\\ast) \\ge 0\\\\-1  \\text{otherwise}\\end{cases}$$\n        The signed distance is $\\phi(\\mathbf{p}) = \\mathrm{sign} \\times d_{\\min}$. If $d_{\\min}=0$, then $\\phi(\\mathbf{p})=0$.\n    b. **Arc-Length Function $\\psi(\\mathbf{p})$**: This function measures the distance from the crack tip $\\mathbf{x}_{N-1}$ to the closest point $\\mathbf{q}^\\ast$ along the polyline. It is calculated using the pre-computed arc-lengths to vertices and the local position on the closest segment:\n        $$\\psi(\\mathbf{p}) = s(\\mathbf{x}_{i^\\ast+1}) + (1 - s_{i^\\ast}^\\ast) L_{i^\\ast}$$\n        Here, $s(\\mathbf{x}_{i^\\ast+1})$ is the distance from the tip to the end-vertex of the closest segment. The term $(1 - s_{i^\\ast}^\\ast) L_{i^\\ast}$ is the distance from the closest point $\\mathbf{q}^\\ast$ to this end-vertex along the segment.\n\nThis principled, step-by-step procedure provides a robust method for computing the required fields, correctly handling all geometric cases including points closest to segment interiors and vertices. The implementation will use `numpy` for efficient and accurate vector arithmetic.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of computing signed distance and arc-length fields\n    for a polyline crack representation.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"vertices\": [[0.0, 0.0], [2.0, 0.0]],\n            \"query_points\": [[1.0, 0.5], [1.0, -0.5], [2.5, 0.0], [0.0, -0.5]]\n        },\n        # Test case 2\n        {\n            \"vertices\": [[0.0, 0.0], [1.0, 0.0], [1.0, 1.0]],\n            \"query_points\": [[0.25, 0.20], [0.80, 0.75], [0.50, -0.30], [-0.20, 0.00]]\n        },\n        # Test case 3\n        {\n            \"vertices\": [[0.0, 0.0], [2.0, 1.0], [3.0, 3.0], [5.0, 2.0]],\n            \"query_points\": [[2.5, 2.0], [3.5, 2.1], [4.5, 2.2], [0.0, 0.0]]\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        vertices = np.array(case[\"vertices\"], dtype=float)\n        query_points = np.array(case[\"query_points\"], dtype=float)\n\n        N = vertices.shape[0]\n        num_segments = N - 1\n\n        # === Pre-computation Phase ===\n        \n        # Segment properties\n        segment_starts = vertices[:-1]\n        segment_ends = vertices[1:]\n        segment_vectors = segment_ends - segment_starts\n        segment_lengths_sq = np.sum(segment_vectors**2, axis=1)\n        segment_lengths = np.sqrt(segment_lengths_sq)\n        \n        # Unit tangents and normals. Add small epsilon to avoid division by zero\n        # although problem guarantees non-degenerate segments.\n        unit_tangents = segment_vectors / (segment_lengths[:, np.newaxis] + 1e-12)\n        unit_normals = np.array([-unit_tangents[:, 1], unit_tangents[:, 0]]).T\n\n        # Arc-lengths from the tip (last vertex) to each vertex\n        arc_lengths_at_vertices = np.zeros(N)\n        for j in range(N - 2, -1, -1):\n            arc_lengths_at_vertices[j] = arc_lengths_at_vertices[j+1] + segment_lengths[j]\n\n        phi_values = []\n        psi_values = []\n\n        # === Query Phase ===\n        for p in query_points:\n            min_dist_sq = np.inf\n            closest_segment_idx = -1\n            optimal_s_star = -1.0\n            closest_point_on_polyline = None\n\n            for i in range(num_segments):\n                # Vector from segment start to query point\n                w = p - segment_starts[i]\n                \n                # Projection parameter (unclamped)\n                s = np.dot(w, segment_vectors[i]) / (segment_lengths_sq[i] + 1e-12)\n                \n                # Clamped parameter\n                s_star = np.clip(s, 0.0, 1.0)\n                \n                # Closest point on the current segment\n                q_star = segment_starts[i] + s_star * segment_vectors[i]\n                \n                dist_sq = np.sum((p - q_star)**2)\n\n                if dist_sq  min_dist_sq:\n                    min_dist_sq = dist_sq\n                    closest_segment_idx = i\n                    optimal_s_star = s_star\n                    closest_point_on_polyline = q_star\n\n            # === Field Computation ===\n            \n            # 1. Signed Distance Function (SDF) phi\n            dist = np.sqrt(min_dist_sq)\n            if np.isclose(dist, 0.0):\n                phi = 0.0\n            else:\n                vec_p_q = p - closest_point_on_polyline\n                dot_product = np.dot(unit_normals[closest_segment_idx], vec_p_q)\n                sign = 1.0 if dot_product = 0 else -1.0\n                phi = sign * dist\n            phi_values.append(phi)\n            \n            # 2. Arc-Length Function psi\n            psi = arc_lengths_at_vertices[closest_segment_idx + 1] + \\\n                  (1 - optimal_s_star) * segment_lengths[closest_segment_idx]\n            psi_values.append(psi)\n\n        all_results.extend(phi_values)\n        all_results.extend(psi_values)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3577077"}, {"introduction": "Evolving the entire level set field across the domain to propagate a crack is computationally prohibitive for realistic problems. This practice ([@problem_id:3577131]) introduces the narrow-band method, an indispensable optimization that confines updates to a small region around the crack. By implementing this technique, you will directly explore the critical trade-off between computational cost and accuracy, a central theme in designing efficient numerical simulations.", "problem": "Consider a two-dimensional computational domain representing a thin plate with a straight crack, where the crack is represented implicitly by the zero level set of a scalar field $\\phi(x,y,t)$, and the sign of $\\phi$ distinguishes the two sides of the crack. Assume the initial condition $\\phi(x,y,0)=x$, which is the signed distance to the plane $x=0$ and whose zero level set corresponds to the straight crack line. The level set is evolved by the linear advection equation\n$$\n\\frac{\\partial \\phi}{\\partial t} + \\mathbf{v}\\cdot\\nabla \\phi = 0,\n$$\nwhere $\\mathbf{v}=(v_x,v_y)$ is a constant velocity field driving the crack front. The exact solution for the chosen initial condition and constant velocity is\n$$\n\\phi_{\\text{exact}}(x,y,t)=x - v_x t,\n$$\nfor any $y$, because $\\nabla \\phi(0)=(1,0)$ and the advection is uniform.\n\nYour task is to implement a narrow-band level set update that restricts computations at each time step to only those grid cells that satisfy $|\\phi|\\le \\delta$, for a given band half-width $\\delta0$. Outside the band, $\\phi$ must remain unchanged. Use a first-order explicit upwind finite difference scheme in space and forward Euler in time for the advection equation. Specifically, for each grid cell with indices $(i,j)$, use the upwind differences\n$$\nD_x^-\\phi_{i,j}=\\frac{\\phi_{i,j}-\\phi_{i-1,j}}{\\Delta x},\\quad\nD_x^+\\phi_{i,j}=\\frac{\\phi_{i+1,j}-\\phi_{i,j}}{\\Delta x},\n$$\n$$\nD_y^-\\phi_{i,j}=\\frac{\\phi_{i,j}-\\phi_{i,j-1}}{\\Delta y},\\quad\nD_y^+\\phi_{i,j}=\\frac{\\phi_{i,j+1}-\\phi_{i,j}}{\\Delta y},\n$$\nand define the discrete advection term at $(i,j)$ as\n$$\n\\mathcal{A}_{i,j} = \\max(v_x,0)\\,D_x^-\\phi_{i,j} + \\min(v_x,0)\\,D_x^+\\phi_{i,j} + \\max(v_y,0)\\,D_y^-\\phi_{i,j} + \\min(v_y,0)\\,D_y^+\\phi_{i,j}.\n$$\nThen the time update for cells inside the band is\n$$\n\\phi_{i,j}^{n+1} = \\phi_{i,j}^n - \\Delta t\\,\\mathcal{A}_{i,j},\\quad \\text{if }|\\phi_{i,j}^n|\\le \\delta,\n$$\nand otherwise\n$$\n\\phi_{i,j}^{n+1} = \\phi_{i,j}^n,\\quad \\text{if }|\\phi_{i,j}^n| \\delta.\n$$\nImpose homogeneous Neumann boundary conditions by copying edge values to ghost points so that one-sided differences are well-defined at the boundaries.\n\nUse the following numerical setup:\n- Domain: $x\\in[-1,1]$ and $y\\in[-1,1]$ in meters.\n- Uniform grid with $N_x=N_y=201$ points, so $\\Delta x=\\Delta y=\\frac{2}{N_x-1}$ in meters.\n- Initial condition: $\\phi(x,y,0)=x$.\n- Velocity: $\\mathbf{v}=(v_x,v_y)=(0.5,0.0)$ in meters per second.\n- Final time: $T=0.4$ in seconds.\n- Time step: choose $\\Delta t$ to satisfy the Courant–Friedrichs–Lewy (CFL) condition $\\Delta t=\\theta\\min\\left(\\frac{\\Delta x}{|v_x|},\\frac{\\Delta y}{|v_y|+\\varepsilon}\\right)$ with $\\theta=0.5$ and $\\varepsilon=0$ when $v_y=0$, so that $\\Delta t=0.5\\,\\frac{\\Delta x}{|v_x|}$ in seconds.\n- Time integration: forward Euler with $N_t=\\left\\lceil\\frac{T}{\\Delta t}\\right\\rceil$ steps.\n\nDefine the accuracy metric as the root-mean-square error (RMSE) between the narrow-band numerical solution at time $T$ and the exact solution $\\phi_{\\text{exact}}(x,y,T)=x-v_x T$ over the entire grid,\n$$\n\\mathrm{RMSE}=\\sqrt{\\frac{1}{N_x N_y}\\sum_{i=1}^{N_x}\\sum_{j=1}^{N_y}\\left(\\phi_{i,j}^{\\text{band}}(T)-\\phi_{\\text{exact}}(x_i,y_j,T)\\right)^2},\n$$\nwhich has units of meters. Define the computational cost as the average fraction of grid cells updated per time step,\n$$\n\\mathrm{cost}=\\frac{1}{N_t}\\sum_{n=0}^{N_t-1}\\frac{\\#\\{(i,j):|\\phi_{i,j}^n|\\le \\delta\\}}{N_x N_y},\n$$\nwhich is unitless and lies in $[0,1]$.\n\nTest suite:\n- Case $1$: $\\delta=0$ in meters (boundary case: only cells exactly on the zero level set are updated).\n- Case $2$: $\\delta=\\Delta x$ in meters (band roughly one grid cell wide).\n- Case $3$: $\\delta=0.05$ in meters (moderate band width).\n- Case $4$: $\\delta=2.0$ in meters (band covers the entire domain; equivalent to full-domain update).\n\nYour program must compute, for each test case, the pair $[\\mathrm{RMSE},\\mathrm{cost}]$ and produce a single line of output containing the list of these pairs as a comma-separated list with no spaces, enclosed in square brackets, for example:\n$[[e_1,c_1],[e_2,c_2],[e_3,c_3],[e_4,c_4]]$.\nAll reported values must be floating-point numbers. No physical units need to be printed in the output; the RMSE will implicitly be in meters and the cost is unitless.", "solution": "The problem requires the implementation and analysis of a narrow-band level set method for simulating the advection of an interface. The governing equation is the linear advection equation, which describes how a scalar field $\\phi$ is transported by a velocity field $\\mathbf{v}$.\n\n### 1. Problem Formulation and Discretization\n\nThe physical problem is the evolution of a scalar field $\\phi(x,y,t)$ in a two-dimensional domain, governed by the partial differential equation (PDE):\n$$\n\\frac{\\partial \\phi}{\\partial t} + \\mathbf{v} \\cdot \\nabla \\phi = 0\n$$\nThe domain is a square plate defined by $x \\in [-1, 1]$ and $y \\in [-1, 1]$. This domain is discretized using a uniform grid with $N_x = 201$ and $N_y = 201$ points. The grid spacing in each direction is therefore identical:\n$$\n\\Delta x = \\frac{1 - (-1)}{N_x - 1} = \\frac{2}{200} = 0.01 \\, \\text{m}\n$$\n$$\n\\Delta y = \\frac{1 - (-1)}{N_y - 1} = \\frac{2}{200} = 0.01 \\, \\text{m}\n$$\nThe grid points are denoted by $(x_i, y_j)$, where $x_i = -1 + i\\Delta x$ for $i \\in \\{0, 1, \\dots, N_x-1\\}$ and $y_j = -1 + j\\Delta y$ for $j \\in \\{0, 1, \\dots, N_y-1\\}$.\n\nThe initial condition for the level set field is given by:\n$$\n\\phi(x, y, 0) = x\n$$\nOn the discrete grid, this translates to $\\phi_{i,j}^0 = x_i$.\n\nThe time evolution is simulated until a final time $T = 0.4 \\, \\text{s}$. The time integration is performed using the forward Euler method. To ensure numerical stability, the time step $\\Delta t$ is determined by the Courant–Friedrichs–Lewy (CFL) condition. With a safety factor $\\theta = 0.5$ and a constant velocity field $\\mathbf{v} = (v_x, v_y) = (0.5, 0.0) \\, \\text{m/s}$, the time step is:\n$$\n\\Delta t = \\theta \\frac{\\Delta x}{|v_x|} = 0.5 \\times \\frac{0.01}{|0.5|} = 0.01 \\, \\text{s}\n$$\nThe total number of time steps required to reach the final time $T$ is:\n$$\nN_t = \\left\\lceil \\frac{T}{\\Delta t} \\right\\rceil = \\left\\lceil \\frac{0.4}{0.01} \\right\\rceil = 40\n$$\n\n### 2. Numerical Scheme: Upwind Finite Difference\n\nThe spatial derivatives in the advection term $\\mathbf{v} \\cdot \\nabla \\phi$ are approximated using a first-order upwind finite difference scheme. This scheme is chosen for its stability properties in solving hyperbolic PDEs like the advection equation. It uses a one-sided difference that takes information from the direction \"upwind\" of the velocity. The discrete advection operator $\\mathcal{A}_{i,j}$ is defined as:\n$$\n\\mathcal{A}_{i,j} = \\max(v_x,0)\\,D_x^-\\phi_{i,j} + \\min(v_x,0)\\,D_x^+\\phi_{i,j} + \\max(v_y,0)\\,D_y^-\\phi_{i,j} + \\min(v_y,0)\\,D_y^+\\phi_{i,j}\n$$\nHere, $D_x^-$, $D_x^+$, $D_y^-$, and $D_y^+$ are the backward and forward difference operators. For the given velocity $\\mathbf{v} = (0.5, 0.0)$, we have $v_x  0$ and $v_y = 0$. The expression for $\\mathcal{A}_{i,j}$ simplifies to:\n$$\n\\mathcal{A}_{i,j} = v_x D_x^-\\phi_{i,j} = 0.5 \\times \\frac{\\phi_{i,j} - \\phi_{i-1,j}}{\\Delta x}\n$$\nTo handle the derivatives at the domain boundaries, homogeneous Neumann boundary conditions are imposed. This is implemented by creating a layer of \"ghost cells\" around the computational grid, where the value in a ghost cell is a copy of the value in the adjacent interior cell. For example, $\\phi_{-1,j} = \\phi_{0,j}$ and $\\phi_{N_x,j} = \\phi_{N_x-1,j}$. This ensures that the normal derivative at the boundary is effectively zero.\n\n### 3. Narrow-Band Update Algorithm\n\nThe narrow-band level set method is an optimization that restricts expensive computations to a small band of grid cells around the zero level set. The algorithm proceeds as follows for each time step from $n=0$ to $N_t-1$:\n\n1.  **Identify the Narrow Band**: A boolean mask is created to identify all grid cells $(i,j)$ where the current level set value $\\phi_{i,j}^n$ satisfies $|\\phi_{i,j}^n| \\le \\delta$, for a given band half-width $\\delta$. The number of cells within this band is counted for the computational cost metric.\n\n2.  **Apply Boundary Conditions**: The grid for $\\phi^n$ is padded with ghost cells according to the homogeneous Neumann condition.\n\n3.  **Compute Advection Term**: The simplified upwind advection term, $\\mathcal{A}_{i,j} = v_x (\\phi_{i,j}^n - \\phi_{i-1,j}^n) / \\Delta x$, is calculated for all grid points.\n\n4.  **Update Level Set Field**: A copy of the current field, $\\phi_{\\text{next}}$, is made from $\\phi^n$. The values of $\\phi_{\\text{next}}$ are updated only for the cells identified to be within the narrow band:\n    $$\n    \\phi_{i,j}^{n+1} = \\phi_{i,j}^n - \\Delta t\\,\\mathcal{A}_{i,j} \\quad \\text{for all } (i,j) \\text{ where } |\\phi_{i,j}^n| \\le \\delta\n    $$\n    For cells outside the band, the value remains unchanged: $\\phi_{i,j}^{n+1} = \\phi_{i,j}^n$.\n\n5.  **Advance to Next Step**: The field for the next time step, $\\phi^{n+1}$, is set to the newly computed field $\\phi_{\\text{next}}$.\n\nThis iterative process is repeated for $N_t = 40$ steps.\n\n### 4. Performance Metrics\n\nAfter the final time step, the numerical solution $\\phi^{\\text{band}}(T)$ is compared against the exact analytical solution. For the initial condition $\\phi(x,y,0) = x$ and constant velocity $\\mathbf{v}=(v_x, 0)$, the exact solution is $\\phi_{\\text{exact}}(x,y,t) = x - v_x t$. At time $T=0.4$, this becomes:\n$$\n\\phi_{\\text{exact}}(x,y,T) = x - 0.5 \\times 0.4 = x - 0.2\n$$\n\nTwo metrics are computed for each test case defined by a different $\\delta$:\n\n1.  **Accuracy (RMSE)**: The Root-Mean-Square Error measures the deviation of the numerical solution from the exact one over the entire grid:\n    $$\n    \\mathrm{RMSE} = \\sqrt{\\frac{1}{N_x N_y}\\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1}\\left(\\phi_{i,j}^{\\text{band}}(T) - \\phi_{\\text{exact}}(x_i,y_j,T)\\right)^2}\n    $$\n\n2.  **Computational Cost**: This metric quantifies the efficiency of the narrow-band approach. It is the average fraction of grid cells updated per time step over the course of the simulation:\n    $$\n    \\mathrm{cost} = \\frac{1}{N_t N_x N_y} \\sum_{n=0}^{N_t-1} \\#\\{(i,j) : |\\phi_{i,j}^n| \\le \\delta\\}\n    $$\n\nThis entire procedure is executed for each of the four specified values of $\\delta$: $0$, $\\Delta x = 0.01$, $0.05$, and $2.0$. The case $\\delta=2.0$ effectively covers the entire domain since $|x| \\le 1$, thus representing a full-domain update with an expected cost of $1.0$. The case $\\delta=0$ is an extreme where only cells precisely on the zero contour are updated, which is expected to be computationally cheap but inaccurate as the interface moves off these grid points. The results provide insight into the trade-off between computational expense and solution accuracy in narrow-band methods.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the narrow-band level set advection problem for a set of test cases.\n    \"\"\"\n    \n    # ------------------\n    # Numerical Setup\n    # ------------------\n    Lx, Ly = 2.0, 2.0  # Domain size in meters\n    Nx, Ny = 201, 201    # Number of grid points\n    vx, vy = 0.5, 0.0    # Velocity in m/s\n    T_final = 0.4      # Final time in seconds\n    cfl_theta = 0.5    # CFL safety factor\n\n    # Grid spacing\n    dx = Lx / (Nx - 1)\n    dy = Ly / (Ny - 1)\n\n    # Time step from CFL condition\n    # Epsilon is only needed for non-zero vy, but to avoid division by zero if vx was 0\n    # we use a small number. Here vx is non-zero, so it is direct.\n    # The problem specifies vy=0, so the min() simplifies.\n    dt = cfl_theta * dx / abs(vx)\n    \n    # Number of time steps\n    Nt = math.ceil(T_final / dt)\n\n    # Grid coordinates\n    x = np.linspace(-Lx/2, Lx/2, Nx)\n    y = np.linspace(-Ly/2, Ly/2, Ny)\n    X, Y = np.meshgrid(x, y, indexing='ij') # Use 'ij' for matrix-style indexing\n\n    # Test cases for narrow-band half-width delta\n    test_cases = [\n        0.0,      # Case 1: Only zero level set\n        dx,       # Case 2: Band width of one grid cell\n        0.05,     # Case 3: Moderate band width\n        2.0       # Case 4: Full domain (max |phi| is 1.0)\n    ]\n\n    results = []\n    for delta in test_cases:\n        # ------------------\n        # Simulation for one delta\n        # ------------------\n\n        # Initialize level set field phi\n        phi = X.copy().T # Transpose X to match (j,i) loop expectations if needed, but 'ij' indexing handles this.\n                         # X is (Nx, Ny) with X[i,j] = x[i]. Correct for (i,j) indexing.\n        \n        total_active_cells = 0\n\n        # Time-stepping loop\n        for n in range(Nt):\n            # 1. Identify the narrow band\n            band_mask = np.abs(phi) = delta\n            total_active_cells += np.sum(band_mask)\n\n            # Create a copy for the next time step\n            phi_next = phi.copy()\n\n            # 2. Apply homogeneous Neumann boundary conditions via padding\n            phi_padded = np.pad(phi, pad_width=1, mode='edge')\n            \n            # Slices correspond to original grid within the padded grid\n            phi_i_j = phi_padded[1:-1, 1:-1]\n            phi_im1_j = phi_padded[:-2, 1:-1]\n            phi_ip1_j = phi_padded[2:, 1:-1]\n            phi_i_jm1 = phi_padded[1:-1, :-2]\n            phi_i_jp1 = phi_padded[1:-1, 2:]\n\n            Dx_minus = (phi_i_j - phi_im1_j) / dx\n            Dx_plus = (phi_ip1_j - phi_i_j) / dx\n            Dy_minus = (phi_i_j - phi_i_jm1) / dy\n            Dy_plus = (phi_i_jp1 - phi_i_j) / dy\n            \n            # 4. Compute discrete advection term\n            vx_pos = max(vx, 0.0)\n            vx_neg = min(vx, 0.0)\n            vy_pos = max(vy, 0.0)\n            vy_neg = min(vy, 0.0)\n            \n            adv_term = (vx_pos * Dx_minus + vx_neg * Dx_plus +\n                        vy_pos * Dy_minus + vy_neg * Dy_plus)\n\n            # 5. Update phi only inside the narrow band\n            phi_next[band_mask] = phi[band_mask] - dt * adv_term[band_mask]\n            \n            # 6. Advance to the next step\n            phi = phi_next\n\n        # ------------------\n        # Post-processing and Metrics\n        # ------------------\n        \n        # Exact solution at final time T\n        phi_exact = X.T - vx * T_final\n        \n        # RMSE calculation\n        rmse = np.sqrt(np.mean((phi - phi_exact)**2))\n        \n        # Computational cost calculation\n        cost = total_active_cells / (Nt * Nx * Ny)\n        \n        results.append([rmse, cost])\n\n    # Format output as required: [[e1,c1],[e2,c2],[e3,c3],[e4,c4]]\n    # using str() and replace() is a robust way to get the exact format\n    output_string = str(results).replace(\" \", \"\")\n\n    print(output_string)\n\nsolve()\n```", "id": "3577131"}, {"introduction": "A level set representation of a crack finds its true power when integrated into a mechanical analysis, such as the Finite Element Method (FEM). This advanced practice ([@problem_id:3577100]) tackles a core challenge at this interface: how to accurately compute integrals over elements that are physically split by the crack. By developing a systematic procedure to partition and integrate over these \"cut\" elements, you will implement a cornerstone of enriched approximation methods like the eXtended Finite Element Method (XFEM).", "problem": "You are asked to design and implement a robust numerical quadrature procedure for three-dimensional tetrahedral finite elements that are intersected by a crack surface represented implicitly by the zero level set of a scalar field. In level set methods for crack representation, the crack surface is modeled as the zero contour of a level set function. Consider a single tetrahedral element with vertices at positions $\\mathbf{v}_0,\\mathbf{v}_1,\\mathbf{v}_2,\\mathbf{v}_3 \\in \\mathbb{R}^3$, and a level set function $\\phi(\\mathbf{x})$ that is linear within the element. The zero level set $\\phi(\\mathbf{x})=0$ should be interpreted as the crack surface. The task is to compute integrals of a piecewise-smooth integrand that experiences a jump discontinuity across $\\{\\mathbf{x} \\mid \\phi(\\mathbf{x})=0\\}$.\n\nThe fundamental bases you must use include: the definition of the level set function and its role in representing interfaces, the linearity of $\\phi(\\mathbf{x})$ within a finite element when prescribed at the vertices, the construction of polyhedral partitions by cutting a convex set with a plane, and the formulation of quadrature rules for tetrahedra using barycentric coordinates. You must start from these foundations to design the procedure and derive the necessary formulas for edge intersection, polyhedron triangulation, and tetrahedral integration. You must not assume any specialized shortcut formulas beyond these basics and you must show how your quadrature rule is selected to exactly integrate polynomials of a given degree within each sub-tetrahedron.\n\nWithin each element, the integrand $f(\\mathbf{x})$ is defined piecewise as follows:\n- For $\\phi(\\mathbf{x})0$, $f(\\mathbf{x})=f^{+}(\\mathbf{x})$,\n- For $\\phi(\\mathbf{x})0$, $f(\\mathbf{x})=f^{-}(\\mathbf{x})$,\nwhere $f^{+}(\\mathbf{x})$ and $f^{-}(\\mathbf{x})$ are smooth polynomials within the element, and the jump is enforced by $f^{-}(\\mathbf{x})=f^{+}(\\mathbf{x}) + J$ with $J \\in \\mathbb{R}$ a constant jump magnitude.\n\nYour program must:\n1. For each tetrahedron, partition the element into two convex polyhedra given by the intersections of the tetrahedron with the half-spaces $\\{\\mathbf{x} \\mid \\phi(\\mathbf{x})\\ge 0\\}$ and $\\{\\mathbf{x} \\mid \\phi(\\mathbf{x})\\le 0\\}$. This requires computing the intersection points between the plane $\\phi(\\mathbf{x})=0$ and any tetrahedron edge whose endpoints have opposite signs of $\\phi$. You must derive and implement the edge intersection computation based on linear interpolation implied by the linearity of $\\phi$ within the element.\n2. Triangulate each convex polyhedron into a set of sub-tetrahedra such that their union equals the polyhedron and they are non-overlapping except possibly on boundaries of measure zero. You must design a general procedure applicable to both the triangular cut case (one vertex on one side and three on the other) and the quadrilateral cut case (two vertices on each side), as well as the no-cut case. Your approach must be derived from first principles of convex polyhedra and must produce a set of tetrahedra that cover the polyhedron in a scientifically sound manner.\n3. On each sub-tetrahedron, perform numerical quadrature using a tetrahedral integration rule that is exact for polynomials up to degree $2$ (second order) to ensure accuracy for quadratic integrands. The rule must be expressed via barycentric coordinates and appropriate weights and must be justified from first principles of polynomial exactness on simplices.\n4. Sum the contributions from sub-tetrahedra on the $\\phi0$ side using $f^{+}(\\mathbf{x})$ and from sub-tetrahedra on the $\\phi0$ side using $f^{-}(\\mathbf{x})$, thereby capturing the jump discontinuity across the crack surface.\n5. Produce the integral value of $f(\\mathbf{x})$ over the entire tetrahedron for each test case.\n\nThe mathematical setup is purely geometric and algebraic. Angles do not appear, so no angle unit is required. Physical units are not involved; all quantities are dimensionless. Your program must use the following test suite, which covers the general case, quadrilateral cut, no cut, and a near-degenerate cut close to a vertex. For all test cases, the integrand on the positive side is\n$$\nf^{+}(\\mathbf{x}) = a_0 + \\mathbf{a} \\cdot \\mathbf{x} + \\mathbf{x}^{\\top} \\mathbf{B} \\mathbf{x},\n$$\nwith $a_0 \\in \\mathbb{R}$, $\\mathbf{a} \\in \\mathbb{R}^3$, and $\\mathbf{B} \\in \\mathbb{R}^{3\\times 3}$ symmetric, and on the negative side $f^{-}(\\mathbf{x}) = f^{+}(\\mathbf{x}) + J$ with $J \\in \\mathbb{R}$.\n\nDefine the tetrahedral vertices for all test cases as\n$$\n\\mathbf{v}_0=(0,0,0),\\quad \\mathbf{v}_1=(1,0,0),\\quad \\mathbf{v}_2=(0,1,0),\\quad \\mathbf{v}_3=(0,0,1).\n$$\nFor each test case $k$, define $\\phi(\\mathbf{x}) = \\mathbf{n}^{(k)} \\cdot \\mathbf{x} - c^{(k)}$ where $\\mathbf{n}^{(k)} \\in \\mathbb{R}^3$ and $c^{(k)} \\in \\mathbb{R}$:\n\n- Test case 1 (triangular cut): $\\mathbf{n}^{(1)}=(1,1,1)$, $c^{(1)}=0.8$, $a_0=0$, $\\mathbf{a}=(0.2,-0.1,0.05)$, $\\mathbf{B}=\\mathrm{diag}(0.1,0.2,0.3)$, $J=1.0$.\n- Test case 2 (quadrilateral cut): $\\mathbf{n}^{(2)}=(1,1,0)$, $c^{(2)}=0.5$, $a_0=0$, $\\mathbf{a}=(0.2,-0.1,0.05)$, $\\mathbf{B}=\\mathrm{diag}(0.1,0.2,0.3)$, $J=1.0$.\n- Test case 3 (no cut, all positive): $\\mathbf{n}^{(3)}=(0,0,1)$, $c^{(3)}=-0.2$, $a_0=0$, $\\mathbf{a}=(0.2,-0.1,0.05)$, $\\mathbf{B}=\\mathrm{diag}(0.1,0.2,0.3)$, $J=1.0$.\n- Test case 4 (near-degenerate triangular cut): $\\mathbf{n}^{(4)}=(1,1,1)$, $c^{(4)}=1 - 10^{-12}$, $a_0=0$, $\\mathbf{a}=(0.2,-0.1,0.05)$, $\\mathbf{B}=\\mathrm{diag}(0.1,0.2,0.3)$, $J=1.0$.\n\nYour program must compute, for each test case, the integral\n$$\nI = \\int_{\\text{tet}} f(\\mathbf{x}) \\, \\mathrm{d}V = \\int_{\\phi(\\mathbf{x})0} f^{+}(\\mathbf{x}) \\, \\mathrm{d}V + \\int_{\\phi(\\mathbf{x})0} f^{-}(\\mathbf{x}) \\, \\mathrm{d}V,\n$$\nby partitioning the tetrahedron using the zero level set and applying sub-tetrahedral quadrature exact for degree $2$ polynomials. The final output must be a single line containing the results for the test cases as a comma-separated list enclosed in square brackets. For example, it should look like\n$[I_1,I_2,I_3,I_4]$,\nwhere $I_k$ is the floating-point integral value for test case $k$.\n\nYour program must be self-contained and runnable with no user input. It must adhere to the execution environment and library constraints specified. The output values must be printed with full precision as default floating-point string representations. The answer has no physical units; return raw numbers.", "solution": "The problem requires the design and implementation of a numerical quadrature procedure to compute the integral of a piecewise-defined function over a single tetrahedral element. The function exhibits a jump discontinuity across a planar surface implicitly defined by the zero level set of a linear function $\\phi(\\mathbf{x})$. The methodology is founded on the principles of computational geometry and numerical analysis, specifically by partitioning the domain of integration according to the sign of $\\phi(\\mathbf{x})$.\n\nThe value to be computed is the integral $I$:\n$$\nI = \\int_{T} f(\\mathbf{x}) \\, \\mathrm{d}V = \\int_{T \\cap \\{\\mathbf{x}|\\phi(\\mathbf{x})0\\}} f^{+}(\\mathbf{x}) \\, \\mathrm{d}V + \\int_{T \\cap \\{\\mathbf{x}|\\phi(\\mathbf{x})0\\}} f^{-}(\\mathbf{x}) \\, \\mathrm{d}V\n$$\nwhere $T$ is the tetrahedral element. The core strategy consists of four main steps: (1) determining the intersection of the plane $\\phi(\\mathbf{x})=0$ with the tetrahedron, (2) partitioning the tetrahedron into two polyhedra based on this intersection, (3) decomposing each polyhedron into a set of non-overlapping sub-tetrahedra, and (4) applying a suitable numerical quadrature rule to each sub-tetrahedron.\n\n**Step 1: Level Set Representation and Edge Intersection**\n\nA tetrahedron $T$ is defined by its four vertices, $\\mathbf{v}_0, \\mathbf{v}_1, \\mathbf{v}_2, \\mathbf{v}_3 \\in \\mathbb{R}^3$. The level set function $\\phi(\\mathbf{x})$ is linear within the element, which means its value at any point $\\mathbf{x}$ can be found by linear interpolation of its values at the vertices. Let $\\phi_i = \\phi(\\mathbf{v}_i)$ for $i \\in \\{0, 1, 2, 3\\}$.\n\nThe cutting plane $\\phi(\\mathbf{x})=0$ intersects the tetrahedron if and only if not all $\\phi_i$ have the same sign. The intersection points, if any, lie on the edges of the tetrahedron. Consider an edge connecting vertices $\\mathbf{v}_i$ and $\\mathbf{v}_j$. Any point $\\mathbf{p}$ on the line segment defined by this edge can be parameterized as $\\mathbf{p}(t) = (1-t)\\mathbf{v}_i + t\\mathbf{v}_j$ for $t \\in [0, 1]$. Due to the linearity of $\\phi$, its value at $\\mathbf{p}(t)$ is $\\phi(\\mathbf{p}(t)) = (1-t)\\phi_i + t\\phi_j$.\n\nThe intersection with the zero level set occurs where $\\phi(\\mathbf{p}(t)) = 0$. Solving for $t$ yields:\n$$\n(1-t)\\phi_i + t\\phi_j = 0 \\implies t\\phi_j - t\\phi_i = -\\phi_i \\implies t(\\phi_j - \\phi_i) = -\\phi_i\n$$\n$$\nt = \\frac{\\phi_i}{\\phi_i - \\phi_j}\n$$\nAn intersection point $\\mathbf{p}_{ij}$ exists within the edge segment (i.e., for $t \\in (0, 1)$) if and only if $\\phi_i$ and $\\phi_j$ have opposite signs. The location of the intersection point is then:\n$$\n\\mathbf{p}_{ij} = (1-t)\\mathbf{v}_i + t\\mathbf{v}_j = \\mathbf{v}_i + t(\\mathbf{v}_j - \\mathbf{v}_i)\n$$\n\n**Step 2: Partitioning the Tetrahedron**\n\nWe first classify the vertices into two sets based on the sign of the level set function: a positive set $V^+ = \\{\\mathbf{v}_i \\mid \\phi_i  0\\}$ and a negative set $V^- = \\{\\mathbf{v}_i \\mid \\phi_i \\le 0\\}$.\n- If either $V^+$ or $V^-$ is empty, the plane does not cut the tetrahedron. The entire element is on one side of the discontinuity, and the integral is computed over the original tetrahedron using either $f^+(\\mathbf{x})$ or $f^-(\\mathbf{x})$.\n- If both sets are non-empty, the plane cuts the tetrahedron. Two cases arise based on the number of vertices on each side:\n    1.  **Triangular Cut (1 vs. 3 vertices):** One vertex is in one set (e.g., $V^-$) and three are in the other ($V^+$). The plane intersects the three edges connecting the single vertex to the other three, forming a triangular intersection area on the plane. This partitions the tetrahedron into a smaller tetrahedron and a pentahedron (a truncated tetrahedron).\n    2.  **Quadrilateral Cut (2 vs. 2 vertices):** Two vertices are in $V^-$ and two are in $V^+$. The plane intersects the four edges connecting vertices from opposite sets, forming a quadrilateral intersection area. This partitions the tetrahedron into two wedge-like polyhedra.\n\n**Step 3: Triangulation of Convex Polyhedra**\n\nTo perform integration, each of the resulting convex polyhedra must be decomposed (triangulated) into a set of non-overlapping sub-tetrahedra. We establish a systematic decomposition for each case.\n\n**Case A: Triangular Cut (1 vs. 3)**\nLet vertex $\\mathbf{v}_d \\in V^-$ and vertices $\\mathbf{v}_a, \\mathbf{v}_b, \\mathbf{v}_c \\in V^+$. The plane intersects edges $(\\mathbf{v}_d, \\mathbf{v}_a)$, $(\\mathbf{v}_d, \\mathbf{v}_b)$, and $(\\mathbf{v}_d, \\mathbf{v}_c)$ at points $\\mathbf{p}_{da}$, $\\mathbf{p}_{db}$, and $\\mathbf{p}_{dc}$, respectively.\n- The negative polyhedron is the tetrahedron $T^- = (\\mathbf{v}_d, \\mathbf{p}_{da}, \\mathbf{p}_{db}, \\mathbf{p}_{dc})$.\n- The positive polyhedron (a pentahedron) is decomposed into three tetrahedra:\n    - $T^+_1 = (\\mathbf{v}_a, \\mathbf{p}_{da}, \\mathbf{p}_{db}, \\mathbf{p}_{dc})$\n    - $T^+_2 = (\\mathbf{v}_a, \\mathbf{v}_b, \\mathbf{p}_{db}, \\mathbf{p}_{dc})$\n    - $T^+_3 = (\\mathbf{v}_a, \\mathbf{v}_b, \\mathbf{v}_c, \\mathbf{p}_{dc})$\nThis decomposition is general and its volume correctly sums to the volume of the pentahedron.\n\n**Case B: Quadrilateral Cut (2 vs. 2)**\nLet vertices $\\mathbf{v}_a, \\mathbf{v}_b \\in V^-$ and $\\mathbf{v}_c, \\mathbf{v}_d \\in V^+$. The plane intersects edges $(\\mathbf{v}_a, \\mathbf{v}_c)$, $(\\mathbf{v}_a, \\mathbf{v}_d)$, $(\\mathbf{v}_b, \\mathbf{v}_c)$, and $(\\mathbf{v}_b, \\mathbf{v}_d)$ at points $\\mathbf{p}_{ac}$, $\\mathbf{p}_{ad}$, $\\mathbf{p}_{bc}$, and $\\mathbf{p}_{bd}$.\n- The negative polyhedron is decomposed into three tetrahedra:\n    - $T^-_1 = (\\mathbf{v}_a, \\mathbf{v}_b, \\mathbf{p}_{ac}, \\mathbf{p}_{ad})$\n    - $T^-_2 = (\\mathbf{v}_b, \\mathbf{p}_{ac}, \\mathbf{p}_{bc}, \\mathbf{p}_{ad})$\n    - $T^-_3 = (\\mathbf{v}_b, \\mathbf{p}_{bc}, \\mathbf{p}_{bd}, \\mathbf{p}_{ad})$\n- By symmetry, the positive polyhedron is decomposed into three tetrahedra:\n    - $T^+_1 = (\\mathbf{v}_c, \\mathbf{v}_d, \\mathbf{p}_{ac}, \\mathbf{p}_{bc})$\n    - $T^+_2 = (\\mathbf{v}_d, \\mathbf{p}_{ac}, \\mathbf{p}_{ad}, \\mathbf{p}_{bc})$\n    - $T^+_3 = (\\mathbf{v}_d, \\mathbf{p}_{ad}, \\mathbf{p}_{bd}, \\mathbf{p}_{bc})$\nThis robust decomposition covers the volume of each wedge-like polyhedron.\n\n**Step 4: Numerical Quadrature on Sub-Tetrahedra**\n\nThe integral of a function $g(\\mathbf{x})$ over a sub-tetrahedron $T_{sub}$ is approximated using a numerical quadrature rule:\n$$\n\\int_{T_{sub}} g(\\mathbf{x}) \\, \\mathrm{d}V \\approx V_{sub} \\sum_{q=1}^{N_q} w_q g(\\mathbf{x}_q)\n$$\nwhere $V_{sub}$ is the volume of the sub-tetrahedron, $\\mathbf{x}_q$ are the quadrature points, $w_q$ are the corresponding weights, and $N_q$ is the number of points. The volume of a tetrahedron with vertices $(\\mathbf{v}_w, \\mathbf{v}_x, \\mathbf{v}_y, \\mathbf{v}_z)$ is given by $V_{sub} = \\frac{1}{6} |\\det([\\mathbf{v}_x-\\mathbf{v}_w, \\mathbf{v}_y-\\mathbf{v}_w, \\mathbf{v}_z-\\mathbf{v}_w])|$.\n\nThe problem requires a rule that is exact for polynomials of degree $2$. A standard $4$-point rule satisfies this condition. The quadrature points are conveniently expressed in barycentric coordinates $(\\xi_0, \\xi_1, \\xi_2, \\xi_3)$ with respect to the sub-tetrahedron's vertices. The rule is defined by four points with the following barycentric coordinates and equal weights:\n- Point 1: $(\\alpha, \\beta, \\beta, \\beta)$\n- Point 2: $(\\beta, \\alpha, \\beta, \\beta)$\n- Point 3: $(\\beta, \\beta, \\alpha, \\beta)$\n- Point 4: $(\\beta, \\beta, \\beta, \\alpha)$\nwhere $\\alpha = \\frac{5+3\\sqrt{5}}{20}$ and $\\beta = \\frac{5-\\sqrt{5}}{20}$. Each point has a weight $w_q = 1/4$.\nThe Cartesian coordinates of a quadrature point $\\mathbf{x}_q$ for a sub-tetrahedron with vertices $(\\mathbf{v}_w, \\mathbf{v}_x, \\mathbf{v}_y, \\mathbf{v}_z)$ and corresponding barycentric coordinates $(\\xi_w, \\xi_x, \\xi_y, \\xi_z)$ are calculated as $\\mathbf{x}_q = \\xi_w \\mathbf{v}_w + \\xi_x \\mathbf{v}_x + \\xi_y \\mathbf{v}_y + \\xi_z \\mathbf{v}_z$.\n\n**Final Algorithm**\n\nThe complete integral $I$ is the sum of integrals over all sub-tetrahedra. For each sub-tetrahedron generated from the positive polyhedron, the integrand $f^+(\\mathbf{x})$ is used. For those from the negative polyhedron, $f^-(\\mathbf{x}) = f^+(\\mathbf{x}) + J$ is used. This procedure correctly accounts for the jump in the integrand across the crack surface. The final implementation will systematically apply these derived formulas to the provided test cases.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the integral of a piecewise polynomial function over a tetrahedral element\n    intersected by a planar crack surface defined by a level set function.\n    \"\"\"\n\n    # Define the fixed tetrahedral vertices for all test cases.\n    v = np.array([\n        [0.0, 0.0, 0.0],  # v0\n        [1.0, 0.0, 0.0],  # v1\n        [0.0, 1.0, 0.0],  # v2\n        [0.0, 0.0, 1.0]   # v3\n    ])\n\n    # Define the test cases.\n    test_cases = [\n        # case 1: triangular cut\n        {'n': np.array([1.0, 1.0, 1.0]), 'c': 0.8, 'a0': 0.0, 'a': np.array([0.2, -0.1, 0.05]), 'B': np.diag([0.1, 0.2, 0.3]), 'J': 1.0},\n        # case 2: quadrilateral cut\n        {'n': np.array([1.0, 1.0, 0.0]), 'c': 0.5, 'a0': 0.0, 'a': np.array([0.2, -0.1, 0.05]), 'B': np.diag([0.1, 0.2, 0.3]), 'J': 1.0},\n        # case 3: no cut, all positive\n        {'n': np.array([0.0, 0.0, 1.0]), 'c': -0.2, 'a0': 0.0, 'a': np.array([0.2, -0.1, 0.05]), 'B': np.diag([0.1, 0.2, 0.3]), 'J': 1.0},\n        # case 4: near-degenerate triangular cut\n        {'n': np.array([1.0, 1.0, 1.0]), 'c': 1.0 - 1e-12, 'a0': 0.0, 'a': np.array([0.2, -0.1, 0.05]), 'B': np.diag([0.1, 0.2, 0.3]), 'J': 1.0},\n    ]\n\n    # Barycentric coordinates and weights for the 4-point, 2nd-order quadrature rule.\n    alpha = (5.0 + 3.0 * np.sqrt(5.0)) / 20.0\n    beta = (5.0 - np.sqrt(5.0)) / 20.0\n    quad_bary_coords = np.array([\n        [alpha, beta,  beta,  beta],\n        [beta,  alpha, beta,  beta],\n        [beta,  beta,  alpha, beta],\n        [beta,  beta,  beta,  alpha]\n    ])\n    quad_weights = np.full(4, 1.0 / 4.0)\n\n    def integrate_tet(tet_vertices, integrand_func):\n        \"\"\"\n        Numerically integrates a given function over a single tetrahedron.\n        \"\"\"\n        v0, v1, v2, v3 = tet_vertices\n        \n        # Volume of the tetrahedron\n        mat = np.array([v1 - v0, v2 - v0, v3 - v0])\n        volume = np.abs(np.linalg.det(mat)) / 6.0\n        \n        if volume  1e-16: # Skip integration for degenerate tetrahedra.\n            return 0.0\n\n        integral = 0.0\n        for i in range(4):\n            bary_coords = quad_bary_coords[i]\n            # Convert barycentric to Cartesian coordinates\n            quad_point = bary_coords[0] * v0 + bary_coords[1] * v1 + \\\n                         bary_coords[2] * v2 + bary_coords[3] * v3\n            \n            # Evaluate integrand at the quadrature point\n            integrand_val = integrand_func(quad_point)\n            integral += quad_weights[i] * integrand_val\n        \n        return volume * integral\n\n    results = []\n    for case in test_cases:\n        n, c, a0, a, B, J = case['n'], case['c'], case['a0'], case['a'], case['B'], case['J']\n\n        def f_plus(x):\n            return a0 + np.dot(a, x) + x.T @ B @ x\n\n        def f_minus(x):\n            return f_plus(x) + J\n\n        phi_vals = np.array([np.dot(n, vi) - c for vi in v])\n        \n        pos_indices = [i for i, val in enumerate(phi_vals) if val  0]\n        neg_indices = [i for i, val in enumerate(phi_vals) if val = 0]\n\n        total_integral = 0.0\n\n        if not pos_indices:  # All vertices are negative\n            total_integral = integrate_tet(v, f_minus)\n        elif not neg_indices:  # All vertices are positive\n            total_integral = integrate_tet(v, f_plus)\n        else: # The element is cut\n            # Find intersection points\n            intersection_points = {}\n            edges = [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]\n            for i, j in edges:\n                if phi_vals[i] * phi_vals[j]  0:\n                    # Sort to ensure consistent keying\n                    i_sorted, j_sorted = sorted((i,j))\n                    phi_i, phi_j = phi_vals[i_sorted], phi_vals[j_sorted]\n                    t = phi_i / (phi_i - phi_j)\n                    p_ij = v[i_sorted] + t * (v[j_sorted] - v[i_sorted])\n                    intersection_points[(i_sorted, j_sorted)] = p_ij\n\n            positive_sub_tets = []\n            negative_sub_tets = []\n\n            if len(neg_indices) == 1 or len(pos_indices) == 1: # 1-vs-3 split\n                if len(neg_indices) == 1:\n                    d_idx = neg_indices[0]\n                    a_idx, b_idx, c_idx = pos_indices\n                else: # Symmetric case\n                    d_idx = pos_indices[0]\n                    a_idx, b_idx, c_idx = neg_indices\n                \n                v_d, v_a, v_b, v_c = v[d_idx], v[a_idx], v[b_idx], v[c_idx]\n                p_da = intersection_points[tuple(sorted((d_idx, a_idx)))]\n                p_db = intersection_points[tuple(sorted((d_idx, b_idx)))]\n                p_dc = intersection_points[tuple(sorted((d_idx, c_idx)))]\n                \n                # Polyhedron on the side of v_d\n                sub_tets_d = [(v_d, p_da, p_db, p_dc)]\n                # Polyhedron on the side of v_a,v_b,v_c\n                sub_tets_abc = [\n                    (v_a, p_da, p_db, p_dc),\n                    (v_a, v_b, p_db, p_dc),\n                    (v_a, v_b, v_c, p_dc)\n                ]\n\n                if phi_vals[d_idx] = 0:\n                    negative_sub_tets.extend(sub_tets_d)\n                    positive_sub_tets.extend(sub_tets_abc)\n                else:\n                    positive_sub_tets.extend(sub_tets_d)\n                    negative_sub_tets.extend(sub_tets_abc)\n\n            elif len(neg_indices) == 2 and len(pos_indices) == 2: # 2-vs-2 split\n                a_idx, b_idx = neg_indices\n                c_idx, d_idx = pos_indices\n                v_a, v_b = v[a_idx], v[b_idx]\n                v_c, v_d = v[c_idx], v[d_idx]\n\n                p_ac = intersection_points[tuple(sorted((a_idx, c_idx)))]\n                p_ad = intersection_points[tuple(sorted((a_idx, d_idx)))]\n                p_bc = intersection_points[tuple(sorted((b_idx, c_idx)))]\n                p_bd = intersection_points[tuple(sorted((b_idx, d_idx)))]\n\n                # Negative polyhedron triangulation\n                negative_sub_tets.extend([\n                    (v_a, v_b, p_ac, p_ad),\n                    (v_b, p_ac, p_bc, p_ad),\n                    (v_b, p_bc, p_bd, p_ad)\n                ])\n                # Positive polyhedron triangulation\n                positive_sub_tets.extend([\n                    (v_c, v_d, p_ac, p_bc),\n                    (v_d, p_ac, p_ad, p_bc),\n                    (v_d, p_ad, p_bd, p_bc)\n                ])\n\n            for tet in positive_sub_tets:\n                total_integral += integrate_tet(tet, f_plus)\n            for tet in negative_sub_tets:\n                total_integral += integrate_tet(tet, f_minus)\n\n        results.append(total_integral)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3577100"}]}