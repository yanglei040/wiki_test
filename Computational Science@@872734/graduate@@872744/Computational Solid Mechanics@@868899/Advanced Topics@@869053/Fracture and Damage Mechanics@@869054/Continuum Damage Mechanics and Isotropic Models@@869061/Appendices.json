{"hands_on_practices": [{"introduction": "We begin our hands-on journey by implementing the backbone of many computational models for inelastic materials: the return-mapping algorithm. This exercise [@problem_id:3554745] tasks you with constructing an implicit time-integration scheme for a classic rate-independent damage model from first principles. By translating the thermodynamic framework and Karush-Kuhn-Tucker (KKT) conditions into a robust predictor-corrector logic, you will develop a foundational skill for simulating material failure.", "problem": "You are asked to formulate and implement an implicit time integration algorithm for a one-dimensional isotropic rate-independent continuum damage model, then apply it to a set of prescribed strain histories. The algorithm must enforce the consistency condition at each time step and produce quantified outputs for a test suite of parameter sets.\n\nAssume a linear elastic base material characterized by modulus $E$ and a scalar isotropic damage variable $d \\in [0,1)$ that reduces the stiffness uniformly. The constitutive stress-strain relation is $ \\sigma = (1 - d) E \\varepsilon $. The Helmholtz free energy per unit volume is postulated as\n$$\n\\psi(\\varepsilon, d) = (1 - d)\\,\\frac{1}{2} E \\varepsilon^2 + \\frac{1}{2} H d^2,\n$$\nwhere $H$ is a positive scalar modulus that regularizes the damage evolution and provides a well-posed driving force. The thermodynamic force conjugate to the damage variable is the damage energy release rate\n$$\nY(\\varepsilon, d) = - \\frac{\\partial \\psi}{\\partial d} = \\frac{1}{2} E \\varepsilon^2 - H d.\n$$\nRate-independent damage activation is controlled by a threshold $Y_0  0$ through the yield function\n$$\nf(\\varepsilon, d) = Y(\\varepsilon, d) - Y_0,\n$$\nenforced with the Karush-Kuhn-Tucker (KKT) conditions\n$$\n\\dot{d} \\ge 0,\\quad f(\\varepsilon, d) \\le 0,\\quad \\dot{d}\\, f(\\varepsilon, d) = 0.\n$$\nAt each discrete time step $t_{n+1}$, given the previous damage $d_n$ and the prescribed strain $\\varepsilon_{n+1}$, construct an implicit update for $d_{n+1}$ that enforces the consistency condition when the damage mechanism is active. Begin from these fundamental definitions and laws and derive the algorithm that decides whether damage grows or stays constant based on $f(\\varepsilon_{n+1}, d_n)$, and, when active, enforces the consistency condition at $t_{n+1}$ so that the updated state satisfies the appropriate constraint. Use the constitutive stress relation $ \\sigma_{n+1} = (1 - d_{n+1}) E \\varepsilon_{n+1} $ to compute the stress response.\n\nNumerical implementation requirements:\n- Use a small non-negative tolerance $\\tau$ (e.g., $\\tau = 10^{-12}$ in Pascals) for inequality checks in the KKT conditions to account for floating-point round-off.\n- Impose a cap $d_{\\max} = 0.999$ to avoid singular stiffness in the numerical update and enforce $d_{n+1} \\in [0, d_{\\max}]$.\n- Enforce the irreversibility constraint $d_{n+1} \\ge d_n$.\n- Regardless of loading or unloading, the algorithm must be implicit in the sense that all updated quantities are computed at $t_{n+1}$.\n\nPhysical units and output specification:\n- All moduli $E$, $H$, threshold $Y_0$, and stresses $\\sigma$ must be treated and reported in Pascals.\n- Strain $\\varepsilon$ is dimensionless.\n- The program must report, for each test case, a list containing three values: the final damage $d_{\\text{end}}$ (dimensionless), the final stress $\\sigma_{\\text{end}}$ in Pascals, and the integer count of the number of time steps at which the consistency condition was active (i.e., damage was updated under the enforced constraint).\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[ \\text{result}_1, \\text{result}_2, \\text{result}_3 ]$), where each $\\text{result}_i$ is itself a list $[ d_{\\text{end}}, \\sigma_{\\text{end}}, \\text{active\\_count} ]$ for the corresponding test case.\n\nTest suite:\n- Case $1$ (increasing strain, activation occurs):\n  - $E = 200 \\times 10^{9}\\ \\text{Pa}$, $H = 10^{4}\\ \\text{Pa}$, $Y_0 = 800\\ \\text{Pa}$, $d_0 = 0.0$, strain sequence $\\{ \\varepsilon_k \\} = [\\, 0.0,\\ 8 \\times 10^{-5},\\ 1 \\times 10^{-4},\\ 1.2 \\times 10^{-4},\\ 2 \\times 10^{-4} \\,]$.\n- Case $2$ (boundary threshold and slight unloading):\n  - $E = 70 \\times 10^{9}\\ \\text{Pa}$, $H = 2 \\times 10^{4}\\ \\text{Pa}$, $Y_0 = 350\\ \\text{Pa}$, $d_0 = 0.0$, strain sequence $\\{ \\varepsilon_k \\} = [\\, 5 \\times 10^{-5},\\ 1 \\times 10^{-4},\\ 9 \\times 10^{-5} \\,]$.\n- Case $3$ (rapid saturation due to small $H$):\n  - $E = 30 \\times 10^{9}\\ \\text{Pa}$, $H = 500\\ \\text{Pa}$, $Y_0 = 100\\ \\text{Pa}$, $d_0 = 0.0$, strain sequence $\\{ \\varepsilon_k \\} = [\\, 2 \\times 10^{-4},\\ 3 \\times 10^{-4},\\ 5 \\times 10^{-4} \\,]$.\n- Case $4$ (loading then unloading):\n  - $E = 100 \\times 10^{9}\\ \\text{Pa}$, $H = 10^{4}\\ \\text{Pa}$, $Y_0 = 1000\\ \\text{Pa}$, $d_0 = 0.0$, strain sequence $\\{ \\varepsilon_k \\} = [\\, 1.5 \\times 10^{-4},\\ 2 \\times 10^{-4},\\ 1 \\times 10^{-4} \\,]$.\n\nYour program must implement the implicit algorithm derived from the fundamental definitions and output the aggregated list of $[ d_{\\text{end}}, \\sigma_{\\text{end}}, \\text{active\\_count} ]$ for these four cases on a single line, in the exact format specified above, with stresses in Pascals and damage dimensionless.", "solution": "The problem statement is evaluated as valid. It is scientifically grounded in the principles of continuum damage mechanics, internally consistent, and provides all necessary data and constraints to formulate a unique and meaningful solution. The problem is a standard exercise in computational solid mechanics, requiring the derivation and implementation of a return mapping algorithm for a rate-independent material model.\n\nThe core of the problem is to devise a time-discrete update rule for the scalar damage variable, $d$, at a time step $t_{n+1}$, given the state at the previous step, $t_n$, and a prescribed strain, $\\varepsilon_{n+1}$. The update must be consistent with the principles of rate-independent irreversible thermodynamics, as specified by the Karush-Kuhn-Tucker (KKT) conditions.\n\nThe state of the system is described by the strain $\\varepsilon$ and the internal damage variable $d$. The model is defined by the following equations:\nThe Helmholtz free energy density:\n$$\n\\psi(\\varepsilon, d) = (1 - d)\\,\\frac{1}{2} E \\varepsilon^2 + \\frac{1}{2} H d^2\n$$\nThe constitutive law for stress:\n$$\n\\sigma = \\frac{\\partial \\psi}{\\partial \\varepsilon} = (1 - d) E \\varepsilon\n$$\nThe thermodynamic force conjugate to damage, known as the damage energy release rate:\n$$\nY = - \\frac{\\partial \\psi}{\\partial d} = \\frac{1}{2} E \\varepsilon^2 - H d\n$$\nDamage evolution is governed by the yield function $f$ and a set of KKT conditions:\n$$\nf(Y) = Y - Y_0 \\le 0\n$$\n$$\n\\dot{d} \\ge 0 \\quad (\\text{Irreversibility})\n$$\n$$\n\\dot{d} f(Y) = 0 \\quad (\\text{Consistency})\n$$\nThese conditions define an elastic domain where $f  0$ and $\\dot{d}=0$, and a loading condition where $f=0$ and $\\dot{d} \\ge 0$.\n\nFor numerical implementation, we discretize in time. Given the state $d_n$ at time $t_n$ and the prescribed strain $\\varepsilon_{n+1}$ at time $t_{n+1}$, we seek to find $d_{n+1}$ and $\\sigma_{n+1}$. The algorithm structure follows a standard elastic predictor/damage corrector scheme, which is implicit as it enforces the conditions at the end of the step, $t_{n+1}$.\n\n**Step 1: Elastic Predictor**\nFirst, we make a trial assumption that the step is purely elastic, meaning there is no evolution of damage.\n$$\nd_{n+1}^{\\text{trial}} = d_n\n$$\n\n**Step 2: Check for Damage Activation**\nWe evaluate the yield function at the trial state, using the known strain $\\varepsilon_{n+1}$ and the trial damage $d_{n+1}^{\\text{trial}}$. Let's define the trial damage energy release rate as:\n$$\nY^{\\text{trial}} = Y(\\varepsilon_{n+1}, d_{n+1}^{\\text{trial}}) = \\frac{1}{2} E \\varepsilon_{n+1}^2 - H d_n\n$$\nThe trial yield function is then:\n$$\nf^{\\text{trial}} = Y^{\\text{trial}} - Y_0 = \\frac{1}{2} E \\varepsilon_{n+1}^2 - H d_n - Y_0\n$$\nWe now check this value against the elastic domain requirement, accounting for a small numerical tolerance $\\tau  0$:\n- If $f^{\\text{trial}} \\le \\tau$, the trial state is admissible. The elastic assumption holds, and no damage evolution occurs. The KKT conditions are satisfied with $\\dot{d}=0$ (or more accurately, $\\Delta d = d_{n+1} - d_n = 0$). Thus, we accept the trial state:\n  $$\n  d_{n+1} = d_n\n  $$\n- If $f^{\\text{trial}}  \\tau$, the trial state is inadmissible as it lies outside the elastic domain. This indicates that damage must occur during the step. The KKT conditions require that the system state returns to the yield surface. This is the **consistency condition**, which must be enforced at the end of the step $t_{n+1}$:\n  $$\n  f(\\varepsilon_{n+1}, d_{n+1}) = 0\n  $$\n\n**Step 3: Damage Corrector**\nWhen the consistency condition is active, we solve for the updated damage value, $d_{n+1}$.\n$$\nf(\\varepsilon_{n+1}, d_{n+1}) = Y(\\varepsilon_{n+1}, d_{n+1}) - Y_0 = 0\n$$\nSubstituting the definition of $Y$:\n$$\n\\frac{1}{2} E \\varepsilon_{n+1}^2 - H d_{n+1} - Y_0 = 0\n$$\nSolving this linear equation for $d_{n+1}$ gives the updated damage:\n$$\nd_{n+1} = \\frac{1}{H} \\left( \\frac{1}{2} E \\varepsilon_{n+1}^2 - Y_0 \\right)\n$$\nThis is the \"return mapping\" part of the algorithm, as it maps the inadmissible trial state back to the yield surface.\n\n**Step 4: Enforcement of Constraints**\nThe problem specifies two additional constraints on the damage variable: irreversibility and a maximum value.\n- **Irreversibility**: Damage can only increase or stay constant, so $d_{n+1} \\ge d_n$.\n- **Saturation**: Damage cannot reach $1$, so a numerical cap is imposed: $d_{n+1} \\le d_{\\max}$.\n\nWhen the damage corrector is applied, the calculated value of $d_{n+1}$ must respect these constraints. We can combine the update into a single expression. Let $d_{\\text{candidate}}$ be the value from the consistency condition:\n$$\nd_{\\text{candidate}} = \\frac{1}{H} \\left( \\frac{1}{2} E \\varepsilon_{n+1}^2 - Y_0 \\right)\n$$\nThe final value for $d_{n+1}$ is then obtained by ensuring it is not less than the previous value, $d_n$, and not greater than the cap, $d_{\\max}$. Note that if the corrector step is active ($f^{\\text{trial}}  0$), then $d_{\\text{candidate}} - d_n = \\frac{1}{H}(\\frac{1}{2} E \\varepsilon_{n+1}^2 - Y_0 - H d_n) = \\frac{1}{H}f^{\\text{trial}}  0$, so $d_{\\text{candidate}}  d_n$ is automatically satisfied. The irreversibility constraint $d_{n+1} \\ge d_n$ is thus inherently fulfilled by the logic of the return mapping. The only constraint to enforce explicitly in this case is the cap.\n\nThe complete algorithmic update for $d_{n+1}$ is:\n1.  Calculate $f^{\\text{trial}} = \\frac{1}{2} E \\varepsilon_{n+1}^2 - H d_n - Y_0$.\n2.  If $f^{\\text{trial}} \\le \\tau$:\n    $d_{n+1} = d_n$.\n3.  Else (if $f^{\\text{trial}}  \\tau$):\n    $d_{\\text{candidate}} = \\frac{1}{H} \\left( \\frac{1}{2} E \\varepsilon_{n+1}^2 - Y_0 \\right)$.\n    $d_{n+1} = \\min(d_{\\text{candidate}}, d_{\\max})$.\n\nThis algorithm implicitly maintains the irreversibility constraint. The case where $f^{\\text{trial}}  \\tau$ corresponds to an active consistency condition, so we increment a counter for such steps.\n\n**Step 5: Stress Update**\nOnce the final damage value $d_{n+1}$ is determined for the step, the stress at time $t_{n+1}$ is calculated using the constitutive law:\n$$\n\\sigma_{n+1} = (1 - d_{n+1}) E \\varepsilon_{n+1}\n$$\n\nThis procedure is repeated for each step in the prescribed strain history to find the final damage $d_{\\text{end}}$, final stress $\\sigma_{\\text{end}}$, and the total count of active damage steps.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the continuum damage mechanics problem for a suite of test cases.\n    \"\"\"\n\n    # Numerical parameters specified in the problem statement.\n    tolerance = 1e-12  # Small tolerance for inequality checks.\n    d_max = 0.999      # Maximum allowable damage value.\n\n    # Test suite defined in the problem statement.\n    test_cases = [\n        # Case 1 (increasing strain, activation occurs)\n        {\n            \"E\": 200e9, \"H\": 1e4, \"Y0\": 800, \"d0\": 0.0,\n            \"strains\": [0.0, 8e-5, 1e-4, 1.2e-4, 2e-4]\n        },\n        # Case 2 (boundary threshold and slight unloading)\n        {\n            \"E\": 70e9, \"H\": 2e4, \"Y0\": 350, \"d0\": 0.0,\n            \"strains\": [5e-5, 1e-4, 9e-5]\n        },\n        # Case 3 (rapid saturation due to small H)\n        {\n            \"E\": 30e9, \"H\": 500, \"Y0\": 100, \"d0\": 0.0,\n            \"strains\": [2e-4, 3e-4, 5e-4]\n        },\n        # Case 4 (loading then unloading)\n        {\n            \"E\": 100e9, \"H\": 1e4, \"Y0\": 1000, \"d0\": 0.0,\n            \"strains\": [1.5e-4, 2e-4, 1e-4]\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        E = case[\"E\"]\n        H = case[\"H\"]\n        Y0 = case[\"Y0\"]\n        \n        d_n = case[\"d0\"]\n        strains = case[\"strains\"]\n        \n        active_count = 0\n\n        # Iterate through the prescribed strain history.\n        for eps_np1 in strains:\n            # Calculate the trial yield function value.\n            # f_trial = Y_trial - Y0 = (0.5 * E * eps_np1^2 - H * d_n) - Y0\n            f_trial = 0.5 * E * eps_np1**2 - H * d_n - Y0\n\n            # Elastic predictor/damage corrector logic\n            if f_trial = tolerance:\n                # Elastic step: damage does not evolve.\n                d_np1 = d_n\n            else:\n                # Damage step: enforce consistency condition f(eps_{n+1}, d_{n+1}) = 0.\n                active_count += 1\n                \n                # Solve for d_{n+1} from the consistency condition:\n                # 0.5 * E * eps_{n+1}^2 - H * d_{n+1} - Y0 = 0\n                d_candidate = (0.5 * E * eps_np1**2 - Y0) / H\n                \n                # Enforce the maximum damage constraint. The irreversibility\n                # d_{n+1} >= d_n is naturally satisfied since f_trial > 0 implies\n                # d_candidate > d_n.\n                d_np1 = min(d_candidate, d_max)\n\n            # Update the damage variable for the next step.\n            d_n = d_np1\n            \n        # After the loop, d_n holds the final damage value.\n        d_end = d_n\n        \n        # Calculate the final stress using the final strain and final damage.\n        eps_end = strains[-1] if strains else 0.0\n        sigma_end = (1 - d_end) * E * eps_end\n        \n        results.append([d_end, sigma_end, active_count])\n\n    # Format the output as a single-line string representation of a list of lists.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3554745"}, {"introduction": "Having implemented a basic return-mapping algorithm, we now turn to a critical aspect of robust numerical simulation: handling floating-point comparisons. In this practice [@problem_id:3554716], you will explore the sensitivity of an operator-split update scheme to finite-precision arithmetic, particularly near the damage activation threshold where the history variable update $\\kappa_{n+1} = \\max(\\kappa_n, \\tilde{\\kappa}(\\varepsilon_{n+1}))$ is ambiguous. By comparing a naive update with a tolerance-aware, robust rule, you will gain insight into preventing numerical artifacts and ensuring the physical consistency of your simulations.", "problem": "Consider a scalar, one-dimensional, isotropic damage model integrated in time by operator splitting. The kinematics is characterized by the small strain variable $\\,\\varepsilon\\,$, the scalar internal history variable $\\,\\kappa\\,$ that must be monotonically nondecreasing, and the scalar damage variable $\\,d\\in[0,1)\\,$. The free energy density is assumed to be\n$$\n\\psi(\\varepsilon,d) = \\tfrac{1}{2}\\,(1-d)\\,E\\,\\varepsilon^2,\n$$\nwhere $\\,E\\,$ is the Young’s modulus. The thermodynamic force conjugate to $\\,d\\,$ is the energy release rate\n$$\nY(\\varepsilon) = -\\frac{\\partial \\psi}{\\partial d} = \\tfrac{1}{2}\\,E\\,\\varepsilon^2 \\ge 0.\n$$\nDamage is driven by a monotonically nondecreasing history variable $\\,\\kappa\\,$ through a constitutive map $\\,d=g(\\kappa)\\,$. Let\n$$\nd(\\kappa) = 1 - \\exp\\!\\Big(-\\big(\\tfrac{\\kappa}{\\kappa_0}\\big)^{m}\\Big),\n$$\nwith parameters $\\,\\kappa_00\\,$ and $\\,m\\ge 1\\,$. The Cauchy stress in one dimension is\n$$\n\\sigma(\\varepsilon,\\kappa) = (1 - d(\\kappa))\\,E\\,\\varepsilon.\n$$\nThe history update is posed as the unilateral constraint\n$$\n\\kappa_{n+1} = \\max\\big(\\kappa_{n},\\,\\tilde{\\kappa}(\\varepsilon_{n+1})\\big), \\quad \\text{with} \\quad \\tilde{\\kappa}(\\varepsilon) = |\\varepsilon|.\n$$\nThis realizes the discrete form of the complementarity (Kuhn–Tucker (KT)) conditions for damage initiation and evolution: $\\,\\tilde{\\kappa}(\\varepsilon_{n+1}) - \\kappa_{n+1} \\le 0\\,$, $\\,\\kappa_{n+1} - \\kappa_{n} \\ge 0\\,$, and $\\,(\\kappa_{n+1}-\\kappa_{n})\\big(\\tilde{\\kappa}(\\varepsilon_{n+1}) - \\kappa_{n+1}\\big)=0\\,$. Near peak strength, floating-point round-off can make $\\,\\tilde{\\kappa}(\\varepsilon_{n+1})\\,$ numerically indistinguishable from $\\,\\kappa_n\\,$, which can cause inconsistent branching decisions unless robust tie-breaking rules are used.\n\nStarting from these principles and definitions only (no other formulas may be assumed), implement two discrete time-stepping updates for a single increment $\\,n\\to n+1\\,$:\n\n- A naive update using the exact maximum,\n$$\n\\kappa_{n+1}^{\\text{naive}} = \\max\\big(\\kappa_n,\\,\\tilde{\\kappa}(\\varepsilon_{n+1})\\big).\n$$\n\n- A robust update that replaces the exact comparison by a tolerance-aware tie-breaking rule: for user-specified $\\,a_{\\mathrm{tol}}\\ge 0\\,$ and $\\,r_{\\mathrm{tol}}\\ge 0\\,$, define\n$$\n\\mathrm{tol}(\\kappa_n,\\tilde{\\kappa}) = a_{\\mathrm{tol}} + r_{\\mathrm{tol}}\\,\\max\\big(|\\kappa_n|,\\,|\\tilde{\\kappa}|\\big).\n$$\nThen set\n$$\n\\kappa_{n+1}^{\\text{rob}} =\n\\begin{cases}\n\\tilde{\\kappa},  \\text{if } \\tilde{\\kappa} \\ge \\kappa_n + \\mathrm{tol},\\\\\n\\kappa_n,  \\text{if } \\tilde{\\kappa} \\le \\kappa_n - \\mathrm{tol},\\\\\n\\kappa_n,  \\text{otherwise (tie region).}\n\\end{cases}\n$$\nThis tie-breaking prefers sticking in the ambiguous band to avoid chatter while preserving monotonicity. Enforce the monotonicity clamp $\\,\\kappa_{n+1}^{\\text{rob}} \\leftarrow \\max(\\kappa_n,\\kappa_{n+1}^{\\text{rob}})\\,$ to guarantee $\\,\\kappa\\,$ does not decrease.\n\nFor each update rule, compute at step $\\,n+1\\,$ the stress $\\,\\sigma_{n+1}\\,$ and the discrete damage dissipation increment\n$$\n\\Delta \\mathcal{D} \\approx Y_{n+\\theta}\\,\\Delta d, \\quad \\Delta d = d(\\kappa_{n+1})-d(\\kappa_n), \\quad Y_{n+\\theta} = \\tfrac{1}{2}\\,E\\,\\varepsilon_{n+1}^2,\n$$\nwith $\\,\\theta=\\tfrac{1}{1}\\,$ (midpoint is not required here; take $\\,Y\\,$ evaluated at $\\,n+1\\,$ for a conservative nonnegativity check since $\\,Y\\ge 0\\,$ and $\\,\\Delta d\\ge 0\\,$ should imply $\\,\\Delta \\mathcal{D}\\ge 0\\,$). Verify $\\,\\Delta d \\ge 0\\,$ numerically to within a damage tolerance $\\,t_{\\mathrm{diss}}\\,$ by checking $\\,\\Delta d \\ge -t_{\\mathrm{diss}}\\,$.\n\nPeak strength sensitivity. For the given $\\,d(\\kappa)\\,$ and $\\,\\kappa=\\tilde{\\kappa}(\\varepsilon)=|\\varepsilon|\\,$ under monotone tension, the stress–strain relation reads\n$$\n\\sigma(\\varepsilon) = E\\,\\varepsilon\\,\\exp\\!\\Big(-\\big(\\tfrac{\\varepsilon}{\\kappa_0}\\big)^m\\Big),\n$$\nwhose peak occurs at\n$$\n\\varepsilon_{\\mathrm{p}} = \\kappa_0\\,m^{-1/m}.\n$$\nProvide a numerical study that includes cases with $\\,\\varepsilon_{n+1}\\,$ very close to $\\,\\varepsilon_{\\mathrm{p}}\\,$ so that floating-point round-off may flip the comparison outcome. Quantify the effect by reporting the discrete stress increment $\\,\\Delta \\sigma = \\sigma_{n+1}-\\sigma_{n}\\,$ for both update rules.\n\nImplementation requirements.\n\n- Use the operator-split algorithm: given $\\,(\\varepsilon_n,\\kappa_n)\\,$, compute $\\,\\tilde{\\kappa}(\\varepsilon_{n+1})\\,$, update $\\,\\kappa_{n+1}\\,$ with each rule, then compute $\\,d_{n+1}=d(\\kappa_{n+1})\\,$ and $\\,\\sigma_{n+1}\\,$.\n- Use the material parameters $\\,E=\\,$$\\,2.10\\times 10^{5}\\,$ pascals, $\\,\\kappa_0=\\,$$\\,2.0\\times 10^{-2}\\,$, and $\\,m=\\,$$\\,2.0\\,$.\n- Use the robust tolerances $\\,a_{\\mathrm{tol}}=\\,$$\\,1.0\\times 10^{-12}\\,$, $\\,r_{\\mathrm{tol}}=\\,$$\\,1.0\\times 10^{-8}\\,$, and damage positivity tolerance $\\,t_{\\mathrm{diss}}=\\,$$\\,1.0\\times 10^{-14}\\,$.\n- Treat strain as dimensionless and all stresses to be expressed in pascals; report $\\,\\Delta \\sigma\\,$ in pascals without any units in the output.\n\nTest suite. For each case $\\,i\\,$, the input is $\\,(\\varepsilon_n^{(i)},\\kappa_n^{(i)},\\varepsilon_{n+1}^{(i)})\\,$ and the outputs to be produced are\n$$\n\\big[\\kappa_{n+1}^{\\text{naive}},\\ \\kappa_{n+1}^{\\text{rob}},\\ \\Delta \\sigma^{\\text{naive}},\\ \\Delta \\sigma^{\\text{rob}},\\ \\mathrm{mon}^{\\text{naive}},\\ \\mathrm{mon}^{\\text{rob}},\\ \\mathrm{diss}^{\\text{naive}},\\ \\mathrm{diss}^{\\text{rob}}\\big],\n$$\nwhere $\\,\\mathrm{mon}\\,$ and $\\,\\mathrm{diss}\\,$ are boolean flags for monotonicity ($\\,\\kappa_{n+1}\\ge \\kappa_n\\,$) and discrete damage positivity ($\\,\\Delta d \\ge -t_{\\mathrm{diss}}\\,$). Use the following cases:\n\n- Case $\\,1\\,$ (happy path, clear increase): $\\ \\varepsilon_n=\\,$$\\,1.0\\times 10^{-2}\\,$, $\\ \\kappa_n=\\,$$\\,1.0\\times 10^{-2}\\,$, $\\ \\varepsilon_{n+1}=\\,$$\\,1.2\\times 10^{-2}\\,$.\n- Case $\\,2\\,$ (near peak, tiny upward difference below tolerance): Let $\\,\\varepsilon_{\\mathrm{p}}=\\kappa_0\\,m^{-1/m}\\,$. Use $\\ \\varepsilon_n=\\,$$\\,1.414213561\\times 10^{-2}\\,$, $\\ \\kappa_n=\\varepsilon_n\\,$, $\\ \\varepsilon_{n+1}=\\,$$\\,1.414213563\\times 10^{-2}\\,$.\n- Case $\\,3\\,$ (near peak, tiny downward difference): $\\ \\varepsilon_n=\\,$$\\,1.414213563\\times 10^{-2}\\,$, $\\ \\kappa_n=\\varepsilon_n\\,$, $\\ \\varepsilon_{n+1}=\\,$$\\,1.414213561\\times 10^{-2}\\,$.\n- Case $\\,4\\,$ (edge, near zero): $\\ \\varepsilon_n=\\,$$\\,0.0\\,$, $\\ \\kappa_n=\\,$$\\,0.0\\,$, $\\ \\varepsilon_{n+1}=\\,$$\\,1.0\\times 10^{-16}\\,$.\n- Case $\\,5\\,$ (large magnitude, relative tolerance dominant): $\\ \\varepsilon_n=\\,$$\\,1.0\\,$, $\\ \\kappa_n=\\,$$\\,1.0\\,$, $\\ \\varepsilon_{n+1}=\\,$$\\,1.000000005\\,$.\n- Case $\\,6\\,$ (strong increase): $\\ \\varepsilon_n=\\,$$\\,5.0\\times 10^{-1}\\,$, $\\ \\kappa_n=\\,$$\\,5.0\\times 10^{-1}\\,$, $\\ \\varepsilon_{n+1}=\\,$$\\,6.0\\times 10^{-1}\\,$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list of eight entries as ordered above. For example, the output should look like\n$$\n[\\,[\\cdots 8\\ \\text{entries}\\cdots],[\\cdots],[\\cdots],[\\cdots],[\\cdots],[\\cdots]\\,].\n$$\nAll stresses must be expressed in pascals and all booleans must appear as programming-language boolean literals.", "solution": "The problem is well-posed and scientifically grounded. It presents a standard problem in computational damage mechanics, providing all necessary constitutive equations, parameters, and algorithms to perform a numerical study on the robustness of history variable updates. All provided information is self-contained and consistent.\n\nThe task is to implement and compare two different update schemes for the scalar history variable $\\kappa$ in a one-dimensional isotropic damage model. The model is defined within the framework of continuum mechanics, using an operator-split approach for the time integration of the internal variables.\n\nThe state of the material at time step $n$ is described by the strain $\\varepsilon_n$ and the history variable $\\kappa_n$. The history variable $\\kappa$ is a measure of the maximum strain magnitude experienced by the material and is constitutively required to be monotonically nondecreasing, i.e., $\\kappa_{n+1} \\ge \\kappa_n$.\n\nThe core constitutive relations are:\nThe Helmholtz free energy density, $\\psi$, is given by:\n$$\n\\psi(\\varepsilon, d) = \\tfrac{1}{2}\\,(1-d)\\,E\\,\\varepsilon^2\n$$\nwhere $E$ is the Young's modulus and $d$ is the scalar damage variable, $d \\in [0, 1)$.\n\nThe damage variable $d$ is a function of the history variable $\\kappa$:\n$$\nd(\\kappa) = 1 - \\exp\\!\\Big(-\\big(\\tfrac{\\kappa}{\\kappa_0}\\big)^{m}\\Big)\n$$\nwith material parameters $\\kappa_0  0$ and $m \\ge 1$.\n\nThe Cauchy stress $\\sigma$ is derived from the free energy as $\\sigma = \\frac{\\partial \\psi}{\\partial \\varepsilon}$:\n$$\n\\sigma(\\varepsilon, \\kappa) = (1 - d(\\kappa))\\,E\\,\\varepsilon = E\\,\\varepsilon\\,\\exp\\!\\Big(-\\big(\\tfrac{\\kappa}{\\kappa_0}\\big)^{m}\\Big)\n$$\n\nThe evolution of damage is governed by the update of $\\kappa$. A trial value for the history variable at step $n+1$ is defined based on the new strain $\\varepsilon_{n+1}$:\n$$\n\\tilde{\\kappa}(\\varepsilon_{n+1}) = |\\varepsilon_{n+1}|\n$$\nThis trial value is then used to update $\\kappa$ from its value at the previous step, $\\kappa_n$. The evolution must satisfy the Kuhn-Tucker conditions, which discretely imply $\\kappa_{n+1} = \\max(\\kappa_n, \\tilde{\\kappa}(\\varepsilon_{n+1}))$. The problem requires a comparison of a naive implementation of this update with a robust, tolerance-based version.\n\nThe algorithmic procedure for a single time increment from $n$ to $n+1$ is as follows:\n1.  Given the state $(\\varepsilon_n, \\kappa_n)$ and the new strain $\\varepsilon_{n+1}$.\n2.  Calculate the stress at the beginning of the increment: $\\sigma_n = \\sigma(\\varepsilon_n, \\kappa_n)$.\n3.  Calculate the trial history variable: $\\tilde{\\kappa}_{n+1} = |\\varepsilon_{n+1}|$.\n4.  Update the history variable to $\\kappa_{n+1}$ using two distinct rules:\n\n    a.  **Naive Update Rule**: This rule directly implements the `max` function, which is susceptible to floating-point errors when $\\tilde{\\kappa}_{n+1}$ is very close to $\\kappa_n$.\n        $$\n        \\kappa_{n+1}^{\\text{naive}} = \\max(\\kappa_n, \\tilde{\\kappa}_{n+1})\n        $$\n\n    b.  **Robust Update Rule**: This rule introduces a tolerance band around $\\kappa_n$ to handle ambiguous cases where $\\tilde{\\kappa}_{n+1} \\approx \\kappa_n$. It prevents damage evolution if the trial value is not sufficiently larger than the current history value. The tolerance is defined as:\n        $$\n        \\mathrm{tol} = a_{\\mathrm{tol}} + r_{\\mathrm{tol}}\\,\\max(|\\kappa_n|, |\\tilde{\\kappa}_{n+1}|)\n        $$\n        where $a_{\\text{tol}}$ is an absolute tolerance and $r_{\\text{tol}}$ is a relative tolerance. The update logic is specified as:\n        $$\n        \\kappa'_{n+1} =\n        \\begin{cases}\n        \\tilde{\\kappa}_{n+1},  \\text{if } \\tilde{\\kappa}_{n+1} \\ge \\kappa_n + \\mathrm{tol} \\\\\n        \\kappa_n,            \\text{otherwise}\n        \\end{cases}\n        $$\n        A final monotonicity clamp is applied as requested, although the rule as defined for non-negative $\\kappa$ and $\\tilde{\\kappa}$ already ensures this:\n        $$\n        \\kappa_{n+1}^{\\text{rob}} = \\max(\\kappa_n, \\kappa'_{n+1})\n        $$\n\n5.  For each of the resulting history variables ($\\kappa_{n+1}^{\\text{naive}}$ and $\\kappa_{n+1}^{\\text{rob}}$), calculate the corresponding quantities at step $n+1$:\n    -   Damage: $d_{n+1} = d(\\kappa_{n+1})$.\n    -   Stress: $\\sigma_{n+1} = \\sigma(\\varepsilon_{n+1}, \\kappa_{n+1})$.\n    -   Stress increment: $\\Delta\\sigma = \\sigma_{n+1} - \\sigma_n$.\n\n6.  Finally, perform verification checks for each update rule:\n    -   **Monotonicity of $\\kappa$**: Check if $\\kappa_{n+1} \\ge \\kappa_n$. This is expected to be true for both rules by construction.\n    -   **Positivity of Dissipation**: The damage increment $\\Delta d = d_{n+1} - d_n$ must be non-negative. To account for floating-point inaccuracies, this is checked using a tolerance $t_{\\text{diss}}$: $\\Delta d \\ge -t_{\\text{diss}}$. This is also expected to be true since $d(\\kappa)$ is a monotonically increasing function and $\\kappa_{n+1} \\ge \\kappa_n$.\n\nThe implementation will apply this procedure to each test case provided, using the specified material parameters ($E = 2.1 \\times 10^5$, $\\kappa_0 = 2.0 \\times 10^{-2}$, $m = 2.0$) and tolerances ($a_{\\text{tol}} = 1.0 \\times 10^{-12}$, $r_{\\text{tol}} = 1.0 \\times 10^{-8}$, $t_{\\text{diss}} = 1.0 \\times 10^{-14}$). The eight specified output values will be computed for each case.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the continuum damage mechanics problem by implementing and\n    comparing naive and robust update rules for the history variable.\n    \"\"\"\n    # Material and tolerance parameters from the problem statement\n    E = 2.10e5\n    kappa_0 = 2.0e-2\n    m = 2.0\n    a_tol = 1.0e-12\n    r_tol = 1.0e-8\n    t_diss = 1.0e-14\n\n    # --- Constitutive Functions ---\n    def damage_func(kappa):\n        if kappa  0: # kappa must be non-negative\n            return 0.0\n        return 1.0 - np.exp(-((kappa / kappa_0)**m))\n\n    def stress_func(epsilon, kappa):\n        d = damage_func(kappa)\n        return (1.0 - d) * E * epsilon\n    \n    # Test cases from the problem statement\n    test_cases = [\n        # (epsilon_n, kappa_n, epsilon_n+1)\n        (1.0e-2, 1.0e-2, 1.2e-2),\n        (1.414213561e-2, 1.414213561e-2, 1.414213563e-2),\n        (1.414213563e-2, 1.414213563e-2, 1.414213561e-2),\n        (0.0, 0.0, 1.0e-16),\n        (1.0, 1.0, 1.000000005),\n        (5.0e-1, 5.0e-1, 6.0e-1),\n    ]\n\n    results = []\n    \n    for eps_n, kappa_n, eps_n1 in test_cases:\n        \n        # --- Common calculations for the step ---\n        sigma_n = stress_func(eps_n, kappa_n)\n        d_n = damage_func(kappa_n)\n        tilde_kappa_n1 = abs(eps_n1)\n\n        # --- Naive Update ---\n        kappa_n1_naive = max(kappa_n, tilde_kappa_n1)\n        sigma_n1_naive = stress_func(eps_n1, kappa_n1_naive)\n        d_n1_naive = damage_func(kappa_n1_naive)\n        \n        delta_sigma_naive = sigma_n1_naive - sigma_n\n        mon_naive = kappa_n1_naive >= kappa_n\n        delta_d_naive = d_n1_naive - d_n\n        diss_naive = delta_d_naive >= -t_diss\n\n        # --- Robust Update ---\n        tol = a_tol + r_tol * max(abs(kappa_n), abs(tilde_kappa_n1))\n        \n        if tilde_kappa_n1 >= kappa_n + tol:\n            kappa_n1_rob_intermediate = tilde_kappa_n1\n        elif tilde_kappa_n1 = kappa_n - tol:\n            # This branch is for completeness based on the provided rule,\n            # but with positive kappa and the final clamp, it has less effect.\n            kappa_n1_rob_intermediate = kappa_n\n        else: # Tie region\n            kappa_n1_rob_intermediate = kappa_n\n\n        # Apply monotonicity clamp as requested\n        kappa_n1_rob = max(kappa_n, kappa_n1_rob_intermediate)\n        \n        sigma_n1_rob = stress_func(eps_n1, kappa_n1_rob)\n        d_n1_rob = damage_func(kappa_n1_rob)\n        \n        delta_sigma_rob = sigma_n1_rob - sigma_n\n        mon_rob = kappa_n1_rob >= kappa_n\n        delta_d_rob = d_n1_rob - d_n\n        diss_rob = delta_d_rob >= -t_diss\n\n        # --- Assemble results for the current case ---\n        case_result = [\n            kappa_n1_naive,\n            kappa_n1_rob,\n            delta_sigma_naive,\n            delta_sigma_rob,\n            mon_naive,\n            mon_rob,\n            diss_naive,\n            diss_rob\n        ]\n        results.append(case_result)\n\n    # --- Final Output Formatting ---\n    # Create the string representation manually to match the required format\n    # `repr()` is used to get a standard string for floats and booleans.\n    outer_parts = []\n    for res_list in results:\n        inner_parts = [repr(x) for x in res_list]\n        outer_parts.append(f\"[{','.join(inner_parts)}]\")\n    final_string = f\"[{','.join(outer_parts)}]\"\n\n    print(final_string)\n\nsolve()\n```", "id": "3554716"}, {"introduction": "Our final practice elevates the analysis from the local constitutive level to the global system solution. This exercise [@problem_id:3554721] delves into the numerical analysis of coupled field problems, comparing the convergence properties of monolithic and staggered (block Gauss-Seidel) solution schemes. By deriving the system Jacobian and the staggered iteration matrix, you will use the spectral radius $\\rho(G)$ to rigorously determine the conditions for local convergence, providing deep insights into the stability and efficiency of different solver architectures for coupled damage-mechanics problems.", "problem": "Consider a one-dimensional small-strain bar with a single displacement degree of freedom and an isotropic scalar damage variable. Let $u \\in \\mathbb{R}$ be the displacement unknown and $d \\in [0,1]$ be the internal damage variable. Assume a non-dimensionalized Helmholtz free energy per unit reference volume of the form\n$$\n\\psi(\\varepsilon,d,\\nabla d) = \\tfrac{1}{2} \\left(1-d\\right)^{2} E \\, \\varepsilon^{2} + \\tfrac{1}{2} k_d \\, d^{2},\n$$\nwhere $E0$ is a (non-dimensionalized) elastic modulus and $k_d  0$ is an effective (non-dimensionalized) damage regularization stiffness arising from spatial discretization of a gradient regularization. Consider a single-element discretization in which the axial strain is proportional to the displacement, so that the incremental potential energy is\n$$\n\\Pi(u,d) = \\tfrac{1}{2} \\left(1-d\\right)^{2} E \\, u^{2} - f u + \\tfrac{1}{2} k_d \\, d^{2},\n$$\nwith $f \\ge 0$ denoting a constant external generalized load. The stationarity conditions yield the residuals\n$$\nR_u(u,d) = \\frac{\\partial \\Pi}{\\partial u} = \\left(1-d\\right)^{2} E\\, u - f, \\quad\nR_d(u,d) = \\frac{\\partial \\Pi}{\\partial d} = -\\left(1-d\\right) E\\, u^{2} + k_d \\, d.\n$$\nDefine the monolithic Jacobian matrix of the coupled system $\\{u,d\\}$ as\n$$\nJ(u,d) = \\begin{bmatrix}\nA  B\\\\\nC  D\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\frac{\\partial R_u}{\\partial u}  \\frac{\\partial R_u}{\\partial d} \\\\\n\\frac{\\partial R_d}{\\partial u}  \\frac{\\partial R_d}{\\partial d}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\left(1-d\\right)^{2} E  -2\\left(1-d\\right) E\\, u\\\\\n-2\\left(1-d\\right) E\\, u  E\\, u^{2} + k_d\n\\end{bmatrix}.\n$$\nA staggered (block Gauss–Seidel) Newton iteration sequentially solves the subproblems for $u$ with $d$ held fixed, then for $d$ with $u$ held fixed, at each global iteration. Linearizing about a solution $\\{u^\\star,d^\\star\\}$ with Jacobian blocks $A,B,C,D$ evaluated at $\\{u^\\star,d^\\star\\}$, the linearized error propagation for the staggered iteration is governed by the iteration matrix\n$$\nG = -\\left[\\begin{array}{cc} A  0\\\\ C  D\\end{array}\\right]^{-1}\\left[\\begin{array}{cc} 0  B\\\\ 0  0\\end{array}\\right]\n=\n\\begin{bmatrix}\n0  -A^{-1} B \\\\\n0  D^{-1} C A^{-1} B\n\\end{bmatrix}.\n$$\nThe spectral radius $\\rho(G)$ controls the local linear convergence of the staggered scheme; specifically, if $\\rho(G)  1$, then the staggered iteration is locally linearly convergent in a neighborhood of $\\{u^\\star,d^\\star\\}$. In the monolithic Newton method with a consistent Jacobian and twice continuously differentiable residual, local quadratic convergence holds if $J(u^\\star,d^\\star)$ is nonsingular and the initial iterate is sufficiently close to the solution.\n\nYour tasks are:\n1. Starting from the incremental potential $\\Pi(u,d)$ and the stationarity conditions, derive the Jacobian blocks $A, B, C, D$ at a general state $\\{u,d\\}$ solely using the definitions of the residuals $R_u$ and $R_d$.\n2. For the staggered (block Gauss–Seidel) linearization, derive the iteration matrix $G$ in terms of the Jacobian blocks $A, B, C, D$, and simplify the spectral radius $\\rho(G)$ for the present scalar-block case. Express the simplified $\\rho(G)$ in terms of $E, k_d, u^\\star, d^\\star$ only.\n3. Show that the coupled equilibrium satisfies the algebraic system $R_u(u^\\star,d^\\star) = 0$ and $R_d(u^\\star,d^\\star) = 0$. By eliminating $u^\\star$ in favor of $d^\\star$, reduce the equilibrium conditions to a single scalar equation in $x := 1 - d^\\star \\in (0,1]$ of the form\n$$\nF(x;E,k_d,f) = k_d\\left(x^4 - x^3\\right) + \\frac{f^2}{E} = 0,\n$$\nand use this to compute $u^\\star$ and $d^\\star$.\n4. Using the above, evaluate the spectral radius $\\rho(G)$ at $\\{u^\\star,d^\\star\\}$ and decide whether the staggered method is locally convergent by checking whether $\\rho(G)  1$. Additionally, decide whether the monolithic Newton method is locally quadratically convergent by checking whether the full Jacobian $J(u^\\star,d^\\star)$ is nonsingular.\n5. Implement a program that, for a set of test cases, solves for $\\{u^\\star,d^\\star\\}$, computes $\\rho(G)$, and returns two booleans per test case: one indicating staggered local convergence based on $\\rho(G)  1$, and one indicating monolithic local quadratic convergence based on $\\det J(u^\\star,d^\\star) \\ne 0$. The problem is fully non-dimensional; report all quantities without physical units. For numerical robustness, you may use a tolerance of $\\varepsilon = 10^{-12}$ when comparing to zero or one.\n\nTest suite:\n- Case $1$: $(E,k_d,f) = (1000, 10, 1)$.\n- Case $2$: $(E,k_d,f) = (1000, 1, 10)$.\n- Case $3$: $(E,k_d,f) = (1000, 1000, 10)$.\n- Case $4$: $(E,k_d,f) = (1000, 10, 0)$.\n\nYour program must:\n- Solve the reduced scalar equation $F(x;E,k_d,f) = 0$ for $x \\in (0,1]$ to obtain $d^\\star = 1 - x$ and $u^\\star = f/\\left(E x^{2}\\right)$, with the convention that if $f=0$ then $x=1$.\n- Compute $A,B,C,D$ at $\\{u^\\star,d^\\star\\}$, then compute the spectral radius via the simplified formula you derived.\n- For each test case, output a triple $[\\rho, \\text{staggered\\_convergent}, \\text{monolithic\\_quadratic}]$, where $\\rho$ is a floating-point number rounded to $8$ decimal places, and the two booleans are expressed as either True or False.\n- Aggregate the results of all test cases into a single line printed to standard output, formatted as a Python-style list of lists, for example, $[[r_1,b_1,c_1],[r_2,b_2,c_2],\\ldots]$.\n\nYour final program must be self-contained, require no user input, and strictly follow the specified output format.", "solution": "This problem requires a detailed analysis of the convergence properties of monolithic and staggered solution schemes for a one-dimensional, single-degree-of-freedom continuum damage mechanics model. The analysis involves several steps: derivation of the system Jacobian, formulation of the staggered iteration matrix and its spectral radius, reduction of the equilibrium equations to a single scalar equation, and evaluation of the convergence criteria at the equilibrium state.\n\n**Task 1: Derivation of the Jacobian Blocks**\n\nThe Jacobian matrix $J$ is defined by the partial derivatives of the residuals $R_u(u,d)$ and $R_d(u,d)$ with respect to the variables $u$ and $d$. The residuals are given as:\n$$\nR_u(u,d) = \\left(1-d\\right)^{2} E\\, u - f\n$$\n$$\nR_d(u,d) = -\\left(1-d\\right) E\\, u^{2} + k_d \\, d\n$$\nThe Jacobian blocks $A$, $B$, $C$, and $D$ are calculated as follows:\n$A = \\frac{\\partial R_u}{\\partial u} = \\frac{\\partial}{\\partial u} \\left[ \\left(1-d\\right)^{2} E\\, u - f \\right] = \\left(1-d\\right)^{2} E$\n\n$B = \\frac{\\partial R_u}{\\partial d} = \\frac{\\partial}{\\partial d} \\left[ \\left(1-d\\right)^{2} E\\, u - f \\right] = 2\\left(1-d\\right)(-1) E\\, u = -2\\left(1-d\\right) E\\, u$\n\n$C = \\frac{\\partial R_d}{\\partial u} = \\frac{\\partial}{\\partial u} \\left[ -\\left(1-d\\right) E\\, u^{2} + k_d \\, d \\right] = -\\left(1-d\\right) E\\, (2u) = -2\\left(1-d\\right) E\\, u$\n\n$D = \\frac{\\partial R_d}{\\partial d} = \\frac{\\partial}{\\partial d} \\left[ -\\left(1-d\\right) E\\, u^{2} + k_d \\, d \\right] = -(-1) E\\, u^{2} + k_d = E\\, u^{2} + k_d$\n\nThese derived expressions match the Jacobian matrix provided in the problem statement.\n\n**Task 2: Derivation of the Staggered Iteration Matrix and its Spectral Radius**\n\nThe staggered (block Gauss-Seidel) iteration matrix $G$ is given by:\n$$\nG = -\\left[\\begin{array}{cc} A  0\\\\ C  D\\end{array}\\right]^{-1}\\left[\\begin{array}{cc} 0  B\\\\ 0  0\\end{array}\\right]\n$$\nThe first matrix is block lower-triangular. Its inverse is found by inverting the diagonal blocks:\n$$\n\\left[\\begin{array}{cc} A  0\\\\ C  D\\end{array}\\right]^{-1} = \\begin{bmatrix} A^{-1}  0 \\\\ -D^{-1} C A^{-1}  D^{-1} \\end{bmatrix}\n$$\nSubstituting this into the expression for $G$:\n$$\nG = - \\begin{bmatrix} A^{-1}  0 \\\\ -D^{-1} C A^{-1}  D^{-1} \\end{bmatrix} \\begin{bmatrix} 0  B \\\\ 0  0 \\end{bmatrix} = - \\begin{bmatrix} A^{-1}(0) + 0(0)  A^{-1}B + 0(0) \\\\ -D^{-1}CA^{-1}(0) + D^{-1}(0)  -D^{-1}CA^{-1}B + D^{-1}(0) \\end{bmatrix} = \\begin{bmatrix} 0  -A^{-1}B \\\\ 0  D^{-1}CA^{-1}B \\end{bmatrix}\n$$\nSince $G$ is a block upper-triangular matrix, its eigenvalues are the eigenvalues of its diagonal blocks. In this scalar-block case, the diagonal blocks are the scalars $0$ and $D^{-1}CA^{-1}B = \\frac{BC}{AD}$.\n\nThe spectral radius $\\rho(G)$ is the maximum of the absolute values of the eigenvalues:\n$$\n\\rho(G) = \\max\\left( \\left|\\lambda_1\\right|, \\left|\\lambda_2\\right| \\right) = \\left| \\frac{BC}{AD} \\right|\n$$\nNow, we substitute the expressions for $A$, $B$, $C$, and $D$ evaluated at an equilibrium state $\\{u^\\star, d^\\star\\}$:\n$A = \\left(1-d^\\star\\right)^{2} E$\n$B = -2\\left(1-d^\\star\\right) E\\, u^\\star$\n$C = -2\\left(1-d^\\star\\right) E\\, u^\\star$\n$D = E\\, (u^\\star)^{2} + k_d$\n\n$$\n\\rho(G) = \\left| \\frac{\\left(-2\\left(1-d^\\star\\right) E\\, u^\\star\\right) \\left(-2\\left(1-d^\\star\\right) E\\, u^\\star\\right)}{\\left(\\left(1-d^\\star\\right)^{2} E\\right) \\left(E\\, (u^\\star)^{2} + k_d\\right)} \\right| = \\frac{4\\left(1-d^\\star\\right)^{2} E^2 (u^\\star)^2}{\\left(1-d^\\star\\right)^{2} E \\left(E\\, (u^\\star)^{2} + k_d\\right)} = \\frac{4 E (u^\\star)^2}{E (u^\\star)^2 + k_d}\n$$\nThis is the expression for the spectral radius in terms of $E$, $k_d$, $u^\\star$, and $d^\\star$.\n\n**Task 3: Derivation of the Scalar Equilibrium Equation**\n\nThe equilibrium state $\\{u^\\star, d^\\star\\}$ satisfies the stationarity conditions $R_u(u^\\star, d^\\star)=0$ and $R_d(u^\\star, d^\\star)=0$:\n1. $R_u = 0 \\implies \\left(1-d^\\star\\right)^{2} E\\, u^\\star - f = 0$\n2. $R_d = 0 \\implies -\\left(1-d^\\star\\right) E\\, (u^\\star)^{2} + k_d \\, d^\\star = 0$\n\nFrom equation (1), if $f  0$, then $d^\\star \\neq 1$, and we can solve for $u^\\star$:\n$$\nu^\\star = \\frac{f}{\\left(1-d^\\star\\right)^{2} E}\n$$\nSubstitute this expression for $u^\\star$ into equation (2):\n$$\n-\\left(1-d^\\star\\right) E \\left( \\frac{f}{\\left(1-d^\\star\\right)^{2} E} \\right)^2 + k_d d^\\star = 0\n$$\n$$\n-\\left(1-d^\\star\\right) E \\frac{f^2}{\\left(1-d^\\star\\right)^{4} E^2} + k_d d^\\star = 0\n$$\n$$\n-\\frac{f^2}{\\left(1-d^\\star\\right)^{3} E} + k_d d^\\star = 0\n$$\nLet's define $x := 1 - d^\\star$, which implies $d^\\star = 1 - x$. Substituting this into the equation:\n$$\n-\\frac{f^2}{x^3 E} + k_d (1-x) = 0\n$$\nRearranging the terms to match the required form:\n$$\nk_d (1-x) = \\frac{f^2}{x^3 E}\n$$\n$$\nk_d E x^3 (1-x) = f^2\n$$\n$$\nk_d (x^3 - x^4) = \\frac{f^2}{E}\n$$\n$$\nk_d (x^4 - x^3) + \\frac{f^2}{E} = 0\n$$\nThis is the desired scalar equation $F(x;E,k_d,f) = 0$. Once $x$ is found, we have $d^\\star = 1-x$ and $u^\\star = f / (E x^2)$.\nFor the case $f=0$, the equation becomes $k_d(x^4-x^3)=0$, which yields $x^3(x-1)=0$. The solutions are $x=0$ and $x=1$. With $d \\in [0,1]$, we have $x \\in [0,1]$. The problem statement provides the convention that for $f=0$, we take $x=1$, corresponding to the undamaged state $d^\\star=0$ and $u^\\star=0$.\n\n**Task 4: Evaluation of Convergence Criteria**\n\nWe now express the convergence criteria in terms of the single variable $x := 1 - d^\\star$.\n\n**Staggered Scheme:**\nFrom the equilibrium condition $R_d=0$, we have $k_d d^\\star = (1-d^\\star) E (u^\\star)^2$. This gives $E(u^\\star)^2 = \\frac{k_d d^\\star}{1-d^\\star}$.\nSubstituting this into the expression for $\\rho(G)$:\n$$\n\\rho(G) = \\frac{4 E (u^\\star)^2}{E (u^\\star)^2 + k_d} = \\frac{4 \\frac{k_d d^\\star}{1-d^\\star}}{\\frac{k_d d^\\star}{1-d^\\star} + k_d} = \\frac{4 \\frac{d^\\star}{1-d^\\star}}{\\frac{d^\\star}{1-d^\\star} + 1} = \\frac{4 \\frac{d^\\star}{1-d^\\star}}{\\frac{d^\\star + (1-d^\\star)}{1-d^\\star}} = \\frac{4 \\frac{d^\\star}{1-d^\\star}}{\\frac{1}{1-d^\\star}} = 4d^\\star\n$$\nThe local linear convergence condition is $\\rho(G)  1$, which simplifies to $4d^\\star  1$, or $d^\\star  1/4$.\n\n**Monolithic Scheme:**\nLocal quadratic convergence depends on the non-singularity of the Jacobian $J(u^\\star, d^\\star)$, i.e., $\\det(J) \\neq 0$.\n$$\n\\det(J) = AD - BC = \\left((1-d^\\star)^2 E\\right) (E(u^\\star)^2+k_d) - \\left(-2(1-d^\\star)Eu^\\star\\right)^2\n$$\n$$\n\\det(J) = (1-d^\\star)^2 E (E(u^\\star)^2+k_d) - 4(1-d^\\star)^2 E^2 (u^\\star)^2\n$$\n$$\n\\det(J) = (1-d^\\star)^2 E k_d - 3(1-d^\\star)^2 E^2 (u^\\star)^2 = (1-d^\\star)^2 E (k_d - 3E(u^\\star)^2)\n$$\nSubstituting $E(u^\\star)^2 = \\frac{k_d d^\\star}{1-d^\\star}$:\n$$\n\\det(J) = (1-d^\\star)^2 E \\left(k_d - 3\\frac{k_d d^\\star}{1-d^\\star}\\right) = (1-d^\\star)^2 E k_d \\left(1 - \\frac{3d^\\star}{1-d^\\star}\\right)\n$$\n$$\n\\det(J) = (1-d^\\star)^2 E k_d \\left(\\frac{1-d^\\star-3d^\\star}{1-d^\\star}\\right) = (1-d^\\star) E k_d (1 - 4d^\\star)\n$$\nSince $E0$, $k_d0$, and for $f0$, $d^\\star \\in (0,1)$ so $1-d^\\star \\neq 0$, the condition $\\det(J) \\neq 0$ is equivalent to $1 - 4d^\\star \\neq 0$, which means $d^\\star \\neq 1/4$.\n\nBoth convergence analyses highlight a critical damage state at $d^\\star = 1/4$. At this point, the spectral radius of the staggered scheme reaches unity, indicating a loss of guaranteed convergence, and the monolithic Jacobian becomes singular, indicating a bifurcation or limit point and loss of quadratic convergence.\n\n**Implementation Summary:**\nFor each test case $(E, k_d, f)$:\n1. If $f=0$, set $x=1$. Otherwise, calculate $C = f^2/(E k_d)$ and numerically solve $x^3(1-x) - C = 0$ for $x \\in [0.75, 1]$ to find $x^\\star$. This interval is chosen because the physical equilibrium path starts at $x=1$ (no damage) and proceeds towards lower values of $x$ (increasing damage) as the load $f$ increases. The maximum of $x^3(1-x)$ occurs at $x=3/4$, marking the limit point.\n2. Calculate $d^\\star = 1 - x^\\star$.\n3. Calculate $\\rho(G) = 4d^\\star$.\n4. Check staggered convergence: $\\rho(G)  1$.\n5. Check monolithic convergence: $d^\\star \\neq 1/4$.\nThe results are then formatted as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves for the equilibrium state of a 1D damage model and analyzes the\n    local convergence properties of monolithic and staggered numerical schemes.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (E, k_d, f)\n        (1000, 10, 1),\n        (1000, 1, 10),\n        (1000, 1000, 10),\n        (1000, 10, 0),\n    ]\n\n    results = []\n    # Numerical tolerance for comparisons\n    epsilon = 1e-12\n\n    for E, k_d, f in test_cases:\n        # Task 3: Solve for equilibrium state {u*, d*}\n        # by finding x* = 1-d* from F(x;E,k_d,f) = 0.\n\n        if abs(f)  epsilon:\n            # Per problem convention, if f=0, then x=1 (no damage state).\n            x_star = 1.0\n        else:\n            # For f > 0, solve k_d(x^4-x^3) + f^2/E = 0.\n            # This is equivalent to solving x^3(1-x) = C, where C = f^2/(E*k_d).\n            # The physically stable equilibrium branch corresponds to roots x in [0.75, 1.0].\n            # The function h(x) = x^3(1-x) has a maximum at x=0.75.\n            C = f**2 / (E * k_d)\n            \n            # Use a robust root-finding algorithm (Brent's method) on the stable interval.\n            # The function whose root we seek is g(x) = x^3(1-x) - C.\n            # g(0.75) = (3/4)^3 * (1/4) - C = 27/256 - C >= 0 for the given test cases.\n            # g(1) = 0 - C = 0.\n            # The interval [0.75, 1.0] brackets the root.\n            try:\n                # Handle the boundary case where C = 27/256 exactly\n                if abs(C - 27.0/256.0)  epsilon:\n                    x_star = 0.75\n                else:\n                    x_star = brentq(lambda x: x**3 * (1 - x) - C, 0.75, 1.0)\n            except ValueError:\n                # This would occur if C > 27/256, for which no real solution for x in [0,1] exists.\n                # The problem's test cases avoid this scenario.\n                # For robustness, we could assign a NaN or error state.\n                # For this specific problem, it is safe to assume a solution exists.\n                # Let's add a placeholder just in case, though it is not expected to be hit.\n                rho, staggered_convergent, monolithic_quadratic = (np.nan, False, False)\n                results.append([rho, staggered_convergent, monolithic_quadratic])\n                continue\n\n        # From x_star, compute d_star\n        d_star = 1.0 - x_star\n\n        # Task 4: Evaluate convergence criteria.\n        \n        # Staggered scheme convergence: rho(G) = 4*d_star  1\n        rho = 4.0 * d_star\n        staggered_convergent = rho  1.0 - epsilon\n        \n        # Monolithic scheme quadratic convergence: det(J) != 0, which is equivalent to d_star != 1/4\n        # We can check this by |d_star - 0.25| > epsilon.\n        # Note that d_star = 1 - x_star, so d_star = 1/4 is equivalent to x_star = 3/4.\n        monolithic_quadratic = abs(d_star - 0.25) > epsilon\n\n        # Format the results as per problem specification.\n        results.append([round(rho, 8), staggered_convergent, monolithic_quadratic])\n\n    # Final print statement in the exact required format.\n    # The default string representation of a list of lists is the required format.\n    print(str(results))\n\nsolve()\n```", "id": "3554721"}]}