{"hands_on_practices": [{"introduction": "At the heart of any crystal plasticity model lies the constitutive rule that governs how much slip occurs on each slip system. This exercise provides a foundational coding practice for implementing the widely used rate-dependent power law, which relates the resolved shear stress to the resulting slip rate [@problem_id:3556441]. By computing slip rates and identifying which systems are \"active,\" you will build the core computational engine that drives plastic deformation in crystalline materials.", "problem": "You are given a set of slip systems indexed by $\\alpha$ in the context of Crystal Plasticity (CP). Each slip system is characterized by a resolved shear stress $\\tau^\\alpha$ and a slip resistance (also called critical resolved shear stress) $g^\\alpha$, both with units of stress. The material is rate-dependent with a rate sensitivity parameter $m$ (dimensionless) and a reference slip rate $\\dot{\\gamma}_0$ (in $\\mathrm{s}^{-1}$). The mechanical dissipation is defined as $D = \\sum_\\alpha \\tau^\\alpha \\dot{\\gamma}^\\alpha$, and a convex dissipation potential is assumed to generate an associated flow rule. The goal is to compute the slip rates $\\dot{\\gamma}^\\alpha$ for each slip system based on this principle and then determine the active set using a thresholding algorithm. A slip system is considered active if its overstress ratio $r^\\alpha = \\left|\\tau^\\alpha\\right| / g^\\alpha$ is above a specified ratio threshold and its slip rate magnitude is above a prescribed tolerance.\n\nFundamental basis for derivation and implementation:\n- The rate-dependent constitutive description is derived from the assumption of a convex pseudo-potential of dissipation that depends on the magnitude of the slip rates and on the slip resistances.\n- The associated flow rule is obtained by enforcing that the resolved shear stress is the subdifferential of the dissipation potential with respect to the slip rate, consistent with the second law of thermodynamics.\n\nYou must write a complete program that, for each test case specified below, computes:\n1. The slip rates $\\dot{\\gamma}^\\alpha$ in $\\mathrm{s}^{-1}$ for all slip systems.\n2. The active-set flags $A^\\alpha \\in \\{\\text{True}, \\text{False}\\}$ determined by the thresholding algorithm defined as follows:\n   - Compute the overstress ratio $r^\\alpha = \\left|\\tau^\\alpha\\right| / g^\\alpha$ (dimensionless).\n   - A slip system is active if both $r^\\alpha \\ge r_{\\mathrm{thr}}$ and $\\left|\\dot{\\gamma}^\\alpha\\right| \\ge \\dot{\\gamma}_{\\mathrm{tol}}$.\n\nYour program must produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets. Each test caseâ€™s result must be represented as a list containing two lists: the first is the list of slip rates in $\\mathrm{s}^{-1}$, and the second is the list of booleans for the active set. For example: $[\\,[\\,[\\dot{\\gamma}^1,\\dot{\\gamma}^2,\\ldots],\\,[A^1,A^2,\\ldots]\\,],\\ldots\\,]$.\n\nUse the following test suite. All stresses $\\tau^\\alpha$ and $g^\\alpha$ are to be interpreted in $\\mathrm{MPa}$, slip rates in $\\mathrm{s}^{-1}$, and angles are not used in this problem.\n\n- Test case $1$ (general case, mixed signs and a zero stress):\n  - $\\boldsymbol{\\tau} = [\\,120,\\,80,\\,-110,\\,20,\\,0,\\,95\\,]\\,\\mathrm{MPa}$,\n  - $\\boldsymbol{g} = [\\,100,\\,100,\\,100,\\,100,\\,100,\\,100\\,]\\,\\mathrm{MPa}$,\n  - $m = 0.05$,\n  - $\\dot{\\gamma}_0 = 10^{-3}\\,\\mathrm{s}^{-1}$,\n  - $r_{\\mathrm{thr}} = 0.98$,\n  - $\\dot{\\gamma}_{\\mathrm{tol}} = 10^{-6}\\,\\mathrm{s}^{-1}$.\n\n- Test case $2$ (boundary conditions including $\\left|\\tau^\\alpha\\right| = g^\\alpha$ and zero stress):\n  - $\\boldsymbol{\\tau} = [\\,100,\\,100,\\,-100,\\,50,\\,-50,\\,0\\,]\\,\\mathrm{MPa}$,\n  - $\\boldsymbol{g} = [\\,100,\\,120,\\,100,\\,60,\\,50,\\,80\\,]\\,\\mathrm{MPa}$,\n  - $m = 0.2$,\n  - $\\dot{\\gamma}_0 = 10^{-3}\\,\\mathrm{s}^{-1}$,\n  - $r_{\\mathrm{thr}} = 1.0$,\n  - $\\dot{\\gamma}_{\\mathrm{tol}} = 5\\times 10^{-6}\\,\\mathrm{s}^{-1}$.\n\n- Test case $3$ (low overstress ratios, moderate rate sensitivity):\n  - $\\boldsymbol{\\tau} = [\\,30,\\,-45,\\,70,\\,-10,\\,5,\\,15\\,]\\,\\mathrm{MPa}$,\n  - $\\boldsymbol{g} = [\\,150,\\,150,\\,200,\\,200,\\,180,\\,160\\,]\\,\\mathrm{MPa}$,\n  - $m = 0.5$,\n  - $\\dot{\\gamma}_0 = 10^{-2}\\,\\mathrm{s}^{-1}$,\n  - $r_{\\mathrm{thr}} = 0.9$,\n  - $\\dot{\\gamma}_{\\mathrm{tol}} = 10^{-4}\\,\\mathrm{s}^{-1}$.\n\n- Test case $4$ (near-zero stresses to probe numerical stability):\n  - $\\boldsymbol{\\tau} = [\\,0.1,\\,-0.2,\\,0.0,\\,0.05,\\,-0.05,\\,0.01\\,]\\,\\mathrm{MPa}$,\n  - $\\boldsymbol{g} = [\\,100,\\,100,\\,100,\\,120,\\,120,\\,150\\,]\\,\\mathrm{MPa}$,\n  - $m = 0.05$,\n  - $\\dot{\\gamma}_0 = 10^{-3}\\,\\mathrm{s}^{-1}$,\n  - $r_{\\mathrm{thr}} = 0.95$,\n  - $\\dot{\\gamma}_{\\mathrm{tol}} = 10^{-8}\\,\\mathrm{s}^{-1}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is of the form $[\\,[\\dot{\\gamma}^1,\\dot{\\gamma}^2,\\ldots],\\,[A^1,A^2,\\ldots]\\,]$. All slip rates must be expressed in $\\mathrm{s}^{-1}$.", "solution": "The problem as stated is valid. It is scientifically grounded in the principles of continuum mechanics and materials science, specifically in the domain of rate-dependent crystal plasticity. The problem is well-posed, objective, and contains all necessary information to derive a unique and meaningful solution. The formulation is a standard one in the field, relying on a power-law relationship between resolved shear stress and slip rate, which is derivable from a convex dissipation potential.\n\nThe thermodynamic framework for crystal plasticity postulates the existence of a dissipation potential, $\\Psi$, which is a convex function of the slip rates $\\dot{\\gamma}^\\alpha$. The resolved shear stress $\\tau^\\alpha$ on each slip system $\\alpha$ is then derived from this potential through an associated flow rule, ensuring that the dissipation, $D = \\sum_\\alpha \\tau^\\alpha \\dot{\\gamma}^\\alpha$, is non-negative. This is expressed as:\n$$\n\\tau^\\alpha = \\frac{\\partial \\Psi}{\\partial \\dot{\\gamma}^\\alpha}\n$$\nA commonly used form for the dissipation potential, which gives rise to the specified power-law viscoplasticity model, is:\n$$\n\\Psi(\\{\\dot{\\gamma}^\\beta\\}; \\{g^\\beta\\}) = \\sum_{\\beta} \\frac{g^\\beta \\dot{\\gamma}_0}{m+1} \\left( \\frac{|\\dot{\\gamma}^\\beta|}{\\dot{\\gamma}_0} \\right)^{m+1}\n$$\nwhere $g^\\beta$ is the slip resistance of system $\\beta$, $\\dot{\\gamma}_0$ is a reference slip rate, and $m$ is the rate sensitivity parameter. All these quantities are given in the problem statement.\n\nApplying the associated flow rule, we differentiate the potential $\\Psi$ with respect to a specific slip rate $\\dot{\\gamma}^\\alpha$:\n$$\n\\tau^\\alpha = \\frac{\\partial}{\\partial \\dot{\\gamma}^\\alpha} \\left[ \\sum_{\\beta} \\frac{g^\\beta \\dot{\\gamma}_0}{m+1} \\left( \\frac{|\\dot{\\gamma}^\\beta|}{\\dot{\\gamma}_0} \\right)^{m+1} \\right]\n$$\nSince the slip systems are uncoupled in the potential, the derivatives for $\\beta \\neq \\alpha$ are zero. We are left with:\n$$\n\\tau^\\alpha = \\frac{g^\\alpha \\dot{\\gamma}_0}{m+1} \\frac{\\partial}{\\partial \\dot{\\gamma}^\\alpha} \\left( \\frac{|\\dot{\\gamma}^\\alpha|}{\\dot{\\gamma}_0} \\right)^{m+1}\n$$\nUsing the chain rule, and noting that $\\frac{d|x|}{dx} = \\mathrm{sgn}(x)$, we obtain:\n$$\n\\tau^\\alpha = \\frac{g^\\alpha \\dot{\\gamma}_0}{m+1} (m+1) \\left( \\frac{|\\dot{\\gamma}^\\alpha|}{\\dot{\\gamma}_0} \\right)^{m} \\frac{1}{\\dot{\\gamma}_0} \\mathrm{sgn}(\\dot{\\gamma}^\\alpha)\n$$\nSimplifying this expression yields the relationship between the resolved shear stress and the slip rate:\n$$\n\\tau^\\alpha = g^\\alpha \\left( \\frac{|\\dot{\\gamma}^\\alpha|}{\\dot{\\gamma}_0} \\right)^m \\mathrm{sgn}(\\dot{\\gamma}^\\alpha)\n$$\nTo ensure non-negative dissipation ($\\tau^\\alpha \\dot{\\gamma}^\\alpha \\ge 0$), the signs of $\\tau^\\alpha$ and $\\dot{\\gamma}^\\alpha$ must be the same, so $\\mathrm{sgn}(\\tau^\\alpha) = \\mathrm{sgn}(\\dot{\\gamma}^\\alpha)$. Taking the absolute value of both sides:\n$$\n|\\tau^\\alpha| = g^\\alpha \\left( \\frac{|\\dot{\\gamma}^\\alpha|}{\\dot{\\gamma}_0} \\right)^m\n$$\nWe can now solve for the magnitude of the slip rate $|\\dot{\\gamma}^\\alpha|$:\n$$\n\\left( \\frac{|\\tau^\\alpha|}{g^\\alpha} \\right) = \\left( \\frac{|\\dot{\\gamma}^\\alpha|}{\\dot{\\gamma}_0} \\right)^m \\implies \\left( \\frac{|\\tau^\\alpha|}{g^\\alpha} \\right)^{1/m} = \\frac{|\\dot{\\gamma}^\\alpha|}{\\dot{\\gamma}_0} \\implies |\\dot{\\gamma}^\\alpha| = \\dot{\\gamma}_0 \\left( \\frac{|\\tau^\\alpha|}{g^\\alpha} \\right)^{1/m}\n$$\nReintroducing the sign, we arrive at the final constitutive equation for the slip rate on system $\\alpha$:\n$$\n\\dot{\\gamma}^\\alpha = \\dot{\\gamma}_0 \\left( \\frac{|\\tau^\\alpha|}{g^\\alpha} \\right)^{1/m} \\mathrm{sgn}(\\tau^\\alpha)\n$$\nThis equation provides a direct method to compute the slip rate $\\dot{\\gamma}^\\alpha$ for each slip system given the resolved shear stress $\\tau^\\alpha$, the current slip resistance $g^\\alpha$, the reference slip rate $\\dot{\\gamma}_0$, and the rate sensitivity exponent $m$. It is important to note that if $\\tau^\\alpha = 0$, then $\\dot{\\gamma}^\\alpha = 0$, which is physically and mathematically consistent. All provided slip resistances $g^\\alpha$ are strictly positive, preventing any division by zero.\n\nThe second part of the problem requires the determination of the active set of slip systems. A slip system $\\alpha$ is defined as active if two conditions are met simultaneously:\n1.  The overstress ratio, $r^\\alpha = \\frac{|\\tau^\\alpha|}{g^\\alpha}$, must be greater than or equal to a specified threshold $r_{\\mathrm{thr}}$.\n2.  The magnitude of the slip rate, $|\\dot{\\gamma}^\\alpha|$, must be greater than or equal to a specified tolerance $\\dot{\\gamma}_{\\mathrm{tol}}$.\n\nTherefore, the activity flag $A^\\alpha$ for each system is determined by the logical expression:\n$$\nA^\\alpha = (r^\\alpha \\ge r_{\\mathrm{thr}}) \\land (|\\dot{\\gamma}^\\alpha| \\ge \\dot{\\gamma}_{\\mathrm{tol}})\n$$\nwhere $\\land$ represents the logical AND operator.\n\nThe computational procedure for each test case is as follows:\n1.  For each slip system $\\alpha$ from $1$ to $N$, where $N$ is the number of systems in the given test case:\n    a.  Obtain the values of $\\tau^\\alpha$, $g^\\alpha$, $m$, and $\\dot{\\gamma}_0$.\n    b.  Compute the slip rate $\\dot{\\gamma}^\\alpha$ using the derived power-law equation.\n    c.  Compute the overstress ratio $r^\\alpha = |\\tau^\\alpha| / g^\\alpha$.\n    d.  Evaluate the activity flag $A^\\alpha$ by checking if both $r^\\alpha \\ge r_{\\mathrm{thr}}$ and $|\\dot{\\gamma}^\\alpha| \\ge \\dot{\\gamma}_{\\mathrm{tol}}$ are `True`.\n2.  Collect the computed slip rates into a list $[\\dot{\\gamma}^1, \\dot{\\gamma}^2, \\ldots, \\dot{\\gamma}^N]$.\n3.  Collect the activity flags into a list $[A^1, A^2, \\ldots, A^N]$.\n4.  Combine these two lists into the final structure for the test case: $[[\\dot{\\gamma}^1, \\ldots], [A^1, \\ldots]]$.\nThis procedure is repeated for all specified test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes slip rates and active sets for crystal plasticity problems.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (tau, g, m, gamma0_dot, r_thr, gamma_tol_dot)\n    # Stresses are in MPa, slip rates in s^-1.\n    test_cases = [\n        (\n            np.array([120.0, 80.0, -110.0, 20.0, 0.0, 95.0]),  # tau (MPa)\n            np.array([100.0, 100.0, 100.0, 100.0, 100.0, 100.0]),  # g (MPa)\n            0.05,  # m\n            1e-3,  # gamma0_dot (s^-1)\n            0.98,  # r_thr\n            1e-6   # gamma_tol_dot (s^-1)\n        ),\n        (\n            np.array([100.0, 100.0, -100.0, 50.0, -50.0, 0.0]),\n            np.array([100.0, 120.0, 100.0, 60.0, 50.0, 80.0]),\n            0.2,\n            1e-3,\n            1.0,\n            5e-6\n        ),\n        (\n            np.array([30.0, -45.0, 70.0, -10.0, 5.0, 15.0]),\n            np.array([150.0, 150.0, 200.0, 200.0, 180.0, 160.0]),\n            0.5,\n            1e-2,\n            0.9,\n            1e-4\n        ),\n        (\n            np.array([0.1, -0.2, 0.0, 0.05, -0.05, 0.01]),\n            np.array([100.0, 100.0, 100.0, 120.0, 120.0, 150.0]),\n            0.05,\n            1e-3,\n            0.95,\n            1e-8\n        )\n    ]\n\n    results = []\n    for case in test_cases:\n        tau, g, m, gamma0_dot, r_thr, gamma_tol_dot = case\n\n        # Ensure g is not zero to avoid division by zero, though not present in test data.\n        # Create a mask for non-zero g for safe division.\n        g_is_zero = (g == 0)\n        overstress_ratio = np.full_like(tau, 0.0)\n        \n        # Calculate overstress ratio only where g is not zero\n        # Where g is zero, overstress is infinite if tau is non-zero, handled implicitly\n        # since gamma_dot would be infinite. In this problem, all g > 0.\n        overstress_ratio = np.abs(tau) / g\n\n        # Calculate slip rates using the power-law constitutive equation.\n        # np.power(0, positive_number) is 0, correctly handling tau=0.\n        # np.sign(0) is 0, also handled correctly.\n        exponent = 1.0 / m\n        gamma_dot = gamma0_dot * np.power(overstress_ratio, exponent) * np.sign(tau)\n\n        # Determine the active set based on the two conditions.\n        # 1. Overstress ratio threshold\n        # 2. Slip rate magnitude tolerance\n        active_set_flags = (overstress_ratio >= r_thr) & (np.abs(gamma_dot) >= gamma_tol_dot)\n\n        # Format results for the current case as required\n        gamma_dot_list = gamma_dot.tolist()\n        active_set_list = active_set_flags.tolist()\n        \n        results.append([gamma_dot_list, active_set_list])\n\n    # Convert the list of results to the required string format.\n    # The default str() representation for lists includes spaces after commas,\n    # which is consistent with the visual spacing in the problem's LaTeX example.\n    result_strings = [str(r) for r in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n\n```", "id": "3556441"}, {"introduction": "Once the slip rates $\\dot{\\gamma}_\\alpha$ are known, the next step is to determine their collective effect on the macroscopic plastic deformation of the crystal. This is achieved by integrating the plastic velocity gradient $L^p = \\sum_{\\alpha} \\dot{\\gamma}_\\alpha s_\\alpha \\otimes m_\\alpha$ to update the plastic deformation gradient $F^p$ over a time step. This practice challenges you to implement and compare two common numerical integration schemes, highlighting the critical difference in accuracy between a simple first-order approximation and the more robust exponential map update [@problem_id:3556395].", "problem": "Consider the finite-strain crystal plasticity kinematics in which the total deformation gradient is multiplicatively decomposed as $F = F^e F^p$, where $F^e$ is the elastic deformation gradient and $F^p$ is the plastic deformation gradient. The plastic flow is governed by the ordinary differential equation (ODE) $\\dot{F}^p = L^p F^p$, where $L^p$ is the plastic velocity gradient. For a set of crystallographic slip systems indexed by $\\alpha$, the plastic velocity gradient is defined by the sum $L^p = \\sum_{\\alpha} \\dot{\\gamma}_\\alpha \\, s_\\alpha \\otimes m_\\alpha$. Here $s_\\alpha$ is the unit slip direction vector, $m_\\alpha$ is the unit slip plane normal vector, $\\dot{\\gamma}_\\alpha$ is the slip rate on system $\\alpha$, and $\\otimes$ denotes the dyadic product.\n\nSlip system activation is driven by the resolved shear stress on each system, defined by $\\tau_\\alpha = s_\\alpha \\cdot \\sigma \\cdot m_\\alpha$, where $\\sigma$ is the Cauchy stress tensor (symmetric), and $\\cdot$ denotes the appropriate tensor contractions. Use the overstress power-law with a threshold to determine slip rates:\n$$\n\\dot{\\gamma}_\\alpha = \\gamma_0 \\left( \\frac{\\langle |\\tau_\\alpha| - \\tau_c \\rangle_+}{\\tau_c} \\right)^n \\operatorname{sign}(\\tau_\\alpha),\n$$\nwhere $\\gamma_0$ is a reference slip rate (in $\\mathrm{s}^{-1}$), $\\tau_c$ is the critical resolved shear stress (in $\\mathrm{MPa}$), $n$ is the rate sensitivity exponent (dimensionless), $\\langle x \\rangle_+ = \\max(x,0)$ is the Macaulay bracket, and $\\operatorname{sign}(\\cdot)$ is the sign function.\n\nStarting from $F^p_n = I$, where $I$ is the identity tensor, implement two time integration schemes for the update from time $t_n$ to $t_{n+1} = t_n + \\Delta t$:\n1. The exponential map update, grounded in the exact solution of the ODE with piecewise-constant $L^p_n$: $F^p_{n+1} = \\exp(\\Delta t \\, L^p_n) F^p_n$, where $\\exp(\\cdot)$ denotes the matrix exponential.\n2. The first-order explicit Euler update: $F^p_{n+1} \\approx (I + \\Delta t \\, L^p_n) F^p_n$.\n\nYour program must:\n- Construct the specified slip systems and stresses.\n- Compute $\\tau_\\alpha$ for each slip system, determine $\\dot{\\gamma}_\\alpha$ using the given activation law, assemble $L^p$, and then compute both $F^p_{n+1}$ via the exponential map and via the first-order update.\n- Quantify the accuracy of the first-order update by computing the Frobenius norm error $e = \\| F^p_{\\text{Euler}} - F^p_{\\text{exp}} \\|_F$, where $\\| \\cdot \\|_F$ denotes the Frobenius norm. This error is dimensionless; report it as a float.\n\nUse the following two slip systems in a face-centered cubic crystal:\n- Slip system $1$: $m_1 = \\frac{1}{\\sqrt{3}}[1,\\,1,\\,1]$, $s_1 = \\frac{1}{\\sqrt{2}}[0,\\,1,\\,-1]$.\n- Slip system $2$: $m_2 = \\frac{1}{\\sqrt{3}}[1,\\,-1,\\,1]$, $s_2 = \\frac{1}{\\sqrt{2}}[1,\\,1,\\,0]$.\n\nLet the Cauchy stress be a combination of two shear components $\\sigma_{xy} = A$ and $\\sigma_{xz} = B$ (in $\\mathrm{MPa}$), with all other components equal to zero, i.e.,\n$$\n\\sigma = \\begin{bmatrix}\n0 & A & B \\\\\nA & 0 & 0 \\\\\nB & 0 & 0\n\\end{bmatrix}.\n$$\n\nUse the following material parameters for all test cases: $\\gamma_0 = 0.1$ $\\mathrm{s}^{-1}$, $\\tau_c = 100$ $\\mathrm{MPa}$, $n = 10$ (dimensionless). The initial plastic deformation gradient is $F^p_n = I$.\n\nTest suite:\n- Case $1$ (general case, small step): $A = 750$ $\\mathrm{MPa}$, $B = 450$ $\\mathrm{MPa}$, $\\Delta t = 0.001$ $\\mathrm{s}$.\n- Case $2$ (large shear step): $A = 750$ $\\mathrm{MPa}$, $B = 450$ $\\mathrm{MPa}$, $\\Delta t = 0.1$ $\\mathrm{s}$.\n- Case $3$ (single-slip activation boundary): $A = 600$ $\\mathrm{MPa}$, $B = 0$ $\\mathrm{MPa}$, $\\Delta t = 0.05$ $\\mathrm{s}$.\n\nYour program should produce a single line of output containing the Frobenius norm error for each test case as a comma-separated list enclosed in square brackets (e.g., $[e_1,e_2,e_3]$). All outputs must be floats. There are no angle quantities, so no angle unit is needed. All quantities with units are specified; report the final errors as dimensionless floats.", "solution": "The problem requires a comparative analysis of two numerical integration schemes for the evolution of the plastic deformation gradient, $F^p$, within the framework of finite-strain crystal plasticity. We are asked to compute the error of a first-order explicit Euler scheme relative to the more accurate exponential map update, which serves as a reference solution under the assumption of a piecewise-constant plastic velocity gradient.\n\nThe kinematic foundation is the multiplicative decomposition of the total deformation gradient $F$ into elastic and plastic parts:\n$$F = F^e F^p$$\nThe evolution of the plastic part is governed by the flow rule, which is a first-order ordinary differential equation:\n$$\\dot{F}^p = L^p F^p$$\nwhere $L^p$ is the plastic velocity gradient. For a crystal with a set of slip systems indexed by $\\alpha$, $L^p$ is constructed as a sum over a-priori known crystallographic directions:\n$$L^p = \\sum_{\\alpha} \\dot{\\gamma}_\\alpha \\, s_\\alpha \\otimes m_\\alpha$$\nHere, $\\dot{\\gamma}_\\alpha$ is the scalar slip rate, and $s_\\alpha$ and $m_\\alpha$ are the unit vectors defining the slip direction and the slip plane normal, respectively. The dyadic product $s_\\alpha \\otimes m_\\alpha$ is often termed the Schmid tensor for system $\\alpha$.\n\nThe driving force for plastic slip is the resolved shear stress $\\tau_\\alpha$, which represents the projection of the Cauchy stress tensor $\\sigma$ onto the slip system:\n$$\\tau_\\alpha = s_\\alpha \\cdot (\\sigma m_\\alpha) = s_\\alpha^T \\sigma m_\\alpha$$\nThe slip rate $\\dot{\\gamma}_\\alpha$ is determined by a phenomenological constitutive relation. In this problem, a rate-dependent power-law with a threshold is specified:\n$$\n\\dot{\\gamma}_\\alpha = \\gamma_0 \\left( \\frac{\\langle |\\tau_\\alpha| - \\tau_c \\rangle_+}{\\tau_c} \\right)^n \\operatorname{sign}(\\tau_\\alpha)\n$$\nwhere $\\langle x \\rangle_+ = \\max(x,0)$ is the Macaulay bracket. This function indicates that slip only occurs when the magnitude of the resolved shear stress $|\\tau_\\alpha|$ exceeds a critical value $\\tau_c$. The parameters $\\gamma_0$ and $n$ control the reference rate of slip and the material's rate sensitivity, respectively.\n\nThe problem requires updating the plastic deformation gradient from an initial state $F^p_n = I$ at time $t_n$ to a final state $F^p_{n+1}$ at time $t_{n+1} = t_n + \\Delta t$. The stress $\\sigma$ and material parameters are assumed to be constant during this time step, which implies that $\\tau_\\alpha$, $\\dot{\\gamma}_\\alpha$, and consequently $L^p$ are all constant. Let us denote this constant plastic velocity gradient as $L^p_n$.\n\nThe two integration schemes to be compared are:\n$1$. The exponential map update: This is the exact solution to the ODE $\\dot{F}^p = L^p_n F^p$ for a constant $L^p_n$. Given $F^p(t_n) = F^p_n$, the solution at $t_{n+1}$ is:\n$$F^p_{n+1, \\text{exp}} = \\exp(\\Delta t \\, L^p_n) F^p_n$$\nSince the initial condition is $F^p_n = I$, this simplifies to $F^p_{n+1, \\text{exp}} = \\exp(\\Delta t \\, L^p_n)$.\n\n$2$. The first-order explicit Euler update: This is a first-order Taylor approximation of the exponential map.\n$$F^p_{n+1, \\text{Euler}} \\approx (I + \\Delta t \\, L^p_n) F^p_n$$\nWith $F^p_n = I$, this becomes $F^p_{n+1, \\text{Euler}} = I + \\Delta t \\, L^p_n$.\n\nThe accuracy of the Euler scheme is quantified by the Frobenius norm of the difference between the two results:\n$$e = \\| F^p_{n+1, \\text{Euler}} - F^p_{n+1, \\text{exp}} \\|_F$$\n\nThe computational procedure for each test case is as follows:\n\n$1$. **Define constants and inputs:**\nMaterial parameters: $\\gamma_0 = 0.1 \\, \\mathrm{s}^{-1}$, $\\tau_c = 100 \\, \\mathrm{MPa}$, $n = 10$.\nSlip systems:\n-   System $\\alpha = 1$: $m_1 = \\frac{1}{\\sqrt{3}}[1, 1, 1]^T$ and $s_1 = \\frac{1}{\\sqrt{2}}[0, 1, -1]^T$.\n-   System $\\alpha = 2$: $m_2 = \\frac{1}{\\sqrt{3}}[1, -1, 1]^T$ and $s_2 = \\frac{1}{\\sqrt{2}}[1, 1, 0]^T$.\nCase-specific inputs: $A$, $B$, and $\\Delta t$.\n\n$2$. **Construct the Cauchy stress tensor $\\sigma$**:\n$$\n\\sigma = \\begin{bmatrix}\n0 & A & B \\\\\nA & 0 & 0 \\\\\nB & 0 & 0\n\\end{bmatrix}\n$$\nAll values are in $\\mathrm{MPa}$.\n\n$3$. **Compute the resolved shear stresses $\\tau_\\alpha$**:\nFor each system $\\alpha \\in \\{1, 2\\}$, calculate $\\tau_\\alpha = s_\\alpha^T \\sigma m_\\alpha$.\n\n$4$. **Compute the slip rates $\\dot{\\gamma}_\\alpha$**:\nUsing the calculated $\\tau_\\alpha$ and the given power-law, determine $\\dot{\\gamma}_\\alpha$. If $|\\tau_\\alpha| \\le \\tau_c$, then $\\dot{\\gamma}_\\alpha = 0$.\n\n$5$. **Assemble the plastic velocity gradient $L^p_n$**:\nFirst, calculate the Schmid tensors $P_\\alpha = s_\\alpha m_\\alpha^T$. Then, calculate the sum $L^p_n = \\sum_{\\alpha=1}^2 \\dot{\\gamma}_\\alpha P_\\alpha$.\n\n$6$. **Compute the updated plastic deformation gradients**:\n-   $F^p_{n+1, \\text{exp}} = \\exp(\\Delta t \\, L^p_n)$, computed using a matrix exponential function.\n-   $F^p_{n+1, \\text{Euler}} = I + \\Delta t \\, L^p_n$, where $I$ is the $3 \\times 3$ identity matrix.\n\n$7$. **Calculate the Frobenius norm error $e$**:\n-   Compute the difference matrix $D = F^p_{n+1, \\text{Euler}} - F^p_{n+1, \\text{exp}}$.\n-   Calculate the error $e = \\sqrt{\\sum_{i=1}^3 \\sum_{j=1}^3 D_{ij}^2}$.\n\nThis procedure is systematically applied to each of the three test cases provided in the problem statement. The error $e$ is expected to grow with the magnitude of $\\Delta t \\, L^p_n$. Specifically, since the Euler method is a first-order approximation, the local truncation error is of order $(\\Delta t)^2$. This implies that for a fixed $L^p_n$, increasing $\\Delta t$ by a factor of $100$ (from Case $1$ to Case $2$) should increase the error $e$ by a factor of approximately $100^2 = 10000$. Case $3$ explores a scenario of single slip, where one slip system is inactive. The same computational steps apply. The Python implementation will utilize the `numpy` library for vector and matrix operations and `scipy.linalg.expm` for the matrix exponential, which is a robust algorithm for this purpose. The final output is a list of the computed dimensionless errors for the three cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Solves the crystal plasticity problem for the given test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (A [MPa], B [MPa], dt [s])\n        (750.0, 450.0, 0.001),  # Case 1\n        (750.0, 450.0, 0.1),    # Case 2\n        (600.0, 0.0, 0.05),     # Case 3\n    ]\n\n    # Material parameters\n    gamma0 = 0.1  # s^-1\n    tau_c = 100.0   # MPa\n    n = 10.0      # dimensionless\n\n    # Slip systems for FCC\n    # System 1\n    m1 = (1.0 / np.sqrt(3.0)) * np.array([1.0, 1.0, 1.0])\n    s1 = (1.0 / np.sqrt(2.0)) * np.array([0.0, 1.0, -1.0])\n    # System 2\n    m2 = (1.0 / np.sqrt(3.0)) * np.array([1.0, -1.0, 1.0])\n    s2 = (1.0 / np.sqrt(2.0)) * np.array([1.0, 1.0, 0.0])\n    \n    slip_systems = [(s1, m1), (s2, m2)]\n\n    results = []\n    for case in test_cases:\n        A, B, dt = case\n\n        # Construct Cauchy stress tensor\n        sigma = np.array([\n            [0.0, A, B],\n            [A, 0.0, 0.0],\n            [B, 0.0, 0.0]\n        ])\n\n        # Initialize plastic velocity gradient\n        Lp = np.zeros((3, 3))\n        \n        # Loop over slip systems to calculate slip rates and assemble Lp\n        for s, m in slip_systems:\n            # Calculate resolved shear stress (tau)\n            # tau = s . (sigma . m)\n            tau = np.dot(s, np.dot(sigma, m))\n            \n            # Calculate slip rate (dgamma) using the overstress power law\n            if abs(tau) > tau_c:\n                # Macaulay bracket is handled by the condition\n                # <|tau| - tau_c>+ = |tau| - tau_c\n                dgamma = gamma0 * ((abs(tau) - tau_c) / tau_c)**n * np.sign(tau)\n            else:\n                dgamma = 0.0\n\n            # Add contribution to the plastic velocity gradient\n            # Lp += dgamma * (s dyadic m)\n            Lp += dgamma * np.outer(s, m)\n            \n        # Initial plastic deformation gradient is identity\n        # Fp_n = np.identity(3)\n\n        # 1. Exponential map update (exact solution for constant Lp)\n        # Fp_{n+1} = exp(dt * Lp) * Fp_n\n        Fp_exp = expm(dt * Lp)\n\n        # 2. First-order explicit Euler update\n        # Fp_{n+1} = (I + dt * Lp) * Fp_n\n        Fp_euler = np.identity(3) + dt * Lp\n        \n        # Quantify error using Frobenius norm\n        error = np.linalg.norm(Fp_euler - Fp_exp, 'fro')\n        \n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3556395"}, {"introduction": "A complete finite-strain crystal plasticity model requires a rigorous kinematic framework to handle the large deformations and rotations. This exercise focuses on the essential tensor operations of \"pushing-forward\" slip system vectors from the reference configuration to the current configuration and \"pulling-back\" stresses and other quantities [@problem_id:3556393]. By implementing these transformations and verifying the principle of material objectivity, you will construct the robust kinematic scaffolding necessary to ensure your model's predictions are physically meaningful and independent of the observer's reference frame.", "problem": "Implement a program that, for finite-strain crystal plasticity kinematics, performs the push-forward and pull-back of slip systems between the reference, intermediate, and current configurations, and verifies the frame-indifference (objectivity) of a resolved shear stress activation criterion under superposed rigid-body rotations. All quantities are nondimensional. Use only the mathematical bases enumerated below and do not assume any shortcut formulas beyond them.\n\nBase definitions and facts:\n- Let the total deformation gradient be $F \\in \\mathbb{R}^{3 \\times 3}$ with the multiplicative split $F = F^e F^p$, where $F^e$ is the elastic part and $F^p$ is the plastic part.\n- Vectors push-forward by $A$ as $v \\mapsto A v$. Covectors (such as plane normals) push-forward by $A^{-T}$ as $n \\mapsto A^{-T} n$. These rules preserve duality in the sense that $n \\cdot v$ is invariant under the appropriate paired transformations.\n- The right polar decomposition of $F^e$ exists and is given by $F^e = R^e U^e$, where $R^e \\in \\mathrm{SO}(3)$ is a proper orthogonal rotation and $U^e$ is a symmetric, positive-definite stretch tensor. The rotation is $R^e = F^e (U^e)^{-1}$ and $U^e$ is the unique positive-definite square root of $C^e = (F^e)^T F^e$.\n- For a compressible Neo-Hookean elastic response, the Kirchhoff stress is $\\tau = \\mu (B^e - I) + \\kappa \\ln J \\, I$, where $B^e = F^e (F^e)^T$, $J = \\det(F^e)$, $I$ is the identity, $\\mu$ is the shear modulus, and $\\kappa$ is the bulk modulus. The Cauchy stress is $\\sigma = \\tau / J$.\n- The Schmid tensor for a slip system with slip direction $s$ and slip plane normal $m$ in the current configuration is $P = \\tfrac{1}{2} (s \\otimes m + m \\otimes s)$. For a symmetric Cauchy stress $\\sigma$, the resolved shear stress equals $\\tau_{\\mathrm{rss}} = \\sigma : P = s \\cdot (\\sigma m)$.\n\nTasks to implement:\n1. Push-forward mapping of a slip system $(s_0, m_0)$ from the reference configuration to the intermediate configuration via $F^p$, treating $s_0$ as a vector and $m_0$ as a covector, then normalize both, and then rotate both by $R^e$ to the current configuration. Explicitly, compute the intermediate slip direction and normal as the normalized images under $F^p$ and $(F^p)^{-T}$, respectively, and then compute the current slip direction and normal by rotation with $R^e$. Ensure that orthogonality $s \\cdot m = 0$ and unit norms are enforced at the current configuration.\n2. Pull-back mapping of a slip system $(s, m)$ from the current configuration to the reference by undoing the rotation $R^e$ and then using $F^p$ inverses appropriately (vector pulled-back by $(F^p)^{-1}$ and covector pulled-back by $(F^p)^T$), normalizing at each stage. Verify that the round-trip from reference to current and back recovers the original directions up to a possible sign, which should not affect the physical slip system.\n3. Using the compressible Neo-Hookean model, compute the Cauchy stress $\\sigma$ from $F^e$ with given $(\\mu, \\kappa)$ and then compute the resolved shear stress $\\tau_{\\mathrm{rss}}$ for each slip system in the current configuration.\n4. Verify objectivity: Under a superposed rigid-body rotation $Q \\in \\mathrm{SO}(3)$ applied to the current configuration that changes $F^e$ to $F^{e\\star} = Q F^e$, recompute the current slip system and the Cauchy stress and evaluate the resolved shear stress $\\tau_{\\mathrm{rss}}^\\star$. Demonstrate numerically that $\\tau_{\\mathrm{rss}}^\\star = \\tau_{\\mathrm{rss}}$ within a specified tolerance.\n\nTest suite and parameters:\n- Use the following three test cases. For each case, use the given $F^p$, $F^e$, reference slip system $(s_0, m_0)$, rigid rotation $Q$, and elastic parameters $(\\mu, \\kappa)$. All matrices and vectors are to be used exactly as specified.\n\nCase A:\n- $F^p = \\begin{bmatrix} 1 & 0.3 & 0 \\\\ 0 & 1 & 0.2 \\\\ 0 & 0 & 1 \\end{bmatrix}$, $F^e = \\begin{bmatrix} 1.1 & 0.2 & 0 \\\\ 0 & 0.9 & 0.1 \\\\ 0 & 0 & 1.05 \\end{bmatrix}$.\n- $(s_0, m_0) = \\left( \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\end{bmatrix}, \\begin{bmatrix} 0 \\\\ 1 \\\\ 0 \\end{bmatrix} \\right)$.\n- $Q = \\begin{bmatrix} 0.5 & -0.8660254037844386 & 0 \\\\ 0.8660254037844386 & 0.5 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}$.\n- $(\\mu, \\kappa) = (50, 100)$.\n\nCase B:\n- $F^p = \\mathrm{diag}(0.9, 1.3, 0.8547008547008547)$, $F^e = \\begin{bmatrix} 1 & 0 & 0 \\\\ 0 & \\tfrac{\\sqrt{2}}{2} & -\\tfrac{\\sqrt{2}}{2} \\\\ 0 & \\tfrac{\\sqrt{2}}{2} & \\tfrac{\\sqrt{2}}{2} \\end{bmatrix}$.\n- $(s_0, m_0) = \\left( \\begin{bmatrix} 0 \\\\ 1 \\\\ 0 \\end{bmatrix}, \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\end{bmatrix} \\right)$.\n- $Q = I = \\begin{bmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}$.\n- $(\\mu, \\kappa) = (50, 100)$.\n\nCase C:\n- $F^p = \\mathrm{diag}(1.2, 0.9, 0.9259259259)$, $F^e = \\begin{bmatrix} 1 & 0.15 & 0 \\\\ 0 & 1 & 0.2 \\\\ 0.05 & 0 & 1 \\end{bmatrix}$.\n- $(s_0, m_0) = \\left( \\dfrac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\\\ 1 \\\\ 0 \\end{bmatrix}, \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\end{bmatrix} \\right)$.\n- $Q = \\begin{bmatrix} 0 & 1 & 0 \\\\ 0 & 0 & 1 \\\\ 1 & 0 & 0 \\end{bmatrix}$.\n- $(\\mu, \\kappa) = (50, 100)$.\n\nWhat to compute and verify for each case:\n- Compute the current slip system $(s, m)$ by push-forward and the reference slip system $(\\tilde{s}_0, \\tilde{m}_0)$ recovered by pull-back from $(s, m)$. Enforce normalization at each step. Verify orthogonality and unit-norm of $(s, m)$ numerically, and verify round-trip recovery of $(s_0, m_0)$ up to sign by checking that $\\left| \\tilde{s}_0 \\cdot s_0 \\right|$ and $\\left| \\tilde{m}_0 \\cdot m_0 \\right|$ are close to $1$.\n- Compute $\\sigma$ from $F^e$ and $(\\mu, \\kappa)$ and the resolved shear stress $\\tau_{\\mathrm{rss}}$. Then, with $F^{e\\star} = Q F^e$, recompute $\\sigma^\\star$ and $\\tau_{\\mathrm{rss}}^\\star$. Verify objectivity by checking that $\\left| \\tau_{\\mathrm{rss}}^\\star - \\tau_{\\mathrm{rss}} \\right|$ is within tolerance.\n\nNumerical tolerances and pass criteria:\n- Use tolerance $\\varepsilon_{\\mathrm{orth}} = 10^{-12}$ for orthogonality and unit-norm checks, $\\varepsilon_{\\mathrm{round}} = 10^{-10}$ for the round-trip checks on directions, and $\\varepsilon_{\\mathrm{obj}} = 10^{-10}$ for the objectivity check on resolved shear stress.\n- A case passes if and only if all three conditions hold: (i) $\\left| s \\cdot m \\right| \\le \\varepsilon_{\\mathrm{orth}}$ and $\\left| \\lVert s \\rVert - 1 \\right| \\le \\varepsilon_{\\mathrm{orth}}$ and $\\left| \\lVert m \\rVert - 1 \\right| \\le \\varepsilon_{\\mathrm{orth}}$; (ii) $\\left| \\tilde{s}_0 \\cdot s_0 \\right| \\ge 1 - \\varepsilon_{\\mathrm{round}}$ and $\\left| \\tilde{m}_0 \\cdot m_0 \\right| \\ge 1 - \\varepsilon_{\\mathrm{round}}$; (iii) $\\left| \\tau_{\\mathrm{rss}}^\\star - \\tau_{\\mathrm{rss}} \\right| \\le \\varepsilon_{\\mathrm{obj}}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the pass or fail results for Cases A, B, and C as a comma-separated list enclosed in square brackets (for example, $\\left[ \\mathrm{True}, \\mathrm{False}, \\mathrm{True} \\right]$ should be printed as \"[True,False,True]\").", "solution": "The problem is valid as it is scientifically grounded in the principles of continuum mechanics and crystal plasticity, is well-posed with all necessary information provided, and is stated in an objective, formal manner. The tasks involve the implementation of standard, albeit specific, kinematic transformations and constitutive relations common in computational solid mechanics. We proceed to solve the problem by implementing the required steps.\n\nThe analysis is broken down into four principal parts for each test case, following the problem description: (1) the push-forward mapping of a slip system from the reference to the current configuration, (2) the pull-back mapping to verify the kinematic round-trip, (3) the computation of stress and resolved shear stress, and (4) the verification of frame-indifference (objectivity) of the resolved shear stress under a superposed rigid-body rotation.\n\n**1. Push-Forward Kinematics of a Slip System**\n\nThe kinematics of crystal plasticity relate three configurations: the reference (or undeformed) configuration $\\mathcal{B}_0$, the current (or deformed) configuration $\\mathcal{B}$, and a conceptual intermediate configuration $\\mathcal{B}_p$. The total deformation gradient $F$ is multiplicatively decomposed as $F = F^e F^p$, where $F^p$ maps from $\\mathcal{B}_0$ to $\\mathcal{B}_p$, and $F^e$ maps from $\\mathcal{B}_p$ to $\\mathcal{B}$.\n\nA slip system is defined by a slip direction vector and a slip plane normal covector. In the reference configuration, these are denoted as $(s_0, m_0)$, which are given as orthogonal unit vectors.\n\nThe push-forward from $\\mathcal{B}_0$ to $\\mathcal{B}_p$ is governed by $F^p$. A vector transforms as $v \\mapsto F^p v$, and a covector (normal) transforms as $n \\mapsto (F^p)^{-T} n$. This transformation law ensures that the dot product (duality pairing) between a vector and a covector is preserved between their un-normalized images, i.e., $((F^p)^{-T} m_0) \\cdot (F^p s_0) = m_0 \\cdot s_0$. The slip system in the intermediate configuration, $(s_{\\mathrm{int}}, m_{\\mathrm{int}})$, is obtained by normalizing these transformed vectors:\n$$s_{\\mathrm{int}} = \\frac{F^p s_0}{\\|F^p s_0\\|}, \\quad m_{\\mathrm{int}} = \\frac{(F^p)^{-T} m_0}{\\| (F^p)^{-T} m_0 \\|}$$\nSince $s_0 \\cdot m_0 = 0$, it follows that $s_{\\mathrm{int}} \\cdot m_{\\mathrm{int}} = 0$.\n\nThe mapping from $\\mathcal{B}_p$ to $\\mathcal{B}$ is governed by the elastic deformation gradient $F^e$. The problem specifies a particular kinematic assumption for this step. First, $F^e$ is decomposed via the right polar decomposition into a proper orthogonal rotation $R^e \\in \\mathrm{SO}(3)$ and a symmetric positive-definite right stretch tensor $U^e$, such that $F^e = R^e U^e$. The stretch $U^e$ is calculated as the unique positive-definite square root of the right Cauchy-Green tensor $C^e = (F^e)^T F^e$. The rotation is then found as $R^e = F^e (U^e)^{-1}$.\n\nThe problem states that the slip system vectors in the intermediate configuration are mapped to the current configuration by rotation with $R^e$. This implies that the slip system is considered to be embedded in a lattice that is elastically rotated but not stretched.\n$$s = R^e s_{\\mathrm{int}}, \\quad m = R^e m_{\\mathrm{int}}$$\nSince $R^e$ is a rotation and $(s_{\\mathrm{int}}, m_{\\mathrm{int}})$ are orthonormal, the resulting current slip system $(s, m)$ will also consist of orthonormal vectors. This is verified numerically against the tolerance $\\varepsilon_{\\mathrm{orth}} = 10^{-12}$.\n\n**2. Pull-Back Kinematics and Round-Trip Verification**\n\nTo verify the consistency of the kinematic mappings, a round-trip from the current configuration back to the reference configuration is performed. This pull-back operation is the inverse of the push-forward.\n\nStarting with the current slip system $(s, m)$, we first pull back to the intermediate configuration by undoing the rotation $R^e$:\n$$s_{\\mathrm{int}}^{\\mathrm{rec}} = (R^e)^{-1} s = (R^e)^T s, \\quad m_{\\mathrm{int}}^{\\mathrm{rec}} = (R^e)^{-1} m = (R^e)^T m$$\nNext, we pull back from $\\mathcal{B}_p$ to $\\mathcal{B}_0$. A vector is pulled back by $(F^p)^{-1}$ and a covector by $(F^p)^T$. The un-normalized reference vectors are:\n$$s_0' = (F^p)^{-1} s_{\\mathrm{int}}^{\\mathrm{rec}}, \\quad m_0' = (F^p)^T m_{\\mathrm{int}}^{\\mathrm{rec}}$$\nFinally, we normalize these vectors to obtain the recovered reference slip system $(\\tilde{s}_0, \\tilde{m}_0)$:\n$$\\tilde{s}_0 = \\frac{s_0'}{\\|s_0'\\|}, \\quad \\tilde{m}_0 = \\frac{m_0'}{\\|m_0'\\|}$$\nThe round-trip is considered successful if the recovered system $(\\tilde{s}_0, \\tilde{m}_0)$ is equivalent to the original system $(s_0, m_0)$. As a slip system's physical meaning is independent of the sign of its direction or normal vectors, we verify success by checking if their respective absolute dot products are close to $1$: $|\\tilde{s}_0 \\cdot s_0| \\ge 1 - \\varepsilon_{\\mathrm{round}}$ and $|\\tilde{m}_0 \\cdot m_0| \\ge 1 - \\varepsilon_{\\mathrm{round}}$, with $\\varepsilon_{\\mathrm{round}} = 10^{-10}$.\n\n**3. Stress and Resolved Shear Stress Calculation**\n\nThe driving force for slip is the resolved shear stress $\\tau_{\\mathrm{rss}}$, which depends on the Cauchy stress $\\sigma$ and the current slip system $(s, m)$. The problem specifies a compressible Neo-Hookean material model.\n\nThe Kirchhoff stress $\\tau$ is first computed from the elastic deformation. It is given by:\n$$\\tau = \\mu (B^e - I) + \\kappa \\ln(J) I$$\nwhere $B^e = F^e (F^e)^T$ is the left Cauchy-Green (or Finger) tensor for the elastic deformation, $J = \\det(F^e)$ is the elastic volume change, $I$ is the $3 \\times 3$ identity matrix, and $(\\mu, \\kappa)$ are the shear and bulk moduli.\n\nThe Cauchy stress $\\sigma$ is related to the Kirchhoff stress by $\\sigma = \\tau / J$.\n\nThe resolved shear stress $\\tau_{\\mathrm{rss}}$ for the slip system $(s, m)$ is the projection of the traction on the slip plane, $(\\sigma m)$, onto the slip direction $s$:\n$$\\tau_{\\mathrm{rss}} = s \\cdot (\\sigma m)$$\nFor a symmetric Cauchy stress, this is equivalent to the double contraction $\\sigma : P$, where $P = \\frac{1}{2}(s \\otimes m + m \\otimes s)$ is the Schmid tensor.\n\n**4. Verification of Objectivity**\n\nA fundamental principle of continuum mechanics is frame-indifference or objectivity, which requires that material response be independent of the observer (i.e., independent of superposed rigid-body motions). We verify this for the resolved shear stress.\n\nA rigid-body rotation is applied to the current configuration, represented by a proper orthogonal matrix $Q \\in \\mathrm{SO}(3)$. This transforms the elastic deformation gradient to $F^{e\\star} = Q F^e$. All other quantities must be recomputed based on this new deformation.\n\nThe new polar decomposition is $F^{e\\star} = R^{e\\star} U^{e\\star}$. We find that $U^{e\\star} = U^e$ and $R^{e\\star} = Q R^e$. The intermediate configuration and its slip system $(s_{\\mathrm{int}}, m_{\\mathrm{int}})$ are unaffected, as they depend only on $F^p$. The new current slip system is:\n$$s^\\star = R^{e\\star} s_{\\mathrm{int}} = (Q R^e) s_{\\mathrm{int}} = Q s, \\quad m^\\star = R^{e\\star} m_{\\mathrm{int}} = (Q R^e) m_{\\mathrm{int}} = Q m$$\nThe new stress tensor $\\sigma^\\star$ is computed from $F^{e\\star}$. The transformed left Cauchy-Green tensor is $B^{e\\star} = Q B^e Q^T$ and the determinant is invariant, $J^\\star = J$. The resulting Kirchhoff and Cauchy stresses transform as objective second-order tensors:\n$$\\tau^\\star = Q \\tau Q^T, \\quad \\sigma^\\star = Q \\sigma Q^T$$\nThe new resolved shear stress $\\tau_{\\mathrm{rss}}^\\star$ is:\n$$\\tau_{\\mathrm{rss}}^\\star = s^\\star \\cdot (\\sigma^\\star m^\\star) = (Qs) \\cdot ((Q \\sigma Q^T) (Qm)) = s^T Q^T Q \\sigma Q^T Q m = s^T \\sigma m = \\tau_{\\mathrm{rss}}$$\nThe resolved shear stress must be invariant. We verify this calculation numerically by checking that $|\\tau_{\\mathrm{rss}}^\\star - \\tau_{\\mathrm{rss}}| \\le \\varepsilon_{\\mathrm{obj}}$, with $\\varepsilon_{\\mathrm{obj}} = 10^{-10}$. A case passes if and only if all three verification criteria (orthonormality, round-trip, and objectivity) are met.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import inv, det, sqrtm\n\ndef solve():\n    \"\"\"\n    Main function to run the crystal plasticity kinematics validation\n    for all specified test cases.\n    \"\"\"\n\n    class CrystalPlasticityKinematics:\n        \"\"\"\n        A class to encapsulate the computations and state for a single\n        crystal plasticity test case.\n        \"\"\"\n\n        def __init__(self, Fp, Fe, s0, m0, Q, mu_kappa):\n            \"\"\"\n            Initializes the state with the given parameters for one test case.\n            \"\"\"\n            self.Fp = np.asarray(Fp, dtype=float)\n            self.Fe = np.asarray(Fe, dtype=float)\n            self.s0 = np.asarray(s0, dtype=float) / np.linalg.norm(s0)\n            self.m0 = np.asarray(m0, dtype=float) / np.linalg.norm(m0)\n            self.Q = np.asarray(Q, dtype=float)\n            self.mu, self.kappa = mu_kappa\n\n            # Intermediate and current quantities to be computed\n            self.s_int, self.m_int = None, None\n            self.Re, self.Ue = None, None\n            self.s, self.m = None, None\n            self.sigma, self.tau_rss = None, None\n            self.s_star, self.m_star = None, None\n            self.sigma_star, self.tau_rss_star = None, None\n            \n            # Recovered quantities\n            self.s0_tilde, self.m0_tilde = None, None\n\n        def _perform_polar_decomposition(self, F):\n            \"\"\"Computes the right polar decomposition F = R U.\"\"\"\n            C = F.T @ F\n            U = sqrtm(C)\n            # Ensure U is real, although it should be for positive semi-definite C\n            if np.iscomplexobj(U): U = U.real\n            R = F @ inv(U)\n            return R, U\n\n        def _perform_push_forward(self):\n            \"\"\"Task 1: Pushes the slip system from reference to current config.\"\"\"\n            # Map from reference to intermediate configuration\n            Fp_inv_T = inv(self.Fp).T\n            s_int_prime = self.Fp @ self.s0\n            m_int_prime = Fp_inv_T @ self.m0\n            \n            self.s_int = s_int_prime / np.linalg.norm(s_int_prime)\n            self.m_int = m_int_prime / np.linalg.norm(m_int_prime)\n\n            # Polar decomposition of elastic deformation\n            self.Re, self.Ue = self._perform_polar_decomposition(self.Fe)\n\n            # Map from intermediate to current configuration\n            self.s = self.Re @ self.s_int\n            self.m = self.Re @ self.m_int\n\n        def _perform_pull_back(self):\n            \"\"\"Task 2: Pulls the slip system from current back to reference.\"\"\"\n            # From current to intermediate\n            s_int_rec = self.Re.T @ self.s\n            m_int_rec = self.Re.T @ self.m\n            \n            # From intermediate to reference\n            s0_prime_rec = inv(self.Fp) @ s_int_rec\n            m0_prime_rec = self.Fp.T @ m_int_rec\n            \n            self.s0_tilde = s0_prime_rec / np.linalg.norm(s0_prime_rec)\n            self.m0_tilde = m0_prime_rec / np.linalg.norm(m0_prime_rec)\n\n        def _compute_stress_and_rss(self, F, s, m):\n            \"\"\"Task 3: Computes stress and resolved shear stress.\"\"\"\n            J = det(F)\n            if J <= 0: raise ValueError(\"Non-positive determinant.\")\n            Be = F @ F.T\n            I = np.identity(3)\n            tau = self.mu * (Be - I) + self.kappa * np.log(J) * I\n            sigma = tau / J\n            tau_rss = s.dot(sigma @ m)\n            return sigma, tau_rss\n\n        def _compute_rotated_quantities(self):\n            \"\"\"Task 4: Re-computes quantities under superposed rotation.\"\"\"\n            # New elastic deformation gradient\n            Fe_star = self.Q @ self.Fe\n            \n            # New polar decomposition and current slip system\n            Re_star, _ = self._perform_polar_decomposition(Fe_star)\n            self.s_star = Re_star @ self.s_int\n            self.m_star = Re_star @ self.m_int\n\n            # New stress and RSS\n            self.sigma_star, self.tau_rss_star = self._compute_stress_and_rss(\n                Fe_star, self.s_star, self.m_star\n            )\n\n        def run_verifications(self, tolerances):\n            \"\"\"\n            Executes all computational tasks and performs verifications.\n            Returns True if all checks pass, False otherwise.\n            \"\"\"\n            eps_orth, eps_round, eps_obj = tolerances\n\n            # Perform all computations\n            self._perform_push_forward()\n            self._perform_pull_back()\n            self.sigma, self.tau_rss = self._compute_stress_and_rss(self.Fe, self.s, self.m)\n            self._compute_rotated_quantities()\n\n            # Verification (i): Orthonormality in current configuration\n            pass_ortho = (abs(self.s.dot(self.m)) <= eps_orth and\n                          abs(np.linalg.norm(self.s) - 1) <= eps_orth and\n                          abs(np.linalg.norm(self.m) - 1) <= eps_orth)\n\n            # Verification (ii): Round-trip recovery\n            pass_round_trip = (abs(self.s0_tilde.dot(self.s0)) >= 1 - eps_round and\n                               abs(self.m0_tilde.dot(self.m0)) >= 1 - eps_round)\n\n            # Verification (iii): Objectivity of resolved shear stress\n            pass_objectivity = abs(self.tau_rss_star - self.tau_rss) <= eps_obj\n\n            return pass_ortho and pass_round_trip and pass_objectivity\n\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A\n        (np.array([[1, 0.3, 0], [0, 1, 0.2], [0, 0, 1]]),\n         np.array([[1.1, 0.2, 0], [0, 0.9, 0.1], [0, 0, 1.05]]),\n         np.array([1, 0, 0]),\n         np.array([0, 1, 0]),\n         np.array([[0.5, -0.8660254037844386, 0], [0.8660254037844386, 0.5, 0], [0, 0, 1]]),\n         (50, 100)),\n        # Case B\n        (np.diag([0.9, 1.3, 0.8547008547008547]),\n         np.array([[1, 0, 0], [0, np.sqrt(2)/2, -np.sqrt(2)/2], [0, np.sqrt(2)/2, np.sqrt(2)/2]]),\n         np.array([0, 1, 0]),\n         np.array([1, 0, 0]),\n         np.identity(3),\n         (50, 100)),\n        # Case C\n        (np.diag([1.2, 0.9, 0.9259259259]),\n         np.array([[1, 0.15, 0], [0, 1, 0.2], [0.05, 0, 1]]),\n         np.array([1/np.sqrt(2), 1/np.sqrt(2), 0]),\n         np.array([0, 0, 1]),\n         np.array([[0, 1, 0], [0, 0, 1], [1, 0, 0]]),\n         (50, 100))\n    ]\n\n    tolerances = (1e-12, 1e-10, 1e-10) # (eps_orth, eps_round, eps_obj)\n    results = []\n\n    for case_params in test_cases:\n        Fp, Fe, s0, m0, Q, mu_kappa = case_params\n        \n        try:\n            case_runner = CrystalPlasticityKinematics(Fp, Fe, s0, m0, Q, mu_kappa)\n            result = case_runner.run_verifications(tolerances)\n            results.append(result)\n        except (np.linalg.LinAlgError, ValueError) as e:\n            # In case of singular matrices or other numerical issues\n            print(f\"Error processing a case: {e}\")\n            results.append(False)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3556393"}]}