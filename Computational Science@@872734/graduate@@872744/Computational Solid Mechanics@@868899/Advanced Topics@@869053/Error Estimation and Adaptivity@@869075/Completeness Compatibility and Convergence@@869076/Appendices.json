{"hands_on_practices": [{"introduction": "The cornerstone of the isoparametric finite element method is the mapping from a simple parent domain to a physically shaped element. The quality of this geometric transformation, quantified by the Jacobian determinant $J$, is critical for ensuring a valid, non-inverted element and for controlling the interpolation error. This practice delves into this fundamental concept by analyzing a distorted quadrilateral element, directly linking the properties of the Jacobian to the conditions necessary for convergence [@problem_id:3549774].", "problem": "Consider an isoparametric bilinear quadrilateral element ($Q4$) used in the Finite Element Method (FEM). The parent domain is the square with natural coordinates $(\\xi,\\eta) \\in [-1,1] \\times [-1,1]$, and the element mapping to the physical domain is defined by the bilinear shape functions $N_{i}(\\xi,\\eta)$ and the physical corner node coordinates $(x_{i},y_{i})$ for $i=1,2,3,4$. The bilinear shape functions are\n$$\nN_{1}(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta),\\quad\nN_{2}(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta),\\quad\nN_{3}(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta),\\quad\nN_{4}(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta).\n$$\nLet the physical corner node coordinates be\n$$\n(x_{1},y_{1})=(0,0),\\quad (x_{2},y_{2})=(2,0),\\quad (x_{3},y_{3})=(2(1+\\alpha),1),\\quad (x_{4},y_{4})=(0,1),\n$$\nwhere $\\alpha \\ge 0$ is a dimensionless distortion parameter that shifts the top right corner horizontally. The isoparametric mapping is\n$$\nx(\\xi,\\eta) = \\sum_{i=1}^{4} N_{i}(\\xi,\\eta)\\, x_{i},\\qquad y(\\xi,\\eta) = \\sum_{i=1}^{4} N_{i}(\\xi,\\eta)\\, y_{i}.\n$$\nDefine the Jacobian matrix of the mapping as\n$$\n\\mathbf{F}(\\xi,\\eta) = \n\\begin{pmatrix}\n\\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial x}{\\partial \\eta} \\\\\n\\frac{\\partial y}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\eta}\n\\end{pmatrix},\n$$\nand its determinant as $J(\\xi,\\eta) = \\det \\mathbf{F}(\\xi,\\eta)$. Starting from the definitions above:\n- Derive the explicit expression for $J(\\xi,\\eta)$ as a function of $\\alpha$, $\\xi$, and $\\eta$.\n- Using first principles of isoparametric mappings, analyze conditions ensuring positivity $J(\\xi,\\eta)>0$ over the entire parent domain and boundedness quantified by the ratio $J_{\\max}/J_{\\min}$, where $J_{\\min}=\\min_{(\\xi,\\eta)\\in[-1,1]^{2}} J(\\xi,\\eta)$ and $J_{\\max}=\\max_{(\\xi,\\eta)\\in[-1,1]^{2}} J(\\xi,\\eta)$.\n- Explain how positivity and boundedness of $J$ relate to completeness (the ability to represent linear fields), compatibility (continuity of displacement across element boundaries), and convergence (error reduction with mesh refinement), focusing on the amplification of interpolation error via the mapping and its effect on convergence rates.\n\nSuppose, for acceptable element quality in a convergence study, the boundedness requirement is set to\n$$\n\\frac{J_{\\max}}{J_{\\min}} \\le \\kappa_{\\max},\\quad \\kappa_{\\max} = 2.\n$$\nDetermine the largest allowable distortion parameter $\\alpha^{\\star}$ such that both positivity and the boundedness condition hold. Express the final answer for $\\alpha^{\\star}$ as a dimensionless number. No rounding is required.", "solution": "The problem as stated is scientifically sound, well-posed, and contains all necessary information for a unique solution. The concepts of isoparametric mapping, the Jacobian of the transformation, and its properties are central to the theory of the Finite Element Method (FEM). This problem investigates these concepts for a specific bilinear quadrilateral element.\n\nThe solution proceeds in four stages: first, we derive the explicit expression for the Jacobian determinant $J(\\xi,\\eta)$; second, we analyze the conditions for its positivity and boundedness; third, we discuss the implications for the core FEM properties of completeness, compatibility, and convergence; and fourth, we calculate the maximum allowable distortion parameter $\\alpha^{\\star}$ based on the given criteria.\n\nFirst, we determine the mapping from the parent domain coordinates $(\\xi, \\eta)$ to the physical domain coordinates $(x,y)$. The mapping is given by\n$$x(\\xi,\\eta) = \\sum_{i=1}^{4} N_{i}(\\xi,\\eta)\\, x_{i}$$\n$$y(\\xi,\\eta) = \\sum_{i=1}^{4} N_{i}(\\xi,\\eta)\\, y_{i}$$\nThe shape functions $N_i$ and nodal coordinates $(x_i, y_i)$ are provided.\nFor the $x$-coordinate, substituting the given values $x_{1}=0$, $x_{2}=2$, $x_{3}=2(1+\\alpha)$, and $x_{4}=0$:\n$$x(\\xi,\\eta) = N_{2}(\\xi,\\eta) (2) + N_{3}(\\xi,\\eta) (2(1+\\alpha))$$\n$$x(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta)(2) + \\frac{1}{4}(1+\\xi)(1+\\eta)(2(1+\\alpha))$$\n$$x(\\xi,\\eta) = \\frac{1}{2}(1+\\xi) \\left[ (1-\\eta) + (1+\\alpha)(1+\\eta) \\right]$$\n$$x(\\xi,\\eta) = \\frac{1}{2}(1+\\xi) \\left[ 1 - \\eta + 1 + \\eta + \\alpha(1+\\eta) \\right]$$\n$$x(\\xi,\\eta) = \\frac{1}{2}(1+\\xi) \\left[ 2 + \\alpha(1+\\eta) \\right] = (1+\\xi)\\left(1 + \\frac{\\alpha}{2}(1+\\eta)\\right)$$\nFor the $y$-coordinate, substituting the given values $y_{1}=0$, $y_{2}=0$, $y_{3}=1$, and $y_{4}=1$:\n$$y(\\xi,\\eta) = N_{3}(\\xi,\\eta) (1) + N_{4}(\\xi,\\eta) (1)$$\n$$y(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta) + \\frac{1}{4}(1-\\xi)(1+\\eta)$$\n$$y(\\xi,\\eta) = \\frac{1+\\eta}{4} \\left[ (1+\\xi) + (1-\\xi) \\right] = \\frac{1+\\eta}{4}(2) = \\frac{1}{2}(1+\\eta)$$\nNext, we compute the components of the Jacobian matrix $\\mathbf{F}(\\xi,\\eta)$ by taking partial derivatives of $x(\\xi,\\eta)$ and $y(\\xi,\\eta)$ with respect to $\\xi$ and $\\eta$.\n$$\\frac{\\partial x}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi} \\left[ (1+\\xi)\\left(1 + \\frac{\\alpha}{2}(1+\\eta)\\right) \\right] = 1 + \\frac{\\alpha}{2}(1+\\eta)$$\n$$\\frac{\\partial x}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta} \\left[ (1+\\xi)\\left(1 + \\frac{\\alpha}{2}(1+\\eta)\\right) \\right] = (1+\\xi)\\frac{\\alpha}{2}$$\n$$\\frac{\\partial y}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi} \\left[ \\frac{1}{2}(1+\\eta) \\right] = 0$$\n$$\\frac{\\partial y}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta} \\left[ \\frac{1}{2}(1+\\eta) \\right] = \\frac{1}{2}$$\nThe Jacobian matrix is therefore\n$$\n\\mathbf{F}(\\xi,\\eta) = \n\\begin{pmatrix}\n1 + \\frac{\\alpha}{2}(1+\\eta) & \\frac{\\alpha}{2}(1+\\xi) \\\\\n0 & \\frac{1}{2}\n\\end{pmatrix}\n$$\nThe Jacobian determinant, $J(\\xi,\\eta) = \\det \\mathbf{F}(\\xi,\\eta)$, is calculated as:\n$$J(\\xi,\\eta) = \\left( 1 + \\frac{\\alpha}{2}(1+\\eta) \\right) \\left( \\frac{1}{2} \\right) - \\left( \\frac{\\alpha}{2}(1+\\xi) \\right) (0)$$\n$$J(\\xi,\\eta) = \\frac{1}{2} + \\frac{\\alpha}{4}(1+\\eta)$$\nThis is the explicit expression for the Jacobian determinant. Note that it is independent of $\\xi$.\n\nNow, we analyze the positivity and boundedness of $J(\\xi,\\eta)$ on the parent domain $(\\xi,\\eta) \\in [-1,1] \\times [-1,1]$. The parameter $\\alpha$ is given as $\\alpha \\ge 0$.\nThe positivity condition requires $J(\\xi,\\eta) > 0$ for all $(\\xi,\\eta)$ in the domain. To check this, we find the minimum value of $J$, denoted $J_{\\min}$. Since $\\alpha \\ge 0$, $J(\\xi,\\eta)$ is a non-decreasing function of $\\eta$. Thus, its minimum value occurs at the minimum value of $\\eta$, which is $\\eta = -1$.\n$$J_{\\min} = \\min_{(\\xi,\\eta)\\in[-1,1]^{2}} J(\\xi,\\eta) = J(\\xi, -1) = \\frac{1}{2} + \\frac{\\alpha}{4}(1 - 1) = \\frac{1}{2}$$\nSince $J_{\\min} = 1/2$, which is strictly positive, the condition $J(\\xi,\\eta) > 0$ is satisfied for all $\\alpha \\ge 0$ over the entire parent element. This ensures that the isoparametric mapping is always non-singular and one-to-one for this family of elements.\nFor the boundedness analysis, we need the maximum value of $J$, denoted $J_{\\max}$. Since $J$ is non-decreasing with $\\eta$, its maximum occurs at $\\eta = 1$.\n$$J_{\\max} = \\max_{(\\xi,\\eta)\\in[-1,1]^{2}} J(\\xi,\\eta) = J(\\xi, 1) = \\frac{1}{2} + \\frac{\\alpha}{4}(1 + 1) = \\frac{1}{2} + \\frac{\\alpha}{2}$$\nThe boundedness is quantified by the ratio $J_{\\max}/J_{\\min}$:\n$$\\frac{J_{\\max}}{J_{\\min}} = \\frac{\\frac{1}{2} + \\frac{\\alpha}{2}}{\\frac{1}{2}} = 1 + \\alpha$$\n\nNext, we relate these properties of the Jacobian to the concepts of completeness, compatibility, and convergence in FEM.\n**Completeness** requires that an element's shape functions can exactly represent any linear displacement field (a constant strain state). For the bilinear Q4 element, the shape functions are constructed to satisfy $\\sum_{i=1}^{4} N_{i} = 1$ and can reproduce any function of the form $a+bx+cy$. This property is inherent to the shape functions and ensures the element passes the patch test, a necessary condition for convergence. The role of the Jacobian here is secondary but fundamental: a valid, invertible mapping ($J > 0$) is required to uniquely relate the physical space $(x,y)$ to the parent space $(\\xi,\\eta)$, which is a prerequisite for the entire formulation to be meaningful.\n**Compatibility** requires that the displacement field is continuous across inter-element boundaries. For isoparametric elements, using the same shape functions for geometry and displacements guarantees this. The mapping of a common edge between two elements is defined only by the coordinates of the nodes on that edge. If two elements share these nodes, they share the identical physical boundary, and the displacement field, interpolated along this edge by the same nodal values, will be continuous. A positive Jacobian ($J>0$) throughout the element, including its boundary, ensures a non-degenerate geometry where elements do not overlap or fold, which is essential for constituting a valid, compatible mesh.\n**Convergence** refers to the error in the numerical solution diminishing as the mesh is refined. Error estimates in FEM show that the approximation error is bounded by a constant $C$ that depends on the element geometry, among other factors. This constant $C$ is adversely affected by element distortion from its ideal shape (a square in the parent domain). For an isoparametric mapping, the norms of the Jacobian matrix $\\mathbf{F}$ and its inverse $\\mathbf{F}^{-1}$ appear in this constant. A large variation in the Jacobian determinant $J$ within an element is a sign of high distortion. The ratio $J_{\\max}/J_{\\min}$ is a common metric for this distortion. If this ratio is large, the constant $C$ in the error bound can become large, leading to poor accuracy for a given mesh size $h$. For convergence at the optimal theoretical rate, it is necessary that this ratio remains bounded for all elements in a sequence of refined meshes. A singularity ($J=0$) corresponds to an infinite ratio, breaking down the error estimates and leading to a failure of convergence.\n\nFinally, we determine the largest allowable distortion parameter $\\alpha^{\\star}$ given the constraint $\\frac{J_{\\max}}{J_{\\min}} \\le \\kappa_{\\max}$, with $\\kappa_{\\max} = 2$.\nWe have already found the positivity condition $J>0$ is always satisfied for $\\alpha \\ge 0$.\nThe boundedness condition is:\n$$\\frac{J_{\\max}}{J_{\\min}} \\le 2$$\nSubstituting our derived expression for the ratio:\n$$1 + \\alpha \\le 2$$\nThis simplifies to:\n$$\\alpha \\le 1$$\nSince the problem specifies $\\alpha \\ge 0$, the acceptable range for the distortion parameter is $0 \\le \\alpha \\le 1$. The largest allowable value, $\\alpha^{\\star}$, is the upper bound of this range.\n$$\\alpha^{\\star} = 1$$", "answer": "$$\\boxed{1}$$", "id": "3549774"}, {"introduction": "For a finite element formulation to be convergent, it must be stable, meaning any non-rigid deformation must have a positive strain energy cost. This stability can be compromised by numerical shortcuts like reduced integration, which can fail to detect certain deformation patterns known as zero-energy or 'hourglass' modes. In this exercise, you will derive these pathological modes from first principles for a classic underintegrated element and understand why they lead to a loss of stability and a failure to converge [@problem_id:3549776].", "problem": "Consider a two-dimensional, linear elastic, plane strain quadrilateral finite element with four nodes ($Q4$ element) defined over the parent coordinates $(\\xi,\\eta) \\in [-1,1]\\times[-1,1]$. The node ordering is $1:(-1,-1)$, $2:(+1,-1)$, $3:(+1,+1)$, $4:(-1,+1)$. The element uses bilinear interpolation for the displacement field $\\boldsymbol{u}(\\xi,\\eta) = u(\\xi,\\eta)\\,\\boldsymbol{e}_x + v(\\xi,\\eta)\\,\\boldsymbol{e}_y$, where $u(\\xi,\\eta)$ and $v(\\xi,\\eta)$ are interpolated from nodal values via four shape functions $N_i(\\xi,\\eta)$ that form a partition of unity and satisfy the Kronecker-delta interpolation property at the nodes. Assume a rectangular mapping to physical coordinates with unit Jacobian at $(\\xi,\\eta)=(0,0)$ so that derivatives with respect to physical coordinates equal derivatives with respect to the parent coordinates at the element center. The strain is computed under the small-strain kinematics, with the strain vector defined as $\\boldsymbol{\\varepsilon} = \\begin{pmatrix} \\varepsilon_{xx} & \\varepsilon_{yy} & \\gamma_{xy} \\end{pmatrix}^{\\mathsf{T}}$ using the standard definitions $\\varepsilon_{xx} = \\partial u/\\partial x$, $\\varepsilon_{yy} = \\partial v/\\partial y$, and $\\gamma_{xy} = \\partial u/\\partial y + \\partial v/\\partial x$. The element stiffness uses one-point Gaussian quadrature at the center $(\\xi,\\eta)=(0,0)$ (underintegration). The material is homogeneous, isotropic, and linearly elastic, but you should keep all material parameters symbolic.\n\nStarting from these fundamentals, do the following:\n\n1. Derive the discrete strain operator $\\boldsymbol{B}$ at $(\\xi,\\eta)=(0,0)$ in terms of the four nodal displacement components $u_i$ and $v_i$ ($i=1,\\dots,4$). Express $\\varepsilon_{xx}$, $\\varepsilon_{yy}$, and $\\gamma_{xy}$ at the center as linear forms of the nodal values. Use only the properties of bilinear shape functions and their derivatives at the center implied by the node locations; do not assume any formula not derivable from these properties.\n\n2. Determine all nontrivial nodal displacement patterns $(u_1,v_1,u_2,v_2,u_3,v_3,u_4,v_4)$ that lie in the kernel of $\\boldsymbol{B}$ and are not rigid body modes (two translations and one in-plane rotation). Identify and construct explicitly the hourglass modes as zero-energy kinematic patterns introduced by underintegration for this $Q4$ element, and show that they produce $\\boldsymbol{\\varepsilon}=\\boldsymbol{0}$ at $(\\xi,\\eta)=(0,0)$ while being non-rigid.\n\n3. Explain, using the principles of completeness, compatibility, and convergence, why these hourglass modes violate compatibility and stability, and how underintegration causes the loss of coercivity of the discrete bilinear form. Ground your explanation in the variational structure of the finite element method (Finite Element Method (FEM)) and the role of adequate quadrature.\n\n4. Focus on the hourglass mode defined by $u$-displacements alternating as $+1,-1,+1,-1$ at nodes $1,2,3,4$ respectively, with $v$-displacements all zero. Normalize its corresponding $8$-component nodal displacement vector to have Euclidean norm equal to $1$, and report the normalized vector in the ordering $(u_1,v_1,u_2,v_2,u_3,v_3,u_4,v_4)$.\n\nNo numerical values are to be substituted for material parameters. Your final reported result must be the single normalized hourglass mode vector. No rounding is required.", "solution": "The problem is subjected to validation and is found to be scientifically grounded, well-posed, objective, and internally consistent. It represents a standard and fundamental analysis within the field of computational solid mechanics. We may therefore proceed with a complete solution.\n\nThe problem requires a multi-part analysis of a four-node quadrilateral ($Q4$) plane strain finite element, focusing on the pathological effects of underintegration. We will address each part in sequence.\n\n**1. Derivation of the Discrete Strain Operator $\\boldsymbol{B}$ at the Element Center**\n\nThe displacement field $(u,v)$ within the element is interpolated from the nodal displacements $(u_i,v_i)$ using bilinear shape functions $N_i(\\xi,\\eta)$. The displacement at any point $(\\xi,\\eta)$ in the parent domain is given by:\n$$\nu(\\xi,\\eta) = \\sum_{i=1}^{4} N_i(\\xi,\\eta) u_i\n$$\n$$\nv(\\xi,\\eta) = \\sum_{i=1}^{4} N_i(\\xi,\\eta) v_i\n$$\nThe bilinear shape functions for a $Q4$ element with nodes at $(\\xi_i, \\eta_i) \\in \\{(-1,-1), (1,-1), (1,1), (-1,1)\\}$ are defined as:\n$$\nN_i(\\xi,\\eta) = \\frac{1}{4}(1 + \\xi_i\\xi)(1 + \\eta_i\\eta)\n$$\nThe problem states that due to a rectangular mapping with a unit Jacobian at the element center $(\\xi,\\eta)=(0,0)$, the physical derivatives equal the parent coordinate derivatives at this specific point. That is, $\\frac{\\partial}{\\partial x} = \\frac{\\partial}{\\partial \\xi}$ and $\\frac{\\partial}{\\partial y} = \\frac{\\partial}{\\partial \\eta}$ at $(\\xi,\\eta)=(0,0)$.\n\nThe strain components $\\varepsilon_{xx}$, $\\varepsilon_{yy}$, and $\\gamma_{xy}$ are defined by the derivatives of the displacement field. We must first find the derivatives of the shape functions.\n$$\n\\frac{\\partial N_i}{\\partial \\xi} = \\frac{1}{4} \\xi_i (1 + \\eta_i\\eta) \\quad \\implies \\quad \\frac{\\partial N_i}{\\partial \\xi}\\bigg|_{(0,0)} = \\frac{1}{4} \\xi_i\n$$\n$$\n\\frac{\\partial N_i}{\\partial \\eta} = \\frac{1}{4} \\eta_i (1 + \\xi_i\\xi) \\quad \\implies \\quad \\frac{\\partial N_i}{\\partial \\eta}\\bigg|_{(0,0)} = \\frac{1}{4} \\eta_i\n$$\nThe nodal coordinates in the parent domain are $\\xi = (-1, +1, +1, -1)^{\\mathsf{T}}$ and $\\eta = (-1, -1, +1, +1)^{\\mathsf{T}}$ for nodes $i=1,2,3,4$.\n\nNow, we can compute the strain components at the center point $(0,0)$:\n$$\n\\varepsilon_{xx}(0,0) = \\frac{\\partial u}{\\partial x}\\bigg|_{(0,0)} = \\frac{\\partial u}{\\partial \\xi}\\bigg|_{(0,0)} = \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial \\xi}\\bigg|_{(0,0)} u_i = \\frac{1}{4} \\sum_{i=1}^{4} \\xi_i u_i\n$$\n$$\n\\varepsilon_{xx}(0,0) = \\frac{1}{4}(-1 \\cdot u_1 + 1 \\cdot u_2 + 1 \\cdot u_3 - 1 \\cdot u_4) = \\frac{1}{4}(-u_1 + u_2 + u_3 - u_4)\n$$\nSimilarly for $\\varepsilon_{yy}$:\n$$\n\\varepsilon_{yy}(0,0) = \\frac{\\partial v}{\\partial y}\\bigg|_{(0,0)} = \\frac{\\partial v}{\\partial \\eta}\\bigg|_{(0,0)} = \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial \\eta}\\bigg|_{(0,0)} v_i = \\frac{1}{4} \\sum_{i=1}^{4} \\eta_i v_i\n$$\n$$\n\\varepsilon_{yy}(0,0) = \\frac{1}{4}(-1 \\cdot v_1 - 1 \\cdot v_2 + 1 \\cdot v_3 + 1 \\cdot v_4) = \\frac{1}{4}(-v_1 - v_2 + v_3 + v_4)\n$$\nAnd for the shear strain $\\gamma_{xy}$:\n$$\n\\gamma_{xy}(0,0) = \\frac{\\partial u}{\\partial y}\\bigg|_{(0,0)} + \\frac{\\partial v}{\\partial x}\\bigg|_{(0,0)} = \\frac{\\partial u}{\\partial \\eta}\\bigg|_{(0,0)} + \\frac{\\partial v}{\\partial \\xi}\\bigg|_{(0,0)}\n$$\n$$\n\\gamma_{xy}(0,0) = \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial \\eta}\\bigg|_{(0,0)} u_i + \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial \\xi}\\bigg|_{(0,0)} v_i = \\frac{1}{4} \\sum_{i=1}^{4} \\eta_i u_i + \\frac{1}{4} \\sum_{i=1}^{4} \\xi_i v_i\n$$\n$$\n\\gamma_{xy}(0,0) = \\frac{1}{4}(-u_1 - u_2 + u_3 + u_4) + \\frac{1}{4}(-v_1 + v_2 + v_3 - v_4)\n$$\nThe discrete strain-displacement relation $\\boldsymbol{\\varepsilon} = \\boldsymbol{B}\\boldsymbol{d}$ relates the strain vector $\\boldsymbol{\\varepsilon} = (\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy})^{\\mathsf{T}}$ to the nodal displacement vector $\\boldsymbol{d} = (u_1, v_1, u_2, v_2, u_3, v_3, u_4, v_4)^{\\mathsf{T}}$. From the expressions above, the matrix $\\boldsymbol{B}$ evaluated at the center $(\\xi,\\eta)=(0,0)$ is:\n$$\n\\boldsymbol{B}(0,0) = \\frac{1}{4} \\begin{pmatrix}\n-1 & 0 & 1 & 0 & 1 & 0 & -1 & 0 \\\\\n0 & -1 & 0 & -1 & 0 & 1 & 0 & 1 \\\\\n-1 & -1 & -1 & 1 & 1 & 1 & 1 & -1\n\\end{pmatrix}\n$$\n\n**2. Identification of Hourglass Modes**\n\nHourglass modes are non-rigid-body displacement patterns that produce zero strain at the quadrature point(s). They are vectors in the kernel of the discrete strain operator $\\boldsymbol{B}(0,0)$, excluding the vectors corresponding to rigid body motion. We must find the null space of $\\boldsymbol{B}(0,0)$, i.e., all vectors $\\boldsymbol{d} \\neq \\boldsymbol{0}$ such that $\\boldsymbol{B}(0,0)\\boldsymbol{d} = \\boldsymbol{0}$. This leads to a system of three linear equations:\n$$\n-u_1 + u_2 + u_3 - u_4 = 0 \\quad (1)\n$$\n$$\n-v_1 - v_2 + v_3 + v_4 = 0 \\quad (2)\n$$\n$$\n-u_1 - u_2 + u_3 + u_4 - v_1 + v_2 + v_3 - v_4 = 0 \\quad (3)\n$$\nThe matrix $\\boldsymbol{B}(0,0)$ has rank $3$, so its kernel has dimension $8-3=5$. Three of these dimensions correspond to the rigid body modes (two translations, one in-plane rotation), which produce zero strain everywhere and are thus necessarily in the kernel of $\\boldsymbol{B}(0,0)$. The remaining $5-3=2$ dimensions correspond to the hourglass modes.\n\nThe rigid body modes are:\n1.  **Translation in x-direction**: $\\boldsymbol{d}_{R1} = (1, 0, 1, 0, 1, 0, 1, 0)^{\\mathsf{T}}$.\n2.  **Translation in y-direction**: $\\boldsymbol{d}_{R2} = (0, 1, 0, 1, 0, 1, 0, 1)^{\\mathsf{T}}$.\n3.  **In-plane rotation**: For a square element, nodal displacements for a small rotation are $\\boldsymbol{u} \\propto (-\\eta_i)$ and $\\boldsymbol{v} \\propto (\\xi_i)$. This gives $\\boldsymbol{d}_{R3} \\propto (-(-1),-1, -(-1),1, -(1),1, -(1),-1) = (1,-1,1,1,-1,1,-1,-1)^{\\mathsf{T}}$.\nOne can verify that these three vectors satisfy equations $(1)$, $(2)$, and $(3)$.\n\nThe two hourglass modes are vectors in the kernel that are linearly independent of the rigid body modes. We can construct them by observing patterns that satisfy the kernel equations. Let us define the nodal vectors $\\boldsymbol{h}_{xy} = (1, -1, 1, -1)^{\\mathsf{T}}$.\n\n*   **Hourglass Mode 1 (HG1)**: Let $\\boldsymbol{u} = c_1 \\boldsymbol{h}_{xy} = (c_1, -c_1, c_1, -c_1)^{\\mathsf{T}}$ and $\\boldsymbol{v} = \\boldsymbol{0}$.\n    Equation (1): $-c_1 + (-c_1) + c_1 - (-c_1) = 0$.\n    Equation (2): $0 = 0$.\n    Equation (3): $-c_1 - (-c_1) + c_1 + (-c_1) + 0 = 0$.\n    This mode satisfies the zero-strain condition at the center. The corresponding displacement vector (with $c_1=1$) is $\\boldsymbol{d}_{H1} = (1, 0, -1, 0, 1, 0, -1, 0)^{\\mathsf{T}}$. This represents a kinematic pattern where the displacement field is $u(\\xi,\\eta) \\propto \\xi\\eta$ and $v(\\xi,\\eta)=0$.\n\n*   **Hourglass Mode 2 (HG2)**: Let $\\boldsymbol{u} = \\boldsymbol{0}$ and $\\boldsymbol{v} = c_2 \\boldsymbol{h}_{xy} = (c_2, -c_2, c_2, -c_2)^{\\mathsf{T}}$.\n    Equation (1): $0 = 0$.\n    Equation (2): $-c_2 - (-c_2) + c_2 + (-c_2) = 0$.\n    Equation (3): $0 - c_2 + (-c_2) + c_2 - (-c_2) = 0$.\n    This mode also satisfies the zero-strain condition. The corresponding displacement vector (with $c_2=1$) is $\\boldsymbol{d}_{H2} = (0, 1, 0, -1, 0, 1, 0, -1)^{\\mathsf{T}}$. This pattern corresponds to $u(\\xi,\\eta)=0$ and $v(\\xi,\\eta) \\propto \\xi\\eta$.\n\nThese two vectors, $\\boldsymbol{d}_{H1}$ and $\\boldsymbol{d}_{H2}$, are linearly independent of each other and of the rigid body modes. They form a basis for the space of hourglass modes for this element.\n\n**3. Explanation of Pathological Behavior**\n\nThe presence of hourglass modes is a numerical pathology that violates fundamental requirements for a stable and convergent finite element formulation.\n\n*   **Completeness**: The bilinear interpolation space of the $Q4$ element is \"complete\" in that it can represent rigid-body motion and constant strain states exactly. The interpolation itself can also represent the hourglassing fields (e.g., $u=\\xi\\eta$). The failure is not in the completeness of the interpolation but in the inability of the underintegrated quadrature rule to detect the energy associated with these modes.\n\n*   **Compatibility and Stability**: The core issue lies with stability. In the variational formulation of the finite element method, the total potential energy is minimized. The strain energy, a quadratic form of the nodal displacements, is $U = \\frac{1}{2}\\boldsymbol{d}^{\\mathsf{T}}\\boldsymbol{K}\\boldsymbol{d}$, where $\\boldsymbol{K}$ is the element stiffness matrix. The stiffness matrix is computed by integrating the product $\\boldsymbol{B}^{\\mathsf{T}}\\boldsymbol{C}\\boldsymbol{B}$ over the element volume, where $\\boldsymbol{C}$ is the material constitutive matrix. For a stable element, $\\boldsymbol{K}$ must be positive definite on the space of deformations that are not rigid-body motions. This property, known as coercivity of the discrete bilinear form, ensures that any non-rigid deformation incurs a positive strain energy cost, leading to a unique solution.\n\n    When one-point quadrature is used, the stiffness matrix is approximated as $\\boldsymbol{K} \\approx (\\boldsymbol{B}^{\\mathsf{T}}(0,0)\\boldsymbol{C}\\boldsymbol{B}(0,0)) \\times \\text{Area}$. If $\\boldsymbol{d}$ is an hourglass mode vector, then by definition $\\boldsymbol{B}(0,0)\\boldsymbol{d}=\\boldsymbol{0}$. Consequently, the strain energy associated with this mode is computed as zero:\n    $$\n    U_{HG} = \\frac{1}{2}\\boldsymbol{d}_{HG}^{\\mathsf{T}}\\boldsymbol{K}\\boldsymbol{d}_{HG} = \\frac{1}{2} (\\boldsymbol{B}(0,0)\\boldsymbol{d}_{HG})^{\\mathsf{T}} \\boldsymbol{C} (\\boldsymbol{B}(0,0)\\boldsymbol{d}_{HG}) \\times \\text{Area} = 0\n    $$\n    This is despite the fact that the true strain energy of an hourglass mode is non-zero, as the strains are non-zero everywhere except at the element center. For example, for HG1, $u=\\xi\\eta$, so $\\varepsilon_{xx}=\\partial u/\\partial x \\propto \\eta$ and $\\gamma_{xy}=\\partial u/\\partial y \\propto \\xi$. The strain energy density is non-zero, and its integral over the element is positive.\n\n    The failure of the quadrature to \"see\" this energy means the discrete stiffness matrix $\\boldsymbol{K}$ is singular (it has a kernel larger than just the rigid-body modes). This loss of coercivity means the discrete system $\\boldsymbol{K}\\boldsymbol{d}=\\boldsymbol{f}$ is unstable and may not have a unique solution. Within a mesh, these zero-energy modes can be excited without any energy penalty, leading to spurious, oscillatory \"checkerboard\" patterns in the solution that have no physical basis. While the displacement field of a single element might be continuous ($C^0$ compatible), a global solution composed of such unpenalized modes often appears highly discontinuous or \"incompatible\" in a physical sense.\n\n*   **Convergence**: A stable method is a prerequisite for convergence. Since the underintegrated element is unstable, it is not guaranteed to converge to the correct solution as the mesh is refined ($h \\to 0$). The numerical solution can be polluted by arbitrary combinations of hourglass modes, preventing the error from vanishing.\n\n**4. Normalization of a Specific Hourglass Mode**\n\nThe problem specifies an hourglass mode with $u$-displacements alternating as $(+1, -1, +1, -1)$ at nodes $1, 2, 3, 4$ respectively, and all $v$-displacements being zero. This corresponds to the nodal displacement values:\n$$\nu_1 = 1, \\quad u_2 = -1, \\quad u_3 = 1, \\quad u_4 = -1\n$$\n$$\nv_1 = 0, \\quad v_2 = 0, \\quad v_3 = 0, \\quad v_4 = 0\n$$\nThe corresponding $8$-component nodal displacement vector $\\boldsymbol{d}$ in the ordering $(u_1, v_1, u_2, v_2, u_3, v_3, u_4, v_4)$ is:\n$$\n\\boldsymbol{d} = (1, 0, -1, 0, 1, 0, -1, 0)^{\\mathsf{T}}\n$$\nWe must normalize this vector to have a Euclidean norm of $1$. First, we compute its current norm, $||\\boldsymbol{d}||_2$:\n$$\n||\\boldsymbol{d}||_2 = \\sqrt{1^2 + 0^2 + (-1)^2 + 0^2 + 1^2 + 0^2 + (-1)^2 + 0^2} = \\sqrt{1 + 1 + 1 + 1} = \\sqrt{4} = 2\n$$\nThe normalized vector, $\\boldsymbol{d}_{\\text{norm}}$, is obtained by dividing $\\boldsymbol{d}$ by its norm:\n$$\n\\boldsymbol{d}_{\\text{norm}} = \\frac{1}{||\\boldsymbol{d}||_2} \\boldsymbol{d} = \\frac{1}{2} (1, 0, -1, 0, 1, 0, -1, 0)^{\\mathsf{T}}\n$$\n$$\n\\boldsymbol{d}_{\\text{norm}} = (\\frac{1}{2}, 0, -\\frac{1}{2}, 0, \\frac{1}{2}, 0, -\\frac{1}{2}, 0)^{\\mathsf{T}}\n$$\nThis is the required normalized hourglass mode vector.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{2} & 0 & -\\frac{1}{2} & 0 & \\frac{1}{2} & 0 & -\\frac{1}{2} & 0\n\\end{pmatrix}\n}\n$$", "id": "3549776"}, {"introduction": "In a well-posed finite element approximation, the total error arises from two main sources: the inability of the polynomial basis to perfectly match the true solution within an element (a completeness issue) and the constraints imposed by enforcing continuity between elements (a compatibility issue). This advanced practice introduces a powerful analytical tool to dissect the total approximation error into these distinct, orthogonal components. By implementing this decomposition, you will gain a deeper, quantitative understanding of how different aspects of the formulation contribute to the overall error [@problem_id:3549795].", "problem": "Consider a scalar, two-dimensional anisotropic bending surrogate defined on the unit square domain $\\Omega = [0,1]\\times[0,1]$. Let the manufactured exact displacement field be $u(x,y) = d_1 x^2 + d_2 y^2 + d_3 x y$ with constants $d_1$, $d_2$, and $d_3$, and let the approximate displacement $u_h$ be the continuous piecewise linear nodal interpolant of $u$ on a conforming triangular mesh obtained by subdividing a uniform rectangular grid of $N_x \\times N_y$ cells into right triangles. The energy weight is an anisotropic, symmetric positive-definite tensor $A \\in \\mathbb{R}^{2\\times 2}$ with principal stiffnesses $a_x>0$, $a_y>0$, and an in-plane rotation $\\theta$ (in degrees), so that\n$$\nA(\\theta) \\;=\\; R(\\theta)^\\top \\begin{bmatrix} a_x & 0 \\\\ 0 & a_y \\end{bmatrix} R(\\theta), \\quad\nR(\\theta) \\;=\\; \\begin{bmatrix} \\cos(\\theta_r) & -\\sin(\\theta_r) \\\\ \\sin(\\theta_r) & \\cos(\\theta_r) \\end{bmatrix}, \\quad \\theta_r = \\theta\\cdot \\frac{\\pi}{180}.\n$$\nThe anisotropic $H^1$ seminorm of an error $e = u - u_h$ is defined by\n$$\n\\vert e \\vert_{H^1,A}^2 \\;=\\; \\int_{\\Omega} \\nabla e \\cdot A \\, \\nabla e \\,\\mathrm{d}x.\n$$\nFor each mesh triangle $K$ of area $\\vert K\\vert$, define the exact mean gradient of $u$ over $K$ by\n$$\ng_K \\;=\\; \\frac{1}{\\vert K\\vert} \\int_K \\nabla u \\,\\mathrm{d}x.\n$$\nOn each $K$, the discrete gradient $\\nabla u_h\\vert_K$ is constant. Using only the definitions above, derive a decomposition of $\\vert e \\vert_{H^1,A}^2$ into two orthogonal residuals that separate intra-element polynomial reproduction (completeness) from interelement continuity effects (compatibility), namely\n$$\n\\vert e \\vert_{H^1,A}^2 \\;=\\; \\sum_{K} \\int_K (\\nabla u - g_K)\\cdot A \\,(\\nabla u - g_K)\\,\\mathrm{d}x\n\\;+\\; \\sum_{K} \\vert K\\vert\\,(g_K - \\nabla u_h\\vert_K)^\\top A \\,(g_K - \\nabla u_h\\vert_K),\n$$\nand prove the orthogonality of the two residual contributions in the $A$-weighted inner product. Explain clearly why the first term quantifies completeness (polynomial reproduction capability inside elements) and the second term quantifies compatibility (the manner in which interelement constraints lead to broken gradients).\n\nThen, implement a program that:\n- Constructs a uniform triangulation of $\\Omega$ with $N_x \\times N_y$ rectangular cells split along the lower-left to upper-right diagonal.\n- Computes $u_h$ by nodal interpolation of $u$.\n- For each triangle, evaluates:\n    - The area $\\vert K\\vert$,\n    - The constant discrete gradient $\\nabla u_h\\vert_K$,\n    - The exact mean gradient $g_K$ (noting that $\\nabla u$ is linear for quadratic $u$ so $g_K$ equals $\\nabla u$ at the triangle centroid),\n    - The integrals of the completeness and total error contributions using a quadrature rule exact for quadratic polynomials on triangles.\n- Aggregates the total error $\\vert e \\vert_{H^1,A}$, the completeness component, and the compatibility component, verifies the orthogonality identity numerically, and reports the ratios of the completeness and compatibility components to the total error squared.\n\nUse the following fixed manufactured coefficients in $u$: $d_1 = 1.0$, $d_2 = 0.2$, $d_3 = 0.5$. There are four test cases with $(N_x, N_y, a_x, a_y, \\theta)$ specified as:\n1. $(8, 8, 1.0, 100.0, 0)$,\n2. $(4, 4, 1000.0, 1.0, 0)$,\n3. $(16, 16, 1.0, 1.0, 0)$,\n4. $(6, 6, 100.0, 10.0, 45)$.\nThe angle $\\theta$ is given in degrees. No physical units are required; all quantities are dimensionless.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, output a list of six entries:\n- The total anisotropic $H^1$ seminorm of the error $\\vert e \\vert_{H^1,A}$ (a float),\n- The completeness component $\\left(\\sum_{K} \\int_K (\\nabla u - g_K)\\cdot A \\,(\\nabla u - g_K)\\,\\mathrm{d}x\\right)^{1/2}$ (a float),\n- The compatibility component $\\left(\\sum_{K} \\vert K\\vert\\,(g_K - \\nabla u_h\\vert_K)^\\top A \\,(g_K - \\nabla u_h\\vert_K)\\right)^{1/2}$ (a float),\n- A boolean indicating whether the orthogonal decomposition identity holds to within a relative tolerance of $10^{-10}$ for the squared seminorms,\n- The decimal ratio of the completeness squared to the total squared,\n- The decimal ratio of the compatibility squared to the total squared.\n\nThe final output format must be exactly: a single line with a Python list of four lists, one per test case, for example, $[[r_{1,1},r_{1,2},\\dots],[r_{2,1},\\dots],\\dots]$.", "solution": "The problem statement is assessed as valid, being scientifically grounded in computational solid mechanics, well-posed, objective, and self-contained. The task is to first derive and explain an orthogonal decomposition of the approximation error in the anisotropic $H^1$ seminorm and then to implement a numerical verification.\n\nThe derivation of the error decomposition begins with the definition of the squared anisotropic $H^1$ seminorm of the error $e = u - u_h$:\n$$ \\vert e \\vert_{H^1,A}^2 = \\int_{\\Omega} (\\nabla e)^\\top A (\\nabla e) \\,\\mathrm{d}x $$\nwhere $\\Omega$ is the domain, $u$ is the exact solution, $u_h$ is the finite element approximation, and $A$ is the symmetric positive-definite weight tensor. The integral over the domain $\\Omega$ can be expressed as a sum of integrals over the individual triangular elements $K$ of the mesh:\n$$ \\vert e \\vert_{H^1,A}^2 = \\sum_K \\int_K (\\nabla u - \\nabla u_h)^\\top A (\\nabla u - \\nabla u_h) \\,\\mathrm{d}x $$\nWithin each element $K$, we introduce the exact mean gradient $g_K = \\frac{1}{\\vert K\\vert} \\int_K \\nabla u \\,\\mathrm{d}x$ by adding and subtracting it inside the term $(\\nabla u - \\nabla u_h)$:\n$$ \\nabla u - \\nabla u_h = (\\nabla u - g_K) + (g_K - \\nabla u_h) $$\nSubstituting this into the integrand for a single element gives:\n$$ \\int_K [(\\nabla u - g_K) + (g_K - \\nabla u_h)]^\\top A [(\\nabla u - g_K) + (g_K - \\nabla u_h)] \\,\\mathrm{d}x $$\nBy expanding this quadratic form, we obtain three terms:\n$$ \\int_K (\\nabla u - g_K)^\\top A (\\nabla u - g_K) \\,\\mathrm{d}x \\quad (I) $$\n$$ + \\int_K (g_K - \\nabla u_h)^\\top A (g_K - \\nabla u_h) \\,\\mathrm{d}x \\quad (II) $$\n$$ + 2 \\int_K (\\nabla u - g_K)^\\top A (g_K - \\nabla u_h) \\,\\mathrm{d}x \\quad (III) $$\nWe analyze each term. For term (III), we note that for a piecewise linear approximation $u_h$, the gradient $\\nabla u_h\\vert_K$ is constant over the element $K$. The mean gradient $g_K$ is also a constant vector for the element $K$. Similarly, the tensor $A$ is constant. Thus, the term $(g_K - \\nabla u_h\\vert_K)$ can be factored out of the integral:\n$$ (III) = 2 \\left( \\int_K (\\nabla u - g_K) \\,\\mathrm{d}x \\right)^\\top A (g_K - \\nabla u_h\\vert_K) $$\nBy the definition of the mean gradient $g_K$, we have $\\int_K \\nabla u \\,\\mathrm{d}x = \\vert K\\vert g_K$. The integral of the constant vector $g_K$ is $\\int_K g_K \\,\\mathrm{d}x = \\vert K\\vert g_K$. Therefore, the integral in term (III) evaluates to the zero vector:\n$$ \\int_K (\\nabla u - g_K) \\,\\mathrm{d}x = \\int_K \\nabla u \\,\\mathrm{d}x - \\int_K g_K \\,\\mathrm{d}x = \\vert K\\vert g_K - \\vert K\\vert g_K = \\mathbf{0} $$\nConsequently, the cross-term (III) is zero for every element $K$. This proves the orthogonality of the vector fields $(\\nabla u - g_K)$ and $(g_K - \\nabla u_h\\vert_K)$ in the $A$-weighted inner product over each element, $\\langle v, w \\rangle_{A,K} = \\int_K v^\\top A w \\,\\mathrm{d}x$.\n\nNext, we simplify term (II). Since the entire integrand $(g_K - \\nabla u_h\\vert_K)^\\top A (g_K - \\nabla u_h\\vert_K)$ is a constant scalar value on element $K$, the integral is simply this constant multiplied by the area of the element, $\\vert K\\vert$:\n$$ (II) = \\vert K\\vert (g_K - \\nabla u_h\\vert_K)^\\top A (g_K - \\nabla u_h\\vert_K) $$\nCombining these results and summing over all elements $K$ yields the final decomposition:\n$$ \\vert e \\vert_{H^1,A}^2 = \\sum_K \\int_K (\\nabla u - g_K)^\\top A (\\nabla u - g_K) \\,\\mathrm{d}x + \\sum_K \\vert K\\vert (g_K - \\nabla u_h\\vert_K)^\\top A (g_K - \\nabla u_h\\vert_K) $$\nThis is the desired identity. The two terms on the right-hand side represent orthogonal contributions to the total squared error.\n\nExplanation of the decomposition's components:\n\n1.  **Completeness Residual**: The first term, $\\sum_K \\int_K (\\nabla u - g_K)^\\top A (\\nabla u - g_K) \\,\\mathrm{d}x$, quantifies the intra-element error arising from the inherent limitations of the polynomial space used for the approximation. It measures how much the true gradient $\\nabla u$ varies within each element from its own element-wise mean, $g_K$. In a weighted sense, $g_K$ can be seen as the best constant-vector approximation to $\\nabla u$ over $K$. Since a linear element's gradient is constant, this term represents the error that cannot be eliminated, even with the \"best\" possible constant gradient. This error is non-zero if the exact solution cannot be represented exactly by the chosen finite element basis functions (e.g., if $u$ is quadratic and the basis is linear). The ability of a basis to reproduce polynomials up to a certain degree is known as its **completeness** property. This term is an intrinsic error associated with the choice of finite element space and the mesh, independent of the particular discrete solution $u_h$.\n\n2.  **Compatibility Residual**: The second term, $\\sum_K \\vert K\\vert (g_K - \\nabla u_h\\vert_K)^\\top A (g_K - \\nabla u_h\\vert_K)$, quantifies the error due to inter-element constraints. The discrete gradient $\\nabla u_h\\vert_K$ is determined by the nodal values of $u$ at the element's vertices. Since the interpolant $u_h$ must be continuous across element boundaries (a weak form of **compatibility**), the nodal values are shared among adjacent elements. This sharing imposes constraints that prevent $\\nabla u_h\\vert_K$ on a given element from being the optimal local approximation $g_K$. Instead, $\\nabla u_h\\vert_K$ represents a compromise to maintain global continuity of $u_h$. The gradient field $\\nabla u_h$ is itself discontinuous (\"broken\") across element edges. This term thus measures the discrepancy between the element-mean gradient $g_K$ and the constrained, \"broken\" gradient $\\nabla u_h\\vert_K$ of the global approximation. It reflects how fitting a global, continuous displacement field forces local gradients to deviate from their ideal local approximations.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and numerically verifies an error decomposition for an anisotropic \n    bending problem using the Finite Element Method.\n    \"\"\"\n    \n    # Manufactured solution coefficients\n    d1, d2, d3 = 1.0, 0.2, 0.5\n    \n    # Exact solution u(x,y) and its gradient ∇u(x,y)\n    u_exact = lambda x, y: d1 * x**2 + d2 * y**2 + d3 * x * y\n    grad_u_exact = lambda x, y: np.array([2 * d1 * x + d3 * y, 2 * d2 * y + d3 * x])\n\n    test_cases = [\n        (8, 8, 1.0, 100.0, 0),\n        (4, 4, 1000.0, 1.0, 0),\n        (16, 16, 1.0, 1.0, 0),\n        (6, 6, 100.0, 10.0, 45),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        Nx, Ny, ax, ay, theta_deg = case\n        \n        # Construct the anisotropic stiffness tensor A\n        theta_rad = np.deg2rad(theta_deg)\n        c, s = np.cos(theta_rad), np.sin(theta_rad)\n        R = np.array([[c, -s], [s, c]])\n        A_diag = np.array([[ax, 0], [0, ay]])\n        A = R.T @ A_diag @ R\n        \n        hx, hy = 1.0 / Nx, 1.0 / Ny\n        \n        total_error_sq = 0.0\n        total_completeness_sq = 0.0\n        total_compatibility_sq = 0.0\n\n        for i in range(Nx):\n            for j in range(Ny):\n                x_i, y_j = i * hx, j * hy\n                x_ip1, y_jp1 = (i + 1) * hx, (j + 1) * hy\n                \n                # Vertices of the rectangular cell\n                p1 = np.array([x_i, y_j])       # lower-left\n                p2 = np.array([x_ip1, y_j])     # lower-right\n                p3 = np.array([x_ip1, y_jp1])   # upper-right\n                p4 = np.array([x_i, y_jp1])     # upper-left\n\n                # Define the two triangles in the cell\n                triangles = [\n                    (p1, p2, p3),  # Lower-right triangle\n                    (p1, p3, p4)   # Upper-left triangle\n                ]\n                \n                for vertices_tuple in triangles:\n                    vertices = np.array(vertices_tuple)\n                    v1, v2, v3 = vertices[0], vertices[1], vertices[2]\n                    x1, y1 = v1; x2, y2 = v2; x3, y3 = v3\n\n                    # Area of the triangle K\n                    area = 0.5 * abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))\n\n                    # Discrete gradient ∇u_h on K\n                    u1, u2, u3 = u_exact(x1, y1), u_exact(x2, y2), u_exact(x3, y3)\n                    B_matrix = (1.0 / (2.0 * area)) * np.array([\n                        [y2 - y3, y3 - y1, y1 - y2],\n                        [x3 - x2, x1 - x3, x2 - x1]\n                    ])\n                    grad_uh_k = B_matrix @ np.array([u1, u2, u3])\n                    \n                    # Exact mean gradient g_K (∇u at centroid for linear ∇u)\n                    centroid = np.mean(vertices, axis=0)\n                    g_k = grad_u_exact(centroid[0], centroid[1])\n                    \n                    # Compatibility component (squared) for K\n                    diff_compat = g_k - grad_uh_k\n                    compat_sq_k = area * (diff_compat.T @ A @ diff_compat)\n                    total_compatibility_sq += compat_sq_k\n\n                    # Quadrature for total and completeness error integrals\n                    # 3-point rule (midpoints of edges), exact for quadratics\n                    q_pts = np.array([(v1 + v2) / 2.0, (v2 + v3) / 2.0, (v3 + v1) / 2.0])\n                    \n                    total_sq_k = 0.0\n                    complete_sq_k = 0.0\n                    \n                    for q_pt in q_pts:\n                        grad_u_q = grad_u_exact(q_pt[0], q_pt[1])\n                        \n                        # Total error integrand at quadrature point\n                        diff_total = grad_u_q - grad_uh_k\n                        total_sq_k += diff_total.T @ A @ diff_total\n                        \n                        # Completeness error integrand at quadrature point\n                        diff_complete = grad_u_q - g_k\n                        complete_sq_k += diff_complete.T @ A @ diff_complete\n\n                    # Apply quadrature weights (1/3) and area\n                    total_error_sq += total_sq_k * (area / 3.0)\n                    total_completeness_sq += complete_sq_k * (area / 3.0)\n\n        # Final aggregation and calculations\n        total_error_norm = np.sqrt(total_error_sq)\n        completeness_norm = np.sqrt(total_completeness_sq)\n        compatibility_norm = np.sqrt(total_compatibility_sq)\n\n        # Orthogonality check\n        identity_holds = False\n        if total_error_sq > 1e-15:\n            relative_diff = abs(total_error_sq - (total_completeness_sq + total_compatibility_sq)) / total_error_sq\n            if relative_diff  1e-10:\n                identity_holds = True\n        \n        # Ratios\n        ratio_completeness = total_completeness_sq / total_error_sq if total_error_sq > 1e-15 else 0.0\n        ratio_compatibility = total_compatibility_sq / total_error_sq if total_error_sq > 1e-15 else 0.0\n\n        results.append([\n            total_error_norm,\n            completeness_norm,\n            compatibility_norm,\n            identity_holds,\n            ratio_completeness,\n            ratio_compatibility\n        ])\n\n    # Format the final output string\n    output_str = str(results)\n    print(output_str)\n\nsolve()\n```", "id": "3549795"}]}