{"hands_on_practices": [{"introduction": "Residual-based estimators directly measure how well a numerical solution satisfies the underlying physical laws, and a key component is the traction jump across element interfaces, which quantifies the imbalance of internal forces. This exercise [@problem_id:3541963] provides a step-by-step guide to computing this jump term from a given finite element displacement field. This practice offers a foundational, hands-on understanding of where numerical errors originate in a discretization.", "problem": "Consider a two-dimensional cantilever beam under a tip load, modeled in plane strain, discretized by the Finite Element Method (FEM) using linear Lagrange elements ($P_1$). Focus on a local interior edge $e$ that is the common edge of two adjacent triangles arising from splitting the unit square with coordinates (in meters) $A=(0,0)$, $B=(1,0)$, $C=(0,1)$, and $D=(1,1)$ along the diagonal from $B$ to $C$. Let $T^{+}=\\triangle ABC$ and $T^{-}=\\triangle BDC$, and let $e$ be the edge connecting $B$ and $C$. The discrete displacement field $u_h=(u_{h,x},u_{h,y})$ is piecewise affine over each triangle and is given at the mesh vertices (in meters) by\n- $u_h(A)=(0,0)$,\n- $u_h(B)=(1.0\\times 10^{-4},\\,2.0\\times 10^{-4})$,\n- $u_h(C)=(-5.0\\times 10^{-5},\\,3.0\\times 10^{-4})$,\n- $u_h(D)=(9.0\\times 10^{-5},\\,4.7\\times 10^{-4})$.\nAssume an isotropic, homogeneous, linear elastic material in plane strain with Lamé parameters $(\\lambda,\\mu)$ equal to $\\lambda=1.2\\times 10^{9}\\,\\mathrm{Pa}$ and $\\mu=0.8\\times 10^{9}\\,\\mathrm{Pa}$. The Cauchy stress tensor is defined by $\\sigma(u_h)=2\\mu\\,\\varepsilon(u_h)+\\lambda\\,\\mathrm{tr}(\\varepsilon(u_h))\\,I$, where $\\varepsilon(u_h)=(\\nabla u_h+(\\nabla u_h)^{\\top})/2$ is the symmetric gradient and $I$ is the identity tensor. On an interior edge $e$ shared by elements $T^{+}$ and $T^{-}$ with outward unit normals along $e$ denoted by $n^{+}$ (for $T^{+}$) and $n^{-}$ (for $T^{-}$) satisfying $n^{-}=-n^{+}$, define the traction jump vector by $\\llbracket \\sigma(u_h)n \\rrbracket := \\sigma(u_h)|_{T^{+}}\\,n^{+}+\\sigma(u_h)|_{T^{-}}\\,n^{-}$. The edge norm is $\\|v\\|_{0,e}=\\left(\\int_{e}|v|^{2}\\,\\mathrm{d}s\\right)^{1/2}$ with $|\\cdot|$ the Euclidean norm in $\\mathbb{R}^{2}$. Using these data and definitions, compute the interior edge jump contribution $\\|\\llbracket \\sigma(u_h)n\\rrbracket\\|_{0,e}$ for the edge $e=\\overline{BC}$. Express your final answer in $\\mathrm{N}\\,\\mathrm{m}^{-3/2}$ and round your answer to four significant figures.", "solution": "The problem is first validated to ensure it is scientifically sound, self-contained, and well-posed.\n\n### Step 1: Extract Givens\n- **Geometry:** A unit square with vertices $A=(0,0)$, $B=(1,0)$, $C=(0,1)$, and $D=(1,1)$ in meters. The domain is divided into two triangles: $T^{+} = \\triangle ABC$ and $T^{-} = \\triangle BDC$.\n- **Edge of Interest:** $e = \\overline{BC}$, the common edge between $T^{+}$ and $T^{-}$.\n- **FEM Discretization:** Linear Lagrange elements ($P_1$). The discrete displacement field $u_h=(u_{h,x}, u_{h,y})$ is piecewise affine.\n- **Nodal Displacements (in meters):**\n  - $u_h(A) = (0,0)$\n  - $u_h(B) = (1.0 \\times 10^{-4}, 2.0 \\times 10^{-4})$\n  - $u_h(C) = (-5.0 \\times 10^{-5}, 3.0 \\times 10^{-4})$\n  - $u_h(D) = (9.0 \\times 10^{-5}, 4.7 \\times 10^{-4})$\n- **Material Model:** Isotropic, homogeneous, linear elastic, plane strain.\n- **Material Properties (Lamé parameters):** $\\lambda = 1.2 \\times 10^{9}\\,\\mathrm{Pa}$, $\\mu = 0.8 \\times 10^{9}\\,\\mathrm{Pa}$.\n- **Constitutive Relation:** Cauchy stress $\\sigma(u_h) = 2\\mu\\,\\varepsilon(u_h) + \\lambda\\,\\mathrm{tr}(\\varepsilon(u_h))\\,I$, with $\\varepsilon(u_h) = (\\nabla u_h + (\\nabla u_h)^{\\top})/2$.\n- **Definitions:**\n  - Traction jump: $\\llbracket \\sigma(u_h)n \\rrbracket = \\sigma(u_h)|_{T^{+}}\\,n^{+} + \\sigma(u_h)|_{T^{-}}\\,n^{-}$, where $n^{\\pm}$ are the outward unit normals from $T^{\\pm}$ along $e$, and $n^{-} = -n^{+}$.\n  - Edge norm: $\\|v\\|_{0,e} = \\left(\\int_{e}|v|^{2}\\,\\mathrm{d}s\\right)^{1/2}$.\n- **Objective:** Compute $\\|\\llbracket \\sigma(u_h)n\\rrbracket\\|_{0,e}$ for $e=\\overline{BC}$ and provide the result rounded to four significant figures in units of $\\mathrm{N}\\,\\mathrm{m}^{-3/2}$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is a standard exercise in a posteriori error estimation for the Finite Element Method in computational solid mechanics. It is scientifically grounded in the principles of linear elasticity and continuum mechanics. All terms are standard and precisely defined. All required data (geometry, nodal displacements, material constants) are provided and are physically plausible. The problem is well-posed, objective, and contains no contradictions or ambiguities.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete solution follows.\n\n### Detailed Solution\n\nThe solution proceeds by first computing the constant displacement gradient on each triangular element, then the strain and stress tensors, followed by the traction jump vector, and finally the required edge norm.\n\n**1. Displacement Gradients**\nSince the displacement field $u_h$ is affine (linear) on each triangle, its gradient, $\\nabla u_h$, is a constant matrix on each element.\n\nFor element $T^{+} = \\triangle ABC$ with vertices $A(0,0)$, $B(1,0)$, and $C(0,1)$, the displacement field is of the form $u_h(x,y) = \\mathbf{a} + \\mathbf{B}\\begin{pmatrix}x \\\\ y\\end{pmatrix}$. The gradient is $\\nabla u_h = \\mathbf{B}^T$. The coefficients are found from the nodal values:\n$u_h(0,0) = \\mathbf{a} = u_h(A) = (0,0)$.\n$u_h(1,0) = \\mathbf{a} + \\mathbf{B}\\begin{pmatrix}1 \\\\ 0\\end{pmatrix} = u_h(B)$, which implies the first column of $\\mathbf{B}$ is $u_h(B)$.\n$u_h(0,1) = \\mathbf{a} + \\mathbf{B}\\begin{pmatrix}0 \\\\ 1\\end{pmatrix} = u_h(C)$, which implies the second column of $\\mathbf{B}$ is $u_h(C)$.\nSo, $\\mathbf{B} = \\begin{pmatrix} u_{h,x}(B) & u_{h,x}(C) \\\\ u_{h,y}(B) & u_{h,y}(C) \\end{pmatrix} = \\begin{pmatrix} 1.0 \\times 10^{-4} & -5.0 \\times 10^{-5} \\\\ 2.0 \\times 10^{-4} & 3.0 \\times 10^{-4} \\end{pmatrix}$.\nThe gradient on $T^{+}$ is:\n$$ \\nabla u_h|_{T^{+}} = \\mathbf{B}^T = \\begin{pmatrix} 1.0 \\times 10^{-4} & 2.0 \\times 10^{-4} \\\\ -5.0 \\times 10^{-5} & 3.0 \\times 10^{-4} \\end{pmatrix} $$\n\nFor element $T^{-} = \\triangle BDC$ with vertices $B(1,0)$, $D(1,1)$, and $C(0,1)$, we again set $u_h(x,y) = \\mathbf{a} + \\mathbf{B}\\begin{pmatrix}x \\\\ y\\end{pmatrix}$. We solve a system of linear equations:\n$u_h(C) = u_h(0,1) = \\mathbf{a} + \\mathbf{B}\\begin{pmatrix}0 \\\\ 1\\end{pmatrix}$\n$u_h(B) = u_h(1,0) = \\mathbf{a} + \\mathbf{B}\\begin{pmatrix}1 \\\\ 0\\end{pmatrix}$\n$u_h(D) = u_h(1,1) = \\mathbf{a} + \\mathbf{B}\\begin{pmatrix}1 \\\\ 1\\end{pmatrix}$\nFrom these, we find the columns of $\\mathbf{B}$ are $B_{\\cdot 1} = u_h(D) - u_h(C)$ and $B_{\\cdot 2} = u_h(D) - u_h(B)$.\n$B_{\\cdot 1} = \\begin{pmatrix} 9.0 \\times 10^{-5} - (-5.0 \\times 10^{-5}) \\\\ 4.7 \\times 10^{-4} - 3.0 \\times 10^{-4} \\end{pmatrix} = \\begin{pmatrix} 1.4 \\times 10^{-4} \\\\ 1.7 \\times 10^{-4} \\end{pmatrix}$.\n$B_{\\cdot 2} = \\begin{pmatrix} 9.0 \\times 10^{-5} - 1.0 \\times 10^{-4} \\\\ 4.7 \\times 10^{-4} - 2.0 \\times 10^{-4} \\end{pmatrix} = \\begin{pmatrix} -1.0 \\times 10^{-5} \\\\ 2.7 \\times 10^{-4} \\end{pmatrix}$.\nSo, $\\mathbf{B} = \\begin{pmatrix} 1.4 \\times 10^{-4} & -1.0 \\times 10^{-5} \\\\ 1.7 \\times 10^{-4} & 2.7 \\times 10^{-4} \\end{pmatrix}$.\nThe gradient on $T^{-}$ is:\n$$ \\nabla u_h|_{T^{-}} = \\mathbf{B}^T = \\begin{pmatrix} 1.4 \\times 10^{-4} & 1.7 \\times 10^{-4} \\\\ -1.0 \\times 10^{-5} & 2.7 \\times 10^{-4} \\end{pmatrix} $$\n\n**2. Strain and Stress Tensors**\nThe strain tensor is $\\varepsilon = \\frac{1}{2}(\\nabla u_h + (\\nabla u_h)^T)$.\nOn $T^{+}$:\n$$ \\varepsilon^{+} = \\frac{1}{2}\\left(\\begin{pmatrix} 1.0 \\times 10^{-4} & 2.0 \\times 10^{-4} \\\\ -5.0 \\times 10^{-5} & 3.0 \\times 10^{-4} \\end{pmatrix} + \\begin{pmatrix} 1.0 \\times 10^{-4} & -5.0 \\times 10^{-5} \\\\ 2.0 \\times 10^{-4} & 3.0 \\times 10^{-4} \\end{pmatrix}\\right) = \\begin{pmatrix} 1.0 \\times 10^{-4} & 7.5 \\times 10^{-5} \\\\ 7.5 \\times 10^{-5} & 3.0 \\times 10^{-4} \\end{pmatrix} $$\nThe trace is $\\mathrm{tr}(\\varepsilon^{+}) = (1.0 + 3.0) \\times 10^{-4} = 4.0 \\times 10^{-4}$.\nThe stress tensor $\\sigma^{+} = 2\\mu\\varepsilon^{+} + \\lambda\\,\\mathrm{tr}(\\varepsilon^{+})I$:\n$$ \\sigma^{+} = 2(0.8 \\times 10^9)\\varepsilon^{+} + (1.2 \\times 10^9)(4.0 \\times 10^{-4})I $$\n$$ \\sigma^{+} = 1.6 \\times 10^9 \\begin{pmatrix} 1.0 \\times 10^{-4} & 7.5 \\times 10^{-5} \\\\ 7.5 \\times 10^{-5} & 3.0 \\times 10^{-4} \\end{pmatrix} + 4.8 \\times 10^5 I = \\begin{pmatrix} 1.6 \\times 10^5 & 1.2 \\times 10^5 \\\\ 1.2 \\times 10^5 & 4.8 \\times 10^5 \\end{pmatrix} + \\begin{pmatrix} 4.8 \\times 10^5 & 0 \\\\ 0 & 4.8 \\times 10^5 \\end{pmatrix} $$\n$$ \\sigma^{+} = \\begin{pmatrix} 6.4 \\times 10^5 & 1.2 \\times 10^5 \\\\ 1.2 \\times 10^5 & 9.6 \\times 10^5 \\end{pmatrix}\\,\\mathrm{Pa} $$\n\nOn $T^{-}$:\n$$ \\varepsilon^{-} = \\frac{1}{2}\\left(\\begin{pmatrix} 1.4 \\times 10^{-4} & 1.7 \\times 10^{-4} \\\\ -1.0 \\times 10^{-5} & 2.7 \\times 10^{-4} \\end{pmatrix} + \\begin{pmatrix} 1.4 \\times 10^{-4} & -1.0 \\times 10^{-5} \\\\ 1.7 \\times 10^{-4} & 2.7 \\times 10^{-4} \\end{pmatrix}\\right) = \\begin{pmatrix} 1.4 \\times 10^{-4} & 8.0 \\times 10^{-5} \\\\ 8.0 \\times 10^{-5} & 2.7 \\times 10^{-4} \\end{pmatrix} $$\nThe trace is $\\mathrm{tr}(\\varepsilon^{-}) = (1.4 + 2.7) \\times 10^{-4} = 4.1 \\times 10^{-4}$.\nThe stress tensor $\\sigma^{-} = 2\\mu\\varepsilon^{-} + \\lambda\\,\\mathrm{tr}(\\varepsilon^{-})I$:\n$$ \\sigma^{-} = 2(0.8 \\times 10^9)\\varepsilon^{-} + (1.2 \\times 10^9)(4.1 \\times 10^{-4})I $$\n$$ \\sigma^{-} = 1.6 \\times 10^9 \\begin{pmatrix} 1.4 \\times 10^{-4} & 8.0 \\times 10^{-5} \\\\ 8.0 \\times 10^{-5} & 2.7 \\times 10^{-4} \\end{pmatrix} + 4.92 \\times 10^5 I = \\begin{pmatrix} 2.24 \\times 10^5 & 1.28 \\times 10^5 \\\\ 1.28 \\times 10^5 & 4.32 \\times 10^5 \\end{pmatrix} + \\begin{pmatrix} 4.92 \\times 10^5 & 0 \\\\ 0 & 4.92 \\times 10^5 \\end{pmatrix} $$\n$$ \\sigma^{-} = \\begin{pmatrix} 7.16 \\times 10^5 & 1.28 \\times 10^5 \\\\ 1.28 \\times 10^5 & 9.24 \\times 10^5 \\end{pmatrix}\\,\\mathrm{Pa} $$\n\n**3. Traction Jump Vector**\nThe edge $e$ is the segment $\\overline{BC}$ connecting $B(1,0)$ and $C(0,1)$. The vector along the edge is $C-B = (-1,1)$. An orthogonal vector is $(1,1)$. For $T^+ = \\triangle ABC$, the vertex $A(0,0)$ is on the side of the line $x+y-1=0$ where $x+y-1<0$, so the outward normal points in the direction where $x+y-1>0$. Thus, the outward unit normal from $T^{+}$ is:\n$$ n^{+} = \\frac{1}{\\sqrt{1^2+1^2}}(1,1) = \\frac{1}{\\sqrt{2}}\\begin{pmatrix}1 \\\\ 1\\end{pmatrix} $$\nThe traction jump is defined as $\\llbracket \\sigma(u_h)n \\rrbracket = \\sigma^{+}n^{+} + \\sigma^{-}n^{-}$. Since $n^{-} = -n^{+}$, this simplifies to $\\llbracket \\sigma(u_h)n \\rrbracket = (\\sigma^{+} - \\sigma^{-})n^{+}$. We compute the difference in stress tensors:\n$$ \\sigma^{+} - \\sigma^{-} = 10^5 \\left( \\begin{pmatrix} 6.4 & 1.2 \\\\ 1.2 & 9.6 \\end{pmatrix} - \\begin{pmatrix} 7.16 & 1.28 \\\\ 1.28 & 9.24 \\end{pmatrix} \\right) = 10^5 \\begin{pmatrix} -0.76 & -0.08 \\\\ -0.08 & 0.36 \\end{pmatrix} $$\nThe traction jump vector $J = \\llbracket \\sigma(u_h)n \\rrbracket$ is:\n$$ J = 10^5 \\begin{pmatrix} -0.76 & -0.08 \\\\ -0.08 & 0.36 \\end{pmatrix} \\frac{1}{\\sqrt{2}}\\begin{pmatrix}1 \\\\ 1\\end{pmatrix} = \\frac{10^5}{\\sqrt{2}} \\begin{pmatrix} -0.76 - 0.08 \\\\ -0.08 + 0.36 \\end{pmatrix} = \\frac{10^5}{\\sqrt{2}}\\begin{pmatrix} -0.84 \\\\ 0.28 \\end{pmatrix} $$\nSince $\\sigma^{+}$ and $\\sigma^{-}$ are constant on their respective elements, the jump vector $J$ is constant along the edge $e$.\n\n**4. Edge Norm Calculation**\nThe norm is $\\|J\\|_{0,e} = \\left(\\int_e |J|^2 \\mathrm{d}s\\right)^{1/2}$. As $J$ is constant, this simplifies to $\\|J\\|_{0,e} = |J| \\sqrt{\\mathrm{length}(e)}$.\nThe length of edge $e$ is $L_e = \\sqrt{(1-0)^2 + (0-1)^2} = \\sqrt{2}\\,\\mathrm{m}$.\nThe Euclidean norm of the jump vector is:\n$$ |J| = \\left| \\frac{10^5}{\\sqrt{2}}\\begin{pmatrix} -0.84 \\\\ 0.28 \\end{pmatrix} \\right| = \\frac{10^5}{\\sqrt{2}} \\sqrt{(-0.84)^2 + (0.28)^2} = \\frac{10^5}{\\sqrt{2}} \\sqrt{0.7056 + 0.0784} = \\frac{10^5}{\\sqrt{2}} \\sqrt{0.784} $$\nFactoring terms: $0.784 = 0.28^2 \\times 10$.\n$$ |J| = \\frac{10^5}{\\sqrt{2}} \\sqrt{0.28^2 \\times 10} = \\frac{10^5 \\times 0.28 \\times \\sqrt{10}}{\\sqrt{2}} = 0.28 \\times 10^5 \\sqrt{5}\\,\\mathrm{N}\\,\\mathrm{m}^{-2} $$\nFinally, we compute the edge norm:\n$$ \\|J\\|_{0,e} = |J| \\sqrt{L_e} = (0.28 \\times 10^5 \\sqrt{5}) \\sqrt{\\sqrt{2}} = 0.28 \\times 10^5 \\sqrt{5} \\sqrt[4]{2} $$\nThe units are $(\\mathrm{N}\\,\\mathrm{m}^{-2}) \\cdot \\mathrm{m}^{1/2} = \\mathrm{N}\\,\\mathrm{m}^{-3/2}$.\n\n**5. Final Numerical Value**\nWe now compute the numerical value and round to four significant figures:\n$$ \\|J\\|_{0,e} = 2.8 \\times 10^4 \\times \\sqrt{5} \\times \\sqrt[4]{2} \\approx 2.8 \\times 10^4 \\times (2.2360679...) \\times (1.1892071...) $$\n$$ \\|J\\|_{0,e} \\approx 2.8 \\times 10^4 \\times (2.6591479...) \\approx 7.445614... \\times 10^4 $$\nRounding to four significant figures, we get $7.446 \\times 10^4$.", "answer": "$$\\boxed{7.446 \\times 10^{4}}$$", "id": "3541963"}, {"introduction": "Equilibration-based estimators offer a powerful alternative to direct residual measurement, where the core idea is to construct a \"better,\" post-processed stress field that exactly satisfies static equilibrium. The error is then estimated by measuring the deviation of the original finite element stress from this improved field. This coding exercise [@problem_id:3542003] makes the abstract concept of equilibrated flux reconstruction tangible by having you implement the procedure for a one-dimensional bar, from solving local problems for nodal fluxes to calculating the final error estimate.", "problem": "Consider one-dimensional linear elasticity on a bar of length $L>0$, with constant cross-sectional area $A=1$ and constant Young’s modulus $E>0$. Let $u(x)$ denote the axial displacement, $\\varepsilon(u)=\\dfrac{du}{dx}$ the axial strain, and $\\sigma(u)=E\\,\\varepsilon(u)$ the axial stress. The strong form of equilibrium with body force $b(x)$ (force per unit volume) is $-\\dfrac{d}{dx}\\sigma = b$ in $(0,L)$, with a Dirichlet boundary condition $u(0)=0$ and a Neumann boundary condition prescribing the terminal traction $\\sigma(L)=t_R$. Assume a partition of the domain into $N$ uniform elements with nodes $0=x_0<x_1<\\dots<x_N=L$, $h=L/N$. A conforming piecewise-linear finite element solution $u_h$ is obtained by assembling the bilinear form $\\int_0^L E\\,u'(x)\\,v'(x)\\,dx$ and the linear functional $\\int_0^L b(x)\\,v(x)\\,dx + t_R\\,v(L)$, imposing the essential boundary condition $u(0)=0$. Define the discrete stress $\\sigma(u_h)$ element-wise as the constant $E$ times the derivative of $u_h$ on each element.\n\nThe goal is to construct an equilibrated stress field $\\hat{\\sigma}_h$ that is conforming in the Sobolev space of square-integrable vector fields with square-integrable divergence, denoted $H(\\text{div})$, by solving local Neumann problems on element patches. In one dimension, $H(\\text{div})$-conformity translates to producing a globally continuous stress $\\hat{\\sigma}_h(x)$ with square-integrable derivative and enforcing local equilibrium $-\\dfrac{d}{dx}\\hat{\\sigma}_h=b$ in each element. To achieve this via local Neumann problems on element patches, proceed as follows.\n\nFor each element $K_i=[x_i,x_{i+1}]$, enforce the Neumann compatibility condition for the reconstructed nodal fluxes $s_i=\\hat{\\sigma}_h(x_i)$ and $s_{i+1}=\\hat{\\sigma}_h(x_{i+1})$:\n$$\ns_{i+1}-s_i = -\\int_{x_i}^{x_{i+1}} b(x)\\,dx.\n$$\nThis expresses element-wise equilibrium. Impose the terminal traction as a boundary condition at $x=L$, namely $s_N=t_R$. These conditions uniquely determine all nodal fluxes $\\{s_i\\}_{i=0}^N$ by backward accumulation from $s_N$. On each element $K_i$, define the reconstructed stress as the unique solution to the local Neumann problem\n$$\n-\\frac{d}{dx}\\hat{\\sigma}_h(x) = b(x)\\quad\\text{for }x\\in K_i,\\quad \\hat{\\sigma}_h(x_i)=s_i,\\quad \\hat{\\sigma}_h(x_{i+1})=s_{i+1},\n$$\nwhich yields the explicit expression\n$$\n\\hat{\\sigma}_h(x) = s_i - \\int_{x_i}^{x} b(\\xi)\\,d\\xi,\\quad x\\in K_i.\n$$\nThis construction produces a globally continuous, piecewise-linear $\\hat{\\sigma}_h$ with square-integrable derivative and element-wise equilibrium, hence $H(\\text{div})$-conforming.\n\nDefine the element-wise estimator\n$$\n\\eta_K^2 = \\big\\| C^{-1/2}\\big(\\hat{\\sigma}_h - \\sigma(u_h)\\big)\\big\\|_{0,K}^2 = \\int_K \\frac{1}{E}\\,\\big(\\hat{\\sigma}_h(x)-\\sigma(u_h)\\big)^2\\,dx,\n$$\nwhere $C$ is the elastic compliance operator so that in one dimension $C^{-1/2}=(1/\\sqrt{E})$. For piecewise-constant $b$ on each element $K_i$ with value $b_i$, and piecewise-constant discrete stress $\\sigma(u_h)$ equal to $\\sigma_i$ on $K_i$, the reconstructed stress is affine on $K_i$:\n$$\n\\hat{\\sigma}_h(x) = s_i - b_i\\,(x-x_i),\\quad x\\in K_i,\n$$\nand the estimator integral admits the closed form\n$$\n\\eta_{K_i}^2 = \\int_{x_i}^{x_{i+1}} \\frac{1}{E}\\,\\big(s_i - b_i\\,(x-x_i) - \\sigma_i\\big)^2\\,dx = \\frac{1}{E}\\left[d_i^2\\,h - d_i\\,b_i\\,h^2 + \\frac{b_i^2\\,h^3}{3}\\right],\n$$\nwith $d_i = s_i - \\sigma_i$ and $h=x_{i+1}-x_i$.\n\nYour task is to implement a program that:\n1. Assembles and solves the one-dimensional finite element problem to obtain $u_h$ for each test case, computes $\\sigma(u_h)$ element-wise, reconstructs the equilibrated stress $\\hat{\\sigma}_h$ via the local Neumann patch procedure described above, and evaluates the global estimator $\\sum_{K}\\eta_K^2$.\n2. Uses the following test suite, with all quantities in the International System of Units (SI):\n   a) $L=1.0$ m, $E=2.0\\times 10^{11}$ Pa, $N=4$, $b(x)$ piecewise constant with $b_i=1.0\\times 10^6$ N/m$^3$ on each element, $t_R=0.0$ Pa.\n   b) $L=1.0$ m, $E=7.0\\times 10^{10}$ Pa, $N=3$, $b(x)$ piecewise constant with $(b_0,b_1,b_2)=(1.0\\times 10^6,-0.5\\times 10^6,2.0\\times 10^6)$ N/m$^3$, $t_R=5.0\\times 10^6$ Pa.\n   c) $L=0.5$ m, $E=1.0\\times 10^{11}$ Pa, $N=1$, $b(x)$ piecewise constant with $b_0=0.0$ N/m$^3$, $t_R=1.0\\times 10^6$ Pa.\n3. Produces a single line of output containing the global estimator values $\\sum_{K}\\eta_K^2$ for the three test cases as a comma-separated list enclosed in square brackets, for example $[r_1,r_2,r_3]$, where each $r_i$ is a floating-point number. Express the values in Pascal-meter (Pa·m) and output them numerically as floats without unit symbols.\n\nAngles are not involved. No percentages are involved. The program must be completely self-contained and require no user input. The computations must be carried out exactly as described and the output must strictly adhere to the specified single-line format.", "solution": "The problem statement has been validated and is deemed valid. It is scientifically grounded in the principles of linear elasticity and the finite element method, mathematically self-consistent, and provides a complete and unambiguous specification for the required calculations.\n\nThe task is to compute an *a posteriori* error estimator for a one-dimensional linear elasticity problem solved using the finite element method. The procedure involves several distinct steps, which are implemented for three specific test cases.\n\nFirst, we solve the finite element problem for the nodal displacements. The governing weak form for the displacement field $u(x)$, subject to $u(0)=0$, is given by: find $u$ such that for all admissible test functions $v$,\n$$\n\\int_0^L E\\,u'(x)\\,v'(x)\\,dx = \\int_0^L b(x)\\,v(x)\\,dx + t_R\\,v(L)\n$$\nwhere $E$ is Young's modulus, $b(x)$ is the body force per unit volume, and $t_R$ is the prescribed traction at $x=L$. The cross-sectional area is $A=1$. We discretize the domain $[0, L]$ into $N$ uniform elements of length $h=L/N$. The displacement $u_h(x)$ is approximated by piecewise-linear basis functions. The unknown degrees of freedom are the nodal displacements $u_1, u_2, \\dots, u_N$, as $u_0=u(0)=0$ is a given boundary condition. This leads to a linear system of equations $\\mathbf{K}\\mathbf{U} = \\mathbf{F}$, where $\\mathbf{U} = [u_1, u_2, \\dots, u_N]^T$.\n\nThe stiffness matrix $\\mathbf{K}$ has entries $K_{ij} = \\int_0^L E \\phi_i'(x) \\phi_j'(x) dx$, where $\\phi_i$ are the standard linear \"hat\" basis functions. For a uniform mesh with $u_0=0$, the resulting $N \\times N$ matrix is:\n$$\n\\mathbf{K} = \\frac{E}{h}\n\\begin{pmatrix}\n2 & -1 & 0 & \\dots & 0 \\\\\n-1 & 2 & -1 & \\dots & 0 \\\\\n0 & \\ddots & \\ddots & \\ddots & 0 \\\\\n\\vdots & & -1 & 2 & -1 \\\\\n0 & \\dots & 0 & -1 & 1\n\\end{pmatrix}\n$$\nThe force vector $\\mathbf{F}$ has entries $F_i = \\int_0^L b(x)\\phi_i(x) dx + t_R \\phi_i(L)$. For a piecewise-constant body force $b(x)=b_k$ on each element $K_k=[x_k, x_{k+1}]$, the components of $\\mathbf{F}$ are:\n$$\nF_i = \\frac{h}{2}(b_{i-1} + b_i) \\quad \\text{for } i=1, \\dots, N-1,\n$$\n$$\nF_N = \\frac{h}{2}b_{N-1} + t_R.\n$$\nSolving $\\mathbf{K}\\mathbf{U}=\\mathbf{F}$ yields the nodal displacements $u_1, \\dots, u_N$.\n\nSecond, we compute the piecewise-constant finite element stress $\\sigma(u_h)$ on each element $K_i=[x_i, x_{i+1}]$:\n$$\n\\sigma_i = E \\frac{u_{i+1}-u_i}{h}\n$$\n\nThird, we construct the $H(\\text{div})$-conforming equilibrated stress field $\\hat{\\sigma}_h$. This involves finding the nodal values of the reconstructed stress, denoted $s_i = \\hat{\\sigma}_h(x_i)$. These are determined by enforcing the Neumann boundary condition $s_N = t_R$ and then applying a backward recurrence relation derived from element-wise equilibrium:\n$$\ns_i = s_{i+1} + \\int_{x_i}^{x_{i+1}} b(x) dx\n$$\nFor a piecewise-constant body force $b_i$, this simplifies to $s_i = s_{i+1} + b_i h$. This relation is used to compute $s_{N-1}, s_{N-2}, \\dots, s_0$ sequentially.\n\nFourth, we calculate the local error estimator $\\eta_{K_i}^2$ for each element $K_i$. Using the provided closed-form expression for piecewise-constant $b_i$:\n$$\n\\eta_{K_i}^2 = \\frac{1}{E}\\left[d_i^2\\,h - d_i\\,b_i\\,h^2 + \\frac{b_i^2\\,h^3}{3}\\right]\n$$\nwhere $d_i = s_i - \\sigma_i$ is the difference between the reconstructed stress at the element's start node and the finite element stress on that element.\n\nFinally, the global error estimator value is the sum of the local contributions:\n$$\n\\eta^2 = \\sum_{i=0}^{N-1} \\eta_{K_i}^2\n$$\nThis entire procedure is implemented for each of the three test cases specified in the problem. The final output is a list of the global estimator values $\\eta^2$ for each case, expressed in Pascal-meters (Pa·m), which is equivalent to Newtons per meter (N/m).", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport scipy.linalg\n\ndef compute_estimator(L, E, N, b, t_R):\n    \"\"\"\n    Computes the equilibrated a posteriori error estimator for a 1D bar.\n\n    Args:\n        L (float): Length of the bar.\n        E (float): Young's modulus.\n        N (int): Number of elements.\n        b (list or np.ndarray): Piecewise-constant body force on each element.\n        t_R (float): Traction at the right end x=L.\n\n    Returns:\n        float: The value of the global error estimator squared.\n    \"\"\"\n    # Step 1: Solve the Finite Element problem\n    h = L / N\n    \n    # Assemble stiffness matrix K for N free DoFs (u_1, ..., u_N)\n    K = np.zeros((N, N))\n    main_diag = (2 * E / h) * np.ones(N)\n    main_diag[-1] = E / h  # Correct entry for K_NN with u(0)=0\n    off_diag = (-E / h) * np.ones(N - 1)\n    K += np.diag(main_diag)\n    K += np.diag(off_diag, k=1)\n    K += np.diag(off_diag, k=-1)\n    \n    # Assemble force vector F\n    F = np.zeros(N)\n    for i in range(1, N): # Corresponds to F_1 to F_{N-1}\n        # F_i relates to nodes i, body forces b_{i-1} and b_i\n        F[i-1] = (h / 2.0) * (b[i-1] + b[i])\n        \n    # Last component F_N\n    F[N-1] = (h / 2.0) * b[N-1] + t_R\n    \n    # Solve for nodal displacements U = [u_1, ..., u_N]\n    U = scipy.linalg.solve(K, F)\n    \n    # Create full displacement vector including boundary condition u_0 = 0\n    u_full = np.concatenate(([0.0], U))\n    \n    # Step 2: Compute element-wise FE stress sigma_h\n    sigma_h = np.zeros(N)\n    for i in range(N):\n        sigma_h[i] = E * (u_full[i+1] - u_full[i]) / h\n        \n    # Step 3: Reconstruct equilibrated nodal stresses s_i\n    s = np.zeros(N + 1)\n    s[N] = t_R # Boundary condition at x=L\n    \n    # Backward recurrence to find s_{N-1}, ..., s_0\n    for i in range(N - 1, -1, -1):\n        s[i] = s[i+1] + b[i] * h\n        \n    # Step 4: Evaluate the error estimator\n    total_eta_sq = 0.0\n    for i in range(N):\n        d_i = s[i] - sigma_h[i]\n        b_i = b[i]\n        \n        # Use the provided closed-form integral for eta_K_i^2\n        eta_k_sq = (1 / E) * (d_i**2 * h - d_i * b_i * h**2 + (b_i**2 * h**3) / 3.0)\n        total_eta_sq += eta_k_sq\n        \n    return total_eta_sq\n    \n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # a) L=1.0, E=2.0e11, N=4, b(x)=1.0e6, t_R=0.0\n        {'L': 1.0, 'E': 2.0e11, 'N': 4, 'b': np.full(4, 1.0e6), 't_R': 0.0},\n        \n        # b) L=1.0, E=7.0e10, N=3, b(x)=[1e6, -0.5e6, 2e6], t_R=5.0e6\n        {'L': 1.0, 'E': 7.0e10, 'N': 3, 'b': np.array([1.0e6, -0.5e6, 2.0e6]), 't_R': 5.0e6},\n        \n        # c) L=0.5, E=1.0e11, N=1, b(x)=0, t_R=1.0e6\n        {'L': 0.5, 'E': 1.0e11, 'N': 1, 'b': np.array([0.0]), 't_R': 1.0e6},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_estimator(case['L'], case['E'], case['N'], case['b'], case['t_R'])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3542003"}, {"introduction": "The primary application of *a posteriori* error estimation is to guide adaptive mesh refinement (AMR), enabling simulations to automatically focus computational power on regions with high error. This practice [@problem_id:3542038] immerses you in the core of this adaptive loop by tasking you with implementing the famous Dörfler marking strategy. By using local error indicators to decide which elements to refine, you will directly observe how adaptivity can overcome the challenges posed by singularities and restore optimal convergence rates.", "problem": "Consider small-strain linear elasticity in two dimensions on an L-shaped domain with a re-entrant corner. Let the body be modeled in plane strain with Lamé parameters $\\lambda$ and $\\mu$, and displacement field $\\mathbf{u}$ governed by the strong form $-\\nabla \\cdot \\boldsymbol{\\sigma} = \\mathbf{f}$ in $\\Omega$, with $\\boldsymbol{\\sigma} = \\lambda (\\nabla \\cdot \\mathbf{u}) \\mathbf{I} + 2 \\mu \\, \\boldsymbol{\\varepsilon}(\\mathbf{u})$ and $\\boldsymbol{\\varepsilon}(\\mathbf{u}) = \\tfrac{1}{2}(\\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^{\\top})$, subject to mixed boundary conditions. In domains with re-entrant corners, solutions exhibit singular stress states and reduced regularity near the corner. Adaptive mesh refinement guided by a posteriori error estimation is used to restore optimal convergence rates in the energy norm.\n\nA residual-jump-based estimator partitions the global error surrogate into local indicators $\\eta_K$ per element $K$, and is known to be both reliable and efficient under standard assumptions in the Finite Element Method (FEM). A bulk-chasing strategy selects elements to refine so that a fixed fraction of the global estimator is addressed at each step. One such strategy is known as Dörfler marking. You must implement this marking in a minimal-cardinality sense: among all subsets of elements that capture a prescribed fraction of the total squared indicator, select one with the smallest number of elements.\n\nTo make this implementable without solving the linear elasticity equations, use a scalar surrogate consistent with the singularity class of re-entrant corners (as widely employed in analysis of adaptive methods). Specifically, on the L-shaped domain $\\Omega = [-1,1]^2 \\setminus \\big([0,1]\\times[-1,0]\\big)$ with a re-entrant corner at the origin, model the local indicator scaling near the corner by the power-law\n$$\n\\eta_K \\approx c \\, \\sqrt{h_K} \\, r_K^{\\alpha - 1},\n$$\nwhere $c$ is a positive constant (set $c=1$), $h_K$ is the element size, $r_K$ is the Euclidean distance from the element center to the origin, and $\\alpha = 0.544483736782$ is the L-shaped singularity exponent associated with a homogeneous scalar elliptic model. This surrogate is consistent with the behavior of residual-jump error estimators for problems with corner singularities and captures the necessary near-corner refinement bias.\n\nYour task is to:\n- Construct an initial uniform square tessellation over $\\Omega$ by subdividing $[-1,1]^2$ into $n_x \\times n_y$ equal squares and discarding those whose centers lie in the excised square $[0,1]\\times[-1,0]$. Use $n_x = n_y = 12$.\n- For each element $K$, compute $r_K$ and $\\eta_K$ using the above surrogate. Avoid division by zero by taking $r_K \\leftarrow \\max(r_K, 10^{-6})$.\n- Implement the minimal-cardinality bulk-chasing marking strategy that, for a given parameter $\\theta \\in (0,1)$, selects a set $\\mathcal{M}$ so that the selected elements’ squared indicators capture at least a fraction of the total squared estimator, while the number of marked elements is as small as possible.\n- Refine marked elements by subdividing each selected square into four child squares of half size. Children whose centers fall outside $\\Omega$ must be discarded; those inside replace their parent in the mesh. Recompute indicators on the refined mesh.\n- Repeat the mark-refine cycle for a fixed number of refinement steps, using the same $\\theta$ each time. Use $N_{\\text{steps}} = 7$.\n- At each step $k$, compute the global estimator $E_k = \\left(\\sum_{K} \\eta_K^2\\right)^{1/2}$ and the number of elements $N_k$ currently in the mesh.\n- Estimate the convergence rate $p(\\theta)$ by fitting a line to $(\\log N_k, \\log E_k)$ over the last five refinement steps and taking $p(\\theta) = -\\text{slope}$. This approximates the rate in the model $E(N) \\approx C N^{-p}$ for large $N$.\n\nImplement the above in a single program that evaluates several values of $\\theta$ and reports the estimated convergence rates. You must ensure numerical stability and scientific plausibility of the surrogate and the refinement procedure.\n\nTest suite:\n- Use the following values of $\\theta$: $0.15$, $0.3$, $0.5$, $0.7$, $0.9$.\n- For each $\\theta$, run the full refinement loop and compute $p(\\theta)$ as specified.\n\nAnswer specification:\n- The final output of your program must be a single line containing the list of estimated rates for all $\\theta$ values in the test suite, in the order provided.\n- The format must be a comma-separated list enclosed in square brackets, for example $[p(0.15),p(0.3),p(0.5),p(0.7),p(0.9)]$.\n- Each entry must be a floating-point number. No physical units are required and no angles are involved.\n\nYour program must be self-contained and runnable without any external inputs or files.", "solution": "The problem provides a detailed specification for simulating an adaptive mesh refinement (AMR) procedure for a problem with a corner singularity. The validation confirms that the problem is scientifically sound, well-posed, and contains all necessary information for a deterministic implementation. It is a standard numerical experiment in the field of adaptive finite element methods (AFEM).\n\nThe core task is to implement a `mark-refine` cycle driven by Dörfler marking, using a surrogate error indicator that models the behavior of solutions to elliptic partial differential equations on an L-shaped domain. The ultimate goal is to estimate the convergence rate of the global error estimator as a function of the number of elements for different values of the marking parameter $\\theta$.\n\n**1. Domain and Initial Mesh**\n\nThe computational domain is the L-shaped region $\\Omega = [-1,1]^2 \\setminus \\big([0,1]\\times[-1,0]\\big)$, which features a re-entrant corner at the origin $(0,0)$. This corner induces a singularity in the solution of elliptic boundary value problems, degrading the performance of standard numerical methods on uniform meshes.\n\nThe simulation begins by constructing an initial mesh. A square domain $[-1,1]^2$ is first tessellated into a uniform grid of $n_x \\times n_y$ smaller squares, with $n_x = n_y = 12$. The side length of these initial elements is $h_0 = (1 - (-1))/12 = 1/6$. Elements whose geometric center $(x_c, y_c)$ falls within the excised quadrant, i.e., satisfies $x_c > 0$ and $y_c < 0$, are discarded. This process results in an initial mesh of $N_0 = 12^2 - 6^2 = 144 - 36 = 108$ square elements, which accurately represents the domain $\\Omega$.\n\nEach element $K$ in the mesh is represented by its center coordinates and its side length $h_K$.\n\n**2. Surrogate Error Indicator**\n\nInstead of solving the full linear elasticity equations, which is computationally expensive, we use a surrogate model for the local error indicator $\\eta_K$ on each element $K$. This model is designed to mimic the spatial distribution of the true error, which is dominated by the corner singularity. The formula provided is:\n$$\n\\eta_K = c \\, \\sqrt{h_K} \\, r_K^{\\alpha - 1}\n$$\nwhere:\n- $c=1$ is a constant.\n- $h_K$ is the side length of the square element $K$.\n- $r_K$ is the Euclidean distance from the center of element $K$ to the re-entrant corner at the origin. To prevent division by zero for elements possibly centered at the origin, $r_K$ is clamped to a minimum value: $r_K \\leftarrow \\max(r_K, 10^{-6})$.\n- $\\alpha = 0.544483736782$ is the strength of the singularity. For the Poisson equation on an L-shaped domain, the solution $u$ near the corner has the form $u \\sim r^{\\alpha} \\sin(\\alpha \\phi)$, where $(r, \\phi)$ are polar coordinates. The error is concentrated where gradients of the solution are large. Since $\\alpha < 1$, the term $r_K^{\\alpha - 1}$ becomes large as $r_K \\to 0$, correctly identifying elements near the singularity as having a larger error contribution.\n\n**3. The Adaptive `MARK-REFINE` Algorithm**\n\nThe core of the simulation is an iterative loop that adaptively refines the mesh. For a given marking parameter $\\theta \\in (0,1)$, the loop runs for $N_{\\text{steps}}=7$ iterations. Each iteration consists of four main steps: COMPUTE, MARK, REFINE, and RECORD.\n\n**3A. COMPUTE**\nFor the current mesh $\\mathcal{T}_k$ at step $k$, we first compute the error indicator $\\eta_K$ for every element $K \\in \\mathcal{T}_k$ using the surrogate formula. Then, the total squared error estimator is calculated as the sum of the squares of the local indicators:\n$$\nE_k^2 = \\sum_{K \\in \\mathcal{T}_k} \\eta_K^2\n$$\n\n**3B. MARK**\nThe marking step selects a subset of elements $\\mathcal{M}_k \\subset \\mathcal{T}_k$ for refinement. We employ Dörfler marking (also known as bulk chasing), which aims to refine a sufficient number of elements to guarantee a reduction in the total error. The strategy is to find a set $\\mathcal{M}_k$ with the minimal possible number of elements (minimal cardinality) that satisfies the criterion:\n$$\n\\sum_{K \\in \\mathcal{M}_k} \\eta_K^2 \\ge \\theta E_k^2\n$$\nAlgorithmically, this is achieved by:\n1. Sorting all elements in descending order based on their indicator values $\\eta_K$.\n2. Iterating through the sorted list, adding elements to the marked set $\\mathcal{M}_k$ and accumulating their squared indicators.\n3. Stopping as soon as the accumulated sum reaches the target threshold $\\theta E_k^2$. This greedy approach guarantees that we select the elements with the largest errors while marking the smallest number of them.\n\n**3C. REFINE**\nThe marked elements in $\\mathcal{M}_k$ are refined, while unmarked elements are carried over to the next mesh $\\mathcal{T}_{k+1}$. The refinement procedure for a square element is a simple quadrisection:\n1. Each marked square $K \\in \\mathcal{M}_k$ is subdivided into four equal smaller squares (children), each with half the side length of the parent.\n2. Each child element is checked for validity: its center must lie within the domain $\\Omega$. Children whose centers are in the excised region $[0,1] \\times [-1,0]$ are discarded.\n3. The new mesh $\\mathcal{T}_{k+1}$ is formed by the union of the set of unmarked elements from $\\mathcal{T}_k$ and the set of all valid new child elements.\n\n**3D. RECORD**\nAt each step $k$, we record the number of elements $N_k = |\\mathcal{T}_k|$ and the global error estimator $E_k = \\sqrt{E_k^2}$.\n\n**4. Convergence Rate Estimation**\n\nThe theory of AFEM predicts that for an appropriate adaptive strategy, the convergence of the error $E$ with respect to the number of elements $N$ should follow a power law:\n$$\nE(N) \\approx C N^{-p}\n$$\nwhere $p$ is the convergence rate. For problems with singularities, uniform refinement yields a suboptimal rate, but adaptive refinement can restore the optimal rate, which is related to the singularity exponent $\\alpha$. Taking the logarithm of the above relation yields a linear equation:\n$$\n\\log E \\approx \\log C - p \\log N\n$$\nThis shows that a plot of $\\log E$ versus $\\log N$ should be a straight line with a slope of $-p$.\n\nTo estimate $p$, we perform a linear regression on the collected data points $(\\log N_k, \\log E_k)$. As specified, we use the data from the last five refinement steps (from $k=2$ to $k=6$) to estimate the asymptotic rate, ignoring any initial transient behavior. The slope of the best-fit line is calculated, and the convergence rate is determined as $p(\\theta) = -\\text{slope}$. This entire process is repeated for each value of $\\theta$ in the test suite.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements an adaptive mesh refinement simulation for an L-shaped domain\n    to estimate the convergence rate of a surrogate error estimator.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    ALPHA = 0.544483736782\n    THETAS = [0.15, 0.3, 0.5, 0.7, 0.9]\n    N_STEPS = 7\n    NX, NY = 12, 12\n    R_CLAMP = 1e-6\n\n    def is_in_domain(center):\n        \"\"\"Checks if a point is within the L-shaped domain.\"\"\"\n        x, y = center\n        # The excised region is where x > 0 and y < 0.\n        return not (x > 0 and y < 0)\n\n    def generate_initial_mesh():\n        \"\"\"Creates the initial uniform mesh on the L-shaped domain.\"\"\"\n        h_initial = 2.0 / NX\n        mesh_elements = []\n        for i in range(NX):\n            for j in range(NY):\n                xc = -1.0 + h_initial / 2.0 + i * h_initial\n                yc = -1.0 + h_initial / 2.0 + j * h_initial\n                if is_in_domain((xc, yc)):\n                    # Each element is [center_x, center_y, size]\n                    mesh_elements.append([xc, yc, h_initial])\n        return np.array(mesh_elements)\n\n    def run_simulation(theta):\n        \"\"\"\n        Runs the full mark-refine simulation for a given theta value.\n        \"\"\"\n        mesh = generate_initial_mesh()\n        log_N_E_data = []\n\n        for step in range(N_STEPS):\n            # 1. COMPUTE: Indicators and global estimator\n            if mesh.shape[0] == 0:\n                # This should not happen in a valid run, but as a safeguard.\n                if len(log_N_E_data) >= 5:\n                    break\n                else: # Not enough data points to fit\n                    return np.nan \n\n            centers = mesh[:, :2]\n            sizes = mesh[:, 2]\n            \n            r_k = np.linalg.norm(centers, axis=1)\n            r_k = np.maximum(r_k, R_CLAMP)\n            \n            eta_k = np.sqrt(sizes) * r_k**(ALPHA - 1)\n            eta_k_sq = eta_k**2\n            \n            E_k_sq = np.sum(eta_k_sq)\n            E_k = np.sqrt(E_k_sq)\n            N_k = mesh.shape[0]\n\n            # 2. RECORD: Store log-log data\n            log_N_E_data.append([np.log(N_k), np.log(E_k)])\n\n            # Stop after recording the last step's data\n            if step == N_STEPS - 1:\n                break\n\n            # 3. MARK: Dörfler marking\n            total_eta_sq = E_k_sq\n            target_sum_sq = theta * total_eta_sq\n            \n            sorted_indices = np.argsort(eta_k)[::-1]\n            sorted_eta_k_sq = eta_k_sq[sorted_indices]\n            \n            cumulative_sum_sq = np.cumsum(sorted_eta_k_sq)\n            \n            # Find the number of elements to mark\n            # np.searchsorted finds the index where target would be inserted.\n            # We need to take all elements up to and including this index.\n            num_to_mark = np.searchsorted(cumulative_sum_sq, target_sum_sq) + 1\n            \n            marked_indices = sorted_indices[:num_to_mark]\n            unmarked_indices = sorted_indices[num_to_mark:]\n\n            # 4. REFINE: Create the new mesh\n            unmarked_elements = mesh[unmarked_indices]\n            \n            newly_refined_elements = []\n            for idx in marked_indices:\n                parent_center = mesh[idx, :2]\n                parent_size = mesh[idx, 2]\n                child_size = parent_size / 2.0\n                offset = child_size / 2.0\n                \n                # Generate 4 children\n                child_centers = [\n                    parent_center + np.array([-offset, -offset]),\n                    parent_center + np.array([ offset, -offset]),\n                    parent_center + np.array([-offset,  offset]),\n                    parent_center + np.array([ offset,  offset]),\n                ]\n                \n                for child_center in child_centers:\n                    if is_in_domain(child_center):\n                        newly_refined_elements.append([child_center[0], child_center[1], child_size])\n            \n            if newly_refined_elements:\n                mesh = np.vstack((unmarked_elements, np.array(newly_refined_elements)))\n            else:\n                mesh = unmarked_elements\n        \n        # 5. ESTIMATE CONVERGENCE RATE\n        # Use the last 5 data points for linear regression\n        if len(log_N_E_data) < 5:\n            return np.nan # Cannot fit with fewer than 2 points, but problem asks for 5.\n\n        last_5_data = np.array(log_N_E_data[-5:])\n        log_N = last_5_data[:, 0]\n        log_E = last_5_data[:, 1]\n        \n        # Perform linear regression: log_E = slope * log_N + intercept\n        # np.polyfit returns [slope, intercept]\n        slope, _ = np.polyfit(log_N, log_E, 1)\n        \n        # Convergence rate p = -slope\n        p_theta = -slope\n        return p_theta\n\n    # --- Main Execution ---\n    results = []\n    for theta in THETAS:\n        rate = run_simulation(theta)\n        results.append(rate)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3542038"}]}