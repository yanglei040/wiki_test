{"hands_on_practices": [{"introduction": "Understanding spurious zero-energy modes begins with the ability to detect and quantify them. This first practice provides a direct, computational method for measuring the \"hourglassing\" of an element by projecting its deformation onto the known hourglass mode shapes. By simulating the torsion of a bar discretized with 8-node hexahedral (Hex8) elements under reduced integration [@problem_id:3602265], you will see firsthand how a seemingly smooth deformation can excite these non-physical, zero-energy patterns, providing a foundational understanding of their kinematic origin.", "problem": "Consider the eight-node trilinear hexahedron (Hex8) with one-point (reduced) Gaussian integration in three-dimensional linear elasticity. Begin from the principle of virtual work: the internal virtual work is given by $\\delta W_{\\text{int}} = \\int_{\\Omega} \\boldsymbol{\\varepsilon}(\\mathbf{u}) : \\mathbb{C} : \\boldsymbol{\\varepsilon}(\\delta \\mathbf{u}) \\, dV$, where $\\boldsymbol{\\varepsilon}(\\mathbf{u})$ is the small-strain tensor, $\\mathbb{C}$ is the fourth-order elasticity tensor, and $\\Omega$ is the element domain. For a Hex8 element with one-point integration, the element stiffness matrix is approximated as $\\mathbf{K}_e \\approx \\mathbf{B}(\\xi_0,\\eta_0,\\zeta_0)^{\\top} \\mathbb{C} \\, \\mathbf{B}(\\xi_0,\\eta_0,\\zeta_0) \\, \\det \\mathbf{J}(\\xi_0,\\eta_0,\\zeta_0)$ evaluated at the single reduced integration point $(\\xi_0,\\eta_0,\\zeta_0) = (0,0,0)$. This approximation is rank-deficient for the Hex8 element and admits spurious zero-energy modes, commonly called hourglass modes, that produce zero strain at the integration point and hence cost no energy under the reduced integration rule. These spurious modes can be represented through nodal sign patterns defined on the reference element.\n\nDefine the reference parametric coordinates $(r,s,t)\\in\\{-1,+1\\}^3$ at the eight corner nodes of the hexahedron, ordered as follows: node $1$ at $(r,s,t)=(-1,-1,-1)$, node $2$ at $(+1,-1,-1)$, node $3$ at $(+1,+1,-1)$, node $4$ at $(-1,+1,-1)$, node $5$ at $(-1,-1,+1)$, node $6$ at $(+1,-1,+1)$, node $7$ at $(+1,+1,+1)$, and node $8$ at $(-1,+1,+1)$. Let $h_i^{(1)}=r_i$, $h_i^{(2)}=s_i$, $h_i^{(3)}=t_i$, and $h_i^{(4)}=r_i s_i t_i$ denote the canonical hourglass shape patterns (for $i=1,\\dots,8$ and modes $\\alpha=1,\\dots,4$). For a given element with nodal displacement components $u_i^{(a)}$ in Cartesian direction $a\\in\\{x,y,z\\}$, define the hourglass amplitude in mode $\\alpha$ and direction $a$ by the discrete projection\n$$\nq_{e}^{(\\alpha,a)} = \\frac{1}{8} \\sum_{i=1}^{8} h_i^{(\\alpha)} \\, u_i^{(a)}.\n$$\nThis $q_{e}^{(\\alpha,a)}$ is a measure of how strongly the element’s nodal displacement pattern excites the corresponding spurious zero-energy mode under one-point integration.\n\nNow consider a straight prismatic bar of length $L$ aligned with the global $Z$-axis, with rectangular cross-section of widths $W_x$ and $W_y$ along the global $X$- and $Y$-axes, respectively. The bar is clamped at $Z=0$ and twisted by a small end rotation $\\Theta$ at $Z=L$. Adopt the small-twist kinematics that rigidly rotates each cross-section by an angle $\\theta(Z)=\\Theta \\, Z / L$ about the $Z$-axis. In Cartesian coordinates, the imposed displacement field is\n$$\nu_x(X,Y,Z) = -\\theta(Z) \\, Y = -\\frac{\\Theta}{L} \\, Z \\, Y,\\quad\nu_y(X,Y,Z) = \\theta(Z) \\, X = \\frac{\\Theta}{L} \\, Z \\, X,\\quad\nu_z(X,Y,Z) = 0.\n$$\n\nDiscretize the bar by a structured mesh of Hex8 elements, $N_x \\times N_y \\times N_z$ in the $X$-, $Y$-, and $Z$-directions, respectively. To vary the mesh orientation with respect to the global axes, rotate each element’s local in-plane axes by an angle $\\beta$ about the $Z$-axis, so that local directions $\\mathbf{e}_1$ and $\\mathbf{e}_2$ are obtained by rotating the global $(X,Y)$ axes by $\\beta$, and $\\mathbf{e}_3$ remains aligned with $Z$. Within each element, assume an affine mapping from $(r,s,t)\\in[-1,1]^3$ to the global coordinates:\n$$ \\mathbf{x}(r,s,t) = \\mathbf{x}_c + \\mathbf{R}_z(\\beta) \\begin{bmatrix} \\frac{h_x}{2} r \\\\ \\frac{h_y}{2} s \\\\ \\frac{h_z}{2} t \\end{bmatrix} $$\nwhere $\\mathbf{x}_c$ is the element center in global coordinates, $h_x=W_x/N_x$, $h_y=W_y/N_y$, $h_z=L/N_z$, and $\\mathbf{R}_z(\\beta)$ is the standard rotation matrix about $Z$ by angle $\\beta$.\n\nFor each element, compute the nodal positions at the eight corners by substituting $(r_i,s_i,t_i)$ and then evaluate the imposed twist displacement $(u_x,u_y,u_z)$ at those nodal coordinates. Using the definitions above, compute $q_{e}^{(\\alpha,a)}$ for $\\alpha\\in\\{1,2,3,4\\}$ and $a\\in\\{x,y,z\\}$. As a scalar summary per mesh, define the maximum absolute hourglass amplitude\n$$\nQ_{\\max} = \\max_{e} \\max_{\\alpha\\in\\{1,2,3,4\\}} \\max_{a\\in\\{x,y,z\\}} \\left| q_{e}^{(\\alpha,a)} \\right|.\n$$\nThis $Q_{\\max}$ has the unit of length. Your task is to compute $Q_{\\max}$ for a set of parameterized test cases that vary mesh orientation $\\beta$, twist angle $\\Theta$, and element aspect ratios through $(N_x,N_y,N_z)$.\n\nYou must implement a program that performs the following steps from first principles:\n- Create the structured mesh element centers $\\mathbf{x}_c$ covering $X\\in[-W_x/2,W_x/2]$, $Y\\in[-W_y/2,W_y/2]$, $Z\\in[0,L]$, with $N_x$, $N_y$, $N_z$ elements.\n- For each element, generate its eight nodal coordinates using the affine mapping with rotation $\\beta$ and sizes $(h_x,h_y,h_z)$.\n- Evaluate the imposed displacement field at each node.\n- Compute the four hourglass mode amplitudes $q_{e}^{(\\alpha,a)}$ per element and the scalar $Q_{\\max}$ over the entire mesh.\n\nAll physical quantities use the International System of Units. Specifically:\n- All lengths $L$, $W_x$, $W_y$ must be given in meters, and the output $Q_{\\max}$ must be reported in meters.\n- The angle $\\Theta$ must be given in radians.\n- The mesh orientation angle $\\beta$ must be given in degrees in the input parameter sets and internally converted to radians for computation.\n\nTest Suite:\nCompute $Q_{\\max}$ for the following four test cases. Each case is an ordered tuple $(L,W_x,W_y,N_x,N_y,N_z,\\Theta,\\beta)$ with the units and conventions specified above.\n- Case $1$: $(L,W_x,W_y,N_x,N_y,N_z,\\Theta,\\beta) = (2.0, 1.0, 0.6, 2, 1, 4, 0.1, 0.0)$.\n- Case $2$: $(L,W_x,W_y,N_x,N_y,N_z,\\Theta,\\beta) = (2.0, 1.0, 0.6, 2, 1, 4, 0.1, 45.0)$.\n- Case $3$: $(L,W_x,W_y,N_x,N_y,N_z,\\Theta,\\beta) = (2.0, 1.0, 0.6, 4, 1, 2, 0.1, 0.0)$.\n- Case $4$: $(L,W_x,W_y,N_x,N_y,N_z,\\Theta,\\beta) = (2.0, 1.0, 0.6, 2, 1, 4, 1.0\\times 10^{-6}, 30.0)$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the values of $Q_{\\max}$ for the four cases, in meters, each formatted with exactly $10$ digits after the decimal point, as a comma-separated list enclosed in square brackets. For example, an acceptable output format is $[0.1234567890,0.2345678901,0.3456789012,0.4567890123]$. No additional text should be printed.", "solution": "The user has provided a valid, well-posed problem in computational solid mechanics. The task is to compute the maximum hourglass amplitude, denoted $Q_{\\max}$, for several discretizations of a prismatic bar under torsion. The solution requires a direct, numerical implementation of the provided formulas, proceeding from first principles as laid out in the problem statement. The following steps detail the procedure for calculating $Q_{\\max}$ for a single test case.\n\nThe first step is to establish the geometric and kinematic parameters for a given test case, which is defined by the tuple $(L, W_x, W_y, N_x, N_y, N_z, \\Theta, \\beta_{\\text{deg}})$. The physical dimensions of the bar are length $L$, width $W_x$, and depth $W_y$. It is discretized into a structured mesh of $N_x \\times N_y \\times N_z$ hexahedral elements. The dimensions of each element are $h_x = W_x / N_x$, $h_y = W_y / N_y$, and $h_z = L / N_z$. The total twist angle is $\\Theta$, and the element orientation angle $\\beta$ is obtained by converting $\\beta_{\\text{deg}}$ from degrees to radians.\n\nThe core of the computation involves iterating over every element in the mesh. The domain of the bar is centered in the $X$-$Y$ plane, spanning $X \\in [-W_x/2, W_x/2]$ and $Y \\in [-W_y/2, W_y/2]$, and extends along the $Z$-axis from $Z=0$ to $Z=L$. The center of an element, indexed by $(i,j,k)$ where $i \\in \\{0, \\dots, N_x-1\\}$, $j \\in \\{0, \\dots, N_y-1\\}$, and $k \\in \\{0, \\dots, N_z-1\\}$, is located at global coordinates $\\mathbf{x}_c = [X_c, Y_c, Z_c]^{\\top}$, calculated as:\n$$\nX_c = -\\frac{W_x}{2} + (i + 0.5) h_x\n$$\n$$\nY_c = -\\frac{W_y}{2} + (j + 0.5) h_y\n$$\n$$\nZ_c = (k + 0.5) h_z\n$$\nFor each element, we must determine the global coordinates of its eight nodes. The problem specifies an affine mapping from the reference element domain $(r,s,t) \\in [-1,1]^3$ to the global coordinate system $\\mathbf{x}$:\n$$\n\\mathbf{x}(r,s,t) = \\mathbf{x}_c + \\mathbf{R}_z(\\beta) \\begin{bmatrix} \\frac{h_x}{2} r \\\\ \\frac{h_y}{2} s \\\\ \\frac{h_z}{2} t \\end{bmatrix}\n$$\nwhere $\\mathbf{R}_z(\\beta)$ is the standard rotation matrix about the $Z$-axis:\n$$\n\\mathbf{R}_z(\\beta) = \\begin{bmatrix} \\cos\\beta & -\\sin\\beta & 0 \\\\ \\sin\\beta & \\cos\\beta & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}\n$$\nThe coordinates of the eight nodes, $\\mathbf{x}_i = [X_i, Y_i, Z_i]^{\\top}$ for $i=1,\\dots,8$, are found by substituting the parametric coordinates $(r_i, s_i, t_i)$ corresponding to each node into the mapping function. The nodal ordering and their parametric coordinates $(r_i, s_i, t_i)$ are given as: $1:(-1,-1,-1)$, $2:(+1,-1,-1)$, $3:(+1,+1,-1)$, $4:(-1,+1,-1)$, $5:(-1,-1,+1)$, $6:(+1,-1,+1)$, $7:(+1,+1,+1)$, $8:(-1,+1,+1)$.\n\nOnce the global coordinates $(X_i, Y_i, Z_i)$ for each of the eight nodes are known, the imposed displacement field is evaluated at these locations. The displacement field for small-angle twist is:\n$$\nu_x(X,Y,Z) = -\\frac{\\Theta}{L} Z Y, \\quad u_y(X,Y,Z) = \\frac{\\Theta}{L} Z X, \\quad u_z(X,Y,Z) = 0\n$$\nSubstituting the nodal coordinates $(X_i, Y_i, Z_i)$ yields the nodal displacement components $(u_i^{(x)}, u_i^{(y)}, u_i^{(z)})$.\n\nWith the nodal displacements for an element calculated, the next step is to compute the hourglass mode amplitudes. These amplitudes, $q_{e}^{(\\alpha,a)}$, measure the projection of the element's deformation onto the spurious zero-energy modes. The formula provided is:\n$$\nq_{e}^{(\\alpha,a)} = \\frac{1}{8} \\sum_{i=1}^{8} h_i^{(\\alpha)} \\, u_i^{(a)}\n$$\nThis calculation is performed for each of the four hourglass modes $\\alpha \\in \\{1,2,3,4\\}$ and for each Cartesian direction $a \\in \\{x,y,z\\}$. The hourglass shape patterns, $h_i^{(\\alpha)}$, are defined based on the nodal parametric coordinates: $h_i^{(1)}=r_i$, $h_i^{(2)}=s_i$, $h_i^{(3)}=t_i$, and $h_i^{(4)}=r_i s_i t_i$. This results in a total of $4 \\times 3 = 12$ hourglass amplitudes for each element.\n\nFinally, the overall metric $Q_{\\max}$ is determined by finding the maximum absolute value among all computed hourglass amplitudes across all elements in the mesh:\n$$\nQ_{\\max} = \\max_{e} \\max_{\\alpha\\in\\{1,2,3,4\\}} \\max_{a\\in\\{x,y,z\\}} |q_{e}^{(\\alpha,a)}|\n$$\nThis process is repeated for each of the test cases specified in the problem, and the resulting values of $Q_{\\max}$ are collected. The implementation will use matrix and vector operations for efficiency, particularly for calculating nodal coordinates and the sum-products in the hourglass amplitude formula.", "answer": "```python\nimport numpy as np\n\ndef calculate_q_max(L, Wx, Wy, Nx, Ny, Nz, Theta, beta_deg):\n    \"\"\"\n    Computes the maximum absolute hourglass amplitude Q_max for a given set of parameters.\n    \"\"\"\n    # 1. Define constants and derived parameters\n    hx = Wx / Nx\n    hy = Wy / Ny\n    hz = L / Nz\n    beta_rad = np.deg2rad(beta_deg)\n    k0 = Theta / L\n\n    # 2. Pre-compute helper matrices\n    # Nodal parametric coordinates based on the specified ordering\n    r = np.array([-1, 1, 1, -1, -1, 1, 1, -1])\n    s = np.array([-1, -1, 1, 1, -1, -1, 1, 1])\n    t = np.array([-1, -1, -1, -1, 1, 1, 1, 1])\n\n    # Hourglass shape pattern vectors h_i^(alpha)\n    h1 = r\n    h2 = s\n    h3 = t\n    h4 = r * s * t\n    H = np.array([h1, h2, h3, h4])  # Shape (4, 8)\n\n    # Rotation matrix R_z(beta)\n    c, s_rot = np.cos(beta_rad), np.sin(beta_rad)\n    Rz = np.array([[c, -s_rot, 0], [s_rot, c, 0], [0, 0, 1]])\n\n    # Vector of local coordinates for the 8 nodes relative to the element center\n    nodes_local_coords = 0.5 * np.array([hx * r, hy * s, hz * t]) # Shape (3, 8)\n\n    global_q_max = 0.0\n\n    # 3. Iterate over all elements in the structured mesh\n    for i in range(Nx):\n        for j in range(Ny):\n            for k in range(Nz):\n                # 3.1. Calculate element center coordinates\n                Xc = -Wx / 2 + (i + 0.5) * hx\n                Yc = -Wy / 2 + (j + 0.5) * hy\n                Zc = (k + 0.5) * hz\n                elem_center = np.array([Xc, Yc, Zc])\n\n                # 3.2. Generate global coordinates for the 8 nodes of the element\n                # Use broadcasting: (3,1) + (3,3) @ (3,8) -> (3,8)\n                nodes_global_coords = elem_center[:, np.newaxis] + Rz @ nodes_local_coords\n                X_nodes = nodes_global_coords[0, :]\n                Y_nodes = nodes_global_coords[1, :]\n                Z_nodes = nodes_global_coords[2, :]\n\n                # 3.3. Evaluate the imposed displacement field at each node\n                ux_nodes = -k0 * Z_nodes * Y_nodes\n                uy_nodes = k0 * Z_nodes * X_nodes\n                uz_nodes = np.zeros(8)\n                U = np.array([ux_nodes, uy_nodes, uz_nodes]) # Shape (3, 8)\n\n                # 3.4. Compute the hourglass mode amplitudes for the element\n                # Q_e (4,3) = (1/8) * H(4,8) @ U.T(8,3)\n                Q_e = (1.0 / 8.0) * H @ U.T\n\n                # 3.5. Update the global maximum absolute amplitude\n                elem_q_max = np.max(np.abs(Q_e))\n                if elem_q_max > global_q_max:\n                    global_q_max = elem_q_max\n\n    return global_q_max\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    # Test suite: (L, Wx, Wy, Nx, Ny, Nz, Theta, beta_deg)\n    test_cases = [\n        (2.0, 1.0, 0.6, 2, 1, 4, 0.1, 0.0),\n        (2.0, 1.0, 0.6, 2, 1, 4, 0.1, 45.0),\n        (2.0, 1.0, 0.6, 4, 1, 2, 0.1, 0.0),\n        (2.0, 1.0, 0.6, 2, 1, 4, 1.0e-6, 30.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, Wx, Wy, Nx, Ny, Nz, Theta, beta_deg = case\n        q_max_result = calculate_q_max(L, Wx, Wy, Nx, Ny, Nz, Theta, beta_deg)\n        results.append(f\"{q_max_result:.10f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3602265"}, {"introduction": "Once identified, hourglass modes must be suppressed using a control algorithm to ensure a physically meaningful solution. This exercise transitions from diagnosing the problem to implementing the cure, challenging you to add artificial stiffness to a 2D quadrilateral mesh using two classic control schemes [@problem_id:3602193]. By quantifying the resulting errors in stress and wave speed, you will grapple with the critical trade-off in hourglass control: finding the ideal parameterization that eliminates spurious modes without excessively stiffening the element and corrupting the physical solution.", "problem": "Consider a two-dimensional, linearly elastic, homogeneous rectangular strip of length $L$, height $H$, thickness $t$, mass density $\\rho$, Young's modulus $E$, and Poisson's ratio $\\nu$, modeled under plane stress. The strip is discretized using four-node bilinear quadrilateral elements (denoted $Q_4$) with one-point (reduced) integration at the element center. Reduced integration in $Q_4$ elements is known to admit spurious zero-energy modes (hourglassing), which can corrupt both stress predictions and propagating wave characteristics in explicit dynamics.\n\nThe fundamental base for this problem is the principle of virtual work and the standard small-strain, linearized kinematics and constitutive law. The discrete internal elastic forces follow from the bilinear form\n$$\n\\mathbf{K} = \\sum_{e} \\int_{\\Omega_e} \\mathbf{B}^T \\mathbf{D} \\mathbf{B}\\, t \\, \\mathrm{d}\\Omega,\n$$\nwhere $e$ indexes elements, $\\mathbf{B}$ is the strain-displacement matrix at the quadrature point, $\\mathbf{D}$ is the plane stress constitutive matrix,\n$$\n\\mathbf{D} = \\frac{E}{1-\\nu^2}\n\\begin{bmatrix}\n1 & \\nu & 0 \\\\\n\\nu & 1 & 0 \\\\\n0 & 0 & \\frac{1-\\nu}{2}\n\\end{bmatrix},\n$$\nand $t$ is the thickness. The one-point integration approximates the integral by evaluating $\\mathbf{B}$ and $\\mathbf{D}$ at the element center and multiplying by the physical element area; mass is assembled as a lumped matrix\n$$\n\\mathbf{M} = \\sum_{e} \\rho \\, t \\, A_e \\, \\mathbf{M}_e^{\\text{lumped}},\n$$\nwith $A_e$ the in-plane area of element $e$ and appropriate per-node mass sharing.\n\nTo mitigate hourglassing, add an artificial hourglass control stiffness $\\mathbf{K}_{\\text{hg}}$ to each element. You will implement and compare two distinct algorithms, each parameterized by a non-dimensional control coefficient $\\alpha$ scaled by the material shear modulus $\\mu = \\dfrac{E}{2(1+\\nu)}$ and the thickness $t$:\n\n1. A Wilkins-style pattern control using two linearly independent nodal pattern vectors on the four nodes of a $Q_4$ element,\n   $$\n   \\mathbf{q}_1 = \\begin{bmatrix} 1 & -1 & 1 & -1 \\end{bmatrix}^T,\\quad\n   \\mathbf{q}_2 = \\begin{bmatrix} 1 & 1 & -1 & -1 \\end{bmatrix}^T,\n   $$\n   applied independently to the $u$- and $v$-components of nodal displacement, with stiffness scale $c = \\alpha \\, \\mu \\, t$.\n\n2. A Flanagan–Belytschko-style gradient-based control using constant hourglass vectors defined by the derivatives of bilinear shape functions at the element center,\n   $$\n   \\boldsymbol{\\gamma}_{\\xi} = \\frac{1}{2}\\begin{bmatrix} -1 & 1 & 1 & -1 \\end{bmatrix}^T,\\quad\n   \\boldsymbol{\\gamma}_{\\eta} = \\frac{1}{2}\\begin{bmatrix} -1 & -1 & 1 & 1 \\end{bmatrix}^T,\n   $$\n   applied independently to the $u$- and $v$-components, again with stiffness scale $c = \\alpha \\, \\mu \\, t$.\n\nThese artificial stiffnesses penalize discrete patterns that do not contribute to the strain at the center and should therefore suppress the spurious zero-energy modes; however, overly strong control can artificially stiffen the physical modes and distort stress and wave speed.\n\nYour program must:\n\n- Assemble the global stiffness $\\mathbf{K}_{\\text{tot}} = \\mathbf{K} + \\mathbf{K}_{\\text{hg}}$ and lumped mass $\\mathbf{M}$ for a mesh of $N_x \\times N_y$ elements covering the rectangle $[0,L] \\times [0,H]$.\n\n- Quantify the stress error under a uniform kinematic boundary condition: prescribe a uniform axial strain by setting the boundary nodal displacements to $u(x,y) = \\varepsilon_0 x$, $v(x,y) = 0$, with $\\varepsilon_0$ constant, solve for interior nodal displacements, and compute the average axial stress $\\overline{\\sigma}_{xx}$ over all elements using the center-point strains. The reference stress is $\\sigma_{xx}^{\\text{ref}} = E \\, \\varepsilon_0$. Report the relative stress error\n  $$\n  e_{\\sigma} = \\left| \\frac{\\overline{\\sigma}_{xx} - E \\varepsilon_0}{E \\varepsilon_0} \\right|.\n  $$\n\n- Quantify the wave speed error by solving the constrained generalized eigenproblem for longitudinal vibration with fixed ends: fix all degrees of freedom on the planes $x=0$ and $x=L$ to zero, leave the top and bottom free, and solve\n  $$\n  \\mathbf{K}_{\\text{tot,ff}} \\boldsymbol{\\phi} = \\lambda \\, \\mathbf{M}_{\\text{ff}} \\boldsymbol{\\phi},\n  $$\n  on the remaining free degrees of freedom. Extract the smallest positive eigenvalue $\\lambda_{\\min}$ (ignoring any non-positive or near-zero values). With strip length $L$, estimate the numerical wave speed via the first-mode relation $c_{\\text{num}} = \\dfrac{\\sqrt{\\lambda_{\\min}} \\, L}{\\pi}$, and compare to the continuum extensional wave speed $c_0 = \\sqrt{\\dfrac{E}{\\rho}}$ for an axially dominated mode in plane stress. Report the relative wave speed error\n  $$\n  e_c = \\left| \\frac{c_{\\text{num}} - c_0}{c_0} \\right|.\n  $$\n\n- Diagnose hourglass control strength regimes:\n  - Declare control \"too weak\" if the smallest eigenvalue of the constrained static stiffness matrix $\\mathbf{K}_{\\text{tot,ff}}$ satisfies $\\lambda_{\\min}^{K} < \\tau_K$, where $\\tau_K$ is a small tolerance scale tied to material stiffness; in this problem, use $\\tau_K = 10^{-9} \\, E \\, t$.\n  - Declare control \"too strong\" if either $e_c > \\tau_c$ or $e_{\\sigma} > \\tau_{\\sigma}$; in this problem, use $\\tau_c = 0.10$ and $\\tau_{\\sigma} = 0.05$.\n\nUse the following physical and numerical parameters, expressed in the required units:\n\n- $L = 1.0$ m, $H = 0.2$ m, $t = 0.01$ m.\n- $E = 70\\times 10^9$ Pa, $\\nu = 0.30$, $\\rho = 2700$ kg/m$^3$.\n- $\\varepsilon_0 = 0.001$ (dimensionless).\n- Mesh resolution $N_x = 10$, $N_y = 2$.\n\nImplement the two hourglass control algorithms described above and compare across the following test suite of $(\\text{algorithm}, \\alpha)$ pairs:\n\n- $[\\text{\"none\"}, 0.0]$ (no hourglass control),\n- $[\\text{\"wilkins\"}, 0.01]$,\n- $[\\text{\"wilkins\"}, 0.05]$,\n- $[\\text{\"wilkins\"}, 0.50]$,\n- $[\\text{\"fb\"}, 0.01]$,\n- $[\\text{\"fb\"}, 0.05]$,\n- $[\\text{\"fb\"}, 0.50]$.\n\nFor each test, compute the list $[e_{\\sigma}, e_c, \\text{weak}, \\text{strong}]$, where $e_{\\sigma}$ is a float, $e_c$ is a float, $\\text{weak}$ is a boolean, and $\\text{strong}$ is a boolean. Angle units do not apply. Express stress in pascals (Pa) internally; the final errors $e_{\\sigma}$ and $e_c$ are dimensionless.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a sublist in the same order as above. For example, the output format must be\n$$\n[\\,[e_{\\sigma}^{(1)}, e_c^{(1)}, \\text{weak}^{(1)}, \\text{strong}^{(1)}], \\ldots, [e_{\\sigma}^{(7)}, e_c^{(7)}, \\text{weak}^{(7)}, \\text{strong}^{(7)}]\\,].\n$$", "solution": "The user-provided problem statement has been analyzed and found to be valid. The problem is scientifically grounded in computational solid mechanics, well-posed, objective, and contains sufficient information for a unique solution. The methodologies described—finite element analysis with reduced integration, hourglass control schemes, static analysis for stress accuracy, and eigenvalue analysis for wave propagation—are standard and correctly formulated. The provided parameters and test cases are clear and computationally feasible. The solution proceeds as follows.\n\n### 1. Finite Element Formulation\n\nThe core of the solution is a finite element (FE) model of a two-dimensional rectangular domain under plane stress conditions. The domain is discretized into a structured mesh of $N_x \\times N_y$ four-node bilinear quadrilateral ($Q_4$) elements. Each node possesses two degrees of freedom (DOFs), representing displacements in the $x$ and $y$ directions.\n\n**Element-Level Matrices:**\nFor each element $e$, we compute the stiffness matrix $\\mathbf{K}_e$, the lumped mass matrix $\\mathbf{M}_e$, and the hourglass control stiffness matrix $\\mathbf{K}_{\\text{hg},e}$.\n\nThe element stiffness matrix $\\mathbf{K}_e$ is calculated using one-point quadrature, meaning the integrand is evaluated only at the element's isoparametric center $(\\xi, \\eta) = (0, 0)$.\n$$\n\\mathbf{K}_e = (\\mathbf{B}^T \\mathbf{D} \\mathbf{B})_{(\\xi=0, \\eta=0)} \\cdot A_e \\cdot t\n$$\nwhere $A_e$ is the element area, $t$ is the thickness, $\\mathbf{D}$ is the plane stress constitutive matrix, and $\\mathbf{B}$ is the strain-displacement matrix. For a rectangular element of size $\\Delta x \\times \\Delta y$, the $\\mathbf{B}$ matrix evaluated at the center is constant and depends only on $\\Delta x$ and $\\Delta y$.\n\nThe element lumped mass matrix $\\mathbf{M}_e$ is a diagonal matrix. The total mass of the element, $m_e = \\rho A_e t$, is distributed equally among its four nodes. Each node is assigned a mass of $m_e/4$ for each of its two DOFs.\n\nThe hourglass stiffness matrix $\\mathbf{K}_{\\text{hg},e}$ is added to counteract the spurious zero-energy modes introduced by reduced integration. Its form depends on the chosen algorithm. For both Wilkins and Flanagan-Belytschko (FB) methods as specified, the element hourglass stiffness is constructed from given pattern vectors. Let $\\mathbf{p}_1$ and $\\mathbf{p}_2$ be the two characteristic vectors for a given method (e.g., for Wilkins, $\\mathbf{p}_1 = \\mathbf{q}_1$ and $\\mathbf{p}_2 = \\mathbf{q}_2$). The anti-hourglass stiffness for one displacement component (e.g., $u$) is given by $\\mathbf{Q} = c_e (\\mathbf{p}_1 \\mathbf{p}_1^T + \\mathbf{p}_2 \\mathbf{p}_2^T)$, where $c_e$ is the stiffness scale. The full $8 \\times 8$ element hourglass matrix $\\mathbf{K}_{\\text{hg},e}$ applies this stiffness block independently to both $u$ and $v$ displacements. The stiffness scale is given as $c_e = \\alpha \\mu t$, where $\\alpha$ is the dimensionless control coefficient and $\\mu = E / (2(1+\\nu))$ is the shear modulus.\n\n**Global Assembly:**\nThe global stiffness matrix $\\mathbf{K}_{\\text{tot}}$ and mass matrix $\\mathbf{M}$ are assembled by summing the contributions from all elements.\n$$\n\\mathbf{K}_{\\text{tot}} = \\sum_e (\\mathbf{K}_e + \\mathbf{K}_{\\text{hg},e})\n\\qquad\n\\mathbf{M} = \\sum_e \\mathbf{M}_e\n$$\nA standard assembly procedure maps local element DOFs to their corresponding global DOF indices.\n\n### 2. Static Analysis for Stress Error ($e_{\\sigma}$)\n\nThis analysis quantifies how well the model reproduces a state of uniform stress.\n1.  **Boundary Conditions (BCs):** Nodal displacements on the entire boundary of the rectangle ($x=0, x=L, y=0, y=H$) are prescribed to match a uniform strain field: $u(x,y) = \\varepsilon_0 x$ and $v(x,y) = 0$.\n2.  **System Partitioning:** The global system of equations $\\mathbf{K}_{\\text{tot}} \\mathbf{d} = \\mathbf{f}$ is partitioned into parts corresponding to interior (unknown) and boundary (known) DOFs. This yields $\\mathbf{K}_{\\text{ii}} \\mathbf{d}_{\\text{i}} = -\\mathbf{K}_{\\text{ib}} \\mathbf{d}_{\\text{b}}$, where 'i' denotes interior and 'b' denotes boundary.\n3.  **Solution:** The system is solved for the interior displacements $\\mathbf{d}_{\\text{i}}$. For the case with no hourglass control ($\\alpha = 0$), the matrix $\\mathbf{K}_{\\text{ii}}$ may be singular. A least-squares solver is used to find the minimum-norm solution, which is robust in such cases.\n4.  **Stress Calculation:** With the full displacement vector $\\mathbf{d}$ (both prescribed and solved parts), the strain $\\boldsymbol{\\epsilon}_e = \\mathbf{B} \\mathbf{d}_e$ and stress $\\boldsymbol{\\sigma}_e = \\mathbf{D} \\boldsymbol{\\epsilon}_e$ are computed at the center of each element.\n5.  **Error Calculation:** The average axial stress $\\overline{\\sigma}_{xx}$ across all elements is computed. The relative error is then $e_{\\sigma} = | (\\overline{\\sigma}_{xx} / \\sigma_{xx}^{\\text{ref}}) - 1 |$, with the reference stress being $\\sigma_{xx}^{\\text{ref}} = E \\varepsilon_0$.\n\n### 3. Eigenvalue Analysis for Wave Speed Error ($e_c$)\n\nThis analysis assesses the effect of hourglass control on the dynamic properties of the mesh, specifically the speed of longitudinal waves.\n1.  **Boundary Conditions (BCs):** All DOFs for nodes on the planes $x=0$ and $x=L$ are fixed (constrained to zero). All other DOFs are free.\n2.  **System Partitioning:** The global matrices $\\mathbf{K}_{\\text{tot}}$ and $\\mathbf{M}$ are reduced to only the free DOFs, yielding $\\mathbf{K}_{\\text{ff}}$ and $\\mathbf{M}_{\\text{ff}}$.\n3.  **Eigenproblem solution:** The generalized eigenvalue problem $\\mathbf{K}_{\\text{ff}} \\boldsymbol{\\phi} = \\lambda \\mathbf{M}_{\\text{ff}} \\boldsymbol{\\phi}$ is solved. The eigenvalues $\\lambda$ correspond to the squared natural frequencies ($\\omega^2$) of the free system.\n4.  **Wave Speed Calculation:** The smallest strictly positive eigenvalue, $\\lambda_{\\min}$, is identified. This corresponds to the fundamental mode of vibration. The numerical wave speed is estimated using the formula for a 1D rod: $c_{\\text{num}} = \\sqrt{\\lambda_{\\min}} L / \\pi$.\n5.  **Error Calculation:** This numerical speed is compared to the theoretical 1D extensional wave speed, $c_0 = \\sqrt{E/\\rho}$. The relative error is $e_c = | (c_{\\text{num}} / c_0) - 1 |$.\n\n### 4. Diagnosis of Control Strength\n\nFinally, the implemented hourglass control for each parameter set is diagnosed as \"too weak\" or \"too strong\" based on the following criteria.\n*   **\"Too weak\":** The control is insufficient if the constrained stiffness matrix $\\mathbf{K}_{\\text{ff}}$ is nearly singular, which indicates the presence of barely-resisted zero-energy modes. This is checked by computing the smallest eigenvalue of $\\mathbf{K}_{\\text{ff}}$, denoted $\\lambda_{\\min}^K$. If $\\lambda_{\\min}^K < \\tau_K = 10^{-9} E t$, the `weak` flag is set to `True`.\n*   **\"Too strong\":** The control is excessive if it unacceptably pollutes the physical response. This is diagnosed by checking if either the stress error or the wave speed error exceeds predefined tolerances. If $e_{\\sigma} > \\tau_{\\sigma} = 0.05$ or $e_c > \\tau_c = 0.10$, the `strong` flag is set to `True`.\n\nThis entire procedure is repeated for each of the seven test cases specified in the problem statement. The results are then collected and formatted into the required output.", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh, eigvalsh\n\ndef solve():\n    # --- PHYSICAL AND NUMERICAL PARAMETERS ---\n    L = 1.0  # m\n    H = 0.2  # m\n    t = 0.01  # m\n    E = 70.0e9  # Pa\n    nu = 0.30\n    rho = 2700.0  # kg/m^3\n    eps0 = 0.001\n\n    # --- MESH PARAMETERS ---\n    Nx = 10\n    Ny = 2\n\n    # --- DIAGNOSIS TOLERANCES ---\n    tau_K = 1.0e-9 * E * t\n    tau_c = 0.10\n    tau_sigma = 0.05\n\n    # --- TEST CASES ---\n    test_cases = [\n        (\"none\", 0.0),\n        (\"wilkins\", 0.01),\n        (\"wilkins\", 0.05),\n        (\"wilkins\", 0.50),\n        (\"fb\", 0.01),\n        (\"fb\", 0.05),\n        (\"fb\", 0.50),\n    ]\n\n    def run_single_case(algorithm, alpha):\n        # --- DERIVED PARAMETERS ---\n        mu = E / (2.0 * (1.0 + nu))\n        c_hg = alpha * mu * t\n        \n        # Plane stress constitutive matrix D\n        D_factor = E / (1.0 - nu**2)\n        D = D_factor * np.array([\n            [1.0, nu, 0.0],\n            [nu, 1.0, 0.0],\n            [0.0, 0.0, (1.0 - nu) / 2.0]\n        ])\n\n        # --- MESH GENERATION ---\n        num_nodes_x = Nx + 1\n        num_nodes_y = Ny + 1\n        num_nodes = num_nodes_x * num_nodes_y\n        num_dofs = 2 * num_nodes\n        \n        dx = L / Nx\n        dy = H / Ny\n        A_e = dx * dy\n\n        node_coords = np.zeros((num_nodes, 2))\n        for i in range(num_nodes_x):\n            for j in range(num_nodes_y):\n                node_id = i * num_nodes_y + j\n                node_coords[node_id] = [i * dx, j * dy]\n\n        elements = np.zeros((Nx * Ny, 4), dtype=int)\n        for i in range(Nx):\n            for j in range(Ny):\n                el_id = i * Ny + j\n                n1 = i * num_nodes_y + j\n                n2 = (i + 1) * num_nodes_y + j\n                n3 = (i + 1) * num_nodes_y + (j + 1)\n                n4 = i * num_nodes_y + (j + 1)\n                elements[el_id] = [n1, n2, n3, n4]\n\n        # --- ELEMENT-LEVEL MATRICES (CONSTANT FOR UNIFORM MESH) ---\n        # Strain-displacement matrix B at element center\n        dN_dxi = 0.25 * np.array([-1, 1, 1, -1])\n        dN_deta = 0.25 * np.array([-1, -1, 1, 1])\n        J_inv = np.array([[2.0 / dx, 0.0], [0.0, 2.0 / dy]])\n        dN_dxy = J_inv @ np.vstack([dN_dxi, dN_deta])\n        dN_dx = dN_dxy[0, :]\n        dN_dy = dN_dxy[1, :]\n        \n        B = np.zeros((3, 8))\n        for i in range(4):\n            B[0, 2 * i] = dN_dx[i]\n            B[1, 2 * i + 1] = dN_dy[i]\n            B[2, 2 * i] = dN_dy[i]\n            B[2, 2 * i + 1] = dN_dx[i]\n\n        Ke = B.T @ D @ B * A_e * t\n\n        # Lumped mass matrix\n        m_node = rho * A_e * t / 4.0\n        Me = np.diag([m_node] * 8)\n\n        # Hourglass stiffness matrix\n        K_hg_e = np.zeros((8, 8))\n        if algorithm != \"none\":\n            if algorithm == \"wilkins\":\n                p1 = np.array([1, -1, 1, -1])\n                p2 = np.array([1, 1, -1, -1])\n            elif algorithm == \"fb\":\n                p1 = 0.5 * np.array([-1, 1, 1, -1])\n                p2 = 0.5 * np.array([-1, -1, 1, 1])\n            else:\n                raise ValueError(\"Unknown algorithm\")\n            \n            Q = p1[:, None] @ p1[None, :] + p2[:, None] @ p2[None, :]\n            K_hg_u = c_hg * Q\n            K_hg_e[0::2, 0::2] = K_hg_u\n            K_hg_e[1::2, 1::2] = K_hg_u\n\n        # --- ASSEMBLY ---\n        K_tot = np.zeros((num_dofs, num_dofs))\n        M = np.zeros((num_dofs, num_dofs))\n        for el_nodes in elements:\n            dof_map = np.empty(8, dtype=int)\n            for i in range(4):\n                dof_map[2 * i] = 2 * el_nodes[i]\n                dof_map[2 * i + 1] = 2 * el_nodes[i] + 1\n            \n            ix = np.ix_(dof_map, dof_map)\n            K_tot[ix] += Ke + K_hg_e\n            M[ix] += Me\n\n        # --- STRESS ERROR ANALYSIS ---\n        is_boundary_node = np.zeros(num_nodes, dtype=bool)\n        tol = 1e-9\n        is_boundary_node[node_coords[:, 0] < tol] = True\n        is_boundary_node[node_coords[:, 0] > L - tol] = True\n        is_boundary_node[node_coords[:, 1] < tol] = True\n        is_boundary_node[node_coords[:, 1] > H - tol] = True\n        \n        boundary_dofs = np.where(np.repeat(is_boundary_node, 2))[0]\n        interior_dofs = np.where(np.logical_not(np.repeat(is_boundary_node, 2)))[0]\n\n        d_b = np.zeros(len(boundary_dofs))\n        boundary_nodes = np.where(is_boundary_node)[0]\n        for i, b_dof in enumerate(boundary_dofs):\n            node_idx = b_dof // 2\n            coord = b_dof % 2\n            if coord == 0: # u-dof\n                d_b[i] = eps0 * node_coords[node_idx, 0]\n            # v-dof is 0\n\n        K_ii = K_tot[np.ix_(interior_dofs, interior_dofs)]\n        K_ib = K_tot[np.ix_(interior_dofs, boundary_dofs)]\n        \n        f_i = -K_ib @ d_b\n        \n        if algorithm == \"none\": # Use least squares for potentially singular matrix\n            d_i, _, _, _ = np.linalg.lstsq(K_ii, f_i, rcond=None)\n        else:\n            d_i = np.linalg.solve(K_ii, f_i)\n        \n        d = np.zeros(num_dofs)\n        d[boundary_dofs] = d_b\n        d[interior_dofs] = d_i\n\n        stresses = []\n        for el_nodes in elements:\n            el_dofs = np.empty(8, dtype=int)\n            for i in range(4):\n                el_dofs[2*i] = 2*el_nodes[i]\n                el_dofs[2*i+1] = 2*el_nodes[i]+1\n            d_e = d[el_dofs]\n            strain_e = B @ d_e\n            stress_e = D @ strain_e\n            stresses.append(stress_e[0]) # sigma_xx\n        \n        avg_sigma_xx = np.mean(stresses)\n        ref_sigma_xx = E * eps0\n        e_sigma = np.abs(avg_sigma_xx / ref_sigma_xx - 1.0)\n        \n        # --- WAVE SPEED ERROR ANALYSIS ---\n        is_fixed_node = (node_coords[:, 0] < tol) | (node_coords[:, 0] > L - tol)\n        fixed_dofs = np.where(np.repeat(is_fixed_node, 2))[0]\n        free_dofs = np.setdiff1d(np.arange(num_dofs), fixed_dofs)\n        \n        K_ff = K_tot[np.ix_(free_dofs, free_dofs)]\n        M_ff = M[np.ix_(free_dofs, free_dofs)]\n\n        eigvals = eigh(K_ff, M_ff, eigvals_only=True)\n        lambda_min = eigvals[eigvals > 1e-6]\n        if len(lambda_min) > 0:\n            lambda_min = lambda_min[0]\n            c_num = np.sqrt(lambda_min) * L / np.pi\n            c0 = np.sqrt(E / rho)\n            e_c = np.abs(c_num / c0 - 1.0)\n        else:\n            e_c = np.inf # No positive eigenvalue found\n\n        # --- DIAGNOSIS ---\n        eigvals_K = eigvalsh(K_ff)\n        lambda_min_K = eigvals_K[0] if len(eigvals_K) > 0 else 0.0\n        \n        is_weak = lambda_min_K < tau_K\n        is_strong = (e_c > tau_c) or (e_sigma > tau_sigma)\n        \n        return [e_sigma, e_c, is_weak, is_strong]\n\n    results = []\n    for algorithm, alpha in test_cases:\n        res = run_single_case(algorithm, alpha)\n        results.append(res)\n    \n    # --- FORMATTING OUTPUT ---\n    def format_val(v):\n        if isinstance(v, bool):\n            return str(v).lower()\n        return f\"{v:.6g}\"\n\n    result_str = \",\".join(\n        f'[{\",\".join(map(format_val, case))}]' for case in results\n    )\n    print(f\"[{result_str}]\")\n\n\nsolve()\n```", "id": "3602193"}, {"introduction": "The most catastrophic effects of hourglassing often appear in explicit dynamic simulations, where uncontrolled modes can lead to explosive instabilities. This final practice zooms in on the temporal behavior of a single hourglass mode, modeling it as a simple oscillator subject to different control strategies and mass matrix formulations [@problem_id:3602209]. By analyzing the stability of the time integration scheme, you will discover how choices in the numerical setup, such as using a lumped versus a consistent mass matrix, directly influence whether these parasitic modes decay or grow over time.", "problem": "Consider a single underintegrated $4$-node bilinear quadrilateral (Q4) finite element of the Finite Element Method (FEM) in two spatial dimensions, but restrict attention to a single scalar degree of freedom per node aligned with one Cartesian direction. Under $1$-point (reduced) integration, this element exhibits a spurious zero-energy hourglass mode. Let the nodal displacement vector be $u \\in \\mathbb{R}^4$, and select one canonical hourglass pattern vector $q \\in \\mathbb{R}^4$ defined by\n$$\nq = \\begin{bmatrix} 1 \\\\ -1 \\\\ 1 \\\\ -1 \\end{bmatrix}.\n$$\nAssume a unit square element with area $A = 1$, unit lumped density-thickness $\\rho t = 1$, and adopt the following mass matrices for the scalar degree of freedom per node:\n- The consistent mass matrix $M_c$ given by\n$$\nM_c = \\frac{A}{36} \\begin{bmatrix}\n4 & 2 & 1 & 2 \\\\\n2 & 4 & 2 & 1 \\\\\n1 & 2 & 4 & 2 \\\\\n2 & 1 & 2 & 4\n\\end{bmatrix},\n$$\n- The lumped mass matrix $M_l$ given by\n$$\nM_l = \\operatorname{diag}\\left(\\frac{A}{4}, \\frac{A}{4}, \\frac{A}{4}, \\frac{A}{4}\\right).\n$$\nArtificial hourglass control is modeled as viscous and stiffness penalization acting only in the hourglass subspace spanned by $q$, with\n$$\nK_{\\mathrm{hg}} = k_0 \\, q q^{\\mathsf{T}}, \\qquad C_{\\mathrm{hg}} = c_0 \\, q q^{\\mathsf{T}},\n$$\nwhere $k_0 \\ge 0$ and $c_0 \\ge 0$ are nondimensional control parameters. Consider the semi-discrete free-vibration equation in the hourglass subspace, projected by the ansatz $u(t) = a(t) q$:\n$$\nM \\, \\ddot{u}(t) + C_{\\mathrm{hg}} \\, \\dot{u}(t) + K_{\\mathrm{hg}} \\, u(t) = 0.\n$$\nProjecting onto $q$ yields a single-degree-of-freedom oscillator for the hourglass amplitude $a(t)$:\n$$\nm \\, \\ddot{a}(t) + c \\, \\dot{a}(t) + k \\, a(t) = 0,\n$$\nwith the effective modal coefficients\n$$\nm = q^{\\mathsf{T}} M q, \\qquad c = q^{\\mathsf{T}} C_{\\mathrm{hg}} q = c_0 \\, (q^{\\mathsf{T}} q)^2, \\qquad k = q^{\\mathsf{T}} K_{\\mathrm{hg}} q = k_0 \\, (q^{\\mathsf{T}} q)^2.\n$$\nAll quantities are nondimensional; no physical units are required or expected in the answer.\n\nTime integration is performed by the Newmark family with average acceleration parameters $\\gamma = \\tfrac{1}{2}$ and $\\beta = \\tfrac{1}{4}$. Denote the discrete time step by $\\Delta t > 0$. For given $(m,c,k,\\Delta t)$, the Newmark method defines a linear amplification operator that maps the state vector $[u^n, v^n, a^n]^{\\mathsf{T}}$ at time step $n$ to $[u^{n+1}, v^{n+1}, a^{n+1}]^{\\mathsf{T}}$ at time step $n+1$. The growth/decay factor of the hourglass mode for one time step is the spectral radius $\\rho$ of this amplification operator, i.e., the maximum modulus among its eigenvalues. Values $\\rho < 1$ imply decay, $\\rho = 1$ implies neutral propagation, and $\\rho > 1$ implies growth.\n\nTasks:\n- Derive $m$ for both $M = M_c$ (consistent) and $M = M_l$ (lumped).\n- Construct the $3 \\times 3$ amplification matrix for the Newmark average acceleration method (with $\\gamma = \\tfrac{1}{2}$ and $\\beta = \\tfrac{1}{4}$) applied to the scalar oscillator $m \\, \\ddot{a} + c \\, \\dot{a} + k \\, a = 0$, treating $[u,v,a]$ as the state.\n- For each test case below, compute the spectral radius $\\rho_c$ using $M = M_c$ and $\\rho_l$ using $M = M_l$ with identical $(k_0,c_0,\\Delta t)$. Use $q^{\\mathsf{T}} q = 4$ and the definitions above to obtain $k$ and $c$ from $(k_0,c_0)$.\n- Identify whether mass lumping exacerbates spurious oscillations, defined here as the predicate $\\rho_l > \\rho_c$.\n\nTest suite:\n- Case $1$: $(k_0, c_0, \\Delta t) = (0.5, 0.1, 0.2)$.\n- Case $2$: $(k_0, c_0, \\Delta t) = (0.0, 0.1, 0.4)$.\n- Case $3$: $(k_0, c_0, \\Delta t) = (0.0, 0.0, 0.1)$.\n- Case $4$: $(k_0, c_0, \\Delta t) = (2.0, 0.02, 0.05)$.\n\nYour program must:\n- Implement the derivation numerically as stated to produce $\\rho_c$ and $\\rho_l$ for each case, rounded to $8$ decimal places.\n- For each case, output a list $[\\rho_c, \\rho_l, \\text{exacerbate}]$, where $\\text{exacerbate}$ is a boolean that is $\\text{True}$ if and only if $\\rho_l > \\rho_c$.\n- Aggregate all four case results into a single list in the order given.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each case formatted as specified and floats rounded to $8$ decimals, e.g., $[[\\rho_{c,1},\\rho_{l,1},\\text{bool}_1],[\\rho_{c,2},\\rho_{l,2},\\text{bool}_2],[\\rho_{c,3},\\rho_{l,3},\\text{bool}_3],[\\rho_{c,4},\\rho_{l,4},\\text{bool}_4]]$.", "solution": "The user has provided a well-posed problem statement from the field of computational solid mechanics. It is scientifically grounded, objective, and contains all necessary information to proceed with a unique solution. The problem is therefore deemed valid.\n\nThe task is to analyze the stability of a spurious hourglass mode in a $4$-node quadrilateral finite element under different mass matrix formulations (consistent vs. lumped) when using the Newmark average acceleration method for time integration. The stability is quantified by the spectral radius of the amplification operator associated with the numerical scheme.\n\n### Step 1: Derivation of Modal Parameters\n\nThe dynamics of the hourglass mode are projected onto the canonical hourglass vector $q = \\begin{bmatrix} 1 & -1 & 1 & -1 \\end{bmatrix}^{\\mathsf{T}}$, resulting in a single-degree-of-freedom oscillator for the modal amplitude $a(t)$:\n$$\nm \\, \\ddot{a}(t) + c \\, \\dot{a}(t) + k \\, a(t) = 0\n$$\nThe effective modal parameters $m$, $c$, and $k$ are derived by projecting the full system matrices onto the hourglass mode $q$.\n\n**Effective Stiffness and Damping:**\nThe hourglass stiffness and damping are given by $K_{\\mathrm{hg}} = k_0 \\, q q^{\\mathsf{T}}$ and $C_{\\mathrm{hg}} = c_0 \\, q q^{\\mathsf{T}}$. The effective modal coefficients are:\n$$\nk = q^{\\mathsf{T}} K_{\\mathrm{hg}} q = q^{\\mathsf{T}} (k_0 \\, q q^{\\mathsf{T}}) q = k_0 (q^{\\mathsf{T}} q) (q^{\\mathsf{T}} q) = k_0 (q^{\\mathsf{T}} q)^2\n$$\n$$\nc = q^{\\mathsf{T}} C_{\\mathrm{hg}} q = q^{\\mathsf{T}} (c_0 \\, q q^{\\mathsf{T}}) q = c_0 (q^{\\mathsf{T}} q) (q^{\\mathsf{T}} q) = c_0 (q^{\\mathsf{T}} q)^2\n$$\nGiven the vector $q$, we first compute the scalar product $q^{\\mathsf{T}} q$:\n$$\nq^{\\mathsf{T}} q = (1)^2 + (-1)^2 + (1)^2 + (-1)^2 = 1+1+1+1=4\n$$\nTherefore, the effective stiffness and damping are:\n$$\nk = k_0 (4)^2 = 16 k_0\n$$\n$$\nc = c_0 (4)^2 = 16 c_0\n$$\n\n**Effective Mass:**\nThe effective modal mass $m$ is given by $m = q^{\\mathsf{T}} M q$. We must compute this for both the lumped and consistent mass matrices, with element area $A=1$.\n\n1.  **Lumped Mass Matrix ($M_l$):**\n    The lumped mass matrix is diagonal: $M_l = \\operatorname{diag}\\left(\\frac{A}{4}, \\frac{A}{4}, \\frac{A}{4}, \\frac{A}{4}\\right) = \\frac{1}{4} I$, where $I$ is the $4 \\times 4$ identity matrix.\n    $$\n    m_l = q^{\\mathsf{T}} M_l q = q^{\\mathsf{T}} \\left(\\frac{1}{4} I\\right) q = \\frac{1}{4} q^{\\mathsf{T}} q = \\frac{1}{4} (4) = 1\n    $$\n    The effective mass for the lumped formulation is $m_l = 1$.\n\n2.  **Consistent Mass Matrix ($M_c$):**\n    The consistent mass matrix is given by $M_c = \\frac{A}{36} \\begin{bmatrix} 4 & 2 & 1 & 2 \\\\ 2 & 4 & 2 & 1 \\\\ 1 & 2 & 4 & 2 \\\\ 2 & 1 & 2 & 4 \\end{bmatrix} = \\frac{1}{36} \\begin{bmatrix} 4 & 2 & 1 & 2 \\\\ 2 & 4 & 2 & 1 \\\\ 1 & 2 & 4 & 2 \\\\ 2 & 1 & 2 & 4 \\end{bmatrix}$.\n    We compute the product $M_c q$:\n    $$\n    M_c q = \\frac{1}{36} \\begin{bmatrix} 4 & 2 & 1 & 2 \\\\ 2 & 4 & 2 & 1 \\\\ 1 & 2 & 4 & 2 \\\\ 2 & 1 & 2 & 4 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ -1 \\\\ 1 \\\\ -1 \\end{bmatrix} = \\frac{1}{36} \\begin{bmatrix} 4(1) + 2(-1) + 1(1) + 2(-1) \\\\ 2(1) + 4(-1) + 2(1) + 1(-1) \\\\ 1(1) + 2(-1) + 4(1) + 2(-1) \\\\ 2(1) + 1(-1) + 2(1) + 4(-1) \\end{bmatrix} = \\frac{1}{36} \\begin{bmatrix} 1 \\\\ -1 \\\\ 1 \\\\ -1 \\end{bmatrix} = \\frac{1}{36} q\n    $$\n    The hourglass vector $q$ is an eigenvector of $M_c$ with eigenvalue $\\frac{1}{36}$.\n    The effective mass is then:\n    $$\n    m_c = q^{\\mathsf{T}} M_c q = q^{\\mathsf{T}} \\left(\\frac{1}{36} q\\right) = \\frac{1}{36} q^{\\mathsf{T}} q = \\frac{1}{36}(4) = \\frac{1}{9}\n    $$\n    The effective mass for the consistent formulation is $m_c = \\frac{1}{9}$. Notably, $m_c < m_l$.\n\n### Step 2: Newmark Amplification Matrix\n\nThe Newmark family of methods is used for time integration. The specific parameters are $\\gamma = \\frac{1}{2}$ and $\\beta = \\frac{1}{4}$, corresponding to the average acceleration method, which is unconditionally stable for linear systems. We denote the modal displacement, velocity, and acceleration at time step $n$ by $d_n$, $v_n$, and $A_n$ respectively. The state is represented by the vector $[d_n, v_n, A_n]^{\\mathsf{T}}$. The updates to find the state at $n+1$ are given by:\n$$\nd_{n+1} = d_n + \\Delta t \\, v_n + \\Delta t^2 \\left[ \\left(\\frac{1}{2} - \\beta\\right) A_n + \\beta A_{n+1} \\right]\n$$\n$$\nv_{n+1} = v_n + \\Delta t \\left[ (1 - \\gamma) A_n + \\gamma A_{n+1} \\right]\n$$\nAnd the equation of motion must be satisfied at time $t_{n+1}$:\n$$\nm A_{n+1} + c v_{n+1} + k d_{n+1} = 0\n$$\nSubstituting $\\gamma = \\frac{1}{2}$ and $\\beta = \\frac{1}{4}$:\n$$\nd_{n+1} = d_n + \\Delta t \\, v_n + \\frac{\\Delta t^2}{4} (A_n + A_{n+1})\n$$\n$$\nv_{n+1} = v_n + \\frac{\\Delta t}{2} (A_n + A_{n+1})\n$$\nWe can express the state $[d_{n+1}, v_{n+1}, A_{n+1}]^{\\mathsf{T}}$ as a linear transformation of the state $[d_n, v_n, A_n]^{\\mathsf{T}}$. To do this, we first solve for $A_{n+1}$ by substituting the expressions for $d_{n+1}$ and $v_{n+1}$ into the equation of motion:\n$$\nm A_{n+1} + c \\left(v_n + \\frac{\\Delta t}{2} A_n + \\frac{\\Delta t}{2} A_{n+1}\\right) + k \\left(d_n + \\Delta t \\, v_n + \\frac{\\Delta t^2}{4} A_n + \\frac{\\Delta t^2}{4} A_{n+1}\\right) = 0\n$$\nCollecting terms for $A_{n+1}$:\n$$\n\\left( m + c\\frac{\\Delta t}{2} + k\\frac{\\Delta t^2}{4} \\right) A_{n+1} = -k d_n - (c + k \\Delta t) v_n - \\left( c\\frac{\\Delta t}{2} + k\\frac{\\Delta t^2}{4} \\right) A_n\n$$\nLet $D = m + c\\frac{\\Delta t}{2} + k\\frac{\\Delta t^2}{4}$. We can write $A_{n+1}$ as a linear combination of the state at step $n$:\n$$\nA_{n+1} = \\left(-\\frac{k}{D}\\right) d_n + \\left(-\\frac{c + k \\Delta t}{D}\\right) v_n + \\left(-\\frac{c\\Delta t/2 + k\\Delta t^2/4}{D}\\right) A_n\n$$\nLet this be $A_{n+1} = A_{31} d_n + A_{32} v_n + A_{33} A_n$. The expressions for $d_{n+1}$ and $v_{n+1}$ can now be written in terms of the state at $n$:\n$$\nd_{n+1} = d_n + \\Delta t v_n + \\frac{\\Delta t^2}{4} A_n + \\frac{\\Delta t^2}{4} (A_{31} d_n + A_{32} v_n + A_{33} A_n)\n$$\n$$\nv_{n+1} = v_n + \\frac{\\Delta t}{2} A_n + \\frac{\\Delta t}{2} (A_{31} d_n + A_{32} v_n + A_{33} A_n)\n$$\nThis defines the $3 \\times 3$ amplification matrix $\\mathbf{A}$ such that $[d_{n+1}, v_{n+1}, A_{n+1}]^{\\mathsf{T}} = \\mathbf{A} [d_n, v_n, A_n]^{\\mathsf{T}}$:\n$$\n\\mathbf{A} = \\begin{bmatrix}\n1 + \\frac{\\Delta t^2}{4} A_{31} & \\Delta t + \\frac{\\Delta t^2}{4} A_{32} & \\frac{\\Delta t^2}{4}(1 + A_{33}) \\\\\n\\frac{\\Delta t}{2} A_{31} & 1 + \\frac{\\Delta t}{2} A_{32} & \\frac{\\Delta t}{2}(1 + A_{33}) \\\\\nA_{31} & A_{32} & A_{33}\n\\end{bmatrix}\n$$\n\n### Step 3: Spectral Radius and Stability Analysis\n\nThe stability of the numerical scheme is governed by the eigenvalues of the amplification matrix $\\mathbf{A}$. The method is stable if all eigenvalues have a magnitude less than or equal to one. The spectral radius, $\\rho(\\mathbf{A})$, is the maximum magnitude among the eigenvalues:\n$$\n\\rho(\\mathbf{A}) = \\max_i |\\lambda_i|\n$$\nwhere $\\lambda_i$ are the eigenvalues of $\\mathbf{A}$.\n- If $\\rho < 1$, any initial perturbation will decay, indicating numerical damping.\n- If $\\rho = 1$, the amplitude of the mode is neutrally stable.\n- If $\\rho > 1$, the mode will grow, leading to numerical instability.\n\nA larger spectral radius (closer to $1$) implies less numerical damping and thus a more persistent (exacerbated) spurious oscillation. We will compute the spectral radius for both the consistent mass case, $\\rho_c=\\rho(\\mathbf{A}_c)$, and the lumped mass case, $\\rho_l=\\rho(\\mathbf{A}_l)$. The predicate $\\rho_l > \\rho_c$ determines if mass lumping exacerbates the hourglass mode for a given set of parameters.\n\n### Step 4: Numerical Evaluation for Test Cases\n\nFor each test case $(k_0, c_0, \\Delta t)$, the following algorithm is executed:\n1.  Calculate $k = 16 k_0$ and $c = 16 c_0$.\n2.  **Consistent Mass Case:**\n    a. Set $m = m_c = 1/9$.\n    b. Construct the amplification matrix $\\mathbf{A}_c$ using $(m, c, k, \\Delta t)$.\n    c. Compute the eigenvalues of $\\mathbf{A}_c$ and find the spectral radius $\\rho_c$.\n3.  **Lumped Mass Case:**\n    a. Set $m = m_l = 1$.\n    b. Construct the amplification matrix $\\mathbf{A}_l$ using $(m, c, k, \\Delta t)$.\n    c. Compute the eigenvalues of $\\mathbf{A}_l$ and find the spectral radius $\\rho_l$.\n4.  Compare the results to determine if $\\rho_l > \\rho_c$.\n5.  Store the triplet $[\\rho_c, \\rho_l, (\\rho_l > \\rho_c)]$ for the final output, with floating-point numbers rounded to $8$ decimal places.\n\nThis procedure will be implemented in the provided Python script.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing hourglass mode stability for consistent\n    and lumped mass matrices using the Newmark average acceleration method.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (k0, c0, dt)\n        (0.5, 0.1, 0.2),\n        (0.0, 0.1, 0.4),\n        (0.0, 0.0, 0.1),\n        (2.0, 0.02, 0.05),\n    ]\n\n    # Pre-calculated modal parameter constants\n    qTq = 4.0\n    m_c = 1.0 / 9.0  # Effective mass for consistent mass matrix\n    m_l = 1.0        # Effective mass for lumped mass matrix\n\n    def calculate_spectral_radius(m, c, k, dt):\n        \"\"\"\n        Constructs the Newmark amplification matrix for state [d, v, A]\n        and returns its spectral radius.\n        \n        Args:\n            m (float): Effective mass\n            c (float): Effective damping\n            k (float): Effective stiffness\n            dt (float): Time step\n        \n        Returns:\n            float: The spectral radius of the amplification matrix.\n        \"\"\"\n        # Newmark parameters for average acceleration method\n        beta = 0.25\n        gamma = 0.5\n        \n        # Denominator in the expression for A_{n+1}\n        # D = m + c*gamma*dt + k*beta*dt**2\n        D = m + c * (gamma * dt) + k * (beta * dt**2)\n        \n        if D == 0:\n            # Avoid division by zero, though unlikely with the given problem setup.\n            # A large number will indicate instability if it happens.\n            return np.inf\n\n        # Third row of the amplification matrix A, which relates A_{n+1} to [d_n, v_n, A_n]\n        A31 = -k / D\n        A32 = -(c + k * dt) / D\n        A33 = -(c * (1 - gamma) * dt + k * (0.5 - beta) * dt**2) / D\n        \n        # With beta=1/4 and gamma=1/2:\n        # A33 = -(c * dt / 2 + k * dt**2 / 4) / D\n\n        # Construct the full 3x3 amplification matrix\n        # Using direct formula for beta=1/4, gamma=1/2\n        amp_matrix = np.array([\n            [1 + 0.25 * dt**2 * A31, dt + 0.25 * dt**2 * A32, 0.25 * dt**2 * (1 + A33)],\n            [0.5 * dt * A31, 1 + 0.5 * dt * A32, 0.5 * dt * (1 + A33)],\n            [A31, A32, A33]\n        ])\n\n        # Calculate eigenvalues and find the spectral radius (max absolute value)\n        eigenvalues = np.linalg.eigvals(amp_matrix)\n        spectral_radius = np.max(np.abs(eigenvalues))\n        \n        return spectral_radius\n\n    results = []\n    for case in test_cases:\n        k0, c0, dt = case\n        \n        # Calculate effective stiffness and damping\n        k = k0 * (qTq**2)\n        c = c0 * (qTq**2)\n        \n        # Calculate spectral radius for consistent mass\n        rho_c = calculate_spectral_radius(m_c, c, k, dt)\n        \n        # Calculate spectral radius for lumped mass\n        rho_l = calculate_spectral_radius(m_l, c, k, dt)\n        \n        # Round results to 8 decimal places\n        rho_c_rounded = round(rho_c, 8)\n        rho_l_rounded = round(rho_l, 8)\n        \n        # Check if mass lumping exacerbates oscillations\n        is_exacerbated = rho_l_rounded > rho_c_rounded\n        \n        results.append([rho_c_rounded, rho_l_rounded, is_exacerbated])\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) automatically converts each inner list to its string representation.\n    # Special handling for booleans to make them lowercase 'true'/'false'\n    def format_case(case_result):\n        rho_c_str = f\"{case_result[0]:.8f}\"\n        rho_l_str = f\"{case_result[1]:.8f}\"\n        bool_str = str(case_result[2]).lower()\n        return f\"[{rho_c_str},{rho_l_str},{bool_str}]\"\n    \n    output_str = \",\".join(map(format_case, results))\n    print(f\"[{output_str}]\")\n\n\nsolve()\n```", "id": "3602209"}]}