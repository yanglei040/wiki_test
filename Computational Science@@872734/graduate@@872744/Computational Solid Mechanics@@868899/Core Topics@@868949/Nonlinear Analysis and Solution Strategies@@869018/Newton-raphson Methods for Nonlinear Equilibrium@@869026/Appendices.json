{"hands_on_practices": [{"introduction": "Before we can solve a nonlinear problem, we must first express it in a form that our numerical methods can understand. This exercise [@problem_id:3583531] walks you through the foundational process of translating a physical problem—a one-dimensional bar with a nonlinear material response—into the discrete language of the Finite Element Method (FEM). You will derive the element-level residual vector, which represents the force imbalance at the nodes for a given displacement field, providing a concrete understanding of the very quantity the Newton-Raphson method aims to drive to zero.", "problem": "Consider a quasi-static, one-dimensional bar of length $L = 2\\,\\mathrm{m}$, uniform cross-sectional area $A = 1\\,\\mathrm{m^2}$, and a nonlinear material law $\\sigma(\\varepsilon) = E\\,\\varepsilon + \\alpha\\,\\varepsilon^{3}$, where $\\sigma$ is the Cauchy stress and $\\varepsilon$ is the small strain. The bar is subjected to a distributed load $q(x) = q_{0}\\,x$ with $q_{0} = 1.0 \\times 10^{5}\\,\\mathrm{N/m^2}$, and traction-free boundary conditions at $x=0$ and $x=L$.\n\nUsing the Finite Element Method (FEM) and the Newton-Raphson method (NR) for nonlinear equilibrium, start from the strong form of equilibrium and its weak form via the Principle of Virtual Work (PVW). Derive the element-level expression for the nodal residual vector $r^{e}(u)$ in terms of the internal and external force contributions, for a linear two-node element on an interval $[x_{i}, x_{j}]$ with standard linear shape functions. Then, on a mesh of $2$ equal linear elements spanning $[0,2]$ with nodes at $x_{0}=0$, $x_{1}=1$, and $x_{2}=2$, assemble the global residual vector $r(u)$.\n\nEvaluate the residual vector for the discrete displacement field $u_{h}(x)$ defined by nodal values $u_{0} = 0\\,\\mathrm{m}$, $u_{1} = 0.10\\,\\mathrm{m}$, and $u_{2} = 0.25\\,\\mathrm{m}$, with material parameters $E = 10^{6}\\,\\mathrm{Pa}$ and $\\alpha = 10^{7}\\,\\mathrm{Pa}$. Use exact arithmetic where possible. Express the final nodal residual vector in Newtons (N). The final answer must be a single row matrix containing the three nodal residuals. No rounding is required; provide exact values.", "solution": "The problem statement has been validated and is deemed valid. It is scientifically grounded in the principles of continuum mechanics and the Finite Element Method, is well-posed, objective, and provides all necessary data for a unique solution. The interpretation of the distributed load $q(x)$ with units of N/m$^2$ for $q_0$ is resolved by dimensional analysis: the term $q(x)=q_0 x$ represents a force per unit length, with units $(N/m^2) \\cdot m = N/m$, which is consistent for a one-dimensional bar problem.\n\nThe solution proceeds by first establishing the governing equations in their strong and weak forms, then deriving the finite element residual expressions, and finally evaluating these expressions for the specified mesh and displacement field.\n\n**1. Governing Equations**\n\nThe strong form of the equilibrium equation for a one-dimensional bar is:\n$$\n\\frac{d(N)}{dx} + f(x) = 0 \\quad \\text{for } x \\in (0, L)\n$$\nwhere $N$ is the axial force and $f(x)$ is the distributed axial load per unit length. The axial force is $N = A\\sigma$, where $A$ is the cross-sectional area and $\\sigma$ is the Cauchy stress. The distributed load is given as $q(x) = q_0 x$, so we identify $f(x) = q(x)$. With a constant area $A$, the equilibrium equation becomes:\n$$\nA\\frac{d\\sigma}{dx} + q_0 x = 0\n$$\nThe material law is nonlinear: $\\sigma(\\varepsilon) = E\\varepsilon + \\alpha\\varepsilon^3$. The strain-displacement relation is $\\varepsilon = \\frac{du}{dx}$. The problem specifies traction-free boundary conditions, which means the axial force $N$ is zero at $x=0$ and $x=L$.\n\nTo derive the weak form, we employ the Principle of Virtual Work (PVW). We multiply the equilibrium equation by a virtual displacement $\\delta u$ and integrate over the domain $[0,L]$:\n$$\n\\int_{0}^{L} \\delta u \\left( A\\frac{d\\sigma}{dx} + q(x) \\right) dx = 0\n$$\nIntegrating the first term by parts yields:\n$$\n\\left[ \\delta u (A\\sigma) \\right]_0^L - \\int_0^L (A\\sigma) \\frac{d(\\delta u)}{dx} dx + \\int_0^L \\delta u q(x) dx = 0\n$$\nThe boundary term $\\left[ \\delta u (A\\sigma) \\right]_0^L$ represents the work done by external point forces at the boundaries. Since the boundaries are traction-free, $A\\sigma(0)=0$ and $A\\sigma(L)=0$, so this term vanishes. The derivative of the virtual displacement is the virtual strain, $\\delta\\varepsilon = d(\\delta u)/dx$. The weak form is thus:\n$$\n\\int_0^L \\sigma(\\varepsilon) \\delta\\varepsilon A \\,dx - \\int_0^L q(x) \\delta u \\,dx = 0\n$$\nFor the Newton-Raphson method, we define the residual, which represents the imbalance between internal and external forces for a given displacement field $u(x)$. The residual functional $R(u, \\delta u)$ is:\n$$\nR(u, \\delta u) = \\int_0^L A\\sigma(\\varepsilon) \\delta\\varepsilon \\,dx - \\int_0^L q(x) \\delta u \\,dx\n$$\nEquilibrium is achieved when $R(u, \\delta u) = 0$ for all admissible virtual displacements $\\delta u$.\n\n**2. Finite Element Formulation**\n\nWe discretize the domain into finite elements. For a generic two-node linear element on $[x_i, x_j]$, the displacement $u(x)$ is interpolated from the nodal displacements $u_i$ and $u_j$:\n$$\nu(x) = N_i(x)u_i + N_j(x)u_j = \\boldsymbol{N}(x) \\boldsymbol{u}^e\n$$\nwhere $\\boldsymbol{u}^e = \\begin{pmatrix} u_i  u_j \\end{pmatrix}^\\mathsf{T}$ and $\\boldsymbol{N} = \\begin{pmatrix} N_i(x)  N_j(x) \\end{pmatrix}$. The linear shape functions are:\n$$\nN_i(x) = \\frac{x_j-x}{L_e}, \\quad N_j(x) = \\frac{x-x_i}{L_e}\n$$\nwith element length $L_e = x_j - x_i$. The strain $\\varepsilon$ within the element is constant:\n$$\n\\varepsilon_e = \\frac{du}{dx} = \\frac{d\\boldsymbol{N}}{dx}\\boldsymbol{u}^e = \\begin{pmatrix} -\\frac{1}{L_e}  \\frac{1}{L_e} \\end{pmatrix} \\begin{pmatrix} u_i \\\\ u_j \\end{pmatrix} = \\frac{u_j - u_i}{L_e}\n$$\nThe strain-displacement matrix is $\\boldsymbol{B} = \\frac{1}{L_e} \\begin{pmatrix} -1  1 \\end{pmatrix}$. The virtual displacement and strain are interpolated similarly: $\\delta u = \\boldsymbol{N} \\boldsymbol{\\delta u}^e$ and $\\delta\\varepsilon = \\boldsymbol{B} \\boldsymbol{\\delta u}^e$.\n\nSubstituting these into the residual functional and summing over all elements gives:\n$$\n(\\boldsymbol{\\delta u})^\\mathsf{T} \\boldsymbol{r} = \\sum_e (\\boldsymbol{\\delta u}^e)^\\mathsf{T} \\left( \\int_{x_i}^{x_j} A \\sigma(\\varepsilon_e) \\boldsymbol{B}^T dx - \\int_{x_i}^{x_j} q(x) \\boldsymbol{N}^T dx \\right)\n$$\nwhere $\\boldsymbol{r}$ is the global nodal residual vector. We can identify the element residual vector $\\boldsymbol{r}^e$:\n$$\n\\boldsymbol{r}^e = \\boldsymbol{f}_{int}^e - \\boldsymbol{f}_{ext}^e\n$$\nwhere $\\boldsymbol{f}_{int}^e$ is the element internal force vector and $\\boldsymbol{f}_{ext}^e$ is the element external force vector.\n\n**Derivation of Element Internal Force Vector $\\boldsymbol{f}_{int}^e$:**\n$$\n\\boldsymbol{f}_{int}^e = \\int_{x_i}^{x_j} A \\sigma(\\varepsilon_e) \\boldsymbol{B}^T dx = A \\sigma(\\varepsilon_e) \\boldsymbol{B}^T \\int_{x_i}^{x_j} dx = A L_e \\sigma(\\varepsilon_e) \\boldsymbol{B}^T\n$$\n$$\n\\boldsymbol{f}_{int}^e = A L_e \\left( E\\varepsilon_e + \\alpha\\varepsilon_e^3 \\right) \\frac{1}{L_e} \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} = A \\left( E\\varepsilon_e + \\alpha\\varepsilon_e^3 \\right) \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix}\n$$\n\n**Derivation of Element External Force Vector $\\boldsymbol{f}_{ext}^e$:**\n$$\n\\boldsymbol{f}_{ext}^e = \\int_{x_i}^{x_j} q(x) \\boldsymbol{N}^T dx = \\int_{x_i}^{x_j} q_0 x \\begin{pmatrix} (x_j-x)/L_e \\\\ (x-x_i)/L_e \\end{pmatrix} dx\n$$\nThe evaluation of this integral yields the standard result for a linear load on a linear element:\n$$\n\\boldsymbol{f}_{ext}^e = \\frac{q_0 L_e}{6} \\begin{pmatrix} 2x_i + x_j \\\\ x_i + 2x_j \\end{pmatrix}\n$$\n\n**3. Numerical Evaluation**\n\nThe bar is discretized into $2$ elements of equal length.\n- Total length $L=2\\,\\mathrm{m}$, so each element length is $L_e=1\\,\\mathrm{m}$.\n- Nodes are at $x_0=0$, $x_1=1$, and $x_2=2$.\n- Material parameters: $A=1\\,\\mathrm{m^2}$, $E=10^6\\,\\mathrm{Pa}$, $\\alpha=10^7\\,\\mathrm{Pa}$.\n- Load parameter: $q_0=10^5\\,\\mathrm{N/m^2}$.\n- Nodal displacements: $u_0=0\\,\\mathrm{m}$, $u_1=0.1\\,\\mathrm{m}$, $u_2=0.25\\,\\mathrm{m}$.\n\n**Element 1 (Nodes 0, 1):**\n$x_i=0$, $x_j=1$, $L_e=1$. Nodal displacements $u_0=0, u_1=0.1$.\n- Strain: $\\varepsilon^{(1)} = (u_1 - u_0)/L_e = (0.1 - 0)/1 = 0.1$.\n- Stress: $\\sigma^{(1)} = E\\varepsilon^{(1)} + \\alpha(\\varepsilon^{(1)})^3 = 10^6(0.1) + 10^7(0.1)^3 = 10^5 + 10^4 = 1.1 \\times 10^5\\,\\mathrm{Pa}$.\n- Internal force vector: $\\boldsymbol{f}_{int}^{(1)} = A\\sigma^{(1)}\\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} = 1 \\cdot (1.1 \\times 10^5) \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} -110000 \\\\ 110000 \\end{pmatrix}\\,\\mathrm{N}$.\n- External force vector: $\\boldsymbol{f}_{ext}^{(1)} = \\frac{10^5 \\cdot 1}{6}\\begin{pmatrix} 2(0)+1 \\\\ 0+2(1) \\end{pmatrix} = \\frac{10^5}{6}\\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 50000/3 \\\\ 100000/3 \\end{pmatrix}\\,\\mathrm{N}$.\n- Residual vector: $\\boldsymbol{r}^{(1)} = \\boldsymbol{f}_{int}^{(1)} - \\boldsymbol{f}_{ext}^{(1)} = \\begin{pmatrix} -110000 - 50000/3 \\\\ 110000 - 100000/3 \\end{pmatrix} = \\begin{pmatrix} -380000/3 \\\\ 230000/3 \\end{pmatrix}\\,\\mathrm{N}$.\n\n**Element 2 (Nodes 1, 2):**\n$x_i=1$, $x_j=2$, $L_e=1$. Nodal displacements $u_1=0.1, u_2=0.25$.\n- Strain: $\\varepsilon^{(2)} = (u_2 - u_1)/L_e = (0.25 - 0.1)/1 = 0.15$.\n- Stress: $\\sigma^{(2)} = E\\varepsilon^{(2)} + \\alpha(\\varepsilon^{(2)})^3 = 10^6(0.15) + 10^7(0.15)^3 = 150000 + 10^7(0.003375) = 150000 + 33750 = 183750\\,\\mathrm{Pa}$.\n- Internal force vector: $\\boldsymbol{f}_{int}^{(2)} = A\\sigma^{(2)}\\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} = 1 \\cdot 183750 \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} -183750 \\\\ 183750 \\end{pmatrix}\\,\\mathrm{N}$.\n- External force vector: $\\boldsymbol{f}_{ext}^{(2)} = \\frac{10^5 \\cdot 1}{6}\\begin{pmatrix} 2(1)+2 \\\\ 1+2(2) \\end{pmatrix} = \\frac{10^5}{6}\\begin{pmatrix} 4 \\\\ 5 \\end{pmatrix} = \\begin{pmatrix} 200000/3 \\\\ 250000/3 \\end{pmatrix}\\,\\mathrm{N}$.\n- Residual vector: $\\boldsymbol{r}^{(2)} = \\boldsymbol{f}_{int}^{(2)} - \\boldsymbol{f}_{ext}^{(2)} = \\begin{pmatrix} -183750 - 200000/3 \\\\ 183750 - 250000/3 \\end{pmatrix} = \\begin{pmatrix} (-551250-200000)/3 \\\\ (551250-250000)/3 \\end{pmatrix} = \\begin{pmatrix} -751250/3 \\\\ 301250/3 \\end{pmatrix}\\,\\mathrm{N}$.\n\n**Assembly of Global Residual Vector $\\boldsymbol{r}$**\nThe global residual vector $\\boldsymbol{r} = \\begin{pmatrix} r_0  r_1  r_2 \\end{pmatrix}^\\mathsf{T}$ is assembled from the element contributions:\n$$\nr_0 = r^{(1)}_0 = -\\frac{380000}{3}\n$$\n$$\nr_1 = r^{(1)}_1 + r^{(2)}_0 = \\frac{230000}{3} - \\frac{751250}{3} = \\frac{230000 - 751250}{3} = \\frac{-521250}{3} = -173750\n$$\n$$\nr_2 = r^{(2)}_1 = \\frac{301250}{3}\n$$\nThe final global residual vector, with components expressed in Newtons, is:\n$$\n\\boldsymbol{r} = \\begin{pmatrix} -380000/3 \\\\ -173750 \\\\ 301250/3 \\end{pmatrix}\n$$", "answer": "$$\n\\boxed{\\begin{pmatrix} -\\frac{380000}{3}  -173750  \\frac{301250}{3} \\end{pmatrix}}\n$$", "id": "3583531"}, {"introduction": "With the ability to formulate the residual and its derivative, the tangent stiffness, we can now build the iterative engine to find the equilibrium solution. This hands-on coding practice [@problem_id:3583538] guides you through implementing and comparing two workhorse algorithms: the full Newton-Raphson method and the modified Newton-Raphson method. By analyzing their performance on a simple nonlinear problem, you will gain direct insight into the classic trade-off between the rapid, quadratic convergence of the full Newton method and the reduced computational cost per iteration of the modified Newton method.", "problem": "Implement a complete, runnable program that compares two Newton-Raphson strategies for solving a nonlinear equilibrium problem arising from a one-dimensional finite element discretization. The physical model is a single bar with one end fixed and one end subjected to a monotonically increasing axial load. The bar has uniform cross-sectional area and is discretized as a single linear two-node element, so the axial strain is uniform under the applied end displacement. The internal axial stress follows a nonlinear constitutive law. The goal is to formulate the equilibrium residual, derive the tangent needed for Newton iterations, and then implement and compare the full Newton method and the modified Newton method (freezing the tangent stiffness over multiple iterations). You must compute iteration counts and observed convergence rates and produce them in a single aggregated output line.\n\nFoundational base:\n- Global equilibrium in the Finite Element Method (FEM): the discrete equilibrium condition is $r(u) = 0$, where $r(u)$ is the residual force vector (here scalar), $u$ is the discrete nodal displacement, $r(u) = f_{\\text{ext}} - f_{\\text{int}}(u)$, and $f_{\\text{ext}}$ is the external nodal force vector (here scalar).\n- Kinematics: for a single uniform bar element of length $L$ with linear shape functions and one free end displacement $u$, the axial strain is $\\varepsilon = u / L$.\n- Nonlinear constitutive law: axial stress is given by $\\sigma(\\varepsilon) = E \\varepsilon + \\beta \\varepsilon^3$, where $E  0$ is the Young’s modulus and $\\beta \\ge 0$ controls the cubic nonlinearity; assume nondimensionalized units so all quantities are dimensionless in this problem statement.\n- Internal force: for a uniform bar with cross-sectional area $A$ and constant strain, the internal force at the free node reduces to $f_{\\text{int}}(u) = A \\sigma(\\varepsilon)$.\n\nDefine the equilibrium residual for a given end load $P$ and nodal displacement $u$ as $r(u) = P - f_{\\text{int}}(u) = P - A \\left( E \\frac{u}{L} + \\beta \\left(\\frac{u}{L}\\right)^3 \\right)$. The consistent tangent, required by Newton-Raphson (NR), is $K_{\\text{T}}(u) = \\frac{dr}{du}$. The full Newton method at iteration $k$ uses the current $K_{\\text{T}}(u_k)$, while the modified Newton method freezes $K_{\\text{T}}$ at the start of each load increment and reuses it for all iterations within that increment.\n\nProgramming tasks:\n1. Starting from the equilibrium residual definition $r(u) = P - f_{\\text{int}}(u)$ and the constitutive law $\\sigma(\\varepsilon) = E \\varepsilon + \\beta \\varepsilon^3$, derive $r(u)$ and $K_{\\text{T}}(u)$ explicitly in terms of $u$, $E$, $\\beta$, $A$, $L$, and $P$.\n2. Implement two nonlinear solvers over a sequence of load increments:\n   - Full Newton method: update $K_{\\text{T}}(u_k)$ at every iteration within a load increment.\n   - Modified Newton method: freeze $K_{\\text{T}}$ at the start of each load increment (use the tangent evaluated at the first iterate of the increment, i.e., at the previous increment’s converged displacement).\n   Each load increment increases $P$ by $\\Delta P = P_{\\text{total}}/N_{\\text{inc}}$ and seeks a converged $u$ such that $|r(u)| \\le \\text{tol}$.\n3. Use the previous increment’s converged displacement as the initial guess for the next increment. For each increment, record the sequence of residual norms $\\|r(u_k)\\|$ until convergence.\n4. For the modified Newton method, compute the observed linear convergence factor averaged over all iterations and increments where at least two iterations occur: $\\lambda_k = \\frac{\\|r_{k+1}\\|}{\\|r_k\\|}$, and report the arithmetic mean over all such $\\lambda_k$. For the full Newton method, compute the observed quadratic factor averaged similarly: $q_k = \\frac{\\|r_{k+1}\\|}{\\|r_k\\|^2}$, reporting the arithmetic mean of all $q_k$ where at least two iterations occur.\n5. For each test case, compute the total number of iterations accumulated over all increments for the full Newton method and for the modified Newton method. Convergence tolerances apply to the residual norm $\\|r\\|$, which in this scalar case is $|r|$.\n\nTest suite:\nUse nondimensional parameters $A = 1$, $L = 1$, $E = 1$ for all test cases. Use maximum iterations per increment $\\text{max\\_iter} = 50$ and residual tolerance $\\text{tol} = 10^{-10}$. The test suite consists of four cases:\n- Case $1$: $\\beta = 0.1$, $P_{\\text{total}} = 0.5$, $N_{\\text{inc}} = 5$.\n- Case $2$: $\\beta = 1.0$, $P_{\\text{total}} = 0.8$, $N_{\\text{inc}} = 8$.\n- Case $3$: $\\beta = 5.0$, $P_{\\text{total}} = 0.8$, $N_{\\text{inc}} = 8$.\n- Case $4$ (near-linear boundary): $\\beta = 0.0$, $P_{\\text{total}} = 0.5$, $N_{\\text{inc}} = 5$.\n\nOutput specification:\n- For each test case, produce a list `[N_full, N_mod, R_full, R_mod]` where `N_full` is the total number of iterations for the full Newton method, `N_mod` is the total number of iterations for the modified Newton method, `R_full` is the averaged quadratic factor for the full Newton method, and `R_mod` is the averaged linear convergence factor for the modified Newton method. All four values must be numeric; in cases with fewer than two iterations across all increments (for the factor definition), report $0.0$ for the corresponding rate.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with one sub-list per test case in order: case $1$, case $2$, case $3$, case $4$. For example, the exact format must be like `[[N_full,N_mod,R_full,R_mod],...]`. As all outputs are counts or ratios, no physical units are required in the output.\n\nScientific realism constraints:\n- The problem is nondimensionalized, so all parameters are dimensionless, ensuring unit consistency.\n- The constitutive nonlinearity $\\beta \\ge 0$ guarantees a positive tangent modulus $E_{\\text{t}} = E + 3 \\beta \\varepsilon^2$, thereby avoiding loss of ellipticity and ensuring robust convergence for the chosen loads.\n- Use deterministic algorithms with no randomization, fixed tolerance $\\text{tol} = 10^{-10}$, and maximum iteration cap $\\text{max\\_iter} = 50$ to ensure reproducibility.\n\nYour implementation must be a complete, runnable program. Do not read any input or write any output other than the required single line. The implementation language must be Python with the constraints specified later. The results must be computed numerically by the program using the algorithms derived from first principles above.", "solution": "We start from the discrete equilibrium in the Finite Element Method (FEM): $r(u) = f_{\\text{ext}} - f_{\\text{int}}(u)$. For a one-dimensional bar of length $L$ and cross-sectional area $A$ with uniform strain, the axial strain is $\\varepsilon = u/L$. The constitutive law is $\\sigma(\\varepsilon) = E \\varepsilon + \\beta \\varepsilon^3$ with $E > 0$ and $\\beta \\ge 0$. The internal nodal axial force at the free end equals the cross-sectional area times the axial stress, $f_{\\text{int}}(u) = A \\sigma(\\varepsilon) = A \\left( E \\frac{u}{L} + \\beta \\left(\\frac{u}{L}\\right)^3 \\right)$. The external nodal force is $f_{\\text{ext}} = P$. Consequently, the scalar residual is\n$$\nr(u) = P - A\\left(E \\frac{u}{L} + \\beta \\left(\\frac{u}{L}\\right)^3 \\right).\n$$\nThe consistent tangent needed by Newton-Raphson (NR) is the derivative of $r(u)$ with respect to $u$:\n$$\nK_{\\text{T}}(u) = \\frac{dr}{du} = -A\\left(\\frac{E}{L} + 3\\beta \\frac{u^2}{L^3}\\right).\n$$\nThe negative sign is not problematic because the NR update solves $K_{\\text{T}}(u_k) \\Delta u_k = -r(u_k)$ and updates $u_{k+1} = u_k + \\Delta u_k$. Since $K_{\\text{T}}(u)$ is strictly negative for all $u$ when $E > 0$ and $\\beta \\ge 0$ with $A>0$, $L>0$, the iteration is well-posed; it leads to positive $\\Delta u_k$ when $r(u_k) > 0$ under monotonic loading.\n\nWe consider two algorithms:\n- Full Newton: At iteration $k$ within a given load increment, assemble $K_{\\text{T}}(u_k)$ from the current iterate. Solve $K_{\\text{T}}(u_k)\\Delta u_k = -r(u_k)$ and update $u_{k+1} = u_{k} + \\Delta u_k$. Repeat until $|r(u_{k+1})| \\le \\text{tol}$ or $k$ reaches $\\text{max\\_iter}$.\n- Modified Newton: At the start of each load increment, freeze $K_{\\text{T}}$ by evaluating it at the previous increment’s converged displacement $u^{(i-1)}$, which serves as the initial guess $u_0^{(i)}$. Then iterate with this fixed $K_{\\text{T}}$ for all Newton updates in the increment until convergence or $\\text{max\\_iter}$.\n\nLoading and initialization:\nWe adopt a load increment scheme with $N_{\\text{inc}}$ uniform steps. The total load is $P_{\\text{total}}$, and each increment increases the load by $\\Delta P = P_{\\text{total}} / N_{\\text{inc}}$. At increment $i$ ($i = 1, \\ldots, N_{\\text{inc}}$), the target load is $P_i = i \\Delta P$. The initial guess for $u$ at increment $i$ is the converged displacement from increment $i-1$, with $u^{(0)} = 0$ for the first increment. For each increment and each method, we record the residual norms $|r(u_k)|$ at each NR iteration $k$.\n\nConvergence rate measures:\n- For the modified Newton method with a frozen tangent within an increment, the expected local behavior near the solution is linear: $|r_{k+1}| \\approx \\lambda |r_k|$ where $0  \\lambda  1$ in the convergent regime. We estimate the linear factor at each step as $\\lambda_k = \\frac{|r_{k+1}|}{|r_k|}$ and compute the arithmetic average over all increments and all iteration indices $k$ where at least two residuals exist (i.e., $k$ ranges from $0$ to $n-2$ if $n$ residuals were recorded in that increment).\n- For the full Newton method with a consistent tangent, the local behavior near the solution is quadratic: $|r_{k+1}| \\approx q |r_k|^2$ for small $|r_k|$. We estimate the quadratic factor at each step as $q_k = \\frac{|r_{k+1}|}{|r_k|^2}$ and compute the arithmetic average over all increments and eligible iteration indices. In increments converging in fewer than two iterations, the factor cannot be estimated; those increments are excluded from the averages. If no eligible steps exist across all increments in a test case, we return $0.0$ for the corresponding averaged rate.\n\nTest cases and expectations:\nWe use nondimensional parameters $A = 1$, $L = 1$, $E = 1$, which implies $f_{\\text{int}}(u) = E u + \\beta u^3$ and $K_{\\text{T}}(u) = -\\left(E + 3\\beta u^2\\right)$ for this choice. We set $\\text{tol} = 10^{-10}$ and $\\text{max\\_iter} = 50$. Four cases are simulated:\n- Case $1$: $\\beta = 0.1$, $P_{\\text{total}} = 0.5$, $N_{\\text{inc}} = 5$. Expect moderate nonlinearity; full Newton should exhibit near-quadratic convergence with small averaged $q$, while modified Newton should show linear convergence with a factor $\\lambda$ bounded away from zero.\n- Case $2$: $\\beta = 1.0$, $P_{\\text{total}} = 0.8$, $N_{\\text{inc}} = 8$. Increased nonlinearity; full Newton remains efficient; modified Newton may require more iterations with a larger $\\lambda$.\n- Case $3$: $\\beta = 5.0$, $P_{\\text{total}} = 0.8$, $N_{\\text{inc}} = 8$. Strong nonlinearity; the tangent grows significantly with $u$. Full Newton should still converge robustly with near-quadratic behavior; modified Newton may have slower rates and higher iteration counts because the frozen tangent is less representative away from the initial guess.\n- Case $4$: $\\beta = 0.0$, $P_{\\text{total}} = 0.5$, $N_{\\text{inc}} = 5$. Purely linear; both methods reduce to solving a linear equation. From an arbitrary initial guess per increment (previous converged value), Newton converges in a single iteration per increment. The averaged rates cannot be meaningfully computed because there is at most one iteration per increment; thus the rate outputs should be $0.0$ for both methods in this case.\n\nOutput format:\nFor each test case, return the list `[N_full, N_mod, R_full, R_mod]` and aggregate all four cases into a single top-level list, printed as one line, e.g., `[[N_full,N_mod,R_full,R_mod], [...], [...], [...]]`. The values are integers for `N_full`, `N_mod` and floating-point for `R_full`, `R_mod`. Because these are counts and nondimensional ratios, no physical units are required in the output.\n\nAlgorithmic robustness:\nWe set a strict residual tolerance $\\text{tol} = 10^{-10}$ to capture asymptotic behavior in the rate estimates. The positive tangent modulus $E_{\\text{t}} = E + 3 \\beta \\varepsilon^2$ ensures unique solutions for the specified loads. The maximum iteration cap $\\text{max\\_iter} = 50$ guards against pathological cases. The load stepping strategy maintains monotonic increase in $P$, and the choice of initial guesses promotes rapid convergence.\n\nThe program implements these steps exactly and prints the required single-line output in the specified format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef residual(u, P, E, beta, A, L):\n    # r(u) = P - A*(E*u/L + beta*(u/L)^3)\n    return P - A * (E * (u / L) + beta * (u / L) ** 3)\n\ndef tangent(u, E, beta, A, L):\n    # K_T(u) = dr/du = -A*(E/L + 3*beta*u^2/L^3)\n    return -A * (E / L + 3.0 * beta * (u ** 2) / (L ** 3))\n\ndef newton_solve(P_total, N_inc, E, beta, A, L, tol=1e-10, max_iter=50, mode=\"full\"):\n    \"\"\"\n    Solve the nonlinear equilibrium over load increments using either full Newton or modified Newton.\n    Returns:\n        total_iterations: int\n        avg_rate: float (quadratic factor for 'full', linear factor for 'modified')\n    \"\"\"\n    u = 0.0  # initial displacement for first increment\n    deltaP = P_total / N_inc\n    total_iterations = 0\n    rate_values = []  # stores lambda_k for 'modified' or q_k for 'full'\n\n    for i in range(1, N_inc + 1):\n        P_i = i * deltaP\n        # Initial guess is previous increment's converged displacement\n        u_i = u\n        residuals = []\n\n        # Freeze tangent for modified Newton at start of increment\n        if mode == \"modified\":\n            K_freeze = tangent(u_i, E, beta, A, L)\n\n        for k in range(max_iter):\n            r_k = residual(u_i, P_i, E, beta, A, L)\n            residuals.append(abs(r_k))\n            if abs(r_k) = tol:\n                # Converged at iteration k\n                total_iterations += k  # we count completed iterations before reaching tolerance\n                break\n            # Choose tangent according to method\n            if mode == \"full\":\n                K_t = tangent(u_i, E, beta, A, L)\n            else:\n                K_t = K_freeze\n\n            # Guard against zero tangent (should not occur with chosen parameters)\n            if K_t == 0.0:\n                # Fail-safe: break to avoid division by zero\n                total_iterations += k + 1\n                break\n\n            # Newton update: K_t * delta = -r_k  = delta = -r_k / K_t\n            delta = -r_k / K_t\n            u_i = u_i + delta\n\n            # If we reached the last allowed iteration without satisfying tol, count it\n            if k == max_iter - 1:\n                total_iterations += max_iter\n\n        # Post-processing for rate estimates within this increment\n        # We use the recorded residuals sequence residuals[0..n-1] to compute step-wise rates\n        n_res = len(residuals)\n        if n_res = 2:\n            for idx in range(n_res - 1):\n                r_k = residuals[idx]\n                r_k1 = residuals[idx + 1]\n                if mode == \"modified\":\n                    # Linear factor lambda = r_{k+1} / r_k\n                    if r_k  0.0:\n                        rate_values.append(r_k1 / r_k)\n                else:\n                    # Quadratic factor q = r_{k+1} / r_k^2\n                    if r_k  0.0:\n                        rate_values.append(r_k1 / (r_k ** 2))\n\n        # Update global u for next increment initial guess\n        u = u_i\n\n    # Average the collected rates; if none, return 0.0\n    if len(rate_values)  0:\n        avg_rate = float(np.mean(rate_values))\n    else:\n        avg_rate = 0.0\n\n    return total_iterations, avg_rate\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Using nondimensional parameters: A=1, L=1, E=1 for all cases.\n    test_cases = [\n        # (beta, P_total, N_inc, E, A, L)\n        (0.1, 0.5, 5, 1.0, 1.0, 1.0),  # Case 1\n        (1.0, 0.8, 8, 1.0, 1.0, 1.0),  # Case 2\n        (5.0, 0.8, 8, 1.0, 1.0, 1.0),  # Case 3\n        (0.0, 0.5, 5, 1.0, 1.0, 1.0),  # Case 4 (linear)\n    ]\n\n    results = []\n    for case in test_cases:\n        beta, P_total, N_inc, E, A, L = case\n\n        # Full Newton\n        N_full, R_full = newton_solve(\n            P_total=P_total, N_inc=N_inc, E=E, beta=beta, A=A, L=L,\n            tol=1e-10, max_iter=50, mode=\"full\"\n        )\n        # Modified Newton (freeze tangent per increment)\n        N_mod, R_mod = newton_solve(\n            P_total=P_total, N_inc=N_inc, E=E, beta=beta, A=A, L=L,\n            tol=1e-10, max_iter=50, mode=\"modified\"\n        )\n\n        results.append([N_full, N_mod, R_full, R_mod])\n\n    # Final print statement in the exact required format.\n    # Single line: list of sublists per test case.\n    print(str(results))\n\nsolve()\n```", "id": "3583538"}, {"introduction": "Standard Newton-Raphson methods, which control the applied load, can fail when the structure's response includes limit points, such as snap-through or snap-back behavior. This advanced practice [@problem_id:3583526] introduces a powerful solution: the arc-length continuation method, which traces the equilibrium path by controlling the \"distance\" traveled in the combined load-displacement space. By implementing an extended system that solves for both displacement and the load parameter simultaneously, you will learn how to navigate complex equilibrium paths and analyze post-critical phenomena.", "problem": "Implement an extended system Newton-Raphson method to solve a constrained nonlinear equilibrium defined by an augmented system with an arc-length constraint. Consider a two-degree-of-freedom unknown vector $\\mathbf{u} \\in \\mathbb{R}^2$ and a scalar load parameter $\\lambda \\in \\mathbb{R}$. Let the potential energy be\n$$\n\\Pi(\\mathbf{u},\\lambda) = \\frac{1}{4}\\left(\\mathbf{u}^\\mathsf{T}\\mathbf{u} - \\lambda\\right)^2,\n$$\nand the equilibrium equations be given by the stationarity condition of $\\Pi$, that is\n$$\n\\mathbf{R}(\\mathbf{u},\\lambda) = \\nabla_{\\mathbf{u}} \\Pi(\\mathbf{u},\\lambda) = \\left(\\mathbf{u}^\\mathsf{T}\\mathbf{u} - \\lambda\\right)\\mathbf{u} = \\mathbf{0}.\n$$\nThe associated tangent stiffness (Jacobian with respect to $\\mathbf{u}$) and the derivative with respect to $\\lambda$ are\n$$\n\\mathbf{K}(\\mathbf{u},\\lambda) = \\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{u}} = \\left(\\mathbf{u}^\\mathsf{T}\\mathbf{u} - \\lambda\\right)\\mathbf{I} + 2\\mathbf{u}\\mathbf{u}^\\mathsf{T}, \\qquad \\mathbf{q}(\\mathbf{u}) = \\frac{\\partial \\mathbf{R}}{\\partial \\lambda} = -\\mathbf{u}.\n$$\nTo follow solution paths, augment $\\mathbf{R}(\\mathbf{u},\\lambda) = \\mathbf{0}$ with an arc-length constraint $g(\\mathbf{u},\\lambda) = 0$ defined over increments $\\Delta \\mathbf{u} = \\mathbf{u} - \\mathbf{u}_k$ and $\\Delta \\lambda = \\lambda - \\lambda_k$ relative to the last converged equilibrium $(\\mathbf{u}_k, \\lambda_k)$. Implement and compare two choices for $g$:\n- Displacement-norm arc-length:\n$$\ng_{\\text{disp}}(\\mathbf{u},\\lambda) = \\Delta \\mathbf{u}^\\mathsf{T}\\Delta \\mathbf{u} + \\psi\\,\\Delta \\lambda^2 - \\Delta s^2.\n$$\n- Energy-norm arc-length with regularization:\n$$\ng_{\\text{energy}}(\\mathbf{u},\\lambda) = \\Delta \\mathbf{u}^\\mathsf{T}\\left(\\mathbf{K}(\\mathbf{u}_k,\\lambda_k) + \\epsilon\\,\\mathbf{I}\\right)\\Delta \\mathbf{u} + \\psi\\,\\Delta \\lambda^2 - \\Delta s^2,\n$$\nwhere $\\psi > 0$ is a scaling factor balancing the load and displacement components, $\\Delta s > 0$ is the prescribed arc-length, and $\\epsilon > 0$ is a small regularization to avoid degeneracy at bifurcation.\n\nAt each continuation step, solve the extended system\n$$\n\\begin{bmatrix}\n\\mathbf{R}(\\mathbf{u},\\lambda) \\\\\ng(\\mathbf{u},\\lambda)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{0} \\\\\n0\n\\end{bmatrix}\n$$\nusing Newton-Raphson on the extended system. Linearize about the current iterate $(\\mathbf{u}^{(i)},\\lambda^{(i)})$ to update by $(\\delta \\mathbf{u}, \\delta \\lambda)$, where the Jacobian of the extended system is\n$$\n\\mathbf{J}_{\\text{ext}} =\n\\begin{bmatrix}\n\\mathbf{K}(\\mathbf{u}^{(i)},\\lambda^{(i)})  \\mathbf{q}(\\mathbf{u}^{(i)}) \\\\\n\\frac{\\partial g}{\\partial \\mathbf{u}}(\\mathbf{u}^{(i)},\\lambda^{(i)})^\\mathsf{T}  \\frac{\\partial g}{\\partial \\lambda}(\\mathbf{u}^{(i)},\\lambda^{(i)})\n\\end{bmatrix},\n$$\nwith\n$$\n\\frac{\\partial g_{\\text{disp}}}{\\partial \\mathbf{u}} = 2\\Delta \\mathbf{u}, \\quad \\frac{\\partial g_{\\text{disp}}}{\\partial \\lambda} = 2\\psi\\,\\Delta \\lambda,\n$$\nand\n$$\n\\frac{\\partial g_{\\text{energy}}}{\\partial \\mathbf{u}} = 2\\left(\\mathbf{K}(\\mathbf{u}_k,\\lambda_k)+\\epsilon\\,\\mathbf{I}\\right)\\Delta \\mathbf{u}, \\quad \\frac{\\partial g_{\\text{energy}}}{\\partial \\lambda} = 2\\psi\\,\\Delta \\lambda.\n$$\nUse a predictor based on the linearized compatibility condition\n$$\n\\mathbf{K}(\\mathbf{u}_k,\\lambda_k)\\,\\mathbf{d}_u + \\mathbf{q}(\\mathbf{u}_k)\\,d_\\lambda = \\mathbf{0},\n$$\nparameterized by\n$$\n\\mathbf{d}_u = \\alpha\\,\\mathbf{u}_k + \\beta\\,\\mathbf{t}_k, \\quad d_\\lambda = 2\\alpha\\,\\mathbf{u}_k^\\mathsf{T}\\mathbf{u}_k,\n$$\nwhere $\\mathbf{t}_k$ is any unit tangent vector orthogonal to $\\mathbf{u}_k$. Choose $\\alpha$ to satisfy the chosen arc-length normalization $g(\\mathbf{u}_k+\\mathbf{d}_u,\\lambda_k+d_\\lambda)=0$ for the given $\\beta$ and sign convention $d_\\lambda0$. Then correct iteratively using Newton-Raphson with the extended Jacobian until the residual norm and constraint violation are below tolerance.\n\nYour program must implement both $g_{\\text{disp}}$ and $g_{\\text{energy}}$ and perform continuation over multiple steps. Use the following test suite, which is designed to probe different behaviors including branching effects due to symmetry, metric influence, and near-singular conditions:\n- Test case $1$ (displacement-norm, symmetry-breaking predictor): $(\\mathbf{u}_0,\\lambda_0) = ([0.5,\\,0.0],\\,0.25)$, arc-length $\\Delta s = 0.05$, scaling $\\psi = 0.5$, regularization $\\epsilon$ ignored, tangent bias $\\beta = 0.02$, number of steps $N = 8$, tolerance for convergence $\\mathrm{tol} = 10^{-10}$ and maximum Newton iterations per step $50$. Report the final orientation angle $\\theta = \\mathrm{atan2}(u_2,u_1)$ in radians.\n- Test case $2$ (energy-norm, same predictor and step size): $(\\mathbf{u}_0,\\lambda_0) = ([0.5,\\,0.0],\\,0.25)$, arc-length $\\Delta s = 0.05$, scaling $\\psi = 0.5$, regularization $\\epsilon = 10^{-4}$, tangent bias $\\beta = 0.02$, number of steps $N = 8$, tolerance $\\mathrm{tol} = 10^{-10}$, maximum Newton iterations per step $50$. Report the final $\\theta$ in radians.\n- Test case $3$ (energy-norm, near-bifurcation robustness): $(\\mathbf{u}_0,\\lambda_0) = ([0.2,\\,0.0],\\,0.04)$, arc-length $\\Delta s = 0.02$, scaling $\\psi = 0.5$, regularization $\\epsilon = 10^{-4}$, tangent bias $\\beta = 0$, number of steps $N = 5$, tolerance $\\mathrm{tol} = 10^{-12}$, maximum Newton iterations per step $80$. Report $1$ if all steps converge to the specified tolerance and $0$ otherwise.\n\nAngle unit specification: express all angles in radians. The final output of your program must be a single line containing a comma-separated list enclosed in square brackets with the results for test cases $1$, $2$, and $3$ in order, namely $[\\theta_{\\text{disp}},\\theta_{\\text{energy}},\\mathrm{conv3}]$. Each $\\theta$ must be represented as a floating-point number, and $\\mathrm{conv3}$ must be an integer $0$ or $1$.", "solution": "The user has provided a scientifically sound and well-posed problem in computational solid mechanics. The task is to implement and apply an arc-length continuation method to trace the equilibrium path of a nonlinear two-degree-of-freedom system. The problem is valid as it is self-contained, based on established principles of nonlinear finite element analysis, and free from any factual or logical inconsistencies.\n\nThe solution proceeds by first detailing the theoretical framework of the extended system arc-length method, and then implementing this framework in a Python program to solve the specific test cases provided.\n\n### Principle-Based Design of the Solution Method\n\nThe core of the problem lies in solving a system of nonlinear algebraic equations that represent mechanical equilibrium. Such systems are often parameterized by a load factor, $\\lambda$.\n\n**1. Nonlinear Equilibrium and Tangent Stiffness**\n\nThe equilibrium state of the system is defined by the stationarity of the potential energy $\\Pi(\\mathbf{u}, \\lambda)$, which leads to the residual equations $\\mathbf{R}(\\mathbf{u}, \\lambda) = \\mathbf{0}$. For the given potential $\\Pi(\\mathbf{u},\\lambda) = \\frac{1}{4}\\left(\\mathbf{u}^\\mathsf{T}\\mathbf{u} - \\lambda\\right)^2$, the residual is:\n$$\n\\mathbf{R}(\\mathbf{u},\\lambda) = \\nabla_{\\mathbf{u}} \\Pi = \\left(\\mathbf{u}^\\mathsf{T}\\mathbf{u} - \\lambda\\right)\\mathbf{u} = \\mathbf{0}\n$$\nThese equations are nonlinear in the unknown displacement vector $\\mathbf{u}$. We solve them using the Newton-Raphson method, which requires the linearization of $\\mathbf{R}$ around a configuration $(\\mathbf{u}^{(i)}, \\lambda^{(i)})$. This linearization involves the tangent stiffness matrix $\\mathbf{K}$ (the Jacobian of $\\mathbf{R}$ with respect to $\\mathbf{u}$) and the derivative with respect to the load parameter, $\\mathbf{q}$:\n$$\n\\mathbf{K}(\\mathbf{u},\\lambda) = \\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{u}} = \\left(\\mathbf{u}^\\mathsf{T}\\mathbf{u} - \\lambda\\right)\\mathbf{I} + 2\\mathbf{u}\\mathbf{u}^\\mathsf{T}\n$$\n$$\n\\mathbf{q}(\\mathbf{u}) = \\frac{\\partial \\mathbf{R}}{\\partial \\lambda} = -\\mathbf{u}\n$$\n\n**2. Path-Following and Arc-Length Constraint**\n\nStandard Newton-Raphson methods fail at limit points (like turning points in the load-deflection curve) or bifurcation points, where the tangent stiffness matrix $\\mathbf{K}$ becomes singular. To overcome this, the arc-length continuation method is employed. It treats the load parameter $\\lambda$ as an additional unknown and introduces a constraint equation $g(\\mathbf{u}, \\lambda) = 0$ that controls the progression along the solution path in the state space $(\\mathbf{u}, \\lambda)$. This transforms the problem into solving an augmented system of $n+1$ equations for $n+1$ unknowns ($\\mathbf{u}$ and $\\lambda$):\n$$\n\\begin{bmatrix}\n\\mathbf{R}(\\mathbf{u},\\lambda) \\\\\ng(\\mathbf{u},\\lambda)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{0} \\\\\n0\n\\end{bmatrix}\n$$\nThe arc-length constraint $g(\\mathbf{u}, \\lambda) = 0$ defines a surface (e.g., a hypersphere) of radius $\\Delta s$ around the previously converged equilibrium point $(\\mathbf{u}_k, \\lambda_k)$, and the next solution is found at the intersection of this surface and the equilibrium path. The problem specifies two forms for this constraint, based on increments $\\Delta \\mathbf{u} = \\mathbf{u} - \\mathbf{u}_k$ and $\\Delta \\lambda = \\lambda - \\lambda_k$:\n- **Displacement-norm:** $g_{\\text{disp}}(\\mathbf{u},\\lambda) = \\Delta \\mathbf{u}^\\mathsf{T}\\Delta \\mathbf{u} + \\psi\\,\\Delta \\lambda^2 - \\Delta s^2 = 0$. This defines a cylindrical or ellipsoidal constraint surface, with $\\psi$ scaling the contribution of the load parameter.\n- **Energy-norm:** $g_{\\text{energy}}(\\mathbf{u},\\lambda) = \\Delta \\mathbf{u}^\\mathsf{T}\\left(\\mathbf{K}_k + \\epsilon\\,\\mathbf{I}\\right)\\Delta \\mathbf{u} + \\psi\\,\\Delta \\lambda^2 - \\Delta s^2 = 0$, where $\\mathbf{K}_k = \\mathbf{K}(\\mathbf{u}_k, \\lambda_k)$. This metric is motivated by the work done by the incremental forces. The regularization term $\\epsilon\\mathbf{I}$ ensures the matrix $\\mathbf{K}_k + \\epsilon\\mathbf{I}$ is positive definite, even if $\\mathbf{K}_k$ is singular, which improves robustness near critical points.\n\n**3. Newton-Raphson for the Extended System**\n\nThe augmented system is solved iteratively. Given an iterate $(\\mathbf{u}^{(i)}, \\lambda^{(i)})$, the correction $(\\delta \\mathbf{u}, \\delta \\lambda)$ is found by solving the linearized system:\n$$\n\\mathbf{J}_{\\text{ext}}^{(i)}\n\\begin{Bmatrix}\n\\delta \\mathbf{u} \\\\\n\\delta \\lambda\n\\end{Bmatrix}\n=\n-\n\\begin{Bmatrix}\n\\mathbf{R}(\\mathbf{u}^{(i)},\\lambda^{(i)}) \\\\\ng(\\mathbf{u}^{(i)},\\lambda^{(i)})\n\\end{Bmatrix}\n$$\nThe extended Jacobian matrix $\\mathbf{J}_{\\text{ext}}$ is:\n$$\n\\mathbf{J}_{\\text{ext}} =\n\\begin{bmatrix}\n\\mathbf{K}(\\mathbf{u}^{(i)},\\lambda^{(i)})  \\mathbf{q}(\\mathbf{u}^{(i)}) \\\\\n\\frac{\\partial g}{\\partial \\mathbf{u}}(\\mathbf{u}^{(i)},\\lambda^{(i)})^\\mathsf{T}  \\frac{\\partial g}{\\partial \\lambda}(\\mathbf{u}^{(i)},\\lambda^{(i)})\n\\end{bmatrix}\n$$\nThe required derivatives of the constraint functions are:\n- For $g_{\\text{disp}}$: $\\frac{\\partial g_{\\text{disp}}}{\\partial \\mathbf{u}} = 2\\Delta \\mathbf{u}$ and $\\frac{\\partial g_{\\text{disp}}}{\\partial \\lambda} = 2\\psi\\Delta \\lambda$.\n- For $g_{\\text{energy}}$: $\\frac{\\partial g_{\\text{energy}}}{\\partial \\mathbf{u}} = 2(\\mathbf{K}_k+\\epsilon\\mathbf{I})\\Delta \\mathbf{u}$ and $\\frac{\\partial g_{\\text{energy}}}{\\partial \\lambda} = 2\\psi\\Delta \\lambda$.\n\n**4. Predictor-Corrector Algorithm**\n\nEach step of the continuation method consists of two phases:\n1.  **Predictor Phase:** An initial guess for the next equilibrium point is computed. This guess is a step of length $\\Delta s$ along the tangent to the solution path at the last converged point $(\\mathbf{u}_k, \\lambda_k)$. The tangent direction $(\\mathbf{d}_u, d_\\lambda)$ is prescribed by the problem statement, which ensures it satisfies the linearized equilibrium condition at the singular starting points. The scaling parameter $\\alpha$ is calculated to satisfy the arc-length constraint for this predictor step, i.e., $g(\\mathbf{u}_k + \\mathbf{d}_u, \\lambda_k + d_\\lambda) = 0$. The sign of $\\alpha$ is chosen such that $d_\\lambda > 0$, ensuring forward progression in the load parameter initially. The first iterate is $(\\mathbf{u}^{(0)}, \\lambda^{(0)}) = (\\mathbf{u}_k + \\mathbf{d}_u, \\lambda_k + d_\\lambda)$.\n2.  **Corrector Phase:** Starting from the predictor point, the extended Newton-Raphson scheme is applied iteratively to converge to the true equilibrium point on the constraint surface. The iterations continue until the norm of the extended residual vector falls below a specified tolerance $\\mathrm{tol}$.\n\nThe overall process involves starting from a known equilibrium point $(\\mathbf{u}_0, \\lambda_0)$ and sequentially computing a series of points $(\\mathbf{u}_1, \\lambda_1), (\\mathbf{u}_2, \\lambda_2), \\dots$ that trace out the solution path. This approach allows the method to navigate around limit points and follow complex post-bifurcation paths, which is precisely what the test cases are designed to probe. The parameter $\\beta$ in the predictor acts as an \"imperfection\" to nudge the solution off a primary path onto a secondary, symmetry-broken branch.", "answer": "```python\nimport numpy as np\n\ndef run_continuation(\n    u0, lambda0, constraint_type, ds, psi, beta, epsilon, N, tol, max_iter\n):\n    \"\"\"\n    Performs arc-length continuation to solve a nonlinear system.\n\n    Args:\n        u0 (np.ndarray): Initial displacement vector.\n        lambda0 (float): Initial load parameter.\n        constraint_type (str): 'disp' or 'energy'.\n        ds (float): Arc-length for each step.\n        psi (float): Load-displacement scaling factor.\n        beta (float): Predictor tangent bias.\n        epsilon (float): Regularization for energy norm.\n        N (int): Number of continuation steps.\n        tol (float): Convergence tolerance.\n        max_iter (int): Maximum Newton iterations per step.\n\n    Returns:\n        tuple: (final u vector, boolean for all steps converged).\n    \"\"\"\n    u_current = np.array(u0, dtype=float)\n    lambda_current = float(lambda0)\n    \n    all_steps_converged = True\n\n    for _ in range(N):\n        u_k = u_current\n        lambda_k = lambda_current\n\n        # --- Predictor Step ---\n        norm_u_k_sq = u_k @ u_k\n        if norm_u_k_sq  1e-16: # Avoid division by zero, though problem setup avoids this.\n            t_k = np.array([1.0, 0.0]) \n        else:\n            t_k = np.array([-u_k[1], u_k[0]]) / np.sqrt(norm_u_k_sq)\n        \n        # Calculate alpha for the predictor\n        d_lambda_over_alpha = 2 * norm_u_k_sq\n        \n        if constraint_type == 'disp':\n            # Denominator of alpha^2: du^T du + psi * dlambda^2\n            # du = alpha*u_k + beta*t_k\n            # (alpha*u_k + beta*t_k)^T(alpha*u_k + beta*t_k) = alpha^2*norm_u_k^2 + beta^2\n            # because u_k and t_k are orthogonal.\n            numerator = ds**2 - beta**2\n            denominator = norm_u_k_sq + psi * (d_lambda_over_alpha**2)\n            if numerator  0:\n                 all_steps_converged = False\n                 break\n            alpha = np.sqrt(numerator / denominator)\n        \n        elif constraint_type == 'energy':\n            # The matrix for the energy norm metric is M = K_k + eps*I\n            # At given starting points, u_k^T u_k - lambda_k = 0, so K_k = 2*u_k*u_k^T\n            K_k = 2 * np.outer(u_k, u_k)\n            M_mat = K_k + epsilon * np.eye(2)\n            \n            # Predictor du = alpha*u_k + beta*t_k\n            # du^T M du = (alpha*u_k + beta*t_k)^T M (alpha*u_k + beta*t_k)\n            # This expands to: alpha^2 * u_k^T M u_k + beta^2 * t_k^T M t_k \n            # (cross terms are zero as u_k and t_k are eigenvectors of M)\n            numerator = ds**2 - beta**2 * (t_k @ M_mat @ t_k)\n            denominator = (u_k @ M_mat @ u_k) + psi * (d_lambda_over_alpha**2)\n            if numerator  0:\n                 all_steps_converged = False\n                 break\n            alpha = np.sqrt(numerator / denominator)\n\n        d_lambda = alpha * d_lambda_over_alpha\n        d_u = alpha * u_k + beta * t_k\n\n        u_c = u_k + d_u\n        lambda_c = lambda_k + d_lambda\n\n        # --- Corrector Step (Newton-Raphson) ---\n        step_converged = False\n        for _ in range(max_iter):\n            # Calculate increments from start of step\n            delta_u = u_c - u_k\n            delta_lambda = lambda_c - lambda_k\n            \n            # Evaluate extended residual\n            R = (u_c @ u_c - lambda_c) * u_c\n            \n            if constraint_type == 'disp':\n                g = delta_u @ delta_u + psi * delta_lambda**2 - ds**2\n            else: # energy norm\n                # K_k is constant within the step\n                K_k = 2 * np.outer(u_k, u_k)\n                M_mat = K_k + epsilon * np.eye(2)\n                g = delta_u @ M_mat @ delta_u + psi * delta_lambda**2 - ds**2\n\n            extended_residual = np.array([R[0], R[1], g])\n            \n            if np.linalg.norm(extended_residual)  tol:\n                step_converged = True\n                break\n                \n            # Evaluate extended Jacobian\n            K_c = (u_c @ u_c - lambda_c) * np.eye(2) + 2 * np.outer(u_c, u_c)\n            q_c = -u_c\n            \n            if constraint_type == 'disp':\n                dg_du = 2 * delta_u\n                dg_dlambda = 2 * psi * delta_lambda\n            else: # energy norm\n                # K_k is constant within the step\n                K_k = 2 * np.outer(u_k, u_k)\n                M_mat = K_k + epsilon * np.eye(2)\n                dg_du = 2 * M_mat @ delta_u\n                dg_dlambda = 2 * psi * delta_lambda\n\n            J_ext = np.zeros((3, 3))\n            J_ext[0:2, 0:2] = K_c\n            J_ext[0:2, 2] = q_c\n            J_ext[2, 0:2] = dg_du\n            J_ext[2, 2] = dg_dlambda\n            \n            # Solve for update and apply\n            try:\n                update = np.linalg.solve(J_ext, -extended_residual)\n            except np.linalg.LinAlgError:\n                all_steps_converged = False\n                break\n                \n            u_c += update[0:2]\n            lambda_c += update[2]\n        \n        if not step_converged:\n            all_steps_converged = False\n            # For Test Case 3, we must check if *all* steps converge,\n            # so we only set the flag and break the inner loop. The outer\n            # loop should technically stop if a step fails, but the requirement\n            # is just to report if *all* N steps succeeded. So we can break.\n            break\n\n        u_current = u_c\n        lambda_current = lambda_c\n\n    return u_current, all_steps_converged\n\ndef solve():\n    \"\"\"\n    Sets up and runs the test cases specified in the problem statement.\n    \"\"\"\n    test_cases = [\n        # Case 1: displacement-norm, symmetry-breaking\n        dict(u0=[0.5, 0.0], lambda0=0.25, constraint_type='disp', ds=0.05, \n             psi=0.5, beta=0.02, epsilon=0.0, N=8, tol=1e-10, max_iter=50),\n        # Case 2: energy-norm, symmetry-breaking\n        dict(u0=[0.5, 0.0], lambda0=0.25, constraint_type='energy', ds=0.05, \n             psi=0.5, beta=0.02, epsilon=1e-4, N=8, tol=1e-10, max_iter=50),\n        # Case 3: energy-norm, robustness test\n        dict(u0=[0.2, 0.0], lambda0=0.04, constraint_type='energy', ds=0.02, \n             psi=0.5, beta=0.0, epsilon=1e-4, N=5, tol=1e-12, max_iter=80),\n    ]\n\n    results = []\n\n    # Test Case 1\n    u_final_1, _ = run_continuation(**test_cases[0])\n    theta_1 = np.arctan2(u_final_1[1], u_final_1[0])\n    results.append(theta_1)\n\n    # Test Case 2\n    u_final_2, _ = run_continuation(**test_cases[1])\n    theta_2 = np.arctan2(u_final_2[1], u_final_2[0])\n    results.append(theta_2)\n\n    # Test Case 3\n    _, conv_3 = run_continuation(**test_cases[2])\n    results.append(int(conv_3))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3583526"}]}