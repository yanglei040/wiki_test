{"hands_on_practices": [{"introduction": "The journey into nonlinear analysis begins with understanding how to correctly linearize the governing equations. This first practice challenges you to derive the consistent tangent stiffness matrix for a simple bar element with both material and geometric nonlinearities, starting from the principle of virtual work [@problem_id:2538124]. Mastering this fundamental procedure is the cornerstone for tackling more complex nonlinear finite element problems.", "problem": "Consider a single $1\\text{-dimensional}$, two-node linear bar finite element of length $L$, occupying the reference domain $x \\in [0,L]$, with displacement field $u(x)$ approximated by the standard linear interpolation $u(x) = N_{1}(x)\\,u_{1} + N_{2}(x)\\,u_{2}$, where $N_{1}(x) = 1 - x/L$ and $N_{2}(x) = x/L$. The cross-sectional area varies linearly as $A(x) = A_{0}\\left(1 + \\beta \\frac{x}{L}\\right)$ with given constants $A_{0} > 0$ and real $\\beta$. The bar is made of a material with a nonlinear constitutive law $\\sigma = \\sigma(\\epsilon)$, where the engineering strain is $\\epsilon(x) = \\frac{du}{dx}$. For this problem, take $\\sigma(\\epsilon) = E\\,\\epsilon + \\alpha\\,\\epsilon^{3}$ with given constants $E > 0$ and $\\alpha$ real.\n\nStarting from the principle of virtual work and the definition of the element internal force vector in the finite element method (FEM), perform a consistent linearization of the weak form about an arbitrary trial state $u^{t}(x) = N_{1}(x)\\,u_{1}^{t} + N_{2}(x)\\,u_{2}^{t}$ with given nodal values $u_{1}^{t}$ and $u_{2}^{t}$. Derive the element consistent tangent stiffness matrix evaluated at the trial state. Express your result entirely in terms of $A_{0}$, $\\beta$, $L$, $E$, $\\alpha$, $u_{1}^{t}$, and $u_{2}^{t}$, using the element strain-displacement matrix $B = \\left[-\\frac{1}{L}\\ \\ \\frac{1}{L}\\right]$. \n\nYour final answer must be the closed-form $2 \\times 2$ tangent stiffness matrix evaluated at the trial state, written as a single symbolic expression. Do not include units in your final answer.", "solution": "The problem as stated is scientifically grounded, well-posed, and self-contained. It presents a standard, albeit non-trivial, exercise in nonlinear finite element analysis. All provided information is consistent and sufficient for deriving the requested quantity. The problem is therefore valid. We now proceed with the derivation.\n\nThe starting point for the formulation of a nonlinear finite element problem is the principle of virtual work (PVW). The statement of equilibrium requires that the internal virtual work, $\\delta W_{int}$, equals the external virtual work, $\\delta W_{ext}$, for any arbitrary kinematically admissible virtual displacement. We are concerned with the internal forces and the tangent stiffness, so we focus on the internal virtual work. For a one-dimensional bar, $\\delta W_{int}$ is given by the integral of the stress $\\sigma$ acting over the virtual strain $\\delta\\epsilon$ throughout the volume of the element:\n$$\n\\delta W_{int} = \\int_{V} \\sigma \\delta\\epsilon \\, dV = \\int_{0}^{L} \\sigma(x) A(x) \\delta\\epsilon(x) \\, dx\n$$\nHere, $A(x)$ is the cross-sectional area, $L$ is the element length, and $\\sigma$ and $\\epsilon$ are the engineering stress and strain, respectively.\n\nThe displacement field $u(x)$ is approximated using linear shape functions $N_1(x)$ and $N_2(x)$ and nodal displacements $u_1$ and $u_2$. In matrix notation, we write the displacement vector as $\\mathbf{u}_{e} = \\begin{pmatrix} u_1 & u_2 \\end{pmatrix}^T$, and the displacement field as:\n$$\nu(x) = \\mathbf{N}(x) \\mathbf{u}_{e} = \\begin{pmatrix} N_1(x) & N_2(x) \\end{pmatrix} \\mathbf{u}_{e}\n$$\nThe strain $\\epsilon(x)$ is the spatial derivative of the displacement:\n$$\n\\epsilon(x) = \\frac{du}{dx} = \\frac{d\\mathbf{N}}{dx} \\mathbf{u}_{e} = \\mathbf{B} \\mathbf{u}_{e}\n$$\nwhere $\\mathbf{B}$ is the strain-displacement matrix. For the given linear shape functions $N_{1}(x) = 1 - x/L$ and $N_{2}(x) = x/L$, the derivatives are constant: $\\frac{dN_1}{dx} = -\\frac{1}{L}$ and $\\frac{dN_2}{dx} = \\frac{1}{L}$. Thus, $\\mathbf{B}$ is a constant matrix:\n$$\n\\mathbf{B} = \\begin{pmatrix} -\\frac{1}{L} & \\frac{1}{L} \\end{pmatrix}\n$$\nSince $\\mathbf{B}$ is constant, the strain $\\epsilon$ is also constant throughout the element for any given $\\mathbf{u}_e$.\n\nThe virtual strain $\\delta\\epsilon$ is related to the virtual nodal displacements $\\delta\\mathbf{u}_e$ by the same matrix $\\mathbf{B}$:\n$$\n\\delta\\epsilon(x) = \\mathbf{B} \\delta\\mathbf{u}_{e}\n$$\nSubstituting the discretized forms of $\\sigma$ and $\\delta\\epsilon$ into the PVW expression:\n$$\n\\delta W_{int} = \\int_{0}^{L} \\sigma(\\mathbf{B}\\mathbf{u}_{e}) A(x) (\\mathbf{B} \\delta\\mathbf{u}_{e}) \\, dx = \\delta\\mathbf{u}_{e}^T \\left( \\int_{0}^{L} \\mathbf{B}^T \\sigma(\\mathbf{B}\\mathbf{u}_{e}) A(x) \\, dx \\right)\n$$\nFrom the PVW, $\\delta W_{int} = \\delta\\mathbf{u}_{e}^T \\mathbf{f}_{int}$, we identify the element internal force vector $\\mathbf{f}_{int}$:\n$$\n\\mathbf{f}_{int}(\\mathbf{u}_{e}) = \\int_{0}^{L} \\mathbf{B}^T \\sigma(\\mathbf{B}\\mathbf{u}_{e}) A(x) \\, dx\n$$\nThe element consistent tangent stiffness matrix, $\\mathbf{K}_T$, is defined as the GÃ¢teaux derivative of the internal force vector with respect to the nodal displacement vector:\n$$\n\\mathbf{K}_T = \\frac{d\\mathbf{f}_{int}}{d\\mathbf{u}_e}\n$$\nPerforming this differentiation:\n$$\nd\\mathbf{f}_{int} = \\int_{0}^{L} \\mathbf{B}^T d\\sigma A(x) \\, dx\n$$\nThe differential of stress, $d\\sigma$, is related to the differential of strain, $d\\epsilon$, via the tangent modulus $E_T = \\frac{d\\sigma}{d\\epsilon}$.\n$$\nd\\sigma = E_T(\\epsilon) d\\epsilon = E_T(\\epsilon) \\mathbf{B} d\\mathbf{u}_e\n$$\nSubstituting this into the expression for $d\\mathbf{f}_{int}$:\n$$\nd\\mathbf{f}_{int} = \\int_{0}^{L} \\mathbf{B}^T E_T(\\epsilon) \\mathbf{B} d\\mathbf{u}_e A(x) \\, dx = \\left( \\int_{0}^{L} \\mathbf{B}^T E_T(\\epsilon) \\mathbf{B} A(x) \\, dx \\right) d\\mathbf{u}_e\n$$\nThus, the tangent stiffness matrix is:\n$$\n\\mathbf{K}_T(\\mathbf{u}_e) = \\int_{0}^{L} \\mathbf{B}^T E_T(\\epsilon) \\mathbf{B} A(x) \\, dx\n$$\nThe problem requires evaluating $\\mathbf{K}_T$ at a given trial state $\\mathbf{u}_{e}^t = \\begin{pmatrix} u_1^t & u_2^t \\end{pmatrix}^T$. The strain at this state, $\\epsilon^t$, is constant:\n$$\n\\epsilon^t = \\mathbf{B} \\mathbf{u}_{e}^t = \\begin{pmatrix} -\\frac{1}{L} & \\frac{1}{L} \\end{pmatrix} \\begin{pmatrix} u_1^t \\\\ u_2^t \\end{pmatrix} = \\frac{u_2^t - u_1^t}{L}\n$$\nThe nonlinear constitutive law is given as $\\sigma(\\epsilon) = E\\,\\epsilon + \\alpha\\,\\epsilon^3$. The tangent modulus $E_T$ is its derivative with respect to strain:\n$$\nE_T(\\epsilon) = \\frac{d\\sigma}{d\\epsilon} = E + 3\\alpha\\,\\epsilon^2\n$$\nEvaluating this at the trial strain $\\epsilon^t$:\n$$\nE_T(\\epsilon^t) = E + 3\\alpha (\\epsilon^t)^2 = E + 3\\alpha \\left( \\frac{u_2^t - u_1^t}{L} \\right)^2\n$$\nSince $\\mathbf{B}$ and $E_T(\\epsilon^t)$ are constant with respect to the integration variable $x$, we can move them outside the integral for $\\mathbf{K}_T$:\n$$\n\\mathbf{K}_T(\\mathbf{u}_{e}^t) = \\mathbf{B}^T E_T(\\epsilon^t) \\mathbf{B} \\int_{0}^{L} A(x) \\, dx\n$$\nNext, we evaluate the integral of the area function $A(x) = A_{0}\\left(1 + \\beta \\frac{x}{L}\\right)$:\n$$\n\\int_{0}^{L} A(x) \\, dx = \\int_{0}^{L} A_0 \\left( 1 + \\beta \\frac{x}{L} \\right) dx = A_0 \\left[ x + \\frac{\\beta x^2}{2L} \\right]_{0}^{L} = A_0 \\left( L + \\frac{\\beta L^2}{2L} \\right) = A_0 L \\left( 1 + \\frac{\\beta}{2} \\right)\n$$\nThe matrix product $\\mathbf{B}^T \\mathbf{B}$ is:\n$$\n\\mathbf{B}^T \\mathbf{B} = \\begin{pmatrix} -1/L \\\\ 1/L \\end{pmatrix} \\begin{pmatrix} -1/L & 1/L \\end{pmatrix} = \\begin{pmatrix} 1/L^2 & -1/L^2 \\\\ -1/L^2 & 1/L^2 \\end{pmatrix} = \\frac{1}{L^2} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}\n$$\nNow, we assemble all the components:\n$$\n\\mathbf{K}_T(\\mathbf{u}_{e}^t) = \\frac{1}{L^2} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix} \\left( E + 3\\alpha \\frac{(u_2^t - u_1^t)^2}{L^2} \\right) \\left( A_0 L \\left( 1 + \\frac{\\beta}{2} \\right) \\right)\n$$\nCombining the scalar terms, we obtain the final expression for the consistent tangent stiffness matrix:\n$$\n\\mathbf{K}_T = \\frac{A_0}{L} \\left( 1 + \\frac{\\beta}{2} \\right) \\left( E + 3\\alpha \\frac{(u_2^t - u_1^t)^2}{L^2} \\right) \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}\n$$\nTo present the answer as a single matrix, we define the scalar coefficient as:\n$$\nC = \\frac{A_0}{L} \\left( 1 + \\frac{\\beta}{2} \\right) \\left( E + 3\\alpha \\frac{(u_2^t - u_1^t)^2}{L^2} \\right)\n$$\nThe tangent stiffness matrix is then $\\mathbf{K}_T = \\begin{pmatrix} C & -C \\\\ -C & C \\end{pmatrix}$. This is the required result.", "answer": "$$\n\\boxed{\n\\frac{A_0}{L} \\left( 1 + \\frac{\\beta}{2} \\right) \\left( E + 3\\alpha \\frac{(u_2^t - u_1^t)^2}{L^2} \\right)\n\\begin{pmatrix}\n1 & -1 \\\\\n-1 & 1\n\\end{pmatrix}\n}\n$$", "id": "2538124"}, {"introduction": "An analytical formula is only as good as its implementation, and verifying complex mathematical expressions in code is a crucial skill for any computational engineer. This exercise guides you through the process of implementing a finite-difference check to verify your analytically derived tangent stiffness matrix [@problem_id:3552137]. By exploring the impact of the perturbation size $\\epsilon$, you will gain practical insight into the delicate balance between truncation error and floating-point round-off error that is central to numerical analysis.", "problem": "Consider a one-dimensional, two-node bar element with two displacement degrees of freedom collected in the vector $\\mathbf{u} = [u_1,u_2]^T$. The element has constant cross-sectional area $A > 0$, length $L > 0$, and a nonlinear constitutive law relating the Cauchy stress $\\sigma$ to the engineering strain $\\varepsilon$ as $\\sigma(\\varepsilon) = E\\,\\varepsilon + \\beta\\,\\varepsilon^3$, where $E > 0$ is a linear modulus and $\\beta \\ge 0$ is a nonlinear coefficient. Using linear shape functions, the engineering strain is $\\varepsilon = (u_2 - u_1)/L$. The internal residual vector $\\mathbf{R}(\\mathbf{u})$ arises from the principle of virtual work and is defined by the integral of the stress projected by the strain-displacement matrix over the element. In this setting, you may assume the residual has two components $R_1(\\mathbf{u})$ and $R_2(\\mathbf{u})$ determined by the mechanics of the bar element with the given constitutive law.\n\nThe goal is to design and implement a finite-difference check of the consistent tangent stiffness matrix $\\mathbf{K}(\\mathbf{u}) = \\partial \\mathbf{R}/\\partial \\mathbf{u}$ using the central difference approximation\n$$\nK_{ij}^{\\mathrm{FD}}(\\mathbf{u};\\epsilon) \\approx \\frac{R_i(\\mathbf{u} + \\epsilon\\,\\mathbf{e}_j) - R_i(\\mathbf{u} - \\epsilon\\,\\mathbf{e}_j)}{2\\,\\epsilon},\n$$\nwhere $\\epsilon > 0$ is a scalar perturbation size, $i,j \\in \\{1,2\\}$, and $\\mathbf{e}_j$ is the $j$-th canonical unit vector in $\\mathbb{R}^2$. You must also compute the exact consistent tangent stiffness $\\mathbf{K}(\\mathbf{u})$ by differentiating $\\mathbf{R}(\\mathbf{u})$ with respect to $\\mathbf{u}$ starting from the fundamental definitions provided, and compare $\\mathbf{K}^{\\mathrm{FD}}$ against $\\mathbf{K}$ by reporting the relative Frobenius norm error\n$$\n\\eta(\\epsilon,\\mathbf{u}) = \\frac{\\left\\|\\mathbf{K}^{\\mathrm{FD}}(\\mathbf{u};\\epsilon) - \\mathbf{K}(\\mathbf{u})\\right\\|_F}{\\left\\|\\mathbf{K}(\\mathbf{u})\\right\\|_F}.\n$$\n\nYour program must implement the residual $\\mathbf{R}(\\mathbf{u})$ for the described bar element and the exact consistent tangent stiffness $\\mathbf{K}(\\mathbf{u})$ derived from first principles. Then, for each test case listed below, it must compute the finite-difference approximation $\\mathbf{K}^{\\mathrm{FD}}(\\mathbf{u};\\epsilon)$, evaluate the relative error $\\eta(\\epsilon,\\mathbf{u})$, and aggregate the results.\n\nUse the following material and geometric parameters for all tests: $A = 1.0$, $L = 1.0$, $E = 10.0$, $\\beta = 5.0$. Treat all quantities as dimensionless; no physical units are required in the output.\n\nTest suite:\n1. A general case to validate accuracy at a moderate perturbation: $\\mathbf{u} = [0.2,\\,0.8]^T$, $\\epsilon = 10^{-6}$.\n2. A round-off sensitive case with an extremely small perturbation: $\\mathbf{u} = [0.2,\\,0.8]^T$, $\\epsilon = 10^{-12}$.\n3. A truncation-error dominated case with a large perturbation: $\\mathbf{u} = [0.2,\\,0.8]^T$, $\\epsilon = 10^{-2}$.\n4. A near-zero-strain edge case: $\\mathbf{u} = [10^{-12},\\,-10^{-12}]^T$, $\\epsilon = 10^{-6}$.\n5. A case using a recommended central-difference scaling tied to machine precision: $\\mathbf{u} = [0.2,\\,0.8]^T$, $\\epsilon = \\varepsilon_{\\mathrm{mach}}^{1/3}$, where $\\varepsilon_{\\mathrm{mach}}$ is the machine precision for double-precision floating-point arithmetic.\n\nYour program should produce a single line of output containing the five relative errors $\\eta$ for the test cases as a comma-separated list enclosed in square brackets (for example, \"[e1,e2,e3,e4,e5]\"), where each $e_k$ is a decimal number.", "solution": "The problem statement is evaluated as valid. It is scientifically grounded in the principles of computational solid mechanics, contains all necessary information, is free from contradictions, and is well-posed, admitting a unique and meaningful solution.\n\nThe primary objective is to verify an analytically derived consistent tangent stiffness matrix, $\\mathbf{K}(\\mathbf{u})$, against its numerical approximation via the central finite-difference method, $\\mathbf{K}^{\\mathrm{FD}}(\\mathbf{u};\\epsilon)$. The verification is quantified by the relative Frobenius norm error, $\\eta$.\n\nFirst, we derive the analytical expressions for the internal residual vector, $\\mathbf{R}(\\mathbf{u})$, and the consistent tangent stiffness matrix, $\\mathbf{K}(\\mathbf{u})$. The derivation begins from the principle of virtual work. For a one-dimensional bar element, the internal virtual work, $\\delta W_{\\text{int}}$, is given by the volume integral of the stress, $\\sigma$, multiplied by the virtual strain, $\\delta\\varepsilon$:\n$$\n\\delta W_{\\text{int}} = \\int_{V} \\sigma \\, \\delta\\varepsilon \\, dV\n$$\nGiven a constant cross-sectional area $A$ and element length $L$, and assuming linear shape functions which result in a constant strain field within the element, the integral simplifies to:\n$$\n\\delta W_{\\text{int}} = \\sigma A L \\, \\delta\\varepsilon\n$$\nThe engineering strain, $\\varepsilon$, is related to the nodal displacement vector $\\mathbf{u} = [u_1, u_2]^T$ by the strain-displacement matrix $\\mathbf{B}$:\n$$\n\\varepsilon = \\frac{u_2 - u_1}{L} = \\begin{bmatrix} -1/L & 1/L \\end{bmatrix} \\begin{bmatrix} u_1 \\\\ u_2 \\end{bmatrix} = \\mathbf{B}\\mathbf{u}\n$$\nThe virtual strain is then $\\delta\\varepsilon = \\mathbf{B}\\delta\\mathbf{u}$. Substituting this into the virtual work expression yields:\n$$\n\\delta W_{\\text{int}} = \\sigma A L (\\mathbf{B}\\delta\\mathbf{u}) = (\\sigma A L \\mathbf{B}) \\delta\\mathbf{u}\n$$\nThe internal virtual work is also defined in terms of the internal residual vector $\\mathbf{R}$ as $\\delta W_{\\text{int}} = \\mathbf{R}^T \\delta\\mathbf{u}$. By comparing the two expressions, we identify the residual vector:\n$$\n\\mathbf{R}(\\mathbf{u})^T = \\sigma A L \\mathbf{B} \\implies \\mathbf{R}(\\mathbf{u}) = \\mathbf{B}^T \\sigma A L\n$$\nSubstituting the expression for $\\mathbf{B}$, and the given constitutive law $\\sigma(\\varepsilon) = E\\varepsilon + \\beta\\varepsilon^3$:\n$$\n\\mathbf{R}(\\mathbf{u}) = \\begin{bmatrix} -1/L \\\\ 1/L \\end{bmatrix} \\left( E\\varepsilon + \\beta\\varepsilon^3 \\right) A L = A \\left( E\\varepsilon + \\beta\\varepsilon^3 \\right) \\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix}\n$$\nThis expression defines the internal forces at the nodes, which are equal and opposite, as expected.\n\nNext, we derive the consistent tangent stiffness matrix, $\\mathbf{K}(\\mathbf{u})$, by differentiating the residual vector $\\mathbf{R}(\\mathbf{u})$ with respect to the displacement vector $\\mathbf{u}$:\n$$\n\\mathbf{K}(\\mathbf{u}) = \\frac{\\partial \\mathbf{R}(\\mathbf{u})}{\\partial \\mathbf{u}}\n$$\nUsing the chain rule, and the fact that $\\sigma$ is a function of $\\varepsilon$, which in turn is a function of $\\mathbf{u}$:\n$$\n\\mathbf{K}(\\mathbf{u}) = \\frac{\\partial \\mathbf{R}}{\\partial \\varepsilon} \\frac{\\partial \\varepsilon}{\\partial \\mathbf{u}} = \\left( \\frac{\\partial}{\\partial \\varepsilon} \\left[ \\mathbf{B}^T \\sigma(\\varepsilon) A L \\right] \\right) (\\mathbf{B}) = \\mathbf{B}^T \\frac{d\\sigma}{d\\varepsilon} \\mathbf{B} A L\n$$\nThe derivative of stress with respect to strain, $\\frac{d\\sigma}{d\\varepsilon}$, is the material tangent modulus, $E_t$:\n$$\nE_t = \\frac{d\\sigma}{d\\varepsilon} = \\frac{d}{d\\varepsilon}\\left(E\\varepsilon + \\beta\\varepsilon^3\\right) = E + 3\\beta\\varepsilon^2\n$$\nSubstituting $E_t$ and $\\mathbf{B}$ into the expression for $\\mathbf{K}$:\n$$\n\\mathbf{K}(\\mathbf{u}) = \\begin{bmatrix} -1/L \\\\ 1/L \\end{bmatrix} (E + 3\\beta\\varepsilon^2) \\begin{bmatrix} -1/L & 1/L \\end{bmatrix} A L = \\frac{AL}{L^2}(E + 3\\beta\\varepsilon^2) \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}\n$$\nThis simplifies to the final analytical expression for the consistent tangent stiffness matrix:\n$$\n\\mathbf{K}(\\mathbf{u}) = \\frac{A}{L} \\left( E + 3\\beta\\left(\\frac{u_2 - u_1}{L}\\right)^2 \\right) \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}\n$$\nThe problem requires computing a numerical approximation, $\\mathbf{K}^{\\mathrm{FD}}$, using the central difference formula:\n$$\nK_{ij}^{\\mathrm{FD}}(\\mathbf{u};\\epsilon) = \\frac{R_i(\\mathbf{u} + \\epsilon\\,\\mathbf{e}_j) - R_i(\\mathbf{u} - \\epsilon\\,\\mathbf{e}_j)}{2\\,\\epsilon}\n$$\nHere, $\\mathbf{e}_1 = [1,0]^T$ and $\\mathbf{e}_2 = [0,1]^T$ are the canonical basis vectors. This formula is applied for each column $j$ of the matrix.\n\nFinally, the relative error $\\eta$ is computed using the Frobenius norm, denoted by $\\|\\cdot\\|_F$, which for a matrix $\\mathbf{M}$ is defined as $\\|\\mathbf{M}\\|_F = \\sqrt{\\sum_i \\sum_j M_{ij}^2}$. The error is:\n$$\n\\eta(\\epsilon,\\mathbf{u}) = \\frac{\\left\\|\\mathbf{K}^{\\mathrm{FD}}(\\mathbf{u};\\epsilon) - \\mathbf{K}(\\mathbf{u})\\right\\|_F}{\\left\\|\\mathbf{K}(\\mathbf{u})\\right\\|_F}\n$$\nThe implementation will consist of functions to compute $\\mathbf{R}(\\mathbf{u})$, $\\mathbf{K}(\\mathbf{u})$, and $\\mathbf{K}^{\\mathrm{FD}}(\\mathbf{u};\\epsilon)$, and then evaluate $\\eta$ for each of the five specified test cases. The fifth case requires the machine epsilon for double-precision floating-point numbers, $\\varepsilon_{\\mathrm{mach}}$, which is the smallest number such that $1.0 + \\varepsilon_{\\mathrm{mach}} \\ne 1.0$. The optimal perturbation for a central difference scheme is often related to $\\varepsilon_{\\mathrm{mach}}^{1/3}$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Computes and compares analytical and finite-difference tangent stiffness matrices\n    for a nonlinear 1D bar element.\n    \"\"\"\n\n    # Define material and geometric parameters\n    A = 1.0  # Cross-sectional area\n    L = 1.0  # Length\n    E = 10.0 # Linear modulus\n    beta = 5.0 # Nonlinear coefficient\n\n    def residual(u, A, L, E, beta):\n        \"\"\"\n        Computes the internal residual vector R(u) for the bar element.\n        R(u) = A * sigma(epsilon) * [-1, 1]^T\n        \"\"\"\n        if not isinstance(u, np.ndarray):\n            u = np.array(u, dtype=float)\n        \n        strain = (u[1] - u[0]) / L\n        stress = E * strain + beta * strain**3\n        internal_force = A * stress\n        return np.array([-internal_force, internal_force])\n\n    def exact_stiffness(u, A, L, E, beta):\n        \"\"\"\n        Computes the exact consistent tangent stiffness matrix K(u).\n        K(u) = (A/L) * (E + 3*beta*epsilon^2) * [[1, -1], [-1, 1]]\n        \"\"\"\n        if not isinstance(u, np.ndarray):\n            u = np.array(u, dtype=float)\n            \n        strain = (u[1] - u[0]) / L\n        tangent_modulus = E + 3.0 * beta * strain**2\n        factor = (A / L) * tangent_modulus\n        return factor * np.array([[1.0, -1.0], [-1.0, 1.0]])\n\n    def fd_stiffness(u, eps, A, L, E, beta):\n        \"\"\"\n        Computes the finite-difference approximation of the tangent stiffness matrix.\n        \"\"\"\n        if not isinstance(u, np.ndarray):\n            u = np.array(u, dtype=float)\n            \n        K_fd = np.zeros((2, 2))\n        e_vecs = [np.array([1.0, 0.0]), np.array([0.0, 1.0])]\n        \n        for j in range(2):\n            u_plus = u + eps * e_vecs[j]\n            u_minus = u - eps * e_vecs[j]\n            \n            R_plus = residual(u_plus, A, L, E, beta)\n            R_minus = residual(u_minus, A, L, E, beta)\n            \n            K_fd[:, j] = (R_plus - R_minus) / (2.0 * eps)\n            \n        return K_fd\n\n    def relative_error(K_fd, K_exact):\n        \"\"\"\n        Computes the relative Frobenius norm error between two matrices.\n        \"\"\"\n        diff_norm = np.linalg.norm(K_fd - K_exact, 'fro')\n        exact_norm = np.linalg.norm(K_exact, 'fro')\n        \n        # Handle case where the exact norm is zero\n        if exact_norm == 0:\n            return 0.0 if diff_norm == 0 else np.inf\n            \n        return diff_norm / exact_norm\n\n    # Machine epsilon for double precision\n    eps_mach = np.finfo(float).eps\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1. General case\n        {'u': np.array([0.2, 0.8]), 'eps': 1e-6},\n        # 2. Round-off sensitive case\n        {'u': np.array([0.2, 0.8]), 'eps': 1e-12},\n        # 3. Truncation-error dominated case\n        {'u': np.array([0.2, 0.8]), 'eps': 1e-2},\n        # 4. Near-zero-strain edge case\n        {'u': np.array([1e-12, -1e-12]), 'eps': 1e-6},\n        # 5. Optimal perturbation case\n        {'u': np.array([0.2, 0.8]), 'eps': eps_mach**(1/3.0)}\n    ]\n\n    results = []\n    for case in test_cases:\n        u_vec = case['u']\n        epsilon = case['eps']\n        \n        # Compute the exact and finite-difference matrices\n        K_exact = exact_stiffness(u_vec, A, L, E, beta)\n        K_fd = fd_stiffness(u_vec, epsilon, A, L, E, beta)\n        \n        # Compute and store the relative error\n        error = relative_error(K_fd, K_exact)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3552137"}, {"introduction": "After deriving and verifying the tangent matrix, the final question is: why is this 'consistency' so important? This practice demonstrates the profound impact of a consistent tangent on the efficiency of a nonlinear solver [@problem_id:3552105]. By comparing the convergence behavior of a Newton method with a consistent versus an inconsistent tangent, you will witness firsthand how consistency enables rapid, quadratic convergence and reduces the reliance on performance-costly line-search modifications.", "problem": "Consider a single-degree-of-freedom equilibrium problem representing a linearly discretized bar in one dimension with a smooth softening-type constitutive response that remains monotone in stress. Let the displacement be the unknown scalar $u$, the engineering strain be $\\varepsilon = u$, and the Cauchy stress be given by the nonlinear constitutive function $\\sigma(\\varepsilon) = \\dfrac{E\\,\\varepsilon}{1 + \\alpha\\,\\varepsilon}$, where $E > 0$ is a modulus and $\\alpha \\ge 0$ controls the stiffness degradation with increasing strain. Assume nondimensional units with $A = 1$, $L = 1$, and $E = 1$ throughout, so that no physical unit conversion is required. The external load is the scalar $P \\ge 0$ and the residual equation to be solved at each load step is $R(u;P) = \\sigma(u) - P = 0$.\n\nYour task is to implement a line-search modified Newton method for the equilibrium equation based on minimizing the scalar merit function $\\phi(u) = \\tfrac{1}{2}\\,R(u;P)^2$ using an Armijo sufficient decrease backtracking rule. The Newton search direction at iterate $u_k$ must be computed from a linearization $K(u_k)\\,\\Delta u_k = -R(u_k;P)$, where $K(u_k)$ is the tangent stiffness, and the trial update is $u_{k+1}^{\\text{trial}} = u_k + \\alpha_k\\,\\Delta u_k$ with backtracking parameter $\\alpha_k \\in (0,1]$ chosen to satisfy the Armijo sufficient decrease condition on $\\phi$.\n\nYou must:\n- Derive and implement the exact consistent tangent stiffness $K_{\\text{cons}}(u) = \\dfrac{dR}{du}(u)$ that follows from the residual $R(u;P)$ and the given constitutive law.\n- Implement an inconsistent tangent model $K_{\\text{inc}}(u) = s\\,K_{\\text{cons}}(u)$, where $s \\in (0,1]$ is a prescribed scalar that artificially perturbs the true tangent. This models a common source of algorithmic inconsistency in practice.\n- Implement a line-search modified Newton method with the Armijo sufficient decrease rule on the merit function $\\phi(u)$, with standard parameters $c_1 \\in (0,1)$ and backtracking factor $\\beta \\in (0,1)$. Use $c_1 = 10^{-4}$ and $\\beta = 1/2$. Start each load step from the converged $u$ of the previous step and initialize the line search with $\\alpha_k = 1$ at each iteration.\n- For each load step, terminate Newton iterations once $|R(u;P)| \\le \\text{tol}$, with $\\text{tol} = 10^{-12}$. Impose a maximum of $50$ Newton iterations per load step and a maximum of $20$ backtracking reductions per iteration.\n- Record two metrics over an entire load path: the total number of backtracking reductions (i.e., the number of times $\\alpha$ is multiplied by $\\beta$ before accepting a step), and the rejection frequency defined as the ratio of the number of accepted updates with $\\alpha < 1$ to the total number of accepted updates over the load path. Both metrics are unitless.\n\nUse a load-controlled procedure with a linear ramp of the external load from $P = 0$ to a specified $P_{\\max}$ in $N_{\\text{inc}}$ equal increments. Use the previous converged solution as the initial guess for the next load step. The nonlinear stress model is monotone, but its tangent stiffness decreases along the path as $\\alpha$ increases, which provides a softening-type response without loss of monotonicity. This setting is crafted to reveal the impact of consistent versus inconsistent tangents on line-search behavior.\n\nTest Suite. Run the solver for the following four cases, each specified by the tuple $(\\alpha, P_{\\max}, N_{\\text{inc}}, s)$:\n- Case A (consistent tangent, softening path): $(10.0, 0.09, 5, 1.0)$.\n- Case B (inconsistent, moderate perturbation): $(10.0, 0.09, 5, 0.5)$.\n- Case C (inconsistent, severe perturbation): $(10.0, 0.09, 5, 0.1)$.\n- Case D (milder softening, inconsistent): $(3.0, 0.25, 5, 0.5)$.\n\nAll quantities are nondimensional; no physical units are required in the answer. Your program must output a single line containing the results as a comma-separated list enclosed in square brackets, aggregating the metrics in the order: $[\\text{backtracks}_A,\\text{rejection\\_freq}_A,\\text{backtracks}_B,\\text{rejection\\_freq}_B,\\text{backtracks}_C,\\text{rejection\\_freq}_C,\\text{backtracks}_D,\\text{rejection\\_freq}_D]$, where each $\\text{rejection\\_freq}$ must be printed as a decimal rounded to six digits after the decimal point, and each $\\text{backtracks}$ is an integer. For example, the required format is $[\\text{bA},\\text{fA},\\text{bB},\\text{fB},\\text{bC},\\text{fC},\\text{bD},\\text{fD}]$.\n\nThe correctness criteria are:\n- The consistent tangent $K_{\\text{cons}}$ must be derived from first principles for the given constitutive model.\n- The line-search Armijo rule must be implemented on the merit function $\\phi(u)$ using the directional derivative implied by the true Jacobian of $R$.\n- The reported metrics must reflect the total number of backtracking reductions and the rejection frequency over the entire load path for each case.", "solution": "The user requests the implementation of a line-search modified Newton method to solve a single-degree-of-freedom nonlinear equilibrium problem. The core task is to compare the performance of the solver when using a consistent tangent stiffness versus an inconsistent one. The performance is measured by the number of backtracking reductions and the frequency of step-size rejections during the line search.\n\nThe problem is first validated to be scientifically sound, well-posed, and objective. It represents a standard problem in computational solid mechanics and is specified with sufficient detail and consistency to admit a unique, verifiable solution.\n\nThe equilibrium of the one-dimensional bar is governed by the nonlinear scalar equation:\n$$\nR(u; P) = \\sigma(u) - P = 0\n$$\nwhere $u$ is the displacement, $P$ is the applied external load, and $\\sigma(u)$ is the stress given by the nonlinear constitutive law. With engineering strain $\\varepsilon = u$ and material modulus $E=1$, the stress function is:\n$$\n\\sigma(u) = \\frac{u}{1 + \\alpha u}\n$$\nHere, $\\alpha \\ge 0$ is a parameter controlling the material's softening response. The residual equation is therefore:\n$$\nR(u; P) = \\frac{u}{1 + \\alpha u} - P = 0\n$$\n\nThe solution is found using a Newton-Raphson iterative scheme. Given an estimate $u_k$ at iteration $k$, a better estimate $u_{k+1} = u_k + \\Delta u_k$ is sought. The correction $\\Delta u_k$ is found by solving the linearized system:\n$$\nK(u_k) \\Delta u_k = -R(u_k; P)\n$$\nwhere $K(u_k)$ is the tangent stiffness matrix (a scalar in this case) at $u_k$.\n\nA key aspect of the Newton method's quadratic convergence rate is the use of the **consistent tangent stiffness**, which is the exact derivative of the residual with respect to the unknown. We derive this as:\n$$\nK_{\\text{cons}}(u) = \\frac{d R(u; P)}{d u} = \\frac{d}{d u} \\left( \\frac{u}{1 + \\alpha u} \\right)\n$$\nUsing the quotient rule for differentiation, $(\\frac{f}{g})' = \\frac{f'g - fg'}{g^2}$, with $f(u) = u$ and $g(u) = 1 + \\alpha u$, we get $f'(u)=1$ and $g'(u)=\\alpha$.\n$$\nK_{\\text{cons}}(u) = \\frac{(1)(1 + \\alpha u) - (u)(\\alpha)}{(1 + \\alpha u)^2} = \\frac{1 + \\alpha u - \\alpha u}{(1 + \\alpha u)^2} = \\frac{1}{(1 + \\alpha u)^2}\n$$\nThe problem also requires implementing an **inconsistent tangent stiffness** to model practical algorithmic errors, defined as:\n$$\nK_{\\text{inc}}(u) = s \\cdot K_{\\text{cons}}(u) = \\frac{s}{(1 + \\alpha u)^2}\n$$\nwhere $s \\in (0, 1]$ is a perturbation factor. When $s \\neq 1$, the tangent stiffness $K(u_k) = K_{\\text{inc}}(u_k)$ is no longer the true derivative of the residual, which generally degrades the convergence rate of the pure Newton method.\n\nTo ensure global convergence, especially when far from the solution or when using an inconsistent tangent, the standard Newton step is modified with a line search. The update is given by $u_{k+1} = u_k + \\alpha_k \\Delta u_k$, where $\\alpha_k \\in (0, 1]$ is a step size parameter determined by a backtracking line search. The search aims to find an $\\alpha_k$ that provides sufficient decrease in a merit function, chosen here as:\n$$\n\\phi(u) = \\frac{1}{2} R(u; P)^2\n$$\nThe search direction $\\Delta u_k = -R(u_k;P)/K(u_k)$ is a descent direction for $\\phi(u)$ as long as the directional derivative is negative. The directional derivative of $\\phi$ at $u_k$ along $\\Delta u_k$ is:\n$$\nD\\phi(u_k)[\\Delta u_k] = \\nabla\\phi(u_k)^T \\Delta u_k = \\left(\\frac{d\\phi}{du}\\right)_{u_k} \\Delta u_k\n$$\nThe gradient of the merit function is $\\frac{d\\phi}{du} = \\frac{d}{du}(\\frac{1}{2}R^2) = R \\frac{dR}{du} = R \\cdot K_{\\text{cons}}$. Thus,\n$$\nD\\phi(u_k)[\\Delta u_k] = R(u_k) K_{\\text{cons}}(u_k) \\Delta u_k = R(u_k) K_{\\text{cons}}(u_k) \\left(-\\frac{R(u_k)}{K(u_k)}\\right) = -[R(u_k)]^2 \\frac{K_{\\text{cons}}(u_k)}{K(u_k)}\n$$\nSubstituting $K(u_k) = s \\cdot K_{\\text{cons}}(u_k)$, the directional derivative becomes:\n$$\nD\\phi(u_k)[\\Delta u_k] = -\\frac{[R(u_k)]^2}{s}\n$$\nSince $s>0$ and $[R(u_k)]^2 \\ge 0$, the directional derivative is always non-positive, confirming that $\\Delta u_k$ is a descent direction for the merit function $\\phi$.\n\nThe backtracking algorithm uses the **Armijo condition** to accept a step. Starting with $\\alpha_k = 1$, we check if:\n$$\n\\phi(u_k + \\alpha_k \\Delta u_k) \\le \\phi(u_k) + c_1 \\alpha_k D\\phi(u_k)[\\Delta u_k]\n$$\nwith $c_1 = 10^{-4}$. If the condition is not met, the step size is reduced by a factor $\\beta = 1/2$, i.e., $\\alpha_k \\leftarrow \\beta \\alpha_k$, and the check is repeated. Each such reduction is counted as a \"backtrack\".\n\nThe overall algorithm proceeds as follows for each test case:\n1.  Initialize the converged displacement $u_{\\text{conv}} = 0$ and the performance metrics (total backtracks, etc.) to zero.\n2.  Loop through $N_{\\text{inc}}$ load increments from $P = P_{\\max}/N_{\\text{inc}}$ to $P=P_{\\max}$.\n3.  For each load $P$, start a Newton loop with initial guess $u = u_{\\text{conv}}$.\n4.  Inside the Newton loop, compute the residual $R(u;P)$. If $|R| \\le \\text{tol}=10^{-12}$, the step has converged. Store the new $u_{\\text{conv}}$ and proceed to the next load increment.\n5.  If not converged, compute the tangent $K(u)$ (consistent or inconsistent based on $s$) and the search direction $\\Delta u$.\n6.  Perform the backtracking line search to find an acceptable step size $\\alpha_k$, starting with $\\alpha_k=1$. Count the number of reductions.\n7.  Update the displacement $u \\leftarrow u + \\alpha_k \\Delta u$.\n8.  Record metrics: increment the total number of updates. If $\\alpha_k < 1$, increment the count of rejected full steps.\n9.  Repeat the Newton loop until convergence or max iterations.\n10. After all load steps, calculate the final rejection frequency and return the total backtracks and this frequency.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test cases and print results.\n    \"\"\"\n    \n    def run_solver(alpha_mat, P_max, N_inc, s):\n        \"\"\"\n        Solves the 1D nonlinear problem for a single parameter set.\n\n        Args:\n            alpha_mat (float): Material parameter for softening.\n            P_max (float): Maximum applied load.\n            N_inc (int): Number of load increments.\n            s (float): Inconsistency factor for the tangent stiffness.\n\n        Returns:\n            tuple: A tuple containing:\n                - total_backtracks (int): Total number of backtracking reductions.\n                - rejection_freq (float): Ratio of updates with alpha < 1 to total updates.\n        \"\"\"\n        # --- Solver Parameters ---\n        c1 = 1e-4\n        beta = 0.5\n        tol = 1e-12\n        max_newton_iter = 50\n        max_backtrack_iter = 20\n\n        # --- State and Metrics Initialization ---\n        u_converged = 0.0\n        total_backtracks = 0\n        updates_with_alpha_lt_1 = 0\n        total_updates = 0\n\n        # --- Load Stepping ---\n        load_increments = np.linspace(P_max / N_inc, P_max, N_inc)\n\n        for P in load_increments:\n            u = u_converged  # Initial guess from previous converged step\n\n            for k in range(max_newton_iter):\n                # --- Calculate Residual ---\n                # Based on sigma(u) = u / (1 + alpha_mat * u)\n                # Denominator is always positive for u>=0 and alpha_mat>=0.\n                R_u = u / (1.0 + alpha_mat * u) - P\n\n                # --- Check for Convergence ---\n                if abs(R_u) <= tol:\n                    break\n\n                # --- Calculate Tangent Stiffness and Search Direction ---\n                K_cons_u = 1.0 / (1.0 + alpha_mat * u)**2\n                K_u = s * K_cons_u\n                \n                # Safeguard against singular tangent (unlikely for this problem)\n                if abs(K_u) < 1e-20:\n                    # Could indicate a limit point or error, break iteration\n                    break\n                    \n                delta_u = -R_u / K_u\n\n                # --- Line Search (Armijo Backtracking) ---\n                alpha_step = 1.0\n                num_backtracks_this_iter = 0\n                \n                phi_u = 0.5 * R_u**2\n                \n                # Directional derivative of the merit function phi\n                # D(phi)[delta_u] = -R^2 * K_cons/K = -R^2/s\n                slope = -R_u**2 / s\n\n                for _ in range(max_backtrack_iter):\n                    u_trial = u + alpha_step * delta_u\n                    \n                    # The trial step should not lead to non-physical strain\n                    # 1 + alpha_mat * u_trial must be > 0.\n                    # Since u >= 0 and P >= 0, this is not an issue.\n                    \n                    R_trial = u_trial / (1.0 + alpha_mat * u_trial) - P\n                    phi_trial = 0.5 * R_trial**2\n\n                    # Armijo sufficient decrease condition\n                    if phi_trial <= phi_u + c1 * alpha_step * slope:\n                        break  # Sufficient decrease, accept step\n                    else:\n                        # Condition failed, backtrack\n                        alpha_step *= beta\n                        num_backtracks_this_iter += 1\n                else:\n                    # Max backtracking iterations reached, may indicate failure to find a step.\n                    # For this problem, we proceed with the last attempted step and hope the\n                    # next Newton iteration can recover.\n                    break \n                \n                # --- Update State and Metrics ---\n                u = u_trial\n                total_updates += 1\n                total_backtracks += num_backtracks_this_iter\n                if alpha_step < 1.0:\n                    updates_with_alpha_lt_1 += 1\n\n            # Store converged solution for the next load step\n            u_converged = u\n        \n        # --- Final Metric Calculation ---\n        if total_updates == 0:\n            rejection_freq = 0.0\n        else:\n            rejection_freq = updates_with_alpha_lt_1 / total_updates\n            \n        return total_backtracks, rejection_freq\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Parameter set 1: alpha, P_max, N_inc, s)\n        (10.0, 0.09, 5, 1.0),  # Case A\n        (10.0, 0.09, 5, 0.5),  # Case B\n        (10.0, 0.09, 5, 0.1),  # Case C\n        (3.0, 0.25, 5, 0.5),   # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha_val, p_max_val, n_inc_val, s_val = case\n        backtracks, rej_freq = run_solver(alpha_val, p_max_val, n_inc_val, s_val)\n        results.append(str(backtracks))\n        results.append(f\"{rej_freq:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3552105"}]}