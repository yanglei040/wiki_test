{"hands_on_practices": [{"introduction": "This exercise tackles a core kinematic concept in axisymmetric analysis: the hoop strain. By deriving the expression for $\\varepsilon_{\\theta\\theta}$ directly from the finite element displacement interpolation, you will solidify your understanding of how continuum principles are discretized. The practice further challenges you to address the apparent mathematical singularity at the axis of rotation ($r=0$), a critical step for developing a physically meaningful and numerically robust formulation [@problem_id:3545424].", "problem": "Consider an isoparametric axisymmetric quadrilateral finite element in cylindrical coordinates with radial coordinate $r$ and axial coordinate $z$. The displacement field is axisymmetric (no dependence on the circumferential angle), and the small-strain tensor is assumed valid. The discrete kinematic interpolation within the element is\n$$\nu_r(r,z) = \\sum_{i=1}^{n} N_i(r,z)\\,u_{ri},\\qquad\nu_z(r,z) = \\sum_{i=1}^{n} N_i(r,z)\\,u_{zi},\n$$\nwhere $N_i$ are the shape functions, $u_{ri}$ and $u_{zi}$ are the nodal radial and axial displacement degrees of freedom, and $n$ is the number of nodes. Let $(r_g,z_g)$ denote a Gauss point in the physical element with radius $r_g \\ge 0$.\n\nStarting from the definition of the small-strain tensor in cylindrical coordinates and the axisymmetric kinematic assumptions, derive the hoop (circumferential) strain component $\\varepsilon_{\\theta\\theta}$ at the Gauss point $(r_g,z_g)$ in terms of $N_i$, $u_{ri}$, and $r_g$. Carefully justify each step using fundamental continuum kinematics in cylindrical coordinates and the provided displacement interpolation. Then, discuss how to handle the apparent $1/r$ singularity in $\\varepsilon_{\\theta\\theta}$ as $r_g \\to 0$ to obtain a finite, well-defined limit at the axis, and derive the corresponding limiting expression in terms of $N_i$ and their derivatives with respect to $r$.\n\nProvide your final answer as a single symbolic expression for $\\varepsilon_{\\theta\\theta}$ at a general Gauss point with $r_g0$. Since the final answer is symbolic, no rounding is required. Strain is dimensionless; do not include units in the final answer.", "solution": "**Problem Validation**\n\n**Step 1: Extract Givens**\n- Coordinate System: Cylindrical coordinates with radial coordinate $r$ and axial coordinate $z$.\n- Element Type: Isoparametric axisymmetric quadrilateral finite element.\n- Kinematic Assumption: The displacement field is axisymmetric, with no dependence on the circumferential angle.\n- Strain Assumption: The small-strain tensor is valid.\n- Discrete Kinematic Interpolation:\n  $$u_r(r,z) = \\sum_{i=1}^{n} N_i(r,z)\\,u_{ri}$$\n  $$u_z(r,z) = \\sum_{i=1}^{n} N_i(r,z)\\,u_{zi}$$\n- Definitions: $N_i$ are the shape functions, $u_{ri}$ and $u_{zi}$ are the nodal radial and axial displacement degrees of freedom, $n$ is the number of nodes.\n- Evaluation Point: A Gauss point $(r_g, z_g)$ in the physical element with radius $r_g \\ge 0$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem statement is evaluated based on the established criteria.\n- **Scientifically Grounded**: The problem is firmly rooted in the classical theory of continuum mechanics and the finite element method, specifically for axisymmetric analysis. The concepts of strain-displacement relations in cylindrical coordinates and isoparametric interpolation are standard and rigorously defined in computational solid mechanics.\n- **Well-Posed**: The problem is well-posed. It asks for the derivation of a specific quantity (hoop strain) based on a complete set of provided definitions and assumptions. The second part of the question, regarding the singularity at the axis of symmetry, is a standard and well-understood topic in axisymmetric formulations, for which a unique and meaningful limiting value exists.\n- **Objective**: The problem is stated in precise, objective, and quantitative terms. All terms are standard within the field and free of ambiguity or subjective interpretation.\n\nThe problem does not exhibit any of the flaws listed for invalidity. It is scientifically sound, formally structured, complete, and poses a meaningful question within its specified domain.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A complete, reasoned solution will be provided.\n\n**Solution Derivation**\n\nThe objective is to derive the expression for the hoop (circumferential) strain component, $\\varepsilon_{\\theta\\theta}$, at a Gauss point $(r_g, z_g)$, and to analyze its behavior as the radial coordinate approaches zero.\n\nFirst, we recall the small-strain tensor components in a cylindrical coordinate system $(r, \\theta, z)$. The displacement vector is $\\mathbf{u} = u_r(r,z) \\mathbf{e}_r + u_z(r,z) \\mathbf{e}_z$, where the axisymmetric assumption implies that the displacements do not depend on the circumferential coordinate $\\theta$, and the circumferential displacement component $u_\\theta$ is zero. The strain-displacement relations are given by:\n$$ \\varepsilon_{rr} = \\frac{\\partial u_r}{\\partial r} $$\n$$ \\varepsilon_{zz} = \\frac{\\partial u_z}{\\partial z} $$\n$$ \\varepsilon_{\\theta\\theta} = \\frac{1}{r}\\frac{\\partial u_\\theta}{\\partial \\theta} + \\frac{u_r}{r} $$\n$$ \\varepsilon_{rz} = \\frac{1}{2}\\left( \\frac{\\partial u_r}{\\partial z} + \\frac{\\partial u_z}{\\partial r} \\right) $$\nThe other shear strain components, $\\varepsilon_{r\\theta}$ and $\\varepsilon_{z\\theta}$, are zero due to the axisymmetric assumption ($u_\\theta=0$ and $\\partial/\\partial\\theta=0$).\n\nWe are interested in the hoop strain, $\\varepsilon_{\\theta\\theta}$. The general expression is $\\varepsilon_{\\theta\\theta} = \\frac{1}{r}\\frac{\\partial u_\\theta}{\\partial \\theta} + \\frac{u_r}{r}$. Applying the axisymmetric assumption, the circumferential displacement $u_\\theta$ is zero. Consequently, its derivative with respect to $\\theta$ is also zero. This simplifies the expression for the hoop strain to:\n$$ \\varepsilon_{\\theta\\theta} = \\frac{u_r}{r} $$\nThis equation expresses a fundamental kinematic relationship in axisymmetric problems: the hoop strain at a point is equal to the radial displacement at that point divided by its radial coordinate.\n\nNext, we introduce the finite element discretization for the radial displacement $u_r$. As given in the problem statement, the displacement within an element is interpolated from the nodal displacements using shape functions $N_i$:\n$$ u_r(r,z) = \\sum_{i=1}^{n} N_i(r,z)\\,u_{ri} $$\nwhere $n$ is the number of nodes in the element, $u_{ri}$ are the nodal values of the radial displacement, and $N_i(r,z)$ are the shape functions.\n\nTo find the hoop strain at the specified Gauss point $(r_g, z_g)$, we substitute the interpolated displacement field into the kinematic relation for $\\varepsilon_{\\theta\\theta}$ and evaluate the expression at this point. Assuming $r_g > 0$, we have:\n$$ \\varepsilon_{\\theta\\theta}(r_g, z_g) = \\frac{u_r(r_g, z_g)}{r_g} $$\nSubstituting the expression for $u_r(r_g, z_g)$:\n$$ \\varepsilon_{\\theta\\theta}(r_g, z_g) = \\frac{1}{r_g} \\left( \\sum_{i=1}^{n} N_i(r_g, z_g)\\,u_{ri} \\right) $$\nThis is the expression for the hoop strain at a general point $(r_g, z_g)$ with a non-zero radius.\n\nNow, we address the second part of the problem: the behavior as $r_g \\to 0$. The expression $\\varepsilon_{\\theta\\theta} = u_r/r$ has an apparent singularity at $r=0$. However, physical continuity requires that a point on the axis of revolution ($r=0$) cannot have a non-zero radial displacement, as this would create a void or material self-penetration. Therefore, a physical constraint exists:\n$$ u_r(0, z) = 0 \\quad \\text{for all } z $$\nIn the context of the finite element model, this means for any element that has nodes on the axis of symmetry, the radial displacement degrees of freedom $u_{ri}$ for those specific nodes $i$ must be constrained to zero. With this constraint, the interpolated radial displacement $u_r(r,z)$ approaches zero as $r \\to 0$.\n\nThus, the limit of $\\varepsilon_{\\theta\\theta}$ as $r \\to 0$ becomes an indeterminate form of the type $0/0$:\n$$ \\lim_{r \\to 0} \\varepsilon_{\\theta\\theta}(r, z) = \\lim_{r \\to 0} \\frac{u_r(r, z)}{r} $$\nWe can evaluate this limit using L'Hôpital's rule, by differentiating the numerator and the denominator with respect to $r$:\n$$ \\lim_{r \\to 0} \\frac{u_r(r, z)}{r} = \\lim_{r \\to 0} \\frac{\\frac{\\partial u_r}{\\partial r}(r,z)}{\\frac{\\partial r}{\\partial r}} = \\lim_{r \\to 0} \\frac{\\partial u_r}{\\partial r}(r,z) = \\frac{\\partial u_r}{\\partial r}\\bigg|_{r=0} $$\nFrom the strain-displacement relations, we recognize that $\\frac{\\partial u_r}{\\partial r}$ is the radial strain component, $\\varepsilon_{rr}$. Therefore, at the axis of symmetry, the hoop strain is equal to the radial strain:\n$$ \\varepsilon_{\\theta\\theta}(0, z) = \\varepsilon_{rr}(0, z) $$\nThis is a required condition for strain compatibility at the axis of symmetry.\n\nTo find the limiting expression in terms of the finite element quantities, we first compute the derivative of the interpolated displacement field with respect to $r$:\n$$ \\frac{\\partial u_r}{\\partial r}(r,z) = \\frac{\\partial}{\\partial r} \\left( \\sum_{i=1}^{n} N_i(r,z)\\,u_{ri} \\right) = \\sum_{i=1}^{n} \\frac{\\partial N_i}{\\partial r}(r,z)\\,u_{ri} $$\nEvaluating this expression at a point on the axis of symmetry, $(0, z_g)$, gives the limiting value of the hoop strain:\n$$ \\lim_{r_g \\to 0} \\varepsilon_{\\theta\\theta}(r_g, z_g) = \\left( \\sum_{i=1}^{n} \\frac{\\partial N_i}{\\partial r}(r,z)\\,u_{ri} \\right)\\bigg|_{(r=0, z=z_g)} = \\sum_{i=1}^{n} \\frac{\\partial N_i}{\\partial r}(0, z_g)\\,u_{ri} $$\nThis expression is finite and well-defined, resolving the apparent singularity. For practical computation at a Gauss point located exactly on the axis, this latter formula is used. For any Gauss point with $r_g > 0$, the former expression is used.\n\nThe problem asks for the single symbolic expression for $\\varepsilon_{\\theta\\theta}$ at a general Gauss point with $r_g > 0$. This corresponds to the first part of our derivation.", "answer": "$$\n\\boxed{\\frac{1}{r_g} \\sum_{i=1}^{n} N_i(r_g, z_g)\\,u_{ri}}\n$$", "id": "3545424"}, {"introduction": "Ensuring the correctness of a finite element code is paramount, and patch tests are a powerful tool for verification. This practice focuses on a unique feature of axisymmetric models: the $2\\pi r$ weighting within the volume integral used to calculate strain energy. You will design a numerical experiment to compare several strategies for implementing this term and see how common mistakes, such as omitting the radius or the $2\\pi$ factor, lead to predictable errors in the total energy [@problem_id:3545418].", "problem": "You are to write a complete, runnable program that evaluates and compares three mathematically equivalent strategies for incorporating the $2\\pi$ factor in axisymmetric finite element (FE) computations, and to design a patch test whose energy scaling reveals implementation inconsistencies. The physical context is an axisymmetric, isotropic, linearly elastic solid under a kinematically imposed patch test displacement field. The fundamental basis must be the Principle of Virtual Work and three-dimensional isotropic linear elasticity. The program must build a single bilinear quadrilateral axisymmetric element patch and use two-point Gaussian quadrature in each natural coordinate. The patch test displacement field is uniform $u_r = \\alpha r$, $u_z = 0$, producing constant strains. The energy density must be derived from three-dimensional isotropic linear elasticity using Lamé parameters. Numerical integration must include the axisymmetric volume factor. Three strategies to incorporate $2\\pi$ must be implemented and compared:\n- Global scaling: assemble the area integral with radius weighting and multiply the total by $2\\pi$ at the end.\n- Element-level scaling: multiply by $2\\pi$ within each element’s integration loop.\n- Embedded in quadrature weights: include $2\\pi r$ directly in the quadrature weights at each Gaussian point.\n\nYou must also implement intentionally inconsistent variants to reveal energy scaling errors:\n- Missing $2\\pi$ factor.\n- Missing radius weighting $r$ in the axisymmetric measure.\n- Double application of the $2\\pi$ factor.\n\nThe derivation must start from the following fundamental laws and core definitions:\n- The Principle of Virtual Work states that the internal virtual work equals the external virtual work for admissible virtual displacements. For the present kinematic patch, the internal energy is $W = \\int_V \\tfrac{1}{2}\\boldsymbol{\\sigma}:\\boldsymbol{\\varepsilon}\\,\\mathrm{d}V$.\n- For isotropic linear elasticity, the stress-strain relation in three dimensions is $\\boldsymbol{\\sigma} = \\lambda \\operatorname{tr}(\\boldsymbol{\\varepsilon})\\mathbf{I} + 2\\mu \\boldsymbol{\\varepsilon}$, where $\\lambda$ and $\\mu$ are the Lamé parameters expressed in terms of Young’s modulus $E$ and Poisson’s ratio $\\nu$ as $\\lambda = \\dfrac{E\\nu}{(1+\\nu)(1-2\\nu)}$ and $\\mu = \\dfrac{E}{2(1+\\nu)}$.\n- For axisymmetry, the volume integral reduces to an area integral with the axisymmetric factor, $\\mathrm{d}V = 2\\pi r\\,\\mathrm{d}A$, so $W = \\int_A \\tfrac{1}{2}\\boldsymbol{\\sigma}:\\boldsymbol{\\varepsilon}\\,(2\\pi r)\\,\\mathrm{d}A$.\n\nThe bilinear quadrilateral element is defined over natural coordinates $(\\xi,\\eta)\\in[-1,1]\\times[-1,1]$ with standard bilinear shape functions. The patch test displacement field $u_r=\\alpha r$, $u_z=0$ produces constant strains $\\varepsilon_r=\\alpha$, $\\varepsilon_\\theta=\\alpha$, $\\varepsilon_z=0$, $\\gamma_{rz}=0$. With these, the energy density becomes a constant that your program must compute from the material parameters. The program must then numerically integrate the energy over the element using the three correct strategies and the three inconsistent strategies defined above. The correct strategies must yield identical energies equal to the analytic energy derived from the fundamental basis, and the inconsistent strategies must deviate in ways that reveal incorrect scaling with geometry.\n\nThe material and kinematic parameters are:\n- Young’s modulus $E = 210\\times 10^{9}$ in pascals.\n- Poisson’s ratio $\\nu = 0.30$.\n- Patch test parameter $\\alpha = 1.0\\times 10^{-3}$, dimensionless.\n\nConstruct a single bilinear quadrilateral element for each test case with nodal coordinates $(r,z)$ ordered counterclockwise starting from the lower-left corner:\n- Node $1$: $(r_1,z_1)$.\n- Node $2$: $(r_2,z_1)$.\n- Node $3$: $(r_2,z_2)$.\n- Node $4$: $(r_1,z_2)$.\nTake the axial length to be $L = z_2 - z_1$.\n\nProvide the following test suite to exercise different facets of the implementation:\n- Test case $1$ (happy path, includes the axis): $r_1 = 0.0$ in meters, $r_2 = 1.0$ in meters, $L = 2.0$ in meters.\n- Test case $2$ (moderate annulus): $r_1 = 0.5$ in meters, $r_2 = 1.0$ in meters, $L = 2.0$ in meters.\n- Test case $3$ (thin annulus at large radius): $r_1 = 0.95$ in meters, $r_2 = 1.0$ in meters, $L = 2.0$ in meters.\n\nFor each test case, your program must compute:\n- The total strain energy using the three correct strategies and the analytic energy based on the derived constant energy density and exact axisymmetric area integral. All energies must be expressed in joules.\n- The maximum relative error among the three correct strategies compared to the analytic energy, dimensionless.\n- The ratios of the inconsistent energies to the analytic energy for the three inconsistent variants, dimensionless.\n\nAdditionally, evaluate energy scaling across geometries using one correct strategy by comparing energy ratios to the expected analytic scaling with geometry. Specifically, compute for test case $i$ relative scaling error with respect to test case $1$:\n$$\n\\delta_i = \\frac{\\dfrac{W_i}{W_1} - \\dfrac{r_{2,i}^2 - r_{1,i}^2}{r_{2,1}^2 - r_{1,1}^2}}{\\dfrac{r_{2,i}^2 - r_{1,i}^2}{r_{2,1}^2 - r_{1,1}^2}},\n$$\nfor $i\\in\\{2,3\\}$, where $W_i$ is the correct total energy and $r_{1,i},r_{2,i}$ are the radii of test case $i$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must aggregate, in order, for each test case $i\\in\\{1,2,3\\}$:\n- $W^{\\mathrm{global}}_i$ in joules,\n- $W^{\\mathrm{element}}_i$ in joules,\n- $W^{\\mathrm{weights}}_i$ in joules,\n- $W^{\\mathrm{analytic}}_i$ in joules,\n- $\\varepsilon^{\\mathrm{rel}}_i$ (maximum relative error of the three correct strategies against analytic),\n- $\\rho^{\\mathrm{no2\\pi}}_i$ (ratio of missing-$2\\pi$ energy to analytic),\n- $\\rho^{\\mathrm{nor}}_i$ (ratio of missing-$r$ energy to analytic),\n- $\\rho^{\\mathrm{double2\\pi}}_i$ (ratio of double-$2\\pi$ energy to analytic),\nfollowed by the two scaling errors $\\delta_2$ and $\\delta_3$ defined above, dimensionless. Express all energies in joules, and express all ratios and errors as decimal numbers without percentage signs. Angles are not involved in this problem. The outputs must be in the exact order specified and the final print must contain only the single line with the aggregated list.", "solution": "The problem requires the development and validation of a finite element (FE) program for an axisymmetric solid mechanics problem. The task is to evaluate three mathematically equivalent strategies for incorporating the $2\\pi$ factor essential to axisymmetric analysis, alongside three intentionally flawed strategies, to demonstrate how a properly designed patch test can reveal implementation errors.\n\nFirst, we establish the analytical foundation based on the provided principles. The problem concerns an isotropic, linearly elastic solid undergoing a prescribed displacement field $u_r = \\alpha r$ and $u_z = 0$.\nThe strain components in a cylindrical coordinate system $(r, \\theta, z)$ are derived from the displacement field:\n$$ \\varepsilon_r = \\frac{\\partial u_r}{\\partial r} = \\frac{\\partial (\\alpha r)}{\\partial r} = \\alpha $$\n$$ \\varepsilon_\\theta = \\frac{u_r}{r} = \\frac{\\alpha r}{r} = \\alpha $$\n$$ \\varepsilon_z = \\frac{\\partial u_z}{\\partial z} = \\frac{\\partial (0)}{\\partial z} = 0 $$\n$$ \\gamma_{rz} = \\frac{\\partial u_r}{\\partial z} + \\frac{\\partial u_z}{\\partial r} = \\frac{\\partial (\\alpha r)}{\\partial z} + \\frac{\\partial (0)}{\\partial r} = 0 $$\nThe strain tensor is therefore constant throughout the body, given by the vector $\\boldsymbol{\\varepsilon} = [\\alpha, \\alpha, 0, 0]^T$.\n\nThe stress-strain relationship for an isotropic linear elastic material is given by $\\boldsymbol{\\sigma} = \\lambda \\operatorname{tr}(\\boldsymbol{\\varepsilon})\\mathbf{I} + 2\\mu \\boldsymbol{\\varepsilon}$, where $\\lambda$ and $\\mu$ are the Lamé parameters. The trace of the strain tensor is $\\operatorname{tr}(\\boldsymbol{\\varepsilon}) = \\varepsilon_r + \\varepsilon_\\theta + \\varepsilon_z = \\alpha + \\alpha + 0 = 2\\alpha$.\nThe stress components are thus:\n$$ \\sigma_r = \\lambda(2\\alpha) + 2\\mu(\\alpha) = (2\\lambda + 2\\mu)\\alpha $$\n$$ \\sigma_\\theta = \\lambda(2\\alpha) + 2\\mu(\\alpha) = (2\\lambda + 2\\mu)\\alpha $$\n$$ \\sigma_z = \\lambda(2\\alpha) + 2\\mu(0) = 2\\lambda\\alpha $$\n$$ \\tau_{rz} = \\mu \\gamma_{rz} = 0 $$\nThe stress tensor is also constant.\n\nThe strain energy density $U$ is given by $U = \\frac{1}{2}\\boldsymbol{\\sigma}:\\boldsymbol{\\varepsilon} = \\frac{1}{2}(\\sigma_r\\varepsilon_r + \\sigma_\\theta\\varepsilon_\\theta + \\sigma_z\\varepsilon_z + \\tau_{rz}\\gamma_{rz})$.\nSubstituting the derived strains and stresses:\n$$ U = \\frac{1}{2} [ (2\\lambda + 2\\mu)\\alpha^2 + (2\\lambda + 2\\mu)\\alpha^2 + 0 + 0 ] = (2\\lambda + 2\\mu)\\alpha^2 $$\nExpressing the Lamé parameters in terms of Young's modulus $E$ and Poisson's ratio $\\nu$, we find the combination $(2\\lambda + 2\\mu)$ simplifies to $\\frac{E}{(1+\\nu)(1-2\\nu)}$.\nThus, the strain energy density is a constant:\n$$ U_{const} = \\frac{E \\alpha^2}{(1+\\nu)(1-2\\nu)} $$\nThe total strain energy $W$ is the integral of the energy density over the volume $V$. For an axisymmetric body, the differential volume element is $\\mathrm{d}V = 2\\pi r\\,\\mathrm{d}A$, where $\\mathrm{d}A = \\mathrm{d}r\\,\\mathrm{d}z$.\n$$ W^{\\mathrm{analytic}} = \\int_V U_{const} \\,\\mathrm{d}V = U_{const} \\int_A 2\\pi r \\,\\mathrm{d}A $$\nFor a rectangular cross-section defined by $r \\in [r_1, r_2]$ and $z \\in [z_1, z_2]$ with length $L = z_2 - z_1$:\n$$ W^{\\mathrm{analytic}} = U_{const} \\cdot 2\\pi \\int_{z_1}^{z_2} \\int_{r_1}^{r_2} r \\,\\mathrm{d}r\\,\\mathrm{d}z = U_{const} \\cdot 2\\pi \\cdot L \\cdot \\left[\\frac{r^2}{2}\\right]_{r_1}^{r_2} $$\n$$ W^{\\mathrm{analytic}} = U_{const} \\cdot \\pi L (r_2^2 - r_1^2) $$\nThis provides the exact analytical solution against which the numerical results will be validated.\n\nNext, we design the numerical FE model. A single four-node bilinear quadrilateral element is used, with nodes at $(r_1, z_1)$, $(r_2, z_1)$, $(r_2, z_2)$, and $(r_1, z_2)$. In the natural coordinate system $(\\xi, \\eta) \\in [-1, 1] \\times [-1, 1]$, the geometry is mapped as $r(\\xi, \\eta) = \\sum N_i(\\xi, \\eta) r_i$ and $z(\\xi, \\eta) = \\sum N_i(\\xi, \\eta) z_i$. For the rectangular element geometry, this simplifies to $r(\\xi) = \\frac{1}{2}(1-\\xi)r_1 + \\frac{1}{2}(1+\\xi)r_2$ and $z(\\eta) = \\frac{1}{2}(1-\\eta)z_1 + \\frac{1}{2}(1+\\eta)z_2$.\nThe Jacobian of this transformation is a constant diagonal matrix, $\\mathbf{J} = \\mathrm{diag}(\\frac{r_2-r_1}{2}, \\frac{L}{2})$, so its determinant is $\\det(\\mathbf{J}) = \\frac{(r_2-r_1)L}{4}$.\nThe prescribed displacement field $u_r = \\alpha r$ can be represented exactly by setting the nodal displacements to $d_{ri} = \\alpha r_i$ and $d_{zi} = 0$. This is a key feature of a patch test: the FE interpolation $u_r(\\xi, \\eta) = \\sum N_i d_{ri} = \\sum N_i (\\alpha r_i) = \\alpha \\sum N_i r_i = \\alpha r(\\xi, \\eta)$ perfectly reproduces the analytical field. Consequently, the strains computed within the element are guaranteed to be constant and correct, matching the analytical derivation.\n\nThe numerical integration of the total energy is performed using $2 \\times 2$ Gaussian quadrature. The energy integral is:\n$$ W = \\int_{-1}^{1}\\int_{-1}^{1} U_{const} \\cdot (2\\pi r(\\xi, \\eta)) \\cdot \\det(\\mathbf{J}) \\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta $$\nThe quadrature approximation is a weighted sum over the Gauss points $(\\xi_k, \\eta_k)$:\n$$ W \\approx \\sum_{k=1}^{4} w_k \\cdot U_{const} \\cdot (2\\pi r(\\xi_k, \\eta_k)) \\cdot \\det(\\mathbf{J}) $$\nThe integrand term $r(\\xi) \\det(\\mathbf{J})$ is a linear function of $\\xi$ and constant with respect to $\\eta$. A $2$-point Gaussian quadrature rule is exact for polynomials of degree up to $2(2)-1 = 3$. Therefore, the numerical integration of the energy is exact for this problem, and the computed numerical energy for any correct strategy must equal the analytical energy up to floating-point precision.\n\nThe algorithmic implementation will compute the total energy using six strategies:\n1.  **$W^{\\mathrm{global}}$ (Correct)**: The area integral $\\int_A U_{const} \\cdot r \\,\\mathrm{d}A$ is computed numerically. The result is multiplied by $2\\pi$ at the end.\n2.  **$W^{\\mathrm{element}}$ (Correct)**: For a single element, this is identical to the global strategy. The factor $2\\pi$ is applied after the element's quadrature sum is completed.\n3.  **$W^{\\mathrm{weights}}$ (Correct)**: The factor $2\\pi r$ is included in the integrand at each Gauss point, effectively modifying the quadrature \"weight\" to $w_k \\cdot (2\\pi r_k) \\cdot \\det(\\mathbf{J})$.\nThese three methods are mathematically equivalent and must produce identical results.\n\nThe three inconsistent variants are designed to expose common implementation errors:\n4.  **$W^{\\mathrm{no2\\pi}}$ (Incorrect)**: The $2\\pi$ factor is omitted entirely. The computed energy will be $W^{\\mathrm{analytic}} / (2\\pi)$.\n5.  **$W^{\\mathrm{nor}}$ (Incorrect)**: The radius weighting $r$ is omitted from the axisymmetric measure, which becomes $2\\pi\\,\\mathrm{d}A$ instead of $2\\pi r\\,\\mathrm{d}A$. The energy is $W = \\int_A U_{const} (2\\pi) \\mathrm{d}A = U_{const} \\cdot 2\\pi \\cdot \\text{Area} = U_{const} \\cdot 2\\pi L (r_2-r_1)$. The ratio to the analytic energy is $\\rho^{\\mathrm{nor}} = \\frac{2\\pi L (r_2-r_1)}{\\pi L (r_2^2-r_1^2)} = \\frac{2}{r_1+r_2}$, which is geometry-dependent.\n6.  **$W^{\\mathrm{double2\\pi}}$ (Incorrect)**: The $2\\pi$ factor is applied twice, e.g., by embedding it in the quadrature and then applying it globally. The result is $2\\pi \\cdot W^{\\mathrm{analytic}}$.\n\nThe program will execute these calculations for three test geometries to probe different regimes: a solid cylinder ($r_1=0$), a moderate annulus, and a thin annulus. It will report the energies, the relative error of correct methods against the analytic solution, and the ratios of incorrect energies to the analytic one. Finally, it calculates a relative scaling error $\\delta_i$ to verify that the energy ratio between different geometries matches the analytical prediction $W_i/W_1 = (r_{2,i}^2 - r_{1,i}^2) / (r_{2,1}^2 - r_{1,1}^2)$. Due to the exactness of the numerical integration, this error should be zero.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Evaluates and compares strategies for incorporating the 2*pi factor in\n    axisymmetric finite element computations using a patch test.\n    \"\"\"\n    # Define material and kinematic parameters\n    E = 210e9  # Young's modulus in Pascals\n    nu = 0.30  # Poisson's ratio\n    alpha = 1.0e-3  # Patch test displacement parameter\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (r1_meters, r2_meters, L_meters)\n    test_cases = [\n        (0.0, 1.0, 2.0),\n        (0.5, 1.0, 2.0),\n        (0.95, 1.0, 2.0),\n    ]\n\n    # Pre-calculate constant terms\n    # Constant strain energy density U_const\n    U_const = (E / ((1 + nu) * (1 - 2 * nu))) * alpha**2\n\n    # Gaussian quadrature points and weights for 2x2 integration\n    gp_loc = 1.0 / np.sqrt(3.0)\n    gauss_points = [(-gp_loc, -gp_loc), (gp_loc, -gp_loc),\n                    (gp_loc, gp_loc), (-gp_loc, gp_loc)]\n    gauss_weights = [1.0, 1.0, 1.0, 1.0]\n\n    all_results = []\n    correct_energies_for_scaling = []\n\n    # Process each test case\n    for r1, r2, L in test_cases:\n        # --- Analytic Solution ---\n        # W_analytic = U_const * pi * L * (r2^2 - r1^2)\n        W_analytic = U_const * np.pi * L * (r2**2 - r1**2)\n\n        # --- Numerical Integration (FEA) ---\n        # For a rectangular element, the Jacobian determinant is constant.\n        detJ = (r2 - r1) * L / 4.0\n\n        # Initialize terms for quadrature sums\n        # This term corresponds to the integral of U*r*dA over the element area\n        area_integral_term_r = 0.0\n        # This term corresponds to the integral of U*dA (missing r)\n        area_integral_term_no_r = 0.0\n\n        # Quadrature loop over 4 Gauss points\n        for i, (xi, eta) in enumerate(gauss_points):\n            w = gauss_weights[i]\n            # Radius at the current Gauss point from isoparametric mapping\n            r_gp = 0.5 * (1 - xi) * r1 + 0.5 * (1 + xi) * r2\n            \n            # Accumulate contributions for different integrands\n            area_integral_term_r += U_const * r_gp * detJ * w\n            area_integral_term_no_r += U_const * detJ * w\n        \n        # --- Compute Energies for All Strategies ---\n        \n        # Correct strategies (should be mathematically identical)\n        # 1. Global scaling: Multiply total area integral by 2*pi\n        W_global = area_integral_term_r * (2 * np.pi)\n        \n        # 2. Element-level scaling: For a single element, same as global\n        W_element = area_integral_term_r * (2 * np.pi)\n        \n        # 3. Embedded in weights: Include 2*pi*r in the sum at each GP\n        # This is mathematically equivalent to the above.\n        W_weights = area_integral_term_r * (2 * np.pi)\n        \n        # Inconsistent strategies\n        # 4. Missing 2*pi factor\n        W_no2pi = area_integral_term_r\n        \n        # 5. Missing radius weighting r in the measure\n        W_nor = area_integral_term_no_r * (2 * np.pi)\n        \n        # 6. Double application of 2*pi factor\n        W_double2pi = W_global * (2 * np.pi)\n\n        # --- Calculate Required Metrics ---\n        # Maximum relative error among correct strategies vs. analytic\n        w_analytic_abs = abs(W_analytic)\n        if w_analytic_abs  1e-15: # Avoid division by zero\n            rel_err_global = abs(W_global - W_analytic) / w_analytic_abs\n            rel_err_element = abs(W_element - W_analytic) / w_analytic_abs\n            rel_err_weights = abs(W_weights - W_analytic) / w_analytic_abs\n            max_rel_error = max(rel_err_global, rel_err_element, rel_err_weights)\n            \n            # Ratios of inconsistent energies to analytic energy\n            ratio_no2pi = W_no2pi / W_analytic\n            ratio_nor = W_nor / W_analytic\n            ratio_double2pi = W_double2pi / W_analytic\n        else: # Handle case where analytic energy is zero (e.g., r1=r2)\n            max_rel_error = 0.0\n            ratio_no2pi = np.nan\n            ratio_nor = np.nan\n            ratio_double2pi = np.nan\n\n        # Append results for the current test case to the master list\n        all_results.extend([\n            W_global, W_element, W_weights, W_analytic,\n            max_rel_error, ratio_no2pi, ratio_nor, ratio_double2pi\n        ])\n        \n        # Store one of the correct energy values for the final scaling check\n        correct_energies_for_scaling.append(W_global)\n\n    # --- Evaluate Energy Scaling Across Geometries ---\n    W1 = correct_energies_for_scaling[0]\n    r1_1, r2_1, _ = test_cases[0]\n    geo_factor_1 = r2_1**2 - r1_1**2\n\n    # Scaling error for test case 2 vs 1\n    W2 = correct_energies_for_scaling[1]\n    r1_2, r2_2, _ = test_cases[1]\n    geo_factor_2 = r2_2**2 - r1_2**2\n    analytic_ratio_21 = geo_factor_2 / geo_factor_1 if abs(geo_factor_1)  1e-15 else np.nan\n    numerical_ratio_21 = W2 / W1 if abs(W1)  1e-15 else np.nan\n    delta_2 = (numerical_ratio_21 - analytic_ratio_21) / analytic_ratio_21 if abs(analytic_ratio_21)  1e-15 else 0.0\n\n    # Scaling error for test case 3 vs 1\n    W3 = correct_energies_for_scaling[2]\n    r1_3, r2_3, _ = test_cases[2]\n    geo_factor_3 = r2_3**2 - r1_3**2\n    analytic_ratio_31 = geo_factor_3 / geo_factor_1 if abs(geo_factor_1)  1e-15 else np.nan\n    numerical_ratio_31 = W3 / W1 if abs(W1)  1e-15 else np.nan\n    delta_3 = (numerical_ratio_31 - analytic_ratio_31) / analytic_ratio_31 if abs(analytic_ratio_31)  1e-15 else 0.0\n\n    all_results.append(delta_2)\n    all_results.append(delta_3)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3545418"}, {"introduction": "Building upon the theoretical foundations, this exercise delves into a practical numerical issue that arises in axisymmetric simulations. The terms involving the radius $r$ in both the kinematics and the integration measure can lead to poor numerical conditioning of the stiffness matrix for elements near the axis of symmetry. Through this practice, you will quantify this ill-conditioning for different mesh topologies and explore mapping strategies to mitigate instability, a key skill for robustly modeling solid bodies of revolution [@problem_id:3545417].", "problem": "You are asked to implement and compare two axisymmetric meridian mesh topologies adjacent to the axis in the context of computational solid mechanics, and to quantify numerical conditioning of the assembled stiffness matrix as the minimum radius approaches the axis. The derivation must start from first principles and use a consistent axisymmetric formulation for four-node bilinear isoparametric quadrilateral elements. The comparison should consider wedge-like meshes (with nodes lying on the axis) and rectangular meshes (offset by a strictly positive minimum radius). You must also implement a mapping strategy to avoid collapse in the hoop strain terms when the radius is very small.\n\nThe fundamental base that must be used includes the following, without providing any shortcut formulas:\n- Newton's laws of motion for continua and the principle of virtual work relating internal virtual work to external virtual work.\n- Small-strain kinematics in axisymmetry, where displacements are functions of the meridian coordinates and independent of the circumferential coordinate, and the hoop strain is defined consistently with axisymmetry.\n- Isotropic linear elasticity (Hooke's law) in three dimensions specialized to axisymmetric conditions, introducing the Lamé parameters from the Young's modulus and Poisson's ratio.\n- Isoparametric mapping for quadrilateral elements, Jacobian transformation between parent and physical coordinates, and Gaussian quadrature for numerical integration.\n\nYour program must:\n1. Construct two-element meridian meshes in the $r$-$z$ plane with the same axial extent. Each element is a four-node bilinear quadrilateral. One mesh is wedge-like adjacent to the axis, with the left column of nodes having $r=0$. The other is rectangular and offset from the axis so that the left column has $r=r_{\\min}0$.\n2. Assemble the global axisymmetric stiffness matrix using a consistent bilinear isoparametric element formulation. The strain-displacement matrix must include radial, axial, hoop, and shear components; the constitutive relation must be for isotropic three-dimensional linear elasticity under axisymmetric conditions; and the integration weight must include the radius as required by axisymmetry. The integration must use $2\\times 2$ Gaussian quadrature in the parent coordinates.\n3. Impose essential boundary conditions to eliminate rigid-body modes and enforce axis regularity. For the wedge-like mesh, enforce $u_r=0$ at nodes on the axis $r=0$ and fix one axial displacement to anchor the solution. For the rectangular mesh, fix both displacement components at one corner node to remove rigid-body translations.\n4. Compute the condition number of the reduced stiffness matrix (after applying boundary conditions by elimination of constrained degrees of freedom) for each test case using the $2$-norm definition, and return the results as unitless floating-point numbers.\n5. Implement two mapping strategies for evaluating the radius in the hoop strain and the axisymmetric integration weight: a standard isoparametric radius computation and a safeguarded radius floor mapping, where the effective radius used in these terms is $r_{\\text{eff}}=\\max(r,r_{\\text{floor}})$ with a prescribed $r_{\\text{floor}}0$.\n\nMaterial and geometric data (use these values):\n- Young's modulus $E$ in pascals is $E=210\\times 10^{9}$.\n- Poisson's ratio $\\nu$ is $\\nu=0.3$.\n- Radial element width $h_r$ in meters is $h_r=1.0$.\n- Axial element height $h_z$ in meters is $h_z=1.0$.\nThese quantities are used to construct the finite element model, but the final reported condition numbers are unitless. Ensure that any intermediate quantities are treated consistently, and note that the condition number is independent of the overall scaling by $E$.\n\nDefine the meridian mesh for both topologies as follows:\n- The mesh has two elements stacked in the axial direction, sharing a middle row of nodes. Nodes form a $2$-column by $3$-row grid. For the wedge-like mesh, the left column radii are $r=0$ and the right column radii are $r=h_r$. For the rectangular mesh, the left column radii are $r=r_{\\min}$ and the right column radii are $r=r_{\\min}+h_r$. The axial coordinates of the rows are $z=0$, $z=h_z$, $z=2h_z$.\n- Elements are defined by the node indices in counterclockwise order: bottom-left, bottom-right, top-right, top-left.\n\nBoundary conditions:\n- Wedge-like mesh: enforce $u_r=0$ at every node with $r=0$ and fix $u_z=0$ at the bottom-left node.\n- Rectangular mesh: fix both $u_r=0$ and $u_z=0$ at the bottom-left node.\nThese are sufficient to remove rigid-body modes needed for a well-posed stiffness matrix in this comparison and to enforce axis regularity in the wedge-like case.\n\nTest suite:\n- Case $1$: rectangular mesh with $r_{\\min}=10^{-6}\\ \\text{m}$, standard mapping with $r_{\\text{floor}}=0$.\n- Case $2$: rectangular mesh with $r_{\\min}=10^{-3}\\ \\text{m}$, standard mapping with $r_{\\text{floor}}=0$.\n- Case $3$: rectangular mesh with $r_{\\min}=10^{-1}\\ \\text{m}$, standard mapping with $r_{\\text{floor}}=0$.\n- Case $4$: wedge-like mesh with geometric $r_{\\min}=0\\ \\text{m}$, standard mapping with $r_{\\text{floor}}=0$.\n- Case $5$: rectangular mesh with $r_{\\min}=10^{-6}\\ \\text{m}$, floor mapping with $r_{\\text{floor}}=10^{-3}\\ \\text{m}$.\n- Case $6$: wedge-like mesh with geometric $r_{\\min}=0\\ \\text{m}$, floor mapping with $r_{\\text{floor}}=10^{-3}\\ \\text{m}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,result_3]$). Each $result_i$ must be the floating-point condition number of the reduced stiffness matrix for the corresponding test case. No other text should be printed. The values are unitless floats.\n\nThe problem requires scientific realism and derivation from first principles. You must ensure that your implementation is consistent with the axisymmetric formulation and that it addresses the numerical behavior near the axis. In addition to computing the condition numbers for the test suite, your solution should propose mapping strategies to avoid collapse and justify their physical and numerical meaning based on the foundational laws and definitions specified above.", "solution": "The problem is validated as scientifically grounded, well-posed, and objective. It represents a standard investigation in computational solid mechanics concerning numerical conditioning in axisymmetric finite element analysis. All necessary data and conditions are provided, and there are no contradictions or ambiguities.\n\nThe solution is derived from the principle of virtual work, which states that for a body in equilibrium, the virtual work done by internal stresses equals the virtual work done by external forces for any kinematically admissible virtual displacement. For a continuum, this is expressed as:\n$$\n\\delta W_{\\text{int}} = \\int_V \\delta\\boldsymbol{\\epsilon}^T \\boldsymbol{\\sigma} \\, dV = \\delta W_{\\text{ext}}\n$$\nIn an axisymmetric setting, the volume element is $dV = 2\\pi r \\, dA$, where $A$ is the area in the $r$-$z$ meridian plane. The displacement field is purely a function of meridian coordinates $(r, z)$, i.e., $\\mathbf{u}(r, z) = [u_r(r, z), u_z(r, z)]^T$.\n\nUnder the assumption of small strains, the strain components are given by the vector $\\boldsymbol{\\epsilon} = [\\epsilon_r, \\epsilon_z, \\epsilon_\\theta, \\gamma_{rz}]^T$, where:\n$$\n\\epsilon_r = \\frac{\\partial u_r}{\\partial r}, \\quad \\epsilon_z = \\frac{\\partial u_z}{\\partial z}, \\quad \\epsilon_\\theta = \\frac{u_r}{r}, \\quad \\gamma_{rz} = \\frac{\\partial u_r}{\\partial z} + \\frac{\\partial u_z}{\\partial r}\n$$\nThe hoop strain $\\epsilon_\\theta$ is a unique feature of axisymmetry and becomes a source of numerical difficulty as the radius $r$ approaches zero.\n\nThe material is assumed to be isotropic and linearly elastic, governed by Hooke's law, $\\boldsymbol{\\sigma} = \\mathbf{C} \\boldsymbol{\\epsilon}$, where $\\boldsymbol{\\sigma} = [\\sigma_r, \\sigma_z, \\sigma_\\theta, \\tau_{rz}]^T$ is the stress vector. The constitutive matrix $\\mathbf{C}$ for an isotropic material under axisymmetric conditions is:\n$$\n\\mathbf{C} = \\frac{E}{(1+\\nu)(1-2\\nu)}\n\\begin{pmatrix}\n1-\\nu  \\nu  \\nu  0 \\\\\n\\nu  1-\\nu  \\nu  0 \\\\\n\\nu  \\nu  1-\\nu  0 \\\\\n0  0  0  \\frac{1-2\\nu}{2}\n\\end{pmatrix}\n$$\nwhere $E$ is Young's modulus and $\\nu$ is Poisson's ratio.\n\nWe employ the four-node bilinear isoparametric quadrilateral element. The geometry and displacement fields within an element are interpolated from nodal values using shape functions $N_i(\\xi, \\eta)$ in a parent coordinate system $(\\xi, \\eta) \\in [-1, 1] \\times [-1, 1]$:\n$$\nr(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) r_i, \\quad z(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) z_i\n$$\n$$\nu_r(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) u_{ri}, \\quad u_z(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) u_{zi}\n$$\nLetting $\\mathbf{d}^e$ be the vector of an element's $8$ nodal displacements, we can write the displacement field as $\\mathbf{u} = \\mathbf{N}\\mathbf{d}^e$ and the strain field as $\\boldsymbol{\\epsilon} = \\mathbf{B}\\mathbf{d}^e$. The strain-displacement matrix $\\mathbf{B}$ is derived from the strain definitions and the isoparametric interpolation. For a node $i$, its contribution to $\\mathbf{B}$ is a $4 \\times 2$ submatrix $\\mathbf{B}_i$:\n$$\n\\mathbf{B}_i(\\xi, \\eta) = \\begin{pmatrix}\n\\frac{\\partial N_i}{\\partial r}  0 \\\\\n0  \\frac{\\partial N_i}{\\partial z} \\\\\n\\frac{N_i}{r}  0 \\\\\n\\frac{\\partial N_i}{\\partial z}  \\frac{\\partial N_i}{\\partial r}\n\\end{pmatrix}\n$$\nThe spatial derivatives of shape functions are found using the Jacobian matrix of the coordinate transformation, $\\mathbf{J}$, where $\\left[\\frac{\\partial N_i}{\\partial r}, \\frac{\\partial N_i}{\\partial z}\\right]^T = \\mathbf{J}^{-T} \\left[\\frac{\\partial N_i}{\\partial \\xi}, \\frac{\\partial N_i}{\\partial \\eta}\\right]^T$.\n\nSubstituting the finite element approximations into the principle of virtual work yields the discrete system $\\mathbf{K}\\mathbf{d} = \\mathbf{F}_{\\text{ext}}$, where the global stiffness matrix $\\mathbf{K}$ is assembled from element stiffness matrices $\\mathbf{k}^e$:\n$$\n\\mathbf{k}^e = \\int_{A_e} \\mathbf{B}^T \\mathbf{C} \\mathbf{B} \\, (2\\pi r) \\, dA = \\int_{-1}^{1}\\int_{-1}^{1} \\mathbf{B}^T(\\xi, \\eta) \\mathbf{C} \\mathbf{B}(\\xi, \\eta) \\, (2\\pi r(\\xi, \\eta)) \\, \\det(\\mathbf{J}) \\, d\\xi \\, d\\eta\n$$\nThis integral is evaluated numerically using $2 \\times 2$ Gaussian quadrature.\n\nThe numerical challenge arises from the $1/r$ term in the hoop strain component of the $\\mathbf{B}$ matrix. As an element approaches the axis of symmetry ($r \\to 0$), this term can become very large. In the integral for $\\mathbf{k}^e$, this large term is multiplied by the integration weight factor $r$, which becomes very small. The product of a very large term and a very small term, $\\mathbf{B}^T \\mathbf{C} \\mathbf{B} \\cdot r$, can lead to a stiffness matrix with a wide range of coefficient magnitudes. This results in a high condition number, indicating numerical sensitivity and potential for large errors in the solution.\n\nTo investigate this, two strategies for evaluating the radius $r$ at the Gauss points are implemented:\n1.  **Standard Isoparametric Mapping**: The radius $r_g = r(\\xi_g, \\eta_g)$ evaluated at a Gauss point is used directly. For cases near the axis, $r_g$ can be very small, leading to the ill-conditioning described. This is equivalent to setting a radius floor of $r_{\\text{floor}} = 0$.\n2.  **Safeguarded Floor Mapping**: A minimum effective radius, $r_{\\text{floor}}  0$, is introduced. The effective radius used in both the hoop strain term ($1/r$) and the integration weight ($2\\pi r$) is $r_{\\text{eff}} = \\max(r_g, r_{\\text{floor}})$. This strategy prevents the $1/r$ term from becoming singular and ensures the element retains a minimum \"volume\" contribution to the stiffness, thereby regularizing the matrix and improving its condition. Physically, it models a thin tubular element instead of a zero-radius line, which can be a more stable idealization.\n\nThe global stiffness matrix is assembled from the two elements. Essential boundary conditions are then applied by eliminating the rows and columns corresponding to the constrained degrees of freedom. For the wedge-like mesh, the axisymmetry condition requires $u_r = 0$ for all nodes on the axis ($r=0$). For the rectangular mesh, which models a thick cylinder with a small inner radius, rigid body motion is removed by fixing a single node. The condition number of the resulting reduced stiffness matrix is then computed using the $2$-norm. This procedure is repeated for each test case to quantify the effect of mesh topology and radius mapping on numerical stability.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_constitutive_matrix(E, nu):\n    \"\"\"\n    Computes the axisymmetric constitutive matrix for an isotropic material.\n    \"\"\"\n    C = np.zeros((4, 4))\n    factor = E / ((1.0 + nu) * (1.0 - 2.0 * nu))\n    \n    C[0, 0] = factor * (1.0 - nu)\n    C[0, 1] = factor * nu\n    C[0, 2] = factor * nu\n    \n    C[1, 0] = factor * nu\n    C[1, 1] = factor * (1.0 - nu)\n    C[1, 2] = factor * nu\n    \n    C[2, 0] = factor * nu\n    C[2, 1] = factor * nu\n    C[2, 2] = factor * (1.0 - nu)\n    \n    C[3, 3] = factor * (1.0 - 2.0 * nu) / 2.0\n    \n    return C\n\ndef get_shape_functions(xi, eta):\n    \"\"\"\n    Computes shape functions and their derivatives for a 4-node quad element.\n    \"\"\"\n    N = 0.25 * np.array([\n        (1.0 - xi) * (1.0 - eta),\n        (1.0 + xi) * (1.0 - eta),\n        (1.0 + xi) * (1.0 + eta),\n        (1.0 - xi) * (1.0 + eta)\n    ])\n    \n    dN_dxi = 0.25 * np.array([\n        -(1.0 - eta),\n        (1.0 - eta),\n        (1.0 + eta),\n        -(1.0 + eta)\n    ])\n    \n    dN_deta = 0.25 * np.array([\n        -(1.0 - xi),\n        -(1.0 + xi),\n        (1.0 + xi),\n        (1.0 - xi)\n    ])\n    \n    return N, dN_dxi, dN_deta\n\ndef get_element_stiffness(node_coords, C, r_floor):\n    \"\"\"\n    Computes the stiffness matrix for a single 4-node axisymmetric element.\n    \"\"\"\n    k_e = np.zeros((8, 8))\n    gauss_points = [-1.0 / np.sqrt(3.0), 1.0 / np.sqrt(3.0)]\n    gauss_weights = [1.0, 1.0]\n\n    for i, xi in enumerate(gauss_points):\n        for j, eta in enumerate(gauss_points):\n            N, dN_dxi, dN_deta = get_shape_functions(xi, eta)\n            \n            # Jacobian matrix\n            J = np.zeros((2, 2))\n            J[0, 0] = np.dot(dN_dxi, node_coords[:, 0])  # dr/dxi\n            J[0, 1] = np.dot(dN_dxi, node_coords[:, 1])  # dz/dxi\n            J[1, 0] = np.dot(dN_deta, node_coords[:, 0]) # dr/deta\n            J[1, 1] = np.dot(dN_deta, node_coords[:, 1]) # dz/deta\n            \n            det_J = np.linalg.det(J)\n            inv_J = np.linalg.inv(J)\n            \n            # Derivatives of shape functions w.r.t. physical coordinates (r, z)\n            dN_d_phys = inv_J @ np.array([dN_dxi, dN_deta])\n            dN_dr = dN_d_phys[0, :]\n            dN_dz = dN_d_phys[1, :]\n            \n            # Radius at the Gauss point\n            r_gp = np.dot(N, node_coords[:, 0])\n            \n            # Apply safeguarded radius floor mapping\n            r_eff = max(r_gp, r_floor)\n            \n            # Strain-displacement matrix B\n            B = np.zeros((4, 8))\n            for k in range(4):\n                B[0, 2*k]     = dN_dr[k]\n                B[1, 2*k+1]   = dN_dz[k]\n                if r_eff  1e-15:  # Avoid division by zero\n                    B[2, 2*k] = N[k] / r_eff\n                B[3, 2*k]     = dN_dz[k]\n                B[3, 2*k+1]   = dN_dr[k]\n            \n            # Integrate to get stiffness matrix contribution\n            weight = gauss_weights[i] * gauss_weights[j]\n            k_e += (B.T @ C @ B) * (2.0 * np.pi * r_eff) * det_J * weight\n            \n    return k_e\n\ndef run_analysis(mesh_type, r_min, r_floor):\n    \"\"\"\n    Performs the full analysis for one test case.\n    \"\"\"\n    # 1. Define material and geometric properties\n    E = 210e9\n    nu = 0.3\n    h_r = 1.0\n    h_z = 1.0\n    C = get_constitutive_matrix(E, nu)\n\n    # 2. Define node coordinates based on mesh type\n    r_geom = 0.0 if mesh_type == 'wedge' else r_min\n    \n    nodes = np.array([\n        [r_geom, 0.0],\n        [r_geom + h_r, 0.0],\n        [r_geom, h_z],\n        [r_geom + h_r, h_z],\n        [r_geom, 2.0 * h_z],\n        [r_geom + h_r, 2.0 * h_z]\n    ])\n    num_nodes = 6\n    num_dofs = 2 * num_nodes\n\n    # 3. Define elements and DOF maps for assembly\n    # Connectivity [bottom-left, bottom-right, top-right, top-left]\n    elements = [[0, 1, 3, 2], [2, 3, 5, 4]]\n    # Maps local element DOFs to global DOFs\n    dof_maps = [\n        np.array([0, 1, 2, 3, 6, 7, 4, 5]),\n        np.array([4, 5, 6, 7, 10, 11, 8, 9])\n    ]\n\n    # 4. Assemble global stiffness matrix K\n    K = np.zeros((num_dofs, num_dofs))\n    for i, elem_node_indices in enumerate(elements):\n        elem_coords = nodes[elem_node_indices]\n        k_e = get_element_stiffness(elem_coords, C, r_floor)\n        \n        ix_map = dof_maps[i]\n        K[np.ix_(ix_map, ix_map)] += k_e\n\n    # 5. Apply Boundary Conditions by elimination\n    if mesh_type == 'wedge':\n        # ur=0 at r=0 (nodes 0, 2, 4 -> DOFs 0, 4, 8)\n        # uz=0 at node 0 (DOF 1) to remove rigid body motion\n        constrained_dofs = [0, 1, 4, 8]\n    else: # rectangular\n        # ur=0, uz=0 at node 0 (DOFs 0, 1) to remove rigid body motion\n        constrained_dofs = [0, 1]\n    \n    all_dofs = np.arange(num_dofs)\n    free_dofs = np.setdiff1d(all_dofs, constrained_dofs)\n    K_reduced = K[np.ix_(free_dofs, free_dofs)]\n    \n    # 6. Compute and return the 2-norm condition number\n    condition_number = np.linalg.cond(K_reduced, p=2)\n    return condition_number\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {'type': 'rectangular', 'r_min': 1e-6, 'r_floor': 0.0},\n        {'type': 'rectangular', 'r_min': 1e-3, 'r_floor': 0.0},\n        {'type': 'rectangular', 'r_min': 1e-1, 'r_floor': 0.0},\n        {'type': 'wedge', 'r_min': 0.0, 'r_floor': 0.0},\n        {'type': 'rectangular', 'r_min': 1e-6, 'r_floor': 1e-3},\n        {'type': 'wedge', 'r_min': 0.0, 'r_floor': 1e-3},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_analysis(\n            mesh_type=case['type'],\n            r_min=case['r_min'],\n            r_floor=case['r_floor']\n        )\n        results.append(result)\n\n    print(f\"[{','.join(f'{r:.7e}' for r in results)}]\")\n\nsolve()\n```", "id": "3545417"}]}