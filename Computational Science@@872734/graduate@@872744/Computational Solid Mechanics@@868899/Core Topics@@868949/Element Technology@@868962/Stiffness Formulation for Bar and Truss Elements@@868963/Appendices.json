{"hands_on_practices": [{"introduction": "Moving from theory to a robust computational tool begins with the fundamental building block: the element itself. This first practice guides you through the essential process of deriving and implementing the global stiffness matrix, $K_e$, for a single 2D truss element from first principles [@problem_id:3602979]. The exercise emphasizes the critical role of verification by having you design numerical checks that probe the matrix's physical and mathematical properties, such as its invariance to rotation and its spectral signature, which reveals the element's rigid body and deformation modes.", "problem": "You are to implement a program that, from first principles, constructs the global stiffness matrix of a two-dimensional bar (two-node truss) element and designs numerical checks to validate invariance to rigid rotations and detect common sign-convention mistakes. The derivation must start from the one-dimensional small-strain kinematics, the linear elastic constitutive law, and the Principle of Virtual Work, and then proceed to obtain the local element stiffness in the element’s axial coordinate. Next, use an orthogonal transformation built from direction cosines to map the local stiffness to the global (laboratory) coordinate frame with two Degrees of Freedom (DOF) per node. The program must then exercise this formulation on a test suite that probes rotational invariance, symmetry and positive semidefiniteness, a deliberately “pathological” orientation, and a degenerate geometry edge case.\n\nFundamental base that you are expected to use:\n- Small-strain kinematics for an axially deforming bar: axial strain $\\,\\varepsilon = du/dx\\,$.\n- Linear elastic constitutive relation for a bar: axial stress $\\,\\sigma = E\\,\\varepsilon\\,$, where $\\,E\\,$ is Young’s modulus.\n- Principle of Virtual Work for a conservative linear system, enabling the derivation of a symmetric element stiffness operator from the internal virtual work balance.\n- Orthogonal basis change using direction cosines to map between local element and global coordinates.\n\nUse the following modeling and numerical conventions:\n- Two-dimensional bar element with nodes at global coordinates $\\,(x_1,y_1)\\,$ and $\\,(x_2,y_2)\\,$, Young’s modulus $\\,E\\,$ (in Pascals), and cross-sectional area $\\,A\\,$ (in square meters).\n- The element length is $\\,\\ell = \\sqrt{(x_2-x_1)^2 + (y_2-y_1)^2}\\,$ in meters, and its unit direction cosines are $\\,c = (x_2-x_1)/\\ell\\,$ and $\\,s = (y_2-y_1)/\\ell\\,$.\n- The local element displacement vector is two-dimensional with one translational DOF per node along the element axis, while the global displacement vector is four-dimensional with two translational DOFs per node. The mapping from global to local must be constructed from the direction cosines by an orthogonal transformation.\n- Treat the element as linear elastic and neglect body forces.\n\nYour program must:\n- Construct the $\\,4\\times 4\\,$ global element stiffness matrix $\\,K_e\\,$ from first principles by forming the $\\,2\\times 2\\,$ local stiffness in the element axis, then mapping it to the global frame by an orthogonal transformation built from the direction cosines $\\,c\\,$ and $\\,s\\,$.\n- Compute the spectrum of $\\,K_e\\,$ and extract the unique nonzero eigenvalue. For a free two-node bar element in two dimensions, $\\,K_e\\,$ must be symmetric positive semidefinite with exactly one strictly positive eigenvalue. All eigenvalues should be reported with numerical safeguards; consider an eigenvalue “zero” if its magnitude is below a tolerance scaled by $\\,k = EA/\\ell\\,$.\n- Verify rotational invariance with a “pathological” orientation that flips the element by $\\,180^\\circ\\,$, which changes the signs of both $\\,c\\,$ and $\\,s\\,$ simultaneously. The global $\\,K_e\\,$ must be invariant under this flip if the transformation is implemented correctly. Measure invariance via the Frobenius norm of the difference and compare against a relative tolerance.\n- Detect a common sign-convention mistake by comparing the correct stiffness against one computed with a deliberately sign-flawed transformation. On a non-axis-aligned element, this mistake must lead to a detectable discrepancy. Report whether the discrepancy exceeds a specified tolerance.\n- Detect degenerate geometry by flagging elements whose length satisfies $\\,\\ell  10^{-9}\\,$ meters, in which case no stiffness should be constructed.\n\nPhysical units:\n- Use $\\,\\mathrm{Pa}\\,$ for $\\,E\\,$, $\\,\\mathrm{m}^2\\,$ for $\\,A\\,$, and $\\,\\mathrm{m}\\,$ for all coordinates. Stiffness matrix entries and eigenvalues are in $\\,\\mathrm{N}/\\mathrm{m}\\,$. Express all reported eigenvalues in $\\,\\mathrm{N}/\\mathrm{m}\\,$ as floating-point numbers.\n\nAngle unit:\n- Any reference to an angle is implied by the coordinates; no explicit angle inputs are required.\n\nTolerances:\n- Use an eigenvalue zero-tolerance of $\\,10^{-9}\\,k\\,$, where $\\,k = EA/\\ell\\,$ has units $\\,\\mathrm{N}/\\mathrm{m}\\,$.\n- Use a relative matrix invariance tolerance of $\\,10^{-12}\\,$ when checking equality under a $\\,180^\\circ\\,$ flip via the Frobenius norm.\n- Use the degenerate-length threshold $\\,10^{-9}\\,$ meters.\n\nTest suite:\n- Use $\\,E = 210\\times 10^{9}\\,$ Pa and $\\,A = 10^{-2}\\,$ $\\mathrm{m}^2$ for all non-degenerate elements.\n- Case A (axis-aligned, horizontal): node $\\,1$ at $\\,(0,0)\\,$ meters, node $\\,2$ at $\\,(5,0)\\,$ meters. Report the unique nonzero eigenvalue of $\\,K_e\\,$ in $\\,\\mathrm{N}/\\mathrm{m}\\,$ as a float.\n- Case B (axis-aligned, vertical): node $\\,1$ at $\\,(0,0)\\,$ meters, node $\\,2$ at $\\,(0,5)\\,$ meters. Report the unique nonzero eigenvalue of $\\,K_e\\,$ in $\\,\\mathrm{N}/\\mathrm{m}\\,$ as a float.\n- Case C (non-axis-aligned $\\,3$–$4$–$5$ triangle geometry): node $\\,1$ at $\\,(0,0)\\,$ meters, node $\\,2$ at $\\,(3,4)\\,$ meters. Report the unique nonzero eigenvalue of $\\,K_e\\,$ in $\\,\\mathrm{N}/\\mathrm{m}\\,$ as a float.\n- Pathological rotation invariance: compare $\\,K_e\\,$ for $\\,(0,0)\\rightarrow(3,4)\\,$ and $\\,(0,0)\\rightarrow(-3,-4)\\,$. Report a boolean that is true if the relative Frobenius norm of the difference is below $\\,10^{-12}\\,$.\n- Symmetry and positive semidefiniteness check on Case C: report a boolean that is true if $\\,K_e\\,$ is symmetric within machine tolerance and has exactly one strictly positive eigenvalue with all others within the zero-tolerance defined above.\n- Sign-convention mistake detection on a non-axis-aligned element: use nodes $\\,(0,0)\\,$ and $\\,(1,1)\\,$. Intentionally construct a transformation with an incorrect sign in one direction cosine entry and compare the resulting stiffness to the correct one. Report a boolean that is true if the Frobenius norm of the difference exceeds the eigenvalue zero-tolerance scale.\n- Degenerate geometry: nodes $\\,(0,0)\\,$ and $\\,(10^{-12},0)\\,$. Report a boolean that is true if the geometry is correctly flagged as invalid due to $\\,\\ell  10^{-9}\\,$ meters.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the following order:\n  - the three floats for the unique nonzero eigenvalues in Cases A, B, and C (in $\\,\\mathrm{N}/\\mathrm{m}\\,$),\n  - the four booleans for, respectively, the $\\,180^\\circ\\,$ invariance check, the symmetry and positive semidefiniteness check, the sign-convention mistake detection, and the degenerate geometry detection.\n- Example of the required output structure: $\\,[\\text{float},\\text{float},\\text{float},\\text{bool},\\text{bool},\\text{bool},\\text{bool}]$.", "solution": "The problem requires the formulation and programmatic implementation of the global stiffness matrix for a two-dimensional bar (truss) element, including a suite of numerical validation checks. The derivation and implementation will proceed from first principles as stipulated.\n\n### Derivation of the Element Stiffness Matrix\n\nThe relationship between nodal forces and nodal displacements for a finite element is expressed through its stiffness matrix. We derive this matrix using the Principle of Virtual Work ($\\delta W$), which states that for a body in equilibrium, the internal virtual work done by stresses is equal to the external virtual work done by applied forces for any kinematically admissible virtual displacement. For deriving the stiffness matrix, we consider only the internal virtual work, $\\delta W_{int}$.\n\n$\\delta W_{int} = \\int_V \\delta\\varepsilon^T \\sigma \\, dV$\n\n**1. Local Stiffness Matrix ($k_e$)**\n\nFirst, we formulate the stiffness in a local coordinate system aligned with the element's axis ($x'$). The element has two nodes, 1 and 2, and its properties are Young's modulus $E$, cross-sectional area $A$, and length $\\ell$. The degrees of freedom are the axial displacements $d'_{1}$ and $d'_{2}$ at each node.\n\nThe displacement field $u'(x')$ along the element is interpolated from the nodal displacements using linear shape functions, $N_1(x') = 1 - x'/\\ell$ and $N_2(x') = x'/\\ell$:\n$$ u'(x') = N_1(x') d'_{1} + N_2(x') d'_{2} = \\begin{bmatrix} N_1(x')  N_2(x') \\end{bmatrix} \\begin{Bmatrix} d'_{1} \\\\ d'_{2} \\end{Bmatrix} = \\mathbf{N} \\mathbf{d}_{local} $$\n\nThe axial strain $\\varepsilon$ is the spatial derivative of the displacement field. For linear shape functions, the strain is constant along the element:\n$$ \\varepsilon = \\frac{du'}{dx'} = \\frac{d\\mathbf{N}}{dx'} \\mathbf{d}_{local} = \\begin{bmatrix} -\\frac{1}{\\ell}  \\frac{1}{\\ell} \\end{bmatrix} \\mathbf{d}_{local} = \\mathbf{B} \\mathbf{d}_{local} $$\nHere, $\\mathbf{B}$ is the strain-displacement matrix. The virtual strain is $\\delta\\varepsilon = \\mathbf{B} \\delta\\mathbf{d}_{local}$.\n\nThe constitutive law for linear elasticity (Hooke's Law) relates stress $\\sigma$ and strain $\\varepsilon$:\n$$ \\sigma = E \\varepsilon = E \\mathbf{B} \\mathbf{d}_{local} $$\n\nSubstituting these into the internal virtual work expression, and noting that for a bar of constant area $A$, $dV = A \\, dx'$:\n$$ \\delta W_{int} = \\int_0^\\ell (\\delta\\varepsilon)^T \\sigma A \\, dx' = \\int_0^\\ell (\\mathbf{B} \\delta\\mathbf{d}_{local})^T (E \\mathbf{B} \\mathbf{d}_{local}) A \\, dx' $$\nSince $\\mathbf{d}_{local}$ and its variation $\\delta\\mathbf{d}_{local}$ are independent of $x'$, and $\\mathbf{B}$, $E$, and $A$ are constant, we can write:\n$$ \\delta W_{int} = (\\delta\\mathbf{d}_{local})^T \\left( A E \\int_0^\\ell \\mathbf{B}^T \\mathbf{B} \\, dx' \\right) \\mathbf{d}_{local} $$\nThe expression in the parentheses is the $2 \\times 2$ local stiffness matrix, $k_e$:\n$$ k_e = A E \\ell \\mathbf{B}^T \\mathbf{B} = A E \\ell \\begin{Bmatrix} -1/\\ell \\\\ 1/\\ell \\end{Bmatrix} \\begin{bmatrix} -1/\\ell  1/\\ell \\end{bmatrix} = \\frac{AE}{\\ell^2} \\ell \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix} $$\n$$ k_e = \\frac{EA}{\\ell} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix} $$\n\n**2. Global Stiffness Matrix ($K_e$)**\n\nNext, we transform the local stiffness matrix into the global $x$-$y$ coordinate system. Each node now has two translational degrees of freedom: $(u_1, v_1)$ for node 1 and $(u_2, v_2)$ for node 2. The global displacement vector is $\\mathbf{d}_{global} = [u_1, v_1, u_2, v_2]^T$.\n\nThe local axial displacement $d'_i$ at a node is the projection of its global displacement vector $(u_i, v_i)$ onto the element's axis. The direction of this axis is given by a unit vector with components $(c, s)$, where $c$ and $s$ are the direction cosines:\n$$ c = \\frac{x_2 - x_1}{\\ell}, \\quad s = \\frac{y_2 - y_1}{\\ell} $$\nThe relationship between local and global displacements is:\n$$ d'_{1} = c u_1 + s v_1 $$\n$$ d'_{2} = c u_2 + s v_2 $$\nThis can be written in matrix form as $\\mathbf{d}_{local} = \\mathbf{T} \\mathbf{d}_{global}$:\n$$ \\begin{Bmatrix} d'_{1} \\\\ d'_{2} \\end{Bmatrix} = \\begin{bmatrix} c  s  0  0 \\\\ 0  0  c  s \\end{bmatrix} \\begin{Bmatrix} u_1 \\\\ v_1 \\\\ u_2 \\\\ v_2 \\end{Bmatrix} $$\nwhere $\\mathbf{T}$ is the $2 \\times 4$ transformation matrix.\n\nBy the principle of work equivalence, the internal work must be invariant to the choice of coordinate system.\n$$ \\delta W_{int} = (\\delta\\mathbf{d}_{local})^T k_e \\mathbf{d}_{local} = (\\delta\\mathbf{d}_{global})^T K_e \\mathbf{d}_{global} $$\nSubstituting $\\mathbf{d}_{local} = \\mathbf{T} \\mathbf{d}_{global}$ and $\\delta\\mathbf{d}_{local} = \\mathbf{T} \\delta\\mathbf{d}_{global}$:\n$$ (\\mathbf{T} \\delta\\mathbf{d}_{global})^T k_e (\\mathbf{T} \\mathbf{d}_{global}) = (\\delta\\mathbf{d}_{global})^T (\\mathbf{T}^T k_e \\mathbf{T}) \\mathbf{d}_{global} $$\nFrom this, we identify the $4 \\times 4$ global stiffness matrix $K_e$:\n$$ K_e = \\mathbf{T}^T k_e \\mathbf{T} $$\nPerforming the matrix multiplication:\n$$ K_e = \\begin{bmatrix} c  0 \\\\ s  0 \\\\ 0  c \\\\ 0  s \\end{bmatrix} \\left( \\frac{EA}{\\ell} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix} \\right) \\begin{bmatrix} c  s  0  0 \\\\ 0  0  c  s \\end{bmatrix} $$\n$$ K_e = \\frac{EA}{\\ell} \\begin{bmatrix} c  -c \\\\ s  -s \\\\ -c  c \\\\ -s  s \\end{bmatrix} \\begin{bmatrix} c  s  0  0 \\\\ 0  0  c  s \\end{bmatrix} $$\nThis results in the final expression for the global stiffness matrix:\n$$ K_e = \\frac{EA}{\\ell} \\begin{bmatrix} c^2  cs  -c^2  -cs \\\\ cs  s^2  -cs  -s^2 \\\\ -c^2  -cs  c^2  cs \\\\ -cs  -s^2  cs  s^2 \\end{bmatrix} $$\nThis matrix can be compactly written as $K_e = \\frac{EA}{\\ell} \\begin{bmatrix} \\mathbf{M}  -\\mathbf{M} \\\\ -\\mathbf{M}  \\mathbf{M} \\end{bmatrix}$ where $\\mathbf{M} = \\begin{bmatrix} c^2  cs \\\\ cs  s^2 \\end{bmatrix}$.\n\n### Properties and Validation Checks\n\n**1. Spectrum of $K_e$**: The matrix $K_e$ is of size $4 \\times 4$. For a free element, there are three rigid body modes (two translations and one rotation in the 2D plane), which correspond to three zero eigenvalues. The matrix is therefore of rank 1. A rank-1 matrix has only one non-zero eigenvalue, which is equal to its trace.\n$$ \\lambda_{nonzero} = \\text{Tr}(K_e) = \\frac{EA}{\\ell} (c^2 + s^2 + c^2 + s^2) = \\frac{EA}{\\ell} (2(c^2+s^2)) = 2 \\frac{EA}{\\ell} $$\nThis eigenvalue represents the element's axial stiffness and is invariant to the element's orientation in space.\n\n**2. Rotational Invariance**: The structure of $K_e$ depends on $c^2$, $s^2$, and $cs$. If an element is rotated by $180^\\circ$, its direction cosines change sign: $(c, s) \\to (-c, -s)$. However, the products $c^2 \\to (-c)^2 = c^2$, $s^2 \\to (-s)^2 = s^2$, and $cs \\to (-c)(-s) = cs$ remain unchanged. Therefore, the global stiffness matrix $K_e$ must be invariant under such a rotation.\n\n**3. Symmetry and Positive Semidefiniteness**: The matrix $K_e$ is derived from the expression $\\mathbf{T}^T k_e \\mathbf{T}$. Since the local stiffness matrix $k_e$ is symmetric, $K_e$ is also symmetric. As a stiffness matrix for a stable physical system, it must be positive semidefinite, meaning all its eigenvalues must be non-negative ($\\lambda_i \\ge 0$).\n\n**4. Sign-Convention Mistake**: A common error is to use an inconsistent sign for a direction cosine, for example, using $s = (y_1-y_2)/\\ell$ instead of $s = (y_2-y_1)/\\ell$. This flaw flips the sign of $s$, which in turn flips the sign of the $cs$ term in the matrix $\\mathbf{M}$, leading to an incorrect stiffness matrix for any non-axis-aligned element.\n\n**5. Degenerate Geometry**: If the two nodes of an element are coincident or numerically very close, the length $\\ell$ approaches zero. This leads to a division by zero in the stiffness calculation, indicating a singularity. Such elements must be flagged and excluded from analysis.\n\nThe following program implements these principles and performs the required validation checks on the specified test suite.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef get_stiffness_matrix(coords, E, A, sign_error_s=False):\n    \"\"\"\n    Constructs the global stiffness matrix for a 2D bar element.\n\n    Args:\n        coords (tuple): A tuple of (x1, y1, x2, y2) nodal coordinates.\n        E (float): Young's modulus in Pascals.\n        A (float): Cross-sectional area in square meters.\n        sign_error_s (bool): If True, introduces a sign error in the 's' direction cosine.\n\n    Returns:\n        tuple: A tuple containing (K_e, l, k_base) where K_e is the 4x4 stiffness\n               matrix (np.ndarray), l is the element length (float), and k_base\n               is the axial stiffness EA/l (float). Returns (None, l, None) if\n               the element is degenerate.\n    \"\"\"\n    x1, y1, x2, y2 = coords\n    dx = x2 - x1\n    dy = y2 - y1\n    \n    l = np.sqrt(dx**2 + dy**2)\n    \n    # Degenerate geometry check\n    degenerate_length_threshold = 1e-9\n    if l  degenerate_length_threshold:\n        return None, l, None\n\n    c = dx / l\n    s = dy / l\n    \n    # Introduce intentional sign error for the specific test case\n    if sign_error_s:\n        s = -s\n\n    k_base = E * A / l\n    \n    c2 = c * c\n    s2 = s * s\n    cs = c * s\n    \n    # Sub-matrix M\n    M = np.array([\n        [c2, cs],\n        [cs, s2]\n    ])\n    \n    # Assemble the 4x4 global stiffness matrix K_e\n    K_e = k_base * np.block([\n        [ M, -M],\n        [-M,  M]\n    ])\n    \n    return K_e, l, k_base\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and generate the final output.\n    \"\"\"\n    results = []\n    \n    # --- Shared parameters ---\n    E_modulus = 210.0e9  # Pa\n    Area = 1.0e-2       # m^2\n    \n    # --- Test Cases A, B, C: Unique Nonzero Eigenvalue ---\n    cases_abc = [\n        (0.0, 0.0, 5.0, 0.0),  # Case A: Horizontal\n        (0.0, 0.0, 0.0, 5.0),  # Case B: Vertical\n        (0.0, 0.0, 3.0, 4.0),  # Case C: 3-4-5 Triangle\n    ]\n    \n    for coords in cases_abc:\n        K_e, l, k_base = get_stiffness_matrix(coords, E_modulus, Area)\n        \n        # Eigenvalue zero tolerance\n        eigenvalue_zero_tol = 1e-9 * k_base\n        \n        # Use eigh for symmetric matrices; it's faster and more stable\n        eigenvalues = eigh(K_e, eigvals_only=True)\n        \n        # Find the single eigenvalue that is strictly positive\n        # based on the defined tolerance.\n        nonzero_eig = eigenvalues[eigenvalues > eigenvalue_zero_tol]\n        \n        # There should be exactly one such eigenvalue\n        if len(nonzero_eig) == 1:\n            results.append(nonzero_eig[0])\n        else:\n            # Append a sentinel value if the check fails, though it shouldn't\n            results.append(-1.0)\n            \n    # --- Pathological Rotation Invariance Check ---\n    coords1 = (0.0, 0.0, 3.0, 4.0)\n    coords2 = (0.0, 0.0, -3.0, -4.0) # 180-degree rotation\n    \n    K_e1, _, _ = get_stiffness_matrix(coords1, E_modulus, Area)\n    K_e2, _, _ = get_stiffness_matrix(coords2, E_modulus, Area)\n    \n    norm_k1 = np.linalg.norm(K_e1, 'fro')\n    diff_norm = np.linalg.norm(K_e1 - K_e2, 'fro')\n    \n    # Avoid division by zero for a null matrix, though not expected here\n    relative_diff = diff_norm / norm_k1 if norm_k1 > 0 else 0\n    \n    relative_invariance_tol = 1e-12\n    invariance_check = relative_diff  relative_invariance_tol\n    results.append(invariance_check)\n\n    # --- Symmetry and Positive Semidefiniteness (PSD) Check on Case C ---\n    K_e_C, l_C, k_base_C = get_stiffness_matrix(cases_abc[2], E_modulus, Area)\n    \n    # 1. Symmetry Check\n    is_symmetric = np.allclose(K_e_C, K_e_C.T)\n    \n    # 2. PSD Check: 1 strictly positive eigenvalue, others are 'zero'\n    eigenvalues_C = eigh(K_e_C, eigvals_only=True)\n    eigenvalue_zero_tol_C = 1e-9 * k_base_C\n    \n    # All eigenvalues must be non-negative (within tolerance)\n    are_non_negative = np.all(eigenvalues_C >= -eigenvalue_zero_tol_C)\n    \n    # Exactly one eigenvalue must be strictly positive\n    num_positive_eigs = np.sum(eigenvalues_C > eigenvalue_zero_tol_C)\n    has_one_positive_eig = (num_positive_eigs == 1)\n\n    symmetry_psd_check = is_symmetric and are_non_negative and has_one_positive_eig\n    results.append(symmetry_psd_check)\n    \n    # --- Sign-Convention Mistake Detection ---\n    coords_sign_test = (0.0, 0.0, 1.0, 1.0)\n    \n    K_correct, l_sign, k_base_sign = get_stiffness_matrix(coords_sign_test, E_modulus, Area, sign_error_s=False)\n    K_flawed, _, _ = get_stiffness_matrix(coords_sign_test, E_modulus, Area, sign_error_s=True)\n    \n    # The scale for comparison is k = EA/l\n    zero_tolerance_scale = k_base_sign\n    \n    mistake_diff_norm = np.linalg.norm(K_correct - K_flawed, 'fro')\n    \n    sign_mistake_detected = mistake_diff_norm > zero_tolerance_scale\n    results.append(sign_mistake_detected)\n\n    # --- Degenerate Geometry Detection ---\n    coords_degenerate = (0.0, 0.0, 1e-12, 0.0)\n    \n    _, l_degenerate, _ = get_stiffness_matrix(coords_degenerate, E_modulus, Area)\n    \n    degenerate_length_threshold = 1e-9\n    is_degenerate = l_degenerate  degenerate_length_threshold\n    results.append(is_degenerate)\n    \n    # --- Final Output Formatting ---\n    # Convert booleans to lowercase 'true'/'false' for output\n    formatted_results = []\n    for r in results:\n        if isinstance(r, bool):\n            formatted_results.append(str(r).lower())\n        else:\n            formatted_results.append(f\"{r:.1f}\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3602979"}, {"introduction": "A valid finite element formulation must respect fundamental physical principles. This practice explores a crucial \"sanity check\" by verifying that a small truss assembly generates zero internal forces under rigid-body motion, a direct consequence of the principle of virtual work [@problem_id:3602998]. By intentionally introducing a subtle bug into the coordinate transformation matrix, this exercise provides a powerful lesson on how minor implementation errors can violate physical laws and create non-physical \"spurious stiffness,\" demonstrating the necessity of designing a comprehensive suite of regression tests.", "problem": "A two-dimensional truss element is a straight bar connecting two nodes, each with two degrees of freedom (DOF) in the global coordinate directions. The stiffness formulation for such elements in the Finite Element Method (FEM) must preserve the physical invariance of rigid-body motions, meaning that any uniform translation or uniform rotation of the entire structure should induce zero internal force. Start from the following fundamental bases: (i) small-strain linear elasticity with $ \\sigma = E\\,\\varepsilon $, (ii) bar axial strain $ \\varepsilon = \\frac{du}{dx} $ under small displacement gradients, and (iii) the principle of virtual work equating internal and external work in equilibrium for linear systems. From these, derive the element stiffness in local axial coordinates and then rigorously obtain the global stiffness through an orthogonal transformation that projects global displacements onto the element axis. The transformation relies on the direction cosines $ c = \\Delta x / L $ and $ s = \\Delta y / L $, where $ \\Delta x $ and $ \\Delta y $ are the differences in nodal coordinates and $ L $ is the element length.\n\nDesign a minimal two-element truss that, under pure rigid-body motion, should exhibit zero internal forces. Use three nodes: node $ 0 $ at $(0,0)$, node $ 1 $ at $(1,1)$, and node $ 2 $ at $(1,-1)$, with elements $(0,1)$ and $(0,2)$. Consider two rigid-body motions: a uniform translation by $(t_x,t_y)$ applied to every node, and a uniform infinitesimal rotation by angle $ \\varphi $ about the origin, where each node at $(x_i,y_i)$ moves by $(u_{x,i},u_{y,i}) = \\varphi(-y_i, x_i)$. For a correct transformation from global to local displacements, these motions must yield zero internal forces after assembling the global stiffness matrix and multiplying by the global displacement vector.\n\nTo probe sensitivity to transformation sign errors, define a \"buggy\" transformation that incorrectly flips the sign of the sine term for the projection of the second node. Specifically, the erroneous transformation maps the global displacements of the second node using $ s \\mapsto -s $ in its sine contribution while leaving the cosine contribution unchanged. Show that this single sign error introduces spurious stiffness, i.e., non-zero internal forces arise under pure rigid-body motions.\n\nYou must implement a complete program that:\n- Constructs the global stiffness matrix for a two-dimensional truss structure from first principles, assembling element stiffnesses computed by projecting global DOFs onto the local axial DOFs and then back to the global coordinates. Use both the correct transformation and the buggy transformation described above.\n- Computes the Euclidean norm of the internal force vector $ \\mathbf{r} = \\mathbf{K}\\mathbf{u} $ for specified rigid-body motions, where $ \\mathbf{K} $ is the assembled global stiffness matrix and $ \\mathbf{u} $ is the global displacement vector.\n- Uses the following physical parameters for all elements: Young’s modulus $ E = 7.0\\times 10^{10}\\,\\mathrm{Pa} $, cross-sectional area $ A = 1.0\\times 10^{-4}\\,\\mathrm{m}^2 $.\n- Uses translation $(t_x,t_y) = (0.123\\,\\mathrm{m},-0.456\\,\\mathrm{m})$ and rotation $ \\varphi = 0.2\\,\\mathrm{rad} $.\n- Produces results expressed in newtons ($ \\mathrm{N} $), with angles expressed in radians.\n\nAdditionally, design two more truss variants to act as regression tests:\n1. An axis-aligned variant: nodes $(0,0)$, $(1,0)$, $(-1,0)$ with elements $(0,1)$ and $(0,2)$, which should be insensitive to the sine-sign bug because $ s = 0 $ for all elements.\n2. A near-axis-aligned variant: nodes $(0,0)$, $(1,\\varepsilon)$, $(-1,\\varepsilon)$ with $ \\varepsilon = 10^{-6}\\,\\mathrm{m} $ and elements $(0,1)$ and $(0,2)$, which should exhibit very small but non-zero spurious stiffness under the buggy transformation.\n\nFor each truss variant, compute the Euclidean norms of the internal force vector $ \\|\\mathbf{K}\\mathbf{u}\\|_2 $ for the following cases:\n- Correct transformation under uniform translation and uniform rotation.\n- Buggy transformation under uniform translation and uniform rotation.\n\nOrganize the tests as follows:\n- Variant $ V_1 $ (rotated truss): nodes $(0,0)$, $(1,1)$, $(1,-1)$; elements $(0,1)$ and $(0,2)$; translation and rotation as specified.\n- Variant $ V_2 $ (axis-aligned truss): nodes $(0,0)$, $(1,0)$, $(-1,0)$; elements $(0,1)$ and $(0,2)$; translation and rotation as specified.\n- Variant $ V_3 $ (near-axis truss): nodes $(0,0)$, $(1,\\varepsilon)$, $(-1,\\varepsilon)$ with $ \\varepsilon = 10^{-6}\\,\\mathrm{m} $; elements $(0,1)$ and $(0,2)$; translation and rotation as specified.\n\nYour program must produce a single line of output containing eight comma-separated floats enclosed in square brackets, in the exact order:\n$ [R_{V_1}^{\\text{corr,trans}}, R_{V_1}^{\\text{corr,rot}}, R_{V_1}^{\\text{bug,trans}}, R_{V_1}^{\\text{bug,rot}}, R_{V_2}^{\\text{bug,trans}}, R_{V_2}^{\\text{bug,rot}}, R_{V_3}^{\\text{bug,trans}}, R_{V_3}^{\\text{bug,rot}}] $,\nwhere each $ R $ is the Euclidean norm $ \\|\\mathbf{K}\\mathbf{u}\\|_2 $ in $ \\mathrm{N} $. The axis-aligned variant $ V_2 $ under the buggy transformation should ideally produce exactly zero for both motions, thereby revealing a blind spot in the bug detection, while $ V_3 $ should produce small, non-zero values that scale with $ \\varepsilon $. This output serves as an automated regression test suite to flag such transformation sign bugs.\n\nYour implementation must be self-contained, use only the specified runtime environment, and require no input. The final answer must be a complete runnable program that constructs the three truss variants, assembles the stiffness matrices using both the correct and buggy transformations, applies the specified rigid-body motions, computes the norms in $ \\mathrm{N} $, and prints them in the required final output format on a single line.", "solution": "The central subject of this problem is the formulation of the element stiffness matrix for a two-dimensional truss element within the framework of the Finite Element Method (FEM). A cornerstone of any valid mechanical formulation is its adherence to physical invariance principles, specifically that rigid-body motions—uniform translations or rotations of an undeformed body—must not generate internal stresses or strains. The problem requires a rigorous derivation of the correct stiffness matrix, a demonstration of its invariance property, and an analysis of how a specific, subtle error in the underlying geometric transformation violates this principle, leading to spurious, non-physical internal forces.\n\n### 1. Element Stiffness in Local Coordinates\n\nWe begin with a single truss element, which is a one-dimensional bar. In its local coordinate system, defined by the element's axis $x'$, the element connects two nodes, $1$ and $2$. Each node has a single axial degree of freedom, $u'_1$ and $u'_2$.\n\nUnder the assumption of small displacements, the axial displacement field $u'(x')$ can be linearly interpolated from the nodal displacements:\n$$ u'(x') = (1 - \\frac{x'}{L})u'_1 + (\\frac{x'}{L})u'_2 $$\nwhere $L$ is the element length.\n\nThe axial strain $\\varepsilon$ is the spatial derivative of the displacement field. For this linear interpolation, the strain is constant along the element:\n$$ \\varepsilon = \\frac{du'}{dx'} = \\frac{1}{L}(u'_2 - u'_1) $$\nThis can be written in matrix form as $\\varepsilon = \\mathbf{B}\\mathbf{u'}$, where $\\mathbf{u'} = [u'_1, u'_2]^T$ is the local displacement vector and $\\mathbf{B} = \\frac{1}{L}[-1, 1]$ is the strain-displacement matrix.\n\nAccording to linear elasticity (Hooke's Law for a 1D bar), the axial stress $\\sigma$ is proportional to the strain: $\\sigma = E\\varepsilon$, where $E$ is Young's modulus.\n\nThe relationship between nodal forces $\\mathbf{f'} = [f'_1, f'_2]^T$ and nodal displacements $\\mathbf{u'}$ is given by the local element stiffness matrix $\\mathbf{k'}$, such that $\\mathbf{f'} = \\mathbf{k'}\\mathbf{u'}$. Using the principle of virtual work or strain energy methods, $\\mathbf{k'}$ is derived as:\n$$ \\mathbf{k'} = \\int_V \\mathbf{B}^T E \\mathbf{B} \\,dV = A \\int_0^L \\mathbf{B}^T E \\mathbf{B} \\,dx' $$\nwhere $A$ is the cross-sectional area. Substituting $\\mathbf{B}$ yields:\n$$ \\mathbf{k'} = A \\int_0^L \\frac{1}{L^2} \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} E \\begin{pmatrix} -1  1 \\end{pmatrix} dx' = \\frac{AE}{L^2} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} \\int_0^L dx' = \\frac{AE}{L} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} $$\nThis is the standard $2 \\times 2$ stiffness matrix for a bar element in its local coordinate system.\n\n### 2. Transformation to Global Coordinates\n\nIn a two-dimensional analysis, each node $i$ has two global degrees of freedom, $(u_{ix}, u_{iy})$. The element's orientation is defined by the angle $\\theta$ it makes with the global x-axis, or equivalently by its direction cosines:\n$$ c = \\cos\\theta = \\frac{x_j - x_i}{L} \\quad \\text{and} \\quad s = \\sin\\theta = \\frac{y_j - y_i}{L} $$\nwhere nodes $i$ and $j$ are the element's endpoints.\n\nThe axial displacement of a node is the projection of its global displacement vector onto the element's axis. Thus, the local axial displacements $u'_i$ and $u'_j$ are related to the global displacements $\\mathbf{u}_e = [u_{ix}, u_{iy}, u_{jx}, u_{jy}]^T$ by a transformation matrix $\\mathbf{T}$:\n$$ \\mathbf{u'} = \\begin{pmatrix} u'_i \\\\ u'_j \\end{pmatrix} = \\begin{pmatrix} c  s  0  0 \\\\ 0  0  c  s \\end{pmatrix} \\begin{pmatrix} u_{ix} \\\\ u_{iy} \\\\ u_{jx} \\\\ u_{jy} \\end{pmatrix} = \\mathbf{T}\\mathbf{u}_e $$\nThe principle of work equivalence states that the work done by global forces and local forces must be equal, $\\mathbf{u'}^T\\mathbf{f'} = \\mathbf{u}_e^T\\mathbf{f}_e$. This yields the transformation for forces: $\\mathbf{f}_e = \\mathbf{T}^T\\mathbf{f'}$.\n\nSubstituting these relations, we get $\\mathbf{f}_e = \\mathbf{T}^T(\\mathbf{k'}\\mathbf{u'}) = \\mathbf{T}^T\\mathbf{k'}(\\mathbf{T}\\mathbf{u}_e)$. Therefore, the element stiffness matrix in global coordinates, $\\mathbf{k}_e$, is:\n$$ \\mathbf{k}_e = \\mathbf{T}^T\\mathbf{k'}\\mathbf{T} $$\nPerforming this matrix multiplication:\n$$ \\mathbf{k}_e = \\frac{AE}{L} \\begin{pmatrix} c  0 \\\\ s  0 \\\\ 0  c \\\\ 0  s \\end{pmatrix} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} \\begin{pmatrix} c  s  0  0 \\\\ 0  0  c  s \\end{pmatrix} = \\frac{AE}{L} \\begin{pmatrix}\nc^2  cs  -c^2  -cs \\\\\ncs  s^2  -cs  -s^2 \\\\\n-c^2  -cs  c^2  cs \\\\\n-cs  -s^2  cs  s^2\n\\end{pmatrix} $$\nThis matrix is symmetric and correctly relates the four global degrees of freedom of the element. A key property of $\\mathbf{k}_e$ is that the sum of the elements in any row or column is zero. This ensures that a uniform translation, where all nodes have the same displacement $(t_x, t_y)$, results in zero net forces, as $\\mathbf{k}_e [t_x, t_y, t_x, t_y]^T = \\mathbf{0}$. The formulation also correctly yields zero force for infinitesimal rotations, as the net change in element length is zero to first order.\n\n### 3. The \"Buggy\" Transformation and Spurious Stiffness\n\nThe problem introduces an erroneous transformation matrix, $\\mathbf{T}_{bug}$, where the sign of the sine term for the projection of the second node (node $j$) is flipped:\n$$ \\mathbf{T}_{bug} = \\begin{pmatrix} c  s  0  0 \\\\ 0  0  c  -s \\end{pmatrix} $$\nThis seemingly minor sign error corresponds to an inconsistent geometric assumption. The resulting \"buggy\" element stiffness matrix, $\\mathbf{k}_{e,bug}$, is derived similarly:\n$$ \\mathbf{k}_{e,bug} = \\mathbf{T}_{bug}^T \\mathbf{k'} \\mathbf{T}_{bug} $$\nLet's define a vector $\\mathbf{v}_{bug} = (\\begin{pmatrix}1  -1\\end{pmatrix} \\mathbf{T}_{bug})^T = [c, s, -c, s]^T$. Then the buggy stiffness matrix is the outer product $\\mathbf{k}_{e,bug} = \\frac{AE}{L} \\mathbf{v}_{bug}\\mathbf{v}_{bug}^T$, which results in:\n$$ \\mathbf{k}_{e,bug} = \\frac{AE}{L} \\begin{pmatrix}\nc^2  cs  -c^2  cs \\\\\ncs  s^2  -cs  s^2 \\\\\n-c^2  -cs  c^2  -cs \\\\\ncs  s^2  -cs  s^2\n\\end{pmatrix} $$\nWhile this matrix is still symmetric, it no longer possesses the zero-row-sum property. The sum of any row is proportional to $2s$. Specifically, the sum of row $i$ is proportional to $(\\mathbf{v}_{bug})_i \\sum_j (\\mathbf{v}_{bug})_j = (\\mathbf{v}_{bug})_i (c+s-c+s) = 2s(\\mathbf{v}_{bug})_i$. This sum is non-zero if $s \\neq 0$. Consequently, when a uniform translation is applied, $\\mathbf{k}_{e,bug} [t_x, t_y, t_x, t_y]^T \\neq \\mathbf{0}$, producing spurious, non-physical internal forces. This violates the principle of translational invariance. A similar analysis shows violation of rotational invariance.\n\n### 4. System Assembly and Analysis\n\nThe global stiffness matrix $\\mathbf{K}$ for the entire structure is assembled by summing the contributions from all element stiffness matrices $\\mathbf{k}_e$ according to their nodal connectivity. The total internal force vector for the structure under a prescribed global displacement vector $\\mathbf{u}$ is $\\mathbf{r} = \\mathbf{K}\\mathbf{u}$.\n\nThe problem requires calculating the Euclidean norm of this force vector, $\\|\\mathbf{r}\\|_2$, for three truss variants under both translation and rotation, using both the correct and buggy stiffness formulations.\n\n- **V1 (Rotated Truss)**: Elements have non-zero $s$ values, so the bug will manifest for both translation and rotation.\n- **V2 (Axis-Aligned Truss)**: Elements are aligned with the x-axis, so $s = 0$ for all. The buggy transformation becomes identical to the correct one ($c \\pm s = c \\pm 0$), making the bug undetectable in this configuration. $\\|\\mathbf{r}\\|_2$ should be zero.\n- **V3 (Near-Axis Truss)**: Elements have a very small but non-zero $s = \\varepsilon/L$. The buggy formulation will produce small, non-zero spurious forces, demonstrating the sensitivity of the error to orientation.\n\nFor the correct formulation, $\\|\\mathbf{K}_{corr}\\mathbf{u}_{RBM}\\|_2$ must be zero (within floating-point precision) for any rigid-body motion (RBM). For the buggy formulation, $\\|\\mathbf{K}_{bug}\\mathbf{u}_{RBM}\\|_2$ will be non-zero if any element has $s \\neq 0$, exposing the flaw. The following program implements this validation procedure.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_element_stiffness(p1, p2, E, A, buggy):\n    \"\"\"\n    Computes the 4x4 element stiffness matrix in global coordinates.\n\n    Args:\n        p1 (tuple): Coordinates of the first node (x1, y1).\n        p2 (tuple): Coordinates of the second node (x2, y2).\n        E (float): Young's modulus.\n        A (float): Cross-sectional area.\n        buggy (bool): If True, use the buggy transformation matrix.\n\n    Returns:\n        numpy.ndarray: The 4x4 element stiffness matrix.\n    \"\"\"\n    dx = p2[0] - p1[0]\n    dy = p2[1] - p1[1]\n    L = np.sqrt(dx**2 + dy**2)\n\n    if np.isclose(L, 0):\n        return np.zeros((4, 4))\n\n    c = dx / L\n    s = dy / L\n\n    # Local 2x2 stiffness matrix\n    k_prime_factor = E * A / L\n    k_prime = k_prime_factor * np.array([[1, -1], [-1, 1]])\n\n    # Transformation matrix from global to local displacements\n    if buggy:\n        # Buggy transformation: flips the sign of 's' for the second node\n        T = np.array([[c, s, 0, 0], [0, 0, c, -s]])\n    else:\n        # Correct transformation\n        T = np.array([[c, s, 0, 0], [0, 0, c, s]])\n        \n    # Element stiffness matrix in global coordinates: k_e = T.T @ k_prime @ T\n    k_e = T.T @ k_prime @ T\n    \n    return k_e\n\ndef assemble_global_stiffness(nodes, elements, E, A, buggy):\n    \"\"\"\n    Assembles the global stiffness matrix for the truss structure.\n\n    Args:\n        nodes (list of tuples): List of nodal coordinates.\n        elements (list of tuples): List of elements defined by node indices.\n        E (float): Young's modulus.\n        A (float): Cross-sectional area.\n        buggy (bool): If True, use the buggy element stiffness formulation.\n\n    Returns:\n        numpy.ndarray: The global stiffness matrix.\n    \"\"\"\n    num_nodes = len(nodes)\n    num_dofs = 2 * num_nodes\n    K = np.zeros((num_dofs, num_dofs))\n\n    for n1, n2 in elements:\n        p1 = nodes[n1]\n        p2 = nodes[n2]\n        k_e = get_element_stiffness(p1, p2, E, A, buggy)\n\n        # Map local DOFs to global DOFs\n        dof_map = [2 * n1, 2 * n1 + 1, 2 * n2, 2 * n2 + 1]\n        \n        # Add element stiffness to global matrix\n        for i_local in range(4):\n            for j_local in range(4):\n                i_global = dof_map[i_local]\n                j_global = dof_map[j_local]\n                K[i_global, j_global] += k_e[i_local, j_local]\n    \n    return K\n\ndef get_displacement_vectors(nodes, t_vec, phi):\n    \"\"\"\n    Generates global displacement vectors for rigid-body motions.\n\n    Args:\n        nodes (list of tuples): List of nodal coordinates.\n        t_vec (tuple): Translation vector (tx, ty).\n        phi (float): Infinitesimal rotation angle in radians.\n\n    Returns:\n        tuple: (u_translation, u_rotation) as numpy arrays.\n    \"\"\"\n    num_nodes = len(nodes)\n    num_dofs = 2 * num_nodes\n    u_trans = np.zeros(num_dofs)\n    u_rot = np.zeros(num_dofs)\n\n    tx, ty = t_vec\n    for i, (x, y) in enumerate(nodes):\n        # Uniform translation\n        u_trans[2 * i] = tx\n        u_trans[2 * i + 1] = ty\n        \n        # Infinitesimal rotation about the origin\n        u_rot[2 * i] = -phi * y\n        u_rot[2 * i + 1] = phi * x\n        \n    return u_trans, u_rot\n\ndef solve():\n    \"\"\"\n    Main function to execute the problem's requirements.\n    \"\"\"\n    # Physical and motion parameters\n    E = 7.0e10  # Pa\n    A = 1.0e-4  # m^2\n    translation_vec = (0.123, -0.456)  # m\n    rotation_angle = 0.2  # rad\n    epsilon = 1.0e-6 # m\n\n    # Define truss variants\n    variants = {\n        \"V1\": {\n            \"nodes\": [(0.0, 0.0), (1.0, 1.0), (1.0, -1.0)],\n            \"elements\": [(0, 1), (0, 2)],\n        },\n        \"V2\": {\n            \"nodes\": [(0.0, 0.0), (1.0, 0.0), (-1.0, 0.0)],\n            \"elements\": [(0, 1), (0, 2)],\n        },\n        \"V3\": {\n            \"nodes\": [(0.0, 0.0), (1.0, epsilon), (-1.0, epsilon)],\n            \"elements\": [(0, 1), (0, 2)],\n        },\n    }\n\n    results = []\n\n    # --- Variant V1: Rotated Truss ---\n    v1_spec = variants[\"V1\"]\n    v1_nodes = v1_spec[\"nodes\"]\n    v1_elements = v1_spec[\"elements\"]\n    u_trans_v1, u_rot_v1 = get_displacement_vectors(v1_nodes, translation_vec, rotation_angle)\n\n    # Correct transformation\n    K_corr_v1 = assemble_global_stiffness(v1_nodes, v1_elements, E, A, buggy=False)\n    r_corr_trans_v1 = K_corr_v1 @ u_trans_v1\n    r_corr_rot_v1 = K_corr_v1 @ u_rot_v1\n    results.append(np.linalg.norm(r_corr_trans_v1))\n    results.append(np.linalg.norm(r_corr_rot_v1))\n\n    # Buggy transformation\n    K_bug_v1 = assemble_global_stiffness(v1_nodes, v1_elements, E, A, buggy=True)\n    r_bug_trans_v1 = K_bug_v1 @ u_trans_v1\n    r_bug_rot_v1 = K_bug_v1 @ u_rot_v1\n    results.append(np.linalg.norm(r_bug_trans_v1))\n    results.append(np.linalg.norm(r_bug_rot_v1))\n    \n    # --- Variant V2: Axis-Aligned Truss ---\n    v2_spec = variants[\"V2\"]\n    v2_nodes = v2_spec[\"nodes\"]\n    v2_elements = v2_spec[\"elements\"]\n    u_trans_v2, u_rot_v2 = get_displacement_vectors(v2_nodes, translation_vec, rotation_angle)\n\n    # Buggy transformation (Correct is guaranteed to be 0)\n    K_bug_v2 = assemble_global_stiffness(v2_nodes, v2_elements, E, A, buggy=True)\n    r_bug_trans_v2 = K_bug_v2 @ u_trans_v2\n    r_bug_rot_v2 = K_bug_v2 @ u_rot_v2\n    results.append(np.linalg.norm(r_bug_trans_v2))\n    results.append(np.linalg.norm(r_bug_rot_v2))\n\n    # --- Variant V3: Near-Axis-Aligned Truss ---\n    v3_spec = variants[\"V3\"]\n    v3_nodes = v3_spec[\"nodes\"]\n    v3_elements = v3_spec[\"elements\"]\n    u_trans_v3, u_rot_v3 = get_displacement_vectors(v3_nodes, translation_vec, rotation_angle)\n\n    # Buggy transformation\n    K_bug_v3 = assemble_global_stiffness(v3_nodes, v3_elements, E, A, buggy=True)\n    r_bug_trans_v3 = K_bug_v3 @ u_trans_v3\n    r_bug_rot_v3 = K_bug_v3 @ u_rot_v3\n    results.append(np.linalg.norm(r_bug_trans_v3))\n    results.append(np.linalg.norm(r_bug_rot_v3))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```", "id": "3602998"}, {"introduction": "Beyond satisfying rigid-body invariance, a reliable element formulation must be able to accurately represent basic states of deformation. This practice introduces the patch test, a cornerstone of finite element verification that is a necessary condition for proving convergence [@problem_id:3603016]. You will impose a linear displacement field on a patch of elements and verify that your formulation can exactly reproduce the corresponding constant strain state, providing confidence that the element can serve as a valid basis for analyzing more complex, non-uniform strain fields.", "problem": "Design and implement a two-dimensional truss patch test that verifies exact reproduction of a uniform linear displacement (constant strain) field by the assembled global stiffness matrix and diagnoses failures arising from errors in the transformation between local and global coordinates. Your implementation must adhere to the following specifications.\n\nStart from fundamental small-strain kinematics and the Principle of Virtual Work (PVW), and use one-dimensional axial linear elasticity for each bar. Consider a planar truss wherein each element carries only axial force. For a node at position $(x,y)$, define a linear displacement field that produces a uniform isotropic strain: $u(x,y)=\\epsilon_0 x$ and $v(x,y)=\\epsilon_0 y$, where $\\epsilon_0$ is a given scalar. Under this field, the small-strain tensor is uniform with $ \\varepsilon_{xx}=\\epsilon_0$, $\\varepsilon_{yy}=\\epsilon_0$, $\\varepsilon_{xy}=0$, so that the axial strain of any bar with unit direction vector $\\mathbf{n}=[c,s]^T$ is $ \\epsilon_{\\text{axial}}=\\mathbf{n}^T \\boldsymbol{\\varepsilon} \\, \\mathbf{n} = \\epsilon_0$. Your program must verify that the finite element truss formulation reproduces this exactly.\n\nGeometry and material:\n- Nodes: a uniform $3\\times 3$ grid with spacing $L = 1.0$ meters, i.e., coordinates $(i L, j L)$ for $i,j \\in \\{0,1,2\\}$.\n- Elements: for cases that include diagonals, connect horizontal neighbors, vertical neighbors, and both diagonals in each $1\\times 1$ square cell. For cases without diagonals, include only horizontal and vertical neighbors.\n- Material: Young’s modulus $E = 210 \\times 10^9$ pascals and cross-sectional area $A = 1.0\\times 10^{-4}$ square meters for all elements.\n\nBoundary conditions and exact field:\n- Prescribe essential boundary conditions (Dirichlet) on all boundary nodes to match the exact linear field $u(x,y)=\\epsilon_0 x$, $v(x,y)=\\epsilon_0 y$. Keep the single interior node at $(L,L)$ free.\n- Assemble the global stiffness matrix $K$ from element contributions using a correct transformation from local axial coordinates to global $(u_x,u_y)$ degrees of freedom.\n- Solve for the free degrees of freedom and compare against the exact field evaluated at those nodes.\n\nValidation criteria for a patch test pass:\n- Displacement reproduction: the computed free-node displacements match the exact field to within a relative tolerance of $1.0\\times 10^{-10}$, using an absolute fallback tolerance of $1.0\\times 10^{-12}$ when the exact norm is zero. Formally, if $\\mathbf{u}_f$ is the computed vector of free degrees of freedom and $\\mathbf{u}_{f}^{\\text{exact}}$ is the exact one, require $\\|\\mathbf{u}_f-\\mathbf{u}_{f}^{\\text{exact}}\\|_2 \\le \\max( 1.0\\times 10^{-10}\\|\\mathbf{u}_{f}^{\\text{exact}}\\|_2, 1.0\\times 10^{-12})$.\n- Uniform axial strain: for every element, compute axial strain from nodal displacements as $\\epsilon_e = \\dfrac{\\mathbf{n}^T(\\mathbf{u}_j-\\mathbf{u}_i)}{L_e}$, where $L_e$ is the element length and $\\mathbf{u}_i,\\mathbf{u}_j$ are nodal displacement vectors. Require $|\\epsilon_e-\\epsilon_0| \\le \\max( 1.0\\times 10^{-10}|\\epsilon_0|, 1.0\\times 10^{-12})$ for all elements.\n\nFailure diagnosis via transformation errors:\n- To expose transformation-matrix mistakes, also assemble $K$ using an intentionally erroneous transformation in which the direction cosines are swapped, i.e., use $c_{\\text{bug}}=\\Delta y/L$ and $s_{\\text{bug}}=\\Delta x/L$ in place of the correct $c=\\Delta x/L$ and $s=\\Delta y/L$. With this bug, at least one of the above criteria must fail for a nontrivial $\\epsilon_0$.\n\nTest suite:\nImplement the following four cases, each case yielding a boolean indicating whether the patch test passes.\n- Case $1$: diagonals included, correct transformation, $\\epsilon_0=1.0\\times 10^{-4}$.\n- Case $2$: diagonals included, erroneous (swapped) transformation, $\\epsilon_0=1.0\\times 10^{-4}$.\n- Case $3$: no diagonals, correct transformation, $\\epsilon_0=5.0\\times 10^{-5}$.\n- Case $4$: diagonals included, correct transformation, $\\epsilon_0=0.0$.\n\nUnits and outputs:\n- All distances are in meters, forces in newtons, stresses in pascals, strains dimensionless, and displacements in meters. Angles must be treated implicitly via direction cosines; do not use degrees or radians explicitly.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[\\text{true},\\text{false},\\text{true}]$, but with Python boolean capitalization), corresponding to Cases $1$ through $4$ in order.\n\nRestrictions:\n- The final answer must be a complete, runnable program that assembles the truss stiffness matrix, applies boundary conditions, solves for free degrees of freedom, computes the diagnostic quantities, and prints the final results in the exact required format.", "solution": "The problem requires the design and implementation of a patch test for a two-dimensional truss structure. The patch test is a fundamental verification procedure in the finite element method (FEM) used to ensure that an element formulation can exactly reproduce a constant strain state. Passing the patch test is a necessary condition for the convergence of a finite element. This solution details the theoretical derivation and algorithmic implementation for this test.\n\nThe foundation of the displacement-based finite element method is the Principle of Virtual Work (PVW), which states that a body is in equilibrium if, for any kinematically admissible virtual displacement field, the internal virtual work equals the external virtual work. For a linearly elastic body without body forces, this is expressed as:\n$$\n\\int_V \\delta\\boldsymbol{\\varepsilon}^T \\boldsymbol{\\sigma} \\, dV = \\delta\\mathbf{u}^T \\mathbf{F}\n$$\nwhere $\\boldsymbol{\\sigma}$ is the stress tensor, $\\delta\\boldsymbol{\\varepsilon}$ is the virtual strain tensor corresponding to the virtual displacements $\\delta\\mathbf{u}$, and $\\mathbf{F}$ is the vector of external nodal forces.\n\nFor a one-dimensional truss element oriented along a local axis $x'$, the stress and strain are purely axial. Using the constitutive relation $\\sigma' = E \\epsilon'$, where $E$ is Young's modulus, the PVW for an element of length $L_e$ and constant cross-sectional area $A$ simplifies to:\n$$\n\\int_0^{L_e} (A E \\epsilon') \\delta\\epsilon' \\, dx' = \\delta\\mathbf{u}'_{\\text{local}}^T \\mathbf{f}'_{\\text{local}}\n$$\nThe axial strain $\\epsilon'$ is assumed to be constant along the element and is given by the change in length divided by the original length. For an element with local nodal displacements $d'_1$ and $d'_2$ at its two ends, the strain is $\\epsilon' = (d'_2 - d'_1) / L_e$. The virtual strain is $\\delta\\epsilon' = (\\delta d'_2 - \\delta d'_1) / L_e$. Substituting these into the integral and performing the integration yields:\n$$\n\\frac{AE}{L_e} (d'_2 - d'_1) (\\delta d'_2 - \\delta d'_1) = f'_1 \\delta d'_1 + f'_2 \\delta d'_2\n$$\nBy matching coefficients of the independent virtual displacements $\\delta d'_1$ and $\\delta d'_2$, we obtain the nodal force-displacement relationship in the local coordinate system:\n$$\n\\begin{pmatrix} f'_1 \\\\ f'_2 \\end{pmatrix} = \\frac{AE}{L_e} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} \\begin{pmatrix} d'_1 \\\\ d'_2 \\end{pmatrix}\n$$\nThis defines the local element stiffness matrix $\\mathbf{k}'_e = \\frac{AE}{L_e} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}$.\n\nTo use this in a two-dimensional analysis, we must transform it to the global $(x, y)$ coordinate system. Let the element connect node $1$ at $(x_1, y_1)$ to node $2$ at $(x_2, y_2)$. The element's orientation is defined by its direction cosines: $c = \\cos\\theta = \\frac{\\Delta x}{L_e}$ and $s = \\sin\\theta = \\frac{\\Delta y}{L_e}$, where $\\Delta x = x_2 - x_1$, $\\Delta y = y_2 - y_1$, and $L_e = \\sqrt{\\Delta x^2 + \\Delta y^2}$. The global displacement vector for the element is $\\mathbf{d}_e = [u_1, v_1, u_2, v_2]^T$. The local axial displacement at each node is the projection of the global displacement vector onto the element's axis:\n$$\nd'_1 = u_1 c + v_1 s \\quad , \\quad d'_2 = u_2 c + v_2 s\n$$\nThe element strain energy is $U_e = \\frac{1}{2} \\mathbf{d}'^T \\mathbf{k}'_e \\mathbf{d}' = \\frac{1}{2} \\frac{AE}{L_e} (d'_2 - d'_1)^2$. Substituting the expressions for $d'_1$ and $d'_2$:\n$$\nU_e = \\frac{1}{2} \\frac{AE}{L_e} \\left( (u_2 - u_1)c + (v_2 - v_1)s \\right)^2\n$$\nThe global element stiffness matrix $\\mathbf{k}_e$ is the Hessian of the strain energy with respect to the global nodal displacements, $\\mathbf{k}_e(i,j) = \\frac{\\partial^2 U_e}{\\partial d_i \\partial d_j}$. Performing this differentiation yields the $4 \\times 4$ global element stiffness matrix:\n$$\n\\mathbf{k}_e = \\frac{EA}{L_e}\n\\begin{pmatrix}\nc^2  cs  -c^2  -cs \\\\\ncs  s^2  -cs  -s^2 \\\\\n-c^2  -cs  c^2  cs \\\\\n-cs  -s^2  cs  s^2\n\\end{pmatrix}\n$$\nThe global stiffness matrix $\\mathbf{K}$ for the entire truss structure is assembled by summing the contributions from each element's $\\mathbf{k}_e$ into the appropriate locations corresponding to the element's global degrees of freedom (DOFs). This results in the global system of linear equations $\\mathbf{K}\\mathbf{u} = \\mathbf{F}$, where $\\mathbf{u}$ is the vector of all global nodal displacements and $\\mathbf{F}$ is the vector of all external nodal forces.\n\nFor the patch test, boundary conditions are applied. We partition the DOFs into a set of free (unknown) DOFs, subscripted $f$, and a set of prescribed (known) DOFs, subscripted $p$. The global system is re-written as:\n$$\n\\begin{pmatrix} \\mathbf{K}_{ff}  \\mathbf{K}_{fp} \\\\ \\mathbf{K}_{pf}  \\mathbf{K}_{pp} \\end{pmatrix}\n\\begin{pmatrix} \\mathbf{u}_f \\\\ \\mathbf{u}_p \\end{pmatrix} =\n\\begin{pmatrix} \\mathbf{F}_f \\\\ \\mathbf{F}_p \\end{pmatrix}\n$$\nThe problem specifies a $3 \\times 3$ grid of nodes with spacing $L=1.0$. All $8$ boundary nodes have their displacements prescribed to match the exact linear field $u(x,y)=\\epsilon_0 x$ and $v(x,y)=\\epsilon_0 y$. This leaves the single interior node at $(L, L)$ as the only node with free DOFs. No external forces are applied to this interior node, so $\\mathbf{F}_f = \\mathbf{0}$. The equation for the unknown displacements $\\mathbf{u}_f$ is extracted from the top partition:\n$$\n\\mathbf{K}_{ff} \\mathbf{u}_f + \\mathbf{K}_{fp} \\mathbf{u}_p = \\mathbf{F}_f = \\mathbf{0}\n$$\nThis is solved for $\\mathbf{u}_f$:\n$$\n\\mathbf{K}_{ff} \\mathbf{u}_f = - \\mathbf{K}_{fp} \\mathbf{u}_p\n$$\nThe computed $\\mathbf{u}_f$ must then be validated against two criteria. First, it must match the exact displacement for the free node, $\\mathbf{u}_{f}^{\\text{exact}} = [\\epsilon_0 L, \\epsilon_0 L]^T$, within a specified tolerance: $\\|\\mathbf{u}_f - \\mathbf{u}_{f}^{\\text{exact}}\\|_2 \\le \\max(1.0\\times 10^{-10}\\|\\mathbf{u}_{f}^{\\text{exact}}\\|_2, 1.0\\times 10^{-12})$. Second, the axial strain $\\epsilon_e$ in every element, computed from the full displacement field (both computed $\\mathbf{u}_f$ and prescribed $\\mathbf{u}_p$), must match the exact constant strain $\\epsilon_0$:\n$$\n\\epsilon_e = \\frac{\\mathbf{n}^T(\\mathbf{u}_j-\\mathbf{u}_i)}{L_e}\n$$\nwhere $\\mathbf{u}_i$ and $\\mathbf{u}_j$ are the full displacement vectors at the element's nodes and $\\mathbf{n}$ is the element's unit direction vector. This must satisfy $|\\epsilon_e-\\epsilon_0| \\le \\max(1.0\\times 10^{-10}|\\epsilon_0|, 1.0\\times 10^{-12})$ for all elements. A test case passes only if both the displacement and strain criteria are met.\n\nTo diagnose implementation errors, a test case is included where the element stiffness matrix is assembled using an intentionally flawed transformation: the direction cosines are swapped ($c_{\\text{bug}}=s$, $s_{\\text{bug}}=c$). For any element not at a $45^\\circ$ angle (where $c=s$), this introduces an error into $\\mathbf{k}_e$ and consequently into the global matrix $\\mathbf{K}$. This incorrect stiffness representation leads to an erroneous force balance at the free node, causing the computed displacement $\\mathbf{u}_f$ to deviate from the exact solution, thus failing the test. This demonstrates the sensitivity of the FEM formulation to the correct coordinate transformation. The implementation will proceed by constructing the required node/element geometry, assembling $\\mathbf{K}$ according to the case specifications, partitioning the system, solving for $\\mathbf{u}_f$, and conducting the validation checks.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the truss patch test suite and print results.\n    \"\"\"\n\n    def get_geometry(include_diagonals, L):\n        \"\"\"\n        Generates the nodal coordinates and element connectivity for the 3x3 grid.\n        \n        Args:\n            include_diagonals (bool): If True, adds diagonal elements to the mesh.\n            L (float): The spacing between nodes in the grid.\n        \n        Returns:\n            tuple: A tuple containing:\n                - nodes (np.ndarray): An array of node coordinates (N x 2).\n                - elements (list): A list of tuples, where each tuple contains the \n                                   indices of the two nodes connected by an element.\n        \"\"\"\n        # Node coordinates for a 3x3 grid, numbered 0-8 row by row from bottom-left\n        nodes = np.array([[i * L, j * L] for j in range(3) for i in range(3)])\n\n        # Element connectivity\n        elements = []\n        # Horizontal elements\n        for j in range(3):\n            for i in range(2):\n                elements.append((j * 3 + i, j * 3 + i + 1))\n        # Vertical elements\n        for i in range(3):\n            for j in range(2):\n                elements.append((j * 3 + i, (j + 1) * 3 + i))\n\n        if include_diagonals:\n            # Diagonal elements for each 1x1 cell\n            for j in range(2):\n                for i in range(2):\n                    n_bl = j * 3 + i        # bottom-left node of cell\n                    n_br = j * 3 + i + 1    # bottom-right\n                    n_tl = (j + 1) * 3 + i  # top-left\n                    n_tr = (j + 1) * 3 + i + 1 # top-right\n                    elements.append((n_bl, n_tr)) # up-sloping diagonal\n                    elements.append((n_br, n_tl)) # down-sloping diagonal\n        \n        return nodes, elements\n\n    def run_patch_test(include_diagonals, use_buggy_transform, epsilon_0):\n        \"\"\"\n        Performs a single patch test case.\n        \n        Args:\n            include_diagonals (bool): Flag to include diagonal elements.\n            use_buggy_transform (bool): Flag to use the erroneous transformation matrix.\n            epsilon_0 (float): The magnitude of the uniform isotropic strain.\n            \n        Returns:\n            bool: True if the patch test passes, False otherwise.\n        \"\"\"\n        # Material and geometric properties\n        L = 1.0  # meters\n        E = 210.0e9  # Pascals\n        A = 1.0e-4   # square meters\n\n        nodes, elements = get_geometry(include_diagonals, L)\n        num_nodes = len(nodes)\n        num_dofs = 2 * num_nodes\n        K = np.zeros((num_dofs, num_dofs))\n\n        # Assemble global stiffness matrix K\n        for n1_idx, n2_idx in elements:\n            p1 = nodes[n1_idx]\n            p2 = nodes[n2_idx]\n            \n            delta = p2 - p1\n            length = np.linalg.norm(delta)\n            \n            c = delta[0] / length\n            s = delta[1] / length\n\n            if use_buggy_transform:\n                c_trans, s_trans = s, c # Intentionally swapped cosines\n            else:\n                c_trans, s_trans = c, s\n\n            k_const = E * A / length\n            \n            c2 = c_trans**2\n            s2 = s_trans**2\n            cs = c_trans * s_trans\n\n            k_e_4x4 = k_const * np.array([\n                [ c2,  cs, -c2, -cs],\n                [ cs,  s2, -cs, -s2],\n                [-c2, -cs,  c2,  cs],\n                [-cs, -s2,  cs,  s2]\n            ])\n\n            dof_indices = [2 * n1_idx, 2 * n1_idx + 1, 2 * n2_idx, 2 * n2_idx + 1]\n            K[np.ix_(dof_indices, dof_indices)] += k_e_4x4\n\n        # Apply boundary conditions and partition the system\n        free_node_idx = 4  # The central node at (L, L)\n        free_dofs = [2 * free_node_idx, 2 * free_node_idx + 1]\n        all_dofs = list(range(num_dofs))\n        prescribed_dofs = sorted(list(set(all_dofs) - set(free_dofs)))\n\n        # Construct vector of prescribed displacements u_p\n        u_p = np.zeros(len(prescribed_dofs))\n        for i, dof in enumerate(prescribed_dofs):\n            node_idx = dof // 2\n            dof_type = dof % 2  # 0 for x-dof, 1 for y-dof\n            u_p[i] = epsilon_0 * nodes[node_idx, dof_type]\n        \n        # Extract submatrices for solving the free DOFs\n        K_ff = K[np.ix_(free_dofs, free_dofs)]\n        K_fp = K[np.ix_(free_dofs, prescribed_dofs)]\n        \n        # Solve for free displacements u_f\n        # System: K_ff * u_f = -K_fp * u_p\n        rhs = -K_fp @ u_p\n        \n        # Check if K_ff is singular, although not expected for these structures\n        if np.linalg.cond(K_ff) > 1/np.finfo(K_ff.dtype).eps:\n             return False # Unstable structure case\n        \n        u_f = np.linalg.solve(K_ff, rhs)\n\n        # --- Validation Phase ---\n\n        # 1. Displacement reproduction check\n        node_f_coords = nodes[free_node_idx]\n        u_f_exact = epsilon_0 * node_f_coords\n        \n        disp_err_norm = np.linalg.norm(u_f - u_f_exact)\n        u_f_exact_norm = np.linalg.norm(u_f_exact)\n        disp_tol = max(1.0e-10 * u_f_exact_norm, 1.0e-12)\n        \n        disp_check_passed = disp_err_norm = disp_tol\n\n        # 2. Uniform axial strain check\n        # Reconstruct the full displacement vector u to calculate strains\n        u_full = np.zeros(num_dofs)\n        u_full[free_dofs] = u_f\n        u_full[prescribed_dofs] = u_p\n        \n        strain_check_passed = True\n        for n1_idx, n2_idx in elements:\n            p1 = nodes[n1_idx]\n            p2 = nodes[n2_idx]\n            \n            delta = p2 - p1\n            length = np.linalg.norm(delta)\n            \n            # Strain calculation must always use the correct direction cosines\n            c_correct = delta[0] / length\n            s_correct = delta[1] / length\n            \n            u1_vec = u_full[2 * n1_idx : 2 * n1_idx + 2]\n            u2_vec = u_full[2 * n2_idx : 2 * n2_idx + 2]\n            \n            delta_u = u2_vec - u1_vec\n            n_vec = np.array([c_correct, s_correct])\n            \n            # Strain is projection of relative displacement onto element axis, divided by length\n            epsilon_e = (n_vec @ delta_u) / length\n            \n            strain_err = abs(epsilon_e - epsilon_0)\n            strain_tol = max(1.0e-10 * abs(epsilon_0), 1.0e-12)\n            \n            if strain_err > strain_tol:\n                strain_check_passed = False\n                break  # Fail fast\n                \n        return disp_check_passed and strain_check_passed\n\n    # Define the test suite\n    test_cases = [\n        # Case 1: Diagonals, correct transform, non-zero strain\n        {'include_diagonals': True, 'use_buggy_transform': False, 'epsilon_0': 1.0e-4},\n        # Case 2: Diagonals, erroneous transform, non-zero strain\n        {'include_diagonals': True, 'use_buggy_transform': True, 'epsilon_0': 1.0e-4},\n        # Case 3: No diagonals, correct transform, non-zero strain\n        {'include_diagonals': False, 'use_buggy_transform': False, 'epsilon_0': 5.0e-5},\n        # Case 4: Diagonals, correct transform, zero strain\n        {'include_diagonals': True, 'use_buggy_transform': False, 'epsilon_0': 0.0},\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_patch_test(**params)\n        results.append(result)\n\n    # Format and print the final output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3603016"}]}