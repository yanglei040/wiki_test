{"hands_on_practices": [{"introduction": "Before deploying a finite element in complex simulations, we must ensure its fundamental correctness. The patch test serves as an essential benchmark, verifying that the element can exactly reproduce a constant strain state, which is the simplest non-trivial physical response. In this practice [@problem_id:3583985], you will implement a patch test to confirm this capability for the Q9 element, exploring how geometric distortions can affect its validity and lead to test failure.", "problem": "Consider the two-dimensional isoparametric nine-node Lagrangian quadrilateral element defined over the reference square $[-1,1] \\times [-1,1]$ with local coordinates $(\\xi,\\eta)$. The nine nodes are located at $(\\xi,\\eta) \\in \\{(-1,-1),(0,-1),(1,-1),(-1,0),(0,0),(1,0),(-1,1),(0,1),(1,1)\\}$ and indexed in the following order: $k=0 \\rightarrow (-1,-1)$, $k=1 \\rightarrow (0,-1)$, $k=2 \\rightarrow (1,-1)$, $k=3 \\rightarrow (-1,0)$, $k=4 \\rightarrow (0,0)$, $k=5 \\rightarrow (1,0)$, $k=6 \\rightarrow (-1,1)$, $k=7 \\rightarrow (0,1)$, $k=8 \\rightarrow (1,1)$. Let the physical coordinates of node $k$ be $(X_k,Y_k)$.\n\nYou must construct the quadratic one-dimensional Lagrange polynomials $L_i(\\xi)$ and $L_j(\\eta)$ for $i,j \\in \\{-1,0,1\\}$, and then form the nine-node Lagrangian shape functions\n$$\nN_{ij}(\\xi,\\eta) = L_i(\\xi)\\,L_j(\\eta), \\quad i,j \\in \\{-1,0,1\\}.\n$$\nUse these to implement the standard isoparametric mapping\n$$\nx(\\xi,\\eta) = \\sum_{a=0}^{8} N_a(\\xi,\\eta)\\,X_a, \\quad y(\\xi,\\eta) = \\sum_{a=0}^{8} N_a(\\xi,\\eta)\\,Y_a,\n$$\nwhere $N_a(\\xi,\\eta)$ denotes the shape function associated with node $a$ under the stated ordering. Compute the Jacobian matrix\n$$\n\\mathbf{J}(\\xi,\\eta) = \n\\begin{bmatrix}\n\\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial x}{\\partial \\eta} \\\\\n\\frac{\\partial y}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\eta}\n\\end{bmatrix},\n$$\nand its determinant $\\det \\mathbf{J}(\\xi,\\eta)$ at the $3 \\times 3$ Gauss–Legendre quadrature points with abscissae $\\{-\\sqrt{3/5},\\,0,\\,\\sqrt{3/5}\\}$ in each coordinate.\n\nFor the patch test, consider the scalar displacement field (sufficient for verifying constant strain reproduction in the Finite Element Method (FEM))\n$$\nu(x,y) = a + b\\,x + c\\,y,\n$$\nwith given constants $a$, $b$, and $c$. Define nodal values $u_a = u(X_a,Y_a)$. Using the constructed shape functions and the chain rule, compute the gradient $\\nabla u$ at the $3 \\times 3$ Gauss points and compare against the exact constant gradient $\\nabla u_{\\text{exact}} = [\\,b,\\,c\\,]^T$. A test passes if and only if two conditions hold simultaneously: \n- $\\det \\mathbf{J}(\\xi,\\eta) > 0$ at all Gauss points, and \n- the maximum absolute component-wise error between the computed and exact gradients over all Gauss points is less than a tolerance of $10^{-10}$.\n\nYou must also identify the failure condition when $\\det \\mathbf{J}(\\xi,\\eta) \\le 0$ at any Gauss point, which invalidates the isoparametric map and causes the patch test to fail.\n\nImplement a complete, runnable program that:\n- Constructs $L_i(\\xi)$ and $L_j(\\eta)$ for $i,j \\in \\{-1,0,1\\}$ from first principles of Lagrange interpolation,\n- Builds $N_{ij}(\\xi,\\eta)$ and their derivatives with respect to $\\xi$ and $\\eta$,\n- Computes $\\mathbf{J}(\\xi,\\eta)$, its determinant, and the gradient $\\nabla u$ via the inverse-transpose of $\\mathbf{J}$,\n- Evaluates the patch test pass/fail as described.\n\nNo physical units or angle units are involved in this problem.\n\nTest Suite:\nUse the following four test cases, all defined for a single nine-node element. In each case, the node ordering is $k=0,\\dots,8$ corresponding to the $(\\xi,\\eta)$ locations listed at the beginning of this problem.\n\n- Test case $1$ (random mild distortion): Start from the unit square with corners $(0,0)$, $(1,0)$, $(0,1)$, $(1,1)$ assigned to $k \\in \\{0,2,6,8\\}$ respectively, midside nodes at edge midpoints, and center at $(0.5,0.5)$. Randomly perturb only the midside and center nodes by adding independent uniform perturbations in $[-0.1,0.1]$ in both $x$ and $y$ directions using a pseudorandom generator with seed $42$. Corners remain fixed.\n- Test case $2$ (bow-tie self-intersection): Assign corners to produce a self-intersecting quadrilateral: $k=0 \\rightarrow (0,0)$, $k=2 \\rightarrow (1,0)$, $k=6 \\rightarrow (1,1)$, $k=8 \\rightarrow (0,1)$. Set midside nodes to edge midpoints of the corresponding (possibly crossing) edges: $k=1 \\rightarrow (0.5,0)$, $k=3 \\rightarrow (0.5,0.5)$, $k=5 \\rightarrow (0.5,0.5)$, $k=7 \\rightarrow (0.5,1)$, and the center $k=4 \\rightarrow (0.5,0.5)$.\n- Test case $3$ (random strong distortion but attempting non-inversion): Same base unit square as test case $1$, but perturb midside and center nodes by uniform perturbations in $[-0.45,0.45]$ using seed $7$. Corners remain fixed.\n- Test case $4$ (collapsed bottom edge): Set $k=0 \\rightarrow (0,0)$, $k=2 \\rightarrow (0,0)$, bottom midside $k=1 \\rightarrow (0,0)$, left midside $k=3 \\rightarrow (0,0.5)$, right midside $k=5 \\rightarrow (0.5,0.5)$, top midside $k=7 \\rightarrow (0.5,1)$, top-left $k=6 \\rightarrow (0,1)$, top-right $k=8 \\rightarrow (1,1)$, center $k=4 \\rightarrow (0.25,0.5)$.\n\nUse the displacement parameters $a=0.3$, $b=-1.2$, $c=2.5$ for all test cases.\n\nAnswer Specification:\nFor each test case, compute:\n- a boolean indicating whether the patch test passes under the stated criteria, and\n- the minimum value of $\\det \\mathbf{J}(\\xi,\\eta)$ over the $3 \\times 3$ Gauss points.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is a list of two elements $[\\text{pass}, \\min\\det]$ in the same order as the test suite, for example, $\\big[\\, [\\text{True},\\,0.123],\\,[\\text{False},\\,-0.001],\\,[\\text{True},\\,0.05],\\,[\\text{False},\\,-0.02] \\,\\big]$.", "solution": "The user has provided a computational solid mechanics problem concerning the validation of a nine-node Lagrangian quadrilateral element using a patch test.\n\n### Step 1: Extract Givens\n- **Element Type**: Two-dimensional isoparametric nine-node Lagrangian quadrilateral element.\n- **Reference Domain**: A square defined by local coordinates $(\\xi, \\eta)$ where $\\xi, \\eta \\in [-1, 1]$.\n- **Node Locations (Reference)**: The nine nodes are at all combinations of $\\xi, \\eta \\in \\{-1, 0, 1\\}$.\n- **Node Ordering**: A specific mapping from index $k=0, \\dots, 8$ to reference coordinates $(\\xi_k, \\eta_k)$: $k=0 \\rightarrow (-1,-1)$, $k=1 \\rightarrow (0,-1)$, $k=2 \\rightarrow (1,-1)$, $k=3 \\rightarrow (-1,0)$, $k=4 \\rightarrow (0,0)$, $k=5 \\rightarrow (1,0)$, $k=6 \\rightarrow (-1,1)$, $k=7 \\rightarrow (0,1)$, $k=8 \\rightarrow (1,1)$.\n- **Shape Functions**: Defined by the tensor product of one-dimensional quadratic Lagrange polynomials: $N_{ij}(\\xi,\\eta) = L_i(\\xi)L_j(\\eta)$ for $i,j \\in \\{-1,0,1\\}$.\n- **Isoparametric Mapping**: The physical coordinates $(x,y)$ are mapped from the reference coordinates $(\\xi,\\eta)$ using the shape functions $N_a$ and nodal physical coordinates $(X_a, Y_a)$: $x(\\xi,\\eta) = \\sum_{a=0}^{8} N_a(\\xi,\\eta)X_a$ and $y(\\xi,\\eta) = \\sum_{a=0}^{8} N_a(\\xi,\\eta)Y_a$.\n- **Jacobian Matrix**: $\\mathbf{J}(\\xi,\\eta) = \\begin{bmatrix} \\partial x/\\partial \\xi & \\partial x/\\partial \\eta \\\\ \\partial y/\\partial \\xi & \\partial y/\\partial \\eta \\end{bmatrix}$. A quantity to compute is its determinant, $\\det \\mathbf{J}$.\n- **Evaluation Points**: The $3 \\times 3$ Gauss-Legendre quadrature points, with abscissae $\\{-\\sqrt{3/5}, 0, \\sqrt{3/5}\\}$ in each coordinate direction $(\\xi, \\eta)$.\n- **Patch Test Field**: A scalar displacement field $u(x,y) = a + b x + c y$ with given constants $a, b, c$.\n- **Nodal Values**: $u_a = u(X_a, Y_a)$.\n- **Gradient Calculation**: The gradient $\\nabla u = [\\partial u/\\partial x, \\partial u/\\partial y]^T$ is to be computed at the Gauss points using the shape functions and the chain rule.\n- **Patch Test Criteria**: A test passes if and only if both conditions are met:\n    1.  $\\det \\mathbf{J}(\\xi,\\eta) > 0$ at all $9$ Gauss points.\n    2.  The maximum absolute component-wise error between the computed gradient $\\nabla u$ and the exact gradient $[\\,b,\\,c\\,]^T$ over all Gauss points is less than a tolerance of $10^{-10}$.\n- **Displacement Parameters**: For all test cases, $a=0.3$, $b=-1.2$, $c=2.5$.\n- **Test Cases**: Four test cases are defined by the nodal physical coordinates $(X_k, Y_k)$ for $k=0, \\dots, 8$:\n    1.  **Random Mild Distortion**: Unit square with corners fixed, midside and center nodes perturbed by uniform random values in $[-0.1, 0.1]$ (seed $42$).\n    2.  **Bow-tie Self-intersection**: Corners are $k=0 \\to (0,0)$, $k=2 \\to (1,0)$, $k=6 \\to (1,1)$, $k=8 \\to (0,1)$. Midside and center nodes are placed accordingly, leading to some coincident nodes.\n    3.  **Random Strong Distortion**: Same as case 1 but with perturbations in $[-0.45, 0.45]$ (seed $7$).\n    4.  **Collapsed Bottom Edge**: Nodes $k=0, 1, 2$ are all mapped to the physical point $(0,0)$.\n- **Required Output**: For each test case, a boolean for patch test pass/fail and the minimum value of $\\det \\mathbf{J}$ over the Gauss points. The final output must be a single line containing a list of these results.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is subjected to validation against the specified criteria.\n- **Scientifically Grounded**: The problem is a standard verification procedure in the Finite Element Method (FEM). The concepts of isoparametric mapping, Lagrangian shape functions, the Jacobian of transformation, Gauss quadrature, and the patch test are all fundamental, well-established principles in computational solid mechanics.\n- **Well-Posed**: The problem is algorithmically specified. The inputs (nodal coordinates, displacement field parameters) are clearly defined for each case. The computational procedure is deterministic and leads to a unique solution for each test case.\n- **Objective**: The problem is stated in precise, quantitative, and unbiased mathematical language. All criteria are objective (e.g., $\\det \\mathbf{J} > 0$, error $< 10^{-10}$).\n- **Completeness and Consistency**: All necessary data and definitions are provided. The node ordering, shape function construction, physical coordinates, and evaluation criteria are all specified without ambiguity or contradiction.\n- **Feasibility and Realism**: The described computations are standard in FEM software and are physically and mathematically feasible. The test cases, including distorted and degenerate geometries, are designed to test the robustness of the element formulation, which is a common practice.\n- **Other Flaws**: The problem is not trivial, as it requires a non-negligible implementation of FEM concepts. It is not tautological, metaphorical, or outside the realm of scientific verifiability.\n\n### Step 3: Verdict and Action\nThe problem statement is **valid**. It is self-contained, scientifically sound, and well-posed. A complete solution will be provided.\n\n### Principle-Based Design of the Solution\nThe solution is developed by methodically implementing the principles of isoparametric finite element formulation.\n\n**1. One-Dimensional Lagrange Polynomials**\nThe basis for the nine-node element's shape functions are the one-dimensional quadratic Lagrange polynomials defined over the interval $[-1, 1]$ with nodes at $\\zeta \\in \\{-1, 0, 1\\}$. For an index $i \\in \\{-1, 0, 1\\}$, the polynomial $L_i(\\zeta)$ has the property that $L_i(\\zeta_j) = \\delta_{ij}$ (the Kronecker delta) where $\\zeta_j \\in \\{-1, 0, 1\\}$.\nThe general form is $L_i(\\zeta) = \\prod_{j \\in \\{-1,0,1\\}, j \\neq i} \\frac{\\zeta - \\zeta_j}{\\zeta_i - \\zeta_j}$. This yields:\n- $L_{-1}(\\zeta) = \\frac{(\\zeta-0)(\\zeta-1)}{(-1-0)(-1-1)} = \\frac{1}{2}\\zeta(\\zeta-1)$\n- $L_{0}(\\zeta) = \\frac{(\\zeta-(-1))(\\zeta-1)}{(0-(-1))(0-1)} = -(\\zeta+1)(\\zeta-1) = 1-\\zeta^2$\n- $L_{1}(\\zeta) = \\frac{(\\zeta-(-1))(\\zeta-0)}{(1-(-1))(1-0)} = \\frac{1}{2}\\zeta(\\zeta+1)$\n\nTheir derivatives with respect to $\\zeta$ are also required:\n- $\\frac{dL_{-1}}{d\\zeta} = \\zeta - \\frac{1}{2}$\n- $\\frac{dL_{0}}{d\\zeta} = -2\\zeta$\n- $\\frac{dL_{1}}{d\\zeta} = \\zeta + \\frac{1}{2}$\n\n**2. Two-Dimensional Shape Functions**\nThe two-dimensional shape functions $N_k(\\xi, \\eta)$ for node $k$ are formed by a tensor product of the 1D polynomials. Given the specified node ordering $k = 0, \\dots, 8$, we can establish a mapping from the scalar index $k$ to the pair of 1D node indices $(i, j) \\in \\{-1, 0, 1\\} \\times \\{-1, 0, 1\\}$. The mapping is $i = (k \\pmod 3) - 1$ and $j = \\lfloor k/3 \\rfloor - 1$.\nThe shape function for node $k$, corresponding to index pair $(i, j)$, is:\n$$N_k(\\xi, \\eta) = L_i(\\xi) L_j(\\eta)$$\nIts partial derivatives, required for the Jacobian calculation, are found using the product rule:\n$$\\frac{\\partial N_k}{\\partial \\xi} = \\frac{dL_i(\\xi)}{d\\xi} L_j(\\eta)$$\n$$\\frac{\\partial N_k}{\\partial \\eta} = L_i(\\xi) \\frac{dL_j(\\eta)}{d\\eta}$$\n\n**3. Isoparametric Mapping and the Jacobian Matrix**\nThe isoparametric formulation uses the same shape functions to interpolate both the geometry and the solution field. The mapping from the reference element $(\\xi, \\eta)$ to the physical element $(x, y)$ is:\n$$x(\\xi, \\eta) = \\sum_{k=0}^{8} N_k(\\xi, \\eta) X_k, \\quad y(\\xi, \\eta) = \\sum_{k=0}^{8} N_k(\\xi, \\eta) Y_k$$\nThe Jacobian matrix $\\mathbf{J}$ relates the differential elements in the two coordinate systems, $d\\mathbf{x} = \\mathbf{J} d\\boldsymbol{\\xi}$. Its components are:\n$$J_{11} = \\frac{\\partial x}{\\partial \\xi} = \\sum_{k=0}^{8} \\frac{\\partial N_k}{\\partial \\xi} X_k, \\quad J_{12} = \\frac{\\partial x}{\\partial \\eta} = \\sum_{k=0}^{8} \\frac{\\partial N_k}{\\partial \\eta} X_k$$\n$$J_{21} = \\frac{\\partial y}{\\partial \\xi} = \\sum_{k=0}^{8} \\frac{\\partial N_k}{\\partial \\xi} Y_k, \\quad J_{22} = \\frac{\\partial y}{\\partial \\eta} = \\sum_{k=0}^{8} \\frac{\\partial N_k}{\\partial \\eta} Y_k$$\nThe determinant $\\det \\mathbf{J}$ is a scaling factor between the differential areas: $dA_{phys} = \\det \\mathbf{J} \\, dA_{ref}$. A valid mapping requires $\\det \\mathbf{J} > 0$ everywhere in the element. If $\\det \\mathbf{J} \\le 0$, the mapping is singular or locally inverted (\"tangled mesh\"), which is unphysical.\n\n**4. The Patch Test**\nThe patch test verifies an element's ability to exactly reproduce a constant strain state. For a displacement field $u(x, y) = a + bx + cy$, the strain components (derivatives of displacement) are constant: $\\frac{\\partial u}{\\partial x} = b$ and $\\frac{\\partial u}{\\partial y} = c$. The exact gradient is $\\nabla u_{\\text{exact}} = [b, c]^T$.\nThe nodal displacements are set to the exact values: $u_k = u(X_k, Y_k) = a + b X_k + c Y_k$.\nThe interpolated displacement field within the element is $u^h(\\xi, \\eta) = \\sum_{k=0}^{8} N_k(\\xi, \\eta) u_k$. Due to the properties of the isoparametric mapping, specifically that $\\sum N_k = 1$ (partition of unity) and $\\sum N_k X_k = x$, it can be shown that $u^h(\\xi, \\eta) = a + b x(\\xi, \\eta) + c y(\\xi, \\eta)$. This means the interpolated field is identical to the exact field.\nThe computed gradient in physical coordinates is obtained via the chain rule:\n$$\\begin{pmatrix} \\partial u^h/\\partial \\xi \\\\ \\partial u^h/\\partial \\eta \\end{pmatrix} = \\mathbf{J} \\begin{pmatrix} \\partial u^h/\\partial x \\\\ \\partial u^h/\\partial y \\end{pmatrix} \\implies \\nabla u^h = \\begin{pmatrix} \\partial u^h/\\partial x \\\\ \\partial u^h/\\partial y \\end{pmatrix} = \\mathbf{J}^{-1} \\begin{pmatrix} \\partial u^h/\\partial \\xi \\\\ \\partial u^h/\\partial \\eta \\end{pmatrix}$$\nwhere $\\partial u^h/\\partial \\xi = \\sum_k (\\partial N_k/\\partial \\xi) u_k$ and $\\partial u^h/\\partial \\eta = \\sum_k (\\partial N_k/\\partial \\eta) u_k$.\nTheoretically, if $\\det \\mathbf{J} > 0$, the computed gradient $\\nabla u^h$ must equal the exact gradient $[b, c]^T$ to within machine precision. The test passes if this holds and the Jacobian determinant is positive at all specified Gauss points.\n\n**5. Implementation**\nThe solution is implemented as a Python program. This program defines functions for the 1D Lagrange polynomials and their derivatives. A core function computes the 2D shape functions and their derivatives at a given $(\\xi, \\eta)$ point. A main test function orchestrates the process for a given set of nodal coordinates: it iterates through the $3 \\times 3$ Gauss points, computes $\\mathbf{J}$ and $\\det \\mathbf{J}$, and if the mapping is valid, it proceeds to compute the displacement gradient and its error. The results are aggregated to determine the overall pass/fail status and the minimum Jacobian determinant. This process is repeated for each of the four test cases defined in the problem.", "answer": "```python\nimport numpy as np\n\ndef _l_1d(zeta, i):\n    \"\"\"Computes the 1D quadratic Lagrange polynomial L_i(zeta) for i in {-1, 0, 1}.\"\"\"\n    if i == -1:\n        return 0.5 * zeta * (zeta - 1.0)\n    elif i == 0:\n        return 1.0 - zeta**2\n    elif i == 1:\n        return 0.5 * zeta * (zeta + 1.0)\n    else:\n        raise ValueError(\"Invalid index for 1D Lagrange polynomial.\")\n\ndef _dl_1d(zeta, i):\n    \"\"\"Computes the derivative of the 1D Lagrange polynomial dL_i/dzeta.\"\"\"\n    if i == -1:\n        return zeta - 0.5\n    elif i == 0:\n        return -2.0 * zeta\n    elif i == 1:\n        return zeta + 0.5\n    else:\n        raise ValueError(\"Invalid index for 1D Lagrange polynomial derivative.\")\n\ndef get_shape_functions_and_derivs(xi, eta):\n    \"\"\"\n    Computes the 9-node quad shape functions and their derivatives at (xi, eta).\n    Node ordering k=0..8 corresponds to (i,j) pairs from (-1,-1) to (1,1).\n    \"\"\"\n    N = np.zeros(9)\n    dN_dxi_deta = np.zeros((9, 2))\n    \n    for k in range(9):\n        i = (k % 3) - 1\n        j = (k // 3) - 1\n\n        L_i_xi = _l_1d(xi, i)\n        L_j_eta = _l_1d(eta, j)\n        dL_i_xi = _dl_1d(xi, i)\n        dL_j_eta = _dl_1d(eta, j)\n\n        N[k] = L_i_xi * L_j_eta\n        dN_dxi_deta[k, 0] = dL_i_xi * L_j_eta  # dN_k/dxi\n        dN_dxi_deta[k, 1] = L_i_xi * dL_j_eta  # dN_k/deta\n        \n    return N, dN_dxi_deta\n\ndef run_patch_test_q9(coords, a, b, c, tol):\n    \"\"\"\n    Performs the patch test for a single 9-node element.\n    \"\"\"\n    gauss_abscissae = [-np.sqrt(3.0 / 5.0), 0.0, np.sqrt(3.0 / 5.0)]\n    gauss_points = [(xi, eta) for eta in gauss_abscissae for xi in gauss_abscissae]\n    \n    min_det_J = float('inf')\n    max_grad_error = 0.0\n    \n    all_dets_positive = True\n\n    # Nodal displacements from the exact field u(x,y)\n    nodal_u = a + b * coords[:, 0] + c * coords[:, 1]\n    grad_u_exact = np.array([b, c])\n\n    for xi, eta in gauss_points:\n        # Get shape functions and their derivatives at the current Gauss point\n        N, dN_dxi_deta = get_shape_functions_and_derivs(xi, eta)\n        \n        # Compute Jacobian matrix\n        # J = [dx/dxi, dx/deta]\n        #     [dy/dxi, dy/deta]\n        J = np.dot(dN_dxi_deta.T, coords)\n\n        # Compute determinant of Jacobian\n        det_J = np.linalg.det(J)\n        min_det_J = min(min_det_J, det_J)\n        \n        if det_J <= 0:\n            all_dets_positive = False\n\n        # Compute gradient if mapping is valid\n        if det_J > 0:\n            # Gradient of u in reference coordinates\n            grad_u_ref = np.dot(dN_dxi_deta.T, nodal_u)\n\n            # Gradient of u in physical coordinates: grad_u_phys = J^-1 * grad_u_ref\n            try:\n                grad_u_phys = np.linalg.solve(J, grad_u_ref)\n                error = np.max(np.abs(grad_u_phys - grad_u_exact))\n                max_grad_error = max(max_grad_error, error)\n            except np.linalg.LinAlgError:\n                # This should not happen if det_J > 0, but as a safeguard\n                all_dets_positive = False\n    \n    passes = all_dets_positive and (max_grad_error < tol)\n    return [passes, min_det_J]\n\n\ndef solve():\n    # Define test parameters\n    a, b, c = 0.3, -1.2, 2.5\n    tolerance = 1e-10\n    \n    # --- Test Case Generation ---\n    test_cases_coords = []\n\n    # Case 1: Random Mild Distortion\n    rng1 = np.random.default_rng(42)\n    coords1 = np.array([\n        [0.0, 0.0], [0.5, 0.0], [1.0, 0.0],\n        [0.0, 0.5], [0.5, 0.5], [1.0, 0.5],\n        [0.0, 1.0], [0.5, 1.0], [1.0, 1.0]\n    ])\n    perturbed_indices = [1, 3, 4, 5, 7]\n    perturbations1 = rng1.uniform(-0.1, 0.1, size=(len(perturbed_indices), 2))\n    coords1[perturbed_indices] += perturbations1\n    test_cases_coords.append(coords1)\n\n    # Case 2: Bow-tie self-intersection\n    coords2 = np.array([\n        [0.0, 0.0], [0.5, 0.0], [1.0, 0.0],  # k=0,1,2\n        [0.5, 0.5], [0.5, 0.5], [0.5, 0.5],  # k=3,4,5\n        [1.0, 1.0], [0.5, 1.0], [0.0, 1.0]   # k=6,7,8\n    ])\n    test_cases_coords.append(coords2)\n\n    # Case 3: Random Strong Distortion\n    rng3 = np.random.default_rng(7)\n    coords3 = np.array([\n        [0.0, 0.0], [0.5, 0.0], [1.0, 0.0],\n        [0.0, 0.5], [0.5, 0.5], [1.0, 0.5],\n        [0.0, 1.0], [0.5, 1.0], [1.0, 1.0]\n    ])\n    perturbations3 = rng3.uniform(-0.45, 0.45, size=(len(perturbed_indices), 2))\n    coords3[perturbed_indices] += perturbations3\n    test_cases_coords.append(coords3)\n    \n    # Case 4: Collapsed bottom edge\n    coords4 = np.array([\n        [0.0, 0.0], [0.0, 0.0], [0.0, 0.0],      # k=0,1,2\n        [0.0, 0.5], [0.25, 0.5], [0.5, 0.5],    # k=3,4,5\n        [0.0, 1.0], [0.5, 1.0], [1.0, 1.0]     # k=6,7,8\n    ])\n    test_cases_coords.append(coords4)\n\n    # Run tests and collect results\n    results = []\n    for coords in test_cases_coords:\n        result = run_patch_test_q9(coords, a, b, c, tolerance)\n        results.append(result)\n        \n    # Format and print the final output as a single string\n    # E.g., [[True, 0.123], [False, -0.001]]\n    output_str = f\"[{', '.join(str(r) for r in results)}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3583985"}, {"introduction": "An element that passes the patch test is guaranteed to converge, but this says nothing about *how quickly*. This practice delves into the quantitative assessment of accuracy by verifying the element's convergence rates against theoretical predictions. Using a manufactured solution for a model problem [@problem_id:3583965], you will numerically compute the error in both the $H^1$-seminorm and the $L^2$-norm, confirming the expected optimal rates of $O(h^2)$ and $O(h^3)$ for the biquadratic Q9 element.", "problem": "Consider the scalar anti-plane shear model governed by the Poisson equation on the unit square domain $[0,1] \\times [0,1]$. Let $u:[0,1] \\times [0,1] \\to \\mathbb{R}$ be the scalar displacement field. The strong form is\n$$\n-\\nabla \\cdot (\\nabla u) = f \\text{ in } \\Omega = [0,1]^2, \\quad u = g \\text{ on } \\partial \\Omega.\n$$\nYou will work with a manufactured solution $u_{\\text{ex}}(x,y)$, so that $f$ and $g$ are induced by $u_{\\text{ex}}$ using the strong form. Use the following manufactured solution:\n$$\nu_{\\text{ex}}(x,y) = \\sin(\\pi x)\\sin(\\pi y).\n$$\nUsing the strong form, define $f(x,y)$ and $g(x,y)$ consistently from $u_{\\text{ex}}(x,y)$.\n\nYour tasks are:\n- From the weak form posed in the Sobolev space $H^1_0(\\Omega)$ and the Galerkin method, derive the theoretically expected convergence orders in the $H^1$-seminorm (energy norm) and the $L^2$-norm when the trial space is the conforming nine-node Lagrangian quadrilateral element space (often referred to as the tensor-product quadratic family). The derivation must start only from the variational formulation and the general approximation properties of tensor-product quadratic interpolation, without using any pre-quoted target rates. Clearly state the assumptions on solution regularity and mesh regularity that produce your rate conclusions.\n- Implement a conforming finite element solver using the nine-node Lagrangian quadrilateral element on a sequence of uniform meshes of the unit square $\\Omega$, with $N \\in \\{2,4,8\\}$ elements along each coordinate direction. For a uniform tensor grid with $N$ elements per side, the element size is $h = 1/N$.\n- Construct the nine-node shape functions on the bi-unit reference square $[-1,1]^2$ from the tensor product of the one-dimensional quadratic Lagrange polynomials associated with the nodes at $\\xi \\in \\{-1,0,1\\}$ and $\\eta \\in \\{-1,0,1\\}$. Use an isoparametric affine map from the reference square to each physical rectangular element (which is valid on a uniform rectangular mesh). Assemble the global stiffness matrix and load vector using Gauss-Legendre quadrature of sufficiently high order to achieve assembly accuracy for the chosen manufactured data.\n- Impose Dirichlet boundary conditions strongly by prescribing the exact values of $u_{\\text{ex}}$ at all boundary nodes, and solve for the nodal values on the interior.\n- Compute the $H^1$-seminorm error\n$$\n\\lvert u_{\\text{ex}} - u_h \\rvert_{H^1(\\Omega)} = \\left( \\int_{\\Omega} \\|\\nabla u_{\\text{ex}} - \\nabla u_h\\|^2 \\, d\\Omega \\right)^{1/2}\n$$\nand the $L^2$-norm error\n$$\n\\|u_{\\text{ex}} - u_h\\|_{L^2(\\Omega)} = \\left( \\int_{\\Omega} (u_{\\text{ex}} - u_h)^2 \\, d\\Omega \\right)^{1/2}\n$$\nusing sufficiently high-order Gauss-Legendre quadrature on each element.\n- For the sequence of meshes with $N \\in \\{2,4,8\\}$, compute the observed convergence rates between successive mesh refinements for each norm. If $e(h)$ denotes the error at mesh size $h$, define the observed rate between $h$ and $h/2$ as\n$$\n\\text{rate} = \\frac{\\log(e(h)/e(h/2))}{\\log(2)}.\n$$\n\nFoundational material you may use:\n- The variational formulation posed on $H^1_0(\\Omega)$ and the standard Galerkin framework.\n- Well-posedness of the variational problem for the Poisson operator with homogeneous Dirichlet boundary conditions.\n- The Céa lemma relating the Galerkin error to the best approximation error in the trial space.\n- The existence of a bounded interpolation operator into the tensor-product quadratic space, together with the general interpolation error estimates for sufficiently smooth functions on shape-regular, quasi-uniform meshes.\n- The Aubin–Nitsche duality argument for improving $L^2$-norm estimates from energy-norm estimates under appropriate elliptic regularity.\n\nNumerical details to be implemented:\n- Use the exact manufactured solution $u_{\\text{ex}}(x,y) = \\sin(\\pi x)\\sin(\\pi y)$, its gradient $\\nabla u_{\\text{ex}}(x,y)$, and the corresponding right-hand side $f(x,y)$ induced by the strong form.\n- Use Gauss-Legendre quadrature of order at least $4$ per direction for stiffness/load assembly, and of order at least $6$ per direction for error evaluation.\n- Treat the reference element $[-1,1]^2$ with the tensor-product quadratic basis from the one-dimensional polynomials associated with the nodes $\\{-1,0,1\\}$. The two-dimensional basis is obtained by tensor products and the derivatives by product rules.\n\nTest suite:\n- Use three meshes with $N \\in \\{2,4,8\\}$ elements per side.\n- For each $N$, compute the pair of errors $(\\lvert \\cdot \\rvert_{H^1}, \\|\\cdot\\|_{L^2})$.\n- Compute the observed rates between $N=2$ and $N=4$, and between $N=4$ and $N=8$, for both norms. Additionally, report four boolean checks that validate whether the observed rates in the $H^1$-seminorm exceed $1.9$ for both refinement steps and whether the observed rates in the $L^2$-norm exceed $2.8$ for both refinement steps.\n\nFinal output format:\n- Your program should produce a single line of output containing a comma-separated list enclosed in square brackets. The list must contain, in this exact order:\n    - The $H^1$-seminorm error for $N=2$,\n    - The $L^2$-norm error for $N=2$,\n    - The $H^1$-seminorm error for $N=4$,\n    - The $L^2$-norm error for $N=4$,\n    - The $H^1$-seminorm error for $N=8$,\n    - The $L^2$-norm error for $N=8$,\n    - The observed $H^1$-seminorm rate from $N=2$ to $N=4$,\n    - The observed $H^1$-seminorm rate from $N=4$ to $N=8$,\n    - The observed $L^2$-norm rate from $N=2$ to $N=4$,\n    - The observed $L^2$-norm rate from $N=4$ to $N=8$,\n    - A boolean indicating whether the $H^1$ rates for both refinements exceed $1.9$,\n    - A boolean indicating whether the $L^2$ rates for both refinements exceed $2.8$,\n    - A boolean indicating whether the $H^1$ rate from $N=2$ to $N=4$ exceeds $1.9$,\n    - A boolean indicating whether the $L^2$ rate from $N=2$ to $N=4$ exceeds $2.8$.\n- All floating-point numbers must be printed in fixed-point format with exactly 8 digits after the decimal point.\n- The output must look like\n$$\n[\\text{eH1\\_N2},\\text{eL2\\_N2},\\text{eH1\\_N4},\\text{eL2\\_N4},\\text{eH1\\_N8},\\text{eL2\\_N8},\\text{rateH1\\_24},\\text{rateH1\\_48},\\text{rateL2\\_24},\\text{rateL2\\_48},\\text{boolH1All},\\text{boolL2All},\\text{boolH1\\_24},\\text{boolL2\\_24}]\n$$\nwith the comma-separated values adhering to the ordering above and booleans printed as either True or False. No units are involved, and angles do not appear in this problem.", "solution": "The problem requires the derivation of theoretical convergence rates for a nine-node Lagrangian quadrilateral finite element discretization of the Poisson equation, followed by a numerical verification of these rates using a manufactured solution.\n\n### Part 1: Problem Formulation and Theoretical Analysis\n\n**1.1. Strong and Weak Formulations**\n\nThe problem is governed by the Poisson equation on the unit square domain $\\Omega = [0,1]^2$:\n$$\n-\\nabla^2 u = f \\quad \\text{in } \\Omega,\n$$\nwith Dirichlet boundary conditions $u=g$ on the boundary $\\partial\\Omega$.\n\nThe manufactured solution is given by $u_{\\text{ex}}(x,y) = \\sin(\\pi x)\\sin(\\pi y)$. We derive the source term $f$ and boundary data $g$ from $u_{\\text{ex}}$.\nThe gradient is $\\nabla u_{\\text{ex}} = (\\pi \\cos(\\pi x)\\sin(\\pi y), \\pi \\sin(\\pi x)\\cos(\\pi y))$.\nThe Laplacian is $\\nabla^2 u_{\\text{ex}} = \\frac{\\partial^2 u_{\\text{ex}}}{\\partial x^2} + \\frac{\\partial^2 u_{\\text{ex}}}{\\partial y^2} = -\\pi^2 \\sin(\\pi x)\\sin(\\pi y) - \\pi^2 \\sin(\\pi x)\\sin(\\pi y) = -2\\pi^2 u_{\\text{ex}}$.\nThus, the source term is $f(x,y) = -\\nabla^2 u_{\\text{ex}} = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$.\n\nFor the boundary data $g$, we evaluate $u_{\\text{ex}}$ on $\\partial\\Omega$. Since $\\sin(0) = 0$ and $\\sin(\\pi) = 0$, $u_{\\text{ex}}(x,y)$ is zero on all four sides of the unit square. Thus, $g(x,y) = 0$ on $\\partial\\Omega$. The problem is homogeneous.\n\nThe corresponding weak (variational) formulation is to find a solution $u$ in the Sobolev space $H^1_0(\\Omega) = \\{ v \\in H^1(\\Omega) : v|_{\\partial\\Omega} = 0 \\}$ such that:\n$$\n\\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\Omega = \\int_{\\Omega} f v \\, d\\Omega \\quad \\forall v \\in H^1_0(\\Omega).\n$$\nThis can be written in abstract form as finding $u \\in H^1_0(\\Omega)$ such that $a(u,v) = L(v)$ for all $v \\in H^1_0(\\Omega)$, where the bilinear form $a(u,v) = \\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\Omega$ defines an inner product on $H^1_0(\\Omega)$ and induces the energy norm $|v|_{H^1(\\Omega)} = \\sqrt{a(v,v)}$. The linear functional is $L(v) = \\int_{\\Omega} f v \\, d\\Omega$.\n\n**1.2. Galerkin Method and Convergence Rates**\n\nThe finite element method is a Galerkin method where we seek an approximate solution $u_h$ in a finite-dimensional subspace $V_h \\subset H^1_0(\\Omega)$. The space $V_h$ consists of continuous piecewise biquadratic polynomials defined over a mesh of quadrilateral elements, which are zero on $\\partial\\Omega$. The Galerkin problem is to find $u_h \\in V_h$ such that:\n$$\na(u_h, v_h) = L(v_h) \\quad \\forall v_h \\in V_h.\n$$\n\n**$H^1$-seminorm Convergence:**\nThe analysis starts with Céa's lemma, which for this problem states that the error in the Galerkin solution is bounded by the best approximation error in the subspace $V_h$:\n$$\n|u - u_h|_{H^1(\\Omega)} \\leq \\inf_{v_h \\in V_h} |u - v_h|_{H^1(\\Omega)}.\n$$\nThe best approximation error can be bounded by the error of a particular interpolant in $V_h$. Let $\\mathcal{I}_h u$ be the standard biquadratic Lagrange interpolant of $u$ in $V_h$. Standard interpolation theory provides an estimate for the interpolation error, assuming the solution $u$ possesses sufficient regularity and the mesh is quasi-uniform. For a finite element of polynomial degree $p$, the estimate is:\n$$\n|u - \\mathcal{I}_h u|_{H^1(\\Omega)} \\leq C h^p |u|_{H^{p+1}(\\Omega)},\n$$\nwhere $h$ is the characteristic mesh size and $C$ is a constant independent of $h$.\nThe nine-node Lagrangian element is a tensor-product quadratic element, so its polynomial degree is $p=2$. The estimate requires the solution to be in the Sobolev space $H^{p+1}(\\Omega) = H^3(\\Omega)$. Our manufactured solution $u_{\\text{ex}}(x,y) = \\sin(\\pi x)\\sin(\\pi y)$ is infinitely differentiable ($C^\\infty$), so it belongs to $H^k(\\Omega)$ for any $k$, including $H^3(\\Omega)$.\nCombining these results, the theoretical convergence rate for the $H^1$-seminorm error is:\n$$\n|u_{\\text{ex}} - u_h|_{H^1(\\Omega)} = O(h^p) = O(h^2).\n$$\nThe expected order of convergence is $2$.\n\n**$L^2$-norm Convergence:**\nTo obtain a higher rate of convergence for the $L^2$-norm, we use the Aubin-Nitsche duality argument. This argument requires $H^2$ elliptic regularity for the Poisson problem, which holds for a convex domain like the unit square. This means that for the auxiliary problem $-\\nabla^2 \\phi = \\psi$ in $\\Omega$ with $\\phi=0$ on $\\partial\\Omega$, the solution satisfies $\\|\\phi\\|_{H^2(\\Omega)} \\leq C_{\\text{reg}} \\|\\psi\\|_{L^2(\\Omega)}$ for any $\\psi \\in L^2(\\Omega)$.\nThe Aubin-Nitsche argument yields the following estimate:\n$$\n\\|u - u_h\\|_{L^2(\\Omega)} \\leq C h |u - u_h|_{H^1(\\Omega)}.\n$$\nSubstituting the previously derived rate for the $H^1$-seminorm error:\n$$\n\\|u_{\\text{ex}} - u_h\\|_{L^2(\\Omega)} \\leq C h \\cdot O(h^p) = O(h^{p+1}).\n$$\nFor our biquadratic element with $p=2$, the theoretical convergence rate for the $L^2$-norm error is:\n$$\n\\|u_{\\text{ex}} - u_h\\|_{L^2(\\Omega)} = O(h^{p+1}) = O(h^3).\n$$\nThe expected order of convergence is $3$.\n\n### Part 2: Finite Element Implementation Details\n\n**2.1. Discretization and Shape Functions**\nThe domain $\\Omega=[0,1]^2$ is discretized into a uniform grid of $N \\times N$ square elements of side length $h=1/N$. The nine-node (biquadratic) Lagrangian element is used. The shape functions $N_i(\\xi, \\eta)$ on the reference element $[-1,1]^2$ are constructed as tensor products of one-dimensional quadratic Lagrange polynomials $L_k(s)$ associated with nodes at $s \\in \\{-1,0,1\\}$:\n$L_0(s) = \\frac{1}{2}s(s-1)$, $L_1(s) = 1-s^2$, $L_2(s) = \\frac{1}{2}s(s+1)$.\nThe nine 2D shape functions $N_k(\\xi, \\eta)$ for $k=0, \\dots, 8$ are $N_{ij}(\\xi, \\eta) = L_i(\\xi)L_j(\\eta)$ where $i,j \\in \\{0,1,2\\}$.\n\n**2.2. Isoparametric Mapping and Numerical Quadrature**\nAn affine isoparametric map $x(\\xi, \\eta)$ transforms from the reference element to each physical element $K_e$. For a square element with center $(x_c, y_c)$ and side length $h$, this map is $x = x_c + \\frac{h}{2}\\xi$, $y = y_c + \\frac{h}{2}\\eta$. The Jacobian determinant is constant: $\\det(J) = h^2/4$.\n\nElement stiffness matrices $k^e$ and load vectors $f^e$ are computed by transforming the integrals to the reference element and evaluating them numerically using Gauss-Legendre quadrature.\n$$\nk^e_{ij} = \\int_{-1}^1 \\int_{-1}^1 \\left(\\nabla N_i(\\xi, \\eta)\\right)^T (J^{-T} J^{-1}) \\left(\\nabla N_j(\\xi, \\eta)\\right) \\det(J) \\,d\\xi d\\eta\n$$\n$$\nf^e_i = \\int_{-1}^1 \\int_{-1}^1 f(x(\\xi,\\eta), y(\\xi,\\eta)) N_i(\\xi, \\eta) \\det(J) \\,d\\xi d\\eta\n$$\nThe integrand for $k^e$ is a polynomial. For biquadratic elements and an affine map, its degree in each variable is at most $4$. A $3$-point Gauss rule would be exact, but the problem specifies at least $4$ points per direction; we use a $4 \\times 4$ rule. The integrand for $f^e$ is non-polynomial, so a high-order rule improves accuracy.\nThe element contributions are assembled into a global stiffness matrix $K$ and load vector $F$.\n\n**2.3. Boundary Conditions and Solution**\nHomogeneous Dirichlet boundary conditions ($u=0$) are imposed strongly. This is achieved by partitioning the global system of equations into interior and boundary unknowns. The system $K_{II}U_I = F_I - K_{IB}U_B$ is solved for the interior nodal values $U_I$. Since the boundary values $U_B$ are all zero, this simplifies to solving $K_{II} U_I = F_I$.\n\n**2.4. Error Calculation**\nThe $H^1$-seminorm and $L^2$-norm of the error $e = u_{\\text{ex}} - u_h$ are computed by summing contributions from each element, evaluated using high-order ($6 \\times 6$) Gauss-Legendre quadrature for accuracy.\n$$\n|e|_{H^1(\\Omega)}^2 = \\sum_{e} \\int_{K_e} \\|\\nabla u_{\\text{ex}} - \\nabla u_h\\|^2 \\,d\\Omega \\quad \\text{and} \\quad \\|e\\|_{L^2(\\Omega)}^2 = \\sum_{e} \\int_{K_e} (u_{\\text{ex}} - u_h)^2 \\,d\\Omega.\n$$\n\n**2.5. Rate Calculation**\nFor each norm, the observed convergence rate between meshes with sizes $h_1$ and $h_2=h_1/2$ is calculated as $\\text{rate} = \\log(e_1/e_2) / \\log(2)$. This is done for the refinements from $N=2$ to $N=4$ and from $N=4$ to $N=8$.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a 9-node quadrilateral FEM solver for the Poisson equation\n    and performs a convergence study.\n    \"\"\"\n\n    def get_gauss_points(order):\n        return np.polynomial.legendre.leggauss(order)\n\n    # 1D quadratic shape functions and their derivatives\n    L = [\n        lambda s: 0.5 * s * (s - 1),\n        lambda s: 1 - s**2,\n        lambda s: 0.5 * s * (s + 1),\n    ]\n    dL = [\n        lambda s: s - 0.5,\n        lambda s: -2 * s,\n        lambda s: s + 0.5,\n    ]\n\n    def shape_functions(xi, eta):\n        N = np.zeros(9)\n        for j in range(3):\n            for i in range(3):\n                N[j * 3 + i] = L[i](xi) * L[j](eta)\n        return N\n\n    def shape_function_derivatives(xi, eta):\n        dN = np.zeros((9, 2))\n        for j in range(3):\n            for i in range(3):\n                dN[j * 3 + i, 0] = dL[i](xi) * L[j](eta)  # d/d(xi)\n                dN[j * 3 + i, 1] = L[i](xi) * dL[j](eta)  # d/d(eta)\n        return dN\n\n    # Manufactured solution and its derivatives\n    u_ex = lambda x, y: np.sin(np.pi * x) * np.sin(np.pi * y)\n    grad_u_ex = lambda x, y: np.array([\n        np.pi * np.cos(np.pi * x) * np.sin(np.pi * y),\n        np.pi * np.sin(np.pi * x) * np.cos(np.pi * y)\n    ])\n    f_source = lambda x, y: 2 * np.pi**2 * np.sin(np.pi * x) * np.sin(np.pi * y)\n    \n    mesh_sizes = [2, 4, 8]\n    errors = []\n\n    GQ_ORDER_ASSEMBLY = 4\n    GQ_ORDER_ERROR = 6\n    gp_assembly, gw_assembly = get_gauss_points(GQ_ORDER_ASSEMBLY)\n    gp_error, gw_error = get_gauss_points(GQ_ORDER_ERROR)\n\n    for N in mesh_sizes:\n        h = 1.0 / N\n        num_nodes_1d = 2 * N + 1\n        num_nodes = num_nodes_1d**2\n        \n        nodes = np.zeros((num_nodes, 2))\n        for j in range(num_nodes_1d):\n            for i in range(num_nodes_1d):\n                nodes[j * num_nodes_1d + i] = [i * h / 2.0, j * h / 2.0]\n\n        elements = []\n        for j in range(N):\n            for i in range(N):\n                el_nodes = np.zeros(9, dtype=int)\n                for row in range(3):\n                    for col in range(3):\n                        node_x_idx = 2 * i + col\n                        node_y_idx = 2 * j + row\n                        el_nodes[row * 3 + col] = node_y_idx * num_nodes_1d + node_x_idx\n                elements.append(el_nodes)\n        \n        K_global = np.zeros((num_nodes, num_nodes))\n        F_global = np.zeros(num_nodes)\n        \n        for el_nodes in elements:\n            k_elem = np.zeros((9, 9))\n            f_elem = np.zeros(9)\n            \n            x_nodes = nodes[el_nodes]\n            x_c = np.mean(x_nodes, axis=0) # Center of the element\n            \n            # Jacobian for affine map from [-1,1]^2 to [x-h/2,x+h/2]x[y-h/2,y+h/2]\n            det_J = (h / 2.0)**2\n            inv_J_T = np.array([[2.0 / h, 0], [0, 2.0 / h]])\n\n            for i in range(GQ_ORDER_ASSEMBLY):\n                for j in range(GQ_ORDER_ASSEMBLY):\n                    xi, eta = gp_assembly[i], gp_assembly[j]\n                    weight = gw_assembly[i] * gw_assembly[j]\n                    \n                    x_phys = x_c[0] + xi * h / 2.0\n                    y_phys = x_c[1] + eta * h / 2.0\n                    \n                    N_vals = shape_functions(xi, eta)\n                    dN_dxi_eta = shape_function_derivatives(xi, eta)\n                    \n                    dN_dx_dy = dN_dxi_eta @ inv_J_T\n                    \n                    B = dN_dx_dy.T\n                    k_elem += (B.T @ B) * weight * det_J\n                    \n                    f_val = f_source(x_phys, y_phys)\n                    f_elem += f_val * N_vals * weight * det_J\n            \n            for i in range(9):\n                for j in range(9):\n                    K_global[el_nodes[i], el_nodes[j]] += k_elem[i, j]\n                F_global[el_nodes[i]] += f_elem[i]\n\n        boundary_nodes = [i for i in range(num_nodes) if (nodes[i,0]==0 or nodes[i,0]==1 or nodes[i,1]==0 or nodes[i,1]==1)]\n        interior_nodes = list(set(range(num_nodes)) - set(boundary_nodes))\n\n        K_interior = K_global[np.ix_(interior_nodes, interior_nodes)]\n        F_interior = F_global[interior_nodes]\n        \n        U_interior = np.linalg.solve(K_interior, F_interior)\n        \n        U_global = np.zeros(num_nodes)\n        U_global[interior_nodes] = U_interior\n        \n        err_H1_sq = 0.0\n        err_L2_sq = 0.0\n\n        for el_nodes in elements:\n            x_nodes = nodes[el_nodes]\n            u_elem = U_global[el_nodes]\n            x_c = np.mean(x_nodes, axis=0)\n            det_J = (h / 2.0)**2\n            inv_J_T = np.array([[2.0 / h, 0], [0, 2.0 / h]])\n            \n            for i in range(GQ_ORDER_ERROR):\n                for j in range(GQ_ORDER_ERROR):\n                    xi, eta = gp_error[i], gp_error[j]\n                    weight = gw_error[i] * gw_error[j]\n                    \n                    x_phys = x_c[0] + xi * h / 2.0\n                    y_phys = x_c[1] + eta * h / 2.0\n                    \n                    N_vals = shape_functions(xi, eta)\n                    dN_dxi_eta = shape_function_derivatives(xi, eta)\n                    dN_dx_dy = dN_dxi_eta @ inv_J_T\n                    \n                    u_h = np.dot(N_vals, u_elem)\n                    grad_u_h = u_elem @ dN_dx_dy\n                    \n                    u_exact_val = u_ex(x_phys, y_phys)\n                    grad_u_exact_val = grad_u_ex(x_phys, y_phys)\n                    \n                    err_L2_sq += (u_exact_val - u_h)**2 * weight * det_J\n                    err_H1_sq += np.sum((grad_u_exact_val - grad_u_h)**2) * weight * det_J\n\n        errors.append((np.sqrt(err_H1_sq), np.sqrt(err_L2_sq)))\n\n    eH1_N2, eL2_N2 = errors[0]\n    eH1_N4, eL2_N4 = errors[1]\n    eH1_N8, eL2_N8 = errors[2]\n\n    rateH1_24 = np.log(eH1_N2 / eH1_N4) / np.log(2)\n    rateH1_48 = np.log(eH1_N4 / eH1_N8) / np.log(2)\n    rateL2_24 = np.log(eL2_N2 / eL2_N4) / np.log(2)\n    rateL2_48 = np.log(eL2_N4 / eL2_N8) / np.log(2)\n\n    boolH1_24 = rateH1_24 > 1.9\n    boolL2_24 = rateL2_24 > 2.8\n    boolH1All = (rateH1_24 > 1.9) and (rateH1_48 > 1.9)\n    boolL2All = (rateL2_24 > 2.8) and (rateL2_48 > 2.8)\n\n    output = [\n        f\"{eH1_N2:.8f}\", f\"{eL2_N2:.8f}\",\n        f\"{eH1_N4:.8f}\", f\"{eL2_N4:.8f}\",\n        f\"{eH1_N8:.8f}\", f\"{eL2_N8:.8f}\",\n        f\"{rateH1_24:.8f}\", f\"{rateH1_48:.8f}\",\n        f\"{rateL2_24:.8f}\", f\"{rateL2_48:.8f}\",\n        str(boolH1All), str(boolL2All),\n        str(boolH1_24), str(boolL2_24)\n    ]\n    \n    print(f\"[{','.join(output)}]\")\n\nsolve()\n\n```", "id": "3583965"}, {"introduction": "Even a verified, accurate element can exhibit pathological behavior in certain physical regimes. One of the most notorious issues is \"volumetric locking,\" where an element becomes excessively stiff when modeling nearly incompressible materials, leading to inaccurate results. In this practice [@problem_id:3584031], you will diagnose this issue in the fully-integrated Q9 element and implement a widely-used remedy, the selective integration or $\\bar{\\mathbf{B}}$ method, demonstrating its effectiveness in restoring physical accuracy.", "problem": "Implement, from first principles, a small-strain, two-dimensional isoparametric Finite Element Method (FEM) for a single nine-node Lagrangian quadrilateral element (often abbreviated as Q9) to study the effect of selective integration on volumetric locking. Consider linear, isotropic elasticity under plane strain with Lamé parameters $\\lambda$ and $\\mu$ defined from Young’s modulus $E$ and Poisson’s ratio $\\nu$ by $\\lambda = \\dfrac{E \\nu}{(1+\\nu)(1-2\\nu)}$ and $\\mu = \\dfrac{E}{2(1+\\nu)}$. The governing equations in the absence of body forces are derived from the quasi-static balance of linear momentum $\\nabla \\cdot \\boldsymbol{\\sigma} = \\boldsymbol{0}$, with the linear constitutive relation $\\boldsymbol{\\sigma} = \\mathbf{D} \\boldsymbol{\\varepsilon}$ and small strain tensor $\\boldsymbol{\\varepsilon} = \\mathrm{sym}(\\nabla \\boldsymbol{u})$. Under plane strain, the elasticity (constitutive) matrix in Voigt notation $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^T$ is\n$$\n\\mathbf{D} = \n\\begin{bmatrix}\n\\lambda + 2\\mu & \\lambda & 0 \\\\\n\\lambda & \\lambda + 2\\mu & 0 \\\\\n0 & 0 & \\mu\n\\end{bmatrix}.\n$$\nUse the isoparametric mapping with biquadratic Lagrange shape functions on the parent square $(\\xi,\\eta)\\in[-1,1]^2$ and perform numerical integration by Gaussian Quadrature (GQ). The element stiffness matrix is \n$$\n\\mathbf{K}_e = \\int_{\\Omega_e} \\mathbf{B}^T \\mathbf{D} \\mathbf{B} \\, d\\Omega,\n$$\nwhere $\\mathbf{B}$ is the standard strain-displacement matrix built from spatial derivatives of shape functions. Apply a uniform traction $\\boldsymbol{t} = [p, 0]^T$ on the right edge $\\Gamma_t$ of the element and assemble the consistent nodal force vector \n$$\n\\mathbf{f}_t = \\int_{\\Gamma_t} \\mathbf{N}^T \\boldsymbol{t} \\, d\\Gamma,\n$$\nwhere $\\mathbf{N}$ collects the scalar shape functions and the line integral is evaluated by one-dimensional Gaussian Quadrature on that edge.\n\nYour task is to implement two integration strategies for the same Q9 element:\n- Full integration: use $3\\times 3$ Gaussian Quadrature for the domain integral in $\\mathbf{K}_e$ without modification to $\\mathbf{B}$.\n- Selective integration via a $\\bar{\\mathbf{B}}$-type modification: construct a modified $\\bar{\\mathbf{B}}$ at each $3\\times 3$ Gaussian point by replacing only the volumetric (dilatational) part of the strain with its element mean, approximated by a single $1\\times 1$ Gaussian point at the element center. Let $\\frac{\\partial N_i}{\\partial x}$ and $\\frac{\\partial N_i}{\\partial y}$ denote spatial derivatives of the $i$-th shape function at a given quadrature point, and let $\\langle \\frac{\\partial N_i}{\\partial x} \\rangle$ and $\\langle \\frac{\\partial N_i}{\\partial y} \\rangle$ denote their elementwise averages computed using the central $1\\times 1$ quadrature. To enforce that the dilatation $\\varepsilon_{xx} + \\varepsilon_{yy}$ equals its element mean while leaving the shear unchanged, modify the first two rows of $\\mathbf{B}$ as follows: for each node $i$, with the $2\\times 1$ displacement vector at node $i$ collecting $(u_i, v_i)$,\n- define $\\Delta_i^x = \\langle \\tfrac{\\partial N_i}{\\partial x} \\rangle - \\tfrac{\\partial N_i}{\\partial x}$ and $\\Delta_i^y = \\langle \\tfrac{\\partial N_i}{\\partial y} \\rangle - \\tfrac{\\partial N_i}{\\partial y}$,\n- add $\\tfrac{1}{2}\\Delta_i^x$ to the $(\\varepsilon_{xx}, u_i)$ entry and $\\tfrac{1}{2}\\Delta_i^y$ to the $(\\varepsilon_{xx}, v_i)$ entry,\n- add $\\tfrac{1}{2}\\Delta_i^x$ to the $(\\varepsilon_{yy}, u_i)$ entry and $\\tfrac{1}{2}\\Delta_i^y$ to the $(\\varepsilon_{yy}, v_i)$ entry,\n- leave the shear row (for $\\gamma_{xy}$) unchanged.\nThis enforces that $\\varepsilon_{xx}+\\varepsilon_{yy}$ is replaced by its elementwise average while preserving the deviatoric and shear content, which mitigates volumetric locking.\n\nGeometry, material, and loading:\n- Single Q9 element spanning the unit square with physical coordinates $(x,y)\\in[0,1]\\times[0,1]$ in meters, obtained by mapping the standard Q9 parent nodes $(\\xi,\\eta)\\in\\{(-1,-1),(1,-1),(1,1),(-1,1),(0,-1),(1,0),(0,1),(-1,0),(0,0)\\}$ via $x=\\frac{\\xi+1}{2}$ and $y=\\frac{\\eta+1}{2}$.\n- Thickness $t = 1$ meter (plane strain).\n- Young’s modulus $E = 1000$ Pascals.\n- Right edge traction magnitude $p = 1$ Newton per meter, applied in the positive $x$-direction.\n- Essential boundary conditions: fix both displacement components $u=v=0$ on the left edge $x=0$ (all nodes lying at $x=0$).\n\nQuantity of interest:\n- For each case, compute the horizontal displacement $u_x$ at the mid-node on the right edge (node at $(x,y)=(1,0.5)$, which is node $6$ in standard Q9 ordering) in meters.\n\nTest suite:\n- Three Poisson’s ratios $\\nu \\in \\{0.0, 0.3, 0.49\\}$ (unitless).\n- For each $\\nu$, compute two values: the full integration result $u_x^{\\text{full}}$ and the selective-integration result $u_x^{\\text{sel}}$, both in meters as floating-point numbers.\n\nFinal output format:\n- Your program should produce a single line of output containing a flat, comma-separated list of six numbers corresponding to $[u_x^{\\text{full}}(\\nu=0.0), u_x^{\\text{sel}}(\\nu=0.0), u_x^{\\text{full}}(\\nu=0.3), u_x^{\\text{sel}}(\\nu=0.3), u_x^{\\text{full}}(\\nu=0.49), u_x^{\\text{sel}}(\\nu=0.49)]$, expressed in meters and each rounded to six decimal places.\n- Example of the required formatting pattern (illustrative only): \"[0.001234,0.001567,0.000890,0.001234,0.000100,0.001200]\".\n\nScientific and numerical constraints:\n- Use the fundamental weak form of linear elasticity, small-strain kinematics, and standard isoparametric Q9 interpolation.\n- Use $3\\times 3$ Gaussian Quadrature for domain integrals in both strategies; in the selective strategy, use a central $1\\times 1$ quadrature solely to compute the element-mean derivatives that define the $\\bar{\\mathbf{B}}$ modification.\n- Use $3$-point Gaussian Quadrature for the right-edge traction integral.\n- Plane strain assumption must be used consistently.\n- All physical quantities must be reported in meters for displacements and Pascals for stiffness quantities internally, but only the displacements are to be printed in the final output line as specified.", "solution": "The user-provided problem is a valid, well-posed exercise in computational solid mechanics. It is scientifically grounded in the principles of linear elasticity and the Finite Element Method (FEM), contains all necessary data for a unique solution, and is formulated with objective and precise language. The task is to implement a two-dimensional, small-strain, isoparametric FEM analysis for a single nine-node Lagrangian quadrilateral (Q9) element to compare the effects of full and selective numerical integration on volumetric locking.\n\nThe solution proceeds as follows: First, we establish the theoretical framework, including the governing equations, the isoparametric Q9 element formulation, and the material model. Second, we detail the two numerical integration strategies: standard full integration and the selective integration scheme using the $\\bar{\\mathbf{B}}$ method. Finally, we outline the procedure for assembling the system of equations, applying boundary conditions, and solving for the nodal displacements.\n\n### 1. Theoretical Formulation\n\nThe problem is governed by the quasi-static balance of linear momentum, which in the absence of body forces is $\\nabla \\cdot \\boldsymbol{\\sigma} = \\boldsymbol{0}$, where $\\boldsymbol{\\sigma}$ is the Cauchy stress tensor. For small strains, the strain tensor is $\\boldsymbol{\\varepsilon} = \\mathrm{sym}(\\nabla \\boldsymbol{u})$, where $\\boldsymbol{u}$ is the displacement field. The material is linear, elastic, and isotropic, following the constitutive relation $\\boldsymbol{\\sigma} = \\mathbf{D} \\boldsymbol{\\varepsilon}$.\n\nThe weak form of the governing equation, which is the basis of the FEM, leads to the element-level matrix equation:\n$$\n\\mathbf{K}_e \\mathbf{d}_e = \\mathbf{f}_e\n$$\nwhere $\\mathbf{d}_e$ is the vector of nodal displacements for the element, $\\mathbf{K}_e$ is the element stiffness matrix, and $\\mathbf{f}_e$ is the element nodal force vector.\n\nThe element stiffness matrix is given by the integral over the element's domain $\\Omega_e$:\n$$\n\\mathbf{K}_e = \\int_{\\Omega_e} \\mathbf{B}^T \\mathbf{D} \\mathbf{B} \\, d\\Omega\n$$\nThe strain-displacement matrix, $\\mathbf{B}$, relates nodal displacements to strain components: $\\boldsymbol{\\varepsilon} = \\mathbf{B} \\mathbf{d}_e$.\n\n### 2. Isoparametric Nine-Node Quadrilateral (Q9) Element\n\nWe use a Q9 element defined on a parent square domain $(\\xi, \\eta) \\in [-1, 1]^2$. The element has nine nodes located at the grid points of $\\{-1, 0, 1\\} \\times \\{-1, 0, 1\\}$. The physical coordinates $(x, y)$ are mapped from the parent coordinates $(\\xi, \\eta)$ using the same shape functions used for interpolating the displacement field (isoparametric concept):\n$$\nx(\\xi, \\eta) = \\sum_{i=1}^{9} N_i(\\xi, \\eta) x_i, \\quad y(\\xi, \\eta) = \\sum_{i=1}^{9} N_i(\\xi, \\eta) y_i\n$$\nwhere $(x_i, y_i)$ are the physical coordinates of node $i$. For the specified unit square geometry $(x,y)\\in[0,1]^2$, the mapping is $x = (\\xi+1)/2$ and $y = (\\eta+1)/2$.\n\nThe biquadratic Lagrange shape functions $N_i(\\xi, \\eta)$ are products of 1D quadratic Lagrange polynomials. For a node $i$ at parent coordinates $(\\xi_i, \\eta_i)$:\n$N_i(\\xi, \\eta) = L(\\xi, \\xi_i) L(\\eta, \\eta_i)$, where\n$$\nL(t, t_i) = \n\\begin{cases}\n    \\frac{1}{2} t(t-1) & \\text{if } t_i = -1 \\\\\n    1 - t^2 & \\text{if } t_i = 0 \\\\\n    \\frac{1}{2} t(t+1) & \\text{if } t_i = 1\n\\end{cases}\n$$\nThe chain rule relates spatial derivatives to derivatives in the parent domain:\n$$\n\\begin{Bmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{Bmatrix} = \\mathbf{J}^{-1} \\begin{Bmatrix} \\frac{\\partial N_i}{\\partial \\xi} \\\\ \\frac{\\partial N_i}{\\partial \\eta} \\end{Bmatrix}\n$$\nwhere $\\mathbf{J}$ is the Jacobian matrix of the coordinate transformation. For the given mapping, $\\mathbf{J}$ is constant: $\\mathbf{J} = \\begin{bmatrix} 1/2 & 0 \\\\ 0 & 1/2 \\end{bmatrix}$, so $\\det(\\mathbf{J})=1/4$.\n\nThe strain-displacement matrix $\\mathbf{B}$ for a 2D problem is a $3 \\times 18$ matrix, composed of $3 \\times 2$ blocks for each of the $9$ nodes:\n$$\n\\mathbf{B} = [\\mathbf{B}_1, \\mathbf{B}_2, \\dots, \\mathbf{B}_9], \\quad \\mathbf{B}_i = \\begin{bmatrix} \\frac{\\partial N_i}{\\partial x} & 0 \\\\ 0 & \\frac{\\partial N_i}{\\partial y} \\\\ \\frac{\\partial N_i}{\\partial y} & \\frac{\\partial N_i}{\\partial x} \\end{bmatrix}\n$$\n\n### 3. Material Constitutive Model: Plane Strain\n\nUnder the plane strain assumption ($\\varepsilon_{zz}=0$), the constitutive matrix $\\mathbf{D}$ relates the in-plane stress and strain components ($\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^T$) via Lamé parameters $\\lambda$ and $\\mu$:\n$$\n\\mathbf{D} = \n\\begin{bmatrix}\n\\lambda + 2\\mu & \\lambda & 0 \\\\\n\\lambda & \\lambda + 2\\mu & 0 \\\\\n0 & 0 & \\mu\n\\end{bmatrix}\n$$\nThe parameters are defined from Young’s modulus $E$ and Poisson’s ratio $\\nu$ as:\n$$\n\\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)}, \\quad \\mu = \\frac{E}{2(1+\\nu)}\n$$\nAs $\\nu \\to 0.5$ (incompressible limit), $\\lambda \\to \\infty$, which can lead to numerical instability known as volumetric locking.\n\n### 4. Integration Schemes\n\nThe stiffness integral is evaluated numerically using Gaussian Quadrature (GQ):\n$$\n\\mathbf{K}_e = \\int_{-1}^1 \\int_{-1}^1 \\mathbf{B}^T(\\xi, \\eta) \\mathbf{D} \\mathbf{B}(\\xi, \\eta) \\det(\\mathbf{J}) \\, d\\xi \\, d\\eta \\approx \\sum_{j=1}^{n_{gp}} \\sum_{k=1}^{n_{gp}} w_j w_k \\left[ \\mathbf{B}^T \\mathbf{D} \\mathbf{B} \\det(\\mathbf{J}) \\right]_{(\\xi_j, \\eta_k)}\n$$\n\n**Full Integration:**\nThis approach uses a $3 \\times 3$ grid of Gaussian points ($n_{gp}=3$), which is sufficient to exactly integrate the stiffness matrix for a rectangular Q9 element. However, it is susceptible to volumetric locking for nearly incompressible materials.\n\n**Selective Integration ($\\bar{\\mathbf{B}}$ Method):**\nThis method mitigates locking by modifying the strain-displacement matrix to enforce a constant volumetric strain across the element. The element stiffness is still computed using a $3 \\times 3$ GQ, but at each quadrature point $(\\xi_{gp}, \\eta_{gp})$, a modified matrix $\\bar{\\mathbf{B}}$ is used. The modification steps are:\n\n1.  Compute the standard spatial derivatives $\\frac{\\partial N_i}{\\partial x}$ and $\\frac{\\partial N_i}{\\partial y}$ at the current $3 \\times 3$ quadrature point.\n2.  Compute the element-mean spatial derivatives $\\langle \\frac{\\partial N_i}{\\partial x} \\rangle$ and $\\langle \\frac{\\partial N_i}{\\partial y} \\rangle$ by evaluating them at the element center $(\\xi=0, \\eta=0)$, which corresponds to a $1 \\times 1$ GQ rule.\n3.  For each node $i$, define the deviation terms: $\\Delta_i^x = \\langle \\tfrac{\\partial N_i}{\\partial x} \\rangle - \\tfrac{\\partial N_i}{\\partial x}$ and $\\Delta_i^y = \\langle \\tfrac{\\partial N_i}{\\partial y} \\rangle - \\tfrac{\\partial N_i}{\\partial y}$.\n4.  Construct the modified matrix $\\bar{\\mathbf{B}}$ by adjusting the blocks $\\mathbf{B}_i$ of the standard matrix $\\mathbf{B}$:\n    $$\n    \\bar{\\mathbf{B}}_i = \\begin{bmatrix}\n    \\frac{\\partial N_i}{\\partial x} + \\frac{1}{2}\\Delta_i^x & \\frac{1}{2}\\Delta_i^y \\\\\n    \\frac{1}{2}\\Delta_i^x & \\frac{\\partial N_i}{\\partial y} + \\frac{1}{2}\\Delta_i^y \\\\\n    \\frac{\\partial N_i}{\\partial y} & \\frac{\\partial N_i}{\\partial x}\n    \\end{bmatrix}\n    $$\nThis modification ensures that the computed volumetric strain $\\varepsilon_v = \\varepsilon_{xx} + \\varepsilon_{yy}$ is replaced by its element-wise average $\\langle \\varepsilon_v \\rangle$, effectively decoupling the volumetric response from higher-order deformation modes and preventing locking.\n\n### 5. Force Vector, Boundary Conditions, and Solution\n\nThe external load is a uniform traction $\\boldsymbol{t} = [p, 0]^T$ on the right edge ($x=1$, or $\\xi=1$). The consistent nodal force vector is computed by a line integral, evaluated using $3$-point one-dimensional GQ:\n$$\n\\mathbf{f}_t = \\int_{\\Gamma_t} \\mathbf{N}^T \\boldsymbol{t} \\, d\\Gamma = \\int_{-1}^1 \\mathbf{N}(\\xi=1, \\eta)^T \\begin{Bmatrix} p \\\\ 0 \\end{Bmatrix} |\\frac{d\\mathbf{x}}{d\\eta}| d\\eta \\approx \\sum_{k=1}^{3} w_k \\left[ \\mathbf{N}^T \\begin{Bmatrix} p \\\\ 0 \\end{Bmatrix} \\frac{1}{2} \\right]_{(\\xi=1, \\eta_k)}\n$$\nwhere $|d\\mathbf{x}/d\\eta|=1/2$ is the length of the differential line element on the edge.\n\nEssential boundary conditions $u=v=0$ are applied on the left edge ($x=0$), fixing the degrees of freedom (DOFs) associated with nodes 1, 4, and 8. The system $\\mathbf{K}\\mathbf{d} = \\mathbf{f}$ is partitioned into free and prescribed DOFs, and the reduced system $\\mathbf{K}_{ff} \\mathbf{d}_f = \\mathbf{f}_f$ is solved for the unknown displacements $\\mathbf{d}_f$. The horizontal displacement $u_x$ at the mid-node of the right edge (node 6) is then extracted from the solution vector.\nThis procedure is repeated for each specified value of Poisson's ratio $\\nu$ and for both integration schemes. The results demonstrate that for $\\nu$ approaching $0.5$, the full integration scheme produces an overly stiff response (small displacement), a classic sign of volumetric locking, while the selective integration scheme yields a more physically plausible result.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy is not needed for this problem, numpy.polynomial is sufficient\nfrom numpy.polynomial.legendre import leggauss\n\ndef solve():\n    \"\"\"\n    Implements a 2D FEM analysis for a single Q9 element to study volumetric locking.\n    \"\"\"\n    \n    def get_q9_shape_functions_and_derivs(xi, eta):\n        \"\"\"\n        Calculates the shape functions and their derivatives for a Q9 element \n        at a given point (xi, eta) in the parent domain.\n\n        Node ordering used internally, standard counter-clockwise from bottom-left corner,\n        then mid-side nodes, then center node.\n        1(-1,-1), 2(1,-1), 3(1,1), 4(-1,1), 5(0,-1), 6(1,0), 7(0,1), 8(-1,0), 9(0,0)\n        \"\"\"\n        # Nodal coordinates in parent domain [-1, 1] x [-1, 1]\n        xis = [-1, 1, 1, -1, 0, 1, 0, -1, 0]\n        etas = [-1, -1, 1, 1, -1, 0, 1, 0, 0]\n        \n        N = np.zeros(9)\n        dN_dxi = np.zeros(9)\n        dN_deta = np.zeros(9)\n\n        # 1D Lagrange Polynomials and their derivatives\n        def get_1d_poly_and_deriv(t, t_node):\n            if t_node == -1:\n                L = 0.5 * t * (t-1)\n                dL_dt = t - 0.5\n            elif t_node == 0:\n                L = 1 - t**2\n                dL_dt = -2*t\n            elif t_node == 1:\n                L = 0.5 * t * (t+1)\n                dL_dt = t + 0.5\n            else:\n                raise ValueError(\"Invalid nodal coordinate\")\n            return L, dL_dt\n\n        for i in range(9):\n            xi_node, eta_node = xis[i], etas[i]\n            \n            L_xi, dL_dxi = get_1d_poly_and_deriv(xi, xi_node)\n            L_eta, dL_deta = get_1d_poly_and_deriv(eta, eta_node)\n            \n            N[i] = L_xi * L_eta\n            dN_dxi[i] = dL_dxi * L_eta\n            dN_deta[i] = L_xi * dL_deta\n            \n        return N, dN_dxi, dN_deta\n\n    def get_fem_solution(E, nu, integration_type):\n        \"\"\"\n        Calculates the displacement for a given material and integration type.\n        \"\"\"\n        # Material parameters for plane strain\n        if abs(1 - 2*nu)  1e-9: # Handle the incompressible limit case\n             lambda_ = 1e12 * E # Use a large number\n        else:\n            lambda_ = E * nu / ((1 + nu) * (1 - 2 * nu))\n        mu = E / (2 * (1 + nu))\n\n        D = np.array([\n            [lambda_ + 2 * mu, lambda_, 0],\n            [lambda_, lambda_ + 2 * mu, 0],\n            [0, 0, mu]\n        ])\n\n        # Isoparametric mapping and Jacobian\n        J = np.array([[0.5, 0.0], [0.0, 0.5]])\n        detJ = np.linalg.det(J)\n        J_inv = np.linalg.inv(J)\n\n        # Stiffness Matrix K_e (18x18)\n        K_e = np.zeros((18, 18))\n        \n        # Gaussian quadrature for domain integral\n        gp_3, w_3 = leggauss(3)\n        \n        # Element-mean derivatives for B-bar method\n        if integration_type == 'selective':\n            _, dN_dxi_mean, dN_deta_mean = get_q9_shape_functions_and_derivs(0, 0)\n            dN_dx_mean = J_inv[0, 0] * dN_dxi_mean\n            dN_dy_mean = J_inv[1, 1] * dN_deta_mean\n\n        for i in range(3):\n            for j in range(3):\n                xi, eta = gp_3[i], gp_3[j]\n                weight = w_3[i] * w_3[j]\n                \n                _, dN_dxi, dN_deta = get_q9_shape_functions_and_derivs(xi, eta)\n                \n                # Spatial derivatives dN/dx, dN/dy\n                dN_dx = J_inv[0, 0] * dN_dxi\n                dN_dy = J_inv[1, 1] * dN_deta\n\n                # Strain-displacement matrix B (3x18)\n                B = np.zeros((3, 18))\n                for k in range(9):\n                    B[0, 2*k] = dN_dx[k]\n                    B[1, 2*k+1] = dN_dy[k]\n                    B[2, 2*k] = dN_dy[k]\n                    B[2, 2*k+1] = dN_dx[k]\n\n                # B-bar modification for selective integration\n                if integration_type == 'selective':\n                    B_bar = np.zeros_like(B)\n                    for k in range(9):\n                        delta_x = dN_dx_mean[k] - dN_dx[k]\n                        delta_y = dN_dy_mean[k] - dN_dy[k]\n                        B_bar[0, 2*k]   = dN_dx[k] + 0.5 * delta_x\n                        B_bar[0, 2*k+1] = 0.5 * delta_y\n                        B_bar[1, 2*k]   = 0.5 * delta_x\n                        B_bar[1, 2*k+1] = dN_dy[k] + 0.5 * delta_y\n                        B_bar[2, 2*k]   = dN_dy[k]\n                        B_bar[2, 2*k+1] = dN_dx[k]\n                    B_to_use = B_bar\n                else: # full integration\n                    B_to_use = B\n\n                K_e += B_to_use.T @ D @ B_to_use * detJ * weight\n\n        # Force vector F_t (18x1)\n        F_t = np.zeros(18)\n        p = 1.0  # Traction magnitude N/m\n        \n        # 1D GQ for line integral on right edge (xi=1)\n        gp_3_1d, w_3_1d = leggauss(3)\n        dl_deta = 0.5  # |dy/deta| on edge xi=1\n        \n        for i in range(3):\n            eta = gp_3_1d[i]\n            weight = w_3_1d[i]\n            \n            N, _, _ = get_q9_shape_functions_and_derivs(1, eta)\n            \n            for k in range(9):\n                F_t[2*k] += N[k] * p * dl_deta * weight\n                \n        # Apply boundary conditions\n        # Fix nodes 1, 4, 8 (left edge, x=0)\n        # 0-indexed DOFs to fix: 0,1 (node 1), 6,7 (node 4), 14,15 (node 8)\n        fixed_dofs = [0, 1, 6, 7, 14, 15]\n        all_dofs = list(range(18))\n        free_dofs = [dof for dof in all_dofs if dof not in fixed_dofs]\n\n        K_ff = K_e[np.ix_(free_dofs, free_dofs)]\n        F_f = F_t[free_dofs]\n\n        # Solve for free displacements\n        U_f = np.linalg.solve(K_ff, F_f)\n        \n        # DOF of interest: u_x at node 6 (x=1, y=0.5 -> xi=1, eta=0)\n        # Node 6 has DOFs 10 (u) and 11 (v) (0-indexed)\n        target_dof = 10\n        target_idx_in_Uf = free_dofs.index(target_dof)\n        \n        return U_f[target_idx_in_Uf]\n\n    # --- Main execution ---\n    test_cases = [0.0, 0.3, 0.49]\n    E = 1000.0  # Pascals\n    \n    results = []\n    \n    for nu in test_cases:\n        # Full integration\n        ux_full = get_fem_solution(E, nu, integration_type='full')\n        results.append(ux_full)\n        \n        # Selective integration\n        ux_sel = get_fem_solution(E, nu, integration_type='selective')\n        results.append(ux_sel)\n\n    # Format output as specified\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3584031"}]}