{"hands_on_practices": [{"introduction": "A cornerstone of hyperelasticity is the equivalence of mechanical work, regardless of the specific stress and strain measures used, provided they form a thermodynamically conjugate pair. This foundational exercise reinforces this principle by exploring the relationship between two common Lagrangian pairs: the first Piola-Kirchhoff stress $\\boldsymbol{P}$ and the deformation gradient $\\boldsymbol{F}$, and the second Piola-Kirchhoff stress $\\boldsymbol{S}$ and the Green-Lagrange strain $\\boldsymbol{E}$. By first deriving the fundamental kinematic identity $\\boldsymbol{P} = \\boldsymbol{F} \\boldsymbol{S}$ and then verifying it numerically, you will build a concrete understanding of how these different descriptions are elegantly connected through the principle of work conjugacy [@problem_id:3606700].", "problem": "Consider a hyperelastic solid undergoing finite deformation. Let the deformation gradient be denoted by $\\boldsymbol{F} \\in \\mathbb{R}^{3 \\times 3}$ with Jacobian $J = \\det \\boldsymbol{F} > 0$, the right Cauchy–Green tensor be $\\boldsymbol{C} = \\boldsymbol{F}^{\\mathsf{T}} \\boldsymbol{F}$, and the Green–Lagrange strain be $\\boldsymbol{E} = \\tfrac{1}{2}(\\boldsymbol{C} - \\boldsymbol{I})$, where $\\boldsymbol{I}$ is the identity tensor. The first and second Piola–Kirchhoff stresses are denoted by $\\boldsymbol{P}$ and $\\boldsymbol{S}$, respectively. The specific Helmholtz free energy (strain energy density) per unit reference volume is taken as a compressible neo-Hookean model\n$$\n\\Psi(\\boldsymbol{C}) = \\frac{\\mu}{2}\\big(\\operatorname{tr} \\boldsymbol{C} - 3\\big) - \\mu \\ln J + \\frac{\\kappa}{2}\\big(\\ln J\\big)^2,\n$$\nwhere $\\mu > 0$ is the shear modulus, $\\kappa > 0$ is the bulk modulus, and $J = \\sqrt{\\det \\boldsymbol{C}}$.\n\nTasks:\n- Starting only from fundamental definitions $\\boldsymbol{S} = 2\\,\\partial \\Psi / \\partial \\boldsymbol{C}$ and $\\boldsymbol{P} = \\partial \\Psi / \\partial \\boldsymbol{F}$, use the chain rule and tensor calculus to derive the kinematic identity that relates these thermodynamic conjugate pairs, namely to show that $\\boldsymbol{P} = \\boldsymbol{F} \\boldsymbol{S}$, and to establish the work-conjugacy equivalence $\\boldsymbol{P} : \\dot{\\boldsymbol{F}} = \\boldsymbol{S} : \\dot{\\boldsymbol{E}}$, where the superposed dot denotes a material time derivative and $\\boldsymbol{A} : \\boldsymbol{B} = \\operatorname{tr}(\\boldsymbol{A}^{\\mathsf{T}} \\boldsymbol{B})$ denotes the double contraction. Your derivation must be grounded in the basic kinematics $\\boldsymbol{C} = \\boldsymbol{F}^{\\mathsf{T}} \\boldsymbol{F}$ and $\\boldsymbol{E} = \\tfrac{1}{2}(\\boldsymbol{C} - \\boldsymbol{I})$ and must not assume any pre-known stress–strain formula beyond the stated definitions.\n- Implement a program that, for a set of prescribed test cases, numerically verifies:\n  $1)$ the identity $\\boldsymbol{P} = \\boldsymbol{F} \\boldsymbol{S}$ by comparing $\\boldsymbol{P}$ computed from $\\Psi(\\boldsymbol{F})$ with $\\boldsymbol{F} \\boldsymbol{S}$ computed from $\\Psi(\\boldsymbol{C})$, and \n  $2)$ the work-conjugacy equality $\\boldsymbol{P} : \\dot{\\boldsymbol{F}} = \\boldsymbol{S} : \\dot{\\boldsymbol{E}}$ using $\\dot{\\boldsymbol{E}} = \\tfrac{1}{2}(\\dot{\\boldsymbol{F}}^{\\mathsf{T}} \\boldsymbol{F} + \\boldsymbol{F}^{\\mathsf{T}} \\dot{\\boldsymbol{F}})$.\n  Use the Frobenius norm to measure tensor differences. Report each verification as a boolean indicating whether the absolute error is below a specified tolerance.\n- All quantities are nondimensional; do not attach physical units. Angles do not appear. Percentages are not used.\n\nUse the following test suite. Each test case specifies $(\\mu, \\kappa, \\boldsymbol{F}, \\dot{\\boldsymbol{F}})$:\n- Test case $1$ (general large deformation):\n  - $\\mu = 80.0$, $\\kappa = 240.0$,\n  - $\\boldsymbol{F} = \\begin{bmatrix} 1.30  0.40  0.00 \\\\ 0.20  0.90  0.10 \\\\ 0.00  0.05  1.20 \\end{bmatrix}$,\n  - $\\dot{\\boldsymbol{F}} = \\begin{bmatrix} 0.05  -0.02  0.00 \\\\ 0.03  0.01  -0.04 \\\\ 0.00  0.02  -0.01 \\end{bmatrix}$.\n- Test case $2$ (nearly volumetric stretch):\n  - $\\mu = 50.0$, $\\kappa = 500.0$,\n  - $\\boldsymbol{F} = \\begin{bmatrix} 1.05  0.00  0.00 \\\\ 0.00  1.05  0.00 \\\\ 0.00  0.00  1.05 \\end{bmatrix}$,\n  - $\\dot{\\boldsymbol{F}} = \\begin{bmatrix} 0.01  0.00  0.00 \\\\ 0.00  0.01  0.00 \\\\ 0.00  0.00  0.01 \\end{bmatrix}$.\n- Test case $3$ (isochoric shear-like deformation):\n  - $\\mu = 30.0$, $\\kappa = 90.0$,\n  - $\\boldsymbol{F} = \\begin{bmatrix} 1.20  0.50  0.00 \\\\ 0.00  0.8333333333333334  0.00 \\\\ 0.00  0.00  1.00 \\end{bmatrix}$,\n  - $\\dot{\\boldsymbol{F}} = \\begin{bmatrix} 0.00  0.03  0.00 \\\\ 0.00  -0.02  0.00 \\\\ 0.00  0.00  0.00 \\end{bmatrix}$.\n- Test case $4$ (near-incompressible mixed loading):\n  - $\\mu = 60.0$, $\\kappa = 6000.0$,\n  - $\\boldsymbol{F} = \\begin{bmatrix} 0.80  0.00  0.00 \\\\ 0.00  1.25  0.00 \\\\ 0.00  0.00  1.02 \\end{bmatrix}$,\n  - $\\dot{\\boldsymbol{F}} = \\begin{bmatrix} -0.01  0.00  0.00 \\\\ 0.00  0.015  0.00 \\\\ 0.00  0.00  -0.002 \\end{bmatrix}$.\n- Test case $5$ (strongly anisotropic stretch with positive Jacobian):\n  - $\\mu = 70.0$, $\\kappa = 210.0$,\n  - $\\boldsymbol{F} = \\begin{bmatrix} 0.50  0.00  0.00 \\\\ 0.00  0.90  0.00 \\\\ 0.00  0.00  2.80 \\end{bmatrix}$,\n  - $\\dot{\\boldsymbol{F}} = \\begin{bmatrix} 0.02  0.00  0.00 \\\\ 0.00  -0.01  0.00 \\\\ 0.00  0.00  0.03 \\end{bmatrix}$.\n\nFor each test case, perform the following numerical checks:\n- Compute $\\boldsymbol{S}$ from $\\Psi(\\boldsymbol{C})$ using $\\boldsymbol{S} = 2\\,\\partial \\Psi / \\partial \\boldsymbol{C}$.\n- Compute $\\boldsymbol{P}$ from $\\Psi(\\boldsymbol{F})$ using $\\boldsymbol{P} = \\partial \\Psi / \\partial \\boldsymbol{F}$.\n- Form $\\boldsymbol{F} \\boldsymbol{S}$ and compute the Frobenius-norm error $e_{1} = \\|\\boldsymbol{P} - \\boldsymbol{F} \\boldsymbol{S}\\|_{F}$.\n- Compute $\\dot{\\boldsymbol{E}} = \\tfrac{1}{2}(\\dot{\\boldsymbol{F}}^{\\mathsf{T}} \\boldsymbol{F} + \\boldsymbol{F}^{\\mathsf{T}} \\dot{\\boldsymbol{F}})$, then compute $e_{2} = \\big|\\,\\boldsymbol{P} : \\dot{\\boldsymbol{F}} - \\boldsymbol{S} : \\dot{\\boldsymbol{E}}\\,\\big|$.\n\nUse the tolerance $\\varepsilon = 10^{-10}$ for both checks. A check is deemed passed if the corresponding error is less than or equal to $\\varepsilon$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated Python-style list of length $5$, where each element is a two-element list $[b_{1}, b_{2}]$ of booleans corresponding to the pass/fail status of $(e_{1} \\le \\varepsilon)$ and $(e_{2} \\le \\varepsilon)$ for that test case, respectively. For example: \"[[True,True],[True,True],[True,True],[True,True],[True,True]]\".", "solution": "The problem is valid as it is scientifically grounded in the principles of continuum mechanics, is mathematically well-posed, objective, and provides a complete and consistent set of data and definitions for both the theoretical derivation and the numerical verification.\n\nThe solution is presented in two parts. First, a theoretical derivation of the required identities is provided. Second, the logic for the numerical implementation is outlined, which includes deriving the specific stress-strain relations from the given Helmholtz free energy function.\n\n### Theoretical Derivation\n\nThe derivation proceeds from the fundamental definitions provided for the first and second Piola-Kirchhoff stresses, $\\boldsymbol{P}$ and $\\boldsymbol{S}$, in terms of the Helmholtz free energy, $\\Psi$. The core mathematical tool is the chain rule for derivatives of tensor-valued functions.\n\n**1. Derivation of the Kinematic Identity $\\boldsymbol{P} = \\boldsymbol{F} \\boldsymbol{S}$**\n\nThe Helmholtz free energy $\\Psi$ is given as a function of the right Cauchy-Green tensor $\\boldsymbol{C}$, i.e., $\\Psi = \\hat{\\Psi}(\\boldsymbol{C})$. Since $\\boldsymbol{C}$ is a function of the deformation gradient $\\boldsymbol{F}$ through the kinematic relation $\\boldsymbol{C} = \\boldsymbol{F}^{\\mathsf{T}} \\boldsymbol{F}$, $\\Psi$ can also be considered a function of $\\boldsymbol{F}$, i.e., $\\Psi(\\boldsymbol{F}) = \\hat{\\Psi}(\\boldsymbol{C}(\\boldsymbol{F}))$.\n\nThe first Piola-Kirchhoff stress tensor $\\boldsymbol{P}$ is defined as the derivative of $\\Psi$ with respect to $\\boldsymbol{F}$:\n$$\n\\boldsymbol{P} = \\frac{\\partial \\Psi}{\\partial \\boldsymbol{F}}\n$$\nThis relationship implies that the differential of $\\Psi$ can be written as $\\mathrm{d}\\Psi = \\boldsymbol{P} : \\mathrm{d}\\boldsymbol{F}$, where the double contraction is defined as $\\boldsymbol{A} : \\boldsymbol{B} = \\operatorname{tr}(\\boldsymbol{A}^{\\mathsf{T}} \\boldsymbol{B})$.\n\nUsing the chain rule, we can express the derivative of $\\Psi$ with respect to $\\boldsymbol{F}$ in terms of its derivative with respect to $\\boldsymbol{C}$:\n$$\n\\mathrm{d}\\Psi = \\frac{\\partial \\Psi}{\\partial \\boldsymbol{C}} : \\mathrm{d}\\boldsymbol{C}\n$$\nThe problem defines the second Piola-Kirchhoff stress tensor $\\boldsymbol{S}$ as $\\boldsymbol{S} = 2 \\frac{\\partial \\Psi}{\\partial \\boldsymbol{C}}$, which implies $\\frac{\\partial \\Psi}{\\partial \\boldsymbol{C}} = \\frac{1}{2} \\boldsymbol{S}$. Substituting this into the expression for $\\mathrm{d}\\Psi$ yields:\n$$\n\\mathrm{d}\\Psi = \\frac{1}{2} \\boldsymbol{S} : \\mathrm{d}\\boldsymbol{C}\n$$\nNext, we find the differential of $\\boldsymbol{C}$:\n$$\n\\boldsymbol{C} = \\boldsymbol{F}^{\\mathsf{T}} \\boldsymbol{F} \\implies \\mathrm{d}\\boldsymbol{C} = \\mathrm{d}(\\boldsymbol{F}^{\\mathsf{T}}) \\boldsymbol{F} + \\boldsymbol{F}^{\\mathsf{T}} \\mathrm{d}\\boldsymbol{F} = (\\mathrm{d}\\boldsymbol{F})^{\\mathsf{T}} \\boldsymbol{F} + \\boldsymbol{F}^{\\mathsf{T}} \\mathrm{d}\\boldsymbol{F}\n$$\nSubstituting $\\mathrm{d}\\boldsymbol{C}$ into the expression for $\\mathrm{d}\\Psi$:\n$$\n\\mathrm{d}\\Psi = \\frac{1}{2} \\boldsymbol{S} : \\left( (\\mathrm{d}\\boldsymbol{F})^{\\mathsf{T}} \\boldsymbol{F} + \\boldsymbol{F}^{\\mathsf{T}} \\mathrm{d}\\boldsymbol{F} \\right) = \\frac{1}{2} \\left[ \\boldsymbol{S} : ((\\mathrm{d}\\boldsymbol{F})^{\\mathsf{T}} \\boldsymbol{F}) + \\boldsymbol{S} : (\\boldsymbol{F}^{\\mathsf{T}} \\mathrm{d}\\boldsymbol{F}) \\right]\n$$\nUsing the identity $\\boldsymbol{A}:\\boldsymbol{B} = \\operatorname{tr}(\\boldsymbol{A}^{\\mathsf{T}}\\boldsymbol{B})$ and the fact that $\\boldsymbol{S}$ is symmetric ($\\boldsymbol{S} = \\boldsymbol{S}^{\\mathsf{T}}$):\n$$\n\\mathrm{d}\\Psi = \\frac{1}{2} \\left[ \\operatorname{tr}(\\boldsymbol{S}^{\\mathsf{T}} (\\mathrm{d}\\boldsymbol{F})^{\\mathsf{T}} \\boldsymbol{F}) + \\operatorname{tr}(\\boldsymbol{S}^{\\mathsf{T}} \\boldsymbol{F}^{\\mathsf{T}} \\mathrm{d}\\boldsymbol{F}) \\right] = \\frac{1}{2} \\left[ \\operatorname{tr}(\\boldsymbol{S} (\\mathrm{d}\\boldsymbol{F})^{\\mathsf{T}} \\boldsymbol{F}) + \\operatorname{tr}(\\boldsymbol{S} \\boldsymbol{F}^{\\mathsf{T}} \\mathrm{d}\\boldsymbol{F}) \\right]\n$$\nUsing the cyclic property of the trace operator, $\\operatorname{tr}(ABC) = \\operatorname{tr}(BCA)$, the first term becomes $\\operatorname{tr}(\\boldsymbol{S} (\\mathrm{d}\\boldsymbol{F})^{\\mathsf{T}} \\boldsymbol{F}) = \\operatorname{tr}(\\boldsymbol{F} \\boldsymbol{S} (\\mathrm{d}\\boldsymbol{F})^{\\mathsf{T}})$. Using the property $\\operatorname{tr}(\\boldsymbol{A}) = \\operatorname{tr}(\\boldsymbol{A}^{\\mathsf{T}})$, this term is also equal to $\\operatorname{tr}((\\boldsymbol{F} \\boldsymbol{S} (\\mathrm{d}\\boldsymbol{F})^{\\mathsf{T}})^{\\mathsf{T}}) = \\operatorname{tr}(\\mathrm{d}\\boldsymbol{F} \\boldsymbol{S}^{\\mathsf{T}} \\boldsymbol{F}^{\\mathsf{T}}) = \\operatorname{tr}(\\mathrm{d}\\boldsymbol{F} \\boldsymbol{S} \\boldsymbol{F}^{\\mathsf{T}})$. Cycling the terms gives $\\operatorname{tr}(\\boldsymbol{S} \\boldsymbol{F}^{\\mathsf{T}} \\mathrm{d}\\boldsymbol{F})$. Thus, the two terms in the bracket are identical:\n$$\n\\operatorname{tr}(\\boldsymbol{S} (\\mathrm{d}\\boldsymbol{F})^{\\mathsf{T}} \\boldsymbol{F}) = \\operatorname{tr}(\\boldsymbol{S} \\boldsymbol{F}^{\\mathsf{T}} \\mathrm{d}\\boldsymbol{F})\n$$\nTherefore, the expression for $\\mathrm{d}\\Psi$ simplifies to:\n$$\n\\mathrm{d}\\Psi = \\frac{1}{2} \\left[ \\operatorname{tr}(\\boldsymbol{S} \\boldsymbol{F}^{\\mathsf{T}} \\mathrm{d}\\boldsymbol{F}) + \\operatorname{tr}(\\boldsymbol{S} \\boldsymbol{F}^{\\mathsf{T}} \\mathrm{d}\\boldsymbol{F}) \\right] = \\operatorname{tr}(\\boldsymbol{S} \\boldsymbol{F}^{\\mathsf{T}} \\mathrm{d}\\boldsymbol{F})\n$$\nWe have two expressions for $\\mathrm{d}\\Psi$:\n$$\n\\mathrm{d}\\Psi = \\boldsymbol{P} : \\mathrm{d}\\boldsymbol{F} = \\operatorname{tr}(\\boldsymbol{P}^{\\mathsf{T}} \\mathrm{d}\\boldsymbol{F}) \\quad \\text{and} \\quad \\mathrm{d}\\Psi = \\operatorname{tr}(\\boldsymbol{S} \\boldsymbol{F}^{\\mathsf{T}} \\mathrm{d}\\boldsymbol{F})\n$$\nSince this equality must hold for an arbitrary differential $\\mathrm{d}\\boldsymbol{F}$, the pre-multipliers must be equal:\n$$\n\\boldsymbol{P}^{\\mathsf{T}} = \\boldsymbol{S} \\boldsymbol{F}^{\\mathsf{T}}\n$$\nTransposing both sides yields $\\boldsymbol{P} = (\\boldsymbol{S} \\boldsymbol{F}^{\\mathsf{T}})^{\\mathsf{T}} = \\boldsymbol{F} \\boldsymbol{S}^{\\mathsf{T}}$. Since $\\boldsymbol{C} = \\boldsymbol{C}^{\\mathsf{T}}$, its conjugate work variable $\\boldsymbol{S}$ must also be symmetric ($\\boldsymbol{S} = \\boldsymbol{S}^{\\mathsf{T}}$). Thus, we arrive at the desired kinematic identity:\n$$\n\\boldsymbol{P} = \\boldsymbol{F} \\boldsymbol{S}\n$$\n\n**2. Derivation of the Work-Conjugacy Equivalence $\\boldsymbol{P} : \\dot{\\boldsymbol{F}} = \\boldsymbol{S} : \\dot{\\boldsymbol{E}}$**\n\nThe material rate of work done per unit reference volume is given by the power density $\\mathcal{P} = \\boldsymbol{P} : \\dot{\\boldsymbol{F}}$. We can show the equivalence by substituting the identities derived above.\nStarting with the right-hand side, $\\boldsymbol{S} : \\dot{\\boldsymbol{E}}$, and using the given expression for the rate of the Green-Lagrange strain, $\\dot{\\boldsymbol{E}} = \\frac{1}{2}(\\dot{\\boldsymbol{F}}^{\\mathsf{T}} \\boldsymbol{F} + \\boldsymbol{F}^{\\mathsf{T}} \\dot{\\boldsymbol{F}})$:\n$$\n\\boldsymbol{S} : \\dot{\\boldsymbol{E}} = \\boldsymbol{S} : \\left(\\frac{1}{2}(\\dot{\\boldsymbol{F}}^{\\mathsf{T}} \\boldsymbol{F} + \\boldsymbol{F}^{\\mathsf{T}} \\dot{\\boldsymbol{F}})\\right) = \\frac{1}{2} \\left( \\boldsymbol{S} : (\\dot{\\boldsymbol{F}}^{\\mathsf{T}} \\boldsymbol{F}) + \\boldsymbol{S} : (\\boldsymbol{F}^{\\mathsf{T}} \\dot{\\boldsymbol{F}}) \\right)\n$$\nUsing the trace representation $\\boldsymbol{A}:\\boldsymbol{B} = \\operatorname{tr}(\\boldsymbol{A}^{\\mathsf{T}}\\boldsymbol{B})$ and $\\boldsymbol{S} = \\boldsymbol{S}^{\\mathsf{T}}$:\n$$\n\\boldsymbol{S} : \\dot{\\boldsymbol{E}} = \\frac{1}{2} \\left( \\operatorname{tr}(\\boldsymbol{S} \\dot{\\boldsymbol{F}}^{\\mathsf{T}} \\boldsymbol{F}) + \\operatorname{tr}(\\boldsymbol{S} \\boldsymbol{F}^{\\mathsf{T}} \\dot{\\boldsymbol{F}}) \\right)\n$$\nAs established in the previous section, $\\operatorname{tr}(\\boldsymbol{S} \\dot{\\boldsymbol{F}}^{\\mathsf{T}} \\boldsymbol{F}) = \\operatorname{tr}(\\boldsymbol{S} \\boldsymbol{F}^{\\mathsf{T}} \\dot{\\boldsymbol{F}})$. Therefore,\n$$\n\\boldsymbol{S} : \\dot{\\boldsymbol{E}} = \\frac{1}{2} \\left( \\operatorname{tr}(\\boldsymbol{S} \\boldsymbol{F}^{\\mathsf{T}} \\dot{\\boldsymbol{F}}) + \\operatorname{tr}(\\boldsymbol{S} \\boldsymbol{F}^{\\mathsf{T}} \\dot{\\boldsymbol{F}}) \\right) = \\operatorname{tr}(\\boldsymbol{S} \\boldsymbol{F}^{\\mathsf{T}} \\dot{\\boldsymbol{F}})\n$$\nNow, consider the left-hand side, $\\boldsymbol{P} : \\dot{\\boldsymbol{F}}$. Using the trace representation and the identity $\\boldsymbol{P} = \\boldsymbol{F}\\boldsymbol{S}$ (which implies $\\boldsymbol{P}^{\\mathsf{T}} = \\boldsymbol{S}^{\\mathsf{T}} \\boldsymbol{F}^{\\mathsf{T}} = \\boldsymbol{S} \\boldsymbol{F}^{\\mathsf{T}}$):\n$$\n\\boldsymbol{P} : \\dot{\\boldsymbol{F}} = \\operatorname{tr}(\\boldsymbol{P}^{\\mathsf{T}} \\dot{\\boldsymbol{F}}) = \\operatorname{tr}((\\boldsymbol{S} \\boldsymbol{F}^{\\mathsf{T}}) \\dot{\\boldsymbol{F}}) = \\operatorname{tr}(\\boldsymbol{S} \\boldsymbol{F}^{\\mathsf{T}} \\dot{\\boldsymbol{F}})\n$$\nComparing the results for both sides, we find they are identical:\n$$\n\\boldsymbol{P} : \\dot{\\boldsymbol{F}} = \\operatorname{tr}(\\boldsymbol{S} \\boldsymbol{F}^{\\mathsf{T}} \\dot{\\boldsymbol{F}}) = \\boldsymbol{S} : \\dot{\\boldsymbol{E}}\n$$\nThis establishes the work-conjugacy equivalence.\n\n### Numerical Implementation Logic\n\nTo numerically verify these identities, we must compute $\\boldsymbol{P}$ and $\\boldsymbol{S}$ from the provided Helmholtz free energy function:\n$$\n\\Psi(\\boldsymbol{C}) = \\frac{\\mu}{2}\\big(\\operatorname{tr} \\boldsymbol{C} - 3\\big) - \\mu \\ln J + \\frac{\\kappa}{2}\\big(\\ln J\\big)^2\n$$\nwhere $J = \\sqrt{\\det \\boldsymbol{C}}$. This can be rewritten using $\\ln J = \\frac{1}{2}\\ln(\\det \\boldsymbol{C})$:\n$$\n\\Psi(\\boldsymbol{C}) = \\frac{\\mu}{2}\\big(\\operatorname{tr} \\boldsymbol{C} - 3\\big) - \\frac{\\mu}{2} \\ln(\\det \\boldsymbol{C}) + \\frac{\\kappa}{8}\\big(\\ln(\\det \\boldsymbol{C})\\big)^2\n$$\n\n**1. Computing the Second Piola-Kirchhoff Stress $\\boldsymbol{S}$**\n\n$\\boldsymbol{S}$ is computed using its definition $\\boldsymbol{S} = 2 \\frac{\\partial \\Psi}{\\partial \\boldsymbol{C}}$. We need the tensor derivatives of the terms in $\\Psi$:\n- $\\frac{\\partial (\\operatorname{tr} \\boldsymbol{C})}{\\partial \\boldsymbol{C}} = \\boldsymbol{I}$ (the identity tensor)\n- $\\frac{\\partial (\\ln(\\det \\boldsymbol{C}))}{\\partial \\boldsymbol{C}} = (\\det \\boldsymbol{C})^{-1} \\boldsymbol{C}^{-\\mathsf{T}} = \\boldsymbol{C}^{-1}$ (since $\\boldsymbol{C}$ is symmetric)\n\nApplying these rules:\n$$\n\\frac{\\partial \\Psi}{\\partial \\boldsymbol{C}} = \\frac{\\mu}{2}\\boldsymbol{I} - \\frac{\\mu}{2} \\boldsymbol{C}^{-1} + \\frac{\\kappa}{8} \\left( 2 \\ln(\\det \\boldsymbol{C}) \\cdot \\boldsymbol{C}^{-1} \\right) = \\frac{\\mu}{2}\\boldsymbol{I} + \\left( \\frac{\\kappa}{4}\\ln(\\det \\boldsymbol{C}) - \\frac{\\mu}{2} \\right) \\boldsymbol{C}^{-1}\n$$\nTherefore, $\\boldsymbol{S} = 2 \\frac{\\partial \\Psi}{\\partial \\boldsymbol{C}}$ is:\n$$\n\\boldsymbol{S} = \\mu \\boldsymbol{I} + \\left( \\frac{\\kappa}{2}\\ln(\\det \\boldsymbol{C}) - \\mu \\right) \\boldsymbol{C}^{-1}\n$$\nSince $J = \\sqrt{\\det \\boldsymbol{C}}$, $\\ln(\\det \\boldsymbol{C}) = 2 \\ln J$. Substituting this gives the final expression for implementation:\n$$\n\\boldsymbol{S} = \\mu \\boldsymbol{I} + (\\kappa \\ln J - \\mu) \\boldsymbol{C}^{-1}\n$$\n\n**2. Computing the First Piola-Kirchhoff Stress $\\boldsymbol{P}$**\n\n$\\boldsymbol{P}$ is computed using its definition $\\boldsymbol{P} = \\frac{\\partial \\Psi}{\\partial \\boldsymbol{F}}$. We express $\\Psi$ in terms of $\\boldsymbol{F}$:\n$$\n\\Psi(\\boldsymbol{F}) = \\frac{\\mu}{2}\\big(\\operatorname{tr}(\\boldsymbol{F}^{\\mathsf{T}}\\boldsymbol{F}) - 3\\big) - \\mu \\ln(\\det \\boldsymbol{F}) + \\frac{\\kappa}{2}\\big(\\ln(\\det \\boldsymbol{F})\\big)^2\n$$\nWe need the tensor derivatives of the terms in $\\Psi$ with respect to $\\boldsymbol{F}$:\n- $\\frac{\\partial (\\operatorname{tr}(\\boldsymbol{F}^{\\mathsf{T}}\\boldsymbol{F}))}{\\partial \\boldsymbol{F}} = 2\\boldsymbol{F}$\n- $\\frac{\\partial (\\ln(\\det \\boldsymbol{F}))}{\\partial \\boldsymbol{F}} = \\boldsymbol{F}^{-\\mathsf{T}}$\n\nApplying these rules, let $J = \\det \\boldsymbol{F}$:\n$$\n\\boldsymbol{P} = \\frac{\\partial \\Psi}{\\partial \\boldsymbol{F}} = \\frac{\\mu}{2}(2\\boldsymbol{F}) - \\mu \\boldsymbol{F}^{-\\mathsf{T}} + \\frac{\\kappa}{2} \\left( 2 \\ln J \\cdot \\boldsymbol{F}^{-\\mathsf{T}} \\right)\n$$\nThis simplifies to the final expression for implementation:\n$$\n\\boldsymbol{P} = \\mu \\boldsymbol{F} + (\\kappa \\ln J - \\mu) \\boldsymbol{F}^{-\\mathsf{T}}\n$$\nAs a consistency check, we can verify that $\\boldsymbol{P} = \\boldsymbol{F}\\boldsymbol{S}$ holds algebraically with these expressions: $\\boldsymbol{F} \\boldsymbol{S} = \\boldsymbol{F}(\\mu \\boldsymbol{I} + (\\kappa \\ln J - \\mu) \\boldsymbol{C}^{-1}) = \\mu \\boldsymbol{F} + (\\kappa \\ln J - \\mu) \\boldsymbol{F} \\boldsymbol{C}^{-1}$. Since $\\boldsymbol{C}^{-1} = (\\boldsymbol{F}^{\\mathsf{T}}\\boldsymbol{F})^{-1} = \\boldsymbol{F}^{-1}\\boldsymbol{F}^{-\\mathsf{T}}$, we have $\\boldsymbol{F} \\boldsymbol{C}^{-1} = \\boldsymbol{F}(\\boldsymbol{F}^{-1}\\boldsymbol{F}^{-\\mathsf{T}}) = \\boldsymbol{F}^{-\\mathsf{T}}$. This confirms $\\boldsymbol{F} \\boldsymbol{S} = \\mu \\boldsymbol{F} + (\\kappa \\ln J - \\mu) \\boldsymbol{F}^{-\\mathsf{T}} = \\boldsymbol{P}$.\n\nThe numerical program will compute $\\boldsymbol{S}$ and $\\boldsymbol{P}$ using these derived formulae and then verify the identities $\\boldsymbol{P}=\\boldsymbol{F}\\boldsymbol{S}$ and $\\boldsymbol{P}:\\dot{\\boldsymbol{F}} = \\boldsymbol{S}:\\dot{\\boldsymbol{E}}$ for each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational solid mechanics problem by performing theoretical\n    derivations and numerical verifications for a compressible neo-Hookean material.\n    \"\"\"\n\n    # Define the tolerance for numerical checks.\n    tolerance = 1e-10\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (mu, kappa, F_matrix, F_dot_matrix)\n    test_cases = [\n        (80.0, 240.0,\n         np.array([[1.30, 0.40, 0.00],\n                   [0.20, 0.90, 0.10],\n                   [0.00, 0.05, 1.20]]),\n         np.array([[0.05, -0.02, 0.00],\n                   [0.03,  0.01, -0.04],\n                   [0.00,  0.02, -0.01]])),\n        (50.0, 500.0,\n         np.array([[1.05, 0.00, 0.00],\n                   [0.00, 1.05, 0.00],\n                   [0.00, 0.00, 1.05]]),\n         np.array([[0.01, 0.00, 0.00],\n                   [0.00, 0.01, 0.00],\n                   [0.00, 0.00, 0.01]])),\n        (30.0, 90.0,\n         np.array([[1.20, 0.50, 0.00],\n                   [0.00, 0.8333333333333334, 0.00],\n                   [0.00, 0.00, 1.00]]),\n         np.array([[0.00,  0.03, 0.00],\n                   [0.00, -0.02, 0.00],\n                   [0.00,  0.00, 0.00]])),\n        (60.0, 6000.0,\n         np.array([[0.80, 0.00, 0.00],\n                   [0.00, 1.25, 0.00],\n                   [0.00, 0.00, 1.02]]),\n         np.array([[-0.01,  0.00,  0.00],\n                   [ 0.00,  0.015, 0.00],\n                   [ 0.00,  0.00, -0.002]])),\n        (70.0, 210.0,\n         np.array([[0.50, 0.00, 0.00],\n                   [0.00, 0.90, 0.00],\n                   [0.00, 0.00, 2.80]]),\n         np.array([[0.02,  0.00, 0.00],\n                   [-0.00, -0.01, 0.00],\n                   [0.00,  0.00, 0.03]]))\n    ]\n\n    results = []\n    \n    # Process each test case\n    for mu, kappa, F, F_dot in test_cases:\n        # Basic kinematic quantities\n        J = np.linalg.det(F)\n        C = F.T @ F\n        I = np.eye(3)\n\n        # 1. Compute S from Psi(C)\n        # S = mu*I + (kappa*ln(J) - mu)*C_inv\n        # where ln(det(C)) = 2*ln(J)\n        C_inv = np.linalg.inv(C)\n        S = mu * I + (kappa * np.log(J) - mu) * C_inv\n        \n        # 2. Compute P from Psi(F)\n        # P = mu*F + (kappa*ln(J) - mu)*F_inv_T\n        F_inv_T = np.linalg.inv(F).T\n        P_from_psi = mu * F + (kappa * np.log(J) - mu) * F_inv_T\n        \n        # 3. Form P from S using P = F*S\n        P_from_S = F @ S\n        \n        # 4. Perform the first verification: check if P from Psi(F) equals F*S\n        error_1 = np.linalg.norm(P_from_psi - P_from_S, 'fro')\n        check_1 = error_1 = tolerance\n\n        # 5. Compute E_dot\n        E_dot = 0.5 * (F_dot.T @ F + F.T @ F_dot)\n        \n        # 6. Compute work rates P:F_dot and S:E_dot\n        # Double contraction A:B is tr(A.T @ B), which is equivalent to np.sum(A * B)\n        work_rate_P = np.sum(P_from_psi * F_dot)\n        work_rate_S = np.sum(S * E_dot)\n\n        # 7. Perform the second verification: check if work rates are equal\n        error_2 = np.abs(work_rate_P - work_rate_S)\n        check_2 = error_2 = tolerance\n\n        results.append([check_1, check_2])\n\n    # Format the final output as a single-line string\n    # e.g., [[True,True],[True,True],...]\n    output_str = \"[\" + \",\".join(map(str, results)) + \"]\"\n    \n    # Final print statement in the exact required format.\n    print(output_str)\n\nsolve()\n```", "id": "3606700"}, {"introduction": "Moving from the material to the spatial frame, it is crucial to correctly identify the conjugate pair that defines the internal power. In the presence of motion involving rigid body rotation, the choice of the kinematic rate variable is not arbitrary. This practice is designed to provide a clear, practical demonstration of why the symmetric rate-of-deformation tensor $\\boldsymbol{D}$ is the correct work conjugate to the symmetric Cauchy stress $\\boldsymbol{\\tau}$, and the full velocity gradient $\\boldsymbol{L}$ is not. Through a numerical experiment [@problem_id:3606689], you will quantify the error that arises from an incorrect pairing, thereby appreciating the deep connection between work conjugacy and the principle of material frame-indifference.", "problem": "Consider a two-dimensional plane-strain continuum undergoing simple shear with a superposed rigid-body rotation. Let the spatial coordinates be $(x,y)$ in meters, and consider the velocity field $\\boldsymbol{v}(x,y)$ defined by the superposition of a simple shear of rate $\\dot{\\gamma}$ in the $x$-direction and a rigid-body rotation about the out-of-plane axis at angular speed $\\omega$ (radians per second). The velocity field is\n$$\n\\boldsymbol{v}(x,y) = \\begin{bmatrix} \\dot{\\gamma}\\,y \\\\ 0 \\end{bmatrix} + \\begin{bmatrix} -\\omega\\,y \\\\ \\omega\\,x \\end{bmatrix}.\n$$\nThe velocity gradient $\\boldsymbol{L}$, the rate-of-deformation (symmetric) tensor $\\boldsymbol{D}$, and the spin (skew-symmetric) tensor $\\boldsymbol{W}$ are defined by\n$$\n\\boldsymbol{L} = \\nabla \\boldsymbol{v}, \\quad \\boldsymbol{D} = \\tfrac{1}{2}\\left(\\boldsymbol{L} + \\boldsymbol{L}^{\\mathsf{T}}\\right), \\quad \\boldsymbol{W} = \\tfrac{1}{2}\\left(\\boldsymbol{L} - \\boldsymbol{L}^{\\mathsf{T}}\\right).\n$$\nAssume a linear viscous solid-like response (Newtonian effective behavior) with dynamic viscosity $\\mu$ (Pascal seconds), where the Cauchy stress $\\boldsymbol{\\tau}$ is given by\n$$\n\\boldsymbol{\\tau} = 2\\,\\mu\\,\\boldsymbol{D}.\n$$\nTo diagnose violations of work conjugacy, introduce a spurious non-objective contamination in the computed stress of the form\n$$\n\\boldsymbol{\\tau}_{\\text{bad}} = \\boldsymbol{\\tau} + s\\,\\boldsymbol{W},\n$$\nwhere $s = \\beta\\,\\mu$, and $\\beta$ is a dimensionless parameter. The internal mechanical power per unit volume is defined by the double contraction (Frobenius inner product) of stress with the appropriate kinematic rate. Using the above definitions, compute, for each test case:\n- The baseline internal power using the correct conjugate pair,\n$$\np_{\\text{correct}} = \\boldsymbol{\\tau} : \\boldsymbol{D},\n$$\nexpressed in watts per cubic meter ($\\mathrm{W/m^3}$).\n- The internal power obtained by an incorrect usage that contracts the contaminated stress with the full velocity gradient,\n$$\np_{\\text{wrong}} = \\boldsymbol{\\tau}_{\\text{bad}} : \\boldsymbol{L},\n$$\nexpressed in watts per cubic meter ($\\mathrm{W/m^3}$).\n- The absolute deviation\n$$\n\\Delta p = \\left|p_{\\text{wrong}} - p_{\\text{correct}}\\right|,\n$$\nexpressed in watts per cubic meter ($\\mathrm{W/m^3}$).\n\nYour task is to write a complete, runnable program that, for the following test suite, computes $\\boldsymbol{L}$, $\\boldsymbol{D}$, $\\boldsymbol{W}$ from $\\boldsymbol{v}(x,y)$ (analytically, since the field is linear), forms $\\boldsymbol{\\tau}$ and $\\boldsymbol{\\tau}_{\\text{bad}}$ with the given parameters, evaluates $p_{\\text{correct}}$, $p_{\\text{wrong}}$, and outputs $\\Delta p$ for each case. Use the specified physical units: $\\dot{\\gamma}$ in per second ($\\mathrm{s^{-1}}$), $\\omega$ in radians per second ($\\mathrm{rad/s}$), $\\mu$ in Pascal seconds ($\\mathrm{Pa\\cdot s}$), and $\\Delta p$ in watts per cubic meter ($\\mathrm{W/m^3}$). Angles are specified in radians.\n\nTest suite (each tuple is $(\\dot{\\gamma},\\ \\omega,\\ \\mu,\\ \\beta)$):\n- Case $1$: $(10,\\ 0,\\ 100,\\ 0.2)$\n- Case $2$: $(10,\\ 5,\\ 100,\\ 0.2)$\n- Case $3$: $(0,\\ 7,\\ 100,\\ 0.2)$\n- Case $4$: $(2,\\ 50,\\ 100,\\ 0.2)$\n\nScientific realism: In a continuum without couple stresses, the Cauchy stress $\\boldsymbol{\\tau}$ must remain symmetric; any anti-symmetric component implied by numerical contamination models a violation of angular momentum balance and will manifest as a deviation when contracting with $\\boldsymbol{L}$ rather than with $\\boldsymbol{D}$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the above test suite, where each entry is the absolute deviation $\\Delta p$ for that case in $\\mathrm{W/m^3}$, for example,\n$$\n[\\Delta p_1,\\Delta p_2,\\Delta p_3,\\Delta p_4].\n$$\nNo other text should be printed.", "solution": "The user-provided problem is evaluated as valid.\n\n### Step 1: Extract Givens\n- **Velocity field**: $\\boldsymbol{v}(x,y) = \\begin{bmatrix} \\dot{\\gamma}\\,y \\\\ 0 \\end{bmatrix} + \\begin{bmatrix} -\\omega\\,y \\\\ \\omega\\,x \\end{bmatrix}$\n- **Velocity gradient**: $\\boldsymbol{L} = \\nabla \\boldsymbol{v}$\n- **Rate-of-deformation tensor**: $\\boldsymbol{D} = \\tfrac{1}{2}\\left(\\boldsymbol{L} + \\boldsymbol{L}^{\\mathsf{T}}\\right)$\n- **Spin tensor**: $\\boldsymbol{W} = \\tfrac{1}{2}\\left(\\boldsymbol{L} - \\boldsymbol{L}^{\\mathsf{T}}\\right)$\n- **Constitutive relation (Cauchy stress)**: $\\boldsymbol{\\tau} = 2\\,\\mu\\,\\boldsymbol{D}$\n- **Contaminated stress**: $\\boldsymbol{\\tau}_{\\text{bad}} = \\boldsymbol{\\tau} + s\\,\\boldsymbol{W}$, where $s = \\beta\\,\\mu$\n- **Correct internal power**: $p_{\\text{correct}} = \\boldsymbol{\\tau} : \\boldsymbol{D}$\n- **Incorrect internal power**: $p_{\\text{wrong}} = \\boldsymbol{\\tau}_{\\text{bad}} : \\boldsymbol{L}$\n- **Absolute deviation**: $\\Delta p = \\left|p_{\\text{wrong}} - p_{\\text{correct}}\\right|$\n- **Parameters**: Shear rate $\\dot{\\gamma}$ ($\\mathrm{s^{-1}}$), angular speed $\\omega$ ($\\mathrm{rad/s}$), dynamic viscosity $\\mu$ ($\\mathrm{Pa\\cdot s}$), dimensionless parameter $\\beta$.\n- **Test Suite**:\n  - Case $1$: $(\\dot{\\gamma},\\ \\omega,\\ \\mu,\\ \\beta) = (10,\\ 0,\\ 100,\\ 0.2)$\n  - Case $2$: $(\\dot{\\gamma},\\ \\omega,\\ \\mu,\\ \\beta) = (10,\\ 5,\\ 100,\\ 0.2)$\n  - Case $3$: $(\\dot{\\gamma},\\ \\omega,\\ \\mu,\\ \\beta) = (0,\\ 7,\\ 100,\\ 0.2)$\n  - Case $4$: $(\\dot{\\gamma},\\ \\omega,\\ \\mu,\\ \\beta) = (2,\\ 50,\\ 100,\\ 0.2)$\n\n### Step 2: Validate Using Extracted Givens\nThe problem is **valid**.\n- **Scientifically Grounded**: The problem is set within the standard framework of continuum mechanics. The definitions of $\\boldsymbol{L}$, $\\boldsymbol{D}$, $\\boldsymbol{W}$, and the constitutive law for a linear viscous fluid are fundamental concepts. The introduction of $\\boldsymbol{\\tau}_{\\text{bad}}$ is a pedagogical tool to demonstrate the consequences of violating the principle of material frame-indifference (objectivity) and work conjugacy, which is a legitimate and common practice in mechanics education. The \"Scientific realism\" note in the problem statement correctly identifies the physical meaning of such a contamination.\n- **Well-Posed**: The problem is deterministic. For each set of input parameters, the quantities to be computed are uniquely defined through a sequence of explicit algebraic operations. A unique solution exists for each test case.\n- **Objective**: The problem is stated using precise, standard terminology from continuum mechanics, free from subjectivity or ambiguity.\n- **Self-contained and Consistent**: All necessary equations, definitions, and data are provided. The units are consistent: the power density calculation results in $\\mathrm{(Pa\\cdot s) \\cdot (s^{-1}) \\cdot (s^{-1}) = Pa \\cdot s^{-1} = (N/m^2) \\cdot s^{-1} = (J/m^3) \\cdot s^{-1} = W/m^3}$, which matches the required output unit.\n\n### Step 3: Verdict and Action\nThe problem is valid and a solution will be provided.\n\nThe objective is to calculate the absolute deviation $\\Delta p$ between a correctly computed internal power density and an incorrectly computed one. The deviation arises from a non-objective contamination of the stress tensor. The analytical derivation proceeds as follows.\n\nFirst, we determine the velocity gradient tensor $\\boldsymbol{L}$. The velocity field is given by $\\boldsymbol{v}(x,y) = [v_x, v_y]^{\\mathsf{T}} = [(\\dot{\\gamma}-\\omega)y, \\omega x]^{\\mathsf{T}}$. The velocity gradient $\\boldsymbol{L}$, whose components are $L_{ij} = \\partial v_i / \\partial x_j$, is:\n$$\nL_{11} = \\frac{\\partial v_x}{\\partial x} = 0, \\quad L_{12} = \\frac{\\partial v_x}{\\partial y} = \\dot{\\gamma} - \\omega\n$$\n$$\nL_{21} = \\frac{\\partial v_y}{\\partial x} = \\omega, \\quad L_{22} = \\frac{\\partial v_y}{\\partial y} = 0\n$$\nThus, the velocity gradient tensor is constant throughout the domain:\n$$\n\\boldsymbol{L} = \\begin{bmatrix} 0  \\dot{\\gamma} - \\omega \\\\ \\omega  0 \\end{bmatrix}\n$$\nNext, we decompose $\\boldsymbol{L}$ into its symmetric part, the rate-of-deformation tensor $\\boldsymbol{D}$, and its skew-symmetric part, the spin tensor $\\boldsymbol{W}$.\n$$\n\\boldsymbol{D} = \\frac{1}{2}(\\boldsymbol{L} + \\boldsymbol{L}^{\\mathsf{T}}) = \\frac{1}{2}\\left( \\begin{bmatrix} 0  \\dot{\\gamma} - \\omega \\\\ \\omega  0 \\end{bmatrix} + \\begin{bmatrix} 0  \\omega \\\\ \\dot{\\gamma} - \\omega  0 \\end{bmatrix} \\right) = \\frac{1}{2} \\begin{bmatrix} 0  \\dot{\\gamma} \\\\ \\dot{\\gamma}  0 \\end{bmatrix}\n$$\n$$\n\\boldsymbol{W} = \\frac{1}{2}(\\boldsymbol{L} - \\boldsymbol{L}^{\\mathsf{T}}) = \\frac{1}{2}\\left( \\begin{bmatrix} 0  \\dot{\\gamma} - \\omega \\\\ \\omega  0 \\end{bmatrix} - \\begin{bmatrix} 0  \\omega \\\\ \\dot{\\gamma} - \\omega  0 \\end{bmatrix} \\right) = \\frac{1}{2} \\begin{bmatrix} 0  \\dot{\\gamma} - 2\\omega \\\\ -(\\dot{\\gamma} - 2\\omega)  0 \\end{bmatrix}\n$$\nThe Cauchy stress $\\boldsymbol{\\tau}$ for the linear viscous material is given by $\\boldsymbol{\\tau} = 2\\mu\\boldsymbol{D}$:\n$$\n\\boldsymbol{\\tau} = 2\\mu \\left( \\frac{1}{2} \\begin{bmatrix} 0  \\dot{\\gamma} \\\\ \\dot{\\gamma}  0 \\end{bmatrix} \\right) = \\mu \\begin{bmatrix} 0  \\dot{\\gamma} \\\\ \\dot{\\gamma}  0 \\end{bmatrix}\n$$\nThe correct internal power is the double contraction of the Cauchy stress and the rate-of-deformation tensor, $p_{\\text{correct}} = \\boldsymbol{\\tau} : \\boldsymbol{D}$. This pairing is required by thermodynamics and ensures objectivity, as both $\\boldsymbol{\\tau}$ and $\\boldsymbol{D}$ are objective tensors for this material model.\n$$\np_{\\text{correct}} = \\left( \\mu \\begin{bmatrix} 0  \\dot{\\gamma} \\\\ \\dot{\\gamma}  0 \\end{bmatrix} \\right) : \\left( \\frac{1}{2} \\begin{bmatrix} 0  \\dot{\\gamma} \\\\ \\dot{\\gamma}  0 \\end{bmatrix} \\right) = \\mu \\left( \\frac{\\dot{\\gamma}^2}{2} + \\frac{\\dot{\\gamma}^2}{2} \\right) = \\mu \\dot{\\gamma}^2\n$$\nThe incorrect power calculation uses a contaminated stress $\\boldsymbol{\\tau}_{\\text{bad}} = \\boldsymbol{\\tau} + s\\boldsymbol{W}$ (with $s = \\beta\\mu$) contracted with the full velocity gradient $\\boldsymbol{L}$.\n$$\np_{\\text{wrong}} = \\boldsymbol{\\tau}_{\\text{bad}} : \\boldsymbol{L} = (\\boldsymbol{\\tau} + s\\boldsymbol{W}) : (\\boldsymbol{D} + \\boldsymbol{W})\n$$\nExpanding the double dot product:\n$$\np_{\\text{wrong}} = \\boldsymbol{\\tau}:\\boldsymbol{D} + \\boldsymbol{\\tau}:\\boldsymbol{W} + s\\boldsymbol{W}:\\boldsymbol{D} + s\\boldsymbol{W}:\\boldsymbol{W}\n$$\nHere, we use the property that the double contraction of a symmetric tensor (like $\\boldsymbol{\\tau}$ and $\\boldsymbol{D}$) with a skew-symmetric tensor (like $\\boldsymbol{W}$) is always zero. Therefore, $\\boldsymbol{\\tau}:\\boldsymbol{W} = 0$ and $\\boldsymbol{W}:\\boldsymbol{D} = 0$. The expression for $p_{\\text{wrong}}$ simplifies to:\n$$\np_{\\text{wrong}} = \\boldsymbol{\\tau}:\\boldsymbol{D} + s\\boldsymbol{W}:\\boldsymbol{W} = p_{\\text{correct}} + s\\boldsymbol{W}:\\boldsymbol{W}\n$$\nThe deviation in power calculation is therefore $\\Delta p = |p_{\\text{wrong}} - p_{\\text{correct}}| = |s\\boldsymbol{W}:\\boldsymbol{W}|$. This reveals that the error is precisely the work-rate of the non-physical, non-objective part of the stress ($s\\boldsymbol{W}$) on the non-objective part of the kinematics ($\\boldsymbol{W}$).\nLet's compute $\\boldsymbol{W}:\\boldsymbol{W}$:\n$$\n\\boldsymbol{W}:\\boldsymbol{W} = \\left( \\frac{1}{2} \\right)^2 \\left( 0^2 + (\\dot{\\gamma} - 2\\omega)^2 + (-(\\dot{\\gamma} - 2\\omega))^2 + 0^2 \\right) = \\frac{1}{4} \\left( 2 (\\dot{\\gamma} - 2\\omega)^2 \\right) = \\frac{1}{2}(\\dot{\\gamma} - 2\\omega)^2\n$$\nSubstituting this into the expression for the deviation, and noting that $s=\\beta\\mu$ and the other terms are non-negative, we obtain the final analytical formula for the absolute deviation:\n$$\n\\Delta p = |s\\boldsymbol{W}:\\boldsymbol{W}| = \\beta\\mu \\left( \\frac{1}{2}(\\dot{\\gamma} - 2\\omega)^2 \\right) = \\frac{\\beta\\mu}{2}(\\dot{\\gamma} - 2\\omega)^2\n$$\nThis formula is implemented for each test case. The implementation, as requested by the prompt, will perform the full matrix calculations to demonstrate the process explicitly.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the absolute deviation in power density for several test cases\n    of a 2D continuum undergoing simple shear and rigid rotation.\n    \"\"\"\n    # Test suite (each tuple is (gamma_dot, omega, mu, beta))\n    test_cases = [\n        (10.0, 0.0, 100.0, 0.2),  # Case 1\n        (10.0, 5.0, 100.0, 0.2),  # Case 2\n        (0.0, 7.0, 100.0, 0.2),   # Case 3\n        (2.0, 50.0, 100.0, 0.2),  # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        gamma_dot, omega, mu, beta = case\n\n        # Analytically compute the velocity gradient tensor L, which is constant.\n        # L_ij = dv_i / dx_j\n        # v_x = gamma_dot*y - omega*y = (gamma_dot - omega)*y\n        # v_y = omega*x\n        # L = [[0, gamma_dot - omega], [omega, 0]]\n        L = np.array([\n            [0.0, gamma_dot - omega],\n            [omega, 0.0]\n        ])\n\n        # Decompose L into symmetric (D) and skew-symmetric (W) parts.\n        D = 0.5 * (L + L.T)  # Rate-of-deformation tensor\n        W = 0.5 * (L - L.T)  # Spin tensor\n\n        # Compute the Cauchy stress tensor tau for a linear viscous solid.\n        # tau = 2 * mu * D\n        tau = 2.0 * mu * D\n        \n        # Compute the spurious non-objective contamination factor s.\n        s = beta * mu\n\n        # Compute the contaminated stress tensor tau_bad.\n        # tau_bad = tau + s * W\n        tau_bad = tau + s * W\n\n        # The double dot product A:B is implemented as the sum of the\n        # element-wise product of the matrices, np.sum(A * B).\n\n        # Compute the correct internal power density.\n        # p_correct = tau : D\n        p_correct = np.sum(tau * D)\n\n        # Compute the incorrect internal power density.\n        # p_wrong = tau_bad : L\n        p_wrong = np.sum(tau_bad * L)\n\n        # Compute the absolute deviation.\n        delta_p = abs(p_wrong - p_correct)\n        \n        results.append(delta_p)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3606689"}, {"introduction": "The principles of thermodynamic consistency are not just pillars of classical mechanics; they provide an essential blueprint for modern, data-driven approaches to material modeling. While machine learning models can be powerful approximators, they do not inherently respect physical laws like the conservation of energy or the second law of thermodynamics. This advanced practice [@problem_id:3606695] guides you through the process of building a \"physics-informed\" constitutive model that is thermodynamically consistent by construction, by deriving stress and entropy from a learnable scalar potential. By comparing this to a direct, unconstrained model, you will see how the classical concept of conjugate pairs is a key strategy for embedding physical realism into the next generation of computational tools.", "problem": "Consider small-strain, plane-strain thermoelasticity in which the Green-Lagrange strain tensor is approximated by the symmetric tensor $\\boldsymbol{E} \\in \\mathbb{R}^{2 \\times 2}$, and temperature appears through the deviation $\\tau = \\theta - \\theta_{0}$. A hyperelastic, thermoelastic material is characterized by a Helmholtz free energy density $\\psi(\\boldsymbol{E},\\theta)$ such that the thermodynamic conjugate pairs satisfy $\\boldsymbol{S} = \\partial \\psi / \\partial \\boldsymbol{E}$ and $\\eta = - \\partial \\psi / \\partial \\theta$, where $\\boldsymbol{S}$ is the Second Piola-Kirchhoff stress and $\\eta$ is the entropy density. The Maxwell relation enforcing thermodynamic consistency follows from Schwarz’s theorem on equality of mixed partial derivatives and reads $\\partial \\boldsymbol{S}/\\partial \\theta + \\partial \\eta/\\partial \\boldsymbol{E} = \\boldsymbol{0}$. In a machine-learning setting, a constitutive model is thermodynamically consistent by construction if its predicted stresses and entropies are obtained as the appropriate conjugate gradients of a scalar potential.\n\nYour task is to implement a program that learns two models from synthetic data generated by a known but hidden-from-the-learner free energy density and then evaluates thermodynamic consistency and predictive accuracy:\n\n- Model A (potential-based): A scalar free energy ansatz $\\psi_{w}(\\boldsymbol{E},\\theta)$ parameterized linearly in a set of scalar basis functions. Predictions $\\boldsymbol{S}_{w}$ and $\\eta_{w}$ are obtained as $\\boldsymbol{S}_{w}=\\partial \\psi_{w}/\\partial \\boldsymbol{E}$ and $\\eta_{w}=-\\partial \\psi_{w}/\\partial \\theta$. This model is thermodynamically consistent by construction.\n\n- Model B (direct map): Independent linear maps predict the components of $\\boldsymbol{S}$ and $\\eta$ directly from a feature vector built from $(\\boldsymbol{E},\\theta)$, without ensuring they derive from a single potential. This model can violate thermodynamic consistency, which will be measured and also penalized by a regularization term in training.\n\nAll quantities in this problem are nondimensionalized by characteristic scales, so no physical units appear. The final requested outputs are dimensionless floats.\n\nFundamental base and data generation. Use the following well-tested constitutive facts to ground your design: hyperelasticity requires $\\boldsymbol{S} = \\partial \\psi/\\partial \\boldsymbol{E}$, $\\eta = -\\partial \\psi/\\partial \\theta$, and Maxwell symmetry implies $\\partial \\boldsymbol{S}/\\partial \\theta + \\partial \\eta/\\partial \\boldsymbol{E} = \\boldsymbol{0}$. Synthesize training and validation data from a strongly convex quadratic free energy density of the form\n$$\n\\psi_{\\mathrm{gt}}(\\boldsymbol{E},\\theta) = \\tfrac{1}{2}\\lambda\\left(\\mathrm{tr}\\,\\boldsymbol{E}\\right)^{2} + \\mu\\,\\mathrm{tr}\\!\\left(\\boldsymbol{E}^{2}\\right) + \\tfrac{1}{2}c\\,\\tau^{2} + \\alpha\\,\\tau\\,\\mathrm{tr}\\,\\boldsymbol{E},\n$$\nwith parameters $\\lambda = 2.0$, $\\mu = 3.0$, $c = 0.5$, $\\alpha = 0.2$, and $\\tau = \\theta - \\theta_{0}$. For plane strain, $\\boldsymbol{E}$ is symmetric with independent components $E_{11}$, $E_{22}$, $E_{12}=E_{21}$. Randomly sample training and validation sets of states $(\\boldsymbol{E},\\tau)$ by drawing $E_{11}$, $E_{22}$, $E_{12}$ independently and uniformly from $[-e_{\\max},e_{\\max}]$ and $\\tau$ uniformly from $[-t_{\\max},t_{\\max}]$, with $e_{\\max} = 0.02$ and $t_{\\max} = 0.1$. For each sampled state, compute $\\boldsymbol{S}_{\\mathrm{gt}}$ and $\\eta_{\\mathrm{gt}}$ from $\\psi_{\\mathrm{gt}}$ via the conjugate definitions.\n\nModel A design. Use the scalar potential ansatz\n$$\n\\psi_{w}(\\boldsymbol{E},\\theta) = \\tfrac{1}{2}w_{1}\\left(\\mathrm{tr}\\,\\boldsymbol{E}\\right)^{2} + w_{2}\\,\\mathrm{tr}\\!\\left(\\boldsymbol{E}^{2}\\right) + \\tfrac{1}{2}w_{3}\\,\\tau^{2} + w_{4}\\,\\tau\\,\\mathrm{tr}\\,\\boldsymbol{E}.\n$$\nBy fundamental definitions, $\\boldsymbol{S}_{w} = \\partial \\psi_{w}/\\partial \\boldsymbol{E}$ and $\\eta_{w} = -\\partial \\psi_{w}/\\partial \\theta$. Determine the linear relationships that map $w = (w_{1},w_{2},w_{3},w_{4})$ to the predicted components of $\\boldsymbol{S}_{w}$ and $\\eta_{w}$ at any state $(\\boldsymbol{E},\\tau)$, and fit $w$ by least squares to $(\\boldsymbol{S}_{\\mathrm{gt}},\\eta_{\\mathrm{gt}})$ computed from the training set.\n\nModel B design. Define the feature vector\n$$\ng(\\boldsymbol{E},\\tau) = \\begin{bmatrix} \\mathrm{tr}\\,\\boldsymbol{E} \\\\ E_{11} \\\\ E_{22} \\\\ E_{12} \\\\ \\tau \\\\ 1 \\end{bmatrix}\\!,\n$$\nand predict\n$$\nS_{11} = a_{11}^{\\top} g,\\quad S_{22} = a_{22}^{\\top} g,\\quad S_{12} = a_{12}^{\\top} g,\\quad \\eta = b^{\\top} g,\n$$\nwith independent coefficient vectors $a_{11},a_{22},a_{12},b \\in \\mathbb{R}^{6}$. Train this model by minimizing a regularized empirical risk that adds a thermodynamic-violation penalty weighted by a nonnegative scalar $\\gamma$. Using $\\partial g/\\partial E_{11} = [1,1,0,0,0,0]^{\\top}$, $\\partial g/\\partial E_{22} = [1,0,1,0,0,0]^{\\top}$, $\\partial g/\\partial E_{12} = [0,0,0,1,0,0]^{\\top}$, and $\\partial g/\\partial \\theta = [0,0,0,0,1,0]^{\\top}$, define the linearized residuals that must vanish for exact thermodynamic consistency:\n- Mechanical cross-partial symmetry residuals:\n$$\nR_{11,22} = a_{11}^{\\top}\\tfrac{\\partial g}{\\partial E_{22}} - a_{22}^{\\top}\\tfrac{\\partial g}{\\partial E_{11}},\\quad\nR_{11,12} = a_{11}^{\\top}\\tfrac{\\partial g}{\\partial E_{12}} - a_{12}^{\\top}\\tfrac{\\partial g}{\\partial E_{11}},\\quad\nR_{22,12} = a_{22}^{\\top}\\tfrac{\\partial g}{\\partial E_{12}} - a_{12}^{\\top}\\tfrac{\\partial g}{\\partial E_{22}}.\n$$\n- Thermal Maxwell residuals:\n$$\nM_{11} = a_{11}^{\\top}\\tfrac{\\partial g}{\\partial \\theta} + b^{\\top}\\tfrac{\\partial g}{\\partial E_{11}},\\quad\nM_{22} = a_{22}^{\\top}\\tfrac{\\partial g}{\\partial \\theta} + b^{\\top}\\tfrac{\\partial g}{\\partial E_{22}},\\quad\nM_{12} = a_{12}^{\\top}\\tfrac{\\partial g}{\\partial \\theta} + b^{\\top}\\tfrac{\\partial g}{\\partial E_{12}}.\n$$\nDefine the scalar violation metric\n$$\nV = \\sqrt{R_{11,22}^{2} + R_{11,12}^{2} + R_{22,12}^{2} + M_{11}^{2} + M_{22}^{2} + M_{12}^{2}}.\n$$\nTrain Model B by minimizing the objective\n$$\n\\mathcal{L}_{\\gamma} = \\frac{1}{N}\\sum_{n=1}^{N}\\left(\\|\\boldsymbol{S}_{\\mathrm{pred}}^{(n)} - \\boldsymbol{S}_{\\mathrm{gt}}^{(n)}\\|_{F}^{2} + \\left(\\eta_{\\mathrm{pred}}^{(n)} - \\eta_{\\mathrm{gt}}^{(n)}\\right)^{2}\\right) + \\gamma V^{2},\n$$\nwhere $N$ is the number of training samples and $\\|\\cdot\\|_{F}$ denotes the Frobenius norm.\n\nEvaluation metrics. On a separate validation set, compute for each model the relative root-mean-square error\n$$\n\\mathrm{RelRMSE} = \\sqrt{\\frac{\\sum_{m}\\left(\\|\\boldsymbol{S}_{\\mathrm{pred}}^{(m)} - \\boldsymbol{S}_{\\mathrm{gt}}^{(m)}\\|_{F}^{2} + \\left(\\eta_{\\mathrm{pred}}^{(m)} - \\eta_{\\mathrm{gt}}^{(m)}\\right)^{2}\\right)}{\\sum_{m}\\left(\\|\\boldsymbol{S}_{\\mathrm{gt}}^{(m)}\\|_{F}^{2} + \\left(\\eta_{\\mathrm{gt}}^{(m)}\\right)^{2}\\right)}},\n$$\nand the thermodynamic violation metric $V$ defined above. Additionally, evaluate a boundary-state check at $\\boldsymbol{E}=\\boldsymbol{0}$ and $\\tau=0$ by computing the combined norm\n$$\nN_{0} = \\sqrt{\\|\\boldsymbol{S}_{\\mathrm{pred}}\\|_{F}^{2} + \\eta_{\\mathrm{pred}}^{2}}\\quad\\text{at}\\quad \\boldsymbol{E}=\\boldsymbol{0},\\ \\tau=0,\n$$\nand a pure-shear check at $E_{11}=0$, $E_{22}=0$, $E_{12}=\\gamma_{s}/2$, $\\tau=0$ with $\\gamma_{s} = 0.04$, by reporting the relative error in $S_{12}$.\n\nImplementation and test suite. Your program must:\n- Generate training and validation data using $N_{\\mathrm{train}} = 200$, $N_{\\mathrm{val}} = 100$, $e_{\\max} = 0.02$, $t_{\\max} = 0.1$, a fixed random seed of $42$, and the ground-truth parameters $\\lambda = 2.0$, $\\mu = 3.0$, $c = 0.5$, $\\alpha = 0.2$.\n- Train Model A on the training data and evaluate on the validation data.\n- Train Model B three times with regularization weights $\\gamma \\in \\{0.0, 0.01, 1.0\\}$ and evaluate on the validation data.\n- Compute the following ten scalar results, in this exact order:\n    $1.$ $V$ for Model A,\n    $2.$ $\\mathrm{RelRMSE}$ for Model A,\n    $3.$ $V$ for Model B with $\\gamma = 0.0$,\n    $4.$ $\\mathrm{RelRMSE}$ for Model B with $\\gamma = 0.0$,\n    $5.$ $V$ for Model B with $\\gamma = 0.01$,\n    $6.$ $\\mathrm{RelRMSE}$ for Model B with $\\gamma = 0.01$,\n    $7.$ $V$ for Model B with $\\gamma = 1.0$,\n    $8.$ $\\mathrm{RelRMSE}$ for Model B with $\\gamma = 1.0$,\n    $9.$ $N_{0}$ for Model A,\n    $10.$ the relative error in $S_{12}$ under pure shear for Model A with $\\gamma_{s} = 0.04$.\nAll outputs are dimensionless.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each float rounded to six decimal places, for example, $[x_{1},x_{2},\\dots,x_{10}]$ where each $x_{k}$ is rounded to six decimals. No other output is permitted.", "solution": "The user wants to solve a problem in computational thermoelasticity, focusing on the comparison between a thermodynamically consistent constitutive model and a potentially inconsistent one.\n\n### Problem Validation\n\nThe problem statement has been critically examined and is deemed valid.\n\n1.  **Givens Extraction**: All necessary physical relations, model definitions, parameters ($\\lambda, \\mu, c, \\alpha$), data generation specifications ($N_{\\text{train}}, N_{\\text{val}}, e_{\\max}, t_{\\max}$, random seed), and evaluation metrics ($\\mathrm{RelRMSE}, V, N_0$, pure-shear error) are explicitly provided.\n2.  **Scientific Grounding**: The problem is rooted in the standard theory of continuum thermoelasticity. The concepts of Helmholtz free energy $\\psi$, thermodynamic conjugate pairs ($\\boldsymbol{S}=\\partial\\psi/\\partial \\boldsymbol{E}$, $\\eta=-\\partial\\psi/\\partial\\theta$), and Maxwell relations are correctly stated. The use of a potential-based model (Model A) versus a direct data-driven map (Model B) to illustrate thermodynamic consistency is a standard and important topic in physics-informed machine learning.\n3.  **Well-Posedness and Consistency**:\n    *   The ground-truth constitutive model is a standard linear isotropic thermoelastic material, and the provided expressions for stress $\\boldsymbol{S}_{\\mathrm{gt}}$ and entropy $\\eta_{\\mathrm{gt}}$ are correct derivatives of the given free energy $\\psi_{\\mathrm{gt}}$.\n    *   Model A is constructed based on a potential $\\psi_w$ whose functional form nests the ground-truth potential, ensuring it can, in principle, perfectly represent the data. The fitting of its parameters $w$ is a standard linear least-squares problem.\n    *   Model B uses a direct linear mapping from features to outputs. The training objective $\\mathcal{L}_{\\gamma}$ is a regularized least-squares loss. The penalty term $\\gamma V^2$ is based on residuals ($R_{ij,kl}, M_{ij}$) that correctly represent the conditions for thermodynamic consistency (existence of a potential and Maxwell symmetry). Minimizing $\\mathcal{L}_{\\gamma}$ is a well-posed quadratic optimization problem.\n    *   While there is slight ambiguity in the problem's notation $\\partial/\\partial \\boldsymbol{E}$ for a symmetric tensor, the provided ground-truth stress-strain relations are unambiguous. These relations are consistent with the definitions of the thermodynamic-violation residuals used for Model B, making the problem internally consistent and solvable as stated.\n4.  **Feasibility**: The tasks involve generating data, solving linear least-squares problems (for Model A) and regularized linear least-squares problems (for Model B), and evaluating well-defined metrics. All steps are computationally feasible using standard numerical libraries.\n\nThe problem is valid and a detailed solution can be constructed.\n\n### Solution Derivations\n\nThe solution proceeds by implementing the steps detailed in the problem statement.\n\n**1. Data Generation**\nTraining ($N_{\\mathrm{train}}=200$) and validation ($N_{\\mathrm{val}}=100$) datasets are created by sampling strain components $E_{11}, E_{22}, E_{12}$ and temperature deviation $\\tau$. For each state $(\\boldsymbol{E}, \\tau)$, the ground-truth Second Piola-Kirchhoff stress $\\boldsymbol{S}_{\\mathrm{gt}}$ and entropy $\\eta_{\\mathrm{gt}}$ are computed using the provided parameters $\\lambda=2.0, \\mu=3.0, c=0.5, \\alpha=0.2$.\nThe constitutive relations are:\n$$\n\\boldsymbol{S}_{\\mathrm{gt}} = \\lambda(\\mathrm{tr}\\,\\boldsymbol{E})\\boldsymbol{I} + 2\\mu \\boldsymbol{E} + \\alpha\\tau \\boldsymbol{I}\n\\quad \\implies \\quad\n\\begin{cases}\nS_{\\mathrm{gt},11} = \\lambda(E_{11}+E_{22}) + 2\\mu E_{11} + \\alpha\\tau \\\\\nS_{\\mathrm{gt},22} = \\lambda(E_{11}+E_{22}) + 2\\mu E_{22} + \\alpha\\tau \\\\\nS_{\\mathrm{gt},12} = 2\\mu E_{12}\n\\end{cases}\n$$\n$$\n\\eta_{\\mathrm{gt}} = -\\frac{\\partial \\psi_{\\mathrm{gt}}}{\\partial \\tau} = -(c\\tau + \\alpha\\,\\mathrm{tr}\\,\\boldsymbol{E})\n$$\n\n**2. Model A: Potential-Based Learning**\nModel A uses the potential ansatz $\\psi_{w} = \\tfrac{1}{2}w_{1}(\\mathrm{tr}\\,\\boldsymbol{E})^{2} + w_{2}\\,\\mathrm{tr}(\\boldsymbol{E}^{2}) + \\tfrac{1}{2}w_{3}\\tau^{2} + w_{4}\\tau\\,\\mathrm{tr}\\,\\boldsymbol{E}$. The predicted stress and entropy are derived from this potential:\n$S_{w,11} = (w_1+2w_2)E_{11} + w_1 E_{22} + w_4\\tau$\n$S_{w,22} = w_1 E_{11} + (w_1+2w_2)E_{22} + w_4\\tau$\n$S_{w,12} = 2w_2 E_{12}$\n$\\eta_w = -w_3\\tau - w_4 \\mathrm{tr}\\,\\boldsymbol{E}$\nThese equations are linear in the unknown weights $w = [w_1, w_2, w_3, w_4]^T$. We can formulate a linear least-squares problem $X_A w = Y_A$ by stacking these equations for all $N_{\\mathrm{train}}$ training samples. The objective is to minimize the sum of squared errors, which includes the Frobenius norm of the stress error, $\\|\\boldsymbol{S}_{\\mathrm{pred}} - \\boldsymbol{S}_{\\mathrm{gt}}\\|_F^2 = (S_{11,\\Delta})^2 + (S_{22,\\Delta})^2 + 2(S_{12,\\Delta})^2$. To account for this, the equations for $S_{12}$ are weighted by $\\sqrt{2}$ in the least-squares system. The system is solved for $w$ using `numpy.linalg.lstsq`.\n\n**3. Model B: Direct Map with Regularization**\nModel B predicts each component of stress and entropy as a linear combination of features $g(\\boldsymbol{E},\\tau) = [\\mathrm{tr}\\,\\boldsymbol{E}, E_{11}, E_{22}, E_{12}, \\tau, 1]^{\\top}$. This involves $4 \\times 6 = 24$ parameters, which we collect in a single vector $p$. The training minimizes the objective function $\\mathcal{L}_{\\gamma}$. This is a regularized least-squares problem. The empirical risk term $\\frac{1}{N}\\sum(\\dots)$ can be written as $\\frac{1}{N}\\|X_p p - Y_p\\|_2^2$, where $X_p$ is a design matrix and $Y_p$ is the target vector. The penalty term $\\gamma V^2$ can be written as a quadratic form $\\gamma p^T C^T C p$, where the matrix $C$ encodes the linear thermodynamic consistency constraints.\nMinimizing $\\mathcal{L}_{\\gamma}$ with respect to $p$ yields the linear system:\n$$\n\\left(\\frac{1}{N_{\\mathrm{train}}} X_p^T X_p + \\gamma C^T C\\right) p = \\frac{1}{N_{\\mathrm{train}}} X_p^T Y_p\n$$\nThis $24 \\times 24$ system is solved for $p$ for each value of $\\gamma \\in \\{0.0, 0.01, 1.0\\}$. As with Model A, the use of the Frobenius norm is handled by scaling the rows corresponding to $S_{12}$ by $\\sqrt{2}$.\n\n**4. Evaluation**\nThe trained models are evaluated on the validation set.\n*   **$V$ for Model A**: By construction, Model A is based on a potential and its predictions satisfy the consistency relations exactly. Thus, its violation metric $V$ is $0$.\n*   **RelRMSE**: Calculated for all models on the validation set using the provided formula, properly accounting for the Frobenius norm of the stress tensor.\n*   **$V$ for Model B**: Calculated from the fitted parameter vector $p$ using the definition $V = \\sqrt{\\|Cp\\|_2^2}$.\n*   **$N_0$ for Model A**: Evaluated at $\\boldsymbol{E}=\\boldsymbol{0}, \\tau=0$. Given the structure of the model, the predictions for stress and entropy must be zero, so $N_0=0$.\n*   **Pure-Shear Error for Model A**: The relative error in the predicted shear stress $S_{12}$ is calculated at a specific pure-shear state. Since Model A's structure matches the ground truth, this error is expected to be very small, limited only by the precision of the least-squares fit.\nThe ten required results are then collected and formatted.", "answer": "```python\nimport numpy as np\n\n# Ground Truth Parameters\nLAMBDA_GT = 2.0\nMU_GT = 3.0\nC_GT = 0.5\nALPHA_GT = 0.2\n\n# Data Generation Parameters\nN_TRAIN = 200\nN_VAL = 100\nE_MAX = 0.02\nT_MAX = 0.1\nRANDOM_SEED = 42\n\n# Special Check Parameters\nGAMMA_S = 0.04\n\n\ndef generate_data(n_samples, seed):\n    \"\"\"Generates synthetic strain-temperature data and corresponding stress-entropy targets.\"\"\"\n    rng = np.random.default_rng(seed)\n    E11 = rng.uniform(-E_MAX, E_MAX, n_samples)\n    E22 = rng.uniform(-E_MAX, E_MAX, n_samples)\n    E12 = rng.uniform(-E_MAX, E_MAX, n_samples)\n    tau = rng.uniform(-T_MAX, T_MAX, n_samples)\n    \n    trE = E11 + E22\n    \n    S_gt_11 = LAMBDA_GT * trE + 2 * MU_GT * E11 + ALPHA_GT * tau\n    S_gt_22 = LAMBDA_GT * trE + 2 * MU_GT * E22 + ALPHA_GT * tau\n    S_gt_12 = 2 * MU_GT * E12\n    eta_gt = -C_GT * tau - ALPHA_GT * trE\n    \n    strains = np.vstack([E11, E22, E12, tau]).T\n    targets = np.vstack([S_gt_11, S_gt_22, S_gt_12, eta_gt]).T\n    \n    return strains, targets\n\ndef train_model_A(strains_train, targets_train):\n    \"\"\"Trains Model A by solving a linear least-squares problem for the potential weights.\"\"\"\n    n_samples = strains_train.shape[0]\n    X_A = np.zeros((4 * n_samples, 4))\n    Y_A = np.zeros(4 * n_samples)\n    sqrt2 = np.sqrt(2.0)\n    \n    for i in range(n_samples):\n        E11, E22, E12, tau = strains_train[i]\n        trE = E11 + E22\n        \n        # Rows corresponding to S_11, S_22, sqrt(2)*S_12, eta\n        X_A[4 * i, :]     = [trE, 2 * E11, 0, tau]\n        X_A[4 * i + 1, :] = [trE, 2 * E22, 0, tau]\n        X_A[4 * i + 2, :] = [0, sqrt2 * 2 * E12, 0, 0]\n        X_A[4 * i + 3, :] = [0, 0, -tau, -trE]\n\n        Y_A[4*i:4*i+4] = [targets_train[i, 0], targets_train[i, 1], sqrt2 * targets_train[i, 2], targets_train[i, 3]]\n\n    w, _, _, _ = np.linalg.lstsq(X_A, Y_A, rcond=None)\n    return w\n\ndef train_model_B(strains_train, targets_train, gamma):\n    \"\"\"Trains Model B by solving a regularized linear least-squares problem.\"\"\"\n    n_samples = strains_train.shape[0]\n    num_params = 24\n    \n    X_B_prime = np.zeros((4 * n_samples, num_params))\n    Y_B_prime = np.zeros(4 * n_samples)\n    sqrt2 = np.sqrt(2.0)\n\n    for i in range(n_samples):\n        E11, E22, E12, tau = strains_train[i]\n        trE = E11 + E22\n        g = np.array([trE, E11, E22, E12, tau, 1.0])\n        \n        X_B_prime[4 * i, 0:6]     = g\n        X_B_prime[4 * i + 1, 6:12] = g\n        X_B_prime[4 * i + 2, 12:18] = sqrt2 * g\n        X_B_prime[4 * i + 3, 18:24] = g\n\n        Y_B_prime[4*i:4*i+4] = [targets_train[i, 0], targets_train[i, 1], sqrt2 * targets_train[i, 2], targets_train[i, 3]]\n        \n    v11, v22, v12, v_theta = [1,1,0,0,0,0], [1,0,1,0,0,0], [0,0,0,1,0,0], [0,0,0,0,1,0]\n    C = np.zeros((6, num_params))\n    C[0, 0:6], C[0, 6:12]   = v22, [-x for x in v11]\n    C[1, 0:6], C[1, 12:18]  = v12, [-x for x in v11]\n    C[2, 6:12], C[2, 12:18] = v12, [-x for x in v22]\n    C[3, 0:6], C[3, 18:24]  = v_theta, v11\n    C[4, 6:12], C[4, 18:24] = v_theta, v22\n    C[5, 12:18], C[5, 18:24]= v_theta, v12\n    \n    A = (1/n_samples) * X_B_prime.T @ X_B_prime + gamma * C.T @ C\n    b_vec = (1/n_samples) * X_B_prime.T @ Y_B_prime\n    \n    p = np.linalg.solve(A, b_vec)\n    return p\n\ndef predict_model_A(w, strains):\n    \"\"\"Predicts stress and entropy using Model A's learned weights.\"\"\"\n    w1, w2, w3, w4 = w\n    E11, E22, E12, tau = strains.T\n    trE = E11 + E22\n    S_pred_11 = w1 * trE + 2 * w2 * E11 + w4 * tau\n    S_pred_22 = w1 * trE + 2 * w2 * E22 + w4 * tau\n    S_pred_12 = 2 * w2 * E12\n    eta_pred = -w3 * tau - w4 * trE\n    return np.vstack([S_pred_11, S_pred_22, S_pred_12, eta_pred]).T\n\ndef predict_model_B(p, strains):\n    \"\"\"Predicts stress and entropy using Model B's learned parameters.\"\"\"\n    E11, E22, E12, tau = strains.T\n    trE = E11 + E22\n    g = np.vstack([trE, E11, E22, E12, tau, np.ones_like(E11)]).T\n    a11, a22, a12, b_eta = p[0:6], p[6:12], p[12:18], p[18:24]\n    S_pred_11 = g @ a11\n    S_pred_22 = g @ a22\n    S_pred_12 = g @ a12\n    eta_pred = g @ b_eta\n    return np.vstack([S_pred_11, S_pred_22, S_pred_12, eta_pred]).T\n\ndef calculate_rel_rmse(preds, gts):\n    \"\"\"Computes the relative root-mean-square error.\"\"\"\n    delta_S11, delta_S22, delta_S12, delta_eta = (preds - gts).T\n    numerator = np.sum(delta_S11**2 + delta_S22**2 + 2 * delta_S12**2 + delta_eta**2)\n    gt_S11, gt_S22, gt_S12, gt_eta = gts.T\n    denominator = np.sum(gt_S11**2 + gt_S22**2 + 2 * gt_S12**2 + gt_eta**2)\n    return np.sqrt(numerator / denominator) if denominator != 0 else 0.0\n\ndef calculate_V(p):\n    \"\"\"Computes the thermodynamic violation metric V for Model B.\"\"\"\n    v11, v22, v12, v_theta = np.array([1,1,0,0,0,0]), np.array([1,0,1,0,0,0]), np.array([0,0,0,1,0,0]), np.array([0,0,0,0,1,0])\n    a11, a22, a12, b_eta = p[0:6], p[6:12], p[12:18], p[18:24]\n    R1122 = a11 @ v22 - a22 @ v11\n    R1112 = a11 @ v12 - a12 @ v11\n    R2212 = a22 @ v12 - a12 @ v22\n    M11 = a11 @ v_theta + b_eta @ v11\n    M22 = a22 @ v_theta + b_eta @ v22\n    M12 = a12 @ v_theta + b_eta @ v12\n    return np.sqrt(R1122**2 + R1112**2 + R2212**2 + M11**2 + M22**2 + M12**2)\n    \ndef solve():\n    \"\"\"Main driver function to perform training, evaluation, and printing results.\"\"\"\n    strains_train, targets_train = generate_data(N_TRAIN, RANDOM_SEED)\n    strains_val, targets_val = generate_data(N_VAL, RANDOM_SEED + 1)\n    \n    results = []\n    \n    # Model A Evaluation\n    w_A = train_model_A(strains_train, targets_train)\n    results.append(0.0)  # V for Model A is 0 by construction\n    preds_A_val = predict_model_A(w_A, strains_val)\n    results.append(calculate_rel_rmse(preds_A_val, targets_val))\n    \n    # Model B Evaluation for different gammas\n    for gamma in [0.0, 0.01, 1.0]:\n        p_B = train_model_B(strains_train, targets_train, gamma)\n        results.append(calculate_V(p_B))\n        preds_B_val = predict_model_B(p_B, strains_val)\n        results.append(calculate_rel_rmse(preds_B_val, targets_val))\n        \n    # Boundary-state check for Model A\n    preds_N0 = predict_model_A(w_A, np.array([[0, 0, 0, 0]]))\n    S_F_sq = preds_N0[0,0]**2 + preds_N0[0,1]**2 + 2 * preds_N0[0,2]**2\n    results.append(np.sqrt(S_F_sq + preds_N0[0,3]**2))\n    \n    # Pure-shear check for Model A\n    E12_shear = GAMMA_S / 2.0\n    S_gt_12 = 2 * MU_GT * E12_shear\n    preds_shear = predict_model_A(w_A, np.array([[0, 0, E12_shear, 0]]))\n    S_pred_12 = preds_shear[0, 2]\n    results.append(np.abs(S_pred_12 - S_gt_12) / np.abs(S_gt_12))\n    \n    print(f\"[{','.join(f'{x:.6f}' for x in results)}]\")\n\nsolve()\n\n```", "id": "3606695"}]}