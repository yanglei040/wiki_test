{"hands_on_practices": [{"introduction": "Mastering any numerical method begins with its most fundamental application. This first practice focuses on implementing the implicit Newmark-β scheme for a simple linear single-degree-of-freedom (SDOF) oscillator. You will derive the core components of the implicit solver, including the effective stiffness matrix and effective load vector, which are essential for solving the system at each time step. This exercise [@problem_id:3573229] provides a solid foundation by guiding you through a complete one-step update and a stability analysis using the amplification matrix, building the essential skills needed for more complex dynamic simulations.", "problem": "You are asked to design and implement a program that computes the effective system and algorithmic coefficients for the implicit Newmark-beta family of time integration schemes in computational solid mechanics, and uses them to perform a one-step update and to assess linear stability via the amplification matrix, all for a single degree of freedom (SDOF) linear oscillator.\n\nStart from the fundamental governing equation of motion for an SDOF system derived from Newton’s Second Law of Motion:\n$$\nm \\, \\ddot{u}(t) + c \\, \\dot{u}(t) + k \\, u(t) = f(t),\n$$\nwhere $m$ is the mass, $c$ is the viscous damping coefficient, $k$ is the linear stiffness, $u(t)$ is the displacement, $\\dot{u}(t)$ is the velocity, $\\ddot{u}(t)$ is the acceleration, and $f(t)$ is the external force. Units must be used consistently: $m$ in $\\mathrm{kg}$, $c$ in $\\mathrm{N \\cdot s/m}$, $k$ in $\\mathrm{N/m}$, $t$ in $\\mathrm{s}$, $u$ in $\\mathrm{m}$, $\\dot{u}$ in $\\mathrm{m/s}$, $\\ddot{u}$ in $\\mathrm{m/s^2}$, and $f$ in $\\mathrm{N}$.\n\nThe implicit Newmark-beta family of schemes uses two parameters $ \\beta $ and $ \\gamma $ to relate $u_{n+1}$, $v_{n+1}$, and $a_{n+1}$ at time $t_{n+1}=t_n+\\Delta t$ to the known state $(u_n, v_n, a_n)$ at $t_n$, for a fixed time step $\\Delta t > 0$. From the above base, derive the consistent effective system needed to solve for $u_{n+1}$ implicitly, and the associated algorithmic coefficients that appear in the effective stiffness and effective load for the SDOF case. Then, using the same principles and the discrete update relations of the Newmark-beta method, derive the formulas to recover $a_{n+1}$ and $v_{n+1}$ from $u_{n+1}$ and the known prior state. Finally, define the linear amplification mapping that sends the state vector $[u_n, v_n, a_n]^T$ to $[u_{n+1}, v_{n+1}, a_{n+1}]^T$ for the homogeneous problem with $f \\equiv 0$, and determine its spectral radius for the given parameters by direct construction of the mapping.\n\nYour program must implement these steps and compute, for each test case below:\n- The six algorithmic coefficients (dimensionally consistent) that arise in the effective system and load assembly for the implicit Newmark-beta scheme.\n- The effective scalar stiffness $k_{\\mathrm{eff}}$ for the SDOF system in the implicit solve at $t_{n+1}$.\n- The one-step updated displacement $u_{n+1}$ computed from the effective system using the given $f_{n+1}$ and the provided prior state $(u_n, v_n, a_n)$.\n- The spectral radius $\\rho$ of the amplification matrix associated with the homogeneous ($f \\equiv 0$) discrete update mapping for the given $(m,c,k,\\Delta t,\\beta,\\gamma)$.\n\nUse coherent International System of Units. Report the spectral radius $\\rho$ as a dimensionless real number. Report $k_{\\mathrm{eff}}$ in $\\mathrm{N/m}$ and $u_{n+1}$ in $\\mathrm{m}$. Do not apply rounding; compute with standard double-precision floating point arithmetic.\n\nTest suite (each case defines the parameters and prior state at $t_n$, as well as the external force at $t_{n+1}$):\n1. Case A (happy path, lightly damped):\n   - $m = 2.0 \\, \\mathrm{kg}$, $c = 0.5 \\, \\mathrm{N \\cdot s/m}$, $k = 50.0 \\, \\mathrm{N/m}$, $\\Delta t = 0.1 \\, \\mathrm{s}$, $\\beta = 0.25$, $\\gamma = 0.5$.\n   - Prior state: $u_n = 0.02 \\, \\mathrm{m}$, $v_n = 0.0 \\, \\mathrm{m/s}$, $a_n = 0.0 \\, \\mathrm{m/s^2}$.\n   - External force at the next step: $f_{n+1} = 1.0 \\, \\mathrm{N}$.\n2. Case B (undamped, stiff, small time step):\n   - $m = 1.0 \\, \\mathrm{kg}$, $c = 0.0 \\, \\mathrm{N \\cdot s/m}$, $k = 1000.0 \\, \\mathrm{N/m}$, $\\Delta t = 0.01 \\, \\mathrm{s}$, $\\beta = 0.3025$, $\\gamma = 0.6$.\n   - Prior state: $u_n = 0.0 \\, \\mathrm{m}$, $v_n = 1.0 \\, \\mathrm{m/s}$, $a_n = 0.0 \\, \\mathrm{m/s^2}$.\n   - External force at the next step: $f_{n+1} = 0.0 \\, \\mathrm{N}$.\n3. Case C (heavily damped, larger time step):\n   - $m = 1.0 \\, \\mathrm{kg}$, $c = 5.0 \\, \\mathrm{N \\cdot s/m}$, $k = 20.0 \\, \\mathrm{N/m}$, $\\Delta t = 0.2 \\, \\mathrm{s}$, $\\beta = 0.25$, $\\gamma = 0.6$.\n   - Prior state: $u_n = -0.1 \\, \\mathrm{m}$, $v_n = 0.5 \\, \\mathrm{m/s}$, $a_n = 0.0 \\, \\mathrm{m/s^2}$.\n   - External force at the next step: $f_{n+1} = 0.0 \\, \\mathrm{N}$.\n\nYour program must:\n- Derive and use the consistent implicit Newmark-beta effective system and algorithmic coefficients.\n- Assemble and solve the scalar effective system for $u_{n+1}$ for the given $f_{n+1}$ and prior state.\n- Recover $a_{n+1}$ and $v_{n+1}$ from $u_{n+1}$ and the prior state using the Newmark-beta update relations.\n- Construct the $3 \\times 3$ amplification matrix by applying the one-step mapping to the three canonical basis initial states for the homogeneous problem, and compute its spectral radius $\\rho$.\n\nFinal output format:\n- Your program should produce a single line of output containing a list of three results, one per test case, where each test case result is itself a list of nine floating-point numbers in the following order:\n  $[k_{\\mathrm{eff}}, a_0, a_1, a_2, a_3, a_4, a_5, \\rho, u_{n+1}]$.\n- The line must be exactly a Python-style list literal with no extra text, for example:\n  $[[\\dots\\text{Case A nine values}\\dots],[\\dots\\text{Case B nine values}\\dots],[\\dots\\text{Case C nine values}\\dots]]$.", "solution": "The problem requires the design and implementation of a program to analyze a single-degree-of-freedom (SDOF) linear oscillator using the implicit Newmark-beta family of time integration schemes. This involves deriving and computing the effective system coefficients, performing a one-step time update, and assessing the linear stability of the scheme via its amplification matrix.\n\nThe analysis begins with the governing differential equation for an SDOF system:\n$$\nm \\, \\ddot{u}(t) + c \\, \\dot{u}(t) + k \\, u(t) = f(t)\n$$\nwhere $m$, $c$, and $k$ are the mass, damping, and stiffness coefficients, respectively. $u(t)$, $\\dot{u}(t)$, and $\\ddot{u}(t)$ are the displacement, velocity, and acceleration. We denote the discrete approximations at time $t_n$ as $u_n$, $v_n = \\dot{u}(t_n)$, and $a_n = \\ddot{u}(t_n)$.\n\nThe Newmark-beta method provides update rules for the displacement and velocity at time $t_{n+1} = t_n + \\Delta t$:\n$$\nu_{n+1} = u_n + \\Delta t \\, v_n + \\Delta t^2 \\left[ \\left(\\frac{1}{2} - \\beta\\right) a_n + \\beta a_{n+1} \\right] \\quad (1)\n$$\n$$\nv_{n+1} = v_n + \\Delta t \\left[ (1-\\gamma) a_n + \\gamma a_{n+1} \\right] \\quad (2)\n$$\nwhere $\\beta$ and $\\gamma$ are the dimensionless parameters of the scheme.\n\n### Derivation of the Effective System\n\nFor an implicit scheme, the equation of motion is enforced at the end of the time step, $t_{n+1}$:\n$$\nm a_{n+1} + c v_{n+1} + k u_{n+1} = f_{n+1} \\quad (3)\n$$\nThe primary unknown is the displacement $u_{n+1}$. To solve for it, we must express $a_{n+1}$ and $v_{n+1}$ in terms of $u_{n+1}$ and the known state at $t_n$.\n\nFrom equation (1), we can rearrange to express $a_{n+1}$ as a function of $u_{n+1}$:\n$$\na_{n+1} = \\frac{1}{\\beta \\Delta t^2} (u_{n+1} - u_n) - \\frac{1}{\\beta \\Delta t} v_n - \\left(\\frac{1}{2\\beta} - 1\\right) a_n \\quad (A)\n$$\nNow, substitute this expression for $a_{n+1}$ into equation (2) to find $v_{n+1}$ in terms of $u_{n+1}$:\n$$\nv_{n+1} = v_n + (1-\\gamma)\\Delta t a_n + \\gamma \\Delta t \\left[ \\frac{1}{\\beta \\Delta t^2} (u_{n+1} - u_n) - \\frac{1}{\\beta \\Delta t} v_n - \\left(\\frac{1}{2\\beta} - 1\\right) a_n \\right]\n$$\nGrouping terms by state variables yields:\n$$\nv_{n+1} = \\frac{\\gamma}{\\beta \\Delta t} (u_{n+1} - u_n) + \\left(1 - \\frac{\\gamma}{\\beta}\\right)v_n + \\Delta t \\left(1 - \\frac{\\gamma}{2\\beta}\\right)a_n \\quad (B)\n$$\n\nNext, we substitute expressions (A) and (B) into the equation of motion (3). To make the formulation suitable for a general solver, we rearrange it into the form of a linear system, $k_{\\mathrm{eff}} u_{n+1} = f_{\\mathrm{eff}}$. We group all terms containing the unknown $u_{n+1}$ on the left-hand side (LHS) and all known quantities on the right-hand side (RHS).\n\n$$\nm a_{n+1} + c v_{n+1} + k u_{n+1} = f_{n+1}\n$$\n$$\nm\\left(\\dots\\right) + c\\left(\\dots\\right) + k u_{n+1} = f_{n+1}\n$$\nSubstituting (A) and (B) and rearranging:\n$$\n\\left( \\frac{1}{\\beta \\Delta t^2}m + \\frac{\\gamma}{\\beta \\Delta t}c + k \\right) u_{n+1} = f_{n+1} + m\\left(\\frac{u_n}{\\beta \\Delta t^2} + \\frac{v_n}{\\beta \\Delta t} + \\left(\\frac{1}{2\\beta}-1\\right)a_n\\right) + c\\left(\\frac{\\gamma u_n}{\\beta \\Delta t} + \\left(\\frac{\\gamma}{\\beta} - 1 \\right)v_n + \\Delta t\\left(\\frac{\\gamma}{2\\beta} - 1\\right)a_n\\right)\n$$\n\nFrom this equation, we can identify the effective stiffness $k_{\\mathrm{eff}}$ and the effective load $f_{\\mathrm{eff}}$.\n\n**Effective Stiffness:**\n$$\nk_{\\mathrm{eff}} = k + \\frac{\\gamma}{\\beta \\Delta t} c + \\frac{1}{\\beta \\Delta t^2} m\n$$\n\n**Algorithmic Coefficients:** The problem asks for six algorithmic coefficients that arise in the assembly of the effective system. Based on the derived effective system equation, a consistent and meaningful set of six coefficients is:\n- $a_0 = \\frac{1}{\\beta \\Delta t^2}$: coefficient multiplying $m$ in $k_{\\mathrm{eff}}$ and $m u_n$ on the RHS.\n- $a_1 = \\frac{\\gamma}{\\beta \\Delta t}$: coefficient multiplying $c$ in $k_{\\mathrm{eff}}$ and $c u_n$ on the RHS.\n- $a_2 = \\frac{1}{\\beta \\Delta t}$: coefficient for the contribution of $v_n$ from the mass term on the RHS.\n- $a_3 = \\frac{1}{2\\beta} - 1$: coefficient for the contribution of $a_n$ from the mass term on the RHS.\n- $a_4 = \\frac{\\gamma}{\\beta} - 1$: coefficient for the contribution of $v_n$ from the damping term on the RHS.\n- $a_5 = \\Delta t \\left( \\frac{\\gamma}{2\\beta} - 1 \\right)$: coefficient for the contribution of $a_n$ from the damping term on the RHS.\n\nUsing these coefficients, the effective system is:\n$$\nk_{\\mathrm{eff}} = k + a_1 c + a_0 m\n$$\n$$\nf_{\\mathrm{eff}} = f_{n+1} + m(a_0 u_n + a_2 v_n + a_3 a_n) + c(a_1 u_n + a_4 v_n + a_5 a_n)\n$$\nThe update proceeds by solving $u_{n+1} = f_{\\mathrm{eff}} / k_{\\mathrm{eff}}$, and then recovering $a_{n+1}$ and $v_{n+1}$ using equations (A) and (2) respectively.\n\n### Stability Analysis via Amplification Matrix\n\nTo analyze the stability of the numerical scheme, we consider the homogeneous problem ($f(t) \\equiv 0$). The one-step update can be written as a linear map from the state vector at $t_n$, $\\mathbf{d}_n = [u_n, v_n, a_n]^T$, to the state vector at $t_{n+1}$, $\\mathbf{d}_{n+1} = [u_{n+1}, v_{n+1}, a_{n+1}]^T$:\n$$\n\\mathbf{d}_{n+1} = \\mathbf{A} \\, \\mathbf{d}_n\n$$\nwhere $\\mathbf{A}$ is the $3 \\times 3$ amplification matrix. The scheme is stable if the spectral radius $\\rho(\\mathbf{A}) = \\max_i |\\lambda_i|$ is less than or equal to $1$, where $\\lambda_i$ are the eigenvalues of $\\mathbf{A}$.\n\nTo derive $\\mathbf{A}$, we first express $a_{n+1}$ in terms of the state at $t_n$. For the homogeneous problem, the discrete equation of motion is $m a_{n+1} + c v_{n+1} + k u_{n+1} = 0$. Substituting the Newmark update equations (1) and (2) into this gives:\n$$\nm a_{n+1} + c(v_n + \\Delta t(1-\\gamma) a_n + \\gamma \\Delta t a_{n+1}) + k(u_n + \\Delta t v_n + \\Delta t^2(\\tfrac{1}{2}-\\beta) a_n + \\beta \\Delta t^2 a_{n+1}) = 0\n$$\nSolving for $a_{n+1}$:\n$$\n(m + c \\gamma \\Delta t + k \\beta \\Delta t^2) a_{n+1} = -k u_n - (c+k\\Delta t)v_n - (c\\Delta t(1-\\gamma)+k\\Delta t^2(\\tfrac{1}{2}-\\beta)) a_n\n$$\nLet $D = m + c \\gamma \\Delta t + k \\beta \\Delta t^2$. Then $a_{n+1}$ is a linear combination of $u_n, v_n, a_n$, which defines the third row of $\\mathbf{A}$:\n$$\na_{n+1} = A_{31} u_n + A_{32} v_n + A_{33} a_n\n$$\nwhere\n$A_{31} = -k/D$\n$A_{32} = -(c + k\\Delta t)/D$\n$A_{33} = -(c\\Delta t(1-\\gamma) + k\\Delta t^2(\\tfrac{1}{2}-\\beta))/D$\n\nThe first and second rows of $\\mathbf{A}$ are found by substituting this expression for $a_{n+1}$ back into the update equations (1) and (2).\nFor $u_{n+1}$:\n$$\nu_{n+1} = u_n + \\Delta t v_n + \\Delta t^2(\\tfrac{1}{2}-\\beta)a_n + \\beta\\Delta t^2(A_{31}u_n+A_{32}v_n+A_{33}a_n)\n$$\n$$\nA_{11} = 1 + \\beta \\Delta t^2 A_{31}, \\quad A_{12} = \\Delta t + \\beta \\Delta t^2 A_{32}, \\quad A_{13} = \\Delta t^2(\\tfrac{1}{2}-\\beta) + \\beta \\Delta t^2 A_{33}\n$$\nFor $v_{n+1}$:\n$$\nv_{n+1} = v_n + \\Delta t(1-\\gamma) a_n + \\gamma\\Delta t(A_{31}u_n+A_{32}v_n+A_{33}a_n)\n$$\n$$\nA_{21} = \\gamma\\Delta t A_{31}, \\quad A_{22} = 1 + \\gamma\\Delta t A_{32}, \\quad A_{23} = \\Delta t(1-\\gamma) + \\gamma\\Delta t A_{33}\n$$\nWith the matrix $\\mathbf{A}$ constructed, its eigenvalues can be computed numerically to find the spectral radius $\\rho(\\mathbf{A})$.\n\nThe program will implement these derivations to compute the required quantities for each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes effective system coefficients, one-step update, and spectral radius\n    for the implicit Newmark-beta scheme for an SDOF linear oscillator.\n    \"\"\"\n    # Test cases: (m, c, k, dt, beta, gamma, u_n, v_n, a_n, f_n1)\n    test_cases = [\n        # Case A (happy path, lightly damped)\n        (2.0, 0.5, 50.0, 0.1, 0.25, 0.5, 0.02, 0.0, 0.0, 1.0),\n        # Case B (undamped, stiff, small time step)\n        (1.0, 0.0, 1000.0, 0.01, 0.3025, 0.6, 0.0, 1.0, 0.0, 0.0),\n        # Case C (heavily damped, larger time step)\n        (1.0, 5.0, 20.0, 0.2, 0.25, 0.6, -0.1, 0.5, 0.0, 0.0),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        m, c, k, dt, beta, gamma, u_n, v_n, a_n, f_n1 = case\n\n        # Part 1: Compute the six algorithmic coefficients\n        # These coefficients are derived from the effective system formulation.\n        # k_eff = k + a_1*c + a_0*m\n        # f_eff = f_n+1 + m*(a_0*u_n + a_2*v_n + a_3*a_n) + c*(a_1*u_n + a_4*v_n + a_5*a_n)\n        \n        # Check for beta = 0 case, which leads to division by zero\n        if beta == 0:\n            # The displacement-based formulation used here is not valid for beta=0.\n            # An acceleration-based formulation would be needed. This is an edge case\n            # not relevant to the test suite, but good practice to consider.\n            # For this problem, we assume beta > 0.\n            pass\n\n        a0 = 1.0 / (beta * dt**2)\n        a1 = gamma / (beta * dt)\n        a2 = 1.0 / (beta * dt)\n        a3 = 1.0 / (2.0 * beta) - 1.0\n        a4 = gamma / beta - 1.0\n        a5 = dt * (gamma / (2.0 * beta) - 1.0)\n\n        # Part 2: Compute effective stiffness and solve for u_{n+1}\n        k_eff = k + a1 * c + a0 * m\n        \n        f_eff_mass = m * (a0 * u_n + a2 * v_n + a3 * a_n)\n        f_eff_damp = c * (a1 * u_n + a4 * v_n + a5 * a_n)\n        f_eff = f_n1 + f_eff_mass + f_eff_damp\n        \n        u_n1 = f_eff / k_eff\n\n        # Part 3: Compute the spectral radius of the amplification matrix\n        # Amplification matrix A maps d_n = [u_n, v_n, a_n]^T to d_{n+1}\n        \n        # Denominator for the amplification matrix elements\n        D = m + c * gamma * dt + k * beta * dt**2\n        \n        # Third row of A (expression for a_{n+1})\n        A31 = -k / D\n        A32 = -(c + k * dt) / D\n        A33 = -(c * dt * (1.0 - gamma) + k * dt**2 * (0.5 - beta)) / D\n        \n        # First row of A (expression for u_{n+1})\n        A11 = 1.0 + beta * dt**2 * A31\n        A12 = dt + beta * dt**2 * A32\n        A13 = dt**2 * (0.5 - beta) + beta * dt**2 * A33\n        \n        # Second row of A (expression for v_{n+1})\n        A21 = gamma * dt * A31\n        A22 = 1.0 + gamma * dt * A32\n        A23 = dt * (1.0 - gamma) + gamma * dt * A33\n        \n        # Construct the amplification matrix\n        A_matrix = np.array([\n            [A11, A12, A13],\n            [A21, A22, A23],\n            [A31, A32, A33]\n        ])\n        \n        # Compute eigenvalues and spectral radius\n        eigenvalues = np.linalg.eigvals(A_matrix)\n        rho = np.max(np.abs(eigenvalues))\n\n        # Assemble results for the current case in the specified order\n        case_results = [k_eff, a0, a1, a2, a3, a4, a5, rho, u_n1]\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format\n    # Printing a list of lists requires careful formatting.\n    # We use repr() on each inner list to get its string representation\n    # and then join them.\n    print(f\"[{','.join(repr(res) for res in all_results)}]\")\n\nsolve()\n```", "id": "3573229"}, {"introduction": "Real-world engineering systems are often nonlinear. This practice extends the Newmark-β method to a classic problem in computational mechanics: the stick-slip dynamics of a system with Coulomb friction. You will discover how the inherent stiffness of frictional contact can trigger non-physical, high-frequency oscillations known as \"numerical chatter.\" The key takeaway from this exercise [@problem_id:3573269] is learning how to use the algorithmic damping controlled by the Newmark parameter $\\gamma$ to suppress these spurious oscillations, a crucial technique for obtaining stable and physically meaningful results in contact simulations.", "problem": "You are to design and implement a complete, runnable program that investigates how algorithmic damping in the implicit Newmark-$\\beta$ family of schemes affects stick-slip dynamics in frictional contact, with the goal of identifying parameter regimes $\\left(\\beta,\\gamma\\right)$ that suppress numerical chatter without overdamping physically relevant oscillatory modes. The investigation must be posed purely in mathematical and logical terms, using a single-degree-of-freedom system consistent with computational solid mechanics.\n\nStart from the governing laws and definitions. Use Newton’s Second Law and standard constitutive relations. Consider a single-degree-of-freedom mass-spring-damper system with scalar displacement $x(t)$, velocity $v(t)$, and acceleration $a(t)$, driven by a harmonic external force. The equation of motion is\n$$\nm\\,a(t) + c\\,v(t) + k\\,x(t) = f_{\\mathrm{ext}}(t) + f_{\\mathrm{fr}}(t),\n$$\nwhere $m$ is the mass, $c$ is the viscous damping coefficient, $k$ is the stiffness, $f_{\\mathrm{ext}}(t)$ is the external force, and $f_{\\mathrm{fr}}(t)$ is the tangential Coulomb friction contact force. The external force is prescribed as\n$$\nf_{\\mathrm{ext}}(t) = A \\sin(\\omega t),\n$$\nwith $A$ the amplitude and $\\omega$ the angular frequency. Assume a rigid surface with constant tangential velocity $v_b$, and constant normal load $N$. The Coulomb friction law is\n$$\nf_{\\mathrm{fr}}(t) = \n\\begin{cases}\n\\lambda(t), & \\text{if sticking}, \\\\\n-\\mu N\\,\\mathrm{sign}\\big(v(t)-v_b\\big), & \\text{if slipping},\n\\end{cases}\n$$\nwith static stick admissibility $\\lvert \\lambda(t) \\rvert \\le \\mu N$, coefficient of friction $\\mu$, and normal load $N$. The stick constraint is $v(t) = v_b$, whereas slip imposes $f_{\\mathrm{fr}}(t)$ at the Coulomb limit with direction opposite to the relative tangential velocity.\n\nDiscretize time using a uniform time step $\\Delta t$ and the implicit Newmark-$\\beta$ family characterized by parameters $\\beta$ and $\\gamma$. The discrete kinematic update relations must be derived from first principles (do not assume them) and must enable solving for the unknown acceleration at the new time step to enforce dynamic equilibrium implicitly in the presence of frictional contact. Implement a consistent stick-slip decision procedure at each time step, based on the stick constraint and Coulomb limit, that ensures the friction state and force satisfy the admissibility conditions.\n\nThe purpose is to quantify the onset and prevalence of numerical chatter caused by algorithmic (numerical) damping control via $\\left(\\beta,\\gamma\\right)$, and to identify regimes that eliminate stick-slip oscillations without overdamping physical modes. For this, you must:\n\n- Implement a simulator that advances $\\left(x,v,a\\right)$ from $t_n$ to $t_{n+1}$ under the discrete implicit equilibrium and Newmark-$\\beta$ kinematics, while determining stick versus slip consistently with the Coulomb law for friction and the stick admissibility.\n- Define a chatter metric as follows: count the number of consecutive time-step state toggles (stick $\\leftrightarrow$ slip, or slip direction flips) that occur when the relative velocity magnitude $\\lvert v(t)-v_b\\rvert$ is below a small threshold $\\varepsilon_r$. Normalize this count by the number of time steps to obtain a dimensionless chatter score $C \\in [0,1]$.\n- Define a physical-mode preservation metric by computing the steady-state displacement amplitude under periodic forcing and comparing it to a baseline simulation with $\\beta = 1/4$ and $\\gamma = 1/2$ (no algorithmic numerical damping). Let $R$ be the amplitude ratio (test amplitude divided by baseline amplitude), computed over the final portion of the simulation interval to avoid transients.\n\nClassify a parameter regime $\\left(\\beta,\\gamma\\right)$ as “good” if it simultaneously satisfies $C \\le C_{\\max}$ and $R \\ge R_{\\min}$, where $C_{\\max}$ and $R_{\\min}$ are fixed thresholds you choose to ensure reasonable chatter suppression without excessive attenuation of physical oscillations. Your program must compute, for each test case, a boolean indicating whether the regime is good.\n\nUse the following scientifically realistic parameters and units:\n\n- Mass $m = 1$ in $\\mathrm{kg}$.\n- Stiffness $k = 1000$ in $\\mathrm{N}/\\mathrm{m}$.\n- Viscous damping $c = 1$ in $\\mathrm{N}\\cdot\\mathrm{s}/\\mathrm{m}$.\n- Coefficient of friction $\\mu = 0.3$ dimensionless.\n- Normal load $N = 10$ in $\\mathrm{N}$.\n- Belt velocity $v_b = 0$ in $\\mathrm{m}/\\mathrm{s}$.\n- External force amplitude $A = 50$ in $\\mathrm{N}$.\n- Angular frequency $\\omega = \\sqrt{k/m}$ in $\\mathrm{rad}/\\mathrm{s}$.\n- Total simulation time $T = 5$ in $\\mathrm{s}$.\n- Relative velocity chatter threshold $\\varepsilon_r = 10^{-3}$ in $\\mathrm{m}/\\mathrm{s}$.\n\nConstruct and evaluate the following test suite, each defined by $\\left(\\beta,\\gamma,\\Delta t\\right)$:\n\n- Case $1$: $\\beta = 1/4$, $\\gamma = 1/2$, $\\Delta t = 5 \\times 10^{-3}$ in $\\mathrm{s}$.\n- Case $2$: $\\beta = 0.30$, $\\gamma = 0.60$, $\\Delta t = 5 \\times 10^{-3}$ in $\\mathrm{s}$.\n- Case $3$: $\\beta = 0.40$, $\\gamma = 0.80$, $\\Delta t = 5 \\times 10^{-3}$ in $\\mathrm{s}$.\n- Case $4$: $\\beta = 0.28$, $\\gamma = 0.62$, $\\Delta t = 2 \\times 10^{-3}$ in $\\mathrm{s}$.\n\nFor each case, compute the chatter score $C$ and amplitude ratio $R$ with respect to the per-case baseline using $\\beta = 1/4$ and $\\gamma = 1/2$ and the same $\\Delta t$. Then output a boolean indicating whether $\\left(C \\le C_{\\max}\\right)$ and $\\left(R \\ge R_{\\min}\\right)$ with thresholds $C_{\\max} = 2 \\times 10^{-2}$ and $R_{\\min} = 7 \\times 10^{-1}$.\n\nYour program should produce a single line of output containing the four booleans for the test suite as a comma-separated list enclosed in square brackets, for example, `[True,False,True,True]`. No additional text should be printed. All internal computations must adhere to the stated units. Angles must be in radians. Percentages must not be used; any fractional quantities must remain as decimal numbers.", "solution": "The user has provided a well-defined problem in computational solid mechanics, requiring the implementation of an implicit Newmark-$\\beta$ time integration scheme to study stick-slip friction dynamics.\n\n### **Problem Validation**\n\n1.  **Extract Givens**:\n    *   **Equation of Motion**: $m\\,a(t) + c\\,v(t) + k\\,x(t) = f_{\\mathrm{ext}}(t) + f_{\\mathrm{fr}}(t)$.\n    *   **External Force**: $f_{\\mathrm{ext}}(t) = A \\sin(\\omega t)$.\n    *   **Coulomb Friction**: $f_{\\mathrm{fr}}(t)$ is $\\lambda(t)$ for stick ($v(t) = v_b$, $|\\lambda(t)| \\le \\mu N$) and $-\\mu N\\,\\mathrm{sign}(v(t)-v_b)$ for slip.\n    *   **Numerical Scheme**: Implicit Newmark-$\\beta$ with parameters $(\\beta, \\gamma)$ and time step $\\Delta t$.\n    *   **Parameters**: $m = 1\\,\\mathrm{kg}$, $k = 1000\\,\\mathrm{N}/\\mathrm{m}$, $c = 1\\,\\mathrm{N}\\cdot\\mathrm{s}/\\mathrm{m}$, $\\mu = 0.3$, $N = 10\\,\\mathrm{N}$, $v_b = 0\\,\\mathrm{m}/\\mathrm{s}$, $A = 50\\,\\mathrm{N}$, $\\omega = \\sqrt{k/m}\\,\\mathrm{rad}/\\mathrm{s}$, $T = 5\\,\\mathrm{s}$, $\\varepsilon_r = 10^{-3}\\,\\mathrm{m}/\\mathrm{s}$.\n    *   **Metrics**: Chatter score $C$ (normalized count of low-velocity state toggles) and amplitude ratio $R$ (test amplitude vs. baseline amplitude).\n    *   **Classification Criteria**: A regime is \"good\" if $C \\le C_{\\max} = 2 \\times 10^{-2}$ and $R \\ge R_{\\min} = 7 \\times 10^{-1}$.\n    *   **Test Cases**:\n        1.  $(\\beta = 1/4, \\gamma = 1/2, \\Delta t = 5 \\times 10^{-3}\\,\\mathrm{s})$\n        2.  $(\\beta = 0.30, \\gamma = 0.60, \\Delta t = 5 \\times 10^{-3}\\,\\mathrm{s})$\n        3.  $(\\beta = 0.40, \\gamma = 0.80, \\Delta t = 5 \\times 10^{-3}\\,\\mathrm{s})$\n        4.  $(\\beta = 0.28, \\gamma = 0.62, \\Delta t = 2 \\times 10^{-3}\\,\\mathrm{s})$\n    *   **Baseline**: For each test case, the baseline uses $\\beta = 1/4$, $\\gamma = 1/2$ and the same $\\Delta t$.\n    *   **Initial Conditions**: Not explicitly specified. Standard practice for analyzing steady-state response is to assume zero initial conditions: $x(0)=0$ and $v(0)=0$.\n\n2.  **Validate Using Extracted Givens**:\n    *   **Scientifically Grounded**: Yes. The problem is based on Newton's laws, standard material/contact models, and a canonical numerical integration method.\n    *   **Well-Posed**: Yes. The governing equations and numerical procedure are well-defined. The lack of explicit initial conditions is a minor omission, resolvable with a standard, non-prejudicial assumption ($x_0=0, v_0=0$) that does not affect the steady-state metrics.\n    *   **Objective**: Yes. All definitions, parameters, and criteria are quantitative and objective.\n\n3.  **Verdict and Action**: The problem is **valid**. A full solution will be provided.\n\n### **Methodology and Derivations**\n\n**1. Newmark-$\\beta$ Kinematic Update Rules**\nThe implicit Newmark-$\\beta$ scheme updates displacement $x$ and velocity $v$ from time $t_n$ to $t_{n+1} = t_n + \\Delta t$ based on a weighted average of accelerations $a_n$ and $a_{n+1}$. The update rules are derived from truncated Taylor series expansions:\n$$\nx_{n+1} = x_n + v_n \\Delta t + \\left( \\left(\\frac{1}{2}-\\beta\\right)a_n + \\beta a_{n+1} \\right) \\Delta t^2\n$$\n$$\nv_{n+1} = v_n + \\left( (1-\\gamma)a_n + \\gamma a_{n+1} \\right) \\Delta t\n$$\nwhere $(\\beta, \\gamma)$ are the Newmark parameters. For numerical stability in linear systems, the conditions $2\\beta \\ge \\gamma \\ge 1/2$ are typically required. Algorithmic damping, which dissipates spurious high-frequency oscillations, is introduced when $\\gamma > 1/2$.\n\n**2. Discretized Implicit Equation of Motion**\nThe system's equation of motion at time $t_{n+1}$ is:\n$$\nm\\,a_{n+1} + c\\,v_{n+1} + k\\,x_{n+1} = f_{\\mathrm{ext}, n+1} + f_{\\mathrm{fr}, n+1}\n$$\nTo solve this implicit equation for the unknown acceleration $a_{n+1}$, we express $x_{n+1}$ and $v_{n+1}$ in terms of $a_{n+1}$ and known quantities at $t_n$. We define predictor quantities, $\\tilde{x}_{n+1}$ and $\\tilde{v}_{n+1}$:\n$$\n\\tilde{x}_{n+1} = x_n + v_n \\Delta t + \\left(\\frac{1}{2}-\\beta\\right)a_n \\Delta t^2\n$$\n$$\n\\tilde{v}_{n+1} = v_n + (1-\\gamma)a_n \\Delta t\n$$\nThe full updates are then:\n$$\nx_{n+1} = \\tilde{x}_{n+1} + \\beta \\Delta t^2 a_{n+1}\n$$\n$$\nv_{n+1} = \\tilde{v}_{n+1} + \\gamma \\Delta t a_{n+1}\n$$\nSubstituting these into the equation of motion and rearranging for $a_{n+1}$ yields:\n$$\n(m + c\\gamma\\Delta t + k\\beta\\Delta t^2) a_{n+1} = f_{\\mathrm{ext}, n+1} - c\\tilde{v}_{n+1} - k\\tilde{x}_{n+1} + f_{\\mathrm{fr}, n+1}\n$$\nLet's define the effective mass $m^* = m + c\\gamma\\Delta t + k\\beta\\Delta t^2$. The equation becomes:\n$$\nm^* a_{n+1} = f_{\\mathrm{res}, n+1} + f_{\\mathrm{fr}, n+1}\n$$\nwhere $f_{\\mathrm{res}, n+1} = f_{\\mathrm{ext}, n+1} - c\\tilde{v}_{n+1} - k\\tilde{x}_{n+1}$ is the residual force excluding the friction contribution.\n\n**3. Frictional Contact Algorithm (Return Mapping)**\nThe friction force $f_{\\mathrm{fr}, n+1}$ is also unknown. We use a trial-and-check (return mapping) procedure.\n\n*   **Trial Stick**: Assume the system is sticking at $t_{n+1}$, which imposes the kinematic constraint $v_{n+1} = v_b$. Using the velocity update rule, we can find the required acceleration, $a_{n+1}^{\\text{stick}}$:\n    $$\n    v_b = \\tilde{v}_{n+1} + \\gamma \\Delta t a_{n+1}^{\\text{stick}} \\implies a_{n+1}^{\\text{stick}} = \\frac{v_b - \\tilde{v}_{n+1}}{\\gamma \\Delta t}\n    $$\n    The corresponding friction force required to maintain this state, $\\lambda_{n+1}$, is found from the discretized equation of motion:\n    $$\n    \\lambda_{n+1} = m^* a_{n+1}^{\\text{stick}} - f_{\\mathrm{res}, n+1}\n    $$\n\n*   **Check Admissibility**: The stick assumption is valid only if the required static friction force is within the Coulomb limit: $|\\lambda_{n+1}| \\le \\mu N$.\n\n*   **Decision and Update**:\n    *   If $|\\lambda_{n+1}| \\le \\mu N$ (Stick): The assumption is correct. The final acceleration is $a_{n+1} = a_{n+1}^{\\text{stick}}$. The friction state is \"stick\".\n    *   If $|\\lambda_{n+1}| > \\mu N$ (Slip): The assumption is false. The system slips, and the friction force is at its kinetic limit, $f_{\\mathrm{fr}, n+1} = -\\mu N \\cdot \\mathrm{sign}(\\lambda_{n+1})$. The direction of slip is governed by the sign of the elastic predictor force $\\lambda_{n+1}$ that breaks the stick condition. The acceleration is then recalculated with this known friction force:\n        $$\n        a_{n+1}^{\\text{slip}} = \\frac{f_{\\mathrm{res}, n+1} - \\mu N \\cdot \\mathrm{sign}(\\lambda_{n+1})}{m^*}\n        $$\n        The final acceleration is $a_{n+1} = a_{n+1}^{\\text{slip}}$. The friction state is \"slip\".\n\nFinally, once the correct $a_{n+1}$ is determined, the velocity $v_{n+1}$ and displacement $x_{n+1}$ are updated using the Newmark kinematic rules.\n\n**4. Metric Computation**\n\n*   **Chatter Score ($C$)**: A state variable tracks the friction status at each time step (e.g., $0$ for stick, $1$ for positive slip, $-1$ for negative slip). We iterate through the time history, counting any change in this state from one step to the next (`state(n) != state(n-1)`). If such a toggle occurs and the relative velocity magnitude $|v_n-v_b|$ is below the threshold $\\varepsilon_r$, a chatter event is counted. The total count is normalized by the total number of simulation steps.\n\n*   **Amplitude Ratio ($R$)**: For each test case, a baseline simulation is also performed using the constant-average-acceleration method ($\\beta=1/4, \\gamma=1/2$) with the same time step. The steady-state displacement amplitude is calculated for both the test and baseline simulations by taking half the peak-to-trough displacement over the latter half of the simulation time. The ratio $R$ is the test amplitude divided by the baseline amplitude.\n\nThe combination of these two metrics allows for the classification of a Newmark parameter set as \"good\" if it successfully suppresses numerical chatter ($C \\le C_{\\max}$) without excessively damping the physical response of the system ($R \\ge R_{\\min}$).", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(m, k, c, mu, N, vb, A, omega, T, dt, beta, gamma):\n    \"\"\"\n    Simulates a single-degree-of-freedom system with Coulomb friction\n    using the implicit Newmark-beta method.\n    \"\"\"\n    num_steps = int(T / dt)\n    t_hist = np.linspace(0, T, num_steps + 1)\n    \n    x_hist = np.zeros(num_steps + 1)\n    v_hist = np.zeros(num_steps + 1)\n    a_hist = np.zeros(num_steps + 1)\n    # Friction state: 0=stick, 1=slip(v>vb), -1=slip(v<vb)\n    state_hist = np.zeros(num_steps + 1, dtype=int)\n    \n    # Initial conditions: x(0)=0, v(0)=0.\n    # From EOM at t=0, with f_ext(0)=0 and v(0)=vb=0,\n    # the system is sticking with a_0=0 and f_fr(0)=0.\n    x_hist[0] = 0.0\n    v_hist[0] = 0.0\n    a_hist[0] = 0.0\n    state_hist[0] = 0\n    \n    mu_N = mu * N\n    m_eff = m + c * gamma * dt + k * beta * dt**2\n\n    for n in range(num_steps):\n        # Known state at step n\n        x_n, v_n, a_n = x_hist[n], v_hist[n], a_hist[n]\n        t_np1 = t_hist[n+1]\n        \n        # Predictor terms for the next step n+1\n        v_tilde = v_n + (1 - gamma) * dt * a_n\n        x_tilde = x_n + dt * v_n + (0.5 - beta) * dt**2 * a_n\n        \n        f_ext_np1 = A * np.sin(omega * t_np1)\n        f_res = f_ext_np1 - c * v_tilde - k * x_tilde\n        \n        # --- Trial Stick ---\n        # Calculate acceleration required to enforce stick condition v[n+1] = vb\n        a_stick = (vb - v_tilde) / (gamma * dt)\n        \n        # Calculate corresponding friction force (Lagrange multiplier)\n        lambda_np1 = m_eff * a_stick - f_res\n\n        # --- Stick-Slip Check and Update ---\n        is_slip = abs(lambda_np1) > mu_N\n\n        if not is_slip:\n            # Stick is confirmed\n            a_hist[n+1] = a_stick\n        else:\n            # Slip occurs, calculate slip acceleration\n            slip_dir_force = -np.sign(lambda_np1)\n            f_fr = slip_dir_force * mu_N\n            a_hist[n+1] = (f_res + f_fr) / m_eff\n            \n        # --- Final Kinematic Update ---\n        a_np1 = a_hist[n+1]\n        v_hist[n+1] = v_tilde + gamma * dt * a_np1\n        x_hist[n+1] = x_tilde + beta * dt**2 * a_np1\n\n        # --- Log Friction State for Metrics ---\n        if not is_slip:\n            state_hist[n+1] = 0\n        else:\n            v_rel = v_hist[n+1] - vb\n            if v_rel > 1e-12: # Use a small tolerance for comparison\n                state_hist[n+1] = 1\n            elif v_rel < -1e-12:\n                state_hist[n+1] = -1\n            else: # Landed exactly on stick velocity\n                state_hist[n+1] = 0\n\n    return t_hist, x_hist, v_hist, a_hist, state_hist\n\ndef calculate_chatter_score(v_hist, state_hist, vb, eps_r, num_steps):\n    \"\"\"Calculates the normalized chatter score.\"\"\"\n    chatter_count = 0\n    for i in range(1, num_steps + 1):\n        if state_hist[i] != state_hist[i-1]:  # State toggle occurred\n            if abs(v_hist[i] - vb) < eps_r:\n                chatter_count += 1\n    return chatter_count / num_steps\n\ndef calculate_amplitude_ratio(x_hist_test, x_hist_base, num_steps):\n    \"\"\"Calculates the ratio of steady-state displacement amplitudes.\"\"\"\n    ss_start_index = num_steps // 2\n    \n    x_ss_test = x_hist_test[ss_start_index:]\n    amp_test = (np.max(x_ss_test) - np.min(x_ss_test)) / 2\n    \n    x_ss_base = x_hist_base[ss_start_index:]\n    amp_base = (np.max(x_ss_base) - np.min(x_ss_base)) / 2\n\n    if amp_base < 1e-9: # Avoid division by zero/small number\n        return 1.0 if amp_test < 1e-9 else np.inf\n\n    return amp_test / amp_base\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and classify Newmark parameter regimes.\n    \"\"\"\n    # Define physical parameters\n    m = 1.0\n    k = 1000.0\n    c = 1.0\n    mu = 0.3\n    N = 10.0\n    vb = 0.0\n    A = 50.0\n    omega = np.sqrt(k / m)\n    T = 5.0\n    \n    # Define metric and classification parameters\n    eps_r = 1e-3\n    C_max = 2e-2\n    R_min = 7e-1\n\n    # Define the test suite (beta, gamma, dt)\n    test_cases = [\n        (1/4, 1/2, 5e-3),\n        (0.30, 0.60, 5e-3),\n        (0.40, 0.80, 5e-3),\n        (0.28, 0.62, 2e-3),\n    ]\n\n    results = []\n    \n    for beta_test, gamma_test, dt in test_cases:\n        num_steps = int(T / dt)\n        \n        # Define baseline parameters for comparison\n        beta_base, gamma_base = 1/4, 1/2\n        \n        # Run baseline simulation for the current time step\n        _, x_base, _, _, _ = run_simulation(\n            m, k, c, mu, N, vb, A, omega, T, dt, beta_base, gamma_base\n        )\n        \n        # Run the test case simulation\n        _, x_test, v_test, _, state_test = run_simulation(\n            m, k, c, mu, N, vb, A, omega, T, dt, beta_test, gamma_test\n        )\n        \n        # --- Calculate Metrics ---\n        # 1. Chatter Score (C)\n        C = calculate_chatter_score(v_test, state_test, vb, eps_r, num_steps)\n        \n        # 2. Amplitude Ratio (R)\n        R = calculate_amplitude_ratio(x_test, x_base, num_steps)\n        \n        # --- Classify the Regime ---\n        is_good = (C <= C_max) and (R >= R_min)\n        results.append(is_good)\n\n    # Print the final result in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3573269"}, {"introduction": "Advanced computational solid mechanics involves coupling time integration with complex material models that include internal state variables, such as plasticity and damage. This practice explores such a composite integration scheme, where the Newmark-β method for the global mechanical balance is combined with a local update for the material state. The critical concept here [@problem_id:3573276] is the role of the consistent algorithmic tangent stiffness, $\\mathbf{K}_{\\text{alg}}$, which ensures numerical stability and rapid convergence. By analyzing systems with different material states—from elastic to perfectly plastic—you will gain insight into the conditions for unconditional stability in nonlinear, path-dependent dynamic systems.", "problem": "You are to formulate, analyze, and test a composite time-integration algorithm for small-strain dynamics with internal variables. The mechanical balance is integrated by the implicit Newmark-$\\beta$ family, while the internal variables are advanced by an operator split with a local update. Your tasks are to derive the scheme from first principles, prove unconditional stability under appropriate parameter choices and tangential coupling, and implement a test function that evaluates the stability through the spectral radius of the amplification matrix for a small set of representative cases.\n\nStart from the fundamental base: Newton’s second law of motion for a small-strain, linearized system,\n$$\n\\mathbf{M}\\,\\mathbf{a}(t) + \\mathbf{C}\\,\\mathbf{v}(t) + \\mathbf{K}(\\boldsymbol{\\alpha}(t))\\,\\mathbf{u}(t) = \\mathbf{f}(t),\n$$\nwhere $\\mathbf{u}$ is displacement, $\\mathbf{v} = \\dot{\\mathbf{u}}$ is velocity, $\\mathbf{a} = \\ddot{\\mathbf{u}}$ is acceleration, $\\mathbf{M}$ is the symmetric positive definite mass matrix, $\\mathbf{C}$ is a symmetric positive semidefinite damping matrix, $\\mathbf{K}(\\boldsymbol{\\alpha})$ is the (possibly state-dependent) symmetric tangent stiffness associated with internal variables $\\boldsymbol{\\alpha}$, and $\\mathbf{f}$ is external load. Consider a time step from $t_n$ to $t_{n+1} = t_n + \\Delta t$ with constant time step $\\Delta t > 0$, use the implicit Newmark-$\\beta$ family with parameters $\\beta$ and $\\gamma$, and assume the operator split updates $\\boldsymbol{\\alpha}$ locally at $t_{n+1}$, providing the consistent algorithmic tangent $\\mathbf{K}_{\\text{alg}} := \\partial \\mathbf{R}_{\\text{int}}/\\partial \\mathbf{u}$ evaluated at $t_{n+1}$, where $\\mathbf{R}_{\\text{int}}$ is the internal force vector. Assume zero external load, $\\mathbf{f}(t) \\equiv \\mathbf{0}$, for the purpose of the stability analysis.\n\nRequirements:\n- Derive the composite integrator that combines: mechanical equilibrium advanced by implicit Newmark-$\\beta$ with parameters $\\beta$ and $\\gamma$, and an operator-split update of the internal variables to compute the consistent algorithmic tangent $\\mathbf{K}_{\\text{alg}}$ used in the global mechanical solve at $t_{n+1}$. Do not use any pre-stated Newmark update formulas; instead, start from the Newmark-$\\beta$ kinematic definitions and Newton’s second law to obtain the linear system for the unknowns at $t_{n+1}$.\n- Prove that if the consistent algorithmic tangent $\\mathbf{K}_{\\text{alg}}$ is symmetric positive semidefinite and the damping matrix $\\mathbf{C}$ is symmetric positive semidefinite, then for parameter choices $\\beta \\ge \\frac{1}{4}$ and $\\gamma \\ge \\frac{1}{2}$, the scheme is unconditionally stable with respect to the time step $\\Delta t$ in the sense of energy boundedness for the homogeneous system (zero load). Your proof must proceed from Newton’s second law, the Newmark-$\\beta$ kinematic definitions, and an energy or norm argument, and it must articulate the role of the consistent tangent coupling.\n- Implement a function that, for a single-degree-of-freedom (Single Degree Of Freedom, SDOF) system with scalar mass $m$, damping $c$, and consistent algorithmic tangent stiffness $k_{\\text{alg}}$, constructs the linear amplification matrix that maps the state vector $[\\;u_n,\\;v_n,\\;a_n\\;]^T$ to $[\\;u_{n+1},\\;v_{n+1},\\;a_{n+1}\\;]^T$ under the implicit Newmark-$\\beta$ scheme with zero load. Use this to compute the spectral radius (the maximum magnitude of the eigenvalues) as a function of $(m,c,k_{\\text{alg}},\\Delta t,\\beta,\\gamma)$. The construction must follow directly from your derived Newmark relations and Newton’s second law without relying on any external formulas.\n\nAll quantities in this problem are nondimensional; no physical units are required.\n\nTest suite:\nUse the following four SDOF cases, each evaluated at three time steps $\\Delta t \\in \\{\\,10^{-3},\\,1,\\,10^{3}\\,\\}$, with $\\beta = \\frac{1}{4}$ and $\\gamma = \\frac{1}{2}$:\n\n- Elastic reference case: $m = 1$, $c = 0$, $k_{\\text{alg}} = 1000$.\n- Elastoplastic with linear isotropic hardening in a post-yield consistent tangent state: take $m = 1$, $c = 0$, elastic modulus surrogate $k_{\\mathrm{e}} = 1000$, hardening modulus surrogate $h = 500$, and use the well-known one-dimensional consistent tangent $k_{\\text{alg}} = \\dfrac{k_{\\mathrm{e}}\\,h}{k_{\\mathrm{e}} + h}$. This yields a reduced but positive $k_{\\text{alg}}$ suitable for stability testing.\n- Perfect plasticity in a fully plastic state: $m = 1$, $c = 0$, $k_{\\text{alg}} = 0$.\n- Damage-reduced stiffness with viscous damping: $m = 1$, $c = 5$, pristine stiffness $k_0 = 1000$, scalar damage $d = 0.7$, so $k_{\\text{alg}} = (1 - d)\\,k_0$.\n\nFor each case, compute the maximum spectral radius over the three $\\Delta t$ values. The final output of your program must be a single line containing a list with four floating-point numbers in order corresponding to the four test cases. The format must be exactly a comma-separated Python-style list, for example\n$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$,\nwith no additional text. There is no need to round the results.\n\nAngle units do not apply in this problem. Percentages must be expressed as decimals when applicable.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$).", "solution": "This problem addresses the formulation and stability analysis of a composite time integration scheme for nonlinear solid dynamics, where the mechanical balance is integrated via the implicit Newmark-$\\beta$ method and internal variables are updated through an operator split. The solution is structured into three parts: first, the derivation of the discrete linear system to be solved at each time step; second, a proof of unconditional stability under the specified conditions; and third, the formulation of the amplification matrix for spectral stability analysis of a single-degree-of-freedom (SDOF) system.\n\n**1. Derivation of the Composite Integrator**\n\nThe analysis begins with the semi-discretized equation of motion for a system undergoing small strains at time $t_{n+1}$:\n$$\n\\mathbf{M}\\,\\mathbf{a}_{n+1} + \\mathbf{C}\\,\\mathbf{v}_{n+1} + \\mathbf{R}_{\\text{int}}(\\mathbf{u}_{n+1}, \\boldsymbol{\\alpha}_{n+1}) = \\mathbf{f}_{n+1}\n$$\nwhere $\\mathbf{M}$ is the mass matrix, $\\mathbf{C}$ is the damping matrix, and $\\mathbf{R}_{\\text{int}}$ is the internal force vector, which is a function of the displacement $\\mathbf{u}_{n+1}$ and internal variables $\\boldsymbol{\\alpha}_{n+1}$. The external force vector is $\\mathbf{f}_{n+1}$. The variables $\\mathbf{a}_{n+1}$ and $\\mathbf{v}_{n+1}$ are the acceleration and velocity vectors at time $t_{n+1}$. The operator split implies that for a given displacement $\\mathbf{u}_{n+1}$, the internal variables $\\boldsymbol{\\alpha}_{n+1}$ (and thus $\\mathbf{R}_{\\text{int}}$) are determined by a local constitutive update.\n\nThe implicit Newmark-$\\beta$ method provides the kinematic relations between displacement, velocity, and acceleration. Starting from the state $(\\mathbf{u}_n, \\mathbf{v}_n, \\mathbf{a}_n)$ at time $t_n$, the state at $t_{n+1} = t_n + \\Delta t$ is given by:\n$$\n\\mathbf{u}_{n+1} = \\mathbf{u}_n + \\Delta t \\, \\mathbf{v}_n + \\Delta t^2 \\left( \\left(\\frac{1}{2}-\\beta\\right)\\mathbf{a}_n + \\beta \\mathbf{a}_{n+1} \\right) \\quad (1)\n$$\n$$\n\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\Delta t \\left( (1-\\gamma)\\mathbf{a}_n + \\gamma \\mathbf{a}_{n+1} \\right) \\quad (2)\n$$\nwhere $\\beta$ and $\\gamma$ are the Newmark parameters. To solve for the state at $t_{n+1}$, we must solve the equation of motion simultaneously with these kinematic updates. This generally results in a nonlinear algebraic system for the unknown displacement $\\mathbf{u}_{n+1}$, which is solved using an iterative procedure like the Newton-Raphson method. The problem asks for the linear system in this context.\n\nWe first express acceleration $\\mathbf{a}_{n+1}$ and velocity $\\mathbf{v}_{n+1}$ as functions of the unknown displacement $\\mathbf{u}_{n+1}$ and known quantities from step $n$. From eq. $(1)$:\n$$\n\\beta \\Delta t^2 \\mathbf{a}_{n+1} = \\mathbf{u}_{n+1} - \\left[ \\mathbf{u}_n + \\Delta t \\, \\mathbf{v}_n + \\Delta t^2 \\left(\\frac{1}{2}-\\beta\\right)\\mathbf{a}_n \\right]\n$$\nThis gives the update for acceleration:\n$$\n\\mathbf{a}_{n+1} = \\frac{1}{\\beta \\Delta t^2} (\\mathbf{u}_{n+1} - \\mathbf{u}_n) - \\frac{1}{\\beta \\Delta t} \\mathbf{v}_n - \\left(\\frac{1}{2\\beta}-1\\right) \\mathbf{a}_n \\quad (3)\n$$\nSubstituting eq. $(3)$ into eq. $(2)$ gives the update for velocity:\n$$\n\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\Delta t(1-\\gamma)\\mathbf{a}_n + \\gamma\\Delta t \\left[ \\frac{1}{\\beta \\Delta t^2} (\\mathbf{u}_{n+1} - \\mathbf{u}_n) - \\frac{1}{\\beta \\Delta t} \\mathbf{v}_n - \\left(\\frac{1}{2\\beta}-1\\right) \\mathbf{a}_n \\right]\n$$\n$$\n\\mathbf{v}_{n+1} = \\frac{\\gamma}{\\beta\\Delta t}(\\mathbf{u}_{n+1} - \\mathbf{u}_n) + (1-\\frac{\\gamma}{\\beta})\\mathbf{v}_n + \\Delta t\\left(1-\\gamma - \\frac{\\gamma}{2\\beta} + \\gamma\\right)\\mathbf{a}_n = \\frac{\\gamma}{\\beta\\Delta t}(\\mathbf{u}_{n+1} - \\mathbf{u}_n) + (1-\\frac{\\gamma}{\\beta})\\mathbf{v}_n + \\Delta t(1 - \\frac{\\gamma}{2\\beta})\\mathbf{a}_n \\quad (4)\n$$\nIn a Newton-Raphson scheme, we solve for a correction $\\Delta\\mathbf{u}$ to the current displacement guess $\\mathbf{u}_{n+1}^{(i)}$. The linearized system is $\\mathbf{K}_{\\text{eff}} \\Delta\\mathbf{u} = -\\mathbf{R}^{(i)}$, where $\\mathbf{R}^{(i)}$ is the residual at iteration $i$ and $\\mathbf{K}_{\\text{eff}}$ is the effective tangent stiffness matrix. The residual is $\\mathbf{R} = \\mathbf{M}\\mathbf{a}_{n+1} + \\mathbf{C}\\mathbf{v}_{n+1} + \\mathbf{R}_{\\text{int}}(\\mathbf{u}_{n+1}) - \\mathbf{f}_{n+1}$.\nThe effective stiffness is the Jacobian of the residual with respect to $\\mathbf{u}_{n+1}$:\n$$\n\\mathbf{K}_{\\text{eff}} = \\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{u}_{n+1}} = \\mathbf{M}\\frac{\\partial \\mathbf{a}_{n+1}}{\\partial \\mathbf{u}_{n+1}} + \\mathbf{C}\\frac{\\partial \\mathbf{v}_{n+1}}{\\partial \\mathbf{u}_{n+1}} + \\frac{\\partial \\mathbf{R}_{\\text{int}}}{\\partial \\mathbf{u}_{n+1}}\n$$\nFrom eqs. $(3)$ and $(4)$, we find the derivatives:\n$$\n\\frac{\\partial \\mathbf{a}_{n+1}}{\\partial \\mathbf{u}_{n+1}} = \\frac{1}{\\beta \\Delta t^2} \\mathbf{I} \\quad \\text{and} \\quad \\frac{\\partial \\mathbf{v}_{n+1}}{\\partial \\mathbf{u}_{n+1}} = \\frac{\\gamma}{\\beta \\Delta t} \\mathbf{I}\n$$\nThe term $\\frac{\\partial \\mathbf{R}_{\\text{int}}}{\\partial \\mathbf{u}_{n+1}}$ is precisely the definition of the consistent algorithmic tangent, $\\mathbf{K}_{\\text{alg}}$. Therefore, the linear system solved at each time step (or each Newton iteration) for the displacement $\\mathbf{u}_{n+1}$ (or its increment) is governed by the effective stiffness matrix:\n$$\n\\mathbf{K}_{\\text{eff}} = \\frac{1}{\\beta \\Delta t^2}\\mathbf{M} + \\frac{\\gamma}{\\beta \\Delta t}\\mathbf{C} + \\mathbf{K}_{\\text{alg}}\n$$\nThe full system is $\\mathbf{K}_{\\text{eff}} \\mathbf{u}_{n+1} = \\mathbf{f}_{\\text{eff}}$, where $\\mathbf{f}_{\\text{eff}}$ contains the external forces $\\mathbf{f}_{n+1}$ and all terms dependent on the state at $t_n$.\n\n**2. Proof of Unconditional Stability**\n\nUnconditional stability implies that for any time step size $\\Delta t > 0$, the total energy of the discrete system remains bounded for a homogeneous system ($\\mathbf{f}(t) \\equiv \\mathbf{0}$). The proof relies on showing that a discrete energy-like function is non-increasing. The conditions for this proof are $\\gamma \\ge 1/2$, $\\beta \\ge 1/4$, and that the damping matrix $\\mathbf{C}$ and the consistent algorithmic tangent $\\mathbf{K}_{\\text{alg}}$ are symmetric positive semidefinite. The latter implies that the internal force is derivable from a convex potential energy function $\\Pi(\\mathbf{u})$, i.e., $\\mathbf{R}_{\\text{int}} = \\partial \\Pi/\\partial \\mathbf{u}$ and $\\mathbf{K}_{\\text{alg}} = \\partial^2\\Pi/\\partial\\mathbf{u}^2 \\ge \\mathbf{0}$.\n\nThe proof strategy is to establish an energy balance over a single time step. The work done by the system of forces must balance the change in energy. The discrete equation of motion for the homogeneous system at $t_{n+1}$ is:\n$$\n\\mathbf{M}\\mathbf{a}_{n+1} + \\mathbf{C}\\mathbf{v}_{n+1} + \\mathbf{R}_{\\text{int}, n+1} = \\mathbf{0}\n$$\nTaking the dot product with the velocity increment $\\mathbf{v}_{n+1} - \\mathbf{v}_n$ and performing a term-by-term analysis (a process involving significant but standard algebraic manipulation of the Newmark relations) leads to a discrete energy balance of the form:\n$$\n(E_{k,n+1}+\\Pi_{n+1}) - (E_{k,n}+\\Pi_{n}) = -\\mathcal{D}_{\\text{phys}} - \\mathcal{D}_{\\text{alg}}\n$$\nwhere $E_{k,n} = \\frac{1}{2}\\mathbf{v}_n^T \\mathbf{M} \\mathbf{v}_n$ is the kinetic energy and $\\Pi_n$ is the stored potential energy at $t_n$. The term $\\mathcal{D}_{\\text{phys}}$ represents the physical energy dissipation due to the damping matrix $\\mathbf{C}$, and $\\mathcal{D}_{\\text{alg}}$ is the numerical dissipation arising from the algorithm. For the scheme to be stable, both dissipation terms must be non-negative.\n\nThe physical dissipation term, approximated over the step, can be shown to be of the form $\\mathcal{D}_{\\text{phys}} \\approx \\Delta t \\mathbf{v}_{n+1/2}^T \\mathbf{C} \\mathbf{v}_{n+1/2}$, which is non-negative since $\\mathbf{C}$ is positive semidefinite.\n\nThe crucial part is the numerical dissipation, which, after the aforementioned algebraic manipulation, can be expressed as:\n$$\n\\mathcal{D}_{\\text{alg}} = (\\gamma - 1/2) \\Delta t (\\mathbf{a}_{n+1} - \\mathbf{a}_n)^T \\mathbf{M} (\\mathbf{a}_{n+1} - \\mathbf{a}_n) + \\text{other terms} \n$$\nA more elegant formulation (due to Simo and Tarnow) defines a modified, algorithmically-consistent energy functional. The change in this functional is shown to be dissipated by terms that are manifestly non-negative under the given conditions. A key dissipation term is proportional to $(\\gamma - 1/2)$. For this term to be non-negative (as $\\mathbf{M}$ is positive definite), we must have $\\gamma \\ge 1/2$. The choice of $\\beta \\ge 1/4$ (specifically, $\\beta \\ge \\gamma/2$) ensures that no spurious energy is generated through the interaction of high-frequency modes, thereby preventing instabilities.\n\nThe assumption that $\\mathbf{K}_{\\text{alg}}$ is symmetric positive semidefinite is essential. It guarantees that the internal force field is conservative (or at least non-dissipative in a potential sense), allowing the use of a potential energy $\\Pi$ and satisfying the inequality $(\\mathbf{u}_{n+1}-\\mathbf{u}_n)^T \\mathbf{R}_{\\text{int},n+1} \\ge \\Pi_{n+1}-\\Pi_n$, which is a property of convex functions. This ensures that the work done by internal forces corresponds to a non-negative stored energy (or a bounded change), preventing artificial energy creation from the material model's algorithmic representation.\n\nIn summary, the conditions $\\gamma \\ge 1/2$ and $\\beta \\ge 1/4$, combined with symmetric positive semidefinite $\\mathbf{C}$ and $\\mathbf{K}_{\\text{alg}}$, guarantee that the total discrete energy of the system does not increase, proving unconditional stability.\n\n**3. Spectral Analysis of an SDOF System**\n\nFor a single-degree-of-freedom (SDOF) system with mass $m$, damping $c$, and algorithmic stiffness $k_{\\text{alg}}$, the state can be represented by the vector $\\mathbf{z}_n = [\\,u_n, v_n, a_n\\,]^T$. The integrator advances the state such that $\\mathbf{z}_{n+1} = \\mathbf{A}\\,\\mathbf{z}_n$, where $\\mathbf{A}$ is the amplification matrix. Stability requires that the spectral radius of this matrix, $\\rho(\\mathbf{A}) = \\max_i |\\lambda_i(\\mathbf{A})|$, be less than or equal to $1$.\n\nThe governing equations are:\n$$\nm a_{n+1} + c v_{n+1} + k_{\\text{alg}} u_{n+1} = 0 \\quad (5)\n$$\n$$\nu_{n+1} = u_n + \\Delta t v_n + \\Delta t^2 ( (1/2-\\beta)a_n + \\beta a_{n+1} ) \\quad (6)\n$$\n$$\nv_{n+1} = v_n + \\Delta t ( (1-\\gamma)a_n + \\gamma a_{n+1} ) \\quad (7)\n$$\nTo construct $\\mathbf{A}$, we express $u_{n+1}$, $v_{n+1}$, and $a_{n+1}$ as linear combinations of $u_n$, $v_n$, and $a_n$. We first solve for $a_{n+1}$. Substitute eqs. $(6)$ and $(7)$ into $(5)$:\n$$\nm a_{n+1} + c(v_n + \\Delta t (1-\\gamma)a_n + \\gamma\\Delta t a_{n+1}) + k_{\\text{alg}}(u_n + \\Delta t v_n + \\Delta t^2((1/2-\\beta)a_n + \\beta a_{n+1})) = 0\n$$\nGrouping terms by $a_{n+1}$ on the left-hand side:\n$$\n(m + c\\gamma\\Delta t + k_{\\text{alg}}\\beta\\Delta t^2) a_{n+1} = -k_{\\text{alg}} u_n - (c + k_{\\text{alg}}\\Delta t)v_n - (c\\Delta t(1-\\gamma) + k_{\\text{alg}}\\Delta t^2(1/2-\\beta))a_n\n$$\nLet $D = m + c\\gamma\\Delta t + k_{\\text{alg}}\\beta\\Delta t^2$. Since $m>0$ and all other parameters are non-negative, $D>0$.\n$$\na_{n+1} = \\frac{-k_{\\text{alg}}}{D} u_n - \\frac{c + k_{\\text{alg}}\\Delta t}{D} v_n - \\frac{c\\Delta t(1-\\gamma) + k_{\\text{alg}}\\Delta t^2(1/2-\\beta)}{D} a_n\n$$\nThis expression provides the third row of the amplification matrix $\\mathbf{A}$. The other two state variables, $v_{n+1}$ and $u_{n+1}$, can now be found by substituting this expression for $a_{n+1}$ back into eqs. $(7)$ and $(6)$, respectively. This yields the remaining rows of $\\mathbf{A}$:\n$$\n\\mathbf{A} = \n\\begin{pmatrix}\n1 + \\beta\\Delta t^2 A_{31} & \\Delta t + \\beta\\Delta t^2 A_{32} & \\Delta t^2(1/2-\\beta) + \\beta\\Delta t^2 A_{33} \\\\\n\\gamma\\Delta t A_{31} & 1 + \\gamma\\Delta t A_{32} & \\Delta t(1-\\gamma) + \\gamma\\Delta t A_{33} \\\\\nA_{31} & A_{32} & A_{33}\n\\end{pmatrix}\n$$\nwhere $A_{3j}$ are the coefficients of $u_n, v_n, a_n$ in the expression for $a_{n+1}$. Specifically:\n$A_{31} = -k_{\\text{alg}}/D$\n$A_{32} = -(c + k_{\\text{alg}}\\Delta t)/D$\n$A_{33} = -(c\\Delta t(1-\\gamma) + k_{\\text{alg}}\\Delta t^2(1/2-\\beta))/D$\n\nBy constructing this matrix for the given parameters and computing its eigenvalues, we can determine the spectral radius and thus numerically verify the stability properties of the scheme for the specified test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the maximum spectral radius for four SDOF test cases using the\n    implicit Newmark-beta method.\n    \"\"\"\n\n    def calculate_max_spectral_radius(m, c, k_alg, beta, gamma, time_steps):\n        \"\"\"\n        Calculates the maximum spectral radius of the amplification matrix over a\n        range of time steps.\n        \n        Args:\n            m (float): Mass.\n            c (float): Damping.\n            k_alg (float): Algorithmic tangent stiffness.\n            beta (float): Newmark parameter.\n            gamma (float): Newmark parameter.\n            time_steps (list of float): Time steps to evaluate.\n        \n        Returns:\n            float: The maximum spectral radius found.\n        \"\"\"\n        max_rho = 0.0\n\n        for dt in time_steps:\n            # Denominator of the expression for a_{n+1}\n            # This is always positive for m > 0, c, k_alg, beta, gamma >= 0, dt > 0.\n            D = m + c * gamma * dt + k_alg * beta * dt**2\n\n            # Initialize the 3x3 amplification matrix A that maps\n            # [u_n, v_n, a_n]^T to [u_{n+1}, v_{n+1}, a_{n+1}]^T.\n            # Use complex numbers to handle eigenvalues correctly.\n            A = np.zeros((3, 3), dtype=np.complex128)\n\n            # Coefficients for the third row of A (expression for a_{n+1})\n            # a_{n+1} = A[2,0]*u_n + A[2,1]*v_n + A[2,2]*a_n\n            A[2, 0] = -k_alg / D\n            A[2, 1] = -(c + k_alg * dt) / D\n            A[2, 2] = -(c * dt * (1 - gamma) + k_alg * dt**2 * (0.5 - beta)) / D\n\n            # Coefficients for the second row of A (expression for v_{n+1})\n            # v_{n+1} = v_n + dt*(1-gamma)*a_n + dt*gamma*a_{n+1}\n            A[1, 0] = gamma * dt * A[2, 0]\n            A[1, 1] = 1.0 + gamma * dt * A[2, 1]\n            A[1, 2] = dt * (1.0 - gamma) + gamma * dt * A[2, 2]\n\n            # Coefficients for the first row of A (expression for u_{n+1})\n            # u_{n+1} = u_n + dt*v_n + dt^2*(0.5-beta)*a_n + dt^2*beta*a_{n+1}\n            A[0, 0] = 1.0 + beta * dt**2 * A[2, 0]\n            A[0, 1] = dt + beta * dt**2 * A[2, 1]\n            A[0, 2] = dt**2 * (0.5 - beta) + beta * dt**2 * A[2, 2]\n\n            # Compute the spectral radius (maximum absolute eigenvalue)\n            eigenvalues = np.linalg.eigvals(A)\n            rho = np.max(np.abs(eigenvalues))\n            \n            # Update the maximum spectral radius found so far\n            if rho > max_rho:\n                max_rho = rho\n        \n        return max_rho\n\n    # Define common parameters for the test suite\n    beta_val = 0.25\n    gamma_val = 0.5\n    time_steps_eval = [1e-3, 1.0, 1e3]\n    \n    # Define the four SDOF test cases\n    # Case 1: Elastic reference\n    case1 = (1.0, 0.0, 1000.0)\n\n    # Case 2: Elastoplastic with linear hardening\n    k_e = 1000.0\n    h = 500.0\n    k_alg_2 = (k_e * h) / (k_e + h)\n    case2 = (1.0, 0.0, k_alg_2)\n\n    # Case 3: Perfect plasticity\n    case3 = (1.0, 0.0, 0.0)\n\n    # Case 4: Damage-reduced stiffness with damping\n    k0 = 1000.0\n    d = 0.7\n    k_alg_4 = (1.0 - d) * k0\n    case4 = (1.0, 5.0, k_alg_4)\n    \n    test_cases = [case1, case2, case3, case4]\n\n    results = []\n    for m_val, c_val, k_val in test_cases:\n        max_rho = calculate_max_spectral_radius(m_val, c_val, k_val, beta_val, gamma_val, time_steps_eval)\n        results.append(max_rho)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3573276"}]}