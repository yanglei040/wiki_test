{"hands_on_practices": [{"introduction": "The first step in applying Hamilton's principle to a continuous body is spatial discretization. This practice focuses on the kinetic energy term in the Lagrangian, demonstrating how its consistent discretization via the finite element method gives rise to the consistent mass matrix. By deriving this matrix from first principles and contrasting it with the computationally convenient lumped mass matrix, you will gain a deeper appreciation for the concept of variational consistency and its practical implications for the accuracy of dynamic simulations [@problem_id:3569540].", "problem": "Consider a single four-node bilinear quadrilateral finite element in the reference configuration, modeling a homogeneous, isotropic elastic solid undergoing small motions without external forces. The reference domain is the unit square with out-of-plane thickness, that is, $\\Omega_0 = \\{(X,Y) \\mid 0 \\leq X \\leq 1, \\ 0 \\leq Y \\leq 1\\}$ and thickness $t_0 = 0.01 \\ \\mathrm{m}$ in the third direction. The material has constant mass density $\\rho_0 = 7800 \\ \\mathrm{kg/m^3}$. Let a single Cartesian component of the displacement be discretized by the standard four-node bilinear shape functions\n$$\nN_1(X,Y) = (1 - X)(1 - Y), \\quad\nN_2(X,Y) = X(1 - Y), \\quad\nN_3(X,Y) = XY, \\quad\nN_4(X,Y) = (1 - X)Y,\n$$\nso that the discrete field is $u(X,Y,t) = \\sum_{i=1}^{4} N_i(X,Y) \\, q_i(t)$ with generalized coordinates $q_i(t)$.\n\nStarting from Hamilton’s principle for dynamics, derive the semidiscrete equations of motion for this element by using the exact kinetic energy integral over $\\Omega_0$ (with the given thickness) and obtain the consistent element mass matrix entries from first principles. Then, construct the diagonal lumped mass matrix by the row-sum technique, and explain, in terms of the semidiscrete energy arising from Hamilton’s principle, the consequence of mass lumping for energy conservation in the absence of external forces.\n\nFinally, for the nodal velocity vector $\\dot{\\boldsymbol{q}} = \\begin{pmatrix} 1 \\\\ 2 \\\\ 3 \\\\ 4 \\end{pmatrix} \\ \\mathrm{m/s}$, compute the scalar difference $\\Delta T = T_{\\text{consistent}} - T_{\\text{lumped}}$ between the kinetic energy obtained with the consistent mass matrix and that obtained with the lumped mass matrix. Round your answer to four significant figures. Express the final energy in Joules.", "solution": "Hamilton's principle states that for a conservative mechanical system, the variation of the action integral is zero, i.e., $\\delta \\int_{t_1}^{t_2} L \\, dt = 0$, where $L = T - V$ is the Lagrangian, $T$ is the kinetic energy, and $V$ is the potential energy. For the given elastic solid without external forces, the system is conservative.\n\nThe kinetic energy $T$ of the element is given by the integral of the kinetic energy density over its volume $\\Omega$:\n$$\nT = \\frac{1}{2} \\int_{\\Omega} \\rho \\dot{u}^2 \\, dV\n$$\nFor the reference configuration, this is $T = \\frac{1}{2} \\int_{\\Omega_0} \\rho_0 \\dot{u}^2 \\, dV_0$. The displacement field $u$ is a single Cartesian component, discretized using the shape functions $N_i$ and nodal degrees of freedom $q_i(t)$ as $u(X,Y,t) = \\sum_{i=1}^{4} N_i(X,Y) q_i(t)$. This can be written in matrix form as $u = \\mathbf{N}\\mathbf{q}$, where $\\mathbf{N} = \\begin{pmatrix} N_1 & N_2 & N_3 & N_4 \\end{pmatrix}$ and $\\mathbf{q} = \\begin{pmatrix} q_1 & q_2 & q_3 & q_4 \\end{pmatrix}^\\mathsf{T}$.\n\nThe velocity field is $\\dot{u} = \\mathbf{N}\\dot{\\mathbf{q}}$. Substituting this into the kinetic energy expression gives:\n$$\nT = \\frac{1}{2} \\int_{\\Omega_0} \\rho_0 (\\mathbf{N}\\dot{\\mathbf{q}})^{\\mathsf{T}} (\\mathbf{N}\\dot{\\mathbf{q}}) \\, dV_0 = \\frac{1}{2} \\int_{\\Omega_0} \\rho_0 \\dot{\\mathbf{q}}^{\\mathsf{T}} \\mathbf{N}^{\\mathsf{T}} \\mathbf{N} \\dot{\\mathbf{q}} \\, dV_0\n$$\nSince the nodal velocities $\\dot{\\mathbf{q}}$ are functions of time only and not of position, they can be factored out of the integral:\n$$\nT = \\frac{1}{2} \\dot{\\mathbf{q}}^{\\mathsf{T}} \\left( \\rho_0 \\int_{\\Omega_0} \\mathbf{N}^{\\mathsf{T}} \\mathbf{N} \\, dV_0 \\right) \\dot{\\mathbf{q}} = \\frac{1}{2} \\dot{\\mathbf{q}}^{\\mathsf{T}} \\mathbf{M} \\dot{\\mathbf{q}}\n$$\nwhere $\\mathbf{M} = \\rho_0 \\int_{\\Omega_0} \\mathbf{N}^{\\mathsf{T}} \\mathbf{N} \\, dV_0$ is the consistent element mass matrix.\n\nThe potential energy $V$ is the strain energy stored in the element, which can be expressed in quadratic form as $V = \\frac{1}{2} \\mathbf{q}^{\\mathsf{T}} \\mathbf{K} \\mathbf{q}$, where $\\mathbf{K}$ is the element stiffness matrix. The Lagrangian for the discrete system is $L = \\frac{1}{2} \\dot{\\mathbf{q}}^{\\mathsf{T}} \\mathbf{M} \\dot{\\mathbf{q}} - \\frac{1}{2} \\mathbf{q}^{\\mathsf{T}} \\mathbf{K} \\mathbf{q}$.\n\nApplying the Euler-Lagrange equations, $\\frac{d}{dt}\\left(\\frac{\\partial L}{\\partial \\dot{\\mathbf{q}}}\\right) - \\frac{\\partial L}{\\partial \\mathbf{q}} = \\mathbf{0}$, yields the semidiscrete equations of motion:\n$$\n\\mathbf{M} \\ddot{\\mathbf{q}} + \\mathbf{K} \\mathbf{q} = \\mathbf{0}\n$$\n\nNext, we compute the consistent mass matrix $\\mathbf{M}_{\\text{consistent}}$. The volume element is $dV_0 = t_0 \\, dX \\, dY$, where $t_0$ is the constant thickness. The domain of integration is the unit square in the $X-Y$ plane. The entries of the mass matrix are given by:\n$$\nM_{ij} = \\rho_0 t_0 \\int_{0}^{1} \\int_{0}^{1} N_i(X,Y) N_j(X,Y) \\, dX \\, dY\n$$\nDue to the product form of the shape functions, these integrals are separable. Let's compute the basis integrals:\n$\\int_0^1 (1-\\xi)^2 d\\xi = \\frac{1}{3}$, $\\int_0^1 \\xi^2 d\\xi = \\frac{1}{3}$, $\\int_0^1 \\xi(1-\\xi) d\\xi = \\frac{1}{6}$, $\\int_0^1 \\xi d\\xi = \\frac{1}{2}$, $\\int_0^1 (1-\\xi) d\\xi = \\frac{1}{2}$.\nFor example, for the diagonal term $M_{11}$:\n$M_{11} = \\rho_0 t_0 \\int_0^1 (1-X)^2 dX \\int_0^1 (1-Y)^2 dY = \\rho_0 t_0 (\\frac{1}{3})(\\frac{1}{3}) = \\frac{\\rho_0 t_0}{9}$.\nFor the off-diagonal term $M_{12}$:\n$M_{12} = \\rho_0 t_0 \\int_0^1 X(1-X) dX \\int_0^1 (1-Y)^2 dY = \\rho_0 t_0 (\\frac{1}{6})(\\frac{1}{3}) = \\frac{\\rho_0 t_0}{18}$.\nFor the off-diagonal term $M_{13}$:\n$M_{13} = \\rho_0 t_0 \\int_0^1 X(1-X) dX \\int_0^1 Y(1-Y) dY = \\rho_0 t_0 (\\frac{1}{6})(\\frac{1}{6}) = \\frac{\\rho_0 t_0}{36}$.\nBy symmetry and the structure of the shape functions, we can construct the full matrix. Let $c = \\rho_0 t_0 = 7800 \\frac{\\text{kg}}{\\text{m}^3} \\times 0.01 \\ \\text{m} = 78 \\ \\frac{\\text{kg}}{\\text{m}^2}$.\n$$\n\\mathbf{M}_{\\text{consistent}} = \\frac{c}{36} \\begin{pmatrix} 4 & 2 & 1 & 2 \\\\ 2 & 4 & 2 & 1 \\\\ 1 & 2 & 4 & 2 \\\\ 2 & 1 & 2 & 4 \\end{pmatrix} = \\frac{78}{36} \\begin{pmatrix} 4 & 2 & 1 & 2 \\\\ 2 & 4 & 2 & 1 \\\\ 1 & 2 & 4 & 2 \\\\ 2 & 1 & 2 & 4 \\end{pmatrix} = \\frac{13}{6} \\begin{pmatrix} 4 & 2 & 1 & 2 \\\\ 2 & 4 & 2 & 1 \\\\ 1 & 2 & 4 & 2 \\\\ 2 & 1 & 2 & 4 \\end{pmatrix}\n$$\nThe lumped mass matrix $\\mathbf{M}_{\\text{lumped}}$ is constructed using the row-sum technique, where each diagonal entry is the sum of all entries in the corresponding row of the consistent mass matrix, and all off-diagonal entries are zero.\n$M_{ii}^{\\text{lumped}} = \\sum_{j=1}^{4} M_{ij}^{\\text{consistent}}$.\nFor the first row: $\\sum_{j=1}^{4} M_{1j} = \\frac{13}{6}(4+2+1+2) = \\frac{13}{6}(9) = \\frac{39}{2} = 19.5$.\nDue to the symmetry of the element geometry and shape functions, all row sums are identical. The total mass of the element is $m = \\rho_0 t_0 \\times A = 78 \\times (1 \\times 1) = 78$ kg. The sum of the diagonal entries of the lumped matrix is $4 \\times 19.5 = 78$, so mass is conserved.\n$$\n\\mathbf{M}_{\\text{lumped}} = \\begin{pmatrix} 19.5 & 0 & 0 & 0 \\\\ 0 & 19.5 & 0 & 0 \\\\ 0 & 0 & 19.5 & 0 \\\\ 0 & 0 & 0 & 19.5 \\end{pmatrix} = 19.5 \\mathbf{I}\n$$\nwhere $\\mathbf{I}$ is the $4 \\times 4$ identity matrix.\n\nThe consequence of mass lumping for energy conservation:\nIn a conservative system, the total energy $E = T+V$ is constant. The semidiscrete equations of motion, $\\mathbf{M} \\ddot{\\mathbf{q}} + \\mathbf{K} \\mathbf{q} = \\mathbf{0}$, conserve the discrete total energy $E_{\\text{discrete}} = \\frac{1}{2} \\dot{\\mathbf{q}}^{\\mathsf{T}} \\mathbf{M} \\dot{\\mathbf{q}} + \\frac{1}{2} \\mathbf{q}^{\\mathsf{T}} \\mathbf{K} \\mathbf{q}$. This is because $\\frac{dE_{\\text{discrete}}}{dt} = \\dot{\\mathbf{q}}^{\\mathsf{T}}(\\mathbf{M}\\ddot{\\mathbf{q}} + \\mathbf{K}\\mathbf{q}) = \\dot{\\mathbf{q}}^{\\mathsf{T}}\\mathbf{0} = 0$. This conservation property holds for any symmetric mass matrix $\\mathbf{M}$, including both $\\mathbf{M}_{\\text{consistent}}$ and $\\mathbf{M}_{\\text{lumped}}$.\n\nHowever, the physical meaning of the conserved quantity changes. The consistent mass matrix $\\mathbf{M}_{\\text{consistent}}$ is derived directly from the kinetic energy integral of the interpolated field, $T_{\\text{consistent}} = \\frac{1}{2}\\int \\rho_0 (\\mathbf{N}\\dot{\\mathbf{q}})^2 dV_0$. Thus, $E_{\\text{consistent}} = T_{\\text{consistent}} + V$ is a consistent, discrete representation of the continuum energy.\nThe lumped mass matrix $\\mathbf{M}_{\\text{lumped}}$ is an ad-hoc approximation. While the resulting system conserves its own energy, $E_{\\text{lumped}} = T_{\\text{lumped}} + V$, the kinetic energy term $T_{\\text{lumped}} = \\frac{1}{2}\\dot{\\mathbf{q}}^{\\mathsf{T}}\\mathbf{M}_{\\text{lumped}}\\dot{\\mathbf{q}}$ is no longer the true kinetic energy of the velocity field defined by the shape functions. It corresponds to a simplified model of point masses at the nodes. Therefore, the consequence of mass lumping is not the violation of energy conservation for the resulting algebraic system, but the substitution of the variationally consistent energy expression with an approximate one, thereby altering the dynamic characteristics (e.g., natural frequencies) of the model.\n\nFinally, we compute the kinetic energy difference $\\Delta T = T_{\\text{consistent}} - T_{\\text{lumped}}$ for $\\dot{\\boldsymbol{q}} = \\begin{pmatrix}1 & 2 & 3 & 4\\end{pmatrix}^{\\mathsf{T}} \\ \\mathrm{m/s}$.\n$$\n\\Delta T = \\frac{1}{2} \\dot{\\mathbf{q}}^{\\mathsf{T}} \\mathbf{M}_{\\text{consistent}} \\dot{\\mathbf{q}} - \\frac{1}{2} \\dot{\\mathbf{q}}^{\\mathsf{T}} \\mathbf{M}_{\\text{lumped}} \\dot{\\mathbf{q}} = \\frac{1}{2} \\dot{\\mathbf{q}}^{\\mathsf{T}} (\\mathbf{M}_{\\text{consistent}} - \\mathbf{M}_{\\text{lumped}}) \\dot{\\mathbf{q}}\n$$\nLet's compute the difference matrix $\\mathbf{M}_{\\text{diff}} = \\mathbf{M}_{\\text{consistent}} - \\mathbf{M}_{\\text{lumped}}$.\n$M_{ii}^{\\text{lumped}} = \\frac{13}{6}(9) = \\frac{39}{2}$. The consistent matrix entries are scaled by $\\frac{13}{6}$.\n$\\mathbf{M}_{\\text{lumped}} = \\frac{13}{6} \\begin{pmatrix} 9 & 0 & 0 & 0 \\\\ 0 & 9 & 0 & 0 \\\\ 0 & 0 & 9 & 0 \\\\ 0 & 0 & 0 & 9 \\end{pmatrix}$.\n$$\n\\mathbf{M}_{\\text{diff}} = \\frac{13}{6} \\left( \\begin{pmatrix} 4 & 2 & 1 & 2 \\\\ 2 & 4 & 2 & 1 \\\\ 1 & 2 & 4 & 2 \\\\ 2 & 1 & 2 & 4 \\end{pmatrix} - \\begin{pmatrix} 9 & 0 & 0 & 0 \\\\ 0 & 9 & 0 & 0 \\\\ 0 & 0 & 9 & 0 \\\\ 0 & 0 & 0 & 9 \\end{pmatrix} \\right) = \\frac{13}{6} \\begin{pmatrix} -5 & 2 & 1 & 2 \\\\ 2 & -5 & 2 & 1 \\\\ 1 & 2 & -5 & 2 \\\\ 2 & 1 & 2 & -5 \\end{pmatrix}\n$$\nNow we compute the quadratic form $\\dot{\\mathbf{q}}^{\\mathsf{T}} \\mathbf{M}_{\\text{diff}} \\dot{\\mathbf{q}}$:\n$$\n\\mathbf{M}_{\\text{diff}} \\dot{\\mathbf{q}} = \\frac{13}{6} \\begin{pmatrix} -5 & 2 & 1 & 2 \\\\ 2 & -5 & 2 & 1 \\\\ 1 & 2 & -5 & 2 \\\\ 2 & 1 & 2 & -5 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 2 \\\\ 3 \\\\ 4 \\end{pmatrix} = \\frac{13}{6} \\begin{pmatrix} -5(1) + 2(2) + 1(3) + 2(4) \\\\ 2(1) - 5(2) + 2(3) + 1(4) \\\\ 1(1) + 2(2) - 5(3) + 2(4) \\\\ 2(1) + 1(2) + 2(3) - 5(4) \\end{pmatrix} = \\frac{13}{6} \\begin{pmatrix} 10 \\\\ 2 \\\\ -2 \\\\ -10 \\end{pmatrix}\n$$\n$$\n\\dot{\\mathbf{q}}^{\\mathsf{T}} (\\mathbf{M}_{\\text{diff}} \\dot{\\mathbf{q}}) = \\begin{pmatrix} 1 & 2 & 3 & 4 \\end{pmatrix} \\frac{13}{6} \\begin{pmatrix} 10 \\\\ 2 \\\\ -2 \\\\ -10 \\end{pmatrix} = \\frac{13}{6} (1(10) + 2(2) + 3(-2) + 4(-10))\n$$\n$$\n= \\frac{13}{6} (10 + 4 - 6 - 40) = \\frac{13}{6} (-32) = -\\frac{13 \\times 16}{3} = -\\frac{208}{3}\n$$\nThe energy difference is $\\Delta T = \\frac{1}{2} \\left(-\\frac{208}{3}\\right) = -\\frac{104}{3} \\approx -34.666...$ J.\nRounding to four significant figures, we get $\\Delta T = -34.67$ J.", "answer": "$$\n\\boxed{-34.67}\n$$", "id": "3569540"}, {"introduction": "Once a system is discretized in space, we must develop a time-stepping algorithm to evolve its dynamics. This exercise guides you through the construction of a variational integrator, a class of numerical methods derived directly from a discrete version of Hamilton's principle rather than from simple Taylor series approximations. By applying the principle of stationary action to a discrete Lagrangian, you will derive the celebrated Störmer-Verlet scheme, revealing how variational principles naturally lead to algorithms with excellent long-term stability and conservation properties [@problem_id:3569586].", "problem": "Consider a hyperelastic continuum body occupying a fixed reference configuration $\\Omega_{0}$ with material mass density $\\rho_{0}$. Let $d(X,t)$ denote the material displacement field. Introduce a uniform time grid $t_{n}=n h$ with time step $h>0$, and define the midpoint discrete Lagrangian over a single time step by\n$$\nL_{d}\\!\\left(d_{n},d_{n+1}\\right)=\\int_{\\Omega_{0}} \\tfrac{1}{2}\\,\\rho_{0}\\,\\left(\\tfrac{d_{n+1}-d_{n}}{h}\\right)\\!\\cdot\\!\\left(\\tfrac{d_{n+1}-d_{n}}{h}\\right)\\,dV \\;-\\; \\Psi\\!\\left(\\tfrac{d_{n+1}+d_{n}}{2}\\right).\n$$\nAssume there are no external forces. Perform a standard finite element (FE) spatial discretization with shape functions that interpolate the displacement field as $d(X,t)\\approx \\sum_{a} N_{a}(X)\\,d_{a}(t)$, leading to a vector of nodal unknowns $d_{n}\\in\\mathbb{R}^{N}$. Let the consistent mass matrix be\n$$\nM=\\int_{\\Omega_{0}}\\rho_{0}\\,N^{\\top}N\\,dV,\n$$\nand assume a linear elastic stored energy so that the discrete potential can be represented exactly as the quadratic form\n$$\n\\Psi(d)=\\tfrac{1}{2}\\,d^{\\top}K\\,d,\n$$\nwith a symmetric positive semidefinite stiffness matrix $K\\in\\mathbb{R}^{N\\times N}$. Using discrete Hamilton’s principle (stationarity of the discrete action sum), derive the fully discrete update map for the nodal displacement vector $d_{n+1}$ in terms of $d_{n}$ and $d_{n-1}$, expressed only in terms of $M$, $K$, and $h$. You may assume that the matrix to be inverted in the update is nonsingular.\n\nProvide your final answer as a single closed-form analytic expression for $d_{n+1}$ in terms of $d_{n}$, $d_{n-1}$, $M$, $K$, and $h$. No numerical evaluation is required, and no units are to be reported with the final expression.", "solution": "The solution proceeds by first expressing the discrete Lagrangian in terms of the nodal displacement vectors and the provided matrices, and then applying the discrete Hamilton's principle to find the equations of motion.\n\nFirst, we substitute the FE spatial discretization into the given discrete Lagrangian, $L_{d}\\!\\left(d_{n},d_{n+1}\\right)$. The displacement vector at time $t_n$ is denoted by the nodal vector $d_n$.\n\nThe first term in the Lagrangian is the discrete kinetic energy, $T_d$. Using the FE approximation $d(X, t_n) \\approx N(X)d_n$:\n$$\nT_d(d_n, d_{n+1}) = \\int_{\\Omega_{0}} \\tfrac{1}{2}\\,\\rho_{0}\\,\\left(\\frac{N d_{n+1}-N d_{n}}{h}\\right)^{\\top}\\left(\\frac{N d_{n+1}-N d_{n}}{h}\\right)\\,dV\n$$\n$$\nT_d(d_n, d_{n+1}) = \\frac{1}{2h^2} \\int_{\\Omega_{0}} \\rho_{0} (d_{n+1}-d_n)^{\\top} N^{\\top} N (d_{n+1}-d_n)\\,dV\n$$\nSince the nodal vectors $d_n$ and $d_{n+1}$ are independent of the spatial variable $X$, they can be moved outside the integral:\n$$\nT_d(d_n, d_{n+1}) = \\frac{1}{2h^2} (d_{n+1}-d_n)^{\\top} \\left(\\int_{\\Omega_{0}} \\rho_{0} N^{\\top} N \\,dV\\right) (d_{n+1}-d_n)\n$$\nSubstituting the definition of the consistent mass matrix $M$, we get:\n$$\nT_d(d_n, d_{n+1}) = \\frac{1}{2h^2} (d_{n+1}-d_n)^{\\top} M (d_{n+1}-d_n)\n$$\nThe second term in the Lagrangian is the negative of the potential energy, evaluated at the midpoint displacement $\\frac{d_{n+1}+d_n}{2}$. Given the quadratic form for the potential energy, $\\Psi(d) = \\frac{1}{2}d^{\\top}K d$, we have:\n$$\n\\Psi\\left(\\frac{d_{n+1}+d_{n}}{2}\\right) = \\frac{1}{2} \\left(\\frac{d_{n+1}+d_{n}}{2}\\right)^{\\top} K \\left(\\frac{d_{n+1}+d_{n}}{2}\\right) = \\frac{1}{8} (d_{n+1}+d_n)^{\\top} K (d_{n+1}+d_n)\n$$\nCombining these results, the fully discrete Lagrangian for a single time step is:\n$$\nL_d(d_n, d_{n+1}) = \\frac{1}{2h^2} (d_{n+1}-d_n)^{\\top} M (d_{n+1}-d_n) - \\frac{1}{8} (d_{n+1}+d_n)^{\\top} K (d_{n+1}+d_n)\n$$\nThe discrete action sum over a time interval is $S_d = \\sum_{n} L_d(d_n, d_{n+1})$. Discrete Hamilton's principle requires that the action be stationary with respect to variations in the path, i.e., $\\delta S_d = 0$. Considering variations $\\delta d_n$ at an arbitrary interior time step $t_n$ (which implies $\\delta d_k = 0$ at the endpoints of the time interval), the stationarity condition yields the discrete Euler-Lagrange equations. The nodal displacement vector $d_n$ appears in two consecutive Lagrangian terms: $L_d(d_{n-1}, d_n)$ and $L_d(d_n, d_{n+1})$. The stationarity condition with respect to $d_n$ is:\n$$\n\\frac{\\partial}{\\partial d_n} \\left( L_d(d_{n-1}, d_n) + L_d(d_n, d_{n+1}) \\right) = 0\n$$\nThis can be written as:\n$$\nD_2 L_d(d_{n-1}, d_n) + D_1 L_d(d_n, d_{n+1}) = 0\n$$\nwhere $D_1 L_d(x,y)$ denotes the partial derivative (gradient) of $L_d(x,y)$ with respect to its first argument $x$, and $D_2 L_d(x,y)$ denotes the partial derivative with respect to its second argument $y$.\n\nWe compute these derivatives. Using the matrix calculus identity $\\nabla_z (z^{\\top}A z) = 2Az$ for a symmetric matrix $A$:\nFor $L_d(x,y) = \\frac{1}{2h^2} (y-x)^{\\top} M (y-x) - \\frac{1}{8} (y+x)^{\\top} K (y+x)$:\nThe gradient with respect to the first argument $x$ is:\n$$\nD_1 L_d(x,y) = \\frac{\\partial L_d}{\\partial x} = \\frac{1}{2h^2} \\left( -2M(y-x) \\right) - \\frac{1}{8} \\left( 2K(y+x) \\right) = -\\frac{1}{h^2}M(y-x) - \\frac{1}{4}K(y+x)\n$$\nThe gradient with respect to the second argument $y$ is:\n$$\nD_2 L_d(x,y) = \\frac{\\partial L_d}{\\partial y} = \\frac{1}{2h^2} \\left( 2M(y-x) \\right) - \\frac{1}{8} \\left( 2K(y+x) \\right) = \\frac{1}{h^2}M(y-x) - \\frac{1}{4}K(y+x)\n$$\nNow we evaluate these for our discrete Euler-Lagrange equation:\n$$\nD_1 L_d(d_n, d_{n+1}) = -\\frac{1}{h^2}M(d_{n+1}-d_n) - \\frac{1}{4}K(d_{n+1}+d_n)\n$$\n$$\nD_2 L_d(d_{n-1}, d_n) = \\frac{1}{h^2}M(d_n-d_{n-1}) - \\frac{1}{4}K(d_n+d_{n-1})\n$$\nSubstituting these into the stationarity condition:\n$$\n\\left( \\frac{1}{h^2}M(d_n-d_{n-1}) - \\frac{1}{4}K(d_n+d_{n-1}) \\right) + \\left( -\\frac{1}{h^2}M(d_{n+1}-d_n) - \\frac{1}{4}K(d_{n+1}+d_n) \\right) = 0\n$$\nTo simplify and solve for $d_{n+1}$, we can multiply the entire equation by $h^2$:\n$$\nM(d_n-d_{n-1}) - \\frac{h^2}{4}K(d_n+d_{n-1}) - M(d_{n+1}-d_n) - \\frac{h^2}{4}K(d_{n+1}+d_n) = 0\n$$\nNow, we group terms by the displacement vectors $d_{n+1}$, $d_n$, and $d_{n-1}$:\n$$\n\\left(-M - \\frac{h^2}{4}K\\right)d_{n+1} + \\left(M - \\frac{h^2}{4}K + M - \\frac{h^2}{4}K\\right)d_n + \\left(-M - \\frac{h^2}{4}K\\right)d_{n-1} = 0\n$$\n$$\n-\\left(M + \\frac{h^2}{4}K\\right)d_{n+1} + \\left(2M - \\frac{h^2}{2}K\\right)d_n - \\left(M + \\frac{h^2}{4}K\\right)d_{n-1} = 0\n$$\nIsolating the term with $d_{n+1}$:\n$$\n\\left(M + \\frac{h^2}{4}K\\right)d_{n+1} = \\left(2M - \\frac{h^2}{2}K\\right)d_n - \\left(M + \\frac{h^2}{4}K\\right)d_{n-1}\n$$\nThe problem states that the matrix to be inverted is nonsingular. This matrix is $\\left(M + \\frac{h^2}{4}K\\right)$. Since $M$ is symmetric positive definite (for a non-degenerate mesh) and $K$ is symmetric positive semidefinite, their sum is symmetric positive definite and thus invertible. We can therefore left-multiply by its inverse to solve for $d_{n+1}$:\n$$\nd_{n+1} = \\left(M + \\frac{h^2}{4}K\\right)^{-1} \\left[ \\left(2M - \\frac{h^2}{2}K\\right)d_n - \\left(M + \\frac{h^2}{4}K\\right)d_{n-1} \\right]\n$$\nThis is the fully discrete update map for the nodal displacement vector.", "answer": "$$\n\\boxed{\\left(M + \\frac{h^{2}}{4}K\\right)^{-1} \\left[ \\left(2M - \\frac{h^{2}}{2}K\\right)d_{n} - \\left(M + \\frac{h^{2}}{4}K\\right)d_{n-1} \\right]}\n$$", "id": "3569586"}, {"introduction": "Theory comes to life through computation. This hands-on coding practice challenges you to implement and compare a variational integrator against a standard non-variational scheme for a nonlinear wave propagation problem. You will numerically verify the theoretical guarantees of variational integrators, such as the exact conservation of momentum, a direct consequence of the discrete Noether's theorem. This exercise provides tangible proof of the superior long-term fidelity of structure-preserving algorithms and solidifies the connection between the abstract principles of variational mechanics and the concrete behavior of numerical simulations [@problem_id:3569611].", "problem": "Consider a one-dimensional periodic lattice that approximates a hyperelastic bar. There are $N$ nodes with periodic indexing $i \\in \\{0,1,\\dots,N-1\\}$, nodal displacements $u_i(t)$, and nodal velocities $v_i(t) = \\dot{u}_i(t)$. The inter-nodal spacing is $h$, the nodal mass is $m$, and the bonds are nearest-neighbor with a hyperelastic stored energy per bond given by $w(e) = \\tfrac{1}{2} E e^2 + \\tfrac{1}{4} H e^4$, where $e$ is the engineering strain of a bond. The total potential energy is the sum over bonds, $V(u) = \\sum_{i=0}^{N-1} h\\, w(e_i)$, where $e_i = (u_{i+1} - u_i)/h$ with periodic wrap $u_N \\equiv u_0$. Assume $m = 1$ and $h = 1$ so that the semi-discrete equations of motion are $u_{tt} = f(u)$ with internal force $f(u) = -\\nabla V(u)$. The initial condition is a single Fourier mode displacement with zero initial velocity, $u_i(0) = A \\sin(k x_i)$, $v_i(0) = 0$, with $x_i = i h$ and wavenumber $k = 2\\pi m_k/(N h)$, where $m_k$ is an integer mode index. All angles must be treated in radians.\n\nYour task is to derive and implement two time integrators for this semi-discrete system starting from Hamilton’s principle of stationary action. The base principles you must use are: (i) the definition of kinetic energy $T = \\tfrac{1}{2}\\sum_i m v_i^2$, (ii) the hyperelastic stored energy $V(u)$ as above, (iii) the strong form $m u_{tt} = f(u)$ derived from the Euler–Lagrange equations, and (iv) the discrete Lagrangian construction associated with the midpoint rule for a variational integrator.\n\n1. Derive a time-stepping algorithm that results from applying the implicit midpoint discretization to the Hamiltonian form of the equations. This must be obtained by discretizing the action with a midpoint discrete Lagrangian and taking the discrete Euler–Lagrange equations. The method should update $(u_n, v_n)$ to $(u_{n+1}, v_{n+1})$ using quantities evaluated at temporal midpoints, and must be solved at each step by a consistent nonlinear solve. Explain how the discrete Noether theorem associated with spatial translation invariance implies a discrete linear momentum conservation law for this method.\n\n2. Derive a second-order explicit central-difference-type scheme directly from the strong form $u_{tt} = f(u)$ without using a discrete action. Articulate its update logic in terms of positions and velocities at integer times, using only forces evaluated at integer times. Do not introduce any artificial dissipation or filtering.\n\n3. Using both integrators, simulate the evolution of the lattice under the initial sinusoidal displacement (with zero initial velocity). Define the discrete total linear momentum at time step $n$ as $P_n = \\sum_{i=0}^{N-1} m v_i^n$. Define the phase of mode $m_k$ at time $t_n$ by projecting the displacement field onto the sine and cosine basis of that mode, i.e., compute $a_{\\sin}(t_n) = \\sum_{i=0}^{N-1} u_i(t_n) \\sin(k x_i)$ and $a_{\\cos}(t_n) = \\sum_{i=0}^{N-1} u_i(t_n) \\cos(k x_i)$, and define $\\phi(t_n) = \\operatorname{atan2}(a_{\\sin}(t_n), a_{\\cos}(t_n))$ in radians. For each test case below, take as “reference phase” the phase produced by the variational midpoint integrator integrated with a time step that is ten times smaller than the one used for the comparison in that test case, over the same physical duration.\n\n4. For each test case, compute the following four scalars:\n   - The absolute phase error in radians for the explicit central-difference scheme at the final time with respect to the reference phase, $|\\phi_{\\text{CD}}(T) - \\phi_{\\text{ref}}(T)|$, wrapped to the interval $[-\\pi,\\pi]$ before taking the absolute value.\n   - The maximum absolute deviation of total linear momentum over the simulation for the explicit central-difference scheme, $\\max_{0 \\le n \\le N_t} |P_n - P_0|$, where $N_t$ is the number of time steps and $P_0$ is the initial total momentum.\n   - The absolute phase error in radians at the final time for the variational midpoint integrator with the coarse time step used in the test case compared to the reference phase from the fine time step, again wrapped to $[-\\pi,\\pi]$ before taking the absolute value.\n   - The maximum absolute deviation of total linear momentum over the simulation for the variational midpoint integrator with the coarse time step.\n\n5. Use the following test suite. All quantities are dimensionless; angles must be computed in radians.\n   - Test case $1$: $N=32$, $E=1.0$, $H=1.0$, $A=10^{-3}$, $m_k=3$, $\\Delta t=0.4$, $T=20.0$.\n   - Test case $2$: $N=32$, $E=1.0$, $H=1.0$, $A=10^{-3}$, $m_k=3$, $\\Delta t=0.8$, $T=20.0$.\n   - Test case $3$: $N=32$, $E=1.0$, $H=5.0$, $A=2\\times 10^{-2}$, $m_k=5$, $\\Delta t=0.5$, $T=15.0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list of lists in the order of the test cases, where each inner list contains the four scalars specified above for that test case in the order given, for example, $[[\\text{cd\\_phase\\_err},\\text{cd\\_mom\\_drift},\\text{vmi\\_phase\\_err},\\text{vmi\\_mom\\_drift}],\\dots]$. No other text must be printed. All angles must be in radians. All outputs must be represented as floating-point numbers. The program must be self-contained and must not require any user input.", "solution": "The problem asks for the derivation, implementation, and comparison of two time integration schemes for a one-dimensional periodic hyperelastic bar, modeled as a discrete lattice of $N$ nodes. The solution is presented in three main parts: the derivation of the variational midpoint integrator, the derivation of the explicit central-difference scheme, and finally, the computational implementation and analysis. Throughout the derivation, we use the specified values of nodal mass $m=1$ and inter-nodal spacing $h=1$.\n\n**1. Derivation of the Variational Midpoint Integrator (VMI)**\n\nThe dynamics of the system are governed by the Lagrangian $L(u, \\dot{u}) = T(\\dot{u}) - V(u)$, where $u = \\{u_i\\}_{i=0}^{N-1}$ is the vector of nodal displacements. The kinetic energy $T$ and potential energy $V$ are given by:\n$$\nT(\\dot{u}) = \\frac{1}{2} \\sum_{i=0}^{N-1} m \\dot{u}_i^2 = \\frac{1}{2} \\sum_{i=0}^{N-1} \\dot{u}_i^2\n$$\n$$\nV(u) = \\sum_{i=0}^{N-1} h \\, w(e_i) = \\sum_{i=0}^{N-1} w(e_i)\n$$\nwhere the strain in bond $i$ is $e_i = (u_{i+1} - u_i)/h = u_{i+1} - u_i$ (with periodic index $u_N \\equiv u_0$), and the stored energy function is $w(e) = \\frac{1}{2} E e^2 + \\frac{1}{4} H e^4$. The equations of motion $m \\ddot{u} = -\\nabla V(u) = f(u)$ follow from the Euler-Lagrange equations.\n\nA variational integrator is derived from Hamilton's principle of stationary action, $S = \\int L(u(t), \\dot{u}(t)) dt$, by first discretizing the action and then applying the variational principle. We discretize time into steps of size $\\Delta t$, with $t_n = n \\Delta t$. The action is approximated as a sum $S_d = \\sum_n \\Delta t L_d(u_n, u_{n+1})$, where $L_d$ is the discrete Lagrangian. Following the problem's prescription, we use the midpoint rule to approximate the integral of the Lagrangian over one time step $[t_n, t_{n+1}]$:\n$$\nL_d(u_n, u_{n+1}) = L\\left(\\frac{u_n + u_{n+1}}{2}, \\frac{u_{n+1} - u_n}{\\Delta t}\\right) = T\\left(\\frac{u_{n+1} - u_n}{\\Delta t}\\right) - V\\left(\\frac{u_n + u_{n+1}}{2}\\right)\n$$\nThe principle of stationary discrete action, $\\delta S_d = 0$, for variations $\\delta u_n$ that vanish at the endpoints, leads to the discrete Euler-Lagrange (DEL) equations for each node $j$:\n$$\nD_2 L_d(u_{n-1}, u_n)_j + D_1 L_d(u_n, u_{n+1})_j = 0\n$$\nwhere $D_1$ and $D_2$ denote differentiation with respect to the first and second vector arguments of $L_d$. It can be shown that this variational principle is equivalent to applying the implicit midpoint rule to the Hamiltonian form of the equations of motion, $\\dot{u} = v$ and $\\dot{v} = m^{-1}f(u)$. This gives the following system of equations for the update from $(u_n, v_n)$ to $(u_{n+1}, v_{n+1})$:\n$$\n\\frac{u_{n+1} - u_n}{\\Delta t} = \\frac{v_n + v_{n+1}}{2}\n$$\n$$\nm \\frac{v_{n+1} - v_n}{\\Delta t} = f\\left(\\frac{u_n + u_{n+1}}{2}\\right)\n$$\nThis is a system of implicit equations for $u_{n+1}$ and $v_{n+1}$. We can combine them to obtain a single nonlinear vector equation for $u_{n+1}$. From the first equation, we express $v_{n+1}$ as $v_{n+1} = \\frac{2}{\\Delta t}(u_{n+1} - u_n) - v_n$. Substituting this into the second equation yields:\n$$\n\\frac{m}{\\Delta t} \\left( \\frac{2}{\\Delta t}(u_{n+1} - u_n) - v_n - v_n \\right) - f\\left(\\frac{u_n + u_{n+1}}{2}\\right) = 0\n$$\nRearranging gives the residual equation $G(u_{n+1}) = 0$, where:\n$$\nG(x) = \\frac{2m}{(\\Delta t)^2}(x - u_n) - \\frac{2m}{\\Delta t}v_n - f\\left(\\frac{u_n + x}{2}\\right)\n$$\nThis nonlinear system for $x=u_{n+1}$ must be solved at each time step, typically using a Newton-Raphson method.\n\n**Discrete Momentum Conservation:** The continuous Lagrangian $L$ is invariant under a uniform translation of all nodes, $u_i \\rightarrow u_i + c$. By Noether's theorem, this symmetry implies the conservation of total linear momentum, $P = \\sum_i m \\dot{u}_i$. The discrete Lagrangian $L_d$ is also invariant under this symmetry. The discrete version of Noether's theorem guarantees that a corresponding discrete quantity is exactly conserved by the integrator. Summing the second equation of the VMI update over all nodes $i$:\n$$\n\\sum_{i=0}^{N-1} m (v_{i,n+1} - v_{i,n}) = \\Delta t \\sum_{i=0}^{N-1} f_i\\left(\\frac{u_n + u_{n+1}}{2}\\right)\n$$\nThe total force $\\sum_i f_i$ is zero due to the periodic boundary conditions, as $f_i = \\sigma(e_i) - \\sigma(e_{i-1})$ where $\\sigma(e) = w'(e)$, leading to a telescoping sum that cancels to zero. Therefore, $\\sum_i m v_{i,n+1} = \\sum_i m v_{i,n}$. The total linear momentum $P_n = \\sum_i m v_{i,n}$ is exactly conserved at each step, up to floating-point precision.\n\n**2. Derivation of the Explicit Central Difference (CD) Scheme**\n\nThe second scheme is derived directly from the strong form of the equations of motion, $m \\ddot{u} = f(u)$. A common and effective second-order explicit method is the Velocity-Verlet algorithm. Its derivation proceeds from a Taylor expansion. The algorithm is as follows:\n\n1.  First, update the positions from time $t_n$ to $t_{n+1}$:\n    $$\n    u_{n+1} = u_n + v_n \\Delta t + \\frac{1}{2m} f(u_n) (\\Delta t)^2\n    $$\n2.  Next, compute the forces at the new position $u_{n+1}$:\n    $$ a_{n+1} = \\frac{1}{m} f(u_{n+1}) $$\n3.  Finally, update the velocities to time $t_{n+1}$:\n    $$\n    v_{n+1} = v_n + \\frac{\\Delta t}{2m} (f(u_n) + f(u_{n+1}))\n    $$\nThis scheme is explicit, computationally inexpensive, second-order accurate, and symplectic. Like the VMI, it also conserves total linear momentum exactly (up to machine precision), because the velocity update step implies $P_{n+1} - P_n = \\sum_i m(v_{i,n+1}-v_{i,n}) = \\frac{\\Delta t}{2}(\\sum_i f_i(u_n) + \\sum_i f_i(u_{n+1})) = 0+0=0$.\n\n**3. Computational Implementation Details**\n\nBoth integrators are implemented in Python.\n-   **Force and Jacobian:** A function is created to compute the force vector $f(u)$, where $f_j = (E e_j + H e_j^3) - (E e_{j-1} + H e_{j-1}^3)$ with $e_j = u_{j+1}-u_j$. The Jacobian of the force, $-\\nabla^2V$, is also needed for the VMI's Newton solver.\n-   **VMI Solver:** The implicit step of the VMI is solved using a Newton-Raphson method until the Euclidean norm of the residual vector falls below a small tolerance ($10^{-12}$).\n-   **Initial Conditions:** The simulation starts with the initial displacement $u_i(0) = A \\sin(k x_i)$ and zero initial velocity $v_i(0)=0$, where $x_i=i$ and $k=2\\pi m_k/N$.\n-   **Analysis:** For each test case, four quantities are computed:\n    1.  The reference phase $\\phi_{\\text{ref}}(T)$ is obtained by running the VMI with a time step $\\Delta t_{\\text{ref}} = \\Delta t/10$.\n    2.  The Central Difference (CD) scheme is run with the specified time step $\\Delta t$ to find its final phase $\\phi_{\\text{CD}}(T)$ and the maximum absolute momentum deviation.\n    3.  The VMI is run with the coarse time step $\\Delta t$ to find its final phase $\\phi_{\\text{VMI}}(T)$ and maximum momentum deviation.\n    4.  Phase errors $|\\phi(T) - \\phi_{\\text{ref}}(T)|$ are computed, with the difference wrapped to the interval $[-\\pi, \\pi]$ before taking the absolute value. The momentum deviations are also recorded.", "answer": "```python\nimport numpy as np\nimport scipy.linalg\n\ndef get_force(u, E, H):\n    \"\"\"Computes the internal force vector f(u).\"\"\"\n    # Strain e_i = u_{i+1} - u_i\n    e = np.roll(u, -1) - u\n    # Stress sigma(e) = w'(e) = E*e + H*e^3\n    sigma = E * e + H * e**3\n    # Force f_j = sigma(e_j) - sigma(e_{j-1})\n    f = sigma - np.roll(sigma, 1)\n    return f\n\ndef get_force_jacobian(u, E, H):\n    \"\"\"Computes the Jacobian of the internal force, Del(f) = -V''(u).\"\"\"\n    N = len(u)\n    # Strain e_i = u_{i+1} - u_i\n    e = np.roll(u, -1) - u\n    # sigma'(e) = E + 3*H*e^2\n    s_prime = E + 3 * H * e**2\n    \n    # Main diagonal: H_jj = -(s_prime_j + s_prime_{j-1})\n    diag_main = -s_prime - np.roll(s_prime, 1)\n    # Upper diagonal: H_{j,j+1} = s_prime_j\n    diag_upper = s_prime\n    # Lower diagonal: H_{j,j-1} = s_prime_{j-1}\n    diag_lower = np.roll(s_prime, 1)\n\n    # Construct the circulant tridiagonal matrix\n    J = np.diag(diag_main)\n    J += np.diag(diag_upper[:-1], k=1)\n    J += np.diag(diag_lower[1:], k=-1)\n    J[0, -1] = diag_lower[0]\n    J[-1, 0] = diag_upper[-1]\n    \n    return J\n\ndef step_cd(u, v, dt, m, E, H):\n    \"\"\"Performs one step of the explicit Central Difference (Velocity-Verlet) integrator.\"\"\"\n    a_n = get_force(u, E, H) / m\n    u_np1 = u + v * dt + 0.5 * a_n * dt**2\n    a_np1 = get_force(u_np1, E, H) / m\n    v_np1 = v + 0.5 * (a_n + a_np1) * dt\n    return u_np1, v_np1\n\ndef step_vmi(u, v, dt, m, E, H):\n    \"\"\"Performs one step of the Variational Midpoint Integrator.\"\"\"\n    N = len(u)\n    # Initial guess for u_{n+1} using explicit Euler\n    x = u + v * dt\n\n    # Newton-Raphson solver for the implicit equation\n    # G(x) = (2m/dt^2)(x - u_n) - (2m/dt)v_n - f((u_n+x)/2) = 0\n    max_iter = 10\n    tol = 1e-12\n    for _ in range(max_iter):\n        u_mid = (u + x) / 2.0\n        force_mid = get_force(u_mid, E, H)\n        \n        # Residual G(x)\n        G = (2.0 * m / dt**2) * (x - u) - (2.0 * m / dt) * v - force_mid\n        \n        if np.linalg.norm(G) < tol:\n            break\n        \n        # Jacobian J(x) = dG/dx = (2m/dt^2)I - 0.5*Del(f)(u_mid)\n        force_jac_mid = get_force_jacobian(u_mid, E, H)\n        J = (2.0 * m / dt**2) * np.eye(N) - 0.5 * force_jac_mid\n        \n        # Solve J*delta_x = -G and update\n        delta_x = scipy.linalg.solve(J, -G)\n        x += delta_x\n\n    u_np1 = x\n    # Update velocity\n    v_np1 = (2.0 / dt) * (u_np1 - u) - v\n    return u_np1, v_np1\n\ndef get_phase(u, k, x_nodes):\n    \"\"\"Computes the phase of the k-th Fourier mode.\"\"\"\n    kx = k * x_nodes\n    a_sin = np.sum(u * np.sin(kx))\n    a_cos = np.sum(u * np.cos(kx))\n    return np.arctan2(a_sin, a_cos)\n\ndef wrap_angle(angle):\n    \"\"\"Wraps an angle to the interval [-pi, pi].\"\"\"\n    return (angle + np.pi) % (2 * np.pi) - np.pi\n\ndef run_simulation(integrator_func, N, E, H, A, mk, dt, T, m, h):\n    \"\"\"Runs a simulation for a given integrator and returns final phase and momentum drift.\"\"\"\n    \n    k = 2.0 * np.pi * mk / (N * h)\n    x_nodes = np.arange(N) * h\n    \n    u = A * np.sin(k * x_nodes)\n    v = np.zeros(N)\n\n    # Initial momentum is zero\n    p_initial = np.sum(m * v)\n    max_mom_drift = 0.0\n    \n    num_steps = int(round(T / dt))\n    for n in range(num_steps):\n        u, v = integrator_func(u, v, dt, m, E, H)\n        p_current = np.sum(m * v)\n        mom_drift = np.abs(p_current - p_initial)\n        if mom_drift > max_mom_drift:\n            max_mom_drift = mom_drift\n            \n    final_phase = get_phase(u, k, x_nodes)\n    return final_phase, max_mom_drift\n\ndef solve():\n    test_cases = [\n        {'N': 32, 'E': 1.0, 'H': 1.0, 'A': 1e-3, 'mk': 3, 'dt': 0.4, 'T': 20.0},\n        {'N': 32, 'E': 1.0, 'H': 1.0, 'A': 1e-3, 'mk': 3, 'dt': 0.8, 'T': 20.0},\n        {'N': 32, 'E': 1.0, 'H': 5.0, 'A': 2e-2, 'mk': 5, 'dt': 0.5, 'T': 15.0},\n    ]\n\n    all_results = []\n    \n    m, h = 1.0, 1.0 # From problem statement\n\n    for case in test_cases:\n        N, E, H, A, mk, dt, T = case['N'], case['E'], case['H'], case['A'], case['mk'], case['dt'], case['T']\n        \n        # 1. Get reference phase from fine-step VMI\n        dt_ref = dt / 10.0\n        ref_phase, _ = run_simulation(step_vmi, N, E, H, A, mk, dt_ref, T, m, h)\n        \n        # 2. Run CD with coarse step\n        cd_phase, cd_mom_drift = run_simulation(step_cd, N, E, H, A, mk, dt, T, m, h)\n        \n        # 3. Run VMI with coarse step\n        vmi_phase, vmi_mom_drift = run_simulation(step_vmi, N, E, H, A, mk, dt, T, m, h)\n\n        # 4. Calculate errors\n        cd_phase_err = np.abs(wrap_angle(cd_phase - ref_phase))\n        vmi_phase_err = np.abs(wrap_angle(vmi_phase - ref_phase))\n\n        case_results = [cd_phase_err, cd_mom_drift, vmi_phase_err, vmi_mom_drift]\n        all_results.append(case_results)\n\n    # Format output as [[r1,r2,r3,r4],[...],...] with no spaces\n    result_strings = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3569611"}]}