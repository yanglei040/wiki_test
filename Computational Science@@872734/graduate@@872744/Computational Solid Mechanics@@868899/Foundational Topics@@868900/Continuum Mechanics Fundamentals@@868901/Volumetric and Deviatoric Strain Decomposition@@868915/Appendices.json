{"hands_on_practices": [{"introduction": "In computational solid mechanics, abstract tensor equations must be translated into concrete matrix and vector operations. This exercise provides practice in this crucial skill by deriving the matrix operator that projects a small strain tensor, represented in engineering Voigt notation, onto its deviatoric part. Mastering this conversion is fundamental for implementing constitutive models within finite element analysis (FEA) software. [@problem_id:3609739]", "problem": "Consider small-strain kinematics in three-dimensional ($3$D) computational solid mechanics. Let the symmetric infinitesimal strain tensor be denoted by $\\boldsymbol{\\varepsilon}$ with components $\\varepsilon_{ij}$, and recall the volumetricâ€“deviatoric decomposition defined by the fundamental relation $\\boldsymbol{\\varepsilon} = \\boldsymbol{\\varepsilon}^{\\text{dev}} + \\boldsymbol{\\varepsilon}^{\\text{vol}}$, where the volumetric part is given by $\\boldsymbol{\\varepsilon}^{\\text{vol}} = \\tfrac{1}{3} \\operatorname{tr}(\\boldsymbol{\\varepsilon}) \\boldsymbol{I}$ and the deviatoric part by $\\boldsymbol{\\varepsilon}^{\\text{dev}} = \\boldsymbol{\\varepsilon} - \\tfrac{1}{3} \\operatorname{tr}(\\boldsymbol{\\varepsilon}) \\boldsymbol{I}$. In three dimensions, adopt the engineering Voigt notation for strains, mapping $\\boldsymbol{\\varepsilon}$ to the $6 \\times 1$ strain vector $\\boldsymbol{e}$ as $\\boldsymbol{e} = [\\varepsilon_{11}, \\varepsilon_{22}, \\varepsilon_{33}, \\gamma_{23}, \\gamma_{13}, \\gamma_{12}]^{\\mathsf{T}}$ with $\\gamma_{ij} = 2 \\varepsilon_{ij}$ for $i \\neq j$. Using only these definitions and the linearity of the mapping between tensor and Voigt vector representations, derive the unique linear operator $\\mathbb{P}^{\\text{dev}}$ in Voigt form, represented as a $6 \\times 6$ matrix, such that $\\boldsymbol{e}^{\\text{dev}} = \\mathbb{P}^{\\text{dev}} \\boldsymbol{e}$ yields the engineering-Voigt vector of the deviatoric strain $\\boldsymbol{\\varepsilon}^{\\text{dev}}$. Provide the explicit $6 \\times 6$ matrix of $\\mathbb{P}^{\\text{dev}}$. Express your final answer as an exact matrix; no rounding is required and no physical units are involved.", "solution": "The problem statement is deemed valid as it is scientifically grounded, well-posed, and objective. It presents a standard derivation in continuum mechanics that is based on established definitions and is free from any contradictions or ambiguities.\n\nThe objective is to derive the $6 \\times 6$ matrix representation, $\\mathbb{P}^{\\text{dev}}$, of the linear operator that projects the engineering Voigt strain vector $\\boldsymbol{e}$ onto its deviatoric part $\\boldsymbol{e}^{\\text{dev}}$. The relationship is given by $\\boldsymbol{e}^{\\text{dev}} = \\mathbb{P}^{\\text{dev}} \\boldsymbol{e}$.\n\nThe derivation begins with the fundamental definition of the deviatoric strain tensor, $\\boldsymbol{\\varepsilon}^{\\text{dev}}$, in terms of the full strain tensor, $\\boldsymbol{\\varepsilon}$:\n$$\n\\boldsymbol{\\varepsilon}^{\\text{dev}} = \\boldsymbol{\\varepsilon} - \\boldsymbol{\\varepsilon}^{\\text{vol}}\n$$\nwhere $\\boldsymbol{\\varepsilon}^{\\text{vol}}$ is the volumetric part of the strain. The volumetric strain is defined as:\n$$\n\\boldsymbol{\\varepsilon}^{\\text{vol}} = \\frac{1}{3} \\operatorname{tr}(\\boldsymbol{\\varepsilon}) \\boldsymbol{I}\n$$\nHere, $\\operatorname{tr}(\\boldsymbol{\\varepsilon})$ is the trace of the strain tensor, and $\\boldsymbol{I}$ is the second-order identity tensor. The trace is the sum of the diagonal components:\n$$\n\\operatorname{tr}(\\boldsymbol{\\varepsilon}) = \\varepsilon_{11} + \\varepsilon_{22} + \\varepsilon_{33}\n$$\nSubstituting this into the definition for $\\boldsymbol{\\varepsilon}^{\\text{dev}}$, we obtain its component form:\n$$\n\\varepsilon_{ij}^{\\text{dev}} = \\varepsilon_{ij} - \\frac{1}{3} (\\varepsilon_{11} + \\varepsilon_{22} + \\varepsilon_{33}) \\delta_{ij}\n$$\nwhere $\\delta_{ij}$ is the Kronecker delta, which is $1$ if $i=j$ and $0$ if $i \\neq j$.\n\nWe now evaluate the components of $\\boldsymbol{\\varepsilon}^{\\text{dev}}$.\n\nFor the diagonal components ($i=j$):\n$$\n\\varepsilon_{11}^{\\text{dev}} = \\varepsilon_{11} - \\frac{1}{3}(\\varepsilon_{11} + \\varepsilon_{22} + \\varepsilon_{33}) = \\frac{2}{3}\\varepsilon_{11} - \\frac{1}{3}\\varepsilon_{22} - \\frac{1}{3}\\varepsilon_{33}\n$$\n$$\n\\varepsilon_{22}^{\\text{dev}} = \\varepsilon_{22} - \\frac{1}{3}(\\varepsilon_{11} + \\varepsilon_{22} + \\varepsilon_{33}) = -\\frac{1}{3}\\varepsilon_{11} + \\frac{2}{3}\\varepsilon_{22} - \\frac{1}{3}\\varepsilon_{33}\n$$\n$$\n\\varepsilon_{33}^{\\text{dev}} = \\varepsilon_{33} - \\frac{1}{3}(\\varepsilon_{11} + \\varepsilon_{22} + \\varepsilon_{33}) = -\\frac{1}{3}\\varepsilon_{11} - \\frac{1}{3}\\varepsilon_{22} + \\frac{2}{3}\\varepsilon_{33}\n$$\n\nFor the off-diagonal components ($i \\neq j$), the Kronecker delta $\\delta_{ij}$ is zero, so the second term vanishes:\n$$\n\\varepsilon_{ij}^{\\text{dev}} = \\varepsilon_{ij} - 0 = \\varepsilon_{ij}\n$$\nThis means $\\varepsilon_{23}^{\\text{dev}} = \\varepsilon_{23}$, $\\varepsilon_{13}^{\\text{dev}} = \\varepsilon_{13}$, and $\\varepsilon_{12}^{\\text{dev}} = \\varepsilon_{12}$.\n\nNext, we map these tensor components to the engineering Voigt strain vector notation. The full strain vector $\\boldsymbol{e}$ and the deviatoric strain vector $\\boldsymbol{e}^{\\text{dev}}$ are defined as:\n$$\n\\boldsymbol{e} = \\begin{pmatrix} \\varepsilon_{11} \\\\ \\varepsilon_{22} \\\\ \\varepsilon_{33} \\\\ \\gamma_{23} \\\\ \\gamma_{13} \\\\ \\gamma_{12} \\end{pmatrix} = \\begin{pmatrix} \\varepsilon_{11} \\\\ \\varepsilon_{22} \\\\ \\varepsilon_{33} \\\\ 2\\varepsilon_{23} \\\\ 2\\varepsilon_{13} \\\\ 2\\varepsilon_{12} \\end{pmatrix} \\quad \\text{and} \\quad \\boldsymbol{e}^{\\text{dev}} = \\begin{pmatrix} \\varepsilon_{11}^{\\text{dev}} \\\\ \\varepsilon_{22}^{\\text{dev}} \\\\ \\varepsilon_{33}^{\\text{dev}} \\\\ \\gamma_{23}^{\\text{dev}} \\\\ \\gamma_{13}^{\\text{dev}} \\\\ \\gamma_{12}^{\\text{dev}} \\end{pmatrix} = \\begin{pmatrix} \\varepsilon_{11}^{\\text{dev}} \\\\ \\varepsilon_{22}^{\\text{dev}} \\\\ \\varepsilon_{33}^{\\text{dev}} \\\\ 2\\varepsilon_{23}^{\\text{dev}} \\\\ 2\\varepsilon_{13}^{\\text{dev}} \\\\ 2\\varepsilon_{12}^{\\text{dev}} \\end{pmatrix}\n$$\nThe first three components of $\\boldsymbol{e}^{\\text{dev}}$ are the diagonal components of $\\boldsymbol{\\varepsilon}^{\\text{dev}}$ which we have already found in terms of the components of $\\boldsymbol{\\varepsilon}$. We can write them in terms of the first three components of $\\boldsymbol{e}$:\n$$\ne_1^{\\text{dev}} = \\varepsilon_{11}^{\\text{dev}} = \\frac{2}{3}e_1 - \\frac{1}{3}e_2 - \\frac{1}{3}e_3\n$$\n$$\ne_2^{\\text{dev}} = \\varepsilon_{22}^{\\text{dev}} = -\\frac{1}{3}e_1 + \\frac{2}{3}e_2 - \\frac{1}{3}e_3\n$$\n$$\ne_3^{\\text{dev}} = \\varepsilon_{33}^{\\text{dev}} = -\\frac{1}{3}e_1 - \\frac{1}{3}e_2 + \\frac{2}{3}e_3\n$$\nThe last three components of $\\boldsymbol{e}^{\\text{dev}}$ are the engineering shear strains. Using the fact that $\\varepsilon_{ij}^{\\text{dev}} = \\varepsilon_{ij}$ for $i \\neq j$:\n$$\ne_4^{\\text{dev}} = \\gamma_{23}^{\\text{dev}} = 2\\varepsilon_{23}^{\\text{dev}} = 2\\varepsilon_{23} = \\gamma_{23} = e_4\n$$\n$$\ne_5^{\\text{dev}} = \\gamma_{13}^{\\text{dev}} = 2\\varepsilon_{13}^{\\text{dev}} = 2\\varepsilon_{13} = \\gamma_{13} = e_5\n$$\n$$\ne_6^{\\text{dev}} = \\gamma_{12}^{\\text{dev}} = 2\\varepsilon_{12}^{\\text{dev}} = 2\\varepsilon_{12} = \\gamma_{12} = e_6\n$$\nWe now write these relationships in matrix form, $\\boldsymbol{e}^{\\text{dev}} = \\mathbb{P}^{\\text{dev}} \\boldsymbol{e}$:\n$$\n\\begin{pmatrix} e_1^{\\text{dev}} \\\\ e_2^{\\text{dev}} \\\\ e_3^{\\text{dev}} \\\\ e_4^{\\text{dev}} \\\\ e_5^{\\text{dev}} \\\\ e_6^{\\text{dev}} \\end{pmatrix} =\n\\begin{pmatrix}\n\\frac{2}{3}e_1 - \\frac{1}{3}e_2 - \\frac{1}{3}e_3 + 0e_4 + 0e_5 + 0e_6 \\\\\n-\\frac{1}{3}e_1 + \\frac{2}{3}e_2 - \\frac{1}{3}e_3 + 0e_4 + 0e_5 + 0e_6 \\\\\n-\\frac{1}{3}e_1 - \\frac{1}{3}e_2 + \\frac{2}{3}e_3 + 0e_4 + 0e_5 + 0e_6 \\\\\n0e_1 + 0e_2 + 0e_3 + 1e_4 + 0e_5 + 0e_6 \\\\\n0e_1 + 0e_2 + 0e_3 + 0e_4 + 1e_5 + 0e_6 \\\\\n0e_1 + 0e_2 + 0e_3 + 0e_4 + 0e_5 + 1e_6\n\\end{pmatrix}\n$$\nBy inspection, we extract the coefficients to form the matrix $\\mathbb{P}^{\\text{dev}}$:\n$$\n\\mathbb{P}^{\\text{dev}} =\n\\begin{pmatrix}\n\\frac{2}{3} & -\\frac{1}{3} & -\\frac{1}{3} & 0 & 0 & 0 \\\\\n-\\frac{1}{3} & \\frac{2}{3} & -\\frac{1}{3} & 0 & 0 & 0 \\\\\n-\\frac{1}{3} & -\\frac{1}{3} & \\frac{2}{3} & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 1 & 0 & 0 \\\\\n0 & 0 & 0 & 0 & 1 & 0 \\\\\n0 & 0 & 0 & 0 & 0 & 1\n\\end{pmatrix}\n$$\nThis matrix maps the normal strain components to their deviatoric counterparts while leaving the engineering shear strain components unchanged, consistent with the definition of deviatoric strain. It can be conveniently written in block form as:\n$$\n\\mathbb{P}^{\\text{dev}} = \\begin{pmatrix} \\mathbb{P}_{3 \\times 3}^{\\text{dev}} & \\boldsymbol{0}_{3 \\times 3} \\\\ \\boldsymbol{0}_{3 \\times 3} & \\boldsymbol{I}_{3 \\times 3} \\end{pmatrix}\n, \\quad \\text{where} \\quad\n\\mathbb{P}_{3 \\times 3}^{\\text{dev}} = \\frac{1}{3} \\begin{pmatrix} 2 & -1 & -1 \\\\ -1 & 2 & -1 \\\\ -1 & -1 & 2 \\end{pmatrix}\n$$\nThe resulting $6 \\times 6$ matrix is the required linear operator.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{2}{3} & -\\frac{1}{3} & -\\frac{1}{3} & 0 & 0 & 0 \\\\\n-\\frac{1}{3} & \\frac{2}{3} & -\\frac{1}{3} & 0 & 0 & 0 \\\\\n-\\frac{1}{3} & -\\frac{1}{3} & \\frac{2}{3} & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 1 & 0 & 0 \\\\\n0 & 0 & 0 & 0 & 1 & 0 \\\\\n0 & 0 & 0 & 0 & 0 & 1\n\\end{pmatrix}\n}\n$$", "id": "3609739"}, {"introduction": "When moving from small to large deformations, the simple additive split of strain is no longer sufficient, and we often turn to a multiplicative decomposition of the deformation gradient $\\boldsymbol{F}$. This practice focuses on implementing the widely used decomposition that separates the deformation into a purely volumetric part and a volume-preserving (isochoric) part. This exercise will guide you through creating a numerical algorithm to compute the isochoric mapping $\\bar{\\boldsymbol{F}} = J^{-1/3}\\boldsymbol{F}$, a cornerstone of many advanced material models. [@problem_id:3609735]", "problem": "You are given a three-dimensional continuum kinematics setting where a deformation is characterized by a deformation gradient matrix $ \\boldsymbol{F} \\in \\mathbb{R}^{3 \\times 3} $ with positive determinant $ J = \\det \\boldsymbol{F} > 0 $. In computational solid mechanics, a common multiplicative split separates the volumetric change from the isochoric (volume-preserving) part. Starting from fundamental definitions of the deformation gradient and its Jacobian determinant, derive an explicit expression for the volume-preserving mapping that factors out a scalar volumetric stretch so that the resulting isochoric part has unit determinant. Based on your derivation, design a robust numerical algorithm that, for each given input $ \\boldsymbol{F} $, computes an isochoric mapping $ \\bar{\\boldsymbol{F}} $ such that $ \\det \\bar{\\boldsymbol{F}} = 1 $ in exact arithmetic, and then verifies this numerically within a prescribed tolerance.\n\nYour program must implement the following tasks:\n\n1. From the fundamental base consisting of:\n   - The definition of the deformation gradient $ \\boldsymbol{F} $ as the spatial gradient of motion.\n   - The Jacobian determinant $ J = \\det \\boldsymbol{F} $ representing the local ratio of deformed to reference volume.\n   - A multiplicative decomposition into a scalar volumetric part and a volume-preserving isochoric part, where the volumetric part is restricted to be an isotropic scalar multiple of the identity and the isochoric part must satisfy the constraint of unit determinant.\n   derive the explicit expression for the isochoric mapping $ \\bar{\\boldsymbol{F}} $ in terms of $ \\boldsymbol{F} $ and $ J $ without assuming any special structure of $ \\boldsymbol{F} $ beyond $ J > 0 $.\n\n2. Specify a numerically stable algorithm to compute $ \\bar{\\boldsymbol{F}} $ for $ 3 \\times 3 $ inputs, including a discussion on handling very small or very large $ J $ while maintaining floating-point robustness. Your algorithm must:\n   - Compute $ J $ from $ \\boldsymbol{F} $ using a numerically stable determinant evaluation.\n   - Compute the scalar that factors out the volumetric stretch using a numerically stable cube root for $ J $.\n   - Form $ \\bar{\\boldsymbol{F}} $ by appropriately scaling $ \\boldsymbol{F} $ so that, in exact arithmetic, $ \\det \\bar{\\boldsymbol{F}} = 1 $.\n   - Verify numerically that $ \\left| \\det \\bar{\\boldsymbol{F}} - 1 \\right| \\le \\varepsilon $, with $ \\varepsilon = 10^{-9} $.\n\n3. Implement your algorithm in code and apply it to the following test suite of input deformation gradients. Each $ \\boldsymbol{F}^{(k)} $ is a $ 3 \\times 3 $ real matrix with positive determinant:\n   - Test $ 1 $ (identity): $ \\boldsymbol{F}^{(1)} = \\begin{bmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix} $.\n   - Test $ 2 $ (pure volumetric stretch): $ \\boldsymbol{F}^{(2)} = 2 \\, \\boldsymbol{I} = \\begin{bmatrix} 2 & 0 & 0 \\\\ 0 & 2 & 0 \\\\ 0 & 0 & 2 \\end{bmatrix} $.\n   - Test $ 3 $ (simple shear with unit determinant): $ \\boldsymbol{F}^{(3)} = \\begin{bmatrix} 1 & 0.3 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix} $.\n   - Test $ 4 $ (rotation about the $ z $-axis by angle $ \\theta $ followed by anisotropic stretch): let $ \\theta = \\pi/6 $ (in radians), $ \\boldsymbol{R}_z(\\theta) = \\begin{bmatrix} \\cos\\theta & -\\sin\\theta & 0 \\\\ \\sin\\theta & \\cos\\theta & 0 \\\\ 0 & 0 & 1 \\end{bmatrix} $, and $ \\boldsymbol{D} = \\operatorname{diag}(1.5,\\, 0.8,\\, 1.2) $. Use $ \\boldsymbol{F}^{(4)} = \\boldsymbol{R}_z(\\theta) \\, \\boldsymbol{D} $.\n   - Test $ 5 $ (highly anisotropic with small Jacobian): $ \\boldsymbol{F}^{(5)} = \\operatorname{diag}(10^{-3},\\, 1,\\, 1) $.\n   - Test $ 6 $ (upper-triangular nearly incompressible): $ \\boldsymbol{F}^{(6)} = \\begin{bmatrix} 1.02 & 0.01 & 0 \\\\ 0 & 0.98 & 0.02 \\\\ 0 & 0 & 1.01 \\end{bmatrix} $.\n\nYour program must, for each test case $ k \\in \\{1,2,3,4,5,6\\} $, output a boolean value indicating whether $ \\left| \\det \\bar{\\boldsymbol{F}}^{(k)} - 1 \\right| \\le \\varepsilon $ holds, with $ \\varepsilon = 10^{-9} $. The final output format must be a single line containing a comma-separated list of these boolean results enclosed in square brackets, for example $ [\\mathrm{True},\\mathrm{False},\\dots] $. No other text should be printed. Angles are to be interpreted in radians. No physical units are involved in this computation, as all quantities are nondimensional in this formulation.", "solution": "We begin from the definition of the deformation gradient $ \\boldsymbol{F} = \\dfrac{\\partial \\boldsymbol{x}}{\\partial \\boldsymbol{X}} \\in \\mathbb{R}^{3 \\times 3} $, which maps material line elements to spatial line elements. Its Jacobian determinant $ J = \\det \\boldsymbol{F} $ represents the local ratio of deformed to reference volume. In the multiplicative split of volumetric and isochoric deformation, we seek a decomposition into an isotropic volumetric stretch and a volume-preserving component,\n$$\n\\boldsymbol{F} = \\bar{\\boldsymbol{F}} \\, \\boldsymbol{F}_{\\mathrm{vol}},\n$$\nwhere $ \\boldsymbol{F}_{\\mathrm{vol}} = \\beta \\, \\boldsymbol{I} $ for some scalar $ \\beta > 0 $, and the isochoric part $ \\bar{\\boldsymbol{F}} $ is constrained by\n$$\n\\det \\bar{\\boldsymbol{F}} = 1.\n$$\nTaking determinants of both sides and using $ \\det(\\beta \\boldsymbol{I}) = \\beta^3 $ in three dimensions, we obtain\n$$\n\\det \\boldsymbol{F} = \\det \\bar{\\boldsymbol{F}} \\, \\det \\boldsymbol{F}_{\\mathrm{vol}} = 1 \\cdot \\beta^3,\n$$\nhence\n$$\n\\beta = J^{1/3}.\n$$\nSolving for the isochoric mapping gives\n$$\n\\bar{\\boldsymbol{F}} = \\boldsymbol{F} \\, \\boldsymbol{F}_{\\mathrm{vol}}^{-1} = \\boldsymbol{F} \\, (\\beta \\boldsymbol{I})^{-1} = \\beta^{-1} \\boldsymbol{F} = J^{-1/3} \\boldsymbol{F}.\n$$\nThis expression is unique given the isotropy of $ \\boldsymbol{F}_{\\mathrm{vol}} $ and the unit-determinant constraint on $ \\bar{\\boldsymbol{F}} $. The derivation relies solely on the fundamental definitions of $ \\boldsymbol{F} $, the Jacobian determinant, and the multiplicative split with an isotropic volumetric part.\n\nFor numerical computation, the algorithm proceeds as follows for each input $ \\boldsymbol{F} \\in \\mathbb{R}^{3 \\times 3} $:\n\n1. Compute the Jacobian $ J = \\det \\boldsymbol{F} $ using a numerically stable determinant routine. In practice, $ J $ can be computed via $ \\operatorname{LU} $ decomposition or a robust library routine. We assume double-precision floating-point arithmetic.\n\n2. Enforce the physical admissibility condition $ J > 0 $ to avoid non-physical inversions and to ensure a real cube root.\n\n3. Compute the volumetric scalar $ \\beta = J^{1/3} $ using a robust real cube root operation. Numerically, $ \\beta = \\operatorname{cbrt}(J) $ is preferred to avoid loss of significance for very small or large $ J $; equivalently, one may use $ \\beta = \\exp\\big( \\tfrac{1}{3} \\log J \\big) $ for improved stability if a cube root function is not available.\n\n4. Form the isochoric mapping by a scalar rescaling:\n$$\n\\bar{\\boldsymbol{F}} = \\beta^{-1} \\boldsymbol{F}.\n$$\n\n5. Verify the isochoric constraint numerically by evaluating $ \\det \\bar{\\boldsymbol{F}} $ and checking if $ \\left| \\det \\bar{\\boldsymbol{F}} - 1 \\right| \\le \\varepsilon $, with tolerance $ \\varepsilon = 10^{-9} $.\n\nNumerical considerations:\n\n- When $ J $ is very small but positive, $ \\beta $ will also be small, and $ \\beta^{-1} $ will be large. Since $ \\bar{\\boldsymbol{F}} $ is formed by a uniform scaling of $ \\boldsymbol{F} $, the determinant calculation for $ \\bar{\\boldsymbol{F}} $ remains well-conditioned relative to the determinant of $ \\boldsymbol{F} $, because $ \\det(\\bar{\\boldsymbol{F}}) = \\beta^{-3} \\det(\\boldsymbol{F}) = 1 $ in exact arithmetic. To minimize rounding errors in computing $ \\beta $, a direct cube root (or exponential-logarithm pair) is recommended.\n\n- For upper-triangular inputs, the determinant is the product of diagonal entries, which provides a straightforward check. For general inputs, reliable library routines for determinants (e.g., based on $ \\operatorname{LU} $ factorization) yield stable results.\n\nAlgorithmic steps summarized:\n\n- Input: $ \\boldsymbol{F} $.\n- Compute $ J = \\det \\boldsymbol{F} $; ensure $ J > 0 $.\n- Compute $ \\beta = \\operatorname{cbrt}(J) $ and the scaling $ s = \\beta^{-1} $.\n- Compute $ \\bar{\\boldsymbol{F}} = s \\, \\boldsymbol{F} $.\n- Evaluate $ d = \\det \\bar{\\boldsymbol{F}} $ and check $ \\left| d - 1 \\right| \\le \\varepsilon $.\n\nApplication to the test suite:\n\n- Test $ 1 $: $ \\boldsymbol{F}^{(1)} = \\boldsymbol{I} $ yields $ J = 1 $, $ \\beta = 1 $, $ \\bar{\\boldsymbol{F}} = \\boldsymbol{I} $, and $ \\det \\bar{\\boldsymbol{F}} = 1 $.\n\n- Test $ 2 $: $ \\boldsymbol{F}^{(2)} = 2 \\boldsymbol{I} $ yields $ J = 8 $, $ \\beta = 2 $, $ \\bar{\\boldsymbol{F}} = \\boldsymbol{I} $, and $ \\det \\bar{\\boldsymbol{F}} = 1 $.\n\n- Test $ 3 $: $ \\boldsymbol{F}^{(3)} $ is upper triangular with ones on the diagonal, so $ J = 1 $, $ \\beta = 1 $, $ \\bar{\\boldsymbol{F}} = \\boldsymbol{F}^{(3)} $, and $ \\det \\bar{\\boldsymbol{F}} = 1 $.\n\n- Test $ 4 $: $ \\boldsymbol{F}^{(4)} = \\boldsymbol{R}_z(\\theta) \\boldsymbol{D} $ has $ J = \\det \\boldsymbol{R}_z(\\theta) \\det \\boldsymbol{D} = 1 \\cdot (1.5 \\cdot 0.8 \\cdot 1.2) = 1.44 $, so $ \\beta = 1.44^{1/3} $, $ \\bar{\\boldsymbol{F}} = \\beta^{-1} \\boldsymbol{F}^{(4)} $, yielding $ \\det \\bar{\\boldsymbol{F}} = 1 $.\n\n- Test $ 5 $: $ \\boldsymbol{F}^{(5)} = \\operatorname{diag}(10^{-3}, 1, 1) $ gives $ J = 10^{-3} $, $ \\beta = 10^{-1} $, $ \\bar{\\boldsymbol{F}} = \\operatorname{diag}(10^{-3} \\cdot 10, 1 \\cdot 10, 1 \\cdot 10) $, so $ \\det \\bar{\\boldsymbol{F}} = (10^{-2}) \\cdot 10 \\cdot 10 = 1 $.\n\n- Test $ 6 $: $ \\boldsymbol{F}^{(6)} $ is upper triangular with diagonal entries $ 1.02 $, $ 0.98 $, $ 1.01 $, so $ J = 1.02 \\cdot 0.98 \\cdot 1.01 > 0 $, and the same scaling produces $ \\det \\bar{\\boldsymbol{F}} = 1 $ in exact arithmetic.\n\nThe program implements these steps, computes the boolean check $ \\left| \\det \\bar{\\boldsymbol{F}} - 1 \\right| \\le \\varepsilon $ for each test, and outputs a single line containing the list of boolean results in the specified format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef isochoric_map(F: np.ndarray, eps: float = 1e-9):\n    \"\"\"\n    Compute the isochoric part of the deformation gradient for a 3x3 matrix F:\n        Fbar = J^{-1/3} * F, where J = det(F) > 0,\n    and check whether det(Fbar) is within eps of 1.\n\n    Parameters\n    ----------\n    F : np.ndarray\n        A 3x3 deformation gradient with positive determinant.\n    eps : float\n        Tolerance for the determinant check.\n\n    Returns\n    -------\n    Fbar : np.ndarray\n        The isochoric part of F with det(Fbar) approximately equal to 1.\n    det_ok : bool\n        True if |det(Fbar) - 1| <= eps, False otherwise.\n    det_Fbar : float\n        The computed determinant of Fbar (for reference).\n    \"\"\"\n    # Compute Jacobian determinant\n    J = float(np.linalg.det(F))\n    if not np.isfinite(J) or J <= 0.0:\n        # Not physically admissible for this decomposition; return failure.\n        return np.full_like(F, np.nan), False, np.nan\n\n    # Compute the cube root using a robust function\n    beta = float(np.cbrt(J))  # volumetric stretch scalar\n    # Scaling factor to remove volumetric part\n    s = 1.0 / beta\n\n    # Form isochoric F\n    Fbar = s * F\n\n    # Verify isochoric constraint numerically\n    det_Fbar = float(np.linalg.det(Fbar))\n    det_ok = abs(det_Fbar - 1.0) <= eps\n\n    return Fbar, det_ok, det_Fbar\n\ndef build_test_suite():\n    # Test 1: Identity\n    F1 = np.eye(3)\n\n    # Test 2: Pure volumetric stretch 2*I\n    F2 = 2.0 * np.eye(3)\n\n    # Test 3: Simple shear with unit determinant\n    F3 = np.array([\n        [1.0, 0.3, 0.0],\n        [0.0, 1.0, 0.0],\n        [0.0, 0.0, 1.0]\n    ], dtype=float)\n\n    # Test 4: Rotation about z by theta then anisotropic stretch\n    theta = np.pi / 6.0  # radians\n    Rz = np.array([\n        [np.cos(theta), -np.sin(theta), 0.0],\n        [np.sin(theta),  np.cos(theta), 0.0],\n        [0.0,            0.0,           1.0]\n    ], dtype=float)\n    D = np.diag([1.5, 0.8, 1.2])\n    F4 = Rz @ D\n\n    # Test 5: Highly anisotropic with small Jacobian\n    F5 = np.diag([1e-3, 1.0, 1.0])\n\n    # Test 6: Upper-triangular nearly incompressible\n    F6 = np.array([\n        [1.02, 0.01, 0.0],\n        [0.0,  0.98, 0.02],\n        [0.0,  0.0,  1.01]\n    ], dtype=float)\n\n    return [F1, F2, F3, F4, F5, F6]\n\ndef solve():\n    eps = 1e-9\n    test_cases = build_test_suite()\n    results = []\n    for F in test_cases:\n        _, det_ok, _ = isochoric_map(F, eps=eps)\n        results.append(det_ok)\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3609735"}, {"introduction": "The logarithmic strain, $\\boldsymbol{h} = \\ln \\boldsymbol{U}$, offers an elegant way to analyze large deformations, as its deviatoric part represents pure distortion. However, its computation via the spectral decomposition of the stretch tensor $\\boldsymbol{U}$ can be numerically unstable, especially when principal stretches are nearly equal. This advanced practice challenges you to implement a robust algorithm that computes the deviatoric logarithmic strain, $\\boldsymbol{h}^{\\mathrm{dev}}$, by incorporating a stabilization scheme for clustered eigenvalues, highlighting the practical considerations required for reliable scientific computing. [@problem_id:3609738]", "problem": "You are given a right stretch tensor from the polar decomposition in continuum mechanics, which is a symmetric positive-definite (SPD) tensor denoted by $\\boldsymbol{U} \\in \\mathbb{R}^{3 \\times 3}$. The aim is to compute the deviatoric part of the logarithmic (Hencky) strain, denoted by $\\boldsymbol{h}^{\\mathrm{dev}}$, using the eigendecomposition of $\\boldsymbol{U}$, and to design an algorithm that remains numerically stable when principal stretches are nearly equal.\n\nStart from fundamental definitions:\n- The logarithmic strain is defined as the principal matrix logarithm $\\boldsymbol{h} = \\log \\boldsymbol{U}$.\n- The deviatoric projection of any second-order tensor $\\boldsymbol{A}$ is given by $\\operatorname{dev}(\\boldsymbol{A}) = \\boldsymbol{A} - \\dfrac{1}{3}\\operatorname{tr}(\\boldsymbol{A}) \\boldsymbol{I}$, where $\\boldsymbol{I}$ is the identity tensor and $\\operatorname{tr}(\\cdot)$ denotes the trace operator.\n\nUsing only the spectral theorem for real symmetric matrices and these definitions as the fundamental base, derive from first principles an algorithm that computes $\\boldsymbol{h}^{\\mathrm{dev}}$ from $\\boldsymbol{U}$ via its eigendecomposition $\\boldsymbol{U} = \\boldsymbol{Q}\\,\\mathrm{diag}(\\lambda_1,\\lambda_2,\\lambda_3)\\,\\boldsymbol{Q}^\\mathsf{T}$, with $\\lambda_i > 0$ the principal stretches and $\\boldsymbol{Q}$ orthogonal. Your algorithm must explicitly address and mitigate numerical stability issues when two or more $\\lambda_i$ are nearly equal. In particular, incorporate a clustering tolerance $\\tau > 0$ so that eigenvalues within a relative gap less than or equal to $\\tau$ are treated as a cluster and assigned a common principal logarithmic stretch equal to the average of their logarithms, while their spectral projector is taken as the sum of the individual projectors. Then form $\\boldsymbol{h}$ from this clustered spectral representation and finally compute $\\boldsymbol{h}^{\\mathrm{dev}}$ by removing the volumetric part.\n\nImplementation requirements:\n- Design two computational paths:\n  - An \"exact spectral\" path that uses the eigendecomposition to compute $\\boldsymbol{h} = \\boldsymbol{Q}\\,\\mathrm{diag}(\\log \\lambda_1,\\log \\lambda_2,\\log \\lambda_3)\\,\\boldsymbol{Q}^\\mathsf{T}$ without clustering, and then $\\boldsymbol{h}^{\\mathrm{dev}}$ via the deviatoric projection.\n  - A \"stabilized spectral\" path that performs eigenvalue clustering with a user-specified tolerance $\\tau$ as described above before reconstructing $\\boldsymbol{h}$, and then applies the deviatoric projection to obtain $\\boldsymbol{h}^{\\mathrm{dev}}$.\n- For both paths, ensure that the result is real-valued and symmetric to within floating-point rounding.\n- Angles, when used, must be in radians.\n\nTest suite and output specification:\n- Use the following five symmetric positive-definite test tensors (all entries are dimensionless). Let $\\boldsymbol{R}_z(\\theta)$ denote a rotation by angle $\\theta$ about the $z$-axis and $\\boldsymbol{R}_y(\\phi)$ a rotation by angle $\\phi$ about the $y$-axis. Use $\\theta = \\pi/4$ and $\\phi = 0.2$ (radians), and define $\\boldsymbol{Q} = \\boldsymbol{R}_z(\\theta)\\,\\boldsymbol{R}_y(\\phi)$.\n  1. $\\boldsymbol{U}_1 = \\mathrm{diag}(1.4,\\,1.1,\\,0.7)$.\n  2. $\\boldsymbol{U}_2 = \\boldsymbol{Q}^\\mathsf{T}\\,\\mathrm{diag}(1.5,\\,1.5,\\,0.8)\\,\\boldsymbol{Q}$.\n  3. $\\boldsymbol{U}_3 = \\mathrm{diag}(1.2,\\,1.2,\\,1.2)$.\n  4. $\\boldsymbol{U}_4 = \\mathrm{diag}(1.1,\\,1.100000001,\\,0.9)$.\n  5. $\\boldsymbol{U}_5 = \\mathrm{diag}(10^{-8},\\,1.0,\\,10^{8})$.\n- Use a clustering tolerance of $\\tau = 10^{-7}$.\n- For each $\\boldsymbol{U}_k$, compute the Frobenius norm of the difference between the stabilized and exact deviatoric logarithmic strains,\n  $$e_k = \\left\\|\\boldsymbol{h}^{\\mathrm{dev}}_{\\mathrm{stabilized}}(\\boldsymbol{U}_k;\\tau) - \\boldsymbol{h}^{\\mathrm{dev}}_{\\mathrm{exact}}(\\boldsymbol{U}_k)\\right\\|_{\\mathrm{F}},$$\n  where $\\|\\cdot\\|_{\\mathrm{F}}$ is the Frobenius norm.\n- Your program should produce a single line of output containing the five real numbers $e_1,\\ldots,e_5$ as a comma-separated list enclosed in square brackets, with no units, for example, $[x_1,x_2,x_3,x_4,x_5]$.\n\nYour task:\n- Provide a complete, runnable program that implements the above algorithm and computes the required output on the specified test suite. No user input is required. Ensure all intermediate computations adhere to the definitions provided and that numerical stability is addressed in the stabilized path via eigenvalue clustering.", "solution": "The problem requires the development and implementation of a numerically stable algorithm to compute the deviatoric part of the logarithmic strain tensor, $\\boldsymbol{h}^{\\mathrm{dev}}$, from the right stretch tensor $\\boldsymbol{U}$. The solution must be derived from first principles and must explicitly address numerical instabilities arising from nearly-repeated principal stretches (eigenvalues of $\\boldsymbol{U}$).\n\nFirst, we establish the mathematical framework based on the provided definitions. The right stretch tensor $\\boldsymbol{U}$ is a symmetric positive-definite (SPD) tensor in $\\mathbb{R}^{3 \\times 3}$. According to the spectral theorem for real symmetric matrices, $\\boldsymbol{U}$ can be decomposed as:\n$$ \\boldsymbol{U} = \\sum_{i=1}^{3} \\lambda_i (\\boldsymbol{q}_i \\otimes \\boldsymbol{q}_i) = \\boldsymbol{Q} \\boldsymbol{\\Lambda} \\boldsymbol{Q}^\\mathsf{T} $$\nwhere $\\lambda_i > 0$ are the eigenvalues of $\\boldsymbol{U}$, known as the principal stretches, and $\\boldsymbol{q}_i$ are the corresponding orthonormal eigenvectors, forming the columns of the orthogonal matrix $\\boldsymbol{Q}$. The tensor $\\boldsymbol{\\Lambda}$ is a diagonal matrix of the eigenvalues. The term $\\boldsymbol{P}_i = \\boldsymbol{q}_i \\otimes \\boldsymbol{q}_i$ represents the spectral projector onto the eigenspace of $\\lambda_i$.\n\nThe logarithmic strain tensor, or Hencky strain, $\\boldsymbol{h}$, is defined as the principal matrix logarithm of $\\boldsymbol{U}$. Applying the function on the spectrum of $\\boldsymbol{U}$ yields:\n$$ \\boldsymbol{h} = \\log(\\boldsymbol{U}) = \\sum_{i=1}^{3} \\log(\\lambda_i) \\boldsymbol{P}_i = \\boldsymbol{Q} \\mathrm{diag}(\\log\\lambda_1, \\log\\lambda_2, \\log\\lambda_3) \\boldsymbol{Q}^\\mathsf{T} $$\nWe denote the principal logarithmic strains as $h_i = \\log(\\lambda_i)$.\n\nThe deviatoric part of any second-order tensor $\\boldsymbol{A}$, denoted $\\operatorname{dev}(\\boldsymbol{A})$, is obtained by subtracting its isotropic (or spherical) part:\n$$ \\operatorname{dev}(\\boldsymbol{A}) = \\boldsymbol{A} - \\frac{1}{3}\\operatorname{tr}(\\boldsymbol{A}) \\boldsymbol{I} $$\nwhere $\\operatorname{tr}(\\cdot)$ is the trace operator and $\\boldsymbol{I}$ is the $3 \\times 3$ identity tensor.\n\nTo find the deviatoric logarithmic strain $\\boldsymbol{h}^{\\mathrm{dev}}$, we first compute the trace of $\\boldsymbol{h}$:\n$$ \\operatorname{tr}(\\boldsymbol{h}) = \\operatorname{tr}\\left(\\sum_{i=1}^{3} h_i \\boldsymbol{P}_i\\right) = \\sum_{i=1}^{3} h_i \\operatorname{tr}(\\boldsymbol{P}_i) $$\nThe trace of a rank-$1$ projector $\\boldsymbol{P}_i = \\boldsymbol{q}_i \\boldsymbol{q}_i^\\mathsf{T}$ is $\\operatorname{tr}(\\boldsymbol{q}_i \\boldsymbol{q}_i^\\mathsf{T}) = \\operatorname{tr}(\\boldsymbol{q}_i^\\mathsf{T} \\boldsymbol{q}_i) = \\operatorname{tr}(1) = 1$. Thus, the trace of $\\boldsymbol{h}$ is the sum of the principal logarithmic strains, which is the volumetric logarithmic strain $h_{\\mathrm{vol}}$:\n$$ \\operatorname{tr}(\\boldsymbol{h}) = \\sum_{i=1}^{3} h_i = \\log(\\lambda_1) + \\log(\\lambda_2) + \\log(\\lambda_3) = \\log(\\lambda_1 \\lambda_2 \\lambda_3) = \\log(\\det(\\boldsymbol{U})) $$\nThe deviatoric strain tensor is then:\n$$ \\boldsymbol{h}^{\\mathrm{dev}} = \\boldsymbol{h} - \\frac{1}{3} h_{\\mathrm{vol}} \\boldsymbol{I} = \\boldsymbol{h} - \\frac{1}{3} \\left(\\sum_{i=1}^{3} h_i\\right) \\boldsymbol{I} $$\n\nTwo computational procedures are designed as per the problem requirements.\n\n**1. Exact Spectral Algorithm**\nThis path follows the derived formulas directly, without special handling for eigenvalue proximity.\n1.  Compute the eigendecomposition of $\\boldsymbol{U}$ to obtain eigenvalues $\\lambda_i$ and eigenvectors $\\boldsymbol{q}_i$ (as columns of $\\boldsymbol{Q}$).\n2.  Compute the principal logarithmic strains $h_i = \\log(\\lambda_i)$ for $i=1, 2, 3$.\n3.  Reconstruct the full logarithmic strain tensor $\\boldsymbol{h} = \\boldsymbol{Q} \\mathrm{diag}(h_1, h_2, h_3) \\boldsymbol{Q}^\\mathsf{T}$.\n4.  Compute the trace $\\operatorname{tr}(\\boldsymbol{h}) = h_1 + h_2 + h_3$.\n5.  Compute the deviatoric tensor $\\boldsymbol{h}^{\\mathrm{dev}}_{\\mathrm{exact}} = \\boldsymbol{h} - \\frac{1}{3}\\operatorname{tr}(\\boldsymbol{h})\\boldsymbol{I}$.\n\n**2. Stabilized Spectral Algorithm**\nThis path addresses numerical instabilities that occur when two or more eigenvalues $\\lambda_i$ are nearly equal. In such cases, the corresponding eigenvectors are not numerically stable, though the subspace they span is. The prescribed stabilization procedure regularizes the computation by averaging within clusters of close eigenvalues.\n1.  Compute the eigendecomposition of $\\boldsymbol{U}$ to obtain sorted eigenvalues $\\lambda_1 \\le \\lambda_2 \\le \\lambda_3$ and eigenvectors $\\boldsymbol{Q}$.\n2.  Identify clusters of eigenvalues. A cluster is formed if the relative gap between adjacent eigenvalues is below a tolerance $\\tau$. For a pair $\\lambda_i, \\lambda_{i+1}$, the condition is $|\\lambda_{i+1} - \\lambda_i| / ((\\lambda_{i+1} + \\lambda_i)/2) \\le \\tau$. The clustering is transitive.\n3.  For each identified cluster $C_k = \\{\\lambda_j, ..., \\lambda_m\\}$, compute a common principal logarithmic stretch as the average of their individual logarithms:\n    $$ h_{C_k} = \\frac{1}{|C_k|} \\sum_{j \\in C_k} \\log(\\lambda_j) $$\n    For eigenvalues not in any cluster, their logarithmic strain is computed individually as $h_i = \\log(\\lambda_i)$.\n4.  Reconstruct the stabilized logarithmic strain tensor $\\boldsymbol{h}_{\\mathrm{stabilized}}$ using the (potentially averaged) principal logarithmic strains.\n    $$ \\boldsymbol{h}_{\\mathrm{stabilized}} = \\boldsymbol{Q} \\mathrm{diag}(h^{\\mathrm{stab}}_1, h^{\\mathrm{stab}}_2, h^{\\mathrm{stab}}_3) \\boldsymbol{Q}^\\mathsf{T} $$\n5.  Compute the trace $\\operatorname{tr}(\\boldsymbol{h}_{\\mathrm{stabilized}})$. Note that this procedure preserves the trace: $\\operatorname{tr}(\\boldsymbol{h}_{\\mathrm{stabilized}}) = \\sum_i h^{\\mathrm{stab}}_i = \\sum_i \\log(\\lambda_i) = \\operatorname{tr}(\\boldsymbol{h})$.\n6.  Compute the deviatoric tensor $\\boldsymbol{h}^{\\mathrm{dev}}_{\\mathrm{stabilized}} = \\boldsymbol{h}_{\\mathrm{stabilized}} - \\frac{1}{3}\\operatorname{tr}(\\boldsymbol{h}_{\\mathrm{stabilized}})\\boldsymbol{I}$.\n\nThe stabilization works by replacing the numerically sensitive computation involving individual projectors, e.g., $\\log(\\lambda_i)\\boldsymbol{P}_i + \\log(\\lambda_j)\\boldsymbol{P}_j$, with $\\frac{1}{2}(\\log\\lambda_i+\\log\\lambda_j)(\\boldsymbol{P}_i+\\boldsymbol{P}_j)$. The combined projector $\\boldsymbol{P}_i+\\boldsymbol{P}_j$ is stable even if $\\boldsymbol{P}_i$ and $\\boldsymbol{P}_j$ are not.\n\nFinally, the difference between the two approaches for each test case $\\boldsymbol{U}_k$ is quantified using the Frobenius norm of the difference between the resulting deviatoric tensors:\n$$ e_k = \\left\\|\\boldsymbol{h}^{\\mathrm{dev}}_{\\mathrm{stabilized}}(\\boldsymbol{U}_k;\\tau) - \\boldsymbol{h}^{\\mathrm{dev}}_{\\mathrm{exact}}(\\boldsymbol{U}_k)\\right\\|_{\\mathrm{F}} $$\nThe implementation will construct the five test tensors, compute $e_k$ for each, and report the results. To ensure symmetry in the face of floating-point inaccuracies, all computed strain tensors $\\boldsymbol{h}$ and $\\boldsymbol{h}^{\\mathrm{dev}}$ are explicitly symmetrized via the operation $\\boldsymbol{A} \\to \\frac{1}{2}(\\boldsymbol{A} + \\boldsymbol{A}^\\mathsf{T})$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_h_dev(U, stabilized, tau):\n    \"\"\"\n    Computes the deviatoric logarithmic strain tensor for a given stretch tensor U.\n\n    Args:\n        U (np.ndarray): The 3x3 symmetric positive-definite right stretch tensor.\n        stabilized (bool): If True, use the eigenvalue clustering stabilization.\n                           If False, use the direct 'exact' spectral method.\n        tau (float): The relative tolerance for eigenvalue clustering.\n\n    Returns:\n        np.ndarray: The 3x3 deviatoric logarithmic strain tensor.\n    \"\"\"\n    # For a real symmetric matrix U, eigh is the correct and robust choice.\n    # It returns eigenvalues sorted in ascending order and corresponding eigenvectors.\n    l, Q = np.linalg.eigh(U)\n\n    # The problem statement guarantees U is SPD, so all eigenvalues lambda_i are > 0.\n    # Thus, np.log(l) is well-defined.\n\n    # Compute principal logarithmic strains\n    h_prin = np.log(l)\n    \n    h_prin_to_use = h_prin.copy()\n    \n    if stabilized:\n        # Perform eigenvalue clustering on the sorted eigenvalues 'l'.\n        \n        # Check for proximity between adjacent eigenvalues\n        is_close_01 = abs(l[1] - l[0]) <= tau * (l[1] + l[0]) / 2.0\n        is_close_12 = abs(l[2] - l[1]) <= tau * (l[2] + l[1]) / 2.0\n        \n        if is_close_01 and is_close_12:\n            # Cluster of 3: all eigenvalues are close.\n            h_avg = np.mean(h_prin)\n            h_prin_to_use[:] = h_avg\n        elif is_close_01:\n            # Cluster of 2: eigenvalues at indices 0 and 1 are close.\n            h_avg = np.mean(h_prin[0:2])\n            h_prin_to_use[0:2] = h_avg\n        elif is_close_12:\n            # Cluster of 2: eigenvalues at indices 1 and 2 are close.\n            h_avg = np.mean(h_prin[1:3])\n            h_prin_to_use[1:3] = h_avg\n    \n    # Reconstruct the logarithmic strain tensor H from its spectral components\n    H = Q @ np.diag(h_prin_to_use) @ Q.T\n    \n    # Enforce symmetry to correct for any minor floating-point inaccuracies\n    H = (H + H.T) / 2.0\n    \n    # Compute the deviatoric part by removing the isotropic part\n    trace_H = np.trace(H)\n    H_dev = H - (1/3.0) * trace_H * np.eye(3)\n    \n    return H_dev\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run computations, and print the results.\n    \"\"\"\n    # Define constants as per the problem statement\n    theta = np.pi / 4.0\n    phi = 0.2\n    tau = 1e-7\n\n    # Construct the rotation matrix Q for test case U_2\n    c_th, s_th = np.cos(theta), np.sin(theta)\n    Rz = np.array([[c_th, -s_th, 0.0], \n                   [s_th,  c_th, 0.0], \n                   [0.0,   0.0, 1.0]])\n    \n    c_ph, s_ph = np.cos(phi), np.sin(phi)\n    Ry = np.array([[c_ph,  0.0, s_ph], \n                   [0.0,   1.0, 0.0], \n                   [-s_ph, 0.0, c_ph]])\n    \n    Q_for_U2 = Rz @ Ry\n\n    # Define the five symmetric positive-definite test tensors\n    test_cases = [\n        # U_1: Distinct eigenvalues\n        np.diag([1.4, 1.1, 0.7]),\n        \n        # U_2: Repeated eigenvalues, non-diagonal\n        Q_for_U2.T @ np.diag([1.5, 1.5, 0.8]) @ Q_for_U2,\n        \n        # U_3: All eigenvalues are identical (isotropic stretch)\n        np.diag([1.2, 1.2, 1.2]),\n        \n        # U_4: Nearly-repeated eigenvalues, to test clustering\n        np.diag([1.1, 1.100000001, 0.9]),\n        \n        # U_5: Eigenvalues with very large spread (ill-conditioned)\n        np.diag([1e-8, 1.0, 1e8])\n    ]\n\n    results = []\n    for U in test_cases:\n        # Compute the deviatoric log strain using the 'exact' method\n        h_dev_exact = compute_h_dev(U, stabilized=False, tau=None)\n        \n        # Compute the deviatoric log strain using the 'stabilized' method\n        h_dev_stab = compute_h_dev(U, stabilized=True, tau=tau)\n        \n        # Calculate the Frobenius norm of the difference between the two results\n        error = np.linalg.norm(h_dev_stab - h_dev_exact, 'fro')\n        results.append(error)\n\n    # Format and print the final output as a single list\n    print(f\"[{','.join([f'{r:.17e}' for r in results])}]\")\n\nsolve()\n```", "id": "3609738"}]}