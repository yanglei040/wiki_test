{"hands_on_practices": [{"introduction": "The deformation gradient, $\\mathbf{F}$, is the cornerstone of continuum mechanics, providing a local linear approximation of a deformation map. This exercise [@problem_id:3579908] challenges you to compute $\\mathbf{F}$ for a non-uniform shear and analyze its mathematical properties. By examining whether $\\mathbf{F}$ is symmetric, you will uncover its deep connection to the physical nature of the deformation, distinguishing between pure stretch and motions that involve local material rotation.", "problem": "Consider a body undergoing a deformation from a reference (material) configuration with material coordinates $\\boldsymbol{X} = (X_{1}, X_{2}, X_{3})$ to a current (spatial) configuration with spatial coordinates $\\boldsymbol{x} = (x_{1}, x_{2}, x_{3})$ described by the mapping $\\boldsymbol{\\varphi} : \\mathbb{R}^{3} \\to \\mathbb{R}^{3}$, where\n$$\n\\boldsymbol{\\varphi}(\\boldsymbol{X}) = \\left( X_{1} + \\kappa X_{2}^{2},\\, X_{2},\\, X_{3} \\right),\n$$\nand $\\kappa$ is a real constant parameter. Starting from the fundamental definition of the deformation gradient, compute the deformation gradient tensor $\\boldsymbol{F}(\\boldsymbol{X})$ in the material coordinates. Then, determine whether $\\boldsymbol{F}(\\boldsymbol{X})$ is symmetric for all $\\boldsymbol{X}$ and discuss the kinematic implications of your finding in terms of local rotation and stretch in the polar decomposition. Your reasoning must proceed from first principles: the meaning of a deformation map in computational solid mechanics and the definition of the deformation gradient as the material derivative of the map. Express your final answer as the exact analytic expression for $\\boldsymbol{F}(\\boldsymbol{X})$. No rounding is required, and no units should be included in the final expression.", "solution": "The solution proceeds from the fundamental definition of the deformation gradient tensor in continuum mechanics.\n\nThe deformation map $\\boldsymbol{x} = \\boldsymbol{\\varphi}(\\boldsymbol{X})$ relates the position of a material point $\\boldsymbol{X}$ in the reference configuration to its position $\\boldsymbol{x}$ in the current configuration. The components of this map are given as:\n$$\nx_{1}(\\boldsymbol{X}) = X_{1} + \\kappa X_{2}^{2} \\\\\nx_{2}(\\boldsymbol{X}) = X_{2} \\\\\nx_{3}(\\boldsymbol{X}) = X_{3}\n$$\nThe deformation gradient tensor, denoted by $\\boldsymbol{F}$, is defined as the material gradient of the deformation map $\\boldsymbol{\\varphi}$. It describes how an infinitesimal vector $d\\boldsymbol{X}$ in the reference configuration is mapped to an infinitesimal vector $d\\boldsymbol{x}$ in the current configuration, via the relation $d\\boldsymbol{x} = \\boldsymbol{F} d\\boldsymbol{X}$. The components of $\\boldsymbol{F}$ are given by the partial derivatives of the spatial coordinates with respect to the material coordinates:\n$$\nF_{ij} = \\frac{\\partial x_{i}}{\\partial X_{j}}\n$$\nwhere $i, j \\in \\{1, 2, 3\\}$. We now compute each of the nine components of the tensor $\\boldsymbol{F}(\\boldsymbol{X})$.\n\nFor the first row ($i=1$):\n$$\nF_{11} = \\frac{\\partial x_{1}}{\\partial X_{1}} = \\frac{\\partial}{\\partial X_{1}}(X_{1} + \\kappa X_{2}^{2}) = 1 \\\\\nF_{12} = \\frac{\\partial x_{1}}{\\partial X_{2}} = \\frac{\\partial}{\\partial X_{2}}(X_{1} + \\kappa X_{2}^{2}) = 2\\kappa X_{2} \\\\\nF_{13} = \\frac{\\partial x_{1}}{\\partial X_{3}} = \\frac{\\partial}{\\partial X_{3}}(X_{1} + \\kappa X_{2}^{2}) = 0\n$$\n\nFor the second row ($i=2$):\n$$\nF_{21} = \\frac{\\partial x_{2}}{\\partial X_{1}} = \\frac{\\partial}{\\partial X_{1}}(X_{2}) = 0 \\\\\nF_{22} = \\frac{\\partial x_{2}}{\\partial X_{2}} = \\frac{\\partial}{\\partial X_{2}}(X_{2}) = 1 \\\\\nF_{23} = \\frac{\\partial x_{2}}{\\partial X_{3}} = \\frac{\\partial}{\\partial X_{3}}(X_{2}) = 0\n$$\n\nFor the third row ($i=3$):\n$$\nF_{31} = \\frac{\\partial x_{3}}{\\partial X_{1}} = \\frac{\\partial}{\\partial X_{1}}(X_{3}) = 0 \\\\\nF_{32} = \\frac{\\partial x_{3}}{\\partial X_{2}} = \\frac{\\partial}{\\partial X_{2}}(X_{3}) = 0 \\\\\nF_{33} = \\frac{\\partial x_{3}}{\\partial X_{3}} = \\frac{\\partial}{\\partial X_{3}}(X_{3}) = 1\n$$\n\nAssembling these components into a matrix representation, the deformation gradient tensor is:\n$$\n\\boldsymbol{F}(\\boldsymbol{X}) = \\begin{pmatrix} 1 & 2\\kappa X_{2} & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\n\nNext, we must determine if $\\boldsymbol{F}(\\boldsymbol{X})$ is symmetric for all $\\boldsymbol{X}$. A tensor is symmetric if it is equal to its transpose, i.e., if $\\boldsymbol{F} = \\boldsymbol{F}^{T}$. The transpose of $\\boldsymbol{F}$ is:\n$$\n\\boldsymbol{F}^{T}(\\boldsymbol{X}) = \\begin{pmatrix} 1 & 0 & 0 \\\\ 2\\kappa X_{2} & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\nComparing $\\boldsymbol{F}$ and $\\boldsymbol{F}^{T}$, we see that $\\boldsymbol{F} = \\boldsymbol{F}^{T}$ if and only if $F_{12} = F_{21}$, $F_{13} = F_{31}$, and $F_{23} = F_{32}$. The second and third conditions are satisfied ($0=0$). However, the first condition requires $2\\kappa X_{2} = 0$. This equality holds for all $\\boldsymbol{X}$ only if the constant $\\kappa = 0$. If $\\kappa \\neq 0$, the equality holds only for material points on the plane $X_{2} = 0$. Since the problem asks if $\\boldsymbol{F}$ is symmetric for *all* $\\boldsymbol{X}$, the answer is no (assuming a non-trivial deformation where $\\kappa \\neq 0$).\n\nFinally, we discuss the kinematic implications. The polar decomposition theorem states that any invertible deformation gradient $\\boldsymbol{F}$ can be uniquely decomposed into the product of a rotation tensor $\\boldsymbol{R}$ and a symmetric, positive-definite right stretch tensor $\\boldsymbol{U}$, such that $\\boldsymbol{F} = \\boldsymbol{R}\\boldsymbol{U}$. The tensor $\\boldsymbol{U}$ describes the pure stretching and shearing of the material element from the reference configuration, while $\\boldsymbol{R}$ describes its subsequent rigid body rotation.\n\nIf the deformation gradient $\\boldsymbol{F}$ were symmetric, it would imply that $\\boldsymbol{F} = \\boldsymbol{U}$ and the rotation tensor $\\boldsymbol{R} = \\boldsymbol{I}$ (the identity tensor), assuming $\\boldsymbol{F}$ is also positive definite. A deformation where $\\boldsymbol{R} = \\boldsymbol{I}$ is known as a pure stretch, meaning the material element is stretched along its principal axes without any local rotation.\n\nIn this problem, $\\boldsymbol{F}$ is generally not symmetric. The non-symmetry of $\\boldsymbol{F}$ is a direct indication that the deformation is not a pure stretch. The rotation tensor $\\boldsymbol{R}$ will not be the identity tensor (unless $2\\kappa X_{2} = 0$). This means that, in general, a material element at a point $\\boldsymbol{X}$ undergoes both stretching (described by $\\boldsymbol{U}$) and a local rigid body rotation (described by $\\boldsymbol{R}$). The deformation described is a non-uniform simple shear, where the amount of shear in the $X_{1}$ direction is proportional to the square of the $X_2$ coordinate. Simple shear is a classic example of a motion that intrinsically involves rotation. The non-symmetry of the deformation gradient is the mathematical manifestation of this physical rotation.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1 & 2\\kappa X_{2} & 0 \\\\\n0 & 1 & 0 \\\\\n0 & 0 & 1\n\\end{pmatrix}\n}\n$$", "id": "3579908"}, {"introduction": "Building upon the static description of deformation, this practice [@problem_id:3579907] introduces the dimension of time to explore the kinematics of motion. You will derive and numerically verify the fundamental relationship connecting the rate of change of the deformation gradient, $\\dot{\\mathbf{F}}$, with gradients of the velocity field. This exercise is crucial for understanding how quantities are tracked and updated for a moving continuum, linking the material and spatial frames in a dynamic context.", "problem": "Consider a smooth motion map from a material configuration to a spatial configuration defined by the function $\\mathbf{x}(\\mathbf{X}, t)$, where $\\mathbf{X} \\in \\mathbb{R}^3$ denotes the material coordinates and $\\mathbf{x} \\in \\mathbb{R}^3$ denotes the spatial coordinates at time $t \\in \\mathbb{R}$. Let the deformation gradient be defined as $\\mathbf{F}(\\mathbf{X}, t)$ with entries given by the partial derivatives of $\\mathbf{x}$ with respect to $\\mathbf{X}$, and let the material velocity be $\\mathbf{v}(\\mathbf{X}, t)$ defined by the time derivative of $\\mathbf{x}$ at fixed $\\mathbf{X}$. Assume the motion map and its partial derivatives are continuous in all arguments so that differentiation can be interchanged.\n\nTask 1 (derivation):\n- Starting from the kinematic definition of the motion map and the deformation gradient, derive an expression for the material time derivative of the deformation gradient, expressed in terms of the material gradient of the velocity. The derivation must begin from the fundamental definitions of $\\mathbf{x}(\\mathbf{X}, t)$, $\\mathbf{F}(\\mathbf{X}, t)$, and $\\mathbf{v}(\\mathbf{X}, t)$.\n- Derive a relation connecting the material gradient of velocity and the spatial gradient of velocity through the deformation gradient. The derivation must begin from the fundamental definitions and use only standard chain-rule arguments in a scientifically realistic manner.\n\nTask 2 (implementation and comparison):\nImplement the derived expressions and compare them numerically on three kinematically distinct motions. For each motion, evaluate the following residuals at specified material points:\n- Residual A: the maximum absolute entrywise difference between the material time derivative of the deformation gradient and the material gradient of the velocity, evaluated at fixed $\\mathbf{X}$.\n- Residual B: the maximum absolute entrywise difference between the material gradient of velocity and the product of the spatial velocity gradient and the deformation gradient, evaluated at the same $\\mathbf{X}$.\n\nAll quantities are to be computed in consistent physical units with positions in meters ($\\mathrm m$), time in seconds ($\\mathrm s$), and angular rates in radians per second. The residuals must be reported in reciprocal seconds ($1/\\mathrm s$). Angles must be treated in radians.\n\nUse the following test suite, which spans a general case, a rigid-body boundary case, and an inhomogeneous edge case:\n\n- Test Case 1 (time-dependent simple shear):\n  - Motion: $\\mathbf{x}(\\mathbf{X}, t) = \\begin{bmatrix} X_1 + \\gamma(t) X_2 \\\\ X_2 \\\\ X_3 \\end{bmatrix}$ with $\\gamma(t) = t^2$ for $t = 0.5\\,\\mathrm s$.\n  - Material points (in $\\mathrm m$): $\\mathbf{X}^{(1)} = \\begin{bmatrix} 0.4 \\\\ -0.3 \\\\ 0.2 \\end{bmatrix}$, $\\mathbf{X}^{(2)} = \\begin{bmatrix} 1.0 \\\\ 0.0 \\\\ -0.5 \\end{bmatrix}$, $\\mathbf{X}^{(3)} = \\begin{bmatrix} 0.0 \\\\ 0.0 \\\\ 0.0 \\end{bmatrix}$.\n\n- Test Case 2 (planar rigid rotation about the $z$-axis):\n  - Motion: $\\mathbf{x}(\\mathbf{X}, t) = \\mathbf{R}(t)\\,\\mathbf{X}$, where $\\mathbf{R}(t)$ is the rotation of angle $\\theta(t) = \\omega t$ with angular rate $\\omega = 3.0\\,\\mathrm{rad}/\\mathrm s$ at $t = 0.2\\,\\mathrm s$.\n  - Material points (in $\\mathrm m$): $\\mathbf{X}^{(1)} = \\begin{bmatrix} 0.7 \\\\ 0.2 \\\\ 0.0 \\end{bmatrix}$, $\\mathbf{X}^{(2)} = \\begin{bmatrix} -0.5 \\\\ 1.0 \\\\ 0.3 \\end{bmatrix}$, $\\mathbf{X}^{(3)} = \\begin{bmatrix} 0.0 \\\\ 0.0 \\\\ 0.0 \\end{bmatrix}$.\n\n- Test Case 3 (inhomogeneous, time-dependent stretch-shear):\n  - Motion: $\\mathbf{x}(\\mathbf{X}, t) = \\begin{bmatrix} e^{\\alpha t} X_1 \\\\ \\left(1 + \\beta t X_1\\right) X_2 \\\\ X_3 \\end{bmatrix}$ with $\\alpha = 1.2\\,\\mathrm s^{-1}$, $\\beta = 0.8\\,\\mathrm{m}^{-1}\\mathrm s^{-1}$ at $t = 0.4\\,\\mathrm s$.\n  - Material points (in $\\mathrm m$): $\\mathbf{X}^{(1)} = \\begin{bmatrix} 0.6 \\\\ 0.5 \\\\ -0.2 \\end{bmatrix}$, $\\mathbf{X}^{(2)} = \\begin{bmatrix} 1.2 \\\\ -0.4 \\\\ 0.1 \\end{bmatrix}$, $\\mathbf{X}^{(3)} = \\begin{bmatrix} 0.0 \\\\ 1.0 \\\\ 0.0 \\end{bmatrix}$.\n\nFor each test case, compute:\n- Residual A: $\\max$ over the listed points of the maximum absolute entry of the difference between the material time derivative of $\\mathbf{F}$ and the material gradient of $\\mathbf{v}$, expressed in $1/\\mathrm s$.\n- Residual B: $\\max$ over the listed points of the maximum absolute entry of the difference between the material gradient of $\\mathbf{v}$ and the product of the spatial gradient of $\\mathbf{v}$ with $\\mathbf{F}$, expressed in $1/\\mathrm s$.\n\nFinal output format:\nYour program should produce a single line of output containing the six residuals as a comma-separated list enclosed in square brackets (for example, $\\left[ r_1, r_2, r_3, r_4, r_5, r_6 \\right]$). The entries must be ordered as $\\left[ \\text{Shear Residual A}, \\text{Shear Residual B}, \\text{Rotation Residual A}, \\text{Rotation Residual B}, \\text{Inhomogeneous Residual A}, \\text{Inhomogeneous Residual B} \\right]$, with each value in $1/\\mathrm s$.", "solution": "The solution is presented in two parts as required: first, the analytical derivations of the kinematic relations, and second, the numerical implementation to verify these relations for the specified test cases.\n\n### Part 1: Analytical Derivations\n\nThe core of this problem lies in deriving two fundamental kinematic identities in continuum mechanics. These derivations are based on the provided definitions of the motion map $\\mathbf{x}(\\mathbf{X}, t)$, the deformation gradient $\\mathbf{F}(\\mathbf{X}, t)$, and the material velocity $\\mathbf{v}(\\mathbf{X}, t)$.\n\n**Derivation 1: Material Time Derivative of the Deformation Gradient**\n\nThe first task is to derive an expression for the material time derivative of the deformation gradient, $\\dot{\\mathbf{F}}$, in terms of the material gradient of the velocity, $\\nabla_{\\mathbf{X}} \\mathbf{v}$.\n\nBy definition, the deformation gradient $\\mathbf{F}$ is the tensor whose components are given by the partial derivatives of the spatial coordinates $x_i$ with respect to the material coordinates $X_j$:\n$$\nF_{ij}(\\mathbf{X}, t) = \\frac{\\partial x_i(\\mathbf{X}, t)}{\\partial X_j}\n$$\nThe material time derivative, denoted by a superposed dot, is the partial derivative with respect to time $t$ holding the material coordinate $\\mathbf{X}$ fixed. Applying this to $F_{ij}$:\n$$\n\\dot{F}_{ij} = \\frac{\\partial}{\\partial t} \\left( F_{ij} \\right) = \\frac{\\partial}{\\partial t} \\left( \\frac{\\partial x_i}{\\partial X_j} \\right)\n$$\nThe problem statement assumes that the motion map $\\mathbf{x}(\\mathbf{X}, t)$ and its partial derivatives are continuous in all their arguments. This smoothness condition allows for the interchange of the order of partial differentiation with respect to $t$ and $X_j$:\n$$\n\\dot{F}_{ij} = \\frac{\\partial}{\\partial X_j} \\left( \\frac{\\partial x_i}{\\partial t} \\right)\n$$\nThe material velocity $\\mathbf{v}(\\mathbf{X}, t)$ is defined as the time derivative of the position vector $\\mathbf{x}(\\mathbf{X}, t)$ for a fixed material point $\\mathbf{X}$:\n$$\nv_i(\\mathbf{X}, t) = \\frac{\\partial x_i(\\mathbf{X}, t)}{\\partial t}\n$$\nSubstituting this definition into the expression for $\\dot{F}_{ij}$:\n$$\n\\dot{F}_{ij} = \\frac{\\partial v_i}{\\partial X_j}\n$$\nThe term on the right-hand side, $\\frac{\\partial v_i}{\\partial X_j}$, is the $ij$-th component of the material gradient of the velocity field $\\mathbf{v}$, which is denoted as $\\nabla_{\\mathbf{X}} \\mathbf{v}$. Therefore, in direct tensor notation, we arrive at the first required identity:\n$$\n\\dot{\\mathbf{F}} = \\nabla_{\\mathbf{X}} \\mathbf{v}\n$$\nThis identity shows that the rate of change of the deformation gradient for a material particle is equal to the gradient of the velocity field with respect to the particle's original position.\n\n**Derivation 2: Relation Between Material and Spatial Velocity Gradients**\n\nThe second task is to derive the relationship between the material gradient of velocity, $\\nabla_{\\mathbf{X}} \\mathbf{v}$, and the spatial gradient of velocity, $\\nabla_{\\mathbf{x}} \\mathbf{v}$. The spatial velocity gradient, often denoted by $\\mathbf{L}$, has components $L_{ik} = \\frac{\\partial v_i}{\\partial x_k}$.\n\nThe velocity field can be expressed as a function of material coordinates, $\\mathbf{v}(\\mathbf{X}, t)$, or as a function of spatial coordinates, $\\mathbf{v}(\\mathbf{x}, t)$. These two representations are linked through the motion map: $\\mathbf{v}(\\mathbf{X}, t) = \\mathbf{v}(\\mathbf{x}(\\mathbf{X}, t), t)$.\n\nWe start with the component form of the material velocity gradient, which we found in the first derivation:\n$$\n(\\nabla_{\\mathbf{X}} \\mathbf{v})_{ij} = \\frac{\\partial v_i(\\mathbf{x}(\\mathbf{X}, t), t)}{\\partial X_j}\n$$\nTo evaluate this derivative, we apply the chain rule for multivariable functions, treating $v_i$ as a function of $\\mathbf{x}$, which in turn is a function of $\\mathbf{X}$:\n$$\n\\frac{\\partial v_i}{\\partial X_j} = \\sum_{k=1}^{3} \\frac{\\partial v_i}{\\partial x_k} \\frac{\\partial x_k}{\\partial X_j}\n$$\nLet's identify the terms in this summation:\n- The term $\\frac{\\partial v_i}{\\partial x_k}$ is the $ik$-th component of the spatial velocity gradient, $\\mathbf{L} = \\nabla_{\\mathbf{x}} \\mathbf{v}$.\n- The term $\\frac{\\partial x_k}{\\partial X_j}$ is the $kj$-th component of the deformation gradient, $\\mathbf{F}$.\n\nSubstituting these back into the summation gives:\n$$\n(\\nabla_{\\mathbf{X}} \\mathbf{v})_{ij} = \\sum_{k=1}^{3} L_{ik} F_{kj}\n$$\nThis summation is precisely the definition of the $ij$-th component of the matrix product of $\\mathbf{L}$ and $\\mathbf{F}$. Thus, in direct tensor notation, we have the second required identity:\n$$\n\\nabla_{\\mathbf{X}} \\mathbf{v} = (\\nabla_{\\mathbf{x}} \\mathbf{v}) \\cdot \\mathbf{F} \\quad \\text{or} \\quad \\nabla_{\\mathbf{X}} \\mathbf{v} = \\mathbf{L} \\mathbf{F}\n$$\nCombining the two derived identities, we obtain the fundamental relation $\\dot{\\mathbf{F}} = \\mathbf{L} \\mathbf{F}$, which is a cornerstone of kinematic analysis in continuum mechanics.\n\n### Part 2: Numerical Verification\n\nThe derived identities, $\\dot{\\mathbf{F}} = \\nabla_{\\mathbf{X}} \\mathbf{v}$ and $\\nabla_{\\mathbf{X}} \\mathbf{v} = (\\nabla_{\\mathbf{x}} \\mathbf{v}) \\cdot \\mathbf{F}$, are exact analytical relationships. The numerical implementation will verify that for the given test cases, the difference between the left-hand side and the right-hand side of these equations is zero, up to floating-point precision.\n\n- **Residual A** corresponds to the first identity: $\\text{Residual A} = \\max_{\\mathbf{X}^{(k)}} \\| \\dot{\\mathbf{F}} - \\nabla_{\\mathbf{X}} \\mathbf{v} \\|_{\\max}$.\n- **Residual B** corresponds to the second identity: $\\text{Residual B} = \\max_{\\mathbf{X}^{(k)}} \\| \\nabla_{\\mathbf{X}} \\mathbf{v} - (\\nabla_{\\mathbf{x}} \\mathbf{v}) \\cdot \\mathbf{F} \\|_{\\max}$.\n\nFor each test case, we must first compute the analytical expressions for the required tensors ($\\mathbf{F}$, $\\dot{\\mathbf{F}}$, $\\nabla_{\\mathbf{X}}\\mathbf{v}$, and $\\nabla_{\\mathbf{x}}\\mathbf{v}$), then evaluate them at the specified time and material points, and finally compute the residuals. The analytical derivations for each case confirm that both residual matrices are identically zero. The Python code below implements these calculations. The resulting non-zero residuals are attributable solely to floating-point arithmetic errors.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_residuals_case1():\n    \"\"\"Calculates residuals for Test Case 1 (time-dependent simple shear).\"\"\"\n    t = 0.5\n    points = [\n        np.array([0.4, -0.3, 0.2]),\n        np.array([1.0, 0.0, -0.5]),\n        np.array([0.0, 0.0, 0.0]),\n    ]\n    max_res_A = 0.0\n    max_res_B = 0.0\n\n    for X in points:\n        # Material time derivative of F\n        F_dot = np.array([[0.0, 2 * t, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]])\n\n        # Material gradient of velocity\n        # v = [2*t*X2, 0, 0], so grad_X(v) is independent of X\n        grad_v_mat = np.array([[0.0, 2 * t, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]])\n\n        # Deformation gradient F\n        F = np.array([[1.0, t**2, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])\n\n        # Spatial gradient of velocity L\n        # x = [X1 + t^2*X2, X2, X3] => X2 = x2\n        # v_spatial = [2*t*x2, 0, 0], grad_x(v_spatial) is independent of x\n        grad_v_spa = np.array([[0.0, 2 * t, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]])\n\n        # Residual matrices\n        res_A_matrix = F_dot - grad_v_mat\n        res_B_matrix = grad_v_mat - grad_v_spa @ F\n\n        # Maximum absolute entrywise norms\n        current_res_A = np.max(np.abs(res_A_matrix))\n        current_res_B = np.max(np.abs(res_B_matrix))\n\n        max_res_A = max(max_res_A, current_res_A)\n        max_res_B = max(max_res_B, current_res_B)\n        \n    return max_res_A, max_res_B\n    \ndef calculate_residuals_case2():\n    \"\"\"Calculates residuals for Test Case 2 (planar rigid rotation).\"\"\"\n    t = 0.2\n    omega = 3.0\n    points = [\n        np.array([0.7, 0.2, 0.0]),\n        np.array([-0.5, 1.0, 0.3]),\n        np.array([0.0, 0.0, 0.0]),\n    ]\n    max_res_A = 0.0\n    max_res_B = 0.0\n\n    theta = omega * t\n    ct, st = np.cos(theta), np.sin(theta)\n\n    for X in points:\n        # F = R(t), so F_dot = R_dot(t)\n        R_dot = omega * np.array([[-st, -ct, 0.0], [ct, -st, 0.0], [0.0, 0.0, 0.0]])\n        F_dot = R_dot\n\n        # v = R_dot * X, so grad_X(v) = R_dot\n        grad_v_mat = R_dot\n\n        # F = R(t)\n        F = np.array([[ct, -st, 0.0], [st, ct, 0.0], [0.0, 0.0, 1.0]])\n\n        # L = R_dot * R^T, independent of x\n        grad_v_spa = omega * np.array([[0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 0.0]])\n\n        # Residual matrices\n        res_A_matrix = F_dot - grad_v_mat\n        res_B_matrix = grad_v_mat - grad_v_spa @ F\n\n        # Maximum absolute entrywise norms\n        current_res_A = np.max(np.abs(res_A_matrix))\n        current_res_B = np.max(np.abs(res_B_matrix))\n\n        max_res_A = max(max_res_A, current_res_A)\n        max_res_B = max(max_res_B, current_res_B)\n        \n    return max_res_A, max_res_B\n\ndef calculate_residuals_case3():\n    \"\"\"Calculates residuals for Test Case 3 (inhomogeneous stretch-shear).\"\"\"\n    t = 0.4\n    alpha = 1.2\n    beta = 0.8\n    points = [\n        np.array([0.6, 0.5, -0.2]),\n        np.array([1.2, -0.4, 0.1]),\n        np.array([0.0, 1.0, 0.0]),\n    ]\n    max_res_A = 0.0\n    max_res_B = 0.0\n\n    for X in points:\n        X1, X2, X3 = X\n        eat = np.exp(alpha * t)\n\n        # F_dot depends on X\n        F_dot = np.array([\n            [alpha * eat, 0.0, 0.0],\n            [beta * X2, beta * X1, 0.0],\n            [0.0, 0.0, 0.0]\n        ])\n\n        # grad_v_mat depends on X\n        # v = [alpha*eat*X1, beta*X1*X2, 0]\n        grad_v_mat = np.array([\n            [alpha * eat, 0.0, 0.0],\n            [beta * X2, beta * X1, 0.0],\n            [0.0, 0.0, 0.0]\n        ])\n        \n        # F depends on X\n        F = np.array([\n            [eat, 0.0, 0.0],\n            [beta * t * X2, 1 + beta * t * X1, 0.0],\n            [0.0, 0.0, 1.0]\n        ])\n\n        # grad_v_spa depends on X, via the mapping x(X)\n        denom = 1 + beta * t * X1\n        grad_v_spa_21 = (beta * X2 * np.exp(-alpha * t)) / denom\n        grad_v_spa_22 = (beta * X1) / denom\n        grad_v_spa = np.array([\n            [alpha, 0.0, 0.0],\n            [grad_v_spa_21, grad_v_spa_22, 0.0],\n            [0.0, 0.0, 0.0]\n        ])\n\n        # Residual matrices\n        res_A_matrix = F_dot - grad_v_mat\n        res_B_matrix = grad_v_mat - grad_v_spa @ F\n        \n        # Maximum absolute entrywise norms\n        current_res_A = np.max(np.abs(res_A_matrix))\n        current_res_B = np.max(np.abs(res_B_matrix))\n\n        max_res_A = max(max_res_A, current_res_A)\n        max_res_B = max(max_res_B, current_res_B)\n        \n    return max_res_A, max_res_B\n\ndef solve():\n    \"\"\"Main function to solve the problem and print results.\"\"\"\n    # Test Case 1\n    res_A_1, res_B_1 = calculate_residuals_case1()\n    \n    # Test Case 2\n    res_A_2, res_B_2 = calculate_residuals_case2()\n    \n    # Test Case 3\n    res_A_3, res_B_3 = calculate_residuals_case3()\n\n    results = [res_A_1, res_B_1, res_A_2, res_B_2, res_A_3, res_B_3]\n\n    print(f\"[{','.join(f'{r:.1e}' for r in results)}]\")\n\nsolve()\n```", "id": "3579907"}, {"introduction": "This final practice [@problem_id:3579912] bridges continuum theory with the discrete world of the Finite Element Method (FEM), a core tool in computational solid mechanics. You will implement the full kinematic chain, from a parent element's parametric coordinates ($\\boldsymbol{\\xi}$) to material coordinates ($\\mathbf{X}$) and finally to spatial coordinates ($\\mathbf{x}$). This exercise highlights the practical importance of the chain rule for transforming derivatives, a procedure essential for computing physical quantities like strain and stress within distorted finite elements.", "problem": "Consider a two-dimensional isoparametric quadrilateral finite element in the Finite Element Method (FEM). Let the parametric coordinates be $\\boldsymbol{\\xi} = (\\xi,\\eta)$ with $\\xi \\in [-1,1]$ and $\\eta \\in [-1,1]$. The isoparametric mapping from parametric space to the material (reference) configuration is $\\boldsymbol{\\Phi}(\\boldsymbol{\\xi}) = \\mathbf X$, and the deformation mapping from material coordinates to spatial (current) coordinates is $\\boldsymbol{\\varphi}(\\mathbf X) = \\mathbf x$. You will implement these maps, derive and verify the chain rule for gradients $\\nabla_{\\boldsymbol{\\xi}} \\to \\nabla_{\\mathbf X} \\to \\nabla_{\\mathbf x}$, and test quadrature-based integration accuracy for distorted elements.\n\nFundamental base:\n- The isoparametric mapping employs bilinear shape functions on the square $[-1,1]\\times[-1,1]$. Denote the four nodes in parametric space at $(-1,-1)$, $(1,-1)$, $(1,1)$, $(-1,1)$ with corresponding material coordinates $\\mathbf X_I$ for $I=1,2,3,4$. The bilinear shape functions are\n$$\nN_1(\\xi,\\eta) = \\tfrac{1}{4}(1-\\xi)(1-\\eta),\\quad\nN_2(\\xi,\\eta) = \\tfrac{1}{4}(1+\\xi)(1-\\eta),\\quad\nN_3(\\xi,\\eta) = \\tfrac{1}{4}(1+\\xi)(1+\\eta),\\quad\nN_4(\\xi,\\eta) = \\tfrac{1}{4}(1-\\xi)(1+\\eta).\n$$\nThe mapping is $\\mathbf X(\\xi,\\eta) = \\sum_{I=1}^4 N_I(\\xi,\\eta)\\,\\mathbf X_I$. Its Jacobian with respect to $\\boldsymbol{\\xi}$ is the $2\\times 2$ matrix\n$$\n\\mathbf J_{\\boldsymbol{\\Phi}}(\\boldsymbol{\\xi}) = \\frac{\\partial \\mathbf X}{\\partial \\boldsymbol{\\xi}} =\n\\begin{bmatrix}\n\\frac{\\partial X_1}{\\partial \\xi} & \\frac{\\partial X_1}{\\partial \\eta} \\\\\n\\frac{\\partial X_2}{\\partial \\xi} & \\frac{\\partial X_2}{\\partial \\eta}\n\\end{bmatrix},\n$$\nwhere $X_1$ and $X_2$ are the components of $\\mathbf X$.\n\n- The deformation mapping is given by $\\boldsymbol{\\varphi}(\\mathbf X) = \\mathbf X + \\mathbf u(\\mathbf X)$, with\n$$\n\\mathbf u(\\mathbf X) = \\begin{bmatrix} \\alpha X_1^2 + 0.05\\,X_2 \\\\ \\alpha X_1 X_2 \\end{bmatrix},\n$$\nwhere $\\alpha$ is a small non-dimensional parameter. The deformation gradient is the $2\\times 2$ matrix\n$$\n\\mathbf F(\\mathbf X) = \\frac{\\partial \\mathbf x}{\\partial \\mathbf X} =\n\\begin{bmatrix}\n1 + 2\\alpha X_1 & 0.05 \\\\\n\\alpha X_2 & 1 + \\alpha X_1\n\\end{bmatrix}.\n$$\n\n- For a scalar field $a$ defined in spatial coordinates, $a(\\mathbf x)$, the chain rule for gradients under composition $a(\\boldsymbol{\\varphi}(\\boldsymbol{\\Phi}(\\boldsymbol{\\xi})))$ yields\n$$\n\\nabla_{\\boldsymbol{\\xi}} a = \\mathbf J_{\\boldsymbol{\\Phi}}(\\boldsymbol{\\xi})^{\\top}\\,\\mathbf F(\\mathbf X)^{\\top}\\,\\nabla_{\\mathbf x} a,\\quad\n\\nabla_{\\mathbf X} a = \\mathbf F(\\mathbf X)^{\\top}\\,\\nabla_{\\mathbf x} a,\\quad\n\\nabla_{\\mathbf x} a = \\mathbf F(\\mathbf X)^{-\\top}\\,\\mathbf J_{\\boldsymbol{\\Phi}}(\\boldsymbol{\\xi})^{-\\top}\\,\\nabla_{\\boldsymbol{\\xi}} a,\n$$\nassuming invertibility of $\\mathbf J_{\\boldsymbol{\\Phi}}$ and $\\mathbf F$.\n\n- The integral of a scalar field $g(\\mathbf X)$ over the physical element is transformed to parametric space as\n$$\n\\int_{\\Omega_e} g(\\mathbf X)\\, \\mathrm d\\Omega = \\int_{-1}^{1}\\int_{-1}^{1} g(\\mathbf X(\\boldsymbol{\\xi})) \\,\\det\\left(\\mathbf J_{\\boldsymbol{\\Phi}}(\\boldsymbol{\\xi})\\right)\\, \\mathrm d\\xi\\,\\mathrm d\\eta.\n$$\nGaussian quadrature on $[-1,1]$ uses standard Gauss-Legendre points and weights. For $1\\times 1$, use points $\\{0\\}$ with weights $\\{2\\}$. For $2\\times 2$, use points $\\{-1/\\sqrt{3},\\,1/\\sqrt{3}\\}$ with weights $\\{1,\\,1\\}$. For $3\\times 3$, use points $\\{-\\sqrt{3/5},\\,0,\\,\\sqrt{3/5}\\}$ with weights $\\{5/9,\\,8/9,\\,5/9\\}$.\n\nTask:\n1. Implement the isoparametric mapping $\\boldsymbol{\\Phi}(\\boldsymbol{\\xi})$ with bilinear shape functions and evaluate its Jacobian $\\mathbf J_{\\boldsymbol{\\Phi}}(\\boldsymbol{\\xi})$.\n2. Implement the deformation mapping $\\boldsymbol{\\varphi}(\\mathbf X)$ and its deformation gradient $\\mathbf F(\\mathbf X)$.\n3. Define the scalar field\n$$\na(\\mathbf x) = \\sin(\\pi x_1)\\,\\cos(\\pi x_2),\n$$\nwith arguments in radians. Compute the analytical spatial gradient\n$$\n\\nabla_{\\mathbf x} a(\\mathbf x) = \\begin{bmatrix}\n\\pi \\cos(\\pi x_1)\\cos(\\pi x_2) \\\\\n-\\pi \\sin(\\pi x_1)\\sin(\\pi x_2)\n\\end{bmatrix}.\n$$\n4. Verify the chain rule at the $2\\times 2$ Gauss points for each element by:\n   - Computing $\\nabla_{\\boldsymbol{\\xi}} a$ via central finite differences on $\\boldsymbol{\\xi}$ with step $h = 10^{-6}$ applied to the composed field $a(\\boldsymbol{\\varphi}(\\boldsymbol{\\Phi}(\\boldsymbol{\\xi})))$.\n   - Computing $\\nabla_{\\boldsymbol{\\xi}} a$ via $\\mathbf J_{\\boldsymbol{\\Phi}}^{\\top}\\mathbf F^{\\top}\\nabla_{\\mathbf x} a$ and comparing to the finite difference result using the Euclidean norm of their difference.\n   - Computing $\\nabla_{\\mathbf x} a$ via $\\mathbf F^{-\\top}\\mathbf J_{\\boldsymbol{\\Phi}}^{-\\top}\\nabla_{\\boldsymbol{\\xi}} a$ starting from the finite difference $\\nabla_{\\boldsymbol{\\xi}} a$, and comparing to the analytical $\\nabla_{\\mathbf x} a$ using the Euclidean norm.\n   - Report, for each element, the maximum of the two norms over the $2\\times 2$ Gauss points as a single float.\n\n5. Test integration accuracy for the constant integrand $g(\\mathbf X) = 1$ (dimensionless) by computing the element area via transformed quadrature\n$$\nA_{\\text{quad}}^{(m)} = \\sum_{i=1}^{m}\\sum_{j=1}^{m} w_i w_j \\,\\det(\\mathbf J_{\\boldsymbol{\\Phi}}(\\xi_i,\\eta_j)),\n$$\nfor $m = 1, 2, 3$. Compare to the exact polygon area of the quadrilateral with the shoelace formula. Report, for each element, the absolute errors $|A_{\\text{quad}}^{(1)} - A_{\\text{poly}}|$, $|A_{\\text{quad}}^{(2)} - A_{\\text{poly}}|$, and $|A_{\\text{quad}}^{(3)} - A_{\\text{poly}}|$ as floats.\n\n6. Orientation and near-singularity check: For each element, evaluate $\\det(\\mathbf J_{\\boldsymbol{\\Phi}})$ at the $3\\times 3$ Gauss points and report a boolean indicating whether all determinants are strictly positive. Also sample $\\det(\\mathbf J_{\\boldsymbol{\\Phi}})$ on a uniform $11\\times 11$ grid on $[-1,1]^2$ and report the minimum value found as a float.\n\nTest suite:\n- Case A (affine parallelogram; expected exactness at $2\\times 2$): $\\mathbf X_1=(0,0)$, $\\mathbf X_2=(2,0)$, $\\mathbf X_3=(3,1)$, $\\mathbf X_4=(1,1)$.\n- Case B (moderately distorted convex quadrilateral): $\\mathbf X_1=(0,0)$, $\\mathbf X_2=(2,0.3)$, $\\mathbf X_3=(2.2,1.0)$, $\\mathbf X_4=(0.1,1.1)$.\n- Case C (highly skewed but positively oriented quadrilateral): $\\mathbf X_1=(0,0)$, $\\mathbf X_2=(1.0,0.02)$, $\\mathbf X_3=(1.02,0.98)$, $\\mathbf X_4=(0.01,1.0)$.\n\nParameter values:\n- Use $\\alpha = 0.1$ in the deformation mapping.\n- Use central differences with step $h = 10^{-6}$ in parametric coordinates.\n\nFinal output specification:\n- For each case, output a list of six values in the order: maximum chain rule gradient error over $2\\times 2$ points (float), absolute area error using $1\\times 1$ quadrature (float), absolute area error using $2\\times 2$ quadrature (float), absolute area error using $3\\times 3$ quadrature (float), orientation check over $3\\times 3$ points (boolean), and minimum Jacobian determinant over the $11\\times 11$ grid (float).\n- Concatenate the three case results into a single list of length $18$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,\\dots,r_{18}]$).", "solution": "The problem requires a thorough analysis and implementation of several core concepts in continuum mechanics and the Finite Element Method (FEM) for a two-dimensional isoparametric quadrilateral element. The tasks involve coordinate transformations, gradient computations, numerical integration, and element quality assessment. The solution will proceed by first establishing the mathematical framework for each component and then applying it to the specified test cases.\n\n### 1. Mathematical and Algorithmic Framework\n\n#### 1.1 Isoparametric Mapping and its Jacobian\nThe isoparametric formulation maps a standard parent element, the square domain defined by $\\boldsymbol{\\xi} = (\\xi,\\eta)$ where $\\xi, \\eta \\in [-1, 1]$, to a quadrilateral element in the material (or physical) domain $\\Omega_e$. This mapping, $\\mathbf{X} = \\boldsymbol{\\Phi}(\\boldsymbol{\\xi})$, is defined using the same shape functions that would be used to interpolate a field variable over the element. For a 4-node quadrilateral, bilinear shape functions $N_I(\\boldsymbol{\\xi})$ are used:\n$$\n\\mathbf{X}(\\boldsymbol{\\xi}) = \\sum_{I=1}^4 N_I(\\boldsymbol{\\xi}) \\mathbf{X}_I\n$$\nwhere $\\mathbf{X}_I$ are the coordinates of the four nodes of the element in the material configuration. The shape functions are given by:\n$N_1(\\xi,\\eta) = \\tfrac{1}{4}(1-\\xi)(1-\\eta)$, $N_2(\\xi,\\eta) = \\tfrac{1}{4}(1+\\xi)(1-\\eta)$, $N_3(\\xi,\\eta) = \\tfrac{1}{4}(1+\\xi)(1+\\eta)$, $N_4(\\xi,\\eta) = \\tfrac{1}{4}(1-\\xi)(1+\\eta)$.\n\nThe local-to-global derivative relationship is governed by the Jacobian of this mapping, $\\mathbf{J}_{\\boldsymbol{\\Phi}}$. It is a $2 \\times 2$ matrix that relates differential areas and gradients between the parametric and material spaces.\n$$\n\\mathbf{J}_{\\boldsymbol{\\Phi}}(\\boldsymbol{\\xi}) = \\frac{\\partial \\mathbf{X}}{\\partial \\boldsymbol{\\xi}} = \\begin{bmatrix} \\frac{\\partial X_1}{\\partial \\xi} & \\frac{\\partial X_1}{\\partial \\eta} \\\\ \\frac{\\partial X_2}{\\partial \\xi} & \\frac{\\partial X_2}{\\partial \\eta} \\end{bmatrix}\n$$\nThe components are computed by differentiating the mapping equation:\n$$\n\\frac{\\partial X_k}{\\partial \\xi_j} = \\sum_{I=1}^4 \\frac{\\partial N_I(\\boldsymbol{\\xi})}{\\partial \\xi_j} X_{I,k}\n$$\nwhere $k \\in \\{1, 2\\}$ and $\\xi_j \\in \\{\\xi, \\eta\\}$. In matrix form, this can be efficiently computed as $\\mathbf{J}_{\\boldsymbol{\\Phi}} = \\mathbf{X}_{\\text{nodes}}^T \\mathbf{G}(\\boldsymbol{\\xi})$, where $\\mathbf{X}_{\\text{nodes}}$ is the $4 \\times 2$ matrix of nodal coordinates and $\\mathbf{G}(\\boldsymbol{\\xi})$ is the $4 \\times 2$ matrix of shape function derivatives with respect to $\\boldsymbol{\\xi}$, with entries $G_{Ij} = \\frac{\\partial N_I}{\\partial \\xi_j}$.\n\n#### 1.2 Deformation Mapping and its Gradient\nThe deformation mapping $\\boldsymbol{\\varphi}$ takes a point $\\mathbf{X}$ from the material configuration to its corresponding point $\\mathbf{x}$ in the spatial (current) configuration. It is given as $\\mathbf{x} = \\boldsymbol{\\varphi}(\\mathbf{X}) = \\mathbf{X} + \\mathbf{u}(\\mathbf{X})$, where $\\mathbf{u}(\\mathbf{X})$ is the displacement field. The problem specifies:\n$$\n\\mathbf{u}(\\mathbf{X}) = \\begin{bmatrix} \\alpha X_1^2 + 0.05\\,X_2 \\\\ \\alpha X_1 X_2 \\end{bmatrix} \\quad \\text{with } \\alpha = 0.1\n$$\nThe local deformation is characterized by the deformation gradient, $\\mathbf{F}$, defined as the derivative of the spatial coordinates with respect to the material coordinates:\n$$\n\\mathbf{F}(\\mathbf{X}) = \\frac{\\partial \\mathbf{x}}{\\partial \\mathbf{X}} = \\mathbf{I} + \\frac{\\partial \\mathbf{u}}{\\partial \\mathbf{X}}\n$$\nwhere $\\mathbf{I}$ is the identity tensor. For the given displacement field, this yields:\n$$\n\\mathbf{F}(\\mathbf{X}) = \\begin{bmatrix} 1 + 2\\alpha X_1 & 0.05 \\\\ \\alpha X_2 & 1 + \\alpha X_1 \\end{bmatrix}\n$$\n\n#### 1.3 Chain Rule Verification\nThe core of this task is to verify the chain rule for gradients across the three coordinate systems: parametric ($\\boldsymbol{\\xi}$), material ($\\mathbf{X}$), and spatial ($\\mathbf{x}$). The composite mapping is $a(\\mathbf{x}) = a(\\boldsymbol{\\varphi}(\\boldsymbol{\\Phi}(\\boldsymbol{\\xi})))$. The chain rule relates the gradients:\n$$\n\\nabla_{\\boldsymbol{\\xi}} a = \\mathbf{J}_{\\boldsymbol{\\Phi}}^T \\mathbf{F}^T \\nabla_{\\mathbf{x}} a\n$$\nTo verify this, we perform two comparisons at each of the four $2 \\times 2$ Gaussian quadrature points:\n1.  We compute the gradient in parametric space, $\\nabla_{\\boldsymbol{\\xi}} a$, numerically using a central finite difference scheme with a small step $h = 10^{-6}$. This serves as a reference value.\n2.  We compute the same gradient using the analytical chain rule: $\\nabla_{\\boldsymbol{\\xi}} a_{\\text{chain}} = \\mathbf{J}_{\\boldsymbol{\\Phi}}^T \\mathbf{F}^T \\nabla_{\\mathbf{x}} a_{\\text{analytical}}$, where all Jacobians and the analytical spatial gradient of the scalar field $a(\\mathbf{x}) = \\sin(\\pi x_1)\\cos(\\pi x_2)$ are evaluated at the appropriate corresponding points. The Euclidean norm of the difference, $\\|\\nabla_{\\boldsymbol{\\xi}} a - \\nabla_{\\boldsymbol{\\xi}} a_{\\text{chain}}\\|$, quantifies the error.\n3.  We also verify the inverse relationship: $\\nabla_{\\mathbf{x}} a = \\mathbf{F}^{-\\top} \\mathbf{J}_{\\boldsymbol{\\Phi}}^{-\\top} \\nabla_{\\boldsymbol{\\xi}} a$. We use the numerically computed $\\nabla_{\\boldsymbol{\\xi}} a$ to calculate a value for $\\nabla_{\\mathbf{x}} a$ and compare it with the analytical spatial gradient. The error is measured by the norm of their difference.\nThe final reported error for this task is the maximum of these error norms over all four Gauss points.\n\n#### 1.4 Integration Accuracy and Area Calculation\nThe integral of a function over the material element domain $\\Omega_e$ is computed by transforming it to an integral over the parent domain $[-1, 1]^2$:\n$$\n\\int_{\\Omega_e} g(\\mathbf{X}) \\, d\\Omega = \\int_{-1}^{1}\\int_{-1}^{1} g(\\mathbf{X}(\\boldsymbol{\\xi})) \\det(\\mathbf{J}_{\\boldsymbol{\\Phi}}(\\boldsymbol{\\xi})) \\, d\\xi d\\eta\n$$\nThis integral is then approximated using 2D Gaussian quadrature:\n$$\n\\int_{-1}^{1}\\int_{-1}^{1} f(\\boldsymbol{\\xi}) \\, d\\xi d\\eta \\approx \\sum_{i=1}^{m}\\sum_{j=1}^{m} w_i w_j f(\\xi_i, \\eta_j)\n$$\nwhere $(\\xi_i, \\eta_j)$ are the Gauss points and $w_i, w_j$ are the corresponding weights for an $m$-point rule.\n\nTo test accuracy, we compute the area of the element, for which the integrand is $g(\\mathbf{X}) = 1$. The area is computed using $m \\times m$ quadrature for $m=1, 2, 3$. These numerical results are compared against the exact area of the quadrilateral, which is calculated using the shoelace formula:\n$$\nA_{\\text{poly}} = \\frac{1}{2} \\left| \\sum_{I=1}^{4} (X_{I,1} X_{I+1,2} - X_{I+1,1} X_{I,2}) \\right|\n$$\nwith node $5$ being the same as node $1$. For a general bilinear isoparametric element, the Jacobian determinant $\\det(\\mathbf{J}_{\\boldsymbol{\\Phi}})$ is a quadratic polynomial in $\\xi$ and $\\eta$. A $2 \\times 2$ Gauss rule (degree of precision 3) is therefore expected to integrate this quantity exactly, yielding zero error for the area calculation. The $1 \\times 1$ rule may have a significant error for distorted elements, while the $3 \\times 3$ rule will also be exact.\n\n#### 1.5 Element Quality and Orientation\nThe Jacobian determinant, $\\det(\\mathbf{J}_{\\boldsymbol{\\Phi}})$, represents the ratio of differential area in the material space to that in the parametric space ($d\\Omega = \\det(\\mathbf{J}_{\\boldsymbol{\\Phi}}) d\\xi d\\eta$). For a valid, non-degenerate mapping, the determinant must be strictly positive throughout the element domain. A negative determinant indicates element inversion (folding), while a zero determinant signifies a singularity where the mapping is not one-to-one.\nWe assess this in two ways:\n1.  We check that $\\det(\\mathbf{J}_{\\boldsymbol{\\Phi}}) > 0$ at all nine points of a $3 \\times 3$ Gauss grid. This provides a robust check of element orientation for typical integration scenarios.\n2.  We compute the minimum value of $\\det(\\mathbf{J}_{\\boldsymbol{\\Phi}})$ on a fine $11 \\times 11$ uniform grid over the parent element. This gives an indication of how close the element is to becoming singular (a smaller minimum value implies higher distortion).\n\nThese steps will be implemented for each of the three test element geometries, providing a comprehensive analysis of their properties under the given deformation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the computational solid mechanics problem.\n    It processes three test cases for a 2D isoparametric quadrilateral element.\n    \"\"\"\n    \n    # --- Problem Parameters ---\n    ALPHA = 0.1\n    H_FD = 1e-6\n\n    # --- Gaussian Quadrature Data ---\n    gauss_data = {\n        1: {'points': [0.0], 'weights': [2.0]},\n        2: {'points': [-1.0 / np.sqrt(3.0), 1.0 / np.sqrt(3.0)], 'weights': [1.0, 1.0]},\n        3: {'points': [-np.sqrt(3.0 / 5.0), 0.0, np.sqrt(3.0 / 5.0)], 'weights': [5.0 / 9.0, 8.0 / 9.0, 5.0 / 9.0]}\n    }\n    \n    # --- Test Cases ---\n    test_cases = [\n        # Case A: Affine parallelogram\n        np.array([[0.0, 0.0], [2.0, 0.0], [3.0, 1.0], [1.0, 1.0]]),\n        # Case B: Moderately distorted convex quad\n        np.array([[0.0, 0.0], [2.0, 0.3], [2.2, 1.0], [0.1, 1.1]]),\n        # Case C: Highly skewed but positively oriented quad\n        np.array([[0.0, 0.0], [1.0, 0.02], [1.02, 0.98], [0.01, 1.0]]),\n    ]\n\n    # --- Helper Functions ---\n\n    def get_shape_functions_and_derivs(xi, eta):\n        \"\"\"\n        Computes bilinear shape functions N and their derivatives G at (xi, eta).\n        N is a (4,) array of shape function values.\n        G is a (4, 2) array of derivatives w.r.t (xi, eta).\n        \"\"\"\n        N = 0.25 * np.array([\n            (1 - xi) * (1 - eta),\n            (1 + xi) * (1 - eta),\n            (1 + xi) * (1 + eta),\n            (1 - xi) * (1 + eta)\n        ])\n        \n        G = 0.25 * np.array([\n            [-(1 - eta), -(1 - xi)],\n            [ (1 - eta), -(1 + xi)],\n            [ (1 + eta),  (1 + xi)],\n            [-(1 + eta),  (1 - xi)]\n        ])\n        return N, G\n\n    def isoparametric_map(xi, eta, X_nodes):\n        N, _ = get_shape_functions_and_derivs(xi, eta)\n        return N @ X_nodes\n\n    def get_isoparametric_jacobian(xi, eta, X_nodes):\n        _, G = get_shape_functions_and_derivs(xi, eta)\n        # J_phi = X_nodes^T * G\n        return X_nodes.T @ G\n\n    def deformation_map(X, alpha):\n        X1, X2 = X\n        u = np.array([alpha * X1**2 + 0.05 * X2, alpha * X1 * X2])\n        return X + u\n\n    def get_deformation_gradient(X, alpha):\n        X1, X2 = X\n        F = np.array([\n            [1 + 2 * alpha * X1, 0.05],\n            [alpha * X2, 1 + alpha * X1]\n        ])\n        return F\n\n    def scalar_field(x):\n        x1, x2 = x\n        return np.sin(np.pi * x1) * np.cos(np.pi * x2)\n\n    def scalar_field_gradient(x):\n        x1, x2 = x\n        grad_a = np.array([\n            np.pi * np.cos(np.pi * x1) * np.cos(np.pi * x2),\n            -np.pi * np.sin(np.pi * x1) * np.sin(np.pi * x2)\n        ])\n        return grad_a\n\n    def shoelace_area(X_nodes):\n        x = X_nodes[:, 0]\n        y = X_nodes[:, 1]\n        return 0.5 * np.abs(np.dot(x, np.roll(y, -1)) - np.dot(y, np.roll(x, -1)))\n\n    # --- Main Processing Loop ---\n    \n    all_results = []\n    \n    for X_nodes in test_cases:\n        \n        # --- Task 4: Chain Rule Verification ---\n        gp_2x2 = gauss_data[2]['points']\n        chain_rule_errors = []\n        for eta_p in gp_2x2:\n            for xi_p in gp_2x2:\n                # Mappings and Jacobians at the Gauss point\n                X = isoparametric_map(xi_p, eta_p, X_nodes)\n                x = deformation_map(X, ALPHA)\n                J_phi = get_isoparametric_jacobian(xi_p, eta_p, X_nodes)\n                F = get_deformation_gradient(X, ALPHA)\n                \n                # --- Finite Difference Gradient ---\n                def composite_field(xi, eta):\n                    X_val = isoparametric_map(xi, eta, X_nodes)\n                    x_val = deformation_map(X_val, ALPHA)\n                    return scalar_field(x_val)\n\n                grad_xi_a_fd_xi = (composite_field(xi_p + H_FD, eta_p) - composite_field(xi_p - H_FD, eta_p)) / (2 * H_FD)\n                grad_xi_a_fd_eta = (composite_field(xi_p, eta_p + H_FD) - composite_field(xi_p, eta_p - H_FD)) / (2 * H_FD)\n                grad_xi_a_fd = np.array([grad_xi_a_fd_xi, grad_xi_a_fd_eta])\n\n                # --- Comparison 1: Gradient in xi-space ---\n                grad_x_a_analytic = scalar_field_gradient(x)\n                grad_xi_a_chain = J_phi.T @ F.T @ grad_x_a_analytic\n                err1 = np.linalg.norm(grad_xi_a_fd - grad_xi_a_chain)\n                chain_rule_errors.append(err1)\n\n                # --- Comparison 2: Gradient in x-space ---\n                J_phi_inv_T = np.linalg.inv(J_phi).T\n                F_inv_T = np.linalg.inv(F).T\n                grad_x_a_from_xi = F_inv_T @ J_phi_inv_T @ grad_xi_a_fd\n                err2 = np.linalg.norm(grad_x_a_from_xi - grad_x_a_analytic)\n                chain_rule_errors.append(err2)\n        \n        max_chain_rule_error = max(chain_rule_errors)\n        \n        # --- Task 5: Integration Accuracy ---\n        exact_area = shoelace_area(X_nodes)\n        area_errors = []\n        for m in [1, 2, 3]:\n            points = gauss_data[m]['points']\n            weights = gauss_data[m]['weights']\n            quad_area = 0.0\n            for i, w_i in enumerate(weights):\n                for j, w_j in enumerate(weights):\n                    xi_p, eta_p = points[i], points[j]\n                    J_phi = get_isoparametric_jacobian(xi_p, eta_p, X_nodes)\n                    det_J = np.linalg.det(J_phi)\n                    quad_area += w_i * w_j * det_J\n            area_errors.append(abs(quad_area - exact_area))\n            \n        # --- Task 6: Orientation and Singularity Check ---\n        # 3x3 Gauss grid check\n        gp_3x3 = gauss_data[3]['points']\n        all_dets_positive = True\n        for eta_p in gp_3x3:\n            for xi_p in gp_3x3:\n                det_J = np.linalg.det(get_isoparametric_jacobian(xi_p, eta_p, X_nodes))\n                if det_J <= 0:\n                    all_dets_positive = False\n                    break\n            if not all_dets_positive:\n                break\n        \n        # 11x11 uniform grid check\n        grid_points = np.linspace(-1, 1, 11)\n        min_det_J = np.inf\n        for eta_p in grid_points:\n            for xi_p in grid_points:\n                det_J = np.linalg.det(get_isoparametric_jacobian(xi_p, eta_p, X_nodes))\n                if det_J < min_det_J:\n                    min_det_J = det_J\n\n        # --- Aggregate results for the case ---\n        case_results = [\n            max_chain_rule_error,\n            area_errors[0],\n            area_errors[1],\n            area_errors[2],\n            all_dets_positive,\n            min_det_J\n        ]\n        all_results.extend(case_results)\n\n    # --- Final Output ---\n    # The format string ensures floats are printed with sufficient precision\n    # and booleans as 'True' or 'False'.\n    formatted_results = [f\"{r:.8e}\" if isinstance(r, float) else str(r) for r in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```", "id": "3579912"}]}