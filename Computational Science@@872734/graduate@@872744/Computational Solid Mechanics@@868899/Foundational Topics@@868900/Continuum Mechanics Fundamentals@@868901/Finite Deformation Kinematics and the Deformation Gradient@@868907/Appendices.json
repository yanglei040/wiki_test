{"hands_on_practices": [{"introduction": "To begin our hands-on exploration, we will start with the fundamental task of quantifying deformation for one of the simplest cases: uniaxial stretch. This exercise [@problem_id:3565015] requires you to derive several key kinematic measures, including the right and left Cauchy–Green tensors, $\\mathbf{C}$ and $\\mathbf{B}$, and the Green–Lagrange and Euler–Almansi strain tensors, $\\mathbf{E}$ and $\\mathbf{e}$. By working through this canonical example, you will build a concrete understanding of how these different tensors capture changes in length and how they relate to one another in both the reference and current configurations.", "problem": "A homogeneous deformation maps a body from the reference configuration with material coordinates $\\mathbf{X}$ to the current configuration with spatial coordinates $\\mathbf{x}$ via a constant deformation gradient $\\mathbf{F}$. Consider a uniaxial stretch along the first basis direction with $\\mathbf{F}=\\operatorname{diag}(\\lambda,\\,1,\\,1)$, where $\\lambda>0$ is the principal stretch.\n\nStarting from the core definitions in finite deformation kinematics, derive explicit expressions for the right Cauchy–Green deformation tensor $\\mathbf{C}$, the left Cauchy–Green deformation tensor $\\mathbf{B}$, the Green–Lagrange strain tensor $\\mathbf{E}$, and the Euler–Almansi strain tensor $\\mathbf{e}$. Identify which tensor components are nonzero and interpret physically what those components represent in terms of changes of squared lengths and local stretches in the reference and current configurations.\n\nReport as your final answer the closed-form expression for the Lagrangian normal strain component $E_{11}$ as a function of $\\lambda$. No rounding is required. The final answer should be a single analytic expression without units.", "solution": "The problem statement is evaluated as valid. It is scientifically grounded in the principles of continuum mechanics, is well-posed with sufficient information to derive a unique solution, and is expressed in objective, formal language. The problem is a standard exercise in finite deformation kinematics and is free of any inconsistencies or ambiguities.\n\nWe begin by stating the fundamental definitions of the quantities to be derived. Let $\\mathbf{F}$ be the deformation gradient tensor, which maps material line elements $d\\mathbf{X}$ in the reference configuration to spatial line elements $d\\mathbf{x}$ in the current configuration via $d\\mathbf{x} = \\mathbf{F} d\\mathbf{X}$.\n\nThe right Cauchy–Green deformation tensor, $\\mathbf{C}$, is a material tensor defined as:\n$$\n\\mathbf{C} = \\mathbf{F}^\\top \\mathbf{F}\n$$\nIt measures the deformation of the material itself and is independent of rigid body rotations of the final configuration.\n\nThe left Cauchy–Green deformation tensor, $\\mathbf{B}$, is a spatial tensor defined as:\n$$\n\\mathbf{B} = \\mathbf{F} \\mathbf{F}^\\top\n$$\nIt is also known as the Finger tensor.\n\nThe Green–Lagrange strain tensor, $\\mathbf{E}$, is a material tensor that quantifies the strain relative to the reference configuration. It is defined as:\n$$\n\\mathbf{E} = \\frac{1}{2}(\\mathbf{C} - \\mathbf{I})\n$$\nwhere $\\mathbf{I}$ is the second-order identity tensor.\n\nThe Euler–Almansi strain tensor, $\\mathbf{e}$, is a spatial tensor that quantifies strain relative to the current configuration. It is defined as:\n$$\n\\mathbf{e} = \\frac{1}{2}(\\mathbf{I} - \\mathbf{B}^{-1})\n$$\n\nThe problem specifies a homogeneous uniaxial stretch along the first basis direction, for which the deformation gradient $\\mathbf{F}$ is given in matrix form as:\n$$\n\\mathbf{F} = \\begin{pmatrix} \\lambda & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\nwhere $\\lambda > 0$.\n\nWe now proceed to calculate each tensor.\n\n**1. Right Cauchy–Green Deformation Tensor, $\\mathbf{C}$**\nUsing the definition $\\mathbf{C} = \\mathbf{F}^\\top \\mathbf{F}$, and noting that the given $\\mathbf{F}$ is a diagonal (and thus symmetric) matrix such that $\\mathbf{F}^\\top = \\mathbf{F}$:\n$$\n\\mathbf{C} = \\mathbf{F}^\\top \\mathbf{F} = \\mathbf{F}^2 = \\begin{pmatrix} \\lambda & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} \\lambda & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} = \\begin{pmatrix} \\lambda^2 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\nThe only nonzero components are on the diagonal: $C_{11} = \\lambda^2$, $C_{22} = 1$, and $C_{33} = 1$. Physically, the diagonal component $C_{II}$ (no summation implied) represents the square of the stretch for a material line element originally oriented along the $I$-th basis vector. Here, $C_{11} = \\lambda^2$ is the squared stretch in the first direction, while $C_{22} = C_{33} = 1$ indicates no change in length for elements initially in the second and third directions.\n\n**2. Left Cauchy–Green Deformation Tensor, $\\mathbf{B}$**\nUsing the definition $\\mathbf{B} = \\mathbf{F} \\mathbf{F}^\\top$:\n$$\n\\mathbf{B} = \\mathbf{F} \\mathbf{F}^\\top = \\begin{pmatrix} \\lambda & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} \\lambda & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} = \\begin{pmatrix} \\lambda^2 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\nFor this specific deformation, where $\\mathbf{F}$ is symmetric, the left and right Cauchy–Green tensors are identical: $\\mathbf{B} = \\mathbf{C}$. The physical interpretation is analogous, but $\\mathbf{B}$ is associated with the spatial configuration.\n\n**3. Green–Lagrange Strain Tensor, $\\mathbf{E}$**\nUsing the definition $\\mathbf{E} = \\frac{1}{2}(\\mathbf{C} - \\mathbf{I})$:\n$$\n\\mathbf{E} = \\frac{1}{2} \\left( \\begin{pmatrix} \\lambda^2 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} - \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} \\right) = \\frac{1}{2} \\begin{pmatrix} \\lambda^2 - 1 & 0 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0 \\end{pmatrix}\n$$\nThe only nonzero component is $E_{11} = \\frac{1}{2}(\\lambda^2 - 1)$. This component is the Lagrangian normal strain in the first direction. It measures the change in squared length of a material element referred to its original squared length. For a material line element $d\\mathbf{S} = dS_1 \\mathbf{E}_1$, the change in its squared length is $ds^2 - dS_1^2 = (\\lambda^2 dS_1^2) - dS_1^2 = (\\lambda^2 - 1)dS_1^2$. The definition of Lagrangian strain states $ds^2 - dS_1^2 = 2E_{11} dS_1^2$, which confirms our result for $E_{11}$.\n\n**4. Euler–Almansi Strain Tensor, $\\mathbf{e}$**\nUsing the definition $\\mathbf{e} = \\frac{1}{2}(\\mathbf{I} - \\mathbf{B}^{-1})$, we first find the inverse of $\\mathbf{B}$:\n$$\n\\mathbf{B}^{-1} = \\begin{pmatrix} \\lambda^2 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}^{-1} = \\begin{pmatrix} \\frac{1}{\\lambda^2} & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} = \\begin{pmatrix} \\lambda^{-2} & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\nNow we compute $\\mathbf{e}$:\n$$\n\\mathbf{e} = \\frac{1}{2} \\left( \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} - \\begin{pmatrix} \\lambda^{-2} & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} \\right) = \\frac{1}{2} \\begin{pmatrix} 1 - \\lambda^{-2} & 0 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0 \\end{pmatrix}\n$$\nThe only nonzero component is $e_{11} = \\frac{1}{2}(1 - \\lambda^{-2})$. This quantity is the Eulerian normal strain in the first direction. It measures the change in squared length of a material element referred to its final squared length. For a line element that is aligned with the first basis vector in the spatial configuration, $d\\mathbf{s} = ds_1 \\mathbf{e}_1$, the definition of Eulerian strain states $ds_1^2 - dS^2 = 2e_{11} ds_1^2$, which is consistent with our result.\n\nThe problem asks for the closed-form expression for the Lagrangian normal strain component $E_{11}$ as a function of $\\lambda$. As derived above, this is $E_{11} = \\frac{1}{2}(\\lambda^2 - 1)$.", "answer": "$$\n\\boxed{\\frac{1}{2}(\\lambda^{2} - 1)}\n$$", "id": "3565015"}, {"introduction": "A central principle in continuum mechanics is that the constitutive response of a material must be independent of any rigid body motion superposed on the deformation. This exercise [@problem_id:3565006] guides you to prove this principle of material frame-indifference, or objectivity, from first principles. By analyzing how a simple shear deformation is affected by a superposed rotation and translation, you will discover which kinematic quantities, such as the Right Cauchy-Green tensor $\\mathbf{C}$ and its invariants, are objective and thus suitable for formulating physical laws.", "problem": "Consider a body undergoing a smooth motion from a reference configuration, with material point position $\\mathbf{X}$ mapping to current position $\\mathbf{x}(\\mathbf{X},t)$ at time $t$. The deformation gradient is defined as $\\mathbf{F}(\\mathbf{X},t)=\\nabla_{\\mathbf{X}}\\mathbf{x}(\\mathbf{X},t)$. A simple shear in the $\\mathbf{e}_{1}$ direction with shear along $\\mathbf{e}_{2}$ is prescribed by\n$$\n\\mathbf{F}(t)=\\begin{pmatrix}\n1 & \\gamma(t) & 0\\\\\n0 & 1 & 0\\\\\n0 & 0 & 1\n\\end{pmatrix},\n$$\nwhere $\\gamma(t)$ is a known, sufficiently smooth scalar function of time. A superposed rigid body motion is applied, defined by\n$$\n\\mathbf{x}^{*}(\\mathbf{X},t)=\\mathbf{Q}(t)\\,\\mathbf{x}(\\mathbf{X},t)+\\mathbf{c}(t),\n$$\nwhere $\\mathbf{Q}(t)$ is a proper orthogonal rotation ($\\mathbf{Q}(t)^{\\top}\\mathbf{Q}(t)=\\mathbf{I}$ and $\\det \\mathbf{Q}(t)=1$) and $\\mathbf{c}(t)$ is a spatially uniform translation vector, both smooth in time. Starting from the fundamental definitions above and without invoking any pre-stated transformation formulas, derive the transformed deformation gradient $\\mathbf{F}^{*}(t)$ and the transformed Right Cauchy-Green deformation tensor (RCG), $\\mathbf{C}^{*}(t)=\\mathbf{F}^{*}(t)^{\\top}\\mathbf{F}^{*}(t)$. Using the definitions of the principal invariants of $\\mathbf{C}$,\n$$\nI_{1}(\\mathbf{C})=\\mathrm{tr}\\,\\mathbf{C},\\quad\nI_{2}(\\mathbf{C})=\\tfrac{1}{2}\\left[(\\mathrm{tr}\\,\\mathbf{C})^{2}-\\mathrm{tr}\\left(\\mathbf{C}^{2}\\right)\\right],\\quad\nI_{3}(\\mathbf{C})=\\det\\mathbf{C},\n$$\nidentify which of these invariants remain unchanged under the given superposed motion and justify your conclusion from first principles. Finally, evaluate the analytic expression of $I_{1}(\\mathbf{C}^{*}(t))$ in terms of $\\gamma(t)$ using the prescribed simple shear. Report your final answer as a single closed-form expression for $I_{1}(\\mathbf{C}^{*}(t))$. No rounding is required and no units are needed.", "solution": "The solution is developed in four parts as requested by the problem statement.\n\n**Part 1: Derivation of the transformed deformation gradient $\\mathbf{F}^{*}(t)$**\n\nThe transformed deformation gradient, denoted $\\mathbf{F}^{*}$, is defined as the gradient of the transformed position field $\\mathbf{x}^{*}$ with respect to the material coordinates $\\mathbf{X}$.\n$$\n\\mathbf{F}^{*}(\\mathbf{X},t) = \\nabla_{\\mathbf{X}} \\mathbf{x}^{*}(\\mathbf{X},t)\n$$\nSubstituting the given expression for the superposed motion $\\mathbf{x}^{*}(\\mathbf{X},t)=\\mathbf{Q}(t)\\,\\mathbf{x}(\\mathbf{X},t)+\\mathbf{c}(t)$:\n$$\n\\mathbf{F}^{*} = \\nabla_{\\mathbf{X}} \\left[ \\mathbf{Q}(t)\\,\\mathbf{x}(\\mathbf{X},t) + \\mathbf{c}(t) \\right]\n$$\nThe gradient operator is linear, so we can distribute it:\n$$\n\\mathbf{F}^{*} = \\nabla_{\\mathbf{X}} \\left( \\mathbf{Q}(t)\\,\\mathbf{x}(\\mathbf{X},t) \\right) + \\nabla_{\\mathbf{X}} \\mathbf{c}(t)\n$$\nThe rotation tensor $\\mathbf{Q}(t)$ and the translation vector $\\mathbf{c}(t)$ are specified as spatially uniform, meaning they do not depend on the material position $\\mathbf{X}$. Therefore, they can be treated as constants with respect to the $\\nabla_{\\mathbf{X}}$ operator.\nThe gradient of the translation vector is zero:\n$$\n\\nabla_{\\mathbf{X}} \\mathbf{c}(t) = \\mathbf{0}\n$$\nFor the first term, since $\\mathbf{Q}(t)$ does not depend on $\\mathbf{X}$, we can write:\n$$\n\\nabla_{\\mathbf{X}} \\left( \\mathbf{Q}(t)\\,\\mathbf{x}(\\mathbf{X},t) \\right) = \\mathbf{Q}(t) \\left( \\nabla_{\\mathbf{X}}\\mathbf{x}(\\mathbf{X},t) \\right)\n$$\nBy definition, $\\mathbf{F}(\\mathbf{X},t) = \\nabla_{\\mathbf{X}}\\mathbf{x}(\\mathbf{X},t)$. Thus, we obtain the transformation rule for the deformation gradient:\n$$\n\\mathbf{F}^{*}(t) = \\mathbf{Q}(t) \\mathbf{F}(t)\n$$\n\n**Part 2: Derivation of the transformed Right Cauchy-Green deformation tensor $\\mathbf{C}^{*}(t)$**\n\nThe transformed Right Cauchy-Green deformation tensor $\\mathbf{C}^{*}$ is defined as $\\mathbf{C}^{*}(t) = \\mathbf{F}^{*}(t)^{\\top}\\mathbf{F}^{*}(t)$. Substituting the result from Part 1:\n$$\n\\mathbf{C}^{*}(t) = \\left( \\mathbf{Q}(t) \\mathbf{F}(t) \\right)^{\\top} \\left( \\mathbf{Q}(t) \\mathbf{F}(t) \\right)\n$$\nUsing the property of the transpose of a matrix product, $(\\mathbf{A}\\mathbf{B})^{\\top} = \\mathbf{B}^{\\top}\\mathbf{A}^{\\top}$:\n$$\n\\mathbf{C}^{*}(t) = \\mathbf{F}(t)^{\\top} \\mathbf{Q}(t)^{\\top} \\mathbf{Q}(t) \\mathbf{F}(t)\n$$\nThe problem states that $\\mathbf{Q}(t)$ is an orthogonal tensor, for which $\\mathbf{Q}(t)^{\\top}\\mathbf{Q}(t) = \\mathbf{I}$, where $\\mathbf{I}$ is the identity tensor. Substituting this property:\n$$\n\\mathbf{C}^{*}(t) = \\mathbf{F}(t)^{\\top} \\mathbf{I} \\mathbf{F}(t) = \\mathbf{F}(t)^{\\top} \\mathbf{F}(t)\n$$\nBy definition, the original Right Cauchy-Green tensor is $\\mathbf{C}(t) = \\mathbf{F}(t)^{\\top}\\mathbf{F}(t)$. Therefore, we find that:\n$$\n\\mathbf{C}^{*}(t) = \\mathbf{C}(t)\n$$\n\n**Part 3: Identification of unchanged invariants**\n\nThe principal invariants $I_{1}$, $I_{2}$, and $I_{3}$ are scalar functions of the components of the tensor $\\mathbf{C}$. As we have proven from first principles in Part 2, the Right Cauchy-Green tensor is itself unchanged by a superposed rigid body motion, i.e., $\\mathbf{C}^{*} = \\mathbf{C}$.\nSince the invariants are functions solely of the tensor $\\mathbf{C}$, and $\\mathbf{C}$ does not change, the invariants must also remain unchanged.\n- $I_{1}(\\mathbf{C}^{*}) = \\mathrm{tr}(\\mathbf{C}^{*}) = \\mathrm{tr}(\\mathbf{C}) = I_{1}(\\mathbf{C})$\n- $I_{2}(\\mathbf{C}^{*}) = \\tfrac{1}{2}\\left[(\\mathrm{tr}\\,\\mathbf{C}^{*})^{2}-\\mathrm{tr}((\\mathbf{C}^{*})^{2})\\right] = \\tfrac{1}{2}\\left[(\\mathrm{tr}\\,\\mathbf{C})^{2}-\\mathrm{tr}(\\mathbf{C}^{2})\\right] = I_{2}(\\mathbf{C})$\n- $I_{3}(\\mathbf{C}^{*}) = \\det(\\mathbf{C}^{*}) = \\det(\\mathbf{C}) = I_{3}(\\mathbf{C})$\nTherefore, all three principal invariants $I_{1}$, $I_{2}$, and $I_{3}$ remain unchanged under the given superposed motion. This demonstrates the material frame-indifference (objectivity) of the Right Cauchy-Green tensor and its invariants.\n\n**Part 4: Evaluation of the analytic expression for $I_{1}(\\mathbf{C}^{*}(t))$**\n\nFrom Part 3, we know that $I_{1}(\\mathbf{C}^{*}(t)) = I_{1}(\\mathbf{C}(t))$. We proceed to calculate $I_{1}(\\mathbf{C}(t))$ using the prescribed simple shear deformation.\nThe deformation gradient is given as:\n$$\n\\mathbf{F}(t)=\\begin{pmatrix} 1 & \\gamma(t) & 0\\\\ 0 & 1 & 0\\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\nIts transpose is:\n$$\n\\mathbf{F}(t)^{\\top}=\\begin{pmatrix} 1 & 0 & 0\\\\ \\gamma(t) & 1 & 0\\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\nNow, we compute $\\mathbf{C}(t) = \\mathbf{F}(t)^{\\top}\\mathbf{F}(t)$:\n$$\n\\mathbf{C}(t) = \\begin{pmatrix} 1 & 0 & 0\\\\ \\gamma(t) & 1 & 0\\\\ 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} 1 & \\gamma(t) & 0\\\\ 0 & 1 & 0\\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\nPerforming the matrix multiplication:\n$$\n\\mathbf{C}(t) = \\begin{pmatrix}\n1\\cdot 1 + 0\\cdot 0 + 0\\cdot 0 & 1\\cdot\\gamma(t) + 0\\cdot 1 + 0\\cdot 0 & 1\\cdot 0 + 0\\cdot 0 + 0\\cdot 1 \\\\\n\\gamma(t)\\cdot 1 + 1\\cdot 0 + 0\\cdot 0 & \\gamma(t)\\cdot\\gamma(t) + 1\\cdot 1 + 0\\cdot 0 & \\gamma(t)\\cdot 0 + 1\\cdot 0 + 0\\cdot 1 \\\\\n0\\cdot 1 + 0\\cdot 0 + 1\\cdot 0 & 0\\cdot\\gamma(t) + 0\\cdot 1 + 1\\cdot 0 & 0\\cdot 0 + 0\\cdot 0 + 1\\cdot 1\n\\end{pmatrix}\n$$\n$$\n\\mathbf{C}(t) = \\begin{pmatrix} 1 & \\gamma(t) & 0 \\\\ \\gamma(t) & \\gamma(t)^{2} + 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\nThe first principal invariant, $I_{1}(\\mathbf{C})$, is the trace of $\\mathbf{C}$:\n$$\nI_{1}(\\mathbf{C}(t)) = \\mathrm{tr}(\\mathbf{C}(t)) = C_{11} + C_{22} + C_{33}\n$$\nSubstituting the diagonal components from the calculated $\\mathbf{C}(t)$ matrix:\n$$\nI_{1}(\\mathbf{C}(t)) = 1 + (\\gamma(t)^{2} + 1) + 1\n$$\n$$\nI_{1}(\\mathbf{C}(t)) = 3 + \\gamma(t)^{2}\n$$\nSince $I_{1}(\\mathbf{C}^{*}(t)) = I_{1}(\\mathbfC(t))$, the final expression is:\n$$\nI_{1}(\\mathbf{C}^{*}(t)) = 3 + \\gamma(t)^{2}\n$$", "answer": "$$\n\\boxed{3 + \\gamma(t)^{2}}\n$$", "id": "3565006"}, {"introduction": "Having established the theoretical framework for deformation measures, we now turn to the practical challenges of their computation, a crucial step in any finite element simulation. This computational exercise [@problem_id:3564980] focuses on the polar decomposition of the deformation gradient, $\\mathbf{F}=\\mathbf{R}\\mathbf{U}$, which is fundamental to many advanced constitutive models. You will compare the robustness of a direct SVD-based method against an iterative Newton-like scheme, specifically investigating their performance and error propagation as the deformation becomes nearly singular ($J = \\det \\mathbf{F} \\to 0$), a common scenario in complex simulations.", "problem": "Consider a deformation gradient matrix $\\mathbf{F} \\in \\mathbb{R}^{3 \\times 3}$ in finite deformation kinematics, with polar decomposition $\\mathbf{F} = \\mathbf{R}\\,\\mathbf{U} = \\mathbf{V}\\,\\mathbf{R}$, where $\\mathbf{R} \\in \\mathbb{R}^{3 \\times 3}$ is a proper orthogonal tensor (rotation with $\\mathbf{R}^{\\top}\\mathbf{R} = \\mathbf{I}$ and $\\det \\mathbf{R} = +1$), $\\mathbf{U} \\in \\mathbb{R}^{3 \\times 3}$ is the right stretch tensor (symmetric positive definite), and $\\mathbf{V} \\in \\mathbb{R}^{3 \\times 3}$ is the left stretch tensor (symmetric positive definite). Let $J = \\det \\mathbf{F}$ denote the Jacobian determinant. The goal is to assess the robustness of two alternative strategies to compute the rotation tensor $\\mathbf{R}$ in the polar decomposition as $J \\to 0^{+}$ (near-singular $\\mathbf{F}$), and to quantify the propagation of errors in $\\mathbf{R}$ into the computed stretch tensors $\\mathbf{U}$ and $\\mathbf{V}$.\n\nStarting from the core definitions of the polar decomposition and the orthogonality condition for $\\mathbf{R}$, and from the fact that for an orientation-preserving deformation one has $J > 0$, proceed as follows:\n\n- Strategy A (Singular Value Decomposition based): Use a decomposition of $\\mathbf{F}$ into orthogonal and diagonal factors to construct a reference solution $(\\mathbf{R}_{\\mathrm{svd}}, \\mathbf{U}_{\\mathrm{ref}}, \\mathbf{V}_{\\mathrm{ref}})$ that is robust even when $\\mathbf{F}$ is ill-conditioned but invertible. Do not assume any particular formula beyond the existence of such a decomposition into orthogonal matrices and a diagonal matrix with nonnegative entries.\n- Strategy B (Iterated Newton method on the orthogonality constraint): Starting from $\\mathbf{X}_{0} = \\mathbf{F}$, design an iteration that converges to the nearest orthogonal matrix $\\mathbf{R}$ in the sense of the Frobenius norm by enforcing $\\mathbf{R}^{\\top}\\mathbf{R} = \\mathbf{I}$ as a nonlinear constraint. Use a scaling mechanism within the iteration to maintain numerical stability when $\\mathbf{F}$ is ill-conditioned, and stop when the orthogonality defect becomes sufficiently small.\n\nHaving obtained $\\mathbf{R}_{\\mathrm{svd}}$ via Strategy A and $\\mathbf{R}_{\\mathrm{new}}$ via Strategy B, define the following derived quantities for Strategy B:\n- $\\mathbf{U}_{\\mathrm{new}} = \\mathbf{R}_{\\mathrm{new}}^{\\top}\\mathbf{F}$ and $\\mathbf{V}_{\\mathrm{new}} = \\mathbf{F}\\,\\mathbf{R}_{\\mathrm{new}}^{\\top}$.\n- The symmetric parts $\\operatorname{sym}(\\mathbf{U}_{\\mathrm{new}}) = \\tfrac{1}{2}\\left(\\mathbf{U}_{\\mathrm{new}} + \\mathbf{U}_{\\mathrm{new}}^{\\top}\\right)$ and $\\operatorname{sym}(\\mathbf{V}_{\\mathrm{new}}) = \\tfrac{1}{2}\\left(\\mathbf{V}_{\\mathrm{new}} + \\mathbf{V}_{\\mathrm{new}}^{\\top}\\right)$.\n\nUse the Frobenius norm $\\|\\mathbf{A}\\|_{F} = \\sqrt{\\operatorname{tr}(\\mathbf{A}^{\\top}\\mathbf{A})}$ for all matrix norms. Quantify robustness and error propagation via the following metrics:\n- Orthogonality defect of $\\mathbf{R}$: $e_{R}(\\mathbf{R}) = \\|\\mathbf{R}^{\\top}\\mathbf{R} - \\mathbf{I}\\|_{F}$.\n- Relative error in right stretch due to Strategy B: $e_{U} = \\dfrac{\\|\\operatorname{sym}(\\mathbf{U}_{\\mathrm{new}}) - \\mathbf{U}_{\\mathrm{ref}}\\|_{F}}{\\|\\mathbf{U}_{\\mathrm{ref}}\\|_{F}}$.\n- Relative error in left stretch due to Strategy B: $e_{V} = \\dfrac{\\|\\operatorname{sym}(\\mathbf{V}_{\\mathrm{new}}) - \\mathbf{V}_{\\mathrm{ref}}\\|_{F}}{\\|\\mathbf{V}_{\\mathrm{ref}}\\|_{F}}$.\n- Symmetric positive definiteness flag for $\\operatorname{sym}(\\mathbf{U}_{\\mathrm{new}})$: $\\text{spd\\_ok} = \\text{True}$ if the minimum eigenvalue of $\\operatorname{sym}(\\mathbf{U}_{\\mathrm{new}})$ is strictly positive, and $\\text{False}$ otherwise.\n\nConstruct $\\mathbf{F}$ for each test case in the suite as\n$$\n\\mathbf{F} = \\mathbf{Q}_{1}\\,\\mathrm{diag}(\\sigma_{1},\\sigma_{2},\\sigma_{3})\\,\\mathbf{Q}_{2}^{\\top},\n$$\nwhere $\\mathbf{Q}_{1}$ and $\\mathbf{Q}_{2}$ are proper orthogonal matrices built from Z–Y–X extrinsic rotations composed as $\\mathbf{Q}(\\alpha,\\beta,\\gamma) = \\mathbf{R}_{z}(\\gamma)\\,\\mathbf{R}_{y}(\\beta)\\,\\mathbf{R}_{x}(\\alpha)$ with angles in radians, and\n$$\n\\mathbf{R}_{x}(\\alpha) = \\begin{bmatrix} 1 & 0 & 0 \\\\ 0 & \\cos\\alpha & -\\sin\\alpha \\\\ 0 & \\sin\\alpha & \\cos\\alpha \\end{bmatrix},\\quad\n\\mathbf{R}_{y}(\\beta) = \\begin{bmatrix} \\cos\\beta & 0 & \\sin\\beta \\\\ 0 & 1 & 0 \\\\ -\\sin\\beta & 0 & \\cos\\beta \\end{bmatrix},\\quad\n\\mathbf{R}_{z}(\\gamma) = \\begin{bmatrix} \\cos\\gamma & -\\sin\\gamma & 0 \\\\ \\sin\\gamma & \\cos\\gamma & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}.\n$$\n\nTest suite (angles in radians):\n- Case $1$: $(\\sigma_{1},\\sigma_{2},\\sigma_{3}) = (1.2,\\,0.9,\\,10^{-1})$, $\\mathbf{Q}_{1} = \\mathbf{Q}(0.3,\\,-0.5,\\,0.8)$, $\\mathbf{Q}_{2} = \\mathbf{Q}(0.2,\\,0.4,\\,-0.6)$.\n- Case $2$: $(\\sigma_{1},\\sigma_{2},\\sigma_{3}) = (1.4,\\,0.7,\\,10^{-3})$, $\\mathbf{Q}_{1} = \\mathbf{Q}(0.7,\\,0.1,\\,-0.4)$, $\\mathbf{Q}_{2} = \\mathbf{Q}(-0.5,\\,0.9,\\,0.3)$.\n- Case $3$: $(\\sigma_{1},\\sigma_{2},\\sigma_{3}) = (1.1,\\,0.8,\\,10^{-6})$, $\\mathbf{Q}_{1} = \\mathbf{Q}(-0.2,\\,0.6,\\,1.0)$, $\\mathbf{Q}_{2} = \\mathbf{Q}(0.9,\\,-0.7,\\,0.5)$.\n- Case $4$: $(\\sigma_{1},\\sigma_{2},\\sigma_{3}) = (2.0,\\,0.5,\\,10^{-8})$, $\\mathbf{Q}_{1} = \\mathbf{Q}(0.4,\\,-0.9,\\,0.2)$, $\\mathbf{Q}_{2} = \\mathbf{Q}(-0.3,\\,0.8,\\,-1.1)$.\n- Case $5$: $(\\sigma_{1},\\sigma_{2},\\sigma_{3}) = (5.0,\\,10^{-2},\\,10^{-8})$, $\\mathbf{Q}_{1} = \\mathbf{Q}(1.0,\\,-1.2,\\,0.4)$, $\\mathbf{Q}_{2} = \\mathbf{Q}(0.6,\\,0.5,\\,-0.9)$.\n\nFor each case:\n1. Build $\\mathbf{F}$ from the specified parameters and compute $J = \\det \\mathbf{F}$.\n2. Compute $(\\mathbf{R}_{\\mathrm{svd}}, \\mathbf{U}_{\\mathrm{ref}}, \\mathbf{V}_{\\mathrm{ref}})$ using Strategy A.\n3. Compute $\\mathbf{R}_{\\mathrm{new}}$ using Strategy B with a numerically stable scaling and termination when either the orthogonality defect $e_{R}(\\mathbf{R}_{\\mathrm{new}})$ is below $10^{-12}$ or when successive iterates change by less than $10^{-12}$ in relative Frobenius norm, with a maximum of $100$ iterations.\n4. Form $\\mathbf{U}_{\\mathrm{new}}$, $\\mathbf{V}_{\\mathrm{new}}$, and their symmetric parts.\n5. Report the tuple\n$$\n\\left[J,\\; e_{R}(\\mathbf{R}_{\\mathrm{svd}}),\\; e_{R}(\\mathbf{R}_{\\mathrm{new}}),\\; e_{U},\\; e_{V},\\; \\text{spd\\_ok}\\right]\n$$\nin that order, where $\\text{spd\\_ok}$ is a boolean.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the six-entry list for one test case, in the order of the cases above. There are no physical units in this problem, and all angles must be interpreted in radians. The final output must therefore be a single line of the form\n$[\\text{case1\\_list},\\text{case2\\_list},\\text{case3\\_list},\\text{case4\\_list},\\text{case5\\_list}]$,\nwith each numeric value represented as a floating-point number and each $\\text{spd\\_ok}$ represented as a boolean literal.", "solution": "The user-provided problem is assessed to be valid. It is scientifically grounded in continuum mechanics and numerical linear algebra, is well-posed with all necessary data and clear objectives, and is formulated in an objective, formal language. The problem requires a comparison of two numerical strategies for computing the polar decomposition of a nearly singular deformation gradient tensor, which is a relevant and non-trivial task in computational solid mechanics.\n\n### Scientific Principles and Algorithmic Design\n\nThe problem centers on the polar decomposition of the deformation gradient tensor $\\mathbf{F}$ into a rotation $\\mathbf{R}$ and a symmetric positive-definite stretch tensor $\\mathbf{U}$ (or $\\mathbf{V}$), given by $\\mathbf{F} = \\mathbf{R}\\mathbf{U} = \\mathbf{V}\\mathbf{R}$. We are asked to evaluate two computational strategies for finding $\\mathbf{R}$ when $\\mathbf{F}$ is ill-conditioned, i.e., its Jacobian determinant $J = \\det \\mathbf{F}$ is close to zero.\n\n#### **1. Construction of the Deformation Gradient $\\mathbf{F}$**\n\nFor each test case, the deformation gradient $\\mathbf{F}$ is constructed using its singular value decomposition (SVD) form:\n$$\n\\mathbf{F} = \\mathbf{Q}_{1}\\,\\mathbf{\\Sigma}\\,\\mathbf{Q}_{2}^{\\top}\n$$\nHere, $\\mathbf{\\Sigma} = \\mathrm{diag}(\\sigma_{1}, \\sigma_{2}, \\sigma_{3})$ is a diagonal matrix of singular values, and $\\mathbf{Q}_{1}, \\mathbf{Q}_{2}$ are proper orthogonal matrices (rotations). These rotation matrices are built by composing Z-Y-X extrinsic rotations, $\\mathbf{Q}(\\alpha,\\beta,\\gamma) = \\mathbf{R}_{z}(\\gamma)\\,\\mathbf{R}_{y}(\\beta)\\,\\mathbf{R}_{x}(\\alpha)$, using the provided definitions for rotations about the Cartesian axes.\n\n#### **2. Strategy A: SVD-based Reference Solution**\n\nThis strategy leverages the SVD of $\\mathbf{F}$ to directly construct the components of the polar decomposition. The SVD of $\\mathbf{F}$ is given by:\n$$\n\\mathbf{F} = \\mathbf{W}\\mathbf{\\Sigma}_{\\mathrm{svd}}\\mathbf{Z}^{\\top}\n$$\nwhere $\\mathbf{W}$ and $\\mathbf{Z}$ are orthogonal matrices and $\\mathbf{\\Sigma}_{\\mathrm{svd}}$ is a diagonal matrix containing the singular values of $\\mathbf{F}$ in descending order. By comparing this with the polar decomposition $\\mathbf{F} = \\mathbf{R}\\mathbf{U}$, we can identify the rotation and stretch tensors.\n\nThe rotation tensor $\\mathbf{R}$ and the right stretch tensor $\\mathbf{U}$ can be expressed as:\n$$\n\\mathbf{R} = \\mathbf{W}\\mathbf{Z}^{\\top}\n$$\n$$\n\\mathbf{U} = \\mathbf{Z}\\mathbf{\\Sigma}_{\\mathrm{svd}}\\mathbf{Z}^{\\top}\n$$\nSince the problem specifies orientation-preserving deformations ($J = \\det \\mathbf{F} > 0$), and the singular values are positive, we must have $\\det(\\mathbf{W}\\mathbf{Z}^\\top) = +1$. Thus, $\\mathbf{R}$ as constructed is a proper rotation. This method is known to be the most robust way to compute the polar decomposition and serves as our reference solution.\n\nThe reference quantities are computed as follows:\n- $\\mathbf{R}_{\\mathrm{svd}} = \\mathbf{W}\\mathbf{Z}^{\\top}$\n- $\\mathbf{U}_{\\mathrm{ref}} = \\mathbf{Z}\\mathbf{\\Sigma}_{\\mathrm{svd}}\\mathbf{Z}^{\\top}$\n- $\\mathbf{V}_{\\mathrm{ref}} = \\mathbf{W}\\mathbf{\\Sigma}_{\\mathrm{svd}}\\mathbf{W}^{\\top}$ (since $\\mathbf{V} = \\mathbf{R}\\mathbf{U}\\mathbf{R}^\\top$)\n\nThese formulations ensure that $\\mathbf{U}_{\\mathrm{ref}}$ and $\\mathbf{V}_{\\mathrm{ref}}$ are perfectly symmetric, as required by their definitions.\n\n#### **3. Strategy B: Iterative Newton-based Method**\n\nThis strategy seeks to find the rotation $\\mathbf{R}$ by iteratively enforcing the orthogonality condition $\\mathbf{R}^\\top\\mathbf{R} = \\mathbf{I}$. A classic and robust iteration for this purpose is a scaled version of the Newton-Schulz method. Starting with $\\mathbf{R}_{0} = \\mathbf{F}$, the iteration proceeds as:\n$$\n\\mathbf{R}_{k+1} = \\frac{1}{2}\\left(\\mu_k \\mathbf{R}_k + \\frac{1}{\\mu_k}\\mathbf{R}_k^{-\\top}\\right)\n$$\nThe scaling factor $\\mu_k$ is crucial for numerical stability, especially when $\\mathbf{R}_k$ is ill-conditioned (as $\\mathbf{R}_0=\\mathbf{F}$ is). A practical and effective choice for the scaling factor, which aims to balance the norms of the two terms in the update, is:\n$$\n\\mu_k = \\left( \\frac{\\|\\mathbf{R}_k^{-1}\\|_F}{\\|\\mathbf{R}_k\\|_F} \\right)^{1/2}\n$$\nThis iteration exhibits quadratic convergence once the iterate is sufficiently close to being orthogonal. The main challenge is the computation of the matrix inverse $\\mathbf{R}_k^{-1}$ at each step, which can be inaccurate if $\\mathbf{R}_k$ is nearly singular. This is precisely the scenario tested in this problem.\n\nThe iteration is terminated when one of the following conditions is met:\n1.  The orthogonality defect $e_R(\\mathbf{R}_{k+1}) = \\|\\mathbf{R}_{k+1}^{\\top}\\mathbf{R}_{k+1} - \\mathbf{I}\\|_{F}$ falls below a tolerance of $10^{-12}$.\n2.  The relative change in successive iterates $\\|\\mathbf{R}_{k+1} - \\mathbf{R}_k\\|_F / \\|\\mathbf{R}_k\\|_F$ is less than $10^{-12}$.\n3.  A maximum of $100$ iterations is reached.\n\n#### **4. Error Quantification**\n\nOnce both $\\mathbf{R}_{\\mathrm{svd}}$ and $\\mathbf{R}_{\\mathrm{new}}$ are computed, we evaluate the performance of Strategy B against the reference from Strategy A.\n\n- The Jacobian determinant $J = \\det \\mathbf{F}$ is computed.\n- The orthogonality defect $e_R$ is evaluated for both $\\mathbf{R}_{\\mathrm{svd}}$ and $\\mathbf{R}_{\\mathrm{new}}$.\n- From $\\mathbf{R}_{\\mathrm{new}}$, we compute $\\mathbf{U}_{\\mathrm{new}} = \\mathbf{R}_{\\mathrm{new}}^{\\top}\\mathbf{F}$ and $\\mathbf{V}_{\\mathrm{new}} = \\mathbf{F}\\mathbf{R}_{\\mathrm{new}}^{\\top}$. These are not guaranteed to be symmetric due to the approximate nature of $\\mathbf{R}_{\\mathrm{new}}$.\n- We therefore take their symmetric parts: $\\operatorname{sym}(\\mathbf{U}_{\\mathrm{new}})$ and $\\operatorname{sym}(\\mathbf{V}_{\\mathrm{new}})$.\n- The relative errors $e_U$ and $e_V$ quantify how well the symmetric parts of the stretch tensors derived from Strategy B match the reference stretch tensors from Strategy A.\n- Finally, the symmetric positive definiteness of the computed stretch $\\operatorname{sym}(\\mathbf{U}_{\\mathrm{new}})$ is checked by verifying if its smallest eigenvalue is strictly positive. This is a critical physical and mathematical requirement for a stretch tensor. Eigenvalues are computed for the symmetric matrix $\\operatorname{sym}(\\mathbf{U}_{\\mathrm{new}})$ using a specialized, stable algorithm.\n\nThis comprehensive analysis will reveal how numerical errors in computing the rotation $\\mathbf{R}$ via an iterative scheme propagate to the stretch tensors, especially in the challenging regime of near-singularity.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational solid mechanics problem comparing SVD and iterative\n    methods for polar decomposition of a nearly singular deformation gradient.\n    \"\"\"\n\n    def build_rotation_matrices(alpha, beta, gamma):\n        \"\"\"Constructs elemental and composite rotation matrices.\"\"\"\n        Rx = np.array([\n            [1, 0, 0],\n            [0, np.cos(alpha), -np.sin(alpha)],\n            [0, np.sin(alpha), np.cos(alpha)]\n        ])\n        Ry = np.array([\n            [np.cos(beta), 0, np.sin(beta)],\n            [0, 1, 0],\n            [-np.sin(beta), 0, np.cos(beta)]\n        ])\n        Rz = np.array([\n            [np.cos(gamma), -np.sin(gamma), 0],\n            [np.sin(gamma), np.cos(gamma), 0],\n            [0, 0, 1]\n        ])\n        return Rz @ Ry @ Rx\n\n    def analyze_case(sigmas, q1_angles, q2_angles):\n        \"\"\"\n        Performs the full analysis for a single test case.\n        \"\"\"\n        # 1. Build F and compute J\n        Q1 = build_rotation_matrices(*q1_angles)\n        Q2 = build_rotation_matrices(*q2_angles)\n        Sigma = np.diag(sigmas)\n        F = Q1 @ Sigma @ Q2.T\n        J = np.linalg.det(F)\n\n        # 2. Strategy A (SVD-based reference solution)\n        W, s, Zt = np.linalg.svd(F)\n        # Ensure proper rotation for R_svd. Since det(F) > 0, det(W)*det(Zt) must be +1.\n        # Numerical inaccuracies might flip the sign, so we correct if necessary.\n        # However, for F with det>0, standard SVD should yield det(W)*det(Z_T) > 0.\n        # So det(W Z^T) = det(W)det(Z^T) = det(W)det(Z) = +1\n        R_svd = W @ Zt\n        # U_ref and V_ref are built from SVD components to ensure perfect symmetry\n        Z = Zt.T\n        U_ref = Z @ np.diag(s) @ Zt\n        V_ref = W @ np.diag(s) @ W.T\n\n        # 3. Strategy B (Iterative Newton method)\n        R_new = F.copy()\n        max_iter = 100\n        tol_defect = 1e-12\n        tol_rel_change = 1e-12\n\n        for _ in range(max_iter):\n            R_old = R_new.copy()\n            norm_R_old = np.linalg.norm(R_old, 'fro')\n            \n            # The core of the scaled iteration\n            try:\n                R_inv = np.linalg.inv(R_old)\n            except np.linalg.LinAlgError:\n                # If matrix becomes singular, iteration fails. \n                # This may happen in extreme cases. Report failure with NaN.\n                R_new = np.full((3, 3), np.nan)\n                break\n\n            norm_R_inv = np.linalg.norm(R_inv, 'fro')\n            \n            if norm_R_old == 0 or norm_R_inv == 0:\n                break # Avoid division by zero\n                \n            mu = (norm_R_inv / norm_R_old)**0.5\n            R_new = 0.5 * (mu * R_old + (1.0 / mu) * R_inv.T)\n\n            # Check convergence\n            rel_change = np.linalg.norm(R_new - R_old, 'fro') / norm_R_old\n            defect = np.linalg.norm(R_new.T @ R_new - np.eye(3), 'fro')\n\n            if rel_change < tol_rel_change or defect < tol_defect:\n                break\n\n        # 4. Form derived quantities and compute metrics\n        # Orthogonality defects\n        e_R_svd = np.linalg.norm(R_svd.T @ R_svd - np.eye(3), 'fro')\n        \n        if np.isnan(R_new).any():\n            e_R_new, e_U, e_V, spd_ok = np.nan, np.nan, np.nan, False\n        else:\n            e_R_new = np.linalg.norm(R_new.T @ R_new - np.eye(3), 'fro')\n    \n            # Derived quantities for Strategy B\n            U_new = R_new.T @ F\n            V_new = F @ R_new.T\n            sym_U_new = 0.5 * (U_new + U_new.T)\n            sym_V_new = 0.5 * (V_new + V_new.T)\n    \n            # Relative errors in stretch tensors\n            norm_U_ref = np.linalg.norm(U_ref, 'fro')\n            norm_V_ref = np.linalg.norm(V_ref, 'fro')\n            \n            e_U = np.linalg.norm(sym_U_new - U_ref, 'fro') / norm_U_ref if norm_U_ref > 0 else 0.0\n            e_V = np.linalg.norm(sym_V_new - V_ref, 'fro') / norm_V_ref if norm_V_ref > 0 else 0.0\n    \n            # SPD check for sym(U_new)\n            try:\n                eigvals = np.linalg.eigvalsh(sym_U_new)\n                spd_ok = np.min(eigvals) > 0\n            except np.linalg.LinAlgError:\n                spd_ok = False\n\n        return [J, e_R_svd, e_R_new, e_U, e_V, spd_ok]\n\n    # Test suite from the problem statement\n    test_cases = [\n        ((1.2, 0.9, 1e-1), (0.3, -0.5, 0.8), (0.2, 0.4, -0.6)),\n        ((1.4, 0.7, 1e-3), (0.7, 0.1, -0.4), (-0.5, 0.9, 0.3)),\n        ((1.1, 0.8, 1e-6), (-0.2, 0.6, 1.0), (0.9, -0.7, 0.5)),\n        ((2.0, 0.5, 1e-8), (0.4, -0.9, 0.2), (-0.3, 0.8, -1.1)),\n        ((5.0, 1e-2, 1e-8), (1.0, -1.2, 0.4), (0.6, 0.5, -0.9)),\n    ]\n\n    results = []\n    for case in test_cases:\n        sigmas, q1_angles, q2_angles = case\n        result_tuple = analyze_case(sigmas, q1_angles, q2_angles)\n        results.append(result_tuple)\n\n    # Format output as a single-line string representation of a list of lists.\n    # str() applied to a list produces the desired '[item1, item2, ...]' format.\n    output_str = \"[\" + \",\".join(map(str, results)) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "3564980"}]}