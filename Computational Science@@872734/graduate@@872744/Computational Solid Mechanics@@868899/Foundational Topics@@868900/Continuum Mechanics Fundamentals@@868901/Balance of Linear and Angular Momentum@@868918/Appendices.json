{"hands_on_practices": [{"introduction": "This exercise brings us back to the foundational definition of linear momentum. Before applying the more complex balance laws, it is crucial to understand how to compute momentum directly from the velocity field of a body. This practice sharpens your skills in setting up and evaluating volume integrals in a continuum mechanics context, reinforcing the direct link between kinematics and momentum. [@problem_id:3546840]", "problem": "Consider a homogeneous three-dimensional solid body of constant current mass density $\\rho$ that, over the time interval $[0, T]$, occupies the fixed rectangular region $\\Omega = [0, a] \\times [0, b] \\times [0, c] \\subset \\mathbb{R}^{3}$. Assume no mass enters or leaves $\\Omega$ in this interval. The velocity field in the current configuration is prescribed for $t \\in [0, T]$ by\n$$\n\\mathbf{v}(\\mathbf{x}, t) = \\big(0,\\ \\alpha\\, t\\, x,\\ \\beta\\, t^{2}\\, x\\big),\n$$\nwhere $\\mathbf{x} = (x, y, z)$, the constant $\\alpha$ has units of $\\mathrm{s}^{-2}$, and the constant $\\beta$ has units of $\\mathrm{s}^{-3}$. The body force per unit mass is spatially uniform and given by\n$$\n\\mathbf{b}(\\mathbf{x}, t) = \\big(0,\\ \\tfrac{\\alpha a}{2},\\ \\beta a\\, t\\big),\n$$\nand the prescribed traction on the boundary $\\partial \\Omega$ is identically zero for all $t \\in [0, T]$. Assume small strains so that the occupied region remains $\\Omega$ and the density $\\rho$ remains constant in time.\n\nUsing only the definition of the total linear momentum $\\mathbf{p}(t)$ of the body, compute the change in total linear momentum $\\Delta \\mathbf{p} = \\mathbf{p}(T) - \\mathbf{p}(0)$ over the interval $[0, T]$. Express your final answer as a $3$-component row vector in Newton-seconds (use $\\mathrm{N\\cdot s}$), in terms of $\\rho$, $\\alpha$, $\\beta$, $a$, $b$, $c$, and $T$. Do not approximate; provide an exact closed-form expression.", "solution": "The problem is first validated to ensure it is self-contained, scientifically grounded, and well-posed.\n\n**Step 1: Extracted Givens**\n- Body: Homogeneous three-dimensional solid.\n- Current mass density: Constant $\\rho$.\n- Time interval: $[0, T]$.\n- Region of occupation: Fixed rectangular domain $\\Omega = [0, a] \\times [0, b] \\times [0, c]$.\n- Mass conservation: No mass flux across the boundary $\\partial \\Omega$.\n- Velocity field: $\\mathbf{v}(\\mathbf{x}, t) = \\big(0,\\ \\alpha\\, t\\, x,\\ \\beta\\, t^{2}\\, x\\big)$ for $\\mathbf{x} = (x, y, z) \\in \\Omega$ and $t \\in [0, T]$.\n- Constants: $\\alpha$ has units of $\\mathrm{s}^{-2}$, $\\beta$ has units of $\\mathrm{s}^{-3}$.\n- Body force per unit mass: $\\mathbf{b}(\\mathbf{x}, t) = \\big(0,\\ \\tfrac{\\alpha a}{2},\\ \\beta a\\, t\\big)$.\n- Boundary condition: Traction on $\\partial \\Omega$ is zero.\n- Assumption: Small strains, implying the region $\\Omega$ and density $\\rho$ are constant over time.\n\n**Step 2: Validation**\nThe problem is well-posed and scientifically consistent within the framework of continuum mechanics.\n- The velocity field $\\mathbf{v}(\\mathbf{x}, t)$ is divergence-free: $\\nabla \\cdot \\mathbf{v} = \\frac{\\partial (0)}{\\partial x} + \\frac{\\partial (\\alpha t x)}{\\partial y} + \\frac{\\partial (\\beta t^2 x)}{\\partial z} = 0 + 0 + 0 = 0$. This is consistent with the assumption of constant density $\\rho$ for an incompressible material, as required by the continuity equation $\\frac{D\\rho}{Dt} + \\rho (\\nabla \\cdot \\mathbf{v}) = 0$.\n- The units of all provided quantities are consistent. For example, the units of the components of $\\mathbf{v}$ are $\\mathrm{m/s}$ and the units of the components of $\\mathbf{b}$ are $\\mathrm{m/s^2}$.\n- The data provided for the velocity field, body force, and boundary conditions are consistent with Cauchy's first law of motion, $\\frac{d\\mathbf{p}}{dt} = \\mathbf{F}_{\\text{ext}}$, where $\\mathbf{F}_{\\text{ext}}$ is the total external force. This confirms the absence of internal contradictions.\n- The task is specific, objective, and solvable using standard principles. The instruction to use only the definition of linear momentum is a clear directive for the solution methodology.\n\n**Verdict:** The problem is valid.\n\n**Step 3: Solution**\nThe problem requires the computation of the change in total linear momentum, $\\Delta \\mathbf{p} = \\mathbf{p}(T) - \\mathbf{p}(0)$, using only the definition of total linear momentum, $\\mathbf{p}(t)$.\n\nThe definition of the total linear momentum $\\mathbf{p}(t)$ of a body occupying a region $\\Omega$ with density $\\rho$ and velocity field $\\mathbf{v}(\\mathbf{x}, t)$ is given by the volume integral:\n$$\n\\mathbf{p}(t) = \\int_{\\Omega} \\rho\\, \\mathbf{v}(\\mathbf{x}, t) \\, dV\n$$\nThe body has a constant mass density $\\rho$ and occupies the fixed rectangular region $\\Omega = [0, a] \\times [0, b] \\times [0, c]$. The velocity field is given as $\\mathbf{v}(\\mathbf{x}, t) = \\big(0,\\ \\alpha\\, t\\, x,\\ \\beta\\, t^{2}\\, x\\big)$.\n\nWe substitute the given expressions into the definition of momentum:\n$$\n\\mathbf{p}(t) = \\int_{0}^{c} \\int_{0}^{b} \\int_{0}^{a} \\rho \\begin{pmatrix} 0 \\\\ \\alpha t x \\\\ \\beta t^2 x \\end{pmatrix} dx\\, dy\\, dz\n$$\nSince $\\rho$, $t$, $\\alpha$, and $\\beta$ are constant with respect to the spatial integration variables $x$, $y$, and $z$, we can treat them as constants during the integration process. We evaluate the integral for each component of the vector $\\mathbf{p}(t) = (p_x(t), p_y(t), p_z(t))$.\n\nFor the $x$-component, $p_x(t)$:\n$$\np_x(t) = \\int_{0}^{c} \\int_{0}^{b} \\int_{0}^{a} \\rho \\cdot 0 \\, dx\\, dy\\, dz = 0\n$$\n\nFor the $y$-component, $p_y(t)$:\n$$\np_y(t) = \\int_{0}^{c} \\int_{0}^{b} \\int_{0}^{a} \\rho (\\alpha t x) \\, dx\\, dy\\, dz\n$$\nBy separating the integrals, we get:\n$$\np_y(t) = \\rho \\alpha t \\left( \\int_{0}^{a} x \\, dx \\right) \\left( \\int_{0}^{b} dy \\right) \\left( \\int_{0}^{c} dz \\right)\n$$\nEvaluating each integral:\n$$\n\\int_{0}^{a} x \\, dx = \\left[ \\frac{x^2}{2} \\right]_{0}^{a} = \\frac{a^2}{2}\n$$\n$$\n\\int_{0}^{b} dy = [y]_{0}^{b} = b\n$$\n$$\n\\int_{0}^{c} dz = [z]_{0}^{c} = c\n$$\nSubstituting these results back into the expression for $p_y(t)$:\n$$\np_y(t) = \\rho \\alpha t \\left( \\frac{a^2}{2} \\right) (b) (c) = \\frac{1}{2} \\rho \\alpha a^2 b c t\n$$\n\nFor the $z$-component, $p_z(t)$:\n$$\np_z(t) = \\int_{0}^{c} \\int_{0}^{b} \\int_{0}^{a} \\rho (\\beta t^2 x) \\, dx\\, dy\\, dz\n$$\nSimilarly, separating the integrals:\n$$\np_z(t) = \\rho \\beta t^2 \\left( \\int_{0}^{a} x \\, dx \\right) \\left( \\int_{0}^{b} dy \\right) \\left( \\int_{0}^{c} dz \\right)\n$$\nThe integrals are the same as before. Substituting their values:\n$$\np_z(t) = \\rho \\beta t^2 \\left( \\frac{a^2}{2} \\right) (b) (c) = \\frac{1}{2} \\rho \\beta a^2 b c t^2\n$$\n\nCombining the components, the total linear momentum as a function of time is:\n$$\n\\mathbf{p}(t) = \\left( 0, \\frac{1}{2} \\rho \\alpha a^2 b c t, \\frac{1}{2} \\rho \\beta a^2 b c t^2 \\right)\n$$\n\nThe problem asks for the change in total linear momentum, $\\Delta \\mathbf{p} = \\mathbf{p}(T) - \\mathbf{p}(0)$.\nFirst, we evaluate $\\mathbf{p}(t)$ at $t=T$:\n$$\n\\mathbf{p}(T) = \\left( 0, \\frac{1}{2} \\rho \\alpha a^2 b c T, \\frac{1}{2} \\rho \\beta a^2 b c T^2 \\right)\n$$\nNext, we evaluate $\\mathbf{p}(t)$ at $t=0$:\n$$\n\\mathbf{p}(0) = \\left( 0, \\frac{1}{2} \\rho \\alpha a^2 b c (0), \\frac{1}{2} \\rho \\beta a^2 b c (0)^2 \\right) = (0, 0, 0)\n$$\nFinally, we compute the difference:\n$$\n\\Delta \\mathbf{p} = \\mathbf{p}(T) - \\mathbf{p}(0) = \\left( 0, \\frac{1}{2} \\rho \\alpha a^2 b c T, \\frac{1}{2} \\rho \\beta a^2 b c T^2 \\right) - (0, 0, 0)\n$$\n$$\n\\Delta \\mathbf{p} = \\left( 0, \\frac{1}{2} \\rho \\alpha a^2 b c T, \\frac{1}{2} \\rho \\beta a^2 b c T^2 \\right)\n$$\nThis is the final answer, expressed as a $3$-component row vector in terms of the given parameters. The units are $\\mathrm{kg \\cdot m/s}$, which is equivalent to $\\mathrm{N \\cdot s}$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0 & \\frac{1}{2} \\rho \\alpha a^2 b c T & \\frac{1}{2} \\rho \\beta a^2 b c T^2\n\\end{pmatrix}\n}\n$$", "id": "3546840"}, {"introduction": "Moving from continuum theory to computational practice, we now explore how balance laws are preserved in a discretized setting. The constant-stress patch test is a fundamental benchmark for any finite element code, verifying that the formulation can exactly represent a simple, uniform state of stress without generating spurious internal forces or moments. This practice demonstrates the discrete analogue of the equilibrium equations, $\\nabla \\cdot \\boldsymbol{\\sigma} = \\boldsymbol{0}$, and is essential for building robust and reliable simulation tools. [@problem_id:3546843]", "problem": "Consider a two-dimensional small-strain continuum occupying a bounded polygonal domain in the plane with coordinates in meters. Assume zero body force and zero inertia so that the balance of linear momentum reduces to $ \\nabla \\cdot \\boldsymbol{\\sigma} = \\boldsymbol{0} $ in the interior, where $ \\boldsymbol{\\sigma} $ is the Cauchy stress tensor. Further assume the Cauchy stress tensor is spatially uniform and symmetric, $ \\boldsymbol{\\sigma} = \\boldsymbol{\\sigma}^{\\top} $, everywhere in the domain. The boundary traction is conceptually taken as $ \\boldsymbol{t} = \\boldsymbol{\\sigma} \\boldsymbol{n} $ so that the continuum is in equilibrium with the uniform stress state.\n\nYou are given meshes composed of linear three-node triangular elements (also called $ P_1 $ elements). For each element with nodes at positions $ (x_1,y_1) $, $ (x_2,y_2) $, and $ (x_3,y_3) $, the shape functions $ N_1 $, $ N_2 $, and $ N_3 $ are linear and satisfy the partition of unity $ \\sum_{i=1}^{3} N_i = 1 $ and linear completeness $ \\sum_{i=1}^{3} x_i N_i = x $, $ \\sum_{i=1}^{3} y_i N_i = y $. The gradient $ \\nabla N_i $ is constant within a linear triangular element. Using the principle of virtual work and the balance of linear and angular momentum, the assembled internal nodal force vector is obtained by integrating the stress against appropriate test functions derived from $ \\nabla N_i $ over each element and summing contributions to shared nodes. Take unit thickness so that forces are in newtons (N) and moments are in newton-meters (N·m).\n\nTask: Implement a constant-stress patch test. For each provided mesh and a specified uniform symmetric Cauchy stress $ \\boldsymbol{\\sigma} $, compute the assembled internal nodal forces. Then verify global conservation by checking:\n- The resultant internal force $ \\boldsymbol{F} = \\sum_{a} \\boldsymbol{f}_a $ is numerically zero (the balance of global linear momentum), where $ \\boldsymbol{f}_a $ is the internal nodal force at node $ a $.\n- The resultant internal moment about the origin, $ M_z = \\sum_{a} (x_a f_{a,y} - y_a f_{a,x}) $, is numerically zero (the balance of global angular momentum), where $ (x_a,y_a) $ are nodal coordinates and $ (f_{a,x}, f_{a,y}) $ are components of $ \\boldsymbol{f}_a $.\n\nYou must treat every triangular element exactly in closed form using the linear shape function gradients (which are constant per element), and you must assemble contributions additively at shared nodes. Use a numerical tolerance of $ 10^{-9} $ N for the resultant force magnitude $ \\| \\boldsymbol{F} \\|_2 $ and $ 10^{-9} $ N·m for $ |M_z| $ to decide whether \"vanish\" holds.\n\nPhysical units:\n- Coordinates are in meters (m).\n- Stress components are in pascals (Pa).\n- Thickness is unity (m).\n- Forces are in newtons (N).\n- Moments are in newton-meters (N·m).\n\nAngle units are not used in this problem.\n\nTest suite:\nFor each test case, you are given a set of nodes, a triangulation (elements), and a uniform symmetric Cauchy stress tensor $ \\boldsymbol{\\sigma} $ in pascals.\n- Test case 1 (happy path, convex square mesh):\n  - Nodes: $ [(0,0), (1,0), (1,1), (0,1)] $.\n  - Elements (0-based node indices): $ [(0,1,2), (0,2,3)] $.\n  - Stress $ \\boldsymbol{\\sigma} $: $ \\begin{bmatrix} 2.0\\times 10^6 & 0.5\\times 10^6 \\\\ 0.5\\times 10^6 & 1.0\\times 10^6 \\end{bmatrix} $ Pa.\n- Test case 2 (skewed quadrilateral mesh):\n  - Nodes: $ [(0.0,0.0), (2.0,0.2), (2.2,1.0), (0.3,1.2)] $.\n  - Elements: $ [(0,1,2), (0,2,3)] $.\n  - Stress $ \\boldsymbol{\\sigma} $: $ \\begin{bmatrix} 0.0 & 3.0\\times 10^6 \\\\ 3.0\\times 10^6 & 0.0 \\end{bmatrix} $ Pa.\n- Test case 3 (single triangle, boundary-like case):\n  - Nodes: $ [(0.0,0.0), (2.0,0.0), (0.0,1.0)] $.\n  - Elements: $ [(0,1,2)] $.\n  - Stress $ \\boldsymbol{\\sigma} $: $ \\begin{bmatrix} 1.0\\times 10^6 & 0.0 \\\\ 0.0 & 1.0\\times 10^6 \\end{bmatrix} $ Pa.\n- Test case 4 (skinny near-degenerate triangles):\n  - Nodes: $ [(0.0,0.0), (1.0,1.0\\times 10^{-8}), (1.0,0.0), (0.5,1.0\\times 10^{-8})] $.\n  - Elements: $ [(0,1,2), (0,2,3)] $.\n  - Stress $ \\boldsymbol{\\sigma} $: $ \\begin{bmatrix} 4.0\\times 10^6 & 2.0\\times 10^6 \\\\ 2.0\\times 10^6 & 0.5\\times 10^6 \\end{bmatrix} $ Pa.\n\nRequired output:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result is itself a two-entry list $ [\\mathrm{force\\_zero}, \\mathrm{moment\\_zero}] $ of booleans, where $ \\mathrm{force\\_zero} $ is true if $ \\| \\boldsymbol{F} \\|_2 < 10^{-9} $ N and $ \\mathrm{moment\\_zero} $ is true if $ |M_z| < 10^{-9} $ N·m. For example: $ [[\\mathrm{true},\\mathrm{true}],[\\mathrm{true},\\mathrm{true}],\\dots] $.", "solution": "The problem statement is a valid exercise in computational solid mechanics, specifically a constant-stress patch test for linear triangular elements. It is scientifically grounded, well-posed, and provides all necessary information to proceed with a solution.\n\nThe solution is derived from the principle of virtual work, which states that the internal virtual work done by stresses is equal to the external virtual work done by applied forces for a body in equilibrium. For a continuum domain $\\Omega$ with no body forces, the internal virtual work $\\delta W_{\\text{int}}$ is given by:\n$$\n\\delta W_{\\text{int}} = \\int_{\\Omega} \\boldsymbol{\\sigma} : \\delta\\boldsymbol{\\varepsilon} \\, dV\n$$\nwhere $\\boldsymbol{\\sigma}$ is the Cauchy stress tensor and $\\delta\\boldsymbol{\\varepsilon}$ is the virtual strain tensor.\n\nIn the finite element method, the domain $\\Omega$ is discretized into elements. Within each element $\\Omega_e$, the displacement field $\\boldsymbol{u}$ is interpolated from the nodal displacements $\\boldsymbol{d}^e$ using a matrix of shape functions $\\boldsymbol{N}$:\n$$\n\\boldsymbol{u}(\\boldsymbol{x}) = \\boldsymbol{N}(\\boldsymbol{x}) \\boldsymbol{d}^e\n$$\nThe small strain tensor $\\boldsymbol{\\varepsilon}$ is related to the nodal displacements by the strain-displacement matrix $\\boldsymbol{B}$:\n$$\n\\boldsymbol{\\varepsilon}(\\boldsymbol{x}) = \\boldsymbol{B}(\\boldsymbol{x}) \\boldsymbol{d}^e\n$$\nThe virtual strain is then $\\delta\\boldsymbol{\\varepsilon} = \\boldsymbol{B} \\delta\\boldsymbol{d}^e$. Substituting this into the virtual work expression and expressing the tensor dot product using Voigt notation (where stresses $\\boldsymbol{\\sigma}$ and strains $\\boldsymbol{\\varepsilon}$ are represented as vectors) gives:\n$$\n\\delta W_{\\text{int}}^e = \\int_{\\Omega_e} (\\delta\\boldsymbol{d}^e)^T \\boldsymbol{B}^T \\boldsymbol{\\sigma} \\, dV = (\\delta\\boldsymbol{d}^e)^T \\left( \\int_{\\Omega_e} \\boldsymbol{B}^T \\boldsymbol{\\sigma} \\, dV \\right)\n$$\nThe internal virtual work is also defined as the work done by the internal nodal forces $\\boldsymbol{f}_{\\text{int}}^e$:\n$$\n\\delta W_{\\text{int}}^e = (\\delta\\boldsymbol{d}^e)^T \\boldsymbol{f}_{\\text{int}}^e\n$$\nBy comparing the two expressions, the elemental internal force vector is:\n$$\n\\boldsymbol{f}_{\\text{int}}^e = \\int_{\\Omega_e} \\boldsymbol{B}^T \\boldsymbol{\\sigma} \\, dV\n$$\nFor a two-dimensional problem with unit thickness $h=1$, the volume integral becomes an area integral. For a linear triangular element, the gradient of the shape functions is constant, making the matrix $\\boldsymbol{B}$ constant. Given that the stress tensor $\\boldsymbol{\\sigma}$ is also uniform, the integral simplifies to:\n$$\n\\boldsymbol{f}_{\\text{int}}^e = A_e \\, h \\, \\boldsymbol{B}^T \\boldsymbol{\\sigma} = A_e \\boldsymbol{B}^T \\boldsymbol{\\sigma}\n$$\nwhere $A_e$ is the area of the element.\n\nA more direct approach avoids forming the full $\\boldsymbol{B}$ matrix. The force on a single node $i$ of an element, $\\boldsymbol{f}_i^e$, can be found by considering its contribution to the virtual work. This results in:\n$$\n\\boldsymbol{f}_i^e = \\int_{A_e} (\\nabla N_i)^T \\boldsymbol{\\sigma} \\, dA\n$$\nwhere $N_i$ is the shape function for node $i$. Since $\\nabla N_i$ and $\\boldsymbol{\\sigma}$ are constant, this is:\n$$\n\\boldsymbol{f}_i^e = A_e (\\nabla N_i)^T \\boldsymbol{\\sigma}\n$$\nThe gradient of the shape function $N_i$ for a linear triangle with vertices $(x_1, y_1)$, $(x_2, y_2)$, and $(x_3, y_3)$ is:\n$$\n\\nabla N_i = \\begin{pmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{pmatrix} = \\frac{1}{2A_e} \\begin{pmatrix} b_i \\\\ c_i \\end{pmatrix}\n$$\nwhere $A_e = \\frac{1}{2} (x_1(y_2-y_3) + x_2(y_3-y_1) + x_3(y_1-y_2))$ is the signed area of the triangle, and the coefficients are:\n$$\n\\begin{array}{lll}\nb_1 = y_2 - y_3 & \\quad & c_1 = x_3 - x_2 \\\\\nb_2 = y_3 - y_1 & \\quad & c_2 = x_1 - x_3 \\\\\nb_3 = y_1 - y_2 & \\quad & c_3 = x_2 - x_1\n\\end{array}\n$$\nThe stress tensor is $\\boldsymbol{\\sigma} = \\begin{pmatrix} \\sigma_{xx} & \\sigma_{xy} \\\\ \\sigma_{yx} & \\sigma_{yy} \\end{pmatrix}$. Since it is symmetric, $\\sigma_{xy} = \\sigma_{yx}$.\nThe force vector $\\boldsymbol{f}_i^e = (f_{ix}^e, f_{iy}^e)^T$ for node $i$ is calculated as:\n$$\n\\boldsymbol{f}_i^e = A_e \\begin{pmatrix} \\frac{\\partial N_i}{\\partial x} & \\frac{\\partial N_i}{\\partial y} \\end{pmatrix} \\begin{pmatrix} \\sigma_{xx} & \\sigma_{xy} \\\\ \\sigma_{xy} & \\sigma_{yy} \\end{pmatrix}\n= A_e \\begin{pmatrix} \\frac{\\partial N_i}{\\partial x} \\sigma_{xx} + \\frac{\\partial N_i}{\\partial y} \\sigma_{xy} \\\\ \\frac{\\partial N_i}{\\partial x} \\sigma_{xy} + \\frac{\\partial N_i}{\\partial y} \\sigma_{yy} \\end{pmatrix}\n$$\nSubstituting the expressions for the gradients:\n$$\nf_{ix}^e = A_e \\left( \\frac{b_i}{2A_e} \\sigma_{xx} + \\frac{c_i}{2A_e} \\sigma_{xy} \\right) = \\frac{1}{2} (b_i \\sigma_{xx} + c_i \\sigma_{xy})\n$$\n$$\nf_{iy}^e = A_e \\left( \\frac{b_i}{2A_e} \\sigma_{xy} + \\frac{c_i}{2A_e} \\sigma_{yy} \\right) = \\frac{1}{2} (b_i \\sigma_{xy} + c_i \\sigma_{yy})\n$$\nThe patch test requires verification of global equilibrium. The total internal force $\\boldsymbol{F}$ is the sum of all assembled nodal forces $\\boldsymbol{f}_a$:\n$$\n\\boldsymbol{F} = \\sum_a \\boldsymbol{f}_a = \\sum_a \\left( \\sum_{e \\in \\text{patch}(a)} \\boldsymbol{f}_{a,e} \\right) = \\sum_e \\sum_{i=1}^3 \\boldsymbol{f}_i^e\n$$\nThe sum of forces for a single element is zero because $\\sum_i b_i = (y_2 - y_3) + (y_3 - y_1) + (y_1 - y_2) = 0$ and $\\sum_i c_i = (x_3 - x_2) + (x_1 - x_3) + (x_2 - x_1) = 0$. Consequently, the total force $\\boldsymbol{F}$ for any patch of elements must be zero.\n\nThe total moment about the origin, $M_z$, is the sum of moments from all assembled nodal forces:\n$$\nM_z = \\sum_a (x_a f_{a,y} - y_a f_{a,x}) = \\sum_e \\sum_{i=1}^3 (x_i f_{iy}^e - y_i f_{ix}^e)\n$$\nwhere $(x_i, y_i)$ are the coordinates of the nodes of element $e$. It can be shown through algebraic manipulation that the moment contribution from a single element is zero: $\\sum_{i=1}^3 (x_i f_{iy}^e - y_i f_{ix}^e) = 0$. This relies on the identities $\\sum y_i b_i = 0$, $\\sum x_i c_i = 0$, and $\\sum x_i b_i = \\sum y_i c_i = 2A_e$. As a result, the total moment $M_z$ for any patch must also be zero.\n\nThe algorithm proceeds as follows for each test case:\n1. Initialize a global force vector for all nodes to zero.\n2. For each triangular element:\n    a. Identify the coordinates $(x_1, y_1), (x_2, y_2), (x_3, y_3)$ of its three nodes.\n    b. Compute the coefficients $b_i$ and $c_i$ for $i=1, 2, 3$.\n    c. Use the derived formulas to calculate the elemental nodal force components $(f_{ix}^e, f_{iy}^e)$ for each of the three nodes.\n    d. Add these elemental forces to the corresponding entries in the global force vector.\n3. After processing all elements, calculate the resultant force $\\boldsymbol{F}$ by summing all vectors in the global force vector. Check if its L2-norm, $\\|\\boldsymbol{F}\\|_2$, is less than the tolerance $10^{-9}$.\n4. Calculate the resultant moment $M_z$ by summing the cross products $\\boldsymbol{r}_a \\times \\boldsymbol{f}_a$ for all nodes. Check if its absolute value, $|M_z|$, is less than the tolerance $10^{-9}$.\n5. Record the boolean results for the force and moment checks.\n\nThis procedure rigorously tests whether the finite element formulation for linear triangles satisfies the fundamental conservation laws of linear and angular momentum for a constant stress state, which is a critical verification test for any finite element code.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs a constant-stress patch test on several 2D triangular meshes.\n    Verifies that the sum of internal nodal forces and the sum of moments of these\n    forces about the origin are numerically zero, as required by the principles\n    of conservation of linear and angular momentum for a body in equilibrium.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"nodes\": [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],\n            \"elements\": [(0, 1, 2), (0, 2, 3)],\n            \"stress\": np.array([[2.0e6, 0.5e6], [0.5e6, 1.0e6]])\n        },\n        {\n            \"nodes\": [(0.0, 0.0), (2.0, 0.2), (2.2, 1.0), (0.3, 1.2)],\n            \"elements\": [(0, 1, 2), (0, 2, 3)],\n            \"stress\": np.array([[0.0, 3.0e6], [3.0e6, 0.0]])\n        },\n        {\n            \"nodes\": [(0.0, 0.0), (2.0, 0.0), (0.0, 1.0)],\n            \"elements\": [(0, 1, 2)],\n            \"stress\": np.array([[1.0e6, 0.0], [0.0, 1.0e6]])\n        },\n        {\n            \"nodes\": [(0.0, 0.0), (1.0, 1.0e-8), (1.0, 0.0), (0.5, 1.0e-8)],\n            \"elements\": [(0, 1, 2), (0, 2, 3)],\n            \"stress\": np.array([[4.0e6, 2.0e6], [2.0e6, 0.5e6]])\n        }\n    ]\n\n    results = []\n    \n    # Set the numerical tolerance.\n    tolerance = 1e-9\n\n    for case in test_cases:\n        nodes = np.array(case[\"nodes\"], dtype=np.float64)\n        elements = np.array(case[\"elements\"], dtype=np.int64)\n        stress = case[\"stress\"]\n        \n        num_nodes = len(nodes)\n        global_forces = np.zeros((num_nodes, 2), dtype=np.float64)\n\n        # Extract stress components\n        s_xx = stress[0, 0]\n        s_yy = stress[1, 1]\n        s_xy = stress[0, 1]  # Stress tensor is symmetric\n\n        # Loop over each element to calculate and assemble internal forces\n        for element_indices in elements:\n            # Get nodal coordinates for the current element\n            p1 = nodes[element_indices[0]]\n            p2 = nodes[element_indices[1]]\n            p3 = nodes[element_indices[2]]\n            \n            x1, y1 = p1\n            x2, y2 = p2\n            x3, y3 = p3\n            \n            # Calculate coefficients for shape function gradients\n            # b_i = y_j - y_k, c_i = x_k - x_j (for i,j,k in cyclic order)\n            b1 = y2 - y3\n            c1 = x3 - x2\n            \n            b2 = y3 - y1\n            c2 = x1 - x3\n            \n            b3 = y1 - y2\n            c3 = x2 - x1\n            \n            b_coeffs = [b1, b2, b3]\n            c_coeffs = [c1, c2, c3]\n\n            # Calculate elemental nodal forces\n            # f_ix = 0.5 * (b_i * sigma_xx + c_i * sigma_xy)\n            # f_iy = 0.5 * (b_i * sigma_xy + c_i * sigma_yy)\n            for i in range(3):\n                node_global_idx = element_indices[i]\n                b_i = b_coeffs[i]\n                c_i = c_coeffs[i]\n                \n                f_ix = 0.5 * (b_i * s_xx + c_i * s_xy)\n                f_iy = 0.5 * (b_i * s_xy + c_i * s_yy)\n                \n                # Assemble into global force vector\n                global_forces[node_global_idx, 0] += f_ix\n                global_forces[node_global_idx, 1] += f_iy\n\n        # --- Verification Step ---\n        \n        # 1. Check balance of linear momentum (resultant force)\n        total_force = np.sum(global_forces, axis=0)\n        force_magnitude = np.linalg.norm(total_force)\n        force_is_zero = force_magnitude < tolerance\n\n        # 2. Check balance of angular momentum (resultant moment about origin)\n        total_moment = 0.0\n        for i in range(num_nodes):\n            x_i, y_i = nodes[i]\n            f_ix, f_iy = global_forces[i]\n            total_moment += x_i * f_iy - y_i * f_ix\n            \n        moment_is_zero = abs(total_moment) < tolerance\n        \n        # Store results as strings 'true'/'false' for output formatting\n        results.append(f\"[{str(force_is_zero).lower()},{str(moment_is_zero).lower()}]\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3546843"}, {"introduction": "In computational dynamics, ensuring that fundamental physical laws are conserved is paramount. This problem delves into a critical aspect of dynamic simulations: the effect of mass matrix discretization on the conservation of angular momentum. By comparing the 'consistent' and 'lumped' mass matrix approaches, you will uncover why the seemingly simpler method can fail to conserve angular momentum and learn a technique to correct for this numerical artifact. [@problem_id:3546856]", "problem": "You are to implement a program that examines how the choice of discrete mass representation in the Finite Element Method (FEM) affects the preservation of angular momentum during free rigid-body rotation, quantifies the error, and applies a correction. The focus is on the balance of linear and angular momentum for an elastic solid under free rotation, in which the kinematics reduce to rigid-body motion and internal elastic forces vanish in the absence of strain.\n\nThe fundamental base assumptions and laws to start from are:\n- Newton’s Second Law in integral form for a continuum: for any region with mass density $\\rho$, body force per unit mass $\\mathbf{b}$, traction $\\mathbf{t}$ on the boundary, and velocity field $\\mathbf{v}$,\n$$\\frac{d}{dt}\\int_{\\Omega}\\rho\\,\\mathbf{v}\\,d\\Omega = \\int_{\\Omega}\\rho\\,\\mathbf{b}\\,d\\Omega + \\int_{\\partial\\Omega}\\mathbf{t}\\,dS.$$\n- Balance of angular momentum in integral form:\n$$\\frac{d}{dt}\\int_{\\Omega}\\rho\\,\\mathbf{x}\\times\\mathbf{v}\\,d\\Omega = \\int_{\\Omega}\\rho\\,\\mathbf{x}\\times\\mathbf{b}\\,d\\Omega + \\int_{\\partial\\Omega}\\mathbf{x}\\times\\mathbf{t}\\,dS.$$\n- Free rigid-body rotation corresponds to $\\mathbf{b}=\\mathbf{0}$ and no boundary tractions, and the velocity field is $\\mathbf{v}(\\mathbf{x})=\\boldsymbol{\\omega}\\times(\\mathbf{x}-\\mathbf{x}_{\\mathrm{cm}})$, where $\\boldsymbol{\\omega}$ is the angular velocity vector and $\\mathbf{x}_{\\mathrm{cm}}$ is the center of mass.\n\nIn a discrete FEM setting for a mesh of linear triangles in a planar body of uniform thickness, the mass matrix can be constructed in two forms:\n- The consistent mass matrix $M$ defined by\n$$M=\\int_{\\Omega}\\rho\\,\\mathbf{N}\\mathbf{N}^{T}\\,d\\Omega,$$\nwith $\\mathbf{N}$ collecting the scalar shape functions, assembled in a block-diagonal manner for vector degrees of freedom.\n- The lumped mass vector $m$ obtained by diagonalizing the consistent mass so that the nodal mass is $m_{i}=\\sum_{j}M_{ij}$ for each scalar degree of freedom.\n\nDiscrete linear momentum for a velocity vector of nodal values $\\mathbf{v}_{h}$ is\n$$\\mathbf{p}_{\\mathrm{cons}} = M\\,\\mathbf{v}_{h},\\quad \\mathbf{p}_{\\mathrm{lump}} = \\mathrm{diag}(m)\\,\\mathbf{v}_{h}.$$\nThe discrete angular momentum about the center of mass $\\mathbf{x}_{\\mathrm{cm}}$ is computed as\n$$\\mathbf{L}_{\\mathrm{cons}} = \\sum_{a=1}^{N}\\left(\\mathbf{x}_{a}-\\mathbf{x}_{\\mathrm{cm}}\\right)\\times\\mathbf{p}_{\\mathrm{cons},a},\\quad \\mathbf{L}_{\\mathrm{lump}} = \\sum_{a=1}^{N}\\left(\\mathbf{x}_{a}-\\mathbf{x}_{\\mathrm{cm}}\\right)\\times\\mathbf{p}_{\\mathrm{lump},a},$$\nwhere $\\mathbf{x}_{a}$ are nodal positions and $\\mathbf{p}_{\\cdot,a}$ are the nodal momentum vectors.\n\nYour program must:\n1. Construct a planar mesh of a rectangle of width $W$ and height $H$, centered at the origin, discretized into $n_{x}\\times n_{y}$ rectangular cells, each split into two triangles. Assume uniform thickness $t$ and uniform density $\\rho$.\n2. Assemble the consistent mass contributions element-wise for linear triangles, using exact integration for the scalar mass submatrix\n$$M_{e}^{\\mathrm{scalar}}=\\rho\\,t\\,\\frac{A_{e}}{12}\\begin{bmatrix}2&1&1\\\\1&2&1\\\\1&1&2\\end{bmatrix},$$\nand block-diagonal assembly for vector degrees of freedom.\n3. Assemble the lumped mass per node using $m_{i} = \\rho\\,t\\,\\sum_{e\\ni i}\\frac{A_{e}}{3}$ (for each scalar degree of freedom, identical for the two in-plane directions).\n4. Initialize nodal velocities to a rigid-body field $\\mathbf{v}(\\mathbf{x})=\\boldsymbol{\\omega}\\times(\\mathbf{x}-\\mathbf{x}_{\\mathrm{cm}})$ with $\\boldsymbol{\\omega}=(0,0,\\omega_{z})$, where $\\omega_{z}$ is specified. Use the mass-weighted center of mass computed from the lumped masses for $\\mathbf{x}_{\\mathrm{cm}}$.\n5. Compute the discrete angular momenta $\\mathbf{L}_{\\mathrm{cons}}$ and $\\mathbf{L}_{\\mathrm{lump}}$ and report the relative error\n$$E=\\frac{\\left\\|\\mathbf{L}_{\\mathrm{lump}}-\\mathbf{L}_{\\mathrm{cons}}\\right\\|_{2}}{\\left\\|\\mathbf{L}_{\\mathrm{cons}}\\right\\|_{2}}.$$\n6. Propose and apply a correction: compute the lumped inertia tensor\n$$I_{\\mathrm{lump}}=\\sum_{a=1}^{N}m_{a}\\left(\\|\\mathbf{r}_{a}\\|^{2}I_{3}-\\mathbf{r}_{a}\\mathbf{r}_{a}^{T}\\right),\\quad \\mathbf{r}_{a}=\\mathbf{x}_{a}-\\mathbf{x}_{\\mathrm{cm}},$$\nsolve for a corrective angular velocity\n$$\\delta\\boldsymbol{\\omega}=I_{\\mathrm{lump}}^{-1}\\left(\\mathbf{L}_{\\mathrm{cons}}-\\mathbf{L}_{\\mathrm{lump}}\\right),$$\napply corrected velocities $\\mathbf{v}_{a}^{\\mathrm{corr}}=\\mathbf{v}_{a}+\\delta\\boldsymbol{\\omega}\\times\\mathbf{r}_{a}$, and recompute $\\mathbf{L}_{\\mathrm{lump}}^{\\mathrm{corr}}$. Report the corrected relative error\n$$E_{\\mathrm{corr}}=\\frac{\\left\\|\\mathbf{L}_{\\mathrm{lump}}^{\\mathrm{corr}}-\\mathbf{L}_{\\mathrm{cons}}\\right\\|_{2}}{\\left\\|\\mathbf{L}_{\\mathrm{cons}}\\right\\|_{2}}.$$\n\nPhysical units: use International System of Units (SI). Input parameters are in meters ($\\mathrm{m}$) for $W$ and $H$, kilograms per cubic meter ($\\mathrm{kg/m^{3}}$) for $\\rho$, meters ($\\mathrm{m}$) for $t$, and radians per second ($\\mathrm{rad/s}$) for $\\omega_{z}$. The outputs are dimensionless floats (relative errors), so no unit conversion is required.\n\nYour program should produce results for the following test suite of parameter values:\n- Test case 1 (happy path, coarse mesh): $W=1.0$, $H=1.0$, $n_{x}=2$, $n_{y}=2$, $\\rho=1.0$, $t=1.0$, $\\omega_{z}=3.0$.\n- Test case 2 (boundary case, single cell): $W=1.0$, $H=1.0$, $n_{x}=1$, $n_{y}=1$, $\\rho=1.0$, $t=1.0$, $\\omega_{z}=2.0$.\n- Test case 3 (anisotropic rectangle, moderate resolution): $W=2.0$, $H=0.5$, $n_{x}=20$, $n_{y}=5$, $\\rho=1.0$, $t=1.0$, $\\omega_{z}=1.5$.\n- Test case 4 (fine mesh, larger spin): $W=1.0$, $H=1.0$, $n_{x}=40$, $n_{y}=40$, $\\rho=1.0$, $t=1.0$, $\\omega_{z}=7.0$.\n\nFor each test case, compute and return a list of two floats $[E,E_{\\mathrm{corr}}]$.\n\nFinal output format: Your program should produce a single line of output containing the results for all test cases as a comma-separated list of lists enclosed in square brackets. For example: \"[[e1_before,e1_after],[e2_before,e2_after],...]\".", "solution": "The problem has been validated and is determined to be a well-posed, scientifically sound problem in computational solid mechanics. It addresses the consequences of different mass lumping schemes on the conservation of angular momentum in a Finite Element Method (FEM) simulation of a rigid body rotation. The provided methodology for quantification and correction is standard and correct. We will proceed with a detailed derivation of the computational steps.\n\nThe solution is implemented by following the sequence of tasks prescribed in the problem statement.\n\n1.  **Mesh Generation**\n    A rectangular domain of width $W$ and height $H$ is centered at the origin, so its corners are at $(\\pm W/2, \\pm H/2)$. This domain is discretized into a grid of $n_{x} \\times n_{y}$ rectangular cells. The nodes of the mesh are located at the grid points. The number of nodes is $N_{nodes}=(n_{x}+1)(n_{y}+1)$. The coordinates $(x_i, y_j)$ of a node at grid position $(i,j)$ are given by:\n    $$x_i = -\\frac{W}{2} + i \\frac{W}{n_x}, \\quad i=0, 1, \\dots, n_x$$\n    $$y_j = -\\frac{H}{2} + j \\frac{H}{n_y}, \\quad j=0, 1, \\dots, n_y$$\n    Each rectangular cell is then subdivided into two linear triangular elements. A consistent diagonal splitting pattern is used across all cells, for example, connecting the bottom-left corner to the top-right corner of each cell. This process generates $2 \\times n_x \\times n_y$ triangular elements. The area of each triangle, $A_e$, is constant for this structured mesh:\n    $$A_e = \\frac{1}{2}\\left(\\frac{W}{n_x}\\right)\\left(\\frac{H}{n_y}\\right)$$\n\n2.  **Consistent Mass Matrix Assembly**\n    The problem involves planar motion, with two degrees of freedom (DOFs) per node (one for each Cartesian direction $x$ and $y$). The total number of DOFs is $N_{dof} = 2 N_{nodes}$. The consistent mass matrix $M$ is assembled from element-level contributions. For a linear triangle, the scalar element mass matrix is given as:\n    $$M_{e}^{\\mathrm{scalar}}=\\rho t \\frac{A_{e}}{12}\\begin{bmatrix}2&1&1\\\\1&2&1\\\\1&1&2\\end{bmatrix}$$\n    where $\\rho$ is the density and $t$ is the thickness. For vector DOFs, assuming no mass coupling between $x$ and $y$ directions, the global mass matrix $M$ is constructed by assembling a scalar mass matrix $M_s$ of size $N_{nodes} \\times N_{nodes}$ and then populating the full $N_{dof} \\times N_{dof}$ matrix such that $M_{2i,2j} = M_{2i+1,2j+1} = (M_s)_{ij}$ and $M_{2i,2j+1} = M_{2i+1,2j} = 0$. The matrix $M_s$ is built using a standard FEM assembly procedure, summing contributions from $M_{e}^{\\mathrm{scalar}}$ for all elements into the global matrix according to node connectivity.\n\n3.  **Lumped Mass Assembly**\n    The lumped mass matrix is a diagonal matrix. The scalar mass $m_a$ at each node $a$ is obtained by summing the entries in the corresponding row of the scalar consistent mass matrix $M_s$:\n    $$m_a = \\sum_{j=1}^{N_{nodes}} (M_s)_{aj}$$\n    This is equivalent to the provided formula $m_a = \\rho t \\sum_{e \\ni a} \\frac{A_e}{3}$. The lumped mass matrix $M_{\\mathrm{lump}}$ is a diagonal matrix of size $N_{dof} \\times N_{dof}$ where the diagonal entries for node $a$ are both equal to $m_a$.\n\n4.  **Velocity Initialization**\n    First, the center of mass $\\mathbf{x}_{\\mathrm{cm}}$ is computed using the lumped nodal masses:\n    $$\\mathbf{x}_{\\mathrm{cm}} = \\frac{\\sum_{a=1}^{N_{nodes}} m_a \\mathbf{x}_a}{\\sum_{a=1}^{N_{nodes}} m_a}$$\n    Due to the symmetry of the mesh and uniform density, the calculated $\\mathbf{x}_{\\mathrm{cm}}$ will be at the origin $(0,0)$. The nodal velocity vector $\\mathbf{v}_h$ is initialized to represent a rigid body rotation with angular velocity $\\boldsymbol{\\omega}=(0,0,\\omega_z)$ about this center of mass. For each node $a$ with position vector $\\mathbf{x}_a$, the velocity $\\mathbf{v}_a$ is:\n    $$\\mathbf{v}_a = \\boldsymbol{\\omega} \\times (\\mathbf{x}_a - \\mathbf{x}_{\\mathrm{cm}})$$\n    In component form, with $\\mathbf{r}_a = \\mathbf{x}_a - \\mathbf{x}_{\\mathrm{cm}} = (r_{ax}, r_{ay})$, the velocity is $\\mathbf{v}_a = (-\\omega_z r_{ay}, \\omega_z r_{ax})$. These values populate the global velocity vector $\\mathbf{v}_h$.\n\n5.  **Angular Momentum and Error Calculation**\n    The nodal linear momentum vectors are computed for both mass representations:\n    $$\\mathbf{p}_{\\mathrm{cons}} = M \\mathbf{v}_h \\quad \\text{and} \\quad \\mathbf{p}_{\\mathrm{lump}} = M_{\\mathrm{lump}} \\mathbf{v}_h$$\n    The total discrete angular momentum about $\\mathbf{x}_{\\mathrm{cm}}$ is then calculated by summing the contributions from each node $a$:\n    $$\\mathbf{L}_{\\mathrm{cons}} = \\sum_{a=1}^{N_{nodes}} \\mathbf{r}_a \\times \\mathbf{p}_{\\mathrm{cons},a}$$\n    $$\\mathbf{L}_{\\mathrm{lump}} = \\sum_{a=1}^{N_{nodes}} \\mathbf{r}_a \\times \\mathbf{p}_{\\mathrm{lump},a}$$\n    where $\\mathbf{p}_{\\cdot,a}$ is the $2$D linear momentum vector for node $a$. For this planar problem, the angular momentum vectors will only have a non-zero $z$-component. The relative error $E$ is computed as:\n    $$E = \\frac{\\|\\mathbf{L}_{\\mathrm{lump}} - \\mathbf{L}_{\\mathrm{cons}}\\|_2}{\\|\\mathbf{L}_{\\mathrm{cons}}\\|_2}$$\n\n6.  **Correction Procedure**\n    To correct the lumped mass angular momentum, a corrective velocity field is applied. First, the lumped inertia tensor $I_{\\mathrm{lump}}$ is computed. It represents the moment of inertia of the system of lumped masses:\n    $$I_{\\mathrm{lump}}=\\sum_{a=1}^{N_{nodes}} m_a (\\|\\mathbf{r}_a\\|^2 I_3 - \\mathbf{r}_a \\mathbf{r}_a^T)$$\n    where $I_3$ is the $3 \\times 3$ identity matrix and $\\mathbf{r}_a$ are $3$D position vectors (with $z=0$). The angular momentum discrepancy $\\Delta \\mathbf{L} = \\mathbf{L}_{\\mathrm{cons}} - \\mathbf{L}_{\\mathrm{lump}}$ is used to find a corrective angular velocity $\\delta \\boldsymbol{\\omega}$ by solving the linear system:\n    $$I_{\\mathrm{lump}} \\, \\delta\\boldsymbol{\\omega} = \\Delta \\mathbf{L}$$\n    The nodal velocities are then corrected:\n    $$\\mathbf{v}_{a}^{\\mathrm{corr}} = \\mathbf{v}_a + \\delta\\boldsymbol{\\omega} \\times \\mathbf{r}_a$$\n    Using the corrected velocity vector $\\mathbf{v}_h^{\\mathrm{corr}}$, the lumped angular momentum is recomputed, yielding $\\mathbf{L}_{\\mathrm{lump}}^{\\mathrm{corr}}$. By construction, $\\mathbf{L}_{\\mathrm{lump}}^{\\mathrm{corr}}$ should be equal to $\\mathbf{L}_{\\mathrm{cons}}$. The final corrected relative error, $E_{\\mathrm{corr}}$, is calculated, which is expected to be near machine precision zero.\n    $$E_{\\mathrm{corr}} = \\frac{\\|\\mathbf{L}_{\\mathrm{lump}}^{\\mathrm{corr}} - \\mathbf{L}_{\\mathrm{cons}}\\|_2}{\\|\\mathbf{L}_{\\mathrm{cons}}\\|_2}$$\nThe results for each test case consist of the pair $[E, E_{\\mathrm{corr}}]$.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    \n    def solve_case(W, H, nx, ny, rho, t, omega_z):\n        \"\"\"\n        Computes the angular momentum errors for a single test case.\n\n        Args:\n            W (float): Width of the rectangle.\n            H (float): Height of the rectangle.\n            nx (int): Number of cells in the x-direction.\n            ny (int): Number of cells in the y-direction.\n            rho (float): Material density.\n            t (float): Thickness of the planar body.\n            omega_z (float): Angular velocity about the z-axis.\n\n        Returns:\n            list[float, float]: A list containing the initial relative error E and the corrected relative error E_corr.\n        \"\"\"\n        # 1. Mesh Generation\n        num_nodes = (nx + 1) * (ny + 1)\n        nodes = np.zeros((num_nodes, 2), dtype=np.float64)\n        node_map = {}\n        k = 0\n        dx, dy = W / nx, H / ny\n        for j in range(ny + 1):\n            for i in range(nx + 1):\n                nodes[k] = [-W/2 + i * dx, -H/2 + j * dy]\n                node_map[(i, j)] = k\n                k += 1\n\n        elements = []\n        for j in range(ny):\n            for i in range(nx):\n                n1 = node_map[(i, j)]\n                n2 = node_map[(i + 1, j)]\n                n3 = node_map[(i + 1, j + 1)]\n                n4 = node_map[(i, j + 1)]\n                elements.append([n1, n2, n3])\n                elements.append([n1, n3, n4])\n\n        Ae = 0.5 * dx * dy\n\n        # 2. Consistent Mass Matrix Assembly\n        M_scalar = np.zeros((num_nodes, num_nodes), dtype=np.float64)\n        M_element_scalar = (rho * t * Ae / 12.0) * np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\n        for el_nodes in elements:\n            for i_local in range(3):\n                for j_local in range(3):\n                    i_global = el_nodes[i_local]\n                    j_global = el_nodes[j_local]\n                    M_scalar[i_global, j_global] += M_element_scalar[i_local, j_local]\n\n        num_dofs = 2 * num_nodes\n        M_consistent = np.zeros((num_dofs, num_dofs), dtype=np.float64)\n        for i in range(num_nodes):\n            for j in range(num_nodes):\n                M_consistent[2*i, 2*j] = M_scalar[i, j]\n                M_consistent[2*i+1, 2*j+1] = M_scalar[i, j]\n\n        # 3. Lumped Mass Assembly\n        m_scalar = np.sum(M_scalar, axis=1)\n        M_lumped_diag = np.zeros(num_dofs, dtype=np.float64)\n        for i in range(num_nodes):\n            M_lumped_diag[2*i] = m_scalar[i]\n            M_lumped_diag[2*i+1] = m_scalar[i]\n\n        # 4. Velocity Initialization\n        # Center of mass is (0,0) by symmetry. Using analytical result avoids float precision issues.\n        x_cm = np.array([0.0, 0.0])\n        r_nodes = nodes - x_cm\n        v_h = np.zeros(num_dofs, dtype=np.float64)\n        for i in range(num_nodes):\n            v_h[2*i]   = -omega_z * r_nodes[i, 1]\n            v_h[2*i+1] =  omega_z * r_nodes[i, 0]\n\n        # 5. Angular Momentum and Error Calculation\n        p_cons = M_consistent @ v_h\n        p_lump = M_lumped_diag * v_h\n\n        L_cons_z = np.sum(r_nodes[:, 0] * p_cons[1::2] - r_nodes[:, 1] * p_cons[0::2])\n        L_lump_z = np.sum(r_nodes[:, 0] * p_lump[1::2] - r_nodes[:, 1] * p_lump[0::2])\n        \n        L_cons_vec = np.array([0.0, 0.0, L_cons_z])\n        L_lump_vec = np.array([0.0, 0.0, L_lump_z])\n        \n        norm_L_cons = np.linalg.norm(L_cons_vec)\n        error = np.linalg.norm(L_lump_vec - L_cons_vec) / norm_L_cons if norm_L_cons > 0 else 0.0\n\n        # 6. Correction Procedure\n        I_lump = np.zeros((3, 3), dtype=np.float64)\n        r_nodes_3d = np.hstack([r_nodes, np.zeros((num_nodes, 1), dtype=np.float64)])\n        for i in range(num_nodes):\n            r_vec = r_nodes_3d[i, :]\n            I_node = m_scalar[i] * (np.dot(r_vec, r_vec) * np.eye(3) - np.outer(r_vec, r_vec))\n            I_lump += I_node\n        \n        delta_L = L_cons_vec - L_lump_vec\n        \n        try:\n            delta_omega_vec = np.linalg.solve(I_lump, delta_L)\n        except np.linalg.LinAlgError:\n            delta_omega_vec = np.zeros(3)\n\n        v_h_corr = np.copy(v_h)\n        for i in range(num_nodes):\n            v_corr_delta = np.cross(delta_omega_vec, r_nodes_3d[i, :])\n            v_h_corr[2*i]   += v_corr_delta[0]\n            v_h_corr[2*i+1] += v_corr_delta[1]\n            \n        p_lump_corr = M_lumped_diag * v_h_corr\n        \n        L_lump_corr_z = np.sum(r_nodes[:, 0] * p_lump_corr[1::2] - r_nodes[:, 1] * p_lump_corr[0::2])\n        L_lump_corr_vec = np.array([0.0, 0.0, L_lump_corr_z])\n\n        error_corr = np.linalg.norm(L_lump_corr_vec - L_cons_vec) / norm_L_cons if norm_L_cons > 0 else 0.0\n            \n        return [error, error_corr]\n\n    test_cases = [\n        (1.0, 1.0, 2, 2, 1.0, 1.0, 3.0),\n        (1.0, 1.0, 1, 1, 1.0, 1.0, 2.0),\n        (2.0, 0.5, 20, 5, 1.0, 1.0, 1.5),\n        (1.0, 1.0, 40, 40, 1.0, 1.0, 7.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(*case)\n        results.append(result)\n\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nsolve()\n```", "id": "3546856"}]}