{"hands_on_practices": [{"introduction": "The foundation of any entropy stable scheme is the entropy conservative numerical flux. This first exercise guides you through the process of constructing such a flux from first principles for the scalar Burgers' equation. By applying the definitions of an entropy pair and the Tadmor discrete entropy conservation condition, you will derive the classic two-point entropy conservative flux, providing a concrete understanding of the algebraic constraints that must be satisfied.", "problem": "Consider the scalar conservation law for viscous-free flow, Burgers’ equation, given by $u_{t} + \\left(f(u)\\right)_{x} = 0$ with $f(u) = \\frac{u^{2}}{2}$, discretized by a discontinuous Galerkin (DG) method. Let an entropy pair $(U(u),q(u))$ be defined by a strictly convex entropy $U(u)$ and an associated entropy flux $q(u)$ satisfying the compatibility condition $q^{\\prime}(u) = v(u)\\,f^{\\prime}(u)$, where the entropy variable is $v(u) = U^{\\prime}(u)$. The Tadmor entropy conservation condition for a two-point numerical flux $f^{ec}(u_{L},u_{R})$ is that the interface contribution satisfies a discrete chain rule using a flux potential $\\psi(u)$, namely $\\left(v_{R} - v_{L}\\right)\\,f^{ec}(u_{L},u_{R}) = \\psi(u_{R}) - \\psi(u_{L})$, where $\\psi(u)$ is defined in terms of the entropy pair and the physical flux using the identity $\\psi(u) = v(u)\\,f(u) - q(u)$.\n\nUsing only the definitions of an entropy pair and the above discrete entropy conservation condition, specialize to the quadratic entropy $U(u) = \\frac{u^{2}}{2}$ and perform the following steps:\n- Derive the entropy flux $q(u)$ from the compatibility condition $q^{\\prime}(u) = v(u)\\,f^{\\prime}(u)$.\n- Define the flux potential $\\psi(u)$ from the entropy pair and the physical flux using the identity $\\psi(u) = v(u)\\,f(u) - q(u)$.\n- Use the Tadmor condition to construct a closed-form expression for the two-point entropy conservative flux $f^{ec}(u_{L},u_{R})$ that is symmetric, consistent, and continuous in the limit $u_{L} \\to u_{R}$.\n\nState your final answer as a single closed-form analytic expression for $f^{ec}(u_{L},u_{R})$. No numerical evaluation or rounding is required.", "solution": "The problem statement is evaluated as valid, as it is scientifically grounded, well-posed, and objective. It presents a standard derivation in the field of numerical methods for hyperbolic conservation laws, specifically the construction of an entropy conservative flux. All definitions and conditions provided are standard in the literature (e.g., Tadmor, 1987).\n\nWe proceed with the derivation as requested. The problem specifies the Burgers' equation, for which the physical flux is $f(u) = \\frac{u^{2}}{2}$. We are to use the specific quadratic entropy function $U(u) = \\frac{u^{2}}{2}$.\n\nFirst, we derive the associated entropy variable $v(u)$ and entropy flux $q(u)$.\nThe entropy variable $v(u)$ is defined as the derivative of the entropy function $U(u)$ with respect to the conserved variable $u$:\n$$v(u) = U^{\\prime}(u) = \\frac{d}{du}\\left(\\frac{u^{2}}{2}\\right) = u$$\nThe entropy flux $q(u)$ is determined by the compatibility condition $q^{\\prime}(u) = v(u)f^{\\prime}(u)$. First, we find the derivative of the physical flux $f(u)$:\n$$f^{\\prime}(u) = \\frac{d}{du}\\left(\\frac{u^{2}}{2}\\right) = u$$\nNow we substitute $v(u)$ and $f^{\\prime}(u)$ into the compatibility condition:\n$$q^{\\prime}(u) = (u)(u) = u^{2}$$\nTo find $q(u)$, we integrate $q^{\\prime}(u)$ with respect to $u$. We can set the constant of integration to zero, as the entropy flux is defined up to an additive constant, which will be eliminated when taking differences:\n$$q(u) = \\int u^{2} \\, du = \\frac{u^{3}}{3}$$\n\nNext, we define the flux potential $\\psi(u)$ using the provided identity $\\psi(u) = v(u)f(u) - q(u)$. We substitute the expressions for $v(u)$, $f(u)$, and $q(u)$:\n$$\\psi(u) = (u)\\left(\\frac{u^{2}}{2}\\right) - \\frac{u^{3}}{3} = \\frac{u^{3}}{2} - \\frac{u^{3}}{3}$$\nCombining the terms gives the expression for the flux potential:\n$$\\psi(u) = \\frac{3u^{3} - 2u^{3}}{6} = \\frac{u^{3}}{6}$$\n\nFinally, we construct the two-point entropy conservative flux $f^{ec}(u_{L}, u_{R})$ using the Tadmor entropy conservation condition:\n$$\\left(v(u_{R}) - v(u_{L})\\right)f^{ec}(u_{L}, u_{R}) = \\psi(u_{R}) - \\psi(u_{L})$$\nSubstituting the expressions we found for $v(u)$ and $\\psi(u)$, we have $v(u_{L}) = u_{L}$, $v(u_{R}) = u_{R}$, $\\psi(u_{L}) = \\frac{u_{L}^{3}}{6}$, and $\\psi(u_{R}) = \\frac{u_{R}^{3}}{6}$. The condition becomes:\n$$\\left(u_{R} - u_{L}\\right)f^{ec}(u_{L}, u_{R}) = \\frac{u_{R}^{3}}{6} - \\frac{u_{L}^{3}}{6}$$\nTo find the flux, we solve for $f^{ec}(u_{L}, u_{R})$ by dividing by $(u_{R} - u_{L})$, assuming $u_{R} \\neq u_{L}$:\n$$f^{ec}(u_{L}, u_{R}) = \\frac{1}{u_{R} - u_{L}}\\left(\\frac{u_{R}^{3} - u_{L}^{3}}{6}\\right) = \\frac{u_{R}^{3} - u_{L}^{3}}{6(u_{R} - u_{L})}$$\nTo obtain a closed-form expression that is continuous and well-defined even when $u_{L} = u_{R}$, we use the algebraic identity for the difference of cubes, $a^{3} - b^{3} = (a-b)(a^{2} + ab + b^{2})$:\n$$u_{R}^{3} - u_{L}^{3} = (u_{R} - u_{L})(u_{R}^{2} + u_{R}u_{L} + u_{L}^{2})$$\nSubstituting this factored form into the expression for the flux:\n$$f^{ec}(u_{L}, u_{R}) = \\frac{(u_{R} - u_{L})(u_{R}^{2} + u_{R}u_{L} + u_{L}^{2})}{6(u_{R} - u_{L})}$$\nCanceling the $(u_{R} - u_{L})$ term, we arrive at the final expression for the entropy conservative flux:\n$$f^{ec}(u_{L}, u_{R}) = \\frac{u_{L}^{2} + u_{L}u_{R} + u_{R}^{2}}{6}$$\nThis expression is symmetric, as swapping $u_{L}$ and $u_{R}$ leaves the expression unchanged. It is also consistent, since in the limit $u_{L} \\to u_{R} = u$, we have:\n$$f^{ec}(u, u) = \\frac{u^{2} + u \\cdot u + u^{2}}{6} = \\frac{3u^{2}}{6} = \\frac{u^{2}}{2} = f(u)$$\nThis fulfills all the requirements of the problem.", "answer": "$$\\boxed{\\frac{u_{L}^{2} + u_{L}u_{R} + u_{R}^{2}}{6}}$$", "id": "3384448"}, {"introduction": "An entropy conservative flux is necessary but not sufficient for creating an entropy conservative scheme; the discretization of the volume integrals must also respect the entropy balance. This practice investigates the crucial role of quadrature rules in the discrete entropy identity, focusing on how underintegration can introduce spurious, non-physical entropy production within an element. By analyzing the polynomial degree of the entropy residual and implementing a numerical test, you will quantify this effect and establish the minimum quadrature accuracy needed to avoid it.", "problem": "You will investigate how volume underintegration in nodal spectral and discontinuous Galerkin discretizations affects the discrete entropy balance for one-dimensional scalar conservation laws. Consider the scalar conservation law $u_t + f(u)_x = 0$ on the reference interval $[-1,1]$. Let $U(u)$ denote a strictly convex mathematical entropy and let $F(u)$ denote the associated entropy flux satisfying $F'(u) = U'(u) f'(u)$. For sufficiently smooth $u$, the continuous entropy identity reads $U(u)_t + F(u)_x = 0$, and after integration over $[-1,1]$, one obtains $\\frac{d}{dt} \\int_{-1}^{1} U(u) \\, dx + \\left[ F(u) \\right]_{x=-1}^{x=1} = 0$. In a nodal spectral or discontinuous Galerkin discretization, the semi-discrete entropy balance depends on how the volume term $\\int_{-1}^{1} U'(u) \\, f(u)_x \\, dx$ is approximated. When the volume integral is computed by an underintegrated quadrature, spurious entropy production may result.\n\nYour tasks are:\n- Derive, from the fundamental properties of the scalar conservation law and the chain rule, a bound on the polynomial degree of the integrand appearing in the discrete volume contribution to the entropy balance when $u$ is approximated by a polynomial of degree $p$ and the nonlinear flux is Burgers flux $f(u) = \\frac{1}{2} u^2$ with the quadratic entropy $U(u) = \\frac{1}{2} u^2$. Use this to infer a minimum quadrature exactness requirement in terms of $p$ that suffices to avoid spurious entropy production in the volume contribution.\n- Quantify the effect of underintegration using two families of element-volume quadrature rules:\n  1. Gauss–Legendre quadrature with $N$ points on $[-1,1]$, which is exact for polynomials up to degree $2N - 1$.\n  2. Gauss–Lobatto–Legendre quadrature with $N$ points on $[-1,1]$, which is exact for polynomials up to degree $2N - 3$.\n- Implement a program that, for a given polynomial degree $p$, constructs a representative polynomial approximation $u_p(x)$ of degree $p$ and evaluates the discrete entropy residual\n  $$ R_N = \\sum_{i=1}^{N} w_i \\, U'(u_p(x_i)) \\, \\frac{d}{dx} f(u_p(x_i)) \\;-\\; \\left[ F(u_p(x)) \\right]_{x=-1}^{x=1}, $$\n  where $\\{x_i,w_i\\}_{i=1}^{N}$ are the quadrature nodes and weights for either Gauss–Legendre or Gauss–Lobatto–Legendre quadrature. Here, $U(u) = \\frac{1}{2} u^2$, $U'(u) = u$, $f(u) = \\frac{1}{2} u^2$, and $F(u) = \\frac{1}{3} u^3$. Choose\n  $$ u_p(x) = \\sum_{k=0}^{p} \\frac{1}{k+1} P_k(x), $$\n  where $P_k(x)$ denotes the degree-$k$ Legendre polynomial on $[-1,1]$, so that $u_p$ has nontrivial contributions from all degrees up to $p$. Compute $\\frac{d}{dx} f(u_p(x))$ exactly by differentiating $u_p$ analytically in $x$.\n- For a tolerance of $10^{-12}$, identify the smallest $N$ such that $|R_N| \\le 10^{-12}$ for each of the two quadrature families and for each polynomial degree $p$. Also, quantify the magnitude of spurious entropy production by reporting $|R_{p+1}|$ for both Gauss–Legendre and Gauss–Lobatto–Legendre quadrature (i.e., using $N = p+1$ volume points).\n\nUse the following test suite for $p$:\n- $p = 1$ (boundary case where low-degree interactions may be exactly integrated by modest quadrature),\n- $p = 2$ (moderate degree),\n- $p = 3$ (typical nontrivial case),\n- $p = 4$ (higher degree to expose scaling).\n\nYour program must:\n- For each $p$ in the test suite, compute and return a list of four values:\n  1. the smallest $N$ for Gauss–Legendre such that $|R_N| \\le 10^{-12}$,\n  2. the smallest $N$ for Gauss–Lobatto–Legendre such that $|R_N| \\le 10^{-12}$,\n  3. the value of $|R_{p+1}|$ using Gauss–Legendre with $N = p+1$,\n  4. the value of $|R_{p+1}|$ using Gauss–Lobatto–Legendre with $N = p+1$.\n- Aggregate the results for the test suite into a single line of output as a comma-separated list of lists enclosed in square brackets (e.g., $[ [a_1,a_2,a_3,a_4], [b_1,b_2,b_3,b_4], \\dots ]$).\n\nNotes and constraints:\n- The analysis and the program must be based on the chain rule identity for $U'(u) f'(u) u_x$ and exact endpoint evaluation of $F(u)$. No additional stabilization or interface terms are to be included, and no physical units are present in this problem.\n- Angles are not used in this problem.\n- All outputs must be plain numbers; do not use percentage signs or any units.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[[r_{11},r_{12},r_{13},r_{14}],[r_{21},r_{22},r_{23},r_{24}],[r_{31},r_{32},r_{33},r_{34}],[r_{41},r_{42},r_{43},r_{44}]]$), where each $r_{ij}$ is a number as specified above.", "solution": "The problem requires an analysis of the spurious entropy production arising from volume underintegration in a nodal spectral or discontinuous Galerkin method for a scalar conservation law. We must first formulate the discrete entropy balance and then determine the conditions under which the volume integral term is computed exactly.\n\nThe semi-discrete form of the conservation law, after multiplication by a test function $\\phi$ and integration over a reference element $I = [-1, 1]$, is\n$$ \\frac{d}{dt} \\int_{-1}^{1} u_p \\phi \\, dx - \\int_{-1}^{1} f(u_p) \\phi_x \\, dx + \\left[ f(u_p) \\phi \\right]_{x=-1}^{x=1} = 0 $$\nwhere $u_p$ is a polynomial approximation of degree $p$ to the solution $u$. To analyze entropy stability, one typically chooses the test function $\\phi$ to be related to the entropy variable, $v = U'(u)$. In a nodal DG setting, we can take $\\phi = v(u_p) = U'(u_p)$. The time derivative term becomes $\\int_{-1}^{1} U'(u_p) \\frac{\\partial u_p}{\\partial t} \\, dx = \\frac{d}{dt} \\int_{-1}^{1} U(u_p) \\, dx$. The semi-discrete entropy balance for the element is then\n$$ \\frac{d}{dt} \\int_{-1}^{1} U(u_p) \\, dx + \\int_{-1}^{1} U'(u_p) f(u_p)_x \\, dx = \\text{Boundary and interface terms} $$\nThe continuous entropy identity states $U(u)_t + F(u)_x = 0$. Integrating over the element gives $\\frac{d}{dt} \\int_{-1}^{1} U(u) \\, dx + \\left[ F(u) \\right]_{x=-1}^{x=1} = 0$. The discrete formulation should mimic this. The focus of this problem is the volume integral $\\int_{-1}^{1} U'(u_p(x)) f(u_p(x))_x \\, dx$.\n\nIn a numerical implementation, this integral is replaced by a quadrature sum:\n$$ \\int_{-1}^{1} U'(u_p(x)) f(u_p(x))_x \\, dx \\approx \\sum_{i=1}^{N} w_i U'(u_p(x_i)) f(u_p(x_i))_x $$\nwhere $\\{x_i, w_i\\}_{i=1}^{N}$ are the quadrature nodes and weights.\n\nThe core of the analysis lies in the identity relating the integrand to the entropy flux $F(u)$. By the chain rule, $f(u_p(x))_x = f'(u_p(x)) u_p'(x)$. The integrand is thus:\n$$ I(x) = U'(u_p(x)) f'(u_p(x)) u_p'(x) $$\nThe entropy flux $F(u)$ is defined such that $F'(u) = U'(u) f'(u)$. Substituting this into the integrand gives:\n$$ I(x) = F'(u_p(x)) u_p'(x) $$\nBy another application of the chain rule, this is precisely the derivative of the composite function $F(u_p(x))$:\n$$ I(x) = \\frac{d}{dx} F(u_p(x)) $$\nTherefore, the exact value of the volume integral can be found using the Fundamental Theorem of Calculus:\n$$ \\int_{-1}^{1} U'(u_p(x)) f(u_p(x))_x \\, dx = \\int_{-1}^{1} \\frac{d}{dx} F(u_p(x)) \\, dx = \\left[ F(u_p(x)) \\right]_{x=-1}^{x=1} $$\nThe discrete entropy residual, $R_N$, as defined in the problem, measures the error of the quadrature rule for this integral:\n$$ R_N = \\left( \\sum_{i=1}^{N} w_i I(x_i) \\right) - \\int_{-1}^{1} I(x) \\, dx $$\nThe residual $R_N$ is zero if and only if the quadrature rule is exact for the integrand $I(x)$. To determine the required exactness, we must find the polynomial degree of $I(x)$.\n\nThe problem specifies the Burgers' flux $f(u) = \\frac{1}{2} u^2$ and the quadratic entropy $U(u) = \\frac{1}{2} u^2$. This gives the entropy variable $U'(u) = u$ and the entropy flux $F(u) = \\frac{1}{3} u^3$.\nThe solution approximation $u_p(x)$ is a polynomial of degree $p$.\nThe composite function $F(u_p(x)) = \\frac{1}{3} (u_p(x))^3$ is a polynomial of degree $3p$.\nThe integrand $I(x) = \\frac{d}{dx} F(u_p(x))$ is therefore a polynomial of degree $3p-1$.\n\nFor the residual $R_N$ to be zero (up to machine precision), the quadrature rule must be exact for all polynomials of degree up to $3p-1$.\n\nWe now apply this requirement to the two specified quadrature families:\n1.  **Gauss–Legendre Quadrature**: A rule with $N$ points is exact for polynomials of degree up to $2N-1$. To avoid spurious entropy production from the volume term, we require:\n    $$ 2N - 1 \\ge 3p - 1 \\implies 2N \\ge 3p \\implies N \\ge \\frac{3p}{2} $$\n    Since $N$ must be an integer, the minimum number of Gauss-Legendre points is $N_{GL} = \\lceil \\frac{3p}{2} \\rceil$.\n\n2.  **Gauss–Lobatto–Legendre Quadrature**: A rule with $N$ points is exact for polynomials of degree up to $2N-3$. The requirement is:\n    $$ 2N - 3 \\ge 3p - 1 \\implies 2N \\ge 3p + 2 \\implies N \\ge \\frac{3p}{2} + 1 $$\n    The minimum number of Gauss-Lobatto-Legendre points is $N_{GLL} = \\lceil \\frac{3p}{2} + 1 \\rceil$.\n\nThese results provide the theoretical minimum number of quadrature points to ensure the discrete volume integral matches the change in entropy flux at the boundaries, thus preserving the local cell entropy balance for smooth solutions. The provided implementation will verify these theoretical predictions and quantify the error when an insufficient number of points ($N=p+1$) is used, a common scenario in underintegrated or collocated discontinuous Galerkin methods.", "answer": "```python\nimport numpy as np\nfrom scipy.special import legendre, roots_legendre\n\ndef solve():\n    \"\"\"\n    Analyzes the effect of volume underintegration on the discrete entropy balance\n    for a nodal DG discretization of a scalar conservation law.\n    \"\"\"\n    TOL = 1e-12\n    test_ps = [1, 2, 3, 4]\n    all_results = []\n\n    def get_up_and_dup_poly1d(p):\n        \"\"\"Constructs polynomial objects for u_p(x) and its derivative u_p'(x).\"\"\"\n        u_p_poly = np.poly1d([0.0])\n        for k in range(p + 1):\n            coeff = 1.0 / (k + 1)\n            P_k = legendre(k)\n            u_p_poly += coeff * P_k\n        \n        du_p_poly = u_p_poly.deriv(1)\n        return u_p_poly, du_p_poly\n\n    def get_gll_quadrature(N):\n        \"\"\"\n        Computes Gauss-Lobatto-Legendre quadrature nodes and weights for [-1, 1].\n        \"\"\"\n        if N  2:\n            raise ValueError(\"Gauss-Lobatto-Legendre quadrature requires N >= 2 points.\")\n\n        # Nodes are {-1, 1} and the roots of P'_{N-1}(x)\n        p_N_minus_1_deriv = legendre(N - 1).deriv(1)\n        interior_nodes = p_N_minus_1_deriv.roots\n        nodes = np.zeros(N)\n        nodes[0] = -1.0\n        nodes[N - 1] = 1.0\n        nodes[1:-1] = np.sort(np.real_if_close(interior_nodes))\n\n        # Weights w_i = 2 / (N(N-1) * [P_{N-1}(x_i)]^2)\n        weights = np.zeros(N)\n        p_N_minus_1 = legendre(N - 1)\n        weights = 2.0 / (N * (N - 1) * p_N_minus_1(nodes)**2)\n        \n        return nodes, weights\n\n    def calculate_residual(p, N, quad_type):\n        \"\"\"Calculates the discrete entropy residual R_N.\"\"\"\n        u_p, du_p = get_up_and_dup_poly1d(p)\n\n        if quad_type == 'gauss-legendre':\n            if N == 0: return np.inf # Not meaningful\n            nodes, weights = roots_legendre(N)\n        elif quad_type == 'gauss-lobatto':\n            if N  2: return np.inf # Not meaningful\n            nodes, weights = get_gll_quadrature(N)\n        else:\n            raise ValueError(\"Unknown quadrature type\")\n\n        # Integrand I(x) = U'(u_p) * (d/dx f(u_p)) = u_p * (u_p * u_p') = u_p^2 * u_p'\n        u_p_vals = u_p(nodes)\n        du_p_vals = du_p(nodes)\n        integrand_vals = u_p_vals**2 * du_p_vals\n\n        # discrete volume integral\n        quad_sum = np.sum(weights * integrand_vals)\n\n        # Exact boundary term: [F(u_p(x))]_{-1}^1\n        # F(u) = 1/3 * u^3\n        u_p_at_1 = u_p(1.0)\n        u_p_at_minus_1 = u_p(-1.0)\n        boundary_term = (1.0 / 3.0) * (u_p_at_1**3 - u_p_at_minus_1**3)\n\n        residual = quad_sum - boundary_term\n        return residual\n\n    for p in test_ps:\n        p_results = []\n\n        # 1. Smallest N for Gauss-Legendre\n        N = 1\n        while True:\n            residual = calculate_residual(p, N, 'gauss-legendre')\n            if abs(residual) = TOL:\n                p_results.append(N)\n                break\n            N += 1\n            if N > 50: # Safety break\n                p_results.append(-1)\n                break\n\n        # 2. Smallest N for Gauss-Lobatto-Legendre\n        N = 2\n        while True:\n            residual = calculate_residual(p, N, 'gauss-lobatto')\n            if abs(residual) = TOL:\n                p_results.append(N)\n                break\n            N += 1\n            if N > 50: # Safety break\n                p_results.append(-1)\n                break\n\n        # 3. |R_{p+1}| for Gauss-Legendre\n        N_gl = p + 1\n        residual_gl = calculate_residual(p, N_gl, 'gauss-legendre')\n        p_results.append(abs(residual_gl))\n\n        # 4. |R_{p+1}| for Gauss-Lobatto-Legendre\n        N_gll = p + 1\n        residual_gll = calculate_residual(p, N_gll, 'gauss-lobatto')\n        p_results.append(abs(residual_gll))\n        \n        all_results.append(p_results)\n    \n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3384466"}, {"introduction": "Moving from simple reference elements to realistic curvilinear meshes introduces new challenges for conservation, as the geometry itself must be discretized carefully. This hands-on exercise explores the vital connection between the discrete Geometric Conservation Law (GCL) and entropy conservation for a linear advection problem on a mapped grid. You will quantify how inconsistent computation of the metric terms introduces aliasing errors that manifest as spurious entropy production, demonstrating that a robust scheme must discretize both the physics and the geometry with compatible operators.", "problem": "Consider the two-dimensional scalar linear advection equation on a curvilinear mapped square reference element,\n$$\\frac{\\partial u}{\\partial t} + \\nabla \\cdot (\\mathbf{c}\\, u) = 0,$$\nwhere $\\mathbf{c} = (c_x,c_y)$ is a constant advection velocity vector and $u(x,y,t)$ is a scalar field. The physical coordinates $(x,y)$ are obtained from a polynomial curvilinear mapping of the reference coordinates $(\\xi,\\eta)\\in[-1,1]^2$:\n$$x(\\xi,\\eta) = \\xi + \\alpha\\left(\\xi^2\\eta - \\frac{1}{2}\\xi\\eta^2\\right), \\quad y(\\xi,\\eta) = \\eta + \\alpha\\left(\\xi\\eta^2 - \\frac{1}{2}\\xi^2\\eta\\right),$$\nwhere $\\alpha$ is a real parameter controlling the mapping distortion. The Jacobian of the transformation is\n$$J = x_\\xi y_\\eta - x_\\eta y_\\xi.$$\nDefine the contravariant metric components\n$$\\mathbf{a}^\\xi = \\left(y_\\eta,-x_\\eta\\right), \\quad \\mathbf{a}^\\eta = \\left(-y_\\xi,x_\\xi\\right),$$\nand the corresponding transformed scalar coefficients\n$$\\beta^\\xi = \\mathbf{c}\\cdot \\mathbf{a}^\\xi = c_x y_\\eta - c_y x_\\eta, \\quad \\beta^\\eta = \\mathbf{c}\\cdot \\mathbf{a}^\\eta = -c_x y_\\xi + c_y x_\\xi.$$\nFor a Gauss–Legendre–Lobatto (GLL) nodal discretization at polynomial degree $N$, with $N+1$ GLL nodes per coordinate direction, denote the one-dimensional differentiation matrix by $D$ and the quadrature weights by $w$. The Discontinuous Galerkin Spectral Element Method (DGSEM) with split forms and symmetric two-point flux differencing is defined for the volume terms as follows: along each coordinate direction, a symmetric two-point flux function is formed using arithmetic averages, and its discrete divergence is taken with the differentiation matrix $D$. This construction is known to be entropy conservative for the free-stream constant solution when discrete metric identities and the Geometric Conservation Law (GCL) are enforced with consistent metric discretization based on the same $D$ in each direction.\n\nIn this exercise, you will:\n- Construct the free-stream discrete residual for the scalar linear advection equation using the DGSEM split-form volume discretization on the aforementioned curvilinear mapping.\n- Enforce discrete metric identities by computing $x_\\xi$, $x_\\eta$, $y_\\xi$, $y_\\eta$ using the same differentiation matrix $D$ along each respective coordinate, thereby ensuring the commutation of mixed derivatives and satisfaction of the discrete GCL $D_\\xi \\mathbf{a}^\\xi + D_\\eta \\mathbf{a}^\\eta = \\mathbf{0}$.\n- Quantify sensitivity to metric aliasing by intentionally breaking metric consistency through mixed and naive derivative operators in the metric computation, and measure the resulting discrete entropy production for a free-stream constant $u$.\n\nUse the following fundamental base and definitions:\n- The scalar conservation law with constant velocity $\\mathbf{c}$ and the definition of entropy for a scalar conservative system, $s(u) = \\frac{1}{2}u^2$, together with the corresponding semi-discrete entropy production for the volume terms,\n$$\\frac{d}{dt}\\int_\\Omega J\\, s(u)\\, d\\xi d\\eta \\approx \\sum_{i=0}^{N}\\sum_{j=0}^{N} w_i w_j\\, J_{ij}\\, u_{ij}\\, R_{ij},$$\nwhere $R_{ij}$ denotes the semi-discrete residual at node $(i,j)$ produced by the split-form volume discretization.\n- The symmetric two-point flux differencing in each coordinate direction, using arithmetic averages of the state $u$ and metric coefficients $\\beta^\\xi$, $\\beta^\\eta$, and the one-dimensional differentiation matrix $D$ applied along the respective tensor-product index, so that the discrete divergence in split form is a sum of $D$-weighted pairwise fluxes with symmetric averaging.\n\nYour program must:\n- Construct $N+1$ GLL nodes and weights for each one-dimensional coordinate direction on $[-1,1]$, and the corresponding collocation differentiation matrix $D$.\n- Build the curvilinear mapping $x(\\xi,\\eta)$ and $y(\\xi,\\eta)$ on the tensor-product grid.\n- Compute the metric terms in three distinct modes:\n    1. Consistent: use $D$ along both $\\xi$ and $\\eta$ directions for all coordinate derivatives $x_\\xi$, $x_\\eta$, $y_\\xi$, $y_\\eta$.\n    2. Mismatch: use a naive finite-difference matrix $E$ along $\\eta$ for $y_\\eta$ while using $D$ along $\\eta$ for $x_\\eta$, and use $D$ along $\\xi$ for $y_\\xi$ while using $E$ along $\\xi$ for $x_\\xi$.\n    3. Finite-difference: use the naive finite-difference matrix $E$ along both directions for all coordinate derivatives.\n- Form the contravariant vectors, the scalar coefficients $\\beta^\\xi$ and $\\beta^\\eta$, and the Jacobian $J$ consistently with the chosen metric mode.\n- Evaluate the split-form DGSEM volume residual $R$ for a free-stream constant solution $u=u_0$ with $u_0 = 1$, using symmetric arithmetic averages for the two-point fluxes in both directions and the differentiation matrix $D$ along each respective direction.\n- Compute the scalar discrete entropy production proxy,\n$$\\Delta = \\left| \\sum_{i=0}^{N}\\sum_{j=0}^{N} w_i w_j\\, J_{ij}\\, u_{ij}\\, R_{ij} \\right|,$$\nwhich must be exactly zero for the consistent metric mode when discrete metric identities and GCL are satisfied, and generally nonzero when metric aliasing is introduced by the mismatch or finite-difference modes.\n\nSet the advection velocity to a fixed nontrivial constant $\\mathbf{c} = (1, \\frac{1}{2})$. Use periodic boundary conditions conceptually; for the free-stream constant solution with symmetric split-form volume discretization, the surface terms vanish and you only need to evaluate the volume residual.\n\nTest Suite:\nFor each of the following parameter sets $(N,\\alpha,\\text{mode})$, compute and return the scalar $\\Delta$ as a float:\n- $(6, 0.2, \\text{consistent})$.\n- $(6, 0.2, \\text{mismatch})$.\n- $(6, 0.6, \\text{mismatch})$.\n- $(4, 0.2, \\text{fd})$.\n- $(6, 0.0, \\text{mismatch})$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4,r_5]$), where each $r_k$ is the computed $\\Delta$ for the corresponding test case, expressed as a float in machine precision units. No additional text should be printed.", "solution": "The user wants to analyze the entropy production of a Discontinuous Galerkin Spectral Element Method (DGSEM) for the two-dimensional scalar linear advection equation,\n$$\n\\frac{\\partial u}{\\partial t} + \\nabla \\cdot (\\mathbf{c}\\, u) = 0,\n$$\non a curvilinear grid. The core of the problem lies in understanding how the discrete approximation of geometric terms affects the conservation properties of the numerical scheme. A key property of a well-designed DGSEM is its ability to be entropy conservative, particularly for simple solutions like a constant free-stream, which is a fundamental consistency check.\n\n### Step 1: Theoretical Framework\n\n**1.1. Governing Equation in Transformed Coordinates**\n\nThe physical domain $(x,y)$ is mapped from a square reference element $(\\xi, \\eta) \\in [-1,1]^2$ via the polynomial mapping:\n$$\nx(\\xi,\\eta) = \\xi + \\alpha\\left(\\xi^2\\eta - \\frac{1}{2}\\xi\\eta^2\\right)\n$$\n$$\ny(\\xi,\\eta) = \\eta + \\alpha\\left(\\xi\\eta^2 - \\frac{1}{2}\\xi^2\\eta\\right)\n$$\nThe scalar advection equation, when transformed into these reference coordinates, becomes:\n$$\n\\frac{\\partial (Ju)}{\\partial t} + \\frac{\\partial (\\beta^\\xi u)}{\\partial \\xi} + \\frac{\\partial (\\beta^\\eta u)}{\\partial \\eta} = 0\n$$\nwhere $J = x_\\xi y_\\eta - x_\\eta y_\\xi$ is the Jacobian of the transformation, and $\\beta^\\xi = c_x y_\\eta - c_y x_\\eta$, $\\beta^\\eta = -c_x y_\\xi + c_y x_\\xi$ are the contravariant flux coefficients.\n\n**1.2. The Geometric Conservation Law (GCL)**\n\nFor a time-invariant (steady) mesh, the metric terms satisfy the Geometric Conservation Law (GCL):\n$$\n\\frac{\\partial \\mathbf{a}^\\xi}{\\partial \\xi} + \\frac{\\partial \\mathbf{a}^\\eta}{\\partial \\eta} = \\mathbf{0}\n$$\nwhere $\\mathbf{a}^\\xi = (y_\\eta, -x_\\eta)$ and $\\mathbf{a}^\\eta = (-y_\\xi, x_\\xi)$. This identity is equivalent to the commutation of mixed partial derivatives (e.g., $x_{\\xi\\eta} = x_{\\eta\\xi}$) for a smooth mapping. Taking the dot product of the GCL with the constant velocity vector $\\mathbf{c}$ yields:\n$$\n\\frac{\\partial \\beta^\\xi}{\\partial \\xi} + \\frac{\\partial \\beta^\\eta}{\\partial \\eta} = 0\n$$\nThis identity is crucial. For a constant free-stream solution $u=u_0$, the transformed equation simplifies to $u_0 \\left( \\frac{\\partial \\beta^\\xi}{\\partial \\xi} + \\frac{\\partial \\beta^\\eta}{\\partial \\eta} \\right) = 0$, which is trivially satisfied at the continuous level due to the GCL. A numerical scheme should replicate this behavior at the discrete level.\n\n**1.3. Split-Form DGSEM and Entropy Conservation**\n\nThe problem specifies a split-form DGSEM. For the linear advection equation, a common split form for the spatial operator is $\\frac{1}{2} (\\nabla \\cdot (\\mathbf{c}u) + \\mathbf{c} \\cdot \\nabla u)$. The semi-discrete equation for the nodal values $u_{ij}$ is $\\frac{du_{ij}}{dt} = -R_{ij}$, where $R_{ij}$ is the discrete residual. The discrete residual from the split-form volume integral for the constant free-stream solution ($u=u_0=1$) simplifies significantly. Since discrete derivatives of a constant are zero ($D_\\xi U = \\mathbf{0}$, $D_\\eta U = \\mathbf{0}$ for $U$ being a matrix of constants), the residual becomes:\n$$\nR_{ij} = \\frac{1}{2J_{ij}} \\left( (D_\\xi \\beta^\\xi)_{ij} + (D_\\eta \\beta^\\eta)_{ij} \\right)\n$$\nHere, $D_\\xi$ and $D_\\eta$ represent the discrete differentiation operators in the $\\xi$ and $\\eta$ directions, respectively, based on the one-dimensional differentiation matrix $D$ operating on the tensor-product grid.\n\nThe rate of change of discrete entropy is given by the formula:\n$$\n\\frac{d}{dt}\\sum_{i=0}^{N}\\sum_{j=0}^{N} w_i w_j J_{ij} s(u_{ij}) = -\\sum_{i=0}^{N}\\sum_{j=0}^{N} w_i w_j J_{ij} u_{ij} R_{ij}\n$$\nThe quantity to be computed is the magnitude of this sum, denoted by $\\Delta$. For $u=u_0=1$:\n$$\n\\Delta = \\left| \\sum_{i,j} w_i w_j J_{ij} (1) R_{ij} \\right| = \\left| \\sum_{i,j} w_i w_j J_{ij} \\frac{1}{2J_{ij}} \\left( (D_\\xi \\beta^\\xi)_{ij} + (D_\\eta \\beta^\\eta)_{ij} \\right) \\right|\n$$\n$$\n\\Delta = \\frac{1}{2} \\left| \\sum_{i,j} w_i w_j \\left( (D_\\xi \\beta^\\xi)_{ij} + (D_\\eta \\beta^\\eta)_{ij} \\right) \\right|\n$$\nThe term $(D_\\xi \\beta^\\xi)_{ij} + (D_\\eta \\beta^\\eta)_{ij}$ is the discrete version of the GCL identity.\n\n### Step 2: Implementation Strategy\n\n**2.1. Nodal Discretization**\n\nFirst, we generate the $N+1$ Gauss-Legendre-Lobatto (GLL) nodes $\\xi_i$ and corresponding quadrature weights $w_i$ on $[-1,1]$. From these nodes, we construct the collocation differentiation matrix $D$. We also construct a \"naive\" second-order finite-difference matrix $E$ on the same GLL node distribution.\n\n**2.2. Metric Term Computation**\n\nThe core of the analysis lies in how the metric derivatives ($x_\\xi, x_\\eta, y_\\xi, y_\\eta$) are computed.\n- **Consistent Mode**: All four derivatives are computed using the same GLL differentiation matrix $D$. For instance, $x_\\xi$ is found by applying $D$ along the $\\xi$-direction to the grid of $x$-coordinates. In this case, the discrete differentiation operators commute ($D_\\xi D_\\eta = D_\\eta D_\\xi$), ensuring the discrete GCL is satisfied: $D_\\xi \\beta^\\xi + D_\\eta \\beta^\\eta = \\mathbf{0}$. Consequently, the residual $R$ is zero, and the entropy production $\\Delta$ must be zero up to machine precision.\n- **Mismatch Mode**: The derivatives are computed with a mix of operators. As specified, $x_\\xi$ and $y_\\eta$ use the naive matrix $E$, while $y_\\xi$ and $x_\\eta$ use the GLL matrix $D$. This inconsistency breaks the commutation property, leading to a non-zero discrete GCL term ($D_\\xi \\beta^\\xi + D_\\eta \\beta^\\eta \\neq \\mathbf{0}$), a non-zero residual $R$, and hence, non-zero entropy production $\\Delta$.\n- **Finite-Difference (fd) Mode**: All four derivatives are computed using the naive matrix $E$. While the same operator is used for each derivative, the discrete divergence in the residual calculation still uses the GLL matrix $D$. This mismatch between the operator used for the metrics and the operator used for the divergence also breaks the discrete GCL, leading to non-zero entropy production.\n\n**2.3. Calculation of Entropy Production**\n\nFor each test case $(N, \\alpha, \\text{mode})$, the following procedure is executed:\n1.  Generate the GLL nodes, weights, and differentiation matrices $D$ and $E$ for the given polynomial degree $N$.\n2.  Construct the 2D grid coordinates $(X, Y)$ using the specified mapping parameter $\\alpha$.\n3.  Compute the metric derivative matrices ($x_\\xi, x_\\eta, y_\\xi, y_\\eta$) according to the specified `mode`.\n4.  Calculate the Jacobian $J$ and the flux coefficient matrices $\\beta^\\xi$ and $\\beta^\\eta$.\n5.  Compute the discrete GCL residual term: $Res_{GCL} = (D_\\xi \\beta^\\xi) + (D_\\eta \\beta^\\eta)$, which in matrix form is $(\\beta^\\xi \\cdot D^T) + (D \\cdot \\beta^\\eta)$.\n6.  Substitute this into the formula for $\\Delta$: $\\Delta = \\frac{1}{2} |\\sum_{i,j} w_i w_j (Res_{GCL})_{ij}|$. This is equivalent to summing the elements of the matrix $\\frac{1}{2} W_{2D} \\circ Res_{GCL}$, where $W_{2D}$ is the outer product of the 1D weight vector $w$ and $\\circ$ is the element-wise product.\nThe final Python code implements this logic for each test case provided.", "answer": "```python\nimport numpy as np\nfrom scipy.special import legendre\n\ndef solve():\n    \"\"\"\n    Main solver function to compute entropy production for the given test cases.\n    \"\"\"\n\n    def gll_nodes_weights(N):\n        \"\"\"\n        Computes Gauss-Legendre-Lobatto (GLL) nodes and weights for polynomial degree N.\n        This corresponds to N+1 points.\n        \"\"\"\n        if N == 0:\n            return np.array([0.0]), np.array([2.0])\n        if N == 1:\n            return np.array([-1.0, 1.0]), np.array([1.0, 1.0])\n        \n        # GLL nodes are -1, 1, and the roots of the derivative of the N-th Legendre polynomial.\n        p_N = legendre(N)\n        p_N_prime_coeffs = np.polyder(p_N.coef)\n        interior_nodes = np.polynomial.polynomial.polyroots(p_N_prime_coeffs[::-1])\n        nodes = np.concatenate(([-1.0], np.sort(np.real(interior_nodes)), [1.0]))\n        \n        # GLL weights formula\n        weights = 2.0 / (N * (N + 1) * p_N(nodes)**2)\n        \n        return nodes, weights\n\n    def differentiation_matrix(nodes):\n        \"\"\"\n        Computes the GLL collocation differentiation matrix using a barycentric formula.\n        \"\"\"\n        N = len(nodes) - 1\n        D = np.zeros((N + 1, N + 1))\n        \n        # Barycentric weights\n        bary_weights = np.ones(N + 1)\n        for j in range(N + 1):\n            for k in range(N + 1):\n                if j != k:\n                    bary_weights[j] *= (nodes[j] - nodes[k])\n        bary_weights = 1.0 / bary_weights\n\n        # Off-diagonal entries\n        for i in range(N + 1):\n            for j in range(N + 1):\n                if i != j:\n                    D[i, j] = (bary_weights[j] / bary_weights[i]) / (nodes[i] - nodes[j])\n        \n        # Diagonal entries (sum of row is zero)\n        for i in range(N + 1):\n           D[i, i] = -np.sum(D[i, :])\n\n        return D\n\n    def naive_fd_matrix(nodes):\n        \"\"\"\n        Computes a naive finite difference matrix (2nd-order interior, 1st-order boundary) on the GLL nodes.\n        \"\"\"\n        N = len(nodes) - 1\n        E = np.zeros((N + 1, N + 1))\n\n        # Forward difference at the first point\n        E[0, 0] = -1.0 / (nodes[1] - nodes[0])\n        E[0, 1] = 1.0 / (nodes[1] - nodes[0])\n\n        # Backward difference at the last point\n        if N > 0:\n            E[N, N] = 1.0 / (nodes[N] - nodes[N-1])\n            E[N, N-1] = -1.0 / (nodes[N] - nodes[N-1])\n\n        # Centered difference for interior points\n        for i in range(1, N):\n            E[i, i-1] = -1.0 / (nodes[i+1] - nodes[i-1])\n            E[i, i+1] = 1.0 / (nodes[i+1] - nodes[i-1])\n\n        return E\n\n    def compute_entropy_production(N, alpha, mode):\n        \"\"\"\n        Computes the discrete entropy production proxy Delta for a given configuration.\n        \"\"\"\n        c = np.array([1.0, 0.5])\n\n        xi, w = gll_nodes_weights(N)\n        D = differentiation_matrix(xi)\n        \n        XI, ETA = np.meshgrid(xi, xi)\n        X = XI + alpha * (XI**2 * ETA - 0.5 * XI * ETA**2)\n        Y = ETA + alpha * (XI * ETA**2 - 0.5 * XI**2 * ETA)\n\n        # Derivatives w.r.t. xi are applied to columns (index 1), so op.T is right-multiplied.\n        # Derivatives w.r.t. eta are applied to rows (index 0), so op is left-multiplied.\n        if mode == 'consistent':\n            x_xi = X @ D.T\n            y_xi = Y @ D.T\n            x_eta = D @ X\n            y_eta = D @ Y\n        elif mode == 'mismatch':\n            E = naive_fd_matrix(xi)\n            # As per problem statement:\n            # use E along xi for x_xi\n            x_xi = X @ E.T\n            # use D along xi for y_xi\n            y_xi = Y @ D.T\n            # use D along eta for x_eta\n            x_eta = D @ X\n            # use E along eta for y_eta\n            y_eta = E @ Y\n        elif mode == 'fd':\n            E = naive_fd_matrix(xi)\n            x_xi = X @ E.T\n            y_xi = Y @ E.T\n            x_eta = E @ X\n            y_eta = E @ Y\n        else:\n            raise ValueError(f\"Unknown mode: {mode}\")\n\n        beta_xi = c[0] * y_eta - c[1] * x_eta\n        beta_eta = -c[0] * y_xi + c[1] * x_xi\n        \n        gcl_residual_term = (beta_xi @ D.T) + (D @ beta_eta)\n\n        W_2d = np.outer(w, w)\n        \n        delta = np.abs(0.5 * np.sum(W_2d * gcl_residual_term))\n        \n        return delta\n\n    test_cases = [\n        (6, 0.2, 'consistent'),\n        (6, 0.2, 'mismatch'),\n        (6, 0.6, 'mismatch'),\n        (4, 0.2, 'fd'),\n        (6, 0.0, 'mismatch'),\n    ]\n\n    results = []\n    for N, alpha, mode in test_cases:\n        result = compute_entropy_production(N, alpha, mode)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3384461"}]}