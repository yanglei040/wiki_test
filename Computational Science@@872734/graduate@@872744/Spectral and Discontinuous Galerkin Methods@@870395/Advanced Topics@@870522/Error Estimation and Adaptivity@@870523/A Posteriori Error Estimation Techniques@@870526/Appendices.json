{"hands_on_practices": [{"introduction": "This problem provides a fundamental, hands-on calculation of a key component in residual-based error estimators. By computing the traction jump across an interior element edge [@problem_id:3541963], you will connect the abstract formula to concrete values derived from a finite element solution. This exercise is crucial for demystifying the local nature of these estimators and building intuition for how they detect inconsistencies in the numerical stress field.", "problem": "Consider a two-dimensional cantilever beam under a tip load, modeled in plane strain, discretized by the Finite Element Method (FEM) using linear Lagrange elements ($P_1$). Focus on a local interior edge $e$ that is the common edge of two adjacent triangles arising from splitting the unit square with coordinates (in meters) $A=(0,0)$, $B=(1,0)$, $C=(0,1)$, and $D=(1,1)$ along the diagonal from $B$ to $C$. Let $T^{+}=\\triangle ABC$ and $T^{-}=\\triangle BDC$, and let $e$ be the edge connecting $B$ and $C$. The discrete displacement field $u_h=(u_{h,x},u_{h,y})$ is piecewise affine over each triangle and is given at the mesh vertices (in meters) by\n- $u_h(A)=(0,0)$,\n- $u_h(B)=(1.0\\times 10^{-4},\\,2.0\\times 10^{-4})$,\n- $u_h(C)=(-5.0\\times 10^{-5},\\,3.0\\times 10^{-4})$,\n- $u_h(D)=(9.0\\times 10^{-5},\\,4.7\\times 10^{-4})$.\nAssume an isotropic, homogeneous, linear elastic material in plane strain with Lamé parameters $(\\lambda,\\mu)$ equal to $\\lambda=1.2\\times 10^{9}\\,\\mathrm{Pa}$ and $\\mu=0.8\\times 10^{9}\\,\\mathrm{Pa}$. The Cauchy stress tensor is defined by $\\sigma(u_h)=2\\mu\\,\\varepsilon(u_h)+\\lambda\\,\\mathrm{tr}(\\varepsilon(u_h))\\,I$, where $\\varepsilon(u_h)=(\\nabla u_h+(\\nabla u_h)^{\\top})/2$ is the symmetric gradient and $I$ is the identity tensor. On an interior edge $e$ shared by elements $T^{+}$ and $T^{-}$ with outward unit normals along $e$ denoted by $n^{+}$ (for $T^{+}$) and $n^{-}$ (for $T^{-}$) satisfying $n^{-}=-n^{+}$, define the traction jump vector by $\\llbracket \\sigma(u_h)n \\rrbracket := \\sigma(u_h)|_{T^{+}}\\,n^{+}+\\sigma(u_h)|_{T^{-}}\\,n^{-}$. The edge norm is $\\|v\\|_{0,e}=\\left(\\int_{e}|v|^{2}\\,\\mathrm{d}s\\right)^{1/2}$ with $|\\,\\cdot\\,|$ the Euclidean norm in $\\mathbb{R}^{2}$. Using these data and definitions, compute the interior edge jump contribution $\\|\\llbracket \\sigma(u_h)n\\rrbracket\\|_{0,e}$ for the edge $e=\\overline{BC}$. Express your final answer in $\\mathrm{N}\\,\\mathrm{m}^{-3/2}$ and round your answer to four significant figures.", "solution": "The problem is first validated to ensure it is scientifically sound, self-contained, and well-posed.\n\n### Step 1: Extract Givens\n- **Geometry:** A unit square with vertices $A=(0,0)$, $B=(1,0)$, $C=(0,1)$, and $D=(1,1)$ in meters. The domain is divided into two triangles: $T^{+} = \\triangle ABC$ and $T^{-} = \\triangle BDC$.\n- **Edge of Interest:** $e = \\overline{BC}$, the common edge between $T^{+}$ and $T^{-}$.\n- **FEM Discretization:** Linear Lagrange elements ($P_1$). The discrete displacement field $u_h=(u_{h,x}, u_{h,y})$ is piecewise affine.\n- **Nodal Displacements (in meters):**\n  - $u_h(A) = (0,0)$\n  - $u_h(B) = (1.0 \\times 10^{-4}, 2.0 \\times 10^{-4})$\n  - $u_h(C) = (-5.0 \\times 10^{-5}, 3.0 \\times 10^{-4})$\n  - $u_h(D) = (9.0 \\times 10^{-5}, 4.7 \\times 10^{-4})$\n- **Material Model:** Isotropic, homogeneous, linear elastic, plane strain.\n- **Material Properties (Lamé parameters):** $\\lambda = 1.2 \\times 10^{9}\\,\\mathrm{Pa}$, $\\mu = 0.8 \\times 10^{9}\\,\\mathrm{Pa}$.\n- **Constitutive Relation:** Cauchy stress $\\sigma(u_h) = 2\\mu\\,\\varepsilon(u_h) + \\lambda\\,\\mathrm{tr}(\\varepsilon(u_h))\\,I$, with $\\varepsilon(u_h) = (\\nabla u_h + (\\nabla u_h)^{\\top})/2$.\n- **Definitions:**\n  - Traction jump: $\\llbracket \\sigma(u_h)n \\rrbracket = \\sigma(u_h)|_{T^{+}}\\,n^{+} + \\sigma(u_h)|_{T^{-}}\\,n^{-}$, where $n^{\\pm}$ are the outward unit normals from $T^{\\pm}$ along $e$, and $n^{-} = -n^{+}$.\n  - Edge norm: $\\|v\\|_{0,e} = \\left(\\int_{e}|v|^{2}\\,\\mathrm{d}s\\right)^{1/2}$.\n- **Objective:** Compute $\\|\\llbracket \\sigma(u_h)n\\rrbracket\\|_{0,e}$ for $e=\\overline{BC}$ and provide the result rounded to four significant figures in units of $\\mathrm{N}\\,\\mathrm{m}^{-3/2}$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is a standard exercise in a posteriori error estimation for the Finite Element Method in computational solid mechanics. It is scientifically grounded in the principles of linear elasticity and continuum mechanics. All terms are standard and precisely defined. All required data (geometry, nodal displacements, material constants) are provided and are physically plausible. The problem is well-posed, objective, and contains no contradictions or ambiguities.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete solution follows.\n\n### Detailed Solution\n\nThe solution proceeds by first computing the constant displacement gradient on each triangular element, then the strain and stress tensors, followed by the traction jump vector, and finally the required edge norm.\n\n**1. Displacement Gradients**\nSince the displacement field $u_h$ is affine (linear) on each triangle, its gradient, $\\nabla u_h$, is a constant matrix on each element.\n\nFor element $T^{+} = \\triangle ABC$ with vertices $A(0,0)$, $B(1,0)$, and $C(0,1)$, the displacement field is of the form $u_h(x,y) = \\mathbf{a} + \\mathbf{B}\\begin{pmatrix}x \\\\ y\\end{pmatrix}$. The gradient is $\\nabla u_h = \\mathbf{B}^T$. The coefficients are found from the nodal values:\n$u_h(0,0) = \\mathbf{a} = u_h(A) = (0,0)$.\n$u_h(1,0) = \\mathbf{a} + \\mathbf{B}\\begin{pmatrix}1 \\\\ 0\\end{pmatrix} = u_h(B)$, which implies the first column of $\\mathbf{B}$ is $u_h(B)$.\n$u_h(0,1) = \\mathbf{a} + \\mathbf{B}\\begin{pmatrix}0 \\\\ 1\\end{pmatrix} = u_h(C)$, which implies the second column of $\\mathbf{B}$ is $u_h(C)$.\nSo, $\\mathbf{B} = \\begin{pmatrix} u_{h,x}(B)  u_{h,x}(C) \\\\ u_{h,y}(B)  u_{h,y}(C) \\end{pmatrix} = \\begin{pmatrix} 1.0 \\times 10^{-4}  -5.0 \\times 10^{-5} \\\\ 2.0 \\times 10^{-4}  3.0 \\times 10^{-4} \\end{pmatrix}$.\nThe gradient on $T^{+}$ is:\n$$ \\nabla u_h|_{T^{+}} = \\mathbf{B}^T = \\begin{pmatrix} 1.0 \\times 10^{-4}  2.0 \\times 10^{-4} \\\\ -5.0 \\times 10^{-5}  3.0 \\times 10^{-4} \\end{pmatrix} $$\n\nFor element $T^{-} = \\triangle BDC$ with vertices $B(1,0)$, $D(1,1)$, and $C(0,1)$, we again set $u_h(x,y) = \\mathbf{a} + \\mathbf{B}\\begin{pmatrix}x \\\\ y\\end{pmatrix}$. We solve a system of linear equations:\n$u_h(C) = u_h(0,1) = \\mathbf{a} + \\mathbf{B}\\begin{pmatrix}0 \\\\ 1\\end{pmatrix}$\n$u_h(B) = u_h(1,0) = \\mathbf{a} + \\mathbf{B}\\begin{pmatrix}1 \\\\ 0\\end{pmatrix}$\n$u_h(D) = u_h(1,1) = \\mathbf{a} + \\mathbf{B}\\begin{pmatrix}1 \\\\ 1\\end{pmatrix}$\nFrom these, we find the columns of the matrix of partial derivatives to be $u_{h, \\cdot j}(D) - u_{h, \\cdot j}(C)$ and $u_{h, \\cdot j}(D) - u_{h, \\cdot j}(B)$ respectively. This leads to the gradient matrix:\n$$ \\nabla u_h|_{T^{-}} = \\begin{pmatrix} u_{h,x}(D) - u_{h,x}(C)  u_{h,y}(D) - u_{h,y}(C) \\\\ u_{h,x}(D) - u_{h,x}(B)  u_{h,y}(D) - u_{h,y}(B) \\end{pmatrix} = \\begin{pmatrix} 1.4 \\times 10^{-4}  1.7 \\times 10^{-4} \\\\ -1.0 \\times 10^{-5}  2.7 \\times 10^{-4} \\end{pmatrix} $$\n\n**2. Strain and Stress Tensors**\nThe strain tensor is $\\varepsilon = \\frac{1}{2}(\\nabla u_h + (\\nabla u_h)^T)$.\nOn $T^{+}$:\n$$ \\varepsilon^{+} = \\frac{1}{2}\\left(\\begin{pmatrix} 1.0 \\times 10^{-4}  2.0 \\times 10^{-4} \\\\ -5.0 \\times 10^{-5}  3.0 \\times 10^{-4} \\end{pmatrix} + \\begin{pmatrix} 1.0 \\times 10^{-4}  -5.0 \\times 10^{-5} \\\\ 2.0 \\times 10^{-4}  3.0 \\times 10^{-4} \\end{pmatrix}\\right) = \\begin{pmatrix} 1.0 \\times 10^{-4}  7.5 \\times 10^{-5} \\\\ 7.5 \\times 10^{-5}  3.0 \\times 10^{-4} \\end{pmatrix} $$\nThe trace is $\\mathrm{tr}(\\varepsilon^{+}) = (1.0 + 3.0) \\times 10^{-4} = 4.0 \\times 10^{-4}$.\nThe stress tensor $\\sigma^{+} = 2\\mu\\varepsilon^{+} + \\lambda\\,\\mathrm{tr}(\\varepsilon^{+})I$:\n$$ \\sigma^{+} = 2(0.8 \\times 10^9)\\varepsilon^{+} + (1.2 \\times 10^9)(4.0 \\times 10^{-4})I $$\n$$ \\sigma^{+} = 1.6 \\times 10^9 \\begin{pmatrix} 1.0 \\times 10^{-4}  7.5 \\times 10^{-5} \\\\ 7.5 \\times 10^{-5}  3.0 \\times 10^{-4} \\end{pmatrix} + 4.8 \\times 10^5 I = \\begin{pmatrix} 1.6 \\times 10^5  1.2 \\times 10^5 \\\\ 1.2 \\times 10^5  4.8 \\times 10^5 \\end{pmatrix} + \\begin{pmatrix} 4.8 \\times 10^5  0 \\\\ 0  4.8 \\times 10^5 \\end{pmatrix} $$\n$$ \\sigma^{+} = \\begin{pmatrix} 6.4 \\times 10^5  1.2 \\times 10^5 \\\\ 1.2 \\times 10^5  9.6 \\times 10^5 \\end{pmatrix}\\,\\mathrm{Pa} $$\n\nOn $T^{-}$:\n$$ \\varepsilon^{-} = \\frac{1}{2}\\left(\\begin{pmatrix} 1.4 \\times 10^{-4}  1.7 \\times 10^{-4} \\\\ -1.0 \\times 10^{-5}  2.7 \\times 10^{-4} \\end{pmatrix} + \\begin{pmatrix} 1.4 \\times 10^{-4}  -1.0 \\times 10^{-5} \\\\ 1.7 \\times 10^{-4}  2.7 \\times 10^{-4} \\end{pmatrix}\\right) = \\begin{pmatrix} 1.4 \\times 10^{-4}  8.0 \\times 10^{-5} \\\\ 8.0 \\times 10^{-5}  2.7 \\times 10^{-4} \\end{pmatrix} $$\nThe trace is $\\mathrm{tr}(\\varepsilon^{-}) = (1.4 + 2.7) \\times 10^{-4} = 4.1 \\times 10^{-4}$.\nThe stress tensor $\\sigma^{-} = 2\\mu\\varepsilon^{-} + \\lambda\\,\\mathrm{tr}(\\varepsilon^{-})I$:\n$$ \\sigma^{-} = 2(0.8 \\times 10^9)\\varepsilon^{-} + (1.2 \\times 10^9)(4.1 \\times 10^{-4})I $$\n$$ \\sigma^{-} = 1.6 \\times 10^9 \\begin{pmatrix} 1.4 \\times 10^{-4}  8.0 \\times 10^{-5} \\\\ 8.0 \\times 10^{-5}  2.7 \\times 10^{-4} \\end{pmatrix} + 4.92 \\times 10^5 I = \\begin{pmatrix} 2.24 \\times 10^5  1.28 \\times 10^5 \\\\ 1.28 \\times 10^5  4.32 \\times 10^5 \\end{pmatrix} + \\begin{pmatrix} 4.92 \\times 10^5  0 \\\\ 0  4.92 \\times 10^5 \\end{pmatrix} $$\n$$ \\sigma^{-} = \\begin{pmatrix} 7.16 \\times 10^5  1.28 \\times 10^5 \\\\ 1.28 \\times 10^5  9.24 \\times 10^5 \\end{pmatrix}\\,\\mathrm{Pa} $$\n\n**3. Traction Jump Vector**\nThe edge $e$ is the segment $\\overline{BC}$ connecting $B(1,0)$ and $C(0,1)$. The vector along the edge is $C-B = (-1,1)$. An orthogonal vector is $(1,1)$. For $T^+ = \\triangle ABC$, the vertex $A(0,0)$ is on the side of the line $x+y-1=0$ where $x+y-10$, so the outward normal points in the direction where $x+y-10$. Thus, the outward unit normal from $T^{+}$ is:\n$$ n^{+} = \\frac{1}{\\sqrt{1^2+1^2}}(1,1) = \\frac{1}{\\sqrt{2}}\\begin{pmatrix}1 \\\\ 1\\end{pmatrix} $$\nThe traction jump is defined as $\\llbracket \\sigma(u_h)n \\rrbracket = \\sigma^{+}n^{+} + \\sigma^{-}n^{-}$. Since $n^{-} = -n^{+}$, this simplifies to $\\llbracket \\sigma(u_h)n \\rrbracket = (\\sigma^{+} - \\sigma^{-})n^{+}$. We compute the difference in stress tensors:\n$$ \\sigma^{+} - \\sigma^{-} = 10^5 \\left( \\begin{pmatrix} 6.4  1.2 \\\\ 1.2  9.6 \\end{pmatrix} - \\begin{pmatrix} 7.16  1.28 \\\\ 1.28  9.24 \\end{pmatrix} \\right) = 10^5 \\begin{pmatrix} -0.76  -0.08 \\\\ -0.08  0.36 \\end{pmatrix} $$\nThe traction jump vector $J = \\llbracket \\sigma(u_h)n \\rrbracket$ is:\n$$ J = 10^5 \\begin{pmatrix} -0.76  -0.08 \\\\ -0.08  0.36 \\end{pmatrix} \\frac{1}{\\sqrt{2}}\\begin{pmatrix}1 \\\\ 1\\end{pmatrix} = \\frac{10^5}{\\sqrt{2}} \\begin{pmatrix} -0.76 - 0.08 \\\\ -0.08 + 0.36 \\end{pmatrix} = \\frac{10^5}{\\sqrt{2}}\\begin{pmatrix} -0.84 \\\\ 0.28 \\end{pmatrix} $$\nSince $\\sigma^{+}$ and $\\sigma^{-}$ are constant on their respective elements, the jump vector $J$ is constant along the edge $e$.\n\n**4. Edge Norm Calculation**\nThe norm is $\\|J\\|_{0,e} = \\left(\\int_e |J|^2 \\mathrm{d}s\\right)^{1/2}$. As $J$ is constant, this simplifies to $\\|J\\|_{0,e} = \\sqrt{|J|^2 \\cdot \\mathrm{length}(e)} = |J| \\sqrt{\\mathrm{length}(e)}$.\nThe length of edge $e$ is $L_e = \\sqrt{(1-0)^2 + (0-1)^2} = \\sqrt{2}\\,\\mathrm{m}$.\nThe Euclidean norm of the jump vector is:\n$$ |J| = \\left| \\frac{10^5}{\\sqrt{2}}\\begin{pmatrix} -0.84 \\\\ 0.28 \\end{pmatrix} \\right| = \\frac{10^5}{\\sqrt{2}} \\sqrt{(-0.84)^2 + (0.28)^2} = \\frac{10^5}{\\sqrt{2}} \\sqrt{0.7056 + 0.0784} = \\frac{10^5}{\\sqrt{2}} \\sqrt{0.784} $$\n$$ |J| = \\frac{10^5}{\\sqrt{2}} (0.28 \\sqrt{10}) = 0.28 \\times 10^5 \\sqrt{5}\\,\\mathrm{N}\\,\\mathrm{m}^{-2} $$\nFinally, we compute the edge norm:\n$$ \\|J\\|_{0,e} = |J| \\sqrt{L_e} = (0.28 \\times 10^5 \\sqrt{5}) \\sqrt{\\sqrt{2}} = 0.28 \\times 10^5 \\sqrt{5} \\sqrt[4]{2} $$\nThe units are $(\\mathrm{N}\\,\\mathrm{m}^{-2}) \\cdot \\mathrm{m}^{1/2} = \\mathrm{N}\\,\\mathrm{m}^{-3/2}$.\n\n**5. Final Numerical Value**\nWe now compute the numerical value and round to four significant figures:\n$$ \\|J\\|_{0,e} = 2.8 \\times 10^4 \\times \\sqrt{5} \\times \\sqrt[4]{2} \\approx 2.8 \\times 10^4 \\times (2.2360679...) \\times (1.1892071...) $$\n$$ \\|J\\|_{0,e} \\approx 2.8 \\times 10^4 \\times (2.6591479...) \\approx 7.445614... \\times 10^4 $$\nRounding to four significant figures, we get $7.446 \\times 10^4$.", "answer": "$$\\boxed{7.446 \\times 10^{4}}$$", "id": "3541963"}, {"introduction": "Moving beyond global error norms, this practice delves into goal-oriented error estimation using the Dual-Weighted Residual (DWR) method. You will compute an error estimate for a specific quantity of interest—the solution at a single point—by formulating and solving the corresponding adjoint problem for a Discontinuous Galerkin discretization [@problem_id:3361410]. This comprehensive exercise showcases the elegance of the DWR framework and its power in providing sharp estimates for targeted outputs.", "problem": "Consider the one-dimensional Poisson problem on the open interval $\\Omega=(0,1)$ with homogeneous Dirichlet boundary conditions,\n$$\n- u'' = f \\quad \\text{in } \\Omega, \\qquad u(0)=0,\\quad u(1)=0,\n$$\nwhere $f(x)=1$. Let the partition $\\mathcal{T}_h$ consist of the two elements $K_1=(0,\\tfrac{1}{2})$ and $K_2=(\\tfrac{1}{2},1)$, and consider the Discontinuous Galerkin (DG) finite element space of piecewise polynomials of degree at most one on each element. Use the Symmetric Interior Penalty Galerkin (SIPG) method with penalty parameter $\\sigma=2$.\n\nDefine on each element $K_j$ the affine mapping $x=\\tfrac{1}{4}(\\xi+1)$ for $K_1$ and $x=\\tfrac{1}{2}+\\tfrac{1}{4}(\\xi+1)$ for $K_2$ from the reference interval $[-1,1]$, and the local basis functions $\\phi_{j,0}(\\xi)=1$ and $\\phi_{j,1}(\\xi)=\\xi$. Denote the four global basis functions by $b_1=\\phi_{1,0}$, $b_2=\\phi_{1,1}$, $b_3=\\phi_{2,0}$, and $b_4=\\phi_{2,1}$. The SIPG bilinear form $a(\\cdot,\\cdot)$ on this mesh is defined by\n$$\na(u,v) = \\sum_{K\\in \\mathcal{T}_h}\\int_K u' v'\\,dx \\;-\\; \\sum_{F\\in \\mathcal{F}_h^{\\mathrm{int}}}\\Big( \\{u'\\}[v] + \\{v'\\}[u] \\Big) \\;+\\; \\sum_{F\\in \\mathcal{F}_h^{\\mathrm{int}}}\\frac{\\sigma}{h_F}[u][v] \n\\\\ - \\sum_{F\\in \\mathcal{F}_h^{\\partial}}\\Big( u' n\\, v + v' n\\, u \\Big) \\;+\\; \\sum_{F\\in \\mathcal{F}_h^{\\partial}}\\frac{\\sigma}{h_F} u v,\n$$\nwhere $\\mathcal{F}_h^{\\mathrm{int}}$ denotes the set of interior faces, $\\mathcal{F}_h^{\\partial}$ denotes the set of boundary faces, $n$ is the outward unit normal, $h_F$ is the face length, $\\{\\,\\cdot\\,\\}$ denotes the average across an interior face, and $[\\,\\cdot\\,]$ denotes the jump across an interior face. For Dirichlet boundary conditions, the boundary terms incorporate the boundary data via Nitsche’s method.\n\nThe goal functional is the point evaluation $J(u)=u(x_0)$ with $x_0=\\tfrac{3}{4}$.\n\nTasks:\n1. Starting from the SIPG bilinear form, formulate the discrete adjoint (dual) problem associated with the goal functional $J(u)=u(x_0)$, namely: find $z_h$ in the DG space such that $a(w_h,z_h)=J(w_h)$ for all $w_h$ in the DG space.\n2. Compute the discrete adjoint solution $z_h$ by solving the corresponding linear system.\n3. Compute the primal DG solution $u_h$ for the given right-hand side $f(x)=1$ by solving the SIPG linear system.\n4. Using the Dual-Weighted Residual (DWR) identity for symmetric bilinear forms, assemble a computable estimator for the goal error in the form\n$$\n\\eta = (f,z) - a(u_h,z),\n$$\nwhere $z$ is the continuous adjoint solving $-z''=\\delta_{x_0}$ with $z(0)=z(1)=0$, and evaluate $\\eta$ for the specified data and mesh. Express your final answer as a single exact value. No rounding is required.", "solution": "This problem requires solving the primal and dual (adjoint) problems using the specified Discontinuous Galerkin (DG) method and then using these solutions to evaluate an error estimator for a quantity of interest. The DWR error identity $J(u)-J(u_h) = (f,z) - a(u_h,z)$ gives the exact error in the functional, which we will calculate.\n\n### Preliminaries: Basis Functions and DG Parameters\nThe mesh consists of two elements $K_1=(0, 1/2)$ and $K_2=(1/2, 1)$, each of size $h=1/2$. The penalty parameter is $\\sigma=2$. The penalty term scaling is $\\sigma/h_F = 2/(1/2)=4$, assuming face length $h_F$ is the adjacent element size.\nThe four global basis functions are:\n- On $K_1$: $b_1(x)=1$, $b_2(x)=4x-1$.\n- On $K_2$: $b_3(x)=1$, $b_4(x)=4x-3$.\nAnd zero otherwise. Their derivatives are $b_1'=0, b_2'=4$ on $K_1$ and $b_3'=0, b_4'=4$ on $K_2$.\n\nKey values at faces:\n- **At $x=0$ (boundary, $n=-1$):** $b_1=1, b_2=-1$.\n- **At $x=1/2$ (interior):**\n  - From left ($K_1$): $b_1=1, b_2=1$. $b_1'=0, b_2'=4$.\n  - From right ($K_2$): $b_3=1, b_4=-1$. $b_3'=0, b_4'=4$.\n  - Jumps $[b_i] = b_i(1/2^+) - b_i(1/2^-)$: $[b_1]=-1, [b_2]=-1, [b_3]=1, [b_4]=-1$.\n  - Averages $\\{b_i'\\} = (b_i'(1/2^+) + b_i'(1/2^-))/2$: $\\{b_1'\\}=0, \\{b_2'\\}=2, \\{b_3'\\}=0, \\{b_4'\\}=2$.\n- **At $x=1$ (boundary, $n=1$):** $b_3=1, b_4=1$.\n\n### The Stiffness Matrix\nThe primal and dual problems share the same stiffness matrix $A$ with entries $A_{ij}=a(b_i, b_j)$. The bilinear form from the problem statement is:\n$a(u,v) = \\sum_K \\int_K u'v'dx - (\\{u'\\}[v]+\\{v'\\}[u])|_{1/2} + 4[u][v]|_{1/2} - (u'nv+v'nu)|_0 - (u'nv+v'nu)|_1 + 4(uv)|_0 + 4(uv)|_1$.\nWith normals $n(0)=-1, n(1)=1$, this becomes:\n$a(u,v) = \\sum_K \\int_K u'v'dx - (\\{u'\\}[v]+\\{v'\\}[u])_{1/2} + 4[u][v]_{1/2} + (u'v+v'u)_0 + 4(uv)_0 - (u'v+v'u)_1 + 4(uv)_1$.\nComputing the entries:\n- $A_{11}=a(b_1,b_1) = 4[b_1]^2 + 4 b_1(0)^2 = 4(-1)^2 + 4(1)^2 = 8$.\n- $A_{12}=a(b_1,b_2) = -(\\{b_2'\\}[b_1]) + 4[b_1][b_2] + (b_2'b_1)_0 + 4(b_1 b_2)_0 = -(2(-1)) + 4(-1)(-1) + 4(1) + 4(1)(-1) = 2+4+4-4=6$.\n- $A_{13}=a(b_1,b_3) = 4[b_1][b_3] = 4(-1)(1)=-4$.\n- $A_{22}=a(b_2,b_2) = \\int_0^{1/2} 4^2 dx - 2\\{b_2'\\}[b_2] + 4[b_2]^2 + 2(b_2'b_2)_0 + 4b_2(0)^2 = 8 - 2(2)(-1)+4(-1)^2+2(4)(-1)+4(-1)^2 = 8+4+4-8+4 = 12$.\nBy symmetry and structure, we can find the rest of the matrix:\n$$ A = \\begin{pmatrix} 8  6  -4  6 \\\\ 6  12  -6  8 \\\\ -4  -6  8  -6 \\\\ 6  8  -6  12 \\end{pmatrix} $$\n\n### Task 1  2: Discrete Adjoint Problem\nFind $z_h = \\sum z_j b_j$ such that $A \\mathbf{z} = \\mathbf{J}$, where $\\mathbf{J}_i = J(b_i) = b_i(3/4)$.\nThe point $x_0=3/4$ is in element $K_2$, so $b_1(3/4)=0$ and $b_2(3/4)=0$.\n- $J(b_1)=0$\n- $J(b_2)=0$\n- $J(b_3) = b_3(3/4)=1$\n- $J(b_4) = b_4(3/4) = 4(3/4)-3=0$\nSo, the RHS vector is $\\mathbf{J} = (0, 0, 1, 0)^T$. Solving the linear system $A \\mathbf{z} = (0,0,1,0)^T$ yields:\n$$ \\mathbf{z} = (-1/24, 1/8, 7/24, 1/8)^T $$\nThe discrete adjoint solution $z_h$ is given by these coefficients.\n\n### Task 3: Discrete Primal Problem\nFind $u_h = \\sum u_j b_j$ such that $A \\mathbf{u} = \\mathbf{F}$, where $\\mathbf{F}_i = \\int_\\Omega f b_i dx = \\int_\\Omega b_i dx$.\n- $F_1 = \\int_0^{1/2} 1 dx = 1/2$.\n- $F_2 = \\int_0^{1/2} (4x-1) dx = [2x^2-x]_0^{1/2} = 0$.\n- $F_3 = \\int_{1/2}^1 1 dx = 1/2$.\n- $F_4 = \\int_{1/2}^1 (4x-3) dx = [2x^2-3x]_{1/2}^1 = 0$.\nThe RHS vector is $\\mathbf{F} = (1/2, 0, 1/2, 0)^T$. The problem is symmetric, so we expect a symmetric solution $u_1=u_3, u_2=-u_4$.\nSolving the linear system $A \\mathbf{u} = (1/2,0,1/2,0)^T$ yields:\n$$ \\mathbf{u} = (1/8, 0, 1/8, 0)^T $$\nThis means the primal DG solution is a piecewise constant function: $u_h(x) = 1/8$ for $x \\in (0,1/2) \\cup (1/2,1)$.\n\n### Task 4: Error Estimator Evaluation\nThe estimator is $\\eta = (f,z) - a(u_h,z)$.\n**1. Continuous Adjoint Solution $z$**\nThe continuous adjoint problem is $-z'' = \\delta_{x_0}$ with $z(0)=z(1)=0$ and $x_0=3/4$. The solution is the Green's function for the domain:\n$$ z(x) = \\begin{cases} (1-x_0)x = \\frac{1}{4}x  \\text{if } x \\le 3/4 \\\\ x_0(1-x) = \\frac{3}{4}(1-x)  \\text{if } x > 3/4 \\end{cases} $$\nIts derivatives are $z'(x) = 1/4$ for $x  3/4$ and $z'(x) = -3/4$ for $x > 3/4$.\n\n**2. Compute $(f,z)$**\nSince $f(x)=1$, this is the integral of $z$ over $\\Omega$:\n$$ (f,z) = \\int_0^1 z(x) dx = \\int_0^{3/4} \\frac{1}{4}x \\,dx + \\int_{3/4}^1 \\frac{3}{4}(1-x) \\,dx $$\n$$ = \\frac{1}{4}\\left[\\frac{x^2}{2}\\right]_0^{3/4} + \\frac{3}{4}\\left[x-\\frac{x^2}{2}\\right]_{3/4}^1 = \\frac{1}{8}\\left(\\frac{9}{16}\\right) + \\frac{3}{4}\\left( (1-\\frac{1}{2}) - (\\frac{3}{4}-\\frac{9}{32}) \\right) $$\n$$ = \\frac{9}{128} + \\frac{3}{4}\\left( \\frac{1}{2} - \\frac{15}{32} \\right) = \\frac{9}{128} + \\frac{3}{4}\\left( \\frac{1}{32} \\right) = \\frac{9}{128} + \\frac{3}{128} = \\frac{12}{128} = \\frac{3}{32} $$\n\n**3. Compute $a(u_h, z)$**\nWe evaluate the bilinear form with $u=u_h=1/8$ and $v=z$.\n$u_h$ is piecewise constant, so $u_h'=0$. The jump $[u_h]=0$ at $x=1/2$.\nThe bilinear form simplifies significantly:\n$a(u_h,z) = \\sum_K \\int_K 0 \\cdot z' dx - \\sum_{F_{int}} (\\dots) + \\sum_{F_{\\partial}}(\\dots)$.\nThe volume integrals are zero. Since $[u_h]=0$ and $u_h'=0$, and $z$ is continuous ($[z]=0$), all interior face terms are zero. We are left with boundary terms:\n$a(u_h, z) = (u_h'z+z'u_h)|_0 + 4(u_h z)|_0 - (u_h'z+z'u_h)|_1 + 4(u_h z)|_1$.\nSince $z(0)=z(1)=0$ and $u_h'=0$, this becomes:\n$a(u_h,z) = z'(0)u_h(0) - z'(1)u_h(1)$.\nWe have $u_h(0)=1/8$, $u_h(1)=1/8$. From the continuous adjoint solution, $z'(0)=1/4$ and $z'(1)=-3/4$.\n$$ a(u_h,z) = \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{8}\\right) - \\left(-\\frac{3}{4}\\right)\\left(\\frac{1}{8}\\right) = \\frac{1}{32} + \\frac{3}{32} = \\frac{4}{32} = \\frac{1}{8} $$\n\n**4. Final Estimator Value**\n$$ \\eta = (f,z) - a(u_h,z) = \\frac{3}{32} - \\frac{1}{8} = \\frac{3}{32} - \\frac{4}{32} = -\\frac{1}{32} $$\nThis value is the exact error in the functional, $J(u) - J(u_h) = u(3/4) - u_h(3/4) = \\frac{3}{32} - \\frac{1}{8} = -\\frac{1}{32}$.", "answer": "$$\n\\boxed{-\\frac{1}{32}}\n$$", "id": "3361410"}, {"introduction": "This final practice transitions from calculation to implementation, guiding you through the construction of a complete adaptive mesh refinement (AMR) algorithm. Using a surrogate error indicator that models a classic corner singularity, you will implement the `ESTIMATE-MARK-REFINE` cycle driven by the theoretically-grounded Dörfler marking strategy [@problem_id:3542038]. By analyzing the resulting convergence rates, you will witness firsthand how a posteriori error estimators are used to achieve optimal efficiency in practical computations.", "problem": "Consider small-strain linear elasticity in two dimensions on an L-shaped domain with a re-entrant corner. Let the body be modeled in plane strain with Lamé parameters $\\lambda$ and $\\mu$, and displacement field $\\mathbf{u}$ governed by the strong form $-\\nabla \\cdot \\boldsymbol{\\sigma} = \\mathbf{f}$ in $\\Omega$, with $\\boldsymbol{\\sigma} = \\lambda (\\nabla \\cdot \\mathbf{u}) \\mathbf{I} + 2 \\mu \\, \\boldsymbol{\\varepsilon}(\\mathbf{u})$ and $\\boldsymbol{\\varepsilon}(\\mathbf{u}) = \\tfrac{1}{2}(\\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^{\\top})$, subject to mixed boundary conditions. In domains with re-entrant corners, solutions exhibit singular stress states and reduced regularity near the corner. Adaptive mesh refinement guided by a posteriori error estimation is used to restore optimal convergence rates in the energy norm.\n\nA residual-jump-based estimator partitions the global error surrogate into local indicators $\\eta_K$ per element $K$, and is known to be both reliable and efficient under standard assumptions in the Finite Element Method (FEM). A bulk-chasing strategy selects elements to refine so that a fixed fraction of the global estimator is addressed at each step. One such strategy is known as Dörfler marking. You must implement this marking in a minimal-cardinality sense: among all subsets of elements that capture a prescribed fraction of the total squared indicator, select one with the smallest number of elements.\n\nTo make this implementable without solving the linear elasticity equations, use a scalar surrogate consistent with the singularity class of re-entrant corners (as widely employed in analysis of adaptive methods). Specifically, on the L-shaped domain $\\Omega = [-1,1]^2 \\setminus \\big([0,1]\\times[-1,0]\\big)$ with a re-entrant corner at the origin, model the local indicator scaling near the corner by the power-law\n$$\n\\eta_K \\approx c \\, \\sqrt{h_K} \\, r_K^{\\alpha - 1},\n$$\nwhere $c$ is a positive constant (set $c=1$), $h_K$ is the element size, $r_K$ is the Euclidean distance from the element center to the origin, and $\\alpha = 0.544483736782$ is the L-shaped singularity exponent associated with a homogeneous scalar elliptic model. This surrogate is consistent with the behavior of residual-jump error estimators for problems with corner singularities and captures the necessary near-corner refinement bias.\n\nYour task is to:\n- Construct an initial uniform square tessellation over $\\Omega$ by subdividing $[-1,1]^2$ into $n_x \\times n_y$ equal squares and discarding those whose centers lie in the excised square $[0,1]\\times[-1,0]$. Use $n_x = n_y = 12$.\n- For each element $K$, compute $r_K$ and $\\eta_K$ using the above surrogate. Avoid division by zero by taking $r_K \\leftarrow \\max(r_K, 10^{-6})$.\n- Implement the minimal-cardinality bulk-chasing marking strategy that, for a given parameter $\\theta \\in (0,1)$, selects a set $\\mathcal{M}$ so that the selected elements’ squared indicators capture at least a fraction of the total squared estimator, while the number of marked elements is as small as possible.\n- Refine marked elements by subdividing each selected square into four child squares of half size. Children whose centers fall outside $\\Omega$ must be discarded; those inside replace their parent in the mesh. Recompute indicators on the refined mesh.\n- Repeat the mark-refine cycle for a fixed number of refinement steps, using the same $\\theta$ each time. Use $N_{\\text{steps}} = 7$.\n- At each step $k$, compute the global estimator $E_k = \\left(\\sum_{K} \\eta_K^2\\right)^{1/2}$ and the number of elements $N_k$ currently in the mesh.\n- Estimate the convergence rate $p(\\theta)$ by fitting a line to $(\\log N_k, \\log E_k)$ over the last five refinement steps and taking $p(\\theta) = -\\text{slope}$. This approximates the rate in the model $E(N) \\approx C N^{-p}$ for large $N$.\n\nImplement the above in a single program that evaluates several values of $\\theta$ and reports the estimated convergence rates. You must ensure numerical stability and scientific plausibility of the surrogate and the refinement procedure.\n\nTest suite:\n- Use the following values of $\\theta$: $0.15$, $0.3$, $0.5$, $0.7$, $0.9$.\n- For each $\\theta$, run the full refinement loop and compute $p(\\theta)$ as specified.\n\nAnswer specification:\n- The final output of your program must be a single line containing the list of estimated rates for all $\\theta$ values in the test suite, in the order provided.\n- The format must be a comma-separated list enclosed in square brackets, for example $[p(0.15),p(0.3),p(0.5),p(0.7),p(0.9)]$.\n- Each entry must be a floating-point number. No physical units are required and no angles are involved.\n\nYour program must be self-contained and runnable without any external inputs or files.", "solution": "The problem provides a detailed specification for simulating an adaptive mesh refinement (AMR) procedure for a problem with a corner singularity. The validation confirms that the problem is scientifically sound, well-posed, and contains all necessary information for a deterministic implementation. It is a standard numerical experiment in the field of adaptive finite element methods (AFEM).\n\nThe core task is to implement a `mark-refine` cycle driven by Dörfler marking, using a surrogate error indicator that models the behavior of solutions to elliptic partial differential equations on an L-shaped domain. The ultimate goal is to estimate the convergence rate of the global error estimator as a function of the number of elements for different values of the marking parameter $\\theta$.\n\n**1. Domain and Initial Mesh**\n\nThe computational domain is the L-shaped region $\\Omega = [-1,1]^2 \\setminus \\big([0,1]\\times[-1,0]\\big)$, which features a re-entrant corner at the origin $(0,0)$. This corner induces a singularity in the solution of elliptic boundary value problems, degrading the performance of standard numerical methods on uniform meshes.\n\nThe simulation begins by constructing an initial mesh. A square domain $[-1,1]^2$ is first tessellated into a uniform grid of $n_x \\times n_y$ smaller squares, with $n_x = n_y = 12$. The side length of these initial elements is $h_0 = (1 - (-1))/12 = 2/12 = 1/6$. Elements whose geometric center $(x_c, y_c)$ falls within the excised quadrant, i.e., satisfies $x_c  0$ and $y_c  0$, are discarded. This process results in an initial mesh of $N_0 = 12^2 - 6^2 = 144 - 36 = 108$ square elements, which accurately represents the domain $\\Omega$.\n\nEach element $K$ in the mesh is represented by its center coordinates and its side length $h_K$.\n\n**2. Surrogate Error Indicator**\n\nInstead of solving the full linear elasticity equations, which is computationally expensive, we use a surrogate model for the local error indicator $\\eta_K$ on each element $K$. This model is designed to mimic the spatial distribution of the true error, which is dominated by the corner singularity. The formula provided is:\n$$\n\\eta_K = c \\, \\sqrt{h_K} \\, r_K^{\\alpha - 1}\n$$\nwhere:\n- $c=1$ is a constant.\n- $h_K$ is the side length of the square element $K$.\n- $r_K$ is the Euclidean distance from the center of element $K$ to the re-entrant corner at the origin. To prevent division by zero for elements possibly centered at the origin, $r_K$ is clamped to a minimum value: $r_K \\leftarrow \\max(r_K, 10^{-6})$.\n- $\\alpha = 0.544483736782$ is the strength of the singularity. For the Poisson equation on an L-shaped domain, the solution $u$ near the corner has the form $u \\sim r^{\\alpha} \\sin(\\alpha \\phi)$, where $(r, \\phi)$ are polar coordinates. The error is concentrated where gradients of the solution are large. Since $\\alpha  1$, the term $r_K^{\\alpha - 1}$ becomes large as $r_K \\to 0$, correctly identifying elements near the singularity as having a larger error contribution.\n\n**3. The Adaptive `MARK-REFINE` Algorithm**\n\nThe core of the simulation is an iterative loop that adaptively refines the mesh. For a given marking parameter $\\theta \\in (0,1)$, the loop runs for $N_{\\text{steps}}=7$ iterations. Each iteration consists of four main steps: COMPUTE, MARK, REFINE, and RECORD.\n\n**3A. COMPUTE**\nFor the current mesh $\\mathcal{T}_k$ at step $k$, we first compute the error indicator $\\eta_K$ for every element $K \\in \\mathcal{T}_k$ using the surrogate formula. Then, the total squared error estimator is calculated as the sum of the squares of the local indicators:\n$$\nE_k^2 = \\sum_{K \\in \\mathcal{T}_k} \\eta_K^2\n$$\n\n**3B. MARK**\nThe marking step selects a subset of elements $\\mathcal{M}_k \\subset \\mathcal{T}_k$ for refinement. We employ Dörfler marking (also known as bulk chasing), which aims to refine a sufficient number of elements to guarantee a reduction in the total error. The strategy is to find a set $\\mathcal{M}_k$ with the minimal possible number of elements (minimal cardinality) that satisfies the criterion:\n$$\n\\sum_{K \\in \\mathcal{M}_k} \\eta_K^2 \\ge \\theta E_k^2\n$$\nAlgorithmically, this is achieved by:\n1. Sorting all elements in descending order based on their indicator values $\\eta_K$.\n2. Iterating through the sorted list, adding elements to the marked set $\\mathcal{M}_k$ and accumulating their squared indicators.\n3. Stopping as soon as the accumulated sum reaches the target threshold $\\theta E_k^2$. This greedy approach guarantees that we select the elements with the largest errors while marking the smallest number of them.\n\n**3C. REFINE**\nThe marked elements in $\\mathcal{M}_k$ are refined, while unmarked elements are carried over to the next mesh $\\mathcal{T}_{k+1}$. The refinement procedure for a square element is a simple quadrisection:\n1. Each marked square $K \\in \\mathcal{M}_k$ is subdivided into four equal smaller squares (children), each with half the side length of the parent.\n2. Each child element is checked for validity: its center must lie within the domain $\\Omega$. Children whose centers are in the excised region $[0,1] \\times [-1,0]$ are discarded.\n3. The new mesh $\\mathcal{T}_{k+1}$ is formed by the union of the set of unmarked elements from $\\mathcal{T}_k$ and the set of all valid new child elements.\n\n**3D. RECORD**\nAt each step $k$, we record the number of elements $N_k = |\\mathcal{T}_k|$ and the global error estimator $E_k = \\sqrt{E_k^2}$.\n\n**4. Convergence Rate Estimation**\n\nThe theory of AFEM predicts that for an appropriate adaptive strategy, the convergence of the error $E$ with respect to the number of elements $N$ should follow a power law:\n$$\nE(N) \\approx C N^{-p}\n$$\nwhere $p$ is the convergence rate. For problems with singularities, uniform refinement yields a suboptimal rate, but adaptive refinement can restore the optimal rate, which is related to the singularity exponent $\\alpha$. Taking the logarithm of the above relation yields a linear equation:\n$$\n\\log E \\approx \\log C - p \\log N\n$$\nThis shows that a plot of $\\log E$ versus $\\log N$ should be a straight line with a slope of $-p$.\n\nTo estimate $p$, we perform a linear regression on the collected data points $(\\log N_k, \\log E_k)$. As specified, we use the data from the last five refinement steps (from $k=2$ to $k=6$) to estimate the asymptotic rate, ignoring any initial transient behavior. The slope of the best-fit line is calculated, and the convergence rate is determined as $p(\\theta) = -\\text{slope}$. This entire process is repeated for each value of $\\theta$ in the test suite.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements an adaptive mesh refinement simulation for an L-shaped domain\n    to estimate the convergence rate of a surrogate error estimator.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    ALPHA = 0.544483736782\n    THETAS = [0.15, 0.3, 0.5, 0.7, 0.9]\n    N_STEPS = 7\n    NX, NY = 12, 12\n    R_CLAMP = 1e-6\n\n    def is_in_domain(center):\n        \"\"\"Checks if a point is within the L-shaped domain.\"\"\"\n        x, y = center\n        # The excised region is where x > 0 and y  0.\n        return not (x > 0 and y  0)\n\n    def generate_initial_mesh():\n        \"\"\"Creates the initial uniform mesh on the L-shaped domain.\"\"\"\n        h_initial = 2.0 / NX\n        mesh_elements = []\n        for i in range(NX):\n            for j in range(NY):\n                xc = -1.0 + h_initial / 2.0 + i * h_initial\n                yc = -1.0 + h_initial / 2.0 + j * h_initial\n                if is_in_domain((xc, yc)):\n                    # Each element is [center_x, center_y, size]\n                    mesh_elements.append([xc, yc, h_initial])\n        return np.array(mesh_elements)\n\n    def run_simulation(theta):\n        \"\"\"\n        Runs the full mark-refine simulation for a given theta value.\n        \"\"\"\n        mesh = generate_initial_mesh()\n        log_N_E_data = []\n\n        for step in range(N_STEPS):\n            # 1. COMPUTE: Indicators and global estimator\n            if mesh.shape[0] == 0:\n                if len(log_N_E_data) >= 5:\n                    break\n                else: \n                    return np.nan \n\n            centers = mesh[:, :2]\n            sizes = mesh[:, 2]\n            \n            r_k = np.linalg.norm(centers, axis=1)\n            r_k = np.maximum(r_k, R_CLAMP)\n            \n            eta_k = np.sqrt(sizes) * r_k**(ALPHA - 1)\n            eta_k_sq = eta_k**2\n            \n            E_k_sq = np.sum(eta_k_sq)\n            E_k = np.sqrt(E_k_sq)\n            N_k = mesh.shape[0]\n\n            # 2. RECORD: Store log-log data\n            log_N_E_data.append([np.log(N_k), np.log(E_k)])\n\n            # Stop after recording the last step's data\n            if step == N_STEPS - 1:\n                break\n\n            # 3. MARK: Dörfler marking\n            total_eta_sq = E_k_sq\n            target_sum_sq = theta * total_eta_sq\n            \n            sorted_indices = np.argsort(eta_k)[::-1]\n            sorted_eta_k_sq = eta_k_sq[sorted_indices]\n            \n            cumulative_sum_sq = np.cumsum(sorted_eta_k_sq)\n            \n            # Find the number of elements to mark\n            num_to_mark = np.searchsorted(cumulative_sum_sq, target_sum_sq) + 1\n            \n            marked_indices = sorted_indices[:num_to_mark]\n            unmarked_indices = sorted_indices[num_to_mark:]\n\n            # 4. REFINE: Create the new mesh\n            unmarked_elements = mesh[unmarked_indices]\n            \n            newly_refined_elements = []\n            for idx in marked_indices:\n                parent_center = mesh[idx, :2]\n                parent_size = mesh[idx, 2]\n                child_size = parent_size / 2.0\n                offset = child_size / 2.0\n                \n                # Generate 4 children\n                child_centers = [\n                    parent_center + np.array([-offset, -offset]),\n                    parent_center + np.array([ offset, -offset]),\n                    parent_center + np.array([-offset,  offset]),\n                    parent_center + np.array([ offset,  offset]),\n                ]\n                \n                for child_center in child_centers:\n                    if is_in_domain(child_center):\n                        newly_refined_elements.append([child_center[0], child_center[1], child_size])\n            \n            if newly_refined_elements:\n                mesh = np.vstack((unmarked_elements, np.array(newly_refined_elements)))\n            else:\n                mesh = unmarked_elements\n        \n        # 5. ESTIMATE CONVERGENCE RATE\n        # Use the last 5 data points for linear regression\n        if len(log_N_E_data)  5:\n            return np.nan \n\n        last_5_data = np.array(log_N_E_data[-5:])\n        log_N = last_5_data[:, 0]\n        log_E = last_5_data[:, 1]\n        \n        # Perform linear regression: log_E = slope * log_N + intercept\n        slope, _ = np.polyfit(log_N, log_E, 1)\n        \n        # Convergence rate p = -slope\n        p_theta = -slope\n        return p_theta\n\n    # --- Main Execution ---\n    results = []\n    for theta in THETAS:\n        rate = run_simulation(theta)\n        results.append(rate)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3542038"}]}