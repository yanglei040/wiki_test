{"hands_on_practices": [{"introduction": "The first step toward mastering any numerical method is to build it. This practice guides you through the implementation of a Flux Reconstruction (FR) scheme for the linear advection equation, focusing on the core components that define the method's behavior. By constructing the scheme with different sets of solution points—Gauss, Lobatto, and equidistant nodes—you will directly investigate how this fundamental choice impacts the energy stability of the discretization [@problem_id:3386483], a critical factor for robust numerical simulations.", "problem": "Consider the one-dimensional linear advection conservation law on a periodic domain,\n$$\nu_t + a\\,u_x = 0,\\quad x\\in[0,L],\\ t\\ge 0,\n$$\nwith constant advection speed $a>0$ and periodic boundary conditions. Discretize the domain into $N$ uniform elements of size $h=L/N$ and approximate the solution in each element by a polynomial of degree $p$ in the reference coordinate $\\xi\\in[-1,1]$. Within each element, use a nodal representation with $n=p+1$ distinct nodes $\\{\\xi_i\\}_{i=1}^n$ and their associated discrete mass matrix defined by quadrature weights.\n\nThe Flux Reconstruction (FR) method, also referred to as Correction Procedure via Reconstruction (CPR), augments the nodal derivative of the interpolated flux with a correction built from interface flux differences and chosen correction functions. In the strong, element-wise form with periodic coupling, and for $a>0$ (inflow at the left face), the semi-discrete scheme can be written as\n$$\n\\frac{d\\mathbf{u}_e}{dt} \\;=\\; -\\frac{2a}{h}\\left( \\mathbf{D}\\,\\mathbf{u}_e \\;+\\; c\\,\\mathbf{g}'_L\\left( u^{\\text{num}}_{e-1,R} - u^{\\text{poly}}_{e,L} \\right)\\right),\n$$\nwhere $\\mathbf{u}_e\\in\\mathbb{R}^n$ is the vector of nodal solution values in element $e$, $\\mathbf{D}\\in\\mathbb{R}^{n\\times n}$ is the nodal differentiation matrix for the chosen nodes, $u^{\\text{poly}}_{e,L}$ is the left boundary value obtained by interpolation, $u^{\\text{num}}_{e-1,R}$ is the incoming right boundary value from the left neighbor via the numerical flux, and $c$ is a scalar correction amplitude. The boundary values emerge from evaluating the nodal Lagrange basis at $\\xi=-1$ and $\\xi=+1$. Denote the corresponding evaluation row vectors by $\\mathbf{v}_L^T$ and $\\mathbf{v}_R^T$, respectively, so that $u^{\\text{poly}}_{e,L}=\\mathbf{v}_L^T\\mathbf{u}_e$ and $u^{\\text{num}}_{e-1,R}=\\mathbf{v}_R^T\\mathbf{u}_{e-1}$ for $a>0$ with upwinding. The discrete mass matrix $\\mathbf{M}\\in\\mathbb{R}^{n\\times n}$ is defined as the diagonal matrix of quadrature weights associated with the chosen nodal distribution, providing the discrete inner product $\\langle \\mathbf{u},\\mathbf{v}\\rangle_{\\mathbf{M}}=\\mathbf{u}^T\\mathbf{M}\\mathbf{v}$.\n\nYou will compare three nodal distributions:\n- Legendre–Gauss nodes with their exact Gauss quadrature weights.\n- Legendre–Gauss–Lobatto nodes with Lobatto quadrature weights.\n- Equidistant nodes on $[-1,1]$ with closed Newton–Cotes quadrature weights determined by exactness on polynomials up to degree $n-1$.\n\nFor the correction function at the left face, select the unique polynomial of degree $p+1$ defined by\n$$\ng_L(\\xi) = s_p\\;\\frac{1-\\xi}{2}\\;P_p(\\xi),\\quad s_p := \\frac{1}{P_p(-1)} = (-1)^p,\n$$\nwhere $P_p(\\xi)$ is the Legendre polynomial of degree $p$. This choice enforces $g_L(-1)=1$, $g_L(+1)=0$, and yields a non-constant derivative\n$$\ng_L'(\\xi) = s_p\\left[ -\\frac{1}{2}P_p(\\xi) + \\frac{1-\\xi}{2}P_p'(\\xi)\\right],\n$$\nwhose nodal sampling produces the vector $\\mathbf{g}'_L\\in\\mathbb{R}^n$ used in the FR correction.\n\nDefine the global semi-discrete operator $\\mathbf{A}\\in\\mathbb{R}^{(Nn)\\times(Nn)}$ that advances the concatenated state $\\mathbf{U}\\in\\mathbb{R}^{Nn}$ formed by stacking all element-wise nodal states $\\{\\mathbf{u}_e\\}_{e=0}^{N-1}$. With periodic coupling, the operator has block structure with intra-element terms involving $\\mathbf{D}$ and inter-element inflow coupling through $\\mathbf{g}'_L\\mathbf{v}_R^T$. Let the global block-diagonal mass matrix be $\\mathbf{M}_{\\text{glob}}=\\operatorname{diag}(\\mathbf{M},\\dots,\\mathbf{M})\\in\\mathbb{R}^{(Nn)\\times(Nn)}$.\n\nAs a stability metric based on the energy in the $\\mathbf{M}_{\\text{glob}}$ inner product, consider the symmetric operator\n$$\n\\mathbf{S}_{\\mathbf{M}} = \\frac{1}{2}\\left(\\mathbf{M}_{\\text{glob}}\\mathbf{A} + \\mathbf{A}^T\\mathbf{M}_{\\text{glob}}\\right).\n$$\nIts generalized eigenvalues with respect to $\\mathbf{M}_{\\text{glob}}$ characterize the instantaneous energy growth rate: non-positivity of the largest eigenvalue implies non-increasing discrete energy. To compare nodal distributions, you must:\n1. Construct $\\mathbf{A}$ for each nodal distribution and given $(p,N)$ using upwind numerical flux for $a>0$ on a periodic domain of length $L=1$.\n2. Compute the largest generalized eigenvalue of $\\mathbf{S}_{\\mathbf{M}}$ with respect to $\\mathbf{M}_{\\text{glob}}$, equivalently the maximum eigenvalue of the symmetric matrix $\\mathbf{C}=\\mathbf{M}_{\\text{glob}}^{-1/2}\\mathbf{S}_{\\mathbf{M}}\\mathbf{M}_{\\text{glob}}^{-1/2}$, as a real scalar stability indicator.\n3. Derive a correction scaling law $c_{\\text{norm}}$ for each nodal distribution that normalizes the effect of the discrete mass matrix across $n$ points, by requiring that the $\\mathbf{M}$-weighted norm of the derivative correction vector be equalized across nodal sets. Specifically, choose for each nodal set $S$,\n$$\nc_{\\text{norm}}^{(S)} \\ \\text{such that}\\ \\ \\left\\|\\mathbf{g}'_L\\right\\|_{\\mathbf{M}^{(S)}} \\, c_{\\text{norm}}^{(S)} \\ = \\ \\left\\|\\mathbf{g}'_L\\right\\|_{\\mathbf{M}^{(\\text{ref})}},\n$$\nwhere $\\|\\mathbf{w}\\|_{\\mathbf{M}} := \\sqrt{\\mathbf{w}^T\\mathbf{M}\\mathbf{w}}$ and $(\\text{ref})$ denotes a fixed reference nodal set. Use Legendre–Gauss–Lobatto as the reference in this task. Implement this normalization in the FR operator by scaling the correction amplitude $c$ with $c_{\\text{norm}}^{(S)}$.\n4. Quantify the impact of nodal distributions on the stability metric before and after applying the normalization.\n\nYour program must implement the above and produce numerical results for the following test suite, with $a=1$ and $L=1$:\n- Test case 1: $p=2$, $N=10$.\n- Test case 2: $p=3$, $N=8$.\n- Test case 3: $p=5$, $N=6$.\n\nFor each test case, and for each nodal distribution in the order Legendre–Gauss, Legendre–Gauss–Lobatto, Equidistant, compute two real numbers:\n- The largest eigenvalue of $\\mathbf{C}$ with $c=1$ (no normalization).\n- The largest eigenvalue of $\\mathbf{C}$ with the normalized correction amplitude $c=c_{\\text{norm}}^{(S)}$ derived above.\n\nThe final output format must be a single line containing a list of three lists, one per test case. Each inner list must contain six floating-point numbers in the order\n$$\n\\big[\\lambda_{\\max}^{\\text{Gauss}},\\ \\lambda_{\\max}^{\\text{Lobatto}},\\ \\lambda_{\\max}^{\\text{Equid}},\\ \\lambda_{\\max,\\text{norm}}^{\\text{Gauss}},\\ \\lambda_{\\max,\\text{norm}}^{\\text{Lobatto}},\\ \\lambda_{\\max,\\text{norm}}^{\\text{Equid}}\\big],\n$$\nwhere each $\\lambda_{\\max}$ is the largest eigenvalue of $\\mathbf{C}$ for the specified configuration. The line must be printed exactly as a Python list of lists, for example:\n$$\n\\texttt{[[x_{11},x_{12},x_{13},x_{14},x_{15},x_{16}],[x_{21},\\dots,x_{26}],[x_{31},\\dots,x_{36}]]}\n$$\nNo units are involved in this problem. Angles are not used. Percentages are not used.", "solution": "The user wants to analyze the stability of the Flux Reconstruction (FR) / Correction Procedure via Reconstruction (CPR) method for solving the one-dimensional linear advection equation. This analysis involves comparing three different sets of nodal points within each element: Legendre-Gauss (LG), Legendre-Gauss-Lobatto (LGL), and Equidistant nodes. The stability will be quantified by computing the largest eigenvalue of a specific symmetrized operator derived from the semi-discrete system. The problem also requires deriving and applying a normalization factor to the correction term to ensure a fair comparison between the different nodal distributions.\n\n### **Problem Validation**\n\n**Step 1: Extract Givens**\n\n- **Conservation Law**: $u_t + a\\,u_x = 0$, for $x\\in[0,L]$, $t\\ge 0$.\n- **Advection Speed**: Constant $a>0$.\n- **Boundary Conditions**: Periodic on $[0,L]$.\n- **Discretization**: $N$ uniform elements, size $h=L/N$.\n- **Approximation**: Polynomial of degree $p$ on $n=p+1$ nodes $\\{\\xi_i\\}_{i=1}^n$ in the reference element $\\xi\\in[-1,1]$.\n- **Nodal Sets**:\n  1. Legendre-Gauss (LG) nodes and weights.\n  2. Legendre-Gauss-Lobatto (LGL) nodes and weights.\n  3. Equidistant nodes with closed Newton-Cotes weights (exact for polynomials up to degree $n-1$).\n- **Semi-Discrete FR/CPR Form**: $\\frac{d\\mathbf{u}_e}{dt} = -\\frac{2a}{h}\\left( \\mathbf{D}\\,\\mathbf{u}_e + c\\,\\mathbf{g}'_L\\left( u^{\\text{num}}_{e-1,R} - u^{\\text{poly}}_{e,L} \\right)\\right)$.\n- **Terms in FR Form**:\n  - $\\mathbf{u}_e$: Vector of nodal solution values in element $e$.\n  - $\\mathbf{D}$: Nodal differentiation matrix.\n  - $u^{\\text{poly}}_{e,L} = \\mathbf{v}_L^T\\mathbf{u}_e$: Interpolated solution at the left boundary ($\\xi=-1$).\n  - $u^{\\text{num}}_{e-1,R} = \\mathbf{v}_R^T\\mathbf{u}_{e-1}$: Numerical flux from the right boundary of the left neighbor (upwinding for $a>0$).\n  - $c$: Scalar correction amplitude.\n  - $\\mathbf{g}'_L$: Vector of nodal values of the derivative of the correction function $g_L(\\xi)$.\n- **Correction Function**: $g_L(\\xi) = s_p\\;\\frac{1-\\xi}{2}\\;P_p(\\xi)$ with $s_p = (-1)^p$, where $P_p(\\xi)$ is the Legendre polynomial of degree $p$.\n- **Mass Matrix**: $\\mathbf{M}$ is a diagonal matrix of quadrature weights. Global mass matrix is $\\mathbf{M}_{\\text{glob}}=\\operatorname{diag}(\\mathbf{M},\\dots,\\mathbf{M})$.\n- **Stability Metric**: Largest eigenvalue of the symmetric matrix $\\mathbf{C}=\\mathbf{M}_{\\text{glob}}^{-1/2}\\mathbf{S}_{\\mathbf{M}}\\mathbf{M}_{\\text{glob}}^{-1/2}$, where $\\mathbf{S}_{\\mathbf{M}} = \\frac{1}{2}\\left(\\mathbf{M}_{\\text{glob}}\\mathbf{A} + \\mathbf{A}^T\\mathbf{M}_{\\text{glob}}\\right)$, and $\\mathbf{A}$ is the global semi-discrete operator ($\\frac{d\\mathbf{U}}{dt} = \\mathbf{A}\\mathbf{U}$).\n- **Correction Normalization**: Determine $c_{\\text{norm}}^{(S)}$ for each nodal set $S$ such that $\\left\\|\\mathbf{g}'_L\\right\\|_{\\mathbf{M}^{(S)}} \\, c_{\\text{norm}}^{(S)} = \\left\\|\\mathbf{g}'_L\\right\\|_{\\mathbf{M}^{(\\text{ref})}}$, where the reference set is LGL. The norm is $\\|\\mathbf{w}\\|_{\\mathbf{M}} = \\sqrt{\\mathbf{w}^T\\mathbf{M}\\mathbf{w}}$.\n- **Constants**: $a=1$, $L=1$.\n- **Test Cases**: $(p=2, N=10)$; $(p=3, N=8)$; $(p=5, N=6)$.\n- **Required Output**: For each test case, a list of six eigenvalues: $[\\lambda_{\\max}^{\\text{LG}}, \\lambda_{\\max}^{\\text{LGL}}, \\lambda_{\\max}^{\\text{Equid}}]$ with $c=1$, followed by $[\\lambda_{\\max,\\text{norm}}^{\\text{LG}}, \\lambda_{\\max,\\text{norm}}^{\\text{LGL}}, \\lambda_{\\max,\\text{norm}}^{\\text{Equid}}]$ with $c=c_{\\text{norm}}$.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem statement is examined against the validation criteria.\n\n- **Scientific Groundedness**: The problem is a standard exercise in the field of high-order numerical methods for PDEs, specifically focusing on the spectral properties of the FR/CPR formulation. All concepts (nodal bases, differentiation matrices, FR correction, energy stability analysis) are well-established in the scientific literature.\n- **Well-Posedness**: The problem is mathematically and algorithmically well-defined. All components necessary for the construction of the operators and subsequent eigenvalue analysis are specified. The tasks lead to a unique set of numerical results.\n- **Objectivity**: The problem is stated using precise, objective mathematical language, free from ambiguity or subjective claims.\n- **Flaw Checklist**:\n  1.  **Scientific/Factual Unsoundness**: None. The formulation is correct.\n  2.  **Non-Formalizable/Irrelevant**: None. The problem is a formal numerical analysis task directly relevant to its stated topic.\n  3.  **Incomplete/Contradictory Setup**: None. All required definitions for nodes, weights, matrices, and operators are provided or can be uniquely derived from standard principles.\n  4.  **Unrealistic/Infeasible**: None. The problem is a standard numerical experiment with feasible parameters.\n  5.  **Ill-Posed/Poorly Structured**: None. The problem is well-structured and leads to a unique, meaningful numerical solution (the set of eigenvalues).\n  6.  **Pseudo-Profound/Trivial**: None. The problem requires a non-trivial implementation of several concepts from numerical analysis and linear algebra, representing a legitimate computational task.\n  7.  **Outside Scientific Verifiability**: None. The results are numerically computable and can be independently verified.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. A complete solution will be provided.\n\n### **Solution Methodology**\n\nThe solution requires constructing the global semi-discrete operator $\\mathbf{A}$ and the global mass matrix $\\mathbf{M}_{\\text{glob}}$ for various configurations of polynomial degree $p$, element count $N$, and nodal distributions. The core steps for each configuration are:\n\n1.  **Generate Nodal Data**: For each nodal set (LG, LGL, Equidistant) with $n=p+1$ points:\n    -   Compute the node locations $\\{\\xi_i\\}_{i=1}^n \\in [-1, 1]$.\n    -   Compute the corresponding quadrature weights $\\{w_i\\}_{i=1}^n$. These form the diagonal of the element mass matrix $\\mathbf{M}$.\n\n2.  **Construct Element-wise Matrices**:\n    -   **Differentiation Matrix ($\\mathbf{D}$)**: Compute the $n \\times n$ matrix where $D_{ij} = \\ell_j'(\\xi_i)$, with $\\ell_j$ being the $j$-th Lagrange polynomial. A stable method using barycentric weights will be employed.\n    -   **Boundary Evaluation Vectors ($\\mathbf{v}_L^T, \\mathbf{v}_R^T$)**: These are row vectors containing the values of the Lagrange basis functions at $\\xi=-1$ and $\\xi=1$, respectively. For LGL nodes, which include the endpoints, these vectors are trivial (e.g., $\\mathbf{v}_L^T = [1, 0, \\dots, 0]$). For other nodes, they must be computed.\n    -   **Correction Function Vector ($\\mathbf{g}'_L$)**: Evaluate the derivative of the specified correction function, $g_L'(\\xi) = (-1)^p\\left[ -\\frac{1}{2}P_p(\\xi) + \\frac{1-\\xi}{2}P_p'(\\xi)\\right]$, at each nodal point $\\xi_i$ to form the vector $\\mathbf{g}'_L$.\n\n3.  **Normalization Factor Calculation**:\n    -   For each nodal set $S \\in \\{\\text{LG, LGL, Equidistant}\\}$, calculate the normalization factor $c_{\\text{norm}}^{(S)} = \\frac{\\|\\mathbf{g}'_L\\|_{\\mathbf{M}^{(\\text{LGL})}}}{\\|\\mathbf{g}'_L\\|_{\\mathbf{M}^{(S)}}}$. The reference norm is computed using the LGL nodes and weights for the given degree $p$. The $\\mathbf{M}$-norm is $\\|\\mathbf{w}\\|_{\\mathbf{M}} = \\sqrt{\\mathbf{w}^T \\mathbf{M} \\mathbf{w}}$. By definition, $c_{\\text{norm}}^{(\\text{LGL})} = 1$.\n\n4.  **Assemble Global Operator ($\\mathbf{A}$)**:\n    -   The global operator $\\mathbf{A}$ is an $(Nn) \\times (Nn)$ block-circulant matrix. Its definition arises from substituting the numerical flux into the FR scheme:\n      $$ \\frac{d\\mathbf{u}_e}{dt} = -\\frac{2a}{h}\\left( (\\mathbf{D} - c\\mathbf{g}'_L\\mathbf{v}_L^T)\\mathbf{u}_e + (c\\mathbf{g}'_L\\mathbf{v}_R^T)\\mathbf{u}_{e-1} \\right) $$\n    -   The diagonal blocks are $\\mathbf{A}_{ee} = -\\frac{2a}{h}(\\mathbf{D} - c\\mathbf{g}'_L\\mathbf{v}_L^T)$.\n    -   The sub-diagonal blocks (and the top-right block due to periodicity) are $\\mathbf{A}_{e,e-1} = -\\frac{2a}{h}(c\\mathbf{g}'_L\\mathbf{v}_R^T)$.\n    -   This is performed for both $c=1$ and $c=c_{\\text{norm}}^{(S)}$.\n\n5.  **Compute Stability Metric**:\n    -   Construct the global mass matrix $\\mathbf{M}_{\\text{glob}}$ as a block-diagonal matrix of the element mass matrices $\\mathbf{M}$.\n    -   Form the symmetric part of the mass-scaled operator: $\\mathbf{S}_{\\mathbf{M}} = \\frac{1}{2}(\\mathbf{M}_{\\text{glob}}\\mathbf{A} + \\mathbf{A}^T\\mathbf{M}_{\\text{glob}})$.\n    -   To find the generalized eigenvalues of $(\\mathbf{S_M}, \\mathbf{M}_{\\text{glob}})$, we solve the equivalent standard eigenvalue problem for the symmetric matrix $\\mathbf{C} = \\mathbf{M}_{\\text{glob}}^{-1/2} \\mathbf{S_M} \\mathbf{M}_{\\text{glob}}^{-1/2}$.\n    -   The largest eigenvalue of $\\mathbf{C}$ is computed. Since $\\mathbf{C}$ is symmetric, its eigenvalues are real, and efficient algorithms can be used. A non-positive value implies non-increasing energy (stability).\n\nThis entire process is repeated for each test case $(p, N)$ and each of the three nodal distributions.", "answer": "```python\nimport numpy as np\nfrom scipy.special import legendre, roots_legendre, roots_jacobi\nfrom scipy.linalg import eigh\n\ndef get_nodes_and_weights(n, node_type):\n    \"\"\"\n    Computes nodal points and quadrature weights for a given type.\n    n: number of points (p+1)\n    node_type: 'gauss', 'lobatto', or 'equidistant'\n    \"\"\"\n    if node_type == 'gauss':\n        nodes, weights = roots_legendre(n)\n        return np.array(nodes), np.array(weights)\n    elif node_type == 'lobatto':\n        p = n - 1\n        if n == 1:\n            return np.array([0.0]), np.array([2.0])\n        if n == 2:\n            return np.array([-1.0, 1.0]), np.array([1.0, 1.0])\n        \n        interior_nodes, _ = roots_jacobi(n - 2, 1, 1)\n        nodes = np.concatenate(([-1.0], np.sort(interior_nodes), [1.0]))\n        \n        P_p = legendre(p)\n        weights = 2.0 / (n * p * P_p(nodes)**2)\n        return nodes, weights\n    elif node_type == 'equidistant':\n        nodes = np.linspace(-1.0, 1.0, n)\n        # Newton-Cotes weights by solving Vandermonde system\n        V = np.vander(nodes, n, increasing=True)\n        rhs = np.zeros(n)\n        for i in range(n):\n            rhs[i] = (1.0 - (-1.0)**(i + 1)) / (i + 1)\n        weights = np.linalg.solve(V.T, rhs)\n        return nodes, weights\n    else:\n        raise ValueError(f\"Unknown node type: {node_type}\")\n\ndef lagrange_diff_matrix(nodes):\n    \"\"\"\n    Computes the differentiation matrix using the barycentric formula.\n    \"\"\"\n    n = len(nodes)\n    D = np.zeros((n, n))\n    \n    # Barycentric weights\n    w = np.ones(n)\n    for j in range(n):\n        for k in range(n):\n            if k != j:\n                w[j] *= (nodes[j] - nodes[k])\n    w = 1.0 / w\n    \n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                D[i, j] = (w[j] / w[i]) / (nodes[i] - nodes[j])\n                \n    for i in range(n):\n        D[i, i] = -np.sum(D[i, :])\n    return D\n\ndef get_boundary_vectors(nodes):\n    \"\"\"\n    Computes Lagrange basis evaluation vectors at xi = -1 and xi = 1.\n    \"\"\"\n    n = len(nodes)\n    # Check if nodes are Lobatto type (endpoints included)\n    if np.isclose(nodes[0], -1.0) and np.isclose(nodes[-1], 1.0):\n        vL = np.zeros(n)\n        vL[0] = 1.0\n        vR = np.zeros(n)\n        vR[-1] = 1.0\n        return vL, vR\n    \n    # Otherwise, compute via explicit Lagrange polynomial evaluation.\n    def lagrange_eval(x, j, eval_nodes):\n        num, den = 1.0, 1.0\n        for m, xm in enumerate(eval_nodes):\n            if m != j:\n                num *= (x - xm)\n                den *= (eval_nodes[j] - xm)\n        return num / den\n\n    vL = np.array([lagrange_eval(-1.0, j, nodes) for j in range(n)])\n    vR = np.array([lagrange_eval(1.0, j, nodes) for j in range(n)])\n    return vL, vR\n\ndef get_correction_vector(p, nodes):\n    \"\"\"\n    Computes the nodal vector for the derivative of the g_L correction function.\n    \"\"\"\n    sp = (-1.0)**p\n    Pp = legendre(p)\n    Pp_prime = Pp.deriv(1)\n    \n    g_prime_vals = sp * (-0.5 * Pp(nodes) + 0.5 * (1.0 - nodes) * Pp_prime(nodes))\n    return g_prime_vals\n\ndef compute_max_eigenvalue(A, M_glob):\n    \"\"\"\n    Computes the largest generalized eigenvalue of (S_M, M_glob).\n    \"\"\"\n    S_M = 0.5 * (M_glob @ A + A.T @ M_glob)\n    # Using scipy.linalg.eigh for generalized symmetric eigenproblem\n    # It is generally more stable than forming C explicitly.\n    # It returns eigenvalues in ascending order.\n    eigvals = eigh(S_M, M_glob, eigvals_only=True)\n    return eigvals[-1]\n\ndef solve_one_case(p, N, a, L):\n    \"\"\"\n    Solves the problem for one (p, N) test case.\n    \"\"\"\n    n = p + 1\n    h = L / N\n    \n    node_types = ['gauss', 'lobatto', 'equidistant']\n    \n    # Calculate normalization constants\n    ref_nodes, ref_weights = get_nodes_and_weights(n, 'lobatto')\n    ref_g_prime = get_correction_vector(p, ref_nodes)\n    ref_M_elem = np.diag(ref_weights)\n    norm_ref = np.sqrt(ref_g_prime.T @ ref_M_elem @ ref_g_prime)\n    \n    c_norms = {}\n    for nt in node_types:\n        nodes_s, weights_s = get_nodes_and_weights(n, nt)\n        g_prime_s = get_correction_vector(p, nodes_s)\n        M_elem_s = np.diag(weights_s)\n        norm_s = np.sqrt(g_prime_s.T @ M_elem_s @ g_prime_s)\n        c_norms[nt] = norm_ref / norm_s if norm_s > 1e-15 else 1.0\n\n    unnormalized_eigs = []\n    normalized_eigs = []\n\n    for node_type in node_types:\n        nodes, weights = get_nodes_and_weights(n, node_type)\n        D = lagrange_diff_matrix(nodes)\n        M_elem = np.diag(weights)\n        vL_T, vR_T = get_boundary_vectors(nodes)\n        g_prime_vec = get_correction_vector(p, nodes)\n        \n        # Calculate for both c=1 and c=c_norm\n        for c_val, eig_list in zip([1.0, c_norms[node_type]], [unnormalized_eigs, normalized_eigs]):\n            dof = N * n\n            \n            # semi-discrete operator blocks\n            prefactor = -2.0 * a / h\n            A_diag_block = prefactor * (D - c_val * np.outer(g_prime_vec, vL_T))\n            A_offdiag_block = prefactor * (c_val * np.outer(g_prime_vec, vR_T))\n            \n            # Assemble global operator A\n            A = np.zeros((dof, dof))\n            for e in range(N):\n                e_slice = slice(e * n, (e + 1) * n)\n                em1 = (e - 1 + N) % N\n                em1_slice = slice(em1 * n, (em1 + 1) * n)\n                \n                A[e_slice, e_slice] = A_diag_block\n                A[e_slice, em1_slice] = A_offdiag_block\n                \n            M_glob = np.kron(np.eye(N), M_elem)\n            \n            max_eig = compute_max_eigenvalue(A, M_glob)\n            eig_list.append(max_eig)\n\n    return unnormalized_eigs + normalized_eigs\n\ndef solve():\n    \"\"\"\n    Main driver function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        (2, 10),  # p, N\n        (3, 8),\n        (5, 6),\n    ]\n    a = 1.0\n    L = 1.0\n    \n    final_results = []\n    for p, N in test_cases:\n        case_results = solve_one_case(p, N, a, L)\n        final_results.append(case_results)\n        \n    # The output format must be a Python list of lists.\n    # str(list) provides the canonical representation.\n    # The example in the prompt `[[x11,x12,...]]` has no spaces.\n    # We will remove them to match the example's formatting precisely.\n    print(str(final_results).replace(\" \", \"\"))\n\nsolve()\n\n```", "id": "3386483"}, {"introduction": "While linear problems provide a clean introduction, most real-world applications involve nonlinearities, which present a unique challenge for high-order methods: aliasing. This exercise shifts focus from stability to accuracy, asking you to analyze how the polynomial degree of a nonlinear flux can corrupt the solution if the integrals in the weak form are not computed with sufficient precision. By deriving the necessary quadrature rule, you will uncover the principle of 'over-integration' [@problem_id:3386485], a vital technique for preserving the design order of accuracy in nonlinear simulations.", "problem": "Consider the one-dimensional conservation law $u_{t} + \\partial_{x} f(u) = 0$ on a periodic domain, discretized by the Flux Reconstruction (FR) method, also known as the Correction Procedure via Reconstruction (CPR), on a uniform mesh of affine-mapped elements with local coordinate $\\xi \\in [-1,1]$. On each element, the approximate solution $u^{h}(\\xi)$ is represented by a polynomial of degree $p$ in $\\xi$, constructed from nodal values at the Gauss–Lobatto–Legendre (GLL) points. The weak form of the volume term is taken in the standard FR/DG-integrated-by-parts form and evaluated with a volume quadrature.\n\nAssume a nonlinear flux $f(u) = u^{k}$ with an integer $k \\geq 2$. The design-order of accuracy for smooth solutions, in the absence of quadrature aliasing and assuming sufficiently regular correction functions, is $p+1$. Under-integration (aliasing) in the volume term arises when the chosen quadrature does not integrate the polynomial integrand of the volume term exactly, thereby degrading the formal order of accuracy below $p+1$.\n\nUsing only well-tested facts about polynomial degrees under composition and multiplication, and the classical exactness properties of Gauss–Lobatto–Legendre quadrature with $Q$ points (exact for polynomials up to degree $2Q-3$) and Gauss–Legendre quadrature with $M$ points (exact up to degree $2M-1$), carry out the following:\n\n1. Identify the maximum polynomial degree of the volume integrand that must be exactly integrated on each element for the weak form with test functions of degree at most $p$.\n2. Explain how, for $Q=p+1$, this leads to aliasing for $k \\geq 2$ and thus degrades the formal order of accuracy from the $p+1$ design-order.\n3. Propose a sufficient over-integration condition by choosing a Gauss–Legendre volume quadrature with $M$ points so that the volume term is integrated exactly and the design-order $p+1$ is recovered.\n\nYour final answer must be a single closed-form analytic expression giving the minimal $M$ in terms of $p$ and $k$ that guarantees exact integration of the volume term. No numerical approximation or rounding is required.", "solution": "The problem asks for the minimum number of Gauss-Legendre quadrature points, $M$, required to exactly integrate the volume term in a Flux Reconstruction scheme, thereby avoiding aliasing and preserving the method's formal order of accuracy. The solution approximation is a polynomial of degree $p$, and the flux function is $f(u) = u^k$.\n\nThe weak form of the governing equation, after integration by parts on a reference element, contains a volume integral of the form:\n$$\n\\int_{-1}^{1} f(u^{h}(\\xi)) \\frac{d v^{h}}{d \\xi} \\, d\\xi\n$$\nwhere $u^h$ is the degree-$p$ polynomial solution and $v^h$ is a test function from the same polynomial space ($\\deg(v^h) \\leq p$). To avoid quadrature error, the numerical quadrature rule must be exact for the integrand $I(\\xi) = f(u^{h}(\\xi)) \\frac{d v^{h}}{d \\xi}$.\n\n**1. Maximum Polynomial Degree of the Volume Integrand**\n\nFirst, we determine the maximum polynomial degree of the integrand $I(\\xi)$.\n- The solution approximation $u^{h}(\\xi)$ is a polynomial of degree at most $p$, so $\\deg(u^{h}) \\leq p$.\n- The flux function is $f(u) = u^{k}$. When applied to the polynomial solution, the resulting flux is $f(u^{h}(\\xi)) = (u^{h}(\\xi))^{k}$. Its maximum degree is $\\deg(f(u^{h})) = k \\cdot \\deg(u^{h}) = kp$.\n- The test function $v^{h}(\\xi)$ is a polynomial of degree at most $p$, so its derivative, $\\frac{d v^{h}}{d \\xi}$, is a polynomial of degree at most $p-1$.\n- The integrand $I(\\xi)$ is the product of these two polynomials. The degree of a product is the sum of the degrees.\n- Therefore, the maximum degree of the integrand is:\n$$\n\\deg(I) = \\deg(f(u^{h})) + \\deg\\left(\\frac{d v^{h}}{d \\xi}\\right) = kp + (p-1) = (k+1)p - 1\n$$\nFor the weak form to be satisfied without introducing quadrature error, the quadrature rule must be exact for polynomials up to degree $(k+1)p - 1$.\n\n**2. Aliasing with Standard GLL Quadrature**\n\nA common practice is to use the $Q=p+1$ Gauss–Lobatto–Legendre (GLL) points for the volume quadrature. A GLL rule with $Q$ points is exact for polynomials of degree up to $2Q-3$.\n- With $Q = p+1$, the standard GLL quadrature is exact for polynomials up to degree:\n$$\n2(p+1) - 3 = 2p - 1\n$$\n- Aliasing occurs if the degree of the integrand is greater than the degree of exactness of the quadrature rule:\n$$\n\\deg(I) > 2p - 1\n$$\n- Substituting the expression for $\\deg(I)$:\n$$\n(k+1)p - 1 > 2p - 1 \\implies (k+1)p > 2p\n$$\n- Assuming a non-trivial polynomial approximation space ($p \\geq 1$), this simplifies to:\n$$\nk+1 > 2 \\implies k > 1\n$$\n- Since the problem specifies an integer $k \\geq 2$, this condition is always met. Thus, for any such nonlinear flux, the standard GLL quadrature with $p+1$ points is insufficient to integrate the volume term exactly, leading to aliasing errors that degrade the scheme's accuracy.\n\n**3. Sufficient Over-integration Condition**\n\nTo recover the design order of accuracy, we must use a quadrature rule that is exact for polynomials of degree up to $(k+1)p - 1$. The problem proposes using a Gauss–Legendre (GL) quadrature with $M$ points. A GL rule with $M$ points is exact for polynomials up to degree $2M-1$.\n- The condition for exact integration is:\n$$\n\\text{Degree of Exactness} \\geq \\deg(I)\n$$\n- Substituting the known values:\n$$\n2M - 1 \\geq (k+1)p - 1\n$$\n- Simplifying the inequality for $M$:\n$$\n2M \\geq (k+1)p \\implies M \\geq \\frac{(k+1)p}{2}\n$$\n- Since $M$ must be an integer (the number of points), we must take the smallest integer that satisfies this inequality. This is the ceiling function.\n- The minimal number of Gauss-Legendre points required is:\n$$\nM_{min} = \\left\\lceil \\frac{(k+1)p}{2} \\right\\rceil\n$$\nThis choice of $M$ ensures the volume integral is computed exactly, which is a necessary condition for the scheme to achieve its formal design order of accuracy of $p+1$ for smooth solutions.", "answer": "$$\\boxed{\\left\\lceil \\frac{(k+1)p}{2} \\right\\rceil}$$", "id": "3386485"}, {"introduction": "Beyond ensuring basic stability and accuracy, the FR framework offers the flexibility to tune its components for superior performance. This practice explores the advanced topic of superconvergence, where specific choices of solution points and correction functions can yield an order of accuracy higher than the polynomial degree $p$ would suggest. By identifying these specific conditions [@problem_id:3386507], you will appreciate FR not as a single method, but as a unifying family of schemes that includes variants with exceptional properties.", "problem": "Consider the one-dimensional (1D) linear advection equation $\\partial_t u + a \\,\\partial_x u = 0$ on a periodic domain partitioned into a uniform mesh with cell size $h$. In each cell, a Flux Reconstruction (FR) scheme, also known as Correction Procedure via Reconstruction (CPR), represents the solution by a polynomial of degree at most $p$ at $p+1$ solution points on the reference element $\\xi \\in [-1,1]$, mapped affinely from the physical cell. The reconstructed flux adds correction polynomials $g_L(\\xi)$ and $g_R(\\xi)$ of degree $p+1$ that enforce boundary conditions through a numerical flux; assume an upwind two-point numerical flux and an energy-stable choice of correction polynomials so that the semidiscrete scheme is conservative. The cell average in each element is the mean of the polynomial over the cell, and its semidiscrete evolution depends only on the reconstructed numerical fluxes at the left and right interfaces.\n\nStarting from these principles:\n- Conservation implies that the semidiscrete evolution of the cell average depends only on the difference of interface fluxes divided by the cell size $h$.\n- For smooth solutions, design-order accuracy of the FR approximation in the element interior is $\\mathcal{O}(h^{p+1})$.\n- Superconvergence of the interface fluxes to $\\mathcal{O}(h^{p+2})$ is known to induce the same order for the evolution of cell averages, provided time integration does not reduce the spatial order.\n\nWhich of the following statements correctly specifies sufficient conditions on the choice of solution points and correction polynomials to ensure that, for smooth solutions and upwind numerical flux, both the interface fluxes and the cell averages achieve $\\mathcal{O}(h^{p+2})$ accuracy in the spatial discretization?\n\nA. Use $p+1$ Gauss–Legendre solution points (nodes strictly inside $[-1,1]$) together with degree-$p+1$ left/right correction polynomials $g_L, g_R$ that interpolate boundary values $g_L(-1)=1$, $g_L(1)=0$, $g_R(-1)=0$, $g_R(1)=1$, and whose derivatives are orthogonal (in the Gauss–Legendre discrete inner product, exact up to degree $2p+1$) to all Legendre modes of degree $\\le p$. With an upwind numerical flux, the reconstructed interface states are $\\mathcal{O}(h^{p+2})$, and by conservation the cell averages are also $\\mathcal{O}(h^{p+2})$.\n\nB. Use $p+1$ Gauss–Lobatto solution points (including $\\xi=\\pm 1$) and symmetric degree-$p+1$ correction polynomials satisfying $g_L(\\pm 1)=g_R(\\pm 1)=1/2$, since including the interfaces as solution points guarantees $\\mathcal{O}(h^{p+2})$ accuracy of both interface fluxes and cell averages.\n\nC. Use any symmetric set of $p+1$ solution points with the central numerical flux and any energy-stable correction polynomials; for smooth periodic solutions, symmetry and stability alone imply $\\mathcal{O}(h^{p+2})$ superconvergence of interface fluxes and cell averages.\n\nD. Use $p+1$ Gauss–Legendre solution points and any energy-stable correction polynomials satisfying the boundary interpolation conditions $g_L(-1)=1$, $g_L(1)=0$, $g_R(-1)=0$, $g_R(1)=1$, without requiring any discrete orthogonality of $g_L'$ and $g_R'$; energy stability alone ensures $\\mathcal{O}(h^{p+2})$ accuracy of both interface fluxes and cell averages.", "solution": "This problem asks for the sufficient conditions within the Flux Reconstruction (FR) framework to achieve an $\\mathcal{O}(h^{p+2})$ superconvergence rate for interface fluxes and cell averages for the linear advection equation. The standard order of accuracy for a degree-$p$ polynomial approximation is $\\mathcal{O}(h^{p+1})$.\n\n1.  **FR Framework and Accuracy**: The FR scheme reconstructs a continuous flux from a discontinuous degree-$p$ polynomial solution. By conservation, the error in the cell average evolution is driven by the error in the interface fluxes. Thus, to achieve $\\mathcal{O}(h^{p+2})$ accuracy for cell averages, the interface fluxes must be superconvergent with $\\mathcal{O}(h^{p+2})$ accuracy.\n\n2.  **Mechanism of Superconvergence**: Superconvergence in FR schemes arises when the scheme's components (solution points, correction functions) are specifically chosen to make it equivalent to a different numerical method known to possess superconvergent properties. For $\\mathcal{O}(h^{p+2})$ flux accuracy, the target is often a specific variant of the Discontinuous Galerkin (DG) method. Certain DG methods, particularly those based on a Legendre polynomial basis and tested against the same basis, exhibit superconvergence of the solution at the element outflow boundary.\n\n3.  **Conditions for $\\mathcal{O}(h^{p+2})$ Superconvergence**: To replicate this behavior in the FR framework, two specific choices are required:\n    *   **Solution Points**: The $p+1$ solution points within the element must be the **Gauss-Legendre** nodes. These nodes are the roots of the degree $p+1$ Legendre polynomial and are optimal for Gaussian quadrature, which is a key ingredient in the error analysis of DG methods.\n    *   **Correction Functions**: The correction functions must be chosen to establish the equivalence with the superconvergent DG scheme. This is achieved when the derivatives of the correction functions, $g_L'$ and $g_R'$, are orthogonal to the polynomial space used for the solution approximation (i.e., all polynomials of degree up to $p$). This condition ensures that the correction term does not pollute the moments of the solution residual, preserving the high-order accuracy properties inherited from the underlying DG formulation.\n\n4.  **Option-by-Option Analysis**:\n    *   **A**: This option correctly identifies the two crucial conditions: (1) using $p+1$ Gauss-Legendre solution points, and (2) using correction polynomials whose derivatives are orthogonal to all Legendre modes of degree $\\le p$. This combination is known to make the FR scheme equivalent to a DG method that provides $\\mathcal{O}(h^{p+2})$ accuracy for the solution at the outflow boundary, and thus for the upwind flux. The conclusion that cell averages also become $\\mathcal{O}(h^{p+2})$ accurate is a direct consequence of conservation. **This statement is correct.**\n    *   **B**: This option suggests using Gauss-Lobatto points. These points are typically associated with standard $\\mathcal{O}(h^{p+1})$ accuracy, not $\\mathcal{O}(h^{p+2})$ flux superconvergence. Including boundary points does not automatically guarantee superconvergence. The proposed correction functions are also incorrect for this purpose. This statement is incorrect.\n    *   **C**: This option incorrectly suggests that symmetry and a central flux are sufficient. A central flux is non-dissipative and can lead to instability if not paired with specific SBP operators. More importantly, symmetry alone does not guarantee superconvergence of this order; the specific choice of points and the properties of the correction functions are critical. This statement is incorrect.\n    *   **D**: This option correctly identifies Gauss-Legendre points but wrongly claims that *any* energy-stable correction function is sufficient. Energy stability is a property related to the boundedness of a solution norm, not its accuracy order. The specific orthogonality property of the correction functions, as stated in option A, is a necessary condition for achieving superconvergence and is not guaranteed by energy stability alone. This statement is incorrect.\n\nTherefore, option A provides the correct and sufficient conditions for the desired superconvergence property.", "answer": "$$\\boxed{A}$$", "id": "3386507"}]}