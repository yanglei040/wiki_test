{"hands_on_practices": [{"introduction": "The flexibility of spectral element methods partly comes from their ability to handle $p$-nonconforming meshes, where adjacent elements have different polynomial degrees. The first step in connecting such elements is to understand the mismatch in their trace spaces. This exercise [@problem_id:3403322] asks you to perform a fundamental calculation: counting the number of algebraic constraints required on the higher-degree element's boundary, providing a clear link between the abstract dimension of polynomial spaces and the concrete requirements of a stable numerical scheme.", "problem": "Consider a nonconforming interface between two quadrilateral spectral elements in two spatial dimensions. The geometry mapping along the shared edge is affine so that polynomial traces map isomorphically. The left (fine) element uses a hierarchical modal spectral basis of polynomial degree $p_{f}$ in each coordinate, and the right (coarse) element uses a hierarchical modal spectral basis of polynomial degree $p_{c}$ in each coordinate, with $p_{f} > p_{c}$. Along their common straight edge, the trace spaces are one-dimensional polynomial spaces $P_{p_{f}}$ and $P_{p_{c}}$ on the reference interval $[-1,1]$, respectively. Assume the hierarchical bases on the edge are constructed so that $P_{p_{c}} \\subset P_{p_{f}}$ as subspaces, and that the edge degrees of freedom are exactly the coefficients of these hierarchical edge bases.\n\nContinuity across the nonconforming interface is imposed by a classical mortar methodology in which the coarse side is the master and the fine side is the slave: the trace on the fine side is weakly constrained so that its projection onto $P_{p_{c}}$ matches the coarse trace, while any fine-side trace component orthogonal to $P_{p_{c}}$ must be eliminated by independent algebraic constraints. Endpoint continuity at the two shared vertices is enforced strongly through mesh connectivity and is not to be counted separately.\n\nUsing only the core definitions of trace spaces, polynomial degree, and hierarchical subspace nesting, determine the number of independent algebraic constraints that must be added on the fine-side edge degrees of freedom solely due to the $p$-jump when $p_{f} = 6$ and $p_{c} = 3$. Your final answer must be a single integer. No rounding is required.", "solution": "The user wants me to solve a problem from the field of spectral and discontinuous Galerkin methods.\n\n### Step 1: Extract Givens\n- **Domain:** A nonconforming interface between two quadrilateral spectral elements in two spatial dimensions.\n- **Interface Edge:** The common edge is straight, and the geometry mapping is affine.\n- **Element Properties:**\n    - Left element (fine): Hierarchical modal spectral basis of polynomial degree $p_f$.\n    - Right element (coarse): Hierarchical modal spectral basis of polynomial degree $p_c$.\n- **Polynomial Degree Condition:** $p_f > p_c$.\n- **Trace Spaces:** Along the common edge (a reference interval $[-1,1]$), the trace spaces are:\n    - Fine side: $P_{p_f}$, the space of one-dimensional polynomials of degree at most $p_f$.\n    - Coarse side: $P_{p_c}$, the space of one-dimensional polynomials of degree at most $p_c$.\n- **Basis Property:** The hierarchical bases ensure that $P_{p_c}$ is a subspace of $P_{p_f}$, i.e., $P_{p_c} \\subset P_{p_f}$.\n- **Degrees of Freedom (DOFs):** The edge DOFs are the coefficients of the hierarchical edge bases.\n- **Continuity Imposition (Mortar Method):**\n    - The coarse side is the master; the fine side is the slave.\n    - **Coupling Constraint:** The trace on the fine side, $u_f \\in P_{p_f}$, is weakly constrained such that its projection onto $P_{p_c}$ matches the coarse trace, $u_c \\in P_{p_c}$.\n    - **Additional Constraint:** Any component of the fine-side trace that is orthogonal to $P_{p_c}$ must be eliminated by independent algebraic constraints.\n- **Vertex Treatment:** Endpoint continuity at the two shared vertices is enforced strongly and is not to be counted in the final answer.\n- **Specific Values:** $p_f = 6$ and $p_c = 3$.\n- **Question:** Determine the number of independent algebraic constraints that must be added on the fine-side edge DOFs solely due to the $p$-jump.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientific Grounding:** The problem is firmly rooted in the theory of numerical methods for partial differential equations, specifically spectral element and discontinuous Galerkin methods. The concepts of trace spaces, hierarchical bases, p-nonconformity, and mortar methods are standard and well-defined in this field. The entire setup is scientifically and mathematically sound.\n- **Well-Posedness:** The problem is well-posed. It provides a clear and complete description of the mathematical spaces, the degrees of freedom, and the constraint mechanism. The question asks for a specific integer quantity that can be uniquely determined from the provided definitions and data.\n- **Objectivity:** The problem is stated in precise, objective, and technical language, free from ambiguity or subjective claims.\n\n### Step 3: Verdict and Action\nThe problem is valid. It is a standard exercise in understanding the degrees of freedom and constraints at a nonconforming interface in a $p$-type spectral element discretization. I will proceed with the solution.\n\nThe problem asks for the number of independent algebraic constraints imposed on the fine-side edge degrees of freedom due to the jump in polynomial degree, under a specific mortar-type coupling strategy.\n\nThe degrees of freedom (DOFs) on an element edge are given by the dimension of the polynomial trace space on that edge. The space of polynomials of degree at most $p$ in one dimension, denoted $P_p$, has a dimension of $p+1$.\n\nFor the fine side of the interface, the trace space is $P_{p_f}$. The number of DOFs on this side, $N_f$, is the dimension of this space:\n$$N_f = \\dim(P_{p_f}) = p_f + 1$$\n\nFor the coarse side of the interface, the trace space is $P_{p_c}$. The number of DOFs on this side, $N_c$, is the dimension of this space:\n$$N_c = \\dim(P_{p_c}) = p_c + 1$$\n\nThe problem states that the bases are hierarchical, which ensures that the polynomial space on the coarse side is a proper subspace of the polynomial space on the fine side, since $p_f > p_c$. This is expressed as $P_{p_c} \\subset P_{p_f}$.\n\nThe enforcement of continuity is described in two parts:\n1.  The trace on the fine side ($u_f \\in P_{p_f}$) is constrained such that its projection onto the coarse space $P_{p_c}$ matches the trace on the coarse side ($u_c \\in P_{p_c}$). This is the coupling portion of the mortar method. It effectively links a number of DOFs on the fine side equal to the dimension of $P_{p_c}$ to the corresponding DOFs on the coarse side. The number of such coupling conditions is $\\dim(P_{p_c}) = p_c + 1$.\n\n2.  Any component of the fine-side trace that is orthogonal to $P_{p_c}$ must be eliminated. This refers to the portion of the solution $u_f$ that lies in the complement of $P_{p_c}$ within $P_{p_f}$. Let this complement space be denoted by $P_{p_f} \\setminus P_{p_c}$. The dimension of this complement space is the difference in the dimensions of the two spaces:\n$$\\dim(P_{p_f} \\setminus P_{p_c}) = \\dim(P_{p_f}) - \\dim(P_{p_c}) = N_f - N_c$$\nSubstituting the expressions for the dimensions:\n$$\\dim(P_{p_f} \\setminus P_{p_c}) = (p_f + 1) - (p_c + 1) = p_f - p_c$$\nTo \"eliminate\" the component of the solution in this space means to constrain it to be zero. This requires imposing a number of independent algebraic constraints equal to the dimension of this space. These are the constraints applied solely to the fine-side DOFs to handle the higher-order modes that have no counterpart on the coarse side.\n\nThe problem explicitly asks for the number of these \"elimination\" constraints, which arise \"solely due to the $p$-jump\". The note about strong enforcement of vertex continuity serves to confirm that we should focus on the mismatch in the polynomial function spaces themselves, not the shared endpoints of the edge. Our calculation based on the dimensions of the full polynomial spaces, $\\dim(P_{p_f}) - \\dim(P_{p_c})$, correctly isolates the effect of the polynomial degree mismatch.\n\nTherefore, the number of required independent algebraic constraints is $p_f - p_c$.\n\nGiven the specific values $p_f = 6$ and $p_c = 3$, we can calculate the number of constraints:\n$$\\text{Number of constraints} = p_f - p_c = 6 - 3 = 3$$\nThese $3$ constraints force the coefficients of the hierarchical basis functions of degrees $4$, $5$, and $6$ on the fine-side edge to be zero.", "answer": "$$\\boxed{3}$$", "id": "3403322"}, {"introduction": "After understanding *how many* constraints are needed, the next question is *how* the mortar coupling works. This practice goes beyond simple counting and delves into the analytical heart of the mortar method by exploring it as an $L^2$ projection. By explicitly proving the projection's exactness for polynomials within the target space and then calculating the projection error for a higher-order function, you will gain a deep understanding of how the mortar operator transfers information and where approximation errors arise. This is a classic exercise [@problem_id:3403327] that illuminates the approximation theory underpinning the method.", "problem": "Consider a one-dimensional nonconforming interface (a mortar) between a coarse parent edge and two fine child edges. Let the parent interface be $\\Gamma=[-1,1]$, and the two children be $\\Gamma_{L}=[-1,0]$ and $\\Gamma_{R}=[0,1]$. Let the parent trace space be the polynomial space $\\mathbb{P}_{3}(\\Gamma)$ of all real polynomials of degree at most $3$ on $\\Gamma$, and let each child trace be the restriction to $\\Gamma_{L}$ or $\\Gamma_{R}$ of a polynomial in $\\mathbb{P}_{3}([-1,1])$. Define the canonical mortar projection $\\Pi_{M}:\\left.\\mathbb{P}_{3}([-1,1])\\right|_{\\Gamma_{L}\\cup\\Gamma_{R}}\\to \\mathbb{P}_{3}(\\Gamma)$ by the variational condition\n$$\n\\int_{-1}^{1} (\\Pi_{M} u)(s)\\, v(s)\\, \\mathrm{d}s \\;=\\; \\int_{-1}^{0} u(s)\\, v(s)\\, \\mathrm{d}s \\;+\\; \\int_{0}^{1} u(s)\\, v(s)\\, \\mathrm{d}s\\quad \\text{for all } v\\in \\mathbb{P}_{3}(\\Gamma).\n$$\nAssume that all integrals are evaluated exactly.\n\nStarting from the definition of the $L^{2}$ inner product and the fundamental properties of orthogonal polynomials on $[-1,1]$, do the following:\n\n- Show, by explicit reasoning from the variational definition above and polynomial orthogonality, that if $u\\in \\mathbb{P}_{3}([-1,1])$ then $(\\Pi_{M}u)(s)=u(s)$ for all $s\\in [-1,1]$; that is, polynomials up to degree $3$ transmit exactly through the mortar.\n\n- Next, take $u(s)=s^{4}$ and compute the mortar projection error $e(s):=u(s)-(\\Pi_{M}u)(s)$ on $\\Gamma$. Express $e(s)$ as a single closed-form analytic expression in $s$.\n\nYour final answer should be the simplified expression for $e(s)$ as a function of $s$. No rounding is required.", "solution": "The problem will first be validated against the specified criteria before a solution is attempted.\n\n### Step 1: Extract Givens\nThe data, variables, and conditions explicitly given in the problem statement are:\n- Parent interface: $\\Gamma = [-1, 1]$.\n- Child interfaces: $\\Gamma_{L} = [-1, 0]$ and $\\Gamma_{R} = [0, 1]$.\n- Parent trace space: $\\mathbb{P}_{3}(\\Gamma)$, the space of real polynomials of degree at most $3$ on $\\Gamma$.\n- Child trace: Restriction of a polynomial in $\\mathbb{P}_{3}([-1,1])$ to $\\Gamma_{L}$ or $\\Gamma_{R}$.\n- Mortar projection operator: $\\Pi_{M}:\\left.\\mathbb{P}_{3}([-1,1])\\right|_{\\Gamma_{L}\\cup\\Gamma_{R}}\\to \\mathbb{P}_{3}(\\Gamma)$.\n- Variational definition of the mortar projection:\n$$\n\\int_{-1}^{1} (\\Pi_{M} u)(s)\\, v(s)\\, \\mathrm{d}s \\;=\\; \\int_{-1}^{0} u(s)\\, v(s)\\, \\mathrm{d}s \\;+\\; \\int_{0}^{1} u(s)\\, v(s)\\, \\mathrm{d}s\\quad \\text{for all } v\\in \\mathbb{P}_{3}(\\Gamma).\n$$\n- Assumption: All integrals are evaluated exactly.\n- Task 1: Show that if $u\\in \\mathbb{P}_{3}([-1,1])$, then $(\\Pi_{M}u)(s)=u(s)$ for all $s\\in [-1,1]$.\n- Task 2: For $u(s)=s^{4}$, compute the mortar projection error $e(s):=u(s)-(\\Pi_{M}u)(s)$.\n- Required final answer: A simplified, closed-form analytic expression for $e(s)$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is subjected to a critical validation check.\n- **Scientifically Grounded:** The problem is firmly rooted in the mathematical field of numerical analysis, specifically the theory of spectral and discontinuous Galerkin methods. Mortar methods, polynomial spaces ($\\mathbb{P}_k$), and $L^2$ projections are standard, well-defined concepts. The setup is a canonical one-dimensional example used to analyze the properties of such methods.\n- **Well-Posed:** The problem is well-posed. The variational definition provided uniquely defines the operator $\\Pi_M$ as an $L^2$-projection onto the finite-dimensional space $\\mathbb{P}_3(\\Gamma)$, which guarantees the existence and uniqueness of the projected function $(\\Pi_M u)$. The tasks are specific and lead to a unique, meaningful solution.\n- **Objective:** The problem is formulated in precise and objective mathematical language, free of any subjectivity or ambiguity.\n- **Completeness and Consistency:** The problem is self-contained. All necessary definitions for the spaces, the domain, and the projection operator are provided. There are no missing data or contradictory constraints. The additivity property of definite integrals simplifies the right-hand side of the variational definition, but this is a feature of the problem, not a flaw.\n\nThe problem does not violate any of the invalidity criteria. It is a standard, formal problem in applied mathematics.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. A full solution will be provided.\n\n### Solution\nThe solution is presented in two parts, corresponding to the two tasks specified in the problem statement.\n\n**Part 1: Exactness of Mortar Projection for $u \\in \\mathbb{P}_{3}(\\Gamma)$**\n\nThe variational definition of the mortar projection $\\Pi_{M}$ is given by:\n$$\n\\int_{-1}^{1} (\\Pi_{M} u)(s)\\, v(s)\\, \\mathrm{d}s \\;=\\; \\int_{-1}^{0} u(s)\\, v(s)\\, \\mathrm{d}s \\;+\\; \\int_{0}^{1} u(s)\\, v(s)\\, \\mathrm{d}s\n$$\nfor all test functions $v \\in \\mathbb{P}_{3}(\\Gamma)$.\n\nBy the property of additivity of definite integrals, the right-hand side can be combined into a single integral over the parent domain $\\Gamma = [-1, 1]$:\n$$\n\\int_{-1}^{0} u(s)\\, v(s)\\, \\mathrm{d}s \\;+\\; \\int_{0}^{1} u(s)\\, v(s)\\, \\mathrm{d}s = \\int_{-1}^{1} u(s)\\, v(s)\\, \\mathrm{d}s\n$$\nThus, the variational definition simplifies to:\n$$\n\\int_{-1}^{1} (\\Pi_{M} u)(s)\\, v(s)\\, \\mathrm{d}s = \\int_{-1}^{1} u(s)\\, v(s)\\, \\mathrm{d}s \\quad \\text{for all } v\\in \\mathbb{P}_{3}(\\Gamma).\n$$\nThis can be rewritten by moving all terms to one side:\n$$\n\\int_{-1}^{1} \\left( u(s) - (\\Pi_{M} u)(s) \\right) v(s)\\, \\mathrm{d}s = 0 \\quad \\text{for all } v\\in \\mathbb{P}_{3}(\\Gamma).\n$$\nThis equation states that the function $u(s) - (\\Pi_{M} u)(s)$ is $L^2$-orthogonal to every function in the space $\\mathbb{P}_{3}(\\Gamma)$. Note that $\\Pi_M u$ is itself an element of $\\mathbb{P}_3(\\Gamma)$ by definition of the operator's codomain.\n\nNow, consider the case where the input function $u$ is itself a polynomial in $\\mathbb{P}_{3}(\\Gamma)$. In this case, the difference, let's call it $w(s) = u(s) - (\\Pi_{M} u)(s)$, is also a polynomial of degree at most $3$, i.e., $w \\in \\mathbb{P}_{3}(\\Gamma)$.\n\nThe orthogonality condition states that $\\int_{-1}^{1} w(s) v(s) \\mathrm{d}s = 0$ for all $v \\in \\mathbb{P}_{3}(\\Gamma)$. Since $w(s)$ itself is an element of $\\mathbb{P}_{3}(\\Gamma)$, we are free to choose $v(s) = w(s)$. Substituting this choice gives:\n$$\n\\int_{-1}^{1} (w(s))^2\\, \\mathrm{d}s = 0.\n$$\nThe integrand $(w(s))^2$ is a non-negative, continuous function on the interval $[-1, 1]$ (since $w(s)$ is a polynomial). The integral of such a function can be zero only if the function itself is identically zero everywhere on the interval of integration.\nTherefore, we must have $(w(s))^2 = 0$ for all $s \\in [-1, 1]$, which implies $w(s) = 0$ for all $s \\in [-1, 1]$.\n\nRecalling the definition of $w(s)$, this means:\n$$\nu(s) - (\\Pi_{M} u)(s) = 0 \\quad \\implies \\quad (\\Pi_{M} u)(s) = u(s) \\quad \\text{for all } s \\in [-1, 1].\n$$\nThis demonstrates that for any polynomial $u$ up to degree $3$, the mortar projection is the identity operator, meaning such polynomials are transmitted exactly. This is a fundamental property of $L^2$-projections: if a function is already in the target space, its projection is the function itself.\n\n**Part 2: Computation of the Projection Error for $u(s) = s^4$**\n\nWe are asked to compute the projection error $e(s) = u(s) - (\\Pi_{M}u)(s)$ for $u(s)=s^4$.\nFrom Part 1, we know that $(\\Pi_M u)(s)$ is the $L^2$-projection of $u(s)$ onto the space $\\mathbb{P}_3(\\Gamma)$. Let $p(s) = (\\Pi_M u)(s) \\in \\mathbb{P}_3(\\Gamma)$. The error $e(s) = u(s) - p(s) = s^4 - p(s)$ must be $L^2$-orthogonal to the entire space $\\mathbb{P}_3(\\Gamma)$.\n\nTo find this projection and error, we utilize the basis of Legendre polynomials, $\\{L_k(s)\\}_{k=0}^\\infty$, which are orthogonal on the interval $[-1, 1]$ with respect to the $L^2$ inner product: $\\int_{-1}^1 L_j(s) L_k(s) \\mathrm{d}s = \\frac{2}{2k+1}\\delta_{jk}$, where $\\delta_{jk}$ is the Kronecker delta.\n\nThe projection $p(s)$ of a function $u(s)$ onto $\\mathbb{P}_N(\\Gamma)$ is the truncation of its Legendre series expansion at degree $N$. Here, $N=3$. We expand $u(s)=s^4$ in the Legendre basis:\n$$\nu(s) = \\sum_{k=0}^{4} c_k L_k(s), \\quad \\text{where} \\quad c_k = \\frac{\\langle u, L_k \\rangle}{\\langle L_k, L_k \\rangle} = \\frac{2k+1}{2} \\int_{-1}^1 u(s) L_k(s) \\mathrm{d}s.\n$$\nThe projection onto $\\mathbb{P}_3(\\Gamma)$ is then $p(s) = \\sum_{k=0}^{3} c_k L_k(s)$, and the error is $e(s) = u(s) - p(s) = c_4 L_4(s)$.\n\nThe first few Legendre polynomials are:\n$L_0(s) = 1$\n$L_1(s) = s$\n$L_2(s) = \\frac{1}{2}(3s^2-1)$\n$L_3(s) = \\frac{1}{2}(5s^3-3s)$\n$L_4(s) = \\frac{1}{8}(35s^4 - 30s^2 + 3)$\n\nWe can find the expansion of $s^4$ by algebraic manipulation. From the definition of $L_4(s)$:\n$8 L_4(s) = 35s^4 - 30s^2 + 3$\n$35s^4 = 8L_4(s) + 30s^2 - 3$\n$s^4 = \\frac{8}{35}L_4(s) + \\frac{30}{35}s^2 - \\frac{3}{35} = \\frac{8}{35}L_4(s) + \\frac{6}{7}s^2 - \\frac{3}{35}$\n\nNext, we express $s^2$ using $L_2(s)$ and $L_0(s)$:\n$L_2(s) = \\frac{3}{2}s^2 - \\frac{1}{2} \\implies 3s^2 = 2L_2(s) + 1 \\implies s^2 = \\frac{2}{3}L_2(s) + \\frac{1}{3}L_0(s)$.\n\nSubstituting this into the expression for $s^4$:\n$s^4 = \\frac{8}{35}L_4(s) + \\frac{6}{7}\\left(\\frac{2}{3}L_2(s) + \\frac{1}{3}L_0(s)\\right) - \\frac{3}{35}L_0(s)$\n$s^4 = \\frac{8}{35}L_4(s) + \\frac{4}{7}L_2(s) + \\frac{2}{7}L_0(s) - \\frac{3}{35}L_0(s)$\n$s^4 = \\frac{8}{35}L_4(s) + \\frac{4}{7}L_2(s) + \\left(\\frac{10}{35} - \\frac{3}{35}\\right)L_0(s)$\n$s^4 = \\frac{8}{35}L_4(s) + \\frac{4}{7}L_2(s) + \\frac{1}{5}L_0(s)$\n\nThe function $u(s) = s^4$ is an even function, so its expansion contains only even-indexed Legendre polynomials, which is consistent with our result. The projection onto $\\mathbb{P}_3(\\Gamma)$ is the sum of terms with degree less than or equal to $3$:\n$$\np(s) = (\\Pi_M u)(s) = \\frac{1}{5}L_0(s) + \\frac{4}{7}L_2(s)\n$$\nThe projection error $e(s)$ is the remaining part of the expansion:\n$$\ne(s) = u(s) - p(s) = \\frac{8}{35}L_4(s)\n$$\nTo get the final expression for $e(s)$ in terms of $s$, we substitute the definition of $L_4(s)$:\n$$\ne(s) = \\frac{8}{35} \\left( \\frac{1}{8}(35s^4 - 30s^2 + 3) \\right)\n$$\n$$\ne(s) = \\frac{1}{35} (35s^4 - 30s^2 + 3)\n$$\n$$\ne(s) = s^4 - \\frac{30}{35}s^2 + \\frac{3}{35}\n$$\nSimplifying the fraction gives the final analytical expression for the error:\n$$\ne(s) = s^4 - \\frac{6}{7}s^2 + \\frac{3}{35}\n$$\nThis is the required closed-form expression for the mortar projection error.", "answer": "$$\\boxed{s^4 - \\frac{6}{7}s^2 + \\frac{3}{35}}$$", "id": "3403327"}, {"introduction": "This capstone exercise [@problem_id:3403378] bridges the gap from analytical theory to computational practice, integrating the concepts into a complete simulation. You will implement a two-element model, enforce continuity with a mortar-type Lagrange multiplier, and compute the resulting Schur complement matrix—the core of many advanced domain decomposition solvers. By numerically verifying the Schur complement's properties, you will see how theoretical guarantees, such as symmetry and positive definiteness, manifest in a practical computational setting.", "problem": "Consider the one-dimensional reaction-diffusion model problem with two adjacent spectral elements, a left element on the interval $[-1,0]$ and a right element on the interval $[0,1]$. Let the polynomial degrees be $p=2$ on the left and $q=3$ on the right, respectively. The partial differential equation is\n$$\n- u''(x) + \\alpha\\, u(x) = f(x) \\quad \\text{for } x \\in [-1,0]\\cup[0,1],\n$$\nwith homogeneous constraints on the outer boundaries and a weak interface constraint at $x=0$:\n$$\nu(-1) = 0, \\quad u(1) = 0, \\quad \\text{and} \\quad u(0^-)=u(0^+).\n$$\nThe interface constraint is enforced using a mortar-type Lagrange multiplier. The weak form uses the standard energy functional and constraints via Lagrange multipliers, leading to a symmetric saddle-point system.\n\nUse the spectral element method on each subinterval with Lagrange basis functions associated to Gauss–Lobatto–Legendre (GLL) nodes. Denote by $n=p$ and $m=q$ their polynomial degrees, so the left element has $n+1$ GLL nodes and the right element has $m+1$ GLL nodes. For a given element of length $h$, the reference-to-physical mapping is linear with Jacobian $J=h/2$. Using the GLL quadrature weights, the element-level mass matrix and stiffness matrix are defined by\n$$\nM_e = \\frac{h}{2}\\, W, \\qquad K_e = \\frac{2}{h}\\, D^\\top W D + \\alpha\\, M_e,\n$$\nwhere $W$ is the diagonal matrix of GLL weights and $D$ is the GLL derivative matrix with entries $D_{ij} = \\ell_j'(\\xi_i)$, with $\\ell_j$ the $j$-th Lagrange basis function evaluated at the GLL nodes $\\{\\xi_i\\}$.\n\nAssemble the global matrix $K$ by block-diagonal concatenation of the left and right element matrices with no strong boundary enforcement, and enforce the constraints via a Lagrange multiplier vector $\\lambda \\in \\mathbb{R}^3$. The constraints are:\n- Left Dirichlet boundary: $u_L(\\xi=-1)=0$,\n- Mortar interface continuity: $u_L(\\xi=+1)=u_R(\\xi=-1)$,\n- Right Dirichlet boundary: $u_R(\\xi=+1)=0$,\nencoded by a matrix $B \\in \\mathbb{R}^{3 \\times (n+1+m+1)}$ acting on the concatenated nodal vector $u$ of both elements.\n\nThe resulting Karush–Kuhn–Tucker (KKT) system is\n$$\n\\begin{bmatrix}\nK & B^\\top \\\\\nB & 0\n\\end{bmatrix}\n\\begin{bmatrix}\nu \\\\ \\lambda\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nf \\\\ 0\n\\end{bmatrix},\n$$\nwith $f$ taken as the zero vector (the homogeneous case) so that only the structure of the Schur complement matters.\n\nTask:\n1. Derive from first principles the discrete element matrices $M_e$ and $K_e$ using the GLL quadrature and the derivative matrix $D$. Construct the global block-diagonal $K$ and the constraint matrix $B$ as described above.\n2. Compute the Schur complement matrix for the Lagrange multipliers\n$$\nS = - B\\, K^{-1} B^\\top,\n$$\nexplicitly and numerically for the specified configuration.\n3. Verify symmetry and conditioning numerically for the Schur complement $S$ by reporting:\n   - The relative symmetry error $\\|S - S^\\top\\|_2 \\big/ \\|S\\|_2$,\n   - The spectral condition number of $-S$, defined as $\\kappa(-S) = \\lambda_{\\max}(-S) / \\lambda_{\\min}(-S)$.\nProvide the numerical values as floating-point numbers.\n\nUse the following test suite of parameter values $(h_L,h_R,\\alpha)$ to explore different element scalings and reaction strengths:\n- Case A (baseline): $(h_L,h_R,\\alpha) = (1.0, 1.0, 1.0)$,\n- Case B (left short element): $(h_L,h_R,\\alpha) = (0.5, 1.0, 1.0)$,\n- Case C (weak reaction, right long element): $(h_L,h_R,\\alpha) = (1.0, 2.0, 0.01)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each case contributes a list with two floats in the order $[\\text{symmetry\\_error}, \\text{condition\\_number}]$. The final output must be\n$$\n\\big[ [\\text{A\\_sym}, \\text{A\\_cond}], [\\text{B\\_sym}, \\text{B\\_cond}], [\\text{C\\_sym}, \\text{C\\_cond}] \\big].\n$$\nNo physical units are involved; angles do not apply. All numerical answers must be floats. The code must be self-contained and runnable without user input, and it must implement the computations using the above definitions from first principles (GLL quadrature, Lagrange basis derivatives, assembly, and Schur complement).", "solution": "The problem requires the numerical construction and analysis of the Schur complement matrix arising from a mortar-type enforcement of interface continuity between two non-conforming spectral elements. The analysis will be performed for a one-dimensional reaction-diffusion model. The solution proceeds in several stages: derivation of the necessary spectral method components, assembly of the global system, calculation of the Schur complement, and finally, numerical verification of its properties for the specified test cases.\n\n### 1. Discretization via Spectral Element Method\n\nThe domain is decomposed into two elements: a left element of length $h_L$ and a right element of length $h_R$, meeting at an interface. Within each element, the solution $u(x)$ is approximated by a polynomial. We use a nodal approach, where the polynomial is represented by its values at a set of Gauss-Lobatto-Legendre (GLL) points.\n\n#### 1.1. Gauss-Lobatto-Legendre (GLL) Quadrature and Basis\n\nFor a reference element on $[-1, 1]$, a polynomial approximation of degree $N$ is defined using $N+1$ GLL nodes, denoted $\\{\\xi_i\\}_{i=0}^N$. These nodes are the roots of $(1-\\xi^2)P'_N(\\xi) = 0$, where $P_N(\\xi)$ is the Legendre polynomial of degree $N$. The set includes the endpoints $\\xi_0 = -1$ and $\\xi_{N} = 1$. The associated quadrature weights are $\\{w_i\\}_{i=0}^N$.\n\nThe basis functions are the Lagrange polynomials $\\{\\ell_j(\\xi)\\}_{j=0}^N$ defined by $\\ell_j(\\xi_k) = \\delta_{jk}$. The derivative of these basis functions evaluated at the GLL nodes forms the differentiation matrix $D$ with entries $D_{ij} = \\ell'_j(\\xi_i)$.\n\nFor this problem, the left element has polynomial degree $p=n=2$, corresponding to $n+1=3$ GLL nodes. The right element has degree $q=m=3$, corresponding to $m+1=4$ GLL nodes.\n\n- **Left Element ($n=2$):**\n  - Nodes: $\\xi_L = [-1, 0, 1]$.\n  - Weights: $w_L = [1/3, 4/3, 1/3]$.\n- **Right Element ($m=3$):**\n  - Nodes: $\\xi_R = [-1, -1/\\sqrt{5}, 1/\\sqrt{5}, 1]$.\n  - Weights: $w_R = [1/6, 5/6, 5/6, 1/6]$.\n\nThe differentiation matrices $D_L$ (for $n=2$) and $D_R$ (for $m=3$) are constructed from the analytical formulas for $\\ell'_j(\\xi_i)$.\n\n#### 1.2. Element-Level Matrices\n\nThe weak form of the PDE on a single element $[x_a, x_b]$ of length $h = x_b-x_a$ is\n$$\n\\int_{x_a}^{x_b} (u'v' + \\alpha uv) dx = \\int_{x_a}^{x_b} fv dx,\n$$\nneglecting boundary/flux terms which are handled by assembly and constraints. Using a linear mapping $x(\\xi) = (h/2)\\xi + (x_a+x_b)/2$ from the reference element $[-1,1]$ with Jacobian $J = h/2$, the bilinear forms are transformed:\n$$\n\\int_{x_a}^{x_b} u'v' dx = \\frac{2}{h} \\int_{-1}^{1} \\frac{du}{d\\xi}\\frac{dv}{d\\xi} d\\xi \\quad \\text{and} \\quad \\int_{x_a}^{x_b} uv dx = \\frac{h}{2} \\int_{-1}^{1} uv d\\xi.\n$$\nApplying GLL quadrature, these integrals are approximated. The resulting element stiffness matrix $K_e$ is the sum of a Laplacian part and a mass part:\n$$\nK_e = A_e + \\alpha M_e.\n$$\nThe problem statement gives the standard spectrally-exact (diagonal) mass matrix $M_e = \\frac{h}{2} W$, where $W$ is the diagonal matrix of GLL weights. The discrete Laplacian matrix is $A_e = \\frac{2}{h} D^\\top W D$. Thus, the element stiffness matrix is:\n$$\nK_e = \\frac{2}{h} D^\\top W D + \\alpha \\frac{h}{2} W.\n$$\nSince $\\alpha > 0$ for all test cases and $W$ is positive definite, $K_e$ will be symmetric and positive definite.\n\n### 2. Global System Assembly and Constraints\n\nThe global stiffness matrix $K$ is formed by a block-diagonal assembly of the left and right element matrices, $K_L$ and $K_R$:\n$$\nK = \\begin{bmatrix} K_L & 0 \\\\ 0 & K_R \\end{bmatrix}.\n$$\nThe total degrees of freedom are the concatenated nodal values $u = [u_L^\\top, u_R^\\top]^\\top$, a vector of size $(n+1) + (m+1) = 3+4=7$. The indexing is $u = [u_{L,0}, u_{L,1}, u_{L,2}, u_{R,0}, u_{R,1}, u_{R,2}, u_{R,3}]^\\top$.\n\nThe constraints are enforced via a Lagrange multiplier vector $\\lambda \\in \\mathbb{R}^3$, corresponding to the three constraint equations, which are written as $Bu=0$:\n1.  **Left Dirichlet:** $u(-1) = 0$. This is the value at the first node of the left element, $u_{L,0}=0$.\n2.  **Interface Continuity:** $u(0^-) = u(0^+)$. This equates the value at the last node of the left element, $u_{L,n}$, to the value at the first node of the right element, $u_{R,0}$. For $n=2$, this is $u_{L,2} - u_{R,0} = 0$.\n3.  **Right Dirichlet:** $u(1) = 0$. This is the value at the last node of the right element, $u_{R,m}=0$. For $m=3$, this is $u_{R,3}=0$.\n\nThese three linear equations on the vector $u$ define the $3 \\times 7$ constraint matrix $B$:\n$$\nB = \\begin{pmatrix}\n1 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n0 & 0 & 1 & -1 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 0 & 0 & 0 & 1\n\\end{pmatrix}.\n$$\n\n### 3. The Schur Complement Matrix\n\nThe full saddle-point system is given by the Karush-Kuhn-Tucker (KKT) equations:\n$$\n\\begin{bmatrix}\nK & B^\\top \\\\\nB & 0\n\\end{bmatrix}\n\\begin{bmatrix}\nu \\\\ \\lambda\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nf \\\\ 0\n\\end{bmatrix}.\n$$\nBy eliminating $u = K^{-1}(f - B^\\top \\lambda)$, we obtain the system for the Lagrange multipliers $\\lambda$: $(B K^{-1} B^\\top) \\lambda = B K^{-1} f$. The Schur complement of the block $K$ is $S_{KKT} = -B K^{-1} B^\\top$. The problem defines the Schur complement as $S = S_{KKT}$.\n$$\nS = -B K^{-1} B^\\top.\n$$\nSince $K$ is symmetric, $K^{-1}$ is symmetric. Consequently, $S$ must be symmetric, as $S^\\top = -(B K^{-1} B^\\top)^\\top = -(B^\\top)^\\top (K^{-1})^\\top B^\\top = -B K^{-1} B^\\top = S$. Any numerical deviation from symmetry is due to floating-point arithmetic error.\n\nThe matrix $-S = B K^{-1} B^\\top$ is expected to be positive definite. Since $K$ is positive definite for $\\alpha > 0$, $K^{-1}$ is also positive definite. For any non-zero vector $v \\in \\mathbb{R}^3$, the quadratic form $v^\\top(-S)v = v^\\top B K^{-1} B^\\top v = (B^\\top v)^\\top K^{-1} (B^\\top v)$ is positive if $B^\\top v \\neq 0$. The matrix $B$ has full row rank, which implies its transpose $B^\\top$ has a trivial null space. Thus, for any $v \\neq 0$, $B^\\top v \\neq 0$, guaranteeing that $-S$ is positive definite. This allows for a meaningful computation of its spectral condition number $\\kappa(-S) = \\lambda_{\\max}(-S) / \\lambda_{\\min}(-S)$.\n\nThe numerical procedure involves:\n1.  For each test case $(h_L, h_R, \\alpha)$, construct $K_L$ and $K_R}$.\n2.  Assemble the global matrix $K$ and the constraint matrix $B$.\n3.  Compute $K^{-1}$ and subsequently $S = -B K^{-1} B^\\top$.\n4.  Calculate the relative symmetry error $\\|S - S^\\top\\|_2 / \\|S\\|_2$.\n5.  Compute the eigenvalues of the symmetric positive definite matrix $-S$ to find its condition number.", "answer": "```python\nimport numpy as np\nfrom scipy.special import legendre, roots_jacobi\n\ndef gll_data(N):\n    \"\"\"\n    Computes Gauss-Lobatto-Legendre (GLL) nodes, weights, and differentiation matrix.\n    \n    Args:\n        N (int): Polynomial degree.\n        \n    Returns:\n        tuple: A tuple containing:\n            - xi (np.ndarray): GLL nodes on [-1, 1].\n            - w (np.ndarray): GLL quadrature weights.\n            - D (np.ndarray): GLL differentiation matrix.\n    \"\"\"\n    if N == 0:\n        return np.array([0.0]), np.array([2.0]), np.array([[0.0]])\n    if N == 1:\n        return np.array([-1., 1.]), np.array([1., 1.]), np.array([[-0.5, 0.5], [-0.5, 0.5]])\n\n    # Nodes are roots of (1-x^2)P'_N(x)\n    # The internal nodes are roots of P'_N(x), which are roots of Jacobi polynomial P_{N-1}^{(1,1)}(x)\n    if N > 1:\n        internal_nodes, _ = roots_jacobi(N - 1, 1, 1)\n    else:\n        internal_nodes = np.array([])\n    xi = np.concatenate(([-1.0], np.sort(internal_nodes), [1.0]))\n\n    # Weights\n    p_N = legendre(N)\n    w = 2 / (N * (N + 1) * p_N(xi)**2)\n\n    # Differentiation Matrix\n    D = np.zeros((N + 1, N + 1))\n    p_N_vals = p_N(xi)\n    for i in range(N + 1):\n        for j in range(N + 1):\n            if i != j:\n                D[i, j] = p_N_vals[i] / (p_N_vals[j] * (xi[i] - xi[j]))\n            elif i == 0:\n                D[0, 0] = -N * (N + 1) / 4.0\n            elif i == N:\n                D[N, N] = N * (N + 1) / 4.0\n            else:\n                # Based on sum-to-zero property. For internal nodes this is 0.\n                D[i, i] = 0.0\n    \n    return xi, w, D\n\ndef solve_case(h_L, h_R, alpha):\n    \"\"\"\n    Solves one case of the problem by constructing matrices and computing metrics.\n    \n    Args:\n        h_L (float): Length of the left element.\n        h_R (float): Length of the right element.\n        alpha (float): Reaction coefficient.\n        \n    Returns:\n        list: A list containing [symmetry_error, condition_number].\n    \"\"\"\n    # 1. Get GLL data for left (n=2) and right (m=3) elements\n    n, m = 2, 3\n    _, w_L, D_L = gll_data(n)\n    _, w_R, D_R = gll_data(m)\n\n    # 2. Construct element stiffness matrices K_L and K_R\n    W_L = np.diag(w_L)\n    K_L = (2 / h_L) * (D_L.T @ W_L @ D_L) + alpha * (h_L / 2) * W_L\n\n    W_R = np.diag(w_R)\n    K_R = (2 / h_R) * (D_R.T @ W_R @ D_R) + alpha * (h_R / 2) * W_R\n\n    # 3. Assemble global block-diagonal stiffness matrix K\n    N_L, N_R = n + 1, m + 1\n    K = np.zeros((N_L + N_R, N_L + N_R))\n    K[0:N_L, 0:N_L] = K_L\n    K[N_L:N_L + N_R, N_L:N_L + N_R] = K_R\n\n    # 4. Construct constraint matrix B\n    # u = [u_L_0, u_L_1, u_L_2, u_R_0, u_R_1, u_R_2, u_R_3]^T\n    # Constraints are:\n    # 1. u_L(-1) = u_L,0 = 0\n    # 2. u_L(1) = u_R(-1) => u_L,n = u_R,0 => u_L,2 = u_R,0\n    # 3. u_R(1) = u_R,m = 0 => u_R,3 = 0\n    B = np.zeros((3, N_L + N_R))\n    B[0, 0] = 1.0          # u_L,0 = 0\n    B[1, n] = 1.0          # u_L,n - u_R,0 = 0\n    B[1, N_L] = -1.0\n    B[2, N_L + N_R - 1] = 1.0 # u_R,m = 0\n\n    # 5. Compute Schur complement S = -B K^{-1} B^T\n    K_inv = np.linalg.inv(K)\n    S = -B @ K_inv @ B.T\n    \n    # 6. Compute metrics for S\n    # Relative symmetry error using spectral norm\n    norm_S = np.linalg.norm(S, 2)\n    # Avoid division by zero if S is the zero matrix\n    sym_err = np.linalg.norm(S - S.T, 2) / norm_S if norm_S > 0 else 0.0\n    \n    # Condition number of -S\n    neg_S = -S\n    # -S is symmetric, so we can use eigvalsh for efficiency and stability\n    eigvals = np.linalg.eigvalsh(neg_S)\n    \n    # Check for positive definiteness\n    if np.any(eigvals = 0):\n        raise ValueError(f\"Matrix -S is not positive definite for case ({h_L}, {h_R}, {alpha}). Eigenvalues: {eigvals}\")\n        \n    min_eig = np.min(eigvals)\n    cond_num = np.max(eigvals) / min_eig if min_eig > 0 else float('inf')\n\n    return [sym_err, cond_num]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: (h_L, h_R, alpha) = (1.0, 1.0, 1.0)\n        (1.0, 1.0, 1.0),\n        # Case B: (h_L, h_R, alpha) = (0.5, 1.0, 1.0)\n        (0.5, 1.0, 1.0),\n        # Case C: (h_L, h_R, alpha) = (1.0, 2.0, 0.01)\n        (1.0, 2.0, 0.01),\n    ]\n\n    results = []\n    for case in test_cases:\n        h_L, h_R, alpha = case\n        result = solve_case(h_L, h_R, alpha)\n        results.append(result)\n\n    # Format output as specified: [[A_sym, A_cond], [B_sym, B_cond], [C_sym, C_cond]]\n    # map(str, results) will convert each sublist like [val1, val2] to a string '[val1, val2]'\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3403378"}]}