{"hands_on_practices": [{"introduction": "To begin our hands-on exploration of Proper Orthogonal Decomposition (POD), we first need to master its primary computational engine: the method of snapshots. This practice guides you through deriving and implementing this essential algorithm, which efficiently computes optimal basis modes from a high-dimensional dataset [@problem_id:3410811]. Crucially, you will incorporate a weighted inner product defined by a mass matrix $M$, a necessary step for applying POD to solutions generated by spectral or Discontinuous Galerkin (DG) methods.", "problem": "You are given a snapshot matrix $X \\in \\mathbb{R}^{N \\times m}$ with $m \\ll N$ and a symmetric positive definite matrix $M \\in \\mathbb{R}^{N \\times N}$ that induces the weighted inner product $\\langle u,v\\rangle_M = u^\\top M v$ and norm $\\|u\\|_M = \\sqrt{u^\\top M u}$. In the Proper Orthogonal Decomposition (POD) problem, one seeks an $M$-orthonormal basis that maximizes the mean-square projection of the snapshots, where $M$ represents, for example, the mass matrix arising from a spectral or discontinuous Galerkin discretization. The method of snapshots constructs POD modes using an eigenvalue problem in the snapshot space.\n\nStarting from the definition of the POD subspace as the solution of the constrained maximization of the average $M$-energy captured by orthonormal basis vectors, derive an explicit algorithm based on fundamental linear algebra principles to compute $M$-orthonormal POD modes using the method of snapshots. Your derivation must begin from the variational characterization of optimality under the $M$-inner product and reduce the problem to an eigenvalue problem posed in the $m$-dimensional snapshot space. The algorithm must automatically determine the numerical rank based on a principled tolerance and must be robust when $X$ is rank-deficient.\n\nThen implement your algorithm as a program that:\n- Given several test cases $(M,X)$, computes the POD modes and verifies $M$-orthonormality. Specifically, if $\\Phi \\in \\mathbb{R}^{N \\times r}$ denotes the computed POD basis (with $r$ equal to the determined numerical rank), verify that $\\Phi^\\top M \\Phi$ is the identity matrix of size $r$ within a consistent numerical tolerance.\n- For each test case, return a boolean indicating whether both the $M$-orthonormality check passes and the number of returned modes equals the numerical rank determined by your tolerance from the snapshot-space eigenvalue problem.\n\nNo physical units or angles are involved in this problem. All outputs are dimensionless. Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, `[True,False,...]`.\n\nUse the following test suite. For all cases below, $N$ and $m$ are understood from the dimensions.\n\nTest case one (happy path):\n- $M_1 = I_6$, the identity matrix of size $6$.\n- $X_1 = \\begin{bmatrix}\n1 & 2 & 3\\\\\n0 & 1 & 0\\\\\n1 & 0 & 1\\\\\n2 & 1 & 0\\\\\n0 & 1 & 2\\\\\n1 & 0 & 0\n\\end{bmatrix}$.\n\nTest case two (nontrivial diagonal $M$):\n- $M_2 = \\mathrm{diag}(2,\\,0.5,\\,3,\\,1.5,\\,4,\\,1)$.\n- $X_2 = \\begin{bmatrix}\n0.5 & 1.0 & -1.0\\\\\n2.0 & -1.0 & 0.0\\\\\n1.5 & 0.0 & 2.0\\\\\n0.0 & 1.0 & 1.0\\\\\n-1.0 & 0.5 & 0.0\\\\\n1.0 & -0.5 & 2.0\n\\end{bmatrix}$.\n\nTest case three (rank-deficient snapshots with symmetric positive definite $M$ constructed from a given $A$):\n- Define $A_3 = \\begin{bmatrix}\n1 & 0 & 2 & 0 & 1 & 0\\\\\n0 & 1 & 0 & 2 & 0 & 1\\\\\n1 & 1 & 0 & 0 & 1 & 0\\\\\n0 & 0 & 1 & 1 & 0 & 1\\\\\n1 & 0 & 0 & 1 & 1 & 0\\\\\n0 & 1 & 1 & 0 & 0 & 1\n\\end{bmatrix}$ and set $M_3 = A_3^\\top A_3 + 0.1\\,I_6$.\n- Let $c_1 = \\begin{bmatrix}1\\\\0\\\\1\\\\0\\\\1\\\\0\\end{bmatrix}$ and $c_2 = \\begin{bmatrix}0\\\\1\\\\0\\\\1\\\\0\\\\1\\end{bmatrix}$, and form $X_3 = \\begin{bmatrix} c_1 & c_2 & (c_1+c_2) & (2\\,c_2)\\end{bmatrix}$.\n\nTest case four (single snapshot):\n- $M_4 = \\mathrm{diag}(1,\\,2,\\,3,\\,4,\\,5)$.\n- $X_4 = \\begin{bmatrix}1\\\\-1\\\\2\\\\0\\\\3\\end{bmatrix}$.\n\nTest case five (ill-conditioned diagonal $M$):\n- $M_5 = \\mathrm{diag}(10^{-6},\\,10^{-3},\\,1,\\,10^{3},\\,10^{6},\\,2)$.\n- $X_5 = \\begin{bmatrix}\n1.0 & 0.0 & 0.5\\\\\n0.0 & 1.0 & -0.5\\\\\n0.5 & -0.5 & 1.0\\\\\n1.0 & 0.0 & -1.0\\\\\n0.0 & 1.0 & 0.0\\\\\n1.0 & -1.0 & 0.0\n\\end{bmatrix}$.\n\nAlgorithmic and verification requirements:\n- Derive the method of snapshots from first principles under the $M$-inner product, reducing the construction to an eigenvalue problem in snapshot space and back-substitution to form modes.\n- Implement a numerically stable selection of the numerical rank by thresholding the eigenvalues of the snapshot-space correlation matrix relative to its largest eigenvalue and machine precision. If $r$ is the number of eigenvalues above the threshold, return exactly $r$ modes.\n- Verify $M$-orthonormality via the Frobenius norm of $\\Phi^\\top M \\Phi - I_r$ being below a tolerance that scales appropriately with the problem size and machine precision.\n- For each test case, output a boolean that is `True` if and only if the orthonormality verification passes and the number of returned modes equals the determined numerical rank, and `False` otherwise.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, `[True,False,True,True,True]`.", "solution": "The problem of computing Proper Orthogonal Decomposition (POD) modes is fundamentally an optimization problem. Given a set of snapshots represented by the columns of a matrix $X \\in \\mathbb{R}^{N \\times m}$, and a symmetric positive definite (SPD) matrix $M \\in \\mathbb{R}^{N \\times N}$ defining a weighted inner product $\\langle u, v \\rangle_M = u^\\top M v$, we seek an $M$-orthonormal basis $\\{\\phi_k\\}_{k=1}^r$ that optimally captures the \"energy\" of the snapshots. The \"method of snapshots\" is an efficient algorithm to solve this problem when the number of snapshots $m$ is much smaller than the state dimension $N$ (i.e., $m \\ll N$).\n\nWe begin by deriving the algorithm from its variational foundation. The first POD mode, $\\phi_1$, is the vector that maximizes the mean-square projection of the snapshots, subject to being normalized in the $M$-norm. This is expressed as the following optimization problem:\n$$\n\\max_{\\phi \\in \\mathbb{R}^N} \\frac{1}{m} \\sum_{j=1}^{m} |\\langle x_j, \\phi \\rangle_M|^2 \\quad \\text{subject to} \\quad \\|\\phi\\|_M^2 = 1\n$$\nwhere $x_j$ is the $j$-th column of the snapshot matrix $X$.\n\nThe objective function can be rewritten using matrix notation. The squared inner product is $|\\langle x_j, \\phi \\rangle_M|^2 = (\\phi^\\top M x_j)(x_j^\\top M \\phi)$. Summing over all snapshots gives:\n$$\n\\frac{1}{m} \\sum_{j=1}^{m} \\phi^\\top M x_j x_j^\\top M \\phi = \\phi^\\top M \\left( \\frac{1}{m} \\sum_{j=1}^{m} x_j x_j^\\top \\right) M \\phi = \\phi^\\top M \\left( \\frac{1}{m} X X^\\top \\right) M \\phi\n$$\nLet $C_X = \\frac{1}{m} X X^\\top$ be the spatial correlation matrix. The constraint is $\\|\\phi\\|_M^2 = \\phi^\\top M \\phi = 1$. The optimization problem for $\\phi_1$ is:\n$$\n\\max_{\\phi \\in \\mathbb{R}^N} \\phi^\\top M C_X M \\phi \\quad \\text{subject to} \\quad \\phi^\\top M \\phi = 1\n$$\nThis is a standard Rayleigh quotient problem. Using the method of Lagrange multipliers, we define the Lagrangian $\\mathcal{L}(\\phi, \\sigma) = \\phi^\\top M C_X M \\phi - \\sigma (\\phi^\\top M \\phi - 1)$. Taking the gradient with respect to $\\phi^\\top$ and setting it to zero yields the generalized eigenvalue problem:\n$$\nM C_X M \\phi = \\sigma M \\phi\n$$\nSince $M$ is invertible, this is equivalent to $C_X M \\phi = \\sigma \\phi$. This is an $N \\times N$ eigenvalue problem, which is computationally prohibitive to solve directly if $N$ is large.\n\nThe method of snapshots provides an efficient alternative by exploiting the fact that any POD mode $\\phi$ must lie in the span of the snapshots. To see this, note that from the eigenvalue equation, $\\phi = \\frac{1}{\\sigma} C_X M \\phi = \\frac{1}{\\sigma m} (XX^\\top) M \\phi$. This can be written as $\\phi = \\sum_{j=1}^m \\alpha_j x_j$, where the coefficients are $\\alpha_j = \\frac{1}{\\sigma m} x_j^\\top M \\phi$. This demonstrates that $\\phi \\in \\text{span}\\{x_1, \\dots, x_m\\}$.\n\nThus, we can seek the POD modes in the form of a linear combination of the snapshots:\n$$\n\\phi = X a = \\sum_{j=1}^{m} a_j x_j\n$$\nfor some coefficient vector $a \\in \\mathbb{R}^m$. Substituting this ansatz into the original variational problem, the objective function becomes:\n$$\n\\phi^\\top M C_X M \\phi = (Xa)^\\top M \\left(\\frac{1}{m}XX^\\top\\right) M (Xa) = \\frac{1}{m} a^\\top (X^\\top M X) (X^\\top M X) a\n$$\nLet us define the snapshot Gram matrix $K_m = X^\\top M X \\in \\mathbb{R}^{m \\times m}$. This matrix is symmetric and positive semi-definite. The objective function simplifies to $\\frac{1}{m} a^\\top K_m^2 a$. The constraint $\\phi^\\top M \\phi = 1$ becomes:\n$$\n(Xa)^\\top M (Xa) = a^\\top (X^\\top M X) a = a^\\top K_m a = 1\n$$\nThe problem is reduced to an $m$-dimensional optimization problem for the coefficient vector $a$:\n$$\n\\max_{a \\in \\mathbb{R}^m} \\frac{1}{m} a^\\top K_m^2 a \\quad \\text{subject to} \\quad a^\\top K_m a = 1\n$$\nAgain, we form the Lagrangian $\\mathcal{L}(a, \\lambda) = \\frac{1}{m} a^\\top K_m^2 a - \\lambda(a^\\top K_m a - 1)$. The stationarity condition is $\\frac{1}{m} K_m^2 a - \\lambda K_m a = 0$. Since we are seeking non-trivial modes, we are not interested in the null space of $K_m$ (where $K_m a = 0$). For $a$ outside the null space, we can simplify to:\n$$\nK_m a = m \\lambda a\n$$\nThis is a standard $m \\times m$ eigenvalue problem. Let $(\\lambda_k, a_k)$ for $k=1, \\dots, r$ be the eigenpairs of $K_m$, where $r \\le m$ is the rank of $K_m$. The eigenvalues $\\lambda_k$ are the $M$-weighted energies of the modes, and the eigenvectors $a_k$ provide the coefficients to construct the POD modes. Since $K_m$ is symmetric, its eigenvectors can be chosen to be orthonormal, $a_k^\\top a_j = \\delta_{kj}$.\n\nThe POD modes $\\phi_k$ are constructed from the eigenvectors $a_k$. First, we form `pre-modes` $\\tilde{\\phi}_k = X a_k$. Their $M$-inner products are:\n$$\n\\langle \\tilde{\\phi}_k, \\tilde{\\phi}_j \\rangle_M = (Xa_k)^\\top M (Xa_j) = a_k^\\top (X^\\top M X) a_j = a_k^\\top K_m a_j = a_k^\\top (\\lambda_j a_j) = \\lambda_j (a_k^\\top a_j) = \\lambda_j \\delta_{kj}\n$$\nThis shows that the pre-modes are $M$-orthogonal. The $M$-norm of a pre-mode is $\\|\\tilde{\\phi}_k\\|_M = \\sqrt{\\lambda_k}$. To obtain an $M$-orthonormal basis, we normalize each pre-mode:\n$$\n\\phi_k = \\frac{\\tilde{\\phi}_k}{\\|\\tilde{\\phi}_k\\|_M} = \\frac{X a_k}{\\sqrt{\\lambda_k}}\n$$\nThis is valid for all strictly positive eigenvalues $\\lambda_k > 0$.\n\nThe complete algorithm is as follows:\n1.  **Form Snapshot Gram Matrix**: Compute $K_m = X^\\top M X$, an $m \\times m$ matrix.\n2.  **Solve Eigenproblem**: Solve the symmetric eigenvalue problem $K_m a_k = \\lambda_k a_k$ for eigenvalues $\\lambda_k$ and orthonormal eigenvectors $a_k$.\n3.  **Determine Rank**: Sort the eigenvalues in descending order: $\\lambda_1 \\ge \\lambda_2 \\ge \\dots \\ge \\lambda_m \\ge 0$. The numerical rank $r$ is determined by retaining eigenvalues that are significant relative to the largest one. A principled tolerance is $\\tau = \\lambda_1 \\cdot m \\cdot \\epsilon_{\\text{mach}}$, where $\\epsilon_{\\text{mach}}$ is machine epsilon. The rank $r$ is the number of eigenvalues $\\lambda_k > \\tau$.\n4.  **Construct Modes**: For the $r$ selected eigenpairs $(\\lambda_k, a_k)$, construct the POD modes $\\phi_k = \\frac{1}{\\sqrt{\\lambda_k}} X a_k$. The final basis is $\\Phi = [\\phi_1, \\dots, \\phi_r] \\in \\mathbb{R}^{N \\times r}$.\n5.  **Verification**: Confirm that the computed basis $\\Phi$ is indeed $M$-orthonormal by checking if the matrix $\\Phi^\\top M \\Phi$ is close to the identity matrix $I_r$. The deviation is measured by the Frobenius norm $\\|\\Phi^\\top M \\Phi - I_r\\|_F$, which should be below a verification tolerance. A robust tolerance must account for the problem's numerical conditioning, which is related to the condition number of the effective matrix being inverted, i.e., $\\kappa(K_m) = \\lambda_1 / \\lambda_r$.\n\nThis derivation and resulting algorithm provide a complete, robust procedure for computing $M$-orthonormal POD modes using the method of snapshots, including principled rank determination and verification.", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the POD algorithm on them.\n    \"\"\"\n\n    def compute_pod_modes(M: np.ndarray, X: np.ndarray) -> bool:\n        \"\"\"\n        Computes M-orthonormal POD modes using the method of snapshots and verifies the result.\n        \n        Args:\n            M: The symmetric positive definite mass matrix (N x N).\n            X: The snapshot matrix (N x m).\n        \n        Returns:\n            A boolean that is True if the M-orthonormality check passes and the\n            number of returned modes equals the determined numerical rank.\n        \"\"\"\n        N, m = X.shape\n\n        if m == 0:\n            # Vacuously true: numerical rank is 0, 0 modes are returned,\n            # and orthonormality of an empty set is trivial.\n            return True\n\n        # Step 1: Form the snapshot-space Gram matrix Km = X^T * M * X\n        Km = X.T @ M @ X\n\n        # Step 2: Solve the eigenvalue problem for the symmetric matrix Km\n        try:\n            # eigh returns eigenvalues in ascending order and orthonormal eigenvectors\n            eigenvalues, eigenvectors = eigh(Km)\n        except np.linalg.LinAlgError:\n            # This can occur if Km contains non-finite values, indicating an invalid setup.\n            return False\n\n        # Sort eigenvalues and corresponding eigenvectors in descending order\n        sorted_indices = np.argsort(eigenvalues)[::-1]\n        lambdas = eigenvalues[sorted_indices]\n        A = eigenvectors[:, sorted_indices]\n\n        # Step 3: Determine the numerical rank r based on a principled tolerance\n        lambda_max = lambdas[0] if m > 0 and len(lambdas) > 0 else 0.0\n        \n        if lambda_max = 0:\n            # This happens if all snapshots are in the null space of M or are zero vectors.\n            r = 0\n        else:\n            # Rank tolerance relative to the largest eigenvalue, machine precision, and problem size\n            rank_tol = lambda_max * m * np.finfo(float).eps\n            r = np.sum(lambdas > rank_tol)\n\n        if r == 0:\n            # No significant modes were found. The number of modes returned (0) matches rank (0).\n            return True\n\n        # Step 4: Select the top r eigenvalues and eigenvectors\n        top_lambdas = lambdas[:r]\n        top_A = A[:, :r]\n\n        # Step 5: Construct the POD modes\n        # phi_k = (1/sqrt(lambda_k)) * X @ a_k\n        # In matrix form: Phi = X @ A_r @ Lambda_r^(-1/2)\n        Phi = (X @ top_A) / np.sqrt(top_lambdas)\n\n        # Step 6: Verification\n        # 6a: The number of returned modes must match the determined rank.\n        num_modes_ok = (Phi.shape[1] == r)\n\n        # 6b: The computed basis Phi must be M-orthonormal.\n        # We check if Phi^T @ M @ Phi is close to the identity matrix.\n        check_matrix = Phi.T @ M @ Phi\n        Id_r = np.eye(r)\n        frob_norm_diff = np.linalg.norm(check_matrix - Id_r, 'fro')\n\n        # A principled verification tolerance that adapts to the problem's conditioning.\n        # The condition number of the snapshot Gram matrix subproblem.\n        lambda_min_r = top_lambdas[-1]\n        cond_Km_r = lambda_max / lambda_min_r if lambda_min_r > 0 else np.inf\n\n        # The tolerance scales with problem size, machine epsilon, and conditioning.\n        # We also set a minimum tolerance floor for well-conditioned problems.\n        verify_tol = max(1e-9, np.sqrt(r) * cond_Km_r * m * np.finfo(float).eps)\n        \n        orthonormality_ok = (frob_norm_diff  verify_tol)\n\n        return orthonormality_ok and num_modes_ok\n\n    # Define test cases\n    # Test case one\n    M1 = np.eye(6)\n    X1 = np.array([\n        [1, 2, 3], [0, 1, 0], [1, 0, 1],\n        [2, 1, 0], [0, 1, 2], [1, 0, 0]\n    ], dtype=float)\n\n    # Test case two\n    M2 = np.diag([2.0, 0.5, 3.0, 1.5, 4.0, 1.0])\n    X2 = np.array([\n        [0.5, 1.0, -1.0], [2.0, -1.0, 0.0], [1.5, 0.0, 2.0],\n        [0.0, 1.0, 1.0], [-1.0, 0.5, 0.0], [1.0, -0.5, 2.0]\n    ], dtype=float)\n\n    # Test case three\n    A3 = np.array([\n        [1, 0, 2, 0, 1, 0], [0, 1, 0, 2, 0, 1], [1, 1, 0, 0, 1, 0],\n        [0, 0, 1, 1, 0, 1], [1, 0, 0, 1, 1, 0], [0, 1, 1, 0, 0, 1]\n    ], dtype=float)\n    M3 = A3.T @ A3 + 0.1 * np.eye(6)\n    c1 = np.array([1, 0, 1, 0, 1, 0], dtype=float)\n    c2 = np.array([0, 1, 0, 1, 0, 1], dtype=float)\n    X3 = np.array([c1, c2, c1 + c2, 2 * c2]).T\n\n    # Test case four\n    M4 = np.diag([1.0, 2.0, 3.0, 4.0, 5.0])\n    X4 = np.array([[1], [-1], [2], [0], [3]], dtype=float)\n\n    # Test case five\n    M5 = np.diag([1e-6, 1e-3, 1.0, 1e3, 1e6, 2.0])\n    X5 = np.array([\n        [1.0, 0.0, 0.5], [0.0, 1.0, -0.5], [0.5, -0.5, 1.0],\n        [1.0, 0.0, -1.0], [0.0, 1.0, 0.0], [1.0, -1.0, 0.0]\n    ], dtype=float)\n\n    test_cases = [\n        (M1, X1),\n        (M2, X2),\n        (M3, X3),\n        (M4, X4),\n        (M5, X5),\n    ]\n\n    results = []\n    for M, X in test_cases:\n        result = compute_pod_modes(M, X)\n        results.append(str(result))\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3410811"}, {"introduction": "With the core POD algorithm in hand, we now turn to a common challenge in practical applications: handling inhomogeneous boundary conditions. This exercise demonstrates the standard technique of using a \"lifting function\" to transform the problem into one with homogeneous boundary conditions, for which a standard POD basis is well-suited [@problem_id:3410807]. Mastering this procedure is key to building effective reduced-order models for a wide range of real-world partial differential equations.", "problem": "Consider the one-dimensional heat equation on the unit interval with inhomogeneous Dirichlet boundary conditions,\n$$\nu_t(x,t) = u_{xx}(x,t) + f(x,t), \\quad x \\in (0,1), \\; t0,\n$$\nsubject to\n$$\nu(0,t) = g_0(t), \\qquad u(1,t) = g_1(t),\n$$\nand a given initial condition $u(x,0) = u_0(x)$ consistent with the boundary data. In a spectral Galerkin or Discontinuous Galerkin (DG) discretization, Proper Orthogonal Decomposition (POD) is to be used for model reduction. To handle the inhomogeneous boundary conditions, introduce a lifting of the form $u = \\ell + \\tilde{u}$, where the lifting $\\ell$ enforces the boundary values and the homogeneous component $\\tilde{u}$ satisfies homogeneous Dirichlet boundary conditions.\n\n1) Starting from the strong form and the definition of $\\ell$ as a boundary lifting, derive the partial differential equation governing $\\tilde{u}$ and its weak form suitable for a Galerkin projection onto homogeneous Dirichlet test functions. Express clearly how the forcing terms are modified by the lifting, identifying the contributions that arise from $\\ell_t$ and $\\ell_{xx}$.\n\n2) Let $\\{\\varphi_i(x)\\}_{i=1}^r$ be POD modes computed in a reduced space that enforces homogeneous Dirichlet boundary conditions. Let the $L^2(0,1)$ inner product be the Galerkin inner product. Derive the reduced-order model for the modal coefficients $a_i(t)$ defined by the expansion $\\tilde{u}(x,t) = \\sum_{i=1}^r a_i(t)\\,\\varphi_i(x)$. Your derivation must start from the weak form and arrive at a system of ordinary differential equations of the form\n$$\n\\mathbf{M}\\,\\dot{\\mathbf{a}}(t) + \\mathbf{S}\\,\\mathbf{a}(t) = \\mathbf{F}(t),\n$$\nidentifying the reduced mass matrix $\\mathbf{M}$, stiffness matrix $\\mathbf{S}$, and reduced forcing vector $\\mathbf{F}(t)$ in terms of the chosen inner product and the modified forcing due to the lifting.\n\n3) Clarify, from first principles, how to compute snapshots of the homogeneous component $\\tilde{u}$ from full-order snapshots of $u$ arising from a DG simulation that enforces the inhomogeneous boundary conditions via numerical fluxes. Specify how to form the snapshot ensemble and correlation operator for POD so that the modes satisfy homogeneous Dirichlet boundary conditions and the inner product is consistent with the discrete DG mass matrix.\n\n4) Now specialize to the following data, which you must use to carry out a concrete calculation. Take the boundary data and source\n$$\ng_0(t) = \\sin(t), \\qquad g_1(t) = 0, \\qquad f(x,t) = x,\n$$\nand choose the linear lifting\n$$\n\\ell(x,t) = g_0(t)\\,(1-x) + g_1(t)\\,x.\n$$\nLet the reduced basis consist of the first two $L^2(0,1)$-orthonormal sine functions,\n$$\n\\varphi_1(x) = \\sqrt{2}\\,\\sin(\\pi x), \\qquad \\varphi_2(x) = \\sqrt{2}\\,\\sin(2\\pi x).\n$$\nUsing your general reduced-order model, compute the first component of the reduced forcing, $F_1(t)$, and then evaluate it at $t = \\ln(2)$. Express your final answer as a closed-form analytic expression in terms of elementary functions. Do not approximate; no rounding is required. The requested final answer is the value of $F_1(\\ln 2)$, given as a single closed-form expression without units.", "solution": "The problem is valid as it is scientifically grounded in the theory of partial differential equations and numerical methods, well-posed, objective, and contains all necessary information for a complete solution.\n\nThe problem asks for a four-part solution involving the model reduction of a one-dimensional heat equation with inhomogeneous boundary conditions using Proper Orthogonal Decomposition (POD).\n\n**1) Derivation of the PDE for the Homogeneous Component and its Weak Form**\n\nThe given partial differential equation (PDE) is the heat equation:\n$$\nu_t(x,t) = u_{xx}(x,t) + f(x,t), \\quad x \\in (0,1), \\; t0\n$$\nwith inhomogeneous Dirichlet boundary conditions:\n$$\nu(0,t) = g_0(t), \\qquad u(1,t) = g_1(t)\n$$\nWe introduce a lifting decomposition $u(x,t) = \\ell(x,t) + \\tilde{u}(x,t)$. The function $\\ell(x,t)$ is the lifting, designed to satisfy the inhomogeneous boundary conditions, i.e., $\\ell(0,t) = g_0(t)$ and $\\ell(1,t) = g_1(t)$. Consequently, the new unknown function $\\tilde{u}(x,t)$ must satisfy homogeneous Dirichlet boundary conditions:\n$$\n\\tilde{u}(0,t) = u(0,t) - \\ell(0,t) = g_0(t) - g_0(t) = 0\n$$\n$$\n\\tilde{u}(1,t) = u(1,t) - \\ell(1,t) = g_1(t) - g_1(t) = 0\n$$\nTo find the PDE governing $\\tilde{u}$, we substitute the decomposition $u = \\ell + \\tilde{u}$ into the original heat equation. We compute the partial derivatives of $u$:\n$$\nu_t = \\frac{\\partial}{\\partial t}(\\ell + \\tilde{u}) = \\ell_t + \\tilde{u}_t\n$$\n$$\nu_{xx} = \\frac{\\partial^2}{\\partial x^2}(\\ell + \\tilde{u}) = \\ell_{xx} + \\tilde{u}_{xx}\n$$\nSubstituting these into the PDE gives:\n$$\n\\ell_t + \\tilde{u}_t = (\\ell_{xx} + \\tilde{u}_{xx}) + f(x,t)\n$$\nRearranging the terms to isolate the equation for $\\tilde{u}$, we obtain:\n$$\n\\tilde{u}_t - \\tilde{u}_{xx} = f(x,t) - \\ell_t(x,t) + \\ell_{xx}(x,t)\n$$\nThis is the strong form of the PDE for the homogeneous component $\\tilde{u}$. The term on the right-hand side is the modified forcing term, where $-\\ell_t$ and $\\ell_{xx}$ are the contributions from the lifting function.\n\nTo derive the weak form, we multiply this PDE by a test function $v(x)$ that belongs to the space of functions appropriate for homogeneous Dirichlet boundary conditions, typically $v \\in H_0^1(0,1)$, which means $v$ is square-integrable, its derivative is square-integrable, and $v(0)=v(1)=0$. We then integrate over the spatial domain $[0,1]$:\n$$\n\\int_0^1 (\\tilde{u}_t - \\tilde{u}_{xx}) v \\, dx = \\int_0^1 (f - \\ell_t + \\ell_{xx}) v \\, dx\n$$\nUsing the linearity of the integral, we separate the terms on the left:\n$$\n\\int_0^1 \\tilde{u}_t v \\, dx - \\int_0^1 \\tilde{u}_{xx} v \\, dx = \\int_0^1 (f - \\ell_t + \\ell_{xx}) v \\, dx\n$$\nWe apply integration by parts to the second term on the left:\n$$\n- \\int_0^1 \\tilde{u}_{xx} v \\, dx = - \\left[ \\tilde{u}_x v \\right]_0^1 + \\int_0^1 \\tilde{u}_x v_x \\, dx\n$$\nSince the test function $v$ satisfies homogeneous Dirichlet boundary conditions, $v(0)=v(1)=0$, the boundary term $\\left[ \\tilde{u}_x v \\right]_0^1$ vanishes. The weak form is then to find $\\tilde{u}(\\cdot, t) \\in H_0^1(0,1)$ such that for all $v \\in H_0^1(0,1)$:\n$$\n\\int_0^1 \\tilde{u}_t v \\, dx + \\int_0^1 \\tilde{u}_x v_x \\, dx = \\int_0^1 (f - \\ell_t + \\ell_{xx}) v \\, dx\n$$\n\n**2) Derivation of the Reduced-Order Model (ROM)**\n\nThe reduced-order model is obtained by a Galerkin projection of the weak form onto a low-dimensional subspace spanned by the POD modes $\\{\\varphi_i(x)\\}_{i=1}^r$. These modes satisfy the homogeneous Dirichlet boundary conditions, so they form a valid basis for the space where $\\tilde{u}$ resides. We seek an approximate solution of the form:\n$$\n\\tilde{u}(x,t) \\approx \\sum_{j=1}^r a_j(t)\\,\\varphi_j(x)\n$$\nwhere $a_j(t)$ are the time-dependent modal coefficients. We substitute this expansion into the weak form derived in Part 1. For the Galerkin method, we choose the test functions to be the basis functions themselves, i.e., $v(x) = \\varphi_i(x)$ for $i=1, \\dots, r$.\n\nSubstituting the expansion and $v=\\varphi_i$ into the weak form yields, for each $i \\in \\{1, \\dots, r\\}$:\n$$\n\\int_0^1 \\frac{\\partial}{\\partial t}\\left(\\sum_{j=1}^r a_j(t)\\varphi_j(x)\\right) \\varphi_i(x) \\, dx + \\int_0^1 \\frac{\\partial}{\\partial x}\\left(\\sum_{j=1}^r a_j(t)\\varphi_j(x)\\right) \\frac{d\\varphi_i}{dx}(x) \\, dx = \\int_0^1 (f - \\ell_t + \\ell_{xx}) \\varphi_i(x) \\, dx\n$$\nUsing the linearity of differentiation and integration, we obtain:\n$$\n\\sum_{j=1}^r \\dot{a}_j(t) \\int_0^1 \\varphi_j(x) \\varphi_i(x) \\, dx + \\sum_{j=1}^r a_j(t) \\int_0^1 \\frac{d\\varphi_j}{dx}(x) \\frac{d\\varphi_i}{dx}(x) \\, dx = \\int_0^1 (f - \\ell_t + \\ell_{xx}) \\varphi_i(x) \\, dx\n$$\nWe define the $L^2(0,1)$ inner product as $(w,z) = \\int_0^1 w(x)z(x) \\, dx$. The system of equations can be written as:\n$$\n\\sum_{j=1}^r (\\varphi_j, \\varphi_i) \\dot{a}_j(t) + \\sum_{j=1}^r (\\varphi_j', \\varphi_i') a_j(t) = (f - \\ell_t + \\ell_{xx}, \\varphi_i)\n$$\nThis is a system of $r$ ordinary differential equations (ODEs) for the coefficients $\\mathbf{a}(t) = [a_1(t), \\dots, a_r(t)]^T$. We can write this system in matrix form $\\mathbf{M}\\,\\dot{\\mathbf{a}}(t) + \\mathbf{S}\\,\\mathbf{a}(t) = \\mathbf{F}(t)$, where the entries of the matrices and the vector are:\n-   **Reduced Mass Matrix $\\mathbf{M}$**: $M_{ij} = (\\varphi_j, \\varphi_i)$. Note that the indices are often swapped, but since the inner product is symmetric, $M_{ij}=M_{ji}$.\n-   **Reduced Stiffness Matrix $\\mathbf{S}$**: $S_{ij} = (\\varphi_j', \\varphi_i')$.\n-   **Reduced Forcing Vector $\\mathbf{F}(t)$**: $F_i(t) = (f - \\ell_t + \\ell_{xx}, \\varphi_i)$.\n\nIf the POD basis $\\{\\varphi_i\\}$ is chosen to be orthonormal with respect to the $L^2$ inner product, then $(\\varphi_i, \\varphi_j) = \\delta_{ij}$ (the Kronecker delta). In this case, the mass matrix $\\mathbf{M}$ becomes the identity matrix $\\mathbf{I}$, simplifying the system to $\\dot{\\mathbf{a}}(t) + \\mathbf{S}\\,\\mathbf{a}(t) = \\mathbf{F}(t)$.\n\n**3) Snapshot Computation from a DG Simulation**\n\nIn a Discontinuous Galerkin (DG) simulation, the full-order solution $u_h(x,t)$ is computed at a set of discrete time instances $\\{t_k\\}_{k=1}^{N_s}$, yielding a set of snapshots $\\{u_h(x, t_k)\\}$. The inhomogeneous boundary conditions $u(0,t_k)=g_0(t_k)$ and $u(1,t_k)=g_1(t_k)$ are typically enforced weakly through numerical fluxes at the domain boundaries.\n\nTo generate snapshots for the homogeneous component $\\tilde{u}$, we perform the following steps:\n1.  For each snapshot time $t_k$, construct the corresponding lifting function $\\ell(x, t_k)$ on the same discrete mesh used for the DG simulation. This is a simple evaluation of the known analytical function $\\ell(x,t)$.\n2.  Subtract the lifting function from the full-order DG solution snapshot to obtain the snapshot for the homogeneous component: $\\tilde{u}_h(x, t_k) = u_h(x, t_k) - \\ell(x, t_k)$. By construction, $\\tilde{u}_h(x, t_k)$ will satisfy homogeneous boundary conditions in the same weak sense that $u_h$ satisfies the inhomogeneous ones. The collection $\\{\\tilde{u}_h(x, t_k)\\}_{k=1}^{N_s}$ forms the snapshot ensemble.\n3.  To construct the POD modes, we use the method of snapshots. The goal is to find a basis that is optimal with respect to the energy captured in the snapshots, measured in an appropriate norm. The problem specifies an inner product consistent with the discrete DG mass matrix, $\\mathbf{M}_{DG}$. Let $\\tilde{\\mathbf{u}}_k$ be the vector of degrees of freedom representing the snapshot $\\tilde{u}_h(x, t_k)$. The discrete inner product between two snapshots $\\tilde{u}_h(\\cdot, t_k)$ and $\\tilde{u}_h(\\cdot, t_l)$ is given by $\\tilde{\\mathbf{u}}_k^T \\mathbf{M}_{DG} \\tilde{\\mathbf{u}}_l$.\n4.  The snapshot correlation matrix (or Gramian) $\\mathbf{C}$ is an $N_s \\times N_s$ matrix whose entries are the inner products of the snapshots: $C_{kl} = (\\tilde{u}_h(\\cdot, t_k), \\tilde{u}_h(\\cdot, t_l))_{\\mathrm{DG}} = \\tilde{\\mathbf{u}}_k^T \\mathbf{M}_{DG} \\tilde{\\mathbf{u}}_l$.\n5.  Solve the eigenvalue problem for the correlation matrix: $\\mathbf{C} \\mathbf{v}_i = \\lambda_i \\mathbf{v}_i$, where $\\lambda_i$ are the eigenvalues and $\\mathbf{v}_i$ are the corresponding eigenvectors.\n6.  The $i$-th POD mode $\\varphi_i(x)$ is constructed as a linear combination of the snapshots, with coefficients given by the components of the eigenvector $\\mathbf{v}_i$:\n$$\n\\varphi_i(x) = \\frac{1}{\\sqrt{\\lambda_i}} \\sum_{k=1}^{N_s} (\\mathbf{v}_i)_k \\, \\tilde{u}_h(x, t_k)\n$$\nSince each snapshot $\\tilde{u}_h$ satisfies homogeneous boundary conditions, any linear combination of them, including the POD modes $\\varphi_i$, will also satisfy these conditions. Furthermore, this procedure guarantees that the resulting modes $\\{\\varphi_i\\}$ are orthonormal with respect to the DG-induced inner product: $(\\varphi_i, \\varphi_j)_{\\mathrm{DG}} = \\delta_{ij}$.\n\n**4) Concrete Calculation of the Reduced Forcing Component**\n\nWe are given the specific data:\n-   Boundary data: $g_0(t) = \\sin(t)$, $g_1(t) = 0$.\n-   Source term: $f(x,t) = x$.\n-   Lifting function: $\\ell(x,t) = g_0(t)\\,(1-x) + g_1(t)\\,x = \\sin(t)(1-x)$.\n-   Reduced basis functions: $\\varphi_1(x) = \\sqrt{2}\\,\\sin(\\pi x)$, $\\varphi_2(x) = \\sqrt{2}\\,\\sin(2\\pi x)$.\n\nWe need to compute the first component of the reduced forcing vector, $F_1(t)$, and evaluate it at $t = \\ln(2)$.\nFrom Part 2, the formula is $F_1(t) = (f - \\ell_t + \\ell_{xx}, \\varphi_1)$.\n\nFirst, we compute the derivatives of the lifting function $\\ell(x,t)$:\n$$\n\\ell_t(x,t) = \\frac{\\partial}{\\partial t} [\\sin(t)(1-x)] = (1-x)\\cos(t)\n$$\n$$\n\\ell_x(x,t) = \\frac{\\partial}{\\partial x} [\\sin(t)(1-x)] = -\\sin(t)\n$$\n$$\n\\ell_{xx}(x,t) = \\frac{\\partial}{\\partial x} [-\\sin(t)] = 0\n$$\nThe modified forcing term is:\n$$\nf(x,t) - \\ell_t(x,t) + \\ell_{xx}(x,t) = x - (1-x)\\cos(t)\n$$\nNow we compute the inner product with $\\varphi_1(x)$:\n$$\nF_1(t) = \\int_0^1 \\left( x - (1-x)\\cos(t) \\right) \\sqrt{2}\\,\\sin(\\pi x) \\, dx\n$$\nWe can split the integral:\n$$\nF_1(t) = \\sqrt{2} \\int_0^1 x \\sin(\\pi x) \\, dx - \\sqrt{2} \\cos(t) \\int_0^1 (1-x) \\sin(\\pi x) \\, dx\n$$\nLet's evaluate the two definite integrals. For the first integral, we use integration by parts with $u=x$ and $dv=\\sin(\\pi x)dx$:\n$$\n\\int_0^1 x \\sin(\\pi x) \\, dx = \\left[ -x \\frac{\\cos(\\pi x)}{\\pi} \\right]_0^1 - \\int_0^1 \\left(-\\frac{\\cos(\\pi x)}{\\pi}\\right) dx = -\\frac{1}{\\pi}\\cos(\\pi) + \\frac{1}{\\pi} \\left[ \\frac{\\sin(\\pi x)}{\\pi} \\right]_0^1 = \\frac{1}{\\pi} + 0 = \\frac{1}{\\pi}\n$$\nFor the second integral:\n$$\n\\int_0^1 (1-x) \\sin(\\pi x) \\, dx = \\int_0^1 \\sin(\\pi x) \\, dx - \\int_0^1 x \\sin(\\pi x) \\, dx\n$$\nThe first part is $\\int_0^1 \\sin(\\pi x) dx = \\left[-\\frac{\\cos(\\pi x)}{\\pi}\\right]_0^1 = -\\frac{1}{\\pi}(\\cos(\\pi) - \\cos(0)) = -\\frac{1}{\\pi}(-1 - 1) = \\frac{2}{\\pi}$.\nThe second part we already found to be $\\frac{1}{\\pi}$. So, the second integral is $\\frac{2}{\\pi} - \\frac{1}{\\pi} = \\frac{1}{\\pi}$.\n\nSubstituting these results back into the expression for $F_1(t)$:\n$$\nF_1(t) = \\sqrt{2} \\left( \\frac{1}{\\pi} \\right) - \\sqrt{2} \\cos(t) \\left( \\frac{1}{\\pi} \\right) = \\frac{\\sqrt{2}}{\\pi} (1 - \\cos(t))\n$$\nFinally, we evaluate $F_1(t)$ at $t=\\ln(2)$:\n$$\nF_1(\\ln(2)) = \\frac{\\sqrt{2}}{\\pi} (1 - \\cos(\\ln(2)))\n$$\nThis is the required closed-form analytic expression.", "answer": "$$\n\\boxed{\\frac{\\sqrt{2}}{\\pi} (1 - \\cos(\\ln(2)))}\n$$", "id": "3410807"}, {"introduction": "Our final practice explores an advanced scenario where a naive application of POD can be suboptimal: modeling phenomena with sharp, moving discontinuities like shock waves. A single global basis struggles to efficiently capture both the smooth pre-shock evolution and the complex post-shock dynamics. This computational experiment introduces the concept of time-windowed POD, where separate bases are computed for different phases of the simulation, leading to a more accurate and compact representation of the system's behavior [@problem_id:3410825].", "problem": "Consider the one-dimensional compressible Euler equations for a calorically perfect gas with specific heat ratio $\\gamma = 1.4$ on the spatial domain $x \\in [0,1]$ and time interval $t \\in [0,T]$. The conservative variables are $U = (\\rho, \\rho u, E)^\\top$, where $\\rho$ is density, $u$ is velocity, and $E$ is total energy. The governing equations are\n$$\n\\frac{\\partial U}{\\partial t} + \\frac{\\partial F(U)}{\\partial x} = 0,\n$$\nwhere the flux is\n$$\nF(U) = \n\\begin{pmatrix}\n\\rho u \\\\\n\\rho u^2 + p \\\\\nu (E + p)\n\\end{pmatrix},\n$$\nand the pressure $p$ is given by the equation of state $p = (\\gamma - 1)\\left(E - \\frac{1}{2}\\rho u^2\\right)$.\n\nUse a Discontinuous Galerkin (DG) discretization with polynomial degree $p=0$ (that is, piecewise constant basis per cell), which coincides with a conservative finite volume method. Employ the Harten–Lax–van Leer–Einfeldt (HLLE) approximate Riemann solver for intercell numerical fluxes. Let $N$ be the number of computational cells with uniform cell width $\\Delta x = 1/N$. Use transmissive boundary conditions.\n\nInitialize the flow with a smoothed shock tube profile centered at $x_0 = 0.5$ with smoothing width $w = 0.02$. Let the left state be $(\\rho_L, u_L, p_L) = (1.0, 0.0, 1.0)$ and the right state be $(\\rho_R, u_R, p_R) = (0.125, 0.0, 0.1)$. Define the smooth blending function\n$$\n\\phi(x) = \\frac{1}{2}\\left(1 - \\tanh\\left(\\frac{x - x_0}{w}\\right)\\right),\n$$\nand set the initial conditions\n$$\n\\rho(x,0) = \\phi(x)\\rho_L + (1 - \\phi(x))\\rho_R,\\quad\nu(x,0) = 0,\\quad\np(x,0) = \\phi(x)p_L + (1 - \\phi(x))p_R.\n$$\nIntegrate the system up to a final time $T = 0.2$ using a stable explicit time stepping with a Courant–Friedrichs–Lewy (CFL) number of $0.5$, where the time step $\\Delta t$ satisfies\n$$\n\\Delta t \\le \\mathrm{CFL}\\,\\frac{\\Delta x}{\\max_i \\left(|u_i| + c_i\\right)},\\quad c_i = \\sqrt{\\gamma \\frac{p_i}{\\rho_i}},\n$$\nand record $M=60$ equally spaced snapshots of the density field $\\rho(x,t)$ over $t \\in [0,T]$. Assemble the snapshot matrix $X \\in \\mathbb{R}^{N \\times M}$ whose columns are the nodal density values at each snapshot time.\n\nDefine two time windows: a pre-shock window $W_{\\text{pre}} = \\{t \\in [0, t_{\\text{pre}}]\\}$ and a post-shock window $W_{\\text{post}} = \\{t \\in [t_{\\text{post}}, T]\\}$, with $0  t_{\\text{pre}}  t_{\\text{post}}  T$. For each window, form the windowed snapshot matrices $X_{\\text{pre}}$ and $X_{\\text{post}}$ by selecting the columns of $X$ whose snapshot times lie in the corresponding window.\n\nPerform Proper Orthogonal Decomposition (POD) via Singular Value Decomposition (SVD) on each windowed snapshot matrix. Proper Orthogonal Decomposition (POD) seeks orthonormal spatial modes $\\{\\varphi_i\\}$ that optimally represent the snapshot ensemble in the least-squares sense. Concretely, compute the SVD\n$$\nX_{\\text{win}} = U_{\\text{win}} \\Sigma_{\\text{win}} V_{\\text{win}}^\\top,\n$$\nwhere $U_{\\text{win}} \\in \\mathbb{R}^{N \\times r_{\\max}}$ contains orthonormal columns (spatial POD modes), $\\Sigma_{\\text{win}}$ is diagonal with nonnegative singular values, and $V_{\\text{win}}$ contains temporal coefficients. Let $r$ be a chosen truncation rank, and retain the first $r$ left singular vectors, denoted $\\varphi_i$ for $i = 1,\\dots,r$, with corresponding singular values $\\sigma_i$.\n\nTo quantify discontinuity-induced contamination of POD modes, define a shock-region mask based on a gradient threshold. For a given window, compute the discrete gradient magnitude of density at each snapshot as\n$$\ng_j(t_k) = \\left|\\frac{\\rho_{j+1}(t_k) - \\rho_{j}(t_k)}{\\Delta x}\\right|,\\quad j=1,\\dots,N-1,\n$$\nand define the maximum-in-time gradient at each interface within the window\n$$\nG_j = \\max_{t_k \\in W_{\\text{win}}} g_j(t_k).\n$$\nGiven a gradient threshold $\\tau  0$, define the shock-region mask $\\mathcal{I}_\\tau$ as the set of cell indices whose adjacent interface gradient exceeds the threshold:\n$$\n\\mathcal{I}_\\tau = \\left\\{ i \\in \\{1,\\dots,N\\} \\,\\middle|\\, \\max\\left(G_{i-1}, G_i\\right) \\ge \\tau \\right\\},\n$$\nwith the convention that $G_0 = G_N = 0$.\n\nFor a normalized POD mode $\\varphi_i$ (as output by SVD), define its contamination fraction\n$$\nC_i = \\frac{\\sum_{j \\in \\mathcal{I}_\\tau} \\varphi_i(j)^2}{\\sum_{j=1}^{N} \\varphi_i(j)^2}.\n$$\nDefine the weighted contamination index for the first $r$ modes as\n$$\n\\mathrm{CI}(r,\\tau) = \\frac{\\sum_{i=1}^{r} \\sigma_i^2\\, C_i}{\\sum_{i=1}^{r} \\sigma_i^2},\n$$\nwhere $\\sigma_i$ are the singular values associated with the modes. Compute $\\mathrm{CI}_{\\text{pre}}(r,\\tau)$ and $\\mathrm{CI}_{\\text{post}}(r,\\tau)$ for the two windows, and report the difference\n$$\n\\Delta(r,\\tau) = \\mathrm{CI}_{\\text{post}}(r,\\tau) - \\mathrm{CI}_{\\text{pre}}(r,\\tau).\n$$\n\nImplement the above, and evaluate the following test suite using the fixed discretization parameters $N=200$, $T=0.2$, $\\gamma=1.4$, $M=60$, and CFL$=0.5$:\n\n- Test case 1 (happy path): $(r, \\tau, t_{\\text{pre}}, t_{\\text{post}}) = (5, 50.0, 0.05, 0.12)$.\n- Test case 2 (higher rank): $(r, \\tau, t_{\\text{pre}}, t_{\\text{post}}) = (10, 50.0, 0.05, 0.12)$.\n- Test case 3 (stricter threshold): $(r, \\tau, t_{\\text{pre}}, t_{\\text{post}}) = (5, 80.0, 0.05, 0.12)$.\n- Test case 4 (single mode): $(r, \\tau, t_{\\text{pre}}, t_{\\text{post}}) = (1, 50.0, 0.05, 0.12)$.\n- Test case 5 (lenient threshold and high rank): $(r, \\tau, t_{\\text{pre}}, t_{\\text{post}}) = (20, 30.0, 0.05, 0.12)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases listed above, with each entry being the floating-point value of $\\Delta(r,\\tau)$ for that case (for example, \"[result1,result2,result3,result4,result5]\"). No units are required in the output. Angles do not appear. If any computed window contains fewer than two snapshots or if $r$ exceeds the number of available singular values in that window, adjust $r$ to the maximum available in that window and proceed.", "solution": "The user has provided a well-defined computational problem in the field of fluid dynamics and model order reduction. I will proceed with a detailed breakdown of the solution methodology, followed by the complete implementation.\n\n### Step 1: Problem Validation\n\n**1.1. Extraction of Givens**\n\n- **Governing Equations**: 1D compressible Euler equations, $\\frac{\\partial U}{\\partial t} + \\frac{\\partial F(U)}{\\partial x} = 0$.\n- **State Vector**: $U = (\\rho, \\rho u, E)^\\top$.\n- **Flux Vector**: $F(U) = (\\rho u, \\rho u^2 + p, u (E + p))^\\top$.\n- **Equation of State**: $p = (\\gamma - 1)(E - \\frac{1}{2}\\rho u^2)$ for a calorically perfect gas.\n- **Physical Parameters**: Specific heat ratio $\\gamma = 1.4$.\n- **Domain**: Spatial $x \\in [0,1]$, Temporal $t \\in [0,T]$ with $T=0.2$.\n- **Discretization**: Discontinuous Galerkin (DG) with polynomial degree $p=0$ on $N=200$ uniform cells. Cell width $\\Delta x = 1/N$. This is equivalent to a finite volume method.\n- **Numerical Flux**: Harten–Lax–van Leer–Einfeldt (HLLE) approximate Riemann solver.\n- **Boundary Conditions**: Transmissive.\n- **Initial Conditions**: A smoothed shock tube profile.\n    - Left state $(\\rho_L, u_L, p_L) = (1.0, 0.0, 1.0)$.\n    - Right state $(\\rho_R, u_R, p_R) = (0.125, 0.0, 0.1)$.\n    - Smoothing function: $\\phi(x) = \\frac{1}{2}(1 - \\tanh((x - x_0)/w))$ with center $x_0 = 0.5$ and width $w = 0.02$.\n    - Initial profiles: $\\rho(x,0)$, $u(x,0)$, $p(x,0)$ are weighted averages of left/right states using $\\phi(x)$.\n- **Time Integration**: Explicit, with CFL number $0.5$. Time step $\\Delta t \\le \\mathrm{CFL}\\,\\frac{\\Delta x}{\\max_i (|u_i| + c_i)}$, where $c_i = \\sqrt{\\gamma p_i/\\rho_i}$.\n- **Snapshot Collection**: $M=60$ equally spaced snapshots of the density field $\\rho(x,t)$ over $t \\in [0,T]$.\n- **POD Analysis**:\n    - Snapshot matrix $X \\in \\mathbb{R}^{N \\times M}$.\n    - Time windows: $W_{\\text{pre}} = [0, t_{\\text{pre}}]$ and $W_{\\text{post}} = [t_{\\text{post}}, T]$.\n    - SVD on windowed matrices: $X_{\\text{win}} = U_{\\text{win}} \\Sigma_{\\text{win}} V_{\\text{win}}^\\top$.\n- **Contamination Quantification**:\n    - Shock-region mask $\\mathcal{I}_\\tau$ based on maximum-in-time discrete gradient magnitude $G_j$ and a threshold $\\tau$.\n    - Contamination fraction $C_i$ for each POD mode $\\varphi_i$.\n    - Weighted contamination index $\\mathrm{CI}(r,\\tau) = (\\sum_{i=1}^{r} \\sigma_i^2 C_i) / (\\sum_{i=1}^{r} \\sigma_i^2)$.\n- **Final Output**: The difference $\\Delta(r,\\tau) = \\mathrm{CI}_{\\text{post}}(r,\\tau) - \\mathrm{CI}_{\\text{pre}}(r,\\tau)$.\n- **Test Cases**:\n    1. $(r, \\tau, t_{\\text{pre}}, t_{\\text{post}}) = (5, 50.0, 0.05, 0.12)$\n    2. $(r, \\tau, t_{\\text{pre}}, t_{\\text{post}}) = (10, 50.0, 0.05, 0.12)$\n    3. $(r, \\tau, t_{\\text{pre}}, t_{\\text{post}}) = (5, 80.0, 0.05, 0.12)$\n    4. $(r, \\tau, t_{\\text{pre}}, t_{\\text{post}}) = (1, 50.0, 0.05, 0.12)$\n    5. $(r, \\tau, t_{\\text{pre}}, t_{\\text{post}}) = (20, 30.0, 0.05, 0.12)$\n- **Special Rule**: If $r$ exceeds the number of available singular values in a window, $r$ must be adjusted to the maximum available for that window.\n\n**1.2. Validation and Verdict**\n\nThe problem is scientifically grounded, well-posed, and objective. It describes a standard numerical experiment in computational fluid dynamics and reduced-order modeling.\n- **Scientific Soundness**: The Euler equations, equation of state, and the use of a conservative numerical scheme (DG p=0/FVM) with an HLLE solver are standard and physically correct for modeling inviscid compressible flow. The Sod shock tube is a canonical benchmark problem.\n- **Well-Posedness**: The problem is well-posed. The initial conditions are specified, boundary conditions are defined, and the numerical method is complete. The parameters for discretization, time-stepping (CFL condition), and analysis are all provided, leading to a unique, computable solution.\n- **Objectivity and Clarity**: The problem is stated in precise mathematical and algorithmic terms. All quantities, including the custom \"contamination index,\" are defined through unambiguous formulas.\n\nThe problem does not violate any of the invalidity criteria. It is a complex, multi-step computational task that is verifiable and formalizable.\n\n**Verdict: The problem is valid.**\n\n### Step 2: Solution Design\n\nThe solution will be implemented in Python using the `numpy` library. The overall process is divided into three main parts:\n1.  **Numerical Simulation**: A finite volume solver for the 1D Euler equations is developed. This solver uses the HLLE approximate Riemann solver for numerical fluxes and an explicit forward Euler time integration scheme stabilized by a CFL condition.\n2.  **Data Collection**: The simulation is run from $t=0$ to $t=T$, and snapshots of the density field are collected at $M$ equally spaced time intervals.\n3.  **POD and Contamination Analysis**: For each test case, the snapshot data is partitioned into pre-shock and post-shock windows. Proper Orthogonal Decomposition (POD) via Singular Value Decomposition (SVD) is performed on each windowed dataset. A shock-region mask is computed based on a gradient threshold, and this mask is used to calculate the weighted contamination index for each window. The final result is the difference between the post-shock and pre-shock contamination indices.\n\n**Part 1: Finite Volume Solver**\n\nThe state of the system is represented by a `numpy` array `U` of shape `(3, N)`, where `N` is the number of cells and the first dimension corresponds to the conservative variables $(\\rho, \\rho u, E)$.\n\n- **Initial Conditions**: At $t=0$, the primitive variables $(\\rho, u, p)$ are calculated at each cell center using the given smoothed profile. These are then converted to the conservative state vector $U$.\n- **Time Stepping**: The main loop advances time from $t=0$ to $t=T$. In each step:\n    1.  The maximum wave speed over all cells, $\\lambda_{\\max} = \\max_i(|u_i| + c_i)$, is computed.\n    2.  A stable time step $\\Delta t$ is calculated using the CFL condition. To ensure snapshots are captured exactly, $\\Delta t$ is adjusted if the next time step would cross a scheduled snapshot time.\n    3.  **Boundary Conditions**: Transmissive boundary conditions are implemented by creating two ghost cells at each end of the domain, with their states copied from the adjacent interior cell.\n    4.  **Numerical Flux**: The HLLE flux, $F^*_{HLLE}$, is computed at each of the $N+1$ cell interfaces. The states for the left ($U_L$) and right ($U_R$) side of an interface are taken from the corresponding cells (or ghost cells). The HLLE flux is calculated as:\n        $$ F_{HLLE}(U_L, U_R) = \\frac{ S_R F(U_L) - S_L F(U_R) + S_L S_R (U_R - U_L) }{ S_R - S_L } $$\n        if $S_L  0  S_R$. If $S_L \\ge 0$, the flux is $F(U_L)$; if $S_R \\le 0$, the flux is $F(U_R)$. The signal speeds $S_L$ and $S_R$ are estimated based on the minimum and maximum wave speeds from the left and right states: $S_L = \\min(u_L - c_L, u_R - c_R)$ and $S_R = \\max(u_L + c_L, u_R + c_R)$.\n    5.  **State Update**: The conservative state in each cell $i$ is updated using the finite volume formula:\n        $$ U_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x} (F^*_{i+1/2} - F^*_{i-1/2}) $$\n\n**Part 2: Snapshot and Analysis**\n\n- **Snapshot Matrix**: A matrix $X$ of shape $(N, M)$ is pre-allocated. During the simulation, whenever the current time $t$ matches a snapshot time, the density vector $\\rho$ (the first component of the state vector $U$) is extracted and stored as a column in $X$.\n- **Windowing**: For each test case, the columns of $X$ corresponding to the pre-shock time window $[0, t_{\\text{pre}}]$ and post-shock time window $[t_{\\text{post}}, T]$ are extracted to form matrices $X_{\\text{pre}}$ and $X_{\\text{post}}$.\n- **POD via SVD**: The `numpy.linalg.svd` function is applied to each windowed matrix, $X_{\\text{win}} = U_{\\text{win}} \\Sigma_{\\text{win}} V_{\\text{win}}^\\top$. The columns of $U_{\\text{win}}$ are the spatial POD modes ($\\varphi_i$), and the diagonal entries of $\\Sigma_{\\text{win}}$ are the singular values ($\\sigma_i$). In accordance with the problem, the rank $r$ for analysis is adjusted to be no more than the number of snapshots in the window: $r_{\\text{eff}} = \\min(r_{\\text{requested}}, \\text{num\\_snapshots})$.\n- **Contamination Index Calculation**:\n    1.  **Gradient Calculation**: For each window, the discrete density gradient is computed for all snapshots. The maximum gradient magnitude across time is found for each cell interface, yielding a vector $G$ of size $N-1$.\n    2.  **Shock-Region Mask**: For a given threshold $\\tau$, a boolean mask is created. A cell $i$ is flagged as part of the shock region if the maximum gradient $G$ at either of its adjacent interfaces exceeds $\\tau$.\n    3.  **Contamination Fraction**: For each of the first $r_{\\text{eff}}$ POD modes $\\varphi_i$, the contamination fraction $C_i$ is computed as the sum of squares of its components within the shock region. Since the modes from SVD are normalized, this is simply $\\sum_{j \\in \\mathcal{I}_\\tau} \\varphi_i(j)^2$.\n    4.  **Weighted Index**: The contamination index for the window, $\\mathrm{CI}(r, \\tau)$, is computed by averaging the fractions $C_i$, weighted by the corresponding squared singular values $\\sigma_i^2$.\n- **Final Result**: The difference $\\Delta = \\mathrm{CI}_{\\text{post}} - \\mathrm{CI}_{\\text{pre}}$ is computed and stored for each test case. The final output is a list of these delta values.\n\nThis structured approach ensures all requirements of the problem are met, including the specific numerical methods, data analysis procedures, and handling of special conditions.", "answer": "```python\nimport numpy as np\n\ndef get_primitive_from_conservative(U, gamma):\n    \"\"\"Converts conservative variables to primitive variables.\"\"\"\n    rho = U[0, :]\n    rhou = U[1, :]\n    E = U[2, :]\n    u = rhou / rho\n    p = (gamma - 1.0) * (E - 0.5 * rhou**2 / rho)\n    return rho, u, p\n\ndef get_conservative_from_primitive(rho, u, p, gamma):\n    \"\"\"Converts primitive variables to conservative variables.\"\"\"\n    U = np.zeros((3, len(rho)))\n    U[0, :] = rho\n    U[1, :] = rho * u\n    U[2, :] = p / (gamma - 1.0) + 0.5 * rho * u**2\n    return U\n\ndef get_flux(U, gamma):\n    \"\"\"Computes the physical flux F(U).\"\"\"\n    rho, u, p = get_primitive_from_conservative(U, gamma)\n    flux = np.zeros_like(U)\n    flux[0, :] = rho * u\n    flux[1, :] = rho * u**2 + p\n    flux[2, :] = u * (U[2, :] + p)\n    return flux\n\ndef get_hlle_flux(UL, UR, gamma):\n    \"\"\"Computes the HLLE approximate Riemann solver flux.\"\"\"\n    rho_L, u_L, p_L = get_primitive_from_conservative(UL.reshape(3, 1), gamma)\n    rho_R, u_R, p_R = get_primitive_from_conservative(UR.reshape(3, 1), gamma)\n\n    c_L = np.sqrt(gamma * p_L / rho_L)\n    c_R = np.sqrt(gamma * p_R / rho_R)\n\n    s_L = min(u_L - c_L, u_R - c_R)[0]\n    s_R = max(u_L + c_L, u_R + c_R)[0]\n\n    flux_L = get_flux(UL.reshape(3, 1), gamma)\n    flux_R = get_flux(UR.reshape(3, 1), gamma)\n\n    if s_L >= 0.0:\n        return flux_L.flatten()\n    elif s_R = 0.0:\n        return flux_R.flatten()\n    else:\n        num = s_R * flux_L - s_L * flux_R + s_L * s_R * (UR.reshape(3, 1) - UL.reshape(3, 1))\n        den = s_R - s_L\n        return (num / den).flatten()\n\ndef run_simulation(N, T, M, CFL, gamma):\n    \"\"\"Runs the 1D Euler simulation and collects density snapshots.\"\"\"\n    dx = 1.0 / N\n    x = (np.arange(N) + 0.5) * dx\n    \n    # Initial conditions\n    rho_L, u_L, p_L = 1.0, 0.0, 1.0\n    rho_R, u_R, p_R = 0.125, 0.0, 0.1\n    x0, w = 0.5, 0.02\n    \n    phi = 0.5 * (1.0 - np.tanh((x - x0) / w))\n    rho0 = phi * rho_L + (1.0 - phi) * rho_R\n    u0 = phi * u_L + (1.0 - phi) * u_R\n    p0 = phi * p_L + (1.0 - phi) * p_R\n    \n    U = get_conservative_from_primitive(rho0, u0, p0, gamma)\n    \n    t_snapshots = np.linspace(0, T, M)\n    snapshots = np.zeros((N, M))\n    snapshots[:, 0] = U[0, :].copy()\n    \n    t = 0.0\n    snapshot_idx = 1\n    \n    while t  T:\n        rho, u, p = get_primitive_from_conservative(U, gamma)\n        c = np.sqrt(gamma * p / rho)\n        max_speed = np.max(np.abs(u) + c)\n        \n        dt = CFL * dx / max_speed\n        \n        if snapshot_idx  M and t + dt >= t_snapshots[snapshot_idx]:\n            dt = t_snapshots[snapshot_idx] - t\n        elif t + dt > T:\n            dt = T - t\n\n        U_ext = np.zeros((3, N + 2))\n        U_ext[:, 1:-1] = U\n        U_ext[:, 0] = U[:, 0] # Transmissive BC\n        U_ext[:, -1] = U[:, -1] # Transmissive BC\n        \n        fluxes = np.zeros((3, N + 1))\n        for i in range(N + 1):\n            fluxes[:, i] = get_hlle_flux(U_ext[:, i], U_ext[:, i+1], gamma)\n            \n        U_update = -(dt / dx) * (fluxes[:, 1:] - fluxes[:, :-1])\n        U += U_update\n        \n        t += dt\n\n        if snapshot_idx  M and np.isclose(t, t_snapshots[snapshot_idx]):\n            snapshots[:, snapshot_idx] = U[0, :].copy()\n            snapshot_idx += 1\n            \n    return snapshots, t_snapshots\n\ndef calculate_ci(X_win, r_req, tau, dx, N):\n    \"\"\"Calculates the weighted contamination index for a given window.\"\"\"\n    num_snapshots = X_win.shape[1]\n    if num_snapshots  2: # As per problem, though my settings avoid this.\n        return 0.0\n\n    r = min(r_req, num_snapshots)\n    \n    # SVD for POD modes\n    try:\n        U, s, Vt = np.linalg.svd(X_win, full_matrices=False)\n    except np.linalg.LinAlgError:\n        return 0.0\n\n    # Calculate max-in-time gradient\n    grads = np.abs((X_win[1:, :] - X_win[:-1, :]) / dx)\n    G = np.max(grads, axis=1) # Shape (N-1)\n    \n    # Create shock-region mask\n    mask = np.zeros(N, dtype=bool)\n    if N > 1:\n        mask[0] = G[0] >= tau\n        mask[-1] = G[-2] >= tau\n        if N > 2:\n            mask[1:-1] = (G[:-1] >= tau) | (G[1:] >= tau)\n    \n    mask_indices = np.where(mask)[0]\n\n    # Calculate contamination fractions\n    C_vec = np.zeros(r)\n    modes = U[:, :r]\n    if mask_indices.size > 0:\n        components_in_mask = modes[mask_indices, :]\n        C_vec = np.sum(components_in_mask**2, axis=0) # Denominator (norm^2) is 1.0\n\n    # Calculate weighted contamination index\n    sigmas_sq = s[:r]**2\n    numerator = np.sum(sigmas_sq * C_vec)\n    denominator = np.sum(sigmas_sq)\n\n    if denominator == 0.0:\n        return 0.0\n        \n    return numerator / denominator\n\ndef solve():\n    # Fixed parameters\n    N = 200\n    T = 0.2\n    gamma = 1.4\n    M = 60\n    CFL = 0.5\n    dx = 1.0 / N\n\n    # Run simulation once to generate all snapshots\n    X, t_snapshots = run_simulation(N, T, M, CFL, gamma)\n\n    test_cases = [\n        (5, 50.0, 0.05, 0.12),\n        (10, 50.0, 0.05, 0.12),\n        (5, 80.0, 0.05, 0.12),\n        (1, 50.0, 0.05, 0.12),\n        (20, 30.0, 0.05, 0.12),\n    ]\n\n    results = []\n    for r_req, tau, t_pre, t_post in test_cases:\n        # Pre-shock window\n        pre_indices = np.where(t_snapshots = t_pre)[0]\n        X_pre = X[:, pre_indices]\n        ci_pre = calculate_ci(X_pre, r_req, tau, dx, N)\n        \n        # Post-shock window\n        post_indices = np.where(t_snapshots >= t_post)[0]\n        X_post = X[:, post_indices]\n        ci_post = calculate_ci(X_post, r_req, tau, dx, N)\n        \n        delta = ci_post - ci_pre\n        results.append(delta)\n\n    # Format output as specified\n    print(f\"[{','.join(f'{res:.10f}' for res in results)}]\")\n\nsolve()\n```", "id": "3410825"}]}