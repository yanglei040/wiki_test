{"hands_on_practices": [{"introduction": "This first exercise provides a foundational, analytical look into a defining characteristic of the spectral Tau method. By working through this problem, you will uncover how the enforcement of exact boundary conditions \"contaminates\" the highest-order spectral coefficients of the solution. Understanding this mechanism is fundamental to correctly interpreting the results of a Tau approximation and appreciating its unique properties compared to other spectral methods [@problem_id:3419545].", "problem": "Consider the Spectral Tau method (also known as the Tau method in spectral approximations) for a scalar boundary-value problem posed on the interval $[-1,1]$ using the Legendre polynomial basis $\\{P_{n}(x)\\}_{n=0}^{\\infty}$. Let the target function be the analytic function\n$$\nu(x) \\;=\\; \\frac{1}{\\sqrt{\\,1 \\;-\\; 2 t x \\;+\\; t^{2}\\,}},\n$$\nwith a real parameter $t$ satisfying $|t|<1$. The identity operator $L u = u$ is used so that the interior residual equation is $u_{N}(x) \\approx u(x)$ in the Legendre-weighted sense, while nonhomogeneous Dirichlet boundary conditions $u(-1)=A$ and $u(1)=B$ are enforced exactly via two Tau rows. The Spectral Tau approximation is sought in the form\n$$\nu_{N}(x) \\;=\\; \\sum_{n=0}^{N} a_{n}^{(N)}\\,P_{n}(x).\n$$\nThe Tau discretization proceeds by enforcing the weighted residual conditions\n$$\n\\int_{-1}^{1} P_{n}(x)\\,\\big(u_{N}(x) - u(x)\\big)\\,dx \\;=\\; 0,\\quad n=0,1,\\dots,N-2,\n$$\nand replacing the last two equations by the nonhomogeneous boundary conditions\n$$\nu_{N}(-1) \\;=\\; u(-1),\\qquad u_{N}(1) \\;=\\; u(1).\n$$\nThis construction makes the top two coefficients $a_{N-1}^{(N)}$ and $a_{N}^{(N)}$ deviate from the true Legendre coefficients of $u$ in order to enforce the boundary values; this is the boundary-data contamination induced by the Tau rows. Using only first principles about orthogonality of Legendre polynomials and the endpoint values $P_{n}(\\pm 1)$, determine closed-form expressions for the contaminated coefficients $a_{N-1}^{(N)}$ and $a_{N}^{(N)}$ as functions of $t$ and $N$. Your final answers must be analytic expressions, and no rounding is required. In addition, from these expressions, infer whether the contaminated modes decay or grow with increasing $N$, but ensure your submitted final answer contains only the expressions for $a_{N-1}^{(N)}$ and $a_{N}^{(N)}$.", "solution": "The problem asks for the determination of the two highest-degree coefficients, $a_{N-1}^{(N)}$ and $a_N^{(N)}$, in a Spectral Tau approximation of a given function $u(x)$. The approximation $u_N(x)$ is constructed to satisfy a set of weighted residual equations and two boundary conditions exactly.\n\nThe target function is given by\n$$u(x) = \\frac{1}{\\sqrt{1 - 2tx + t^2}}, \\quad |t|<1.$$\nThis function is the generating function for the Legendre polynomials, $P_n(x)$. Its expansion in the Legendre basis is known to be\n$$u(x) = \\sum_{n=0}^{\\infty} t^n P_n(x).$$\nThe true Legendre coefficients of $u(x)$, which we may denote as $c_n$, are therefore given by $c_n = t^n$.\n\nThe Spectral Tau approximation is sought in the form\n$$u_N(x) = \\sum_{n=0}^{N} a_n^{(N)} P_n(x).$$\nThe coefficients $a_n^{(N)}$ are determined by a system of $N+1$ linear equations. For $n=0, 1, \\dots, N-2$, the equations are given by the weighted residual conditions:\n$$\\int_{-1}^{1} P_n(x) \\big(u_N(x) - u(x)\\big) dx = 0.$$\nLet's substitute the series expansions for $u_N(x)$ and $u(x)$ into this integral expression:\n$$\\int_{-1}^{1} P_n(x) \\left( \\sum_{k=0}^{N} a_k^{(N)} P_k(x) - \\sum_{k=0}^{\\infty} t^k P_k(x) \\right) dx = 0.$$\nDue to the orthogonality property of Legendre polynomials, $\\int_{-1}^{1} P_n(x) P_k(x) dx = \\frac{2}{2n+1}\\delta_{nk}$, where $\\delta_{nk}$ is the Kronecker delta, the integral simplifies significantly. For a given $n \\in \\{0, 1, \\dots, N-2\\}$, the integral picks out only the terms where $k=n$:\n$$a_n^{(N)} \\int_{-1}^{1} P_n(x)^2 dx - t^n \\int_{-1}^{1} P_n(x)^2 dx = 0.$$\nThis simplifies to $(a_n^{(N)} - t^n) \\frac{2}{2n+1} = 0$, which implies\n$$a_n^{(N)} = t^n \\quad \\text{for } n = 0, 1, \\dots, N-2.$$\nThus, the lower-order coefficients of the Tau approximation are identical to the true Legendre coefficients of the function $u(x)$. The \"contamination\" from enforcing the boundary conditions affects only the coefficients not constrained by orthogonality, namely $a_{N-1}^{(N)}$ and $a_N^{(N)}$.\n\nTo find these two remaining coefficients, we use the two boundary conditions, which are enforced exactly:\n$$u_N(-1) = u(-1) \\quad \\text{and} \\quad u_N(1) = u(1).$$\nWe first evaluate the true function $u(x)$ at the boundaries $x=\\pm 1$:\n$$u(1) = \\frac{1}{\\sqrt{1 - 2t + t^2}} = \\frac{1}{\\sqrt{(1-t)^2}} = \\frac{1}{|1-t|} = \\frac{1}{1-t}, \\quad \\text{since } |t|<1.$$\n$$u(-1) = \\frac{1}{\\sqrt{1 + 2t + t^2}} = \\frac{1}{\\sqrt{(1+t)^2}} = \\frac{1}{|1+t|} = \\frac{1}{1+t}, \\quad \\text{since } |t|<1.$$\nNext, we evaluate the approximation $u_N(x)$ at the boundaries, using the known properties $P_n(1)=1$ and $P_n(-1)=(-1)^n$:\n$$u_N(1) = \\sum_{n=0}^{N} a_n^{(N)} P_n(1) = \\sum_{n=0}^{N} a_n^{(N)}.$$\n$$u_N(-1) = \\sum_{n=0}^{N} a_n^{(N)} P_n(-1) = \\sum_{n=0}^{N} a_n^{(N)} (-1)^n.$$\nEquating the approximation to the true function at the boundaries gives the system:\n1.  $\\sum_{n=0}^{N} a_n^{(N)} = u(1) = \\frac{1}{1-t} = \\sum_{n=0}^{\\infty} t^n$.\n2.  $\\sum_{n=0}^{N} a_n^{(N)} (-1)^n = u(-1) = \\frac{1}{1+t} = \\sum_{n=0}^{\\infty} (-t)^n$.\n\nLet's expand the sums for the Tau approximation, substituting $a_n^{(N)} = t^n$ for $n \\le N-2$:\n1.  $\\sum_{n=0}^{N-2} t^n + a_{N-1}^{(N)} + a_N^{(N)} = \\sum_{n=0}^{\\infty} t^n = \\sum_{n=0}^{N-2} t^n + \\sum_{n=N-1}^{\\infty} t^n$.\n    Subtracting the common partial sum from both sides yields:\n    $$a_{N-1}^{(N)} + a_N^{(N)} = \\sum_{n=N-1}^{\\infty} t^n = t^{N-1} + t^N + t^{N+1} + \\dots$$\n    This is a geometric series with first term $t^{N-1}$ and ratio $t$. Its sum is $\\frac{t^{N-1}}{1-t}$.\n    So, our first equation is: $a_{N-1}^{(N)} + a_N^{(N)} = \\frac{t^{N-1}}{1-t}$.\n\n2.  $\\sum_{n=0}^{N-2} t^n (-1)^n + a_{N-1}^{(N)} (-1)^{N-1} + a_N^{(N)} (-1)^N = \\sum_{n=0}^{\\infty} (-t)^n = \\sum_{n=0}^{N-2} (-t)^n + \\sum_{n=N-1}^{\\infty} (-t)^n$.\n    Subtracting the common partial sum from both sides yields:\n    $$a_{N-1}^{(N)} (-1)^{N-1} + a_N^{(N)} (-1)^N = \\sum_{n=N-1}^{\\infty} (-t)^n = \\frac{(-t)^{N-1}}{1-(-t)} = \\frac{(-1)^{N-1} t^{N-1}}{1+t}.$$\n    Dividing the entire equation by $(-1)^{N-1}$ gives:\n    $$a_{N-1}^{(N)} - a_N^{(N)} = \\frac{t^{N-1}}{1+t}.$$\n\nWe now have a $2 \\times 2$ linear system for $a_{N-1}^{(N)}$ and $a_N^{(N)}$:\n$$\n\\begin{cases}\n    a_{N-1}^{(N)} + a_N^{(N)} = \\frac{t^{N-1}}{1-t} \\\\\n    a_{N-1}^{(N)} - a_N^{(N)} = \\frac{t^{N-1}}{1+t}\n\\end{cases}\n$$\nTo solve for $a_{N-1}^{(N)}$, we add the two equations:\n$$2 a_{N-1}^{(N)} = \\frac{t^{N-1}}{1-t} + \\frac{t^{N-1}}{1+t} = t^{N-1} \\left( \\frac{(1+t) + (1-t)}{(1-t)(1+t)} \\right) = t^{N-1} \\left( \\frac{2}{1-t^2} \\right).$$\n$$a_{N-1}^{(N)} = \\frac{t^{N-1}}{1-t^2}.$$\nTo solve for $a_N^{(N)}$, we subtract the second equation from the first:\n$$2 a_N^{(N)} = \\frac{t^{N-1}}{1-t} - \\frac{t^{N-1}}{1+t} = t^{N-1} \\left( \\frac{(1+t) - (1-t)}{(1-t)(1+t)} \\right) = t^{N-1} \\left( \\frac{2t}{1-t^2} \\right).$$\n$$a_N^{(N)} = \\frac{t^N}{1-t^2}.$$\nThese are the closed-form expressions for the contaminated coefficients. The true coefficients are $c_{N-1} = t^{N-1}$ and $c_N = t^N$. The contamination manifests as a multiplicative factor of $\\frac{1}{1-t^2}$, which is constant with respect to $N$.\n\nRegarding the behavior for large $N$: since $|t|<1$, the terms $|t|^{N-1}$ and $|t|^N$ both decay to zero as $N \\to \\infty$. Therefore, the contaminated coefficients $a_{N-1}^{(N)}$ and $a_N^{(N)}$ decay to zero, ensuring convergence of the spectral approximation's coefficients.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{t^{N-1}}{1-t^2} & \\frac{t^N}{1-t^2}\n\\end{pmatrix}\n}\n$$", "id": "3419545"}, {"introduction": "Moving from pure theory to computational practice, this exercise challenges you to implement a Legendre-Tau method and investigate its performance under non-ideal conditions. You will explore the method's robustness when the forcing term of a differential equation lacks smoothness, a common scenario in many physical and engineering applications. This practice will build your skills in constructing a Tau solver and analyzing how the method's accuracy and the behavior of its \"Tau multipliers\" are affected by the regularity of the problem data [@problem_id:3419498].", "problem": "Consider the one-dimensional Legendre Sturm–Liouville operator defined on the interval $[-1,1]$ by\n$$\\mathcal{L} u(x) = -\\frac{\\mathrm{d}}{\\mathrm{d}x}\\left((1-x^2)\\frac{\\mathrm{d}u}{\\mathrm{d}x}(x)\\right) + \\alpha\\,u(x),$$\nwith a fixed positive constant $\\alpha>0$. The Legendre polynomials $P_n(x)$ are eigenfunctions of $\\mathcal{L}$, satisfying\n$$\\mathcal{L} P_n(x) = \\lambda_n P_n(x),\\quad \\lambda_n = n(n+1)+\\alpha,\\quad n=0,1,2,\\ldots.$$\nWe consider the boundary value problem\n$$\\mathcal{L}u(x) = f(x),\\quad x\\in(-1,1),\\qquad u(-1)=0,\\quad u(1)=0,$$\nand approximate $u$ using the spectral Tau method with a truncated Legendre expansion\n$$u_N(x) = \\sum_{n=0}^N a_n P_n(x).$$\nLet $f$ be expanded in Legendre polynomials as $f(x)=\\sum_{n=0}^\\infty b_n P_n(x)$, and model rough right-hand sides $f \\in H^{-1+\\delta}(-1,1)$ by choosing\n$$b_n = (n+1)^{-1+\\delta},\\quad n\\ge 0,$$\nfor small positive $\\delta$ (so that $f$ is borderline near $H^{-1}$ as $\\delta\\to 0^+$). For fixed truncation $N$, the spectral Tau method with Dirichlet boundary conditions enforces the differential equation in the first $N-1$ Legendre modes and replaces the last two modal equations by the two boundary conditions. Specifically, for $n=0,1,\\ldots,N-2$,\n$$\\lambda_n a_n = b_n,$$\nand the coefficients $a_{N-1},a_N$ are determined by imposing\n$$u_N(-1)=\\sum_{n=0}^N a_n P_n(-1)=0,\\qquad u_N(1)=\\sum_{n=0}^N a_n P_n(1)=0,$$\nusing $P_n(1)=1$ and $P_n(-1)=(-1)^n$. The Tau multipliers associated with the top two modes are the residuals in those modes,\n$$\\tau_{N-1} = \\lambda_{N-1} a_{N-1} - b_{N-1},\\qquad \\tau_N = \\lambda_N a_N - b_N.$$\nThe goal is to quantify robustness of the spectral Tau method when $f$ is rough by tracking how the Tau multipliers and the top coefficients behave as $\\delta\\to 0^+$.\n\nYour task is to implement a program that, for a given set of test cases $(N,\\alpha,\\delta)$, constructs the Tau solution $u_N$ as above, computes the top two coefficients $a_{N-1}$ and $a_N$, and computes the normalized Tau multipliers $\\tau_{N-1}/\\lambda_{N-1}$ and $\\tau_{N}/\\lambda_{N}$. Report the absolute values of these four quantities for each test case:\n- $\\left|\\tau_{N-1}/\\lambda_{N-1}\\right|$,\n- $\\left|\\tau_{N}/\\lambda_{N}\\right|$,\n- $\\left|a_{N-1}\\right|$,\n- $\\left|a_{N}\\right|$.\n\nStart from the fundamental properties of Legendre polynomials and the spectral Tau method as described. Do not use pre-derived shortcut formulas beyond what follows from these properties. Design the algorithm to compute $a_n$ for $n=0,\\ldots,N-2$ directly from the enforced modal equations and then solve the two boundary constraints for $a_{N-1},a_N$.\n\nTest suite:\n- Use the constant $\\alpha=1$ in all tests.\n- Use the following test cases $(N,\\alpha,\\delta)$:\n  1. $(64,1,0.4)$,\n  2. $(64,1,0.1)$,\n  3. $(64,1,0.01)$,\n  4. $(64,1,10^{-6})$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list of the four-tuples, enclosed in square brackets. Each test case’s result must be the list\n$$\\left[\\left|\\tau_{N-1}/\\lambda_{N-1}\\right|,\\left|\\tau_{N}/\\lambda_{N}\\right|,\\left|a_{N-1}\\right|,\\left|a_N\\right|\\right].$$\n- For example, the output should have the form\n$$\\left[\\left[r_{11},r_{12},r_{13},r_{14}\\right],\\left[r_{21},r_{22},r_{23},r_{24}\\right],\\left[r_{31},r_{32},r_{33},r_{34}\\right],\\left[r_{41},r_{42},r_{43},r_{44}\\right]\\right],$$\nwhere each $r_{ij}$ is a floating-point number.", "solution": "The problem requires the computation of the top two spectral coefficients and the corresponding normalized Tau multipliers for a Legendre-based spectral Tau method applied to a one-dimensional Sturm–Liouville problem. The solution involves deriving and solving a system of equations for these coefficients based on the imposed boundary conditions.\n\nThe Legendre-based spectral Tau method for the boundary value problem\n$$ \\mathcal{L}u(x) = f(x),\\quad x\\in(-1,1),\\qquad u(-1)=0,\\quad u(1)=0, $$\nwhere $\\mathcal{L} u(x) = -((1-x^2)u'(x))' + \\alpha u(x)$, approximates the solution $u(x)$ by a truncated Legendre series\n$$ u_N(x) = \\sum_{n=0}^N a_n P_n(x). $$\nThe forcing function $f(x)$ is represented by its Legendre series $f(x) = \\sum_{n=0}^\\infty b_n P_n(x)$.\n\nThe core of the spectral Tau method is to project the differential equation onto a set of test functions, which in this case are the Legendre polynomials $P_n(x)$ for $n=0, 1, \\ldots, N-2$. The final two degrees of freedom are used to enforce the boundary conditions.\n\nThe operator $\\mathcal{L}$ is diagonal in the Legendre basis, with $\\mathcal{L}P_n(x) = \\lambda_n P_n(x)$ where $\\lambda_n = n(n+1)+\\alpha$. Applying the operator to the truncated series gives\n$$ \\mathcal{L}u_N(x) = \\sum_{n=0}^N a_n \\mathcal{L}P_n(x) = \\sum_{n=0}^N a_n \\lambda_n P_n(x). $$\nThe residual of the differential equation is\n$$ R_N(x) = \\mathcal{L}u_N(x) - f(x) = \\sum_{n=0}^N (\\lambda_n a_n - b_n) P_n(x) - \\sum_{n=N+1}^\\infty b_n P_n(x). $$\nThe methodology enforces that the residual is orthogonal to the first $N-1$ Legendre polynomials:\n$$ \\int_{-1}^1 R_N(x) P_n(x) w(x) \\mathrm{d}x = 0 \\quad \\text{for } n=0, 1, \\ldots, N-2, $$\nwhere $w(x)=1$ is the weight function for Legendre polynomials. Due to orthogonality, this simplifies to\n$$ \\lambda_n a_n - b_n = 0 \\implies a_n = \\frac{b_n}{\\lambda_n} \\quad \\text{for } n=0, 1, \\ldots, N-2. $$\nThe problem provides the model for the coefficients of the right-hand side $f(x)$ as $b_n = (n+1)^{-1+\\delta}$ for $n \\ge 0$. Thus, for the lower-order modes, we have\n$$ a_n = \\frac{(n+1)^{-1+\\delta}}{n(n+1)+\\alpha} \\quad \\text{for } n=0, 1, \\ldots, N-2. $$\nThese $N-1$ coefficients can be computed directly.\n\nThe remaining two coefficients, $a_{N-1}$ and $a_N$, are determined by the two boundary conditions, $u_N(1)=0$ and $u_N(-1)=0$. Using the known properties of Legendre polynomials, $P_n(1)=1$ and $P_n(-1)=(-1)^n$, the boundary conditions become:\n$$ u_N(1) = \\sum_{n=0}^N a_n P_n(1) = \\sum_{n=0}^N a_n = 0 $$\n$$ u_N(-1) = \\sum_{n=0}^N a_n P_n(-1) = \\sum_{n=0}^N (-1)^n a_n = 0 $$\nWe can separate the known and unknown parts of these sums:\n$$ \\left( \\sum_{n=0}^{N-2} a_n \\right) + a_{N-1} + a_N = 0 $$\n$$ \\left( \\sum_{n=0}^{N-2} (-1)^n a_n \\right) + (-1)^{N-1}a_{N-1} + (-1)^N a_N = 0 $$\nLet's define the known summations as $S_1$ and $S_{-1}$:\n$$ S_1 = \\sum_{n=0}^{N-2} a_n = \\sum_{n=0}^{N-2} \\frac{(n+1)^{-1+\\delta}}{n(n+1)+\\alpha} $$\n$$ S_{-1} = \\sum_{n=0}^{N-2} (-1)^n a_n = \\sum_{n=0}^{N-2} (-1)^n \\frac{(n+1)^{-1+\\delta}}{n(n+1)+\\alpha} $$\nThe system for $a_{N-1}$ and $a_N$ is then:\n$$ \\begin{cases} a_{N-1} + a_N = -S_1 \\\\ (-1)^{N-1}a_{N-1} + (-1)^N a_N = -S_{-1} \\end{cases} $$\nMultiplying the second equation by $(-1)^{N-1}$ gives $a_{N-1} - a_N = -(-1)^{-(N-1)}S_{-1} = (-1)^N S_{-1}$. The system is:\n$$ \\begin{cases} a_{N-1} + a_N = -S_1 \\\\ a_{N-1} - a_N = (-1)^N S_{-1} \\end{cases} $$\nThis is a simple $2 \\times 2$ linear system. Adding the two equations yields $2a_{N-1} = -S_1 + (-1)^N S_{-1}$, and subtracting the second from the first yields $2a_N = -S_1 - (-1)^N S_{-1}$. The solutions are:\n$$ a_{N-1} = \\frac{1}{2} \\left( -S_1 + (-1)^N S_{-1} \\right) $$\n$$ a_N = \\frac{1}{2} \\left( -S_1 - (-1)^N S_{-1} \\right) $$\nThese formulas allow for the direct computation of $a_{N-1}$ and $a_N$ once $S_1$ and $S_{-1}$ are calculated.\n\nThe Tau multipliers are defined as the residuals in the modes corresponding to the boundary conditions:\n$$ \\tau_{N-1} = \\lambda_{N-1} a_{N-1} - b_{N-1} $$\n$$ \\tau_N = \\lambda_N a_N - b_N $$\nThe problem asks for the normalized Tau multipliers, $\\tau_{n}/\\lambda_{n}$, which are given by:\n$$ \\frac{\\tau_{N-1}}{\\lambda_{N-1}} = a_{N-1} - \\frac{b_{N-1}}{\\lambda_{N-1}} $$\n$$ \\frac{\\tau_N}{\\lambda_N} = a_N - \\frac{b_N}{\\lambda_N} $$\nThe final step is to compute the absolute values of these two quantities, along with the absolute values of $|a_{N-1}|$ and $|a_N|$.\n\nThe algorithm for each test case $(N, \\alpha, \\delta)$ is as follows:\n1.  Compute the vectors $\\lambda_n = n(n+1)+\\alpha$ and $b_n = (n+1)^{-1+\\delta}$ for $n=0, 1, \\ldots, N$.\n2.  Compute the coefficients $a_n = b_n/\\lambda_n$ for $n=0, 1, \\ldots, N-2$.\n3.  Calculate the sums $S_1 = \\sum_{n=0}^{N-2} a_n$ and $S_{-1} = \\sum_{n=0}^{N-2} (-1)^n a_n$.\n4.  Use the derived formulas to calculate $a_{N-1}$ and $a_N$.\n5.  Calculate the normalized Tau multipliers $a_{N-1} - b_{N-1}/\\lambda_{N-1}$ and $a_N - b_N/\\lambda_N$.\n6.  Take the absolute values of the four required quantities: $|\\tau_{N-1}/\\lambda_{N-1}|$, $|\\tau_N/\\lambda_N|$, $|a_{N-1}|$, and $|a_N|$.\n\nThis procedure is implemented for the given test cases. For all cases, $N=64$ (an even number), so $(-1)^N = 1$. The formulas for $a_{N-1}$ and $a_N$ specialize to:\n$$ a_{N-1} = \\frac{1}{2}(-S_1 + S_{-1}) $$\n$$ a_{N} = \\frac{1}{2}(-S_1 - S_{-1}) $$\nThe implementation uses `numpy` for efficient array operations.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes top coefficients and Tau multipliers for a spectral Tau method.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (64, 1, 0.4),\n        (64, 1, 0.1),\n        (64, 1, 0.01),\n        (64, 1, 1e-6),\n    ]\n\n    results = []\n    for N, alpha, delta in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        \n        # Use float64 for precision in calculations.\n        n_full = np.arange(N + 1, dtype=np.float64)\n    \n        # Eigenvalues of the Sturm-Liouville operator\n        lambda_n = n_full * (n_full + 1) + alpha\n        \n        # Coefficients of the forcing function f(x)\n        b_n = (n_full + 1)**(-1 + delta)\n        \n        # Coefficients a_n for n = 0, ..., N-2 are determined by the projected DE\n        n_lower = np.arange(N - 1)\n        a_n_lower = b_n[:N-1] / lambda_n[:N-1]\n        \n        # Calculate the sums S_1 and S_{-1} needed for the boundary conditions\n        S1 = np.sum(a_n_lower)\n        \n        signs = (-1)**n_lower\n        S_minus_1 = np.sum(a_n_lower * signs)\n        \n        # Determine a_{N-1} and a_N by solving the 2x2 system from BCs.\n        # u_N(1) = Sum(a_n) = 0  => a_{N-1} + a_N = -S1\n        # u_N(-1) = Sum((-1)^n a_n) = 0 => (-1)^{N-1}a_{N-1} + (-1)^N a_N = -S_{-1}\n        # which simplifies to a_{N-1} - a_N = (-1)^N S_{-1}\n        \n        sign_N = (-1)**N\n        \n        # Solution of the 2x2 system\n        a_N_minus_1 = 0.5 * (-S1 + S_minus_1 * sign_N)\n        a_N = 0.5 * (-S1 - S_minus_1 * sign_N)\n        \n        # Normalized Tau multipliers are defined as tau_n / lambda_n = a_n - b_n / lambda_n\n        tau_norm_N_minus_1 = a_N_minus_1 - b_n[N-1] / lambda_n[N-1]\n        tau_norm_N = a_N - b_n[N] / lambda_n[N]\n        \n        # The four quantities to report are the absolute values.\n        result = [\n            np.abs(tau_norm_N_minus_1),\n            np.abs(tau_norm_N),\n            np.abs(a_N_minus_1),\n            np.abs(a_N)\n        ]\n        results.append(result)\n\n    # Final print statement in the exact required format: [[r1,r2,...],[...],...]\n    case_strs = [f\"[{','.join(map(str, res))}]\" for res in results]\n    print(f\"[{','.join(case_strs)}]\")\n\nsolve()\n```", "id": "3419498"}, {"introduction": "Our final practice takes you \"under the hood\" to the computational core of the Tau method: the linear algebraic system. The structure and conditioning of the \"Tau matrix\" dictate the efficiency and stability of the entire solution process. This problem guides you through the essential steps of constructing this matrix from first principles and then exploring preconditioning strategies to improve its properties, an indispensable skill for developing robust and large-scale spectral codes [@problem_id:3419514].", "problem": "Consider the spectral Tau method for the linear boundary value problem on the interval $[-1,1]$:\n$$\n- u''(x) = f(x), \\quad x \\in (-1,1), \\qquad u(-1) = 0, \\quad u(1) = 0,\n$$\nwhere $u(x)$ is approximated by a truncated Legendre series $u_N(x) = \\sum_{k=0}^{N} a_k P_k(x)$, with $P_k(x)$ denoting the Legendre polynomial of degree $k$. Let $\\{P_k(x)\\}_{k=0}^\\infty$ be the classical orthogonal polynomial family on $[-1,1]$ with unit weight, satisfying\n$$\n\\int_{-1}^{1} P_i(x) P_j(x)\\, dx = \\frac{2}{2i+1} \\delta_{ij}.\n$$\nThe spectral Tau method enforces the differential equation in a weak sense for the first $N-1$ Legendre test functions and imposes the two boundary conditions by replacing the last two equations. Specifically, define the $(N+1)\\times(N+1)$ Tau matrix $A$ as follows:\n- For interior indices $i = 0,1,\\dots,N-2$, the row corresponds to the weak form of $-u''(x)$ projected onto $P_i(x)$:\n$$\n\\int_{-1}^{1} P_i(x)\\big(-u''(x)\\big)\\, dx = \\int_{-1}^{1} P_i(x) f(x)\\, dx.\n$$\n- The last two rows enforce the Dirichlet boundary conditions:\n$$\n\\sum_{k=0}^{N} a_k P_k(-1) = 0 \\quad \\text{and} \\quad \\sum_{k=0}^{N} a_k P_k(1) = 0.\n$$\nFor a Legendre-series representation $v(x) = \\sum_{k=0}^{N} c_k P_k(x)$, its second derivative $v''(x)$ has a Legendre-series representation with coefficients obtained by applying the Legendre-series differentiation operator twice. If $v''(x) = \\sum_{i=0}^{N-2} d_i P_i(x)$, then the weak projection onto $P_i(x)$ is\n$$\n\\int_{-1}^{1} P_i(x) v''(x)\\, dx = \\frac{2}{2i+1} d_i.\n$$\nUsing these facts, the interior rows of the Tau matrix are linear in the modal coefficients $a_k$ through the Legendre-series second derivative operator.\n\nPreconditioning is often required to improve the conditioning of the Tau matrix and the robustness of iterative solvers. In this task, you will construct $A$ and evaluate two left preconditioning strategies:\n1. Row $2$-norm scaling preconditioner, which scales each row $A_{i,:}$ by the reciprocal of its Euclidean norm, i.e., $M_{\\text{row}}^{-1} = \\operatorname{diag}\\left( \\frac{1}{\\|A_{i,:}\\|_2} \\right)$.\n2. Legendre weight normalization preconditioner, which scales the interior rows by the Legendre inner-product weight and leaves the boundary rows unchanged, i.e.,\n$$\nM_{\\text{w}}^{-1} = \\operatorname{diag}\\left( \\frac{2i+1}{2} \\text{ for } i=0,\\dots,N-2; \\; 1, \\; 1 \\right).\n$$\n\nStarting from the orthogonality of Legendre polynomials and the definition of the spectral Tau method, derive the construction of the Tau matrix $A$ and the right-hand side vector $b$ for a given Legendre-series forcing $f(x) = \\sum_{k=0}^{N-2} \\hat{f}_k P_k(x)$, where\n$$\nb_i = \\int_{-1}^{1} P_i(x) f(x)\\, dx = \\frac{2}{2i+1} \\hat{f}_i, \\quad i=0,\\dots,N-2, \\qquad b_{N-1} = 0, \\quad b_N = 0.\n$$\nImplement a complete, runnable program that:\n- Constructs the Legendre-series second derivative operator applied to modal coefficients, by using Legendre-series differentiation twice.\n- Assembles the Tau matrix $A$ for given $N$.\n- Assembles the right-hand side $b$ for given Legendre forcing coefficients $\\hat{f}_k$.\n- Forms the preconditioned matrices $A_{\\text{row}} = M_{\\text{row}}^{-1} A$ and $A_{\\text{w}} = M_{\\text{w}}^{-1} A$ and the preconditioned right-hand sides $b_{\\text{row}} = M_{\\text{row}}^{-1} b$ and $b_{\\text{w}} = M_{\\text{w}}^{-1} b$.\n- Computes the $2$-norm condition numbers $\\kappa_2(A)$, $\\kappa_2(A_{\\text{row}})$, and $\\kappa_2(A_{\\text{w}})$.\n- Computes the relative residual norms after one Richardson iteration step from the zero initial guess for each system $A x = b$, $A_{\\text{row}} x = b_{\\text{row}}$, and $A_{\\text{w}} x = b_{\\text{w}}$, taking $x^{(1)} = b$, $x^{(1)}_{\\text{row}} = b_{\\text{row}}$, and $x^{(1)}_{\\text{w}} = b_{\\text{w}}$, and reporting\n$$\n\\rho_{\\text{none}} = \\frac{\\| b - A x^{(1)} \\|_2}{\\| b \\|_2}, \\quad \\rho_{\\text{row}} = \\frac{\\| b - A x^{(1)}_{\\text{row}} \\|_2}{\\| b \\|_2}, \\quad \\rho_{\\text{w}} = \\frac{\\| b - A x^{(1)}_{\\text{w}} \\|_2}{\\| b \\|_2}.\n$$\n\nUse the following test suite of parameter values to exercise different behaviors of the method:\n- Test case 1 (boundary-dominated, minimal size): $N = 2$ and $f(x) = P_0(x)$, that is $\\hat{f}_0 = 1$ and $\\hat{f}_k = 0$ for $k \\ge 1$.\n- Test case 2 (moderate size, sparse forcing): $N = 16$ and $f(x) = P_2(x) + 0.5\\, P_5(x) + 0.1\\, P_{12}(x)$, that is $\\hat{f}_2 = 1$, $\\hat{f}_5 = 0.5$, $\\hat{f}_{12} = 0.1$, all other $\\hat{f}_k = 0$.\n- Test case 3 (large size, alternating decaying forcing): $N = 48$ and $\\hat{f}_k = \\frac{(-1)^k}{k+1}$ for $k = 0,1,\\dots,N-2$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a sublist with the six floating-point numbers\n$$\n[\\kappa_2(A), \\; \\kappa_2(A_{\\text{row}}), \\; \\kappa_2(A_{\\text{w}}), \\; \\rho_{\\text{none}}, \\; \\rho_{\\text{row}}, \\; \\rho_{\\text{w}}].\n$$\nFor example, the output must look like\n$$\n\\big[ [\\text{t1\\_kA},\\text{t1\\_kRow},\\text{t1\\_kW},\\text{t1\\_rhoNone},\\text{t1\\_rhoRow},\\text{t1\\_rhoW}], [\\text{t2\\_kA},\\dots], [\\text{t3\\_kA},\\dots] \\big],\n$$\nwith no additional text. Angles are not involved, and there are no physical units; all numerical answers must be reported as plain floating-point numbers in the specified format.", "solution": "The user-provided problem is a valid, well-posed task in numerical analysis. It requires the construction and analysis of a spectral Tau method for a second-order boundary value problem. We will proceed with a full derivation and solution.\n\nThe problem is to solve $-u''(x) = f(x)$ on the interval $[-1, 1]$ with homogeneous Dirichlet boundary conditions $u(-1) = 0$ and $u(1) = 0$. The solution $u(x)$ is approximated by a degree-$N$ polynomial $u_N(x) = \\sum_{k=0}^{N} a_k P_k(x)$, where $P_k(x)$ are the Legendre polynomials. The goal is to determine the coefficients $a_k$.\n\nThe spectral Tau method generates a system of linear equations, $A\\vec{a} = \\vec{b}$, for the coefficient vector $\\vec{a} = [a_0, a_1, \\dots, a_N]^T$. We will construct the $(N+1) \\times (N+1)$ matrix $A$ and the right-hand side vector $\\vec{b}$ of size $N+1$.\n\n**1. Legendre Series Differentiation**\n\nA critical component is the operator that maps the Legendre coefficients of a function $v(x)$ to the coefficients of its derivative $v'(x)$. Let $v(x) = \\sum_{k=0}^{N} c_k P_k(x)$ and its derivative be $v'(x) = \\sum_{j=0}^{N-1} c'_j P_j(x)$. The coefficients are related by the well-known recurrence:\n$$\nc'_j = (2j+1) \\sum_{\\substack{k=j+1 \\\\ k+j \\text{ is odd}}}^{N} c_k\n$$\nThis relation defines a linear operator, which can be represented by an $(N+1) \\times (N+1)$ matrix $D^{(1)}$ that maps the coefficient vector $\\vec{c}=[c_0, \\dots, c_N]^T$ to $\\vec{c'} = [c'_0, \\dots, c'_{N-1}, 0, \\dots, 0]^T$. The matrix entries are:\n$$\nD^{(1)}_{jk} = \\begin{cases} 2j+1 & \\text{if } k > j \\text{ and } k+j \\text{ is odd} \\\\ 0 & \\text{otherwise} \\end{cases}\n$$\nThe second derivative operator, $D^{(2)}$, which maps the coefficients of $v(x)$ to those of $v''(x)$, is obtained by applying the first derivative operator twice: $D^{(2)} = D^{(1)} \\times D^{(1)}$.\n\n**2. Assembling the Tau Matrix $A$**\n\nThe $(N+1)$ equations that form the system $A\\vec{a}=\\vec{b}$ come from two sources: the differential equation and the boundary conditions.\n\n*   **Interior Rows ($i=0, 1, \\dots, N-2$):**\n    These rows enforce the differential equation in a weighted-residual sense. The equation for the $i$-th test function $P_i(x)$ is:\n    $$\n    \\int_{-1}^{1} P_i(x) \\left(-u_N''(x)\\right) dx = \\int_{-1}^{1} P_i(x) f(x) dx\n    $$\n    Let the Legendre expansion of the second derivative be $u_N''(x) = \\sum_{j=0}^{N-2} d_j P_j(x)$, where the coefficient vector $\\vec{d} = D^{(2)}\\vec{a}$. The left-hand side (LHS) becomes:\n    $$\n    \\text{LHS}_i = -\\int_{-1}^{1} P_i(x) \\left( \\sum_{j=0}^{N-2} d_j P_j(x) \\right) dx\n    $$\n    Using the orthogonality property of Legendre polynomials, $\\int_{-1}^{1} P_i(x) P_j(x) dx = \\frac{2}{2i+1} \\delta_{ij}$, the LHS simplifies to:\n    $$\n    \\text{LHS}_i = -d_i \\frac{2}{2i+1} = -\\frac{2}{2i+1} (D^{(2)}\\vec{a})_i = -\\frac{2}{2i+1} \\sum_{j=0}^{N} D^{(2)}_{ij} a_j\n    $$\n    The problem defines the $i$-th row of the linear system as $(A\\vec{a})_i = b_i$. By matching terms, the $i$-th row of the matrix $A$ for $i=0, \\dots, N-2$ is given by:\n    $$\n    A_{ij} = -\\frac{2}{2i+1} D^{(2)}_{ij} \\quad \\text{for } j=0, \\dots, N\n    $$\n\n*   **Boundary Rows ($i=N-1, N$):**\n    The last two rows of the system impose the Dirichlet boundary conditions $u_N(-1)=0$ and $u_N(1)=0$.\n    $$\n    u_N(1) = \\sum_{k=0}^{N} a_k P_k(1) = 0 \\quad \\text{and} \\quad u_N(-1) = \\sum_{k=0}^{N} a_k P_k(-1) = 0\n    $$\n    Using the known properties $P_k(1)=1$ and $P_k(-1)=(-1)^k$, these equations become:\n    $$\n    \\sum_{k=0}^{N} a_k = 0 \\quad \\text{and} \\quad \\sum_{k=0}^{N} a_k (-1)^k = 0\n    $$\n    We assign the condition at $x=-1$ to row $N-1$ and the condition at $x=1$ to row $N$. This defines the last two rows of $A$:\n    $$\n    A_{N-1, k} = (-1)^k \\quad \\text{for } k=0, \\dots, N\n    $$\n    $$\n    A_{N, k} = 1 \\quad \\text{for } k=0, \\dots, N\n    $$\n\n**3. Assembling the Right-Hand-Side Vector $\\vec{b}$**\n\n*   For the interior equations ($i=0, \\dots, N-2$), the right-hand side is $b_i = \\int_{-1}^{1} P_i(x) f(x) dx$. Given the expansion $f(x) = \\sum_{k=0}^{N-2} \\hat{f}_k P_k(x)$, orthogonality gives:\n    $$\n    b_i = \\hat{f}_i \\int_{-1}^{1} P_i(x)^2 dx = \\frac{2}{2i+1} \\hat{f}_i\n    $$\n*   For the boundary equations ($i=N-1, N$), the conditions are homogeneous, so $b_{N-1}=0$ and $b_{N}=0$.\n\n**4. Preconditioning**\n\nTwo left preconditioners are considered. A preconditioner $M^{-1}$ transforms the system $A\\vec{a}=\\vec{b}$ into $M^{-1}A\\vec{a} = M^{-1}\\vec{b}$.\n1.  **Row 2-norm scaling:** $M_{\\text{row}}^{-1}$ is a diagonal matrix where the $i$-th diagonal element is the reciprocal of the Euclidean norm of the $i$-th row of $A$: $(M_{\\text{row}}^{-1})_{ii} = 1/\\|A_{i,:}\\|_2$.\n2.  **Legendre weight normalization:** $M_{\\text{w}}^{-1}$ is a diagonal matrix intended to reverse the scaling applied to the interior rows of $A$. Its diagonal entries are $(M_{\\text{w}}^{-1})_{ii} = (2i+1)/2$ for $i=0, \\dots, N-2$, and $(M_{\\text{w}}^{-1})_{ii} = 1$ for $i=N-1, N$.\n\nThe preconditioned matrices are $A_{\\text{row}} = M_{\\text{row}}^{-1} A$ and $A_{\\text{w}} = M_{\\text{w}}^{-1} A$. The preconditioned right-hand sides are $\\vec{b}_{\\text{row}} = M_{\\text{row}}^{-1} \\vec{b}$ and $\\vec{b}_{\\text{w}} = M_{\\text{w}}^{-1} \\vec{b}$.\n\n**5. Condition Number and Residual Norm Calculation**\n\nThe $2$-norm condition numbers $\\kappa_2(\\cdot)$ of the original and preconditioned matrices are computed. The improvement in convergence behavior is assessed using one step of a Richardson iteration, starting from a zero initial guess. For a generic preconditioned system $M^{-1}A\\vec{a}=M^{-1}\\vec{b}$, the first Richardson iterate (with step size $1$) is $\\vec{a}^{(1)} = M^{-1}\\vec{b}$. The problem specifies using this iterate to evaluate the residual of the original system, $\\| \\vec{b} - A \\vec{a}^{(1)} \\|_2 / \\| \\vec{b} \\|_2$.\n*   No preconditioning ($M=I$): $\\vec{a}^{(1)} = \\vec{b}$. The residual norm is $\\rho_{\\text{none}} = \\| \\vec{b} - A\\vec{b} \\|_2 / \\| \\vec{b} \\|_2$.\n*   Row-norm preconditioning ($M=M_{\\text{row}}$): $\\vec{a}^{(1)}_{\\text{row}} = M_{\\text{row}}^{-1}\\vec{b} = \\vec{b}_{\\text{row}}$. Residual norm is $\\rho_{\\text{row}} = \\| \\vec{b} - A\\vec{b}_{\\text{row}} \\|_2 / \\| \\vec{b} \\|_2$.\n*   Weight preconditioning ($M=M_{\\text{w}}$): $\\vec{a}^{(1)}_{\\text{w}} = M_{\\text{w}}^{-1}\\vec{b} = \\vec{b}_{\\text{w}}$. Residual norm is $\\rho_{\\text{w}} = \\| \\vec{b} - A\\vec{b}_{\\text{w}} \\|_2 / \\| \\vec{b} \\|_2$.\n\nThe implementation will follow these derived steps.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main driver function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1: N=2, f(x) = P_0(x)\n        (2, {0: 1.0}),\n        # Test case 2: N=16, f(x) = P_2(x) + 0.5 P_5(x) + 0.1 P_12(x)\n        (16, {2: 1.0, 5: 0.5, 12: 0.1}),\n        # Test case 3: N=48, f_k = (-1)^k / (k+1)\n        (48, 'alternating')\n    ]\n\n    results = []\n    for N, f_hat_coeffs in test_cases:\n        res = compute_metrics(N, f_hat_coeffs)\n        results.append(res)\n    \n    # Format the output string as required: [[...],[...],[...]]\n    case_strings = []\n    for res_list in results:\n      case_strings.append(f\"[{','.join(map(str, res_list))}]\")\n    final_string = f\"[{','.join(case_strings)}]\"\n    print(final_string)\n\ndef compute_metrics(N, f_hat_coeffs):\n    \"\"\"\n    Constructs matrices and computes metrics for a single test case.\n\n    Args:\n        N (int): The degree of the Legendre polynomial approximation.\n        f_hat_coeffs (dict or str): Specification for the forcing term coefficients.\n\n    Returns:\n        list: A list of six floating-point numbers containing the computed metrics.\n    \"\"\"\n    # 1. Construct f_hat vector from the provided coefficients\n    f_hat = np.zeros(N - 1)\n    if isinstance(f_hat_coeffs, dict):\n        for k, v in f_hat_coeffs.items():\n            if k < len(f_hat):\n                f_hat[k] = v\n    elif f_hat_coeffs == 'alternating':\n        k_vals = np.arange(N - 1)\n        f_hat = ((-1.0)**k_vals) / (k_vals + 1.0)\n\n    # 2. Construct Legendre differentiation matrix D1 and second derivative D2\n    D1 = np.zeros((N + 1, N + 1))\n    for n in range(N):\n        for k in range(n + 1, N + 1):\n            if (k + n) % 2 == 1:\n                D1[n, k] = 2 * n + 1\n    D2 = D1 @ D1\n    \n    # 3. Assemble the Tau matrix A\n    A = np.zeros((N + 1, N + 1))\n    # Interior rows (i = 0 to N-2)\n    i_vals_int = np.arange(N - 1)\n    scaling_int = -2.0 / (2.0 * i_vals_int + 1.0)\n    A[:N-1, :] = scaling_int[:, np.newaxis] * D2[:N-1, :]\n    # Boundary rows (i = N-1, N)\n    k_vals = np.arange(N + 1)\n    A[N - 1, :] = (-1.0)**k_vals\n    A[N, :] = 1.0\n\n    # 4. Assemble the right-hand side vector b\n    b = np.zeros(N + 1)\n    b[:N-1] = (2.0 / (2.0 * i_vals_int + 1.0)) * f_hat\n    \n    # 5. Compute condition number of the original matrix A\n    kappa_A = np.linalg.cond(A)\n\n    # 6. Row 2-norm preconditioning\n    M_row_inv_diag = np.zeros(N + 1)\n    row_norms = np.linalg.norm(A, axis=1)\n    non_zero_indices = row_norms > 1e-15\n    M_row_inv_diag[non_zero_indices] = 1.0 / row_norms[non_zero_indices]\n    \n    A_row = A * M_row_inv_diag[:, np.newaxis]\n    b_row = b * M_row_inv_diag\n    kappa_A_row = np.linalg.cond(A_row)\n\n    # 7. Legendre weight normalization preconditioning\n    M_w_inv_diag = np.ones(N + 1)\n    M_w_inv_diag[:N-1] = (2.0 * i_vals_int + 1.0) / 2.0\n    \n    A_w = A * M_w_inv_diag[:, np.newaxis]\n    b_w = b * M_w_inv_diag\n    kappa_A_w = np.linalg.cond(A_w)\n\n    # 8. Compute relative residual norms\n    norm_b = np.linalg.norm(b)\n    \n    if norm_b < 1e-15:\n        rho_none = 0.0\n        rho_row = 0.0\n        rho_w = 0.0\n    else:\n        # Preconditioned Richardson step 1: x_k+1 = x_k + M^-1 (b - A x_k)\n        # With x_0 = 0, we get x_1 = M^-1 b.\n        # Residual norm is ||b - A x_1||_2 / ||b||_2\n\n        # No preconditioning (M = I): x_1 = b\n        x1_none = b\n        rho_none = np.linalg.norm(b - A @ x1_none) / norm_b\n        \n        # Row-norm preconditioning: x_1 = M_row^-1 b = b_row\n        x1_row = b_row\n        rho_row = np.linalg.norm(b - A @ x1_row) / norm_b\n        \n        # Weight preconditioning: x_1 = M_w^-1 b = b_w\n        x1_w = b_w\n        rho_w = np.linalg.norm(b - A @ x1_w) / norm_b\n\n    return [kappa_A, kappa_A_row, kappa_A_w, rho_none, rho_row, rho_w]\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3419514"}]}