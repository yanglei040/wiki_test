{"hands_on_practices": [{"introduction": "Beyond the textbook case of linear advection with constant speed, real-world applications often involve nonlinear equations where the characteristic speed varies in space and time. This exercise [@problem_id:3374433] provides a practical guide to implementing a dynamic Courant-Friedrichs-Lewy (CFL) condition for the inviscid Burgers' equation, a prototype for more complex hyperbolic systems. You will develop a time-step estimator that adapts to the local solution behavior and investigate a critical implementation detail: how the accuracy of estimating the maximum wave speed, $|u|$, impacts the stability and reliability of the entire simulation.", "problem": "Consider the one-dimensional inviscid Burgers equation, a hyperbolic conservation law given by $u_t + \\left(\\frac{u^2}{2}\\right)_x = 0$, discretized using the Discontinuous Galerkin (DG) method with piecewise polynomials of degree $p$ on a partition of the domain into elements $K$ of length $h_K$. The Courant Friedrichs Lewy (CFL) condition for explicit time integration must ensure that the discrete numerical domain of dependence contains the partial differential equation’s domain of dependence. Your task is to derive a nonlinear CFL estimator for the DG discretization of the inviscid Burgers equation and then quantitatively test its sensitivity to two implementation choices: under-integrated aliasing versus oversampled exact quadrature surrogate, and the presence versus absence of shock-capturing artificial viscosity.\n\nStart from fundamental bases appropriate to hyperbolic conservation laws and DG methods:\n- The characteristic speed of inviscid Burgers is $a(u) = u$, so the advective stability limit for an explicit method must be governed by an elementwise bound involving $h_K$, $p$, and the maximum characteristic speed on each element.\n- Polynomial inverse and trace inequalities imply that DG semi-discrete operators have elementwise spectral radii that scale with $(2p+1)$ for advection-like terms.\n- Artificial viscosity used for shock capturing adds a diffusive operator; explicit stabilization of diffusion typically imposes a parabolic restriction that scales like $h_K^2$ with a polynomial-degree-dependent factor.\n\nYou must:\n1. Derive a nonlinear CFL estimator that is consistent with these fundamental facts and yields an elementwise advective time-step restriction depending on $h_K$, $p$, and a per-element bound on $|u|$.\n2. Derive an accompanying diffusive time-step restriction for artificial viscosity $\\nu_K$ based on a gradient-based sensor, with a dependence on $h_K$, $p$, and $\\nu_K$ proportional to a parabolic scaling.\n3. Implement two ways to estimate the required per-element maxima:\n   - An under-integrated aliasing estimate using $N_{\\text{alias}} = p+1$ uniformly spaced sampling points per element (including both endpoints) for the maximum of $|u|$ and $|u_x|$.\n   - An oversampled “exact quadrature surrogate” estimate using $N_{\\text{exact}} = 200p + 50$ uniformly spaced sampling points per element (including both endpoints) for the maximum of $|u|$ and $|u_x|$.\n4. Compute, for each test case, four scalars:\n   - The global advective time step using the aliasing estimate.\n   - The global advective time step using the exact quadrature surrogate estimate.\n   - The global total time step (the minimum of advective and diffusive restrictions) using the aliasing estimate.\n   - The global total time step using the exact quadrature surrogate estimate.\n\nDefinitions to use in your program:\n- The advective characteristic speed is $|u|$.\n- The artificial viscosity is defined per element as $\\nu_K = \\kappa\\, h_K \\max_{x \\in K} |u_x(x)|$, where $\\kappa$ is a prescribed constant.\n- The global total time step is the minimum over elements of the minimum of the advective and diffusive restrictions.\n\nTest suite (domain is $[0,1]$ in all cases):\n- Case 1 (smooth “happy path” without shock capturing):\n  - Mesh: four equal elements, so $h_K = 0.25$ for all $K$.\n  - Polynomial degree: $p = 3$.\n  - Field: $u(x) = \\sin(2\\pi x)$ and $u_x(x) = 2\\pi \\cos(2\\pi x)$.\n  - Constants: use $C_{\\text{adv}} = 0.5$, $C_{\\text{visc}} = 0.25$, and $\\kappa = 0$.\n  - Sampling: $N_{\\text{alias}} = p+1$ and $N_{\\text{exact}} = 200p + 50$.\n- Case 2 (near-discontinuous profile with shock capturing):\n  - Mesh: eight equal elements, so $h_K = 0.125$ for all $K$.\n  - Polynomial degree: $p = 5$.\n  - Field: $u(x) = \\tanh\\left(100(x - 0.5)\\right)$ and $u_x(x) = 100\\,\\text{sech}^2\\left(100(x - 0.5)\\right)$.\n  - Constants: use $C_{\\text{adv}} = 0.4$, $C_{\\text{visc}} = 0.25$, and $\\kappa = 0.05$.\n  - Sampling: $N_{\\text{alias}} = p+1$ and $N_{\\text{exact}} = 200p + 50$.\n- Case 3 (edge case with one very small element, without shock capturing):\n  - Mesh: two elements with $h_1 = 10^{-3}$ and $h_2 = 1 - 10^{-3}$.\n  - Polynomial degree: $p = 1$.\n  - Field: $u(x) = 10 + \\tfrac{1}{2}\\sin(2\\pi x)$ and $u_x(x) = \\pi \\cos(2\\pi x)$.\n  - Constants: use $C_{\\text{adv}} = 0.9$, $C_{\\text{visc}} = 0.25$, and $\\kappa = 0$.\n  - Sampling: $N_{\\text{alias}} = p+1$ and $N_{\\text{exact}} = 200p + 50$.\n\nOutput specification:\n- Your program should produce a single line of output containing the results for all test cases aggregated into a single comma-separated list enclosed in square brackets, ordered as:\n  $[$Case 1 advective aliasing, Case 1 advective exact, Case 1 total aliasing, Case 1 total exact, Case 2 advective aliasing, Case 2 advective exact, Case 2 total aliasing, Case 2 total exact, Case 3 advective aliasing, Case 3 advective exact, Case 3 total aliasing, Case 3 total exact$]$.\n- All outputs must be real numbers (floats). No physical units are required; all quantities are dimensionless.\n\nYour program must implement the derived estimator and compute the requested outputs for the three cases above using the specified constants and sampling rules. No user input is allowed; hard-code the test suite inside the program. The program must be a complete, runnable script that prints only the single line specified above.", "solution": "The problem is valid and well-posed. It addresses the determination of a stable time-step size for the explicit Discontinuous Galerkin (DG) discretization of the inviscid Burgers equation, a canonical problem in the numerical analysis of hyperbolic conservation laws. We will first derive the necessary time-step estimators and then implement them to analyze the specified test cases.\n\n### Derivation of Time-Step Estimators\n\nThe stability of an explicit time-stepping scheme for a semi-discretized partial differential equation $\\frac{d\\mathbf{u}}{dt} = \\mathbf{L}(\\mathbf{u})$ is governed by the Courant-Friedrichs-Lewy (CFL) condition, which requires that the time step $\\Delta t$ satisfies $\\Delta t \\le \\frac{C}{\\rho(\\mathbf{L})}$, where $\\rho(\\mathbf{L})$ is the spectral radius of the spatial operator $\\mathbf{L}$ and $C$ is a constant depending on the time-integration scheme. For a system involving both advection and diffusion, $\\mathbf{L} = \\mathbf{L}_{\\text{adv}} + \\mathbf{L}_{\\text{visc}}$, the time step is typically limited by the sum of the spectral radii, leading to the restriction $\\frac{1}{\\Delta t} \\approx \\frac{1}{\\Delta t_{\\text{adv}}} + \\frac{1}{\\Delta t_{\\text{visc}}}$. A more straightforward and common practice is to take the minimum of the individual restrictions: $\\Delta t = \\min(\\Delta t_{\\text{adv}}, \\Delta t_{\\text{visc}})$.\n\nThe global time step is the minimum of the element-wise time steps over all elements $K$ in the mesh $\\mathcal{T}_h$:\n$$ \\Delta t_{\\text{global}} = \\min_{K \\in \\mathcal{T}_h} \\Delta t_K $$\n\n#### 1. Advective Time-Step Restriction ($\\Delta t_{\\text{adv}}$)\n\nFor a one-dimensional hyperbolic problem, the spectral radius of the DG spatial operator on an element $K$ is bounded by a quantity proportional to the maximum characteristic speed on that element and geometric and polynomial-degree-dependent factors. The problem states that for advection, the spectral radius scales with $(2p+1)/h_K$. The characteristic speed for the inviscid Burgers equation, $u_t + (u^2/2)_x = 0$, is $a(u) = u$.\n\nThe element-wise spectral radius for the advective part is thus modeled as:\n$$ \\rho(\\mathbf{L}_{\\text{adv}, K}) \\propto \\frac{(2p+1)}{h_K} \\max_{x \\in K} |a(u(x))| = \\frac{(2p+1)}{h_K} \\max_{x \\in K} |u(x)| $$\nThe corresponding time-step restriction is inversely proportional to this spectral radius. Including the provided dimensionless constant $C_{\\text{adv}}$, we define the element-wise advective time-step restriction as:\n$$ \\Delta t_{\\text{adv}, K} = C_{\\text{adv}} \\frac{h_K}{(2p+1) \\max_{x \\in K} |u(x)|} $$\nThis formula correctly captures the expected behavior: the stable time step must decrease for smaller elements ($h_K$), higher polynomial degrees ($p$), and larger wave speeds ($|u|$).\n\n#### 2. Diffusive Time-Step Restriction ($\\Delta t_{\\text{visc}}$)\n\nAn artificial viscosity term adds a parabolic, diffusion-like operator to the system for shock-capturing. For an explicit method, this imposes a more stringent time-step restriction that typically scales with $h_K^2$. Standard analysis of DG methods for parabolic problems shows that the spectral radius of the DG Laplacian operator scales as $\\rho(\\mathbf{L}_{\\text{visc}, K}) \\propto \\nu_K (p+1)^4 / h_K^2$ or $\\nu_K (2p+1)^2 / h_K^2$. Given the use of $(2p+1)$ in the advective scaling, it is consistent and standard to use a scaling of $(2p+1)^2$ for the diffusive term, which arises from applying a polynomial inverse inequality twice.\n\nThus, we model the element-wise spectral radius for the viscous part as:\n$$ \\rho(\\mathbf{L}_{\\text{visc}, K}) \\propto \\frac{\\nu_K (2p+1)^2}{h_K^2} $$\nThe time-step restriction is, therefore:\n$$ \\Delta t_{\\text{visc}, K} \\le C_{\\text{visc}} \\frac{h_K^2}{\\nu_K (2p+1)^2} $$\nThe problem defines the element-wise artificial viscosity as $\\nu_K = \\kappa\\, h_K \\max_{x \\in K} |u_x(x)|$. Substituting this into the restriction gives:\n$$ \\Delta t_{\\text{visc}, K} = C_{\\text{visc}} \\frac{h_K^2}{\\left(\\kappa\\, h_K \\max_{x \\in K} |u_x(x)|\\right) (2p+1)^2} = \\frac{C_{\\text{visc}} h_K}{\\kappa (2p+1)^2 \\max_{x \\in K} |u_x(x)|} $$\nThis restriction applies only when $\\kappa  0$. If $\\kappa=0$, there is no artificial viscosity, and $\\Delta t_{\\text{visc}, K} = \\infty$.\n\n#### 3. Total Element-wise Time Step\n\nThe total time-step restriction for a single element $K$ is the minimum of the advective and diffusive limits:\n$$ \\Delta t_K = \\min(\\Delta t_{\\text{adv}, K}, \\Delta t_{\\text{visc}, K}) $$\nThe global time step for the entire simulation is then the minimum over all elements:\n$$ \\Delta t = \\min_{K \\in \\mathcal{T}_h} \\Delta t_K $$\n\n### Implementation and Analysis\n\nThe problem requires computing four scalar time steps for each test case, based on two different methods for estimating the maxima of $|u|$ and $|u_x|$ on each element: an under-integrated \"aliasing\" estimate and an oversampled \"exact surrogate\" estimate.\n\nThe procedure for each test case is as follows:\n1.  For each element $K$ in the mesh:\n    a.  Define the sampling points for both the aliasing ($N_{\\text{alias}}=p+1$) and exact surrogate ($N_{\\text{exact}}=200p+50$) methods.\n    b.  Evaluate $|u(x)|$ and $|u_x(x)|$ at these sample points to find the respective maxima for each method: $\\max_{\\text{alias}}|u|$, $\\max_{\\text{alias}}|u_x|$, $\\max_{\\text{exact}}|u|$, $\\max_{\\text{exact}}|u_x|$.\n    c.  Calculate the four element-wise time steps: $\\Delta t_{\\text{adv}, K, \\text{alias}}$, $\\Delta t_{\\text{total}, K, \\text{alias}}$, $\\Delta t_{\\text{adv}, K, \\text{exact}}$, and $\\Delta t_{\\text{total}, K, \\text{exact}}$.\n2.  Compute the global minimum across all elements for each of the four time-step categories to obtain the final required scalars.\n\nThis procedure will be encoded into a Python script to compute the values for the three specified test cases. A crucial aspect of the problem is that the global time step is the *minimum over all elements*. This means that a local error in estimating a maximum (e.g., aliasing missing a peak) might not affect the final global time step if the time step is limited by a different element where the estimate is accurate.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes nonlinear CFL estimators for a DG discretization of the\n    inviscid Burgers equation based on the specified problem statement.\n    \"\"\"\n    \n    # Helper for sech(x) = 1/cosh(x)\n    def sech(x):\n        return 1.0 / np.cosh(x)\n\n    def compute_all_time_steps(h_k, p, u_func, du_dx_func, element_bounds,\n                               C_adv, C_visc, kappa):\n        \"\"\"\n        Computes the four required global time-step scalars for a given test case.\n        \"\"\"\n        num_elements = len(h_k)\n        \n        # p is uniform across elements for all test cases\n        P = p \n        p_vals = [P] * num_elements\n        \n        N_alias_vals = [p_val + 1 for p_val in p_vals]\n        N_exact_vals = [200 * p_val + 50 for p_val in p_vals]\n\n        # Initialize lists to store element-wise time steps\n        elem_dt_adv_alias = np.zeros(num_elements)\n        elem_dt_total_alias = np.zeros(num_elements)\n        elem_dt_adv_exact = np.zeros(num_elements)\n        elem_dt_total_exact = np.zeros(num_elements)\n\n        for i in range(num_elements):\n            x_left, x_right = element_bounds[i]\n\n            # 1. Aliasing sampling\n            x_alias = np.linspace(x_left, x_right, N_alias_vals[i])\n            u_samples_alias = u_func(x_alias)\n            du_dx_samples_alias = du_dx_func(x_alias)\n            max_u_alias = np.max(np.abs(u_samples_alias)) if u_samples_alias.size > 0 else 0.0\n            max_du_dx_alias = np.max(np.abs(du_dx_samples_alias)) if du_dx_samples_alias.size > 0 else 0.0\n\n            # 2. Exact surrogate sampling\n            x_exact = np.linspace(x_left, x_right, N_exact_vals[i])\n            u_samples_exact = u_func(x_exact)\n            du_dx_samples_exact = du_dx_func(x_exact)\n            max_u_exact = np.max(np.abs(u_samples_exact))\n            max_du_dx_exact = np.max(np.abs(du_dx_samples_exact))\n\n            # --- Calculate dt for aliasing ---\n            # Advective time step\n            # Use a small tolerance to avoid division by zero\n            if max_u_alias > 1e-14:\n                dt_adv_k_alias = C_adv * h_k[i] / ((2 * P + 1) * max_u_alias)\n            else:\n                dt_adv_k_alias = np.inf\n            elem_dt_adv_alias[i] = dt_adv_k_alias\n\n            # Viscous time step\n            if kappa > 0 and max_du_dx_alias > 1e-14:\n                dt_visc_k_alias = (C_visc * h_k[i]) / (kappa * max_du_dx_alias * (2 * P + 1)**2)\n            else:\n                dt_visc_k_alias = np.inf\n            \n            elem_dt_total_alias[i] = min(dt_adv_k_alias, dt_visc_k_alias)\n\n            # --- Calculate dt for exact surrogate ---\n            # Advective time step\n            if max_u_exact > 1e-14:\n                dt_adv_k_exact = C_adv * h_k[i] / ((2 * P + 1) * max_u_exact)\n            else:\n                dt_adv_k_exact = np.inf\n            elem_dt_adv_exact[i] = dt_adv_k_exact\n\n            # Viscous time step\n            if kappa > 0 and max_du_dx_exact > 1e-14:\n                dt_visc_k_exact = (C_visc * h_k[i]) / (kappa * max_du_dx_exact * (2 * P + 1)**2)\n            else:\n                dt_visc_k_exact = np.inf\n            \n            elem_dt_total_exact[i] = min(dt_adv_k_exact, dt_visc_k_exact)\n\n        # Find global minimums\n        global_dt_adv_alias = np.min(elem_dt_adv_alias)\n        global_dt_adv_exact = np.min(elem_dt_adv_exact)\n        global_dt_total_alias = np.min(elem_dt_total_alias)\n        global_dt_total_exact = np.min(elem_dt_total_exact)\n        \n        return [global_dt_adv_alias, global_dt_adv_exact, global_dt_total_alias, global_dt_total_exact]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (smooth, no viscosity)\n        {\n            \"p\": 3, \"h_k\": [0.25, 0.25, 0.25, 0.25],\n            \"u_func\": lambda x: np.sin(2 * np.pi * x),\n            \"du_dx_func\": lambda x: 2 * np.pi * np.cos(2 * np.pi * x),\n            \"C_adv\": 0.5, \"C_visc\": 0.25, \"kappa\": 0.0,\n            \"element_bounds\": [(0, 0.25), (0.25, 0.5), (0.5, 0.75), (0.75, 1.0)]\n        },\n        # Case 2 (near-discontinuous, with viscosity)\n        {\n            \"p\": 5, \"h_k\": [0.125] * 8,\n            \"u_func\": lambda x: np.tanh(100 * (x - 0.5)),\n            \"du_dx_func\": lambda x: 100 * sech(100 * (x - 0.5))**2,\n            \"C_adv\": 0.4, \"C_visc\": 0.25, \"kappa\": 0.05,\n            \"element_bounds\": [(i * 0.125, (i + 1) * 0.125) for i in range(8)]\n        },\n        # Case 3 (small element, no viscosity)\n        {\n            \"p\": 1, \"h_k\": [1e-3, 1-1e-3],\n            \"u_func\": lambda x: 10 + 0.5 * np.sin(2 * np.pi * x),\n            \"du_dx_func\": lambda x: np.pi * np.cos(2 * np.pi * x),\n            \"C_adv\": 0.9, \"C_visc\": 0.25, \"kappa\": 0.0,\n            \"element_bounds\": [(0, 1e-3), (1e-3, 1.0)]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        case_results = compute_all_time_steps(\n            h_k=case[\"h_k\"],\n            p=case[\"p\"],\n            u_func=case[\"u_func\"],\n            du_dx_func=case[\"du_dx_func\"],\n            element_bounds=case[\"element_bounds\"],\n            C_adv=case[\"C_adv\"],\n            C_visc=case[\"C_visc\"],\n            kappa=case[\"kappa\"]\n        )\n        all_results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3374433"}, {"introduction": "The CFL condition, $\\Delta t \\le C \\frac{\\Delta x}{a_{\\max}}$, contains a crucial constant $C$ that depends on the specific numerical scheme. This practice [@problem_id:3374451] delves into the theoretical underpinnings of this constant, revealing how it emerges from the interaction between the spatial operator's eigenvalues and the time integrator's stability region. By performing a Fourier analysis of a Discontinuous Galerkin (DG) scheme, you will see how the choice of numerical flux—specifically, the degree of upwinding—shapes the operator's spectrum in the complex plane, thereby determining the maximum stable time step and explaining why upwind fluxes are essential for the stability of high-order DG methods.", "problem": "Consider one-dimensional linear advection of a scalar field on a periodic domain, governed by the partial differential equation $u_{t} + a\\,u_{x} = 0$ with constant speed $a  0$. Discretize the domain $\\Omega = [0,L]$ by a uniform mesh of $N$ elements of width $h = L/N$. On each element, approximate $u$ by polynomials of degree $p \\geq 1$ using the Discontinuous Galerkin (DG) method with a modal Legendre basis and exact mass matrix. Impose interelement coupling via the numerical flux\n$$\nF^{*}(u^{-},u^{+}) = a\\,\\{u\\} \\;-\\; \\frac{a\\,\\theta}{2}\\,[u], \\quad \\theta \\in [0,1],\n$$\nwhere $\\{u\\} = \\tfrac{1}{2}(u^{-} + u^{+})$ and $[u] = u^{+} - u^{-}$ denote the average and jump at each interface, and superscripts $-$ and $+$ denote traces from the left and right elements, respectively. Assume periodic boundary conditions.\n\nAdopt a Fourier mode ansatz across elements $u^{n}(x,t) = \\widehat{u}(x,t)\\,\\exp(i\\,n\\,\\xi)$, where $n$ indexes elements and $\\xi \\in [0,2\\pi)$ is the nondimensional wavenumber. By block-circulant structure, the semi-discrete DG operator diagonalizes for each $\\xi$ to a $(p+1)\\times(p+1)$ matrix whose eigenvalues $\\lambda_{j}(\\xi;\\theta,p)$ (the DG Fourier symbol) determine stability. Advance in time with the third-order Strong Stability Preserving Runge–Kutta method (SSP-RK3), and recall that linear stability requires the scaled eigenvalues $z_{j} = \\Delta t\\,\\lambda_{j}(\\xi;\\theta,p)$ lie in the absolute stability region $\\{z \\in \\mathbb{C} : |R(z)| \\leq 1\\}$ of SSP-RK3, where $R(z)$ is the method’s stability polynomial.\n\nStarting from these foundations:\n- Derive how the parameter $\\theta$ modifies the DG Fourier symbol by introducing a real (dissipative) shift proportional to the interface jump and characterize the symbol for each $\\xi$ in terms of its real and imaginary parts, emphasizing the monotone dependence of the real part on $\\theta$.\n- Using sharp inverse inequalities for polynomials of degree $p$ on an interval and the interface coupling structure, bound the spectral magnitude by a constant proportional to $(2p+1)\\,a/h$. Explain how this scaling enters the Courant–Friedrichs–Lewy (CFL) restriction for explicit time stepping.\n- Use the SSP-RK3 absolute stability region to relate the allowable time step $\\Delta t$ to the orientation of the symbol in the complex plane, and quantify how the increase in the negative real shift induced by $\\theta$ impacts the allowable $\\Delta t$ versus $p$.\n\nIdentify the single value of $\\theta \\in [0,1]$ that maximizes the allowable $\\Delta t$ under SSP-RK3 for all polynomial degrees $p \\geq 1$ on this uniform mesh. Your final answer must be a single real number. No rounding is needed. If you produce any intermediate numerical values for stability-region intersections, keep them symbolic in the derivation and do not include physical units in the final answer.", "solution": "The problem is valid and well-posed. A complete, reasoned solution will be provided.\n\n### Solution\nThe problem asks for the value of the parameter $\\theta \\in [0,1]$ that maximizes the allowable time step $\\Delta t$ for a DG discretization of the linear advection equation, when time integration is performed with the SSP-RK3 method, for all polynomial degrees $p \\ge 1$.\n\nThe semi-discrete DG formulation for the linear advection equation on a uniform periodic mesh takes the form of a system of ordinary differential equations:\n$$ \\frac{d\\vec{u}}{dt} = \\mathcal{L}_{DG}\\vec{u} $$\nwhere $\\vec{u}$ is the global vector of degrees of freedom and $\\mathcal{L}_{DG}$ is the spatial discretization operator. The stability of an explicit time-stepping scheme depends on the eigenvalues, $\\lambda_j$, of this operator. The Fourier analysis simplifies this by block-diagonalizing $\\mathcal{L}_{DG}$, allowing us to study a $(p+1)\\times(p+1)$ matrix for each nondimensional wavenumber $\\xi$. Its eigenvalues, $\\lambda_j(\\xi; \\theta, p)$, constitute the DG Fourier symbol.\n\nFirst, we characterize the effect of the parameter $\\theta$ on these eigenvalues. The numerical flux is $F^{*}(u^{-},u^{+}) = a\\,\\{u\\} \\;-\\; \\frac{a\\,\\theta}{2}\\,[u]$. This formulation interpolates between two key cases:\n*   For $\\theta=0$, the flux is the purely central flux, $F^*=a\\{u\\}$. For a skew-symmetric method like DG, the resulting spatial operator $\\mathcal{L}_{DG}$ is anti-adjoint with respect to a suitable inner product. Consequently, its eigenvalues $\\lambda_j(\\xi; 0, p)$ are purely imaginary.\n*   For $\\theta=1$, the flux becomes the fully upwind flux, $F^* = a u^-$ (since for $a>0$, $a\\{u\\} - \\frac{a}{2}[u] = a u^-$).\nThe term $-\\frac{a\\theta}{2}[u]$ introduces numerical dissipation. As $\\theta$ increases from $0$ to $1$, the amount of dissipation increases, which shifts the operator's eigenvalues from the imaginary axis into the left half of the complex plane (i.e., $\\text{Re}(\\lambda_j) \\le 0$).\n\nThe problem states that for an explicit time-stepping scheme, stability requires $\\Delta t |\\lambda_{\\max}| \\leq C_{\\text{stab}}$, where $C_{\\text{stab}}$ is a constant determined by the stability region of the scheme. With the given scaling $|\\lambda_{\\max}| \\propto (2p+1)a/h$, the CFL condition becomes:\n$$ \\frac{a \\Delta t}{h} \\le \\frac{C_{\\text{stab}}}{C(2p+1)} $$\nfor some constants $C$ and $C_{\\text{stab}}$. This demonstrates that the time step restriction becomes more severe as the polynomial degree $p$ increases.\n\nThe core of the problem lies in the interaction between the DG spectrum and the SSP-RK3 stability region. The stability condition is that the set of scaled eigenvalues $\\{ z_j = \\Delta t \\lambda_j \\}$ must be contained in $\\mathcal{S}_{RK3} = \\{ z \\in \\mathbb{C} : |R(z)| \\le 1 \\}$. The shape of $\\mathcal{S}_{RK3}$ is critical.\n- It is symmetric with respect to the real axis.\n- Its intersection with the imaginary axis is the interval $[-i\\sqrt{3}, i\\sqrt{3}]$.\n- Its intersection with the negative real axis is an interval approximately $[-2.5127, 0]$.\nThe region is notably narrow along the imaginary axis compared to its extent along the negative real axis.\n\nLet us analyze the behavior for different $\\theta$ and large $p$:\n- **Case $\\theta=0$ (Central Flux)**: The spectrum $\\{\\lambda_j\\}$ lies entirely on the imaginary axis. The spectral radius scales with $p$; let's denote it $\\omega_{\\max}(p) \\propto (2p+1)a/h$. The stability condition is $\\Delta t \\, \\omega_{\\max}(p) \\le \\sqrt{3}$. The allowable time step is severely restricted by the small extent of $\\mathcal{S}_{RK3}$ along the imaginary axis. The CFL number $\\frac{a \\Delta t}{h}$ scales as $1/(2p+1)$.\n\n- **Case $\\theta \\in (0, 1)$ (Mixed Flux)**: For any value of $\\theta$ less than $1$, the numerical flux retains a component of the central flux. The operator $\\mathcal{L}_{DG}(\\theta)$ can be seen as a perturbation of the anti-adjoint central flux operator. For large $p$, the high-frequency modes of the central flux operator dominate the imaginary extent of the spectrum. Thus, for any $\\theta  1$, the spectrum for large $p$ will extend far along the imaginary direction (or close to it). The allowable time step will continue to be limited by the narrow \"neck\" of the SSP-RK3 stability region around the imaginary axis. The maximum allowable Courant number will still scale as $1/(2p+1)$, with a proportionality constant that depends on $\\theta$, but this scaling remains fundamentally restrictive due to the spectrum's large imaginary part.\n\n- **Case $\\theta=1$ (Upwind Flux)**: When $\\theta=1$, the central flux component is completely eliminated. The numerical flux becomes the fully upwind flux, $F^* = a u^-$. The character of the DG spectrum changes fundamentally. The eigenvalues for the upwind scheme are known to lie within a circular or cardioid-like region in the left-half complex plane, tangent to the origin. Crucially, this spectral footprint does not extend indefinitely along the imaginary axis for large $p$. Instead, the entire scaled spectrum $\\frac{h}{a(2p+1)}\\sigma_p(1)$ remains confined to a bounded region. This bounded region \"fits\" much more efficiently into the wider part of the SSP-RK3 stability region, away from the restrictive imaginary axis. The resulting CFL limit, while still scaling as $1/(2p+1)$, has a significantly larger proportionality constant than for any $\\theta  1$ in the limit of large $p$.\n\nThe question asks for a single value of $\\theta$ that maximizes the allowable $\\Delta t$ for *all* $p \\ge 1$. For any choice of $\\theta'  1$, one can find a sufficiently large polynomial degree $p$ such that the time step restriction imposed by the large imaginary eigenvalues (due to the residual central flux component) becomes more severe than the restriction for the purely upwind scheme ($\\theta=1$). In the limit $p \\to \\infty$, the ratio of the allowable time step for $\\theta=1$ to that for any $\\theta'  1$ tends to infinity. Therefore, to ensure a robust and not overly restrictive CFL condition across all polynomial degrees, especially for high-order methods, the only rational choice is to completely eliminate the source of the restrictive behavior, which is the central flux component. This is achieved by setting $\\theta=1$.\n\nThis choice maximizes the allowable $\\Delta t$ in the sense that it yields the best asymptotic scaling behavior for large $p$, making it the superior choice for a method intended to work for all $p \\ge 1$.", "answer": "$$\\boxed{1}$$", "id": "3374451"}, {"introduction": "The CFL condition can be viewed not just as a constraint, but as a powerful tool for optimizing computational resources. This hands-on exercise [@problem_id:3374373] challenges you to design and implement a $p$-adaptive controller, a core component of modern high-order simulation codes. You will create an algorithm that uses the local Courant number, $C_K$, as a sensor to dynamically adjust the polynomial degree $p_K$ on each element, striving to equalize the stability margin across the entire mesh. This practice moves beyond static stability analysis to the design of intelligent, adaptive methods that automatically balance accuracy and efficiency.", "problem": "Design and implement a program that constructs an adaptive polynomial-degree controller for a one-dimensional discontinuous Galerkin method based on the Courant–Friedrichs–Lewy stability condition. Consider a mesh with elements indexed by $K$, each with characteristic size $h_K$ (in meters), local maximum characteristic speed $a_K$ (in meters per second), and a local polynomial degree $p_K$ (dimensionless). The time step is global and denoted by $\\Delta t$ (in seconds). Define the local Courant number as $C_K = \\dfrac{a_K \\,\\Delta t\\, (p_K + 1)}{h_K}$, a dimensionless quantity that measures the ratio between the numerical domain of dependence and the physical domain of dependence scaled by the local resolution. Assume an explicit time integrator that imposes a stability admissibility threshold $C_{\\mathrm{crit}}$ (dimensionless) such that a necessary linear stability condition is $C_K \\le C_{\\mathrm{crit}}$ for each element $K$. The integer polynomial degree is bounded by $p_{\\min} \\le p_K \\le p_{\\max}$.\n\nStarting from the fundamental definition of $C_K$ and the monotonic effect of $p_K$ on $C_K$ (strictly increasing in $p_K$ for $a_K \\Delta t / h_K  0$, and constant for $a_K = 0$), design a controller that:\n- Decreases $p_K$ wherever the local stability condition is violated.\n- Increases $p_K$ wherever the local stability condition allows and $\\Delta t$ is not the limiting factor.\n- Aims to equalize the local Courant numbers across the mesh as much as possible under the constraints.\n\nTo render the task well-posed and programmatically testable, implement the following precise controller semantics, derived from the above principles and the requirement to equalize the Courant numbers:\n- Stabilization phase: For each element $K$, while $C_K  C_{\\mathrm{crit}}$ and $p_K  p_{\\min}$, decrement $p_K \\leftarrow p_K - 1$ and update $C_K$ accordingly. After this phase, every element satisfies $C_K \\le C_{\\mathrm{crit}}$ or $p_K = p_{\\min}$.\n- Equalization phase (water-filling with stability): Repeatedly perform the following step until no change is possible:\n  - Identify the set of indices $S$ of elements that are eligible to increase, meaning $p_K  p_{\\max}$ and the incremented Courant number $C_K^{\\mathrm{new}} = \\dfrac{a_K \\,\\Delta t\\, (p_K + 2)}{h_K}$ would satisfy $C_K^{\\mathrm{new}} \\le C_{\\mathrm{crit}}$.\n  - If $S$ is empty, terminate. Otherwise, among $S$, select the element with the smallest current $C_K$; break ties by the smallest index $K$.\n  - Increase its degree: $p_K \\leftarrow p_K + 1$ and update $C_K$.\nThis controller maximizes the minimum $C_K$ subject to $C_K \\le C_{\\mathrm{crit}}$ and $p_{\\min} \\le p_K \\le p_{\\max}$ and enforces a deterministic tie-breaking, thereby producing a unique outcome.\n\nYour program must implement the above controller exactly and return, for each test case, the final vector of integers $[p_1,\\dots,p_{N}]$ after convergence of both phases. All physical quantities must be used with their specified units: $h_K$ in meters, $a_K$ in meters per second, and $\\Delta t$ in seconds. The output degrees $p_K$ are dimensionless integers.\n\nUse the following test suite. For each test case, the input is given in the order: the list $[h_K]$, the list $[a_K]$, the list $[p_K^{(0)}]$ of initial degrees, the scalar $\\Delta t$, the scalar $C_{\\mathrm{crit}}$, the integers $p_{\\min}$ and $p_{\\max}$. All lists are ordered by increasing element index.\n- Test case A (heterogeneous mesh with a tight element that must decrease): $[h_K] = [0.1,\\,0.05,\\,0.2,\\,0.04,\\,0.12]$, $[a_K] = [1.0,\\,0.8,\\,1.2,\\,1.5,\\,0.5]$, $[p_K^{(0)}] = [1,\\,2,\\,1,\\,3,\\,0]$, $\\Delta t = 0.01$, $C_{\\mathrm{crit}} = 0.9$, $p_{\\min} = 0$, $p_{\\max} = 5$.\n- Test case B (elements with zero speed, testing saturation at $p_{\\max}$): $[h_K] = [0.1,\\,0.1,\\,0.1]$, $[a_K] = [0.0,\\,1.0,\\,0.0]$, $[p_K^{(0)}] = [0,\\,0,\\,0]$, $\\Delta t = 0.02$, $C_{\\mathrm{crit}} = 0.6$, $p_{\\min} = 0$, $p_{\\max} = 7$.\n- Test case C (very small elements forcing degree reduction): $[h_K] = [0.005,\\,0.01,\\,0.03]$, $[a_K] = [2.0,\\,2.0,\\,2.0]$, $[p_K^{(0)}] = [3,\\,3,\\,3]$, $\\Delta t = 0.002$, $C_{\\mathrm{crit}} = 0.9$, $p_{\\min} = 0$, $p_{\\max} = 5$.\n- Test case D (already balanced, all can be raised to the stability limit): $[h_K] = [1.0,\\,1.0,\\,1.0,\\,1.0]$, $[a_K] = [1.0,\\,1.0,\\,1.0,\\,1.0]$, $[p_K^{(0)}] = [1,\\,1,\\,1,\\,1]$, $\\Delta t = 0.1$, $C_{\\mathrm{crit}} = 0.5$, $p_{\\min} = 0$, $p_{\\max} = 4$.\n\nYour program should produce a single line of output containing the final degree lists for all test cases as a comma-separated list enclosed in square brackets (e.g., $[rA,rB,rC,rD]$), where each $r\\cdot$ is itself a list of integers $[p_1,\\dots,p_{N}]$ for its test case. No additional text should be printed.", "solution": "The user has provided a problem that requires the design and implementation of an adaptive polynomial-degree controller for a one-dimensional discontinuous Galerkin (DG) method. The controller's logic is based on satisfying the Courant–Friedrichs–Lewy (CFL) stability condition.\n\n### Step 1: Extract Givens\n- **Mesh Elements**: Indexed by $K$.\n- **Element Size**: $h_K$ (meters).\n- **Characteristic Speed**: $a_K$ (meters/second).\n- **Polynomial Degree**: $p_K$ (dimensionless integer).\n- **Global Time Step**: $\\Delta t$ (seconds).\n- **Local Courant Number**: $C_K = \\dfrac{a_K \\,\\Delta t\\, (p_K + 1)}{h_K}$.\n- **Stability Condition**: $C_K \\le C_{\\mathrm{crit}}$ for all $K$.\n- **Stability Threshold**: $C_{\\mathrm{crit}}$ (dimensionless).\n- **Degree Bounds**: $p_{\\min} \\le p_K \\le p_{\\max}$.\n- **Controller Logic**:\n    1.  **Stabilization Phase**: For each element $K$, if $C_K  C_{\\mathrm{crit}}$ and $p_K  p_{\\min}$, repeatedly decrement $p_K$ by $1$ until the condition is met.\n    2.  **Equalization Phase**: Iteratively perform the following until no more changes occur:\n        a. Identify the set $S$ of elements where $p_K  p_{\\max}$ and incrementing $p_K$ would not violate the stability condition (i.e., $C_K^{\\mathrm{new}} = \\frac{a_K \\Delta t (p_K + 2)}{h_K} \\le C_{\\mathrm{crit}}$).\n        b. If $S$ is empty, terminate.\n        c. Otherwise, from $S$, select the element with the minimum current $C_K$. Ties are broken by choosing the element with the smallest index $K$.\n        d. Increment $p_K$ for the selected element and update its $C_K$.\n- **Inputs**: Test cases providing lists of $[h_K]$, $[a_K]$, initial $[p_K^{(0)}]$, and scalar parameters $\\Delta t$, $C_{\\mathrm{crit}}$, $p_{\\min}$, $p_{\\max}$.\n- **Output**: A list containing the final integer degree vectors $[p_1, \\dots, p_N]$ for each test case.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientific Grounding**: The problem is well-grounded in the numerical analysis of partial differential equations. The CFL condition and the concept of a p-adaptive DG method are standard and scientifically valid. The provided formula for the Courant number, $C_K$, is a common model for DG methods, which scales with polynomial degree $p_K$.\n- **Well-Posedness**: The controller logic is described by a deterministic algorithm. The stabilization phase must terminate as $p_K$ is an integer bounded below by $p_{\\min}$. The equalization phase is a greedy algorithm operating on a finite state space (since each $p_K$ is bounded), and each step monotonically increases one of the $p_K$ values. The strict tie-breaking rule ensures a unique execution path and a unique final state. Thus, a unique solution exists.\n- **Objectivity**: The problem is stated in precise, formal language. The controller's behavior is explicitly defined, leaving no room for subjectivity.\n- **Completeness and Consistency**: All necessary parameters and initial conditions are provided for each test case. The units are consistent ($a_K \\Delta t / h_K$ is dimensionless). The problem is self-contained and free of contradictions.\n\n### Step 3: Verdict and Action\nThe problem is valid. It is a well-defined computational task based on sound scientific principles. A solution will be developed based on the specified algorithm.\n\n### Algorithmic Design\n\nThe solution will be implemented as a Python program that processes a series of test cases. For each case, a function will execute the two-phase controller logic.\n\n1.  **Initialization**:\n    - The input lists for $h_K$, $a_K$, and $p_K^{(0)}$ will be converted to NumPy arrays for efficient vectorized computation. Let these be `h`, `a`, and `p`.\n    - To optimize performance, the constant factor for the Courant number calculation, $c_{\\mathrm{factor},K} = \\dfrac{a_K \\Delta t}{h_K}$, will be pre-computed for each element $K$. The Courant number is then $C_K = c_{\\mathrm{factor},K} (p_K + 1)$.\n    - The initial Courant numbers $C_K$ are calculated based on the initial degrees $p_K^{(0)}$.\n\n2.  **Phase 1: Stabilization**:\n    - The program will iterate through each element $K$.\n    - A `while` loop checks if the element violates the stability condition ($C_K  C_{\\mathrm{crit}}$) and if its degree can be reduced ($p_K  p_{\\min}$).\n    - If both are true, $p_K$ is decremented, and $C_K$ is re-computed. This loop continues until the element is stable or its degree reaches $p_{\\min}$.\n\n3.  **Phase 2: Equalization (Water-Filling)**:\n    - This phase is implemented within a main `while` loop that continues as long as at least one element's degree can be increased.\n    - In each iteration of this main loop:\n        a. A list of `eligible_candidates` is constructed. An element $K$ is eligible if its degree $p_K$ is less than $p_{\\max}$ and its potential new Courant number, upon incrementing $p_K$, does not exceed $C_{\\mathrm{crit}}$.\n        b. Each candidate is stored as a tuple `(C_K, K)` containing its current Courant number and its index.\n        c. If the list of candidates is empty, the main loop terminates, as the system has reached a stable, optimized state.\n        d. If there are candidates, the list is sorted. The primary sort key is $C_K$ (ascending), and the secondary key is the index $K$ (ascending). Python's default sort is stable, which, when applied to a list of tuples `(value, index)` created by iterating through indices in ascending order, automatically respects the tie-breaking rule.\n        e. The degree $p_K$ of the first element in the sorted list (the one with the minimum $C_K$, with ties broken by index) is incremented, and its $C_K$ is updated.\n    - This iterative process is analogous to \"water-filling,\" where we greedily \"pour\" degrees into the elements with the most \"capacity\" (lowest $C_K$) under the stability constraint.\n\n4.  **Final Output**:\n    - After the controller converges, the final NumPy array of degrees `p` is converted back to a Python list of integers.\n    - The results from all test cases are collected and formatted into a single string as specified by the problem, e.g., `[[p1,p2,...],[q1,q2,...]]`.\n\nThis design ensures a correct and efficient implementation of the specified deterministic controller.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_controller(h_k_list, a_k_list, p_k_initial_list, delta_t, c_crit, p_min, p_max):\n    \"\"\"\n    Implements the adaptive polynomial-degree controller based on the CFL condition.\n    \n    The controller operates in two phases:\n    1. Stabilization: Decrements polynomial degrees to satisfy the stability condition.\n    2. Equalization: Iteratively increases degrees for elements with the most\n       stability headroom, aiming to balance Courant numbers across the mesh.\n    \"\"\"\n    # Convert input lists to NumPy arrays for efficient vectorized operations.\n    h_k = np.array(h_k_list, dtype=np.float64)\n    a_k = np.array(a_k_list, dtype=np.float64)\n    p_k = np.array(p_k_initial_list, dtype=np.int64)\n    \n    num_elements = len(h_k)\n    \n    # Pre-calculate the constant part of the Courant number for each element.\n    # This avoids repeated floating-point divisions inside loops.\n    # Characteristic size h_k is assumed to be > 0.\n    c_factor = np.divide(a_k * delta_t, h_k, out=np.zeros_like(a_k, dtype=float), where=h_k!=0)\n\n    # Initialize local Courant numbers.\n    c_k = c_factor * (p_k.astype(np.float64) + 1.0)\n\n    # Phase 1: Stabilization\n    # For each element K, while C_K > C_crit and p_K > p_min, decrement p_K.\n    for k in range(num_elements):\n        while c_k[k] > c_crit and p_k[k] > p_min:\n            p_k[k] -= 1\n            c_k[k] = c_factor[k] * (p_k[k] + 1.0)\n\n    # Phase 2: Equalization (water-filling with stability)\n    # Repeatedly increase p_K for the most \"roomy\" eligible element.\n    while True:\n        eligible_candidates = []\n        for k in range(num_elements):\n            # Check eligibility: p_K  p_max...\n            if p_k[k]  p_max:\n                # ...and ensure the incremented Courant number is within the stability limit.\n                c_new = c_factor[k] * (p_k[k] + 2.0)\n                if c_new = c_crit:\n                    # A candidate is stored as a tuple (current C_K, index K)\n                    # for sorting according to the specified criteria.\n                    eligible_candidates.append((c_k[k], k))\n        \n        # If no elements are eligible for a degree increase, the process has converged.\n        if not eligible_candidates:\n            break\n\n        # Sort candidates to find the one with the smallest current C_K.\n        # Python's list.sort() is stable, so in case of a tie in C_K,\n        # the original order (by increasing index K) is preserved,\n        # fulfilling the tie-breaking rule.\n        eligible_candidates.sort()\n        \n        # Select the element to update (the first one after sorting).\n        k_to_increase = eligible_candidates[0][1]\n        \n        # Increase its polynomial degree and update its Courant number.\n        p_k[k_to_increase] += 1\n        c_k[k_to_increase] = c_factor[k_to_increase] * (p_k[k_to_increase] + 1.0)\n\n    return p_k.tolist()\n\ndef solve():\n    \"\"\"\n    Defines the test suite, runs the controller for each case,\n    and prints the results in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case A\n        {'h_k': [0.1, 0.05, 0.2, 0.04, 0.12], 'a_k': [1.0, 0.8, 1.2, 1.5, 0.5], 'p_k_initial': [1, 2, 1, 3, 0], 'delta_t': 0.01, 'c_crit': 0.9, 'p_min': 0, 'p_max': 5},\n        # Test Case B\n        {'h_k': [0.1, 0.1, 0.1], 'a_k': [0.0, 1.0, 0.0], 'p_k_initial': [0, 0, 0], 'delta_t': 0.02, 'c_crit': 0.6, 'p_min': 0, 'p_max': 7},\n        # Test Case C\n        {'h_k': [0.005, 0.01, 0.03], 'a_k': [2.0, 2.0, 2.0], 'p_k_initial': [3, 3, 3], 'delta_t': 0.002, 'c_crit': 0.9, 'p_min': 0, 'p_max': 5},\n        # Test Case D\n        {'h_k': [1.0, 1.0, 1.0, 1.0], 'a_k': [1.0, 1.0, 1.0, 1.0], 'p_k_initial': [1, 1, 1, 1], 'delta_t': 0.1, 'c_crit': 0.5, 'p_min': 0, 'p_max': 4}\n    ]\n\n    results = []\n    for case in test_cases:\n        final_p_k = run_controller(\n            case['h_k'],\n            case['a_k'],\n            case['p_k_initial'],\n            case['delta_t'],\n            case['c_crit'],\n            case['p_min'],\n            case['p_max']\n        )\n        results.append(final_p_k)\n\n    # Format the results into the required string format \"[[...],[...],...]\".\n    # The str() representation of a list includes brackets. Spaces are removed\n    # to match the compact output format example.\n    results_str = ','.join([str(res).replace(' ', '') for res in results])\n    print(f\"[{results_str}]\")\n\nsolve()\n```", "id": "3374373"}]}