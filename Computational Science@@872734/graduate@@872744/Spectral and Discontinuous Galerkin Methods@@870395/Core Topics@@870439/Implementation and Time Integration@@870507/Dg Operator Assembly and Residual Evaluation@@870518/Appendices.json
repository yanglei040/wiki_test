{"hands_on_practices": [{"introduction": "A crucial first step in developing scientific software is to verify its correctness against known analytical results. This practice guides you through a fundamental verification test for a Discontinuous Galerkin (DG) method. By implementing a scheme for the linear advection equation, you will numerically confirm a key theoretical property: the conservation of the total discrete mass (the integral of the solution) when using a central numerical flux on a periodic domain [@problem_id:3377756]. This exercise reinforces the structure of the strong-form DG residual and builds confidence in your implementation by ensuring it respects a fundamental physical law.", "problem": "Consider the linear advection initial value problem on a periodic one-dimensional domain,\n$$\nu_t + a\\,u_x = 0 \\quad \\text{on} \\quad x \\in [0,L],\n$$\nwith periodic boundary conditions and a dimensionless constant advection speed $a$. The goal is to construct a Discontinuous Galerkin (DG) verification test showing that the discrete integral of $u$ is invariant in time under the DG residual when using a central numerical flux.\n\nWork in the nodal collocation setting with Legendre-Gauss-Lobatto (LGL) nodes. Let each element be an affine map of the reference interval $r \\in [-1,1]$ to a physical element $x \\in [x_{e}, x_{e+1}]$ of uniform length $L_e$, with Jacobian $J_e = L_e/2$. Within each element, represent $u(r,t)$ at the $N+1$ LGL nodes $\\{r_i\\}_{i=0}^N$ using Lagrange interpolation and use LGL quadrature weights $\\{w_i\\}_{i=0}^N$. Let $D \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ be the differentiation matrix defined by the derivatives of the Lagrange basis polynomials evaluated at the LGL nodes.\n\nDefine the strong-form DG residual for the scalar advection flux $f(u) = a\\,u$ on element $e$ and node $i$ by\n$$\nR_i^{(e)} = -\\frac{2}{L_e}\\sum_{j=0}^N D_{ij}\\,f\\!\\left(u_j^{(e)}\\right) \\;+\\; \\frac{2}{L_e\\,w_i}\n\\Big( \\delta_{i,N}\\big(f^{*}_{\\text{right}} - f(u_N^{(e)})\\big) \\;-\\; \\delta_{i,0}\\big(f^{*}_{\\text{left}} - f(u_0^{(e)})\\big) \\Big),\n$$\nwhere $f^{*}_{\\text{left}}$ and $f^{*}_{\\text{right}}$ are the consistent numerical fluxes at the left and right interfaces of element $e$, respectively, and $\\delta_{i,k}$ is the Kronecker delta. Use the central numerical flux\n$$\nf^{*} = \\frac{1}{2}\\Big(f(u^{-}) + f(u^{+})\\Big) = \\frac{a}{2}\\Big(u^{-} + u^{+}\\Big),\n$$\nwhere $u^{-}$ and $u^{+}$ denote the interior and exterior traces at the interface. Enforce periodicity by taking the exterior trace at the domain boundaries from the opposite end of the mesh.\n\nDefine the discrete integral (with LGL quadrature) of the DG field $u$ as\n$$\nI[u] \\;=\\; \\sum_{e=1}^{E} \\sum_{i=0}^{N} J_e\\, w_i\\, u_i^{(e)}.\n$$\nYour task is to implement a program that:\n1. Constructs the LGL nodes, LGL weights, and the Lagrange differentiation matrix $D$ for any polynomial degree $N \\geq 1$.\n2. Builds a periodic mesh with $E$ elements over $[0,L]$ with uniform element size $L_e = L/E$.\n3. Assembles the DG strong-form residual $R_i^{(e)}$ using the central numerical flux and evaluates the discrete time derivative of the integral as\n$$\n\\frac{d}{dt} I[u] \\;=\\; \\sum_{e=1}^{E} \\sum_{i=0}^{N} J_e\\, w_i\\, R_i^{(e)}.\n$$\n4. Verifies the invariance of the discrete integral by checking that $\\left|\\frac{d}{dt}I[u]\\right|$ is below a prescribed tolerance for several test cases.\n\nAll quantities are to be treated as dimensionless. Angles do not appear in this problem. Use the following test suite, which specifies the mesh, polynomial order, domain length, advection speed, and initial condition. For each case, construct the nodal values $u_i^{(e)}$ by evaluating the given initial condition at the physical coordinates of the LGL nodes.\n\nTest suite:\n- Case 1 (smooth “happy path”): $E=4$, $N=3$, $L=1$, $a=1$, $u(x)=\\sin(2\\pi x/L)$.\n- Case 2 (discontinuous profile, negative speed): $E=3$, $N=2$, $L=2$, $a=-0.7$, $u(x)=\\begin{cases}1 & \\text{if } x<L/2,\\\\ 0 & \\text{otherwise.}\\end{cases}$\n- Case 3 (single element, higher order, random nodal values): $E=1$, $N=5$, $L=1$, $a=0.3$, $u$ is pseudo-random at nodes with a fixed seed for reproducibility.\n- Case 4 (many elements, lowest order): $E=8$, $N=1$, $L=1$, $a=3$, $u$ is pseudo-random at nodes with a fixed seed for reproducibility.\n- Case 5 (smooth with different domain length): $E=5$, $N=4$, $L=\\pi$, $a=2$, $u(x)=\\cos(x)$.\n\nTolerance specification:\n- Use a tolerance of $\\varepsilon = 5\\times 10^{-12}$ for the check $\\left|\\frac{d}{dt}I[u]\\right| \\le \\varepsilon$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., “[result1,result2,result3]”), where each result is a boolean indicating whether the invariance condition holds for that test case.", "solution": "The problem requires the verification of a conservation property for a nodal Discontinuous Galerkin (DG) method applied to the one-dimensional linear advection equation, $u_t + a\\,u_x = 0$. Specifically, we must show that the discrete spatial integral of the solution, $I[u]$, is invariant in time when using the prescribed strong-form DG residual with a central numerical flux. The time derivative of the discrete integral is given by\n$$\n\\frac{d}{dt} I[u] \\;=\\; \\sum_{e=1}^{E} \\sum_{i=0}^{N} J_e\\, w_i\\, R_i^{(e)}\n$$\nWe will first prove analytically that this quantity is zero up to machine precision, and then implement a numerical test to verify this conclusion for the provided test cases.\n\n**Theoretical Verification of Integral Invariance**\n\nThe core of the verification lies in a careful summation of the residual contributions across all elements in the periodic domain. The time derivative of the discrete integral $I[u]$ is given by the sum of the changes within each element. Let us analyze the contribution from a single element, $e$. This contribution is $Q^{(e)} = \\sum_{i=0}^{N} J_e\\, w_i\\, R_i^{(e)}$.\n\nSubstituting the given definition of the strong-form residual $R_i^{(e)}$:\n$$\nR_i^{(e)} = -\\frac{1}{J_e}\\sum_{j=0}^N D_{ij}\\,f_j^{(e)} \\;+\\; \\frac{1}{J_e\\,w_i} \\Big( \\delta_{i,N}\\big(f^{*}_{\\text{right}} - f_N^{(e)}\\big) \\;-\\; \\delta_{i,0}\\big(f^{*}_{\\text{left}} - f_0^{(e)}\\big) \\Big),\n$$\nwhere we use the notation $f_j^{(e)} = f(u_j^{(e)})$ and have substituted $J_e = L_e/2$. The contribution $Q^{(e)}$ becomes:\n$$\nQ^{(e)} = \\sum_{i=0}^{N} J_e w_i \\left[ -\\frac{1}{J_e}\\sum_{j=0}^N D_{ij}\\,f_j^{(e)} \\;+\\; \\frac{1}{J_e\\,w_i} \\Big( \\delta_{i,N}(f^{*}_{\\text{right}} - f_N^{(e)}) - \\delta_{i,0}(f^{*}_{\\text{left}} - f_0^{(e)}) \\Big) \\right]\n$$\nThe Jacobian $J_e$ cancels in both terms:\n$$\nQ^{(e)} = -\\sum_{i=0}^{N} w_i \\sum_{j=0}^{N} D_{ij}\\,f_j^{(e)} \\;+\\; \\sum_{i=0}^{N} \\Big( \\delta_{i,N}(f^{*}_{\\text{right}} - f_N^{(e)}) - \\delta_{i,0}(f^{*}_{\\text{left}} - f_0^{(e)}) \\Big)\n$$\nThe second term simplifies due to the Kronecker delta $\\delta_{i,k}$, which is $1$ if $i=k$ and $0$ otherwise. The sum over $i$ collapses, leaving only the terms for $i=0$ and $i=N$:\n$$\n\\sum_{i=0}^{N} \\Big( \\dots \\Big) = (f^{*}_{\\text{right}} - f_N^{(e)}) - (f^{*}_{\\text{left}} - f_0^{(e)})\n$$\nThe first term involves the differentiation matrix $D$ and the quadrature weights $w$. For a differentiation matrix based on Legendre-Gauss-Lobatto (LGL) nodes and the corresponding quadrature weights, they satisfy a Summation-By-Parts (SBP) property. Specifically, for any vector of nodal values $\\mathbf{g} = [g_0, \\dots, g_N]^T$ representing a polynomial of degree at most $N$, the discrete integral of its derivative is exact:\n$$\n\\sum_{i=0}^{N} w_i (D\\mathbf{g})_i = \\sum_{i=0}^{N} w_i \\sum_{j=0}^{N} D_{ij} g_j = g_N - g_0\n$$\nApplying this SBP property to our flux vector $\\mathbf{f}^{(e)}$, which represents a polynomial of degree $N$ since $f(u)=a\\,u$ is linear, we get:\n$$\n\\sum_{i=0}^{N} w_i \\sum_{j=0}^{N} D_{ij}\\,f_j^{(e)} = f_N^{(e)} - f_0^{(e)}\n$$\nSubstituting these results back into the expression for $Q^{(e)}$:\n$$\nQ^{(e)} = -(f_N^{(e)} - f_0^{(e)}) + (f^{*}_{\\text{right}} - f_N^{(e)}) - (f^{*}_{\\text{left}} - f_0^{(e)})\n$$\nThis can be rearranged to:\n$$\nQ^{(e)} = (f_0^{(e)} - f^{*}_{\\text{left}}) - (f_N^{(e)} - f^{*}_{\\text{right}})\n$$\nNow, we introduce the definition of the central numerical flux, $f^{*} = \\frac{1}{2}(f(u^{-}) + f(u^{+}))$. At the left interface of element $e$, the interior trace is $u^{-} = u_0^{(e)}$ and the exterior trace $u^{+}$ is the solution value from the right boundary of the neighboring element to the left, which we denote $u_N^{(e-1)}$. Thus,\n$$\nf^{*}_{\\text{left}} = f^{*}_{e-1/2} = \\frac{1}{2}\\Big(f(u_0^{(e)}) + f(u_N^{(e-1)})\\Big) = \\frac{1}{2}\\Big(f_0^{(e)} + f_N^{(e-1)}\\Big)\n$$\nSimilarly, at the right interface of element $e$, the interior trace is $u^{-} = u_N^{(e)}$ and the exterior trace is $u^{+} = u_0^{(e+1)}$. Thus,\n$$\nf^{*}_{\\text{right}} = f^{*}_{e+1/2} = \\frac{1}{2}\\Big(f(u_N^{(e)}) + f(u_0^{(e+1)})\\Big) = \\frac{1}{2}\\Big(f_N^{(e)} + f_0^{(e+1)}\\Big)\n$$\nSubstituting these into the expression for $Q^{(e)}$:\n$$\nQ^{(e)} = \\left(f_0^{(e)} - \\frac{1}{2}(f_0^{(e)} + f_N^{(e-1)})\\right) - \\left(f_N^{(e)} - \\frac{1}{2}(f_N^{(e)} + f_0^{(e+1)})\\right)\n$$\n$$\nQ^{(e)} = \\frac{1}{2}\\Big(f_0^{(e)} - f_N^{(e-1)}\\Big) - \\frac{1}{2}\\Big(f_N^{(e)} - f_0^{(e+1)}\\Big)\n$$\nThe total rate of change is the sum over all elements, $\\frac{d}{dt}I[u] = \\sum_{e=1}^{E} Q^{(e)}$. Due to the periodic domain, the element indices are taken modulo $E$.\n$$\n\\frac{d}{dt}I[u] = \\frac{1}{2} \\sum_{e=1}^{E} \\left[ \\Big(f_0^{(e)} - f_N^{(e-1)}\\Big) - \\Big(f_N^{(e)} - f_0^{(e+1)}\\Big) \\right]\n$$\nLet's examine the terms in this summation. The term $\\frac{1}{2}(f_0^{(e)} - f_N^{(e-1)})$ is associated with the interface between elements $e-1$ and $e$. The term $-\\frac{1}{2}(f_N^{(e)} - f_0^{(e+1)})$ is associated with the interface between elements $e$ and $e+1$. When we sum over all $e$, each interface is visited twice. For the interface between element $k$ and $k+1$, we get a contribution from $Q^{(k)}$ and $Q^{(k+1)}$:\n- From $Q^{(k)}$ (as the right interface): $-\\frac{1}{2}(f_N^{(k)} - f_0^{(k+1)})$\n- From $Q^{(k+1)}$ (as the left interface): $+\\frac{1}{2}(f_0^{(k+1)} - f_N^{(k)})$\nThese two terms are equal and opposite, summing to zero. This cancellation occurs at every interface within the domain. Because of periodicity, the interface between element $E$ and element $1$ also exhibits this cancellation. Therefore, the entire sum is a telescoping sum that evaluates to exactly zero.\n\nThis proves that for the given DG formulation with a central flux, the discrete integral is conserved regardless of the initial data. The numerical implementation should confirm this, with any non-zero result being attributable to floating-point arithmetic errors.\n\n**Algorithmic Implementation**\n\nThe numerical verification proceeds as follows:\n$1$. **LGL Utilities**: For each required polynomial degree $N$, we generate the $N+1$ Legendre-Gauss-Lobatto (LGL) nodes $\\{r_i\\}$, quadrature weights $\\{w_i\\}$, and the differentiation matrix $D$.\n    - The nodes $r_i$ are the roots of $(1-r^2)L'_N(r)$, where $L_N$ is the Legendre polynomial of degree $N$. The exterior nodes are always $r_0=-1$ and $r_N=1$. The interior nodes are the roots of $L'_N(r)$.\n    - The weights are given by the formula $w_i = \\frac{2}{N(N+1)L_N(r_i)^2}$.\n    - The off-diagonal entries of the differentiation matrix are $D_{ij} = \\frac{L_N(r_i)}{L_N(r_j)(r_i-r_j)}$ for $i \\neq j$. The diagonal entries are $D_{00} = -\\frac{N(N+1)}{4}$, $D_{NN} = \\frac{N(N+1)}{4}$, and $D_{ii}=0$ for $i \\in \\{1,\\dots,N-1\\}$.\n$2$. **Mesh and State Initialization**: A uniform periodic mesh of $E$ elements is created on $[0, L]$. The physical coordinates of all LGL nodes are determined using the affine mapping $x_i^{(e)} = x_e + (r_i+1)J_e$, where $J_e = L_e/2 = L/(2E)$. The nodal solution values $u_i^{(e)}$ are initialized by evaluating the specified initial condition function at these physical coordinates. For random cases, a pseudo-random number generator with a fixed seed is used to populate these values.\n$3$. **Residual and Integral Evaluation**: The program iterates through each element $e=1, \\dots, E$ to compute its contribution to $\\frac{d}{dt}I[u]$.\n    - For each element $e$, the nodal solution vector $\\mathbf{u}^{(e)}$ is used to form the flux vector $\\mathbf{f}^{(e)} = a\\,\\mathbf{u}^{(e)}$.\n    - The interior traces $u_0^{(e)}$ and $u_N^{(e)}$ are identified. The exterior trace values, $u_N^{(e-1)}$ and $u_0^{(e+1)}$, are retrieved from neighboring elements, respecting the mesh periodicity.\n    - The left and right numerical fluxes, $f^{*}_{\\text{left}}$ and $f^{*}_{\\text{right}}$, are computed using the central flux formula.\n    - The strong-form residual vector $\\mathbf{R}^{(e)}$ is assembled according to the provided equation.\n    - The contribution from this element to the time derivative of the integral, $Q^{(e)} = J_e \\mathbf{w}^T \\mathbf{R}^{(e)}$, is computed and added to a running total.\n$4$. **Verification**: After summing contributions from all elements, the absolute value of the total $\\frac{d}{dt}I[u]$ is compared against the specified tolerance $\\varepsilon = 5 \\times 10^{-12}$. The result for each test case is a boolean indicating whether the computed value is within this tolerance.", "answer": "```python\nimport numpy as np\nfrom scipy.special import legendre\n\ndef get_lgl_basis(N):\n    \"\"\"\n    Computes LGL nodes, weights, and differentiation matrix for a given degree N.\n    \"\"\"\n    if N == 0:\n        return np.array([-1.0]), np.array([2.0]), np.array([[0.0]])\n    \n    # Nodes are roots of (1-x^2) * L_N'(x)\n    # Interior nodes are roots of L_N'(x)\n    p_N = legendre(N)\n    p_N_prime_roots = p_N.deriv().roots\n    nodes = np.concatenate(([-1.0], np.sort(p_N_prime_roots), [1.0]))\n\n    # Weights\n    weights = 2.0 / (N * (N + 1) * (p_N(nodes)**2))\n\n    # Differentiation matrix\n    D = np.zeros((N + 1, N + 1))\n    for i in range(N + 1):\n        for j in range(N + 1):\n            if i != j:\n                D[i, j] = p_N(nodes[i]) / (p_N(nodes[j]) * (nodes[i] - nodes[j]))\n    \n    D[0, 0] = -N * (N + 1) / 4.0\n    D[N, N] = N * (N + 1) / 4.0\n    \n    return nodes, weights, D\n\n# Cache for LGL basis to avoid recomputation\nLGL_CACHE = {}\n\ndef get_cached_lgl_basis(N):\n    if N not in LGL_CACHE:\n        LGL_CACHE[N] = get_lgl_basis(N)\n    return LGL_CACHE[N]\n\ndef calculate_dIdt(E, N, L, a, u_func, is_random=False, rng=None):\n    \"\"\"\n    Calculates the discrete time derivative of the integral I[u] for a given test case.\n    \"\"\"\n    # 1. Construct LGL basis\n    r, w, D = get_cached_lgl_basis(N)\n    \n    # 2. Build periodic mesh and initialize solution\n    Le = L / E\n    Je = Le / 2.0\n    \n    # Element boundaries\n    x_bounds = np.linspace(0, L, E + 1)\n    \n    # Store all nodal values for easy access to neighbors\n    u_all = np.zeros((E, N + 1))\n    \n    if is_random:\n        u_all = rng.random((E, N + 1))\n    else:\n        for e in range(E):\n            x_e_start = x_bounds[e]\n            # Map reference nodes to physical nodes for this element\n            x_nodes_e = x_e_start + (r + 1) * Je\n            u_all[e, :] = u_func(x_nodes_e, L)\n\n    # 3. Assemble residual and evaluate discrete time derivative of the integral\n    dIdt = 0.0\n    \n    for e in range(E):\n        u_e = u_all[e, :]\n        f_e = a * u_e\n        \n        # Volume term contribution to the residual\n        R_vol = -(1.0 / Je) * (D @ f_e)\n        \n        # Surface term contribution (flux corrections)\n        \n        # Left interface of element e\n        u_minus_left = u_e[0]\n        # Find left neighbor (periodic)\n        e_left = (e - 1 + E) % E\n        u_plus_left = u_all[e_left, N]\n        f_star_left = (a / 2.0) * (u_minus_left + u_plus_left)\n        \n        # Right interface of element e\n        u_minus_right = u_e[N]\n        # Find right neighbor (periodic)\n        e_right = (e + 1) % E\n        u_plus_right = u_all[e_right, 0]\n        f_star_right = (a / 2.0) * (u_minus_right + u_plus_right)\n        \n        # Complete residual R for element e\n        R_e = np.copy(R_vol)\n        R_e[N] += (1.0 / (Je * w[N])) * (f_star_right - f_e[N])\n        R_e[0] -= (1.0 / (Je * w[0])) * (f_star_left - f_e[0])\n        \n        # Add element's contribution to dI/dt\n        # This is sum_{i=0 to N} J_e * w_i * R_i^(e)\n        dIdt += Je * np.dot(w, R_e)\n        \n    return dIdt\n\n\ndef solve():\n    \"\"\"\n    Main solver function that runs all test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        # Case 1 (smooth “happy path”)\n        {'E': 4, 'N': 3, 'L': 1.0, 'a': 1.0, 'u_func': lambda x, L: np.sin(2 * np.pi * x / L)},\n        # Case 2 (discontinuous profile, negative speed)\n        {'E': 3, 'N': 2, 'L': 2.0, 'a': -0.7, 'u_func': lambda x, L: np.where(x < L / 2.0, 1.0, 0.0)},\n        # Case 3 (single element, higher order, random nodal values)\n        {'E': 1, 'N': 5, 'L': 1.0, 'a': 0.3, 'u_func': None, 'is_random': True, 'seed': 42},\n        # Case 4 (many elements, lowest order)\n        {'E': 8, 'N': 1, 'L': 1.0, 'a': 3.0, 'u_func': None, 'is_random': True, 'seed': 123},\n         # Case 5 (smooth with different domain length)\n        {'E': 5, 'N': 4, 'L': np.pi, 'a': 2.0, 'u_func': lambda x, L: np.cos(x)},\n    ]\n    \n    tolerance = 5e-12\n    results = []\n\n    for case in test_cases:\n        rng = None\n        if case.get('is_random', False):\n            rng = np.random.default_rng(seed=case['seed'])\n            \n        dIdt_val = calculate_dIdt(\n            E=case['E'], \n            N=case['N'], \n            L=case['L'], \n            a=case['a'], \n            u_func=case['u_func'],\n            is_random=case.get('is_random', False),\n            rng=rng\n        )\n        \n        results.append(abs(dIdt_val) <= tolerance)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3377756"}, {"introduction": "Building on the previous practice, we now investigate the theoretical underpinnings of why certain DG schemes are conservative. The choice of nodal points within an element is not merely a matter of convenience; it has profound implications for the properties of the resulting numerical operators. This exercise [@problem_id:3377712] contrasts Gauss-Lobatto-Legendre nodes, which satisfy the crucial Summation-By-Parts (SBP) property, with Gauss-Legendre nodes, which do not. You will quantify the \"face-volume mismatch\" and see firsthand how this abstract algebraic property translates into a concrete, measurable error in discrete conservation, providing a deeper understanding of what makes a DG scheme robust.", "problem": "Investigate how the choice of nodal distribution affects operator assembly and residual evaluation in the Discontinuous Galerkin (DG) method for a one-dimensional linear advection equation. Specifically, compare Gauss–Lobatto–Legendre nodes with Gauss–Legendre nodes in terms of face–volume coupling and discrete conservation properties when assembling a strong-form DG residual from a weak-form discretization using the Summation-By-Parts (SBP) identity.\n\nConsider the one-dimensional linear advection equation\n$$\nu_t + a\\,u_x = 0\n$$\non the domain $[0,1]$ with periodic boundary conditions, where $a$ is a constant advection speed. Partition the domain into $N_e$ uniform elements of size $h = 1/N_e$, each mapped to the reference interval $[-1,1]$ via $x = x_L + \\tfrac{h}{2}(r+1)$, where $x_L$ is the left endpoint of the element and $r \\in [-1,1]$ is the reference coordinate. Let the Jacobian of the mapping be $J = h/2$.\n\nUse a nodal Lagrange polynomial basis of degree $p$ on each element with $N = p+1$ nodes. Investigate two nodal distributions:\n- Gauss–Lobatto–Legendre nodes, which include the endpoints $-1$ and $1$.\n- Gauss–Legendre nodes, which exclude the endpoints.\n\nDefine the diagonal quadrature-based mass matrix $M \\in \\mathbb{R}^{N \\times N}$ with entries given by the quadrature weights, the nodal differentiation matrix $D \\in \\mathbb{R}^{N \\times N}$ associated with the Lagrange basis, the restriction operator $R \\in \\mathbb{R}^{2 \\times N}$ that evaluates nodal polynomials at the two faces $r=-1$ and $r=1$, and the face orientation matrix $B = \\mathrm{diag}(-1,1)$. The Summation-By-Parts (SBP) identity on the reference element is\n$$\nD^\\top M = - M D + R^\\top B R.\n$$\nThis identity holds exactly for Gauss–Lobatto–Legendre collocation, but not for Gauss–Legendre collocation.\n\nStarting from the weak-form DG discretization on the reference element,\n$$\nM\\,J\\,\\dot{u} = -a\\,D^\\top M\\,u + R^\\top B\\,f^\\ast,\n$$\nwhere $f^\\ast$ is the two-component numerical flux vector at the element faces, derive the strong-form DG residual by substituting the SBP identity, yielding\n$$\n\\dot{u} = \\frac{a}{J} D\\,u + \\frac{1}{J} M^{-1} R^\\top B \\left(f^\\ast - a\\,R\\,u\\right).\n$$\nAssemble this strong-form residual element-wise using periodic boundary conditions and the upwind numerical flux for $a>0$, namely $f^\\ast = a\\,u^{-}$ on each face, where $u^{-}$ is the interior trace from the upwind side. For periodic boundaries, the left face flux of an element is taken from the right face interior trace of its left neighbor.\n\nYou must quantify:\n1. The face–volume mismatch for each nodal distribution, defined as the Frobenius norm\n$$\n\\left\\| M D + D^\\top M - R^\\top B R \\right\\|_F,\n$$\ncomputed on the reference element.\n2. The discrete conservation error induced by assembling the strong-form residual using the SBP substitution. This is defined as the absolute value of the global mass rate\n$$\n\\left|\\sum_{e=1}^{N_e} J \\sum_{i=1}^{N} w_i\\,\\dot{u}_i^{(e)}\\right|,\n$$\nwhere $w_i$ are the quadrature weights, $J$ is the element Jacobian, and $\\dot{u}_i^{(e)}$ are the nodal time derivatives in element $e$ from the strong-form residual. For periodic boundaries and the exact weak form, this quantity should be exactly zero; any nonzero value reflects a loss of discrete conservation attributable to face–volume mismatch in the strong assembly.\n\nAngle units (for trigonometric initial data) must be in radians.\n\nYour program must implement:\n- Construction of Gauss–Legendre nodes and weights.\n- Construction of Gauss–Lobatto–Legendre nodes and weights, using roots of the derivative of the Legendre polynomial $P_{N-1}'$ (equivalently, roots of the Jacobi polynomial $P_{N-2}^{(1,1)}$) for interior nodes, and exact endpoint inclusion.\n- Barycentric weights for nodal Lagrange interpolation.\n- The nodal differentiation matrix $D$ via barycentric weights.\n- The restriction operator $R$ that evaluates nodal polynomials at $r=-1$ and $r=1$ via barycentric interpolation.\n- Assembly of the strong-form DG residual using the formula above, periodic connectivity, and upwind flux for $a>0$.\n\nTest Suite:\nProvide three test cases to evaluate different aspects:\n- Case $1$ (general/happy path): $p=4$, $N_e=4$, $a=1.0$, initial condition $u(x)=\\sin(2\\pi x)$.\n- Case $2$ (single element periodic boundary): $p=5$, $N_e=1$, $a=1.0$, initial condition $u(x)$ equal to the Legendre polynomial $P_p(r)$ evaluated on each element in reference coordinates $r$.\n- Case $3$ (edge case with under-resolution): $p=2$, $N_e=3$, $a=1.0$, initial condition $u(x)=\\sin(10\\pi x)$.\n\nFor each case, compute and report four floats in the following fixed order:\n- Face–volume mismatch norm for Gauss–Lobatto–Legendre nodes.\n- Face–volume mismatch norm for Gauss–Legendre nodes.\n- Discrete conservation error (absolute global mass rate) for Gauss–Lobatto–Legendre nodes.\n- Discrete conservation error (absolute global mass rate) for Gauss–Legendre nodes.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered by concatenating the four outputs for Case $1$, then Case $2$, then Case $3$:\n$$\n[\\text{C1\\_GLL\\_mismatch},\\text{C1\\_GL\\_mismatch},\\text{C1\\_GLL\\_cons\\_err},\\text{C1\\_GL\\_cons\\_err},\\text{C2\\_GLL\\_mismatch},\\text{C2\\_GL\\_mismatch},\\text{C2\\_GLL\\_cons\\_err},\\text{C2\\_GL\\_cons\\_err},\\text{C3\\_GLL\\_mismatch},\\text{C3\\_GL\\_mismatch},\\text{C3\\_GLL\\_cons\\_err},\\text{C3\\_GL\\_cons\\_err}]\n$$\nAll outputs must be real numbers (floats).", "solution": "The problem requires an investigation into the effects of nodal distribution—specifically, Gauss–Lobatto–Legendre (GLL) versus Gauss–Legendre (GL) nodes—on operator assembly and conservation properties in a Discontinuous Galerkin (DG) method. The analysis is performed for the one-dimensional linear advection equation, $u_t + a\\,u_x = 0$, discretized using a nodal DG approach on a reference element interval $r \\in [-1,1]$.\n\n**1. Nodal Basis and Quadrature**\n\nThe solution on each element is approximated by a polynomial of degree $p$ constructed from a Lagrange basis defined on a set of $N=p+1$ nodes.\n- **Gauss–Lobatto–Legendre (GLL) nodes:** These $N$ nodes include the endpoints $r=\\{-1, 1\\}$. The $N-2$ interior nodes are the roots of the derivative of the $p$-th degree Legendre polynomial, $P_p'(r)$, which are equivalent to the roots of the Jacobi polynomial $P_{p-2}^{(1,1)}(r)$. This choice is crucial as it leads to an exact Summation-By-Parts (SBP) property.\n- **Gauss–Legendre (GL) nodes:** These $N$ nodes are the roots of the $(p+1)$-th degree Legendre polynomial, $P_{p+1}(r)$. They are all located in the interior of the interval $(-1,1)$. This choice results in a higher-order accurate quadrature rule but does not satisfy the SBP property exactly.\n\nFor each nodal set, we define a diagonal mass matrix $M$, whose entries $M_{ii}$ are the corresponding quadrature weights $w_i$.\n\n**2. Differentiation and Restriction Operators**\n\n- **Differentiation Matrix ($D$):** The nodal differentiation matrix $D$ is constructed such that for a vector $u$ of nodal values, $D u$ gives the nodal values of the derivative of the corresponding interpolating polynomial. It is computed efficiently using barycentric interpolation weights.\n- **Restriction Operator ($R$):** The restriction operator $R \\in \\mathbb{R}^{2 \\times N}$ evaluates the polynomial at the element faces, $r=-1$ and $r=1$. For GLL nodes, which include the endpoints, $R$ is a sparse matrix of zeros with a $1$ in the columns corresponding to the endpoint nodes. For GL nodes, $R$ is dense and its entries are computed using the barycentric formula for Lagrange interpolation at $r=\\{-1, 1\\}$.\n\n**3. The Summation-By-Parts (SBP) Property and Face–Volume Mismatch**\n\nThe SBP property is a discrete analogue of integration by parts and is fundamental to proving the stability and conservation of high-order numerical schemes. For our nodal DG setting, it is expressed as:\n$$\nD^\\top M + M D = R^\\top B R\n$$\nwhere $B = \\mathrm{diag}(-1,1)$ is the face orientation matrix. This identity states that the differentiation operator is skew-symmetric up to a boundary term. A key theoretical result is that this identity holds *exactly* for GLL nodes and their corresponding quadrature rule. For GL nodes, it does not.\n\nTo quantify this, we compute the **face–volume mismatch**, defined by the Frobenius norm of the SBP error matrix:\n$$\n\\text{mismatch} = \\left\\| M D + D^\\top M - R^\\top B R \\right\\|_F\n$$\nFor GLL nodes, this norm will be zero up to machine precision. For GL nodes, it will be non-zero, indicating a discrepancy between the volume integral term (left side) and the face integral term (right side) in the discrete integration-by-parts identity.\n\n**4. Weak vs. Strong Form and the Role of SBP**\n\nThe problem provides a starting weak-form DG discretization on the reference element:\n$$\nM\\,J\\,\\dot{u} = -a\\,D^\\top M\\,u + R^\\top B\\,f^\\ast\n$$\nHere, $J$ is the Jacobian of the mapping, $\\dot{u}$ is the vector of nodal time derivatives, and $f^\\ast$ is the numerical flux vector at the element faces.\n\nA \"strong form\" can be derived by formally substituting the SBP identity ($D^\\top M = -MD + R^\\top B R$) into the weak form. This yields the expression for the residual used in the computation:\n$$\n\\dot{u} = \\frac{a}{J} D\\,u + \\frac{1}{J} M^{-1} R^\\top B \\left(f^\\ast - a\\,R\\,u\\right)\n$$\nThe term $f^\\ast - a\\,R\\,u$ represents the difference between the numerical flux and the physical flux, $f(u)=au$, traced to the element boundary. For the upwind flux ($f^\\ast = au^-$ with $a>0$) on periodic elements, this difference is non-zero only at the left face of each element, where it is proportional to the jump in the solution.\n\n**5. Discrete Conservation and its Error**\n\nThe global rate of change of mass is given by $\\frac{d}{dt} \\sum_{e} \\int_{K_e} u \\,dx$, which discretizes to $\\sum_e J \\sum_i w_i \\dot{u}_i^{(e)}$. The problem states that for the exact weak form with periodic boundaries, this quantity is zero, meaning the method is discretely conservative.\n\nWhen we compute $\\dot{u}$ using the strong form derived via the SBP substitution, we can measure the induced **discrete conservation error**:\n$$\n\\text{error} = \\left|\\sum_{e=1}^{N_e} J \\sum_{i=1}^{N} w_i\\,\\dot{u}_i^{(e)}\\right|\n$$\n- For **GLL nodes**, the SBP substitution is exact. The derived strong form is algebraically equivalent to the conservative weak form. Therefore, the computed conservation error is expected to be near zero (machine precision).\n- For **GL nodes**, the SBP substitution is inexact due to the non-zero face–volume mismatch. The derived strong form is therefore not equivalent to the original weak form. This algebraic inconsistency breaks the cancellation of terms that ensures conservation, leading to a non-zero conservation error.\n\nThe implementation systematically constructs these operators for both nodal types, assembles the strong-form residual element by element with periodic connectivity, and then computes the two specified metrics (mismatch norm and conservation error) for each test case. This quantitatively demonstrates the crucial role of the SBP property in linking operator structure to fundamental conservation laws in DG methods.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_jacobi, eval_legendre, roots_legendre, legendre\n\ndef gauss_lobatto_legendre_nodes_weights(p):\n    \"\"\"\n    Computes Gauss-Lobatto-Legendre nodes and weights for polynomial degree p.\n    Nodes are roots of (1-x^2)P_p'(x).\n    \"\"\"\n    N = p + 1\n    if N == 1:\n        return np.array([0.0]), np.array([2.0])\n    \n    # Nodes are -1, 1, and roots of P_p'(x), which are roots of Jacobi P_{p-1}^{(1,1)}(x)\n    # The degree of the Jacobi polynomial is p-1 = N-2.\n    interior_nodes = roots_jacobi(p - 1, 1, 1)[0] if p > 1 else np.array([])\n    nodes = np.concatenate(([-1.0], interior_nodes, [1.0]))\n    \n    # Weights using formula: w_i = 2 / (p*(p+1) * [P_p(x_i)]^2)\n    Pn = legendre(p)\n    weights = 2 / (p * N * Pn(nodes)**2)\n    \n    idx = np.argsort(nodes)\n    nodes = nodes[idx]\n    weights = weights[idx]\n    \n    return nodes, weights\n\ndef gauss_legendre_nodes_weights(p):\n    \"\"\"\n    Computes Gauss-Legendre nodes and weights for polynomial degree p.\n    Uses N=p+1 points. Nodes are roots of P_{p+1}(x).\n    \"\"\"\n    N = p + 1\n    nodes, weights = roots_legendre(N)\n    \n    idx = np.argsort(nodes)\n    nodes = nodes[idx]\n    weights = weights[idx]\n    \n    return nodes, weights\n\ndef barycentric_weights(nodes):\n    \"\"\"\n    Computes barycentric weights for Lagrange interpolation.\n    \"\"\"\n    N = len(nodes)\n    weights = np.ones(N)\n    for j in range(N):\n        for k in range(N):\n            if k != j:\n                weights[j] /= (nodes[j] - nodes[k])\n    return weights\n\ndef differentiation_matrix(nodes, bary_weights):\n    \"\"\"\n    Computes the nodal differentiation matrix using the barycentric formula.\n    \"\"\"\n    N = len(nodes)\n    D = np.zeros((N, N))\n    for i in range(N):\n        sum_row = 0.0\n        for j in range(N):\n            if i != j:\n                D[i, j] = (bary_weights[j] / bary_weights[i]) / (nodes[i] - nodes[j])\n                sum_row += D[i, j]\n        D[i, i] = -sum_row\n    return D\n\ndef restriction_operator(nodes, bary_weights):\n    \"\"\"\n    Computes the restriction operator R for evaluating polynomials at r=-1 and r=1.\n    \"\"\"\n    N = len(nodes)\n    R = np.zeros((2, N))\n    \n    # Evaluation at r = -1\n    # Check if -1 is a node to avoid division by zero\n    if np.any(np.isclose(nodes, -1.0)):\n        idx = np.where(np.isclose(nodes, -1.0))[0][0]\n        R[0, idx] = 1.0\n    else:\n        # Use barycentric formula for L_j(-1)\n        terms = bary_weights / (-1.0 - nodes)\n        R[0, :] = terms / np.sum(terms)\n\n    # Evaluation at r = 1\n    if np.any(np.isclose(nodes, 1.0)):\n        idx = np.where(np.isclose(nodes, 1.0))[0][0]\n        R[1, idx] = 1.0\n    else:\n        # Use barycentric formula for L_j(1)\n        terms = bary_weights / (1.0 - nodes)\n        R[1, :] = terms / np.sum(terms)\n        \n    return R\n\ndef run_case(p, Ne, a, ic_func):\n    \"\"\"\n    Runs a single test case for both GLL and GL nodes, returning a list of 4 results.\n    \"\"\"\n    N = p + 1\n    h = 1.0 / Ne\n    J = h / 2.0\n    B = np.diag([-1.0, 1.0])\n    \n    case_results = []\n    \n    # --- Process for both GLL and GL node types ---\n    node_types = ['GLL', 'GL']\n    for node_type in node_types:\n        if node_type == 'GLL':\n            nodes, weights = gauss_lobatto_legendre_nodes_weights(p)\n            R = np.zeros((2, N))\n            R[0, 0] = 1.0 # Node 0 is at -1\n            R[1, -1] = 1.0# Node N-1 is at 1\n        else: # GL\n            nodes, weights = gauss_legendre_nodes_weights(p)\n            bary_w = barycentric_weights(nodes)\n            R = restriction_operator(nodes, bary_w)\n\n        bary_weights = barycentric_weights(nodes)\n        D = differentiation_matrix(nodes, bary_weights)\n        M = np.diag(weights)\n\n        # 1. Face-volume mismatch norm\n        mismatch_norm = np.linalg.norm(M @ D + D.T @ M - R.T @ B @ R, 'fro')\n        \n        # 2. Discrete conservation error\n        # Initialize solution vector over all elements\n        u_global = np.zeros((Ne, N))\n        for e in range(Ne):\n            x_L = e * h\n            x_phys = x_L + J * (nodes + 1.0)\n            u_global[e, :] = ic_func(x_phys)\n            \n        u_dot_global = np.zeros((Ne, N))\n        M_inv = np.diag(1.0 / weights)\n    \n        # Assemble strong-form residual for all elements\n        for e in range(Ne):\n            u_e = u_global[e, :]\n            e_minus = (e - 1 + Ne) % Ne # Periodic neighbor\n            u_e_minus = u_global[e_minus, :]\n            \n            # For a > 0, upwind flux is determined by the state on the left.\n            # Upwind value for left face of element 'e' is trace from right face of 'e_minus'.\n            u_trace_left_neighbor_right = (R @ u_e_minus)[1]\n            # Interior value for left face of element 'e'.\n            u_trace_self_left = (R @ u_e)[0]\n\n            # The flux difference term: f* - a*R*u\n            flux_diff = np.zeros(2)\n            # At left face (r=-1): a*u_minus - a*u_plus = a * (jump)\n            flux_diff[0] = a * (u_trace_left_neighbor_right - u_trace_self_left)\n            # At right face (r=+1): a*u_minus - a*u_plus = a*u_self - a*u_self = 0\n            flux_diff[1] = 0.0\n            \n            # Strong form residual calculation\n            vol_term = (a / J) * (D @ u_e)\n            surf_term = (1.0 / J) * (M_inv @ R.T @ B @ flux_diff)\n            u_dot_global[e, :] = vol_term + surf_term\n            \n        # Compute global mass rate\n        global_mass_rate = 0.0\n        for e in range(Ne):\n            global_mass_rate += J * np.sum(weights * u_dot_global[e, :])\n        cons_err = np.abs(global_mass_rate)\n        \n        case_results.extend([mismatch_norm, cons_err])\n        \n    # Reorder to match GLL_mismatch, GL_mismatch, GLL_cons_err, GL_cons_err\n    return [case_results[0], case_results[2], case_results[1], case_results[3]]\n\ndef solve():\n    # Define test cases: (p, Ne, a, initial_condition_function)\n    test_cases = [\n        # Case 1: General case\n        (4, 4, 1.0, lambda x: np.sin(2 * np.pi * x)),\n        # Case 2: Single element, polynomial IC\n        (5, 1, 1.0, lambda x: eval_legendre(5, 2 * x - 1)),\n        # Case 3: Under-resolved wave\n        (2, 3, 1.0, lambda x: np.sin(10 * np.pi * x))\n    ]\n\n    final_results = []\n    for p, Ne, a, ic_func in test_cases:\n        # returns [GLL_mismatch, GL_mismatch, GLL_cons_err, GL_cons_err]\n        case_results = run_case(p, Ne, a, ic_func)\n        final_results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n\n```", "id": "3377712"}, {"introduction": "Beyond operator structure, the accuracy of numerical integration is another critical aspect of a reliable DG method, especially for problems with nonlinear fluxes. This practice explores a subtle but important source of error: under-integration of face terms. You will work with a specially constructed nonlinear flux whose divergence is analytically zero, meaning it should not contribute to any change in the cell average [@problem_id:3377711]. By varying the accuracy of the face quadrature rule, you will discover that this conservation property is only upheld discretely if the integration is sufficiently precise, demonstrating how numerical approximations can violate fundamental physical principles if not handled with care.", "problem": "Consider a two-dimensional conservation law in divergence form, discretized by the Discontinuous Galerkin (DG) method. Let the spatial domain be the unit square $\\Omega = [0,1]\\times[0,1]$, partitioned into a Cartesian mesh with $N_x$ rectangular elements in the $x$-direction and $N_y$ rectangular elements in the $y$-direction. Each element $K$ carries a local polynomial approximation space of total degree $p$, denoted by $P_p$. Let the exact state be a globally smooth polynomial solution $u \\in P_p$ with total degree $p$ on $\\Omega$. Define the nonlinear flux field\n$$\n\\mathbf{F}(u,\\nabla u) = \\left(\\Psi'(u)\\,\\partial_{y}u,\\; -\\,\\Psi'(u)\\,\\partial_{x}u\\right),\n$$\nwhere $\\Psi(u) = u^{m}$ with integer $m \\ge 2$, so that $\\Psi'(u) = m\\,u^{m-1}$. By the equality of mixed partial derivatives, the continuous divergence of this flux satisfies\n$$\n\\nabla\\cdot\\mathbf{F}(u,\\nabla u) = \\partial_x\\left(\\Psi'(u)\\,\\partial_y u\\right) + \\partial_y\\left(-\\,\\Psi'(u)\\,\\partial_x u\\right) = \\partial_x\\partial_y \\Psi(u) - \\partial_y\\partial_x \\Psi(u) = 0.\n$$\nTherefore, the exact continuous time derivative of any cell average of $u$ vanishes for this flux.\n\nIn the semi-discrete DG formulation for a conservation law, the residual of the element $K$ with the constant test function $\\phi \\equiv 1$ reduces to pure face contributions,\n$$\nR_K = \\sum_{f \\subset \\partial K} \\int_{f} \\widehat{\\mathbf{F}}(u,\\nabla u)\\cdot \\mathbf{n}_K \\,\\mathrm{d}s,\n$$\nwhere $\\widehat{\\mathbf{F}}$ is a consistent numerical flux and $\\mathbf{n}_K$ is the outward unit normal on each face of $K$. For a smooth polynomial $u$ with no jump across interior faces and a central flux, $\\widehat{\\mathbf{F}}$ equals the physical flux $\\mathbf{F}$ on all faces. The exact continuous value of $R_K$ is zero for all $K$ because $\\nabla\\cdot\\mathbf{F}=0$. However, in practice, the face integrals are approximated by a one-dimensional Gaussian quadrature of order $q_f$, and the integrand $\\mathbf{F}\\cdot \\mathbf{n}_K$ is a polynomial of degree\n$$\nd = (m-1)\\,p + (p-1),\n$$\non each straight face. An order-$q_f$ Gauss–Legendre quadrature integrates exactly any polynomial up to degree $2q_f - 1$. Consequently, unless $2q_f - 1 \\ge d$, the DG residual $R_K$ will suffer underintegration error, and the computed cell-average conservation will be violated, even though the true continuous residual is zero.\n\nTask: Implement a program that assembles the DG residual $R_K$ with central flux for the given $\\mathbf{F}$ and a polynomial $u \\in P_p$, using face Gaussian quadrature of order $q_f$. Quantify conservation error by computing the absolute global conservation defect\n$$\nE(q_f) = \\left| \\sum_{K} R_K \\right|,\n$$\nfor several test cases. The function $u(x,y)$ is to be defined as a fixed polynomial of total degree $p$ with deterministic coefficients:\n$$\nu(x,y) = \\sum_{a=0}^{p}\\sum_{b=0}^{p-a} c_{a,b}\\, x^{a} y^{b}, \\quad c_{a,b} = \\frac{1}{a+b+1}.\n$$\nUse the exact analytic partial derivatives for $\\partial_x u$ and $\\partial_y u$ in the flux. The mesh is uniform with element sizes $h_x = 1/N_x$ and $h_y = 1/N_y$, and the outward normals on faces are aligned with Cartesian axes. Face integrals must be computed by Gauss–Legendre quadrature of order $q_f$ along the corresponding one-dimensional face segment. No volume quadrature is needed because the test function $\\phi \\equiv 1$ eliminates the volume terms for this flux.\n\nDefine the following test suite of parameter tuples $(p,m,N_x,N_y,q_f)$:\n- Test 1 (severe underintegration): $(3,3,4,4,1)$\n- Test 2 (near-threshold underintegration): $(3,3,4,4,4)$\n- Test 3 (threshold order): $(3,3,4,4,5)$\n- Test 4 (overintegration): $(3,3,4,4,7)$\n- Test 5 (simpler polynomial, overintegration): $(2,2,3,3,3)$\n\nFor each test, compute $E(q_f)$ as a floating-point number. The program should produce a single line of output containing all five results formatted as a comma-separated list enclosed in square brackets, in the order of the tests above, for example, $\\texttt{[r_1,r_2,r_3,r_4,r_5]}$, where each $r_i$ is the value of $E(q_f)$ for Test $i$.\n\nThere are no physical units involved in this problem. All angles, if any appear, are to be interpreted in radians. The final outputs are floating-point numbers.\n\nYour implementation must be a complete, runnable program in a modern programming language and must not require any external input. It must numerically assemble the face contributions based on the specified polynomial $u$, compute the DG residuals with the chosen face quadrature orders, and report the conservation defects for the test suite in the exact specified output format.", "solution": "The user provides a valid problem statement.\n\n**Problem Formulation and Analysis**\n\nThe problem requires the calculation of the global conservation defect for a Discontinuous Galerkin (DG) discretization of a specific two-dimensional conservation law. The conservation law is given by $\\partial_t u + \\nabla \\cdot \\mathbf{F}(u, \\nabla u) = 0$, where the flux function is $\\mathbf{F} = (\\Psi'(u)\\,\\partial_{y}u, -\\Psi'(u)\\,\\partial_{x}u)$ with $\\Psi(u) = u^m$. A key property of this flux is that its divergence is identically zero, $\\nabla \\cdot \\mathbf{F} = 0$, for any sufficiently smooth solution $u$. This is a consequence of the equality of mixed partial derivatives:\n$$\n\\nabla \\cdot \\mathbf{F} = \\partial_x(\\Psi'(u)\\,\\partial_y u) + \\partial_y(-\\Psi'(u)\\,\\partial_x u) = \\partial_x\\partial_y\\Psi(u) - \\partial_y\\partial_x\\Psi(u) = 0.\n$$\n\nThe semi-discrete DG formulation for an element $K$ is obtained by multiplying the PDE by a test function $\\phi \\in P_p$, integrating over $K$, and applying the divergence theorem:\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t} \\int_K u_h \\phi \\, \\mathrm{d}V = \\int_K \\mathbf{F}(u_h, \\nabla u_h) \\cdot \\nabla \\phi \\, \\mathrm{d}V - \\int_{\\partial K} \\widehat{\\mathbf{F}}(u_h, \\nabla u_h) \\cdot \\mathbf{n}_K \\phi \\, \\mathrm{d}s.\n$$\nHere, $u_h$ is the polynomial approximation to $u$, $\\widehat{\\mathbf{F}}$ is a numerical flux, and $\\mathbf{n}_K$ is the outward unit normal to the boundary $\\partial K$.\n\nThe problem specifies using the constant test function $\\phi \\equiv 1$. For this choice, $\\nabla \\phi = \\mathbf{0}$, which eliminates the volume integral term. The residual for the cell average, $R_K$, simplifies to a sum of face integrals:\n$$\nR_K = \\int_{\\partial K} \\widehat{\\mathbf{F}}(u_h, \\nabla u_h) \\cdot \\mathbf{n}_K \\, \\mathrm{d}s = \\sum_{f \\subset \\partial K} \\int_{f} \\widehat{\\mathbf{F}} \\cdot \\mathbf{n}_K \\, \\mathrm{d}s.\n$$\nThe problem states that the exact solution $u$ is a globally smooth polynomial of total degree $p$. The DG approximation $u_h$ is taken to be this exact solution. Because $u_h$ is smooth, there are no jumps across element interfaces. The problem specifies a central numerical flux, which for a continuous solution reduces to the physical flux, i.e., $\\widehat{\\mathbf{F}} = \\mathbf{F}$.\n\nThe task is to compute the global conservation defect, $E(q_f) = |\\sum_K R_K|$. Crucially, the sum of residuals over all elements $K$ in the mesh exhibits a telescoping property. For any interior face $f$ shared by two elements $K_L$ and $K_R$, we have $\\mathbf{n}_{K_L} = -\\mathbf{n}_{K_R}$. The contribution to the total sum from this face is:\n$$\n\\int_f \\mathbf{F} \\cdot \\mathbf{n}_{K_L} \\, \\mathrm{d}s + \\int_f \\mathbf{F} \\cdot \\mathbf{n}_{K_R} \\, \\mathrm{d}s = \\int_f \\mathbf{F} \\cdot (\\mathbf{n}_{K_L} - \\mathbf{n}_{K_L}) \\, \\mathrm{d}s = 0.\n$$\nThis cancellation is perfect, even when the integrals are approximated by numerical quadrature, because the same quadrature rule is applied to integrands that are equal and opposite. Consequently, all interior face contributions cancel, and the global sum reduces to the sum of integrals over the faces on the boundary of the entire domain $\\Omega$:\n$$\n\\sum_K R_K = \\sum_{f \\subset \\partial\\Omega} \\int_f \\mathbf{F} \\cdot \\mathbf{n} \\, \\mathrm{d}s \\equiv \\oint_{\\partial\\Omega} \\mathbf{F} \\cdot \\mathbf{n} \\, \\mathrm{d}s.\n$$\nThis significantly simplifies the computation, as we only need to consider the four boundary segments of the unit square $[0,1] \\times [0,1]$. The mesh parameters $N_x$ and $N_y$ become irrelevant to the final value, as they only affect the number of interior faces that cancel out.\n\nThe continuous boundary integral is also zero due to the divergence theorem and the divergence-free nature of the flux: $\\oint_{\\partial\\Omega} \\mathbf{F} \\cdot \\mathbf{n} \\, \\mathrm{d}s = \\iint_\\Omega \\nabla \\cdot \\mathbf{F} \\, \\mathrm{d}V = \\iint_\\Omega 0 \\, \\mathrm{d}V = 0$.\nThe conservation defect $E(q_f)$ will be non-zero only if the numerical quadrature used to approximate the boundary integrals is not exact for the integrand.\n\nThe integrand on any face is a component of $\\mathbf{F} = (m u^{m-1} \\partial_y u, -m u^{m-1} \\partial_x u)$. Since $u$ is a polynomial of total degree $p$, its derivatives $\\partial_x u, \\partial_y u$ are polynomials of total degree $p-1$. The term $u^{m-1}$ is a polynomial of total degree $(m-1)p$. Thus, the integrand is a polynomial of degree $d = (m-1)p + (p-1)$. A Gauss-Legendre quadrature rule with $q_f$ points is exact for polynomials of degree up to $2q_f - 1$. Therefore, if $2q_f - 1 \\ge d$, the numerical quadrature will be exact, the computed boundary integral will be zero (up to machine precision), and $E(q_f)$ will be zero. If $2q_f - 1 < d$, quadrature error will occur, leading to a non-zero $E(q_f)$.\n\n**Algorithm**\n\n1.  **Define Test Cases**: Use the five provided tuples of $(p,m,N_x,N_y,q_f)$.\n2.  **Iterate through Test Cases**: For each case:\n    a. **Prepare Polynomial**: Construct the representation of the polynomial $u(x,y) = \\sum_{a=0}^{p}\\sum_{b=0}^{p-a} \\frac{1}{a+b+1} x^a y^b$ and functions to evaluate it and its partial derivatives, $\\partial_x u$ and $\\partial_y u$.\n    b. **Get Quadrature Rule**: Obtain the Gauss-Legendre points $\\xi_k$ and weights $w_k$ for order $q_f$. These are defined on the interval $[-1,1]$.\n    c. **Initialize Total Integral**: Set a running sum, `total_integral`, to $0$.\n    d. **Compute Boundary Integrals**: Sum the contributions from the four boundary segments of the unit square. For an interval $[a,b]$, quadrature points are mapped as $z_k = a + \\frac{b-a}{2}(1+\\xi_k)$ and the integral approximation is $\\frac{b-a}{2}\\sum_k w_k f(z_k)$. Here, each boundary segment has length $1$, so the factor is $0.5$.\n        i. **Bottom boundary** ($y=0$, $x \\in [0,1]$, $\\mathbf{n}=(0,-1)$): Add $\\int_0^1 (-F_y) \\, \\mathrm{d}x = \\int_0^1 m u^{m-1} \\partial_x u \\, \\mathrm{d}x$ to `total_integral`.\n        ii. **Right boundary** ($x=1$, $y \\in [0,1]$, $\\mathbf{n}=(1,0)$): Add $\\int_0^1 F_x \\, \\mathrm{d}y = \\int_0^1 m u^{m-1} \\partial_y u \\, \\mathrm{d}y$ to `total_integral`.\n        iii. **Top boundary** ($y=1$, $x \\in [0,1]$, $\\mathbf{n}=(0,1)$): Add $\\int_0^1 F_y \\, \\mathrm{d}x = \\int_0^1 -m u^{m-1} \\partial_x u \\, \\mathrm{d}x$ to `total_integral`.\n        iv. **Left boundary** ($x=0$, $y \\in [0,1]$, $\\mathbf{n}=(-1,0)$): Add $\\int_0^1 (-F_x) \\, \\mathrm{d}y = \\int_0^1 -m u^{m-1} \\partial_y u \\, \\mathrm{d}y$ to `total_integral`.\n    e. **Calculate Defect**: The defect for the current test case is $|\\text{total\\_integral}|$.\n3.  **Store and format results** as a comma-separated list in brackets.\n\nThis approach correctly implements the required calculation in an efficient manner by exploiting the mathematical properties of the DG formulation.", "answer": "```python\nimport numpy as np\n\ndef generate_poly_coeffs(p):\n    \"\"\"\n    Generates coefficients for the polynomial u(x,y) up to total degree p.\n    u(x,y) = sum_{a=0 to p} sum_{b=0 to p-a} c_ab * x^a * y^b\n    c_ab = 1 / (a + b + 1)\n    \n    Returns a list of dictionaries, where each dict represents a term {'a': a, 'b': b, 'c': c_ab}.\n    \"\"\"\n    coeffs = []\n    for a in range(p + 1):\n        for b in range(p - a + 1):\n            c_ab = 1.0 / (a + b + 1)\n            coeffs.append({'a': a, 'b': b, 'c': c_ab})\n    return coeffs\n\ndef evaluate_poly_and_grads(x, y, coeffs):\n    \"\"\"\n    Evaluates the polynomial u and its partial derivatives du/dx, du/dy\n    at a point (x, y) given the coefficient representation.\n    \"\"\"\n    u_val = 0.0\n    du_dx = 0.0\n    du_dy = 0.0\n    for term in coeffs:\n        a, b, c = term['a'], term['b'], term['c']\n        \n        # u(x,y) term. Note: x**0 is 1, even if x is 0.\n        u_val += c * (x**a) * (y**b)\n        \n        # du/dx term\n        if a > 0:\n            du_dx += c * a * (x**(a - 1)) * (y**b)\n        \n        # du/dy term\n        if b > 0:\n            du_dy += c * b * (x**a) * (y**(b - 1))\n            \n    return u_val, du_dx, du_dy\n\ndef compute_conservation_defect(p, m, q_f):\n    \"\"\"\n    Computes the global conservation defect E(q_f) for a given set of parameters.\n    The calculation simplifies to the sum of flux integrals over the domain boundary.\n    \"\"\"\n    poly_coeffs = generate_poly_coeffs(p)\n    xi, w = np.polynomial.legendre.leggauss(q_f)\n    \n    # Quadrature points and weights mapped to the interval [0, 1]\n    # The Jacobian of the transformation from [-1, 1] to [0, 1] is 0.5.\n    quad_pts = 0.5 * (1.0 + xi)\n    quad_w = 0.5 * w\n    \n    total_integral = 0.0\n    \n    # 1. Bottom boundary: y=0, n=(0,-1). Integral of -F_y = m*u^(m-1)*du_dx\n    for x_q, w_q in zip(quad_pts, quad_w):\n        u, du_dx, du_dy = evaluate_poly_and_grads(x_q, 0.0, poly_coeffs)\n        integrand = m * (u**(m - 1)) * du_dx\n        total_integral += w_q * integrand\n        \n    # 2. Right boundary: x=1, n=(1,0). Integral of F_x = m*u^(m-1)*du_dy\n    for y_q, w_q in zip(quad_pts, quad_w):\n        u, du_dx, du_dy = evaluate_poly_and_grads(1.0, y_q, poly_coeffs)\n        integrand = m * (u**(m - 1)) * du_dy\n        total_integral += w_q * integrand\n        \n    # 3. Top boundary: y=1, n=(0,1). Integral of F_y = -m*u^(m-1)*du_dx\n    for x_q, w_q in zip(quad_pts, quad_w):\n        u, du_dx, du_dy = evaluate_poly_and_grads(x_q, 1.0, poly_coeffs)\n        integrand = -m * (u**(m - 1)) * du_dx\n        total_integral += w_q * integrand\n        \n    # 4. Left boundary: x=0, n=(-1,0). Integral of -F_x = -m*u^(m-1)*du_dy\n    for y_q, w_q in zip(quad_pts, quad_w):\n        u, du_dx, du_dy = evaluate_poly_and_grads(0.0, y_q, poly_coeffs)\n        integrand = -m * (u**(m - 1)) * du_dy\n        total_integral += w_q * integrand\n        \n    return abs(total_integral)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (p, m, N_x, N_y, q_f)\n        (3, 3, 4, 4, 1),  # Test 1\n        (3, 3, 4, 4, 4),  # Test 2\n        (3, 3, 4, 4, 5),  # Test 3\n        (3, 3, 4, 4, 7),  # Test 4\n        (2, 2, 3, 3, 3),  # Test 5\n    ]\n    \n    results = []\n    for case in test_cases:\n        p, m, _, _, q_f = case\n        # N_x and N_y are not needed due to the telescoping sum of residuals.\n        defect = compute_conservation_defect(p, m, q_f)\n        results.append(defect)\n        \n    # Format output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solution\nsolve()\n\n```", "id": "3377711"}]}