{"hands_on_practices": [{"introduction": "To truly understand a numerical method, it is often best to construct it from its foundational principles. This first practice guides you through the process of deriving Clenshaw-Curtis quadrature weights by enforcing the rule's exactness for a set of monomials. By setting up and solving the resulting Vandermonde linear system [@problem_id:3405824], you will gain a concrete understanding of the interpolatory nature of the quadrature and empirically verify its degree of precision.", "problem": "You are tasked with constructing an interpolatory quadrature rule based on Chebyshev–Lobatto points, commonly used within spectral methods and Discontinuous Galerkin (DG) methods for polynomial approximation on a reference element. The objective is to compute the weights of the Clenshaw–Curtis quadrature rule with $N=5$ nodes on the interval $[-1,1]$, and to empirically determine the highest polynomial degree that is integrated exactly by this rule (the degree of precision).\n\nFundamental base:\n- A quadrature rule on $[-1,1]$ is defined by nodes $\\{x_k\\}_{k=0}^{N-1} \\subset [-1,1]$ and weights $\\{w_k\\}_{k=0}^{N-1}$ such that\n$$\nQ_N[f] \\equiv \\sum_{k=0}^{N-1} w_k\\, f(x_k) \\approx \\int_{-1}^{1} f(x)\\, dx.\n$$\n- The Chebyshev–Lobatto nodes (also called extremal points of Chebyshev polynomials) are defined by\n$$\nx_k = \\cos\\left(\\frac{\\pi k}{N-1}\\right), \\quad k=0,1,\\dots,N-1,\n$$\nwhich lie in $[-1,1]$ and include the endpoints $\\pm 1$.\n- An interpolatory quadrature rule determined by nodes $\\{x_k\\}_{k=0}^{N-1}$ is uniquely characterized by requiring exactness for all monomials up to degree $N-1$, namely\n$$\n\\sum_{k=0}^{N-1} w_k\\, x_k^m \\;=\\; \\int_{-1}^{1} x^m \\, dx \\quad \\text{for all } m=0,1,\\dots,N-1,\n$$\nwhere the moments are\n$$\n\\int_{-1}^{1} x^m \\, dx =\n\\begin{cases}\n0, & \\text{if } m \\text{ is odd},\\\\\n\\dfrac{2}{m+1}, & \\text{if } m \\text{ is even}.\n\\end{cases}\n$$\n- The degree of precision $d$ of a quadrature rule is the largest integer such that the rule integrates all polynomials $p(x)$ with $\\deg(p)\\le d$ exactly, i.e., $\\sum_{k=0}^{N-1} w_k\\, p(x_k) = \\int_{-1}^{1} p(x)\\, dx$ for every polynomial $p$ of degree at most $d$.\n\nTask:\n1. Using the above definitions, construct the Clenshaw–Curtis quadrature weights $\\{w_k\\}_{k=0}^{4}$ for $N=5$ nodes on $[-1,1]$ by enforcing exactness on monomials $\\{1, x, x^2, x^3, x^4\\}$.\n2. Empirically determine the highest polynomial degree that this $N=5$ quadrature rule integrates exactly by testing monomials $x^m$ sequentially for $m=0,1,2,\\dots$ until the first failure of exactness. Exactness must be judged by equality to the analytical moment within an absolute tolerance of $10^{-12}$.\n3. In the context of spectral and Discontinuous Galerkin (DG) methods, comment on how the choice of Chebyshev–Lobatto nodes relates to minimizing Runge phenomena and facilitating stable interpolation and quadrature.\n\nTest suite and output specification:\n- Your program must execute the following test cases, each specified by a pair $(N, M_{\\max})$ where $N$ is the number of Chebyshev–Lobatto nodes and $M_{\\max}$ is the largest monomial degree to test for exactness:\n    - Test case 1 (happy path): $(N, M_{\\max}) = (5, 12)$.\n    - Test case 2 (boundary case): $(N, M_{\\max}) = (2, 6)$.\n    - Test case 3 (odd $N$ edge case beyond five nodes): $(N, M_{\\max}) = (7, 16)$.\n- For each test case, construct the interpolatory quadrature weights by solving the exactness conditions for monomials up to degree $N-1$, evaluate the empirical degree of precision by checking monomials up to $M_{\\max}$, and return the result as a list containing:\n    - The integer $N$,\n    - The list of $N$ floating-point weights in their natural order corresponding to nodes $\\{x_k\\}_{k=0}^{N-1}$,\n    - The integer empirical degree of precision $d$.\n- Your program should produce a single line of output containing the results for all test cases, formatted as a comma-separated list of lists without spaces, enclosed in square brackets. For example: \n$$\n\\text{Output: }[[N_1,[w_{1,0},\\dots,w_{1,N_1-1}],d_1],[N_2,[w_{2,0},\\dots,w_{2,N_2-1}],d_2],[N_3,[w_{3,0},\\dots,w_{3,N_3-1}],d_3]].\n$$\nNo physical units are involved in this problem, and no angle units are required.", "solution": "The problem posed is to construct and analyze the Clenshaw–Curtis quadrature rule based on Chebyshev–Lobatto nodes for a given number of nodes, $N$. This process involves two primary computational tasks: calculating the quadrature weights and empirically determining the rule's degree of precision. It also requires a qualitative explanation of the role these specific nodes play in numerical methods.\n\nFirst, the problem statement is validated.\n\n### Step 1: Extract Givens\n- **Quadrature Rule:** $Q_N[f] \\equiv \\sum_{k=0}^{N-1} w_k\\, f(x_k) \\approx \\int_{-1}^{1} f(x)\\, dx$.\n- **Nodes:** Chebyshev–Lobatto points, $x_k = \\cos\\left(\\frac{\\pi k}{N-1}\\right)$ for $k=0,1,\\dots,N-1$.\n- **Weight Calculation:** The rule is interpolatory, meaning it is exact for monomials up to degree $N-1$. This leads to the linear system $\\sum_{k=0}^{N-1} w_k\\, x_k^m = \\int_{-1}^{1} x^m \\, dx$ for $m=0,1,\\dots,N-1$.\n- **Moments of Monomials:** $\\int_{-1}^{1} x^m \\, dx$ is $0$ for odd $m$ and $\\frac{2}{m+1}$ for even $m$.\n- **Degree of Precision ($d$):** The largest integer such that the rule is exact for all polynomials of degree up to $d$.\n- **Task Specifics:** Determine weights for $N=5$. Empirically find the degree of precision for $N=5$ using a tolerance of $10^{-12}$.\n- **Contextual Task:** Comment on the benefits of Chebyshev-Lobatto nodes for stable interpolation and quadrature.\n- **Test Cases:** $(N, M_{\\max}) = (5, 12)$, $(N, M_{\\max}) = (2, 6)$, $(N, M_{\\max}) = (7, 16)$.\n- **Output Specification:** A list of lists of the form $[N, [\\text{weights}], d]$ for each test case.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded in the established theory of numerical analysis, specifically numerical quadrature and polynomial approximation. All definitions, including those for the quadrature rule, Chebyshev-Lobatto nodes, and the method for determining weights, are standard and mathematically correct. The problem is well-posed; for a set of $N$ distinct nodes, the $N \\times N$ Vandermonde matrix is invertible, guaranteeing a unique set of weights. The Chebyshev-Lobatto nodes for $N \\ge 2$ are distinct on the interval $[-1, 1]$. The instructions are clear, unambiguous, and self-contained, with no internal contradictions. It is a standard, solvable problem in computational mathematics.\n\n### Step 3: Verdict and Action\nThe problem is valid. A solution will be constructed.\n\n### Solution Derivation\n\n#### Quadrature Weight Calculation\n\nAn interpolatory quadrature rule is defined by the set of nodes $\\{x_k\\}_{k=0}^{N-1}$ and is constructed to be exact for a basis of the polynomial space of degree at most $N-1$. A common choice for this basis is the set of monomials $\\{1, x, x^2, \\dots, x^{N-1}\\}$. The condition of exactness for each monomial $x^m$ translates to a linear equation:\n$$\n\\sum_{k=0}^{N-1} w_k x_k^m = \\int_{-1}^{1} x^m \\, dx, \\quad m=0, 1, \\dots, N-1.\n$$\n\nThis constitutes a system of $N$ linear equations for the $N$ unknown weights $\\{w_k\\}_{k=0}^{N-1}$. In matrix form, this is written as $V \\mathbf{w} = \\mathbf{b}$, where:\n- $\\mathbf{w} = [w_0, w_1, \\dots, w_{N-1}]^T$ is the vector of unknown weights.\n- $V$ is the Vandermonde matrix defined by the nodes, with entries $V_{mk} = (x_k)^m$ for $m, k \\in \\{0, 1, \\dots, N-1\\}$.\n- $\\mathbf{b}$ is the vector of moments of the monomials, with entries $b_m = \\int_{-1}^{1} x^m \\, dx$. The analytical values are:\n$$\nb_m =\n\\begin{cases}\n\\frac{2}{m+1} & \\text{if } m \\text{ is even} \\\\\n0 & \\text{if } m \\text{ is odd}\n\\end{cases}\n$$\n\nThe specified nodes are the Chebyshev–Lobatto points, given by $x_k = \\cos\\left(\\frac{\\pi k}{N-1}\\right)$ for $k=0, 1, \\dots, N-1$. These nodes are symmetric about $x=0$ and include the endpoints $-1$ and $1$. As long as $N \\ge 2$, these nodes are distinct, which ensures that the Vandermonde matrix $V$ is non-singular. Consequently, the system $V \\mathbf{w} = \\mathbf{b}$ has a unique solution for the weights, which can be found numerically by solving this linear system.\n\n#### Empirical Degree of Precision\n\nThe degree of precision, $d$, of a quadrature rule is the maximum integer such that the rule integrates every polynomial of degree up to $d$ exactly. By construction, an $N$-point interpolatory rule has a degree of precision of at least $N-1$. It may be higher. To determine $d$ empirically, we test the rule's exactness on monomials $x^m$ for successively increasing integer powers $m=0, 1, 2, \\dots, M_{\\max}$.\n\nFor each $m$, we compute the numerical approximation of the integral:\n$$\nQ_N[x^m] = \\sum_{k=0}^{N-1} w_k x_k^m\n$$\nand compare it to the exact analytical value, $I[x^m] = \\int_{-1}^{1} x^m \\, dx = b_m$. The test for exactness is whether the absolute error is within a specified tolerance $\\epsilon = 10^{-12}$:\n$$\n|Q_N[x^m] - I[x^m]| \\le \\epsilon\n$$\nThe degree of precision $d$ is the largest integer $m$ for which this condition holds for all integers from $0$ to $m$. In practice, we find the first monomial power, say $m^*$, for which the quadrature fails. The degree of precision is then $d = m^* - 1$. If the rule is exact for all tested monomials up to $M_{\\max}$, the empirical degree is reported as $M_{\\max}$.\n\nIt is a known theoretical result that the degree of precision for an $N$-point Clenshaw-Curtis rule is at least $N-1$. Our empirical investigation should determine the exact value for the test cases. This should not be confused with the Gauss-Lobatto-Legendre rule, which uses the same nodes but optimizes the weights differently to achieve a higher degree of precision of $2N-3$.\n\n#### Commentary on Chebyshev-Lobatto Nodes in Spectral/DG Methods\n\nThe selection of nodes for polynomial interpolation and quadrature is of paramount importance in spectral and Discontinuous Galerkin (DG) methods. The choice of Chebyshev-Lobatto nodes is motivated by several key properties that ensure numerical stability and accuracy:\n\n1.  **Minimization of Runge's Phenomenon:** When using high-degree polynomial interpolants, equispaced nodes lead to large oscillations near the boundaries of the interval, a behavior known as Runge's phenomenon. The Chebyshev-Lobatto nodes are not equispaced; they cluster near the endpoints $\\pm 1$. This specific distribution of points is optimal in the sense that it minimizes the maximum error of polynomial interpolation over the class of all possible node sets, as measured by the Lebesgue constant. The Lebesgue constant for Chebyshev points grows logarithmically with the polynomial degree $N$, i.e., $\\Lambda_N \\sim \\log N$, whereas for equispaced points, it grows exponentially, $\\Lambda_N \\sim 2^N/N\\log N$. The slow growth for Chebyshev points ensures that the interpolation process is stable and converges as $N \\rightarrow \\infty$ for sufficiently smooth functions.\n\n2.  **Stable and Accurate Quadrature:** The favorable interpolation properties translate directly to quadrature. Because the Clenshaw-Curtis rule is based on an accurate polynomial interpolant, the resulting quadrature is also highly accurate. The weights are always positive, which contributes to the numerical stability of the integration scheme.\n\n3.  **Boundary Conditions and Element Coupling in DG Methods:** In DG methods, the domain is broken into smaller elements, and the solution is approximated by a polynomial on each element (typically a reference element like $[-1, 1]$ mapped to the physical element). The inclusion of the endpoints $\\pm 1$ in the Chebyshev-Lobatto set is particularly advantageous. It allows\n    for the direct imposition of boundary conditions on the element and facilitates the computation of numerical fluxes at element interfaces, which are critical for coupling adjacent elements and defining the global discrete problem.\n\nIn summary, Chebyshev-Lobatto nodes provide a robust foundation for high-order spectral and DG methods by guaranteeing stable polynomial interpolation and yielding accurate, positive-weight quadrature rules, while also simplifying the handling of element boundaries.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs Clenshaw-Curtis quadrature rules based on Chebyshev-Lobatto nodes,\n    determines their empirical degree of precision, and formats the output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (5, 12),  # Test case 1 (happy path)\n        (2, 6),   # Test case 2 (boundary case)\n        (7, 16),  # Test case 3 (odd N edge case)\n    ]\n\n    results = []\n    TOLERANCE = 1e-12\n\n    for N, M_max in test_cases:\n        # Step 1: Generate Chebyshev-Lobatto nodes.\n        # x_k = cos(pi*k / (N-1)) for k = 0, ..., N-1\n        k_vals = np.arange(N)\n        nodes = np.cos(np.pi * k_vals / (N - 1))\n        # Ensure that nodes that should be exactly 0 are not affected by floating point inaccuracies for large N\n        nodes = np.where(np.abs(nodes)  1e-15, 0, nodes)\n\n\n        # Step 2: Construct the Vandermonde matrix V such that V[m, k] = nodes[k]**m.\n        # This sets up the linear system V @ w = b.\n        V = np.vander(nodes, N, increasing=True).T\n\n        # Step 3: Construct the moment vector b, where b[m] = integral of x^m from -1 to 1.\n        m_vals = np.arange(N)\n        moments = np.zeros(N)\n        # Integral is 2/(m+1) for even m, and 0 for odd m.\n        moments[::2] = 2.0 / (m_vals[::2] + 1)\n\n        # Step 4: Solve the linear system V @ w = b for the weights w.\n        try:\n            weights = np.linalg.solve(V, moments)\n        except np.linalg.LinAlgError:\n            # This should not happen for N >= 2 as nodes are distinct.\n            # Handle potential error gracefully if it occurs.\n            results.append([N, [], -1])\n            continue\n            \n        # Step 5: Empirically determine the degree of precision.\n        # The degree of precision is the largest integer d such that the rule\n        # is exact for all monomials x^m where m = d.\n        degree_of_precision = -1\n        for m in range(M_max + 1):\n            numerical_integral = np.sum(weights * (nodes**m))\n            \n            if m % 2 == 0:\n                exact_integral = 2.0 / (m + 1)\n            else:\n                exact_integral = 0.0\n\n            if np.abs(numerical_integral - exact_integral) > TOLERANCE:\n                degree_of_precision = m - 1\n                break\n        \n        # If the loop completes without breaking, the rule is exact for all tested monomials.\n        if degree_of_precision == -1:\n            degree_of_precision = M_max\n\n        # Store the results for this test case.\n        # The weights are converted to a standard Python list for formatting.\n        results.append([N, list(weights), degree_of_precision])\n\n    # Format the final output string as per the problem specification.\n    # We build the string manually to avoid spaces introduced by str(list).\n    result_strings = []\n    for res in results:\n        N_val, weights_list, d_val = res\n        weights_str = f\"[{','.join(f'{w:.15f}' for w in weights_list)}]\"\n        result_strings.append(f\"[{N_val},{weights_str},{d_val}]\")\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3405824"}, {"introduction": "While the direct construction from the previous exercise is instructive, it is computationally impractical for a large number of nodes $N$. Fortunately, the special structure of the Chebyshev nodes allows for a much faster approach. This practice demonstrates how to derive and implement the canonical $O(N\\log N)$ algorithm for computing Clenshaw-Curtis weights by leveraging the Discrete Cosine Transform (DCT) [@problem_id:3371402], connecting quadrature theory to the powerful framework of fast Fourier analysis.", "problem": "Let $n \\in \\mathbb{N}_0$ and consider the Clenshaw–Curtis quadrature rule on the interval $[-1,1]$ with $n+1$ nodes $x_j = \\cos\\left(\\frac{\\pi j}{n}\\right)$ for $j = 0,1,\\dots,n$ when $n \\ge 1$ and a single node $x_0=1$ when $n=0$. The goal is to compute the quadrature weights $w_j$ such that, for suitable functions $f$, the approximation $\\sum_{j=0}^n w_j f(x_j)$ is close to $\\int_{-1}^1 f(x)\\,dx$. Your task is to derive, from first principles, an algorithm of complexity $O(n\\log n)$ to compute the weights $w_j$ by exploiting cosine expansions and the Discrete Cosine Transform of type I (DCT-I), including correct handling of endpoint scaling. All angles must be in radians.\n\nBegin from the following fundamental base:\n- The Chebyshev polynomials of the first kind satisfy $T_k(\\cos \\theta) = \\cos(k\\theta)$ for all integers $k \\ge 0$ and real $\\theta$.\n- For $k \\ge 0$, the exact integrals of Chebyshev polynomials over $[-1,1]$ are given by\n$$\n\\int_{-1}^1 T_k(x)\\,dx =\n\\begin{cases}\n2  \\text{if } k = 0, \\\\\n0  \\text{if } k \\text{ is odd}, \\\\\n\\dfrac{2}{1-k^2}  \\text{if } k \\text{ is even and } k \\ge 2.\n\\end{cases}\n$$\n- The discrete cosine orthogonality on the Chebyshev grid $\\theta_j = \\frac{\\pi j}{n}$ involves the primed sum $\\sum_{j=0}^n{}'$, where endpoints $j=0$ and $j=n$ are counted with weight $1/2$, namely $\\sum_{j=0}^n{}' a_j := \\frac{1}{2}a_0 + \\sum_{j=1}^{n-1} a_j + \\frac{1}{2} a_n$. The Discrete Cosine Transform of type I (DCT-I) without normalization is characterized by\n$$\n\\operatorname{DCT\\!I}[v]_k \\;=\\; 2 \\sum_{j=0}^n{}' v_j \\cos\\!\\left(\\frac{\\pi j k}{n}\\right), \\quad k=0,1,\\dots,n,\n$$\nand its inverse satisfies $v = \\operatorname{DCT\\!I}(\\operatorname{DCT\\!I}(v)) / (2n)$ for length $n+1$ vectors.\n\nUsing only the above base, derive why the Clenshaw–Curtis weights $w_j$ can be obtained by an inverse DCT-I applied to a vector formed from the exact integrals $\\int_{-1}^1 T_k(x)\\,dx$, and determine the precise scaling and endpoint handling required to recover the $w_j$ from the inverse transform. Your derivation must clearly explain why the complexity of your final algorithm is $O(n \\log n)$.\n\nThen, implement the derived algorithm in a program that, for given $n$, constructs the weights $w_j$ using a DCT-I in $O(n\\log n)$ time by zero-padding odd Chebyshev modes appropriately and correctly scaling the output to account for the primed sum.\n\nAngles must be in radians. No physical units are involved.\n\nYour program must evaluate the following test suite and output the specified aggregated results:\n- Test 1 (boundary case): $n=0$. Compare the computed weights to the reference weights $[2]$ and report the maximum absolute difference as a floating-point number.\n- Test 2 (small case): $n=1$. Compare to the reference weights $[1,1]$ and report the maximum absolute difference as a floating-point number.\n- Test 3 (small case): $n=2$. Compare to the reference weights $\\left[\\frac{1}{3},\\frac{4}{3},\\frac{1}{3}\\right]$ and report the maximum absolute difference as a floating-point number.\n- Test 4 (exactness on polynomials): $n=7$. For each integer $m$ with $0 \\le m \\le 7$, evaluate the discrete moment $\\sum_{j=0}^7 w_j T_m(x_j)$ and compare it to the exact integral $\\int_{-1}^1 T_m(x)\\,dx$ given above. Report the maximum absolute error over $m=0,1,\\dots,7$ as a floating-point number.\n- Test 5 (nonpolynomial function): $n=32$. Approximate $\\int_{-1}^1 e^x\\,dx$ using the quadrature and compare to the exact value $2\\sinh(1)$. Report the absolute error as a floating-point number.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, \"[result1,result2,result3,result4,result5]\". The results must correspond in order to Tests 1 through 5. All angles must be in radians.", "solution": "The user wants to derive and implement an $O(n \\log n)$ algorithm for computing Clenshaw-Curtis quadrature weights $w_j$ for $n+1$ nodes $x_j=\\cos(\\frac{\\pi j}{n})$.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- Quadrature nodes: $x_j = \\cos\\left(\\frac{\\pi j}{n}\\right)$ for $j = 0,1,\\dots,n$, with $n \\in \\mathbb{N}_0$. For $n=0$, a single node $x_0=1$ is specified.\n- Quadrature rule: $\\int_{-1}^1 f(x)\\,dx \\approx \\sum_{j=0}^n w_j f(x_j)$.\n- Chebyshev polynomials: $T_k(\\cos \\theta) = \\cos(k\\theta)$.\n- Exact integrals of Chebyshev polynomials:\n$$\nI_k := \\int_{-1}^1 T_k(x)\\,dx =\n\\begin{cases}\n2  \\text{if } k = 0 \\\\\n0  \\text{if } k \\text{ is odd} \\\\\n\\dfrac{2}{1-k^2}  \\text{if } k \\text{ is even and } k \\ge 2\n\\end{cases}\n$$\n- Primed sum: $\\sum_{j=0}^n{}' a_j := \\frac{1}{2}a_0 + \\sum_{j=1}^{n-1} a_j + \\frac{1}{2}a_n$.\n- Discrete Cosine Transform of type I (DCT-I): $\\operatorname{DCT\\!I}[v]_k = 2 \\sum_{j=0}^n{}' v_j \\cos\\left(\\frac{\\pi j k}{n}\\right)$, for $k=0,1,\\dots,n$.\n- Inverse DCT-I relation: $v = \\operatorname{DCT\\!I}(\\operatorname{DCT\\!I}(v)) / (2n)$ for a vector $v$ of length $n+1$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded, well-posed, and objective. It is a standard problem in numerical analysis, specifically in the field of spectral methods. All definitions and formulas provided are standard and correct. The problem is self-contained and supplies all necessary information for its solution. The special definition for $n=0$ is unambiguous and consistent with the provided test case. The problem does not violate any of the invalidity criteria.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A complete solution will be provided.\n\n### Derivation and Algorithm\n\nThe Clenshaw-Curtis quadrature rule is constructed to be exact for polynomials up to degree $n$. This is achieved by approximating the integrand $f(x)$ with its unique polynomial interpolant $p_n(x)$ of degree at most $n$ at the Chebyshev nodes $x_j$, and then integrating $p_n(x)$ exactly. If $f(x)$ is itself a polynomial of degree at most $n$, then $p_n(x) = f(x)$, and the quadrature must be exact.\n\nConsequently, the quadrature rule must be exact for all Chebyshev polynomials $T_m(x)$ for $m=0, 1, \\dots, n$, since $T_m(x)$ is a polynomial of degree $m$. This condition establishes a system of equations for the unknown weights $w_j$:\n$$\n\\sum_{j=0}^n w_j T_m(x_j) = \\int_{-1}^1 T_m(x)\\,dx = I_m, \\quad \\text{for } m = 0, 1, \\dots, n.\n$$\nTo align this system with the structure of the provided DCT-I, we introduce a modified weight vector $w'$ where the endpoints are scaled:\n$w'_0 = 2w_0$, $w'_n = 2w_n$, and $w'_j = w_j$ for $j=1, \\dots, n-1$.\nUsing the definition of the primed sum $\\sum'$, the exactness condition becomes:\n$$\n\\sum_{j=0}^n{}' w'_j T_m(x_j) = I_m, \\quad \\text{for } m = 0, 1, \\dots, n.\n$$\nSubstituting the identities $x_j = \\cos\\left(\\frac{\\pi j}{n}\\right)$ and $T_m(x_j) = \\cos\\left(\\frac{\\pi j m}{n}\\right)$:\n$$\n\\sum_{j=0}^n{}' w'_j \\cos\\left(\\frac{\\pi j m}{n}\\right) = I_m, \\quad \\text{for } m = 0, 1, \\dots, n.\n$$\nWe now relate this to the given DCT-I definition: $\\operatorname{DCT\\!I}[v]_k = 2 \\sum_{j=0}^n{}' v_j \\cos\\left(\\frac{\\pi j k}{n}\\right)$.\nApplying this transform to our vector $w'$ (of length $n+1$), we get for each component $m=0, \\dots, n$:\n$$\n(\\operatorname{DCT\\!I}[w'])_m = 2 \\sum_{j=0}^n{}' w'_j \\cos\\left(\\frac{\\pi j m}{n}\\right) = 2 I_m.\n$$\nLet $c$ be a vector of length $n+1$ with elements $c_m = 2I_m$. The above relation is $c = \\operatorname{DCT-I}[w']$. To find the sought-after weights $w'$, we must apply the inverse transform to $c$. The problem provides the inverse relation $v = \\operatorname{DCT\\!I}(\\operatorname{DCT\\!I}(v)) / (2n)$, which implies that the inverse DCT-I operator is the DCT-I operator itself, followed by scaling by $1/(2n)$.\nTherefore, we can find $w'$ as:\n$$\nw' = \\operatorname{IDCT-I}(c) = \\frac{\\operatorname{DCT-I}(c)}{2n}.\n$$\nLet's write out the components $w'_j$ of the vector $w'$:\n$$\nw'_j = \\frac{1}{2n} (\\operatorname{DCT-I}[c])_j = \\frac{1}{2n} \\left( 2 \\sum_{k=0}^n{}' c_k \\cos\\left(\\frac{\\pi j k}{n}\\right) \\right).\n$$\nSubstituting $c_k = 2I_k$:\n$$\nw'_j = \\frac{1}{2n} \\left( 2 \\sum_{k=0}^n{}' (2I_k) \\cos\\left(\\frac{\\pi j k}{n}\\right) \\right) = \\frac{2}{n} \\sum_{k=0}^n{}' I_k \\cos\\left(\\frac{\\pi j k}{n}\\right).\n$$\nExpanding the primed sum over $k$:\n$$\nw'_j = \\frac{2}{n} \\left[ \\frac{1}{2}I_0 + \\sum_{k=1}^{n-1} I_k \\cos\\left(\\frac{\\pi j k}{n}\\right) + \\frac{1}{2}I_n \\cos\\left(\\pi j\\right) \\right] = \\frac{1}{n} \\left[ I_0 + 2\\sum_{k=1}^{n-1} I_k \\cos\\left(\\frac{\\pi j k}{n}\\right) + I_n (-1)^j \\right].\n$$\nThis expression can be computed efficiently. The `scipy.fft` library provides an inverse DCT of type I, `idct(..., type=1)`, which, with `norm='backward'` (the default), computes for an input vector $Y$ of length $N=n+1$:\n$$\nX_j = \\frac{1}{2n} \\left[ Y_0 + 2\\sum_{k=1}^{n-1} Y_k \\cos\\left(\\frac{\\pi j k}{n}\\right) + Y_n (-1)^j \\right].\n$$\nComparing this with our expression for $w'_j$, we see that if we set the input vector $Y$ to be our vector of integrals $I$ (where $Y_k=I_k$), then $w'_j = 2 \\times X_j$.\nThis provides a direct and efficient algorithm:\n1.  For a given $n \\ge 1$, construct the vector $I$ of length $n+1$, where $I_k = \\int_{-1}^1 T_k(x)\\,dx$. The odd-indexed elements $I_k$ will be zero, corresponding to the \"zero-padding [of] odd Chebyshev modes\" mentioned in the problem.\n2.  Compute the vector $w'$ by applying the inverse DCT-I to $I$ and scaling: $w' = 2 \\times \\operatorname{idct}(I, \\text{type=1})$.\n3.  Recover the final quadrature weights $w_j$ by undoing the initial scaling of endpoints: $w_0 = w'_0/2$, $w_n = w'_n/2$, and $w_j=w'_j$ for $j=1, \\dots, n-1$.\n\nThe special case $n=0$ involves one node $x_0=1$. The simplest quadrature rule, $w_0 f(x_0)$, should be exact for $T_0(x)=1$. This requires $w_0 T_0(1) = \\int_{-1}^1 T_0(x)dx \\implies w_0 \\cdot 1 = 2$, so $w_0=2$.\n\nThe complexity of this algorithm is dominated by the `idct` computation. Fast implementations of DCT/IDCT, like the one in `scipy`, are based on the Fast Fourier Transform (FFT) algorithm. For an input of size $N=n+1$, the complexity is $O(N \\log N)$, which is $O(n \\log n)$. All other steps are $O(n)$, so the overall complexity is $O(n \\log n)$.", "answer": "```python\nimport numpy as np\nfrom scipy import fft\nimport math\n\ndef solve():\n    \"\"\"\n    Derives Clenshaw-Curtis weights and runs tests specified in the problem.\n    \"\"\"\n\n    def compute_weights(n: int) -> np.ndarray:\n        \"\"\"\n        Computes Clenshaw-Curtis quadrature weights for n+1 nodes in O(n log n) time.\n        \n        Args:\n            n: The order of the quadrature rule, corresponding to n+1 nodes.\n        \n        Returns:\n            A numpy array of n+1 quadrature weights.\n        \"\"\"\n        if not isinstance(n, int) or n  0:\n            raise ValueError(\"n must be a non-negative integer.\")\n\n        if n == 0:\n            return np.array([2.0])\n\n        # 1. Construct the vector I of exact integrals of Chebyshev polynomials T_k.\n        k = np.arange(n + 1)\n        Ivec = np.zeros(n + 1, dtype=float)\n\n        # For even k, I_k = 2 / (1 - k^2). For odd k, I_k = 0.\n        # I_0 = 2 is handled by the formula since 1 - 0^2 = 1.\n        even_indices = k[k % 2 == 0]\n        Ivec[even_indices] = 2.0 / (1.0 - even_indices**2)\n\n        # 2. Compute the modified weights w' using the inverse DCT of type 1.\n        # From the derivation, w'_j = 2 * idct(Ivec, type=1)_j.\n        # The norm='backward' option provides the required 1/(2n) scaling factor.\n        w_prime = 2 * fft.idct(Ivec, type=1, norm='backward')\n\n        # 3. Recover the final weights w by halving the endpoint values of w'.\n        w = w_prime\n        w[0] /= 2.0\n        w[-1] /= 2.0\n        \n        return w\n\n    # --- Test Suite ---\n    \n    # Test 1 (boundary case): n=0\n    n0 = 0\n    w0 = compute_weights(n0)\n    ref_w0 = np.array([2.0])\n    res1 = np.max(np.abs(w0 - ref_w0))\n\n    # Test 2 (small case): n=1\n    n1 = 1\n    w1 = compute_weights(n1)\n    ref_w1 = np.array([1.0, 1.0])\n    res2 = np.max(np.abs(w1 - ref_w1))\n\n    # Test 3 (small case): n=2\n    n2 = 2\n    w2 = compute_weights(n2)\n    ref_w2 = np.array([1/3.0, 4/3.0, 1/3.0])\n    res3 = np.max(np.abs(w2 - ref_w2))\n\n    # Test 4 (exactness on polynomials): n=7\n    n7 = 7\n    w7 = compute_weights(n7)\n    errors7 = []\n    for m in range(n7 + 1):\n        # Nodes x_j = cos(pi*j/n)\n        nodes = np.cos(math.pi * np.arange(n7 + 1) / n7)\n        # Values of T_m(x_j) at nodes\n        Tm_at_nodes = np.cos(m * math.pi * np.arange(n7 + 1) / n7)\n        # Quadrature sum\n        discrete_moment = np.sum(w7 * Tm_at_nodes)\n        \n        # Exact integral of T_m(x)\n        if m == 0:\n            exact_integral = 2.0\n        elif m % 2 != 0:\n            exact_integral = 0.0\n        else: # m is even and >= 2\n            exact_integral = 2.0 / (1 - m**2)\n            \n        errors7.append(np.abs(discrete_moment - exact_integral))\n    res4 = np.max(errors7)\n\n    # Test 5 (nonpolynomial function): n=32\n    n32 = 32\n    w32 = compute_weights(n32)\n    nodes_32 = np.cos(math.pi * np.arange(n32 + 1) / n32)\n    f_vals = np.exp(nodes_32)\n    quadrature_approx = np.sum(w32 * f_vals)\n    exact_integral_exp = math.exp(1.0) - math.exp(-1.0) # 2*sinh(1)\n    res5 = np.abs(quadrature_approx - exact_integral_exp)\n\n    results = [res1, res2, res3, res4, res5]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3371402"}, {"introduction": "The theoretical properties of a quadrature rule are important, but its practical performance across a range of problems determines its utility. In this exercise, you will put your Clenshaw-Curtis implementation to the test by comparing its accuracy against the renowned Gauss-Legendre quadrature. By evaluating integrals of smooth, non-smooth, and oscillatory functions [@problem_id:2378822], you will gain critical insight into the distinct advantages of each method and learn to choose the right tool for the job.", "problem": "Consider numerical approximation of definite integrals over the closed interval $[-1,1]$ using two distinct families of quadrature rules that are central to approximation theory and computational physics: Clenshaw–Curtis quadrature based on Chebyshev nodes and Gauss–Legendre quadrature based on Legendre polynomial roots.\n\nDefinitions:\n- For a positive integer $m \\ge 2$, define the set of $m$ Chebyshev–Lobatto nodes by $x_k = \\cos\\!\\left(\\dfrac{k\\pi}{m-1}\\right)$ for $k=0,1,\\dots,m-1$. The Clenshaw–Curtis quadrature of order $m$ is defined as the exact integral over $[-1,1]$ of the unique polynomial of degree at most $m-1$ that interpolates the integrand at these nodes.\n- For a positive integer $m \\ge 1$, the $m$-point Gauss–Legendre quadrature on $[-1,1]$ is the quadrature rule with $m$ nodes and positive weights that integrates every polynomial of degree at most $2m-1$ exactly.\n\nTasks:\n1. For each integrand $f(x)$ listed below and the specified number of nodes $m$, compute two approximations to the definite integral $\\int_{-1}^{1} f(x)\\,dx$: one using the order-$m$ Clenshaw–Curtis quadrature and one using the $m$-point Gauss–Legendre quadrature.\n2. For each case, also compute the absolute error of each approximation relative to the exact integral value.\n3. Angles in all trigonometric functions must be in radians.\n\nTest suite:\n- Case A: $f(x) = x^8 - 3x^3 + 2$, with $m=5$. Exact integral: $\\displaystyle \\int_{-1}^{1} \\left(x^8 - 3x^3 + 2\\right)\\,dx = \\dfrac{38}{9}$.\n- Case B: $f(x) = |x|$, with $m=17$. Exact integral: $\\displaystyle \\int_{-1}^{1} |x|\\,dx = 1$.\n- Case C: $f(x) = \\sqrt{1 - x^2}$, with $m=17$. Exact integral: $\\displaystyle \\int_{-1}^{1} \\sqrt{1 - x^2}\\,dx = \\dfrac{\\pi}{2}$.\n- Case D: $f(x) = \\sin(50x)$, with $m=65$. Exact integral: $\\displaystyle \\int_{-1}^{1} \\sin(50x)\\,dx = 0$. Angles are in radians.\n- Case E: $f(x) = e^{x}$, with $m=9$. Exact integral: $\\displaystyle \\int_{-1}^{1} e^{x}\\,dx = e - e^{-1}$.\n\nRequired program output:\n- For each case in the order A, B, C, D, E, compute the absolute error of the Clenshaw–Curtis approximation and the absolute error of the Gauss–Legendre approximation.\n- Your program should produce a single line of output containing these $10$ floating-point numbers as a comma-separated list enclosed in square brackets, in the order\n$[\\text{err}_{\\mathrm{CC,A}},\\text{err}_{\\mathrm{GL,A}},\\text{err}_{\\mathrm{CC,B}},\\text{err}_{\\mathrm{GL,B}},\\text{err}_{\\mathrm{CC,C}},\\text{err}_{\\mathrm{GL,C}},\\text{err}_{\\mathrm{CC,D}},\\text{err}_{\\mathrm{GL,D}},\\text{err}_{\\mathrm{CC,E}},\\text{err}_{\\mathrm{GL,E}}]$.", "solution": "The problem statement has been subjected to rigorous validation and is found to be complete, consistent, and scientifically sound. It is well-posed, with all necessary data and definitions provided for a unique and meaningful solution. The problem concerns fundamental methods in numerical analysis—Clenshaw–Curtis and Gauss–Legendre quadrature—which are central topics in computational physics. Therefore, we may proceed with the solution.\n\nThe task is to approximate the definite integral $I[f] = \\int_{-1}^{1} f(x)\\,dx$ for several functions using two distinct quadrature rules, each with a specified number of nodes $m$, and to compute the absolute error of each approximation.\n\n**Gauss–Legendre Quadrature**\n\nThe $m$-point Gauss–Legendre (GL) quadrature rule is a form of Gaussian quadrature designed to achieve the highest possible degree of algebraic precision. The quadrature sum is given by:\n$$ \\int_{-1}^{1} f(x)\\,dx \\approx \\sum_{i=1}^{m} w_i f(x_i) $$\nFor a given number of nodes $m$, both the nodes $\\{x_i\\}$ and weights $\\{w_i\\}$ are chosen optimally. The nodes $x_i$ are the roots of the Legendre polynomial of degree $m$, $P_m(x)$, which are all real, distinct, and lie within the interval $(-1, 1)$. The corresponding weights $w_i$ are all positive and are chosen such that the rule is exact for all polynomials of degree up to $2m-1$. This high degree of exactness makes Gauss–Legendre quadrature exceptionally efficient for analytic functions.\n\nFor computational purposes, the nodes and weights are not calculated from first principles but are obtained from pre-computed values or reliable numerical libraries. In this case, we use the `scipy.special.roots_legendre` function, which provides high-precision values for both.\n\n**Clenshaw–Curtis Quadrature**\n\nClenshaw–Curtis (CC) quadrature is an interpolatory quadrature rule based on a function's expansion in a series of Chebyshev polynomials. The nodes are chosen to be the Chebyshev–Lobatto points, which are the extrema of the Chebyshev polynomial of degree $m-1$, $T_{m-1}(x)$:\n$$ x_k = \\cos\\left(\\frac{k\\pi}{m-1}\\right) \\quad \\text{for } k = 0, 1, \\dots, m-1 $$\nThe method works by constructing the unique polynomial $p_{m-1}(x)$ of degree at most $m-1$ that interpolates the function $f(x)$ at these $m$ nodes. The integral of $f(x)$ is then approximated by the exact integral of this interpolating polynomial:\n$$ \\int_{-1}^{1} f(x)\\,dx \\approx \\int_{-1}^{1} p_{m-1}(x)\\,dx $$\nThe interpolating polynomial $p_{m-1}(x)$ can be expressed as a finite sum of Chebyshev polynomials:\n$$ p_{m-1}(x) = \\sum_{j=0}^{m-1} a_j T_j(x) $$\nThe coefficients $\\{a_j\\}$ can be determined efficiently from the function values $\\{f(x_k)\\}$ at the nodes, for which the `numpy.polynomial.chebyshev.chebfit` routine is suitable. Once the coefficients are known, the integral is computed by leveraging the known analytical integrals of the Chebyshev polynomials:\n$$ \\int_{-1}^{1} T_j(x)\\,dx = \\begin{cases} \\frac{2}{1-j^2}  \\text{if } j \\text{ is even} \\\\ 0  \\text{if } j \\text{ is odd} \\end{cases} $$\nSubstituting this into the integral of the series gives the Clenshaw–Curtis approximation:\n$$ I_{CC} = \\int_{-1}^{1} \\sum_{j=0}^{m-1} a_j T_j(x)\\,dx = \\sum_{j=0, \\, j \\text{ even}}^{m-1} a_j \\frac{2}{1-j^2} $$\nThe degree of exactness for an order-$m$ CC rule is $m-1$. While lower than that of GL quadrature for the same $m$, CC has other advantages, such as its nested nodes and efficiency via Fast Fourier Transform (FFT) based methods.\n\n**Computational Procedure**\n\nFor each of the five test cases specified:\n1.  **Define Inputs**: The function $f(x)$, the number of nodes $m$, and the exact value of the integral $I_{exact}$ are defined.\n2.  **Gauss–Legendre Approximation**:\n    a. Obtain the $m$ GL nodes and weights using `scipy.special.roots_legendre(m)`.\n    b. Calculate the approximate integral $I_{GL} = \\sum_{i=0}^{m-1} w_i f(x_i)$.\n    c. Compute the absolute error $\\text{err}_{GL} = |I_{GL} - I_{exact}|$.\n3.  **Clenshaw–Curtis Approximation**:\n    a. Generate the $m$ CC nodes $x_k = \\cos(k\\pi/(m-1))$.\n    b. Evaluate the function at these nodes to get values $y_k = f(x_k)$.\n    c. Compute the Chebyshev coefficients $\\{a_j\\}$ of the interpolating polynomial of degree $m-1$ using `numpy.polynomial.chebyshev.chebfit`.\n    d. Calculate the approximate integral $I_{CC}$ using the summation over the even-indexed coefficients.\n    e. Compute the absolute error $\\text{err}_{CC} = |I_{CC} - I_{exact}|$.\n4.  **Collate Results**: The two error values for each case, $\\text{err}_{CC}$ and $\\text{err}_{GL}$, are stored in the specified order.\n\n**Analysis of Expected Performance**\n-   **Case A ($f(x) = x^8 - 3x^3 + 2, m=5$)**: The integrand is a polynomial of degree $8$. The $5$-point GL rule is exact for polynomials up to degree $2(5)-1=9$. Therefore, the error $\\text{err}_{GL}$ is expected to be zero, up to machine precision. The order-$5$ CC rule is exact for polynomials up to degree $4$, so $\\text{err}_{CC}$ will be non-zero.\n-   **Case B ($f(x) = |x|, m=17$)**: The function has a derivative discontinuity at $x=0$, which limits the convergence rate of both methods. High-order accuracy is lost.\n-   **Case C ($f(x) = \\sqrt{1 - x^2}, m=17$)**: The function has derivative singularities at the endpoints $x=\\pm 1$. The change of variable $x=\\cos\\theta$, which is implicit in the formulation of CC, transforms the integrand into a smooth periodic function, $\\sin^2\\theta$. CC is expected to be exceptionally accurate for this case.\n-   **Case D ($f(x) = \\sin(50x), m=65$)**: This is a highly oscillatory analytic function. Both methods should provide good approximations, but the high frequency requires a sufficient number of points to resolve the oscillations. GL is generally superior for such smooth functions.\n-   **Case E ($f(x) = e^x, m=9$)**: The integrand is an entire function (analytic everywhere). Both methods will exhibit rapid (exponential) convergence. For a given $m$, GL is expected to be significantly more accurate due to its higher degree of exactness.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\nfrom numpy.polynomial.chebyshev import chebfit\n\ndef solve():\n    \"\"\"\n    Computes and compares the accuracy of Clenshaw-Curtis and Gauss-Legendre\n    quadratures for a suite of test integrals.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"func\": lambda x: x**8 - 3*x**3 + 2,\n            \"m\": 5,\n            \"exact\": 38.0 / 9.0\n        },\n        {\n            \"name\": \"B\",\n            \"func\": lambda x: np.abs(x),\n            \"m\": 17,\n            \"exact\": 1.0\n        },\n        {\n            \"name\": \"C\",\n            \"func\": lambda x: np.sqrt(1 - x**2),\n            \"m\": 17,\n            \"exact\": np.pi / 2.0\n        },\n        {\n            \"name\": \"D\",\n            \"func\": lambda x: np.sin(50 * x),\n            \"m\": 65,\n            \"exact\": 0.0\n        },\n        {\n            \"name\": \"E\",\n            \"func\": lambda x: np.exp(x),\n            \"m\": 9,\n            \"exact\": np.e - 1.0/np.e\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        f = case[\"func\"]\n        m = case[\"m\"]\n        exact_val = case[\"exact\"]\n\n        # --- Gauss-Legendre Quadrature ---\n        # The scipy function returns nodes and weights for the m-point rule.\n        gl_nodes, gl_weights = roots_legendre(m)\n        \n        # Approximate the integral by summing f(x_i) * w_i\n        gl_approx = np.sum(gl_weights * f(gl_nodes))\n        \n        # Calculate the absolute error.\n        err_gl = np.abs(gl_approx - exact_val)\n\n        # --- Clenshaw-Curtis Quadrature ---\n        # Get the m Chebyshev-Lobatto nodes.\n        # These are the extrema of the Chebyshev polynomial T_{m-1}(x).\n        cc_nodes = np.cos(np.arange(m) * np.pi / (m - 1))\n        \n        # Evaluate the function at the nodes.\n        cc_vals = f(cc_nodes)\n        \n        # Compute the coefficients of the Chebyshev series that interpolates\n        # the function at the nodes. The degree of interpolant is m-1.\n        # `chebfit` is used for this purpose.\n        # For interpolation at Chebyshev nodes, least squares fit is equivalent to interpolation.\n        coeffs = chebfit(cc_nodes, cc_vals, m - 1)\n        \n        # Integrate the Chebyshev series expansion.\n        # The integral of a Chebyshev polynomial T_j(x) over [-1, 1] is\n        # 2/(1-j^2) for j even, and 0 for j odd.\n        cc_approx = 0.0\n        for j in range(0, m, 2):\n            cc_approx += coeffs[j] * (2.0 / (1.0 - j**2))\n            \n        # Calculate the absolute error.\n        err_cc = np.abs(cc_approx - exact_val)\n\n        results.extend([err_cc, err_gl])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2378822"}]}