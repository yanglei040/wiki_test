{"hands_on_practices": [{"introduction": "This practice tackles a foundational aspect of handling experimental and simulated data: units and numerical precision. Before any physics analysis can be performed, it is critical to ensure all data is in a consistent system of units, but this conversion process is not without computational consequences. This exercise challenges you to implement these conversions and to rigorously quantify the floating-point round-off errors introduced, a crucial skill for writing robust scientific software and correctly interpreting numerical results [@problem_id:3513376].", "problem": "You are given an abstracted event record modeled on the High Energy Physics Monte Carlo (HepMC3) library. In HepMC3, energy-like quantities such as four-momentum components are kept in a single energy unit and space-like quantities such as vertex positions are kept in a single length unit. The conventional default units used by HepMC3 for event records produced by general-purpose generators are energy in $\\,\\mathrm{GeV}\\,$ and length in $\\,\\mathrm{mm}\\,$, with well-defined enumerations for energy units $\\,\\{\\mathrm{eV},\\mathrm{keV},\\mathrm{MeV},\\mathrm{GeV},\\mathrm{TeV}\\}\\,$ and for length units $\\,\\{\\mathrm{mm},\\mathrm{cm},\\mathrm{m}\\}\\,$. An event record consists of a list of particles, each with a four-momentum $(E,p_x,p_y,p_z)$ and a production vertex position $(x,y,z)$, where $(E,p_x,p_y,p_z)$ are in $\\,\\mathrm{GeV}\\,$ and $(x,y,z)$ are in $\\,\\mathrm{mm}\\,$.\n\nStarting from dimensional analysis and standard unit definitions, derive the mathematically correct conversion for transforming energy-like quantities from $\\,\\mathrm{GeV}\\,$ to $\\,\\mathrm{MeV}\\,$ and length-like quantities from $\\,\\mathrm{mm}\\,$ to $\\,\\mathrm{cm}\\,$. Assume all numerical computations are carried out in double-precision floating point conforming to the Institute of Electrical and Electronics Engineers (IEEE) $\\,754\\,$ standard, with machine epsilon $\\,\\epsilon\\,$ defined as the smallest positive number such that $\\,1+\\epsilon \\neq 1\\,$ in double precision.\n\nYour task is to implement a program that:\n- Converts the given event records from $(\\mathrm{GeV},\\mathrm{mm})$ to $(\\mathrm{MeV},\\mathrm{cm})$ using the correct multiplicative conversion factors deduced from fundamental unit definitions.\n- Quantifies rigorous upper bounds on round-off error introduced by the floating-point operations used for these conversions, expressed as absolute error bounds. Use a first-principles floating-point rounding model for a single multiplication by an exactly representable integer factor for energy and by a non-exact decimal factor for length. The bounds must be computed per numerical field and aggregated per event as the maximum absolute error bound across all converted quantities within that event.\n- Produces a single line of output containing a list of per-event results. Each per-event result must be a two-element list $[E_{\\max},L_{\\max}]$ where $E_{\\max}$ is the maximum absolute error bound among all converted energy-like quantities in $\\,\\mathrm{MeV}\\,$, and $L_{\\max}$ is the maximum absolute error bound among all converted length-like quantities in $\\,\\mathrm{cm}\\,$. All outputs must be real numbers in standard decimal form without units.\n\nFundamental base:\n- Use the definition $\\,1\\,\\mathrm{GeV} = 10^{3}\\,\\mathrm{MeV}\\,$.\n- Use the definition $\\,1\\,\\mathrm{cm} = 10\\,\\mathrm{mm}\\,$.\n- Use the IEEE $\\,754\\,$ rounding-to-nearest model for a single floating-point multiplication with machine epsilon $\\,\\epsilon\\,$. Treat multiplication by an exactly representable integer $\\,k\\,$ as inducing at most one rounding with relative error bounded by $\\,\\epsilon\\,$, and multiplication by a non-exact decimal factor $\\,q\\,$ as the composition of representing $\\,q\\,$ (relative error bounded by $\\,\\epsilon\\,$) and a single rounded multiplication (relative error bounded by $\\,\\epsilon\\,$), yielding a conservative bound on the total relative error not exceeding $\\,2\\epsilon\\,$.\n\nUnits and numerical outputs:\n- Conversion outputs are internal to the program; the final printed results must be the error bounds as described and must be dimensionless numerical values printed in standard decimal notation.\n- Angles are not used in this task; there is no angle unit to specify.\n\nTest suite:\nYou must apply your program to the following three event records. Each event is a list of particles, and each particle is defined by two tuples, $(E,p_x,p_y,p_z)$ in $\\,\\mathrm{GeV}\\,$ and $(x,y,z)$ in $\\,\\mathrm{mm}\\,$:\n\n- Event $\\,1\\,$:\n  - Particle $\\,1\\,$: $(E,p_x,p_y,p_z) = (91.1876,1.0,-2.0,10.0)$, $(x,y,z) = (0.5,-1.2,30.0)$\n  - Particle $\\,2\\,$: $(E,p_x,p_y,p_z) = (45.5938,-0.3,0.1,-5.0)$, $(x,y,z) = (0.0,0.0,0.0)$\n  - Particle $\\,3\\,$: $(E,p_x,p_y,p_z) = (0.005,0.001,0.0002,-0.0001)$, $(x,y,z) = (0.001,-0.002,0.005)$\n- Event $\\,2\\,$:\n  - Particle $\\,1\\,$: $(E,p_x,p_y,p_z) = (13000.0,100.0,-200.0,5000.0)$, $(x,y,z) = (1000000.0,0.0,-1000000.0)$\n  - Particle $\\,2\\,$: $(E,p_x,p_y,p_z) = (0.0,0.0,0.0,0.0)$, $(x,y,z) = (1.0,-1.0,1.0)$\n- Event $\\,3\\,$:\n  - Particle $\\,1\\,$: $(E,p_x,p_y,p_z) = (1.0\\times 10^{-9},-1.0\\times 10^{-9},2.0\\times 10^{-9},-3.0\\times 10^{-9})$, $(x,y,z) = (1.0\\times 10^{-6},-2.0\\times 10^{-6},3.0\\times 10^{-6})$\n  - Particle $\\,2\\,$: $(E,p_x,p_y,p_z) = (5.0\\times 10^{-3},-5.0\\times 10^{-3},0.0,1.0\\times 10^{-2})$, $(x,y,z) = (1.0\\times 10^{-3},0.0,-1.0\\times 10^{-3})$\n\nFinal output format:\nYour program should produce a single line of output containing the per-event results as a comma-separated list enclosed in square brackets, where each element is the two-element list $[E_{\\max},L_{\\max}]$. For example, the output must have the form $[\\,[E_{\\max}^{(1)},L_{\\max}^{(1)}],[E_{\\max}^{(2)},L_{\\max}^{(2)}],[E_{\\max}^{(3)},L_{\\max}^{(3)}]\\,]$ with numeric values in place of the symbols.", "solution": "The problem requires the derivation of conversion factors and the analysis of associated floating-point errors for event records in high-energy physics. The analysis will proceed in three stages: first, the derivation of the multiplicative conversion factors; second, the modeling and calculation of upper bounds for absolute floating-point errors; and third, the specification of an algorithm to apply these calculations to the given test data.\n\n**1. Derivation of Conversion Factors**\n\nThe problem specifies conversions for energy-like and length-like quantities based on standard unit definitions.\n\n- **Energy Conversion ($\\mathrm{GeV} \\to \\mathrm{MeV}$)**: The provided definition is $1\\,\\mathrm{GeV} = 10^3\\,\\mathrm{MeV}$. To convert a value $Q_{\\mathrm{GeV}}$ in units of $\\mathrm{GeV}$ to its equivalent $Q_{\\mathrm{MeV}}$ in units of $\\mathrm{MeV}$, we multiply by the appropriate conversion factor derived from this identity:\n$$ Q_{\\mathrm{MeV}} = Q_{\\mathrm{GeV}} \\times \\left( \\frac{10^3\\,\\mathrm{MeV}}{1\\,\\mathrm{GeV}} \\right) = Q_{\\mathrm{GeV}} \\times 1000 $$\nThe conversion factor is the integer $k = 1000$. In the IEEE $754$ double-precision binary format, the integer $1000$ is exactly representable, as it can be written as $1000 = 125 \\times 2^3$, and the integer mantissa $125$ requires only $7$ bits, which is well within the $52$-bit limit.\n\n- **Length Conversion ($\\mathrm{mm} \\to \\mathrm{cm}$)**: The provided definition is $1\\,\\mathrm{cm} = 10\\,\\mathrm{mm}$. To convert a value $P_{\\mathrm{mm}}$ in units of $\\mathrm{mm}$ to its equivalent $P_{\\mathrm{cm}}$ in units of $\\mathrm{cm}$, the conversion is:\n$$ P_{\\mathrm{cm}} = P_{\\mathrm{mm}} \\times \\left( \\frac{1\\,\\mathrm{cm}}{10\\,\\mathrm{mm}} \\right) = P_{\\mathrm{mm}} \\times 0.1 $$\nThe conversion factor is the decimal fraction $q = 0.1$. In base $2$, this is a non-terminating, repeating fraction ($0.000110011..._2$). Consequently, $0.1$ cannot be represented exactly in any finite-bit binary floating-point system, including IEEE $754$ double precision.\n\n**2. Floating-Point Error Analysis**\n\nThe problem mandates an error analysis based on a first-principles model of IEEE $754$ double-precision arithmetic, for which we denote the machine epsilon by $\\epsilon$. The machine epsilon, $\\epsilon$, is the upper bound on the relative error of a single fundamental floating-point operation, i.e., $fl(x \\odot y) = (x \\odot y)(1+\\delta)$ where $|\\delta| \\le \\epsilon$.\n\n- **Absolute Error Bound for Energy Conversion**: The conversion is $Q_{\\mathrm{MeV}} = Q_{\\mathrm{GeV}} \\times 1000$. The problem states that multiplication by the exactly representable factor $1000$ induces at most one rounding. The computed value, $Q'_{\\mathrm{MeV}}$, is related to the exact mathematical result, $Q_{\\mathrm{GeV}} \\times 1000$, by:\n$$ Q'_{\\mathrm{MeV}} = fl(Q_{\\mathrm{GeV}} \\times 1000) = (Q_{\\mathrm{GeV}} \\times 1000)(1 + \\delta_{E}) $$\nwhere the relative error $|\\delta_{E}| \\le \\epsilon$. The absolute error, $\\Delta Q_E = |Q'_{\\mathrm{MeV}} - (Q_{\\mathrm{GeV}} \\times 1000)|$, is therefore bounded by:\n$$ \\text{bound}(\\Delta Q_E) = |(Q_{\\mathrm{GeV}} \\times 1000)\\delta_{E}| \\le |Q_{\\mathrm{GeV}} \\times 1000| \\times \\epsilon $$\nFor each event, the maximum absolute error bound, $E_{\\max}$, is the maximum of this bound over all energy-like quantities $\\{E, p_x, p_y, p_z\\}$ for all particles within that event. This maximum is determined by the component with the largest magnitude:\n$$ E_{\\max} = \\left( \\max_{\\text{event}} |Q_{\\mathrm{GeV}}| \\right) \\times 1000 \\times \\epsilon $$\nThe resulting error bound $E_{\\max}$ has units of $\\mathrm{MeV}$.\n\n- **Absolute Error Bound for Length Conversion**: The conversion is $P_{\\mathrm{cm}} = P_{\\mathrm{mm}} \\times 0.1$. The problem specifies a conservative model where the total relative error from this operation is bounded by $2\\epsilon$. This accounts for both the initial error in representing the non-exact factor $0.1$ and the subsequent error from the multiplication. The computed value, $P'_{\\mathrm{cm}}$, is related to the exact mathematical result, $P_{\\mathrm{mm}} \\times 0.1$, by:\n$$ P'_{\\mathrm{cm}} = (P_{\\mathrm{mm}} \\times 0.1)(1 + \\delta_{L}) $$\nwhere the total relative error $|\\delta_{L}| \\le 2\\epsilon$. The absolute error, $\\Delta Q_L = |P'_{\\mathrm{cm}} - (P_{\\mathrm{mm}} \\times 0.1)|$, is bounded by:\n$$ \\text{bound}(\\Delta Q_L) = |(P_{\\mathrm{mm}} \\times 0.1)\\delta_{L}| \\le |P_{\\mathrm{mm}} \\times 0.1| \\times 2\\epsilon $$\nFor each event, the maximum absolute error bound, $L_{\\max}$, is the maximum of this bound over all length-like quantities $\\{x, y, z\\}$ for all particles within that event:\n$$ L_{\\max} = \\left( \\max_{\\text{event}} |P_{\\mathrm{mm}}| \\right) \\times 0.1 \\times 2\\epsilon = \\left( \\max_{\\text{event}} |P_{\\mathrm{mm}}| \\right) \\times 0.2 \\times \\epsilon $$\nThe resulting error bound $L_{\\max}$ has units of $\\mathrm{cm}$.\n\n**3. Algorithm and Implementation**\n\nAn algorithm to compute the required error bounds for the test suite is as follows:\n1.  Obtain the machine epsilon, $\\epsilon$, for IEEE $754$ double-precision numbers.\n2.  For each event in the test suite:\n    a. Initialize `max_abs_energy_GeV` and `max_abs_length_mm` to $0.0$.\n    b. Iterate through each particle in the event.\n        i. For the particle's four-momentum $(E, p_x, p_y, p_z)$ in $\\mathrm{GeV}$, find the maximum absolute value among its components. Update `max_abs_energy_GeV` to be the maximum of its current value and this new maximum.\n        ii. For the particle's vertex position $(x, y, z)$ in $\\mathrm{mm}$, find the maximum absolute value among its components. Update `max_abs_length_mm` to be the maximum of its current value and this new maximum.\n    c. After processing all particles, compute the event-wide maximum absolute error bounds using the derived formulas:\n       - $E_{\\max} = \\texttt{max\\_abs\\_energy\\_GeV} \\times 1000 \\times \\epsilon$\n       - $L_{\\max} = \\texttt{max\\_abs\\_length\\_mm} \\times 0.2 \\times \\epsilon$\n    d. Store the resulting pair $[E_{\\max}, L_{\\max}]$.\n3.  Format the list of stored pairs into a single string according to the specified output format, `[[E_max_1,L_max_1],[E_max_2,L_max_2],...]`, and print it.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating floating-point error bounds for unit\n    conversions in high-energy physics event records.\n    \"\"\"\n\n    # Define the test suite from the problem statement.\n    # Structure: list of events.\n    # Each event: list of particles.\n    # Each particle: tuple of (four_momentum_GeV, vertex_position_mm).\n    test_cases = [\n        # Event 1\n        [\n            ((91.1876, 1.0, -2.0, 10.0), (0.5, -1.2, 30.0)),\n            ((45.5938, -0.3, 0.1, -5.0), (0.0, 0.0, 0.0)),\n            ((0.005, 0.001, 0.0002, -0.0001), (0.001, -0.002, 0.005))\n        ],\n        # Event 2\n        [\n            ((13000.0, 100.0, -200.0, 5000.0), (1000000.0, 0.0, -1000000.0)),\n            ((0.0, 0.0, 0.0, 0.0), (1.0, -1.0, 1.0))\n        ],\n        # Event 3\n        [\n            ((1.0e-9, -1.0e-9, 2.0e-9, -3.0e-9), (1.0e-6, -2.0e-6, 3.0e-6)),\n            ((5.0e-3, -5.0e-3, 0.0, 1.0e-2), (1.0e-3, 0.0, -1.0e-3))\n        ]\n    ]\n\n    # Get machine epsilon for IEEE 754 double precision (np.float64).\n    epsilon = np.finfo(np.float64).eps\n\n    results = []\n    for event in test_cases:\n        max_abs_energy_component_gev = 0.0\n        max_abs_length_component_mm = 0.0\n\n        # Find the maximum absolute value for energy and length quantities in the event.\n        for particle in event:\n            momenta, positions = particle\n            \n            # Find max absolute value for energy-like quantities (in GeV)\n            current_max_e = max(map(abs, momenta))\n            if current_max_e > max_abs_energy_component_gev:\n                max_abs_energy_component_gev = current_max_e\n\n            # Find max absolute value for length-like quantities (in mm)\n            current_max_l = max(map(abs, positions))\n            if current_max_l > max_abs_length_component_mm:\n                max_abs_length_component_mm = current_max_l\n\n        # Calculate E_max: absolute error bound for energy conversion (in MeV).\n        # The model is: E_max = (max |val_GeV|) * 1000 * epsilon\n        e_max = max_abs_energy_component_gev * 1000.0 * epsilon\n\n        # Calculate L_max: absolute error bound for length conversion (in cm).\n        # The model is: L_max = (max |val_mm|) * 0.1 * 2 * epsilon\n        l_max = max_abs_length_component_mm * 0.2 * epsilon\n        \n        results.append([e_max, l_max])\n\n    # Format the final output string exactly as specified.\n    # Python's default float-to-string conversion produces standard decimal form.\n    output_str = \"[\" + \",\".join([f\"[{e},{l}]\" for e, l in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "3513376"}, {"introduction": "Data formats in high-energy physics evolve, and a common task for computational physicists is migrating event records between different versions, such as from HepMC2 to HepMC3. This practice moves beyond simple numerical conversion to address the structural integrity of the event history, which is represented as a directed graph of particles and vertices. You will implement a converter that not only handles unit changes and maps particle status codes but also rigorously preserves the crucial mother-daughter relationships that encode the physics of the event [@problem_id:3513391].", "problem": "You are given the task of implementing a converter between two in-memory representations of high-energy physics event records that abstract the common features of the High Energy Physics Monte Carlo (HepMC) version $2$ and version $3$ formats. Each event is a directed bipartite graph with vertex nodes (production or decay points) and particle nodes (edges connecting vertices). The input representation (HepMC$2$-like) declares its units for momentum-energy and space-time separately. The output representation (HepMC$3$-like) must preserve the graph structure and explicitly convert all numerical quantities into fixed target units. The converter must also map integer particle status codes from the input convention to the output convention via a well-defined function. You must implement a runnable program that performs this conversion for a small test suite of events, checks three invariants for each event, and outputs the results.\n\nFoundational base and definitions to use:\n- A HepMC event can be idealized as a directed bipartite graph $G = (V \\cup P, E)$ with $V$ the set of vertices, $P$ the set of particles, and $E$ edges connecting $V$ to $P$ and $P$ to $V$ such that there are no edges between two $V$ or two $P$ nodes. Each particle $p \\in P$ has at most one production vertex $\\mathrm{prod}(p) \\in V$ and at most one end vertex $\\mathrm{end}(p) \\in V$. Each vertex $v \\in V$ has an incoming set $\\mathrm{in}(v) \\subseteq P$ and an outgoing set $\\mathrm{out}(v) \\subseteq P$ that satisfy set equalities induced by particle endpoints: $\\mathrm{in}(v) = \\{ p \\in P \\mid \\mathrm{end}(p) = v \\}$ and $\\mathrm{out}(v) = \\{ p \\in P \\mid \\mathrm{prod}(p) = v \\}$.\n- Four-momentum is represented as a tuple $(p_x, p_y, p_z, E)$ and four-position as $(x, y, z, t)$. In natural units with speed of light $c = 1$, the unit for energy and momentum is common. Unit conversions are pure scalings: if the input momentum-energy unit is $\\mathsf{MEV}$ and the target is $\\mathsf{GEV}$ then the scale factor $s_p$ is $s_p = 10^{-3}$; if the input is $\\mathsf{GEV}$, then $s_p = 1$. For space-time, if the input length unit is $\\mathsf{CM}$ and the target is $\\mathsf{MM}$ then the scale factor $s_\\ell$ is $s_\\ell = 10$, and if the input is $\\mathsf{MM}$ then $s_\\ell = 1$. Apply $s_p$ to all four-momentum components and $s_\\ell$ to all four-position components.\n- Particle status codes are integers. You must define a deterministic mapping function $f: \\mathbb{Z} \\to \\mathbb{Z}$ for the conversion. You are required to choose a convention that resolves the ambiguity of nonstandard codes while preserving typical semantics such as final-state and decayed/intermediate categories. You must document your choice inside your code as comments.\n\nYour target output representation must:\n- Use fixed target units: $\\mathsf{GEV}$ for momentum-energy and $\\mathsf{MM}$ for space-time.\n- Preserve the event graph structure exactly: for every particle and vertex, the relationships $\\mathrm{prod}(\\cdot)$ and $\\mathrm{end}(\\cdot)$ and the derived sets $\\mathrm{in}(\\cdot)$, $\\mathrm{out}(\\cdot)$ must match between input and output modulo units and status code values.\n- Map status codes using your defined $f(s)$ and apply this to every particle.\n\nFor each event in the test suite below, your program must compute and append to a single flat list three boolean results in this order:\n- Units-correct: a boolean indicating whether all four-momenta and four-positions have been converted to the specified target units by the correct scale factors, within a relative tolerance of $10^{-12}$.\n- Status-correct: a boolean indicating whether every particle status in the output equals $f(s)$ applied to the input status $s$.\n- Graph-preserved: a boolean indicating whether the input and output graphs have identical adjacency in terms of production and end vertices for every particle, and incoming and outgoing particle sets for every vertex.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,...]\"). The elements must be booleans.\n\nTest suite specification:\nImplement the test suite as three concrete HepMC$2$-like events with the following exact content. All numerical values must be interpreted in their declared input units and converted to the target units in the output.\n\nEvent A:\n- Input units: momentum-energy unit $\\mathsf{MEV}$, length unit $\\mathsf{MM}$.\n- Vertices:\n  - Vertex $v_1$: identifier $1$, position $(x,y,z,t) = (0.0, 0.0, 0.0, 0.0)$.\n  - Vertex $v_2$: identifier $2$, position $(x,y,z,t) = (0.0, 0.0, 1.0, 1.0)$.\n- Particles:\n  - Particle $p_1$: identifier $1$, status $2$, four-momentum $(p_x,p_y,p_z,E) = (0.0, 0.0, 1000.0, 1100.0)$, $\\mathrm{prod}(p_1) = v_1$, $\\mathrm{end}(p_1) = v_2$.\n  - Particle $p_2$: identifier $2$, status $1$, four-momentum $(100.0, 0.0, 400.0, 412.3105626)$, $\\mathrm{prod}(p_2) = v_2$, $\\mathrm{end}(p_2) = \\varnothing$.\n  - Particle $p_3$: identifier $3$, status $1$, four-momentum $(-100.0, 0.0, 600.0, 687.6894374)$, $\\mathrm{prod}(p_3) = v_2$, $\\mathrm{end}(p_3) = \\varnothing$.\n\nEvent B:\n- Input units: momentum-energy unit $\\mathsf{GEV}$, length unit $\\mathsf{CM}$.\n- Vertices:\n  - Vertex $v_{10}$: identifier $10$, position $(0.0, 0.0, 0.0, 0.0)$.\n  - Vertex $v_{11}$: identifier $11$, position $(0.1, -0.2, 0.3, 0.0)$.\n- Particles:\n  - Particle $p_{12}$: identifier $12$, status $2$, four-momentum $(0.3, 0.4, 0.0, 0.5)$, $\\mathrm{prod}(p_{12}) = v_{10}$, $\\mathrm{end}(p_{12}) = v_{11}$.\n  - Particle $p_{13}$: identifier $13$, status $1$, four-momentum $(0.1, 0.2, 0.0, 0.2236067977)$, $\\mathrm{prod}(p_{13}) = v_{11}$, $\\mathrm{end}(p_{13}) = \\varnothing$.\n  - Particle $p_{14}$: identifier $14$, status $1$, four-momentum $(0.2, 0.2, 0.0, 0.2763932023)$, $\\mathrm{prod}(p_{14}) = v_{11}$, $\\mathrm{end}(p_{14}) = \\varnothing$.\n  - Particle $p_{10}$: identifier $10$, status $3$, four-momentum $(0.0, 0.0, 0.0, 0.0)$, with no production or end vertex attached.\n\nEvent C:\n- Input units: momentum-energy unit $\\mathsf{MEV}$, length unit $\\mathsf{CM}$.\n- Vertices:\n  - Vertex $v_{100}$: identifier $100$, position $(0.0, 0.0, 0.0, 0.0)$.\n  - Vertex $v_{101}$: identifier $101$, position $(0.0, 0.0, 0.01, 0.01)$.\n  - Vertex $v_{102}$: identifier $102$, position $(0.0, 0.0, 0.02, 0.02)$.\n- Particles:\n  - Particle $p_{100}$: identifier $100$, status $2$, four-momentum $(0.0, 0.0, 1500.0, 1600.0)$, $\\mathrm{prod}(p_{100}) = v_{100}$, $\\mathrm{end}(p_{100}) = v_{101}$.\n  - Particle $p_{101}$: identifier $101$, status $2$, four-momentum $(0.0, 0.0, 1000.0, 1100.0)$, $\\mathrm{prod}(p_{101}) = v_{101}$, $\\mathrm{end}(p_{101}) = v_{102}$.\n  - Particle $p_{102}$: identifier $102$, status $1$, four-momentum $(0.0, 0.0, 500.0, 500.0)$, $\\mathrm{prod}(p_{102}) = v_{102}$, $\\mathrm{end}(p_{102}) = \\varnothing$.\n  - Particle $p_{103}$: identifier $103$, status $1$, four-momentum $(0.0, 0.0, 500.0, 600.0)$, $\\mathrm{prod}(p_{103}) = v_{102}$, $\\mathrm{end}(p_{103}) = \\varnothing$.\n\nUnit conversion targets and tolerances:\n- Convert all $(p_x, p_y, p_z, E)$ to $\\mathsf{GEV}$.\n- Convert all $(x, y, z, t)$ to $\\mathsf{MM}$.\n- Use absolute or relative tolerance of $10^{-12}$ when comparing floating-point quantities.\n\nStatus mapping convention:\n- Define and use a mapping $f(s)$ that preserves the meaning of final-state and decayed/intermediate codes where $s \\in \\{1,2\\}$ and assigns a consistent code for documentation or other non-propagating entries. For all other $s$, provide a well-documented conventional choice. You must describe $f$ in your source code comments.\n\nOutput format requirement:\n- Your program must produce a single line containing one flat list with $9$ booleans in the exact order: for Event A $(\\text{Units-correct}, \\text{Status-correct}, \\text{Graph-preserved})$, followed by Event B in the same order, followed by Event C in the same order. The printed line must be in the format \"[val1,val2,...,val9]\".\n\nAll computations must be performed with internal floating-point arithmetic consistent with the unit rules stated. No file input or output is permitted; construct the test events inside the program. No external libraries beyond the specified ones are allowed.", "solution": "The problem requires the implementation of a converter for high-energy physics event records. This task can be deconstructed into three primary components: data structure definition, data transformation, and verification. The solution is designed following a principle-based approach, ensuring correctness and clarity at each step.\n\nFirst, to formalize the problem, we establish a robust in-memory representation for the event data. An event is a directed bipartite graph $G = (V \\cup P, E)$, where $V$ is a set of vertices and $P$ is a set of particles. We define Python classes to model these entities. The `Vertex` class stores a unique integer identifier, a $4$-dimensional position vector $(x, y, z, t)$, and lists of incoming and outgoing particles. The `Particle` class stores a unique integer identifier, a particle status code, a $4$-dimensional momentum vector $(p_x, p_y, p_z, E)$, and references to its production and end vertices. An `Event` class aggregates the vertices and particles, along with the event-wide momentum-energy and length units. Using NumPy arrays for the $4$-vectors provides a computationally efficient way to handle numerical operations.\n\nSecond, we implement the conversion logic. This process generates a new `Event` object in the target representation from an input `Event`. The conversion involves three distinct transformations applied to the data:\n\n1.  **Unit Conversion:** All numerical quantities must be converted to the target units of Giga-electron Volts ($\\mathsf{GEV}$) for momentum-energy and millimeters ($\\mathsf{MM}$) for space-time. This is achieved by applying scaling factors. The momentum-energy scaling factor, $s_p$, is $10^{-3}$ if converting from $\\mathsf{MEV}$ to $\\mathsf{GEV}$, and $1$ if the input is already in $\\mathsf{GEV}$. The length scaling factor, $s_\\ell$, is $10$ if converting from $\\mathsf{CM}$ to $\\mathsf{MM}$, and $1$ if the input is already in $\\mathsf{MM}$. For each particle, its four-momentum vector is multiplied by $s_p$. For each vertex, its four-position vector is multiplied by $s_\\ell$.\n\n2.  **Status Code Mapping:** Particle status codes are integers that denote the particle's role in the event history. We must define a deterministic mapping function $f: \\mathbb{Z} \\to \\mathbb{Z}$ to convert from the input convention to the output convention. A standard and logical choice for $f(s)$ is to preserve the conventional meanings of common codes while handling others gracefully. We define $f(1) = 1$ for final-state particles, $f(2) = 2$ for decayed intermediate particles, and $f(3) = 0$ for documentation entries. All other non-standard codes are also mapped to $0$, a common practice for codes without a direct physical interpretation in the target scheme. This function $f(s)$ is applied to the status code of every particle during the conversion.\n\n3.  **Graph Structure Preservation:** The event's history is encoded in its graph topology, specifically the connections between particles and vertices. The relationships $\\mathrm{prod}(p)$ (the production vertex of particle $p$) and $\\mathrm{end}(p)$ (the end vertex of particle $p$) must be preserved. The conversion process achieves this by first creating a complete set of new particles and vertices with transformed numerical data, and then re-establishing the links between them. For each new particle, its production and end vertex references are set to the new vertices that correspond (by unique identifier) to the original vertices. Since the sets of incoming particles $\\mathrm{in}(v)$ and outgoing particles $\\mathrm{out}(v)$ for a vertex $v$ are fully determined by the $\\mathrm{prod}(\\cdot)$ and $\\mathrm{end}(\\cdot)$ relations of all particles, preserving these relations guarantees the entire graph structure is preserved.\n\nThird, a set of three invariants is checked for each converted event to validate the correctness of the transformation. The results of these checks, which are boolean values, form the final output.\n\n1.  **Units-correct:** This invariant is verified by iterating through all particles and vertices of the output event. For each entity, we check if its four-vector is numerically equal to the original four-vector multiplied by the appropriate scaling factor ($s_p$ or $s_\\ell$). The comparison is performed using `numpy.allclose`, which robustly handles floating-point arithmetic with a specified relative tolerance of $10^{-12}$. The invariant holds only if the check passes for all entities.\n\n2.  **Status-correct:** This invariant is confirmed by iterating through all particles in the output event and ensuring that each particle's status code is equal to the result of applying the mapping function $f(s)$ to the status code of the corresponding particle in the input event.\n\n3.  **Graph-preserved:** This invariant is tested by verifying the topological integrity. For each particle in the input event, we find its counterpart in the output event by its identifier. We then compare the identifiers of their respective production and end vertices. The graph is considered preserved if, for every particle, the production and end vertex identifiers in the output event match those in the input event. This includes correctly handling particles that may lack a production or end vertex (e.g., initial or final state particles without a recorded decay vertex).\n\nThe overall implementation processes the three test events from the provided suite, performs the conversion and verification for each, and aggregates the nine resulting boolean values into a single flat list for the final output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# A deterministic function to map particle status codes.\n# This function must be documented as per the problem description.\n# Convention chosen:\n# - Status 1 (final-state) maps to 1.\n# - Status 2 (intermediate/decayed) maps to 2.\n# - Status 3 (documentation) maps to 0, a common convention for non-physical entries.\n# - All other status codes are mapped to 0 as a catch-all for undefined/non-standard codes.\ndef status_map(s: int) -> int:\n    \"\"\"Maps an input status code to an output status code.\"\"\"\n    if s == 1:\n        return 1\n    if s == 2:\n        return 2\n    if s == 3:\n        return 0\n    return 0\n\nclass Vertex:\n    \"\"\"Represents a vertex in the event graph.\"\"\"\n    def __init__(self, id_val: int, pos: tuple):\n        self.id = id_val\n        self.pos = np.array(pos, dtype=float)\n        self.incoming_particles = []\n        self.outgoing_particles = []\n\n    def __repr__(self) -> str:\n        return f\"Vertex(id={self.id}, pos={self.pos})\"\n\nclass Particle:\n    \"\"\"Represents a particle in the event graph.\"\"\"\n    def __init__(self, id_val: int, status: int, mom: tuple):\n        self.id = id_val\n        self.status = status\n        self.mom = np.array(mom, dtype=float)\n        self.prod_vertex = None\n        self.end_vertex = None\n\n    def __repr__(self) -> str:\n        prod_id = self.prod_vertex.id if self.prod_vertex else None\n        end_id = self.end_vertex.id if self.end_vertex else None\n        return f\"Particle(id={self.id}, status={self.status}, mom={self.mom}, prod={prod_id}, end={end_id})\"\n\nclass Event:\n    \"\"\"Represents a single event, containing vertices and particles.\"\"\"\n    def __init__(self, mom_unit: str, len_unit: str):\n        self.mom_unit = mom_unit\n        self.len_unit = len_unit\n        self.vertices = {}  # map id -> Vertex\n        self.particles = {} # map id -> Particle\n\n    def add_vertex(self, vertex: Vertex):\n        self.vertices[vertex.id] = vertex\n\n    def add_particle(self, particle: Particle):\n        self.particles[particle.id] = particle\n\ndef convert_event(input_event: Event) -> Event:\n    \"\"\"Converts an event to the target representation.\"\"\"\n    # Determine scaling factors\n    s_p = 1e-3 if input_event.mom_unit == 'MEV' else 1.0\n    s_l = 10.0 if input_event.len_unit == 'CM' else 1.0\n    \n    # Create new event with target units\n    output_event = Event('GEV', 'MM')\n\n    # Convert vertices\n    for v_id, v_in in input_event.vertices.items():\n        new_pos = v_in.pos * s_l\n        output_event.add_vertex(Vertex(v_id, tuple(new_pos)))\n\n    # Convert particles\n    for p_id, p_in in input_event.particles.items():\n        new_mom = p_in.mom * s_p\n        new_status = status_map(p_in.status)\n        output_event.add_particle(Particle(p_id, new_status, tuple(new_mom)))\n\n    # Re-establish graph links\n    for p_id, p_in in input_event.particles.items():\n        p_out = output_event.particles[p_id]\n        if p_in.prod_vertex:\n            prod_v_out = output_event.vertices[p_in.prod_vertex.id]\n            p_out.prod_vertex = prod_v_out\n            prod_v_out.outgoing_particles.append(p_out)\n        if p_in.end_vertex:\n            end_v_out = output_event.vertices[p_in.end_vertex.id]\n            p_out.end_vertex = end_v_out\n            end_v_out.incoming_particles.append(p_out)\n            \n    return output_event\n\ndef run_checks(input_event: Event, output_event: Event):\n    \"\"\"Performs the three required checks and returns the boolean results.\"\"\"\n    # Determine scaling factors again for verification\n    s_p = 1e-3 if input_event.mom_unit == 'MEV' else 1.0\n    s_l = 10.0 if input_event.len_unit == 'CM' else 1.0\n    \n    # 1. Units-correct check\n    units_correct = True\n    # Check particle momenta\n    for p_id, p_in in input_event.particles.items():\n        p_out = output_event.particles[p_id]\n        expected_mom = p_in.mom * s_p\n        if not np.allclose(p_out.mom, expected_mom, rtol=1e-12, atol=1e-12):\n            units_correct = False\n            break\n    # Check vertex positions\n    if units_correct:\n        for v_id, v_in in input_event.vertices.items():\n            v_out = output_event.vertices[v_id]\n            expected_pos = v_in.pos * s_l\n            if not np.allclose(v_out.pos, expected_pos, rtol=1e-12, atol=1e-12):\n                units_correct = False\n                break\n\n    # 2. Status-correct check\n    status_correct = True\n    for p_id, p_in in input_event.particles.items():\n        p_out = output_event.particles[p_id]\n        if p_out.status != status_map(p_in.status):\n            status_correct = False\n            break\n\n    # 3. Graph-preserved check\n    graph_preserved = True\n    for p_id, p_in in input_event.particles.items():\n        p_out = output_event.particles[p_id]\n        \n        in_prod_id = p_in.prod_vertex.id if p_in.prod_vertex else None\n        out_prod_id = p_out.prod_vertex.id if p_out.prod_vertex else None\n        \n        in_end_id = p_in.end_vertex.id if p_in.end_vertex else None\n        out_end_id = p_out.end_vertex.id if p_out.end_vertex else None\n        \n        if in_prod_id != out_prod_id or in_end_id != out_end_id:\n            graph_preserved = False\n            break\n\n    return units_correct, status_correct, graph_preserved\n\ndef solve():\n    \"\"\"Main function to define tests, run conversion and checks, and print results.\"\"\"\n    test_cases = [\n        # Event A\n        {\n            \"units\": (\"MEV\", \"MM\"),\n            \"vertices\": [\n                (1, (0.0, 0.0, 0.0, 0.0)),\n                (2, (0.0, 0.0, 1.0, 1.0)),\n            ],\n            \"particles\": [\n                (1, 2, (0.0, 0.0, 1000.0, 1100.0)),\n                (2, 1, (100.0, 0.0, 400.0, 412.3105626)),\n                (3, 1, (-100.0, 0.0, 600.0, 687.6894374)),\n            ],\n            \"links\": [\n                (1, 1, 2),\n                (2, 2, None),\n                (3, 2, None),\n            ]\n        },\n        # Event B\n        {\n            \"units\": (\"GEV\", \"CM\"),\n            \"vertices\": [\n                (10, (0.0, 0.0, 0.0, 0.0)),\n                (11, (0.1, -0.2, 0.3, 0.0)),\n            ],\n            \"particles\": [\n                (12, 2, (0.3, 0.4, 0.0, 0.5)),\n                (13, 1, (0.1, 0.2, 0.0, 0.2236067977)),\n                (14, 1, (0.2, 0.2, 0.0, 0.2763932023)),\n                (10, 3, (0.0, 0.0, 0.0, 0.0)),\n            ],\n            \"links\": [\n                (12, 10, 11),\n                (13, 11, None),\n                (14, 11, None),\n                (10, None, None),\n            ]\n        },\n        # Event C\n        {\n            \"units\": (\"MEV\", \"CM\"),\n            \"vertices\": [\n                (100, (0.0, 0.0, 0.0, 0.0)),\n                (101, (0.0, 0.0, 0.01, 0.01)),\n                (102, (0.0, 0.0, 0.02, 0.02)),\n            ],\n            \"particles\": [\n                (100, 2, (0.0, 0.0, 1500.0, 1600.0)),\n                (101, 2, (0.0, 0.0, 1000.0, 1100.0)),\n                (102, 1, (0.0, 0.0, 500.0, 500.0)),\n                (103, 1, (0.0, 0.0, 500.0, 600.0)),\n            ],\n            \"links\": [\n                (100, 100, 101),\n                (101, 101, 102),\n                (102, 102, None),\n                (103, 102, None),\n            ]\n        }\n    ]\n\n    results = []\n    for case_data in test_cases:\n        # Build input event from data\n        input_event = Event(*case_data[\"units\"])\n        for v_data in case_data[\"vertices\"]:\n            input_event.add_vertex(Vertex(*v_data))\n        for p_data in case_data[\"particles\"]:\n            input_event.add_particle(Particle(*p_data))\n        \n        for p_id, prod_v_id, end_v_id in case_data[\"links\"]:\n            particle = input_event.particles[p_id]\n            if prod_v_id is not None:\n                prod_v = input_event.vertices[prod_v_id]\n                particle.prod_vertex = prod_v\n                prod_v.outgoing_particles.append(particle)\n            if end_v_id is not None:\n                end_v = input_event.vertices[end_v_id]\n                particle.end_vertex = end_v\n                end_v.incoming_particles.append(particle)\n        \n        # Perform conversion\n        output_event = convert_event(input_event)\n        \n        # Run checks and store results\n        check_results = run_checks(input_event, output_event)\n        results.extend(check_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3513391"}, {"introduction": "An event record is not just a collection of data; it is a narrative that must obey the laws of physics and logical consistency. This exercise puts you in the role of a data validator, tasked with ensuring that an event record represents a physically plausible history. You will implement a series of checks that enforce fundamental principles such as four-momentum conservation at each interaction vertex and the causal structure of the decay chain, which must form a directed acyclic graph [@problem_id:3513428].", "problem": "You are given the task of designing and implementing a programmatic validator for high-energy physics event records that represent particle histories as a graph of vertices (interactions or decays) connected by particles. The validator must enforce logically and physically consistent status transitions and related constraints. The event data model follows a simplified but standard model inspired by formats such as HepMC and HEPEVT:\n\n- Each particle has:\n  - A unique integer identifier $p \\in \\mathbb{Z}$.\n  - An integer status $s \\in \\{-1,1,2\\}$, where $s=-1$ denotes an incoming beam particle, $s=1$ denotes a final-state stable particle, and $s=2$ denotes an intermediate decaying or propagating particle.\n  - A production vertex identifier $v_{\\mathrm{prod}} \\in \\mathbb{Z} \\cup \\{\\varnothing\\}$ and an end vertex identifier $v_{\\mathrm{end}} \\in \\mathbb{Z} \\cup \\{\\varnothing\\}$.\n  - A four-momentum $p^{\\mu}=(E,p_x,p_y,p_z)$ in natural units with the speed of light $c$ set to $1$, where all components are given in gigaelectronvolts (GeV). That is, $E$ is in $\\mathrm{GeV}$ and $(p_x,p_y,p_z)$ are in $\\mathrm{GeV}$.\n\n- Each vertex has:\n  - A unique integer identifier $v \\in \\mathbb{Z}$.\n  - A list of incoming particle identifiers and a list of outgoing particle identifiers.\n\nThe validator must enforce the following constraints derived from fundamental principles:\n\n1. Status-vertex incidence rules:\n   - If $s=-1$ (incoming), then $v_{\\mathrm{prod}}=\\varnothing$ and $v_{\\mathrm{end}}\\neq \\varnothing$.\n   - If $s=1$ (final-state), then $v_{\\mathrm{prod}}\\neq \\varnothing$ and $v_{\\mathrm{end}}=\\varnothing$.\n   - If $s=2$ (intermediate), then $v_{\\mathrm{prod}}\\neq \\varnothing$ and $v_{\\mathrm{end}}\\neq \\varnothing$.\n\n2. Vertex-particle consistency:\n   - For every vertex $v$, the declared incoming particle set must equal the set $\\{p \\mid v_{\\mathrm{end}}(p)=v\\}$, and the declared outgoing particle set must equal the set $\\{p \\mid v_{\\mathrm{prod}}(p)=v\\}$.\n   - For every vertex $v$, incoming particles must have $s \\in \\{-1,2\\}$ and outgoing particles must have $s \\in \\{1,2\\}$.\n   - Every vertex must have at least one incoming and at least one outgoing particle.\n\n3. Four-momentum conservation at each vertex $v$:\n   - Let $\\sum_{\\mathrm{in}} p^{\\mu}$ be the sum over incoming four-momenta and $\\sum_{\\mathrm{out}} p^{\\mu}$ be the sum over outgoing four-momenta. The conservation condition is\n     $$\\left|\\sum_{\\mathrm{in}} p^{\\mu} - \\sum_{\\mathrm{out}} p^{\\mu}\\right| \\le \\varepsilon \\quad \\text{component-wise},$$\n     for a given tolerance $\\varepsilon > 0$, interpreted as a bound in $\\mathrm{GeV}$ for each component. Use $\\varepsilon = 10^{-9}\\,\\mathrm{GeV}$.\n\n4. Causal acyclicity of the particle-vertex graph:\n   - Construct a directed graph where for each vertex $v$, for each incoming particle $p_{\\mathrm{in}}$ and each outgoing particle $p_{\\mathrm{out}}$, add an edge $p_{\\mathrm{in}} \\to p_{\\mathrm{out}}$. The graph must be a directed acyclic graph (DAG). Any cycle violates causality.\n\nYour program must implement these checks and output whether each provided event is valid. The output for each event must be a boolean, with $ \\mathrm{True}$ indicating that the event passes all checks and $ \\mathrm{False}$ otherwise.\n\nAll energies and momentum components are to be interpreted and validated in $\\mathrm{GeV}$, using natural units with $c=1$.\n\nTest Suite:\nImplement your validator against the following concrete events. Each event is specified by a list of particles and a list of vertices. Each particle record is a tuple $(\\text{id}, s, v_{\\mathrm{prod}}, v_{\\mathrm{end}}, (E,p_x,p_y,p_z))$, and each vertex record is a tuple $(\\text{id}, [\\text{incoming}], [\\text{outgoing}])$.\n\n- Event $1$ (happy path, valid):\n  - Particles:\n    - $(1,-1,\\varnothing,101,(100,0,0,100))$\n    - $(2,-1,\\varnothing,101,(100,0,0,-100))$\n    - $(3,2,101,102,(120,0,0,10))$\n    - $(4,1,101,\\varnothing,(80,0,0,-10))$\n    - $(5,1,102,\\varnothing,(60,10,0,5))$\n    - $(6,1,102,\\varnothing,(60,-10,0,5))$\n  - Vertices:\n    - $(101,[1,2],[3,4])$\n    - $(102,[3],[5,6])$\n\n- Event $2$ (invalid: final-state particle has an end vertex and participates as incoming at that vertex):\n  - Particles:\n    - $(11,-1,\\varnothing,201,(10,0,0,0))$\n    - $(10,1,201,202,(10,0,0,0))$\n  - Vertices:\n    - $(201,[11],[10])$\n    - $(202,[10],[])$\n\n- Event $3$ (invalid: intermediate without end vertex):\n  - Particles:\n    - $(20,-1,\\varnothing,301,(50,0,0,0))$\n    - $(21,2,301,\\varnothing,(50,0,0,0))$\n  - Vertices:\n    - $(301,[20],[21])$\n\n- Event $4$ (invalid: incoming with a production vertex):\n  - Particles:\n    - $(30,-1,401,402,(5,0,0,0))$\n  - Vertices:\n    - $(401,[],[30])$\n    - $(402,[30],[])$\n\n- Event $5$ (invalid: vertex-particle mismatch and inconsistent production vertex for an outgoing particle):\n  - Particles:\n    - $(40,-1,\\varnothing,501,(10,0,0,0))$\n    - $(41,2,501,502,(10,0,0,0))$\n    - $(42,1,503,\\varnothing,(10,0,0,0))$\n  - Vertices:\n    - $(501,[40],[41])$\n    - $(502,[41],[42])$\n    - $(503,[],[42])$\n\n- Event $6$ (invalid: four-momentum not conserved at a vertex beyond tolerance $\\varepsilon$):\n  - Particles:\n    - $(50,-1,\\varnothing,601,(10,0,0,0))$\n    - $(51,1,601,\\varnothing,(9,0,0,0))$\n  - Vertices:\n    - $(601,[50],[51])$\n\n- Event $7$ (invalid: causal cycle in the graph):\n  - Particles:\n    - $(60,2,701,702,(5,0,0,0))$\n    - $(61,2,702,701,(5,0,0,0))$\n  - Vertices:\n    - $(701,[61],[60])$\n    - $(702,[60],[61])$\n\nYour program must evaluate these $7$ events and produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For example, the output format must be exactly of the form $[\\mathrm{result}_1,\\mathrm{result}_2,\\ldots,\\mathrm{result}_7]$, where each $\\mathrm{result}_i$ is a boolean.", "solution": "The problem statement has been evaluated and is determined to be valid. It is scientifically grounded, well-posed, objective, and contains all necessary information to construct a unique and verifiable solution. We will now proceed with the design and explanation of the validator.\n\nThe programmatic validation of a high-energy physics event record requires a series of checks to ensure the event's logical self-consistency and its adherence to fundamental physical laws. We will design a validator that systematically applies four categories of constraints: (1) status-vertex incidence rules, (2) vertex-particle graph consistency, (3) four-momentum conservation at each vertex, and (4) causal acyclicity. An event is deemed valid only if it passes all checks.\n\nFirst, for efficient access, the event data, provided as lists of particles and vertices, will be parsed into dictionaries mapping unique identifiers to their respective data structures. A particle with identifier $p$ is denoted as $P_p$, and a vertex with identifier $v$ as $V_v$. The four-momentum of particle $p$ is $p^{\\mu}$. The null vertex identifier, $\\varnothing$, is represented by a null value in the implementation.\n\n**1. Status-Vertex Incidence Rules**\n\nThis set of rules formalizes the lifecycle of a particle within an event. A particle's status, $s$, dictates its position in the event's history graph.\n\n*   **Principle**: Particles are classified by their role. An incoming beam particle ($s=-1$) originates from outside the event, thus it has no production vertex ($v_{\\mathrm{prod}}=\\varnothing$), but it must interact at some vertex ($v_{\\mathrm{end}}\\neq \\varnothing$). A final-state particle ($s=1$) is stable and leaves the interaction region, so it must be produced at a vertex ($v_{\\mathrm{prod}}\\neq \\varnothing$) but has no subsequent decay or interaction vertex ($v_{\\mathrm{end}}=\\varnothing$). An intermediate particle ($s=2$) is produced and subsequently decays or interacts, so it must be bracketed by both a production and an end vertex ($v_{\\mathrm{prod}}\\neq \\varnothing$ and $v_{\\mathrm{end}}\\neq \\varnothing$).\n\n*   **Algorithm**: The validator iterates through every particle $P_p$ in the event. For each particle, it checks the following logical conditions:\n    *   If $s(P_p) = -1$, it must be that $v_{\\mathrm{prod}}(P_p) = \\varnothing$ and $v_{\\mathrm{end}}(P_p) \\neq \\varnothing$.\n    *   If $s(P_p) = 1$, it must be that $v_{\\mathrm{prod}}(P_p) \\neq \\varnothing$ and $v_{\\mathrm{end}}(P_p) = \\varnothing$.\n    *   If $s(P_p) = 2$, it must be that $v_{\\mathrm{prod}}(P_p) \\neq \\varnothing$ and $v_{\\mathrm{end}}(P_p) \\neq \\varnothing$.\n    A failure of any of these conditions for any particle invalidates the entire event.\n\n**2. Vertex-Particle Consistency**\n\nThis check ensures that the particle and vertex records provide a consistent and complete description of the event's graph topology.\n\n*   **Principle**: The event record contains two perspectives on the event graph: the particles' vertex pointers ($v_{\\mathrm{prod}}, v_{\\mathrm{end}}$) and the vertices' particle lists (incoming, outgoing). These two perspectives must be mutually consistent. Furthermore, a vertex represents a physical interaction, which must involve particles both entering and exiting, and the status of these particles must be appropriate for their role.\n\n*   **Algorithm**: The validator iterates through every vertex $V_v$. For each vertex, it performs four checks:\n    1.  **Topological Consistency**: It constructs the set of actual incoming particles, $I_{actual} = \\{p \\mid v_{\\mathrm{end}}(P_p) = v\\}$, and the set of actual outgoing particles, $O_{actual} = \\{p \\mid v_{\\mathrm{prod}}(P_p) = v\\}$. It then verifies that these sets are identical to the declared incoming and outgoing particle lists provided with the vertex data, $I_{declared}$ and $O_{declared}$. That is, $I_{actual} = \\text{set}(I_{declared})$ and $O_{actual} = \\text{set}(O_{declared})$.\n    2.  **Particle Status at Vertex**: For every particle $p \\in I_{declared}$, the validator checks that its status $s(P_p) \\in \\{-1, 2\\}$. For every particle $p' \\in O_{declared}$, it checks that its status $s(P_{p'}) \\in \\{1, 2\\}$. A final-state particle ($s=1$) cannot be incoming to a vertex, and an initial-state particle ($s=-1$) cannot be outgoing from one.\n    3.  **Vertex Population**: A physical vertex must represent an interaction or decay. Therefore, it must have at least one incoming and at least one outgoing particle. The validator checks if $|I_{declared}| \\ge 1$ and $|O_{declared}| \\ge 1$.\n    Any discrepancy found in these checks for any vertex marks the event as invalid.\n\n**3. Four-Momentum Conservation**\n\nThis is a stringent test based on one of the most fundamental conservation laws in physics.\n\n*   **Principle**: In the absence of external fields, the total four-momentum of an isolated system is conserved. At each vertex, which represents a local interaction, the sum of the four-momenta of all incoming particles must equal the sum of the four-momenta of all outgoing particles. This stems from the invariance of physical laws under spacetime translation (Noether's theorem).\n\n*   **Algorithm**: For each vertex $V_v$, the validator calculates the sum of four-momenta for all incoming particles, $\\sum_{\\mathrm{in}} p^{\\mu} = \\sum_{p \\in I_{declared}} p^{\\mu}(P_p)$, and for all outgoing particles, $\\sum_{\\mathrm{out}} p^{\\mu} = \\sum_{p' \\in O_{declared}} p^{\\mu}(P_{p'})$. Due to finite floating-point precision, a direct equality check is inappropriate. Instead, the condition is that the absolute difference for each of the four components (energy and three momentum components) must be less than or equal to a small tolerance, $\\varepsilon$. The problem specifies $\\varepsilon = 10^{-9} \\, \\mathrm{GeV}$.\n    $$ \\left| \\left(\\sum_{\\mathrm{in}} p^{\\mu}\\right)_k - \\left(\\sum_{\\mathrm{out}} p^{\\mu}\\right)_k \\right| \\le \\varepsilon $$\n    for each component $k \\in \\{0, 1, 2, 3\\}$. A violation of this condition at any vertex invalidates the event.\n\n**4. Causal Acyclicity**\n\nThis constraint ensures that the event history is causally possible.\n\n*   **Principle**: Causality dictates that an effect cannot precede its cause. In the context of a particle history graph, this means a particle cannot be its own ancestor. For example, a particle cannot decay into products which then interact to re-form the original particle. The sequence of productions and decays must form a Directed Acyclic Graph (DAG).\n\n*   **Algorithm**: A directed graph is constructed where the nodes represent the particles. An edge $p_{\\mathrm{in}} \\to p_{\\mathrm{out}}$ is added if there exists a vertex $V_v$ where $p_{\\mathrm{in}}$ is an incoming particle and $p_{\\mathrm{out}}$ is an outgoing particle. This graph represents the flow of causality and lineage. To check for cycles, a Depth-First Search (DFS) algorithm is employed. During the traversal, nodes are tracked using three states: unvisited, visiting (currently in the recursion stack), and visited (all descendants explored). If the DFS encounters a node that is currently in the 'visiting' state, a back edge has been found, which indicates a cycle. The presence of any cycle violates causality and invalidates the event.\n\nBy methodically applying these four layers of validation, the program can rigorously determine the physical and logical validity of any given event record.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the validator.\n    \"\"\"\n    \n    # Represents the null vertex identifier .\n    NULL_VERTEX = None\n\n    # Test cases as defined in the problem statement.\n    test_cases = [\n        # Event 1 (valid)\n        {\n            \"particles\": [\n                (1, -1, NULL_VERTEX, 101, (100, 0, 0, 100)),\n                (2, -1, NULL_VERTEX, 101, (100, 0, 0, -100)),\n                (3, 2, 101, 102, (120, 0, 0, 10)),\n                (4, 1, 101, NULL_VERTEX, (80, 0, 0, -10)),\n                (5, 1, 102, NULL_VERTEX, (60, 10, 0, 5)),\n                (6, 1, 102, NULL_VERTEX, (60, -10, 0, 5)),\n            ],\n            \"vertices\": [\n                (101, [1, 2], [3, 4]),\n                (102, [3], [5, 6]),\n            ]\n        },\n        # Event 2 (invalid: final-state particle has end vertex)\n        {\n            \"particles\": [\n                (11, -1, NULL_VERTEX, 201, (10, 0, 0, 0)),\n                (10, 1, 201, 202, (10, 0, 0, 0)),\n            ],\n            \"vertices\": [\n                (201, [11], [10]),\n                (202, [10], []),\n            ]\n        },\n        # Event 3 (invalid: intermediate without end vertex)\n        {\n            \"particles\": [\n                (20, -1, NULL_VERTEX, 301, (50, 0, 0, 0)),\n                (21, 2, 301, NULL_VERTEX, (50, 0, 0, 0)),\n            ],\n            \"vertices\": [\n                (301, [20], [21]),\n            ]\n        },\n        # Event 4 (invalid: incoming with production vertex)\n        {\n            \"particles\": [\n                (30, -1, 401, 402, (5, 0, 0, 0)),\n            ],\n            \"vertices\": [\n                (401, [], [30]),\n                (402, [30], []),\n            ]\n        },\n        # Event 5 (invalid: vertex-particle mismatch)\n        {\n            \"particles\": [\n                (40, -1, NULL_VERTEX, 501, (10, 0, 0, 0)),\n                (41, 2, 501, 502, (10, 0, 0, 0)),\n                (42, 1, 503, NULL_VERTEX, (10, 0, 0, 0)),\n            ],\n            \"vertices\": [\n                (501, [40], [41]),\n                (502, [41], [42]),\n                (503, [], [42]),\n            ]\n        },\n        # Event 6 (invalid: four-momentum not conserved)\n        {\n            \"particles\": [\n                (50, -1, NULL_VERTEX, 601, (10, 0, 0, 0)),\n                (51, 1, 601, NULL_VERTEX, (9, 0, 0, 0)),\n            ],\n            \"vertices\": [\n                (601, [50], [51]),\n            ]\n        },\n        # Event 7 (invalid: causal cycle)\n        {\n            \"particles\": [\n                (60, 2, 701, 702, (5, 0, 0, 0)),\n                (61, 2, 702, 701, (5, 0, 0, 0)),\n            ],\n            \"vertices\": [\n                (701, [61], [60]),\n                (702, [60], [61]),\n            ]\n        }\n    ]\n\n    results = [validate_event(case[\"particles\"], case[\"vertices\"], NULL_VERTEX) for case in test_cases]\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef validate_event(particles_list, vertices_list, null_vertex_id):\n    \"\"\"\n    Performs all validation checks for a single event.\n    \"\"\"\n    \n    # Pre-processing: Create efficient look-up maps\n    particles_map = {p[0]: {\"id\": p[0], \"s\": p[1], \"v_prod\": p[2], \"v_end\": p[3], \"pmu\": np.array(p[4])} for p in particles_list}\n    vertices_map = {v[0]: {\"id\": v[0], \"in\": v[1], \"out\": v[2]} for v in vertices_list}\n\n    # 1. Status-vertex incidence rules\n    for p_id, p_data in particles_map.items():\n        s, v_prod, v_end = p_data[\"s\"], p_data[\"v_prod\"], p_data[\"v_end\"]\n        if s == -1 and not (v_prod == null_vertex_id and v_end != null_vertex_id): return False\n        if s == 1 and not (v_prod != null_vertex_id and v_end == null_vertex_id): return False\n        if s == 2 and not (v_prod != null_vertex_id and v_end != null_vertex_id): return False\n\n    # 2. Vertex-particle consistency\n    for v_id, v_data in vertices_map.items():\n        # Check vertex population\n        if not (v_data[\"in\"] and v_data[\"out\"]): return False\n\n        # Compare declared vs actual particle sets at vertex\n        actual_in = {p_id for p_id, p in particles_map.items() if p[\"v_end\"] == v_id}\n        actual_out = {p_id for p_id, p in particles_map.items() if p[\"v_prod\"] == v_id}\n        if set(v_data[\"in\"]) != actual_in or set(v_data[\"out\"]) != actual_out: return False\n\n        # Check status of particles at vertex\n        for p_id in v_data[\"in\"]:\n            if particles_map[p_id][\"s\"] not in [-1, 2]: return False\n        for p_id in v_data[\"out\"]:\n            if particles_map[p_id][\"s\"] not in [1, 2]: return False\n    \n    # 3. Four-momentum conservation\n    epsilon = 1e-9\n    for v_id, v_data in vertices_map.items():\n        sum_in_pmu = np.sum([particles_map[p_id][\"pmu\"] for p_id in v_data[\"in\"]], axis=0)\n        sum_out_pmu = np.sum([particles_map[p_id][\"pmu\"] for p_id in v_data[\"out\"]], axis=0)\n        if not np.all(np.abs(sum_in_pmu - sum_out_pmu) <= epsilon): return False\n\n    # 4. Causal acyclicity\n    # Build adjacency list for the particle causality graph\n    adj = {p_id: [] for p_id in particles_map}\n    for v_data in vertices_map.values():\n        for p_in in v_data[\"in\"]:\n            for p_out in v_data[\"out\"]:\n                adj[p_in].append(p_out)\n    \n    # DFS-based cycle detection\n    # States: 0 = unvisited, 1 = visiting, 2 = visited\n    path = set()  # Corresponds to state 1 (visiting)\n    visited = set() # Corresponds to state 2 (visited)\n\n    def has_cycle(node):\n        path.add(node)\n        for neighbor in adj.get(node, []):\n            if neighbor in path:\n                return True\n            if neighbor not in visited:\n                if has_cycle(neighbor):\n                    return True\n        path.remove(node)\n        visited.add(node)\n        return False\n\n    for node in particles_map:\n        if node not in visited:\n            if has_cycle(node):\n                return False\n\n    return True\n\nsolve()\n```", "id": "3513428"}]}