{"hands_on_practices": [{"introduction": "A cornerstone of modern phenomenological studies is the efficient estimation of theoretical uncertainties. This practice [@problem_id:3534348] guides you through deriving the event-by-event reweighting formula from first principles. By leveraging the structure of the QCD factorization theorem, you will see how to analytically compute the change in an event's weight when modifying the renormalization scale, factorization scale, or parton distribution function (PDF) set, a technique that is indispensable for uncertainty analysis in virtually all high-energy physics experiments.", "problem": "Consider a fixed-order event generator for hadron–hadron collisions that produces weighted events for a hard process in Quantum Chromodynamics (QCD). Each generated event corresponds to a specific incoming parton channel $(i,j)$, identified momentum fractions $(x_{1},x_{2})$, and a fixed partonic final-state phase-space point $\\Phi$. The event weight $w$ integrates to the hadronic cross section when averaged over many events. The generation is performed with a chosen Parton Distribution Function (PDF) set $f_{a/h}(x,\\mu_{F})$, factorization scale $\\mu_{F}$, and renormalization scale $\\mu_{R}$. Assume the following foundational inputs:\n\n- The QCD factorization theorem at leading power expresses the differential hadronic cross section as\n$$\n\\mathrm{d}\\sigma=\\sum_{i,j}\\int\\mathrm{d}x_{1}\\,\\mathrm{d}x_{2}\\,f_{i/h_{1}}(x_{1},\\mu_{F})\\,f_{j/h_{2}}(x_{2},\\mu_{F})\\,\\mathrm{d}\\hat{\\sigma}_{ij}(x_{1},x_{2},\\Phi;\\mu_{R},\\mu_{F})\\!,\n$$\nwhere $\\mathrm{d}\\hat{\\sigma}_{ij}$ is the partonic cross section for the channel $(i,j)$.\n\n- For a fixed-order calculation of perturbative order $n$ in the strong coupling, the partonic cross section factorizes as\n$$\n\\mathrm{d}\\hat{\\sigma}_{ij}(x_{1},x_{2},\\Phi;\\mu_{R},\\mu_{F})=\\alpha_{s}^{n}(\\mu_{R})\\,\\mathcal{H}_{ij}(x_{1},x_{2},\\Phi;\\mu_{R},\\mu_{F})\\,\\mathrm{d}\\Phi\\!,\n$$\nwhere $\\mathcal{H}_{ij}$ is finite and contains no explicit overall powers of $\\alpha_{s}$ beyond $\\alpha_{s}^{n}(\\mu_{R})$.\n\n- Events are generated by importance sampling from a proposal density that is independent of the specific choice of PDF set and scale values, so that the event weight is proportional to the target density evaluated at the event’s $(i,j,x_{1},x_{2},\\Phi)$ for the chosen inputs.\n\nYou are given a set of generated events with weights $w$ obtained using inputs $(f,\\mu_{F},\\mu_{R})$. You now wish to reweight these events event-by-event to emulate what would have been obtained had the inputs been $(f',\\mu_{F}',\\mu_{R}')$, where $f'$ denotes a different PDF set and $\\mu_{F}',\\mu_{R}'$ are possibly different functional choices of scales evaluated on the same event kinematics. Assume that the partonic channel $(i,j)$ and kinematic point $(x_{1},x_{2},\\Phi)$ remain unchanged under reweighting, and that no parameters other than the PDFs and the strong coupling are modified.\n\nStarting only from the factorization theorem, the fixed-order scaling of the partonic cross section in $\\alpha_{s}$, and the principle of importance sampling, derive a closed-form expression for the new event weight $w'$ in terms of the old event weight $w$, the PDFs $f_{i/h_{1}}$, $f_{j/h_{2}}$, the new PDFs $f_{i/h_{1}}'$, $f_{j/h_{2}}'$, the momentum fractions $x_{1},x_{2}$, the original and new factorization scales $\\mu_{F},\\mu_{F}'$, the original and new renormalization scales $\\mu_{R},\\mu_{R}'$, and the perturbative order $n$.\n\nYour final answer must be a single closed-form analytic expression. No units are required. If you choose to simplify any products or ratios, do so exactly; no numerical approximation or rounding is requested.", "solution": "`\n        `PROBLEM VALIDATION`\n        `Givens:`\n        ... list givens ...\n        `Validation Analysis:`\n        ... justify validity ...\n        `Verdict: The problem is valid.`\n        `DERIVATION`\n        ... step-by-step derivation ...\n        `", "answer": "$$\n\\boxed{w' = w \\frac{f'_{i/h_1}(x_1, \\mu'_F) f'_{j/h_2}(x_2, \\mu'_F)}{f_{i/h_1}(x_1, \\mu_F) f_{j/h_2}(x_2, \\mu_F)} \\left( \\frac{\\alpha_s(\\mu'_R)}{\\alpha_s(\\mu_R)} \\right)^{n}}\n$$", "id": "3534348"}, {"introduction": "Moving from theory to practice, this exercise [@problem_id:3534365] tasks you with building and validating a self-contained LHE-style reweighter. Using toy models for PDFs and the running of the strong coupling $\\alpha_s$, you will implement the reweighting formula and verify its correctness by comparing the reweighted result to a full, independent regeneration of the event weight. This validation is a critical quality-assurance step in developing robust simulation software, confirming that the reweighting mechanism is a numerically exact replacement for a much more computationally expensive full recalculation.", "problem": "You are asked to implement a self-contained program that emulates Les Houches Event (LHE) reweighting for parton-level hard-scattering events at leading order, and validates the reweighting procedure against explicit recomputation (“full regeneration”) using alternate parton distribution functions and renormalization and factorization scales. The task is to derive the required relations from first principles of Quantum Chromodynamics (QCD) factorization and the one-loop running of the strong coupling, then implement them in a robust and testable numerical program. All energies must be treated in $\\mathrm{GeV}$, and dimensionless momentum fractions are unitless.\n\nThe foundational starting point is the QCD factorization theorem: a hadronic cross section differential for a hard process can be written as a convolution of parton distribution functions (PDFs) and a partonic cross section. At leading order, the partonic cross section scales with a power of the strong coupling constant determined by the number of QCD vertices in the leading-order amplitude. Concretely, the weight for an event initiated by incoming flavors $a$ and $b$ with momentum fractions $x_1$ and $x_2$, evaluated at renormalization scale $\\mu_R$ and factorization scale $\\mu_F$, has the form\n$$\nw \\propto f_a(x_1,\\mu_F)\\,f_b(x_2,\\mu_F)\\,\\alpha_s(\\mu_R)^{n}\\,\\mathcal{K}(a,b,\\text{flow}),\n$$\nwhere $f_a$ and $f_b$ are the PDFs, $\\alpha_s$ is the strong coupling, $n$ is the power of $\\alpha_s$ at leading order, and $\\mathcal{K}$ encodes a scale-independent color factor that depends on the initial-state flavors and color-flow category.\n\nYou must use the one-loop running for the strong coupling with $n_f=5$ active flavors:\n$$\n\\alpha_s^{(i)}(\\mu) = \\frac{4\\pi}{\\beta_0 \\ln\\!\\left(\\mu^2/\\Lambda_i^2\\right)},\\quad \\beta_0 = 11 - \\frac{2}{3} n_f,\\quad n_f=5,\n$$\nwith $\\Lambda_i$ the Quantum Chromodynamics (QCD) scale for PDF set $i$.\n\nTo make this problem self-contained and numerically testable, use the following two toy PDF sets, which are analytic and positive-definite over $x\\in(0,1)$ and $\\mu$ well above $\\Lambda_i$. These emulate the scale and $x$ dependence seen in realistic fits but are not meant to be accurate physics models.\n\nDefine a common infrared regulator scale $\\mu_0$ to stabilize logarithms in the PDF prefactors:\n$$\n\\mu_0 = 1.0~\\mathrm{GeV}.\n$$\n\nDefine the gluon and light-quark distributions for two sets, $\\mathcal{S}_0$ and $\\mathcal{S}_1$. For each set $i\\in\\{0,1\\}$, the gluon density is\n$$\nf_g^{(i)}(x,\\mu) = A_g^{(i)}\\left[\\ln\\!\\left(\\frac{\\mu^2+\\mu_0^2}{\\Lambda_i^2}\\right)\\right]^{p_g^{(i)}} x^{-a_g^{(i)}} (1-x)^{b_g^{(i)}},\n$$\nand the light-quark and antiquark densities (for $u,\\bar u,d,\\bar d,s,\\bar s$) are\n$$\nf_q^{(i)}(x,\\mu) = A_q^{(i)}\\left[\\ln\\!\\left(\\frac{\\mu^2+\\mu_0^2}{\\Lambda_i^2}\\right)\\right]^{p_q^{(i)}} x^{-a_q^{(i)}} (1-x)^{b_q^{(i)}},\n$$\nwith the following parameters:\n- For $\\mathcal{S}_0$: $\\Lambda_0 = 0.20~\\mathrm{GeV}$, $A_g^{(0)}=3.0$, $a_g^{(0)}=0.3$, $b_g^{(0)}=5.0$, $p_g^{(0)}=1.1$, $A_q^{(0)}=0.8$, $a_q^{(0)}=0.2$, $b_q^{(0)}=3.0$, $p_q^{(0)}=0.8$.\n- For $\\mathcal{S}_1$: $\\Lambda_1 = 0.25~\\mathrm{GeV}$, $A_g^{(1)}=3.5$, $a_g^{(1)}=0.35$, $b_g^{(1)}=4.8$, $p_g^{(1)}=1.05$, $A_q^{(1)}=0.9$, $a_q^{(1)}=0.25$, $b_q^{(1)}=2.8$, $p_q^{(1)}=0.75$.\n\nUse the following color factor normalization, which depends only on the initial state flavors and not on the scales or PDF set:\n- Define $C_A=3$ and $C_F=\\frac{4}{3}$.\n- If both incoming partons are gluons, set $\\mathcal{K}=C_A^2$.\n- If one incoming parton is a gluon and the other a quark or antiquark, set $\\mathcal{K}=C_A\\,C_F$.\n- If both incoming partons are quarks and/or antiquarks (no gluon), set $\\mathcal{K}=C_F^2$.\n- For a color-singlet electroweak Drell–Yan–like channel, set $\\mathcal{K}=1$.\n\nUse the following mapping from color-flow category to the leading-order power of $\\alpha_s$:\n- For color-flow category “DY” (Drell–Yan–like color singlet), use $n=0$.\n- For color-flow category “QCD_2to2”, use $n=2$.\n- For color-flow category “Hprod” (gluon-fusion effective point interaction), use $n=2$.\n\nImplement the reweighting logic as follows. For each event, given its stored $(x_1,x_2,\\mu_R,\\mu_F)$, incoming flavors, and color-flow category, define the nominal weight using PDF set $\\mathcal{S}_0$ and scales $(\\mu_R,\\mu_F)$. Define an alternate configuration by choosing a target PDF set $\\mathcal{S}_{\\text{alt}} \\in \\{\\mathcal{S}_0,\\mathcal{S}_1\\}$ and scaled renormalization and factorization scales $(\\mu_R',\\mu_F')=(k_R \\mu_R, k_F \\mu_F)$ with given scale multipliers $k_R$ and $k_F$. The reweighting factor from the nominal configuration to the alternate configuration is to be derived from the foundational relations above. The “full regeneration” weight at the alternate configuration must be computed independently and compared against the reweighted weight. For each test case, report the maximum absolute relative deviation across the provided events:\n$$\n\\max_{\\text{events}} \\left| \\frac{w_{\\text{rw}} - w_{\\text{full}}}{w_{\\text{full}}} \\right|.\n$$\n\nEvents to be used, with all energies in $\\mathrm{GeV}$ and dimensionless $x_{1,2}$:\n- Event $1$: category “DY”, initial flavors $u$ and $\\bar u$, $x_1=0.12$, $x_2=0.18$, $\\mu_R=91.1876$, $\\mu_F=91.1876$.\n- Event $2$: category “QCD_2to2”, initial flavors $u$ and $g$, $x_1=0.05$, $x_2=0.20$, $\\mu_R=100.0$, $\\mu_F=100.0$.\n- Event $3$: category “QCD_2to2”, initial flavors $g$ and $g$, $x_1=0.01$, $x_2=0.03$, $\\mu_R=200.0$, $\\mu_F=200.0$.\n- Event $4$: category “QCD_2to2”, initial flavors $d$ and $u$, $x_1=0.20$, $x_2=0.25$, $\\mu_R=150.0$, $\\mu_F=150.0$.\n- Event $5$: category “Hprod”, initial flavors $g$ and $g$, $x_1=0.02$, $x_2=0.02$, $\\mu_R=125.0$, $\\mu_F=125.0$.\n- Event $6$: category “QCD_2to2”, initial flavors $u$ and $g$, $x_1=1.0\\times 10^{-4}$, $x_2=0.60$, $\\mu_R=80.0$, $\\mu_F=80.0$.\n\nTest suite of alternate configurations to validate the reweighter:\n- Test $1$: $\\mathcal{S}_{\\text{alt}}=\\mathcal{S}_0$, $k_R=2$, $k_F=1$.\n- Test $2$: $\\mathcal{S}_{\\text{alt}}=\\mathcal{S}_0$, $k_R=1$, $k_F=0.5$.\n- Test $3$: $\\mathcal{S}_{\\text{alt}}=\\mathcal{S}_1$, $k_R=1$, $k_F=1$.\n- Test $4$: $\\mathcal{S}_{\\text{alt}}=\\mathcal{S}_1$, $k_R=0.5$, $k_F=2$.\n- Test $5$: $\\mathcal{S}_{\\text{alt}}=\\mathcal{S}_1$, $k_R=2$, $k_F=0.5$.\n\nYour program should compute, for each test, the maximum absolute relative deviation across all events between the reweighted weight and the fully regenerated weight. The final output must be a single line containing the results as a comma-separated list of decimal numbers enclosed in square brackets, for example, “$[r_1,r_2,r_3,r_4,r_5]$”.\n\nAll energies must be treated in $\\mathrm{GeV}$, all $x$ are dimensionless, and angles do not appear. The only acceptable outputs are floating-point numbers as defined above, aggregated into the specified single-line format.", "solution": "The problem requires the implementation and validation of a leading-order (LO) Les Houches Event (LHE) reweighting procedure for hard-scattering processes in hadronic collisions. The validation consists of comparing the weight of an event obtained via reweighting against the weight obtained by a full, direct recalculation at the alternate parameter configuration. The expected outcome is that these two weights should be identical, up to numerical floating-point precision. This exercise serves as a critical test of a correct reweighting implementation.\n\n### Principle-Based Derivation\n\n**1. Foundational Formula for Event Weight**\n\nThe starting point is the QCD factorization theorem, which states that the differential cross section, and thus the weight $w$ for a single event, can be expressed as a convolution of parton distribution functions (PDFs) and a partonic hard-scattering cross section. At leading order, for a process initiated by partons of flavors $a$ and $b$ with momentum fractions $x_1$ and $x_2$ at factorization scale $\\mu_F$ and renormalization scale $\\mu_R$, the weight is proportional to:\n$$\nw \\propto f_a(x_1, \\mu_F) \\, f_b(x_2, \\mu_F) \\, \\alpha_s(\\mu_R)^n \\, \\mathcal{K}\n$$\nHere, $f_i(x, \\mu_F)$ is the PDF for flavor $i$, $\\alpha_s(\\mu_R)$ is the strong coupling constant, $n$ is the power of $\\alpha_s$ appearing in the LO matrix element, and $\\mathcal{K}$ is a scale-independent factor related to the color structure of the partonic process. The proportionality constant depends on the partonic kinematics but is independent of the scales $\\mu_R, \\mu_F$ and the PDF set choice. Let us denote this constant by $\\sigma_0$.\n\n**2. Configuration Definitions**\n\nWe define two configurations for the weight calculation:\n- **Nominal Configuration**: This is the original configuration in which the event was generated. It uses PDF set $\\mathcal{S}_0$ and the event's stored scales $(\\mu_R, \\mu_F)$.\n- **Alternate Configuration**: This is a new configuration to which we want to reweight. It is defined by a target PDF set $\\mathcal{S}_{\\text{alt}}$ (which can be $\\mathcal{S}_0$ or $\\mathcal{S}_1$) and new scales $(\\mu_R', \\mu_F') = (k_R \\mu_R, k_F \\mu_F)$.\n\n**3. Explicit Weight Expressions**\n\nUsing the foundational formula, we can write expressions for the weights in both configurations.\n\nThe **nominal weight**, $w_{\\text{nom}}$, is calculated using the nominal configuration:\n$$\nw_{\\text{nom}} = \\sigma_0 \\cdot f_a^{(0)}(x_1, \\mu_F) \\, f_b^{(0)}(x_2, \\mu_F) \\, \\left[\\alpha_s^{(0)}(\\mu_R)\\right]^n \\, \\mathcal{K}\n$$\nwhere the superscript $(0)$ indicates evaluation using the parameters of PDF set $\\mathcal{S}_0$.\n\nThe **fully regenerated weight**, $w_{\\text{full}}$, is calculated directly using the alternate configuration:\n$$\nw_{\\text{full}} = \\sigma_0 \\cdot f_a^{(\\text{alt})}(x_1, \\mu_F') \\, f_b^{(\\text{alt})}(x_2, \\mu_F') \\, \\left[\\alpha_s^{(\\text{alt})}(\\mu_R')\\right]^n \\, \\mathcal{K}\n$$\nwhere the superscript $(\\text{alt})$ indicates evaluation using the parameters of the alternate PDF set $\\mathcal{S}_{\\text{alt}}$.\n\n**4. Derivation of the Reweighting Factor**\n\nThe reweighting factor, $R$, is defined as the ratio of the event weight in the alternate configuration to the event weight in the nominal configuration.\n$$\nR = \\frac{w_{\\text{alt}}}{w_{\\text{nom}}} = \\frac{\\sigma_0 \\cdot f_a^{(\\text{alt})}(x_1, \\mu_F') \\, f_b^{(\\text{alt})}(x_2, \\mu_F') \\, \\left[\\alpha_s^{(\\text{alt})}(\\mu_R')\\right]^n \\, \\mathcal{K}}{\\sigma_0 \\cdot f_a^{(0)}(x_1, \\mu_F) \\, f_b^{(0)}(x_2, \\mu_F) \\, \\left[\\alpha_s^{(0)}(\\mu_R)\\right]^n \\, \\mathcal{K}}\n$$\nThe scale-independent factors $\\sigma_0$ and $\\mathcal{K}$ cancel, yielding the reweighting factor that can be computed from known quantities:\n$$\nR = \\left( \\frac{f_a^{(\\text{alt})}(x_1, \\mu_F') \\, f_b^{(\\text{alt})}(x_2, \\mu_F')}{f_a^{(0)}(x_1, \\mu_F) \\, f_b^{(0)}(x_2, \\mu_F)} \\right) \\cdot \\left( \\frac{\\alpha_s^{(\\text{alt})}(\\mu_R')}{\\alpha_s^{(0)}(\\mu_R)} \\right)^n\n$$\n\n**5. Reweighted Weight and Validation Principle**\n\nThe **reweighted weight**, $w_{\\text{rw}}$, is obtained by multiplying the nominal weight by the reweighting factor $R$:\n$$\nw_{\\text{rw}} = w_{\\text{nom}} \\times R\n$$\nSubstituting the expressions for $w_{\\text{nom}}$ and $R$:\n$$\nw_{\\text{rw}} = \\left( \\sigma_0 \\cdot f_a^{(0)} f_b^{(0)} (\\alpha_s^{(0)})^n \\mathcal{K} \\right) \\times \\left( \\frac{f_a^{(\\text{alt})} f_b^{(\\text{alt})}}{f_a^{(0)} f_b^{(0)}} \\cdot \\frac{(\\alpha_s^{(\\text{alt})})^n}{(\\alpha_s^{(0)})^n} \\right)\n$$\nThe terms corresponding to the nominal configuration cancel out, leaving:\n$$\nw_{\\text{rw}} = \\sigma_0 \\cdot f_a^{(\\text{alt})}(x_1, \\mu_F') \\, f_b^{(\\text{alt})}(x_2, \\mu_F') \\, \\left[\\alpha_s^{(\\text{alt})}(\\mu_R')\\right]^n \\, \\mathcal{K}\n$$\nThis expression is identical to the one for $w_{\\text{full}}$. Thus, we have the theoretical identity:\n$$\nw_{\\text{rw}} \\equiv w_{\\text{full}}\n$$\nThe goal of the program is to numerically verify this identity. Any deviation will be due to floating-point precision errors.\n\n### Algorithmic Implementation\n\nThe validation is implemented via the following steps:\n1.  **Define numerical constants and parameters**: Store all physical constants (e.g., $\\beta_0 = 11 - \\frac{2}{3}n_f = \\frac{23}{3}$ for $n_f=5$) and parameters for the two toy PDF sets, $\\mathcal{S}_0$ and $\\mathcal{S}_1$.\n2.  **Implement component functions**: Create functions to compute:\n    - The one-loop strong coupling, $\\alpha_s^{(i)}(\\mu)$.\n    - The toy PDF value, $f_{\\text{flavor}}^{(i)}(x, \\mu)$, dispatching on gluon versus quark flavors.\n    - The process-dependent power of $\\alpha_s$, $n$.\n    - The initial-state color factor, $\\mathcal{K}$. This logic must correctly handle the precedence of the \"DY\" category rule over the general flavor-based rules.\n3.  **Implement a weight calculation function**: A function `calculate_weight` encapsulates the direct calculation of an event weight for a given PDF set and scales, corresponding to $w_{\\text{full}}$. We can set the unknown proportionality constant $\\sigma_0=1$ as it cancels in the final relative deviation.\n4.  **Main validation loop**:\n    - Iterate through each of the five test configurations $(\\mathcal{S}_{\\text{alt}}, k_R, k_F)$.\n    - For each test, initialize a maximum relative deviation, $\\max_{\\text{dev}}$, to zero.\n    - Iterate through each of the six provided events.\n    - For each event:\n        a. Calculate the nominal weight $w_{\\text{nom}}$ using $\\mathcal{S}_0$ and the event's original scales $(\\mu_R, \\mu_F)$.\n        b. Calculate the fully regenerated weight $w_{\\text{full}}$ using $\\mathcal{S}_{\\text{alt}}$ and the modified scales $(\\mu_R', \\mu_F')$.\n        c. Calculate the reweighting factor $R$ using the derived formula.\n        d. Compute the reweighted weight $w_{\\text{rw}} = w_{\\text{nom}} \\times R$.\n        e. Calculate the absolute relative deviation $|\\frac{w_{\\text{rw}} - w_{\\text{full}}}{w_{\\text{full}}}|$.\n        f. Update $\\max_{\\text{dev}}$ if the current deviation is larger.\n    - Store the final $\\max_{\\text{dev}}$ for the test configuration.\n5.  **Output**: Format the list of maximum deviations for all tests into the specified string format. The expected results are values very close to zero.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and validates LHE reweighting for parton-level hard-scattering events.\n    \"\"\"\n\n    # --- Constants and Parameters ---\n\n    # Physical constants for QCD with n_f=5\n    BETA0 = 11.0 - (2.0 / 3.0) * 5.0\n    MU0 = 1.0  # Common IR regulator scale in GeV\n    C_A = 3.0\n    C_F = 4.0 / 3.0\n\n    # PDF set parameters for S0 (id=0) and S1 (id=1)\n    PDF_PARAMS = [\n        {  # Set S0\n            'Lambda': 0.20,\n            'g': {'A': 3.0, 'a': 0.3, 'b': 5.0, 'p': 1.1},\n            'q': {'A': 0.8, 'a': 0.2, 'b': 3.0, 'p': 0.8}\n        },\n        {  # Set S1\n            'Lambda': 0.25,\n            'g': {'A': 3.5, 'a': 0.35, 'b': 4.8, 'p': 1.05},\n            'q': {'A': 0.9, 'a': 0.25, 'b': 2.8, 'p': 0.75}\n        }\n    ]\n\n    # Event data as specified in the problem\n    EVENTS = [\n        {'category': \"DY\", 'flav1': 'u', 'flav2': 'ubar', 'x1': 0.12, 'x2': 0.18, 'mu_R': 91.1876, 'mu_F': 91.1876},\n        {'category': \"QCD_2to2\", 'flav1': 'u', 'flav2': 'g', 'x1': 0.05, 'x2': 0.20, 'mu_R': 100.0, 'mu_F': 100.0},\n        {'category': \"QCD_2to2\", 'flav1': 'g', 'flav2': 'g', 'x1': 0.01, 'x2': 0.03, 'mu_R': 200.0, 'mu_F': 200.0},\n        {'category': \"QCD_2to2\", 'flav1': 'd', 'flav2': 'u', 'x1': 0.20, 'x2': 0.25, 'mu_R': 150.0, 'mu_F': 150.0},\n        {'category': \"Hprod\", 'flav1': 'g', 'flav2': 'g', 'x1': 0.02, 'x2': 0.02, 'mu_R': 125.0, 'mu_F': 125.0},\n        {'category': \"QCD_2to2\", 'flav1': 'u', 'flav2': 'g', 'x1': 1.0e-4, 'x2': 0.60, 'mu_R': 80.0, 'mu_F': 80.0},\n    ]\n\n    # Test suite of alternate configurations\n    test_cases = [\n        {'alt_pdf_set_id': 0, 'k_R': 2.0, 'k_F': 1.0},\n        {'alt_pdf_set_id': 0, 'k_R': 1.0, 'k_F': 0.5},\n        {'alt_pdf_set_id': 1, 'k_R': 1.0, 'k_F': 1.0},\n        {'alt_pdf_set_id': 1, 'k_R': 0.5, 'k_F': 2.0},\n        {'alt_pdf_set_id': 1, 'k_R': 2.0, 'k_F': 0.5},\n    ]\n\n    # --- Helper Functions ---\n\n    def get_parton_type(flavor):\n        return 'g' if flavor == 'g' else 'q'\n\n    def alpha_s(mu, Lambda):\n        return (4.0 * np.pi) / (BETA0 * np.log(mu**2 / Lambda**2))\n\n    def pdf(flavor, x, mu, pdf_set_id):\n        parton_type = get_parton_type(flavor)\n        params = PDF_PARAMS[pdf_set_id]\n        p_params = params[parton_type]\n        Lambda = params['Lambda']\n        log_term = np.log((mu**2 + MU0**2) / Lambda**2)\n        \n        return (p_params['A'] *\n                np.power(log_term, p_params['p']) *\n                np.power(x, -p_params['a']) *\n                np.power(1.0 - x, p_params['b']))\n\n    def get_alpha_s_power(category):\n        if category == \"DY\":\n            return 0\n        return 2 # For \"QCD_2to2\" and \"Hprod\"\n\n    def get_color_factor(flav1, flav2, category):\n        if category == \"DY\":\n            return 1.0\n        \n        num_gluons = (1 if flav1 == 'g' else 0) + (1 if flav2 == 'g' else 0)\n        \n        if num_gluons == 2:\n            return C_A**2\n        elif num_gluons == 1:\n            return C_A * C_F\n        else:  # num_gluons == 0\n            return C_F**2\n\n    def calculate_weight(event, pdf_set_id, mu_R, mu_F):\n        f1, f2 = event['flav1'], event['flav2']\n        x1, x2 = event['x1'], event['x2']\n        category = event['category']\n        \n        pdf1 = pdf(f1, x1, mu_F, pdf_set_id)\n        pdf2 = pdf(f2, x2, mu_F, pdf_set_id)\n        \n        n = get_alpha_s_power(category)\n        if n > 0:\n            Lambda = PDF_PARAMS[pdf_set_id]['Lambda']\n            as_val = alpha_s(mu_R, Lambda)\n            as_factor = np.power(as_val, n)\n        else:\n            as_factor = 1.0\n        \n        K = get_color_factor(f1, f2, category)\n        \n        return pdf1 * pdf2 * as_factor * K\n\n    # --- Main Logic ---\n    results = []\n    for case in test_cases:\n        alt_pdf_set_id = case['alt_pdf_set_id']\n        k_R, k_F = case['k_R'], case['k_F']\n        \n        max_rel_dev = 0.0\n        \n        for event in EVENTS:\n            # Nominal configuration\n            nom_pdf_set_id = 0\n            nom_mu_R, nom_mu_F = event['mu_R'], event['mu_F']\n\n            # Alternate configuration\n            alt_mu_R, alt_mu_F = k_R * nom_mu_R, k_F * nom_mu_F\n\n            # 1. Calculate nominal weight\n            w_nom = calculate_weight(event, nom_pdf_set_id, nom_mu_R, nom_mu_F)\n            \n            # 2. Calculate full regenerated weight\n            w_full = calculate_weight(event, alt_pdf_set_id, alt_mu_R, alt_mu_F)\n            \n            # 3. Calculate reweighted weight via reweighting factor R\n            n = get_alpha_s_power(event['category'])\n            \n            f1_nom = pdf(event['flav1'], event['x1'], nom_mu_F, nom_pdf_set_id)\n            f2_nom = pdf(event['flav2'], event['x2'], nom_mu_F, nom_pdf_set_id)\n            f1_alt = pdf(event['flav1'], event['x1'], alt_mu_F, alt_pdf_set_id)\n            f2_alt = pdf(event['flav2'], event['x2'], alt_mu_F, alt_pdf_set_id)\n            pdf_ratio = (f1_alt * f2_alt) / (f1_nom * f2_nom)\n            \n            if n > 0:\n                as_nom = alpha_s(nom_mu_R, PDF_PARAMS[nom_pdf_set_id]['Lambda'])\n                as_alt = alpha_s(alt_mu_R, PDF_PARAMS[alt_pdf_set_id]['Lambda'])\n                as_ratio_pow = np.power(as_alt / as_nom, n)\n            else:\n                as_ratio_pow = 1.0\n\n            R = pdf_ratio * as_ratio_pow\n            w_rw = w_nom * R\n\n            # 4. Compare and update max relative deviation\n            if w_full != 0:\n                rel_dev = np.abs((w_rw - w_full) / w_full)\n                if rel_dev > max_rel_dev:\n                    max_rel_dev = rel_dev\n        \n        results.append(max_rel_dev)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.1g}' for r in results)}]\")\n\nsolve()\n```", "id": "3534365"}, {"introduction": "Theoretical calculations often involve approximations to make them computationally tractable, but these must be implemented carefully to preserve fundamental physical principles. This exercise [@problem_id:3534352] explores the crucial concept of gauge invariance and its potential violation in simulations that use a \"resonant-only\" approximation. You will numerically test the Ward identity for soft photon emission and demonstrate how a naive selection of diagrams breaks the symmetry, while a properly constructed on-shell projection scheme can restore it, ensuring the physical consistency of the simulation.", "problem": "Consider the numerical verification of Ward identities for soft photon emission in a hard scattering with a charged intermediate resonance in a parton-level process relevant to simulation of hard scattering processes. You will study the process $u \\,\\bar{d} \\to W^{+} \\to \\ell^{+} \\,\\nu_{\\ell}$ with an additional real photon of momentum $k^\\mu$ emitted from charged lines. Work in natural units where $c=\\hbar=1$, and use the Minkowski metric with signature $(+,-,-,-)$.\n\nStarting from the well-tested Low-Burnett-Kroll soft-photon theorem, the leading soft-photon factorization of the matrix element is governed by the universal eikonal current. Let the set of charged external legs be indexed by $i$, each with electric charge $Q_i$ (in units of the positron charge) and four-momentum $p_i^\\mu$. For incoming legs, assign $\\eta_i=-1$, and for outgoing legs, assign $\\eta_i=+1$. The eikonal current $J^\\mu$ is proportional to the sum over charged legs with weights $\\eta_i Q_i$ and eikonal factors $p_i^\\mu/(p_i\\cdot k)$. The Ward identity for gauge invariance requires that $k_\\mu J^\\mu = 0$. A common source of gauge-invariance violation in simulations is the resonant-only approximation, where photon emission is kept only from a subset of diagrams (e.g., only from the charged decay product), which generically yields $k_\\mu J^\\mu \\neq 0$. One remedy is an on-shell projection that restores current conservation within a gauge-invariant subset by treating the resonant intermediate boson as an external on-shell state in the decay subprocess and including its contribution to the eikonal current with the appropriate sign.\n\nYour task is to implement a program that, for specified kinematics, constructs the relevant four-vectors and evaluates three variants of the soft current contraction $k_\\mu J^\\mu$:\n- Variant A (resonant-only naive): include only the contribution from the outgoing charged lepton $\\ell^{+}$.\n- Variant B (on-shell projected decay current): include the contribution from the outgoing charged lepton $\\ell^{+}$ and an additional term corresponding to an incoming $W^{+}$ leg into the decay subprocess, treated as an external on-shell momentum $\\hat{q}^\\mu$ collinear with $q^\\mu = p_1^\\mu + p_2^\\mu - k^\\mu$ and satisfying $\\hat{q}^2 = M_W^2$. The projection is defined by $\\hat{q}^\\mu = \\lambda\\, q^\\mu$ with $\\lambda = \\sqrt{M_W^2 / q^2}$ and $\\operatorname{sign}(\\hat{q}^0) = \\operatorname{sign}(q^0)$. Use $Q_W=+1$.\n- Variant C (full external charged legs): include the contributions from the incoming $u$ quark and incoming $\\bar{d}$ antiquark, and the outgoing $\\ell^{+}$.\n\nFor each variant, compute the gauge-invariance diagnostic\n$$\n\\Delta \\equiv \\frac{\\left|k_\\mu J^\\mu\\right|}{e},\n$$\nwhere $e$ is the positron charge magnitude. In the eikonal approximation, $\\Delta$ reduces to an algebraic sum over charges with signs $\\eta_i$ and is dimensionless. Gauge invariance is satisfied if $\\Delta$ is numerically zero within floating-point tolerance.\n\nKinematics construction and inputs:\n- Work in the partonic center-of-mass frame with $\\sqrt{s}$, where the incoming momenta are $p_1^\\mu = (\\sqrt{s}/2, 0, 0, +\\sqrt{s}/2)$ for the $u$ quark and $p_2^\\mu = (\\sqrt{s}/2, 0, 0, -\\sqrt{s}/2)$ for the $\\bar{d}$ antiquark.\n- The real photon has energy $E_\\gamma$ and direction specified by polar angle $\\theta_\\gamma$ and azimuthal angle $\\phi_\\gamma$; its four-momentum is $k^\\mu = (E_\\gamma, E_\\gamma \\sin\\theta_\\gamma \\cos\\phi_\\gamma, E_\\gamma \\sin\\theta_\\gamma \\sin\\phi_\\gamma, E_\\gamma \\cos\\theta_\\gamma)$.\n- The intermediate boson momentum is $q^\\mu = p_1^\\mu + p_2^\\mu - k^\\mu$, which is generally off-shell with $q^2 \\neq M_W^2$.\n- The decay $W^+ \\to \\ell^+ \\nu$ is modeled as a two-body decay into massless particles in the $q$ rest frame with a chosen decay direction $(\\theta_{\\mathrm{dec}}, \\phi_{\\mathrm{dec}})$ for the charged lepton. Then boost the decay products back to the lab frame to obtain $p_\\ell^\\mu$ and $p_\\nu^\\mu$ such that $p_\\ell^\\mu + p_\\nu^\\mu = q^\\mu$ holds exactly. You must ensure that $q^2  0$ for the chosen parameters.\n- Use the electric charges $Q_u = +2/3$, $Q_{\\bar{d}} = +1/3$, $Q_\\ell = +1$, and $Q_W = +1$. In Variant C, the signs $\\eta_i$ are applied as $\\eta_u = -1$, $\\eta_{\\bar{d}} = -1$, $\\eta_{\\ell} = +1$. The neutrino is neutral and does not contribute.\n\nImplementation requirements:\n- Implement the Lorentz boost to and from the $q$ rest frame explicitly for the two-body decay construction.\n- Implement the on-shell projection $\\hat{q}^\\mu = \\lambda q^\\mu$ with $\\lambda = \\sqrt{M_W^2/q^2}$ and use $\\hat{q}\\cdot k$ in Variant B.\n- Compute $\\Delta$ for Variants A, B, and C for each test case below. All four-vectors are in $\\mathrm{GeV}$ units, and angles are in radians. Report the outputs as dimensionless floats.\n\nTest suite:\nUse $M_W = 80.379\\,\\mathrm{GeV}$ and the following four test cases specified by tuples $(\\sqrt{s}, E_\\gamma, \\theta_\\gamma, \\phi_\\gamma, \\theta_{\\mathrm{dec}}, \\phi_{\\mathrm{dec}})$, where all energies are in $\\mathrm{GeV}$ and all angles are in radians:\n- Case 1 (generic kinematics): $(\\sqrt{s}, E_\\gamma, \\theta_\\gamma, \\phi_\\gamma, \\theta_{\\mathrm{dec}}, \\phi_{\\mathrm{dec}}) = (500, 5, 0.7, 1.0, 1.3, 0.5)$.\n- Case 2 (soft photon): $(\\sqrt{s}, E_\\gamma, \\theta_\\gamma, \\phi_\\gamma, \\theta_{\\mathrm{dec}}, \\phi_{\\mathrm{dec}}) = (500, 10^{-3}, 1.1, 2.2, 0.9, 1.7)$.\n- Case 3 (near-collinear lepton-photon): $(\\sqrt{s}, E_\\gamma, \\theta_\\gamma, \\phi_\\gamma, \\theta_{\\mathrm{dec}}, \\phi_{\\mathrm{dec}}) = (500, 2, 0.9005, 0.2005, 0.9, 0.2)$.\n- Case 4 (hard photon, off-shell $q^2$): $(\\sqrt{s}, E_\\gamma, \\theta_\\gamma, \\phi_\\gamma, \\theta_{\\mathrm{dec}}, \\phi_{\\mathrm{dec}}) = (500, 200, 1.2, 2.0, 0.4, 2.5)$.\n\nRequired final output:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain, for each case in the order given above, the three values $\\left[\\Delta_{\\mathrm{A}}, \\Delta_{\\mathrm{B}}, \\Delta_{\\mathrm{C}}\\right]$ concatenated in that order for all cases. For example, the output format must be\n$[\\Delta_{\\mathrm{A}}^{(1)},\\Delta_{\\mathrm{B}}^{(1)},\\Delta_{\\mathrm{C}}^{(1)},\\Delta_{\\mathrm{A}}^{(2)},\\Delta_{\\mathrm{B}}^{(2)},\\Delta_{\\mathrm{C}}^{(2)},\\Delta_{\\mathrm{A}}^{(3)},\\Delta_{\\mathrm{B}}^{(3)},\\Delta_{\\mathrm{C}}^{(3)},\\Delta_{\\mathrm{A}}^{(4)},\\Delta_{\\mathrm{B}}^{(4)},\\Delta_{\\mathrm{C}}^{(4)}]$ with each $\\Delta$ reported as a floating-point number (dimensionless).", "solution": "The problem requires the numerical verification of gauge invariance for soft photon emission in the process $u \\,\\bar{d} \\to W^{+} \\to \\ell^{+} \\,\\nu_{\\ell} + \\gamma$. This is approached by evaluating the contraction of the photon momentum $k^\\mu$ with the eikonal current $J^\\mu$ for three different approximations (variants) of the set of emitting charged particles. The diagnostic for gauge invariance is defined as $\\Delta \\equiv \\left|k_\\mu J^\\mu\\right|/e$, where $e$ is the elementary charge.\n\n**Fundamental Principle: Gauge Invariance and the Soft-Photon Theorem**\n\nA fundamental principle of quantum electrodynamics is gauge invariance. For a process involving the emission of a real photon with momentum $k^\\mu$ and polarization vector $\\epsilon^\\mu$, the scattering amplitude $\\mathcal{M}$ must be invariant under the gauge transformation $\\epsilon^\\mu \\to \\epsilon^\\mu + \\alpha k^\\mu$ for any scalar $\\alpha$. This implies that if we replace the polarization vector with the photon's momentum, the resulting amplitude must vanish: $k_\\mu \\mathcal{M}^\\mu(k) = 0$. This is a manifestation of the Ward-Takahashi identity.\n\nIn the soft-photon limit ($E_\\gamma \\to 0$), the Low-Burnett-Kroll (LBK) theorem provides a universal factorization of the scattering amplitude. The leading term is given by the eikonal approximation, where the amplitude for the process with a photon is related to the amplitude without the photon, $\\mathcal{M}_0$, by:\n$$\n\\mathcal{M} \\approx e \\left( \\sum_{i \\in \\text{charged}} \\eta_i Q_i \\frac{p_i^\\mu}{p_i \\cdot k} \\right) \\epsilon_\\mu^* \\mathcal{M}_0 \\equiv J^\\mu \\epsilon_\\mu^* \\mathcal{M}_0\n$$\nHere, the sum is over all external charged particles, $Q_i$ is the charge of particle $i$ in units of $e$, $p_i^\\mu$ is its four-momentum, and $\\eta_i$ is a sign factor which is $-1$ for incoming particles and $+1$ for outgoing particles.\n\nThe gauge invariance condition $k_\\mu \\mathcal{M}^\\mu = 0$ translates to the requirement that $k_\\mu J^\\mu = 0$ for the eikonal current. Let us evaluate this contraction:\n$$\nk_\\mu J^\\mu = k_\\mu \\left( e \\sum_i \\eta_i Q_i \\frac{p_i^\\mu}{p_i \\cdot k} \\right) = e \\sum_i \\eta_i Q_i \\frac{k \\cdot p_i}{p_i \\cdot k}\n$$\nSince the Minkowski dot product is symmetric, $k \\cdot p_i = p_i \\cdot k$. As long as no charged particle is perfectly collinear with the photon (i.e., $p_i \\cdot k \\neq 0$), each term $\\frac{k \\cdot p_i}{p_i \\cdot k}$ is exactly $1$. Therefore, the contraction simplifies to a sum over the signed charges of the particles included in the current:\n$$\nk_\\mu J^\\mu = e \\sum_i \\eta_i Q_i\n$$\nThis expression is zero if and only if the total charge is conserved for the set of particles considered. The diagnostic $\\Delta$ thus becomes:\n$$\n\\Delta = \\frac{|k_\\mu J^\\mu|}{e} = \\left| \\sum_i \\eta_i Q_i \\right|\n$$\nThis result is purely algebraic and independent of the specific kinematics (momenta), as long as the calculations are performed with sufficient numerical precision. The core of the problem is to construct the full kinematics and verify that this simple analytical result is reproduced numerically.\n\n**Analysis of the Three Variants**\n\n1.  **Variant A (resonant-only naive):** The current includes only the contribution from the outgoing charged lepton $\\ell^+$. The set of emitters is $\\{\\ell^+\\}$.\n    -   $\\sum_i \\eta_i Q_i = \\eta_\\ell Q_\\ell = (+1)(+1) = 1$.\n    -   Theoretically, $\\Delta_A = |1| = 1$. This current is not gauge invariant, as it does not correspond to a charge-conserving process.\n\n2.  **Variant B (on-shell projected decay current):** The current includes contributions from the outgoing $\\ell^+$ and the incoming effective $W^+$ for the decay subprocess $W^+ \\to \\ell^+ \\nu_\\ell$. The set of emitters is $\\{W^+_{\\text{in}}, \\ell^+_{\\text{out}}\\}$.\n    -   $\\sum_i \\eta_i Q_i = \\eta_W Q_W + \\eta_\\ell Q_\\ell = (-1)(+1) + (+1)(+1) = 0$.\n    -   Theoretically, $\\Delta_B = |0| = 0$. This current is gauge invariant because charge is conserved in the subprocess. The use of the projected momentum $\\hat{q}^\\mu$ for the $W^+$ is a technique to define an on-shell momentum for the intermediate particle, but it does not alter the fundamental charge conservation property.\n\n3.  **Variant C (full external charged legs):** The current includes all external charged particles of the full process $u\\,\\bar{d} \\to \\ell^+\\nu_\\ell\\gamma$: the incoming $u$ quark, the incoming $\\bar{d}$ antiquark, and the outgoing $\\ell^+$. The set of emitters is $\\{u_{\\text{in}}, \\bar{d}_{\\text{in}}, \\ell^+_{\\text{out}}\\}$.\n    -   $Q_u = +2/3$, $Q_{\\bar{d}}=+1/3$. Note that the charge of the $\\bar{d}$ antiquark is opposite to the $d$ quark.\n    -   $\\sum_i \\eta_i Q_i = \\eta_u Q_u + \\eta_{\\bar{d}} Q_{\\bar{d}} + \\eta_\\ell Q_\\ell = (-1)(+2/3) + (-1)(+1/3) + (+1)(+1) = -1 + 1 = 0$.\n    -   Theoretically, $\\Delta_C = |0| = 0$. This current is gauge invariant because it includes all external charged particles of a charge-conserving physical process.\n\n**Numerical Implementation Strategy**\n\nThe program will perform the full kinematic construction for each test case and then compute the $\\Delta$ values numerically to verify the expected analytical results of $[1, 0, 0]$.\n\n1.  **Define Constants and Four-Vectors:** All constants ($M_W$, charges) and initial four-vectors ($p_1^\\mu$ for $u$, $p_2^\\mu$ for $\\bar{d}$, $k^\\mu$ for $\\gamma$) are constructed in the partonic center-of-mass frame using the given parameters. The intermediate boson momentum is calculated as $q^\\mu = p_1^\\mu + p_2^\\mu - k^\\mu$. We use the Minkowski metric with signature $(+,-,-,-)$ for all dot products.\n\n2.  **Two-Body Decay and Lorentz Boost:** To obtain the lepton momentum $p_\\ell^\\mu$, we first model the decay in the rest frame of the intermediate vector boson (the \"$q$-frame\"). In this frame, the boson has momentum $q'^\\mu = (\\sqrt{q^2}, 0, 0, 0)$. The decay products, $\\ell^+$ and $\\nu_\\ell$, are massless and have energy $E'_\\ell = E'_\\nu = \\sqrt{q^2}/2$. The lepton's momentum four-vector $p'^\\mu_\\ell$ is constructed using the given decay angles $(\\theta_{\\mathrm{dec}}, \\phi_{\\mathrm{dec}})$. This vector is then transformed back to the lab frame using a Lorentz boost. The boost is parameterized by the velocity of the $q$-frame with respect to the lab frame, $\\vec{\\beta} = \\vec{q}/q_0$. A numerically stable formulation of the Lorentz transformation is used to find $p_\\ell^\\mu$.\n\n3.  **Diagnostic Calculation:** For each variant (A, B, C), the sum for $\\Delta$ is computed. This involves calculating the dot products $p_i \\cdot k$ for each relevant momentum ($p_1^\\mu, p_2^\\mu, p_\\ell^\\mu, \\hat{q}^\\mu$) and then evaluating the expression $\\left|\\sum_i \\eta_i Q_i (k \\cdot p_i) / (p_i \\cdot k)\\right|$. This procedure will test whether the numerical evaluation, subject to floating-point arithmetic, reproduces the integer results predicted by charge conservation, especially in the near-collinear kinematics of Case 3 where $p_\\ell \\cdot k$ becomes very small. The results for $\\Delta_B$ and $\\Delta_C$ are expected to be numerically close to zero (e.g., on the order of machine epsilon).\n\nThis detailed numerical procedure serves as a robust check of the implementation of the soft-photon approximation and a verification of the underlying gauge principle in a computational context.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational high-energy physics problem regarding Ward identities\n    for soft photon emission.\n    \"\"\"\n\n    # --- Constants and Physical Parameters ---\n    M_W = 80.379  # GeV\n    Q_u = 2.0 / 3.0\n    Q_dbar = 1.0 / 3.0\n    Q_ell = 1.0\n    Q_W = 1.0\n    eta_u = -1.0\n    eta_dbar = -1.0\n    eta_ell = 1.0\n    eta_W = -1.0  # W+ is an incoming particle in the decay subprocess\n\n    # --- Test Cases ---\n    # Tuples of (sqrt_s, E_gamma, theta_gamma, phi_gamma, theta_dec, phi_dec)\n    test_cases = [\n        (500.0, 5.0, 0.7, 1.0, 1.3, 0.5),\n        (500.0, 1e-3, 1.1, 2.2, 0.9, 1.7),\n        (500.0, 2.0, 0.9005, 0.2005, 0.9, 0.2),\n        (500.0, 200.0, 1.2, 2.0, 0.4, 2.5),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        sqrt_s, E_gamma, theta_gamma, phi_gamma, theta_dec, phi_dec = case\n\n        # --- Helper Functions for 4-Vector Operations ---\n        def minkowski_dot(v1, v2):\n            \"\"\"Computes the dot product of two 4-vectors using (+, -, -, -) metric.\"\"\"\n            return v1[0] * v2[0] - np.dot(v1[1:], v2[1:])\n\n        def lorentz_boost(p_prime, q_lab):\n            \"\"\"\n            Boosts a 4-vector p_prime from the rest frame of a particle q\n            to the lab frame where q has 4-momentum q_lab.\n            Uses a numerically stable formula.\n            \"\"\"\n            m_q_sq = minkowski_dot(q_lab, q_lab)\n            if m_q_sq = 1e-12:  # Protect against spacelike or null q\n                raise ValueError(\"Cannot boost to rest frame of a space-like or light-like particle.\")\n            m_q = np.sqrt(m_q_sq)\n            q0 = q_lab[0]\n            q_vec = q_lab[1:]\n\n            if np.allclose(q_vec, 0):\n                return p_prime\n\n            p_prime_E = p_prime[0]\n            p_prime_vec = p_prime[1:]\n\n            # Energy in lab frame: E_lab = (q0*E' + q_vec . p'_vec) / m_q\n            p_lab_E = (q0 * p_prime_E + np.dot(q_vec, p_prime_vec)) / m_q\n            \n            # 3-momentum in lab frame: p_vec_lab = p'_vec + ( (q_vec . p'_vec) / (m_q * (q0+m_q)) + E'/m_q ) * q_vec\n            factor = (np.dot(q_vec, p_prime_vec) / (m_q * (q0 + m_q))) + (p_prime_E / m_q)\n            p_lab_vec = p_prime_vec + factor * q_vec\n            \n            p_lab = np.zeros(4)\n            p_lab[0] = p_lab_E\n            p_lab[1:] = p_lab_vec\n            return p_lab\n\n        # --- Step 1: Kinematics Construction ---\n        p1 = np.array([sqrt_s / 2.0, 0.0, 0.0, sqrt_s / 2.0])  # u quark\n        p2 = np.array([sqrt_s / 2.0, 0.0, 0.0, -sqrt_s / 2.0]) # d-bar antiquark\n\n        k = np.array([\n            E_gamma,\n            E_gamma * np.sin(theta_gamma) * np.cos(phi_gamma),\n            E_gamma * np.sin(theta_gamma) * np.sin(phi_gamma),\n            E_gamma * np.cos(theta_gamma)\n        ]) # Photon\n\n        q = p1 + p2 - k # Intermediate boson\n\n        # --- Step 2: W* Decay and Boost ---\n        q_sq = minkowski_dot(q, q)\n        if q_sq = 0:\n            raise ValueError(f\"q^2 must be positive, but got {q_sq}. Check kinematics.\")\n        m_q = np.sqrt(q_sq)\n\n        # Lepton in q-rest frame (massless decay)\n        E_prime_l = m_q / 2.0\n        p_prime_l = np.array([\n            E_prime_l,\n            E_prime_l * np.sin(theta_dec) * np.cos(phi_dec),\n            E_prime_l * np.sin(theta_dec) * np.sin(phi_dec),\n            E_prime_l * np.cos(theta_dec)\n        ])\n\n        # Boost lepton to lab frame\n        p_ell = lorentz_boost(p_prime_l, q)\n\n        # --- Step 3: Compute Gauge Invariance Diagnostics ---\n        def current_term(eta, Q, p, k_photon):\n            \"\"\"Computes one term in the eikonal current sum, eta*Q*p/(p.k).\"\"\"\n            pk_dot = minkowski_dot(p, k_photon)\n            # The problem is designed such that the analytical result of k.J simplifies.\n            # Numerically, we compute k.p/p.k which should be 1.\n            if abs(pk_dot)  1e-15:\n                # In a real collinear singularity, this term would diverge.\n                # Here, we expect k.p == p.k, so the ratio is 1. We return the charge factor.\n                return eta * Q\n            return eta * Q * minkowski_dot(k_photon, p) / pk_dot\n\n        # Variant A: Resonant-only naive (only lepton emits)\n        sum_A = current_term(eta_ell, Q_ell, p_ell, k)\n        Delta_A = abs(sum_A)\n\n        # Variant B: On-shell projected decay current (W+ -> l+)\n        # Construct projected on-shell momentum for W\n        lambda_proj = np.sqrt(M_W**2 / q_sq)\n        q_hat = lambda_proj * q\n        \n        sum_B = (current_term(eta_ell, Q_ell, p_ell, k) +\n                 current_term(eta_W, Q_W, q_hat, k))\n        Delta_B = abs(sum_B)\n\n        # Variant C: Full external charged legs (u, d-bar, l+)\n        sum_C = (current_term(eta_u, Q_u, p1, k) +\n                 current_term(eta_dbar, Q_dbar, p2, k) +\n                 current_term(eta_ell, Q_ell, p_ell, k))\n        Delta_C = abs(sum_C)\n\n        all_results.extend([Delta_A, Delta_B, Delta_C])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3534352"}]}