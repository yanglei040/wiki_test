{"hands_on_practices": [{"introduction": "A cornerstone of analyzing particle interactions is the use of Lorentz-invariant quantities that are independent of the observer's reference frame. The Mandelstam variables, denoted by $s$, $t$, and $u$, are fundamental invariants for $2 \\to 2$ scattering processes. This exercise provides essential practice in constructing relativistic four-vectors from laboratory measurements and using them to compute these crucial variables, solidifying your understanding of on-shell conditions and four-vector algebra [@problem_id:3529989].", "problem": "Consider a $2 \\to 2$ elastic scattering in the center-of-mass frame in natural units where the speed of light ($c$) is set to $1$. Two incoming particles with rest masses $m_{1}$ and $m_{2}$ and three-momenta $\\vec{p}_{1}$ and $\\vec{p}_{2}$ scatter into two outgoing particles with rest masses $m_{3}$ and $m_{4}$ and three-momenta $\\vec{p}_{3}$ and $\\vec{p}_{4}$. All four particles are on-shell. Use the Minkowski metric with signature $(+,-,-,-)$.\n\nSpecify the kinematics as follows:\n- Masses: $m_{1} = m_{3} = 0.13957\\,\\mathrm{GeV}$ and $m_{2} = m_{4} = 0.93827\\,\\mathrm{GeV}$.\n- Incoming three-momenta: $\\vec{p}_{1} = (0,\\,0,\\,2.000)\\,\\mathrm{GeV}$ and $\\vec{p}_{2} = (0,\\,0,\\,-2.000)\\,\\mathrm{GeV}$.\n- Outgoing three-momenta: choose $\\vec{p}_{3}$ to have magnitude $|\\vec{p}_{3}| = 2.000\\,\\mathrm{GeV}$ and to point at polar angle $\\theta = 60^{\\circ}$ in the $x$–$z$ plane (azimuth $\\phi = 0$), and set $\\vec{p}_{4} = -\\vec{p}_{3}$.\n\nTasks:\n1. Using only the on-shell condition for each particle and the definition of four-momentum, compute the on-shell energies $E_{i}$ for $i \\in \\{1,2,3,4\\}$ and assemble the four-vectors $p_{i}^{\\mu} = (E_{i},\\,\\vec{p}_{i})$.\n2. Using the definitions of the Mandelstam invariants in terms of four-vectors and the Minkowski metric, compute the invariants $s$, $t$, and $u$ numerically for this event.\n3. Verify the consistency with energy–momentum conservation by confirming that the total initial four-momentum equals the total final four-momentum, and by checking the identity $s + t + u = m_{1}^{2} + m_{2}^{2} + m_{3}^{2} + m_{4}^{2}$.\n4. Provide the numerical values of $s$, $t$, and $u$ in $\\mathrm{GeV}^{2}$. Round your final reported values to four significant figures. Angles are specified in degrees; do not convert to radians for this problem.\n\nYour final answer must consist only of the three values $(s,\\,t,\\,u)$, ordered as written, and expressed in $\\mathrm{GeV}^{2}$.", "solution": "This problem requires the calculation of the Mandelstam invariants $s$, $t$, and $u$ for a given $2 \\to 2$ elastic scattering process. We use natural units ($c=1$) and the Minkowski metric $g_{\\mu\\nu} = \\mathrm{diag}(1, -1, -1, -1)$.\n\n**1. Compute Energies and Four-Vectors**\n\nThe on-shell condition for a particle with mass $m$ and three-momentum $\\vec{p}$ relates its energy $E$ and momentum via $E = \\sqrt{m^2 + |\\vec{p}|^2}$. The magnitude of the three-momentum for all particles is given as $|\\vec{p}| = 2.000\\,\\mathrm{GeV}$.\n\n- For particles 1 and 3 ($m_1 = m_3 = 0.13957\\,\\mathrm{GeV}$):\n  $E_1 = E_3 = \\sqrt{(0.13957)^2 + (2.000)^2} \\approx \\sqrt{0.01948 + 4.000} \\approx 2.004864\\,\\mathrm{GeV}$.\n\n- For particles 2 and 4 ($m_2 = m_4 = 0.93827\\,\\mathrm{GeV}$):\n  $E_2 = E_4 = \\sqrt{(0.93827)^2 + (2.000)^2} \\approx \\sqrt{0.88035 + 4.000} \\approx 2.209152\\,\\mathrm{GeV}$.\n\nNext, we assemble the four-vectors $p_i^{\\mu} = (E_i, \\vec{p}_i)$.\n- $\\vec{p}_1 = (0, 0, 2.000)\\,\\mathrm{GeV}$\n- $\\vec{p}_2 = (0, 0, -2.000)\\,\\mathrm{GeV}$\n- For $\\vec{p}_3$, with $|\\vec{p}_3|=2.000\\,\\mathrm{GeV}$, $\\theta=60^{\\circ}$, $\\phi=0^{\\circ}$:\n  $p_{3x} = 2.000 \\sin(60^{\\circ}) \\cos(0^{\\circ}) = 2.000 \\cdot \\frac{\\sqrt{3}}{2} = \\sqrt{3} \\approx 1.732\\,\\mathrm{GeV}$\n  $p_{3y} = 2.000 \\sin(60^{\\circ}) \\sin(0^{\\circ}) = 0\\,\\mathrm{GeV}$\n  $p_{3z} = 2.000 \\cos(60^{\\circ}) = 2.000 \\cdot 0.5 = 1.000\\,\\mathrm{GeV}$\n  So, $\\vec{p}_3 = (\\sqrt{3}, 0, 1.000)\\,\\mathrm{GeV}$.\n- $\\vec{p}_4 = -\\vec{p}_3 = (-\\sqrt{3}, 0, -1.000)\\,\\mathrm{GeV}$.\n\nThe four-vectors in units of GeV are:\n$p_1^{\\mu} = (2.004864, 0, 0, 2.000)$\n$p_2^{\\mu} = (2.209152, 0, 0, -2.000)$\n$p_3^{\\mu} = (2.004864, \\sqrt{3}, 0, 1.000)$\n$p_4^{\\mu} = (2.209152, -\\sqrt{3}, 0, -1.000)$\n\n**2. Compute Mandelstam Invariants**\n\nThe Mandelstam invariants are defined as:\n- $s = (p_1 + p_2)^2$\n- $t = (p_1 - p_3)^2$\n- $u = (p_1 - p_4)^2$\n\n**Calculation of $s$**:\nIn the center-of-mass frame, $\\vec{p}_1 + \\vec{p}_2 = \\vec{0}$.\n$p_1^{\\mu} + p_2^{\\mu} = (E_1 + E_2, \\vec{0}) = (2.004864 + 2.209152, \\vec{0}) = (4.214016, \\vec{0})\\,\\mathrm{GeV}$.\n$s = (E_1 + E_2)^2 = (4.214016)^2 \\approx 17.757915\\,\\mathrm{GeV}^2$.\n\n**Calculation of $t$**:\nFor elastic scattering, $m_1 = m_3$ and $|\\vec{p}_1| = |\\vec{p}_3|$, so $E_1 = E_3$.\n$p_1^{\\mu} - p_3^{\\mu} = (E_1 - E_3, \\vec{p}_1 - \\vec{p}_3) = (0, \\vec{p}_1 - \\vec{p}_3)$.\n$t = (p_1 - p_3)^2 = 0^2 - |\\vec{p}_1 - \\vec{p}_3|^2 = -|\\vec{p}_1 - \\vec{p}_3|^2$.\n$\\vec{p}_1 - \\vec{p}_3 = (0, 0, 2.000) - (\\sqrt{3}, 0, 1.000) = (-\\sqrt{3}, 0, 1.000)\\,\\mathrm{GeV}$.\n$|\\vec{p}_1 - \\vec{p}_3|^2 = (-\\sqrt{3})^2 + 0^2 + 1^2 = 3 + 1 = 4.000\\,\\mathrm{GeV}^2$.\n$t = -4.000\\,\\mathrm{GeV}^2$.\n\n**Calculation of $u$**:\nWe can use the identity $s + t + u = \\sum m_i^2$.\n$\\sum m_i^2 = m_1^2 + m_2^2 + m_3^2 + m_4^2 = 2(m_1^2 + m_2^2)$.\n$\\sum m_i^2 = 2 \\cdot (0.13957^2 + 0.93827^2) \\approx 2 \\cdot (0.019480 + 0.880350) = 1.79966\\,\\mathrm{GeV}^2$.\n$u = \\sum m_i^2 - s - t \\approx 1.79966 - 17.757915 - (-4.000) = -11.958255\\,\\mathrm{GeV}^2$.\n\n**3. Final Values**\n\nRounding the results to four significant figures:\n- $s = 17.757915\\,\\mathrm{GeV}^2 \\to 17.76\\,\\mathrm{GeV}^2$\n- $t = -4.000\\,\\mathrm{GeV}^2$ (this result is exact)\n- $u = -11.958255\\,\\mathrm{GeV}^2 \\to -11.96\\,\\mathrm{GeV}^2$\n\nThe final numerical values for $(s, t, u)$ are $(17.76, -4.000, -11.96)\\,\\mathrm{GeV}^2$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n17.76 & -4.000 & -11.96\n\\end{pmatrix}\n}\n$$", "id": "3529989"}, {"introduction": "Moving from static calculations to dynamic simulations is a key step in computational physics, as event generators are indispensable tools in high-energy physics. This practice guides you through the creation of a Monte Carlo generator for a two-body particle decay, a process known as phase space sampling. You will implement the general Lorentz boost to transform particles from the center-of-mass frame to the laboratory frame and use statistical methods to verify that your implementation of the Lorentz transformations correctly handles the kinematics of an isotropic decay [@problem_id:3530037].", "problem": "Implement a complete, runnable program that performs Monte Carlo sampling of a relativistic two-body final state from a parent particle, using isotropic emission in the center-of-mass frame (also called the rest frame of the parent) and a Lorentz boost back to a specified laboratory frame. The goal is to verify, by direct computation, that the distribution of the reconstructed polar angle cosine in the center-of-mass frame is uniform and that four-momentum is conserved to high numerical accuracy. All derivations and implementation must be grounded in first principles: conservation of four-momentum, Lorentz invariance, and the geometry of rotations in three-dimensional space.\n\nYour program must satisfy the following scientific and computational requirements.\n\n- Use Natural Units where $c=1$. All energies and masses must be specified in $\\mathrm{GeV}$, all three-momenta must be specified in $\\mathrm{GeV}$, and all angles must be expressed in radians. The outputs must be dimensionless floats.\n\n- For a given parent four-momentum in the laboratory frame, compute the parent invariant mass by contracting its four-vector with the Minkowski metric and taking the positive root. Use conservation of four-momentum to determine the unique kinematics for a two-body final state in the center-of-mass frame. The isotropy requirement in the center-of-mass frame implies that the distribution of the polar angle cosine for one of the daughters, denoted by $\\cos\\theta^\\ast$, is uniform on the interval $\\left[-1,1\\right]$, and the azimuthal angle $\\phi^\\ast$ is uniform on $\\left[0,2\\pi\\right)$.\n\n- Implement the Lorentz transformation of arbitrary four-vectors under a pure boost specified by a velocity three-vector $\\boldsymbol{\\beta}$ with magnitude strictly less than $1$, where $\\gamma = 1/\\sqrt{1-\\lVert \\boldsymbol{\\beta}\\rVert^2}$. The boost must be applicable along an arbitrary direction in three-dimensional space, and correctly specialized to the zero-velocity limit.\n\n- Algorithmic workflow for each test case:\n  1. From a given parent three-momentum in the laboratory frame and the parent invariant mass, construct the parent laboratory-frame four-momentum and the corresponding boost velocity from the center-of-mass frame to the laboratory frame.\n  2. In the center-of-mass frame, sample $N$ independent pairs $\\left(\\cos\\theta^\\ast,\\phi^\\ast\\right)$ with $\\cos\\theta^\\ast$ uniform on $\\left[-1,1\\right]$ and $\\phi^\\ast$ uniform on $\\left[0,2\\pi\\right)$. The polar axis must be chosen along the laboratory boost direction (the direction of $\\boldsymbol{\\beta}$) to make the verification unambiguous and reproducible.\n  3. Using conservation of four-momentum and the mass-shell conditions, construct the two daughter four-momenta in the center-of-mass frame. Boost both daughter four-momenta to the laboratory frame using the boost determined in Step $1$.\n  4. Verify four-momentum conservation numerically in the laboratory frame by comparing the component-wise sum of daughter four-momenta to the parent laboratory four-momentum over all $N$ samples, and report the maximum absolute component deviation normalized by the parent invariant mass. This produces a dimensionless measure.\n  5. Independently, reconstruct $\\cos\\theta^\\ast$ by applying the inverse boost (from the laboratory frame back to the center-of-mass frame) to one daughter’s laboratory four-momentum, computing the cosine of the polar angle with respect to the boost direction, and aggregating the reconstructed values over the $N$ samples. Quantify the uniformity of the reconstructed $\\cos\\theta^\\ast$ sample on $\\left[-1,1\\right]$ by computing the Kolmogorov–Smirnov statistic $D$, defined as the supremum of the absolute difference between the empirical cumulative distribution function and the exact cumulative distribution function for the uniform distribution on $\\left[-1,1\\right]$.\n  6. For reproducibility, set the pseudorandom number generator seed to $123456$.\n\n- Implement the above for the following test suite of parameter values. Each test case is specified by a tuple $\\left(M,\\;m_1,\\;m_2,\\;\\mathbf{p}_{\\text{lab}},\\;N\\right)$, where $M$ is the parent invariant mass in $\\mathrm{GeV}$, $m_1$ and $m_2$ are the daughter masses in $\\mathrm{GeV}$, $\\mathbf{p}_{\\text{lab}}$ is the parent laboratory three-momentum in $\\mathrm{GeV}$, and $N$ is the number of Monte Carlo samples:\n  - Case A (general, moderate boost): $\\left(10.0,\\;3.0,\\;2.0,\\;(0.0,\\,0.0,\\,15.0),\\;50000\\right)$.\n  - Case B (massless daughters, high boost): $\\left(10.0,\\;0.0,\\;0.0,\\;(0.0,\\,0.0,\\,90.0),\\;50000\\right)$.\n  - Case C (asymmetric masses, non-collinear boost): $\\left(10.0,\\;0.5,\\;8.5,\\;(7.0,\\,4.0,\\,1.0),\\;50000\\right)$.\n  - Case D (near-threshold daughters, small boost): $\\left(5.1,\\;2.5,\\;2.5,\\;(0.1,\\,-0.2,\\,0.3),\\;50000\\right)$.\n\n- Your program must produce, for each test case, two floats:\n  - The Kolmogorov–Smirnov statistic $D$ for the reconstructed $\\cos\\theta^\\ast$ values against the uniform distribution on $\\left[-1,1\\right]$.\n  - The maximum relative four-momentum conservation error, defined as the maximum absolute deviation across all components and all samples of the vector difference between the summed daughter laboratory four-momenta and the parent laboratory four-momentum, divided by the parent invariant mass.\n\n- Final Output Format: Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Flatten the per-case two-float outputs into a single list in the order $\\left[D_A,\\;\\varepsilon_A,\\;D_B,\\;\\varepsilon_B,\\;D_C,\\;\\varepsilon_C,\\;D_D,\\;\\varepsilon_D\\right]$, where $D_X$ and $\\varepsilon_X$ correspond to the statistic and conservation error for case $X \\in \\{A,B,C,D\\}$. For example, an output with placeholder values would look like $\\left[0.00123,1.2\\mathrm{e}{-12},0.00234,1.1\\mathrm{e}{-12},\\ldots\\right]$.\n\nYour implementation must be general and must not hard-code any frame-dependent simplifications. All transformations must be done with fully three-dimensional vectors and four-vectors, and the logic must be robust in the limits of small and large boosts, as well as in the presence of massless and nearly-threshold kinematics. The final numerical outputs must be dimensionless floats.", "solution": "The user-provided problem is assessed as valid. It is scientifically grounded, well-posed, objective, and contains sufficient information for a unique solution. The task is to implement a Monte Carlo simulation of a relativistic two-body decay, grounded in the principles of special relativity, and to verify the simulation's correctness through statistical analysis and checks of conservation laws.\n\nThe solution is developed based on the following first principles of relativistic kinematics.\n\n**1. Four-Momentum and Invariant Mass**\n\nIn the framework of special relativity and using natural units where the speed of light $c=1$, the state of a particle is described by its four-momentum, $p^\\mu = (E, \\mathbf{p})$, where $E$ is the energy and $\\mathbf{p}$ is the three-momentum. The Minkowski metric is taken to be $g_{\\mu\\nu} = \\mathrm{diag}(1, -1, -1, -1)$. The invariant mass $m$ of a particle is a Lorentz-invariant quantity defined by the contraction of its four-momentum: $m^2 = p^\\mu p_\\mu = E^2 - \\lVert\\mathbf{p}\\rVert^2$.\n\n**2. Two-Body Decay Kinematics in the Center-of-Mass Frame**\n\nConsider a parent particle of mass $M$ decaying into two daughter particles with masses $m_1$ and $m_2$: $P \\to p_1 + p_2$. In the center-of-mass (CM) frame, the parent particle is at rest. Its four-momentum is $P^\\ast = (M, \\mathbf{0})$. By conservation of four-momentum, $P^\\ast = p_1^\\ast + p_2^\\ast$. This implies that the daughters' three-momenta are equal and opposite: $\\mathbf{p}_1^\\ast = -\\mathbf{p}_2^\\ast \\equiv \\mathbf{p}^\\ast$.\n\nThe energies of the daughters in the CM frame are given by the on-shell conditions:\n$$\nE_1^\\ast = \\sqrt{m_1^2 + \\lVert\\mathbf{p}^\\ast\\rVert^2} \\quad \\text{and} \\quad E_2^\\ast = \\sqrt{m_2^2 + \\lVert\\mathbf{p}^\\ast\\rVert^2}\n$$\nConservation of energy requires $M = E_1^\\ast + E_2^\\ast$. Solving for the magnitude of the daughter momentum, $\\lVert\\mathbf{p}^\\ast\\rVert$, yields a unique value:\n$$\nM - \\sqrt{m_1^2 + \\lVert\\mathbf{p}^\\ast\\rVert^2} = \\sqrt{m_2^2 + \\lVert\\mathbf{p}^\\ast\\rVert^2}\n$$\nSquaring both sides and solving for $\\lVert\\mathbf{p}^\\ast\\rVert^2$ leads to:\n$$\n\\lVert\\mathbf{p}^\\ast\\rVert = \\frac{\\sqrt{(M^2 - (m_1+m_2)^2)(M^2 - (m_1-m_2)^2)}}{2M} = \\frac{\\sqrt{\\lambda(M^2, m_1^2, m_2^2)}}{2M}\n$$\nwhere $\\lambda(x, y, z) = x^2+y^2+z^2-2xy-2yz-2zx$ is the Källén or triangle function. A decay is only kinematically possible if $M > m_1 + m_2$.\n\n**3. Isotropic Decay and Orientation**\n\nThe problem specifies an isotropic decay in the CM frame. This implies that the direction of the daughter momentum $\\mathbf{p}^\\ast$ is uniformly distributed over the solid angle. This distribution is generated by sampling the polar angle cosine, $\\cos\\theta^\\ast$, from a uniform distribution on $[-1, 1]$, and the azimuthal angle, $\\phi^\\ast$, from a uniform distribution on $[0, 2\\pi)$.\n\nThe problem defines the polar axis of this spherical coordinate system to be aligned with the direction of the boost, $\\hat{\\boldsymbol{\\beta}}$, from the CM frame to the laboratory frame. To construct the three-momentum vector $\\mathbf{p}^\\ast$, we define a right-handed orthonormal basis $(\\hat{\\mathbf{v}}, \\hat{\\mathbf{w}}, \\hat{\\mathbf{u}})$ where $\\hat{\\mathbf{u}} = \\hat{\\boldsymbol{\\beta}}$. The vector $\\mathbf{p}^\\ast$ is then:\n$$\n\\mathbf{p}^\\ast = \\lVert\\mathbf{p}^\\ast\\rVert (\\sin\\theta^\\ast \\cos\\phi^\\ast \\hat{\\mathbf{v}} + \\sin\\theta^\\ast \\sin\\phi^\\ast \\hat{\\mathbf{w}} + \\cos\\theta^\\ast \\hat{\\mathbf{u}})\n$$\nwhere $\\sin\\theta^\\ast = \\sqrt{1 - \\cos^2\\theta^\\ast}$.\n\n**4. Lorentz Transformation (Boost)**\n\nThe relationship between the CM frame and the laboratory frame is a pure Lorentz boost. The parent particle has three-momentum $\\mathbf{p}_{\\text{lab}}$ and energy $E_{\\text{lab}} = \\sqrt{M^2 + \\lVert\\mathbf{p}_{\\text{lab}}\\rVert^2}$ in the lab frame. The boost velocity vector is the velocity of the parent particle in the lab frame:\n$$\n\\boldsymbol{\\beta} = \\frac{\\mathbf{p}_{\\text{lab}}}{E_{\\text{lab}}}\n$$\nThe Lorentz factor is $\\gamma = 1/\\sqrt{1 - \\lVert\\boldsymbol{\\beta}\\rVert^2}$. A four-vector $q^\\mu=(q^0, \\mathbf{q})$ transforms to the boosted frame as $q'^\\mu=(q'^0, \\mathbf{q}')$ according to:\n$$\n\\begin{align*}\nq'^0 &= \\gamma(q^0 + \\boldsymbol{\\beta} \\cdot \\mathbf{q}) \\\\\n\\mathbf{q}' &= \\mathbf{q} + \\left(\\frac{\\gamma - 1}{\\lVert\\boldsymbol{\\beta}\\rVert^2}\\right)(\\mathbf{q} \\cdot \\boldsymbol{\\beta})\\boldsymbol{\\beta} + \\gamma q^0 \\boldsymbol{\\beta}\n\\end{align*}\n$$\nThis transformation is applied to the daughter four-momenta $p_1^\\ast$ and $p_2^\\ast$ to obtain their values in the laboratory frame, $p_{1, \\text{lab}}$ and $p_{2, \\text{lab}}$. The inverse boost, used for verification, is achieved by transforming with velocity $-\\boldsymbol{\\beta}$.\n\n**5. Algorithmic Implementation and Verification**\n\nThe algorithm proceeds as follows for each test case:\n\n1.  **Parent Kinematics**: Given $M$ and $\\mathbf{p}_{\\text{lab}}$, we compute $E_{\\text{lab}}$, the parent four-momentum $P_{\\text{lab}} = (E_{\\text{lab}}, \\mathbf{p}_{\\text{lab}})$, and the boost vector $\\boldsymbol{\\beta} = \\mathbf{p}_{\\text{lab}}/E_{\\text{lab}}$.\n2.  **CM Kinematics**: We compute the magnitude of the daughter momentum $\\lVert\\mathbf{p}^\\ast\\rVert$ and the CM energies $E_1^\\ast, E_2^\\ast$.\n3.  **Monte Carlo Sampling**: We generate $N$ pairs of $(\\cos\\theta^\\ast, \\phi^\\ast)$ from their respective uniform distributions using a pseudorandom number generator with a fixed seed for reproducibility.\n4.  **Daughter Momenta Construction**: For each of the $N$ events, we construct the daughter three-momenta $\\mathbf{p}^\\ast$ and $-\\mathbf{p}^\\ast$ in the CM frame using the specified orientation, form the four-momenta $p_1^\\ast, p_2^\\ast$, and boost them to the lab frame to get $p_{1, \\text{lab}}, p_{2, \\text{lab}}$.\n5.  **Verification**:\n    *   **Four-Momentum Conservation**: We compute the deviation $\\Delta P = (p_{1, \\text{lab}} + p_{2, \\text{lab}}) - P_{\\text{lab}}$ for each event. The conservation error $\\varepsilon$ is the maximum absolute value of any component of $\\Delta P$ over all $N$ events, normalized by the parent mass $M$:\n        $$\n        \\varepsilon = \\frac{\\max_{i \\in \\{1..N\\}, \\mu \\in \\{0,1,2,3\\}} |\\Delta P_i^\\mu|}{M}\n        $$\n    *   **Distribution Uniformity**: For each event, we take the lab four-momentum of one daughter, $p_{1, \\text{lab}}$, apply the inverse boost $(-\\boldsymbol{\\beta})$ to return to the CM frame, and reconstruct the polar angle cosine:\n        $$\n        \\cos\\theta_{\\text{reco}}^\\ast = \\frac{\\mathbf{p}_{1, \\text{reco}}^\\ast \\cdot \\hat{\\boldsymbol{\\beta}}}{\\lVert\\mathbf{p}_{1, \\text{reco}}^\\ast\\rVert}\n        $$\n        We then compute the Kolmogorov-Smirnov (KS) statistic, $D$, which measures the maximum difference between the empirical cumulative distribution function (ECDF) of the $N$ reconstructed $\\cos\\theta_{\\text{reco}}^\\ast$ values and the theoretical CDF of the uniform distribution on $[-1, 1]$, which is $F(x)=(x+1)/2$.\n        $$\n        D = \\sup_x |F_N(x) - F(x)|\n        $$\n\nThis procedure rigorously simulates the physical process and provides quantitative checks on the correctness of the implementation of the underlying relativistic principles. The calculations are performed using vectorized operations for efficiency.", "answer": "```python\nimport numpy as np\nfrom scipy.stats import kstest\n\ndef solve():\n    \"\"\"\n    Simulates relativistic two-body decays and verifies the results.\n    \"\"\"\n\n    def boost(p_4vecs, beta_vec):\n        \"\"\"\n        Performs a Lorentz boost on an array of 4-vectors.\n\n        Args:\n            p_4vecs (np.ndarray): An array of 4-vectors, shape (N, 4).\n            beta_vec (np.ndarray): The 3-vector boost velocity, shape (3,).\n\n        Returns:\n            np.ndarray: The array of boosted 4-vectors, shape (N, 4).\n        \"\"\"\n        beta_sq = np.dot(beta_vec, beta_vec)\n        if beta_sq == 0.0:\n            return p_4vecs\n        if beta_sq >= 1.0:\n            raise ValueError(\"Boost velocity must be less than c=1.\")\n        \n        gamma = 1.0 / np.sqrt(1.0 - beta_sq)\n        \n        p0 = p_4vecs[:, 0]\n        p_3vecs = p_4vecs[:, 1:]\n        \n        beta_dot_p = np.dot(p_3vecs, beta_vec)\n        \n        p0_prime = gamma * (p0 + beta_dot_p)\n        \n        # Vectorized implementation of the 3-momentum boost formula\n        factor = (gamma - 1.0) / beta_sq\n        p_3vecs_prime = p_3vecs \\\n                     + np.outer(factor * beta_dot_p, beta_vec) \\\n                     + np.outer(gamma * p0, beta_vec)\n\n        p_prime = np.zeros_like(p_4vecs)\n        p_prime[:, 0] = p0_prime\n        p_prime[:, 1:] = p_3vecs_prime\n        \n        return p_prime\n\n    def process_case(M, m1, m2, p_lab_3vec, N, rng):\n        \"\"\"\n        Processes a single test case for the two-body decay simulation.\n        \"\"\"\n        p_lab_3vec = np.array(p_lab_3vec, dtype=np.float64)\n\n        # 1. Parent kinematics in the lab frame\n        p_lab_norm = np.linalg.norm(p_lab_3vec)\n        E_lab = np.sqrt(M**2 + p_lab_norm**2)\n        P_lab = np.array([E_lab, p_lab_3vec[0], p_lab_3vec[1], p_lab_3vec[2]])\n        \n        beta_vec = p_lab_3vec / E_lab\n        beta_norm = np.linalg.norm(beta_vec)\n\n        # 2. Sample N events in the CM frame\n        cos_theta_star = rng.uniform(-1.0, 1.0, size=N)\n        phi_star = rng.uniform(0.0, 2.0 * np.pi, size=N)\n        sin_theta_star = np.sqrt(1.0 - cos_theta_star**2)\n        \n        # 3. Construct daughter momenta in the CM frame\n        if M < m1 + m2:\n            raise ValueError(\"Decay is kinematically forbidden.\")\n        \n        p_star_mag_sq = (M**2 - (m1 + m2)**2) * (M**2 - (m1 - m2)**2) / (4.0 * M**2)\n        p_star_mag = np.sqrt(p_star_mag_sq)\n        \n        E1_star = np.sqrt(m1**2 + p_star_mag**2)\n        E2_star = np.sqrt(m2**2 + p_star_mag**2)\n\n        # Construct orthonormal basis aligned with the boost direction\n        if beta_norm > 1e-12:\n            u_hat = beta_vec / beta_norm\n        else: # Handle zero boost case\n            u_hat = np.array([0., 0., 1.])\n\n        # Robustly find a vector 'a' not parallel to u_hat\n        a = np.zeros(3)\n        idx = np.argmin(np.abs(u_hat))\n        a[idx] = 1.0\n        w_hat = np.cross(u_hat, a)\n        w_hat /= np.linalg.norm(w_hat)\n        v_hat = np.cross(w_hat, u_hat)\n\n        # Construct daughter 1's 3-momentum vectors in the CM frame\n        p_star_x = p_star_mag * sin_theta_star * np.cos(phi_star)\n        p_star_y = p_star_mag * sin_theta_star * np.sin(phi_star)\n        p_star_z = p_star_mag * cos_theta_star\n        \n        p_star_vecs = np.outer(p_star_x, v_hat) + \\\n                      np.outer(p_star_y, w_hat) + \\\n                      np.outer(p_star_z, u_hat)\n        \n        # Construct daughter 4-momenta in the CM frame\n        p1_star = np.hstack((np.full((N, 1), E1_star), p_star_vecs))\n        p2_star = np.hstack((np.full((N, 1), E2_star), -p_star_vecs))\n\n        # Boost daughters to lab frame\n        p1_lab = boost(p1_star, beta_vec)\n        p2_lab = boost(p2_star, beta_vec)\n\n        # 4. Verify 4-momentum conservation\n        P_lab_broadcast = np.tile(P_lab, (N, 1))\n        delta_P = (p1_lab + p2_lab) - P_lab_broadcast\n        max_abs_dev = np.max(np.abs(delta_P))\n        conservation_error = max_abs_dev / M\n\n        # 5. Verify cos(theta*) distribution\n        p1_reco_star = boost(p1_lab, -beta_vec)\n        p1_reco_3vecs_star = p1_reco_star[:, 1:]\n        p1_reco_3vecs_mag = np.linalg.norm(p1_reco_3vecs_star, axis=1)\n        \n        # Avoid division by zero for massless particles at rest (not in this problem)\n        safe_mags = np.where(p1_reco_3vecs_mag > 1e-12, p1_reco_3vecs_mag, 1.0)\n        \n        cos_theta_reco = np.dot(p1_reco_3vecs_star, u_hat) / safe_mags\n        \n        ks_result = kstest(cos_theta_reco, 'uniform', args=(-1, 2))\n        ks_statistic = ks_result.statistic\n        \n        return ks_statistic, conservation_error\n\n    # --- Main execution starts here ---\n\n    test_cases = [\n        # (M, m1, m2, p_lab, N)\n        (10.0, 3.0, 2.0, (0.0, 0.0, 15.0), 50000),    # Case A\n        (10.0, 0.0, 0.0, (0.0, 0.0, 90.0), 50000),    # Case B\n        (10.0, 0.5, 8.5, (7.0, 4.0, 1.0), 50000),     # Case C\n        (5.1, 2.5, 2.5, (0.1, -0.2, 0.3), 50000),     # Case D\n    ]\n    \n    # Initialize RNG with fixed seed for reproducibility\n    rng = np.random.default_rng(123456)\n    \n    results = []\n    for case in test_cases:\n        M, m1, m2, p_lab, N = case\n        ks_d, error_eps = process_case(M, m1, m2, p_lab, N, rng)\n        results.extend([ks_d, error_eps])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3530037"}, {"introduction": "The elegant mathematics of relativity often encounters the harsh realities of finite-precision computer arithmetic, where direct implementation of formulas can lead to profound inaccuracies. This exercise tackles a critical numerical challenge in modern physics analysis: the catastrophic cancellation that occurs when calculating the invariant mass of a system of highly energetic, collimated jets. By implementing and comparing naive summation with a more robust technique like the Kahan algorithm, you will gain direct experience in diagnosing and mitigating numerical instabilities to produce reliable scientific results [@problem_id:3530040].", "problem": "You are asked to design and implement a computational routine for invariant mass-squared aggregation in the context of Special Relativity and High-Energy Physics (HEP). The routine must diagnose and mitigate numerical instability due to catastrophic cancellation when summing nearly lightlike and collimated four-momenta. The foundational base is the Minkowski metric with signature $(+,-,-,-)$ in natural units where the speed of light $c=1$, the definition of the energy-momentum four-vector $p^\\mu=(E,\\vec p)$, and the invariant mass-squared of a system obtained by summing four-momenta and taking the Minkowski norm. For a set of $N$ particles, the invariant mass-squared $m^2$ of the system is given by\n$$\nm^2=\\left(\\sum_{i=1}^N E_i\\right)^2-\\left\\lVert \\sum_{i=1}^N \\vec p_i \\right\\rVert^2=\\left(\\sum_{i=1}^N E_i\\right)^2-\\left(\\left(\\sum_{i=1}^N p_{x,i}\\right)^2+\\left(\\sum_{i=1}^N p_{y,i}\\right)^2+\\left(\\sum_{i=1}^N p_{z,i}\\right)^2\\right).\n$$\nIn multi-jet events with nearly collinear and nearly lightlike momenta, the quantity $m^2$ is obtained as the difference of two large, nearly equal positive numbers, which is especially sensitive to floating-point rounding error. You must implement three computational strategies for the invariant mass-squared:\n- A naive summation using standard double-precision arithmetic (IEEE 754 double, where IEEE stands for the Institute of Electrical and Electronics Engineers).\n- A compensated summation using the Kahan algorithm to reduce accumulation error in $\\sum E_i$ and each component of $\\sum \\vec p_i$.\n- A mixed-precision approach that uses high-precision decimal arithmetic for the sums and the squaring, to serve as a high-accuracy reference.\n\nYour program must:\n1. Read no input and use the test suite provided below.\n2. For each test case, construct each jet’s longitudinal momentum component $p_{z,i}$ from the provided $(E_i,p_{x,i},p_{y,i},s_i)$ via\n$$\np_{z,i}=s_i\\sqrt{E_i^2-p_{x,i}^2-p_{y,i}^2},\n$$\nwhere $s_i\\in\\{+1,-1\\}$ sets the sign of $p_{z,i}$. All energies $E_i$ are specified in $\\text{GeV}$, momenta $p_{x,i},p_{y,i},p_{z,i}$ in $\\text{GeV}$, and the invariant mass-squared $m^2$ in $\\text{GeV}^2$. Angles are not used; therefore no angle unit applies.\n3. Compute the invariant mass-squared $m^2$ using:\n   - Naive summation in double precision.\n   - Kahan compensated summation in double precision.\n   - Mixed precision, using high-precision decimal arithmetic to compute the sums and the final difference.\n4. Use the mixed-precision result as the reference $m^2_{\\text{ref}}$ and report the relative errors for the naive and compensated methods as\n$$\n\\varepsilon_{\\text{naive}}=\\frac{\\left|m^2_{\\text{naive}}-m^2_{\\text{ref}}\\right|}{\\max\\left(1,\\left|m^2_{\\text{ref}}\\right|\\right)},\\quad\n\\varepsilon_{\\text{comp}}=\\frac{\\left|m^2_{\\text{comp}}-m^2_{\\text{ref}}\\right|}{\\max\\left(1,\\left|m^2_{\\text{ref}}\\right|\\right)}.\n$$\n5. Additionally, compute a cancellation severity diagnostic\n$$\n\\rho=\\frac{\\left|m^2_{\\text{ref}}\\right|}{\\left(\\left(\\sum_i E_i\\right)^2+\\left\\lVert \\sum_i \\vec p_i\\right\\rVert^2\\right)},\n$$\nusing the same high-precision sums. Small values of $\\rho$ (for example, $\\rho\\ll 1$) indicate potential catastrophic cancellation.\n\nTest suite:\n- Case $1$ (highly collimated six jets, all $p_{z,i}>0$):\n  - Jet $1$: $(E_1,p_{x,1},p_{y,1},s_1)=(600.0,0.10,-0.08,+1)$\n  - Jet $2$: $(E_2,p_{x,2},p_{y,2},s_2)=(550.0,-0.12,0.06,+1)$\n  - Jet $3$: $(E_3,p_{x,3},p_{y,3},s_3)=(500.0,0.08,0.04,+1)$\n  - Jet $4$: $(E_4,p_{x,4},p_{y,4},s_4)=(450.0,-0.07,-0.03,+1)$\n  - Jet $5$: $(E_5,p_{x,5},p_{y,5},s_5)=(400.0,0.05,0.02,+1)$\n  - Jet $6$: $(E_6,p_{x,6},p_{y,6},s_6)=(350.0,-0.04,-0.01,+1)$\n- Case $2$ (back-to-back nearly lightlike di-jet):\n  - Jet $1$: $(E_1,p_{x,1},p_{y,1},s_1)=(500.0,100.0,0.0,+1)$\n  - Jet $2$: $(E_2,p_{x,2},p_{y,2},s_2)=(500.0,-100.0,0.0,-1)$\n- Case $3$ (four jets, mixed directions):\n  - Jet $1$: $(E_1,p_{x,1},p_{y,1},s_1)=(200.0,30.0,-20.0,+1)$\n  - Jet $2$: $(E_2,p_{x,2},p_{y,2},s_2)=(150.0,-25.0,15.0,-1)$\n  - Jet $3$: $(E_3,p_{x,3},p_{y,3},s_3)=(120.0,10.0,-8.0,+1)$\n  - Jet $4$: $(E_4,p_{x,4},p_{y,4},s_4)=(80.0,-5.0,3.0,-1)$\n- Case $4$ (ten extremely collimated jets with tiny transverse momenta, all $p_{z,i}>0$):\n  - Jet $1$: $(E_1,p_{x,1},p_{y,1},s_1)=(550.0,0.0010,-0.0012,+1)$\n  - Jet $2$: $(E_2,p_{x,2},p_{y,2},s_2)=(530.0,-0.0013,0.0009,+1)$\n  - Jet $3$: $(E_3,p_{x,3},p_{y,3},s_3)=(510.0,0.0007,-0.0008,+1)$\n  - Jet $4$: $(E_4,p_{x,4},p_{y,4},s_4)=(490.0,-0.0009,0.0011,+1)$\n  - Jet $5$: $(E_5,p_{x,5},p_{y,5},s_5)=(470.0,0.0011,-0.0007,+1)$\n  - Jet $6$: $(E_6,p_{x,6},p_{y,6},s_6)=(450.0,-0.0008,0.0006,+1)$\n  - Jet $7$: $(E_7,p_{x,7},p_{y,7},s_7)=(430.0,0.0006,-0.0004,+1)$\n  - Jet $8$: $(E_8,p_{x,8},p_{y,8},s_8)=(410.0,-0.0004,0.0005,+1)$\n  - Jet $9$: $(E_9,p_{x,9},p_{y,9},s_9)=(390.0,0.0005,-0.0003,+1)$\n  - Jet $10$: $(E_{10},p_{x,10},p_{y,10},s_{10})=(370.0,-0.0003,0.0004,+1)$\n\nOutput specification:\n- For each case, compute and report a list of six real numbers\n$$\n\\left[m^2_{\\text{naive}},~m^2_{\\text{comp}},~m^2_{\\text{mixed}},~\\varepsilon_{\\text{naive}},~\\varepsilon_{\\text{comp}},~\\rho\\right],\n$$\nwhere $m^2_{\\text{naive}}$, $m^2_{\\text{comp}}$, and $m^2_{\\text{mixed}}$ are in $\\text{GeV}^2$, and $\\varepsilon_{\\text{naive}}$, $\\varepsilon_{\\text{comp}}$, and $\\rho$ are dimensionless decimals. Your program should produce a single line of output containing the results as a comma-separated list of the four case results enclosed in square brackets. For example, the format must be\n$$\n\\left[ [\\cdots], [\\cdots], [\\cdots], [\\cdots] \\right],\n$$\nwith no additional text.", "solution": "The problem requires the implementation and comparison of three different numerical methods for calculating the invariant mass-squared of a system of particles, a fundamental quantity in relativistic kinematics. The central challenge is to address the numerical instability known as catastrophic cancellation, which arises when computing this quantity for systems of highly collimated, high-energy particles (jets).\n\nThe foundation of this problem lies in Einstein's Special Relativity, specifically in the properties of the energy-momentum four-vector, $p^\\mu = (E, \\vec{p}) = (E, p_x, p_y, p_z)$, where $E$ is the energy and $\\vec{p}$ is the three-momentum. We work in natural units where the speed of light $c=1$. The geometry of spacetime is described by the Minkowski metric, which we use in the $(+,-,-,-)$ signature, so the Minkowski dot product of two four-vectors $a^\\mu$ and $b^\\mu$ is $a \\cdot b = a^0 b^0 - \\vec{a} \\cdot \\vec{b}$.\n\nThe invariant mass-squared, $m^2$, of a single particle is the squared Minkowski norm of its four-momentum: $m^2 = p^\\mu p_\\mu = E^2 - |\\vec{p}|^2$. This quantity is a Lorentz invariant, meaning it has the same value in all inertial reference frames. For a system of $N$ particles, the total four-momentum is the sum of the individual four-momenta, $P^\\mu = \\sum_{i=1}^N p_i^\\mu$. The invariant mass-squared of the system is then the squared norm of this total four-momentum:\n$$\nM^2 = P^\\mu P_\\mu = \\left(\\sum_{i=1}^N p_i^\\mu\\right) \\cdot \\left(\\sum_{j=1}^N p_j^\\nu\\right) = \\left(\\sum_i E_i\\right)^2 - \\left|\\sum_i \\vec{p}_i\\right|^2\n$$\nThis is the formula provided in the problem. The individual particles (jets) are treated as massless, meaning for each jet $i$, its own invariant-mass squared is $m_i^2 = E_i^2 - |\\vec{p}_i|^2 = 0$. This allows the calculation of the longitudinal momentum component $p_{z,i}$ from the given energy $E_i$ and transverse momentum components $p_{x,i}, p_{y,i}$:\n$$\np_{z,i} = s_i \\sqrt{E_i^2 - (p_{x,i}^2 + p_{y,i}^2)}\n$$\nwhere $s_i \\in \\{+1, -1\\}$ determines the direction along the z-axis.\n\nThe numerical challenge, catastrophic cancellation, occurs when $P^\\mu$ is \"light-like,\" i.e., when the total energy $E_{tot} = \\sum E_i$ is very close to the magnitude of the total momentum $|\\vec{p}_{tot}| = |\\sum \\vec{p}_i|$. This happens, for example, when all particles travel in nearly the same direction at nearly the speed of light. In this scenario, $E_{tot}^2$ and $|\\vec{p}_{tot}|^2$ are two very large, nearly-equal numbers. Standard floating-point arithmetic (like IEEE 754 double precision) has finite precision (about 16 decimal digits). When two nearly equal large numbers are subtracted, the leading, most significant digits cancel out, leaving a result dominated by the accumulated rounding errors from previous calculations. This can lead to a final value for $M^2$ that is wildly inaccurate, possibly even having the wrong sign.\n\nTo diagnose and mitigate this, we will implement and compare three computational strategies.\n\n1.  **Naive Summation (Double Precision)**: This is the most straightforward approach. The components of each four-momentum are summed using standard floating-point arithmetic. The final invariant mass-squared is computed as $M_{\\text{naive}}^2 = (\\sum E_i)^2 - ((\\sum p_{x,i})^2 + (\\sum p_{y,i})^2 + (\\sum p_{z,i})^2)$. This method is expected to perform poorly in cases of severe cancellation (e.g., highly collimated jets).\n\n2.  **Compensated Summation (Kahan Algorithm)**: This method aims to improve the accuracy of the sums. The Kahan summation algorithm is a classic technique to reduce the numerical error in the summation of a sequence of floating-point numbers. For each of the four components of the total momentum ($E_{tot}, p_{x,tot}, p_{y,tot}, p_{z,tot}$), the sum is computed as follows:\n    - Initialize a sum $S=0$ and a compensation variable $c=0$.\n    - For each term $x_i$ in the sequence:\n        1.  $y = x_i - c$ (Subtract the previous error).\n        2.  $t = S + y$ (Add to the sum).\n        3.  $c = (t - S) - y$ (The new error is the part of $y$ that was lost in the addition to $S$).\n        4.  $S = t$ (Update the sum).\n    This procedure effectively tracks the \"lost\" low-order bits and adds them back into the sum at a later stage, drastically reducing the cumulative error. The invariant mass-squared, $M_{\\text{comp}}^2$, is then calculated from these more accurate sums.\n\n3.  **Mixed-Precision Reference Calculation**: To establish a \"ground truth\", we employ arbitrary-precision arithmetic, available in Python's `decimal` module. We set a very high precision (e.g., 100 decimal digits) for these calculations. The initial jet data, given as floats, are first converted to high-precision `Decimal` objects. All subsequent operations—calculating $p_z$, summing the four-momentum components, and computing the final difference of squares—are performed using this high-precision arithmetic. The result, $M_{\\text{ref}}^2$, is considered the high-accuracy reference against which the other methods are judged.\n\nThe analysis is completed by computing two metrics:\n-   **Relative Error ($\\varepsilon$)**: For the naive and compensated methods, a relative error is calculated with respect to the reference result: $\\varepsilon = |M^2 - M_{\\text{ref}}^2| / \\max(1, |M_{\\text{ref}}^2|)$. The denominator is regularized with $\\max(1, \\dots)$ to handle cases where $M_{\\text{ref}}^2$ is zero or very small.\n-   **Cancellation Diagnostic ($\\rho$)**: This metric quantifies the severity of the cancellation. It is the ratio of the magnitude of the final result to the sum of the large numbers that were subtracted: $\\rho = |M_{\\text{ref}}^2| / (E_{tot}^2 + |\\vec{p}_{tot}|^2)$, using the high-precision sums. A value of $\\rho \\ll 1$ indicates that the result is much smaller than the numbers subtracted to obtain it, signaling severe catastrophic cancellation.\n\nThe implementation will proceed by defining a function to process each test case. This function will construct the four-momenta, apply each of the three computational strategies to find $M^2$, and then compute the errors and the diagnostic $\\rho$. The results for all test cases will then be aggregated and formatted as specified.", "answer": "```python\nimport numpy as np\nfrom decimal import Decimal, getcontext\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Set the precision for the high-accuracy reference calculation.\n    # 100 digits is more than sufficient to be a \"ground truth\" for double precision.\n    getcontext().prec = 100\n\n    test_cases = [\n        # Case 1: highly collimated six jets\n        [\n            (600.0, 0.10, -0.08, +1), (550.0, -0.12, 0.06, +1),\n            (500.0, 0.08, 0.04, +1), (450.0, -0.07, -0.03, +1),\n            (400.0, 0.05, 0.02, +1), (350.0, -0.04, -0.01, +1)\n        ],\n        # Case 2: back-to-back nearly lightlike di-jet\n        [\n            (500.0, 100.0, 0.0, +1), (500.0, -100.0, 0.0, -1)\n        ],\n        # Case 3: four jets, mixed directions\n        [\n            (200.0, 30.0, -20.0, +1), (150.0, -25.0, 15.0, -1),\n            (120.0, 10.0, -8.0, +1), (80.0, -5.0, 3.0, -1)\n        ],\n        # Case 4: ten extremely collimated jets\n        [\n            (550.0, 0.0010, -0.0012, +1), (530.0, -0.0013, 0.0009, +1),\n            (510.0, 0.0007, -0.0008, +1), (490.0, -0.0009, 0.0011, +1),\n            (470.0, 0.0011, -0.0007, +1), (450.0, -0.0008, 0.0006, +1),\n            (430.0, 0.0006, -0.0004, +1), (410.0, -0.0004, 0.0005, +1),\n            (390.0, 0.0005, -0.0003, +1), (370.0, -0.0003, 0.0004, +1)\n        ]\n    ]\n\n    all_results = [process_case(case) for case in test_cases]\n\n    # Format the output as a stringified list of lists.\n    result_strings = [str(res) for res in all_results]\n    print(f\"[{','.join(result_strings)}]\")\n\ndef kahan_sum(data):\n    \"\"\"\n    Computes the sum of a sequence of floats using Kahan's compensated summation algorithm.\n    \"\"\"\n    s = 0.0\n    c = 0.0  # A running compensation for lost low-order bits.\n    for x in data:\n        y = x - c\n        t = s + y\n        c = (t - s) - y\n        s = t\n    return s\n\ndef process_case(jet_data):\n    \"\"\"\n    Processes a single test case, calculating invariant mass-squared with three methods\n    and reporting errors and a diagnostic.\n    \"\"\"\n    momenta_float = []\n    momenta_dec = []\n\n    for E, px, py, s in jet_data:\n        # Double precision (float) calculation\n        E_f, px_f, py_f = float(E), float(px), float(py)\n        # Ensure argument to sqrt is non-negative, though data is well-formed\n        pz_f_sq_arg = E_f**2 - px_f**2 - py_f**2\n        pz_f = float(s) * math.sqrt(max(0.0, pz_f_sq_arg))\n        momenta_float.append([E_f, px_f, py_f, pz_f])\n        \n        # High precision (Decimal) calculation\n        # Use strings for exact representation\n        E_d, px_d, py_d = Decimal(str(E)), Decimal(str(px)), Decimal(str(py))\n        s_d = Decimal(s)\n        pz_d_sq_arg = E_d**2 - px_d**2 - py_d**2\n        pz_d = s_d * pz_d_sq_arg.sqrt()\n        momenta_dec.append([E_d, px_d, py_d, pz_d])\n\n    momenta_float_np = np.array(momenta_float, dtype=np.float64)\n\n    # --- 1. Naive Summation ---\n    P_naive = np.sum(momenta_float_np, axis=0)\n    m2_naive = P_naive[0]**2 - (P_naive[1]**2 + P_naive[2]**2 + P_naive[3]**2)\n\n    # --- 2. Kahan Compensated Summation ---\n    E_comp = kahan_sum(momenta_float_np[:, 0])\n    px_comp = kahan_sum(momenta_float_np[:, 1])\n    py_comp = kahan_sum(momenta_float_np[:, 2])\n    pz_comp = kahan_sum(momenta_float_np[:, 3])\n    m2_comp = E_comp**2 - (px_comp**2 + py_comp**2 + pz_comp**2)\n\n    # --- 3. Mixed-Precision Reference Calculation ---\n    E_ref = sum(p[0] for p in momenta_dec)\n    px_ref = sum(p[1] for p in momenta_dec)\n    py_ref = sum(p[2] for p in momenta_dec)\n    pz_ref = sum(p[3] for p in momenta_dec)\n    p_vec_norm_sq_ref = px_ref**2 + py_ref**2 + pz_ref**2\n    m2_ref = E_ref**2 - p_vec_norm_sq_ref\n\n    # --- 4. Relative Errors ---\n    m2_ref_f = float(m2_ref)\n    denom_err = max(1.0, abs(m2_ref_f))\n    eps_naive = abs(m2_naive - m2_ref_f) / denom_err\n    eps_comp = abs(m2_comp - m2_ref_f) / denom_err\n\n    # --- 5. Cancellation Severity Diagnostic ---\n    denom_rho = E_ref**2 + p_vec_norm_sq_ref\n    rho = float(abs(m2_ref) / denom_rho if denom_rho != 0 else Decimal(0))\n    \n    return [m2_naive, m2_comp, m2_ref_f, eps_naive, eps_comp, rho]\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3530040"}]}