{"hands_on_practices": [{"introduction": "Our exploration of computational techniques begins with the Klein-Gordon equation, the prototypical relativistic wave equation for scalar fields. When we discretize spacetime to simulate this equation, we inevitably alter how waves propagate, a phenomenon captured by the numerical dispersion relation. This first practice [@problem_id:3530411] offers a foundational exercise in computational physics: you will design a numerical scheme and quantify its accuracy by comparing the numerical dispersion to the exact analytical result, thereby measuring the phase error introduced by the algorithm.", "problem": "Consider the free Klein-Gordon equation in one spatial dimension with periodic boundary conditions, in natural units where the speed of light and the reduced Planck constant are equal to one. You are to design and analyze a Fourier spectral semi-discretization in space combined with a second-order centered finite-difference method in time, and then quantify the phase error by comparing the numerical dispersion relation against the exact continuum dispersion relation. The spatial domain is periodic with length $L$, the number of equispaced grid points is $N$, and the Fourier mode index is $q$ corresponding to wave number $k = 2\\pi q/L$. The mass parameter is $m \\ge 0$. Time is discretized with step size $\\Delta t$, and the total comparison time horizon is $T$. Angles must be measured in radians.\n\nYour tasks are:\n1. Starting from the fundamental operator form of the relativistic Klein-Gordon equation, together with the plane-wave ansatz and periodic spatial domain, derive the exact continuum dispersion relation as a function of mass and wave number. Then derive the numerical dispersion relation produced by the combination of a Fourier spectral spatial discretization and a centered second-order finite-difference time discretization applied to the second-order-in-time formulation. Use these to define a rigorous phase error measure at discrete time $t_n = n\\,\\Delta t$, where $n = \\lfloor T/\\Delta t \\rfloor$.\n2. Design an algorithm that, given $(m, L, N, q, \\Delta t, T)$, computes:\n   - the exact angular frequency,\n   - the numerical angular frequency produced by the time-stepping method,\n   - the absolute wrapped phase error at time $t_n$, defined as the absolute value of the difference between the numerical and exact phases at $t_n$, wrapped to the principal interval $[-\\pi,\\pi]$ before taking the absolute value.\n3. Implement the algorithm as a complete and runnable program that produces the required outputs for the provided test suite. The outputs must be dimensionless real numbers (floats). Angles must be in radians.\n\nAssumptions and requirements:\n- Use natural units so that the exact continuum dispersion relation depends only on $m$ and $k$ without additional constants.\n- Use the Fourier spectral method in space so that the spatial derivative is represented exactly on each Fourier mode. Use a centered second-order finite-difference method for the second derivative in time.\n- Assume stability holds, and if roundoff pushes an argument outside the valid range for inverse trigonometric evaluation, clamp it to the nearest valid value.\n- Define $n = \\lfloor T/\\Delta t \\rfloor$ so that $t_n \\le T$.\n- Define the wrapped phase difference between numerical and exact phases, $\\Delta \\theta_{\\mathrm{wrapped}} \\in [-\\pi,\\pi]$, by adding or subtracting integer multiples of $2\\pi$ to minimize the absolute difference; return its absolute value.\n- All answers are dimensionless and must be expressed in radians for any angular quantity.\n\nTest suite:\nYou must compute the absolute wrapped phase error at time $t_n$ for each of the following parameter sets, each provided as the tuple $(m, L, N, q, \\Delta t, T)$ with all numbers in natural units:\n- Case A: $(m = 1.0, L = 2\\pi, N = 128, q = 3, \\Delta t = 0.1, T = 10.0)$.\n- Case B: $(m = 0.0, L = 2\\pi, N = 128, q = 32, \\Delta t = 0.05, T = 5.0)$.\n- Case C: $(m = 0.5, L = 2\\pi, N = 128, q = 1, \\Delta t = 1.78, T = 10.0)$.\n- Case D: $(m = 10.0, L = 2\\pi, N = 128, q = 1, \\Delta t = 0.05, T = 10.0)$.\n\nFinal output format:\nYour program should produce a single line of output containing the four absolute wrapped phase errors, in order for cases A through D, as a comma-separated list enclosed in square brackets, for example, $[\\text{resultA},\\text{resultB},\\text{resultC},\\text{resultD}]$. No additional output is permitted.", "solution": "The user-provided problem is a well-posed task in computational physics, requiring the analysis of a numerical method for the Klein-Gordon equation. The process involves deriving the exact and numerical dispersion relations and then calculating the phase error.\n\n### Part 1: Derivation of Dispersion Relations and Phase Error\n\n**1. The Klein-Gordon Equation and Exact Dispersion Relation**\n\nThe free Klein-Gordon equation in $1+1$ dimensions (one spatial, one temporal) is, in natural units where the reduced Planck constant $\\hbar=1$ and the speed of light $c=1$:\n$$ \\left( \\frac{\\partial^2}{\\partial t^2} - \\frac{\\partial^2}{\\partial x^2} + m^2 \\right) \\psi(x, t) = 0 $$\nHere, $\\psi(x,t)$ is the scalar field, $m \\ge 0$ is the mass parameter, $x$ is the spatial coordinate, and $t$ is the time coordinate.\nWe seek a plane-wave solution of the form $\\psi(x,t) = A e^{i(kx - \\omega t)}$, where $k$ is the wave number and $\\omega$ is the angular frequency. Substituting this ansatz into the equation, we find the derivatives:\n$$ \\frac{\\partial^2 \\psi}{\\partial t^2} = -\\omega^2 \\psi(x,t) \\quad , \\quad \\frac{\\partial^2 \\psi}{\\partial x^2} = -k^2 \\psi(x,t) $$\nThe equation becomes an algebraic condition on $\\omega$ and $k$:\n$$ (-\\omega^2 - (-k^2) + m^2) \\psi(x,t) = 0 $$\nFor a non-trivial solution where $\\psi(x,t) \\neq 0$, the expression in the parenthesis must be zero:\n$$ \\omega^2 = k^2 + m^2 $$\nBy convention, we consider positive frequencies, which leads to the exact continuum dispersion relation:\n$$ \\omega_{\\mathrm{exact}}(k) = \\sqrt{k^2 + m^2} $$\nThe problem specifies a periodic spatial domain of length $L$. This quantizes the allowed wave numbers to $k = \\frac{2\\pi q}{L}$ for an integer mode index $q$. Thus, the exact frequency for mode $q$ is:\n$$ \\omega_{\\mathrm{exact}}(q) = \\sqrt{\\left(\\frac{2\\pi q}{L}\\right)^2 + m^2} $$\n\n**2. Numerical Dispersion Relation**\n\nThe problem prescribes a semi-discretization method. The equation of motion is first written as:\n$$ \\frac{\\partial^2 \\psi}{\\partial t^2} = \\left( \\frac{\\partial^2}{\\partial x^2} - m^2 \\right) \\psi $$\nA Fourier spectral method is used for the spatial dimension. This method is exact for differentiating the Fourier modes that can be represented on the grid. For a single Fourier mode $e^{ikx}$, the operator $\\frac{\\partial^2}{\\partial x^2}$ acts as multiplication by $-k^2$. Therefore, the semi-discretized equation for a single Fourier coefficient $\\hat{\\psi}_k(t)$ becomes an ordinary differential equation (ODE):\n$$ \\frac{d^2 \\hat{\\psi}_k(t)}{dt^2} = -(k^2 + m^2) \\hat{\\psi}_k(t) = -\\omega_{\\mathrm{exact}}^2(k) \\hat{\\psi}_k(t) $$\nThe time derivative is then discretized using a second-order centered finite difference scheme. Let $t_n = n\\Delta t$ be the discrete time points, with $\\Delta t$ as the time step, and let $\\hat{\\psi}_k^n$ be the numerical approximation of $\\hat{\\psi}_k(t_n)$. The second derivative is approximated as:\n$$ \\frac{d^2 \\hat{\\psi}_k(t_n)}{dt^2} \\approx \\frac{\\hat{\\psi}_k^{n+1} - 2\\hat{\\psi}_k^n + \\hat{\\psi}_k^{n-1}}{(\\Delta t)^2} $$\nSubstituting this into the ODE yields the fully discrete recurrence relation:\n$$ \\frac{\\hat{\\psi}_k^{n+1} - 2\\hat{\\psi}_k^n + \\hat{\\psi}_k^{n-1}}{(\\Delta t)^2} = -\\omega_{\\mathrm{exact}}^2(k) \\hat{\\psi}_k^n $$\nTo find the numerical dispersion relation, we use a discrete plane-wave ansatz $\\hat{\\psi}_k^n = A e^{-i\\tilde{\\omega} n \\Delta t}$, where $\\tilde{\\omega}$ is the numerical frequency. Substituting this into the recurrence relation gives:\n$$ \\frac{e^{-i\\tilde{\\omega}\\Delta t} - 2 + e^{i\\tilde{\\omega}\\Delta t}}{(\\Delta t)^2} = -\\omega_{\\mathrm{exact}}^2(k) $$\nUsing Euler's identity $e^{i\\theta} + e^{-i\\theta} = 2\\cos(\\theta)$, the numerator becomes $2\\cos(\\tilde{\\omega}\\Delta t) - 2$. The equation simplifies to:\n$$ \\frac{2\\cos(\\tilde{\\omega}\\Delta t) - 2}{(\\Delta t)^2} = -\\omega_{\\mathrm{exact}}^2(k) $$\nUsing the half-angle identity $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$, we get:\n$$ \\frac{-4\\sin^2(\\frac{\\tilde{\\omega}\\Delta t}{2})}{(\\Delta t)^2} = -\\omega_{\\mathrm{exact}}^2(k) $$\n$$ \\sin^2\\left(\\frac{\\tilde{\\omega}\\Delta t}{2}\\right) = \\frac{\\omega_{\\mathrm{exact}}^2(k) (\\Delta t)^2}{4} $$\nTaking the square root and solving for $\\tilde{\\omega}$ yields the numerical dispersion relation:\n$$ \\tilde{\\omega}(k) = \\frac{2}{\\Delta t} \\arcsin\\left(\\frac{\\omega_{\\mathrm{exact}}(k) \\Delta t}{2}\\right) $$\nThis relation is valid as long as the scheme is stable, which requires the argument of $\\arcsin$ to be within $[-1, 1]$, leading to the CFL condition $|\\omega_{\\mathrm{exact}}(k) \\Delta t| \\le 2$.\n\n**3. Phase Error Definition**\n\nThe phase of the exact solution at time $t_n = n \\Delta t$ is $\\theta_{\\mathrm{exact}}(t_n) = \\omega_{\\mathrm{exact}} t_n$.\nThe phase of the numerical solution at time $t_n$ is $\\theta_{\\mathrm{num}}(t_n) = \\tilde{\\omega} t_n$.\nThe time step index is $n = \\lfloor T/\\Delta t \\rfloor$.\nThe raw phase error at time $t_n$ is the difference:\n$$ \\Delta\\theta(t_n) = \\theta_{\\mathrm{num}}(t_n) - \\theta_{\\mathrm{exact}}(t_n) = (\\tilde{\\omega} - \\omega_{\\mathrm{exact}}) t_n $$\nThe problem requires this phase difference to be wrapped to the principal interval $[-\\pi, \\pi]$. This can be achieved using the modulo operation:\n$$ \\Delta\\theta_{\\mathrm{wrapped}} = (\\Delta\\theta + \\pi) \\pmod{2\\pi} - \\pi $$\nThe final quantity to be computed is the absolute value of this wrapped phase difference, $|\\Delta\\theta_{\\mathrm{wrapped}}|$.\n\n### Part 2: Algorithm Design\n\nThe algorithm computes the absolute wrapped phase error for a given set of parameters $(m, L, N, q, \\Delta t, T)$. The parameter $N$ confirms that the mode $q$ is well-resolved by the grid (i.e., $|q|  N/2$), but does not enter the single-mode dispersion calculation directly.\n\n1.  **Calculate Constants:** Compute the wave number $k = \\frac{2\\pi q}{L}$ and the final time step index $n = \\lfloor T/\\Delta t \\rfloor$. The total time for phase accumulation is $t_n = n \\cdot \\Delta t$.\n2.  **Compute Exact Frequency:** Calculate $\\omega_{\\mathrm{exact}} = \\sqrt{k^2 + m^2}$.\n3.  **Compute Numerical Frequency:** Calculate $\\tilde{\\omega} = \\frac{2}{\\Delta t} \\arcsin\\left(\\frac{\\omega_{\\mathrm{exact}} \\Delta t}{2}\\right)$. To ensure numerical stability, especially with floating-point arithmetic, the argument of the $\\arcsin$ function is clamped to the range $[-1.0, 1.0]$.\n4.  **Compute Phase Error:** Calculate the raw phase difference $\\Delta\\theta = (\\tilde{\\omega} - \\omega_{\\mathrm{exact}}) t_n$.\n5.  **Wrap and Finalize:** Wrap $\\Delta\\theta$ to $[-\\pi, \\pi]$ and take its absolute value.\n\nThis logic is implemented for each test case provided in the problem statement.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Klein-Gordon phase error problem for the given test suite.\n    \"\"\"\n\n    def calculate_phase_error(m, L, N, q, dt, T):\n        \"\"\"\n        Calculates the absolute wrapped phase error for a given parameter set.\n        \n        Args:\n            m (float): Mass parameter.\n            L (float): Length of the periodic spatial domain.\n            N (int): Number of equispaced grid points.\n            q (int): Fourier mode index.\n            dt (float): Time step size.\n            T (float): Total comparison time horizon.\n            \n        Returns:\n            float: The absolute wrapped phase error in radians.\n        \"\"\"\n        # The number of grid points N is provided to ensure the mode q is\n        # resolved by the grid (non-aliased), satisfying |q|  N/2.\n        # It is not used in the dispersion relation of a single mode.\n        \n        # 1. Calculate wave number and final time\n        k = (2.0 * np.pi * q) / L\n        # Per problem spec, n = floor(T/dt)\n        n = np.floor(T / dt)\n        t_n = n * dt\n\n        # 2. Calculate the exact continuum angular frequency\n        omega_exact = np.sqrt(k**2 + m**2)\n\n        # 3. Calculate the numerical angular frequency\n        # The argument for arcsin is derived from the numerical scheme\n        arg_asin = (omega_exact * dt) / 2.0\n        \n        # Clamp the argument to [-1, 1] to prevent domain errors from\n        # floating-point inaccuracies, as required by the problem statement.\n        # This handles cases at the edge of the stability limit.\n        arg_asin_clamped = np.clip(arg_asin, -1.0, 1.0)\n        \n        omega_num = (2.0 / dt) * np.arcsin(arg_asin_clamped)\n\n        # 4. Calculate the total phase difference at time t_n\n        phase_difference = (omega_num - omega_exact) * t_n\n\n        # 5. Wrap the phase difference to the principal interval [-pi, pi]\n        # The formula (x + pi) % (2*pi) - pi maps x to the interval [-pi, pi].\n        wrapped_phase_difference = (phase_difference + np.pi) % (2.0 * np.pi) - np.pi\n        \n        # The final result is the absolute value of the wrapped phase difference.\n        abs_wrapped_phase_error = np.abs(wrapped_phase_difference)\n        \n        return abs_wrapped_phase_error\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (m, L, N, q, \\Delta t, T)\n    test_cases = [\n        (1.0, 2.0 * np.pi, 128, 3, 0.1, 10.0),    # Case A\n        (0.0, 2.0 * np.pi, 128, 32, 0.05, 5.0),   # Case B\n        (0.5, 2.0 * np.pi, 128, 1, 1.78, 10.0),   # Case C\n        (10.0, 2.0 * np.pi, 128, 1, 0.05, 10.0),  # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters and calculate the result for one case\n        m, L, N, q, dt, T = case\n        result = calculate_phase_error(m, L, N, q, dt, T)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3530411"}, {"introduction": "Moving from scalar fields to the spin-$\\frac{1}{2}$ fermions described by the Dirac equation, we encounter unique quantum phenomena with no classical analogue. One of the most famous is *Zitterbewegung*, a rapid trembling motion predicted for a localized electron. This hands-on exercise [@problem_id:3530387] provides a direct computational window into this effect, demonstrating that it arises from the interference between positive- and negative-energy components of the particle's wave packet. By numerically evolving a wave packet and using energy projectors, you will see this phenomenon emerge from the simulation and verify that it vanishes for states of pure energy.", "problem": "Consider the free Dirac equation in $1+1$ dimensions for a two-component spinor $\\psi(x,t)$,\n$$\ni\\,\\partial_t \\psi(x,t) \\;=\\; H \\,\\psi(x,t), \\quad H \\;=\\; \\alpha\\,\\hat{p} \\;+\\; \\beta\\,m,\n$$\nwhere $\\hat{p} = -i\\,\\partial_x$, the matrices $\\alpha$ and $\\beta$ obey $\\,\\{\\alpha,\\beta\\}=0\\,$, $\\,\\alpha^2=\\beta^2=I\\,$, and $m$ is the rest mass. Take the standard representation $\\,\\alpha=\\sigma_x\\,$ and $\\,\\beta=\\sigma_z\\,$, where $\\sigma_x$ and $\\sigma_z$ are Pauli matrices. In momentum space, with wave number $k$ (so that $\\hat{p}\\to k$), the Hamiltonian becomes\n$$\nH(k) \\;=\\; \\sigma_x\\,k \\;+\\; \\sigma_z\\,m,\n$$\nwith energy eigenvalues $E_\\pm(k)=\\pm\\sqrt{k^2+m^2}$. For each fixed $k$, one may write the time evolution operator using the identity $H(k)^2 = E(k)^2 I$:\n$$\nU(k,t) \\;=\\; e^{-i\\,H(k)\\,t} \\;=\\; \\cos\\!\\big(E(k)\\,t\\big)\\,I \\;-\\; i\\,\\frac{\\sin\\!\\big(E(k)\\,t\\big)}{E(k)}\\,H(k),\n$$\nwhere $E(k)=\\sqrt{k^2+m^2}$. The energy projectors $P_\\pm(k)$ onto positive/negative energy subspaces are\n$$\nP_\\pm(k) \\;=\\; \\frac{1}{2}\\left(I \\;\\pm\\; \\frac{H(k)}{E(k)}\\right),\n$$\nwith the understanding that at points where $E(k)=0$ one sets $P_\\pm(k)=\\tfrac{1}{2}I$.\n\nA localized packet in momentum space is defined as\n$$\n\\psi(k,0) \\;=\\; \\phi(k)\\,s_0,\\qquad \n\\phi(k) \\;=\\; \\exp\\!\\left(-\\frac{(k-k_0)^2}{2\\,\\sigma_k^2}\\right),\n$$\nwith constant spinor $s_0$ chosen such that $\\psi(k,0)$ is not an energy eigenstate at each $k$ (to ensure a nontrivial mixture of $E_\\pm$ components). The packet evolved in time is $\\psi(k,t)=U(k,t)\\,\\psi(k,0)$ for a given mass $m$.\n\nDefine the position expectation in momentum representation by the standard rule that the position operator is $i\\,\\partial_k$:\n$$\n\\langle x \\rangle(t) \\;=\\; \\frac{\\int dk\\; \\psi^\\dagger(k,t)\\,i\\,\\partial_k \\psi(k,t)}{\\int dk\\; \\psi^\\dagger(k,t)\\,\\psi(k,t)}.\n$$\nIn natural units with reduced Planck constant $\\hbar$ and speed of light $c$ set to one ($\\hbar=c=1$), the group velocity for a positive-energy quasimonochromatic packet centered at $k_0$ is\n$$\nv \\;=\\; \\frac{\\partial E}{\\partial k}\\bigg|_{k_0} \\;=\\; \\frac{k_0}{\\sqrt{k_0^2+m^2}}.\n$$\nThe Zitterbewegung signal $z(t)$ is defined by subtracting the drift of the packet’s center,\n$$\nz(t) \\;=\\; \\langle x \\rangle(t) \\;-\\; \\big(\\langle x \\rangle(0) + v\\,t\\big),\n$$\nand its amplitude is taken to be the half peak-to-peak value over a specified time window,\n$$\nA \\;=\\; \\frac{1}{2}\\Big(\\max_t z(t) \\;-\\; \\min_t z(t)\\Big).\n$$\n\nYour task is to write a complete, runnable program that:\n- Constructs the initial packet $\\psi(k,0)$ with parameters $k_0$ and $\\sigma_k$ and spinor $s_0$ fixed as described below.\n- Evolves the packet using $U(k,t)$ for a set of times $t$.\n- Computes $\\langle x \\rangle(t)$ via the momentum-space definition and then $z(t)$ and amplitude $A$.\n- Implements energy component isolation by applying $P_\\pm(k)$ to $\\psi(k,0)$ to create purely positive-energy or purely negative-energy initial states before time evolution, and compares the presence or absence of Zitterbewegung.\n- Tests the dependence of the amplitude $A$ on the mass $m$.\n\nUse the following concrete and scientifically sound parameter choices for reproducibility:\n- Work in natural units ($\\hbar=c=1$), so all quantities are dimensionless. When reporting amplitudes, treat them as lengths in natural units.\n- The momentum grid is uniform: $k \\in [-K_{\\max}, K_{\\max}]$ with $K_{\\max} = 10$ sampled at $N=1024$ points.\n- The initial packet parameters are $k_0=1$ and $\\sigma_k=0.5$. Use $s_0=\\begin{pmatrix}1\\\\0\\end{pmatrix}$ so that the packet is not an energy eigenstate at each $k$.\n- The time window is $t \\in [0,T]$ with $T=20$ sampled at $N_t=400$ uniformly spaced points. All trigonometric function arguments must be treated in radians.\n\nEnergy isolation and test suite:\n- For a given $m$, define three modes for the initial state $\\psi(k,0)$ before time evolution: \n  - \"mix\": the raw $\\psi(k,0)$ as given,\n  - \"pos\": $\\psi(k,0)$ replaced by $P_+(k)\\,\\psi(k,0)$,\n  - \"neg\": $\\psi(k,0)$ replaced by $P_-(k)\\,\\psi(k,0)$.\n- Use the amplitude definition $A$ for each case.\n\nProvide the following test suite of parameter values, covering a general case, boundary cases, and isolation effects:\n- Test $1$: mass $m=0$, mode \"mix\".\n- Test $2$: mass $m=0$, mode \"pos\".\n- Test $3$: mass $m=0.5$, mode \"mix\".\n- Test $4$: mass $m=2.0$, mode \"mix\".\n- Test $5$: mass $m=1.0$, mode \"pos\"; additionally, report a boolean indicating whether Zitterbewegung is numerically quenched in this positive-energy case, defined as $A  \\epsilon$ with threshold $\\epsilon=0.02$.\n\nFinal output specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the following fixed order and types:\n  - $A$ for Test $1$ (float rounded to $6$ decimal places),\n  - $A$ for Test $2$ (float rounded to $6$ decimal places),\n  - $A$ for Test $3$ (float rounded to $6$ decimal places),\n  - $A$ for Test $4$ (float rounded to $6$ decimal places),\n  - $A$ for Test $5$ (float rounded to $6$ decimal places),\n  - the boolean for Test $5$ quench condition (either True or False).\nFor example, the output format is exactly like $[a_1,a_2,a_3,a_4,a_5,b]$, where each $a_i$ is a float with $6$ decimals and $b$ is a boolean literal. Express all amplitudes in natural-unit length (with $\\hbar=c=1$).", "solution": "The problem requires the numerical simulation of a one-dimensional relativistic wave packet governed by the Dirac equation to quantify the phenomenon of Zitterbewegung. The solution involves discretizing the problem in momentum space, evolving the initial state in time, and calculating the expectation value of the position operator.\n\nThe fundamental equation is the time-dependent Dirac equation in $1+1$ dimensions, $i\\,\\partial_t \\psi = H \\psi$. In momentum space, the Hamiltonian for a particle of mass $m$ is a $2 \\times 2$ matrix, $H(k) = k\\,\\sigma_x + m\\,\\sigma_z$, where $k$ is the wave number and $\\sigma_x$, $\\sigma_z$ are Pauli matrices.\n\nThe algorithmic procedure is as follows:\n\n1.  **Discretization and Parameter Setup**: We establish a numerical grid for the momentum (wave number) $k$ from $-K_{\\max}$ to $K_{\\max}$ with $N$ points, and a grid for time $t$ from $0$ to $T$ with $N_t$ points. The parameters $K_{\\max}=10$, $N=1024$, $T=20$, and $N_t=400$ are used as specified. All physical quantities are treated as dimensionless, consistent with natural units ($\\hbar=c=1$).\n\n2.  **Hamiltonian and Energy Spectrum**: For each discrete value of $k$ on the grid, we construct the Hamiltonian matrix $H(k)$. The energy eigenvalues are given by $E(k) = \\sqrt{k^2+m^2}$. The time evolution operator $U(k,t)$ and the energy projection operators $P_\\pm(k)$ depend on $H(k)$ and $E(k)$. A crucial implementation detail is the handling of the case $E(k)=0$, which occurs if $m=0$ and $k=0$. At this point, expressions involving $1/E(k)$ are evaluated using their limiting behavior. Specifically, the term $\\sin(E(k)t)/E(k)$ in $U(k,t)$ becomes $t$, and the projectors $P_\\pm(k)$ are defined as $\\frac{1}{2}I$. This is handled numerically by using a safe inverse for $E(k)$ that is zero where $E(k)$ is zero.\n\n3.  **Initial State Construction**: The initial wave packet is a Gaussian in momentum space, $\\psi(k,0) = \\phi(k)s_0$, where $\\phi(k) = \\exp(-\\frac{(k-k_0)^2}{2\\sigma_k^2})$ and $s_0 = \\begin{pmatrix}1\\\\0\\end{pmatrix}$. This state is a superposition of positive and negative energy components, which is the necessary condition for Zitterbewegung.\n    -   For the `\"mix\"` mode, this $\\psi(k,0)$ is used directly.\n    -   For the `\"pos\"` and `\"neg\"` modes, the initial state is projected onto the corresponding energy subspace by applying the operators $P_+(k)$ or $P_-(k)$: $\\psi_{\\text{pos}}(k,0) = P_+(k)\\psi(k,0)$ and $\\psi_{\\text{neg}}(k,0) = P_-(k)\\psi(k,0)$. This projection is expected to quench the Zitterbewegung.\n\n4.  **Time Evolution**: The state at a later time $t$ is $\\psi(k,t) = U(k,t)\\psi(k,0)$. Using the given identity, $U(k,t) = \\cos(E(k)t)I - i \\frac{\\sin(E(k)t)}{E(k)}H(k)$, we can compute $\\psi(k,t)$ for all points on the $k$-$t$ grid in a vectorized manner for efficiency.\n\n5.  **Position Expectation Value**: The core observable is the expectation value of the position operator, $\\langle x \\rangle(t)$. In the momentum representation, the position operator is $\\hat{x} = i\\,\\partial_k$. Thus, its expectation value is:\n    $$\n    \\langle x \\rangle(t) = \\frac{\\int \\psi^\\dagger(k,t) (i\\,\\partial_k) \\psi(k,t) \\,dk}{\\int \\psi^\\dagger(k,t) \\psi(k,t) \\,dk}\n    $$\n    The denominator is the total probability, which is conserved over time and can be calculated from the initial state $\\psi(k,0)$. The numerator is computed numerically. First, for each time $t$, the derivative $\\partial_k \\psi(k,t)$ is computed across the momentum grid using a finite-difference method (`numpy.gradient`). Then, the inner product $\\psi^\\dagger(k,t) (i\\,\\partial_k \\psi(k,t))$ is calculated for each $k$. Finally, this quantity is integrated over $k$ using a simple summation scaled by the grid spacing $dk$. The entire calculation is vectorized over both the $k$ and $t$ grids.\n\n6.  **Zitterbewegung Signal and Amplitude**: Zitterbewegung is the rapid oscillatory motion of the particle's position around its classical trajectory. The signal $z(t)$ is isolated by subtracting the mean drift from $\\langle x \\rangle(t)$:\n    $$\n    z(t) = \\langle x \\rangle(t) - (\\langle x \\rangle(0) + v t)\n    $$\n    Here, $\\langle x \\rangle(0)$ is the initial position expectation, and $v$ is the group velocity of the packet, $v = \\frac{\\partial E}{\\partial k}|_{k=k_0} = k_0/\\sqrt{k_0^2+m^2}$. The amplitude $A$ of this oscillatory signal is then calculated as half the peak-to-peak value, $A = \\frac{1}{2}(\\max_t z(t) - \\min_t z(t))$, over the specified time window.\n\n7.  **Test Suite Execution**: The program systematically executes the described procedure for each test case, varying the mass $m$ and the initial state preparation mode. For the final test case, it additionally checks if the computed amplitude $A$ is below a threshold $\\epsilon=0.02$ to determine if Zitterbewegung is numerically quenched. The results are collected and formatted as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_zitterbewegung(m, mode, k_grid, t_grid, k0, sigma_k):\n    \"\"\"\n    Computes the Zitterbewegung amplitude for a 1D Dirac wave packet.\n\n    Args:\n        m (float): Mass of the particle.\n        mode (str): Initial state mode (\"mix\", \"pos\", \"neg\").\n        k_grid (np.ndarray): Array of momentum points.\n        t_grid (np.ndarray): Array of time points.\n        k0 (float): Center of the initial momentum distribution.\n        sigma_k (float): Width of the initial momentum distribution.\n\n    Returns:\n        float or tuple: The amplitude A. For Test 5, returns (A, is_quenched).\n    \"\"\"\n    N = len(k_grid)\n    dk = k_grid[1] - k_grid[0]\n\n    # Define matrices\n    sigma_x = np.array([[0, 1], [1, 0]], dtype=complex)\n    sigma_z = np.array([[1, 0], [0, -1]], dtype=complex)\n    I = np.eye(2, dtype=complex)\n\n    # Construct Hamiltonian H(k) for all k points\n    # H_k_array has shape (N, 2, 2)\n    H_k_array = sigma_x[None, :, :] * k_grid[:, None, None] + sigma_z[None, :, :] * m\n\n    # Energy eigenvalues E(k) = sqrt(k^2 + m^2)\n    E_k = np.sqrt(k_grid**2 + m**2)\n\n    # Create a safe inverse for E(k) to handle E(k)=0 case (m=0, k=0)\n    inv_E_k = np.zeros_like(E_k)\n    nonzero_mask = E_k != 0\n    inv_E_k[nonzero_mask] = 1.0 / E_k[nonzero_mask]\n\n    # Construct initial state psi(k, 0)\n    phi_k = np.exp(-(k_grid - k0)**2 / (2 * sigma_k**2))\n    s0 = np.array([1.0, 0.0], dtype=complex)\n    psi_k_0_raw = phi_k[:, None] * s0[None, :]  # Shape (N, 2)\n\n    if mode == \"mix\":\n        psi_k_0 = psi_k_0_raw\n    else:\n        # Construct energy projectors P_pm(k)\n        term_H_over_E = H_k_array * inv_E_k[:, None, None]\n        if mode == \"pos\":\n            P_k = 0.5 * (I[None, :, :] + term_H_over_E)\n        elif mode == \"neg\":\n            P_k = 0.5 * (I[None, :, :] - term_H_over_E)\n        \n        # Project initial state: psi_k_0 = P_k @ psi_k_0_raw\n        psi_k_0 = np.einsum('kij,kj-ki', P_k, psi_k_0_raw)\n\n    # Denominator for x(t): Norm = integral |psi(k,0)|^2 dk\n    norm_integrand = np.sum(np.conj(psi_k_0) * psi_k_0, axis=1).real\n    norm = np.sum(norm_integrand) * dk\n    if norm  1e-12: # Avoid division by zero if packet is null\n        return (0.0, True) if m == 1.0 and mode == \"pos\" else 0.0\n\n    # Vectorize time evolution\n    E_k_t = np.outer(E_k, t_grid) # Shape (N, N_t)\n    cos_Ekt = np.cos(E_k_t)\n    sin_Ekt = np.sin(E_k_t)\n\n    # U(k,t) @ psi(k,0) = (cos(Et)I - i*sin(Et)/E*H) @ psi(k,0)\n    H_psi_0 = np.einsum('kij,kj-ki', H_k_array, psi_k_0)\n    psi_k_t = (cos_Ekt[..., None] * psi_k_0[:, None, :] -\n               1j * sin_Ekt[..., None] * inv_E_k[:, None, None] * H_psi_0[:, None, :])\n    # psi_k_t has shape (N, N_t, 2)\n\n    # Numerator for x(t): integral psi^dagger * (i * d/dk) * psi dk\n    d_psi_k_t_dk = np.gradient(psi_k_t, k_grid, axis=0, edge_order=2)\n    numerator_integrand = np.sum(np.conj(psi_k_t) * (1j * d_psi_k_t_dk), axis=2)\n    num_t = np.sum(numerator_integrand, axis=0) * dk\n    \n    x_t = (num_t / norm).real\n\n    # Calculate Zitterbewegung signal z(t) and amplitude A\n    x0 = x_t[0]\n    E_k0 = np.sqrt(k0**2 + m**2)\n    v_group = k0 / E_k0 if E_k0  1e-9 else 0.0\n    \n    drift_t = x0 + v_group * t_grid\n    z_t = x_t - drift_t\n    \n    A = 0.5 * (np.max(z_t) - np.min(z_t))\n\n    if m == 1.0 and mode == \"pos\": # Special logic for Test 5\n        is_quenched = A  0.02\n        return A, is_quenched\n    \n    return A\n\ndef solve():\n    # Define simulation parameters from the problem statement\n    K_max = 10.0\n    N = 1024\n    T = 20.0\n    N_t = 400\n    k0 = 1.0\n    sigma_k = 0.5\n    \n    k_grid = np.linspace(-K_max, K_max, N)\n    t_grid = np.linspace(0, T, N_t)\n\n    # Define the test suite\n    test_cases = [\n        {\"m\": 0.0, \"mode\": \"mix\"},    # Test 1\n        {\"m\": 0.0, \"mode\": \"pos\"},    # Test 2\n        {\"m\": 0.5, \"mode\": \"mix\"},    # Test 3\n        {\"m\": 2.0, \"mode\": \"mix\"},    # Test 4\n        {\"m\": 1.0, \"mode\": \"pos\"},    # Test 5\n    ]\n    \n    results = []\n    \n    for i, case in enumerate(test_cases):\n        res = compute_zitterbewegung(\n            m=case[\"m\"],\n            mode=case[\"mode\"],\n            k_grid=k_grid,\n            t_grid=t_grid,\n            k0=k0,\n            sigma_k=sigma_k\n        )\n        if i == 4: # Test 5 returns a tuple\n            amp, is_quenched = res\n            results.append(amp)\n            results.append(is_quenched)\n        else:\n            results.append(res)\n            \n    # Format and print the final output\n    formatted_results = []\n    for item in results:\n        if isinstance(item, float):\n            formatted_results.append(f\"{item:.6f}\")\n        else:\n            formatted_results.append(str(item))\n            \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3530387"}, {"introduction": "A central challenge in computational high-energy physics is the formulation of fermionic fields on a spacetime lattice, which is essential for non-perturbative studies like lattice QCD. Naive discretizations lead to a proliferation of unphysical particle species, a problem known as \"fermion doubling\". This advanced practice [@problem_id:3530403] tackles this issue head-on by introducing the Wilson term, a crucial modification that removes the doublers by giving them a large mass. You will implement the Wilson-Dirac operator and numerically verify both the solution to the doubling problem and its important consequence: an explicit but controlled breaking of chiral symmetry, illustrating a fundamental trade-off at the heart of modern lattice field theory.", "problem": "Construct a complete, runnable program that demonstrates how adding a Wilson term to the free lattice Dirac operator in two Euclidean dimensions lifts fermion doublers while explicitly breaking chiral symmetry, together with a quantitative analysis of the continuum limit trade-off.\n\nBegin from the following foundational base applicable to computational high-energy physics:\n- Discretize spatial derivatives on a hypercubic lattice using central finite differences. In momentum space, the operator corresponding to the partial derivative $\\partial_\\mu$ has the symbol $i\\sin(q_{\\mu})/a$, where $a$ is the lattice spacing and $q_{\\mu} \\equiv p_{\\mu} a$ is the dimensionless lattice momentum (angle) in radians within the first Brillouin Zone (BZ).\n- The free, massless, naive Dirac operator in momentum space in $d=2$ Euclidean dimensions is constructed from these symbols and two-dimensional gamma matrices obeying the Euclidean Clifford algebra. Use the $2 \\times 2$ Pauli matrices as a valid representation: define $\\gamma_1 = \\sigma_1$, $\\gamma_2 = \\sigma_2$, and the chirality matrix $\\gamma_5 = \\sigma_3$, which anticommutes with $\\gamma_1$ and $\\gamma_2$.\n- The Wilson term is obtained by adding a lattice Laplacian to the naive operator to lift the doubler modes. In momentum space the lattice Laplacian symbol along direction $\\mu$ is $2(1 - \\cos(q_{\\mu}))/a^2$. The Wilson term added to the Dirac operator is proportional to this Laplacian and has the form $R(\\mathbf{q}) \\,\\mathbf{1}$ with $R(\\mathbf{q}) = - r \\sum_{\\mu} (1 - \\cos(q_{\\mu}))/a$, where $r$ is the dimensionless Wilson parameter and $\\mathbf{1}$ is the identity in spinor space. This shifts doubler modes to masses of order $1/a$ while modifying the low-energy behavior by terms of order $a$.\n\nYour program must implement the following, all in $d=2$ Euclidean dimensions with momenta sampled on a uniform grid in the Brillouin Zone:\n1. Define the free naive Dirac operator $D_{\\text{naive}}(\\mathbf{q}) = i \\sum_{\\mu=1}^{2} \\gamma_{\\mu} \\sin(q_{\\mu})/a + m_0 \\,\\mathbf{1}$, where $m_0$ is the bare mass.\n2. Define the Wilson-Dirac operator $D_{\\text{Wilson}}(\\mathbf{q}) = D_{\\text{naive}}(\\mathbf{q}) + R(\\mathbf{q}) \\,\\mathbf{1}$ with $R(\\mathbf{q}) = - r \\sum_{\\mu=1}^{2} \\left(1 - \\cos(q_{\\mu})\\right)/a$.\n3. Demonstrate doubler lifting by counting the number of near-zero singular values of $D_{\\text{naive}}(\\mathbf{q})$ and $D_{\\text{Wilson}}(\\mathbf{q})$ across the Brillouin Zone for the massless case $m_0=0$. Here “near-zero” means the smallest singular value $s_{\\min}(\\mathbf{q})$ is below a threshold $\\varepsilon(a)$ proportional to $1/a$. Use $\\varepsilon(a) = \\varepsilon_0/a$ with $\\varepsilon_0 = 10^{-8}$ to maintain a scale-consistent threshold in physical units.\n4. Quantify chiral symmetry breaking by computing, for each operator $D(\\mathbf{q})$, the anticommutator with chirality, $\\{\\gamma_5, D(\\mathbf{q})\\} = \\gamma_5 D(\\mathbf{q}) + D(\\mathbf{q}) \\gamma_5$, and then forming a dimensionless infrared ratio\n$$\n\\mathcal{R}_{\\text{IR}} = \\max_{\\mathbf{p} \\in \\mathcal{B}_{\\text{IR}}} \\frac{\\left\\| \\{\\gamma_5, D(\\mathbf{q})\\} \\right\\|_2}{\\left\\| D(\\mathbf{q}) \\right\\|_2},\n$$\nwhere $\\|\\cdot\\|_2$ denotes the spectral norm, $\\mathbf{q} = a \\mathbf{p}$, and $\\mathcal{B}_{\\text{IR}}$ is the infrared ball of physical momenta defined by $\\|\\mathbf{p}\\| \\le p_{\\text{cut}}$. This infrared ratio vanishes identically for the massless naive operator and is nonzero for the Wilson operator at finite lattice spacing, but should scale to zero linearly in $a$ for fixed $p_{\\text{cut}}$.\n5. Implement the Brillouin Zone sampling using a uniform grid with $N$ points per direction, with $q_{\\mu} = 2\\pi k_{\\mu}/N$ for integers $k_{\\mu} \\in \\{0,1,\\dots,N-1\\}$, so that the BZ is $[0,2\\pi) \\times [0,2\\pi)$ in $q$-space. Angles such as $q_{\\mu}$ must be treated in radians. For the infrared ratio, restrict the maximization to grid points with $\\|\\mathbf{p}\\| = \\|\\mathbf{q}\\|/a \\le p_{\\text{cut}}$.\n\nThe program must evaluate the following test suite of parameter sets and produce quantitative outputs:\n- Test case 1 (baseline without Wilson term): $N = 64$, $a = 1.0$ (dimensionless lattice units), $r = 0.0$, $m_0 = 0.0$, $p_{\\text{cut}} = 0.5$ (in inverse lattice-length units), with angles in radians.\n- Test case 2 (Wilson term on a coarse lattice): $N = 64$, $a = 1.0$, $r = 1.0$, $m_0 = 0.0$, $p_{\\text{cut}} = 0.5$, angles in radians.\n- Test case 3 (Wilson term on a finer lattice): $N = 64$, $a = 0.5$, $r = 1.0$, $m_0 = 0.0$, $p_{\\text{cut}} = 0.5$, angles in radians.\n\nFor each test case, the program must compute and return four numbers:\n- The integer count of near-zero modes for $D_{\\text{naive}}$ over the full Brillouin Zone.\n- The integer count of near-zero modes for $D_{\\text{Wilson}}$ over the full Brillouin Zone.\n- The infrared chiral violation ratio $\\mathcal{R}_{\\text{IR}}$ for $D_{\\text{naive}}$ (a float).\n- The infrared chiral violation ratio $\\mathcal{R}_{\\text{IR}}$ for $D_{\\text{Wilson}}$ (a float).\n\nFinal output format requirement:\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, in the order\n$$\n[\\text{cN}_1,\\text{cW}_1,\\text{rN}_1,\\text{rW}_1,\\text{cN}_2,\\text{cW}_2,\\text{rN}_2,\\text{rW}_2,\\text{cN}_3,\\text{cW}_3,\\text{rN}_3,\\text{rW}_3],\n$$\nwhere $\\text{cN}_i$ is the naive near-zero count, $\\text{cW}_i$ is the Wilson near-zero count, $\\text{rN}_i$ is the naive infrared ratio, and $\\text{rW}_i$ is the Wilson infrared ratio for test case $i$. The counts are integers and the ratios are floats. Angles in all trigonometric functions must be in radians. All outputs are dimensionless. No external input or files are permitted; the program must run as-is and print the line.", "solution": "The user has provided a valid problem statement from the field of computational high-energy physics, specifically lattice gauge theory. The problem requires a numerical demonstration of how the Wilson fermion formulation solves the fermion doubling problem at the cost of explicitly breaking chiral symmetry. The solution will be developed by first establishing the mathematical framework, then outlining the computational steps for the required analysis.\n\n### Principle-Based Design\n\nThe core of the problem lies in the discretization of the Dirac operator on a Euclidean spacetime lattice. The naive discretization leads to unphysical fermion replicas, known as \"doublers,\" a manifestation of the Nielsen-Ninomiya no-go theorem. The Wilson term is an elegant, albeit imperfect, solution.\n\n#### 1. Mathematical Formulation\n\nWe operate in $d=2$ Euclidean dimensions. The continuum Dirac operator is $D = \\sum_{\\mu=1,2} \\gamma_\\mu \\partial_\\mu + m_0$. Discretizing this on a hypercubic lattice with spacing $a$ using a symmetric finite difference for the derivative, $\\partial_\\mu \\psi(x) \\to [\\psi(x+a\\hat{\\mu}) - \\psi(x-a\\hat{\\mu})]/(2a)$, leads to the momentum-space representation of the derivative operator being $i \\sin(p_\\mu a)/a$. We define the dimensionless momentum as $q_\\mu = p_\\mu a$.\n\nThe gamma matrices in $d=2$ can be represented by Pauli matrices, satisfying the Euclidean Clifford algebra $\\{\\gamma_\\mu, \\gamma_\\nu\\} = 2\\delta_{\\mu\\nu}\\mathbf{1}$. We use the standard representation:\n$$\n\\gamma_1 = \\sigma_1 = \\begin{pmatrix} 0  1 \\\\ 1  0 \\end{pmatrix}, \\quad\n\\gamma_2 = \\sigma_2 = \\begin{pmatrix} 0  -i \\\\ i  0 \\end{pmatrix}\n$$\nThe chirality matrix is $\\gamma_5 = \\sigma_3 = \\begin{pmatrix} 1  0 \\\\ 0  -1 \\end{pmatrix}$, which anticommutes with $\\gamma_1$ and $\\gamma_2$: $\\{\\gamma_5, \\gamma_\\mu\\} = 0$.\n\nThe **naive Dirac operator** in momentum space for a massless fermion ($m_0=0$) is:\n$$\nD_{\\text{naive}}(\\mathbf{q}) = \\frac{i}{a} \\sum_{\\mu=1}^{2} \\gamma_{\\mu} \\sin(q_{\\mu}) = \\frac{i}{a} \\begin{pmatrix} 0  \\sin(q_1) - i\\sin(q_2) \\\\ \\sin(q_1) + i\\sin(q_2)  0 \\end{pmatrix}\n$$\n\nThe **Wilson term** is constructed from the lattice Laplacian, whose symbol is $\\sum_\\mu 2(1-\\cos q_\\mu)/a^2$. It is added to the operator to give the doublers a large mass. The Wilson term is:\n$$\nR(\\mathbf{q}) = -\\frac{r}{a} \\sum_{\\mu=1}^{2} (1 - \\cos(q_{\\mu}))\n$$\nwhere $r$ is the dimensionless Wilson parameter. This term is proportional to the identity matrix in spinor space, $\\mathbf{1}$.\n\nThe **Wilson-Dirac operator** is the sum of the naive operator and the Wilson term:\n$$\nD_{\\text{Wilson}}(\\mathbf{q}) = D_{\\text{naive}}(\\mathbf{q}) + R(\\mathbf{q})\\mathbf{1} = \\begin{pmatrix} R(\\mathbf{q})  \\frac{i}{a}(\\sin(q_1) - i\\sin(q_2)) \\\\ \\frac{i}{a}(\\sin(q_1) + i\\sin(q_2))  R(\\mathbf{q}) \\end{pmatrix}\n$$\n\n#### 2. Doubler Lifting Analysis\n\nFermion modes correspond to the zeros of the Dirac operator, i.e., where its singular values are zero. The singular values are the square roots of the eigenvalues of $D^\\dagger D$.\n\nFor the naive operator (with $m_0=0$), it is anti-hermitian ($D_{\\text{naive}}^\\dagger = -D_{\\text{naive}}$). Thus,\n$$\nD_{\\text{naive}}^\\dagger D_{\\text{naive}} = -D_{\\text{naive}}^2 = -\\left(\\frac{i}{a}\\right)^2 \\left(\\sum_\\mu \\gamma_\\mu \\sin q_\\mu\\right)^2 = \\frac{1}{a^2} \\left(\\sum_\\mu \\sin^2 q_\\mu\\right)\\mathbf{1}\n$$\nThe singular values are degenerate and given by $s_{\\text{naive}}(\\mathbf{q}) = \\frac{1}{a} \\sqrt{\\sin^2 q_1 + \\sin^2 q_2}$. These are zero when both $\\sin q_1 = 0$ and $\\sin q_2 = 0$. In the Brillouin Zone $q_\\mu \\in [0, 2\\pi)$, this occurs at four momentum points: $(0,0)$, $(0,\\pi)$, $(\\pi,0)$, and $(\\pi,\\pi)$. These $2^d=4$ massless modes are the physical fermion and three unphysical \"doublers.\"\n\nFor the Wilson operator, $D_{\\text{Wilson}} = D_{\\text{naive}} + R(\\mathbf{q})\\mathbf{1}$. Since $R(\\mathbf{q})$ is real, its dagger operation is trivial.\n$$\nD_{\\text{Wilson}}^\\dagger D_{\\text{Wilson}} = (-D_{\\text{naive}} + R(\\mathbf{q})\\mathbf{1})(D_{\\text{naive}} + R(\\mathbf{q})\\mathbf{1}) = -D_{\\text{naive}}^2 + R(\\mathbf{q})^2\\mathbf{1}\n$$\n$$\nD_{\\text{Wilson}}^\\dagger D_{\\text{Wilson}} = \\left( \\frac{1}{a^2}(\\sin^2 q_1 + \\sin^2 q_2) + R(\\mathbf{q})^2 \\right)\\mathbf{1}\n$$\nThe singular values are $s_{\\text{Wilson}}(\\mathbf{q}) = \\sqrt{\\frac{1}{a^2}(\\sin^2 q_1 + \\sin^2 q_2) + R(\\mathbf{q})^2}$. For this to be zero, both terms under the square root must vanish. The term with sines vanishes at the same four doubler locations. However, the Wilson term $R(\\mathbf{q})$ is only zero at $\\mathbf{q}=(0,0)$ (for $r \\ne 0$). At the other three locations, e.g., $\\mathbf{q}=(\\pi,0)$, $R(\\pi,0) = -2r/a \\neq 0$. The doublers at the BZ corners acquire a mass of order $r/a$, decoupling them in the continuum limit ($a \\to 0$). Only the physical mode at $\\mathbf{q}=(0,0)$ remains massless.\n\nThe algorithm will count the number of momentum points $\\mathbf{q}$ on an $N \\times N$ grid where the smallest singular value is below a threshold $\\varepsilon(a) = \\varepsilon_0/a$, for $\\varepsilon_0 = 10^{-8}$. We expect to count $4$ for the naive operator and $1$ for the Wilson operator (with $r=1$).\n\n#### 3. Chiral Symmetry Breaking Analysis\n\nChiral symmetry for a massless Dirac operator $D$ is expressed by the condition $\\{\\gamma_5, D\\} = 0$.\n\nFor the naive operator, $\\{\\gamma_5, D_{\\text{naive}}\\} = \\frac{i}{a} \\sum_\\mu \\{\\gamma_5, \\gamma_\\mu\\} \\sin q_\\mu = 0$, since the gamma matrices anticommute with $\\gamma_5$. The naive massless operator possesses exact chiral symmetry.\n\nFor the Wilson operator, the Wilson term does not anticommute with $\\gamma_5$:\n$$\n\\{\\gamma_5, D_{\\text{Wilson}}\\} = \\{\\gamma_5, D_{\\text{naive}}\\} + \\{\\gamma_5, R(\\mathbf{q})\\mathbf{1}\\} = 0 + R(\\mathbf{q})(\\gamma_5 \\mathbf{1} + \\mathbf{1} \\gamma_5) = 2R(\\mathbf{q})\\gamma_5\n$$\nThis non-zero anticommutator signifies that the Wilson term explicitly breaks chiral symmetry. The magnitude of this breaking is proportional to $R(\\mathbf{q})$. In the infrared (continuum) limit $\\mathbf{q} \\to 0$, $R(\\mathbf{q}) \\approx -\\frac{r}{2a}|\\mathbf{q}|^2 = -\\frac{ra}{2}|\\mathbf{p}|^2$. The breaking is an $O(a)$ effect, which vanishes in the continuum limit.\n\nWe quantify this by computing the dimensionless ratio $\\mathcal{R}_{\\text{IR}}$ over an infrared ball of physical momenta, $\\|\\mathbf{p}\\| \\le p_{\\text{cut}}$, which is equivalent to $\\|\\mathbf{q}'\\| \\le a p_{\\text{cut}}$, where $\\mathbf{q}'$ are momenta mapped to the interval $[-\\pi, \\pi]$.\n$$\n\\mathcal{R}_{\\text{IR}} = \\max_{\\|\\mathbf{p}\\| \\le p_{\\text{cut}}} \\frac{\\left\\| \\{\\gamma_5, D(\\mathbf{q})\\} \\right\\|_2}{\\left\\| D(\\mathbf{q}) \\right\\|_2}\n$$\nwhere $\\|\\cdot\\|_2$ is the spectral norm (largest singular value).\nFor $D_{\\text{naive}}$, this ratio is identically zero. For $D_{\\text{Wilson}}$, the ratio is approximately $\\frac{|2R(\\mathbf{q})|}{\\|D_{\\text{Wilson}}(\\mathbf{q})\\|_2}$. As argued above, this ratio is expected to be proportional to the lattice spacing $a$. The program will compute this maximum ratio for both operators over the specified infrared region.\n\n#### 4. Algorithmic Implementation\n\nThe program will iterate through the specified test cases. For each case:\n1.  Define constants and operators based on the parameters $N, a, r, m_0, p_{\\text{cut}}$.\n2.  Generate a $2$D grid of dimensionless momenta $\\mathbf{q} = (q_1, q_2)$ where $q_\\mu = 2\\pi k_\\mu/N$ for $k_\\mu \\in \\{0, \\dots, N-1\\}$.\n3.  Initialize counters for near-zero modes and variables for the maximum infrared ratios.\n4.  Iterate over each point $\\mathbf{q}$ on the grid.\n    a. Construct the $2 \\times 2$ matrices for $D_{\\text{naive}}(\\mathbf{q})$ and $D_{\\text{Wilson}}(\\mathbf{q})$.\n    b. Compute their singular values using `numpy.linalg.svd`.\n    c. Compare the minimum singular value of each operator to the threshold $\\varepsilon_0/a$ and update the respective counters.\n    d. Map the momentum $\\mathbf{q}$ to $\\mathbf{q}' \\in [-\\pi, \\pi]^2$ to correctly measure its distance from the origin. Check if $\\|\\mathbf{q}'\\| \\le a p_{\\text{cut}}$.\n    e. If inside the infrared ball, compute $\\{\\gamma_5, D\\}$ for both operators, find their spectral norms, find the spectral norms of the operators themselves, and update the maximum ratios $\\mathcal{R}_{\\text{IR}}$.\n5.  Store the four computed values (two counts, two ratios) for the test case.\n6.  After processing all test cases, print the results in the required single-line format.\n\nThis procedure will numerically verify the theoretical predictions: the naive operator has doublers but is chirally symmetric, while the Wilson operator removes doublers at the expense of introducing a controlled, explicit breaking of chiral symmetry that vanishes in the continuum limit.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Demonstrates doubler lifting and chiral symmetry breaking by the Wilson term\n    in the 2D lattice Dirac operator.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, a, r, m0, p_cut)\n        (64, 1.0, 0.0, 0.0, 0.5), # Case 1: Naive operator baseline\n        (64, 1.0, 1.0, 0.0, 0.5), # Case 2: Wilson operator, coarse lattice\n        (64, 0.5, 1.0, 0.0, 0.5), # Case 3: Wilson operator, finer lattice\n    ]\n\n    # Define gamma matrices (Pauli matrices) and identity\n    gamma1 = np.array([[0, 1], [1, 0]], dtype=complex)\n    gamma2 = np.array([[0, -1j], [1j, 0]], dtype=complex)\n    gamma5 = np.array([[1, 0], [0, -1]], dtype=complex)\n    identity = np.eye(2, dtype=complex)\n\n    results = []\n    \n    for N, a, r, m0, p_cut in test_cases:\n        # Initialize outputs for the current test case\n        count_naive = 0\n        count_wilson = 0\n        max_ratio_naive = 0.0\n        max_ratio_wilson = 0.0\n        \n        # Threshold for counting near-zero modes\n        epsilon_0 = 1e-8\n        threshold = epsilon_0 / a\n        \n        # Infrared momentum cutoff in q-space\n        ir_q_radius = a * p_cut\n        \n        # Generate the momentum grid in radians for the Brillouin Zone [0, 2pi) x [0, 2pi)\n        k_vals = np.arange(N)\n        q_vals = 2 * np.pi * k_vals / N\n        \n        # Loop over all momentum points in the Brillouin Zone\n        for q1 in q_vals:\n            for q2 in q_vals:\n                # --- Construct Operators ---\n                \n                # Naive Dirac operator D_naive(q)\n                d_naive_term = (gamma1 * np.sin(q1) + gamma2 * np.sin(q2))\n                D_naive = (1j / a) * d_naive_term + m0 * identity\n\n                # Wilson term R(q)\n                R_q = -r / a * ((1 - np.cos(q1)) + (1 - np.cos(q2)))\n\n                # Wilson-Dirac operator D_Wilson(q)\n                D_wilson = D_naive + R_q * identity\n                \n                # --- 1. Doubler Lifting Analysis ---\n                \n                # Singular values are computed from the operator matrices\n                s_naive = np.linalg.svd(D_naive, compute_uv=False)\n                s_wilson = np.linalg.svd(D_wilson, compute_uv=False)\n                \n                # Check if the smallest singular value is near-zero\n                if np.min(s_naive)  threshold:\n                    count_naive += 1\n                if np.min(s_wilson)  threshold:\n                    count_wilson += 1\n                \n                # --- 2. Chiral Symmetry Breaking Analysis ---\n                \n                # Map q from [0, 2pi) to [-pi, pi) to correctly calculate distance from origin\n                q1_prime = (q1 + np.pi) % (2 * np.pi) - np.pi\n                q2_prime = (q2 + np.pi) % (2 * np.pi) - np.pi\n                \n                q_norm = np.sqrt(q1_prime**2 + q2_prime**2)\n\n                if q_norm = ir_q_radius:\n                    # Anticommutators {gamma5, D}\n                    anticomm_naive = gamma5 @ D_naive + D_naive @ gamma5\n                    anticomm_wilson = gamma5 @ D_wilson + D_wilson @ gamma5\n                    \n                    # Spectral norms ||.||_2 (largest singular value)\n                    norm_D_naive = np.max(s_naive)\n                    norm_D_wilson = np.max(s_wilson)\n                    \n                    # For anticommutators, need to compute SVD if they are not just scaled matrices\n                    norm_anticomm_naive = np.linalg.svd(anticomm_naive, compute_uv=False)[0]\n                    norm_anticomm_wilson = np.linalg.svd(anticomm_wilson, compute_uv=False)[0]\n                    \n                    # Calculate ratios and update maximums\n                    if norm_D_naive  1e-12: # Avoid division by zero at q=0\n                        ratio_naive = norm_anticomm_naive / norm_D_naive\n                        if ratio_naive  max_ratio_naive:\n                            max_ratio_naive = ratio_naive\n                            \n                    if norm_D_wilson  1e-12: # Avoid division by zero at q=0\n                        ratio_wilson = norm_anticomm_wilson / norm_D_wilson\n                        if ratio_wilson  max_ratio_wilson:\n                            max_ratio_wilson = ratio_wilson\n                            \n        results.extend([count_naive, count_wilson, max_ratio_naive, max_ratio_wilson])\n\n    # Final print statement in the exact required format.\n    formatted_results = []\n    for i, res in enumerate(results):\n        if i % 4  2: # Counts are integers\n            formatted_results.append(str(int(res)))\n        else: # Ratios are floats\n            formatted_results.append(str(res))\n            \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3530403"}]}