{"hands_on_practices": [{"introduction": "We begin our practical exploration with a foundational algorithm, the Linear Congruential Generator (LCG). While historically important and simple to implement, LCGs can contain critical flaws. This exercise guides you through the process of diagnosing one of its most notorious weaknesses: the severe serial correlation present in the low-order bits of its output sequence. By formally deriving this correlation and quantifying its impact on the variance of a Monte Carlo estimator [@problem_id:3333419], you will develop essential skills for critically evaluating the quality of a pseudo-random number generator.", "problem": "Consider a Linear Congruential Generator (LCG) defined by the recurrence $x_{t+1} \\equiv a x_t + c \\pmod{m}$ with modulus $m = 2^w$, multiplier $a$, and increment $c$. It is widely recognized that in modulo arithmetic, congruences propagate down to residues modulo divisors, so the recurrence for the $k$ lowest-order bits (i.e., modulo $2^k$ with $k \\leq w$) is $x_{t+1} \\equiv a x_t + c \\pmod{2^k}$. In this problem, you will analyze the impact of using low-order bits to form pseudo-random variates in stochastic simulation.\n\nLet $w = 3$, $a = 1$, $c = 1$, and $m = 2^w = 8$. Define the pseudo-random variate $U_t$ by mapping the $k = 3$ lowest-order bits of $x_t$ into the unit interval via $U_t = (x_t \\bmod 2^k)/2^k$. Assume an unknown seed $x_0$ that is uniformly distributed on $\\{0,1,\\dots,7\\}$, and consider the Monte Carlo estimator of the mean, $\\hat{\\mu}_n = \\frac{1}{n} \\sum_{t=1}^{n} U_t$.\n\nYour tasks are:\n1. Starting from the definition of the LCG, formally show that with the above parameters the sequence of low-order-bit variates obeys $U_{t+1} \\equiv U_t + 2^{-3} \\pmod{1}$, and deduce that this induces severe serial correlations. Your argument must rely only on the recurrence definition, modular arithmetic, and the mapping from bits to the unit interval.\n2. Using only first principles for the variance of averages of dependent sequences, compute the exact variance $\\operatorname{Var}[\\hat{\\mu}_n]$ when $n = 3$, taking the expectation with respect to the uniform seed $x_0$.\n\nExpress your final answer as an exact fraction. Do not round.", "solution": "The problem is found to be valid as it is scientifically grounded in the theory of pseudo-random number generation, is well-posed with a complete and consistent set of givens, and is expressed in objective, formal language. We may therefore proceed with the solution.\n\nThe problem is divided into two parts. The first is to establish a deterministic recurrence for the pseudo-random variates $U_t$. The second is to compute the variance of a Monte Carlo estimator based on a sequence of these variates.\n\n**Part 1: Recurrence Relation for $U_t$**\n\nThe Linear Congruential Generator (LCG) is defined by the recurrence relation $x_{t+1} \\equiv a x_t + c \\pmod{m}$. The problem provides the specific parameters: multiplier $a=1$, increment $c=1$, and modulus $m=2^w$ with $w=3$, so $m=2^3=8$. The recurrence is thus:\n$$\nx_{t+1} \\equiv x_t + 1 \\pmod{8}\n$$\nThis means that for any integer state $x_t \\in \\{0, 1, \\dots, 7\\}$, the next state $x_{t+1}$ is given by $x_{t+1} = (x_t + 1) \\bmod 8$.\n\nThe pseudo-random variate $U_t$ is defined by mapping the $k$ lowest-order bits of $x_t$ to the unit interval $[0, 1)$. The number of bits is specified as $k=3$. The mapping is $U_t = (x_t \\bmod 2^k)/2^k$. With $k=3$, this becomes:\n$$\nU_t = \\frac{x_t \\bmod 2^3}{2^3} = \\frac{x_t \\bmod 8}{8}\n$$\nSince the states $x_t$ are themselves the result of a modulo $8$ operation, they are always in the set $\\{0, 1, \\dots, 7\\}$. For any such $x_t$, we have $x_t \\bmod 8 = x_t$. Therefore, the relation simplifies to:\n$$\nU_t = \\frac{x_t}{8}\n$$\nThis implies $x_t = 8 U_t$. We can substitute this into the recurrence for $x_t$. The next state is given by $x_{t+1} = (x_t + 1) \\bmod 8$. The corresponding variate $U_{t+1}$ is:\n$$\nU_{t+1} = \\frac{x_{t+1}}{8} = \\frac{(x_t + 1) \\bmod 8}{8}\n$$\nSubstituting $x_t = 8 U_t$:\n$$\nU_{t+1} = \\frac{(8 U_t + 1) \\bmod 8}{8}\n$$\nThe operation $(z \\bmod N)/N$ gives the fractional part of the number $z/N$, which can be written as $\\{z/N\\}$ or $z/N \\pmod 1$. Applying this insight, we get:\n$$\nU_{t+1} = \\frac{8 U_t + 1}{8} \\pmod 1 = \\left(U_t + \\frac{1}{8}\\right) \\pmod 1\n$$\nWith $2^{-3} = 1/8$, we have successfully shown that the sequence of variates obeys the relation:\n$$\nU_{t+1} \\equiv U_t + 2^{-3} \\pmod{1}\n$$\nThis recurrence is fully deterministic. Given any $U_t$, the value of $U_{t+1}$ is uniquely determined. This demonstrates a perfect linear relationship between successive values, which represents an extreme case of serial correlation. A plot of pairs $(U_t, U_{t+1})$ would show points lying on just two parallel lines, $y=x+1/8$ and $y=x-7/8$, which is a catastrophic failure for a sequence intended to be pseudo-random.\n\n**Part 2: Variance Calculation for $\\hat{\\mu}_3$**\n\nThe Monte Carlo estimator for the mean is given by $\\hat{\\mu}_n = \\frac{1}{n} \\sum_{t=1}^{n} U_t$. We are asked to compute its variance for $n=3$, which is $\\operatorname{Var}[\\hat{\\mu}_3]$.\n$$\n\\operatorname{Var}[\\hat{\\mu}_3] = \\operatorname{Var}\\left[\\frac{1}{3}(U_1 + U_2 + U_3)\\right] = \\frac{1}{9} \\operatorname{Var}[U_1 + U_2 + U_3]\n$$\nThe variance of a sum of random variables is given by:\n$$\n\\operatorname{Var}\\left[\\sum_{t=1}^{n} U_t\\right] = \\sum_{i=1}^{n} \\sum_{j=1}^{n} \\operatorname{Cov}[U_i, U_j] = \\sum_{t=1}^{n} \\operatorname{Var}[U_t] + 2 \\sum_{1 \\le i < j \\le n} \\operatorname{Cov}[U_i, U_j]\n$$\nFor $n=3$, this expands to:\n$$\n\\operatorname{Var}[U_1 + U_2 + U_3] = \\operatorname{Var}[U_1] + \\operatorname{Var}[U_2] + \\operatorname{Var}[U_3] + 2(\\operatorname{Cov}[U_1, U_2] + \\operatorname{Cov}[U_1, U_3] + \\operatorname{Cov}[U_2, U_3])\n$$\nThe expectation is taken over the distribution of the seed $x_0$, which is uniform on $\\{0, 1, \\dots, 7\\}$. The sequence of states is $x_t = (x_0 + t) \\bmod 8$, and the variates are $U_t = x_t/8$.\n\nFirst, we establish the properties of the sequence $\\{U_t\\}$. Since $x_0$ is a uniform random variable on $\\{0, 1, \\dots, 7\\}$, and $t$ is a constant, the variable $x_t = (x_0 + t) \\bmod 8$ is also uniformly distributed on $\\{0, 1, \\dots, 7\\}$ for any $t \\ge 1$. Consequently, each $U_t$ follows the same discrete uniform distribution on the set $\\{0, \\frac{1}{8}, \\frac{2}{8}, \\dots, \\frac{7}{8}\\}$, with $P(U_t = i/8) = 1/8$ for $i \\in \\{0, \\dots, 7\\}$. This implies the sequence is stationary, so $\\operatorname{E}[U_t]$ and $\\operatorname{Var}[U_t]$ are constant for all $t$, and the autocovariance $\\operatorname{Cov}[U_t, U_{t+k}]$ depends only on the lag $k$.\n\nWe compute the first and second moments of $U_t$:\n$$\n\\operatorname{E}[U_t] = \\sum_{i=0}^{7} \\frac{i}{8} P\\left(x_t = i\\right) = \\frac{1}{8} \\sum_{i=0}^{7} \\frac{i}{8} = \\frac{1}{64} \\frac{7(8)}{2} = \\frac{28}{64} = \\frac{7}{16}\n$$\n$$\n\\operatorname{E}[U_t^2] = \\sum_{i=0}^{7} \\left(\\frac{i}{8}\\right)^2 P\\left(x_t = i\\right) = \\frac{1}{8} \\sum_{i=0}^{7} \\frac{i^2}{64} = \\frac{1}{512} \\sum_{i=0}^{7} i^2 = \\frac{1}{512} \\frac{7(7+1)(2 \\cdot 7+1)}{6} = \\frac{140}{512} = \\frac{35}{128}\n$$\nThe variance is:\n$$\n\\operatorname{Var}[U_t] = \\operatorname{E}[U_t^2] - (\\operatorname{E}[U_t])^2 = \\frac{35}{128} - \\left(\\frac{7}{16}\\right)^2 = \\frac{35}{128} - \\frac{49}{256} = \\frac{70 - 49}{256} = \\frac{21}{256}\n$$\nSo, $\\operatorname{Var}[U_1] = \\operatorname{Var}[U_2] = \\operatorname{Var}[U_3] = 21/256$.\n\nNext, we compute the autocovariances $\\gamma(k) = \\operatorname{Cov}[U_t, U_{t+k}]$.\n$\\gamma(k) = \\operatorname{E}[U_t U_{t+k}] - \\operatorname{E}[U_t]\\operatorname{E}[U_{t+k}] = \\operatorname{E}[U_t U_{t+k}] - (7/16)^2$.\nWe have $U_{t+k} = ((x_t+k)\\pmod 8)/8$.\n$$\n\\operatorname{E}[U_t U_{t+k}] = \\operatorname{E}\\left[\\frac{x_t}{8} \\frac{(x_t+k)\\pmod 8}{8}\\right] = \\frac{1}{64}\\operatorname{E}[x_t ((x_t+k)\\pmod 8)]\n$$\nThe expectation is over $x_t \\sim U\\{0, \\dots, 7\\}$.\n$$\n\\operatorname{E}[x_t ((x_t+k)\\pmod 8)] = \\frac{1}{8}\\sum_{j=0}^{7} j ((j+k)\\pmod 8)\n$$\nFor lag $k=1$:\n$$\n\\frac{1}{8}\\sum_{j=0}^{7} j ((j+1)\\pmod 8) = \\frac{1}{8}(0 \\cdot 1 + 1 \\cdot 2 + 2 \\cdot 3 + 3 \\cdot 4 + 4 \\cdot 5 + 5 \\cdot 6 + 6 \\cdot 7 + 7 \\cdot 0) = \\frac{112}{8} = 14\n$$\nSo $\\operatorname{E}[U_t U_{t+1}] = 14/64 = 7/32$.\n$\\gamma(1) = \\operatorname{Cov}[U_1, U_2] = \\operatorname{Cov}[U_2, U_3] = \\frac{7}{32} - \\frac{49}{256} = \\frac{56 - 49}{256} = \\frac{7}{256}$.\n\nFor lag $k=2$:\n$$\n\\frac{1}{8}\\sum_{j=0}^{7} j ((j+2)\\pmod 8) = \\frac{1}{8}(0 \\cdot 2 + 1 \\cdot 3 + 2 \\cdot 4 + 3 \\cdot 5 + 4 \\cdot 6 + 5 \\cdot 7 + 6 \\cdot 0 + 7 \\cdot 1) = \\frac{92}{8} = \\frac{23}{2}\n$$\nSo $\\operatorname{E}[U_t U_{t+2}] = (23/2)/64 = 23/128$.\n$\\gamma(2) = \\operatorname{Cov}[U_1, U_3] = \\frac{23}{128} - \\frac{49}{256} = \\frac{46 - 49}{256} = -\\frac{3}{256}$.\n\nNow we assemble the variance of the sum:\n\\begin{align*} \\operatorname{Var}[U_1 + U_2 + U_3] &= 3 \\operatorname{Var}[U_t] + 2(2\\gamma(1) + \\gamma(2)) \\\\ &= 3\\left(\\frac{21}{256}\\right) + 2\\left(2\\left(\\frac{7}{256}\\right) - \\frac{3}{256}\\right) \\\\ &= \\frac{63}{256} + 2\\left(\\frac{14 - 3}{256}\\right) \\\\ &= \\frac{63}{256} + 2\\left(\\frac{11}{256}\\right) = \\frac{63+22}{256} = \\frac{85}{256} \\end{align*}\nFinally, the variance of the estimator $\\hat{\\mu}_3$ is:\n$$\n\\operatorname{Var}[\\hat{\\mu}_3] = \\frac{1}{9} \\operatorname{Var}[U_1 + U_2 + U_3] = \\frac{1}{9} \\cdot \\frac{85}{256} = \\frac{85}{2304}\n$$\nThe numerator is $85 = 5 \\times 17$ and the denominator is $2304 = 9 \\times 256 = 3^2 \\times 2^8$, so the fraction is in its simplest form.", "answer": "$$\n\\boxed{\\frac{85}{2304}}\n$$", "id": "3333419"}, {"introduction": "Modern high-performance generators, such as those in the xorshift family, gain their speed from bitwise operations that are linear over the finite field $\\mathbb{F}_2$. This inherent linearity, however, creates statistical artifacts that can be detected and may compromise simulation results. This practice explores the crucial difference between linearity in a bitwise context (the vector space $\\mathbb{F}_2^w$) and non-linearity in integer arithmetic (the ring $\\mathbb{Z}/2^w\\mathbb{Z}$). You will analyze how applying a simple non-linear output permutation, such as multiplication by an odd constant, can effectively break these linear patterns [@problem_id:3333396], a technique central to the design of robust, state-of-the-art generators.", "problem": "Consider a word-oriented xorshift pseudo-random number generator (PRNG) over a fixed word size $w \\in \\mathbb{N}$, with internal state $x \\in \\{0,1,\\dots,2^w-1\\}$. The update rule applies a sequence of shifts and exclusive-or operations of the form\n$$\nx \\leftarrow x \\oplus (x \\ll a), \\quad x \\leftarrow x \\oplus (x \\gg b), \\quad x \\leftarrow x \\oplus (x \\ll c),\n$$\nfor fixed positive integers $a$, $b$, and $c$ less than $w$, where $\\ll$ and $\\gg$ denote logical left and right shifts and $\\oplus$ denotes bitwise exclusive-or. The raw output is the updated word $x$. Suppose we instead output a permuted word\n$$\ny \\equiv C \\cdot x \\pmod{2^w},\n$$\nfor a fixed odd integer $C$ with $1 \\leq C < 2^w$.\n\nUsing the following foundational notions:\n\n- The finite field of two elements $\\mathbb{F}_2 = \\{0,1\\}$ with addition and multiplication modulo $2$, and the vector space $\\mathbb{F}_2^w$ of $w$-bit words under componentwise addition (bitwise exclusive-or) and scalar multiplication.\n- A function $f:\\mathbb{F}_2^w \\to \\mathbb{F}_2^w$ is $\\mathbb{F}_2$-linear if and only if $f(u \\oplus v) = f(u) \\oplus f(v)$ and $f(\\alpha u) = \\alpha f(u)$ for all $u,v \\in \\mathbb{F}_2^w$ and scalars $\\alpha \\in \\mathbb{F}_2$.\n- The ring of integers modulo $2^w$, denoted $\\mathbb{Z}/2^w\\mathbb{Z}$, and the fact that multiplication by $C$ modulo $2^w$ is a bijection if and only if $\\gcd(C,2^w)=1$.\n- The principle that applying a bijection to uniformly distributed outputs preserves uniformity at the word level.\n\nAnswer the following multiple-choice question by selecting all statements that are correct:\n\nA. The xorshift state transition described above is a linear transformation on $\\mathbb{F}_2^w$, so statistical tests designed to detect linear structure in binary sequences (e.g., binary matrix rank and linear complexity tests) can reveal artifacts in the raw output.\n\nB. The mapping $f(x) = C \\cdot x \\bmod 2^w$ with odd $C$ is $\\mathbb{F}_2$-linear on $\\mathbb{F}_2^w$, so it cannot mitigate linear artifacts inherent in the xorshift generator.\n\nC. The mapping $f(x) = C \\cdot x \\bmod 2^w$ with odd $C$ is a bijection on $\\mathbb{Z}/2^w\\mathbb{Z}$ and preserves word-level uniformity; moreover, because carries make $f$ non-linear over $\\mathbb{F}_2$, it can mitigate linear artifacts in tests sensitive to $\\mathbb{F}_2$-linearity.\n\nD. Applying the multiplicative permutation to the output necessarily reduces the period of the generator by a factor equal to $C$, unless $C=1$.\n\nE. The mapping $f(x) = C \\cdot x \\bmod 2^w$ with odd $C$ makes each output bit of $y$ independent and identically distributed as $\\operatorname{Bernoulli}(1/2)$, regardless of bit-level deficiencies in the original xorshift output.\n\nSelect all that apply.", "solution": "The problem asks us to evaluate five statements regarding a word-oriented xorshift pseudo-random number generator (PRNG) and a specific multiplicative output transformation. First, we validate the problem statement.\n\n### Problem Statement Validation\n\n**Step 1: Extract Givens**\n- **Generator Type**: Word-oriented xorshift PRNG.\n- **Word Size**: $w \\in \\mathbb{N}$.\n- **State Space**: $x \\in \\{0, 1, \\dots, 2^w-1\\}$.\n- **State Update Rule**: A sequence of operations: $x \\leftarrow x \\oplus (x \\ll a)$, $x \\leftarrow x \\oplus (x \\gg b)$, $x \\leftarrow x \\oplus (x \\ll c)$, where $a, b, c$ are fixed positive integers less than $w$.\n- **Operators**: $\\ll$ and $\\gg$ are logical bit shifts, $\\oplus$ is bitwise exclusive-or.\n- **Raw Output**: The updated state word $x$.\n- **Modified Output**: A permuted word $y \\equiv C \\cdot x \\pmod{2^w}$.\n- **Multiplier**: $C$ is a fixed odd integer, $1 \\leq C < 2^w$.\n- **Foundational Concepts**:\n    - The vector space $\\mathbb{F}_2^w$ over the field $\\mathbb{F}_2 = \\{0,1\\}$.\n    - Definition of an $\\mathbb{F}_2$-linear function on $\\mathbb{F}_2^w$.\n    - The ring of integers $\\mathbb{Z}/2^w\\mathbb{Z}$.\n    - The condition for multiplication by $C$ to be a bijection on $\\mathbb{Z}/2^w\\mathbb{Z}$ is $\\gcd(C, 2^w) = 1$.\n    - A bijection applied to a uniform distribution preserves word-level uniformity.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientific Groundedness**: The problem describes the xorshift family of generators and a common technique for improving their statistical quality (non-linear output mixing). These are standard concepts in the field of PRNG design. The mathematical frameworks of $\\mathbb{F}_2^w$ (for linearity analysis) and $\\mathbb{Z}/2^w\\mathbb{Z}$ (for arithmetic analysis) are appropriate and correctly defined. The problem is scientifically sound.\n- **Well-Posedness**: The question requires evaluating the correctness of several statements based on the provided setup and foundational principles. Each statement can be rigorously analyzed for its validity.\n- **Objectivity**: The problem is stated in precise, formal language, free from subjective or ambiguous terms.\n- **Completeness and Consistency**: The problem statement provides all necessary information to analyze the generator's properties and evaluate the options. There are no contradictions.\n\n**Step 3: Verdict and Action**\nThe problem statement is valid. We will proceed to derive the solution by analyzing each option.\n\n### Derivation and Option Analysis\n\nLet the state of the generator be a vector in the vector space $\\mathbb{F}_2^w$. The bitwise XOR operation $\\oplus$ corresponds to vector addition in $\\mathbb{F}_2^w$. The logical shift operations, $x \\ll a$ and $x \\gg b$, are linear transformations on $\\mathbb{F}_2^w$. They can be represented by $w \\times w$ matrices with entries in $\\mathbb{F}_2$.\n\nThe operation $x \\leftarrow x \\oplus (x \\text{ shift } k)$ can be written as $x_{\\text{new}} = (I \\oplus S)x_{\\text{old}}$, where $I$ is the identity matrix and $S$ is the matrix for the shift operation. The composition of linear transformations is a linear transformation. Therefore, the entire xorshift state update, $x_{n+1} = T(x_n)$, is an $\\mathbb{F}_2$-linear transformation on $\\mathbb{F}_2^w$.\n\n**A. The xorshift state transition described above is a linear transformation on $\\mathbb{F}_2^w$, so statistical tests designed to detect linear structure in binary sequences (e.g., binary matrix rank and linear complexity tests) can reveal artifacts in the raw output.**\n\nAs established above, the state transition of an xorshift generator is a composition of bitwise XOR and shift operations. Let a state $x$ be a vector in $\\mathbb{F}_2^w$. A shift operation $S(x)$ is linear, so $S(u \\oplus v) = S(u) \\oplus S(v)$. The operation $f(x) = x \\oplus S(x)$ is also linear: $f(u \\oplus v) = (u \\oplus v) \\oplus S(u \\oplus v) = (u \\oplus S(u)) \\oplus (v \\oplus S(v)) = f(u) \\oplus f(v)$. Since the overall state transition is a composition of such linear functions, it is itself a linear transformation over $\\mathbb{F}_2^w$.\nThis inherent linearity implies that the sequence of output words (if we take the raw state $x$ as output) satisfies a linear recurrence relation over $\\mathbb{F}_2$. For instance, for any sequence of $w+1$ consecutive raw outputs $x_n, x_{n+1}, \\dots, x_{n+w}$, there exists a non-trivial set of coefficients $c_i \\in \\{0,1\\}$ such that $\\bigoplus_{i=0}^w c_i x_{n+i} = 0$. This is a massive statistical defect. Statistical tests like the binary matrix rank test or the linear complexity test are specifically designed to detect such linear relations. An $\\mathbb{F}_2$-linear generator like xorshift will fail these tests spectacularly.\n**Verdict: Correct.**\n\n**B. The mapping $f(x) = C \\cdot x \\bmod 2^w$ with odd $C$ is $\\mathbb{F}_2$-linear on $\\mathbb{F}_2^w$, so it cannot mitigate linear artifacts inherent in the xorshift generator.**\n\nTo check for $\\mathbb{F}_2$-linearity, we must verify if $f(u \\oplus v) = f(u) \\oplus f(v)$ for all $u, v \\in \\mathbb{F}_2^w$. The operation $C \\cdot x \\pmod{2^w}$ is integer multiplication, not a bitwise operation over $\\mathbb{F}_2$. Integer multiplication involves carry propagation, which is a non-linear operation when viewed over $\\mathbb{F}_2$.\nLet's consider a simple counterexample. Let $w=4$, $C=3$. Let $u=1$ (binary `0001`) and $v=2$ (binary `0010`). Then $u \\oplus v = 3$ (binary `0011`).\n- $f(u) = 3 \\cdot 1 \\pmod{16} = 3$ (binary `0011`).\n- $f(v) = 3 \\cdot 2 \\pmod{16} = 6$ (binary `0110`).\n- $f(u) \\oplus f(v) = 3 \\oplus 6 = 5$ (binary `0101`).\n- $f(u \\oplus v) = f(3) = 3 \\cdot 3 \\pmod{16} = 9$ (binary `1001`).\nSince $f(u \\oplus v) = 9 \\neq 5 = f(u) \\oplus f(v)$, the function $f(x)$ is not $\\mathbb{F}_2$-linear. The premise of the statement is false. Because the mapping is in fact non-linear, it is a candidate for mitigating linear artifacts, contradicting the statement's conclusion.\n**Verdict: Incorrect.**\n\n**C. The mapping $f(x) = C \\cdot x \\bmod 2^w$ with odd $C$ is a bijection on $\\mathbb{Z}/2^w\\mathbb{Z}$ and preserves word-level uniformity; moreover, because carries make $f$ non-linear over $\\mathbb{F}_2$, it can mitigate linear artifacts in tests sensitive to $\\mathbb{F}_2$-linearity.**\n\nThis statement consists of several claims.\n1.  **Bijection**: The mapping $f(x) = C \\cdot x$ is a bijection on $\\mathbb{Z}/2^w\\mathbb{Z}$ if and only if $C$ has a multiplicative inverse modulo $2^w$. This is true if and only if $\\gcd(C, 2^w) = 1$. Since $C$ is odd, its prime factors are all odd. The only prime factor of $2^w$ is $2$. Thus, $\\gcd(C, 2^w) = 1$, and the mapping is a bijection. This claim is correct.\n2.  **Uniformity**: If the raw output $x$ is assumed to be uniformly distributed on the set of all $2^w$ words, applying a bijection to this set results in another set of $2^w$ distinct words, which must also be uniformly distributed. This claim is correct.\n3.  **Non-linearity and Mitigation**: As demonstrated in the analysis of option B, the integer multiplication involves carry bits, making the function $f(x)$ non-linear over $\\mathbb{F}_2$. Applying a non-linear function to the output of a linear generator is a standard and effective method to break the linear dependencies. The resulting sequence of outputs $y_n = f(x_n)$ will not satisfy the simple linear recurrences that the raw sequence $x_n$ does. This improves the generator's performance on statistical tests that are sensitive to $\\mathbb{F}_2$-linearity. This is a central idea in modern PRNG design (e.g., the PCG and xoshiro families). This claim is correct.\nAll parts of the statement are correct and logically connected.\n**Verdict: Correct.**\n\n**D. Applying the multiplicative permutation to the output necessarily reduces the period of the generator by a factor equal to $C$, unless $C=1$.**\n\nThe period of a PRNG is a property of its state transition function, $x_{n+1} = T(x_n)$. An output function $y_n = f(x_n)$ does not alter the underlying sequence of states $\\{x_n\\}$. Let the period of the state sequence be $P$, so $x_{n+P} = x_n$ for a given cycle. Then the output sequence has $y_{n+P} = f(x_{n+P}) = f(x_n) = y_n$. This means the period of the output sequence must be a divisor of $P$.\nThe function $f(x)$ is a bijection. If the output period were a smaller value $k < P$ (where $k$ divides $P$), it would mean $y_{n+k} = y_n$ for all $n$ in the cycle. This implies $f(x_{n+k}) = f(x_n)$. Since $f$ is a bijection, $f(a)=f(b)$ if and only if $a=b$. Therefore, $x_{n+k} = x_n$, which contradicts the fact that $P$ is the period of the state sequence. Thus, the period of the output sequence is exactly equal to the period of the state sequence. The statement that the period is reduced is false.\n**Verdict: Incorrect.**\n\n**E. The mapping $f(x) = C \\cdot x \\bmod 2^w$ with odd $C$ makes each output bit of $y$ independent and identically distributed as $\\operatorname{Bernoulli}(1/2)$, regardless of bit-level deficiencies in the original xorshift output.**\n\nThis is a very strong claim. Let's analyze the effect of the mapping on the least significant bit (LSB). Let $x_0$ be the LSB of $x$ and $y_0$ be the LSB of $y = C \\cdot x$. In integer arithmetic modulo $2$, the LSB of a product is the product of the LSBs. So, $y_0 \\equiv C_0 \\cdot x_0 \\pmod 2$, where $C_0$ is the LSB of $C$. Since $C$ is an odd integer, its LSB is $C_0=1$. Therefore, $y_0 \\equiv 1 \\cdot x_0 \\pmod 2$, which means $y_0 = x_0$.\nThe LSB of the output $y$ is identical to the LSB of the input $x$. The multiplicative mapping does not alter the LSB at all. If the sequence of LSBs from the raw xorshift generator has statistical defects (e.g., a short period, a bias away from $1/2$), these defects will be passed on directly to the LSB of the final output $y$. Therefore, the mapping does not fix all bit-level deficiencies, and it certainly does not guarantee that every output bit becomes perfectly random.\n**Verdict: Incorrect.**\n\nFinal conclusion: Statements A and C are correct.", "answer": "$$\\boxed{AC}$$", "id": "3333396"}, {"introduction": "The grand scale of simulations in computational high-energy physics necessitates massive parallelism, where thousands of jobs run concurrently. To ensure statistical independence and reproducibility, each job requires a unique, non-overlapping stream of pseudo-random numbers. This practice addresses this critical infrastructure challenge by having you derive and implement the \"skip-ahead\" algorithm. You will learn to represent the LCG recurrence as an affine transformation and use an efficient $\\mathcal{O}(\\log n)$ algorithm to jump billions of steps forward in the sequence [@problem_id:3529403], a fundamental technique for partitioning PRNG streams in a parallel computing environment.", "problem": "You are tasked with formalizing and implementing an efficient skip-ahead method for a Linear Congruential Generator (LCG), a widely used pseudo-random number generator in computational high-energy physics (HEP), particularly for large-scale Monte Carlo event generation where reproducibility, parallelism, and stream partitioning are essential. The base process is the LCG recurrence on integers modulo a positive integer modulus:\n- The state update is given by $x_{t+1} = (a x_t + c) \\bmod m$ for all integers $t \\ge 0$, where the parameters $a$, $c$, and $m$ are fixed integers with $m \\ge 2$, and $x_t \\in \\{0,1,\\dots,m-1\\}$.\n\nStarting from this fundamental definition of the LCG and standard properties of modular arithmetic (such as associativity and distributivity of addition and multiplication modulo $m$), derive a closed-form expression for $x_{t+n}$ as a function of $a$, $c$, $m$, $x_t$, and $n$, without assuming any special number-theoretic properties of $m$ (do not assume primality or coprimality conditions). Your derivation must begin from the recurrence definition and must not assume any pre-known closed form. The resulting formula must be valid for all integers $n \\ge 0$, including special cases such as $a = 1$ and $c = 0$.\n\nThen, design an algorithm that computes $x_{t+n}$ in time polylogarithmic in $n$, specifically with asymptotic complexity $\\mathcal{O}(\\log n)$ arithmetic operations modulo $m$, so that it remains computationally feasible when $n$ is as large as $10^{12}$. The algorithm must avoid modular inverses and should be correct for arbitrary $m$ (including $m$ that are powers of two). Your design must be grounded in first principles and must clearly identify the algebraic structure being exponentiated.\n\nFinally, implement your algorithm as a complete program that produces the outputs for the following test suite. Each test case is independent. For each, compute the single requested result and collect all results in the specified output format.\n\nTest suite:\n- Case A (identity boundary): parameters $m = 97$, $a = 5$, $c = 3$, $x_t = 42$, $n = 0$. Output the integer $x_{t+n}$.\n- Case B (single-step check): parameters $m = 97$, $a = 5$, $c = 3$, $x_t = 42$, $n = 1$. Output the integer $x_{t+n}$.\n- Case C (two-step check): parameters $m = 97$, $a = 5$, $c = 3$, $x_t = 42$, $n = 2$. Output the integer $x_{t+n}$.\n- Case D (large $n$ with small prime modulus): parameters $m = 97$, $a = 5$, $c = 3$, $x_t = 42$, $n = 10^{12}$. Output the integer $x_{t+n}$.\n- Case E (large $n$ with power-of-two modulus used in practice): parameters $m = 2^{48}$, $a = 25214903917$, $c = 11$, $x_t = 0$, $n = 10^{12}$. Output the integer $x_{t+n}$.\n- Case F (multiplicative generator edge case): parameters $m = 2^{48}$, $a = 25214903917$, $c = 0$, $x_t = 1$, $n = 10^{12}$. Output the integer $x_{t+n}$.\n- Case G (degenerate multiplier $a = 1$ edge case): parameters $m = 1{,}000{,}000{,}007$, $a = 1$, $c = 123{,}456{,}789$, $x_t = 987{,}654{,}321$, $n = 10^{12}$. Output the integer $x_{t+n}$.\n- Case H (semigroup consistency property as a boolean): parameters $m = 2^{48}$, $a = 25214903917$, $c = 11$, $x_t = 123{,}456{,}789{,}012{,}345$, $n_1 = 10^{12} - 1{,}234{,}567$, $n_2 = 1{,}234{,}567$. Compute the boolean truth value of the statement that $x_{t+(n_1+n_2)}$ equals the result of applying skip-ahead by $n_1$ and then by $n_2$, i.e., whether\n$$\n\\bigl(x_{t+n_1}\\bigr) \\xrightarrow{\\text{skip by } n_2} x_{t+n_1+n_2}\n\\quad \\text{equals} \\quad\nx_{t+(n_1+n_2)}\n$$\nwhen both are computed by your $\\mathcal{O}(\\log n)$ algorithm.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for Cases A through H, in order, as a comma-separated list enclosed in square brackets (for example, $[r_A,r_B,\\dots,r_H]$), where each $r$ is either an integer or a boolean as specified above. No additional text should be printed.\n\nNo physical units or angle units are involved. All numeric outputs must be exact integers or booleans as specified. The algorithm must run in time feasible for $n = 10^{12}$ on a modern machine, by employing an $\\mathcal{O}(\\log n)$ skip-ahead strategy.", "solution": "The problem asks for the derivation and implementation of an efficient skip-ahead algorithm for a Linear Congruential Generator (LCG). An LCG is defined by the recurrence relation:\n$$x_{t+1} = (a x_t + c) \\bmod m$$\nfor integers $t \\ge 0$, where $a$ (the multiplier), $c$ (the increment), and $m$ (the modulus) are fixed integer parameters with $m \\ge 2$. The state of the generator at time $t$ is $x_t$, an integer in the set $\\{0, 1, \\dots, m-1\\}$. The task is to find $x_{t+n}$ given $x_t$ and a large integer step $n$, in a time complexity polylogarithmic in $n$, specifically $\\mathcal{O}(\\log n)$.\n\nFirst, we derive a closed-form expression for $x_{t+n}$ by unrolling the recurrence.\nFor $n=1$:\n$$x_{t+1} = a x_t + c$$\nFor $n=2$:\n$$x_{t+2} = a x_{t+1} + c = a(a x_t + c) + c = a^2 x_t + ac + c$$\nFor $n=3$:\n$$x_{t+3} = a x_{t+2} + c = a(a^2 x_t + ac + c) + c = a^3 x_t + a^2 c + ac + c$$\nObserving the pattern, we hypothesize that for any integer $n \\ge 0$, the state $x_{t+n}$ is given by:\n$$x_{t+n} = a^n x_t + c \\left(\\sum_{i=0}^{n-1} a^i\\right)$$\nAll arithmetic is performed modulo $m$. We prove this formula by mathematical induction on $n$.\n\n**Base Case ($n=0$):** The formula gives $x_{t+0} = a^0 x_t + c \\sum_{i=0}^{-1} a^i$. The empty sum is $0$, so $x_{t+0} = 1 \\cdot x_t + c \\cdot 0 = x_t$. This is correct.\n**Base Case ($n=1$):** The formula gives $x_{t+1} = a^1 x_t + c \\sum_{i=0}^{0} a^i = a x_t + c \\cdot a^0 = a x_t + c$. This matches the LCG recurrence.\n\n**Inductive Step:** Assume the formula is true for some integer $k \\ge 0$:\n$$x_{t+k} = a^k x_t + c \\left(\\sum_{i=0}^{k-1} a^i\\right)$$\nWe now find an expression for $x_{t+k+1}$:\n$$x_{t+k+1} = a x_{t+k} + c$$\nSubstituting the inductive hypothesis for $x_{t+k}$:\n$$x_{t+k+1} = a \\left( a^k x_t + c \\sum_{i=0}^{k-1} a^i \\right) + c$$\n$$x_{t+k+1} = a^{k+1} x_t + a c \\sum_{i=0}^{k-1} a^i + c$$\n$$x_{t+k+1} = a^{k+1} x_t + c \\left( a \\sum_{i=0}^{k-1} a^i + 1 \\right)$$\n$$x_{t+k+1} = a^{k+1} x_t + c \\left( \\sum_{i=0}^{k-1} a^{i+1} + a^0 \\right)$$\n$$x_{t+k+1} = a^{k+1} x_t + c \\left( \\sum_{j=1}^{k} a^{j} + a^0 \\right) = a^{k+1} x_t + c \\left( \\sum_{j=0}^{k} a^{j} \\right)$$\nThis is the hypothesized formula for $n=k+1$. The induction is complete. The closed-form expression for $x_{t+n}$ is:\n$$x_{t+n} = \\left(a^n x_t + c \\left(\\sum_{i=0}^{n-1} a^i\\right)\\right) \\bmod m$$\nThe term $\\sum_{i=0}^{n-1} a^i$ is a geometric series. If $a \\ne 1$, its sum is $\\frac{a^n-1}{a-1}$. Using this would require computing the modular multiplicative inverse of $(a-1) \\pmod m$, which may not exist if $\\gcd(a-1, m) \\ne 1$. The problem explicitly forbids this approach. If $a=1$, the sum is simply $n$. A general method is needed.\n\nTo achieve $\\mathcal{O}(\\log n)$ complexity without modular inverses, we can represent the LCG update as an affine transformation and use exponentiation by squaring on this transformation. The function $f(x) = (ax+c) \\pmod m$ maps a state $x_t$ to $x_{t+1}$. Applying the LCG for $n$ steps is equivalent to composing this function with itself $n$ times: $f^n(x_t) = f(f(\\dots f(x_t)\\dots))$.\n\nThe algebraic structure of these affine transformations can be captured using $2 \\times 2$ matrices. We augment the state $x_t$ into a vector $\\begin{pmatrix} x_t \\\\ 1 \\end{pmatrix}$. The LCG update can then be written as a matrix-vector product:\n$$ \\begin{pmatrix} x_{t+1} \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} a & c \\\\ 0 & 1 \\end{pmatrix} \\begin{pmatrix} x_t \\\\ 1 \\end{pmatrix} \\pmod m $$\nLet $T = \\begin{pmatrix} a & c \\\\ 0 & 1 \\end{pmatrix}$. Applying the transformation $n$ times corresponds to raising the matrix $T$ to the $n$-th power:\n$$ \\begin{pmatrix} x_{t+n} \\\\ 1 \\end{pmatrix} = T^n \\begin{pmatrix} x_t \\\\ 1 \\end{pmatrix} \\pmod m $$\nThe power $T^n$ can be computed efficiently in $\\mathcal{O}(\\log n)$ time using exponentiation by squaring. The operations are $2 \\times 2$ matrix multiplications modulo $m$.\nThe structure of $T^n$ is $T^n = \\begin{pmatrix} a^n & c \\sum_{i=0}^{n-1} a^i \\\\ 0 & 1 \\end{pmatrix} = \\begin{pmatrix} A_n & C_n \\\\ 0 & 1 \\end{pmatrix}$, where $A_n = a^n$ and $C_n = c \\sum_{i=0}^{n-1} a^i$ are the effective multiplier and increment for $n$ steps.\nInstead of implementing full matrix multiplication, we can work directly with the pair of coefficients $(A, C)$ that define the affine transformation $x \\mapsto Ax+C$.\nThe composition of two transformations, $(A_1, C_1)$ followed by $(A_2, C_2)$, is:\n$x \\xrightarrow{(A_1, C_1)} A_1 x + C_1 \\xrightarrow{(A_2, C_2)} A_2(A_1 x + C_1) + C_2 = (A_2 A_1) x + (A_2 C_1 + C_2)$.\nThis defines a composition law for the transformation pairs:\n$$(A_2, C_2) \\circ (A_1, C_1) = (A_2 A_1, A_2 C_1 + C_2)$$\nThis composition is associative. We want to compute $(a,c)^n$, which is $(a,c)$ composed with itself $n$ times. We can use binary exponentiation (exponentiation by squaring) on this pair structure.\n\nThe algorithm to compute $(A_n, C_n) = (a, c)^n$ is as follows:\n1. Initialize a result pair $(A_{res}, C_{res})$ to the identity transformation, which is $(1, 0)$ (since $1 \\cdot x + 0 = x$).\n2. Initialize an accumulator pair $(A_{acc}, C_{acc})$ to the base transformation, $(a, c)$.\n3. Iterate while $n > 0$:\n   a. If $n$ is odd, compose the result with the accumulator: $(A_{res}, C_{res}) \\leftarrow (A_{acc}, C_{acc}) \\circ (A_{res}, C_{res})$.\n      - $A_{res}' = (A_{acc} \\cdot A_{res}) \\bmod m$\n      - $C_{res}' = (A_{acc} \\cdot C_{res} + C_{acc}) \\bmod m$\n   b. Square the accumulator: $(A_{acc}, C_{acc}) \\leftarrow (A_{acc}, C_{acc}) \\circ (A_{acc}, C_{acc})$.\n      - $A_{acc}' = (A_{acc} \\cdot A_{acc}) \\bmod m$\n      - $C_{acc}' = (A_{acc} \\cdot C_{acc} + C_{acc}) \\bmod m$\n   c. Update $n$ to $n \\leftarrow \\lfloor n/2 \\rfloor$.\n4. The final pair $(A_{res}, C_{res})$ is $(A_n, C_n)$.\n\nAfter computing $(A_n, C_n)$, the final state $x_{t+n}$ is calculated as:\n$$x_{t+n} = (A_n \\cdot x_t + C_n) \\bmod m$$\nThis entire process involves a number of modular multiplications and additions proportional to $\\log_2 n$, fulfilling the complexity requirement. It avoids modular inverses and is valid for any choice of parameters $m, a, c$ as specified. This principled approach, grounded in the algebraic structure of affine transformations, yields a robust and efficient algorithm.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the LCG skip-ahead problem for a suite of test cases.\n    \"\"\"\n    \n    def lcg_skip_ahead(m, a, c, x0, n):\n        \"\"\"\n        Computes the n-th state of an LCG starting from x0 in O(log n) time.\n        The LCG is defined by x_next = (a * x + c) % m.\n\n        Args:\n            m (int): The modulus.\n            a (int): The multiplier.\n            c (int): The increment.\n            x0 (int): The initial state.\n            n (int): The number of steps to advance.\n\n        Returns:\n            int: The state x_n.\n        \"\"\"\n        if n == 0:\n            return x0\n\n        # The LCG recurrence x_next = a*x + c is an affine transformation.\n        # Advancing n steps is equivalent to composing this transformation n times.\n        # We can represent the transformation as a pair (A, C) for x -> A*x + C.\n        # The composition of (A1, C1) and (A2, C2) is (A2*A1, A2*C1 + C2).\n        # We use binary exponentiation (exponentiation by squaring) on this\n        # transformation pair to compute the n-step transformation (A_n, C_n).\n\n        # Ensure all initial parameters are within the modulus\n        a %= m\n        c %= m\n\n        # A_res, C_res store the resulting n-step transformation.\n        # Initialize to the identity transformation (A=1, C=0).\n        A_res, C_res = 1, 0  \n\n        # A_acc, C_acc store the transformation for the current power of 2.\n        # Initialize to the single-step transformation (a, c).\n        A_acc, C_acc = a, c\n        \n        k = n\n        while k > 0:\n            if k % 2 == 1:\n                # Compose the result with the current power-of-2 transformation.\n                # (A_res, C_res) -> (A_acc, C_acc) o (A_res, C_res)\n                # A_res' = A_acc * A_res\n                # C_res' = A_acc * C_res + C_acc\n                A_res_new = (A_acc * A_res) % m\n                C_res_new = (A_acc * C_res + C_acc) % m\n                A_res, C_res = A_res_new, C_res_new\n\n            # Square the power-of-2 transformation.\n            # (A_acc, C_acc) -> (A_acc, C_acc) o (A_acc, Cacc)\n            # A_acc' = A_acc * A_acc\n            # C_acc' = A_acc * C_acc + C_acc\n            A_acc_new = (A_acc * A_acc) % m\n            C_acc_new = (A_acc * C_acc + C_acc) % m\n            A_acc, C_acc = A_acc_new, C_acc_new\n            \n            k //= 2\n\n        # After the loop, (A_res, C_res) is the n-step transformation.\n        # Apply it to the initial state x0.\n        return (A_res * x0 + C_res) % m\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (m, a, c, x_t, n_or_n1, n2)\n        ('A', 97, 5, 3, 42, 0, None),\n        ('B', 97, 5, 3, 42, 1, None),\n        ('C', 97, 5, 3, 42, 2, None),\n        ('D', 97, 5, 3, 42, 10**12, None),\n        ('E', 2**48, 25214903917, 11, 0, 10**12, None),\n        ('F', 2**48, 25214903917, 0, 1, 10**12, None),\n        ('G', 1000000007, 1, 123456789, 987654321, 10**12, None),\n        ('H', 2**48, 25214903917, 11, 123456789012345, 10**12 - 1234567, 1234567),\n    ]\n\n    results = []\n    for case in test_cases:\n        case_id, m, a, c, x_t, n1, n2 = case\n        \n        if case_id != 'H':\n            result = lcg_skip_ahead(m, a, c, x_t, n1)\n        else:\n            # Case H: Check semigroup property\n            n_total = n1 + n2\n            \n            # Compute x_{t + n1 + n2} directly\n            res_direct = lcg_skip_ahead(m, a, c, x_t, n_total)\n            \n            # Compute sequentially: skip by n1, then by n2\n            x_intermediate = lcg_skip_ahead(m, a, c, x_t, n1)\n            res_sequential = lcg_skip_ahead(m, a, c, x_intermediate, n2)\n            \n            result = (res_direct == res_sequential)\n            \n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Convert boolean to lowercase 'true' for python output consistency\n    final_results = [str(r).lower() if isinstance(r, bool) else str(r) for r in results]\n    print(f\"[{','.join(final_results)}]\")\n\nsolve()\n```", "id": "3529403"}]}