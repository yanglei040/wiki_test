{"hands_on_practices": [{"introduction": "Automating the calculation of scattering amplitudes begins with a systematic way to represent particle kinematics. This exercise guides you through a first-principles derivation to determine the essential number of variables needed to describe any generic $n$-particle scattering process [@problem_id:3505457]. Understanding this \"dimensionality\" of the kinematic space, expressed in terms of Lorentz-invariant scalars, is a cornerstone for building efficient and general-purpose computational tools.", "problem": "Consider a generic Quantum Field Theory (QFT) tree-level scattering process within the Standard Model in four-dimensional Minkowski spacetime. In automated matrix-element generation, a code must represent kinematics using Lorentz-invariant scalars constructed from external momenta. Let a $2 \\to 2$ massless scattering process have incoming four-momenta $p_{1}$ and $p_{2}$, and outgoing four-momenta $p_{3}$ and $p_{4}$, all satisfying $p_{i}^{2} = 0$ and total momentum conservation $\\sum_{i=1}^{4} p_{i} = 0$. Define the canonical Mandelstam invariants from first principles, and deduce their dependence in the massless case.\n\nThen, generalize to an $n$-point massless amplitude in four dimensions, with $n \\geq 4$ external lightlike momenta $\\{p_{1},\\dots,p_{n}\\}$ obeying $p_{i}^{2} = 0$ and $\\sum_{i=1}^{n} p_{i} = 0$. Starting strictly from the on-shell conditions, total momentum conservation, and global Lorentz invariance, derive the minimal number of independent Lorentz-invariant scalars required to fully parametrize generic external kinematics up to a global Lorentz transformation. Construct an explicit minimal set composed exclusively of two-particle invariants $s_{ij} \\equiv 2\\,p_{i}\\cdot p_{j}$ appropriate for use in automated codes, and justify its independence.\n\nYour final answer must be the single closed-form expression for the minimal number of independent invariants as a function of $n$. No intermediate equalities are permitted as the final answer. If you introduce any numerical quantity, do not round unless explicitly instructed, and no rounding is requested here. Express all mathematics in LaTeX, and state units only if needed; none are needed here. Angles, if any appear, must be in radians; none are needed here.", "solution": "The problem asks for a derivation of the minimal number of independent Lorentz-invariant scalars required to parametrize the kinematics of an $n$-point massless scattering amplitude in four-dimensional spacetime. First, the specific case of $2 \\to 2$ scattering ($n=4$) will be analyzed, followed by the generalization to arbitrary $n \\geq 4$.\n\nThe provided constraints are that all external four-momenta $\\{p_1, \\dots, p_n\\}$ are lightlike (on-shell and massless), satisfying $p_i^2 = 0$, and that total momentum is conserved, $\\sum_{i=1}^n p_i = 0$. The latter convention, where all momenta are treated on an equal footing (e.g., all incoming or all outgoing), is standard in automated matrix element generation systems. The Lorentz-invariant scalars are defined as $s_{ij} \\equiv 2 p_i \\cdot p_j$. Note that with the on-shell condition $p_i^2=0$, an alternative common definition $s_{ij} \\equiv (p_i+p_j)^2$ is equivalent, since $(p_i+p_j)^2 = p_i^2 + p_j^2 + 2 p_i \\cdot p_j = 0 + 0 + 2 p_i \\cdot p_j = s_{ij}$.\n\n**Part 1: Analysis of $2 \\to 2$ Scattering ($n=4$)**\n\nFor a $2 \\to 2$ process with massless particles, we have four momenta $p_1, p_2, p_3, p_4$ satisfying $p_i^2 = 0$ for $i \\in \\{1,2,3,4\\}$ and $p_1+p_2+p_3+p_4=0$.\nThe problem asks to define the canonical Mandelstam invariants. In the physical scattering process $p_1 + p_2 \\to p_3' + p_4'$, momentum conservation is $p_1+p_2 = p_3'+p_4'$. To match the problem's convention $\\sum p_i=0$, we identify the outgoing physical momenta as $p_3 = -p_3'$ and $p_4 = -p_4'$. The standard Mandelstam variables are:\n$$s = (p_1+p_2)^2$$\n$$t = (p_1-p_3')^2 = (p_1+p_3)^2$$\n$$u = (p_1-p_4')^2 = (p_1+p_4)^2$$\nUsing the on-shell condition $p_i^2=0$, these become:\n$$s = 2 p_1 \\cdot p_2 = s_{12}$$\n$$t = 2 p_1 \\cdot p_3 = s_{13}$$\n$$u = 2 p_1 \\cdot p_4 = s_{14}$$\nTo find the dependence among them, we use the momentum conservation law. By taking the dot product of $p_1$ with the conservation equation $\\sum_{j=1}^4 p_j=0$, we get:\n$$p_1 \\cdot (p_1+p_2+p_3+p_4) = 0$$\n$$p_1^2 + p_1 \\cdot p_2 + p_1 \\cdot p_3 + p_1 \\cdot p_4 = 0$$\nSince $p_1^2=0$, and using the definitions of $s_{ij}$, this yields:\n$$\\frac{1}{2}s_{12} + \\frac{1}{2}s_{13} + \\frac{1}{2}s_{14} = 0$$\n$$s+t+u = 0$$\nThis is the well-known relation for massless $2 \\to 2$ scattering. It demonstrates that only two of the three Mandelstam variables are independent. For example, given $s$ and $t$, $u$ is fixed. Thus, for $n=4$, the minimal number of independent invariants is $2$.\n\n**Part 2: Generalization to $n$-Point Amplitudes**\n\nWe now derive the minimal number of independent Lorentz-invariant scalars needed to specify the kinematics for a generic $n$-point massless scattering process in $D=4$ dimensions. The number of such scalars is equal to the dimension of the moduli space of kinematic configurations. We can calculate this dimension by counting the total degrees of freedom and subtracting those removed by constraints and symmetries.\n\n1.  **Initial Degrees of Freedom**: We begin with $n$ four-vectors, $\\{p_1, \\dots, p_n\\}$. Each four-vector $p_i$ has $D=4$ components. Thus, the total number of initial variables is $n \\times D = 4n$.\n\n2.  **Constraints**: The system is subject to two types of physical constraints:\n    *   **On-shell Conditions**: Each particle is massless and on-shell, meaning its four-momentum squared is zero: $p_i^2 = 0$. This provides $n$ independent scalar equations.\n    *   **Momentum Conservation**: The total momentum is conserved: $\\sum_{i=1}^n p_i = 0$. This is a vector equation, providing $D=4$ independent scalar constraints.\n\n    The number of variables remaining after imposing these constraints is $4n - n - 4 = 3n - 4$.\n\n3.  **Symmetry Redundancy**: A physical scattering amplitude is independent of the observer's inertial reference frame. The kinematics are therefore defined only up to a global Lorentz transformation. The set of such transformations forms the Lorentz group, $SO(1, D-1)$. The number of parameters (or generators) of this group is $\\binom{D}{2}$. For $D=4$, the number of parameters is $\\binom{4}{2} = 6$ (three spatial rotations and three Lorentz boosts). These transformations do not change the Lorentz-invariant scalars, so the $3n-4$ variables we counted above are not independent invariants. We must subtract the number of parameters of the Lorentz group to find the dimension of the space of invariants.\n\n4.  **Minimal Number of Invariants**: The minimal number of independent Lorentz-invariant scalars is the number of kinematic variables minus the number of parameters of the Lorentz group:\n    $$N_{\\text{indep}} = (nD - n - D) - \\binom{D}{2}$$\n    Substituting $D=4$:\n    $$N_{\\text{indep}} = (4n - n - 4) - \\binom{4}{2} = (3n - 4) - 6 = 3n - 10$$\n    This formula is valid for $n \\ge 4$. For $n=4$, it correctly yields $3(4) - 10 = 2$. For $n=5$, it yields $3(5) - 10 = 5$.\n\n**Construction of an Explicit Minimal Set**\n\nThe problem requires the construction of an explicit minimal set of $3n-10$ independent invariants of the form $s_{ij} = 2 p_i \\cdot p_j$. The total number of such invariants is $\\binom{n}{2}$, which for $n>4$ is larger than $3n-10$. This implies the existence of non-trivial relations among the $s_{ij}$. These relations arise from two sources:\n1.  **Linear Constraints**: From momentum conservation, for any $i \\in \\{1, \\dots, n\\}$, we have $\\sum_{j \\neq i} s_{ij} = 2 p_i \\cdot \\sum_{j \\neq i} p_j = 2 p_i \\cdot (-p_i) = -2 p_i^2 = 0$. There are $n-1$ independent relations of this type.\n2.  **Non-linear Constraints**: The fact that the momenta exist in a $D=4$ dimensional spacetime imposes further non-linear constraints, known as Gram determinant conditions. For any set of $k>D$ vectors, the determinant of their Gram matrix (matrix of dot products) must vanish. Due to momentum conservation, the rank of the Gram matrix of all $n$ momenta is at most $D-1=3$. These conditions lead to complex polynomial relations among the $s_{ij}$.\n\nConstructing a basis requires a careful selection of $s_{ij}$ that avoids all such linear and non-linear dependencies. A valid construction for a minimal set of $3n-10$ independent invariants for generic kinematics (i.e., not restricted to a lower-dimensional subspace) for $n \\ge 4$ is as follows:\n$$ \\mathcal{B} = \\{s_{1,j} \\mid j=2, \\dots, n-2\\} \\cup \\{s_{2,j} \\mid j=3, \\dots, n-1\\} \\cup \\{s_{3,j} \\mid j=4, \\dots, n-1\\} $$\nLet's verify the size of this set. The number of elements is:\n$$ ( (n-2) - 2 + 1 ) + ( (n-1) - 3 + 1 ) + ( (n-1) - 4 + 1 ) = (n-3) + (n-3) + (n-4) = 3n-10 $$\nThe count is correct for $n \\ge 5$. For the edge case $n=4$, the set is $\\{s_{1,2}\\} \\cup \\{s_{2,3}\\} \\cup \\emptyset$, giving two invariants, $\\{s_{12}, s_{23}\\}$. This is a valid basis, as $s_{13}$ can be determined via the linear relations (e.g., $s_{13}=s_{24}$ and $s_{12}+s_{13}+s_{14}=0$).\n\nThe independence of this set for generic kinematics is non-trivial to prove formally but can be understood intuitively. The invariants involving $p_1, p_2, p_3$ serve to establish a \"reference frame\", and the remaining invariants position the other momenta $p_4, \\dots, p_{n-1}$ with respect to this frame ($p_n$ is then fixed by momentum conservation). The specific indices are chosen to avoid the simplest dependencies while spanning the full $3n-10$ dimensional space.\n\nThe final answer requested is the single closed-form expression for the minimal number of independent invariants as a function of $n$. Based on the counting of degrees of freedom, this number is $3n-10$.", "answer": "$$\\boxed{3n-10}$$", "id": "3505457"}, {"introduction": "With the kinematic framework established, we now turn to the heart of the task: calculating the matrix element, $\\mathcal{M}$. This practice problem uses a simplified \"toy\" theory to illustrate how an automated generator constructs the full amplitude from its constituent Feynman diagrams [@problem_id:3505480]. You will see how contributions from different scattering channels are combined and how the crucial quantum mechanical principle of symmetrization for identical particles is implemented in the final squared matrix element.", "problem": "Consider a toy scalar Quantum Field Theory (QFT) designed to mimic automated matrix element generation for the partonic process $gg \\to \\phi \\phi$, where $g$ and $\\phi$ are real scalar fields. The model includes two additional real scalar mediator fields $\\sigma$ and $\\chi$. The relevant interaction terms are\n$$\n\\mathcal{L}_{\\mathrm{int}} \\;=\\; -\\frac{1}{2}\\,\\kappa\\,\\sigma\\,g^{2} \\;-\\; \\frac{1}{2}\\,\\eta\\,\\sigma\\,\\phi^{2} \\;-\\; \\xi\\,\\chi\\,g\\,\\phi,\n$$\nwith real coupling constants $\\kappa$, $\\eta$, and $\\xi$, and masses $m_{\\sigma}$ and $m_{\\chi}$ for $\\sigma$ and $\\chi$, respectively. The external fields $g$ and $\\phi$ are taken to be massless. Work at tree level. The partonic Mandelstam invariants are defined conventionally by $s=(p_{1}+p_{2})^{2}$, $t=(p_{1}-k_{1})^{2}$, and $u=(p_{1}-k_{2})^{2}$, where $p_{1}$ and $p_{2}$ are the incoming $g$ four-momenta, and $k_{1}$ and $k_{2}$ are the outgoing $\\phi$ four-momenta. Because the final-state scalars are identical, both $t$- and $u$-channel diagrams contribute in addition to the $s$-channel.\n\nStarting from the Feynman rules implied by the interaction Lagrangian, derive the tree-level amplitude contributions for the $s$-, $t$-, and $u$-channel diagrams, and then demonstrate how identical final-state symmetrization is handled in matrix element squaring in a way consistent with automated generators. Assume all couplings are real and neglect widths, so the propagators are purely real. Define the “symmetrized squared matrix element” as the quantity in which the identical-particle factor $1/2!$ from the two-body phase space has been absorbed into the matrix element normalization, a convention used in some automated matrix element generators to avoid double counting in identical final-state phase-space integration.\n\nYour task is to produce a single closed-form analytic expression for the symmetrized squared matrix element $\\left| \\mathcal{M} \\right|^{2}_{\\mathrm{sym}}$ for $gg \\to \\phi \\phi$ at tree level in terms of $s$, $t$, $u$, $\\kappa$, $\\eta$, $\\xi$, $m_{\\sigma}$, and $m_{\\chi}$ under the assumptions stated. The final answer must be a single expression and must not include any units. If you introduce any additional symbols during your derivation, clearly define them. No numerical approximation or rounding is required.", "solution": "The problem is valid as it is scientifically grounded in Quantum Field Theory, well-posed, and objective. It represents a standard, albeit simplified, calculation in computational high-energy physics. We proceed with the solution.\n\nThe goal is to compute the tree-level symmetrized squared matrix element, $|\\mathcal{M}|_{\\mathrm{sym}}^2$, for the process $g(p_1)g(p_2) \\to \\phi(k_1)\\phi(k_2)$, where $g$ and $\\phi$ are massless real scalar fields. The process is mediated by the scalar fields $\\sigma$ and $\\chi$.\n\nFirst, we derive the Feynman rules from the given interaction Lagrangian:\n$$\n\\mathcal{L}_{\\mathrm{int}} \\;=\\; -\\frac{1}{2}\\,\\kappa\\,\\sigma\\,g^{2} \\;-\\; \\frac{1}{2}\\,\\eta\\,\\sigma\\,\\phi^{2} \\;-\\; \\xi\\,\\chi\\,g\\,\\phi\n$$\nThe vertex factor for an interaction is derived from the term $i\\mathcal{L}_{\\mathrm{int}}$. For vertices involving identical fields, a symmetry factor must be included, which is canceled by the explicit numerical factor in the Lagrangian.\n\\begin{itemize}\n    \\item The $\\sigma g g$ vertex, from the term $-\\frac{1}{2}\\kappa\\sigma g^2$, is $-i\\kappa$. The symmetry factor of $2!$ for the two identical $g$ fields is canceled by the $\\frac{1}{2}$ in the Lagrangian.\n    \\item The $\\sigma \\phi \\phi$ vertex, from $-\\frac{1}{2}\\eta\\sigma \\phi^2$, is $-i\\eta$.\n    \\item The $\\chi g \\phi$ vertex, from $-\\xi\\chi g \\phi$, is $-i\\xi$. There is no symmetry factor as the fields are distinct.\n\\end{itemize}\nThe propagators for the massive scalar mediators $\\sigma$ and $\\chi$ with four-momentum $q$ are given by:\n\\begin{itemize}\n    \\item $\\sigma$ propagator: $\\frac{i}{q^2 - m_{\\sigma}^2}$\n    \\item $\\chi$ propagator: $\\frac{i}{q^2 - m_{\\chi}^2}$\n\\end{itemize}\nThe problem states to neglect widths, so the $i\\epsilon$ term is omitted.\n\nAt tree level, three Feynman diagrams contribute to the process $gg \\to \\phi\\phi$: one $s$-channel diagram mediated by $\\sigma$, one $t$-channel diagram mediated by $\\chi$, and one $u$-channel diagram also mediated by $\\chi$. The $u$-channel diagram is necessary because the two final-state $\\phi$ particles are identical.\n\nThe Mandelstam variables are defined as $s=(p_{1}+p_{2})^{2}$, $t=(p_{1}-k_{1})^{2}$, and $u=(p_{1}-k_{2})^{2}$. Since the external particles are massless ($p_1^2=p_2^2=k_1^2=k_2^2=0$), we have the relation $s+t+u=0$.\n\nWe now calculate the invariant amplitude, denoted $\\mathcal{M}$, for each diagram. The total amplitude for a diagram is conventionally designated $i\\mathcal{M}_{\\text{diagram}}$.\n\n1.  **s-channel amplitude ($\\mathcal{M}_s$):**\n    The process is $gg \\to \\sigma^* \\to \\phi\\phi$. The four-momentum of the intermediate $\\sigma$ is $q_s = p_1 + p_2$, so $q_s^2 = s$.\n    $$\n    i\\mathcal{M}_s = (-i\\kappa) \\left( \\frac{i}{s - m_{\\sigma}^2} \\right) (-i\\eta) = -i \\frac{\\kappa\\eta}{s - m_{\\sigma}^2}\n    $$\n    Thus, the amplitude is:\n    $$\n    \\mathcal{M}_s = -\\frac{\\kappa\\eta}{s - m_{\\sigma}^2}\n    $$\n\n2.  **t-channel amplitude ($\\mathcal{M}_t$):**\n    This process involves the exchange of a $\\chi$ particle. The four-momentum of the intermediate $\\chi$ is $q_t = p_1 - k_1$, so $q_t^2 = t$.\n    $$\n    i\\mathcal{M}_t = (-i\\xi) \\left( \\frac{i}{t - m_{\\chi}^2} \\right) (-i\\xi) = -i \\frac{\\xi^2}{t - m_{\\chi}^2}\n    $$\n    Thus, the amplitude is:\n    $$\n    \\mathcal{M}_t = -\\frac{\\xi^2}{t - m_{\\chi}^2}\n    $$\n\n3.  **u-channel amplitude ($\\mathcal{M}_u$):**\n    This diagram is topologically equivalent to the $t$-channel diagram, but with the identical final-state particles interchanged ($k_1 \\leftrightarrow k_2$). The four-momentum of the intermediate $\\chi$ is $q_u = p_1 - k_2$, so $q_u^2 = u$.\n    $$\n    i\\mathcal{M}_u = (-i\\xi) \\left( \\frac{i}{u - m_{\\chi}^2} \\right) (-i\\xi) = -i \\frac{\\xi^2}{u - m_{\\chi}^2}\n    $$\n    Thus, the amplitude is:\n    $$\n    \\mathcal{M}_u = -\\frac{\\xi^2}{u - m_{\\chi}^2}\n    $$\n\nThe total amplitude $\\mathcal{M}_{\\text{total}}$ is the sum of the amplitudes for all contributing diagrams:\n$$\n\\mathcal{M}_{\\text{total}} = \\mathcal{M}_s + \\mathcal{M}_t + \\mathcal{M}_u = -\\left( \\frac{\\kappa\\eta}{s - m_{\\sigma}^2} + \\frac{\\xi^2}{t - m_{\\chi}^2} + \\frac{\\xi^2}{u - m_{\\chi}^2} \\right)\n$$\nSince all coupling constants are real and widths are neglected, the amplitude $\\mathcal{M}_{\\text{total}}$ is a real quantity. The squared matrix element is therefore $|\\mathcal{M}_{\\text{total}}|^2 = (\\mathcal{M}_{\\text{total}})^2$:\n$$\n|\\mathcal{M}_{\\text{total}}|^2 = \\left( \\frac{\\kappa\\eta}{s - m_{\\sigma}^2} + \\frac{\\xi^2}{t - m_{\\chi}^2} + \\frac{\\xi^2}{u - m_{\\chi}^2} \\right)^2\n$$\nThe problem defines the \"symmetrized squared matrix element\" $|\\mathcal{M}|_{\\mathrm{sym}}^2$ as the quantity where the identical final-state particle symmetry factor of $1/2!$ from the phase space is absorbed into the matrix element itself.\n$$\n|\\mathcal{M}|_{\\mathrm{sym}}^2 = \\frac{1}{2!} |\\mathcal{M}_{\\text{total}}|^2 = \\frac{1}{2} |\\mathcal{M}_{\\text{total}}|^2\n$$\nSubstituting the expression for $|\\mathcal{M}_{\\text{total}}|^2$, we obtain the final expression for the symmetrized squared matrix element:\n$$\n|\\mathcal{M}|_{\\mathrm{sym}}^2 = \\frac{1}{2} \\left( \\frac{\\kappa\\eta}{s - m_{\\sigma}^2} + \\frac{\\xi^2}{t - m_{\\chi}^2} + \\frac{\\xi^2}{u - m_{\\chi}^2} \\right)^2\n$$\nThis is the single closed-form analytic expression required. It is expressed solely in terms of the given parameters $s$, $t$, $u$, $\\kappa$, $\\eta$, $\\xi$, $m_{\\sigma}$, and $m_{\\chi}$.", "answer": "$$\n\\boxed{\\frac{1}{2} \\left( \\frac{\\kappa\\eta}{s - m_{\\sigma}^{2}} + \\frac{\\xi^{2}}{t - m_{\\chi}^{2}} + \\frac{\\xi^{2}}{u - m_{\\chi}^{2}} \\right)^{2}}\n$$", "id": "3505480"}, {"introduction": "As we move to more complex, realistic processes, the number of Feynman diagrams can become enormous. A key challenge in automation is to identify and compute only the unique topologies, avoiding redundant calculations for diagrams that are structurally identical but have different particle labelings. This exercise delves into the algorithmic core of this problem, tasking you with implementing a \"canonicalization\" routine based on graph isomorphism to efficiently manage large ensembles of diagrams [@problem_id:3505556].", "problem": "You are tasked with designing and validating a canonicalization module for tree-level Feynman diagram topologies in non-Abelian gauge theory, with a focus on automated matrix element generation. At tree level in Yang–Mills theory, pure-gluon diagrams can be represented by undirected trees where internal interaction vertices have degree $3$ (cubic representation) and external legs (gluons) correspond to degree-$1$ leaves. Two such trees represent the same diagram topology if and only if they are isomorphic as unlabeled graphs. The computational problem is to algorithmically identify and merge duplicates arising from graph isomorphism, which is a key step in automated matrix element generation to avoid redundant evaluation of identical topologies.\n\nStarting from the following foundational bases:\n\n- The definition of graph isomorphism: two undirected graphs $G = (V,E)$ and $G' = (V',E')$ are isomorphic if there exists a bijection $\\phi: V \\to V'$ such that for every unordered pair $\\{u,v\\} \\subset V$ one has $\\{u,v\\} \\in E$ if and only if $\\{\\phi(u),\\phi(v)\\} \\in E'$.\n- The concept of a tree: an undirected connected acyclic graph.\n- The combinatorial fact that a full binary rooted tree with $n$ leaves, when converted to an unrooted tree by suppressing the root (contracting its two incident edges into one), produces an unrooted tree whose internal vertices all have degree $3$ and whose leaves have degree $1$; this is a standard cubic representation of tree-level gluon diagrams.\n- The well-tested method for tree isomorphism via canonical forms using centers and rooted canonical encodings, where the center of a tree is obtained by iteratively removing leaves until one or two nodes remain.\n\nYour program must:\n\n1. Implement a canonicalization routine for undirected trees that returns a canonical string representative that is identical for isomorphic trees and distinct for non-isomorphic trees. The routine must:\n   - For an unrooted tree, find its center(s) by iteratively removing leaves.\n   - For a rooted tree, compute a canonical encoding recursively by collecting canonical encodings of subtrees, sorting them, and concatenating them with delimiters. The unrooted canonical form is chosen as the lexicographically minimal rooted canonical form taken over the center(s).\n2. Generate tree ensembles representing $n$-gluon tree topologies as follows:\n   - Enumerate all ordered full binary rooted trees with $n$ leaves by recursively splitting $n$ into $k$ and $n-k$ leaves for $k \\in \\{1,\\dots,n-1\\}$ and combining left and right subtrees. Then convert each to an unrooted cubic tree by suppressing the root (removing the root and connecting its two children by an edge), producing an undirected tree graph in which internal nodes have degree $3$ and leaves have degree $1$.\n   - Create ensembles with random node label permutations to simulate random labeling. For these, random bijections on node identifiers must be applied to generate isomorphic copies of the same topology.\n3. Use the canonicalization routine to compress each ensemble into unique topologies and report the number of distinct canonical representatives found.\n\nDesign choices must be derived from the definitions above and must not rely on any pre-baked graph isomorphism library. All graph manipulations should be explicit in your code.\n\nTest Suite and Required Output:\n\nImplement the following test cases, each producing an integer count of unique topologies across the described ensemble:\n- Case A (label-invariance validation): For $n = 7$, choose any single unrooted cubic tree generated by the enumeration described above, then generate $M = 50$ isomorphic copies by applying $50$ independent, uniformly random permutations of node identifiers. Compute the canonical form for each and count the number of unique canonical representatives. This should validate that isomorphic relabelings are merged. Use a fixed pseudorandom seed so the result is deterministic.\n- Case B (happy path enumeration): For $n = 6$, enumerate all ordered full binary rooted trees with $n$ leaves, convert each to an unrooted cubic tree, canonicalize, and count the number of unique representatives.\n- Case C (growing complexity): Same as Case B but for $n = 7$.\n- Case D (increased coverage): Same as Case B but for $n = 8$.\n- Case E (boundary case): Same as Case B but for $n = 3$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order [Case A, Case B, Case C, Case D, Case E], for example, \"[1,2,3,6,1]\". No physical units are involved, and no angles are involved. All outputs are integers.", "solution": "The posed problem concerns the canonicalization of tree-level Feynman diagram topologies in the context of automated matrix element generation for non-Abelian gauge theories, such as Yang-Mills theory. At tree level, pure-gluon scattering amplitudes are represented by a specific class of graphs: unrooted, undirected trees where all internal vertices have a degree of $3$ and external particles (gluons) correspond to leaves of degree $1$. The fundamental computational challenge is that many different labeled graphs, arising from the enumeration process, can correspond to the same underlying physical topology. Identifying and eliminating these duplicates is crucial for efficiency. This is precisely the graph isomorphism problem, applied to this specific family of trees.\n\nThe solution rests upon the principle of defining a canonical representation for each tree. A canonical form is a unique string or label for an entire isomorphism class of graphs. Two graphs are isomorphic if, and only if, their canonical forms are identical. The problem specifies a robust, standard algorithm for tree canonicalization that leverages the structural properties of trees, namely their center(s).\n\n**Theoretical and Algorithmic Framework**\n\n1.  **Graph Representation**: An undirected graph is represented using an adjacency list, specifically a dictionary where keys are integer vertex identifiers and values are lists of adjacent vertex identifiers.\n\n2.  **Topology Generation**: The initial set of candidate topologies is generated by enumerating all *ordered full binary rooted trees* with $n$ leaves. The number of such trees is the $(n-1)$-th Catalan number, $C_{n-1}$. This enumeration is performed recursively: to form a tree with $n$ leaves, we combine a left subtree with $k$ leaves and a right subtree with $n-k$ leaves, for all possible partitions where $k \\in \\{1, 2, \\dots, n-1\\}$. Each abstract tree structure is then realized as a concrete graph. A rooted graph with $n$ leaves and $n-1$ internal nodes is built, for a total of $2n-1$ vertices. This rooted tree is then converted to the required unrooted cubic tree representation by \"suppressing the root.\" This operation involves removing the root vertex and connecting its two children with a new edge. The resulting graph has $n$ leaves (degree $1$) and $n-2$ internal vertices (degree $3$), accurately modeling an $n$-gluon tree-level interaction.\n\n3.  **Canonicalization via Tree Centers**: The core of the solution is the canonical labeling algorithm, which proceeds in three steps:\n    a. **Finding the Center**: The center of an unrooted tree provides a unique structural reference point. It consists of either one vertex (a unicentered tree) or two adjacent vertices (a bicentered tree). The center is found by an iterative pruning algorithm: all vertices of degree $1$ (leaves) are removed. This process is repeated on the resulting smaller tree until only one or two vertices remain. These final vertices form the center.\n    b. **Rooted Canonical Form**: Once a tree is conceptually \"rooted\" at a vertex, its canonical form can be computed recursively. For a given node, the canonical forms of the subtrees hanging off its children are computed first. These resulting strings are then sorted lexicographically and concatenated, enclosed by delimiters (parentheses in this implementation) to form the canonical string for the node. A leaf, having no children, has a base canonical form, `()`. The recursive definition is:\n    $$\n    \\text{CanonicalForm}(\\text{node}) = \\text{\"(\"} + \\text{sorted\\_join}(\\{\\text{CanonicalForm}(\\text{child}_i)\\}) + \\text{\")\"}\n    $$\n    c. **Unrooted Canonical Form**: The canonical form for the original unrooted tree is determined by its center. It is defined as the lexicographically *minimal* rooted canonical form, where the candidates are generated by rooting the tree at each of its central vertices. If the center is a single vertex $c$, there is only one candidate form. If the center is a pair of vertices $\\{c_1, c_2\\}$, we compute the rooted canonical forms with respect to both $c_1$ and $c_2$ and choose the lexicographically smaller string. This procedure ensures a unique outcome for any given tree topology, regardless of initial vertex labeling.\n\n4.  **Test Suite and Verification**: The algorithm is validated against a specified test suite:\n    *   **Case A ($n=7$, label invariance)**: This case acts as a sanity check. A single tree topology is created, and $M=50$ isomorphic copies are generated by applying random permutations to its vertex labels. A correct canonicalization algorithm must map all these differently labeled but structurally identical graphs to the same canonical string. Thus, the number of unique representatives must be $1$.\n    *   **Cases B, C, D, E ($n=6, 7, 8, 3$)**: These cases test the full enumeration and canonicalization pipeline. For each $n$, all ordered binary trees are generated, converted to unrooted cubic trees, and canonicalized. The number of unique canonical forms found corresponds to the number of distinct unlabeled cubic trees with $n$ leaves. These quantities are known in combinatorics and provide a definitive verification of the algorithm's correctness. The expected counts for distinct tree topologies for $n=3, 6, 7, 8$ are $1, 2, 3, 6$ respectively.\n\nThe implementation encapsulates these principles into a set of functions that generate, manipulate, and canonicalize the tree graphs, ultimately computing the required counts for each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\nimport sys\n\n# It is necessary to increase the recursion limit for deeper tree structures\n# that can arise during generation, particularly for n=8.\nsys.setrecursionlimit(3000)\n\n_memo_generate_trees = {}\n\ndef generate_ordered_binary_trees(n):\n    \"\"\"\n    Recursively generates all ordered full binary trees with n leaves.\n    The trees are represented as nested tuples, where () is a leaf.\n    Uses memoization to avoid recomputing for the same n.\n    \"\"\"\n    if n in _memo_generate_trees:\n        return _memo_generate_trees[n]\n    if n == 1:\n        return [()]  # A leaf is represented by an empty tuple\n    \n    trees = []\n    for k in range(1, n):\n        left_subtrees = generate_ordered_binary_trees(k)\n        right_subtrees = generate_ordered_binary_trees(n - k)\n        for L in left_subtrees:\n            for R in right_subtrees:\n                trees.append((L, R))\n    \n    _memo_generate_trees[n] = trees\n    return trees\n\ndef build_graph_from_tuple(tree_tuple, n_leaves):\n    \"\"\"\n    Converts a nested tuple representation of a rooted binary tree\n    into an adjacency list graph representation.\n    Leaves are labeled 0 to n-1, internal nodes from n upwards.\n    Returns the adjacency list and the ID of the root node.\n    \"\"\"\n    adj = defaultdict(list)\n    leaf_counter = [0]\n    internal_counter = [n_leaves]\n\n    def _build(subtree):\n        # Base case: a leaf node\n        if not subtree:\n            node_id = leaf_counter[0]\n            leaf_counter[0] += 1\n            return node_id\n\n        # Recursive step: an internal node\n        node_id = internal_counter[0]\n        internal_counter[0] += 1\n        \n        left_id = _build(subtree[0])\n        right_id = _build(subtree[1])\n\n        adj[node_id].append(left_id)\n        adj[left_id].append(node_id)\n        adj[node_id].append(right_id)\n        adj[right_id].append(node_id)\n        \n        return node_id\n\n    root_id = _build(tree_tuple)\n    return dict(adj), root_id\n\ndef convert_to_unrooted(adj, root_id):\n    \"\"\"\n    Converts a rooted binary tree graph to an unrooted cubic tree by\n    suppressing the root: removing the root and connecting its two children.\n    \"\"\"\n    unrooted_adj = {k: list(v) for k, v in adj.items()}\n    \n    # A tree with n=2 leaves becomes a single edge between the leaves.\n    if len(adj) == 3 and n_leaves_from_adj(adj) == 2:\n        leaves = [k for k, v in adj.items() if len(v) == 1]\n        l1, l2 = leaves\n        return {l1: [l2], l2: [l1]}\n\n    if root_id not in unrooted_adj or len(unrooted_adj[root_id]) != 2:\n         # This block handles simple cases or malformed inputs gracefully.\n         # For n=3+, the root will always have 2 children in our generation scheme.\n         return unrooted_adj\n\n    c1, c2 = unrooted_adj[root_id]\n    \n    del unrooted_adj[root_id]\n    \n    unrooted_adj[c1].remove(root_id)\n    unrooted_adj[c2].remove(root_id)\n    \n    unrooted_adj[c1].append(c2)\n    unrooted_adj[c2].append(c1)\n    \n    return unrooted_adj\n\ndef find_center(adj):\n    \"\"\"\n    Finds the center(s) of a tree by iteratively removing leaves.\n    Returns a list containing one or two central node IDs.\n    \"\"\"\n    if not adj:\n        return []\n    if len(adj) <= 2:\n        return list(adj.keys())\n\n    nodes = set(adj.keys())\n    degrees = {node: len(neighbors) for node, neighbors in adj.items()}\n    \n    leaves = [node for node, deg in degrees.items() if deg == 1]\n    \n    count = len(leaves)\n    while len(nodes) - count > 0:\n        new_leaves = []\n        for leaf in leaves:\n            for neighbor in adj[leaf]:\n                degrees[neighbor] -= 1\n                if degrees[neighbor] == 1:\n                    new_leaves.append(neighbor)\n        count += len(new_leaves)\n        if not new_leaves:\n            break\n        leaves = new_leaves\n        \n    return leaves\n\ndef _rooted_canonical_form(adj, root, parent):\n    \"\"\"\n    Recursively computes the canonical string for a tree rooted at `root`.\n    `parent` is used to prevent traversing backwards.\n    \"\"\"\n    children = [n for n in adj.get(root, []) if n != parent]\n    if not children:\n        return \"()\"\n    \n    child_forms = []\n    for child in children:\n        child_forms.append(_rooted_canonical_form(adj, child, root))\n    \n    child_forms.sort()\n    return \"(\" + \"\".join(child_forms) + \")\"\n\ndef get_canonical_form(adj):\n    \"\"\"\n    Computes the canonical form of an unrooted tree by finding its center(s)\n    and choosing the lexicographically minimal rooted representation.\n    \"\"\"\n    if not adj: return \"\"\n    if len(adj) == 1: return \"()\"\n\n    centers = find_center(adj)\n    \n    candidate_forms = []\n    for c in centers:\n        # parent is set to a value guaranteed not to be a node ID\n        candidate_forms.append(_rooted_canonical_form(adj, c, -1))\n        \n    return min(candidate_forms)\n\ndef n_leaves_from_adj(adj):\n    \"\"\"Helper to count leaves (degree-1 nodes) in a graph.\"\"\"\n    return sum(1 for node in adj if len(adj[node]) == 1)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases_params = [\n        {'type': 'A', 'n': 7, 'M': 50},\n        {'type': 'B', 'n': 6},\n        {'type': 'C', 'n': 7},\n        {'type': 'D', 'n': 8},\n        {'type': 'E', 'n': 3},\n    ]\n\n    results = []\n    \n    # Pre-clear memoization for clean runs if solve() were called multiple times\n    _memo_generate_trees.clear()\n\n    for case in test_cases_params:\n        n = case['n']\n        \n        if case['type'] == 'A':\n            # Case A: Validate canonicalization on isomorphic graphs\n            canonical_forms = set()\n            # Generate a single representative tree for n=7\n            # We pick the first one generated for simplicity.\n            first_tree_tuple = generate_ordered_binary_trees(n)[0]\n            base_adj, root_id = build_graph_from_tuple(first_tree_tuple, n)\n            base_unrooted_adj = convert_to_unrooted(base_adj, root_id)\n            \n            canonical_forms.add(get_canonical_form(base_unrooted_adj))\n            \n            # Generate M isomorphic copies by permuting node labels\n            nodes = sorted(list(base_unrooted_adj.keys()))\n            num_nodes = len(nodes)\n            rng = np.random.default_rng(seed=42) # for deterministic result\n            \n            for _ in range(case['M']):\n                perm = rng.permutation(nodes)\n                mapping = {old: new for old, new in zip(nodes, perm)}\n                \n                permuted_adj = defaultdict(list)\n                for u, neighbors in base_unrooted_adj.items():\n                    new_u = mapping[u]\n                    for v in neighbors:\n                        new_v = mapping[v]\n                        permuted_adj[new_u].append(new_v)\n                \n                canonical_forms.add(get_canonical_form(dict(permuted_adj)))\n\n            results.append(len(canonical_forms))\n\n        else:\n            # Cases B, C, D, E: Enumerate and count unique topologies\n            ordered_trees = generate_ordered_binary_trees(n)\n            canonical_forms = set()\n\n            for tree_tuple in ordered_trees:\n                adj, root_id = build_graph_from_tuple(tree_tuple, n)\n                unrooted_adj = convert_to_unrooted(adj, root_id)\n                form = get_canonical_form(unrooted_adj)\n                canonical_forms.add(form)\n\n            results.append(len(canonical_forms))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3505556"}]}