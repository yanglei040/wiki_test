{"hands_on_practices": [{"introduction": "Before writing a single line of a complex hydrodynamic solver, one must master the rules that govern its stability. This first practice focuses on the Courant-Friedrichs-Lewy (CFL) condition, a cornerstone of numerical methods for hyperbolic equations. You will derive and apply this stability constraint in the context of Milne coordinates [@problem_id:3516494], which are essential for describing the boost-invariant expansion of the quark-gluon plasma, learning how to correctly handle the effects of a curvilinear, time-dependent metric on the maximum permissible timestep.", "problem": "Consider an explicit finite-volume solver for relativistic ideal hydrodynamics used in heavy-ion collision simulations that couples a background fluid to localized energy-momentum deposition from jets (jet quenching) via source terms. The fluid obeys conservation of energy-momentum, expressed as $\\partial_{\\mu} T^{\\mu \\nu} = J^{\\nu}$, where $T^{\\mu \\nu} = (\\varepsilon + p) u^{\\mu} u^{\\nu} - p g^{\\mu \\nu}$ for an ideal fluid and $J^{\\nu}$ encodes jet energy-momentum deposition. The evolution is performed in Milne coordinates $(\\tau, x, y, \\eta_{s})$, suitable for near boost-invariant longitudinal expansion in heavy-ion collisions, with metric $\\mathrm{diag}(+1,-1,-1,-\\tau^{2})$. In these curvilinear coordinates, proper spatial distances at fixed $\\tau$ are $|dx|$, $|dy|$, and $\\tau |d\\eta_{s}|$ along $x$, $y$, and $\\eta_{s}$, respectively.\n\nA necessary condition for stability of an explicit scheme is the Courant–Friedrichs–Lewy (CFL) criterion, which requires that within one time step the fastest signal along any coordinate direction must not traverse more than one cell in that direction, when measured against the proper spatial scale of the grid cell. In a local orthonormal frame, the fastest signal relative to the fluid is bounded by the speed of sound $c_{s}$, and the fastest laboratory-frame signal along a given direction is bounded above by the sum of the fluid speed component magnitude and $c_{s}$ along that direction. In curvilinear coordinates, the coordinate speed along directions with nontrivial metric scale factors must be converted using the appropriate proper-to-coordinate length relation.\n\nAssume the equation of state is approximately conformal so that $c_{s} = \\sqrt{1/3}$ in natural units (set the speed of light $c = 1$), and the local three-velocity components (in the local orthonormal frame aligned with $(x,y,\\eta_{s})$) at a given grid point are $v_{x} = 0.40$, $v_{y} = 0.30$, and $v_{\\eta} = 0.05$. At a hydrodynamic time $\\tau = 3.0$ fm/$c$, the mesh spacings are $\\Delta x = 0.06$ fm, $\\Delta y = 0.08$ fm, and $\\Delta \\eta_{s} = 0.02$. The explicit time integrator uses a Courant number $C = 0.50$.\n\nStarting from the above principles, derive the CFL stability condition appropriate to Milne coordinates and compute the maximum allowable time step $\\Delta \\tau_{\\max}$ at this grid point. Round your answer to four significant figures and express $\\Delta \\tau_{\\max}$ in femtometer per speed of light (fm/$c$).", "solution": "The problem asks for the derivation of the Courant–Friedrichs–Lewy (CFL) stability condition for a relativistic hydrodynamic simulation in Milne coordinates and the calculation of the maximum allowable time step $\\Delta \\tau_{\\max}$ at a specific grid point.\n\nThe validation process confirms that the problem is scientifically grounded, well-posed, objective, and internally consistent. All necessary physical principles and numerical data are provided. The context is a standard scenario in computational high-energy physics. Thus, the problem is valid, and a solution can be formulated.\n\nThe CFL condition is a necessary condition for the stability of explicit numerical schemes for solving partial differential equations. It states that the numerical domain of dependence of a grid point must contain the physical domain of dependence. For an explicit time-stepping scheme, this implies that within a single time step $\\Delta t$, the fastest propagating signal must not travel further than one grid cell. This can be expressed for each spatial dimension $i$ as:\n$$ \\Delta t \\le C \\frac{\\Delta L_i}{v_{\\text{sig}, i}} $$\nwhere $\\Delta L_i$ is the proper physical size of the grid cell in direction $i$, $v_{\\text{sig}, i}$ is the maximum proper speed of any signal in that direction, and $C$ is the Courant number, a safety factor typically less than or equal to $1$. The overall maximum time step is limited by the most restrictive of these conditions:\n$$ \\Delta t_{\\max} = C \\cdot \\min_{i} \\left( \\frac{\\Delta L_i}{v_{\\text{sig}, i}} \\right) $$\n\nIn this problem, the time coordinate is the proper time $\\tau$, so we are seeking $\\Delta \\tau_{\\max}$. The spatial coordinates are $(x, y, \\eta_{s})$, which are curvilinear. The relationship between coordinate intervals and proper spatial distances is given by the spacetime metric, $g_{\\mu\\nu} = \\mathrm{diag}(+1, -1, -1, -\\tau^2)$. The invariant line element is $ds^2 = g_{\\mu\\nu} dx^{\\mu} dx^{\\nu}$. At a fixed time $\\tau$ (i.e., $d\\tau = 0$), the square of a proper spatial distance element $dL$ is:\n$$ dL^2 = -ds^2 = dx^2 + dy^2 + \\tau^2 d\\eta_s^2 $$\nFrom this, we identify the proper length of the grid cells along each coordinate axis, given the coordinate grid spacings $\\Delta x$, $\\Delta y$, and $\\Delta \\eta_s$:\n\\begin{itemize}\n    \\item Along the $x$-axis: $\\Delta L_x = \\Delta x$\n    \\item Along the $y$-axis: $\\Delta L_y = \\Delta y$\n    \\item Along the $\\eta_s$-axis: $\\Delta L_{\\eta} = \\tau \\Delta \\eta_s$\n\\end{itemize}\n\nNext, we establish the maximum signal propagation speeds. The problem specifies that in a local orthonormal frame, the fastest signal speed along a direction $i$ is the sum of the magnitude of the fluid velocity component $|v_i|$ and the speed of sound $c_s$. These are the proper speeds, corresponding to propagation over proper distances.\n\\begin{itemize}\n    \\item Signal speed in $x$ direction: $v_{\\text{sig}, x} = |v_x| + c_s$\n    \\item Signal speed in $y$ direction: $v_{\\text{sig}, y} = |v_y| + c_s$\n    \\item Signal speed in $\\eta$ direction: $v_{\\text{sig}, \\eta} = |v_{\\eta}| + c_s$\n\\end{itemize}\nThe speed of light is set to $c=1$.\n\nCombining these elements, the CFL condition for the maximum time step $\\Delta \\tau_{\\max}$ becomes:\n$$ \\Delta \\tau_{\\max} = C \\cdot \\min \\left( \\frac{\\Delta L_x}{v_{\\text{sig}, x}}, \\frac{\\Delta L_y}{v_{\\text{sig}, y}}, \\frac{\\Delta L_{\\eta}}{v_{\\text{sig}, \\eta}} \\right) $$\nSubstituting the expressions for proper lengths and signal speeds:\n$$ \\Delta \\tau_{\\max} = C \\cdot \\min \\left( \\frac{\\Delta x}{|v_x| + c_s}, \\frac{\\Delta y}{|v_y| + c_s}, \\frac{\\tau \\Delta \\eta_s}{|v_{\\eta}| + c_s} \\right) $$\n\nWe now substitute the numerical values provided in the problem statement:\n\\begin{itemize}\n    \\item Courant number: $C = 0.50$\n    \\item Speed of sound: $c_s = \\sqrt{1/3}$\n    \\item Fluid velocity components: $v_x = 0.40$, $v_y = 0.30$, $v_{\\eta} = 0.05$\n    \\item Hydrodynamic time: $\\tau = 3.0$ fm/$c$\n    \\item Mesh spacings: $\\Delta x = 0.06$ fm, $\\Delta y = 0.08$ fm, $\\Delta \\eta_s = 0.02$\n\\end{itemize}\n\nFirst, we calculate the three time-scale limits corresponding to each spatial direction:\n1.  For the $x$-direction:\n    $$ \\frac{\\Delta x}{|v_x| + c_s} = \\frac{0.06}{|0.40| + \\sqrt{1/3}} = \\frac{0.06}{0.40 + \\sqrt{1/3}} \\text{ fm}/c $$\n2.  For the $y$-direction:\n    $$ \\frac{\\Delta y}{|v_y| + c_s} = \\frac{0.08}{|0.30| + \\sqrt{1/3}} = \\frac{0.08}{0.30 + \\sqrt{1/3}} \\text{ fm}/c $$\n3.  For the $\\eta_s$-direction:\n    $$ \\frac{\\tau \\Delta \\eta_s}{|v_{\\eta}| + c_s} = \\frac{(3.0)(0.02)}{|0.05| + \\sqrt{1/3}} = \\frac{0.06}{0.05 + \\sqrt{1/3}} \\text{ fm}/c $$\n\nNow, we evaluate these expressions numerically. We use the value $c_s = \\sqrt{1/3} \\approx 0.57735$.\n1.  $x$-direction limit:\n    $$ \\frac{0.06}{0.40 + 0.57735} = \\frac{0.06}{0.97735} \\approx 0.061395 \\text{ fm}/c $$\n2.  $y$-direction limit:\n    $$ \\frac{0.08}{0.30 + 0.57735} = \\frac{0.08}{0.87735} \\approx 0.091184 \\text{ fm}/c $$\n3.  $\\eta_s$-direction limit:\n    $$ \\frac{0.06}{0.05 + 0.57735} = \\frac{0.06}{0.62735} \\approx 0.095640 \\text{ fm}/c $$\n\nThe minimum of these three values determines the overall time step constraint:\n$$ \\min(0.061395, 0.091184, 0.095640) = 0.061395 \\text{ fm}/c $$\nThis most restrictive condition comes from the $x$-direction.\n\nFinally, we apply the Courant number $C = 0.50$ to find the maximum allowed time step $\\Delta \\tau_{\\max}$:\n$$ \\Delta \\tau_{\\max} = C \\cdot \\min(\\dots) = 0.50 \\times 0.061395 \\text{ fm}/c \\approx 0.0306975 \\text{ fm}/c $$\n\nThe problem requires the answer to be rounded to four significant figures. The first four significant figures are $3, 0, 6, 9$. The next digit is $7$, so we round up the last significant digit.\n$$ \\Delta \\tau_{\\max} \\approx 0.03070 \\text{ fm}/c $$\nThe trailing zero is significant.", "answer": "$$\\boxed{0.03070}$$", "id": "3516494"}, {"introduction": "With the principles of numerical stability established, we now turn to constructing the core engine of our simulation: a 2D relativistic hydrodynamic solver. This comprehensive exercise [@problem_id:3516450] challenges you to implement a modern, high-resolution shock-capturing scheme from first principles, tailored to the Milne coordinate system. By building a working solver for a canonical blast-wave problem, you will gain invaluable hands-on experience with the entire computational workflow, from discretizing the covariant conservation laws to managing the crucial conversion between conserved and primitive variables.", "problem": "Implement a complete, runnable program that numerically solves the ideal relativistic hydrodynamics equations for a conformal fluid in Milne coordinates using a Kurganov–Tadmor central scheme with total variation diminishing (TVD) limiters, and tests positivity preservation of the energy density and pressure in a transverse two-dimensional ($2$D) blast-wave problem. The implementation must start from the covariant conservation of the energy–momentum tensor and use an equation of state appropriate to conformal matter, with the coordinate system chosen to reflect the longitudinal boost invariance relevant to ultrarelativistic heavy-ion collisions. The algorithm must be designed from first principles and must not assume any pre-packaged fluid solver. The required numerical outputs are binary indicators of whether the computed fields remain non-negative under each test configuration.\n\nPhysical and mathematical model:\n- Use the covariant conservation law $\\nabla_{\\mu} T^{\\mu \\nu} = 0$ as the fundamental starting point, where the ideal fluid energy–momentum tensor is $T^{\\mu \\nu} = (\\epsilon + p)\\, u^{\\mu} u^{\\nu} - p\\, g^{\\mu \\nu}$ with energy density $\\epsilon$, pressure $p$, and fluid four-velocity $u^{\\mu}$. Work in Milne coordinates $(\\tau, x, y, \\eta)$ with metric $g_{\\mu \\nu} = \\mathrm{diag}(1, -1, -1, -\\tau^{2})$, assume longitudinal boost invariance (no dependence on spatial rapidity $\\eta$) and $u^{\\eta} = 0$. The equation of state is conformal: $p = c_{s}^{2}\\, \\epsilon$ with $c_{s}^{2} = 1/3$.\n- Starting from the conservation law and the Milne metric, reduce the system to a conservative form for the transverse plane with proper time $\\tau$ as the evolution variable. Denote $Q^{\\nu} = T^{\\tau \\nu}$ with $\\nu \\in \\{\\tau, x, y\\}$. Show that the equations can be written in the form\n$$\n\\partial_{\\tau} \\left( \\tau\\, Q^{\\nu} \\right) + \\partial_{x} \\left( \\tau\\, T^{x \\nu} \\right) + \\partial_{y} \\left( \\tau\\, T^{y \\nu} \\right) = S^{\\nu}(\\tau, \\mathbf{x}),\n$$\nwhere $S^{\\tau} = -p$ and $S^{x} = S^{y} = 0$, consistently derived from $\\nabla_{\\mu} T^{\\mu \\nu} = 0$ using the non-vanishing Christoffel symbols of the Milne metric. This establishes the conservative variables $\\tau\\, Q^{\\nu}$ and their geometric source terms.\n\nNumerical algorithm requirements:\n- Implement a Kurganov–Tadmor central-upwind scheme in the transverse directions with TVD slope limiting (e.g., minmod family) to achieve second-order accuracy in space while controlling spurious oscillations near strong gradients. Use a two-stage Strong Stability Preserving Runge–Kutta (SSP-RK$2$) time integrator for the semi-discrete system.\n- Reconstruct left and right states at each face using limited slopes applied to primitive variables $(\\epsilon, v_{x}, v_{y})$, where $v_{i}$ are the spatial components of the three-velocity and $u^{\\mu} = \\gamma \\, (1, v_{x}, v_{y}, 0)$ with $\\gamma = 1/\\sqrt{1 - v^{2}}$ and $v^{2} = v_{x}^{2} + v_{y}^{2}$. Compute fluxes $T^{i \\nu}$ from the reconstructed primitives and use them in the central scheme.\n- Determine local one-dimensional signal speeds in direction $n \\in \\{x,y\\}$ from the relativistic velocity addition rule as\n$$\n\\lambda_{\\pm} = \\frac{v_{n} \\pm c_{s}}{1 \\pm v_{n}\\, c_{s}},\n$$\nwhere $c_{s} = \\sqrt{c_{s}^{2}}$. Use these to set the central-upwind flux’s one-sided speeds $a^{+} = \\max(0, \\lambda_{+}^{L}, \\lambda_{+}^{R})$ and $a^{-} = \\min(0, \\lambda_{-}^{L}, \\lambda_{-}^{R})$ at each face.\n- At each stage, recover primitive variables from the conservative ones by inverting the ideal-fluid relations for $T^{\\mu \\nu}$ under the conformal equation of state. This inversion must be derived from first principles using the definitions of $T^{\\mu \\nu}$ and the relation $p = c_{s}^{2}\\, \\epsilon$, and it must ensure $v^{2}  1$. Adopt a robust method that handles strong gradients.\n- Use an explicit Courant–Friedrichs–Lewy (CFL) condition based on the maximum local signal speeds to choose the time step $\\Delta \\tau$. The underlying spatial discretization is uniform with grid spacings $\\Delta x$ and $\\Delta y$.\n- Boundary conditions: adopt transmissive (zero-gradient) outflow conditions at the transverse boundaries.\n\nBlast-wave initial condition:\n- Consider a blast-wave initial condition in the transverse plane at proper time $\\tau_{0}$ in which the energy density is centrally peaked and the initial transverse flow vanishes. Use a smooth radial profile to avoid non-physical oscillations. Specifically, with radius $r = \\sqrt{x^{2} + y^{2}}$, initialize\n$$\n\\epsilon(\\tau_{0}, x, y) = \\epsilon_{\\mathrm{out}} + \\left(\\epsilon_{\\mathrm{in}} - \\epsilon_{\\mathrm{out}}\\right) \\exp \\left( -\\frac{r^{2}}{2 \\sigma^{2}} \\right),\n$$\nwith $\\sigma = r_{0} / 2$, initial $v_{x}(\\tau_{0}, x, y) = 0$, and initial $v_{y}(\\tau_{0}, x, y) = 0$. Set $p(\\tau_{0}, x, y) = c_{s}^{2}\\, \\epsilon(\\tau_{0}, x, y)$.\n- Adopt natural units where $\\hbar = c = k_{B} = 1$, so all quantities are dimensionless, and no explicit physical units are required in the output.\n\nComputational domain and discretization:\n- Transverse domain: $x, y \\in [-L, L]$ with $L$ specified per test.\n- Uniform grid with $N_{x} \\times N_{y}$ cells. Use $N_{x} = N_{y} = 40$. Grid spacings are $\\Delta x = 2L/N_{x}$ and $\\Delta y = 2L/N_{y}$.\n- Evolve from $\\tau_{0}$ to $\\tau_{f}$ with a constant equation of state parameter $c_{s}^{2} = 1/3$.\n\nTest suite:\n- Implement the solver and run it for the following three parameter sets. In each, $N_{x} = N_{y} = 40$, $c_{s}^{2} = 1/3$, initial transverse velocities are zero, reconstruction limiter parameter $\\theta = 1.8$, Courant factor $\\mathrm{CFL} = 0.4$, transmissive boundaries, and SSP-RK$2$ is used.\n    1. Case A (happy path): $L = 6.0$, $\\tau_{0} = 0.6$, $\\tau_{f} = 1.0$, $\\epsilon_{\\mathrm{in}} = 10.0$, $\\epsilon_{\\mathrm{out}} = 1.0$, $r_{0} = 1.5$.\n    2. Case B (low exterior energy, stronger gradient): $L = 6.0$, $\\tau_{0} = 0.6$, $\\tau_{f} = 1.0$, $\\epsilon_{\\mathrm{in}} = 8.0$, $\\epsilon_{\\mathrm{out}} = 0.2$, $r_{0} = 1.0$.\n    3. Case C (narrow hot spot): $L = 6.0$, $\\tau_{0} = 0.6$, $\\tau_{f} = 1.0$, $\\epsilon_{\\mathrm{in}} = 12.0$, $\\epsilon_{\\mathrm{out}} = 0.5$, $r_{0} = 0.8$.\n- For each case, after evolving to $\\tau_{f}$, compute the minimum values of $\\epsilon$ and $p$ over all grid cells. Define a positivity indicator $\\Pi$ that equals $1$ if both $\\min \\epsilon \\ge 0$ and $\\min p \\ge 0$, and equals $0$ otherwise.\n\nFinal output format:\n- Your program should produce a single line of output containing the three positivity indicators for the test cases as a comma-separated list enclosed in square brackets. For example: \"[1,1,1]\".\n- The program must not require any user input and must not read or write any external files. It must run to completion under the specified execution environment.\n\nNotes:\n- Your derivation must start from $\\nabla_{\\mu} T^{\\mu \\nu} = 0$ and the definition of $T^{\\mu \\nu}$, and may use well-tested relations such as the relativistic signal speeds for a barotropic ideal fluid. Avoid invoking pre-derived discretization shortcuts in the problem statement; the full algorithmic pathway must be made explicit in your implementation and in the solution discussion.", "solution": "The user-provided problem is a valid, well-posed, and scientifically grounded task in computational high-energy physics. It requires the implementation of a numerical solver for the equations of ideal relativistic hydrodynamics in a specific coordinate system relevant to heavy-ion collisions. The problem specifies the physical model, governing equations, numerical methods, initial and boundary conditions, and test parameters with complete clarity. All terms are formally defined, and the required output is objective and verifiable. The solution proceeds as follows.\n\n### 1. Derivation of the Equations of Motion\n\nThe fundamental equation is the covariant conservation of the energy-momentum tensor, $\\nabla_{\\mu} T^{\\mu \\nu} = 0$. For a general coordinate system, this can be written as:\n$$\n\\frac{1}{\\sqrt{-g}} \\partial_{\\mu} (\\sqrt{-g} T^{\\mu \\nu}) + \\Gamma^{\\nu}_{\\sigma \\rho} T^{\\sigma \\rho} = 0\n$$\nwhere $\\Gamma^{\\nu}_{\\sigma \\rho}$ are the Christoffel symbols and $g$ is the determinant of the metric tensor $g_{\\mu \\nu}$.\n\nFor the metric specified in the problem, $g_{\\mu \\nu} = \\mathrm{diag}(1, -1, -1, -\\tau^2)$, the determinant is $g = (1)(-1)(-1)(-\\tau^2) = -\\tau^2$, so $\\sqrt{-g} = \\tau$. The non-vanishing Christoffel symbols for this metric are $\\Gamma^{\\tau}_{\\eta\\eta} = \\tau$ and $\\Gamma^{\\eta}_{\\tau\\eta} = \\Gamma^{\\eta}_{\\eta\\tau} = 1/\\tau$.\n\nSubstituting $\\sqrt{-g} = \\tau$ into the conservation law and multiplying by $\\tau$ is not quite right; we start from the covariant derivative form. Expanding it and assuming boost invariance ($\\partial_\\eta = 0$) gives:\n$$\n\\partial_{\\tau} (\\tau T^{\\tau \\nu}) + \\partial_{x} (\\tau T^{x \\nu}) + \\partial_{y} (\\tau T^{y \\nu}) = -\\tau \\Gamma^{\\nu}_{\\sigma \\rho} T^{\\sigma \\rho}\n$$\nThis matches the required conservative form $\\partial_{\\tau} \\left( \\tau\\, Q^{\\nu} \\right) + \\partial_{x} \\left( \\tau\\, T^{x \\nu} \\right) + \\partial_{y} \\left( \\tau\\, T^{y \\nu} \\right) = S^{\\nu}$, with conserved variables $U^{\\nu} = \\tau Q^{\\nu} = \\tau T^{\\tau \\nu}$ and source term $S^{\\nu} = -\\tau \\Gamma^{\\nu}_{\\sigma \\rho} T^{\\sigma \\rho}$.\n\nWe now compute the source terms for $\\nu \\in \\{\\tau, x, y\\}$.\n*   For $\\nu=x$ and $\\nu=y$, the Christoffel symbols $\\Gamma^{x}_{\\sigma\\rho}$ and $\\Gamma^{y}_{\\sigma\\rho}$ are all zero. Thus, $S^{x} = 0$ and $S^{y} = 0$.\n*   For $\\nu=\\tau$, the only non-zero Christoffel symbol is $\\Gamma^{\\tau}_{\\eta\\eta} = \\tau$. The source term is $S^{\\tau} = -\\tau \\Gamma^{\\tau}_{\\eta\\eta} T^{\\eta\\eta} = -\\tau^2 T^{\\eta\\eta}$.\n\nThe energy-momentum tensor is $T^{\\mu \\nu} = (\\epsilon + p) u^{\\mu} u^{\\nu} - p g^{\\mu \\nu}$. The inverse metric is $g^{\\mu \\nu} = \\mathrm{diag}(1, -1, -1, -1/\\tau^2)$. With the condition $u^\\eta=0$, the $T^{\\eta\\eta}$ component is:\n$$\nT^{\\eta\\eta} = (\\epsilon + p) (u^{\\eta})^2 - p g^{\\eta\\eta} = 0 - p (-1/\\tau^2) = p/\\tau^2\n$$\nSubstituting this into the expression for $S^{\\tau}$:\n$$\nS^{\\tau} = -\\tau^2 (p/\\tau^2) = -p\n$$\nThis confirms the source terms given in the problem statement: $S^{\\tau} = -p$ and $S^{x} = S^{y} = 0$. The term $S^{\\tau}=-p$ represents the work done by pressure due to the longitudinal expansion of the system, causing the total energy in a transverse slice to decrease over time.\n\n### 2. State Vectors and Conversions\n\nThe numerical simulation evolves a vector of conserved variables $\\mathbf{U} = (\\tau T^{\\tau\\tau}, \\tau T^{\\tau x}, \\tau T^{\\tau y})^T$. However, reconstruction and flux calculations are most naturally performed using primitive variables $\\mathbf{V} = (\\epsilon, v_x, v_y)^T$. Therefore, robust conversion routines between these two representations are essential.\n\n**Primitive-to-Conserved:** Given $\\mathbf{V} = (\\epsilon, v_x, v_y)^T$, we use the conformal EoS $p = c_s^2 \\epsilon$ with $c_s^2=1/3$. The Lorentz factor is $\\gamma = (1-v_x^2-v_y^2)^{-1/2}$. The components of the energy-momentum tensor are:\n$$\nT^{\\tau\\tau} = (\\epsilon + p)\\gamma^2 - p = \\epsilon(1+c_s^2)\\gamma^2 - c_s^2\\epsilon \\\\\nT^{\\tau x} = (\\epsilon + p)\\gamma^2 v_x = \\epsilon(1+c_s^2)\\gamma^2 v_x \\\\\nT^{\\tau y} = (\\epsilon + p)\\gamma^2 v_y = \\epsilon(1+c_s^2)\\gamma^2 v_y\n$$\nThe conserved variables are then $U^{\\nu} = \\tau T^{\\tau\\nu}$.\n\n**Conserved-to-Primitive:** This inversion is more complex. Let $S_{\\tau} = U_0/\\tau = T^{\\tau\\tau}$ and $M_{i} = U_{i}/\\tau = T^{\\tau i}$. Let $M^2=M_x^2+M_y^2$. From these definitions, one can derive a quadratic equation for $\\epsilon$. For the specific case of a conformal EoS with $c_s^2=1/3$, this equation is:\n$$\n\\epsilon^2 + 2S_{\\tau}\\epsilon - 3(S_{\\tau}^2 - M^2) = 0\n$$\nSolving for the physical root ($\\epsilon > 0$), we obtain:\n$$\n\\epsilon = -S_{\\tau} + \\sqrt{4S_{\\tau}^2 - 3M^2}\n$$\nThis requires the argument of the square root to be non-negative. Once $\\epsilon$ is found, pressure is $p=c_s^2 \\epsilon$. The velocities are then recovered from:\n$$\nv_x = \\frac{M_x}{S_{\\tau} + p}, \\quad v_y = \\frac{M_y}{S_{\\tau} + p}\n$$\nA robust implementation must handle potential numerical issues, such as the square root argument becoming negative or the resulting velocity squared $v^2$ exceeding $1$.\n\n### 3. Numerical Algorithm\n\nThe solver is implemented using a finite-volume method. The domain is divided into cells, and the evolution equation is integrated over each cell.\n\n**Spatial Discretization:** The Kurganov-Tadmor (KT) central-upwind scheme is used to compute numerical fluxes at cell interfaces. This scheme is well-suited for hyperbolic conservation laws as it properly incorporates signal propagation speeds to ensure stability. The numerical flux $\\hat{\\mathbf{F}}$ between a left (L) and right (R) state is:\n$$\n\\hat{\\mathbf{F}} = \\frac{a^+ \\mathbf{F}(\\mathbf{V}_R) - a^- \\mathbf{F}(\\mathbf{V}_L)}{a^+ - a^-} + \\frac{a^+ a^-}{a^+ - a^-} (\\mathbf{U}_R - \\mathbf{U}_L)\n$$\nwhere $\\mathbf{F}$ is the physical flux vector, and $a^+$ and $a^-$ are the maximum right-going and minimum left-going signal speeds at the interface, respectively. These speeds are computed from the relativistic velocity addition formula for sound waves: $\\lambda_{\\pm} = (v_n \\pm c_s) / (1 \\pm v_n c_s)$, where $v_n$ is the fluid velocity normal to the interface.\n\n**Second-Order Reconstruction:** To achieve second-order spatial accuracy, the states $\\mathbf{V}_L$ and $\\mathbf{V}_R$ are obtained by a linear reconstruction from cell-averaged values. A Total Variation Diminishing (TVD) slope limiter is applied to prevent spurious oscillations near sharp gradients (shocks or contact discontinuities). The specific implementation uses a generalized minmod limiter with a parameter $\\theta=1.8$, which provides a balance between being diffusive and compressive.\n\n**Time Integration:** A two-stage, second-order Strong Stability Preserving Runge-Kutta (SSP-RK2) method is used for time evolution. This ensures that the time-stepping does not introduce new oscillations and preserves the stability properties of the spatial discretization. A Courant-Friedrichs-Lewy (CFL) condition determines the time step $\\Delta\\tau$ based on the maximum signal speed across the grid, ensuring numerical stability.\n\n**Positivity Check:** The problem requires testing whether the energy density $\\epsilon$ and pressure $p$ remain non-negative throughout the evolution. Since $p=c_s^2\\epsilon$ and $c_s^20$, this reduces to checking if $\\min(\\epsilon) \\ge 0$. After the final time step, the minimum value of $\\epsilon$ is computed across the grid. A binary indicator is set to $1$ if this condition is met, and $0$ otherwise. High-gradient regions or insufficient resolution can lead to numerical errors that violate positivity, a common challenge in hydrodynamic simulations.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global constants and simulation parameters\nC_S2 = 1.0 / 3.0\nC_S = np.sqrt(C_S2)\nGHOST_CELLS = 2\n\ndef minmod_limiter(a, b, theta):\n    \"\"\"\n    Generalized minmod limiter with parameter theta for slope reconstruction.\n    \"\"\"\n    if a * b = 0:\n        return 0.0\n    else:\n        return np.sign(a) * min(abs(a) * theta, abs(b) * theta, 0.5 * abs(a + b))\n\ndef cons_to_prim(U, tau):\n    \"\"\"\n    Converts a conserved variable vector U to a primitive variable vector V = (epsilon, vx, vy).\n    U = (tau*T_tt, tau*T_tx, tau*T_ty)\n    \"\"\"\n    S_tau = U[0] / tau\n    M_x = U[1] / tau\n    M_y = U[2] / tau\n    M_sq = M_x**2 + M_y**2\n\n    rad_arg = 4.0 * S_tau**2 - 3.0 * M_sq\n    if rad_arg  0:\n        return np.array([1e-9, 0.0, 0.0])\n\n    eps = -S_tau + np.sqrt(rad_arg)\n    \n    if eps = 0:\n        return np.array([1e-9, 0.0, 0.0])\n\n    p = C_S2 * eps\n    S_tau_plus_p = S_tau + p\n    \n    if abs(S_tau_plus_p)  1e-12:\n        return np.array([eps, 0.0, 0.0])\n        \n    v_sq = M_sq / (S_tau_plus_p**2)\n    vx = M_x / S_tau_plus_p\n    vy = M_y / S_tau_plus_p\n\n    if v_sq = 1.0:\n        factor = 0.99999 / np.sqrt(v_sq)\n        vx *= factor\n        vy *= factor\n\n    return np.array([eps, vx, vy])\n\ndef prim_to_cons(V, tau):\n    \"\"\"Converts primitive variables V to conserved variables U.\"\"\"\n    eps, vx, vy = V\n    v_sq = vx**2 + vy**2\n    if v_sq = 1.0:\n        gamma = 1e6\n    else:\n        gamma = 1.0 / np.sqrt(1.0 - v_sq)\n        \n    p = C_S2 * eps\n    h = eps + p\n    \n    T_tt = h * gamma**2 - p\n    T_tx = h * gamma**2 * vx\n    T_ty = h * gamma**2 * vy\n    \n    return np.array([tau * T_tt, tau * T_tx, tau * T_ty])\n\ndef prim_to_flux_x(V, tau):\n    \"\"\"Calculates x-flux from primitive variables V.\"\"\"\n    eps, vx, vy = V\n    v_sq = vx**2 + vy**2\n    if v_sq = 1.0:\n        gamma = 1e6\n    else:\n        gamma = 1.0 / np.sqrt(1.0 - v_sq)\n        \n    p = C_S2 * eps\n    h = eps + p\n    \n    F_x = np.zeros(3)\n    F_x[0] = tau * h * gamma**2 * vx\n    F_x[1] = tau * (h * gamma**2 * vx**2 + p)\n    F_x[2] = tau * h * gamma**2 * vx * vy\n    return F_x\n\ndef prim_to_flux_y(V, tau):\n    \"\"\"Calculates y-flux from primitive variables V.\"\"\"\n    eps, vx, vy = V\n    v_sq = vx**2 + vy**2\n    if v_sq = 1.0:\n        gamma = 1e6\n    else:\n        gamma = 1.0 / np.sqrt(1.0 - v_sq)\n        \n    p = C_S2 * eps\n    h = eps + p\n    \n    F_y = np.zeros(3)\n    F_y[0] = tau * h * gamma**2 * vy\n    F_y[1] = tau * h * gamma**2 * vx * vy\n    F_y[2] = tau * (h * gamma**2 * vy**2 + p)\n    return F_y\n\ndef apply_bcs(V_grid):\n    \"\"\"Applies transmissive (zero-gradient) boundary conditions.\"\"\"\n    gh = GHOST_CELLS\n    Nx_phy, Ny_phy, _ = V_grid.shape\n    Nx, Ny = Nx_phy - 2 * gh, Ny_phy - 2 * gh\n\n    for i in range(gh):\n        V_grid[i, :, :] = V_grid[gh, :, :]\n        V_grid[Nx + gh + i, :, :] = V_grid[Nx + gh - 1, :, :]\n    \n    for j in range(gh):\n        V_grid[:, j, :] = V_grid[:, gh, :]\n        V_grid[:, Ny + gh + j, :] = V_grid[:, Ny + gh - 1, :]\n\ndef get_source(V):\n    \"\"\"Calculates the source term S = (-p, 0, 0).\"\"\"\n    eps = V[0]\n    p = C_S2 * eps\n    return np.array([-p, 0.0, 0.0])\n\ndef compute_rhs(V_grid, tau, dx, dy, Nx, Ny, theta):\n    gh = GHOST_CELLS\n    Nx_full, Ny_full, _ = V_grid.shape\n    RHS = np.zeros_like(V_grid)\n    \n    # X-direction sweep\n    slopes_x = np.zeros_like(V_grid)\n    for j in range(Ny_full):\n        for i in range(1, Nx_full - 1):\n             for k in range(3):\n                slopes_x[i, j, k] = minmod_limiter(V_grid[i, j, k] - V_grid[i-1, j, k], V_grid[i+1, j, k] - V_grid[i, j, k], theta)\n\n    for j in range(gh, Ny + gh):\n        for i in range(gh - 1, Nx + gh):\n            VL = V_grid[i, j, :] + 0.5 * slopes_x[i, j, :]\n            VR = V_grid[i+1, j, :] - 0.5 * slopes_x[i+1, j, :]\n            \n            UL = prim_to_cons(VL, tau)\n            UR = prim_to_cons(VR, tau)\n            FxL = prim_to_flux_x(VL, tau)\n            FxR = prim_to_flux_x(VR, tau)\n            \n            lambda_p_L = (VL[1] + C_S) / (1. + VL[1]*C_S)\n            lambda_m_L = (VL[1] - C_S) / (1. - VL[1]*C_S)\n            lambda_p_R = (VR[1] + C_S) / (1. + VR[1]*C_S)\n            lambda_m_R = (VR[1] - C_S) / (1. - VR[1]*C_S)\n            \n            ap = max(0.0, lambda_p_L, lambda_p_R)\n            am = min(0.0, lambda_m_L, lambda_m_R)\n            \n            if ap - am  1e-9:\n                flux = (ap * FxL - am * FxR + ap * am * (UR - UL)) / (ap - am)\n            else:\n                flux = 0.5 * (FxL + FxR)\n            \n            RHS[i, j, :] -= flux / dx\n            RHS[i+1, j, :] += flux / dx\n\n    # Y-direction sweep\n    slopes_y = np.zeros_like(V_grid)\n    for i in range(Nx_full):\n        for j in range(1, Ny_full-1):\n             for k in range(3):\n                slopes_y[i, j, k] = minmod_limiter(V_grid[i, j, k] - V_grid[i, j-1, k], V_grid[i, j+1, k] - V_grid[i, j, k], theta)\n                \n    for i in range(gh, Nx + gh):\n        for j in range(gh - 1, Ny + gh):\n            VL = V_grid[i, j, :] + 0.5 * slopes_y[i, j, :]\n            VR = V_grid[i, j+1, :] - 0.5 * slopes_y[i, j+1, :]\n\n            UL = prim_to_cons(VL, tau)\n            UR = prim_to_cons(VR, tau)\n            FyL = prim_to_flux_y(VL, tau)\n            FyR = prim_to_flux_y(VR, tau)\n\n            lambda_p_L = (VL[2] + C_S) / (1. + VL[2]*C_S)\n            lambda_m_L = (VL[2] - C_S) / (1. - VL[2]*C_S)\n            lambda_p_R = (VR[2] + C_S) / (1. + VR[2]*C_S)\n            lambda_m_R = (VR[2] - C_S) / (1. - VR[2]*C_S)\n\n            ap = max(0.0, lambda_p_L, lambda_p_R)\n            am = min(0.0, lambda_m_L, lambda_m_R)\n            \n            if ap - am  1e-9:\n                flux = (ap * FyL - am * FyR + ap * am * (UR - UL)) / (ap - am)\n            else:\n                flux = 0.5 * (FyL + FyR)\n\n            RHS[i, j, :] -= flux / dy\n            RHS[i, j+1, :] += flux / dy\n            \n    # Add source term\n    for i in range(gh, Nx + gh):\n       for j in range(gh, Ny + gh):\n           RHS[i, j, :] += get_source(V_grid[i, j, :])\n           \n    return RHS\n\ndef solve_hydro(L, tau0, tauf, eps_in, eps_out, r0, Nx, Ny, CFL, theta):\n    \"\"\"Main hydro solver function for one test case.\"\"\"\n    dx = 2.0 * L / Nx\n    dy = 2.0 * L / Ny\n    gh = GHOST_CELLS\n    \n    Nx_full, Ny_full = Nx + 2*gh, Ny + 2*gh\n    V_grid = np.zeros((Nx_full, Ny_full, 3))\n    \n    x_coords = np.linspace(-L - (gh - 0.5)*dx, L + (gh - 0.5)*dx, Nx_full)\n    y_coords = np.linspace(-L - (gh - 0.5)*dy, L + (gh - 0.5)*dy, Ny_full)\n    \n    sigma_blast = r0 / 2.0\n    for i in range(Nx_full):\n        for j in range(Ny_full):\n            r = np.sqrt(x_coords[i]**2 + y_coords[j]**2)\n            eps_val = eps_out + (eps_in - eps_out) * np.exp(-r**2 / (2 * sigma_blast**2))\n            V_grid[i, j, :] = [eps_val, 0.0, 0.0]\n\n    U_grid = np.zeros_like(V_grid)\n    for i in range(Nx_full):\n        for j in range(Ny_full):\n            U_grid[i, j, :] = prim_to_cons(V_grid[i, j, :], tau0)\n            \n    tau = tau0\n    while tau  tauf:\n        apply_bcs(V_grid)\n        \n        max_speed = 1e-9\n        for i in range(gh, Nx + gh):\n            for j in range(gh, Ny + gh):\n                _, vx, vy = V_grid[i,j]\n                speed_x = (abs(vx) + C_S) / (1. + abs(vx)*C_S)\n                speed_y = (abs(vy) + C_S) / (1. + abs(vy)*C_S)\n                max_speed = max(max_speed, speed_x, speed_y)\n        \n        dt = CFL * min(dx, dy) / max_speed\n        if tau + dt  tauf:\n            dt = tauf - tau\n        \n        # SSP-RK2 Stage 1\n        RHS_n = compute_rhs(V_grid, tau, dx, dy, Nx, Ny, theta)\n        U1 = U_grid + dt * RHS_n\n        V1 = np.zeros_like(V_grid)\n        for i in range(Nx_full):\n            for j in range(Ny_full):\n                 V1[i, j, :] = cons_to_prim(U1[i,j], tau + dt)\n\n        # SSP-RK2 Stage 2\n        apply_bcs(V1)\n        RHS_1 = compute_rhs(V1, tau + dt, dx, dy, Nx, Ny, theta)\n        U_np1 = 0.5 * U_grid + 0.5 * (U1 + dt * RHS_1)\n\n        # Update for next step\n        U_grid = U_np1\n        for i in range(Nx_full):\n            for j in range(Ny_full):\n                V_grid[i, j, :] = cons_to_prim(U_grid[i,j], tau + dt)\n        tau += dt\n    \n    min_eps = np.min(V_grid[gh:-gh, gh:-gh, 0])\n    return 1 if min_eps = 0.0 else 0\n\ndef solve():\n    test_cases = [\n        # (Parameter set 1: Case A)\n        {'L': 6.0, 'tau0': 0.6, 'tauf': 1.0, 'eps_in': 10.0, 'eps_out': 1.0, 'r0': 1.5, 'Nx': 40, 'Ny': 40, 'CFL': 0.4, 'theta': 1.8},\n        # (Parameter set 2: Case B)\n        {'L': 6.0, 'tau0': 0.6, 'tauf': 1.0, 'eps_in': 8.0, 'eps_out': 0.2, 'r0': 1.0, 'Nx': 40, 'Ny': 40, 'CFL': 0.4, 'theta': 1.8},\n        # (Parameter set 3: Case C)\n        {'L': 6.0, 'tau0': 0.6, 'tauf': 1.0, 'eps_in': 12.0, 'eps_out': 0.5, 'r0': 0.8, 'Nx': 40, 'Ny': 40, 'CFL': 0.4, 'theta': 1.8},\n    ]\n\n    results = []\n    for params in test_cases:\n        result = solve_hydro(**params)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3516450"}, {"introduction": "A powerful application of hydrodynamic simulations is to provide a dynamic, evolving background for studying the transport of energetic probes. This final practice bridges the gap between the simulated medium and the phenomenology of jet quenching [@problem_id:3516447]. You will first derive how the medium's flow velocity creates a Doppler-like modification to the effective momentum broadening experienced by a jet, then implement a path integral to calculate the total accumulated quenching power along different trajectories, providing direct insight into how flow anisotropies impact hard probe measurements.", "problem": "Consider the interaction of an ultrarelativistic jet with a hydrodynamic medium in high-energy heavy-ion collisions. Work in natural units where $c=1$. Adopt the Minkowski metric with signature $(+,-,-,-)$. Let the jet four-momentum be $p^\\mu = (E,\\vec{p})$ with $|\\vec{p}| \\approx E$ and unit direction $\\vec{n} = \\vec{p}/|\\vec{p}|$, and let the medium four-velocity be $u^\\mu = \\gamma(\\vec{v}) \\, (1,\\vec{v})$ with $\\gamma(\\vec{v}) = 1/\\sqrt{1-|\\vec{v}|^2}$. Define the Local Rest Frame (LRF) transverse momentum broadening transport coefficient $\\hat{q}_{\\mathrm{LRF}}(T)$ as the rate of transverse momentum squared picked up by the jet per unit length measured in the LRF of the fluid. Assume a constitutive relation $\\hat{q}_{\\mathrm{LRF}}(T) = \\kappa \\, T^3$ for $T \\ge T_c$ and $\\hat{q}_{\\mathrm{LRF}}(T) = 0$ for $T  T_c$, where $T$ is the local temperature, $T_c$ is a pseudo-critical temperature, and $\\kappa$ is a constant. Temperatures are in $\\mathrm{GeV}$, lengths are in $\\mathrm{fm}$, and $\\hat{q}$ has units $\\mathrm{GeV}^2/\\mathrm{fm}$.\n\nTask 1 (derivation): Starting only from Lorentz covariance, the definition of four-velocity $u^\\mu$, four-momentum $p^\\mu$, the Lorentz-invariant scalar $u^\\mu p_\\mu$, and the interpretation of $\\hat{q}_{\\mathrm{LRF}}$ as a rate per unit length in the LRF, derive an expression for the instantaneous effective broadening rate per unit lab-frame length, $\\hat{q}_{\\mathrm{eff}}$, experienced by the jet moving through a flowing medium. Your derivation must explicitly relate $\\hat{q}_{\\mathrm{eff}}$ to $\\hat{q}_{\\mathrm{LRF}}$, $u^\\mu$, and $p^\\mu$, and must identify the multiplicative factor that reduces to a Doppler-like form when the jet is ultrarelativistic and $|\\vec{v}|  1$. Do not assume any specific form for $\\hat{q}_{\\mathrm{eff}}$ at the outset; instead, derive it from the invariance properties and physical interpretation described.\n\nTask 2 (path integral): Consider a jet launched at time $t_0 = 0$ from position $\\vec{x}_0 = (x_0,y_0)$, traveling at speed $|\\vec{v}_{\\mathrm{jet}}|=1$ along the unit direction $\\vec{n}=(n_x,n_y)$ through a two-dimensional, transversely symmetric medium with static temperature field\n$$\nT(x,y) = T_0 \\exp\\!\\left(-\\frac{x^2 + y^2}{2 \\sigma^2}\\right).\n$$\nThe medium has a uniform and constant flow velocity $\\vec{v} = (V_x,V_y)$, so that $u^\\mu$ is spatially constant. Parameterize the jet path by the lab-frame arc length $s \\in [0,L]$ with $\\vec{x}(s) = \\vec{x}_0 + s \\, \\vec{n}$ and $t(s) = t_0 + s$. Using your derived $\\hat{q}_{\\mathrm{eff}}$, compute the line integral\n$$\nJ = \\int_0^L \\hat{q}_{\\mathrm{eff}}(\\vec{x}(s)) \\, ds,\n$$\nwhich has units of $\\mathrm{GeV}^2$. This integral represents the accumulated transverse momentum broadening along the path. If $T(\\vec{x}(s))  T_c$, then $\\hat{q}_{\\mathrm{LRF}}$ is zero at that point, and no contribution should be added from that segment.\n\nTask 3 (implementation and output): Implement a program that performs the above computation for each of the following test cases. For each case, use the given parameters and compute $J$ to high numerical accuracy using a stable, convergent quadrature over $s \\in [0,L]$. Express all $J$ values in $\\mathrm{GeV}^2$, rounded to exactly $6$ decimal places.\n\nCommon parameters for all cases:\n- $\\kappa = 2.0 \\, \\mathrm{GeV}^2/(\\mathrm{fm}\\cdot\\mathrm{GeV}^3)$,\n- $T_c = 0.16 \\, \\mathrm{GeV}$,\n- $t_0 = 0$.\n\nMedium temperature field parameters are $T_0$ and $\\sigma$ as listed per case. The medium velocity $\\vec{v} = (V_x,V_y)$ is uniform in space and time for each case. The jet starts at $\\vec{x}_0 = (x_0,y_0)$ and propagates for length $L$ along direction $\\vec{n}=(n_x,n_y)$, where $\\vec{n}$ is a unit vector in the transverse plane.\n\nTest suite:\n- Case $1$ (baseline rest medium): $T_0 = 0.5$, $\\sigma = 5.0$, $(V_x,V_y) = (0.0,0.0)$, $(x_0,y_0) = (0.0,0.0)$, $(n_x,n_y) = (1.0,0.0)$, $L = 10.0$.\n- Case $2$ (co-flow along the jet): $T_0 = 0.5$, $\\sigma = 5.0$, $(V_x,V_y) = (0.6,0.0)$, $(x_0,y_0) = (0.0,0.0)$, $(n_x,n_y) = (1.0,0.0)$, $L = 10.0$.\n- Case $3$ (counter-flow against the jet): $T_0 = 0.5$, $\\sigma = 5.0$, $(V_x,V_y) = (-0.6,0.0)$, $(x_0,y_0) = (0.0,0.0)$, $(n_x,n_y) = (1.0,0.0)$, $L = 10.0$.\n- Case $4$ (orthogonal fast flow): $T_0 = 0.5$, $\\sigma = 5.0$, $(V_x,V_y) = (0.0,0.9)$, $(x_0,y_0) = (0.0,0.0)$, $(n_x,n_y) = (1.0,0.0)$, $L = 10.0$.\n- Case $5$ (short overlap near edge with co-flow): $T_0 = 0.5$, $\\sigma = 5.0$, $(V_x,V_y) = (0.6,0.0)$, $(x_0,y_0) = (6.0,0.0)$, $(n_x,n_y) = (1.0,0.0)$, $L = 10.0$.\n\nAll quantities listed without units are in $\\mathrm{GeV}$ for temperatures and in $\\mathrm{fm}$ for lengths; velocities are dimensionless fractions of the speed of light in natural units. Angles are not used directly; directions are given by components of unit vectors.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each $J$ rounded to exactly $6$ decimal places and in the specified order of the test suite, for example, $[J_1,J_2,J_3,J_4,J_5]$ where each $J_i$ is a floating-point number representing $\\mathrm{GeV}^2$.", "solution": "The problem requires a three-part solution: a theoretical derivation of the effective momentum broadening rate $\\hat{q}_{\\mathrm{eff}}$, the formulation of a path integral $J$ for the total accumulated broadening, and a numerical implementation to compute $J$ for several test cases.\n\n### Task 1: Derivation of the Effective Broadening Rate $\\hat{q}_{\\mathrm{eff}}$\nWe are tasked with deriving the expression for $\\hat{q}_{\\mathrm{eff}}$, the rate of transverse momentum broadening per unit length in the lab frame, starting from $\\hat{q}_{\\mathrm{LRF}}$, the rate per unit length in the Local Rest Frame (LRF) of the medium.\n\nLet $d\\langle p_\\perp^2 \\rangle$ be the infinitesimal amount of transverse momentum squared acquired by the jet. The problem defines the LRF transport coefficient as:\n$$\n\\hat{q}_{\\mathrm{LRF}} = \\frac{d\\langle p_\\perp^2 \\rangle}{ds_{\\mathrm{LRF}}}\n$$\nwhere $ds_{\\mathrm{LRF}}$ is the infinitesimal path length traversed by the jet as measured in the LRF of a fluid element.\n\nOur goal is to find the effective rate in the lab frame:\n$$\n\\hat{q}_{\\mathrm{eff}} = \\frac{d\\langle p_\\perp^2 \\rangle}{ds_{\\mathrm{lab}}}\n$$\nwhere $ds_{\\mathrm{lab}}$ is the infinitesimal path length in the lab frame.\n\nBy the chain rule, we can relate the two quantities:\n$$\n\\hat{q}_{\\mathrm{eff}} = \\frac{d\\langle p_\\perp^2 \\rangle}{ds_{\\mathrm{LRF}}} \\frac{ds_{\\mathrm{LRF}}}{ds_{\\mathrm{lab}}} = \\hat{q}_{\\mathrm{LRF}} \\frac{ds_{\\mathrm{LRF}}}{ds_{\\mathrm{lab}}}\n$$\nThe core of the derivation is to find the Lorentz-invariant relationship between $ds_{\\mathrm{LRF}}$ and $ds_{\\mathrm{lab}}$.\n\nLet $dx^\\mu$ be the infinitesimal spacetime displacement four-vector of the jet in the lab frame. Since the jet is ultrarelativistic, it travels at the speed of light ($c=1$). If $ds_{\\mathrm{lab}}$ is the path length, the time taken is $dt_{\\mathrm{lab}} = ds_{\\mathrm{lab}}$. The jet travels along the direction given by the unit vector $\\vec{n}$. Thus, the displacement four-vector is:\n$$\ndx^\\mu = (dt_{\\mathrm{lab}}, d\\vec{x}_{\\mathrm{lab}}) = (ds_{\\mathrm{lab}}, \\vec{n} \\, ds_{\\mathrm{lab}})\n$$\nNow, consider the medium's four-velocity $u^\\mu = \\gamma(\\vec{v})(1, \\vec{v})$, where $\\vec{v}$ is the fluid velocity in the lab frame and $\\gamma(\\vec{v}) = (1 - |\\vec{v}|^2)^{-1/2}$.\n\nThe time elapsed in the LRF of the fluid element, $dt_{\\mathrm{LRF}}$, corresponding to the spacetime displacement $dx^\\mu$ is given by the Lorentz-invariant projection of $dx^\\mu$ onto the fluid's four-velocity $u_\\mu$. In the LRF, $u'^\\mu = (1, \\vec{0})$, so $u'_\\mu dx'^\\mu = dt_{\\mathrm{LRF}}$. Due to Lorentz invariance, this holds in any frame:\n$$\ndt_{\\mathrm{LRF}} = u_\\mu dx^\\mu\n$$\nUsing the Minkowski metric with signature $(+,-,-,-)$, we have $u_\\mu = \\gamma(\\vec{v})(1, -\\vec{v})$. We compute the dot product:\n$$\ndt_{\\mathrm{LRF}} = \\gamma(\\vec{v})(1, -\\vec{v}) \\cdot (ds_{\\mathrm{lab}}, \\vec{n} \\, ds_{\\mathrm{lab}}) = \\gamma(\\vec{v}) (1 \\cdot ds_{\\mathrm{lab}} - \\vec{v} \\cdot \\vec{n} \\, ds_{\\mathrm{lab}}) = \\gamma(\\vec{v})(1 - \\vec{v} \\cdot \\vec{n}) \\, ds_{\\mathrm{lab}}\n$$\nSince the jet is massless (or ultrarelativistic), it travels at the speed of light in any inertial frame. Therefore, the path length traversed in the LRF, $ds_{\\mathrm{LRF}}$, is equal to the time elapsed in the LRF, $dt_{\\mathrm{LRF}}$ (as $c=1$).\n$$\nds_{\\mathrm{LRF}} = dt_{\\mathrm{LRF}}\n$$\nSubstituting this into our expression for $dt_{\\mathrm{LRF}}$, we find the relationship between the path lengths:\n$$\n\\frac{ds_{\\mathrm{LRF}}}{ds_{\\mathrm{lab}}} = \\gamma(\\vec{v})(1 - \\vec{v} \\cdot \\vec{n})\n$$\nThis is the required multiplicative factor. It has a \"Doppler-like\" form. Now, we substitute this back into the relation for $\\hat{q}_{\\mathrm{eff}}$:\n$$\n\\hat{q}_{\\mathrm{eff}} = \\hat{q}_{\\mathrm{LRF}} \\cdot \\gamma(\\vec{v})(1 - \\vec{v} \\cdot \\vec{n})\n$$\nTo express this using the jet four-momentum $p^\\mu = (E, \\vec{p})$, we note that for an ultrarelativistic jet, $|\\vec{p}| \\approx E$ and $\\vec{n} = \\vec{p}/|\\vec{p}| \\approx \\vec{p}/E$.\nThe Lorentz scalar $u^\\mu p_\\mu$ is:\n$$\nu^\\mu p_\\mu = \\gamma(\\vec{v})(1, \\vec{v}) \\cdot (E, -\\vec{p}) = \\gamma(\\vec{v})(E - \\vec{v} \\cdot \\vec{p}) = \\gamma(\\vec{v})E(1 - \\vec{v} \\cdot (\\vec{p}/E)) \\approx \\gamma(\\vec{v})E(1 - \\vec{v} \\cdot \\vec{n})\n$$\nFrom this, we see that the derived factor is $\\frac{u^\\mu p_\\mu}{E}$. The final expression for the effective broadening rate is:\n$$\n\\hat{q}_{\\mathrm{eff}} = \\hat{q}_{\\mathrm{LRF}}(T) \\frac{u^\\mu p_\\mu}{E} = \\hat{q}_{\\mathrm{LRF}}(T) \\, \\gamma(\\vec{v})(1 - \\vec{v} \\cdot \\vec{n})\n$$\n\n### Task 2: Formulation of the Path Integral\nWe need to compute the total accumulated transverse momentum broadening, $J$, by integrating $\\hat{q}_{\\mathrm{eff}}$ along the jet's path:\n$$\nJ = \\int_0^L \\hat{q}_{\\mathrm{eff}}(\\vec{x}(s)) \\, ds\n$$\nThe jet's path is parameterized by the lab-frame arc length $s \\in [0,L]$ as $\\vec{x}(s) = \\vec{x}_0 + s\\vec{n}$. The medium has a uniform flow velocity $\\vec{v} = (V_x, V_y)$ and a static temperature profile $T(x,y) = T_0 \\exp[-(x^2+y^2)/(2\\sigma^2)]$. The constitutive relation for $\\hat{q}_{\\mathrm{LRF}}$ is $\\kappa T^3$ for $T \\ge T_c$ and $0$ otherwise.\n\nCombining these elements, the integrand is:\n$$\n\\hat{q}_{\\mathrm{eff}}(s) = \\kappa [T(\\vec{x}(s))]^3 \\cdot \\gamma(\\vec{v})(1 - \\vec{v} \\cdot \\vec{n})\n$$\nThe Doppler-like factor $F_D = \\gamma(\\vec{v})(1 - \\vec{v} \\cdot \\vec{n})$ is constant along the path. The temperature depends on the path parameter $s$ through the position $\\vec{x}(s)$:\n$$\nT(\\vec{x}(s)) = T_0 \\exp\\left(-\\frac{|\\vec{x}_0 + s\\vec{n}|^2}{2\\sigma^2}\\right) = T_0 \\exp\\left(-\\frac{|\\vec{x}_0|^2 + 2s(\\vec{x}_0 \\cdot \\vec{n}) + s^2}{2\\sigma^2}\\right)\n$$\nThe integral $J$ can be written as:\n$$\nJ = \\kappa \\, T_0^3 \\, \\gamma(\\vec{v})(1 - \\vec{v} \\cdot \\vec{n}) \\int_{\\text{path}} \\exp\\left(-\\frac{3(|\\vec{x}_0|^2 + 2s(\\vec{x}_0 \\cdot \\vec{n}) + s^2)}{2\\sigma^2}\\right) ds\n$$\nThe integration is non-zero only over the segment of the path where $T(\\vec{x}(s)) \\ge T_c$. This condition defines the integration limits.\n$$\nT_0 \\exp\\left(-\\frac{|\\vec{x}(s)|^2}{2\\sigma^2}\\right) \\ge T_c \\implies |\\vec{x}(s)|^2 \\le 2\\sigma^2 \\ln\\left(\\frac{T_0}{T_c}\\right)\n$$\nLet $R_{\\mathrm{max}}^2 = 2\\sigma^2 \\ln(T_0/T_c)$. If $T_0  T_c$, this quantity is ill-defined or negative, and the integral is $0$. The inequality becomes $|\\vec{x}_0|^2 + 2s(\\vec{x}_0 \\cdot \\vec{n}) + s^2 \\le R_{\\mathrm{max}}^2$, which is a quadratic inequality for $s$:\n$$\ns^2 + 2(\\vec{x}_0 \\cdot \\vec{n})s + (|\\vec{x}_0|^2 - R_{\\mathrm{max}}^2) \\le 0\n$$\nSolving the corresponding quadratic equation $s^2 + 2(\\vec{x}_0 \\cdot \\vec{n})s + (|\\vec{x}_0|^2 - R_{\\mathrm{max}}^2) = 0$ gives two roots, $s_1$ and $s_2$. The condition $T \\ge T_c$ is satisfied for $s \\in [s_1, s_2]$. The actual integration range must also lie within the jet's total path length $[0,L]$. Thus, the integration limits are:\n$$\ns_{\\mathrm{start}} = \\max(0, s_1) \\quad \\text{and} \\quad s_{\\mathrm{end}} = \\min(L, s_2)\n$$\nIf the discriminant of the quadratic is negative, or if $s_{\\mathrm{end}} \\le s_{\\mathrm{start}}$, the jet path does not cross the hot region, and $J=0$.\n\n### Task 3: Numerical Implementation\nThe resulting definite integral does not, in general, have a simple closed-form solution in terms of elementary functions. A robust approach is to use numerical quadrature. The implementation will calculate $J$ for each test case by:\n1.  Calculating the constant Doppler factor $F_D = \\gamma(1 - \\vec{v} \\cdot \\vec{n})$.\n2.  Determining the integration limits $s_{\\mathrm{start}}$ and $s_{\\mathrm{end}}$ by solving the quadratic inequality derived from the condition $T(s) \\ge T_c$.\n3.  Defining the integrand function, which is proportional to $\\exp(-3|\\vec{x}(s)|^2 / (2\\sigma^2))$.\n4.  Using a numerical integration routine (like `scipy.integrate.quad`) to compute the integral over $[s_{\\mathrm{start}}, s_{\\mathrm{end}}]$.\n5.  Multiplying the numerical result of the integral by the constant prefactors, $\\kappa \\, T_0^3 \\, F_D$, to obtain the final value of $J$.\nThis procedure is applied to each of the five test cases specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Computes the accumulated transverse momentum broadening for a jet in a\n    hydrodynamic medium for a series of test cases.\n    \"\"\"\n    # Common parameters for all cases\n    kappa = 2.0  # GeV^2/(fm*GeV^3)\n    Tc = 0.16    # GeV\n\n    # Test suite from the problem statement\n    test_cases = [\n        # Case 1: baseline rest medium\n        {'T0': 0.5, 'sigma': 5.0, 'Vx': 0.0, 'Vy': 0.0, 'x0': 0.0, 'y0': 0.0, 'nx': 1.0, 'ny': 0.0, 'L': 10.0},\n        # Case 2: co-flow along the jet\n        {'T0': 0.5, 'sigma': 5.0, 'Vx': 0.6, 'Vy': 0.0, 'x0': 0.0, 'y0': 0.0, 'nx': 1.0, 'ny': 0.0, 'L': 10.0},\n        # Case 3: counter-flow against the jet\n        {'T0': 0.5, 'sigma': 5.0, 'Vx': -0.6, 'Vy': 0.0, 'x0': 0.0, 'y0': 0.0, 'nx': 1.0, 'ny': 0.0, 'L': 10.0},\n        # Case 4: orthogonal fast flow\n        {'T0': 0.5, 'sigma': 5.0, 'Vx': 0.0, 'Vy': 0.9, 'x0': 0.0, 'y0': 0.0, 'nx': 1.0, 'ny': 0.0, 'L': 10.0},\n        # Case 5: short overlap near edge with co-flow\n        {'T0': 0.5, 'sigma': 5.0, 'Vx': 0.6, 'Vy': 0.0, 'x0': 6.0, 'y0': 0.0, 'nx': 1.0, 'ny': 0.0, 'L': 10.0},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        T0 = case['T0']\n        sigma = case['sigma']\n        Vx, Vy = case['Vx'], case['Vy']\n        x0, y0 = case['x0'], case['y0']\n        nx, ny = case['nx'], case['ny']\n        L = case['L']\n\n        # Step 1: Calculate the constant Doppler factor\n        v_norm_sq = Vx**2 + Vy**2\n        if v_norm_sq = 1.0:\n            # Physically impossible velocity, handle gracefully\n            results.append(0.0)\n            continue\n        gamma = 1.0 / np.sqrt(1.0 - v_norm_sq)\n        v_dot_n = Vx * nx + Vy * ny\n        doppler_factor = gamma * (1.0 - v_dot_n)\n\n        # Step 2: Determine the integration limits from T(s) = Tc\n        if T0  Tc:\n            results.append(0.0)\n            continue\n        \n        R2_max = 2.0 * sigma**2 * np.log(T0 / Tc)\n\n        # Solve s^2 + 2*(x0 . n)*s + (|x0|^2 - R2_max) = 0\n        x0_dot_n = x0 * nx + y0 * ny\n        x0_norm_sq = x0**2 + y0**2\n\n        # Quadratic equation coefficients: a*s^2 + b*s + c = 0\n        a = 1.0\n        b = 2.0 * x0_dot_n\n        c = x0_norm_sq - R2_max\n\n        discriminant = b**2 - 4.0 * a * c\n        if discriminant  0:\n            results.append(0.0)\n            continue\n\n        sqrt_discriminant = np.sqrt(discriminant)\n        s1 = (-b - sqrt_discriminant) / (2.0 * a)\n        s2 = (-b + sqrt_discriminant) / (2.0 * a)\n\n        s_start = max(0.0, s1)\n        s_end = min(L, s2)\n\n        if s_start = s_end:\n            results.append(0.0)\n            continue\n\n        # Step 3: Define the integrand for numerical integration\n        def integrand(s):\n            x = x0 + s * nx\n            y = y0 + s * ny\n            r_sq = x**2 + y**2\n            # This is the T^3 part, scaled by T0^3, which is a prefactor\n            return np.exp(-3.0 * r_sq / (2.0 * sigma**2))\n\n        # Step 4: Perform the integration\n        integral_val, _ = quad(integrand, s_start, s_end, epsabs=1e-12, epsrel=1e-12)\n\n        # Step 5: Combine all factors to get the final result for J\n        J = doppler_factor * kappa * (T0**3) * integral_val\n        results.append(J)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3516447"}]}