{"hands_on_practices": [{"introduction": "The foundation of any reliable simulation is a correctly implemented force calculation, which represents the gradient of the action. This exercise introduces the essential practice of verifying an analytically derived action gradient against a high-precision numerical finite-difference approximation [@problem_id:3563928]. By implementing this check for a representative toy model, you will gain a critical skill for debugging and validating your own HMC codes before deploying them for physics production.", "problem": "You are asked to implement and validate a finite-difference force check for a small one-dimensional lattice field theory toy model representative of Hybrid Monte Carlo (HMC) used in lattice Effective Field Theory (EFT). The validation must compare central finite-difference estimates of the gradient of the Euclidean action with the analytic gradient derived from first principles of matrix calculus and variational differentiation.\n\nConsider a one-dimensional periodic lattice with $N$ sites and a real auxiliary field vector $\\boldsymbol{\\sigma} \\in \\mathbb{R}^{N}$. Define the periodic nearest-neighbor lattice Laplacian matrix $\\mathbf{L} \\in \\mathbb{R}^{N \\times N}$ by $(\\mathbf{L}\\boldsymbol{v})_{i} = 2 v_{i} - v_{i+1} - v_{i-1}$, with indices taken modulo $N$. The Euclidean action is\n$$\nS(\\boldsymbol{\\sigma}) = \\frac{1}{2}\\,\\boldsymbol{\\sigma}^{\\top}\\,\\mathbf{K}_{\\text{bos}}\\,\\boldsymbol{\\sigma} + \\frac{\\lambda}{4}\\sum_{i=0}^{N-1}\\sigma_i^{4} \\;-\\; \\log\\det\\mathbf{M}(\\boldsymbol{\\sigma}),\n$$\nwhere the bosonic kernel is $\\mathbf{K}_{\\text{bos}} = m^{2}\\,\\mathbf{I} + \\kappa\\,\\mathbf{L}$ and the fermion matrix is\n$$\n\\mathbf{M}(\\boldsymbol{\\sigma}) = \\mathbf{I} + a\\,\\mathrm{diag}\\!\\left(\\exp(\\beta\\,\\boldsymbol{\\sigma})\\right) + t\\,\\mathbf{L}.\n$$\nAll quantities are dimensionless. Assume parameters are such that $\\mathbf{M}(\\boldsymbol{\\sigma})$ is symmetric positive definite for all field configurations considered.\n\nTasks to implement:\n\n1. Derive the analytic gradient $\\nabla S(\\boldsymbol{\\sigma}) \\in \\mathbb{R}^{N}$ starting from the definitions above using only fundamental rules of calculus and linear algebra. You must not assume any shortcut formulas that are not derivable from these bases. The final expression must be correct for arbitrary $N$ and the given action.\n\n2. Implement a numerical central finite-difference approximation to the gradient with component-wise steps. For a given step scale $h>0$, use component-wise steps $\\,\\varepsilon_i = h\\,\\big(1 + |\\sigma_i|\\big)\\,$ and\n$$\n\\big(\\nabla S\\big)^{\\text{FD}}_{i}(\\boldsymbol{\\sigma}) \\;=\\; \\frac{S\\big(\\boldsymbol{\\sigma} + \\varepsilon_i\\,\\mathbf{e}_i\\big) - S\\big(\\boldsymbol{\\sigma} - \\varepsilon_i\\,\\mathbf{e}_i\\big)}{2\\,\\varepsilon_i},\n$$\nwhere $\\mathbf{e}_i$ is the $i$-th standard basis vector.\n\n3. For each test case, estimate a tolerance directly from observed agreement between the analytic and finite-difference gradients over a small training set of random fields. Use the following deterministic procedure:\n   - Generate $N_{\\text{train}} = 5$ independent training configurations $\\boldsymbol{\\sigma}$ with components sampled from a standard normal distribution using a fixed seed $s_{\\text{train}}$ specific to each test case (see Test Suite below). For each configuration, compute the training discrepancy\n     $$\n     d = \\left\\|\\nabla S(\\boldsymbol{\\sigma}) - \\big(\\nabla S\\big)^{\\text{FD}}(\\boldsymbol{\\sigma})\\right\\|_{\\infty}.\n     $$\n     Collect the set $\\{d_j\\}_{j=1}^{N_{\\text{train}}}$.\n   - Compute a scale proxy $s = 1 + \\mathrm{median}\\big(\\{\\|\\nabla S(\\boldsymbol{\\sigma}_j)\\|_{\\infty}\\}_{j=1}^{N_{\\text{train}}}\\big)$.\n   - Set the tolerance to\n     $$\n     \\mathrm{tol} = 10 \\cdot \\mathrm{median}\\left(\\{d_j\\}\\right) + 10^{-12}\\,s.\n     $$\n   This defines a tolerance based solely on observed agreement between finite differences and analytic gradients on the training set.\n\n4. Using an independent test set of $N_{\\text{test}} = 3$ random configurations generated with a fixed seed $s_{\\text{test}}$ per test case, declare the test case to pass if and only if every test configuration satisfies\n$$\n\\left\\|\\nabla S(\\boldsymbol{\\sigma}) - \\big(\\nabla S\\big)^{\\text{FD}}(\\boldsymbol{\\sigma})\\right\\|_{\\infty} \\le \\mathrm{tol}.\n$$\n\nYour program must implement the above for the following test suite of parameter sets. For each case, report a boolean indicating pass or fail according to the rule in item $4$.\n\nTest Suite (each tuple is $(N, m, \\kappa, \\lambda, a, \\beta, t, h, s_{\\text{train}}, s_{\\text{test}})$):\n- Case A (happy path): $(4,\\, 0.5,\\, 1.0,\\, 0.1,\\, 0.7,\\, 0.6,\\, 0.2,\\, 10^{-6},\\, 12345,\\, 54321)$\n- Case B (minimal lattice, diagonal fermion): $(2,\\, 3.0,\\, 0.0,\\, 0.0,\\, 0.25,\\, 0.8,\\, 0.0,\\, 10^{-6},\\, 22345,\\, 64321)$\n- Case C (strong nearest-neighbor fermion, larger $N$): $(8,\\, 0.1,\\, 2.0,\\, 0.0,\\, 0.5,\\, 1.0,\\, 0.5,\\, 10^{-6},\\, 32345,\\, 74321)$\n- Case D (quartic interaction and very small finite-difference step): $(6,\\, 1.2,\\, 0.5,\\, 0.5,\\, 1.0,\\, 1.2,\\, 0.3,\\, 10^{-8},\\, 42345,\\, 84321)$\n\nAngle units are not applicable. There are no physical units; all quantities are dimensionless.\n\nFinal output format: Your program should produce a single line of output containing a list of booleans for the four cases in the order A, B, C, D, printed as a Python-style list, for example, \"[True,False,True,True]\".", "solution": "The problem statement has been rigorously validated and is determined to be valid. It is scientifically grounded, well-posed, self-contained, and computationally feasible. It presents a standard and meaningful task in computational physics: the verification of an analytically derived force term against a numerical finite-difference approximation in the context of a lattice field theory model.\n\nThe solution proceeds in two stages. First, the analytic gradient (force) of the Euclidean action is derived from first principles. Second, an algorithm implementing the specified numerical validation procedure is outlined.\n\n### 1. Analytic Gradient of the Euclidean Action\n\nThe Euclidean action $S(\\boldsymbol{\\sigma})$ is given by:\n$$\nS(\\boldsymbol{\\sigma}) = \\frac{1}{2}\\,\\boldsymbol{\\sigma}^{\\top}\\,\\mathbf{K}_{\\text{bos}}\\,\\boldsymbol{\\sigma} + \\frac{\\lambda}{4}\\sum_{i=0}^{N-1}\\sigma_i^{4} \\;-\\; \\log\\det\\mathbf{M}(\\boldsymbol{\\sigma})\n$$\nWe compute the gradient $\\nabla S(\\boldsymbol{\\sigma})$, whose $k$-th component is $\\frac{\\partial S}{\\partial \\sigma_k}$, by considering each term separately.\n\n#### 1.1. Gradient of the Bosonic Term\n\nThe first term is the quadratic bosonic action, $S_{\\text{bos}}(\\boldsymbol{\\sigma}) = \\frac{1}{2}\\,\\boldsymbol{\\sigma}^{\\top}\\,\\mathbf{K}_{\\text{bos}}\\,\\boldsymbol{\\sigma}$.\nThe bosonic kernel is $\\mathbf{K}_{\\text{bos}} = m^{2}\\,\\mathbf{I} + \\kappa\\,\\mathbf{L}$. The identity matrix $\\mathbf{I}$ is symmetric. The lattice Laplacian $\\mathbf{L}$, defined by $(\\mathbf{L}\\boldsymbol{v})_{i} = 2 v_{i} - v_{i+1} - v_{i-1}$ with periodic boundary conditions, is a real symmetric matrix. Specifically, its elements are $L_{ii}=2$, $L_{i,i\\pm 1}=-1$ (indices modulo $N$), and $L_{ij}=0$ otherwise. Consequently, $\\mathbf{K}_{\\text{bos}}$ is a symmetric matrix.\n\nFor a general quadratic form $f(\\mathbf{x}) = \\frac{1}{2}\\mathbf{x}^{\\top}\\mathbf{A}\\mathbf{x}$ with a symmetric matrix $\\mathbf{A}$, the gradient is $\\nabla f(\\mathbf{x}) = \\mathbf{A}\\mathbf{x}$. Applying this rule, the gradient of the bosonic term is:\n$$\n\\nabla S_{\\text{bos}}(\\boldsymbol{\\sigma}) = \\mathbf{K}_{\\text{bos}}\\,\\boldsymbol{\\sigma}\n$$\n\n#### 1.2. Gradient of the Interaction Term\n\nThe second term is the quartic self-interaction, $S_{\\text{int}}(\\boldsymbol{\\sigma}) = \\frac{\\lambda}{4}\\sum_{i=0}^{N-1}\\sigma_i^{4}$.\nTo find the $k$-th component of the gradient, we differentiate with respect to $\\sigma_k$:\n$$\n\\frac{\\partial S_{\\text{int}}}{\\partial \\sigma_k} = \\frac{\\partial}{\\partial \\sigma_k} \\left( \\frac{\\lambda}{4}\\sum_{i=0}^{N-1}\\sigma_i^{4} \\right) = \\frac{\\lambda}{4} \\cdot (4\\sigma_k^3) = \\lambda\\sigma_k^3\n$$\nThis can be expressed in vector form using the element-wise (Hadamard) power operation, denoted by $\\circ 3$:\n$$\n\\nabla S_{\\text{int}}(\\boldsymbol{\\sigma}) = \\lambda\\,\\boldsymbol{\\sigma}^{\\circ 3}\n$$\n\n#### 1.3. Gradient of the Fermionic Term\n\nThe third term is the fermionic determinant term, $S_{\\text{ferm}}(\\boldsymbol{\\sigma}) = -\\log\\det\\mathbf{M}(\\boldsymbol{\\sigma})$.\nWe use the chain rule and Jacobi's formula for the differential of a determinant. For an invertible matrix $\\mathbf{A}$, $d(\\log\\det\\mathbf{A}) = \\mathrm{tr}(\\mathbf{A}^{-1}d\\mathbf{A})$. Applying this to our term:\n$$\nd S_{\\text{ferm}} = -d(\\log\\det\\mathbf{M}) = -\\mathrm{tr}(\\mathbf{M}^{-1}d\\mathbf{M})\n$$\nThe fermion matrix $\\mathbf{M}(\\boldsymbol{\\sigma}) = \\mathbf{I} + a\\,\\mathrm{diag}\\!\\left(\\exp(\\beta\\,\\boldsymbol{\\sigma})\\right) + t\\,\\mathbf{L}$ depends on $\\boldsymbol{\\sigma}$ only through the diagonal matrix $\\mathbf{D}(\\boldsymbol{\\sigma}) = a\\,\\mathrm{diag}\\!\\left(\\exp(\\beta\\,\\boldsymbol{\\sigma})\\right)$. The differential $d\\mathbf{M}$ is therefore equal to $d\\mathbf{D}$.\n\nThe components of $\\mathbf{D}$ are $D_{ij}(\\boldsymbol{\\sigma}) = a \\exp(\\beta\\sigma_i) \\delta_{ij}$. The partial derivative with respect to $\\sigma_k$ is:\n$$\n\\frac{\\partial D_{ij}}{\\partial \\sigma_k} = a \\frac{\\partial}{\\partial \\sigma_k} (\\exp(\\beta\\sigma_i)\\delta_{ij}) = a \\beta \\exp(\\beta\\sigma_i) \\delta_{ik} \\delta_{ij}\n$$\nThis is non-zero only when $i=j=k$. The matrix $\\frac{\\partial \\mathbf{M}}{\\partial \\sigma_k} = \\frac{\\partial \\mathbf{D}}{\\partial \\sigma_k}$ thus has only one non-zero entry at position $(k,k)$:\n$$\n\\left(\\frac{\\partial \\mathbf{M}}{\\partial \\sigma_k}\\right)_{kk} = a \\beta \\exp(\\beta\\sigma_k)\n$$\nThis can be written using the standard basis vector $\\mathbf{e}_k$ as $\\frac{\\partial \\mathbf{M}}{\\partial \\sigma_k} = a \\beta \\exp(\\beta\\sigma_k) \\mathbf{e}_k \\mathbf{e}_k^{\\top}$.\n\nThe total differential $d\\mathbf{M}$ is $d\\mathbf{M} = \\sum_{k=0}^{N-1} \\frac{\\partial \\mathbf{M}}{\\partial \\sigma_k} d\\sigma_k$. Substituting this into the trace expression:\n$$\nd S_{\\text{ferm}} = -\\mathrm{tr}\\left(\\mathbf{M}^{-1} \\sum_{k=0}^{N-1} a \\beta \\exp(\\beta\\sigma_k) \\mathbf{e}_k \\mathbf{e}_k^{\\top} d\\sigma_k\\right)\n$$\nBy linearity of the trace, we can move the summation outside:\n$$\nd S_{\\text{ferm}} = -\\sum_{k=0}^{N-1} a \\beta \\exp(\\beta\\sigma_k) \\mathrm{tr}(\\mathbf{M}^{-1} \\mathbf{e}_k \\mathbf{e}_k^{\\top}) d\\sigma_k\n$$\nUsing the cyclic property of the trace, $\\mathrm{tr}(\\mathbf{A}\\mathbf{B}) = \\mathrm{tr}(\\mathbf{B}\\mathbf{A})$, we have $\\mathrm{tr}(\\mathbf{M}^{-1} \\mathbf{e}_k \\mathbf{e}_k^{\\top}) = \\mathrm{tr}(\\mathbf{e}_k^{\\top}\\mathbf{M}^{-1}\\mathbf{e}_k)$. The term $\\mathbf{e}_k^{\\top}\\mathbf{M}^{-1}\\mathbf{e}_k$ is a $1 \\times 1$ matrix (a scalar) corresponding to the $k$-th diagonal element of $\\mathbf{M}^{-1}$, which we denote as $(\\mathbf{M}^{-1})_{kk}$.\nThe differential becomes:\n$$\nd S_{\\text{ferm}} = -\\sum_{k=0}^{N-1} a \\beta \\exp(\\beta\\sigma_k) (\\mathbf{M}^{-1})_{kk} d\\sigma_k\n$$\nBy definition, $d S_{\\text{ferm}} = \\sum_{k=0}^{N-1} (\\nabla S_{\\text{ferm}})_k d\\sigma_k$. Comparing coefficients yields the $k$-th component of the gradient:\n$$\n(\\nabla S_{\\text{ferm}})_k = -a \\beta \\exp(\\beta\\sigma_k) (\\mathbf{M}^{-1})_{kk}\n$$\nIn vector form, this is an element-wise product:\n$$\n\\nabla S_{\\text{ferm}}(\\boldsymbol{\\sigma}) = -a\\beta \\exp(\\beta\\boldsymbol{\\sigma}) \\circ \\mathrm{diag}(\\mathbf{M}(\\boldsymbol{\\sigma})^{-1})\n$$\nwhere $\\mathrm{diag}(\\mathbf{A}^{-1})$ denotes the vector of diagonal elements of the matrix $\\mathbf{A}^{-1}$.\n\n#### 1.4. Total Analytic Gradient\n\nCombining the gradients of the three terms gives the final expression for the analytic gradient of the action:\n$$\n\\nabla S(\\boldsymbol{\\sigma}) = \\mathbf{K}_{\\text{bos}}\\,\\boldsymbol{\\sigma} + \\lambda\\,\\boldsymbol{\\sigma}^{\\circ 3} - a \\beta \\exp(\\beta\\,\\boldsymbol{\\sigma}) \\circ \\mathrm{diag}(\\mathbf{M}(\\boldsymbol{\\sigma})^{-1})\n$$\n\n### 2. Algorithmic Design and Validation\n\nThe validation procedure involves implementing the derived analytic gradient and comparing it against a numerical finite-difference approximation.\n\n1.  **Matrix Construction**: For a given lattice size $N$, the periodic Laplacian matrix $\\mathbf{L}$ is constructed. Its elements are $L_{ii}=2$, $L_{i, (i-1+N)\\%N}=-1$, and $L_{i, (i+1)\\%N}=-1$. The bosonic kernel $\\mathbf{K}_{\\text{bos}}$ and fermion matrix $\\mathbf{M}(\\boldsymbol{\\sigma})$ are then built according to their definitions.\n\n2.  **Action and Gradient Implementation**: Three functions are implemented:\n    *   `action(sigma, ...)`: Computes $S(\\boldsymbol{\\sigma})$. The $\\log\\det\\mathbf{M}$ term is calculated using `numpy.linalg.slogdet`, which is numerically robust.\n    *   `analytic_gradient(sigma, ...)`: Computes $\\nabla S(\\boldsymbol{\\sigma})$ using the formula derived above. This requires computing the inverse of $\\mathbf{M}(\\boldsymbol{\\sigma})$ to extract its diagonal elements.\n    *   `fd_gradient(sigma, ...)`: Computes the central finite-difference gradient $(\\nabla S)^{\\text{FD}}$. For each component $i$, it perturbs $\\sigma_i$ by $\\pm \\varepsilon_i$, where $\\varepsilon_i = h(1 + |\\sigma_i|)$, recalculates the full action $S$ at $\\boldsymbol{\\sigma} \\pm \\varepsilon_i \\mathbf{e}_i$, and applies the standard central difference formula.\n\n3.  **Validation Protocol**: For each test case specified in the problem:\n    *   **Tolerance Estimation**: A tolerance `tol` is determined. A set of $N_{\\text{train}} = 5$ random field configurations are generated from a standard normal distribution using the seed $s_{\\text{train}}$. For each configuration, the discrepancy $d = \\|\\nabla S - (\\nabla S)^{\\text{FD}}\\|_{\\infty}$ and the analytic gradient norm $\\|\\nabla S\\|_{\\infty}$ are computed. The tolerance is set to $\\mathrm{tol} = 10 \\cdot \\mathrm{median}(\\{d_j\\}) + 10^{-12} \\cdot (1 + \\mathrm{median}(\\{\\|\\nabla S_j\\|_{\\infty}\\}))$.\n    *   **Testing**: An independent set of $N_{\\text{test}} = 3$ configurations are generated using the seed $s_{\\text{test}}$. The test case is marked as `Pass` (True) if and only if the discrepancy $d$ for all three test configurations is less than or equal to the computed tolerance `tol`. Otherwise, it is marked as `Fail` (False).\n\nThis comprehensive procedure ensures a robust verification of the analytic gradient implementation against a trusted numerical standard.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the validation tests for the lattice EFT model's action gradient.\n    \"\"\"\n\n    test_cases = [\n        # (N, m, kappa, lambda, a, beta, t, h, s_train, s_test)\n        (4, 0.5, 1.0, 0.1, 0.7, 0.6, 0.2, 1e-6, 12345, 54321),\n        (2, 3.0, 0.0, 0.0, 0.25, 0.8, 0.0, 1e-6, 22345, 64321),\n        (8, 0.1, 2.0, 0.0, 0.5, 1.0, 0.5, 1e-6, 32345, 74321),\n        (6, 1.2, 0.5, 0.5, 1.0, 1.2, 0.3, 1e-8, 42345, 84321),\n    ]\n\n    results = []\n    \n    for case_params in test_cases:\n        result = process_case(case_params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef process_case(params):\n    \"\"\"\n    Processes a single test case: calculates tolerance and performs validation.\n    \"\"\"\n    N, m, kappa, lamb, a, beta, t, h, s_train, s_test = params\n    \n    # Pre-compute the static part of matrices\n    L = build_laplacian(N)\n    K_bos = m**2 * np.eye(N) + kappa * L\n\n    # Helper function to pass static matrices\n    def get_action(sigma):\n        return action(sigma, N, lamb, a, beta, t, L, K_bos)\n    \n    def get_analytic_grad(sigma):\n        return analytic_gradient(sigma, N, lamb, a, beta, t, L, K_bos)\n\n    def get_fd_grad(sigma):\n        return fd_gradient(sigma, h, get_action)\n\n    # --- Task 3: Tolerance Estimation ---\n    N_train = 5\n    rng_train = np.random.default_rng(s_train)\n    \n    discrepancies_train = []\n    grad_norms_train = []\n\n    for _ in range(N_train):\n        sigma = rng_train.standard_normal(N)\n        \n        grad_analytic = get_analytic_grad(sigma)\n        grad_fd = get_fd_grad(sigma)\n        \n        d = np.linalg.norm(grad_analytic - grad_fd, ord=np.inf)\n        discrepancies_train.append(d)\n        \n        grad_norm = np.linalg.norm(grad_analytic, ord=np.inf)\n        grad_norms_train.append(grad_norm)\n        \n    median_d = np.median(discrepancies_train)\n    median_grad_norm = np.median(grad_norms_train)\n    scale_proxy = 1.0 + median_grad_norm\n    tol = 10.0 * median_d + 1e-12 * scale_proxy\n\n    # --- Task 4: Validation ---\n    N_test = 3\n    rng_test = np.random.default_rng(s_test)\n    case_passed = True\n    \n    for _ in range(N_test):\n        sigma = rng_test.standard_normal(N)\n        \n        grad_analytic = get_analytic_grad(sigma)\n        grad_fd = get_fd_grad(sigma)\n        \n        d_test = np.linalg.norm(grad_analytic - grad_fd, ord=np.inf)\n\n        if d_test > tol:\n            case_passed = False\n            break\n            \n    return case_passed\n\ndef build_laplacian(N):\n    \"\"\"Constructs the 1D periodic nearest-neighbor lattice Laplacian matrix L.\"\"\"\n    eye_N = np.eye(N)\n    # L = 2I - P_f - P_b, where P_f is forward shift and P_b is backward shift\n    # np.roll(eye, 1, axis=0) is P_f\n    # np.roll(eye, -1, axis=0) is P_b\n    L = 2 * eye_N - np.roll(eye_N, 1, axis=0) - np.roll(eye_N, -1, axis=0)\n    return L\n\ndef action(sigma, N, lamb, a, beta, t, L, K_bos):\n    \"\"\"Computes the Euclidean action S(sigma).\"\"\"\n    # Bosonic term\n    s_bos = 0.5 * sigma.T @ K_bos @ sigma\n    \n    # Quartic interaction term\n    s_int = (lamb / 4.0) * np.sum(sigma**4)\n    \n    # Fermionic term\n    M = np.eye(N) + a * np.diag(np.exp(beta * sigma)) + t * L\n    \n    # M must be SPD as per problem statement, so sign of det is +1\n    sign, logdet = np.linalg.slogdet(M) \n    if sign != 1:\n        # This should not happen with the given problem parameters\n        # but is good practice to check.\n        return np.inf\n    \n    s_ferm = -logdet\n    \n    return s_bos + s_int + s_ferm\n\ndef analytic_gradient(sigma, N, lamb, a, beta, t, L, K_bos):\n    \"\"\"Computes the analytic gradient of the action, nabla S(sigma).\"\"\"\n    # Gradient of bosonic term\n    grad_bos = K_bos @ sigma\n    \n    # Gradient of quartic interaction term\n    grad_int = lamb * (sigma**3)\n    \n    # Gradient of fermionic term\n    M = np.eye(N) + a * np.diag(np.exp(beta * sigma)) + t * L\n    M_inv = np.linalg.inv(M)\n    diag_M_inv = np.diag(M_inv)\n    \n    grad_ferm = -a * beta * np.exp(beta * sigma) * diag_M_inv\n    \n    return grad_bos + grad_int + grad_ferm\n\ndef fd_gradient(sigma, h, action_func):\n    \"\"\"Computes the central finite-difference approximation of the gradient.\"\"\"\n    N = len(sigma)\n    grad_fd = np.zeros(N)\n    \n    for i in range(N):\n        sigma_i = sigma[i]\n        eps_i = h * (1.0 + np.abs(sigma_i))\n        \n        sigma_plus = sigma.copy()\n        sigma_plus[i] += eps_i\n        \n        sigma_minus = sigma.copy()\n        sigma_minus[i] -= eps_i\n        \n        s_plus = action_func(sigma_plus)\n        s_minus = action_func(sigma_minus)\n        \n        grad_fd[i] = (s_plus - s_minus) / (2.0 * eps_i)\n        \n    return grad_fd\n\n# Run the solver\nsolve()\n```", "id": "3563928"}, {"introduction": "With verification techniques established, you are ready to implement the heart of the Hybrid Monte Carlo algorithm for fermions: the pseudofermion force. This practice guides you through setting up the fermion matrix for a simple lattice and using the Conjugate Gradient method to solve the required linear system, from which the force is computed [@problem_id:3563810]. Mastering this task is a key step towards building a complete HMC simulation for Lattice EFT.", "problem": "Consider a spinless fermion auxiliary-field formulation used in Hybrid Monte Carlo (HMC) for Lattice Effective Field Theory (EFT). The pseudofermion representation of the determinant yields the pseudofermion action $S_{\\mathrm{pf}}$ defined by $S_{\\mathrm{pf}} = \\boldsymbol{\\phi}^{\\dagger} \\left(M^{\\dagger} M\\right)^{-1} \\boldsymbol{\\phi}$, where $M[\\boldsymbol{\\sigma}]$ is the fermion matrix depending on the auxiliary field configuration $\\boldsymbol{\\sigma}$ and $\\boldsymbol{\\phi}$ is a fixed pseudofermion field. The HMC force component associated with the auxiliary field degree of freedom at a lattice site is the negative gradient of the total action with respect to that field; for the pseudofermion part alone this leads to a force component $F_i$ at site $i$ given by $F_i = \\boldsymbol{\\chi}^{\\dagger} \\left(\\frac{\\partial}{\\partial \\sigma_i} \\left(M^{\\dagger} M\\right)\\right) \\boldsymbol{\\chi}$, where $\\boldsymbol{\\chi}$ solves the linear system $\\left(M^{\\dagger} M\\right)\\boldsymbol{\\chi} = \\boldsymbol{\\phi}$. You are to compute the numerical value of a single force component $F_x$ at a specified site on a small lattice using Conjugate Gradient on the Normal Equations (CGNE).\n\nThe lattice is a four-dimensional hypercubic lattice of size $2^3 \\times 2$, i.e., spatial extents $N_x = 2$, $N_y = 2$, $N_z = 2$ and temporal extent $N_t = 2$ with periodic boundary conditions in all four directions. The total number of lattice sites is $N = 16$. Use a canonical site indexing $i = i(x,y,z,t)$ that uniquely maps coordinates $(x,y,z,t)$ with $x,y,z \\in \\{0,1\\}$ and $t \\in \\{0,1\\}$ to an integer index $i \\in \\{0,1,\\dots,15\\}$ via $i = x + 2 y + 4 z + 8 t$.\n\nDefine the fermion matrix $M[\\boldsymbol{\\sigma}] \\in \\mathbb{R}^{N \\times N}$ by\n$$\nM_{ij}[\\boldsymbol{\\sigma}] = \\delta_{ij} + g\\,\\sigma_i\\,\\delta_{ij} - \\kappa \\sum_{\\mu \\in \\{x,y,z,t\\}} \\left(\\delta_{j, i+\\hat{\\mu}} + \\delta_{j, i-\\hat{\\mu}}\\right),\n$$\nwhere $\\kappa$ is a nearest-neighbor hopping parameter, $g$ is the coupling to the auxiliary field, $\\sigma_i$ is the value of the auxiliary field at site $i$, $\\delta_{ij}$ is the Kronecker delta, and $i \\pm \\hat{\\mu}$ denote the nearest neighbors of site $i$ in the positive/negative $\\mu$ direction with periodic boundary conditions. The dependence on $\\boldsymbol{\\sigma}$ is strictly diagonal and linear, so $\\frac{\\partial M}{\\partial \\sigma_i} = g E_i$, with $E_i$ the diagonal matrix having a $1$ at position $(i,i)$ and zeros elsewhere. From this, the derivative of the normal matrix satisfies\n$$\n\\frac{\\partial}{\\partial \\sigma_i} \\left(M^{\\dagger} M\\right) = g \\left(E_i M + M^{\\dagger} E_i\\right).\n$$\n\nLet the auxiliary field configuration be specified deterministically by\n$$\n\\sigma(x,y,z,t) = 0.2\\,(-1)^{x+y+z+t} + 0.05\\,(x - y),\n$$\nwhich, via the indexing rule, defines $\\sigma_i$ for all $i \\in \\{0,\\dots,15\\}$. Let the pseudofermion field $\\boldsymbol{\\phi} \\in \\mathbb{R}^N$ be specified component-wise by\n$$\n\\phi_i = \\cos\\left(0.37\\,(i+1)\\right) + 0.1\\,\\sin\\left(0.13\\,(i+1)\\right), \\quad i = 0,1,\\dots,15.\n$$\n\nYou must compute the pseudofermion force component $F_x$ at the single site with coordinates $(x,y,z,t) = (1,0,0,1)$, i.e., at index $i_x = i(1,0,0,1) = 9$, defined by\n$$\nF_x \\equiv F_{i_x} = \\boldsymbol{\\chi}^{\\dagger} \\left(\\frac{\\partial}{\\partial \\sigma_{i_x}} \\left(M^{\\dagger} M\\right)\\right) \\boldsymbol{\\chi} = g \\left(\\boldsymbol{\\chi}^{\\dagger} E_{i_x} M \\boldsymbol{\\chi} + \\boldsymbol{\\chi}^{\\dagger} M^{\\dagger} E_{i_x} \\boldsymbol{\\chi}\\right) = 2g\\,\\mathrm{Re}\\left(\\overline{\\chi_{i_x}} \\,(M\\boldsymbol{\\chi})_{i_x}\\right),\n$$\nwhere $\\boldsymbol{\\chi}$ is the solution of $\\left(M^{\\dagger} M\\right)\\boldsymbol{\\chi} = \\boldsymbol{\\phi}$ obtained numerically using Conjugate Gradient on the Normal Equations with a relative residual tolerance of $\\varepsilon = 10^{-12}$ and a maximum of $1000$ iterations. All computations are real-valued here, so $\\mathrm{Re}$ reduces to the identity.\n\nImplement a program that constructs $M[\\boldsymbol{\\sigma}]$ from the given data, solves for $\\boldsymbol{\\chi}$ using CGNE, and computes $F_x$ as above for each of the following parameter sets $(\\kappa,g)$:\n\n- Test case $1$ (general case): $\\kappa = 0.08$, $g = 0.30$.\n- Test case $2$ (diagonal limit): $\\kappa = 0.00$, $g = 0.30$.\n- Test case $3$ (no coupling limit): $\\kappa = 0.08$, $g = 0.00$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each $F_x$ reported as a floating point number rounded to $8$ decimal places, in the order of the test cases above. For example, the output format must be exactly like $[f_1,f_2,f_3]$, where $f_j$ are the computed numerical values for test case $j$.\n\nNo physical units are involved; all quantities are dimensionless. Angles, where present in trigonometric functions, are in radians. The final numerical outputs must be floats. The solution must use Conjugate Gradient on the Normal Equations to compute $\\boldsymbol{\\chi}$ for each test case independently.", "solution": "The problem statement is assessed to be valid. It is scientifically sound, well-posed, objective, and contains all necessary information to proceed with a unique, verifiable solution. The problem lies within the established framework of computational nuclear physics, specifically addressing algorithm implementation for Hybrid Monte Carlo simulations on a lattice.\n\nThe primary objective is to compute the pseudofermion force component, $F_x$, at a specific lattice site $i_x$, for three distinct sets of physical parameters $(\\kappa, g)$. The force $F_x$ is derived from the pseudofermion action $S_{\\mathrm{pf}} = \\boldsymbol{\\phi}^{\\dagger} \\left(M^{\\dagger} M\\right)^{-1} \\boldsymbol{\\phi}$, and its component at site $i$ is given by $F_i = -\\frac{\\partial S_{\\mathrm{pf}}}{\\partial \\sigma_i}$. This computation involves several well-defined steps.\n\nFirst, we define the computational domain, which is a four-dimensional hypercubic lattice of size $N_x \\times N_y \\times N_z \\times N_t = 2 \\times 2 \\times 2 \\times 2$, resulting in a total of $N=16$ sites. Periodic boundary conditions are applied in all four dimensions. A canonical mapping from site coordinates $(x,y,z,t)$ (with $x,y,z,t \\in \\{0,1\\}$) to a single integer index $i \\in \\{0, 1, \\dots, 15\\}$ is given by $i = x + 2y + 4z + 8t$.\n\nThe core of the model is the real-valued fermion matrix $M[\\boldsymbol{\\sigma}] \\in \\mathbb{R}^{N \\times N}$, defined by its elements:\n$$\nM_{ij}[\\boldsymbol{\\sigma}] = (1 + g\\,\\sigma_i)\\delta_{ij} - \\kappa \\sum_{\\mu \\in \\{x,y,z,t\\}} \\left(\\delta_{j, i+\\hat{\\mu}} + \\delta_{j, i-\\hat{\\mu}}\\right)\n$$\nHere, $\\delta_{ij}$ is the Kronecker delta, $g$ is a coupling constant, $\\kappa$ is the hopping parameter, and $\\boldsymbol{\\sigma}$ is a background auxiliary field. The term $i\\pm\\hat{\\mu}$ indicates the nearest neighbor of site $i$ in the $\\pm\\mu$ direction. The auxiliary field $\\boldsymbol{\\sigma}$ and the pseudofermion field $\\boldsymbol{\\phi}$ are specified deterministically for all sites $i$:\n$$\n\\sigma_i = \\sigma(x,y,z,t) = 0.2\\,(-1)^{x+y+z+t} + 0.05\\,(x - y)\n$$\n$$\n\\phi_i = \\cos\\left(0.37\\,(i+1)\\right) + 0.1\\,\\sin\\left(0.13\\,(i+1)\\right)\n$$\n\nThe force calculation requires an intermediate vector, $\\boldsymbol{\\chi}$, which is determined by solving the linear system of normal equations:\n$$\n\\left(M^{\\dagger} M\\right)\\boldsymbol{\\chi} = \\boldsymbol{\\phi}\n$$\nSince $M$ is a real matrix, $M^{\\dagger} = M^T$. The matrix $A = M^T M$ is symmetric and positive definite (for the given parameters where $M$ is invertible), making the standard Conjugate Gradient (CG) algorithm an appropriate and efficient solver. The problem specifies a relative residual tolerance of $\\varepsilon = 10^{-12}$ and a maximum of $1000$ iterations for the CG solver. The CG algorithm iteratively finds the solution $\\boldsymbol{\\chi}$ starting from an initial guess $\\boldsymbol{\\chi}_0 = \\mathbf{0}$.\n\nOnce $\\boldsymbol{\\chi}$ is found, the force component $F_x$ at the target site $i_x=i(1,0,0,1)=9$ is computed. The general formula for the force is $F_i = \\boldsymbol{\\chi}^{\\dagger} (\\frac{\\partial}{\\partial \\sigma_i} (M^{\\dagger} M)) \\boldsymbol{\\chi}$. Using the provided derivative $\\frac{\\partial}{\\partial \\sigma_i} (M^{\\dagger} M) = g (E_i M + M^{\\dagger} E_i)$, where $E_i$ is a matrix with a single non-zero element $(E_i)_{ii}=1$, the force simplifies. Since all quantities are real, we have:\n$$\nF_{i_x} = \\boldsymbol{\\chi}^T \\left( g(E_{i_x} M + M^T E_{i_x}) \\right) \\boldsymbol{\\chi} = g (\\boldsymbol{\\chi}^T E_{i_x} M \\boldsymbol{\\chi} + \\boldsymbol{\\chi}^T M^T E_{i_x} \\boldsymbol{\\chi})\n$$\nRecognizing that $E_{i_x}$ projects onto the component $i_x$, this becomes:\n$$\nF_{i_x} = g (\\chi_{i_x} (M\\boldsymbol{\\chi})_{i_x} + (M^T\\boldsymbol{\\chi})_{i_x} \\chi_{i_x})\n$$\nSince $\\boldsymbol{\\chi}^T M^T E_{i_x} \\boldsymbol{\\chi}$ is a scalar, it equals its transpose, $(\\boldsymbol{\\chi}^T E_{i_x} M \\boldsymbol{\\chi})^T = \\boldsymbol{\\chi}^T M^T E_{i_x}^T \\boldsymbol{\\chi}$. As $E_{i_x}$ is diagonal, $E_{i_x}^T = E_{i_x}$. Thus, the two terms are identical. The final expression for the force is:\n$$\nF_x \\equiv F_{i_x} = 2g\\,\\chi_{i_x}\\,(M\\boldsymbol{\\chi})_{i_x}\n$$\nThis calculation is performed for each of the three test cases:\n1.  $(\\kappa, g) = (0.08, 0.30)$: The general case requiring the full numerical procedure.\n2.  $(\\kappa, g) = (0.00, 0.30)$: The hopping term vanishes, making $M$ a diagonal matrix. The solution $\\boldsymbol{\\chi}$ can be found analytically, $\\chi_i = \\phi_i / (1+g\\sigma_i)^2$, which serves as a check for the CG solver's result.\n3.  $(\\kappa, g) = (0.08, 0.00)$: The coupling $g$ is zero. The force expression $F_x = 2g\\,\\dots$ immediately implies $F_x=0$, providing a trivial but important sanity check.\n\nThe implementation will construct the matrix $M$ and fields $\\boldsymbol{\\sigma}, \\boldsymbol{\\phi}$ for each case, solve for $\\boldsymbol{\\chi}$ using a custom CG solver, and then compute $F_x$ according to the derived formula.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It computes the pseudofermion force component F_x for three sets of parameters.\n    \"\"\"\n    # Define lattice dimensions and target site for force calculation.\n    NX, NY, NZ, NT = 2, 2, 2, 2\n    N = NX * NY * NZ * NT\n    ix_coords = (1, 0, 0, 1)\n\n    # Define the three test cases as tuples of (kappa, g).\n    test_cases = [\n        (0.08, 0.30),\n        (0.00, 0.30),\n        (0.08, 0.00),\n    ]\n\n    # Helper functions for mapping between coordinates and linear index.\n    def coords_to_index(c):\n        x, y, z, t = c\n        return x + NX * (y + NY * (z + NZ * t))\n\n    def index_to_coords(i):\n        t = i // (NX * NY * NZ)\n        i %= (NX * NY * NZ)\n        z = i // (NX * NY)\n        i %= (NX * NY)\n        y = i // NX\n        x = i % NX\n        return (x, y, z, t)\n    \n    # Get the linear index of the target site.\n    ix = coords_to_index(ix_coords)\n\n    # Pre-calculate neighbor indices for all sites to build M efficiently.\n    neighbors = np.zeros((N, 8), dtype=int)\n    for i in range(N):\n        x, y, z, t = index_to_coords(i)\n        # Neighbors in +x, -x, +y, -y, +z, -z, +t, -t directions.\n        neighbors[i, 0] = coords_to_index(((x + 1) % NX, y, z, t))\n        neighbors[i, 1] = coords_to_index(((x - 1 + NX) % NX, y, z, t))\n        neighbors[i, 2] = coords_to_index((x, (y + 1) % NY, z, t))\n        neighbors[i, 3] = coords_to_index((x, (y - 1 + NY) % NY, z, t))\n        neighbors[i, 4] = coords_to_index((x, y, (z + 1) % NZ, t))\n        neighbors[i, 5] = coords_to_index((x, y, (z - 1 + NZ) % NZ, t))\n        neighbors[i, 6] = coords_to_index((x, y, z, (t + 1) % NT))\n        neighbors[i, 7] = coords_to_index((x, y, z, (t - 1 + NT) % NT))\n\n    # Pre-calculate auxiliary field sigma and pseudofermion field phi.\n    # These are independent of the test case parameters.\n    sigma = np.zeros(N)\n    for i in range(N):\n        x, y, z, t = index_to_coords(i)\n        sigma[i] = 0.2 * (-1)**(x + y + z + t) + 0.05 * (x - y)\n\n    phi = np.zeros(N)\n    for i in range(N):\n        phi[i] = np.cos(0.37 * (i + 1)) + 0.1 * np.sin(0.13 * (i + 1))\n\n    results = []\n    for kappa, g in test_cases:\n        # Trivial case: if g=0, the force is zero.\n        if g == 0.0:\n            results.append(f\"{0.0:.8f}\")\n            continue\n\n        # Construct the fermion matrix M.\n        M = np.zeros((N, N), dtype=float)\n        for i in range(N):\n            M[i, i] = 1.0 + g * sigma[i]\n            if kappa != 0.0:\n                for neighbor_idx in neighbors[i]:\n                    M[i, neighbor_idx] -= kappa\n\n        # Define the system A*chi = b for the CG solver.\n        # A = M^T * M, b = phi.\n        A = M.T @ M\n        b = phi\n\n        # Solve for chi using Conjugate Gradient.\n        chi = cg_solver(A, b, tol=1e-12, max_iter=1000)\n\n        # Calculate the force F_x = 2 * g * chi_ix * (M*chi)_ix.\n        M_chi = M @ chi\n        force = 2.0 * g * chi[ix] * M_chi[ix]\n        results.append(f\"{force:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef cg_solver(A, b, tol, max_iter):\n    \"\"\"\n    Solves the linear system A*x = b using the Conjugate Gradient algorithm.\n    A must be a symmetric positive-definite matrix.\n    \"\"\"\n    x = np.zeros_like(b, dtype=float)\n    r = b - A @ x\n    p = r.copy()\n    rs_old = np.dot(r, r)\n\n    # Calculate norm of b for relative residual check.\n    b_norm = np.linalg.norm(b)\n    if b_norm == 0.0:\n        return x # Trivial solution\n\n    for _ in range(max_iter):\n        Ap = A @ p\n        p_Ap = np.dot(p, Ap)\n        \n        # If curvature is zero or negative, CG might fail.\n        # For a positive definite matrix, this should not happen with non-zero p.\n        if p_Ap = 0:\n            break\n\n        alpha = rs_old / p_Ap\n        x += alpha * p\n        r -= alpha * Ap\n        rs_new = np.dot(r, r)\n\n        # Convergence check using relative residual norm.\n        if np.sqrt(rs_new) / b_norm  tol:\n            break\n\n        p = r + (rs_new / rs_old) * p\n        rs_old = rs_new\n\n    return x\n\nsolve()\n```", "id": "3563810"}, {"introduction": "A correct but slow simulation has limited utility, and real-world actions in Lattice EFT often have components with vastly different force magnitudes and computational costs. This practice challenges you to address this by designing an optimized multiple time scale integrator [@problem_id:3563901]. You will apply a standard cost-benefit analysis to determine an optimal integration schedule, a crucial step in developing efficient, large-scale HMC simulations.", "problem": "Consider a Hybrid Monte Carlo (HMC) scheme applied to a lattice Effective Field Theory (EFT) system whose action decomposes into three factors, denoted by $S_{0}$ (long-range pion field), $S_{1}$ (short-range contact interaction), and $S_{2}$ (fermion determinant). You will design a nested multiple time scale second-order Omelyan integrator to evolve fictitious molecular dynamics trajectories of fixed length $\\tau = 1$ (in lattice time units). The integrator uses an outermost time step $h_{0}$ for $S_{0}$, a subdivision factor $m_{1}$ to define a level-$1$ step size $h_{1} = h_{0}/m_{1}$ for $S_{1}$, and a further subdivision factor $m_{2}$ to define a level-$2$ step size $h_{2} = h_{0}/(m_{1} m_{2})$ for $S_{2}$. In each outermost step, the force from $S_{0}$ is evaluated once, the force from $S_{1}$ is evaluated $m_{1}$ times, and the force from $S_{2}$ is evaluated $m_{1} m_{2}$ times.\n\nAssume the following well-tested modeling facts for reversible, area-preserving second-order integrators:\n- The leading trajectory energy violation variance is modeled as\n$$\n\\operatorname{Var}(\\Delta H) \\;=\\; \\alpha_{0} h_{0}^{4} \\;+\\; \\alpha_{1} \\left(\\frac{h_{0}}{m_{1}}\\right)^{4} \\;+\\; \\alpha_{2} \\left(\\frac{h_{0}}{m_{1} m_{2}}\\right)^{4},\n$$\nwhere $\\alpha_{i}0$ are measured error-coefficient parameters for each factor.\n- The expected Metropolis acceptance probability is\n$$\nP_{\\mathrm{acc}} \\;=\\; \\operatorname{erfc}\\!\\left(\\frac{\\sqrt{\\operatorname{Var}(\\Delta H)}}{2}\\right),\n$$\nwhere $\\operatorname{erfc}$ is the complementary error function.\n- The total computational cost per trajectory (in relative cost units) is modeled as\n$$\nC \\;=\\; \\frac{\\tau}{h_{0}}\\left(c_{0} \\;+\\; c_{1} m_{1} \\;+\\; c_{2} m_{1} m_{2}\\right),\n$$\nwhere $c_{i}0$ are the measured relative costs per force evaluation of factor $S_{i}$.\n\nYou are given the following calibrated measurements (from short diagnostic runs at comparable lattice parameters):\n- $\\alpha_{0} = 4$, $\\alpha_{1} = 40$, $\\alpha_{2} = 12800$.\n- $c_{0} = 1$, $c_{1} = 10$, $c_{2} = 100$.\n- $\\tau = 1$.\n\nDesign the continuous (real-valued) multiple time scale schedule by choosing $h_{0}0$, $m_{1}0$, $m_{2}0$ to minimize the cost $C$ subject to the acceptance probability constraint $P_{\\mathrm{acc}} \\geq P^{\\star}$ with $P^{\\star} = 0.8$. After solving the continuous optimization, round the subdivision factors $m_{1}$ and $m_{2}$ to the nearest integers, recompute $h_{0}$ to exactly satisfy the acceptance constraint with these integer subdivisions, and then compute the expected acceptance $P_{\\mathrm{acc}}$ and the resulting cost $C$.\n\nRound the acceptance to four significant figures and the cost to three significant figures. Express the cost using the unit “cost units.” Your final answer must be the ordered pair of acceptance and cost as a row matrix.", "solution": "The user wants me to solve an optimization problem for a Hybrid Monte Carlo (HMC) simulation. I will first validate the problem statement and then proceed with the solution.\n\n### Step 1: Extract Givens\n- **System**: A lattice Effective Field Theory (EFT) model with an action decomposed into three factors: $S_{0}$ (long-range pion field), $S_{1}$ (short-range contact interaction), and $S_{2}$ (fermion determinant).\n- **Integrator**: A nested multiple time scale second-order Omelyan integrator.\n- **Trajectory Length**: $\\tau = 1$ (in lattice time units).\n- **Time Steps**:\n    - Outermost time step: $h_{0}$ for $S_{0}$.\n    - Level-$1$ time step: $h_{1} = h_{0}/m_{1}$ for $S_{1}$, with subdivision factor $m_{1}$.\n    - Level-$2$ time step: $h_{2} = h_{1}/m_{2} = h_{0}/(m_{1} m_{2})$ for $S_{2}$, with subdivision factor $m_{2}$.\n- **Force Evaluations per Outer Step**: $1$ for $S_{0}$, $m_{1}$ for $S_{1}$, and $m_{1} m_{2}$ for $S_{2}$.\n- **Energy Violation Variance Model**:\n$$\n\\operatorname{Var}(\\Delta H) = \\alpha_{0} h_{0}^{4} + \\alpha_{1} \\left(\\frac{h_{0}}{m_{1}}\\right)^{4} + \\alpha_{2} \\left(\\frac{h_{0}}{m_{1} m_{2}}\\right)^{4}\n$$\n- **Acceptance Probability Model**:\n$$\nP_{\\mathrm{acc}} = \\operatorname{erfc}\\left(\\frac{\\sqrt{\\operatorname{Var}(\\Delta H)}}{2}\\right)\n$$\n- **Computational Cost Model**:\n$$\nC = \\frac{\\tau}{h_{0}}\\left(c_{0} + c_{1} m_{1} + c_{2} m_{1} m_{2}\\right)\n$$\n- **Model Parameters**:\n    - Error coefficients: $\\alpha_{0} = 4$, $\\alpha_{1} = 40$, $\\alpha_{2} = 12800$.\n    - Cost coefficients: $c_{0} = 1$, $c_{1} = 10$, $c_{2} = 100$.\n- **Optimization Goal**: Minimize cost $C$ by choosing continuous (real-valued) $h_{0}0$, $m_{1}0$, $m_{2}0$.\n- **Constraint**: $P_{\\mathrm{acc}} \\geq P^{\\star}$ with $P^{\\star} = 0.8$.\n- **Final Steps**:\n    1. Round the optimized continuous $m_{1}$ and $m_{2}$ to the nearest integers.\n    2. Recompute $h_{0}$ to exactly satisfy the acceptance constraint with the integer subdivisions.\n    3. Compute the final expected acceptance $P_{\\mathrm{acc}}$ and the resulting cost $C$.\n    4. Round $P_{\\mathrm{acc}}$ to four significant figures and $C$ to three significant figures.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, arising from the common task of optimizing algorithm parameters in computational physics, specifically for HMC simulations. The models for energy violation, acceptance probability, and computational cost are standard and well-established in this field. The problem is well-posed: it specifies an objective function to minimize ($C$), a set of variables to optimize ($h_0, m_1, m_2$), and a well-defined constraint ($P_{\\mathrm{acc}} \\geq P^{\\star}$). All necessary data and parameters are provided, making the problem self-contained. The language is objective and precise. No scientific, logical, or structural flaws are detected.\n\n### Step 3: Verdict and Action\nThe problem is valid. I will proceed to solve it.\n\n### Solution\nThe objective is to minimize the computational cost $C$ subject to a minimum acceptance probability constraint $P_{\\mathrm{acc}} \\geq P^{\\star}$. The cost $C$ is a monotonically decreasing function of the outermost time step $h_0$. To minimize $C$, we must choose the largest possible $h_0$ that satisfies the constraint. The acceptance probability $P_{\\mathrm{acc}}$ is a monotonically decreasing function of the energy violation variance $\\operatorname{Var}(\\Delta H)$. Therefore, the largest $h_0$ is obtained when the constraint is saturated, i.e., $P_{\\mathrm{acc}} = P^{\\star} = 0.8$.\n\nFirst, we determine the maximum allowed variance, $\\operatorname{Var}(\\Delta H)_{\\max}$, corresponding to $P_{\\mathrm{acc}} = 0.8$:\n$$\n0.8 = \\operatorname{erfc}\\left(\\frac{\\sqrt{\\operatorname{Var}(\\Delta H)_{\\max}}}{2}\\right)\n$$\nTaking the inverse complementary error function, $\\operatorname{erfc}^{-1}$, of both sides:\n$$\n\\operatorname{erfc}^{-1}(0.8) = \\frac{\\sqrt{\\operatorname{Var}(\\Delta H)_{\\max}}}{2}\n$$\nNumerically, $\\operatorname{erfc}^{-1}(0.8) \\approx 0.179143$. Thus,\n$$\n\\sqrt{\\operatorname{Var}(\\Delta H)_{\\max}} = 2 \\times 0.179143 = 0.358286\n$$\n$$\n\\operatorname{Var}(\\Delta H)_{\\max} = (0.358286)^2 \\approx 0.128369\n$$\nLet's denote this maximum allowed variance as $V_{\\max}$. The constraint becomes $\\operatorname{Var}(\\Delta H) = V_{\\max}$.\n\nThe problem is to minimize $C$ subject to $\\operatorname{Var}(\\Delta H) = V_{\\max}$. Let's define the time steps for each part of the action as $h_0$, $h_1 = h_0/m_1$, and $h_2 = h_1/m_2 = h_0/(m_1 m_2)$. The cost and variance can be re-expressed in terms of these individual time steps:\n$$\n\\operatorname{Var}(\\Delta H) = \\alpha_{0} h_{0}^{4} + \\alpha_{1} h_{1}^{4} + \\alpha_{2} h_{2}^{4} = V_{\\max}\n$$\n$$\nC = \\frac{\\tau c_0}{h_0} + \\frac{\\tau c_1}{h_1} + \\frac{\\tau c_2}{h_2}\n$$\nThis is a constrained optimization problem for the variables $h_0$, $h_1$, $h_2$. We use the method of Lagrange multipliers. The Lagrangian $\\mathcal{L}$ is:\n$$\n\\mathcal{L}(h_0, h_1, h_2, \\lambda) = \\sum_{i=0}^{2} \\frac{\\tau c_i}{h_i} + \\lambda \\left(\\sum_{i=0}^{2} \\alpha_i h_i^4 - V_{\\max}\\right)\n$$\nSetting the partial derivatives with respect to each $h_i$ to zero gives the optimality conditions:\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial h_i} = -\\frac{\\tau c_i}{h_i^2} + 4 \\lambda \\alpha_i h_i^3 = 0\n$$\n$$\n\\implies h_i^5 = \\frac{\\tau c_i}{4 \\lambda \\alpha_i}\n$$\nThis implies that at the optimum, $h_i^5 \\propto c_i / \\alpha_i$. We can find the optimal ratios of the step sizes, which determine the subdivision factors $m_1$ and $m_2$:\n$$\nm_1^5 = \\left(\\frac{h_0}{h_1}\\right)^5 = \\frac{c_0/\\alpha_0}{c_1/\\alpha_1} = \\frac{c_0 \\alpha_1}{c_1 \\alpha_0}\n$$\n$$\nm_2^5 = \\left(\\frac{h_1}{h_2}\\right)^5 = \\frac{c_1/\\alpha_1}{c_2/\\alpha_2} = \\frac{c_1 \\alpha_2}{c_2 \\alpha_1}\n$$\nSubstituting the given parameter values:\n- $\\alpha_{0} = 4$, $\\alpha_{1} = 40$, $\\alpha_{2} = 12800$\n- $c_{0} = 1$, $c_{1} = 10$, $c_{2} = 100$\n\nWe find the optimal continuous values for $m_1$ and $m_2$:\n$$\nm_1^5 = \\frac{1 \\times 40}{10 \\times 4} = \\frac{40}{40} = 1 \\implies m_1 = 1\n$$\n$$\nm_2^5 = \\frac{10 \\times 12800}{100 \\times 40} = \\frac{128000}{4000} = 32 \\implies m_2 = 2\n$$\nThe problem requires rounding these to the nearest integers. Since the optimal continuous values are already integers, the integer subdivision factors are $m_1 = 1$ and $m_2 = 2$.\n\nNext, we recompute $h_0$ to satisfy the acceptance constraint exactly with these integer subdivisions. The constraint is $\\operatorname{Var}(\\Delta H) = V_{\\max}$.\n$$\n\\operatorname{Var}(\\Delta H) = h_{0}^{4} \\left( \\alpha_{0} + \\frac{\\alpha_{1}}{m_{1}^{4}} + \\frac{\\alpha_{2}}{m_{1}^{4} m_{2}^{4}} \\right) = V_{\\max}\n$$\nSubstituting values:\n$$\nh_0^4 \\left( 4 + \\frac{40}{1^4} + \\frac{12800}{1^4 \\times 2^4} \\right) = V_{\\max}\n$$\n$$\nh_0^4 \\left( 4 + 40 + \\frac{12800}{16} \\right) = V_{\\max}\n$$\n$$\nh_0^4 (44 + 800) = 844 h_0^4 = V_{\\max} \\approx 0.128369\n$$\nSolving for $h_0$:\n$$\nh_0^4 = \\frac{V_{\\max}}{844} \\approx \\frac{0.128369}{844} \\approx 0.000152096\n$$\n$$\nh_0 = (0.000152096)^{1/4} \\approx 0.111050\n$$\nWith this value of $h_0$, the variance $\\operatorname{Var}(\\Delta H)$ is exactly $V_{\\max}$, and so the expected acceptance probability $P_{\\mathrm{acc}}$ is exactly $P^{\\star} = 0.8$. To four significant figures, this is $0.8000$.\n\nFinally, we compute the total cost $C$ using $\\tau=1$, $h_0 \\approx 0.111050$, $m_1=1$, and $m_2=2$:\n$$\nC = \\frac{\\tau}{h_{0}}\\left(c_{0} + c_{1} m_{1} + c_{2} m_{1} m_{2}\\right)\n$$\n$$\nC = \\frac{1}{0.111050} \\left( 1 + 10(1) + 100(1)(2) \\right)\n$$\n$$\nC = \\frac{1}{0.111050} (1 + 10 + 200) = \\frac{211}{0.111050} \\approx 1899.95\n$$\nUsing a more precise value for $h_0 = (V_{\\max}/844)^{1/4} \\approx 0.1110504$:\n$$\nC = \\frac{211}{0.1110504} \\approx 1899.988\n$$\nRounding the cost to three significant figures: The number is $1.899988 \\times 10^3$. The first three significant digits are $1, 8, 9$. The next digit is $9$, so we round up the third digit. $189$ becomes $190$. To maintain the correct magnitude, the cost is $1900$.\n\nThe final results are an acceptance of $P_{\\mathrm{acc}} = 0.8000$ and a cost of $C=1900$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.8000  1900\n\\end{pmatrix}\n}\n$$", "id": "3563901"}]}