{"hands_on_practices": [{"introduction": "The triton, the nucleus of tritium ($^{3}\\text{H}$), serves as a fundamental laboratory for testing our understanding of nuclear forces and solving the quantum three-body problem. This practice guides you through a complete computational study of the triton binding energy using the Faddeev formalism, which is the standard theoretical tool for this system. By implementing a numerical solution with a realistic-like separable potential, you will investigate how the calculated binding energy converges as more partial waves are included in the model space, a crucial skill in modern nuclear structure calculations [@problem_id:3598966].", "problem": "You are asked to design and implement a complete computational study to determine, within a controlled and scientifically sound approximation, the minimal number of partial waves required for convergence of the triton three-body bound-state energy (binding energy) to within $10$ kiloelectronvolts ($10$ keV). The study must rest on the Faddeev formalism for the three-body problem and use a realistic nucleon-nucleon ($NN$) interaction represented by a partial-wave projected, rank-$1$ separable potential. Your program must produce a single line containing a list of integers, where each integer is the minimal $L_{\\max}$ (maximum orbital angular momentum quantum number included in the partial-wave expansion) that achieves the specified $10$ keV convergence for a given test case. The program must perform all calculations without any external input and must use International System of Units (SI) derived units appropriate for nuclear physics as specified below.\n\nFoundational base and modeling assumptions to be used in the derivation and computation:\n- The nonrelativistic three-body Schrödinger equation with pairwise interactions is decomposed via the Faddeev equations into components corresponding to each interacting pair. The Faddeev bound-state equation for identical fermions is recast in momentum space and projected onto orbital angular momentum partial waves $L$.\n- The nucleon-nucleon interaction in each partial wave $L$ is modeled by a rank-$1$ separable form\n$$V_L(k, k') = -\\lambda_L\\, g_L(k)\\, g_L(k'),$$\nwhere $k$ and $k'$ are relative momenta in the interacting pair, $\\lambda_L$ is a strength parameter, and $g_L(k)$ is a form factor that encodes short-range physics and correct threshold behavior. A widely used realistic-like choice for the form factor in separable models is\n$$g_L(k) = \\frac{k^L}{\\left(k^2 + \\beta_L^2\\right)^{\\frac{L+1}{2}}},$$\nwith range parameter $\\beta_L>0$ that increases mildly with $L$ to mimic decreasing range in higher partial waves. This choice reproduces the correct centrifugal threshold behavior and provides ultraviolet regularization consistent with realistic potentials.\n- The free three-body Green’s function in the Faddeev kernel is angle-averaged in the pair-spectator Jacobi momenta to obtain a numerically tractable kernel that preserves correct energy and momentum scaling. With spectator momentum $p$ and pair momentum $q$, and three-body binding energy $B>0$ (defined such that the three-body energy is $E=-B$), the angle-averaged propagator is modeled as\n$$G_0(B; p, q) = \\frac{1}{B + \\alpha \\left(p^2 + q^2 + \\frac{p q}{2}\\right)},$$\nwhere $\\alpha = \\frac{(\\hbar c)^2}{m_N}$ and $m_N$ is the nucleon mass. This angle-average is a standard numerical approximation that produces a positive kernel and captures the leading dependence on $p$, $q$, and $B$.\n- The Faddeev homogeneous integral equation in the partial-wave basis is discretized using Gaussian quadrature over $q \\in [0, q_{\\max}]$ with the correct integration measure $q^2 \\, dq$. The discretization produces a block matrix kernel coupling the included partial waves $L \\in \\{0,2,4,\\dots,L_{\\max}\\}$ (only even $L$ contribute to the positive-parity triton ground state). The coupling between partial waves arises from the angular recoupling in the Faddeev permutations and from realistic tensor-induced mixing; it is parametrized by a symmetric matrix of effective strengths $\\lambda_{L L'}$ that reduces to $\\lambda_L$ on the diagonal and is suppressed for $L \\neq L'$ according to physical mixing patterns.\n- The resulting discretized homogeneous equation has the formal structure\n$$\\mathbf{f} = \\mathbf{K}(B; L_{\\max})\\, \\mathbf{f},$$\nwhere $\\mathbf{K}(B; L_{\\max})$ is the block kernel matrix that depends on $B$ and the set of included partial waves up to $L_{\\max}$. A bound state exists when the spectral radius (the largest eigenvalue) $\\rho\\big(\\mathbf{K}(B; L_{\\max})\\big)$ equals $1$. The binding energy $B$ is solved by finding the unique $B>0$ for which $\\rho=1$; as $B$ increases, the kernel entries decrease monotonically, making $\\rho$ a strictly decreasing function of $B$, so bisection is appropriate.\n\nAlgorithmic requirements:\n- Discretize momentum with Gaussian quadrature nodes $\\{q_j\\}$ and weights $\\{w_j\\}$ on $[0, q_{\\max}]$. Use the measure $q_j^2 w_j$ in the integral, producing a Riemann sum representation of the kernel. The kernel block corresponding to coupling between partial waves $L$ and $L'$ is\n$$K^{(L,L')}_{i j}(B) = 2\\, \\lambda_{L L'}\\, g_L(p_i)\\, g_{L'}(q_j)\\, G_0(B; p_i, q_j)\\, q_j^2\\, w_j,$$\nwith the factor $2$ accounting for the two nontrivial permutations in the Faddeev decomposition for three identical fermions.\n- Construct the full kernel $\\mathbf{K}(B; L_{\\max})$ by assembling all $K^{(L,L')}(B)$ blocks into a single matrix acting on the stacked vector of discretized amplitudes for each included partial wave. Compute the spectral radius $\\rho$ by power iteration, which is robust for positive matrices satisfying Perron-Frobenius conditions.\n- Find $B(L_{\\max})$ by bracketing and bisection: determine $B$ such that $\\rho\\big(\\mathbf{K}(B; L_{\\max})\\big)=1$ to within absolute tolerance corresponding to $10$ keV ($0.01$ MeV). Energies must be expressed in megaelectronvolts (MeV).\n- Define a reference energy $B_{\\mathrm{ref}}$ as $B(L_{\\mathrm{ref}})$ with $L_{\\mathrm{ref}}=8$ (i.e., partial waves $L\\in\\{0,2,4,6,8\\}$). For each test case, determine the smallest even $L_{\\max}\\in\\{0,2,4,6,8\\}$ such that $\\left|B(L_{\\max}) - B_{\\mathrm{ref}}\\right| < 0.01$ MeV.\n\nPhysical constants and units:\n- Use $\\hbar c = 197.3269804$ MeV$\\cdot$fm and $m_N = 939.0$ MeV$/c^2$.\n- Momentums $p$ and $q$ are in inverse femtometers (fm$^{-1}$). Energies are in megaelectronvolts (MeV). The kinetic scaling is $\\alpha = (\\hbar c)^2/m_N$ in MeV$\\cdot$fm$^2$ divided by fm$^2$, yielding MeV.\n\nTest suite specification:\nImplement three test cases that probe different physical regimes and mixing patterns. For each case, use only even partial waves up to $L_{\\max}$.\n\nFor all cases:\n- Use Gaussian quadrature with $N=80$ nodes on $[0, q_{\\max}]$.\n- Choose $q_{\\max} = 5.0$ fm$^{-1}$.\n- Define $\\beta_L = \\beta_0\\left(1 + r \\cdot \\frac{L}{2}\\right)$.\n- Define diagonal coupling $\\lambda_{L L} = \\lambda_0 / (1+L)^2$.\n- Define off-diagonal mixing for $L \\neq L'$ as $\\lambda_{L L'} = \\lambda_{\\mathrm{mix}} \\sqrt{\\lambda_{L L} \\lambda_{L' L'}} \\exp\\left(-\\frac{|L-L'|}{2}\\right)$.\n\nCase A (baseline \"happy path\"):\n- $\\beta_0 = 1.5$ fm$^{-1}$, $r = 0.4$, $\\lambda_0 = 600.0$, $\\lambda_{\\mathrm{mix}} = 0.30$.\n\nCase B (strong tensor mixing):\n- $\\beta_0 = 1.2$ fm$^{-1}$, $r = 0.3$, $\\lambda_0 = 800.0$, $\\lambda_{\\mathrm{mix}} = 0.50$.\n\nCase C (shorter range, faster high-$L$ suppression):\n- $\\beta_0 = 1.8$ fm$^{-1}$, $r = 0.5$, $\\lambda_0 = 450.0$, $\\lambda_{\\mathrm{mix}} = 0.20$.\n\nRequired output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"). Each result must be the minimal even integer $L_{\\max}\\in\\{0,2,4,6,8\\}$ for which the binding energy is converged to within $10$ keV relative to $L_{\\mathrm{ref}}=8$ for the corresponding test case.\n\nAngle units do not appear in this problem. No percentages are used. All energies must be handled and compared in MeV. The final output list values are integers with no units.", "solution": "We begin from the nonrelativistic three-body Schrödinger equation for identical nucleons with pairwise interactions. The Faddeev formalism decomposes the three-body wave function into components that satisfy coupled homogeneous integral equations, one for each interacting pair. In momentum space and after partial-wave projection onto orbital angular momentum $L$, the bound-state homogeneous Faddeev equations involve integrals over the spectator momentum $p$ and the pair momentum $q$ of a kernel containing the free Green’s function and the two-body interaction in each partial wave.\n\nTo obtain a numerically tractable approximation that preserves the essential physics of short-range $NN$ forces and partial-wave mixing, we adopt a rank-$1$ separable potential in each partial wave $L$,\n$$V_L(k,k') = -\\lambda_L\\, g_L(k)\\, g_L(k'),$$\nwhere $\\lambda_L$ is the strength and $g_L(k)$ is a form factor with correct threshold behavior and ultraviolet falloff. The form\n$$g_L(k) = \\frac{k^L}{\\left(k^2 + \\beta_L^2\\right)^{\\frac{L+1}{2}}}$$\nis widely used and ensures that the potential is short-ranged with effective range parameter $\\beta_L$. The multipolar threshold factor $k^L$ enforces the centrifugal barrier near $k\\to 0$. Such separable representations are common for realistic interactions when reduced to low-rank approximations for computational expediency.\n\nThe free three-body Green’s function depends on the total three-body energy and the Jacobi momenta. For a bound state with $E=-B$ and $B>0$, we adopt an angle-averaged representation\n$$G_0(B; p, q) = \\frac{1}{B + \\alpha \\left(p^2 + q^2 + \\frac{p q}{2}\\right)}, \\quad \\alpha = \\frac{(\\hbar c)^2}{m_N},$$\nwhich captures the leading dependence on $p$, $q$, and the binding energy $B$ while enabling block-separable numerical construction of the kernel. Angle-averaging is a standard approximation that yields a positive kernel and respects the monotonic decay of the spectral radius with increasing $B$.\n\nProjecting the Faddeev equation onto the set of even partial waves $L\\in\\{0,2,4,\\dots,L_{\\max}\\}$ (positive parity triton ground state), and discretizing the pair momentum integral $\\int_0^{q_{\\max}} dq\\, q^2$ with Gaussian quadrature nodes $\\{q_j\\}$ and weights $\\{w_j\\}$, we obtain the homogeneous linear system\n$$f_L(p_i) = \\sum_{L'} \\sum_{j} K^{(L,L')}_{i j}(B)\\, f_{L'}(q_j),$$\nwith the block kernel\n$$K^{(L,L')}_{i j}(B) = 2\\, \\lambda_{L L'}\\, g_L(p_i)\\, g_{L'}(q_j)\\, G_0(B; p_i, q_j)\\, q_j^2\\, w_j.$$\nThe factor $2$ accounts for the two nontrivial Faddeev permutations of interacting pairs. The symmetric coupling coefficients $\\lambda_{L L'}$ incorporate realistic mixing among partial waves, dominated by the tensor-induced $S$–$D$ mixing and suppressed for $|L-L'|$ large. A reasonable physically motivated choice is\n$$\\lambda_{L L} = \\frac{\\lambda_0}{(1+L)^2}, \\quad \\lambda_{L L'} = \\lambda_{\\mathrm{mix}} \\sqrt{\\lambda_{L L}\\, \\lambda_{L' L'}} \\exp\\left(-\\frac{|L-L'|}{2}\\right)\\quad (L\\neq L'),$$\nwhich ensures that higher partial waves are progressively weaker and that off-diagonal couplings fall off with $|L-L'|$, while maintaining symmetry and positivity.\n\nStacking the discretized amplitudes $f_L(p_i)$ into a single vector $\\mathbf{f}$ and assembling all blocks $K^{(L,L')}(B)$ yields the global kernel matrix $\\mathbf{K}(B; L_{\\max})$. The homogeneous equation becomes\n$$\\mathbf{f} = \\mathbf{K}(B; L_{\\max})\\, \\mathbf{f}.$$\nA nontrivial solution exists when the largest eigenvalue (the spectral radius) satisfies $\\rho\\big(\\mathbf{K}(B; L_{\\max})\\big)=1$ by the Perron–Frobenius theorem for positive matrices. Since all kernel entries decrease monotonically with increasing $B$ (the denominator in $G_0$ grows with $B$), the spectral radius is a strictly decreasing function of $B$, enabling robust bisection to find the unique binding energy $B$ solving $\\rho=1$ to any desired accuracy. We compute $\\rho$ by power iteration, which converges rapidly for positive kernels.\n\nNumerical setup:\n- Choose $q_{\\max}=5.0$ fm$^{-1}$, $N=80$ Gaussian nodes on $[0,q_{\\max}]$, and the measure $q^2\\, dq$ encoded via weights $q_j^2 w_j$.\n- Use $p$ at the same quadrature nodes to construct rows $p_i$ of the kernel. This symmetry simplifies assembling $\\mathbf{K}$.\n- Adopt $\\beta_L = \\beta_0\\left(1 + r \\cdot \\frac{L}{2}\\right)$ to capture the gradual reduction of interaction range in higher partial waves.\n\nBinding energy search:\n- For fixed $L_{\\max}$, bracket the root of $\\rho(B)-1=0$ by scanning $B\\in[0.1, B_{\\mathrm{max}}]$ MeV until $\\rho(B_{\\mathrm{low}})>1$ and $\\rho(B_{\\mathrm{high}})<1$; take $B_{\\mathrm{max}}$ large enough (e.g., $500$ MeV) to guarantee a decrease below $1$.\n- Use bisection to find $B(L_{\\max})$ with absolute tolerance $10^{-2}$ MeV (corresponding to $10$ keV).\n- Define $B_{\\mathrm{ref}} = B(8)$ as the energy with partial waves up to $L_{\\mathrm{ref}}=8$ included.\n- Determine the minimal even $L_{\\max}\\in\\{0,2,4,6,8\\}$ such that $\\left|B(L_{\\max}) - B_{\\mathrm{ref}}\\right| < 0.01$ MeV.\n\nTest suite and expected behavior:\n- Case A represents a typical scenario with moderate tensor mixing and baseline range, providing a “happy path” where convergence is achieved with a small number of partial waves.\n- Case B increases tensor mixing, likely requiring $L_{\\max} \\ge 4$ or $6$ for $10$ keV convergence due to stronger off-diagonal couplings.\n- Case C increases the range parameter for higher $L$, suppressing their contribution more strongly and tending to converge with fewer partial waves.\n\nThe final program, following this derivation, constructs the kernel, computes the spectral radius via power iteration, finds the binding energies for each $L_{\\max}$, compares to $B_{\\mathrm{ref}}$, and outputs a single line with a list of the minimal $L_{\\max}$ values for the three cases. Energies are consistently in MeV, momenta in fm$^{-1}$, and the kinetic scaling is handled by $\\alpha = (\\hbar c)^2/m_N$. The use of separable potentials and angle-averaged propagators is consistent with well-tested computational nuclear physics practices for exploring convergence with respect to partial-wave truncation.", "answer": "```python\nimport numpy as np\n\n# Constants for units: energies in MeV, momenta in fm^-1.\nHBARC = 197.3269804  # MeV*fm\nM_N = 939.0  # MeV/c^2\nALPHA = (HBARC**2) / M_N  # MeV * fm^2 / fm^2 = MeV\n\ndef gauss_legendre_quadrature(n, a, b):\n    # Returns nodes x and weights w for Gauss-Legendre on [a,b]\n    x, w = np.polynomial.legendre.leggauss(n)\n    # Affine transform from [-1,1] to [a,b]\n    t = 0.5 * (x + 1.0)\n    nodes = a + (b - a) * t\n    weights = 0.5 * (b - a) * w\n    return nodes, weights\n\ndef form_factor(L, k, beta_L):\n    # g_L(k) = k^L / (k^2 + beta_L^2)^{(L+1)/2}\n    # Handle k=0 for L>0: k^L is zero-safe\n    denom = (k**2 + beta_L**2)**((L + 1) / 2.0)\n    numer = (k**L)\n    return numer / denom\n\ndef coupling_matrix_entry(L, Lp, lambda0, lambda_mix):\n    # Diagonal: lambda_LL = lambda0 / (1+L)^2\n    # Off-diag: lambda_LL' = lambda_mix * sqrt(lambda_LL * lambda_L'L') * exp(-|L-L'|/2)\n    lam_LL = lambda0 / ((1 + L)**2)\n    lam_LpLp = lambda0 / ((1 + Lp)**2)\n    if L == Lp:\n        return lam_LL\n    else:\n        return lambda_mix * np.sqrt(lam_LL * lam_LpLp) * np.exp(-abs(L - Lp) / 2.0)\n\ndef build_kernel(B, L_vals, p_nodes, w_nodes, beta0, r_growth, lambda0, lambda_mix):\n    # Build the full kernel matrix K(B; Lmax)\n    # p_nodes and w_nodes are 1D arrays of length N over [0, qmax]\n    # Integration measure: q^2 dq -> encoded via weights w_nodes and q_nodes^2\n    q_nodes = p_nodes\n    q_weights = w_nodes\n    N = p_nodes.shape[0]\n    nL = len(L_vals)\n    dim = N * nL\n    K = np.zeros((dim, dim), dtype=np.float64)\n\n    # Precompute g_L(p_i) and g_L(q_j) and betas for each L\n    g_p = {}\n    g_q = {}\n    beta_L_map = {}\n    for L in L_vals:\n        beta_L = beta0 * (1.0 + r_growth * (L / 2.0))\n        beta_L_map[L] = beta_L\n        g_p[L] = form_factor(L, p_nodes, beta_L)\n        g_q[L] = form_factor(L, q_nodes, beta_L)\n\n    # Assemble blocks\n    # Index mapping: block for L index a (0..nL-1), row i (0..N-1) maps to row idx = a*N + i\n    # Similarly for columns: L' index b, col j -> col idx = b*N + j\n    # K^{(L,L')}_{i j} = 2 * lambda_{L,L'} * g_L(p_i) * g_{L'}(q_j) * G0(B; p_i, q_j) * q_j^2 * w_j\n    # G0(B;p,q) = 1 / (B + ALPHA * (p^2 + q^2 + 0.5*p*q))\n    # We'll vectorize over j for each i to fill rows efficiently.\n    for a, L in enumerate(L_vals):\n        gp = g_p[L]  # length N\n        for b, Lp in enumerate(L_vals):\n            lam = coupling_matrix_entry(L, Lp, lambda0, lambda_mix)\n            gq = g_q[Lp]  # length N\n            # Precompute denominator contributions that depend on p_i and q_j\n            # We'll broadcast: for each i, denom = B + ALPHA * (p_i^2 + q^2 + 0.5*p_i*q)\n            for i in range(N):\n                p_i = p_nodes[i]\n                denom = B + ALPHA * (p_i**2 + q_nodes**2 + 0.5 * p_i * q_nodes)\n                G0 = 1.0 / denom\n                row_idx = a * N + i\n                # Column block indices for Lp span b*N .. b*N + N-1\n                cols_start = b * N\n                # Contribution vector to this row from block (L,Lp)\n                contrib = 2.0 * lam * gp[i] * gq * G0 * (q_nodes**2) * q_weights\n                K[row_idx, cols_start:cols_start + N] += contrib\n\n    return K\n\ndef spectral_radius_power_iteration(K, max_iter=200, tol=1e-10):\n    # Power iteration for largest eigenvalue of a positive matrix K\n    n = K.shape[0]\n    v = np.ones(n, dtype=np.float64)\n    v /= np.linalg.norm(v)\n    lambda_old = 0.0\n    for _ in range(max_iter):\n        w = K @ v\n        norm_w = np.linalg.norm(w)\n        if norm_w == 0.0:\n            return 0.0\n        v = w / norm_w\n        # Rayleigh quotient\n        Kv = K @ v\n        lam = float(np.dot(v, Kv))\n        if abs(lam - lambda_old) < tol * max(1.0, abs(lam)):\n            return lam\n        lambda_old = lam\n    return lambda_old\n\ndef find_binding_energy(L_vals, p_nodes, w_nodes, beta0, r_growth, lambda0, lambda_mix,\n                        B_low_init=0.1, B_high_init=20.0, B_max_scan=500.0, tol_keV=10.0):\n    # Find B s.t. spectral radius rho(K(B)) = 1 within tolerance corresponding to 10 keV -> 0.01 MeV\n    # Bracketing: ensure rho(B_low) > 1, rho(B_high) < 1\n    # If needed, adjust B_high upward.\n    # Return B in MeV\n    # Compute kernel and rho at initial bounds\n    def rho_at_B(B):\n        K = build_kernel(B, L_vals, p_nodes, w_nodes, beta0, r_growth, lambda0, lambda_mix)\n        return spectral_radius_power_iteration(K)\n\n    B_low = B_low_init\n    rho_low = rho_at_B(B_low)\n    # Ensure lower bracket is above 1; if not, try smaller B (closer to threshold)\n    if rho_low < 1.0:\n        # Try reducing B_low\n        for factor in [0.05, 0.02, 0.01]:\n            B_low_candidate = B_low * factor\n            rho_candidate = rho_at_B(B_low_candidate)\n            if rho_candidate > 1.0:\n                B_low = B_low_candidate\n                rho_low = rho_candidate\n                break\n        else:\n            # If still not bracketed, return NaN to signal no bound state\n            return np.nan\n\n    B_high = B_high_init\n    rho_high = rho_at_B(B_high)\n    # Increase B_high until rho_high < 1 or reach B_max_scan\n    while rho_high >= 1.0 and B_high < B_max_scan:\n        B_high *= 1.5\n        rho_high = rho_at_B(B_high)\n    if rho_high >= 1.0:\n        return np.nan\n\n    # Bisection\n    tol_MeV = tol_keV / 1000.0  # 10 keV in MeV\n    max_steps = 80\n    for _ in range(max_steps):\n        B_mid = 0.5 * (B_low + B_high)\n        rho_mid = rho_at_B(B_mid)\n        if abs(rho_mid - 1.0) < 1e-6:\n            # close enough in rho, now ensure B within energy tol\n            if abs(B_high - B_low) < tol_MeV:\n                return B_mid\n        if rho_mid > 1.0:\n            B_low = B_mid\n        else:\n            B_high = B_mid\n        if abs(B_high - B_low) < tol_MeV:\n            return 0.5 * (B_low + B_high)\n    return 0.5 * (B_low + B_high)\n\ndef minimal_Lmax_for_convergence(params, L_ref=8, qmax=5.0, N=80, tol_keV=10.0):\n    # params: dict with beta0, r_growth, lambda0, lambda_mix\n    # Construct quadrature\n    p_nodes, w_nodes = gauss_legendre_quadrature(N, 0.0, qmax)\n    # Even L values up to L_ref\n    L_all = [L for L in range(0, L_ref + 1, 2)]\n    # Compute B_ref with L_ref\n    B_ref = find_binding_energy(L_all, p_nodes, w_nodes,\n                                params['beta0'], params['r_growth'],\n                                params['lambda0'], params['lambda_mix'],\n                                B_low_init=0.1, B_high_init=20.0, B_max_scan=500.0, tol_keV=tol_keV)\n    if np.isnan(B_ref):\n        # No bound state found; define convergence as requiring Lmax=0 (degenerate case)\n        return 0\n    # Now test progressively increasing Lmax\n    for Lmax in L_all:\n        L_vals = [L for L in range(0, Lmax + 1, 2)]\n        B_curr = find_binding_energy(L_vals, p_nodes, w_nodes,\n                                     params['beta0'], params['r_growth'],\n                                     params['lambda0'], params['lambda_mix'],\n                                     B_low_init=0.1, B_high_init=20.0, B_max_scan=500.0, tol_keV=tol_keV)\n        if np.isnan(B_curr):\n            # If this truncation loses the bound state, it certainly does not converge; continue\n            continue\n        if abs(B_curr - B_ref) < (tol_keV / 1000.0):\n            return Lmax\n    # If none satisfy, return L_ref\n    return L_ref\n\ndef solve():\n    # Define the test cases as specified\n    test_cases = [\n        # Case A: baseline \"happy path\"\n        {'beta0': 1.5, 'r_growth': 0.4, 'lambda0': 600.0, 'lambda_mix': 0.30},\n        # Case B: strong tensor mixing\n        {'beta0': 1.2, 'r_growth': 0.3, 'lambda0': 800.0, 'lambda_mix': 0.50},\n        # Case C: shorter range, faster high-L suppression\n        {'beta0': 1.8, 'r_growth': 0.5, 'lambda0': 450.0, 'lambda_mix': 0.20},\n    ]\n\n    results = []\n    for params in test_cases:\n        Lmax_min = minimal_Lmax_for_convergence(params, L_ref=8, qmax=5.0, N=80, tol_keV=10.0)\n        results.append(int(Lmax_min))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3598966"}, {"introduction": "Moving from the discrete spectrum of bound states to the continuous spectrum of scattering processes is a critical step in understanding nuclear dynamics. This exercise provides a hands-on verification of the optical theorem, a profound consequence of the unitarity of the scattering $S$-matrix, which ensures the conservation of probability. You will numerically demonstrate that the total cross section is precisely the sum of the elastic and breakup (reaction) cross sections, gaining practical insight into how particle flux is conserved and redistributed among different outcomes in a multi-channel scattering problem [@problem_id:3599037].", "problem": "Consider quantum scattering in the three-body problem within the Faddeev-Alt-Grassberger-Sandhas (Faddeev-AGS) formalism for identical spinless particles in the center-of-mass frame. At a fixed on-shell incident Jacobi momentum magnitude $k$ (in $\\mathrm{fm}^{-1}$), assume that the scattering in the elastic channel is dominated by $s$-wave and low partial waves, and that effective on-shell channel unitarity can be captured by a set of complex partial-wave channel scattering matrix elements $S_\\ell$ of the form $S_\\ell = \\eta_\\ell \\exp(2 i \\delta_\\ell)$, where $\\delta_\\ell$ is a real phase shift (in radians) and $\\eta_\\ell \\in [0,1]$ is a real inelasticity parameter summarizing the net probability loss from the elastic channel to breakup channels for the given partial wave $\\ell$. The spherical symmetry about the beam axis implies that the scattering amplitude depends only on the polar angle $\\theta$ with $\\mu \\equiv \\cos \\theta$.\n\nUse the following fundamental bases:\n- Quantum-mechanical unitarity of the scattering matrix, $S^\\dagger S = I$.\n- The optical theorem, $\\sigma_{\\mathrm{tot}} = \\frac{4 \\pi}{k} \\,\\mathrm{Im}\\, f(0)$, where $f(\\theta)$ is the elastic scattering amplitude.\n- The partial-wave expansion of the elastic scattering amplitude, $f(\\theta) = \\frac{1}{2 i k} \\sum_{\\ell=0}^{\\ell_{\\max}} (2 \\ell + 1)\\,\\left(S_\\ell - 1\\right) P_\\ell(\\cos \\theta)$, where $P_\\ell(\\mu)$ are Legendre polynomials.\n- The definition of the integrated elastic cross section as the angular integral of the differential cross section: $\\sigma_{\\mathrm{el}} = \\int \\mathrm{d}\\Omega\\, |f(\\theta)|^2 = 2 \\pi \\int_{-1}^{1} \\mathrm{d}\\mu\\, |f(\\mu)|^2$.\n- The breakup (reaction) cross section per partial wave, derived from channel unitarity, is proportional to the flux deficit in the elastic channel: for each $\\ell$, the deficit factor is $1 - |S_\\ell|^2 = 1 - \\eta_\\ell^2$.\n\nYour task is to implement a self-contained program that:\n1. Constructs the complex elastic-channel partial-wave scattering matrix elements $S_\\ell$ from specified real $\\delta_\\ell$ and $\\eta_\\ell$ for $\\ell = 0,1,\\dots,\\ell_{\\max}$.\n2. Computes the total cross section $\\sigma_{\\mathrm{tot}}$ using the optical theorem and the forward direction $\\theta = 0$.\n3. Computes the elastic cross section $\\sigma_{\\mathrm{el}}$ by numerically integrating $|f(\\theta)|^2$ over solid angle using Gauss-Legendre quadrature with a specified number $N_\\mu$ of nodes over $\\mu \\in [-1,1]$. The integration is axisymmetric, so only the $\\mu$ integration is required, and the azimuthal integral contributes a factor $2 \\pi$.\n4. Computes the breakup cross section $\\sigma_{\\mathrm{break}}$ using the flux-deficit definition from channel unitarity with the given $S_\\ell$ values.\n5. Verifies, for each test case, whether $|\\sigma_{\\mathrm{tot}} - (\\sigma_{\\mathrm{el}} + \\sigma_{\\mathrm{break}})| \\le \\varepsilon$ within a specified numerical tolerance $\\varepsilon$ (in $\\mathrm{fm}^2$), and reports the result as a boolean.\n\nAll cross sections must be reported in $\\mathrm{fm}^2$, and angles in radians. Use Legendre polynomials $P_\\ell(\\mu)$ with the conventional normalization $P_\\ell(1) = 1$. Your program must produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, for example, \"[$\\mathrm{result}_1$, $\\mathrm{result}_2$, $\\mathrm{result}_3$]\".\n\nImplement and evaluate the following test suite, which is designed to exercise different facets of the computation:\n\n- Test Case A (general \"happy path\"):\n  - Incident momentum magnitude: $k = 1.0$ $\\mathrm{fm}^{-1}$.\n  - Partial waves: $\\ell = 0,1,2,3,4$.\n  - Phase shifts: $(\\delta_0,\\delta_1,\\delta_2,\\delta_3,\\delta_4) = (0.3, -0.15, 0.2, -0.05, 0.08)$ radians.\n  - Inelasticities: $(\\eta_0,\\eta_1,\\eta_2,\\eta_3,\\eta_4) = (0.9, 0.85, 0.7, 1.0, 0.6)$.\n  - Number of Gauss-Legendre nodes: $N_\\mu = 200$.\n  - Tolerance: $\\varepsilon = 10^{-7}$ $\\mathrm{fm}^2$.\n\n- Test Case B (boundary condition: purely elastic scattering):\n  - Incident momentum magnitude: $k = 0.7$ $\\mathrm{fm}^{-1}$.\n  - Partial waves: $\\ell = 0,1,2,3$.\n  - Phase shifts: $(\\delta_0,\\delta_1,\\delta_2,\\delta_3) = (0.25, -0.35, 0.1, -0.28)$ radians.\n  - Inelasticities: $(\\eta_0,\\eta_1,\\eta_2,\\eta_3) = (1.0, 1.0, 1.0, 1.0)$.\n  - Number of Gauss-Legendre nodes: $N_\\mu = 180$.\n  - Tolerance: $\\varepsilon = 10^{-8}$ $\\mathrm{fm}^2$.\n\n- Test Case C (strong breakup component):\n  - Incident momentum magnitude: $k = 1.8$ $\\mathrm{fm}^{-1}$.\n  - Partial waves: $\\ell = 0,1,2,3,4,5,6$.\n  - Phase shifts: $(\\delta_0,\\delta_1,\\delta_2,\\delta_3,\\delta_4,\\delta_5,\\delta_6) = (0.1, -0.2, 0.05, 0.3, -0.15, 0.22, -0.12)$ radians.\n  - Inelasticities: $(\\eta_0,\\eta_1,\\eta_2,\\eta_3,\\eta_4,\\eta_5,\\eta_6) = (0.3, 0.2, 0.5, 0.4, 0.6, 0.7, 0.5)$.\n  - Number of Gauss-Legendre nodes: $N_\\mu = 500$.\n  - Tolerance: $\\varepsilon = 10^{-7}$ $\\mathrm{fm}^2$.\n\n- Test Case D (edge case stressing numerical quadrature resolution):\n  - Incident momentum magnitude: $k = 1.2$ $\\mathrm{fm}^{-1}$.\n  - Partial waves: all integers $\\ell$ from $\\ell = 0$ to $\\ell = 20$ inclusive.\n  - Phase shifts: $\\delta_\\ell = 0.2 \\sin(0.4 \\ell)$ radians for each $\\ell$.\n  - Inelasticities: $\\eta_\\ell = \\max\\{0, \\min\\{1, 0.9 - 0.03 \\ell\\}\\}$ for each $\\ell$.\n  - Number of Gauss-Legendre nodes: $N_\\mu = 12$.\n  - Tolerance: $\\varepsilon = 10^{-6}$ $\\mathrm{fm}^2$.\n\nYour program must implement the above, produce the boolean verification for each test case in the prescribed output format, and adhere to the execution environment constraints. No user input is permitted; the program must run as-is and print only the final results line.", "solution": "The core of the verification rests on the unitarity of the scattering matrix and the optical theorem. In the Faddeev-Alt-Grassberger-Sandhas formalism for three-body scattering, the elastic and breakup channels are coupled through the transition operators that, when projected on-shell, define an $S$-matrix across channels. For a given incident state and partial-wave truncation, the elastic channel diagonal is $S_\\ell = \\eta_\\ell \\exp(2 i \\delta_\\ell)$, where $0 \\le \\eta_\\ell \\le 1$ parameterizes the net inelasticity (probability flux into breakup and other non-elastic channels) and $\\delta_\\ell$ is the elastic phase shift. The unitarity condition $S^\\dagger S = I$ enforces that probabilities across all final channels sum to unity.\n\nTo connect observables, we use the standard partial-wave expansion for the elastic scattering amplitude,\n$$\nf(\\theta) = \\frac{1}{2 i k} \\sum_{\\ell=0}^{\\ell_{\\max}} (2 \\ell + 1)\\,\\left(S_\\ell - 1\\right) P_\\ell(\\cos \\theta),\n$$\nwith $P_\\ell(\\mu)$ the Legendre polynomials and $k$ the incident Jacobi momentum magnitude. This expansion is appropriate for center-of-mass frame scattering with axial symmetry about the beam axis.\n\nFrom the optical theorem, the total cross section is\n$$\n\\sigma_{\\mathrm{tot}} = \\frac{4 \\pi}{k} \\,\\mathrm{Im}\\, f(0).\n$$\nBecause $P_\\ell(1) = 1$, we have\n$$\nf(0) = \\frac{1}{2 i k} \\sum_{\\ell=0}^{\\ell_{\\max}} (2 \\ell + 1)\\,\\left(S_\\ell - 1\\right).\n$$\nDenote $S_\\ell = a_\\ell + i b_\\ell$ with $a_\\ell = \\mathrm{Re}\\, S_\\ell$, $b_\\ell = \\mathrm{Im}\\, S_\\ell$. Then\n$$\n\\mathrm{Im}\\left(\\frac{S_\\ell - 1}{2 i k}\\right) = \\frac{1 - \\mathrm{Re} \\, S_\\ell}{2 k},\n$$\nso\n$$\n\\sigma_{\\mathrm{tot}} = \\frac{4 \\pi}{k} \\sum_{\\ell=0}^{\\ell_{\\max}} \\frac{(2 \\ell + 1)}{2 k}\\left(1 - \\mathrm{Re} \\, S_\\ell\\right) = \\frac{2 \\pi}{k^2} \\sum_{\\ell=0}^{\\ell_{\\max}} (2 \\ell + 1)\\left(1 - \\mathrm{Re} \\, S_\\ell\\right).\n$$\n\nThe elastic cross section is the angular integral of the differential cross section. With axial symmetry, $f(\\theta)$ depends only on $\\theta$ through $\\mu = \\cos \\theta$, and we have\n$$\n\\sigma_{\\mathrm{el}} = \\int \\mathrm{d}\\Omega\\, |f(\\theta)|^2 = 2 \\pi \\int_{-1}^{1} \\mathrm{d}\\mu\\, |f(\\mu)|^2.\n$$\nNumerically, we approximate the integral by Gauss-Legendre quadrature over $\\mu \\in [-1,1]$. Specifically, we choose $N_\\mu$ nodes $\\{\\mu_i\\}$ and weights $\\{w_i\\}$ such that\n$$\n\\sigma_{\\mathrm{el}} \\approx 2 \\pi \\sum_{i=1}^{N_\\mu} w_i \\, \\left| f(\\mu_i) \\right|^2.\n$$\nThe numerical uncertainty decreases rapidly with $N_\\mu$, but for large $\\ell_{\\max}$, $|f(\\mu)|^2$ can have high-degree polynomial behavior, so coarse $N_\\mu$ can incur noticeable quadrature error.\n\nFor the breakup cross section, we use unitarity of the $S$-matrix restricted to the elastic channel and its complement. For each partial wave,\n$$\n1 - |S_\\ell|^2 = 1 - \\eta_\\ell^2,\n$$\nrepresents the elastic flux deficit due to transitions into breakup channels (and any other non-elastic channels lumped into the inelasticity). The integrated breakup cross section extracted from this deficit is\n$$\n\\sigma_{\\mathrm{break}} = \\frac{\\pi}{k^2} \\sum_{\\ell=0}^{\\ell_{\\max}} (2 \\ell + 1) \\left(1 - |S_\\ell|^2\\right) = \\frac{\\pi}{k^2} \\sum_{\\ell=0}^{\\ell_{\\max}} (2 \\ell + 1) \\left(1 - \\eta_\\ell^2\\right).\n$$\n\nCombining the above, one can show analytically using the orthogonality of Legendre polynomials that\n$$\n\\sigma_{\\mathrm{el}} = \\frac{\\pi}{k^2} \\sum_{\\ell=0}^{\\ell_{\\max}} (2 \\ell + 1) \\left| S_\\ell - 1 \\right|^2,\n$$\nsince $|S_\\ell - 1|^2 = 1 + |S_\\ell|^2 - 2 \\mathrm{Re}\\, S_\\ell$. Then\n$$\n\\sigma_{\\mathrm{el}} + \\sigma_{\\mathrm{break}} = \\frac{\\pi}{k^2} \\sum_{\\ell} (2 \\ell + 1) \\left( 1 + |S_\\ell|^2 - 2 \\mathrm{Re}\\, S_\\ell + 1 - |S_\\ell|^2 \\right)\n= \\frac{2 \\pi}{k^2} \\sum_{\\ell} (2 \\ell + 1) \\left(1 - \\mathrm{Re}\\, S_\\ell\\right) = \\sigma_{\\mathrm{tot}}.\n$$\nThus, the identity $\\sigma_{\\mathrm{tot}} = \\sigma_{\\mathrm{el}} + \\sigma_{\\mathrm{break}}$ follows from $S^\\dagger S = I$. Our numerical verification tests this identity in practice by computing $\\sigma_{\\mathrm{tot}}$ from the optical theorem and $f(0)$, computing $\\sigma_{\\mathrm{el}}$ by numerical quadrature of $|f(\\mu)|^2$, and computing $\\sigma_{\\mathrm{break}}$ from $1 - |S_\\ell|^2$ using the specified $S_\\ell$.\n\nAlgorithmic steps for each test case:\n1. Build the list of $(\\delta_\\ell, \\eta_\\ell)$ for $\\ell = 0,1,\\dots,\\ell_{\\max}$ and compute $S_\\ell = \\eta_\\ell \\exp(2 i \\delta_\\ell)$.\n2. Compute $f(\\mu)$ on Gauss-Legendre nodes $\\mu_i$ using\n$$\nf(\\mu_i) = \\frac{1}{2 i k} \\sum_{\\ell=0}^{\\ell_{\\max}} (2 \\ell + 1)\\,\\left(S_\\ell - 1\\right) P_\\ell(\\mu_i).\n$$\n3. Compute $\\sigma_{\\mathrm{el}} \\approx 2 \\pi \\sum_i w_i |f(\\mu_i)|^2$.\n4. Compute $\\sigma_{\\mathrm{tot}} = \\frac{2 \\pi}{k^2} \\sum_{\\ell=0}^{\\ell_{\\max}} (2 \\ell + 1) \\left(1 - \\mathrm{Re}\\, S_\\ell\\right)$.\n5. Compute $\\sigma_{\\mathrm{break}} = \\frac{\\pi}{k^2} \\sum_{\\ell=0}^{\\ell_{\\max}} (2 \\ell + 1) \\left(1 - \\eta_\\ell^2\\right)$.\n6. Evaluate the boolean $|\\sigma_{\\mathrm{tot}} - (\\sigma_{\\mathrm{el}} + \\sigma_{\\mathrm{break}})| \\le \\varepsilon$.\n\nUnits: $k$ must be in $\\mathrm{fm}^{-1}$, all cross sections must be reported in $\\mathrm{fm}^2$, and angles in radians. The specified test suite covers a general case, a purely elastic boundary, a strong-breakup scenario, and a numerically challenging case with large $\\ell_{\\max}$ and coarse quadrature resolution, which highlights the effect of numerical integration error. The final output is a single line in the format \"[$\\mathrm{result}_\\mathrm{A}$,$\\mathrm{result}_\\mathrm{B}$,$\\mathrm{result}_\\mathrm{C}$,$\\mathrm{result}_\\mathrm{D}$]\".", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef legendre_polynomials(l_max, x):\n    \"\"\"\n    Evaluate Legendre polynomials P_l(x) for l = 0..l_max at points x.\n    Returns an array of shape (l_max+1, len(x)).\n    \"\"\"\n    # Use numpy.polynomial.legendre.Legendre basis for stable evaluation\n    P = np.empty((l_max + 1, x.size), dtype=float)\n    for l in range(l_max + 1):\n        poly = np.polynomial.legendre.Legendre.basis(l)\n        P[l, :] = poly(x)\n    return P\n\ndef scattering_amplitude(mu, k, S, P_vals):\n    \"\"\"\n    Compute f(mu) = (1/(2 i k)) sum_{l} (2l+1) (S_l - 1) P_l(mu)\n    mu: array of cos(theta) values\n    k: incident momentum magnitude [fm^-1]\n    S: array of complex S_l values, length L\n    P_vals: array of shape (L, len(mu)) with P_l(mu)\n    Returns complex array f(mu).\n    \"\"\"\n    l_indices = np.arange(S.size)\n    weights = (2 * l_indices + 1).astype(float)\n    # Broadcast weights and S-1 over mu samples\n    coeff = weights * (S - 1.0)\n    # Sum over l with P_l(mu)\n    sum_over_l = np.dot(coeff, P_vals)  # shape (len(mu),)\n    f_mu = sum_over_l / (2j * k)\n    return f_mu\n\ndef sigma_elastic(k, S, P_vals, nodes, weights):\n    \"\"\"\n    Compute elastic cross section via Gauss-Legendre quadrature:\n    sigma_el = 2 pi \\int_{-1}^1 dmu |f(mu)|^2\n    \"\"\"\n    f_mu = scattering_amplitude(nodes, k, S, P_vals)\n    integrand = np.abs(f_mu) ** 2\n    sigma_el = 2.0 * np.pi * np.sum(weights * integrand)\n    return sigma_el\n\ndef sigma_total_optical(k, S):\n    \"\"\"\n    Compute total cross section via optical theorem in partial waves:\n    sigma_tot = (2 pi / k^2) sum_l (2l+1) [1 - Re S_l]\n    \"\"\"\n    l_indices = np.arange(S.size)\n    weights = (2 * l_indices + 1).astype(float)\n    sigma_tot = (2.0 * np.pi / (k ** 2)) * np.sum(weights * (1.0 - np.real(S)))\n    return sigma_tot\n\ndef sigma_breakup(k, etas, l_max):\n    \"\"\"\n    Compute breakup cross section via flux deficit:\n    sigma_break = (pi / k^2) sum_l (2l+1) [1 - eta_l^2]\n    \"\"\"\n    l_indices = np.arange(l_max + 1)\n    weights = (2 * l_indices + 1).astype(float)\n    sigma_br = (np.pi / (k ** 2)) * np.sum(weights * (1.0 - etas ** 2))\n    return sigma_br\n\ndef build_S_from_params(deltas, etas):\n    \"\"\"\n    Construct S_l = eta_l * exp(2 i delta_l)\n    deltas and etas are arrays for l = 0..l_max\n    \"\"\"\n    deltas = np.asarray(deltas, dtype=float)\n    etas = np.asarray(etas, dtype=float)\n    S = etas * np.exp(2j * deltas)\n    return S\n\ndef gauss_legendre_nodes_weights(N):\n    \"\"\"\n    Return nodes and weights for Gauss-Legendre quadrature over [-1,1].\n    \"\"\"\n    nodes, weights = np.polynomial.legendre.leggauss(N)\n    return nodes, weights\n\ndef run_test_case(k, deltas, etas, Nmu, tol):\n    \"\"\"\n    Run a single test case:\n    - Build S_l\n    - Compute sigma_tot via optical theorem\n    - Compute sigma_el via quadrature of |f(mu)|^2\n    - Compute sigma_break from flux deficit\n    - Return boolean of |sigma_tot - (sigma_el + sigma_break)| <= tol\n    \"\"\"\n    deltas = np.asarray(deltas, dtype=float)\n    etas = np.asarray(etas, dtype=float)\n    l_max = deltas.size - 1\n    # Build S_l\n    S = build_S_from_params(deltas, etas)\n    # Gauss-Legendre quadrature nodes and weights\n    nodes, weights = gauss_legendre_nodes_weights(Nmu)\n    # Precompute Legendre polynomials P_l(mu)\n    P_vals = legendre_polynomials(l_max, nodes)\n    # Compute cross sections\n    sigma_el = sigma_elastic(k, S, P_vals, nodes, weights)\n    sigma_tot = sigma_total_optical(k, S)\n    sigma_br = sigma_breakup(k, etas, l_max)\n    # Compare within tolerance\n    diff = abs(sigma_tot - (sigma_el + sigma_br))\n    return diff <= tol\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Test Case A\n    k_A = 1.0\n    deltas_A = [0.3, -0.15, 0.2, -0.05, 0.08]\n    etas_A = [0.9, 0.85, 0.7, 1.0, 0.6]\n    Nmu_A = 200\n    tol_A = 1e-7\n\n    # Test Case B (pure elastic)\n    k_B = 0.7\n    deltas_B = [0.25, -0.35, 0.1, -0.28]\n    etas_B = [1.0, 1.0, 1.0, 1.0]\n    Nmu_B = 180\n    tol_B = 1e-8\n\n    # Test Case C (strong breakup)\n    k_C = 1.8\n    deltas_C = [0.1, -0.2, 0.05, 0.3, -0.15, 0.22, -0.12]\n    etas_C = [0.3, 0.2, 0.5, 0.4, 0.6, 0.7, 0.5]\n    Nmu_C = 500\n    tol_C = 1e-7\n\n    # Test Case D (numerically challenging)\n    k_D = 1.2\n    l_max_D = 20\n    deltas_D = [0.2 * np.sin(0.4 * l) for l in range(l_max_D + 1)]\n    etas_D = [max(0.0, min(1.0, 0.9 - 0.03 * l)) for l in range(l_max_D + 1)]\n    Nmu_D = 12\n    tol_D = 1e-6\n\n    test_cases = [\n        (k_A, deltas_A, etas_A, Nmu_A, tol_A),\n        (k_B, deltas_B, etas_B, Nmu_B, tol_B),\n        (k_C, deltas_C, etas_C, Nmu_C, tol_C),\n        (k_D, deltas_D, etas_D, Nmu_D, tol_D),\n    ]\n\n    results = []\n    for case in test_cases:\n        k, deltas, etas, Nmu, tol = case\n        result = run_test_case(k, deltas, etas, Nmu, tol)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3599037"}, {"introduction": "The interactions used in Faddeev calculations are typically effective potentials that require regularization to manage their behavior at high momenta (in the ultraviolet regime). This practice delves into the important topic of model systematics by exploring how the choice of a regulator function impacts calculated observables. By comparing different regulators calibrated to the same low-energy physics, you will quantify the resulting artifacts in the high-momentum tail of the spectator wave function, developing a critical perspective on the theoretical uncertainties inherent in such models [@problem_id:3598952].", "problem": "You are to implement, from first principles, a computational comparison of spectator momentum distributions arising in a three-body bound-state problem formulated via the Faddeev approach with short-range pairwise interactions. Work in a dimensionless, nonrelativistic framework with Planck’s reduced constant set to unity and particle masses absorbed into the momentum and energy scales so that all quantities are dimensionless. The three-body bound-state spectator amplitude is modeled as the solution of a homogeneous one-dimensional integral equation in the spectator momentum variable. The model reflects an S-wave rank-one separable pair interaction and inserts an ultraviolet regulator. You will compare different regulator choices and quantify the regulator artifacts in the high-momentum tail of the spectator momentum distribution.\n\nFundamental base to be used:\n- The three-body Faddeev equations for identical particles with S-wave interactions reduce, after angular averaging, to a one-dimensional homogeneous integral equation for the spectator amplitude. For a rank-one separable two-body potential, this equation simplifies to an integral equation with a positive, symmetric-in-momenta kernel that contains the free three-body resolvent and the form factor.\n- The S-wave momentum-space measure is $ \\mathrm{d}^3 p = 4\\pi\\, p^2 \\mathrm{d}p $, yielding radial integrals of the form $ \\int_0^\\infty \\mathrm{d}p\\, p^2\\,(\\cdots) $.\n- Ultraviolet regularization is introduced by multiplying the form factor by a regulator function $ r_\\Lambda(p) $ that suppresses high momenta above a scale $ \\Lambda $.\n\nModel specification to implement:\n1. Use the homogeneous integral equation for the spectator amplitude $ \\phi(p) $,\n   $$\n   \\phi(p) \\;=\\; C \\int_0^{\\infty} \\mathrm{d}q\\, q^2\\, K_\\Lambda(p,q)\\, \\phi(q),\n   $$\n   with kernel\n   $$\n   K_\\Lambda(p,q) \\;=\\; \\frac{r_\\Lambda(p)\\, g(p)\\; r_\\Lambda(q)\\, g(q)}{p^2 + q^2 + \\kappa^2}.\n   $$\n   Here $ g(p) $ is a rank-one form factor and $ \\kappa $ is a positive scale mimicking the binding momentum appearing in the free three-body propagator. The constant $ C $ represents the net coupling strength of the effective kernel.\n\n2. Use the Yamaguchi-type form factor\n   $$\n   g(p) \\;=\\; \\frac{1}{p^2 + \\beta^2},\n   $$\n   with $ \\beta = 1 $, and set $ \\kappa = 1 $.\n\n3. Implement three regulator choices:\n   - Sharp cutoff:\n     $$\n     r_\\Lambda^{\\mathrm{sharp}}(p) \\;=\\; \\Theta(\\Lambda - p),\n     $$\n     where $ \\Theta(x) $ is the Heaviside step function.\n   - Gaussian:\n     $$\n     r_\\Lambda^{\\mathrm{gauss}}(p) \\;=\\; \\exp\\!\\Big(-\\big(\\tfrac{p}{\\Lambda}\\big)^2\\Big).\n     $$\n   - Exponential of order $ n $ (with integer $ n \\ge 2 $):\n     $$\n     r_\\Lambda^{\\mathrm{exp}(n)}(p) \\;=\\; \\exp\\!\\Big(-\\big(\\tfrac{p}{\\Lambda}\\big)^n\\Big).\n     $$\n\n4. Discretize the integral equation by a quadrature with $ N $ nodes on $ [0,p_{\\max}] $. Denote the nodes by $ \\{p_i\\}_{i=1}^N $ and weights by $ \\{w_i\\}_{i=1}^N $. Approximate\n   $$\n   \\phi(p_i) \\;\\approx\\; C \\sum_{j=1}^N w_j\\, p_j^2\\, K_\\Lambda(p_i,p_j)\\, \\phi(p_j),\n   $$\n   which is a homogeneous matrix eigenvalue problem. Let $ M_\\Lambda $ be the $ N \\times N $ matrix with entries\n   $$\n   (M_\\Lambda)_{ij} \\;=\\; w_j\\, p_j^2\\, \\frac{r_\\Lambda(p_i)\\, g(p_i)\\; r_\\Lambda(p_j)\\, g(p_j)}{p_i^2 + p_j^2 + \\kappa^2}.\n   $$\n   Then the integral equation becomes $ \\boldsymbol{\\phi} = C\\, M_\\Lambda\\, \\boldsymbol{\\phi} $. The principal (largest) eigenvalue of $ M_\\Lambda $ controls the existence of a nontrivial solution at a given $ C $.\n\n5. Determine the coupling $ C $ by calibrating to a reference regulator choice so that the principal eigenvalue equals unity for that choice. Specifically, for the reference regulator $ r_{\\Lambda_{\\mathrm{ref}}}^{\\mathrm{gauss}} $ with $ \\Lambda_{\\mathrm{ref}} = 15 $, compute the largest eigenvalue $ \\lambda_{\\mathrm{ref}} $ of $ M_{\\Lambda_{\\mathrm{ref}}} $ with $ C=1 $, and set\n   $$\n   C_{\\mathrm{ref}} \\;=\\; \\frac{1}{\\lambda_{\\mathrm{ref}}}.\n   $$\n   Use the same $ C_{\\mathrm{ref}} $ for all other regulator choices when computing their spectator amplitudes; this isolates regulator artifacts at fixed low-momentum calibration.\n\n6. For each regulator choice, extract the principal right eigenvector $ \\boldsymbol{\\phi} $ of $ C_{\\mathrm{ref}} M_\\Lambda $ and normalize it to unit probability in S-wave measure:\n   $$\n   \\sum_{i=1}^N w_i\\, p_i^2\\, |\\phi(p_i)|^2 \\;=\\; 1.\n   $$\n   Define the spectator momentum distribution\n   $$\n   n(p_i) \\;=\\; |\\phi(p_i)|^2.\n   $$\n\n7. Define a tail region $ p \\in [p_{\\mathrm{tail,min}}, p_{\\mathrm{tail,max}}] $ with $ p_{\\mathrm{tail,min}} = 8 $ and $ p_{\\mathrm{tail,max}} = 15 $. Quantify the regulator artifact for a given regulator by the relative weighted $ L^2 $ error in the tail against the reference distribution $ n_{\\mathrm{ref}}(p) $ computed with the Gaussian reference regulator:\n   $$\n   \\varepsilon_{\\mathrm{tail}} \\;=\\; \\frac{\\Big(\\sum_{i \\in \\mathcal{T}} w_i\\, p_i^2\\, \\big[n(p_i) - n_{\\mathrm{ref}}(p_i)\\big]^2\\Big)^{1/2}}{\\Big(\\sum_{i \\in \\mathcal{T}} w_i\\, p_i^2\\, n_{\\mathrm{ref}}(p_i)^2\\Big)^{1/2}},\n   $$\n   where $ \\mathcal{T} $ indexes the nodes $ p_i $ in the tail interval.\n\nImplementation details to use:\n- Use Gauss–Legendre quadrature on $ [0,p_{\\max}] $ with $ N = 160 $ and $ p_{\\max} = 20 $.\n- Use $ \\beta = 1 $ and $ \\kappa = 1 $.\n- Compute the dominant eigenvalue and eigenvector by a power iteration scheme with a relative tolerance of $ 10^{-10} $ and a maximum of $ 2000 $ iterations.\n\nTest suite:\nYou must compute $ \\varepsilon_{\\mathrm{tail}} $ for each of the following regulator parameter sets. Each set is a triple $ (\\mathrm{type}, \\Lambda, n) $, where $ n $ is ignored for non-exponential types.\n\n- $ (\\text{sharp}, 3, 0) $\n- $ (\\text{sharp}, 6, 0) $\n- $ (\\text{gauss}, 3, 0) $\n- $ (\\text{exp}, 3, 4) $\n- $ (\\text{exp}, 6, 4) $\n- $ (\\text{gauss}, 10, 0) $\n\nFinal output format:\nYour program should produce a single line of output containing the six tail errors as a comma-separated list enclosed in square brackets, with each number formatted in scientific notation with six digits after the decimal point (for example, $[1.234567\\mathrm{e}{-}03,2.345678\\mathrm{e}{-}02,\\dots]$). There are no physical units in this problem; all quantities are dimensionless by construction. Angles do not appear explicitly and need not be specified in any unit.", "solution": "The problem requires a numerical investigation into the effects of ultraviolet regulators on the spectator momentum distribution in a simplified three-body bound-state model. The model is based on the Faddeev equations, which, for identical particles with S-wave interactions and a rank-one separable potential, reduce to a one-dimensional homogeneous integral equation. We will discretize this equation, solve it as a matrix eigenvalue problem, and quantify the differences in the high-momentum tail of the solution for various regulator choices.\n\nThe starting point is the homogeneous integral equation for the spectator amplitude $ \\phi(p) $:\n$$\n\\phi(p) \\;=\\; C \\int_0^{\\infty} \\mathrm{d}q\\, q^2\\, K_\\Lambda(p,q)\\, \\phi(q)\n$$\nA non-trivial solution $ \\phi(p) \\neq 0 $ exists only for a specific value of the coupling constant $ C $. The kernel $ K_\\Lambda(p,q) $ is defined as:\n$$\nK_\\Lambda(p,q) \\;=\\; \\frac{r_\\Lambda(p)\\, g(p)\\; r_\\Lambda(q)\\, g(q)}{p^2 + q^2 + \\kappa^2}\n$$\nHere, $ g(p) $ is the form factor of the two-body interaction, $ r_\\Lambda(p) $ is a regulator function suppressing momenta above the scale $ \\Lambda $, and $ \\kappa $ is a constant related to the three-body binding energy. We are given the Yamaguchi form factor $ g(p) = \\frac{1}{p^2 + \\beta^2} $ with $ \\beta = 1 $, and we set $ \\kappa = 1 $.\n\nThe provided regulator functions are:\n1.  Sharp cutoff: $ r_\\Lambda^{\\mathrm{sharp}}(p) = \\Theta(\\Lambda - p) $, where $ \\Theta $ is the Heaviside step function.\n2.  Gaussian: $ r_\\Lambda^{\\mathrm{gauss}}(p) = \\exp\\!\\left(-\\left(\\frac{p}{\\Lambda}\\right)^2\\right) $.\n3.  Exponential: $ r_\\Lambda^{\\mathrm{exp}(n)}(p) = \\exp\\!\\left(-\\left(\\frac{p}{\\Lambda}\\right)^n\\right) $.\n\nTo solve the integral equation numerically, we discretize it using a quadrature rule. We will use Gauss-Legendre quadrature with $ N = 160 $ points over the momentum interval $ [0, p_{\\max}] $, where $ p_{\\max}=20 $. Let $ \\{x_k'\\}_{k=1}^N $ and $ \\{w_k'\\}_{k=1}^N $ be the standard Gauss-Legendre nodes and weights on $ [-1, 1] $. We map these to our interval $ [0, p_{\\max}] $ to get nodes $ p_i $ and weights $ w_i $:\n$$\np_i = \\frac{p_{\\max}}{2}(1 + x_i'), \\quad w_i = w_i' \\frac{p_{\\max}}{2}\n$$\nThe integral equation is then approximated by a matrix equation:\n$$\n\\phi(p_i) \\;\\approx\\; C \\sum_{j=1}^N w_j\\, p_j^2\\, K_\\Lambda(p_i,p_j)\\, \\phi(p_j)\n$$\nThis is a homogeneous matrix eigenvalue problem $ \\boldsymbol{\\phi} = C M_\\Lambda \\boldsymbol{\\phi} $, where $ \\boldsymbol{\\phi} $ is a vector with components $ \\phi_i = \\phi(p_i) $, and $ M_\\Lambda $ is an $ N \\times N $ matrix with elements:\n$$\n(M_\\Lambda)_{ij} \\;=\\; w_j\\, p_j^2\\, K_\\Lambda(p_i, p_j) \\;=\\; w_j\\, p_j^2\\, \\frac{r_\\Lambda(p_i)\\, g(p_i)\\; r_\\Lambda(p_j)\\, g(p_j)}{p_i^2 + p_j^2 + \\kappa^2}\n$$\nA non-trivial solution exists if $ C $ is the reciprocal of an eigenvalue of $ M_\\Lambda $. The physically meaningful bound state corresponds to the eigenvector associated with the largest positive eigenvalue, $ \\lambda_{\\max} $, of $ M_\\Lambda $. Thus, we must have $ C = 1 / \\lambda_{\\max} $.\n\nThe problem specifies a calibration procedure. We first determine the coupling constant $ C_{\\mathrm{ref}} $ using a reference case: a Gaussian regulator with $ \\Lambda_{\\mathrm{ref}} = 15 $. We construct the matrix $ M_{\\Lambda_{\\mathrm{ref}}} $, find its largest eigenvalue $ \\lambda_{\\mathrm{ref}} $, and set $ C_{\\mathrm{ref}} = 1/\\lambda_{\\mathrm{ref}} $. This coupling constant is then held fixed for all other regulator choices. This procedure ensures that all models are calibrated to the same low-energy physics, allowing a fair comparison of their high-momentum (ultraviolet) behavior.\n\nTo find the largest eigenvalue and its corresponding eigenvector, we employ the power iteration method. Starting with a random vector $ \\boldsymbol{v}^{(0)} $, we iterate:\n$$\n\\boldsymbol{v}^{(k+1)} = \\frac{A \\boldsymbol{v}^{(k)}}{||A \\boldsymbol{v}^{(k)}||}\n$$\nwhere $ A $ is the matrix of interest ($ M_\\Lambda $ for calibration, $ C_{\\mathrm{ref}}M_\\Lambda $ for other cases) and the norm can be any vector norm. The sequence of eigenvectors $ \\boldsymbol{v}^{(k)} $ converges to the principal eigenvector, and the eigenvalue can be estimated from the scaling factor. We iterate until the relative change in the eigenvalue is below a tolerance of $ 10^{-10} $.\n\nFor each regulator in the test suite, we perform the following steps:\n1.  Construct the matrix $ M_\\Lambda $.\n2.  Find the principal right eigenvector $ \\boldsymbol{\\phi} $ of the matrix $ C_{\\mathrm{ref}} M_\\Lambda $ using power iteration.\n3.  The resulting eigenvector $ \\boldsymbol{\\phi} $ must be normalized according to the S-wave probability measure. The normalization condition is that the total probability is unity:\n    $$\n    \\sum_{i=1}^N w_i\\, p_i^2\\, |\\phi(p_i)|^2 = 1\n    $$\n    Let $ \\boldsymbol{\\phi}_{\\mathrm{unnorm}} $ be the eigenvector from the power method. The normalized eigenvector is $ \\boldsymbol{\\phi} = \\boldsymbol{\\phi}_{\\mathrm{unnorm}} / \\mathcal{N} $, where the normalization constant is $ \\mathcal{N} = \\sqrt{\\sum_{i=1}^N w_i\\, p_i^2\\, |\\phi_{\\mathrm{unnorm}}(p_i)|^2} $.\n4.  The spectator momentum distribution is then given by $ n(p_i) = |\\phi(p_i)|^2 $.\n\nFinally, we quantify the deviation of each calculated distribution $ n(p) $ from the reference distribution $ n_{\\mathrm{ref}}(p) $ (obtained using the reference regulator). The error metric is the relative weighted $ L^2 $ norm of the difference in the tail region, defined for momenta $ p \\in [p_{\\mathrm{tail,min}}, p_{\\mathrm{tail,max}}] $, with $ p_{\\mathrm{tail,min}} = 8 $ and $ p_{\\mathrm{tail,max}} = 15 $:\n$$\n\\varepsilon_{\\mathrm{tail}} \\;=\\; \\frac{\\left(\\sum_{i \\in \\mathcal{T}} w_i\\, p_i^2\\, \\left[n(p_i) - n_{\\mathrm{ref}}(p_i)\\right]^2\\right)^{1/2}}{\\left(\\sum_{i \\in \\mathcal{T}} w_i\\, p_i^2\\, n_{\\mathrm{ref}}(p_i)^2\\right)^{1/2}}\n$$\nwhere $ \\mathcal{T} $ is the set of indices $ i $ such that $ p_i \\in [8, 15] $. This metric measures the regulator artifact in the high-momentum part of the spectator amplitude.\n\nThe entire procedure is implemented computationally. First, the reference calculation determines $ C_{\\mathrm{ref}} $ and $ n_{\\mathrm{ref}}(p) $. Then, for each test case, the corresponding $ n(p) $ is computed using this fixed $ C_{\\mathrm{ref}} $, and the error $ \\varepsilon_{\\mathrm{tail}} $ is calculated.", "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Solves the three-body problem as specified, calculating regulator artifacts.\n    \"\"\"\n    # --- Problem Parameters ---\n    N = 160\n    P_MAX = 20.0\n    BETA = 1.0\n    KAPPA = 1.0\n    \n    # --- Calibration Parameters ---\n    LAMBDA_REF = 15.0\n    REG_REF_TYPE = 'gauss'\n    \n    # --- Power Iteration Parameters ---\n    TOL = 1e-10\n    MAX_ITER = 2000\n    \n    # --- Tail Region Parameters ---\n    P_TAIL_MIN = 8.0\n    P_TAIL_MAX = 15.0\n\n    # --- Test Suite ---\n    test_cases = [\n        ('sharp', 3, 0),\n        ('sharp', 6, 0),\n        ('gauss', 3, 0),\n        ('exp', 3, 4),\n        ('exp', 6, 4),\n        ('gauss', 10, 0),\n    ]\n\n    # --- Numerical Setup: Gauss-Legendre Quadrature ---\n    # Scipy returns nodes x in [-1, 1] and weights w.\n    x_gl, w_gl = roots_legendre(N)\n    # Transform to interval [0, P_MAX]\n    p_nodes = P_MAX * (1.0 + x_gl) / 2.0\n    p_weights = P_MAX * w_gl / 2.0\n\n    # --- Model Functions ---\n    def form_factor_g(p, beta):\n        return 1.0 / (p**2 + beta**2)\n\n    def regulator_r(p, reg_type, lam, n=0):\n        if reg_type == 'sharp':\n            return np.where(p <= lam, 1.0, 0.0)\n        elif reg_type == 'gauss':\n            return np.exp(-(p / lam)**2)\n        elif reg_type == 'exp':\n            if n < 2:\n                raise ValueError(\"Order n must be >= 2 for exponential regulator.\")\n            return np.exp(-(p / lam)**n)\n        else:\n            raise ValueError(f\"Unknown regulator type: {reg_type}\")\n\n    # --- Power Iteration for Principal Eigenvalue/Eigenvector ---\n    def power_iteration(matrix):\n        \"\"\"Finds the largest eigenvalue and corresponding eigenvector of a matrix.\"\"\"\n        # Start with a random vector\n        vec = np.random.rand(matrix.shape[1])\n        vec /= np.linalg.norm(vec)\n        \n        lambda_val = 0.0\n        for _ in range(MAX_ITER):\n            # Matrix-vector product\n            mat_vec = matrix @ vec\n            \n            # Estimate eigenvalue\n            lambda_new = np.linalg.norm(mat_vec)\n            \n            # Normalize eigenvector\n            vec = mat_vec / lambda_new\n            \n            # Check for convergence\n            if abs(lambda_new - lambda_val) / lambda_new < TOL:\n                return lambda_new, vec\n            \n            lambda_val = lambda_new\n            \n        raise RuntimeError(\"Power iteration did not converge.\")\n\n    # --- Main Calculation Logic ---\n    def get_distribution(reg_type, lam, n, coupling_c):\n        \"\"\"\n        Constructs the matrix, solves the eigenvalue problem, and returns\n        the normalized momentum distribution. Also returns eigenvalue if C=1.\n        \"\"\"\n        # Evaluate functions at quadrature nodes\n        g_p = form_factor_g(p_nodes, BETA)\n        r_p = regulator_r(p_nodes, reg_type, lam, n)\n        \n        # Combined momentum-dependent part of the kernel\n        G_p = r_p * g_p\n        \n        # Construct the non-symmetric matrix M\n        # Using broadcasting for efficiency\n        # p_i -> column vector, p_j -> row vector\n        p_i = p_nodes[:, np.newaxis]\n        p_j = p_nodes[np.newaxis, :]\n        G_i = G_p[:, np.newaxis]\n        G_j = G_p[np.newaxis, :]\n        w_j_qj2 = p_weights[np.newaxis, :] * p_j**2\n        \n        numerator = G_i * G_j\n        denominator = p_i**2 + p_j**2 + KAPPA**2\n        \n        M_lambda = (numerator / denominator) * w_j_qj2\n\n        # In calibration phase, we need lambda_ref for M_lambda (C=1)\n        if coupling_c == 1.0:\n            lambda_max, phi_unnorm = power_iteration(M_lambda)\n            return lambda_max, phi_unnorm\n        \n        # For test cases, solve eigenvalue problem for C_ref * M_lambda\n        full_matrix = coupling_c * M_lambda\n        _, phi_unnorm = power_iteration(full_matrix)\n        \n        # Normalize the eigenvector phi\n        # The eigenvector components are all positive -> abs() is not strictly needed\n        norm_sq = np.sum(p_weights * p_nodes**2 * phi_unnorm**2)\n        phi_norm = phi_unnorm / np.sqrt(norm_sq)\n        \n        # Calculate momentum distribution n(p) = |phi(p)|^2\n        n_p = phi_norm**2\n        return n_p\n\n    # --- Step 1: Calibration to find C_ref and n_ref ---\n    lambda_ref, _ = get_distribution(REG_REF_TYPE, LAMBDA_REF, 0, 1.0)\n    C_ref = 1.0 / lambda_ref\n    \n    n_ref = get_distribution(REG_REF_TYPE, LAMBDA_REF, 0, C_ref)\n    \n    # --- Step 2: Loop through test cases and compute errors ---\n    results = []\n    \n    # Identify indices for the tail region\n    tail_mask = (p_nodes >= P_TAIL_MIN) & (p_nodes <= P_TAIL_MAX)\n    p_tail = p_nodes[tail_mask]\n    w_tail = p_weights[tail_mask]\n    n_ref_tail = n_ref[tail_mask]\n\n    for reg_type, lam, n in test_cases:\n        # Get the momentum distribution for the current test case\n        n_p = get_distribution(reg_type, lam, n, C_ref)\n        n_p_tail = n_p[tail_mask]\n\n        # Calculate the weighted L2 error in the tail\n        numerator_sq = np.sum(w_tail * p_tail**2 * (n_p_tail - n_ref_tail)**2)\n        denominator_sq = np.sum(w_tail * p_tail**2 * n_ref_tail**2)\n        \n        if denominator_sq == 0:\n            # Handle case of zero denominator, though unlikely here\n            error_tail = np.inf if numerator_sq > 0 else 0.0\n        else:\n            error_tail = np.sqrt(numerator_sq / denominator_sq)\n            \n        results.append(error_tail)\n\n    # --- Final Output ---\n    output_str = \",\".join([f\"{res:.6e}\" for res in results])\n    print(f\"[{output_str}]\")\n\nsolve()\n\n```", "id": "3598952"}]}