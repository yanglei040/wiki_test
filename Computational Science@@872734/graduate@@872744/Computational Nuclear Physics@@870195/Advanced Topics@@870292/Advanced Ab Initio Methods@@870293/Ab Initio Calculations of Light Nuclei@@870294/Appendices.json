{"hands_on_practices": [{"introduction": "A crucial first step in many modern *ab initio* calculations is to \"soften\" the nuclear Hamiltonian, making it more amenable to solution in a truncated basis. The Similarity Renormalization Group (SRG) provides a powerful and systematic way to achieve this by applying a continuous unitary transformation that drives the Hamiltonian matrix towards a band-diagonal form while preserving its eigenvalues. This practice will give you hands-on experience implementing the SRG flow equation and verifying its two most important features: the suppression of off-diagonal couplings and the preservation of the energy spectrum [@problem_id:3541264].", "problem": "Consider an ab initio description of light nuclei in a truncated basis where the many-body Hamiltonian is represented by a finite, real, symmetric matrix. The Similarity Renormalization Group (SRG) is a unitary transformation designed to continuously evolve the Hamiltonian to suppress off-diagonal couplings while preserving the spectrum. Starting from the nonrelativistic Hamiltonian and the principle that unitary similarity transformations preserve eigenvalues, one can define a flow with a generator constructed from a fixed reference operator. In this problem, take the generator to be the commutator of the kinetic energy operator with the evolving Hamiltonian.\n\nFundamental base:\n- Let $H_s$ denote the Hamiltonian at flow parameter $s$. The SRG flow is generated by an anti-Hermitian operator $\\eta_s$ satisfying the ordinary differential equation (ODE) $$\\frac{dH_s}{ds} = [\\eta_s, H_s],$$ where $[\\cdot,\\cdot]$ denotes the commutator.\n- Choose the generator $\\eta_s$ to be $$\\eta_s = [T, H_s],$$ where $T$ is the fixed kinetic energy operator (diagonal in the chosen basis).\n- The flow is unitary and thus preserves the eigenvalues of $H_s$ for all $s$, provided the ODE is integrated exactly.\n\nTask:\n- Implement the SRG ODE in matrix form for given $T$ and initial Hamiltonian $H_0 = H_{s=0}$: $$\\frac{dH_s}{ds} = [[T, H_s], H_s].$$\n- Numerically integrate the ODE from $s=0$ to $s=s_{\\text{end}}$ for each specified test case.\n- For each test case, compute two quantities at $s=s_{\\text{end}}$:\n  1. The maximum absolute difference between the sorted eigenvalues of $H_0$ and $H_{s_{\\text{end}}}$, denoted $d_{\\text{spec}}$, expressed in mega-electron volts (MeV). Compute $$d_{\\text{spec}} = \\max_i \\left| \\lambda_i(H_0) - \\lambda_i(H_{s_{\\text{end}}}) \\right|,$$ where the eigenvalues are sorted in ascending order.\n  2. The Frobenius norm of the off-diagonal part of $H_{s_{\\text{end}}}$, denoted $\\|H_{\\text{off}}(s_{\\text{end}})\\|_F$, expressed in mega-electron volts (MeV). Compute $$\\|H_{\\text{off}}(s_{\\text{end}})\\|_F = \\sqrt{\\sum_{i\\neq j} \\left(H_{s_{\\text{end}},ij}\\right)^2}.$$\n\nScientific realism:\n- $T$ is diagonal with entries corresponding to single-particle kinetic energies in mega-electron volts (MeV). The initial Hamiltonian $H_0$ includes both kinetic and potential contributions and is real symmetric.\n- The flow parameter $s$ has units of $\\text{MeV}^{-2}$. All energies are in MeV.\n\nNumerical and output requirements:\n- Use a robust ODE integrator to solve for $H_s$ up to $s_{\\text{end}}$ with sufficient precision to demonstrate spectral invariance numerically.\n- Round each reported float to six decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,...]\"). For each test case, output in order the two floats $d_{\\text{spec}}$ and $\\|H_{\\text{off}}(s_{\\text{end}})\\|_F$, so that the final output aggregates all test cases sequentially.\n\nTest suite:\n- Test case $1$ (two-level, nondegenerate kinetic energies; moderate flow): \n  - $$T = \\begin{pmatrix} 5 & 0 \\\\ 0 & 25 \\end{pmatrix} \\text{ MeV}, \\quad H_0 = \\begin{pmatrix} 2 & 8 \\\\ 8 & 24 \\end{pmatrix} \\text{ MeV}, \\quad s_{\\text{end}} = 0.02 \\text{ MeV}^{-2}.$$\n- Test case $2$ (boundary case, zero flow):\n  - $$T = \\begin{pmatrix} 5 & 0 \\\\ 0 & 25 \\end{pmatrix} \\text{ MeV}, \\quad H_0 = \\begin{pmatrix} 2 & 8 \\\\ 8 & 24 \\end{pmatrix} \\text{ MeV}, \\quad s_{\\text{end}} = 0 \\text{ MeV}^{-2}.$$\n- Test case $3$ (degenerate kinetic energies; generator vanishes):\n  - $$T = \\begin{pmatrix} 10 & 0 \\\\ 0 & 10 \\end{pmatrix} \\text{ MeV}, \\quad H_0 = \\begin{pmatrix} 12 & 4 \\\\ 4 & 9 \\end{pmatrix} \\text{ MeV}, \\quad s_{\\text{end}} = 0.2 \\text{ MeV}^{-2}.$$\n- Test case $4$ (three-level, widely spaced kinetic energies; noticeable decoupling):\n  - $$T = \\begin{pmatrix} 5 & 0 & 0 \\\\ 0 & 15 & 0 \\\\ 0 & 0 & 40 \\end{pmatrix} \\text{ MeV}, \\quad H_0 = \\begin{pmatrix} 4 & 3 & -2 \\\\ 3 & 17 & 4 \\\\ -2 & 4 & 37 \\end{pmatrix} \\text{ MeV}, \\quad s_{\\text{end}} = 0.05 \\text{ MeV}^{-2}.$$\n- Test case $5$ (three-level, near-degenerate pair; stronger flow):\n  - $$T = \\begin{pmatrix} 20 & 0 & 0 \\\\ 0 & 20.1 & 0 \\\\ 0 & 0 & 60 \\end{pmatrix} \\text{ MeV}, \\quad H_0 = \\begin{pmatrix} 20.5 & 5 & -4 \\\\ 5 & 19.9 & 3 \\\\ -4 & 3 & 58.5 \\end{pmatrix} \\text{ MeV}, \\quad s_{\\text{end}} = 0.1 \\text{ MeV}^{-2}.$$\n\nAnswer specification:\n- The program must output a list of $10$ floats (two per test case), each rounded to six decimal places, expressed in MeV, in the exact order: $[d_{\\text{spec}}^{(1)}, \\|H_{\\text{off}}^{(1)}\\|_F, d_{\\text{spec}}^{(2)}, \\|H_{\\text{off}}^{(2)}\\|_F, \\dots, d_{\\text{spec}}^{(5)}, \\|H_{\\text{off}}^{(5)}\\|_F]$.", "solution": "The problem as stated is subjected to validation.\n\n### Step 1: Extract Givens\n- **Governing Equation (SRG ODE)**: The Hamiltonian $H_s$ at flow parameter $s$ evolves according to the ordinary differential equation (ODE):\n$$\n\\frac{dH_s}{ds} = [\\eta_s, H_s]\n$$\n- **Generator Choice**: The generator $\\eta_s$ is chosen as the commutator of the kinetic energy operator $T$ with the evolving Hamiltonian $H_s$:\n$$\n\\eta_s = [T, H_s]\n$$\n- **Combined ODE**: Substituting the generator into the SRG ODE gives the specific flow equation to be solved:\n$$\n\\frac{dH_s}{ds} = [[T, H_s], H_s]\n$$\n- **Initial Condition**: Integration starts from an initial Hamiltonian $H_0 = H_{s=0}$.\n- **Properties**: $H_s$ is a real, symmetric matrix. $T$ is a real, diagonal matrix. The eigenvalues of $H_s$ are preserved for all $s$ under exact integration.\n- **Quantities to Compute at $s=s_{\\text{end}}$**:\n    1.  **Spectral Deviation ($d_{\\text{spec}}$)**: $d_{\\text{spec}} = \\max_i \\left| \\lambda_i(H_0) - \\lambda_i(H_{s_{\\text{end}}}) \\right|$, where eigenvalues $\\lambda_i$ are sorted in ascending order. Units are MeV.\n    2.  **Off-Diagonal Frobenius Norm ($\\|H_{\\text{off}}(s_{\\text{end}})\\|_F$)**: $\\|H_{\\text{off}}(s_{\\text{end}})\\|_F = \\sqrt{\\sum_{i\\neq j} \\left(H_{s_{\\text{end}},ij}\\right)^2}$. Units are MeV.\n- **Units**: All energies ($T$, $H$) are in MeV. The flow parameter $s$ has units of $\\text{MeV}^{-2}$.\n- **Numerical Requirements**: Use a robust ODE integrator. Round final float values to six decimal places.\n- **Test Cases**:\n    - **Case 1**: $T = \\begin{pmatrix} 5 & 0 \\\\ 0 & 25 \\end{pmatrix}$, $H_0 = \\begin{pmatrix} 2 & 8 \\\\ 8 & 24 \\end{pmatrix}$, $s_{\\text{end}} = 0.02$.\n    - **Case 2**: $T = \\begin{pmatrix} 5 & 0 \\\\ 0 & 25 \\end{pmatrix}$, $H_0 = \\begin{pmatrix} 2 & 8 \\\\ 8 & 24 \\end{pmatrix}$, $s_{\\text{end}} = 0$.\n    - **Case 3**: $T = \\begin{pmatrix} 10 & 0 \\\\ 0 & 10 \\end{pmatrix}$, $H_0 = \\begin{pmatrix} 12 & 4 \\\\ 4 & 9 \\end{pmatrix}$, $s_{\\text{end}} = 0.2$.\n    - **Case 4**: $T = \\begin{pmatrix} 5 & 0 & 0 \\\\ 0 & 15 & 0 \\\\ 0 & 0 & 40 \\end{pmatrix}$, $H_0 = \\begin{pmatrix} 4 & 3 & -2 \\\\ 3 & 17 & 4 \\\\ -2 & 4 & 37 \\end{pmatrix}$, $s_{\\text{end}} = 0.05$.\n    - **Case 5**: $T = \\begin{pmatrix} 20 & 0 & 0 \\\\ 0 & 20.1 & 0 \\\\ 0 & 0 & 60 \\end{pmatrix}$, $H_0 = \\begin{pmatrix} 20.5 & 5 & -4 \\\\ 5 & 19.9 & 3 \\\\ -4 & 3 & 58.5 \\end{pmatrix}$, $s_{\\text{end}} = 0.1$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is based on the Similarity Renormalization Group, a standard and well-established method in computational nuclear physics for decoupling Hamiltonians. The choice of generator $\\eta_s = [T, H_s]$ is a common one, designed to drive the Hamiltonian towards a band-diagonal or diagonal form in the basis of the kinetic energy operator. The mathematical formulation involving commutators and unitary transformations is fundamental to quantum mechanics. The problem is a direct application of these principles.\n- **Well-Posed**: The problem is an initial value problem for a system of first-order ODEs. For a finite-dimensional matrix $H_s$ of size $N \\times N$, the governing equation represents a system of $N^2$ coupled ODEs for its elements. The right-hand side, $f(H_s) = [[T, H_s], H_s]$, involves matrix multiplications and additions, which are polynomials in the elements of $H_s$. This function is smooth and globally Lipschitz on any compact domain, guaranteeing the existence and uniqueness of a solution for a given initial condition $H_0$. The task is computationally well-defined.\n- **Objective**: The problem is defined with precise mathematical objects (matrices, ODEs, norms) and specific numerical values for all test cases. There is no ambiguity or subjective language.\n\n### Step 3: Verdict and Action\nThe problem is valid. It is a scientifically sound, well-posed, and objective computational task. A solution will be provided.\n\n### Solution\n\nThe problem requires the numerical integration of a matrix-valued ordinary differential equation that describes the Similarity Renormalization Group (SRG) flow of a nuclear Hamiltonian. The goal is to evolve an initial Hamiltonian $H_0$ to a final Hamiltonian $H_{s_{\\text{end}}}$ and analyze the properties of the result.\n\nThe core of the problem lies in solving the initial value problem:\n$$\n\\frac{dH_s}{ds} = [[T, H_s], H_s], \\quad H(s=0) = H_0\n$$\nwhere $T$ is the kinetic energy matrix, $H_s$ is the Hamiltonian matrix at flow parameter $s$, and $[A, B] = AB - BA$ is the matrix commutator.\n\nThis equation represents a system of $N^2$ coupled nonlinear first-order ODEs, where $N$ is the dimension of the matrices. To solve this system numerically, we employ a standard ODE solver, such as one provided by the `scipy.integrate` library. These solvers operate on one-dimensional state vectors. Therefore, the $N \\times N$ matrix $H_s$ must be flattened into a vector of length $N^2$ to serve as the state variable for the solver.\n\nThe implementation consists of the following steps:\n\n1.  **Define the ODE System Function**: We must create a function, say `f(s, y)`, that computes the time derivative of the state vector `y`. In our case, `y` is the flattened representation of the Hamiltonian matrix $H_s$. The function will:\n    a.  Accept the current flow parameter `s` and the flattened Hamiltonian vector `y`. It will also require the constant kinetic energy matrix $T$ and the matrix dimension $N$ as auxiliary arguments.\n    b.  Reshape the input vector `y` (length $N^2$) into an $N \\times N$ matrix, which we identify as $H_s$.\n    c.  Compute the derivative $\\frac{dH_s}{ds}$ by evaluating the double commutator:\n        i.  First, calculate the inner commutator, which acts as the generator: $\\eta_s = [T, H_s] = T H_s - H_s T$.\n        ii. Second, calculate the outer commutator, which gives the derivative: $\\frac{dH_s}{ds} = [\\eta_s, H_s] = \\eta_s H_s - H_s \\eta_s$.\n    d.  Flatten the resulting $N \\times N$ matrix $\\frac{dH_s}{ds}$ back into a one-dimensional vector of length $N^2$ and return it.\n\n2.  **Integrate the ODE for Each Test Case**: For each provided test case $(T, H_0, s_{\\text{end}})$:\n    a.  Handle trivial-flow cases: If $s_{\\text{end}}=0$ (as in Test Case 2) or if the generator $[T, H_s]$ is identically zero, the Hamiltonian does not evolve, so $H_{s_{\\text{end}}} = H_0$. The generator is identically zero if $T$ is a scalar multiple of the identity matrix (i.e., all its diagonal elements are equal, as in Test Case 3), since it would commute with any $H_s$. In these cases, we bypass the numerical integration.\n    b.  For non-trivial flows, call a numerical ODE solver (e.g., `scipy.integrate.solve_ivp`) with the function defined in step 1, the integration interval $[0, s_{\\text{end}}]$, the flattened initial Hamiltonian $H_0$, and high-precision tolerances (e.g., `rtol=1e-8`, `atol=1e-11`) to accurately capture the near-perfect conservation of eigenvalues.\n    c.  Extract the solution at $s_{\\text{end}}$ and reshape it back into the $N \\times N$ matrix $H_{s_{\\text{end}}}$.\n\n3.  **Compute Final Quantities**: Once $H_{s_{\\text{end}}}$ is obtained, calculate the two required metrics:\n    a.  **Spectral Deviation, $d_{\\text{spec}}$**: This quantity measures the numerical error of the integration, as the eigenvalues must be conserved under an exact unitary transformation.\n        i.  Compute the eigenvalues of the initial Hamiltonian $H_0$, denoted $\\{\\lambda_i(H_0)\\}$. Since $H_0$ is real and symmetric, a specialized algorithm (`numpy.linalg.eigvalsh`) is used for efficiency and stability.\n        ii. Compute the eigenvalues of the final Hamiltonian $H_{s_{\\text{end}}}$, denoted $\\{\\lambda_i(H_{s_{\\text{end}})\\}$.\n        iii. Sort both sets of eigenvalues in ascending order.\n        iv. Calculate the maximum of the absolute differences between corresponding eigenvalues: $d_{\\text{spec}} = \\max_i |\\lambda_i(H_0) - \\lambda_i(H_{s_{\\text{end}}})|$.\n    b.  **Off-Diagonal Frobenius Norm, $\\|H_{\\text{off}}(s_{\\text{end}})\\|_F$**: This quantity measures how much the Hamiltonian has been decoupled (driven towards a diagonal or band-diagonal form). The flow is designed to suppress off-diagonal matrix elements.\n        i.  Construct the off-diagonal part of the final Hamiltonian, $H_{\\text{off}}(s_{\\text{end}})$, by setting its diagonal elements to zero: $H_{\\text{off}} = H_{s_{\\text{end}}} - \\text{diag}(\\text{diag}(H_{s_{\\text{end}}}))$.\n        ii. Compute the Frobenius norm of this matrix: $\\|H_{\\text{off}}\\|_F = \\sqrt{\\sum_{i \\neq j} (H_{s_{\\text{end}},ij})^2}$. This can be done directly using `numpy.linalg.norm`.\n\n4.  **Format Output**: The calculated values for $d_{\\text{spec}}$ and $\\|H_{\\text{off}}(s_{\\text{end}})\\|_F$ for each test case are rounded to six decimal places and aggregated into a single comma-separated list as specified.", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the SRG ODE for a series of test cases and computes specified metrics.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"T\": np.array([[5.0, 0.0], [0.0, 25.0]]),\n            \"H0\": np.array([[2.0, 8.0], [8.0, 24.0]]),\n            \"s_end\": 0.02,\n        },\n        {\n            \"T\": np.array([[5.0, 0.0], [0.0, 25.0]]),\n            \"H0\": np.array([[2.0, 8.0], [8.0, 24.0]]),\n            \"s_end\": 0.0,\n        },\n        {\n            \"T\": np.array([[10.0, 0.0], [0.0, 10.0]]),\n            \"H0\": np.array([[12.0, 4.0], [4.0, 9.0]]),\n            \"s_end\": 0.2,\n        },\n        {\n            \"T\": np.array([[5.0, 0.0, 0.0], [0.0, 15.0, 0.0], [0.0, 0.0, 40.0]]),\n            \"H0\": np.array([[4.0, 3.0, -2.0], [3.0, 17.0, 4.0], [-2.0, 4.0, 37.0]]),\n            \"s_end\": 0.05,\n        },\n        {\n            \"T\": np.array([[20.0, 0.0, 0.0], [0.0, 20.1, 0.0], [0.0, 0.0, 60.0]]),\n            \"H0\": np.array([[20.5, 5.0, -4.0], [5.0, 19.9, 3.0], [-4.0, 3.0, 58.5]]),\n            \"s_end\": 0.1,\n        },\n    ]\n\n    results = []\n\n    def srg_flow_ode(s, h_flat, T, n):\n        \"\"\"\n        Computes the RHS of the SRG ODE: dH/ds = [[T, H], H].\n        The state vector h_flat is the flattened Hamiltonian matrix.\n        \"\"\"\n        H = h_flat.reshape((n, n))\n        \n        # Generator: eta = [T, H]\n        eta = T @ H - H @ T\n        \n        # Derivative: dH/ds = [eta, H]\n        dHds = eta @ H - H @ eta\n        \n        return dHds.flatten()\n\n    for case in test_cases:\n        T = case[\"T\"]\n        H0 = case[\"H0\"]\n        s_end = case[\"s_end\"]\n        n = T.shape[0]\n\n        # Since H is real and symmetric, we use eigvalsh for stability and performance.\n        eigvals0 = np.sort(np.linalg.eigvalsh(H0))\n\n        # Check for trivial flow cases:\n        # 1. Integration time s_end is 0.\n        # 2. T is a scalar multiple of identity, so [T, H] = 0 for any H.\n        #    Since T is given as diagonal, we just check if all diagonal elements are equal.\n        diag_T = np.diag(T)\n        is_T_scalar_multiple = np.allclose(diag_T, diag_T[0])\n\n        if s_end == 0.0 or is_T_scalar_multiple:\n            H_end = H0\n        else:\n            # Numerically integrate the ODE\n            sol = solve_ivp(\n                srg_flow_ode,\n                t_span=[0, s_end],\n                y0=H0.flatten(),\n                args=(T, n),\n                method='RK45',  # A robust standard choice\n                rtol=1e-9,    # Relative tolerance for high precision\n                atol=1e-12    # Absolute tolerance for high precision\n            )\n            H_end = sol.y[:, -1].reshape((n, n))\n        \n        # Compute the spectral deviation d_spec\n        eigvals_end = np.sort(np.linalg.eigvalsh(H_end))\n        d_spec = np.max(np.abs(eigvals0 - eigvals_end))\n\n        # Compute the Frobenius norm of the off-diagonal part of H(s_end)\n        H_off = H_end - np.diag(np.diag(H_end))\n        norm_H_off = np.linalg.norm(H_off, 'fro')\n\n        # Append rounded results to the list\n        results.append(round(d_spec, 6))\n        results.append(round(norm_H_off, 6))\n\n    # Format the final output string exactly as specified.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3541264"}, {"introduction": "The No-Core Shell Model (NCSM) is a foundational variational method for solving the nuclear many-body problem, but its accuracy is limited by the computationally necessary truncation of the basis space. A critical skill for any practitioner is the ability to systematically analyze the convergence of calculated observables as the basis size increases and to extrapolate to the infinite-basis limit. This exercise will guide you through implementing a standard exponential extrapolation for the ground-state energy, a technique essential for extracting high-precision results from a series of finite-space calculations [@problem_id:3541307].", "problem": "Consider the No-Core Shell Model (NCSM) description of the ground-state energy of the alpha particle $^{4}\\mathrm{He}$ computed using a harmonic oscillator single-particle basis characterized by frequency $\\hbar\\Omega$ and a truncation parameter $N_{\\max}$ that limits the total number of excitation quanta. The nuclear Hamiltonian $\\hat{H}$ in an ab initio approach contains realistic two-nucleon and possibly three-nucleon interactions, and the ground state solves the Schrödinger equation $\\hat{H}\\lvert\\Psi_0\\rangle = E_0 \\lvert\\Psi_0\\rangle$. The variational principle ensures that, for a fixed $\\hbar\\Omega$ and increasing $N_{\\max}$, the computed ground-state energy $E(N_{\\max};\\hbar\\Omega)$ monotonically approaches the true energy $E_{\\infty}$ from above.\n\nA widely used, scientifically sound convergence ansatz for sufficiently large $N_{\\max}$ is an exponential approach,\n$$\nE(N_{\\max};\\hbar\\Omega) = E_{\\infty} + c(\\hbar\\Omega)\\,\\mathrm{e}^{-d(\\hbar\\Omega)\\,N_{\\max}},\n$$\nwith $c(\\hbar\\Omega) > 0$ and $d(\\hbar\\Omega) > 0$ depending on the basis frequency $\\hbar\\Omega$. This ansatz encodes the expectation that truncation errors decay exponentially with increasing $N_{\\max}$ due to the short-range character of nuclear interactions and the spectral properties of $\\hat{H}$.\n\nYour task is to design and implement an extrapolation strategy that, given sets of $(N_{\\max}, E)$ points for several $\\hbar\\Omega$ values, fits the model above to estimate $E_{\\infty}$ and then selects the $\\hbar\\Omega$ that minimizes the estimated truncation bias at the largest available $N_{\\max}$ for that set. Define the truncation bias at the largest $N_{\\max}$ as\n$$\n\\Delta_{\\mathrm{trunc}}(\\hbar\\Omega) = c(\\hbar\\Omega)\\,\\mathrm{e}^{-d(\\hbar\\Omega)\\,N_{\\max}^{\\mathrm{max}}},\n$$\nwhere $N_{\\max}^{\\mathrm{max}}$ is the maximum $N_{\\max}$ used for that $\\hbar\\Omega$. The optimal extrapolation strategy is to choose the $\\hbar\\Omega$ that yields the smallest $\\Delta_{\\mathrm{trunc}}(\\hbar\\Omega)$ and report the corresponding extrapolated energy $E_{\\infty}$.\n\nImplement a complete, runnable program that performs the following, strictly in the order given:\n\n- Fit, for each $\\hbar\\Omega$ dataset, the parameters $\\{E_{\\infty}, c, d\\}$ in the model $E(N_{\\max};\\hbar\\Omega) = E_{\\infty} + c\\,\\mathrm{e}^{-d\\,N_{\\max}}$ via nonlinear least squares, enforcing $c>0$ and $d>0$ and $E_{\\infty} < \\min_{N_{\\max}} E(N_{\\max};\\hbar\\Omega)$ to remain consistent with the variational upper-bound property.\n- Compute $\\Delta_{\\mathrm{trunc}}(\\hbar\\Omega)$ from the fitted $c$ and $d$ at the largest $N_{\\max}$ in the dataset.\n- Select the $\\hbar\\Omega$ that minimizes $\\Delta_{\\mathrm{trunc}}(\\hbar\\Omega)$ and record its $\\hbar\\Omega$ and the corresponding fitted $E_{\\infty}$.\n- Repeat the above steps for each scenario in the test suite described below.\n\nUse the following scientifically plausible test suite of synthetic $^{4}\\mathrm{He}$ convergence datasets, generated by the model with known underlying $E_{\\infty}$ and frequency-dependent parameters, without statistical noise. Energies and frequencies must be treated in mega-electron-volts (MeV). The integer values $N_{\\max}$ are dimensionless. For each scenario, the program must construct the datasets and then perform the fits and selection.\n\n- Scenario A (happy path, multiple frequencies, ample data):\n  - True asymptote $E_{\\infty}^{\\mathrm{true}} = -28.30\\,\\mathrm{MeV}$.\n  - Frequencies and parameters:\n    - $\\hbar\\Omega = 12.0\\,\\mathrm{MeV}$ with $c = 10.0\\,\\mathrm{MeV}$ and $d = 0.35$.\n    - $\\hbar\\Omega = 16.0\\,\\mathrm{MeV}$ with $c = 7.0\\,\\mathrm{MeV}$ and $d = 0.50$.\n    - $\\hbar\\Omega = 20.0\\,\\mathrm{MeV}$ with $c = 5.0\\,\\mathrm{MeV}$ and $d = 0.60$.\n    - $\\hbar\\Omega = 24.0\\,\\mathrm{MeV}$ with $c = 6.5\\,\\mathrm{MeV}$ and $d = 0.45$.\n  - Truncations: $N_{\\max} \\in \\{4, 6, 8, 10, 12\\}$.\n\n- Scenario B (boundary condition, fewer points per frequency):\n  - True asymptote $E_{\\infty}^{\\mathrm{true}} = -28.30\\,\\mathrm{MeV}$.\n  - Frequencies and parameters:\n    - $\\hbar\\Omega = 10.0\\,\\mathrm{MeV}$ with $c = 12.0\\,\\mathrm{MeV}$ and $d = 0.30$.\n    - $\\hbar\\Omega = 16.0\\,\\mathrm{MeV}$ with $c = 8.0\\,\\mathrm{MeV}$ and $d = 0.40$.\n    - $\\hbar\\Omega = 22.0\\,\\mathrm{MeV}$ with $c = 6.0\\,\\mathrm{MeV}$ and $d = 0.50$.\n  - Truncations: $N_{\\max} \\in \\{4, 6, 8\\}$.\n\n- Scenario C (edge case, slow convergence):\n  - True asymptote $E_{\\infty}^{\\mathrm{true}} = -28.30\\,\\mathrm{MeV}$.\n  - Frequencies and parameters:\n    - $\\hbar\\Omega = 14.0\\,\\mathrm{MeV}$ with $c = 9.0\\,\\mathrm{MeV}$ and $d = 0.25$.\n    - $\\hbar\\Omega = 18.0\\,\\mathrm{MeV}$ with $c = 7.0\\,\\mathrm{MeV}$ and $d = 0.28$.\n    - $\\hbar\\Omega = 22.0\\,\\mathrm{MeV}$ with $c = 5.0\\,\\mathrm{MeV}$ and $d = 0.33$.\n  - Truncations: $N_{\\max} \\in \\{6, 8, 10, 12, 14\\}$.\n\nFor each scenario, the program must output the selected optimal $\\hbar\\Omega$ in $\\mathrm{MeV}$ and the corresponding extrapolated $E_{\\infty}$ in $\\mathrm{MeV}$, both rounded to three decimal places. The final output format must be a single line containing a comma-separated list of six floating-point values enclosed in square brackets:\n$[\\hbar\\Omega_{\\mathrm{opt}}^{A}, E_{\\infty}^{A}, \\hbar\\Omega_{\\mathrm{opt}}^{B}, E_{\\infty}^{B}, \\hbar\\Omega_{\\mathrm{opt}}^{C}, E_{\\infty}^{C}]$.\nNo additional text is permitted in the output line.", "solution": "The problem presented is a valid and well-posed task in computational nuclear physics. It requires the implementation of a standard data analysis procedure for extrapolating results from *ab initio* No-Core Shell Model (NCSM) calculations to the infinite model space limit. The problem is scientifically grounded, employing a widely accepted exponential convergence ansatz, and provides a clear, objective procedure for determining an optimal basis parameter and the corresponding extrapolated energy. All required data and constraints are fully specified. We will therefore proceed with a complete solution.\n\nThe fundamental goal is to determine the ground-state energy $E_0$ of the alpha particle, ${}^{4}\\text{He}$, by solving the many-body Schrödinger equation, $\\hat{H}\\lvert\\Psi_0\\rangle = E_0 \\lvert\\Psi_0\\rangle$. In the NCSM framework, the nuclear Hamiltonian $\\hat{H}$ is diagonalized in a basis of many-body states constructed from single-particle harmonic oscillator wavefunctions. The basis is necessarily truncated for computational feasibility. This truncation is controlled by the parameter $N_{\\max}$, which limits the total number of harmonic oscillator excitation quanta allowed in a basis state. The single-particle basis itself is defined by the harmonic oscillator frequency $\\hbar\\Omega$.\n\nThe calculated ground-state energy, denoted $E(N_{\\max};\\hbar\\Omega)$, depends on both truncation parameters. The variational principle guarantees that this energy is an upper bound on the true energy, $E(N_{\\max};\\hbar\\Omega) \\ge E_0$. As $N_{\\max}$ increases towards infinity, the calculated energy is expected to converge to the true energy for a fixed $\\hbar\\Omega$. For sufficiently large $N_{\\max}$, this convergence is well-described by the exponential model:\n$$\nE(N_{\\max};\\hbar\\Omega) = E_{\\infty} + c(\\hbar\\Omega)\\,\\mathrm{e}^{-d(\\hbar\\Omega)\\,N_{\\max}}\n$$\nHere, $E_{\\infty}$ represents the extrapolated ground-state energy in the infinite basis limit ($N_{\\max} \\to \\infty$). The parameters $c(\\hbar\\Omega) > 0$ and $d(\\hbar\\Omega) > 0$ are positive, frequency-dependent constants that characterize the rate of convergence.\n\nThe task is to analyze synthetic datasets of $(N_{\\max}, E)$ points generated by this model for several choices of $\\hbar\\Omega$. For each scenario provided, we must identify the optimal $\\hbar\\Omega$ and the corresponding extrapolated energy $E_{\\infty}$. The criterion for optimality is the minimization of the truncation bias at the largest available $N_{\\max}$, denoted $N_{\\max}^{\\mathrm{max}}$. This bias is defined as the difference between the energy at $N_{\\max}^{\\mathrm{max}}$ and the extrapolated asymptote:\n$$\n\\Delta_{\\mathrm{trunc}}(\\hbar\\Omega) = E(N_{\\max}^{\\mathrm{max}};\\hbar\\Omega) - E_{\\infty} = c(\\hbar\\Omega)\\,\\mathrm{e}^{-d(\\hbar\\Omega)\\,N_{\\max}^{\\mathrm{max}}}\n$$\nA smaller $\\Delta_{\\mathrm{trunc}}$ indicates a faster convergence and thus a more reliable extrapolation for a given computational effort (i.e., a given $N_{\\max}^{\\mathrm{max}}$).\n\nThe algorithmic procedure is as follows:\n\n1.  **Data Generation**: For each scenario and each specified $\\hbar\\Omega$, we first construct the synthetic dataset. Using the provided true asymptote $E_{\\infty}^{\\mathrm{true}} = -28.30\\,\\mathrm{MeV}$, the frequency-specific parameters $c$ and $d$, and the set of $N_{\\max}$ values, we calculate the energy points $E(N_{\\max}) = E_{\\infty}^{\\mathrm{true}} + c\\,\\mathrm{e}^{-d\\,N_{\\max}}$.\n\n2.  **Constrained Nonlinear Least-Squares Fitting**: For each dataset corresponding to a single $\\hbar\\Omega$, we fit the parameters $\\{E_{\\infty}, c, d\\}$ of the exponential model. This fitting is performed using the `curve_fit` function from the `scipy.optimize` library. To ensure the physical soundness of the fit, the following constraints are strictly enforced via the `bounds` argument of the function:\n    *   $E_{\\infty} < \\min_{i} E(N_{\\max,i};\\hbar\\Omega)$: The extrapolated energy must be lower than any calculated data point, consistent with the variational principle.\n    *   $c > 0$: The convergence must be from above.\n    *   $d > 0$: The energy must converge as $N_{\\max}$ increases.\n    Since the datasets are generated from the model without noise, the fitting procedure is expected to recover the exact parameters $\\{E_{\\infty}^{\\mathrm{true}}, c, d\\}$ used in the data generation step. Nevertheless, performing the fit is a crucial part of demonstrating the full workflow.\n\n3.  **Truncation Bias Calculation**: With the fitted parameters $\\{E_{\\infty}^{\\mathrm{fit}}, c^{\\mathrm{fit}}, d^{\\mathrm{fit}}\\}$ for each $\\hbar\\Omega$, we compute the truncation bias $\\Delta_{\\mathrm{trunc}} = c^{\\mathrm{fit}}\\,\\mathrm{e}^{-d^{\\mathrm{fit}}\\,N_{\\max}^{\\mathrm{max}}}$, where $N_{\\max}^{\\mathrm{max}}$ is the largest value of $N_{\\max}$ in the respective dataset.\n\n4.  **Optimal Parameter Selection**: Within each scenario, we compare the calculated $\\Delta_{\\mathrm{trunc}}$ values across all available $\\hbar\\Omega$ frequencies. The optimal frequency, $\\hbar\\Omega_{\\mathrm{opt}}$, is identified as the one corresponding to the minimum $\\Delta_{\\mathrm{trunc}}$. The final result for the scenario consists of this $\\hbar\\Omega_{\\mathrm{opt}}$ and its associated extrapolated energy, $E_{\\infty}^{\\mathrm{fit}}$.\n\nThis procedure is repeated for each of the three scenarios (A, B, and C). The final output aggregates the optimal frequency and extrapolated energy pairs from all scenarios into a single formatted string.", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\ndef solve():\n    \"\"\"\n    Implements an extrapolation strategy for No-Core Shell Model calculations.\n    For each scenario, it fits an exponential convergence model to synthetic\n    data sets for several basis frequencies, selects the optimal frequency\n    based on minimum truncation bias, and reports the corresponding\n    extrapolated energy.\n    \"\"\"\n\n    def exponential_model(n_max, e_inf, c, d):\n        \"\"\"\n        Calculates energy based on the exponential convergence ansatz.\n        E(N_max) = E_inf + c * exp(-d * N_max)\n        \"\"\"\n        return e_inf + c * np.exp(-d * n_max)\n\n    scenarios = {\n        'A': {\n            'e_true': -28.30,\n            'n_max': [4, 6, 8, 10, 12],\n            'frequencies': [\n                {'hw': 12.0, 'c': 10.0, 'd': 0.35},\n                {'hw': 16.0, 'c': 7.0, 'd': 0.50},\n                {'hw': 20.0, 'c': 5.0, 'd': 0.60},\n                {'hw': 24.0, 'c': 6.5, 'd': 0.45},\n            ]\n        },\n        'B': {\n            'e_true': -28.30,\n            'n_max': [4, 6, 8],\n            'frequencies': [\n                {'hw': 10.0, 'c': 12.0, 'd': 0.30},\n                {'hw': 16.0, 'c': 8.0, 'd': 0.40},\n                {'hw': 22.0, 'c': 6.0, 'd': 0.50},\n            ]\n        },\n        'C': {\n            'e_true': -28.30,\n            'n_max': [6, 8, 10, 12, 14],\n            'frequencies': [\n                {'hw': 14.0, 'c': 9.0, 'd': 0.25},\n                {'hw': 18.0, 'c': 7.0, 'd': 0.28},\n                {'hw': 22.0, 'c': 5.0, 'd': 0.33},\n            ]\n        }\n    }\n\n    final_results = []\n    \n    # Iterate through scenarios in alphabetical order of keys to ensure consistent output\n    for scenario_key in sorted(scenarios.keys()):\n        scenario_data = scenarios[scenario_key]\n        e_true = scenario_data['e_true']\n        n_max_values = np.array(scenario_data['n_max'], dtype=float)\n        n_max_max = np.max(n_max_values)\n        \n        scenario_fit_results = []\n\n        for freq_params in scenario_data['frequencies']:\n            hw = freq_params['hw']\n            c_true = freq_params['c']\n            d_true = freq_params['d']\n\n            # Step 1: Generate synthetic data\n            e_values = exponential_model(n_max_values, e_true, c_true, d_true)\n\n            # Step 2: Perform constrained nonlinear least-squares fit\n            # Initial guess for the parameters [e_inf, c, d]\n            p0 = [e_values[-1] - 1.0, e_values[0] - e_values[-1], 0.5]\n            \n            # Define bounds: [E_inf, c, d]\n            # E_inf must be < min(E_values), c > 0, d > 0\n            lower_bounds = [-np.inf, 0, 0]\n            upper_bounds = [np.min(e_values), np.inf, np.inf]\n            bounds = (lower_bounds, upper_bounds)\n\n            try:\n                popt, _ = curve_fit(\n                    exponential_model,\n                    n_max_values,\n                    e_values,\n                    p0=p0,\n                    bounds=bounds,\n                    method='trf'\n                )\n                e_inf_fit, c_fit, d_fit = popt\n            except RuntimeError:\n                # In case of fit failure, we would handle it here.\n                # For this problem with perfect data, it's not expected.\n                e_inf_fit, c_fit, d_fit = np.nan, np.nan, np.nan\n\n            # Step 3: Compute truncation bias\n            delta_trunc = c_fit * np.exp(-d_fit * n_max_max)\n            \n            scenario_fit_results.append({\n                'hw': hw,\n                'e_inf': e_inf_fit,\n                'delta_trunc': delta_trunc\n            })\n\n        # Step 4: Select the optimal hw based on minimum truncation bias\n        best_fit = min(scenario_fit_results, key=lambda x: x['delta_trunc'])\n        \n        final_results.append(best_fit['hw'])\n        final_results.append(best_fit['e_inf'])\n\n    # Format the final output string as specified\n    output_str = '[' + ','.join(f'{v:.3f}' for v in final_results) + ']'\n    print(output_str)\n\nsolve()\n```", "id": "3541307"}, {"introduction": "The Coupled-Cluster (CC) method is a non-variational, highly accurate technique that relies on iteratively solving a set of non-linear amplitude equations. A key practical question in any CC calculation is when to terminate the iterative process, as the energy is not guaranteed to improve monotonically. This practice explores the fundamental relationship between the numerical residual of the amplitude equations and the physical error in the ground-state energy, allowing you to design a robust, physics-informed convergence criterion to ensure a desired level of accuracy [@problem_id:3541273].", "problem": "Consider a nonrelativistic nuclear many-body Hamiltonian $H$ acting on an $A$-nucleon Hilbert space and the coupled-cluster (CC) ansatz $|\\Psi\\rangle = e^{T}|\\Phi\\rangle$ with a cluster operator $T$ built from particle-hole excitations on a single-determinant reference $|\\Phi\\rangle$. The exact ground-state energy $E$ for a given nucleus is defined by the time-independent Schrödinger equation $H|\\Psi\\rangle = E|\\Psi\\rangle$. In CC theory, the energy and amplitudes are determined by projecting the similarity-transformed Hamiltonian $\\bar{H} = e^{-T}He^{T}$ onto $|\\Phi\\rangle$ and excited determinants $|\\Phi_{\\mu}\\rangle$, yielding the energy functional $E(T)$ and the amplitude residuals $R_{\\mu}(T) = \\langle \\Phi_{\\mu}|\\bar{H}|\\Phi\\rangle$. The exact solution satisfies $R_{\\mu}(T^{\\star}) = 0$ for all excitation indices $\\mu$.\n\nIn practical iterative solvers for the CC amplitude equations, one monitors the norm of the residual vector $R$, defined for example by the Euclidean norm $\\|R\\| = \\sqrt{\\sum_{\\mu} R_{\\mu}^{2}}$. For a light nucleus such as $^{6}\\mathrm{Li}$, suppose one uses a harmonic-oscillator basis and a softened realistic nucleon-nucleon interaction. Near convergence, a perturbative linearization of the residual equations relates the amplitude correction $\\delta t$ to the residual via the Jacobian $J$ of the residuals, and the energy error $\\Delta E = E(T) - E(T^{\\star})$ to the amplitude correction via the energy gradient $g = \\partial E/\\partial t$ evaluated in the vicinity of the current iterate. The induced operator-norm inequality allows one to bound $\\Delta E$ in terms of $\\|R\\|$, the norm $\\|J^{-1}\\|$, and the norm $\\|g\\|$.\n\nYour tasks are:\n- Starting from the Schrödinger equation $H|\\Psi\\rangle=E|\\Psi\\rangle$, the CC ansatz, the definition of residuals $R_{\\mu}(T)$, and the linearization of the amplitude equations, derive a computable upper bound on the energy error $|\\Delta E|$ as a function of the residual norm $\\|R\\|$, a bound on $\\|J^{-1}\\|$ based on a diagonal approximation by energy denominators, and the energy-gradient norm $\\|g\\|$. Justify each step by invoking standard properties of induced matrix norms and perturbative estimates.\n- Use that in a diagonal (denominator) approximation, the Jacobian $J$ is bounded in operator norm by a minimal excitation energy denominator $\\Delta_{\\min} > 0$, so that $\\|J^{-1}\\| \\leq 1/\\Delta_{\\min}$. Here $\\Delta_{\\min}$ is the smallest magnitude energy denominator across the relevant excitation manifold for $^{6}\\mathrm{Li}$ in the chosen basis.\n- From the derived bound, design a convergence criterion expressed as a strict inequality on $\\|R\\|$ that guarantees a target energy accuracy $|\\Delta E|  10^{-4}$ MeV. The inequality must be expressed in terms of $\\Delta_{\\min}$ and $\\|g\\|$, and must be strict so that the guarantee holds.\n\nImplement a self-contained program that, for each test case, computes:\n1. The upper bound on the energy error in MeV predicted by your derived inequality.\n2. The maximum allowable residual-norm threshold $\\|R\\|_{\\mathrm{thresh}}$ in MeV such that the strict guarantee $|\\Delta E|  10^{-4}$ MeV holds.\n3. A boolean indicating whether the provided residual norm strictly satisfies the designed convergence criterion (that is, whether the computed upper bound is strictly less than $10^{-4}$ MeV).\n\nAll energies must be expressed in mega-electronvolts (MeV). The program must hard-code the following test suite, representing plausible scenarios for $^{6}\\mathrm{Li}$ under different basis and interaction softness choices:\n- Case A (general happy path): residual norm $\\|R\\| = 5\\times 10^{-4}$ MeV, minimal denominator $\\Delta_{\\min} = 12$ MeV, gradient norm $\\|g\\| = 2$ MeV.\n- Case B (boundary condition): residual norm $\\|R\\| = 6\\times 10^{-4}$ MeV, minimal denominator $\\Delta_{\\min} = 12$ MeV, gradient norm $\\|g\\| = 2$ MeV.\n- Case C (small gap edge case): residual norm $\\|R\\| = 1.3\\times 10^{-4}$ MeV, minimal denominator $\\Delta_{\\min} = 3$ MeV, gradient norm $\\|g\\| = 2.5$ MeV.\n- Case D (large gradient with large gap): residual norm $\\|R\\| = 2\\times 10^{-4}$ MeV, minimal denominator $\\Delta_{\\min} = 15$ MeV, gradient norm $\\|g\\| = 5$ MeV.\n- Case E (zero residual): residual norm $\\|R\\| = 0$ MeV, minimal denominator $\\Delta_{\\min} = 8$ MeV, gradient norm $\\|g\\| = 3$ MeV.\n\nYour program should produce a single line of output containing a list of five elements, one per test case, where each element is a sub-list of the form $[E_{\\mathrm{bound}}, R_{\\mathrm{thresh}}, \\mathrm{pass}]$. Here $E_{\\mathrm{bound}}$ is the computed upper bound on $|\\Delta E|$ in MeV, $R_{\\mathrm{thresh}}$ is the computed residual-norm threshold in MeV, and $\\mathrm{pass}$ is a boolean. The output must be printed exactly as a comma-separated list enclosed in square brackets, for example, $[[x_{1},y_{1},b_{1}],[x_{2},y_{2},b_{2}],\\dots]$.", "solution": "The problem posed is a well-defined exercise in applying numerical analysis concepts to the iterative solution of coupled-cluster (CC) amplitude equations in nuclear physics. It is scientifically sound, internally consistent, and contains all necessary information to proceed.\n\nThe solution is developed in three stages as requested: first, the derivation of an upper bound for the energy error; second, the formulation of a convergence criterion based on this bound; and third, the implementation of these calculations for the provided test cases.\n\n**Derivation of the Energy Error Bound**\n\nThe core of the problem lies in relating the energy error $\\Delta E$ to the norm of the residual vector $\\|R\\|$. This is achieved by linearizing the CC equations near the exact solution.\n\nLet $T$ represent the collection of cluster amplitudes, which can be viewed as a vector $t$ in a high-dimensional space. The exact solution $T^{\\star}$ (or $t^{\\star}$) is defined by the condition that all amplitude residuals $R_{\\mu}$ vanish.\n$$R(t^{\\star}) = 0$$\nwhere $R$ is the vector of residuals $R_{\\mu}$.\n\nFor an iterative solver, the current approximation $t$ is not the exact solution, so $R(t) \\neq 0$. We assume we are close to the solution, such that the error in the amplitudes, $\\Delta t = t - t^{\\star}$, is small. A first-order Taylor expansion of the residual vector function $R(t)$ around the exact solution $t^{\\star}$ yields:\n$$R(t) = R(t^{\\star}) + J(t^{\\star}) (t - t^{\\star}) + \\mathcal{O}(\\|\\Delta t\\|^2)$$\nwhere $J(t^{\\star})$ is the Jacobian matrix of the residual function evaluated at the solution, with elements $J_{\\mu\\nu} = \\partial R_{\\mu} / \\partial t_{\\nu}|_{t=t^{\\star}}$.\n\nSince $R(t^{\\star}) = 0$, and approximating the Jacobian at the current iterate $J(t) \\approx J(t^{\\star})$ (a standard practice near convergence), we obtain a linear relationship between the residual $R$ and the amplitude error $\\Delta t$:\n$$R \\approx J \\Delta t$$\nInverting this relationship gives an expression for the amplitude error:\n$$\\Delta t \\approx J^{-1} R$$\n\nNext, we consider the error in the energy, $\\Delta E = E(t) - E(t^{\\star})$. A first-order Taylor expansion of the energy functional $E(t)$ around the solution $t^{\\star}$ gives:\n$$\\Delta E = E(t) - E(t^{\\star}) \\approx g(t^{\\star})^{T} (t - t^{\\star}) = g(t^{\\star})^{T} \\Delta t$$\nwhere $g(t^{\\star})$ is the gradient of the energy with respect to the amplitudes, $g_{\\mu} = \\partial E / \\partial t_{\\mu}$, evaluated at the solution. Again, we approximate $g(t^{\\star}) \\approx g(t) = g$, where $g$ is the gradient at the current iterate.\n$$\\Delta E \\approx g^{T} \\Delta t$$\n\nSubstituting the expression for $\\Delta t$ into the expression for $\\Delta E$, we connect the energy error to the residual:\n$$\\Delta E \\approx g^{T} (J^{-1} R)$$\n\nTo establish a rigorous bound, we take the absolute value and apply standard norm inequalities. Using the Cauchy-Schwarz inequality for the inner product $|u^T v| \\leq \\|u\\| \\|v\\|$ (where $\\|\\cdot\\|$ denotes the Euclidean or $L_2$ norm), we get:\n$$|\\Delta E| \\approx |g^{T} (J^{-1} R)| \\leq \\|g\\| \\|J^{-1} R\\|$$\nNext, we apply the property of the induced matrix norm, $\\|Ax\\| \\leq \\|A\\| \\|x\\|$:\n$$|\\Delta E| \\lesssim \\|g\\| \\|J^{-1}\\| \\|R\\|$$\nThe \"approximately less than or equal to\" sign $\\lesssim$ acknowledges that this bound is derived from a first-order approximation, but it is treated as a strict upper bound by assuming higher-order terms are negligible near convergence.\n\nThe problem states that the inverse Jacobian norm is bounded by the minimal energy denominator, $\\Delta_{\\min}$. This arises from a diagonal approximation of the Jacobian, which is characteristic of Møller-Plesset-like partitioning, where $J_{\\mu\\nu} \\approx (\\epsilon_a + \\epsilon_b + \\dots - \\epsilon_i - \\epsilon_j - \\dots)\\delta_{\\mu\\nu}$. The smallest magnitude of these diagonal energy differences gives $\\Delta_{\\min}$, leading to the bound:\n$$\\|J^{-1}\\| \\leq \\frac{1}{\\Delta_{\\min}}$$\nSubstituting this into our inequality for $|\\Delta E|$ yields the final computable upper bound on the energy error, which we denote $E_{\\mathrm{bound}}$:\n$$|\\Delta E| \\leq \\frac{\\|g\\| \\|R\\|}{\\Delta_{\\min}} \\equiv E_{\\mathrm{bound}}$$\nThis expression fulfills the first task. It provides an upper bound on the energy error $|\\Delta E|$ as a function of the residual norm $\\|R\\|$, the gradient norm $\\|g\\|$, and the minimal energy denominator $\\Delta_{\\min}$.\n\n**Design of the Convergence Criterion**\n\nThe second task is to design a convergence criterion that guarantees a target energy accuracy, specified as $|\\Delta E|  \\epsilon$, where $\\epsilon = 10^{-4} \\text{ MeV}$.\n\nSince we have derived an upper bound for $|\\Delta E|$, the most direct way to guarantee the condition is to require that the upper bound itself is strictly less than the target accuracy $\\epsilon$:\n$$E_{\\mathrm{bound}}  \\epsilon$$\nSubstituting the expression for $E_{\\mathrm{bound}}$:\n$$\\frac{\\|g\\| \\|R\\|}{\\Delta_{\\min}}  \\epsilon$$\nThis inequality is the basis for our convergence criterion. To express it as a condition on the residual norm $\\|R\\|$, we rearrange the terms. Assuming $\\|g\\|  0$ and $\\Delta_{\\min}  0$:\n$$\\|R\\|  \\frac{\\epsilon \\Delta_{\\min}}{\\|g\\|}$$\nWe define the right-hand side as the maximum allowable residual-norm threshold, $\\|R\\|_{\\mathrm{thresh}}$:\n$$\\|R\\|_{\\mathrm{thresh}} = \\frac{\\epsilon \\Delta_{\\min}}{\\|g\\|}$$\nThe convergence criterion is then the strict inequality:\n$$\\|R\\|  \\|R\\|_{\\mathrm{thresh}}$$\nIf a given residual norm $\\|R\\|$ satisfies this condition, the energy error $|\\Delta E|$ is guaranteed to be less than $\\epsilon = 10^{-4} \\text{ MeV}$ within the validity of the linearization.\n\n**Implementation for Test Cases**\n\nThe third task is to implement these formulas for a provided test suite. For each case, we are given values for $\\|R\\|$, $\\Delta_{\\min}$, and $\\|g\\|$. We set $\\epsilon = 10^{-4} \\text{ MeV}$.\n\nFor each test case, we will compute:\n1.  The upper bound on the energy error: $E_{\\mathrm{bound}} = \\frac{\\|g\\| \\|R\\|}{\\Delta_{\\min}}$.\n2.  The residual-norm threshold: $\\|R\\|_{\\mathrm{thresh}} = \\frac{\\epsilon \\Delta_{\\min}}{\\|g\\|}$.\n3.  A boolean flag, `pass`, which is `True` if the convergence criterion is strictly met ($E_{\\mathrm{bound}}  \\epsilon$ or, equivalently, $\\|R\\|  \\|R\\|_{\\mathrm{thresh}}$), and `False` otherwise.\n\nThe program will iterate through the hard-coded test cases, perform these three calculations, and format the results as required.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the coupled-cluster convergence analysis problem.\n\n    For each test case, the function computes:\n    1. E_bound: An upper bound on the energy error in MeV.\n    2. R_thresh: The maximum allowable residual-norm threshold in MeV for a given accuracy.\n    3. pass: A boolean indicating if the given residual norm meets the convergence criterion.\n    \"\"\"\n    \n    # Target energy accuracy in MeV, as specified in the problem.\n    target_accuracy_epsilon = 1e-4\n\n    # Test suite representing plausible scenarios for 6-Li.\n    # Each tuple contains (residual_norm, min_denominator, gradient_norm).\n    # All energy units are MeV.\n    test_cases = [\n        # Case A (general happy path)\n        (5e-4, 12.0, 2.0),\n        # Case B (boundary condition)\n        (6e-4, 12.0, 2.0),\n        # Case C (small gap edge case)\n        (1.3e-4, 3.0, 2.5),\n        # Case D (large gradient with large gap)\n        (2e-4, 15.0, 5.0),\n        # Case E (zero residual)\n        (0.0, 8.0, 3.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        norm_R, delta_min, norm_g = case\n\n        # 1. Compute the upper bound on the energy error, E_bound.\n        # Derived formula: E_bound = (||g|| * ||R||) / Delta_min\n        # We must handle the case where delta_min or norm_g could be zero to avoid division by zero,\n        # although the problem constraints (Delta_min  0) make this unlikely for delta_min.\n        # If norm_g is zero, R_thresh would be infinite. If delta_min is zero, E_bound would be infinite.\n        if delta_min = 0:\n            # Physically, Delta_min  0 is required for a bound state.\n            e_bound = float('inf')\n        else:\n            e_bound = (norm_g * norm_R) / delta_min\n\n        # 2. Compute the maximum allowable residual-norm threshold, R_thresh.\n        # Derived formula: R_thresh = (epsilon * Delta_min) / ||g||\n        if norm_g = 0:\n            # If the gradient norm is zero, any residual is acceptable for this criterion.\n            r_thresh = float('inf')\n        else:\n            r_thresh = (target_accuracy_epsilon * delta_min) / norm_g\n            \n        # 3. Determine if the convergence criterion is strictly satisfied.\n        # The criterion is strict: ||R||  R_thresh, which is equivalent to\n        # the derived energy bound being strictly less than the target accuracy.\n        passes_criterion = e_bound  target_accuracy_epsilon\n\n        results.append([e_bound, r_thresh, passes_criterion])\n\n    # Format the output exactly as a list of lists.\n    # The default string representation of the results list is the desired format.\n    # Example item: [8.333333333333333e-05, 0.0006, True]\n    # The map(str, ...) approach requested in the template is robust for this.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3541273"}]}