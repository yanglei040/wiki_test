{"hands_on_practices": [{"introduction": "The first step in analyzing a rotational band is to determine the rotational frequency $\\omega$ as a function of spin $I$. While defined theoretically as a derivative, $\\hbar\\omega = dE/dI$, experimental data consists of discrete transition energies. This exercise [@problem_id:3543329] challenges you to apply numerical differentiation techniques to estimate $\\omega$ from realistic gamma-ray energy data, exploring the trade-offs between different finite-difference schemes and gaining insight into the numerical challenges encountered when analyzing data near a sharp backbend.", "problem": "In a well-deformed even-even nucleus, a rotational band exhibits a backbending phenomenon in which the kinematic moment of inertia (MOI) changes rapidly with spin. The rotational frequency is defined from first principles by the cranking relation as the derivative of the excitation energy with respect to angular momentum, namely $\\hbar\\omega(I)=\\frac{dE(I)}{dI}$, where $\\hbar$ is the reduced Planck constant and $E(I)$ is the level energy at spin $I$. In spectroscopy, only transition energies are directly measured: $E_\\gamma(I\\to I-2)=E(I)-E(I-2)$. A practical computational task is to estimate $\\hbar\\omega(I)$ from the discrete set of measured $E_\\gamma$ values.\n\nYou are given the following measured $\\gamma$-ray transition energies (all with independent one-standard-deviation uncertainties of $\\pm 2~\\mathrm{keV}$), across a suspected backbend near $I\\approx 18$:\n- $E_\\gamma(12\\to 10)=400~\\mathrm{keV}$,\n- $E_\\gamma(14\\to 12)=460~\\mathrm{keV}$,\n- $E_\\gamma(16\\to 14)=520~\\mathrm{keV}$,\n- $E_\\gamma(18\\to 16)=560~\\mathrm{keV}$,\n- $E_\\gamma(20\\to 18)=500~\\mathrm{keV}$,\n- $E_\\gamma(22\\to 20)=540~\\mathrm{keV}$.\n\nStarting from the definition $\\hbar\\omega(I)=\\frac{dE}{dI}$ and using consistent finite-difference reasoning based solely on the measured $E_\\gamma$ values, determine which of the following statements are correct. Select all that apply.\n\nA. From $\\hbar\\omega(I)=\\frac{dE}{dI}$ and $E_\\gamma(I\\to I-2)=E(I)-E(I-2)$, a symmetric (central) finite-difference estimator on the spin grid with step $h=2$ is\n$\\hbar\\omega(I)\\approx \\dfrac{E_\\gamma(I\\to I-2)+E_\\gamma(I+2\\to I)}{4}$. With the provided data, this gives $\\hbar\\omega(18)\\approx 265~\\mathrm{keV}$, and if each $E_\\gamma$ has an independent standard deviation of $2~\\mathrm{keV}$, the standard deviation of $\\hbar\\omega(18)$ from this estimator is approximately $0.71~\\mathrm{keV}$.\n\nB. A forward one-sided estimator uses only $E_\\gamma(I+2\\to I)$ via $\\hbar\\omega(I)\\approx \\dfrac{E_\\gamma(I+2\\to I)}{2}$. At $I=18$ the estimate is $250~\\mathrm{keV}$; this one-sided estimator has smaller statistical variance than the symmetric estimator and is unbiased even across a sharp backbend.\n\nC. For a smooth rotational band, the truncation error of the symmetric estimator scales as $\\mathcal{O}(h^2)$ in the spin step $h=2$, whereas one-sided estimators scale as $\\mathcal{O}(h)$. Near a backbend, the symmetric estimator at $I=18$ effectively averages pre- and post-crossing local frequencies, introducing additional bias relative to either side, even though its measurement-noise variance is lower than that of one-sided estimates.\n\nD. Using the data, the backward one-sided estimator at $I=18$ gives $\\hbar\\omega\\approx 280~\\mathrm{keV}$, and the symmetric estimator equals the arithmetic mean of the forward and backward one-sided estimates at the same spin.\n\nE. The correct symmetric formula is $\\hbar\\omega(I)\\approx \\dfrac{E_\\gamma(I\\to I-2)+E_\\gamma(I+2\\to I)}{2}$, which with the data yields $\\hbar\\omega(18)\\approx 530~\\mathrm{keV}$, and it has lower truncation error than the $\\dfrac{1}{4}$ version.", "solution": "The problem statement has been critically validated and is determined to be valid. It is scientifically grounded in the principles of nuclear structure physics, specifically the cranking model and the phenomenology of rotational bands. The problem is well-posed, providing all necessary definitions and data to perform a quantitative analysis using standard numerical methods (finite differences). The language is objective and the data are physically realistic.\n\nThe central task is to approximate the rotational frequency, defined as the derivative of energy with respect to angular momentum, $\\hbar\\omega(I) = \\frac{dE(I)}{dI}$, using discrete transition energy data $E_\\gamma(I \\to I-2) = E(I) - E(I-2)$. The spin $I$ is a dimensionless quantity in units of $\\hbar$, and the levels are spaced by $\\Delta I = 2$.\n\nWe first derive the necessary finite-difference estimators for $\\hbar\\omega(I)$.\n\nThe standard central-difference formula for a first derivative $f'(x)$ using a step size $h$ is $f'(x) \\approx \\frac{f(x+h) - f(x-h)}{2h}$. In our context, the function is $E(I)$, the variable is $I$, and the smallest step connecting data points for a symmetric difference is $h=2$. Thus, we have:\n$$ \\hbar\\omega(I) = \\frac{dE}{dI}\\bigg|_I \\approx \\frac{E(I+2) - E(I-2)}{(I+2)-(I-2)} = \\frac{E(I+2) - E(I-2)}{4} $$\nWe can express the numerator in terms of the measurable transition energies:\n$ E(I+2) - E(I-2) = [E(I+2) - E(I)] + [E(I) - E(I-2)] = E_\\gamma(I+2 \\to I) + E_\\gamma(I \\to I-2) $.\nThus, the **symmetric (central) estimator** is:\n$$ \\hbar\\omega_S(I) \\approx \\frac{E_\\gamma(I+2 \\to I) + E_\\gamma(I \\to I-2)}{4} $$\n\nThe one-sided finite-difference estimators are derived similarly. The **forward estimator** uses points $I$ and $I+2$:\n$$ \\hbar\\omega_F(I) = \\frac{dE}{dI}\\bigg|_I \\approx \\frac{E(I+2) - E(I)}{(I+2)-I} = \\frac{E(I+2) - E(I)}{2} = \\frac{E_\\gamma(I+2 \\to I)}{2} $$\nThe **backward estimator** uses points $I-2$ and $I$:\n$$ \\hbar\\omega_B(I) = \\frac{dE}{dI}\\bigg|_I \\approx \\frac{E(I) - E(I-2)}{I-(I-2)} = \\frac{E(I) - E(I-2)}{2} = \\frac{E_\\gamma(I \\to I-2)}{2} $$\n\nThe relevant data for spin $I=18$ are:\n- $E_\\gamma(18 \\to 16) = 560~\\mathrm{keV}$\n- $E_\\gamma(20 \\to 18) = 500~\\mathrm{keV}$\nThe standard deviation for each independent measurement is $\\sigma_{E_\\gamma} = 2~\\mathrm{keV}$.\n\nNow, we evaluate each statement.\n\n**A. From $\\hbar\\omega(I)=\\frac{dE}{dI}$ and $E_\\gamma(I\\to I-2)=E(I)-E(I-2)$, a symmetric (central) finite-difference estimator on the spin grid with step $h=2$ is $\\hbar\\omega(I)\\approx \\dfrac{E_\\gamma(I\\to I-2)+E_\\gamma(I+2\\to I)}{4}$. With the provided data, this gives $\\hbar\\omega(18)\\approx 265~\\mathrm{keV}$, and if each $E_\\gamma$ has an independent standard deviation of $2~\\mathrm{keV}$, the standard deviation of $\\hbar\\omega(18)$ from this estimator is approximately $0.71~\\mathrm{keV}$.**\n\nThe formula provided, $\\hbar\\omega(I)\\approx \\dfrac{E_\\gamma(I\\to I-2)+E_\\gamma(I+2\\to I)}{4}$, matches our derived symmetric estimator $\\hbar\\omega_S(I)$.\nUsing the data for $I=18$:\n$$ \\hbar\\omega_S(18) \\approx \\frac{E_\\gamma(18 \\to 16) + E_\\gamma(20 \\to 18)}{4} = \\frac{560~\\mathrm{keV} + 500~\\mathrm{keV}}{4} = \\frac{1060~\\mathrm{keV}}{4} = 265~\\mathrm{keV} $$\nThis calculation is correct.\nFor the uncertainty, let $X = E_\\gamma(I \\to I-2)$ and $Y = E_\\gamma(I+2 \\to I)$, so $\\hbar\\omega_S = (X+Y)/4$. Given $\\sigma_X = \\sigma_Y = 2~\\mathrm{keV}$ and the measurements are independent, the variance is:\n$$ \\sigma^2_{\\omega_S} = \\left(\\frac{\\partial \\omega_S}{\\partial X}\\right)^2 \\sigma_X^2 + \\left(\\frac{\\partial \\omega_S}{\\partial Y}\\right)^2 \\sigma_Y^2 = \\left(\\frac{1}{4}\\right)^2 \\sigma_X^2 + \\left(\\frac{1}{4}\\right)^2 \\sigma_Y^2 = \\frac{1}{16} (\\sigma_X^2 + \\sigma_Y^2) $$\n$$ \\sigma^2_{\\omega_S} = \\frac{1}{16} ((2~\\mathrm{keV})^2 + (2~\\mathrm{keV})^2) = \\frac{1}{16} (4+4)~\\mathrm{keV}^2 = \\frac{8}{16}~\\mathrm{keV}^2 = 0.5~\\mathrm{keV}^2 $$\nThe standard deviation is $\\sigma_{\\omega_S} = \\sqrt{0.5}~\\mathrm{keV} \\approx 0.7071~\\mathrm{keV}$. This is correctly reported as approximately $0.71~\\mathrm{keV}$.\nAll parts of this statement are correct.\nVerdict: **Correct**.\n\n**B. A forward one-sided estimator uses only $E_\\gamma(I+2\\to I)$ via $\\hbar\\omega(I)\\approx \\dfrac{E_\\gamma(I+2\\to I)}{2}$. At $I=18$ the estimate is $250~\\mathrm{keV}$; this one-sided estimator has smaller statistical variance than the symmetric estimator and is unbiased even across a sharp backbend.**\n\nThe formula $\\hbar\\omega_F(I) \\approx \\frac{E_\\gamma(I+2 \\to I)}{2}$ matches our derivation.\nUsing data for $I=18$:\n$$ \\hbar\\omega_F(18) \\approx \\frac{E_\\gamma(20 \\to 18)}{2} = \\frac{500~\\mathrm{keV}}{2} = 250~\\mathrm{keV} $$\nThis calculation is correct.\nNow, we assess the statistical variance. Let $Y = E_\\gamma(I+2 \\to I)$. The variance of $\\hbar\\omega_F = Y/2$ is:\n$$ \\sigma^2_{\\omega_F} = \\left(\\frac{1}{2}\\right)^2 \\sigma_Y^2 = \\frac{1}{4} (2~\\mathrm{keV})^2 = 1~\\mathrm{keV}^2 $$\nIn A, we found the variance of the symmetric estimator to be $\\sigma^2_{\\omega_S} = 0.5~\\mathrm{keV}^2$. Since $1~\\mathrm{keV}^2 > 0.5~\\mathrm{keV}^2$, the forward estimator has a *larger* statistical variance, not smaller. This part of the statement is false.\nFurthermore, the claim that the estimator is \"unbiased\" is incorrect. All finite-difference approximations for derivatives have a truncation error, which is a source of systematic bias. The truncation error for a one-sided estimator is of order $\\mathcal{O}(h)$, where $h$ is the step size. It is only unbiased if the function is perfectly linear, which is not the case for $E(I)$.\nVerdict: **Incorrect**.\n\n**C. For a smooth rotational band, the truncation error of the symmetric estimator scales as $\\mathcal{O}(h^2)$ in the spin step $h=2$, whereas one-sided estimators scale as $\\mathcal{O}(h)$. Near a backbend, the symmetric estimator at $I=18$ effectively averages pre- and post-crossing local frequencies, introducing additional bias relative to either side, even though its measurement-noise variance is lower than that of one-sided estimates.**\n\nThe statements on truncation error scaling are standard results from numerical analysis. A Taylor series expansion shows the error for the central difference $\\frac{f(x+h)-f(x-h)}{2h}$ is $\\mathcal{O}(h^2)$, while for the one-sided difference $\\frac{f(x+h)-f(x)}{h}$ it is $\\mathcal{O}(h)$. Here, the step size $h$ is $2$. This part is correct.\nThe backbending phenomenon implies a rapid change in the rotational properties. At $I=18$, the symmetric estimator uses $E_\\gamma(18 \\to 16) = 560~\\mathrm{keV}$ (pre-bend) and $E_\\gamma(20 \\to 18) = 500~\\mathrm{keV}$ (post-bend). The symmetric formula averages information from both sides, which can introduce a bias by mixing two different physical regimes. The one-sided estimators isolate these: $\\hbar\\omega_B(18) \\approx 280~\\mathrm{keV}$ and $\\hbar\\omega_F(18) \\approx 250~\\mathrm{keV}$. The symmetric estimate is $\\hbar\\omega_S(18) = 265~\\mathrm{keV}$, which is the mean of these two, thus \"averages\" them. This part is a correct physical and numerical interpretation.\nFinally, the claim that the symmetric estimator's measurement-noise variance is lower than that of one-sided estimators was proven in the analysis of option B. $\\sigma^2_{\\omega_S} = 0.5~\\mathrm{keV}^2$ is less than $\\sigma^2_{\\omega_F} = \\sigma^2_{\\omega_B} = 1~\\mathrm{keV}^2$.\nAll claims in this statement are correct.\nVerdict: **Correct**.\n\n**D. Using the data, the backward one-sided estimator at $I=18$ gives $\\hbar\\omega\\approx 280~\\mathrm{keV}$, and the symmetric estimator equals the arithmetic mean of the forward and backward one-sided estimates at the same spin.**\n\nThe backward estimator is $\\hbar\\omega_B(I) \\approx \\frac{E_\\gamma(I \\to I-2)}{2}$.\nAt $I=18$:\n$$ \\hbar\\omega_B(18) \\approx \\frac{E_\\gamma(18 \\to 16)}{2} = \\frac{560~\\mathrm{keV}}{2} = 280~\\mathrm{keV} $$\nThis calculation is correct.\nNow, we check the relationship between the estimators. The arithmetic mean of the forward and backward estimators is:\n$$ \\frac{\\hbar\\omega_F(I) + \\hbar\\omega_B(I)}{2} = \\frac{1}{2} \\left( \\frac{E_\\gamma(I+2 \\to I)}{2} + \\frac{E_\\gamma(I \\to I-2)}{2} \\right) = \\frac{E_\\gamma(I+2 \\to I) + E_\\gamma(I \\to I-2)}{4} $$\nThis is precisely the formula for the symmetric estimator, $\\hbar\\omega_S(I)$. This property is a mathematical identity.\nBoth parts of the statement are true.\nVerdict: **Correct**.\n\n**E. The correct symmetric formula is $\\hbar\\omega(I)\\approx \\dfrac{E_\\gamma(I\\to I-2)+E_\\gamma(I+2\\to I)}{2}$, which with the data yields $\\hbar\\omega(18)\\approx 530~\\mathrm{keV}$, and it has lower truncation error than the $\\dfrac{1}{4}$ version.**\n\nThe proposed formula is $\\hbar\\omega(I) \\approx \\frac{E_\\gamma(I \\to I-2) + E_\\gamma(I+2 \\to I)}{2}$.\nAs derived at the beginning, the correct symmetric estimator is $\\hbar\\omega_S(I) \\approx \\frac{E_\\gamma(I+2 \\to I) + E_\\gamma(I \\to I-2)}{4}$. The proposed formula is off by a factor of $2$. It is an approximation for $2\\hbar\\omega(I)$, not $\\hbar\\omega(I)$. The formula is incorrect.\nThe calculation $\\hbar\\omega(18) \\approx \\frac{560 + 500}{2} = 530~\\mathrm{keV}$ is arithmetically consistent with the incorrect formula.\nThe claim that this formula has a lower truncation error is false. The formula with the denominator $4$ is the standard second-order-accurate central-difference approximation. The formula with denominator $2$ does not approximate $\\hbar\\omega(I)$ at all, so it cannot be a \"better\" approximation. Its error in approximating $\\hbar\\omega(I)$ is approximately $\\hbar\\omega(I)$ itself, which is far larger than the truncation error of the correct formula.\nVerdict: **Incorrect**.\n\nIn summary, options A, C, and D are correct.", "answer": "$$\\boxed{ACD}$$", "id": "3543329"}, {"introduction": "Once the relationship between spin $I$ and frequency $\\omega$ is established, the next step is to quantify the deviation from smooth rotational behavior by subtracting a reference. In this computational practice [@problem_id:3543269], you will implement the full workflow for analyzing a rotational band, from fitting a Harris expansion reference to calculating the incremental alignment $i_x$. This process allows you to isolate and visualize the sharp gain in angular momentum that is the hallmark of the backbending phenomenon.", "problem": "A rotational band in an even-even nucleus can be studied within the cranking framework, where the rotational frequency is related to the derivative of the excitation energy with respect to the spin. The incremental alignment as a function of rotational frequency is a standard diagnostic of the backbending phenomenon. In this problem, you will implement a computational procedure to estimate a reference moment of inertia using the Harris parameterization and to compute the incremental alignment as a function of rotational frequency for synthetic bands that exhibit controlled backbending behavior. You must produce a runnable program that solves the following.\n\nYou are given that for discrete levels labeled by spin $I$ in units of reduced Planck constant ($\\hbar$), the rotational frequency in megaelectronvolts per $\\hbar$ (MeV$/\\hbar$) is approximated by a centered finite difference from the measured excitation energies in megaelectronvolts (MeV). If the spin step is $\\Delta I=2$ (even-even nucleus), then for an interior level at spin $I$,\n$$\n\\omega(I) \\approx \\frac{E(I+\\Delta I)-E(I-\\Delta I)}{2\\,\\Delta I},\n$$\nwith all energies $E(\\cdot)$ in MeV, yielding $\\omega$ in MeV$/\\hbar$ when $I$ is counted in units of $\\hbar$ and $\\hbar$ is set to unity. The low-frequency reference spin as a function of the rotational frequency is modeled by the Harris expansion\n$$\nI_{\\mathrm{ref}}(\\omega) = J_0\\,\\omega + J_1\\,\\omega^3,\n$$\nwhere $J_0$ has units $\\hbar^2/\\mathrm{MeV}$ and $J_1$ has units $\\hbar^4/\\mathrm{MeV}^3$. The incremental alignment is defined as\n$$\ni_x(\\omega) = I(\\omega) - I_{\\mathrm{ref}}(\\omega),\n$$\nand is reported in units of $\\hbar$.\n\nYour task is to:\n- Generate synthetic rotational band energies $E(I)$ for even spins $I \\in \\{0,2,4,\\dots,I_{\\max}\\}$ using a controlled backbending model governed by a set of parameters. For each parameter set, define a smooth spin-frequency relation by solving for $\\omega$ from the implicit equation\n$$\nI = J_0^{(\\mathrm{true})}\\,\\omega + J_1^{(\\mathrm{true})}\\,\\omega^3 + \\frac{i_{\\mathrm{align}}}{1+\\exp\\!\\left(-\\frac{\\omega-\\omega_c}{\\Delta\\omega}\\right)},\n$$\nwhere $J_0^{(\\mathrm{true})}$ and $J_1^{(\\mathrm{true})}$ define the low-frequency reference, and the last term provides an $S$-shaped alignment gain of magnitude $i_{\\mathrm{align}}$ centered at $\\omega_c$ with width $\\Delta\\omega$. Then construct $E(I)$ by numerical quadrature in spin using the trapezoidal rule with spin step $\\Delta I=2$:\n$$\nE(0)=0,\\quad E(I_k)=E(I_{k-1}) + \\frac{\\omega(I_k)+\\omega(I_{k-1})}{2}\\,\\Delta I,\n$$\nand add a deterministic noise term $n(I)=A_{\\mathrm{noise}}\\sin\\!\\left(\\pi I/6\\right)$ in MeV to each $E(I)$, using the angle in radians. Energies must be reported in MeV.\n- From the synthetic $E(I)$ values, compute the discrete rotational frequencies $\\omega(I)$ at interior spins using the centered finite difference formula for $\\Delta I=2$,\n$$\n\\omega(I)=\\frac{E(I+2)-E(I-2)}{4}.\n$$\n- Using only the low-frequency subset defined by $\\omega(I)\\le \\omega_{\\max}^{(\\mathrm{fit})}$, estimate $J_0$ and $J_1$ by linear least squares fit of $I$ onto the regressors $\\omega$ and $\\omega^3$:\n$$\nI \\approx J_0\\,\\omega + J_1\\,\\omega^3\\quad\\text{for}\\quad \\omega\\le \\omega_{\\max}^{(\\mathrm{fit})}.\n$$\n- Compute the incremental alignment $i_x(\\omega)$ at all available interior frequencies using the fitted $\\hat J_0$ and $\\hat J_1$. Then, by linear interpolation with clamping to the available frequency range, evaluate $i_x(\\omega)$ at three specified evaluation frequencies $\\omega_{\\mathrm{eval}}\\in\\{0.20,0.30,0.40\\}$ MeV$/\\hbar$. If an evaluation frequency lies below the minimum or above the maximum available discrete $\\omega$, clamp it to the nearest available $\\omega$ before interpolation. Report $i_x(\\omega_{\\mathrm{eval}})$ in units of $\\hbar$.\n- Round all reported floating-point outputs to three decimal places.\n\nPhysical units: Spin $I$ is in units of $\\hbar$. Energy $E$ is in MeV. Rotational frequency $\\omega$ is in MeV$/\\hbar$. Parameters $J_0$ and $J_1$ are in $\\hbar^2/\\mathrm{MeV}$ and $\\hbar^4/\\mathrm{MeV}^3$, respectively. Incremental alignment $i_x$ is in units of $\\hbar$.\n\nTest suite and required outputs:\n- You must implement your program to handle the following three parameter sets; each set defines one synthetic band and one fit and evaluation task. For each set, your program must output a list containing five floats: the fitted $\\hat J_0$, the fitted $\\hat J_1$, and the three values $i_x(0.20)$, $i_x(0.30)$, $i_x(0.40)$, in that order. The program must aggregate the three lists into a single outer list and print it as the only output line.\n\n- Parameter sets:\n    1. Set A (happy path):\n        - $J_0^{(\\mathrm{true})}=30.0$, $J_1^{(\\mathrm{true})}=80.0$, $i_{\\mathrm{align}}=8.0$, $\\omega_c=0.32$, $\\Delta\\omega=0.03$, $I_{\\max}=28$, $\\omega_{\\max}^{(\\mathrm{fit})}=0.28$, $A_{\\mathrm{noise}}=0.0$.\n    2. Set B (noisy, fewer levels):\n        - $J_0^{(\\mathrm{true})}=28.0$, $J_1^{(\\mathrm{true})}=60.0$, $i_{\\mathrm{align}}=7.0$, $\\omega_c=0.30$, $\\Delta\\omega=0.02$, $I_{\\max}=20$, $\\omega_{\\max}^{(\\mathrm{fit})}=0.26$, $A_{\\mathrm{noise}}=0.001$.\n    3. Set C (weaker, delayed backbend):\n        - $J_0^{(\\mathrm{true})}=32.0$, $J_1^{(\\mathrm{true})}=70.0$, $i_{\\mathrm{align}}=4.0$, $\\omega_c=0.42$, $\\Delta\\omega=0.04$, $I_{\\max}=28$, $\\omega_{\\max}^{(\\mathrm{fit})}=0.30$, $A_{\\mathrm{noise}}=0.0$.\n\nAlgorithmic constraints and numerical details:\n- For solving the implicit equation for $\\omega$ at a given $I$, use a robust root bracketing method on $\\omega\\in[0,\\omega_{\\max}]$ with a sufficiently large $\\omega_{\\max}$ to ensure that a solution is bracketed for all $I$ in the set; automatically expand the bracket if needed. Treat $I=0$ as $\\omega=0$.\n- Use the trapezoidal rule in $I$ to construct $E(I)$ from the solved $\\omega(I)$.\n- For the fit, if fewer than two points satisfy $\\omega\\le\\omega_{\\max}^{(\\mathrm{fit})}$, expand the fit set by including the smallest-$\\omega$ points until at least two points are available.\n- For interpolation of $i_x(\\omega)$ at the evaluation frequencies, use linear interpolation in $\\omega$ with clamping at the boundaries.\n\nFinal output format:\n- Your program should produce a single line of output containing a single list of three inner lists, where each inner list corresponds to one parameter set in the order A, B, C, and contains five floating-point numbers rounded to three decimals: $[\\hat J_0,\\hat J_1,i_x(0.20),i_x(0.30),i_x(0.40)]$. The printed line must contain only this list, with no additional text. The numbers must be expressed in the units specified above.", "solution": "The user has provided a computational problem in nuclear physics concerning the analysis of the backbending phenomenon in rotational bands of even-even nuclei. The problem is scientifically grounded, well-posed, and provides a complete set of instructions for a multi-step numerical procedure. It is therefore deemed valid. The solution will be constructed following the sequence of tasks outlined.\n\nThe core of the problem is to simulate and then analyze a rotational band. This involves four main stages:\n1.  Generation of synthetic rotational band energies, $E(I)$, based on a phenomenological model for the spin $I$ as a function of rotational frequency $\\omega$.\n2.  Calculation of discrete rotational frequencies $\\omega(I)$ from the synthetic energies using a finite-difference approximation, mimicking the analysis of experimental data.\n3.  Estimation of the Harris parameters, $J_0$ and $J_1$, which define a smooth reference moment of inertia, by performing a linear least-squares fit to the low-frequency portion of the band.\n4.  Calculation and evaluation of the incremental alignment, $i_x$, which quantifies the deviation of the band's spin from the smooth reference.\n\nEach step will be implemented algorithmically as specified.\n\n**1. Synthetic Band Generation**\n\nThe foundation of the synthetic data is the relationship between spin $I$ and rotational frequency $\\omega$. The model provided is:\n$$\nI(\\omega) = J_0^{(\\mathrm{true})}\\,\\omega + J_1^{(\\mathrm{true})}\\,\\omega^3 + \\frac{i_{\\mathrm{align}}}{1+\\exp\\!\\left(-\\frac{\\omega-\\omega_c}{\\Delta\\omega}\\right)}\n$$\nThis equation defines the spin for a given frequency. The first two terms, $J_0^{(\\mathrm{true})}\\,\\omega + J_1^{(\\mathrm{true})}\\,\\omega^3$, represent the Harris parameterization for a smooth, non-interacting rotor. The third term is a logistic function that introduces a rapid, localized increase in spin, known as an alignment gain, of magnitude $i_{\\mathrm{align}}$ around a critical frequency $\\omega_c$. This term simulates the alignment of a pair of high-$j$ nucleons with the rotational axis, which is the microscopic cause of backbending.\n\nTo generate the band, we require the frequency $\\omega$ for a given set of discrete even integer spins $I \\in \\{0, 2, 4, \\dots, I_{\\max}\\}$. This necessitates solving the implicit equation $I = I(\\omega)$ for $\\omega$ at each spin $I$. For $I=0$, the solution is trivially $\\omega=0$. For $I0$, the equation $I(\\omega) - I = 0$ must be solved numerically. Since the function $I(\\omega)$ is monotonically increasing for positive parameters, a unique root $\\omega  0$ exists for any $I  0$. A robust root-finding algorithm, such as the Brent-Dekker method, is suitable for this task. We will define the function $f(\\omega, I) = I(\\omega) - I$ and find its root within a search interval, for instance, $[0, 1.0]$ MeV$/\\hbar$, expanding the interval if necessary.\n\nOnce the smooth frequencies $\\omega(I)$ are determined for each spin $I$, the corresponding excitation energies $E(I)$ are constructed via numerical quadrature of the fundamental relation $dE = \\omega\\,dI$. Using the trapezoidal rule for a spin step $\\Delta I = 2$, the energy of level $I_k$ is recursively calculated from the preceding level $I_{k-1}$:\n$$\nE(I_k) = E(I_{k-1}) + \\int_{I_{k-1}}^{I_k} \\omega(I') dI' \\approx E(I_{k-1}) + \\frac{\\omega(I_k) + \\omega(I_{k-1})}{2} \\Delta I\n$$\nWith $I_k = 2k$, $I_{k-1}=2(k-1)$, and $\\Delta I = 2$, this simplifies to $E(2k) = E(2(k-1)) + \\omega(2k) + \\omega(2(k-1))$. The band starts with $E(0)=0$.\n\nFinally, a deterministic noise term, $n(I) = A_{\\mathrm{noise}}\\sin(\\pi I/6)$, is added to each calculated energy $E(I)$ to simulate experimental uncertainties or small non-rotational effects.\n\n**2. Rotational Frequency Calculation**\n\nFrom the set of discrete synthetic energies $\\{E(I)\\}$, we compute the rotational frequencies using the standard centered finite-difference approximation for the derivative $\\omega = dE/dI$:\n$$\n\\omega(I) \\approx \\frac{E(I+\\Delta I/2) - E(I-\\Delta I/2)}{\\Delta I}\n$$\nFor an even-even nucleus with spin step $\\Delta I=2$, the frequencies are typically calculated at spins intermediate to the levels. However, the problem specifies a symmetric finite difference centered on a level, which requires energies from neighboring levels:\n$$\n\\omega(I) = \\frac{E(I+2) - E(I-2)}{4}\n$$\nThis formula is applied to all interior spins of the band, i.e., for $I \\in \\{2, 4, \\dots, I_{\\max}-2\\}$, where the necessary energy values $E(I\\pm2)$ are available.\n\n**3. Harris Parameter Estimation**\n\nThe next step is to fit the Harris parameters $J_0$ and $J_1$ to establish a reference for the band's behavior. The model is $I \\approx J_0 \\omega + J_1 \\omega^3$. This is a linear regression problem where the dependent variable is $I$ and the independent variables (regressors) are $\\omega$ and $\\omega^3$. The coefficients to be determined are $\\hat J_0$ and $\\hat J_1$.\n\nThe fit is restricted to the low-frequency data points where $\\omega(I) \\le \\omega_{\\max}^{(\\mathrm{fit})}$, as the Harris parameterization is intended to describe the band before the onset of alignment. If this condition yields fewer than two data points, the set is expanded by including the points with the smallest frequencies until at least two points are available to ensure the problem is well-defined.\n\nThe fitting is performed using the method of ordinary least squares. We solve the matrix equation $A\\mathbf{x} = \\mathbf{b}$ for the parameter vector $\\mathbf{x} = [\\hat J_0, \\hat J_1]^T$, where $\\mathbf{b}$ is the vector of spin values $I$ and $A$ is the design matrix whose columns are the corresponding $\\omega$ and $\\omega^3$ values. The least-squares solution is given by $\\hat{\\mathbf{x}} = (A^T A)^{-1} A^T \\mathbf{b}$.\n\n**4. Incremental Alignment**\n\nThe incremental alignment, $i_x$, measures the spin gained by the nucleus relative to the smooth Harris reference at a given frequency. It is defined as:\n$$\ni_x(\\omega) = I(\\omega) - I_{\\mathrm{ref}}(\\omega) = I(\\omega) - (\\hat J_0 \\omega + \\hat J_1 \\omega^3)\n$$\nUsing the fitted parameters $\\hat J_0$ and $\\hat J_1$, we calculate a discrete set of alignment values $\\{i_x(I)\\}$ for all interior spins using their corresponding discrete frequencies $\\{\\omega(I)\\}$.\n\nThe final task is to determine the alignment at three specific evaluation frequencies, $\\omega_{\\mathrm{eval}} \\in \\{0.20, 0.30, 0.40\\}$ MeV$/\\hbar$. This is achieved by performing linear interpolation on the discrete data pairs $(\\omega(I), i_x(I))$. The problem specifies clamping: if an evaluation frequency is outside the range of the calculated discrete frequencies $[\\min(\\omega), \\max(\\omega)]$, the alignment value of the nearest boundary point is used. Standard interpolation functions, such as `numpy.interp`, naturally handle this behavior.\n\nThe resulting five values for each parameter set—the fitted $\\hat J_0$ and $\\hat J_1$, and the three interpolated alignments $i_x(\\omega_{\\mathrm{eval}})$—are rounded to three decimal places and presented as the final output. The entire procedure is encapsulated in a program that iterates through the provided test cases.", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Set A (happy path)\n        {\n            \"J0_true\": 30.0, \"J1_true\": 80.0, \"ialign\": 8.0, \n            \"wc\": 0.32, \"dw\": 0.03, \"I_max\": 28, \n            \"omega_max_fit\": 0.28, \"A_noise\": 0.0\n        },\n        # Set B (noisy, fewer levels)\n        {\n            \"J0_true\": 28.0, \"J1_true\": 60.0, \"ialign\": 7.0, \n            \"wc\": 0.30, \"dw\": 0.02, \"I_max\": 20, \n            \"omega_max_fit\": 0.26, \"A_noise\": 0.001\n        },\n        # Set C (weaker, delayed backbend)\n        {\n            \"J0_true\": 32.0, \"J1_true\": 70.0, \"ialign\": 4.0, \n            \"wc\": 0.42, \"dw\": 0.04, \"I_max\": 28, \n            \"omega_max_fit\": 0.30, \"A_noise\": 0.0\n        }\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result = process_case(params)\n        all_results.append(result)\n\n    # Format the final output string exactly as required.\n    # e.g., [[val1, val2, ...], [val1, val2, ...]]\n    output_str = \"[\" + \",\".join([\n        \"[{:.3f},{:.3f},{:.3f},{:.3f},{:.3f}]\".format(*res) \n        for res in all_results\n    ]) + \"]\"\n\n    print(output_str)\n\ndef _i_of_omega_model(omega, J0, J1, ialign, wc, dw):\n    \"\"\"The implicit model for I as a function of omega.\"\"\"\n    if omega == 0.0:\n        return 0.0\n    harris_term = J0 * omega + J1 * omega**3\n    alignment_term = ialign / (1.0 + np.exp(-(omega - wc) / dw))\n    return harris_term + alignment_term\n\ndef _find_omega_for_spin(I, params):\n    \"\"\"Solves the implicit equation I = I(omega) for omega.\"\"\"\n    if I == 0:\n        return 0.0\n\n    j0t, j1t, ia, wc, dw = params[\"J0_true\"], params[\"J1_true\"], params[\"ialign\"], params[\"wc\"], params[\"dw\"]\n\n    def root_func(omega):\n        return _i_of_omega_model(omega, j0t, j1t, ia, wc, dw) - I\n\n    # Robust root finding with expanding bracket\n    a, b = 1e-9, 1.0  # Start with a small interval [0, 1]\n    fa, fb = root_func(a), root_func(b)\n    \n    while np.sign(fa) == np.sign(fb):\n        b *= 2.0\n        if b > 100:  # Safety break\n            raise RuntimeError(f\"Could not bracket root for I={I}\")\n        fb = root_func(b)\n        \n    return brentq(root_func, a, b)\n\n\ndef process_case(params):\n    \"\"\"\n    Executes the full analysis workflow for a single parameter set.\n    \"\"\"\n    I_max = params[\"I_max\"]\n    spins = np.arange(0, I_max + 1, 2, dtype=float)\n\n    # 1. Generate synthetic band data\n    # 1a. Solve for smooth omega(I) for each spin\n    omega_smooth = np.array([_find_omega_for_spin(I, params) for I in spins])\n\n    # 1b. Integrate to get energies E(I) using trapezoidal rule\n    n_levels = len(spins)\n    E_synth = np.zeros(n_levels)\n    # E(I_k) = E(I_{k-1}) + (omega(I_k)+omega(I_{k-1}))/2 * deltaI, with deltaI=2\n    # E(2k) = E(2(k-1)) + omega_smooth[k] + omega_smooth[k-1]\n    for k in range(1, n_levels):\n        E_synth[k] = E_synth[k-1] + omega_smooth[k] + omega_smooth[k-1]\n\n    # 1c. Add deterministic noise\n    A_noise = params[\"A_noise\"]\n    if A_noise != 0.0:\n        noise = A_noise * np.sin(math.pi * spins / 6.0)\n        E_synth += noise\n\n    # 2. Compute discrete frequencies omega(I) from energies\n    # Interior spins are 2, 4, ..., I_max-2\n    I_interior = spins[1:-1]\n    \n    # E(I) is at index I/2. So E(I-2) -> index k-1, E(I+2) -> k+1 for spin I=2k\n    # omega(I=2k) = (E_synth[k+1] - E_synth[k-1]) / 4\n    omega_discrete = (E_synth[2:] - E_synth[:-2]) / 4.0\n\n    # 3. Fit Harris parameters J0 and J1\n    # 3a. Select low-frequency data for fitting\n    omega_max_fit = params[\"omega_max_fit\"]\n    fit_mask = omega_discrete = omega_max_fit\n    \n    # 3b. Ensure at least 2 points for the fit\n    if np.sum(fit_mask)  2:\n        # Sort by omega and take the first two points\n        sorted_indices = np.argsort(omega_discrete)\n        fit_indices = sorted_indices[:2]\n        I_fit = I_interior[fit_indices]\n        omega_fit = omega_discrete[fit_indices]\n    else:\n        I_fit = I_interior[fit_mask]\n        omega_fit = omega_discrete[fit_mask]\n\n    # 3c. Perform linear least squares fit: I = J0*w + J1*w^3\n    A = np.vstack([omega_fit, omega_fit**3]).T\n    b = I_fit\n    J_hat, _, _, _ = np.linalg.lstsq(A, b, rcond=None)\n    J0_hat, J1_hat = J_hat[0], J_hat[1]\n\n    # 4. Compute and interpolate incremental alignment i_x\n    # 4a. Calculate i_x for all interior points\n    I_ref = J0_hat * omega_discrete + J1_hat * omega_discrete**3\n    ix_discrete = I_interior - I_ref\n\n    # 4b. Interpolate at evaluation frequencies with clamping\n    omega_eval = np.array([0.20, 0.30, 0.40])\n    # np.interp handles clamping by default\n    ix_interpolated = np.interp(omega_eval, omega_discrete, ix_discrete)\n    \n    # 5. Collate and return results (will be rounded later)\n    return [J0_hat, J1_hat, ix_interpolated[0], ix_interpolated[1], ix_interpolated[2]]\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "3543269"}, {"introduction": "Phenomenological models describe backbending, but a deeper understanding requires a microscopic theory that explains it as a competition between pairing correlations and rotational alignment. This advanced exercise [@problem_id:3543335] guides you in building a self-consistent cranked Bardeen-Cooper-Schrieffer (BCS) solver, a cornerstone of nuclear structure theory. By numerically investigating how pairing strength influences the critical frequency for alignment, you will gain firsthand experience with the core microscopic mechanism driving this rotational phenomenon.", "problem": "You are to implement a self-consistent cranked Bardeen–Cooper–Schrieffer (BCS) solver to quantify how the pairing strength controls the backbending frequency in a finite system of equally spaced single-particle levels. The calculation must be performed in a simplified but scientifically consistent cranked mean-field model, and the objective is to extract, for each pairing strength, the backbending frequency from the curvature of the angular momentum as a function of the rotational frequency. The final output must be a single line containing a list of floating-point numbers.\n\nThe fundamental base for this task is the cranking model and the Bardeen–Cooper–Schrieffer theory. Consider a single-particle Hamiltonian subject to cranking,\n$$\n\\hat{H}'(\\omega) = \\hat{H} - \\omega \\hat{J}_x,\n$$\nwhere $\\omega$ is the rotational frequency (in $\\mathrm{MeV}/\\hbar$), and $\\hat{J}_x$ is the angular momentum operator along the cranking axis. The cranked Bardeen–Cooper–Schrieffer quasiparticle spectrum is computed from a set of single-particle levels with energies $\\{\\varepsilon_k\\}$ shifted by the Coriolis term,\n$$\ne_k(\\omega) = \\varepsilon_k - \\omega j_{x,k},\n$$\nwhere $j_{x,k}$ is the single-particle expectation of $\\hat{J}_x$ (in units of $\\hbar$) for level $k$. For an even system with a constant pairing interaction of strength $G$ (in $\\mathrm{MeV}$), the cranked Bardeen–Cooper–Schrieffer gap equation and number equation at each $\\omega$ are\n$$\n\\frac{1}{G} = \\sum_{k=1}^{M} \\frac{1}{2 E_k}, \\quad E_k = \\sqrt{(e_k(\\omega)-\\lambda)^2 + \\Delta^2},\n$$\n$$\nN = 2 \\sum_{k=1}^{M} v_k^2, \\quad v_k^2 = \\frac{1}{2}\\left(1 - \\frac{e_k(\\omega) - \\lambda}{E_k}\\right),\n$$\nwhere $M$ is the number of doubly degenerate levels, $\\Delta$ is the pairing gap, $\\lambda$ is the chemical potential, and $N$ is the total particle number (even). When the pairing collapses ($\\Delta = 0$), the normal phase with step-function occupations must be used to satisfy the number constraint.\n\nDefine the cranked Bardeen–Cooper–Schrieffer expectation value of the Routhian as\n$$\nE_{\\mathrm{R}}(\\omega) = 2 \\sum_{k=1}^M e_k(\\omega)\\, v_k^2 - \\frac{\\Delta^2}{G}.\n$$\nTo enforce the relation $J(\\omega) = \\partial E(\\omega)/\\partial \\omega$ as the working definition of the angular momentum, define\n$$\nE(\\omega) \\equiv - E_{\\mathrm{R}}(\\omega),\n$$\nso that differentiating with respect to $\\omega$ yields the angular momentum in the cranked stationary solution, consistent with the Hellmann–Feynman principle. You must compute $J(\\omega)$ numerically from $E(\\omega)$ using finite differences on a uniform grid in $\\omega$.\n\nThe backbending frequency is to be defined numerically as the value of $\\omega$ at which the discrete derivative $dJ/d\\omega$ attains a pronounced local maximum, corresponding to the sharpest increase in aligned angular momentum. To robustly detect this, you must:\n- Compute $E(\\omega)$ on a uniform grid $\\omega \\in [0, \\omega_{\\max}]$ with spacing $\\delta \\omega$, solve the cranked Bardeen–Cooper–Schrieffer equations at each $\\omega$ for $(\\Delta(\\omega), \\lambda(\\omega))$, and evaluate $J(\\omega)$ via a centered finite difference approximation of $\\partial E/\\partial \\omega$.\n- Compute the discrete derivative $dJ/d\\omega$ and smooth it by a short moving average to reduce numerical noise.\n- Identify the index of the global maximum of the smoothed $dJ/d\\omega$ in the interior of the grid and declare the corresponding $\\omega$ to be the backbending frequency if and only if the peak prominence exceeds a minimal contrast threshold determined from the overall spread of $dJ/d\\omega$. If no pronounced maximum is present, return a sentinel value.\n\nUse the following scientifically plausible and self-consistent model parameters:\n- Number of (pair-degenerate) levels: $M = 12$.\n- Single-particle energies: $\\varepsilon_k$ equally spaced from $-2.75\\,\\mathrm{MeV}$ to $+2.75\\,\\mathrm{MeV}$.\n- Single-particle cranking matrix elements: $j_{x,k} = 0.5 + 0.05\\,k$ for $k = 0, 1, \\ldots, 11$, with two intruder high-$j$ levels near the Fermi surface set to $j_{x,5} = 6.0$ and $j_{x,6} = 6.0$ to model an alignment-driving orbital.\n- Total particle number: $N = 12$.\n- Rotational frequency grid: $\\omega \\in [0, 0.5]\\,\\mathrm{MeV}/\\hbar$ with uniform spacing $\\delta\\omega = 0.005\\,\\mathrm{MeV}/\\hbar$.\n- In the normal phase when $\\Delta = 0$, enforce the number equation by filling levels with $e_k(\\omega)$ up to $N/2$ pairs and choosing $\\lambda$ between the last filled and first empty levels; if degeneracy at the Fermi surface occurs, allow a fractional occupation of the degenerate level(s) to exactly satisfy $N$.\n\nThe program must implement the above without any external input and must produce the backbending frequency for each pairing strength in a fixed test suite, formatted as a single list. If no pronounced maximum of $dJ/d\\omega$ is detected within the grid (i.e., the peak prominence is not statistically significant with respect to the spread of $dJ/d\\omega$), return the sentinel value $-1.0$ for that pairing strength.\n\nTest suite:\n- Pairing strength values $G$ (in $\\mathrm{MeV}$): $[\\,0.15,\\,0.30,\\,0.50,\\,0.80\\,]$.\n- For each $G$ in the list, compute the backbending frequency as described above.\n- Report each result as a float rounded to three decimals, in units of $\\mathrm{MeV}/\\hbar$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example: $[0.125,0.200,-1.000,0.310]$.\n- Each entry corresponds to the backbending frequency for the corresponding $G$ in the test suite, in $\\mathrm{MeV}/\\hbar$, rounded to three decimals, with the sentinel value $-1.000$ used when no pronounced maximum is detected.", "solution": "The provided problem is a well-posed and scientifically grounded task in computational nuclear physics. All parameters and procedures are specified, allowing for a deterministic and verifiable solution. The underlying physics, based on the cranked Bardeen–Cooper–Schrieffer (BCS) model, is a standard theoretical framework for studying nuclear rotational properties. The problem is therefore deemed **valid**.\n\nThe solution involves implementing a self-consistent cranked BCS solver to determine the pairing gap $\\Delta$ and chemical potential $\\lambda$ as a function of rotational frequency $\\omega$. This data is then used to compute the angular momentum $J(\\omega)$ and its derivative $dJ/d\\omega$ to identify the backbending frequency. The core principle is the Hellmann–Feynman theorem, which relates the derivative of the energy to the expectation value of the corresponding operator.\n\n**Step 1: Model Definition and Parameterization**\nThe system is defined by a set of $M=12$ doubly degenerate single-particle levels with energies $\\{\\varepsilon_k\\}$ and angular momentum projections $\\{j_{x,k}\\}$. The cranked single-particle energies are given by $e_k(\\omega) = \\varepsilon_k - \\omega j_{x,k}$. The parameters are fixed as specified: $\\varepsilon_k$ are linearly spaced from $-2.75\\,\\mathrm{MeV}$ to $+2.75\\,\\mathrm{MeV}$; $j_{x,k} = 0.5 + 0.05\\,k$ for $k \\in \\{0, \\ldots, 11\\}$, with intruder states at $k=5, 6$ having $j_{x,5}=6.0$ and $j_{x,6}=6.0$. The system contains $N=12$ particles. The calculation is performed for a list of pairing strengths $G \\in [\\,0.15,\\,0.30,\\,0.50,\\,0.80\\,]\\,\\mathrm{MeV}$ on a uniform grid of rotational frequencies $\\omega \\in [0, 0.5]\\,\\mathrm{MeV}/\\hbar$ with step $\\delta\\omega = 0.005\\,\\mathrm{MeV}/\\hbar$.\n\n**Step 2: Self-Consistent Cranked BCS Solver**\nFor each value of the pairing strength $G$ and at each grid point $\\omega$, we must solve a system of two coupled nonlinear equations for the pairing gap squared, $\\Delta^2$, and the chemical potential, $\\lambda$:\n$$\n\\frac{2}{G} = \\sum_{k=1}^{M} \\frac{1}{\\sqrt{(e_k(\\omega)-\\lambda)^2 + \\Delta^2}} \\quad (\\text{Gap Equation})\n$$\n$$\nN = \\sum_{k=1}^{M} \\left(1 - \\frac{e_k(\\omega) - \\lambda}{\\sqrt{(e_k(\\omega)-\\lambda)^2 + \\Delta^2}}\\right) \\quad (\\text{Number Equation})\n$$\nThese equations are solved numerically. To ensure robustness and efficiency, we employ a standard root-finding algorithm, specifically `scipy.optimize.root`. We solve for the variables $(\\Delta^2, \\lambda)$, which naturally enforces the physical constraint $\\Delta \\ge 0$. The solution from the previous frequency step, $(\\Delta^2(\\omega-\\delta\\omega), \\lambda(\\omega-\\delta\\omega))$, serves as an excellent initial guess for the current step, ensuring smooth convergence across the frequency grid.\n\nIf the solver fails to find a solution with $\\Delta^2  0$ (within a small numerical tolerance), it signifies a transition to the normal (unpaired) phase. In this case, we set $\\Delta=0$ and determine $\\lambda$ by enforcing number conservation for a non-interacting Fermi gas: the $N/2=6$ lowest cranked single-particle levels $e_k(\\omega)$ are filled. The chemical potential $\\lambda$ is set to the midpoint of the highest occupied and lowest unoccupied levels.\n\n**Step 3: Calculation of Angular Momentum**\nWith $(\\Delta(\\omega), \\lambda(\\omega))$ determined, we compute the cranked BCS Routhian:\n$$\nE_{\\mathrm{R}}(\\omega) = 2 \\sum_{k=1}^M e_k(\\omega)\\, v_k^2 - \\frac{\\Delta^2(\\omega)}{G}\n$$\nwhere $v_k^2 = \\frac{1}{2}\\left(1 - \\frac{e_k(\\omega) - \\lambda}{E_k}\\right)$ are the occupation probabilities and $E_k = \\sqrt{(e_k(\\omega)-\\lambda)^2 + \\Delta^2}$ are the quasiparticle energies. The energy $E(\\omega)$ is defined as $E(\\omega) = -E_{\\mathrm{R}}(\\omega)$, which, by the Hellmann–Feynman theorem, ensures that the total angular momentum is given by $J_x(\\omega) = \\frac{\\partial E(\\omega)}{\\partial \\omega}$. We compute $J_x(\\omega)$ numerically using a second-order centered finite difference approximation on the computed $E(\\omega)$ grid:\n$$\nJ_x(\\omega_i) \\approx \\frac{E(\\omega_{i+1}) - E(\\omega_{i-1})}{2\\delta\\omega}\n$$\n\n**Step 4: Identification of Backbending Frequency**\nBackbending is characterized by a rapid increase in angular momentum $J_x$ with frequency $\\omega$, which manifests as a sharp peak in the derivative $dJ_x/d\\omega$. This derivative is also computed via a centered finite difference. To mitigate numerical noise inherent in differentiation, the resulting $dJ_x/d\\omega$ signal is smoothed using a $3$-point moving average.\n\nThe backbending frequency $\\omega_{\\text{bb}}$ is identified following a precise algorithmic procedure:\n1.  The index of the global maximum of the smoothed $dJ_x/d\\omega$ signal is located.\n2.  A check is performed to ensure this maximum occurs in the interior of the frequency grid, not at an endpoint, which would not represent a physical turning point within the model's dynamic range.\n3.  The prominence of this maximum is calculated using `scipy.signal.peak_prominences`. A peak's prominence measures how much it stands out from the surrounding signal.\n4.  This prominence is compared against a dynamic threshold defined as the standard deviation of the smoothed $dJ_x/d\\omega$ signal. This ensures that only statistically significant peaks are considered.\n5.  If the global maximum is an interior peak and its prominence exceeds the threshold, the corresponding frequency $\\omega$ is identified as the backbending frequency $\\omega_{\\text{bb}}$.\n6.  If no such prominent peak is found for a given pairing strength $G$, a sentinel value of $-1.0$ is assigned.\n\nThis entire procedure is repeated for each value of $G$ in the test suite, yielding a list of backbending frequencies that quantify the effect of pairing on rotational alignment. The final results are formatted as requested.", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import root\nfrom scipy.signal import find_peaks, peak_prominences\n\ndef solve():\n    \"\"\"\n    Main function to implement the self-consistent cranked BCS solver and find the backbending frequency.\n    \"\"\"\n\n    def get_bb_frequency(G, M, N, eps, jx, omega_grid, delta_omega):\n        \"\"\"\n        Calculates the backbending frequency for a single pairing strength G.\n        \"\"\"\n        routhians = []\n        # Initial guess for the solver at omega=0.\n        # lam=0 due to symmetry, delta ~ G.\n        # We solve for delta^2, so initial guess is G^2.\n        d2_prev, lam_prev = G**2, 0.0\n\n        for omega in omega_grid:\n            ek = eps - omega * jx\n\n            def bcs_equations(variables, G_val, ek_vals, N_val):\n                d2, lam = variables\n                if d2  0:\n                    d2 = 1e-12 # Enforce delta^2 >= 0\n                \n                ek_prime = ek_vals - lam\n                Ek = np.sqrt(ek_prime**2 + d2)\n                # Add a small value to denominator to prevent division by zero\n                Ek[Ek  1e-12] = 1e-12\n\n                # Gap Equation: sum(1/Ek) - 2/G = 0\n                eq1 = np.sum(1.0 / Ek) - 2.0 / G_val\n                # Number Equation: sum(1 - (ek-lam)/Ek) - N = 0\n                eq2 = np.sum(1.0 - ek_prime / Ek) - N_val\n\n                return [eq1, eq2]\n\n            # Solve for (delta^2, lambda)\n            sol = root(bcs_equations, [d2_prev, lam_prev], args=(G, ek, N), method='hybr', tol=1e-8)\n            \n            d2, lam = 0.0, 0.0\n\n            # Check for a converged, paired solution\n            if sol.success and sol.x[0] > 1e-8:\n                d2, lam = sol.x\n                d2 = max(0, d2)\n                \n                ek_prime = ek - lam\n                Ek = np.sqrt(ek_prime**2 + d2)\n                vk2 = np.zeros_like(Ek)\n                # Use np.divide to handle potential division by zero safely\n                non_zero_Ek = Ek != 0\n                vk2[non_zero_Ek] = 0.5 * (1 - ek_prime[non_zero_Ek] / Ek[non_zero_Ek])\n                \n                # Routhian for paired system\n                e_R = 2 * np.sum(ek * vk2) - d2 / G\n            else:\n                # Normal (unpaired) phase\n                d2 = 0.0\n                sorted_ek = np.sort(ek)\n                lam = 0.5 * (sorted_ek[N//2 - 1] + sorted_ek[N//2])\n                \n                # Occupation numbers (vk^2)\n                vk2 = (ek  lam).astype(float)\n                num_at_fermi = np.sum(ek == lam)\n                if num_at_fermi > 0:\n                    num_below_fermi = np.sum(ek  lam)\n                    needed_occ = (N/2 - num_below_fermi) / num_at_fermi\n                    vk2[ek == lam] = needed_occ\n\n                # Routhian for normal system\n                e_R = 2 * np.sum(ek * vk2)\n            \n            routhians.append(e_R)\n            d2_prev, lam_prev = d2, lam\n\n        E_omega = -np.array(routhians)\n        \n        # Angular momentum J(omega) = dE/domega\n        if len(E_omega)  3: return -1.0\n        J_omega = (E_omega[2:] - E_omega[:-2]) / (2 * delta_omega)\n        \n        # Derivative dJ/domega\n        if len(J_omega)  3: return -1.0\n        dJ_domega = (J_omega[2:] - J_omega[:-2]) / (2 * delta_omega)\n        omega_for_dJ = omega_grid[2:-2]\n\n        # Smooth dJ/domega with a 3-point moving average\n        if len(dJ_domega)  3: return -1.0\n        smoothed_dJ = np.convolve(dJ_domega, np.ones(3)/3.0, mode='valid')\n        omega_for_smoothed = omega_for_dJ[1:-1]\n\n        if len(smoothed_dJ)  3: return -1.0\n        \n        # --- Peak Detection Logic ---\n        # 1. Find global maximum\n        idx_max = np.argmax(smoothed_dJ)\n\n        # 2. Check if it's an interior peak\n        if idx_max == 0 or idx_max == len(smoothed_dJ) - 1:\n            return -1.0\n\n        # 3. Calculate prominence of the global maximum\n        all_peaks, properties = find_peaks(smoothed_dJ, prominence=0)\n        \n        is_a_peak = np.where(all_peaks == idx_max)[0]\n        if len(is_a_peak) == 0:\n            return -1.0 # Global max is not a distinct peak (e.g., on a plateau)\n\n        prominence_of_max = properties['prominences'][is_a_peak[0]]\n\n        # 4. Compare prominence to threshold (std dev of signal)\n        threshold = np.std(smoothed_dJ)\n        if prominence_of_max > threshold:\n            return omega_for_smoothed[idx_max]\n        else:\n            return -1.0\n\n    # --- Main Execution ---\n    # Model parameters\n    M = 12\n    N = 12\n    eps = np.linspace(-2.75, 2.75, M)\n    jx = 0.5 + 0.05 * np.arange(M)\n    jx[5] = 6.0\n    jx[6] = 6.0\n    \n    delta_omega = 0.005\n    omega_grid = np.arange(0, 0.5 + delta_omega, delta_omega)\n    \n    # Test suite from the problem statement\n    test_cases = [0.15, 0.30, 0.50, 0.80]\n\n    results = []\n    for G in test_cases:\n        bb_freq = get_bb_frequency(G, M, N, eps, jx, omega_grid, delta_omega)\n        results.append(bb_freq)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join([f'{r:.3f}' for r in results])}]\")\n\nsolve()\n```", "id": "3543335"}]}