{"hands_on_practices": [{"introduction": "A cornerstone of reliable numerical simulation is the verification of its core components. Before tackling the full complexity of TDHF, we must ensure our time-propagation algorithm performs as expected. This practice guides you through a fundamental diagnostic procedure: assessing the order of accuracy of different time integrators by measuring their energy drift, a direct consequence of their non-unitarity. By comparing the numerical scaling of this error with the theoretical prediction, you will learn a crucial skill for debugging and validating time-evolution codes [@problem_id:3577407].", "problem": "Consider a simplified single-orbital Time-Dependent Hartree-Fock (TDHF) setting in one spatial dimension, where the Slater determinant contains a single occupied orbital and the mean field is static. In this reduction, the orbital obeys the time-dependent Schrödinger equation with a time-independent Hermitian Hamiltonian. Let the orbital be denoted by $|\\psi(t)\\rangle$, and let the Hamiltonian be $H$. The governing equation is\n$$\ni\\frac{\\partial}{\\partial t}|\\psi(t)\\rangle = H|\\psi(t)\\rangle,\n$$\nwith $H$ Hermitian, under natural units where $\\hbar=1$ and $m=1$. The energy expectation is\n$$\nE(t) = \\langle \\psi(t)|H|\\psi(t)\\rangle,\n$$\nwhich is constant in the exact solution for time-independent $H$.\n\nIn numerical TDHF practice, implementation imperfections or the choice of a non-unitary time propagator can lead to energy drift. For a fixed total propagation time $T$ and a time step size $\\Delta t$, the energy drift $\\Delta E(\\Delta t)$ is defined as\n$$\n\\Delta E(\\Delta t) = E(T) - E(0),\n$$\nwhere $|\\psi(0)\\rangle$ is the initial orbital and $|\\psi(T)\\rangle$ is the numerically propagated orbital at time $T$. The task is to predict the $\\Delta t$-dependence of $\\Delta E(\\Delta t)$ for a non-unitary propagator of known order and then measure it numerically to diagnose whether the implemented integrator matches its expected order. Specifically, if a time integrator is of order $p$ (meaning the global solution error scales as $\\mathcal{O}((\\Delta t)^p)$ for fixed $T$), then, for a time-independent $H$, the energy drift is expected to satisfy\n$$\n\\Delta E(\\Delta t) \\propto (\\Delta t)^p\n$$\nfor sufficiently small $\\Delta t$, provided the energy is evaluated on a normalized state at the measurement points.\n\nYour program must:\n\n- Construct a one-dimensional Hamiltonian $H$ on a finite interval with Dirichlet boundary conditions using a second-order central finite difference for the kinetic term and a harmonic oscillator potential. Use a spatial domain $x\\in[-L,L]$ with $L=6$, a uniform grid of $N=128$ points, grid spacing $h$, kinetic operator $T=-\\frac{1}{2}\\frac{d^2}{dx^2}$, and potential $V(x)=\\frac{1}{2}\\omega^2 x^2$ with $\\omega=1$. Discretize $H=T+V$ as a real symmetric matrix. All inner products and expectation values must use the discrete quadrature weight $h$ so that $\\langle \\phi|\\psi\\rangle \\approx h\\sum_i \\phi_i^*\\psi_i$ and $E=\\mathrm{Re}\\left(h\\sum_i \\psi_i^*(H\\psi)_i\\right)$.\n- Initialize $|\\psi(0)\\rangle$ on the grid as the normalized harmonic oscillator ground-state orbital $\\psi(x)=\\pi^{-1/4}\\exp(-x^2/2)$ sampled on the grid, and normalize it with respect to the weighted inner product defined above.\n- Implement three explicit, non-unitary propagators $U(\\Delta t)$ to advance $|\\psi\\rangle\\mapsto|\\psi'\\rangle$ over one time step:\n  1. A first-order method: forward Euler defined by $|\\psi'\\rangle = |\\psi\\rangle - i\\Delta t H|\\psi\\rangle$.\n  2. A second-order polynomial truncation of the exponential: $|\\psi'\\rangle = |\\psi\\rangle - i\\Delta t H|\\psi\\rangle - \\frac{(\\Delta t)^2}{2}H^2|\\psi\\rangle$, with $H^2|\\psi\\rangle$ evaluated as $H(H|\\psi\\rangle)$.\n  3. An intentionally buggy “Crank–Nicolson-like” propagator that wrongly omits the inverse, defined here as $|\\psi'\\rangle = \\left(I - i\\frac{\\Delta t}{2}H\\right)|\\psi\\rangle$.\n- For each propagator, propagate to final time $T=2.0$ using four different time step sizes $\\Delta t\\in\\{0.2,0.1,0.05,0.025\\}$. At $t=0$ and $t=T$, compute $E(t)$ using the normalized orbital $|\\tilde{\\psi}(t)\\rangle = |\\psi(t)\\rangle/\\sqrt{\\langle \\psi(t)|\\psi(t)\\rangle}$.\n- For each propagator, measure the energy drift magnitudes $\\{\\left|\\Delta E(\\Delta t)\\right|\\}$ over the four $\\Delta t$ values and estimate the slope $s$ of $\\log\\left|\\Delta E\\right|$ versus $\\log(\\Delta t)$ by least-squares linear regression. Compare this measured slope $s$ to the integrator’s expected order $p$.\n- Decide whether the implementation is consistent with its expected order by checking if $|s-p|\\leq 0.3$. This threshold is meant to provide a robust diagnostic while allowing for spatial discretization and finite-time effects.\n\nTest suite and required outputs:\n\n- Use the three propagators in the order listed above. Their expected orders are $p=1$ for forward Euler, $p=2$ for the second-order polynomial truncation, and $p=2$ for the intended Crank–Nicolson-like method (however, because the provided “buggy” implementation omits the inverse, the actual measured order may differ).\n- For each propagator, perform the $\\Delta t$ sweep over $\\{0.2,0.1,0.05,0.025\\}$ and estimate the slope $s$ as described.\n- The final output must be a single line containing a comma-separated list of three booleans enclosed in square brackets, in the same order as the propagators above, indicating whether the measured slope agrees with the expected order within the tolerance. For example, if the first two match and the third does not, the output should be $[True,True,False]$.\n\nAll quantities are to be treated in natural units, and since the Hamiltonian, state vector, and time step are dimensionless under these units, no physical unit conversions are required. Angles are not used in this problem. Your program must be complete, self-contained, and produce the exact final output format specified above.", "solution": "The user-provided problem has been rigorously validated and is determined to be a valid, well-posed scientific problem. It is scientifically grounded in the principles of quantum mechanics and numerical analysis, with all necessary parameters and definitions provided for a unique and verifiable solution.\n\nThe problem asks for a numerical verification of the order of accuracy for three different time-propagation schemes applied to the time-dependent Schrödinger equation in a simplified one-dimensional setting. The verification is based on analyzing the scaling of energy drift with respect to the time step size, $\\Delta t$.\n\n### 1. System Discretization and Hamiltonian Construction\n\nThe physical system is defined on a one-dimensional spatial domain $x \\in [-L, L]$ with $L=6$. This domain is discretized into a uniform grid of $N=128$ points, denoted by $\\{x_i\\}$, with a constant grid spacing $h = 2L/(N-1)$. A quantum state $|\\psi\\rangle$ is represented as a complex-valued vector of its values on this grid, $\\psi_i = \\psi(x_i)$.\n\nThe inner product between two states $|\\phi\\rangle$ and $|\\psi\\rangle$ is approximated using a rectangular quadrature rule:\n$$\n\\langle \\phi | \\psi \\rangle \\approx h \\sum_{i=0}^{N-1} \\phi_i^* \\psi_i\n$$\nwhere $\\phi_i^*$ is the complex conjugate of $\\phi_i$.\n\nThe Hamiltonian $H = T + V$ consists of a kinetic term $T = -\\frac{1}{2}\\frac{d^2}{dx^2}$ (with $\\hbar=1, m=1$) and a harmonic oscillator potential $V(x) = \\frac{1}{2}\\omega^2 x^2$ with $\\omega=1$. These operators are discretized as $N \\times N$ matrices.\n\nThe potential operator $V$ is local in position, so its matrix representation is diagonal:\n$$\nV_{ij} = \\left(\\frac{1}{2}\\omega^2 x_i^2\\right) \\delta_{ij}\n$$\nwhere $\\delta_{ij}$ is the Kronecker delta.\n\nThe kinetic operator $T$ is discretized using a second-order central finite difference for the second derivative:\n$$\n\\left(\\frac{d^2\\psi}{dx^2}\\right)_{x=x_i} \\approx \\frac{\\psi_{i+1} - 2\\psi_i + \\psi_{i-1}}{h^2}\n$$\nThis results in a tridiagonal matrix for the kinetic operator $T$:\n$$\nT_{ij} = -\\frac{1}{2h^2} \\begin{cases}\n-2 & \\text{if } i = j \\\\\n1 & \\text{if } |i-j| = 1 \\\\\n0 & \\text{otherwise}\n\\end{cases}\n$$\nThe total Hamiltonian is the matrix sum $H = T + V$, which is a real, symmetric (and thus Hermitian) matrix.\n\n### 2. Initial State\n\nThe initial state $|\\psi(0)\\rangle$ is the ground state of the quantum harmonic oscillator, given by the analytical function $\\psi(x) = \\pi^{-1/4} \\exp(-x^2/2)$. This function is sampled on the spatial grid $\\{x_i\\}$ to obtain the initial state vector. This vector is then normalized with respect to the discrete inner product to ensure $\\langle\\psi(0)|\\psi(0)\\rangle = 1$.\n\n### 3. Time Propagation Methods\n\nThe evolution of the state is governed by $|\\psi(t+\\Delta t)\\rangle = U(\\Delta t)|\\psi(t)\\rangle$, where $U(\\Delta t) = \\exp(-iH\\Delta t)$ is the exact propagator. We implement three different explicit, non-unitary approximations to $U(\\Delta t)$.\n\n1.  **Forward Euler**: This is a first-order Taylor expansion of the exponential:\n    $$\n    |\\psi(t+\\Delta t)\\rangle = |\\psi(t)\\rangle - i\\Delta t H|\\psi(t)\\rangle\n    $$\n    The local truncation error is $\\mathcal{O}((\\Delta t)^2)$, leading to a global error of order $p=1$.\n\n2.  **Second-Order Polynomial Truncation**: This is a second-order Taylor expansion:\n    $$\n    |\\psi(t+\\Delta t)\\rangle = \\left(I - i\\Delta t H - \\frac{(\\Delta t)^2}{2}H^2\\right)|\\psi(t)\\rangle\n    $$\n    The local truncation error is $\\mathcal{O}((\\Delta t)^3)$, yielding a global error of order $p=2$.\n\n3.  **\"Buggy\" Crank–Nicolson-like Propagator**: This method is defined as:\n    $$\n    |\\psi(t+\\Delta t)\\rangle = \\left(I - i\\frac{\\Delta t}{2}H\\right)|\\psi(t)\\rangle\n    $$\n    A correct (implicit, second-order) Crank-Nicolson propagator is given by $(I + i\\frac{\\Delta t}{2}H)|\\psi(t+\\Delta t)\\rangle = (I - i\\frac{\\Delta t}{2}H)|\\psi(t)\\rangle$. The \"buggy\" version provided omits the inverse term on the left-hand side. This results in a propagator that is formally identical to the first-order forward Euler method, but with an effective time step of $\\Delta t/2$. The local truncation error is $\\mathcal{O}((\\Delta t)^2)$, yielding a global error of order $p=1$. The problem specifies testing this against an \"expected\" order of $p=2$, which simulates a diagnostic scenario where a developer's mistaken expectation is tested against numerical reality. The verification procedure is expected to measure an order of $s \\approx 1$, which will fail the test against $p=2$, correctly identifying the implementation as faulty.\n\n### 4. Energy Drift and Order Verification\n\nFor an exact, unitary evolution with a time-independent Hamiltonian, the energy expectation value $E(t) = \\langle\\psi(t)|H|\\psi(t)\\rangle$ is a conserved quantity. The use of non-unitary numerical propagators breaks this conservation, leading to an energy drift $\\Delta E(\\Delta t) = E(T) - E(0)$ over a total propagation time $T$.\n\nThe problem postulates that for a method of order $p$, this energy drift scales as $|\\Delta E(\\Delta t)| \\propto (\\Delta t)^p$ for small $\\Delta t$. Taking the logarithm of both sides gives:\n$$\n\\log|\\Delta E(\\Delta t)| = p \\log(\\Delta t) + \\text{constant}\n$$\nThis linear relationship implies that the order $p$ can be estimated by performing a linear regression on the log-log data of energy drift versus time step size. The slope $s$ of the best-fit line gives a numerical measurement of the order.\n\nThe algorithm proceeds as follows for each propagator:\n1.  For a set of time step sizes $\\Delta t \\in \\{0.2, 0.1, 0.05, 0.025\\}$, propagate the initial state from $t=0$ to $t=T=2.0$.\n2.  Calculate the initial energy $E(0)$ and final energy $E(T)$. At each measurement, the state vector is first normalized before computing the energy expectation value, as specified.\n3.  Compute the absolute energy drift $|\\Delta E(\\Delta t)| = |E(T) - E(0)|$.\n4.  After collecting the drift values for all $\\Delta t$, perform a least-squares linear fit on the points $(\\log(\\Delta t), \\log|\\Delta E(\\Delta t)|)$ to find the slope $s$.\n5.  Compare the measured slope $s$ with the expected order $p$ for that propagator. The implementation is considered consistent if $|s - p| \\le 0.3$. This tolerance allows for deviations due to finite $\\Delta t$ effects and spatial discretization errors.\n\nThe final output is a boolean list indicating this consistency check for each of the three propagators.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs a numerical experiment to verify the order of accuracy for three\n    time-propagation schemes in a simplified 1D TDHF context.\n    \"\"\"\n    # 1. Define constants and simulation parameters\n    L = 6.0\n    N = 128\n    omega = 1.0\n    T = 2.0\n    delta_ts = np.array([0.2, 0.1, 0.05, 0.025])\n    \n    # Expected orders of accuracy (p) for the three propagators\n    expected_orders = [1, 2, 2]\n    tolerance = 0.3\n\n    # 2. Set up the spatial grid\n    x = np.linspace(-L, L, N)\n    h = x[1] - x[0]\n\n    # 3. Construct the Hamiltonian matrix H\n    # Kinetic energy T = -1/2 * d^2/dx^2 via central finite difference\n    diag_T = np.ones(N) / h**2\n    off_diag_T = -np.ones(N - 1) / (2 * h**2)\n    T_matrix = np.diag(diag_T) + np.diag(off_diag_T, k=1) + np.diag(off_diag_T, k=-1)\n    \n    # Potential energy V = 1/2 * omega^2 * x^2\n    V_matrix = np.diag(0.5 * omega**2 * x**2)\n    \n    H = T_matrix + V_matrix\n\n    # 4. Define and normalize the initial state psi_0\n    # Ground state of harmonic oscillator\n    psi_0 = np.pi**(-0.25) * np.exp(-x**2 / 2.0)\n    # The state should be complex for general propagations\n    psi_0 = psi_0.astype(np.complex128)\n    \n    # Normalize with discrete inner product <psi|psi> = h * sum(|psi_i|^2)\n    norm_sq = h * np.sum(np.abs(psi_0)**2)\n    psi_0 = psi_0 / np.sqrt(norm_sq)\n\n    def calculate_energy(psi, H_mat, h_spacing):\n        \"\"\"\n        Calculates the energy expectation <psi|H|psi> for a given state.\n        The state is normalized *before* the expectation value is computed.\n        \"\"\"\n        # Normalize the state vector first, as per problem description\n        current_norm_sq = h_spacing * np.sum(np.abs(psi)**2)\n        if current_norm_sq == 0:\n            return 0.0\n        psi_norm = psi / np.sqrt(current_norm_sq)\n        \n        # Calculate <psi_norm|H|psi_norm>\n        H_psi = H_mat @ psi_norm\n        energy = h_spacing * np.sum(np.conj(psi_norm) * H_psi)\n        return np.real(energy)\n\n    # List to store the boolean results of the consistency checks\n    final_results = []\n    \n    propagator_info = [\n        {'name': 'forward_euler', 'p': 1},\n        {'name': 'taylor_2nd_order', 'p': 2},\n        {'name': 'buggy_cn_like', 'p': 2}\n    ]\n\n    # 5. Main loop over each propagator\n    for info in propagator_info:\n        propagator_type = info['name']\n        p_expected = info['p']\n        \n        energy_drifts = []\n\n        # Loop over different time steps\n        for dt in delta_ts:\n            psi = psi_0.copy()\n            \n            # Initial energy\n            E0 = calculate_energy(psi, H, h)\n            \n            num_steps = int(round(T / dt))\n            \n            # Time propagation loop\n            if propagator_type == 'forward_euler':\n                for _ in range(num_steps):\n                    psi = psi - 1j * dt * (H @ psi)\n            elif propagator_type == 'taylor_2nd_order':\n                for _ in range(num_steps):\n                    H_psi = H @ psi\n                    H2_psi = H @ H_psi\n                    psi = psi - 1j * dt * H_psi - (dt**2 / 2.0) * H2_psi\n            elif propagator_type == 'buggy_cn_like':\n                for _ in range(num_steps):\n                    psi = psi - 1j * (dt / 2.0) * (H @ psi)\n            \n            # Final energy\n            ET = calculate_energy(psi, H, h)\n            \n            # Store absolute energy drift\n            energy_drifts.append(np.abs(ET - E0))\n\n        # 6. Perform log-log linear regression to find the measured order\n        log_dt = np.log(delta_ts)\n        log_delta_E = np.log(np.array(energy_drifts))\n        \n        # Fit a line (polynomial of degree 1) and get the slope\n        slope, _ = np.polyfit(log_dt, log_delta_E, 1)\n        \n        # 7. Check if the measured slope is within tolerance of the expected order\n        is_consistent = np.abs(slope - p_expected) <= tolerance\n        final_results.append(is_consistent)\n\n    # 8. Print the final results in the required format\n    # The output format requires capitalized booleans\n    formatted_results = [str(b) for b in final_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3577407"}, {"introduction": "With a validated time-integration scheme, the next step is to confirm that our simulation correctly reproduces fundamental physical principles. This exercise focuses on numerically verifying Ehrenfest's theorem, which establishes a profound connection between quantum mechanics and the classical laws of motion. You will implement a simulation of a quantum wave packet and demonstrate that the time evolution of its average position and momentum adheres to classical equations, providing a critical check on the physical correctness of your Hamiltonian and observable operators [@problem_id:3577445].", "problem": "You are asked to design and implement a one-dimensional numerical propagation of a single occupied orbital in the Time-Dependent Hartree-Fock (TDHF) approximation, specialized to the single-particle limit where the dynamics reduce to the time-dependent Schrödinger equation in a static, local mean-field potential. Your goal is to numerically verify the Ehrenfest relations under Galilean boosts during the propagation:\n1) $\\frac{d}{dt}\\langle \\hat{x} \\rangle = \\left\\langle \\frac{\\hat{p}}{m} \\right\\rangle$,\n2) $\\frac{d}{dt}\\langle \\hat{p} \\rangle = \\langle -\\partial_x U(x) \\rangle$,\nfor three representative mean-field potentials.\n\nFoundational base:\n- The single-orbital Time-Dependent Hartree-Fock (TDHF) equation in a prescribed mean-field reduces to the time-dependent Schrödinger equation:\n$$\ni \\hbar \\frac{\\partial}{\\partial t}\\psi(x,t) = \\left[-\\frac{\\hbar^2}{2m}\\partial_x^2 + U(x)\\right]\\psi(x,t),\n$$\nwith $\\psi$ normalized to unity. Work in dimensionless units with $\\hbar=1$, so all quantities are dimensionless and your final answers must be dimensionless floats.\n- Expectation values are defined as $\\langle \\hat{A} \\rangle(t)=\\int \\psi^*(x,t) \\hat{A} \\psi(x,t)\\,dx$ for any operator $\\hat{A}$.\n- A Galilean boost by momentum $p_0$ is implemented in the initial state as a phase factor $\\exp(i p_0 x)$ multiplying the spatial wave packet.\n\nAlgorithmic requirements:\n- Use a norm-preserving second-order time integrator consistent with the Hamiltonian time evolution (for example, a symmetric Trotter splitting of kinetic and potential parts implemented with a Fast Fourier Transform (FFT)). The kinetic operator is $\\hat{T}=\\hat{p}^2/(2m)$ with $\\hat{p}=-i\\partial_x$, and the potential operator is $\\hat{V}=U(x)$.\n- Use periodic boundary conditions implied by the FFT on a spatial interval of length $L$ discretized by $N$ grid points. Choose $L$ and simulation times short enough that the wave packet remains well inside the domain throughout each run.\n- The spatial derivative of the wave function for the momentum expectation may be computed spectrally to avoid finite-difference dispersion, using the wave number grid $k$ obtained from the FFT frequency grid. In these units, $\\hat{p}=-i\\partial_x$.\n- Compute the following time series during propagation: $\\langle x \\rangle(t)$, $\\langle p \\rangle(t)$, and $\\langle -\\partial_x U \\rangle(t)$. Approximate time derivatives by a second-order accurate finite difference in time using a central difference in the interior and a one-sided second-order stencil at the endpoints.\n\nInitial state under boost:\n- Use a normalized Gaussian wave packet,\n$$\n\\psi(x,0) = \\left(\\frac{1}{\\pi \\sigma^2}\\right)^{1/4} \\exp\\left(-\\frac{(x-x_0)^2}{2\\sigma^2}\\right)\\exp(i p_0 x).\n$$\n\nPotentials to test:\n- Free particle: $U(x)=0$, hence $\\partial_x U(x)=0$.\n- Harmonic oscillator: $U(x)=\\tfrac{1}{2} m \\omega^2 x^2$, hence $\\partial_x U(x)= m\\omega^2 x$.\n- Gaussian well: $U(x)=-U_0 \\exp\\left(-\\frac{x^2}{2a^2}\\right)$, hence $\\partial_x U(x)= U_0 \\frac{x}{a^2} \\exp\\left(-\\frac{x^2}{2a^2}\\right)$.\n\nNumerical verification:\n- For each test case, simulate the time evolution and evaluate the maximum absolute deviations over the simulated time window for:\n(a) $\\left|\\frac{d}{dt}\\langle x \\rangle - \\frac{\\langle p \\rangle}{m}\\right|$,\n(b) $\\left|\\frac{d}{dt}\\langle p \\rangle - \\langle -\\partial_x U \\rangle\\right|$.\n- Report these two maximum deviations as dimensionless floats per test case.\n\nTest suite:\nUse the following three test cases. All quantities are dimensionless. For each case, discretize space uniformly on $[-L/2,L/2)$ with $N$ points and time with step $\\Delta t$ and $N_t$ steps. Use the FFT frequency grid to define the wave number $k$ and spectral kinetic phase. In all cases set $m=1$.\n1) Free particle under boost:\n- $U(x)=0$,\n- $L=200$, $N=1024$,\n- $\\Delta t=0.02$, $N_t=400$,\n- $\\sigma=2.0$, $x_0=-30.0$, $p_0=2.0$.\n2) Harmonic oscillator under boost:\n- $U(x)=\\tfrac{1}{2} \\omega^2 x^2$ with $\\omega=0.15$,\n- $L=200$, $N=1024$,\n- $\\Delta t=0.02$, $N_t=600$,\n- $\\sigma=1/\\sqrt{\\omega}$, $x_0=15.0$, $p_0=1.0$.\n3) Gaussian well under boost:\n- $U(x)=-U_0 \\exp\\left(-\\frac{x^2}{2a^2}\\right)$ with $U_0=6.0$, $a=3.0$,\n- $L=200$, $N=1024$,\n- $\\Delta t=0.01$, $N_t=800$,\n- $\\sigma=2.0$, $x_0=-20.0$, $p_0=2.0$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element corresponds to one test case in the order listed above and is itself a two-element list containing the two maximum deviations:\n$[[e_{x,1}, e_{p,1}], [e_{x,2}, e_{p,2}], [e_{x,3}, e_{p,3}]]$.\n- All outputs are dimensionless floats. The printed line must have no spaces (e.g., \"[[0.00012,0.00034],[...],[...]]\").", "solution": "The user has provided a valid, well-posed problem in computational quantum mechanics. The task is to numerically solve the one-dimensional time-dependent Schrödinger equation for a single particle and verify the Ehrenfest relations.\n\nThe solution proceeds in three stages: establishing the theoretical and numerical framework, implementing the simulation for each specified case, and finally, quantifying the deviation from the exact Ehrenfest relations. All mathematical expressions are rendered in LaTeX as required.\n\n### 1. Theoretical Framework\n\nThe fundamental equation governing the system is the time-dependent Schrödinger equation (TDSE) for a single-particle wave function $\\psi(x,t)$ in a static potential $U(x)$. In dimensionless units where the reduced Planck constant $\\hbar=1$, the equation is:\n$$\ni \\frac{\\partial}{\\partial t}\\psi(x,t) = \\hat{H}\\psi(x,t) = \\left[-\\frac{1}{2m}\\frac{\\partial^2}{\\partial x^2} + U(x)\\right]\\psi(x,t)\n$$\nHere, $\\hat{H}$ is the Hamiltonian operator, composed of a kinetic energy operator $\\hat{T} = -\\frac{1}{2m}\\frac{\\partial^2}{\\partial x^2}$ and a potential energy operator $\\hat{V} = U(x)$. The wave function is normalized such that $\\int |\\psi(x,t)|^2 dx = 1$.\n\nEhrenfest's theorem connects quantum mechanical expectation values to classical mechanics. For a particle of mass $m$, the two relations to be verified are:\n1.  The time evolution of the expectation value of position $\\langle \\hat{x} \\rangle$:\n    $$ \\frac{d}{dt}\\langle \\hat{x} \\rangle = \\frac{\\langle \\hat{p} \\rangle}{m} $$\n2.  The time evolution of the expectation value of momentum $\\langle \\hat{p} \\rangle$:\n    $$ \\frac{d}{dt}\\langle \\hat{p} \\rangle = \\langle -\\frac{\\partial U}{\\partial x} \\rangle $$\nwhere $\\hat{x}=x$ is the position operator and $\\hat{p}=-i\\frac{\\partial}{\\partial x}$ is the momentum operator (with $\\hbar=1$). The expectation value of an operator $\\hat{A}$ is given by $\\langle \\hat{A} \\rangle(t) = \\int \\psi^*(x,t) \\hat{A} \\psi(x,t) dx$.\n\n### 2. Numerical Implementation\n\nThe TDSE is solved numerically on a discrete spatio-temporal grid.\n\n**2.1. Discretization and Initial State**\n\nThe spatial domain is the interval $[-L/2, L/2)$, discretized into $N$ points $x_j = -L/2 + j \\Delta x$ for $j=0, \\dots, N-1$, with grid spacing $\\Delta x = L/N$. Time is discretized into steps of size $\\Delta t$.\n\nThe initial state at $t=0$ is a Gaussian wave packet centered at $x_0$, with standard deviation $\\sigma$, and subjected to a Galilean boost with momentum $p_0$:\n$$\n\\psi(x,0) = C \\exp\\left(-\\frac{(x-x_0)^2}{2\\sigma^2}\\right)\\,\\exp(i p_0 x)\n$$\nThe constant $C$ is chosen to normalize the wave function on the discrete grid, i.e., $\\sum_{j=0}^{N-1} |\\psi(x_j,0)|^2 \\Delta x = 1$.\n\n**2.2. Time Propagation: Split-Operator FFT Method**\n\nThe formal solution to the TDSE over a small time step $\\Delta t$ is $\\psi(t+\\Delta t) = \\exp(-i\\hat{H}\\Delta t)\\psi(t)$. Since the kinetic ($\\hat{T}$) and potential ($\\hat{V}$) operators do not commute, we use a second-order symmetric Trotter-Suzuki decomposition of the time-evolution operator:\n$$\ne^{-i(\\hat{T}+\\hat{V})\\Delta t} \\approx e^{-i\\hat{V}\\Delta t/2} \\, e^{-i\\hat{T}\\Delta t} \\, e^{-i\\hat{V}\\Delta t/2}\n$$\nThis scheme is unitary (norm-preserving) and accurate to order $O(\\Delta t^3)$ for a single step. The propagation algorithm for one time step is:\n1.  **Potential Half-Step:** Evolve in coordinate space by applying the potential operator for $\\Delta t/2$. This corresponds to multiplying the wave function by a phase factor: $\\psi(x) \\rightarrow \\psi(x) \\exp(-i U(x) \\Delta t / 2)$.\n2.  **Kinetic Full-Step:** Evolve in momentum space by applying the kinetic operator for a full step $\\Delta t$. This is achieved by:\n    a.  Transforming $\\psi(x)$ to its momentum-space representation $\\tilde{\\psi}(k)$ using the Fast Fourier Transform (FFT).\n    b.  Multiplying $\\tilde{\\psi}(k)$ by the kinetic phase factor $\\exp(-i k^2 \\Delta t / (2m))$, where $k$ is the wave number corresponding to the momentum grid.\n    c.  Transforming back to coordinate space using the inverse FFT.\n3.  **Potential Half-Step:** Apply the potential operator again for the second half-step, $\\Delta t/2$, as in step 1.\n\nThe wave number grid $k$ is constructed from the FFT frequencies, $k_n = 2\\pi f_n$, where $f_n$ are the frequencies provided by `numpy.fft.fftfreq(N, d=dx)`.\n\n**2.3. Calculation of Observables**\n\nAt each time step, we compute the required expectation values using numerical integration on the grid:\n-   Position: $\\langle \\hat{x} \\rangle(t) \\approx \\sum_j |\\psi(x_j, t)|^2 x_j \\Delta x$.\n-   Force: $\\langle -\\partial_x U \\rangle(t) \\approx \\sum_j |\\psi(x_j, t)|^2 \\left(-\\frac{\\partial U}{\\partial x}\\Big|_{x_j}\\right) \\Delta x$. The analytic derivatives for the given potentials are used.\n-   Momentum: $\\langle \\hat{p} \\rangle(t) = \\int \\psi^*(x,t)(-i\\partial_x)\\psi(x,t)dx$. The derivative $\\partial_x \\psi$ is computed spectrally for high accuracy. The operator $\\hat{p}\\psi = -i\\partial_x\\psi$ is evaluated as $\\mathcal{F}^{-1}(k \\mathcal{F}(\\psi))$, where $\\mathcal{F}$ and $\\mathcal{F}^{-1}$ denote the FFT and its inverse. The expectation value is then computed by the sum $\\sum_j \\psi_j^*(t) (\\hat{p}\\psi)_j(t) \\Delta x$.\n\n### 3. Verification Procedure\n\nAfter the simulation, we have time series for $\\langle \\hat{x} \\rangle(t_i)$, $\\langle \\hat{p} \\rangle(t_i)$, and $\\langle -\\partial_x U \\rangle(t_i)$.\n\n**3.1. Numerical Differentiation**\n\nThe time derivatives $\\frac{d}{dt}\\langle \\hat{x} \\rangle$ and $\\frac{d}{dt}\\langle \\hat{p} \\rangle$ are computed from their time series, let's call one generically $f(t_i)$, using a second-order accurate finite difference scheme:\n-   For interior points ($i=1, \\dots, N_t-1$): A central difference is used.\n    $$ \\frac{df}{dt}\\Big|_{t_i} \\approx \\frac{f(t_{i+1}) - f(t_{i-1})}{2\\Delta t} $$\n-   For the endpoints ($i=0$ and $i=N_t$): A second-order one-sided stencil is used.\n    $$ \\frac{df}{dt}\\Big|_{t_0} \\approx \\frac{-3f(t_0) + 4f(t_1) - f(t_2)}{2\\Delta t} $$\n    $$ \\frac{df}{dt}\\Big|_{t_{N_t}} \\approx \\frac{3f(t_{N_t}) - 4f(t_{N_t-1}) + f(t_{N_t-2})}{2\\Delta t} $$\n\n**3.2. Error Calculation**\n\nFinally, the numerical validity of the Ehrenfest relations is checked by computing the maximum absolute deviation for each relation over the entire simulation time:\n-   Error in position relation: $e_{x} = \\max_{t_i} \\left| \\frac{d}{dt}\\langle \\hat{x} \\rangle(t_i) - \\frac{\\langle \\hat{p} \\rangle(t_i)}{m} \\right|$\n-   Error in momentum relation: $e_{p} = \\max_{t_i} \\left| \\frac{d}{dt}\\langle \\hat{p} \\rangle(t_i) - \\langle -\\partial_x U \\rangle(t_i) \\right|$\n\nThese two values, $e_x$ and $e_p$, are computed for each of the three potential scenarios, providing a quantitative measure of the simulation's accuracy and its adherence to fundamental quantum principles.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(params):\n    \"\"\"\n    Runs a 1D TDSE simulation for a given set of parameters\n    and verifies Ehrenfest's theorem.\n    \"\"\"\n    # Unpack parameters\n    potential_type = params['potential_type']\n    L = params['L']\n    N = params['N']\n    dt = params['dt']\n    Nt = params['Nt']\n    sigma = params['sigma']\n    x0 = params['x0']\n    p0 = params['p0']\n    m = params.get('m', 1.0)\n    omega = params.get('omega', 0)\n    U0 = params.get('U0', 0)\n    a = params.get('a', 1)\n\n    # Spatial grid\n    dx = L / N\n    x = np.arange(-L / 2, L / 2, dx)\n\n    # Momentum grid (wave number)\n    k = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n\n    # Time grid\n    t_array = np.arange(0, Nt * dt, dt)\n    # Total number of time points where observables are stored is Nt+1\n    # from t=0 to t=Nt*dt inclusive\n    num_time_points = Nt + 1\n\n    # Define potentials and their derivatives\n    if potential_type == 'free':\n        V = np.zeros_like(x)\n        neg_dVdx = np.zeros_like(x)\n    elif potential_type == 'harmonic':\n        V = 0.5 * m * omega**2 * x**2\n        neg_dVdx = -m * omega**2 * x\n    elif potential_type == 'gaussian':\n        V = -U0 * np.exp(-x**2 / (2 * a**2))\n        neg_dVdx = -U0 * (x / a**2) * np.exp(-x**2 / (2 * a**2))\n    else:\n        raise ValueError(\"Unknown potential type\")\n\n    # Initial wave function (normalized)\n    psi = (1 / (np.pi * sigma**2))**(1/4) * \\\n          np.exp(-(x - x0)**2 / (2 * sigma**2)) * \\\n          np.exp(1j * p0 * x)\n    norm = np.sqrt(np.sum(np.abs(psi)**2) * dx)\n    psi /= norm\n\n    # Time evolution operators\n    exp_V_half = np.exp(-1j * V * dt / 2)\n    exp_T = np.exp(-1j * k**2 * dt / (2 * m))\n\n    # Arrays to store expectation values\n    x_exp_t = np.zeros(num_time_points)\n    p_exp_t = np.zeros(num_time_points)\n    force_exp_t = np.zeros(num_time_points)\n\n    # Main time-evolution loop\n    for i in range(num_time_points):\n        # Calculate and store observables at current time\n        x_exp_t[i] = np.sum(np.conj(psi) * x * psi).real * dx\n        \n        psi_k = np.fft.fft(psi)\n        p_psi = np.fft.ifft(k * psi_k)\n        p_exp_t[i] = np.sum(np.conj(psi) * p_psi).real * dx\n        \n        force_exp_t[i] = np.sum(np.abs(psi)**2 * neg_dVdx).real * dx\n\n        # Propagate for the next step (if not the last step)\n        if i < Nt:\n            # First half potential step\n            psi = exp_V_half * psi\n            # Full kinetic step in momentum space\n            psi_k = np.fft.fft(psi)\n            psi_k = exp_T * psi_k\n            psi = np.fft.ifft(psi_k)\n            # Second half potential step\n            psi = exp_V_half * psi\n\n    # Calculate time derivatives of expectation values\n    def second_order_derivative(f, h):\n        dfdt = np.zeros_like(f)\n        # Central difference for interior\n        dfdt[1:-1] = (f[2:] - f[:-2]) / (2 * h)\n        # Second-order forward difference for the start\n        if len(f) > 2:\n            dfdt[0] = (-3*f[0] + 4*f[1] - f[2]) / (2 * h)\n        # Second-order backward difference for the end\n        if len(f) > 2:\n            dfdt[-1] = (3*f[-1] - 4*f[-2] + f[-3]) / (2 * h)\n        return dfdt\n\n    d_x_exp_dt = second_order_derivative(x_exp_t, dt)\n    d_p_exp_dt = second_order_derivative(p_exp_t, dt)\n\n    # Calculate deviations from Ehrenfest relations\n    # We ignore the first and last point for the central difference part\n    # since boundary stencils can be less accurate. But the problem asks\n    for the max over the whole window with specified stencils.\n    err_x = np.abs(d_x_exp_dt - p_exp_t / m)\n    err_p = np.abs(d_p_exp_dt - force_exp_t)\n\n    max_err_x = np.max(err_x)\n    max_err_p = np.max(err_p)\n\n    return [max_err_x, max_err_p]\n\ndef solve():\n    \"\"\"\n    Defines and runs the test cases, then prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        { # 1) Free particle\n            'potential_type': 'free',\n            'L': 200.0, 'N': 1024,\n            'dt': 0.02, 'Nt': 400,\n            'sigma': 2.0, 'x0': -30.0, 'p0': 2.0,\n            'm': 1.0\n        },\n        { # 2) Harmonic oscillator\n            'potential_type': 'harmonic',\n            'L': 200.0, 'N': 1024,\n            'dt': 0.02, 'Nt': 600,\n            'omega': 0.15,\n            'sigma': 1.0 / np.sqrt(0.15), 'x0': 15.0, 'p0': 1.0,\n            'm': 1.0\n        },\n        { # 3) Gaussian well\n            'potential_type': 'gaussian',\n            'L': 200.0, 'N': 1024,\n            'dt': 0.01, 'Nt': 800,\n            'U0': 6.0, 'a': 3.0,\n            'sigma': 2.0, 'x0': -20.0, 'p0': 2.0,\n            'm': 1.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # e.g., [[0.00012,0.00034],[...],[...]]\n    output_str = f\"[{','.join([f'[{r[0]},{r[1]}]' for r in results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3577445"}, {"introduction": "Advanced numerical simulations must not only be accurate but also respect the fundamental symmetries of the underlying physical laws. This practice delves into the subtle but critical issue of Galilean invariance, which dictates that the intrinsic properties of an isolated system should not depend on its overall velocity. You will investigate how a naive discretization of operators on a spatial lattice can violate this symmetry, leading to unphysical results, and explore correction schemes designed to restore it, a crucial step towards building robust and reliable TDHF solvers [@problem_id:3577472].", "problem": "Design and implement a self-contained numerical experiment to assess Galilean invariance in a simplified Time-Dependent Hartree-Fock (TDHF) setting by boosting an isolated, bound system and quantifying violations caused by finite-difference discretization of gradients. Work in one spatial dimension with a Slater determinant built from two orthonormal single-particle orbitals approximating a compact nucleus. Use dimensionless natural units with Planck's constant set to $\\hbar = 1$ and nucleon mass set to $m = 1$; thus all quantities are dimensionless. The goal is to demonstrate what invariance demands, why it is expected from first principles, how finite-difference gradients violate it, and how to construct and test corrections that restore invariance of intrinsic observables.\n\nConstruct the following scenario and computations:\n\n- Geometry and grid:\n  - Use a uniform periodic grid with $N = 512$ points over the interval of length $L = 64$ centered at $x = 0$. The grid spacing is $a = L/N$ and the point coordinates are $x_n = a \\left(n - N/2\\right)$ for integer $n \\in \\{0,1,\\dots,N-1\\}$.\n- Bound system and orbitals:\n  - Use two orthonormal single-particle orbitals $\\psi_0(x)$ and $\\psi_1(x)$ modeled as the first two harmonic-oscillator eigenfunctions with width parameter $b = 2.0$ in the continuum:\n    - $\\psi_0(x) \\propto \\exp\\left(-\\frac{x^2}{2 b^2}\\right)$,\n    - $\\psi_1(x) \\propto \\frac{x}{b} \\exp\\left(-\\frac{x^2}{2 b^2}\\right)$,\n    up to overall normalization constants. Discretize these functions on the grid and renormalize them using the discrete inner product with weight $a$. Treat the system as a Slater determinant with $A = 2$ occupied orbitals.\n- Uniform boost:\n  - For a given velocity $v$, apply a Galilean boost to each orbital by multiplying with the phase $e^{i k_0 x}$ where $k_0 = m v$ and $m = 1$ in these units. Hence, the boosted orbitals are $\\psi_i^{(v)}(x) = e^{i k_0 x} \\psi_i(x)$ for $i \\in \\{0,1\\}$.\n- Discrete operators:\n  - Use second-order central finite differences with periodic boundary conditions to define the discrete Laplacian $\\Delta$ and momentum operator $\\hat{p}$ acting on a grid function $\\phi$ as\n    - $(\\Delta \\phi)_n = \\frac{\\phi_{n+1} - 2 \\phi_n + \\phi_{n-1}}{a^2}$,\n    - $(\\hat{p} \\phi)_n = -i \\frac{\\phi_{n+1} - \\phi_{n-1}}{2 a}$.\n  - Define the discrete kinetic energy as $T[\\{\\psi_i\\}] = \\frac{1}{2m} \\sum_{i=0}^{A-1} \\sum_{n=0}^{N-1} \\psi_i^*(x_n) (-\\Delta \\psi_i)(x_n) a$, and the total momentum as $P[\\{\\psi_i\\}] = \\sum_{i=0}^{A-1} \\sum_{n=0}^{N-1} \\psi_i^*(x_n) (\\hat{p} \\psi_i)(x_n) a$. In these units, take $m = 1$.\n  - Define the naive intrinsic kinetic energy as $T_{\\mathrm{int}}^{\\mathrm{naive}} = T - \\frac{P^2}{2Am}$ with $A = 2$ and $m = 1$.\n- Intrinsic geometry:\n  - Define the one-body density $\\rho(x) = \\sum_{i=0}^{A-1} |\\psi_i(x)|^2$. Define the center-of-mass position $X_{\\mathrm{cm}} = \\frac{1}{A} \\sum_n x_n \\rho(x_n) a$ and the intrinsic mean-square radius $\\langle r^2 \\rangle_{\\mathrm{int}} = \\frac{1}{A} \\sum_n (x_n - X_{\\mathrm{cm}})^2 \\rho(x_n) a$.\n- Lattice-dispersion correction:\n  - For the second-order Laplacian on a periodic grid, the plane-wave kinetic energy dispersion is $\\varepsilon_{\\mathrm{lat}}(k) = \\frac{2 - 2 \\cos(ka)}{2ma^2}$. Propose a dispersion-based correction for a uniform boost by subtracting $A \\varepsilon_{\\mathrm{lat}}(k_0)$ from the boosted total kinetic energy. Define $\\Delta T_{\\mathrm{int}}^{\\mathrm{disp}}(v) = [T(\\{\\psi_i^{(v)}\\}) - A \\varepsilon_{\\mathrm{lat}}(k_0)] - T(\\{\\psi_i^{(0)}\\})$.\n- Gauge-link (Peierls) correction:\n  - Propose a gauge-covariant kinetic energy operator consistent with a uniform boost by introducing a link factor $U = e^{-ik_0 a}$ and defining the link-corrected Laplacian acting on a boosted orbital $\\phi$ by\n    $$ (\\Delta_U \\phi)_n = \\frac{U \\phi_{n+1} - 2 \\phi_n + U^* \\phi_{n-1}}{a^2}. $$\n    The corresponding link-corrected boosted kinetic energy is $T_U[\\{\\psi_i^{(v)}\\}] = \\frac{1}{2m} \\sum_i \\sum_n \\psi_i^{(v)*}(x_n) \\left(-\\Delta_U \\psi_i^{(v)}\\right)(x_n) a$. Define $\\Delta T_{\\mathrm{int}}^{U}(v) = T_U(\\{\\psi_i^{(v)}\\}) - T(\\{\\psi_i^{(0)}\\})$.\n- Invariance metrics to compute for each test velocity $v$:\n  - The absolute change in intrinsic mean-square radius $|\\Delta \\langle r^2 \\rangle_{\\mathrm{int}}(v)| = |\\langle r^2 \\rangle_{\\mathrm{int}}^{(v)} - \\langle r^2 \\rangle_{\\mathrm{int}}^{(0)}|$.\n  - The spurious intrinsic kinetic change using the naive subtraction $\\Delta T_{\\mathrm{int}}^{\\mathrm{naive}}(v) = T_{\\mathrm{int}}^{\\mathrm{naive}}(\\{\\psi_i^{(v)}\\}) - T_{\\mathrm{int}}^{\\mathrm{naive}}(\\{\\psi_i^{(0)}\\})$.\n  - The dispersion-corrected intrinsic change $\\Delta T_{\\mathrm{int}}^{\\mathrm{disp}}(v)$ defined above.\n  - The gauge-link corrected intrinsic change $\\Delta T_{\\mathrm{int}}^{U}(v)$ defined above.\n- Test suite:\n  - Use the velocities $v \\in \\{0.0, 2.0, 8.0, 24.0\\}$. These cover a baseline case, a moderate boost, a stronger boost, and a near-Nyquist boost given $a = 0.125$ so that the Nyquist wavenumber is $\\pi/a \\approx 25.1327$.\n- Output specification:\n  - Your program must compute, for each test velocity $v$ in the order listed above, the quadruple of floats\n    $[\\left|\\Delta \\langle r^2 \\rangle_{\\mathrm{int}}(v)\\right|, \\Delta T_{\\mathrm{int}}^{\\mathrm{naive}}(v), \\Delta T_{\\mathrm{int}}^{\\mathrm{disp}}(v), \\Delta T_{\\mathrm{int}}^{U}(v)]$.\n  - Aggregate all results into a single flat list in the same order, resulting in a list of length $4 \\times 4 = 16$, and print exactly one line containing this flat list in square brackets with comma-separated values, for example `[result_1,result_2,...,result_16]`.\n- All returned values must be floats in these dimensionless units.\n\nYour implementation must be a complete, runnable program that performs all steps without any external input and adheres strictly to the output format requirement above.", "solution": "The problem requires the design and implementation of a numerical experiment to investigate the breaking of Galilean invariance by finite-difference discretizations, a crucial topic in computational many-body physics, particularly within the Time-Dependent Hartree-Fock (TDHF) framework. Galilean invariance dictates that the laws of physics are the same in all inertial reference frames. For an isolated, self-bound system like a nucleus, this implies that its intrinsic properties (e.g., size, binding energy) must be independent of its overall center-of-mass velocity. While this invariance holds for the continuous Schrödinger equation, standard numerical discretizations on a spatial lattice can violate it, introducing artifacts that depend on the system's velocity. This experiment quantifies these violations and tests two common correction schemes.\n\nWe will work in one spatial dimension ($x$) using dimensionless natural units where $\\hbar=1$ and the nucleon mass is $m=1$.\n\nFirst, we establish the computational environment. The system is defined on a uniform periodic grid of $N=512$ points spanning a length $L=64$. The grid spacing is thus $a = L/N = 64/512 = 0.125$. The grid points are $x_n = a(n - N/2)$ for $n \\in \\{0, 1, \\dots, N-1\\}$.\n\nThe bound system is modeled by a Slater determinant of $A=2$ nucleons occupying two orthonormal single-particle orbitals, $\\psi_0(x)$ and $\\psi_1(x)$. These are taken to be the ground and first excited states of a harmonic oscillator potential, with width parameter $b=2.0$:\n$$ \\psi_0(x) \\propto \\exp\\left(-\\frac{x^2}{2 b^2}\\right) $$\n$$ \\psi_1(x) \\propto \\frac{x}{b} \\exp\\left(-\\frac{x^2}{2 b^2}\\right) $$\nThese continuous functions are discretized on the grid, yielding arrays $\\psi_{i,n} = \\psi_i(x_n)$. They are then numerically orthonormalized with respect to the discrete inner product, which for two grid functions $\\phi_A$ and $\\phi_B$ is defined as $\\langle \\phi_A | \\phi_B \\rangle = \\sum_{n=0}^{N-1} \\phi_A^*(x_n) \\phi_B(x_n) a$.\n\nA Galilean boost with velocity $v$ is applied by transforming each stationary-state orbital $\\psi_i(x)$ into a moving one $\\psi_i^{(v)}(x)$ via multiplication by a phase factor:\n$$ \\psi_i^{(v)}(x) = e^{i k_0 x} \\psi_i(x) $$\nwhere $k_0 = m v = v$ is the boost momentum.\n\nKey physical observables are computed using discrete operators. The momentum operator $\\hat{p}$ and the Laplacian $\\Delta$ are approximated using second-order central finite differences with periodic boundary conditions:\n$$ (\\hat{p} \\phi)_n = -i \\frac{\\phi_{n+1} - \\phi_{n-1}}{2a} $$\n$$ (\\Delta \\phi)_n = \\frac{\\phi_{n+1} - 2\\phi_n + \\phi_{n-1}}{a^2} $$\nwhere $\\phi_{N} = \\phi_0$ and $\\phi_{-1} = \\phi_{N-1}$. The total kinetic energy $T$ and total momentum $P$ for the system of $A$ orbitals $\\{\\psi_i\\}$ are:\n$$ T[\\{\\psi_i\\}] = \\frac{1}{2m} \\sum_{i=0}^{A-1} \\sum_{n=0}^{N-1} \\psi_i^*(x_n) (-\\Delta \\psi_i)(x_n) a $$\n$$ P[\\{\\psi_i\\}] = \\sum_{i=0}^{A-1} \\sum_{n=0}^{N-1} \\psi_i^*(x_n) (\\hat{p} \\psi_i)(x_n) a $$\nWith $m=1$ and $A=2$. The \"naive\" intrinsic kinetic energy is obtained by subtracting the center-of-mass kinetic energy:\n$$ T_{\\mathrm{int}}^{\\mathrm{naive}} = T - \\frac{P^2}{2Am} $$\nIn the continuum, $T_{\\mathrm{int}}$ is invariant under a Galilean boost. Our goal is to test this on the lattice.\n\nIntrinsic geometric properties are derived from the one-body density $\\rho(x)$:\n$$ \\rho(x) = \\sum_{i=0}^{A-1} |\\psi_i(x)|^2 $$\nThe center-of-mass position $X_{\\mathrm{cm}}$ and the intrinsic mean-square radius $\\langle r^2 \\rangle_{\\mathrm{int}}$ are:\n$$ X_{\\mathrm{cm}} = \\frac{1}{A} \\sum_{n=0}^{N-1} x_n \\rho(x_n) a $$\n$$ \\langle r^2 \\rangle_{\\mathrm{int}} = \\frac{1}{A} \\sum_{n=0}^{N-1} (x_n - X_{\\mathrm{cm}})^2 \\rho(x_n) a $$\nA critical observation is that the boost operation does not change the density: $\\rho^{(v)}(x) = \\sum_i |e^{ik_0x}\\psi_i(x)|^2 = \\sum_i |\\psi_i(x)|^2 = \\rho^{(0)}(x)$. Consequently, any observable depending only on the density, such as $X_{\\mathrm{cm}}$ and $\\langle r^2 \\rangle_{\\mathrm{int}}$, must be exactly invariant. This provides a sanity check. The first metric, $|\\Delta \\langle r^2 \\rangle_{\\mathrm{int}}(v)| = | \\langle r^2 \\rangle_{\\mathrm{int}}^{(v)} - \\langle r^2 \\rangle_{\\mathrm{int}}^{(0)} |$, must therefore be zero.\n\nThe violation of Galilean invariance arises in the kinetic energy. We test two correction schemes.\n\n1.  **Lattice Dispersion Correction**: The kinetic energy of a plane wave $e^{ikx}$ on our lattice is not the continuum $k^2/(2m)$, but rather $\\varepsilon_{\\mathrm{lat}}(k) = \\frac{2 - 2\\cos(ka)}{2ma^2}$. This correction hypothesizes that the spurious energy comes from miscalculating the boost energy itself. It defines a corrected intrinsic energy change:\n    $$ \\Delta T_{\\mathrm{int}}^{\\mathrm{disp}}(v) = [T(\\{\\psi_i^{(v)}\\}) - A \\varepsilon_{\\mathrm{lat}}(k_0)] - T(\\{\\psi_i^{(0)}\\}) $$\n\n2.  **Gauge-Link (Peierls) Correction**: This is a more fundamental correction that modifies the kinetic operator to be \"gauge-covariant\" with respect to the boost. A link factor $U = e^{-ik_0a}$ is introduced into the finite difference stencil. The link-corrected Laplacian $\\Delta_U$, when acting on a boosted orbital $\\phi = \\psi_i^{(v)}$, is defined as:\n    $$ (\\Delta_U \\phi)_n = \\frac{U \\phi_{n+1} - 2\\phi_n + U^* \\phi_{n-1}}{a^2} $$\n    As can be shown by substitution, this operator satisfies the covariance relation $(\\Delta_U \\psi_i^{(v)})(x_n) = e^{ik_0x_n}(\\Delta \\psi_i)(x_n)$. The link-corrected kinetic energy is $T_U[\\{\\psi_i^{(v)}\\}] = \\sum_i \\langle \\psi_i^{(v)} | -\\Delta_U/(2m) | \\psi_i^{(v)} \\rangle$. The cancellation of phase factors leads to $T_U[\\{\\psi_i^{(v)}\\}] = T[\\{\\psi_i^{(0)}\\}]$. Therefore, the corresponding change $\\Delta T_{\\mathrm{int}}^{U}(v) = T_U(\\{\\psi_i^{(v)}\\}) - T(\\{\\psi_i^{(0)}\\})$ is theoretically expected to be zero, up to floating-point precision.\n\nThe computational procedure is as follows:\n1.  Initialize grid parameters and define the two initial orbitals, then discretize and numerically orthonormalize them.\n2.  Calculate the reference ($v=0$) values: $\\langle r^2 \\rangle_{\\mathrm{int}}^{(0)}$ and $T_{\\mathrm{int}}^{\\mathrm{naive},(0)} = T^{(0)}$. Note that for the symmetric initial state, $P^{(0)}=0$.\n3.  Loop through the test velocities $v \\in \\{0.0, 2.0, 8.0, 24.0\\}$.\n4.  For each non-zero $v$, create the boosted orbitals $\\psi_i^{(v)}$.\n5.  Calculate the four specified metrics:\n    a. $|\\Delta \\langle r^2 \\rangle_{\\mathrm{int}}(v)|$: The change in intrinsic size. Expected to be $0$.\n    b. $\\Delta T_{\\mathrm{int}}^{\\mathrm{naive}}(v) = (T^{(v)} - (P^{(v)})^2/(2A)) - T^{(0)}$: The spurious energy from the naive operator.\n    c. $\\Delta T_{\\mathrm{int}}^{\\mathrm{disp}}(v) = T^{(v)} - A\\,\\varepsilon_{\\mathrm{lat}}(k_0) - T^{(0)}$: The residual energy after dispersion correction.\n    d. $\\Delta T_{\\mathrm{int}}^{U}(v) = T_U(\\{\\psi_i^{(v)}\\}) - T^{(0)}$: The residual energy after gauge-link correction. Expected to be $0$.\n6.  Collect the resulting $4$ values for each of the $4$ velocities into a single flat list of $16$ numbers for the final output. The results will demonstrate the failure of the naive operator and compare the effectiveness of the two correction schemes.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Performs a numerical experiment to assess Galilean invariance\n    in a simplified TDHF setting.\n    \"\"\"\n    # 1. Setup Geometry and Grid\n    N = 512\n    L = 64.0\n    a = L / N\n    x = a * (np.arange(N) - N / 2)\n\n    # 2. Setup Bound System and Orbitals\n    b = 2.0\n    A = 2\n    m = 1.0\n\n    # Define unnormalized orbitals on the grid\n    psi0_unnormalized = np.exp(-x**2 / (2 * b**2))\n    psi1_unnormalized = (x / b) * np.exp(-x**2 / (2 * b**2))\n\n    # Normalize orbitals using the discrete inner product\n    norm0 = np.sqrt(a * np.sum(np.abs(psi0_unnormalized)**2))\n    psi0 = psi0_unnormalized / norm0\n    \n    norm1 = np.sqrt(a * np.sum(np.abs(psi1_unnormalized)**2))\n    psi1 = psi1_unnormalized / norm1\n    \n    # The set of stationary (unboosted) orbitals\n    psis_0 = [psi0.astype(np.complex128), psi1.astype(np.complex128)]\n\n    # 3. Setup Discrete Operators\n    def laplacian(phi, grid_spacing):\n        phi_p1 = np.roll(phi, -1)\n        phi_m1 = np.roll(phi, 1)\n        return (phi_p1 - 2 * phi + phi_m1) / grid_spacing**2\n\n    def momentum_op(phi, grid_spacing):\n        phi_p1 = np.roll(phi, -1)\n        phi_m1 = np.roll(phi, 1)\n        return -1j * (phi_p1 - phi_m1) / (2 * grid_spacing)\n\n    def laplacian_U(phi, grid_spacing, U):\n        phi_p1 = np.roll(phi, -1)\n        phi_m1 = np.roll(phi, 1)\n        U_conj = np.conj(U)\n        return (U * phi_p1 - 2 * phi + U_conj * phi_m1) / grid_spacing**2\n        \n    # 4. Setup Observable Calculations\n    def calculate_T(psis, grid_spacing, mass):\n        ke = 0.0\n        for psi in psis:\n            ke += a * np.sum(np.conj(psi) * (-laplacian(psi, grid_spacing)))\n        return ke / (2 * mass)\n\n    def calculate_P(psis, grid_spacing):\n        mom = 0.0\n        for psi in psis:\n            mom += a * np.sum(np.conj(psi) * momentum_op(psi, grid_spacing))\n        return mom.real # Should be real for Hermitian op expectation\n\n    def calculate_density(psis):\n        rho = np.zeros(N, dtype=float)\n        for psi in psis:\n            rho += np.abs(psi)**2\n        return rho\n\n    def calculate_Xcm(rho, x_grid, grid_spacing, num_particles):\n        return (1.0 / num_particles) * grid_spacing * np.sum(x_grid * rho)\n\n    def calculate_r2_int(rho, x_grid, grid_spacing, num_particles, x_cm):\n        return (1.0 / num_particles) * grid_spacing * np.sum((x_grid - x_cm)**2 * rho)\n\n    def calculate_T_U(psis_v, grid_spacing, mass, k0):\n        ke_U = 0.0\n        U_link = np.exp(-1j * k0 * grid_spacing)\n        for psi_v in psis_v:\n             # The operator is applied directly as per the problem statement\n             ke_U += a * np.sum(np.conj(psi_v) * (-laplacian_U(psi_v, grid_spacing, U_link)))\n        return ke_U / (2 * mass)\n\n    # Calculate reference values for v=0\n    T_0 = calculate_T(psis_0, a, m)\n    P_0 = calculate_P(psis_0, a) # Should be ~0 due to symmetry\n    T_int_naive_0 = T_0 - P_0**2 / (2 * A * m)\n\n    rho_0 = calculate_density(psis_0)\n    Xcm_0 = calculate_Xcm(rho_0, x, a, A) # Should be ~0\n    r2_int_0 = calculate_r2_int(rho_0, x, a, A, Xcm_0)\n\n    # 5. Main Loop over Test Velocities\n    test_velocities = [0.0, 2.0, 8.0, 24.0]\n    all_results = []\n\n    for v in test_velocities:\n        if v == 0.0:\n            all_results.extend([0.0, 0.0, 0.0, 0.0])\n            continue\n\n        k0 = m * v\n        \n        # Create boosted orbitals\n        boost_phase = np.exp(1j * k0 * x)\n        psis_v = [psi * boost_phase for psi in psis_0]\n\n        # --- Metric 1: Change in intrinsic mean-square radius ---\n        rho_v = calculate_density(psis_v)\n        Xcm_v = calculate_Xcm(rho_v, x, a, A)\n        r2_int_v = calculate_r2_int(rho_v, x, a, A, Xcm_v)\n        delta_r2_int = np.abs(r2_int_v - r2_int_0)\n\n        # --- Metric 2: Naive intrinsic kinetic energy change ---\n        T_v = calculate_T(psis_v, a, m)\n        P_v = calculate_P(psis_v, a)\n        T_int_naive_v = T_v - P_v**2 / (2 * A * m)\n        delta_T_int_naive = T_int_naive_v - T_int_naive_0\n\n        # --- Metric 3: Dispersion-corrected intrinsic change ---\n        eps_lat_k0 = (2.0 - 2.0 * np.cos(k0 * a)) / (2 * m * a**2)\n        delta_T_int_disp = (T_v - A * eps_lat_k0) - T_0\n\n        # --- Metric 4: Gauge-link corrected intrinsic change ---\n        T_U_v = calculate_T_U(psis_v, a, m, k0)\n        delta_T_int_U = T_U_v - T_0\n        \n        # Real part is taken as energy values should be real.\n        # Small imaginary parts can arise from float precision errors\n        quadruple = [\n            delta_r2_int,\n            delta_T_int_naive.real,\n            delta_T_int_disp.real,\n            delta_T_int_U.real,\n        ]\n        all_results.extend(quadruple)\n    \n    # 6. Final Output\n    # The format must be a flat list of floats.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3577472"}]}