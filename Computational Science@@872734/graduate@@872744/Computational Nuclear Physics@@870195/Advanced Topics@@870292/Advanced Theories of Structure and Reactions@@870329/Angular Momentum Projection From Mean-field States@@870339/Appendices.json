{"hands_on_practices": [{"introduction": "The foundation of numerical angular momentum projection is the replacement of continuous integrals over the rotation group with discrete sums. A critical first step in any such calculation is determining the appropriate discretization, or mesh, for the Euler angles. This exercise challenges you to determine the minimum number of mesh points required to exactly integrate the angular dependence for all states up to a maximum angular momentum $J_{\\text{max}}$, connecting directly to the Nyquist-Shannon sampling theorem and the problem of aliasing. By working through this, you will gain a fundamental understanding of how to set up a numerically exact projection grid, a prerequisite for any reliable calculation. [@problem_id:3542253]", "problem": "Consider angular momentum projection from a mean-field many-body state in computational nuclear physics. The projection operator onto total angular momentum $J$ and laboratory-frame and intrinsic-frame projections $M$ and $K$ is defined by\n$$\n\\hat{P}^{J}_{MK} = \\frac{2J+1}{8\\pi^{2}} \\int_{0}^{2\\pi}\\!\\!\\mathrm{d}\\alpha \\int_{0}^{\\pi}\\!\\!\\sin\\beta\\,\\mathrm{d}\\beta \\int_{0}^{2\\pi}\\!\\!\\mathrm{d}\\gamma \\; \\mathcal{D}^{J*}_{MK}(\\alpha,\\beta,\\gamma) \\, \\hat{R}(\\alpha,\\beta,\\gamma),\n$$\nwhere $\\mathcal{D}^{J}_{MK}(\\alpha,\\beta,\\gamma)$ is the Wigner $D$-function and $\\hat{R}(\\alpha,\\beta,\\gamma)$ is the rotation operator. It is a well-tested fact that the Wigner $D$-function factorizes as\n$$\n\\mathcal{D}^{J}_{MK}(\\alpha,\\beta,\\gamma) = \\exp(-\\mathrm{i} M \\alpha)\\, d^{J}_{MK}(\\beta)\\, \\exp(-\\mathrm{i} K \\gamma),\n$$\nand that $\\alpha$ and $\\gamma$ are $2\\pi$-periodic angles measured in radians. In practical computations, the integrals over $\\alpha$ and $\\gamma$ are evaluated with equidistant meshes $\\{\\alpha_{k}\\}_{k=0}^{N_{\\alpha}-1}$ and $\\{\\gamma_{\\ell}\\}_{\\ell=0}^{N_{\\gamma}-1}$ with $\\alpha_{k} = 2\\pi k / N_{\\alpha}$ and $\\gamma_{\\ell} = 2\\pi \\ell / N_{\\gamma}$, using the trapezoidal rule.\n\nAssume you wish to exactly project all angular momenta up to a fixed maximum $J_{\\text{max}}$, i.e., all $J$ with $0 \\leq J \\leq J_{\\text{max}}$, for arbitrary mean-field states whose Fourier content in $\\alpha$ and $\\gamma$ does not exceed the harmonics implied by the $\\mathcal{D}^{J}_{MK}$ factors. Starting from the orthogonality of complex exponentials on $[0,2\\pi)$ and the discrete orthogonality properties of equidistant quadrature on the circle, determine the minimal numbers of mesh points $N_{\\alpha}^{\\text{min}}$ and $N_{\\gamma}^{\\text{min}}$ that guarantee the discrete sums over $\\alpha$ and $\\gamma$ reproduce exactly the corresponding continuous integrals for all $M, K \\in \\{-J,-J+1,\\dots,J\\}$ and all $J \\leq J_{\\text{max}}$.\n\nThen, explain the consequences of under-sampling (aliasing) when $N_{\\alpha}$ and/or $N_{\\gamma}$ are chosen below these minimal values, focusing on how distinct Fourier components in $M$ and $K$ can become indistinguishable in the discrete sums, how this affects the projected norm kernels and energies, and how such errors scale with the choice of $N_{\\alpha}$ and $N_{\\gamma}$.\n\nYour final answer must be the minimal $N_{\\alpha}^{\\text{min}}$ and $N_{\\gamma}^{\\text{min}}$ expressed as closed-form expressions in terms of $J_{\\text{max}}$. No numerical rounding is required.", "solution": "The user wants me to solve a problem related to angular momentum projection in computational nuclear physics.\n\n### 1. Problem Validation\n\n#### Step 1: Extract Givens\n\n-   **Projection Operator**: $\\hat{P}^{J}_{MK} = \\frac{2J+1}{8\\pi^{2}} \\int_{0}^{2\\pi}\\!\\!\\mathrm{d}\\alpha \\int_{0}^{\\pi}\\!\\!\\sin\\beta\\,\\mathrm{d}\\beta \\int_{0}^{2\\pi}\\!\\!\\mathrm{d}\\gamma \\; \\mathcal{D}^{J*}_{MK}(\\alpha,\\beta,\\gamma) \\, \\hat{R}(\\alpha,\\beta,\\gamma)$.\n-   **Wigner D-function factorization**: $\\mathcal{D}^{J}_{MK}(\\alpha,\\beta,\\gamma) = \\exp(-\\mathrm{i} M \\alpha)\\, d^{J}_{MK}(\\beta)\\, \\exp(-\\mathrm{i} K \\gamma)$, where `i` is the imaginary unit.\n-   **Periodicity of Euler angles**: $\\alpha$ and $\\gamma$ are $2\\pi$-periodic angles.\n-   **Numerical Integration Scheme**: The integrals over $\\alpha$ and $\\gamma$ are evaluated with the trapezoidal rule on equidistant meshes.\n-   **Mesh definitions**: $\\{\\alpha_{k}\\}_{k=0}^{N_{\\alpha}-1}$ with $\\alpha_{k} = 2\\pi k / N_{\\alpha}$ and $\\{\\gamma_{\\ell}\\}_{\\ell=0}^{N_{\\gamma}-1}$ with $\\gamma_{\\ell} = 2\\pi \\ell / N_{\\gamma}$.\n-   **Projection Goal**: Project all angular momenta $J$ such that $0 \\leq J \\leq J_{\\text{max}}$. This implies all corresponding projections $M, K \\in \\{-J, -J+1, \\dots, J\\}$ are considered.\n-   **State Property**: The mean-field states are arbitrary, but their Fourier content in $\\alpha$ and $\\gamma$ does not exceed the harmonics implied by the $\\mathcal{D}^{J}_{MK}$ factors for $J \\le J_{\\text{max}}$.\n-   **Tasks**:\n    1.  Determine the minimal numbers of mesh points $N_{\\alpha}^{\\text{min}}$ and $N_{\\gamma}^{\\text{min}}$ for exact projection.\n    2.  Explain the consequences of under-sampling (aliasing).\n\n#### Step 2: Validate Using Extracted Givens\n\n-   **Scientifically Grounded**: The problem is set in the context of computational nuclear structure physics, specifically the Peierls-Yoccoz projection method. The definitions of the projection operator, Wigner D-functions, and rotation operator are standard in quantum mechanics. The use of numerical quadrature (trapezoidal rule) for periodic functions is a standard technique in numerical analysis. The concepts are all well-established.\n-   **Well-Posed**: The problem is well-posed. It asks for the minimum number of grid points required to satisfy a well-defined mathematical condition (exactness of a numerical integral for a class of functions with known Fourier properties). The simplifying assumption about the Fourier content of the mean-field state, while an idealization, makes the problem self-contained and solvable. A unique, stable, and meaningful solution exists.\n-   **Objective**: The problem is stated in precise mathematical and physical language, free of subjectivity or ambiguity. The terms are standard in the field.\n\n#### Step 3: Verdict and Action\n\nThe problem is valid. I will proceed with the detailed solution.\n\n### 2. Solution\n\nThe core of the problem is to determine the conditions under which the trapezoidal rule exactly reproduces the continuous integral for a periodic function. Let's consider a generic $2\\pi$-periodic function $f(\\theta)$ with a Fourier series expansion $f(\\theta) = \\sum_{n=-\\infty}^{\\infty} c_n e^{\\mathrm{i}n\\theta}$. The exact integral is given by the zeroth Fourier coefficient:\n$$ \\int_0^{2\\pi} f(\\theta) \\, \\mathrm{d}\\theta = \\int_0^{2\\pi} \\sum_{n=-\\infty}^{\\infty} c_n e^{\\mathrm{i}n\\theta} \\, \\mathrm{d}\\theta = 2\\pi c_0 $$\nThe trapezoidal rule approximation with $N$ equidistant points $\\theta_k = 2\\pi k/N$ for $k \\in \\{0, 1, ..., N-1\\}$ is:\n$$ S_N = \\frac{2\\pi}{N} \\sum_{k=0}^{N-1} f(\\theta_k) = \\frac{2\\pi}{N} \\sum_{k=0}^{N-1} \\sum_{n=-\\infty}^{\\infty} c_n e^{\\mathrm{i}n(2\\pi k/N)} = \\sum_{n=-\\infty}^{\\infty} c_n \\left( \\frac{2\\pi}{N} \\sum_{k=0}^{N-1} (e^{\\mathrm{i}2\\pi n/N})^k \\right) $$\nThe geometric sum in the parenthesis evaluates to $N$ if $e^{\\mathrm{i}2\\pi n/N}=1$ (i.e., if $n$ is an integer multiple of $N$), and to $0$ otherwise. Thus, the discrete sum becomes:\n$$ S_N = 2\\pi \\sum_{p=-\\infty}^{\\infty} c_{pN} = 2\\pi (c_0 + c_N + c_{-N} + c_{2N} + c_{-2N} + \\dots) $$\nThis phenomenon, where higher-frequency components $c_{pN}$ for $p \\neq 0$ contribute to the computed value of the zeroth component, is known as aliasing. For the numerical integral $S_N$ to be exactly equal to the continuous integral $2\\pi c_0$, all aliased terms must vanish. If the function $f(\\theta)$ is band-limited, meaning its Fourier coefficients $c_n$ are zero for $|n| > n_{\\text{max}}$, the condition for exactness becomes that no non-zero multiple of $N$ falls within the range $[-n_{\\text{max}}, n_{\\text{max}}]$. This is satisfied if $N > n_{\\text{max}}$. The minimum integer number of points is thus $N = n_{\\text{max}} + 1$.\n\nWe now apply this to the projection integrals. The quantities computed in practice are matrix elements like $\\langle\\Phi|\\hat{O}\\hat{P}^J_{MK}|\\Phi\\rangle$, where $\\hat{O}$ is typically the identity or the Hamiltonian operator. The integrand depends on the Euler angles $(\\alpha, \\beta, \\gamma)$. Let's analyze the dependence on $\\alpha$ and $\\gamma$. The integrand is of the form $I(\\alpha, \\beta, \\gamma) = \\mathcal{D}^{J*}_{MK}(\\alpha, \\beta, \\gamma) \\langle\\Phi|\\hat{O}\\hat{R}(\\alpha, \\beta, \\gamma)|\\Phi\\rangle$.\n\nUsing the factorization of the Wigner function and the rotation operator $\\hat{R}(\\alpha,\\beta,\\gamma) = e^{-\\mathrm{i}\\alpha\\hat{J}_z}e^{-\\mathrm{i}\\beta\\hat{J}_y}e^{-\\mathrm{i}\\gamma\\hat{J}_z}$, the integrand can be written as:\n$$ I(\\alpha, \\beta, \\gamma) = e^{\\mathrm{i}M\\alpha} d^{J*}_{MK}(\\beta) e^{\\mathrm{i}K\\gamma} \\langle\\Phi|\\hat{O} e^{-\\mathrm{i}\\alpha\\hat{J}_z}e^{-\\mathrm{i}\\beta\\hat{J}_y}e^{-\\mathrm{i}\\gamma\\hat{J}_z}|\\Phi\\rangle $$\nThe state-dependent overlap kernel $h(\\alpha, \\beta, \\gamma) = \\langle\\Phi|\\hat{O}\\hat{R}(\\alpha, \\beta, \\gamma)|\\Phi\\rangle$ is a periodic function of $\\alpha$ and $\\gamma$ and can be expanded in a Fourier series:\n$$ h(\\alpha, \\beta, \\gamma) = \\sum_{m',k'} h_{m'k'}(\\beta) e^{-\\mathrm{i}m'\\alpha} e^{-\\mathrm{i}k'\\gamma} $$\nThe problem states that the Fourier content of the state does not exceed the harmonics implied by $\\mathcal{D}^{J}_{MK}$ factors up to $J_{\\text{max}}$. This is a simplifying assumption that we interpret to mean that the Fourier series for the kernel $h$ is band-limited by $J_{\\text{max}}$, i.e., the sums are restricted to $|m'| \\le J_{\\text{max}}$ and $|k'| \\le J_{\\text{max}}$. The quantum numbers $M, K, m', k'$ are either all integers (for an even number of fermions) or all half-integers (for an odd number of fermions). In either case, the exponents in the Fourier series, such as $M-m'$, are always integers.\n\nFirst, let's determine $N_{\\alpha}^{\\text{min}}$. The part of the integrand depending on $\\alpha$ is:\n$$ f(\\alpha) = e^{\\mathrm{i}M\\alpha} \\sum_{m'} h_{m'k'}(\\beta) e^{-\\mathrm{i}m'\\alpha} = \\sum_{m'} h_{m'k'}(\\beta) e^{\\mathrm{i}(M-m')\\alpha} $$\nWe need to evaluate this for all projections up to $J_{\\text{max}}$, so $M$ takes values in $[-J, J]$ for all $J \\le J_{\\text{max}}$. The maximum absolute value of $M$ is $|M|_{\\text{max}} = J_{\\text{max}}$. Similarly, based on our interpretation of the problem statement, the maximum absolute value of the state's Fourier component is $|m'|_{\\text{max}} = J_{\\text{max}}$.\nThe integer frequency exponent for the $\\alpha$-integration is $n = M-m'$. The maximum value of this exponent is:\n$$ n_{\\text{max}} = M_{\\text{max}} - m'_{\\text{min}} = J_{\\text{max}} - (-J_{\\text{max}}) = 2J_{\\text{max}} $$\nThe minimum value is $n_{\\text{min}} = M_{\\text{min}} - m'_{\\text{max}} = -J_{\\text{max}} - J_{\\text{max}} = -2J_{\\text{max}}$.\nThus, the Fourier spectrum of the integrand is non-zero only for integer frequencies $n$ in the range $[-2J_{\\text{max}}, 2J_{\\text{max}}]$. The highest frequency to resolve is $n_{\\text{max}} = 2J_{\\text{max}}$.\nFor the trapezoidal sum to be exact, the number of points $N_{\\alpha}$ must be strictly greater than this highest frequency:\n$$ N_{\\alpha} > 2J_{\\text{max}} $$\nThe minimal integer number of points is therefore:\n$$ N_{\\alpha}^{\\text{min}} = 2J_{\\text{max}} + 1 $$\n\nSecond, we determine $N_{\\gamma}^{\\text{min}}$ with an analogous argument. The part of the integrand depending on $\\gamma$ is:\n$$ g(\\gamma) = e^{\\mathrm{i}K\\gamma} \\sum_{k'} h_{m'k'}(\\beta) e^{-\\mathrm{i}k'\\gamma} = \\sum_{k'} h_{m'k'}(\\beta) e^{\\mathrm{i}(K-k')\\gamma} $$\nThe projection quantum number $K$ has a maximum absolute value of $|K|_{\\text{max}} = J_{\\text{max}}$. The state's Fourier component $k'$ is assumed to have a maximum absolute value of $|k'|_{\\text{max}} = J_{\\text{max}}$.\nThe integer frequency exponent for the $\\gamma$-integration is $p = K-k'$. The maximum frequency is $p_{\\text{max}} = |K-k'|_{\\text{max}} = |K|_{\\text{max}} + |k'|_{\\text{max}} = 2J_{\\text{max}}$.\nThe condition for exact integration is $N_{\\gamma} > 2J_{\\text{max}}$.\nThe minimal integer number of points is:\n$$ N_{\\gamma}^{\\text{min}} = 2J_{\\text{max}} + 1 $$\n\nFinally, we explain the consequences of under-sampling. If $N_{\\alpha} < N_{\\alpha}^{\\text{min}}$ (i.e., $N_{\\alpha} \\le 2J_{\\text{max}}$), the aliasing formula $S_{N_\\alpha} = 2\\pi \\sum_p c_{pN_{\\alpha}}$ shows that the numerical integral will be contaminated. The calculated value for the integral does not isolate the true $n=0$ component. Instead, it sums the true value with all other Fourier components $c_n$ where the frequency $n = M-m'$ is a non-zero multiple of $N_{\\alpha}$.\nFor example, a physical component in the mean-field state with quantum number $m'$ will be indistinguishable from a component with $m'' = m' - pN_{\\alpha}$ for any integer $p$. When projecting onto a state with a specific lab-frame projection $M$, the numerical procedure will incorrectly mix in contributions from state components with $z$-projections $m' = M - pN_{\\alpha}$.\n\nThis has severe consequences for the computed physical observables:\n1.  **Loss of Orthogonality**: The projected states $|\\Psi^J_{MK}\\rangle$ are no longer proper-spanned eigenstates of $\\hat{J}^2$ and $\\hat{J}_z$. The numerically computed norm matrix $\\langle\\Psi^{J'}_{M'K'}|\\Psi^J_{MK}\\rangle$ will show non-zero overlaps for $J' \\neq J$ or $M' \\neq M$, violating the fundamental orthogonality of angular momentum eigenstates.\n2.  **Incorrect Norm and Hamiltonian Kernels**: The matrices for the norm, $N_{K'K}^J = \\langle\\Phi|\\hat{P}^J_{K'K}|\\Phi\\rangle$, and Hamiltonian, $H_{K'K}^J = \\langle\\Phi|\\hat{H}\\hat{P}^J_{K'K}|\\Phi\\rangle$, will be contaminated by aliased components. For instance, the calculated value for $N_{K'K}^J$ will erroneously include pieces of $N_{K''K}^J$ where $K'' = K' \\pmod{N_\\alpha}$.\n3.  **Inaccurate Energies and Wave Functions**: The projected energies and wave functions are obtained by solving the generalized eigenvalue problem $H^J c^J = E^J N^J c^J$. Since the matrices $H^J$ and $N^J$ are incorrect due to aliasing, the resulting eigenvalues (energies $E^J$) and eigenvectors (mixing coefficients $c^J$) will be inaccurate.\n4.  **Scaling of Errors**: The magnitude of the aliasing error depends on the amplitude of the high-frequency components in the state overlap kernel. In a realistic nuclear mean-field state, the amplitudes of components with high intrinsic angular momentum projections usually decay. The dominant error term will come from the first aliased component, e.g., the one corresponding to Fourier coefficient $c_{N_\\alpha}$. The error can be significant if the grid is severely undersampled, for instance if $N_\\alpha \\approx J_{\\text{max}}$, as many harmonics will be folded back into the fundamental frequency band. Choosing $N_\\alpha = 2J_{\\text{max}}$ is a particularly poor choice, as the highest frequency component $n = 2J_{\\text{max}}$ is aliased directly onto the $n=0$ component, causing a large error.", "answer": "$$\n\\boxed{\n\\begin{pmatrix} N_{\\alpha}^{\\text{min}} = 2J_{\\text{max}} + 1 & N_{\\gamma}^{\\text{min}} = 2J_{\\text{max}} + 1 \\end{pmatrix}\n}\n$$", "id": "3542253"}, {"introduction": "While the first practice establishes a theoretical minimum for the integration mesh, realistic overlap kernels from complex mean-field states often require finer grids to achieve accurate results. Instead of using a dense, uniform mesh, which is computationally expensive, a more efficient approach is to adaptively refine the grid only where needed. This hands-on exercise guides you through designing an adaptive quadrature scheme that iteratively improves the integration accuracy by refining the mesh in the dimension where the integrand varies most rapidly. Mastering this technique is key to performing efficient and reliable convergence tests for projected observables in practical research scenarios. [@problem_id:3542290]", "problem": "You are tasked with designing, implementing, and validating a convergence-testing strategy for angular-momentum projected observables computed by numerical integration over the three Euler angles. Consider the angular-momentum projection of a mean-field state onto good total angular momentum. Start from the operator-level definition of the projection operator\n$$\n\\hat{P}^{J}_{MK} = \\frac{2J+1}{8\\pi^2} \\int d\\Omega \\, \\mathcal{D}^{J}_{MK}(\\Omega)^{\\ast} \\, \\hat{R}(\\Omega),\n$$\nwhere $J$ is the total angular momentum, $M$ and $K$ are its projections, $\\hat{R}(\\Omega)$ is the rotation operator by the Euler angles $\\Omega \\equiv (\\alpha,\\beta,\\gamma)$ with the invariant measure\n$$\nd\\Omega = d\\alpha \\; \\sin\\beta \\; d\\beta \\; d\\gamma,\n$$\nand $\\mathcal{D}^{J}_{MK}(\\Omega)$ is the Wigner rotation matrix. The projected norm kernel for a general mean-field state $\\lvert \\Phi \\rangle$ is\n$$\n\\mathcal{N}^{J}_{MK} = \\langle \\Phi \\lvert \\hat{P}^{J}_{MK} \\rvert \\Phi \\rangle = \\frac{2J+1}{8\\pi^2} \\int d\\Omega \\, \\mathcal{D}^{J}_{MK}(\\Omega)^{\\ast} \\, \\langle \\Phi \\lvert \\hat{R}(\\Omega) \\rvert \\Phi \\rangle.\n$$\nFor this assignment, specialize to $M=K=0$ and model the overlap kernel by a smooth, factorized function\n$$\nn(\\Omega) \\equiv \\langle \\Phi \\lvert \\hat{R}(\\Omega) \\rvert \\Phi \\rangle = \\exp\\big(\\kappa \\cos\\beta\\big)\\, \\exp\\big(\\rho \\cos\\alpha\\big)\\, \\exp\\big(\\sigma \\cos\\gamma\\big),\n$$\nwhere $\\kappa \\ge 0$, $\\rho \\ge 0$, and $\\sigma \\ge 0$ are real parameters. Use the fact that for $M=K=0$ one has $\\mathcal{D}^{J}_{00}(\\alpha,\\beta,\\gamma) = P_{J}(\\cos\\beta)$, where $P_J$ is the Legendre polynomial of degree $J$.\n\nYour objective is to:\n- Derive the exact, closed-form expression (in terms of well-known special functions) for the projected norm\n$$\n\\mathcal{N}^{J} \\equiv \\mathcal{N}^{J}_{00} = \\frac{2J+1}{8\\pi^2} \\int_{0}^{2\\pi} d\\alpha \\int_{0}^{\\pi} \\sin\\beta \\, d\\beta \\int_{0}^{2\\pi} d\\gamma \\; P_{J}(\\cos\\beta)\\, \\exp(\\kappa \\cos\\beta)\\, \\exp(\\rho \\cos\\alpha)\\, \\exp(\\sigma \\cos\\gamma).\n$$\n- Construct a numerical integrator for $\\mathcal{N}^{J}$ using a discrete mesh over the Euler angles with the following quadrature rules:\n  1. For $\\alpha \\in [0,2\\pi)$ and $\\gamma \\in [0,2\\pi)$, use the uniform trapezoidal rule with $N_{\\alpha}$ and $N_{\\gamma}$ equispaced nodes and constant weights, respectively. The angle unit must be radians.\n  2. For $\\beta \\in [0,\\pi]$, use Gauss–Legendre quadrature in the transformed variable $x = \\cos\\beta \\in [-1,1]$, so that\n     $$\n     \\int_{0}^{\\pi} \\sin\\beta \\, g(\\cos\\beta) \\, d\\beta = \\int_{-1}^{1} g(x) \\, dx,\n     $$\n     where the Gauss–Legendre nodes and weights are used to approximate the integral in $x$ with $N_{\\beta}$ nodes.\n- Design a convergence-testing procedure that adaptively refines the Euler-angle meshes by doubling $N_{\\alpha}$, $N_{\\beta}$, or $N_{\\gamma}$ in whichever dimension currently produces the largest change in the projected observable. Use a practical stopping criterion based on the maximum relative change between the current estimate and the estimate obtained by doubling in each individual dimension. Specifically, terminate refinement when the maximum of these three one-step relative changes is strictly less than a user-specified tolerance $\\varepsilon$.\n- For validation, compare the final numerical estimate against the exact expression to compute an a posteriori error. When the exact value magnitude is larger than $10^{-14}$, report the relative error; otherwise, report the absolute error.\n\nImplementation details and constraints:\n- The numerical integration must be performed in radians.\n- The program must be self-contained and must not require user input.\n- You must implement the adaptive refinement described above. Start the refinement from $N_{\\alpha}=N_{\\beta}=N_{\\gamma}=4$ and at each step double only the single dimension corresponding to the largest one-step relative change. Stop when the stopping criterion is met or when a specified maximum $N$ in any dimension is reached.\n- Use only standard scientific functions and quadrature rules as detailed above; do not use any pre-packaged angular momentum projection routines.\n\nProvide exact expressions using well-known special functions as needed. Base your derivations on the fundamental definitions given and on well-tested identities for orthogonal polynomials and special functions, but do not shortcut the derivation to the final expression without justification.\n\nTest suite:\nImplement your program to run the following five test cases. For each case, use the given parameters $(J,\\kappa,\\rho,\\sigma)$, stopping tolerance $\\varepsilon$, and maximum mesh sizes $(N_{\\alpha}^{\\max},N_{\\beta}^{\\max},N_{\\gamma}^{\\max})$. In all cases, angles are in radians.\n\n- Case 1 (baseline smooth): $(J,\\kappa,\\rho,\\sigma) = (0, 0.5, 0.5, 0.5)$, $\\varepsilon = 10^{-9}$, $(N_{\\alpha}^{\\max},N_{\\beta}^{\\max},N_{\\gamma}^{\\max}) = (256,256,256)$.\n- Case 2 (large $J$-oscillations in $\\beta$): $(J,\\kappa,\\rho,\\sigma) = (6, 8.0, 1.0, 1.5)$, $\\varepsilon = 10^{-8}$, $(N_{\\alpha}^{\\max},N_{\\beta}^{\\max},N_{\\gamma}^{\\max}) = (256,512,256)$.\n- Case 3 (sharp structure in $\\alpha$): $(J,\\kappa,\\rho,\\sigma) = (4, 1.0, 6.0, 0.0)$, $\\varepsilon = 10^{-8}$, $(N_{\\alpha}^{\\max},N_{\\beta}^{\\max},N_{\\gamma}^{\\max}) = (512,256,256)$.\n- Case 4 (simultaneously sharp in all angles): $(J,\\kappa,\\rho,\\sigma) = (10, 12.0, 3.0, 3.0)$, $\\varepsilon = 10^{-7}$, $(N_{\\alpha}^{\\max},N_{\\beta}^{\\max},N_{\\gamma}^{\\max}) = (512,512,512)$.\n- Case 5 (nearly flat in $\\beta$, very sharp in $\\alpha$ and $\\gamma$): $(J,\\kappa,\\rho,\\sigma) = (2, 0.01, 10.0, 10.0)$, $\\varepsilon = 10^{-9}$, $(N_{\\alpha}^{\\max},N_{\\beta}^{\\max},N_{\\gamma}^{\\max}) = (1024,512,1024)$.\n\nFinal output specification:\n- For each test case, compute the final numerical estimate using the adaptive procedure and then compute the error with respect to the exact expression as specified above.\n- Your program should produce a single line of output containing a Python-style list with five floating-point numbers, each being the error for the corresponding test case in the order listed above. The line must be formatted exactly as a comma-separated list enclosed in square brackets, for example: \"[e1,e2,e3,e4,e5]\".", "solution": "The problem posed is to derive an exact expression for a specific angular-momentum projected norm, construct an adaptive numerical integrator for it, and validate the numerical result against the exact one for a suite of test cases. The problem is well-defined, scientifically sound, and computationally tractable. We proceed with the derivation and implementation as requested.\n\n### 1. Analytical Derivation of the Projected Norm\n\nThe projected norm to be calculated is given by the integral:\n$$\n\\mathcal{N}^{J} = \\frac{2J+1}{8\\pi^2} \\int_{0}^{2\\pi} d\\alpha \\int_{0}^{\\pi} \\sin\\beta \\, d\\beta \\int_{0}^{2\\pi} d\\gamma \\; P_{J}(\\cos\\beta)\\, \\exp(\\kappa \\cos\\beta)\\, \\exp(\\rho \\cos\\alpha)\\, \\exp(\\sigma \\cos\\gamma)\n$$\nwhere $J$, $\\kappa$, $\\rho$, and $\\sigma$ are non-negative real parameters, and $P_J(x)$ is the Legendre polynomial of degree $J$. The integrand is separable with respect to the three Euler angles $\\alpha$, $\\beta$, and $\\gamma$. Therefore, the triple integral can be factored into a product of three one-dimensional integrals:\n$$\n\\mathcal{N}^{J} = \\frac{2J+1}{8\\pi^2} \\left[ \\int_{0}^{2\\pi} \\exp(\\rho \\cos\\alpha) \\, d\\alpha \\right] \\left[ \\int_{0}^{\\pi} P_{J}(\\cos\\beta) \\exp(\\kappa \\cos\\beta) \\sin\\beta \\, d\\beta \\right] \\left[ \\int_{0}^{2\\pi} \\exp(\\sigma \\cos\\gamma) \\, d\\gamma \\right]\n$$\nWe evaluate each of these integrals separately.\n\n**Integrals over $\\alpha$ and $\\gamma$**\n\nThe integrals over $\\alpha$ and $\\gamma$ are of the same form. Consider the integral over $\\alpha$:\n$$\nI_\\alpha = \\int_{0}^{2\\pi} \\exp(\\rho \\cos\\alpha) \\, d\\alpha\n$$\nThis integral is a standard representation of the modified Bessel function of the first kind of order zero, $I_0(z)$, given by the identity:\n$$\nI_0(z) = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\exp(z \\cos\\theta) \\, d\\theta\n$$\nThus, we have:\n$$\nI_\\alpha = 2\\pi I_0(\\rho)\n$$\nBy identical reasoning, the integral over $\\gamma$ is:\n$$\nI_\\gamma = \\int_{0}^{2\\pi} \\exp(\\sigma \\cos\\gamma) \\, d\\gamma = 2\\pi I_0(\\sigma)\n$$\n\n**Integral over $\\beta$**\n\nThe integral over $\\beta$ is:\n$$\nI_\\beta = \\int_{0}^{\\pi} P_{J}(\\cos\\beta) \\exp(\\kappa \\cos\\beta) \\sin\\beta \\, d\\beta\n$$\nWe perform a change of variables $x = \\cos\\beta$, which implies $dx = -\\sin\\beta \\, d\\beta$. The integration limits $\\beta \\in [0, \\pi]$ become $x \\in [1, -1]$.\n$$\nI_\\beta = \\int_{1}^{-1} P_{J}(x) \\exp(\\kappa x) (-dx) = \\int_{-1}^{1} P_{J}(x) \\exp(\\kappa x) \\, dx\n$$\nThis integral can be evaluated by leveraging the expansion of an exponential function in the basis of Legendre polynomials:\n$$\ne^{zx} = \\sum_{l=0}^{\\infty} (2l+1) i_l(z) P_l(x)\n$$\nwhere $i_l(z)$ is the modified spherical Bessel function of the first kind of order $l$. Using the orthogonality property of Legendre polynomials,\n$$\n\\int_{-1}^{1} P_J(x) P_l(x) dx = \\frac{2}{2l+1} \\delta_{Jl}\n$$\nwe multiply the expansion by $P_J(x)$ and integrate over $x \\in [-1, 1]$:\n$$\n\\int_{-1}^{1} P_J(x) e^{\\kappa x} dx = \\sum_{l=0}^{\\infty} (2l+1) i_l(\\kappa) \\int_{-1}^{1} P_J(x) P_l(x) dx = \\sum_{l=0}^{\\infty} (2l+1) i_l(\\kappa) \\left( \\frac{2}{2l+1} \\delta_{Jl} \\right)\n$$\nThe sum collapses to a single term for $l=J$:\n$$\nI_\\beta = 2 i_J(\\kappa)\n$$\n\n**Final Expression**\n\nSubstituting the results for $I_\\alpha$, $I_\\beta$, and $I_\\gamma$ back into the expression for $\\mathcal{N}^{J}$:\n$$\n\\mathcal{N}^{J} = \\frac{2J+1}{8\\pi^2} (2\\pi I_0(\\rho)) (2 i_J(\\kappa)) (2\\pi I_0(\\sigma))\n$$\n$$\n\\mathcal{N}^{J} = \\frac{2J+1}{8\\pi^2} (8\\pi^2) I_0(\\rho) I_0(\\sigma) i_J(\\kappa)\n$$\nThe exact, closed-form expression for the projected norm is therefore:\n$$\n\\mathcal{N}^{J} = (2J+1) \\, I_0(\\rho) \\, I_0(\\sigma) \\, i_J(\\kappa)\n$$\nThis expression relies on well-known special functions available in standard scientific libraries.\n\n### 2. Numerical Integration Scheme\n\nThe numerical integration of $\\mathcal{N}^{J}$ is performed by discretizing the three-dimensional integral over the Euler angles. As the integrand is separable, we can compute each one-dimensional integral numerically and multiply the results.\n\n- **For $\\alpha$ and $\\gamma$**: The integrals are on $[0, 2\\pi)$. We use the trapezoidal rule for periodic functions, which involves summing the function values at $N$ equispaced points and multiplying by the step size $h=2\\pi/N$. For a set of nodes $\\{\\theta_i = i \\frac{2\\pi}{N}\\}_{i=0}^{N-1}$, the integral is approximated as:\n$$\n\\int_0^{2\\pi} f(\\theta) d\\theta \\approx \\frac{2\\pi}{N} \\sum_{i=0}^{N-1} f(\\theta_i)\n$$\nThis rule is spectrally accurate for smooth, periodic functions.\n\n- **For $\\beta$**: The integral over $\\beta$ is transformed to an integral over $x = \\cos\\beta$ on $[-1, 1]$. This form is ideal for Gauss-Legendre quadrature. Using $N_\\beta$ nodes $x_j$ and weights $w_j$, the integral is approximated as:\n$$\n\\int_{-1}^{1} g(x) dx \\approx \\sum_{j=0}^{N_\\beta-1} w_j g(x_j)\n$$\nThis method is highly efficient, achieving high accuracy with a relatively small number of nodes for smooth integrands.\n\nThe full numerical estimate is the product of these three numerical integrals, scaled by the appropriate prefactor from the original definition:\n$$\n\\mathcal{N}^{J}_{\\text{num}} = \\frac{2J+1}{8\\pi^2} \\left[ \\frac{2\\pi}{N_\\alpha} \\sum_{i=0}^{N_\\alpha-1} e^{\\rho\\cos\\alpha_i} \\right] \\left[ \\sum_{j=0}^{N_\\beta-1} w_j P_J(x_j) e^{\\kappa x_j} \\right] \\left[ \\frac{2\\pi}{N_\\gamma} \\sum_{k=0}^{N_\\gamma-1} e^{\\sigma\\cos\\gamma_k} \\right]\n$$\nThis simplifies to:\n$$\n\\mathcal{N}^{J}_{\\text{num}} = \\frac{2J+1}{2} \\left[ \\frac{1}{N_\\alpha} \\sum_{i=0}^{N_\\alpha-1} e^{\\rho\\cos\\alpha_i} \\right] \\left[ \\sum_{j=0}^{N_\\beta-1} w_j P_J(x_j) e^{\\kappa x_j} \\right] \\left[ \\frac{1}{N_\\gamma} \\sum_{k=0}^{N_\\gamma-1} e^{\\sigma\\cos\\gamma_k} \\right]\n$$\n\n### 3. Adaptive Refinement Strategy\n\nA robust numerical calculation requires a convergence test. We implement an adaptive mesh refinement procedure to automatically determine the required number of quadrature points ($N_\\alpha, N_\\beta, N_\\gamma$) to reach a desired tolerance $\\varepsilon$.\n\nThe procedure begins with a coarse mesh, e.g., $N_\\alpha=N_\\beta=N_\\gamma=4$. It then iteratively refines the mesh in the single dimension that most significantly impacts the result.\nAt each step $k$ with a mesh $(N_\\alpha, N_\\beta, N_\\gamma)_k$:\n1.  Calculate the current value of the norm, $V_k = \\mathcal{N}^{J}_{\\text{num}}((N_\\alpha, N_\\beta, N_\\gamma)_k)$.\n2.  Individually refine each dimension by doubling the number of points and calculate three test values:\n    - $V_{\\alpha} = \\mathcal{N}^{J}_{\\text{num}}((2N_\\alpha, N_\\beta, N_\\gamma)_k)$\n    - $V_{\\beta} = \\mathcal{N}^{J}_{\\text{num}}((N_\\alpha, 2N_\\beta, N_\\gamma)_k)$\n    - $V_{\\gamma} = \\mathcal{N}^{J}_{\\text{num}}((N_\\alpha, N_\\beta, 2N_\\gamma)_k)$\n3.  Compute the one-step relative changes for each dimension:\n    - $\\delta_\\alpha = |V_\\alpha - V_k| / |V_k|$\n    - $\\delta_\\beta = |V_\\beta - V_k| / |V_k|$\n    - $\\delta_\\gamma = |V_\\gamma - V_k| / |V_k|$\n    (A small threshold is used for the denominator $|V_k|$ to prevent division by zero, falling back to an absolute change if necessary).\n4.  Find the maximum change, $\\delta_{\\max} = \\max(\\delta_\\alpha, \\delta_\\beta, \\delta_\\gamma)$.\n5.  If $\\delta_{\\max} < \\varepsilon$, the procedure has converged, and $V_k$ is taken as the final numerical estimate.\n6.  Otherwise, the mesh for the next iteration, $(N_\\alpha, N_\\beta, N_\\gamma)_{k+1}$, is created by doubling the number of points in the dimension that yielded $\\delta_{\\max}$. For example, if $\\delta_\\alpha = \\delta_{\\max}$, then $(N_\\alpha, N_\\beta, N_\\gamma)_{k+1} = (2N_\\alpha, N_\\beta, N_\\gamma)_k$. This prioritizes computational effort where the integrand varies most sharply, leading to an efficient allocation of resources.\n7.  The loop also terminates if any mesh size exceeds its specified maximum.\n\nThis adaptive approach ensures that the numerical integration is both accurate and efficient, automatically tailoring the mesh density to the characteristics of the integrand for each test case. The final converged numerical value is then compared to the exact analytical expression to compute the a posteriori error.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import i0, spherical_in, legendre\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for adaptive angular momentum projection.\n    \"\"\"\n    \n    # (Parameter set), tolerance, max_mesh_sizes\n    test_cases = [\n        # Case 1 (baseline smooth)\n        ((0, 0.5, 0.5, 0.5), 1e-9, (256, 256, 256)),\n        # Case 2 (large J-oscillations in beta)\n        ((6, 8.0, 1.0, 1.5), 1e-8, (256, 512, 256)),\n        # Case 3 (sharp structure in alpha)\n        ((4, 1.0, 6.0, 0.0), 1e-8, (512, 256, 256)),\n        # Case 4 (simultaneously sharp in all angles)\n        ((10, 12.0, 3.0, 3.0), 1e-7, (512, 512, 512)),\n        # Case 5 (nearly flat in beta, very sharp in alpha and gamma)\n        ((2, 0.01, 10.0, 10.0), 1e-9, (1024, 512, 1024)),\n    ]\n\n    # Caches for memoizing quadrature results to improve performance\n    alpha_integral_cache = {}\n    beta_integral_cache = {}\n    gamma_integral_cache = {}\n\n    def integrate_alpha(rho, n_alpha):\n        \"\"\"Computes the integral over the Euler angle alpha.\"\"\"\n        if (rho, n_alpha) in alpha_integral_cache:\n            return alpha_integral_cache[(rho, n_alpha)]\n        \n        # Trapezoidal rule for a periodic function\n        alpha_nodes = np.linspace(0, 2 * np.pi, n_alpha, endpoint=False)\n        integrand_values = np.exp(rho * np.cos(alpha_nodes))\n        integral = (2 * np.pi / n_alpha) * np.sum(integrand_values)\n        \n        alpha_integral_cache[(rho, n_alpha)] = integral\n        return integral\n\n    def integrate_gamma(sigma, n_gamma):\n        \"\"\"Computes the integral over the Euler angle gamma.\"\"\"\n        if (sigma, n_gamma) in gamma_integral_cache:\n            return gamma_integral_cache[(sigma, n_gamma)]\n\n        # Trapezoidal rule for a periodic function\n        gamma_nodes = np.linspace(0, 2 * np.pi, n_gamma, endpoint=False)\n        integrand_values = np.exp(sigma * np.cos(gamma_nodes))\n        integral = (2 * np.pi / n_gamma) * np.sum(integrand_values)\n        \n        gamma_integral_cache[(sigma, n_gamma)] = integral\n        return integral\n\n    gauss_legendre_cache = {}\n    def get_gauss_legendre_points(n_beta):\n        if n_beta in gauss_legendre_cache:\n            return gauss_legendre_cache[n_beta]\n        nodes, weights = np.polynomial.legendre.leggauss(n_beta)\n        gauss_legendre_cache[n_beta] = (nodes, weights)\n        return nodes, weights\n\n    def integrate_beta(J, kappa, n_beta):\n        \"\"\"Computes the integral over the Euler angle beta.\"\"\"\n        if (J, kappa, n_beta) in beta_integral_cache:\n            return beta_integral_cache[(J, kappa, n_beta)]\n\n        # Gauss-Legendre quadrature\n        x_nodes, weights = get_gauss_legendre_points(n_beta)\n        P_J = legendre(J)\n        integrand_values = P_J(x_nodes) * np.exp(kappa * x_nodes)\n        integral = np.sum(weights * integrand_values)\n        \n        beta_integral_cache[(J, kappa, n_beta)] = integral\n        return integral\n\n    def calculate_norm(params, n_alpha, n_beta, n_gamma):\n        \"\"\"Calculates the projected norm for a given mesh.\"\"\"\n        J, kappa, rho, sigma = params\n        \n        integral_alpha = integrate_alpha(rho, n_alpha)\n        integral_beta = integrate_beta(J, kappa, n_beta)\n        integral_gamma = integrate_gamma(sigma, n_gamma)\n        \n        prefactor = (2 * J + 1) / (8 * np.pi**2)\n        \n        return prefactor * integral_alpha * integral_beta * integral_gamma\n\n    def calculate_exact_norm(params):\n        \"\"\"Calculates the exact projected norm using special functions.\"\"\"\n        J, kappa, rho, sigma = params\n        \n        # Handle the special case where kappa = 0 for spherical_in\n        if kappa == 0:\n            i_j_kappa = 1.0 if J == 0 else 0.0\n        else:\n            i_j_kappa = spherical_in(J, kappa)\n\n        return (2 * J + 1) * i0(rho) * i0(sigma) * i_j_kappa\n\n    results = []\n    for params, epsilon, max_Ns in test_cases:\n        alpha_integral_cache.clear()\n        beta_integral_cache.clear()\n        gamma_integral_cache.clear()\n        gauss_legendre_cache.clear()\n\n        J, kappa, rho, sigma = params\n        n_alpha_max, n_beta_max, n_gamma_max = max_Ns\n\n        n_alpha, n_beta, n_gamma = 4, 4, 4\n        \n        while True:\n            current_norm = calculate_norm(params, n_alpha, n_beta, n_gamma)\n\n            # Test refinement in alpha\n            if 2 * n_alpha = n_alpha_max:\n                norm_alpha = calculate_norm(params, 2 * n_alpha, n_beta, n_gamma)\n                if abs(current_norm) > 1e-20:\n                    change_alpha = abs(norm_alpha - current_norm) / abs(current_norm)\n                else:\n                    change_alpha = abs(norm_alpha - current_norm)\n            else:\n                change_alpha = 0.0\n\n            # Test refinement in beta\n            if 2 * n_beta = n_beta_max:\n                norm_beta = calculate_norm(params, n_alpha, 2 * n_beta, n_gamma)\n                if abs(current_norm) > 1e-20:\n                    change_beta = abs(norm_beta - current_norm) / abs(current_norm)\n                else:\n                    change_beta = abs(norm_beta - current_norm)\n            else:\n                change_beta = 0.0\n            \n            # Test refinement in gamma\n            if 2 * n_gamma = n_gamma_max:\n                norm_gamma = calculate_norm(params, n_alpha, n_beta, 2 * n_gamma)\n                if abs(current_norm) > 1e-20:\n                    change_gamma = abs(norm_gamma - current_norm) / abs(current_norm)\n                else:\n                    change_gamma = abs(norm_gamma - current_norm)\n            else:\n                change_gamma = 0.0\n\n            max_change = max(change_alpha, change_beta, change_gamma)\n\n            if max_change  epsilon or max_change == 0.0:\n                final_numerical_norm = current_norm\n                break\n            \n            # Refine the dimension with the largest change\n            if change_alpha >= change_beta and change_alpha >= change_gamma:\n                n_alpha *= 2\n            elif change_beta >= change_alpha and change_beta >= change_gamma:\n                n_beta *= 2\n            else:\n                n_gamma *= 2\n\n        exact_norm = calculate_exact_norm(params)\n        \n        # Calculate error based on magnitude of exact value\n        if abs(exact_norm) > 1e-14:\n            error = abs(final_numerical_norm - exact_norm) / abs(exact_norm)\n        else:\n            error = abs(final_numerical_norm - exact_norm)\n        \n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3542290"}, {"introduction": "After successfully projecting a set of mean-field states, the next step is to extract physical observables like the energy spectrum. This typically involves solving a generalized eigenvalue problem, but a significant practical complication arises: the projected basis states are not only non-orthogonal but often nearly linearly dependent. This exercise tackles this crucial post-projection challenge by implementing canonical orthonormalization, a standard procedure to stabilize the calculation by identifying and removing redundant directions in the basis. By studying the effect of different cutoff thresholds, you will gain insight into how numerical stability directly impacts the calculated physical spectrum. [@problem_id:3542310]", "problem": "Consider the angular-momentum projected configuration mixing of Hartree-Fock-Bogoliubov (HFB) mean-field states in nuclear many-body theory. The non-orthogonality of projected basis states leads to a generalized eigenvalue problem for the Hamiltonian in the subspace spanned by projected configurations. Your task is to implement canonical orthonormalization to address linear dependence and study the effect of cutoff thresholds on small overlap-matrix eigenvalues on the resulting energy spectrum.\n\nStart from the variational principle for stationary states in a non-orthogonal subspace: minimizing the Rayleigh quotient of the Hamiltonian over linear combinations of non-orthogonal projected states leads to a generalized eigenvalue problem of the form $H \\mathbf{c} = E S \\mathbf{c}$, where $S$ is the overlap matrix between basis states and $H$ is the Hamiltonian matrix. Linear dependence manifests as near-zero eigenvalues of $S$, and the canonical orthonormalization procedure (also known as symmetric orthonormalization) remedies both non-orthogonality and near-linear dependence by diagonalizing $S$ and discarding modes with very small norm.\n\nYou must construct, in a purely mathematical form, a symmetric positive semidefinite overlap matrix $S$ and a symmetric Hamiltonian matrix $H$ of dimension $5$, using deterministic orthogonal transformations and prescribed eigenvalues. Specifically:\n\n- Let $n = 5$.\n- Define a sequence of Givens rotations on $\\mathbb{R}^5$ parameterized by angles in radians to construct an orthogonal matrix $Q$:\n  - Rotate in the $(0,1)$-plane by angle $\\alpha = 0.3$ (radians).\n  - Rotate in the $(2,3)$-plane by angle $\\beta = -0.7$ (radians).\n  - Rotate in the $(1,2)$-plane by angle $\\gamma = 0.5$ (radians).\n  - Rotate in the $(0,4)$-plane by angle $\\delta = 0.2$ (radians).\n  The product of these rotations (applied in the stated order) defines $Q$.\n- Using $Q$, define the overlap matrix $S = Q \\,\\mathrm{diag}(s)\\, Q^{\\mathsf{T}}$ with eigenvalues $s = [\\,1.0,\\;0.5,\\;0.05,\\;10^{-8},\\;0.2\\,]$. This choice models one nearly redundant direction with eigenvalue $10^{-8}$ and other well-conditioned directions.\n- Define another orthogonal matrix $R$ by applying Givens rotations (in radians) in the following order:\n  - Rotate in the $(0,2)$-plane by angle $\\theta_1 = -0.4$.\n  - Rotate in the $(3,4)$-plane by angle $\\theta_2 = 0.65$.\n  - Rotate in the $(1,4)$-plane by angle $\\theta_3 = -0.25$.\n  - Rotate in the $(0,3)$-plane by angle $\\theta_4 = 0.15$.\n- Using $R$, define the Hamiltonian $H = R \\,\\mathrm{diag}(e)\\, R^{\\mathsf{T}}$ with energies $e = [\\,-8.0,\\,-2.0,\\;1.0,\\;3.0,\\;7.0\\,]$ (in Mega-electron Volts (MeV)).\n\nImplement canonical orthonormalization as follows, without using any shortcut formulas: diagonalize the overlap matrix $S$, discard eigenmodes whose eigenvalues are below a cutoff threshold, construct the corresponding orthonormal subspace, map the Hamiltonian into that orthonormal subspace, and solve the ordinary eigenvalue problem to obtain the energy spectrum in MeV. If no eigenmodes remain after applying the cutoff, return an empty list to indicate that no physical spectrum is defined in that case.\n\nUse the following test suite of cutoff thresholds (all in absolute value, with removal enforced for eigenvalues less than or equal to the cutoff): $\\epsilon \\in \\{\\,10^{-12},\\;10^{-6},\\;10^{-1},\\;6\\times 10^{-1},\\;2.0\\,\\}$. These cover:\n- A case that keeps almost all modes including the near-redundant one ($\\epsilon = 10^{-12}$).\n- A case that removes the near-zero mode but keeps all well-conditioned ones ($\\epsilon = 10^{-6}$).\n- A case that removes multiple small-norm modes ($\\epsilon = 10^{-1}$).\n- A boundary case leaving a single retained mode ($\\epsilon = 6\\times 10^{-1}$).\n- An extreme case that removes all modes ($\\epsilon = 2.0$).\n\nFor each threshold $\\epsilon$, compute the energies by canonical orthonormalization and diagonalization of the Hamiltonian in the retained orthonormal subspace, and return the energies sorted in ascending order. Express the energies in Mega-electron Volts (MeV) as floating-point numbers rounded to six decimals. The final output must aggregate the results for all test cases into a single line formatted as a comma-separated list enclosed in square brackets, with each per-threshold result itself a bracketed comma-separated list, for example, $\"[[E_{1}^{(1)},E_{2}^{(1)},\\dots],[E_{1}^{(2)},\\dots],\\dots]\"$, where every $E_{k}^{(i)}$ is a float in MeV. Angles are in radians throughout.", "solution": "The problem at hand is a well-posed and scientifically sound exercise in computational many-body physics, specifically addressing the numerical stabilization of the configuration interaction method built upon a non-orthogonal basis of projected mean-field states. The core task is to solve the generalized eigenvalue problem (GEP) $H \\mathbf{c} = E S \\mathbf{c}$ for the energy spectrum $E$ by applying the canonical orthonormalization procedure. This method is essential for handling the near-linear dependencies that arise in the basis set of projected Hartree-Fock-Bogoliubov (HFB) states, which manifest as near-zero eigenvalues in the overlap matrix $S$.\n\nThe solution involves three main stages:\n1.  Construction of the symmetric Hamiltonian matrix $H$ and the symmetric positive semidefinite overlap matrix $S$ according to the specified spectral decompositions.\n2.  Implementation of the canonical orthonormalization algorithm, which transforms the GEP into a standard eigenvalue problem (SEP) within a physically relevant, smaller subspace.\n3.  Application of this procedure for a series of cutoff thresholds $\\epsilon$ to study their effect on the resulting energy spectrum.\n\n**1. Construction of Matrices**\n\nThe matrices $H$ and $S$ are constructed to be of dimension $n=5$. Their spectral properties (eigenvalues) are predefined, and their eigenvectors are determined by specific orthogonal transformation matrices, $R$ and $Q$ respectively, which are themselves products of Givens rotations.\n\nA Givens rotation in the $(i,j)$-plane by an angle $\\phi$ is represented by a matrix $G_{i,j}(\\phi)$ which is an identity matrix except for four elements: $G_{ii} = G_{jj} = \\cos(\\phi)$, $G_{ij} = -\\sin(\\phi)$, and $G_{ji} = \\sin(\\phi)$.\n\nThe orthogonal matrix $Q$ for the overlap matrix $S$ is defined as the product of four successive rotations:\n$$Q = G_{0,4}(\\delta) G_{1,2}(\\gamma) G_{2,3}(\\beta) G_{0,1}(\\alpha)$$\nwith angles $\\alpha = 0.3$, $\\beta = -0.7$, $\\gamma = 0.5$, and $\\delta = 0.2$ radians. The overlap matrix $S$ is then constructed as:\n$$S = Q \\,\\mathrm{diag}(s)\\, Q^{\\mathsf{T}}$$\nwhere the specified eigenvalues are $s = [\\,1.0,\\;0.5,\\;0.05,\\;10^{-8},\\;0.2\\,]$. This construction ensures $S$ is symmetric and positive semidefinite, with one eigenvalue ($10^{-8}$) being extremely small, modeling a near-linear dependence in the basis.\n\nSimilarly, the orthogonal matrix $R$ for the Hamiltonian matrix $H$ is the product of four rotations:\n$$R = G_{0,3}(\\theta_4) G_{1,4}(\\theta_3) G_{3,4}(\\theta_2) G_{0,2}(\\theta_1)$$\nwith angles $\\theta_1 = -0.4$, $\\theta_2 = 0.65$, $\\theta_3 = -0.25$, and $\\theta_4 = 0.15$ radians. The Hamiltonian matrix $H$ is then defined as:\n$$H = R \\,\\mathrm{diag}(e)\\, R^{\\mathsf{T}}$$\nwhere the specified eigenvalues are $e = [\\,-8.0,\\,-2.0,\\;1.0,\\;3.0,\\;7.0\\,]$ in units of Mega-electron Volts (MeV). This construction ensures $H$ is symmetric, as required.\n\n**2. Canonical Orthonormalization Procedure**\n\nThe GEP $H \\mathbf{c} = E S \\mathbf{c}$ is numerically unstable to solve directly when $S$ is ill-conditioned (i.e., has a large condition number, stemming from small eigenvalues). Canonical orthonormalization proceeds as follows:\n\nFirst, the overlap matrix $S$ is diagonalized:\n$$S U = U D_s$$\nwhere $U$ is the orthogonal matrix of eigenvectors $u_i$ and $D_s$ is the diagonal matrix of corresponding eigenvalues $s_i$. These eigenvalues are non-negative.\n\nSecond, a cutoff threshold $\\epsilon$ is introduced to discard eigenmodes associated with eigenvalues $s_i$ that are too small. According to the problem specification, we retain modes for which $s_i  \\epsilon$. Let the number of such retained modes be $k$, where $k \\le n$. If $k=0$, the resulting physical space is empty, and no energy spectrum can be determined.\n\nThird, we construct a transformation matrix $X$ of dimension $n \\times k$. The columns of $X$ define the coefficients of the new $k$ orthonormal basis vectors in terms of the original $n$ non-orthogonal basis vectors. This matrix is constructed from the retained eigenvectors and eigenvalues of $S$:\n$$X = U_{kept} (D_s)_{kept}^{-1/2}$$\nwhere $U_{kept}$ is the $n \\times k$ matrix whose columns are the retained eigenvectors, and $(D_s)_{kept}^{-1/2}$ is the $k \\times k$ diagonal matrix with entries $1/\\sqrt{s_i}$ for the retained eigenvalues. The basis transformed by $X$ is orthonormal, as $X^{\\mathsf{T}}SX = I_k$, where $I_k$ is the $k \\times k$ identity matrix.\n\nFinally, the Hamiltonian is projected onto this new orthonormal subspace:\n$$\\tilde{H} = X^{\\mathsf{T}} H X$$\nThe resulting matrix $\\tilde{H}$ is a $k \\times k$ symmetric matrix. The problem is reduced to a standard eigenvalue problem in the stable subspace:\n$$\\tilde{H} \\mathbf{d} = E \\mathbf{d}$$\nThe eigenvalues $E$ of $\\tilde{H}$ form the physically meaningful energy spectrum.\n\n**3. Application to Test Cases**\n\nThis procedure is applied for each specified cutoff threshold $\\epsilon \\in \\{\\,10^{-12},\\;10^{-6},\\;10^{-1},\\;6\\times 10^{-1},\\;2.0\\,\\}$.\n\n- For $\\epsilon = 10^{-12}$: This threshold is smaller than the smallest eigenvalue of $S$ ($10^{-8}$). Thus, all $5$ eigenmodes of $S$ are retained ($k=5$), and the GEP is transformed into a $5 \\times 5$ SEP.\n- For $\\epsilon = 10^{-6}$: This threshold is larger than $10^{-8}$ but smaller than all other eigenvalues of $S$. The mode corresponding to the $10^{-8}$ eigenvalue is discarded, leading to a $4 \\times 4$ SEP ($k=4$).\n- For $\\epsilon = 10^{-1}$: The eigenvalues $10^{-8}$ and $0.05$ are $\\le \\epsilon$. Thus, two modes are discarded, resulting in a $3 \\times 3$ SEP ($k=3$).\n- For $\\epsilon = 6 \\times 10^{-1}$: Four eigenvalues ($10^{-8}, 0.05, 0.2, 0.5$) are $\\le \\epsilon$. Only the mode corresponding to the largest eigenvalue ($1.0$) is retained, yielding a $1 \\times 1$ problem ($k=1$), whose solution is a single energy value.\n- For $\\epsilon = 2.0$: All eigenvalues of $S$ are smaller than this threshold. All modes are discarded ($k=0$), and the resulting spectrum is an empty set.\n\nThe computed energies for each case are sorted in ascending order and rounded to six decimal places, as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the generalized eigenvalue problem Hc = ESc using canonical\n    orthonormalization for a set of cutoff thresholds.\n    \"\"\"\n    \n    # Define problem parameters\n    n = 5\n    s_eigvals = [1.0, 0.5, 0.05, 1e-8, 0.2]\n    e_eigvals = [-8.0, -2.0, 1.0, 3.0, 7.0] # in MeV\n    \n    # Angles for rotations in radians\n    alpha, beta, gamma, delta = 0.3, -0.7, 0.5, 0.2\n    theta1, theta2, theta3, theta4 = -0.4, 0.65, -0.25, 0.15\n    \n    # Test suite of cutoff thresholds\n    test_cases = [1e-12, 1e-6, 1e-1, 6e-1, 2.0]\n\n    def givens_rotation(dim, i, j, angle):\n        \"\"\"Constructs a Givens rotation matrix.\"\"\"\n        G = np.identity(dim)\n        c, s = np.cos(angle), np.sin(angle)\n        G[i, i] = c\n        G[j, j] = c\n        G[i, j] = -s\n        G[j, i] = s\n        return G\n\n    # Construct the orthogonal matrix Q for the overlap matrix S\n    G1_Q = givens_rotation(n, 0, 1, alpha)\n    G2_Q = givens_rotation(n, 2, 3, beta)\n    G3_Q = givens_rotation(n, 1, 2, gamma)\n    G4_Q = givens_rotation(n, 0, 4, delta)\n    Q = np.linalg.multi_dot([G4_Q, G3_Q, G2_Q, G1_Q])\n\n    # Construct the overlap matrix S\n    D_s = np.diag(s_eigvals)\n    S = Q @ D_s @ Q.T\n\n    # Construct the orthogonal matrix R for the Hamiltonian H\n    G1_R = givens_rotation(n, 0, 2, theta1)\n    G2_R = givens_rotation(n, 3, 4, theta2)\n    G3_R = givens_rotation(n, 1, 4, theta3)\n    G4_R = givens_rotation(n, 0, 3, theta4)\n    R = np.linalg.multi_dot([G4_R, G3_R, G2_R, G1_R])\n\n    # Construct the Hamiltonian matrix H\n    D_e = np.diag(e_eigvals)\n    H = R @ D_e @ R.T\n\n    all_results = []\n    \n    for epsilon in test_cases:\n        # Step 1: Diagonalize the overlap matrix S\n        # np.linalg.eigh returns eigenvalues in ascending order\n        s_vals, U = np.linalg.eigh(S)\n\n        # Step 2: Filter eigenmodes based on the cutoff threshold epsilon\n        # Keep modes where eigenvalue s > epsilon\n        keep_mask = s_vals > epsilon\n        num_kept = np.sum(keep_mask)\n        \n        if num_kept == 0:\n            all_results.append([])\n            continue\n\n        s_kept = s_vals[keep_mask]\n        U_kept = U[:, keep_mask]\n\n        # Step 3: Construct the transformation matrix X\n        # X = U_kept * (D_s_kept)^(-1/2)\n        X = U_kept / np.sqrt(s_kept)\n\n        # Step 4: Transform the Hamiltonian to the new orthonormal basis\n        H_tilde = X.T @ H @ X\n\n        # Step 5: Solve the standard eigenvalue problem for the transformed Hamiltonian\n        # np.linalg.eigh returns sorted eigenvalues\n        energies = np.linalg.eigh(H_tilde)[0]\n\n        # Round the resulting energies to six decimal places\n        rounded_energies = np.round(energies, 6).tolist()\n        all_results.append(rounded_energies)\n\n    # Format the final output string exactly as required\n    output_parts = []\n    for res_list in all_results:\n        # Format each number to have 6 decimal places.\n        formatted_energies = [f\"{val:.6f}\" for val in res_list]\n        inner_string = f\"[{','.join(formatted_energies)}]\"\n        output_parts.append(inner_string)\n    \n    final_output_string = f\"[{','.join(output_parts)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```", "id": "3542310"}]}