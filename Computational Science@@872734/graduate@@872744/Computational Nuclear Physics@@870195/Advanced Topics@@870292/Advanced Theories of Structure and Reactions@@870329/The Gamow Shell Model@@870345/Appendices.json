{"hands_on_practices": [{"introduction": "The foundation of the Gamow Shell Model is its description of single-particle states, including resonances, which are characterized by complex energies. This hands-on exercise delves into the origin of these complex energies by examining a single neutron in a simplified potential well. By applying purely outgoing boundary conditions—a hallmark of decaying Gamow states—you will derive and numerically solve the characteristic equation for a resonance pole, gaining fundamental insight into how finite lifetimes and decay widths, such as $\\Gamma = -2\\operatorname{Im}(E)$, arise from first principles in quantum mechanics [@problem_id:3600450].", "problem": "Consider a single-particle neutron described by the time-independent radial Schrödinger equation in a spherically symmetric, finite-range potential well. The potential is a spherical square well of radius $R$ and depth $V_0$, defined by $V(r) = -V_0$ for $0 \\le r \\le R$ and $V(r) = 0$ for $r  R$. Work in nonrelativistic quantum mechanics using standard single-particle scattering theory. Take the reduced mass equal to the neutron mass and use fully outgoing boundary conditions appropriate for Gamow states in the Gamow shell model. Use the following physical constants: reduced Planck constant times speed of light equal to $\\hbar c = 197.3269804\\,\\text{MeV}\\cdot\\text{fm}$ and neutron mass equal to $m_n c^2 = 939.0\\,\\text{MeV}$. Define $\\alpha \\equiv 2\\mu/\\hbar^2$ with $\\mu = m_n$.\n\nStarting from the radial Schrödinger equation for zero orbital angular momentum (that is, $s$-wave with $l=0$) and the requirement of purely outgoing asymptotics outside the well, derive the complex transcendental equation that determines the $S$-matrix pole positions. Express this equation in terms of the complex exterior momentum $k$ and the interior momentum $q$, where $k^2 = \\alpha E$ and $q^2 = \\alpha(E + V_0)$ with $E$ the complex energy. Clearly state the matching conditions at $r=R$ leading to the transcendental equation.\n\nDefine the pole energy by $E = E_r - i \\Gamma/2$, with $E_r$ and $\\Gamma$ real and $\\Gamma \\ge 0$. For any solution that satisfies the purely outgoing boundary condition and yields $\\operatorname{Im}(E)  0$, extract the width $\\Gamma$ in $\\text{MeV}$ using $\\Gamma = -2\\,\\operatorname{Im}(E)$. If $\\operatorname{Im}(E) \\ge 0$, report the width as $0$.\n\nAlgorithmic task: implement a robust numerical solver for the complex transcendental equation you derived, using the complex variable $k$ as the unknown. Use the principal branch of the complex square root to define $q = \\sqrt{k^2 + \\alpha V_0}$. Solve for the $s$-wave pole located in the fourth quadrant of the complex $k$-plane with $\\operatorname{Re}(k)  0$ and $\\operatorname{Im}(k)  0$ that has the smallest positive real energy $E_r = \\operatorname{Re}(k^2/\\alpha)$. If multiple poles satisfy these criteria, select the one with the smallest $E_r$. If no such pole is found, return width $0$.\n\nNumerical units and output specification: express all energies in $\\text{MeV}$ and all lengths in $\\text{fm}$. Your program must compute the widths $\\Gamma$ for the following test suite of $(V_0, R)$ parameter sets:\n- $(V_0, R) = (50.0\\,\\text{MeV}, 4.0\\,\\text{fm})$\n- $(V_0, R) = (50.0\\,\\text{MeV}, 5.0\\,\\text{fm})$\n- $(V_0, R) = (30.0\\,\\text{MeV}, 4.0\\,\\text{fm})$\n- $(V_0, R) = (70.0\\,\\text{MeV}, 3.0\\,\\text{fm})$\n- $(V_0, R) = (10.0\\,\\text{MeV}, 4.0\\,\\text{fm})$\n\nYour algorithm must be self-contained and deterministic, without user input. To promote robustness, you may use multiple initial guesses for the complex momentum $k$ near $k \\approx m\\pi/R$ for small integers $m$, each with a small negative imaginary part, and pick the valid root according to the selection rule described above. Use the principal square root for complex arithmetic.\n\nYour program should produce a single line of output containing the five widths as a comma-separated list enclosed in square brackets, with each width rounded to six digits after the decimal point, for example, `[0.123456,0.000000,0.987654,0.111111,0.222222]`.", "solution": "The problem requires the derivation and numerical solution of the transcendental equation for $s$-wave Gamow states in a spherical square well potential. A Gamow state is a solution to the time-independent Schrödinger equation corresponding to a complex energy $E = E_r - i\\Gamma/2$, representing a quasi-bound or resonant state that decays over time. The imaginary part of the energy is related to the decay width $\\Gamma$.\n\nThe starting point is the radial Schrödinger equation for the reduced radial wave function $u(r) = r\\psi(r)$ for zero orbital angular momentum ($l=0$):\n$$\n-\\frac{\\hbar^2}{2\\mu} \\frac{d^2u(r)}{dr^2} + V(r)u(r) = E u(r)\n$$\nHere, $\\mu$ is the reduced mass, taken to be the neutron mass $m_n$. The potential $V(r)$ is a finite spherical square well of depth $V_0  0$ and radius $R$:\n$$\nV(r) =\n\\begin{cases}\n-V_0  \\text{for } 0 \\le r \\le R \\\\\n0  \\text{for } r  R\n\\end{cases}\n$$\nWe define the constant $\\alpha \\equiv 2\\mu/\\hbar^2$. The equation is analyzed in two regions.\n\nIn the interior region ($0 \\le r \\le R$), the equation is:\n$$\n\\frac{d^2u_I(r)}{dr^2} + \\alpha(E + V_0)u_I(r) = 0\n$$\nDefining the interior wave number $q$ such that $q^2 = \\alpha(E + V_0)$, the equation simplifies to a simple harmonic oscillator form:\n$$\n\\frac{d^2u_I(r)}{dr^2} + q^2 u_I(r) = 0\n$$\nThe general solution is $u_I(r) = A'\\sin(qr) + B'\\cos(qr)$. The physical requirement that the full wave function $\\psi(r) = u(r)/r$ remains finite at the origin implies that $u(0)=0$. This boundary condition forces $B'=0$, yielding the interior solution:\n$$\nu_I(r) = A \\sin(qr)\n$$\nwhere $A$ is a normalization constant.\n\nIn the exterior region ($r  R$), the potential is zero, $V(r)=0$, and the equation becomes:\n$$\n\\frac{d^2u_{II}(r)}{dr^2} + \\alpha E u_{II}(r) = 0\n$$\nDefining the exterior wave number $k$ such that $k^2 = \\alpha E$, the equation is:\n$$\n\\frac{d^2u_{II}(r)}{dr^2} + k^2 u_{II}(r) = 0\n$$\nThe general solution is a superposition of an incoming spherical wave, $e^{-ikr}$, and an outgoing spherical wave, $e^{ikr}$. Gamow states, as poles of the $S$-matrix, are defined by purely outgoing boundary conditions. This condition requires that the coefficient of the incoming wave be zero. Thus, the exterior solution is:\n$$\nu_{II}(r) = C e^{ikr}\n$$\nwhere $C$ is a constant. For a resonance, the energy $E$ is complex, and so is the wave number $k$. Specifically, for a decaying state, we expect $\\operatorname{Im}(E)  0$, which implies that $k$ lies in the fourth quadrant of the complex plane ($\\operatorname{Re}(k)  0$ and $\\operatorname{Im}(k)  0$). This ensures that the probability density $|\\psi_{II}(r,t)|^2 \\propto |e^{i(kr - Et/\\hbar)}/r|^2$ grows exponentially with $r$, a characteristic feature of unphysical Gamow states.\n\nTo find the allowed complex energies, we impose continuity of the wave function $u(r)$ and its first derivative $u'(r)$ at the boundary $r=R$. The matching conditions are:\n1.  $u_I(R) = u_{II}(R) \\implies A \\sin(qR) = C e^{ikR}$\n2.  $u_I'(R) = u_{II}'(R) \\implies A q \\cos(qR) = C (ik) e^{ikR}$\n\nTo obtain an equation independent of the constants $A$ and $C$, we divide the second equation by the first (assuming $A, C,$ and $\\sin(qR)$ are non-zero):\n$$\n\\frac{A q \\cos(qR)}{A \\sin(qR)} = \\frac{C (ik) e^{ikR}}{C e^{ikR}}\n$$\nThis yields the complex transcendental equation for the $S$-matrix poles:\n$$\nq \\cot(qR) = ik\n$$\nThe solutions to this equation are the complex momenta $k$ of the Gamow states. The interior momentum $q$ is related to $k$ via the definitions $k^2 = \\alpha E$ and $q^2 = \\alpha(E+V_0)$, which gives $q^2 = k^2 + \\alpha V_0$. We use the principal branch of the complex square root to define $q = \\sqrt{k^2 + \\alpha V_0}$.\n\nThe algorithmic task is to solve this equation numerically for the complex variable $k$. For better numerical stability, especially near poles of the cotangent function, the equation is rewritten as $q \\cos(qR) - ik \\sin(qR) = 0$. The roots of this form are identical to the original equation's roots, except for the special cases where $\\sin(qR)=0$, which correspond to bound states of an infinite well and are not the solutions sought.\n\nThe algorithm proceeds as follows:\n1.  Calculate the constant $\\alpha = 2 m_n c^2 / (\\hbar c)^2$ using the provided physical constants.\n2.  For each pair of parameters $(V_0, R)$, solve the complex equation $f(k) = q \\cos(qR) - ik \\sin(qR) = 0$ using a numerical root-finding algorithm.\n3.  To find the desired pole, a search is performed using multiple initial guesses for $k$. Resonances are often viewed as \"leaky\" bound states. The wave numbers for states in an infinite well of radius $R$ are real, $k_m = m\\pi/R$ for positive integers $m$. Thus, good initial guesses for resonance poles are complex numbers close to these values, with a small negative imaginary part, e.g., $k_{\\text{guess}} = m\\pi/R - i\\delta$ for $\\delta  0$.\n4.  Each root $k_{\\text{sol}}$ found by the solver is validated against the problem's criteria:\n    - The pole must be in the fourth quadrant: $\\operatorname{Re}(k_{\\text{sol}})  0$ and $\\operatorname{Im}(k_{\\text{sol}})  0$.\n    - The real part of the corresponding energy, $E_r = \\operatorname{Re}(k_{\\text{sol}}^2/\\alpha)$, must be positive.\n5.  All valid poles found from the various initial guesses are collected. If multiple distinct poles satisfy the criteria, they are sorted by their real energy $E_r$. The one with the smallest positive $E_r$ is selected.\n6.  From the selected pole's complex momentum $k_{\\text{pole}}$, the complex energy is computed as $E = k_{\\text{pole}}^2 / \\alpha$.\n7.  The decay width $\\Gamma$ is extracted using the relation $\\Gamma = -2\\operatorname{Im}(E)$. Given the selection criteria ($\\operatorname{Re}(k)0, \\operatorname{Im}(k)0$), $\\operatorname{Im}(E)$ will be negative, yielding a positive width $\\Gamma$. If no such pole is found, the width is reported as $0$. The final value is formatted to six decimal places.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root\n\ndef solve():\n    \"\"\"\n    Derives and solves the transcendental equation for s-wave Gamow states\n    in a spherical square well potential.\n    \"\"\"\n\n    # Physical constants\n    HBARC = 197.3269804  # MeV * fm\n    M_N_C2 = 939.0      # MeV\n    ALPHA = 2.0 * M_N_C2 / HBARC**2  # MeV^-1 * fm^-2\n\n    # Test cases from the problem statement: (V0 in MeV, R in fm)\n    test_cases = [\n        (50.0, 4.0),\n        (50.0, 5.0),\n        (30.0, 4.0),\n        (70.0, 3.0),\n        (10.0, 4.0),\n    ]\n\n    results = []\n    for V0, R in test_cases:\n        pole_k = find_gamow_pole(V0, R, ALPHA)\n        \n        if pole_k is not None:\n            # Calculate complex energy E from the pole momentum k\n            E = pole_k**2 / ALPHA\n            # Calculate width Gamma = -2 * Im(E)\n            # Im(E) is guaranteed to be  0 for a valid pole, so Gamma  0.\n            # The problem asks to report Gamma=0 if Im(E) = 0; this is a safeguard.\n            gamma = -2 * E.imag if E.imag  0 else 0.0\n        else:\n            # If no valid pole is found, width is 0\n            gamma = 0.0\n        \n        results.append(f\"{gamma:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef find_gamow_pole(V0, R, alpha):\n    \"\"\"\n    Finds the s-wave Gamow pole with the smallest positive real energy.\n    \n    Args:\n        V0 (float): Potential well depth in MeV.\n        R (float): Potential well radius in fm.\n        alpha (float): Constant 2*mu/hbar^2 in MeV^-1 * fm^-2.\n\n    Returns:\n        complex or None: The complex momentum k of the desired pole, or None if not found.\n    \"\"\"\n\n    def target_function(k_vec, V0_in, R_in, alpha_in):\n        \"\"\"\n        Target function f(k) = q*cos(qR) - i*k*sin(qR) = 0 for the root finder.\n        The input k_vec is a real array [Re(k), Im(k)].\n        The output is a real array [Re(f(k)), Im(f(k))].\n        This form avoids poles of cot(qR).\n        \"\"\"\n        k = k_vec[0] + 1j * k_vec[1]\n        \n        # Avoid k=0\n        if abs(k)  1e-9:\n            return [1e10, 1e10]\n\n        q_squared = k**2 + alpha_in * V0_in\n        q = np.sqrt(q_squared) # Principal square root\n        \n        qR = q * R_in\n\n        # Numerically stable form of the transcendental equation\n        val = q * np.cos(qR) - 1j * k * np.sin(qR)\n        \n        return [val.real, val.imag]\n\n    found_poles = []\n    \n    # Grid of initial guesses for k = k_r + i*k_i\n    # Guesses are based on resonances being \"leaky\" bound states of an infinite well (k_r ~ m*pi/R)\n    m_vals = range(1, 15)\n    im_k_vals = np.linspace(-0.01, -0.8, 20)\n\n    for m in m_vals:\n        re_k_guess = m * np.pi / R\n        for im_k_guess in im_k_vals:\n            k_guess = np.array([re_k_guess, im_k_guess])\n            \n            sol = root(target_function, k_guess, args=(V0, R, alpha), method='hybr', tol=1e-9)\n\n            if sol.success:\n                k_sol = sol.x[0] + 1j * sol.x[1]\n\n                # Verify that it is a genuine root\n                res = target_function(sol.x, V0, R, alpha)\n                if np.sqrt(res[0]**2 + res[1]**2)  1e-7:\n                    continue\n\n                # Validate the pole based on problem criteria\n                # 1. Pole in 4th quadrant (Re(k)  0, Im(k)  0)\n                if k_sol.real = 0 or k_sol.imag = 0:\n                    continue\n                \n                # 2. Smallest positive real energy E_r\n                E = k_sol**2 / alpha\n                if E.real = 0:\n                    continue\n                    \n                found_poles.append((E.real, k_sol))\n\n    if not found_poles:\n        return None\n\n    # Sort poles by the real part of the energy\n    found_poles.sort(key=lambda x: x[0])\n    \n    # Filter out duplicate solutions found from different initial guesses\n    unique_poles = []\n    for pole in found_poles:\n        is_duplicate = False\n        for unique_pole in unique_poles:\n            # Check if k-values are very close\n            if np.isclose(pole[1], unique_pole[1], rtol=1e-5, atol=1e-5):\n                is_duplicate = True\n                break\n        if not is_duplicate:\n            unique_poles.append(pole)\n\n    # Return the k of the pole with the smallest positive E_r\n    if unique_poles:\n        return unique_poles[0][1]\n    else:\n        return None\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "3600450"}, {"introduction": "Moving from a single particle to a many-body system, this practice guides you through the construction of a minimalist Gamow Shell Model. You will build a complex-symmetric two-neutron Hamiltonian using a Berggren basis, which includes a resonant state and a discretized scattering continuum, and then introduce a residual pairing interaction. This exercise provides a concrete example of how the Gamow Shell Model combines single-particle information and interactions to describe configuration mixing and correlations in an open quantum system, forming the very core of this theoretical framework [@problem_id:3600461].", "problem": "Implement a minimal two-neutron Gamow Shell Model (GSM) in a single $p_{3/2}$ partial wave using one explicit resonant single-particle state and a discretized non-resonant continuum along a rotated complex-energy contour. Construct the complex-symmetric two-body Hamiltonian for total angular momentum $J=0$ with a rank-one separable pairing residual interaction, and analyze configuration mixing of the resonant-resonant configuration as the pairing strength varies.\n\nYou must start from the following principles and core definitions:\n\n- Berggren completeness: a single-particle basis that includes bound and resonant Gamow states together with a discretized non-resonant continuum along a contour in the complex momentum or energy plane forms a complete set. In computations, the continuum integral is approximated by a quadrature over discretization points with positive weights.\n- For the single partial wave $p_{3/2}$, consider only two-neutron states coupled to total angular momentum $J=0$.\n- The complex-energy single-particle Hamiltonian yields a complex-symmetric two-body Hamiltonian (not Hermitian) when constructed in a Berggren basis. Right eigenvectors solve a generalized complex-symmetric eigenproblem.\n- A separable pairing residual interaction of rank one yields a two-body matrix of the form of an outer product.\n\nBased on these principles, implement the following concrete model choices without introducing any additional assumptions:\n\n1. Single-particle spectrum:\n   - One resonant Gamow pole with complex energy $E_{r} = 2.0 - i\\,0.2$ in mega-electron volts (MeV). Its quadrature weight is fixed to $w_{r} = 1.0$.\n   - A non-resonant continuum represented by $N$ points along a straight line in the complex energy plane parameterized by\n     $$E(s) = s\\,e^{-2 i \\theta}, \\quad s \\in (0, E_{\\max}),$$\n     where $E_{\\max}  0$ is a real energy cutoff and $\\theta  0$ is a rotation angle in radians. Use a midpoint rule with $N$ points:\n     $$s_{n} = \\left(n - \\tfrac{1}{2}\\right)\\frac{E_{\\max}}{N}, \\quad n = 1,2,\\dots,N,$$\n     with continuum quadrature weights\n     $$w_{n} = \\frac{E_{\\max}}{N}.$$\n     The single-particle list is then $\\{(E_{r}, w_{r}), (E(s_{1}), w_{1}), \\dots, (E(s_{N}), w_{N})\\}$.\n\n2. Two-particle $J=0$ basis and Hamiltonian:\n   - Build antisymmetrized two-particle basis states labeled by unordered pairs $(i,j)$ with $i \\le j$, where each index runs over the full single-particle set including the resonance and the $N$ continuum points. All single-particle states are assumed to have the same $j=3/2$.\n   - The unperturbed two-body energy is\n     $$H_{0,(ij),(ij)} = E_{i} + E_{j}.$$\n   - Include a rank-one separable pairing residual interaction\n     $$V = -G\\,|U\\rangle \\langle U|,$$\n     with scalar coupling strength $G \\ge 0$ (in MeV) and pair form factor components\n     $$U_{(ij)} = N_{ij}\\,\\sqrt{w_{i} w_{j}}, \\quad N_{ij} = \\begin{cases} 1  i \\ne j, \\\\ \\tfrac{1}{\\sqrt{2}}  i=j. \\end{cases}$$\n     This produces the complex-symmetric matrix elements\n     $$V_{(ij),(kl)} = -G\\,U_{(ij)}\\,U_{(kl)}.$$\n   - The full two-body Hamiltonian is\n     $$H = H_{0} + V,$$\n     which is complex-symmetric.\n\n3. Eigenproblem and observables:\n   - Diagonalize $H$ to obtain eigenvalues $\\{\\mathcal{E}_{\\alpha}\\}$ and right eigenvectors $\\{|\\Psi_{\\alpha}\\rangle\\}$.\n   - Select the \"ground state\" as the eigenstate with the smallest real part $\\mathrm{Re}\\,\\mathcal{E}_{\\alpha}$.\n   - To analyze configuration mixing, focus on the resonant-resonant configuration $(i=j=\\text{resonance})$. Let $C_{\\mathrm{RR}}$ be the component of the selected right eigenvector along this basis state. For a numerically robust and real-valued mixing measure, normalize the right eigenvector using the standard Euclidean norm, i.e., enforce\n     $$\\sum_{p} |C_{p}|^{2} = 1,$$\n     and define the resonant-resonant mixing weight as\n     $$W_{\\mathrm{RR}} = |C_{\\mathrm{RR}}|^{2}.$$\n\n4. Units and numerical specifications:\n   - All energies must be expressed in mega-electron volts (MeV).\n   - All angles must be in radians.\n   - Report the ground-state energy as the real part $\\mathrm{Re}\\,\\mathcal{E}_{\\mathrm{gs}}$ in MeV, and the mixing weight $W_{\\mathrm{RR}}$ as a dimensionless decimal.\n   - Round both reported numbers to six decimal places.\n\n5. Required output format:\n   - Your program should produce a single line of output containing a list of results for each test case, where each result is itself a two-element list $[\\mathrm{Re}\\,\\mathcal{E}_{\\mathrm{gs}}, W_{\\mathrm{RR}}]$. The final output must be a single line of the form\n     $$\\big[ [x_{1},y_{1}], [x_{2},y_{2}], \\dots \\big],$$\n     where each $x_{k}$ and $y_{k}$ is a decimal rounded to six places, with no extra spaces.\n\nTest suite to implement and evaluate:\n\n- Case A (happy path): $G = 0.25$ MeV, $N = 6$, $E_{\\max} = 10.0$ MeV, $\\theta = 0.34906585$ radians.\n- Case B (zero coupling boundary): $G = 0.0$ MeV, $N = 6$, $E_{\\max} = 10.0$ MeV, $\\theta = 0.34906585$ radians.\n- Case C (denser continuum, stronger pairing): $G = 0.75$ MeV, $N = 10$, $E_{\\max} = 12.0$ MeV, $\\theta = 0.261799388$ radians.\n- Case D (edge case with minimal continuum): $G = 1.2$ MeV, $N = 1$, $E_{\\max} = 8.0$ MeV, $\\theta = 0.34906585$ radians.\n\nYour program must construct the Hamiltonian exactly as specified, solve for the ground state according to the criterion above, compute $W_{\\mathrm{RR}}$ under Euclidean normalization, and print a single line containing the four results as a comma-separated list enclosed in square brackets, for example\n$$[[x_{A},y_{A}],[x_{B},y_{B}],[x_{C},y_{C}],[x_{D},y_{D}]].$$", "solution": "The problem presents a valid, well-posed, and scientifically grounded task within the domain of computational nuclear physics. It requires the implementation of a minimal two-neutron Gamow Shell Model (GSM) for a single $p_{3/2}$ partial wave, exploring configuration mixing under a separable pairing interaction. The problem statement is self-contained, providing all necessary physical principles, mathematical definitions, and numerical parameters to construct and solve the model. We shall proceed with a systematic, step-by-step derivation and construction of the solution.\n\nThe core of the problem lies in constructing and diagonalizing a complex-symmetric many-body Hamiltonian. This Hamiltonian is built upon a single-particle basis, known as the Berggren basis, which is specifically designed for open quantum systems. Such systems are characterized by the possibility of particle emission, leading to states with finite lifetimes (resonances), which are described by complex energies.\n\n**Step 1: Construction of the Single-Particle Berggren Basis**\n\nThe foundation of the model is the single-particle basis, which, according to the Berggren completeness relation, comprises bound states, resonant (Gamow) states, and a discretized non-resonant continuum. The problem specifies a basis consisting of one resonant state and a discretized continuum contour. Let the total number of single-particle states be $K = N+1$. We label these states with an index $i \\in \\{0, 1, \\dots, N\\}$.\n\n1.  **Resonant State ($i=0$):**\n    A single resonant pole is given with a complex energy $E_0$ and an associated quadrature weight $w_0$:\n    $$E_0 = E_r = (2.0 - i\\,0.2) \\, \\mathrm{MeV}$$\n    $$w_0 = w_r = 1.0$$\n\n2.  **Discretized Continuum States ($i=1, \\dots, N$):**\n    The continuum is represented by $N$ states along a rotated contour in the complex energy plane, $E(s) = s\\,e^{-2i\\theta}$. The integral over the continuum is approximated by a quadrature sum using a midpoint rule. The $n$-th discretization point along the contour path, $s_n$, and its associated energy $E_n$ and weight $w_n$ are given by:\n    $$s_n = \\left(n - \\frac{1}{2}\\right) \\frac{E_{\\max}}{N}, \\quad \\text{for } n = 1, 2, \\dots, N$$\n    The corresponding complex energies for the continuum states (which we index from $i=1$ to $N$) are:\n    $$E_i = s_i \\, e^{-2i\\theta}, \\quad \\text{for } i = 1, 2, \\dots, N$$\n    The quadrature weights for these continuum states are:\n    $$w_i = \\frac{E_{\\max}}{N}, \\quad \\text{for } i = 1, 2, \\dots, N$$\n    This defines the complete set of single-particle energies $\\{E_i\\}_{i=0}^{N}$ and weights $\\{w_i\\}_{i=0}^{N}$.\n\n**Step 2: Construction of the Two-Body Hamiltonian for $J=0$**\n\nThe two-neutron Hamiltonian $H$ is the sum of the unperturbed two-body Hamiltonian $H_0$ and a residual pairing interaction $V$. We construct this Hamiltonian in a basis of antisymmetrized two-particle states $|\\phi_{ij}\\rangle$ formed from the single-particle states previously defined. For two neutrons in the same $j=3/2$ shell coupled to total angular momentum $J=0$, the basis states can be indexed by unordered pairs $(i,j)$ with $i, j \\in \\{0, 1, \\dots, N\\}$ and $i \\le j$.\n\nThe dimension of this two-body Hilbert space is $M = \\frac{(N+1)(N+2)}{2}$. We establish a mapping from a single matrix index $p \\in \\{0, 1, \\dots, M-1\\}$ to the pair indices $(i,j)$ by ordering them lexicographically, i.e., $(0,0), (0,1), \\dots, (0,N), (1,1), \\dots, (N,N)$.\n\n1.  **Unperturbed Hamiltonian ($H_0$):**\n    In this basis, $H_0$ is diagonal. The energy of a two-body state where the neutrons occupy single-particle states $i$ and $j$ is simply the sum of their energies.\n    $$H_{0,p,q} = (E_i + E_j) \\, \\delta_{pq}$$\n    where the pair $(i,j)$ corresponds to index $p$.\n\n2.  **Separable Pairing Interaction ($V$):**\n    The interaction is given as a rank-one separable potential, $V = -G |U\\rangle\\langle U|$, where $G$ is the pairing strength and $|U\\rangle$ is a vector of pair form factors in the two-body basis. The matrix elements of $V$ are:\n    $$V_{p,q} = -G \\, U_p \\, U_q$$\n    where $p$ and $q$ correspond to pairs $(i,j)$ and $(k,l)$ respectively. The component $U_p$ corresponding to the pair $(i,j)$ is defined as:\n    $$U_p \\equiv U_{(ij)} = N_{ij} \\sqrt{w_i w_j}$$\n    The normalization factor $N_{ij}$ arises from the antisymmetrization of the two-neutron wavefunction:\n    $$N_{ij} = \\begin{cases} \\frac{1}{\\sqrt{2}}  \\text{if } i = j \\\\ 1  \\text{if } i \\ne j \\end{cases}$$\n\n3.  **Full Hamiltonian ($H$):**\n    The full Hamiltonian matrix is the sum $H = H_0 + V$.\n    $$H_{p,q} = (E_i + E_j) \\, \\delta_{pq} - G \\, U_p \\, U_q$$\n    This matrix is complex and symmetric ($H = H^T$), but not Hermitian ($H \\ne H^\\dagger$), a characteristic feature of Hamiltonians in a Berggren basis.\n\n**Step 3: Eigenproblem Solution and Observable Calculation**\n\nThe final step is to solve the time-independent Schrödinger equation for the two-neutron system, which takes the form of a matrix eigenvalue problem:\n$$H |\\Psi_\\alpha\\rangle = \\mathcal{E}_\\alpha |\\Psi_\\alpha\\rangle$$\nWe use a standard numerical eigensolver capable of handling complex, non-Hermitian matrices to find the complex eigenvalues $\\{\\mathcal{E}_\\alpha\\}$ and their corresponding right eigenvectors $\\{|\\Psi_\\alpha\\rangle\\}$.\n\n1.  **Ground State Identification:**\n    The problem defines the ground state as the eigenstate with the eigenvalue having the smallest real part. The real part of a complex eigenvalue is interpreted as the energy of the many-body state, a convention in open quantum system theory.\n    $$\\mathcal{E}_{\\mathrm{gs}} = \\min_{\\alpha} \\{\\mathrm{Re}(\\mathcal{E}_\\alpha)\\}$$\n    We identify this eigenvalue $\\mathcal{E}_{\\mathrm{gs}}$ and its associated eigenvector $|\\Psi_{\\mathrm{gs}}\\rangle$.\n\n2.  **Configuration Mixing Analysis:**\n    We are interested in the probability of finding the system in the resonant-resonant (RR) configuration, where both neutrons occupy the resonant Gamow state ($i=j=0$).\n    -   Identify the basis state corresponding to the RR configuration. In our lexicographical ordering, this corresponds to the first basis state, $p=0$.\n    -   Let the components of the ground-state eigenvector be $C_p$, i.e., $|\\Psi_{\\mathrm{gs}}\\rangle = \\sum_p C_p |\\phi_p\\rangle$. The RR component is $C_{\\mathrm{RR}} = C_0$.\n    -   The problem specifies a non-standard Euclidean normalization for the eigenvector to compute the mixing weight. We normalize the eigenvector such that $\\sum_p |C_p|^2 = 1$.\n    -   The mixing weight $W_{\\mathrm{RR}}$ is then defined as the squared magnitude of the normalized RR component:\n    $$W_{\\mathrm{RR}} = |C_{\\mathrm{RR}}|^2 / \\sum_{p=0}^{M-1} |C_p|^2$$\n\nThe algorithm proceeds by implementing these three steps for each given test case, calculating the ground-state energy $\\mathrm{Re}(\\mathcal{E}_{\\mathrm{gs}})$ and the mixing weight $W_{\\mathrm{RR}}$, and reporting the results to the specified precision.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Implements a minimal two-neutron Gamow Shell Model (GSM) to analyze configuration\n    mixing in an open quantum system.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: Happy path\n        # G (MeV), N, E_max (MeV), theta (rad)\n        (0.25, 6, 10.0, 0.34906585),\n        # Case B: Zero coupling boundary\n        (0.0, 6, 10.0, 0.34906585),\n        # Case C: Denser continuum, stronger pairing\n        (0.75, 10, 12.0, 0.261799388),\n        # Case D: Edge case with minimal continuum\n        (1.2, 1, 8.0, 0.34906585)\n    ]\n\n    results = []\n    for G, N, E_max, theta in test_cases:\n        # Step 1: Construct the single-particle Berggren basis\n        # The basis consists of one resonant state and N continuum states.\n        \n        # Resonant state (index 0)\n        E_r = 2.0 - 0.2j\n        w_r = 1.0\n\n        num_sp_states = N + 1\n        sp_energies = np.zeros(num_sp_states, dtype=np.complex128)\n        sp_weights = np.zeros(num_sp_states, dtype=np.float64)\n\n        sp_energies[0] = E_r\n        sp_weights[0] = w_r\n\n        # Discretized continuum states (indices 1 to N)\n        if N  0:\n            s_n = (np.arange(1, N + 1) - 0.5) * E_max / N\n            continuum_energies = s_n * np.exp(-2j * theta)\n            continuum_weights = np.full(N, E_max / N)\n            \n            sp_energies[1:] = continuum_energies\n            sp_weights[1:] = continuum_weights\n\n        # Step 2: Construct the two-body Hamiltonian for J=0\n        \n        # Create a mapping from a flat matrix index 'p' to a pair of sp state indices (i, j)\n        basis_pairs = []\n        for i in range(num_sp_states):\n            for j in range(i, num_sp_states):\n                basis_pairs.append((i, j))\n        \n        dim = len(basis_pairs)\n        H = np.zeros((dim, dim), dtype=np.complex128)\n\n        # Construct H0 (diagonal part) and the U vector for the interaction\n        U = np.zeros(dim, dtype=np.float64)\n        for p, (i, j) in enumerate(basis_pairs):\n            # Unperturbed energy\n            H[p, p] = sp_energies[i] + sp_energies[j]\n            \n            # Form factor component U_p\n            N_ij = 1.0 / np.sqrt(2.0) if i == j else 1.0\n            U[p] = N_ij * np.sqrt(sp_weights[i] * sp_weights[j])\n\n        # Construct V (interaction part) and add to H\n        # V is a rank-one matrix: V = -G * |UU|\n        if G  0:\n            V = -G * np.outer(U, U)\n            H += V\n        \n        # Step 3: Solve the eigenproblem and compute observables\n        \n        eigenvalues, eigenvectors = linalg.eig(H)\n        \n        # Find the ground state: the one with the smallest real part of the eigenvalue\n        gs_idx = np.argmin(eigenvalues.real)\n        gs_energy = eigenvalues[gs_idx]\n        gs_vector = eigenvectors[:, gs_idx]\n        \n        # Calculate the ground state energy (real part)\n        Re_E_gs = gs_energy.real\n        \n        # Analyze configuration mixing. The resonant-resonant (RR) configuration\n        # corresponds to the pair (0,0), which is the first state in our basis (p=0).\n        rr_idx = 0\n        C_rr = gs_vector[rr_idx]\n        \n        # Normalize the eigenvector using the standard Euclidean norm as specified\n        norm_sq = np.sum(np.abs(gs_vector)**2)\n        \n        # Calculate the mixing weight W_RR\n        W_rr = np.abs(C_rr)**2 / norm_sq\n\n        # Store rounded results\n        results.append([round(Re_E_gs, 6), round(W_rr, 6)])\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"[{res[0]},{res[1]}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3600461"}, {"introduction": "A practical challenge in any shell model calculation is identifying the physical state of interest among a spectrum of many eigenvalues. In the Gamow Shell Model, this is compounded by the presence of numerous complex eigenvalues arising from the discretized continuum. This practice introduces a powerful numerical technique, based on complex scaling, to distinguish a true resonance from these background states. By tracking the flow of eigenvalues as a function of a rotation angle $\\theta$, you will learn how to isolate a stationary resonance pole, a crucial skill for interpreting the results of realistic calculations in open quantum systems [@problem_id:3600500].", "problem": "You are asked to implement a minimal non-Hermitian two-level model that captures key features of the Gamow shell model for weakly bound and resonant single-particle states. The focus is to compute overlaps and eigenvalue flows under a complex-rotation parameter to isolate the physically meaningful $1/2^+$ resonance from non-resonant background states. The implementation must be a complete program.\n\nStart from the following fundamental base:\n\n- In the Gamow shell model, the single-particle Hamiltonian is represented in a Berggren basis that includes bound, resonant, and non-resonant scattering states. This representation leads to a complex-symmetric Hamiltonian due to outgoing-wave boundary conditions. The appropriate bilinear form is the complex-symmetric product (often called the $c$-product), not the Hermitian inner product.\n- Under exterior complex scaling or contour rotation by an angle $ \\theta $ (in radians), non-resonant continuum contributions rotate in the complex energy plane, while the position of a resonance pole is invariant when analytically continued. This property enables isolation of resonance poles by tracking eigenvalue flows as a function of $ \\theta $ and by using overlaps to maintain continuity of the physical branch.\n\nModel specification:\n\n- Consider a two-dimensional basis with a weakly bound $ s_{1/2} $-like state and a resonant $ p_{3/2} $-like state. In this reduced model, the complex-symmetric Hamiltonian is defined as\n$$\nH(\\theta,g) = \n\\begin{pmatrix}\nE_s^{(0)} + \\Sigma_s(\\theta,g)  V(\\theta,g) \\\\\nV(\\theta,g)  E_p^{(0)} - \\tfrac{i}{2}\\Gamma_p^{(0)} + \\Sigma_p(\\theta,g)\n\\end{pmatrix},\n$$\nwith coupling parameter $ g \\ge 0 $ and rotation angle $ \\theta \\ge 0 $ (in radians). The parametrizations are\n$$\nV(\\theta,g) = g\\, e^{i \\theta}, \\quad\n\\Sigma_s(\\theta,g) = a_s\\, g^2\\, e^{2 i \\theta}, \\quad\n\\Sigma_p(\\theta,g) = a_p\\, g^2\\, e^{2 i \\theta},\n$$\nwhere $ a_s $ and $ a_p $ are real constants.\n\n- Take the $ c $-product for vectors $ \\mathbf{u} $ and $ \\mathbf{v} $ to be $ \\mathbf{u}^T \\mathbf{v} $ (transpose without complex conjugation). When comparing directions or normalizing, use this $ c $-product.\n\nObjective:\n\n- For a given set of parameters $ (E_s^{(0)}, E_p^{(0)}, \\Gamma_p^{(0)}, a_s, a_p, g) $ and a discrete grid of angles $ \\{\\theta_k\\} $, compute, at each $ \\theta_k $, the eigenvalues and $ c $-normalized eigenvectors of $ H(\\theta_k,g) $.\n- Initialize a seed vector $ \\mathbf{s} = (1,0)^T $ to represent the $ s_{1/2} $ structure. At the initial angle $ \\theta_0 $, select the eigenvector whose absolute $ c $-overlap $ \\left|\\mathbf{s}^T \\mathbf{v}\\right| $ is maximal and label its eigenvalue as the current estimate of the $ 1/2^+ $ pole. For each subsequent $ \\theta_k $, select the eigenvector that maximizes the absolute $ c $-overlap with the previously selected eigenvector. This defines a continuous eigenvalue flow.\n- At the final angle in the grid, report the complex energy $ E_{\\text{res}} $ of the tracked branch and the corresponding width $ \\Gamma_{\\text{res}} = -2\\, \\mathrm{Im}(E_{\\text{res}}) $. Express energies and widths in megaelectronvolts (MeV).\n\nAngle unit requirement:\n\n- All angles $ \\theta $ must be interpreted in radians.\n\nPhysical units requirement:\n\n- All energies and widths must be reported in megaelectronvolts (MeV) as floating-point numbers.\n\nTest suite:\n\nUse the following constants for all tests unless otherwise specified: $ a_s = 0.25 $, $ a_p = -0.15 $, and the angle grid $ \\{\\theta_k\\} = \\{0.0, 0.1, 0.2, 0.3\\} $ (radians).\n\nProvide results for the following four parameter sets:\n\n- Case 1 (happy path, weak coupling): $ E_s^{(0)} = -0.30 $ MeV, $ E_p^{(0)} = 1.10 $ MeV, $ \\Gamma_p^{(0)} = 0.30 $ MeV, $ g = 0.15 $.\n- Case 2 (stronger coupling): $ E_s^{(0)} = -0.30 $ MeV, $ E_p^{(0)} = 1.10 $ MeV, $ \\Gamma_p^{(0)} = 0.30 $ MeV, $ g = 0.35 $.\n- Case 3 (near-threshold $ s $ state): $ E_s^{(0)} = -0.05 $ MeV, $ E_p^{(0)} = 1.10 $ MeV, $ \\Gamma_p^{(0)} = 0.30 $ MeV, $ g = 0.25 $.\n- Case 4 (boundary, zero coupling): $ E_s^{(0)} = -0.30 $ MeV, $ E_p^{(0)} = 1.10 $ MeV, $ \\Gamma_p^{(0)} = 0.30 $ MeV, $ g = 0.00 $.\n\nRequired final output format:\n\n- Your program should produce a single line of output containing the results as a comma-separated list of lists. For each case, output a list of three floating-point numbers $ [\\mathrm{Re}(E_{\\text{res}}), \\mathrm{Im}(E_{\\text{res}}), \\Gamma_{\\text{res}}] $ in MeV, in the same order as the test cases above. For example:\n\"[ [x1,y1,z1], [x2,y2,z2], [x3,y3,z3], [x4,y4,z4] ]\"\nwith no additional text. The imaginary part $ \\mathrm{Im}(E_{\\text{res}}) $ should be negative for decaying resonances. All angles are in radians and all energies are in MeV.", "solution": "The problem requires tracking an eigenvalue of a parameter-dependent, complex-symmetric Hamiltonian. This procedure simulates the identification of a physical resonance by exploiting its invariance under the rotation of the complex-energy contour, which distinguishes it from the rotating non-resonant continuum states. The solution involves constructing the Hamiltonian, diagonalizing it at discrete rotation angles, and following the correct eigenvalue branch using an overlap criterion.\n\n**1. Hamiltonian Construction**\n\nFor each rotation angle $\\theta_k$ in the provided grid and a given coupling strength $g$, the $2 \\times 2$ complex-symmetric Hamiltonian matrix $H(\\theta_k, g)$ is constructed. The parameter-dependent components are:\n$$\nV(\\theta,g) = g\\, e^{i \\theta} \\\\\n\\Sigma_s(\\theta,g) = a_s\\, g^2\\, e^{2 i \\theta} \\\\\n\\Sigma_p(\\theta,g) = a_p\\, g^2\\, e^{2 i \\theta}\n$$\nThese are substituted into the Hamiltonian matrix definition:\n$$\nH(\\theta,g) = \n\\begin{pmatrix}\nE_s^{(0)} + \\Sigma_s(\\theta,g)  V(\\theta,g) \\\\\nV(\\theta,g)  E_p^{(0)} - \\tfrac{i}{2}\\Gamma_p^{(0)} + \\Sigma_p(\\theta,g)\n\\end{pmatrix}\n$$\nThis is performed for each angle $\\theta_k$ in the sequence.\n\n**2. Eigenproblem and $c$-Normalization**\n\nAt each step $\\theta_k$, the complex-symmetric matrix $H(\\theta_k, g)$ is diagonalized to find its two complex eigenvalues, $\\{E_1, E_2\\}$, and their corresponding right eigenvectors, $\\{\\mathbf{v}_1, \\mathbf{v}_2\\}$.\n$$\nH \\mathbf{v}_j = E_j \\mathbf{v}_j, \\quad j=1,2\n$$\nThe problem specifies the use of the $c$-product for calculating overlaps. Therefore, the eigenvectors must be $c$-normalized. A raw eigenvector $\\mathbf{v}$ obtained from a numerical library is re-normalized to $\\mathbf{v}_c$ such that its $c$-norm is unity:\n$$\n\\mathbf{v}_c = \\frac{\\mathbf{v}}{\\sqrt{\\mathbf{v}^T \\mathbf{v}}}\n$$\nThis ensures that $\\mathbf{v}_c^T \\mathbf{v}_c = 1$. The principal branch of the complex square root is used.\n\n**3. Eigenvalue Tracking by Overlap**\n\nA continuous branch of eigenvalues is tracked across the angle grid by maximizing the $c$-overlap between eigenvectors at successive steps.\n- **Initialization ($\\theta_0 = 0.0$):** The process starts with a seed vector $\\mathbf{s} = (1,0)^T$, representing the unperturbed $s_{1/2}$ state. The two $c$-normalized eigenvectors at $\\theta_0$, $\\{\\mathbf{v}_{1,c}, \\mathbf{v}_{2,c}\\}$, are computed. The one with the largest absolute $c$-overlap with the seed vector, $\\max_j |\\mathbf{s}^T \\mathbf{v}_{j,c}|$, is selected. This eigenvector and its corresponding eigenvalue become the starting point of the tracked branch. Let's call them $\\mathbf{v}_{\\text{tracked}}^{(0)}$ and $E_{\\text{tracked}}^{(0)}$.\n- **Iteration ($k > 0$):** For each subsequent angle $\\theta_k$, the new $c$-normalized eigenvectors are compared to the tracked eigenvector from the previous step, $\\mathbf{v}_{\\text{tracked}}^{(k-1)}$. The new eigenvector $\\mathbf{v}_{j,c}^{(k)}$ that maximizes the absolute $c$-overlap, $\\max_j |\\left(\\mathbf{v}_{\\text{tracked}}^{(k-1)}\\right)^T \\mathbf{v}_{j,c}^{(k)}|$, is selected. This new eigenvector and its eigenvalue become the next state in the branch: $\\mathbf{v}_{\\text{tracked}}^{(k)}$ and $E_{\\text{tracked}}^{(k)}$.\n\nThis procedure ensures that the algorithm follows a single, continuous trajectory in the complex energy plane, corresponding to the evolution of the physical state of interest.\n\n**4. Final Result**\n\nAfter iterating through all angles in the grid, the final tracked eigenvalue is identified as the resonance energy, $E_{\\text{res}} = E_{\\text{tracked}}^{(\\text{final})}$. The resonance width is then calculated using the definition provided:\n$$\n\\Gamma_{\\text{res}} = -2 \\times \\mathrm{Im}(E_{\\text{res}})\n$$\nThis algorithm is applied to each of the four test cases to obtain the required results.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_resonance_flow(params, a_s, a_p, theta_grid):\n    \"\"\"\n    Computes the resonance energy and width by tracking an eigenvalue flow.\n    For a given set of model parameters, this function iterates over a grid of\n    complex rotation angles, constructs and diagonalizes the Hamiltonian at each\n    angle, and tracks one of the eigenvalues based on an overlap criterion.\n\n    Args:\n        params (tuple): A tuple containing the model parameters \n                        (Es0, Ep0, Gp0, g).\n        a_s (float): The coupling constant for the s-state self-energy.\n        a_p (float): The coupling constant for the p-state self-energy.\n        theta_grid (np.ndarray): An array of rotation angles in radians.\n\n    Returns:\n        list: A list containing [Re(E_res), Im(E_res), Gamma_res] in MeV.\n    \"\"\"\n    # Unpack parameters\n    Es0, Ep0, Gp0, g = params\n\n    # Seed vector for tracking, representing the s_1/2 state\n    tracked_eigvec = np.array([1.0, 0.0], dtype=np.complex128)\n    tracked_eigval = None\n\n    for theta in theta_grid:\n        # Construct the complex-symmetric Hamiltonian H(theta, g)\n        V = g * np.exp(1j * theta)\n        Sigma_s = a_s * g**2 * np.exp(2j * theta)\n        Sigma_p = a_p * g**2 * np.exp(2j * theta)\n\n        H = np.array([\n            [Es0 + Sigma_s, V],\n            [V, Ep0 - 0.5j * Gp0 + Sigma_p]\n        ], dtype=np.complex128)\n\n        # Diagonalize the Hamiltonian. numpy.linalg.eig returns eigenvectors\n        # normalized to Euclidean norm 1, which we must c-normalize next.\n        eigenvalues, eigenvectors = np.linalg.eig(H)\n        \n        # Eigenvalues and corresponding eigenvectors\n        e1, e2 = eigenvalues[0], eigenvalues[1]\n        v1, v2 = eigenvectors[:, 0], eigenvectors[:, 1]\n\n        # C-normalization of eigenvectors: v_cnorm = v / sqrt(v^T v)\n        # For 1D numpy arrays, v.T @ v is the same as v @ v.\n        norm_sq1 = v1 @ v1\n        norm_sq2 = v2 @ v2\n        \n        # The problem is well-posed, so norm_sq is not expected to be zero.\n        v1_c = v1 / np.sqrt(norm_sq1)\n        v2_c = v2 / np.sqrt(norm_sq2)\n\n        # Calculate absolute c-overlaps with the tracked eigenvector from the\n        # previous step. For the first step, tracked_eigvec is the seed vector.\n        overlap1 = np.abs(tracked_eigvec @ v1_c)\n        overlap2 = np.abs(tracked_eigvec @ v2_c)\n\n        # Select the eigenvector that maximizes the overlap to ensure branch continuity.\n        if overlap1  overlap2:\n            tracked_eigvec = v1_c\n            tracked_eigval = e1\n        else:\n            tracked_eigvec = v2_c\n            tracked_eigval = e2\n            \n    # The final tracked eigenvalue is the resonance energy E_res\n    E_res = tracked_eigval\n    # The resonance width is defined as Gamma_res = -2 * Im(E_res)\n    Gamma_res = -2 * np.imag(E_res)\n\n    return [np.real(E_res), np.imag(E_res), Gamma_res]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    # Fixed constants for all tests\n    a_s = 0.25\n    a_p = -0.15\n    theta_grid = np.array([0.0, 0.1, 0.2, 0.3])\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (E_s^(0), E_p^(0), Gamma_p^(0), g)\n    test_cases = [\n        (-0.30, 1.10, 0.30, 0.15),  # Case 1: Weak coupling\n        (-0.30, 1.10, 0.30, 0.35),  # Case 2: Stronger coupling\n        (-0.05, 1.10, 0.30, 0.25),  # Case 3: Near-threshold s-state\n        (-0.30, 1.10, 0.30, 0.00),  # Case 4: Zero coupling\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_resonance_flow(case, a_s, a_p, theta_grid)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Format: \"[[x1,y1,z1],[x2,y2,z2],[x3,y3,z3],[x4,y4,z4]]\"\n    result_strings = []\n    for res in results:\n        # Format each inner list without spaces.\n        result_strings.append(f\"[{res[0]},{res[1]},{res[2]}]\")\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3600500"}]}