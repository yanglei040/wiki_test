{"hands_on_practices": [{"introduction": "This first practice introduces the foundational liquid-drop model for nuclear pasta within a Wigner-Seitz cell, a cornerstone for understanding phase competition in dense matter. You will implement a numerical solution to determine the preferred geometry—droplets, rods, or slabs—by minimizing the total energy, which is a sum of competing surface and Coulomb contributions. This exercise [@problem_id:3579770] builds essential skills in solving boundary value problems with finite differences and performing numerical optimization, providing a direct, hands-on feel for the core physics driving the formation of pasta phases.", "problem": "You are asked to write a complete, runnable program that determines the preferred nuclear pasta geometry as the baryon number density increases, by comparing minimized free-energy densities for three candidate geometries: spheres ($d=3$; \"droplets\"), cylinders ($d=2$; \"rods\"), and slabs ($d=1$; \"slabs\"). The comparison must be performed at each specified baryon number density by minimizing the sum of surface and Coulomb contributions to the free-energy density for each geometry, using the prescribed surface tension, proton fraction, and linear electron screening model.\n\nThe physical and numerical model to implement is as follows.\n\n1. Geometry and Wigner–Seitz construction. For each geometry dimension $d \\in \\{1,2,3\\}$, assume a periodic arrangement of identical clusters described by a Wigner–Seitz cell of radius $R_{\\mathrm{c}}$ and an inner cluster size $r_{\\mathrm{N}}$. The baryon number density is $n$ (in $\\mathrm{fm}^{-3}$). The dense nuclear phase inside the cluster has a fixed baryon number density $n_{\\mathrm{in}} = 0.16\\,\\mathrm{fm}^{-3}$. The volume fraction occupied by the dense phase is\n$$\nu = \\frac{n}{n_{\\mathrm{in}}}, \\quad \\text{clamped to } 10^{-2} \\le u \\le 0.99 \\text{ for numerical stability}.\n$$\nThe Wigner–Seitz relation between the cluster size and cell radius is\n$$\nu = \\left(\\frac{r_{\\mathrm{N}}}{R_{\\mathrm{c}}}\\right)^{d} \\quad \\Rightarrow \\quad R_{\\mathrm{c}} = \\frac{r_{\\mathrm{N}}}{u^{1/d}}.\n$$\nUse $d=3$ for spheres, $d=2$ for cylinders, and $d=1$ for slabs.\n\n2. Proton fraction and electron density. The proton fraction is prescribed as a function of $n$ by\n$$\nY_{p}(n) = 0.05 + 0.1 \\exp\\!\\left(-\\frac{n}{0.06\\,\\mathrm{fm}^{-3}}\\right).\n$$\nThe proton number density inside the dense phase is $n_{p,\\mathrm{in}}(n)=Y_{p}(n)\\,n_{\\mathrm{in}}$. Electrons provide global charge neutrality and are treated in linear response via a screening length that depends on the average electron density $n_{e} = u\\,n_{p,\\mathrm{in}}$.\n\n3. Surface energy density. The surface tension is prescribed as\n$$\n\\sigma(n) = \\max\\!\\left(0.3, \\, 1.0 - 0.4\\,\\frac{n}{0.16\\,\\mathrm{fm}^{-3}}\\right)\\ \\mathrm{MeV/fm^{2}},\n$$\nand the surface energy density for a given geometry is\n$$\n\\varepsilon_{S}(d,n,r_{\\mathrm{N}}) = \\frac{d\\,\\sigma(n)\\,u}{r_{\\mathrm{N}}}\\ \\mathrm{MeV/fm^{3}}.\n$$\n\n4. Electron screening length. Model ultra-relativistic electron screening with an empirical screening length that depends on the average electron density $n_{e}$:\n$$\n\\lambda_{e}(n) = 20\\,\\mathrm{fm}\\ \\left(\\frac{0.05\\,\\mathrm{fm}^{-3}}{n_{e}}\\right)^{1/3}.\n$$\n\n5. Coulomb energy density by screened Poisson problem. Treat the Coulomb energy by solving a one-dimensional radial screened Poisson equation in divergence form for each geometry:\n$$\n\\frac{1}{r^{d-1}} \\frac{d}{dr} \\!\\left(r^{d-1} \\frac{d\\phi}{dr}\\right) - \\frac{\\phi}{\\lambda_{e}^{2}} = - \\rho_{p}(r),\n$$\nwith Neumann boundary conditions $d\\phi/dr\\vert_{r=0} = 0$ and $d\\phi/dr\\vert_{r=R_{\\mathrm{c}}} = 0$. The proton charge density is taken as uniform inside the cluster and zero outside,\n$$\n\\rho_{p}(r) = \\begin{cases}\nn_{p,\\mathrm{in}}(n),  0 \\le r  r_{\\mathrm{N}},\\\\\n0,  r_{\\mathrm{N}} \\le r \\le R_{\\mathrm{c}}.\n\\end{cases}\n$$\nYou must discretize the equation in $r \\in [0, R_{\\mathrm{c}}]$ using a conservative finite-difference scheme in divergence form that is numerically stable at $r=0$ for $d \\in \\{1,2,3\\}$. Compute the Coulomb energy density as\n$$\n\\varepsilon_{C}(d,n,r_{\\mathrm{N}}) = \\frac{1}{2 V_{\\mathrm{cell}}} \\int_{0}^{R_{\\mathrm{c}}} \\rho_{p}(r)\\,\\phi(r)\\, S_{d}\\, r^{d-1}\\, dr,\n$$\nwhere $S_{1}=2$, $S_{2}=2\\pi$, $S_{3}=4\\pi$, and the cell volume is $V_{\\mathrm{cell}} = S_{d} R_{\\mathrm{c}}^{d}/d$. The overall electromagnetic constant is absorbed into units so that only relative comparisons across geometries at the same $n$ are required; the program must ensure internally consistent scaling across geometries.\n\n6. Total free-energy density and minimization. For each geometry and each density $n$, minimize\n$$\n\\varepsilon_{\\mathrm{tot}}(d,n,r_{\\mathrm{N}}) = \\varepsilon_{S}(d,n,r_{\\mathrm{N}}) + \\varepsilon_{C}(d,n,r_{\\mathrm{N}})\n$$\nwith respect to $r_{\\mathrm{N}}$ over a physically reasonable domain $r_{\\mathrm{N}} \\in [0.5\\,\\mathrm{fm},\\,30\\,\\mathrm{fm}]$, using a robust one-dimensional search. The minimization must be performed independently for each geometry.\n\n7. Phase selection. For each density $n$, select the geometry $d$ that yields the smallest minimized $\\varepsilon_{\\mathrm{tot}}(d,n)$.\n\n8. Output encoding. Encode the selected geometry for each density as an integer:\n- $3$ for spheres ($d=3$),\n- $2$ for cylinders ($d=2$),\n- $1$ for slabs ($d=1$).\n\nThe final output should be a single line containing the results for the entire test suite as a comma-separated list enclosed in square brackets.\n\nTest suite. Use the following baryon number densities (in $\\mathrm{fm}^{-3}$) as inputs:\n- Happy-path, low to moderate densities where droplet and rod phases compete: $n \\in \\{0.01,\\,0.03,\\,0.06\\}$.\n- Crossover regime where rods and slabs compete: $n \\in \\{0.09,\\,0.12\\}$.\n- High sub-saturation density close to $n_{\\mathrm{in}}$ to probe slab dominance: $n = 0.15$.\n\nYour program should produce a single line of output containing the integer-encoded preferred geometries for these densities, in the same order, as a comma-separated list enclosed in square brackets (for example, \"[3,3,2,1,1,1]\"). No other output is permitted. Since the outputs are integer codes, no physical units are required for the final answer line.", "solution": "The problem statement has been critically validated and is deemed valid. It presents a scientifically grounded, well-posed, and objective computational task rooted in the field of nuclear astrophysics. The model, while simplified, is based on established principles for studying \"nuclear pasta\" phases, namely the competition between surface and Coulomb energies within a Wigner-Seitz cell framework. All necessary equations, constants, and numerical parameters are provided, forming a self-contained and consistent problem definition. I will now proceed with the solution.\n\nThe core task is to determine the thermodynamically preferred nuclear geometry—spheres ($d=3$), cylinders ($d=2$), or slabs ($d=1$)—as a function of the average baryon number density, $n$. The preferred geometry is that which minimizes the total free-energy density, $\\varepsilon_{\\mathrm{tot}}$, which is the sum of a surface contribution, $\\varepsilon_S$, and a Coulomb contribution, $\\varepsilon_C$.\n\nFor a given geometry dimension $d$ and baryon density $n$, the total energy density is a function of the size $r_{\\mathrm{N}}$ of the dense nuclear clusters:\n$$\n\\varepsilon_{\\mathrm{tot}}(d, n, r_{\\mathrm{N}}) = \\varepsilon_{S}(d, n, r_{\\mathrm{N}}) + \\varepsilon_{C}(d, n, r_{\\mathrm{N}})\n$$\nOur methodology involves two main steps for each specified density $n$:\n1. For each geometry $d \\in \\{1, 2, 3\\}$, we minimize $\\varepsilon_{\\mathrm{tot}}(d, n, r_{\\mathrm{N}})$ with respect to the cluster size $r_{\\mathrm{N}}$ over the specified domain $r_{\\mathrm{N}} \\in [0.5\\,\\mathrm{fm},\\,30\\,\\mathrm{fm}]$. This yields a minimized energy for each geometry, $\\varepsilon_{\\mathrm{min}}(d, n) = \\min_{r_{\\mathrm{N}}} \\varepsilon_{\\mathrm{tot}}(d, n, r_{\\mathrm{N}})$.\n2. We compare these minimized energies and select the geometry $d^*$ that has the lowest energy: $\\varepsilon_{\\mathrm{min}}(d^*, n) \\le \\varepsilon_{\\mathrm{min}}(d, n)$ for all $d \\in \\{1, 2, 3\\}$.\n\nThe surface energy density, $\\varepsilon_S$, is given by:\n$$\n\\varepsilon_{S}(d,n,r_{\\mathrm{N}}) = \\frac{d\\,\\sigma(n)\\,u}{r_{\\mathrm{N}}}\n$$\nwhere $\\sigma(n)$ is the prescribed surface tension and $u = n/n_{\\mathrm{in}}$ is the volume fraction of the dense phase. This term favors larger structures (increasing $r_{\\mathrm{N}}$) to minimize the surface-to-volume ratio.\n\nThe Coulomb energy density, $\\varepsilon_C$, arises from the repulsion of protons within the cluster, screened by a surrounding electron gas. It is calculated by solving the one-dimensional radial screened Poisson equation for the electrostatic potential $\\phi(r)$:\n$$\n\\frac{1}{r^{d-1}} \\frac{d}{dr} \\!\\left(r^{d-1} \\frac{d\\phi}{dr}\\right) - \\frac{\\phi}{\\lambda_{e}^{2}} = - \\rho_{p}(r)\n$$\nsubject to zero-gradient (Neumann) boundary conditions, $\\phi'(0)=0$ and $\\phi'(R_c)=0$, where $R_c = r_{\\mathrm{N}}/u^{1/d}$ is the Wigner-Seitz cell radius. Here, $\\lambda_e$ is the electron screening length and $\\rho_p(r)$ is the proton number density, which is constant inside the cluster ($r  r_{\\mathrm{N}}$) and zero outside.\n\nThis equation can be rewritten as:\n$$\n\\frac{d^2\\phi}{dr^2} + \\frac{d-1}{r}\\frac{d\\phi}{dr} - k^2\\phi = -\\rho_p(r)\n$$\nwhere $k = 1/\\lambda_e$. This is a linear, second-order boundary value problem. We solve it numerically using a finite-difference method on a uniform radial grid of $N_{\\text{grid}}=500$ points from $r=0$ to $r=R_c$.\n- For interior grid points, standard second-order central differences are used for the derivatives.\n- At the origin $r=0$, the term $\\frac{d-1}{r}\\phi'$ is singular for $d1$. Applying L'Hôpital's rule and the boundary condition $\\phi'(0)=0$, the equation becomes $d\\cdot\\phi''(0) - k^2\\phi(0) = -\\rho_p(0)$. This is discretized using a forward difference for $\\phi''(0)$ derived from a ghost point method.\n- At the outer boundary $r=R_c$, the condition $\\phi'(R_c)=0$ is implemented using a backward difference also derived from a ghost point.\n\nThis discretization transforms the differential equation into a tridiagonal system of linear algebraic equations, which is solved efficiently for the potential $\\phi$ at each grid point using `scipy.linalg.solve_banded`.\n\nOnce the potential $\\phi(r)$ is known, the Coulomb energy density is computed by numerically integrating over the charge distribution using the trapezoidal rule (`numpy.trapz`):\n$$\n\\varepsilon_{C}(d,n,r_{\\mathrm{N}}) = \\frac{d}{2 R_c^d} \\int_{0}^{r_{\\mathrm{N}}} n_{p,\\mathrm{in}} \\phi(r) r^{d-1} dr\n$$\nThe total energy $\\varepsilon_{\\mathrm{tot}}(r_{\\mathrm{N}})$ is then minimized with respect to $r_{\\mathrm{N}}$ using the robust `scipy.optimize.minimize_scalar` function with the 'bounded' method.\n\nThe entire process is repeated for each density in the test suite, and the resulting preferred geometry for each density is encoded as an integer ($1, 2,$ or $3$) and presented in the specified output format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize_scalar\nfrom scipy.linalg import solve_banded\n\n# Define constants as per the problem statement.\nN_IN_DENSITY = 0.16  # fm^-3\nN_GRID_POINTS = 500  # Number of grid points for the finite-difference solver.\n\ndef _get_physical_params(n):\n    \"\"\"\n    Calculates density-dependent physical parameters.\n\n    Args:\n        n (float): Baryon number density in fm^-3.\n\n    Returns:\n        tuple: A tuple containing u, n_p_in, sigma_n, lambda_e.\n    \"\"\"\n    u = n / N_IN_DENSITY\n    u = np.clip(u, 1e-2, 0.99)\n    \n    yp_n = 0.05 + 0.1 * np.exp(-n / 0.06)\n    n_p_in = yp_n * N_IN_DENSITY\n    n_e = u * n_p_in\n    \n    sigma_n = max(0.3, 1.0 - 0.4 * n / N_IN_DENSITY)\n    \n    # Avoid division by zero if n_e is extremely small or zero.\n    if n_e = 1e-12:\n        lambda_e = np.inf\n    else:\n        lambda_e = 20.0 * (0.05 / n_e)**(1.0/3.0)\n        \n    return u, n_p_in, sigma_n, lambda_e\n\ndef _calculate_coulomb_energy(d, u, n_p_in, lambda_e, r_N):\n    \"\"\"\n    Solves the screened Poisson equation and computes the Coulomb energy density.\n    \n    Args:\n        d (int): Geometry dimension (1, 2, or 3).\n        u (float): Volume fraction.\n        n_p_in (float): Proton density inside the cluster.\n        lambda_e (float): Electron screening length.\n        r_N (float): Cluster radius.\n\n    Returns:\n        float: The calculated Coulomb energy density in MeV/fm^3 (with absorbed constants).\n    \"\"\"\n    if r_N = 0: return 0.0\n    R_c = r_N / (u**(1.0/d))\n    if R_c = r_N: return np.inf # Unphysical situation where u = 1\n\n    # 1. Set up the grid and physical parameters for the solver.\n    r = np.linspace(0, R_c, N_GRID_POINTS)\n    dr = r[1] - r[0]\n    \n    k_sq = 1.0 / lambda_e**2 if np.isfinite(lambda_e) else 0.0\n    \n    # 2. Define the source term (proton charge density).\n    N_r_idx = np.searchsorted(r, r_N, side='left')\n    rho_p = np.zeros(N_GRID_POINTS)\n    rho_p[:N_r_idx] = n_p_in\n\n    # 3. Build and solve the tridiagonal system for the potential phi.\n    # The system is M*phi = b, where b = -rho_p.\n    # The matrix M is stored in banded format `ab`.\n    dr_sq = dr**2\n    main_diag = np.zeros(N_GRID_POINTS)\n    upper_diag = np.zeros(N_GRID_POINTS - 1)\n    lower_diag = np.zeros(N_GRID_POINTS - 1)\n\n    # Discretization for interior points: 1 = i = N_GRID_POINTS - 2\n    for i in range(1, N_GRID_POINTS - 1):\n        main_diag[i] = -2.0/dr_sq - k_sq\n        upper_diag[i] = 1.0/dr_sq + (d-1.0)/(2.0 * r[i] * dr)\n        lower_diag[i-1] = 1.0/dr_sq - (d-1.0)/(2.0 * r[i] * dr)\n    \n    # Boundary condition at r=0 (i=0)\n    main_diag[0] = -2.0*d/dr_sq - k_sq\n    upper_diag[0] = 2.0*d/dr_sq\n\n    # Boundary condition at r=R_c (i=N_GRID_POINTS-1)\n    main_diag[-1] = -2.0/dr_sq - k_sq\n    lower_diag[-1] = 2.0/dr_sq\n\n    ab = np.zeros((3, N_GRID_POINTS))\n    ab[1, :] = main_diag\n    ab[0, 1:] = upper_diag\n    ab[2, :-1] = lower_diag\n    \n    try:\n        phi = solve_banded((1, 1), ab, -rho_p, check_finite=False)\n    except np.linalg.LinAlgError:\n        return np.inf\n\n    # 4. Compute Coulomb energy density by numerical integration of (1/2) * rho * phi.\n    integrand = phi[:N_r_idx] * (r[:N_r_idx]**(d-1))\n    integral_val = np.trapz(integrand, x=r[:N_r_idx])\n    \n    if R_c == 0: return 0.0\n    \n    e_coul = (d * n_p_in / (2.0 * R_c**d)) * integral_val\n    return e_coul\n\ndef _get_preferred_geometry(n):\n    \"\"\"\n    Finds the pasta geometry with the minimum free energy at a given density n.\n    \n    Args:\n        n (float): Baryon number density in fm^-3.\n        \n    Returns:\n        int: The integer code (1, 2, or 3) for the preferred geometry.\n    \"\"\"\n    u, n_p_in, sigma_n, lambda_e = _get_physical_params(n)\n    \n    min_energies = {}\n    \n    # Iterate through geometries: 3=spheres, 2=cylinders, 1=slabs.\n    for d in [3, 2, 1]:\n        def total_energy(r_N):\n            e_surf = d * sigma_n * u / r_N\n            e_coul = _calculate_coulomb_energy(d, u, n_p_in, lambda_e, r_N)\n            return e_surf + e_coul\n            \n        res = minimize_scalar(\n            total_energy,\n            bounds=(0.5, 30.0),\n            method='bounded'\n        )\n        min_energies[d] = res.fun\n        \n    # Determine the geometry that yields the minimum total energy.\n    preferred_d = min(min_energies, key=min_energies.get)\n    return preferred_d\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite of densities.\n    The results are printed in the specified single-line format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [0.01, 0.03, 0.06, 0.09, 0.12, 0.15]\n\n    results = []\n    for n in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        result = _get_preferred_geometry(n)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3579770"}, {"introduction": "Building on the Wigner-Seitz model, this practice shifts focus to an analytical perspective using an Energy Density Functional (EDF) framework. Here, the complex interplay of forces is distilled into a simplified energy functional, allowing for an analytical optimization that reveals the scaling of energy with the characteristic size of pasta structures. This exercise [@problem_id:3579784] not only deepens your understanding of the competition between surface and Coulomb energies but also introduces the quantitative impact of more subtle nuclear effects like spin-orbit and pairing forces on phase stability.", "problem": "You will implement a computational comparison of two idealized nuclear pasta morphologies—slabs and rods—using an Energy Density Functional (EDF) framework in the compressible liquid-drop approximation. The goal is to compute the difference in energy per baryon between slab and rod configurations at fixed baryon density and proton fraction, and assess how the inclusion of spin-orbit and pairing terms modifies the stability. The problem must be solved from first principles and expressed using mathematically and physically consistent rules.\n\nUse the following physical and modeling setup.\n\n1. Fundamental base and physical context:\n   - Consider a two-phase mixture of nuclear matter in the inner crust of a neutron star at fixed baryon number density $n = 0.06\\,\\mathrm{fm}^{-3}$ and proton fraction $Y_p = 0.05$. One phase is dense nuclear matter at approximately saturation density, and the other is a dilute gas.\n   - The Energy Density Functional (EDF) model includes contributions from bulk nuclear matter, gradient (surface) energy, Coulomb energy, spin-orbit energy, and pairing energy. For uniform phases, the spin-orbit and pairing contributions can be approximated by effective corrections near interfaces.\n\n2. Global constants and fixed conditions:\n   - Use fixed baryon number density $n = 0.06\\,\\mathrm{fm}^{-3}$.\n   - Use fixed proton fraction $Y_p = 0.05$.\n   - Nuclear saturation density $n_0 = 0.16\\,\\mathrm{fm}^{-3}$.\n   - Elementary Coulomb constant in nuclear units: $e^2 = 1.44\\,\\mathrm{MeV\\,fm}$.\n   - Interface thickness (coherence length) $\\xi = 2\\,\\mathrm{fm}$.\n   - Gradient coefficient $C_{\\mathrm{grad}} = 20\\,\\mathrm{MeV\\,fm}^5$.\n   - Baseline spin-orbit coefficient $C_{\\mathrm{so,0}} = 6\\,\\mathrm{MeV\\,fm}^5$.\n   - Baseline pairing suppression scale per unit area $P_s = 1.0\\,\\mathrm{MeV\\,fm}^{-2}$.\n\n3. Geometric and thermodynamic setup:\n   - Assume the dense phase has baryon density $n_{\\mathrm{in}} \\approx n_0$ and the dilute phase has $n_{\\mathrm{out}} \\approx 0$. The volume fraction occupied by the dense phase is $u = n/n_0$, with $0  u  1$. Clamp $u$ to be strictly inside $(0,1)$ if needed for numerical robustness.\n   - The proton density contrast between phases is $\\Delta n_p = Y_p\\,(n_{\\mathrm{in}} - n_{\\mathrm{out}}) \\approx Y_p\\,n_0$.\n   - For both slab (planar) and rod (cylindrical) geometries, represent the morphology with a single characteristic size $l$ of the dense domain (for slabs, the slab thickness $t$; for rods, the cylinder radius $R$). The interface area per unit volume scales as $S/V \\approx 2u/l$ for both geometries in a one-domain-per-cell approximation.\n   - The geometry-dependent Coulomb energy density scales quadratically with the characteristic size $l$ and depends on a dimensionless shape factor $f_d(u)$ and a geometry-dependent prefactor $A_d$:\n     - For slabs (dimension $d=1$), use $A_1 = \\pi$ and $f_1(u) = u\\,(1 - u)$.\n     - For rods (dimension $d=2$), use $A_2 = \\pi/2$ and $f_2(u) = u\\,(1 - u/2)$.\n   - The gradient (surface) energy density is approximated by a term linear in $S/V$: $E_{\\mathrm{surf}}/V \\approx \\sigma_{\\mathrm{surf}}\\,(S/V)$ with $\\sigma_{\\mathrm{surf}} = C_{\\mathrm{grad}}\\,\\Delta n^2/\\xi$ and $\\Delta n = n_{\\mathrm{in}} - n_{\\mathrm{out}} \\approx n_0$.\n   - The spin-orbit energy density is modeled similarly as a linear-in-interface correction: $E_{\\mathrm{so}}/V \\approx \\sigma_{\\mathrm{so}}\\,(S/V)$ with $\\sigma_{\\mathrm{so}} = C_{\\mathrm{so}}\\,\\Delta n^2/\\xi$, where $C_{\\mathrm{so}}$ is a tunable coefficient derived from the baseline $C_{\\mathrm{so,0}}$ via a scale factor.\n   - The pairing energy density exhibits suppression near interfaces. Model the geometry-dependent suppression as $E_{\\mathrm{pair}}/V \\approx \\sigma_{\\mathrm{pair}}\\,(S/V)$ with $\\sigma_{\\mathrm{pair}} = P_s\\,Y_p$ possibly scaled by a factor. The uniform bulk pairing contribution cancels when comparing geometries at fixed $n$ and $Y_p$, so only the interface-dependent suppression term is needed for the energy difference.\n\n4. Optimization principle:\n   - For a given geometry, the geometry-dependent part of the energy density is the sum of an interface-linear term and a Coulomb-quadratic term in the characteristic size $l$:\n     $$\\frac{E_{\\mathrm{geom}}}{V}(l) = \\underbrace{\\left(\\sigma_{\\mathrm{surf}} + \\sigma_{\\mathrm{so}} + \\sigma_{\\mathrm{pair}}\\right)\\frac{2u}{l}}_{\\text{interface-linear}} + \\underbrace{A_d\\,e^2\\,(\\Delta n_p)^2\\,u\\,f_d(u)\\,l^2}_{\\text{Coulomb-quadratic}}.$$\n   - You must minimize $\\frac{E_{\\mathrm{geom}}}{V}(l)$ with respect to $l  0$ for each geometry to obtain the optimized geometry-dependent energy density. Then, convert to energy per baryon by dividing by $n$.\n\n5. Deliverables:\n   - Implement a program that computes the energy per baryon for slabs and rods using the above model, for the specified fixed $n$ and $Y_p$, in units of $\\mathrm{MeV}$ per baryon.\n   - Compute the energy difference per baryon $\\Delta E = E_{\\mathrm{slab}} - E_{\\mathrm{rod}}$ in $\\mathrm{MeV}$ for a suite of test cases that switch spin-orbit and pairing terms on and off, and scale their strengths.\n\n6. Units and numerical reporting:\n   - Express all energy differences in $\\mathrm{MeV}$ per baryon, rounded to six decimals.\n   - Angles are not used; no angle unit is required.\n\n7. Test suite:\n   - Use the following six test cases at the fixed $n$ and $Y_p$ values above. Each case sets boolean toggles for spin-orbit inclusion and pairing inclusion and scale factors relative to the baselines:\n     1. Spin-orbit on, pairing on, spin-orbit scale $1.0$, pairing scale $1.0$.\n     2. Spin-orbit off, pairing off, spin-orbit scale $1.0$, pairing scale $1.0$.\n     3. Spin-orbit on, pairing off, spin-orbit scale $1.0$, pairing scale $1.0$.\n     4. Spin-orbit off, pairing on, spin-orbit scale $1.0$, pairing scale $1.0$.\n     5. Spin-orbit on, pairing on, spin-orbit scale $2.0$, pairing scale $1.0$.\n     6. Spin-orbit on, pairing on, spin-orbit scale $1.0$, pairing scale $2.0$.\n   - For each test case, output two quantities: the energy difference per baryon $\\Delta E$ and a boolean indicating whether the slab configuration is more stable than the rod configuration at the optimum (i.e., whether $\\Delta E  0$).\n\n8. Final output format:\n   - Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain first the six energy differences (in $\\mathrm{MeV}$ per baryon, each rounded to six decimals) followed by the six booleans, in the same order as the test cases. For example, a valid output form is\n     $[\\Delta E_1,\\Delta E_2,\\Delta E_3,\\Delta E_4,\\Delta E_5,\\Delta E_6,\\mathrm{stable}_1,\\mathrm{stable}_2,\\mathrm{stable}_3,\\mathrm{stable}_4,\\mathrm{stable}_5,\\mathrm{stable}_6].$\n\nYour implementation must be a complete, runnable program that adheres to the specified runtime environment and prints only the single line described above.", "solution": "The user wants to solve a computational nuclear physics problem about \"pasta phases\" in neutron stars.\nThe goal of this problem is to compare the energetic stability of two idealized nuclear pasta morphologies, slabs and rods, within the framework of an Energy Density Functional (EDF) using a compressible liquid-drop model. The stability is assessed by calculating the difference in energy per baryon, $\\Delta E = E_{\\mathrm{slab}} - E_{\\mathrm{rod}}$, after optimizing the geometry of each phase. The analysis will also explore the impact of spin-orbit and pairing interactions on this energy difference.\n\nThe core of the model is the geometry-dependent part of the energy density, $\\mathcal{E}_{\\mathrm{geom}}/V$, which is a function of a characteristic size $l$ (slab thickness or rod radius). For a given geometry, indexed by dimensionality $d$ ($d=1$ for slabs, $d=2$ for rods), this energy density is given by the sum of interface-related terms and a Coulomb term:\n$$\n\\frac{E_{\\mathrm{geom}}}{V}(l) \\equiv \\mathcal{E}_d(l) = \\frac{C_1}{l} + C_{2,d} l^2\n$$\nThe first term accounts for the energy cost of creating an interface between the dense and dilute nuclear phases. The coefficient $C_1$ is proportional to the total surface tension $\\sigma_{\\mathrm{total}}$ and the interface area per unit volume, which is approximated as $S/V \\approx 2u/l$. The surface tension itself is a sum of contributions from the nuclear gradient energy ($\\sigma_{\\mathrm{surf}}$), spin-orbit interaction ($\\sigma_{\\mathrm{so}}$), and pairing energy ($\\sigma_{\\mathrm{pair}}$). The coefficient is thus:\n$$\nC_1 = (\\sigma_{\\mathrm{surf}} + \\sigma_{\\mathrm{so}} + \\sigma_{\\mathrm{pair}}) \\cdot 2u\n$$\nwhere $u=n/n_0$ is the volume fraction of the dense phase. The individual surface tension terms are defined as:\n- $\\sigma_{\\mathrm{surf}} = C_{\\mathrm{grad}}\\,\\Delta n^2/\\xi$\n- $\\sigma_{\\mathrm{so}} = C_{\\mathrm{so}}\\,\\Delta n^2/\\xi$\n- $\\sigma_{\\mathrm{pair}} = P_s\\,Y_p \\cdot (\\text{scale factor})$\nHere, $\\Delta n \\approx n_0$ is the baryon density difference between the phases. The spin-orbit and pairing terms can be switched on or off and scaled according to the test case specifications.\n\nThe second term, $C_{2,d} l^2$, represents the repulsive Coulomb energy within the charged dense structures. The coefficient $C_{2,d}$ depends on the geometry:\n$$\nC_{2,d} = A_d\\,e^2\\,(\\Delta n_p)^2\\,u\\,f_d(u)\n$$\nwhere $\\Delta n_p \\approx Y_p n_0$ is the proton density difference, $e^2$ is the Coulomb constant, $A_d$ is a geometry-dependent prefactor ($A_1=\\pi$ for slabs, $A_2=\\pi/2$ for rods), and $f_d(u)$ is a dimensionless shape factor ($f_1(u) = u(1 - u)$ for slabs, $f_2(u) = u(1-u/2)$ for rods).\n\nFor each morphology, we find the optimal characteristic size $l_{d,\\text{opt}}$ by minimizing $\\mathcal{E}_d(l)$ with respect to $l  0$. We solve for $l$ where the derivative of the energy density is zero:\n$$\n\\frac{d\\mathcal{E}_d(l)}{dl} = -\\frac{C_1}{l^2} + 2 C_{2,d} l = 0\n$$\nThis yields the optimal size:\n$$\nl_{d,\\text{opt}} = \\left( \\frac{C_1}{2 C_{2,d}} \\right)^{1/3}\n$$\nSubstituting $l_{d,\\text{opt}}$ back into the energy density expression gives the minimized energy density, $\\mathcal{E}_{d,\\text{min}}$:\n$$\n\\mathcal{E}_{d,\\text{min}} = \\mathcal{E}_d(l_{d,\\text{opt}}) = \\frac{C_1}{l_{d,\\text{opt}}} + C_{2,d} l_{d,\\text{opt}}^2\n$$\nUsing the relation $C_1 = 2 C_{2,d} l_{d,\\text{opt}}^3$, we can simplify this to:\n$$\n\\mathcal{E}_{d,\\text{min}} = 2 C_{2,d} l_{d,\\text{opt}}^2 + C_{2,d} l_{d,\\text{opt}}^2 = 3 C_{2,d} l_{d,\\text{opt}}^2 = 3 C_{2,d} \\left( \\frac{C_1}{2 C_{2,d}} \\right)^{2/3}\n$$\nThis simplifies further to:\n$$\n\\mathcal{E}_{d,\\text{min}} = \\frac{3}{2^{2/3}} C_1^{2/3} C_{2,d}^{1/3}\n$$\nThe problem requires the energy per baryon, $E_{d, \\text{baryon}}$, which is obtained by dividing the minimum energy density by the average baryon density $n$:\n$$\nE_{d, \\text{baryon}} = \\frac{\\mathcal{E}_{d,\\text{min}}}{n} = \\frac{3}{n \\cdot 2^{2/3}} C_1^{2/3} C_{2,d}^{1/3}\n$$\nThe quantity of interest is the difference in energy per baryon between the slab ($d=1$) and rod ($d=2$) configurations:\n$$\n\\Delta E = E_{\\mathrm{slab}} - E_{\\mathrm{rod}} = E_{1, \\text{baryon}} - E_{2, \\text{baryon}}\n$$\nFactoring out the common terms, we arrive at the final expression for computation:\n$$\n\\Delta E = \\frac{3}{n \\cdot 2^{2/3}} C_1^{2/3} \\left( C_{2,1}^{1/3} - C_{2,2}^{1/3} \\right)\n$$\nThe slab configuration is more stable than the rod configuration if $\\Delta E  0$.\n\nThe computational procedure is as follows:\n1.  Define all physical constants ($n, Y_p, n_0, e^2, \\xi, C_{\\mathrm{grad}}, C_{\\mathrm{so,0}}, P_s$) and pre-calculate derived constants ($u, \\Delta n, \\Delta n_p, \\sigma_{\\mathrm{surf}}$).\n2.  Pre-calculate the geometry-dependent Coulomb coefficients $C_{2,1}$ and $C_{2,2}$, as they are constant across all test cases.\n3.  Iterate through the six test cases. For each case:\n    a. Determine the values of $\\sigma_{\\mathrm{so}}$ and $\\sigma_{\\mathrm{pair}}$ based on the boolean flags and scaling factors.\n    b. Calculate the total surface tension $\\sigma_{\\mathrm{total}} = \\sigma_{\\mathrm{surf}} + \\sigma_{\\mathrm{so}} + \\sigma_{\\mathrm{pair}}$.\n    c. Calculate the interface coefficient $C_1 = \\sigma_{\\mathrm{total}} \\cdot 2u$.\n    d. Use the final derived formula to compute $\\Delta E$.\n    e. Determine the stability boolean ($\\Delta E  0$).\n4.  Collect the results and format them into the specified single-line output string.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the energy difference between slab and rod nuclear pasta phases.\n    \"\"\"\n    # 1. Fundamental base and physical context\n    # Fixed global constants and conditions\n    n = 0.06  # Baryon number density in fm^-3\n    Y_p = 0.05  # Proton fraction\n    n_0 = 0.16  # Nuclear saturation density in fm^-3\n    e2 = 1.44  # Elementary Coulomb constant in MeV fm\n    xi = 2.0  # Interface thickness in fm\n    C_grad = 20.0  # Gradient coefficient in MeV fm^5\n    C_so_0 = 6.0  # Baseline spin-orbit coefficient in MeV fm^5\n    P_s = 1.0  # Baseline pairing suppression scale in MeV fm^-2\n\n    # Derived constants from geometric and thermodynamic setup\n    u = n / n_0  # Volume fraction of dense phase\n    delta_n = n_0  # Baryon density contrast (n_in - n_out)\n    delta_np = Y_p * n_0  # Proton density contrast\n\n    # Interface tension contributions\n    sigma_surf = C_grad * (delta_n**2) / xi\n    \n    # Pre-calculate geometry-dependent Coulomb coefficients C_2,d\n    # These are constant across all test cases.\n    \n    # Common factor for C_2,d\n    c2_common_factor = e2 * (delta_np**2) * u\n    \n    # For slabs (d=1)\n    A1 = np.pi\n    f1_u = u * (1.0 - u)\n    C_2_1 = A1 * c2_common_factor * f1_u\n    \n    # For rods (d=2)\n    A2 = np.pi / 2.0\n    f2_u = u * (1.0 - u / 2.0)\n    C_2_2 = A2 * c2_common_factor * f2_u\n\n    # Test suite\n    test_cases = [\n        # (so_on, pairing_on, so_scale, pairing_scale)\n        (True, True, 1.0, 1.0),\n        (False, False, 1.0, 1.0),\n        (True, False, 1.0, 1.0),\n        (False, True, 1.0, 1.0),\n        (True, True, 2.0, 1.0),\n        (True, True, 1.0, 2.0),\n    ]\n\n    delta_e_results = []\n    stability_results = []\n\n    # Optimization and calculation loop\n    for so_on, pairing_on, so_scale, pairing_scale in test_cases:\n        # Calculate case-dependent interface tension terms\n        sigma_so = 0.0\n        if so_on:\n            C_so = C_so_0 * so_scale\n            sigma_so = C_so * (delta_n**2) / xi\n\n        sigma_pair = 0.0\n        if pairing_on:\n            scaled_P_s = P_s * pairing_scale\n            sigma_pair = scaled_P_s * Y_p\n\n        # Total interface tension for the case\n        sigma_total = sigma_surf + sigma_so + sigma_pair\n        \n        # Calculate interface coefficient C_1\n        C_1 = sigma_total * 2.0 * u\n        \n        # Calculate energy difference using the derived formula\n        # Delta_E = (3 / (n * 2^(2/3))) * C_1^(2/3) * (C_2_1^(1/3) - C_2_2^(1/3))\n        \n        const_factor = 3.0 / (n * np.cbrt(4.0))\n        c1_factor = np.cbrt(C_1**2)\n        c2_diff_factor = np.cbrt(C_2_1) - np.cbrt(C_2_2)\n        \n        delta_E = const_factor * c1_factor * c2_diff_factor\n        \n        # Determine stability (slab is more stable if Delta_E  0)\n        is_slab_stable = delta_E  0.0\n        \n        delta_e_results.append(delta_E)\n        stability_results.append(is_slab_stable)\n\n    # Format the final output string\n    # Round delta_E values to six decimal places\n    formatted_delta_e = [f\"{val:.6f}\" for val in delta_e_results]\n    \n    # Convert booleans to strings 'True' or 'False'\n    formatted_stability = [str(val) for val in stability_results]\n    \n    final_output = f\"[{','.join(formatted_delta_e)},{','.join(formatted_stability)}]\"\n\n    # Print the final output in the exact required format\n    print(final_output)\n\nsolve()\n\n```", "id": "3579784"}, {"introduction": "This final practice advances from simple geometries to the complex, three-dimensional world of topologically intricate pasta phases, such as the gyroid. You will use level-set descriptions and spectral methods to calculate the surface and Coulomb energies for these non-trivial structures, comparing their stability against the simpler slab and rod phases. This advanced exercise [@problem_id:3579768] equips you with powerful computational techniques, including FFT-based Poisson solvers, essential for modeling complex microstructures at the forefront of nuclear astrophysics research.", "problem": "You are tasked with building a complete, runnable program that, for topology-constrained nuclear pasta candidates, computes a dimensionless energy difference $\\Delta E$ of gyroid-like configurations relative to slabs and rods, and assesses metastability windows. The computational setting must be purely mathematical and self-contained, starting from established energy components relevant to nuclear pasta microstructures in dense matter.\n\nBegin from the following fundamental base, which is standard in liquid-drop inspired modeling of nuclear pasta: the total energy density is modeled as a sum of a surface term and a Coulomb interaction term. The system occupies a periodic cubic domain and admits candidate morphologies generated by analytic, triply periodic functions; topology is constrained by the selected analytic form. All quantities are dimensionless by construction.\n\nLet the periodic cubic domain be $[0,1]^3$ with periodic boundary conditions. Let the spatial grid have $N$ points per axis, uniform spacing $dx = 1/N$, and Cartesian mesh coordinates $\\{x_i\\}$, $\\{y_j\\}$, $\\{z_k\\}$ for $i,j,k \\in \\{0,1,\\dots,N-1\\}$.\n\nFor each candidate morphology, define an underlying scalar field $\\phi(\\mathbf{r})$ via a trigonometric ansatz with integer wavenumber $k \\in \\mathbb{Z}^{+}$, angular frequency $\\omega = 2\\pi k$, and amplitude fixed to unity. The three candidate families are:\n- Slab (lamella, often called “lasagna”): $\\phi_{\\mathrm{slab}}(x,y,z;k) = \\sin(\\omega x)$.\n- Rod (cylindrical array, often called “spaghetti” in an idealized separable surrogate): $\\phi_{\\mathrm{rod}}(x,y,z;k) = \\sin(\\omega x) + \\sin(\\omega y)$.\n- Gyroid-like triply periodic minimal-surface surrogate (nodal gyroid approximation): $\\phi_{\\mathrm{gyro}}(x,y,z;k) = \\sin(\\omega x)\\cos(\\omega y) + \\sin(\\omega y)\\cos(\\omega z) + \\sin(\\omega z)\\cos(\\omega x)$.\n\nFor a specified dense-phase volume fraction $f \\in (0,1)$, define the isosurface threshold $t$ implicitly so that the dense phase is the superlevel set $\\{\\mathbf{r} \\, | \\, \\phi(\\mathbf{r}) \\ge t\\}$ and the volume fraction of this set equals $f$. Numerically, this can be enforced by setting $t$ equal to the $(1-f)$-quantile of the discrete samples of $\\phi$ on the grid.\n\nLet the phase indicator be $h(\\mathbf{r}) = H(\\phi(\\mathbf{r}) - t)$, where $H$ is the Heaviside function $H(u) = 1$ if $u \\ge 0$ and $H(u) = 0$ otherwise. Enforce charge neutrality by defining a dimensionless charge density $\\rho(\\mathbf{r}) = h(\\mathbf{r}) - f$, which has zero spatial mean by construction when the volume fraction constraint is exactly satisfied.\n\nDefine the surface contribution using the level-set surface area formula. The surface area of the isosurface $\\phi(\\mathbf{r}) = t$ is given by\n$$\nA = \\int_{[0,1]^3} \\delta(\\phi(\\mathbf{r}) - t)\\,\\lVert \\nabla \\phi(\\mathbf{r}) \\rVert \\, d^3\\mathbf{r},\n$$\nwhere $\\delta$ is the Dirac delta function. Numerically approximate $\\delta$ by a narrow Gaussian of width $\\varepsilon  0$,\n$$\n\\delta_{\\varepsilon}(u) = \\frac{1}{\\sqrt{\\pi}\\,\\varepsilon} \\exp\\!\\left(-\\frac{u^2}{\\varepsilon^2}\\right),\n$$\nand approximate the gradient by centered finite differences with periodic boundary conditions:\n$$\n\\partial_x \\phi \\approx \\frac{\\phi(x+dx,y,z) - \\phi(x-dx,y,z)}{2\\,dx}, \\quad \\text{and similarly for } \\partial_y, \\partial_z.\n$$\nLet the surface energy coefficient be $a_s  0$. The surface energy density contribution is $E_{\\mathrm{surf}} = a_s\\,A$.\n\nDefine the Coulomb contribution via the electrostatic potential $\\varphi$ that solves the dimensionless Poisson equation with periodic boundary conditions,\n$$\n-\\nabla^2 \\varphi(\\mathbf{r}) = 4\\pi\\,\\rho(\\mathbf{r}),\n$$\nand let $a_c  0$ be a Coulomb coupling prefactor. The Coulomb energy density contribution is\n$$\nE_{\\mathrm{C}} = \\frac{1}{2} a_c \\int_{[0,1]^3} \\rho(\\mathbf{r})\\,\\varphi(\\mathbf{r}) \\, d^3\\mathbf{r}.\n$$\nNumerically, compute $\\varphi$ using a Fast Fourier Transform (FFT) spectral solver: if $\\widehat{\\rho}(\\mathbf{k})$ is the discrete Fourier transform of $\\rho$ and $\\mathbf{k}$ is the wavevector with squared norm $\\lVert \\mathbf{k} \\rVert^2$, then for all nonzero modes,\n$$\n\\widehat{\\varphi}(\\mathbf{k}) = \\frac{4\\pi \\widehat{\\rho}(\\mathbf{k})}{\\lVert \\mathbf{k} \\rVert^2},\n$$\nand set the zero mode to $0$ to enforce neutrality. Recover $\\varphi(\\mathbf{r})$ by inverse FFT and then form the discretized integral.\n\nThe total energy density for a candidate shape at wavenumber $k$ is the sum\n$$\nE_{\\mathrm{tot}}(k; \\text{shape}, f, a_s, a_c, \\varepsilon) = E_{\\mathrm{surf}}(k) + E_{\\mathrm{C}}(k).\n$$\n\nTopology-constrained minimization: for each shape family, minimize $E_{\\mathrm{tot}}$ over the integer wavenumber $k \\in \\{k_{\\min}, k_{\\min}+1, \\dots, k_{\\max}\\}$, holding the analytic family fixed (this enforces the topology constraint). Identify the minimizing $k_{\\star}$ and the minimal energy $E_{\\min}$ for each shape. Assess local curvature at the discrete minimizer with the second finite difference\n$$\nE''(k_{\\star}) \\approx E_{\\mathrm{tot}}(k_{\\star}+1) - 2\\,E_{\\mathrm{tot}}(k_{\\star}) + E_{\\mathrm{tot}}(k_{\\star}-1),\n$$\nprovided $k_{\\star}$ is strictly interior to the search interval, to check for a local minimum.\n\nEnergy differences and metastability: compute the gyroid’s minimal energy $E_{\\min}^{\\mathrm{gyro}}$ and the slab and rod minimal energies $E_{\\min}^{\\mathrm{slab}}$ and $E_{\\min}^{\\mathrm{rod}}$. Define energy differences\n$$\n\\Delta E_{\\mathrm{g}\\text{-}\\mathrm{s}} = E_{\\min}^{\\mathrm{gyro}} - E_{\\min}^{\\mathrm{slab}}, \\quad\n\\Delta E_{\\mathrm{g}\\text{-}\\mathrm{r}} = E_{\\min}^{\\mathrm{gyro}} - E_{\\min}^{\\mathrm{rod}}.\n$$\nLet the baseline energy be $E_{\\min}^{\\mathrm{base}} = \\min\\!\\big(E_{\\min}^{\\mathrm{slab}}, E_{\\min}^{\\mathrm{rod}}\\big)$ and define $\\Delta E_{\\mathrm{g}\\text{-}\\mathrm{base}} = E_{\\min}^{\\mathrm{gyro}} - E_{\\min}^{\\mathrm{base}}$. For a given nonnegative window parameter $\\delta_{\\max}$, declare the gyroid metastable if all of the following hold: (i) $E''(k_{\\star}^{\\mathrm{gyro}})  0$ (interior local minimum), (ii) $\\Delta E_{\\mathrm{g}\\text{-}\\mathrm{base}}  0$, and (iii) $\\Delta E_{\\mathrm{g}\\text{-}\\mathrm{base}} \\le \\delta_{\\max}$.\n\nAll quantities are dimensionless. Angles are not used. No physical unit conversion is required.\n\nImplement the described computation with the following test suite. For each case, use $N = 32$, $k_{\\min} = 1$, $k_{\\max} = 6$ unless otherwise specified, and report results in the exact output format described below.\n- Case $1$: $f = 0.3$, $a_s = 1.0$, $a_c = 0.1$, $\\varepsilon = 0.03$, $\\delta_{\\max} = 0.05$.\n- Case $2$: $f = 0.5$, $a_s = 0.8$, $a_c = 0.2$, $\\varepsilon = 0.03$, $\\delta_{\\max} = 0.10$.\n- Case $3$: $f = 0.15$, $a_s = 1.2$, $a_c = 0.05$, $\\varepsilon = 0.03$, $\\delta_{\\max} = 0.05$.\n- Case $4$: $f = 0.85$, $a_s = 0.9$, $a_c = 0.25$, $\\varepsilon = 0.03$, $\\delta_{\\max} = 0.10$.\n\nYour program must:\n- For each case, perform topology-constrained minimizations over $k \\in \\{1,2,3,4,5,6\\}$ for the gyroid, slab, and rod families.\n- Compute $E_{\\min}^{\\mathrm{gyro}}$, $E_{\\min}^{\\mathrm{slab}}$, $E_{\\min}^{\\mathrm{rod}}$, $\\Delta E_{\\mathrm{g}\\text{-}\\mathrm{s}}$, $\\Delta E_{\\mathrm{g}\\text{-}\\mathrm{r}}$, and the metastability boolean as defined above.\n- Produce a single line of output containing a list of per-case results, where each per-case result is itself a list formatted as $[E_{\\min}^{\\mathrm{gyro}}, E_{\\min}^{\\mathrm{slab}}, E_{\\min}^{\\mathrm{rod}}, \\Delta E_{\\mathrm{g}\\text{-}\\mathrm{s}}, \\Delta E_{\\mathrm{g}\\text{-}\\mathrm{r}}, \\text{metastable}]$. Energies are floating-point numbers in dimensionless units; the metastability flag is a boolean.\n\nThe final single-line output must be the top-level list of these per-case lists, in case order, printed with standard Python list syntax, for example $[[\\ldots],[\\ldots],[\\ldots],[\\ldots]]$.", "solution": "The provided problem is a self-contained, well-posed exercise in computational physics that is scientifically grounded in the established liquid-drop model for nuclear matter. All parameters, equations, and numerical methods are clearly specified, and there are no internal contradictions, ambiguities, or factual errors. The problem is therefore deemed valid and a solution is constructed as follows.\n\nThe core of the task is to compute the total energy density for three families of nuclear pasta morphologies—slabs, rods, and a gyroid-like structure—and to identify the energetically preferred configurations. The total energy density $E_{\\mathrm{tot}}$ is the sum of a surface energy contribution $E_{\\mathrm{surf}}$ and a Coulomb energy contribution $E_{\\mathrm{C}}$. The calculations are performed on a discretized periodic cubic domain $[0,1]^3$.\n\nFirst, we establish the computational grid. The domain is discretized into a uniform mesh of $N \\times N \\times N$ points. The grid spacing is $dx=1/N$. We generate three-dimensional coordinate arrays $(x, y, z)$ using `numpy.meshgrid` with `'ij'` indexing, such that the array indices correspond directly to the spatial dimensions.\n\nFor each morphology family (slab, rod, gyroid), a scalar field $\\phi(\\mathbf{r})$ is defined by a specific trigonometric ansatz. These are given as:\n- Slab: $\\phi_{\\mathrm{slab}}(x,y,z;k) = \\sin(\\omega x)$\n- Rod: $\\phi_{\\mathrm{rod}}(x,y,z;k) = \\sin(\\omega x) + \\sin(\\omega y)$\n- Gyroid-like: $\\phi_{\\mathrm{gyro}}(x,y,z;k) = \\sin(\\omega x)\\cos(\\omega y) + \\sin(\\omega y)\\cos(\\omega z) + \\sin(\\omega z)\\cos(\\omega x)$\nHere, $k \\in \\mathbb{Z}^{+}$ is an integer wavenumber and $\\omega = 2\\pi k$ is the corresponding angular frequency. These fields are evaluated at every point on the 3D grid.\n\nThe system is partitioned into a dense phase and a dilute phase based on the value of $\\phi(\\mathbf{r})$. For a given dense-phase volume fraction $f$, an isosurface threshold $t$ is determined such that the volume of the region where $\\phi(\\mathbf{r}) \\ge t$ is equal to $f$. Numerically, this is robustly achieved by finding the $(1-f)$-quantile of all values of the discrete field $\\phi$ on the grid. A phase indicator field $h(\\mathbf{r})$ is then defined as $h(\\mathbf{r})=1$ for the dense phase ($\\phi(\\mathbf{r}) \\ge t$) and $h(\\mathbf{r})=0$ for the dilute phase. This is implemented using the condition `phi = t`. To ensure overall charge neutrality, a dimensionless charge density $\\rho(\\mathbf{r})$ is defined as $\\rho(\\mathbf{r}) = h(\\mathbf{r}) - f$. By construction, the spatial average of $\\rho(\\mathbf{r})$ over the domain is approximately zero.\n\nThe surface energy density is given by $E_{\\mathrm{surf}} = a_s A$, where $a_s$ is a given coefficient and $A$ is the total surface area of the interface between the two phases within the unit volume. The area is computed from the level-set integral:\n$$\nA = \\int_{[0,1]^3} \\delta(\\phi(\\mathbf{r}) - t)\\,\\lVert \\nabla \\phi(\\mathbf{r}) \\rVert \\, d^3\\mathbf{r}\n$$\nNumerically, this integral is approximated by a sum over the grid cells. The Dirac delta function $\\delta(u)$ is regularized using a narrow Gaussian function $\\delta_{\\varepsilon}(u) = (\\sqrt{\\pi}\\varepsilon)^{-1} \\exp(-u^2/\\varepsilon^2)$ with a small width $\\varepsilon$. The gradient vector $\\nabla\\phi$ is computed at each grid point using a second-order centered finite difference scheme, which is implemented efficiently for the periodic domain using `numpy.roll` to access neighboring grid points. The gradient norm $\\lVert \\nabla \\phi \\rVert$ is then the standard Euclidean norm of its components. The integral is approximated as a discrete sum over all grid points $i$: $A \\approx \\sum_i \\delta_{\\varepsilon}(\\phi_i - t)\\,\\lVert \\nabla \\phi_i \\rVert \\, (dx)^3$.\n\nThe Coulomb energy density $E_{\\mathrm{C}}$ is calculated from the solution of the Poisson equation, $-\\nabla^2 \\varphi(\\mathbf{r}) = 4\\pi\\,\\rho(\\mathbf{r})$, subject to periodic boundary conditions. This is solved efficiently using a spectral method based on the Fast Fourier Transform (FFT).\n1.  Compute the 3D FFT of the charge density, $\\widehat{\\rho}(\\mathbf{k}) = \\mathcal{F}[\\rho(\\mathbf{r})]$.\n2.  Generate the grid of wavevectors $\\mathbf{k}$ corresponding to the discrete Fourier modes. For a grid of size $N$ with spacing $dx=1/N$, the wavevector components are $k_i = 2\\pi m_i$, where the integers $m_i$ are given by `numpy.fft.fftfreq(N)`.\n3.  In Fourier space, the Poisson equation becomes an algebraic equation: $\\lVert \\mathbf{k} \\rVert^2 \\widehat{\\varphi}(\\mathbf{k}) = 4\\pi \\widehat{\\rho}(\\mathbf{k})$.\n4.  The potential in Fourier space is then $\\widehat{\\varphi}(\\mathbf{k}) = 4\\pi \\widehat{\\rho}(\\mathbf{k}) / \\lVert \\mathbf{k} \\rVert^2$ for all non-zero wavevectors $\\mathbf{k} \\neq \\mathbf{0}$. For the zero mode ($\\mathbf{k}=\\mathbf{0}$), we set $\\widehat{\\varphi}(\\mathbf{0})=0$, which enforces charge neutrality and sets the average potential to zero. The division-by-zero for the zero mode is avoided by identifying this mode and treating it separately.\n5.  The real-space potential $\\varphi(\\mathbf{r})$ is recovered by performing an inverse 3D FFT on $\\widehat{\\varphi}(\\mathbf{k})$.\nThe Coulomb energy density is then computed by approximating the integral $E_{\\mathrm{C}} = \\frac{1}{2} a_c \\int \\rho(\\mathbf{r})\\varphi(\\mathbf{r}) \\, d^3\\mathbf{r}$ as a discrete sum over the grid: $E_{\\mathrm{C}} \\approx \\frac{1}{2} a_c \\sum_i \\rho_i \\varphi_i \\, (dx)^3$.\n\nThe total energy $E_{\\mathrm{tot}} = E_{\\mathrm{surf}} + E_{\\mathrm{C}}$ is calculated for each morphology and for each integer wavenumber $k$ in the specified range $\\{k_{\\min}, \\dots, k_{\\max}\\}$. For each morphology, the minimum energy $E_{\\min}$ and the corresponding optimal wavenumber $k_{\\star}$ are found by selecting the minimum value from the computed energies.\n\nFinally, the metastability of the gyroid phase is assessed. The energy differences $\\Delta E_{\\mathrm{g}\\text{-}\\mathrm{s}} = E_{\\min}^{\\mathrm{gyro}} - E_{\\min}^{\\mathrm{slab}}$ and $\\Delta E_{\\mathrm{g}\\text{-}\\mathrm{r}} = E_{\\min}^{\\mathrm{gyro}} - E_{\\min}^{\\mathrm{rod}}$ are computed. A baseline energy $E_{\\min}^{\\mathrm{base}} = \\min(E_{\\min}^{\\mathrm{slab}}, E_{\\min}^{\\mathrm{rod}})$ is established, and the gyroid's energy relative to this baseline is calculated as $\\Delta E_{\\mathrm{g}\\text{-}\\mathrm{base}} = E_{\\min}^{\\mathrm{gyro}} - E_{\\min}^{\\mathrm{base}}$. The gyroid is declared metastable if three conditions are met simultaneously:\n1.  The configuration corresponds to a local minimum with respect to $k$. This is checked by approximating the second derivative $E''(k_{\\star}^{\\mathrm{gyro}})$ with a centered finite difference. The condition is $E''(k_{\\star}^{\\mathrm{gyro}})  0$, which requires that $k_{\\star}^{\\mathrm{gyro}}$ be an interior point of the search range (i.e., $k_{\\min}  k_{\\star}^{\\mathrm{gyro}}  k_{\\max}$).\n2.  The gyroid is not the ground state: $\\Delta E_{\\mathrm{g}\\text{-}\\mathrm{base}}  0$.\n3.  The gyroid's energy is close enough to the ground state, i.e., within a given window: $\\Delta E_{\\mathrm{g}\\text{-}\\mathrm{base}} \\le \\delta_{\\max}$.\n\nThe overall algorithm iterates through each provided test case, performs these calculations for the three morphologies, determines the minimal energies and metastability, and collates the results into the specified list format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_total_energy(shape, k, f, a_s, a_c, epsilon, N):\n    \"\"\"\n    Computes the total energy density for a given morphology.\n    \"\"\"\n    # 1. Grid Setup\n    dx = 1.0 / N\n    coords_1d = np.linspace(0, 1.0, N, endpoint=False)\n    # 'ij' indexing: xx varies along axis 0, yy axis 1, zz axis 2\n    xx, yy, zz = np.meshgrid(coords_1d, coords_1d, coords_1d, indexing='ij')\n\n    # 2. Scalar Field phi Calculation\n    omega = 2.0 * np.pi * k\n    if shape == 'slab':\n        phi = np.sin(omega * xx)\n    elif shape == 'rod':\n        phi = np.sin(omega * xx) + np.sin(omega * yy)\n    elif shape == 'gyro':\n        phi = (np.sin(omega * xx) * np.cos(omega * yy) +\n               np.sin(omega * yy) * np.cos(omega * zz) +\n               np.sin(omega * zz) * np.cos(omega * xx))\n    else:\n        raise ValueError(\"Unknown shape.\")\n\n    # 3. Isosurface Threshold t\n    t = np.quantile(phi, 1.0 - f)\n\n    # 4. Surface Energy E_surf\n    # Gradient of phi using centered differences with periodic boundaries\n    grad_x = (np.roll(phi, -1, axis=0) - np.roll(phi, 1, axis=0)) / (2.0 * dx)\n    grad_y = (np.roll(phi, -1, axis=1) - np.roll(phi, 1, axis=1)) / (2.0 * dx)\n    grad_z = (np.roll(phi, -1, axis=2) - np.roll(phi, 1, axis=2)) / (2.0 * dx)\n    \n    grad_phi_norm = np.sqrt(grad_x**2 + grad_y**2 + grad_z**2)\n    \n    # Regularized delta function\n    u_arg = (phi - t) / epsilon\n    delta_eps = (1.0 / (np.sqrt(np.pi) * epsilon)) * np.exp(-u_arg**2)\n    \n    # Surface area integral approximation\n    surface_area = np.sum(delta_eps * grad_phi_norm) * (dx**3)\n    E_surf = a_s * surface_area\n\n    # 5. Coulomb Energy E_C\n    # Phase indicator and charge density\n    h = (phi = t).astype(float)\n    rho = h - f\n\n    # FFT-based Poisson solver\n    rho_hat = np.fft.fftn(rho)\n    \n    # Wavevector grid\n    k_freq = np.fft.fftfreq(N, d=dx)\n    kx, ky, kz = np.meshgrid(k_freq, k_freq, k_freq, indexing='ij')\n    # Physical wavevector, k = 2*pi*f\n    k_sq = (2 * np.pi)**2 * (kx**2 + ky**2 + kz**2)\n    \n    # Solve for potential in Fourier space\n    phi_potential_hat = np.zeros_like(rho_hat, dtype=complex)\n    # Avoid division by zero at k=0\n    nonzero_k = k_sq  1e-9 # A small tolerance for floating point k_sq[0,0,0]\n    phi_potential_hat[nonzero_k] = 4 * np.pi * rho_hat[nonzero_k] / k_sq[nonzero_k]\n\n    # Inverse FFT to get potential in real space\n    phi_potential = np.fft.ifftn(phi_potential_hat).real\n    \n    # Coulomb energy integral approximation\n    E_c = 0.5 * a_c * np.sum(rho * phi_potential) * (dx**3)\n\n    return E_surf + E_c\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (f, a_s, a_c, epsilon, delta_max)\n        (0.3, 1.0, 0.1, 0.03, 0.05),\n        (0.5, 0.8, 0.2, 0.03, 0.10),\n        (0.15, 1.2, 0.05, 0.03, 0.05),\n        (0.85, 0.9, 0.25, 0.03, 0.10),\n    ]\n\n    # Shared parameters\n    N = 32\n    k_min = 1\n    k_max = 6\n    k_range = list(range(k_min, k_max + 1))\n    shapes = ['slab', 'rod', 'gyro']\n    \n    all_results = []\n\n    for case in test_cases:\n        f, a_s, a_c, epsilon, delta_max = case\n        \n        min_energies = {}\n        k_stars = {}\n        all_energies = {}\n\n        for shape in shapes:\n            energies_for_shape = [\n                calculate_total_energy(shape, k, f, a_s, a_c, epsilon, N)\n                for k in k_range\n            ]\n            all_energies[shape] = np.array(energies_for_shape)\n            min_idx = np.argmin(all_energies[shape])\n            min_energies[shape] = all_energies[shape][min_idx]\n            k_stars[shape] = k_range[min_idx]\n\n        E_min_gyro = min_energies['gyro']\n        E_min_slab = min_energies['slab']\n        E_min_rod = min_energies['rod']\n\n        # Energy differences\n        dE_gs = E_min_gyro - E_min_slab\n        dE_gr = E_min_gyro - E_min_rod\n\n        # Metastability check\n        is_metastable = False\n        k_star_gyro = k_stars['gyro']\n\n        # Condition (i): Local minimum (curvature check)\n        is_interior = k_min  k_star_gyro  k_max\n        curvature_check = False\n        if is_interior:\n            idx = k_range.index(k_star_gyro)\n            gyro_energies = all_energies['gyro']\n            E_double_prime = gyro_energies[idx + 1] - 2 * gyro_energies[idx] + gyro_energies[idx - 1]\n            if E_double_prime  0:\n                curvature_check = True\n        \n        # Conditions (ii) and (iii): Energy hierarchy\n        E_min_base = min(E_min_slab, E_min_rod)\n        dE_g_base = E_min_gyro - E_min_base\n        \n        energy_diff_check_1 = dE_g_base  0\n        energy_diff_check_2 = dE_g_base = delta_max\n        \n        if curvature_check and energy_diff_check_1 and energy_diff_check_2:\n            is_metastable = True\n\n        case_result = [\n            E_min_gyro, E_min_slab, E_min_rod,\n            dE_gs, dE_gr,\n            is_metastable\n        ]\n        all_results.append(case_result)\n\n    # Final print statement in the exact required format.\n    print(str(all_results))\n\nsolve()\n```", "id": "3579768"}]}