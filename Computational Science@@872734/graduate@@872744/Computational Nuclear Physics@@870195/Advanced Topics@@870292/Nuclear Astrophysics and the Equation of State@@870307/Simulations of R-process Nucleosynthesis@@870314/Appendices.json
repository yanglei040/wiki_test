{"hands_on_practices": [{"introduction": "A credible simulation of nucleosynthesis must be built upon a foundation of physical fidelity. This first practice focuses on the essential task of ensuring your numerical model respects fundamental conservation laws and thermodynamic consistency. You will implement diagnostics and automatic correction procedures for baryon number conservation, charge conservation, and the principle of detailed balance, which connects forward and reverse reaction rates at equilibrium [@problem_id:3590825]. Mastering these techniques is a non-negotiable first step toward building reliable and predictive r-process simulation tools.", "problem": "You are tasked with implementing diagnostic tests and automatic correction procedures for a simplified reaction network representative of rapid neutron-capture process (r-process) nucleosynthesis. The network comprises four species: free neutrons $n$ with mass number $A_n = 1$ and charge number $Z_n = 0$, free protons $p$ with $A_p = 1$ and $Z_p = 1$, a heavy seed nucleus $X$ with mass number $A$ and charge number $Z$, and its neutron-captured successor $X^+$ with mass number $A+1$ and charge number $Z$. The only reaction in the network is radiative neutron capture and its inverse photodisintegration:\n$$\nX + n \\leftrightarrow X^+ + \\gamma.\n$$\nThe forward capture rate per unit volume is given by\n$$\nR_f = n_n \\, n_X \\, \\langle \\sigma v \\rangle,\n$$\nwhere $n_n$ and $n_X$ are the number densities of neutrons and $X$, respectively, and $\\langle \\sigma v \\rangle$ is the thermally averaged product of cross section and relative velocity, expressed in $\\mathrm{m^3/s}$. The reverse photodisintegration rate per unit volume is given by\n$$\nR_r = \\lambda_{\\gamma n} \\, n_{X^+},\n$$\nwhere $\\lambda_{\\gamma n}$ is the photodisintegration rate per $X^+$ nucleus, expressed in $s^{-1}$, and $n_{X^+}$ is the number density of $X^+$. The abundances $Y_i$ are defined per baryon, so that $n_i = Y_i \\, n_b$ for each species $i$, with $n_b = \\rho / m_u$, where $\\rho$ is the mass density in $\\mathrm{kg/m^3}$ and $m_u$ is the atomic mass unit in $\\mathrm{kg}$.\n\nThe time evolution of the abundances under this reaction is governed by\n$$\n\\frac{dY_n}{dt} = -\\frac{R_f}{n_b} + \\frac{R_r}{n_b}, \\quad\n\\frac{dY_X}{dt} = -\\frac{R_f}{n_b} + \\frac{R_r}{n_b}, \\quad\n\\frac{dY_{X^+}}{dt} = \\frac{R_f}{n_b} - \\frac{R_r}{n_b}, \\quad\n\\frac{dY_p}{dt} = 0,\n$$\nwhich follow from counting the changes in particle numbers per unit volume and dividing by $n_b$. These equations exactly conserve total baryon number and charge if evaluated with consistent rates.\n\nThe principle of detailed balance under Nuclear Statistical Equilibrium (NSE) states that the reverse rate $\\lambda_{\\gamma n}$ must be related to the forward rate and thermodynamic quantities via\n$$\n\\lambda_{\\gamma n}^{\\mathrm{db}}(T) = \\langle \\sigma v \\rangle \\frac{2 G_A}{G_{A+1}} \\left( \\frac{m_n k_B T}{2\\pi \\hbar^2} \\right)^{3/2} \\exp\\left( - \\frac{S_n}{k_B T} \\right),\n$$\nwhere $T$ is the temperature in $\\mathrm{K}$, $\\hbar$ is the reduced Planck constant in $\\mathrm{J \\cdot s}$, $m_n$ is the neutron mass in $\\mathrm{kg}$, $k_B$ is the Boltzmann constant in $\\mathrm{J/K}$, $G_A$ and $G_{A+1}$ are the nuclear partition functions of $X$ and $X^+$ (dimensionless), and $S_n$ is the neutron separation energy for $X^+$ in $\\mathrm{J}$. This formula is a well-tested statement of microreversibility for radiative neutron capture and photodisintegration.\n\nYour program must implement:\n- A numerical integrator that advances the abundances $Y_n$, $Y_p$, $Y_X$, and $Y_{X^+}$ through time using an explicit Euler method with a specified timestep.\n- A diagnostic test for detailed balance violation at each step, which evaluates the relative deviation\n$$\nD = \\frac{\\left| \\lambda_{\\gamma n}^{\\mathrm{actual}} - \\lambda_{\\gamma n}^{\\mathrm{db}} \\right|}{\\max\\left( \\lambda_{\\gamma n}^{\\mathrm{db}}, \\varepsilon \\right)},\n$$\nwith a prescribed threshold $\\tau$ and a very small positive $\\varepsilon$ to avoid division by zero (use $\\varepsilon = 10^{-300}$). If $D > \\tau$, a violation is counted and your correction procedure must set $\\lambda_{\\gamma n}^{\\mathrm{used}} = \\lambda_{\\gamma n}^{\\mathrm{db}}$ for the step. Otherwise, use $\\lambda_{\\gamma n}^{\\mathrm{used}} = \\lambda_{\\gamma n}^{\\mathrm{actual}}$.\n- A diagnostic test for conservation of baryon number and charge after each integration step. The invariants to be maintained are\n$$\n\\sum_i A_i Y_i = 1, \\quad \\sum_i Z_i Y_i = Y_e,\n$$\nwhere $Y_e$ is the electron fraction. Because explicit integration and numerical roundoff can introduce small violations, design and implement an automatic correction that projects the abundance vector $\\mathbf{Y}$ back onto the constraint manifold defined by these two linear equalities while minimally perturbing $\\mathbf{Y}$ in the least-squares sense. Use the following procedure:\n  1. Form the residuals\n  $$\n  \\Delta_B = 1 - \\sum_i A_i Y_i, \\quad \\Delta_Q = Y_e - \\sum_i Z_i Y_i.\n  $$\n  2. Compute the correction of the form $\\delta Y_i = \\alpha A_i + \\beta Z_i$ by solving\n  $$\n  \\begin{bmatrix}\n  \\sum_i A_i^2  \\sum_i A_i Z_i \\\\\n  \\sum_i A_i Z_i  \\sum_i Z_i^2\n  \\end{bmatrix}\n  \\begin{bmatrix}\n  \\alpha \\\\ \\beta\n  \\end{bmatrix}\n  =\n  \\begin{bmatrix}\n  \\Delta_B \\\\ \\Delta_Q\n  \\end{bmatrix}.\n  $$\n  3. Update $Y_i \\leftarrow Y_i + \\delta Y_i$ for all species $i$.\n  4. Enforce non-negativity by setting any $Y_i  0$ to $0$, then recompute the residuals and reproject using the same method for up to $2$ additional iterations.\nThis correction guarantees that, in the limit of small residuals, the constraint violations are reduced to machine precision while favoring minimal changes.\n\nYour code must:\n- Use the atomic mass unit $m_u$ as $1.66053906660 \\times 10^{-27} \\, \\mathrm{kg}$, the neutron mass $m_n$ as $1.67492749804 \\times 10^{-27} \\, \\mathrm{kg}$, the Boltzmann constant $k_B$ as $1.380649 \\times 10^{-23} \\, \\mathrm{J/K}$, and the reduced Planck constant $\\hbar$ as $1.054571817 \\times 10^{-34} \\, \\mathrm{J \\cdot s}$.\n- Interpret all quantities in the following units: temperature in $\\mathrm{K}$, density in $\\mathrm{kg/m^3}$, separation energy in $\\mathrm{J}$, reaction rate prefactor $\\langle \\sigma v \\rangle$ in $\\mathrm{m^3/s}$, time in $\\mathrm{s}$, and abundances $Y_i$ dimensionless per baryon.\n- Start with provided initial abundances and parameters for each test case and integrate for the given number of steps and step size.\n\nTest suite:\nImplement the algorithm for the following four test cases. For each case, compute the initial detailed balance rate $\\lambda_{\\gamma n}^{\\mathrm{db}}(t=0)$ and set the actual rate as $\\lambda_{\\gamma n}^{\\mathrm{actual}} = f \\, \\lambda_{\\gamma n}^{\\mathrm{db}}(t=0)$ with a given factor $f$, which remains constant during integration unless corrected by the detailed balance procedure. The partition functions are dimensionless.\n\n- Case $1$ (happy path):\n  - $A = 80$, $Z = 30$, $T = 1.0 \\times 10^{9} \\, \\mathrm{K}$, $\\rho = 1.0 \\times 10^{3} \\, \\mathrm{kg/m^3}$, $Y_e = 0.25$,\n  - $Y_n(0) = 0.347$, $Y_p(0) = 0.01$, $Y_X(0) = 0.005$, $Y_{X^+}(0) = 0.003$,\n  - $\\langle \\sigma v \\rangle = 1.0 \\times 10^{-30} \\, \\mathrm{m^3/s}$, $S_n = 3.20436 \\times 10^{-13} \\, \\mathrm{J}$ (corresponding to $2.0 \\, \\mathrm{MeV}$),\n  - $G_A = 1.0$, $G_{A+1} = 1.0$, $f = 1.2$,\n  - Steps $= 1000$, $\\Delta t = 1.0 \\times 10^{-2} \\, \\mathrm{s}$, threshold $\\tau = 0.05$.\n\n- Case $2$ (large detailed balance violation):\n  - $A = 130$, $Z = 50$, $T = 1.5 \\times 10^{9} \\, \\mathrm{K}$, $\\rho = 5.0 \\times 10^{2} \\, \\mathrm{kg/m^3}$, $Y_e = 0.10$,\n  - $Y_n(0) = 0.7795$, $Y_p(0) = 0.025$, $Y_X(0) = 0.001$, $Y_{X^+}(0) = 0.0005$,\n  - $\\langle \\sigma v \\rangle = 5.0 \\times 10^{-31} \\, \\mathrm{m^3/s}$, $S_n = 2.40327 \\times 10^{-13} \\, \\mathrm{J}$ (corresponding to $1.5 \\, \\mathrm{MeV}$),\n  - $G_A = 1.0$, $G_{A+1} = 1.0$, $f = 5.0$,\n  - Steps $= 800$, $\\Delta t = 2.0 \\times 10^{-2} \\, \\mathrm{s}$, threshold $\\tau = 0.05$.\n\n- Case $3$ (edge case with exact detailed balance at $t=0$):\n  - $A = 60$, $Z = 25$, $T = 5.0 \\times 10^{8} \\, \\mathrm{K}$, $\\rho = 5.0 \\times 10^{1} \\, \\mathrm{kg/m^3}$, $Y_e = 0.35$,\n  - $Y_n(0) = 0.544$, $Y_p(0) = 0.275$, $Y_X(0) = 0.002$, $Y_{X^+}(0) = 0.001$,\n  - $\\langle \\sigma v \\rangle = 1.0 \\times 10^{-31} \\, \\mathrm{m^3/s}$, $S_n = 4.80654 \\times 10^{-13} \\, \\mathrm{J}$ (corresponding to $3.0 \\, \\mathrm{MeV}$),\n  - $G_A = 1.0$, $G_{A+1} = 1.0$, $f = 1.0$,\n  - Steps $= 1200$, $\\Delta t = 1.0 \\times 10^{-2} \\, \\mathrm{s}$, threshold $\\tau = 0.05$.\n\n- Case $4$ (negative abundance initialization to test correction robustness):\n  - $A = 90$, $Z = 35$, $T = 8.0 \\times 10^{8} \\, \\mathrm{K}$, $\\rho = 8.0 \\times 10^{2} \\, \\mathrm{kg/m^3}$, $Y_e = 0.20$,\n  - $Y_n(0) = 0.580056$, $Y_p(0) = 0.060035$, $Y_X(0) = 0.004$, $Y_{X^+}(0) = -1.0 \\times 10^{-6}$,\n  - $\\langle \\sigma v \\rangle = 2.0 \\times 10^{-31} \\, \\mathrm{m^3/s}$, $S_n = 3.52496 \\times 10^{-13} \\, \\mathrm{J}$ (corresponding to $2.2 \\, \\mathrm{MeV}$),\n  - $G_A = 1.0$, $G_{A+1} = 1.0$, $f = 0.5$,\n  - Steps $= 900$, $\\Delta t = 1.0 \\times 10^{-2} \\, \\mathrm{s}$, threshold $\\tau = 0.05$.\n\nFor each test case, your program must compute and return the following outputs after completing the integration:\n- The integer count of steps where the detailed balance violation metric $D$ exceeded the threshold $\\tau$ and therefore triggered correction.\n- The final absolute baryon conservation error $\\left| \\sum_i A_i Y_i - 1 \\right|$ as a floating-point number, in dimensionless abundance units.\n- The final absolute charge conservation error $\\left| \\sum_i Z_i Y_i - Y_e \\right|$ as a floating-point number, in dimensionless abundance units.\n- The maximum relative detailed balance deviation after correction across all steps, defined as $\\max \\left( \\frac{ \\left| \\lambda_{\\gamma n}^{\\mathrm{used}} - \\lambda_{\\gamma n}^{\\mathrm{db}} \\right| }{ \\max\\left( \\lambda_{\\gamma n}^{\\mathrm{db}}, \\varepsilon \\right) } \\right)$, as a floating-point number, in dimensionless units.\n\nFinal output format:\nYour program should produce a single line of output containing the results for the four cases as a comma-separated list of lists enclosed in square brackets, for example $[\\,[c_1,b_1,q_1,m_1],[c_2,b_2,q_2,m_2],[c_3,b_3,q_3,m_3],[c_4,b_4,q_4,m_4]\\,]$, where each $c_i$ is an integer and each $b_i$, $q_i$, and $m_i$ are floating-point numbers.", "solution": "The user has provided a valid problem statement. The problem is scientifically grounded in the principles of nuclear reaction network theory, mathematically well-posed, and provides a complete and unambiguous specification of the task. The task is to implement a numerical simulation of a simplified r-process network, including diagnostic tests and correction procedures for ensuring physical consistency. The provided initial conditions and parameters are sufficient and consistent for a numerical solution. We will proceed to develop the solution as specified.\n\nThe core of the problem is to simulate the time evolution of a system of four chemical species—neutrons ($n$), protons ($p$), a heavy seed nucleus ($X$), and its neutron-capture product ($X^+$)—undergoing the reaction $X + n \\leftrightarrow X^+ + \\gamma$. The abundances of these species, denoted by $Y_i$ (fraction of total baryons), evolve according to a set of ordinary differential equations (ODEs). The simulation must be performed using an explicit Euler method, while incorporating two critical numerical procedures: one to enforce detailed balance and another to maintain the conservation of baryon number and charge.\n\nFirst, we define the state of the system by the abundance vector $\\mathbf{Y} = [Y_n, Y_p, Y_X, Y_{X^+}]^T$. The mass and charge numbers for the species are given by the vectors $\\mathbf{A} = [A_n, A_p, A_X, A_{X^+}]^T = [1, 1, A, A+1]^T$ and $\\mathbf{Z} = [Z_n, Z_p, Z_X, Z_{X^+}]^T = [0, 1, Z, Z]^T$, respectively.\n\nThe time evolution of the abundances is governed by the net reaction flow. The forward rate per unit volume (neutron capture) is $R_f = n_n \\, n_X \\, \\langle \\sigma v \\rangle$, and the reverse rate per unit volume (photodisintegration) is $R_r = \\lambda_{\\gamma n} \\, n_{X^+}$. Expressing number densities $n_i$ in terms of abundances $Y_i$ via $n_i = Y_i \\, n_b$, where $n_b = \\rho/m_u$ is the total baryon number density, the rate equations become:\n$$\n\\frac{dY_n}{dt} = \\frac{dY_X}{dt} = -\\frac{R_f}{n_b} + \\frac{R_r}{n_b} = - \\Phi\n$$\n$$\n\\frac{dY_{X^+}}{dt} = \\frac{R_f}{n_b} - \\frac{R_r}{n_b} = \\Phi\n$$\n$$\n\\frac{dY_p}{dt} = 0\n$$\nwhere the net reaction flow per baryon, $\\Phi$, is given by:\n$$\n\\Phi = \\frac{R_f - R_r}{n_b} = \\langle \\sigma v \\rangle \\frac{\\rho}{m_u} Y_n Y_X - \\lambda_{\\gamma n} Y_{X^+}\n$$\nThe system of ODEs is integrated numerically using the explicit Euler method:\n$$\n\\mathbf{Y}(t + \\Delta t) = \\mathbf{Y}(t) + \\Delta t \\frac{d\\mathbf{Y}}{dt}\\bigg|_t\n$$\n\nA critical aspect of physical consistency is adherence to the principle of detailed balance, which connects the forward and reverse rates at thermodynamic equilibrium. For the reaction $X + n \\leftrightarrow X^+ + \\gamma$, the photodisintegration rate $\\lambda_{\\gamma n}$ of the nucleus $X^+$ depends only on temperature and is given by:\n$$\n\\lambda_{\\gamma n}^{\\mathrm{db}}(T) = \\langle \\sigma v \\rangle \\frac{2 G_A}{G_{A+1}} \\left( \\frac{m_n k_B T}{2\\pi \\hbar^2} \\right)^{3/2} \\exp\\left( - \\frac{S_n}{k_B T} \\right)\n$$\nwhere all quantities are provided physical parameters. Since the temperature $T$ is constant for each test case, this equilibrium rate is also constant. In a numerical simulation, the provided \"actual\" rate $\\lambda_{\\gamma n}^{\\mathrm{actual}}$ may violate this principle. A diagnostic test measures the relative deviation:\n$$\nD = \\frac{\\left| \\lambda_{\\gamma n}^{\\mathrm{actual}} - \\lambda_{\\gamma n}^{\\mathrm{db}} \\right|}{\\max\\left( \\lambda_{\\gamma n}^{\\mathrm{db}}, \\varepsilon \\right)}\n$$\nIf $D$ exceeds a threshold $\\tau$, the rate used in the calculation for that step, $\\lambda_{\\gamma n}^{\\mathrm{used}}$, must be set to $\\lambda_{\\gamma n}^{\\mathrm{db}}$ to restore physical consistency. Otherwise, $\\lambda_{\\gamma n}^{\\mathrm{used}} = \\lambda_{\\gamma n}^{\\mathrm{actual}}$. The count of these correction events is one of the required outputs.\n\nThe second crucial procedure is the enforcement of conservation laws. The total baryon number and charge per baryon must be conserved throughout the simulation. These are expressed as two linear constraints on the abundance vector:\n$$\n\\sum_i A_i Y_i = 1 \\quad \\text{(Baryon number conservation)}\n$$\n$$\n\\sum_i Z_i Y_i = Y_e \\quad \\text{(Charge conservation)}\n$$\nNumerical methods, particularly explicit schemes, do not automatically preserve such invariants, leading to gradual or catastrophic drift. To counteract this, a projection method is applied after each integration step. Given an updated abundance vector $\\mathbf{Y}'$ that violates the constraints, we seek a minimal correction $\\delta \\mathbf{Y}$ such that $\\mathbf{Y}'' = \\mathbf{Y}' + \\delta \\mathbf{Y}$ satisfies them. The problem specifies the correction form $\\delta Y_i = \\alpha A_i + \\beta Z_i$, which constitutes a projection onto the subspace spanned by the constraint vectors $\\mathbf{A}$ and $\\mathbf{Z}$. The unknown coefficients $\\alpha$ and $\\beta$ are found by solving the linear system derived from substituting $\\delta \\mathbf{Y}$ into the constraint equations:\n$$\n\\sum_i A_i (Y'_i + \\alpha A_i + \\beta Z_i) = 1 \\implies \\alpha \\sum_i A_i^2 + \\beta \\sum_i A_i Z_i = 1 - \\sum_i A_i Y'_i = \\Delta_B\n$$\n$$\n\\sum_i Z_i (Y'_i + \\alpha A_i + \\beta Z_i) = Y_e \\implies \\alpha \\sum_i A_i Z_i + \\beta \\sum_i Z_i^2 = Y_e - \\sum_i Z_i Y'_i = \\Delta_Q\n$$\nThis yields the matrix equation:\n$$\n\\begin{bmatrix}\n\\sum_i A_i^2  \\sum_i A_i Z_i \\\\\n\\sum_i A_i Z_i  \\sum_i Z_i^2\n\\end{bmatrix}\n\\begin{bmatrix}\n\\alpha \\\\ \\beta\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\Delta_B \\\\ \\Delta_Q\n\\end{bmatrix}\n$$\nSolving this $2 \\times 2$ system for $\\alpha$ and $\\beta$ provides the correction $\\delta Y_i$. After updating the abundances, non-negativity ($Y_i \\geq 0$) is enforced. The problem requires this correction process (residual calculation, solving for correction, updating, enforcing non-negativity) to be repeated up to three times to handle potentially large initial errors or negative abundances produced by the correction itself. This entire correction procedure is applied to the initial state to ensure it is valid before integration begins, and after each subsequent timestep.\n\nThe overall algorithm for each test case is as follows:\n1.  Initialize physical constants, parameters, and the initial abundance vector $\\mathbf{Y}$.\n2.  Apply the iterative conservation correction to the initial $\\mathbf{Y}$ to ensure it satisfies constraints and non-negativity.\n3.  Calculate the constant detailed balance rate $\\lambda_{\\gamma n}^{\\mathrm{db}}$ based on the constant temperature $T$. Set the constant `actual` rate $\\lambda_{\\gamma n}^{\\mathrm{actual}} = f \\cdot \\lambda_{\\gamma n}^{\\mathrm{db}}$.\n4.  Begin the time-stepping loop for the specified number of steps:\n    a. Evaluate the deviation $D$ and determine $\\lambda_{\\gamma n}^{\\mathrm{used}}$ based on the threshold $\\tau$. Record any correction event and the post-correction deviation.\n    b. Compute the reaction flow $\\Phi$ using $\\lambda_{\\gamma n}^{\\mathrm{used}}$.\n    c. Calculate the abundance derivatives $d\\mathbf{Y}/dt$.\n    d. Perform one explicit Euler step: $\\mathbf{Y} \\leftarrow \\mathbf{Y} + \\Delta t \\cdot d\\mathbf{Y}/dt$.\n    f. Apply the iterative conservation correction procedure to the new $\\mathbf{Y}$.\n5.  After the loop finishes, compute the final absolute errors in baryon and charge conservation and report them along with the total count of detailed balance corrections and the maximum post-correction detailed balance deviation observed during the simulation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    # Physical Constants\n    M_U = 1.66053906660e-27  # kg\n    M_N = 1.67492749804e-27  # kg\n    K_B = 1.380649e-23        # J/K\n    H_BAR = 1.054571817e-34   # J s\n    EPSILON = 1e-300          # Small number to avoid division by zero\n\n    constants = {'m_u': M_U, 'm_n': M_N, 'k_B': K_B, 'hbar': H_BAR, 'epsilon': EPSILON}\n\n    # Test Cases\n    test_cases = [\n        # Case 1\n        {'A': 80, 'Z': 30, 'T': 1.0e9, 'rho': 1.0e3, 'Ye': 0.25,\n         'Y0': [0.347, 0.01, 0.005, 0.003],\n         'sv': 1.0e-30, 'Sn': 3.20436e-13, 'GA': 1.0, 'GA_plus_1': 1.0, 'f': 1.2,\n         'steps': 1000, 'dt': 1.0e-2, 'tau': 0.05},\n        # Case 2\n        {'A': 130, 'Z': 50, 'T': 1.5e9, 'rho': 5.0e2, 'Ye': 0.10,\n         'Y0': [0.7795, 0.025, 0.001, 0.0005],\n         'sv': 5.0e-31, 'Sn': 2.40327e-13, 'GA': 1.0, 'GA_plus_1': 1.0, 'f': 5.0,\n         'steps': 800, 'dt': 2.0e-2, 'tau': 0.05},\n        # Case 3\n        {'A': 60, 'Z': 25, 'T': 5.0e8, 'rho': 5.0e1, 'Ye': 0.35,\n         'Y0': [0.544, 0.275, 0.002, 0.001],\n         'sv': 1.0e-31, 'Sn': 4.80654e-13, 'GA': 1.0, 'GA_plus_1': 1.0, 'f': 1.0,\n         'steps': 1200, 'dt': 1.0e-2, 'tau': 0.05},\n        # Case 4\n        {'A': 90, 'Z': 35, 'T': 8.0e8, 'rho': 8.0e2, 'Ye': 0.20,\n         'Y0': [0.580056, 0.060035, 0.004, -1.0e-6],\n         'sv': 2.0e-31, 'Sn': 3.52496e-13, 'GA': 1.0, 'GA_plus_1': 1.0, 'f': 0.5,\n         'steps': 900, 'dt': 1.0e-2, 'tau': 0.05},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(case, constants)\n        results.append(result)\n\n    # Format the final output string\n    formatted_results = [f\"[{r[0]},{r[1]},{r[2]},{r[3]}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef run_simulation(params, consts):\n    \"\"\"\n    Runs a single simulation case.\n    \"\"\"\n    A_val, Z_val = params['A'], params['Z']\n    T, rho, Ye = params['T'], params['rho'], params['Ye']\n    sv, Sn = params['sv'], params['Sn']\n    GA, GA_plus_1 = params['GA'], params['GA_plus_1']\n    f, steps, dt, tau = params['f'], params['steps'], params['dt'], params['tau']\n\n    m_u, m_n = consts['m_u'], consts['m_n']\n    k_B, hbar = consts['k_B'], consts['hbar']\n    epsilon = consts['epsilon']\n\n    # Species vectors: n, p, X, X+\n    A_vec = np.array([1.0, 1.0, A_val, A_val + 1.0])\n    Z_vec = np.array([0.0, 1.0, Z_val, Z_val])\n\n    # Initial abundances\n    Y = np.array(params['Y0'], dtype=np.float64)\n\n    # Pre-simulation state correction\n    Y = correct_conservation(Y, A_vec, Z_vec, Ye)\n\n    n_b = rho / m_u\n\n    # Calculate constant detailed balance rate and actual rate\n    lambda_db = calculate_lambda_db(T, sv, Sn, GA, GA_plus_1, m_n, k_B, hbar)\n    lambda_actual = f * lambda_db\n\n    # Detailed balance check is now constant throughout the simulation\n    deviation = abs(lambda_actual - lambda_db) / max(lambda_db, epsilon)\n    if deviation > tau:\n        lambda_used = lambda_db\n        db_violations = steps\n    else:\n        lambda_used = lambda_actual\n        db_violations = 0\n    \n    dev_after_corr = abs(lambda_used - lambda_db) / max(lambda_db, epsilon)\n    max_db_dev = dev_after_corr\n\n    # Main integration loop\n    for _ in range(steps):\n        # Derivatives calculation\n        n_n = Y[0] * n_b\n        R_f = n_n * (Y[2] * n_b) * sv\n        R_r = lambda_used * (Y[3] * n_b)\n        Phi = (R_f - R_r) / n_b\n        dY_dt = np.array([-Phi, 0.0, -Phi, Phi])\n\n        # Euler Step\n        Y = Y + dt * dY_dt\n\n        # Conservation Correction\n        Y = correct_conservation(Y, A_vec, Z_vec, Ye)\n\n    # Final metrics\n    baryon_error = abs(1.0 - np.sum(A_vec * Y))\n    charge_error = abs(Ye - np.sum(Z_vec * Y))\n\n    return [db_violations, baryon_error, charge_error, max_db_dev]\n\ndef calculate_lambda_db(T, sv, Sn, GA, GA_plus_1, m_n, k_B, hbar):\n    \"\"\"\n    Calculates the photodissociation rate consistent with detailed balance.\n    This rate depends only on temperature.\n    \"\"\"\n    # This is the neutron quantum concentration n_Q\n    n_Q = ((m_n * k_B * T) / (2.0 * np.pi * hbar**2))**1.5\n    \n    partition_ratio = (2.0 * GA) / GA_plus_1\n    boltzmann_factor = np.exp(-Sn / (k_B * T))\n\n    lambda_db = sv * partition_ratio * n_Q * boltzmann_factor\n    return lambda_db\n\ndef correct_conservation(Y, A_vec, Z_vec, Ye):\n    \"\"\"\n    Applies an iterative projection method to enforce baryon and charge conservation.\n    \"\"\"\n    Y_corrected = np.copy(Y)\n    \n    # Matrix M = C * C^T\n    M = np.array([\n        [np.sum(A_vec**2), np.sum(A_vec * Z_vec)],\n        [np.sum(A_vec * Z_vec), np.sum(Z_vec**2)]\n    ])\n    \n    # Iterative correction\n    for _ in range(3):\n        # Compute residuals\n        delta_B = 1.0 - np.sum(A_vec * Y_corrected)\n        delta_Q = Ye - np.sum(Z_vec * Y_corrected)\n\n        # Early exit if conserved\n        if abs(delta_B)  1e-15 and abs(delta_Q)  1e-15:\n            break\n            \n        # Solve for Lagrange multipliers alpha, beta\n        residuals = np.array([delta_B, delta_Q])\n        try:\n            alpha_beta = np.linalg.solve(M, residuals)\n        except np.linalg.LinAlgError:\n            # This should not happen if A_vec and Z_vec are linearly independent.\n            alpha_beta = np.zeros(2)\n\n        # Apply correction\n        delta_Y = alpha_beta[0] * A_vec + alpha_beta[1] * Z_vec\n        Y_corrected += delta_Y\n\n        # Enforce non-negativity\n        Y_corrected[Y_corrected  0] = 0.0\n\n    return Y_corrected\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3590825"}, {"introduction": "The r-process is often conceptualized through the waiting-point approximation (WPA), which assumes that fast neutron capture and photodisintegration reactions reach a local equilibrium within an isotopic chain. In this exercise, you will move beyond this assumption to test its limits by building a full kinetic model from first principles [@problem_id:3590848]. By comparing your kinetic results to the WPA prediction across a range of astrophysical conditions, you will gain a quantitative understanding of when this crucial approximation holds and when a full network solution is required.", "problem": "Construct a program that quantitatively tests the validity of the waiting-point approximation for a single isotopic chain in rapid neutron-capture process (r-process) nucleosynthesis by scanning neutron number density and temperature pairs and comparing the resulting waiting-point distribution to the solution of the full linear reaction-kinetics system over a finite time. The model must be fully specified and internally consistent, starting from detailed balance and nuclear statistical equilibrium within an isotopic chain.\n\nYou must assume a fixed isotopic chain of five consecutive isotopes labeled by an index $i \\in \\{0,1,2,3,4\\}$ that represent increasing mass number within a fixed proton number $Z$ chain. Let the neutron separation energy sequence (in megaelectronvolts) be\n$S_n(0)=3.5$, $S_n(1)=3.0$, $S_n(2)=2.5$, $S_n(3)=2.2$, $S_n(4)=1.8$,\nwhich is a plausible decreasing trend with increasing neutron number in neutron-rich isotopes. Assume the following physically motivated modeling choices and constants.\n\n- The neutron capture rate from isotope $i$ to isotope $i+1$ is $r^{\\mathrm{cap}}_i = n_n \\langle \\sigma v \\rangle$, with $r^{\\mathrm{cap}}_{4}=0$, where $n_n$ is the free neutron number density (in $\\mathrm{cm}^{-3}$) and $\\langle \\sigma v \\rangle = \\sigma_0 v_{\\mathrm{th}}$ with a constant effective capture cross section $\\sigma_0 = 5\\times 10^{-24}\\ \\mathrm{cm}^2$ and thermal relative speed $v_{\\mathrm{th}} = \\sqrt{\\frac{8 k_B T}{\\pi m_n}}$ in $\\mathrm{cm/s}$. Here $k_B$ is the Boltzmann constant and $m_n$ is the neutron mass.\n- The photodisintegration rate that removes one neutron from isotope $i$ back to isotope $i-1$ is $\\lambda^{\\gamma n}_i$ with $\\lambda^{\\gamma n}_0=0$. Enforce detailed balance with the capture channel under nuclear statistical equilibrium by requiring\n$$\n\\lambda^{\\gamma n}_i \\;=\\; \\langle \\sigma v \\rangle \\times \\frac{2 G_{i-1}}{G_i} \\times n_Q \\times \\exp\\!\\left(-\\frac{S_n(i)}{k_B T}\\right) \\quad \\text{for } i\\ge 1,\n$$\nwhere $G_i$ is the normalized internal partition function of isotope $i$, take $G_i=1$ for all $i$, and $n_Q$ is the neutron quantum concentration defined by\n$$\nn_Q \\;=\\; \\left( \\frac{m_n k_B T}{2\\pi \\hbar^2} \\right)^{3/2}.\n$$\nHere $\\hbar$ is the reduced Planck constant.\n- All physical constants must be used with self-consistent units. The temperature input $T$ is given in gigakelvin and must be converted to kelvin as $T_{\\mathrm{K}} = T \\times 10^9$. The neutron density $n_n$ is in $\\mathrm{cm}^{-3}$. Compute $v_{\\mathrm{th}}$ using $T_{\\mathrm{K}}$ and convert it to $\\mathrm{cm/s}$. Compute $n_Q$ in $\\mathrm{m}^{-3}$ and convert it to $\\mathrm{cm}^{-3}$ by dividing by $10^6$. For Boltzmann factors $\\exp(-S_n/k_BT)$ and $\\exp(S_n/k_BT)$, use $k_B T$ in the same energy units as $S_n$, namely megaelectronvolts; you must therefore use $k_B = 8.617333262\\times 10^{-11}\\ \\mathrm{MeV/K}$ for those exponentials.\n\nDefine the full linear reaction-kinetics system for the abundance vector $\\mathbf{Y}(t) = (Y_0(t),\\dots,Y_4(t))^\\top$ with the inflow/outflow structure induced by single-neutron capture and single-neutron photodisintegration within the chain:\n- For $i=0$,\n$$\n\\frac{dY_0}{dt} \\;=\\; - r^{\\mathrm{cap}}_0 Y_0 \\;+\\; \\lambda^{\\gamma n}_1 Y_1.\n$$\n- For $0i4$,\n$$\n\\frac{dY_i}{dt} \\;=\\; r^{\\mathrm{cap}}_{i-1} Y_{i-1} \\;-\\; \\left( r^{\\mathrm{cap}}_i + \\lambda^{\\gamma n}_i \\right) Y_i \\;+\\; \\lambda^{\\gamma n}_{i+1} Y_{i+1}.\n$$\n- For $i=4$,\n$$\n\\frac{dY_4}{dt} \\;=\\; r^{\\mathrm{cap}}_{3} Y_{3} \\;-\\; \\lambda^{\\gamma n}_4 Y_4.\n$$\nThese equations can be written as $\\frac{d\\mathbf{Y}}{dt} = \\mathbf{M}\\,\\mathbf{Y}$ with a tri-diagonal rate matrix $\\mathbf{M}$ determined by $\\{r^{\\mathrm{cap}}_i\\}$ and $\\{\\lambda^{\\gamma n}_i\\}$. Use the initial condition $Y_2(0)=1$ and $Y_i(0)=0$ for all $i\\neq 2$, which represents all initial abundance localized at the central isotope $i=2$. Evolve to a specified final time $t_{\\mathrm{final}}$ (in seconds) to obtain $\\mathbf{Y}^{\\mathrm{kin}}(t_{\\mathrm{final}})$, the kinetic solution. Ensure that any small numerical negative components in $\\mathbf{Y}^{\\mathrm{kin}}$ are clipped to zero and renormalize so that $\\sum_i Y_i=1$ within machine precision.\n\nDefine the waiting-point approximation (nuclear statistical equilibrium within the isotopic chain) distribution $\\mathbf{Y}^{\\mathrm{WPA}}$ as the chain determined by the Saha-like ratios between adjacent isotopes,\n$$\n\\frac{Y^{\\mathrm{WPA}}_{i}}{Y^{\\mathrm{WPA}}_{i-1}} \\;=\\; n_n\\,\\Theta\\,\\frac{G_i}{2 G_{i-1}}\\;\\exp\\!\\left(\\frac{S_n(i)}{k_B T}\\right) \\quad \\text{for } i=1,2,3,4,\n$$\nwith $\\Theta = n_Q^{-1}$ and $G_i=1$. Construct $\\mathbf{Y}^{\\mathrm{WPA}}$ up to normalization by taking $Y^{\\mathrm{WPA}}_0=1$ and $Y^{\\mathrm{WPA}}_i = Y^{\\mathrm{WPA}}_{i-1}\\times \\left[n_n \\Theta \\times \\frac{1}{2} \\times \\exp\\left(\\frac{S_n(i)}{k_B T}\\right)\\right]$ for $i\\ge 1$, and then normalize so that $\\sum_i Y^{\\mathrm{WPA}}_i = 1$.\n\nQuantify the deviation between the kinetic solution at finite time and the waiting-point approximation by the total variation distance\n$$\n\\Delta \\;=\\; \\frac{1}{2} \\sum_{i=0}^{4} \\left| Y^{\\mathrm{kin}}_i(t_{\\mathrm{final}}) - Y^{\\mathrm{WPA}}_i \\right|.\n$$\nThis deviation is dimensionless and satisfies $0 \\le \\Delta \\le 1$.\n\nYour program must implement the model and compute $\\Delta$ for the following test suite of neutron density, temperature, and evolution time triplets:\n- Case A (typical r-process conditions with fast equilibration): $(n_n, T, t_{\\mathrm{final}}) = (10^{25}\\ \\mathrm{cm}^{-3},\\ 1.5\\ \\mathrm{GK},\\ 10^{-3}\\ \\mathrm{s})$.\n- Case B (slower kinetics at lower neutron density and shorter time): $(10^{20}\\ \\mathrm{cm}^{-3},\\ 1.0\\ \\mathrm{GK},\\ 10^{-6}\\ \\mathrm{s})$.\n- Case C (higher temperature with strong photodisintegration but long time): $(10^{24}\\ \\mathrm{cm}^{-3},\\ 2.0\\ \\mathrm{GK},\\ 5\\times 10^{-4}\\ \\mathrm{s})$.\n- Case D (low temperature, low neutron density, short time leading to freeze-out): $(10^{18}\\ \\mathrm{cm}^{-3},\\ 0.5\\ \\mathrm{GK},\\ 10^{-5}\\ \\mathrm{s})$.\n\nAll physical constants must be used in their standard values:\n- $k_B = 1.380649 \\times 10^{-23} \\, \\mathrm{J/K}$ for kinematic speeds and $k_B = 8.617333262 \\times 10^{-11} \\, \\mathrm{MeV/K}$ in Boltzmann factors.\n- $\\hbar = 1.054571817 \\times 10^{-34} \\, \\mathrm{J \\cdot s}$.\n- $m_n = 1.67492749804 \\times 10^{-27} \\, \\mathrm{kg}$.\n\nThe required final output format is a single line containing the four deviations $\\Delta$ for Cases A, B, C, and D in that order, formatted as a comma-separated list enclosed in square brackets with no spaces, each as scientific notation with six significant figures (for example, $[1.234560\\mathrm{e}{-03},7.890000\\mathrm{e}{-02},\\dots]$). Your program must produce exactly this single line as its only output. Since $\\Delta$ is dimensionless, no physical unit is required in the output.", "solution": "The problem requires a quantitative comparison between two models for describing nuclear abundances in an isotopic chain under conditions relevant to the rapid neutron-capture (r-) process: a full time-dependent reaction kinetics model and the waiting-point approximation (WPA). The comparison is to be performed by calculating the total variation distance between the abundance distributions predicted by each model at a specified final time for several sets of astrophysical conditions (neutron number density $n_n$, temperature $T$, and evolution time $t_{\\mathrm{final}}$).\n\nFirst, we establish the physical and mathematical framework based on the provided specifications. The system consists of five isotopes of a single element (fixed proton number $Z$), indexed by $i \\in \\{0, 1, 2, 3, 4\\}$, corresponding to increasing mass and neutron numbers. The primary reactions considered are single-neutron capture, $(n, \\gamma)$, and its inverse, photodisintegration, $(\\gamma, n)$.\n\nThe rate of neutron capture on isotope $i$, producing isotope $i+1$, is denoted by $r^{\\mathrm{cap}}_i$. This rate is proportional to the free neutron number density $n_n$ and the thermally-averaged rate coefficient $\\langle \\sigma v \\rangle$:\n$$\nr^{\\mathrm{cap}}_i = n_n \\langle \\sigma v \\rangle\n$$\nThe rate coefficient is modeled as $\\langle \\sigma v \\rangle = \\sigma_0 v_{\\mathrm{th}}$, where $\\sigma_0 = 5 \\times 10^{-24}\\ \\mathrm{cm}^2$ is a constant effective cross section, and $v_{\\mathrm{th}} = \\sqrt{\\frac{8 k_B T}{\\pi m_n}}$ is the mean relative speed between neutrons and nuclei at temperature $T$. The capture chain terminates at isotope $i=4$, so $r^{\\mathrm{cap}}_4 = 0$.\n\nThe reverse reaction, photodisintegration of isotope $i$ into isotope $i-1$ and a neutron, occurs at a rate $\\lambda^{\\gamma n}_i$. This rate is not an independent parameter but is linked to the capture rate via the principle of detailed balance, which must hold in nuclear statistical equilibrium. The provided relation is:\n$$\n\\lambda^{\\gamma n}_i = \\langle \\sigma v \\rangle \\frac{2 G_{i-1}}{G_i} n_Q \\exp\\left(-\\frac{S_n(i)}{k_B T}\\right) \\quad \\text{for } i \\ge 1\n$$\nHere, $G_i$ is the partition function of nucleus $i$ (taken as $G_i=1$), $S_n(i)$ is the neutron separation energy for nucleus $i$, and $n_Q$ is the neutron quantum concentration:\n$$\nn_Q = \\left( \\frac{m_n k_B T}{2\\pi \\hbar^2} \\right)^{3/2}\n$$\nThe factor of $2$ accounts for the spin degeneracy of the free neutron. The exponential term is the standard Boltzmann factor governing the thermodynamics of the reaction, where $k_B T$ must be in the same energy units as $S_n$ (megaelectronvolts, MeV). Photodisintegration is not possible for the lightest isotope, so $\\lambda^{\\gamma n}_0=0$.\n\nWith these rates, we can formulate the two models for the abundance vector $\\mathbf{Y}(t) = (Y_0(t), Y_1(t), Y_2(t), Y_3(t), Y_4(t))^\\top$.\n\n**1. The Full Reaction-Kinetics Model**\n\nThis model describes the time evolution of abundances via a system of coupled linear ordinary differential equations, representing the net flow into and out of each isotopic state. The system is written as $\\frac{d\\mathbf{Y}}{dt} = \\mathbf{M} \\mathbf{Y}$, where the rate matrix $\\mathbf{M}$ is constructed from the capture and photodisintegration rates. The explicit equations are:\n$$\n\\frac{dY_0}{dt} = -r^{\\mathrm{cap}}_0 Y_0 + \\lambda^{\\gamma n}_1 Y_1\n$$\n$$\n\\frac{dY_i}{dt} = r^{\\mathrm{cap}}_{i-1} Y_{i-1} - (r^{\\mathrm{cap}}_i + \\lambda^{\\gamma n}_i) Y_i + \\lambda^{\\gamma n}_{i+1} Y_{i+1} \\quad \\text{for } i \\in \\{1, 2, 3\\}\n$$\n$$\n\\frac{dY_4}{dt} = r^{\\mathrm{cap}}_3 Y_3 - \\lambda^{\\gamma n}_4 Y_4\n$$\nThis defines a $5 \\times 5$ tridiagonal matrix $\\mathbf{M}$. For a given initial abundance vector $\\mathbf{Y}(0)$, the solution at time $t_{\\mathrm{final}}$ is given by the action of the matrix exponential on the initial vector:\n$$\n\\mathbf{Y}^{\\mathrm{kin}}(t_{\\mathrm{final}}) = \\exp(\\mathbf{M} t_{\\mathrm{final}}) \\mathbf{Y}(0)\n$$\nThe problem specifies the initial condition as all material being in the state $i=2$, i.e., $\\mathbf{Y}(0) = (0, 0, 1, 0, 0)^\\top$. The calculation of the matrix exponential $\\exp(\\mathbf{M} t_{\\mathrm{final}})$ is a standard numerical linear algebra task, for which we use `scipy.linalg.expm`. After evolution, the resulting vector $\\mathbf{Y}^{\\mathrm{kin}}(t_{\\mathrm{final}})$ is processed by clipping any small negative values arising from numerical error to zero and renormalizing such that $\\sum_i Y^{\\mathrm{kin}}_i = 1$.\n\n**2. The Waiting-Point Approximation (WPA)**\n\nThe WPA assumes that the reactions are so fast compared to other timescales (like beta-decay, which is not considered here) that a state of nuclear statistical equilibrium is reached and maintained within the isotopic chain. In this equilibrium, the net flow for each reaction link is zero:\n$$\nr^{\\mathrm{cap}}_{i-1} Y_{i-1} = \\lambda^{\\gamma n}_i Y_i \\quad \\text{for each } i \\in \\{1, 2, 3, 4\\}\n$$\nThis leads to a set of Saha-like equations for the ratios of adjacent abundances:\n$$\n\\frac{Y^{\\mathrm{WPA}}_i}{Y^{\\mathrm{WPA}}_{i-1}} = \\frac{r^{\\mathrm{cap}}_{i-1}}{\\lambda^{\\gamma n}_i} = \\frac{n_n \\langle \\sigma v \\rangle}{\\langle \\sigma v \\rangle \\frac{2 G_{i-1}}{G_i} n_Q \\exp\\left(-\\frac{S_n(i)}{k_B T}\\right)} = n_n n_Q^{-1} \\frac{G_i}{2 G_{i-1}} \\exp\\left(\\frac{S_n(i)}{k_B T}\\right)\n$$\nGiven $G_i=1$, this simplifies the ratio. The WPA abundance distribution $\\mathbf{Y}^{\\mathrm{WPA}}$ is constructed by setting $Y^{\\mathrm{WPA}}_0 = 1$, calculating the subsequent unnormalized abundances $Y^{\\mathrm{WPA}}_i$ using these ratios, and finally normalizing the entire vector so that $\\sum_i Y^{\\mathrm{WPA}}_i = 1$. The WPA distribution is stationary and depends only on $n_n$ and $T$, not on time or the initial state.\n\n**3. The Comparison Metric**\n\nThe quantitative difference between the time-evolved kinetic solution $\\mathbf{Y}^{\\mathrm{kin}}(t_{\\mathrm{final}})$ and the equilibrium WPA solution $\\mathbf{Y}^{\\mathrm{WPA}}$ is measured by the total variation distance, $\\Delta$:\n$$\n\\Delta = \\frac{1}{2} \\sum_{i=0}^{4} \\left| Y^{\\mathrm{kin}}_i(t_{\\mathrm{final}}) - Y^{\\mathrm{WPA}}_i \\right|\n$$\nThis metric ranges from $\\Delta=0$ for identical distributions to $\\Delta=1$ for completely disjoint distributions. A small value of $\\Delta$ indicates that the system has had sufficient time for the given conditions to relax to the equilibrium state predicted by the WPA. A large value indicates that the system is far from equilibrium at $t_{\\mathrm{final}}$.\n\nThe implementation will proceed by first defining all physical constants with the specified precision and units. For each test case $(n_n, T, t_{\\mathrm{final}})$, the code will compute the necessary rates, construct the rate matrix $\\mathbf{M}$ for the kinetic model, solve for $\\mathbf{Y}^{\\mathrm{kin}}(t_{\\mathrm{final}})$, compute the equilibrium distribution $\\mathbf{Y}^{\\mathrm{WPA}}$, and finally calculate $\\Delta$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Computes the deviation between a kinetic reaction network solution and the\n    waiting-point approximation for an r-process isotopic chain.\n    \"\"\"\n\n    # Physical Constants\n    KB_J_K = 1.380649e-23  # Boltzmann constant in J/K\n    KB_MEV_K = 8.617333262e-11 # Boltzmann constant in MeV/K\n    HBAR_JS = 1.054571817e-34 # Reduced Planck constant in J*s\n    M_N_KG = 1.67492749804e-27 # Neutron mass in kg\n\n    # Model Parameters\n    SIGMA0_CM2 = 5e-24  # Neutron capture cross section in cm^2\n    S_N_MEV = np.array([3.5, 3.0, 2.5, 2.2, 1.8]) # Neutron separation energies in MeV\n    NUM_ISOTOPES = 5\n\n    def calculate_deviation(n_n_cm3, T_GK, t_final_s):\n        \"\"\"\n        Calculates the total variation distance for a given set of conditions.\n        \n        Args:\n            n_n_cm3 (float): Neutron number density in cm^-3.\n            T_GK (float): Temperature in Gigakelvin.\n            t_final_s (float): Final evolution time in seconds.\n\n        Returns:\n            float: The total variation distance Delta.\n        \"\"\"\n        # --- Unit Conversions and Basic Quantities ---\n        T_K = T_GK * 1e9  # Temperature in Kelvin\n        kBT_MeV = KB_MEV_K * T_K # Thermal energy in MeV\n\n        # --- Calculate Rates ---\n\n        # Thermal velocity v_th in cm/s\n        v_th_ms = np.sqrt((8 * KB_J_K * T_K) / (np.pi * M_N_KG))\n        v_th_cms = v_th_ms * 100.0\n\n        # Rate coefficient sigma v in cm^3/s\n        sigma_v_cm3_s = SIGMA0_CM2 * v_th_cms\n        \n        # Neutron capture rates r_cap in s^-1\n        r_cap = np.zeros(NUM_ISOTOPES)\n        r_cap[:-1] = n_n_cm3 * sigma_v_cm3_s\n\n        # Neutron quantum concentration n_Q in cm^-3\n        n_q_m3 = ((M_N_KG * KB_J_K * T_K) / (2 * np.pi * HBAR_JS**2))**1.5\n        n_q_cm3 = n_q_m3 * 1e-6\n        \n        # Photodisintegration rates lambda_gn in s^-1\n        lambda_gn = np.zeros(NUM_ISOTOPES)\n        # G_i = 1 for all i, so G_i-1/G_i = 1\n        # Factor 2 is for neutron spin degeneracy\n        for i in range(1, NUM_ISOTOPES):\n            # Using S_n(i) for photodisintegration from isotope i\n            lambda_gn[i] = sigma_v_cm3_s * 2.0 * n_q_cm3 * np.exp(-S_N_MEV[i] / kBT_MeV)\n\n        # --- 1. Kinetic Model Solution ---\n\n        # Construct the rate matrix M (5x5)\n        M = np.zeros((NUM_ISOTOPES, NUM_ISOTOPES))\n        \n        # Diagonal elements: -(total loss rate)\n        M.flat[::NUM_ISOTOPES+1] = -(r_cap + lambda_gn)\n        \n        # Super-diagonal elements: M[i, i+1] (flow from i+1 to i via photodisintegration)\n        for i in range(NUM_ISOTOPES - 1):\n            M[i, i+1] = lambda_gn[i+1]\n            \n        # Sub-diagonal elements: M[i, i-1] (flow from i-1 to i via capture)\n        for i in range(1, NUM_ISOTOPES):\n            M[i, i-1] = r_cap[i-1]\n\n        # Initial condition: Y(0) = [0, 0, 1, 0, 0]\n        Y0 = np.zeros(NUM_ISOTOPES)\n        Y0[2] = 1.0\n\n        # Evolve: Y(t_final) = exp(M * t_final) * Y(0)\n        M_t = M * t_final_s\n        exp_M_t = expm(M_t)\n        Y_kin = exp_M_t @ Y0\n\n        # Post-process: clip negatives and re-normalize\n        Y_kin[Y_kin  0] = 0.0\n        norm_kin = np.sum(Y_kin)\n        if norm_kin  0:\n            Y_kin /= norm_kin\n\n        # --- 2. Waiting-Point Approximation (WPA) Solution ---\n\n        Y_wpa = np.zeros(NUM_ISOTOPES)\n        Y_wpa[0] = 1.0 # Set initial reference abundance\n        \n        # Calculate ratios Y[i]/Y[i-1]\n        for i in range(1, NUM_ISOTOPES):\n            # G_i=1 implies G_i/G_i-1 = 1\n            ratio = (n_n_cm3 / n_q_cm3) * (1.0 / 2.0) * np.exp(S_N_MEV[i] / kBT_MeV)\n            Y_wpa[i] = Y_wpa[i-1] * ratio\n\n        # Normalize WPA distribution\n        norm_wpa = np.sum(Y_wpa)\n        if norm_wpa  0:\n            Y_wpa /= norm_wpa\n            \n        # --- 3. Calculate Deviation ---\n\n        delta = 0.5 * np.sum(np.abs(Y_kin - Y_wpa))\n        \n        return delta\n\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (n_n, T, t_final)\n        (1e25, 1.5, 1e-3),\n        # Case B\n        (1e20, 1.0, 1e-6),\n        # Case C\n        (1e24, 2.0, 5e-4),\n        # Case D\n        (1e18, 0.5, 1e-5),\n    ]\n\n    results = []\n    for case in test_cases:\n        n_n, T, t_final = case\n        result = calculate_deviation(n_n, T, t_final)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6e}' for r in results)}]\")\n\nsolve()\n```", "id": "3590848"}, {"introduction": "The vast disparity in timescales between fast neutron captures and slow beta decays makes r-process reaction networks notoriously 'stiff' systems of ordinary differential equations. This final practice confronts this core numerical challenge head-on by having you quantify stiffness using the spectral properties of the system's Jacobian matrix [@problem_id:3590855]. You will then implement an intelligent, adaptive integration strategy that dynamically switches between non-stiff (explicit) and stiff (implicit) solvers, mirroring a key technique used in state-of-the-art simulation codes to achieve both accuracy and efficiency.", "problem": "You are modeling a simplified reaction network relevant to simulations of rapid neutron-capture process (r-process) nucleosynthesis. Consider a linear three-isotope chain with neutron capture and beta decay. Let the state vector be $Y(t) = [Y_1(t), Y_2(t), Y_3(t)]^\\top$, representing number abundances per baryon (dimensionless). The coupled Ordinary Differential Equation (ODE) system for $Y(t)$ is governed by mass-action kinetics with a time-dependent neutron-capture rate and constant beta-decay rates:\n$$\n\\frac{d}{dt}\n\\begin{bmatrix}\nY_1 \\\\\nY_2 \\\\\nY_3\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n- k_c(t) Y_1 - \\beta_1 Y_1 \\\\\nk_c(t) Y_1 - k_c(t) Y_2 - \\beta_2 Y_2 \\\\\nk_c(t) Y_2 - k_c(t) Y_3 - \\beta_3 Y_3\n\\end{bmatrix},\n$$\nwhere $k_c(t) = k_0 \\, e^{-t/\\tau}$ is the effective neutron-capture rate with units $\\mathrm{s}^{-1}$, $k_0$ is a constant with units $\\mathrm{s}^{-1}$, and $\\tau$ is a decay timescale with units $\\mathrm{s}$. The beta-decay rates $\\beta_1$, $\\beta_2$, $\\beta_3$ are constants with units $\\mathrm{s}^{-1}$. Define the Jacobian matrix $J(t,Y) = \\partial f/\\partial Y$ of the right-hand side $f(t,Y)$ of the ODE. A common stiffness indicator is the largest magnitude eigenvalue $\\lambda_{\\max}(J(t,Y))$ of $J(t,Y)$.\n\nYour task is to write a complete, runnable program that:\n- Implements the ODE system and its Jacobian.\n- Computes and tracks the largest-magnitude eigenvalue $\\lambda_{\\max}(J(t,Y))$ over time (units $\\mathrm{s}^{-1}$).\n- Designs and applies a solver-switching policy based on two thresholds $0  \\theta_{\\mathrm{low}}  \\theta_{\\mathrm{high}}$, both with units $\\mathrm{s}^{-1}$, as follows:\n  - If the current integration method is explicit and $|\\lambda_{\\max}(J(t,Y))| \\ge \\theta_{\\mathrm{high}}$, immediately switch to a stiff method.\n  - If the current integration method is stiff and $|\\lambda_{\\max}(J(t,Y))| \\le \\theta_{\\mathrm{low}}$, immediately switch to a nonstiff explicit method.\n  - Use hysteresis: in the intermediate region $\\theta_{\\mathrm{low}}  |\\lambda_{\\max}(J(t,Y))|  \\theta_{\\mathrm{high}}$, retain the current method.\n  - The initial method at $t=0$ must be chosen consistently with the policy using $|\\lambda_{\\max}(J(0,Y(0)))|$ and the thresholds.\n- Integrates from initial time $t_0 = 0$ to final time $t_f$ and returns:\n  - The integer number of method switches that occurred strictly after $t=0$.\n  - The maximum observed value of $|\\lambda_{\\max}(J(t,Y))|$ over the interval $[0,t_f]$ as a float, expressed in $\\mathrm{s}^{-1}$.\n  - The final abundances $Y_1(t_f)$, $Y_2(t_f)$, $Y_3(t_f)$ as floats.\n\nUse the following initial condition and parameters for all tests unless otherwise stated: $Y_1(0)=1$, $Y_2(0)=0$, $Y_3(0)=0$ (dimensionless), and relative/absolute tolerances for integration must be chosen to ensure numerical accuracy appropriate for stiff linear systems. Angles are not involved. All reported physical rates must implicitly be in $\\mathrm{s}^{-1}$. Times are in $\\mathrm{s}$. Express all returned floats in plain decimal form.\n\nYou must implement the solver-switching by partitioning the time domain into subintervals and integrating with the chosen method on each subinterval. At subinterval boundaries where the hysteresis rule triggers, reinitialize the integrator with the new method and continue. You may assume the use of a robust implicit method for stiff regimes and an explicit method for nonstiff regimes. The Jacobian should be used by the stiff solver.\n\nYour program must run the following test suite and aggregate the results:\n\n- Test case $1$ (happy path; one expected switch from stiff to nonstiff):\n  - $k_0 = 50$, $\\tau = 0.5$, $(\\beta_1,\\beta_2,\\beta_3) = (0.5, 1.0, 2.0)$, $t_f = 2.0$, $\\theta_{\\mathrm{low}} = 10$, $\\theta_{\\mathrm{high}} = 20$.\n\n- Test case $2$ (always nonstiff):\n  - $k_0 = 1.0$, $\\tau = 0.5$, $(\\beta_1,\\beta_2,\\beta_3) = (0.5, 1.0, 2.0)$, $t_f = 2.0$, $\\theta_{\\mathrm{low}} = 10$, $\\theta_{\\mathrm{high}} = 20$.\n\n- Test case $3$ (always stiff over the horizon):\n  - $k_0 = 200$, $\\tau = 5.0$, $(\\beta_1,\\beta_2,\\beta_3) = (0.5, 1.0, 2.0)$, $t_f = 1.0$, $\\theta_{\\mathrm{low}} = 30$, $\\theta_{\\mathrm{high}} = 60$.\n\nFor each test case, your program must produce a list of five numbers in the order $[\\text{num\\_switches}, \\max |\\lambda_{\\max}|, Y_1(t_f), Y_2(t_f), Y_3(t_f)]$. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each test case’s list enclosed in its own square brackets. For example: \"[[a,b,c,d,e],[f,g,h,i,j],[k,l,m,n,o]]\".", "solution": "The user-provided problem statement has been validated and is deemed **valid**. It is scientifically grounded, well-posed, objective, and contains all necessary information to construct a unique and meaningful solution. The task involves solving a system of linear ordinary differential equations (ODEs) derived from a simplified nuclear reaction network, implementing a custom integration strategy that switches between stiff and nonstiff solvers based on an analysis of the system's stiffness.\n\nThe solution proceeds in four stages:\n1.  Derivation and analysis of the system's Jacobian matrix.\n2.  Analysis of the stiffness indicator, which is the largest-magnitude eigenvalue of the Jacobian.\n3.  Design of a solver-switching algorithm based on this analysis.\n4.  Implementation of the algorithm to solve the provided test cases.\n\n**1. System Analysis and Jacobian Derivation**\n\nThe system of ODEs describes the time evolution of three isotope abundances, $Y_1(t)$, $Y_2(t)$, and $Y_3(t)$, assembled in a state vector $Y(t) = [Y_1(t), Y_2(t), Y_3(t)]^\\top$. The governing equation is $\\frac{dY}{dt} = f(t, Y)$, where:\n$$\nf(t, Y) =\n\\begin{bmatrix}\n- k_c(t) Y_1 - \\beta_1 Y_1 \\\\\nk_c(t) Y_1 - k_c(t) Y_2 - \\beta_2 Y_2 \\\\\nk_c(t) Y_2 - k_c(t) Y_3 - \\beta_3 Y_3\n\\end{bmatrix}\n$$\nThis is a linear system, which can be expressed in matrix form as $\\frac{dY}{dt} = A(t)Y$, with the reaction matrix $A(t)$ given by:\n$$\nA(t) =\n\\begin{bmatrix}\n-k_c(t) - \\beta_1  0  0 \\\\\nk_c(t)  -k_c(t) - \\beta_2  0 \\\\\n0  k_c(t)  -k_c(t) - \\beta_3\n\\end{bmatrix}\n$$\nwhere $k_c(t) = k_0 e^{-t/\\tau}$. The Jacobian of the system, $J(t, Y) = \\frac{\\partial f}{\\partial Y}$, quantifies how the rates of change of the state variables respond to infinitesimal changes in the state variables themselves. Because the ODE system is linear in $Y$, the Jacobian is simply the matrix $A(t)$ and is independent of the state vector $Y$:\n$$\nJ(t) = A(t) =\n\\begin{bmatrix}\n-k_c(t) - \\beta_1  0  0 \\\\\nk_c(t)  -k_c(t) - \\beta_2  0 \\\\\n0  k_c(t)  -k_c(t) - \\beta_3\n\\end{bmatrix}\n$$\n\n**2. Stiffness Indicator Analysis**\n\nThe stiffness of the system is assessed using the largest-magnitude eigenvalue of the Jacobian, which we denote $|\\lambda|_{\\max}(t)$. The Jacobian $J(t)$ is a lower-triangular matrix. A fundamental property of triangular matrices is that their eigenvalues are their diagonal entries. Thus, the eigenvalues of $J(t)$ are:\n$$\n\\lambda_1(t) = -k_c(t) - \\beta_1\n$$\n$$\n\\lambda_2(t) = -k_c(t) - \\beta_2\n$$\n$$\n\\lambda_3(t) = -k_c(t) - \\beta_3\n$$\nThe problem parameters $k_0$, $\\tau$, and $\\beta_i$ for $i \\in \\{1, 2, 3\\}$ are all positive constants. The neutron-capture rate $k_c(t) = k_0 e^{-t/\\tau}$ is consequently always non-negative for $t \\ge 0$. Therefore, all three eigenvalues $\\lambda_i(t)$ are real and strictly negative for all $t \\ge 0$.\n\nThe stiffness indicator is the maximum of the absolute values of these eigenvalues:\n$$\n|\\lambda|_{\\max}(t) = \\max \\left( | -k_c(t) - \\beta_1 |, | -k_c(t) - \\beta_2 |, | -k_c(t) - \\beta_3 | \\right)\n$$\nSince $k_c(t) \\ge 0$ and $\\beta_i  0$, this simplifies to:\n$$\n|\\lambda|_{\\max}(t) = \\max \\left( k_c(t) + \\beta_1, k_c(t) + \\beta_2, k_c(t) + \\beta_3 \\right)\n$$\nThis can be further simplified to:\n$$\n|\\lambda|_{\\max}(t) = k_c(t) + \\max(\\beta_1, \\beta_2, \\beta_3) = k_0 e^{-t/\\tau} + \\max_{i} \\beta_i\n$$\nThis analytical expression for the stiffness indicator reveals a critical property: since $k_c(t)$ is a strictly monotonically decreasing function of time $t$ for $t  0$, $|\\lambda|_{\\max}(t)$ is also a strictly monotonically decreasing function of time. This insight greatly simplifies the design of the solver-switching algorithm. Specifically, the maximum value of the stiffness indicator over the entire integration interval $[0, t_f]$ must occur at the initial time, $t=0$:\n$$\n\\max_{t \\in [0, t_f]} |\\lambda|_{\\max}(t) = |\\lambda|_{\\max}(0) = k_0 e^0 + \\max_{i} \\beta_i = k_0 + \\max_{i} \\beta_i\n$$\n\n**3. Algorithm Design for Solver Switching**\n\nThe monotonicity of $|\\lambda|_{\\max}(t)$ dictates that the system can only transition from a more stiff regime to a less stiff one. It can never switch from nonstiff to stiff, nor can it oscillate between the two states. This allows for a predictive, rather than reactive, approach to solver switching.\n\nThe algorithm is as follows:\n\n1.  **Determine Initial Solver:** The choice of the initial solver at $t=0$ depends on the initial stiffness $|\\lambda|_{\\max}(0) = k_0 + \\max_{i} \\beta_i$ relative to the high threshold $\\theta_{\\mathrm{high}}$.\n    *   If $|\\lambda|_{\\max}(0) \\ge \\theta_{\\mathrm{high}}$, the system is initially stiff. We start with a stiff solver (e.g., `Radau`).\n    *   If $|\\lambda|_{\\max}(0)  \\theta_{\\mathrm{high}}$, the system is initially nonstiff. We start with a nonstiff explicit solver (e.g., `RK45`).\n\n2.  **Define Integration Strategy:**\n    *   **If starting with a nonstiff solver:** Since $|\\lambda|_{\\max}(t)$ is monotonically decreasing, the condition $|\\lambda|_{\\max}(t) \\ge \\theta_{\\mathrm{high}}$ will never be met for $t  0$. Therefore, no switch will occur. The integration proceeds from $t_0=0$ to $t_f$ with the nonstiff solver. The number of switches is $0$.\n    *   **If starting with a stiff solver:** A switch to a nonstiff solver is triggered if the stiffness falls below the low threshold, i.e., $|\\lambda|_{\\max}(t) \\le \\theta_{\\mathrm{low}}$. We must find the time $t_{\\text{switch}}$ where this threshold is crossed:\n        $$\n        |\\lambda|_{\\max}(t_{\\text{switch}}) = k_0 e^{-t_{\\text{switch}}/\\tau} + \\max_{i} \\beta_i = \\theta_{\\mathrm{low}}\n        $$\n        Solving for $t_{\\text{switch}}$ yields:\n        $$\n        t_{\\text{switch}} = -\\tau \\ln\\left(\\frac{\\theta_{\\mathrm{low}} - \\max_{i} \\beta_i}{k_0}\\right)\n        $$\n        A valid switch occurs only if this equation has a real, positive solution within the integration interval. This requires:\n        a) $\\theta_{\\mathrm{low}} - \\max_{i} \\beta_i  0$, ensuring the argument of the logarithm is positive.\n        b) $0  t_{\\text{switch}}  t_f$.\n\n        If a valid switch point $t_{\\text{switch}}$ exists:\n        - Integrate from $t=0$ to $t=t_{\\text{switch}}$ using the stiff solver.\n        - Use the state $Y(t_{\\text{switch}})$ as the initial condition for the next phase.\n        - Integrate from $t=t_{\\text{switch}}$ to $t=t_f$ using the nonstiff solver.\n        - The number of switches is $1$.\n\n        If no valid $t_{\\text{switch}}$ exists (either because $\\theta_{\\mathrm{low}} \\le \\max_{i} \\beta_i$ or because $t_{\\text{switch}} \\ge t_f$), the system remains stiff for the entire duration.\n        - Integrate from $t=0$ to $t=t_f$ using only the stiff solver.\n        - The number of switches is $0$.\n\n**4. Implementation Details**\n\nThe algorithm is implemented in Python using the `numpy` library for numerical operations and `scipy.integrate.solve_ivp` for solving the ODE system.\n- The ODE function $f(t,Y)$ and its Jacobian $J(t)$ are defined.\n- A main function iterates through each test case.\n- For each case, it first calculates $|\\lambda|_{\\max}(0)$ and the potential $t_{\\text{switch}}$.\n- Based on the logic above, it performs either one or two integrations using `solve_ivp` with the appropriate `method` (`'Radau'` for stiff, `'RK45'` for nonstiff) and `jac` arguments.\n- Strict numerical tolerances (`rtol=1e-9`, `atol=1e-9`) are used to ensure accuracy, which is crucial for stiff systems.\n- The required outputs—number of switches, maximum eigenvalue magnitude, and final abundances—are collected for each test case and formatted as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the r-process nucleosynthesis model.\n    \"\"\"\n    test_cases = [\n        # Test case 1: Happy path (stiff - nonstiff switch)\n        {'k0': 50.0, 'tau': 0.5, 'betas': (0.5, 1.0, 2.0), 'tf': 2.0, 'theta_low': 10.0, 'theta_high': 20.0},\n        # Test case 2: Always nonstiff\n        {'k0': 1.0, 'tau': 0.5, 'betas': (0.5, 1.0, 2.0), 'tf': 2.0, 'theta_low': 10.0, 'theta_high': 20.0},\n        # Test case 3: Always stiff over the horizon\n        {'k0': 200.0, 'tau': 5.0, 'betas': (0.5, 1.0, 2.0), 'tf': 1.0, 'theta_low': 30.0, 'theta_high': 60.0},\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result = _solve_single_case(**params)\n        all_results.append(result)\n\n    # Format the final output as a list of lists of floats/ints.\n    # e.g., \"[[a,b,c,d,e],[f,g,h,i,j],[k,l,m,n,o]]\"\n    formatted_results = [\n        f\"[{res[0]},{res[1]:.10f},{res[2]:.10f},{res[3]:.10f},{res[4]:.10f}]\"\n        for res in all_results\n    ]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef _solve_single_case(k0, tau, betas, tf, theta_low, theta_high):\n    \"\"\"\n    Solves a single instance of the ODE problem with solver switching.\n    \"\"\"\n    y0 = np.array([1.0, 0.0, 0.0])\n    t0 = 0.0\n    \n    # Unpack beta decay rates for clarity\n    beta1, beta2, beta3 = betas\n    beta_max = max(betas)\n\n    # Define the neutron capture rate function\n    def kc(t):\n        return k0 * np.exp(-t / tau)\n\n    # Define the ODE system dy/dt = f(t, y)\n    def ode_system(t, y):\n        y1, y2, y3 = y\n        k_c = kc(t)\n        \n        dy1dt = -k_c * y1 - beta1 * y1\n        dy2dt =  k_c * y1 - k_c * y2 - beta2 * y2\n        dy3dt =  k_c * y2 - k_c * y3 - beta3 * y3\n        \n        return np.array([dy1dt, dy2dt, dy3dt])\n\n    # Define the Jacobian of the ODE system. It's independent of y.\n    def jacobian(t, y):\n        k_c = kc(t)\n        return np.array([\n            [-k_c - beta1,   0.0,            0.0],\n            [ k_c,          -k_c - beta2,   0.0],\n            [ 0.0,           k_c,          -k_c - beta3]\n        ])\n\n    # The largest magnitude eigenvalue is analytical: |lambda_max(t)| = kc(t) + max(betas)\n    def lambda_max_mag(t):\n        return kc(t) + beta_max\n\n    # Calculate max |lambda_max| over the interval [t0, tf].\n    # Since lambda_max_mag(t) is monotonically decreasing, the max is at t=0.\n    max_lambda_observed = lambda_max_mag(t0)\n\n    num_switches = 0\n    \n    # Set high-precision tolerances appropriate for stiff solvers\n    rtol = 1e-9\n    atol = 1e-9\n\n    # Determine initial solver type based on stiffness at t=0\n    # and the logic derived from the problem statement.\n    if max_lambda_observed = theta_high:\n        # Start with a stiff solver\n        current_method = 'stiff'\n        solver_stiff = 'Radau'\n    else:\n        # Start with a non-stiff solver\n        current_method = 'nonstiff'\n        solver_nonstiff = 'RK45'\n    \n    # --- Integration Logic ---\n    if current_method == 'nonstiff':\n        # If we start non-stiff, we'll never switch to stiff because |lambda_max(t)| is decreasing.\n        sol = solve_ivp(\n            fun=ode_system,\n            t_span=(t0, tf),\n            y0=y0,\n            method=solver_nonstiff,\n            rtol=rtol,\n            atol=atol\n        )\n        y_final = sol.y[:, -1]\n\n    else: # current_method == 'stiff'\n        # Check for a potential switch from stiff to non-stiff.\n        # This occurs when |lambda_max(t)| drops below theta_low.\n        t_switch = -1.0\n        # The switch is only possible if theta_low  beta_max\n        if theta_low  beta_max:\n            log_arg = (theta_low - beta_max) / k0\n            # log_arg must be positive and less than 1 for a switch within t0.\n            if 0  log_arg  1:\n                t_switch = -tau * math.log(log_arg)\n        \n        if 0  t_switch  tf:\n            # A switch occurs. Integrate in two steps.\n            num_switches = 1\n            \n            # 1. Stiff integration from t0 to t_switch\n            sol1 = solve_ivp(\n                fun=ode_system,\n                t_span=(t0, t_switch),\n                y0=y0,\n                method=solver_stiff,\n                jac=jacobian,\n                rtol=rtol,\n                atol=atol\n            )\n            \n            # 2. Non-stiff integration from t_switch to tf\n            y_intermediate = sol1.y[:, -1]\n            solver_nonstiff = 'RK45'\n            sol2 = solve_ivp(\n                fun=ode_system,\n                t_span=(t_switch, tf),\n                y0=y_intermediate,\n                method=solver_nonstiff,\n                rtol=rtol,\n                atol=atol\n            )\n            y_final = sol2.y[:, -1]\n        \n        else:\n            # No switch within the interval. Integrate fully with the stiff solver.\n            sol = solve_ivp(\n                fun=ode_system,\n                t_span=(t0, tf),\n                y0=y0,\n                method=solver_stiff,\n                jac=jacobian,\n                rtol=rtol,\n                atol=atol\n            )\n            y_final = sol.y[:, -1]\n\n    y1f, y2f, y3f = y_final\n    return [num_switches, max_lambda_observed, y1f, y2f, y3f]\n\nsolve()\n```", "id": "3590855"}]}