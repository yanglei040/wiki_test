{"hands_on_practices": [{"introduction": "The heart of Brueckner-Hartree-Fock theory is the Bethe-Goldstone equation, which transforms the bare nucleon-nucleon interaction into an effective in-medium interaction, the $G$-matrix. This exercise provides hands-on practice in solving this fundamental integral equation by discretizing it into a matrix equation. You will implement a robust numerical solution and validate it against a known semi-analytic result, a crucial step in building a reliable BHF code [@problem_id:3545576].", "problem": "You are asked to implement a fully self-contained program that constructs a discretized matrix representation of the Bethe-Goldstone equation for the in-medium interaction (the in-medium $G$-matrix) for symmetric nuclear matter at zero total pair momentum. Your task is to start from first principles appropriate to computational nuclear physics and derive the discrete linear system that arises from a quadrature approximation, then implement and evaluate it numerically. You must use a physically plausible single-particle spectrum and a simple but nontrivial separable interaction to enable an internal consistency check. All momenta must be expressed in $\\mathrm{fm}^{-1}$, all energies in $\\mathrm{MeV}$, and angles in radians.\n\nBegin from the standard physical starting point for Brueckner-Hartree-Fock (BHF) theory: the Bethe-Goldstone equation for the in-medium two-body reaction matrix $G$, which in the $S$-wave, zero total momentum approximation can be written as a one-dimensional integral equation in the relative momentum $k$. Adopt the conventional normalization for partial waves in which the three-dimensional integral becomes a factor times an integral in $q \\in [0,\\Lambda]$ over $q^{2}\\,\\mathrm{d}q$, where $\\Lambda$ is a finite momentum cutoff. The intermediate-state Pauli operator must be taken in the angle-average and for zero total momentum reduce to a step function $Q(q,k_{F})=\\Theta(q-k_{F})$, where $k_{F}$ is the Fermi momentum. The single-particle energy must be taken to be the free kinetic spectrum $\\epsilon(q)=\\frac{\\hbar^{2}}{2m_{N}}\\,q^{2}$ with $\\frac{\\hbar^{2}}{2m_{N}}=20.735\\,\\mathrm{MeV}\\cdot\\mathrm{fm}^{2}$. The starting energy is a complex quantity of the form $\\omega + i\\,\\eta$ with real $\\omega$ and a small positive regulator $\\eta$ (with units of $\\mathrm{MeV}$) that implements the causal prescription and regularizes the energy denominator.\n\nUse the rank-$1$ separable Yamaguchi potential in momentum space,\n$$\nV(k,k')=-\\lambda\\,g(k)\\,g(k')\\,,\\qquad g(k)=\\frac{1}{k^{2}+\\beta^{2}}\\,,\n$$\nwith $\\lambda>0$ and range parameter $\\beta>0$. In the $S$-wave and zero center-of-mass momentum, the in-medium Bethe-Goldstone equation becomes a one-dimensional integral equation in $q$ for each pair $(k,k')$, involving the kernel $V(k,q)$, the Pauli factor $Q(q,k_{F})$, and the propagator denominator $\\left[\\omega-\\epsilon(q)-\\epsilon(q)\\right]^{-1}=\\left[\\omega-2\\,\\epsilon(q)\\right]^{-1}$. Your code must discretize the $q$-integral on a finite momentum interval $[0,\\Lambda]$ using a Gaussian quadrature with $N$ nodes and weights $\\{(q_{i},w_{i})\\}_{i=1}^{N}$. To evaluate the $G$-matrix at a specific on-shell momentum $k_{0}$, you must augment the quadrature grid by including $k_{0}$ as an additional collocation point with zero quadrature weight so that it does not alter the integral but does produce $G(k_{0},k')$ through the same linear system. In all expressions, carry the conventional $S$-wave factor explicitly as\n$$\n\\frac{2}{\\pi}\\int_{0}^{\\Lambda} q^{2}\\,\\mathrm{d}q \\,\\cdots \\, .\n$$\n\nNumerically, you must treat the energy denominator\n$$\n\\omega-\\epsilon_{p_{1}}-\\epsilon_{p_{2}}=\\omega-2\\,\\epsilon(q)=\\omega - 2 \\times 20.735\\,q^{2}\\,,\n$$\nby adding the small imaginary regulator so that the denominator is $\\omega-2\\,\\epsilon(q)+i\\,\\eta$ with $\\eta \\ge 0$. The Pauli operator $Q(q,k_{F})$ must be implemented as a sharp step function $Q(q,k_{F})=1$ if $q>k_{F}$ and $Q(q,k_{F})=0$ otherwise. You must formulate the discretized equation as a linear algebra problem on the combined grid $\\{k_{0}\\}\\cup\\{q_{i}\\}_{i=1}^{N}$ and solve for the full matrix $G(k_{a},k_{b};\\omega)$ at those grid points. Then extract the on-shell element $G(k_{0},k_{0};\\omega)$.\n\nTo verify correctness and to assess the numerical treatment of the energy denominator, compute in parallel the closed-form solution that exists for rank-$1$ separable potentials by reducing the Bethe-Goldstone equation to a scalar equation for a strength parameter and then reconstructing the on-shell $G$-matrix element. Use the same quadrature rule and Pauli operator in the scalar equation so that discrepancies reflect only the consistency of your discretization and linear algebra.\n\nTest suite and parameters. For each case below, the input parameters are $(k_{F},k_{0},\\Lambda,N,\\beta,\\lambda,\\omega,\\eta)$, in the stated units. Use exactly these four cases in this order:\n- Case A (free-space, on-shell): $k_{F}=0.0\\,\\mathrm{fm}^{-1}$, $k_{0}=1.0\\,\\mathrm{fm}^{-1}$, $\\Lambda=8.0\\,\\mathrm{fm}^{-1}$, $N=120$, $\\beta=1.4\\,\\mathrm{fm}^{-1}$, $\\lambda=200.0\\,\\mathrm{MeV}\\cdot\\mathrm{fm}^{3}$, $\\omega=2\\times 20.735\\times k_{0}^{2}\\,\\mathrm{MeV}$, $\\eta=1.0\\,\\mathrm{MeV}$.\n- Case B (normal density, on-shell above $k_{F}$): $k_{F}=1.3\\,\\mathrm{fm}^{-1}$, $k_{0}=1.6\\,\\mathrm{fm}^{-1}$, $\\Lambda=8.0\\,\\mathrm{fm}^{-1}$, $N=120$, $\\beta=1.4\\,\\mathrm{fm}^{-1}$, $\\lambda=200.0\\,\\mathrm{MeV}\\cdot\\mathrm{fm}^{3}$, $\\omega=2\\times 20.735\\times k_{0}^{2}\\,\\mathrm{MeV}$, $\\eta=1.0\\,\\mathrm{MeV}$.\n- Case C (near Fermi surface, on-shell just above $k_{F}$): $k_{F}=1.3\\,\\mathrm{fm}^{-1}$, $k_{0}=1.31\\,\\mathrm{fm}^{-1}$, $\\Lambda=8.0\\,\\mathrm{fm}^{-1}$, $N=120$, $\\beta=1.4\\,\\mathrm{fm}^{-1}$, $\\lambda=200.0\\,\\mathrm{MeV}\\cdot\\mathrm{fm}^{3}$, $\\omega=2\\times 20.735\\times k_{0}^{2}\\,\\mathrm{MeV}$, $\\eta=0.5\\,\\mathrm{MeV}$.\n- Case D (off-shell below threshold, free-space): $k_{F}=0.0\\,\\mathrm{fm}^{-1}$, $k_{0}=0.5\\,\\mathrm{fm}^{-1}$, $\\Lambda=8.0\\,\\mathrm{fm}^{-1}$, $N=120$, $\\beta=1.4\\,\\mathrm{fm}^{-1}$, $\\lambda=200.0\\,\\mathrm{MeV}\\cdot\\mathrm{fm}^{3}$, $\\omega=-20.0\\,\\mathrm{MeV}$, $\\eta=0.0\\,\\mathrm{MeV}$.\n\nYour program must, for each case, do the following:\n- Assemble the discretized matrix equation on the combined grid with $k_{0}$ as an additional collocation point of zero quadrature weight and solve for the full $G$-matrix.\n- Extract the on-shell element $G(k_{0},k_{0};\\omega)$.\n- Independently compute the corresponding on-shell element implied by the closed-form separable reduction using the same quadrature and Pauli operator.\n- Return the absolute discrepancies between the two complex numbers’ real and imaginary parts, i.e., $|\\Re G_{\\mathrm{matrix}}-\\Re G_{\\mathrm{sep}}|$ and $|\\Im G_{\\mathrm{matrix}}-\\Im G_{\\mathrm{sep}}|$, expressed in $\\mathrm{MeV}\\cdot\\mathrm{fm}^{3}$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as\n$\\big[$discrepancy for Case A real part, discrepancy for Case A imaginary part, discrepancy for Case B real part, discrepancy for Case B imaginary part, discrepancy for Case C real part, discrepancy for Case C imaginary part, discrepancy for Case D real part, discrepancy for Case D imaginary part$\\big]$.", "solution": "The user requires a numerical solution and verification for the Bethe-Goldstone equation in the context of Brueckner-Hartree-Fock theory for nuclear matter. The problem is validated as scientifically grounded, well-posed, and internally consistent. It represents a standard, albeit simplified, problem in computational nuclear physics.\n\n### 1. Problem Formulation\n\nThe starting point is the Bethe-Goldstone equation for the in-medium reaction matrix, $G$, for two nucleons interacting in symmetric nuclear matter with zero total momentum. In the $S$-wave channel, this is a one-dimensional integral equation:\n$$\nG(k, k'; \\omega) = V(k, k') + \\frac{2}{\\pi} \\int_{0}^{\\Lambda} q^2 dq \\, V(k, q) \\frac{Q(q, k_F)}{\\omega + i\\eta - 2\\epsilon(q)} G(q, k'; \\omega)\n$$\nwhere:\n- $k$ and $k'$ are the initial and final relative momenta.\n- $V(k, k')$ is the nucleon-nucleon interaction in the $S$-wave channel.\n- The integral is over intermediate relative momenta $q$ up to a cutoff $\\Lambda$. The factor $\\frac{2}{\\pi}$ is a specified normalization convention.\n- $Q(q, k_F) = \\Theta(q - k_F)$ is the angle-averaged Pauli exclusion operator, which restricts intermediate states to be above the Fermi momentum $k_F$. It is $1$ for $q > k_F$ and $0$ otherwise.\n- $\\epsilon(q) = \\frac{\\hbar^2 q^2}{2m_N}$ is the single-particle energy of a free nucleon with mass $m_N$. The constant is given as $\\frac{\\hbar^2}{2m_N} = 20.735\\,\\mathrm{MeV}\\cdot\\mathrm{fm}^2$.\n- $\\omega + i\\eta$ is the complex starting energy, with $\\omega$ being the real energy and $\\eta > 0$ a small positive regulator ensuring the correct causal boundary conditions and preventing singularities in the energy denominator.\n\nThe interaction is a rank-$1$ separable Yamaguchi potential:\n$$\nV(k, k') = -\\lambda g(k) g(k') \\quad \\text{with} \\quad g(k) = \\frac{1}{k^2 + \\beta^2}\n$$\nwhere $\\lambda$ is the strength and $\\beta$ is related to the range of the interaction.\n\n### 2. Numerical Discretization and Matrix Formulation\n\nTo solve the integral equation numerically, we discretize the integral over $q \\in [0, \\Lambda]$ using an $N$-point Gaussian quadrature rule. Let the quadrature nodes be $\\{q_i\\}_{i=1}^N$ and the corresponding weights be $\\{w_i\\}_{i=1}^N$. The integral is approximated as:\n$$\n\\int_{0}^{\\Lambda} f(q) dq \\approx \\sum_{i=1}^{N} w_i f(q_i)\n$$\nThe problem requires us to evaluate the $G$-matrix at a specific momentum $k_0$. We augment the set of quadrature nodes with $k_0$ to form a combined grid of collocation points, $P = \\{p_a\\}_{a=0}^N$, where $p_0 = k_0$ and $p_a = q_a$ for $a=1, \\dots, N$. The point $k_0$ is assigned a zero quadrature weight.\n\nThe discretized Bethe-Goldstone equation becomes a system of linear equations for the values of the $G$-matrix at the grid points, $G_{ab} = G(p_a, p_b)$:\n$$\nG(p_a, p_b) = V(p_a, p_b) + \\frac{2}{\\pi} \\sum_{i=1}^{N} w_i q_i^2 V(p_a, q_i) \\frac{Q(q_i, k_F)}{\\omega + i\\eta - 2\\epsilon(q_i)} G(q_i, p_b)\n$$\nRecognizing that $q_i=p_i$ and $G(q_i, p_b)=G_{ib}$, we can write this as a matrix equation. Let us define a matrix $\\mathbf{C}$ of size $(N+1) \\times (N+1)$:\n$$\nC_{ai} = \n\\begin{cases}\n    \\frac{2}{\\pi} w_i q_i^2 V(p_a, q_i) \\frac{Q(q_i, k_F)}{\\omega + i\\eta - 2\\epsilon(q_i)} & \\text{for } i \\in \\{1, \\dots, N\\} \\\\\n    0 & \\text{for } i = 0\n\\end{cases}\n$$\nThe equation for the matrix $\\mathbf{G}$ (with elements $G_{ab}$) in terms of matrix $\\mathbf{V}$ (with elements $V_{ab}$) is:\n$$\n\\mathbf{G} = \\mathbf{V} + \\mathbf{C} \\mathbf{G} \\implies (\\mathbf{I} - \\mathbf{C})\\mathbf{G} = \\mathbf{V}\n$$\nwhere $\\mathbf{I}$ is the identity matrix. The solution is formally $\\mathbf{G} = (\\mathbf{I} - \\mathbf{C})^{-1} \\mathbf{V}$.\n\nSince the potential is separable, $\\mathbf{V}$ is a rank-1 matrix: $V_{ab} = -\\lambda g(p_a) g(p_b)$, which can be written as $\\mathbf{V} = -\\lambda \\vec{g} \\vec{g}^T$, where $\\vec{g}$ is a column vector with elements $g_a = g(p_a)$.\nThe solution for $\\mathbf{G}$ is then $\\mathbf{G} = -\\lambda (\\mathbf{I} - \\mathbf{C})^{-1} (\\vec{g} \\vec{g}^T)$.\nTo find the required element $G_{00} = G(k_0, k_0)$, we can solve the linear system $(\\mathbf{I} - \\mathbf{C})\\vec{y} = \\vec{g}$ for the vector $\\vec{y}$. The solution vector is $\\vec{y} = (\\mathbf{I} - \\mathbf{C})^{-1}\\vec{g}$, and the full $G$-matrix is then $\\mathbf{G} = -\\lambda \\vec{y} \\vec{g}^T$.\nThe specific element we need is $G_{00} = -\\lambda y_0 g_0$, where $y_0$ is the first component of $\\vec{y}$ and $g_0 = g(p_0) = g(k_0)$. This approach avoids constructing the full inverse and is computationally more efficient.\n\n### 3. Closed-Form Separable Reduction\n\nA key feature of a rank-$1$ separable potential is that the integral equation can be solved analytically, reducing it to a scalar algebraic equation. We substitute $V(k, k') = -\\lambda g(k) g(k')$ into the Bethe-Goldstone equation. The structure of the equation implies that $G(k, k')$ must also be separable, so we make the ansatz $G(k, k') = \\tau(\\omega) g(k) g(k')$. Substituting this and canceling $g(k)$ and $g(k')$ yields a scalar equation for the function $\\tau(\\omega)$:\n$$\n\\tau(\\omega) = -\\lambda + \\frac{2}{\\pi} \\int_0^\\Lambda q^2 dq \\, [-\\lambda g(q)] \\frac{Q(q, k_F)}{\\omega' - 2\\epsilon(q)} [\\tau(\\omega) g(q)]\n$$\n$$\n\\tau(\\omega) = -\\lambda - \\lambda \\tau(\\omega) \\left[ \\frac{2}{\\pi} \\int_0^\\Lambda q^2 dq \\frac{g(q)^2 Q(q, k_F)}{\\omega' - 2\\epsilon(q)} \\right]\n$$\nLet's define the loop integral $I(\\omega')$:\n$$\nI(\\omega') = \\frac{2}{\\pi} \\int_0^\\Lambda q^2 dq \\frac{g(q)^2 Q(q, k_F)}{\\omega' - 2\\epsilon(q)}\n$$\nThen $\\tau(\\omega) = -\\lambda / (1 + \\lambda I(\\omega'))$. The G-matrix is thus:\n$$\nG(k, k'; \\omega) = \\frac{-\\lambda g(k) g(k')}{1 + \\lambda I(\\omega')}\n$$\nFor verification, we compute the integral $I(\\omega')$ using the same Gaussian quadrature rule as in the matrix method:\n$$\nI(\\omega') \\approx \\frac{2}{\\pi} \\sum_{i=1}^{N} w_i q_i^2 \\frac{g(q_i)^2 Q(q_i, k_F)}{\\omega' - 2\\epsilon(q_i)}\n$$\nThe on-shell element $G(k_0, k_0; \\omega)$ is then calculated directly from this formula.\n\n### 4. Consistency Check\n\nThe problem is designed such that the matrix method and the separable reduction method are two different numerical routes to the same underlying analytical solution. As derived analytically in the thought process, both methods yield the same expression: $G(k_0, k_0) = \\frac{-\\lambda g(k_0)^2}{1+\\lambda I(\\omega')}$. Therefore, when implemented numerically using the same quadrature scheme, the results from both methods should be identical up to floating-point precision. The requested discrepancies, $|\\Re G_{\\mathrm{matrix}}-\\Re G_{\\mathrm{sep}}|$ and $|\\Im G_{\\mathrm{matrix}}-\\Im G_{\\mathrm{sep}}|$, serve as a stringent test of the correctness and consistency of the implementation of the discretized linear algebra problem.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Main driver function to solve the problem for all specified test cases.\n    \"\"\"\n    # Test suite parameters:\n    # (k_F, k_0, Lambda, N, beta, lambda, omega, eta)\n    HBARC2_2M = 20.735  # MeV*fm^2\n\n    test_cases = [\n        # Case A (free-space, on-shell)\n        (0.0, 1.0, 8.0, 120, 1.4, 200.0, 2 * HBARC2_2M * 1.0**2, 1.0),\n        # Case B (normal density, on-shell above k_F)\n        (1.3, 1.6, 8.0, 120, 1.4, 200.0, 2 * HBARC2_2M * 1.6**2, 1.0),\n        # Case C (near Fermi surface, on-shell just above k_F)\n        (1.3, 1.31, 8.0, 120, 1.4, 200.0, 2 * HBARC2_2M * 1.31**2, 0.5),\n        # Case D (off-shell below threshold, free-space)\n        (0.0, 0.5, 8.0, 120, 1.4, 200.0, -20.0, 0.0),\n    ]\n\n    results = []\n    for case_params in test_cases:\n        d_real, d_imag = solve_case(*case_params)\n        results.append(f\"{d_real:.15e}\")\n        results.append(f\"{d_imag:.15e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef solve_case(kF, k0, Lambda, N, beta, lam, omega, eta):\n    \"\"\"\n    Solves the Bethe-Goldstone equation for a single set of parameters\n    using both the matrix inversion method and the separable reduction,\n    and returns the discrepancies between them.\n    \"\"\"\n    # Physical constant\n    HBARC2_2M = 20.735  # MeV*fm^2\n\n    # 1. Setup Grid and Quadrature\n    # Get N Gauss-Legendre quadrature points (x) and weights (w_prime) for [-1, 1]\n    x_nodes, w_prime = roots_legendre(N)\n    \n    # Map nodes and weights to the integration interval [0, Lambda]\n    q_nodes = Lambda * (x_nodes + 1.0) / 2.0\n    w_nodes = Lambda * w_prime / 2.0\n\n    # The full momentum grid consists of k0 and the quadrature nodes.\n    # p_grid[0] = k0, p_grid[1:] = q_nodes\n    p_grid = np.concatenate(([k0], q_nodes))\n    \n    # 2. Define Physical Quantities\n    def g_form_factor(k_val):\n        return 1.0 / (k_val**2 + beta**2)\n\n    def energy_spectrum(k_val):\n        return HBARC2_2M * k_val**2\n    \n    # Evaluate quantities on the grids\n    epsilon_q = energy_spectrum(q_nodes)\n    g_p = g_form_factor(p_grid)\n    g_q = g_form_factor(q_nodes)\n    \n    # Pauli operator Q(q, kF) = 1 if q > kF, else 0\n    Q_q = (q_nodes > kF).astype(np.float64)\n\n    # Complex starting energy\n    omega_c = complex(omega, eta)\n    \n    # Propagator denominator for all quadrature points\n    propagator_denom = omega_c - 2.0 * epsilon_q\n\n    # 3. Matrix Method for G(k0, k0)\n    # The discretized B-G equation is (I - C)G = V.\n    # For a separable potential, this leads to solving (I - C)y = g_vec,\n    # and then G_00 = -lam * y_0 * g_0.\n\n    # Construct the matrix C of size (N+1) x (N+1)\n    C = np.zeros((N + 1, N + 1), dtype=np.complex128)\n    \n    # Common part of the kernel for all quadrature points\n    kernel_integrand_base = (2.0 / np.pi) * w_nodes * q_nodes**2 * Q_q / propagator_denom\n    \n    # The matrix C's columns for i=1..N are constructed. C's first column (i=0) is zero.\n    for a in range(N + 1):  # Loop over rows of C (momentum p_a)\n        # V(p_a, q_i) = -lam * g(p_a) * g(q_i)\n        # C_{a,i} for i=1..N involves V(p_a, q_{i-1}) in 0-based indexing\n        V_pa_qi = -lam * g_p[a] * g_q\n        C[a, 1:] = kernel_integrand_base * V_pa_qi\n\n    # Form the matrix M = I - C for the linear system M*y = g_vec\n    M = np.identity(N + 1, dtype=np.complex128) - C\n    \n    # The vector g_vec has components g(p_a)\n    g_vec = g_p.astype(np.complex128)\n    \n    # Solve the linear system M*y = g_vec\n    y = np.linalg.solve(M, g_vec)\n    \n    # Calculate G_matrix(k0, k0) which corresponds to G_00\n    G_matrix = -lam * g_p[0] * y[0]\n\n    # 4. Separable Reduction Method for G(k0, k0)\n    # G(k,k') = V(k,k') / (1 + lam*I)\n    # where I = (2/pi) * integral_q [ q^2 * g(q)^2 * Q(q) / (omega' - 2*eps(q)) ]\n    \n    # Evaluate the loop integral I using the same quadrature rule\n    integrand_I = (2.0 / np.pi) * q_nodes**2 * g_q**2 * Q_q / propagator_denom\n    I_val = np.sum(w_nodes * integrand_I)\n    \n    # Calculate G_sep(k0, k0)\n    G_sep = (-lam * g_p[0]**2) / (1.0 + lam * I_val)\n\n    # 5. Compute and return the absolute discrepancies\n    d_real = np.abs(G_matrix.real - G_sep.real)\n    d_imag = np.abs(G_matrix.imag - G_sep.imag)\n\n    return d_real, d_imag\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "3545576"}, {"introduction": "With the $G$-matrix in hand, the next step is to compute bulk properties of nuclear matter, such as the total energy per particle, $E/A$. This quantity, as a function of density, defines the nuclear equation of state. This practice guides you through the calculation of $E/A$ using a simplified, yet powerful, BHF model and reinforces the critical skill of validating your code against well-understood physical limits [@problem_id:3545472].", "problem": "Consider homogeneous symmetric nuclear matter treated within Brueckner-Hartree-Fock (BHF) theory. The Brueckner reaction matrix, commonly called the $G$-matrix, solves the Bethe–Goldstone equation,\n$$\nG(\\mathbf{k},\\mathbf{k}';\\omega) \\;=\\; V(\\mathbf{k},\\mathbf{k}') \\;+\\; \\int \\frac{d^3\\mathbf{q}}{(2\\pi)^3}\\, V(\\mathbf{k},\\mathbf{q}) \\, \\frac{Q(\\mathbf{q},k_F)}{\\omega - 2 e(\\mathbf{q}) + i\\eta} \\, G(\\mathbf{q},\\mathbf{k}';\\omega),\n$$\nwhere $V(\\mathbf{k},\\mathbf{k}')$ is the nucleon-nucleon interaction in momentum space, $Q(\\mathbf{q},k_F)$ is the Pauli blocking operator, $e(\\mathbf{q})$ is the single-particle energy, $\\omega$ is the starting energy, $k_F$ is the Fermi momentum, and $\\eta$ is a positive infinitesimal ensuring causal boundary conditions. In homogeneous nuclear matter, one often adopts the angle-averaged Pauli operator and a free single-particle spectrum, namely $e(\\mathbf{q})$ depends only on $|\\mathbf{q}|$ and is given by $e(q) = \\frac{q^2}{2m}$.\n\nFor this problem, adopt the following simplifying and standard approximations appropriate to a computational validation task:\n- Use a separable Yamaguchi $S$-wave potential of the form\n$$\nV(k,k') \\;=\\; -\\lambda\\, g(k)\\, g(k'), \\qquad g(k) \\;=\\; \\frac{1}{k^2 + \\beta^2},\n$$\nwith positive coupling strength $\\lambda$ and range parameter $\\beta > 0$.\n- Employ isotropic free single-particle energies $e(q)=\\frac{q^2}{2m}$, with nucleon mass $m$.\n- Use the angle-average starting energy $\\omega$ evaluated at the Fermi surface,\n$$\n\\omega \\;=\\; 2 e(k_F),\n$$\nand the angle-averaged Pauli operator $Q(\\mathbf{q},k_F) = \\Theta(q - k_F)$, where $\\Theta$ is the Heaviside step function.\n- Work in natural units with $\\hbar = 1$ and $m = 1$ so that $e(q)=\\frac{q^2}{2}$; all energies and momenta are dimensionless in these units. Express all final energies per particle in these natural units.\n\nUnder these assumptions, the separable structure implies the ansatz\n$$\nG(k,k';\\omega) \\;=\\; g(k)\\, g(k')\\, \\tau(\\omega;k_F),\n$$\nwhere the in-medium $\\tau$ function satisfies\n$$\n\\tau(\\omega;k_F) \\;=\\; \\frac{-\\lambda}{1 + \\lambda\\, J(\\omega;k_F)}, \\qquad\nJ(\\omega;k_F) \\;=\\; \\frac{1}{2\\pi^2} \\int_{k_F}^{\\infty} dq\\, \\frac{q^2\\, g(q)^2}{\\omega - 2 e(q) + i\\eta}.\n$$\nUsing the free spectrum $e(q)=\\frac{q^2}{2}$ and the specified $\\omega=2 e(k_F)=k_F^2$, the real part of $J(\\omega;k_F)$ is the principal value integral\n$$\n\\operatorname{Re}\\, J(k_F^2;k_F) \\;=\\; \\frac{1}{2\\pi^2} \\int_{k_F}^{\\infty} dq\\, q^2\\, g(q)^2 \\, \\frac{k_F^2 - q^2}{(k_F^2 - q^2)^2 + \\eta^2},\n$$\nwhere $\\eta>0$ regularizes the integrable singularity at $q=k_F$ and numerically emulates the principal value. The average of $g(k)^2$ over the occupied Fermi sphere appears via\n$$\nI_F(k_F) \\;=\\; \\frac{1}{2\\pi^2} \\int_0^{k_F} dk\\, k^2\\, g(k)^2.\n$$\n\nIn this simplified angle-averaged separable model, a semi-analytic expression for the interaction energy per particle is obtained by averaging the on-shell $G$-matrix over pairs inside the Fermi sea. Approximating the $\\tau$-function by its value at $\\omega=2e(k_F)$, one obtains\n$$\n\\frac{E_{\\text{pot}}}{A}(k_F) \\;\\approx\\; \\frac{d\\, \\tau(k_F^2;k_F)}{2\\, \\rho(k_F)} \\; \\left[I_F(k_F)\\right]^2,\n$$\nwhere $d$ is an effective channel-weight factor that we set to $d=1$ for a single $S$-wave channel, and the density of symmetric nuclear matter (spin-isospin degeneracy equal to $4$) is\n$$\n\\rho(k_F) \\;=\\; \\frac{4\\, k_F^3}{6\\pi^2} \\;=\\; \\frac{2\\, k_F^3}{3\\pi^2}.\n$$\nThe kinetic energy per particle of a free Fermi gas in these units is\n$$\n\\frac{E_{\\text{kin}}}{A}(k_F) \\;=\\; \\frac{3}{5}\\, e(k_F) \\;=\\; \\frac{3}{10}\\, k_F^2,\n$$\nso that the total energy per particle is\n$$\n\\frac{E}{A}(k_F) \\;=\\; \\frac{E_{\\text{kin}}}{A}(k_F) \\;+\\; \\frac{E_{\\text{pot}}}{A}(k_F).\n$$\n\nTask:\n- Write a complete program that, for a given set of parameters $(k_F,\\beta,\\lambda)$, computes $\\operatorname{Re}\\, J(k_F^2;k_F)$, then $\\tau(k_F^2;k_F)$ using the real part of $J$, evaluates $I_F(k_F)$, and finally returns the total energy per particle $\\frac{E}{A}(k_F)$ in the specified natural units.\n- Use a small positive regulator $\\eta$ (e.g., $\\eta=10^{-6}$) in the numerical integration for $\\operatorname{Re}\\, J$.\n- Implement accurate numerical integration for semi-infinite domains to evaluate the integrals for $J$ and $I_F$.\n- Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"), with each result rounded to six decimal places.\n\nTest Suite:\nCompute the total energy per particle $\\frac{E}{A}(k_F)$ for the following four cases, designed to validate limits and coverage:\n1. Happy-path nuclear-matter-like case: $k_F = 1.33$, $\\beta = 1.0$, $\\lambda = 2.0$.\n2. Zero-coupling limit: $k_F = 1.33$, $\\beta = 1.0$, $\\lambda = 0.0$. In this limit, the output must equal the free Fermi-gas kinetic energy per particle $\\frac{3}{10}k_F^2$.\n3. Low-density boundary: $k_F = 0.1$, $\\beta = 1.0$, $\\lambda = 2.0$. The interaction contribution should be negligible and the output should be close to $\\frac{3}{10}k_F^2$.\n4. Short-range (large $\\beta$) edge case: $k_F = 1.33$, $\\beta = 10.0$, $\\lambda = 2.0$. The Yamaguchi form factor suppresses the interaction and the result should be close to the kinetic term.\n\nYour program should produce a single line of output containing the energies for the four cases in the exact order listed above, formatted as a comma-separated list enclosed in square brackets and rounded to six decimal places, e.g., \"[E1,E2,E3,E4]\".", "solution": "The problem requires the calculation of the total energy per particle, $\\frac{E}{A}$, for symmetric nuclear matter within a simplified Brueckner-Hartree-Fock (BHF) framework. The calculation is based on a specific set of approximations: a separable Yamaguchi potential, a free-particle kinetic energy spectrum, and angle-averaged Pauli operator and starting energy. The task is to implement the provided formulas numerically for a given set of parameters $(k_F, \\beta, \\lambda)$, where $k_F$ is the Fermi momentum, and $\\beta$ and $\\lambda$ are parameters of the potential. We operate in natural units where $\\hbar=1$ and the nucleon mass $m=1$.\n\nThe total energy per particle is the sum of the kinetic and potential energy contributions:\n$$\n\\frac{E}{A}(k_F) = \\frac{E_{\\text{kin}}}{A}(k_F) + \\frac{E_{\\text{pot}}}{A}(k_F)\n$$\n\nThe calculation proceeds by evaluating each component as follows.\n\n**1. Kinetic Energy per Particle**\nFor a free Fermi gas of nucleons in the specified units, the average kinetic energy per particle is given by:\n$$\n\\frac{E_{\\text{kin}}}{A}(k_F) = \\frac{3}{5} e(k_F) = \\frac{3}{5} \\frac{k_F^2}{2m} = \\frac{3}{10} k_F^2\n$$\nThis term depends only on the Fermi momentum $k_F$.\n\n**2. Potential Energy per Particle**\nThe potential energy per particle, within the specified approximations, is given by:\n$$\n\\frac{E_{\\text{pot}}}{A}(k_F) \\approx \\frac{d \\cdot \\tau(k_F^2;k_F)}{2 \\rho(k_F)} [I_F(k_F)]^2\n$$\nHere, the effective channel-weight factor is $d=1$. The three key components to be calculated are the density $\\rho(k_F)$, the integral $I_F(k_F)$, and the in-medium function $\\tau(k_F^2;k_F)$.\n\n**2.1. Nuclear Matter Density, $\\rho(k_F)$**\nThe density of symmetric nuclear matter, accounting for a spin-isospin degeneracy of $4$, is given by:\n$$\n\\rho(k_F) = \\frac{4 \\cdot (\\frac{4}{3}\\pi k_F^3)}{(2\\pi)^3} = \\frac{2k_F^3}{3\\pi^2}\n$$\n\n**2.2. Fermi-Sphere Average Integral, $I_F(k_F)$**\nThis term represents the average of the square of the potential's form factor, $g(k)$, over the occupied states within the Fermi sphere. The form factor for the Yamaguchi potential is $g(k) = \\frac{1}{k^2 + \\beta^2}$. The integral is defined as:\n$$\nI_F(k_F) = \\frac{1}{2\\pi^2} \\int_0^{k_F} dk\\, k^2\\, g(k)^2 = \\frac{1}{2\\pi^2} \\int_0^{k_F} dk\\, \\frac{k^2}{(k^2 + \\beta^2)^2}\n$$\nThis is a proper integral over a finite domain $[0, k_F]$ and will be evaluated using numerical quadrature.\n\n**2.3. The In-Medium Function, $\\tau(k_F^2; k_F)$**\nThe function $\\tau$ captures the effect of the nuclear medium on the two-nucleon interaction. For a separable potential, it is given by:\n$$\n\\tau(\\omega;k_F) = \\frac{-\\lambda}{1 + \\lambda J(\\omega;k_F)}\n$$\nThe problem specifies using the starting energy $\\omega = 2e(k_F) = k_F^2$ and instructs to use only the real part of the loop integral $J(\\omega;k_F)$. Thus, we compute:\n$$\n\\tau(k_F^2;k_F) = \\frac{-\\lambda}{1 + \\lambda \\operatorname{Re}J(k_F^2;k_F)}\n$$\n\n**2.4. The Loop Integral, $\\operatorname{Re}J(k_F^2; k_F)$**\nThe real part of the loop integral $J$ accounts for the propagation of a pair of particles above the Fermi sea. The expression to be computed is:\n$$\n\\operatorname{Re}J(k_F^2;k_F) = \\frac{1}{2\\pi^2} \\int_{k_F}^{\\infty} dq\\, q^2\\, g(q)^2 \\, \\frac{k_F^2 - q^2}{(k_F^2 - q^2)^2 + \\eta^2}\n$$\nSubstituting the form factor $g(q) = \\frac{1}{q^2 + \\beta^2}$, the integrand becomes:\n$$\n\\frac{1}{2\\pi^2} \\frac{q^2}{(q^2 + \\beta^2)^2} \\frac{k_F^2 - q^2}{(k_F^2 - q^2)^2 + \\eta^2}\n$$\nThis integral is over the semi-infinite domain $[k_F, \\infty)$. The term involving $\\eta$ is a regularization of the pole at $q=k_F$ that appears in the principal value integral obtained in the limit $\\eta \\to 0^+$. For a small but finite $\\eta = 10^{-6}$, the integrand is well-behaved, although it may have a sharp feature near $q=k_F$ that requires a robust numerical integration method.\n\n**Computational Algorithm**\nThe algorithm to compute the total energy for a given set of parameters $(k_F, \\beta, \\lambda)$ is as follows:\n1.  Calculate the kinetic energy per particle: $\\frac{E_{\\text{kin}}}{A} = \\frac{3}{10}k_F^2$.\n2.  If $\\lambda=0$, the potential energy is $0$, and the total energy is just the kinetic energy.\n3.  If $\\lambda \\neq 0$:\n    a. Define the integrand for $I_F(k_F)$ and compute the integral numerically from $0$ to $k_F$. Multiply by the prefactor $\\frac{1}{2\\pi^2}$ to get $I_F(k_F)$.\n    b. Define the integrand for $\\operatorname{Re}J(k_F^2;k_F)$ using the regulator $\\eta=10^{-6}$. Compute the integral numerically from $k_F$ to $\\infty$. Multiply by the prefactor $\\frac{1}{2\\pi^2}$ to get $\\operatorname{Re}J(k_F^2;k_F)$.\n    c. Calculate $\\tau(k_F^2;k_F) = \\frac{-\\lambda}{1 + \\lambda \\operatorname{Re}J(k_F^2;k_F)}$.\n    d. Calculate the nuclear density $\\rho(k_F) = \\frac{2k_F^3}{3\\pi^2}$.\n    e. Assemble the potential energy per particle: $\\frac{E_{\\text{pot}}}{A} = \\frac{\\tau(k_F^2;k_F)}{2\\rho(k_F)} [I_F(k_F)]^2$.\n    f. Sum the kinetic and potential energies to obtain the total energy per particle, $\\frac{E}{A}(k_F)$.\n\nThis procedure is implemented for each of the four test cases provided in the problem statement.", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Solves the BHF problem for the given test cases and prints the results.\n    \"\"\"\n\n    # Test cases: (k_F, beta, lambda)\n    test_cases = [\n        (1.33, 1.0, 2.0),\n        (1.33, 1.0, 0.0),\n        (0.1, 1.0, 2.0),\n        (1.33, 10.0, 2.0),\n    ]\n\n    results = []\n    for kF, beta, lam in test_cases:\n        energy = calculate_total_energy_per_particle(kF, beta, lam)\n        results.append(f\"{energy:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_total_energy_per_particle(kF, beta, lam, eta=1e-6):\n    \"\"\"\n    Calculates the total energy per particle for given BHF model parameters.\n\n    Args:\n        kF (float): Fermi momentum.\n        beta (float): Range parameter of the Yamaguchi potential.\n        lam (float): Coupling strength of the Yamaguchi potential.\n        eta (float): Regulator for the principal value integral.\n\n    Returns:\n        float: The total energy per particle E/A.\n    \"\"\"\n    # Kinetic energy per particle for a free Fermi gas in natural units (m=1)\n    E_kin_per_A = (3.0 / 10.0) * kF**2\n\n    # If coupling is zero, potential energy is zero.\n    if lam == 0.0:\n        return E_kin_per_A\n\n    # --- Potential Energy Calculation ---\n\n    # 1. Calculate the integral I_F(kF)\n    # Integrand for I_F\n    def integrand_IF(k):\n        return (k**2) / ((k**2 + beta**2)**2)\n\n    # Numerical integration from 0 to kF\n    integral_val_IF, _ = quad(integrand_IF, 0, kF)\n    I_F_kF = (1.0 / (2.0 * np.pi**2)) * integral_val_IF\n\n    # 2. Calculate the real part of the loop integral, Re[J(omega, kF)]\n    # Integrand for Re[J]\n    def integrand_ReJ(q):\n        # Using kF**2 for omega\n        omega = kF**2\n        g_q_sq = 1.0 / ((q**2 + beta**2)**2)\n        propagator_real_part = (omega - q**2) / ((omega - q**2)**2 + eta**2)\n        return q**2 * g_q_sq * propagator_real_part\n\n    # Numerical integration from kF to infinity\n    integral_val_ReJ, _ = quad(integrand_ReJ, kF, np.inf)\n    ReJ_kF = (1.0 / (2.0 * np.pi**2)) * integral_val_ReJ\n\n    # 3. Calculate the in-medium tau-function\n    tau_kF = -lam / (1.0 + lam * ReJ_kF)\n\n    # 4. Calculate the density rho(kF)\n    rho_kF = (2.0 * kF**3) / (3.0 * np.pi**2)\n\n    # 5. Calculate the potential energy per particle\n    # Effective channel weight d=1\n    E_pot_per_A = (tau_kF / (2.0 * rho_kF)) * (I_F_kF**2)\n\n    # Total energy is the sum of kinetic and potential energies\n    E_total_per_A = E_kin_per_A + E_pot_per_A\n\n    return E_total_per_A\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "3545472"}, {"introduction": "A key success of microscopic nuclear theory is explaining saturation—why nuclear matter has a stable equilibrium density with a binding energy of about $-16$ MeV per nucleon. This phenomenon arises from a delicate cancellation between attractive and repulsive components of the nuclear force. This exercise allows you to computationally investigate this balance by isolating the contribution of the tensor force, demonstrating its essential role in providing the attraction needed for nuclear binding [@problem_id:3545468].", "problem": "You are tasked with writing a complete, runnable program that, within a simplified but principled Brueckner-Hartree-Fock framework, quantifies how turning off the tensor-induced $S$–$D$ coupling in the ${}^3S_1$–${}^3D_1$ channel shifts the saturation point of symmetric nuclear matter. You must base your model on the following fundamental elements and well-tested approximations, and you must compute all energies in mega-electronvolts per nucleon (MeV per nucleon), all densities in inverse cubic femtometers (fm$^{-3}$), all wave numbers in inverse femtometers (fm$^{-1}$), and all ranges in femtometers (fm). The required output is a single line containing a list of floating-point numbers that aggregates the results for multiple test parameter sets as specified below.\n\nStart from the following base:\n\n1. Uniform symmetric nuclear matter with spin-isospin degeneracy $\\nu = 4$. The number density $\\rho$ and the Fermi momentum $k_F$ are related by\n$$\n\\rho = \\frac{\\nu k_F^3}{6\\pi^2} = \\frac{2 k_F^3}{3\\pi^2}.\n$$\n\n2. The kinetic energy per nucleon in a non-relativistic Fermi gas is\n$$\n\\frac{T}{A} = \\frac{3}{5} \\frac{\\hbar^2 k_F^2}{2m},\n$$\nwhere $\\hbar^2/(2m) = 20.735 \\ \\mathrm{MeV\\,fm^2}$.\n\n3. The potential energy per nucleon from a finite-range central force in the Hartree-Fock approximation is given by the coordinate-space expression\n$$\n\\frac{E_{\\text{central}}}{A} = \\frac{\\rho}{2} \\int d^3 r \\, V_c(r) \\left[ 1 - \\frac{1}{\\nu} \\, \\ell^2(k_F r) \\right],\n$$\nwhere $\\ell(x) = \\dfrac{3 j_1(x)}{x}$ is the Slater function with $j_1(x)$ the spherical Bessel function of order $1$. Use a two-Gaussian central potential,\n$$\nV_c(r) = V_R \\, e^{-r^2/\\alpha_R^2} + V_A \\, e^{-r^2/\\alpha_A^2},\n$$\nwith $V_R > 0$ representing short-range repulsion and $V_A < 0$ representing intermediate-range attraction. Implement the angular integration to reduce the integral to\n$$\n\\frac{E_{\\text{central}}}{A} = \\frac{\\rho}{2} \\int_{0}^{\\infty} 4\\pi r^2 \\, V_c(r) \\left[ 1 - \\frac{1}{\\nu} \\, \\ell^2(k_F r) \\right] \\, dr.\n$$\n\n4. The tensor-induced ${}^3S_1$–${}^3D_1$ coupling does not contribute at Hartree-Fock order in spin-saturated matter. To include it, approximate the second-order Brueckner correlation energy by a separable-$S$–$D$ kernel with Gaussian form factor. Model the tensor contribution per nucleon as\n$$\n\\frac{E_{\\text{tensor}}}{A} = - c_0 \\, \\frac{\\hbar^2}{2m} \\, \\frac{1}{\\Lambda} \\, \\frac{J_h(k_F;\\Lambda) \\, J_p(k_F;\\Lambda,\\kappa)}{\\rho},\n$$\nwhere $c_0$ is a dimensionless strength parameter, $\\Lambda$ is a momentum-scale cutoff, and $\\kappa$ regularizes the average particle-hole energy denominator. Use the factorized, angle-averaged integrals\n$$\nJ_h(k_F;\\Lambda) = \\int_0^{k_F} h^2 \\, e^{-2h^2/\\Lambda^2} \\, dh, \\quad\nJ_p(k_F;\\Lambda,\\kappa) = \\int_{k_F}^{\\infty} \\frac{p^2 \\, e^{-2p^2/\\Lambda^2}}{p^2 + \\kappa^2} \\, dp.\n$$\nThis factorization is obtained by approximating the energy denominator by a function of particle momentum only, $p^2 + \\kappa^2$, which is justified when particle momenta are typically larger than hole momenta in particle-hole excitations and by using a separable Gaussian form factor $g(k) = e^{-k^2/\\Lambda^2}$ for the ${}^3S_1$–${}^3D_1$ coupling.\n\n5. The total energy per nucleon is then\n$$\n\\frac{E}{A}(k_F; s) = \\frac{T}{A}(k_F) + \\frac{E_{\\text{central}}}{A}(k_F) + s \\, \\frac{E_{\\text{tensor}}}{A}(k_F),\n$$\nwith a switch parameter $s \\in \\{0,1\\}$ that represents turning the $S$–$D$ coupling off ($s=0$) or on ($s=1$).\n\nYour task:\n\n- For each parameter set in the test suite below, compute the saturation point in two scenarios: with tensor coupling ($s=1$) and with tensor coupling turned off ($s=0$). The saturation point is defined as the value of $k_F$ in a specified grid that minimizes $E/A$. If $E/A$ is monotonic over the grid, define the saturation point as the grid endpoint where $E/A$ attains its smallest value.\n- Convert each saturation Fermi momentum to saturation density using $\\rho = \\dfrac{2 k_F^3}{3\\pi^2}$.\n- Quantify the shift due to the tensor force by computing differences\n$$\n\\Delta \\rho_{\\text{sat}} = \\rho_{\\text{sat}}^{(s=1)} - \\rho_{\\text{sat}}^{(s=0)}, \\qquad\n\\Delta (E/A)_{\\text{sat}} = \\left.\\frac{E}{A}\\right|_{\\text{sat}, s=1} - \\left.\\frac{E}{A}\\right|_{\\text{sat}, s=0}.\n$$\n\nNumerical instructions and conventions:\n\n- Use $\\nu = 4$ exactly.\n- Use $\\hbar^2/(2m) = 20.735 \\ \\mathrm{MeV\\,fm^2}$ exactly.\n- For the Slater function, use $\\ell(x) = \\dfrac{3 j_1(x)}{x}$ with $j_1(x) = \\dfrac{\\sin x}{x^2} - \\dfrac{\\cos x}{x}$ and define $\\ell(0)=1$ by continuity.\n- Perform the $r$-integration for the central energy over $[0, +\\infty)$ by truncating at a large but finite upper limit. A scientifically sound choice is to use an upper limit equal to $8$ times the largest range parameter, i.e., $r_{\\max} = 8 \\, \\max(\\alpha_R,\\alpha_A)$, which is sufficient for Gaussian ranges.\n- For the tensor integrals, evaluate $J_h$ over $[0,k_F]$ and $J_p$ over $[k_F,+\\infty)$ with the exponential form factor ensuring convergence.\n- Scan the Fermi momentum on a uniform grid $k_F \\in [0.4, 1.8] \\ \\mathrm{fm^{-1}}$ with exactly $121$ points.\n- For each parameter set, return six quantities in the following order, with explicit units and rounding:\n    1. $\\rho_{\\text{sat}}^{(s=1)}$ in fm$^{-3}$, rounded to three decimals.\n    2. $\\left.\\dfrac{E}{A}\\right|_{\\text{sat}, s=1}$ in MeV per nucleon, rounded to two decimals.\n    3. $\\rho_{\\text{sat}}^{(s=0)}$ in fm$^{-3}$, rounded to three decimals.\n    4. $\\left.\\dfrac{E}{A}\\right|_{\\text{sat}, s=0}$ in MeV per nucleon, rounded to two decimals.\n    5. $\\Delta \\rho_{\\text{sat}}$ in fm$^{-3}$, rounded to three decimals.\n    6. $\\Delta (E/A)_{\\text{sat}}$ in MeV per nucleon, rounded to two decimals.\n\nTest suite (each tuple specifies $(V_R,\\alpha_R,V_A,\\alpha_A,c_0,\\Lambda,\\kappa)$ with $V_R$ and $V_A$ in MeV, $\\alpha_R$ and $\\alpha_A$ in fm, and $\\Lambda$ and $\\kappa$ in fm$^{-1}$):\n\n- Case $1$ (happy path): $(650.0, \\ 0.5, \\ -35.0, \\ 1.2, \\ 3.0, \\ 2.0, \\ 1.0)$.\n- Case $2$ (weak tensor edge): $(650.0, \\ 0.5, \\ -35.0, \\ 1.2, \\ 0.8, \\ 1.8, \\ 1.0)$.\n- Case $3$ (stronger short-range repulsion): $(800.0, \\ 0.5, \\ -30.0, \\ 1.2, \\ 3.5, \\ 2.2, \\ 1.3)$.\n\nFinal output format:\n\n- Your program should produce a single line of output containing the results for the three cases as a comma-separated list enclosed in square brackets, with the six rounded numbers for Case $1$ first, followed by the six rounded numbers for Case $2$, and then the six rounded numbers for Case $3$. For example, a syntactically correct output structure is\n$[\\rho^{(1)}_{\\text{sat}, s=1},E^{(1)}_{\\text{sat}, s=1},\\rho^{(1)}_{\\text{sat}, s=0},E^{(1)}_{\\text{sat}, s=0},\\Delta\\rho^{(1)}_{\\text{sat}},\\Delta E^{(1)}_{\\text{sat}},\\rho^{(2)}_{\\text{sat}, s=1},\\dots,\\Delta E^{(3)}_{\\text{sat}}]$.", "solution": "The problem as stated is scientifically grounded, well-posed, and objective. It presents a simplified but standard model from computational nuclear physics, specifically a Brueckner-Hartree-Fock inspired framework for symmetric nuclear matter. All components of the model, including the kinetic energy of a Fermi gas, the Hartree-Fock potential energy with a Gaussian interaction, and a separable model for second-order tensor correlations, are based on established principles. The parameters, constants, and numerical instructions are complete and consistent. Therefore, a meaningful and unique solution can be derived. We proceed with the solution.\n\nThe objective is to determine the saturation point—the density $\\rho_{\\text{sat}}$ and energy per nucleon $(E/A)_{\\text{sat}}$ at which the system is most stable—for symmetric nuclear matter. We will compute this for two cases: with the tensor-force contribution included ($s=1$) and without it ($s=0$). The shift in the saturation point will then be quantified.\n\nThe total energy per nucleon, $\\frac{E}{A}$, is a function of the Fermi momentum $k_F$ and a switch parameter $s$:\n$$\n\\frac{E}{A}(k_F; s) = \\frac{T}{A}(k_F) + \\frac{E_{\\text{central}}}{A}(k_F) + s \\, \\frac{E_{\\text{tensor}}}{A}(k_F)\n$$\nThe Fermi momentum $k_F$ is related to the nucleon number density $\\rho$ for spin-isospin symmetric matter (degeneracy $\\nu=4$) by $\\rho = \\frac{2 k_F^3}{3\\pi^2}$. We will analyze each term of the energy expression in detail.\n\n**1. Kinetic Energy per Nucleon**\nThe average kinetic energy per nucleon, $\\frac{T}{A}$, for a non-relativistic Fermi gas is given by:\n$$\n\\frac{T}{A}(k_F) = \\frac{3}{5} \\frac{\\hbar^2 k_F^2}{2m}\n$$\nThis term represents the energy arising from the quantum-mechanical motion of nucleons confined within a finite volume, as dictated by the Pauli exclusion principle. We use the provided constant $\\frac{\\hbar^2}{2m} = 20.735 \\ \\mathrm{MeV\\,fm^2}$.\n\n**2. Central Potential Energy per Nucleon**\nThe contribution from central forces, $\\frac{E_{\\text{central}}}{A}$, is calculated within the Hartree-Fock approximation. This term accounts for the direct (Hartree) and exchange (Fock) interactions between nucleons. The provided formula is:\n$$\n\\frac{E_{\\text{central}}}{A}(k_F) = \\frac{\\rho}{2} \\int_{0}^{\\infty} 4\\pi r^2 \\, V_c(r) \\left[ 1 - \\frac{1}{\\nu} \\, \\ell^2(k_F r) \\right] \\, dr\n$$\nThe components of this expression are:\n- $V_c(r) = V_R \\, e^{-r^2/\\alpha_R^2} + V_A \\, e^{-r^2/\\alpha_A^2}$: A two-range Gaussian potential, a common phenomenological form representing short-range repulsion ($V_R > 0$) and intermediate-range attraction ($V_A < 0$).\n- $\\ell(x) = \\frac{3 j_1(x)}{x}$: The Slater function, where $j_1(x)$ is the spherical Bessel function of the first kind of order one. The term $\\ell^2(k_F r)$ arises from the angle-averaging of the squared one-body density matrix and represents the effect of Pauli blocking on the two-nucleon interaction in the medium. By continuity, $\\ell(0)=1$. This integral is evaluated numerically for each $k_F$. Per the instructions, the integration range is truncated at a sufficiently large radius $r_{\\max} = 8 \\, \\max(\\alpha_R, \\alpha_A)$ to ensure convergence due to the Gaussian nature of the potential.\n\n**3. Tensor Correlation Energy per Nucleon**\nThe Hartree-Fock approximation for spin-saturated matter does not capture the effects of the strong tensor force, which is a key driver of nuclear binding and saturation. The term $\\frac{E_{\\text{tensor}}}{A}$ models this contribution as a second-order perturbation in the Brueckner G-matrix formalism. The formula given is:\n$$\n\\frac{E_{\\text{tensor}}}{A}(k_F) = - c_0 \\, \\frac{\\hbar^2}{2m} \\, \\frac{1}{\\Lambda} \\, \\frac{J_h(k_F;\\Lambda) \\, J_p(k_F;\\Lambda,\\kappa)}{\\rho}\n$$\nThis expression approximates the energy gain from virtual particle-hole excitations induced by the tensor force coupling the ${}^3S_1$ and ${}^3D_1$ partial waves. Its components are:\n- $J_h(k_F;\\Lambda) = \\int_0^{k_F} h^2 \\, e^{-2h^2/\\Lambda^2} \\, dh$: An integral over occupied \"hole\" states up to the Fermi momentum $k_F$.\n- $J_p(k_F;\\Lambda,\\kappa) = \\int_{k_F}^{\\infty} \\frac{p^2 \\, e^{-2p^2/\\Lambda^2}}{p^2 + \\kappa^2} \\, dp$: An integral over unoccupied \"particle\" states above $k_F$.\n- The Gaussian form factor $e^{-k^2/\\Lambda^2}$ reflects the finite range of the interaction in momentum space. The term $\\frac{1}{p^2+\\kappa^2}$ is a simplified angle-averaged energy denominator, where $\\kappa$ represents an average excitation energy scale. The negative sign indicates that this second-order term is attractive. These integrals are computed numerically.\n\n**Computational Procedure**\nThe core of the task is to implement a procedure to calculate $\\frac{E}{A}$ as a function of $k_F$ and find its minimum.\n1.  A uniform grid of $121$ points for $k_F$ is established in the interval $[0.4, 1.8] \\ \\mathrm{fm^{-1}}$.\n2.  For each parameter set provided in the test suite:\n    a. We compute the energy-per-nucleon curve $\\frac{E}{A}(k_F)$ across the grid for both $s=1$ (tensor on) and $s=0$ (tensor off). This involves calculating the three energy components for each $k_F$ value, using numerical integration (`scipy.integrate.quad`) for the central and tensor potential terms.\n    b. The saturation point for each scenario is identified by finding the value of $k_F$ on the grid that minimizes $\\frac{E}{A}$. If the function is monotonic on the grid, the saturation point is taken as the grid endpoint with the lower energy.\n    c. The saturation Fermi momentum, $k_{F, \\text{sat}}$, is used to calculate the saturation density $\\rho_{\\text{sat}} = \\frac{2 k_{F, \\text{sat}}^3}{3\\pi^2}$. The corresponding minimum energy is $(E/A)_{\\text{sat}}$.\n    d. Finally, the differences $\\Delta \\rho_{\\text{sat}} = \\rho_{\\text{sat}}^{(s=1)} - \\rho_{\\text{sat}}^{(s=0)}$ and $\\Delta (E/A)_{\\text{sat}} = (E/A)_{\\text{sat}}^{(s=1)} - (E/A)_{\\text{sat}}^{(s=0)}$ are calculated to quantify the impact of the tensor force.\n3.  The six resulting quantities for each test case are rounded as specified and aggregated into a single output list.\n\nThe implementation will be encapsulated in a Python program utilizing the `numpy` and `scipy` libraries for numerical calculations.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.special import spherical_jn\n\ndef solve():\n    \"\"\"\n    Computes the saturation point of symmetric nuclear matter using a\n    simplified Brueckner-Hartree-Fock framework and quantifies the shift\n    due to the tensor force.\n    \"\"\"\n\n    # --- Fixed Physical and Model Constants ---\n    HBAR2_OVER_2M = 20.735  # MeV*fm^2\n    NU = 4.0  # Spin-isospin degeneracy\n\n    # --- Test Cases ---\n    # Each tuple: (V_R, alpha_R, V_A, alpha_A, c0, Lambda, kappa)\n    test_cases = [\n        (650.0, 0.5, -35.0, 1.2, 3.0, 2.0, 1.0),\n        (650.0, 0.5, -35.0, 1.2, 0.8, 1.8, 1.0),\n        (800.0, 0.5, -30.0, 1.2, 3.5, 2.2, 1.3),\n    ]\n\n    # --- Numerical Grid ---\n    kF_grid = np.linspace(0.4, 1.8, 121)\n\n    # --- Helper Functions for Energy Calculation ---\n\n    def _density(kF):\n        \"\"\"Calculates nucleon number density from Fermi momentum.\"\"\"\n        return 2.0 * kF**3 / (3.0 * np.pi**2)\n\n    def _kinetic_energy_per_nucleon(kF):\n        \"\"\"Calculates kinetic energy per nucleon.\"\"\"\n        return (3.0 / 5.0) * HBAR2_OVER_2M * kF**2\n\n    def _slater_l(x):\n        \"\"\"\n        Calculates the Slater function l(x) = 3*j1(x)/x.\n        Handles the x=0 case by using the known limit l(0)=1.\n        \"\"\"\n        if np.isclose(x, 0.0):\n            return 1.0\n        # For precision, use spherical_jn(1,x) which computes j_1(x)\n        return 3.0 * spherical_jn(1, x) / x\n\n    def _central_energy_per_nucleon(kF, params):\n        \"\"\"Calculates the central potential energy per nucleon.\"\"\"\n        V_R, alpha_R, V_A, alpha_A, _, _, _ = params\n        rho = _density(kF)\n\n        def Vc(r):\n            return V_R * np.exp(-r**2 / alpha_R**2) + V_A * np.exp(-r**2 / alpha_A**2)\n\n        def integrand(r):\n            slater_term = _slater_l(kF * r)\n            return 4.0 * np.pi * r**2 * Vc(r) * (1.0 - (1.0 / NU) * slater_term**2)\n\n        r_max = 8.0 * max(alpha_R, alpha_A)\n        # The integral from 0 to r_max\n        integral_val, _ = quad(integrand, 0, r_max, epsabs=1e-9, limit=100)\n\n        return (rho / 2.0) * integral_val\n\n    def _tensor_energy_per_nucleon(kF, params):\n        \"\"\"Calculates the tensor correlation energy per nucleon.\"\"\"\n        _, _, _, _, c0, Lambda, kappa = params\n        \n        if np.isclose(kF, 0.0):\n            return 0.0\n\n        rho = _density(kF)\n\n        # J_h integral\n        def jh_integrand(h):\n            return h**2 * np.exp(-2.0 * h**2 / Lambda**2)\n\n        Jh, _ = quad(jh_integrand, 0, kF, epsabs=1e-9, limit=100)\n\n        # J_p integral\n        def jp_integrand(p):\n            return (p**2 * np.exp(-2.0 * p**2 / Lambda**2)) / (p**2 + kappa**2)\n\n        Jp, _ = quad(jp_integrand, kF, np.inf, epsabs=1e-9, limit=100)\n\n        return -c0 * HBAR2_OVER_2M * (1.0 / Lambda) * (Jh * Jp / rho)\n\n    def _get_saturation_properties(params, s, kF_grid):\n        \"\"\"\n        Calculates the energy-density curve and finds the saturation point.\n        s=1 for tensor ON, s=0 for tensor OFF.\n        \"\"\"\n        energies = []\n        # Pre-calculate central energies as they are independent of 's'\n        central_energies = {kF: _central_energy_per_nucleon(kF, params) for kF in kF_grid}\n\n        for kF in kF_grid:\n            e_kin = _kinetic_energy_per_nucleon(kF)\n            e_cen = central_energies[kF]\n            e_ten = 0.0\n            if s == 1:\n                e_ten = _tensor_energy_per_nucleon(kF, params)\n            \n            total_energy = e_kin + e_cen + e_ten\n            energies.append(total_energy)\n        \n        energies = np.array(energies)\n        idx_min = np.argmin(energies)\n        \n        e_sat = energies[idx_min]\n        kF_sat = kF_grid[idx_min]\n        rho_sat = _density(kF_sat)\n        \n        return rho_sat, e_sat\n\n    # --- Main Loop to Process Test Cases ---\n    final_results = []\n    for params in test_cases:\n        # Scenario s=1 (Tensor ON)\n        rho_sat_s1, e_sat_s1 = _get_saturation_properties(params, 1, kF_grid)\n\n        # Scenario s=0 (Tensor OFF)\n        rho_sat_s0, e_sat_s0 = _get_saturation_properties(params, 0, kF_grid)\n\n        # Differences\n        delta_rho = rho_sat_s1 - rho_sat_s0\n        delta_e = e_sat_s1 - e_sat_s0\n\n        # Store rounded results in the required order\n        final_results.extend([\n            round(rho_sat_s1, 3), round(e_sat_s1, 2),\n            round(rho_sat_s0, 3), round(e_sat_s0, 2),\n            round(delta_rho, 3), round(delta_e, 2)\n        ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n\n```", "id": "3545468"}]}