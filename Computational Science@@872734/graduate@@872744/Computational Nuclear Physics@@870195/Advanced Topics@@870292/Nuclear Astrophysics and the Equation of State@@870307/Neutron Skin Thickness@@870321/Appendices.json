{"hands_on_practices": [{"introduction": "Before drawing physical conclusions from a computational model, we must first establish the reliability and precision of our numerical methods. This foundational practice guides you through a convergence study for the neutron skin thickness, $\\Delta r_{np}$, in a spherical nucleus like $^{208}\\mathrm{Pb}$ [@problem_id:3573312]. By systematically varying the radial mesh spacing, the computational box size, and iterative solver tolerances, you will develop the essential skill of quantifying numerical errors and establishing the criteria needed for physically meaningful results.", "problem": "You are tasked with designing and implementing a complete, runnable numerical program that performs a convergence study of the neutron skin thickness, denoted by $\\Delta r_{np}$, in a spherical nucleus. The quantities of interest are derived from first principles of continuous distributions and numerical quadrature on a finite computational domain, without relying on shortcut formulas. Your program must analyze how the computed $\\Delta r_{np}$ depends on three numerical parameters: the radial mesh spacing $dr$, the spherical box radius $R_{\\mathrm{box}}$, and the iteration tolerance $\\mathrm{tol}$ used for shape parameter determination.\n\nBegin from the following foundational base:\n- A spherically symmetric particle density $\\rho(r)$ in three dimensions contributes to the total particle number through the volume integral $N = \\int 4\\pi r^2 \\rho(r)\\,dr$ for neutrons and $Z = \\int 4\\pi r^2 \\rho(r)\\,dr$ for protons, where the integrals are over the physical space.\n- The root-mean-square radius of a species with spherical density $\\rho(r)$ is defined by $r_{\\mathrm{rms}} = \\sqrt{\\dfrac{\\int 4\\pi r^4 \\rho(r)\\,dr}{\\int 4\\pi r^2 \\rho(r)\\,dr}}$.\n- The neutron skin thickness is defined as $\\Delta r_{np} = r_{\\mathrm{rms}}^{(n)} - r_{\\mathrm{rms}}^{(p)}$, where $r_{\\mathrm{rms}}^{(n)}$ and $r_{\\mathrm{rms}}^{(p)}$ are the root-mean-square radii of neutrons and protons, respectively.\n\nModel the neutron and proton densities by two-parameter Fermi profiles (also called Woodsâ€“Saxon profiles) with spherical symmetry,\n$$\n\\rho_{q}(r;c_q,a_q,\\rho_{0,q}) = \\frac{\\rho_{0,q}}{1 + \\exp\\!\\left(\\frac{r - c_q}{a_q}\\right)} \\quad \\text{for } q \\in \\{n,p\\},\n$$\nwhere $c_q$ is the half-density radius, $a_q$ is the surface diffuseness, and $\\rho_{0,q}$ is a central density scale. Use the following physically plausible, fixed parameters for the lead nucleus with mass number $A$:\n- Nucleus: $^{208}\\mathrm{Pb}$ with $A = 208$, neutron number $N = 126$, proton number $Z = 82$.\n- Surface diffuseness: $a_n = a_p = 0.55\\ \\mathrm{fm}$.\n- Saturation central density: $\\rho_{\\mathrm{sat}} = 0.16\\ \\mathrm{fm}^{-3}$.\n- Central densities partitioned by isospin fraction: $\\rho_{0,n} = \\rho_{\\mathrm{sat}}\\cdot \\dfrac{N}{A}$ and $\\rho_{0,p} = \\rho_{\\mathrm{sat}}\\cdot \\dfrac{Z}{A}$.\n\nCritically, determine the shape parameters $c_n$ and $c_p$ by solving the normalization conditions\n$$\n\\int_0^{R_{\\mathrm{box}}} 4\\pi r^2 \\rho_{n}(r;c_n,a_n,\\rho_{0,n})\\,dr = N, \\qquad\n\\int_0^{R_{\\mathrm{box}}} 4\\pi r^2 \\rho_{p}(r;c_p,a_p,\\rho_{0,p})\\,dr = Z,\n$$\non the finite numerical domain $r \\in [0, R_{\\mathrm{box}}]$, using a robust one-dimensional root-finding procedure that does not assume a closed-form solution. The iteration must terminate when the relative residual in normalization is below the specified $\\mathrm{tol}$, or when an upper bound on the number of iterations is reached. Your algorithm must search a valid bracket for $c_q$ (ensuring that the target normalization is attainable within $[c_{\\mathrm{min}}, c_{\\mathrm{max}}]$) and must gracefully handle the case where $R_{\\mathrm{box}}$ is too small to achieve exact normalization (in which case $c_q$ should be clamped to the largest feasible value in the bracket).\n\nOn a radial mesh $r_k = k\\cdot dr$ for integers $k$ such that $0 \\le r_k \\le R_{\\mathrm{box}}$, compute the integrals using a consistent composite numerical quadrature scheme over the mesh with spacing $dr$. The neutron skin thickness $\\Delta r_{np}$ must be evaluated in femtometers (fm). To assess convergence, define a high-accuracy reference value $\\Delta r_{np}^{\\mathrm{ref}}$ computed on a very fine mesh with large box and tight tolerance, and measure the absolute deviation\n$$\n\\varepsilon(dr, R_{\\mathrm{box}}, \\mathrm{tol}) = \\left|\\Delta r_{np}(dr, R_{\\mathrm{box}}, \\mathrm{tol}) - \\Delta r_{np}^{\\mathrm{ref}}\\right|\n$$\nin femtometers. The target precision criterion is $\\varepsilon \\le 0.005\\ \\mathrm{fm}$.\n\nImplement the program to:\n1. Construct the densities $\\rho_n(r)$ and $\\rho_p(r)$ for given $dr$, $R_{\\mathrm{box}}$, and $\\mathrm{tol}$ by determining $c_n$ and $c_p$ via iterative normalization constrained to $[0, R_{\\mathrm{box}}]$.\n2. Compute $r_{\\mathrm{rms}}^{(n)}$, $r_{\\mathrm{rms}}^{(p)}$, and hence $\\Delta r_{np}$ for each case.\n3. Compute $\\Delta r_{np}^{\\mathrm{ref}}$ using $dr_{\\mathrm{ref}} = 0.005\\ \\mathrm{fm}$, $R_{\\mathrm{box}}^{\\mathrm{ref}} = 25\\ \\mathrm{fm}$, and $\\mathrm{tol}_{\\mathrm{ref}} = 10^{-12}$.\n4. For each test case $\\{dr, R_{\\mathrm{box}}, \\mathrm{tol}\\}$, output whether the target precision threshold $\\varepsilon \\le 0.005\\ \\mathrm{fm}$ is met, as a boolean.\n\nTest Suite:\nUse the following set of eight parameter triplets to probe different aspects of convergence, including mesh coarseness, box truncation, and iteration tightness:\n- Case $1$: $dr = 0.50\\ \\mathrm{fm}$, $R_{\\mathrm{box}} = 9.0\\ \\mathrm{fm}$, $\\mathrm{tol} = 10^{-2}$.\n- Case $2$: $dr = 0.10\\ \\mathrm{fm}$, $R_{\\mathrm{box}} = 9.0\\ \\mathrm{fm}$, $\\mathrm{tol} = 10^{-8}$.\n- Case $3$: $dr = 0.20\\ \\mathrm{fm}$, $R_{\\mathrm{box}} = 14.0\\ \\mathrm{fm}$, $\\mathrm{tol} = 10^{-6}$.\n- Case $4$: $dr = 0.10\\ \\mathrm{fm}$, $R_{\\mathrm{box}} = 20.0\\ \\mathrm{fm}$, $\\mathrm{tol} = 10^{-6}$.\n- Case $5$: $dr = 0.05\\ \\mathrm{fm}$, $R_{\\mathrm{box}} = 16.0\\ \\mathrm{fm}$, $\\mathrm{tol} = 10^{-4}$.\n- Case $6$: $dr = 0.05\\ \\mathrm{fm}$, $R_{\\mathrm{box}} = 25.0\\ \\mathrm{fm}$, $\\mathrm{tol} = 10^{-8}$.\n- Case $7$: $dr = 0.02\\ \\mathrm{fm}$, $R_{\\mathrm{box}} = 25.0\\ \\mathrm{fm}$, $\\mathrm{tol} = 10^{-10}$.\n- Case $8$: $dr = 0.01\\ \\mathrm{fm}$, $R_{\\mathrm{box}} = 12.0\\ \\mathrm{fm}$, $\\mathrm{tol} = 10^{-12}$.\n\nRequired Final Output Format:\nYour program should produce a single line of output containing the results for the above eight test cases as a comma-separated list enclosed in square brackets, with entries being booleans indicating whether $\\varepsilon \\le 0.005\\ \\mathrm{fm}$ holds for each case, in the given order (for example, $\\left[\\mathrm{True},\\mathrm{False},\\ldots\\right]$). No other text should be printed.", "solution": "The problem requires a numerical convergence study of the neutron skin thickness, $\\Delta r_{np}$, for the $^{208}\\mathrm{Pb}$ nucleus. The solution involves implementing a computational framework based on first principles, employing numerical quadrature and root-finding algorithms. The foundation of this analysis rests on modeling the neutron and proton distributions with two-parameter Fermi density profiles and then numerically solving for the parameters that ensure correct particle number normalization.\n\n**1. Theoretical and Mathematical Framework**\n\nThe neutron ($q=n$) and proton ($q=p$) density distributions are modeled by the spherically symmetric two-parameter Fermi function:\n$$\n\\rho_{q}(r; c_q, a_q, \\rho_{0,q}) = \\frac{\\rho_{0,q}}{1 + \\exp\\left(\\frac{r - c_q}{a_q}\\right)}\n$$\nwhere $r$ is the radial coordinate, $c_q$ is the half-density radius, $a_q$ is the surface diffuseness, and $\\rho_{0,q}$ is the central density parameter. For the $^{208}\\mathrm{Pb}$ nucleus, we are given $A=208$, $N=126$, and $Z=82$. The diffuseness is fixed at $a_n = a_p = 0.55\\ \\mathrm{fm}$. The central densities are derived from the saturation density $\\rho_{\\mathrm{sat}} = 0.16\\ \\mathrm{fm}^{-3}$ as $\\rho_{0,n} = \\rho_{\\mathrm{sat}} \\cdot (N/A)$ and $\\rho_{0,p} = \\rho_{\\mathrm{sat}} \\cdot (Z/A)$.\n\nThe half-density radii, $c_n$ and $c_p$, are not given and must be determined by enforcing the normalization condition within a finite spherical volume of radius $R_{\\mathrm{box}}$. This condition states that the integral of the number density over the volume must equal the total number of particles of that species:\n$$\nN_q = \\int_0^{R_{\\mathrm{box}}} 4\\pi r^2 \\rho_q(r; c_q, a_q, \\rho_{0,q}) \\, dr\n$$\nwhere $N_n = N$ and $N_p = Z$.\n\nOnce the correctly normalized densities are obtained, the root-mean-square (rms) radius for each particle species is calculated as:\n$$\nr_{\\mathrm{rms}}^{(q)} = \\sqrt{\\frac{\\int_0^{R_{\\mathrm{box}}} 4\\pi r^4 \\rho_q(r) \\, dr}{\\int_0^{R_{\\mathrm{box}}} 4\\pi r^2 \\rho_q(r) \\, dr}}\n$$\nThe denominator in this expression is precisely the particle number $N_q$. For numerical consistency, it is crucial to use the value of the integral computed on the numerical grid, rather than the target values $N$ or $Z$.\n\nFinally, the neutron skin thickness is the difference between the neutron and proton rms radii:\n$$\n\\Delta r_{np} = r_{\\mathrm{rms}}^{(n)} - r_{\\mathrm{rms}}^{(p)}\n$$\n\n**2. Numerical Strategy and Algorithmic Design**\n\nThe core of the problem is to solve the normalization equation for $c_q$ and then compute the rms radii using numerical integration.\n\n**2.1. Numerical Quadrature**\nAll integrals are computed numerically on a discrete radial mesh. The mesh is defined by a spacing $dr$ over the interval $[0, R_{\\mathrm{box}}]$, giving points $r_k = k \\cdot dr$ for $k=0, 1, \\dots, \\lfloor R_{\\mathrm{box}}/dr \\rfloor$. A high-order composite quadrature rule is appropriate for integrating the smooth functions involved. We select the composite Simpson's rule, which offers excellent accuracy. The `scipy.integrate.simpson` function provides a robust implementation of this method that correctly handles grids with both even and odd numbers of intervals.\n\n**2.2. Root-Finding for the Half-Density Radius $c_q$**\nFor each species $q$, we must find the value of $c_q$ that satisfies the normalization condition. This is a one-dimensional root-finding problem. Let us define a function for the residual:\n$$\nf(c_q) = \\left( \\int_0^{R_{\\mathrm{box}}} 4\\pi r^2 \\rho_q(r; c_q) \\, dr \\right) - N_q = 0\n$$\nThe integral term, which we can denote as $I(c_q)$, is a monotonically decreasing function of $c_q$. A larger $c_q$ pushes the density distribution outwards, so for a fixed box radius $R_{\\mathrm{box}}$, the integrated number of particles within the box decreases. This monotonicity guarantees that if a solution for $c_q$ exists within a given search interval, it is unique.\n\nA robust bisection method is employed to find the root $c_q$. The search is conducted within the physical bracket $[c_{\\mathrm{min}}, c_{\\mathrm{max}}] = [0, R_{\\mathrm{box}}]$. The bisection algorithm proceeds as follows:\n1.  Establish the search bracket $[c_{\\mathrm{min}}, c_{\\mathrm{max}}]$.\n2.  Before starting the search, check if the target $N_q$ is bracketed by the values of the integral at the endpoints, $I(c_{\\mathrm{min}})$ and $I(c_{\\mathrm{max}})$.\n    -   If $N_q > I(c_{\\mathrm{min}})$, the integration box is too small to contain $N_q$ particles, even for the most compact density profile ($c_q = 0$). In this case, $c_q$ is set to $c_{\\mathrm{min}} = 0$, the value that maximizes the particle count.\n    -   If $N_q < I(c_{\\mathrm{max}})$, the particle count is always greater than $N_q$, even for the most diffuse profile within the bracket ($c_q = R_{\\mathrm{box}}$). Here, $c_q$ is set to $c_{\\mathrm{max}} = R_{\\mathrm{box}}$ to minimize the count.\n3.  If a root is bracketed, iterate by repeatedly bisecting the interval. At each step $i$, a midpoint $c_{\\mathrm{mid}, i}$ is tested. The bracket for the next step is updated based on whether $I(c_{\\mathrm{mid}, i})$ is greater or less than $N_q$.\n4.  The iteration terminates when the relative residual for the particle number is less than the specified tolerance $\\mathrm{tol}$, i.e., $|I(c_q) - N_q| / N_q < \\mathrm{tol}$, or after a fixed maximum number of iterations is reached.\n\n**3. Implementation and Convergence Study**\n\nThe overall program is structured to perform the calculations for a series of test cases and compare them against a high-accuracy reference case.\n\n1.  **Reference Calculation**: A reference value, $\\Delta r_{np}^{\\mathrm{ref}}$, is first computed using a very fine mesh ($dr_{\\mathrm{ref}} = 0.005\\ \\mathrm{fm}$), a large box radius ($R_{\\mathrm{box}}^{\\mathrm{ref}} = 25\\ \\mathrm{fm}$), and a strict root-finding tolerance ($\\mathrm{tol}_{\\mathrm{ref}} = 10^{-12}$). This provides a benchmark assumed to be very close to the true converged value.\n\n2.  **Test Case Evaluation**: The program then iterates through the eight provided test cases, each defined by a triplet of parameters $\\{dr, R_{\\mathrm{box}}, \\mathrm{tol}\\}$. For each case:\n    a. The half-density radii $c_n$ and $c_p$ are determined using the bisection method described above.\n    b. The rms radii $r_{\\mathrm{rms}}^{(n)}$ and $r_{\\mathrm{rms}}^{(p)}$ are computed using Simpson's rule.\n    c. The neutron skin thickness $\\Delta r_{np}$ is calculated.\n    d. The absolute deviation from the reference, $\\varepsilon = |\\Delta r_{np} - \\Delta r_{np}^{\\mathrm{ref}}|$, is computed.\n\n3.  **Output**: The a boolean value, indicating whether the deviation $\\varepsilon$ meets the precision criterion $\\varepsilon \\le 0.005\\ \\mathrm{fm}$, is determined for each case. The final output is a list of these boolean results.\n\nThe implementation is encapsulated within a Python program, leveraging `numpy` for efficient array operations and `scipy.integrate.simpson` for numerical quadrature, adhering to all specified constraints.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Main function to perform the convergence study of the neutron skin thickness.\n    \"\"\"\n    \n    #\n    # --- Problem Constants ---\n    #\n    A = 208.0\n    N = 126.0\n    Z = 82.0\n    a_n = 0.55\n    a_p = 0.55\n    rho_sat = 0.16\n    \n    # Derived density parameters\n    rho_0_n = rho_sat * (N / A)\n    rho_0_p = rho_sat * (Z / A)\n\n    #\n    # --- Numerical Implementation ---\n    #\n\n    def find_c(dr, R_box, tol, N_target, a, rho_0):\n        \"\"\"\n        Determines the half-density radius 'c' using a bisection root-finding method.\n        \"\"\"\n        num_points = int(R_box / dr) + 1\n        r_grid = np.linspace(0.0, R_box, num_points)\n\n        def calculate_norm_at_c(c_val):\n            \"\"\"Helper function to compute the integrated particle number for a given c.\"\"\"\n            # Fermi-Dirac distribution\n            rho_vals = rho_0 / (1.0 + np.exp((r_grid - c_val) / a))\n            # Integrand for particle number\n            integrand = 4.0 * np.pi * r_grid**2 * rho_vals\n            # Numerical integration using Simpson's rule\n            return integrate.simpson(integrand, x=r_grid)\n\n        # Establish search bracket\n        c_min, c_max = 0.0, R_box\n        \n        # Calculate normalization at bracket boundaries\n        # Note: Integral is a monotonically decreasing function of c\n        norm_at_c_min = calculate_norm_at_c(c_min) # Max possible norm\n        norm_at_c_max = calculate_norm_at_c(c_max) # Min possible norm\n        \n        # Handle cases where the target cannot be bracketed\n        if N_target > norm_at_c_min:\n            # Box is too small to contain N_target particles.\n            # Return c_min to maximize the enclosed particle number.\n            return c_min\n        if N_target < norm_at_c_max:\n            # Integral is always larger than N_target.\n            # Return c_max to minimize the enclosed particle number.\n            return c_max\n\n        # Bisection search\n        max_iter = 100\n        for _ in range(max_iter):\n            c_mid = (c_min + c_max) / 2.0\n            \n            # Avoid infinite loops if float precision limit is reached\n            if c_mid == c_min or c_mid == c_max:\n                break\n            \n            norm_mid = calculate_norm_at_c(c_mid)\n            \n            # Check for convergence based on relative residual\n            if abs(norm_mid - N_target) / N_target < tol:\n                return c_mid\n            \n            # Update bracket\n            if norm_mid > N_target:\n                # I(c) too high, need to increase c to decrease I(c)\n                c_min = c_mid\n            else:\n                # I(c) too low, need to decrease c to increase I(c)\n                c_max = c_mid\n        \n        # Return best estimate if max iterations are reached\n        return (c_min + c_max) / 2.0\n\n    def calculate_rms_radius(c, dr, R_box, a, rho_0):\n        \"\"\"Computes the root-mean-square radius for a given density profile.\"\"\"\n        num_points = int(R_box / dr) + 1\n        r_grid = np.linspace(0.0, R_box, num_points)\n        \n        rho_vals = rho_0 / (1.0 + np.exp((r_grid - c) / a))\n        \n        # r^2 moment integrand\n        integrand_r2 = 4.0 * np.pi * r_grid**2 * rho_vals\n        # r^4 moment integrand\n        integrand_r4 = 4.0 * np.pi * r_grid**4 * rho_vals\n        \n        # Compute integrals\n        I_r2 = integrate.simpson(integrand_r2, x=r_grid)\n        I_r4 = integrate.simpson(integrand_r4, x=r_grid)\n        \n        if I_r2 <= 0:\n            return 0.0\n            \n        return np.sqrt(I_r4 / I_r2)\n\n    def get_skin_thickness(dr, R_box, tol):\n        \"\"\"Orchestrates the calculation of the neutron skin thickness for one case.\"\"\"\n        c_n = find_c(dr, R_box, tol, N, a_n, rho_0_n)\n        c_p = find_c(dr, R_box, tol, Z, a_p, rho_0_p)\n        \n        r_rms_n = calculate_rms_radius(c_n, dr, R_box, a_n, rho_0_n)\n        r_rms_p = calculate_rms_radius(c_p, dr, R_box, a_p, rho_0_p)\n        \n        return r_rms_n - r_rms_p\n\n    #\n    # --- Convergence Study Execution ---\n    #\n\n    # Define reference case for high-accuracy benchmark\n    dr_ref = 0.005\n    R_box_ref = 25.0\n    tol_ref = 1.0e-12\n    delta_r_np_ref = get_skin_thickness(dr_ref, R_box_ref, tol_ref)\n\n    # Define the test suite\n    test_cases = [\n        # Case 1: dr, R_box, tol\n        (0.50, 9.0, 1.0e-2),\n        # Case 2\n        (0.10, 9.0, 1.0e-8),\n        # Case 3\n        (0.20, 14.0, 1.0e-6),\n        # Case 4\n        (0.10, 20.0, 1.0e-6),\n        # Case 5\n        (0.05, 16.0, 1.0e-4),\n        # Case 6\n        (0.05, 25.0, 1.0e-8),\n        # Case 7\n        (0.02, 25.0, 1.0e-10),\n        # Case 8\n        (0.01, 12.0, 1.0e-12),\n    ]\n\n    precision_threshold = 0.005  # fm\n    results = []\n    \n    for dr, R_box, tol in test_cases:\n        delta_r_np_case = get_skin_thickness(dr, R_box, tol)\n        deviation = abs(delta_r_np_case - delta_r_np_ref)\n        results.append(deviation <= precision_threshold)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3573312"}, {"introduction": "Having established a numerically robust method for spherical nuclei, we can now apply it to investigate more complex physical phenomena. This exercise explores the fascinating interplay between the neutron skin, an isovector property sensitive to the symmetry energy, and nuclear deformation, a collective feature that governs the shape of the nucleus [@problem_id:3573317]. You will implement a model for axially deformed nuclei and compute the sensitivity of $\\Delta r_{np}$ to the deformation parameter $\\beta_2$, gaining insight into how nuclear structure evolves away from closed shells.", "problem": "You are to implement a complete, runnable program to quantify how the neutron skin thickness responds to nuclear shape-phase transitions from spherical to prolate deformation. The fundamental physical quantity is the neutron skin thickness, defined as the difference between the root-mean-square radii of the neutron distribution and the proton distribution. Let the neutron skin thickness be denoted by $\\Delta r_{np}$ and defined by $\\Delta r_{np} = \\sqrt{\\langle r^2 \\rangle_n} - \\sqrt{\\langle r^2 \\rangle_p}$, where $\\langle r^2 \\rangle_q$ for species $q \\in \\{n,p\\}$ is the mean-square radius computed from a nuclear density distribution $\\rho_q(\\mathbf{r})$.\n\nYou must work from the following foundational definitions and well-tested constructs in nuclear structure physics:\n- The root-mean-square radius for a density $\\rho_q(\\mathbf{r})$ is given by $\\sqrt{\\langle r^2 \\rangle_q}$, with $\\langle r^2 \\rangle_q = \\dfrac{\\int r^2 \\rho_q(\\mathbf{r}) \\, d^3\\mathbf{r}}{\\int \\rho_q(\\mathbf{r}) \\, d^3\\mathbf{r}}$.\n- The nuclear density distribution for species $q$ is modeled by a deformed two-parameter Fermi distribution, a widely used representation in nuclear physics, in which the surface is deformed by a quadrupole parameter. The density is constructed in spherical coordinates by adopting an angle-dependent surface radius and a radial profile controlled by a half-density radius and diffuseness parameter.\n- The quadrupole deformation is parameterized by the deformation parameter $\\beta_2$ and the real spherical harmonic $Y_{20}(\\theta)$, with the deformed surface radius given by $r_{\\text{surf}}(\\theta) = c_q \\left(1 + \\beta_2 Y_{20}(\\theta)\\right)$, where $c_q$ is the half-density radius for species $q$ and $Y_{20}(\\theta) = \\sqrt{\\dfrac{5}{16\\pi}} \\left(3 \\cos^2\\theta - 1\\right)$.\n- The two-parameter Fermi radial profile is taken as $\\rho_q(r,\\theta) = \\dfrac{1}{1 + \\exp\\left(\\dfrac{r - r_{\\text{surf}}(\\theta)}{a_q}\\right)}$, where $a_q$ is the diffuseness parameter for species $q$. In forming ratios to compute $\\langle r^2 \\rangle_q$, the overall normalization factor for $\\rho_q$ cancels and is therefore not required.\n\nYour program must compute $\\Delta r_{np}$ for two shapes of each selected isotope: the spherical case with $\\beta_2 = 0$, and a specified prolate case with a nonzero $\\beta_2$. You must then compute the sensitivity of $\\Delta r_{np}$ with respect to the deformation change using a finite-difference measure\n$$\nS = \\frac{\\Delta r_{np}(\\beta_2) - \\Delta r_{np}(0)}{\\beta_2},\n$$\nwhich is to be reported in units of femtometers per unit deformation parameter $\\beta_2$. All radii and lengths must be expressed in femtometers (fm).\n\nParameterization rules to ensure scientific realism:\n- For an isotope with mass number $A$, proton number $Z$, and neutron number $N = A - Z$, adopt a common baseline radius parameter $c_0 = r_0 A^{1/3}$ with $r_0 = 1.2 \\,\\text{fm}$.\n- Let the isospin asymmetry be $I = \\dfrac{N - Z}{A}$. Use an isovector half-density radius splitting $c_n = c_0 + \\dfrac{\\kappa I}{2}$ and $c_p = c_0 - \\dfrac{\\kappa I}{2}$ with $\\kappa = 1.0 \\,\\text{fm}$.\n- Use a baseline diffuseness $a_0 = 0.55 \\,\\text{fm}$ and allow a mild isovector modulation $a_n = a_0 \\left(1 + \\eta I\\right)$ and $a_p = a_0 \\left(1 - \\dfrac{\\eta I}{2}\\right)$ with $\\eta = 0.3$. These choices are designed to produce scientifically plausible magnitudes for $\\Delta r_{np}$ across the isotopic chain.\n\nComputational requirements:\n- Implement the integrals for $\\langle r^2 \\rangle_q$ by numerical quadrature in spherical coordinates. Use the substitution $x = \\cos\\theta$ to reduce the angular integral, noting that $\\sin\\theta \\, d\\theta = dx$, and include the azimuthal integration factor $2\\pi$. The resulting numerator and denominator integrals should be computed over $r \\in [0, r_{\\max}]$ and $x \\in [-1,1]$, where $r_{\\max}$ is a sufficiently large cutoff to capture the density tail. The final expressions are\n$$\n\\langle r^2 \\rangle_q = \\frac{\\int_0^{r_{\\max}} \\int_{-1}^{1} 2\\pi \\, r^4 \\, \\rho_q(r,x) \\, dr \\, dx}{\\int_0^{r_{\\max}} \\int_{-1}^{1} 2\\pi \\, r^2 \\, \\rho_q(r,x) \\, dr \\, dx},\n$$\nwith $x = \\cos\\theta$ and $Y_{20}(\\theta)$ evaluated as a function of $x$.\n- Choose $r_{\\max}$ large enough to make numerical truncation negligible for the adopted $c_q$ and $a_q$. A fixed margin beyond the deformed surface is acceptable provided it is large enough relative to $a_q$.\n\nTest suite and required outputs:\n- Your program must compute the sensitivity $S$ for the following five test cases. Each test input is a tuple $(\\text{element}, A, Z, \\beta_2)$:\n    1. $(\\text{Kr}, 86, 36, 0.30)$\n    2. $(\\text{Kr}, 96, 36, 0.32)$\n    3. $(\\text{Sr}, 92, 38, 0.15)$\n    4. $(\\text{Sr}, 100, 38, 0.38)$\n    5. $(\\text{Kr}, 78, 36, 0.05)$\n- For each case, compute $S$ in femtometers per unit $\\beta_2$ as defined above. You must use radians for any angular computations internally, although the substitution eliminates explicit angles. The final outputs must be floats.\n- Final output format: Your program should produce a single line of output containing the sensitivities for the five test cases as a comma-separated list enclosed in square brackets, for example, $[\\text{result1},\\text{result2},\\text{result3},\\text{result4},\\text{result5}]$. Each entry must be a float in femtometers per unit $\\beta_2$; round each to six decimal places to standardize presentation.", "solution": "The problem is valid as it is scientifically grounded in established principles of nuclear structure physics, is well-posed with a complete and consistent set of definitions and parameters, and is expressed in objective, formalizable language. The task is to compute the sensitivity of the neutron skin thickness to quadrupole deformation for a set of specific nuclei.\n\n### 1. Principle of the Calculation\n\nThe primary objective is to calculate the sensitivity, $S$, of the neutron skin thickness, $\\Delta r_{np}$, with respect to the quadrupole deformation parameter, $\\beta_2$. The sensitivity is defined by the finite-difference formula:\n$$\nS = \\frac{\\Delta r_{np}(\\beta_2) - \\Delta r_{np}(0)}{\\beta_2}\n$$\nThis quantity measures the change in the neutron skin thickness per unit change in the deformation parameter. The neutron skin thickness itself is the difference between the root-mean-square (RMS) radii of the neutron and proton distributions:\n$$\n\\Delta r_{np} = \\sqrt{\\langle r^2 \\rangle_n} - \\sqrt{\\langle r^2 \\rangle_p}\n$$\nwhere $\\sqrt{\\langle r^2 \\rangle_q}$ is the RMS radius for a given nucleon species $q \\in \\{n, p\\}$ (neutrons or protons).\n\n### 2. Nuclear Model and Parameterization\n\nThe calculation is based on a standard model for the nuclear density distribution, $\\rho_q(\\mathbf{r})$, which is assumed to be a deformed two-parameter Fermi distribution.\n\n**Density Distribution:** The density $\\rho_q$ for species $q$ at a given position $(r, \\theta, \\phi)$ is given in spherical coordinates (with azimuthal symmetry) by:\n$$\n\\rho_q(r,\\theta) = \\frac{1}{1 + \\exp\\left(\\frac{r - r_{\\text{surf}}(\\theta)}{a_q}\\right)}\n$$\nHere, $a_q$ is the diffuseness parameter, which controls the thickness of the nuclear surface. The term $r_{\\text{surf}}(\\theta)$ represents the angle-dependent nuclear surface radius, which incorporates the quadrupole deformation:\n$$\nr_{\\text{surf}}(\\theta) = c_q \\left(1 + \\beta_2 Y_{20}(\\theta)\\right)\n$$\nwhere $c_q$ is the half-density radius (the radius at which the density drops to half its central value in the spherical case), $\\beta_2$ is the quadrupole deformation parameter, and $Y_{20}(\\theta)$ is the real spherical harmonic:\n$$\nY_{20}(\\theta) = \\sqrt{\\frac{5}{16\\pi}} \\left(3 \\cos^2\\theta - 1\\right)\n$$\n\n**Parameterization:** The model parameters $c_q$ and $a_q$ for neutrons and protons are determined based on the macroscopic-microscopic approach, linking them to the nucleus's mass number $A$, proton number $Z$, and neutron number $N=A-Z$.\n- The isospin asymmetry is defined as $I = \\frac{N - Z}{A}$.\n- A baseline half-density radius $c_0$ is scaled with the mass number, consistent with the liquid drop model: $c_0 = r_0 A^{1/3}$, with $r_0 = 1.2 \\, \\text{fm}$.\n- The neutron and proton half-density radii are split by an isovector term:\n  $$\n  c_n = c_0 + \\frac{\\kappa I}{2}, \\quad c_p = c_0 - \\frac{\\kappa I}{2} \\quad (\\text{with } \\kappa = 1.0 \\, \\text{fm})\n  $$\n- The diffuseness parameters are also modulated by isospin asymmetry, starting from a baseline value $a_0 = 0.55 \\, \\text{fm}$:\n  $$\n  a_n = a_0(1 + \\eta I), \\quad a_p = a_0\\left(1 - \\frac{\\eta I}{2}\\right) \\quad (\\text{with } \\eta = 0.3)\n  $$\nThese parameterizations ensure that for neutron-rich nuclei ($I > 0$), the neutron distribution has a larger radius and is more diffuse than the proton distribution, leading to a positive neutron skin.\n\n### 3. Computational Method\n\nThe core of the computation is the calculation of the mean-square radius $\\langle r^2 \\rangle_q$ for each nucleon species, which is defined by the integral ratio:\n$$\n\\langle r^2 \\rangle_q = \\frac{\\int r^2 \\rho_q(\\mathbf{r}) \\, d^3\\mathbf{r}}{\\int \\rho_q(\\mathbf{r}) \\, d^3\\mathbf{r}}\n$$\nUsing spherical coordinates, the volume element is $d^3\\mathbf{r} = r^2 \\sin\\theta \\, dr \\, d\\theta \\, d\\phi$. Due to the azimuthal symmetry of $\\rho_q(r, \\theta)$, the integration over $\\phi$ yields a factor of $2\\pi$. By making the standard substitution $x = \\cos\\theta$, for which $dx = -\\sin\\theta \\, d\\theta$, the integrals become two-dimensional:\n$$\n\\langle r^2 \\rangle_q = \\frac{\\int_0^{r_{\\max}} \\int_{-1}^{1} 2\\pi \\, r^4 \\, \\rho_q(r,x) \\, dx \\, dr}{\\int_0^{r_{\\max}} \\int_{-1}^{1} 2\\pi \\, r^2 \\, \\rho_q(r,x) \\, dx \\, dr}\n$$\nwhere the density $\\rho_q(r,x)$ is now a function of radius $r$ and the cosine of the polar angle, $x$. The integrals are performed numerically over $x \\in [-1, 1]$ and $r \\in [0, r_{\\max}]$. The upper radial cutoff $r_{\\max}$ must be chosen sufficiently large to ensure that the tail of the Fermi distribution is fully captured and truncation errors are negligible. A value of $r_{\\max} = 25 \\, \\text{fm}$ is chosen, which is significantly larger than any expected nuclear radius in the test cases, even when deformed.\n\n### 4. Algorithmic Design\n\nThe overall algorithm to compute the sensitivity $S$ for each test case $(\\text{isotope}, A, Z, \\beta_2)$ is as follows:\n\n1.  **Define a function to compute the RMS radius, `get_rms_radius(A, Z, beta2, species)`**:\n    - This function takes the nuclear composition ($A, Z$), the deformation $\\beta_2$, and the nucleon species ('n' or 'p') as input.\n    - It first calculates the derived parameters $I$, $c_0$, $c_q$, and $a_q$ according to the specified parameterization rules.\n    - It defines the integrand functions for the numerator ($\\propto r^4 \\rho_q$) and the denominator ($\\propto r^2 \\rho_q$). The density $\\rho_q(r, x)$ is computed internally based on the input parameters.\n    - It uses a 2D numerical quadrature routine (`scipy.integrate.dblquad`) to evaluate the numerator and denominator integrals over the domain $r \\in [0, 25]$ and $x \\in [-1, 1]$.\n    - Finally, it computes $\\langle r^2 \\rangle_q$ as the ratio of the integrals and returns its square root, $\\sqrt{\\langle r^2 \\rangle_q}$.\n\n2.  **Define a function to compute the sensitivity, `compute_sensitivity(A, Z, beta2)`**:\n    - This function orchestrates the calculation for a single test case.\n    - It computes the neutron skin thickness for the deformed case, $\\Delta r_{np}(\\beta_2)$, by calling `get_rms_radius` for both neutrons and protons with the given $\\beta_2$ and taking the difference.\n    - It computes the neutron skin thickness for the spherical case, $\\Delta r_{np}(0)$, by calling `get_rms_radius` for both neutrons and protons with $\\beta_2=0$.\n    - It calculates the sensitivity $S$ using the finite-difference formula.\n\n3.  **Main Execution Loop**:\n    - The main part of the program iterates through the list of specified test cases.\n    - For each case, it calls `compute_sensitivity` to obtain the value of $S$.\n    - The results are collected into a list.\n    - The final list of results is formatted into the required string output: a comma-separated list of floating-point numbers (rounded to six decimal places) enclosed in square brackets. This structure is implemented in the provided Python code within the `<final_answer>` tag.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import dblquad\n\ndef solve():\n    \"\"\"\n    Computes the sensitivity of the neutron skin thickness to nuclear deformation\n    for a series of test cases.\n    \"\"\"\n    \n    # Define physical and model constants as specified in the problem statement\n    R0_FM = 1.2\n    KAPPA_FM = 1.0\n    A0_FM = 0.55\n    ETA = 0.3\n    R_MAX_FM = 25.0  # Sufficiently large integration cutoff radius in fm\n\n    # Define the test cases from the problem statement.\n    # Each tuple contains: (Element Name, Mass Number A, Proton Number Z, Deformation beta_2)\n    test_cases = [\n        (\"Kr\", 86, 36, 0.30),\n        (\"Kr\", 96, 36, 0.32),\n        (\"Sr\", 92, 38, 0.15),\n        (\"Sr\", 100, 38, 0.38),\n        (\"Kr\", 78, 36, 0.05),\n    ]\n\n    def get_rms_radius(A, Z, beta2, species):\n        \"\"\"\n        Calculates the root-mean-square radius for a given species (n or p).\n        \"\"\"\n        N = A - Z\n        I = (N - Z) / A if A > 0 else 0.0\n        c0 = R0_FM * A**(1/3)\n\n        if species == 'n':\n            c_q = c0 + KAPPA_FM * I / 2.0\n            a_q = A0_FM * (1.0 + ETA * I)\n        elif species == 'p':\n            c_q = c0 - KAPPA_FM * I / 2.0\n            a_q = A0_FM * (1.0 - ETA * I / 2.0)\n        else:\n            raise ValueError(\"Species must be 'n' or 'p'\")\n\n        y20_prefactor = np.sqrt(5.0 / (16.0 * np.pi))\n\n        def rho_q(r, x):\n            \"\"\"\n            Deformed two-parameter Fermi distribution. x is cos(theta).\n            \"\"\"\n            y20 = y20_prefactor * (3.0 * x**2 - 1.0)\n            r_surf = c_q * (1.0 + beta2 * y20)\n            \n            exponent = (r - r_surf) / a_q\n            # Avoid overflow for large positive exponents\n            if exponent > 100.0:\n                return 0.0\n            return 1.0 / (1.0 + np.exp(exponent))\n\n        def integrand_num(r, x):\n            return 2.0 * np.pi * r**4 * rho_q(r, x)\n\n        def integrand_den(r, x):\n            return 2.0 * np.pi * r**2 * rho_q(r, x)\n\n        # scipy.integrate.dblquad integrates func(y, x) over x in [a,b] and y in [g(x), h(x)]\n        # Our integral is over x=cos(theta) in [-1, 1] and r in [0, R_MAX_FM]\n        # The call should be dblquad(integrand, x_min, x_max, y_min, y_max)\n        # where integrand is a function of (y, x). Here y->r, x->x\n        num_integral, _ = dblquad(integrand_num, -1.0, 1.0, 0.0, R_MAX_FM)\n        den_integral, _ = dblquad(integrand_den, -1.0, 1.0, 0.0, R_MAX_FM)\n\n        if den_integral == 0:\n            return 0.0\n\n        mean_sq_radius = num_integral / den_integral\n        return np.sqrt(mean_sq_radius)\n\n    def compute_sensitivity(A, Z, beta2):\n        \"\"\"\n        Computes the sensitivity S for a given nucleus and deformation.\n        \"\"\"\n        # Calculate Delta_r_np for the deformed case\n        rms_n_deformed = get_rms_radius(A, Z, beta2, 'n')\n        rms_p_deformed = get_rms_radius(A, Z, beta2, 'p')\n        delta_r_np_deformed = rms_n_deformed - rms_p_deformed\n\n        # Calculate Delta_r_np for the spherical case (beta2 = 0)\n        rms_n_spherical = get_rms_radius(A, Z, 0.0, 'n')\n        rms_p_spherical = get_rms_radius(A, Z, 0.0, 'p')\n        delta_r_np_spherical = rms_n_spherical - rms_p_spherical\n        \n        if beta2 == 0:\n            # The sensitivity is undefined for beta2 = 0, but problem cases have beta2 > 0.\n            # In principle, one could define it as the derivative at beta2=0.\n            # For this problem, we just avoid division by zero.\n            return 0.0\n\n        sensitivity = (delta_r_np_deformed - delta_r_np_spherical) / beta2\n        return sensitivity\n\n    results = []\n    for _, A, Z, beta2 in test_cases:\n        s = compute_sensitivity(A, Z, beta2)\n        results.append(s)\n\n    # Final print statement in the exact required format.\n    # Format each result to six decimal places to standardize presentation.\n    formatted_results = [f'{r:.6f}' for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3573317"}, {"introduction": "The most rigorous theoretical predictions include an honest assessment of their own uncertainties. This advanced practice introduces the modern framework of uncertainty quantification (UQ) based on chiral Effective Field Theory (EFT) [@problem_id:3573318]. You will construct a computational emulator that propagates uncertainties from the theory's low-energy constants and its series truncation, producing a full probability distribution for the neutron skin thickness of $^{48}\\mathrm{Ca}$. This exercise moves beyond single-value predictions to the state-of-the-art practice of generating statistically meaningful results.", "problem": "You are tasked with constructing a computational emulator to quantify neutron skin thickness in a medium-mass nucleus within a principled uncertainty framework that follows Effective Field Theory (EFT) error propagation. The observable is the neutron skin thickness of calcium-48, denoted by $\\Delta r_{np}(^{48}\\mathrm{Ca})$, and defined as the difference between the neutron and proton root-mean-square radii, $\\Delta r_{np} = \\sqrt{\\langle r_n^2 \\rangle} - \\sqrt{\\langle r_p^2 \\rangle}$. The emulator must embed the separation of scales and order-by-order organization of chiral Effective Field Theory (EFT), and emulate contributions computed by the Valence-Space In-Medium Similarity Renormalization Group (VS-IMSRG) up to a known order while treating omitted higher-order terms probabilistically. Your task is to formalize this problem from first principles and implement a program to produce a reproducible posterior summary of $\\Delta r_{np}$ under specified scenarios.\n\nFundamental base, assumptions, and structure:\n\n1. Adopt the organizing principle of chiral Effective Field Theory (EFT): an observable $X$ admits a low-momentum expansion in a small parameter $Q$, given by $X(Q) = \\sum_{n=0}^{\\infty} c_n Q^n$, where $Q = p/\\Lambda_b$ with $p$ a characteristic momentum and $\\Lambda_b$ an EFT breakdown scale. The coefficients $c_n$ are dimensionful and are assumed to be \"natural\" (order unity in EFT-normalized units) when appropriately scaled. The series is truncated in practice, which induces a truncation error dominated by omitted terms for $n$ greater than the maximal included order.\n\n2. Model the predicted neutron skin thickness for $^{48}\\mathrm{Ca}$ as\n$$\n\\Delta r_{np} = b_0 + b_L \\, L + b_{LL} \\, L^2 + \\sum_{n=0}^{N_{\\mathrm{avail}}} \\bar{c}_n \\, Q^n + \\sum_{n=N_{\\mathrm{avail}}+1}^{\\infty} c_n \\, Q^n,\n$$\nwhere $L$ is the symmetry-energy slope parameter in megaelectronvolts, $b_0$, $b_L$, and $b_{LL}$ are emulator coefficients approximating VS-IMSRG baseline sensitivity to isovector physics, $\\bar{c}_n$ are known included-order contributions (emulating VS-IMSRG results at computed orders), and $c_n$ for $n > N_{\\mathrm{avail}}$ are unknown higher-order coefficients modeled probabilistically. This decomposition enforces the separation between computed contributions and EFT truncation uncertainty. All contributions have units consistent with femtometers for $\\Delta r_{np}$.\n\n3. Treat the low-energy constants (LECs) that control isovector physics via a minimal linearized map to the symmetry-energy slope parameter $L$. Introduce two isovector LECs, $C_1$ and $C_2$, with independent Gaussian priors:\n$$\nC_1 \\sim \\mathcal{N}(\\mu_1, \\sigma_1^2), \\quad C_2 \\sim \\mathcal{N}(\\mu_2, \\sigma_2^2).\n$$\nDefine a linear map to $L$ by\n$$\nL = \\kappa_1 C_1 + \\kappa_2 C_2,\n$$\nwhere $\\kappa_1$ and $\\kappa_2$ are constants in megaelectronvolts. This map encodes a first-order sensitivity to isovector couplings.\n\n4. Use well-tested EFT naturalness assumptions for unknown higher-order coefficients:\n$$\nc_n \\stackrel{\\mathrm{iid}}{\\sim} \\mathcal{N}(0, \\sigma_c^2),\n$$\nindependent across $n$ and independent of $(C_1, C_2)$. This induces a Gaussian truncation tail with variance increasing with $Q$ and decreasing with the number of included orders $N_{\\mathrm{avail}}$. Implement the infinite tail as a finite sum to a large order $N_{\\mathrm{tail}}$ ensuring numerical convergence.\n\n5. For scientific plausibility and unit consistency, use the following emulator constants:\n- Emulator sensitivity coefficients in femtometers and mixed units:\n$$\nb_0 = 0.10 \\,\\mathrm{fm}, \\quad b_L = 0.0005 \\,\\mathrm{fm/MeV}, \\quad b_{LL} = 1.0 \\times 10^{-6} \\,\\mathrm{fm/MeV}^2.\n$$\n- Isovector LEC prior means and standard deviations (dimensionless):\n$$\n\\mu_1 = 1.0, \\quad \\sigma_1 = 0.2; \\quad \\mu_2 = 0.0, \\quad \\sigma_2 = 0.3.\n$$\n- Linear map coefficients:\n$$\n\\kappa_1 = 60.0 \\,\\mathrm{MeV}, \\quad \\kappa_2 = 20.0 \\,\\mathrm{MeV}.\n$$\n- Included-order emulator contributions (known VS-IMSRG-like terms, in femtometers):\n$$\n\\bar{c}_0 = 0.015 \\,\\mathrm{fm}, \\quad \\bar{c}_1 = -0.005 \\,\\mathrm{fm}, \\quad \\bar{c}_2 = 0.003 \\,\\mathrm{fm}, \\quad \\bar{c}_3 = 0.000 \\,\\mathrm{fm}, \\quad \\bar{c}_4 = -0.001 \\,\\mathrm{fm}.\n$$\n- Naturalness scale for unknown higher-order coefficients:\n$$\n\\sigma_c = 0.02 \\,\\mathrm{fm}.\n$$\n\n6. Algorithmic requirements:\n- Perform Monte Carlo sampling of $(C_1, C_2)$ from their Gaussian priors and of $c_n$ for $n \\in \\{N_{\\mathrm{avail}}+1, \\ldots, N_{\\mathrm{avail}} + N_{\\mathrm{tail}}\\}$ from $\\mathcal{N}(0, \\sigma_c^2)$.\n- For each sample, compute $L$, the baseline VS-IMSRG emulator $b_0 + b_L L + b_{LL} L^2$, add the known included-order sum $\\sum_{n=0}^{N_{\\mathrm{avail}}} \\bar{c}_n Q^n$, and add the sampled truncation tail $\\sum_{n=N_{\\mathrm{avail}}+1}^{N_{\\mathrm{avail}}+N_{\\mathrm{tail}}} c_n Q^n$ to assemble a sampled $\\Delta r_{np}$.\n- Use a fixed random seed for reproducibility.\n\n7. Statistical summary and output specification:\n- For each test case, compute the posterior mean of $\\Delta r_{np}$ and the central $68\\%$ credible half-width defined as $\\frac{1}{2}(q_{0.84} - q_{0.16})$, where $q_{p}$ denotes the $p$-quantile of the Monte Carlo samples.\n- Express all results in femtometers, rounded to three decimal places.\n\nTest suite:\nEvaluate the emulator under the following scenarios, each specified by $(Q, N_{\\mathrm{avail}}, N_{\\mathrm{tail}}, N_{\\mathrm{samples}})$:\n- Case $1$: $(Q = 0.35, \\, N_{\\mathrm{avail}} = 3, \\, N_{\\mathrm{tail}} = 50, \\, N_{\\mathrm{samples}} = 20000)$.\n- Case $2$: $(Q = 0.50, \\, N_{\\mathrm{avail}} = 2, \\, N_{\\mathrm{tail}} = 50, \\, N_{\\mathrm{samples}} = 20000)$.\n- Case $3$: $(Q = 0.25, \\, N_{\\mathrm{avail}} = 4, \\, N_{\\mathrm{tail}} = 50, \\, N_{\\mathrm{samples}} = 20000)$.\n- Case $4$: $(Q = 0.55, \\, N_{\\mathrm{avail}} = 1, \\, N_{\\mathrm{tail}} = 50, \\, N_{\\mathrm{samples}} = 20000)$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case is represented by a two-element list of floats $[\\mathrm{mean}, \\mathrm{half\\_width}]$ in femtometers, each rounded to three decimal places. For example, the output must look like\n$[[0.123,0.015],[0.120,0.018],[0.130,0.012],[0.135,0.020]]$.", "solution": "The user has provided a well-defined problem in computational nuclear physics concerning the emulation of the neutron skin thickness of $^{48}\\mathrm{Ca}$ using a model derived from chiral Effective Field Theory (EFT). I will proceed with a detailed, step-by-step solution.\n\nThe problem is to compute the posterior mean and the $68\\%$ central credible half-width for the neutron skin thickness, $\\Delta r_{np}$, under four different scenarios. The model for $\\Delta r_{np}$ is a composite one, combining a baseline model dependent on the nuclear symmetry-energy slope parameter $L$, a sum of known contributions from the EFT expansion, and a probabilistic term representing the EFT truncation error.\n\nThe model is given by:\n$$\n\\Delta r_{np} = \\underbrace{b_0 + b_L \\, L + b_{LL} \\, L^2}_{\\text{Baseline (from }L\\text{)}} + \\underbrace{\\sum_{n=0}^{N_{\\mathrm{avail}}} \\bar{c}_n \\, Q^n}_{\\text{Known EFT terms}} + \\underbrace{\\sum_{n=N_{\\mathrm{avail}}+1}^{N_{\\mathrm{avail}}+N_{\\mathrm{tail}}} c_n \\, Q^n}_{\\text{EFT Truncation Error}}\n$$\nwhere the infinite sum for the truncation error is approximated by a finite sum up to a sufficiently high order $N_{\\mathrm{avail}}+N_{\\mathrm{tail}}$. The parameters in this model are sourced from different distributions, reflecting their respective uncertainties.\n\nThe parameter $L$, the symmetry-energy slope, is not directly sampled. Instead, it is determined by a linear mapping from two underlying dimensionless low-energy constants (LECs), $C_1$ and $C_2$:\n$$\nL = \\kappa_1 C_1 + \\kappa_2 C_2\n$$\nThe LECs themselves are treated as independent random variables drawn from Gaussian priors:\n$$\nC_1 \\sim \\mathcal{N}(\\mu_1, \\sigma_1^2), \\quad C_2 \\sim \\mathcal{N}(\\mu_2, \\sigma_2^2)\n$$\nThe problem specifies the values for the means ($\\mu_1, \\mu_2$), standard deviations ($\\sigma_1, \\sigma_2$), and the linear map coefficients ($\\kappa_1, \\kappa_2$).\n\nThe coefficients $c_n$ for the unknown higher-order terms in the EFT expansion ($n > N_{\\mathrm{avail}}$) are modeled as independent and identically distributed random variables, consistent with EFT naturalness assumptions. They are drawn from a zero-mean Gaussian distribution:\n$$\nc_n \\stackrel{\\mathrm{iid}}{\\sim} \\mathcal{N}(0, \\sigma_c^2)\n$$\nThe standard deviation $\\sigma_c$ is given, representing the expected size of these coefficients in natural units (here, specified in femtometers).\n\nThe remaining quantities in the model are deterministic constants for any given test case: the baseline coefficients ($b_0, b_L, b_{LL}$), the expansion parameter $Q$, the known EFT coefficients ($\\bar{c}_n$ up to order $N_{\\mathrm{avail}}$), and the order of truncation $N_{\\mathrm{avail}}$.\n\nThe computational strategy is to perform a Monte Carlo simulation. For each test case, we will generate a large number of samples ($N_{\\mathrm{samples}}$) from the posterior predictive distribution of $\\Delta r_{np}$. A single sample of $\\Delta r_{np}$ is constructed as follows:\n1.  Draw a single sample of $C_1$ from $\\mathcal{N}(\\mu_1, \\sigma_1^2)$ and a single sample of $C_2$ from $\\mathcal{N}(\\mu_2, \\sigma_2^2)$.\n2.  Calculate the corresponding value of $L$ using the linear map.\n3.  Calculate the baseline contribution, $b_0 + b_L L + b_{LL} L^2$.\n4.  Draw $N_{\\mathrm{tail}}$ samples for the unknown coefficients $c_n$ for $n = N_{\\mathrm{avail}}+1, \\dots, N_{\\mathrm{avail}}+N_{\\mathrm{tail}}$, each from $\\mathcal{N}(0, \\sigma_c^2)$.\n5.  Calculate the truncation error contribution by summing these sampled coefficients multiplied by the appropriate powers of $Q$, i.e., $\\sum_{n=N_{\\mathrm{avail}}+1}^{N_{\\mathrm{avail}}+N_{\\mathrm{tail}}} c_n Q^n$.\n6.  The deterministic part from known EFT orders, $\\sum_{n=0}^{N_{\\mathrm{avail}}} \\bar{c}_n Q^n$, is calculated once per test case.\n7.  Sum these three components (baseline, known EFT, truncation error) to obtain one sample of $\\Delta r_{np}$.\n\nThis process is repeated $N_{\\mathrm{samples}}$ times. For efficiency, this procedure will be vectorized using `numpy`. We can generate all $N_{\\mathrm{samples}}$ of $C_1$ and $C_2$ at once, producing arrays of $L$ values and baseline contributions. Similarly, we can generate an $N_{\\mathrm{samples}} \\times N_{\\mathrm{tail}}$ matrix of $c_n$ samples and use a matrix-vector product to compute the truncation error term for all samples simultaneously.\n\nOnce the array of $N_{\\mathrm{samples}}$ of $\\Delta r_{np}$ is generated, we compute two summary statistics:\n1.  The posterior mean, which is the arithmetic average of the samples: $\\langle \\Delta r_{np} \\rangle = \\frac{1}{N_{\\mathrm{samples}}} \\sum_{i=1}^{N_{\\mathrm{samples}}} (\\Delta r_{np})_i$.\n2.  The central $68\\%$ credible half-width. This requires finding the $16^{th}$ and $84^{th}$ percentiles of the sample distribution, denoted $q_{0.16}$ and $q_{0.84}$ respectively. The half-width is then given by $\\frac{1}{2}(q_{0.84} - q_{0.16})$.\n\nThis entire process is repeated for each of the four test cases specified, which differ in their values of the expansion parameter $Q$ and the included EFT order $N_{\\mathrm{avail}}$. The final results, rounded to three decimal places, will be presented in the specified list format. A fixed random seed will be used to ensure the numerical reproducibility of the results.\n\nThe physical constants and model parameters are:\n- $b_0 = 0.10$ fm\n- $b_L = 0.0005$ fm/MeV\n- $b_{LL} = 1.0 \\times 10^{-6}$ fm/MeV$^2$\n- $\\mu_1 = 1.0$, $\\sigma_1 = 0.2$\n- $\\mu_2 = 0.0$, $\\sigma_2 = 0.3$\n- $\\kappa_1 = 60.0$ MeV\n- $\\kappa_2 = 20.0$ MeV\n- $\\bar{c} = [0.015, -0.005, 0.003, 0.000, -0.001]$ fm\n- $\\sigma_c = 0.02$ fm\n\nThese will be hardcoded in the implementation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the posterior mean and 68% credible half-width for the neutron\n    skin thickness of 48Ca using an EFT-based emulator.\n    \"\"\"\n    # Set a fixed random seed for reproducibility.\n    np.random.seed(42)\n\n    # Define the constants from the problem statement.\n    # Emulator sensitivity coefficients\n    b0 = 0.10  # fm\n    bL = 0.0005  # fm/MeV\n    bLL = 1.0e-6  # fm/MeV^2\n\n    # Isovector LEC prior means and standard deviations (dimensionless)\n    mu1, sigma1 = 1.0, 0.2\n    mu2, sigma2 = 0.0, 0.3\n\n    # Linear map coefficients\n    kappa1 = 60.0  # MeV\n    kappa2 = 20.0  # MeV\n\n    # Included-order emulator contributions (fm)\n    c_bar = np.array([0.015, -0.005, 0.003, 0.000, -0.001])\n\n    # Naturalness scale for unknown higher-order coefficients\n    sigma_c = 0.02  # fm\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Q, N_avail, N_tail, N_samples)\n        (0.35, 3, 50, 20000),\n        (0.50, 2, 50, 20000),\n        (0.25, 4, 50, 20000),\n        (0.55, 1, 50, 20000),\n    ]\n\n    results = []\n    for Q, N_avail, N_tail, N_samples in test_cases:\n        # Perform Monte Carlo simulation for a single case.\n        \n        # 1. Sample LECs and compute L, the symmetry-energy slope.\n        C1_samples = np.random.normal(mu1, sigma1, N_samples)\n        C2_samples = np.random.normal(mu2, sigma2, N_samples)\n        L_samples = kappa1 * C1_samples + kappa2 * C2_samples\n        \n        # 2. Compute the baseline contribution to delta_r_np.\n        baseline_samples = b0 + bL * L_samples + bLL * L_samples**2\n        \n        # 3. Compute the deterministic contribution from known EFT orders.\n        # This is a scalar value for a given case.\n        known_orders = np.arange(0, N_avail + 1)\n        Q_powers_known = Q**known_orders\n        c_bar_known = c_bar[:N_avail + 1]\n        known_eft_term = np.dot(c_bar_known, Q_powers_known)\n        \n        # 4. Compute the probabilistic contribution from EFT truncation error.\n        # Orders for the truncation tail\n        trunc_orders = np.arange(N_avail + 1, N_avail + N_tail + 1)\n        Q_powers_trunc = Q**trunc_orders # Vector of shape (N_tail,)\n        \n        # Sample coefficients c_n ~ N(0, sigma_c^2)\n        c_n_samples = np.random.normal(0, sigma_c, size=(N_samples, N_tail))\n        \n        # Compute the sum for each Monte Carlo sample via matrix-vector product\n        trunc_error_samples = c_n_samples @ Q_powers_trunc\n        \n        # 5. Assemble the total delta_r_np for all samples.\n        dr_np_samples = baseline_samples + known_eft_term + trunc_error_samples\n        \n        # 6. Compute summary statistics.\n        # Posterior mean\n        mean_dr_np = np.mean(dr_np_samples)\n        \n        # Central 68% credible half-width\n        q16, q84 = np.quantile(dr_np_samples, [0.16, 0.84])\n        half_width = 0.5 * (q84 - q16)\n        \n        # Round results and append to the list.\n        results.append([round(mean_dr_np, 3), round(half_width, 3)])\n\n    # Format the final output string as specified.\n    # e.g., [[0.123, 0.015], [0.120, 0.018], ...]\n    result_str = \",\".join([f\"[{m},{w}]\" for m, w in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "3573318"}]}