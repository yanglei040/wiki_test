{"hands_on_practices": [{"introduction": "Any practical nuclear structure calculation must work within a finite, truncated model space. The operators for Fermi transitions, $\\hat{T}_\\pm$ and $\\hat{T}_z$, are generators of the $SU(2)$ isospin group and must obey its strict commutation relations. This exercise [@problem_id:3546702] provides hands-on practice in representing these operators as matrices and numerically investigating how projecting them onto a truncated space can violate the fundamental algebra, a critical diagnostic for the integrity of a computational model.", "problem": "Consider the Special Unitary group of degree two ($SU(2)$) acting in an isospin space characterized by total isospin $T$ with basis states $\\lvert T,m\\rangle$ for $m \\in \\{-T,-T+1,\\dots,T\\}$. The Fermi transition operator relevant for Fermi $\\beta$ decay is the isospin raising or lowering operator $ \\hat{T}_\\pm $, and the Fermi matrix element $M_F$ between isobaric analog states is the transition amplitude $ \\langle T,m_f \\lvert \\hat{T}_\\pm \\rvert T,m_i \\rangle $ with $m_f = m_i \\pm 1$. In a computational setting with a truncated model space, effective operators are introduced to act within the truncated space; however, truncation can modify the operator algebra.\n\nStarting from the following fundamental base: the $SU(2)$ Lie algebra representation in the $\\lvert T,m\\rangle$ basis is defined by the ladder actions $ \\hat{T}_\\pm \\lvert T,m\\rangle = \\sqrt{T(T+1)-m(m\\pm 1)} \\, \\lvert T,m\\pm 1\\rangle $ and the diagonal action $ \\hat{T}_z \\lvert T,m\\rangle = m \\lvert T,m\\rangle $. The commutator of two operators $ \\hat{A} $ and $ \\hat{B} $ is $ [\\hat{A},\\hat{B}] = \\hat{A}\\hat{B} - \\hat{B}\\hat{A} $. The Frobenius norm of a matrix $ \\hat{X} $ is $ \\lVert \\hat{X} \\rVert_F = \\sqrt{\\sum_{i,j} \\lvert X_{ij} \\rvert^2} $.\n\nYou must implement a program that constructs the exact $SU(2)$ operators $ \\hat{T}_+ $, $ \\hat{T}_- $, and $ \\hat{T}_z $ for a given $T$, then projects them into a specified truncated subspace spanned by a subset of the $m$ values. Define two operator sets within the truncated space:\n\n1. Projected operators: $ \\hat{T}_\\pm^{(P)} = P \\hat{T}_\\pm P $ and $ \\hat{T}_z^{(P)} = P \\hat{T}_z P $, where $P$ is the projector onto the truncated subspace.\n2. Algebra-restored effective operators: $ \\hat{T}_\\pm^{(\\mathrm{eff})} = \\hat{T}_\\pm^{(P)} $ and $ \\hat{T}_z^{(\\mathrm{eff})} = \\tfrac{1}{2} \\left[ \\hat{T}_+^{(\\mathrm{eff})}, \\hat{T}_-^{(\\mathrm{eff})} \\right] $.\n\nFor each test case below, compute three quantities:\n\n- The algebra violation in the projected set: $ D_P = \\left\\lVert \\left[ \\hat{T}_+^{(P)}, \\hat{T}_-^{(P)} \\right] - 2 \\hat{T}_z^{(P)} \\right\\rVert_F $.\n- The algebra violation in the algebra-restored effective set: $ D_{\\mathrm{eff}} = \\left\\lVert \\left[ \\hat{T}_+^{(\\mathrm{eff})}, \\hat{T}_-^{(\\mathrm{eff})} \\right] - 2 \\hat{T}_z^{(\\mathrm{eff})} \\right\\rVert_F $.\n- The absolute error in the Fermi matrix element within the truncated space using $ \\hat{T}_\\pm^{(\\mathrm{eff})} $ relative to the exact full-space matrix element using $ \\hat{T}_\\pm $ for the specified transition $ m_i \\to m_f $: $ E_F = \\left\\lvert \\langle T,m_f \\lvert \\hat{T}_\\pm^{(\\mathrm{eff})} \\rvert T,m_i \\rangle_{\\text{trunc}} - \\langle T,m_f \\lvert \\hat{T}_\\pm \\rvert T,m_i \\rangle_{\\text{full}} \\right\\rvert $. If either $m_i$ or $m_f$ is absent from the truncated subspace, define the truncated matrix element to be $0$.\n\nUse the following test suite, which covers a complete space, contiguous truncations, and noncontiguous truncations with allowed and disallowed transitions:\n\n- Test case 1: $ T = 2 $, truncated $ m $-set $ \\{-2,-1,0,1,2\\} $, operator $ \\hat{T}_+ $, initial $ m_i = 0 $ (thus $ m_f = 1 $).\n- Test case 2: $ T = 2 $, truncated $ m $-set $ \\{-2,-1,0,1\\} $, operator $ \\hat{T}_+ $, initial $ m_i = 1 $ (thus $ m_f = 2 $).\n- Test case 3: $ T = \\tfrac{3}{2} $, truncated $ m $-set $ \\{-\\tfrac{3}{2},-\\tfrac{1}{2},\\tfrac{1}{2}\\} $, operator $ \\hat{T}_+ $, initial $ m_i = -\\tfrac{1}{2} $ (thus $ m_f = \\tfrac{1}{2} $).\n- Test case 4: $ T = \\tfrac{3}{2} $, truncated $ m $-set $ \\{-\\tfrac{3}{2},\\tfrac{1}{2},\\tfrac{3}{2}\\} $, operator $ \\hat{T}_- $, initial $ m_i = \\tfrac{1}{2} $ (thus $ m_f = -\\tfrac{1}{2} $).\n- Test case 5: $ T = \\tfrac{5}{2} $, truncated $ m $-set $ \\{-\\tfrac{5}{2},-\\tfrac{3}{2},-\\tfrac{1}{2},\\tfrac{1}{2},\\tfrac{3}{2}\\} $, operator $ \\hat{T}_+ $, initial $ m_i = \\tfrac{3}{2} $ (thus $ m_f = \\tfrac{5}{2} $).\n\nYour program should produce a single line of output containing the results as a comma-separated list of lists, each inner list ordered as $[D_P, D_{\\mathrm{eff}}, E_F]$ in the same order as the test cases, enclosed in square brackets. For example, the output format must be exactly like $[[d_1,d_2,e_1],[d_3,d_4,e_2],\\dots]$ with numeric values.", "solution": "The problem is scientifically grounded, well-posed, and objective. It presents a clearly defined computational task rooted in the standard principles of quantum mechanics, specifically the representation theory of the $SU(2)$ Lie group as applied to nuclear isospin. The concepts of model space truncation, effective operators, and a quantitative analysis of the resulting violation of the operator algebra are standard topics in computational many-body physics. All necessary definitions, constants, and test cases are provided, and there are no internal contradictions or ambiguities. The problem is therefore valid and a solution can be constructed.\n\nThe solution will be developed by following these principal steps:\n1.  Represent the isospin operators $\\hat{T}_+, \\hat{T}_-,$ and $\\hat{T}_z$ as matrices in the full Hilbert space for a given total isospin $T$.\n2.  Define the truncated model space and construct the projection operator $P$.\n3.  Apply the projector to obtain the projected operators $\\hat{T}_\\pm^{(P)}$ and $\\hat{T}_z^{(P)}$ which act within the truncated space.\n4.  Construct the algebra-restored effective operators $\\hat{T}_\\pm^{(\\mathrm{eff})}$ and $\\hat{T}_z^{(\\mathrm{eff})}$ according to their definitions.\n5.  Compute the required quantities: the algebra violation for projected operators $D_P$, the algebra violation for effective operators $D_\\mathrm{eff}$, and the error in the Fermi matrix element $E_F$.\n\n**Step 1: Full-Space Matrix Representation**\n\nFor a given total isospin $T$, the Hilbert space is spanned by the $d = 2T+1$ basis states $\\lvert T, m \\rangle$, where $m \\in \\{T, T-1, \\dots, -T\\}$. We establish an ordered basis by sorting these states in descending order of their magnetic quantum number $m$. In this basis, a state $\\lvert T, m \\rangle$ is a column vector with a $1$ at the position corresponding to its $m$ value and zeros elsewhere. The index $j$ of a basis vector (from $0$ to $d-1$) corresponds to the quantum number $m_j = T-j$.\n\nThe matrix elements of the operators $\\hat{T}_z$, $\\hat{T}_+$, and $\\hat{T}_-$ in this basis are given by:\n-   $\\langle T, m' \\lvert \\hat{T}_z \\rvert T, m \\rangle = m \\, \\delta_{m',m}$. This results in a diagonal matrix $(\\hat{T}_z)_{ij} = (T-i) \\delta_{ij}$.\n-   $\\langle T, m' \\lvert \\hat{T}_+ \\rvert T, m \\rangle = \\sqrt{T(T+1)-m(m+1)} \\, \\delta_{m',m+1}$. This is a superdiagonal matrix.\n-   $\\langle T, m' \\lvert \\hat{T}_- \\rvert T, m \\rangle = \\sqrt{T(T+1)-m(m-1)} \\, \\delta_{m',m-1}$. This is a subdiagonal matrix, and $\\hat{T}_- = (\\hat{T}_+)^\\dagger$.\n\n**Step 2: Projection into the Truncated Space**\n\nA truncated model space is defined by a subset of the full set of $m$ values. The projection operator $P$ isolates this subspace. If the truncated basis is of dimension $d_{\\text{trunc}}$, the projected operators are $d_{\\text{trunc}} \\times d_{\\text{trunc}}$ matrices.\nAlgorithmically, this is achieved by first identifying the indices of the basis states in the full space that are part of the truncated space. Then, the projected operator matrices are constructed by selecting only the rows and columns corresponding to these indices from the full-space operator matrices.\n\n**Step 3: Projected and Algebra-Restored Effective Operators**\n\nFollowing the problem definition, we construct two sets of operators in the truncated space.\n\n1.  **Projected Operators**: These are obtained by direct projection of the full-space operators.\n    $$ \\hat{T}_\\pm^{(P)} = P \\hat{T}_\\pm P $$\n    $$ \\hat{T}_z^{(P)} = P \\hat{T}_z P $$\n    In our matrix implementation, these correspond to the submatrices described in Step 2.\n\n2.  **Algebra-Restored Effective Operators**: This set is constructed to enforce one of the $SU(2)$ commutation relations by definition.\n    $$ \\hat{T}_\\pm^{(\\mathrm{eff})} = \\hat{T}_\\pm^{(P)} $$\n    $$ \\hat{T}_z^{(\\mathrm{eff})} = \\frac{1}{2} \\left[ \\hat{T}_+^{(\\mathrm{eff})}, \\hat{T}_-^{(\\mathrm{eff})} \\right] = \\frac{1}{2} \\left( \\hat{T}_+^{(P)} \\hat{T}_-^{(P)} - \\hat{T}_-^{(P)} \\hat{T}_+^{(P)} \\right) $$\n\n**Step 4: Calculation of Observables**\n\nWith the operator matrices defined, we can compute the three requested quantities.\n\n-   **Projected Algebra Violation, $D_P$**: The fundamental $SU(2)$ commutation relation is $[\\hat{T}_+, \\hat{T}_-] = 2\\hat{T}_z$. Truncation generally breaks this. The violation is quantified by the Frobenius norm of the residual matrix:\n    $$ D_P = \\left\\lVert \\left[ \\hat{T}_+^{(P)}, \\hat{T}_-^{(P)} \\right] - 2 \\hat{T}_z^{(P)} \\right\\rVert_F $$\n    where the Frobenius norm is $\\lVert \\hat{X} \\rVert_F = \\sqrt{\\sum_{i,j} |X_{ij}|^2}$. This is computed by matrix multiplication and subtraction, followed by the norm calculation.\n\n-   **Effective Algebra Violation, $D_{\\mathrm{eff}}$**: We compute the same quantity for the algebra-restored set.\n    $$ D_{\\mathrm{eff}} = \\left\\lVert \\left[ \\hat{T}_+^{(\\mathrm{eff})}, \\hat{T}_-^{(\\mathrm{eff})} \\right] - 2 \\hat{T}_z^{(\\mathrm{eff})} \\right\\rVert_F $$\n    By substituting the definition of $\\hat{T}_z^{(\\mathrm{eff})}$, we see:\n    $$ D_{\\mathrm{eff}} = \\left\\lVert \\left[ \\hat{T}_+^{(\\mathrm{eff})}, \\hat{T}_-^{(\\mathrm{eff})} \\right] - 2 \\left( \\frac{1}{2} \\left[ \\hat{T}_+^{(\\mathrm{eff})}, \\hat{T}_-^{(\\mathrm{eff})} \\right] \\right) \\right\\rVert_F = \\lVert 0 \\rVert_F = 0 $$\n    This quantity is identically zero by construction, which serves as a validation of the logic.\n\n-   **Fermi Matrix Element Error, $E_F$**: This measures the error in a specific transition amplitude due to the use of the effective operator.\n    $$ E_F = \\left\\lvert M_F^{(\\mathrm{eff})} - M_F^{(\\mathrm{exact})} \\right\\rvert $$\n    The exact matrix element $M_F^{(\\mathrm{exact})} = \\langle T, m_f \\lvert \\hat{T}_\\pm \\rvert T, m_i \\rangle$ is simply the value $\\sqrt{T(T+1)-m_i(m_i \\pm 1)}$. The effective matrix element $M_F^{(\\mathrm{eff})} = \\langle T, m_f \\lvert \\hat{T}_\\pm^{(\\mathrm{eff})} \\rvert T, m_i \\rangle_{\\text{trunc}}$ is extracted from the matrix $\\hat{T}_\\pm^{(\\mathrm{eff})}$. If either the initial state $\\lvert T, m_i \\rangle$ or final state $\\lvert T, m_f \\rangle$ is not in the truncated subspace, $M_F^{(\\mathrm{eff})}$ is defined to be $0$. Otherwise, it is the element of the $\\hat{T}_\\pm^{(\\mathrm{eff})}$ matrix connecting the basis vectors corresponding to $m_i$ and $m_f$. The absolute difference gives the error $E_F$.\n\nThis procedure is systematically applied to each test case to generate the final results.", "answer": "```python\nimport numpy as np\n\ndef solve_case(T, truncated_m_set, op_str, m_i):\n    \"\"\"\n    Solves a single test case for the SU(2) operator truncation problem.\n\n    Args:\n        T (float): Total isospin.\n        truncated_m_set (set): A set of m-values defining the truncated subspace.\n        op_str (str): The operator to use for E_F, either 'T+' or 'T-'.\n        m_i (float): The initial m-value for the transition.\n\n    Returns:\n        list: A list containing [D_p, D_eff, E_f].\n    \"\"\"\n    # 1. Define full space\n    # The dimension of the full SU(2) representation for isospin T\n    dim_full = int(2 * T + 1)\n    # Create the list of m-values, sorted in descending order, for the basis\n    full_m_list = np.arange(T, -T - 1, -1)\n    m_to_full_idx = {m: i for i, m in enumerate(full_m_list)}\n\n    # 2. Construct full-space operators\n    T_plus_full = np.zeros((dim_full, dim_full), dtype=float)\n    T_minus_full = np.zeros((dim_full, dim_full), dtype=float)\n    T_z_full = np.diag(full_m_list)\n\n    for i, m in enumerate(full_m_list):\n        # T+ acting on |T, m gives ...|T, m+1\n        if m  T:\n            # Map state |T, m (col i) to state |T, m+1 (row i-1)\n            val = np.sqrt(T * (T + 1) - m * (m + 1))\n            T_plus_full[i - 1, i] = val\n        # T- acting on |T, m gives ...|T, m-1\n        if m  -T:\n            # Map state |T, m (col i) to state |T, m-1 (row i+1)\n            val = np.sqrt(T * (T + 1) - m * (m - 1))\n            T_minus_full[i + 1, i] = val\n\n    # 3. Define truncated space and build projected operators\n    # Sort the truncated m-set descendingly to match the full basis ordering\n    trunc_m_list = sorted(list(truncated_m_set), reverse=True)\n    m_to_trunc_idx = {m: i for i, m in enumerate(trunc_m_list)}\n\n    # Get the indices in the full space that correspond to the truncated space\n    trunc_full_indices = [m_to_full_idx[m] for m in trunc_m_list]\n\n    # Build projected operators by taking submatrices\n    T_plus_p = T_plus_full[np.ix_(trunc_full_indices, trunc_full_indices)]\n    T_minus_p = T_minus_full[np.ix_(trunc_full_indices, trunc_full_indices)]\n    T_z_p = T_z_full[np.ix_(trunc_full_indices, trunc_full_indices)]\n\n    # 4. Calculate D_P (algebra violation in projected set)\n    commutator_p = T_plus_p @ T_minus_p - T_minus_p @ T_plus_p\n    violation_matrix_p = commutator_p - 2 * T_z_p\n    D_p = np.linalg.norm(violation_matrix_p, 'fro')\n\n    # 5. Calculate D_eff (algebra violation in algebra-restored set)\n    T_plus_eff = T_plus_p\n    T_minus_eff = T_minus_p\n    # T_z_eff is defined to restore the algebra\n    commutator_eff = T_plus_eff @ T_minus_eff - T_minus_eff @ T_plus_eff\n    T_z_eff = 0.5 * commutator_eff\n    \n    violation_matrix_eff = commutator_eff - 2 * T_z_eff\n    D_eff = np.linalg.norm(violation_matrix_eff, 'fro') # This will be zero by construction\n\n    # 6. Calculate E_F (error in Fermi matrix element)\n    if op_str == 'T+':\n        op_eff = T_plus_eff\n        m_f = m_i + 1\n        exact_me = np.sqrt(T*(T+1) - m_i*(m_i+1)) if m_i  T else 0\n    else:  # op_str == 'T-'\n        op_eff = T_minus_eff\n        m_f = m_i - 1\n        exact_me = np.sqrt(T*(T+1) - m_i*(m_i-1)) if m_i  -T else 0\n    \n    # Check if the transition occurs within the truncated space\n    if m_i in truncated_m_set and m_f in truncated_m_set:\n        idx_i_trunc = m_to_trunc_idx[m_i]\n        idx_f_trunc = m_to_trunc_idx[m_f]\n        trunc_me = op_eff[idx_f_trunc, idx_i_trunc]\n    else:\n        # If initial or final state is outside the truncated space, the matrix element is 0\n        trunc_me = 0.0\n\n    E_f = np.abs(trunc_me - exact_me)\n    \n    # Return results rounded to high precision to avoid floating point noise\n    return [round(D_p, 8), round(D_eff, 8), round(E_f, 8)]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # (T, truncated_m_set, operator_str, m_i)\n        (2.0, {-2.0, -1.0, 0.0, 1.0, 2.0}, 'T+', 0.0),\n        (2.0, {-2.0, -1.0, 0.0, 1.0}, 'T+', 1.0),\n        (1.5, {-1.5, -0.5, 0.5}, 'T+', -0.5),\n        (1.5, {-1.5, 0.5, 1.5}, 'T-', 0.5),\n        (2.5, {-2.5, -1.5, -0.5, 0.5, 1.5}, 'T+', 1.5),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        T, truncated_m_set, op_str, m_i = case\n        result = solve_case(T, truncated_m_set, op_str, m_i)\n        all_results.append(result)\n\n    # Format the final output string to match the problem specification\n    # e.g., [[d_1,d_2,e_1],[d_3,d_4,e_2],...] with no spaces\n    results_str_list = []\n    for res in all_results:\n        # res is a list like [1.0, 2.0, 3.0]\n        # format it to \"[1.0,2.0,3.0]\"\n        formatted_res_str = f\"[{res[0]},{res[1]},{res[2]}]\"\n        results_str_list.append(formatted_res_str)\n    \n    final_output = f\"[{','.join(results_str_list)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3546702"}, {"introduction": "Many-body nuclear calculations frequently employ a basis of harmonic oscillator wavefunctions for their convenience, but this choice can introduce computational artifacts if not handled carefully. A physical nuclear Hamiltonian must be translationally invariant, meaning the intrinsic structure is fully decoupled from the center-of-mass (CM) motion. This practice [@problem_id:3546717] walks you through a concrete model showing how basis truncation breaks this decoupling, leading to spurious CM contamination that spoils symmetry-protected observables like the Fermi matrix element, and demonstrates how to implement remedies to restore physical consistency.", "problem": "You are asked to derive, implement, and test a computational model that quantifies how the breaking of center-of-mass factorization impacts the Fermi matrix element in the No-Core Shell Model (NCSM), and to assess the effectiveness of remedies based on the center-of-mass Hamiltonian constraint and Lawson-term penalization. The objective is to compute the deviation of the Fermi matrix element due to center-of-mass contamination and demonstrate how different remedies restore the expected value.\n\nBegin from the following foundational base and definitions:\n\n- In a harmonic oscillator representation for a two-nucleon system with equal masses, the total Hamiltonian separates into intrinsic and center-of-mass parts when translational invariance holds. Let $x_1$ and $x_2$ denote the particle coordinates in one spatial dimension, with the center-of-mass coordinate $X = \\frac{x_1 + x_2}{2}$ and the relative coordinate $x = x_1 - x_2$. For equal masses $m$ and angular frequency $\\omega$, the center-of-mass mass is $M = 2m$ and the reduced mass is $\\mu = \\frac{m}{2}$.\n- The center-of-mass Hamiltonian is $H_{\\mathrm{cm}} = \\frac{P^2}{2M} + \\frac{1}{2} M \\omega^2 X^2$, and the intrinsic Hamiltonian is $H_{\\mathrm{int}} = \\frac{p^2}{2\\mu} + \\frac{1}{2} \\mu \\omega^2 x^2$, where $P$ and $p$ are the respective conjugate momenta.\n- The Fermi matrix element $M_F$ is defined by the sum of isospin-raising operators acting on all nucleons, $F = \\sum_{i=1}^A \\tau_i^+$, and connects isobaric analog states. For a two-nucleon system in a pure isospin triplet $T=1$ with projection change $\\Delta M_T = +1$, the ideal value is $M_F = \\sqrt{2}$ if the spatial parts of the initial and final states are identical and center-of-mass factorization holds.\n- Breaking center-of-mass factorization can be modeled by adding a weak coupling between $X$ and $x$ to the Hamiltonian, which correlates center-of-mass and intrinsic motions. Introduce a coupling $H_{\\mathrm{coup}} = \\alpha X x$ with a small real parameter $\\alpha$. The total Hamiltonian to diagonalize is $H = H_{\\mathrm{cm}} + H_{\\mathrm{int}} + H_{\\mathrm{coup}}$.\n- Remedies include constraining the center-of-mass state to the $n_{\\mathrm{cm}} = 0$ subspace (a hard constraint emulating $H_{\\mathrm{cm}}$ minimization) or adding a Lawson term, which penalizes center-of-mass excitations by $H \\mapsto H + \\beta H_{\\mathrm{cm}}$, with $\\beta  0$.\n\nRepresentation and computational setup:\n\n- Work in units where $\\hbar = 1$, $m = 1$, and $\\omega = 1$. Energies are thus in units of $\\hbar\\omega$.\n- Use a product basis of harmonic oscillator eigenstates for center-of-mass and relative motion, $\\{|N\\rangle_{\\mathrm{cm}} \\otimes |n\\rangle_{\\mathrm{rel}}\\}$, where $N = 0,\\dots,N_{\\mathrm{cm}}^{\\max}$ and $n = 0,\\dots,N_{\\mathrm{rel}}^{\\max}$. The uncoupled Hamiltonian has eigenvalues $E_{N,n} = \\omega \\left(N + \\tfrac{1}{2}\\right) + \\omega \\left(n + \\tfrac{1}{2}\\right)$.\n- The position operators in one dimension have matrix elements in the harmonic oscillator basis given by $X = x_{\\mathrm{cm}} \\left(\\sqrt{N+1} |N\\rangle\\langle N+1| + \\sqrt{N} |N\\rangle\\langle N-1|\\right)$ and $x = x_{\\mathrm{rel}} \\left(\\sqrt{n+1} |n\\rangle\\langle n+1| + \\sqrt{n} |n\\rangle\\langle n-1|\\right)$, with $x_{\\mathrm{cm}} = \\sqrt{\\frac{1}{2 M \\omega}}$ and $x_{\\mathrm{rel}} = \\sqrt{\\frac{1}{2 \\mu \\omega}}$. In these units, $M = 2$, $\\mu = \\tfrac{1}{2}$, thus $x_{\\mathrm{cm}} = \\tfrac{1}{2}$ and $x_{\\mathrm{rel}} = 1$.\n- The coupling $H_{\\mathrm{coup}} = \\alpha X x$ thus connects states with $(N,n) \\to (N\\pm 1, n \\pm 1)$.\n\nIsospin structure and evaluation of $M_F$:\n\n- Consider three isospin sectors labeled by spatial states associated with $|pp\\rangle$, $|pn\\rangle$, and $|np\\rangle$. Construct the initial isospin-symmetric state $|i\\rangle = \\frac{1}{\\sqrt{2}}\\left(|pn\\rangle + |np\\rangle\\right)$ with respective spatial parts $\\phi_{pn}(X,x)$ and $\\phi_{np}(X,x)$, and the final state $|f\\rangle = |pp\\rangle$ with spatial part $\\phi_{pp}(X,x)$.\n- The Fermi operator $F$ acts only on the isospin part, mapping $|pn\\rangle \\mapsto |pp\\rangle$ and $|np\\rangle \\mapsto |pp\\rangle$. The reduced Fermi matrix element thus becomes\n$$\nM_F = \\frac{1}{\\sqrt{2}} \\left( \\langle \\phi_{pp} | \\phi_{pn} \\rangle + \\langle \\phi_{pp} | \\phi_{np} \\rangle \\right),\n$$\nwhere each inner product is computed over the product basis of center-of-mass and relative harmonic oscillator states.\n- Center-of-mass contamination is quantified by the expectation value $\\langle H_{\\mathrm{cm}} \\rangle$ in each sector’s ground state; in the ideal factorized case it equals $\\tfrac{1}{2}$ in these units.\n\nComputational tasks:\n\n1. For each isospin sector ($pp$, $pn$, $np$), build $H = H_{\\mathrm{cm}} + H_{\\mathrm{int}} + H_{\\mathrm{coup}} + \\beta H_{\\mathrm{cm}}$ with the specified $(\\alpha,\\beta)$ and sector-specific center-of-mass truncations $N_{\\mathrm{cm}}^{\\max}$ and a common relative truncation $N_{\\mathrm{rel}}^{\\max}$.\n2. Diagonalize $H$ to obtain the normalized ground-state spatial vector $\\phi_{\\mathrm{sector}}$ in the sector’s product basis. Embed each sector’s ground state into a common “superspace” basis determined by $N_{\\mathrm{cm}}^{\\sup} = \\max\\{N_{\\mathrm{cm},pp}^{\\max}, N_{\\mathrm{cm},pn}^{\\max}, N_{\\mathrm{cm},np}^{\\max}\\}$ and the common $N_{\\mathrm{rel}}^{\\max}$ by zero-padding missing components.\n3. Compute $M_F$ by the formula above using the embedded states, and compute the average center-of-mass contamination defined as the arithmetic mean of $\\langle H_{\\mathrm{cm}} \\rangle$ in the $pp$, $pn$, and $np$ sectors.\n4. Express energies in units of $\\hbar\\omega$ and the Fermi matrix element as a dimensionless number.\n\nTest suite:\n\nImplement the following five test cases, each specified by the tuple $\\{N_{\\mathrm{cm},pp}^{\\max}, N_{\\mathrm{cm},pn}^{\\max}, N_{\\mathrm{cm},np}^{\\max}, N_{\\mathrm{rel}}^{\\max}, \\alpha, \\beta\\}$:\n\n- Case 1 (ideal factorization baseline): $\\{3,3,3,6,0.0,0.0\\}$.\n- Case 2 (broken factorization via coupling and mismatched truncations): $\\{1,1,2,6,0.2,0.0\\}$.\n- Case 3 (hard $H_{\\mathrm{cm}}$ constraint remedy, center-of-mass frozen): $\\{0,0,0,6,0.2,0.0\\}$.\n- Case 4 (Lawson-term remedy): $\\{3,3,3,6,0.2,5.0\\}$.\n- Case 5 (strong coupling, mismatched truncations): $\\{1,2,3,6,0.5,0.0\\}$.\n\nRequired outputs and format:\n\n- For each case, compute two floats: the Fermi matrix element $M_F$ and the average center-of-mass energy $\\overline{\\langle H_{\\mathrm{cm}} \\rangle}$ across the three sectors, both in the units specified above.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order\n$$\n[M_F^{(1)}, \\overline{\\langle H_{\\mathrm{cm}} \\rangle}^{(1)}, M_F^{(2)}, \\overline{\\langle H_{\\mathrm{cm}} \\rangle}^{(2)}, \\dots, M_F^{(5)}, \\overline{\\langle H_{\\mathrm{cm}} \\rangle}^{(5)}].\n$$\n\nAngles are not used in this problem. No percentages are used; all computations are performed in the specified units with outputs as decimal floats.", "solution": "The problem asks for a computational analysis of center-of-mass (CM) factorization breaking in a simplified two-nucleon system and the effectiveness of common remedies. This is a quintessential problem in the No-Core Shell Model (NCSM), where wavefunctions are constructed in a basis of harmonic oscillator (HO) states. Unless handled carefully, the finite truncation of this basis breaks the translational invariance of the nuclear Hamiltonian, leading to spurious mixing of the intrinsic motion of nucleons with the motion of their center-of-mass. This contamination affects the calculation of observables, including the Fermi matrix element $M_F$ for beta decay, which should be protected by isospin symmetry. We will construct the Hamiltonian matrix for the system, diagonalize it to find the ground state wavefunctions, and then compute the Fermi matrix element $M_F$ and the expectation value of the CM Hamiltonian, $\\langle H_{\\mathrm{cm}} \\rangle$, to quantify the contamination and the success of the remedies.\n\n**1. Theoretical Framework: Hamiltonian and Basis States**\n\nWe model a two-nucleon system in one dimension using a harmonic oscillator basis. The units are set such that $\\hbar = 1$, the nucleon mass $m = 1$, and the oscillator frequency $\\omega = 1$. Consequently, the center-of-mass mass is $M = 2m = 2$ and the reduced mass is $\\mu = m/2 = 1/2$.\n\nThe total Hamiltonian $H$ is a sum of four components: the intrinsic Hamiltonian $H_{\\mathrm{int}}$, the center-of-mass Hamiltonian $H_{\\mathrm{cm}}$, a coupling term $H_{\\mathrm{coup}}$ modeling the factorization breaking, and a Lawson penalty term $H_{\\mathrm{Lawson}}$ used as a remedy.\n$$\nH = H_{\\mathrm{int}} + H_{\\mathrm{cm}} + H_{\\mathrm{coup}} + H_{\\mathrm{Lawson}}\n$$\nSubstituting the given definitions, this becomes:\n$$\nH = H_{\\mathrm{int}} + (1+\\beta) H_{\\mathrm{cm}} + \\alpha X x\n$$\nwhere $\\alpha$ is the coupling strength parameter and $\\beta$ is the Lawson penalty parameter.\n\nThe problem is solved within a truncated product basis of HO eigenstates for the relative ($n$) and CM ($N$) motion: $\\{|N\\rangle_{\\mathrm{cm}} \\otimes |n\\rangle_{\\mathrm{rel}}\\}$, which we denote as $|N, n\\rangle$. The basis is truncated at maximum quantum numbers $N_{\\mathrm{cm}}^{\\max}$ and $N_{\\mathrm{rel}}^{\\max}$.\n\n**2. Matrix Representation of the Hamiltonian**\n\nWe construct the matrix representation of $H$ in the $|N, n\\rangle$ basis. A pair of indices $(N, n)$ can be mapped to a single matrix index $k$.\n\n- **Intrinsic and Center-of-Mass Hamiltonians ($H_{\\mathrm{int}}, H_{\\mathrm{cm}}$):** These operators are diagonal in the chosen basis. Their eigenvalues in the specified units ($\\omega=1$) are $E_{\\mathrm{int}} = n + \\frac{1}{2}$ and $E_{\\mathrm{cm}} = N + \\frac{1}{2}$. Their matrix elements are:\n$$\n\\langle N', n' | H_{\\mathrm{int}} | N, n \\rangle = \\left(n + \\frac{1}{2}\\right) \\delta_{N'N} \\delta_{n'n}\n$$\n$$\n\\langle N', n' | (1+\\beta) H_{\\mathrm{cm}} | N, n \\rangle = (1+\\beta)\\left(N + \\frac{1}{2}\\right) \\delta_{N'N} \\delta_{n'n}\n$$\n\n- **Coupling Hamiltonian ($H_{\\mathrm{coup}}$):** The term $H_{\\mathrm{coup}} = \\alpha X x$ is off-diagonal. The matrix elements of the position operators $X$ and $x$ are given by:\n$$\n\\langle K' | \\hat{O} | K \\rangle = \\sqrt{\\frac{\\hbar}{2m_O\\omega}} \\left( \\sqrt{K+1} \\delta_{K', K+1} + \\sqrt{K} \\delta_{K', K-1} \\right)\n$$\nwhere $\\hat{O}$ is the position operator with associated mass $m_O$. For the CM operator $X$, the mass is $M=2$, and for the relative operator $x$, the mass is $\\mu=1/2$. In our units, this gives prefactors $x_{\\mathrm{cm}} = \\sqrt{1/(2 \\cdot 2 \\cdot 1)} = 1/2$ and $x_{\\mathrm{rel}} = \\sqrt{1/(2 \\cdot 1/2 \\cdot 1)} = 1$. The matrix element for the coupling term is:\n$$\n\\langle N', n' | H_{\\mathrm{coup}} | N, n \\rangle = \\alpha \\langle N' | X | N \\rangle \\langle n' | x | n \\rangle\n$$\nThis element is non-zero only when $N' = N \\pm 1$ and $n' = n \\pm 1$. The specific values are, for instance:\n$$\n\\langle N+1, n+1 | H_{\\mathrm{coup}} | N, n \\rangle = \\alpha \\left(\\frac{1}{2}\\sqrt{N+1}\\right) \\left(1\\cdot\\sqrt{n+1}\\right) = \\frac{\\alpha}{2}\\sqrt{(N+1)(n+1)}\n$$\nThe other non-zero elements connecting $|N,n\\rangle$ to $|N\\pm 1, n \\pm 1\\rangle$ are derived similarly. The total Hamiltonian matrix is the sum of these component matrices.\n\n**3. Calculation of Ground States and Observables**\n\nFor each isospin sector ($pp$, $pn$, $np$), the corresponding Hamiltonian matrix $H_{\\mathrm{sector}}$ is constructed using the sector-specific truncation $N_{\\mathrm{cm, sector}}^{\\max}$ and the common $N_{\\mathrm{rel}}^{\\max}$. The matrix is then numerically diagonalized to find its eigenvalues and eigenvectors. The ground state, $\\phi_{\\mathrm{sector}}$, is the eigenvector corresponding to the lowest eigenvalue.\n\n- **Center-of-Mass Contamination:** The degree of CM contamination in a state $\\phi_{\\mathrm{sector}} = \\sum_{N,n} c_{N,n} |N,n\\rangle$ is quantified by the expectation value $\\langle H_{\\mathrm{cm}} \\rangle_{\\mathrm{sector}}$. Since the $H_{\\mathrm{cm}}$ operator is diagonal in our basis, this calculation is straightforward:\n$$\n\\langle H_{\\mathrm{cm}} \\rangle_{\\mathrm{sector}} = \\langle \\phi_{\\mathrm{sector}} | H_{\\mathrm{cm}} | \\phi_{\\mathrm{sector}} \\rangle = \\sum_{N,n} |c_{N,n}|^2 \\left(N + \\frac{1}{2}\\right)\n$$\nThe problem requires the arithmetic mean across the three sectors, $\\overline{\\langle H_{\\mathrm{cm}} \\rangle} = \\frac{1}{3} \\sum_{\\mathrm{sector} \\in \\{pp,pn,np\\}} \\langle H_{\\mathrm{cm}} \\rangle_{\\mathrm{sector}}$. In the ideal, uncoupled case, the ground state is $|0,0\\rangle$, for which $\\langle H_{\\mathrm{cm}} \\rangle = 1/2$. Deviations from $1/2$ indicate contamination.\n\n- **Fermi Matrix Element ($M_F$):** The Fermi matrix element is given by $M_F = \\frac{1}{\\sqrt{2}} ( \\langle \\phi_{pp} | \\phi_{pn} \\rangle + \\langle \\phi_{pp} | \\phi_{np} \\rangle )$. A complication arises because the ground states $\\phi_{pp}$, $\\phi_{pn}$, and $\\phi_{np}$ may be computed in bases with different CM truncations ($N_{\\mathrm{cm, pp}}^{\\max}$, $N_{\\mathrm{cm, pn}}^{\\max}$, $N_{\\mathrm{cm, np}}^{\\max}$). To compute the required overlaps, these state vectors must first be embedded into a common, larger basis, or \"superspace.\" This superspace is defined by the maximum of the individual CM truncations, $N_{\\mathrm{cm}}^{\\sup} = \\max_{\\mathrm{sector}}\\{N_{\\mathrm{cm, sector}}^{\\max}\\}$, and the common relative truncation, $N_{\\mathrm{rel}}^{\\max}$. A state vector from a smaller basis is embedded by padding it with zeros for the basis states that exist in the superspace but not in the original, smaller space. After embedding, all state vectors have the same dimension, and their overlap can be computed as a simple vector dot product. In the ideal case where all states are simply $|0,0\\rangle$, the overlaps are both $1$, yielding $M_F = \\frac{1}{\\sqrt{2}}(1+1) = \\sqrt{2}$. Deviations from $\\sqrt{2}$ indicate a loss of isospin symmetry, often due to CM artifacts.\n\n**4. Computational Workflow**\n\nThe overall algorithm proceeds as follows for each of the five test cases:\n1.  Define the parameters for the case: $\\{N_{\\mathrm{cm},pp}^{\\max}, N_{\\mathrm{cm},pn}^{\\max}, N_{\\mathrm{cm},np}^{\\max}, N_{\\mathrm{rel}}^{\\max}, \\alpha, \\beta\\}$.\n2.  Determine the dimensions of the common superspace: $N_{\\mathrm{cm}}^{\\sup} = \\max(N_{\\mathrm{cm},pp}^{\\max}, N_{\\mathrm{cm},pn}^{\\max}, N_{\\mathrm{cm},np}^{\\max})$.\n3.  For each isospin sector ($pp$, $pn$, $np$):\n    a. Construct the Hamiltonian matrix $H_{\\mathrm{sector}}$ of size $(N_{\\mathrm{cm, sector}}^{\\max}+1)(N_{\\mathrm{rel}}^{\\max}+1) \\times (N_{\\mathrm{cm, sector}}^{\\max}+1)(N_{\\mathrm{rel}}^{\\max}+1)$ using the matrix elements derived above.\n    b. Diagonalize $H_{\\mathrm{sector}}$ to obtain the ground state eigenvector $\\phi_{\\mathrm{sector}}$ and its corresponding eigenvalue.\n    c. Calculate $\\langle H_{\\mathrm{cm}} \\rangle_{\\mathrm{sector}}$ using the components of $\\phi_{\\mathrm{sector}}$.\n    d. Embed $\\phi_{\\mathrm{sector}}$ into the superspace basis by zero-padding, yielding $\\phi_{\\mathrm{sector}}^{\\mathrm{sup}}$.\n4.  Compute the Fermi matrix element using the embedded vectors: $M_F = \\frac{1}{\\sqrt{2}} ( \\langle \\phi_{pp}^{\\mathrm{sup}} | \\phi_{pn}^{\\mathrm{sup}} \\rangle + \\langle \\phi_{pp}^{\\mathrm{sup}} | \\phi_{np}^{\\mathrm{sup}} \\rangle )$.\n5.  Compute the average CM energy: $\\overline{\\langle H_{\\mathrm{cm}} \\rangle} = \\frac{1}{3}(\\langle H_{\\mathrm{cm}} \\rangle_{pp} + \\langle H_{\\mathrm{cm}} \\rangle_{pn} + \\langle H_{\\mathrm{cm}} \\rangle_{np})$.\n6.  Store the pair of results $(M_F, \\overline{\\langle H_{\\mathrm{cm}} \\rangle})$ for the current test case.\nThis procedure is repeated for all test cases to generate the final list of results.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom numpy.linalg import eigh\n\ndef calculate_ground_state_properties(N_cm_max, N_rel_max, alpha, beta):\n    \"\"\"\n    Constructs and diagonalizes the Hamiltonian for a given sector.\n\n    Args:\n        N_cm_max (int): Maximum CM quantum number.\n        N_rel_max (int): Maximum relative quantum number.\n        alpha (float): Coupling strength.\n        beta (float): Lawson term parameter.\n\n    Returns:\n        tuple: A tuple containing:\n            - gs_vector (np.ndarray): The ground state eigenvector.\n            - h_cm_exp (float): The expectation value of H_cm in the ground state.\n    \"\"\"\n    dim_cm = N_cm_max + 1\n    dim_rel = N_rel_max + 1\n    dim = dim_cm * dim_rel\n    H = np.zeros((dim, dim))\n\n    # Define prefactors for position operators in specified units\n    x_cm = 0.5\n    x_rel = 1.0\n\n    # Build the Hamiltonian matrix\n    for N in range(dim_cm):\n        for n in range(dim_rel):\n            k = N * dim_rel + n\n\n            # Diagonal part: (1+beta)*H_cm + H_int\n            diag_val = (1.0 + beta) * (N + 0.5) + (n + 0.5)\n            H[k, k] = diag_val\n\n            # Off-diagonal part: alpha * X * x\n            if alpha != 0.0:\n                # Four possible connections: (N+/-1, n+/-1)\n                # Connection to (N+1, n+1)\n                if N + 1  dim_cm and n + 1  dim_rel:\n                    N_p, n_p = N + 1, n + 1\n                    k_p = N_p * dim_rel + n_p\n                    val = alpha * (x_cm * np.sqrt(N + 1)) * (x_rel * np.sqrt(n + 1))\n                    H[k, k_p] = val\n                    H[k_p, k] = val\n                \n                # Connection to (N+1, n-1)\n                if N + 1  dim_cm and n - 1 = 0:\n                    N_p, n_p = N + 1, n - 1\n                    k_p = N_p * dim_rel + n_p\n                    val = alpha * (x_cm * np.sqrt(N + 1)) * (x_rel * np.sqrt(n))\n                    H[k, k_p] = val\n                    H[k_p, k] = val\n\n                # Connection to (N-1, n+1) - handled implicitly by symmetric filling\n                # Connection to (N-1, n-1) - handled implicitly by symmetric filling\n\n    # Diagonalize the Hermitian matrix\n    eigenvalues, eigenvectors = eigh(H)\n    \n    # Ground state is the eigenvector for the lowest eigenvalue\n    gs_vector = eigenvectors[:, 0]\n    \n    # Calculate expectation value of H_cm\n    h_cm_exp = 0.0\n    for N in range(dim_cm):\n        for n in range(dim_rel):\n            k = N * dim_rel + n\n            coeff_sq = gs_vector[k]**2\n            h_cm_exp += coeff_sq * (N + 0.5)\n            \n    return gs_vector, h_cm_exp\n\ndef solve():\n    \"\"\"\n    Main solver function that iterates through test cases and computes the required observables.\n    \"\"\"\n    test_cases = [\n        # (N_cm_pp_max, N_cm_pn_max, N_cm_np_max, N_rel_max, alpha, beta)\n        (3, 3, 3, 6, 0.0, 0.0),  # Case 1\n        (1, 1, 2, 6, 0.2, 0.0),  # Case 2\n        (0, 0, 0, 6, 0.2, 0.0),  # Case 3\n        (3, 3, 3, 6, 0.2, 5.0),  # Case 4\n        (1, 2, 3, 6, 0.5, 0.0),  # Case 5\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N_cm_pp_max, N_cm_pn_max, N_cm_np_max, N_rel_max, alpha, beta = case\n        \n        # Determine superspace dimensions\n        N_cm_sup = max(N_cm_pp_max, N_cm_pn_max, N_cm_np_max)\n        dim_rel_common = N_rel_max + 1\n        dim_sup = (N_cm_sup + 1) * dim_rel_common\n        \n        sector_params = {\n            'pp': N_cm_pp_max,\n            'pn': N_cm_pn_max,\n            'np': N_cm_np_max\n        }\n        \n        ground_states = {}\n        h_cm_expectations = {}\n        \n        for sector, N_cm_max in sector_params.items():\n            gs_vec, h_cm_exp = calculate_ground_state_properties(N_cm_max, N_rel_max, alpha, beta)\n            h_cm_expectations[sector] = h_cm_exp\n            \n            # Embed the ground state vector into the superspace\n            gs_sup = np.zeros(dim_sup)\n            dim_sec_cm = N_cm_max + 1\n            for N in range(dim_sec_cm):\n                start_idx_sec = N * dim_rel_common\n                end_idx_sec = start_idx_sec + dim_rel_common\n                \n                start_idx_sup = N * dim_rel_common\n                end_idx_sup = start_idx_sup + dim_rel_common\n                \n                gs_sup[start_idx_sup:end_idx_sup] = gs_vec[start_idx_sec:end_idx_sec]\n            \n            ground_states[sector] = gs_sup\n\n        # Calculate Fermi Matrix Element M_F\n        overlap_pp_pn = np.dot(ground_states['pp'], ground_states['pn'])\n        overlap_pp_np = np.dot(ground_states['pp'], ground_states['np'])\n        M_F = (1.0 / np.sqrt(2.0)) * (overlap_pp_pn + overlap_pp_np)\n        \n        # Calculate average H_cm expectation value\n        avg_h_cm = np.mean(list(h_cm_expectations.values()))\n\n        results.extend([M_F, avg_h_cm])\n\n    # Format the final output string as specified\n    output_str = f\"[{','.join(f'{x:.8f}' for x in results)}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3546717"}, {"introduction": "For most nuclei of interest, the dimension of the Hamiltonian matrix is far too large to permit full diagonalization. The Lanczos algorithm is a workhorse of computational nuclear physics that brilliantly circumvents this issue by finding properties of the system in a small, tailored subspace. This exercise [@problem_id:3546731] guides you through an implementation of the Lanczos strength-function method, allowing you to compute key characteristics of the Fermi transition strength distribution, such as its centroid and width, and to connect this powerful numerical tool to the fundamental physics of the model-independent Fermi sum rule.", "problem": "You are to implement a complete numerical procedure to compute Fermi transition strength moments using the Lanczos strength-function method in a simplified, computationally tractable model, and to test a model-independent sum rule. The physical observable of interest is the Fermi strength function for charge-exchange transitions from a nuclear many-body ground state under the action of the Fermi operator, and its energy-weighted moments. Your task is to work in a finite-dimensional basis in which the excitation subspace is represented by orthonormal basis states labeled by single-particle energy differences, and to use a Lanczos tridiagonalization to approximate the strength distribution and its low-order moments. All energies must be treated and reported in mega-electron volts (MeV).\n\nFundamental base:\n- The Fermi operator for charge-exchange transitions can be written as $F_{-} = \\sum_{i=1}^{A} \\tau_{i}^{-}$, where $A$ is the nucleon number and $\\tau_{i}^{-}$ is the isospin-lowering operator acting on nucleon $i$. In an independent-particle description that restricts to neutron-to-proton transitions, the action of $F_{-}$ on the ground state $|0\\rangle$ produces a superposition of one-particle-one-hole excitations with amplitudes determined by occupancy, which we encode as a nonnegative weight for each accessible excitation.\n- The non-energy-weighted sum rule for Fermi transitions in this restricted channel is given by the norm squared of $F_{-}|0\\rangle$, which equals the neutron excess $N - Z$ when no proton-to-neutron transitions are allowed in the model space, where $N$ is the neutron number and $Z$ is the proton number. In our discrete computational model, this norm is computed as the sum of nonnegative integer weights associated with each accessible transition.\n- The strength function for an operator $F$ is $S(\\omega) = \\sum_{n} \\left|\\langle n|F|0\\rangle\\right|^{2} \\delta\\!\\left(\\omega - (E_{n}-E_{0})\\right)$, where $\\{|n\\rangle\\}$ is a complete set of excited eigenstates of the Hamiltonian $H$ with excitation energies $E_{n}-E_{0} \\ge 0$. Its moments are $m_{k} = \\int \\omega^{k} S(\\omega)\\, d\\omega$. In a finite-dimensional representation with discrete excitation energies, these moments reduce to finite sums.\n- The Lanczos strength-function method constructs an orthonormal basis via Lanczos tridiagonalization of the Hamiltonian $H$ starting from the normalized pivot vector $|v_{0}\\rangle = \\frac{F|0\\rangle}{\\|F|0\\rangle\\|}$, yielding a symmetric tridiagonal matrix $T_{L}$ of dimension $L \\times L$ after $L$ iterations (or fewer if convergence is reached sooner). The eigenvalues and the first components of the normalized eigenvectors of $T_{L}$ define a Gaussian quadrature approximation to the spectral distribution associated with $H$ and $|v_{0}\\rangle$, which provides approximations to the energy-weighted moments $m_{k}$.\n\nComputational setup:\n- Represent the excitation Hamiltonian in the restricted transition subspace by a diagonal matrix $H = \\mathrm{diag}(\\Delta_{1}, \\Delta_{2}, \\ldots, \\Delta_{K})$, where $\\Delta_{j} \\ge 0$ are excitation energies in MeV. The vector $|b\\rangle \\equiv F_{-}|0\\rangle$ is represented in the same basis by its components $b_{j} = \\sqrt{w_{j}}$, where $w_{j} \\in \\mathbb{N}_{0}$ are nonnegative integer weights that encode how many indistinguishable neutron-to-proton transitions contribute at energy $\\Delta_{j}$. The non-energy-weighted sum (zeroth moment) is $m_{0} = \\langle b|b\\rangle = \\sum_{j=1}^{K} w_{j}$.\n- Perform $L$ iterations of Lanczos tridiagonalization starting from $|v_{0}\\rangle = \\frac{|b\\rangle}{\\sqrt{m_{0}}}$ when $m_{0}  0$; if $m_{0} = 0$, skip Lanczos and define the centroid and width to be zero as specified below. Form the tridiagonal matrix $T_{L}$ with diagonal elements $\\alpha_{\\ell}$ and off-diagonal elements $\\beta_{\\ell}$ for $\\ell = 0, 1, \\ldots$, in the usual three-term recurrence, with early termination if a new Lanczos vector has norm below a small threshold. Use the eigenvalues and the first components of the normalized eigenvectors of $T_{L}$ to construct a Gaussian quadrature approximation that yields approximations to the first two energy-weighted moments $m_{1}$ and $m_{2}$, and therefore the centroid and width of the strength distribution.\n- Define the centroid as $E_{\\mathrm{c}} = \\frac{m_{1}}{m_{0}}$ (in MeV) and the standard deviation (width) as $\\sigma = \\sqrt{\\frac{m_{2}}{m_{0}} - \\left(\\frac{m_{1}}{m_{0}}\\right)^{2}}$ (in MeV) when $m_{0}  0$. When $m_{0} = 0$, set $E_{\\mathrm{c}} = 0$ and $\\sigma = 0$ by convention.\n\nTasks:\n- For each test case below, construct $H$ and $|b\\rangle$ from the provided $\\{\\Delta_{j}\\}$ and $\\{w_{j}\\}$, compute the exact zeroth moment $m_{0} = \\sum_{j=1}^{K} w_{j}$, and verify the restricted-channel Fermi sum rule $m_{0} = N - Z$ within a numerical tolerance of $|\\cdot|  10^{-12}$. Then, using $L$ Lanczos iterations as specified for the case, compute the centroid $E_{\\mathrm{c}}$ and width $\\sigma$ in MeV using the Gaussian quadrature implied by the Lanczos tridiagonalization. If $m_{0} = 0$, set both $E_{\\mathrm{c}}$ and $\\sigma$ to zero without running Lanczos.\n- All energies must be expressed in mega-electron volts (MeV). The final outputs for $E_{\\mathrm{c}}$ and $\\sigma$ must be real-valued floating-point numbers in MeV.\n\nTest suite:\nProvide results for the following parameter sets. For each case, numbers are given in their natural units, with energies in MeV.\n- Case 1: $\\Delta = [1.0, 3.0, 7.0]$, $w = [1, 1, 1]$, $N = 7, Z = 4, L = 3$.\n- Case 2: $\\Delta = [2.0, 5.0]$, $w = [1, 1]$, $N = 8, Z = 6, L = 2$.\n- Case 3: $\\Delta = [10.0]$, $w = [4]$, $N = 12, Z = 8, L = 5$.\n- Case 4: $\\Delta = [1.0, 2.0]$, $w = [0, 0]$, $N = 5, Z = 5, L = 2$.\n- Case 5: $\\Delta = [1.0, 4.0, 9.0, 16.0]$, $w = [2, 1, 3, 2]$, $N = 13, Z = 5, L = 1$.\n\nRequired final output format:\n- Your program must produce a single line of output containing a list of per-case results, each result itself being a list of three entries: the first is a boolean indicating whether the equality $m_{0} = N - Z$ holds within the stated tolerance, the second is the centroid $E_{\\mathrm{c}}$ in MeV as a floating-point number, and the third is the width $\\sigma$ in MeV as a floating-point number. The line should be a comma-separated list enclosed in square brackets, for example, $[\\,\\mathrm{case}_{1},\\mathrm{case}_{2},\\ldots\\,]$, where each $\\mathrm{case}_{i}$ is of the form $[\\,\\mathrm{boolean}, E_{\\mathrm{c}}, \\sigma\\,]$.", "solution": "We begin with the Fermi charge-exchange operator $F_{-} = \\sum_{i=1}^{A} \\tau_{i}^{-}$ acting on the nuclear ground state $|0\\rangle$. In an independent-particle picture restricted to neutron-to-proton ($n \\rightarrow p$) transitions within a given model space, the action of $F_{-}$ produces a coherent superposition of one-particle-one-hole excitations. The associated strength function is $S(\\omega) = \\sum_{n} \\left|\\langle n|F_{-}|0\\rangle\\right|^{2} \\delta\\!\\left(\\omega - (E_{n}-E_{0})\\right)$, with energy moments $m_{k} = \\int \\omega^{k} S(\\omega)\\, d\\omega$. The zeroth moment $m_{0}$ is the norm squared of $F_{-}|0\\rangle$, $m_{0} = \\langle 0|F_{+} F_{-}|0\\rangle$, which, under the stated restriction of no $p \\rightarrow n$ transitions, equals the neutron excess $N - Z$ as a well-known model-independent Fermi sum rule.\n\nTo pass from a general many-body treatment to a computationally manageable representation, we encode the strength distribution in an orthonormal basis $\\{|j\\rangle\\}_{j=1}^{K}$ of accessible excitations where the Hamiltonian $H$ is diagonal, $H = \\mathrm{diag}(\\Delta_{1}, \\ldots, \\Delta_{K})$, with $\\Delta_{j} \\ge 0$ the excitation energies in mega-electron volts (MeV). The vector $|b\\rangle \\equiv F_{-}|0\\rangle$ has components $b_{j} = \\sqrt{w_{j}}$ with nonnegative integer weights $w_{j} \\in \\mathbb{N}_{0}$. In this representation, the strength function is $S(\\omega) = \\sum_{j=1}^{K} w_{j} \\, \\delta(\\omega - \\Delta_{j})$, and the low-order moments are finite sums: $m_{0} = \\sum_{j=1}^{K} w_{j}$, $m_{1} = \\sum_{j=1}^{K} w_{j} \\Delta_{j}$, and $m_{2} = \\sum_{j=1}^{K} w_{j} \\Delta_{j}^{2}$. The centroid and width are defined by $E_{\\mathrm{c}} = \\frac{m_{1}}{m_{0}}$ and $\\sigma = \\sqrt{\\frac{m_{2}}{m_{0}} - \\left(\\frac{m_{1}}{m_{0}}\\right)^{2}}$ when $m_{0}  0$, and by convention $E_{\\mathrm{c}} = 0$ and $\\sigma = 0$ when $m_{0} = 0$.\n\nThe Lanczos strength-function method provides an efficient way to approximate the spectral distribution associated with $(H, |b\\rangle)$ without diagonalizing the full Hamiltonian. One constructs the normalized pivot vector $|v_{0}\\rangle = \\frac{|b\\rangle}{\\|b\\|}$ with $\\|b\\| = \\sqrt{m_{0}}$, and applies the three-term Lanczos recurrence\n$|w_{\\ell}\\rangle = H|v_{\\ell}\\rangle - \\beta_{\\ell} |v_{\\ell-1}\\rangle$, $\\alpha_{\\ell} = \\langle v_{\\ell}|w_{\\ell}\\rangle$, $|w_{\\ell}\\rangle \\leftarrow |w_{\\ell}\\rangle - \\alpha_{\\ell} |v_{\\ell}\\rangle$, $\\beta_{\\ell+1} = \\|\\,|w_{\\ell}\\rangle\\,\\|$, and $|v_{\\ell+1}\\rangle = \\frac{|w_{\\ell}\\rangle}{\\beta_{\\ell+1}}$,\nwith initialization $|v_{-1}\\rangle \\equiv 0$, $\\beta_{0} \\equiv 0$. After $L$ iterations (or earlier if $\\beta_{\\ell+1}$ vanishes within a small tolerance), one obtains a symmetric tridiagonal matrix $T_{L}$ with diagonal entries $\\alpha_{0}, \\ldots, \\alpha_{L-1}$ and off-diagonal entries $\\beta_{1}, \\ldots, \\beta_{L-1}$. The spectral theorem ensures that the pair $(H, |v_{0}\\rangle)$ induces a positive measure on the real line (the spectral measure of $H$ with respect to $|v_{0}\\rangle$). Gaussian quadrature theory then states that the eigenvalues $\\{\\lambda_{j}\\}_{j=1}^{L}$ of $T_{L}$, together with the squared first components $\\{w_{j}^{(\\mathrm{GQ})}\\}_{j=1}^{L}$ of the normalized eigenvectors of $T_{L}$, define a quadrature rule that is exact for the first $2L$ moments of the spectral measure in the ideal arithmetic and exact Krylov subspace setting. Consequently, approximate moments follow as $m_{k} \\approx m_{0} \\sum_{j=1}^{L} w_{j}^{(\\mathrm{GQ})} \\lambda_{j}^{k}$ for $k = 1, 2$, from which the centroid and width are obtained.\n\nAlgorithmic design:\n- Input: the lists of excitation energies $\\{\\Delta_{j}\\}_{j=1}^{K}$ in MeV, weights $\\{w_{j}\\}_{j=1}^{K}$, the pair $(N, Z)$, and the Lanczos iteration count $L$.\n- Compute $m_{0} = \\sum_{j=1}^{K} w_{j}$ and verify the Fermi sum rule by checking $|m_{0} - (N - Z)|  10^{-12}$, a tight tolerance that is suitable since our $m_{0}$ is evaluated exactly from integer weights.\n- If $m_{0} = 0$, return $(\\mathrm{True}, 0.0, 0.0)$ because the restricted-channel sum rule holds trivially and the strength distribution is empty.\n- Else, form the normalized pivot $|v_{0}\\rangle = \\frac{|b\\rangle}{\\sqrt{m_{0}}}$ with $b_{j} = \\sqrt{w_{j}}$, and perform up to $L$ Lanczos iterations, with early termination if a new Lanczos vector norm falls below a small threshold (e.g., $10^{-14}$). In our diagonal-$H$ representation, matrix-vector products are $H|x\\rangle$ with $(H x)_{j} = \\Delta_{j} x_{j}$.\n- Assemble the tridiagonal matrix $T_{L}$ and solve its symmetric eigenproblem to obtain $\\{\\lambda_{j}\\}$ and $\\{u_{j}\\}$, where $u_{j}$ is the $j$-th normalized eigenvector. The Gaussian quadrature weights are $w_{j}^{(\\mathrm{GQ})} = \\left(u_{j}\\right)_{1}^{2}$, where $\\left(u_{j}\\right)_{1}$ denotes the first component of $u_{j}$ in the Lanczos basis. Compute $m_{1} \\approx m_{0} \\sum_{j} w_{j}^{(\\mathrm{GQ})} \\lambda_{j}$ and $m_{2} \\approx m_{0} \\sum_{j} w_{j}^{(\\mathrm{GQ})} \\lambda_{j}^{2}$, then compute $E_{\\mathrm{c}}$ and $\\sigma$ as above. Notably, for $L = 1$, the centroid $E_{\\mathrm{c}}$ is already exact because $\\alpha_{0} = \\langle v_{0}|H|v_{0}\\rangle = \\frac{\\langle b|H|b\\rangle}{\\langle b|b\\rangle} = \\frac{m_{1}}{m_{0}}$, while the width is generally underestimated.\n- Numerical stability: we include full reorthogonalization of the new Lanczos vector against all previous Lanczos vectors to mitigate loss of orthogonality in finite precision, although in our diagonal representation the three-term recurrence is typically sufficient.\n\nApplication to the test suite:\n- Case $1$ with $\\Delta = [\\,1.0, 3.0, 7.0\\,]$, $w = [\\,1, 1, 1\\,]$, $N - Z = 3$, and $L = 3$ yields exact centroid and width because the Krylov subspace spans the full space; the outputs are the boolean $\\mathrm{True}$, the centroid in MeV, and the width in MeV.\n- Case $2$ with $\\Delta = [\\,2.0, 5.0\\,]$, $w = [\\,1, 1\\,]$, $N - Z = 2$, and $L = 2$ also spans the full space; exact centroid and width follow.\n- Case $3$ with $\\Delta = [\\,10.0\\,]$, $w = [\\,4\\,]$, $N - Z = 4$, and $L = 5$ truncates to one dimension immediately; the centroid is $10.0$ MeV and the width is $0.0$ MeV.\n- Case $4$ with $\\Delta = [\\,1.0, 2.0\\,]$, $w = [\\,0, 0\\,]$, $N - Z = 0$, has no strength; by convention, the centroid and width are both $0.0$ MeV, and the sum-rule check is $\\mathrm{True}$.\n- Case $5$ with $\\Delta = [\\,1.0, 4.0, 9.0, 16.0\\,]$, $w = [\\,2, 1, 3, 2\\,]$, $N - Z = 8$, and $L = 1$ demonstrates that with a single Lanczos iteration the centroid is exact while the width collapses to $0.0$ MeV, illustrating the Gaussian quadrature truncation effect.\n\nThe program implements these steps and prints a single line containing a list of per-case results $[\\,\\mathrm{boolean}, E_{\\mathrm{c}}, \\sigma\\,]$, where $E_{\\mathrm{c}}$ and $\\sigma$ are in mega-electron volts (MeV).", "answer": "```python\nimport numpy as np\n\ndef lanczos_tridiagonal(diag_energies, v0, max_iters, tol=1e-14, reorth=True):\n    \"\"\"\n    Perform Lanczos tridiagonalization for a diagonal Hamiltonian H=diag(diag_energies).\n    Args:\n        diag_energies: numpy array of shape (K,), energies Δ_j (MeV).\n        v0: initial normalized vector of shape (K,).\n        max_iters: maximum Lanczos iterations L.\n        tol: threshold for early termination if beta becomes too small.\n        reorth: if True, perform full reorthogonalization against previous vectors.\n    Returns:\n        alphas: list of diagonal entries of T\n        betas: list of off-diagonal entries of T (length len(alphas)-1)\n        V: list of Lanczos vectors (each numpy array)\n    \"\"\"\n    K = diag_energies.shape[0]\n    assert v0.shape == (K,)\n    # Normalize v0 just in case\n    nrm = np.linalg.norm(v0)\n    if nrm == 0.0:\n        return [], [], []\n    v0 = v0 / nrm\n\n    V = []\n    alphas = []\n    betas = []\n\n    v_prev = np.zeros_like(v0)\n    v = v0.copy()\n\n    for it in range(max_iters):\n        # w = H v\n        w = diag_energies * v\n        alpha = float(np.dot(v, w))\n        w = w - alpha * v\n        if it  0:\n            w = w - betas[-1] * v_prev\n\n        if reorth and len(V)  0:\n            # Full reorthogonalization against all previous Lanczos vectors\n            for vk in V:\n                coeff = float(np.dot(vk, w))\n                w -= coeff * vk\n\n        beta = float(np.linalg.norm(w))\n        V.append(v.copy())\n        alphas.append(alpha)\n        if beta  tol:\n            break\n        betas.append(beta)\n        v_prev = v\n        v = w / beta\n\n    return alphas, betas, V\n\ndef gauss_quadrature_moments_from_tridiagonal(alphas, betas, m0):\n    \"\"\"\n    Given tridiagonal parameters, compute approximate moments m1 and m2 using Gauss quadrature.\n    Args:\n        alphas: list of diagonal entries of T\n        betas: list of off-diagonal entries of T\n        m0: zeroth moment (norm squared of b)\n    Returns:\n        m1_approx, m2_approx\n    \"\"\"\n    n = len(alphas)\n    if n == 0 or m0 == 0.0:\n        return 0.0, 0.0\n    # Build symmetric tridiagonal T\n    T = np.zeros((n, n), dtype=float)\n    for i in range(n):\n        T[i, i] = alphas[i]\n    for i in range(n - 1):\n        T[i, i + 1] = betas[i]\n        T[i + 1, i] = betas[i]\n    # Eigen-decomposition\n    evals, evecs = np.linalg.eigh(T)\n    # Weights are squares of first row components of eigenvectors (component index 0)\n    weights = (evecs[0, :] ** 2).astype(float)\n    # Approximate moments\n    m1 = m0 * float(np.dot(weights, evals))\n    m2 = m0 * float(np.dot(weights, evals**2))\n    return m1, m2\n\ndef compute_case(energies, weights, N, Z, L):\n    \"\"\"\n    Compute sum-rule verification, centroid, and width for one case.\n    Args:\n        energies: list or array of Δ_j (MeV)\n        weights: list or array of w_j (nonnegative integers)\n        N, Z: neutron and proton numbers (integers)\n        L: number of Lanczos iterations (integer)\n    Returns:\n        (bool_sumrule_ok, centroid_MeV, width_MeV)\n    \"\"\"\n    energies = np.array(energies, dtype=float)\n    weights = np.array(weights, dtype=float)\n    # Build b vector with components sqrt(w_j)\n    b = np.sqrt(weights)\n    m0 = float(np.dot(b, b))  # sum of weights\n    sumrule_target = float(N - Z)\n    sumrule_ok = abs(m0 - sumrule_target)  1e-12\n\n    if m0 == 0.0:\n        # No strength in the restricted channel\n        return [sumrule_ok, 0.0, 0.0]\n\n    # Normalized pivot\n    v0 = b / np.sqrt(m0)\n    # Lanczos\n    alphas, betas, _ = lanczos_tridiagonal(energies, v0, max_iters=int(L), tol=1e-14, reorth=True)\n    # If no steps returned (should not happen with m00), fall back to exact moments\n    if len(alphas) == 0:\n        m1 = float(np.dot(weights, energies))\n        m2 = float(np.dot(weights, energies**2))\n    else:\n        m1, m2 = gauss_quadrature_moments_from_tridiagonal(alphas, betas, m0)\n\n    # Centroid and width\n    centroid = m1 / m0\n    variance = m2 / m0 - centroid**2\n    # Numerical safeguard for tiny negative due to roundoff\n    if variance  0 and variance  -1e-12:\n        variance = 0.0\n    width = float(np.sqrt(variance)) if variance = 0 else float('nan')\n\n    return [sumrule_ok, float(centroid), float(width)]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (energies Δ_j in MeV, weights w_j, N, Z, L)\n    test_cases = [\n        ([1.0, 3.0, 7.0], [1, 1, 1], 7, 4, 3),\n        ([2.0, 5.0], [1, 1], 8, 6, 2),\n        ([10.0], [4], 12, 8, 5),\n        ([1.0, 2.0], [0, 0], 5, 5, 2),\n        ([1.0, 4.0, 9.0, 16.0], [2, 1, 3, 2], 13, 5, 1),\n    ]\n\n    results = []\n    for energies, weights, N, Z, L in test_cases:\n        result = compute_case(energies, weights, N, Z, L)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3546731"}]}