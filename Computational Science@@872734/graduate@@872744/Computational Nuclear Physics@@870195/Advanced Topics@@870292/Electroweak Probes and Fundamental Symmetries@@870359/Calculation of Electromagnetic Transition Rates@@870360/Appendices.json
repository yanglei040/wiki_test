{"hands_on_practices": [{"introduction": "The nuclear shell model provides a powerful framework for understanding nuclear structure, where electromagnetic transitions are described by matrix elements of multipole operators between nuclear states. At the heart of these calculations lies the ability to evaluate single-particle matrix elements, which serve as the fundamental building blocks. This practice [@problem_id:3545957] will guide you through a first-principles derivation of a reduced single-particle matrix element, providing essential hands-on experience with the quantum theory of angular momentum, including the Wigner-Eckart theorem and recoupling techniques using Wigner $3j$ and $6j$ symbols.", "problem": "Consider a single nucleon moving in a spherically symmetric mean-field potential, so that the single-particle eigenstates can be written as $\\lvert n \\, l \\, j \\, m_j \\rangle$ with orbital angular momentum $l$, intrinsic spin $s = \\tfrac{1}{2}$, total angular momentum $j$, and magnetic projection $m_j$. Let the spatial wave function separate into a radial part $R_{n l}(r)$ and an angular-spin part constructed by coupling $l$ and $s$ to $j$. Define the one-body spherical tensor operator of rank $\\lambda$ acting only in coordinate space by $T^{(\\lambda)}_{\\mu} = r^{\\lambda} Y_{\\lambda \\mu}(\\Omega)$, where $Y_{\\lambda \\mu}(\\Omega)$ are the Condon–Shortley spherical harmonics normalized by $\\int \\lvert Y_{\\lambda \\mu}(\\Omega) \\rvert^{2} \\, d\\Omega = 1$. Using only standard angular momentum coupling theory grounded in the Wigner–Eckart theorem and the recoupling of orbital and spin angular momenta via Wigner $6j$ symbols, derive from first principles the closed-form analytic expression for the reduced single-particle matrix element $\\langle n_b \\, l_b \\, j_b \\lVert r^{\\lambda} Y_{\\lambda} \\rVert n_a \\, l_a \\, j_a \\rangle$ in the $jj$-coupling scheme. Your final expression must be written in terms of:\n- a radial integral $R^{(\\lambda)}_{ba} \\equiv \\int_{0}^{\\infty} dr \\, r^{2} \\, R_{n_b l_b}(r) \\, r^{\\lambda} \\, R_{n_a l_a}(r)$,\n- one Wigner $3j$ symbol,\n- one Wigner $6j$ symbol,\n- and explicit dependence on $l_a$, $l_b$, $j_a$, $j_b$, and $\\lambda$.\nDefine any shorthand you introduce (for example, $\\hat{j} \\equiv \\sqrt{2j+1}$). Present the final result as a single closed-form analytic expression. Do not compute any numerical values.", "solution": "The problem statement is a standard exercise in the quantum theory of angular momentum, specifically within the context of the nuclear shell model. It requires the derivation of a reduced single-particle matrix element for an electromagnetic-type operator.\n\nThe objective is to derive the analytic expression for the reduced matrix element $\\langle n_b \\, l_b \\, j_b \\lVert T^{(\\lambda)} \\rVert n_a \\, l_a \\, j_a \\rangle$, where the single-particle operator is $T^{(\\lambda)}_{\\mu} = r^{\\lambda} Y_{\\lambda \\mu}(\\Omega)$. The single-particle states $|n \\, l \\, j \\, m_j \\rangle$ are eigenstates in a $jj$-coupling scheme.\n\nFirst, we define the shorthand notation $\\hat{j} \\equiv \\sqrt{2j+1}$ for any angular momentum $j$.\n\nThe single-particle wave function has a separable form, consisting of a radial part and an angular-spin part:\n$$\n\\Psi_{nljm_j}(\\mathbf{r}) = \\langle \\mathbf{r} | n \\, l \\, j \\, m_j \\rangle = R_{nl}(r) \\langle \\Omega, \\sigma | (ls)j m_j \\rangle\n$$\nHere, $R_{nl}(r)$ is the radial wave function and $|(ls)j m_j\\rangle$ is the coupled angular-spin state. The operator $T^{(\\lambda)}_{\\mu} = r^{\\lambda} Y_{\\lambda \\mu}(\\Omega)$ is a product of a purely radial part, $r^{\\lambda}$, and a purely angular part, $Y_{\\lambda \\mu}(\\Omega)$. Since $r^{\\lambda}$ is a scalar with respect to rotations, it does not affect the tensor properties of the operator. The matrix element can thus be factored into a radial integral and a reduced matrix element of the angular-spin part.\n\n$$\n\\langle n_b \\, l_b \\, j_b \\lVert r^{\\lambda} Y_{\\lambda} \\rVert n_a \\, l_a \\, j_a \\rangle = \\left( \\int_{0}^{\\infty} dr \\, r^{2} \\, R_{n_b l_b}(r) \\, r^{\\lambda} \\, R_{n_a l_a}(r) \\right) \\langle (l_b s) j_b \\lVert Y_{\\lambda} \\rVert (l_a s) j_a \\rangle\n$$\nThe radial integral corresponds precisely to the definition of $R^{(\\lambda)}_{ba}$ given in the problem statement. The task reduces to calculating the reduced matrix element of $Y_{\\lambda}$ in the coupled basis, $\\langle (l_b s) j_b \\lVert Y_{\\lambda} \\rVert (l_a s) j_a \\rangle$.\n\nThe operator $Y_{\\lambda}$ acts only on the orbital part (subspace 1) of the coupled state $|(ls)j\\rangle$ and is a scalar operator (identity) with respect to the spin part (subspace 2). For such an operator, a standard formula from angular momentum recoupling theory gives the reduced matrix element in the coupled basis in terms of the reduced matrix element in the uncoupled basis. The formula is:\n$$\n\\langle (j_1 j_2)J \\lVert F^{(k)} \\rVert (j'_1 j'_2)J' \\rangle = \\delta_{j_2 j'_2} (-1)^{j_1+j_2+J'+k} \\hat{J} \\hat{J'} \\begin{Bmatrix} J & k & J' \\\\ j'_1 & j_1 & j_2 \\end{Bmatrix} \\langle j_1 \\lVert F^{(k)} \\rVert j'_1 \\rangle\n$$\nWe make the following identifications:\n_Subspace 1 (orbital):_ $j_1 \\to l_b$, $j'_1 \\to l_a$.\n_Subspace 2 (spin):_ $j_2 \\to s$, $j'_2 \\to s$.\n_Coupled states:_ $J \\to j_b$, $J' \\to j_a$.\n_Operator:_ $F^{(k)} \\to Y_{\\lambda}$, so $k \\to \\lambda$.\n\nThe condition $\\delta_{s,s}=1$ is met. Substituting these into the formula, we obtain:\n$$\n\\langle (l_b s) j_b \\lVert Y_{\\lambda} \\rVert (l_a s) j_a \\rangle = (-1)^{l_b+s+j_a+\\lambda} \\hat{j_b} \\hat{j_a} \\begin{Bmatrix} j_b & \\lambda & j_a \\\\ l_a & l_b & s \\end{Bmatrix} \\langle l_b \\lVert Y_{\\lambda} \\rVert l_a \\rangle\n$$\nThe next step is to find an explicit expression for the reduced matrix element of the spherical harmonic in the orbital basis, $\\langle l_b \\lVert Y_{\\lambda} \\rVert l_a \\rangle$. We can derive this using the Wigner-Eckart theorem and the known formula for the integral of three spherical harmonics (the Gaunt integral).\n\nThe Wigner-Eckart theorem states:\n$$\n\\langle l_b m_{l_b} | Y_{\\lambda \\mu} | l_a m_{l_a} \\rangle = (-1)^{l_b-m_{l_b}} \\begin{pmatrix} l_b & \\lambda & l_a \\\\ -m_{l_b} & \\mu & m_{l_a} \\end{pmatrix} \\langle l_b \\lVert Y_{\\lambda} \\rVert l_a \\rangle\n$$\nThe matrix element on the left is also given by the Gaunt integral:\n$$\n\\langle l_b m_{l_b} | Y_{\\lambda \\mu} | l_a m_{l_a} \\rangle = \\int d\\Omega \\, Y_{l_b m_{l_b}}^*(\\Omega) Y_{\\lambda \\mu}(\\Omega) Y_{l_a m_{l_a}}(\\Omega)\n$$\nUsing the Condon-Shortley phase convention, $Y_{lm}^* = (-1)^m Y_{l,-m}$, this becomes:\n$$\n(-1)^{m_{l_b}} \\int d\\Omega \\, Y_{l_b, -m_{l_b}}(\\Omega) Y_{\\lambda \\mu}(\\Omega) Y_{l_a m_{l_a}}(\\Omega)\n$$\nThe integral of three spherical harmonics is given by:\n$$\n\\int Y_{j_1 m_1} Y_{j_2 m_2} Y_{j_3 m_3} d\\Omega = \\sqrt{\\frac{\\hat{j_1}^2 \\hat{j_2}^2 \\hat{j_3}^2}{4\\pi}} \\begin{pmatrix} j_1 & j_2 & j_3 \\\\ 0 & 0 & 0 \\end{pmatrix} \\begin{pmatrix} j_1 & j_2 & j_3 \\\\ m_1 & m_2 & m_3 \\end{pmatrix}\n$$\nApplying this to our integral yields:\n$$\n\\langle l_b m_{l_b} | Y_{\\lambda \\mu} | l_a m_{l_a} \\rangle = (-1)^{m_{l_b}} \\sqrt{\\frac{\\hat{l_b}^2 \\hat{\\lambda}^2 \\hat{l_a}^2}{4\\pi}} \\begin{pmatrix} l_b & \\lambda & l_a \\\\ 0 & 0 & 0 \\end{pmatrix} \\begin{pmatrix} l_b & \\lambda & l_a \\\\ -m_{l_b} & \\mu & m_{l_a} \\end{pmatrix}\n$$\nBy comparing this result with the Wigner-Eckart theorem expression, we can extract the reduced matrix element:\n$$\n\\langle l_b \\lVert Y_{\\lambda} \\rVert l_a \\rangle = (-1)^{l_b} \\hat{l_a}\\hat{l_b}\\hat{\\lambda} \\sqrt{\\frac{1}{4\\pi}} \\begin{pmatrix} l_b & \\lambda & l_a \\\\ 0 & 0 & 0 \\end{pmatrix}\n$$\nNow we assemble all the components. The full reduced matrix element is:\n$$\n\\langle n_b l_b j_b \\lVert r^{\\lambda} Y_{\\lambda} \\rVert n_a l_a j_a \\rangle = R_{ba}^{(\\lambda)} \\times \\left( (-1)^{l_b+s+j_a+\\lambda} \\hat{j_b} \\hat{j_a} \\begin{Bmatrix} j_b & \\lambda & j_a \\\\ l_a & l_b & s \\end{Bmatrix} \\langle l_b \\lVert Y_{\\lambda} \\rVert l_a \\rangle \\right)\n$$\nSubstituting the expression for $\\langle l_b \\lVert Y_{\\lambda} \\rVert l_a \\rangle$:\n$$\n= R_{ba}^{(\\lambda)} (-1)^{l_b+s+j_a+\\lambda} \\hat{j_b} \\hat{j_a} \\begin{Bmatrix} j_b & \\lambda & j_a \\\\ l_a & l_b & s \\end{Bmatrix} \\left( (-1)^{l_b} \\frac{\\hat{l_a}\\hat{l_b}\\hat{\\lambda}}{\\sqrt{4\\pi}} \\begin{pmatrix} l_b & \\lambda & l_a \\\\ 0 & 0 & 0 \\end{pmatrix} \\right)\n$$\nThe phase factor simplifies: $(-1)^{l_b+s+j_a+\\lambda} (-1)^{l_b} = (-1)^{2l_b+s+j_a+\\lambda} = (-1)^{s+j_a+\\lambda}$.\nThe problem specifies a nucleon, for which the intrinsic spin is $s=1/2$. Substituting this value, the final expression is:\n$$\n\\langle n_b l_b j_b \\lVert r^{\\lambda} Y_{\\lambda} \\rVert n_a l_a j_a \\rangle = R_{ba}^{(\\lambda)} \\frac{(-1)^{1/2+j_a+\\lambda}}{\\sqrt{4\\pi}} \\hat{j_a}\\hat{j_b}\\hat{l_a}\\hat{l_b}\\hat{\\lambda} \\begin{Bmatrix} j_b & \\lambda & j_a \\\\ l_a & l_b & 1/2 \\end{Bmatrix} \\begin{pmatrix} l_b & \\lambda & l_a \\\\ 0 & 0 & 0 \\end{pmatrix}\n$$\nThis expression contains the radial integral, one Wigner $6j$ symbol, one Wigner $3j$ symbol, and explicit dependence on the relevant quantum numbers, as required. The Wigner $3j$ symbol $\\begin{pmatrix} l_b & \\lambda & l_a \\\\ 0 & 0 & 0 \\end{pmatrix}$ enforces the parity selection rule, being non-zero only if $l_a+l_b+\\lambda$ is an even integer.", "answer": "$$\\boxed{R^{(\\lambda)}_{ba} \\frac{(-1)^{j_a+\\lambda+1/2}}{\\sqrt{4\\pi}} \\sqrt{(2j_a+1)(2j_b+1)(2l_a+1)(2l_b+1)(2\\lambda+1)} \\begin{Bmatrix} j_b & \\lambda & j_a \\\\ l_a & l_b & 1/2 \\end{Bmatrix} \\begin{pmatrix} l_b & \\lambda & l_a \\\\ 0 & 0 & 0 \\end{pmatrix}}$$", "id": "3545957"}, {"introduction": "A crucial aspect of any realistic nuclear structure calculation is ensuring that the results are free from unphysical artifacts. One common issue is the spurious excitation of the nuclear center-of-mass, which arises when using a basis (like the harmonic oscillator) that does not respect the translational invariance of the underlying nuclear interaction. This exercise [@problem_id:3545987] delves into this problem by tasking you with deriving the correct, translationally invariant electric dipole operator and quantifying the spurious strength using the powerful Thomas-Reiche-Kuhn sum rule, reinforcing the connection between fundamental symmetries and practical computation.", "problem": "Consider an atomic nucleus modeled as a system of $A$ nucleons of mass $m$, with $Z$ protons (each carrying electric charge $e$) and $N$ neutrons (electrically neutral), so that $A = N + Z$. Let the nuclear Hamiltonian be\n$$\n\\hat{H} = \\sum_{i=1}^{A} \\frac{\\hat{\\boldsymbol{p}}_{i}^{2}}{2m} + \\sum_{i<j} V\\!\\left(|\\hat{\\boldsymbol{r}}_{i} - \\hat{\\boldsymbol{r}}_{j}|\\right),\n$$\nwhich is translationally invariant because $V$ depends only on relative distances. The naive electric dipole operator is\n$$\n\\hat{\\boldsymbol{D}} = \\sum_{i=1}^{A} e_{i} \\hat{\\boldsymbol{r}}_{i},\n$$\nwith $e_{i} = e$ for protons and $e_{i} = 0$ for neutrons. Electromagnetic transition rates are computed from matrix elements of $\\hat{\\boldsymbol{D}}$, but this operator contains center-of-mass motion that produces spurious $E1$ strength.\n\nUsing only first principles, do the following:\n\n- Starting from translational invariance of physical observables under the uniform translation $\\hat{\\boldsymbol{r}}_{i} \\to \\hat{\\boldsymbol{r}}_{i} + \\boldsymbol{a}$ (with constant $\\boldsymbol{a}$), derive the unique linear-in-coordinates, translationally invariant $E1$ operator built from $\\{\\hat{\\boldsymbol{r}}_{i}\\}$ and show that it can be written in terms of the center-of-mass coordinate $\\hat{\\boldsymbol{R}}_{\\text{cm}} = \\frac{1}{A} \\sum_{i=1}^{A} \\hat{\\boldsymbol{r}}_{i}$ as\n$$\n\\hat{\\boldsymbol{D}}_{\\text{int}} = \\sum_{i=1}^{A} e_{i} \\left( \\hat{\\boldsymbol{r}}_{i} - \\hat{\\boldsymbol{R}}_{\\text{cm}} \\right).\n$$\n\n- Using the double-commutator energy-weighted sum rule for the Thomas–Reiche–Kuhn (TRK) sum,\n$$\nm_{1}(\\hat{O}) = \\frac{1}{2} \\left\\langle 0 \\left| \\left[ \\hat{O}, \\left[ \\hat{H}, \\hat{O} \\right] \\right] \\right| 0 \\right\\rangle,\n$$\ncompute $m_{1}$ for an $E1$ Cartesian component of the naive operator, $\\hat{D}_{x} = e \\sum_{p=1}^{Z} \\hat{x}_{p}$, and for the corresponding component of the intrinsic operator, $\\hat{D}_{x}^{\\text{int}} = e \\sum_{p=1}^{Z} \\left( \\hat{x}_{p} - \\hat{X}_{\\text{cm}} \\right)$, where $\\hat{X}_{\\text{cm}} = \\frac{1}{A} \\sum_{i=1}^{A} \\hat{x}_{i}$. Then, by rotational invariance, express the full $E1$ TRK sums for $\\hat{\\boldsymbol{D}}$ and $\\hat{\\boldsymbol{D}}_{\\text{int}}$ in the standard spherical-tensor normalization.\n\n- Define the spurious energy-weighted strength as $m_{1}^{\\text{sp}} = m_{1}(\\hat{\\boldsymbol{D}}) - m_{1}(\\hat{\\boldsymbol{D}}_{\\text{int}})$ and the suppression factor $S$ as the fraction of the naive $E1$ energy-weighted strength removed by eliminating the center-of-mass spuriosity:\n$$\nS = \\frac{m_{1}^{\\text{sp}}}{m_{1}(\\hat{\\boldsymbol{D}})}.\n$$\n\n- For an isospin-symmetric nucleus with $N = Z$, evaluate $S$ and give it as a single exact fraction. No rounding is necessary. The final answer is dimensionless; do not include units.", "solution": "This problem guides us through the derivation and quantification of spurious center-of-mass effects in nuclear electric dipole transitions.\n\n**1. Derivation of the Intrinsic E1 Operator**\n\nAn operator is translationally invariant if it is unchanged by a uniform translation of all particle coordinates, $\\hat{\\boldsymbol{r}}_{i} \\to \\hat{\\boldsymbol{r}}'_{i} = \\hat{\\boldsymbol{r}}_{i} + \\boldsymbol{a}$, for an arbitrary constant vector $\\boldsymbol{a}$. The center-of-mass coordinate transforms as:\n$$\n\\hat{\\boldsymbol{R}}'_{\\text{cm}} = \\frac{1}{A} \\sum_{i=1}^{A} \\hat{\\boldsymbol{r}}'_{i} = \\frac{1}{A} \\sum_{i=1}^{A} (\\hat{\\boldsymbol{r}}_{i} + \\boldsymbol{a}) = \\left(\\frac{1}{A} \\sum_{i=1}^{A} \\hat{\\boldsymbol{r}}_{i}\\right) + \\left(\\frac{1}{A} \\sum_{i=1}^{A} \\boldsymbol{a}\\right) = \\hat{\\boldsymbol{R}}_{\\text{cm}} + \\boldsymbol{a}\n$$\nThe proposed intrinsic operator $\\hat{\\boldsymbol{D}}_{\\text{int}}$ transforms as:\n$$\n\\hat{\\boldsymbol{D}}'_{\\text{int}} = \\sum_{i=1}^{A} e_{i} \\left( \\hat{\\boldsymbol{r}}'_{i} - \\hat{\\boldsymbol{R}}'_{\\text{cm}} \\right) = \\sum_{i=1}^{A} e_{i} \\left( (\\hat{\\boldsymbol{r}}_{i} + \\boldsymbol{a}) - (\\hat{\\boldsymbol{R}}_{\\text{cm}} + \\boldsymbol{a}) \\right) = \\sum_{i=1}^{A} e_{i} \\left( \\hat{\\boldsymbol{r}}_{i} - \\hat{\\boldsymbol{R}}_{\\text{cm}} \\right) = \\hat{\\boldsymbol{D}}_{\\text{int}}\n$$\nSince $\\hat{\\boldsymbol{D}}'_{\\text{int}} = \\hat{\\boldsymbol{D}}_{\\text{int}}$, the operator is translationally invariant. It is constructed from the particle coordinates $\\{\\hat{\\boldsymbol{r}}_i\\}$ and is linear in them. We can relate it to the naive operator $\\hat{\\boldsymbol{D}}$ by noting that $\\sum_{i=1}^{A} e_{i} = Ze$:\n$$\n\\hat{\\boldsymbol{D}} = \\sum_{i=1}^{A} e_{i} \\hat{\\boldsymbol{r}}_{i} = \\sum_{i=1}^{A} e_{i} \\left( (\\hat{\\boldsymbol{r}}_{i} - \\hat{\\boldsymbol{R}}_{\\text{cm}}) + \\hat{\\boldsymbol{R}}_{\\text{cm}} \\right) = \\hat{\\boldsymbol{D}}_{\\text{int}} + Ze \\hat{\\boldsymbol{R}}_{\\text{cm}}\n$$\nThis shows that $\\hat{\\boldsymbol{D}}$ is a sum of the translationally invariant intrinsic operator and a term describing the motion of the center-of-mass, which is responsible for spurious E1 strength.\n\n**2. Calculation of the TRK Sum Rules**\n\nWe evaluate $m_{1}(\\hat{O}) = \\frac{1}{2} \\langle 0 | [ \\hat{O}, [ \\hat{H}, \\hat{O} ] ] | 0 \\rangle$. The potential energy term $\\hat{V}$ in the Hamiltonian commutes with any operator that is a sum of individual particle coordinates. We only need the commutator with the kinetic energy $\\hat{T}$. Let $\\hat{O}_x = \\sum_{i=1}^{A} c_i \\hat{x}_i$. Using $[\\hat{x}_i, \\hat{p}_{jx}] = i\\hbar\\delta_{ij}$, we find:\n$$\n[\\hat{H}, \\hat{O}_x] = [\\hat{T}, \\hat{O}_x] = -\\frac{i\\hbar}{m} \\sum_{j=1}^{A} c_j \\hat{p}_{jx}\n$$\nThe double commutator is then:\n$$\n[\\hat{O}_x, [\\hat{H}, \\hat{O}_x]] = \\left[ \\sum_{k=1}^{A} c_k \\hat{x}_k, -\\frac{i\\hbar}{m} \\sum_{j=1}^{A} c_j \\hat{p}_{jx} \\right] = \\frac{\\hbar^2}{m} \\sum_{j=1}^{A} c_j^2\n$$\nThis result is a constant (a c-number), so the sum rule is $m_1(\\hat{O}_x) = \\frac{\\hbar^2}{2m} \\sum_{j=1}^{A} c_j^2$.\n\nFor the naive operator $\\hat{D}_{x} = e \\sum_{p=1}^{Z} \\hat{x}_{p}$, the coefficients are $c_i=e$ for $Z$ protons and $c_i=0$ for $N$ neutrons, so $\\sum c_i^2 = Ze^2$.\n$$\nm_1(\\hat{D}_x) = \\frac{\\hbar^2 e^2 Z}{2m}\n$$\nFor the intrinsic operator $\\hat{D}_{x}^{\\text{int}} = e\\frac{N}{A}\\sum_{p=1}^{Z}\\hat{x}_p - e\\frac{Z}{A}\\sum_{n=1}^{N}\\hat{x}_n$, the coefficients are $c'_p = e\\frac{N}{A}$ for protons and $c'_n = -e\\frac{Z}{A}$ for neutrons.\n$$\n\\sum_{i=1}^{A} (c'_i)^2 = Z \\left(e\\frac{N}{A}\\right)^2 + N \\left(-e\\frac{Z}{A}\\right)^2 = \\frac{e^2ZN}{A}\n$$\n$$\nm_1(\\hat{D}_x^{\\text{int}}) = \\frac{\\hbar^2}{2m} \\frac{e^2 ZN}{A}\n$$\nBy rotational invariance, the total TRK sums are three times these values:\n$$\nm_1(\\hat{\\boldsymbol{D}}) = \\frac{3\\hbar^2 e^2 Z}{2m} \\quad \\text{and} \\quad m_1(\\hat{\\boldsymbol{D}}_{\\text{int}}) = \\frac{3\\hbar^2 e^2 ZN}{2mA}\n$$\n\n**3. Spurious Strength and Suppression Factor**\n\nThe spurious energy-weighted strength is the difference:\n$$\nm_{1}^{\\text{sp}} = m_{1}(\\hat{\\boldsymbol{D}}) - m_{1}(\\hat{\\boldsymbol{D}}_{\\text{int}}) = \\frac{3\\hbar^2 e^2 Z}{2m} \\left(1 - \\frac{N}{A}\\right) = \\frac{3\\hbar^2 e^2 Z}{2m} \\left(\\frac{Z}{A}\\right) = \\frac{3\\hbar^2 e^2 Z^2}{2mA}\n$$\nThe suppression factor $S$ is the ratio of the spurious strength to the naive strength:\n$$\nS = \\frac{m_{1}^{\\text{sp}}}{m_{1}(\\hat{\\boldsymbol{D}})} = \\frac{3\\hbar^2 e^2 Z^2 / (2mA)}{3\\hbar^2 e^2 Z / (2m)} = \\frac{Z}{A}\n$$\n\n**4. Evaluation for an Isospin-Symmetric Nucleus**\n\nFor an isospin-symmetric nucleus, $N=Z$. The total mass number is $A=N+Z = 2Z$.\nSubstituting this into our expression for the suppression factor $S$:\n$$\nS = \\frac{Z}{A} = \\frac{Z}{2Z} = \\frac{1}{2}\n$$", "answer": "$$\\boxed{\\frac{1}{2}}$$", "id": "3545987"}, {"introduction": "While analytical derivations provide deep physical insight, applying them to medium- and heavy-mass nuclei often involves model spaces with billions of basis states, rendering direct diagonalization of the Hamiltonian matrix computationally impossible. To overcome this challenge, physicists employ powerful numerical techniques like the Lanczos algorithm to efficiently compute physical observables. In this hands-on coding practice [@problem_id:3545977], you will implement the Lanczos strength-function method, a cornerstone of modern large-scale shell-model calculations, and assess its convergence, gaining practical experience with a tool used at the frontiers of computational nuclear physics.", "problem": "Write a complete, runnable program that implements the Lanczos strength-function method to compute discrete electromagnetic transition strengths in finite-dimensional model spaces and assess convergence with respect to the number of Lanczos vectors. The program must adhere to the following specification.\n\n- Mathematical definitions:\n  - Let $H \\in \\mathbb{R}^{N \\times N}$ be a real symmetric Hamiltonian matrix with orthonormal eigenpairs $\\{ \\lvert n \\rangle, E_n \\}$, so that $H \\lvert n \\rangle = E_n \\lvert n \\rangle$ and $\\langle n \\vert m \\rangle = \\delta_{nm}$.\n  - Let $O \\in \\mathbb{R}^{N \\times N}$ be a real symmetric transition operator.\n  - Let the initial state $\\lvert i \\rangle \\in \\mathbb{R}^N$ be a normalized vector. For cases where $\\lvert i \\rangle$ is the ground state of $H$, it means $\\lvert i \\rangle$ is the normalized eigenvector of $H$ associated with the smallest eigenvalue $E_i$.\n  - The exact discrete strength distribution is\n    $$ S(\\omega) = \\sum_{n=1}^{N} \\left| \\langle n \\lvert O \\rvert i \\rangle \\right|^2 \\, \\delta\\!\\left(\\omega - (E_n - E_i)\\right). $$\n  - The Lanczos strength-function approximation is constructed by:\n    - Starting vector $\\lvert \\phi_0 \\rangle = \\frac{O \\lvert i \\rangle}{\\| O \\lvert i \\rangle \\|}$ if $\\| O \\lvert i \\rangle \\| \\neq 0$, otherwise the distribution is identically zero.\n    - Perform $m$-step Lanczos tridiagonalization of $H$ on the Krylov subspace $\\mathcal{K}_m(H,\\lvert \\phi_0 \\rangle) = \\text{span}\\{\\lvert \\phi_0 \\rangle, H \\lvert \\phi_0 \\rangle, \\dots, H^{m-1} \\lvert \\phi_0 \\rangle\\}$ to obtain the tridiagonal matrix $T_m$ with eigenpairs $\\{ \\theta_k, \\lvert y_k \\rangle \\}$, where $\\lvert y_k \\rangle$ are eigenvectors of $T_m$ and $\\theta_k \\in \\mathbb{R}$ are the corresponding Ritz energies.\n    - The approximate discrete strengths and transition energies are\n      $$ \\tilde{S}(\\omega) = \\sum_{k=1}^{m'} w_k \\, \\delta\\!\\left(\\omega - (\\theta_k - E_i)\\right), \\quad w_k = \\| O \\lvert i \\rangle \\|^2 \\, \\left| \\langle e_1 \\vert y_k \\rangle \\right|^2, $$\n      where $m' \\le m$ is the numerical rank of the constructed tridiagonalization (terminates early if a Lanczos norm vanishes), and $\\lvert e_1 \\rangle$ is the first basis vector of $\\mathbb{R}^{m'}$.\n  - To assess convergence, compare the exact and Lanczos-approximated smeared strength functions\n    $$ S_\\sigma(\\omega) = \\sum_{n=1}^{N} \\left| \\langle n \\lvert O \\rvert i \\rangle \\right|^2 \\, g_\\sigma\\!\\left(\\omega - (E_n - E_i)\\right), \\quad\n       \\tilde{S}_\\sigma(\\omega) = \\sum_{k=1}^{m'} w_k \\, g_\\sigma\\!\\left(\\omega - (\\theta_k - E_i)\\right), $$\n    where $g_\\sigma(x) = \\frac{1}{\\sigma \\sqrt{2\\pi}} \\exp\\!\\left(-\\frac{x^2}{2\\sigma^2}\\right)$ is a Gaussian of width $\\sigma$.\n  - Sum rules to validate numerics:\n    - Zeroth-moment sum rule (non-energy-weighted): $\\int_{-\\infty}^{\\infty} S(\\omega)\\, d\\omega = \\langle i \\lvert O^2 \\rvert i \\rangle$.\n    - The corresponding Lanczos approximation satisfies $\\sum_{k} w_k \\approx \\langle i \\lvert O^2 \\rvert i \\rangle$ in finite arithmetic.\n\n- Numerical and output requirements:\n  - All quantities are dimensionless; energies and strengths must be treated as dimensionless numbers. No physical units are required.\n  - Use a Gaussian smearing width of $\\sigma = 0.15$ and a uniform grid in $\\omega$ with spacing $\\Delta \\omega = 0.01$. The grid must cover the interval\n    $$ \\omega \\in [\\min(\\Delta E) - 0.5, \\max(\\Delta E) + 0.5], \\quad \\Delta E = \\{ E_n - E_i \\}_{n=1}^{N}, $$\n    and must also include the approximate transition energies $\\{ \\theta_k - E_i \\}$ when present.\n  - For each test case, compute two scalar diagnostics:\n    - The relative $\\ell_1$ error of the smeared distributions on the grid,\n      $$ \\varepsilon_{\\mathrm{L1}} = \\frac{\\sum_j \\left| \\tilde{S}_\\sigma(\\omega_j) - S_\\sigma(\\omega_j) \\right|}{\\sum_j S_\\sigma(\\omega_j)}, $$\n      with the convention that if the denominator is zero (identically zero strength), then $\\varepsilon_{\\mathrm{L1}} = 0$.\n    - The relative error in the non-energy-weighted sum rule,\n      $$ \\varepsilon_{0} = \n         \\begin{cases}\n           \\dfrac{\\left| \\sum_k w_k - \\sum_n \\left| \\langle n \\lvert O \\rvert i \\rangle \\right|^2 \\right|}{\\sum_n \\left| \\langle n \\lvert O \\rvert i \\rangle \\right|^2}, & \\text{if } \\sum_n \\left| \\langle n \\lvert O \\rvert i \\rangle \\right|^2 > 0, \\\\\n           0, & \\text{otherwise.}\n         \\end{cases}\n      $$\n  - Define a convergence flag for each test case as a boolean\n    $\\text{converged} = \\left( \\varepsilon_{\\mathrm{L1}} \\le \\tau \\right), \\quad \\tau = 0.05$.\n\n- Test suite:\n  - Use the following four test cases. In all cases $N = 6$ and all matrices are given explicitly; matrix entries not shown are zero, and all matrices are symmetric with $M_{ij} = M_{ji}$.\n  - For cases where the initial state is the ground state, take $\\lvert i \\rangle$ to be the normalized eigenvector of $H$ associated with the smallest eigenvalue obtained by exact diagonalization; if there is degeneracy at the minimum, choose the eigenvector in that degenerate subspace having the largest overlap with the canonical basis vector $\\lvert e_1 \\rangle$.\n  - Test Case $1$ (happy path):\n    - $H_1 = \\begin{pmatrix}\n      -3.0 & 0.2 & 0.0 & 0.0 & 0.0 & 0.0\\\\\n      0.2 & -1.5 & 0.3 & 0.0 & 0.0 & 0.0\\\\\n      0.0 & 0.3 & 0.5 & 0.4 & 0.0 & 0.0\\\\\n      0.0 & 0.0 & 0.4 & 1.8 & 0.5 & 0.0\\\\\n      0.0 & 0.0 & 0.0 & 0.5 & 3.0 & 0.6\\\\\n      0.0 & 0.0 & 0.0 & 0.0 & 0.6 & 4.5\n      \\end{pmatrix}$,\n      $O_1 = \\begin{pmatrix}\n      0.0 & 0.5 & 0.1 & 0.0 & 0.0 & 0.0\\\\\n      0.5 & 0.0 & 0.4 & 0.2 & 0.0 & 0.0\\\\\n      0.1 & 0.4 & 0.0 & 0.3 & 0.2 & 0.0\\\\\n      0.0 & 0.2 & 0.3 & 0.0 & 0.4 & 0.1\\\\\n      0.0 & 0.0 & 0.2 & 0.4 & 0.0 & 0.5\\\\\n      0.0 & 0.0 & 0.0 & 0.1 & 0.5 & 0.0\n      \\end{pmatrix}$,\n      initial state $\\lvert i \\rangle$ is the ground state of $H_1$, $m = 4$.\n  - Test Case $2$ (boundary in $m$):\n    - Same $H_1$ and $O_1$ as in Test Case $1$, initial state $\\lvert i \\rangle$ is the ground state of $H_1$, $m = 1$.\n  - Test Case $3$ (zero operator edge case):\n    - Same $H_1$ as in Test Case $1$, take $O_0 = 0_{6 \\times 6}$ (the $6 \\times 6$ zero matrix), initial state $\\lvert i \\rangle$ is the ground state of $H_1$, $m = 4$.\n  - Test Case $4$ (degenerate Hamiltonian):\n    - $H_2 = \\mathrm{diag}(0.0,\\, 0.0,\\, 1.0,\\, 1.5,\\, 2.5,\\, 2.5)$,\n      $O_2 = \\begin{pmatrix}\n      0.0 & 0.3 & 0.2 & 0.0 & 0.1 & 0.0\\\\\n      0.3 & 0.0 & 0.0 & 0.2 & 0.0 & 0.1\\\\\n      0.2 & 0.0 & 0.0 & 0.3 & 0.0 & 0.0\\\\\n      0.0 & 0.2 & 0.3 & 0.0 & 0.4 & 0.0\\\\\n      0.1 & 0.0 & 0.0 & 0.4 & 0.0 & 0.2\\\\\n      0.0 & 0.1 & 0.0 & 0.0 & 0.2 & 0.0\n      \\end{pmatrix}$,\n      initial state $\\lvert i \\rangle = \\lvert e_1 \\rangle = (1,0,0,0,0,0)^\\top$, $m = 4$.\n\n- Required final output format:\n  - For each test case, output a list containing three entries $[\\varepsilon_{\\mathrm{L1}}, \\varepsilon_0, \\text{converged}]$, where the boolean is printed as a language-native boolean literal.\n  - The program must produce a single line of output containing the results as a comma-separated list of these per-test-case lists enclosed in square brackets, for example:\n    $$ \\texttt{[[0.0123,0.0001,True],[\\dots],\\dots]} $$\n  - No other text may be printed.\n\nAll computations must be performed in pure floating-point arithmetic. The program must be self-contained, must not read any input, and must not access external files or the network. The implementation language and environment constraints are specified in the final answer section. All energies and strengths are to be treated as dimensionless numbers. Angles are not used. Percentages must not be used; all errors must be given as decimal fractions.", "solution": "The problem asks for an implementation and validation of the Lanczos strength-function method, a powerful numerical technique used in large-scale quantum calculations to find the distribution of transition strengths without fully diagonalizing the Hamiltonian. The core idea is to approximate the full Hilbert space with a much smaller Krylov subspace, which is constructed specifically to capture the system's response to the transition operator.\n\n### Conceptual Steps of the Solution\n\n1.  **Preparation and Initial State:** For each test case, the program must first establish the initial state $|i\\rangle$ and its energy $E_i$. If the state is defined as the ground state, this requires a full diagonalization of the Hamiltonian $H$ to find the eigenvector corresponding to the lowest eigenvalue. The problem specifies a tie-breaking rule for degenerate ground states.\n\n2.  **Exact Strength Distribution (Benchmark):** Since the test cases use small matrices, we can compute the exact strength distribution for comparison. This is done by using all the eigenpairs $\\{|n\\rangle, E_n\\}$ from the full diagonalization of $H$. The exact strengths are calculated as $|\\langle n|O|i\\rangle|^2$ for each final state $|n\\rangle$. The non-energy-weighted sum rule, $\\sum_n |\\langle n|O|i\\rangle|^2 = \\langle i|O^2|i\\rangle$, provides a key benchmark.\n\n3.  **Lanczos Tridiagonalization:** The heart of the algorithm is the construction of a Krylov subspace starting from the \"doorway\" state, $| \\phi_0 \\rangle = O|i\\rangle / \\|O|i\\rangle\\|$. A three-term recurrence relation, known as the Lanczos algorithm, is applied for $m$ iterations. This process generates an orthonormal basis for the Krylov subspace and simultaneously builds an $m \\times m$ real, symmetric, tridiagonal matrix, $T_m$. This matrix is a projection of the full Hamiltonian $H$ onto the Krylov subspace.\n\n4.  **Approximate Strength Distribution:** The tridiagonal matrix $T_m$ is much smaller and cheaper to diagonalize than the original $H$. Its eigenvalues, $\\{\\theta_k\\}$, are the \"Ritz energies,\" which approximate the true transition energies. The corresponding strengths, $\\{w_k\\}$, can be calculated from the eigenvectors of $T_m$ and the norm of the initial doorway state, using the formula $w_k = \\|O|i\\rangle\\|^2 |\\langle e_1 | y_k \\rangle|^2$, where $|y_k\\rangle$ is an eigenvector of $T_m$ and $|e_1\\rangle$ is the first canonical basis vector. A crucial property of the Lanczos method is that the sum of these approximate strengths, $\\sum_k w_k$, exactly equals the exact non-energy-weighted sum rule in perfect arithmetic.\n\n5.  **Comparison and Diagnostics:** To compare the discrete exact and approximate spectra, they are convoluted with a Gaussian function to produce continuous, \"smeared\" strength functions. The relative $\\ell_1$ error between these two smeared distributions measures how well the Lanczos approximation reproduces the overall shape of the true strength function. The relative error in the sum rule is also calculated to check for numerical precision issues. Finally, the convergence is assessed by comparing the $\\ell_1$ error to a predefined tolerance $\\tau$.\n\nThe Python implementation follows these steps, using libraries like NumPy and SciPy for efficient linear algebra operations, including the diagonalization of both dense and tridiagonal matrices. The code handles the specified test cases, including edge cases like a zero operator and a degenerate Hamiltonian, and formats the output as required.", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh_tridiagonal\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and generate the final output.\n    \"\"\"\n\n    # Test Case 1 & 2\n    H1 = np.zeros((6, 6))\n    H1.flat[::7] = [-3.0, -1.5, 0.5, 1.8, 3.0, 4.5]\n    H1[0, 1] = H1[1, 0] = 0.2\n    H1[1, 2] = H1[2, 1] = 0.3\n    H1[2, 3] = H1[3, 2] = 0.4\n    H1[3, 4] = H1[4, 3] = 0.5\n    H1[4, 5] = H1[5, 4] = 0.6\n\n    O1 = np.zeros((6, 6))\n    O1[0, 1] = O1[1, 0] = 0.5\n    O1[0, 2] = O1[2, 0] = 0.1\n    O1[1, 2] = O1[2, 1] = 0.4\n    O1[1, 3] = O1[3, 1] = 0.2\n    O1[2, 3] = O1[3, 2] = 0.3\n    O1[2, 4] = O1[4, 2] = 0.2\n    O1[3, 4] = O1[4, 3] = 0.4\n    O1[3, 5] = O1[5, 3] = 0.1\n    O1[4, 5] = O1[5, 4] = 0.5\n\n    # Test Case 3\n    O0 = np.zeros((6, 6))\n\n    # Test Case 4\n    H2 = np.diag([0.0, 0.0, 1.0, 1.5, 2.5, 2.5])\n    O2 = np.zeros((6, 6))\n    O2[0, 1] = O2[1, 0] = 0.3\n    O2[0, 2] = O2[2, 0] = 0.2\n    O2[0, 4] = O2[4, 0] = 0.1\n    O2[1, 3] = O2[3, 1] = 0.2\n    O2[1, 5] = O2[5, 1] = 0.1\n    O2[2, 3] = O2[3, 2] = 0.3\n    O2[3, 4] = O2[4, 3] = 0.4\n    O2[4, 5] = O2[5, 4] = 0.2\n\n    initial_state_e1 = np.zeros(6)\n    initial_state_e1[0] = 1.0\n\n    test_cases = [\n        {'H': H1, 'O': O1, 'm': 4, 'initial_state_def': 'ground_state'},\n        {'H': H1, 'O': O1, 'm': 1, 'initial_state_def': 'ground_state'},\n        {'H': H1, 'O': O0, 'm': 4, 'initial_state_def': 'ground_state'},\n        {'H': H2, 'O': O2, 'm': 4, 'initial_state_def': initial_state_e1}\n    ]\n    \n    results = []\n    for case in test_cases:\n        result = compute_strength_function_diagnostics(**case)\n        results.append(result)\n\n    output_parts = []\n    for res in results:\n        # Format boolean as True/False literal without quotes\n        part = f\"[{res[0]},{res[1]},{str(res[2])}]\"\n        output_parts.append(part)\n    final_output = f\"[{','.join(output_parts)}]\"\n    print(final_output)\n\ndef get_initial_state(H, initial_state_def):\n    \"\"\"\n    Determines the initial state vector |i> and its energy E_i.\n    \"\"\"\n    if isinstance(initial_state_def, np.ndarray):\n        i_state = initial_state_def\n        i_energy = i_state.T @ H @ i_state\n        return i_state, i_energy\n\n    if initial_state_def == 'ground_state':\n        eigenvalues, eigenvectors = np.linalg.eigh(H)\n        min_eigenvalue = eigenvalues[0]\n        \n        # Find indices of degenerate ground states\n        gs_indices = np.where(np.isclose(eigenvalues, min_eigenvalue))[0]\n        \n        if len(gs_indices) == 1:\n            i_state = eigenvectors[:, gs_indices[0]]\n        else:\n            # Tie-breaking rule: max overlap with e1\n            gs_candidates = eigenvectors[:, gs_indices]\n            best_idx_in_subspace = np.argmax(np.abs(gs_candidates[0, :]))\n            i_state = gs_candidates[:, best_idx_in_subspace]\n            \n        i_energy = min_eigenvalue\n        return i_state, i_energy\n    \n    raise ValueError(\"Invalid initial_state_def\")\n\ndef compute_strength_function_diagnostics(H, O, m, initial_state_def):\n    \"\"\"\n    Computes diagnostics for a single test case.\n    \"\"\"\n    N = H.shape[0]\n    sigma = 0.15\n    delta_omega = 0.01\n    conv_tau = 0.05\n    \n    # Step 1: Determine initial state and energy\n    i_state, i_energy = get_initial_state(H, initial_state_def)\n    \n    # Step 2: Calculate starting vector for Lanczos\n    phi0_unnorm = O @ i_state\n    norm_phi0_unnorm = np.linalg.norm(phi0_unnorm)\n\n    # Step 3: Handle the zero strength case\n    if norm_phi0_unnorm < 1e-15:\n        return [0.0, 0.0, True]\n\n    # Step 4: Lanczos Algorithm\n    phi0 = phi0_unnorm / norm_phi0_unnorm\n    V = np.zeros((N, m + 1))\n    alphas = np.zeros(m)\n    betas = np.zeros(m - 1)\n    V[:, 0] = phi0\n    \n    w_prime = H @ V[:, 0]\n    alpha = np.dot(V[:, 0], w_prime)\n    alphas[0] = alpha\n    w = w_prime - alpha * V[:, 0]\n    \n    m_prime = m\n    for j in range(1, m):\n        beta = np.linalg.norm(w)\n        if beta < 1e-15:\n            m_prime = j\n            break\n\n        V[:, j] = w / beta\n        betas[j - 1] = beta\n\n        w_prime = H @ V[:, j]\n        alpha = np.dot(V[:, j], w_prime)\n        alphas[j] = alpha\n        \n        w = w_prime - alpha * V[:, j] - beta * V[:, j - 1]\n\n    # Step 5: Get approximate spectrum (Ritz values)\n    eff_alphas = alphas[:m_prime]\n    eff_betas = betas[:m_prime - 1]\n    ritz_energies, ritz_vectors = eigh_tridiagonal(eff_alphas, eff_betas)\n    \n    approx_weights = norm_phi0_unnorm**2 * ritz_vectors[0, :]**2\n    approx_sum_rule = np.sum(approx_weights)\n    approx_trans_energies = ritz_energies - i_energy\n    \n    # Step 6: Get exact spectrum\n    exact_energies, exact_vectors = np.linalg.eigh(H)\n    exact_trans_energies = exact_energies - i_energy\n    exact_strengths = (exact_vectors.T @ phi0_unnorm)**2\n    exact_sum_rule = np.sum(exact_strengths)\n    \n    # Step 7: Smeared functions on a grid\n    all_trans_energies = np.concatenate((exact_trans_energies, approx_trans_energies))\n    omega_min = np.min(all_trans_energies) - 0.5\n    omega_max = np.max(all_trans_energies) + 0.5\n    omega_grid = np.arange(omega_min, omega_max, delta_omega)\n\n    def gaussian(x, s):\n        return np.exp(-x**2 / (2 * s**2)) / (s * np.sqrt(2 * np.pi))\n\n    # Vectorized calculation of smeared functions\n    s_exact_smeared = np.sum(\n        gaussian(omega_grid[:, np.newaxis] - exact_trans_energies, sigma) * exact_strengths, axis=1\n    )\n    s_approx_smeared = np.sum(\n        gaussian(omega_grid[:, np.newaxis] - approx_trans_energies, sigma) * approx_weights, axis=1\n    )\n    \n    # Step 8: Calculate diagnostics\n    # epsilon_L1\n    l1_numerator = np.sum(np.abs(s_approx_smeared - s_exact_smeared))\n    l1_denominator = np.sum(s_exact_smeared)\n    epsilon_l1 = l1_numerator / l1_denominator if l1_denominator > 1e-15 else 0.0\n\n    # epsilon_0\n    sum_rule_numerator = np.abs(approx_sum_rule - exact_sum_rule)\n    sum_rule_denominator = exact_sum_rule\n    epsilon_0 = sum_rule_numerator / sum_rule_denominator if sum_rule_denominator > 1e-15 else 0.0\n    \n    # Convergence flag\n    converged = (epsilon_l1 <= conv_tau)\n\n    return [epsilon_l1, epsilon_0, converged]\n\nsolve()\n```", "id": "3545977"}]}