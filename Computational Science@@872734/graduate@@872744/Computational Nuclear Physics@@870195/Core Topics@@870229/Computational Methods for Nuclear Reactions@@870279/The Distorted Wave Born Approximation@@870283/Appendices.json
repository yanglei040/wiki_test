{"hands_on_practices": [{"introduction": "Before applying any approximation, it is crucial to understand its domain of validity. This practice provides a direct way to validate the Distorted Wave Born Approximation (DWBA) by comparing it against an exact quantum mechanical solution. You will work with a specially constructed potential—a rank-two separable potential—for which the Lippmann-Schwinger equation can be solved algebraically, providing a definitive benchmark for the DWBA calculation [@problem_id:3598541]. This exercise sharpens your understanding of the underlying scattering theory and builds confidence in the approximation's predictive power.", "problem": "Consider a single-channel, spinless, non-relativistic two-body scattering problem in the $s$-wave with units fixed so that $\\hbar = 1$ and $2\\mu = 1$, where $\\mu$ is the reduced mass. Let $E$ denote the kinetic energy and $k$ denote the on-shell momentum satisfying $E = k^2$. The free resolvent (free Green's function) operator is denoted by $G_0(E)$, and the exact transition operator $T(E)$ obeys the Lippmann–Schwinger (LS) equation $T(E) = V + V G_0(E) T(E)$, where $V$ is the interaction potential operator. The interaction potential is chosen to be a sum of two rank-$1$ separable potentials, $V = U + W$, with $U = \\lambda_U \\lvert g_U \\rangle \\langle g_U \\rvert$ and $W = \\lambda_W \\lvert g_W \\rangle \\langle g_W \\rvert$, where $\\lambda_U$ and $\\lambda_W$ are coupling strengths and the form factors in momentum space are defined as $g_U(p) = \\dfrac{1}{p^2 + \\beta_U^2}$ and $g_W(p) = \\dfrac{1}{p^2 + \\beta_W^2}$ with range parameters $\\beta_U$ and $\\beta_W$. \n\nFrom first principles, start with the Lippmann–Schwinger equation and the definition of rank-$1$ separable potentials to derive the exact on-shell transition amplitude $t_{\\mathrm{exact}}(k) \\equiv \\langle k \\lvert T(E) \\rvert k \\rangle$ for the total interaction $V = U + W$. Then, starting from the same LS foundation and the definition of the Distorted Wave Born Approximation (DWBA), where $U$ is treated to all orders and $W$ is treated to first order in the distorted-wave basis generated by $U$, derive the DWBA on-shell amplitude $t_{\\mathrm{DWBA}}(k) \\equiv \\langle k \\lvert T_{\\mathrm{DWBA}}(E) \\rvert k \\rangle$. Ensure that your derivations explicitly identify all required intermediate operator-valued objects and scalar quantities, including but not limited to the loop integrals $I_{ij}(E) \\equiv \\langle g_i \\lvert G_0(E) \\rvert g_j \\rangle$ for $i,j \\in \\{ U, W \\}$, and clarify how the principal value and imaginary parts arise from the resolvent.\n\nThe program must implement the following computational tasks to validate the Distorted Wave Born Approximation (DWBA):\n- Compute $t_{\\mathrm{exact}}(k)$ from the full LS solution for $V = U + W$ using the rank-$2$ separable structure.\n- Compute $t_{\\mathrm{DWBA}}(k)$ where the distorted waves are generated by $U$ and $W$ is included to leading order in the distorted-wave Born sense.\n- Evaluate the loop integrals $I_{ij}(E)$ in momentum space using the spherical measure and the transformation to a finite integration domain. The measure must be $\\dfrac{d^3 p}{(2\\pi)^3}$, and the spherical reduction must be handled with the factor $\\dfrac{1}{2\\pi^2}$ multiplying the radial integral. The imaginary part must result from the on-shell delta-function structure of $G_0(E)$, and the real part must be computed as a Cauchy principal value integral. The computation must be numerically stable for small and moderate on-shell momenta $k$.\n\nDefine a metric of agreement between DWBA and exact LS for a given parameter set as\n$$\nM \\equiv \\max_{k \\in \\mathcal{K}} \\frac{\\lvert t_{\\mathrm{DWBA}}(k) - t_{\\mathrm{exact}}(k) \\rvert}{\\lvert t_{\\mathrm{exact}}(k) \\rvert},\n$$\nwhere $\\mathcal{K}$ is a finite set of on-shell momenta. The quantity $M$ is dimensionless. If $\\lvert t_{\\mathrm{exact}}(k) \\rvert$ is numerically indistinguishable from zero, use a regularized denominator $\\lvert t_{\\mathrm{exact}}(k) \\rvert + \\epsilon$ with a small $\\epsilon$ to avoid division by zero, and justify the choice of $\\epsilon$ in your solution. Angles do not appear in this $s$-wave calculation, so no angle units are required.\n\nYour program must implement the computations for the following test suite of parameter sets, each with a corresponding set of three on-shell momenta:\n- Test case $1$ (moderate distortion, weak perturbation, typical energies): $\\lambda_U = -1.0$, $\\beta_U = 1.0$, $\\lambda_W = -0.2$, $\\beta_W = 2.0$, and $\\mathcal{K} = \\{ 0.05, 0.30, 0.80 \\}$.\n- Test case $2$ (near-threshold energies): $\\lambda_U = -1.0$, $\\beta_U = 1.0$, $\\lambda_W = -0.2$, $\\beta_W = 2.0$, and $\\mathcal{K} = \\{ 0.001, 0.020, 0.050 \\}$.\n- Test case $3$ (stronger perturbation to explore DWBA breakdown): $\\lambda_U = -1.0$, $\\beta_U = 1.0$, $\\lambda_W = -0.8$, $\\beta_W = 2.0$, and $\\mathcal{K} = \\{ 0.05, 0.30, 0.80 \\}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases $1$, $2$, and $3$, where each entry is the metric $M$ for the corresponding test case. For example, an acceptable output format is $\\left[ r_1, r_2, r_3 \\right]$ with $r_1$, $r_2$, and $r_3$ being floating-point numbers.", "solution": "The problem requires the derivation and computation of the exact and Distorted Wave Born Approximation (DWBA) on-shell transition amplitudes for a specific non-relativistic scattering problem. The interaction potential $V$ is a sum of two rank-one separable potentials, $V=U+W$. The analysis will be conducted in the $s$-wave channel with units $\\hbar=1$ and $2\\mu=1$, where $\\mu$ is the reduced mass. The on-shell energy is $E=k^2$ for momentum $k$.\n\nFirst, we derive the expressions for the exact and DWBA amplitudes. Next, we detail the calculation of the necessary loop integrals. Finally, we outline the computational implementation to compute the agreement metric $M$.\n\n### 1. Derivation of the Exact On-Shell Amplitude $t_{\\mathrm{exact}}(k)$\n\nThe total potential is $V = U + W$, where $U = \\lambda_U \\lvert g_U \\rangle \\langle g_U \\rvert$ and $W = \\lambda_W \\lvert g_W \\rangle \\langle g_W \\rvert$. The Lippmann-Schwinger (LS) equation for the transition operator $T(E)$ is\n$$\nT(E) = V + V G_0(E) T(E)\n$$\nwhere $G_0(E) = (E - H_0 + i\\epsilon)^{-1}$ is the free resolvent. Since $V$ is a rank-two separable operator, the solution $T(E)$ will also be a separable operator within the space spanned by $\\{ \\lvert g_U \\rangle, \\lvert g_W \\rangle \\}$. We can posit the form:\n$$\nT(E) = \\sum_{i,j \\in \\{U, W\\}} \\lvert g_i \\rangle \\tau_{ij}(E) \\langle g_j \\rvert\n$$\nA more direct and systematic method is to solve for the operator algebraically. Let's substitute the form of $V$ into the LS equation:\n$$\nT(E) = \\lambda_U \\lvert g_U \\rangle \\langle g_U \\rvert + \\lambda_W \\lvert g_W \\rangle \\langle g_W \\rvert + (\\lambda_U \\lvert g_U \\rangle \\langle g_U \\rvert + \\lambda_W \\lvert g_W \\rangle \\langle g_W \\rvert) G_0(E) T(E)\n$$\nLet's define the matrix elements of $T(E)$ between the form factor states: $T_{ij}(E) = \\langle g_i \\rvert T(E) \\rvert g_j \\rangle$. By left-projecting the LS equation with $\\langle g_U \\rvert$ and $\\langle g_W \\rvert$, we obtain a system of equations for $\\langle g_U \\rvert T(E)$ and $\\langle g_W \\rvert T(E)$.\nLet us define $f_i(E, \\mathbf{p}) \\equiv \\langle g_i \\rvert T(E) \\rvert \\mathbf{p} \\rangle$. Taking the matrix element of the LS equation with $\\langle g_i \\rvert$ on the left and $\\lvert \\mathbf{p} \\rangle$ on the right gives:\n$$\nf_U(E, \\mathbf{p}) = \\lambda_U g_U(p) \\langle g_U \\rvert \\mathbf{p} \\rangle + \\lambda_U \\langle g_U \\rvert G_0(E) T(E) \\rvert \\mathbf{p} \\rangle \\\\\nf_W(E, \\mathbf{p}) = \\lambda_W g_W(p) \\langle g_W \\rvert \\mathbf{p} \\rangle + \\lambda_W \\langle g_W \\rvert G_0(E) T(E) \\rvert \\mathbf{p} \\rangle\n$$\nThis line of reasoning is incorrect. A simpler method is to assume $T(E)$ can be written as $T(E) = \\lvert g_U \\rangle \\langle f_U \\rvert + \\lvert g_W \\rangle \\langle f_W \\rvert$. Substituting this into the LS equation and assuming linear independence of $\\lvert g_U \\rangle$ and $\\lvert g_W \\rangle$ leads to a system of coupled algebraic equations for the unknown bra-vectors $\\langle f_U \\rvert$ and $\\langle f_W \\rvert$:\n$$\n\\begin{pmatrix} 1 - \\lambda_U I_{UU}(E) & -\\lambda_U I_{UW}(E) \\\\ -\\lambda_W I_{WU}(E) & 1 - \\lambda_W I_{WW}(E) \\end{pmatrix} \\begin{pmatrix} \\langle f_U \\rvert \\\\ \\langle f_W \\rvert \\end{pmatrix} = \\begin{pmatrix} \\lambda_U\\langle g_U \\rvert \\\\ \\lambda_W\\langle g_W \\rvert \\end{pmatrix}\n$$\nHere, $I_{ij}(E) \\equiv \\langle g_i \\rvert G_0(E) \\rvert g_j \\rangle$ are the loop integrals. The $2 \\times 2$ matrix can be inverted. Let its determinant be $D(E)$:\n$$\nD(E) = (1 - \\lambda_U I_{UU}(E))(1 - \\lambda_W I_{WW}(E)) - \\lambda_U \\lambda_W I_{UW}(E) I_{WU}(E)\n$$\nAs $G_0$ is self-adjoint and the form factors are real, $I_{UW} = I_{WU}$. The solution for $\\langle f_U \\rvert$ and $\\langle f_W \\rvert$ is found by matrix inversion. Substituting back into the ansatz for $T(E)$ and taking the on-shell matrix element $\\langle k \\rvert T(E=k^2) \\rvert k \\rangle$ yields:\n$$\nt_{\\mathrm{exact}}(k) = \\frac{1}{D(k^2)} \\left[ \\lambda_U(1-\\lambda_W I_{WW}) g_U(k)^2 + \\lambda_W(1-\\lambda_U I_{UU}) g_W(k)^2 + 2\\lambda_U\\lambda_W I_{UW} g_U(k)g_W(k) \\right]\n$$\nwhere all loop integrals $I_{ij}$ are evaluated at $E=k^2+i\\epsilon$. The momentum-space form factors are given by $g_i(p) = 1/(p^2+\\beta_i^2)$.\n\n### 2. Derivation of the DWBA On-Shell Amplitude $t_{\\mathrm{DWBA}}(k)$\n\nIn the DWBA, the potential $U$ is treated to all orders, generating \"distorted waves\", while $W$ is treated as a first-order perturbation. The T-operator in this approximation is given by the two-potential formula truncated at leading order in $W$:\n$$\nT_{\\mathrm{DWBA}}(E) = T_U(E) + \\Omega_U^{(-)\\dagger}(E) W \\Omega_U^{(+)}(E)\n$$\nwhere $T_U$ is the exact T-operator for the potential $U$ alone, and $\\Omega_U^{(\\pm)}(E) = 1+G_0(E)T_U(E)$ are the Møller wave operators for potential $U$. The on-shell transition amplitude is $t_{\\mathrm{DWBA}}(k) = \\langle k \\rvert T_{\\mathrm{DWBA}}(E=k^2) \\rvert k \\rangle$. This is:\n$$\nt_{\\mathrm{DWBA}}(k) = \\langle k \\rvert T_U(k^2) \\rvert k \\rangle + \\langle k \\rvert \\Omega_U^{(-)\\dagger}(k^2) W \\Omega_U^{(+)}(k^2) \\rvert k \\rangle\n$$\nThe second term is recognized as the matrix element of $W$ between distorted waves: $\\langle \\psi_k^{(-)} \\rvert W \\rvert \\psi_k^{(+)} \\rangle$, where $\\lvert \\psi_k^{(+)} \\rangle = \\Omega_U^{(+)}(k^2) \\lvert k \\rangle$ and $\\langle \\psi_k^{(-)} \\rvert = \\langle k \\rvert \\Omega_U^{(-)\\dagger}(k^2)$.\n\nFirst, we find $t_U(k) = \\langle k \\rvert T_U(k^2) \\rvert k \\rangle$. For the rank-1 potential $U$, the T-operator is:\n$$\nT_U(E) = \\frac{\\lambda_U \\lvert g_U \\rangle \\langle g_U \\rvert}{1 - \\lambda_U I_{UU}(E)}\n$$\nThus, its on-shell element is:\n$$\nt_U(k) = \\frac{\\lambda_U g_U(k)^2}{1 - \\lambda_U I_{UU}(k^2)}\n$$\nNext, we evaluate the distorted-wave matrix element. The distorted states are:\n$$\n\\lvert \\psi_k^{(+)} \\rangle = (1 + G_0(k^2) T_U(k^2)) \\lvert k \\rangle = \\lvert k \\rangle + G_0(k^2) \\frac{\\lambda_U g_U(k)}{1 - \\lambda_U I_{UU}(k^2)} \\lvert g_U \\rangle\n$$\n$$\n\\langle \\psi_k^{(-)} \\rvert = \\langle k \\rvert (1 + T_U(k^2) G_0(k^2)) = \\langle k \\rvert + \\frac{\\lambda_U g_U(k)}{1 - \\lambda_U I_{UU}(k^2)} \\langle g_U \\rvert G_0(k^2)\n$$\nThe matrix element of $W = \\lambda_W \\lvert g_W \\rangle \\langle g_W \\rvert$ is $\\lambda_W \\langle \\psi_k^{(-)} \\rvert g_W \\rangle \\langle g_W \\rvert \\psi_k^{(+)} \\rangle$. We compute the projections:\n$$\n\\langle g_W \\rvert \\psi_k^{(+)} \\rangle = \\langle g_W \\rvert k \\rangle + \\frac{\\lambda_U g_U(k)}{1 - \\lambda_U I_{UU}(k^2)} \\langle g_W \\rvert G_0(k^2) \\rvert g_U \\rangle = g_W(k) + \\frac{\\lambda_U g_U(k) I_{WU}(k^2)}{1 - \\lambda_U I_{UU}(k^2)}\n$$\n$$\n\\langle \\psi_k^{(-)} \\rvert g_W \\rangle = \\langle k \\rvert g_W \\rangle + \\frac{\\lambda_U g_U(k)}{1 - \\lambda_U I_{UU}(k^2)} \\langle g_U \\rvert G_0(k^2) \\rvert g_W \\rangle = g_W(k) + \\frac{\\lambda_U g_U(k) I_{UW}(k^2)}{1 - \\lambda_U I_{UU}(k^2)}\n$$\nSince $I_{UW} = I_{WU}$, these two projections are identical. Let's call this term the \"distorted form factor\" $\\mathcal{D}_W(k)$.\n$$\n\\mathcal{D}_W(k) = g_W(k) + \\frac{\\lambda_U I_{UW}(k^2)}{1 - \\lambda_U I_{UU}(k^2)} g_U(k)\n$$\nThe DWBA amplitude is the sum of the T-matrix for $U$ and the Born term for $W$ in the distorted basis:\n$$\nt_{\\mathrm{DWBA}}(k) = t_U(k) + \\lambda_W \\left( \\mathcal{D}_W(k) \\right)^2\n$$\n\n### 3. Evaluation of the Loop Integrals $I_{ij}(E)$\n\nThe loop integrals are the cornerstone of the calculation.\n$$\nI_{ij}(E) = \\langle g_i \\rvert G_0(E) \\rvert g_j \\rangle = \\int \\frac{d^3p}{(2\\pi)^3} g_i(p) \\frac{1}{E - p^2 + i\\epsilon} g_j(p)\n$$\nUsing the specified $s$-wave measure $\\frac{1}{2\\pi^2} \\int_0^\\infty p^2 dp$ and $E=k^2$:\n$$\nI_{ij}(k^2) = \\frac{1}{2\\pi^2} \\int_0^\\infty dp \\, p^2 \\frac{g_i(p) g_j(p)}{k^2 - p^2 + i\\epsilon}\n$$\nUsing the Sokhotski-Plemelj theorem, $\\frac{1}{x+i\\epsilon} = \\mathcal{P}\\frac{1}{x} - i\\pi\\delta(x)$, we separate the real and imaginary parts.\n\nThe imaginary part is:\n$$\n\\mathrm{Im} \\, I_{ij}(k^2) = -\\frac{\\pi}{2\\pi^2} \\int_0^\\infty dp \\, p^2 g_i(p) g_j(p) \\delta(k^2-p^2)\n$$\nUsing $\\delta(k^2-p^2) = \\frac{1}{2k}\\delta(p-k)$ for $p, k > 0$:\n$$\n\\mathrm{Im} \\, I_{ij}(k^2) = -\\frac{1}{2\\pi} \\int_0^\\infty dp \\, p^2 g_i(p) g_j(p) \\frac{\\delta(p-k)}{2k} = -\\frac{k^2 g_i(k) g_j(k)}{4\\pi k} = -\\frac{k}{4\\pi} g_i(k) g_j(k)\n$$\n\nThe real part is a Cauchy Principal Value integral:\n$$\n\\mathrm{Re} \\, I_{ij}(k^2) = \\frac{1}{2\\pi^2} \\mathcal{P} \\int_0^\\infty dp \\, p^2 \\frac{g_i(p) g_j(p)}{k^2 - p^2}\n$$\nThis integral is numerically challenging due to the singularity at $p=k$. We regularize it by subtracting the singular behavior:\n$$\n\\mathcal{P} \\int_0^\\infty \\frac{F(p)}{k^2-p^2} dp = \\int_0^\\infty \\frac{F(p) - F(k)}{k^2-p^2} dp\n$$\nwhere $F(p) = p^2 g_i(p) g_j(p)$. The integrand is now well-behaved at $p=k$, and its value at this point is given by the limit:\n$$\n\\lim_{p \\to k} \\frac{F(p)-F(k)}{k^2-p^2} = \\lim_{p \\to k} \\frac{F(p)-F(k)}{-(p-k)(p+k)} = -\\frac{F'(k)}{2k}\n$$\nThe integral over the infinite domain $[0, \\infty)$ is handled numerically by `scipy.integrate.quad`, which employs robust quadrature schemes suitable for such improper integrals, effectively mapping the domain to a finite one. For the special case $k=0$, the integral is no longer a principal value and can be solved analytically:\n$$\n\\mathrm{Re} \\, I_{ij}(0) = -\\frac{1}{2\\pi^2} \\int_0^\\infty dp \\, g_i(p)g_j(p) = -\\frac{1}{4\\pi \\beta_i \\beta_j (\\beta_i + \\beta_j)}\n$$\nIf $\\beta_i = \\beta_j = \\beta$, this becomes $-\\frac{1}{8\\pi \\beta^3}$.\n\n### 4. Computational Strategy and Metric\n\nThe algorithm proceeds as follows for each test case:\n1.  For each momentum $k$ in the set $\\mathcal{K}$, the complex loop integrals $I_{UU}(k^2)$, $I_{WW}(k^2)$, and $I_{UW}(k^2)$ are computed numerically as described above. A helper function will handle the principal value integral by implementing the subtraction method and explicitly coding the integrand's limit at the singularity to ensure numerical stability.\n2.  Using these integrals and the form factors evaluated at $k$, the complex amplitudes $t_{\\mathrm{exact}}(k)$ and $t_{\\mathrm{DWBA}}(k)$ are calculated using their respective derived formulae.\n3.  The relative error $\\lvert t_{\\mathrm{DWBA}}(k) - t_{\\mathrm{exact}}(k) \\rvert / (\\lvert t_{\\mathrm{exact}}(k) \\rvert + \\epsilon)$ is computed for each $k$.\n4.  The regularization parameter $\\epsilon = 10^{-16}$ is introduced in the denominator. This value is on the order of machine precision for `float64` numbers and serves only to prevent division-by-zero errors if $t_{\\mathrm{exact}}(k)$ is numerically zero (a Ramsauer-Townsend-like zero), without biasing the metric otherwise.\n5.  The metric $M$ for the test case is the maximum of these relative errors over the set $\\mathcal{K}$.\nThe final output is a list of the $M$ values for the three test cases.", "answer": "```python\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Solves the scattering problem for the given test cases.\n\n    Derives and computes the exact and DWBA T-matrix elements for a rank-2\n    separable potential. It then calculates a metric of agreement between\n    the two approximations for three different parameter sets.\n    \"\"\"\n\n    # Epsilon for regularization of the metric's denominator\n    EPSILON = 1e-16\n\n    # Test cases: (lambda_U, beta_U, lambda_W, beta_W, k_values)\n    test_cases = [\n        (-1.0, 1.0, -0.2, 2.0, [0.05, 0.30, 0.80]),\n        (-1.0, 1.0, -0.2, 2.0, [0.001, 0.020, 0.050]),\n        (-1.0, 1.0, -0.8, 2.0, [0.05, 0.30, 0.80]),\n    ]\n\n    # Store a cache for loop integral calculations to avoid re-computation\n    # Key: (k, beta_i, beta_j)\n    loop_integral_cache = {}\n\n    def get_form_factor(p, beta):\n        \"\"\"Calculates the Yamaguchi form factor g(p).\"\"\"\n        return 1.0 / (p**2 + beta**2)\n\n    def calculate_loop_integral(k, beta_i, beta_j):\n        \"\"\"\n        Calculates the complex loop integral I_ij(k^2).\n        I_ij(E) = <g_i|G_0(E)|g_j>\n        \"\"\"\n        # Sort betas to ensure cache key uniqueness (since I_ij = I_ji)\n        b_i, b_j = min(beta_i, beta_j), max(beta_i, beta_j)\n        if (k, b_i, b_j) in loop_integral_cache:\n            return loop_integral_cache[(k, b_i, b_j)]\n\n        # Imaginary part (analytic)\n        im_part = -k / (4 * np.pi) * get_form_factor(k, beta_i) * get_form_factor(k, beta_j)\n\n        # Real part (principal value integral)\n        if k == 0.0:\n            if beta_i != beta_j:\n                re_part = -1.0 / (4 * np.pi * beta_i * beta_j * (beta_i + beta_j))\n            else: # beta_i == beta_j\n                re_part = -1.0 / (8 * np.pi * beta_i**3)\n        else:\n            # Integrand for the subtracted principal value integral\n            def pv_integrand(p):\n                # Numerically stable calculation of (F(p) - F(k)) / (k^2 - p^2)\n                # where F(p) = p^2 * g_i(p) * g_j(p)\n                \n                # Use a tolerance for floating point comparison\n                if abs(p - k) < 1e-9:\n                    # Limit of the integrand as p -> k, which is -F'(k)/(2k)\n                    p_sq = p**2\n                    gi = get_form_factor(p, beta_i)\n                    gj = get_form_factor(p, beta_j)\n                    \n                    term1 = 2 * p * gi * gj\n                    d_gi_dp = -2 * p * gi**2\n                    d_gj_dp = -2 * p * gj**2\n                    term2 = p_sq * (d_gi_dp * gj + gi * d_gj_dp)\n                    \n                    fp_prime_k = term1 + term2\n                    return -fp_prime_k / (2 * k)\n\n                p_sq = p**2\n                k_sq = k**2\n                F_p = p_sq * get_form_factor(p, beta_i) * get_form_factor(p, beta_j)\n                F_k = k_sq * get_form_factor(k, beta_i) * get_form_factor(k, beta_j)\n                return (F_p - F_k) / (k_sq - p_sq)\n\n            # Perform numerical integration\n            integral_val, _ = integrate.quad(pv_integrand, 0, np.inf, epsabs=1e-12, epsrel=1e-12)\n            re_part = integral_val / (2 * np.pi**2)\n        \n        result = re_part + 1j * im_part\n        loop_integral_cache[(k, b_i, b_j)] = result\n        return result\n\n    final_metrics = []\n    for case in test_cases:\n        lambda_U, beta_U, lambda_W, beta_W, k_values = case\n        \n        # Clear cache for each new parameter set\n        loop_integral_cache.clear()\n\n        ratios = []\n        for k in k_values:\n            g_U_k = get_form_factor(k, beta_U)\n            g_W_k = get_form_factor(k, beta_W)\n\n            I_UU = calculate_loop_integral(k, beta_U, beta_U)\n            I_WW = calculate_loop_integral(k, beta_W, beta_W)\n            I_UW = calculate_loop_integral(k, beta_U, beta_W)\n            \n            # --- Exact T-matrix calculation ---\n            D_exact = (1 - lambda_U * I_UU) * (1 - lambda_W * I_WW) - lambda_U * lambda_W * I_UW**2\n            num_exact = (lambda_U * (1 - lambda_W * I_WW) * g_U_k**2 +\n                         lambda_W * (1 - lambda_U * I_UU) * g_W_k**2 +\n                         2 * lambda_U * lambda_W * I_UW * g_U_k * g_W_k)\n            t_exact = num_exact / D_exact\n\n            # --- DWBA T-matrix calculation ---\n            D_U = 1 - lambda_U * I_UU\n            t_U = lambda_U * g_U_k**2 / D_U\n            \n            distorted_gW = g_W_k + (lambda_U * I_UW / D_U) * g_U_k\n            t_dwba = t_U + lambda_W * distorted_gW**2\n            \n            # --- Metric calculation ---\n            numerator = np.abs(t_dwba - t_exact)\n            denominator = np.abs(t_exact) + EPSILON\n            ratios.append(numerator / denominator)\n\n        final_metrics.append(np.max(ratios))\n        \n    # Format and print the final output\n    print(f\"[{','.join(f'{m:.8f}' for m in final_metrics)}]\")\n\nsolve()\n```", "id": "3598541"}, {"introduction": "The DWBA is a powerful tool for extracting nuclear structure information from experimental data, particularly for direct reactions that are peripheral, or localized to the nuclear surface. In such cases, the reaction is primarily sensitive to the long-range \"tail\" of the nucleon's bound-state wavefunction, whose magnitude is set by the Asymptotic Normalization Constant (ANC). This hands-on problem has you investigate this crucial concept by modeling a wavefunction with independent interior and asymptotic parts, allowing you to numerically demonstrate how forward-angle cross sections are governed by the ANC rather than the complex details of the nuclear interior [@problem_id:3598529].", "problem": "You will implement a computational model to analyze how the asymptotic normalization constant (ANC) of the bound-state wavefunction alters the distorted wave Born approximation (DWBA) transition amplitude and to demonstrate that angular distributions at forward angles are most sensitive to ANCs rather than to interior structure. The analysis must be carried out by deriving the governing integral from standard scattering theory and then evaluating it numerically for a physically reasonable one-dimensional radial model.\n\nStarting point and definitions: begin from the first Born approximation and the Distorted Wave Born Approximation (DWBA) statements in scattering theory. For a single-nucleon transfer reaction, the DWBA transition amplitude can be written as an integral over the radial coordinate, where the integrand consists of the product of the transition form factor, a bound-state radial wavefunction, and the overlap of initial and final distorted waves. In a plane-wave surrogate for the distorted waves, the angular dependence enters through the momentum transfer. Use the following model and definitions:\n\n- Let the DWBA amplitude be modeled as\n$$\nT_{fi}(\\theta) \\propto \\int_0^{\\infty} r^2\\, u_B(r)\\, f_{\\mathrm{WS}}(r;R_0,a_0)\\, j_0\\!\\big(q(\\theta)\\, r\\big)\\, \\mathrm{d}r,\n$$\nwhere $u_B(r)$ is the bound-state radial wavefunction, $f_{\\mathrm{WS}}(r;R_0,a_0)$ is a Woods–Saxon surface-localized form factor representing the transition potential and surface sensitivity, $j_0(x)$ is the spherical Bessel function of order $0$, and $q(\\theta)$ is the momentum transfer as a function of the scattering angle $\\theta$.\n\n- Define the Woods–Saxon form factor by\n$$\nf_{\\mathrm{WS}}(r;R_0,a_0) = \\frac{1}{1+\\exp\\!\\left(\\frac{r-R_0}{a_0}\\right)},\n$$\nwith parameters $R_0$ and $a_0$ specified below.\n\n- Model the bound-state radial wavefunction as a smooth sum of an interior component and an asymptotic tail weighted by the asymptotic normalization constant (ANC) $C$, switched by a smooth matching function,\n$$\nu_B(r) = u_{\\mathrm{int}}(r)\\,\\big(1-S(r;R_m,a_m)\\big) + C\\,e^{-\\kappa r}\\,S(r;R_m,a_m),\n$$\nwith interior component\n$$\nu_{\\mathrm{int}}(r) = N_{\\mathrm{int}}\\, r\\, e^{-r/R_{\\mathrm{int}}},\n$$\nand matching function\n$$\nS(r;R_m,a_m) = \\frac{1}{1+\\exp\\!\\left(\\frac{R_m - r}{a_m}\\right)}.\n$$\nHere $N_{\\mathrm{int}}$ scales the interior amplitude independently of the ANC $C$, $R_{\\mathrm{int}}$ sets the interior scale, and $(R_m,a_m)$ control where and how the tail switches on.\n\n- The separation energy $S_B$ for the bound state determines the tail inverse length scale\n$$\n\\kappa = \\frac{\\sqrt{2\\,\\mu_B\\, S_B}}{\\hbar c},\n$$\nwhere $\\mu_B$ is the reduced mass for the bound configuration and $\\hbar c$ is the usual constant.\n\n- The momentum transfer $q(\\theta)$ is computed from\n$$\nq(\\theta) = 2\\,k\\,\\sin\\!\\left(\\frac{\\theta}{2}\\right), \\quad\nk = \\frac{\\sqrt{2\\,\\mu\\,E}}{\\hbar c},\n$$\nwith $\\mu$ the reduced mass in the entrance channel and $E$ the laboratory kinetic energy of the projectile.\n\nUnits and constants:\n- Use $\\hbar c = 197.3269804$ in $\\mathrm{MeV\\cdot fm}$.\n- Use $\\mu = 469.459$ in $\\mathrm{MeV}$ for the entrance-channel reduced mass.\n- Use $\\mu_B = 469.459$ in $\\mathrm{MeV}$ for the bound-state reduced mass.\n- Use $E = 50.0$ in $\\mathrm{MeV}$.\n- Use $R_0 = 6.0$ in $\\mathrm{fm}$, $a_0 = 0.6$ in $\\mathrm{fm}$, $R_{\\mathrm{int}} = 2.0$ in $\\mathrm{fm}$, $R_m = 6.0$ in $\\mathrm{fm}$, and $a_m = 0.5$ in $\\mathrm{fm}$.\n- All distances $r$ must be in $\\mathrm{fm}$, angles $\\theta$ must be in radians, and energies must be in $\\mathrm{MeV}$.\n\nNumerical evaluation:\n- Evaluate the integral numerically on a uniform radial grid from $r=0$ to $r=r_{\\max}$ with $r_{\\max} = 30.0$ in $\\mathrm{fm}$ and a step size chosen to ensure convergence. Use a numerically stable method to integrate $r^2\\,u_B(r)\\, f_{\\mathrm{WS}}(r;R_0,a_0)\\, j_0(qr)$.\n\nSensitivity quantification:\n- For a given angle $\\theta$ and separation energy $S_B$, define the sensitivity to the ANC by computing the ratio\n$$\nR_C(\\theta;S_B) = \\frac{\\left|T_{fi}(\\theta;C_2)\\right|}{\\left|T_{fi}(\\theta;C_1)\\right|},\n$$\nfor two ANCs $C_2$ and $C_1$. Forward-angle sensitivity implies $R_C(\\theta)$ close to $C_2/C_1$ when $\\theta$ is small, whereas sensitivity diminishes at larger $\\theta$.\n- To contrast ANC with interior sensitivity, similarly define\n$$\nR_{\\mathrm{int}}(\\theta;S_B) = \\frac{\\left|T_{fi}(\\theta;N_{\\mathrm{int},2})\\right|}{\\left|T_{fi}(\\theta;N_{\\mathrm{int},1})\\right|},\n$$\nwith fixed $C$ and varying interior amplitude $N_{\\mathrm{int}}$.\n\nTest suite:\n- Compute the following five ratios with the parameters specified above, where $C_1$, $C_2$, $N_{\\mathrm{int},1}$, $N_{\\mathrm{int},2}$, and $S_B$ are given for each case. All angles are in radians, and results are dimensionless.\n    1. $R_C(\\theta;S_B)$ at $\\theta = 0.05$, $S_B = 1.0$, with $C_1 = 1.0$ and $C_2 = 1.5$.\n    2. $R_C(\\theta;S_B)$ at $\\theta = 0.7$, $S_B = 1.0$, with $C_1 = 1.0$ and $C_2 = 1.5$.\n    3. $R_C(\\theta;S_B)$ at $\\theta = 0.001$, $S_B = 1.0$, with $C_1 = 1.0$ and $C_2 = 1.5$.\n    4. $R_{\\mathrm{int}}(\\theta;S_B)$ at $\\theta = 0.05$, $S_B = 1.0$, with $C = 1.0$ fixed and $N_{\\mathrm{int},1} = 1.0$, $N_{\\mathrm{int},2} = 1.5$.\n    5. $R_C(\\theta;S_B)$ at $\\theta = 0.05$, $S_B = 0.2$, with $C_1 = 1.0$ and $C_2 = 1.5$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for the five test cases as a comma-separated list of floats rounded to $6$ decimal places and enclosed in square brackets, for example, $\\big[0.000000,0.000000,0.000000,0.000000,0.000000\\big]$.", "solution": "The problem has been validated and is deemed a well-posed, scientifically grounded exercise in computational nuclear physics. It accurately represents a simplified but physically meaningful model for studying single-nucleon transfer reactions within the distorted wave Born approximation (DWBA) framework. All necessary parameters, functions, and constants are provided, and the stated objective is to numerically verify a key tenet of reaction theory: the sensitivity of forward-angle cross sections to the asymptotic normalization constant (ANC) of the bound-state wavefunction.\n\nThe solution proceeds by developing a numerical implementation of the provided theoretical model. The core of the problem is the evaluation of the DWBA transition amplitude, $T_{fi}(\\theta)$, which is given by the integral:\n$$\nT_{fi}(\\theta) \\propto \\int_0^{\\infty} r^2\\, u_B(r)\\, f_{\\mathrm{WS}}(r;R_0,a_0)\\, j_0\\!\\big(q(\\theta)\\, r\\big)\\, \\mathrm{d}r\n$$\nThis integral represents the overlap between the initial and final states, mediated by a transition potential. In this model, the integrand is composed of four key components:\n\n1.  The phase space factor $r^2$.\n2.  The bound-state radial wavefunction $u_B(r)$. This function describes the spatial distribution of the transferred nucleon in its final bound state. It is modeled with an interior part and an asymptotic tail, governed by the ANC, $C$.\n3.  A surface-peaked transition form factor, $f_{\\mathrm{WS}}(r;R_0,a_0)$, represented by a Woods-Saxon function. This localizes the interaction to the nuclear surface, a common feature of direct reactions.\n4.  The distorted wave overlap, approximated here by the spherical Bessel function $j_0(q(\\theta)r)$. This term arises from a plane-wave approximation for the scattering states and introduces the dependence on the scattering angle $\\theta$ through the momentum transfer $q(\\theta)$.\n\nThe numerical evaluation of $T_{fi}(\\theta)$ is structured as follows:\n\nFirst, we define all physical constants and model parameters as specified. This includes the reduced masses $\\mu$ and $\\mu_B$, the kinetic energy $E$, the nuclear radii and diffuseness parameters ($R_0$, $a_0$, $R_{\\mathrm{int}}$, $R_m$, $a_m$), and the physical constant $\\hbar c$.\n\nSecond, we calculate the derived kinematic quantities that depend on the specific reaction conditions ($\\theta$, $S_B$).\n- The entrance-channel wave number, $k$, is computed from the projectile's kinetic energy $E$ and the reduced mass $\\mu$:\n  $$k = \\frac{\\sqrt{2\\,\\mu\\,E}}{\\hbar c}$$\n- The momentum transfer, $q(\\theta)$, is then calculated as a function of the scattering angle $\\theta$:\n  $$q(\\theta) = 2\\,k\\,\\sin\\!\\left(\\frac{\\theta}{2}\\right)$$\n- The decay constant of the bound-state tail, $\\kappa$, depends on the nucleon's separation energy $S_B$ and the bound-state reduced mass $\\mu_B$:\n  $$\\kappa = \\frac{\\sqrt{2\\,\\mu_B\\, S_B}}{\\hbar c}$$\n\nThird, we implement the functions that constitute the integrand.\n- The Woods-Saxon form factor $f_{\\mathrm{WS}}(r;R_0,a_0) = \\left(1+\\exp\\left(\\frac{r-R_0}{a_0}\\right)\\right)^{-1}$.\n- The bound-state wavefunction $u_B(r)$, assembled from its interior component $u_{\\mathrm{int}}(r) = N_{\\mathrm{int}}\\, r\\, e^{-r/R_{\\mathrm{int}}}$, its asymptotic tail $C\\,e^{-\\kappa r}$, and the smooth matching function $S(r;R_m,a_m) = \\left(1+\\exp\\left(\\frac{R_m - r}{a_m}\\right)\\right)^{-1}$.\n- The zeroth-order spherical Bessel function, $j_0(x) = \\frac{\\sin(x)}{x}$. A numerically stable implementation is used, which correctly evaluates to $1$ at $x=0$.\n\nFourth, we perform the numerical integration. The integral's infinite upper limit is replaced by a sufficiently large radius $r_{\\max} = 30.0\\,\\mathrm{fm}$, beyond which the integrand is negligible due to the exponential decay of both the bound-state wavefunction and the Woods-Saxon form factor. The radial coordinate $r$ is discretized on a uniform grid from $r=0$ to $r_{\\max}$ with a step size small enough to ensure numerical convergence. The integrand is evaluated at each point on this grid, and the definite integral is computed using the trapezoidal rule, a standard numerical quadrature method available in `NumPy`.\n\nFinally, to address the core question of sensitivity, we compute the ratios $R_C$ and $R_{\\mathrm{int}}$. For each of the five test cases, the transition amplitude $T_{fi}(\\theta)$ is calculated for two different parameter sets (e.g., with $C_1$ and $C_2$, or $N_{\\mathrm{int},1}$ and $N_{\\mathrm{int},2}$). The ratio of the absolute values of these amplitudes is then computed as specified:\n$$\nR_C(\\theta;S_B) = \\frac{\\left|T_{fi}(\\theta;C_2)\\right|}{\\left|T_{fi}(\\theta;C_1)\\right|} \\quad \\text{and} \\quad R_{\\mathrm{int}}(\\theta;S_B) = \\frac{\\left|T_{fi}(\\theta;N_{\\mathrm{int},2})\\right|}{\\left|T_{fi}(\\theta;N_{\\mathrm{int},1})\\right|}\n$$\nThe value of the proportionality constant in the definition of $T_{fi}(\\theta)$ is irrelevant as it cancels out in these ratios. For cases where a parameter is not explicitly varied (e.g., $N_{\\mathrm{int}}$ in an $R_C$ calculation), a default value of $1.0$ is used, as implied by the problem's structure. The resulting five ratios are then formatted and presented as the final answer. This procedure provides a direct, quantitative measure of how changes in the wavefunction's asymptotic tail versus its interior affect the reaction observable at different angles.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# This script implements a computational model for the distorted wave Born\n# approximation (DWBA) to analyze the sensitivity of the transition amplitude\n# to the asymptotic normalization constant (ANC) and interior part of a\n# bound-state wavefunction.\n\n# Define global constants and model parameters in a dictionary for clarity.\nPARAMS = {\n    'hbarc': 197.3269804,  # MeV*fm\n    'mu': 469.459,         # Entrance-channel reduced mass in MeV\n    'mu_B': 469.459,       # Bound-state reduced mass in MeV\n    'E': 50.0,             # Laboratory kinetic energy in MeV\n    'R0': 6.0,             # Woods-Saxon radius for form factor in fm\n    'a0': 0.6,             # Woods-Saxon diffuseness for form factor in fm\n    'R_int': 2.0,          # Scale of the interior wavefunction in fm\n    'R_m': 6.0,            # Matching radius in fm\n    'a_m': 0.5,            # Matching diffuseness in fm\n    'r_max': 30.0,         # Maximum integration radius in fm\n    'n_points': 4001,      # Number of points for the radial integration grid\n}\n\ndef woods_saxon(r, R, a):\n    \"\"\"\n    Calculates the Woods-Saxon function.\n    f(r; R, a) = 1 / (1 + exp((r - R) / a))\n    \"\"\"\n    return 1.0 / (1.0 + np.exp((r - R) / a))\n\ndef matching_function(r, R_m, a_m):\n    \"\"\"\n    Calculates the smooth matching (switch-on) function S.\n    S(r; R_m, a_m) = 1 / (1 + exp((R_m - r) / a_m))\n    \"\"\"\n    return 1.0 / (1.0 + np.exp((R_m - r) / a_m))\n\ndef u_interior(r, N_int, R_int):\n    \"\"\"\n    Calculates the interior component of the bound-state wavefunction.\n    u_int(r) = N_int * r * exp(-r / R_int)\n    \"\"\"\n    return N_int * r * np.exp(-r / R_int)\n\ndef u_bound(r, C, N_int, kappa):\n    \"\"\"\n    Calculates the full modeled bound-state radial wavefunction u_B(r).\n    u_B(r) = u_int(r)*(1-S(r)) + C*exp(-kappa*r)*S(r)\n    \"\"\"\n    u_int = u_interior(r, N_int, PARAMS['R_int'])\n    S = matching_function(r, PARAMS['R_m'], PARAMS['a_m'])\n    u_tail = C * np.exp(-kappa * r)\n    return u_int * (1.0 - S) + u_tail * S\n\ndef spherical_bessel_j0(x):\n    \"\"\"\n    Calculates the spherical Bessel function of order 0, j0(x) = sin(x)/x,\n    using a numerically stable method that handles x=0 correctly.\n    \"\"\"\n    # np.sinc(x/pi) is defined as sin(x)/x\n    return np.sinc(x / np.pi)\n\ndef calculate_T_fi(theta, S_B, C, N_int):\n    \"\"\"\n    Calculates the DWBA transition amplitude integral T_fi.\n\n    Args:\n        theta (float): Scattering angle in radians.\n        S_B (float): Separation energy in MeV.\n        C (float): Asymptotic normalization constant (ANC).\n        N_int (float): Amplitude of the interior wavefunction component.\n\n    Returns:\n        float: The value of the transition amplitude integral.\n    \"\"\"\n    # Calculate derived kinematic and bound-state parameters.\n    k = np.sqrt(2.0 * PARAMS['mu'] * PARAMS['E']) / PARAMS['hbarc']\n    kappa = np.sqrt(2.0 * PARAMS['mu_B'] * S_B) / PARAMS['hbarc']\n    q = 2.0 * k * np.sin(theta / 2.0)\n    \n    # Set up the radial grid for numerical integration.\n    r = np.linspace(0, PARAMS['r_max'], PARAMS['n_points'])\n    \n    # Calculate the components of the integrand on the grid.\n    u_b_r = u_bound(r, C, N_int, kappa)\n    f_ws_r = woods_saxon(r, PARAMS['R0'], PARAMS['a0'])\n    j0_qr = spherical_bessel_j0(q * r)\n    \n    # Form the full integrand: r^2 * u_B(r) * f_WS(r) * j0(q*r).\n    integrand = r**2 * u_b_r * f_ws_r * j0_qr\n    \n    # Perform numerical integration using the trapezoidal rule.\n    t_fi = np.trapz(integrand, r)\n    \n    return t_fi\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the five test cases from the problem statement.\n    # Each case is a dictionary specifying the parameters for the calculation.\n    test_cases = [\n        # 1. R_C at a small forward angle.\n        {'type': 'C', 'theta': 0.05, 'S_B': 1.0, 'val1': 1.0, 'val2': 1.5, 'fixed_param': 1.0},\n        # 2. R_C at a large angle.\n        {'type': 'C', 'theta': 0.7, 'S_B': 1.0, 'val1': 1.0, 'val2': 1.5, 'fixed_param': 1.0},\n        # 3. R_C at a very small (near-zero) forward angle.\n        {'type': 'C', 'theta': 0.001, 'S_B': 1.0, 'val1': 1.0, 'val2': 1.5, 'fixed_param': 1.0},\n        # 4. R_int at a small forward angle.\n        {'type': 'N_int', 'theta': 0.05, 'S_B': 1.0, 'val1': 1.0, 'val2': 1.5, 'fixed_param': 1.0},\n        # 5. R_C for a more weakly bound state (smaller S_B).\n        {'type': 'C', 'theta': 0.05, 'S_B': 0.2, 'val1': 1.0, 'val2': 1.5, 'fixed_param': 1.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'C':\n            # Vary ANC C, keep N_int fixed.\n            C1, C2 = case['val1'], case['val2']\n            N_int = case['fixed_param']\n            T_fi_1 = calculate_T_fi(case['theta'], case['S_B'], C1, N_int)\n            T_fi_2 = calculate_T_fi(case['theta'], case['S_B'], C2, N_int)\n        elif case['type'] == 'N_int':\n            # Vary interior amplitude N_int, keep C fixed.\n            N_int1, N_int2 = case['val1'], case['val2']\n            C = case['fixed_param']\n            T_fi_1 = calculate_T_fi(case['theta'], case['S_B'], C, N_int1)\n            T_fi_2 = calculate_T_fi(case['theta'], case['S_B'], C, N_int2)\n        \n        # Calculate the ratio of the absolute values of the amplitudes.\n        ratio = np.abs(T_fi_2) / np.abs(T_fi_1)\n        results.append(ratio)\n        \n    # Format and print the final output as a single-line comma-separated list.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\n# Execute the solver.\nsolve()\n\n```", "id": "3598529"}, {"introduction": "Practical implementation of scattering theories like DWBA almost always involves a partial-wave expansion, decomposing the problem into contributions from different orbital angular momenta, $\\ell$. Since this is an infinite series, it must be truncated at a maximum value $\\ell_{\\max}$ for numerical computation. This exercise tackles the essential task of ensuring convergence by having you develop and test a quantitative heuristic to automatically determine the optimal cutoff $\\ell_{\\max}$, a vital skill for writing efficient and accurate nuclear reaction codes [@problem_id:3598571].", "problem": "Consider a computational study of the convergence of the partial-wave expansion for the Distorted Wave Born Approximation (DWBA) transition amplitude. The starting point is the standard partial-wave decomposition for a transition amplitude expressed as a sum over orbital angular momentum quantum number $\\ell$, constructed on the basis of the time-independent Schrödinger equation and the superposition of angular momentum eigenstates. To make the problem self-contained and numerically stable, work with the following surrogate DWBA model for the partial-wave coefficients:\n$$\nt_\\ell = i^\\ell \\, j_\\ell(q a)\\,\\big(e^{i\\,\\delta_\\ell} - 1\\big),\n$$\nwhere $j_\\ell$ is the spherical Bessel function of the first kind, $q a$ is a dimensionless momentum-transfer–radius product, and $\\delta_\\ell$ is a model nuclear phase shift that decays for large $\\ell$ due to the short range of the interaction. The truncated transition amplitude at $\\ell_{\\max}$ is\n$$\nT_{fi}^{(\\ell_{\\max})} = \\sum_{\\ell=0}^{\\ell_{\\max}} (2\\ell+1)\\,t_\\ell.\n$$\nAssume the phase shift has the form\n$$\n\\delta_\\ell = \\delta_0 \\exp\\!\\left(-\\left(\\frac{\\ell}{\\ell_0}\\right)^p\\right),\n$$\nwith constants $\\delta_0$, $\\ell_0$, and $p$ chosen to represent different light and heavy target scenarios. In this surrogate, the envelope $j_\\ell(q a)$ captures the angular-momentum selectivity from the finite-range transition form factor, while the factor $e^{i\\,\\delta_\\ell} - 1$ ensures that the contribution decays when $\\delta_\\ell \\to 0$, consistent with the physical expectation that high-$\\ell$ waves feel negligible nuclear distortion.\n\nYour task is to design and implement a quantitative heuristic to choose the smallest $\\ell_{\\max}$ that guarantees a specified relative accuracy $\\varepsilon$ on the complex amplitude, using only the asymptotic decay behavior of $\\delta_\\ell$ and the computed magnitudes of the successive partial-wave contributions. Specifically:\n\n- Define the magnitude of the $\\ell$th contribution as\n$$\na_\\ell = (2\\ell+1)\\,\\big|t_\\ell\\big| = (2\\ell+1)\\,\\big|j_\\ell(q a)\\big|\\,\\big|e^{i\\,\\delta_\\ell} - 1\\big|.\n$$\n- Use a rolling geometric tail heuristic based on $a_\\ell$ to estimate the remainder. Let $r_\\ell = a_\\ell/\\max(a_{\\ell-1},\\eta)$ with a small stabilizer $\\eta$, and define a rolling window average of the most recent $w$ ratios, denoted $\\bar r_\\ell$. Starting from $\\ell \\ge \\lceil q a \\rceil$, wait until $\\bar r_\\ell \\le r_{\\mathrm{trig}}$ to declare that the tail is approximately geometric. Then estimate the tail magnitude by \n$$\nR_{\\mathrm{est}}(\\ell) = \\frac{a_\\ell \\,\\bar r_\\ell}{1-\\bar r_\\ell}.\n$$\nTerminate at the smallest $\\ell_{\\max}$ such that\n$$\nR_{\\mathrm{est}}(\\ell_{\\max}) \\le \\varepsilon \\,\\max\\!\\left(\\big|T_{fi}^{(\\ell_{\\max})}\\big|, A_{\\mathrm{floor}}\\right).\n$$\nHere $\\varepsilon$ is the target relative tolerance, and $A_{\\mathrm{floor}}$ prevents premature termination when $\\big|T_{fi}^{(\\ell)}\\big|$ is accidentally small due to cancellations. Use $w = 3$, $r_{\\mathrm{trig}} = 0.9$, $\\eta = 10^{-30}$, and $A_{\\mathrm{floor}} = 10^{-12}$.\n\n- For validation, compute a high-accuracy reference using $\\ell_{\\mathrm{full}} = 400$:\n$$\nT_{fi}^{(\\ell_{\\mathrm{full}})} = \\sum_{\\ell=0}^{\\ell_{\\mathrm{full}}} (2\\ell+1)\\,t_\\ell,\n$$\nand report the achieved relative error\n$$\n\\mathrm{err} = \\frac{\\big|T_{fi}^{(\\ell_{\\mathrm{full}})} - T_{fi}^{(\\ell_{\\max})}\\big|}{\\big|T_{fi}^{(\\ell_{\\mathrm{full}})}\\big|}.\n$$\n\nImplement the above for the following test suite of parameter sets $\\{(\\delta_0, \\ell_0, p, q a, \\varepsilon)\\}$, designed to probe light versus heavy targets, small versus large momentum transfer, and slowly versus rapidly decaying phase-shift tails:\n\n- Case $\\#1$ (light, moderate range): $(\\delta_0, \\ell_0, p, q a, \\varepsilon) = (0.6, 3.0, 2.0, 4.0, 10^{-7})$.\n- Case $\\#2$ (heavy, slower decay): $(\\delta_0, \\ell_0, p, q a, \\varepsilon) = (2.0, 15.0, 1.0, 14.0, 10^{-6})$.\n- Case $\\#3$ (very low momentum transfer): $(\\delta_0, \\ell_0, p, q a, \\varepsilon) = (0.4, 2.0, 2.0, 0.5, 10^{-9})$.\n- Case $\\#4$ (broad tail, challenging): $(\\delta_0, \\ell_0, p, q a, \\varepsilon) = (3.0, 25.0, 0.7, 20.0, 2\\times 10^{-6})$.\n\nAll quantities in this problem are dimensionless. Angles are in radians. There are no physical units to report.\n\nYour program must:\n- Implement the above surrogate model and heuristic selection of $\\ell_{\\max}$.\n- For each case, compute the integer $\\ell_{\\max}$ returned by the heuristic and the achieved relative error $\\mathrm{err}$ using the $\\ell_{\\mathrm{full}}$ reference. Also compute a boolean flag that is true if $\\mathrm{err} \\le \\varepsilon$ and false otherwise.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each case is reported as a list of the form $[\\ell_{\\max}, \\mathrm{err}, \\mathrm{ok}]$. The float $\\mathrm{err}$ must be rounded to $6$ decimal places. For example: $[[12,0.000123,True],[\\dots]]$.", "solution": "The problem statement has been validated as scientifically grounded, well-posed, and objective. It outlines a detailed computational task within the domain of nuclear physics, providing a self-contained surrogate model and a clear, deterministic heuristic for numerical convergence. All required parameters, constants, and validation metrics are explicitly defined. No contradictions, ambiguities, or factual unsoundness are present. The problem is a valid exercise in computational science.\n\nThe overall objective is to determine a suitable cutoff, $\\ell_{\\max}$, for a partial-wave series, which is a common task in quantum scattering calculations. The partial-wave series for the transition amplitude, truncated at $\\ell_{\\max}$, is given by\n$$\nT_{fi}^{(\\ell_{\\max})} = \\sum_{\\ell=0}^{\\ell_{\\max}} (2\\ell+1)\\,t_\\ell\n$$\nThe problem provides a surrogate model for the partial-wave coefficients $t_\\ell$, which depend on the orbital angular momentum quantum number $\\ell$. This model is\n$$\nt_\\ell = i^\\ell \\, j_\\ell(q a)\\,\\big(e^{i\\,\\delta_\\ell} - 1\\big)\n$$\nHere, $i^\\ell$ is the complex phase factor, $j_\\ell(q a)$ is the spherical Bessel function of the first kind evaluated at the dimensionless argument $q a$, and $\\delta_\\ell$ is a model for the nuclear phase shift. The phase shift itself is given by a generalized exponential decay model:\n$$\n\\delta_\\ell = \\delta_0 \\exp\\!\\left(-\\left(\\frac{\\ell}{\\ell_0}\\right)^p\\right)\n$$\nThis form ensures that for large $\\ell$, $\\delta_\\ell \\to 0$, causing $t_\\ell \\to 0$ and ensuring the convergence of the series. The algorithm's goal is to find the smallest $\\ell_{\\max}$ that satisfies a given relative tolerance $\\varepsilon$.\n\nThe core of the task is to implement a specific heuristic algorithm to find $\\ell_{\\max}$. This algorithm relies on the asymptotic behavior of the series terms. We first define the magnitude of the $\\ell$-th contribution to the sum as\n$$\na_\\ell = (2\\ell+1)\\,\\big|t_\\ell\\big| = (2\\ell+1)\\,\\big|j_\\ell(q a)\\big|\\,\\big|e^{i\\,\\delta_\\ell} - 1\\big|\n$$\nThe heuristic tracks the ratio of successive term magnitudes, $r_\\ell = a_\\ell / \\max(a_{\\ell-1}, \\eta)$, where $\\eta$ is a small regularization constant to prevent division by zero. A rolling average of these ratios, $\\bar{r}_\\ell$, is maintained over a window of size $w=3$.\n\nThe search for $\\ell_{\\max}$ proceeds as follows:\n1.  The partial-wave sum $T_{fi}^{(\\ell)}$ and the magnitudes $a_\\ell$ are computed iteratively, increasing $\\ell$ from $0$.\n2.  The algorithm waits for $\\ell$ to become sufficiently large, specifically $\\ell \\ge \\lceil qa \\rceil$, before it begins checking for tail behavior. This is physically motivated, as the behavior of $j_\\ell(x)$ changes significantly around $\\ell \\approx x$.\n3.  Once in this asymptotic region, the algorithm waits for the rolling ratio average to fall below a threshold: $\\bar{r}_\\ell \\le r_{\\mathrm{trig}}$, with $r_{\\mathrm{trig}} = 0.9$. This signals that the tail of the series is behaving like a geometric series with a common ratio less than $1$.\n4.  Once this \"tail trigger\" is activated, the algorithm estimates the magnitude of the remainder of the series (the \"tail\") using the formula for the sum of a geometric series:\n$$\nR_{\\mathrm{est}}(\\ell) = a_\\ell + a_{\\ell+1} + \\dots \\approx a_\\ell \\sum_{k=0}^\\infty (\\bar{r}_\\ell)^k = \\frac{a_\\ell}{1-\\bar{r}_\\ell}\n$$\nThe problem statement uses a slight variation, $R_{\\mathrm{est}}(\\ell) = \\frac{a_\\ell \\,\\bar r_\\ell}{1-\\bar r_\\ell}$, which estimates the sum from term $\\ell+1$ onward. This is the magnitude of the truncation error.\n5.  The iteration terminates at the first $\\ell$ (which we call $\\ell_{\\max}$) for which this estimated error is smaller than the target tolerance $\\varepsilon$ relative to the magnitude of the current partial sum. A floor value $A_{\\mathrm{floor}}$ is used to prevent premature termination if the partial sum happens to be near zero due to destructive interference. The condition is:\n$$\nR_{\\mathrm{est}}(\\ell_{\\max}) \\le \\varepsilon \\,\\max\\!\\left(\\big|T_{fi}^{(\\ell_{\\max})}\\big|, A_{\\mathrm{floor}}\\right)\n$$\nUpon finding $\\ell_{\\max}$, we validate the effectiveness of this heuristic. A high-precision reference amplitude $T_{fi}^{(\\ell_{\\mathrm{full}})}$ is computed using a large, fixed cutoff $\\ell_{\\mathrm{full}} = 400$. The achieved relative error is then calculated as:\n$$\n\\mathrm{err} = \\frac{\\big|T_{fi}^{(\\ell_{\\mathrm{full}})} - T_{fi}^{(\\ell_{\\max})}\\big|}{\\big|T_{fi}^{(\\ell_{\\mathrm{full}})}\\big|}\n$$\nFinally, we check if this achieved error meets the target tolerance, i.e., if $\\mathrm{err} \\le \\varepsilon$.\n\nThe implementation will be carried out in Python, utilizing the `numpy` library for efficient handling of complex numbers and arrays, and the `scipy.special.spherical_jn` function to compute the spherical Bessel functions. For each test case, we pre-compute all terms up to $\\ell_{\\mathrm{full}}$ to streamline the subsequent heuristic search and reference calculation.", "answer": "```python\nimport numpy as np\nfrom scipy.special import spherical_jn\n\ndef solve():\n    \"\"\"\n    Implements the DWBA surrogate model and the heuristic for selecting l_max,\n    and validates it against a high-precision reference calculation.\n    \"\"\"\n    test_cases = [\n        # (delta0, l0, p, qa, eps)\n        (0.6, 3.0, 2.0, 4.0, 1e-7),      # Case #1\n        (2.0, 15.0, 1.0, 14.0, 1e-6),     # Case #2\n        (0.4, 2.0, 2.0, 0.5, 1e-9),      # Case #3\n        (3.0, 25.0, 0.7, 20.0, 2e-6),    # Case #4\n    ]\n\n    # Heuristic constants\n    w = 3\n    r_trig = 0.9\n    eta = 1e-30\n    A_floor = 1e-12\n    l_full = 400\n\n    results = []\n\n    for case in test_cases:\n        delta0, l0, p, qa, eps = case\n        \n        # --- 1. Pre-computation of all terms up to l_full ---\n        l_vals = np.arange(l_full + 1)\n\n        # Phase shifts delta_l\n        delta_l = delta0 * np.exp(-((l_vals / l0)**p))\n\n        # Spherical Bessel functions j_l(qa)\n        # scipy.special.spherical_jn(n, z) computes for n=0, 1, ..., max(n)\n        j_l_qa = spherical_jn(l_vals, qa)\n\n        # Complex phase factor i^l\n        i_power_l = 1j**l_vals\n\n        # Partial-wave coefficients t_l\n        t_l = i_power_l * j_l_qa * (np.exp(1j * delta_l) - 1)\n\n        # Full terms of the summation (2l+1)*t_l\n        full_terms = (2 * l_vals + 1) * t_l\n        \n        # Magnitudes a_l = |(2l+1)*t_l|\n        a_l_vals = np.abs(full_terms)\n\n        # --- 2. High-accuracy reference calculation ---\n        T_fi_full = np.sum(full_terms)\n\n        # --- 3. Iterative search for l_max using the heuristic ---\n        l_max = -1  # Sentinel value\n        T_fi_current = 0.0 + 0.0j\n        ratios_window = []\n        tail_triggered = False\n        l_start_check = int(np.ceil(qa))\n\n        # The loop runs up to l_full. If the condition is not met, l_max will remain -1,\n        # indicating failure to converge within the l_full limit.\n        for l in range(l_full + 1):\n            T_fi_current += full_terms[l]\n\n            if l == 0:\n                continue\n\n            r_l = a_l_vals[l] / np.maximum(a_l_vals[l - 1], eta)\n            ratios_window.append(r_l)\n            if len(ratios_window) > w:\n                ratios_window.pop(0)\n\n            if len(ratios_window) == w:\n                r_bar = np.mean(ratios_window)\n                \n                # Check for tail trigger condition\n                if l >= l_start_check and not tail_triggered:\n                    if r_bar <= r_trig:\n                        tail_triggered = True\n\n                # If triggered, check for termination\n                if tail_triggered:\n                    # The denominator is safe because r_bar <= r_trig = 0.9\n                    R_est = (a_l_vals[l] * r_bar) / (1 - r_bar)\n                    \n                    threshold = eps * np.maximum(np.abs(T_fi_current), A_floor)\n\n                    if R_est <= threshold:\n                        l_max = l\n                        break\n        \n        if l_max == -1: # Fallback if convergence not found\n            l_max = l_full\n\n        # --- 4. Validation ---\n        T_fi_lmax = np.sum(full_terms[:l_max + 1])\n        \n        # Avoid division by zero if reference amplitude is zero\n        if np.abs(T_fi_full) > eta:\n            err = np.abs(T_fi_full - T_fi_lmax) / np.abs(T_fi_full)\n        else:\n            # If reference is zero, error is just the magnitude of the difference\n            err = np.abs(T_fi_full - T_fi_lmax)\n\n        ok = err <= eps\n        \n        results.append([l_max, round(err, 6), bool(ok)])\n\n    # --- 5. Final Output Formatting ---\n    # The str() representation of a list is '[...]' and of a bool is 'True'/'False',\n    # which matches the required output format.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3598571"}]}